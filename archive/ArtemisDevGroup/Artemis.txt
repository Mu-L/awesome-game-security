Project Path: arc_ArtemisDevGroup_Artemis_ixhxinwq

Source Tree:

```txt
arc_ArtemisDevGroup_Artemis_ixhxinwq
├── Artemis
│   ├── Artemis.vcxproj
│   ├── Artemis.vcxproj.filters
│   ├── Aurora
│   │   ├── Array.h
│   │   ├── Binary.h
│   │   ├── CodeInjection.h
│   │   ├── Color.h
│   │   ├── Console.h
│   │   ├── ConstexprMath.h
│   │   ├── Definitions.h
│   │   ├── DllInjection.h
│   │   ├── Events.h
│   │   ├── Exceptions.h
│   │   ├── FileSystem.h
│   │   ├── HDE
│   │   │   ├── hde32.h
│   │   │   └── hde64.h
│   │   ├── Logger.h
│   │   ├── Memory.h
│   │   ├── MemoryTypes.h
│   │   ├── MemoryWin32.h
│   │   ├── Pipe.h
│   │   ├── ProcessInfo.h
│   │   ├── Property.h
│   │   ├── Shapes.h
│   │   ├── SharedHandle.h
│   │   ├── Signal.h
│   │   ├── Thread.h
│   │   ├── Time.h
│   │   ├── Trampoline.h
│   │   └── Vector.h
│   ├── Constants.h
│   ├── Definitions.h
│   ├── DrawManager.cpp
│   ├── DrawManager.h
│   ├── EventEntries.cpp
│   ├── EventEntries.h
│   ├── EventManager.cpp
│   ├── EventManager.h
│   ├── Events.cpp
│   ├── Events.h
│   ├── ExtensionManager.cpp
│   ├── ExtensionManager.h
│   ├── External.cpp
│   ├── External.h
│   ├── GameManager.cpp
│   ├── GameManager.h
│   ├── ImGui
│   │   ├── imconfig.h
│   │   ├── imgui.h
│   │   ├── imgui_impl_dx11.h
│   │   ├── imgui_impl_win32.h
│   │   ├── imgui_internal.h
│   │   ├── imstb_rectpack.h
│   │   ├── imstb_textedit.h
│   │   └── imstb_truetype.h
│   ├── KeybindManager.cpp
│   ├── KeybindManager.h
│   ├── Keybinds.cpp
│   ├── Keybinds.h
│   ├── Libraries
│   │   ├── DebugLib
│   │   │   ├── Aurora.dll
│   │   │   ├── Aurora.exp
│   │   │   ├── Aurora.lib
│   │   │   ├── Aurora.pdb
│   │   │   ├── ImGui.dll
│   │   │   ├── ImGui.exp
│   │   │   ├── ImGui.lib
│   │   │   ├── ImGui.pdb
│   │   │   ├── MinHook.dll
│   │   │   ├── MinHook.exp
│   │   │   ├── MinHook.lib
│   │   │   └── MinHook.pdb
│   │   └── ReleaseLib
│   │       ├── Aurora.dll
│   │       ├── Aurora.exp
│   │       ├── Aurora.lib
│   │       ├── Aurora.pdb
│   │       ├── ImGui.dll
│   │       ├── ImGui.exp
│   │       ├── ImGui.lib
│   │       ├── ImGui.pdb
│   │       ├── MinHook.dll
│   │       ├── MinHook.exp
│   │       ├── MinHook.lib
│   │       └── MinHook.pdb
│   ├── Manager.cpp
│   ├── Manager.h
│   ├── MinHook
│   │   └── MinHook.h
│   ├── PresentHook.cpp
│   ├── PresentHook.h
│   ├── WindowManager.cpp
│   ├── WindowManager.h
│   ├── Windows.cpp
│   ├── Windows.h
│   ├── dllmain.cpp
│   ├── pch.cpp
│   └── pch.h
├── Artemis.sln
├── LICENSE.md
└── README.md

```

`Artemis.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.2.32630.192
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Artemis", "Artemis\Artemis.vcxproj", "{4E99BAED-17C5-4495-9F7F-C747E38A1D74}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{4E99BAED-17C5-4495-9F7F-C747E38A1D74}.Debug|x64.ActiveCfg = Debug|x64
		{4E99BAED-17C5-4495-9F7F-C747E38A1D74}.Debug|x64.Build.0 = Debug|x64
		{4E99BAED-17C5-4495-9F7F-C747E38A1D74}.Debug|x86.ActiveCfg = Debug|Win32
		{4E99BAED-17C5-4495-9F7F-C747E38A1D74}.Debug|x86.Build.0 = Debug|Win32
		{4E99BAED-17C5-4495-9F7F-C747E38A1D74}.Release|x64.ActiveCfg = Release|x64
		{4E99BAED-17C5-4495-9F7F-C747E38A1D74}.Release|x64.Build.0 = Release|x64
		{4E99BAED-17C5-4495-9F7F-C747E38A1D74}.Release|x86.ActiveCfg = Release|Win32
		{4E99BAED-17C5-4495-9F7F-C747E38A1D74}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {D1589DDE-EB04-4F85-BF0E-91B4966F9A33}
	EndGlobalSection
EndGlobal

```

`Artemis/Artemis.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{4e99baed-17c5-4495-9f7f-c747e38a1d74}</ProjectGuid>
    <RootNamespace>Artemis</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ExternalIncludePath>$(SolutionDir)Artemis;$(ExternalIncludePath)</ExternalIncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ExternalIncludePath>$(SolutionDir)Artemis;$(ExternalIncludePath)</ExternalIncludePath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;ARTEMIS_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;ARTEMIS_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_ARTEMIS_EXPORT;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp20</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
      <AdditionalDependencies>$(ProjectDir)Libraries\DebugLib\Aurora.lib;$(ProjectDir)Libraries\DebugLib\ImGui.lib;$(ProjectDir)Libraries\DebugLib\MinHook.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_ARTEMIS_EXPORT;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp20</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
      <AdditionalDependencies>$(ProjectDir)Libraries\ReleaseLib\Aurora.lib;$(ProjectDir)Libraries\ReleaseLib\ImGui.lib;$(ProjectDir)Libraries\ReleaseLib\MinHook.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="Aurora\Array.h" />
    <ClInclude Include="Aurora\Binary.h" />
    <ClInclude Include="Aurora\CodeInjection.h" />
    <ClInclude Include="Aurora\Color.h" />
    <ClInclude Include="Aurora\Console.h" />
    <ClInclude Include="Aurora\ConstexprMath.h" />
    <ClInclude Include="Aurora\Definitions.h" />
    <ClInclude Include="Aurora\DllInjection.h" />
    <ClInclude Include="Aurora\Events.h" />
    <ClInclude Include="Aurora\Exceptions.h" />
    <ClInclude Include="Aurora\FileSystem.h" />
    <ClInclude Include="Aurora\HDE\hde32.h" />
    <ClInclude Include="Aurora\HDE\hde64.h" />
    <ClInclude Include="Aurora\Logger.h" />
    <ClInclude Include="Aurora\Memory.h" />
    <ClInclude Include="Aurora\MemoryTypes.h" />
    <ClInclude Include="Aurora\MemoryWin32.h" />
    <ClInclude Include="Aurora\Pipe.h" />
    <ClInclude Include="Aurora\ProcessInfo.h" />
    <ClInclude Include="Aurora\Property.h" />
    <ClInclude Include="Aurora\Shapes.h" />
    <ClInclude Include="Aurora\SharedHandle.h" />
    <ClInclude Include="Aurora\Signal.h" />
    <ClInclude Include="Aurora\Thread.h" />
    <ClInclude Include="Aurora\Time.h" />
    <ClInclude Include="Aurora\Trampoline.h" />
    <ClInclude Include="Aurora\Vector.h" />
    <ClInclude Include="Constants.h" />
    <ClInclude Include="Definitions.h" />
    <ClInclude Include="DrawManager.h" />
    <ClInclude Include="EventEntries.h" />
    <ClInclude Include="EventManager.h" />
    <ClInclude Include="Events.h" />
    <ClInclude Include="ExtensionManager.h" />
    <ClInclude Include="External.h" />
    <ClInclude Include="GameManager.h" />
    <ClInclude Include="ImGui\imconfig.h" />
    <ClInclude Include="ImGui\imgui.h" />
    <ClInclude Include="ImGui\imgui_impl_dx11.h" />
    <ClInclude Include="ImGui\imgui_impl_win32.h" />
    <ClInclude Include="ImGui\imgui_internal.h" />
    <ClInclude Include="ImGui\imstb_rectpack.h" />
    <ClInclude Include="ImGui\imstb_textedit.h" />
    <ClInclude Include="KeybindManager.h" />
    <ClInclude Include="Keybinds.h" />
    <ClInclude Include="Manager.h" />
    <ClInclude Include="MinHook\MinHook.h" />
    <ClInclude Include="pch.h" />
    <ClInclude Include="PresentHook.h" />
    <ClInclude Include="WindowManager.h" />
    <ClInclude Include="Windows.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="dllmain.cpp" />
    <ClCompile Include="DrawManager.cpp" />
    <ClCompile Include="EventEntries.cpp" />
    <ClCompile Include="EventManager.cpp" />
    <ClCompile Include="Events.cpp" />
    <ClCompile Include="ExtensionManager.cpp" />
    <ClCompile Include="External.cpp" />
    <ClCompile Include="GameManager.cpp" />
    <ClCompile Include="KeybindManager.cpp" />
    <ClCompile Include="Keybinds.cpp" />
    <ClCompile Include="Manager.cpp" />
    <ClCompile Include="pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="PresentHook.cpp" />
    <ClCompile Include="WindowManager.cpp" />
    <ClCompile Include="Windows.cpp" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Libraries\DebugLib\Aurora.dll" />
    <None Include="Libraries\DebugLib\Aurora.exp" />
    <None Include="Libraries\DebugLib\Aurora.pdb" />
    <None Include="Libraries\DebugLib\ImGui.dll" />
    <None Include="Libraries\DebugLib\ImGui.exp" />
    <None Include="Libraries\DebugLib\ImGui.pdb" />
    <None Include="Libraries\DebugLib\MinHook.dll" />
    <None Include="Libraries\DebugLib\MinHook.exp" />
    <None Include="Libraries\DebugLib\MinHook.pdb" />
    <None Include="Libraries\ReleaseLib\Aurora.dll" />
    <None Include="Libraries\ReleaseLib\Aurora.exp" />
    <None Include="Libraries\ReleaseLib\Aurora.pdb" />
    <None Include="Libraries\ReleaseLib\ImGui.dll" />
    <None Include="Libraries\ReleaseLib\ImGui.exp" />
    <None Include="Libraries\ReleaseLib\ImGui.pdb" />
    <None Include="Libraries\ReleaseLib\MinHook.dll" />
    <None Include="Libraries\ReleaseLib\MinHook.exp" />
    <None Include="Libraries\ReleaseLib\MinHook.pdb" />
  </ItemGroup>
  <ItemGroup>
    <Library Include="Libraries\DebugLib\Aurora.lib" />
    <Library Include="Libraries\DebugLib\ImGui.lib" />
    <Library Include="Libraries\DebugLib\MinHook.lib" />
    <Library Include="Libraries\ReleaseLib\Aurora.lib" />
    <Library Include="Libraries\ReleaseLib\ImGui.lib" />
    <Library Include="Libraries\ReleaseLib\MinHook.lib" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Artemis/Artemis.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Framework">
      <UniqueIdentifier>{05f01d7e-3ec5-4d6a-887f-71baaab7f965}</UniqueIdentifier>
    </Filter>
    <Filter Include="Framework\Header Files">
      <UniqueIdentifier>{3e47c69a-a55a-41ed-8a38-7407fa2737a0}</UniqueIdentifier>
    </Filter>
    <Filter Include="Framework\Source Files">
      <UniqueIdentifier>{76645fc5-3c3b-43c2-9962-5286bee8a548}</UniqueIdentifier>
    </Filter>
    <Filter Include="Libraries">
      <UniqueIdentifier>{4e0a213f-a948-4c47-87c4-835b8950389d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Libraries\x64/Debug">
      <UniqueIdentifier>{b24dab28-5e62-495f-a73e-8a3d0079286a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Libraries\x64/Release">
      <UniqueIdentifier>{7d1b7bc4-ed95-4dfe-ba02-d2ad08d6e3ed}</UniqueIdentifier>
    </Filter>
    <Filter Include="Libraries\x64/Release\Aurora">
      <UniqueIdentifier>{9531e6d0-6c82-44f5-a51e-63150f203982}</UniqueIdentifier>
    </Filter>
    <Filter Include="Libraries\x64/Release\ImGui">
      <UniqueIdentifier>{3032bb7d-3e70-4294-b598-b5506712fd6d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Libraries\x64/Debug\Aurora">
      <UniqueIdentifier>{8e7e5c36-0bb7-4c5f-95a8-02f739635f7d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Libraries\x64/Debug\ImGui">
      <UniqueIdentifier>{910edb44-9264-40bd-a46a-d5da601acbe2}</UniqueIdentifier>
    </Filter>
    <Filter Include="Libraries\Includes">
      <UniqueIdentifier>{008befab-af06-4c95-8618-3e835def74ae}</UniqueIdentifier>
    </Filter>
    <Filter Include="Libraries\Includes\Aurora">
      <UniqueIdentifier>{f2d85015-87eb-4f3a-89e8-7e0a84b9adc4}</UniqueIdentifier>
    </Filter>
    <Filter Include="Libraries\Includes\Aurora\HDE">
      <UniqueIdentifier>{0eb13b2e-075a-4fdd-a703-7f070bcf1157}</UniqueIdentifier>
    </Filter>
    <Filter Include="Libraries\Includes\ImGui">
      <UniqueIdentifier>{71c07986-5de6-4029-ba99-ef08d5250579}</UniqueIdentifier>
    </Filter>
    <Filter Include="Libraries\Includes\MinHook">
      <UniqueIdentifier>{3c8db166-f2e4-4a00-980c-9a708fd43655}</UniqueIdentifier>
    </Filter>
    <Filter Include="Libraries\x64/Release\MinHook">
      <UniqueIdentifier>{2f757fc2-7978-4b5d-bdff-846dc5b5de42}</UniqueIdentifier>
    </Filter>
    <Filter Include="Libraries\x64/Debug\MinHook">
      <UniqueIdentifier>{ea10082e-6a29-41aa-a6c4-c02e2c7b84ba}</UniqueIdentifier>
    </Filter>
    <Filter Include="Framework\Engine">
      <UniqueIdentifier>{e6aebec5-06ae-4798-a02d-7362c4e70efe}</UniqueIdentifier>
    </Filter>
    <Filter Include="Framework\Engine\Header Files">
      <UniqueIdentifier>{6777cb22-ac14-479e-abb0-d86fa3ccef27}</UniqueIdentifier>
    </Filter>
    <Filter Include="Framework\Engine\Source Files">
      <UniqueIdentifier>{a80168bd-990a-4b4b-a4ee-2dcb7793a558}</UniqueIdentifier>
    </Filter>
    <Filter Include="Objects">
      <UniqueIdentifier>{7b7d904d-d297-4ae5-9fe4-9e7571a438a0}</UniqueIdentifier>
    </Filter>
    <Filter Include="Objects\Header Files">
      <UniqueIdentifier>{c5a40781-ba24-4fb5-83c5-18eb22a61044}</UniqueIdentifier>
    </Filter>
    <Filter Include="Objects\Source Files">
      <UniqueIdentifier>{d4d7384f-b8b3-4af3-839e-fb38de01a059}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="pch.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Aurora\Array.h">
      <Filter>Libraries\Includes\Aurora</Filter>
    </ClInclude>
    <ClInclude Include="Aurora\Binary.h">
      <Filter>Libraries\Includes\Aurora</Filter>
    </ClInclude>
    <ClInclude Include="Aurora\CodeInjection.h">
      <Filter>Libraries\Includes\Aurora</Filter>
    </ClInclude>
    <ClInclude Include="Aurora\Color.h">
      <Filter>Libraries\Includes\Aurora</Filter>
    </ClInclude>
    <ClInclude Include="Aurora\Console.h">
      <Filter>Libraries\Includes\Aurora</Filter>
    </ClInclude>
    <ClInclude Include="Aurora\ConstexprMath.h">
      <Filter>Libraries\Includes\Aurora</Filter>
    </ClInclude>
    <ClInclude Include="Aurora\Definitions.h">
      <Filter>Libraries\Includes\Aurora</Filter>
    </ClInclude>
    <ClInclude Include="Aurora\DllInjection.h">
      <Filter>Libraries\Includes\Aurora</Filter>
    </ClInclude>
    <ClInclude Include="Aurora\Events.h">
      <Filter>Libraries\Includes\Aurora</Filter>
    </ClInclude>
    <ClInclude Include="Aurora\Exceptions.h">
      <Filter>Libraries\Includes\Aurora</Filter>
    </ClInclude>
    <ClInclude Include="Aurora\FileSystem.h">
      <Filter>Libraries\Includes\Aurora</Filter>
    </ClInclude>
    <ClInclude Include="Aurora\Logger.h">
      <Filter>Libraries\Includes\Aurora</Filter>
    </ClInclude>
    <ClInclude Include="Aurora\Memory.h">
      <Filter>Libraries\Includes\Aurora</Filter>
    </ClInclude>
    <ClInclude Include="Aurora\MemoryTypes.h">
      <Filter>Libraries\Includes\Aurora</Filter>
    </ClInclude>
    <ClInclude Include="Aurora\MemoryWin32.h">
      <Filter>Libraries\Includes\Aurora</Filter>
    </ClInclude>
    <ClInclude Include="Aurora\Pipe.h">
      <Filter>Libraries\Includes\Aurora</Filter>
    </ClInclude>
    <ClInclude Include="Aurora\ProcessInfo.h">
      <Filter>Libraries\Includes\Aurora</Filter>
    </ClInclude>
    <ClInclude Include="Aurora\Property.h">
      <Filter>Libraries\Includes\Aurora</Filter>
    </ClInclude>
    <ClInclude Include="Aurora\Shapes.h">
      <Filter>Libraries\Includes\Aurora</Filter>
    </ClInclude>
    <ClInclude Include="Aurora\SharedHandle.h">
      <Filter>Libraries\Includes\Aurora</Filter>
    </ClInclude>
    <ClInclude Include="Aurora\Signal.h">
      <Filter>Libraries\Includes\Aurora</Filter>
    </ClInclude>
    <ClInclude Include="Aurora\Thread.h">
      <Filter>Libraries\Includes\Aurora</Filter>
    </ClInclude>
    <ClInclude Include="Aurora\Time.h">
      <Filter>Libraries\Includes\Aurora</Filter>
    </ClInclude>
    <ClInclude Include="Aurora\Trampoline.h">
      <Filter>Libraries\Includes\Aurora</Filter>
    </ClInclude>
    <ClInclude Include="Aurora\Vector.h">
      <Filter>Libraries\Includes\Aurora</Filter>
    </ClInclude>
    <ClInclude Include="Aurora\HDE\hde32.h">
      <Filter>Libraries\Includes\Aurora\HDE</Filter>
    </ClInclude>
    <ClInclude Include="Aurora\HDE\hde64.h">
      <Filter>Libraries\Includes\Aurora\HDE</Filter>
    </ClInclude>
    <ClInclude Include="Definitions.h">
      <Filter>Framework\Header Files</Filter>
    </ClInclude>
    <ClInclude Include="External.h">
      <Filter>Framework\Header Files</Filter>
    </ClInclude>
    <ClInclude Include="KeybindManager.h">
      <Filter>Framework\Header Files</Filter>
    </ClInclude>
    <ClInclude Include="WindowManager.h">
      <Filter>Framework\Header Files</Filter>
    </ClInclude>
    <ClInclude Include="PresentHook.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ImGui\imconfig.h">
      <Filter>Libraries\Includes\ImGui</Filter>
    </ClInclude>
    <ClInclude Include="ImGui\imgui.h">
      <Filter>Libraries\Includes\ImGui</Filter>
    </ClInclude>
    <ClInclude Include="ImGui\imgui_impl_dx11.h">
      <Filter>Libraries\Includes\ImGui</Filter>
    </ClInclude>
    <ClInclude Include="ImGui\imgui_impl_win32.h">
      <Filter>Libraries\Includes\ImGui</Filter>
    </ClInclude>
    <ClInclude Include="ImGui\imgui_internal.h">
      <Filter>Libraries\Includes\ImGui</Filter>
    </ClInclude>
    <ClInclude Include="ImGui\imstb_rectpack.h">
      <Filter>Libraries\Includes\ImGui</Filter>
    </ClInclude>
    <ClInclude Include="ImGui\imstb_textedit.h">
      <Filter>Libraries\Includes\ImGui</Filter>
    </ClInclude>
    <ClInclude Include="MinHook\MinHook.h">
      <Filter>Libraries\Includes\MinHook</Filter>
    </ClInclude>
    <ClInclude Include="Manager.h">
      <Filter>Framework\Header Files</Filter>
    </ClInclude>
    <ClInclude Include="EventManager.h">
      <Filter>Framework\Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Events.h">
      <Filter>Framework\Engine\Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Keybinds.h">
      <Filter>Objects\Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Windows.h">
      <Filter>Objects\Header Files</Filter>
    </ClInclude>
    <ClInclude Include="EventEntries.h">
      <Filter>Objects\Header Files</Filter>
    </ClInclude>
    <ClInclude Include="GameManager.h">
      <Filter>Framework\Engine\Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Constants.h">
      <Filter>Framework\Engine\Header Files</Filter>
    </ClInclude>
    <ClInclude Include="DrawManager.h">
      <Filter>Framework\Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ExtensionManager.h">
      <Filter>Framework\Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="dllmain.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="pch.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="External.cpp">
      <Filter>Framework\Source Files</Filter>
    </ClCompile>
    <ClCompile Include="KeybindManager.cpp">
      <Filter>Framework\Source Files</Filter>
    </ClCompile>
    <ClCompile Include="WindowManager.cpp">
      <Filter>Framework\Source Files</Filter>
    </ClCompile>
    <ClCompile Include="PresentHook.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Manager.cpp">
      <Filter>Framework\Source Files</Filter>
    </ClCompile>
    <ClCompile Include="EventManager.cpp">
      <Filter>Framework\Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Events.cpp">
      <Filter>Framework\Engine\Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Windows.cpp">
      <Filter>Objects\Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Keybinds.cpp">
      <Filter>Objects\Source Files</Filter>
    </ClCompile>
    <ClCompile Include="EventEntries.cpp">
      <Filter>Objects\Source Files</Filter>
    </ClCompile>
    <ClCompile Include="GameManager.cpp">
      <Filter>Framework\Engine\Source Files</Filter>
    </ClCompile>
    <ClCompile Include="DrawManager.cpp">
      <Filter>Framework\Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ExtensionManager.cpp">
      <Filter>Framework\Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="Libraries\ReleaseLib\Aurora.dll">
      <Filter>Libraries\x64/Release\Aurora</Filter>
    </None>
    <None Include="Libraries\ReleaseLib\Aurora.exp">
      <Filter>Libraries\x64/Release\Aurora</Filter>
    </None>
    <None Include="Libraries\ReleaseLib\Aurora.pdb">
      <Filter>Libraries\x64/Release\Aurora</Filter>
    </None>
    <None Include="Libraries\ReleaseLib\ImGui.dll">
      <Filter>Libraries\x64/Release\ImGui</Filter>
    </None>
    <None Include="Libraries\ReleaseLib\ImGui.exp">
      <Filter>Libraries\x64/Release\ImGui</Filter>
    </None>
    <None Include="Libraries\ReleaseLib\ImGui.pdb">
      <Filter>Libraries\x64/Release\ImGui</Filter>
    </None>
    <None Include="Libraries\DebugLib\Aurora.dll">
      <Filter>Libraries\x64/Debug\Aurora</Filter>
    </None>
    <None Include="Libraries\DebugLib\Aurora.exp">
      <Filter>Libraries\x64/Debug\Aurora</Filter>
    </None>
    <None Include="Libraries\DebugLib\Aurora.pdb">
      <Filter>Libraries\x64/Debug\Aurora</Filter>
    </None>
    <None Include="Libraries\DebugLib\ImGui.dll">
      <Filter>Libraries\x64/Debug\ImGui</Filter>
    </None>
    <None Include="Libraries\DebugLib\ImGui.exp">
      <Filter>Libraries\x64/Debug\ImGui</Filter>
    </None>
    <None Include="Libraries\DebugLib\ImGui.pdb">
      <Filter>Libraries\x64/Debug\ImGui</Filter>
    </None>
    <None Include="Libraries\ReleaseLib\MinHook.dll">
      <Filter>Libraries\x64/Release\MinHook</Filter>
    </None>
    <None Include="Libraries\ReleaseLib\MinHook.exp">
      <Filter>Libraries\x64/Release\MinHook</Filter>
    </None>
    <None Include="Libraries\ReleaseLib\MinHook.pdb">
      <Filter>Libraries\x64/Release\MinHook</Filter>
    </None>
    <None Include="Libraries\DebugLib\MinHook.dll">
      <Filter>Libraries\x64/Debug\MinHook</Filter>
    </None>
    <None Include="Libraries\DebugLib\MinHook.exp">
      <Filter>Libraries\x64/Debug\MinHook</Filter>
    </None>
    <None Include="Libraries\DebugLib\MinHook.pdb">
      <Filter>Libraries\x64/Debug\MinHook</Filter>
    </None>
  </ItemGroup>
  <ItemGroup>
    <Library Include="Libraries\ReleaseLib\Aurora.lib">
      <Filter>Libraries\x64/Release\Aurora</Filter>
    </Library>
    <Library Include="Libraries\ReleaseLib\ImGui.lib">
      <Filter>Libraries\x64/Release\ImGui</Filter>
    </Library>
    <Library Include="Libraries\DebugLib\Aurora.lib">
      <Filter>Libraries\x64/Debug\Aurora</Filter>
    </Library>
    <Library Include="Libraries\DebugLib\ImGui.lib">
      <Filter>Libraries\x64/Debug\ImGui</Filter>
    </Library>
    <Library Include="Libraries\ReleaseLib\MinHook.lib">
      <Filter>Libraries\x64/Release\MinHook</Filter>
    </Library>
    <Library Include="Libraries\DebugLib\MinHook.lib">
      <Filter>Libraries\x64/Debug\MinHook</Filter>
    </Library>
  </ItemGroup>
</Project>
```

`Artemis/Aurora/Array.h`:

```h
//------------------------------------------------------------------------>
// MIT License
// 
// Copyright (c) 2023 Artemis Group
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------>
// Aurora: https://github.com/ArtemisDevGroup/Aurora
// This file was authored by:
// @Astrea0014: https://github.com/Astrea0014
//------------------------------------------------------------------------>

#ifndef __AURORA_ARRAY_H__
#define __AURORA_ARRAY_H__

#include <initializer_list>
#include <stdlib.h>

#include "Definitions.h"
#include "Exceptions.h"

namespace Aurora {
	/// <summary>
	/// <para>Represents a result after the comparison of two values.</para>
	/// <para>This is used as a return value for the compare routine of the collection classes.</para>
	/// <para>See guides or the API reference for usage examples.</para>
	/// </summary>
	enum class CompareResult : A_I32 {
		/// <summary>
		/// Element 1 is less than element 2.
		/// </summary>
		LessThan = -1,

		/// <summary>
		/// Element 1 and element 2 are equal.
		/// </summary>
		Equal = 0,

		/// <summary>
		/// Element 1 is more than element 2.
		/// </summary>
		MoreThan = 1
	};

	/// <summary>
	/// A class for pairing two pieces of data.
	/// </summary>
	/// <typeparam name="Type1">- The type of the first object to store.</typeparam>
	/// <typeparam name="Type2">- The type of the second object to store.</typeparam>
	template<NonVoidType Type1, NonVoidType Type2>
	class Pair {
		Type1 Field1;
		Type2 Field2;

	public:
		constexpr Pair() : Field1(), Field2() {}

		/// <summary>
		/// Constructs a pair of two pieces of data.
		/// </summary>
		/// <param name="First">- The first piece of data of the pair.</param>
		/// <param name="Second">- The second piece of data of the pair.</param>
		constexpr Pair(_In_ const Type1& First, _In_ const Type2& Second) : Field1(First), Field2(Second) {}

		/// <summary>
		/// Gets a constant reference to the first object in the pair.
		/// </summary>
		/// <returns>A reference to the first object.</returns>
		AURORA_NDWR_GET("GetFirst") constexpr const Type1& GetFirst() const noexcept { return Field1; }

		/// <summary>
		/// Gets a reference to the first object in the pair.
		/// </summary>
		/// <returns>A reference to the first object.</returns>
		AURORA_NDWR_GET("GetFirst") constexpr Type1& GetFirst() noexcept { return Field1; }

		/// <summary>
		/// Gets a constant reference to the second object in the pair.
		/// </summary>
		/// <returns>A reference to the second object.</returns>
		AURORA_NDWR_GET("GetSecond") constexpr const Type2& GetSecond() const noexcept { return Field2; }

		/// <summary>
		/// Gets a constant reference to the second object in the pair.
		/// </summary>
		/// <returns>A reference to the second object.</returns>
		AURORA_NDWR_GET("GetSecond") constexpr Type2& GetSecond() noexcept { return Field2; }
	};

	/// <summary>
	/// A class for storing sequences of data.
	/// </summary>
	/// <typeparam name="ElementType">- The type of the elements to store.</typeparam>
	/// <typeparam name="nElementCount">- The number of elements to store.</typeparam>
	template<NonVoidType ElementType, A_I32 nElementCount>
	class Array {
	public:
		/// <summary>
		/// The core array storing the values.
		/// </summary>
		ElementType szArray[nElementCount];

		inline operator _Ret_writes_(nElementCount) ElementType* () noexcept { return szArray; }
		constexpr operator _Ret_writes_(nElementCount) const ElementType* () const noexcept { return szArray; }

		inline ElementType& operator[](A_I32 nIndex) { return szArray[nIndex]; }
		constexpr const ElementType operator[](A_I32 nIndex) const { return szArray[nIndex]; }

		/// <summary>
		/// Gets the size of the array and returns it.
		/// </summary>
		/// <returns>The size of the array.</returns>
		AURORA_NDWR_GET("size") constexpr const A_I32 size() const noexcept { return nElementCount; }

		/// <summary>
		/// Gets the begin iterator.
		/// </summary>
		/// <returns>The begin iterator.</returns>
		AURORA_NDWR_GET("begin") inline _Ret_writes_(nElementCount) ElementType* begin() noexcept { return szArray; }

		/// <summary>
		/// Gets the begin const iterator.
		/// </summary>
		/// <returns>The begin const iterator.</returns>
		AURORA_NDWR_GET("begin") constexpr _Ret_writes_(nElementCount) const ElementType* begin() const noexcept { return szArray; }

		/// <summary>
		/// Ges the end iterator.
		/// </summary>
		/// <returns>The end iterator.</returns>
		AURORA_NDWR_GET("end") inline ElementType* end() noexcept { return &szArray[nElementCount]; }

		/// <summary>
		/// Gets the end const iterator.
		/// </summary>
		/// <returns>The end const iterator.</returns>
		AURORA_NDWR_GET("end") constexpr const ElementType* end() const noexcept { return &szArray[nElementCount]; }

		/// <summary>
		/// A function template for a function used to compare elements in this array and sort them accordingly.
		/// </summary>
		using CompareFunction = Function<CompareResult(const ElementType& refElement1, const ElementType& refElement2)>;

		/// <summary>
		/// Sorts the array according to the routine provided.
		/// </summary>
		/// <param name="lpfnCompareFunction">
		/// - A function pointer or lambda expression of a routine comparing two values from the array at a time and returning a value from the CompareResult enumeration.
		/// </param>
		inline A_VOID Sort(_In_ CompareFunction lpfnCompareFunction) { qsort_s((void*)szArray, nElementCount, sizeof(ElementType), [](void* pContext, const void* pElem1, const void* pElem2) -> int { return (int)((*(CompareFunction*)pContext)(*(ElementType*)pElem1, *(ElementType*)pElem2)); }, &lpfnCompareFunction); }
	};

	/// <summary>
	/// A class for dynamically storing lists of objects.
	/// </summary>
	/// <typeparam name="ElementType">- The type of the elements in the list.</typeparam>
	template<NonVoidType ElementType>
	class List {
		ElementType* pArray;
		A_I32 nCount;
		A_I32 nMaxCount;

		static constexpr inline A_I32 c_nPageSize = 64;

		AURORA_NDWR_PURE("ntob") static constexpr A_I32 ntob(A_I32 n) noexcept { return n * sizeof(ElementType); }
		AURORA_NDWR_PURE("bton") static constexpr A_I32 bton(A_I32 b) noexcept { return b / sizeof(ElementType); }

		AURORA_NDWR_PURE("GetRealAllocCount") static constexpr A_I32 GetRealAllocCount(A_I32 nCount) noexcept {
			return bton(c_nPageSize * (ntob(nCount) % c_nPageSize ? (ntob(nCount) / c_nPageSize + 1) : (ntob(nCount) / c_nPageSize)));
		}

		inline A_VOID Allocate(_In_ A_I32 nCount) {
			if (nCount <= nMaxCount) return;

			A_I32 nAllocCount = GetRealAllocCount(nCount);

			if (pArray) {
				ElementType* pOldArray = pArray;
				A_I32 nOldMaxCount = nMaxCount;

				pArray = new ElementType[nAllocCount];
				nMaxCount = nAllocCount;

#pragma warning(push)
#pragma warning(disable:6386) // Disabling "buffer overrun" warning due to pArray never being overran, it gets checked at line 'this' - 12.
				for (A_I32 i = 0; i < this->nCount; i++) pArray[i] = pOldArray[i];
#pragma warning(pop)
			}
			else {
				pArray = new ElementType[nAllocCount];
				nMaxCount = nAllocCount;
				this->nCount = 0;
			}
		}

		inline A_VOID Move(_In_ A_I32 nFrom, _In_ A_I32 nTo) {
			AuroraContextStart();

			if (nFrom > nTo) {
				for (A_I32 i = 0; i < this->nCount - nFrom; i++) pArray[nTo + i] = pArray[nFrom + i];
			}
			else if (nFrom < nTo) {
				for (A_I32 i = this->nCount - 1; i >= nFrom; i--)
					pArray[nTo - nFrom + i] = pArray[i];
			}
			else AuroraThrow(ParameterInvalidException, "nFrom == nTo");

			AuroraContextEnd();
		}

	public:
		inline List() noexcept : pArray(nullptr), nMaxCount(0), nCount(0) {}

		/// <summary>
		/// Initializes a List object with the provided list of objects.
		/// </summary>
		/// <param name="refList">- An initializer list to construct the list instance with.</param>
		inline List(_In_ const std::initializer_list<ElementType>& refList) {
			Allocate(refList.size());

			for (A_I32 i = 0; i < refList.size(); i++) pArray[i] = refList.begin()[i];

			nCount = refList.size();
		}

		/// <summary>
		/// Initializes a List object with the provided array of objects.
		/// </summary>
		/// <typeparam name="nCount">- The number of elements in the array.</typeparam>
		/// <param name="lpArray">- A reference to the array.</param>
		template<A_I32 nSize>
		inline List(_In_ const ElementType(&lpArray)[nSize]) {
			Allocate(nSize);

			for (A_I32 i = 0; i < nCount; i++) this->pArray[i] = lpArray[i];

			this->nCount = nCount;
		}

		/// <summary>
		/// Initializes a List object with the provided array of objects.
		/// </summary>
		/// <param name="lpArray">- A pointer to the array.</param>
		/// <param name="dwSize">- The size of the array in elements.</param>
		/// <exception cref="ParameterInvalidException"/>
		inline List(_In_ const ElementType* lpArray, _In_ A_DWORD dwSize) {
			AuroraContextStart();

			if (!lpArray) AuroraThrow(ParameterInvalidException, "lpArray");

			Allocate(dwSize);
			for (A_I32 i = 0; i < dwSize; i++) this->pArray[i] = lpArray[i];
			this->nCount = dwSize;

			AuroraContextEnd();
		}

		inline List(const List<ElementType>& cpy) {
			Allocate(cpy.nCount);
			for (A_I32 i = 0; i < cpy.nCount; i++) pArray[i] = cpy.pArray[i];
			nCount = cpy.nCount;
		}

		/// <summary>
		/// Releases the current list of objects from the heap and sets the count to 0, effectively clearing the list.
		/// </summary>
		inline A_VOID Clear() {
			if (pArray) {
				delete[] pArray;
				pArray = nullptr;
				nCount = 0;
			}
		}

		inline ~List() { Clear(); }

		/// <summary>
		/// Gets the size of the array and returns it.
		/// </summary>
		/// <returns>The size of the array.</returns>
		AURORA_NDWR_GET("size") constexpr const A_I32 size() const noexcept { return nCount; }

		/// <summary>
		/// Gets the begin iterator.
		/// </summary>
		/// <returns>The begin iterator.</returns>
		AURORA_NDWR_GET("begin") inline ElementType* begin() noexcept { return pArray; }

		/// <summary>
		/// Gets the begin const iterator.
		/// </summary>
		/// <returns>The begin const iterator.</returns>
		AURORA_NDWR_GET("begin") constexpr const ElementType* begin() const noexcept { return pArray; }

		/// <summary>
		/// Ges the end iterator.
		/// </summary>
		/// <returns>The end iterator.</returns>
		AURORA_NDWR_GET("end") inline ElementType* end() noexcept { return &pArray[nCount]; }

		/// <summary>
		/// Gets the end const iterator.
		/// </summary>
		/// <returns>The end const iterator.</returns>
		AURORA_NDWR_GET("end") constexpr const ElementType* end() const noexcept { return &pArray[nCount]; }

		/// <summary>
		/// Adds an element to the list.
		/// </summary>
		/// <param name="refElement">- A constant reference to the element to append.</param>
		/// <param name="nIndex">- The index of where to add the element. If nIndex is its default value of -1, the function will append the element to the end of the list.</param>
		inline A_VOID Add(_In_ const ElementType& refElement, _In_ A_I32 nIndex = -1) {
			Allocate(nCount + 1);

			if (nIndex == -1) {
				pArray[nCount] = refElement;
				nCount++;
			}
			else {
				Move(nIndex, nIndex + 1);
				pArray[nIndex] = refElement;
				nCount++;
			}
		}

		/// <summary>
		/// Adds a list of elements to the list.
		/// </summary>
		/// <param name="refList">- A constant reference to the list of elements to append.</param>
		/// <param name="nIndex">- The index of where to add the elements. If nIndex is its default value of -1, the function will append the elements to the end of the list.</param>
		inline A_VOID Add(_In_ const std::initializer_list<ElementType>& refList, _In_ A_I32 nIndex = -1) {
			Allocate(nCount + refList.size());

			if (nIndex == -1) {
				for (A_I32 i = 0; i < refList.size(); i++)
					pArray[nCount + i] = refList.begin()[i];

				nCount += refList.size();
			}
			else {
				Move(nIndex, nIndex + refList.size());
				for (A_I32 i = 0; i < refList.size(); i++)
					pArray[nIndex + i] = refList.begin()[i];

				nCount += refList.size();
			}
		}

		/// <summary>
		/// Adds a list of elements to the list.
		/// </summary>
		/// <param name="refList">- A constant reference to the list of elements to append.</param>
		/// <param name="nIndex">- The index of where to add the elements. If nIndex is its default value of -1, the function will append the elements to the end of the list.</param>
		inline A_VOID Add(_In_ const List<ElementType>& refList, _In_ A_I32 nIndex = -1) {
			Allocate(nCount + refList.size());

			if (nIndex == -1) {
				for (A_I32 i = 0; i < refList.size(); i++)
					pArray[nCount + i] = refList.begin()[i];

				nCount += refList.size();
			}
			else {
				Move(nIndex, nIndex + refList.size());
				for (A_I32 i = 0; i < refList.size(); i++)
					pArray[nIndex + i] = refList.begin()[i];

				nCount += refList.size();
			}
		}

		/// <summary>
		/// Adds an array of elements to the list.
		/// </summary>
		/// <param name="lpArray">- A pointer to the array to append.</param>
		/// <param name="dwSize">- The size of the array in elements.</param>
		/// <param name="nIndex">- The index of where to add the elements. If nIndex is its default value of -1, the function will append the elements to the end of the list.</param>
		/// <exception cref="ParameterInvalidException"/>
		inline A_VOID Add(_In_ const ElementType* lpArray, _In_ A_DWORD dwSize, _In_ A_I32 nIndex = -1) {
			AuroraContextStart();

			if (!lpArray) AuroraThrow(ParameterInvalidException, "lpArray");

			Allocate(this->nCount + dwSize);

			if (nIndex == -1) {
				for (int i = 0; i < dwSize; i++)
					this->pArray[this->nCount + i] = lpArray[i];

				this->nCount += dwSize;
			}
			else {
				Move(nIndex, nIndex + dwSize);
				for (int i = 0; i < dwSize; i++)
					this->pArray[nIndex + i] = lpArray[i];

				this->nCount += dwSize;
			}

			AuroraContextEnd();
		}

		/// <summary>
		/// Adds an array of elements to the list.
		/// </summary>
		/// <typeparam name="nSize">- The size of the array in elements.</typeparam>
		/// <param name="lpArray">- A pointer to the array to append.</param>
		/// <param name="nIndex">- The index of where to add the elements. If nIndex is its default value of -1, the function will append the elements to the end of the list.</param>
		template<A_I32 nSize>
		inline A_VOID Add(_In_ const ElementType(&lpArray)[nSize], _In_ A_I32 nIndex) { Add(lpArray, nSize, nIndex); }

		/// <summary>
		/// Removes a number of elements from an index.
		/// </summary>
		/// <param name="nCount">- The number of elements to remove. By default this is set to 1.</param>
		/// <param name="nIndex">- The index of where to remove elements. If nIndex is its default value of -1, the function will remove elements from the end of the list.</param>
		inline A_VOID Remove(_In_ A_I32 nCount = 1, _In_ A_I32 nIndex = -1) {
			if (nIndex == -1) {
				this->nCount -= nCount;
			}
			else {
				Move(nIndex + nCount, nIndex);
				this->nCount -= nCount;
			}
		}

		/// <summary>
		/// A function template for a function used to compare elements in this array and sort them accordingly.
		/// </summary>
		using CompareFunction = Function<CompareResult(const ElementType& refElement1, const ElementType& refElement2)>;

		/// <summary>
		/// Sorts the list according to the routine provided.
		/// </summary>
		/// <param name="lpfnCompareFunction">
		/// - A function pointer or lambda expression of a routine comparing two values from the list at a time and returning a value from the CompareResult enumeration.
		/// </param>
		inline A_VOID Sort(_In_ CompareFunction lpfnCompareFunction) { qsort_s((void*)pArray, nCount, sizeof(ElementType), [](void* pContext, const void* pElem1, const void* pElem2) -> int { return (int)((*(CompareFunction*)pContext)(*(ElementType*)pElem1, *(ElementType*)pElem2)); }, &lpfnCompareFunction); }

		inline operator ElementType* () noexcept { return pArray; }
		constexpr operator const ElementType* () const noexcept { return pArray; }

		AURORA_NDWR_GET("operator[]") inline ElementType& operator[](A_I32 nIndex) {
			return pArray[nIndex];
		}

		AURORA_NDWR_GET("operator[]") constexpr const ElementType& operator[](A_I32 nIndex) const {
			return pArray[nIndex];
		}
	};

	/// <summary>
	/// A class for taking a list of arguments as a function parameter.
	/// </summary>
	/// <typeparam name="ElementType">- The type of the arguments.</typeparam>
	template<NonVoidType ElementType>
	class ArgumentList {
		ElementType* pArray;
		int nCount;

	public:
		inline ArgumentList() noexcept : pArray(nullptr), nCount(0) {}

		/// <summary>
		/// Initializes an ArgumentList object with the provided list of objects.
		/// </summary>
		/// <param name="refList">- An initializer list to construct the argument list instance with.</param>
		inline ArgumentList(_In_ const std::initializer_list<ElementType>& refList) {
			nCount = refList.size();
			if (nCount > 0) {
				pArray = new ElementType[nCount];
				for (A_I32 i = 0; i < nCount; i++) pArray[i] = refList.begin()[i];
			}
		}

		inline ArgumentList(const ArgumentList<ElementType>& cpy) {
			if (cpy.pArray) {
				pArray = new ElementType[cpy.nCount];
				nCount = cpy.nCount;

				for (A_I32 i = 0; i < nCount; i++)
					pArray[i] = cpy.pArray[i];
			}
		}

		inline ~ArgumentList() {
			if (pArray) {
				delete[] pArray;
				pArray = nullptr;
				nCount = 0;
			}
		}

		/// <summary>
		/// Gets the size of the array and returns it.
		/// </summary>
		/// <returns>The size of the array.</returns>
		AURORA_NDWR_GET("size") constexpr const A_I32 size() const noexcept { return nCount; }

		/// <summary>
		/// Gets the begin iterator.
		/// </summary>
		/// <returns>The begin iterator.</returns>
		AURORA_NDWR_GET("begin") inline ElementType* begin() noexcept { return pArray; }

		/// <summary>
		/// Gets the begin const iterator.
		/// </summary>
		/// <returns>The begin const iterator.</returns>
		AURORA_NDWR_GET("begin") constexpr const ElementType* begin() const noexcept { return pArray; }

		/// <summary>
		/// Ges the end iterator.
		/// </summary>
		/// <returns>The end iterator.</returns>
		AURORA_NDWR_GET("end") inline ElementType* end() noexcept { return &pArray[nCount]; }

		/// <summary>
		/// Gets the end const iterator.
		/// </summary>
		/// <returns>The end const iterator.</returns>
		AURORA_NDWR_GET("end") constexpr const ElementType* end() const noexcept { return &pArray[nCount]; }

		AURORA_NDWR_GET("operator ElementType*") inline operator ElementType* () noexcept { return pArray; }
		AURORA_NDWR_GET("operator const ElementType*") constexpr operator const ElementType* () const noexcept { return pArray; }

		AURORA_NDWR_GET("operator[]") inline ElementType& operator[](A_I32 nIndex) { return pArray[nIndex]; }
		AURORA_NDWR_GET("operator[]") constexpr const ElementType operator[](A_I32 nIndex) const { return pArray[nIndex]; }
	};
}

#endif // !__AURORA_ARRAY_H__
```

`Artemis/Aurora/Binary.h`:

```h
//------------------------------------------------------------------------>
// MIT License
// 
// Copyright (c) 2023 Artemis Group
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------>
// Aurora: https://github.com/ArtemisDevGroup/Aurora
// This file was authored by:
// @Astrea0014: https://github.com/Astrea0014
//------------------------------------------------------------------------>

#ifndef __AURORA_BINARY_H__
#define __AURORA_BINARY_H__

#include "Definitions.h"

namespace Aurora {
	/// <summary>
	/// A class for doing binary operations on a value.
	/// </summary>
	/// <typeparam name="BufferType">- An integral type with the buffer size desired.</typeparam>
	template<BitwiseType BufferType>
	class Binary {
		BufferType Buffer;

	public:
		// The size of the buffer in bytes.
		static constexpr A_I32 BufferByteCount = sizeof(BufferType);

		// The size of the buffer in bits.
		static constexpr A_I32 BufferBitCount = sizeof(BufferType) * 8;

		constexpr Binary() noexcept : Buffer(0) {}

		/// <summary></summary>
		/// <param name="Buffer">- The value to do binary operations on.</param>
		constexpr Binary(_In_ BufferType Buffer) noexcept : Buffer(Buffer) {}

		/// <summary>
		/// Checks if a bit is set.
		/// </summary>
		/// <param name="nBit">- The index of the bit.</param>
		/// <returns>True if the bit is set, false if it's not.</returns>
		AURORA_NDWR_PURE("CheckBit") constexpr A_BOOL CheckBit(_In_range_(0, BufferBitCount) A_I32 nBit) const noexcept { return !!(Buffer & (1 << nBit)); }

		/// <summary>
		/// Sets a bit.
		/// </summary>
		/// <param name="nBit">- The index of the bit.</param>
		constexpr A_VOID SetBit(_In_range_(0, BufferBitCount) A_I32 nBit) noexcept { Buffer = Buffer | (1 << nBit); }

		/// <summary>
		/// Resets or unsets a bit.
		/// </summary>
		/// <param name="nBit">- The index of the bit.</param>
		constexpr A_VOID ResetBit(_In_range_(0, BufferBitCount) A_I32 nBit) noexcept { Buffer = Buffer ^ (1 << nBit); }

		/// <summary>
		/// Rotates all bits left.
		/// </summary>
		/// <param name="uShift">- The number of bits to shift.</param>
		/// <returns>A Binary instance with the rotated bits.</returns>
		AURORA_NDWR_PURE("Rotl") constexpr Binary Rotl(A_U32 uShift) const noexcept { return Binary(Buffer << uShift | Buffer >> (BufferBitCount - uShift)); }

		/// <summary>
		/// Rotates all bits right.
		/// </summary>
		/// <param name="uShift">- The number of bits to shift.</param>
		/// <returns>A Binary instance with the rotated bits.</returns>
		AURORA_NDWR_PURE("Rotr") constexpr Binary Rotr(A_U32 uShift) const noexcept { return Binary(Buffer >> uShift | Buffer << (BufferBitCount - uShift)); }

		/// <summary>
		/// Gets the value of the buffer.
		/// </summary>
		/// <returns>The value of the buffer.</returns>
		AURORA_NDWR_GET("GetBuffer") constexpr BufferType GetBuffer() const noexcept { return Buffer; }

		/// <summary>
		/// Gets a string representation of the buffer in base 2.
		/// </summary>
		/// <param name="lpBuffer">- A reference to the buffer to receive the string.</param>
		A_VOID GetBinaryString(_Out_writes_z_(BufferBitCount + 1) A_CHAR(&lpBuffer)[BufferBitCount + 1]) const {
			for (A_I32 i = 0; i < BufferBitCount; i++)
				lpBuffer[i] = CheckBit(i) ? '1' : '0';
			lpBuffer[BufferBitCount] = '\0';
		}

		AURORA_NDWR_PURE("operator+") constexpr Binary operator+(_In_ const Binary& right) const noexcept { return Binary(Buffer + right.Buffer); }
		AURORA_NDWR_PURE("operator-") constexpr Binary operator-(_In_ const Binary& right) const noexcept { return Binary(Buffer - right.Buffer); }
		AURORA_NDWR_PURE("operator*") constexpr Binary operator*(_In_ const Binary& right) const noexcept { return Binary(Buffer * right.Buffer); }
		AURORA_NDWR_PURE("operator/") constexpr Binary operator/(_In_ const Binary& right) const noexcept { return Binary(Buffer / right.Buffer); }
		AURORA_NDWR_PURE("operator%") constexpr Binary operator%(_In_ const Binary& right) const noexcept { return Binary(Buffer % right.Buffer); }

		AURORA_NDWR_PURE("operator&") constexpr Binary operator&(_In_ const Binary& right) const noexcept { return Binary(Buffer & right.Buffer); }
		AURORA_NDWR_PURE("operator|") constexpr Binary operator|(_In_ const Binary& right) const noexcept { return Binary(Buffer | right.Buffer); }
		AURORA_NDWR_PURE("operator^") constexpr Binary operator^(_In_ const Binary& right) const noexcept { return Binary(Buffer ^ right.Buffer); }

		AURORA_NDWR_PURE("operator<<") constexpr Binary operator<<(_In_ A_I32 nShiftCount) const noexcept { return Binary(Buffer << nShiftCount); }
		AURORA_NDWR_PURE("operator>>") constexpr Binary operator>>(_In_ A_I32 nShiftCount) const noexcept { return Binary(Buffer >> nShiftCount); }

		constexpr A_VOID operator+=(_In_ const Binary& right) noexcept { Buffer += right.Buffer; }
		constexpr A_VOID operator-=(_In_ const Binary& right) noexcept { Buffer -= right.Buffer; }
		constexpr A_VOID operator*=(_In_ const Binary& right) noexcept { Buffer *= right.Buffer; }
		constexpr A_VOID operator/=(_In_ const Binary& right) noexcept { Buffer /= right.Buffer; }
		constexpr A_VOID operator%=(_In_ const Binary& right) noexcept { Buffer %= right.Buffer; }

		constexpr A_VOID operator&=(_In_ const Binary& right) noexcept { Buffer &= right.Buffer; }
		constexpr A_VOID operator|=(_In_ const Binary& right) noexcept { Buffer |= right.Buffer; }
		constexpr A_VOID operator^=(_In_ const Binary& right) noexcept { Buffer ^= right.Buffer; }

		constexpr A_VOID operator~() const noexcept { ~Buffer; }
	};
}

#endif // !__AURORA_BINARY_H__
```

`Artemis/Aurora/CodeInjection.h`:

```h
//------------------------------------------------------------------------>
// MIT License
// 
// Copyright (c) 2023 Artemis Group
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------>
// Aurora: https://github.com/ArtemisDevGroup/Aurora
// This file was authored by:
// @Astrea0014: https://github.com/Astrea0014
//------------------------------------------------------------------------>

#ifndef __AURORA_CODE_INJECTION_H__
#define __AURORA_CODE_INJECTION_H__

#include "Definitions.h"
#include "Exceptions.h"
#include "MemoryTypes.h"
#include "Trampoline.h"
#include "SharedHandle.h"
#include "MemoryWin32.h"
#include "ProcessInfo.h"

#include "HDE/hde32.h"
#include "HDE/hde64.h"

namespace Aurora {
	namespace Helpers {
		constexpr A_DWORD c_dwRelJmp32Size = 5;

		AURORA_NDWR_PURE("Rel32_JmpOffset32") constexpr A_DWORD Rel32_JmpOffset32(_In_a32_ A_ADDR32 uFrom, _In_a32_ A_ADDR32 uTo) noexcept { return uTo - (uFrom + 5); }
		AURORA_NDWR_PURE("Rel32_JmpOffset64") constexpr A_DWORD Rel32_JmpOffset64(_In_a64_ A_ADDR64 uFrom, _In_a64_ A_ADDR64 uTo) noexcept { return *(A_LPDWORD)&uTo - (*(A_LPDWORD)&uFrom + 5); }

		AURORA_API A_BOOL SEHMemoryCopy(
			_Out_writes_bytes_(dwSize) A_LPVOID lpDestination,
			_In_reads_bytes_(dwSize) A_LPCVOID lpSource,
			_In_ A_DWORD dwSize
		);
	}

	/// <summary>
	/// Used for injecting code at an address.
	/// </summary>
	class AURORA_API CodeInjection32 {
		TrampolineManager32* lpTrampolineManager;
		TrampolineDescriptor32* lpTrampoline;

		A_ADDR32 uInjectionPoint;
		A_LPBYTE lpInjectionPayload;
		A_LPBYTE lpOriginalCode;
		A_DWORD dwInjectionSize;

		HANDLE hProcess;

		A_BOOL bEnabled;

		A_BOOL ReadMemory(_In_a32_ A_ADDR32 uAddress, _Out_writes_bytes_(dwSize) A_LPVOID lpBuffer, _In_ A_DWORD dwSize) noexcept;
		A_BOOL WriteMemory(_In_a32_ A_ADDR32 uAddress, _In_reads_bytes_(dwSize) A_LPCVOID lpBuffer, _In_ A_DWORD dwSize) noexcept;

	public:
		CodeInjection32();

		/// <summary>
		/// Creates a code injection in the local process.
		/// </summary>
		/// <typeparam name="nSize">- The size of the injection.</typeparam>
		/// <param name="uInjectionPoint">- The address of the injection point.</param>
		/// <param name="refInjectionCode">- The code to inject.</param>
		/// <param name="bKeepOverwrittenCode">- Determines whether to keep the code overwritten by the jmp or not.</param>
		/// <exception cref="WindowsApiException"/>
		/// <exception cref="Read32Exception"/>
		/// <exception cref="Write32Exception"/>
		template<A_I32 nSize>
		CodeInjection32(
			_In_a32_ A_ADDR32 uInjectionPoint,
			_In_ const InstructionBytes<nSize>& refInjectionCode,
			_In_ A_BOOL bKeepOverwrittenCode = false
		) : lpTrampolineManager(nullptr), lpTrampoline(nullptr), lpInjectionPayload(nullptr), lpOriginalCode(nullptr), hProcess(nullptr), uInjectionPoint(uInjectionPoint), dwInjectionSize(0), bEnabled(false) {
			AuroraContextStart();

			// Create new trampoline manager.

			lpTrampolineManager = new TrampolineManager32();

			// Get size of overwritten instructions.

			A_BYTE szTempBuffer[32];
			if (!ReadMemory(uInjectionPoint, szTempBuffer, sizeof(szTempBuffer))) AuroraThrow(Read32Exception, uInjectionPoint, sizeof(szTempBuffer));

			do {
				hde32s hde;
				hde32_disasm((const void*)szTempBuffer, &hde);
				dwInjectionSize += hde.len;
			} while (dwInjectionSize < Helpers::c_dwRelJmp32Size);

			// Copy original code into buffer.

			lpOriginalCode = new A_BYTE[dwInjectionSize];
			memcpy(lpOriginalCode, szTempBuffer, dwInjectionSize);

			// Create a trampoline with the size of the injection + the relative offset jump instruction + the original code if specified.

			lpTrampoline = lpTrampolineManager->CreateTrampoline(refInjectionCode.size() + Helpers::c_dwRelJmp32Size + (bKeepOverwrittenCode ? dwInjectionSize : 0));

			// Prepares the injection payload for the assembly patch.

			lpInjectionPayload = new A_BYTE[dwInjectionSize];
			lpInjectionPayload[0] = 0xE9;
			*(A_LPDWORD)&lpInjectionPayload[1] = Helpers::Rel32_JmpOffset32(uInjectionPoint, lpTrampoline->uTrampolineAddress);

			for (A_I32 i = 5; i < dwInjectionSize; i++)
				lpInjectionPayload[i] = 0x90; // Padding with nops.

			A_ADDR32 uIndexedAddress = lpTrampoline->uTrampolineAddress;

			// Writes overwritten code if specified.

			if (bKeepOverwrittenCode) {
				if (!WriteMemory(uIndexedAddress, lpOriginalCode, dwInjectionSize)) AuroraThrow(Write32Exception, uIndexedAddress, dwInjectionSize);
				uIndexedAddress += dwInjectionSize;
			}

			// Writes injection code.

			if (!WriteMemory(uIndexedAddress, refInjectionCode.szBytes, refInjectionCode.size())) AuroraThrow(Write32Exception, uIndexedAddress, refInjectionCode.size());
			uIndexedAddress += refInjectionCode.size();

			// Gets and writes relative jmp code.

			A_BYTE szJmpBackCode[Helpers::c_dwRelJmp32Size] = { 0xE9, 0x00, 0x00, 0x00, 0x00 };
			*(A_LPDWORD)&szJmpBackCode[1] = Helpers::Rel32_JmpOffset32(uIndexedAddress, uInjectionPoint + Helpers::c_dwRelJmp32Size);

			if (!WriteMemory(uIndexedAddress, szJmpBackCode, sizeof(szJmpBackCode))) AuroraThrow(Write32Exception, uIndexedAddress, Helpers::c_dwRelJmp32Size);

			AuroraContextEnd();
		}

		/// <summary>
		/// Creates a code injection in a remote process.
		/// </summary>
		/// <typeparam name="nSize">- The size of the injection.</typeparam>
		/// <param name="refTargetProcess">- A reference to the target process.</param>
		/// <param name="uInjectionPoint">- The address of the injection point.</param>
		/// <param name="refInjectionCode">- The code to inject.</param>
		/// <param name="bKeepOverwrittenCode">- Determines whether to keep the code overwritten by the jmp or not.</param>
		/// <exception cref="WindowsApiException"/>
		/// <exception cref="Read32Exception"/>
		/// <exception cref="Write32Exception"/>
		template<A_I32 nSize>
		CodeInjection32(
			_In_ const ProcessInfo32& refTargetProcess,
			_In_a32_ A_ADDR32 uInjectionPoint,
			_In_ const InstructionBytes<nSize>& refInjectionCode,
			_In_ A_BOOL bKeepOverwrittenCode = false
		) : lpTrampolineManager(nullptr), lpTrampoline(nullptr), lpInjectionPayload(nullptr), lpOriginalCode(nullptr), hProcess(nullptr), uInjectionPoint(uInjectionPoint), dwInjectionSize(0), bEnabled(false) {
			AuroraContextStart();

			// Get handle to remote process.

			hProcess = OpenSharedProcess(ProcessAccessFlags::Vm, false, refTargetProcess.GetProcessId());

			// Create new trampoline manager.

			lpTrampolineManager = new TrampolineManager32(refTargetProcess);

			// Get size of overwritten instructions.

			A_BYTE szTempBuffer[32];
			if (!ReadMemory(uInjectionPoint, szTempBuffer, sizeof(szTempBuffer))) AuroraThrow(Read32Exception, uInjectionPoint, sizeof(szTempBuffer));

			do {
				hde32s hde;
				hde32_disasm((const void*)szTempBuffer, &hde);
				dwInjectionSize += hde.len;
			} while (dwInjectionSize < Helpers::c_dwRelJmp32Size);

			// Copy original code into buffer.

			lpOriginalCode = new A_BYTE[dwInjectionSize];
			memcpy(lpOriginalCode, szTempBuffer, dwInjectionSize);

			// Create a trampoline with the size of the injection + the relative offset jump instruction + the original code if specified.

			lpTrampoline = lpTrampolineManager->CreateTrampoline(refInjectionCode.size() + Helpers::c_dwRelJmp32Size + (bKeepOverwrittenCode ? dwInjectionSize : 0));

			// Prepares the injection payload for the assembly patch.

			lpInjectionPayload = new A_BYTE[dwInjectionSize];
			lpInjectionPayload[0] = 0xE9;
			*(A_LPDWORD)&lpInjectionPayload[1] = Helpers::Rel32_JmpOffset32(uInjectionPoint, lpTrampoline->uTrampolineAddress);

			for (A_I32 i = 5; i < dwInjectionSize; i++)
				lpInjectionPayload[i] = 0x90; // Padding with nops.

			A_ADDR32 uIndexedAddress = lpTrampoline->uTrampolineAddress;

			// Writes overwritten code if specified.

			if (bKeepOverwrittenCode) {
				if (!WriteMemory(uIndexedAddress, lpOriginalCode, dwInjectionSize)) AuroraThrow(Write32Exception, uIndexedAddress, dwInjectionSize);
				uIndexedAddress += dwInjectionSize;
			}

			// Writes injection code.

			if (!WriteMemory(uIndexedAddress, refInjectionCode.szBytes, refInjectionCode.size())) AuroraThrow(Write32Exception, uIndexedAddress, refInjectionCode.size());
			uIndexedAddress += refInjectionCode.size();

			// Gets and writes relative jmp code.

			A_BYTE szJmpBackCode[Helpers::c_dwRelJmp32Size] = { 0xE9, 0x00, 0x00, 0x00, 0x00 };
			*(A_LPDWORD)&szJmpBackCode[1] = Helpers::Rel32_JmpOffset32(uIndexedAddress, uInjectionPoint + Helpers::c_dwRelJmp32Size);

			if (!WriteMemory(uIndexedAddress, szJmpBackCode, sizeof(szJmpBackCode))) AuroraThrow(Write32Exception, uIndexedAddress, Helpers::c_dwRelJmp32Size);

			AuroraContextEnd();
		}

		CodeInjection32(const CodeInjection32&) = delete;

		~CodeInjection32();

		/// <summary>
		/// Enables the code injection.
		/// </summary>
		/// <exception cref="Write32Exception"/>
		A_VOID Enable();

		/// <summary>
		/// Disables the code injection.
		/// </summary>
		/// <exception cref="Write32Exception"/>
		A_VOID Disable();
	};

	/// <summary>
	/// Used for injecting code at an address.
	/// </summary>
	class AURORA_API CodeInjection64 {
		TrampolineManager64* lpTrampolineManager;
		TrampolineDescriptor64* lpTrampoline;

		A_ADDR64 uInjectionPoint;
		A_LPBYTE lpInjectionPayload;
		A_LPBYTE lpOriginalCode;
		A_DWORD dwInjectionSize;

		HANDLE hProcess;

		A_BOOL bEnabled;

		A_BOOL ReadMemory(_In_a64_ A_ADDR64 uAddress, _Out_writes_bytes_(dwSize) A_LPVOID lpBuffer, _In_ A_DWORD dwSize) noexcept;
		A_BOOL WriteMemory(_In_a64_ A_ADDR64 uAddress, _In_reads_bytes_(dwSize) A_LPCVOID lpBuffer, _In_ A_DWORD dwSize) noexcept;

	public:
		CodeInjection64();

		/// <summary>
		/// Creates a code injection in the local process.
		/// </summary>
		/// <typeparam name="nSize">- The size of the injection.</typeparam>
		/// <param name="uInjectionPoint">- The address of the injection point.</param>
		/// <param name="refInjectionCode">- The code to inject.</param>
		/// <param name="bKeepOverwrittenCode">- Determines whether to keep the code overwritten by the jmp or not.</param>
		/// <exception cref="WindowsApiException"/>
		/// <exception cref="Read64Exception"/>
		/// <exception cref="Write64Exception"/>
		template<A_I32 nSize>
		CodeInjection64(
			_In_a64_ A_ADDR64 uInjectionPoint,
			_In_ const InstructionBytes<nSize>& refInjectionCode,
			_In_ A_BOOL bKeepOverwrittenCode = false
		) : lpTrampolineManager(nullptr), lpTrampoline(nullptr), lpInjectionPayload(nullptr), lpOriginalCode(nullptr), hProcess(nullptr), uInjectionPoint(uInjectionPoint), dwInjectionSize(0), bEnabled(false) {
			AuroraContextStart();

			// Create new trampoline manager.

			lpTrampolineManager = new TrampolineManager64();

			// Get size of overwritten instructions.

			A_BYTE szTempBuffer[32];
			if (!ReadMemory(uInjectionPoint, szTempBuffer, sizeof(szTempBuffer))) AuroraThrow(Read64Exception, uInjectionPoint, sizeof(szTempBuffer));

			do {
				hde64s hde;
				hde64_disasm((const void*)szTempBuffer, &hde);
				dwInjectionSize += hde.len;
			} while (dwInjectionSize < Helpers::c_dwRelJmp32Size);

			// Copy original code into buffer.

			lpOriginalCode = new A_BYTE[dwInjectionSize];
			memcpy(lpOriginalCode, szTempBuffer, dwInjectionSize);

			// Create a trampoline with the size of the injection + the relative offset jump instruction + the original code if specified.

			lpTrampoline = lpTrampolineManager->CreateTrampoline(refInjectionCode.size() + Helpers::c_dwRelJmp32Size + (bKeepOverwrittenCode ? dwInjectionSize : 0));

			// Prepares the injection payload for the assembly patch.

			lpInjectionPayload = new A_BYTE[dwInjectionSize];
			lpInjectionPayload[0] = 0xE9;
			*(A_LPDWORD)&lpInjectionPayload[1] = Helpers::Rel32_JmpOffset64(uInjectionPoint, lpTrampoline->uTrampolineAddress);

			for (A_I32 i = 5; i < dwInjectionSize; i++)
				lpInjectionPayload[i] = 0x90; // Padding with nops.

			A_ADDR64 uIndexedAddress = lpTrampoline->uTrampolineAddress;

			// Writes overwritten code if specified.

			if (bKeepOverwrittenCode) {
				if (!WriteMemory(uIndexedAddress, lpOriginalCode, dwInjectionSize)) AuroraThrow(Write64Exception, uIndexedAddress, dwInjectionSize);
				uIndexedAddress += dwInjectionSize;
			}

			// Writes injection code.

			if (!WriteMemory(uIndexedAddress, refInjectionCode.szBytes, refInjectionCode.size())) AuroraThrow(Write64Exception, uIndexedAddress, refInjectionCode.size());
			uIndexedAddress += refInjectionCode.size();

			// Gets and writes relative jmp code.

			A_BYTE szJmpBackCode[Helpers::c_dwRelJmp32Size] = { 0xE9, 0x00, 0x00, 0x00, 0x00 };
			*(A_LPDWORD)&szJmpBackCode[1] = Helpers::Rel32_JmpOffset64(uIndexedAddress, uInjectionPoint + Helpers::c_dwRelJmp32Size);

			if (!WriteMemory(uIndexedAddress, szJmpBackCode, sizeof(szJmpBackCode))) AuroraThrow(Write64Exception, uIndexedAddress, Helpers::c_dwRelJmp32Size);

			AuroraContextEnd();
		}

		/// <summary>
		/// Creates a code injection in a remote process.
		/// </summary>
		/// <typeparam name="nSize">- The size of the injection.</typeparam>
		/// <param name="refTargetProcess">- A reference to the target process.</param>
		/// <param name="uInjectionPoint">- The address of the injection point.</param>
		/// <param name="refInjectionCode">- The code to inject.</param>
		/// <param name="bKeepOverwrittenCode">- Determines whether to keep the code overwritten by the jmp or not.</param>
		/// <exception cref="WindowsApiException"/>
		/// <exception cref="Read64Exception"/>
		/// <exception cref="Write64Exception"/>
		template<A_I32 nSize>
		CodeInjection64(
			_In_ const ProcessInfo64& refTargetProcess,
			_In_a64_ A_ADDR64 uInjectionPoint,
			_In_ const InstructionBytes<nSize>& refInjectionCode,
			_In_ A_BOOL bKeepOverwrittenCode = false
		) : lpTrampolineManager(nullptr), lpTrampoline(nullptr), lpInjectionPayload(nullptr), lpOriginalCode(nullptr), hProcess(nullptr), uInjectionPoint(uInjectionPoint), dwInjectionSize(0), bEnabled(false) {
			AuroraContextStart();

			// Get handle to remote process if remote.

			hProcess = OpenSharedProcess(ProcessAccessFlags::Vm, false, refTargetProcess.GetProcessId());

			// Create new trampoline manager.

			lpTrampolineManager = new TrampolineManager64(refTargetProcess);

			// Get size of overwritten instructions.

			A_BYTE szTempBuffer[32];
			if (!ReadMemory(uInjectionPoint, szTempBuffer, sizeof(szTempBuffer))) AuroraThrow(Read64Exception, uInjectionPoint, sizeof(szTempBuffer));

			do {
				hde64s hde;
				hde64_disasm((const void*)szTempBuffer, &hde);
				dwInjectionSize += hde.len;
			} while (dwInjectionSize < Helpers::c_dwRelJmp32Size);

			// Copy original code into buffer.

			lpOriginalCode = new A_BYTE[dwInjectionSize];
			memcpy(lpOriginalCode, szTempBuffer, dwInjectionSize);

			// Create a trampoline with the size of the injection + the relative offset jump instruction + the original code if specified.

			lpTrampoline = lpTrampolineManager->CreateTrampoline(refInjectionCode.size() + Helpers::c_dwRelJmp32Size + (bKeepOverwrittenCode ? dwInjectionSize : 0));

			// Prepares the injection payload for the assembly patch.

			lpInjectionPayload = new A_BYTE[dwInjectionSize];
			lpInjectionPayload[0] = 0xE9;
			*(A_LPDWORD)&lpInjectionPayload[1] = Helpers::Rel32_JmpOffset64(uInjectionPoint, lpTrampoline->uTrampolineAddress);

			for (A_I32 i = 5; i < dwInjectionSize; i++)
				lpInjectionPayload[i] = 0x90; // Padding with nops.

			A_ADDR64 uIndexedAddress = lpTrampoline->uTrampolineAddress;

			// Writes overwritten code if specified.

			if (bKeepOverwrittenCode) {
				if (!WriteMemory(uIndexedAddress, lpOriginalCode, dwInjectionSize)) AuroraThrow(Write64Exception, uIndexedAddress, dwInjectionSize);
				uIndexedAddress += dwInjectionSize;
			}

			// Writes injection code.

			if (!WriteMemory(uIndexedAddress, refInjectionCode.szBytes, refInjectionCode.size())) AuroraThrow(Write64Exception, uIndexedAddress, refInjectionCode.size());
			uIndexedAddress += refInjectionCode.size();

			// Gets and writes relative jmp code.

			A_BYTE szJmpBackCode[Helpers::c_dwRelJmp32Size] = { 0xE9, 0x00, 0x00, 0x00, 0x00 };
			*(A_LPDWORD)&szJmpBackCode[1] = Helpers::Rel32_JmpOffset64(uIndexedAddress, uInjectionPoint + Helpers::c_dwRelJmp32Size);

			if (!WriteMemory(uIndexedAddress, szJmpBackCode, sizeof(szJmpBackCode))) AuroraThrow(Write64Exception, uIndexedAddress, Helpers::c_dwRelJmp32Size);

			AuroraContextEnd();
		}

		CodeInjection64(const CodeInjection64&) = delete;

		~CodeInjection64();

		/// <summary>
		/// Enables the code injection.
		/// </summary>
		/// <exception cref="Write64Exception"/>
		A_VOID Enable();

		/// <summary>
		/// Disables the code injection.
		/// </summary>
		/// <exception cref="Write64Exception"/>
		A_VOID Disable();
	};


#ifdef _WIN64
	/// <summary>
	/// Used for injecting code at an address.
	/// </summary>
	using CodeInjection = CodeInjection64;
#else
	/// <summary>
	/// Used for injecting code at an address.
	/// </summary>
	using CodeInjection = CodeInjection32;
#endif
}

#endif // !__AURORA_CODE_INJECTION_H__
```

`Artemis/Aurora/Color.h`:

```h
//------------------------------------------------------------------------>
// MIT License
// 
// Copyright (c) 2023 Artemis Group
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------>
// Aurora: https://github.com/ArtemisDevGroup/Aurora
// This file was authored by:
// @Astrea0014: https://github.com/Astrea0014
//------------------------------------------------------------------------>

#ifndef __AURORA_COLOR_H__
#define __AURORA_COLOR_H__

#include "Definitions.h"
#include "String.h"
#include "Vector.h"
#include "ConstexprMath.h"

#undef RGB

namespace Aurora {
	struct AURORA_API RGBA;
	struct AURORA_API HSL;
	struct AURORA_API HEX;

	/// <summary>
	/// Represents a color in amounts of red, green and blue in the ranges of 0 to 255.
	/// </summary>
	struct AURORA_API RGB {
		A_FL32 fR, fG, fB;

		constexpr RGB() noexcept : fR(0), fG(0), fB(0) {}

		/// <summary>
		/// Sets all fields to the value of fX.
		/// </summary>
		/// <param name="fX">- The value to set R, G and B to, ranging from 0 to 255.</param>
		constexpr RGB(_In_ A_FL32 fX) noexcept : fR(fX), fG(fX), fB(fX) {}

		/// <summary>
		/// Sets the values of the fields fR, fG and fB.
		/// </summary>
		/// <param name="fR">- The amount of red, ranging from 0 to 255.</param>
		/// <param name="fG">- The amount of green, ranging from 0 to 255.</param>
		/// <param name="fB">- The amount of blue, ranging from 0 to 255.</param>
		constexpr RGB(_In_ A_FL32 fR, _In_ A_FL32 fG, _In_ A_FL32 fB) noexcept : fR(fR), fG(fG), fB(fB) {}

		/// <summary>
		/// Returns a string representation of the color in a conventional format, e.g: 'rgb(r, g, b)'
		/// </summary>
		/// <param name="lpString">- A pointer to a buffer to receive the returned string.</param>
		/// <param name="dwSize">- The size of the buffer in characters.</param>
		A_VOID ToString(_Out_writes_z_(dwSize) A_LPSTR lpString, _In_ A_DWORD dwSize) const;

		/// <summary>
		/// Converts the current RGB instance into an equivalent RGBA instance.
		/// </summary>
		/// <returns>The current color in RGBA.</returns>
		AURORA_NDWR_PURE("ToRGBA") constexpr RGBA ToRGBA() const noexcept;

		/// <summary>
		/// Converts the current RGB instance into an equivalent HSL instance.
		/// </summary>
		/// <returns>The current color in HSL.</returns>
		AURORA_NDWR_PURE("ToHSL") constexpr HSL ToHSL() const noexcept;

		/// <summary>
		/// Converts the current RGB instance into an equivalent HEX instance.
		/// </summary>
		/// <returns>The current color in HEX.</returns>
		AURORA_NDWR_PURE("ToHex") constexpr HEX ToHex() const noexcept;

		AURORA_NDWR_PURE("operator RGBA") constexpr operator RGBA() const noexcept;
		AURORA_NDWR_PURE("operator HSL") constexpr operator HSL() const noexcept;
		AURORA_NDWR_PURE("operator HEX") constexpr operator HEX() const noexcept;
	};

	/// <summary>
	/// Represents a color in amouns of red, green and blue aswell as an opacity value (alpha) in ranges of 0 to 255.
	/// </summary>
	struct AURORA_API RGBA {
		A_FL32 fR, fG, fB, fA;

		constexpr RGBA() noexcept : fR(0), fG(0), fB(0), fA(0) {}

		/// <summary>
		/// Sets R, G and B to the value of fX and A to the value of fA.
		/// </summary>
		/// <param name="fX">- The value to set R, G and B to, ranging from 0 to 255.</param>
		/// <param name="fA">- The value to set A to, ranging from 0 to 255.</param>
		constexpr RGBA(_In_ A_FL32 fX, _In_ A_FL32 fA) noexcept : fR(fX), fG(fX), fB(fX), fA(fA) {}

		/// <summary>
		/// Sets the values of the fields fR, fG and fB.
		/// </summary>
		/// <param name="fR">- The amount of red, ranging from 0 to 255.</param>
		/// <param name="fG">- The amount of green, ranging from 0 to 255.</param>
		/// <param name="fB">- The amount of blue, ranging from 0 to 255.</param>
		/// <param name="fA">- The value to set A to, ranging from 0 to 255.</param>
		constexpr RGBA(_In_ A_FL32 fR, _In_ A_FL32 fG, _In_ A_FL32 fB, _In_ A_FL32 fA) noexcept : fR(fR), fG(fG), fB(fB), fA(fA) {}

		/// <summary>
		/// Returns a string representation of the color in a conventional format, e.g: 'rgba(r, g, b, a)'
		/// </summary>
		/// <param name="lpString">- A pointer to a buffer to receive the returned string.</param>
		/// <param name="dwSize">- The size of the buffer in characters.</param>
		A_VOID ToString(_Out_writes_z_(dwSize) A_LPSTR lpString, _In_ A_DWORD dwSize) const;

		/// <summary>
		/// Converts the current RGBA instance into an equivalent RGB instance.
		/// </summary>
		/// <returns>The current color in RGB.</returns>
		AURORA_NDWR_PURE("ToRGB") constexpr RGB ToRGB() const noexcept;

		/// <summary>
		/// Converts the current RGBA instance into an equivalent HSL instance.
		/// </summary>
		/// <returns>The current color in HSL.</returns>
		AURORA_NDWR_PURE("ToHSL") constexpr HSL ToHSL() const noexcept;

		/// <summary>
		/// Converts the current RGBA instance into an equivalent HEX instance.
		/// </summary>
		/// <returns>The current color in HEX.</returns>
		AURORA_NDWR_PURE("ToHex") constexpr HEX ToHex() const noexcept;

		AURORA_NDWR_PURE("operator RGB") constexpr operator RGB() const noexcept;
		AURORA_NDWR_PURE("operator HSL") constexpr operator HSL() const noexcept;
		AURORA_NDWR_PURE("operator HEX") constexpr operator HEX() const noexcept;
	};

	/// <summary>
	/// Represents a color in a hue measured in degrees (0 &#x2264; x &#60; 360) aswell as saturation, lightness and opacity (alpha) measured in percent (0 &#x2264; x &#x2264; 1).
	/// </summary>
	struct AURORA_API HSL {
		A_FL32 fHue, fSaturation, fLightness, fAlpha;

		constexpr HSL() noexcept : fHue(0.0f), fSaturation(0.0f), fLightness(0.0f), fAlpha(0.0f) {}

		/// <summary>
		/// Sets the hue, saturation, lightness and alpha.
		/// </summary>
		/// <param name="fHue">- The hue of the color. (0 &#x2264; x &#60; 360)</param>
		/// <param name="fSaturation">
		/// <para>- The saturation of the color. (0 &#x2264; x &#x2264; 1)</para>
		/// <para>A higher saturation produces a more vibrant color whilst a lower saturation creates a more washed out color.</para>
		/// </param>
		/// <param name="fLightness">- The lightness of the color. (0 &#x2264; x &#x2264; 1)</param>
		/// <param name="fAlpha">- The opacity of the color. (0 &#x2264; x &#x2264; 1)</param>
		constexpr HSL(_In_ A_FL32 fHue, _In_ A_FL32 fSaturation, _In_ A_FL32 fLightness, _In_ A_FL32 fAlpha = 1.f) noexcept : fHue(fHue), fSaturation(fSaturation), fLightness(fLightness), fAlpha(fAlpha) {}

		/// <summary>
		/// Returns a string representation of the color in a conventional format, e.g: 'hsl(h, s, l, a)'
		/// </summary>
		/// <param name="lpString">- A pointer to a buffer to receive the returned string.</param>
		/// <param name="dwSize">- The size of the buffer in characters.</param>
		A_VOID ToString(_Out_writes_z_(dwSize) A_LPSTR lpString, _In_ A_DWORD dwSize) const;

		/// <summary>
		/// Converts the current HSL instance into an equivalent RGB instance.
		/// </summary>
		/// <returns>The current color in RGB.</returns>
		AURORA_NDWR_PURE("ToRGB") constexpr RGB ToRGB() const noexcept;

		/// <summary>
		/// Converts the current HSL instance into an equivalent RGBA instance.
		/// </summary>
		/// <returns>The current color in RGBA.</returns>
		AURORA_NDWR_PURE("ToRGBA") constexpr RGBA ToRGBA() const noexcept;

		/// <summary>
		/// Converts the current HSL instance into an equivalent HEX instance.
		/// </summary>
		/// <returns>The current color in HEX.</returns>
		AURORA_NDWR_PURE("ToHex") constexpr HEX ToHex() const noexcept;

		AURORA_NDWR_PURE("operator RGB") constexpr operator RGB() const noexcept;
		AURORA_NDWR_PURE("operator RGBA") constexpr operator RGBA() const noexcept;
		AURORA_NDWR_PURE("operator HEX") constexpr operator HEX() const noexcept;
	};
	
	/// <summary>
	/// <para>Represents a color in amouns of red, green and blue aswell as an opacity value (alpha) in ranges of 0 to 255.</para>
	/// <para>Accepts and returns hexadecimal representations of color, e.g: '#FFF' for pure white, '#0000' for transparency, '#CECECE' for gray, '#FF00FFA0' for moderately opaque purple, et cetera.</para>
	/// </summary>
	struct AURORA_API HEX {
		A_FL32 fR, fG, fB, fA;

		constexpr HEX() noexcept : fR(0), fG(0), fB(0), fA(0) {}

		/// <summary>
		/// Initializes the R, G, B and A fields with values from the provided string.
		/// </summary>
		/// <param name="lpHexString">- The hex string to process.</param>
		HEX(_In_z_ A_LPCSTR lpHexString);

		/// <summary>
		/// <para>Returns a string representation of the color in a conventional format, e.g:</para>
		/// <para>- '#RGB' for colors where the alpha is 'FF' and cases where both digits of R, G and B are the same.</para>
		/// <para>* For example: '#FFF' for pure white, or '#000' for pure black.</para>
		/// <para>- '#RGBA' for colors where both digits of R, G, B and A are the same.</para>
		/// <para>* For example: '#FFF9' for moderately opaque white, or '#0000' for complete transparency.</para>
		/// <para>- '#RRGGBB' for colors where the alpha is 'FF'.</para>
		/// <para>- '#RRGGBBAA' for colors that do not fall under any of the previous cases.</para>
		/// </summary>
		/// <param name="lpString">- A pointer to a buffer to receive the returned string.</param>
		/// <param name="dwSize">- The size of the buffer in characters.</param>
		A_VOID ToString(_Out_writes_z_(dwSize) A_LPSTR lpString, _In_ A_DWORD dwSize) const;

		/// <summary>
		/// Converts the current HEX instance into an equivalent RGB instance.
		/// </summary>
		/// <returns>The current color in RGB.</returns>
		AURORA_NDWR_PURE("ToRGB") constexpr RGB ToRGB() const noexcept { return RGB(fR, fG, fB); }

		/// <summary>
		/// Converts the current HEX instance into an equivalent RGBA instance.
		/// </summary>
		/// <returns>The current color in RGBA.</returns>
		AURORA_NDWR_PURE("ToRGBA") constexpr RGBA ToRGBA() const noexcept { return RGBA(fR, fG, fB, fA); }

		/// <summary>
		/// Converts the current HEX instance into an equivalent HSL instance.
		/// </summary>
		/// <returns>The current color in HSL.</returns>
		AURORA_NDWR_PURE("ToHSL") constexpr HSL ToHSL() const noexcept { return RGBA(fR, fG, fB, fA).ToHSL(); }

		AURORA_NDWR_PURE("operator RGB") constexpr operator RGB() const noexcept { return this->ToRGB(); }
		AURORA_NDWR_PURE("operator RGBA") constexpr operator RGBA() const noexcept { return this->ToRGBA(); }
		AURORA_NDWR_PURE("operator HSL") constexpr operator HSL() const noexcept { return this->ToHSL(); }
	};

	// RGB constexpr definitions.

	constexpr RGBA RGB::ToRGBA() const noexcept { return RGBA(fR, fG, fB, 255.f); }

	constexpr HSL RGB::ToHSL() const noexcept {
		A_FL32 fMax = (A_FL32)Max(Max(fR, fG), fB);
		A_FL32 fMin = (A_FL32)Min(Min(fR, fG), fB);
		A_FL32 fDelta = (fMax - fMin) / 255.0f;

		A_FL32 fLightness = (fMax + fMin) / 510.0f;
		A_FL32 fSaturation = (0.0f < fLightness && 1.0f > fLightness) ? RoundF((fDelta / (1.0f - AbsoluteF(2.0f * fLightness - 1.0f))) * 100.0f) / 100.0f : 0.0f;

		A_FL32 fHue = fR == fG && fR == fB && fG == fB ? 0 : RoundF(RadiansToDegreesF(InverseCosineF((fR - HalfF(fG) - HalfF(fB)) / SquareRootF(SquaredF(fR) + SquaredF(fG) + SquaredF(fB) - fR * fG - fR * fB - fG * fB))));

		return HSL(fB > fG ? (360.0f - fHue) : fHue, fSaturation, fLightness);
	}

	constexpr HEX RGB::ToHex() const noexcept {
		HEX hex;
		hex.fR = fR;
		hex.fG = fG;
		hex.fB = fB;
		hex.fA = 0.f;
		return hex;
	}

	constexpr RGB::operator RGBA() const noexcept { return this->ToRGBA(); }
	constexpr RGB::operator HSL() const noexcept { return this->ToHSL(); }
	constexpr RGB::operator HEX() const noexcept { return this->ToHex(); }

	// RGBA constexpr definitions.

	constexpr RGB RGBA::ToRGB() const noexcept { return RGB(fR, fG, fB); }

	constexpr HSL RGBA::ToHSL() const noexcept {
		HSL hsl = ToRGB().ToHSL();
		hsl.fAlpha = fA / 255.f;
		return hsl;
	}

	constexpr HEX RGBA::ToHex() const noexcept {
		HEX hex;
		hex.fR = fR;
		hex.fG = fG;
		hex.fB = fB;
		hex.fA = fA;
		return hex;
	}

	constexpr RGBA::operator RGB() const noexcept { return this->ToRGB(); }
	constexpr RGBA::operator HSL() const noexcept { return this->ToHSL(); }
	constexpr RGBA::operator HEX() const noexcept { return this->ToHex(); }

	// HSL constexpr definitions.

	constexpr RGB HSL::ToRGB() const noexcept {
		A_FL32 fC = (1.0f - AbsoluteF(2.0f * fLightness - 1.0f)) * fSaturation;
		A_FL32 fX = fC * (1.0f - AbsoluteF(ModulusF(fHue / 60.0f, 2.0f) - 1.0f));
		A_FL32 fm = fLightness - fC / 2.f;

		A_FL32 fR, fG, fB;

		if (0.f <= fHue && fHue < 60.f) { fR = fC; fG = fX; fB = 0.f; }
		else if (60.f <= fHue && fHue < 120.f) { fR = fX; fG = fC; fB = 0.f; }
		else if (120.f <= fHue && fHue < 180.f) { fR = 0.f; fG = fC; fB = fX; }
		else if (180.f <= fHue && fHue < 240.f) { fR = 0.f; fG = fX; fB = fC; }
		else if (240.f <= fHue && fHue < 300.f) { fR = fX; fG = 0.f; fB = fC; }
		else if (300.f <= fHue && fHue < 360.f) { fR = fC; fG = 0.f; fB = fX; }
		else { fR = 0.f; fG = 0.f; fB = 0.f; }

		return RGB(
			RoundF((fR + fm) * 255.f),
			RoundF((fG + fm) * 255.f),
			RoundF((fB + fm) * 255.f)
		);
	}

	constexpr RGBA HSL::ToRGBA() const noexcept {
		RGB rgb = ToRGB();
		return RGBA(rgb.fR, rgb.fG, rgb.fR, fAlpha * 255.f);
	}

	constexpr HEX HSL::ToHex() const noexcept {
		return this->ToRGBA().ToHex();
	}

	constexpr HSL::operator RGB() const noexcept { return this->ToRGB(); }
	constexpr HSL::operator RGBA() const noexcept { return this->ToRGBA(); }
	constexpr HSL::operator HEX() const noexcept { return this->ToHex(); }

	namespace Colors {
		constexpr RGB AliceBlue(240, 248, 255);
		constexpr RGB AntiqueWhite(250, 235, 215);
		constexpr RGB Aqua(0, 255, 255);
		constexpr RGB Aquamarine(127, 255, 212);
		constexpr RGB Azure(240, 255, 255);
		constexpr RGB Beige(245, 245, 220);
		constexpr RGB Bisque(255, 228, 196);
		constexpr RGB Black(0, 0, 0);
		constexpr RGB BlancedAlmond(255, 235, 205);
		constexpr RGB Blue(0, 0, 255);
		constexpr RGB BlueViolet(138, 43, 226);
		constexpr RGB Brown = RGB(165, 42, 42);
		constexpr RGB BurlyWood = RGB(222, 184, 135);
		constexpr RGB CadetBlue = RGB(95, 158, 160);
		constexpr RGB Chartreuse = RGB(127, 255, 0);
		constexpr RGB Chocolate = RGB(210, 105, 30);
		constexpr RGB Coral = RGB(255, 127, 80);
		constexpr RGB CornflowerBlue = RGB(100, 149, 237);
		constexpr RGB Cornsilk = RGB(255, 248, 220);
		constexpr RGB Crimson = RGB(220, 20, 60);
		constexpr RGB Cyan = RGB(0, 255, 255);
		constexpr RGB DarkBlue = RGB(0, 0, 139);
		constexpr RGB DarkCyan = RGB(0, 139, 139);
		constexpr RGB DarkGoldenrod = RGB(184, 134, 11);
		constexpr RGB DarkGray = RGB(169, 169, 169);
		constexpr RGB DarkGreen = RGB(0, 100, 0);
		constexpr RGB DarkKhaki = RGB(189, 183, 107);
		constexpr RGB DarkMagenta = RGB(139, 0, 139);
		constexpr RGB DarkOliveGreen = RGB(85, 107, 47);
		constexpr RGB DarkOrange = RGB(255, 140, 0);
		constexpr RGB DarkRed = RGB(139, 0, 0);
		constexpr RGB DarkSalmon = RGB(233, 150, 122);
		constexpr RGB DarkSeaGreen = RGB(143, 188, 143);
		constexpr RGB DarkSlateBlue = RGB(72, 61, 139);
		constexpr RGB DarkSlateGray = RGB(47, 79, 79);
		constexpr RGB DarkTurquoise = RGB(0, 206, 209);
		constexpr RGB DarkViolet = RGB(148, 0, 211);
		constexpr RGB DeepPink = RGB(255, 20, 147);
		constexpr RGB DeepSkyBlue = RGB(0, 191, 255);
		constexpr RGB DimGray = RGB(105, 105, 105);
		constexpr RGB DodgerBlue = RGB(30, 144, 255);
		constexpr RGB Firebrick = RGB(178, 34, 34);
		constexpr RGB FloralWhite = RGB(255, 250, 240);
		constexpr RGB FloralGreen = RGB(181, 230, 190);
		constexpr RGB Fuchsia = RGB(255, 0, 255);
		constexpr RGB Gainsboro = RGB(220, 220, 220);
		constexpr RGB GhostWhite = RGB(248, 248, 255);
		constexpr RGB Gold = RGB(255, 215, 0);
		constexpr RGB Goldenrod = RGB(218, 165, 32);
		constexpr RGB Gray = RGB(128, 128, 128);
		constexpr RGB Green = RGB(0, 255, 0);
		constexpr RGB GreenYellow = RGB(173, 255, 47);
		constexpr RGB Honeydew = RGB(240, 255, 240);
		constexpr RGB HotPink = RGB(255, 105, 180);
		constexpr RGB IndianRed = RGB(205, 92, 92);
		constexpr RGB Indigo = RGB(75, 0, 130);
		constexpr RGB Ivory = RGB(255, 255, 240);
		constexpr RGB Lavender = RGB(230, 230, 250);
		constexpr RGB LavenderBlush = RGB(255, 240, 245);
		constexpr RGB LawnGreen = RGB(124, 252, 0);
		constexpr RGB LemonChiffon = RGB(255, 250, 205);
		constexpr RGB LightBlue = RGB(173, 216, 230);
		constexpr RGB LightCoral = RGB(240, 128, 128);
		constexpr RGB LightCyan = RGB(224, 255, 255);
		constexpr RGB LightGoldenrodYellow = RGB(250, 250, 210);
		constexpr RGB LightGray = RGB(211, 211, 211);
		constexpr RGB LightPink = RGB(255, 182, 193);
		constexpr RGB LightSalmon = RGB(255, 160, 122);
		constexpr RGB LightSeaGreen = RGB(32, 178, 170);
		constexpr RGB LightSkyBlue = RGB(135, 206, 250);
		constexpr RGB LightSlateGray = RGB(119, 136, 153);
		constexpr RGB LightSteelBlue = RGB(176, 196, 222);
		constexpr RGB LightYellow = RGB(255, 255, 224);
		constexpr RGB Lime = RGB(191, 255, 0);
		constexpr RGB LimeGreen = RGB(50, 205, 50);
		constexpr RGB Linen = RGB(250, 240, 230);
		constexpr RGB Magenta = RGB(255, 0, 255);
		constexpr RGB Maroon = RGB(128, 0, 0);
		constexpr RGB MediumAquamarine = RGB(102, 205, 170);
		constexpr RGB MediumBlue = RGB(0, 0, 205);
		constexpr RGB MediumOrchid = RGB(186, 85, 211);
		constexpr RGB MediumPurple = RGB(147, 112, 219);
		constexpr RGB MediumSeaGreen = RGB(60, 179, 113);
		constexpr RGB MediumSlateBlue = RGB(123, 104, 238);
		constexpr RGB MediumSpringGreen = RGB(0, 250, 154);
		constexpr RGB MediumTurquoise = RGB(72, 209, 204);
		constexpr RGB MediumVioletRed = RGB(199, 21, 133);
		constexpr RGB MidnightBlue = RGB(25, 25, 112);
		constexpr RGB MintCream = RGB(245, 255, 250);
		constexpr RGB MistyRose = RGB(255, 228, 225);
		constexpr RGB Moccasin = RGB(255, 228, 181);
		constexpr RGB NajavoWhite = RGB(255, 222, 173);
		constexpr RGB Navy = RGB(0, 0, 128);
		constexpr RGB OldLace = RGB(253, 245, 230);
		constexpr RGB Olive = RGB(128, 128, 0);
		constexpr RGB OliveDrab = RGB(107, 142, 35);
		constexpr RGB Orange = RGB(255, 165, 0);
		constexpr RGB OrangeRed = RGB(255, 69, 0);
		constexpr RGB Orchid = RGB(218, 112, 214);
		constexpr RGB PaleGoldenrod = RGB(238, 232, 170);
		constexpr RGB PaleGreen = RGB(152, 251, 152);
		constexpr RGB PaleTurquoise = RGB(175, 238, 238);
		constexpr RGB PaleVioletRed = RGB(219, 112, 147);
		constexpr RGB PapayaWhip = RGB(255, 239, 213);
		constexpr RGB PeachPuff = RGB(255, 218, 185);
		constexpr RGB Peru = RGB(205, 133, 63);
		constexpr RGB Pink = RGB(255, 192, 203);
		constexpr RGB Plum = RGB(221, 160, 221);
		constexpr RGB PowderBlue = RGB(176, 224, 230);
		constexpr RGB Purple = RGB(128, 0, 128);
		constexpr RGB Red = RGB(255, 0, 0);
		constexpr RGB RosyBrown = RGB(188, 143, 143);
		constexpr RGB RoyalBlue = RGB(65, 105, 225);
		constexpr RGB SaddleBrown = RGB(139, 69, 19);
		constexpr RGB Salmon = RGB(255, 140, 105);
		constexpr RGB SandyBrown = RGB(244, 164, 96);
		constexpr RGB SeaGreen = RGB(46, 139, 87);
		constexpr RGB SeaShell = RGB(255, 245, 238);
		constexpr RGB Sienna = RGB(136, 45, 23);
		constexpr RGB Silver = RGB(192, 192, 192);
		constexpr RGB SkyBlue = RGB(135, 206, 235);
		constexpr RGB SlateBlue = RGB(106, 90, 205);
		constexpr RGB SlateGray = RGB(112, 128, 144);
		constexpr RGB Snow = RGB(255, 250, 250);
		constexpr RGB SpringGreen = RGB(0, 255, 127);
		constexpr RGB SteelBlue = RGB(70, 130, 180);
		constexpr RGB Tan = RGB(210, 180, 140);
		constexpr RGB Teal = RGB(0, 128, 128);
		constexpr RGB Thistle = RGB(216, 191, 216);
		constexpr RGB Tomato = RGB(255, 99, 71);
		constexpr RGBA Transparent = RGBA(0, 0, 0, 0);
		constexpr RGB Turquoise = RGB(64, 224, 208);
		constexpr RGB Violet = RGB(238, 130, 238);
		constexpr RGB Wheat = RGB(245, 222, 179);
		constexpr RGB White = RGB(255, 255, 255);
		constexpr RGB WhiteSmoke = RGB(245, 245, 245);
		constexpr RGB Yellow = RGB(255, 255, 0);
		constexpr RGB YellowGreen = RGB(154, 205, 50);
	}
}

#endif // !__AURORA_COLOR_H__
```

`Artemis/Aurora/Console.h`:

```h
//------------------------------------------------------------------------>
// MIT License
// 
// Copyright (c) 2023 Artemis Group
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------>
// Aurora: https://github.com/ArtemisDevGroup/Aurora
// This file was authored by:
// @Astrea0014: https://github.com/Astrea0014
//------------------------------------------------------------------------>

#ifndef __AURORA_CONSOLE_H__
#define __AURORA_CONSOLE_H__

#include "Definitions.h"
#include "Exceptions.h"
#include "Color.h"

namespace Aurora {
	/// <summary>
	/// Represents a standard data stream.
	/// </summary>
	enum class StandardStream {
		Out,	// The stdout stream.
		In		// The stdin stream.
	};

	/// <summary>
	/// A set of flags representing a color from the 16-color console standard.
	/// </summary>
	struct ConsoleColorLegacyFlags {
		A_WORD wValue;

		enum Enumeration : A_WORD {
			Black = 0x0000,

			DarkRed = 0x0004,
			DarkGreen = 0x0002,
			DarkBlue = 0x0001,
			DarkGray = 0x0008,

			DarkCyan = DarkBlue | DarkGreen,
			DarkMagenta = DarkRed | DarkBlue,
			DarkYellow = DarkRed | DarkGreen,

			Gray = DarkRed | DarkGreen | DarkBlue,
			Red = DarkRed | DarkGray,
			Green = DarkGreen | DarkGray,
			Blue = DarkBlue | DarkGray,

			Cyan = DarkCyan | DarkGray,
			Magenta = DarkMagenta | DarkGray,
			Yellow = DarkYellow | DarkGray,
			White = DarkRed | DarkGreen | DarkBlue | DarkGray
		};

		constexpr ConsoleColorLegacyFlags() noexcept : wValue(0) {}
		constexpr ConsoleColorLegacyFlags(A_WORD wValue) noexcept : wValue(wValue) {}

		/// <summary>
		/// Gets a WORD representation of the color assigned to this instance to pass to SetConsoleTextAttribute to set the foreground.
		/// </summary>
		/// <returns>A WORD representing the foreground color.</returns>
		AURORA_NDWR_GET("GetForegroundLiteral") constexpr A_WORD GetForegroundLiteral() const noexcept { return wValue; }

		/// <summary>
		/// Gets a WORD representation of the color assigned to this instace to pass to SetConsoleTextAttribute to set the background.
		/// </summary>
		/// <returns>A WORD representing the background color.</returns>
		AURORA_NDWR_GET("GetBackgroundLiteral") constexpr A_WORD GetBackgroundLiteral() const noexcept { return wValue << 4; }
	};

	/// <summary>
	/// Creates a console window if the process does not already have one open.
	/// </summary>
	/// <exception cref="WindowsApiException"/>
	AURORA_API A_VOID CreateConsole();

	/// <summary>
	/// Releases the console window. If the console window was not manually created,
	/// calling this function is unnecessary.
	/// </summary>
	/// <exception cref="WindowsApiException"/>
	AURORA_API A_VOID ReleaseConsole();

	/// <summary>
	/// Opens the specified standard stream for being used in console in or out operations.
	/// </summary>
	/// <param name="Stream">- The stream to open.</param>
	/// <exception cref="ErrnoException"/>
	/// <exception cref="ParameterInvalidException"/>
	AURORA_API A_VOID OpenStream(_In_ StandardStream Stream);

	/// <summary>
	/// <para>Closes the specified standard stream from being used in console in or out operations.</para>
	/// <para>If the standard stream was not manually opened, this function does nothing.</para>
	/// </summary>
	/// <param name="Stream">- The stream to close.</param>
	/// <exception cref="ErrnoException"/>
	/// <exception cref="ParameterInvalidException"/>
	AURORA_API A_VOID CloseStream(_In_ StandardStream Stream);

	/// <summary>
	/// <para>Closes all opened standard streams from being used in console in or out operations.</para>
	/// <para>If the standard stream was not manually opened, this function does nothing.</para>
	/// </summary>
	/// <exception cref="ErrnoException"/>
	/// <exception cref="ParameterInvalidException"/>
	AURORA_API A_VOID CloseAllStreams();

	/// <summary>
	/// <para>Sets the foreground color of the console. This function only works with applications ran in a TrueColor enabled terminal.</para>
	/// <para>For example: Windows Terminal is TrueColor enabled, whereas the Legacy Windows Command Prompt is not.</para>
	/// </summary>
	/// <param name="TrueColor">- The color to set the foreground to, in RGB.</param>
	AURORA_API A_VOID SetConsoleForegroundColor(_In_ const RGB& TrueColor);

	/// <summary>
	/// <para>Resets the foreground color of the console. This function only works with applications ran in a TrueColor enabled terminal.</para>
	/// <para>For example: Windows Terminal is TrueColor enabled, whereas the Legacy Windows Command Prompt is not.</para>
	/// </summary>
	AURORA_API A_VOID ResetConsoleForegroundColor();

	/// <summary>
	/// <para>Sets the background color of the console. This function only works with applications ran in a TrueColor enabled terminal.</para>
	/// <para>For example: Windows Terminal is TrueColor enabled, whereas the Legacy Windows Command Prompt is not.</para>
	/// </summary>
	/// <param name="TrueColor">- The color to set the foreground to, in RGB.</param>
	AURORA_API A_VOID SetConsoleBackgroundColor(_In_ const RGB& TrueColor);

	/// <summary>
	/// <para>Resets the background color of the console. This function only works with applications ran in a TrueColor enabled terminal.</para>
	/// <para>For example: Windows Terminal is TrueColor enabled, whereas the Legacy Windows Command Prompt is not.</para>
	/// </summary>
	AURORA_API A_VOID ResetConsoleBackgroundColor();

	/// <summary>
	/// Sets the foreground color of the console. Supports all windows terminals.
	/// </summary>
	/// <param name="wColorFlags">- The colors to set.</param>
	/// <exception cref="WindowsApiException"/>
	AURORA_API A_VOID SetConsoleForegroundColorLegacy(_In_ ConsoleColorLegacyFlags wColorFlags);

	/// <summary>
	/// Sets the background color of the console. Supports all windows terminals.
	/// </summary>
	/// <param name="wColorFlags">- The colors to set.</param>
	/// <exception cref="WindowsApiException"/>
	AURORA_API A_VOID SetConsoleBackgroundColorLegacy(_In_ ConsoleColorLegacyFlags wColorFlags);
}

#endif // !__AURORA_CONSOLE_H__
```

`Artemis/Aurora/ConstexprMath.h`:

```h
//------------------------------------------------------------------------>
// MIT License
// 
// Copyright (c) 2023 Artemis Group
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------>
// Aurora: https://github.com/ArtemisDevGroup/Aurora
// This file was authored by:
// @Astrea0014: https://github.com/Astrea0014
//------------------------------------------------------------------------>

#ifndef __AURORA_CONSTEXPR_MATH_H__
#define __AURORA_CONSTEXPR_MATH_H__

#include <limits>

#include "Definitions.h"

namespace Aurora {
	constexpr A_FL32 PiF = 3.1415927f;
	constexpr A_FL64 Pi = 3.141592653589793;

	namespace Helpers {
		AURORA_NDWR_PURE("SquareRootNewtonRaphson") constexpr A_FL64 SquareRootNewtonRaphson(A_FL64 x, A_FL64 fCurrent, A_FL64 fPrevious) noexcept { return fCurrent == fPrevious ? fCurrent : SquareRootNewtonRaphson(x, 0.5 * (fCurrent + x / fCurrent), fCurrent); }

        AURORA_NDWR_PURE("InverseTangentSeriesOrderCalculation") constexpr A_FL64 InverseTangentSeriesOrderCalculation(A_FL64 x, A_FL64 xPower, A_U32 uOrder) noexcept { return(1.0 / ((A_FL64)((uOrder - 1) * 4 - 1) * xPower) - 1.0 / ((A_FL64)((uOrder - 1) * 4 + 1) * xPower * x)); }
		AURORA_NDWR_PURE("InverseTangentSeriesOrder") constexpr A_FL64 InverseTangentSeriesOrder(A_FL64 x, A_FL64 xPower, A_U32 uOrder, A_U32 uMaxOrder) noexcept { return(uOrder == 1 ? (Pi / 2.L) - 1.L / x + InverseTangentSeriesOrder(x * x, x * x * x, uOrder + 1, uMaxOrder) : uOrder < uMaxOrder ? InverseTangentSeriesOrderCalculation(x, xPower, uOrder) + InverseTangentSeriesOrder(x, xPower * x * x, uOrder + 1, uMaxOrder) : InverseTangentSeriesOrderCalculation(x, xPower, uOrder)); }

		AURORA_NDWR_PURE("InverseTangentSeries") constexpr A_FL64 InverseTangentSeries(A_FL64 x) noexcept {
            return(x < 3.L ? InverseTangentSeriesOrder(x, x, 1U, 10U) :
                x < 4.L ? InverseTangentSeriesOrder(x, x, 1U, 9U) :
                x < 5.L ? InverseTangentSeriesOrder(x, x, 1U, 8U) :
                x < 7.L ? InverseTangentSeriesOrder(x, x, 1U, 7U) :
                x < 11.L ? InverseTangentSeriesOrder(x, x, 1U, 6U) :
                x < 25.L ? InverseTangentSeriesOrder(x, x, 1U, 5U) :
                x < 100.L ? InverseTangentSeriesOrder(x, x, 1U, 4U) :  
                x < 1000.L ? InverseTangentSeriesOrder(x, x, 1U, 3U) : 
                InverseTangentSeriesOrder(x, x, 1U, 2U));
        }

		AURORA_NDWR_PURE("InverseTangentCFRecursive") constexpr A_FL64 InverseTangentCFRecursive(A_FL64 xx, A_U32 uDepth, A_U32 uMaxDepth) noexcept { return(uDepth < uMaxDepth ? (A_FL64)(2 * uDepth - 1) + uDepth * uDepth * xx / InverseTangentCFRecursive(xx, uDepth + 1, uMaxDepth) : (A_FL64)(2 * uDepth - 1)); }
		AURORA_NDWR_PURE("InverseTangentCF") constexpr A_FL64 InverseTangentCF(A_FL64 x) noexcept { return(x < 0.5L ? x / InverseTangentCFRecursive(x * x, 1U, 15U) : x < 1.L ? x / InverseTangentCFRecursive(x * x, 1U, 25U) : x < 1.5L ? x / InverseTangentCFRecursive(x * x, 1U, 35U) : x < 2.L ? x / InverseTangentCFRecursive(x * x, 1U, 45U) : x / InverseTangentCFRecursive(x * x, 1U, 52U)); }

		AURORA_NDWR_PURE("InverseTangentCalculate") constexpr A_FL64 InverseTangentCalculate(A_FL64 x) noexcept { return(x > 2.5L ? InverseTangentSeries(x) : InverseTangentCF(x)); }
	}

	AURORA_NDWR_PURE("SquaredF") constexpr A_FL32 SquaredF(A_FL32 x) noexcept { return x * x; }
	AURORA_NDWR_PURE("Squared") constexpr A_FL64 Squared(A_FL64 x) noexcept { return x * x; }
	AURORA_NDWR_PURE("SquaredN") constexpr A_I32 SquaredN(A_I32 x) noexcept { return x * x; }
	AURORA_NDWR_PURE("SquaredL") constexpr A_I64 SquaredL(A_I64 x) noexcept { return x * x; }
	AURORA_NDWR_PURE("SquareRootF") constexpr A_FL32 SquareRootF(A_FL32 x) noexcept { return x >= 0 && x < std::numeric_limits<float>::infinity() ? static_cast<A_FL32>(Helpers::SquareRootNewtonRaphson(x, x, 0)) : std::numeric_limits<float>::quiet_NaN(); }
	AURORA_NDWR_PURE("SquareRoot") constexpr A_FL64 SquareRoot(A_FL64 x) noexcept { return x >= 0 && x < std::numeric_limits<double>::infinity() ? Helpers::SquareRootNewtonRaphson(x, x, 0) : std::numeric_limits<double>::quiet_NaN(); }
	AURORA_NDWR_PURE("Max") constexpr A_FL64 Max(A_FL64 x, A_FL64 y) noexcept { return x > y ? x : y; }
	AURORA_NDWR_PURE("Min") constexpr A_FL64 Min(A_FL64 x, A_FL64 y) noexcept { return x < y ? x : y; }
	AURORA_NDWR_PURE("AbsoluteF") constexpr A_FL32 AbsoluteF(A_FL32 x) noexcept { return x >= 0.0 ? x : -x; }
	AURORA_NDWR_PURE("Absolute") constexpr A_FL64 Absolute(A_FL64 x) noexcept { return x >= 0.0 ? x : -x; }
	AURORA_NDWR_PURE("AbsoluteN") constexpr A_I32 AbsoluteN(A_I32 x) noexcept { return x >= 0 ? x : -x; }
	AURORA_NDWR_PURE("AbsoluteL") constexpr A_I64 AbsoluteL(A_I64 x) noexcept { return x >= 0 ? x : -x; }
	AURORA_NDWR_PURE("HalfF") constexpr A_FL32 HalfF(A_FL32 x) noexcept { return x / 2.0f; }
	AURORA_NDWR_PURE("Half") constexpr A_FL64 Half(A_FL64 x) noexcept { return x / 2.0; }
	AURORA_NDWR_PURE("RadiansToDegreesF") constexpr A_FL32 RadiansToDegreesF(A_FL32 x) noexcept { return x * 180.0f / PiF; }
	AURORA_NDWR_PURE("RadiansToDegrees") constexpr A_FL64 RadiansToDegrees(A_FL64 x) noexcept { return x * 180.0 / Pi; }
	AURORA_NDWR_PURE("Sign") constexpr A_FL64 Sign(A_FL64 x) noexcept { return x == 0 ? 0 : x > 0 ? 1 : x < 0 ? -1 : 0; }
	AURORA_NDWR_PURE("RoundF") constexpr A_FL32 RoundF(A_FL32 x) noexcept { return x - static_cast<A_FL32>(static_cast<A_I32>(x)) >= 0.5f ? static_cast<A_FL32>(static_cast<A_I32>(x)) + 1.f : static_cast<A_FL32>(static_cast<A_I32>(x)); }
	AURORA_NDWR_PURE("Round") constexpr A_FL64 Round(A_FL64 x) noexcept { return x - static_cast<A_FL64>(static_cast<A_I64>(x)) >= 0.5f ? static_cast<A_FL64>(static_cast<A_I64>(x)) + 1.f : static_cast<A_FL64>(static_cast<A_I64>(x)); }
	AURORA_NDWR_PURE("ModulusF") constexpr A_FL32 ModulusF(A_FL32 x, A_FL32 y) noexcept { return x - static_cast<A_I64>(x / y) * y; }
	AURORA_NDWR_PURE("Modulus") constexpr A_FL64 Modulus(A_FL64 x, A_FL64 y) noexcept { return x - static_cast<A_I64>(x / y) * y; }
	AURORA_NDWR_PURE("InverseTangentF") constexpr A_FL32 InverseTangentF(A_FL32 x) noexcept { return FLT_MIN > AbsoluteF(x) ? 0.0f : x < 0.0f ? static_cast<A_FL32>(Helpers::InverseTangentCalculate(-x)) : static_cast<A_FL32>(Helpers::InverseTangentCalculate(x)); }
	AURORA_NDWR_PURE("InverseTangent") constexpr A_FL64 InverseTangent(A_FL64 x) noexcept { return DBL_MIN > Absolute(x) ? 0.L : x < 0.L ? Helpers::InverseTangentCalculate(-x) : Helpers::InverseTangentCalculate(x); }
	AURORA_NDWR_PURE("InverseCosineF") constexpr A_FL32 InverseCosineF(A_FL32 x) noexcept { return FLT_MIN > AbsoluteF(x - 1.0f) ? 0.0f : FLT_MIN > AbsoluteF(x) ? Pi / 2.0f : InverseTangentF(SquareRootF(1.0f - SquaredF(x)) / x); }
	AURORA_NDWR_PURE("InverseCosine") constexpr A_FL64 InverseCosine(A_FL64 x) noexcept { return DBL_MIN > Absolute(x - 1.L) ? 0.L : DBL_MIN > Absolute(x) ? Pi / 2.L : InverseTangent(SquareRoot(1.L - Squared(x)) / x); }
	AURORA_NDWR_PURE("Delta") constexpr A_FL64 Delta(A_FL64 x, A_FL64 y) noexcept { return x - y; }
}

#endif // !__AURORA_CONSTEXPR_MATH_H__
```

`Artemis/Aurora/Definitions.h`:

```h
//------------------------------------------------------------------------>
// MIT License
// 
// Copyright (c) 2023 Artemis Group
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------>
// Aurora: https://github.com/ArtemisDevGroup/Aurora
// This file was authored by:
// @Astrea0014: https://github.com/Astrea0014
//------------------------------------------------------------------------>

#ifndef __AURORA_DEFINITIONS_H__
#define __AURORA_DEFINITIONS_H__

#include <sal.h>

// ---------- Macro functions ----------

#define MSB(T) ((T)(1 << (sizeof(T) * 8 - 1)))	// Gets the most significant bit of the specified type.
#define LSB(T) ((T)1)							// Gets the least significant bit of the specified type.

// ---------- Import / Export macros ----------

#define AURORA_EXPORT __declspec(dllexport)
#define AURORA_IMPORT __declspec(dllimport)

#ifdef _AURORA_EXPORT
#define AURORA_API AURORA_EXPORT
#else
#define AURORA_API AURORA_IMPORT
#endif

// ---------- SAL annotations ----------

#define _In_a32_ _In_range_(0x10000U, 0x7FFEFFFFU)
#define _In_opt_a32_(n) _When_(_Param_(n) != 0, _In_a32_)

#define _In_a64_ _In_range_(0x10000U, 0x7FFFFFFEFFFFUi64)
#define _In_opt_a64_(n) _When_(_Param_(n) != 0, _In_a64_)

#ifdef _WIN64
#define _In_a_ _In_a64_
#define _In_opt_a_(n) _In_opt_a64_(n)
#else
#define _In_a_ _In_a32_
#define _In_opt_a_(n) _In_opt_a32_(n)
#endif // _WIN64

// ---------- Predefined constants ----------

#ifndef MAX_PATH
// The maximum number of characters in a valid file path.
#define MAX_PATH 260
#endif // !MAX_PATH

#ifndef MAX_NAME
// The maximum number of characters in a name.
#define MAX_NAME 128
#endif // !MAX_NAME

#ifndef MAX_MSG
// The maximum number of characers in a message.
#define MAX_MSG 256
#endif // !MAX_MSG

#ifndef MAX_INVOKE
// The maximum number of invokable objects registered per instance.
#define MAX_INVOKE 64
#endif // !MAX_INVOKE

// The value of an invalid index.
#define INVALID_INDEX (-1)

// ---------- Miscellaneous macros ----------

// Declares that the functions return value or return value of class or enum type shall not be discarded.
#define AURORA_ND [[nodiscard]]

// Declares that the functions return value or return value of class or enum type shall not be discarded. Additionally specifies a reason.
#define AURORA_NDWR(reason) [[nodiscard(reason)]]

#define AURORA_NDWR_GET(name) AURORA_NDWR("Call to getter '" name "' unnecesary if return value is discarded.")
#define AURORA_NDWR_PURE(name) AURORA_NDWR("Call to pure function '" name "' unnecessary if return value is discarded; function has no side effects.")
#define AURORA_NDWR_DISP(name) AURORA_NDWR("Call to function '" name "' returns a disposable resource; discarding return value leads to resource leaks.")
#define AURORA_NDWR_CREATE(name) AURORA_NDWR("Call to function '" name "' constructs and returns an object as its only operation; discarding this value makes operation obsolete.")

// ---------- Generic and no-return types ----------

// A void. Used to indicate a function not having a return value, Eg: 'void foo();'. Also used to indicate that a function does not have any parameters (in legacy C), Eg: 'int foo(void);'
#define A_VOID void
// A void pointer. Generally used as an out pointer of a generic type. Is prefixed as 'lp'.
typedef A_VOID* A_LPVOID;
// A constant void pointer. Generally used as an in pointer of a generic type. Is prefixed as 'lp'.
typedef const A_VOID* A_LPCVOID;

// ---------- Character and string types ----------

// An ANSI character, prefixed as 'c'.
typedef char A_CHAR;
// An ANSI character pointer, prefixed as 'lp'.
typedef char* A_LPCHAR;
// An ANSI character pointer. Used for string buffers and is prefixed as 'lp'.
typedef char* A_LPSTR;
// A constant ANSI character pointer. Used for strings and is prefixed as 'lp'.
typedef const char* A_LPCSTR;

// A UTF-16LE character, prefixed as 'wc'.
typedef wchar_t A_WCHAR;
// A UTF-16LE character pointer, prefixed as 'lp'.
typedef wchar_t* A_LPWCHAR;
// A UTF-16LE character pointer. Used for wide string buffers and is prefixed as 'lp'.
typedef wchar_t* A_LPWSTR;
// A UTF-16LE character pointer. Used for wide strings and is prefixed as 'lp'.
typedef const wchar_t* A_LPCWSTR;

// ---------- Boolean types ----------

// A boolean, prefixed as 'b'.
typedef bool A_BOOL;
// A boolean pointer, prefixed as 'lp'.
typedef bool* A_LPBOOL;
// A constant boolean pointer, prefixed as 'lp'.
typedef const bool* A_LPCBOOL;

// ---------- Signed integral types ----------

// An 8-bit signed integer, prefixed as 'n'.
typedef signed __int8 A_I8;
// A 16-bit signed integer, prefixed as 'n'.
typedef signed __int16 A_I16;
// A 32-bit signed integer, prefixed as 'n'.
typedef signed __int32 A_I32;
// A 64-bit signed integer, prefixed as 'n'.
typedef signed __int64 A_I64;

// An 8-bit signed integer pointer, prefixed as 'lp'.
typedef A_I8* A_LPI8;
// A 16-bit signed integer pointer, prefixed as 'lp'.
typedef A_I16* A_LPI16;
// A 32-bit signed integer pointer, prefixed as 'lp'.
typedef A_I32* A_LPI32;
// A 64-bit signed integer pointer, prefixed as 'lp'.
typedef A_I64* A_LPI64;

// A constant 8-bit signed integer pointer, prefixed as 'lp'.
typedef const A_I8* A_LPCI8;
// A constant 16-bit signed integer pointer, prefixed as 'lp'.
typedef const A_I16* A_LPCI16;
// A constant 32-bit signed integer pointer, prefixed as 'lp'.
typedef const A_I32* A_LPCI32;
// A constant 64-bit signed integer pointer, prefixed as 'lp'.
typedef const A_I64* A_LPCI64;

// ---------- Unsigned integral types ----------

// An 8-bit unsigned integer, prefixed as 'u'.
typedef unsigned __int8 A_U8;
// A 16-bit unsigned integer, prefixed as 'u'.
typedef unsigned __int16 A_U16;
// A 32-bit unsigned integer, prefixed as 'u'.
typedef unsigned __int32 A_U32;
// A 64-bit unsigned integer, prefixed as 'u'.
typedef unsigned __int64 A_U64;

// An 8-bit unsigned integer pointer, prefixed as 'lp'.
typedef A_U8* A_LPU8;
// A 16-bit unsigned integer pointer, prefixed as 'lp'.
typedef A_U16* A_LPU16;
// A 32-bit unsigned integer pointer, prefixed as 'lp'.
typedef A_U32* A_LPU32;
// A 64-bit unsigned integer pointer, prefixed as 'lp'.
typedef A_U64* A_LPU64;

// A constant 8-bit unsigned integer pointer, prefixed as 'lp'.
typedef const A_U8* A_LPCU8;
// A constant 16-bit unsigned integer pointer, prefixed as 'lp'.
typedef const A_U16* A_LPCU16;
// A constant 32-bit unsigned integer pointer, prefixed as 'lp'.
typedef const A_U32* A_LPCU32;
// A constant 64-bit unsigned integer pointer, prefixed as 'lp'.
typedef const A_U64* A_LPCU64;

// ---------- BYTE, WORD, DWORD and QWORD types ----------

// An 8-bit unsigned integer, prefixed as 'u'.
typedef unsigned char A_BYTE;
// A 16-bit unsigned integer, prefixed as 'w'.
typedef unsigned short A_WORD;
// A 32-bit unsigned integer, prefixed as 'dw'.
typedef unsigned long A_DWORD;
// A 64-bit unsigned integer, prefixed as 'qw'.
typedef unsigned long long A_QWORD;

// An 8-bit unsigned integer pointer, prefixed as 'lp'.
typedef A_BYTE* A_LPBYTE;
// A 16-bit unsigned integer pointer, prefixed as 'lp'.
typedef A_WORD* A_LPWORD;
// A 32-bit unsigned integer pointer, prefixed as 'lp'.
typedef A_DWORD* A_LPDWORD;
// A 64-bit unsigned integer pointer, prefixed as 'lp'.
typedef A_QWORD* A_LPQWORD;

// A constant 8-bit unsigned integer pointer, prefixed as 'lp'.
typedef const A_BYTE* A_LPCBYTE;
// A constant 16-bit unsigned integer pointer, prefixed as 'lp'.
typedef const A_WORD* A_LPCWORD;
// A constant 32-bit unsigned integer pointer, prefixed as 'lp'.
typedef const A_DWORD* A_LPCDWORD;
// A constant 64-bit unsigned integer pointer, prefixed as 'lp'.
typedef const A_QWORD* A_LPCQWORD;

// ---------- Floating point types ----------

// A 32-bit floating point, prefixed as 'f'.
typedef float A_FL32;
// A 64-bit floating point, prefixed as 'f'.
typedef double A_FL64;

// A 32-bit floating point pointer, prefixed as 'lp'.
typedef A_FL32* A_LPFL32;
// A 64-bit floating point pointer, prefixed as 'lp'.
typedef A_FL64* A_LPFL64;

// A constant 32-bit floating point pointer, prefixed as 'lp'.
typedef const A_FL32* A_LPCFL32;
// A constant 64-bit floating point pointer, prefixed as 'lp'.
typedef const A_FL64* A_LPCFL64;

// ---------- Integral address types ----------

// An integral representation of an address pointing to a virtual memory location in a 32-bit process. Prefixed as 'u'.
typedef unsigned __int32 A_ADDR32;
// An integral representation of an address pointing to a virtual memory location in a 64-bit process. Prefixed as 'u'.
typedef unsigned __int64 A_ADDR64;

// A pointer to an integral representation of an address pointing to a virtual memory location in a 32-bit process. Prefixed as 'lp'.
typedef A_ADDR32* A_LPADDR32;
// A pointer to an integral representation of an address pointing to a virtual memory location in a 64-bit process. Prefixed as 'lp'.
typedef A_ADDR64* A_LPADDR64;

// A constant pointer to an integral representation of an address pointing to a virtual memory location in a 32-bit process. Prefixed as 'lp'.
typedef const A_ADDR32* A_LPCADDR32;
// A constant pointer to an integral representation of an address pointing to a virtual memory location in a 64-bit process. Prefixed as 'lp'.
typedef const A_ADDR64* A_LPCADDR64;

#ifdef _WIN64
// An integral representation of an address pointing to a virtual memory location in a 64-bit process. Prefixed as 'u'.
typedef A_ADDR64 A_ADDR;
// A pointer to an integral representation of an address pointing to a virtual memory location in a 64-bit process. Prefixed as 'lp'.
typedef A_ADDR64* A_LPADDR;
// A constant pointer to an integral representation of an address pointing to a virtual memory location in a 64-bit process. Prefixed as 'lp'.
typedef const A_ADDR64* A_LPCADDR;
#else
// An integral representation of an address pointing to a virtual memory location in a 32-bit process. Prefixed as 'u'.
typedef A_ADDR32 A_ADDR;
// A pointer to an integral representation of an address pointing to a virtual memory location in a 32-bit process. Prefixed as 'lp'.
typedef A_ADDR32* A_LPADDR;
// A constant pointer to an integral representation of an address pointing to a virtual memory location in a 32-bit process. Prefixed as 'lp'.
typedef const A_ADDR32* A_LPCADDR;
#endif // _WIN64

// ---------- Concepts ----------

#include <type_traits>
#include <concepts>

namespace Aurora {
	// A null class type and object.
	constexpr class NullClass_t {} NullClass;

	// A concept that restrains a Read functions from returning a void to avoid weird compiler errors.
	template<typename T> concept ReadReturnType = !std::is_same<T, void>::value;

	// A concept that restrains a Write functions from accepting a void as a parameter to avoid weird compiler errors.
	template<typename T> concept WriteDataType = !std::is_same<T, void>::value;
	
	// A concept that restrains a type to either one of two address types.
	template<typename T> concept AddressType = std::is_same<T, A_ADDR32>::value || std::is_same<T, A_ADDR64>::value;

	// A concept that restrains a template type from being void.
	template<typename T> concept NonVoidType = !std::is_same<T, void>::value;

	// A concept that restrains a template type to exclusively accepting enumerations.
	template<typename T> concept EnumerationType = std::is_enum<T>::value;

	// A concept that restains a template type to exclusively accepting integrals.
	template<typename T> concept IntegralType = std::is_integral<T>::value;

	// A concept that restrains a template type to exclusively accepting classes.
	template<typename T> concept ClassType = std::is_class<T>::value;

	// A concept that restrains a template type to have full arithmetic capability, excluding modulus.
	template<typename T> concept ArithmeticType = requires(T a) {
		{ a + a } -> std::convertible_to<T>;
		{ a - a } -> std::convertible_to<T>;
		{ a * a } -> std::convertible_to<T>;
		{ a / a } -> std::convertible_to<T>;

		{ a += a } -> std::convertible_to<T>;
		{ a -= a } -> std::convertible_to<T>;
		{ a *= a } -> std::convertible_to<T>;
		{ a /= a } -> std::convertible_to<T>;
	};

	// A concept that restrains a template type to have full arithmetic capability aswell as full bitwise capability.
	template<typename T> concept BitwiseType = ArithmeticType<T> && requires(T a) {
		{ a ^ a } -> std::convertible_to<T>;
		{ a & a } -> std::convertible_to<T>;
		{ a | a } -> std::convertible_to<T>;
		{ a % a } -> std::convertible_to<T>;
		{ a << a } -> std::convertible_to<T>;
		{ a >> a } -> std::convertible_to<T>;
		{ ~a } -> std::convertible_to<T>;

		{ a ^= a } -> std::convertible_to<T>;
		{ a &= a } -> std::convertible_to<T>;
		{ a |= a } -> std::convertible_to<T>;
		{ a %= a } -> std::convertible_to<T>;
	};

	// A struct that determines whether the templated type is a function pointer or not.
	template<typename T> struct IsFunctionPtr { static constexpr bool value = false; };

	// A struct that determines whether the templated type is a function pointer or not.
	template<typename R, typename... A> struct IsFunctionPtr<R(*)(A...)> { static constexpr bool value = true; };

	// A bool that determines whether the templated type is a function pointer or not.
	template<typename T> constexpr bool IsFunctionPtr_v = IsFunctionPtr<T>::value;

	// A concept that restrains a template type to only be a function pointer.
	template<typename T> concept FunctionPtrType = IsFunctionPtr_v<T>;
}

// ---------- Functions ----------

#include <functional>

namespace Aurora {
	/// <summary>
	/// A function pointer or lambda expression.
	/// </summary>
	/// <typeparam name="T">- A function template, syntaxed: ReturnType(ParameterType...).</typeparam>
	template<typename T>
	using Function = std::function<T>;
}

#endif // !__AURORA_DEFINITIONS_H__
```

`Artemis/Aurora/DllInjection.h`:

```h
//------------------------------------------------------------------------>
// MIT License
// 
// Copyright (c) 2023 Artemis Group
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------>
// Aurora: https://github.com/ArtemisDevGroup/Aurora
// This file was authored by:
// @Astrea0014: https://github.com/Astrea0014
//------------------------------------------------------------------------>

#ifndef __AURORA_DLL_INJECTION_H__
#define __AURORA_DLL_INJECTION_H__

#include "Definitions.h"
#include "Exceptions.h"
#include "ProcessInfo.h"

#undef UNICODE

#include <Windows.h>

namespace Aurora {
	/// <summary>
	/// Defines what the provided path is relative to, if at all.
	/// </summary>
	enum class PathRelativity {
		ToCaller, // The path is relative to the calling process.
		ToTarget, // The path is relative to the target process.
		Absolute  // The path is absolute and starts with a drive letter.
	};

	/// <summary>
	/// Injects a dll into a process.
	/// </summary>
	/// <param name="lpProcessName">- The name of the target process.</param>
	/// <param name="lpDllName">- The payload dll path.</param>
	/// <param name="nPathRelativity">- The relativity of the payload path.</param>
	/// <exception cref="WindowsApiException"/>
	/// <exception cref="ObjectNotFoundException"/>
	/// <exception cref="ParameterInvalidException"/>
	AURORA_API A_VOID InjectDll(
		_In_z_ A_LPCSTR lpProcessName,
		_In_z_ A_LPCSTR lpDllName,
		_In_ PathRelativity nPathRelativity
	);

	/// <summary>
	/// Injects a dll into a process.
	/// </summary>
	/// <param name="refProcessInfo">- A reference to the target process information.</param>
	/// <param name="lpDllName">- The payload dll path.</param>
	/// <param name="nPathRelativity">- The relativity of the payload path.</param>
	/// <exception cref="WindowsApiException"/>
	/// <exception cref="ParameterInvalidException"/>
	AURORA_API A_VOID InjectDll(
		_In_ const ProcessInfo32& refProcessInfo,
		_In_z_ A_LPCSTR lpDllName,
		_In_ PathRelativity nPathRelativity
	);

	/// <summary>
	/// Injects a dll into a process.
	/// </summary>
	/// <param name="refProcessInfo">- A reference to the target process information.</param>
	/// <param name="lpDllName">- The payload dll path.</param>
	/// <param name="nPathRelativity">- The relativity of the payload path.</param>
	/// <exception cref="WindowsApiException"/>
	/// <exception cref="ParameterInvalidException"/>
	AURORA_API A_VOID InjectDll(
		_In_ const ProcessInfo64& refProcessInfo,
		_In_z_ A_LPCSTR lpDllName,
		_In_ PathRelativity nPathRelativity
	);
}

#endif // __AURORA_DLL_INJECTION_H__
```

`Artemis/Aurora/Events.h`:

```h
//------------------------------------------------------------------------>
// MIT License
// 
// Copyright (c) 2023 Artemis Group
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------>
// Aurora: https://github.com/ArtemisDevGroup/Aurora
// This file was authored by:
// @Astrea0014: https://github.com/Astrea0014
//------------------------------------------------------------------------>

#ifndef __AURORA_EVENTS_H__
#define __AURORA_EVENTS_H__

#include "Definitions.h"

namespace Aurora {
	template<typename T, typename... U>
	A_ADDR GetAddressOfFunction(Function<T(U...)> lpfnFunction) {
		typedef T(fnType)(U...);
		fnType** fnPointer = lpfnFunction.template target<fnType*>();
		return (A_ADDR)*fnPointer;
	}

	/// <summary>
	/// A class for subscribing and invoking to events.
	/// </summary>
	/// <typeparam name="InstanceEventArgs">- A class or struct containing event arguments.</typeparam>
	template<ClassType InstanceEventArgs = NullClass_t>
	class Event {
		Function<A_VOID(_In_opt_ A_LPVOID lpSender, _In_opt_ const InstanceEventArgs* lpEventArgs)> lpszfnEventHandlers[MAX_INVOKE];

	public:
		Event() noexcept {
			for (A_I32 i = 0; i < MAX_INVOKE; i++) lpszfnEventHandlers[i] = nullptr;
		}

		/// <summary>
		/// Invokes all registered event handlers.
		/// </summary>
		/// <param name="lpSender">- A pointer to the sender. Can be null.</param>
		/// <param name="lpArgs">- A pointer to an instance of the event args.</param>
		A_VOID Invoke(_In_opt_ A_LPVOID lpSender, _In_opt_ const InstanceEventArgs* lpArgs) const {
			for (A_I32 i = 0; i < MAX_INVOKE; i++)
				if (lpszfnEventHandlers[i] != nullptr)
					lpszfnEventHandlers[i](lpSender, lpArgs);
		}

		/// <summary>
		/// Clears the list of registered event handlers.
		/// </summary>
		A_VOID Clear() noexcept {
			for (A_I32 i = 0; i < MAX_INVOKE; i++) lpszfnEventHandlers[i] = nullptr;
		}

		A_VOID operator+=(_In_ Function<A_VOID(_In_opt_ A_LPVOID lpSender, _In_opt_ const InstanceEventArgs* lpEventArgs)> lpfnEventHandler) noexcept {
			for (A_I32 i = 0; i < MAX_INVOKE; i++)
				if (lpszfnEventHandlers[i] == nullptr) {
					lpszfnEventHandlers[i] = lpfnEventHandler;
					break;
				}
		}

		A_VOID operator-=(_In_ Function<A_VOID(_In_opt_ A_LPVOID lpSender, _In_opt_ const InstanceEventArgs* lpEventArgs)> lpfnEventHandler) noexcept {
			for (A_I32 i = 0; i < MAX_INVOKE; i++)
				if (GetAddressOfFunction(lpszfnEventHandlers[i]) == GetAddressOfFunction(lpfnEventHandler))
					lpszfnEventHandlers[i] = nullptr;
		}
	};

	/// <summary>
	/// A class for subscribing and invoking to events.
	/// </summary>
	template<>
	class Event<NullClass_t> {
		Function<A_VOID(A_LPVOID lpSender)> lpszfnEventHandlers[MAX_INVOKE];

	public:
		Event() noexcept {
			for (A_I32 i = 0; i < MAX_INVOKE; i++) lpszfnEventHandlers[i] = nullptr;
		}

		/// <summary>
		/// Invokes all registered event handlers.
		/// </summary>
		/// <param name="lpSender">- A pointer to the sender. Can be null.</param>
		A_VOID Invoke(_In_opt_ A_LPVOID lpSender) const {
			for (A_I32 i = 0; i < MAX_INVOKE; i++)
				if (lpszfnEventHandlers[i] != nullptr)
					lpszfnEventHandlers[i](lpSender);
		}

		/// <summary>
		/// Clears the list of registered event handlers.
		/// </summary>
		A_VOID Clear() noexcept {
			for (A_I32 i = 0; i < MAX_INVOKE; i++) lpszfnEventHandlers[i] = nullptr;
		}

		A_VOID operator+=(_In_ Function<A_VOID(_In_opt_ A_LPVOID lpSender)> lpfnEventHandler) noexcept {
			for (A_I32 i = 0; i < MAX_INVOKE; i++)
				if (lpszfnEventHandlers[i] == nullptr) {
					lpszfnEventHandlers[i] = lpfnEventHandler;
					break;
				}
		}

		A_VOID operator-=(_In_ Function<A_VOID(_In_opt_ A_LPVOID lpSender)> lpfnEventHandler) noexcept {
			for (A_I32 i = 0; i < MAX_INVOKE; i++)
				if (GetAddressOfFunction(lpszfnEventHandlers[i]) == GetAddressOfFunction(lpfnEventHandler))
					lpszfnEventHandlers[i] = nullptr;
		}
	};
}

#endif // !__AURORA_EVENTS_H__
```

`Artemis/Aurora/Exceptions.h`:

```h
//------------------------------------------------------------------------>
// MIT License
// 
// Copyright (c) 2023 Artemis Group
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------>
// Aurora: https://github.com/ArtemisDevGroup/Aurora
// This file was authored by:
// @Astrea0014: https://github.com/Astrea0014
//------------------------------------------------------------------------>

#ifndef __AURORA_EXCEPTIONS_H__
#define __AURORA_EXCEPTIONS_H__

#include "Definitions.h"

#include <string.h>
#include <Windows.h>
#undef GetMessage

/// <summary>
/// <para>Sets the context of all thrown exceptions to report the current function as the origin of the call.</para>
/// <para>If this function is called inside an already contextualized call, this function will be added to the call trace.</para>
/// </summary>
#define AuroraContextStart() A_DWORD dwKey = Aurora::GlobalExceptionContext::SetContext(__FUNCSIG__)
// Ends the contextualized call. Should be called right before returning.
#define AuroraContextEnd() Aurora::GlobalExceptionContext::ResetContext(dwKey)
// Throws an exception inside of a contextualized call.
#define AuroraThrow(Exception, ...) throw *Exception(__VA_ARGS__).WithContext(__FUNCSIG__, __FILE__, __LINE__)
// Creates a failsafe block that watches out for certain kinds of exceptions. One try block can have multiple catch blocks.
#define AuroraTry try
// Catches an exception as a constant reference. Use the variable 'e' to access the exception.
#define AuroraCatch(exception) catch (const exception& e)

#define MAX_THREADCOUNT 64
#define MAX_CALL_TRACE 64
#define MAX_FUNCTION_SIGNATURE 1024

namespace Aurora {
	/// <summary>
	/// An enumeration containing constants for identifying different types of exceptions.
	/// </summary>
	enum class ExceptionIdentifier : A_DWORD {
		WindowsApi,
		ParameterInvalid,
		Errno,
		IndexOutOfBounds,
		NotImplemented,
		PointerChainInvalid,
		Read32,
		Read64,
		Write32,
		Write64,
		ObjectNotFound,
		Compatibility,
		Resource
	};

	/// <summary>
	/// A static class for globally managing a call stack trace.
	/// </summary>
	class AURORA_API GlobalExceptionContext {
	public:
		GlobalExceptionContext() = delete;
		GlobalExceptionContext(const GlobalExceptionContext&) = delete;

		typedef const A_CHAR(&FunctionsArray)[MAX_CALL_TRACE][MAX_FUNCTION_SIGNATURE];

		/// <summary>
		/// Sets the call context to the provided string.
		/// </summary>
		/// <param name="lpContext">- The context to set.</param>
		/// <returns>A key later used to reset the context.</returns>
		AURORA_NDWR_DISP("SetContext") static A_DWORD SetContext(_In_z_ A_LPCSTR lpContext);

		/// <summary>
		/// Gets the currently set context for the current thread.
		/// </summary>
		/// <returns>A reference to the context array.</returns>
		AURORA_NDWR_GET("GetContext") static FunctionsArray GetContext() noexcept;

		/// <summary>
		/// Gets the number of valid context strings.
		/// </summary>
		/// <returns>The number of contexts.</returns>
		AURORA_NDWR_GET("GetcontextCount") static A_I32 GetContextCount() noexcept;

		/// <summary>
		/// Resets the previously set context.
		/// </summary>
		/// <param name="dwKey">- The context key.</param>
		static A_VOID ResetContext(_In_ A_DWORD dwKey) noexcept;
	};

	/// <summary>
	/// A base class for all exceptions.
	/// </summary>
	class AURORA_API Exception {
		A_CHAR szMessage[MAX_MSG];
		ExceptionIdentifier dwId;

	public:
		/// <summary>
		/// Constructs an Exception.
		/// </summary>
		/// <param name="lpMessage">- The exception message.</param>
		/// <param name="Id">- The exception identifier.</param>
		Exception(_In_z_ A_LPCSTR lpMessage, _In_ const ExceptionIdentifier& refdwId);

		/// <summary>
		/// Gets the message associated with the exception instance.
		/// </summary>
		/// <returns>The exception message.</returns>
		AURORA_NDWR_GET("GetMessage") constexpr _Ret_z_ A_LPCSTR GetMessage() const noexcept;

		/// <summary>
		/// Gets the identifier associated with the exception instance.
		/// </summary>
		/// <returns>The exception identifier.</returns>
		AURORA_NDWR_GET("GetIdentifier") constexpr const ExceptionIdentifier& GetIdentifier() const noexcept;

		A_BOOL operator==(const Exception&) const;
		constexpr A_BOOL operator==(const ExceptionIdentifier&) const noexcept;
		A_BOOL operator==(_In_z_ A_LPCSTR) const;

		A_BOOL operator!=(const Exception&) const;
		constexpr A_BOOL operator!=(const ExceptionIdentifier&) const noexcept;
		A_BOOL operator!=(_In_z_ A_LPCSTR) const;
	};

	/// <summary>
	/// A function template for a next throw event handler.
	/// </summary>
	using ThrowEventHandler = Function<A_VOID(Exception*)>;

	/// <summary>
	/// A static class for managing handlers to be called on the next exception thrown.
	/// </summary>
	class AURORA_API NextThrowEventManager {
	public:
		NextThrowEventManager() = delete;
		NextThrowEventManager(const NextThrowEventManager&) = delete;

		/// <summary>
		/// Queues an event handler to be called on the next exception thrown.
		/// </summary>
		/// <param name="lpfnEventHandler">- A pointer to an event handler.</param>
		/// <param name="bRemoveOnInvoke">- Determines whether the event handler shall remain in the queue or be removed after it is invoked.</param>
		/// <returns>The index of the event handler.</returns>
		static A_I32 QueueEvent(_In_ ThrowEventHandler lpfnEventHandler, _In_ A_BOOL bRemoveOnInvoke = true);

		/// <summary>
		/// Invokes all registered event handlers.
		/// </summary>
		/// <param name="lpException">- The sender.</param>
		static A_VOID Invoke(_In_ Exception* lpException);

		/// <summary>
		/// Clears one or all indexes and resets them to nullptr.
		/// </summary>
		/// <param name="nIndex">- The index of the event handler to clear. If set to INVALID_INDEX (-1) all event handlers will be cleared.</param>
		static A_VOID ClearEventQueue(_In_ A_I32 nIndex = INVALID_INDEX);
	};

	class OnThrowEventManager;

	/// <summary>
	/// A base class for all exceptions. Contains functionality to fetch and manage a context.
	/// </summary>
	/// <typeparam name="Derived">- The derived exception class.</typeparam>
	template<class Derived>
	class ExceptionContext {
		A_CHAR* lpszFunctions[MAX_CALL_TRACE];
		A_CHAR szCoreFunction[MAX_FUNCTION_SIGNATURE];
		A_CHAR szFilePath[MAX_PATH];
		A_I32 nFunctionCount;
		A_I32 nLine;

		A_BOOL bContextSet;

	public:
		inline ExceptionContext() : lpszFunctions(), szCoreFunction(), szFilePath(), nFunctionCount(0), nLine(0), bContextSet(false) {}

		inline ExceptionContext(const ExceptionContext<Derived>& cpy) {
			nFunctionCount = cpy.nFunctionCount;
			for (A_I32 i = 0; i < nFunctionCount; i++) {
				lpszFunctions[i] = new A_CHAR[MAX_FUNCTION_SIGNATURE];
				strcpy_s(lpszFunctions[i], MAX_FUNCTION_SIGNATURE, cpy.lpszFunctions[i]);
			}

			strcpy_s(szCoreFunction, cpy.szCoreFunction);
			strcpy_s(szFilePath, cpy.szFilePath);
			nLine = cpy.nLine;

			bContextSet = cpy.bContextSet;
		}

		inline ~ExceptionContext() {
			for (A_I32 i = 0; i < nFunctionCount; i++)
				delete[] lpszFunctions[i];
		}

		/// <summary>
		/// Sets the context of the exception. This function shall only be called once and only be called through the 'AuroraThrow' macro.
		/// </summary>
		/// <param name="lpFunction">- The signature of the function that failed.</param>
		/// <param name="lpFile">- The name of the file where the function that failed is contained.</param>
		/// <param name="nLine">- The line where the throw happened.</param>
		/// <returns>A pointer to the derived class instance.</returns>
		inline Derived* WithContext(_In_z_ A_LPCSTR lpFunction, _In_z_ A_LPCSTR lpFile, _In_ A_I32 nLine) {
			if (!bContextSet) {
				ZeroMemory(lpszFunctions, sizeof(lpszFunctions));

				nFunctionCount = GlobalExceptionContext::GetContextCount();
				for (A_I32 i = 0; i < nFunctionCount; i++) {
					lpszFunctions[i] = new A_CHAR[MAX_FUNCTION_SIGNATURE];
					strcpy_s(lpszFunctions[i], MAX_FUNCTION_SIGNATURE, GlobalExceptionContext::GetContext()[i]);
				}

				GlobalExceptionContext::ResetContext(GetCurrentThreadId());

				strcpy_s(szCoreFunction, lpFunction);
				strcpy_s(szFilePath, lpFile);
				this->nLine = nLine;

				NextThrowEventManager::Invoke((Derived*)this);
				OnThrowEventManager::Invoke((Derived*)this);

				bContextSet = true;
			}
			return (Derived*)this;
		}

		/// <summary>
		/// Gets a double pointer to the function signatures in the call stack trace.
		/// </summary>
		/// <returns>A double pointer to the call stack trace.</returns>
		AURORA_NDWR_GET("GetFunctions") constexpr A_LPCSTR const* GetFunctions() const noexcept { return lpszFunctions; }

		/// <summary>
		/// Gets the number of function signatures present in the call stack trace.
		/// </summary>
		/// <returns>The number of function signatures.</returns>
		AURORA_NDWR_GET("GetFunctionCount") constexpr A_I32 GetFunctionCount() const noexcept { return nFunctionCount; }

		/// <summary>
		/// Gets the signature of the function where the exception was thrown.
		/// </summary>
		/// <returns>The core function signature.</returns>
		AURORA_NDWR_GET("GetCoreFunction") constexpr _Ret_z_ A_LPCSTR GetCoreFunction() const noexcept { return szCoreFunction; }

		/// <summary>
		/// Gets the name of the file where the exception was thrown.
		/// </summary>
		/// <returns>The file name.</returns>
		AURORA_NDWR_GET("GetFile") constexpr _Ret_z_ A_LPCSTR GetFile() const noexcept { return szFilePath; }

		/// <summary>
		/// Gets the line where the exception was thrown.
		/// </summary>
		/// <returns>The line number.</returns>
		AURORA_NDWR_GET("GetLine") constexpr A_I32 GetLine() const noexcept { return nLine; }
	};

	/// <summary>
	/// An exception types thrown when a Windows API function fails.
	/// </summary>
	class AURORA_API WindowsApiException : public Exception, public ExceptionContext<WindowsApiException> {
		A_DWORD dwWindowsApiCode;
		A_CHAR szWindowsApiMessage[MAX_MSG];
		A_CHAR szWindowsApiFunction[MAX_NAME];

	public:
		/// <summary>
		/// Constructs a WindowsApiException.
		/// </summary>
		/// <param name="lpWindowsApiFunction">- The name of the Windows API function that failed.</param>
		WindowsApiException(_In_z_ A_LPCSTR lpWindowsApiFunction);

		/// <summary>
		/// Gets the Windows API error code returned from 'GetLastError'.
		/// </summary>
		/// <returns>The Windows API error code.</returns>
		AURORA_NDWR_GET("GetWindowsCode") constexpr A_DWORD GetWindowsCode() const noexcept;

		/// <summary>
		/// Gets the Windows API error message returned from 'FormatMessageA'.
		/// </summary>
		/// <returns>The Windows API error message.</returns>
		AURORA_NDWR_GET("GetWindowsMessage") constexpr _Ret_z_ A_LPCSTR GetWindowsMessage() const noexcept;

		/// <summary>
		/// Gets the name of the Windows API function that failed.
		/// </summary>
		/// <returns>The name fo the Windows API function.</returns>
		AURORA_NDWR_GET("GetWindowsFunction") constexpr _Ret_z_ A_LPCSTR GetWindowsFunction() const noexcept;
	};

	/// <summary>
	/// An exception type thrown when parameter validation fails.
	/// </summary>
	class AURORA_API ParameterInvalidException : public Exception, public ExceptionContext<ParameterInvalidException> {
		A_CHAR szParameterName[MAX_NAME];

	public:
		/// <summary>
		/// Constructs a ParameterInvalidException.
		/// </summary>
		/// <param name="lpParameterName">- The name of the parameter causing the throw.</param>
		ParameterInvalidException(_In_z_ A_LPCSTR lpParameterName);

		/// <summary>
		/// Gets the name of the invalid parameter.
		/// </summary>
		/// <returns>The name of the parameter.</returns>
		AURORA_NDWR_GET("GetParameterName") constexpr _Ret_z_ A_LPCSTR GetParameterName() const noexcept;
	};

	/// <summary>
	/// An exception type thrown when a C-standard function fails.
	/// </summary>
	class AURORA_API ErrnoException : public Exception, public ExceptionContext<ErrnoException> {
		errno_t nErrorCode;
		A_CHAR szErrnoString[MAX_MSG];

	public:
		/// <summary>
		/// Constructs an ErrnoException.
		/// </summary>
		/// <param name="nErrorCode">- The errno code.</param>
		ErrnoException(_In_ errno_t nErrorCode);

		/// <summary>
		/// Gets the errno error code.
		/// </summary>
		/// <returns>The error code.</returns>
		AURORA_NDWR_GET("GetErrorCode") constexpr errno_t GetErrorCode() const noexcept;

		/// <summary>
		/// Gets the errno error message.
		/// </summary>
		/// <returns>The error message.</returns>
		AURORA_NDWR_GET("GetErrorMessage") constexpr _Ret_z_ A_LPCSTR GetErrorMessage() const noexcept;
	};

	/// <summary>
	/// An exception type thrown when a feature is not implemented yet but used.
	/// </summary>
	class AURORA_API NotImplementedException : public Exception, public ExceptionContext<NotImplementedException> { public: NotImplementedException(); };

	/// <summary>
	/// An exception type thrown when a pointer chain has an invalid pointer.
	/// </summary>
	class AURORA_API PointerChainInvalidException : public Exception, public ExceptionContext<PointerChainInvalidException> {
		A_I32 nChainLevel;

	public:
		/// <summary>
		/// Constructs a PointerChainInvalidException.
		/// </summary>
		/// <param name="nChainLevel">- The invalid offset level.</param>
		PointerChainInvalidException(_In_ A_I32 nChainLevel);

		/// <summary>
		/// Gets the level at where the pointer chain turned invalid.
		/// </summary>
		/// <returns>The invalid pointer chain level.</returns>
		AURORA_NDWR_GET("GetChainLevel") constexpr A_I32 GetChainLevel() const noexcept;
	};

	namespace Helpers {
		/// <summary>
		/// A base class for all memory related exceptions.
		/// </summary>
		/// <typeparam name="T">- The address width.</typeparam>
		template<AddressType T>
		class MemoryExceptionImpl {
			T uAddress;
			A_DWORD dwSize;

		public:
			/// <summary>
			/// Constructs a MemoryExceptionImpl.
			/// </summary>
			/// <param name="uAddress">- The operation address.</param>
			/// <param name="dwSize">- The operation size.</param>
			MemoryExceptionImpl(_In_ T uAddress, _In_ A_DWORD dwSize) : uAddress(uAddress), dwSize(dwSize) {}

			/// <summary>
			/// Gets the inaccessible address.
			/// </summary>
			/// <returns>The address.</returns>
			AURORA_NDWR_GET("GetAddress") constexpr T GetAddress() const noexcept { return uAddress; }

			/// <summary>
			/// Gets the size of the attempted operation.
			/// </summary>
			/// <returns>The operation size.</returns>
			AURORA_NDWR_GET("GetSize") constexpr A_DWORD GetSize() const noexcept { return dwSize; }
		};
	}

	/// <summary>
	/// An exception type thrown when a read operation fails for a 32-bit process.
	/// </summary>
	class AURORA_API Read32Exception : public Helpers::MemoryExceptionImpl<A_ADDR32>, public Exception, public ExceptionContext<Read32Exception> {
	public:
		/// <summary>
		/// Constructs a Read32Exception.
		/// </summary>
		/// <param name="uAddress">- The operation address.</param>
		/// <param name="dwSize">- The operation size.</param>
		Read32Exception(_In_a32_ A_ADDR32 uAddress, _In_ A_DWORD dwSize);
	};

	/// <summary>
	/// An exception type thrown when a read operation fails for a 64-bit process.
	/// </summary>
	class AURORA_API Read64Exception : public Helpers::MemoryExceptionImpl<A_ADDR64>, public Exception, public ExceptionContext<Read64Exception> {
	public:
		/// <summary>
		/// Constructs a Read64Exception.
		/// </summary>
		/// <param name="uAddress">- The operation address.</param>
		/// <param name="dwSize">- The operation size.</param>
		Read64Exception(_In_a64_ A_ADDR64 uAddress, _In_ A_DWORD dwSize);
	};

	/// <summary>
	/// An exception type thrown when a write operation fails for a 32-bit process.
	/// </summary>
	class AURORA_API Write32Exception : public Helpers::MemoryExceptionImpl<A_ADDR32>, public Exception, public ExceptionContext<Write32Exception> {
	public:
		/// <summary>
		/// Constructs a Write32Exception.
		/// </summary>
		/// <param name="uAddress">- The operation address.</param>
		/// <param name="dwSize">- The operation size.</param>
		Write32Exception(_In_a32_ A_ADDR32 uAddress, _In_ A_DWORD dwSize);
	};

	/// <summary>
	/// An exception type throwm when a write operation fails for a 64-bit process.
	/// </summary>
	class AURORA_API Write64Exception : public Helpers::MemoryExceptionImpl<A_ADDR64>, public Exception, public ExceptionContext<Write64Exception> {
	public:
		/// <summary>
		/// Constructs a Write64Exception.
		/// </summary>
		/// <param name="uAddress">- The operation address.</param>
		/// <param name="dwSize">- The operation size.</param>
		Write64Exception(_In_a64_ A_ADDR64 uAddress, _In_ A_DWORD dwSize);
	};

#ifdef _WIN64
	/// <summary>
	/// An exception type thrown when a read operation fails for a 64-bit process.
	/// </summary>
	using ReadException = Read64Exception;

	/// <summary>
	/// An exception type throwm when a write operation fails for a 64-bit process.
	/// </summary>
	using WriteException = Write64Exception;
#else
	/// <summary>
	/// An exception type thrown when a read operation fails for a 32-bit process.
	/// </summary>
	using ReadException = Read32Exception;

	/// <summary>
	/// An exception type throwm when a write operation fails for a 32-bit process.
	/// </summary>
	using WriteException = Write32Exception;
#endif

	/// <summary>
	/// An exception type thrown when an attempt has been made to fetch an object but it has not been found.
	/// </summary>
	class AURORA_API ObjectNotFoundException : public Exception, public ExceptionContext<ObjectNotFoundException> {
		A_CHAR szObjectType[MAX_NAME];
		A_CHAR szObjectName[MAX_NAME];

	public:
		/// <summary>
		/// Constructs an ObjectNotFoundException.
		/// </summary>
		/// <param name="lpObjectType">- The object type.</param>
		/// <param name="lpObjectName">- The object name.</param>
		ObjectNotFoundException(_In_z_ A_LPCSTR lpObjectType, _In_z_ A_LPCSTR lpObjectName);

		/// <summary>
		/// Gets the type of the object.
		/// </summary>
		/// <returns>The object type.</returns>
		AURORA_NDWR_GET("GetObjectType") constexpr _Ret_z_ A_LPCSTR GetObjectType() const noexcept;

		/// <summary>
		/// Gets the name of the object.
		/// </summary>
		/// <returns>The object name.</returns>
		AURORA_NDWR_GET("GetObjectName") constexpr _Ret_z_ A_LPCSTR GetObjectName() const noexcept;
	};

	/// <summary>
	/// An exception type thrown when either two objects or two parameters are incompatible with each other.
	/// </summary>
	class AURORA_API CompatibilityException : public Exception, public ExceptionContext<CompatibilityException> { public: CompatibilityException(); };

	/// <summary>
	/// Thrown when there are insufficient resources to complete an operation.
	/// </summary>
	class AURORA_API ResourceException : public Exception, public ExceptionContext<ResourceException> { public: ResourceException(); };

	/// <summary>
	/// Represents an index for an event handler.
	/// </summary>
	/// <typeparam name="T">- The exception type associated with the event handler.</typeparam>
	template<class ExceptionClass>
	struct EventHandlerIndex {
	private:
		A_I32 nIndex;

	public:
		/// <summary>
		/// Constructs an EventHandlerIndex.
		/// </summary>
		/// <param name="nIndex">- The index of the event handler.</param>
		constexpr EventHandlerIndex(_In_ A_I32 nIndex) noexcept : nIndex(nIndex) {}

		constexpr operator A_I32& () noexcept { return nIndex; }
		constexpr operator const A_I32& () const noexcept { return nIndex; }
	};

	/// <summary>
	/// Is only valid as an argument to 'ClearEventQueue()'. Clears all registered event handlers instead.
	/// </summary>
	template<class ExceptionClass>
	constexpr EventHandlerIndex<ExceptionClass> All = { -1 };

	namespace Helpers {
		AURORA_NDWR_GET("GetIndexOf") AURORA_API A_I32 GetIndexOf(_In_ A_DWORD dwThreadId);

		/// <summary>
		/// The implementation for an exception event manager.
		/// </summary>
		/// <typeparam name="ExceptionClass">- The exception type to implement an exception event manager for.</typeparam>
		template<class ExceptionClass>
		class AURORA_API OnThrowEventManagerImpl {
			static Function<A_VOID(const ExceptionClass*)> lpszfnOnThrowEventHandlers[MAX_THREADCOUNT][MAX_INVOKE];
			static A_BOOL szbRemoveOnInvoke[MAX_THREADCOUNT][MAX_INVOKE];

		public:
			OnThrowEventManagerImpl() = delete;
			OnThrowEventManagerImpl(const OnThrowEventManagerImpl&) = delete;

			/// <summary>
			/// Queues an event handler to be called on the next exception of the provided type thrown.
			/// </summary>
			/// <param name="lpfnEventHandler">- A pointer to an event handler.</param>
			/// <param name="bRemoveOnInvoke">- Determines whether the event handler shall remain in the queue or be removed after it is invoked.</param>
			/// <returns>The index of the event handler.</returns>
			static inline EventHandlerIndex<ExceptionClass> QueueEvent(_In_ Function<A_VOID(const ExceptionClass*)> lpfnEventHandler, _In_ A_BOOL bRemoveOnInvoke = true) {
				A_I32 nIndex = GetIndexOf(GetCurrentThreadId());
				if (nIndex != INVALID_INDEX)
					for (A_I32 i = 0; i < MAX_INVOKE; i++)
						if (!lpszfnOnThrowEventHandlers[nIndex][i].target<void>()) {
							lpszfnOnThrowEventHandlers[nIndex][i] = lpfnEventHandler;
							return i;
						}
				return INVALID_INDEX;
			}

			/// <summary>
			/// Clears one or all indexes and resets them to nullptr.
			/// </summary>
			/// <param name="nIndex">- The index of the event handler to clear. If set to 'All' (-1) all event handlers will be cleared.</param>
			static inline A_VOID ClearEventQueue(_In_ EventHandlerIndex<ExceptionClass> nIndex) {
				A_I32 nLevel1Index = GetIndexOf(GetCurrentThreadId());
				if (nLevel1Index != INVALID_INDEX) {
					if (nIndex == INVALID_INDEX)
						for (A_I32 i = 0; i < MAX_INVOKE; i++)
							lpszfnOnThrowEventHandlers[nLevel1Index][i] = nullptr;
					else lpszfnOnThrowEventHandlers[nLevel1Index][nIndex] = nullptr;
				}
			}

			/// <summary>
			/// Invokes all registered event handlers.
			/// </summary>
			/// <param name="lpException">- The sender.</param>
			static inline A_VOID Invoke(_In_ const ExceptionClass* lpException) {
				A_I32 nIndex = GetIndexOf(GetCurrentThreadId());
				if (nIndex != INVALID_INDEX)
					for (A_I32 i = MAX_INVOKE - 1; i >= 0; i--)
						if (lpszfnOnThrowEventHandlers[nIndex][i].target<void>()) {
							lpszfnOnThrowEventHandlers[nIndex][i](lpException);
							if (szbRemoveOnInvoke[nIndex][i])
								lpszfnOnThrowEventHandlers[nIndex][i] = nullptr;
						}
			}
		};
	}

	/// <summary>
	/// A static class for managing handlers to be called on the next exception of a particular type thrown.
	/// </summary>
	class OnThrowEventManager :
		public Helpers::OnThrowEventManagerImpl<WindowsApiException>,
		public Helpers::OnThrowEventManagerImpl<ParameterInvalidException>,
		public Helpers::OnThrowEventManagerImpl<ErrnoException>,
		public Helpers::OnThrowEventManagerImpl<NotImplementedException>,
		public Helpers::OnThrowEventManagerImpl<PointerChainInvalidException>,
		public Helpers::OnThrowEventManagerImpl<Read32Exception>,
		public Helpers::OnThrowEventManagerImpl<Read64Exception>,
		public Helpers::OnThrowEventManagerImpl<Write32Exception>,
		public Helpers::OnThrowEventManagerImpl<Write64Exception>,
		public Helpers::OnThrowEventManagerImpl<ObjectNotFoundException>,
		public Helpers::OnThrowEventManagerImpl<CompatibilityException>,
		public Helpers::OnThrowEventManagerImpl<ResourceException>
	{
	public:
		OnThrowEventManager() = delete;
		OnThrowEventManager(const OnThrowEventManager&) = delete;

		using OnThrowEventManagerImpl<WindowsApiException>			::QueueEvent;
		using OnThrowEventManagerImpl<ParameterInvalidException>	::QueueEvent;
		using OnThrowEventManagerImpl<ErrnoException>				::QueueEvent;
		using OnThrowEventManagerImpl<NotImplementedException>		::QueueEvent;
		using OnThrowEventManagerImpl<PointerChainInvalidException>	::QueueEvent;
		using OnThrowEventManagerImpl<Read32Exception>				::QueueEvent;
		using OnThrowEventManagerImpl<Read64Exception>				::QueueEvent;
		using OnThrowEventManagerImpl<Write32Exception>				::QueueEvent;
		using OnThrowEventManagerImpl<Write64Exception>				::QueueEvent;
		using OnThrowEventManagerImpl<ObjectNotFoundException>		::QueueEvent;
		using OnThrowEventManagerImpl<CompatibilityException>		::QueueEvent;
		using OnThrowEventManagerImpl<ResourceException>			::QueueEvent;

		using OnThrowEventManagerImpl<WindowsApiException>			::ClearEventQueue;
		using OnThrowEventManagerImpl<ParameterInvalidException>	::ClearEventQueue;
		using OnThrowEventManagerImpl<ErrnoException>				::ClearEventQueue;
		using OnThrowEventManagerImpl<NotImplementedException>		::ClearEventQueue;
		using OnThrowEventManagerImpl<PointerChainInvalidException>	::ClearEventQueue;
		using OnThrowEventManagerImpl<Read32Exception>				::ClearEventQueue;
		using OnThrowEventManagerImpl<Read64Exception>				::ClearEventQueue;
		using OnThrowEventManagerImpl<Write32Exception>				::ClearEventQueue;
		using OnThrowEventManagerImpl<Write64Exception>				::ClearEventQueue;
		using OnThrowEventManagerImpl<ObjectNotFoundException>		::ClearEventQueue;
		using OnThrowEventManagerImpl<CompatibilityException>		::ClearEventQueue;
		using OnThrowEventManagerImpl<ResourceException>			::ClearEventQueue;

		using OnThrowEventManagerImpl<WindowsApiException>			::Invoke;
		using OnThrowEventManagerImpl<ParameterInvalidException>	::Invoke;
		using OnThrowEventManagerImpl<ErrnoException>				::Invoke;
		using OnThrowEventManagerImpl<NotImplementedException>		::Invoke;
		using OnThrowEventManagerImpl<PointerChainInvalidException>	::Invoke;
		using OnThrowEventManagerImpl<Read32Exception>				::Invoke;
		using OnThrowEventManagerImpl<Read64Exception>				::Invoke;
		using OnThrowEventManagerImpl<Write32Exception>				::Invoke;
		using OnThrowEventManagerImpl<Write64Exception>				::Invoke;
		using OnThrowEventManagerImpl<ObjectNotFoundException>		::Invoke;
		using OnThrowEventManagerImpl<CompatibilityException>		::Invoke;
		using OnThrowEventManagerImpl<ResourceException>			::Invoke;
	};
}

#endif // !__AURORA_EXCEPTIONS_H__
```

`Artemis/Aurora/FileSystem.h`:

```h
//------------------------------------------------------------------------>
// MIT License
// 
// Copyright (c) 2023 Artemis Group
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------>
// Aurora: https://github.com/ArtemisDevGroup/Aurora
// This file was authored by:
// @Astrea0014: https://github.com/Astrea0014
//------------------------------------------------------------------------>

#ifndef __AURORA_FILE_SYSTEM_H__
#define __AURORA_FILE_SYSTEM_H__

#include "Definitions.h"
#include "Exceptions.h"

#include <Windows.h>

#undef CreateDirectory
#undef CreateFile
#undef GetCompressedFileSize

namespace Aurora {
	/// <summary>
	/// Defines how a file creation operation shall treat existing files.
	/// </summary>
	enum class CreationDisposition : A_DWORD {
		CreateNew = CREATE_NEW,					// Creates a new file, only if one does not exist.
		CreateAlways = CREATE_ALWAYS,			// Always creates a new file.
		OpenExisting = OPEN_EXISTING,			// Opens a file, only if it exists.
		OpenAlways = OPEN_ALWAYS,				// Opens a file if it exists, otherwise creates a new file.
		TruncateExisting = TRUNCATE_EXISTING	// Creates a new file, only if one already exists.
	};

	/// <summary>
	/// Defines the access rights of a file instance.
	/// </summary>
	struct FileAccessFlags {
		A_DWORD dwValue;

		enum Enumeration : A_DWORD {
			Read = FILE_GENERIC_READ,		// Allows read operations on the file.
			Write = FILE_GENERIC_WRITE,		// Allows write operations on the file.
			Execute = FILE_GENERIC_EXECUTE	// Allows the file to be executed by the process.
		};

		constexpr FileAccessFlags() noexcept : dwValue(0) {}
		constexpr FileAccessFlags(A_DWORD dwValue) noexcept : dwValue(dwValue) {}

		operator A_DWORD& () noexcept { return dwValue; }
		constexpr operator const A_DWORD& () const noexcept { return dwValue; }
	};

	/// <summary>
	/// Defines which access rights other instances can request when they open the same file.
	/// </summary>
	struct FileShareModeFlags {
		A_DWORD dwValue;

		enum Enumeration : A_DWORD {
			None = 0,
			Read = FILE_SHARE_READ,
			Write = FILE_SHARE_WRITE,
			Delete = FILE_SHARE_DELETE,
			All = Read | Write | Delete
		};

		constexpr FileShareModeFlags() noexcept : dwValue(0) {}
		constexpr FileShareModeFlags(A_DWORD dwValue) noexcept : dwValue(dwValue) {}

		operator A_DWORD& () noexcept { return dwValue; }
		constexpr operator const A_DWORD& () const noexcept { return dwValue; }
	};

	/// <summary>
	/// Defines the attributes of the file.
	/// </summary>
	struct FileAttributeFlags {
		A_DWORD dwValue;

		enum Enumeration : A_DWORD {
			Readonly = FILE_ATTRIBUTE_READONLY,							// A file that is read-only. Applications can read the file, but cannot write to it or delete it. This attribute is not honored on directories.
			Hidden = FILE_ATTRIBUTE_HIDDEN,								// The file or directory is hidden. It is not included in an ordinary directory listing.
			System = FILE_ATTRIBUTE_SYSTEM,								// A file or directory that the operating system uses a part of, or uses exclusively.
			Directory = FILE_ATTRIBUTE_DIRECTORY,						// The handle that identifies a directory.
			Archive = FILE_ATTRIBUTE_ARCHIVE,							// A file or directory that is an archive file or directory. Applications typically use this attribute to mark files for backup or removal.
			Device = FILE_ATTRIBUTE_DEVICE,								// This value is reserved for system use.
			Normal = FILE_ATTRIBUTE_NORMAL,								// A file that does not have other attributes set. This attribute is valid only when used alone.
			/// <summary>
			/// A file that is being used for temporary storage.
			/// File systems avoid writing data back to mass storage if sufficient cache memory is available, because typically, an application deletes a temporary file after the handle is closed.
			/// In that scenario, the system can entirely avoid writing the data. Otherwise, the data is written after the handle is closed.
			/// </summary>
			Temporary = FILE_ATTRIBUTE_TEMPORARY,
			SparseFile = FILE_ATTRIBUTE_SPARSE_FILE,					// A file that is a sparse file.
			ReparsePoint = FILE_ATTRIBUTE_REPARSE_POINT,				// A file or directory that has an associated reparse point, or a file that is a symbolic link.
			Compressed = FILE_ATTRIBUTE_COMPRESSED,						// A file or directory that is compressed. For a file, all of the data in the file is compressed. For a directory, compression is the default for newly created files and subdirectories.
			/// <summary>
			/// The data of a file is not available immediately. This attribute indicates that the file data is physically moved to offline storage.
			/// This attribute is used by Remote Storage, which is the hierarchical storage management software. Applications should not arbitrarily change this attribute.
			/// </summary>
			Offline = FILE_ATTRIBUTE_OFFLINE,
			NoContextIndexed = FILE_ATTRIBUTE_NOT_CONTENT_INDEXED,		// The file or directory is not to be indexed by the content indexing service.
			Encrypted = FILE_ATTRIBUTE_ENCRYPTED,						// A file or directory that is encrypted. For a file, all data streams in the file are encrypted. For a directory, encryption is the default for newly created files and subdirectories.
			/// <summary>
			/// The directory or user data stream is configured with integrity (only supported on ReFS volumes). It is not included in an ordinary directory listing.
			/// The integrity setting persists with the file if it's renamed. If a file is copied the destination file will have integrity set if either the source file or destination directory have integrity set.
			/// </summary>
			IntegrityStream = FILE_ATTRIBUTE_INTEGRITY_STREAM,
			Virtual = FILE_ATTRIBUTE_VIRTUAL,							// This value is reserved for system use.
			/// <summary>
			/// The user data stream not to be read by the background data integrity scanner (AKA scrubber). When set on a directory it only provides inheritance.
			/// This flag is only supported on Storage Spaces and ReFS volumes. It is not included in an ordinary directory listing.
			/// </summary>
			NoScrubData = FILE_ATTRIBUTE_NO_SCRUB_DATA,
			ExtendedAttributes = FILE_ATTRIBUTE_EA,						// A file or directory with extended attributes.
			/// <summary>
			/// This attribute indicates user intent that the file or directory should be kept fully present locally even when not being actively accessed.
			/// This attribute is for use with hierarchical storage management software.
			/// </summary>
			Pinned = FILE_ATTRIBUTE_PINNED,
			/// <summary>
			/// This attribute indicates that the file or directory should not be kept fully present locally except when being actively accessed.
			/// This attribute is for use with hierarchical storage management software.
			/// </summary>
			Unpinned = FILE_ATTRIBUTE_UNPINNED,
			/// <summary>
			/// This attribute only appears in directory enumeration classes (FILE_DIRECTORY_INFORMATION, FILE_BOTH_DIR_INFORMATION, etc.).
			/// When this attribute is set, it means that the file or directory has no physical representation on the local system; the item is virtual.
			/// Opening the item will be more expensive than normal, e.g. it will cause at least some of it to be fetched from a remote store.
			/// </summary>
			RecallOnOpen = FILE_ATTRIBUTE_RECALL_ON_OPEN,
			/// <summary>
			/// When this attribute is set, it means that the file or directory is not fully present locally.
			/// For a file that means that not all of its data is on local storage (e.g. it may be sparse with some data still in remote storage).
			/// For a directory it means that some of the directory contents are being virtualized from another location.
			/// Reading the file / enumerating the directory will be more expensive than normal, e.g. it will cause at least some of the file/directory content to be fetched from a remote store.
			/// Only kernel-mode callers can set this bit.
			/// </summary>
			RecallOnDataAccess = FILE_ATTRIBUTE_RECALL_ON_DATA_ACCESS
		};

		constexpr FileAttributeFlags() noexcept : dwValue(0) {}
		constexpr FileAttributeFlags(A_DWORD dwValue) noexcept : dwValue(dwValue) {}

		/// <summary>
		/// Checks if an attribute flag is set.
		/// </summary>
		/// <param name="dwAttribute">- The attribute to check.</param>
		/// <returns>True if the attribute is set, otherwise false.</returns>
		AURORA_NDWR_GET("CheckAttribute") constexpr A_BOOL CheckAttribute(_In_ const FileAttributeFlags& dwAttribute) const noexcept { return !!(dwValue & dwAttribute.dwValue); }

		operator A_DWORD& () noexcept { return dwValue; }
		constexpr operator const A_DWORD& () const noexcept { return dwValue; }
	};

	/// <summary>
	/// Defines custom file behavior.
	/// </summary>
	struct FileFlags {
		A_DWORD dwValue;

		enum Enumeration : A_DWORD {
			/// <summary>
			/// No custom file behavior.
			/// </summary>
			None = 0,
			/// <summary>
			/// The file is being opened or created for a backup or restore operation.
			/// The system ensures that the calling process overrides file security checks when the process has SE_BACKUP_NAME and SE_RESTORE_NAME privileges.
			/// You must set this flag to obtain a handle to a directory. A directory handle can be passed to some functions instead of a file handle.
			/// </summary>
			BackupSemantics = FILE_FLAG_BACKUP_SEMANTICS,
			/// <summary>
			/// The file is to be deleted immediately after all of its handles are closed, which includes the specified handle and any other open or duplicated handles.
			/// If there are existing open handles to a file, the call fails unless they were all opened with the FILE_SHARE_DELETE share mode.
			/// Subsequent open requests for the file fail, unless the FILE_SHARE_DELETE share mode is specified.
			/// </summary>
			DeleteOnClose = FILE_FLAG_DELETE_ON_CLOSE,
			/// <summary>
			/// The file or device is being opened with no system caching for data reads and writes. This flag does not affect hard disk caching or memory mapped files.
			/// </summary>
			NoBuffering = FILE_FLAG_NO_BUFFERING,
			/// <summary>
			/// Access is intended to be random. The system can use this as a hint to optimize file caching.
			/// This flag has no effect if the file system does not support cached I/O and FILE_FLAG_NO_BUFFERING.
			/// </summary>
			RandomAccess = FILE_FLAG_RANDOM_ACCESS,
			/// <summary>
			/// Access is intended to be sequential from beginning to end. The system can use this as a hint to optimize file caching.
			/// This flag should not be used if read-behind (that is, reverse scans) will be used.
			/// This flag has no effect if the file system does not support cached I/O and FILE_FLAG_NO_BUFFERING.
			/// </summary>
			SequentialScan = FILE_FLAG_SEQUENTIAL_SCAN,
			/// <summary>
			/// Write operations will not go through any intermediate cache, they will go directly to disk.
			/// </summary>
			WriteThrough = FILE_FLAG_WRITE_THROUGH
		};

		constexpr FileFlags() noexcept : dwValue(0) {}
		constexpr FileFlags(A_DWORD dwValue) : dwValue(dwValue) {}

		operator A_DWORD& () noexcept { return dwValue; }
		constexpr operator const A_DWORD& () const noexcept { return dwValue; }
	};

	/// <summary>
	/// Defines what the file pointer offset shall be relative to.
	/// </summary>
	enum class FilePointerMoveMethod : A_DWORD {
		Begin = FILE_BEGIN,			// The beginning of the file. 
		Current = FILE_CURRENT,		// The current file pointer position.
		End = FILE_END				// The end of the file.
	};

	/// <summary>
	/// Represents a local file.
	/// </summary>
	class AURORA_API File {
	protected:
		HANDLE hFile;

	private:
		A_CHAR szFilePath[MAX_PATH];
		A_CHAR szFileName[MAX_NAME];

	public:
		constexpr File() noexcept;

		/// <summary>
		/// Creates or opens a file.
		/// </summary>
		/// <param name="lpFileName">- The name of the file. This can be either relative to the host process or absolute.</param>
		/// <param name="dwCreationDisposition">- The creation disposition. See CreationDisposition for more.</param>
		/// <param name="dwDesiredAccess">- The desired access mode to the file. See FileAccessFlags for more.</param>
		/// <param name="dwAttributes">- The file attributes. See FileAttributeFlags for more.</param>
		/// <param name="dwFlags">- The file flags. See FileFlags for more.</param>
		/// <param name="dwShareMode">- The instance share mode. See FileShareModeFlags for more.</param>
		/// <param name="refTemplateFile">- A reference to a File instance to use as a template for the created file.</param>
		/// <param name="lpSecurityAttributes">- A pointer to a security attributes structure containing security information for the newly created directory. This parameter is optional.</param>
		/// <exception cref="WindowsApiException"/>
		/// <exception cref="ParameterInvalidException"/>
		File(
			_In_z_ A_LPCSTR lpFileName,
			_In_ CreationDisposition dwCreationDisposition,
			_In_ FileAccessFlags dwDesiredAccess = FileAccessFlags::Read | FileAccessFlags::Write,
			_In_ FileAttributeFlags dwAttributes = FileAttributeFlags::Normal,
			_In_ FileFlags dwFlags = FileFlags::None,
			_In_ FileShareModeFlags dwShareMode = FileShareModeFlags::All,
			_In_opt_ const File& refTemplateFile = File(),
			_In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes = nullptr
		);

		File(const File&);

		~File();

		/// <summary>
		/// Gets an absolute path to the file.
		/// </summary>
		/// <returns>The full file path.</returns>
		AURORA_NDWR_GET("GetFilePath") _Ret_z_ constexpr A_LPCSTR GetFilePath() const noexcept;

		/// <summary>
		/// Gets the name of the file.
		/// </summary>
		/// <returns>The file name.</returns>
		AURORA_NDWR_GET("GetFileName") _Ret_z_ constexpr A_LPCSTR GetFileName() const noexcept;

		/// <summary>
		/// Gets the current file attribute flags.
		/// </summary>
		/// <returns>The file attributes.</returns>
		/// <exception cref="WindowsApiException"/>
		AURORA_NDWR_GET("GetAttributes") FileAttributeFlags GetAttributes() const;

		/// <summary>
		/// Sets the current file attribute flags.
		/// </summary>
		/// <param name="dwAttributes">- The attributes to set.</param>
		/// <exception cref="WindowsApiException"/>
		A_VOID SetAttributes(_In_ FileAttributeFlags dwAttributes) const;

		/// <summary>
		/// Gets the current file pointer position relative to the beginning of the file.
		/// </summary>
		/// <returns>The current file pointer.</returns>
		/// <exception cref="WindowsApiException"/>
		AURORA_NDWR_GET("GetFilePointer") A_U64 GetFilePointer() const;

		/// <summary>
		/// Sets the current file pointer position relative to the move method.
		/// </summary>
		/// <param name="dwMoveMethod">- The move method. See FilePointerMoveMethod for more.</param>
		/// <param name="uOffset">- The offset to set the file pointer to.</param>
		/// <exception cref="WindowsApiException"/>
		A_VOID SetFilePointer(_In_ FilePointerMoveMethod dwMoveMethod, _In_ A_U64 uOffset) const;

		/// <summary>
		/// Reads the requested number of bytes from the file pointer.
		/// </summary>
		/// <param name="lpBuffer">- A pointer to a buffer to receive the read data.</param>
		/// <param name="dwSize">- The size of the buffer.</param>
		/// <exception cref="ParameterInvalidException"/>
		/// <exception cref="WindowsApiException"/>
		A_VOID Read(
			_Out_writes_bytes_(dwSize) A_LPVOID lpBuffer,
			_In_ A_DWORD dwSize
		) const;

		/// <summary>
		/// Writes the requested number of bytes to the file pointer.
		/// </summary>
		/// <param name="lpBuffer">- A pointer to a buffer that contains the data to write.</param>
		/// <param name="dwSize">- The size of the buffer.</param>
		/// <exception cref="ParameterInvalidException"/>
		/// <exception cref="WindowsApiException"/>
		A_VOID Write(
			_In_reads_bytes_(dwSize) A_LPCVOID lpBuffer,
			_In_ A_DWORD dwSize
		) const;

		/// <summary>
		/// Gets the size of the file in bytes.
		/// </summary>
		/// <returns>The file size.</returns>
		/// <exception cref="WindowsApiException"/>
		AURORA_NDWR_GET("GetFileSize") A_U64 GetFileSize() const;

		/// <summary>
		/// Gets the compressed size of the file in bytes.
		/// </summary>
		/// <returns>The compressed file size.</returns>
		/// <exception cref="WindowsApiException"/>
		AURORA_NDWR_GET("GetCompressedFileSize") A_U64 GetCompressedFileSize() const;

		/// <summary>
		/// Flushes the current file buffers forcing the contents of the buffers to be written to disk.
		/// </summary>
		/// <exception cref="WindowsApiException"/>
		A_VOID Flush() const;
	};

	/// <summary>
	/// Represents a local text based file.
	/// </summary>
	class AURORA_API TextFile : public File {
		FILE* lpFile;

	public:
		constexpr TextFile() noexcept;
		
		/// <summary>
		/// Creates or opens a text file.
		/// </summary>
		/// <param name="lpFileName">- The name of the file. This can be either relative to the host process or absolute.</param>
		/// <param name="dwCreationDisposition">- The creation disposition. See CreationDisposition for more.</param>
		/// <param name="dwDesiredAccess">- The desired access mode to the file. See FileAccessFlags for more.</param>
		/// <param name="dwAttributes">- The file attributes. See FileAttributeFlags for more.</param>
		/// <param name="dwFlags">- The file flags. See FileFlags for more.</param>
		/// <param name="dwShareMode">- The instance share mode. See FileShareModeFlags for more.</param>
		/// <param name="refTemplateFile">- A reference to a File instance to use as a template for the created file.</param>
		/// <param name="lpSecurityAttributes">- A pointer to a security attributes structure containing security information for the newly created directory. This parameter is optional.</param>
		/// <exception cref="WindowsApiException"/>
		/// <exception cref="ParameterInvalidException"/>
		TextFile(
			_In_z_ A_LPCSTR lpFileName,
			_In_ CreationDisposition dwCreationDisposition,
			_In_ FileAccessFlags dwDesiredAccess = FileAccessFlags::Read | FileAccessFlags::Write,
			_In_ FileAttributeFlags dwAttributes = FileAttributeFlags::Normal,
			_In_ FileFlags dwFlags = FileFlags::None,
			_In_ FileShareModeFlags dwShareMode = FileShareModeFlags::All,
			_In_opt_ const File& refTemplateFile = File(),
			_In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes = nullptr
		);

		~TextFile();

		/// <summary>
		/// Reads the format from the current file pointer.
		/// </summary>
		/// <param name="lpFormat">- The format to read.</param>
		/// <param name="lpArgs">- The format arguments.</param>
		/// <exception cref="ErrnoException"/>
		A_VOID ReadFormatV(_In_z_ _Scanf_format_string_ A_LPCSTR lpFormat, _In_ va_list lpArgs) const;

		/// <summary>
		/// Reads the format from the current file pointer.
		/// </summary>
		/// <param name="lpFormat">- The format to read.</param>
		/// <exception cref="ErrnoException"/>
		A_VOID ReadFormat(_In_z_ _Scanf_format_string_ A_LPCSTR lpFormat, ...) const;

		/// <summary>
		/// Writes the format to the current file pointer.
		/// </summary>
		/// <param name="lpFormat">- The format to write.</param>
		/// <param name="lpArgs">- The format arguments.</param>
		/// <exception cref="ErrnoException"/>
		A_VOID WriteFormatV(_In_z_ _Printf_format_string_ A_LPCSTR lpFormat, _In_ va_list lpArgs) const;

		/// <summary>
		/// Writes the format to the current file pointer.
		/// </summary>
		/// <param name="lpFormat">- The format to write.</param>
		/// <exception cref="ErrnoException"/>
		A_VOID WriteFormat(_In_z_ _Printf_format_string_ A_LPCSTR lpFormat, ...) const;
	};

	/// <summary>
	/// Represents a local directory.
	/// </summary>
	class AURORA_API Directory {
		A_CHAR szDirectoryPath[MAX_PATH];
		A_CHAR szDirectoryName[MAX_NAME];

	public:
		/// <summary>
		/// Opens an existing directory.
		/// </summary>
		/// <param name="lpDirectoryName">- The name of the directory to open.</param>
		/// <exception cref="WindowsApiException"/>
		/// <exception cref="ParameterInvalidException"/>
		Directory(_In_z_ A_LPCSTR lpDirectoryName);

		/// <summary>
		/// Gets an absolute path to the directory.
		/// </summary>
		/// <returns>The full directory path.</returns>
		AURORA_NDWR_GET("GetDirectoryPath") _Ret_z_ constexpr A_LPCSTR GetDirectoryPath() const noexcept;

		/// <summary>
		/// Gets the name of the directory.
		/// </summary>
		/// <returns>The directory name.</returns>
		AURORA_NDWR_GET("GetDirectoryName") _Ret_z_ constexpr A_LPCSTR GetDirectoryName() const noexcept;
		
		/// <summary>
		/// Gets the current directory attribute flags.
		/// </summary>
		/// <returns>The directory attributes.</returns>
		/// <exception cref="WindowsApiException"/>
		AURORA_NDWR_GET("GetAttributes") FileAttributeFlags GetAttributes() const;

		/// <summary>
		/// Sets the current directory attribute flags.
		/// </summary>
		/// <param name="dwAttributes">- The attributes to set.</param>
		/// <exception cref="WindowsApiException"/>
		A_VOID SetAttributes(_In_ FileAttributeFlags dwAttributes) const;

		/// <summary>
		/// Creates or opens a sub-directory in the current directory.
		/// </summary>
		/// <param name="lpDirectoryName">- The name of the directory to create.</param>
		/// <param name="bThrowOnExists">- Determines wether the function should throw or complete successfully if the directory already exists. Defaults to false.</param>
		/// <param name="lpSecurityAttributes">- A pointer to a security attributes structure containing security information for the newly created directory. This parameter is optional.</param>
		/// <returns>The newly created directory.</returns>
		/// <exception cref="WindowsApiException"/>
		/// <exception cref="ParameterInvalidException"/>
		AURORA_NDWR_CREATE("CreateDirectory") Directory CreateDirectory(
			_In_z_ A_LPCSTR lpDirectoryName,
			_In_ A_BOOL bThrowOnExists = false,
			_In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes = nullptr
		) const;

		/// <summary>
		/// Creates a file in the current directory.
		/// </summary>
		/// <param name="lpFileName">- The name of the file to create.</param>
		/// <param name="dwCreationDisposition">- The disposition of the creation.</param>
		/// <param name="dwDesiredAccess">- The desired access mode to the file.</param>
		/// <param name="dwAttributes">- The attributes of the file.</param>
		/// <param name="dwFlags">- Any additional file flags.</param>
		/// <param name="dwShareMode">- The share mode of the file.</param>
		/// <param name="refTemplateFile">- A reference to a file object to use as the template of the file. Only applicable if the file is created.</param>
		/// <param name="lpSecurityAttributes">- A pointer to a security attributes structure containing security information for the newly created file. This parameter is optional.</param>
		/// <returns>The newly created file.</returns>
		/// <exceptions cref="WindowsApiException"/>
		/// <exception cref="ParameterInvalidException"/>
		AURORA_NDWR_CREATE("CreateFile") File CreateFile(
			_In_z_ A_LPCSTR lpFileName,
			_In_ CreationDisposition dwCreationDisposition,
			_In_ FileAccessFlags dwDesiredAccess = FileAccessFlags::Read | FileAccessFlags::Write,
			_In_ FileAttributeFlags dwAttributes = FileAttributeFlags::Normal,
			_In_ FileFlags dwFlags = FileFlags::None,
			_In_ FileShareModeFlags dwShareMode = FileShareModeFlags::All,
			_In_opt_ const File& refTemplateFile = File(),
			_In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes = nullptr
		) const;
	};

	/// <summary>
	/// Creates a directory at the specified location.
	/// </summary>
	/// <param name="lpDirectoryName">- A full path or a path relative to the current process to create the directory at.</param>
	/// <param name="bThrowOnExists">- Determines wether the function should throw or complete successfully if the directory already exists. Defaults to false.</param>
	/// <param name="lpSecurityAttributes">- A pointer to a security attributes structure containing security information for the newly created directory. This parameter is optional.</param>
	/// <returns>The newly created directory.</returns>
	/// <exception cref="WindowsApiException"/>'
	/// <exception cref="ParameterInvalidException"/>
	AURORA_NDWR_CREATE("CreateDirectory") AURORA_API Directory CreateDirectory(
		_In_z_ A_LPCSTR lpDirectoryName,
		_In_ A_BOOL bThrowOnExists = false,
		_In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes = nullptr
	);

	/// <summary>
	/// Represents a local root directory. (C:\, D:\ etc...)
	/// </summary>
	class AURORA_API RootDirectory : public Directory {
		A_CHAR szDrivePath[4];

		_Ret_z_ A_LPCSTR SetDrivePath(_In_ A_CHAR cDriveLetter);

	public:
		/// <summary>
		/// Constructs a RootDirectory.
		/// </summary>
		/// <param name="cDriveLetter">- The letter of the drive to open. The character MUST be uppercase, otherwise this function will fail.</param>
		/// <exception cref="ParameterInvalidException"/>
		RootDirectory(_In_range_('C', 'Z') A_CHAR cDriveLetter);

		/// <summary>
		/// Gets the total number of bytes on the disk.
		/// </summary>
		/// <returns>The total disk space.</returns>
		AURORA_NDWR_GET("GetTotalDiskSpace") A_U64 GetTotalDiskSpace() const;

		/// <summary>
		/// Gets the total number of free bytes on the disk.
		/// </summary>
		/// <returns>The total free disk space.</returns>
		AURORA_NDWR_GET("GetFreeDiskSpace") A_U64 GetFreeDiskSpace() const;
	};
}

#endif // !__AURORA_FILE_SYSTEM_H__
```

`Artemis/Aurora/HDE/hde32.h`:

```h
/*
 * Hacker Disassembler Engine 32
 * Copyright (c) 2006-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 * hde32.h: C/C++ header file
 *
 */

#ifndef _HDE32_H_
#define _HDE32_H_

/* stdint.h - C99 standard header
 * http://en.wikipedia.org/wiki/stdint.h
 *
 * if your compiler doesn't contain "stdint.h" header (for
 * example, Microsoft Visual C++), you can download file:
 *   http://www.azillionmonkeys.com/qed/pstdint.h
 * and change next line to:
 *   #include "pstdint.h"
 */
#include <stdint.h>

#define F_MODRM         0x00000001
#define F_SIB           0x00000002
#define F_IMM8          0x00000004
#define F_IMM16         0x00000008
#define F_IMM32         0x00000010
#define F_DISP8         0x00000020
#define F_DISP16        0x00000040
#define F_DISP32        0x00000080
#define F_RELATIVE      0x00000100
#define F_2IMM16        0x00000800
#define F_ERROR         0x00001000
#define F_ERROR_OPCODE  0x00002000
#define F_ERROR_LENGTH  0x00004000
#define F_ERROR_LOCK    0x00008000
#define F_ERROR_OPERAND 0x00010000
#define F_PREFIX_REPNZ  0x01000000
#define F_PREFIX_REPX   0x02000000
#define F_PREFIX_REP    0x03000000
#define F_PREFIX_66     0x04000000
#define F_PREFIX_67     0x08000000
#define F_PREFIX_LOCK   0x10000000
#define F_PREFIX_SEG    0x20000000
#define F_PREFIX_ANY    0x3f000000

#define PREFIX_SEGMENT_CS   0x2e
#define PREFIX_SEGMENT_SS   0x36
#define PREFIX_SEGMENT_DS   0x3e
#define PREFIX_SEGMENT_ES   0x26
#define PREFIX_SEGMENT_FS   0x64
#define PREFIX_SEGMENT_GS   0x65
#define PREFIX_LOCK         0xf0
#define PREFIX_REPNZ        0xf2
#define PREFIX_REPX         0xf3
#define PREFIX_OPERAND_SIZE 0x66
#define PREFIX_ADDRESS_SIZE 0x67

#pragma pack(push,1)

typedef struct {
    uint8_t len;
    uint8_t p_rep;
    uint8_t p_lock;
    uint8_t p_seg;
    uint8_t p_66;
    uint8_t p_67;
    uint8_t opcode;
    uint8_t opcode2;
    uint8_t modrm;
    uint8_t modrm_mod;
    uint8_t modrm_reg;
    uint8_t modrm_rm;
    uint8_t sib;
    uint8_t sib_scale;
    uint8_t sib_index;
    uint8_t sib_base;
    union {
        uint8_t imm8;
        uint16_t imm16;
        uint32_t imm32;
    } imm;
    union {
        uint8_t disp8;
        uint16_t disp16;
        uint32_t disp32;
    } disp;
    uint32_t flags;
} hde32s;

#pragma pack(pop)

#ifdef __cplusplus
extern "C" {
#endif

#ifdef _AURORA_EXPORT
__declspec(dllexport) unsigned int __cdecl hde32_disasm(const void *code, hde32s *hs);
#else
__declspec(dllimport) unsigned int __cdecl hde32_disasm(const void *code, hde32s *hs);
#endif // _AURORA_EXPORT

#ifdef __cplusplus
}
#endif

#endif /* _HDE32_H_ */

```

`Artemis/Aurora/HDE/hde64.h`:

```h
/*
 * Hacker Disassembler Engine 64
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 * hde64.h: C/C++ header file
 *
 */

#ifndef _HDE64_H_
#define _HDE64_H_

/* stdint.h - C99 standard header
 * http://en.wikipedia.org/wiki/stdint.h
 *
 * if your compiler doesn't contain "stdint.h" header (for
 * example, Microsoft Visual C++), you can download file:
 *   http://www.azillionmonkeys.com/qed/pstdint.h
 * and change next line to:
 *   #include "pstdint.h"
 */
#include <stdint.h>

#define F_MODRM         0x00000001
#define F_SIB           0x00000002
#define F_IMM8          0x00000004
#define F_IMM16         0x00000008
#define F_IMM32         0x00000010
#define F_IMM64         0x00000020
#define F_DISP8         0x00000040
#define F_DISP16        0x00000080
#define F_DISP32        0x00000100
#define F_RELATIVE      0x00000200
#define F_ERROR         0x00001000
#define F_ERROR_OPCODE  0x00002000
#define F_ERROR_LENGTH  0x00004000
#define F_ERROR_LOCK    0x00008000
#define F_ERROR_OPERAND 0x00010000
#define F_PREFIX_REPNZ  0x01000000
#define F_PREFIX_REPX   0x02000000
#define F_PREFIX_REP    0x03000000
#define F_PREFIX_66     0x04000000
#define F_PREFIX_67     0x08000000
#define F_PREFIX_LOCK   0x10000000
#define F_PREFIX_SEG    0x20000000
#define F_PREFIX_REX    0x40000000
#define F_PREFIX_ANY    0x7f000000

#define PREFIX_SEGMENT_CS   0x2e
#define PREFIX_SEGMENT_SS   0x36
#define PREFIX_SEGMENT_DS   0x3e
#define PREFIX_SEGMENT_ES   0x26
#define PREFIX_SEGMENT_FS   0x64
#define PREFIX_SEGMENT_GS   0x65
#define PREFIX_LOCK         0xf0
#define PREFIX_REPNZ        0xf2
#define PREFIX_REPX         0xf3
#define PREFIX_OPERAND_SIZE 0x66
#define PREFIX_ADDRESS_SIZE 0x67

#pragma pack(push,1)

typedef struct {
    uint8_t len;
    uint8_t p_rep;
    uint8_t p_lock;
    uint8_t p_seg;
    uint8_t p_66;
    uint8_t p_67;
    uint8_t rex;
    uint8_t rex_w;
    uint8_t rex_r;
    uint8_t rex_x;
    uint8_t rex_b;
    uint8_t opcode;
    uint8_t opcode2;
    uint8_t modrm;
    uint8_t modrm_mod;
    uint8_t modrm_reg;
    uint8_t modrm_rm;
    uint8_t sib;
    uint8_t sib_scale;
    uint8_t sib_index;
    uint8_t sib_base;
    union {
        uint8_t imm8;
        uint16_t imm16;
        uint32_t imm32;
        uint64_t imm64;
    } imm;
    union {
        uint8_t disp8;
        uint16_t disp16;
        uint32_t disp32;
    } disp;
    uint32_t flags;
} hde64s;

#pragma pack(pop)

#ifdef __cplusplus
extern "C" {
#endif

#ifdef _AURORA_EXPORT
__declspec(dllexport) unsigned int __cdecl hde64_disasm(const void *code, hde64s *hs);
#else
__declspec(dllimport) unsigned int __cdecl hde64_disasm(const void *code, hde64s *hs);
#endif // _AURORA_EXPORT

#ifdef __cplusplus
}
#endif

#endif /* _HDE64_H_ */

```

`Artemis/Aurora/Logger.h`:

```h
//------------------------------------------------------------------------>
// MIT License
// 
// Copyright (c) 2023 Artemis Group
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------>
// Aurora: https://github.com/ArtemisDevGroup/Aurora
// This file was authored by:
// @Astrea0014: https://github.com/Astrea0014
//------------------------------------------------------------------------>

#ifndef __AURORA_LOGGER_H__
#define __AURORA_LOGGER_H__

#include "Definitions.h"
#include "Exceptions.h"
#include "Console.h"
#include "Time.h"

namespace Aurora {
	/// <summary>
	/// Logs messages to the console and/or a file.
	/// </summary>
	class AURORA_API Logger {
	private:
		A_BOOL bLogToConsole;
		A_BOOL bLogToFile;
		FILE* lpLogFile;
		A_CHAR szLogFileName[MAX_PATH];

		A_VOID BeginPrintSession();
		A_VOID EndPrintSession();

	protected:
		/// <summary>
		/// Prints a format to the log file.
		/// </summary>
		/// <param name="lpFormat">- The format to print.</param>
		/// <param name="...">- The format arguments.</param>
		/// <exception cref="ParameterInvalidException"/>
		A_VOID PrintFile(_In_ _Printf_format_string_ A_LPCSTR lpFormat, ...) const;

		/// <summary>
		/// Prints a format to the log file.
		/// </summary>
		/// <param name="lpFormat">- The format to print.</param>
		/// <param name="lpArgs">- The format arguments.</param>
		/// <exception cref="ParameterInvalidException"/>
		A_VOID PrintFileV(_In_ _Printf_format_string_ A_LPCSTR lpFormat, _In_ va_list lpArgs) const;

		/// <summary>
		/// Virtual method that gets called every time the logger instance requests logging to the log file.
		/// </summary>
		/// <param name="refTime">- A reference to a time instance representing the time at which the method was called.</param>
		/// <param name="lpSender">- The sender of the log message. This is usually set to the name of the function printing to the log.</param>
		/// <param name="lpPrefix">- The log level prefix.</param>
		/// <param name="lpFormat">- The format string.</param>
		/// <param name="lpArgs">- The format arguments.</param>
		virtual A_VOID LogToFile(
			_In_ const Time& refTime,
			_In_z_ A_LPCSTR lpSender,
			_In_z_ A_LPCSTR lpPrefix,
			_In_z_ _Printf_format_string_ A_LPCSTR lpFormat,
			_In_ va_list lpArgs
		);

		// <summary>
		/// Virtual method that gets called every time the logger instance requests logging to the console.
		/// </summary>
		/// <param name="refTime">- A reference to a time instance representing the time at which the method was called.</param>
		/// <param name="lpSender">- The sender of the log message. This is usually set to the name of the function printing to the log.</param>
		/// <param name="lpPrefix">- The log level prefix.</param>
		/// <param name="dwPrefixColor">- The color of the prefix string.</param>
		/// <param name="lpFormat">- The format string.</param>
		/// <param name="lpArgs">- The format arguments.</param>
		virtual A_VOID LogToConsole(
			_In_ const Time& refTime,
			_In_z_ A_LPCSTR lpSender,
			_In_z_ A_LPCSTR lpPrefix,
			_In_ ConsoleColorLegacyFlags dwPrefixColor,
			_In_z_ _Printf_format_string_ A_LPCSTR lpFormat,
			_In_ va_list lpArgs
		);

	private:
		A_VOID Log(
			_In_z_ A_LPCSTR lpSender,
			_In_z_ A_LPCSTR lpPrefix,
			_In_ ConsoleColorLegacyFlags dwPrefixColor,
			_In_z_ _Printf_format_string_ A_LPCSTR lpFormat,
			_In_ va_list lpArgs
		);

	public:
		constexpr Logger() noexcept;

		/// <summary>
		/// Constructs a Logger.
		/// </summary>
		/// <param name="bLogToConsole">- If set to true, enables logging to the console. 'LogToConsole' will be called for every log message.</param>
		/// <param name="blogToFile">- If set to true, enables logging to a file. 'LogToFile' will be called for every log message.</param>
		/// <param name="lpLogFileName">
		/// <para>- The name of the log file. If nullptr, "log.log" will be used as the name instead</para>
		/// <para>This parameter is only necessary to specify if you are running multiple Logger instances.</para>
		/// <para>This parameter can also be used to set the log file location for the instance, either to a relative or absolute path.</para>
		/// </param>
		Logger(
			_In_ A_BOOL bLogToConsole,
			_In_ A_BOOL blogToFile,
			_In_opt_z_ A_LPCSTR lpLogFileName = nullptr
		);

		/// <summary>
		/// Logs an informational message.
		/// </summary>
		/// <param name="lpSender">- The sender of the log message. This is usually set to the name of the function printing to the log.</param>
		/// <param name="lpFormat">- The format of the message.</param>
		/// <param name="lpArgs">- The format arguments.</param>
		/// <exception cref="ParameterInvalidException"/>
		/// <exception cref="ErrnoException"/>
		A_VOID LogInfoV(_In_z_ A_LPCSTR lpSender, _In_z_ _Printf_format_string_ A_LPCSTR lpFormat, _In_ va_list lpArgs);

		/// <summary>
		/// Logs an informational message.
		/// </summary>
		/// <param name="lpSender">- The sender of the log message. This is usually set to the name of the function printing to the log.</param>
		/// <param name="lpFormat">- The format of the message.</param>
		/// <param name="...">- The format arguments.</param>
		/// <exception cref="ParameterInvalidException"/>
		/// <exception cref="ErrnoException"/>
		A_VOID LogInfo(_In_z_ A_LPCSTR lpSender, _In_z_ _Printf_format_string_ A_LPCSTR lpFormat, ...);

		/// <summary>
		/// Logs a message indicating success.
		/// </summary>
		/// <param name="lpSender">- The sender of the log message. This is usually set to the name of the function printing to the log.</param>
		/// <param name="lpFormat">- The format of the message.</param>
		/// <param name="lpArgs">- The format arguments.</param>
		/// <exception cref="ParameterInvalidException"/>
		/// <exception cref="ErrnoException"/>
		A_VOID LogSuccessV(_In_z_ A_LPCSTR lpSender, _In_z_ _Printf_format_string_ A_LPCSTR lpFormat, _In_ va_list lpArgs);

		// <summary>
		/// Logs a message indicating success.
		/// </summary>
		/// <param name="lpSender">- The sender of the log message. This is usually set to the name of the function printing to the log.</param>
		/// <param name="lpFormat">- The format of the message.</param>
		/// <param name="...">- The format arguments.</param>
		/// <exception cref="ParameterInvalidException"/>
		/// <exception cref="ErrnoException"/>
		A_VOID LogSuccess(_In_z_ A_LPCSTR lpSender, _In_z_ _Printf_format_string_ A_LPCSTR lpFormat, ...);

		/// <summary>
		/// Logs a warning message.
		/// </summary>
		/// <param name="lpSender">- The sender of the log message. This is usually set to the name of the function printing to the log.</param>
		/// <param name="lpFormat">- The format of the message.</param>
		/// <param name="lpArgs">- The format arguments.</param>
		/// <exception cref="ParameterInvalidException"/>
		/// <exception cref="ErrnoException"/>
		A_VOID LogWarningV(_In_z_ A_LPCSTR lpSender, _In_z_ _Printf_format_string_ A_LPCSTR lpFormat, _In_ va_list lpArgs);

		// <summary>
		/// Logs a message indicating success.
		/// </summary>
		/// <param name="lpSender">- The sender of the log message. This is usually set to the name of the function printing to the log.</param>
		/// <param name="lpFormat">- The format of the message.</param>
		/// <param name="...">- The format arguments.</param>
		/// <exception cref="ParameterInvalidException"/>
		/// <exception cref="ErrnoException"/>
		A_VOID LogWarning(_In_z_ A_LPCSTR lpSender, _In_z_ _Printf_format_string_ A_LPCSTR lpFormat, ...);

		/// <summary>
		/// Logs a message indicating an error.
		/// </summary>
		/// <param name="lpSender">- The sender of the log message. This is usually set to the name of the function printing to the log.</param>
		/// <param name="lpFormat">- The format of the message.</param>
		/// <param name="lpArgs">- The format arguments.</param>
		/// <exception cref="ParameterInvalidException"/>
		/// <exception cref="ErrnoException"/>
		A_VOID LogErrorV(_In_z_ A_LPCSTR lpSender, _In_z_ _Printf_format_string_ A_LPCSTR lpFormat, _In_ va_list lpArgs);

		// <summary>
		/// Logs a message indicating success.
		/// </summary>
		/// <param name="lpSender">- The sender of the log message. This is usually set to the name of the function printing to the log.</param>
		/// <param name="lpFormat">- The format of the message.</param>
		/// <param name="...">- The format arguments.</param>
		/// <exception cref="ParameterInvalidException"/>
		/// <exception cref="ErrnoException"/>
		A_VOID LogError(_In_z_ A_LPCSTR lpSender, _In_z_ _Printf_format_string_ A_LPCSTR lpFormat, ...);
	};
}

#endif // !__AURORA_LOGGER_H__
```

`Artemis/Aurora/Memory.h`:

```h
//------------------------------------------------------------------------>
// MIT License
// 
// Copyright (c) 2023 Artemis Group
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------>
// Aurora: https://github.com/ArtemisDevGroup/Aurora
// This file was authored by:
// @Astrea0014: https://github.com/Astrea0014
//------------------------------------------------------------------------>

#ifndef __AURORA_MEMORY_H__
#define __AURORA_MEMORY_H__

#include "Definitions.h"
#include "ProcessInfo.h"
#include "MemoryTypes.h"

namespace Aurora {
	/// <summary>
	/// Reads memory from an address into a buffer. This function is unsafe and shall not be used unless speed is mandetory.
	/// </summary>
	/// <param name="uAddress">- The address to read memory from.</param>
	/// <param name="lpBuffer">- A pointer to a buffer that receives the read data.</param>
	/// <param name="dwSize">- The number of bytes to read.</param>
	/// <exception cref="ParameterInvalidException"/>
	AURORA_API A_VOID UnsafeRead(
		_In_a_ A_ADDR uAddress,
		_Out_writes_bytes_(dwSize) A_LPVOID lpBuffer,
		_In_ A_DWORD dwSize
	);

	/// <summary>
	/// Reads memory from an address and returns it. This function is unsafe and shall not be used unless speed is mandetory.
	/// </summary>
	/// <typeparam name="ReturnType">- The type to read.</typeparam>
	/// <param name="uAddress">- The address to read memory from.</param>
	/// <returns>The read data.</returns>
	/// <exception cref="ParameterInvalidException"/>
	/// <exception cref="ReadException"/>
	template<ReadReturnType ReturnType>
	AURORA_NDWR_PURE("UnsafeRead") inline ReturnType UnsafeRead(_In_a_ A_ADDR uAddress) {
		AuroraContextStart();

		ReturnType ret = ReturnType();
		UnsafeRead(uAddress, (A_LPVOID)&ret, sizeof(ReturnType));

		AuroraContextEnd();
		return ret;
	}

	/// <summary>
	/// Reads memory from an address and returns it. This function is unsafe and shall not be used unless speed is mandetory.
	/// </summary>
	/// <typeparam name="ReturnType">- The type to read.</typeparam>
	/// <param name="uAddress">- The address to read memory from.</param>
	/// <param name="lpBuffer">- A reference to a buffer to receive the read data.</param>
	/// <exception cref="ParameterInvalidException"/>
	/// <exception cref="ReadException"/>
	template<ReadReturnType ReturnType, A_I32 nSize>
	inline A_VOID UnsafeRead(
		_In_a_ A_ADDR uAddress,
		_Out_writes_(nSize) ReturnType(&lpBuffer)[nSize]
	) {
		AuroraContextStart();
		UnsafeRead(uAddress, (A_LPVOID)lpBuffer, nSize * sizeof(ReturnType));
		AuroraContextEnd();
	}

	/// <summary>
	/// Reads memory from an address into a buffer.
	/// </summary>
	/// <param name="uAddress">- The address to read memory from.</param>
	/// <param name="lpBuffer">- A pointer to a buffer that receives the read data.</param>
	/// <param name="dwSize">- The number of bytes to read.</param>
	/// <exception cref="ParameterInvalidException"/>
	/// <exception cref="ReadException"/>
	AURORA_API A_VOID Read(
		_In_a_ A_ADDR uAddress,
		_Out_writes_bytes_(dwSize) A_LPVOID lpBuffer,
		_In_ A_DWORD dwSize
	);

	/// <summary>
	/// Reads memory from an address and returns it.
	/// </summary>
	/// <typeparam name="ReturnType">- The type to read.</typeparam>
	/// <param name="uAddress">- The address to read memory from.</param>
	/// <returns>The read data.</returns>
	/// <exception cref="ParameterInvalidException"/>
	/// <exception cref="ReadException"/>
	template<ReadReturnType ReturnType>
	AURORA_NDWR_PURE("Read") inline ReturnType Read(_In_a_ A_ADDR uAddress) {
		AuroraContextStart();
		
		ReturnType ret = ReturnType();
		Read(uAddress, (A_LPVOID)&ret, sizeof(ReturnType));

		AuroraContextEnd();
		return ret;
	}

	/// <summary>
	/// Reads memory from an address.
	/// </summary>
	/// <typeparam name="ReturnType">- The type to read.</typeparam>
	/// <param name="uAddress">- The address to read memory from.</param>
	/// <param name="lpBuffer">- A reference to a buffer to receive the read data.</param>
	/// <exception cref="ParameterInvalidException"/>
	/// <exception cref="ReadException"/>
	template<ReadReturnType ReturnType, A_I32 nSize>
	inline A_VOID Read(
		_In_a_ A_ADDR uAddress,
		_Out_writes_(nSize) ReturnType(&lpBuffer)[nSize]
	) {
		AuroraContextStart();
		Read(uAddress, (A_LPVOID)lpBuffer, nSize * sizeof(ReturnType));
		AuroraContextEnd();
	}

	/// <summary>
	/// Reads the address at the end of a pointer chain and returns it.
	/// </summary>
	/// <typeparam name="PointerType">- The type of data at the end of the pointer. In this instance, it does not have an effect on the return value.</typeparam>
	/// <param name="uBaseAddress">- The base address of the pointer.</param>
	/// <param name="refPointer">- A reference to the pointer.</param>
	/// <returns>The address at the end of the pointer chain.</returns>
	/// <exception cref="ParameterInvalidException"/>
	/// <exception cref="ReadException"/>
	template<typename PointerType>
	AURORA_NDWR_PURE("ReadPtrAddress") inline A_ADDR ReadPtrAddress(
		_In_a_ A_ADDR uBaseAddress,
		_In_ const Pointer<PointerType>& refPointer
	) {
		AuroraContextStart();

		for (A_ADDR uOffset : refPointer)
			uBaseAddress = Read<A_ADDR>(uBaseAddress) + uOffset;

		AuroraContextEnd();
		return uBaseAddress;
	}

	/// <summary>
	/// Reads the address at the end of a pointer chain and returns it.
	/// </summary>
	/// <typeparam name="PointerType">- The type of data at the end of the pointer. In this instance, it does not have an effect on the return value.</typeparam>
	/// <param name="refModuleInfo">- A reference to the module containing the base address of the pointer.</param>
	/// <param name="refPointer">- A reference to the pointer.</param>
	/// <returns>The address at the end of the pointer chain.</returns>
	/// <exception cref="ParameterInvalidException"/>
	/// <exception cref="ReadException"/>
	template<typename PointerType>
	AURORA_NDWR_PURE("ReadPtrAddress") inline A_ADDR ReadPtrAddress(
		_In_ const ModuleInfo& refModuleInfo,
		_In_ const BasePointer<PointerType>& refPointer
	) {
		AuroraContextStart();

		A_ADDR uAddress = refModuleInfo.GetModuleBaseAddress() + refPointer.GetOffset();

		for (A_ADDR uOffset : refPointer)
			uAddress = Read<A_ADDR>(uAddress) + uOffset;

		AuroraContextEnd();
		return uAddress;
	}

	// ReadPtr definitions dealing with standard pointers and requiring explicit specification of return type.

	/// <summary>
	/// Reads memory from the end of a pointer chain and returns it.
	/// </summary>
	/// <typeparam name="ReturnType">- The type to read.</typeparam>
	/// <typeparam name="PointerType">- The type specified by the pointer.</typeparam>
	/// <param name="uBaseAddress">- The base address of the pointer.</param>
	/// <param name="refPointer">- A reference to the pointer.</param>
	/// <returns>The read data.</returns>
	/// <exception cref="ParameterInvalidException"/>
	/// <exception cref="ReadException"/>
	template<ReadReturnType ReturnType, typename PointerType>
	AURORA_NDWR_PURE("ReadPtr") inline ReturnType ReadPtr(
		_In_a_ A_ADDR uBaseAddress,
		_In_ const Pointer<PointerType>& refPointer
	) {
		AuroraContextStart();
		ReturnType retValue = Read<ReturnType>(ReadPtrAddress<PointerType>(uBaseAddress, refPointer));
		AuroraContextEnd();
		return retValue;
	}

	/// <summary>
	/// Reads memory from the end of a pointer.
	/// </summary>
	/// <typeparam name="ReturnType">- The type to read.</typeparam>
	/// <typeparam name="PointerType">- The type specified by the pointer.</typeparam>
	/// <typeparam name="nSize">- The number of elements in the array.</typeparam>
	/// <param name="uBaseAddress">- The base address of the pointer.</param>
	/// <param name="refPointer">- A reference to the pointer.</param>
	/// <param name="lpBuffer">- A reference to a buffer to receive the read data.</param>
	/// <exception cref="ParameterInvalidException"/>
	/// <exception cref="ReadException"/>
	template<ReadReturnType ReturnType, typename PointerType, A_I32 nSize>
	inline A_VOID ReadPtr(
		_In_a_ A_ADDR uBaseAddress,
		_In_ const Pointer<PointerType>& refPointer,
		_Out_writes_(nSize) ReturnType(&lpBuffer)[nSize]
	) {
		AuroraContextStart();
		Read<ReturnType, nSize>(ReadPtrAddress<PointerType>(uBaseAddress, refPointer), lpBuffer);
		AuroraContextEnd();
	}

	/// <summary>
	/// Reads memory from the end of a pointer.
	/// </summary>
	/// <typeparam name="ReturnType">- The type to read.</typeparam>
	/// <typeparam name="PointerType">- The type specified by the pointer.</typeparam>
	/// <param name="uBaseAddress">- The base address of the pointer.</param>
	/// <param name="refPointer">- A reference to the pointer.</param>
	/// <param name="lpBuffer">- A pointer to a buffer to receive the read data.</param>
	/// <param name="nSize">- The size of the buffer in elements.</param>
	/// <exception cref="ParameterInvalidException"/>
	/// <exception cref="ReadException"/>
	template<ReadReturnType ReturnType, typename PointerType>
	inline A_VOID ReadPtr(
		_In_a_ A_ADDR uBaseAddress,
		_In_ const Pointer<PointerType>& refPointer,
		_Out_writes_(nSize) ReturnType* lpBuffer,
		_In_ A_I32 nSize
	) {
		AuroraContextStart();
		Read(ReadPtrAddress<PointerType>(uBaseAddress, refPointer), lpBuffer, nSize * sizeof(ReturnType));
		AuroraContextEnd();
	}

	// ReadPtr definitions dealing with base pointers and requiring explicit specification of return type.

	/// <summary>
	/// Reads memory from the end of a pointer chain and returns it.
	/// </summary>
	/// <typeparam name="ReturnType">- The type to read.</typeparam>
	/// <typeparam name="PointerType">- The type specified by the pointer.</typeparam>
	/// <param name="refModuleInfo">- A reference to the module containing the base of the pointer.</param>
	/// <param name="refPointer">- A reference to the base pointer.</param>
	/// <returns>The read data.</returns>
	/// <exception cref="ParameterInvalidException"/>
	/// <exception cref="ReadException"/>
	template<ReadReturnType ReturnType, typename PointerType>
	AURORA_NDWR_PURE("ReadPtr") inline ReturnType ReadPtr(
		_In_ const ModuleInfo& refModuleInfo,
		_In_ const BasePointer<PointerType>& refPointer
	) {
		AuroraContextStart();
		ReturnType retValue = Read<ReturnType>(ReadPtrAddress<PointerType>(refModuleInfo, refPointer));
		AuroraContextEnd();
		return retValue;
	}

	/// <summary>
	/// Reads memory from the end of a pointer chain.
	/// </summary>
	/// <typeparam name="ReturnType">- The type to read.</typeparam>
	/// <typeparam name="PointerType">- The type specified by the pointer.</typeparam>
	/// <typeparam name="nSize">- The number of elements in the array.</typeparam>
	/// <param name="refModuleInfo">- A reference to the module containing the base of the pointer.</param>
	/// <param name="refPointer">- A reference to the base pointer.</param>
	/// <param name="lpBuffer">- A reference to a buffer to receive the read data.</param>
	/// <exception cref="ParameterInvalidException"/>
	/// <exception cref="ReadException"/>
	template<ReadReturnType ReturnType, typename PointerType, A_I32 nSize>
	inline A_VOID ReadPtr(
		_In_ const ModuleInfo& refModuleInfo,
		_In_ const BasePointer<PointerType>& refPointer,
		_Out_writes_(nSize) ReturnType(&lpBuffer)[nSize]
	) {
		AuroraContextStart();
		Read<ReturnType, nSize>(ReadPtrAddress<PointerType>(refModuleInfo, refPointer), lpBuffer);
		AuroraContextEnd();
	}

	/// <summary>
	/// Reads memory from the end of a pointer chain.
	/// </summary>
	/// <typeparam name="ReturnType">- The type to read.</typeparam>
	/// <typeparam name="PointerType">- The type specified by the pointer.</typeparam>
	/// <param name="refModuleInfo">- A reference to the module containing the base of the pointer.</param>
	/// <param name="refPointer">- A reference to the base pointer.</param>
	/// <param name="lpBuffer">- A pointer to a buffer to receive the read data.</param>
	/// <param name="nSize">- The size of the buffer in elements.</param>
	/// <exception cref="ParameterInvalidException"/>
	/// <exception cref="ReadException"/>
	template<ReadReturnType ReturnType, typename PointerType>
	inline A_VOID ReadPtr(
		_In_ const ModuleInfo& refModuleInfo,
		_In_ const BasePointer<PointerType>& refPointer,
		_Out_writes_(nSize) ReturnType* lpBuffer,
		_In_ A_I32 nSize
	) {
		AuroraContextStart();
		Read(ReadPtrAddress<PointerType>(refModuleInfo, refPointer), lpBuffer, nSize * sizeof(ReturnType));
		AuroraContextEnd();
	}

	// ReadPtr definitions dealing with standard pointers and inheriting the return type of the pointer.

	/// <summary>
	/// Reads data from the end of a pointer and returns it.
	/// </summary>
	/// <typeparam name="ReturnType">- The type to read.</typeparam>
	/// <param name="uBaseAddress">- The base address of the pointer.</param>
	/// <param name="refPointer">- A reference to the pointer.</param>
	/// <returns>The read data.</returns>
	/// <exception cref="ParameterInvalidException"/>
	/// <exception cref="ReadException"/>
	template<ReadReturnType ReturnType>
	AURORA_NDWR_PURE("ReadPtr") inline ReturnType ReadPtr(
		_In_a_ A_ADDR uBaseAddress,
		_In_ const Pointer<ReturnType>& refPointer
	) {
		AuroraContextStart();
		ReturnType retValue = Read<ReturnType>(ReadPtrAddress<ReturnType>(uBaseAddress, refPointer));
		AuroraContextEnd();
		return retValue;
	}

	/// <summary>
	/// Reads memory from the end of a pointer.
	/// </summary>
	/// <typeparam name="ReturnType">- The type to read.</typeparam>
	/// <typeparam name="nSize">- The number of elements in the array.</typeparam>
	/// <param name="uBaseAddress">- The base address of the pointer.</param>
	/// <param name="refPointer">- A reference to the pointer.</param>
	/// <param name="lpBuffer">- A reference to a buffer to receive the read data.</param>
	/// <exception cref="ParameterInvalidException"/>
	/// <exception cref="ReadException"/>
	template<ReadReturnType ReturnType, A_I32 nSize>
	inline A_VOID ReadPtr(
		_In_a_ A_ADDR uBaseAddress,
		_In_ const Pointer<ReturnType>& refPointer,
		_Out_writes_(nSize) ReturnType(&lpBuffer)[nSize]
	) {
		AuroraContextStart();
		Read<ReturnType, nSize>(ReadPtrAddress<ReturnType>(uBaseAddress, refPointer), lpBuffer);
		AuroraContextEnd();
	}

	/// <summary>
	/// Reads memory from the end of a pointer.
	/// </summary>
	/// <typeparam name="ReturnType">- The type to read.</typeparam>
	/// <param name="uBaseAddress">- The base address of the pointer.</param>
	/// <param name="refPointer">- A reference to the pointer.</param>
	/// <param name="lpBuffer">- A pointer to a buffer to receive the read data.</param>
	/// <param name="nSize">- The size of the buffer in elements.</param>
	/// <exception cref="ParameterInvalidException"/>
	/// <exception cref="ReadException"/>
	template<ReadReturnType ReturnType>
	inline A_VOID ReadPtr(
		_In_a_ A_ADDR uBaseAddress,
		_In_ const Pointer<ReturnType>& refPointer,
		_Out_writes_(nSize) ReturnType* lpBuffer,
		_In_ A_I32 nSize
	) {
		AuroraContextStart();
		Read(ReadPtrAddress<ReturnType>(uBaseAddress, refPointer), lpBuffer, nSize * sizeof(ReturnType));
		AuroraContextEnd();
	}

	// ReadPtr definitions dealing with base pointers and inheriting the return type of the pointer.

	/// <summary>
	/// Reads memory from the end of a pointer chain and returns it.
	/// </summary>
	/// <typeparam name="ReturnType">- The type to read.</typeparam>
	/// <param name="refModuleInfo">- A reference to the module containing the base of the pointer.</param>
	/// <param name="refPointer">- A reference to the base pointer.</param>
	/// <returns>The read data.</returns>
	/// <exception cref="ParameterInvalidException"/>
	/// <exception cref="ReadException"/>
	template<ReadReturnType ReturnType>
	AURORA_NDWR_PURE("ReadPtr") inline ReturnType ReadPtr(
		_In_ const ModuleInfo& refModuleInfo,
		_In_ const BasePointer<ReturnType>& refPointer
	) {
		AuroraContextStart();
		ReturnType retValue = Read<ReturnType>(ReadPtrAddress<ReturnType>(refModuleInfo, refPointer));
		AuroraContextEnd();
		return retValue;
	}

	/// <summary>
	/// Reads memory from the end of a pointer chain.
	/// </summary>
	/// <typeparam name="ReturnType">- The type to read.</typeparam>
	/// <typeparam name="nSize">- The number of elements in the array.</typeparam>
	/// <param name="refModuleInfo">- A reference to the module containing the base of the pointer.</param>
	/// <param name="refPointer">- A reference to the base pointer.</param>
	/// <param name="lpBuffer">- A reference to a buffer to receive the read data.</param>
	/// <exception cref="ParameterInvalidException"/>
	/// <exception cref="ReadException"/>
	template<ReadReturnType ReturnType, A_I32 nSize>
	inline A_VOID ReadPtr(
		_In_ const ModuleInfo& refModuleInfo,
		_In_ const BasePointer<ReturnType>& refPointer,
		_Out_writes_(nSize) ReturnType(&lpBuffer)[nSize]
	) {
		AuroraContextStart();
		Read<ReturnType, nSize>(ReadPtrAddress<ReturnType>(refModuleInfo, refPointer), lpBuffer);
		AuroraContextEnd();
	}

	/// <summary>
	/// Reads memory from the end of a pointer chain.
	/// </summary>
	/// <typeparam name="ReturnType">- The type to read.</typeparam>
	/// <param name="refModuleInfo">- A reference to the module containing the base of the pointer.</param>
	/// <param name="refPointer">- A reference to the base pointer.</param>
	/// <param name="lpBuffer">- A pointer to a buffer to receive the read data.</param>
	/// <param name="nSize">- The size of the buffer in elements.</param>
	/// <exception cref="ParameterInvalidException"/>
	/// <exception cref="ReadException"/>
	template<ReadReturnType ReturnType>
	inline A_VOID ReadPtr(
		_In_ const ModuleInfo& refModuleInfo,
		_In_ const BasePointer<ReturnType>& refPointer,
		_Out_writes_(nSize) ReturnType* lpBuffer,
		_In_ A_I32 nSize
	) {
		AuroraContextStart();
		Read(ReadPtrAddress<ReturnType>(refModuleInfo, refPointer), lpBuffer, nSize * sizeof(ReturnType));
		AuroraContextEnd();
	}

	/// <summary>
	/// Reads an ANSI string from an address.
	/// </summary>
	/// <param name="uAddress">- The address to read.</param>
	/// <param name="lpBuffer">- A pointer to a buffer to receive the read string.</param>
	/// <param name="dwCount">- The number of characters to read.</param>
	/// <exception cref="ParameterInvalidException"/>
	/// <exception cref="ReadException"/>
	AURORA_API A_VOID ReadStringA(
		_In_a_ A_ADDR uAddress,
		_Out_writes_z_(dwCount) A_LPSTR lpBuffer,
		_In_ A_DWORD dwCount
	);

	/// <summary>
	/// Reads an ANSI string from an address.
	/// </summary>
	/// <typeparam name="nCount">- The size fo the array.</typeparam>
	/// <param name="uAddress">- The address to read.</param>
	/// <param name="lpBuffer">- A reference to a buffer to receive the read string.</param>
	/// <param name="lpNumberOfCharactersRead">- A pointer to a DWORD to receive the number of characters read. This parameter is optional.</param>
	/// <exception cref="ParameterInvalidException"/>
	/// <exception cref="ReadException"/>
	template<A_I32 nCount>
	inline A_VOID ReadStringA(
		_In_a_ A_ADDR uAddress,
		_Out_writes_z_(nCount) A_CHAR(&lpBuffer)[nCount]
	) {
		AuroraContextStart();
		ReadStringA(uAddress, lpBuffer, nCount);
		AuroraContextEnd();
	}

	/// <summary>
	/// Reads a UTF-16LE string from an address.
	/// </summary>
	/// <param name="uAddress">- The address to read.</param>
	/// <param name="lpBuffer">- A pointer to a buffer to receive the read string.</param>
	/// <param name="dwCount">- The number of characters to read.</param>
	/// <exception cref="ParameterInvalidException"/>
	/// <exception cref="ReadException"/>
	AURORA_API A_VOID ReadStringW(
		_In_a_ A_ADDR uAddress,
		_Out_writes_z_(dwCount) A_LPWSTR lpBuffer,
		_In_ A_DWORD dwCount
	);

	/// <summary>
	/// Reads a UTF-16LE string from an address.
	/// </summary>
	/// <typeparam name="nCount">- The number of characters in the array.</typeparam>
	/// <param name="uAddress">- The address to read.</param>
	/// <param name="lpBuffer">- A reference to a buffer to receive the read string.</param>
	/// <param name="lpNumberOfCharactersRead">- A pointer to a DWORD to receive the number of characters read. This parameter is optional.</param>
	/// <exception cref="ParameterInvalidException"/>
	/// <exception cref="ReadException"/>
	template<A_I32 nCount>
	inline A_VOID ReadStringW(
		_In_a_ A_ADDR uAddress,
		_Out_writes_z_(nCount) A_WCHAR(&lpBuffer)[nCount]
	) {
		AuroraContextStart();
		ReadStringW(uAddress, lpBuffer, nCount);
		AuroraContextEnd();
	}

	/// <summary>
	/// Writes memory to an address from a buffer. This function is unsafe and shall not be used unless speed is mandetory.
	/// </summary>
	/// <param name="uAddress">- The address to write memory to.</param>
	/// <param name="lpBuffer">- A pointer to a buffer that contains the data to write.</param>
	/// <param name="dwSize">- The number of bytes to write.</param>
	/// <exception cref="ParameterInvalidException"/>
	AURORA_API A_VOID UnsafeWrite(
		_In_a_ A_ADDR uAddress,
		_In_reads_bytes_(dwSize) A_LPCVOID lpBuffer,
		_In_ A_DWORD dwSize
	);

	/// <summary>
	/// Writes memory to an address from a buffer. This function is unsafe and shall not be used unless speed is mandetory.
	/// </summary>
	/// <param name="uAddress">- The address to write memory to.</param>
	/// <param name="refData">- The data to write.</param>
	/// <exception cref="ParameterInvalidException"/>
	template<WriteDataType DataType>
	inline A_VOID UnsafeWrite(
		_In_a_ A_ADDR uAddress,
		_In_ const DataType& refData
	) {
		AuroraContextStart();
		UnsafeWrite(uAddress, (A_LPCVOID)&refData, sizeof(DataType));
		AuroraContextEnd();
	}

	/// <summary>
	/// Writes memory to an address from a buffer. This function is unsafe and shall not be used unless speed is mandetory.
	/// </summary>
	/// <param name="uAddress">- The address to write memory to.</param>
	/// <param name="lpData">- A reference to an array containing the data to write.</param>
	/// <exception cref="ParameterInvalidException"/>
	/// <exception cref="WriteException"/>
	template<WriteDataType DataType, A_I32 nSize>
	inline A_VOID UnsafeWrite(
		_In_a_ A_ADDR uAddress,
		_In_ const DataType(&lpData)[nSize]
	) {
		AuroraContextStart();
		Write(uAddress, (A_LPCVOID)lpData, nSize * sizeof(DataType));
		AuroraContextEnd();
	}

	/// <summary>
	/// Writes memory to an address from a buffer.
	/// </summary>
	/// <param name="uAddress">- The address to write memory to.</param>
	/// <param name="lpBuffer">- A pointer to a buffer that contains the data to write.</param>
	/// <param name="dwSize">- The number of bytes to write.</param>
	/// <exception cref="ParameterInvalidException"/>
	/// <exception cref="WriteException"/>
	AURORA_API A_VOID Write(
		_In_a_ A_ADDR uAddress,
		_In_reads_bytes_(dwSize) A_LPCVOID lpBuffer,
		_In_ A_DWORD dwSize
	);

	/// <summary>
	/// Writes memory to an address from a buffer.
	/// </summary>
	/// <param name="uAddress">- The address to write memory to.</param>
	/// <param name="refData">- The data to write.</param>
	/// <exception cref="ParameterInvalidException"/>
	/// <exception cref="WriteException"/>
	template<WriteDataType DataType>
	inline A_VOID Write(
		_In_a_ A_ADDR uAddress,
		_In_ const DataType& refData
	) {
		AuroraContextStart();
		Write(uAddress, (A_LPCVOID)&refData, sizeof(DataType));
		AuroraContextEnd();
	}

	/// <summary>
	/// Writes memory to an address from a buffer.
	/// </summary>
	/// <param name="uAddress">- The address to write memory to.</param>
	/// <param name="lpData">- A reference to an array containing the data to write.</param>
	/// <exception cref="ParameterInvalidException"/>
	/// <exception cref="WriteException"/>
	template<WriteDataType DataType, A_I32 nSize>
	inline A_VOID Write(
		_In_a_ A_ADDR uAddress,
		_In_ const DataType(&lpData)[nSize]
	) {
		AuroraContextStart();
		Write(uAddress, (A_LPCVOID)lpData, nSize * sizeof(DataType));
		AuroraContextEnd();
	}

	// WritePtr definitions dealing with standard pointers and requiring explicit specification of data type.

	/// <summary>
	/// Writes memory to the end of a pointer.
	/// </summary>
	/// <typeparam name="DataType">- The type to write.</typeparam>
	/// <typeparam name="PointerType">- The type specified by the pointer.</typeparam>
	/// <param name="uBaseAddress">- The base address of the pointer.</param>
	/// <param name="refPointer">- A reference to the pointer.</param>
	/// <param name="refData">- A reference to the data to write.</param>
	/// <exception cref="ParameterInvalidException"/>
	/// <exception cref="WriteException"/>
	template<WriteDataType DataType, typename PointerType>
	inline A_VOID WritePtr(
		_In_a_ A_ADDR uBaseAddress,
		_In_ const Pointer<PointerType>& refPointer,
		_In_ const DataType& refData
	) {
		AuroraContextStart();
		Write<DataType>(ReadPtrAddress<PointerType>(uBaseAddress, refPointer), refData);
		AuroraContextEnd();
	}

	/// <summary>
	/// Writes memory to the end of a pointer.
	/// </summary>
	/// <typeparam name="DataType">- The type to write.</typeparam>
	/// <typeparam name="PointerType">- The type specified by the pointer.</typeparam>
	/// <typeparam name="nSize">- The number of elements in the array.</typeparam>
	/// <param name="uBaseAddress">- The base address of the pointer.</param>
	/// <param name="refPointer">- A reference to the pointer.</param>
	/// <param name="lpData">- A reference to a buffer containing the data to write.</param>
	/// <exception cref="ParameterInvalidException"/>
	/// <exception cref="WriteException"/>
	template<WriteDataType DataType, typename PointerType, A_I32 nSize>
	inline A_VOID WritePtr(
		_In_a_ A_ADDR uBaseAddress,
		_In_ const Pointer<PointerType>& refPointer,
		_In_ const DataType(&lpData)[nSize]
	) {
		AuroraContextStart();
		Write<DataType, nSize>(ReadPtrAddress<PointerType>(uBaseAddress, refPointer), lpData);
		AuroraContextEnd();
	}

	/// <summary>
	/// Writes memory to the end of a pointer.
	/// </summary>
	/// <typeparam name="DataType">- The type to write.</typeparam>
	/// <typeparam name="PointerType">- The type specified by the pointer.</typeparam>
	/// <param name="uBaseAddress">- The base address of the pointer.</param>
	/// <param name="refPointer">- A reference to the pointer.</param>
	/// <param name="lpData">- A pointer to a buffer containing the data to write.</param>
	/// <param name="nSize">- The size of the buffer in elements.</param>
	/// <exception cref="ParameterInvalidException"/>
	/// <exception cref="WriteException"/>
	template<WriteDataType DataType, typename PointerType>
	inline A_VOID WritePtr(
		_In_a_ A_ADDR uBaseAddress,
		_In_ const Pointer<PointerType>& refPointer,
		_In_ const DataType* lpData,
		_In_ A_I32 nSize
	) {
		AuroraContextStart();
		Write(ReadPtrAddress<PointerType>(uBaseAddress, refPointer), lpData, nSize * sizeof(DataType));
		AuroraContextEnd();
	}

	// WritePtr definitions dealing with base pointers and requiring explicit specification of data type.

	/// <summary>
	/// Writes memory to the end of a pointer.
	/// </summary>
	/// <typeparam name="DataType">- The type to write.</typeparam>
	/// <typeparam name="PointerType">- The type specified by the pointer.</typeparam>
	/// <param name="refModuleInfo">- A reference to the module containing the base of the pointer.</param>
	/// <param name="refPointer">- A reference to the base pointer.</param>
	/// <param name="refData">- A reference to the data to write.</param>
	/// <exception cref="ParameterInvalidException"/>
	/// <exception cref="WriteException"/>
	template<WriteDataType DataType, typename PointerType>
	inline A_VOID WritePtr(
		_In_ const ModuleInfo& refModuleInfo,
		_In_ const BasePointer<PointerType>& refPointer,
		_In_ const DataType& refData
	) {
		AuroraContextStart();
		Write<DataType>(ReadPtrAddress<PointerType>(refModuleInfo, refPointer), refData);
		AuroraContextEnd();
	}

	/// <summary>
	/// Writes memory to the end of a pointer.
	/// </summary>
	/// <typeparam name="DataType">- The type to write.</typeparam>
	/// <typeparam name="PointerType">- The type specified by the pointer.</typeparam>
	/// <param name="refModuleInfo">- A reference to the module containing the base of the pointer.</param>
	/// <param name="refPointer">- A reference to the base pointer.</param>
	/// <param name="lpData">- A reference to a buffer containing the data to write.</param>
	/// <exception cref="ParameterInvalidException"/>
	/// <exception cref="WriteException"/>
	template<WriteDataType DataType, typename PointerType, A_I32 nSize>
	inline A_VOID WritePtr(
		_In_ const ModuleInfo& refModuleInfo,
		_In_ const BasePointer<PointerType>& refPointer,
		_In_ const DataType(&lpData)[nSize]
	) {
		AuroraContextStart();
		Write<DataType, nSize>(ReadPtrAddress<PointerType>(refModuleInfo, refPointer), lpData);
		AuroraContextEnd();
	}

	/// <summary>
	/// Writes memory to the end of a pointer.
	/// </summary>
	/// <typeparam name="DataType">- The type to write.</typeparam>
	/// <typeparam name="PointerType">- The type specified by the pointer.</typeparam>
	/// <param name="refModuleInfo">- A reference to the module containing the base of the pointer.</param>
	/// <param name="refPointer">- A reference to the base pointer.</param>
	/// <param name="lpData">- A pointer to a buffer containing the data to write.</param>
	/// <param name="nSize">- The size of the buffer in elements.</param>
	/// <exception cref="ParameterInvalidException"/>
	/// <exception cref="WriteException"/>
	template<WriteDataType DataType, typename PointerType>
	inline A_VOID WritePtr(
		_In_ const ModuleInfo& refModuleInfo,
		_In_ const BasePointer<PointerType>& refPointer,
		_In_ const DataType* lpData,
		_In_ A_I32 nSize
	) {
		AuroraContextStart();
		Write(ReadPtrAddress<PointerType>(refModuleInfo, refPointer), lpData, nSize * sizeof(DataType));
		AuroraContextEnd();
	}

	// WritePtr definitions dealing with standard pointers and inheriting the data type of the pointer.

	/// <summary>
	/// Writes memory to the end of a pointer.
	/// </summary>
	/// <typeparam name="DataType">- The type to write.</typeparam>
	/// <param name="uBaseAddress">- The base address of the pointer.</param>
	/// <param name="refPointer">- A reference to the pointer.</param>
	/// <param name="refData">- A reference to the data to write.</param>
	/// <exception cref="ParameterInvalidException"/>
	/// <exception cref="WriteException"/>
	template<WriteDataType DataType>
	inline A_VOID WritePtr(
		_In_a_ A_ADDR uBaseAddress,
		_In_ const Pointer<DataType>& refPointer,
		_In_ const DataType& refData
	) {
		AuroraContextStart();
		Write<DataType>(ReadPtrAddress<DataType>(uBaseAddress, refPointer), refData);
		AuroraContextEnd();
	}

	/// <summary>
	/// Writes memory to the end of a pointer.
	/// </summary>
	/// <typeparam name="DataType">- The type to write.</typeparam>
	/// <typeparam name="nSize">- The number of elements in the array.</typeparam>
	/// <param name="uBaseAddress">- The base address of the pointer.</param>
	/// <param name="refPointer">- A reference to the pointer.</param>
	/// <param name="lpData">- A reference to a buffer containing the data to write.</param>
	/// <exception cref="ParameterInvalidException"/>
	/// <exception cref="WriteException"/>
	template<WriteDataType DataType, A_I32 nSize>
	inline A_VOID WritePtr(
		_In_a_ A_ADDR uBaseAddress,
		_In_ const Pointer<DataType>& refPointer,
		_In_ const DataType(&lpData)[nSize]
	) {
		AuroraContextStart();
		Write<DataType, nSize>(ReadPtrAddress<DataType>(uBaseAddress, refPointer), lpData);
		AuroraContextEnd();
	}

	/// <summary>
	/// Writes memory to the end of a pointer.
	/// </summary>
	/// <typeparam name="DataType">- The type to write.</typeparam>
	/// <param name="uBaseAddress">- The base address of the pointer.</param>
	/// <param name="refPointer">- A reference to the pointer.</param>
	/// <param name="lpData">- A pointer to a buffer containing the data to write.</param>
	/// <param name="nSize">- The size of the buffer in elements.</param>
	/// <exception cref="ParameterInvalidException"/>
	/// <exception cref="WriteException"/>
	template<WriteDataType DataType>
	inline A_VOID WritePtr(
		_In_a_ A_ADDR uBaseAddress,
		_In_ const Pointer<DataType>& refPointer,
		_In_ const DataType* lpData,
		_In_ A_I32 nSize
	) {
		AuroraContextStart();
		Write(ReadPtrAddress<DataType>(uBaseAddress, refPointer), lpData, nSize * sizeof(DataType));
		AuroraContextEnd();
	}

	// WritePtr definitions dealing with base pointers and inheriting the data type of the pointer.

	/// <summary>
	/// Writes memory to the end of a pointer.
	/// </summary>
	/// <typeparam name="DataType">- The type to write.</typeparam>
	/// <param name="refModuleInfo">- A reference to the module containing the base of the pointer.</param>
	/// <param name="refPointer">- A reference to the base pointer.</param>
	/// <param name="refData">- A reference to the data to write.</param>
	/// <exception cref="ParameterInvalidException"/>
	/// <exception cref="WriteException"/>
	template<WriteDataType DataType>
	inline A_VOID WritePtr(
		_In_ const ModuleInfo& refModuleInfo,
		_In_ const BasePointer<DataType>& refPointer,
		_In_ const DataType& refData
	) {
		AuroraContextStart();
		Write<DataType>(ReadPtrAddress<DataType>(refModuleInfo, refPointer), refData);
		AuroraContextEnd();
	}

	/// <summary>
	/// Writes memory to the end of a pointer.
	/// </summary>
	/// <typeparam name="DataType">- The type to write.</typeparam>
	/// <param name="refModuleInfo">- A reference to the module containing the base of the pointer.</param>
	/// <param name="refPointer">- A reference to the base pointer.</param>
	/// <param name="lpData">- A reference to a buffer containing the data to write.</param>
	/// <exception cref="ParameterInvalidException"/>
	/// <exception cref="WriteException"/>
	template<WriteDataType DataType, A_I32 nSize>
	inline A_VOID WritePtr(
		_In_ const ModuleInfo& refModuleInfo,
		_In_ const BasePointer<DataType>& refPointer,
		_In_ const DataType(&lpData)[nSize]
	) {
		AuroraContextStart();
		Write<DataType, nSize>(ReadPtrAddress<DataType>(refModuleInfo, refPointer), lpData);
		AuroraContextEnd();
	}

	/// <summary>
	/// Writes memory to the end of a pointer.
	/// </summary>
	/// <typeparam name="DataType">- The type to write.</typeparam>
	/// <param name="refModuleInfo">- A reference to the module containing the base of the pointer.</param>
	/// <param name="refPointer">- A reference to the base pointer.</param>
	/// <param name="lpData">- A pointer to a buffer containing the data to write.</param>
	/// <param name="nSize">- The size of the buffer in elements.</param>
	/// <exception cref="ParameterInvalidException"/>
	/// <exception cref="WriteException"/>
	template<WriteDataType DataType>
	inline A_VOID WritePtr(
		_In_ const ModuleInfo& refModuleInfo,
		_In_ const BasePointer<DataType>& refPointer,
		_In_ const DataType* lpData,
		_In_ A_I32 nSize
	) {
		AuroraContextStart();
		Write(ReadPtrAddress<DataType>(refModuleInfo, refPointer), lpData, nSize * sizeof(DataType));
		AuroraContextEnd();
	}

	/// <summary>
	/// Writes an ANSI string to an address.
	/// </summary>
	/// <param name="uAddress">- The address to write to.</param>
	/// <param name="lpBuffer">- A pointer to the string to write.</param>
	/// <exception cref="ParameterInvalidException"/>
	/// <exception cref="WriteException"/>
	AURORA_API A_VOID WriteStringA(
		_In_a_ A_ADDR uAddress,
		_In_z_ A_LPCSTR lpBuffer
	);

	/// <summary>
	/// Writes a UTF-16LE string to an address.
	/// </summary>
	/// <param name="uAddress">- The address to write to.</param>
	/// <param name="lpBuffer">- A pointer to the string to write.</param>
	/// <exception cref="ParameterInvalidException"/>
	/// <exception cref="WriteException"/>
	AURORA_API A_VOID WriteStringW(
		_In_a_ A_ADDR uAddress,
		_In_z_ A_LPCWSTR lpBuffer
	);

	/// <summary>
	/// Enables an instruction patch.
	/// </summary>
	/// <typeparam name="nSize">- The number of bytes to patch.</typeparam>
	/// <param name="uAddress">- The address to patch.</param>
	/// <param name="refPatch">- A reference to the patch.</param>
	/// <exception cref="ParameterInvalidException"/>
	/// <exception cref="WriteException"/>
	template<A_I32 nSize>
	inline A_VOID EnablePatch(
		_In_a_ A_ADDR uAddress,
		_In_ const InstructionPatch<nSize>& refPatch
	) {
		AuroraContextStart();
		Write<A_BYTE, nSize>(uAddress, refPatch.GetEnableCode().szBytes);
		AuroraContextEnd();
	}

	/// <summary>
	/// Enables an instruction patch.
	/// </summary>
	/// <typeparam name="nSize">- The number of bytes to patch.</typeparam>
	/// <param name="refModuleInfo">- A reference to the module containing the code to patch.</param>
	/// <param name="refPatch">- A reference to the patch.</param>
	/// <exception cref="ParameterInvalidException"/>
	/// <exception cref="WriteException"/>
	template<A_I32 nSize>
	inline A_VOID EnablePatch(
		_In_ const ModuleInfo& refModuleInfo,
		_In_ const BaseInstructionPatch<nSize>& refPatch
	) {
		AuroraContextStart();
		Write<A_BYTE, nSize>(refModuleInfo->GetModuleBaseAddress() + refPatch.GetOffset(), refPatch.GetEnableCode().szBytes);
		AuroraContextEnd();
	}

	/// <summary>
	/// Disables an instruction patch.
	/// </summary>
	/// <typeparam name="nSize">- The number of bytes to patch.</typeparam>
	/// <param name="uAddress">- The address to patch.</param>
	/// <param name="refPatch">- A reference to the patch.</param>
	/// <exception cref="ParameterInvalidException"/>
	/// <exception cref="WriteException"/>
	template<A_I32 nSize>
	inline A_VOID DisablePatch(
		_In_a_ A_ADDR uAddress,
		_In_ const InstructionPatch<nSize>& refPatch
	) {
		AuroraContextStart();
		Write<A_BYTE, nSize>(uAddress, refPatch.GetDisableCode().szBytes);
		AuroraContextEnd();
	}

	/// <summary>
	/// Disables an instruction patch.
	/// </summary>
	/// <typeparam name="nSize">- The number of bytes to patch.</typeparam>
	/// <param name="refModuleInfo">- A reference to the module containing the code to patch.</param>
	/// <param name="refPatch">- A reference to the patch.</param>
	/// <exception cref="ParameterInvalidException"/>
	/// <exception cref="WriteException"/>
	template<A_I32 nSize>
	inline A_VOID DisablePatch(
		_In_ const ModuleInfo& refModuleInfo,
		_In_ const BaseInstructionPatch<nSize>& refPatch
	) {
		AuroraContextStart();
		Write<A_BYTE, nSize>(refModuleInfo->GetModuleBaseAddress() + refPatch.GetOffset(), refPatch.GetDisableCode().szBytes);
		AuroraContextEnd();
	}
}

#endif // !__AURORA_MEMORY_H__
```

`Artemis/Aurora/MemoryTypes.h`:

```h
//------------------------------------------------------------------------>
// MIT License
// 
// Copyright (c) 2023 Artemis Group
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------>
// Aurora: https://github.com/ArtemisDevGroup/Aurora
// This file was authored by:
// @Astrea0014: https://github.com/Astrea0014
//------------------------------------------------------------------------>

#ifndef __AURORA_MEMORY_TYPES_H__
#define __AURORA_MEMORY_TYPES_H__

#include "Definitions.h"
#include "Array.h"

namespace Aurora {
	/// <summary>
	/// A collection of bytes representing CPU-instructions.
	/// </summary>
	template<A_I32 nSize>
	class InstructionBytes {
	public:
		/// <summary>
		/// An array containing the instruction bytes.
		/// </summary>
		A_BYTE szBytes[nSize];

		/// <summary>
		/// Gets the size of the array and returns it.
		/// </summary>
		/// <returns>The size of the array.</returns>
		AURORA_NDWR_GET("size") constexpr const A_I32 size() const noexcept { return nSize; }

		/// <summary>
		/// Gets the begin const iterator.
		/// </summary>
		/// <returns>The begin const iterator.</returns>
		AURORA_NDWR_GET("begin") constexpr A_LPCBYTE begin() const noexcept { return szBytes; }

		/// <summary>
		/// Gets the end const iterator.
		/// </summary>
		/// <returns>The end const iterator.</returns>
		AURORA_NDWR_GET("end") constexpr A_LPCBYTE end() const noexcept { return &szBytes[nSize]; }
	};

	/// <summary>
	/// <para>A pair of byte collections representing CPU-instructions.</para>
	/// <para>Used as a toggleable patch to change the behavior of different functions.</para>
	/// </summary>
	template<A_I32 nSize>
	class InstructionPatch {
		InstructionBytes<nSize> EnableBytes;
		InstructionBytes<nSize> DisableBytes;

	public:
		/// <summary>
		/// Constructs an instruction patch.
		/// </summary>
		/// <param name="EnableBytes">- The instructions to enable the patch.</param>
		/// <param name="DisableBytes">- The instructions to disable the patch. Usually this parameter is the original bytes of the patch.</param>
		constexpr InstructionPatch(
			_In_ const InstructionBytes<nSize>& EnableBytes,
			_In_ const InstructionBytes<nSize>& DisableBytes
		) : EnableBytes(EnableBytes), DisableBytes(DisableBytes) {}

		/// <summary>
		/// Gets a const reference to the bytes used to enable the patch.
		/// </summary>
		/// <returns>A const reference to the enable code.</returns>
		AURORA_NDWR_GET("GetEnableCode") constexpr const InstructionBytes<nSize>& GetEnableCode() const noexcept { return EnableBytes; }

		/// <summary>
		/// Gets a const reference to the bytes used to disable the patch.
		/// </summary>
		/// <returns>A const reference to the disable code.</returns>
		AURORA_NDWR_GET("GetDisableCode") constexpr const InstructionBytes<nSize>& GetDisableCode() const noexcept { return DisableBytes; }
	};

	/// <summary>
	/// <para>A pair of byte collections representing CPU-instructions.</para>
	/// <para>Additionally contains an offset of the base address of the module where the patch shall be written.</para>
	/// <para>Used as a toggleable patch to change the behavior of different functions.</para>
	/// </summary>
	template<A_I32 nSize>
	class BaseInstructionPatch : public InstructionPatch<nSize> {
		A_DWORD dwOffset;

	public:
		/// <summary>
		/// Constructs a base instruction patch.
		/// </summary>
		/// <param name=dwBaseOffset">- The offset from the base address.</param>
		/// <param name="EnableBytes">- The instructions to enable the patch.</param>
		/// <param name="DisableBytes">- The instructions to disable the patch. Usually this parameter is the original bytes of the patch.</param>
		constexpr BaseInstructionPatch(
			_In_ A_DWORD dwBaseOffset,
			_In_ const InstructionBytes<nSize>& EnableBytes,
			_In_ const InstructionBytes<nSize>& DisableBytes
		) : InstructionPatch<nSize>(EnableBytes, DisableBytes), dwOffset(dwBaseOffset) {}

		/// <summary>
		/// Gets the base offset of the patch point.
		/// </summary>
		/// <returns>The base offset.</returns>
		AURORA_NDWR_GET("GetOffset") constexpr A_DWORD GetOffset() const noexcept { return dwOffset; }
	};

	/// <summary>
	/// A pointer chain of 32-bit pointers.
	/// </summary>
	/// <typeparam name="ReturnType">- The type of data at the end of the pointer.</typeparam>
	template<typename ReturnType = void> class Pointer32 : public ArgumentList<A_ADDR32> { public: using ArgumentList<A_ADDR32>::ArgumentList; };

	/// <summary>
	/// A pointer chain of 64-bit pointers.
	/// </summary>
	/// <typeparam name="ReturnType">- The type of data at the end of the pointer.</typeparam>
	template<typename ReturnType = void> class Pointer64 : public ArgumentList<A_ADDR64> { public: using ArgumentList<A_ADDR64>::ArgumentList; };

	/// <summary>
	/// A pointer chain of 32-bit pointers with a base offset.
	/// </summary>
	/// <typeparam name="ReturnType">- The type of data at the end of the pointer.</typeparam>
	template<typename ReturnType = void>
	class BasePointer32 : public Pointer32<ReturnType> {
		A_DWORD dwBaseOffset;
	public:
		inline BasePointer32() noexcept : Pointer32<ReturnType>(), dwBaseOffset(0) {}

		/// <summary>
		/// Constructs a base pointer.
		/// </summary>
		/// <param name="dwBaseOffset">- The offset from the base address.</param>
		/// <param name="list">- The pointer list.</param>
		inline BasePointer32(_In_ A_DWORD dwBaseOffset, _In_ const std::initializer_list<A_ADDR32>& list) : Pointer32<ReturnType>(list), dwBaseOffset(dwBaseOffset) {}

		/// <summary>
		/// Gets the base offset of the pointer.
		/// </summary>
		/// <returns>The base offset.</returns>
		AURORA_NDWR_GET("GetOffset") constexpr A_DWORD GetOffset() const noexcept { return dwBaseOffset; }
	};

	/// <summary>
	/// A pointer chain of 64-bit pointers with a base offset.
	/// </summary>
	/// <typeparam name="ReturnType">- The type of data at the end of the pointer.</typeparam>
	template<typename ReturnType = void>
	class BasePointer64 : public Pointer64<ReturnType> {
		A_DWORD dwBaseOffset;
	public:
		inline BasePointer64() noexcept : Pointer64<ReturnType>(), dwBaseOffset(0) {}

		/// <summary>
		/// Constructs a base pointer.
		/// </summary>
		/// <param name="dwBaseOffset">- The offset from the base address.</param>
		/// <param name="list">- The pointer list.</param>
		inline BasePointer64(_In_ A_DWORD dwBaseOffset, _In_ const std::initializer_list<A_ADDR64>& list) : Pointer64<ReturnType>(list), dwBaseOffset(dwBaseOffset) {}

		/// <summary>
		/// Gets the base offset of the pointer.
		/// </summary>
		/// <returns>The base offset.</returns>
		AURORA_NDWR_GET("GetOffset") constexpr A_DWORD GetOffset() const noexcept { return dwBaseOffset; }
	};

#ifdef _WIN64
	/// <summary>
	/// A pointer chain of 64-bit pointers.
	/// </summary>
	/// <typeparam name="ReturnType">- The type of data at the end of the pointer.</typeparam>
	template<typename ReturnType = void> using Pointer = Pointer64<ReturnType>;

	/// <summary>
	/// A pointer chain of 64-bit pointers with a base offset.
	/// </summary>
	/// <typeparam name="ReturnType">- The type of data at the end of the pointer.</typeparam>
	template<typename ReturnType = void> using BasePointer = BasePointer64<ReturnType>;
#else
	/// <summary>
	/// A pointer chain of 32-bit pointers.
	/// </summary>
	/// <typeparam name="ReturnType">- The type of data at the end of the pointer.</typeparam>
	template<typename ReturnType = void> using Pointer = Pointer32<ReturnType>;

	/// <summary>
	/// A pointer chain of 32-bit pointers with a base offset.
	/// </summary>
	/// <typeparam name="ReturnType">- The type of data at the end of the pointer.</typeparam>
	template<typename ReturnType = void> using BasePointer = BasePointer32<ReturnType>;
#endif // _WIN64
}

#endif // !__AURORA_MEMORY_TYPES_H__
```

`Artemis/Aurora/MemoryWin32.h`:

```h
//------------------------------------------------------------------------>
// MIT License
// 
// Copyright (c) 2023 Artemis Group
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------>
// Aurora: https://github.com/ArtemisDevGroup/Aurora
// This file was authored by:
// @Astrea0014: https://github.com/Astrea0014
//------------------------------------------------------------------------>

#ifndef __AURORA_MEMORY_WIN32_H__
#define __AURORA_MEMORY_WIN32_H__

#include "Definitions.h"
#include "ProcessInfo.h"
#include "SharedHandle.h"
#include "MemoryTypes.h"

#include <Windows.h>

namespace Aurora {
	/// <summary>
	/// Defines the type of virtual memory allocation.
	/// </summary>
	struct AllocationTypeFlags {
		A_DWORD dwValue;

		enum Enumeration : A_DWORD {
			/// <summary>
			/// Allocates memory charges (from the overall size of memory and the paging files on disk) for the specified reserved memory pages.
			/// The function also guarantees that when the caller later initially accesses the memory, the contents will be zero.
			/// </summary>
			Commit = MEM_COMMIT,
			/// <summary>
			/// Reserves a range of the process's virtual address space without allocating any actual physical storage in memory or in the paging file on disk.
			/// </summary>
			Reserve = MEM_RESERVE,
			/// <summary>
			/// Allocates memory at the highest possible address. This can be slower than regular allocations, especially when there are many allocations.
			/// </summary>
			TopDown = MEM_TOP_DOWN,
			/// <summary>
			/// Allocates memory using large page support.
			/// The size and alignment must be a multiple of the large-page minimum.
			/// To obtain this value, use the 'GetLargePageMinimum' function.
			/// If you specify this value, you must also specify 'Reserve' and 'Commit'.
			/// </summary>
			LargePages = MEM_LARGE_PAGES,
			/// <summary>
			/// Reserves an address range that can be used to map Address Windowing Extensions (AWE) pages.
			/// This value must be used with 'Reserve' and no other values.
			/// </summary>
			Physical = MEM_PHYSICAL,
			/// <summary>
			/// Causes the system to track pages that are written to in the allocated region. If you specify this value, you must also specify 'Reserve'.
			/// To retrieve the addresses of the pages that have been written to since the region was allocated or the write-tracking state was reset, call the 'GetWriteWatch' function.
			/// To reset the write-tracking state, call 'GetWriteWatch' or 'ResetWriteWatch'. The write-tracking feature remains enabled for the memory region until the region is freed.
			/// </summary>
			WriteWatch = MEM_WRITE_WATCH
		};

		constexpr AllocationTypeFlags() noexcept : dwValue(0) {}
		constexpr AllocationTypeFlags(A_DWORD dwValue) noexcept : dwValue(dwValue) {}

		/// <summary>
		/// Validates that the value follows the VirtualAlloc specifications.
		/// </summary>
		AURORA_NDWR_PURE("Validate") constexpr A_BOOL Validate() noexcept {
			if (!!(dwValue & MEM_LARGE_PAGES) && !(!!(dwValue & MEM_RESERVE) && !!(dwValue & MEM_COMMIT))) return false;
			if (!!(dwValue & MEM_PHYSICAL) && (dwValue ^ MEM_PHYSICAL) != MEM_RESERVE) return false;
			if (!!(dwValue & MEM_WRITE_WATCH) && !(dwValue & MEM_RESERVE)) return false;
			return true;
		}

		operator A_DWORD& () noexcept { return dwValue; }
		constexpr operator const A_DWORD& () const noexcept { return dwValue; }
	};

	/// <summary>
	/// Defines the protection level of a memory page.
	/// </summary>
	enum class MemoryProtection : A_DWORD {
		Execute = PAGE_EXECUTE,						// Enables execute access to the committed region of pages. An attempt to write to the committed region results in an access violation.
		Execute_Readonly = PAGE_EXECUTE_READ,		// Enables execute or read-only access to the committed region of pages. An attempt to write to the committed region results in an access violation.
		Execute_ReadWrite = PAGE_EXECUTE_READWRITE,	// Enables execute, read-only, or read/write access to the committed region of pages.
		/// <summary>
		/// Enables execute, read-only, or copy-on-write access to a mapped view of a file mapping object.
		/// An attempt to write to a committed copy-on-write page results in a private copy of the page being made for the process.
		/// The private page is marked as 'Execute_ReadWrite', and the change is written to the new page.
		/// </summary>
		Execute_WriteCopy = PAGE_EXECUTE_WRITECOPY,
		NoAccess = PAGE_NOACCESS,					// Disables all access to the committed region of pages. An attempt to read from, write to, or execute the committed region results in an access violation.
		Readonly = PAGE_READONLY,					// Enables read-only access to the committed region of pages. An attempt to write to the committed region results in an access violation. If Data Execution Prevention is enabled, an attempt to execute code in the committed region results in an access violation.
		ReadWrite = PAGE_READWRITE,					// Enables read-only or read/write access to the committed region of pages. If Data Execution Prevention is enabled, attempting to execute code in the committed region results in an access violation.
		/// <summary>
		/// Enables read-only or copy-on-write access to a mapped view of a file mapping object.
		/// An attempt to write to a committed copy-on-write page results in a private copy of the page being made for the process.
		/// The private page is marked as 'ReadWrite', and the change is written to the new page.
		/// If Data Execution Prevention is enabled, attempting to execute code in the committed region results in an access violation.
		/// </summary>
		WriteCopy = PAGE_WRITECOPY
	};

	/// <summary>
	/// Defines the state of an allocation.
	/// </summary>
	enum class AllocationState {
		Unknown = -1,		// The state of the allocation is unknown.
		None,				// The state of the allocation is free.
		Reserved,			// The state of the allocation is reserved.
		Committed			// The state of the allocation is committed.
	};

	/// <summary>
	/// Manages a virtual memory allocation.
	/// </summary>
	class AURORA_API VirtualAllocation32 {
		A_ADDR32 uRequestedAddress;
		A_ADDR32 uAllocatedAddress;
		A_DWORD dwAllocatedSize;
		AllocationTypeFlags dwAllocationType;
		MemoryProtection dwMemoryProtection;

		HANDLE hProcess;

		AllocationState nAllocationState;

	public:
		VirtualAllocation32();

		/// <summary>
		/// Allocates memory in the current process.
		/// </summary>
		/// <param name="uAddress">- The address to allocate, if 0, the function will decide where to allocate.</param>
		/// <param name="dwSize">- The number of bytes to allocate.</param>
		/// <param name="dwAllocationType">- The allocation type. See 'AllocationTypeFlags' for more.</param>
		/// <param name="dwMemoryProtection">- The memory page protection. See 'MemoryProtection' for more.</param>
		/// <exception cref="ParameterInvalidException"/>
		/// <exception cref="WindowsApiException"/>
		VirtualAllocation32(
			_In_opt_a32_(1) A_ADDR32 uAddress,
			_In_ A_DWORD dwSize,
			_In_ AllocationTypeFlags dwAllocationType,
			_In_ MemoryProtection dwMemoryProtection
		);

		/// <summary>
		/// Allocates memory in a remote process.
		/// </summary>
		/// <param name="refTargetProcess">- A reference to the process to allocate memory in.</param>
		/// <param name="uAddress">- The address to allocate, if 0, the function will decide where to allocate.</param>
		/// <param name="dwSize">- The number of bytes to allocate.</param>
		/// <param name="dwAllocationType">- The allocation type. See 'AllocationTypeFlags' for more.</param>
		/// <param name="dwMemoryProtection">- The memory page protection. See 'MemoryProtection' for more.</param>
		/// <exception cref="ParameterInvalidException"/>
		/// <exception cref="WindowsApiException"/>
		VirtualAllocation32(
			_In_ const ProcessInfo32& refTargetProcess,
			_In_opt_a32_(2) A_ADDR32 uAddress,
			_In_ A_DWORD dwSize,
			_In_ AllocationTypeFlags dwAllocationType,
			_In_ MemoryProtection dwMemoryProtection
		);

		VirtualAllocation32(const VirtualAllocation32&) = delete;
		~VirtualAllocation32();

		/// <summary>
		/// Gets the state of the allocation.
		/// </summary>
		/// <returns>The allocation state.</returns>
		AURORA_NDWR_GET("GetAllocationState") constexpr AllocationState GetAllocationState() const noexcept;

		/// <summary>
		/// Gets the current memory page protection constant.
		/// </summary>
		/// <returns>The current memory page protection.</returns>
		AURORA_NDWR_GET("GetMemoryProtection") constexpr MemoryProtection GetMemoryProtection() const noexcept;

		/// <summary>
		/// Gets the requested address.
		/// </summary>
		/// <returns>The requested address.</returns>
		AURORA_NDWR_GET("GetRequestedAddress") constexpr A_ADDR32 GetRequestedAddress() const noexcept;

		/// <summary>
		/// Gets the allocated address.
		/// </summary>
		/// <returns>The allocated address.</returns>
		AURORA_NDWR_GET("GetAllocatedAddress") constexpr A_ADDR32 GetAllocatedAddress() const noexcept;

		/// <summary>
		/// Gets the allocated size in bytes.
		/// </summary>
		/// <returns>The allocated size.</returns>
		AURORA_NDWR_GET("GetAllocatedSize") constexpr A_DWORD GetAllocatedSize() const noexcept;

		/// <summary>
		/// Sets the memory page protection for the allocation.
		/// </summary>
		/// <param name="dwNewProtection">- The new protection constant.</param>
		/// <returns>The previous protection constant.</returns>
		/// <exception cref="ParameterInvalidException"/>
		/// <exception cref="WindowsApiException"/>
		MemoryProtection SetMemoryProtection(_In_ MemoryProtection dwNewProtection);

		/// <summary>
		/// Commits the currently reserved memory.
		/// </summary>
		/// <exception cref="ParameterInvalidException"/>
		/// <exception cref="WindowsApiException"/>
		A_VOID Commit();

		/// <summary>
		/// Decommits the currently committed memory.
		/// </summary>
		/// <exception cref="ParameterInvalidException"/>
		/// <exception cref="WindowsApiException"/>
		A_VOID Decommit();

		/// <summary>
		/// Reads memory from the allocation.
		/// </summary>
		/// <param name="uIndex">- The index relative to the allocation base to read from.</param>
		/// <param name="lpBuffer">- A pointer to a buffer to receive the read data.</param>
		/// <param name="dwSize">- The size of the buffer in bytes.</param>
		/// <exception cref="ParameterInvalidException"/>
		/// <exception cref="Read64Exception"/>
		A_VOID Read(
			_In_ A_U32 uIndex,
			_Out_writes_bytes_(dwSize) A_LPVOID lpBuffer,
			_In_ A_DWORD dwSize
		) const;

		/// <summary>
		/// Reads memory from the allocation.
		/// </summary>
		/// <typeparam name="ReturnType">- The type to read.</typeparam>
		/// <<param name="uIndex">- The index relative to the allocation base to read from.</param>
		/// <returns>The read element.</returns>
		/// <exception cref="ParameterInvalidException"/>
		/// <exception cref="Read64Exception"/>
		template<ReadReturnType ReturnType>
		AURORA_NDWR_PURE("Read") ReturnType Read(_In_ A_U32 uIndex) const {
			AuroraContextStart();
			ReturnType ret;
			Read(uIndex, &ret, sizeof(ReturnType));
			AuroraContextEnd();
			return ret;
		}

		/// <summary>
		/// Reads a an array of elements from the allocation.
		/// </summary>
		/// <typeparam name="ReturnType">- The type to read.</typeparam>
		/// <typeparam name="nSize">- The size of the buffer in elements.</typeparam>
		/// <param name="uIndex">- The index relative to the allocation base to read from.</param>
		/// <param name="lpBuffer">- A reference to a buffer to receive the read data.</param>
		/// <exception cref="ParameterInvalidException"/>
		/// <exception cref="Read64Exception"/>
		template<ReadReturnType ReturnType, A_I32 nSize>
		A_VOID Read(
			_In_ A_U32 uIndex,
			_Out_writes_(nSize) ReturnType(&lpBuffer)[nSize]
		) {
			AuroraContextStart();
			Read(uIndex, lpBuffer, nSize * sizeof(ReturnType));
			AuroraContextEnd();
		}

		/// <summary>
		/// Writes memory to the allocation.
		/// </summary>
		/// <param name="uIndex">- The index relative to the allocation base to write to.</param>
		/// <param name="lpBuffer">- A pointer to a buffer containing the data to write.</param>
		/// <param name="dwSize">- The size of the buffer in bytes.</param>
		/// <exception cref="ParameterInvalidException"/>
		/// <exception cref="Write64Exception"/>
		A_VOID Write(
			_In_ A_U32 uIndex,
			_In_reads_bytes_(dwSize) A_LPCVOID lpBuffer,
			_In_ A_DWORD dwSize
		);

		/// <summary>
		/// Writes a single element to the allocation.
		/// </summary>
		/// <typeparam name="DataType">- The type to write.</typeparam>
		/// <param name="uIndex">- The index relative to the allocation base to write to.</param>
		/// <param name="refData">- A reference to the element to write.</param>
		/// <exception cref="ParameterInvalidException"/>
		/// <exception cref="Write64Exception"/>
		template<WriteDataType DataType>
		A_VOID Write(
			_In_ A_U32 uIndex,
			_In_ const DataType& refData
		) {
			AuroraContextStart();
			Write(uIndex, &refData, sizeof(DataType));
			AuroraContextEnd();
		}

		/// <summary>
		/// Writes an array of elements to the allocation.
		/// </summary>
		/// <typeparam name="DataType">- The type to write.</typeparam>
		/// <typeparam name="nSize">- The size of the buffer in elements.</typeparam>
		/// <param name="uIndex">- The index relative to the allocation base to write to.</param>
		/// <param name="lpBuffer">- A reference to a buffer containing the data to write.</param>
		/// <exception cref="ParameterInvalidException"/>
		/// <exception cref="Write64Exception"/>
		template<WriteDataType DataType, A_I32 nSize>
		A_VOID Write(
			_In_ A_U32 uIndex,
			_In_reads_(nSize) const DataType(&lpBuffer)[nSize]
		) {
			AuroraContextStart();
			Write(uIndex, lpBuffer, nSize * sizeof(DataType));
			AuroraContextEnd();
		}
	};

	/// <summary>
	/// Manages a virtual memory allocation.
	/// </summary>
	class AURORA_API VirtualAllocation64 {
		A_ADDR64 uRequestedAddress;
		A_ADDR64 uAllocatedAddress;
		A_DWORD dwAllocatedSize;
		AllocationTypeFlags dwAllocationType;
		MemoryProtection dwMemoryProtection;

		HANDLE hProcess;

		AllocationState nAllocationState;

	public:
		VirtualAllocation64();

		/// <summary>
		/// Allocates memory in the current process.
		/// </summary>
		/// <param name="uAddress">- The address to allocate, if 0, the function will decide where to allocate.</param>
		/// <param name="dwSize">- The number of bytes to allocate.</param>
		/// <param name="dwAllocationType">- The allocation type. See 'AllocationTypeFlags' for more.</param>
		/// <param name="dwMemoryProtection">- The memory page protection. See 'MemoryProtection' for more.</param>
		/// <exception cref="ParameterInvalidException"/>
		/// <exception cref="WindowsApiException"/>
		VirtualAllocation64(
			_In_opt_a64_(1) A_ADDR64 uAddress,
			_In_ A_DWORD dwSize,
			_In_ AllocationTypeFlags dwAllocationType,
			_In_ MemoryProtection dwMemoryProtection
		);

		/// <summary>
		/// Allocates memory in a remote process.
		/// </summary>
		/// <param name="refTargetProcess">- A reference to the process to allocate memory in.</param>
		/// <param name="uAddress">- The address to allocate, if 0, the function will decide where to allocate.</param>
		/// <param name="dwSize">- The number of bytes to allocate.</param>
		/// <param name="dwAllocationType">- The allocation type. See 'AllocationTypeFlags' for more.</param>
		/// <param name="dwMemoryProtection">- The memory page protection. See 'MemoryProtection' for more.</param>
		/// <exception cref="ParameterInvalidException"/>
		/// <exception cref="WindowsApiException"/>
		VirtualAllocation64(
			_In_ const ProcessInfo64& refTargetProcess,
			_In_opt_a64_(2) A_ADDR64 uAddress,
			_In_ A_DWORD dwSize,
			_In_ AllocationTypeFlags dwAllocationType,
			_In_ MemoryProtection dwMemoryProtection
		);

		VirtualAllocation64(const VirtualAllocation64&) = delete;
		~VirtualAllocation64();

		/// <summary>
		/// Gets the state of the allocation.
		/// </summary>
		/// <returns>The allocation state.</returns>
		AURORA_NDWR_GET("GetAllocationState") constexpr AllocationState GetAllocationState() const noexcept;

		/// <summary>
		/// Gets the current memory page protection constant.
		/// </summary>
		/// <returns>The current memory page protection.</returns>
		AURORA_NDWR_GET("GetMemoryProtection") constexpr MemoryProtection GetMemoryProtection() const noexcept;

		/// <summary>
		/// Gets the requested address.
		/// </summary>
		/// <returns>The requested address.</returns>
		AURORA_NDWR_GET("GetRequestedAddress") constexpr A_ADDR64 GetRequestedAddress() const noexcept;

		/// <summary>
		/// Gets the allocated address.
		/// </summary>
		/// <returns>The allocated address.</returns>
		AURORA_NDWR_GET("GetAllocatedAddress") constexpr A_ADDR64 GetAllocatedAddress() const noexcept;

		/// <summary>
		/// Gets the allocated size in bytes.
		/// </summary>
		/// <returns>The allocated size.</returns>
		AURORA_NDWR_GET("GetAllocatedSize") constexpr A_DWORD GetAllocatedSize() const noexcept;

		/// <summary>
		/// Sets the memory page protection for the allocation.
		/// </summary>
		/// <param name="dwNewProtection">- The new protection constant.</param>
		/// <returns>The previous protection constant.</returns>
		/// <exception cref="ParameterInvalidException"/>
		/// <exception cref="WindowsApiException"/>
		MemoryProtection SetMemoryProtection(_In_ MemoryProtection dwNewProtection);

		/// <summary>
		/// Commits the currently reserved memory.
		/// </summary>
		/// <exception cref="ParameterInvalidException"/>
		/// <exception cref="WindowsApiException"/>
		A_VOID Commit();

		/// <summary>
		/// Decommits the currently committed memory.
		/// </summary>
		/// <exception cref="ParameterInvalidException"/>
		/// <exception cref="WindowsApiException"/>
		A_VOID Decommit();

		/// <summary>
		/// Reads memory from the allocation.
		/// </summary>
		/// <param name="uIndex">- The index relative to the allocation base to read from.</param>
		/// <param name="lpBuffer">- A pointer to a buffer to receive the read data.</param>
		/// <param name="dwSize">- The size of the buffer in bytes.</param>
		/// <exception cref="ParameterInvalidException"/>
		/// <exception cref="Read64Exception"/>
		A_VOID Read(
			_In_ A_U32 uIndex,
			_Out_writes_bytes_(dwSize) A_LPVOID lpBuffer,
			_In_ A_DWORD dwSize
		) const;

		/// <summary>
		/// Reads memory from the allocation.
		/// </summary>
		/// <typeparam name="ReturnType">- The type to read.</typeparam>
		/// <<param name="uIndex">- The index relative to the allocation base to read from.</param>
		/// <returns>The read element.</returns>
		/// <exception cref="ParameterInvalidException"/>
		/// <exception cref="Read64Exception"/>
		template<ReadReturnType ReturnType>
		AURORA_NDWR_PURE("Read") ReturnType Read(_In_ A_U32 uIndex) const {
			AuroraContextStart();
			ReturnType ret;
			Read(uIndex, &ret, sizeof(ReturnType));
			AuroraContextEnd();
			return ret;
		}

		/// <summary>
		/// Reads a an array of elements from the allocation.
		/// </summary>
		/// <typeparam name="ReturnType">- The type to read.</typeparam>
		/// <typeparam name="nSize">- The size of the buffer in elements.</typeparam>
		/// <param name="uIndex">- The index relative to the allocation base to read from.</param>
		/// <param name="lpBuffer">- A reference to a buffer to receive the read data.</param>
		/// <exception cref="ParameterInvalidException"/>
		/// <exception cref="Read64Exception"/>
		template<ReadReturnType ReturnType, A_I32 nSize>
		A_VOID Read(
			_In_ A_U32 uIndex,
			_Out_writes_(nSize) ReturnType(&lpBuffer)[nSize]
		) {
			AuroraContextStart();
			Read(uIndex, lpBuffer, nSize * sizeof(ReturnType));
			AuroraContextEnd();
		}

		/// <summary>
		/// Writes memory to the allocation.
		/// </summary>
		/// <param name="uIndex">- The index relative to the allocation base to write to.</param>
		/// <param name="lpBuffer">- A pointer to a buffer containing the data to write.</param>
		/// <param name="dwSize">- The size of the buffer in bytes.</param>
		/// <exception cref="ParameterInvalidException"/>
		/// <exception cref="Write64Exception"/>
		A_VOID Write(
			_In_ A_U32 uIndex,
			_In_reads_bytes_(dwSize) A_LPCVOID lpBuffer,
			_In_ A_DWORD dwSize
		);

		/// <summary>
		/// Writes a single element to the allocation.
		/// </summary>
		/// <typeparam name="DataType">- The type to write.</typeparam>
		/// <param name="uIndex">- The index relative to the allocation base to write to.</param>
		/// <param name="refData">- A reference to the element to write.</param>
		/// <exception cref="ParameterInvalidException"/>
		/// <exception cref="Write64Exception"/>
		template<WriteDataType DataType>
		A_VOID Write(
			_In_ A_U32 uIndex,
			_In_ const DataType& refData
		) {
			AuroraContextStart();
			Write(uIndex, &refData, sizeof(DataType));
			AuroraContextEnd();
		}

		/// <summary>
		/// Writes an array of elements to the allocation.
		/// </summary>
		/// <typeparam name="DataType">- The type to write.</typeparam>
		/// <typeparam name="nSize">- The size of the buffer in elements.</typeparam>
		/// <param name="uIndex">- The index relative to the allocation base to write to.</param>
		/// <param name="lpBuffer">- A reference to a buffer containing the data to write.</param>
		/// <exception cref="ParameterInvalidException"/>
		/// <exception cref="Write64Exception"/>
		template<WriteDataType DataType, A_I32 nSize>
		A_VOID Write(
			_In_ A_U32 uIndex,
			_In_reads_(nSize) const DataType(&lpBuffer)[nSize]
		) {
			AuroraContextStart();
			Write(uIndex, lpBuffer, nSize * sizeof(DataType));
			AuroraContextEnd();
		}
	};

#ifdef _WIN64
	/// <summary>
	/// Manages a virtual memory allocation.
	/// </summary>
	using VirtualAllocation = VirtualAllocation64;
#else
	/// <summary>
	/// Manages a virtual memory allocation.
	/// </summary>
	using VirtualAllocation = VirtualAllocation32;
#endif // _WIN64s

	/// <summary>
	/// <para>Sets the protection of one or more virtual memory pages.</para>
	/// <para>This function wraps a Windows API function, see VirtualProtect for more.</para>
	/// </summary>
	/// <param name="uAddress">- The address to change the protection at.</param>
	/// <param name="dwSize">- The number of bytes to change the protection for.</param>
	/// <param name="dwProtect">- The protection to set.</param>
	/// <returns>The previous page protection constant.</returns>
	/// <exception cref="WindowsApiException"/>
	AURORA_API MemoryProtection ProtectMemory(
		_In_a_ A_ADDR uAddress,
		_In_ A_DWORD dwSize,
		_In_ MemoryProtection dwProtect
	);

	/// <summary>
	/// <para>Sets the protection of one or more virtual memory pages.</para>
	/// <para>This function wraps a Windows API function, see VirtualProtectEx for more.</para>
	/// </summary>
	/// <param name="refTargetProcess">- A reference to the target process.</param>
	/// <param name="uAddress">- The address to change the protection at.</param>
	/// <param name="dwSize">- The number of bytes to change the protection for.</param>
	/// <param name="dwProtect">- The protection to set.</param>
	/// <returns>The previous page protection constant.</returns>
	/// <exception cref="WindowsApiException"/>
	AURORA_API MemoryProtection ProtectMemory(
		_In_ const ProcessInfo32& refTargetProcess,
		_In_a32_ A_ADDR32 uAddress,
		_In_ A_DWORD dwSize,
		_In_ MemoryProtection dwProtect
	);

	/// <summary>
	/// <para>Sets the protection of one or more virtual memory pages.</para>
	/// <para>This function wraps a Windows API function, see VirtualProtectEx for more.</para>
	/// </summary>
	/// <param name="refTargetProcess">- A reference to the target process.</param>
	/// <param name="uAddress">- The address to change the protection at.</param>
	/// <param name="dwSize">- The number of bytes to change the protection for.</param>
	/// <param name="dwProtect">- The protection to set.</param>
	/// <returns>The previous page protection constant.</returns>
	/// <exception cref="WindowsApiException"/>
	AURORA_API MemoryProtection ProtectMemory(
		_In_ const ProcessInfo64& refTargetProcess,
		_In_a64_ A_ADDR64 uAddress,
		_In_ A_DWORD dwSize,
		_In_ MemoryProtection dwProtect
	);

	/// <summary>
	/// Queries information about one or more memory pages.
	/// </summary>
	/// <param name="uAddress">- The address to query information from.</param>
	/// <param name="lpMbi">- A pointer to a MEMORY_BASIC_INFORMATION structure to receive the queried information.</param>
	/// <exception cref="ParameterInvalidException"/>
	/// <exception cref="WindowsApiException"/>
	AURORA_API A_VOID QueryMemory(
		_In_a_ A_ADDR uAddress,
		_Out_ PMEMORY_BASIC_INFORMATION lpMbi
	);

	/// <summary>
	/// Queries information about one or more memory pages.
	/// </summary>
	/// <param name="refTargetProcess">- A reference to the target process.</param>
	/// <param name="uAddress">- The address to query information from.</param>
	/// <param name="lpMbi">- A pointer to a MEMORY_BASIC_INFORMATION structure to receive the queried information.</param>
	/// <exception cref="ParameterInvalidException"/>
	/// <exception cref="WindowsApiException"/>
	AURORA_API A_VOID QueryMemory(
		_In_ const ProcessInfo32& refTargetProcess,
		_In_a32_ A_ADDR32 uAddress,
		_Out_ PMEMORY_BASIC_INFORMATION lpMbi
	);

	/// <summary>
	/// Queries information about one or more memory pages.
	/// </summary>
	/// <param name="refTargetProcess">- A reference to the target process.</param>
	/// <param name="uAddress">- The address to query information from.</param>
	/// <param name="lpMbi">- A pointer to a MEMORY_BASIC_INFORMATION structure to receive the queried information.</param>
	/// <exception cref="ParameterInvalidException"/>
	/// <exception cref="WindowsApiException"/>
	AURORA_API A_VOID QueryMemory(
		_In_ const ProcessInfo64& refTargetProcess,
		_In_a64_ A_ADDR64 uAddress,
		_Out_ PMEMORY_BASIC_INFORMATION lpMbi
	);
}

#endif // !__AURORA_MEMORY_WIN32_H__
```

`Artemis/Aurora/Pipe.h`:

```h
//------------------------------------------------------------------------>
// MIT License
// 
// Copyright (c) 2023 Artemis Group
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------>
// Aurora: https://github.com/ArtemisDevGroup/Aurora
// This file was authored by:
// @Astrea0014: https://github.com/Astrea0014
//------------------------------------------------------------------------>

#ifndef __AURORA_PIPE_H__
#define __AURORA_PIPE_H__

#include "Definitions.h"
#include "Exceptions.h"

#include <Windows.h>

namespace Aurora {
	/// <summary>
	/// Represents the access mode of a pipe server or client instance.
	/// </summary>
	enum class PipeOpenMode : A_DWORD {
		/// <summary>
		/// The pipe instance accepts inbound data.
		/// </summary>
		Inbound = PIPE_ACCESS_INBOUND,

		/// <summary>
		/// The pipe instance accepts outbound data.
		/// </summary>
		Outbound = PIPE_ACCESS_OUTBOUND,

		/// <summary>
		/// The pipe instance accepts both inbound and outbound data.
		/// </summary>
		Duplex = PIPE_ACCESS_DUPLEX
	};

	/// <summary>
	/// Represents different settings related to the pipe server instance.
	/// </summary>
	struct PipeModeFlags {
		A_DWORD dwValue;

		enum Enumeration : A_DWORD {
			/// <summary>
			/// The pipe writes data as a stream of bytes.
			/// </summary>
			WriteMode_Byte = PIPE_TYPE_BYTE,

			/// <summary>
			/// The pipe writes data as messages (chunks of bytes).
			/// </summary>
			WriteMode_Message = PIPE_TYPE_MESSAGE,

			/// <summary>
			/// The pipe reads data as a stream of bytes.
			/// </summary>
			ReadMode_Byte = PIPE_READMODE_BYTE,

			/// <summary>
			/// The pipe reads data as messages (chunks of bytes).
			/// </summary>
			ReadMode_Message = PIPE_READMODE_MESSAGE,

			/// <summary>
			/// Blocking mode is enabled. Any operations are not completed until there is data to read, all data is written, or a client is connected.
			/// </summary>
			WaitMode_Wait = PIPE_WAIT,

			/// <summary>
			/// Nonblocking mode is enabled. In this mode, any operation always returns immediately.
			/// </summary>
			WaitMode_NoWait = PIPE_NOWAIT,

			/// <summary>
			/// Accepts remote clients.
			/// </summary>
			ClientMode_AcceptRemote = PIPE_ACCEPT_REMOTE_CLIENTS,

			/// <summary>
			/// Reject remote clients.
			/// </summary>
			ClientMode_RejectRemote = PIPE_REJECT_REMOTE_CLIENTS,

			/// <summary>
			/// A preset for byte read and write operations to the pipe.
			/// </summary>
			Byte = WriteMode_Byte | ReadMode_Byte | WaitMode_Wait | ClientMode_AcceptRemote,

			/// <summary>
			/// A preset for message read and write operations to the pipe.
			/// </summary>
			Message = WriteMode_Message | ReadMode_Message | WaitMode_Wait | ClientMode_AcceptRemote
		};

		constexpr PipeModeFlags() noexcept : dwValue(0) {}
		constexpr PipeModeFlags(A_DWORD dwValue) noexcept : dwValue(dwValue) {}

		operator A_DWORD& () noexcept { return dwValue; }
		constexpr operator const A_DWORD& () const noexcept { return dwValue; }
	};

	/// <summary>
	/// An interface containing the shared features between a named pipe server and client.
	/// </summary>
	class AURORA_API INamedPipeBase {
		HANDLE* phPipe;

	public:
		/// <summary>
		/// Sets the handle to pass to the ReadFile and WriteFile functions.
		/// </summary>
		/// <param name="lpPipeHandle">- A pointer to the handle to operate on.</param>
		INamedPipeBase(_In_ LPHANDLE lpPipeHandle);

		INamedPipeBase(const INamedPipeBase&) = delete;
		~INamedPipeBase();

		/// <summary>
		/// A purely virtual function that opens or creates an instance of a named pipe for the class to operate on.
		/// </summary>
		virtual A_VOID Create() = 0;

		/// <summary>
		/// Reads data from the end of the pipe.
		/// </summary>
		/// <param name="lpBuffer">- A pointer to a buffer to receive the data from the pipe.</param>
		/// <param name="dwNumberOfBytesToRead">- The number of bytes to attempt to read from the pipe.</param>
		/// <param name="lpNumberOfBytesRead">- A pointer to a DWORD to receive the number of bytes successfully read from the pipe. This parameter is optional.</param>
		/// <exception cref="ParameterInvalidException"/>
		/// <exception cref="WindowsApiException"/>
		A_VOID Read(
			_Out_writes_bytes_(dwNumberOfBytesToRead) A_LPVOID lpBuffer,
			_In_ A_DWORD dwNumberOfBytesToRead,
			_Out_opt_ A_LPDWORD lpNumberOfBytesRead = nullptr
		);

		/// <summary>
		/// Reads a string from the end of the pipe.
		/// </summary>
		/// <param name="lpString">- A pointer to a buffer to receive the read string.</param>
		/// <param name="dwSize">- The size of the buffer in characters.</param>
		/// <exception cref="ParameterInvalidException"/>
		/// <exception cref="WindowsApiException"/>
		A_VOID Read(
			_Out_writes_z_(dwSize) A_LPSTR lpString,
			_In_ A_DWORD dwSize
		);

		/// <summary>
		/// Reads data from the end of the pipe.
		/// </summary>
		/// <typeparam name="T">- The type of the data to read.</typeparam>
		/// <returns>The read data.</returns>
		/// <exception cref="ParameterInvalidException"/>
		/// <exception cref="WindowsApiException"/>
		template<ReadReturnType ReturnType>
		AURORA_NDWR_PURE("Read") inline ReturnType Read() {
			AuroraContextStart();

			ReturnType ret = ReturnType();

			Read(
				(A_LPVOID)&ret,
				sizeof(ReturnType),
				nullptr
			);

			AuroraContextEnd();
			return ret;
		}

		/// <summary>
		/// Writes data to the end of the pipe.
		/// </summary>
		/// <param name="lpBuffer">- A pointer to a buffer containing the data to write.</param>
		/// <param name="dwNumberOfBytesToWrite">- The number of bytes to write to the pipe</param>
		/// <param name="lpNumberOfBytesWritten">- A pointer to a DWORD to receive the number of bytes successfully written to the pipe. This parameter is optional.</param>
		/// <exception cref="ParameterInvalidException"/>
		/// <exception cref="WindowsApiException"/>
		A_VOID Write(
			_In_reads_bytes_(dwNumberOfBytesToWrite) A_LPCVOID lpBuffer,
			_In_ A_DWORD dwNumberOfBytesToWrite,
			_Out_opt_ A_LPDWORD lpNumberOfBytesWritten = nullptr
		);

		/// <summary>
		/// Writes a string to the end of the pipe.
		/// </summary>
		/// <param name="lpString">- A pointer to the string to write.</param>
		/// <exception cref="ParameterInvalidException"/>
		/// <exception cref="WindowsApiException"/>
		A_VOID Write(_In_z_ A_LPCSTR lpString);

		/// <summary>
		/// Writes data to the end of the pipe.
		/// </summary>
		/// <typeparam name="T">- The type of the data to write.</typeparam>
		/// <param name="refBuffer">- A reference to the data to write.</param>
		/// <exception cref="ParameterInvalidException"/>
		/// <exception cref="WindowsApiException"/>
		template<WriteDataType DataType>
		inline A_VOID Write(_In_ const DataType& refBuffer) {
			AuroraContextStart();

			Write(
				(A_LPCVOID)&refBuffer,
				sizeof(DataType),
				nullptr
			);

			AuroraContextEnd();
		}
	};

	/// <summary>
	/// A class for creating and interacting with a named pipe server.
	/// </summary>
	class AURORA_API NamedPipeServer : public INamedPipeBase {
		A_CHAR szName[MAX_PATH];
		PipeOpenMode dwOpenMode;
		PipeModeFlags dwPipeMode;
		A_DWORD dwMaxInstances;
		SECURITY_ATTRIBUTES SecurityAttributes;
		A_BOOL bSecurityAttributesActive;
		HANDLE hPipe;

	public:
		/// <summary>
		/// Sets the parameters of a named pipe server instance.
		/// </summary>
		/// <param name="lpName">- The name of the pipe, either as-is or prefixed with '\\.\pipe\'.</param>
		/// <param name="dwOpenMode">- A constant defining the open mode of the pipe.</param>
		/// <param name="dwPipeMode">- Bit flags defining the pipe settings.</param>
		/// <param name="dwMaxInstances">- The maximum number of instances allowed to be created by the pipe.</param>
		/// <param name="lpSecurityAttributes">- A pointer to a security attributes structure specifying the security descriptor of the pipe.</param>
		NamedPipeServer(
			_In_z_ A_LPCSTR lpName,
			_In_ PipeOpenMode dwOpenMode,
			_In_ PipeModeFlags dwPipeMode,
			_In_range_(1, PIPE_UNLIMITED_INSTANCES) A_DWORD dwMaxInstances = PIPE_UNLIMITED_INSTANCES,
			_In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes = nullptr
		);

		NamedPipeServer(const NamedPipeServer&) = delete;

		/// <summary>
		/// Creates the pipe server instance.
		/// </summary>
		/// <exception cref="WindowsApiException"/>
		virtual A_VOID INamedPipeBase::Create();

		/// <summary>
		/// Waits for a pipe client to connect to the server.
		/// </summary>
		/// <exception cref="WindowsApiException"/>
		A_VOID Connect() const;

		/// <summary>
		/// Waits for a pipe client to disconnect from the server.
		/// </summary>
		/// <exception cref="WindowsApiException"/>
		A_VOID Disconnect() const;
	};

	/// <summary>
	/// A class for creating and interacting with a named pipe client.
	/// </summary>
	class AURORA_API NamedPipeClient : public INamedPipeBase {
		A_CHAR szName[MAX_PATH];
		PipeOpenMode dwOpenMode;
		SECURITY_ATTRIBUTES SecurityAttributes;
		A_BOOL bSecurityAttributesActive;
		HANDLE hPipe;

	public:
		/// <summary>
		/// Sets the parameters of a named pipe client instance.
		/// </summary>
		/// <param name="lpName">- The name of the pipe, either as-is or prefixed with '\\.\pipe\'.</param>
		/// <param name="dwOpenMode">- A constant defining the open mode of the pipe.</param>
		/// <param name="lpSecurityAttributes">- A pointer to a security attributes structure specifying the security descriptor of the pipe.</param>
		NamedPipeClient(
			_In_z_ A_LPCSTR lpName,
			_In_ PipeOpenMode dwOpenMode,
			_In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes = nullptr
		);

		NamedPipeClient(const NamedPipeClient&) = delete;

		/// <summary>
		/// Creates the pipe server instance.
		/// </summary>
		/// <exception cref="WindowsApiException"/>
		/// <exception cref="ParameterInvalidException"/>
		virtual A_VOID INamedPipeBase::Create();
	};

	/// <summary>
	/// A class for creating and interacting with an anonymous pipe.
	/// </summary>
	class AURORA_API AnonymousPipe {
		HANDLE hReadPipe;
		HANDLE hWritePipe;
		SIZE_T nSize;
		SECURITY_ATTRIBUTES SecurityAttributes;
		A_BOOL bSecurityAttributesActive;

	public:
		/// <summary>
		/// Sets the parameters of an anonymous pipe instance.
		/// </summary>
		/// <param name="lpSecurityAttributes">- A pointer to a security attributes structure specifying the security descriptor of the pipe.</param>
		/// <param name="nSize">- The size of the pipe buffer in bytes.</param>
		AnonymousPipe(
			_In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes = nullptr,
			_In_ SIZE_T nSize = 256
		);

		AnonymousPipe(const AnonymousPipe&) = delete;
		~AnonymousPipe();

		/// <summary>
		/// Creates the anonymous pipe instance.
		/// </summary>
		/// <exception cref="WindowsApiException"/>
		A_VOID Create();

		/// <summary>
		/// Reads data from the end of the pipe.
		/// </summary>
		/// <param name="lpBuffer">- A pointer to a buffer to receive the data from the pipe.</param>
		/// <param name="dwNumberOfBytesToRead">- The number of bytes to attempt to read from the pipe.</param>
		/// <param name="lpNumberOfBytesRead">- A pointer to a DWORD to receive the number of bytes successfully read from the pipe. This parameter is optional.</param>
		/// <exception cref="ParameterInvalidException"/>
		/// <exception cref="WindowsApiException"/>
		A_VOID Read(
			_Out_writes_bytes_(dwNumberOfBytesToRead) A_LPVOID lpBuffer,
			_In_ A_DWORD dwNumberOfBytesToRead,
			_Out_opt_ A_LPDWORD lpNumberOfBytesRead = nullptr
		);

		/// <summary>
		/// Reads a string from the end of the pipe.
		/// </summary>
		/// <param name="lpString">- A pointer to a buffer to receive the read string.</param>
		/// <param name="dwSize">- The size of the buffer in characters.</param>
		/// <exception cref="ParameterInvalidException"/>
		/// <exception cref="WindowsApiException"/>
		A_VOID Read(
			_Out_writes_z_(dwSize) A_LPSTR lpString,
			_In_ A_DWORD dwSize
		);

		/// <summary>
		/// Reads data from the end of the pipe.
		/// </summary>
		/// <typeparam name="T">- The type of the data to read.</typeparam>
		/// <returns>The read data.</returns>
		/// <exception cref="ParameterInvalidException"/>
		/// <exception cref="WindowsApiException"/>
		template<ReadReturnType ReturnType>
		AURORA_NDWR_PURE("Read") inline ReturnType Read() {
			AuroraContextStart();

			ReturnType ret = ReturnType();

			Read(
				(A_LPVOID)&ret,
				sizeof(ReturnType),
				nullptr
			);

			AuroraContextEnd();
			return ret;
		}

		/// <summary>
		/// Writes data to the end of the pipe.
		/// </summary>
		/// <param name="lpBuffer">- A pointer to a buffer containing the data to write.</param>
		/// <param name="dwNumberOfBytesToWrite">- The number of bytes to write to the pipe</param>
		/// <param name="lpNumberOfBytesWritten">- A pointer to a DWORD to receive the number of bytes successfully written to the pipe. This parameter is optional.</param>
		/// <exception cref="ParameterInvalidException"/>
		/// <exception cref="WindowsApiException"/>
		A_VOID Write(
			_In_reads_bytes_(dwNumberOfBytesToWrite) A_LPCVOID lpBuffer,
			_In_ A_DWORD dwNumberOfBytesToWrite,
			_Out_opt_ A_LPDWORD lpNumberOfBytesWritten = nullptr
		);

		/// <summary>
		/// Writes a string to the end of the pipe.
		/// </summary>
		/// <param name="lpString">- A pointer to the string to write.</param>
		/// <exception cref="ParameterInvalidException"/>
		/// <exception cref="WindowsApiException"/>
		A_VOID Write(_In_z_ A_LPCSTR lpString);

		/// <summary>
		/// Writes data to the end of the pipe.
		/// </summary>
		/// <typeparam name="T">- The type of the data to write.</typeparam>
		/// <param name="refBuffer">- A reference to the data to write.</param>
		/// <exception cref="ParameterInvalidException"/>
		/// <exception cref="WindowsApiException"/>
		template<WriteDataType DataType>
		inline A_VOID Write(_In_ const DataType& refBuffer) {
			AuroraContextStart();

			Write(
				(A_LPCVOID)&refBuffer,
				sizeof(DataType),
				nullptr
			);

			AuroraContextEnd();
		}
	};
}

#endif // !__AURORA_PIPE_H__
```

`Artemis/Aurora/ProcessInfo.h`:

```h
//------------------------------------------------------------------------>
// MIT License
// 
// Copyright (c) 2023 Artemis Group
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------>
// Aurora: https://github.com/ArtemisDevGroup/Aurora
// This file was authored by:
// @Astrea0014: https://github.com/Astrea0014
//------------------------------------------------------------------------>

#ifndef __AURORA_PROCESS_INFO_H__
#define __AURORA_PROCESS_INFO_H__

#include "Definitions.h"
#include "Exceptions.h"
#include "Array.h"
#include "SharedHandle.h"

#include <Windows.h>
#undef GetModuleHandle

namespace Aurora {
	class ProcessInfo32;
	class ProcessInfo64;

	/// <summary>
	/// Contains information about a module in a 32-bit process.
	/// </summary>
	class AURORA_API ModuleInfo32 {
		A_CHAR szModuleName[MAX_NAME];
		A_CHAR szModulePath[MAX_PATH];
		HMODULE hModule;
		A_ADDR32 uModuleBaseAddress;
		A_DWORD dwModuleSize;

		const ProcessInfo32* lpOwningProcess;

	public:
		ModuleInfo32();

		/// <summary>
		/// Gathers information about a module.
		/// </summary>
		/// <param name="lpOwningProcess">- A pointer to a process info instance belonging to the owning process.</param>
		/// <param name="hModule">- A handle to the module to gather information about</param>
		/// <exception cref="WindowsApiException"/>
		ModuleInfo32(_In_ const ProcessInfo32* lpOwningProcess, _In_ HMODULE hModule);

		ModuleInfo32(_In_ const ProcessInfo32* lpOwningProcess, _In_ const ModuleInfo32&);

		ModuleInfo32(const ModuleInfo32&);

		/// <summary>
		/// Gets the name of the module represented by the current instance.
		/// </summary>
		/// <returns>The name of the module.</returns>
		AURORA_NDWR_GET("GetModuleName") constexpr A_LPCSTR GetModuleName() const noexcept;

		/// <summary>
		/// Gets the absolute path of the module represented by the current instance.
		/// </summary>
		/// <returns>The path of the module.</returns>
		AURORA_NDWR_GET("GetModulePath") constexpr A_LPCSTR GetModulePath() const noexcept;

		/// <summary>
		/// Gets the handle of the module represented by the current instance.
		/// </summary>
		/// <returns>The handle of the module.</returns>
		AURORA_NDWR_GET("GetModuleHandle") constexpr HMODULE GetModuleHandle() const noexcept;

		/// <summary>
		/// Gets the base address of the allocation belonging to the module represented by the current instance.
		/// </summary>
		/// <returns>The base address of the module allocation.</returns>
		AURORA_NDWR_GET("GetModuleBaseAddress") constexpr A_ADDR32 GetModuleBaseAddress() const noexcept;

		/// <summary>
		/// Gets the size of the allocation belonging to the module represented by the current instance.
		/// </summary>
		/// <returns>The size of the module allocation.</returns>
		AURORA_NDWR_GET("GetModuleSize") constexpr A_DWORD GetModuleSize() const noexcept;

		/// <summary>
		/// Gets a reference to a process info object representing the process where the current instance of the module is loaded.
		/// </summary>
		/// <returns>A reference to the owning process.</returns>
		AURORA_NDWR_GET("GetOwningProcess") constexpr const ProcessInfo32& GetOwningProcess() const noexcept;
	};

	/// <summary>
	/// Contains information about a module in a 64-bit process.
	/// </summary>
	class AURORA_API ModuleInfo64 {
		A_CHAR szModuleName[MAX_NAME];
		A_CHAR szModulePath[MAX_PATH];
		HMODULE hModule;
		A_ADDR64 uModuleBaseAddress;
		A_DWORD dwModuleSize;

		const ProcessInfo64* lpOwningProcess;

	public:
		ModuleInfo64();

		/// <summary>
		/// Gathers information about a module.
		/// </summary>
		/// <param name="lpOwningProcess">- A pointer to a process info instance belonging to the owning process.</param>
		/// <param name="hModule">- A handle to the module to gather information about</param>
		/// <exception cref="WindowsApiException"/>
		ModuleInfo64(_In_ const ProcessInfo64* lpOwningProcess, _In_ HMODULE hModule);

		ModuleInfo64(_In_ const ProcessInfo64* lpOwningProcess, _In_ const ModuleInfo64&);

		ModuleInfo64(const ModuleInfo64&);

		/// <summary>
		/// Gets the name of the module represented by the current instance.
		/// </summary>
		/// <returns>The name of the module.</returns>
		AURORA_NDWR_GET("GetModuleName") constexpr A_LPCSTR GetModuleName() const noexcept;

		/// <summary>
		/// Gets the absolute path of the module represented by the current instance.
		/// </summary>
		/// <returns>The path of the module.</returns>
		AURORA_NDWR_GET("GetModulePath") constexpr A_LPCSTR GetModulePath() const noexcept;

		/// <summary>
		/// Gets the handle of the module represented by the current instance.
		/// </summary>
		/// <returns>The handle of the module.</returns>
		AURORA_NDWR_GET("GetModuleHandle") constexpr HMODULE GetModuleHandle() const noexcept;

		/// <summary>
		/// Gets the base address of the allocation belonging to the module represented by the current instance.
		/// </summary>
		/// <returns>The base address of the module allocation.</returns>
		AURORA_NDWR_GET("GetModuleBaseAddress") constexpr A_ADDR64 GetModuleBaseAddress() const noexcept;

		/// <summary>
		/// Gets the size of the allocation belonging to the module represented by the current instance.
		/// </summary>
		/// <returns>The size of the module allocation.</returns>
		AURORA_NDWR_GET("GetModuleSize") constexpr A_DWORD GetModuleSize() const noexcept;

		/// <summary>
		/// Gets a reference to a process info object representing the process where the current instance of the module is loaded.
		/// </summary>
		/// <returns>A reference to the owning process.</returns>
		AURORA_NDWR_GET("GetOwningProcess") constexpr const ProcessInfo64& GetOwningProcess() const noexcept;
	};

	/// <summary>
	/// Contains information about a 32-bit process.
	/// </summary>
	class AURORA_API ProcessInfo32 {
		A_CHAR szProcessName[MAX_NAME];
		A_CHAR szProcessPath[MAX_PATH];
		HANDLE hProcess;
		A_DWORD dwProcessId;
		List<ModuleInfo32> ModuleList;

	public:
		/// <summary>
		/// Fetches information about a 32-bit process.
		/// </summary>
		/// <param name="lpProcessName">
		/// <para>- The name of the process to fetch information from.</para>
		/// <para>'nullptr' (default) will fetch information about the current process instead.</para>
		/// </param>
		/// <exception cref="WindowsApiException"/>
		ProcessInfo32(_In_opt_z_ A_LPCSTR lpProcessName = nullptr);
		ProcessInfo32(const ProcessInfo32&);
		~ProcessInfo32();

		/// <summary>
		/// Gets the name of the process associated with the instance.
		/// </summary>
		/// <returns>The process name.</returns>
		AURORA_NDWR_GET("GetProcessName") constexpr A_LPCSTR GetProcessName() const noexcept;

		/// <summary>
		/// Gets a path to the process executable associated with the instance.
		/// </summary>
		/// <returns>A process executable path.</returns>
		AURORA_NDWR_GET("GetProcessPath") constexpr A_LPCSTR GetProcessPath() const noexcept;

		/// <summary>
		/// <para>Gets a handle to the process associated with the instance.</para>
		/// <para>The handle has the following access rights:</para>
		/// <para> - PROCESS_VM_READ</para>
		/// <para> - PROCESS_VM_WRITE</para>
		/// <para> - PROCESS_VM_OPERATION</para>
		/// <para> - PROCESS_CREATE_PROCESS</para>
		/// <para> - PROCESS_CREATE_THREAD</para>
		/// <para> - PROCESS_QUERY_INFORMATION</para>
		/// <para> - SYNCHRONIZE</para>
		/// </summary>
		/// <returns>A handle to the process.</returns>
		AURORA_NDWR_GET("GetProcessHandle") constexpr HANDLE GetProcessHandle() const noexcept;

		/// <summary>
		/// Gets the id of the process associated with the instance.
		/// </summary>
		/// <returns>The process id.</returns>
		AURORA_NDWR_GET("GetProcessId") constexpr A_DWORD GetProcessId() const noexcept;

		/// <summary>
		/// Gets a reference to the list of modules loaded in the process associated with the instance.
		/// </summary>
		/// <returns>The loaded module list.</returns>
		AURORA_NDWR_GET("GetModuleList") constexpr const List<ModuleInfo32>& GetModuleList() const noexcept;

		/// <summary>
		/// Gets a reference to the module with the provided name.
		/// </summary>
		/// <param name="lpModuleName">- The name of the module to find.</param>
		/// <returns>A reference to a ModuleInfo32 instance containing information about the module.</returns>
		/// <exception cref="ObjectNotFoundException"/>
		AURORA_NDWR_GET("GetModule") const ModuleInfo32& GetModule(_In_opt_z_ A_LPCSTR lpModuleName = nullptr) const;

		/// <summary>
		/// Checks whether the process info instance represents the current process.
		/// </summary>
		/// <returns>True if the instance represents the current process, otherwise false.</returns>
		AURORA_NDWR_GET("IsCurrentProcess") A_BOOL IsCurrentProcess() const noexcept;

		/// <summary>
		/// Refreshes the module list by fetching every module again.
		/// </summary>
		/// <exception cref="WindowsApiException"/>
		AURORA_NDWR_GET("RefreshModuleList") A_VOID RefreshModuleList();
	}; 

	/// <summary>
	/// Contains information about a 64-bit process.
	/// </summary>
	class AURORA_API ProcessInfo64 {
		A_CHAR szProcessName[MAX_NAME];
		A_CHAR szProcessPath[MAX_PATH];
		HANDLE hProcess;
		A_DWORD dwProcessId;
		List<ModuleInfo64> ModuleList;

	public:
		/// <summary>
		/// Fetches information about a 64-bit process.
		/// </summary>
		/// <param name="lpProcessName">
		/// <para>- The name of the process to fetch information from.</para>
		/// <para>'nullptr' (default) will fetch information about the current process instead.</para>
		/// </param>
		/// <exception cref="WindowsApiException"/>
		ProcessInfo64(_In_opt_z_ A_LPCSTR lpProcessName = nullptr);
		ProcessInfo64(const ProcessInfo64&);
		~ProcessInfo64();

		/// <summary>
		/// Gets the name of the process associated with the instance.
		/// </summary>
		/// <returns>The process name.</returns>
		AURORA_NDWR_GET("GetProcessName") constexpr A_LPCSTR GetProcessName() const noexcept;

		/// <summary>
		/// Gets a path to the process executable associated with the instance.
		/// </summary>
		/// <returns>A process executable path.</returns>
		AURORA_NDWR_GET("GetProcessPath") constexpr A_LPCSTR GetProcessPath() const noexcept;

		/// <summary>
		/// <para>Gets a handle to the process associated with the instance.</para>
		/// <para>The handle has the following access rights:</para>
		/// <para> - PROCESS_VM_READ</para>
		/// <para> - PROCESS_VM_WRITE</para>
		/// <para> - PROCESS_VM_OPERATION</para>
		/// <para> - PROCESS_CREATE_PROCESS</para>
		/// <para> - PROCESS_CREATE_THREAD</para>
		/// <para> - PROCESS_QUERY_INFORMATION</para>
		/// <para> - SYNCHRONIZE</para>
		/// </summary>
		/// <returns>A handle to the process.</returns>
		AURORA_NDWR_GET("GetProcessHandle") constexpr HANDLE GetProcessHandle() const noexcept;

		/// <summary>
		/// Gets the id of the process associated with the instance.
		/// </summary>
		/// <returns>The process id.</returns>
		AURORA_NDWR_GET("GetProcessId") constexpr A_DWORD GetProcessId() const noexcept;

		/// <summary>
		/// Gets a reference to the list of modules loaded in the process associated with the instance.
		/// </summary>
		/// <returns>The loaded module list.</returns>
		AURORA_NDWR_GET("GetModuleList") constexpr const List<ModuleInfo64>& GetModuleList() const noexcept;

		/// <summary>
		/// Gets a reference to the module with the provided name.
		/// </summary>
		/// <param name="lpModuleName">- The name of the module to find.</param>
		/// <returns>A reference to a ModuleInfo32 instance containing information about the module.</returns>
		/// <exception cref="ObjectNotFoundException"/>
		AURORA_NDWR_GET("GetModule") const ModuleInfo64& GetModule(_In_opt_z_ A_LPCSTR lpModuleName = nullptr) const;

		/// <summary>
		/// Checks whether the process info instance represents the current process.
		/// </summary>
		/// <returns>True if the instance represents the current process, otherwise false.</returns>
		AURORA_NDWR_GET("IsCurrentProcess") A_BOOL IsCurrentProcess() const noexcept;

		/// <summary>
		/// Refreshes the module list by fetching every module again.
		/// </summary>
		/// <exception cref="WindowsApiException"/>
		AURORA_NDWR_GET("RefreshModuleList") A_VOID RefreshModuleList();
	};

#ifdef _WIN64
	/// <summary>
	/// Contains information about a module in a 64-bit process.
	/// </summary>
	using ModuleInfo = ModuleInfo64;

	/// <summary>
	/// Contains information about a 64-bit process.
	/// </summary>
	using ProcessInfo = ProcessInfo64;
#else
	/// <summary>
	/// Contains information about a module in a 32-bit process.
	/// </summary>
	using ModuleInfo = ModuleInfo32;

	/// <summary>
	/// Contains information about a 32-bit process.
	/// </summary>
	using ProcessInfo = ProcessInfo32;
#endif // _WIN64

	/// <summary>
	/// Gets information about the current process.
	/// </summary>
	/// <returns>Information about the current process.</returns>
	AURORA_NDWR_GET("GetCurrentProcessInfo") AURORA_API ProcessInfo& GetCurrentProcessInfo() noexcept;
}

#endif // !__AURORA_PROCESS_INFO_H__
```

`Artemis/Aurora/Property.h`:

```h
//------------------------------------------------------------------------>
// MIT License
// 
// Copyright (c) 2023 Artemis Group
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------>
// Aurora: https://github.com/ArtemisDevGroup/Aurora
// This file was authored by:
// @Astrea0014: https://github.com/Astrea0014
//------------------------------------------------------------------------>

#ifndef __AURORA_PROPERTY_H__
#define __AURORA_PROPERTY_H__

#include "Definitions.h"

namespace Aurora {
	/// <summary>
	/// A class for setting custom get and set behaviour for a data field.
	/// </summary>
	/// <typeparam name="T">- The type of the variable.</typeparam>
	template<NonVoidType T>
	class Property {
		Function<const T& (const T&)> Get;
		Function<void(T&, const T&)> Set;

		T value;

	public:
		/// <summary>
		/// Sets the get and set behaviour of the property.
		/// </summary>
		/// <param name="GetFunction">- A lambda or function pointer defining the get behaviour of the property.</param>
		/// <param name="SetFunction">- A lambda or function pointer defining the set behaviour of the property.</param>
		Property(
			_In_ Function<const T& (const T&)> GetFunction,
			_In_ Function<void(T&, const T&)> SetFunction
		) : value(T()), Get(GetFunction), Set(SetFunction) {}

		/// <summary>
		/// Calls the get routine and returns the value.
		/// </summary>
		/// <returns>The value of the property.</returns>
		AURORA_NDWR_GET("GetValue") const T& GetValue() const { return Get(this->value); }

		/// <summary>
		/// Calls the set routine.
		/// </summary>
		/// <param name="refValue">- The value to set.</param>
		void SetValue(const T& refValue) { Set(this->value, refValue); }

		void operator=(const T& refValue) { SetValue(refValue); }
		operator const T& () const { return GetValue(); }
	};

	/// <summary>
	/// A class for setting custom get and set behaviour for an external variable.
	/// </summary>
	/// <typeparam name="T"></typeparam>
	template<NonVoidType T>
	class FullProperty {
		Function<const T& ()> Get;
		Function<void(const T&)> Set;

	public:
		/// <summary>
		/// Sets the get and set behaviour of the property.
		/// </summary>
		/// <param name="GetFunction">- A lambda or function pointer defining the get behaviour of the property.</param>
		/// <param name="SetFunction">- A lambda or function pointer defining the set behaviour of the property.</param>
		FullProperty(
			_In_ Function<const T& ()> GetFunction,
			_In_ Function<void(const T&)> SetFunction
		) : Get(GetFunction), Set(SetFunction) {}

		/// <summary>
		/// Calls the get routine and returns the value.
		/// </summary>
		/// <returns>The value of the property.</returns>
		AURORA_NDWR_GET("GetValue") const T& GetValue() const { return Get(); }

		/// <summary>
		/// Calls the set routine.
		/// </summary>
		/// <param name="refValue">- The value to set.</param>
		void SetValue(const T& refValue) { Set(refValue); }

		void operator=(const T& refValue) { SetValue(refValue); }
		operator const T& () const { return GetValue(); }
	};
}

#endif // !__AURORA_PROPERTY_H__
```

`Artemis/Aurora/Shapes.h`:

```h
//------------------------------------------------------------------------>
// MIT License
// 
// Copyright (c) 2023 Artemis Group
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------>
// Aurora: https://github.com/ArtemisDevGroup/Aurora
// This file was authored by:
// @Astrea0014: https://github.com/Astrea0014
//------------------------------------------------------------------------>

#ifndef __AURORA_SHAPES_H__
#define __AURORA_SHAPES_H__

#include "Definitions.h"
#include "Vector.h"
#include "Color.h"
#include "ConstexprMath.h"
#include "Array.h"

namespace Aurora {
	/// <summary>
	/// A point on a screen.
	/// </summary>
	struct Point {
		A_I32 x; // The x coordinate of the point.
		A_I32 y; // The y coordinate of the point.

		constexpr Point() noexcept : x(0), y(0) {}
		constexpr Point(_In_ const A_I32 x, _In_ const A_I32 y) noexcept : x(x), y(y) {}

		/// <summary>
		/// Gets the distance between the current point and the referenced point.
		/// </summary>
		/// <param name="refPoint">- A constant reference to a point.</param>
		/// <returns>The distance between the two points.</returns>
		AURORA_NDWR_PURE("Distance") constexpr A_FL64 Distance(_In_ const Point& refPoint) const noexcept { return SquareRoot(Squared(x - refPoint.x) + Squared(y - refPoint.y)); }
	};

	/// <summary>
	/// A straight line between two points.
	/// </summary>
	struct Line {
		Array<Point, 2> szptPoints; // The beginning and end points of the line.
		RGBA Color; // The color of the line.
		A_FL32 fThickness; // The thickness of the line.

		constexpr Line() noexcept : szptPoints(), Color(), fThickness(0) {}

		/// <summary>
		/// Constructs a Line.
		/// </summary>
		/// <param name="ptPoint1">- A constant reference to the beginning point of the line.</param>
		/// <param name="ptPoint2">- A constant reference to the end point of the line.</param>
		/// <param name="Color">- The color of the line.</param>
		/// <param name="fThickness">- The thickness of the line.</param>
		constexpr Line(
			_In_ const Point& ptPoint1,
			_In_ const Point& ptPoint2,
			_In_ const RGBA& Color,
			_In_ const A_FL32 fThickness = 1.0f
		) noexcept : szptPoints({ ptPoint1, ptPoint2 }), Color(Color), fThickness(fThickness) {}

		/// <summary>
		/// Gets the cofficient of the slope.
		/// </summary>
		/// <returns>The cofficient of the slope.</returns>
		AURORA_NDWR_PURE("SlopeCofficient") constexpr A_FL64 SlopeCofficient() const noexcept { return Delta(szptPoints[0].y, szptPoints[1].y) / Delta(szptPoints[0].x, szptPoints[1].x); }

		/// <summary>
		/// Checks if the line is parallel with another referenced line.
		/// </summary>
		/// <param name="refLine">- A constant reference to a line.</param>
		/// <returns>True if the lines are parallel, otherwise false.</returns>
		AURORA_NDWR_PURE("IsParallel") constexpr A_BOOL IsParallel(const Line& refLine) const noexcept { return this->SlopeCofficient() - refLine.SlopeCofficient() == 0.0; }
	};

	// Static polyline struct. Number of points decided on compile time. Fully constexpr compatible.

	/// <summary>
	/// A line between multiple points.
	/// </summary>
	/// <typeparam name="nPointCount">- The number of points.</typeparam>
	template<A_I32 nPointCount = 0>
		requires(nPointCount > 2 || nPointCount == 0)
	struct PolyLine {
		Array<Point, nPointCount> szptPoints; // An array of points to draw the line between.
		RGBA Color; // The color of the line.
		A_FL32 fThickness; // The thickness of the line.

		constexpr PolyLine() noexcept : szptPoints(), Color(), fThickness(0) {}

		/// <summary>
		/// Constructs a Polyline.
		/// </summary>
		/// <param name="szptPoints">- The points to draw the line between.</param>
		/// <param name="Color">- The color of the line.</param>
		/// <param name="fThickness">- The thickness of the line.</param>
		constexpr PolyLine(
			_In_ const Array<Point, nPointCount>& szptPoints,
			_In_ const RGBA& Color,
			_In_ const A_FL32 fThickness = 1.0f
		) noexcept : szptPoints(szptPoints), Color(Color), fThickness(fThickness) {}
	};

	// Dynamic polyline struct. Number of points decided on runtime. Not constexpr compatible.

	/// <summary>
	/// A line between multiple points.
	/// </summary>
	template<>
	struct PolyLine<0> {
		List<Point> szptPoints; // A list of points to draw the line between.
		RGBA Color; // The color of the line.
		A_FL32 fThickness; // The thickness of the line.

		inline PolyLine() noexcept : szptPoints(), Color(), fThickness(0) {}

		/// <summary>
		/// Constructs a Polyline.
		/// </summary>
		/// <param name="szptPoints">- The points to draw the line between.</param>
		/// <param name="Color">- The color of the line.</param>
		/// <param name="fThickness">- The thickness of the line.</param>
		inline PolyLine(
			_In_ const List<Point>& szptPoints,
			_In_ const RGBA& Color,
			_In_ const A_FL32 fThickness = 1.0f
		) noexcept : szptPoints(szptPoints), Color(Color), fThickness(fThickness) {}
	};

	/// <summary>
	/// A rectangle between two points.
	/// </summary>
	struct Rectangle {
		Point ptTopLeftPoint; // The top-left point in the rectangle.
		Point ptBottomRightPoint; // The bottom-right point in the rectangle.
		RGBA Color; // The color of the rectangle.
		A_BOOL bFilled; // A bool that determines whether the rectangle shall be drawn as a solid or as an outline.
		A_FL32 fThickness; // The thickness of the rectangle borders.

		constexpr Rectangle() noexcept : ptTopLeftPoint(), ptBottomRightPoint(), Color(), bFilled(false), fThickness(0) {}

		/// <summary>
		/// Constructs a Rectangle.
		/// </summary>
		/// <param name="ptTopLeftPoint">- The top-left corner of the rectangle.</param>
		/// <param name="ptBottomRightPoint">- The bottom-right corner of the rectangle.</param>
		/// <param name="Color">- The color of the rectangle.</param>
		/// <param name="bFilled">- A bool that determines whether the rectangle shall be drawn as a solid or as an outline.</param>
		/// <param name="fThickness">- The thickness of the rectangle borders.</param>
		constexpr Rectangle(
			_In_ const Point& ptTopLeftPoint,
			_In_ const Point& ptBottomRightPoint,
			_In_ const RGBA& Color,
			_In_ const A_BOOL bFilled = false,
			_In_ const A_FL32 fThickness = 1.0f
		) noexcept : ptTopLeftPoint(ptTopLeftPoint),
			ptBottomRightPoint(ptBottomRightPoint),
			Color(Color),
			bFilled(bFilled),
			fThickness(fThickness) {}

		/// <summary>
		/// Calculates the area of the rectangle.
		/// </summary>
		/// <returns>The rectangle area.</returns>
		AURORA_NDWR_PURE("Area") constexpr A_I64 Area() const noexcept { return AbsoluteN(ptTopLeftPoint.x - ptBottomRightPoint.x) * AbsoluteN(ptTopLeftPoint.y - ptBottomRightPoint.y); }
	};

	/// <summary>
	/// A quad polygon.
	/// </summary>
	struct Quad {
		Array<Point, 4> szptPoints; // An array of the points in the quad.
		RGBA Color; // The color of the quad.
		A_BOOL bFilled; // A bool that determines whether the quad shall be drawn as a solid or as an outline.
		A_FL32 fThickness; // The thickness of the quad borders.

		constexpr Quad() noexcept : szptPoints(), Color(), bFilled(false), fThickness(0) {}

		/// <summary>
		/// Constructs a Quad.
		/// </summary>
		/// <param name="ptPoint1">- The first point in the quad.</param>
		/// <param name="ptPoint2">- The second point in the quad.</param>
		/// <param name="ptPoint3">- The third point in the quad.</param>
		/// <param name="ptPoint4">- The fourth point in the quad.</param>
		/// <param name="Color">- The color of the quad.</param>
		/// <param name="bFilled">- A bool that determines whether the quad shall be drawn as a solid or as an outline.</param>
		/// <param name="fThickness">- The thickness of the quad borders.</param>
		constexpr Quad(
			_In_ const Point& ptPoint1,
			_In_ const Point& ptPoint2,
			_In_ const Point& ptPoint3,
			_In_ const Point& ptPoint4,
			_In_ const RGBA& Color,
			_In_ const A_BOOL bFilled = false,
			_In_ const A_FL32 fThickness = 1.0f
		) noexcept : szptPoints({ ptPoint1, ptPoint2, ptPoint3, ptPoint4 }),
			Color(Color),
			bFilled(bFilled),
			fThickness(fThickness) {}
	};

	/// <summary>
	/// A triangle between three points.
	/// </summary>
	struct Triangle {
		Array<Point, 3> szptPoints; // An array of the points in the triangle.
		RGBA Color; // The color of the triangle.
		A_BOOL bFilled; // A bool that determines whether the triangle shall be drawn as a solid or as an outline.
		A_FL32 fThickness; // The thickness of the triangle borders.

		constexpr Triangle() noexcept : szptPoints(), Color(), bFilled(false), fThickness(0) {}

		/// <summary>
		/// Constructs a Triangle.
		/// </summary>
		/// <param name="ptPoint1">- The first point in the triangle.</param>
		/// <param name="ptPoint2">- The second point in the triangle.</param>
		/// <param name="ptPoint3">- The third point in the triangle.</param>
		/// <param name="ptPoint4">- The fourth point in the triangle.</param>
		/// <param name="Color">- The color of the triangle.</param>
		/// <param name="bFilled">- A bool that determines whether the triangle shall be drawn as a solid or as an outline.</param>
		/// <param name="fThickness">- The thickness of the triangle borders.</param>
		constexpr Triangle(
			_In_ const Point& ptPoint1,
			_In_ const Point& ptPoint2,
			_In_ const Point& ptPoint3,
			_In_ const RGBA& Color,
			_In_ const A_BOOL bFilled = false,
			_In_ const A_FL32 fThickness = 1.0f
		) noexcept : szptPoints({ ptPoint1, ptPoint2, ptPoint3 }),
			Color(Color),
			bFilled(bFilled),
			fThickness(fThickness) {}

		/// <summary>
		/// Calculates whether the triangle has a right angle or not.
		/// </summary>
		/// <returns>True if the triangle is right angled, otherwise false.</returns>
		AURORA_NDWR_PURE("IsRightAngled") constexpr A_BOOL IsRightAngled() const noexcept {
			A_I32 nL12Sq = SquaredN(szptPoints[0].x - szptPoints[1].x) +  SquaredN(szptPoints[0].y - szptPoints[1].y);
			A_I32 nL13Sq = SquaredN(szptPoints[0].x - szptPoints[2].x) +  SquaredN(szptPoints[0].y - szptPoints[2].y);
			A_I32 nL23Sq = SquaredN(szptPoints[1].x - szptPoints[2].x) +  SquaredN(szptPoints[1].y - szptPoints[2].y);

			if (nL12Sq > nL13Sq && nL12Sq > nL23Sq && nL13Sq + nL23Sq == nL12Sq) return true;
			else if (nL13Sq > nL12Sq && nL13Sq > nL23Sq && nL12Sq + nL23Sq == nL13Sq) return true;
			else if (nL23Sq > nL12Sq && nL23Sq > nL13Sq && nL12Sq + nL13Sq == nL23Sq) return true;
			else return false;
		}

		/// <summary>
		/// Gets the length of a side in the triangle.
		/// </summary>
		/// <param name="nFirstPointIndex">- The index of the first point of the line.</param>
		/// <param name="nSecondPointIndex">- The index of the second point of the line.</param>
		/// <returns>The length of the side.</returns>
		AURORA_NDWR_PURE("GetSideLength") constexpr A_FL64 GetSideLength(_In_range_(0, 2) A_I32 nFirstPointIndex, _In_range_(0, 2) A_I32 nSecondPointIndex) const noexcept { return szptPoints[nFirstPointIndex].Distance(szptPoints[nSecondPointIndex]); }
	};

	struct Circle {
		Point ptCenterPoint; // The center point of the circle.
		A_I32 nRadius; // The radius of the circle.
		A_I32 nSegments; // The segment (slice) count of the circle.
		RGBA Color; // The color of the circle.
		A_BOOL bFilled; // A bool that determines whether the circle shall be drawn as a solid or as an outline.
		A_FL32 fThickness; // The thickness of the circle border.

		constexpr Circle() noexcept : ptCenterPoint(), nRadius(0), nSegments(0), Color(), bFilled(false), fThickness(0) {}

		/// <summary>
		/// Constructs a Circle.
		/// </summary>
		/// <param name="ptCenterPoint">- The center point of the circle.</param>
		/// <param name="nRadius">- The radius of the circle.</param>
		/// <param name="nSegments">- The segment (slice) count of the circle.</param>
		/// <param name="Color">- The color of the circle.</param>
		/// <param name="bFilled">- A bool that determines whether the circle shall be drawn as a solid or as an outline.</param>
		/// <param name="fThickness">- The thickness of the circle border.</param>
		constexpr Circle(
			_In_ const Point& ptCenterPoint,
			_In_ const A_I32 nRadius,
			_In_ const A_I32 nSegments,
			_In_ const RGBA& Color,
			_In_ const A_BOOL bFilled = false,
			_In_ const A_FL32 fThickness = 1.0f
		) noexcept : ptCenterPoint(ptCenterPoint),
			nRadius(nRadius),
			nSegments(nSegments),
			Color(Color),
			bFilled(bFilled),
			fThickness(fThickness) {}

		/// <summary>
		/// Calculates the area of the circle.
		/// </summary>
		/// <returns>The circle area.</returns>
		AURORA_NDWR_PURE("Area") constexpr A_FL64 Area() const noexcept { return Pi * Squared(nRadius); }

		/// <summary>
		/// Calculates the diameter of the circle.
		/// </summary>
		/// <returns>The circle diameter.</returns>
		AURORA_NDWR_PURE("Diameter") constexpr A_I32 Diameter() const noexcept { return nRadius * 2; }
	};
}

#endif // !__AURORA_SHAPES_H__
```

`Artemis/Aurora/SharedHandle.h`:

```h
//------------------------------------------------------------------------>
// MIT License
// 
// Copyright (c) 2023 Artemis Group
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------>
// Aurora: https://github.com/ArtemisDevGroup/Aurora
// This file was authored by:
// @Astrea0014: https://github.com/Astrea0014
//------------------------------------------------------------------------>

#ifndef __AURORA_SHARED_HANDLE_H__
#define __AURORA_SHARED_HANDLE_H__

#include "Definitions.h"
#include "Exceptions.h"

#include <Windows.h>
#undef CreateProcess

namespace Aurora {
	/// <summary>
	/// Desired access flags when opening a proces handle.
	/// </summary>
	struct ProcessAccessFlags {
		A_DWORD dwValue;

		enum Enumeration : A_DWORD {
			All = PROCESS_ALL_ACCESS,		// All possible access rights for a process object.
			Delete = DELETE,				// Required to delete the object.
			/// <summary>
			/// Required to read information in the security descriptor for the object, not including the information in the SACL.
			/// To read or write the SACL, you must request the ACCESS_SYSTEM_SECURITY access right.
			/// </summary>
			ReadControl = READ_CONTROL,
			Synchronize = SYNCHRONIZE,		// The right to use the object for synchronization. This enables a thread to wait until the object is in the signaled state.
			WriteDac = WRITE_DAC,			// Required to modify the DACL in the security descriptor for the object.
			WriteOwner = WRITE_OWNER,		// Required to change the owner in the security descriptor for the object.

			CreateProcess = PROCESS_CREATE_PROCESS,							// Required to use this process as the parent process with PROC_THREAD_ATTRIBUTE_PARENT_PROCESS.
			CreateThread = PROCESS_CREATE_THREAD,							// Required to create a thread in the process.
			DupHandle = PROCESS_DUP_HANDLE,									// Required to duplicate a handle using DuplicateHandle.
			QueryInformation = PROCESS_QUERY_INFORMATION,					// Required to retrieve certain information about a process, such as its token, exit code, and priority class.
			QueryLimitedInformation = PROCESS_QUERY_LIMITED_INFORMATION,	// Required to retrieve certain information about a process. A handle that has the PROCESS_QUERY_INFORMATION access right is automatically granted PROCESS_QUERY_LIMITED_INFORMATION.   
			SetInformation = PROCESS_SET_INFORMATION,						// Required to set certain information about a process, such as its priority class.
			SetQuota = PROCESS_SET_QUOTA,									// Required to set memory limits using SetProcessWorkingSetSize.
			SuspendResume = PROCESS_SUSPEND_RESUME,							// Required to suspend or resume a process.
			Terminate = PROCESS_TERMINATE,									// Required to terminate a process using TerminateProcess.
			VmOperation = PROCESS_VM_OPERATION,								// Required to perform an operation on the address space of a process (see VirtualProtectEx and WriteProcessMemory).
			VmRead = PROCESS_VM_READ,										// Required to read memory in a process using ReadProcessMemory.
			VmWrite = PROCESS_VM_WRITE,										// Required to write to memory in a process using WriteProcessMemory.
			Vm = PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE	// Includes access to all virtual memory operations.
		};

		constexpr ProcessAccessFlags() noexcept : dwValue(0) {}
		constexpr ProcessAccessFlags(A_DWORD dwValue) noexcept : dwValue(dwValue) {}

		operator A_DWORD& () noexcept { return dwValue; }
		constexpr operator const A_DWORD& () const noexcept { return dwValue; }
	};

	/// <summary>
	/// Opens a shared process handle.
	/// </summary>
	/// <param name="dwDesiredAccess">- The desired access to the process object.</param>
	/// <param name="bInheritHandle">- A bool that determines whether the handle is inheritable or not.</param>
	/// <param name="dwProcessId">- The id of the process.</param>
	/// <returns>A handle to the process.</returns>
	/// <exception cref="WindowsApiException"/>
	AURORA_NDWR_DISP("OpenSharedProcess") AURORA_API HANDLE OpenSharedProcess(_In_ ProcessAccessFlags dwDesiredAccess, _In_ A_BOOL bInheritHandle, _In_ A_DWORD dwProcessId);

	/// <summary>
	/// Closes a shared process handle.
	/// </summary>
	/// <param name="hProcess">- The shared process handle returned by 'OpenSharedProcess'.</param>
	AURORA_API A_VOID CloseSharedProcess(_In_ HANDLE hProcess);

	/// <summary>
	/// Duplicates the shared process handle.
	/// </summary>
	/// <param name="hProcess">-The shared process handle to duplicate.</param>
	/// <returns>The duplicated handle.</returns>
	AURORA_NDWR_DISP("DuplicateSharedProcess") AURORA_API HANDLE DuplicateSharedProcess(_In_ HANDLE hProcess);
}

#endif // !__AURORA_SHARED_HANDLE_H__
```

`Artemis/Aurora/Signal.h`:

```h
//------------------------------------------------------------------------>
// MIT License
// 
// Copyright (c) 2023 Artemis Group
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------>
// Aurora: https://github.com/ArtemisDevGroup/Aurora
// This file was authored by:
// @Astrea0014: https://github.com/Astrea0014
//------------------------------------------------------------------------>

#ifndef __AURORA_SIGNAL_H__
#define __AURORA_SIGNAL_H__

#include "Definitions.h"
#include "Exceptions.h"
#include "Events.h"

namespace Aurora {
	/// <summary>
	/// Represents a process signal.
	/// </summary>
	enum class Signal : A_I32 {
		Abort = 22,				// Abnormal termination.
		Float = 8,				// Floating-point error.
		SegmentViolation = 11,	// Illegal storage access.
		All = 0					// All handlers.
	};

	/// <summary>
	/// The event arguments for a signal event.
	/// </summary>
	class SignalEventArgs {
	public:
		Signal nSignal; // The signal handler that invoked the event.
	};

	/// <summary>
	/// Enables a library defined signal handler for the provided signal.
	/// </summary>
	/// <param name="nSignal">- The signal handler to enable.</param>
	/// <exception cref="ErrnoException"/>
	AURORA_API A_VOID EnableSignalHandler(_In_ Signal nSignal);

	/// <summary>
	/// Disables a library defined signal handler for the provided signal.
	/// </summary>
	/// <param name="nSignal">- The signal handler to disable.</param>
	/// <exception cref="ErrnoException"/>
	AURORA_API A_VOID DisableSignalHandler(_In_ Signal nSignal);

	/// <summary>
	/// Gets the event of a signal handler.
	/// </summary>
	/// <param name="nSignal">- The signal handler event to get.</param>
	/// <returns>The event of the specified signal handler.</returns>
	AURORA_NDWR_GET("GetSignalEvent") AURORA_API Event<SignalEventArgs>& GetSignalEvent(_In_ Signal nSignal) noexcept;
}

#endif // !__AURORA_SIGNAL_H__
```

`Artemis/Aurora/Thread.h`:

```h
//------------------------------------------------------------------------>
// MIT License
// 
// Copyright (c) 2023 Artemis Group
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------>
// Aurora: https://github.com/ArtemisDevGroup/Aurora
// This file was authored by:
// @Astrea0014: https://github.com/Astrea0014
//------------------------------------------------------------------------>

#ifndef __AURORA_THREAD_H__
#define __AURORA_THREAD_H__

#include "Definitions.h"
#include "Exceptions.h"

#include <Windows.h>

namespace Aurora {
	/// <summary>
	/// A thread exit code.
	/// </summary>
	enum class ExitCode : A_DWORD {
		Success = 0,					// The thread exited successfully.
		UnknownError = (A_DWORD)(-1),	// The thread exited due to one or more unknown errors.
		Terminated = (A_DWORD)(-2)		// The thread has been terminated.
	};

	/// <summary>
	/// The result of waiting for a thread..
	/// </summary>
	enum class WaitResult : A_DWORD {
		Succeeded = 0,		// The wait succeeded and the thread exited.
		Abandoned = 0x80,
		TimedOut = 258		// The wait timed out due to the thread not exiting before the wait timer expired.
	};

	/// <summary>
	/// A class for creating and managing a thread.
	/// </summary>
	/// <typeparam name="ArgumentType">- The type of the thread parameter.</typeparam>
	template<typename ArgumentType = void>
	class Thread {
	public:
		/// <summary>
		/// A function template for the function ran by the thread.
		/// </summary>
		using ThreadFunction = Function<ExitCode(ArgumentType Args)>;

	private:
		HANDLE hThread;
		A_DWORD dwThreadId;
		SECURITY_ATTRIBUTES SecurityAttributes;
		A_BOOL bSecurityAttributesActive;

		struct StaticThreadArgs {
			ThreadFunction lpfnThread;
			ArgumentType Args;
		} ArgStruct;

		static A_DWORD __stdcall StaticThread(_In_ StaticThreadArgs* pArgs) { return (A_DWORD)pArgs->lpfnThread(pArgs->Args); }

	public:
		/// <summary>
		/// Sets the fields necessary to start the thread.
		/// </summary>
		/// <param name="lpfnThread">- A pointer to the function to run in the thread.</param>
		/// <param name="lpSecurityAttributes">- A pointer to a security attributes structure specifying the security descriptor of the thread.</param>
		Thread(_In_ ThreadFunction lpfnThread, _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes = nullptr) noexcept : hThread(nullptr), dwThreadId(0) {
			ArgStruct.lpfnThread = lpfnThread;
			if (lpSecurityAttributes) {
				memcpy(&SecurityAttributes, lpSecurityAttributes, sizeof(SECURITY_ATTRIBUTES));
				bSecurityAttributesActive = true;
			}
			else bSecurityAttributesActive = false;
		}

		Thread(const Thread<ArgumentType>& cpy) {
			AuroraContextStart();

			ArgStruct.lpfnThread = cpy.ArgStruct.lpfnThread;
			ArgStruct.Args = cpy.ArgStruct.Args;
			SecurityAttributes = cpy.SecurityAttributes;

			if (!DuplicateHandle(
				GetCurrentProcess(),
				cpy.hThread,
				GetCurrentProcess(),
				&hThread,
				0,
				FALSE,
				DUPLICATE_SAME_ACCESS
			)) AuroraThrow(WindowsApiException, "DuplicateHandle");

			AuroraContextEnd();
		}

		~Thread() {
			if (hThread) {
				CloseHandle(hThread);
				hThread = nullptr;
			}
		}

		/// <summary>
		/// Starts the thread.
		/// </summary>
		/// <param name="Args">- The argument to pass to the thread.</param>
		/// <exception cref="WindowsApiException"/>
		A_VOID Start(_In_ ArgumentType Args) {
			AuroraContextStart();

			if (!hThread) {

				ArgStruct.Args = Args;

				hThread = CreateThread(
					bSecurityAttributesActive ? &SecurityAttributes : nullptr,
					0,
					(LPTHREAD_START_ROUTINE)StaticThread,
					&ArgStruct,
					0,
					&dwThreadId
				);

				if (!hThread) AuroraThrow(WindowsApiException, "CreateThread");
			}

			AuroraContextEnd();
		}

		/// <summary>
		/// Waits for the thread to finish executing.
		/// </summary>
		/// <param name="dwMilliseconds">- The number of milliseconds to wait before returning. Defaults to INFINITE.</param>
		/// <returns>The result of the wait operation.</returns>
		/// <exception cref="WindowsApiException"/>
		WaitResult Wait(_In_ A_DWORD dwMilliseconds = INFINITE) const {
			AuroraContextStart();

			A_DWORD dwResult = WaitForSingleObject(hThread, dwMilliseconds);
			if (dwResult == WAIT_FAILED) AuroraThrow(WindowsApiException, "WaitForSingleObject");

			AuroraContextEnd();
			return (WaitResult)dwResult;
		}

		/// <summary>
		/// Gets the exit code of the thread.
		/// </summary>
		/// <returns>The exit code of the thread.</returns>
		/// <exception cref="WindowsApiException"/>
		AURORA_NDWR_GET("GetExitCode") ExitCode GetExitCode() const {
			AuroraContextStart();

			A_DWORD dwResult;
			if (!GetExitCodeThread(hThread, &dwResult)) AuroraThrow(WindowsApiException, "GetExitCodeThread");

			AuroraContextEnd();
			return (ExitCode)dwResult;
		}

		/// <summary>
		/// Gets the id of the thread.
		/// </summary>
		/// <returns>The thread id.</returns>
		AURORA_NDWR_GET("GetThreadId") constexpr A_DWORD GetThreadId() const noexcept { return dwThreadId; }

		/// <summary>
		/// Terminates the thread.
		/// </summary>
		/// <exception cref="WindowsApiException"/>
		A_VOID Terminate() const {
			AuroraContextStart();

			if (!TerminateThread(hThread, (A_DWORD)ExitCode::Terminated)) AuroraThrow(WindowsApiException, "TerminateThread");

			AuroraContextEnd();
		}
	};

	/// <summary>
	/// A class for creating and managing a thread.
	/// </summary>
	/// <typeparam name="ArgumentType">- The type of the thread parameter.</typeparam>
	template<typename ArgumentType>
	class Thread<const ArgumentType&> {
	public:
		/// <summary>
		/// A function template for the function ran by the thread.
		/// </summary>
		using ThreadFunction = Function<ExitCode(const ArgumentType& refArgs)>;

	private:
		HANDLE hThread;
		A_DWORD dwThreadId;
		SECURITY_ATTRIBUTES SecurityAttributes;
		A_BOOL bSecurityAttributesActive;

		struct StaticThreadArgs {
			ThreadFunction lpfnThread;
			const ArgumentType* lpArgs;
		} ArgStruct;

		static A_DWORD __stdcall StaticThread(_In_ StaticThreadArgs* pArgs) { return (A_DWORD)pArgs->lpfnThread(*pArgs->lpArgs); }

	public:
		/// <summary>
		/// Sets the fields necessary to start the thread.
		/// </summary>
		/// <param name="lpfnThread">- A pointer to the function to run in the thread.</param>
		/// <param name="lpSecurityAttributes">- A pointer to a security attributes structure specifying the security descriptor of the thread.</param>
		Thread(_In_ ThreadFunction lpfnThread, _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes = nullptr) noexcept : hThread(nullptr), dwThreadId(0) {
			ArgStruct.lpfnThread = lpfnThread;
			if (lpSecurityAttributes) {
				memcpy(&SecurityAttributes, lpSecurityAttributes, sizeof(SECURITY_ATTRIBUTES));
				bSecurityAttributesActive = true;
			}
			else bSecurityAttributesActive = false;
		}

		Thread(const Thread<ArgumentType>& cpy) {
			AuroraContextStart();

			ArgStruct.lpfnThread = cpy.ArgStruct.lpfnThread;
			ArgStruct.lpArgs = cpy.ArgStruct.lpArgs;
			SecurityAttributes = cpy.SecurityAttributes;

			if (!DuplicateHandle(
				GetCurrentProcess(),
				cpy.hThread,
				GetCurrentProcess(),
				&hThread,
				0,
				FALSE,
				DUPLICATE_SAME_ACCESS
			)) AuroraThrow(WindowsApiException, "DuplicateHandle");

			AuroraContextEnd();
		}

		~Thread() {
			if (hThread) {
				CloseHandle(hThread);
				hThread = nullptr;
			}
		}

		/// <summary>
		/// Starts the thread.
		/// </summary>
		/// <param name="Args">- The argument to pass to the thread.</param>
		/// <exception cref="WindowsApiException"/>
		A_VOID Start(_In_ const ArgumentType& Args) {
			AuroraContextStart();

			if (!hThread) {

				ArgStruct.lpArgs = &Args;

				hThread = CreateThread(
					bSecurityAttributesActive ? &SecurityAttributes : nullptr,
					0,
					(LPTHREAD_START_ROUTINE)StaticThread,
					&ArgStruct,
					0,
					&dwThreadId
				);

				if (!hThread) AuroraThrow(WindowsApiException, "CreateThread");
			}

			AuroraContextEnd();
		}

		/// <summary>
		/// Waits for the thread to finish executing.
		/// </summary>
		/// <param name="dwMilliseconds">- The number of milliseconds to wait before returning. Defaults to INFINITE.</param>
		/// <returns>The result of the wait operation.</returns>
		/// <exception cref="WindowsApiException"/>
		WaitResult Wait(_In_ A_DWORD dwMilliseconds = INFINITE) const {
			AuroraContextStart();

			A_DWORD dwResult = WaitForSingleObject(hThread, dwMilliseconds);
			if (dwResult == WAIT_FAILED) AuroraThrow(WindowsApiException, "WaitForSingleObject");

			AuroraContextEnd();
			return (WaitResult)dwResult;
		}

		/// <summary>
		/// Gets the exit code of the thread.
		/// </summary>
		/// <returns>The exit code of the thread.</returns>
		/// <exception cref="WindowsApiException"/>
		AURORA_NDWR_GET("GetExitCode") ExitCode GetExitCode() const {
			AuroraContextStart();

			A_DWORD dwResult;
			if (!GetExitCodeThread(hThread, &dwResult)) AuroraThrow(WindowsApiException, "GetExitCodeThread");

			AuroraContextEnd();
			return (ExitCode)dwResult;
		}

		/// <summary>
		/// Gets the id of the thread.
		/// </summary>
		/// <returns>The thread id.</returns>
		AURORA_NDWR_GET("GetThreadId") constexpr A_DWORD GetThreadId() const noexcept { return dwThreadId; }

		/// <summary>
		/// Terminates the thread.
		/// </summary>
		/// <exception cref="WindowsApiException"/>
		A_VOID Terminate() const {
			AuroraContextStart();

			if (!TerminateThread(hThread, (A_DWORD)ExitCode::Terminated)) AuroraThrow(WindowsApiException, "TerminateThread");

			AuroraContextEnd();
		}
	};

	/// <summary>
	/// A class for creating and managing a thread.
	/// </summary>
	template<>
	class Thread<void> {
	public:
		/// <summary>
		/// A function template for the function ran by the thread.
		/// </summary>
		using ThreadFunction = Function<ExitCode()>;

	private:
		ThreadFunction lpfnThread;
		HANDLE hThread;
		A_DWORD dwThreadId;

		SECURITY_ATTRIBUTES SecurityAttributes;
		A_BOOL bSecurityAttributesActive;

		static A_DWORD __stdcall StaticThread(_In_ ThreadFunction* lpfnThread) { return (A_DWORD)((*lpfnThread)()); }

	public:
		/// <summary>
		/// Sets the fields necessary to start the thread.
		/// </summary>
		/// <param name="lpfnThread">- A pointer to the function to run in the thread.</param>
		/// <param name="lpSecurityAttributes">- A pointer to a security attributes structure specifying the security descriptor of the thread.</param>
		Thread(_In_ ThreadFunction lpfnThread, _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes = nullptr) noexcept : lpfnThread(lpfnThread), hThread(nullptr), dwThreadId(0), SecurityAttributes() {
			if (lpSecurityAttributes) {
				memcpy(&SecurityAttributes, lpSecurityAttributes, sizeof(SECURITY_ATTRIBUTES));
				bSecurityAttributesActive = true;
			}
			else bSecurityAttributesActive = false;
		}

		Thread(const Thread<>& cpy) {
			AuroraContextStart();

			lpfnThread = cpy.lpfnThread;
			SecurityAttributes = cpy.SecurityAttributes;

			if (!DuplicateHandle(
				GetCurrentProcess(),
				cpy.hThread,
				GetCurrentProcess(),
				&hThread,
				0,
				FALSE,
				DUPLICATE_SAME_ACCESS
			)) AuroraThrow(WindowsApiException, "DuplicateHandle");

			AuroraContextEnd();
		}

		~Thread() {
			if (hThread) {
				CloseHandle(hThread);
				hThread = nullptr;
			}
		}

		/// <summary>
		/// Starts the thread.
		/// </summary>
		/// <exception cref="WindowsApiException"/>
		A_VOID Start() {
			AuroraContextStart();

			if (!hThread) {
				hThread = CreateThread(
					nullptr,
					0,
					(LPTHREAD_START_ROUTINE)StaticThread,
					&lpfnThread,
					0,
					&dwThreadId
				);

				if (!hThread) AuroraThrow(WindowsApiException, "CreateThread");
			}

			AuroraContextEnd();
		}

		/// <summary>
		/// Waits for the thread to finish executing.
		/// </summary>
		/// <param name="dwMilliseconds">- The number of milliseconds to wait before returning. Defaults to INFINITE.</param>
		/// <returns>The result of the wait operation.</returns>
		/// <exception cref="WindowsApiException"/>
		WaitResult Wait(_In_ A_DWORD dwMilliseconds = INFINITE) const {
			AuroraContextStart();

			A_DWORD dwResult = WaitForSingleObject(hThread, dwMilliseconds);
			if (dwResult == WAIT_FAILED) AuroraThrow(WindowsApiException, "WaitForSingleObject");

			AuroraContextEnd();
			return (WaitResult)dwResult;
		}

		/// <summary>
		/// Gets the exit code of the thread.
		/// </summary>
		/// <returns>The exit code of the thread.</returns>
		/// <exception cref="WindowsApiException"/>
		AURORA_NDWR_GET("GetExitCode") ExitCode GetExitCode() const {
			AuroraContextStart();

			A_DWORD dwResult;
			if (!GetExitCodeThread(hThread, &dwResult)) AuroraThrow(WindowsApiException, "GetExitCodeThread");

			AuroraContextEnd();
			return (ExitCode)dwResult;
		}

		/// <summary>
		/// Gets the id of the thread.
		/// </summary>
		/// <returns>The thread id.</returns>
		AURORA_NDWR_GET("GetThreadId") constexpr A_DWORD GetThreadId() const noexcept { return dwThreadId; }

		/// <summary>
		/// Terminates the thread.
		/// </summary>
		/// <exception cref="WindowsApiException"/>
		A_VOID Terminate() const {
			AuroraContextStart();

#pragma warning(push)
#pragma warning(disable:6258)	// Using TerminateThread does not allow proper thread clean up.
								// Disregarded due to the use case of the function being in situations where no other options are available.
			if (!TerminateThread(hThread, (A_DWORD)ExitCode::Terminated)) AuroraThrow(WindowsApiException, "TerminateThread");
#pragma warning(pop)

			AuroraContextEnd();
		}
	};
}

#endif // !__AURORA_THREAD_H__
```

`Artemis/Aurora/Time.h`:

```h
 //------------------------------------------------------------------------>
// MIT License
// 
// Copyright (c) 2023 Artemis Group
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------>
// Aurora: https://github.com/ArtemisDevGroup/Aurora
// This file was authored by:
// @Astrea0014: https://github.com/Astrea0014
//------------------------------------------------------------------------>

#ifndef __AURORA_TIME_H__
#define __AURORA_TIME_H__

#include "Definitions.h"
#include "Exceptions.h"

namespace Aurora {
    /// <summary>
    /// Represents a moment in time.
    /// </summary>
    struct AURORA_API Time {
        A_WORD wYear;               // The year.
        A_WORD wMonth;              // An integral representation of a month ranging from 1 to 12 depending on the month.
        A_CHAR szMonthString[16];   // A string representation of a month.
        A_WORD wDayOfWeek;          // An integral representation of the day ranging from 1 to 7 depending on the weekday.
        A_CHAR szDayOfWeekString[16]; // A string representation of the weekday.
        A_WORD wDay;                // The day of the month.
        A_WORD wHour;               // The hour.
        A_WORD wMinute;             // The minute.
        A_WORD wSecond;             // The second.
        A_WORD wMilliseconds;       // The millisecond.

        /// <summary>
        /// Gets the current time dependent on the time zone of the local computer.
        /// </summary>
        /// <returns>The current local time.</returns>
        AURORA_NDWR_GET("GetLocal") static Time GetLocal() noexcept;

        /// <summary>
        /// Gets the system time (UTC).
        /// </summary>
        /// <returns>The current system time.</returns>
        AURORA_NDWR_GET("GetSystem") static Time GetSystem() noexcept;

        /// <summary>
        /// <para>Creates a string representation of the time depending on the format provided.</para>
        /// <para>The following format specifiers are valid:</para>
        /// <para>"%y" - The year.</para>
        /// <para>"%mo" / "%mz" - The month / its string representation.</para>
        /// <para>"%w" / "%wz" - The day of week / its string representation.</para>
        /// <para>"%d" - The day.</para>
        /// <para>"%h" - The hour.</para>
        /// <para>"%m" - The minute.</para>
        /// <para>"%s" - The second.</para>
        /// <para>"%ms" - The millisecond.</para>
        /// </summary>
        /// <param name="lpBuffer">- A pointer to a buffer to receive the formatted time.</param>
        /// <param name="dwSize">- The size of the buffer in elements.</param>
        /// <param name="lpFormat">- The format.</param>
        A_VOID FormatString(_Out_writes_z_(dwSize) A_LPSTR lpBuffer, _In_ A_DWORD dwSize, _In_z_ A_LPCSTR lpFormat) const;
        
        /// <summary>
        /// <para>Creates a string representation of the time depending on the format provided.</para>
        /// <para>The following format specifiers are valid:</para>
        /// <para>"%y" - The year.</para>
        /// <para>"%mo" / "%mz" - The month / its string representation.</para>
        /// <para>"%w" / "%wz" - The day of week / its string representation.</para>
        /// <para>"%d" - The day.</para>
        /// <para>"%h" - The hour.</para>
        /// <para>"%m" - The minute.</para>
        /// <para>"%s" - The second.</para>
        /// <para>"%ms" - The millisecond.</para>
        /// </summary>
        /// <typeparam name="nSize">- The size of the buffer in elements.</typeparam>
        /// <param name="lpBuffer">- A reference to a buffer to receive the formatted time.</param>
        /// <param name="lpFormat">- The format.</param>
        template<A_I32 nSize>
        A_VOID FormatString(_Out_writes_z_(nSize) A_CHAR(&lpBuffer)[nSize], _In_z_ A_LPCSTR lpFormat) const {
            FormatString(lpBuffer, nSize, lpFormat);
        }
    };
}

#endif // !__AURORA_TIME_H__
```

`Artemis/Aurora/Trampoline.h`:

```h
//------------------------------------------------------------------------>
// MIT License
// 
// Copyright (c) 2023 Artemis Group
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------>
// Aurora: https://github.com/ArtemisDevGroup/Aurora
// This file was authored by:
// @Astrea0014: https://github.com/Astrea0014
//------------------------------------------------------------------------>


#ifndef __AURORA_TRAMPOLINE_H__
#define __AURORA_TRAMPOLINE_H__

#include "Definitions.h"
#include "Array.h"
#include "ProcessInfo.h"

namespace Aurora {
	constexpr A_DWORD c_dwAllocationSize = 0x10000;							// The size of every trampoline allocation.
	constexpr A_DWORD c_dwPageSize = 0x80;									// The size of every trampoline page.
	constexpr A_DWORD c_dwPageCount = c_dwAllocationSize / c_dwPageSize;	// The number of trampoline pages available in the allocation.

	/// <summary>
	/// A descriptor for a trampoline instance.
	/// </summary>
	struct TrampolineDescriptor32 {
		A_I32 nPageIndex;
		A_I32 nPageCount;
		A_ADDR32 uTrampolineAddress;
		A_DWORD dwRequestedSize;
		A_DWORD dwTrampolineSize;
	};

	/// <summary>
	/// A descriptor for a trampoline instance.
	/// </summary>
	struct TrampolineDescriptor64 {
		A_I32 nPageIndex;
		A_I32 nPageCount;
		A_ADDR64 uTrampolineAddress;
		A_DWORD dwRequestedSize;
		A_DWORD dwTrampolineSize;
	};

	/// <summary>
	/// <para>Manages trampoline instances for a module.</para>
	/// <para>This class shares one allocated instance per module which means that you can create an infinite amount of instances without side effects</para>
	/// </summary>
	class AURORA_API TrampolineManager32 {
		A_DWORD dwProcessId;

	public:
		/// <summary>
		/// Constructs a TrampolineManager32 targetting a local process.
		/// </summary>
		TrampolineManager32() noexcept;

		/// <summary>
		/// Constructs a TrampolineManager32 targetting a remote process.
		/// </summary>
		/// <param name="refProcessInfo">- A reference to the target process.</param>
		TrampolineManager32(_In_ const ProcessInfo32& refProcessInfo) noexcept;

		/// <summary>
		/// Creates a new trampoline.
		/// </summary>
		/// <param name="dwCodeSize">- The trampoline size.</param>
		/// <returns>A pointer to the newly created trampoline descriptor.</returns><
		/// <exception cref="WindowsApiException"/>
		/// <exception cref="ResourceException"/>
		AURORA_NDWR_DISP("CreateTrampoline") _Ret_valid_ TrampolineDescriptor32* CreateTrampoline(_In_ A_DWORD dwCodeSize) const;

		/// <summary>
		/// Releases a previously created trampoline.
		/// </summary>
		/// <param name="lpTrampolineDescriptor">- A pointer to the trampoline descriptor to release.</param>
		/// <exception cref="WindowsApiException"/>
		A_VOID ReleaseTrampoline(_In_ const TrampolineDescriptor32* lpTrampolineDescriptor) const;
	};

	/// <summary>
	/// <para>Manages trampoline instances for a module.</para>
	/// <para>This class shares one allocated instance per module which means that you can create an infinite amount of instances without side effects</para>
	/// </summary>
	class AURORA_API TrampolineManager64 {
		A_DWORD dwProcessId;

	public:
		/// <summary>
		/// Constructs a TrampolineManager64 targetting the current process.
		/// </summary>
		TrampolineManager64() noexcept;

		/// <summary>
		/// Constructs a TrampolineManager64 targetting a remote process.
		/// </summary>
		/// <param name="refProcessInfo">- A reference to the target process.</param>
		TrampolineManager64(_In_ const ProcessInfo64& refProcessInfo) noexcept;

		/// <summary>
		/// Creates a new trampoline.
		/// </summary>
		/// <param name="dwCodeSize">- The trampoline size.</param>
		/// <returns>A pointer to the newly created trampoline descriptor.</returns>
		/// <exception cref="WindowsApiException"/>
		/// <exception cref="ResourceException"/>
		AURORA_NDWR_DISP("CreateTrampoline") _Ret_valid_ TrampolineDescriptor64* CreateTrampoline(_In_ A_DWORD dwCodeSize) const;

		/// <summary>
		/// Releases a previously created trampoline.
		/// </summary>
		/// <param name="lpTrampolineDescriptor">- A pointer to the trampoline descriptor to release.</param>
		/// <exception cref="WindowsApiException"/>
		A_VOID ReleaseTrampoline(_In_ const TrampolineDescriptor64* lpTrampolineDescriptor) const;
	};

#ifdef _WIN64
	/// <summary>
	/// A descriptor for a trampoline instance.
	/// </summary>
	using TrampolineDescriptor = TrampolineDescriptor64;

	/// <summary>
	/// <para>Manages trampoline instances for a module.</para>
	/// <para>This class shares one allocated instance per module which means that you can create an infinite amount of instances without side effects</para>
	/// </summary>
	using TrampolineManager = TrampolineManager64;
#else
	/// <summary>
	/// A descriptor for a trampoline instance.
	/// </summary>
	using TrampolineDescriptor = TrampolineDescriptor32;

	/// <summary>
	/// <para>Manages trampoline instances for a module.</para>
	/// <para>This class shares one allocated instance per module which means that you can create an infinite amount of instances without side effects</para>
	/// </summary>
	using TrampolineManager = TrampolineManager32;
#endif
}

#endif // !__AURORA_TRAMPOLINE_H__
```

`Artemis/Aurora/Vector.h`:

```h
//------------------------------------------------------------------------>
// MIT License
// 
// Copyright (c) 2023 Artemis Group
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------>
// Aurora: https://github.com/ArtemisDevGroup/Aurora
// This file was authored by:
// @Astrea0014: https://github.com/Astrea0014
//------------------------------------------------------------------------>

#ifndef __AURORA_VECTOR_H__
#define __AURORA_VECTOR_H__

#include "Definitions.h"

namespace Aurora {
	/// <summary>
	/// A class for storing for example two-dimensional coordinates.
	/// </summary>
	/// <typeparam name="T">The type of elements to store.</typeparam>
	template<ArithmeticType T = A_FL32>
	struct Vector2 {
		T szVector[2]; // The core array holding the values.

		constexpr Vector2() noexcept : szVector() {}

		/// <summary>
		/// Constructs a vector object setting all elements in the array to the provided element.
		/// </summary>
		/// <param name="n">- The element to set.</param>
		constexpr Vector2(_In_ const T& n) noexcept {
			szVector[0] = n;
			szVector[1] = n;
		}

		/// <summary>
		/// Constructs a vector and initializes the array.
		/// </summary>
		/// <param name="x">- The first value of the vector.</param>
		/// <param name="y">- The second value of the vector.</param>
		constexpr Vector2(_In_ const T& x, _In_ const T& y) noexcept {
			szVector[0] = x;
			szVector[1] = y;
		}

		/// <summary>
		/// Gets a reference to the X slot in the vector.
		/// </summary>
		/// <returns>A reference to X.</returns>
		constexpr _Check_return_ T& X() noexcept { return szVector[0]; }

		/// <summary>
		/// Gets the value of the X slot in the vector.
		/// </summary>
		/// <returns>The value of X.</returns>
		constexpr _Check_return_ const T& X() const noexcept { return szVector[0]; }

		/// <summary>
		/// Gets a reference to the Y slot in the vector.
		/// </summary>
		/// <returns>A reference to Y.</returns>
		constexpr _Check_return_ T& Y() noexcept { return szVector[1]; }

		/// <summary>
		/// Gets the value of the Y slot in the vector.
		/// </summary>
		/// <returns>The value of Y.</returns>
		constexpr _Check_return_ const T& Y() const noexcept { return szVector[1]; }

		/// <summary>
		/// Performs a dot calculation on the current vector and the referenced vector.
		/// </summary>
		/// <param name="v">- The second vector to perform the dot operation with.</param>
		/// <returns>The dot value.</returns>
		constexpr _Check_return_ T Dot(_In_ const Vector2<T>& v) const noexcept { return X() * v.X() + Y() * v.Y(); }

		constexpr _Check_return_ T& operator[](int i) noexcept { return szVector[i]; }
		constexpr _Check_return_ const T& operator[](int i) const noexcept { return szVector[i]; }

		constexpr _Check_return_ Vector2<T> operator+(const Vector2<T>& Right) const noexcept {
			return Vector2<T>(
				szVector[0] + Right.X(),
				szVector[1] + Right.Y()
				);
		}
		constexpr _Check_return_ Vector2<T> operator-(const Vector2<T>& Right) const noexcept {
			return Vector2<T>(
				szVector[0] - Right.X(),
				szVector[1] - Right.Y()
				);
		}
		constexpr _Check_return_ Vector2<T> operator*(const Vector2<T>& Right) const noexcept {
			return Vector2<T>(
				szVector[0] * Right.X(),
				szVector[1] * Right.Y()
				);
		}
		constexpr _Check_return_ Vector2<T> operator/(const Vector2<T>& Right) const noexcept {
			return Vector2<T>(
				szVector[0] / Right.X(),
				szVector[1] / Right.Y()
				);
		}
		constexpr void operator+=(const Vector2<T>& Right) noexcept {
			szVector[0] += Right.X();
			szVector[1] += Right.Y();
		}
		constexpr void operator-=(const Vector2<T>& Right) noexcept {
			szVector[0] -= Right.X();
			szVector[1] -= Right.Y();
		}
		constexpr void operator*=(const Vector2<T>& Right) noexcept {
			szVector[0] *= Right.X();
			szVector[1] *= Right.Y();
		}
		constexpr void operator/=(const Vector2<T>& Right) noexcept {
			szVector[0] /= Right.X();
			szVector[1] /= Right.Y();
		}

		constexpr operator T* () noexcept { return szVector; }
		constexpr operator const T* () const noexcept { return szVector; }
	};

	/// <summary>
	/// A class for storing for example three-dimensional coordinates or RGB color.
	/// </summary>
	/// <typeparam name="T">The type of elements to store.</typeparam>
	template<ArithmeticType T = A_FL32>
	struct Vector3 {
		T szVector[3]; // The core array holding the values.

		constexpr Vector3() noexcept : szVector() {}

		/// <summary>
		/// Constructs a vector object setting all elements in the array to the provided element.
		/// </summary>
		/// <param name="n">- The element to set.</param>
		constexpr Vector3(_In_ const T& n) noexcept {
			szVector[0] = n;
			szVector[1] = n;
			szVector[2] = n;
		}

		/// <summary>
		/// Constructs a vector and initializes the array.
		/// </summary>
		/// <param name="x">- The first value of the vector.</param>
		/// <param name="y">- The second value of the vector.</param>
		/// <param name="z">- The third value of the vector.</param>
		constexpr Vector3(_In_ const T& x, _In_ const T& y, _In_ const T& z) noexcept {
			szVector[0] = x;
			szVector[1] = y;
			szVector[2] = z;
		}

		/// <summary>
		/// Gets a reference to the X slot in the vector.
		/// </summary>
		/// <returns>A reference to X.</returns>
		constexpr _Check_return_ T& X() noexcept { return szVector[0]; }

		/// <summary>
		/// Gets the value of the X slot in the vector.
		/// </summary>
		/// <returns>The value of X.</returns>
		constexpr _Check_return_ T X() const noexcept { return szVector[0]; }

		/// <summary>
		/// Gets a reference to the Y slot in the vector.
		/// </summary>
		/// <returns>A reference to Y.</returns>
		constexpr _Check_return_ T& Y() noexcept { return szVector[1]; }

		/// <summary>
		/// Gets the value of the Y slot in the vector.
		/// </summary>
		/// <returns>The value of Y.</returns>
		constexpr _Check_return_ T Y() const noexcept { return szVector[1]; }

		/// <summary>
		/// Gets a reference to the Z slot in the vector.
		/// </summary>
		/// <returns>A reference to Z.</returns>
		constexpr _Check_return_ T& Z() noexcept { return szVector[2]; }

		/// <summary>
		/// Gets the value of the Z slot in the vector.
		/// </summary>
		/// <returns>The value of Z.</returns>
		constexpr _Check_return_ T Z() const noexcept { return szVector[2]; }

		/// <summary>
		/// Performs a dot calculation on the current vector and the referenced vector.
		/// </summary>
		/// <param name="v">- The second vector to perform the dot operation with.</param>
		/// <returns>The dot value.</returns>
		constexpr _Check_return_ T Dot(_In_ const Vector3<T>& v) const noexcept { return X() * v.X() + Y() * v.Y() + Z() * v.Z(); }

		constexpr _Check_return_ T& operator[](int i) noexcept { return szVector[i]; }
		constexpr _Check_return_ const T& operator[](int i) const noexcept { return szVector[i]; }

		constexpr _Check_return_ Vector3<T> operator+(const Vector3<T>& Right) const noexcept {
			return Vector3<T>(
				szVector[0] + Right.X(),
				szVector[1] + Right.Y(),
				szVector[2] + Right.Z()
				);
		}
		constexpr _Check_return_ Vector3<T> operator-(const Vector3<T>& Right) const noexcept {
			return Vector3<T>(
				szVector[0] - Right.X(),
				szVector[1] - Right.Y(),
				szVector[2] - Right.Z()
				);
		}
		constexpr _Check_return_ Vector3<T> operator*(const Vector3<T>& Right) const noexcept {
			return Vector3<T>(
				szVector[0] * Right.X(),
				szVector[1] * Right.Y(),
				szVector[2] * Right.Z()
				);
		}
		constexpr _Check_return_ Vector3<T> operator/(const Vector3<T>& Right) const noexcept {
			return Vector3<T>(
				szVector[0] / Right.X(),
				szVector[1] / Right.Y(),
				szVector[2] / Right.Z()
				);
		}
		constexpr void operator+=(const Vector3<T>& Right) noexcept {
			szVector[0] += Right.X();
			szVector[1] += Right.Y();
			szVector[2] += Right.Z();
		}
		constexpr void operator-=(const Vector3<T>& Right) noexcept {
			szVector[0] -= Right.X();
			szVector[1] -= Right.Y();
			szVector[2] -= Right.Z();
		}
		constexpr void operator*=(const Vector3<T>& Right) noexcept {
			szVector[0] *= Right.X();
			szVector[1] *= Right.Y();
			szVector[2] *= Right.Z();
		}
		constexpr void operator/=(const Vector3<T>& Right) noexcept {
			szVector[0] /= Right.X();
			szVector[1] /= Right.Y();
			szVector[2] /= Right.Z();
		}
		constexpr operator T* () noexcept { return szVector; }
		constexpr operator const T* () const noexcept { return szVector; }
	};

	/// <summary>
	/// A class for storing for example quaternions or RGBA color.
	/// </summary>
	/// <typeparam name="T"></typeparam>
	template<ArithmeticType T = A_FL32>
	struct Vector4 {
		T szVector[4]; // The core array holding the values.

		constexpr Vector4() noexcept : szVector() {}

		/// <summary>
		/// Constructs a vector object setting all elements in the array to the provided element.
		/// </summary>
		/// <param name="n">- The element to set.</param>
		constexpr Vector4(_In_ const T& n) noexcept {
			szVector[0] = n;
			szVector[1] = n;
			szVector[2] = n;
			szVector[3] = n;
		}

		/// <summary>
		/// Constructs a vector and initializes the array.
		/// </summary>
		/// <param name="x">- The first value of the vector.</param>
		/// <param name="y">- The second value of the vector.</param>
		/// <param name="z">- The third value of the vector.</param>
		/// <param name="w">- The fourth value of the vector.</param>
		constexpr Vector4(_In_ const T& x, _In_ const T& y, _In_ const T& z, _In_ const T& w) noexcept {
			szVector[0] = x;
			szVector[1] = y;
			szVector[2] = z;
			szVector[3] = w;
		}

		/// <summary>
		/// Gets a reference to the X slot in the vector.
		/// </summary>
		/// <returns>A reference to X.</returns>
		constexpr _Check_return_ T& X() noexcept { return szVector[0]; }

		/// <summary>
		/// Gets the value of the X slot in the vector.
		/// </summary>
		/// <returns>The value of X.</returns>
		constexpr _Check_return_ const T& X() const noexcept { return szVector[0]; }

		/// <summary>
		/// Gets a reference to the Y slot in the vector.
		/// </summary>
		/// <returns>A reference to Y.</returns>
		constexpr _Check_return_ T& Y() noexcept { return szVector[1]; }

		/// <summary>
		/// Gets the value of the Y slot in the vector.
		/// </summary>
		/// <returns>The value of Y.</returns>
		constexpr _Check_return_ const T& Y() const noexcept { return szVector[1]; }

		/// <summary>
		/// Gets a reference to the Z slot in the vector.
		/// </summary>
		/// <returns>A reference to Z.</returns>
		constexpr _Check_return_ T& Z() noexcept { return szVector[2]; }

		/// <summary>
		/// Gets the value of the Z slot in the vector.
		/// </summary>
		/// <returns>The value of Z.</returns>
		constexpr _Check_return_ const T& Z() const noexcept { return szVector[2]; }

		/// <summary>
		/// Gets a reference to the W slot in the vector.
		/// </summary>
		/// <returns>A reference to W.</returns>
		constexpr _Check_return_ T& W() noexcept { return szVector[3]; }

		/// <summary>
		/// Gets the value of the W slot in the vector.
		/// </summary>
		/// <returns>The value of W.</returns>
		constexpr _Check_return_ const T& W() const noexcept { return szVector[3]; }

		/// <summary>
		/// Performs a dot calculation on the current vector and the referenced vector.
		/// </summary>
		/// <param name="v">- The second vector to perform the dot operation with.</param>
		/// <returns>The dot value.</returns>
		constexpr _Check_return_ T Dot(_In_ const Vector4<T>& v) const noexcept { return X() * v.X() + Y() * v.Y() + Z() * v.Z() + W() * v.W(); }

		constexpr _Check_return_ T& operator[](int i) noexcept { return szVector[i]; }
		constexpr _Check_return_ const T& operator[](int i) const noexcept { return szVector[i]; }

		constexpr _Check_return_ Vector4<T> operator+(const Vector4<T>& Right) const noexcept {
			return Vector4<T>(
				szVector[0] + Right.X(),
				szVector[1] + Right.Y(),
				szVector[2] + Right.Z(),
				szVector[3] + Right.W()
				);
		}
		constexpr _Check_return_ Vector4<T> operator-(const Vector4<T>& Right) const noexcept {
			return Vector4<T>(
				szVector[0] - Right.X(),
				szVector[1] - Right.Y(),
				szVector[2] - Right.Z(),
				szVector[3] - Right.W()
				);
		}
		constexpr _Check_return_ Vector4<T> operator*(const Vector4<T>& Right) const noexcept {
			return Vector4<T>(
				szVector[0] * Right.X(),
				szVector[1] * Right.Y(),
				szVector[2] * Right.Z(),
				szVector[3] * Right.W()
				);
		}
		constexpr _Check_return_ Vector4<T> operator/(const Vector4<T>& Right) const noexcept {
			return Vector4<T>(
				szVector[0] / Right.X(),
				szVector[1] / Right.Y(),
				szVector[2] / Right.Z(),
				szVector[3] / Right.W()
				);
		}
		constexpr void operator+=(const Vector4<T>& Right) noexcept {
			szVector[0] += Right.X();
			szVector[1] += Right.Y();
			szVector[2] += Right.Z();
			szVector[3] += Right.W();
		}
		constexpr void operator-=(const Vector4<T>& Right) noexcept {
			szVector[0] -= Right.X();
			szVector[1] -= Right.Y();
			szVector[2] -= Right.Z();
			szVector[3] -= Right.W();
		}
		constexpr void operator*=(const Vector4<T>& Right) noexcept {
			szVector[0] *= Right.X();
			szVector[1] *= Right.Y();
			szVector[2] *= Right.Z();
			szVector[3] *= Right.W();
		}
		constexpr void operator/=(const Vector4<T>& Right) noexcept {
			szVector[0] /= Right.X();
			szVector[1] /= Right.Y();
			szVector[2] /= Right.Z();
			szVector[3] /= Right.W();
		}
		constexpr operator T* () noexcept { return szVector; }
		constexpr operator const T* () const noexcept { return szVector; }
	};
}

#endif // !__AURORA_VECTOR_H__
```

`Artemis/Constants.h`:

```h
#ifndef __ARTEMIS_ENGINE_CONSTANTS_H__
#define __ARTEMIS_ENGINE_CONSTANTS_H__

#include <Aurora/Definitions.h>

#include "Definitions.h"

namespace Artemis::Engine::Constants {
	constexpr A_U32 c_uGameManagerOffset = 0x6E3FF30;

	constexpr A_U8 c_uGameStateOffset = 0x50;
}

#endif // !__ARTEMIS_ENGINE_CONSTANTS_H__
```

`Artemis/Definitions.h`:

```h
#ifndef __ARTEMIS_DEFINITIONS_H__
#define __ARTEMIS_DEFINITIONS_H__

#define ARTEMIS_IMPORT __declspec(dllimport)
#define ARTEMIS_EXPORT __declspec(dllexport)

#ifdef _ARTEMIS_EXPORT
#define ARTEMIS_API ARTEMIS_EXPORT
#else
#define ARTEMIS_API ARTEMIS_IMPORT
#endif // _ARTEMIS_EXPORT

#define INVALID_INDEX (-1)

#endif // !__ARTEMIS_DEFINITIONS_H__
```

`Artemis/DrawManager.cpp`:

```cpp
#include "pch.h"
#include "DrawManager.h"

namespace Artemis {
	namespace Helpers {
		ImVec2 PointToImVec2(_In_ const Aurora::Point& refPoint) noexcept {
			return ImVec2(static_cast<float>(refPoint.x), static_cast<float>(refPoint.y));
		}

		constexpr ImU32 RGBAToU32(_In_ const Aurora::RGBA& refColor) noexcept {
			ImU32 uRet = 0;
			ImU8* pBytes = (ImU8*)&uRet;
			pBytes[0] = static_cast<ImU8>(refColor.fR);
			pBytes[1] = static_cast<ImU8>(refColor.fG);
			pBytes[2] = static_cast<ImU8>(refColor.fB);
			pBytes[3] = static_cast<ImU8>(refColor.fA);

			return uRet;
		}
	}

	void IDraw::AddDraw(_In_ const Aurora::Line& refLine) {
		pDrawList->AddLine(
			Helpers::PointToImVec2(refLine.szptPoints[0]),
			Helpers::PointToImVec2(refLine.szptPoints[1]),
			Helpers::RGBAToU32(refLine.Color),
			refLine.fThickness
		);
	}

	void IDraw::AddDraw(_In_ const Aurora::Rectangle& refRectangle) {
		if (refRectangle.bFilled) {
			pDrawList->AddRectFilled(
				Helpers::PointToImVec2(refRectangle.ptTopLeftPoint),
				Helpers::PointToImVec2(refRectangle.ptBottomRightPoint),
				Helpers::RGBAToU32(refRectangle.Color),
				0.0F,
				ImDrawCornerFlags_All
			);
		}
		else {
			pDrawList->AddRect(
				Helpers::PointToImVec2(refRectangle.ptTopLeftPoint),
				Helpers::PointToImVec2(refRectangle.ptBottomRightPoint),
				Helpers::RGBAToU32(refRectangle.Color),
				0.0F,
				ImDrawCornerFlags_All,
				refRectangle.fThickness
			);
		}
	}

	void IDraw::AddDraw(_In_ const Aurora::Quad& refQuad) {
		if (refQuad.bFilled) {
			pDrawList->AddQuadFilled(
				Helpers::PointToImVec2(refQuad.szptPoints[0]),
				Helpers::PointToImVec2(refQuad.szptPoints[1]),
				Helpers::PointToImVec2(refQuad.szptPoints[2]),
				Helpers::PointToImVec2(refQuad.szptPoints[3]),
				Helpers::RGBAToU32(refQuad.Color)
			);
		}
		else {
			pDrawList->AddQuad(
				Helpers::PointToImVec2(refQuad.szptPoints[0]),
				Helpers::PointToImVec2(refQuad.szptPoints[1]),
				Helpers::PointToImVec2(refQuad.szptPoints[2]),
				Helpers::PointToImVec2(refQuad.szptPoints[3]),
				Helpers::RGBAToU32(refQuad.Color),
				refQuad.fThickness
			);
		}
	}

	void IDraw::AddDraw(_In_ const Aurora::Triangle& refTriangle) {
		if (refTriangle.bFilled) {
			pDrawList->AddTriangleFilled(
				Helpers::PointToImVec2(refTriangle.szptPoints[0]),
				Helpers::PointToImVec2(refTriangle.szptPoints[1]),
				Helpers::PointToImVec2(refTriangle.szptPoints[2]),
				Helpers::RGBAToU32(refTriangle.Color)
			);
		}
		else {
			pDrawList->AddTriangle(
				Helpers::PointToImVec2(refTriangle.szptPoints[0]),
				Helpers::PointToImVec2(refTriangle.szptPoints[1]),
				Helpers::PointToImVec2(refTriangle.szptPoints[2]),
				Helpers::RGBAToU32(refTriangle.Color),
				refTriangle.fThickness
			);
		}
	}

	void IDraw::AddDraw(_In_ const Aurora::Circle& refCircle) {
		if (refCircle.bFilled) {
			pDrawList->AddCircleFilled(
				Helpers::PointToImVec2(refCircle.ptCenterPoint),
				static_cast<float>(refCircle.nRadius),
				Helpers::RGBAToU32(refCircle.Color),
				refCircle.nSegments
			);
		}
		else {
			pDrawList->AddCircle(
				Helpers::PointToImVec2(refCircle.ptCenterPoint),
				static_cast<float>(refCircle.nRadius),
				Helpers::RGBAToU32(refCircle.Color),
				refCircle.nSegments,
				refCircle.fThickness
			);
		}
	}

	void IDraw::AddDraw(_In_ const Aurora::PolyLine<>& refPolyLine) {
		ImVec2* v = new ImVec2[refPolyLine.szptPoints.size()];

		for (int i = 0; i < refPolyLine.szptPoints.size(); i++)
			v[i] = Helpers::PointToImVec2(refPolyLine.szptPoints[i]);

		pDrawList->AddPolyline(
			v,
			refPolyLine.szptPoints.size(),
			Helpers::RGBAToU32(refPolyLine.Color),
			false,
			refPolyLine.fThickness
		);

		delete[] v;
	}

	constexpr IDraw::IDraw(bool bForeground) noexcept : bForeground(bForeground) {}

	constexpr bool IDraw::IsForeground() const noexcept { return bForeground; }

	void IDraw::Present(_Inout_ ImDrawList* pDrawList) {
		this->pDrawList = pDrawList;
		Draw();
	}

	void DrawManager::PresentAll(_Inout_ ImDrawList* pForegroundDrawList, _Inout_ ImDrawList* pBackgroundDrawList) {
		for (IDraw* pDraw : InvocableCollection)
			if (pDraw)
				pDraw->Present(pDraw->IsForeground() ? pForegroundDrawList : pBackgroundDrawList);
	}

	DrawManagerCollection::DrawManagerCollection() { ZeroMemory(DrawManagerArray, sizeof(DrawManagerArray)); }

	DrawManagerCollection::~DrawManagerCollection() { this->Release(); }

	DrawManagerIndex DrawManagerCollection::AddNew() {
		for (DrawManagerIndex i = 0; i < MAX_INVOKE; i++)
			if (!DrawManagerArray[i]) {
				DrawManagerArray[i] = new DrawManager();
				return i;
			}
		return INVALID_INDEX;
	}

	void DrawManagerCollection::Release(_In_range_(INVALID_INDEX, MAX_INVOKE) DrawManagerIndex nIndex) {
		if (nIndex == INVALID_INDEX) {
			for (DrawManager* pDrawManager : DrawManagerArray)
				if (pDrawManager)
					delete pDrawManager;
			memset(DrawManagerArray, 0, sizeof(DrawManagerArray));
		}
		else if (DrawManagerArray[nIndex]) {
			delete DrawManagerArray[nIndex];
			DrawManagerArray[nIndex] = nullptr;
		}
	}

	_Ret_maybenull_ DrawManager* DrawManagerCollection::Get(_In_range_(0, MAX_INVOKE) DrawManagerIndex nIndex) {
		if (nIndex > 64 || nIndex < 0) return nullptr;
		return DrawManagerArray[nIndex];
	}

	void DrawManagerCollection::PresentAll(_Inout_ ImDrawList* pForegroundDrawList, _Inout_ ImDrawList* pBackgroundDrawList) {
		for (DrawManager* pDrawManager : DrawManagerArray)
			if (pDrawManager)
				pDrawManager->PresentAll(pForegroundDrawList, pBackgroundDrawList);
	}
}
```

`Artemis/DrawManager.h`:

```h
#ifndef __ARTEMIS_DRAW_MANAGER_H__
#define __ARTEMIS_DRAW_MANAGER_H__

#include <Aurora/Shapes.h>
#include <ImGui/imgui.h>

#include "Definitions.h"
#include "Manager.h"

namespace Artemis {
	namespace Helpers {
		ImVec2 PointToImVec2(_In_ const Aurora::Point& refPoint) noexcept;
		constexpr ImU32 RGBAToU32(_In_ const Aurora::RGBA& refColor) noexcept;
	}

	class IDraw {
		ImDrawList* pDrawList;
		bool bForeground;

	protected:
		void AddDraw(_In_ const Aurora::Line& refLine);
		void AddDraw(_In_ const Aurora::Rectangle& refRectangle);
		void AddDraw(_In_ const Aurora::Quad& refQuad);
		void AddDraw(_In_ const Aurora::Triangle& refTriangle);
		void AddDraw(_In_ const Aurora::Circle& refCircle);
		void AddDraw(_In_ const Aurora::PolyLine<>& refPolyLine);
		
		template<int nPointCount>
		inline void AddDraw(_In_ const Aurora::PolyLine<nPointCount>& refPolyLine) {
			ImVec2 v[nPointCount];
			
			for (int i = 0; i < nPointCount; i++)
				v[i] = Helpers::PointToImVec2(refPolyLine.szptPoints[i]);

			pDrawList->AddPolyline(
				v,
				nPointCount,
				Helpers::RGBAToU32(refPolyLine.Color),
				false,
				refPolyLine.fThickness
			);
		}

	public:
		constexpr IDraw(_In_ bool bForeground = true) noexcept;

		constexpr bool IsForeground() const noexcept;

		virtual void Draw() = 0;

		void Present(_Inout_ ImDrawList* pDrawList);
	};

	using DrawIndex = int;

#ifdef _ARTEMIS_EXPORT
	extern template class Manager<IDraw, DrawIndex>;
#else
	template class ARTEMIS_IMPORT Manager<IDraw, DrawIndex>;
#endif // _ARTEMIS_EXPORT

	class DrawManager : public Manager<IDraw, DrawIndex> {
	public:
		void PresentAll(_Inout_ ImDrawList* pForegroundDrawList, _Inout_ ImDrawList* pBackgroundDrawList);
	};

	using DrawManagerIndex = int;

	class DrawManagerCollection {
		DrawManager* DrawManagerArray[MAX_INVOKE];

	public:
		DrawManagerCollection();
		~DrawManagerCollection();

		DrawManagerIndex AddNew();

		void Release(_In_range_(INVALID_INDEX, MAX_INVOKE) DrawManagerIndex nIndex = INVALID_INDEX);

		_Ret_maybenull_ DrawManager* Get(_In_range_(0, MAX_INVOKE) DrawManagerIndex nIndex);

		void PresentAll(_Inout_ ImDrawList* pForegroundDrawList, _Inout_ ImDrawList* pBackgroundDrawList);
	};
}

#endif // !__ARTEMIS_DRAW_MANAGER_H__
```

`Artemis/EventEntries.cpp`:

```cpp
#include "pch.h"
#include "EventEntries.h"
#include "Events.h"

#include "GameManager.h"

static Artemis::Engine::GameManager GameManager(Aurora::GetCurrentProcessInfo().GetModule());
static Artemis::Engine::GameState LastGameState = Artemis::Engine::GameState::MainMenu;

bool EnterMainMenuEventEntry::Condition() {
	Artemis::Engine::GameState GameState = GameManager.GetGameState();
	bool bCondition = GameState != LastGameState && GameState == Artemis::Engine::GameState::MainMenu;
	LastGameState = GameState;
	return bCondition;
}

void EnterMainMenuEventEntry::Invoke() {
	Artemis::Engine::Events::EnterMainMenuEventArgs e;
	Artemis::Engine::Events::EnterMainMenuEvent.Invoke(this, &e);
}

bool EnterCustomGameLobbyEventEntry::Condition() {
	Artemis::Engine::GameState GameState = GameManager.GetGameState();
	bool bCondition = GameState != LastGameState && GameState == Artemis::Engine::GameState::GamePreLobby;
	LastGameState = GameState;
	return bCondition;
}

void EnterCustomGameLobbyEventEntry::Invoke() {
	Artemis::Engine::Events::EnterCustomGameLobbyEventArgs e;
	Artemis::Engine::Events::EnterCustomGameLobbyEvent.Invoke(this, &e);
}

bool EnterPickPhaseEventEntry::Condition() {
	Artemis::Engine::GameState GameState = GameManager.GetGameState();
	bool bCondition = GameState != LastGameState && GameState == Artemis::Engine::GameState::PickPhase;
	LastGameState = GameState;
	return bCondition;
}

void EnterPickPhaseEventEntry::Invoke() {
	Artemis::Engine::Events::EnterPickPhaseEventArgs e;
	Artemis::Engine::Events::EnterPickPhaseEvent.Invoke(this, &e);
}

bool EnterGameEventEntry::Condition() {
	Artemis::Engine::GameState GameState = GameManager.GetGameState();
	bool bCondition = GameState != LastGameState && GameState == Artemis::Engine::GameState::Playing;
	LastGameState = GameState;
	return bCondition;
}

void EnterGameEventEntry::Invoke() {
	Artemis::Engine::Events::EnterGameEventArgs e;
	Artemis::Engine::Events::EnterGameEvent.Invoke(this, &e);
}
```

`Artemis/EventEntries.h`:

```h
#pragma once

#include "EventManager.h"

class EnterMainMenuEventEntry : public Artemis::IEventEntry {
public:
	virtual bool Condition() final;
	virtual void Invoke() final;
};

class EnterCustomGameLobbyEventEntry : public Artemis::IEventEntry {
public:
	virtual bool Condition() final;
	virtual void Invoke() final;
};

class EnterPickPhaseEventEntry : public Artemis::IEventEntry {
public:
	virtual bool Condition() final;
	virtual void Invoke() final;
};

class EnterGameEventEntry : public Artemis::IEventEntry {
public:
	virtual bool Condition() final;
	virtual void Invoke() final;
};
```

`Artemis/EventManager.cpp`:

```cpp
#include "pch.h"
#include "EventManager.h"

namespace Artemis {
	void EventManager::Invoke() {
		for (IEventEntry* pEntry : InvocableCollection)
			if (pEntry && pEntry->Condition())
				pEntry->Invoke();
	}
}
```

`Artemis/EventManager.h`:

```h
#ifndef __ARTEMIS_EVENT_MANAGER_H__
#define __ARTEMIS_EVENT_MANAGER_H__

#include "Definitions.h"
#include "Manager.h"

namespace Artemis {
	class IEventEntry {
	public:
		virtual bool Condition() = 0;
		virtual void Invoke() = 0;
	};

	using EventEntryIndex = int;

#ifdef _ARTEMIS_EXPORT
	extern template class Manager<IEventEntry, EventEntryIndex>;
#else
	template class ARTEMIS_IMPORT Manager<IEventEntry, EventEntryIndex>;
#endif // _ARTEMIS_EXPORT

	class ARTEMIS_API EventManager : public Manager<IEventEntry, EventEntryIndex> {
	public:
		void Invoke();
	};
}

#endif // !__ARTEMIS_EVENT_MANAGER_H__
```

`Artemis/Events.cpp`:

```cpp
#include "pch.h"
#include "Events.h"

namespace Artemis::Engine::Events {
	ARTEMIS_API Aurora::Event<OnNewFrameEventArgs> OnNewFrameEvent;

	ARTEMIS_API Aurora::Event<EnterMainMenuEventArgs> EnterMainMenuEvent;
	ARTEMIS_API Aurora::Event<EnterCustomGameLobbyEventArgs> EnterCustomGameLobbyEvent;
	ARTEMIS_API Aurora::Event<EnterPickPhaseEventArgs> EnterPickPhaseEvent;
	ARTEMIS_API Aurora::Event<EnterGameEventArgs> EnterGameEvent;
}
```

`Artemis/Events.h`:

```h
#ifndef __ARTEMIS_ENGINE_EVENTS_H__
#define __ARTEMIS_ENGINE_EVENTS_H__

#include <Aurora/Events.h>

#include "Definitions.h"

namespace Artemis::Engine::Events {
	class ARTEMIS_API OnNewFrameEventArgs {};

	class ARTEMIS_API EnterMainMenuEventArgs {};
	class ARTEMIS_API EnterCustomGameLobbyEventArgs {};
	class ARTEMIS_API EnterPickPhaseEventArgs {};
	class ARTEMIS_API EnterGameEventArgs {};

	ARTEMIS_API extern Aurora::Event<OnNewFrameEventArgs> OnNewFrameEvent;

	ARTEMIS_API extern Aurora::Event<EnterMainMenuEventArgs> EnterMainMenuEvent;
	ARTEMIS_API extern Aurora::Event<EnterCustomGameLobbyEventArgs> EnterCustomGameLobbyEvent;
	ARTEMIS_API extern Aurora::Event<EnterPickPhaseEventArgs> EnterPickPhaseEvent;
	ARTEMIS_API extern Aurora::Event<EnterGameEventArgs> EnterGameEvent;
}

#endif // !__ARTEMIS_ENGINE_EVENTS_H__
```

`Artemis/ExtensionManager.cpp`:

```cpp
#include "pch.h"
#include "ExtensionManager.h"

#include "External.h"

namespace Artemis {
	
}
```

`Artemis/ExtensionManager.h`:

```h
#ifndef __ARTEMIS_EXTENSION_MANAGER_H__
#define __ARTEMIS_EXTENSION_MANAGER_H__

#include "Definitions.h"

namespace Artemis {

}

#endif // !__ARTEMIS_EXTENSION_MANAGER_H__
```

`Artemis/External.cpp`:

```cpp
#include "pch.h"
#include "External.h"

namespace Artemis {
#ifdef _DEBUG
	ARTEMIS_API Logger Log(true, true, "Artemis.log");
#else
	ARTEMIS_API Logger Log(false, true, "Artemis.log");
#endif // _DEBUG

	ARTEMIS_API DrawManagerCollection DrawManagers;
	ARTEMIS_API DrawManager& MainDrawManager = *DrawManagers.Get(DrawManagers.AddNew());
	ARTEMIS_API EventManager EventEntries;
	ARTEMIS_API KeybindManager Keybinds;
	ARTEMIS_API WindowManager Windows;
}
```

`Artemis/External.h`:

```h
#ifndef __ARTEMIS_EXTERNAL_H__
#define __ARTEMIS_EXTERNAL_H__

#include <Aurora/Logger.h>

using Aurora::Logger;

#include "Definitions.h"
#include "DrawManager.h"
#include "EventManager.h"
#include "KeybindManager.h"
#include "WindowManager.h"

namespace Artemis {
	ARTEMIS_API void Exit();

	ARTEMIS_API extern Logger Log;

	ARTEMIS_API extern DrawManagerCollection DrawManagers;
	ARTEMIS_API extern DrawManager& MainDrawManager;
	ARTEMIS_API extern EventManager EventEntries;
	ARTEMIS_API extern KeybindManager Keybinds;
	ARTEMIS_API extern WindowManager Windows;
}

#endif // !__ARTEMIS_EXTERNAL_H__
```

`Artemis/GameManager.cpp`:

```cpp
#include "pch.h"
#include "GameManager.h"

#include "Constants.h"

namespace Artemis::Engine {
	GameManager::GameManager(const Aurora::ModuleInfo& refRainbowSix) : uGameManager(refRainbowSix.GetModuleBaseAddress() + Constants::c_uGameManagerOffset) {}

	GameState GameManager::GetGameState() const {
		return *(GameState*)(*(A_ADDR*)uGameManager + Constants::c_uGameStateOffset);
	}
}
```

`Artemis/GameManager.h`:

```h
#ifndef __ARTEMIS_ENGINE_GAME_MANAGER_H__
#define __ARTEMIS_ENGINE_GAME_MANAGER_H__

#include <Aurora/Definitions.h>

#include "Definitions.h"

namespace Artemis::Engine {
	enum class GameState : int {
		Invalid = 0,
		Shutdown = 1,
		MainMenu = 2,
		GamePreLobby = 3,
		PendingRoundStartup = 4,
		PickPhase = 5,
		Playing = 6,
		PlayerControlAllowed = 7
	};

	class ARTEMIS_API GameManager {
		A_ADDR uGameManager;

	public:
		GameManager(const Aurora::ModuleInfo& refRainbowSix);

		GameState GetGameState() const;
	};
}

#endif // !__ARTEMIS_ENGINE_GAME_MANAGER_H__
```

`Artemis/ImGui/imconfig.h`:

```h
//-----------------------------------------------------------------------------
// COMPILE-TIME OPTIONS FOR DEAR IMGUI
// Runtime options (clipboard callbacks, enabling various features, etc.) can generally be set via the ImGuiIO structure.
// You can use ImGui::SetAllocatorFunctions() before calling ImGui::CreateContext() to rewire memory allocation functions.
//-----------------------------------------------------------------------------
// A) You may edit imconfig.h (and not overwrite it when updating Dear ImGui, or maintain a patch/branch with your modifications to imconfig.h)
// B) or add configuration directives in your own file and compile with #define IMGUI_USER_CONFIG "myfilename.h"
// If you do so you need to make sure that configuration settings are defined consistently _everywhere_ Dear ImGui is used, which include
// the imgui*.cpp files but also _any_ of your code that uses Dear ImGui. This is because some compile-time options have an affect on data structures.
// Defining those options in imconfig.h will ensure every compilation unit gets to see the same data structure layouts.
// Call IMGUI_CHECKVERSION() from your .cpp files to verify that the data structures your files are using are matching the ones imgui.cpp is using.
//-----------------------------------------------------------------------------

#pragma once

//---- Define assertion handler. Defaults to calling assert().
//#define IM_ASSERT(_EXPR)  MyAssert(_EXPR)
//#define IM_ASSERT(_EXPR)  ((void)(_EXPR))     // Disable asserts

//---- Define attributes of all API symbols declarations, e.g. for DLL under Windows
// Using dear imgui via a shared library is not recommended, because of function call overhead and because we don't guarantee backward nor forward ABI compatibility.
//#define IMGUI_API __declspec( dllexport )
#define IMGUI_API __declspec( dllimport )

//---- Don't define obsolete functions/enums/behaviors. Consider enabling from time to time after updating to avoid using soon-to-be obsolete function/names.
//#define IMGUI_DISABLE_OBSOLETE_FUNCTIONS

//---- Don't implement demo windows functionality (ShowDemoWindow()/ShowStyleEditor()/ShowUserGuide() methods will be empty)
// It is very strongly recommended to NOT disable the demo windows during development. Please read the comments in imgui_demo.cpp.
//#define IMGUI_DISABLE_DEMO_WINDOWS
//#define IMGUI_DISABLE_METRICS_WINDOW

//---- Don't implement some functions to reduce linkage requirements.
//#define IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS   // [Win32] Don't implement default clipboard handler. Won't use and link with OpenClipboard/GetClipboardData/CloseClipboard etc.
//#define IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS         // [Win32] Don't implement default IME handler. Won't use and link with ImmGetContext/ImmSetCompositionWindow.
//#define IMGUI_DISABLE_WIN32_FUNCTIONS                     // [Win32] Won't use and link with any Win32 function (clipboard, ime).
//#define IMGUI_ENABLE_OSX_DEFAULT_CLIPBOARD_FUNCTIONS      // [OSX] Implement default OSX clipboard handler (need to link with '-framework ApplicationServices', this is why this is not the default).
//#define IMGUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS            // Don't implement ImFormatString/ImFormatStringV so you can implement them yourself (e.g. if you don't want to link with vsnprintf)
//#define IMGUI_DISABLE_DEFAULT_MATH_FUNCTIONS              // Don't implement ImFabs/ImSqrt/ImPow/ImFmod/ImCos/ImSin/ImAcos/ImAtan2 so you can implement them yourself.
//#define IMGUI_DISABLE_DEFAULT_FILE_FUNCTIONS              // Don't implement ImFileOpen/ImFileClose/ImFileRead/ImFileWrite so you can implement them yourself if you don't want to link with fopen/fclose/fread/fwrite. This will also disable the LogToTTY() function.
//#define IMGUI_DISABLE_DEFAULT_ALLOCATORS                  // Don't implement default allocators calling malloc()/free() to avoid linking with them. You will need to call ImGui::SetAllocatorFunctions().

//---- Include imgui_user.h at the end of imgui.h as a convenience
//#define IMGUI_INCLUDE_IMGUI_USER_H

//---- Pack colors to BGRA8 instead of RGBA8 (to avoid converting from one to another)
//#define IMGUI_USE_BGRA_PACKED_COLOR

//---- Avoid multiple STB libraries implementations, or redefine path/filenames to prioritize another version
// By default the embedded implementations are declared static and not available outside of imgui cpp files.
//#define IMGUI_STB_TRUETYPE_FILENAME   "my_folder/stb_truetype.h"
//#define IMGUI_STB_RECT_PACK_FILENAME  "my_folder/stb_rect_pack.h"
//#define IMGUI_DISABLE_STB_TRUETYPE_IMPLEMENTATION
//#define IMGUI_DISABLE_STB_RECT_PACK_IMPLEMENTATION

//---- Define constructor and implicit cast operators to convert back<>forth between your math types and ImVec2/ImVec4.
// This will be inlined as part of ImVec2 and ImVec4 class declarations.
/*
#define IM_VEC2_CLASS_EXTRA                                                 \
        ImVec2(const MyVec2& f) { x = f.x; y = f.y; }                       \
        operator MyVec2() const { return MyVec2(x,y); }

#define IM_VEC4_CLASS_EXTRA                                                 \
        ImVec4(const MyVec4& f) { x = f.x; y = f.y; z = f.z; w = f.w; }     \
        operator MyVec4() const { return MyVec4(x,y,z,w); }
*/

//---- Use 32-bit vertex indices (default is 16-bit) is one way to allow large meshes with more than 64K vertices.
// Your renderer back-end will need to support it (most example renderer back-ends support both 16/32-bit indices).
// Another way to allow large meshes while keeping 16-bit indices is to handle ImDrawCmd::VtxOffset in your renderer.
// Read about ImGuiBackendFlags_RendererHasVtxOffset for details.
//#define ImDrawIdx unsigned int

//---- Override ImDrawCallback signature (will need to modify renderer back-ends accordingly)
//struct ImDrawList;
//struct ImDrawCmd;
//typedef void (*MyImDrawCallback)(const ImDrawList* draw_list, const ImDrawCmd* cmd, void* my_renderer_user_data);
//#define ImDrawCallback MyImDrawCallback

//---- Debug Tools: Macro to break in Debugger
// (use 'Metrics->Tools->Item Picker' to pick widgets with the mouse and break into them for easy debugging.)
//#define IM_DEBUG_BREAK  IM_ASSERT(0)
//#define IM_DEBUG_BREAK  __debugbreak()

//---- Debug Tools: Have the Item Picker break in the ItemAdd() function instead of ItemHoverable(),
// (which comes earlier in the code, will catch a few extra items, allow picking items other than Hovered one.)
// This adds a small runtime cost which is why it is not enabled by default.
//#define IMGUI_DEBUG_TOOL_ITEM_PICKER_EX

//---- Debug Tools: Enable slower asserts
//#define IMGUI_DEBUG_PARANOID

//---- Tip: You can add extra functions within the ImGui:: namespace, here or in your own headers files.
/*
namespace ImGui
{
    void MyFunction(const char* name, const MyMatrix44& v);
}
*/

```

`Artemis/ImGui/imgui.h`:

```h
// dear imgui, v1.75 WIP
// (headers)

// See imgui.cpp file for documentation.
// Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp for demo code.
// Newcomers, read 'Programmer guide' in imgui.cpp for notes on how to setup Dear ImGui in your codebase.
// Get latest version at https://github.com/ocornut/imgui

/*

Index of this file:
// Header mess
// Forward declarations and basic types
// ImGui API (Dear ImGui end-user API)
// Flags & Enumerations
// Memory allocations macros
// ImVector<>
// ImGuiStyle
// ImGuiIO
// Misc data structures (ImGuiInputTextCallbackData, ImGuiSizeCallbackData, ImGuiPayload)
// Obsolete functions
// Helpers (ImGuiOnceUponAFrame, ImGuiTextFilter, ImGuiTextBuffer, ImGuiStorage, ImGuiListClipper, ImColor)
// Draw List API (ImDrawCallback, ImDrawCmd, ImDrawIdx, ImDrawVert, ImDrawChannel, ImDrawListSplitter, ImDrawListFlags, ImDrawList, ImDrawData)
// Font API (ImFontConfig, ImFontGlyph, ImFontGlyphRangesBuilder, ImFontAtlasFlags, ImFontAtlas, ImFont)

*/

#pragma once

// Configuration file with compile-time options (edit imconfig.h or #define IMGUI_USER_CONFIG to your own filename)
#ifdef IMGUI_USER_CONFIG
#include IMGUI_USER_CONFIG
#endif
#if !defined(IMGUI_DISABLE_INCLUDE_IMCONFIG_H) || defined(IMGUI_INCLUDE_IMCONFIG_H)
#include "imconfig.h"
#endif

//-----------------------------------------------------------------------------
// Header mess
//-----------------------------------------------------------------------------

// Includes
#include <float.h>                  // FLT_MIN, FLT_MAX
#include <stdarg.h>                 // va_list, va_start, va_end
#include <stddef.h>                 // ptrdiff_t, NULL
#include <string.h>                 // memset, memmove, memcpy, strlen, strchr, strcpy, strcmp

// Version
// (Integer encoded as XYYZZ for use in #if preprocessor conditionals. Work in progress versions typically starts at XYY99 then bounce up to XYY00, XYY01 etc. when release tagging happens)
#define IMGUI_VERSION               "1.75 WIP"
#define IMGUI_VERSION_NUM           17401
#define IMGUI_CHECKVERSION()        ImGui::DebugCheckVersionAndDataLayout(IMGUI_VERSION, sizeof(ImGuiIO), sizeof(ImGuiStyle), sizeof(ImVec2), sizeof(ImVec4), sizeof(ImDrawVert), sizeof(ImDrawIdx))

// Define attributes of all API symbols declarations (e.g. for DLL under Windows)
// IMGUI_API is used for core imgui functions, IMGUI_IMPL_API is used for the default bindings files (imgui_impl_xxx.h)
// Using dear imgui via a shared library is not recommended, because of function call overhead and because we don't guarantee backward nor forward ABI compatibility.
#ifndef IMGUI_API
#define IMGUI_API
#endif
#ifndef IMGUI_IMPL_API
#define IMGUI_IMPL_API              IMGUI_API
#endif

// Helper Macros
#ifndef IM_ASSERT
#include <assert.h>
#define IM_ASSERT(_EXPR)            assert(_EXPR)                               // You can override the default assert handler by editing imconfig.h
#endif
#if defined(__clang__) || defined(__GNUC__)
#define IM_FMTARGS(FMT)             __attribute__((format(printf, FMT, FMT+1))) // To apply printf-style warnings to our functions.
#define IM_FMTLIST(FMT)             __attribute__((format(printf, FMT, 0)))
#else
#define IM_FMTARGS(FMT)
#define IM_FMTLIST(FMT)
#endif
#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*_ARR)))       // Size of a static C-style array. Don't use on pointers!
#define IM_UNUSED(_VAR)             ((void)_VAR)                                // Used to silence "unused variable warnings". Often useful as asserts may be stripped out from final builds.
#if (__cplusplus >= 201100)
#define IM_OFFSETOF(_TYPE,_MEMBER)  offsetof(_TYPE, _MEMBER)                    // Offset of _MEMBER within _TYPE. Standardized as offsetof() in C++11
#else
#define IM_OFFSETOF(_TYPE,_MEMBER)  ((size_t)&(((_TYPE*)0)->_MEMBER))           // Offset of _MEMBER within _TYPE. Old style macro.
#endif
#define IM_UNICODE_CODEPOINT_MAX     0xFFFF                                     // Last Unicode code point supported by this build.
#define IM_UNICODE_CODEPOINT_INVALID 0xFFFD                                     // Standard invalid Unicode code point.

// Warnings
#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wold-style-cast"
#if __has_warning("-Wzero-as-null-pointer-constant")
#pragma clang diagnostic ignored "-Wzero-as-null-pointer-constant"
#endif
#elif defined(__GNUC__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wpragmas"                  // warning: unknown option after '#pragma GCC diagnostic' kind
#pragma GCC diagnostic ignored "-Wclass-memaccess"          // [__GNUC__ >= 8] warning: 'memset/memcpy' clearing/writing an object of type 'xxxx' with no trivial copy-assignment; use assignment or value-initialization instead
#endif

//-----------------------------------------------------------------------------
// Forward declarations and basic types
//-----------------------------------------------------------------------------

struct ImDrawChannel;               // Temporary storage to output draw commands out of order, used by ImDrawListSplitter and ImDrawList::ChannelsSplit()
struct ImDrawCmd;                   // A single draw command within a parent ImDrawList (generally maps to 1 GPU draw call, unless it is a callback)
struct ImDrawData;                  // All draw command lists required to render the frame + pos/size coordinates to use for the projection matrix.
struct ImDrawList;                  // A single draw command list (generally one per window, conceptually you may see this as a dynamic "mesh" builder)
struct ImDrawListSharedData;        // Data shared among multiple draw lists (typically owned by parent ImGui context, but you may create one yourself)
struct ImDrawListSplitter;          // Helper to split a draw list into different layers which can be drawn into out of order, then flattened back.
struct ImDrawVert;                  // A single vertex (pos + uv + col = 20 bytes by default. Override layout with IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT)
struct ImFont;                      // Runtime data for a single font within a parent ImFontAtlas
struct ImFontAtlas;                 // Runtime data for multiple fonts, bake multiple fonts into a single texture, TTF/OTF font loader
struct ImFontConfig;                // Configuration data when adding a font or merging fonts
struct ImFontGlyph;                 // A single font glyph (code point + coordinates within in ImFontAtlas + offset)
struct ImFontGlyphRangesBuilder;    // Helper to build glyph ranges from text/string data
struct ImColor;                     // Helper functions to create a color that can be converted to either u32 or float4 (*OBSOLETE* please avoid using)
struct ImGuiContext;                // Dear ImGui context (opaque structure, unless including imgui_internal.h)
struct ImGuiIO;                     // Main configuration and I/O between your application and ImGui
struct ImGuiInputTextCallbackData;  // Shared state of InputText() when using custom ImGuiInputTextCallback (rare/advanced use)
struct ImGuiListClipper;            // Helper to manually clip large list of items
struct ImGuiOnceUponAFrame;         // Helper for running a block of code not more than once a frame, used by IMGUI_ONCE_UPON_A_FRAME macro
struct ImGuiPayload;                // User data payload for drag and drop operations
struct ImGuiSizeCallbackData;       // Callback data when using SetNextWindowSizeConstraints() (rare/advanced use)
struct ImGuiStorage;                // Helper for key->value storage
struct ImGuiStyle;                  // Runtime data for styling/colors
struct ImGuiTextBuffer;             // Helper to hold and append into a text buffer (~string builder)
struct ImGuiTextFilter;             // Helper to parse and apply text filters (e.g. "aaaaa[,bbbb][,ccccc]")

// Typedefs and Enums/Flags (declared as int for compatibility with old C++, to allow using as flags and to not pollute the top of this file)
// Use your programming IDE "Go to definition" facility on the names in the central column below to find the actual flags/enum lists.
#ifndef ImTextureID
typedef void* ImTextureID;          // User data to identify a texture (this is whatever to you want it to be! read the FAQ about ImTextureID in imgui.cpp)
#endif
typedef unsigned int ImGuiID;       // Unique ID used by widgets (typically hashed from a stack of string)
typedef unsigned short ImWchar;     // A single U16 character for keyboard input/display. We encode them as multi bytes UTF-8 when used in strings.
typedef int ImGuiCol;               // -> enum ImGuiCol_             // Enum: A color identifier for styling
typedef int ImGuiCond;              // -> enum ImGuiCond_            // Enum: A condition for many Set*() functions
typedef int ImGuiDataType;          // -> enum ImGuiDataType_        // Enum: A primary data type
typedef int ImGuiDir;               // -> enum ImGuiDir_             // Enum: A cardinal direction
typedef int ImGuiKey;               // -> enum ImGuiKey_             // Enum: A key identifier (ImGui-side enum)
typedef int ImGuiNavInput;          // -> enum ImGuiNavInput_        // Enum: An input identifier for navigation
typedef int ImGuiMouseButton;       // -> enum ImGuiMouseButton_     // Enum: A mouse button identifier (0=left, 1=right, 2=middle)
typedef int ImGuiMouseCursor;       // -> enum ImGuiMouseCursor_     // Enum: A mouse cursor identifier
typedef int ImGuiStyleVar;          // -> enum ImGuiStyleVar_        // Enum: A variable identifier for styling
typedef int ImDrawCornerFlags;      // -> enum ImDrawCornerFlags_    // Flags: for ImDrawList::AddRect(), AddRectFilled() etc.
typedef int ImDrawListFlags;        // -> enum ImDrawListFlags_      // Flags: for ImDrawList
typedef int ImFontAtlasFlags;       // -> enum ImFontAtlasFlags_     // Flags: for ImFontAtlas
typedef int ImGuiBackendFlags;      // -> enum ImGuiBackendFlags_    // Flags: for io.BackendFlags
typedef int ImGuiColorEditFlags;    // -> enum ImGuiColorEditFlags_  // Flags: for ColorEdit4(), ColorPicker4() etc.
typedef int ImGuiConfigFlags;       // -> enum ImGuiConfigFlags_     // Flags: for io.ConfigFlags
typedef int ImGuiComboFlags;        // -> enum ImGuiComboFlags_      // Flags: for BeginCombo()
typedef int ImGuiDragDropFlags;     // -> enum ImGuiDragDropFlags_   // Flags: for BeginDragDropSource(), AcceptDragDropPayload()
typedef int ImGuiFocusedFlags;      // -> enum ImGuiFocusedFlags_    // Flags: for IsWindowFocused()
typedef int ImGuiHoveredFlags;      // -> enum ImGuiHoveredFlags_    // Flags: for IsItemHovered(), IsWindowHovered() etc.
typedef int ImGuiInputTextFlags;    // -> enum ImGuiInputTextFlags_  // Flags: for InputText(), InputTextMultiline()
typedef int ImGuiSelectableFlags;   // -> enum ImGuiSelectableFlags_ // Flags: for Selectable()
typedef int ImGuiTabBarFlags;       // -> enum ImGuiTabBarFlags_     // Flags: for BeginTabBar()
typedef int ImGuiTabItemFlags;      // -> enum ImGuiTabItemFlags_    // Flags: for BeginTabItem()
typedef int ImGuiTreeNodeFlags;     // -> enum ImGuiTreeNodeFlags_   // Flags: for TreeNode(), TreeNodeEx(), CollapsingHeader()
typedef int ImGuiWindowFlags;       // -> enum ImGuiWindowFlags_     // Flags: for Begin(), BeginChild()
typedef int (*ImGuiInputTextCallback)(ImGuiInputTextCallbackData *data);
typedef void (*ImGuiSizeCallback)(ImGuiSizeCallbackData* data);

// Scalar data types
typedef signed char         ImS8;   // 8-bit signed integer
typedef unsigned char       ImU8;   // 8-bit unsigned integer
typedef signed short        ImS16;  // 16-bit signed integer
typedef unsigned short      ImU16;  // 16-bit unsigned integer
typedef signed int          ImS32;  // 32-bit signed integer == int
typedef unsigned int        ImU32;  // 32-bit unsigned integer (often used to store packed colors)
#if defined(_MSC_VER) && !defined(__clang__)
typedef signed   __int64    ImS64;  // 64-bit signed integer (pre and post C++11 with Visual Studio)
typedef unsigned __int64    ImU64;  // 64-bit unsigned integer (pre and post C++11 with Visual Studio)
#elif (defined(__clang__) || defined(__GNUC__)) && (__cplusplus < 201100)
#include <stdint.h>
typedef int64_t             ImS64;  // 64-bit signed integer (pre C++11)
typedef uint64_t            ImU64;  // 64-bit unsigned integer (pre C++11)
#else
typedef signed   long long  ImS64;  // 64-bit signed integer (post C++11)
typedef unsigned long long  ImU64;  // 64-bit unsigned integer (post C++11)
#endif

// 2D vector (often used to store positions, sizes, etc.)
struct ImVec2
{
    float     x, y;
    ImVec2()  { x = y = 0.0f; }
    ImVec2(float _x, float _y) { x = _x; y = _y; }
    float  operator[] (size_t idx) const { IM_ASSERT(idx <= 1); return (&x)[idx]; }    // We very rarely use this [] operator, the assert overhead is fine.
    float& operator[] (size_t idx)       { IM_ASSERT(idx <= 1); return (&x)[idx]; }    // We very rarely use this [] operator, the assert overhead is fine.
#ifdef IM_VEC2_CLASS_EXTRA
    IM_VEC2_CLASS_EXTRA     // Define additional constructors and implicit cast operators in imconfig.h to convert back and forth between your math types and ImVec2.
#endif
};

// 4D vector (often used to store floating-point colors)
struct ImVec4
{
    float     x, y, z, w;
    ImVec4()  { x = y = z = w = 0.0f; }
    ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }
#ifdef IM_VEC4_CLASS_EXTRA
    IM_VEC4_CLASS_EXTRA     // Define additional constructors and implicit cast operators in imconfig.h to convert back and forth between your math types and ImVec4.
#endif
};

//-----------------------------------------------------------------------------
// ImGui: Dear ImGui end-user API
// (Inside a namespace so you can add extra functions in your own separate file. Please don't modify imgui source files!)
//-----------------------------------------------------------------------------

namespace ImGui
{
    // Context creation and access
    // Each context create its own ImFontAtlas by default. You may instance one yourself and pass it to CreateContext() to share a font atlas between imgui contexts.
    // None of those functions is reliant on the current context.
    IMGUI_API ImGuiContext* CreateContext(ImFontAtlas* shared_font_atlas = NULL);
    IMGUI_API void          DestroyContext(ImGuiContext* ctx = NULL);   // NULL = destroy current context
    IMGUI_API ImGuiContext* GetCurrentContext();
    IMGUI_API void          SetCurrentContext(ImGuiContext* ctx);
    IMGUI_API bool          DebugCheckVersionAndDataLayout(const char* version_str, size_t sz_io, size_t sz_style, size_t sz_vec2, size_t sz_vec4, size_t sz_drawvert, size_t sz_drawidx);

    // Main
    IMGUI_API ImGuiIO&      GetIO();                                    // access the IO structure (mouse/keyboard/gamepad inputs, time, various configuration options/flags)
    IMGUI_API ImGuiStyle&   GetStyle();                                 // access the Style structure (colors, sizes). Always use PushStyleCol(), PushStyleVar() to modify style mid-frame.
    IMGUI_API void          NewFrame();                                 // start a new Dear ImGui frame, you can submit any command from this point until Render()/EndFrame().
    IMGUI_API void          EndFrame();                                 // ends the Dear ImGui frame. automatically called by Render(), you likely don't need to call that yourself directly. If you don't need to render data (skipping rendering) you may call EndFrame() but you'll have wasted CPU already! If you don't need to render, better to not create any imgui windows and not call NewFrame() at all!
    IMGUI_API void          Render();                                   // ends the Dear ImGui frame, finalize the draw data. You can get call GetDrawData() to obtain it and run your rendering function. (Obsolete: this used to call io.RenderDrawListsFn(). Nowadays, we allow and prefer calling your render function yourself.)
    IMGUI_API ImDrawData*   GetDrawData();                              // valid after Render() and until the next call to NewFrame(). this is what you have to render.

    // Demo, Debug, Information
    IMGUI_API void          ShowDemoWindow(bool* p_open = NULL);        // create Demo window (previously called ShowTestWindow). demonstrate most ImGui features. call this to learn about the library! try to make it always available in your application!
    IMGUI_API void          ShowAboutWindow(bool* p_open = NULL);       // create About window. display Dear ImGui version, credits and build/system information.
    IMGUI_API void          ShowMetricsWindow(bool* p_open = NULL);     // create Metrics/Debug window. display Dear ImGui internals: draw commands (with individual draw calls and vertices), window list, basic internal state, etc.
    IMGUI_API void          ShowStyleEditor(ImGuiStyle* ref = NULL);    // add style editor block (not a window). you can pass in a reference ImGuiStyle structure to compare to, revert to and save to (else it uses the default style)
    IMGUI_API bool          ShowStyleSelector(const char* label);       // add style selector block (not a window), essentially a combo listing the default styles.
    IMGUI_API void          ShowFontSelector(const char* label);        // add font selector block (not a window), essentially a combo listing the loaded fonts.
    IMGUI_API void          ShowUserGuide();                            // add basic help/info block (not a window): how to manipulate ImGui as a end-user (mouse/keyboard controls).
    IMGUI_API const char*   GetVersion();                               // get the compiled version string e.g. "1.23" (essentially the compiled value for IMGUI_VERSION)

    // Styles
    IMGUI_API void          StyleColorsDark(ImGuiStyle* dst = NULL);    // new, recommended style (default)
    IMGUI_API void          StyleColorsClassic(ImGuiStyle* dst = NULL); // classic imgui style
    IMGUI_API void          StyleColorsLight(ImGuiStyle* dst = NULL);   // best used with borders and a custom, thicker font

    // Windows
    // - Begin() = push window to the stack and start appending to it. End() = pop window from the stack.
    // - You may append multiple times to the same window during the same frame.
    // - Passing 'bool* p_open != NULL' shows a window-closing widget in the upper-right corner of the window,
    //   which clicking will set the boolean to false when clicked.
    // - Begin() return false to indicate the window is collapsed or fully clipped, so you may early out and omit submitting
    //   anything to the window. Always call a matching End() for each Begin() call, regardless of its return value!
    //   [Important: due to legacy reason, this is inconsistent with most other functions such as BeginMenu/EndMenu,
    //    BeginPopup/EndPopup, etc. where the EndXXX call should only be called if the corresponding BeginXXX function
    //    returned true. Begin and BeginChild are the only odd ones out. Will be fixed in a future update.]
    // - Note that the bottom of window stack always contains a window called "Debug".
    IMGUI_API bool          Begin(const char* name, bool* p_open = NULL, ImGuiWindowFlags flags = 0);
    IMGUI_API void          End();

    // Child Windows
    // - Use child windows to begin into a self-contained independent scrolling/clipping regions within a host window. Child windows can embed their own child.
    // - For each independent axis of 'size': ==0.0f: use remaining host window size / >0.0f: fixed size / <0.0f: use remaining window size minus abs(size) / Each axis can use a different mode, e.g. ImVec2(0,400).
    // - BeginChild() returns false to indicate the window is collapsed or fully clipped, so you may early out and omit submitting anything to the window.
    //   Always call a matching EndChild() for each BeginChild() call, regardless of its return value [as with Begin: this is due to legacy reason and inconsistent with most BeginXXX functions apart from the regular Begin() which behaves like BeginChild().]
    IMGUI_API bool          BeginChild(const char* str_id, const ImVec2& size = ImVec2(0,0), bool border = false, ImGuiWindowFlags flags = 0);
    IMGUI_API bool          BeginChild(ImGuiID id, const ImVec2& size = ImVec2(0,0), bool border = false, ImGuiWindowFlags flags = 0);
    IMGUI_API void          EndChild();

    // Windows Utilities
    // - 'current window' = the window we are appending into while inside a Begin()/End() block. 'next window' = next window we will Begin() into.
    IMGUI_API bool          IsWindowAppearing();
    IMGUI_API bool          IsWindowCollapsed();
    IMGUI_API bool          IsWindowFocused(ImGuiFocusedFlags flags=0); // is current window focused? or its root/child, depending on flags. see flags for options.
    IMGUI_API bool          IsWindowHovered(ImGuiHoveredFlags flags=0); // is current window hovered (and typically: not blocked by a popup/modal)? see flags for options. NB: If you are trying to check whether your mouse should be dispatched to imgui or to your app, you should use the 'io.WantCaptureMouse' boolean for that! Please read the FAQ!
    IMGUI_API ImDrawList*   GetWindowDrawList();                        // get draw list associated to the current window, to append your own drawing primitives
    IMGUI_API ImVec2        GetWindowPos();                             // get current window position in screen space (useful if you want to do your own drawing via the DrawList API)
    IMGUI_API ImVec2        GetWindowSize();                            // get current window size
    IMGUI_API float         GetWindowWidth();                           // get current window width (shortcut for GetWindowSize().x)
    IMGUI_API float         GetWindowHeight();                          // get current window height (shortcut for GetWindowSize().y)

    // Prefer using SetNextXXX functions (before Begin) rather that SetXXX functions (after Begin).
    IMGUI_API void          SetNextWindowPos(const ImVec2& pos, ImGuiCond cond = 0, const ImVec2& pivot = ImVec2(0,0)); // set next window position. call before Begin(). use pivot=(0.5f,0.5f) to center on given point, etc.
    IMGUI_API void          SetNextWindowSize(const ImVec2& size, ImGuiCond cond = 0);                  // set next window size. set axis to 0.0f to force an auto-fit on this axis. call before Begin()
    IMGUI_API void          SetNextWindowSizeConstraints(const ImVec2& size_min, const ImVec2& size_max, ImGuiSizeCallback custom_callback = NULL, void* custom_callback_data = NULL); // set next window size limits. use -1,-1 on either X/Y axis to preserve the current size. Sizes will be rounded down. Use callback to apply non-trivial programmatic constraints.
    IMGUI_API void          SetNextWindowContentSize(const ImVec2& size);                               // set next window content size (~ scrollable client area, which enforce the range of scrollbars). Not including window decorations (title bar, menu bar, etc.) nor WindowPadding. set an axis to 0.0f to leave it automatic. call before Begin()
    IMGUI_API void          SetNextWindowCollapsed(bool collapsed, ImGuiCond cond = 0);                 // set next window collapsed state. call before Begin()
    IMGUI_API void          SetNextWindowFocus();                                                       // set next window to be focused / top-most. call before Begin()
    IMGUI_API void          SetNextWindowBgAlpha(float alpha);                                          // set next window background color alpha. helper to easily modify ImGuiCol_WindowBg/ChildBg/PopupBg. you may also use ImGuiWindowFlags_NoBackground.
    IMGUI_API void          SetWindowPos(const ImVec2& pos, ImGuiCond cond = 0);                        // (not recommended) set current window position - call within Begin()/End(). prefer using SetNextWindowPos(), as this may incur tearing and side-effects.
    IMGUI_API void          SetWindowSize(const ImVec2& size, ImGuiCond cond = 0);                      // (not recommended) set current window size - call within Begin()/End(). set to ImVec2(0,0) to force an auto-fit. prefer using SetNextWindowSize(), as this may incur tearing and minor side-effects.
    IMGUI_API void          SetWindowCollapsed(bool collapsed, ImGuiCond cond = 0);                     // (not recommended) set current window collapsed state. prefer using SetNextWindowCollapsed().
    IMGUI_API void          SetWindowFocus();                                                           // (not recommended) set current window to be focused / top-most. prefer using SetNextWindowFocus().
    IMGUI_API void          SetWindowFontScale(float scale);                                            // set font scale. Adjust IO.FontGlobalScale if you want to scale all windows. This is an old API! For correct scaling, prefer to reload font + rebuild ImFontAtlas + call style.ScaleAllSizes().
    IMGUI_API void          SetWindowPos(const char* name, const ImVec2& pos, ImGuiCond cond = 0);      // set named window position.
    IMGUI_API void          SetWindowSize(const char* name, const ImVec2& size, ImGuiCond cond = 0);    // set named window size. set axis to 0.0f to force an auto-fit on this axis.
    IMGUI_API void          SetWindowCollapsed(const char* name, bool collapsed, ImGuiCond cond = 0);   // set named window collapsed state
    IMGUI_API void          SetWindowFocus(const char* name);                                           // set named window to be focused / top-most. use NULL to remove focus.

    // Content region
    // - Those functions are bound to be redesigned soon (they are confusing, incomplete and return values in local window coordinates which increases confusion)
    IMGUI_API ImVec2        GetContentRegionMax();                                          // current content boundaries (typically window boundaries including scrolling, or current column boundaries), in windows coordinates
    IMGUI_API ImVec2        GetContentRegionAvail();                                        // == GetContentRegionMax() - GetCursorPos()
    IMGUI_API ImVec2        GetWindowContentRegionMin();                                    // content boundaries min (roughly (0,0)-Scroll), in window coordinates
    IMGUI_API ImVec2        GetWindowContentRegionMax();                                    // content boundaries max (roughly (0,0)+Size-Scroll) where Size can be override with SetNextWindowContentSize(), in window coordinates
    IMGUI_API float         GetWindowContentRegionWidth();                                  //

    // Windows Scrolling
    IMGUI_API float         GetScrollX();                                                   // get scrolling amount [0..GetScrollMaxX()]
    IMGUI_API float         GetScrollY();                                                   // get scrolling amount [0..GetScrollMaxY()]
    IMGUI_API float         GetScrollMaxX();                                                // get maximum scrolling amount ~~ ContentSize.X - WindowSize.X
    IMGUI_API float         GetScrollMaxY();                                                // get maximum scrolling amount ~~ ContentSize.Y - WindowSize.Y
    IMGUI_API void          SetScrollX(float scroll_x);                                     // set scrolling amount [0..GetScrollMaxX()]
    IMGUI_API void          SetScrollY(float scroll_y);                                     // set scrolling amount [0..GetScrollMaxY()]
    IMGUI_API void          SetScrollHereX(float center_x_ratio = 0.5f);                    // adjust scrolling amount to make current cursor position visible. center_x_ratio=0.0: left, 0.5: center, 1.0: right. When using to make a "default/current item" visible, consider using SetItemDefaultFocus() instead.
    IMGUI_API void          SetScrollHereY(float center_y_ratio = 0.5f);                    // adjust scrolling amount to make current cursor position visible. center_y_ratio=0.0: top, 0.5: center, 1.0: bottom. When using to make a "default/current item" visible, consider using SetItemDefaultFocus() instead.
    IMGUI_API void          SetScrollFromPosX(float local_x, float center_x_ratio = 0.5f);  // adjust scrolling amount to make given position visible. Generally GetCursorStartPos() + offset to compute a valid position.
    IMGUI_API void          SetScrollFromPosY(float local_y, float center_y_ratio = 0.5f);  // adjust scrolling amount to make given position visible. Generally GetCursorStartPos() + offset to compute a valid position.

    // Parameters stacks (shared)
    IMGUI_API void          PushFont(ImFont* font);                                         // use NULL as a shortcut to push default font
    IMGUI_API void          PopFont();
    IMGUI_API void          PushStyleColor(ImGuiCol idx, ImU32 col);
    IMGUI_API void          PushStyleColor(ImGuiCol idx, const ImVec4& col);
    IMGUI_API void          PopStyleColor(int count = 1);
    IMGUI_API void          PushStyleVar(ImGuiStyleVar idx, float val);
    IMGUI_API void          PushStyleVar(ImGuiStyleVar idx, const ImVec2& val);
    IMGUI_API void          PopStyleVar(int count = 1);
    IMGUI_API const ImVec4& GetStyleColorVec4(ImGuiCol idx);                                // retrieve style color as stored in ImGuiStyle structure. use to feed back into PushStyleColor(), otherwise use GetColorU32() to get style color with style alpha baked in.
    IMGUI_API ImFont*       GetFont();                                                      // get current font
    IMGUI_API float         GetFontSize();                                                  // get current font size (= height in pixels) of current font with current scale applied
    IMGUI_API ImVec2        GetFontTexUvWhitePixel();                                       // get UV coordinate for a while pixel, useful to draw custom shapes via the ImDrawList API
    IMGUI_API ImU32         GetColorU32(ImGuiCol idx, float alpha_mul = 1.0f);              // retrieve given style color with style alpha applied and optional extra alpha multiplier
    IMGUI_API ImU32         GetColorU32(const ImVec4& col);                                 // retrieve given color with style alpha applied
    IMGUI_API ImU32         GetColorU32(ImU32 col);                                         // retrieve given color with style alpha applied

    // Parameters stacks (current window)
    IMGUI_API void          PushItemWidth(float item_width);                                // set width of items for common large "item+label" widgets. >0.0f: width in pixels, <0.0f align xx pixels to the right of window (so -1.0f always align width to the right side). 0.0f = default to ~2/3 of windows width,
    IMGUI_API void          PopItemWidth();
    IMGUI_API void          SetNextItemWidth(float item_width);                             // set width of the _next_ common large "item+label" widget. >0.0f: width in pixels, <0.0f align xx pixels to the right of window (so -1.0f always align width to the right side)
    IMGUI_API float         CalcItemWidth();                                                // width of item given pushed settings and current cursor position. NOT necessarily the width of last item unlike most 'Item' functions.
    IMGUI_API void          PushTextWrapPos(float wrap_local_pos_x = 0.0f);                 // word-wrapping for Text*() commands. < 0.0f: no wrapping; 0.0f: wrap to end of window (or column); > 0.0f: wrap at 'wrap_pos_x' position in window local space
    IMGUI_API void          PopTextWrapPos();
    IMGUI_API void          PushAllowKeyboardFocus(bool allow_keyboard_focus);              // allow focusing using TAB/Shift-TAB, enabled by default but you can disable it for certain widgets
    IMGUI_API void          PopAllowKeyboardFocus();
    IMGUI_API void          PushButtonRepeat(bool repeat);                                  // in 'repeat' mode, Button*() functions return repeated true in a typematic manner (using io.KeyRepeatDelay/io.KeyRepeatRate setting). Note that you can call IsItemActive() after any Button() to tell if the button is held in the current frame.
    IMGUI_API void          PopButtonRepeat();

    // Cursor / Layout
    // - By "cursor" we mean the current output position.
    // - The typical widget behavior is to output themselves at the current cursor position, then move the cursor one line down.
    // - You can call SameLine() between widgets to undo the last carriage return and output at the right of the preceeding widget.
    IMGUI_API void          Separator();                                                    // separator, generally horizontal. inside a menu bar or in horizontal layout mode, this becomes a vertical separator.
    IMGUI_API void          SameLine(float offset_from_start_x=0.0f, float spacing=-1.0f);  // call between widgets or groups to layout them horizontally. X position given in window coordinates.
    IMGUI_API void          NewLine();                                                      // undo a SameLine() or force a new line when in an horizontal-layout context.
    IMGUI_API void          Spacing();                                                      // add vertical spacing.
    IMGUI_API void          Dummy(const ImVec2& size);                                      // add a dummy item of given size. unlike InvisibleButton(), Dummy() won't take the mouse click or be navigable into.
    IMGUI_API void          Indent(float indent_w = 0.0f);                                  // move content position toward the right, by style.IndentSpacing or indent_w if != 0
    IMGUI_API void          Unindent(float indent_w = 0.0f);                                // move content position back to the left, by style.IndentSpacing or indent_w if != 0
    IMGUI_API void          BeginGroup();                                                   // lock horizontal starting position
    IMGUI_API void          EndGroup();                                                     // unlock horizontal starting position + capture the whole group bounding box into one "item" (so you can use IsItemHovered() or layout primitives such as SameLine() on whole group, etc.)
    IMGUI_API ImVec2        GetCursorPos();                                                 // cursor position in window coordinates (relative to window position)
    IMGUI_API float         GetCursorPosX();                                                //   (some functions are using window-relative coordinates, such as: GetCursorPos, GetCursorStartPos, GetContentRegionMax, GetWindowContentRegion* etc.
    IMGUI_API float         GetCursorPosY();                                                //    other functions such as GetCursorScreenPos or everything in ImDrawList::
    IMGUI_API void          SetCursorPos(const ImVec2& local_pos);                          //    are using the main, absolute coordinate system.
    IMGUI_API void          SetCursorPosX(float local_x);                                   //    GetWindowPos() + GetCursorPos() == GetCursorScreenPos() etc.)
    IMGUI_API void          SetCursorPosY(float local_y);                                   //
    IMGUI_API ImVec2        GetCursorStartPos();                                            // initial cursor position in window coordinates
    IMGUI_API ImVec2        GetCursorScreenPos();                                           // cursor position in absolute screen coordinates [0..io.DisplaySize] (useful to work with ImDrawList API)
    IMGUI_API void          SetCursorScreenPos(const ImVec2& pos);                          // cursor position in absolute screen coordinates [0..io.DisplaySize]
    IMGUI_API void          AlignTextToFramePadding();                                      // vertically align upcoming text baseline to FramePadding.y so that it will align properly to regularly framed items (call if you have text on a line before a framed item)
    IMGUI_API float         GetTextLineHeight();                                            // ~ FontSize
    IMGUI_API float         GetTextLineHeightWithSpacing();                                 // ~ FontSize + style.ItemSpacing.y (distance in pixels between 2 consecutive lines of text)
    IMGUI_API float         GetFrameHeight();                                               // ~ FontSize + style.FramePadding.y * 2
    IMGUI_API float         GetFrameHeightWithSpacing();                                    // ~ FontSize + style.FramePadding.y * 2 + style.ItemSpacing.y (distance in pixels between 2 consecutive lines of framed widgets)

    // ID stack/scopes
    // - Read the FAQ for more details about how ID are handled in dear imgui. If you are creating widgets in a loop you most
    //   likely want to push a unique identifier (e.g. object pointer, loop index) to uniquely differentiate them.
    // - The resulting ID are hashes of the entire stack.
    // - You can also use the "Label##foobar" syntax within widget label to distinguish them from each others.
    // - In this header file we use the "label"/"name" terminology to denote a string that will be displayed and used as an ID,
    //   whereas "str_id" denote a string that is only used as an ID and not normally displayed.
    IMGUI_API void          PushID(const char* str_id);                                     // push string into the ID stack (will hash string).
    IMGUI_API void          PushID(const char* str_id_begin, const char* str_id_end);       // push string into the ID stack (will hash string).
    IMGUI_API void          PushID(const void* ptr_id);                                     // push pointer into the ID stack (will hash pointer).
    IMGUI_API void          PushID(int int_id);                                             // push integer into the ID stack (will hash integer).
    IMGUI_API void          PopID();                                                        // pop from the ID stack.
    IMGUI_API ImGuiID       GetID(const char* str_id);                                      // calculate unique ID (hash of whole ID stack + given parameter). e.g. if you want to query into ImGuiStorage yourself
    IMGUI_API ImGuiID       GetID(const char* str_id_begin, const char* str_id_end);
    IMGUI_API ImGuiID       GetID(const void* ptr_id);

    // Widgets: Text
    IMGUI_API void          TextUnformatted(const char* text, const char* text_end = NULL); // raw text without formatting. Roughly equivalent to Text("%s", text) but: A) doesn't require null terminated string if 'text_end' is specified, B) it's faster, no memory copy is done, no buffer size limits, recommended for long chunks of text.
    IMGUI_API void          Text(const char* fmt, ...)                                      IM_FMTARGS(1); // formatted text
    IMGUI_API void          TextV(const char* fmt, va_list args)                            IM_FMTLIST(1);
    IMGUI_API void          TextColored(const ImVec4& col, const char* fmt, ...)            IM_FMTARGS(2); // shortcut for PushStyleColor(ImGuiCol_Text, col); Text(fmt, ...); PopStyleColor();
    IMGUI_API void          TextColoredV(const ImVec4& col, const char* fmt, va_list args)  IM_FMTLIST(2);
    IMGUI_API void          TextDisabled(const char* fmt, ...)                              IM_FMTARGS(1); // shortcut for PushStyleColor(ImGuiCol_Text, style.Colors[ImGuiCol_TextDisabled]); Text(fmt, ...); PopStyleColor();
    IMGUI_API void          TextDisabledV(const char* fmt, va_list args)                    IM_FMTLIST(1);
    IMGUI_API void          TextWrapped(const char* fmt, ...)                               IM_FMTARGS(1); // shortcut for PushTextWrapPos(0.0f); Text(fmt, ...); PopTextWrapPos();. Note that this won't work on an auto-resizing window if there's no other widgets to extend the window width, yoy may need to set a size using SetNextWindowSize().
    IMGUI_API void          TextWrappedV(const char* fmt, va_list args)                     IM_FMTLIST(1);
    IMGUI_API void          LabelText(const char* label, const char* fmt, ...)              IM_FMTARGS(2); // display text+label aligned the same way as value+label widgets
    IMGUI_API void          LabelTextV(const char* label, const char* fmt, va_list args)    IM_FMTLIST(2);
    IMGUI_API void          BulletText(const char* fmt, ...)                                IM_FMTARGS(1); // shortcut for Bullet()+Text()
    IMGUI_API void          BulletTextV(const char* fmt, va_list args)                      IM_FMTLIST(1);

    // Widgets: Main
    // - Most widgets return true when the value has been changed or when pressed/selected
    // - You may also use one of the many IsItemXXX functions (e.g. IsItemActive, IsItemHovered, etc.) to query widget state.
    IMGUI_API bool          Button(const char* label, const ImVec2& size = ImVec2(0,0));    // button
    IMGUI_API bool          SmallButton(const char* label);                                 // button with FramePadding=(0,0) to easily embed within text
    IMGUI_API bool          InvisibleButton(const char* str_id, const ImVec2& size);        // button behavior without the visuals, frequently useful to build custom behaviors using the public api (along with IsItemActive, IsItemHovered, etc.)
    IMGUI_API bool          ArrowButton(const char* str_id, ImGuiDir dir);                  // square button with an arrow shape
    IMGUI_API void          Image(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0 = ImVec2(0,0), const ImVec2& uv1 = ImVec2(1,1), const ImVec4& tint_col = ImVec4(1,1,1,1), const ImVec4& border_col = ImVec4(0,0,0,0));
    IMGUI_API bool          ImageButton(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0 = ImVec2(0,0),  const ImVec2& uv1 = ImVec2(1,1), int frame_padding = -1, const ImVec4& bg_col = ImVec4(0,0,0,0), const ImVec4& tint_col = ImVec4(1,1,1,1));    // <0 frame_padding uses default frame padding settings. 0 for no padding
    IMGUI_API bool          Checkbox(const char* label, bool* v);
    IMGUI_API bool          CheckboxFlags(const char* label, unsigned int* flags, unsigned int flags_value);
    IMGUI_API bool          RadioButton(const char* label, bool active);                    // use with e.g. if (RadioButton("one", my_value==1)) { my_value = 1; }
    IMGUI_API bool          RadioButton(const char* label, int* v, int v_button);           // shortcut to handle the above pattern when value is an integer
    IMGUI_API void          ProgressBar(float fraction, const ImVec2& size_arg = ImVec2(-1,0), const char* overlay = NULL);
    IMGUI_API void          Bullet();                                                       // draw a small circle and keep the cursor on the same line. advance cursor x position by GetTreeNodeToLabelSpacing(), same distance that TreeNode() uses

    // Widgets: Combo Box
    // - The BeginCombo()/EndCombo() api allows you to manage your contents and selection state however you want it, by creating e.g. Selectable() items.
    // - The old Combo() api are helpers over BeginCombo()/EndCombo() which are kept available for convenience purpose.
    IMGUI_API bool          BeginCombo(const char* label, const char* preview_value, ImGuiComboFlags flags = 0);
    IMGUI_API void          EndCombo(); // only call EndCombo() if BeginCombo() returns true!
    IMGUI_API bool          Combo(const char* label, int* current_item, const char* const items[], int items_count, int popup_max_height_in_items = -1);
    IMGUI_API bool          Combo(const char* label, int* current_item, const char* items_separated_by_zeros, int popup_max_height_in_items = -1);      // Separate items with \0 within a string, end item-list with \0\0. e.g. "One\0Two\0Three\0"
    IMGUI_API bool          Combo(const char* label, int* current_item, bool(*items_getter)(void* data, int idx, const char** out_text), void* data, int items_count, int popup_max_height_in_items = -1);

    // Widgets: Drags
    // - CTRL+Click on any drag box to turn them into an input box. Manually input values aren't clamped and can go off-bounds.
    // - For all the Float2/Float3/Float4/Int2/Int3/Int4 versions of every functions, note that a 'float v[X]' function argument is the same as 'float* v', the array syntax is just a way to document the number of elements that are expected to be accessible. You can pass address of your first element out of a contiguous set, e.g. &myvector.x
    // - Adjust format string to decorate the value with a prefix, a suffix, or adapt the editing and display precision e.g. "%.3f" -> 1.234; "%5.2f secs" -> 01.23 secs; "Biscuit: %.0f" -> Biscuit: 1; etc.
    // - Speed are per-pixel of mouse movement (v_speed=0.2f: mouse needs to move by 5 pixels to increase value by 1). For gamepad/keyboard navigation, minimum speed is Max(v_speed, minimum_step_at_given_precision).
    // - Use v_min < v_max to clamp edits to given limits. Note that CTRL+Click manual input can override those limits.
    // - Use v_max = FLT_MAX / INT_MAX etc to avoid clamping to a maximum, same with v_min = -FLT_MAX / INT_MIN to avoid clamping to a minimum.
    // - Use v_min > v_max to lock edits.
    IMGUI_API bool          DragFloat(const char* label, float* v, float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = "%.3f", float power = 1.0f);     // If v_min >= v_max we have no bound
    IMGUI_API bool          DragFloat2(const char* label, float v[2], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = "%.3f", float power = 1.0f);
    IMGUI_API bool          DragFloat3(const char* label, float v[3], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = "%.3f", float power = 1.0f);
    IMGUI_API bool          DragFloat4(const char* label, float v[4], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = "%.3f", float power = 1.0f);
    IMGUI_API bool          DragFloatRange2(const char* label, float* v_current_min, float* v_current_max, float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = "%.3f", const char* format_max = NULL, float power = 1.0f);
    IMGUI_API bool          DragInt(const char* label, int* v, float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = "%d");                                       // If v_min >= v_max we have no bound
    IMGUI_API bool          DragInt2(const char* label, int v[2], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = "%d");
    IMGUI_API bool          DragInt3(const char* label, int v[3], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = "%d");
    IMGUI_API bool          DragInt4(const char* label, int v[4], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = "%d");
    IMGUI_API bool          DragIntRange2(const char* label, int* v_current_min, int* v_current_max, float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = "%d", const char* format_max = NULL);
    IMGUI_API bool          DragScalar(const char* label, ImGuiDataType data_type, void* p_data, float v_speed, const void* p_min = NULL, const void* p_max = NULL, const char* format = NULL, float power = 1.0f);
    IMGUI_API bool          DragScalarN(const char* label, ImGuiDataType data_type, void* p_data, int components, float v_speed, const void* p_min = NULL, const void* p_max = NULL, const char* format = NULL, float power = 1.0f);

    // Widgets: Sliders
    // - CTRL+Click on any slider to turn them into an input box. Manually input values aren't clamped and can go off-bounds.
    // - Adjust format string to decorate the value with a prefix, a suffix, or adapt the editing and display precision e.g. "%.3f" -> 1.234; "%5.2f secs" -> 01.23 secs; "Biscuit: %.0f" -> Biscuit: 1; etc.
    IMGUI_API bool          SliderFloat(const char* label, float* v, float v_min, float v_max, const char* format = "%.3f", float power = 1.0f);     // adjust format to decorate the value with a prefix or a suffix for in-slider labels or unit display. Use power!=1.0 for power curve sliders
    IMGUI_API bool          SliderFloat2(const char* label, float v[2], float v_min, float v_max, const char* format = "%.3f", float power = 1.0f);
    IMGUI_API bool          SliderFloat3(const char* label, float v[3], float v_min, float v_max, const char* format = "%.3f", float power = 1.0f);
    IMGUI_API bool          SliderFloat4(const char* label, float v[4], float v_min, float v_max, const char* format = "%.3f", float power = 1.0f);
    IMGUI_API bool          SliderAngle(const char* label, float* v_rad, float v_degrees_min = -360.0f, float v_degrees_max = +360.0f, const char* format = "%.0f deg");
    IMGUI_API bool          SliderInt(const char* label, int* v, int v_min, int v_max, const char* format = "%d");
    IMGUI_API bool          SliderInt2(const char* label, int v[2], int v_min, int v_max, const char* format = "%d");
    IMGUI_API bool          SliderInt3(const char* label, int v[3], int v_min, int v_max, const char* format = "%d");
    IMGUI_API bool          SliderInt4(const char* label, int v[4], int v_min, int v_max, const char* format = "%d");
    IMGUI_API bool          SliderScalar(const char* label, ImGuiDataType data_type, void* p_data, const void* p_min, const void* p_max, const char* format = NULL, float power = 1.0f);
    IMGUI_API bool          SliderScalarN(const char* label, ImGuiDataType data_type, void* p_data, int components, const void* p_min, const void* p_max, const char* format = NULL, float power = 1.0f);
    IMGUI_API bool          VSliderFloat(const char* label, const ImVec2& size, float* v, float v_min, float v_max, const char* format = "%.3f", float power = 1.0f);
    IMGUI_API bool          VSliderInt(const char* label, const ImVec2& size, int* v, int v_min, int v_max, const char* format = "%d");
    IMGUI_API bool          VSliderScalar(const char* label, const ImVec2& size, ImGuiDataType data_type, void* p_data, const void* p_min, const void* p_max, const char* format = NULL, float power = 1.0f);

    // Widgets: Input with Keyboard
    // - If you want to use InputText() with a dynamic string type such as std::string or your own, see misc/cpp/imgui_stdlib.h
    // - Most of the ImGuiInputTextFlags flags are only useful for InputText() and not for InputFloatX, InputIntX, InputDouble etc.
    IMGUI_API bool          InputText(const char* label, char* buf, size_t buf_size, ImGuiInputTextFlags flags = 0, ImGuiInputTextCallback callback = NULL, void* user_data = NULL);
    IMGUI_API bool          InputTextMultiline(const char* label, char* buf, size_t buf_size, const ImVec2& size = ImVec2(0,0), ImGuiInputTextFlags flags = 0, ImGuiInputTextCallback callback = NULL, void* user_data = NULL);
    IMGUI_API bool          InputTextWithHint(const char* label, const char* hint, char* buf, size_t buf_size, ImGuiInputTextFlags flags = 0, ImGuiInputTextCallback callback = NULL, void* user_data = NULL);
    IMGUI_API bool          InputFloat(const char* label, float* v, float step = 0.0f, float step_fast = 0.0f, const char* format = "%.3f", ImGuiInputTextFlags flags = 0);
    IMGUI_API bool          InputFloat2(const char* label, float v[2], const char* format = "%.3f", ImGuiInputTextFlags flags = 0);
    IMGUI_API bool          InputFloat3(const char* label, float v[3], const char* format = "%.3f", ImGuiInputTextFlags flags = 0);
    IMGUI_API bool          InputFloat4(const char* label, float v[4], const char* format = "%.3f", ImGuiInputTextFlags flags = 0);
    IMGUI_API bool          InputInt(const char* label, int* v, int step = 1, int step_fast = 100, ImGuiInputTextFlags flags = 0);
    IMGUI_API bool          InputInt2(const char* label, int v[2], ImGuiInputTextFlags flags = 0);
    IMGUI_API bool          InputInt3(const char* label, int v[3], ImGuiInputTextFlags flags = 0);
    IMGUI_API bool          InputInt4(const char* label, int v[4], ImGuiInputTextFlags flags = 0);
    IMGUI_API bool          InputDouble(const char* label, double* v, double step = 0.0, double step_fast = 0.0, const char* format = "%.6f", ImGuiInputTextFlags flags = 0);
    IMGUI_API bool          InputScalar(const char* label, ImGuiDataType data_type, void* p_data, const void* p_step = NULL, const void* p_step_fast = NULL, const char* format = NULL, ImGuiInputTextFlags flags = 0);
    IMGUI_API bool          InputScalarN(const char* label, ImGuiDataType data_type, void* p_data, int components, const void* p_step = NULL, const void* p_step_fast = NULL, const char* format = NULL, ImGuiInputTextFlags flags = 0);

    // Widgets: Color Editor/Picker (tip: the ColorEdit* functions have a little colored preview square that can be left-clicked to open a picker, and right-clicked to open an option menu.)
    // - Note that in C++ a 'float v[X]' function argument is the _same_ as 'float* v', the array syntax is just a way to document the number of elements that are expected to be accessible.
    // - You can pass the address of a first float element out of a contiguous structure, e.g. &myvector.x
    IMGUI_API bool          ColorEdit3(const char* label, float col[3], ImGuiColorEditFlags flags = 0);
    IMGUI_API bool          ColorEdit4(const char* label, float col[4], ImGuiColorEditFlags flags = 0);
    IMGUI_API bool          ColorPicker3(const char* label, float col[3], ImGuiColorEditFlags flags = 0);
    IMGUI_API bool          ColorPicker4(const char* label, float col[4], ImGuiColorEditFlags flags = 0, const float* ref_col = NULL);
    IMGUI_API bool          ColorButton(const char* desc_id, const ImVec4& col, ImGuiColorEditFlags flags = 0, ImVec2 size = ImVec2(0,0));  // display a colored square/button, hover for details, return true when pressed.
    IMGUI_API void          SetColorEditOptions(ImGuiColorEditFlags flags);                     // initialize current options (generally on application startup) if you want to select a default format, picker type, etc. User will be able to change many settings, unless you pass the _NoOptions flag to your calls.

    // Widgets: Trees
    // - TreeNode functions return true when the node is open, in which case you need to also call TreePop() when you are finished displaying the tree node contents.
    IMGUI_API bool          TreeNode(const char* label);
    IMGUI_API bool          TreeNode(const char* str_id, const char* fmt, ...) IM_FMTARGS(2);   // helper variation to easily decorelate the id from the displayed string. Read the FAQ about why and how to use ID. to align arbitrary text at the same level as a TreeNode() you can use Bullet().
    IMGUI_API bool          TreeNode(const void* ptr_id, const char* fmt, ...) IM_FMTARGS(2);   // "
    IMGUI_API bool          TreeNodeV(const char* str_id, const char* fmt, va_list args) IM_FMTLIST(2);
    IMGUI_API bool          TreeNodeV(const void* ptr_id, const char* fmt, va_list args) IM_FMTLIST(2);
    IMGUI_API bool          TreeNodeEx(const char* label, ImGuiTreeNodeFlags flags = 0);
    IMGUI_API bool          TreeNodeEx(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, ...) IM_FMTARGS(3);
    IMGUI_API bool          TreeNodeEx(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, ...) IM_FMTARGS(3);
    IMGUI_API bool          TreeNodeExV(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args) IM_FMTLIST(3);
    IMGUI_API bool          TreeNodeExV(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args) IM_FMTLIST(3);
    IMGUI_API void          TreePush(const char* str_id);                                       // ~ Indent()+PushId(). Already called by TreeNode() when returning true, but you can call TreePush/TreePop yourself if desired.
    IMGUI_API void          TreePush(const void* ptr_id = NULL);                                // "
    IMGUI_API void          TreePop();                                                          // ~ Unindent()+PopId()
    IMGUI_API float         GetTreeNodeToLabelSpacing();                                        // horizontal distance preceding label when using TreeNode*() or Bullet() == (g.FontSize + style.FramePadding.x*2) for a regular unframed TreeNode
    IMGUI_API bool          CollapsingHeader(const char* label, ImGuiTreeNodeFlags flags = 0);  // if returning 'true' the header is open. doesn't indent nor push on ID stack. user doesn't have to call TreePop().
    IMGUI_API bool          CollapsingHeader(const char* label, bool* p_open, ImGuiTreeNodeFlags flags = 0); // when 'p_open' isn't NULL, display an additional small close button on upper right of the header
    IMGUI_API void          SetNextItemOpen(bool is_open, ImGuiCond cond = 0);                  // set next TreeNode/CollapsingHeader open state.

    // Widgets: Selectables
    // - A selectable highlights when hovered, and can display another color when selected.
    // - Neighbors selectable extend their highlight bounds in order to leave no gap between them. This is so a series of selected Selectable appear contiguous.
    IMGUI_API bool          Selectable(const char* label, bool selected = false, ImGuiSelectableFlags flags = 0, const ImVec2& size = ImVec2(0,0));  // "bool selected" carry the selection state (read-only). Selectable() is clicked is returns true so you can modify your selection state. size.x==0.0: use remaining width, size.x>0.0: specify width. size.y==0.0: use label height, size.y>0.0: specify height
    IMGUI_API bool          Selectable(const char* label, bool* p_selected, ImGuiSelectableFlags flags = 0, const ImVec2& size = ImVec2(0,0));       // "bool* p_selected" point to the selection state (read-write), as a convenient helper.

    // Widgets: List Boxes
    // - FIXME: To be consistent with all the newer API, ListBoxHeader/ListBoxFooter should in reality be called BeginListBox/EndListBox. Will rename them.
    IMGUI_API bool          ListBox(const char* label, int* current_item, const char* const items[], int items_count, int height_in_items = -1);
    IMGUI_API bool          ListBox(const char* label, int* current_item, bool (*items_getter)(void* data, int idx, const char** out_text), void* data, int items_count, int height_in_items = -1);
    IMGUI_API bool          ListBoxHeader(const char* label, const ImVec2& size = ImVec2(0,0)); // use if you want to reimplement ListBox() will custom data or interactions. if the function return true, you can output elements then call ListBoxFooter() afterwards.
    IMGUI_API bool          ListBoxHeader(const char* label, int items_count, int height_in_items = -1); // "
    IMGUI_API void          ListBoxFooter();                                                    // terminate the scrolling region. only call ListBoxFooter() if ListBoxHeader() returned true!

    // Widgets: Data Plotting
    IMGUI_API void          PlotLines(const char* label, const float* values, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0, 0), int stride = sizeof(float));
    IMGUI_API void          PlotLines(const char* label, float(*values_getter)(void* data, int idx), void* data, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0, 0));
    IMGUI_API void          PlotHistogram(const char* label, const float* values, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0, 0), int stride = sizeof(float));
    IMGUI_API void          PlotHistogram(const char* label, float(*values_getter)(void* data, int idx), void* data, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0, 0));

    // Widgets: Value() Helpers.
    // - Those are merely shortcut to calling Text() with a format string. Output single value in "name: value" format (tip: freely declare more in your code to handle your types. you can add functions to the ImGui namespace)
    IMGUI_API void          Value(const char* prefix, bool b);
    IMGUI_API void          Value(const char* prefix, int v);
    IMGUI_API void          Value(const char* prefix, unsigned int v);
    IMGUI_API void          Value(const char* prefix, float v, const char* float_format = NULL);

    // Widgets: Menus
    // - Use BeginMenuBar() on a window ImGuiWindowFlags_MenuBar to append to its menu bar.
    // - Use BeginMainMenuBar() to create a menu bar at the top of the screen.
    IMGUI_API bool          BeginMenuBar();                                                     // append to menu-bar of current window (requires ImGuiWindowFlags_MenuBar flag set on parent window).
    IMGUI_API void          EndMenuBar();                                                       // only call EndMenuBar() if BeginMenuBar() returns true!
    IMGUI_API bool          BeginMainMenuBar();                                                 // create and append to a full screen menu-bar.
    IMGUI_API void          EndMainMenuBar();                                                   // only call EndMainMenuBar() if BeginMainMenuBar() returns true!
    IMGUI_API bool          BeginMenu(const char* label, bool enabled = true);                  // create a sub-menu entry. only call EndMenu() if this returns true!
    IMGUI_API void          EndMenu();                                                          // only call EndMenu() if BeginMenu() returns true!
    IMGUI_API bool          MenuItem(const char* label, const char* shortcut = NULL, bool selected = false, bool enabled = true);  // return true when activated. shortcuts are displayed for convenience but not processed by ImGui at the moment
    IMGUI_API bool          MenuItem(const char* label, const char* shortcut, bool* p_selected, bool enabled = true);              // return true when activated + toggle (*p_selected) if p_selected != NULL

    // Tooltips
    // - Tooltip are windows following the mouse which do not take focus away.
    IMGUI_API void          BeginTooltip();                                                     // begin/append a tooltip window. to create full-featured tooltip (with any kind of items).
    IMGUI_API void          EndTooltip();
    IMGUI_API void          SetTooltip(const char* fmt, ...) IM_FMTARGS(1);                     // set a text-only tooltip, typically use with ImGui::IsItemHovered(). override any previous call to SetTooltip().
    IMGUI_API void          SetTooltipV(const char* fmt, va_list args) IM_FMTLIST(1);

    // Popups, Modals
    // The properties of popups windows are:
    // - They block normal mouse hovering detection outside them. (*)
    // - Unless modal, they can be closed by clicking anywhere outside them, or by pressing ESCAPE.
    // - Their visibility state (~bool) is held internally by imgui instead of being held by the programmer as we are used to with regular Begin() calls.
    //   User can manipulate the visibility state by calling OpenPopup().
    // - We default to use the right mouse (ImGuiMouseButton_Right=1) for the Popup Context functions.
    // (*) You can use IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup) to bypass it and detect hovering even when normally blocked by a popup.
    // Those three properties are connected. The library needs to hold their visibility state because it can close popups at any time.
    IMGUI_API void          OpenPopup(const char* str_id);                                      // call to mark popup as open (don't call every frame!). popups are closed when user click outside, or if CloseCurrentPopup() is called within a BeginPopup()/EndPopup() block. By default, Selectable()/MenuItem() are calling CloseCurrentPopup(). Popup identifiers are relative to the current ID-stack (so OpenPopup and BeginPopup needs to be at the same level).
    IMGUI_API bool          BeginPopup(const char* str_id, ImGuiWindowFlags flags = 0);                                             // return true if the popup is open, and you can start outputting to it. only call EndPopup() if BeginPopup() returns true!
    IMGUI_API bool          BeginPopupContextItem(const char* str_id = NULL, ImGuiMouseButton mouse_button = 1);                    // helper to open and begin popup when clicked on last item. if you can pass a NULL str_id only if the previous item had an id. If you want to use that on a non-interactive item such as Text() you need to pass in an explicit ID here. read comments in .cpp!
    IMGUI_API bool          BeginPopupContextWindow(const char* str_id = NULL, ImGuiMouseButton mouse_button = 1, bool also_over_items = true);  // helper to open and begin popup when clicked on current window.
    IMGUI_API bool          BeginPopupContextVoid(const char* str_id = NULL, ImGuiMouseButton mouse_button = 1);                    // helper to open and begin popup when clicked in void (where there are no imgui windows).
    IMGUI_API bool          BeginPopupModal(const char* name, bool* p_open = NULL, ImGuiWindowFlags flags = 0);                     // modal dialog (regular window with title bar, block interactions behind the modal window, can't close the modal window by clicking outside)
    IMGUI_API void          EndPopup();                                                                                             // only call EndPopup() if BeginPopupXXX() returns true!
    IMGUI_API bool          OpenPopupOnItemClick(const char* str_id = NULL, ImGuiMouseButton mouse_button = 1);                     // helper to open popup when clicked on last item (note: actually triggers on the mouse _released_ event to be consistent with popup behaviors). return true when just opened.
    IMGUI_API bool          IsPopupOpen(const char* str_id);                                    // return true if the popup is open at the current begin-ed level of the popup stack.
    IMGUI_API void          CloseCurrentPopup();                                                // close the popup we have begin-ed into. clicking on a MenuItem or Selectable automatically close the current popup.

    // Columns
    // - You can also use SameLine(pos_x) to mimic simplified columns.
    // - The columns API is work-in-progress and rather lacking (columns are arguably the worst part of dear imgui at the moment!)
    // - By end of the 2019 we will expose a new 'Table' api which will replace columns.
    IMGUI_API void          Columns(int count = 1, const char* id = NULL, bool border = true);
    IMGUI_API void          NextColumn();                                                       // next column, defaults to current row or next row if the current row is finished
    IMGUI_API int           GetColumnIndex();                                                   // get current column index
    IMGUI_API float         GetColumnWidth(int column_index = -1);                              // get column width (in pixels). pass -1 to use current column
    IMGUI_API void          SetColumnWidth(int column_index, float width);                      // set column width (in pixels). pass -1 to use current column
    IMGUI_API float         GetColumnOffset(int column_index = -1);                             // get position of column line (in pixels, from the left side of the contents region). pass -1 to use current column, otherwise 0..GetColumnsCount() inclusive. column 0 is typically 0.0f
    IMGUI_API void          SetColumnOffset(int column_index, float offset_x);                  // set position of column line (in pixels, from the left side of the contents region). pass -1 to use current column
    IMGUI_API int           GetColumnsCount();

    // Tab Bars, Tabs
    IMGUI_API bool          BeginTabBar(const char* str_id, ImGuiTabBarFlags flags = 0);        // create and append into a TabBar
    IMGUI_API void          EndTabBar();                                                        // only call EndTabBar() if BeginTabBar() returns true!
    IMGUI_API bool          BeginTabItem(const char* label, bool* p_open = NULL, ImGuiTabItemFlags flags = 0);// create a Tab. Returns true if the Tab is selected.
    IMGUI_API void          EndTabItem();                                                       // only call EndTabItem() if BeginTabItem() returns true!
    IMGUI_API void          SetTabItemClosed(const char* tab_or_docked_window_label);           // notify TabBar or Docking system of a closed tab/window ahead (useful to reduce visual flicker on reorderable tab bars). For tab-bar: call after BeginTabBar() and before Tab submissions. Otherwise call with a window name.

    // Logging/Capture
    // - All text output from the interface can be captured into tty/file/clipboard. By default, tree nodes are automatically opened during logging.
    IMGUI_API void          LogToTTY(int auto_open_depth = -1);                                 // start logging to tty (stdout)
    IMGUI_API void          LogToFile(int auto_open_depth = -1, const char* filename = NULL);   // start logging to file
    IMGUI_API void          LogToClipboard(int auto_open_depth = -1);                           // start logging to OS clipboard
    IMGUI_API void          LogFinish();                                                        // stop logging (close file, etc.)
    IMGUI_API void          LogButtons();                                                       // helper to display buttons for logging to tty/file/clipboard
    IMGUI_API void          LogText(const char* fmt, ...) IM_FMTARGS(1);                        // pass text data straight to log (without being displayed)

    // Drag and Drop
    // [BETA API] API may evolve!
    IMGUI_API bool          BeginDragDropSource(ImGuiDragDropFlags flags = 0);                                      // call when the current item is active. If this return true, you can call SetDragDropPayload() + EndDragDropSource()
    IMGUI_API bool          SetDragDropPayload(const char* type, const void* data, size_t sz, ImGuiCond cond = 0);  // type is a user defined string of maximum 32 characters. Strings starting with '_' are reserved for dear imgui internal types. Data is copied and held by imgui.
    IMGUI_API void          EndDragDropSource();                                                                    // only call EndDragDropSource() if BeginDragDropSource() returns true!
    IMGUI_API bool                  BeginDragDropTarget();                                                          // call after submitting an item that may receive a payload. If this returns true, you can call AcceptDragDropPayload() + EndDragDropTarget()
    IMGUI_API const ImGuiPayload*   AcceptDragDropPayload(const char* type, ImGuiDragDropFlags flags = 0);          // accept contents of a given type. If ImGuiDragDropFlags_AcceptBeforeDelivery is set you can peek into the payload before the mouse button is released.
    IMGUI_API void                  EndDragDropTarget();                                                            // only call EndDragDropTarget() if BeginDragDropTarget() returns true!
    IMGUI_API const ImGuiPayload*   GetDragDropPayload();                                                           // peek directly into the current payload from anywhere. may return NULL. use ImGuiPayload::IsDataType() to test for the payload type.

    // Clipping
    IMGUI_API void          PushClipRect(const ImVec2& clip_rect_min, const ImVec2& clip_rect_max, bool intersect_with_current_clip_rect);
    IMGUI_API void          PopClipRect();

    // Focus, Activation
    // - Prefer using "SetItemDefaultFocus()" over "if (IsWindowAppearing()) SetScrollHereY()" when applicable to signify "this is the default item"
    IMGUI_API void          SetItemDefaultFocus();                                              // make last item the default focused item of a window.
    IMGUI_API void          SetKeyboardFocusHere(int offset = 0);                               // focus keyboard on the next widget. Use positive 'offset' to access sub components of a multiple component widget. Use -1 to access previous widget.

    // Item/Widgets Utilities
    // - Most of the functions are referring to the last/previous item we submitted.
    // - See Demo Window under "Widgets->Querying Status" for an interactive visualization of most of those functions.
    IMGUI_API bool          IsItemHovered(ImGuiHoveredFlags flags = 0);                         // is the last item hovered? (and usable, aka not blocked by a popup, etc.). See ImGuiHoveredFlags for more options.
    IMGUI_API bool          IsItemActive();                                                     // is the last item active? (e.g. button being held, text field being edited. This will continuously return true while holding mouse button on an item. Items that don't interact will always return false)
    IMGUI_API bool          IsItemFocused();                                                    // is the last item focused for keyboard/gamepad navigation?
    IMGUI_API bool          IsItemClicked(ImGuiMouseButton mouse_button = 0);                   // is the last item clicked? (e.g. button/node just clicked on) == IsMouseClicked(mouse_button) && IsItemHovered()
    IMGUI_API bool          IsItemVisible();                                                    // is the last item visible? (items may be out of sight because of clipping/scrolling)
    IMGUI_API bool          IsItemEdited();                                                     // did the last item modify its underlying value this frame? or was pressed? This is generally the same as the "bool" return value of many widgets.
    IMGUI_API bool          IsItemActivated();                                                  // was the last item just made active (item was previously inactive).
    IMGUI_API bool          IsItemDeactivated();                                                // was the last item just made inactive (item was previously active). Useful for Undo/Redo patterns with widgets that requires continuous editing.
    IMGUI_API bool          IsItemDeactivatedAfterEdit();                                       // was the last item just made inactive and made a value change when it was active? (e.g. Slider/Drag moved). Useful for Undo/Redo patterns with widgets that requires continuous editing. Note that you may get false positives (some widgets such as Combo()/ListBox()/Selectable() will return true even when clicking an already selected item).
    IMGUI_API bool          IsItemToggledOpen();                                                // was the last item open state toggled? set by TreeNode().
    IMGUI_API bool          IsAnyItemHovered();                                                 // is any item hovered?
    IMGUI_API bool          IsAnyItemActive();                                                  // is any item active?
    IMGUI_API bool          IsAnyItemFocused();                                                 // is any item focused?
    IMGUI_API ImVec2        GetItemRectMin();                                                   // get upper-left bounding rectangle of the last item (screen space)
    IMGUI_API ImVec2        GetItemRectMax();                                                   // get lower-right bounding rectangle of the last item (screen space)
    IMGUI_API ImVec2        GetItemRectSize();                                                  // get size of last item
    IMGUI_API void          SetItemAllowOverlap();                                              // allow last item to be overlapped by a subsequent item. sometimes useful with invisible buttons, selectables, etc. to catch unused area.

    // Miscellaneous Utilities
    IMGUI_API bool          IsRectVisible(const ImVec2& size);                                  // test if rectangle (of given size, starting from cursor position) is visible / not clipped.
    IMGUI_API bool          IsRectVisible(const ImVec2& rect_min, const ImVec2& rect_max);      // test if rectangle (in screen space) is visible / not clipped. to perform coarse clipping on user's side.
    IMGUI_API double        GetTime();                                                          // get global imgui time. incremented by io.DeltaTime every frame.
    IMGUI_API int           GetFrameCount();                                                    // get global imgui frame count. incremented by 1 every frame.
    IMGUI_API ImDrawList*   GetBackgroundDrawList();                                            // this draw list will be the first rendering one. Useful to quickly draw shapes/text behind dear imgui contents.
    IMGUI_API ImDrawList*   GetForegroundDrawList();                                            // this draw list will be the last rendered one. Useful to quickly draw shapes/text over dear imgui contents.
    IMGUI_API ImDrawListSharedData* GetDrawListSharedData();                                    // you may use this when creating your own ImDrawList instances.
    IMGUI_API const char*   GetStyleColorName(ImGuiCol idx);                                    // get a string corresponding to the enum value (for display, saving, etc.).
    IMGUI_API void          SetStateStorage(ImGuiStorage* storage);                             // replace current window storage with our own (if you want to manipulate it yourself, typically clear subsection of it)
    IMGUI_API ImGuiStorage* GetStateStorage();
    IMGUI_API ImVec2        CalcTextSize(const char* text, const char* text_end = NULL, bool hide_text_after_double_hash = false, float wrap_width = -1.0f);
    IMGUI_API void          CalcListClipping(int items_count, float items_height, int* out_items_display_start, int* out_items_display_end);    // calculate coarse clipping for large list of evenly sized items. Prefer using the ImGuiListClipper higher-level helper if you can.
    IMGUI_API bool          BeginChildFrame(ImGuiID id, const ImVec2& size, ImGuiWindowFlags flags = 0); // helper to create a child window / scrolling region that looks like a normal widget frame
    IMGUI_API void          EndChildFrame();                                                    // always call EndChildFrame() regardless of BeginChildFrame() return values (which indicates a collapsed/clipped window)

    // Color Utilities
    IMGUI_API ImVec4        ColorConvertU32ToFloat4(ImU32 in);
    IMGUI_API ImU32         ColorConvertFloat4ToU32(const ImVec4& in);
    IMGUI_API void          ColorConvertRGBtoHSV(float r, float g, float b, float& out_h, float& out_s, float& out_v);
    IMGUI_API void          ColorConvertHSVtoRGB(float h, float s, float v, float& out_r, float& out_g, float& out_b);

    // Inputs Utilities: Keyboard
    // - For 'int user_key_index' you can use your own indices/enums according to how your backend/engine stored them in io.KeysDown[].
    // - We don't know the meaning of those value. You can use GetKeyIndex() to map a ImGuiKey_ value into the user index.
    IMGUI_API int           GetKeyIndex(ImGuiKey imgui_key);                                    // map ImGuiKey_* values into user's key index. == io.KeyMap[key]
    IMGUI_API bool          IsKeyDown(int user_key_index);                                      // is key being held. == io.KeysDown[user_key_index]. 
    IMGUI_API bool          IsKeyPressed(int user_key_index, bool repeat = true);               // was key pressed (went from !Down to Down)? if repeat=true, uses io.KeyRepeatDelay / KeyRepeatRate
    IMGUI_API bool          IsKeyReleased(int user_key_index);                                  // was key released (went from Down to !Down)?
    IMGUI_API int           GetKeyPressedAmount(int key_index, float repeat_delay, float rate); // uses provided repeat rate/delay. return a count, most often 0 or 1 but might be >1 if RepeatRate is small enough that DeltaTime > RepeatRate
    IMGUI_API void          CaptureKeyboardFromApp(bool want_capture_keyboard_value = true);    // attention: misleading name! manually override io.WantCaptureKeyboard flag next frame (said flag is entirely left for your application to handle). e.g. force capture keyboard when your widget is being hovered. This is equivalent to setting "io.WantCaptureKeyboard = want_capture_keyboard_value"; after the next NewFrame() call.

    // Inputs Utilities: Mouse
    // - To refer to a mouse button, you may use named enums in your code e.g. ImGuiMouseButton_Left, ImGuiMouseButton_Right.
    // - You can also use regular integer: it is forever guaranteed that 0=Left, 1=Right, 2=Middle.
    // - Dragging operations are only reported after mouse has moved a certain distance away from the initial clicking position (see 'lock_threshold' and 'io.MouseDraggingThreshold')
    IMGUI_API bool          IsMouseDown(ImGuiMouseButton button);                               // is mouse button held?
    IMGUI_API bool          IsMouseClicked(ImGuiMouseButton button, bool repeat = false);       // did mouse button clicked? (went from !Down to Down)
    IMGUI_API bool          IsMouseReleased(ImGuiMouseButton button);                           // did mouse button released? (went from Down to !Down)
    IMGUI_API bool          IsMouseDoubleClicked(ImGuiMouseButton button);                      // did mouse button double-clicked? a double-click returns false in IsMouseClicked(). uses io.MouseDoubleClickTime.
    IMGUI_API bool          IsMouseHoveringRect(const ImVec2& r_min, const ImVec2& r_max, bool clip = true);// is mouse hovering given bounding rect (in screen space). clipped by current clipping settings, but disregarding of other consideration of focus/window ordering/popup-block.
    IMGUI_API bool          IsMousePosValid(const ImVec2* mouse_pos = NULL);                    // by convention we use (-FLT_MAX,-FLT_MAX) to denote that there is no mouse available
    IMGUI_API bool          IsAnyMouseDown();                                                   // is any mouse button held?
    IMGUI_API ImVec2        GetMousePos();                                                      // shortcut to ImGui::GetIO().MousePos provided by user, to be consistent with other calls
    IMGUI_API ImVec2        GetMousePosOnOpeningCurrentPopup();                                 // retrieve mouse position at the time of opening popup we have BeginPopup() into (helper to avoid user backing that value themselves)
    IMGUI_API bool          IsMouseDragging(ImGuiMouseButton button, float lock_threshold = -1.0f);         // is mouse dragging? (if lock_threshold < -1.0f, uses io.MouseDraggingThreshold)
    IMGUI_API ImVec2        GetMouseDragDelta(ImGuiMouseButton button = 0, float lock_threshold = -1.0f);   // return the delta from the initial clicking position while the mouse button is pressed or was just released. This is locked and return 0.0f until the mouse moves past a distance threshold at least once (if lock_threshold < -1.0f, uses io.MouseDraggingThreshold)
    IMGUI_API void          ResetMouseDragDelta(ImGuiMouseButton button = 0);                   //
    IMGUI_API ImGuiMouseCursor GetMouseCursor();                                                // get desired cursor type, reset in ImGui::NewFrame(), this is updated during the frame. valid before Render(). If you use software rendering by setting io.MouseDrawCursor ImGui will render those for you
    IMGUI_API void          SetMouseCursor(ImGuiMouseCursor cursor_type);                       // set desired cursor type
    IMGUI_API void          CaptureMouseFromApp(bool want_capture_mouse_value = true);          // attention: misleading name! manually override io.WantCaptureMouse flag next frame (said flag is entirely left for your application to handle). This is equivalent to setting "io.WantCaptureMouse = want_capture_mouse_value;" after the next NewFrame() call.

    // Clipboard Utilities (also see the LogToClipboard() function to capture or output text data to the clipboard)
    IMGUI_API const char*   GetClipboardText();
    IMGUI_API void          SetClipboardText(const char* text);

    // Settings/.Ini Utilities
    // - The disk functions are automatically called if io.IniFilename != NULL (default is "imgui.ini").
    // - Set io.IniFilename to NULL to load/save manually. Read io.WantSaveIniSettings description about handling .ini saving manually.
    IMGUI_API void          LoadIniSettingsFromDisk(const char* ini_filename);                  // call after CreateContext() and before the first call to NewFrame(). NewFrame() automatically calls LoadIniSettingsFromDisk(io.IniFilename).
    IMGUI_API void          LoadIniSettingsFromMemory(const char* ini_data, size_t ini_size=0); // call after CreateContext() and before the first call to NewFrame() to provide .ini data from your own data source.
    IMGUI_API void          SaveIniSettingsToDisk(const char* ini_filename);                    // this is automatically called (if io.IniFilename is not empty) a few seconds after any modification that should be reflected in the .ini file (and also by DestroyContext).
    IMGUI_API const char*   SaveIniSettingsToMemory(size_t* out_ini_size = NULL);               // return a zero-terminated string with the .ini data which you can save by your own mean. call when io.WantSaveIniSettings is set, then save data by your own mean and clear io.WantSaveIniSettings.

    // Memory Allocators
    // - All those functions are not reliant on the current context.
    // - If you reload the contents of imgui.cpp at runtime, you may need to call SetCurrentContext() + SetAllocatorFunctions() again because we use global storage for those.
    IMGUI_API void          SetAllocatorFunctions(void* (*alloc_func)(size_t sz, void* user_data), void (*free_func)(void* ptr, void* user_data), void* user_data = NULL);
    IMGUI_API void*         MemAlloc(size_t size);
    IMGUI_API void          MemFree(void* ptr);

} // namespace ImGui

//-----------------------------------------------------------------------------
// Flags & Enumerations
//-----------------------------------------------------------------------------

// Flags for ImGui::Begin()
enum ImGuiWindowFlags_
{
    ImGuiWindowFlags_None                   = 0,
    ImGuiWindowFlags_NoTitleBar             = 1 << 0,   // Disable title-bar
    ImGuiWindowFlags_NoResize               = 1 << 1,   // Disable user resizing with the lower-right grip
    ImGuiWindowFlags_NoMove                 = 1 << 2,   // Disable user moving the window
    ImGuiWindowFlags_NoScrollbar            = 1 << 3,   // Disable scrollbars (window can still scroll with mouse or programmatically)
    ImGuiWindowFlags_NoScrollWithMouse      = 1 << 4,   // Disable user vertically scrolling with mouse wheel. On child window, mouse wheel will be forwarded to the parent unless NoScrollbar is also set.
    ImGuiWindowFlags_NoCollapse             = 1 << 5,   // Disable user collapsing window by double-clicking on it
    ImGuiWindowFlags_AlwaysAutoResize       = 1 << 6,   // Resize every window to its content every frame
    ImGuiWindowFlags_NoBackground           = 1 << 7,   // Disable drawing background color (WindowBg, etc.) and outside border. Similar as using SetNextWindowBgAlpha(0.0f).
    ImGuiWindowFlags_NoSavedSettings        = 1 << 8,   // Never load/save settings in .ini file
    ImGuiWindowFlags_NoMouseInputs          = 1 << 9,   // Disable catching mouse, hovering test with pass through.
    ImGuiWindowFlags_MenuBar                = 1 << 10,  // Has a menu-bar
    ImGuiWindowFlags_HorizontalScrollbar    = 1 << 11,  // Allow horizontal scrollbar to appear (off by default). You may use SetNextWindowContentSize(ImVec2(width,0.0f)); prior to calling Begin() to specify width. Read code in imgui_demo in the "Horizontal Scrolling" section.
    ImGuiWindowFlags_NoFocusOnAppearing     = 1 << 12,  // Disable taking focus when transitioning from hidden to visible state
    ImGuiWindowFlags_NoBringToFrontOnFocus  = 1 << 13,  // Disable bringing window to front when taking focus (e.g. clicking on it or programmatically giving it focus)
    ImGuiWindowFlags_AlwaysVerticalScrollbar= 1 << 14,  // Always show vertical scrollbar (even if ContentSize.y < Size.y)
    ImGuiWindowFlags_AlwaysHorizontalScrollbar=1<< 15,  // Always show horizontal scrollbar (even if ContentSize.x < Size.x)
    ImGuiWindowFlags_AlwaysUseWindowPadding = 1 << 16,  // Ensure child windows without border uses style.WindowPadding (ignored by default for non-bordered child windows, because more convenient)
    ImGuiWindowFlags_NoNavInputs            = 1 << 18,  // No gamepad/keyboard navigation within the window
    ImGuiWindowFlags_NoNavFocus             = 1 << 19,  // No focusing toward this window with gamepad/keyboard navigation (e.g. skipped by CTRL+TAB)
    ImGuiWindowFlags_UnsavedDocument        = 1 << 20,  // Append '*' to title without affecting the ID, as a convenience to avoid using the ### operator. When used in a tab/docking context, tab is selected on closure and closure is deferred by one frame to allow code to cancel the closure (with a confirmation popup, etc.) without flicker.
    ImGuiWindowFlags_NoNav                  = ImGuiWindowFlags_NoNavInputs | ImGuiWindowFlags_NoNavFocus,
    ImGuiWindowFlags_NoDecoration           = ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoCollapse,
    ImGuiWindowFlags_NoInputs               = ImGuiWindowFlags_NoMouseInputs | ImGuiWindowFlags_NoNavInputs | ImGuiWindowFlags_NoNavFocus,

    // [Internal]
    ImGuiWindowFlags_NavFlattened           = 1 << 23,  // [BETA] Allow gamepad/keyboard navigation to cross over parent border to this child (only use on child that have no scrolling!)
    ImGuiWindowFlags_ChildWindow            = 1 << 24,  // Don't use! For internal use by BeginChild()
    ImGuiWindowFlags_Tooltip                = 1 << 25,  // Don't use! For internal use by BeginTooltip()
    ImGuiWindowFlags_Popup                  = 1 << 26,  // Don't use! For internal use by BeginPopup()
    ImGuiWindowFlags_Modal                  = 1 << 27,  // Don't use! For internal use by BeginPopupModal()
    ImGuiWindowFlags_ChildMenu              = 1 << 28   // Don't use! For internal use by BeginMenu()

    // [Obsolete]
    //ImGuiWindowFlags_ShowBorders          = 1 << 7,   // --> Set style.FrameBorderSize=1.0f or style.WindowBorderSize=1.0f to enable borders around items or windows.
    //ImGuiWindowFlags_ResizeFromAnySide    = 1 << 17,  // --> Set io.ConfigWindowsResizeFromEdges=true and make sure mouse cursors are supported by back-end (io.BackendFlags & ImGuiBackendFlags_HasMouseCursors)
};

// Flags for ImGui::InputText()
enum ImGuiInputTextFlags_
{
    ImGuiInputTextFlags_None                = 0,
    ImGuiInputTextFlags_CharsDecimal        = 1 << 0,   // Allow 0123456789.+-*/
    ImGuiInputTextFlags_CharsHexadecimal    = 1 << 1,   // Allow 0123456789ABCDEFabcdef
    ImGuiInputTextFlags_CharsUppercase      = 1 << 2,   // Turn a..z into A..Z
    ImGuiInputTextFlags_CharsNoBlank        = 1 << 3,   // Filter out spaces, tabs
    ImGuiInputTextFlags_AutoSelectAll       = 1 << 4,   // Select entire text when first taking mouse focus
    ImGuiInputTextFlags_EnterReturnsTrue    = 1 << 5,   // Return 'true' when Enter is pressed (as opposed to every time the value was modified). Consider looking at the IsItemDeactivatedAfterEdit() function.
    ImGuiInputTextFlags_CallbackCompletion  = 1 << 6,   // Callback on pressing TAB (for completion handling)
    ImGuiInputTextFlags_CallbackHistory     = 1 << 7,   // Callback on pressing Up/Down arrows (for history handling)
    ImGuiInputTextFlags_CallbackAlways      = 1 << 8,   // Callback on each iteration. User code may query cursor position, modify text buffer.
    ImGuiInputTextFlags_CallbackCharFilter  = 1 << 9,   // Callback on character inputs to replace or discard them. Modify 'EventChar' to replace or discard, or return 1 in callback to discard.
    ImGuiInputTextFlags_AllowTabInput       = 1 << 10,  // Pressing TAB input a '\t' character into the text field
    ImGuiInputTextFlags_CtrlEnterForNewLine = 1 << 11,  // In multi-line mode, unfocus with Enter, add new line with Ctrl+Enter (default is opposite: unfocus with Ctrl+Enter, add line with Enter).
    ImGuiInputTextFlags_NoHorizontalScroll  = 1 << 12,  // Disable following the cursor horizontally
    ImGuiInputTextFlags_AlwaysInsertMode    = 1 << 13,  // Insert mode
    ImGuiInputTextFlags_ReadOnly            = 1 << 14,  // Read-only mode
    ImGuiInputTextFlags_Password            = 1 << 15,  // Password mode, display all characters as '*'
    ImGuiInputTextFlags_NoUndoRedo          = 1 << 16,  // Disable undo/redo. Note that input text owns the text data while active, if you want to provide your own undo/redo stack you need e.g. to call ClearActiveID().
    ImGuiInputTextFlags_CharsScientific     = 1 << 17,  // Allow 0123456789.+-*/eE (Scientific notation input)
    ImGuiInputTextFlags_CallbackResize      = 1 << 18,  // Callback on buffer capacity changes request (beyond 'buf_size' parameter value), allowing the string to grow. Notify when the string wants to be resized (for string types which hold a cache of their Size). You will be provided a new BufSize in the callback and NEED to honor it. (see misc/cpp/imgui_stdlib.h for an example of using this)
    // [Internal]
    ImGuiInputTextFlags_Multiline           = 1 << 20,  // For internal use by InputTextMultiline()
    ImGuiInputTextFlags_NoMarkEdited        = 1 << 21   // For internal use by functions using InputText() before reformatting data
};

// Flags for ImGui::TreeNodeEx(), ImGui::CollapsingHeader*()
enum ImGuiTreeNodeFlags_
{
    ImGuiTreeNodeFlags_None                 = 0,
    ImGuiTreeNodeFlags_Selected             = 1 << 0,   // Draw as selected
    ImGuiTreeNodeFlags_Framed               = 1 << 1,   // Full colored frame (e.g. for CollapsingHeader)
    ImGuiTreeNodeFlags_AllowItemOverlap     = 1 << 2,   // Hit testing to allow subsequent widgets to overlap this one
    ImGuiTreeNodeFlags_NoTreePushOnOpen     = 1 << 3,   // Don't do a TreePush() when open (e.g. for CollapsingHeader) = no extra indent nor pushing on ID stack
    ImGuiTreeNodeFlags_NoAutoOpenOnLog      = 1 << 4,   // Don't automatically and temporarily open node when Logging is active (by default logging will automatically open tree nodes)
    ImGuiTreeNodeFlags_DefaultOpen          = 1 << 5,   // Default node to be open
    ImGuiTreeNodeFlags_OpenOnDoubleClick    = 1 << 6,   // Need double-click to open node
    ImGuiTreeNodeFlags_OpenOnArrow          = 1 << 7,   // Only open when clicking on the arrow part. If ImGuiTreeNodeFlags_OpenOnDoubleClick is also set, single-click arrow or double-click all box to open.
    ImGuiTreeNodeFlags_Leaf                 = 1 << 8,   // No collapsing, no arrow (use as a convenience for leaf nodes).
    ImGuiTreeNodeFlags_Bullet               = 1 << 9,   // Display a bullet instead of arrow
    ImGuiTreeNodeFlags_FramePadding         = 1 << 10,  // Use FramePadding (even for an unframed text node) to vertically align text baseline to regular widget height. Equivalent to calling AlignTextToFramePadding().
    ImGuiTreeNodeFlags_SpanAvailWidth       = 1 << 11,  // Extend hit box to the right-most edge, even if not framed. This is not the default in order to allow adding other items on the same line. In the future we may refactor the hit system to be front-to-back, allowing natural overlaps and then this can become the default.
    ImGuiTreeNodeFlags_SpanFullWidth        = 1 << 12,  // Extend hit box to the left-most and right-most edges (bypass the indented area).
    ImGuiTreeNodeFlags_NavLeftJumpsBackHere = 1 << 13,  // (WIP) Nav: left direction may move to this TreeNode() from any of its child (items submitted between TreeNode and TreePop)
    //ImGuiTreeNodeFlags_NoScrollOnOpen     = 1 << 14,  // FIXME: TODO: Disable automatic scroll on TreePop() if node got just open and contents is not visible
    ImGuiTreeNodeFlags_CollapsingHeader     = ImGuiTreeNodeFlags_Framed | ImGuiTreeNodeFlags_NoTreePushOnOpen | ImGuiTreeNodeFlags_NoAutoOpenOnLog
};

// Flags for ImGui::Selectable()
enum ImGuiSelectableFlags_
{
    ImGuiSelectableFlags_None               = 0,
    ImGuiSelectableFlags_DontClosePopups    = 1 << 0,   // Clicking this don't close parent popup window
    ImGuiSelectableFlags_SpanAllColumns     = 1 << 1,   // Selectable frame can span all columns (text will still fit in current column)
    ImGuiSelectableFlags_AllowDoubleClick   = 1 << 2,   // Generate press events on double clicks too
    ImGuiSelectableFlags_Disabled           = 1 << 3,   // Cannot be selected, display grayed out text
    ImGuiSelectableFlags_AllowItemOverlap   = 1 << 4    // (WIP) Hit testing to allow subsequent widgets to overlap this one
};

// Flags for ImGui::BeginCombo()
enum ImGuiComboFlags_
{
    ImGuiComboFlags_None                    = 0,
    ImGuiComboFlags_PopupAlignLeft          = 1 << 0,   // Align the popup toward the left by default
    ImGuiComboFlags_HeightSmall             = 1 << 1,   // Max ~4 items visible. Tip: If you want your combo popup to be a specific size you can use SetNextWindowSizeConstraints() prior to calling BeginCombo()
    ImGuiComboFlags_HeightRegular           = 1 << 2,   // Max ~8 items visible (default)
    ImGuiComboFlags_HeightLarge             = 1 << 3,   // Max ~20 items visible
    ImGuiComboFlags_HeightLargest           = 1 << 4,   // As many fitting items as possible
    ImGuiComboFlags_NoArrowButton           = 1 << 5,   // Display on the preview box without the square arrow button
    ImGuiComboFlags_NoPreview               = 1 << 6,   // Display only a square arrow button
    ImGuiComboFlags_HeightMask_             = ImGuiComboFlags_HeightSmall | ImGuiComboFlags_HeightRegular | ImGuiComboFlags_HeightLarge | ImGuiComboFlags_HeightLargest
};

// Flags for ImGui::BeginTabBar()
enum ImGuiTabBarFlags_
{
    ImGuiTabBarFlags_None                           = 0,
    ImGuiTabBarFlags_Reorderable                    = 1 << 0,   // Allow manually dragging tabs to re-order them + New tabs are appended at the end of list
    ImGuiTabBarFlags_AutoSelectNewTabs              = 1 << 1,   // Automatically select new tabs when they appear
    ImGuiTabBarFlags_TabListPopupButton             = 1 << 2,   // Disable buttons to open the tab list popup
    ImGuiTabBarFlags_NoCloseWithMiddleMouseButton   = 1 << 3,   // Disable behavior of closing tabs (that are submitted with p_open != NULL) with middle mouse button. You can still repro this behavior on user's side with if (IsItemHovered() && IsMouseClicked(2)) *p_open = false.
    ImGuiTabBarFlags_NoTabListScrollingButtons      = 1 << 4,   // Disable scrolling buttons (apply when fitting policy is ImGuiTabBarFlags_FittingPolicyScroll)
    ImGuiTabBarFlags_NoTooltip                      = 1 << 5,   // Disable tooltips when hovering a tab
    ImGuiTabBarFlags_FittingPolicyResizeDown        = 1 << 6,   // Resize tabs when they don't fit
    ImGuiTabBarFlags_FittingPolicyScroll            = 1 << 7,   // Add scroll buttons when tabs don't fit
    ImGuiTabBarFlags_FittingPolicyMask_             = ImGuiTabBarFlags_FittingPolicyResizeDown | ImGuiTabBarFlags_FittingPolicyScroll,
    ImGuiTabBarFlags_FittingPolicyDefault_          = ImGuiTabBarFlags_FittingPolicyResizeDown
};

// Flags for ImGui::BeginTabItem()
enum ImGuiTabItemFlags_
{
    ImGuiTabItemFlags_None                          = 0,
    ImGuiTabItemFlags_UnsavedDocument               = 1 << 0,   // Append '*' to title without affecting the ID, as a convenience to avoid using the ### operator. Also: tab is selected on closure and closure is deferred by one frame to allow code to undo it without flicker.
    ImGuiTabItemFlags_SetSelected                   = 1 << 1,   // Trigger flag to programmatically make the tab selected when calling BeginTabItem()
    ImGuiTabItemFlags_NoCloseWithMiddleMouseButton  = 1 << 2,   // Disable behavior of closing tabs (that are submitted with p_open != NULL) with middle mouse button. You can still repro this behavior on user's side with if (IsItemHovered() && IsMouseClicked(2)) *p_open = false.
    ImGuiTabItemFlags_NoPushId                      = 1 << 3    // Don't call PushID(tab->ID)/PopID() on BeginTabItem()/EndTabItem()
};

// Flags for ImGui::IsWindowFocused()
enum ImGuiFocusedFlags_
{
    ImGuiFocusedFlags_None                          = 0,
    ImGuiFocusedFlags_ChildWindows                  = 1 << 0,   // IsWindowFocused(): Return true if any children of the window is focused
    ImGuiFocusedFlags_RootWindow                    = 1 << 1,   // IsWindowFocused(): Test from root window (top most parent of the current hierarchy)
    ImGuiFocusedFlags_AnyWindow                     = 1 << 2,   // IsWindowFocused(): Return true if any window is focused. Important: If you are trying to tell how to dispatch your low-level inputs, do NOT use this. Use ImGui::GetIO().WantCaptureMouse instead.
    ImGuiFocusedFlags_RootAndChildWindows           = ImGuiFocusedFlags_RootWindow | ImGuiFocusedFlags_ChildWindows
};

// Flags for ImGui::IsItemHovered(), ImGui::IsWindowHovered()
// Note: if you are trying to check whether your mouse should be dispatched to imgui or to your app, you should use the 'io.WantCaptureMouse' boolean for that. Please read the FAQ!
// Note: windows with the ImGuiWindowFlags_NoInputs flag are ignored by IsWindowHovered() calls.
enum ImGuiHoveredFlags_
{
    ImGuiHoveredFlags_None                          = 0,        // Return true if directly over the item/window, not obstructed by another window, not obstructed by an active popup or modal blocking inputs under them.
    ImGuiHoveredFlags_ChildWindows                  = 1 << 0,   // IsWindowHovered() only: Return true if any children of the window is hovered
    ImGuiHoveredFlags_RootWindow                    = 1 << 1,   // IsWindowHovered() only: Test from root window (top most parent of the current hierarchy)
    ImGuiHoveredFlags_AnyWindow                     = 1 << 2,   // IsWindowHovered() only: Return true if any window is hovered
    ImGuiHoveredFlags_AllowWhenBlockedByPopup       = 1 << 3,   // Return true even if a popup window is normally blocking access to this item/window
    //ImGuiHoveredFlags_AllowWhenBlockedByModal     = 1 << 4,   // Return true even if a modal popup window is normally blocking access to this item/window. FIXME-TODO: Unavailable yet.
    ImGuiHoveredFlags_AllowWhenBlockedByActiveItem  = 1 << 5,   // Return true even if an active item is blocking access to this item/window. Useful for Drag and Drop patterns.
    ImGuiHoveredFlags_AllowWhenOverlapped           = 1 << 6,   // Return true even if the position is obstructed or overlapped by another window
    ImGuiHoveredFlags_AllowWhenDisabled             = 1 << 7,   // Return true even if the item is disabled
    ImGuiHoveredFlags_RectOnly                      = ImGuiHoveredFlags_AllowWhenBlockedByPopup | ImGuiHoveredFlags_AllowWhenBlockedByActiveItem | ImGuiHoveredFlags_AllowWhenOverlapped,
    ImGuiHoveredFlags_RootAndChildWindows           = ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_ChildWindows
};

// Flags for ImGui::BeginDragDropSource(), ImGui::AcceptDragDropPayload()
enum ImGuiDragDropFlags_
{
    ImGuiDragDropFlags_None                         = 0,
    // BeginDragDropSource() flags
    ImGuiDragDropFlags_SourceNoPreviewTooltip       = 1 << 0,   // By default, a successful call to BeginDragDropSource opens a tooltip so you can display a preview or description of the source contents. This flag disable this behavior.
    ImGuiDragDropFlags_SourceNoDisableHover         = 1 << 1,   // By default, when dragging we clear data so that IsItemHovered() will return false, to avoid subsequent user code submitting tooltips. This flag disable this behavior so you can still call IsItemHovered() on the source item.
    ImGuiDragDropFlags_SourceNoHoldToOpenOthers     = 1 << 2,   // Disable the behavior that allows to open tree nodes and collapsing header by holding over them while dragging a source item.
    ImGuiDragDropFlags_SourceAllowNullID            = 1 << 3,   // Allow items such as Text(), Image() that have no unique identifier to be used as drag source, by manufacturing a temporary identifier based on their window-relative position. This is extremely unusual within the dear imgui ecosystem and so we made it explicit.
    ImGuiDragDropFlags_SourceExtern                 = 1 << 4,   // External source (from outside of dear imgui), won't attempt to read current item/window info. Will always return true. Only one Extern source can be active simultaneously.
    ImGuiDragDropFlags_SourceAutoExpirePayload      = 1 << 5,   // Automatically expire the payload if the source cease to be submitted (otherwise payloads are persisting while being dragged)
    // AcceptDragDropPayload() flags
    ImGuiDragDropFlags_AcceptBeforeDelivery         = 1 << 10,  // AcceptDragDropPayload() will returns true even before the mouse button is released. You can then call IsDelivery() to test if the payload needs to be delivered.
    ImGuiDragDropFlags_AcceptNoDrawDefaultRect      = 1 << 11,  // Do not draw the default highlight rectangle when hovering over target.
    ImGuiDragDropFlags_AcceptNoPreviewTooltip       = 1 << 12,  // Request hiding the BeginDragDropSource tooltip from the BeginDragDropTarget site.
    ImGuiDragDropFlags_AcceptPeekOnly               = ImGuiDragDropFlags_AcceptBeforeDelivery | ImGuiDragDropFlags_AcceptNoDrawDefaultRect  // For peeking ahead and inspecting the payload before delivery.
};

// Standard Drag and Drop payload types. You can define you own payload types using short strings. Types starting with '_' are defined by Dear ImGui.
#define IMGUI_PAYLOAD_TYPE_COLOR_3F     "_COL3F"    // float[3]: Standard type for colors, without alpha. User code may use this type.
#define IMGUI_PAYLOAD_TYPE_COLOR_4F     "_COL4F"    // float[4]: Standard type for colors. User code may use this type.

// A primary data type
enum ImGuiDataType_
{
    ImGuiDataType_S8,       // signed char / char (with sensible compilers)
    ImGuiDataType_U8,       // unsigned char
    ImGuiDataType_S16,      // short
    ImGuiDataType_U16,      // unsigned short
    ImGuiDataType_S32,      // int
    ImGuiDataType_U32,      // unsigned int
    ImGuiDataType_S64,      // long long / __int64
    ImGuiDataType_U64,      // unsigned long long / unsigned __int64
    ImGuiDataType_Float,    // float
    ImGuiDataType_Double,   // double
    ImGuiDataType_COUNT
};

// A cardinal direction
enum ImGuiDir_
{
    ImGuiDir_None    = -1,
    ImGuiDir_Left    = 0,
    ImGuiDir_Right   = 1,
    ImGuiDir_Up      = 2,
    ImGuiDir_Down    = 3,
    ImGuiDir_COUNT
};

// User fill ImGuiIO.KeyMap[] array with indices into the ImGuiIO.KeysDown[512] array
enum ImGuiKey_
{
    ImGuiKey_Tab,
    ImGuiKey_LeftArrow,
    ImGuiKey_RightArrow,
    ImGuiKey_UpArrow,
    ImGuiKey_DownArrow,
    ImGuiKey_PageUp,
    ImGuiKey_PageDown,
    ImGuiKey_Home,
    ImGuiKey_End,
    ImGuiKey_Insert,
    ImGuiKey_Delete,
    ImGuiKey_Backspace,
    ImGuiKey_Space,
    ImGuiKey_Enter,
    ImGuiKey_Escape,
    ImGuiKey_KeyPadEnter,
    ImGuiKey_A,                 // for text edit CTRL+A: select all
    ImGuiKey_C,                 // for text edit CTRL+C: copy
    ImGuiKey_V,                 // for text edit CTRL+V: paste
    ImGuiKey_X,                 // for text edit CTRL+X: cut
    ImGuiKey_Y,                 // for text edit CTRL+Y: redo
    ImGuiKey_Z,                 // for text edit CTRL+Z: undo
    ImGuiKey_COUNT
};

// Gamepad/Keyboard directional navigation
// Keyboard: Set io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard to enable. NewFrame() will automatically fill io.NavInputs[] based on your io.KeysDown[] + io.KeyMap[] arrays.
// Gamepad:  Set io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad to enable. Back-end: set ImGuiBackendFlags_HasGamepad and fill the io.NavInputs[] fields before calling NewFrame(). Note that io.NavInputs[] is cleared by EndFrame().
// Read instructions in imgui.cpp for more details. Download PNG/PSD at http://goo.gl/9LgVZW.
enum ImGuiNavInput_
{
    // Gamepad Mapping
    ImGuiNavInput_Activate,      // activate / open / toggle / tweak value       // e.g. Cross  (PS4), A (Xbox), A (Switch), Space (Keyboard)
    ImGuiNavInput_Cancel,        // cancel / close / exit                        // e.g. Circle (PS4), B (Xbox), B (Switch), Escape (Keyboard)
    ImGuiNavInput_Input,         // text input / on-screen keyboard              // e.g. Triang.(PS4), Y (Xbox), X (Switch), Return (Keyboard)
    ImGuiNavInput_Menu,          // tap: toggle menu / hold: focus, move, resize // e.g. Square (PS4), X (Xbox), Y (Switch), Alt (Keyboard)
    ImGuiNavInput_DpadLeft,      // move / tweak / resize window (w/ PadMenu)    // e.g. D-pad Left/Right/Up/Down (Gamepads), Arrow keys (Keyboard)
    ImGuiNavInput_DpadRight,     //
    ImGuiNavInput_DpadUp,        //
    ImGuiNavInput_DpadDown,      //
    ImGuiNavInput_LStickLeft,    // scroll / move window (w/ PadMenu)            // e.g. Left Analog Stick Left/Right/Up/Down
    ImGuiNavInput_LStickRight,   //
    ImGuiNavInput_LStickUp,      //
    ImGuiNavInput_LStickDown,    //
    ImGuiNavInput_FocusPrev,     // next window (w/ PadMenu)                     // e.g. L1 or L2 (PS4), LB or LT (Xbox), L or ZL (Switch)
    ImGuiNavInput_FocusNext,     // prev window (w/ PadMenu)                     // e.g. R1 or R2 (PS4), RB or RT (Xbox), R or ZL (Switch)
    ImGuiNavInput_TweakSlow,     // slower tweaks                                // e.g. L1 or L2 (PS4), LB or LT (Xbox), L or ZL (Switch)
    ImGuiNavInput_TweakFast,     // faster tweaks                                // e.g. R1 or R2 (PS4), RB or RT (Xbox), R or ZL (Switch)

    // [Internal] Don't use directly! This is used internally to differentiate keyboard from gamepad inputs for behaviors that require to differentiate them.
    // Keyboard behavior that have no corresponding gamepad mapping (e.g. CTRL+TAB) will be directly reading from io.KeysDown[] instead of io.NavInputs[].
    ImGuiNavInput_KeyMenu_,      // toggle menu                                  // = io.KeyAlt
    ImGuiNavInput_KeyLeft_,      // move left                                    // = Arrow keys
    ImGuiNavInput_KeyRight_,     // move right
    ImGuiNavInput_KeyUp_,        // move up
    ImGuiNavInput_KeyDown_,      // move down
    ImGuiNavInput_COUNT,
    ImGuiNavInput_InternalStart_ = ImGuiNavInput_KeyMenu_
};

// Configuration flags stored in io.ConfigFlags. Set by user/application.
enum ImGuiConfigFlags_
{
    ImGuiConfigFlags_None                   = 0,
    ImGuiConfigFlags_NavEnableKeyboard      = 1 << 0,   // Master keyboard navigation enable flag. NewFrame() will automatically fill io.NavInputs[] based on io.KeysDown[].
    ImGuiConfigFlags_NavEnableGamepad       = 1 << 1,   // Master gamepad navigation enable flag. This is mostly to instruct your imgui back-end to fill io.NavInputs[]. Back-end also needs to set ImGuiBackendFlags_HasGamepad.
    ImGuiConfigFlags_NavEnableSetMousePos   = 1 << 2,   // Instruct navigation to move the mouse cursor. May be useful on TV/console systems where moving a virtual mouse is awkward. Will update io.MousePos and set io.WantSetMousePos=true. If enabled you MUST honor io.WantSetMousePos requests in your binding, otherwise ImGui will react as if the mouse is jumping around back and forth.
    ImGuiConfigFlags_NavNoCaptureKeyboard   = 1 << 3,   // Instruct navigation to not set the io.WantCaptureKeyboard flag when io.NavActive is set.
    ImGuiConfigFlags_NoMouse                = 1 << 4,   // Instruct imgui to clear mouse position/buttons in NewFrame(). This allows ignoring the mouse information set by the back-end.
    ImGuiConfigFlags_NoMouseCursorChange    = 1 << 5,   // Instruct back-end to not alter mouse cursor shape and visibility. Use if the back-end cursor changes are interfering with yours and you don't want to use SetMouseCursor() to change mouse cursor. You may want to honor requests from imgui by reading GetMouseCursor() yourself instead.

    // User storage (to allow your back-end/engine to communicate to code that may be shared between multiple projects. Those flags are not used by core Dear ImGui)
    ImGuiConfigFlags_IsSRGB                 = 1 << 20,  // Application is SRGB-aware.
    ImGuiConfigFlags_IsTouchScreen          = 1 << 21   // Application is using a touch screen instead of a mouse.
};

// Back-end capabilities flags stored in io.BackendFlags. Set by imgui_impl_xxx or custom back-end.
enum ImGuiBackendFlags_
{
    ImGuiBackendFlags_None                  = 0,
    ImGuiBackendFlags_HasGamepad            = 1 << 0,   // Back-end Platform supports gamepad and currently has one connected.
    ImGuiBackendFlags_HasMouseCursors       = 1 << 1,   // Back-end Platform supports honoring GetMouseCursor() value to change the OS cursor shape.
    ImGuiBackendFlags_HasSetMousePos        = 1 << 2,   // Back-end Platform supports io.WantSetMousePos requests to reposition the OS mouse position (only used if ImGuiConfigFlags_NavEnableSetMousePos is set).
    ImGuiBackendFlags_RendererHasVtxOffset  = 1 << 3    // Back-end Renderer supports ImDrawCmd::VtxOffset. This enables output of large meshes (64K+ vertices) while still using 16-bit indices.
};

// Enumeration for PushStyleColor() / PopStyleColor()
enum ImGuiCol_
{
    ImGuiCol_Text,
    ImGuiCol_TextDisabled,
    ImGuiCol_WindowBg,              // Background of normal windows
    ImGuiCol_ChildBg,               // Background of child windows
    ImGuiCol_PopupBg,               // Background of popups, menus, tooltips windows
    ImGuiCol_Border,
    ImGuiCol_BorderShadow,
    ImGuiCol_FrameBg,               // Background of checkbox, radio button, plot, slider, text input
    ImGuiCol_FrameBgHovered,
    ImGuiCol_FrameBgActive,
    ImGuiCol_TitleBg,
    ImGuiCol_TitleBgActive,
    ImGuiCol_TitleBgCollapsed,
    ImGuiCol_MenuBarBg,
    ImGuiCol_ScrollbarBg,
    ImGuiCol_ScrollbarGrab,
    ImGuiCol_ScrollbarGrabHovered,
    ImGuiCol_ScrollbarGrabActive,
    ImGuiCol_CheckMark,
    ImGuiCol_SliderGrab,
    ImGuiCol_SliderGrabActive,
    ImGuiCol_Button,
    ImGuiCol_ButtonHovered,
    ImGuiCol_ButtonActive,
    ImGuiCol_Header,                // Header* colors are used for CollapsingHeader, TreeNode, Selectable, MenuItem
    ImGuiCol_HeaderHovered,
    ImGuiCol_HeaderActive,
    ImGuiCol_Separator,
    ImGuiCol_SeparatorHovered,
    ImGuiCol_SeparatorActive,
    ImGuiCol_ResizeGrip,
    ImGuiCol_ResizeGripHovered,
    ImGuiCol_ResizeGripActive,
    ImGuiCol_Tab,
    ImGuiCol_TabHovered,
    ImGuiCol_TabActive,
    ImGuiCol_TabUnfocused,
    ImGuiCol_TabUnfocusedActive,
    ImGuiCol_PlotLines,
    ImGuiCol_PlotLinesHovered,
    ImGuiCol_PlotHistogram,
    ImGuiCol_PlotHistogramHovered,
    ImGuiCol_TextSelectedBg,
    ImGuiCol_DragDropTarget,
    ImGuiCol_NavHighlight,          // Gamepad/keyboard: current highlighted item
    ImGuiCol_NavWindowingHighlight, // Highlight window when using CTRL+TAB
    ImGuiCol_NavWindowingDimBg,     // Darken/colorize entire screen behind the CTRL+TAB window list, when active
    ImGuiCol_ModalWindowDimBg,      // Darken/colorize entire screen behind a modal window, when one is active
    ImGuiCol_COUNT

    // Obsolete names (will be removed)
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
    , ImGuiCol_ModalWindowDarkening = ImGuiCol_ModalWindowDimBg                      // [renamed in 1.63]
    //, ImGuiCol_CloseButton, ImGuiCol_CloseButtonActive, ImGuiCol_CloseButtonHovered// [unused since 1.60+] the close button now uses regular button colors.
#endif
};

// Enumeration for PushStyleVar() / PopStyleVar() to temporarily modify the ImGuiStyle structure.
// NB: the enum only refers to fields of ImGuiStyle which makes sense to be pushed/popped inside UI code. During initialization, feel free to just poke into ImGuiStyle directly.
// NB: if changing this enum, you need to update the associated internal table GStyleVarInfo[] accordingly. This is where we link enum values to members offset/type.
enum ImGuiStyleVar_
{
    // Enum name --------------------- // Member in ImGuiStyle structure (see ImGuiStyle for descriptions)
    ImGuiStyleVar_Alpha,               // float     Alpha
    ImGuiStyleVar_WindowPadding,       // ImVec2    WindowPadding
    ImGuiStyleVar_WindowRounding,      // float     WindowRounding
    ImGuiStyleVar_WindowBorderSize,    // float     WindowBorderSize
    ImGuiStyleVar_WindowMinSize,       // ImVec2    WindowMinSize
    ImGuiStyleVar_WindowTitleAlign,    // ImVec2    WindowTitleAlign
    ImGuiStyleVar_ChildRounding,       // float     ChildRounding
    ImGuiStyleVar_ChildBorderSize,     // float     ChildBorderSize
    ImGuiStyleVar_PopupRounding,       // float     PopupRounding
    ImGuiStyleVar_PopupBorderSize,     // float     PopupBorderSize
    ImGuiStyleVar_FramePadding,        // ImVec2    FramePadding
    ImGuiStyleVar_FrameRounding,       // float     FrameRounding
    ImGuiStyleVar_FrameBorderSize,     // float     FrameBorderSize
    ImGuiStyleVar_ItemSpacing,         // ImVec2    ItemSpacing
    ImGuiStyleVar_ItemInnerSpacing,    // ImVec2    ItemInnerSpacing
    ImGuiStyleVar_IndentSpacing,       // float     IndentSpacing
    ImGuiStyleVar_ScrollbarSize,       // float     ScrollbarSize
    ImGuiStyleVar_ScrollbarRounding,   // float     ScrollbarRounding
    ImGuiStyleVar_GrabMinSize,         // float     GrabMinSize
    ImGuiStyleVar_GrabRounding,        // float     GrabRounding
    ImGuiStyleVar_TabRounding,         // float     TabRounding
    ImGuiStyleVar_ButtonTextAlign,     // ImVec2    ButtonTextAlign
    ImGuiStyleVar_SelectableTextAlign, // ImVec2    SelectableTextAlign
    ImGuiStyleVar_COUNT

    // Obsolete names (will be removed)
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
    , ImGuiStyleVar_Count_ = ImGuiStyleVar_COUNT                    // [renamed in 1.60]
#endif
};

// Flags for ColorEdit3() / ColorEdit4() / ColorPicker3() / ColorPicker4() / ColorButton()
enum ImGuiColorEditFlags_
{
    ImGuiColorEditFlags_None            = 0,
    ImGuiColorEditFlags_NoAlpha         = 1 << 1,   //              // ColorEdit, ColorPicker, ColorButton: ignore Alpha component (will only read 3 components from the input pointer).
    ImGuiColorEditFlags_NoPicker        = 1 << 2,   //              // ColorEdit: disable picker when clicking on colored square.
    ImGuiColorEditFlags_NoOptions       = 1 << 3,   //              // ColorEdit: disable toggling options menu when right-clicking on inputs/small preview.
    ImGuiColorEditFlags_NoSmallPreview  = 1 << 4,   //              // ColorEdit, ColorPicker: disable colored square preview next to the inputs. (e.g. to show only the inputs)
    ImGuiColorEditFlags_NoInputs        = 1 << 5,   //              // ColorEdit, ColorPicker: disable inputs sliders/text widgets (e.g. to show only the small preview colored square).
    ImGuiColorEditFlags_NoTooltip       = 1 << 6,   //              // ColorEdit, ColorPicker, ColorButton: disable tooltip when hovering the preview.
    ImGuiColorEditFlags_NoLabel         = 1 << 7,   //              // ColorEdit, ColorPicker: disable display of inline text label (the label is still forwarded to the tooltip and picker).
    ImGuiColorEditFlags_NoSidePreview   = 1 << 8,   //              // ColorPicker: disable bigger color preview on right side of the picker, use small colored square preview instead.
    ImGuiColorEditFlags_NoDragDrop      = 1 << 9,   //              // ColorEdit: disable drag and drop target. ColorButton: disable drag and drop source.

    // User Options (right-click on widget to change some of them).
    ImGuiColorEditFlags_AlphaBar        = 1 << 16,  //              // ColorEdit, ColorPicker: show vertical alpha bar/gradient in picker.
    ImGuiColorEditFlags_AlphaPreview    = 1 << 17,  //              // ColorEdit, ColorPicker, ColorButton: display preview as a transparent color over a checkerboard, instead of opaque.
    ImGuiColorEditFlags_AlphaPreviewHalf= 1 << 18,  //              // ColorEdit, ColorPicker, ColorButton: display half opaque / half checkerboard, instead of opaque.
    ImGuiColorEditFlags_HDR             = 1 << 19,  //              // (WIP) ColorEdit: Currently only disable 0.0f..1.0f limits in RGBA edition (note: you probably want to use ImGuiColorEditFlags_Float flag as well).
    ImGuiColorEditFlags_DisplayRGB      = 1 << 20,  // [Display]    // ColorEdit: override _display_ type among RGB/HSV/Hex. ColorPicker: select any combination using one or more of RGB/HSV/Hex.
    ImGuiColorEditFlags_DisplayHSV      = 1 << 21,  // [Display]    // "
    ImGuiColorEditFlags_DisplayHex      = 1 << 22,  // [Display]    // "
    ImGuiColorEditFlags_Uint8           = 1 << 23,  // [DataType]   // ColorEdit, ColorPicker, ColorButton: _display_ values formatted as 0..255.
    ImGuiColorEditFlags_Float           = 1 << 24,  // [DataType]   // ColorEdit, ColorPicker, ColorButton: _display_ values formatted as 0.0f..1.0f floats instead of 0..255 integers. No round-trip of value via integers.
    ImGuiColorEditFlags_PickerHueBar    = 1 << 25,  // [Picker]     // ColorPicker: bar for Hue, rectangle for Sat/Value.
    ImGuiColorEditFlags_PickerHueWheel  = 1 << 26,  // [Picker]     // ColorPicker: wheel for Hue, triangle for Sat/Value.
    ImGuiColorEditFlags_InputRGB        = 1 << 27,  // [Input]      // ColorEdit, ColorPicker: input and output data in RGB format.
    ImGuiColorEditFlags_InputHSV        = 1 << 28,  // [Input]      // ColorEdit, ColorPicker: input and output data in HSV format.

    // Defaults Options. You can set application defaults using SetColorEditOptions(). The intent is that you probably don't want to
    // override them in most of your calls. Let the user choose via the option menu and/or call SetColorEditOptions() once during startup.
    ImGuiColorEditFlags__OptionsDefault = ImGuiColorEditFlags_Uint8|ImGuiColorEditFlags_DisplayRGB|ImGuiColorEditFlags_InputRGB|ImGuiColorEditFlags_PickerHueBar,

    // [Internal] Masks
    ImGuiColorEditFlags__DisplayMask    = ImGuiColorEditFlags_DisplayRGB|ImGuiColorEditFlags_DisplayHSV|ImGuiColorEditFlags_DisplayHex,
    ImGuiColorEditFlags__DataTypeMask   = ImGuiColorEditFlags_Uint8|ImGuiColorEditFlags_Float,
    ImGuiColorEditFlags__PickerMask     = ImGuiColorEditFlags_PickerHueWheel|ImGuiColorEditFlags_PickerHueBar,
    ImGuiColorEditFlags__InputMask      = ImGuiColorEditFlags_InputRGB|ImGuiColorEditFlags_InputHSV

    // Obsolete names (will be removed)
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
    , ImGuiColorEditFlags_RGB = ImGuiColorEditFlags_DisplayRGB, ImGuiColorEditFlags_HSV = ImGuiColorEditFlags_DisplayHSV, ImGuiColorEditFlags_HEX = ImGuiColorEditFlags_DisplayHex  // [renamed in 1.69]
#endif
};

// Identify a mouse button. 
// Those values are guaranteed to be stable and we frequently use 0/1 directly. Named enums provided for convenience.
enum ImGuiMouseButton_
{
    ImGuiMouseButton_Left = 0,
    ImGuiMouseButton_Right = 1,
    ImGuiMouseButton_Middle = 2,
    ImGuiMouseButton_COUNT = 5
};

// Enumeration for GetMouseCursor()
// User code may request binding to display given cursor by calling SetMouseCursor(), which is why we have some cursors that are marked unused here
enum ImGuiMouseCursor_
{
    ImGuiMouseCursor_None = -1,
    ImGuiMouseCursor_Arrow = 0,
    ImGuiMouseCursor_TextInput,         // When hovering over InputText, etc.
    ImGuiMouseCursor_ResizeAll,         // (Unused by Dear ImGui functions)
    ImGuiMouseCursor_ResizeNS,          // When hovering over an horizontal border
    ImGuiMouseCursor_ResizeEW,          // When hovering over a vertical border or a column
    ImGuiMouseCursor_ResizeNESW,        // When hovering over the bottom-left corner of a window
    ImGuiMouseCursor_ResizeNWSE,        // When hovering over the bottom-right corner of a window
    ImGuiMouseCursor_Hand,              // (Unused by Dear ImGui functions. Use for e.g. hyperlinks)
    ImGuiMouseCursor_NotAllowed,        // When hovering something with disallowed interaction. Usually a crossed circle.
    ImGuiMouseCursor_COUNT

    // Obsolete names (will be removed)
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
    , ImGuiMouseCursor_Count_ = ImGuiMouseCursor_COUNT      // [renamed in 1.60]
#endif
};

// Enumateration for ImGui::SetWindow***(), SetNextWindow***(), SetNextItem***() functions
// Represent a condition.
// Important: Treat as a regular enum! Do NOT combine multiple values using binary operators! All the functions above treat 0 as a shortcut to ImGuiCond_Always.
enum ImGuiCond_
{
    ImGuiCond_Always        = 1 << 0,   // Set the variable
    ImGuiCond_Once          = 1 << 1,   // Set the variable once per runtime session (only the first call with succeed)
    ImGuiCond_FirstUseEver  = 1 << 2,   // Set the variable if the object/window has no persistently saved data (no entry in .ini file)
    ImGuiCond_Appearing     = 1 << 3    // Set the variable if the object/window is appearing after being hidden/inactive (or the first time)
};

//-----------------------------------------------------------------------------
// Helpers: Memory allocations macros
// IM_MALLOC(), IM_FREE(), IM_NEW(), IM_PLACEMENT_NEW(), IM_DELETE()
// We call C++ constructor on own allocated memory via the placement "new(ptr) Type()" syntax.
// Defining a custom placement new() with a dummy parameter allows us to bypass including <new> which on some platforms complains when user has disabled exceptions.
//-----------------------------------------------------------------------------

struct ImNewDummy {};
inline void* operator new(size_t, ImNewDummy, void* ptr) { return ptr; }
inline void  operator delete(void*, ImNewDummy, void*)   {} // This is only required so we can use the symmetrical new()
#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
#define IM_PLACEMENT_NEW(_PTR)              new(ImNewDummy(), _PTR)
#define IM_NEW(_TYPE)                       new(ImNewDummy(), ImGui::MemAlloc(sizeof(_TYPE))) _TYPE
template<typename T> void IM_DELETE(T* p)   { if (p) { p->~T(); ImGui::MemFree(p); } }

//-----------------------------------------------------------------------------
// Helper: ImVector<>
// Lightweight std::vector<>-like class to avoid dragging dependencies (also, some implementations of STL with debug enabled are absurdly slow, we bypass it so our code runs fast in debug).
//-----------------------------------------------------------------------------
// - You generally do NOT need to care or use this ever. But we need to make it available in imgui.h because some of our public structures are relying on it.
// - We use std-like naming convention here, which is a little unusual for this codebase.
// - Important: clear() frees memory, resize(0) keep the allocated buffer. We use resize(0) a lot to intentionally recycle allocated buffers across frames and amortize our costs.
// - Important: our implementation does NOT call C++ constructors/destructors, we treat everything as raw data! This is intentional but be extra mindful of that,
//   Do NOT use this class as a std::vector replacement in your own code! Many of the structures used by dear imgui can be safely initialized by a zero-memset.
//-----------------------------------------------------------------------------

template<typename T>
struct ImVector
{
    int                 Size;
    int                 Capacity;
    T*                  Data;

    // Provide standard typedefs but we don't use them ourselves.
    typedef T                   value_type;
    typedef value_type*         iterator;
    typedef const value_type*   const_iterator;

    // Constructors, destructor
    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
    inline ImVector(const ImVector<T>& src)                 { Size = Capacity = 0; Data = NULL; operator=(src); }
    inline ImVector<T>& operator=(const ImVector<T>& src)   { clear(); resize(src.Size); memcpy(Data, src.Data, (size_t)Size * sizeof(T)); return *this; }
    inline ~ImVector()                                      { if (Data) IM_FREE(Data); }

    inline bool         empty() const                       { return Size == 0; }
    inline int          size() const                        { return Size; }
    inline int          size_in_bytes() const               { return Size * (int)sizeof(T); }
    inline int          capacity() const                    { return Capacity; }
    inline T&           operator[](int i)                   { IM_ASSERT(i < Size); return Data[i]; }
    inline const T&     operator[](int i) const             { IM_ASSERT(i < Size); return Data[i]; }

    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }
    inline T*           begin()                             { return Data; }
    inline const T*     begin() const                       { return Data; }
    inline T*           end()                               { return Data + Size; }
    inline const T*     end() const                         { return Data + Size; }
    inline T&           front()                             { IM_ASSERT(Size > 0); return Data[0]; }
    inline const T&     front() const                       { IM_ASSERT(Size > 0); return Data[0]; }
    inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }
    inline const T&     back() const                        { IM_ASSERT(Size > 0); return Data[Size - 1]; }
    inline void         swap(ImVector<T>& rhs)              { int rhs_size = rhs.Size; rhs.Size = Size; Size = rhs_size; int rhs_cap = rhs.Capacity; rhs.Capacity = Capacity; Capacity = rhs_cap; T* rhs_data = rhs.Data; rhs.Data = Data; Data = rhs_data; }

    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > sz ? new_capacity : sz; }
    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
    inline void         resize(int new_size, const T& v)    { if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) memcpy(&Data[n], &v, sizeof(v)); Size = new_size; }
    inline void         shrink(int new_size)                { IM_ASSERT(new_size <= Size); Size = new_size; } // Resize a vector to a smaller size, guaranteed not to cause a reallocation
    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

    // NB: It is illegal to call push_back/push_front/insert with a reference pointing inside the ImVector data itself! e.g. v.push_back(v[10]) is forbidden.
    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
    inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }
    inline void         push_front(const T& v)              { if (Size == 0) push_back(v); else insert(Data, v); }
    inline T*           erase(const T* it)                  { IM_ASSERT(it >= Data && it < Data+Size); const ptrdiff_t off = it - Data; memmove(Data + off, Data + off + 1, ((size_t)Size - (size_t)off - 1) * sizeof(T)); Size--; return Data + off; }
    inline T*           erase(const T* it, const T* it_last){ IM_ASSERT(it >= Data && it < Data+Size && it_last > it && it_last <= Data+Size); const ptrdiff_t count = it_last - it; const ptrdiff_t off = it - Data; memmove(Data + off, Data + off + count, ((size_t)Size - (size_t)off - count) * sizeof(T)); Size -= (int)count; return Data + off; }
    inline T*           erase_unsorted(const T* it)         { IM_ASSERT(it >= Data && it < Data+Size);  const ptrdiff_t off = it - Data; if (it < Data+Size-1) memcpy(Data + off, Data + Size - 1, sizeof(T)); Size--; return Data + off; }
    inline T*           insert(const T* it, const T& v)     { IM_ASSERT(it >= Data && it <= Data+Size); const ptrdiff_t off = it - Data; if (Size == Capacity) reserve(_grow_capacity(Size + 1)); if (off < (int)Size) memmove(Data + off + 1, Data + off, ((size_t)Size - (size_t)off) * sizeof(T)); memcpy(&Data[off], &v, sizeof(v)); Size++; return Data + off; }
    inline bool         contains(const T& v) const          { const T* data = Data;  const T* data_end = Data + Size; while (data < data_end) if (*data++ == v) return true; return false; }
    inline T*           find(const T& v)                    { T* data = Data;  const T* data_end = Data + Size; while (data < data_end) if (*data == v) break; else ++data; return data; }
    inline const T*     find(const T& v) const              { const T* data = Data;  const T* data_end = Data + Size; while (data < data_end) if (*data == v) break; else ++data; return data; }
    inline bool         find_erase(const T& v)              { const T* it = find(v); if (it < Data + Size) { erase(it); return true; } return false; }
    inline bool         find_erase_unsorted(const T& v)     { const T* it = find(v); if (it < Data + Size) { erase_unsorted(it); return true; } return false; }
    inline int          index_from_ptr(const T* it) const   { IM_ASSERT(it >= Data && it < Data + Size); const ptrdiff_t off = it - Data; return (int)off; }
};

//-----------------------------------------------------------------------------
// ImGuiStyle
// You may modify the ImGui::GetStyle() main instance during initialization and before NewFrame().
// During the frame, use ImGui::PushStyleVar(ImGuiStyleVar_XXXX)/PopStyleVar() to alter the main style values,
// and ImGui::PushStyleColor(ImGuiCol_XXX)/PopStyleColor() for colors.
//-----------------------------------------------------------------------------

struct ImGuiStyle
{
    float       Alpha;                      // Global alpha applies to everything in Dear ImGui.
    ImVec2      WindowPadding;              // Padding within a window.
    float       WindowRounding;             // Radius of window corners rounding. Set to 0.0f to have rectangular windows.
    float       WindowBorderSize;           // Thickness of border around windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly).
    ImVec2      WindowMinSize;              // Minimum window size. This is a global setting. If you want to constraint individual windows, use SetNextWindowSizeConstraints().
    ImVec2      WindowTitleAlign;           // Alignment for title bar text. Defaults to (0.0f,0.5f) for left-aligned,vertically centered.
    ImGuiDir    WindowMenuButtonPosition;   // Side of the collapsing/docking button in the title bar (None/Left/Right). Defaults to ImGuiDir_Left.
    float       ChildRounding;              // Radius of child window corners rounding. Set to 0.0f to have rectangular windows.
    float       ChildBorderSize;            // Thickness of border around child windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly).
    float       PopupRounding;              // Radius of popup window corners rounding. (Note that tooltip windows use WindowRounding)
    float       PopupBorderSize;            // Thickness of border around popup/tooltip windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly).
    ImVec2      FramePadding;               // Padding within a framed rectangle (used by most widgets).
    float       FrameRounding;              // Radius of frame corners rounding. Set to 0.0f to have rectangular frame (used by most widgets).
    float       FrameBorderSize;            // Thickness of border around frames. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly).
    ImVec2      ItemSpacing;                // Horizontal and vertical spacing between widgets/lines.
    ImVec2      ItemInnerSpacing;           // Horizontal and vertical spacing between within elements of a composed widget (e.g. a slider and its label).
    ImVec2      TouchExtraPadding;          // Expand reactive bounding box for touch-based system where touch position is not accurate enough. Unfortunately we don't sort widgets so priority on overlap will always be given to the first widget. So don't grow this too much!
    float       IndentSpacing;              // Horizontal indentation when e.g. entering a tree node. Generally == (FontSize + FramePadding.x*2).
    float       ColumnsMinSpacing;          // Minimum horizontal spacing between two columns. Preferably > (FramePadding.x + 1).
    float       ScrollbarSize;              // Width of the vertical scrollbar, Height of the horizontal scrollbar.
    float       ScrollbarRounding;          // Radius of grab corners for scrollbar.
    float       GrabMinSize;                // Minimum width/height of a grab box for slider/scrollbar.
    float       GrabRounding;               // Radius of grabs corners rounding. Set to 0.0f to have rectangular slider grabs.
    float       TabRounding;                // Radius of upper corners of a tab. Set to 0.0f to have rectangular tabs.
    float       TabBorderSize;              // Thickness of border around tabs.
    ImGuiDir    ColorButtonPosition;        // Side of the color button in the ColorEdit4 widget (left/right). Defaults to ImGuiDir_Right.
    ImVec2      ButtonTextAlign;            // Alignment of button text when button is larger than text. Defaults to (0.5f, 0.5f) (centered).
    ImVec2      SelectableTextAlign;        // Alignment of selectable text when selectable is larger than text. Defaults to (0.0f, 0.0f) (top-left aligned).
    ImVec2      DisplayWindowPadding;       // Window position are clamped to be visible within the display area by at least this amount. Only applies to regular windows.
    ImVec2      DisplaySafeAreaPadding;     // If you cannot see the edges of your screen (e.g. on a TV) increase the safe area padding. Apply to popups/tooltips as well regular windows. NB: Prefer configuring your TV sets correctly!
    float       MouseCursorScale;           // Scale software rendered mouse cursor (when io.MouseDrawCursor is enabled). May be removed later.
    bool        AntiAliasedLines;           // Enable anti-aliasing on lines/borders. Disable if you are really tight on CPU/GPU.
    bool        AntiAliasedFill;            // Enable anti-aliasing on filled shapes (rounded rectangles, circles, etc.)
    float       CurveTessellationTol;       // Tessellation tolerance when using PathBezierCurveTo() without a specific number of segments. Decrease for highly tessellated curves (higher quality, more polygons), increase to reduce quality.
    ImVec4      Colors[ImGuiCol_COUNT];

    IMGUI_API ImGuiStyle();
    IMGUI_API void ScaleAllSizes(float scale_factor);
};

//-----------------------------------------------------------------------------
// ImGuiIO
// Communicate most settings and inputs/outputs to Dear ImGui using this structure.
// Access via ImGui::GetIO(). Read 'Programmer guide' section in .cpp file for general usage.
//-----------------------------------------------------------------------------

struct ImGuiIO
{
    //------------------------------------------------------------------
    // Configuration (fill once)                // Default value
    //------------------------------------------------------------------

    ImGuiConfigFlags   ConfigFlags;             // = 0              // See ImGuiConfigFlags_ enum. Set by user/application. Gamepad/keyboard navigation options, etc.
    ImGuiBackendFlags  BackendFlags;            // = 0              // See ImGuiBackendFlags_ enum. Set by back-end (imgui_impl_xxx files or custom back-end) to communicate features supported by the back-end.
    ImVec2      DisplaySize;                    // <unset>          // Main display size, in pixels.
    float       DeltaTime;                      // = 1.0f/60.0f     // Time elapsed since last frame, in seconds.
    float       IniSavingRate;                  // = 5.0f           // Minimum time between saving positions/sizes to .ini file, in seconds.
    const char* IniFilename;                    // = "imgui.ini"    // Path to .ini file. Set NULL to disable automatic .ini loading/saving, if e.g. you want to manually load/save from memory.
    const char* LogFilename;                    // = "imgui_log.txt"// Path to .log file (default parameter to ImGui::LogToFile when no file is specified).
    float       MouseDoubleClickTime;           // = 0.30f          // Time for a double-click, in seconds.
    float       MouseDoubleClickMaxDist;        // = 6.0f           // Distance threshold to stay in to validate a double-click, in pixels.
    float       MouseDragThreshold;             // = 6.0f           // Distance threshold before considering we are dragging.
    int         KeyMap[ImGuiKey_COUNT];         // <unset>          // Map of indices into the KeysDown[512] entries array which represent your "native" keyboard state.
    float       KeyRepeatDelay;                 // = 0.250f         // When holding a key/button, time before it starts repeating, in seconds (for buttons in Repeat mode, etc.).
    float       KeyRepeatRate;                  // = 0.050f         // When holding a key/button, rate at which it repeats, in seconds.
    void*       UserData;                       // = NULL           // Store your own data for retrieval by callbacks.

    ImFontAtlas*Fonts;                          // <auto>           // Font atlas: load, rasterize and pack one or more fonts into a single texture.
    float       FontGlobalScale;                // = 1.0f           // Global scale all fonts
    bool        FontAllowUserScaling;           // = false          // Allow user scaling text of individual window with CTRL+Wheel.
    ImFont*     FontDefault;                    // = NULL           // Font to use on NewFrame(). Use NULL to uses Fonts->Fonts[0].
    ImVec2      DisplayFramebufferScale;        // = (1, 1)         // For retina display or other situations where window coordinates are different from framebuffer coordinates. This generally ends up in ImDrawData::FramebufferScale.

    // Miscellaneous options
    bool        MouseDrawCursor;                // = false          // Request ImGui to draw a mouse cursor for you (if you are on a platform without a mouse cursor). Cannot be easily renamed to 'io.ConfigXXX' because this is frequently used by back-end implementations.
    bool        ConfigMacOSXBehaviors;          // = defined(__APPLE__) // OS X style: Text editing cursor movement using Alt instead of Ctrl, Shortcuts using Cmd/Super instead of Ctrl, Line/Text Start and End using Cmd+Arrows instead of Home/End, Double click selects by word instead of selecting whole text, Multi-selection in lists uses Cmd/Super instead of Ctrl (was called io.OptMacOSXBehaviors prior to 1.63)
    bool        ConfigInputTextCursorBlink;     // = true           // Set to false to disable blinking cursor, for users who consider it distracting. (was called: io.OptCursorBlink prior to 1.63)
    bool        ConfigWindowsResizeFromEdges;   // = true           // Enable resizing of windows from their edges and from the lower-left corner. This requires (io.BackendFlags & ImGuiBackendFlags_HasMouseCursors) because it needs mouse cursor feedback. (This used to be a per-window ImGuiWindowFlags_ResizeFromAnySide flag)
    bool        ConfigWindowsMoveFromTitleBarOnly; // = false       // [BETA] Set to true to only allow moving windows when clicked+dragged from the title bar. Windows without a title bar are not affected.
    float       ConfigWindowsMemoryCompactTimer;// = 60.0f          // [BETA] Compact window memory usage when unused. Set to -1.0f to disable.

    //------------------------------------------------------------------
    // Platform Functions
    // (the imgui_impl_xxxx back-end files are setting those up for you)
    //------------------------------------------------------------------

    // Optional: Platform/Renderer back-end name (informational only! will be displayed in About Window) + User data for back-end/wrappers to store their own stuff.
    const char* BackendPlatformName;            // = NULL
    const char* BackendRendererName;            // = NULL
    void*       BackendPlatformUserData;        // = NULL           // User data for platform back-end
    void*       BackendRendererUserData;        // = NULL           // User data for renderer back-end
    void*       BackendLanguageUserData;        // = NULL           // User data for non C++ programming language back-end

    // Optional: Access OS clipboard
    // (default to use native Win32 clipboard on Windows, otherwise uses a private clipboard. Override to access OS clipboard on other architectures)
    const char* (*GetClipboardTextFn)(void* user_data);
    void        (*SetClipboardTextFn)(void* user_data, const char* text);
    void*       ClipboardUserData;

    // Optional: Notify OS Input Method Editor of the screen position of your cursor for text input position (e.g. when using Japanese/Chinese IME on Windows)
    // (default to use native imm32 api on Windows)
    void        (*ImeSetInputScreenPosFn)(int x, int y);
    void*       ImeWindowHandle;                // = NULL           // (Windows) Set this to your HWND to get automatic IME cursor positioning.

#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
    // [OBSOLETE since 1.60+] Rendering function, will be automatically called in Render(). Please call your rendering function yourself now!
    // You can obtain the ImDrawData* by calling ImGui::GetDrawData() after Render(). See example applications if you are unsure of how to implement this.
    void        (*RenderDrawListsFn)(ImDrawData* data);
#else
    // This is only here to keep ImGuiIO the same size/layout, so that IMGUI_DISABLE_OBSOLETE_FUNCTIONS can exceptionally be used outside of imconfig.h.
    void*       RenderDrawListsFnUnused;
#endif

    //------------------------------------------------------------------
    // Input - Fill before calling NewFrame()
    //------------------------------------------------------------------

    ImVec2      MousePos;                       // Mouse position, in pixels. Set to ImVec2(-FLT_MAX,-FLT_MAX) if mouse is unavailable (on another screen, etc.)
    bool        MouseDown[5];                   // Mouse buttons: 0=left, 1=right, 2=middle + extras. ImGui itself mostly only uses left button (BeginPopupContext** are using right button). Others buttons allows us to track if the mouse is being used by your application + available to user as a convenience via IsMouse** API.
    float       MouseWheel;                     // Mouse wheel Vertical: 1 unit scrolls about 5 lines text.
    float       MouseWheelH;                    // Mouse wheel Horizontal. Most users don't have a mouse with an horizontal wheel, may not be filled by all back-ends.
    bool        KeyCtrl;                        // Keyboard modifier pressed: Control
    bool        KeyShift;                       // Keyboard modifier pressed: Shift
    bool        KeyAlt;                         // Keyboard modifier pressed: Alt
    bool        KeySuper;                       // Keyboard modifier pressed: Cmd/Super/Windows
    bool        KeysDown[512];                  // Keyboard keys that are pressed (ideally left in the "native" order your engine has access to keyboard keys, so you can use your own defines/enums for keys).
    float       NavInputs[ImGuiNavInput_COUNT]; // Gamepad inputs. Cleared back to zero by EndFrame(). Keyboard keys will be auto-mapped and be written here by NewFrame().

    // Functions
    IMGUI_API void  AddInputCharacter(unsigned int c);          // Queue new character input
    IMGUI_API void  AddInputCharactersUTF8(const char* str);    // Queue new characters input from an UTF-8 string
    IMGUI_API void  ClearInputCharacters();                     // Clear the text input buffer manually

    //------------------------------------------------------------------
    // Output - Retrieve after calling NewFrame()
    //------------------------------------------------------------------

    bool        WantCaptureMouse;               // When io.WantCaptureMouse is true, imgui will use the mouse inputs, do not dispatch them to your main game/application (in both cases, always pass on mouse inputs to imgui). (e.g. unclicked mouse is hovering over an imgui window, widget is active, mouse was clicked over an imgui window, etc.).
    bool        WantCaptureKeyboard;            // When io.WantCaptureKeyboard is true, imgui will use the keyboard inputs, do not dispatch them to your main game/application (in both cases, always pass keyboard inputs to imgui). (e.g. InputText active, or an imgui window is focused and navigation is enabled, etc.).
    bool        WantTextInput;                  // Mobile/console: when io.WantTextInput is true, you may display an on-screen keyboard. This is set by ImGui when it wants textual keyboard input to happen (e.g. when a InputText widget is active).
    bool        WantSetMousePos;                // MousePos has been altered, back-end should reposition mouse on next frame. Set only when ImGuiConfigFlags_NavEnableSetMousePos flag is enabled.
    bool        WantSaveIniSettings;            // When manual .ini load/save is active (io.IniFilename == NULL), this will be set to notify your application that you can call SaveIniSettingsToMemory() and save yourself. IMPORTANT: You need to clear io.WantSaveIniSettings yourself.
    bool        NavActive;                      // Directional navigation is currently allowed (will handle ImGuiKey_NavXXX events) = a window is focused and it doesn't use the ImGuiWindowFlags_NoNavInputs flag.
    bool        NavVisible;                     // Directional navigation is visible and allowed (will handle ImGuiKey_NavXXX events).
    float       Framerate;                      // Application framerate estimation, in frame per second. Solely for convenience. Rolling average estimation based on IO.DeltaTime over 120 frames
    int         MetricsRenderVertices;          // Vertices output during last call to Render()
    int         MetricsRenderIndices;           // Indices output during last call to Render() = number of triangles * 3
    int         MetricsRenderWindows;           // Number of visible windows
    int         MetricsActiveWindows;           // Number of active windows
    int         MetricsActiveAllocations;       // Number of active allocations, updated by MemAlloc/MemFree based on current context. May be off if you have multiple imgui contexts.
    ImVec2      MouseDelta;                     // Mouse delta. Note that this is zero if either current or previous position are invalid (-FLT_MAX,-FLT_MAX), so a disappearing/reappearing mouse won't have a huge delta.

    //------------------------------------------------------------------
    // [Internal] Dear ImGui will maintain those fields. Forward compatibility not guaranteed!
    //------------------------------------------------------------------

    ImVec2      MousePosPrev;                   // Previous mouse position (note that MouseDelta is not necessary == MousePos-MousePosPrev, in case either position is invalid)
    ImVec2      MouseClickedPos[5];             // Position at time of clicking
    double      MouseClickedTime[5];            // Time of last click (used to figure out double-click)
    bool        MouseClicked[5];                // Mouse button went from !Down to Down
    bool        MouseDoubleClicked[5];          // Has mouse button been double-clicked?
    bool        MouseReleased[5];               // Mouse button went from Down to !Down
    bool        MouseDownOwned[5];              // Track if button was clicked inside a dear imgui window. We don't request mouse capture from the application if click started outside ImGui bounds.
    bool        MouseDownWasDoubleClick[5];     // Track if button down was a double-click
    float       MouseDownDuration[5];           // Duration the mouse button has been down (0.0f == just clicked)
    float       MouseDownDurationPrev[5];       // Previous time the mouse button has been down
    ImVec2      MouseDragMaxDistanceAbs[5];     // Maximum distance, absolute, on each axis, of how much mouse has traveled from the clicking point
    float       MouseDragMaxDistanceSqr[5];     // Squared maximum distance of how much mouse has traveled from the clicking point
    float       KeysDownDuration[512];          // Duration the keyboard key has been down (0.0f == just pressed)
    float       KeysDownDurationPrev[512];      // Previous duration the key has been down
    float       NavInputsDownDuration[ImGuiNavInput_COUNT];
    float       NavInputsDownDurationPrev[ImGuiNavInput_COUNT];
    ImVector<ImWchar> InputQueueCharacters;     // Queue of _characters_ input (obtained by platform back-end). Fill using AddInputCharacter() helper.

    IMGUI_API   ImGuiIO();
};

//-----------------------------------------------------------------------------
// Misc data structures
//-----------------------------------------------------------------------------

// Shared state of InputText(), passed as an argument to your callback when a ImGuiInputTextFlags_Callback* flag is used.
// The callback function should return 0 by default.
// Callbacks (follow a flag name and see comments in ImGuiInputTextFlags_ declarations for more details)
// - ImGuiInputTextFlags_CallbackCompletion:  Callback on pressing TAB
// - ImGuiInputTextFlags_CallbackHistory:     Callback on pressing Up/Down arrows
// - ImGuiInputTextFlags_CallbackAlways:      Callback on each iteration
// - ImGuiInputTextFlags_CallbackCharFilter:  Callback on character inputs to replace or discard them. Modify 'EventChar' to replace or discard, or return 1 in callback to discard.
// - ImGuiInputTextFlags_CallbackResize:      Callback on buffer capacity changes request (beyond 'buf_size' parameter value), allowing the string to grow.
struct ImGuiInputTextCallbackData
{
    ImGuiInputTextFlags EventFlag;      // One ImGuiInputTextFlags_Callback*    // Read-only
    ImGuiInputTextFlags Flags;          // What user passed to InputText()      // Read-only
    void*               UserData;       // What user passed to InputText()      // Read-only

    // Arguments for the different callback events
    // - To modify the text buffer in a callback, prefer using the InsertChars() / DeleteChars() function. InsertChars() will take care of calling the resize callback if necessary.
    // - If you know your edits are not going to resize the underlying buffer allocation, you may modify the contents of 'Buf[]' directly. You need to update 'BufTextLen' accordingly (0 <= BufTextLen < BufSize) and set 'BufDirty'' to true so InputText can update its internal state.
    ImWchar             EventChar;      // Character input                      // Read-write   // [CharFilter] Replace character with another one, or set to zero to drop. return 1 is equivalent to setting EventChar=0;
    ImGuiKey            EventKey;       // Key pressed (Up/Down/TAB)            // Read-only    // [Completion,History]
    char*               Buf;            // Text buffer                          // Read-write   // [Resize] Can replace pointer / [Completion,History,Always] Only write to pointed data, don't replace the actual pointer!
    int                 BufTextLen;     // Text length (in bytes)               // Read-write   // [Resize,Completion,History,Always] Exclude zero-terminator storage. In C land: == strlen(some_text), in C++ land: string.length()
    int                 BufSize;        // Buffer size (in bytes) = capacity+1  // Read-only    // [Resize,Completion,History,Always] Include zero-terminator storage. In C land == ARRAYSIZE(my_char_array), in C++ land: string.capacity()+1
    bool                BufDirty;       // Set if you modify Buf/BufTextLen!    // Write        // [Completion,History,Always]
    int                 CursorPos;      //                                      // Read-write   // [Completion,History,Always]
    int                 SelectionStart; //                                      // Read-write   // [Completion,History,Always] == to SelectionEnd when no selection)
    int                 SelectionEnd;   //                                      // Read-write   // [Completion,History,Always]

    // Helper functions for text manipulation.
    // Use those function to benefit from the CallbackResize behaviors. Calling those function reset the selection.
    IMGUI_API ImGuiInputTextCallbackData();
    IMGUI_API void      DeleteChars(int pos, int bytes_count);
    IMGUI_API void      InsertChars(int pos, const char* text, const char* text_end = NULL);
    bool                HasSelection() const { return SelectionStart != SelectionEnd; }
};

// Resizing callback data to apply custom constraint. As enabled by SetNextWindowSizeConstraints(). Callback is called during the next Begin().
// NB: For basic min/max size constraint on each axis you don't need to use the callback! The SetNextWindowSizeConstraints() parameters are enough.
struct ImGuiSizeCallbackData
{
    void*   UserData;       // Read-only.   What user passed to SetNextWindowSizeConstraints()
    ImVec2  Pos;            // Read-only.   Window position, for reference.
    ImVec2  CurrentSize;    // Read-only.   Current window size.
    ImVec2  DesiredSize;    // Read-write.  Desired size, based on user's mouse position. Write to this field to restrain resizing.
};

// Data payload for Drag and Drop operations: AcceptDragDropPayload(), GetDragDropPayload()
struct ImGuiPayload
{
    // Members
    void*           Data;               // Data (copied and owned by dear imgui)
    int             DataSize;           // Data size

    // [Internal]
    ImGuiID         SourceId;           // Source item id
    ImGuiID         SourceParentId;     // Source parent id (if available)
    int             DataFrameCount;     // Data timestamp
    char            DataType[32+1];     // Data type tag (short user-supplied string, 32 characters max)
    bool            Preview;            // Set when AcceptDragDropPayload() was called and mouse has been hovering the target item (nb: handle overlapping drag targets)
    bool            Delivery;           // Set when AcceptDragDropPayload() was called and mouse button is released over the target item.

    ImGuiPayload()  { Clear(); }
    void Clear()    { SourceId = SourceParentId = 0; Data = NULL; DataSize = 0; memset(DataType, 0, sizeof(DataType)); DataFrameCount = -1; Preview = Delivery = false; }
    bool IsDataType(const char* type) const { return DataFrameCount != -1 && strcmp(type, DataType) == 0; }
    bool IsPreview() const                  { return Preview; }
    bool IsDelivery() const                 { return Delivery; }
};

//-----------------------------------------------------------------------------
// Obsolete functions (Will be removed! Read 'API BREAKING CHANGES' section in imgui.cpp for details)
// Please keep your copy of dear imgui up to date! Occasionally set '#define IMGUI_DISABLE_OBSOLETE_FUNCTIONS' in imconfig.h to stay ahead.
//-----------------------------------------------------------------------------

#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
namespace ImGui
{
    // OBSOLETED in 1.72 (from July 2019)
    static inline void  TreeAdvanceToLabelPos()               { SetCursorPosX(GetCursorPosX() + GetTreeNodeToLabelSpacing()); }
    // OBSOLETED in 1.71 (from June 2019)
    static inline void  SetNextTreeNodeOpen(bool open, ImGuiCond cond = 0) { SetNextItemOpen(open, cond); }
    // OBSOLETED in 1.70 (from May 2019)
    static inline float GetContentRegionAvailWidth()          { return GetContentRegionAvail().x; }
    // OBSOLETED in 1.69 (from Mar 2019)
    static inline ImDrawList* GetOverlayDrawList()            { return GetForegroundDrawList(); }
    // OBSOLETED in 1.66 (from Sep 2018)
    static inline void  SetScrollHere(float center_ratio=0.5f){ SetScrollHereY(center_ratio); }
    // OBSOLETED in 1.63 (between Aug 2018 and Sept 2018)
    static inline bool  IsItemDeactivatedAfterChange()        { return IsItemDeactivatedAfterEdit(); }
    // OBSOLETED in 1.61 (between Apr 2018 and Aug 2018)
    IMGUI_API bool      InputFloat(const char* label, float* v, float step, float step_fast, int decimal_precision, ImGuiInputTextFlags flags = 0); // Use the 'const char* format' version instead of 'decimal_precision'!
    IMGUI_API bool      InputFloat2(const char* label, float v[2], int decimal_precision, ImGuiInputTextFlags flags = 0);
    IMGUI_API bool      InputFloat3(const char* label, float v[3], int decimal_precision, ImGuiInputTextFlags flags = 0);
    IMGUI_API bool      InputFloat4(const char* label, float v[4], int decimal_precision, ImGuiInputTextFlags flags = 0);
    // OBSOLETED in 1.60 (between Dec 2017 and Apr 2018)
    static inline bool  IsAnyWindowFocused()                  { return IsWindowFocused(ImGuiFocusedFlags_AnyWindow); }
    static inline bool  IsAnyWindowHovered()                  { return IsWindowHovered(ImGuiHoveredFlags_AnyWindow); }
    static inline ImVec2 CalcItemRectClosestPoint(const ImVec2& pos, bool on_edge = false, float outward = 0.f) { IM_UNUSED(on_edge); IM_UNUSED(outward); IM_ASSERT(0); return pos; }
}
typedef ImGuiInputTextCallback      ImGuiTextEditCallback;    // OBSOLETED in 1.63 (from Aug 2018): made the names consistent
typedef ImGuiInputTextCallbackData  ImGuiTextEditCallbackData;
#endif

//-----------------------------------------------------------------------------
// Helpers
//-----------------------------------------------------------------------------

// Helper: Execute a block of code at maximum once a frame. Convenient if you want to quickly create an UI within deep-nested code that runs multiple times every frame.
// Usage: static ImGuiOnceUponAFrame oaf; if (oaf) ImGui::Text("This will be called only once per frame");
struct ImGuiOnceUponAFrame
{
    ImGuiOnceUponAFrame() { RefFrame = -1; }
    mutable int RefFrame;
    operator bool() const { int current_frame = ImGui::GetFrameCount(); if (RefFrame == current_frame) return false; RefFrame = current_frame; return true; }
};

// Helper: Parse and apply text filters. In format "aaaaa[,bbbb][,ccccc]"
struct ImGuiTextFilter
{
    IMGUI_API           ImGuiTextFilter(const char* default_filter = "");
    IMGUI_API bool      Draw(const char* label = "Filter (inc,-exc)", float width = 0.0f);  // Helper calling InputText+Build
    IMGUI_API bool      PassFilter(const char* text, const char* text_end = NULL) const;
    IMGUI_API void      Build();
    void                Clear()          { InputBuf[0] = 0; Build(); }
    bool                IsActive() const { return !Filters.empty(); }

    // [Internal]
    struct ImGuiTextRange
    {
        const char*     b;
        const char*     e;

        ImGuiTextRange()                                { b = e = NULL; }
        ImGuiTextRange(const char* _b, const char* _e)  { b = _b; e = _e; }
        bool            empty() const                   { return b == e; }
        IMGUI_API void  split(char separator, ImVector<ImGuiTextRange>* out) const;
    };
    char                    InputBuf[256];
    ImVector<ImGuiTextRange>Filters;
    int                     CountGrep;
};

// Helper: Growable text buffer for logging/accumulating text
// (this could be called 'ImGuiTextBuilder' / 'ImGuiStringBuilder')
struct ImGuiTextBuffer
{
    ImVector<char>      Buf;
    IMGUI_API static char EmptyString[1];

    ImGuiTextBuffer()   { }
    inline char         operator[](int i) const { IM_ASSERT(Buf.Data != NULL); return Buf.Data[i]; }
    const char*         begin() const           { return Buf.Data ? &Buf.front() : EmptyString; }
    const char*         end() const             { return Buf.Data ? &Buf.back() : EmptyString; }   // Buf is zero-terminated, so end() will point on the zero-terminator
    int                 size() const            { return Buf.Size ? Buf.Size - 1 : 0; }
    bool                empty() const           { return Buf.Size <= 1; }
    void                clear()                 { Buf.clear(); }
    void                reserve(int capacity)   { Buf.reserve(capacity); }
    const char*         c_str() const           { return Buf.Data ? Buf.Data : EmptyString; }
    IMGUI_API void      append(const char* str, const char* str_end = NULL);
    IMGUI_API void      appendf(const char* fmt, ...) IM_FMTARGS(2);
    IMGUI_API void      appendfv(const char* fmt, va_list args) IM_FMTLIST(2);
};

// Helper: Key->Value storage
// Typically you don't have to worry about this since a storage is held within each Window.
// We use it to e.g. store collapse state for a tree (Int 0/1)
// This is optimized for efficient lookup (dichotomy into a contiguous buffer) and rare insertion (typically tied to user interactions aka max once a frame)
// You can use it as custom user storage for temporary values. Declare your own storage if, for example:
// - You want to manipulate the open/close state of a particular sub-tree in your interface (tree node uses Int 0/1 to store their state).
// - You want to store custom debug data easily without adding or editing structures in your code (probably not efficient, but convenient)
// Types are NOT stored, so it is up to you to make sure your Key don't collide with different types.
struct ImGuiStorage
{
    // [Internal]
    struct ImGuiStoragePair
    {
        ImGuiID key;
        union { int val_i; float val_f; void* val_p; };
        ImGuiStoragePair(ImGuiID _key, int _val_i)      { key = _key; val_i = _val_i; }
        ImGuiStoragePair(ImGuiID _key, float _val_f)    { key = _key; val_f = _val_f; }
        ImGuiStoragePair(ImGuiID _key, void* _val_p)    { key = _key; val_p = _val_p; }
    };

    ImVector<ImGuiStoragePair>      Data;

    // - Get***() functions find pair, never add/allocate. Pairs are sorted so a query is O(log N)
    // - Set***() functions find pair, insertion on demand if missing.
    // - Sorted insertion is costly, paid once. A typical frame shouldn't need to insert any new pair.
    void                Clear() { Data.clear(); }
    IMGUI_API int       GetInt(ImGuiID key, int default_val = 0) const;
    IMGUI_API void      SetInt(ImGuiID key, int val);
    IMGUI_API bool      GetBool(ImGuiID key, bool default_val = false) const;
    IMGUI_API void      SetBool(ImGuiID key, bool val);
    IMGUI_API float     GetFloat(ImGuiID key, float default_val = 0.0f) const;
    IMGUI_API void      SetFloat(ImGuiID key, float val);
    IMGUI_API void*     GetVoidPtr(ImGuiID key) const; // default_val is NULL
    IMGUI_API void      SetVoidPtr(ImGuiID key, void* val);

    // - Get***Ref() functions finds pair, insert on demand if missing, return pointer. Useful if you intend to do Get+Set.
    // - References are only valid until a new value is added to the storage. Calling a Set***() function or a Get***Ref() function invalidates the pointer.
    // - A typical use case where this is convenient for quick hacking (e.g. add storage during a live Edit&Continue session if you can't modify existing struct)
    //      float* pvar = ImGui::GetFloatRef(key); ImGui::SliderFloat("var", pvar, 0, 100.0f); some_var += *pvar;
    IMGUI_API int*      GetIntRef(ImGuiID key, int default_val = 0);
    IMGUI_API bool*     GetBoolRef(ImGuiID key, bool default_val = false);
    IMGUI_API float*    GetFloatRef(ImGuiID key, float default_val = 0.0f);
    IMGUI_API void**    GetVoidPtrRef(ImGuiID key, void* default_val = NULL);

    // Use on your own storage if you know only integer are being stored (open/close all tree nodes)
    IMGUI_API void      SetAllInt(int val);

    // For quicker full rebuild of a storage (instead of an incremental one), you may add all your contents and then sort once.
    IMGUI_API void      BuildSortByKey();
};

// Helper: Manually clip large list of items.
// If you are submitting lots of evenly spaced items and you have a random access to the list, you can perform coarse clipping based on visibility to save yourself from processing those items at all.
// The clipper calculates the range of visible items and advance the cursor to compensate for the non-visible items we have skipped.
// ImGui already clip items based on their bounds but it needs to measure text size to do so. Coarse clipping before submission makes this cost and your own data fetching/submission cost null.
// Usage:
//     ImGuiListClipper clipper(1000);  // we have 1000 elements, evenly spaced.
//     while (clipper.Step())
//         for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++)
//             ImGui::Text("line number %d", i);
// - Step 0: the clipper let you process the first element, regardless of it being visible or not, so we can measure the element height (step skipped if we passed a known height as second arg to constructor).
// - Step 1: the clipper infer height from first element, calculate the actual range of elements to display, and position the cursor before the first element.
// - (Step 2: dummy step only required if an explicit items_height was passed to constructor or Begin() and user call Step(). Does nothing and switch to Step 3.)
// - Step 3: the clipper validate that we have reached the expected Y position (corresponding to element DisplayEnd), advance the cursor to the end of the list and then returns 'false' to end the loop.
struct ImGuiListClipper
{
    float   StartPosY;
    float   ItemsHeight;
    int     ItemsCount, StepNo, DisplayStart, DisplayEnd;

    // items_count:  Use -1 to ignore (you can call Begin later). Use INT_MAX if you don't know how many items you have (in which case the cursor won't be advanced in the final step).
    // items_height: Use -1.0f to be calculated automatically on first step. Otherwise pass in the distance between your items, typically GetTextLineHeightWithSpacing() or GetFrameHeightWithSpacing().
    // If you don't specify an items_height, you NEED to call Step(). If you specify items_height you may call the old Begin()/End() api directly, but prefer calling Step().
    ImGuiListClipper(int items_count = -1, float items_height = -1.0f)  { Begin(items_count, items_height); } // NB: Begin() initialize every fields (as we allow user to call Begin/End multiple times on a same instance if they want).
    ~ImGuiListClipper()                                                 { IM_ASSERT(ItemsCount == -1); }      // Assert if user forgot to call End() or Step() until false.

    IMGUI_API bool Step();                                              // Call until it returns false. The DisplayStart/DisplayEnd fields will be set and you can process/draw those items.
    IMGUI_API void Begin(int items_count, float items_height = -1.0f);  // Automatically called by constructor if you passed 'items_count' or by Step() in Step 1.
    IMGUI_API void End();                                               // Automatically called on the last call of Step() that returns false.
};

// Helpers macros to generate 32-bit encoded colors
#ifdef IMGUI_USE_BGRA_PACKED_COLOR
#define IM_COL32_R_SHIFT    16
#define IM_COL32_G_SHIFT    8
#define IM_COL32_B_SHIFT    0
#define IM_COL32_A_SHIFT    24
#define IM_COL32_A_MASK     0xFF000000
#else
#define IM_COL32_R_SHIFT    0
#define IM_COL32_G_SHIFT    8
#define IM_COL32_B_SHIFT    16
#define IM_COL32_A_SHIFT    24
#define IM_COL32_A_MASK     0xFF000000
#endif
#define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
#define IM_COL32_WHITE       IM_COL32(255,255,255,255)  // Opaque white = 0xFFFFFFFF
#define IM_COL32_BLACK       IM_COL32(0,0,0,255)        // Opaque black
#define IM_COL32_BLACK_TRANS IM_COL32(0,0,0,0)          // Transparent black = 0x00000000

// Helper: ImColor() implicitly converts colors to either ImU32 (packed 4x1 byte) or ImVec4 (4x1 float)
// Prefer using IM_COL32() macros if you want a guaranteed compile-time ImU32 for usage with ImDrawList API.
// **Avoid storing ImColor! Store either u32 of ImVec4. This is not a full-featured color class. MAY OBSOLETE.
// **None of the ImGui API are using ImColor directly but you can use it as a convenience to pass colors in either ImU32 or ImVec4 formats. Explicitly cast to ImU32 or ImVec4 if needed.
struct ImColor
{
    ImVec4              Value;

    ImColor()                                                       { Value.x = Value.y = Value.z = Value.w = 0.0f; }
    ImColor(int r, int g, int b, int a = 255)                       { float sc = 1.0f/255.0f; Value.x = (float)r * sc; Value.y = (float)g * sc; Value.z = (float)b * sc; Value.w = (float)a * sc; }
    ImColor(ImU32 rgba)                                             { float sc = 1.0f/255.0f; Value.x = (float)((rgba>>IM_COL32_R_SHIFT)&0xFF) * sc; Value.y = (float)((rgba>>IM_COL32_G_SHIFT)&0xFF) * sc; Value.z = (float)((rgba>>IM_COL32_B_SHIFT)&0xFF) * sc; Value.w = (float)((rgba>>IM_COL32_A_SHIFT)&0xFF) * sc; }
    ImColor(float r, float g, float b, float a = 1.0f)              { Value.x = r; Value.y = g; Value.z = b; Value.w = a; }
    ImColor(const ImVec4& col)                                      { Value = col; }
    inline operator ImU32() const                                   { return ImGui::ColorConvertFloat4ToU32(Value); }
    inline operator ImVec4() const                                  { return Value; }

    // FIXME-OBSOLETE: May need to obsolete/cleanup those helpers.
    inline void    SetHSV(float h, float s, float v, float a = 1.0f){ ImGui::ColorConvertHSVtoRGB(h, s, v, Value.x, Value.y, Value.z); Value.w = a; }
    static ImColor HSV(float h, float s, float v, float a = 1.0f)   { float r,g,b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r,g,b,a); }
};

//-----------------------------------------------------------------------------
// Draw List API (ImDrawCmd, ImDrawIdx, ImDrawVert, ImDrawChannel, ImDrawListSplitter, ImDrawListFlags, ImDrawList, ImDrawData)
// Hold a series of drawing commands. The user provides a renderer for ImDrawData which essentially contains an array of ImDrawList.
//-----------------------------------------------------------------------------

// Draw callbacks for advanced uses.
// NB: You most likely do NOT need to use draw callbacks just to create your own widget or customized UI rendering,
// you can poke into the draw list for that! Draw callback may be useful for example to:
//  A) Change your GPU render state,
//  B) render a complex 3D scene inside a UI element without an intermediate texture/render target, etc.
// The expected behavior from your rendering function is 'if (cmd.UserCallback != NULL) { cmd.UserCallback(parent_list, cmd); } else { RenderTriangles() }'
// If you want to override the signature of ImDrawCallback, you can simply use e.g. '#define ImDrawCallback MyDrawCallback' (in imconfig.h) + update rendering back-end accordingly.
#ifndef ImDrawCallback
typedef void (*ImDrawCallback)(const ImDrawList* parent_list, const ImDrawCmd* cmd);
#endif

// Special Draw callback value to request renderer back-end to reset the graphics/render state.
// The renderer back-end needs to handle this special value, otherwise it will crash trying to call a function at this address.
// This is useful for example if you submitted callbacks which you know have altered the render state and you want it to be restored.
// It is not done by default because they are many perfectly useful way of altering render state for imgui contents (e.g. changing shader/blending settings before an Image call).
#define ImDrawCallback_ResetRenderState     (ImDrawCallback)(-1)

// Typically, 1 command = 1 GPU draw call (unless command is a callback)
// Pre 1.71 back-ends will typically ignore the VtxOffset/IdxOffset fields. When 'io.BackendFlags & ImGuiBackendFlags_RendererHasVtxOffset'
// is enabled, those fields allow us to render meshes larger than 64K vertices while keeping 16-bit indices.
struct ImDrawCmd
{
    unsigned int    ElemCount;              // Number of indices (multiple of 3) to be rendered as triangles. Vertices are stored in the callee ImDrawList's vtx_buffer[] array, indices in idx_buffer[].
    ImVec4          ClipRect;               // Clipping rectangle (x1, y1, x2, y2). Subtract ImDrawData->DisplayPos to get clipping rectangle in "viewport" coordinates
    ImTextureID     TextureId;              // User-provided texture ID. Set by user in ImfontAtlas::SetTexID() for fonts or passed to Image*() functions. Ignore if never using images or multiple fonts atlas.
    unsigned int    VtxOffset;              // Start offset in vertex buffer. Pre-1.71 or without ImGuiBackendFlags_RendererHasVtxOffset: always 0. With ImGuiBackendFlags_RendererHasVtxOffset: may be >0 to support meshes larger than 64K vertices with 16-bit indices.
    unsigned int    IdxOffset;              // Start offset in index buffer. Always equal to sum of ElemCount drawn so far.
    ImDrawCallback  UserCallback;           // If != NULL, call the function instead of rendering the vertices. clip_rect and texture_id will be set normally.
    void*           UserCallbackData;       // The draw callback code can access this.

    ImDrawCmd() { ElemCount = 0; TextureId = (ImTextureID)NULL; VtxOffset = IdxOffset = 0;  UserCallback = NULL; UserCallbackData = NULL; }
};

// Vertex index
// (to allow large meshes with 16-bit indices: set 'io.BackendFlags |= ImGuiBackendFlags_RendererHasVtxOffset' and handle ImDrawCmd::VtxOffset in the renderer back-end)
// (to use 32-bit indices: override with '#define ImDrawIdx unsigned int' in imconfig.h)
#ifndef ImDrawIdx
typedef unsigned short ImDrawIdx;
#endif

// Vertex layout
#ifndef IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT
struct ImDrawVert
{
    ImVec2  pos;
    ImVec2  uv;
    ImU32   col;
};
#else
// You can override the vertex format layout by defining IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT in imconfig.h
// The code expect ImVec2 pos (8 bytes), ImVec2 uv (8 bytes), ImU32 col (4 bytes), but you can re-order them or add other fields as needed to simplify integration in your engine.
// The type has to be described within the macro (you can either declare the struct or use a typedef). This is because ImVec2/ImU32 are likely not declared a the time you'd want to set your type up.
// NOTE: IMGUI DOESN'T CLEAR THE STRUCTURE AND DOESN'T CALL A CONSTRUCTOR SO ANY CUSTOM FIELD WILL BE UNINITIALIZED. IF YOU ADD EXTRA FIELDS (SUCH AS A 'Z' COORDINATES) YOU WILL NEED TO CLEAR THEM DURING RENDER OR TO IGNORE THEM.
IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT;
#endif

// For use by ImDrawListSplitter.
struct ImDrawChannel
{
    ImVector<ImDrawCmd>         _CmdBuffer;
    ImVector<ImDrawIdx>         _IdxBuffer;
};

// Split/Merge functions are used to split the draw list into different layers which can be drawn into out of order.
// This is used by the Columns api, so items of each column can be batched together in a same draw call.
struct ImDrawListSplitter
{
    int                         _Current;    // Current channel number (0)
    int                         _Count;      // Number of active channels (1+)
    ImVector<ImDrawChannel>     _Channels;   // Draw channels (not resized down so _Count might be < Channels.Size)

    inline ImDrawListSplitter()  { Clear(); }
    inline ~ImDrawListSplitter() { ClearFreeMemory(); }
    inline void                 Clear() { _Current = 0; _Count = 1; } // Do not clear Channels[] so our allocations are reused next frame
    IMGUI_API void              ClearFreeMemory();
    IMGUI_API void              Split(ImDrawList* draw_list, int count);
    IMGUI_API void              Merge(ImDrawList* draw_list);
    IMGUI_API void              SetCurrentChannel(ImDrawList* draw_list, int channel_idx);
};

enum ImDrawCornerFlags_
{
    ImDrawCornerFlags_None      = 0,
    ImDrawCornerFlags_TopLeft   = 1 << 0, // 0x1
    ImDrawCornerFlags_TopRight  = 1 << 1, // 0x2
    ImDrawCornerFlags_BotLeft   = 1 << 2, // 0x4
    ImDrawCornerFlags_BotRight  = 1 << 3, // 0x8
    ImDrawCornerFlags_Top       = ImDrawCornerFlags_TopLeft | ImDrawCornerFlags_TopRight,   // 0x3
    ImDrawCornerFlags_Bot       = ImDrawCornerFlags_BotLeft | ImDrawCornerFlags_BotRight,   // 0xC
    ImDrawCornerFlags_Left      = ImDrawCornerFlags_TopLeft | ImDrawCornerFlags_BotLeft,    // 0x5
    ImDrawCornerFlags_Right     = ImDrawCornerFlags_TopRight | ImDrawCornerFlags_BotRight,  // 0xA
    ImDrawCornerFlags_All       = 0xF     // In your function calls you may use ~0 (= all bits sets) instead of ImDrawCornerFlags_All, as a convenience
};

enum ImDrawListFlags_
{
    ImDrawListFlags_None             = 0,
    ImDrawListFlags_AntiAliasedLines = 1 << 0,  // Lines are anti-aliased (*2 the number of triangles for 1.0f wide line, otherwise *3 the number of triangles)
    ImDrawListFlags_AntiAliasedFill  = 1 << 1,  // Filled shapes have anti-aliased edges (*2 the number of vertices)
    ImDrawListFlags_AllowVtxOffset   = 1 << 2   // Can emit 'VtxOffset > 0' to allow large meshes. Set when 'ImGuiBackendFlags_RendererHasVtxOffset' is enabled.
};

// Draw command list
// This is the low-level list of polygons that ImGui:: functions are filling. At the end of the frame,
// all command lists are passed to your ImGuiIO::RenderDrawListFn function for rendering.
// Each dear imgui window contains its own ImDrawList. You can use ImGui::GetWindowDrawList() to
// access the current window draw list and draw custom primitives.
// You can interleave normal ImGui:: calls and adding primitives to the current draw list.
// All positions are generally in pixel coordinates (top-left at (0,0), bottom-right at io.DisplaySize), but you are totally free to apply whatever transformation matrix to want to the data (if you apply such transformation you'll want to apply it to ClipRect as well)
// Important: Primitives are always added to the list and not culled (culling is done at higher-level by ImGui:: functions), if you use this API a lot consider coarse culling your drawn objects.
struct ImDrawList
{
    // This is what you have to render
    ImVector<ImDrawCmd>     CmdBuffer;          // Draw commands. Typically 1 command = 1 GPU draw call, unless the command is a callback.
    ImVector<ImDrawIdx>     IdxBuffer;          // Index buffer. Each command consume ImDrawCmd::ElemCount of those
    ImVector<ImDrawVert>    VtxBuffer;          // Vertex buffer.
    ImDrawListFlags         Flags;              // Flags, you may poke into these to adjust anti-aliasing settings per-primitive.

    // [Internal, used while building lists]
    const ImDrawListSharedData* _Data;          // Pointer to shared draw data (you can use ImGui::GetDrawListSharedData() to get the one from current ImGui context)
    const char*             _OwnerName;         // Pointer to owner window's name for debugging
    unsigned int            _VtxCurrentOffset;  // [Internal] Always 0 unless 'Flags & ImDrawListFlags_AllowVtxOffset'.
    unsigned int            _VtxCurrentIdx;     // [Internal] Generally == VtxBuffer.Size unless we are past 64K vertices, in which case this gets reset to 0.
    ImDrawVert*             _VtxWritePtr;       // [Internal] point within VtxBuffer.Data after each add command (to avoid using the ImVector<> operators too much)
    ImDrawIdx*              _IdxWritePtr;       // [Internal] point within IdxBuffer.Data after each add command (to avoid using the ImVector<> operators too much)
    ImVector<ImVec4>        _ClipRectStack;     // [Internal]
    ImVector<ImTextureID>   _TextureIdStack;    // [Internal]
    ImVector<ImVec2>        _Path;              // [Internal] current path building
    ImDrawListSplitter      _Splitter;          // [Internal] for channels api

    // If you want to create ImDrawList instances, pass them ImGui::GetDrawListSharedData() or create and use your own ImDrawListSharedData (so you can use ImDrawList without ImGui)
    ImDrawList(const ImDrawListSharedData* shared_data) { _Data = shared_data; _OwnerName = NULL; Clear(); }
    ~ImDrawList() { ClearFreeMemory(); }
    IMGUI_API void  PushClipRect(ImVec2 clip_rect_min, ImVec2 clip_rect_max, bool intersect_with_current_clip_rect = false);  // Render-level scissoring. This is passed down to your render function but not used for CPU-side coarse clipping. Prefer using higher-level ImGui::PushClipRect() to affect logic (hit-testing and widget culling)
    IMGUI_API void  PushClipRectFullScreen();
    IMGUI_API void  PopClipRect();
    IMGUI_API void  PushTextureID(ImTextureID texture_id);
    IMGUI_API void  PopTextureID();
    inline ImVec2   GetClipRectMin() const { const ImVec4& cr = _ClipRectStack.back(); return ImVec2(cr.x, cr.y); }
    inline ImVec2   GetClipRectMax() const { const ImVec4& cr = _ClipRectStack.back(); return ImVec2(cr.z, cr.w); }

    // Primitives
    // - For rectangular primitives, "p_min" and "p_max" represent the upper-left and lower-right corners.
    IMGUI_API void  AddLine(const ImVec2& p1, const ImVec2& p2, ImU32 col, float thickness = 1.0f);
    IMGUI_API void  AddRect(const ImVec2& p_min, const ImVec2& p_max, ImU32 col, float rounding = 0.0f, ImDrawCornerFlags rounding_corners = ImDrawCornerFlags_All, float thickness = 1.0f);   // a: upper-left, b: lower-right (== upper-left + size), rounding_corners_flags: 4 bits corresponding to which corner to round
    IMGUI_API void  AddRectFilled(const ImVec2& p_min, const ImVec2& p_max, ImU32 col, float rounding = 0.0f, ImDrawCornerFlags rounding_corners = ImDrawCornerFlags_All);                     // a: upper-left, b: lower-right (== upper-left + size)
    IMGUI_API void  AddRectFilledMultiColor(const ImVec2& p_min, const ImVec2& p_max, ImU32 col_upr_left, ImU32 col_upr_right, ImU32 col_bot_right, ImU32 col_bot_left);
    IMGUI_API void  AddQuad(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, ImU32 col, float thickness = 1.0f);
    IMGUI_API void  AddQuadFilled(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, ImU32 col);
    IMGUI_API void  AddTriangle(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, ImU32 col, float thickness = 1.0f);
    IMGUI_API void  AddTriangleFilled(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, ImU32 col);
    IMGUI_API void  AddCircle(const ImVec2& center, float radius, ImU32 col, int num_segments = 12, float thickness = 1.0f);
    IMGUI_API void  AddCircleFilled(const ImVec2& center, float radius, ImU32 col, int num_segments = 12);
    IMGUI_API void  AddNgon(const ImVec2& center, float radius, ImU32 col, int num_segments, float thickness = 1.0f);
    IMGUI_API void  AddNgonFilled(const ImVec2& center, float radius, ImU32 col, int num_segments);
    IMGUI_API void  AddText(const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end = NULL);
    IMGUI_API void  AddText(const ImFont* font, float font_size, const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end = NULL, float wrap_width = 0.0f, const ImVec4* cpu_fine_clip_rect = NULL);
    IMGUI_API void  AddPolyline(const ImVec2* points, int num_points, ImU32 col, bool closed, float thickness);
    IMGUI_API void  AddConvexPolyFilled(const ImVec2* points, int num_points, ImU32 col); // Note: Anti-aliased filling requires points to be in clockwise order.
    IMGUI_API void  AddBezierCurve(const ImVec2& pos0, const ImVec2& cp0, const ImVec2& cp1, const ImVec2& pos1, ImU32 col, float thickness, int num_segments = 0);

    // Image primitives
    // - Read FAQ to understand what ImTextureID is.
    // - "p_min" and "p_max" represent the upper-left and lower-right corners of the rectangle.
    // - "uv_min" and "uv_max" represent the normalized texture coordinates to use for those corners. Using (0,0)->(1,1) texture coordinates will generally display the entire texture.
    IMGUI_API void  AddImage(ImTextureID user_texture_id, const ImVec2& p_min, const ImVec2& p_max, const ImVec2& uv_min = ImVec2(0, 0), const ImVec2& uv_max = ImVec2(1, 1), ImU32 col = IM_COL32_WHITE);
    IMGUI_API void  AddImageQuad(ImTextureID user_texture_id, const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, const ImVec2& uv1 = ImVec2(0, 0), const ImVec2& uv2 = ImVec2(1, 0), const ImVec2& uv3 = ImVec2(1, 1), const ImVec2& uv4 = ImVec2(0, 1), ImU32 col = IM_COL32_WHITE);
    IMGUI_API void  AddImageRounded(ImTextureID user_texture_id, const ImVec2& p_min, const ImVec2& p_max, const ImVec2& uv_min, const ImVec2& uv_max, ImU32 col, float rounding, ImDrawCornerFlags rounding_corners = ImDrawCornerFlags_All);

    // Stateful path API, add points then finish with PathFillConvex() or PathStroke()
    inline    void  PathClear()                                                 { _Path.Size = 0; }
    inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }
    inline    void  PathLineToMergeDuplicate(const ImVec2& pos)                 { if (_Path.Size == 0 || memcmp(&_Path.Data[_Path.Size-1], &pos, 8) != 0) _Path.push_back(pos); }
    inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }  // Note: Anti-aliased filling requires points to be in clockwise order.
    inline    void  PathStroke(ImU32 col, bool closed, float thickness = 1.0f)  { AddPolyline(_Path.Data, _Path.Size, col, closed, thickness); _Path.Size = 0; }
    IMGUI_API void  PathArcTo(const ImVec2& center, float radius, float a_min, float a_max, int num_segments = 10);
    IMGUI_API void  PathArcToFast(const ImVec2& center, float radius, int a_min_of_12, int a_max_of_12);                                            // Use precomputed angles for a 12 steps circle
    IMGUI_API void  PathBezierCurveTo(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, int num_segments = 0);
    IMGUI_API void  PathRect(const ImVec2& rect_min, const ImVec2& rect_max, float rounding = 0.0f, ImDrawCornerFlags rounding_corners = ImDrawCornerFlags_All);

    // Advanced
    IMGUI_API void  AddCallback(ImDrawCallback callback, void* callback_data);  // Your rendering function must check for 'UserCallback' in ImDrawCmd and call the function instead of rendering triangles.
    IMGUI_API void  AddDrawCmd();                                               // This is useful if you need to forcefully create a new draw call (to allow for dependent rendering / blending). Otherwise primitives are merged into the same draw-call as much as possible
    IMGUI_API ImDrawList* CloneOutput() const;                                  // Create a clone of the CmdBuffer/IdxBuffer/VtxBuffer.

    // Advanced: Channels
    // - Use to split render into layers. By switching channels to can render out-of-order (e.g. submit foreground primitives before background primitives)
    // - Use to minimize draw calls (e.g. if going back-and-forth between multiple non-overlapping clipping rectangles, prefer to append into separate channels then merge at the end)
    inline void     ChannelsSplit(int count)    { _Splitter.Split(this, count); }
    inline void     ChannelsMerge()             { _Splitter.Merge(this); }
    inline void     ChannelsSetCurrent(int n)   { _Splitter.SetCurrentChannel(this, n); }

    // Internal helpers
    // NB: all primitives needs to be reserved via PrimReserve() beforehand!
    IMGUI_API void  Clear();
    IMGUI_API void  ClearFreeMemory();
    IMGUI_API void  PrimReserve(int idx_count, int vtx_count);
    IMGUI_API void  PrimUnreserve(int idx_count, int vtx_count);
    IMGUI_API void  PrimRect(const ImVec2& a, const ImVec2& b, ImU32 col);      // Axis aligned rectangle (composed of two triangles)
    IMGUI_API void  PrimRectUV(const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col);
    IMGUI_API void  PrimQuadUV(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a, const ImVec2& uv_b, const ImVec2& uv_c, const ImVec2& uv_d, ImU32 col);
    inline    void  PrimWriteVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col){ _VtxWritePtr->pos = pos; _VtxWritePtr->uv = uv; _VtxWritePtr->col = col; _VtxWritePtr++; _VtxCurrentIdx++; }
    inline    void  PrimWriteIdx(ImDrawIdx idx)                                 { *_IdxWritePtr = idx; _IdxWritePtr++; }
    inline    void  PrimVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col)     { PrimWriteIdx((ImDrawIdx)_VtxCurrentIdx); PrimWriteVtx(pos, uv, col); }
    IMGUI_API void  UpdateClipRect();
    IMGUI_API void  UpdateTextureID();
};

// All draw data to render a Dear ImGui frame
// (NB: the style and the naming convention here is a little inconsistent, we currently preserve them for backward compatibility purpose,
// as this is one of the oldest structure exposed by the library! Basically, ImDrawList == CmdList)
struct ImDrawData
{
    bool            Valid;                  // Only valid after Render() is called and before the next NewFrame() is called.
    ImDrawList**    CmdLists;               // Array of ImDrawList* to render. The ImDrawList are owned by ImGuiContext and only pointed to from here.
    int             CmdListsCount;          // Number of ImDrawList* to render
    int             TotalIdxCount;          // For convenience, sum of all ImDrawList's IdxBuffer.Size
    int             TotalVtxCount;          // For convenience, sum of all ImDrawList's VtxBuffer.Size
    ImVec2          DisplayPos;             // Upper-left position of the viewport to render (== upper-left of the orthogonal projection matrix to use)
    ImVec2          DisplaySize;            // Size of the viewport to render (== io.DisplaySize for the main viewport) (DisplayPos + DisplaySize == lower-right of the orthogonal projection matrix to use)
    ImVec2          FramebufferScale;       // Amount of pixels for each unit of DisplaySize. Based on io.DisplayFramebufferScale. Generally (1,1) on normal display, (2,2) on OSX with Retina display.

    // Functions
    ImDrawData()    { Valid = false; Clear(); }
    ~ImDrawData()   { Clear(); }
    void Clear()    { Valid = false; CmdLists = NULL; CmdListsCount = TotalVtxCount = TotalIdxCount = 0; DisplayPos = DisplaySize = FramebufferScale = ImVec2(0.f, 0.f); } // The ImDrawList are owned by ImGuiContext!
    IMGUI_API void  DeIndexAllBuffers();                    // Helper to convert all buffers from indexed to non-indexed, in case you cannot render indexed. Note: this is slow and most likely a waste of resources. Always prefer indexed rendering!
    IMGUI_API void  ScaleClipRects(const ImVec2& fb_scale); // Helper to scale the ClipRect field of each ImDrawCmd. Use if your final output buffer is at a different scale than Dear ImGui expects, or if there is a difference between your window resolution and framebuffer resolution.
};

//-----------------------------------------------------------------------------
// Font API (ImFontConfig, ImFontGlyph, ImFontAtlasFlags, ImFontAtlas, ImFontGlyphRangesBuilder, ImFont)
//-----------------------------------------------------------------------------

struct ImFontConfig
{
    void*           FontData;               //          // TTF/OTF data
    int             FontDataSize;           //          // TTF/OTF data size
    bool            FontDataOwnedByAtlas;   // true     // TTF/OTF data ownership taken by the container ImFontAtlas (will delete memory itself).
    int             FontNo;                 // 0        // Index of font within TTF/OTF file
    float           SizePixels;             //          // Size in pixels for rasterizer (more or less maps to the resulting font height).
    int             OversampleH;            // 3        // Rasterize at higher quality for sub-pixel positioning. Read https://github.com/nothings/stb/blob/master/tests/oversample/README.md for details.
    int             OversampleV;            // 1        // Rasterize at higher quality for sub-pixel positioning. We don't use sub-pixel positions on the Y axis.
    bool            PixelSnapH;             // false    // Align every glyph to pixel boundary. Useful e.g. if you are merging a non-pixel aligned font with the default font. If enabled, you can set OversampleH/V to 1.
    ImVec2          GlyphExtraSpacing;      // 0, 0     // Extra spacing (in pixels) between glyphs. Only X axis is supported for now.
    ImVec2          GlyphOffset;            // 0, 0     // Offset all glyphs from this font input.
    const ImWchar*  GlyphRanges;            // NULL     // Pointer to a user-provided list of Unicode range (2 value per range, values are inclusive, zero-terminated list). THE ARRAY DATA NEEDS TO PERSIST AS LONG AS THE FONT IS ALIVE.
    float           GlyphMinAdvanceX;       // 0        // Minimum AdvanceX for glyphs, set Min to align font icons, set both Min/Max to enforce mono-space font
    float           GlyphMaxAdvanceX;       // FLT_MAX  // Maximum AdvanceX for glyphs
    bool            MergeMode;              // false    // Merge into previous ImFont, so you can combine multiple inputs font into one ImFont (e.g. ASCII font + icons + Japanese glyphs). You may want to use GlyphOffset.y when merge font of different heights.
    unsigned int    RasterizerFlags;        // 0x00     // Settings for custom font rasterizer (e.g. ImGuiFreeType). Leave as zero if you aren't using one.
    float           RasterizerMultiply;     // 1.0f     // Brighten (>1.0f) or darken (<1.0f) font output. Brightening small fonts may be a good workaround to make them more readable.
    ImWchar         EllipsisChar;           // -1       // Explicitly specify unicode codepoint of ellipsis character. When fonts are being merged first specified ellipsis will be used.

    // [Internal]
    char            Name[40];               // Name (strictly to ease debugging)
    ImFont*         DstFont;

    IMGUI_API ImFontConfig();
};

struct ImFontGlyph
{
    ImWchar         Codepoint;          // 0x0000..0xFFFF
    float           AdvanceX;           // Distance to next character (= data from font + ImFontConfig::GlyphExtraSpacing.x baked in)
    float           X0, Y0, X1, Y1;     // Glyph corners
    float           U0, V0, U1, V1;     // Texture coordinates
};

// Helper to build glyph ranges from text/string data. Feed your application strings/characters to it then call BuildRanges().
// This is essentially a tightly packed of vector of 64k booleans = 8KB storage.
struct ImFontGlyphRangesBuilder
{
    ImVector<ImU32> UsedChars;            // Store 1-bit per Unicode code point (0=unused, 1=used)

    ImFontGlyphRangesBuilder()          { Clear(); }
    inline void     Clear()             { int size_in_bytes = (IM_UNICODE_CODEPOINT_MAX+1) / 8; UsedChars.resize(size_in_bytes / (int)sizeof(ImU32)); memset(UsedChars.Data, 0, (size_t)size_in_bytes); }
    inline bool     GetBit(int n) const { int off = (n >> 5); ImU32 mask = 1u << (n & 31); return (UsedChars[off] & mask) != 0; }  // Get bit n in the array
    inline void     SetBit(int n)       { int off = (n >> 5); ImU32 mask = 1u << (n & 31); UsedChars[off] |= mask; }               // Set bit n in the array
    inline void     AddChar(ImWchar c)  { SetBit(c); }                          // Add character
    IMGUI_API void  AddText(const char* text, const char* text_end = NULL);     // Add string (each character of the UTF-8 string are added)
    IMGUI_API void  AddRanges(const ImWchar* ranges);                           // Add ranges, e.g. builder.AddRanges(ImFontAtlas::GetGlyphRangesDefault()) to force add all of ASCII/Latin+Ext
    IMGUI_API void  BuildRanges(ImVector<ImWchar>* out_ranges);                 // Output new ranges
};

// See ImFontAtlas::AddCustomRectXXX functions.
struct ImFontAtlasCustomRect
{
    unsigned int    ID;             // Input    // User ID. Use < 0x110000 to map into a font glyph, >= 0x110000 for other/internal/custom texture data.
    unsigned short  Width, Height;  // Input    // Desired rectangle dimension
    unsigned short  X, Y;           // Output   // Packed position in Atlas
    float           GlyphAdvanceX;  // Input    // For custom font glyphs only (ID < 0x110000): glyph xadvance
    ImVec2          GlyphOffset;    // Input    // For custom font glyphs only (ID < 0x110000): glyph display offset
    ImFont*         Font;           // Input    // For custom font glyphs only (ID < 0x110000): target font
    ImFontAtlasCustomRect()         { ID = 0xFFFFFFFF; Width = Height = 0; X = Y = 0xFFFF; GlyphAdvanceX = 0.0f; GlyphOffset = ImVec2(0,0); Font = NULL; }
    bool IsPacked() const           { return X != 0xFFFF; }
};

enum ImFontAtlasFlags_
{
    ImFontAtlasFlags_None               = 0,
    ImFontAtlasFlags_NoPowerOfTwoHeight = 1 << 0,   // Don't round the height to next power of two
    ImFontAtlasFlags_NoMouseCursors     = 1 << 1    // Don't build software mouse cursors into the atlas
};

// Load and rasterize multiple TTF/OTF fonts into a same texture. The font atlas will build a single texture holding:
//  - One or more fonts.
//  - Custom graphics data needed to render the shapes needed by Dear ImGui.
//  - Mouse cursor shapes for software cursor rendering (unless setting 'Flags |= ImFontAtlasFlags_NoMouseCursors' in the font atlas).
// It is the user-code responsibility to setup/build the atlas, then upload the pixel data into a texture accessible by your graphics api.
//  - Optionally, call any of the AddFont*** functions. If you don't call any, the default font embedded in the code will be loaded for you.
//  - Call GetTexDataAsAlpha8() or GetTexDataAsRGBA32() to build and retrieve pixels data.
//  - Upload the pixels data into a texture within your graphics system (see imgui_impl_xxxx.cpp examples)
//  - Call SetTexID(my_tex_id); and pass the pointer/identifier to your texture in a format natural to your graphics API.
//    This value will be passed back to you during rendering to identify the texture. Read FAQ entry about ImTextureID for more details.
// Common pitfalls:
// - If you pass a 'glyph_ranges' array to AddFont*** functions, you need to make sure that your array persist up until the
//   atlas is build (when calling GetTexData*** or Build()). We only copy the pointer, not the data.
// - Important: By default, AddFontFromMemoryTTF() takes ownership of the data. Even though we are not writing to it, we will free the pointer on destruction.
//   You can set font_cfg->FontDataOwnedByAtlas=false to keep ownership of your data and it won't be freed,
// - Even though many functions are suffixed with "TTF", OTF data is supported just as well.
// - This is an old API and it is currently awkward for those and and various other reasons! We will address them in the future!
struct ImFontAtlas
{
    IMGUI_API ImFontAtlas();
    IMGUI_API ~ImFontAtlas();
    IMGUI_API ImFont*           AddFont(const ImFontConfig* font_cfg);
    IMGUI_API ImFont*           AddFontDefault(const ImFontConfig* font_cfg = NULL);
    IMGUI_API ImFont*           AddFontFromFileTTF(const char* filename, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL);
    IMGUI_API ImFont*           AddFontFromMemoryTTF(void* font_data, int font_size, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL); // Note: Transfer ownership of 'ttf_data' to ImFontAtlas! Will be deleted after destruction of the atlas. Set font_cfg->FontDataOwnedByAtlas=false to keep ownership of your data and it won't be freed.
    IMGUI_API ImFont*           AddFontFromMemoryCompressedTTF(const void* compressed_font_data, int compressed_font_size, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL); // 'compressed_font_data' still owned by caller. Compress with binary_to_compressed_c.cpp.
    IMGUI_API ImFont*           AddFontFromMemoryCompressedBase85TTF(const char* compressed_font_data_base85, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL);              // 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.
    IMGUI_API void              ClearInputData();           // Clear input data (all ImFontConfig structures including sizes, TTF data, glyph ranges, etc.) = all the data used to build the texture and fonts.
    IMGUI_API void              ClearTexData();             // Clear output texture data (CPU side). Saves RAM once the texture has been copied to graphics memory.
    IMGUI_API void              ClearFonts();               // Clear output font data (glyphs storage, UV coordinates).
    IMGUI_API void              Clear();                    // Clear all input and output.

    // Build atlas, retrieve pixel data.
    // User is in charge of copying the pixels into graphics memory (e.g. create a texture with your engine). Then store your texture handle with SetTexID().
    // The pitch is always = Width * BytesPerPixels (1 or 4)
    // Building in RGBA32 format is provided for convenience and compatibility, but note that unless you manually manipulate or copy color data into
    // the texture (e.g. when using the AddCustomRect*** api), then the RGB pixels emitted will always be white (~75% of memory/bandwidth waste.
    IMGUI_API bool              Build();                    // Build pixels data. This is called automatically for you by the GetTexData*** functions.
    IMGUI_API void              GetTexDataAsAlpha8(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel = NULL);  // 1 byte per-pixel
    IMGUI_API void              GetTexDataAsRGBA32(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel = NULL);  // 4 bytes-per-pixel
    bool                        IsBuilt() const             { return Fonts.Size > 0 && (TexPixelsAlpha8 != NULL || TexPixelsRGBA32 != NULL); }
    void                        SetTexID(ImTextureID id)    { TexID = id; }

    //-------------------------------------------
    // Glyph Ranges
    //-------------------------------------------

    // Helpers to retrieve list of common Unicode ranges (2 value per range, values are inclusive, zero-terminated list)
    // NB: Make sure that your string are UTF-8 and NOT in your local code page. In C++11, you can create UTF-8 string literal using the u8"Hello world" syntax. See FAQ for details.
    // NB: Consider using ImFontGlyphRangesBuilder to build glyph ranges from textual data.
    IMGUI_API const ImWchar*    GetGlyphRangesDefault();                // Basic Latin, Extended Latin
    IMGUI_API const ImWchar*    GetGlyphRangesKorean();                 // Default + Korean characters
    IMGUI_API const ImWchar*    GetGlyphRangesJapanese();               // Default + Hiragana, Katakana, Half-Width, Selection of 1946 Ideographs
    IMGUI_API const ImWchar*    GetGlyphRangesChineseFull();            // Default + Half-Width + Japanese Hiragana/Katakana + full set of about 21000 CJK Unified Ideographs
    IMGUI_API const ImWchar*    GetGlyphRangesChineseSimplifiedCommon();// Default + Half-Width + Japanese Hiragana/Katakana + set of 2500 CJK Unified Ideographs for common simplified Chinese
    IMGUI_API const ImWchar*    GetGlyphRangesCyrillic();               // Default + about 400 Cyrillic characters
    IMGUI_API const ImWchar*    GetGlyphRangesThai();                   // Default + Thai characters
    IMGUI_API const ImWchar*    GetGlyphRangesVietnamese();             // Default + Vietnamese characters

    //-------------------------------------------
    // [BETA] Custom Rectangles/Glyphs API
    //-------------------------------------------

    // You can request arbitrary rectangles to be packed into the atlas, for your own purposes.
    // After calling Build(), you can query the rectangle position and render your pixels.
    // You can also request your rectangles to be mapped as font glyph (given a font + Unicode point),
    // so you can render e.g. custom colorful icons and use them as regular glyphs.
    // Read docs/FONTS.txt for more details about using colorful icons.
    IMGUI_API int               AddCustomRectRegular(unsigned int id, int width, int height);                                                                   // Id needs to be >= 0x110000. Id >= 0x80000000 are reserved for ImGui and ImDrawList
    IMGUI_API int               AddCustomRectFontGlyph(ImFont* font, ImWchar id, int width, int height, float advance_x, const ImVec2& offset = ImVec2(0,0));   // Id needs to be < 0x110000 to register a rectangle to map into a specific font.
    const ImFontAtlasCustomRect*GetCustomRectByIndex(int index) const { if (index < 0) return NULL; return &CustomRects[index]; }

    // [Internal]
    IMGUI_API void              CalcCustomRectUV(const ImFontAtlasCustomRect* rect, ImVec2* out_uv_min, ImVec2* out_uv_max) const;
    IMGUI_API bool              GetMouseCursorTexData(ImGuiMouseCursor cursor, ImVec2* out_offset, ImVec2* out_size, ImVec2 out_uv_border[2], ImVec2 out_uv_fill[2]);

    //-------------------------------------------
    // Members
    //-------------------------------------------

    bool                        Locked;             // Marked as Locked by ImGui::NewFrame() so attempt to modify the atlas will assert.
    ImFontAtlasFlags            Flags;              // Build flags (see ImFontAtlasFlags_)
    ImTextureID                 TexID;              // User data to refer to the texture once it has been uploaded to user's graphic systems. It is passed back to you during rendering via the ImDrawCmd structure.
    int                         TexDesiredWidth;    // Texture width desired by user before Build(). Must be a power-of-two. If have many glyphs your graphics API have texture size restrictions you may want to increase texture width to decrease height.
    int                         TexGlyphPadding;    // Padding between glyphs within texture in pixels. Defaults to 1. If your rendering method doesn't rely on bilinear filtering you may set this to 0.

    // [Internal]
    // NB: Access texture data via GetTexData*() calls! Which will setup a default font for you.
    unsigned char*              TexPixelsAlpha8;    // 1 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight
    unsigned int*               TexPixelsRGBA32;    // 4 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight * 4
    int                         TexWidth;           // Texture width calculated during Build().
    int                         TexHeight;          // Texture height calculated during Build().
    ImVec2                      TexUvScale;         // = (1.0f/TexWidth, 1.0f/TexHeight)
    ImVec2                      TexUvWhitePixel;    // Texture coordinates to a white pixel
    ImVector<ImFont*>           Fonts;              // Hold all the fonts returned by AddFont*. Fonts[0] is the default font upon calling ImGui::NewFrame(), use ImGui::PushFont()/PopFont() to change the current font.
    ImVector<ImFontAtlasCustomRect> CustomRects;    // Rectangles for packing custom texture data into the atlas.
    ImVector<ImFontConfig>      ConfigData;         // Internal data
    int                         CustomRectIds[1];   // Identifiers of custom texture rectangle used by ImFontAtlas/ImDrawList

#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
    typedef ImFontAtlasCustomRect    CustomRect;         // OBSOLETED in 1.72+
    typedef ImFontGlyphRangesBuilder GlyphRangesBuilder; // OBSOLETED in 1.67+
#endif
};

// Font runtime data and rendering
// ImFontAtlas automatically loads a default embedded font for you when you call GetTexDataAsAlpha8() or GetTexDataAsRGBA32().
struct ImFont
{
    // Members: Hot ~20/24 bytes (for CalcTextSize)
    ImVector<float>             IndexAdvanceX;      // 12-16 // out //            // Sparse. Glyphs->AdvanceX in a directly indexable way (cache-friendly for CalcTextSize functions which only this this info, and are often bottleneck in large UI).
    float                       FallbackAdvanceX;   // 4     // out // = FallbackGlyph->AdvanceX
    float                       FontSize;           // 4     // in  //            // Height of characters/line, set during loading (don't change after loading)

    // Members: Hot ~36/48 bytes (for CalcTextSize + render loop)
    ImVector<ImWchar>           IndexLookup;        // 12-16 // out //            // Sparse. Index glyphs by Unicode code-point.
    ImVector<ImFontGlyph>       Glyphs;             // 12-16 // out //            // All glyphs.
    const ImFontGlyph*          FallbackGlyph;      // 4-8   // out // = FindGlyph(FontFallbackChar)
    ImVec2                      DisplayOffset;      // 8     // in  // = (0,0)    // Offset font rendering by xx pixels

    // Members: Cold ~32/40 bytes
    ImFontAtlas*                ContainerAtlas;     // 4-8   // out //            // What we has been loaded into
    const ImFontConfig*         ConfigData;         // 4-8   // in  //            // Pointer within ContainerAtlas->ConfigData
    short                       ConfigDataCount;    // 2     // in  // ~ 1        // Number of ImFontConfig involved in creating this font. Bigger than 1 when merging multiple font sources into one ImFont.
    ImWchar                     FallbackChar;       // 2     // in  // = '?'      // Replacement character if a glyph isn't found. Only set via SetFallbackChar()
    ImWchar                     EllipsisChar;       // 2     // out // = -1       // Character used for ellipsis rendering.
    float                       Scale;              // 4     // in  // = 1.f      // Base font scale, multiplied by the per-window font scale which you can adjust with SetWindowFontScale()
    float                       Ascent, Descent;    // 4+4   // out //            // Ascent: distance from top to bottom of e.g. 'A' [0..FontSize]
    int                         MetricsTotalSurface;// 4     // out //            // Total surface in pixels to get an idea of the font rasterization/texture cost (not exact, we approximate the cost of padding between glyphs)
    bool                        DirtyLookupTables;  // 1     // out //

    // Methods
    IMGUI_API ImFont();
    IMGUI_API ~ImFont();
    IMGUI_API const ImFontGlyph*FindGlyph(ImWchar c) const;
    IMGUI_API const ImFontGlyph*FindGlyphNoFallback(ImWchar c) const;
    float                       GetCharAdvance(ImWchar c) const     { return ((int)c < IndexAdvanceX.Size) ? IndexAdvanceX[(int)c] : FallbackAdvanceX; }
    bool                        IsLoaded() const                    { return ContainerAtlas != NULL; }
    const char*                 GetDebugName() const                { return ConfigData ? ConfigData->Name : "<unknown>"; }

    // 'max_width' stops rendering after a certain width (could be turned into a 2d size). FLT_MAX to disable.
    // 'wrap_width' enable automatic word-wrapping across multiple lines to fit into given width. 0.0f to disable.
    IMGUI_API ImVec2            CalcTextSizeA(float size, float max_width, float wrap_width, const char* text_begin, const char* text_end = NULL, const char** remaining = NULL) const; // utf8
    IMGUI_API const char*       CalcWordWrapPositionA(float scale, const char* text, const char* text_end, float wrap_width) const;
    IMGUI_API void              RenderChar(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, ImWchar c) const;
    IMGUI_API void              RenderText(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, const ImVec4& clip_rect, const char* text_begin, const char* text_end, float wrap_width = 0.0f, bool cpu_fine_clip = false) const;

    // [Internal] Don't use!
    IMGUI_API void              BuildLookupTable();
    IMGUI_API void              ClearOutputData();
    IMGUI_API void              GrowIndex(int new_size);
    IMGUI_API void              AddGlyph(ImWchar c, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advance_x);
    IMGUI_API void              AddRemapChar(ImWchar dst, ImWchar src, bool overwrite_dst = true); // Makes 'dst' character/glyph points to 'src' character/glyph. Currently needs to be called AFTER fonts have been built.
    IMGUI_API void              SetFallbackChar(ImWchar c);
};

#if defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

// Include imgui_user.h at the end of imgui.h (convenient for user to only explicitly include vanilla imgui.h)
#ifdef IMGUI_INCLUDE_IMGUI_USER_H
#include "imgui_user.h"
#endif

```

`Artemis/ImGui/imgui_impl_dx11.h`:

```h
// dear imgui: Renderer for DirectX11
// This needs to be used along with a Platform Binding (e.g. Win32)

// Implemented features:
//  [X] Renderer: User texture binding. Use 'ID3D11ShaderResourceView*' as ImTextureID. Read the FAQ about ImTextureID!
//  [X] Renderer: Support for large meshes (64k+ vertices) with 16-bit indices.

// You can copy and use unmodified imgui_impl_* files in your project. See main.cpp for an example of using this.
// If you are new to dear imgui, read examples/README.txt and read the documentation at the top of imgui.cpp.
// https://github.com/ocornut/imgui

#pragma once

struct ID3D11Device;
struct ID3D11DeviceContext;

IMGUI_IMPL_API bool     ImGui_ImplDX11_Init(ID3D11Device* device, ID3D11DeviceContext* device_context);
IMGUI_IMPL_API void     ImGui_ImplDX11_Shutdown();
IMGUI_IMPL_API void     ImGui_ImplDX11_NewFrame();
IMGUI_IMPL_API void     ImGui_ImplDX11_RenderDrawData(ImDrawData* draw_data);

// Use if you want to reset your rendering device without losing ImGui state.
IMGUI_IMPL_API void     ImGui_ImplDX11_InvalidateDeviceObjects();
IMGUI_IMPL_API bool     ImGui_ImplDX11_CreateDeviceObjects();

```

`Artemis/ImGui/imgui_impl_win32.h`:

```h
// dear imgui: Platform Binding for Windows (standard windows API for 32 and 64 bits applications)
// This needs to be used along with a Renderer (e.g. DirectX11, OpenGL3, Vulkan..)

// Implemented features:
//  [X] Platform: Clipboard support (for Win32 this is actually part of core imgui)
//  [X] Platform: Mouse cursor shape and visibility. Disable with 'io.ConfigFlags |= ImGuiConfigFlags_NoMouseCursorChange'.
//  [X] Platform: Keyboard arrays indexed using VK_* Virtual Key Codes, e.g. ImGui::IsKeyPressed(VK_SPACE).
//  [X] Platform: Gamepad support. Enabled with 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad'.

#pragma once

#include <Windows.h>

IMGUI_IMPL_API bool     ImGui_ImplWin32_Init(void* hwnd);
IMGUI_IMPL_API void     ImGui_ImplWin32_Shutdown();
IMGUI_IMPL_API void     ImGui_ImplWin32_NewFrame();
IMGUI_IMPL_API LRESULT  ImGui_ImplWin32_WndProcHandler(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

// Handler for Win32 messages, update mouse/keyboard data.
// You may or not need this for your implementation, but it can serve as reference for handling inputs.
// Intentionally commented out to avoid dragging dependencies on <windows.h> types. You can COPY this line into your .cpp code instead.
/*
IMGUI_IMPL_API LRESULT  ImGui_ImplWin32_WndProcHandler(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
*/

```

`Artemis/ImGui/imgui_internal.h`:

```h
// dear imgui, v1.75 WIP
// (internal structures/api)

// You may use this file to debug, understand or extend ImGui features but we don't provide any guarantee of forward compatibility!
// Set:
//   #define IMGUI_DEFINE_MATH_OPERATORS
// To implement maths operators for ImVec2 (disabled by default to not collide with using IM_VEC2_CLASS_EXTRA along with your own math types+operators)

/*

Index of this file:
// Header mess
// Forward declarations
// STB libraries includes
// Context pointer
// Generic helpers
// Misc data structures
// Main imgui context
// Tab bar, tab item
// Internal API

*/

#pragma once

//-----------------------------------------------------------------------------
// Header mess
//-----------------------------------------------------------------------------

#ifndef IMGUI_VERSION
#error Must include imgui.h before imgui_internal.h
#endif

#include <stdio.h>      // FILE*, sscanf
#include <stdlib.h>     // NULL, malloc, free, qsort, atoi, atof
#include <math.h>       // sqrtf, fabsf, fmodf, powf, floorf, ceilf, cosf, sinf
#include <limits.h>     // INT_MIN, INT_MAX

// Visual Studio warnings
#ifdef _MSC_VER
#pragma warning (push)
#pragma warning (disable: 4251) // class 'xxx' needs to have dll-interface to be used by clients of struct 'xxx' // when IMGUI_API is set to__declspec(dllexport)
#endif

// Clang/GCC warnings with -Weverything
#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-function"        // for stb_textedit.h
#pragma clang diagnostic ignored "-Wmissing-prototypes"     // for stb_textedit.h
#pragma clang diagnostic ignored "-Wold-style-cast"
#if __has_warning("-Wzero-as-null-pointer-constant")
#pragma clang diagnostic ignored "-Wzero-as-null-pointer-constant"
#endif
#if __has_warning("-Wdouble-promotion")
#pragma clang diagnostic ignored "-Wdouble-promotion"
#endif
#elif defined(__GNUC__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wpragmas"                  // warning: unknown option after '#pragma GCC diagnostic' kind
#pragma GCC diagnostic ignored "-Wclass-memaccess"          // [__GNUC__ >= 8] warning: 'memset/memcpy' clearing/writing an object of type 'xxxx' with no trivial copy-assignment; use assignment or value-initialization instead
#endif

// Legacy defines
#ifdef IMGUI_DISABLE_FORMAT_STRING_FUNCTIONS                // Renamed in 1.74
#error Use IMGUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS
#endif
#ifdef IMGUI_DISABLE_MATH_FUNCTIONS                         // Renamed in 1.74
#error Use IMGUI_DISABLE_DEFAULT_MATH_FUNCTIONS
#endif

//-----------------------------------------------------------------------------
// Forward declarations
//-----------------------------------------------------------------------------

struct ImBoolVector;                // Store 1-bit per value
struct ImRect;                      // An axis-aligned rectangle (2 points)
struct ImDrawDataBuilder;           // Helper to build a ImDrawData instance
struct ImDrawListSharedData;        // Data shared between all ImDrawList instances
struct ImGuiColorMod;               // Stacked color modifier, backup of modified data so we can restore it
struct ImGuiColumnData;             // Storage data for a single column
struct ImGuiColumns;                // Storage data for a columns set
struct ImGuiContext;                // Main Dear ImGui context
struct ImGuiDataTypeInfo;           // Type information associated to a ImGuiDataType enum
struct ImGuiGroupData;              // Stacked storage data for BeginGroup()/EndGroup()
struct ImGuiInputTextState;         // Internal state of the currently focused/edited text input box
struct ImGuiItemHoveredDataBackup;  // Backup and restore IsItemHovered() internal data
struct ImGuiMenuColumns;            // Simple column measurement, currently used for MenuItem() only
struct ImGuiNavMoveResult;          // Result of a directional navigation move query result
struct ImGuiNextWindowData;         // Storage for SetNextWindow** functions
struct ImGuiNextItemData;           // Storage for SetNextItem** functions
struct ImGuiPopupData;              // Storage for current popup stack
struct ImGuiSettingsHandler;        // Storage for one type registered in the .ini file
struct ImGuiStyleMod;               // Stacked style modifier, backup of modified data so we can restore it
struct ImGuiTabBar;                 // Storage for a tab bar
struct ImGuiTabItem;                // Storage for a tab item (within a tab bar)
struct ImGuiWindow;                 // Storage for one window
struct ImGuiWindowTempData;         // Temporary storage for one window (that's the data which in theory we could ditch at the end of the frame)
struct ImGuiWindowSettings;         // Storage for a window .ini settings (we keep one of those even if the actual window wasn't instanced during this session)

// Use your programming IDE "Go to definition" facility on the names of the center columns to find the actual flags/enum lists.
typedef int ImGuiLayoutType;            // -> enum ImGuiLayoutType_         // Enum: Horizontal or vertical
typedef int ImGuiButtonFlags;           // -> enum ImGuiButtonFlags_        // Flags: for ButtonEx(), ButtonBehavior()
typedef int ImGuiColumnsFlags;          // -> enum ImGuiColumnsFlags_       // Flags: BeginColumns()
typedef int ImGuiDragFlags;             // -> enum ImGuiDragFlags_          // Flags: for DragBehavior()
typedef int ImGuiItemFlags;             // -> enum ImGuiItemFlags_          // Flags: for PushItemFlag()
typedef int ImGuiItemStatusFlags;       // -> enum ImGuiItemStatusFlags_    // Flags: for DC.LastItemStatusFlags
typedef int ImGuiNavHighlightFlags;     // -> enum ImGuiNavHighlightFlags_  // Flags: for RenderNavHighlight()
typedef int ImGuiNavDirSourceFlags;     // -> enum ImGuiNavDirSourceFlags_  // Flags: for GetNavInputAmount2d()
typedef int ImGuiNavMoveFlags;          // -> enum ImGuiNavMoveFlags_       // Flags: for navigation requests
typedef int ImGuiNextItemDataFlags;     // -> enum ImGuiNextItemDataFlags_  // Flags: for SetNextItemXXX() functions
typedef int ImGuiNextWindowDataFlags;   // -> enum ImGuiNextWindowDataFlags_// Flags: for SetNextWindowXXX() functions
typedef int ImGuiSeparatorFlags;        // -> enum ImGuiSeparatorFlags_     // Flags: for SeparatorEx()
typedef int ImGuiSliderFlags;           // -> enum ImGuiSliderFlags_        // Flags: for SliderBehavior()
typedef int ImGuiTextFlags;             // -> enum ImGuiTextFlags_          // Flags: for TextEx()

//-------------------------------------------------------------------------
// STB libraries includes
//-------------------------------------------------------------------------

namespace ImStb
{

#undef STB_TEXTEDIT_STRING
#undef STB_TEXTEDIT_CHARTYPE
#define STB_TEXTEDIT_STRING             ImGuiInputTextState
#define STB_TEXTEDIT_CHARTYPE           ImWchar
#define STB_TEXTEDIT_GETWIDTH_NEWLINE   -1.0f
#define STB_TEXTEDIT_UNDOSTATECOUNT     99
#define STB_TEXTEDIT_UNDOCHARCOUNT      999
#include "imstb_textedit.h"

} // namespace ImStb

//-----------------------------------------------------------------------------
// Context pointer
//-----------------------------------------------------------------------------

#ifndef GImGui
extern IMGUI_API ImGuiContext* GImGui;  // Current implicit context pointer
#endif

//-----------------------------------------------------------------------------
// Macros
//-----------------------------------------------------------------------------

// Debug Logging
#ifndef IMGUI_DEBUG_LOG
#define IMGUI_DEBUG_LOG(_FMT,...)       printf("[%05d] " _FMT, GImGui->FrameCount, __VA_ARGS__)
#endif

// Static Asserts
#if (__cplusplus >= 201100)
#define IM_STATIC_ASSERT(_COND)         static_assert(_COND, "")
#else
#define IM_STATIC_ASSERT(_COND)         typedef char static_assertion_##__line__[(_COND)?1:-1]
#endif

// "Paranoid" Debug Asserts are meant to only be enabled during specific debugging/work, otherwise would slow down the code too much.
// We currently don't have many of those so the effect is currently negligible, but onward intent to add more aggressive ones in the code.
//#define IMGUI_DEBUG_PARANOID
#ifdef IMGUI_DEBUG_PARANOID
#define IM_ASSERT_PARANOID(_EXPR)       IM_ASSERT(_EXPR)
#else
#define IM_ASSERT_PARANOID(_EXPR)   
#endif

// Error handling
// Down the line in some frameworks/languages we would like to have a way to redirect those to the programmer and recover from more faults.
#ifndef IM_ASSERT_USER_ERROR
#define IM_ASSERT_USER_ERROR(_EXP,_MSG) IM_ASSERT((_EXP) && _MSG)   // Recoverable User Error
#endif

// Misc Macros
#define IM_PI                           3.14159265358979323846f
#ifdef _WIN32
#define IM_NEWLINE                      "\r\n"   // Play it nice with Windows users (Update: since 2018-05, Notepad finally appears to support Unix-style carriage returns!)
#else
#define IM_NEWLINE                      "\n"
#endif
#define IM_TABSIZE                      (4)
#define IM_F32_TO_INT8_UNBOUND(_VAL)    ((int)((_VAL) * 255.0f + ((_VAL)>=0 ? 0.5f : -0.5f)))   // Unsaturated, for display purpose
#define IM_F32_TO_INT8_SAT(_VAL)        ((int)(ImSaturate(_VAL) * 255.0f + 0.5f))               // Saturated, always output 0..255
#define IM_FLOOR(_VAL)                  ((float)(int)(_VAL))                                    // ImFloor() is not inlined in MSVC debug builds
#define IM_ROUND(_VAL)                  ((float)(int)((_VAL) + 0.5f))                           //

// Enforce cdecl calling convention for functions called by the standard library, in case compilation settings changed the default to e.g. __vectorcall
#ifdef _MSC_VER
#define IMGUI_CDECL __cdecl
#else
#define IMGUI_CDECL
#endif

//-----------------------------------------------------------------------------
// Generic helpers
//-----------------------------------------------------------------------------
// - Helpers: Misc
// - Helpers: Bit manipulation
// - Helpers: String, Formatting
// - Helpers: UTF-8 <> wchar conversions
// - Helpers: ImVec2/ImVec4 operators
// - Helpers: Maths
// - Helpers: Geometry
// - Helper: ImBoolVector
// - Helper: ImPool<>
// - Helper: ImChunkStream<>
//-----------------------------------------------------------------------------

// Helpers: Misc
#define ImQsort         qsort
IMGUI_API ImU32         ImHashData(const void* data, size_t data_size, ImU32 seed = 0);
IMGUI_API ImU32         ImHashStr(const char* data, size_t data_size = 0, ImU32 seed = 0);
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
static inline ImU32     ImHash(const void* data, int size, ImU32 seed = 0) { return size ? ImHashData(data, (size_t)size, seed) : ImHashStr((const char*)data, 0, seed); } // [moved to ImHashStr/ImHashData in 1.68]
#endif

// Helpers: Bit manipulation
static inline bool      ImIsPowerOfTwo(int v)           { return v != 0 && (v & (v - 1)) == 0; }
static inline int       ImUpperPowerOfTwo(int v)        { v--; v |= v >> 1; v |= v >> 2; v |= v >> 4; v |= v >> 8; v |= v >> 16; v++; return v; }

// Helpers: String, Formatting
IMGUI_API int           ImStricmp(const char* str1, const char* str2);
IMGUI_API int           ImStrnicmp(const char* str1, const char* str2, size_t count);
IMGUI_API void          ImStrncpy(char* dst, const char* src, size_t count);
IMGUI_API char*         ImStrdup(const char* str);
IMGUI_API char*         ImStrdupcpy(char* dst, size_t* p_dst_size, const char* str);
IMGUI_API const char*   ImStrchrRange(const char* str_begin, const char* str_end, char c);
IMGUI_API int           ImStrlenW(const ImWchar* str);
IMGUI_API const char*   ImStreolRange(const char* str, const char* str_end);                // End end-of-line
IMGUI_API const ImWchar*ImStrbolW(const ImWchar* buf_mid_line, const ImWchar* buf_begin);   // Find beginning-of-line
IMGUI_API const char*   ImStristr(const char* haystack, const char* haystack_end, const char* needle, const char* needle_end);
IMGUI_API void          ImStrTrimBlanks(char* str);
IMGUI_API const char*   ImStrSkipBlank(const char* str);
IMGUI_API int           ImFormatString(char* buf, size_t buf_size, const char* fmt, ...) IM_FMTARGS(3);
IMGUI_API int           ImFormatStringV(char* buf, size_t buf_size, const char* fmt, va_list args) IM_FMTLIST(3);
IMGUI_API const char*   ImParseFormatFindStart(const char* format);
IMGUI_API const char*   ImParseFormatFindEnd(const char* format);
IMGUI_API const char*   ImParseFormatTrimDecorations(const char* format, char* buf, size_t buf_size);
IMGUI_API int           ImParseFormatPrecision(const char* format, int default_value);
static inline bool      ImCharIsBlankA(char c)          { return c == ' ' || c == '\t'; }
static inline bool      ImCharIsBlankW(unsigned int c)  { return c == ' ' || c == '\t' || c == 0x3000; }

// Helpers: UTF-8 <> wchar conversions
IMGUI_API int           ImTextStrToUtf8(char* buf, int buf_size, const ImWchar* in_text, const ImWchar* in_text_end);      // return output UTF-8 bytes count
IMGUI_API int           ImTextCharFromUtf8(unsigned int* out_char, const char* in_text, const char* in_text_end);          // read one character. return input UTF-8 bytes count
IMGUI_API int           ImTextStrFromUtf8(ImWchar* buf, int buf_size, const char* in_text, const char* in_text_end, const char** in_remaining = NULL);   // return input UTF-8 bytes count
IMGUI_API int           ImTextCountCharsFromUtf8(const char* in_text, const char* in_text_end);                            // return number of UTF-8 code-points (NOT bytes count)
IMGUI_API int           ImTextCountUtf8BytesFromChar(const char* in_text, const char* in_text_end);                        // return number of bytes to express one char in UTF-8
IMGUI_API int           ImTextCountUtf8BytesFromStr(const ImWchar* in_text, const ImWchar* in_text_end);                   // return number of bytes to express string in UTF-8

// Helpers: ImVec2/ImVec4 operators
// We are keeping those disabled by default so they don't leak in user space, to allow user enabling implicit cast operators between ImVec2 and their own types (using IM_VEC2_CLASS_EXTRA etc.)
// We unfortunately don't have a unary- operator for ImVec2 because this would needs to be defined inside the class itself.
#ifdef IMGUI_DEFINE_MATH_OPERATORS
static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }
static inline ImVec2 operator/(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x/rhs, lhs.y/rhs); }
static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }
static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }
static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }
static inline ImVec2 operator/(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x/rhs.x, lhs.y/rhs.y); }
static inline ImVec2& operator+=(ImVec2& lhs, const ImVec2& rhs)                { lhs.x += rhs.x; lhs.y += rhs.y; return lhs; }
static inline ImVec2& operator-=(ImVec2& lhs, const ImVec2& rhs)                { lhs.x -= rhs.x; lhs.y -= rhs.y; return lhs; }
static inline ImVec2& operator*=(ImVec2& lhs, const float rhs)                  { lhs.x *= rhs; lhs.y *= rhs; return lhs; }
static inline ImVec2& operator/=(ImVec2& lhs, const float rhs)                  { lhs.x /= rhs; lhs.y /= rhs; return lhs; }
static inline ImVec4 operator+(const ImVec4& lhs, const ImVec4& rhs)            { return ImVec4(lhs.x+rhs.x, lhs.y+rhs.y, lhs.z+rhs.z, lhs.w+rhs.w); }
static inline ImVec4 operator-(const ImVec4& lhs, const ImVec4& rhs)            { return ImVec4(lhs.x-rhs.x, lhs.y-rhs.y, lhs.z-rhs.z, lhs.w-rhs.w); }
static inline ImVec4 operator*(const ImVec4& lhs, const ImVec4& rhs)            { return ImVec4(lhs.x*rhs.x, lhs.y*rhs.y, lhs.z*rhs.z, lhs.w*rhs.w); }
#endif

// Helpers: File System
#if defined(__EMSCRIPTEN__) && !defined(IMGUI_DISABLE_FILE_FUNCTIONS)
#define IMGUI_DISABLE_FILE_FUNCTIONS
#endif
#ifdef IMGUI_DISABLE_FILE_FUNCTIONS
#define IMGUI_DISABLE_DEFAULT_FILE_FUNCTIONS
typedef void* ImFileHandle;
static inline ImFileHandle  ImFileOpen(const char*, const char*)                    { return NULL; }
static inline bool          ImFileClose(ImFileHandle)                               { return false; }
static inline ImU64         ImFileGetSize(ImFileHandle)                             { return (ImU64)-1; }
static inline ImU64         ImFileRead(void*, ImU64, ImU64, ImFileHandle)           { return 0; }
static inline ImU64         ImFileWrite(const void*, ImU64, ImU64, ImFileHandle)    { return 0; }
#endif

#ifndef IMGUI_DISABLE_DEFAULT_FILE_FUNCTIONS
typedef FILE* ImFileHandle;
IMGUI_API ImFileHandle      ImFileOpen(const char* filename, const char* mode);
IMGUI_API bool              ImFileClose(ImFileHandle file);
IMGUI_API ImU64             ImFileGetSize(ImFileHandle file);
IMGUI_API ImU64             ImFileRead(void* data, ImU64 size, ImU64 count, ImFileHandle file);
IMGUI_API ImU64             ImFileWrite(const void* data, ImU64 size, ImU64 count, ImFileHandle file);
#else
#define IMGUI_DISABLE_TTY_FUNCTIONS // Can't use stdout, fflush if we are not using default file functions
#endif
IMGUI_API void*             ImFileLoadToMemory(const char* filename, const char* mode, size_t* out_file_size = NULL, int padding_bytes = 0);

// Helpers: Maths
// - Wrapper for standard libs functions. (Note that imgui_demo.cpp does _not_ use them to keep the code easy to copy)
#ifndef IMGUI_DISABLE_DEFAULT_MATH_FUNCTIONS
static inline float  ImFabs(float x)                                            { return fabsf(x); }
static inline float  ImSqrt(float x)                                            { return sqrtf(x); }
static inline float  ImPow(float x, float y)                                    { return powf(x, y); }
static inline double ImPow(double x, double y)                                  { return pow(x, y); }
static inline float  ImFmod(float x, float y)                                   { return fmodf(x, y); }
static inline double ImFmod(double x, double y)                                 { return fmod(x, y); }
static inline float  ImCos(float x)                                             { return cosf(x); }
static inline float  ImSin(float x)                                             { return sinf(x); }
static inline float  ImAcos(float x)                                            { return acosf(x); }
static inline float  ImAtan2(float y, float x)                                  { return atan2f(y, x); }
static inline double ImAtof(const char* s)                                      { return atof(s); }
static inline float  ImFloorStd(float x)                                        { return floorf(x); }   // we already uses our own ImFloor() { return (float)(int)v } internally so the standard one wrapper is named differently (it's used by stb_truetype)
static inline float  ImCeil(float x)                                            { return ceilf(x); }
#endif
// - ImMin/ImMax/ImClamp/ImLerp/ImSwap are used by widgets which support for variety of types: signed/unsigned int/long long float/double
// (Exceptionally using templates here but we could also redefine them for variety of types)
template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }
template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }
template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }
template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }
template<typename T> static inline void ImSwap(T& a, T& b)                      { T tmp = a; a = b; b = tmp; }
template<typename T> static inline T ImAddClampOverflow(T a, T b, T mn, T mx)   { if (b < 0 && (a < mn - b)) return mn; if (b > 0 && (a > mx - b)) return mx; return a + b; }
template<typename T> static inline T ImSubClampOverflow(T a, T b, T mn, T mx)   { if (b > 0 && (a < mn + b)) return mn; if (b < 0 && (a > mx + b)) return mx; return a - b; }
// - Misc maths helpers
static inline ImVec2 ImMin(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x < rhs.x ? lhs.x : rhs.x, lhs.y < rhs.y ? lhs.y : rhs.y); }
static inline ImVec2 ImMax(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x >= rhs.x ? lhs.x : rhs.x, lhs.y >= rhs.y ? lhs.y : rhs.y); }
static inline ImVec2 ImClamp(const ImVec2& v, const ImVec2& mn, ImVec2 mx)      { return ImVec2((v.x < mn.x) ? mn.x : (v.x > mx.x) ? mx.x : v.x, (v.y < mn.y) ? mn.y : (v.y > mx.y) ? mx.y : v.y); }
static inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, float t)          { return ImVec2(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t); }
static inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, const ImVec2& t)  { return ImVec2(a.x + (b.x - a.x) * t.x, a.y + (b.y - a.y) * t.y); }
static inline ImVec4 ImLerp(const ImVec4& a, const ImVec4& b, float t)          { return ImVec4(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t); }
static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }
static inline float  ImLengthSqr(const ImVec2& lhs)                             { return lhs.x*lhs.x + lhs.y*lhs.y; }
static inline float  ImLengthSqr(const ImVec4& lhs)                             { return lhs.x*lhs.x + lhs.y*lhs.y + lhs.z*lhs.z + lhs.w*lhs.w; }
static inline float  ImInvLength(const ImVec2& lhs, float fail_value)           { float d = lhs.x*lhs.x + lhs.y*lhs.y; if (d > 0.0f) return 1.0f / ImSqrt(d); return fail_value; }
static inline float  ImFloor(float f)                                           { return (float)(int)(f); }
static inline ImVec2 ImFloor(const ImVec2& v)                                   { return ImVec2((float)(int)(v.x), (float)(int)(v.y)); }
static inline int    ImModPositive(int a, int b)                                { return (a + b) % b; }
static inline float  ImDot(const ImVec2& a, const ImVec2& b)                    { return a.x * b.x + a.y * b.y; }
static inline ImVec2 ImRotate(const ImVec2& v, float cos_a, float sin_a)        { return ImVec2(v.x * cos_a - v.y * sin_a, v.x * sin_a + v.y * cos_a); }
static inline float  ImLinearSweep(float current, float target, float speed)    { if (current < target) return ImMin(current + speed, target); if (current > target) return ImMax(current - speed, target); return current; }
static inline ImVec2 ImMul(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }

// Helpers: Geometry
IMGUI_API ImVec2     ImLineClosestPoint(const ImVec2& a, const ImVec2& b, const ImVec2& p);
IMGUI_API bool       ImTriangleContainsPoint(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p);
IMGUI_API ImVec2     ImTriangleClosestPoint(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p);
IMGUI_API void       ImTriangleBarycentricCoords(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p, float& out_u, float& out_v, float& out_w);
inline float         ImTriangleArea(const ImVec2& a, const ImVec2& b, const ImVec2& c) { return ImFabs((a.x * (b.y - c.y)) + (b.x * (c.y - a.y)) + (c.x * (a.y - b.y))) * 0.5f; }
IMGUI_API ImGuiDir   ImGetDirQuadrantFromDelta(float dx, float dy);

// Helper: ImBoolVector
// Store 1-bit per value. Note that Resize() currently clears the whole vector.
struct IMGUI_API ImBoolVector
{
    ImVector<int>   Storage;
    ImBoolVector()  { }
    void            Resize(int sz)          { Storage.resize((sz + 31) >> 5); memset(Storage.Data, 0, (size_t)Storage.Size * sizeof(Storage.Data[0])); }
    void            Clear()                 { Storage.clear(); }
    bool            GetBit(int n) const     { int off = (n >> 5); int mask = 1 << (n & 31); return (Storage[off] & mask) != 0; }
    void            SetBit(int n, bool v)   { int off = (n >> 5); int mask = 1 << (n & 31); if (v) Storage[off] |= mask; else Storage[off] &= ~mask; }
};

// Helper: ImPool<>
// Basic keyed storage for contiguous instances, slow/amortized insertion, O(1) indexable, O(Log N) queries by ID over a dense/hot buffer,
// Honor constructor/destructor. Add/remove invalidate all pointers. Indexes have the same lifetime as the associated object.
typedef int ImPoolIdx;
template<typename T>
struct IMGUI_API ImPool
{
    ImVector<T>     Buf;        // Contiguous data
    ImGuiStorage    Map;        // ID->Index
    ImPoolIdx       FreeIdx;    // Next free idx to use

    ImPool()    { FreeIdx = 0; }
    ~ImPool()   { Clear(); }
    T*          GetByKey(ImGuiID key)               { int idx = Map.GetInt(key, -1); return (idx != -1) ? &Buf[idx] : NULL; }
    T*          GetByIndex(ImPoolIdx n)             { return &Buf[n]; }
    ImPoolIdx   GetIndex(const T* p) const          { IM_ASSERT(p >= Buf.Data && p < Buf.Data + Buf.Size); return (ImPoolIdx)(p - Buf.Data); }
    T*          GetOrAddByKey(ImGuiID key)          { int* p_idx = Map.GetIntRef(key, -1); if (*p_idx != -1) return &Buf[*p_idx]; *p_idx = FreeIdx; return Add(); }
    bool        Contains(const T* p) const          { return (p >= Buf.Data && p < Buf.Data + Buf.Size); }
    void        Clear()                             { for (int n = 0; n < Map.Data.Size; n++) { int idx = Map.Data[n].val_i; if (idx != -1) Buf[idx].~T(); } Map.Clear(); Buf.clear(); FreeIdx = 0; }
    T*          Add()                               { int idx = FreeIdx; if (idx == Buf.Size) { Buf.resize(Buf.Size + 1); FreeIdx++; } else { FreeIdx = *(int*)&Buf[idx]; } IM_PLACEMENT_NEW(&Buf[idx]) T(); return &Buf[idx]; }
    void        Remove(ImGuiID key, const T* p)     { Remove(key, GetIndex(p)); }
    void        Remove(ImGuiID key, ImPoolIdx idx)  { Buf[idx].~T(); *(int*)&Buf[idx] = FreeIdx; FreeIdx = idx; Map.SetInt(key, -1); }
    void        Reserve(int capacity)               { Buf.reserve(capacity); Map.Data.reserve(capacity); }
    int         GetSize() const                     { return Buf.Size; }
};

// Helper: ImChunkStream<>
// Build and iterate a contiguous stream of variable-sized structures.
// This is used by Settings to store persistent data while reducing allocation count.
// We store the chunk size first, and align the final size on 4 bytes boundaries (this what the '(X + 3) & ~3' statement is for)
// The tedious/zealous amount of casting is to avoid -Wcast-align warnings.
template<typename T>
struct IMGUI_API ImChunkStream
{
    ImVector<char>  Buf;

    void    clear()                     { Buf.clear(); }
    bool    empty() const               { return Buf.Size == 0; }
    int     size() const                { return Buf.Size; }
    T*      alloc_chunk(size_t sz)      { size_t HDR_SZ = 4; sz = ((HDR_SZ + sz) + 3u) & ~3u; int off = Buf.Size; Buf.resize(off + (int)sz); ((int*)(void*)(Buf.Data + off))[0] = (int)sz; return (T*)(void*)(Buf.Data + off + (int)HDR_SZ); }
    T*      begin()                     { size_t HDR_SZ = 4; if (!Buf.Data) return NULL; return (T*)(void*)(Buf.Data + HDR_SZ); }
    T*      next_chunk(T* p)            { size_t HDR_SZ = 4; IM_ASSERT(p >= begin() && p < end()); p = (T*)(void*)((char*)(void*)p + chunk_size(p)); if (p == (T*)(void*)((char*)end() + HDR_SZ)) return (T*)0; IM_ASSERT(p < end()); return p; }
    int     chunk_size(const T* p)      { return ((const int*)p)[-1]; }
    T*      end()                       { return (T*)(void*)(Buf.Data + Buf.Size); }
    int     offset_from_ptr(const T* p) { IM_ASSERT(p >= begin() && p < end()); const ptrdiff_t off = (const char*)p - Buf.Data; return (int)off; }
    T*      ptr_from_offset(int off)    { IM_ASSERT(off >= 4 && off < Buf.Size); return (T*)(void*)(Buf.Data + off); }
};

//-----------------------------------------------------------------------------
// Misc data structures
//-----------------------------------------------------------------------------

enum ImGuiButtonFlags_
{
    ImGuiButtonFlags_None                   = 0,
    ImGuiButtonFlags_Repeat                 = 1 << 0,   // hold to repeat
    ImGuiButtonFlags_PressedOnClickRelease  = 1 << 1,   // [Default] return true on click + release on same item
    ImGuiButtonFlags_PressedOnClick         = 1 << 2,   // return true on click (default requires click+release)
    ImGuiButtonFlags_PressedOnRelease       = 1 << 3,   // return true on release (default requires click+release)
    ImGuiButtonFlags_PressedOnDoubleClick   = 1 << 4,   // return true on double-click (default requires click+release)
    ImGuiButtonFlags_FlattenChildren        = 1 << 5,   // allow interactions even if a child window is overlapping
    ImGuiButtonFlags_AllowItemOverlap       = 1 << 6,   // require previous frame HoveredId to either match id or be null before being usable, use along with SetItemAllowOverlap()
    ImGuiButtonFlags_DontClosePopups        = 1 << 7,   // disable automatically closing parent popup on press // [UNUSED]
    ImGuiButtonFlags_Disabled               = 1 << 8,   // disable interactions
    ImGuiButtonFlags_AlignTextBaseLine      = 1 << 9,   // vertically align button to match text baseline - ButtonEx() only // FIXME: Should be removed and handled by SmallButton(), not possible currently because of DC.CursorPosPrevLine
    ImGuiButtonFlags_NoKeyModifiers         = 1 << 10,  // disable mouse interaction if a key modifier is held
    ImGuiButtonFlags_NoHoldingActiveID      = 1 << 11,  // don't set ActiveId while holding the mouse (ImGuiButtonFlags_PressedOnClick only)
    ImGuiButtonFlags_PressedOnDragDropHold  = 1 << 12,  // press when held into while we are drag and dropping another item (used by e.g. tree nodes, collapsing headers)
    ImGuiButtonFlags_NoNavFocus             = 1 << 13,  // don't override navigation focus when activated
    ImGuiButtonFlags_NoHoveredOnNav         = 1 << 14   // don't report as hovered when navigated on
};

enum ImGuiSliderFlags_
{
    ImGuiSliderFlags_None                   = 0,
    ImGuiSliderFlags_Vertical               = 1 << 0
};

enum ImGuiDragFlags_
{
    ImGuiDragFlags_None                     = 0,
    ImGuiDragFlags_Vertical                 = 1 << 0
};

enum ImGuiColumnsFlags_
{
    // Default: 0
    ImGuiColumnsFlags_None                  = 0,
    ImGuiColumnsFlags_NoBorder              = 1 << 0,   // Disable column dividers
    ImGuiColumnsFlags_NoResize              = 1 << 1,   // Disable resizing columns when clicking on the dividers
    ImGuiColumnsFlags_NoPreserveWidths      = 1 << 2,   // Disable column width preservation when adjusting columns
    ImGuiColumnsFlags_NoForceWithinWindow   = 1 << 3,   // Disable forcing columns to fit within window
    ImGuiColumnsFlags_GrowParentContentsSize= 1 << 4    // (WIP) Restore pre-1.51 behavior of extending the parent window contents size but _without affecting the columns width at all_. Will eventually remove.
};

// Extend ImGuiSelectableFlags_
enum ImGuiSelectableFlagsPrivate_
{
    // NB: need to be in sync with last value of ImGuiSelectableFlags_
    ImGuiSelectableFlags_NoHoldingActiveID  = 1 << 20,
    ImGuiSelectableFlags_PressedOnClick     = 1 << 21,
    ImGuiSelectableFlags_PressedOnRelease   = 1 << 22,
    ImGuiSelectableFlags_DrawFillAvailWidth = 1 << 23,  // FIXME: We may be able to remove this (added in 6251d379 for menus)
    ImGuiSelectableFlags_DrawHoveredWhenHeld= 1 << 24,  // Always show active when held, even is not hovered. This concept could probably be renamed/formalized somehow.
    ImGuiSelectableFlags_SetNavIdOnHover    = 1 << 25
};

// Extend ImGuiTreeNodeFlags_
enum ImGuiTreeNodeFlagsPrivate_
{
    ImGuiTreeNodeFlags_ClipLabelForTrailingButton = 1 << 20
};

enum ImGuiSeparatorFlags_
{
    ImGuiSeparatorFlags_None                = 0,
    ImGuiSeparatorFlags_Horizontal          = 1 << 0,   // Axis default to current layout type, so generally Horizontal unless e.g. in a menu bar
    ImGuiSeparatorFlags_Vertical            = 1 << 1,
    ImGuiSeparatorFlags_SpanAllColumns      = 1 << 2
};

// Transient per-window flags, reset at the beginning of the frame. For child window, inherited from parent on first Begin().
// This is going to be exposed in imgui.h when stabilized enough.
enum ImGuiItemFlags_
{
    ImGuiItemFlags_None                     = 0,
    ImGuiItemFlags_NoTabStop                = 1 << 0,  // false
    ImGuiItemFlags_ButtonRepeat             = 1 << 1,  // false    // Button() will return true multiple times based on io.KeyRepeatDelay and io.KeyRepeatRate settings.
    ImGuiItemFlags_Disabled                 = 1 << 2,  // false    // [BETA] Disable interactions but doesn't affect visuals yet. See github.com/ocornut/imgui/issues/211
    ImGuiItemFlags_NoNav                    = 1 << 3,  // false
    ImGuiItemFlags_NoNavDefaultFocus        = 1 << 4,  // false
    ImGuiItemFlags_SelectableDontClosePopup = 1 << 5,  // false    // MenuItem/Selectable() automatically closes current Popup window
    ImGuiItemFlags_MixedValue               = 1 << 6,  // false    // [BETA] Represent a mixed/indeterminate value, generally multi-selection where values differ. Currently only supported by Checkbox() (later should support all sorts of widgets)
    ImGuiItemFlags_Default_                 = 0
};

// Storage for LastItem data
enum ImGuiItemStatusFlags_
{
    ImGuiItemStatusFlags_None               = 0,
    ImGuiItemStatusFlags_HoveredRect        = 1 << 0,
    ImGuiItemStatusFlags_HasDisplayRect     = 1 << 1,
    ImGuiItemStatusFlags_Edited             = 1 << 2,   // Value exposed by item was edited in the current frame (should match the bool return value of most widgets)
    ImGuiItemStatusFlags_ToggledSelection   = 1 << 3,   // Set when Selectable(), TreeNode() reports toggling a selection. We can't report "Selected" because reporting the change allows us to handle clipping with less issues.
    ImGuiItemStatusFlags_ToggledOpen        = 1 << 4,   // Set when TreeNode() reports toggling their open state. 
    ImGuiItemStatusFlags_HasDeactivated     = 1 << 5,   // Set if the widget/group is able to provide data for the ImGuiItemStatusFlags_Deactivated flag.
    ImGuiItemStatusFlags_Deactivated        = 1 << 6    // Only valid if ImGuiItemStatusFlags_HasDeactivated is set.

#ifdef IMGUI_ENABLE_TEST_ENGINE
    , // [imgui_tests only]
    ImGuiItemStatusFlags_Openable           = 1 << 10,  //
    ImGuiItemStatusFlags_Opened             = 1 << 11,  //
    ImGuiItemStatusFlags_Checkable          = 1 << 12,  //
    ImGuiItemStatusFlags_Checked            = 1 << 13   //
#endif
};

enum ImGuiTextFlags_
{
    ImGuiTextFlags_None = 0,
    ImGuiTextFlags_NoWidthForLargeClippedText = 1 << 0
};

// FIXME: this is in development, not exposed/functional as a generic feature yet.
// Horizontal/Vertical enums are fixed to 0/1 so they may be used to index ImVec2
enum ImGuiLayoutType_
{
    ImGuiLayoutType_Horizontal = 0,
    ImGuiLayoutType_Vertical = 1
};

enum ImGuiLogType
{
    ImGuiLogType_None = 0,
    ImGuiLogType_TTY,
    ImGuiLogType_File,
    ImGuiLogType_Buffer,
    ImGuiLogType_Clipboard
};

// X/Y enums are fixed to 0/1 so they may be used to index ImVec2
enum ImGuiAxis
{
    ImGuiAxis_None = -1,
    ImGuiAxis_X = 0,
    ImGuiAxis_Y = 1
};

enum ImGuiPlotType
{
    ImGuiPlotType_Lines,
    ImGuiPlotType_Histogram
};

enum ImGuiInputSource
{
    ImGuiInputSource_None = 0,
    ImGuiInputSource_Mouse,
    ImGuiInputSource_Nav,
    ImGuiInputSource_NavKeyboard,   // Only used occasionally for storage, not tested/handled by most code
    ImGuiInputSource_NavGamepad,    // "
    ImGuiInputSource_COUNT
};

// FIXME-NAV: Clarify/expose various repeat delay/rate
enum ImGuiInputReadMode
{
    ImGuiInputReadMode_Down,
    ImGuiInputReadMode_Pressed,
    ImGuiInputReadMode_Released,
    ImGuiInputReadMode_Repeat,
    ImGuiInputReadMode_RepeatSlow,
    ImGuiInputReadMode_RepeatFast
};

enum ImGuiNavHighlightFlags_
{
    ImGuiNavHighlightFlags_None         = 0,
    ImGuiNavHighlightFlags_TypeDefault  = 1 << 0,
    ImGuiNavHighlightFlags_TypeThin     = 1 << 1,
    ImGuiNavHighlightFlags_AlwaysDraw   = 1 << 2,       // Draw rectangular highlight if (g.NavId == id) _even_ when using the mouse.
    ImGuiNavHighlightFlags_NoRounding   = 1 << 3
};

enum ImGuiNavDirSourceFlags_
{
    ImGuiNavDirSourceFlags_None         = 0,
    ImGuiNavDirSourceFlags_Keyboard     = 1 << 0,
    ImGuiNavDirSourceFlags_PadDPad      = 1 << 1,
    ImGuiNavDirSourceFlags_PadLStick    = 1 << 2
};

enum ImGuiNavMoveFlags_
{
    ImGuiNavMoveFlags_None                  = 0,
    ImGuiNavMoveFlags_LoopX                 = 1 << 0,   // On failed request, restart from opposite side
    ImGuiNavMoveFlags_LoopY                 = 1 << 1,
    ImGuiNavMoveFlags_WrapX                 = 1 << 2,   // On failed request, request from opposite side one line down (when NavDir==right) or one line up (when NavDir==left)
    ImGuiNavMoveFlags_WrapY                 = 1 << 3,   // This is not super useful for provided for completeness
    ImGuiNavMoveFlags_AllowCurrentNavId     = 1 << 4,   // Allow scoring and considering the current NavId as a move target candidate. This is used when the move source is offset (e.g. pressing PageDown actually needs to send a Up move request, if we are pressing PageDown from the bottom-most item we need to stay in place)
    ImGuiNavMoveFlags_AlsoScoreVisibleSet   = 1 << 5,   // Store alternate result in NavMoveResultLocalVisibleSet that only comprise elements that are already fully visible.
    ImGuiNavMoveFlags_ScrollToEdge          = 1 << 6
};

enum ImGuiNavForward
{
    ImGuiNavForward_None,
    ImGuiNavForward_ForwardQueued,
    ImGuiNavForward_ForwardActive
};

enum ImGuiNavLayer
{
    ImGuiNavLayer_Main  = 0,    // Main scrolling layer
    ImGuiNavLayer_Menu  = 1,    // Menu layer (access with Alt/ImGuiNavInput_Menu)
    ImGuiNavLayer_COUNT
};

enum ImGuiPopupPositionPolicy
{
    ImGuiPopupPositionPolicy_Default,
    ImGuiPopupPositionPolicy_ComboBox
};

// 1D vector (this odd construct is used to facilitate the transition between 1D and 2D, and the maintenance of some branches/patches)
struct ImVec1
{
    float   x;
    ImVec1()         { x = 0.0f; }
    ImVec1(float _x) { x = _x; }
};

// 2D vector (half-size integer)
struct ImVec2ih
{
    short   x, y;
    ImVec2ih()                   { x = y = 0; }
    ImVec2ih(short _x, short _y) { x = _x; y = _y; }
};

// 2D axis aligned bounding-box
// NB: we can't rely on ImVec2 math operators being available here
struct IMGUI_API ImRect
{
    ImVec2      Min;    // Upper-left
    ImVec2      Max;    // Lower-right

    ImRect()                                        : Min(0.0f, 0.0f), Max(0.0f, 0.0f)              {}
    ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}
    ImRect(const ImVec4& v)                         : Min(v.x, v.y), Max(v.z, v.w)                  {}
    ImRect(float x1, float y1, float x2, float y2)  : Min(x1, y1), Max(x2, y2)                      {}

    ImVec2      GetCenter() const                   { return ImVec2((Min.x + Max.x) * 0.5f, (Min.y + Max.y) * 0.5f); }
    ImVec2      GetSize() const                     { return ImVec2(Max.x - Min.x, Max.y - Min.y); }
    float       GetWidth() const                    { return Max.x - Min.x; }
    float       GetHeight() const                   { return Max.y - Min.y; }
    ImVec2      GetTL() const                       { return Min; }                   // Top-left
    ImVec2      GetTR() const                       { return ImVec2(Max.x, Min.y); }  // Top-right
    ImVec2      GetBL() const                       { return ImVec2(Min.x, Max.y); }  // Bottom-left
    ImVec2      GetBR() const                       { return Max; }                   // Bottom-right
    bool        Contains(const ImVec2& p) const     { return p.x     >= Min.x && p.y     >= Min.y && p.x     <  Max.x && p.y     <  Max.y; }
    bool        Contains(const ImRect& r) const     { return r.Min.x >= Min.x && r.Min.y >= Min.y && r.Max.x <= Max.x && r.Max.y <= Max.y; }
    bool        Overlaps(const ImRect& r) const     { return r.Min.y <  Max.y && r.Max.y >  Min.y && r.Min.x <  Max.x && r.Max.x >  Min.x; }
    void        Add(const ImVec2& p)                { if (Min.x > p.x)     Min.x = p.x;     if (Min.y > p.y)     Min.y = p.y;     if (Max.x < p.x)     Max.x = p.x;     if (Max.y < p.y)     Max.y = p.y; }
    void        Add(const ImRect& r)                { if (Min.x > r.Min.x) Min.x = r.Min.x; if (Min.y > r.Min.y) Min.y = r.Min.y; if (Max.x < r.Max.x) Max.x = r.Max.x; if (Max.y < r.Max.y) Max.y = r.Max.y; }
    void        Expand(const float amount)          { Min.x -= amount;   Min.y -= amount;   Max.x += amount;   Max.y += amount; }
    void        Expand(const ImVec2& amount)        { Min.x -= amount.x; Min.y -= amount.y; Max.x += amount.x; Max.y += amount.y; }
    void        Translate(const ImVec2& d)          { Min.x += d.x; Min.y += d.y; Max.x += d.x; Max.y += d.y; }
    void        TranslateX(float dx)                { Min.x += dx; Max.x += dx; }
    void        TranslateY(float dy)                { Min.y += dy; Max.y += dy; }
    void        ClipWith(const ImRect& r)           { Min = ImMax(Min, r.Min); Max = ImMin(Max, r.Max); }                   // Simple version, may lead to an inverted rectangle, which is fine for Contains/Overlaps test but not for display.
    void        ClipWithFull(const ImRect& r)       { Min = ImClamp(Min, r.Min, r.Max); Max = ImClamp(Max, r.Min, r.Max); } // Full version, ensure both points are fully clipped.
    void        Floor()                             { Min.x = IM_FLOOR(Min.x); Min.y = IM_FLOOR(Min.y); Max.x = IM_FLOOR(Max.x); Max.y = IM_FLOOR(Max.y); }
    bool        IsInverted() const                  { return Min.x > Max.x || Min.y > Max.y; }
};

// Type information associated to one ImGuiDataType. Retrieve with DataTypeGetInfo().
struct ImGuiDataTypeInfo
{
    size_t      Size;           // Size in byte
    const char* PrintFmt;       // Default printf format for the type
    const char* ScanFmt;        // Default scanf format for the type
};

// Stacked color modifier, backup of modified data so we can restore it
struct ImGuiColorMod
{
    ImGuiCol    Col;
    ImVec4      BackupValue;
};

// Stacked style modifier, backup of modified data so we can restore it. Data type inferred from the variable.
struct ImGuiStyleMod
{
    ImGuiStyleVar   VarIdx;
    union           { int BackupInt[2]; float BackupFloat[2]; };
    ImGuiStyleMod(ImGuiStyleVar idx, int v)     { VarIdx = idx; BackupInt[0] = v; }
    ImGuiStyleMod(ImGuiStyleVar idx, float v)   { VarIdx = idx; BackupFloat[0] = v; }
    ImGuiStyleMod(ImGuiStyleVar idx, ImVec2 v)  { VarIdx = idx; BackupFloat[0] = v.x; BackupFloat[1] = v.y; }
};

// Stacked storage data for BeginGroup()/EndGroup()
struct ImGuiGroupData
{
    ImVec2      BackupCursorPos;
    ImVec2      BackupCursorMaxPos;
    ImVec1      BackupIndent;
    ImVec1      BackupGroupOffset;
    ImVec2      BackupCurrLineSize;
    float       BackupCurrLineTextBaseOffset;
    ImGuiID     BackupActiveIdIsAlive;
    bool        BackupActiveIdPreviousFrameIsAlive;
    bool        EmitItem;
};

// Simple column measurement, currently used for MenuItem() only.. This is very short-sighted/throw-away code and NOT a generic helper.
struct IMGUI_API ImGuiMenuColumns
{
    float       Spacing;
    float       Width, NextWidth;
    float       Pos[3], NextWidths[3];

    ImGuiMenuColumns();
    void        Update(int count, float spacing, bool clear);
    float       DeclColumns(float w0, float w1, float w2);
    float       CalcExtraSpace(float avail_w) const;
};

// Internal state of the currently focused/edited text input box
struct IMGUI_API ImGuiInputTextState
{
    ImGuiID                 ID;                     // widget id owning the text state
    int                     CurLenW, CurLenA;       // we need to maintain our buffer length in both UTF-8 and wchar format. UTF-8 len is valid even if TextA is not.
    ImVector<ImWchar>       TextW;                  // edit buffer, we need to persist but can't guarantee the persistence of the user-provided buffer. so we copy into own buffer.
    ImVector<char>          TextA;                  // temporary UTF8 buffer for callbacks and other operations. this is not updated in every code-path! size=capacity.
    ImVector<char>          InitialTextA;           // backup of end-user buffer at the time of focus (in UTF-8, unaltered)
    bool                    TextAIsValid;           // temporary UTF8 buffer is not initially valid before we make the widget active (until then we pull the data from user argument)
    int                     BufCapacityA;           // end-user buffer capacity
    float                   ScrollX;                // horizontal scrolling/offset
    ImStb::STB_TexteditState Stb;                   // state for stb_textedit.h
    float                   CursorAnim;             // timer for cursor blink, reset on every user action so the cursor reappears immediately
    bool                    CursorFollow;           // set when we want scrolling to follow the current cursor position (not always!)
    bool                    SelectedAllMouseLock;   // after a double-click to select all, we ignore further mouse drags to update selection
    ImGuiInputTextFlags     UserFlags;              // Temporarily set while we call user's callback
    ImGuiInputTextCallback  UserCallback;           // "
    void*                   UserCallbackData;       // "

    ImGuiInputTextState()                   { memset(this, 0, sizeof(*this)); }
    void        ClearText()                 { CurLenW = CurLenA = 0; TextW[0] = 0; TextA[0] = 0; CursorClamp(); }
    void        ClearFreeMemory()           { TextW.clear(); TextA.clear(); InitialTextA.clear(); }
    int         GetUndoAvailCount() const   { return Stb.undostate.undo_point; }
    int         GetRedoAvailCount() const   { return STB_TEXTEDIT_UNDOSTATECOUNT - Stb.undostate.redo_point; }
    void        OnKeyPressed(int key);      // Cannot be inline because we call in code in stb_textedit.h implementation

    // Cursor & Selection
    void        CursorAnimReset()           { CursorAnim = -0.30f; }                                   // After a user-input the cursor stays on for a while without blinking
    void        CursorClamp()               { Stb.cursor = ImMin(Stb.cursor, CurLenW); Stb.select_start = ImMin(Stb.select_start, CurLenW); Stb.select_end = ImMin(Stb.select_end, CurLenW); }
    bool        HasSelection() const        { return Stb.select_start != Stb.select_end; }
    void        ClearSelection()            { Stb.select_start = Stb.select_end = Stb.cursor; }
    void        SelectAll()                 { Stb.select_start = 0; Stb.cursor = Stb.select_end = CurLenW; Stb.has_preferred_x = 0; }
};

// Windows data saved in imgui.ini file
// Because we never destroy or rename ImGuiWindowSettings, we can store the names in a separate buffer easily.
// (this is designed to be stored in a ImChunkStream buffer, with the variable-length Name following our structure)
struct ImGuiWindowSettings
{
    ImGuiID     ID;
    ImVec2ih    Pos;
    ImVec2ih    Size;
    bool        Collapsed;

    ImGuiWindowSettings()       { ID = 0; Pos = Size = ImVec2ih(0, 0); Collapsed = false; }
    char* GetName()             { return (char*)(this + 1); }
};

struct ImGuiSettingsHandler
{
    const char* TypeName;       // Short description stored in .ini file. Disallowed characters: '[' ']'
    ImGuiID     TypeHash;       // == ImHashStr(TypeName)
    void*       (*ReadOpenFn)(ImGuiContext* ctx, ImGuiSettingsHandler* handler, const char* name);              // Read: Called when entering into a new ini entry e.g. "[Window][Name]"
    void        (*ReadLineFn)(ImGuiContext* ctx, ImGuiSettingsHandler* handler, void* entry, const char* line); // Read: Called for every line of text within an ini entry
    void        (*WriteAllFn)(ImGuiContext* ctx, ImGuiSettingsHandler* handler, ImGuiTextBuffer* out_buf);      // Write: Output every entries into 'out_buf'
    void*       UserData;

    ImGuiSettingsHandler() { memset(this, 0, sizeof(*this)); }
};

// Storage for current popup stack
struct ImGuiPopupData
{
    ImGuiID             PopupId;        // Set on OpenPopup()
    ImGuiWindow*        Window;         // Resolved on BeginPopup() - may stay unresolved if user never calls OpenPopup()
    ImGuiWindow*        SourceWindow;   // Set on OpenPopup() copy of NavWindow at the time of opening the popup
    int                 OpenFrameCount; // Set on OpenPopup()
    ImGuiID             OpenParentId;   // Set on OpenPopup(), we need this to differentiate multiple menu sets from each others (e.g. inside menu bar vs loose menu items)
    ImVec2              OpenPopupPos;   // Set on OpenPopup(), preferred popup position (typically == OpenMousePos when using mouse)
    ImVec2              OpenMousePos;   // Set on OpenPopup(), copy of mouse position at the time of opening popup

    ImGuiPopupData() { PopupId = 0; Window = SourceWindow = NULL; OpenFrameCount = -1; OpenParentId = 0; }
};

struct ImGuiColumnData
{
    float               OffsetNorm;         // Column start offset, normalized 0.0 (far left) -> 1.0 (far right)
    float               OffsetNormBeforeResize;
    ImGuiColumnsFlags   Flags;              // Not exposed
    ImRect              ClipRect;

    ImGuiColumnData()   { OffsetNorm = OffsetNormBeforeResize = 0.0f; Flags = ImGuiColumnsFlags_None; }
};

struct ImGuiColumns
{
    ImGuiID             ID;
    ImGuiColumnsFlags   Flags;
    bool                IsFirstFrame;
    bool                IsBeingResized;
    int                 Current;
    int                 Count;
    float               OffMinX, OffMaxX;       // Offsets from HostWorkRect.Min.x
    float               LineMinY, LineMaxY;
    float               HostCursorPosY;         // Backup of CursorPos at the time of BeginColumns()
    float               HostCursorMaxPosX;      // Backup of CursorMaxPos at the time of BeginColumns()
    ImRect              HostClipRect;           // Backup of ClipRect at the time of BeginColumns()
    ImRect              HostWorkRect;           // Backup of WorkRect at the time of BeginColumns()
    ImVector<ImGuiColumnData> Columns;

    ImGuiColumns()      { Clear(); }
    void Clear()
    {
        ID = 0;
        Flags = ImGuiColumnsFlags_None;
        IsFirstFrame = false;
        IsBeingResized = false;
        Current = 0;
        Count = 1;
        OffMinX = OffMaxX = 0.0f;
        LineMinY = LineMaxY = 0.0f;
        HostCursorPosY = 0.0f;
        HostCursorMaxPosX = 0.0f;
        Columns.clear();
    }
};

// Data shared between all ImDrawList instances
struct IMGUI_API ImDrawListSharedData
{
    ImVec2          TexUvWhitePixel;            // UV of white pixel in the atlas
    ImFont*         Font;                       // Current/default font (optional, for simplified AddText overload)
    float           FontSize;                   // Current/default font size (optional, for simplified AddText overload)
    float           CurveTessellationTol;       // Tessellation tolerance when using PathBezierCurveTo()
    ImVec4          ClipRectFullscreen;         // Value for PushClipRectFullscreen()
    ImDrawListFlags InitialFlags;               // Initial flags at the beginning of the frame (it is possible to alter flags on a per-drawlist basis afterwards)

    // Const data
    // FIXME: Bake rounded corners fill/borders in atlas
    ImVec2          CircleVtx12[12];

    ImDrawListSharedData();
};

struct ImDrawDataBuilder
{
    ImVector<ImDrawList*>   Layers[2];           // Global layers for: regular, tooltip

    void Clear()            { for (int n = 0; n < IM_ARRAYSIZE(Layers); n++) Layers[n].resize(0); }
    void ClearFreeMemory()  { for (int n = 0; n < IM_ARRAYSIZE(Layers); n++) Layers[n].clear(); }
    IMGUI_API void FlattenIntoSingleLayer();
};

struct ImGuiNavMoveResult
{
    ImGuiID       ID;           // Best candidate
    ImGuiID       SelectScopeId;// Best candidate window current selectable group ID
    ImGuiWindow*  Window;       // Best candidate window
    float         DistBox;      // Best candidate box distance to current NavId
    float         DistCenter;   // Best candidate center distance to current NavId
    float         DistAxial;
    ImRect        RectRel;      // Best candidate bounding box in window relative space

    ImGuiNavMoveResult() { Clear(); }
    void Clear()         { ID = SelectScopeId = 0; Window = NULL; DistBox = DistCenter = DistAxial = FLT_MAX; RectRel = ImRect(); }
};

enum ImGuiNextWindowDataFlags_
{
    ImGuiNextWindowDataFlags_None               = 0,
    ImGuiNextWindowDataFlags_HasPos             = 1 << 0,
    ImGuiNextWindowDataFlags_HasSize            = 1 << 1,
    ImGuiNextWindowDataFlags_HasContentSize     = 1 << 2,
    ImGuiNextWindowDataFlags_HasCollapsed       = 1 << 3,
    ImGuiNextWindowDataFlags_HasSizeConstraint  = 1 << 4,
    ImGuiNextWindowDataFlags_HasFocus           = 1 << 5,
    ImGuiNextWindowDataFlags_HasBgAlpha         = 1 << 6
};

// Storage for SetNexWindow** functions
struct ImGuiNextWindowData
{
    ImGuiNextWindowDataFlags    Flags;
    ImGuiCond                   PosCond;
    ImGuiCond                   SizeCond;
    ImGuiCond                   CollapsedCond;
    ImVec2                      PosVal;
    ImVec2                      PosPivotVal;
    ImVec2                      SizeVal;
    ImVec2                      ContentSizeVal;
    bool                        CollapsedVal;
    ImRect                      SizeConstraintRect;
    ImGuiSizeCallback           SizeCallback;
    void*                       SizeCallbackUserData;
    float                       BgAlphaVal;
    ImVec2                      MenuBarOffsetMinVal;    // *Always on* This is not exposed publicly, so we don't clear it.

    ImGuiNextWindowData()       { memset(this, 0, sizeof(*this)); }
    inline void ClearFlags()    { Flags = ImGuiNextWindowDataFlags_None; }
};

enum ImGuiNextItemDataFlags_
{
    ImGuiNextItemDataFlags_None     = 0,
    ImGuiNextItemDataFlags_HasWidth = 1 << 0,
    ImGuiNextItemDataFlags_HasOpen  = 1 << 1
};

struct ImGuiNextItemData
{
    ImGuiNextItemDataFlags      Flags;
    float                       Width;          // Set by SetNextItemWidth().
    bool                        OpenVal;        // Set by SetNextItemOpen() function.
    ImGuiCond                   OpenCond;

    ImGuiNextItemData()         { memset(this, 0, sizeof(*this)); }
    inline void ClearFlags()    { Flags = ImGuiNextItemDataFlags_None; }
};

//-----------------------------------------------------------------------------
// Tabs
//-----------------------------------------------------------------------------

struct ImGuiShrinkWidthItem
{
    int             Index;
    float           Width;
};

struct ImGuiPtrOrIndex
{
    void*           Ptr;                // Either field can be set, not both. e.g. Dock node tab bars are loose while BeginTabBar() ones are in a pool.
    int             Index;              // Usually index in a main pool.

    ImGuiPtrOrIndex(void* ptr)          { Ptr = ptr; Index = -1; }
    ImGuiPtrOrIndex(int index)          { Ptr = NULL; Index = index; }
};

//-----------------------------------------------------------------------------
// Main imgui context
//-----------------------------------------------------------------------------

struct ImGuiContext
{
    bool                    Initialized;
    bool                    FontAtlasOwnedByContext;            // IO.Fonts-> is owned by the ImGuiContext and will be destructed along with it.
    ImGuiIO                 IO;
    ImGuiStyle              Style;
    ImFont*                 Font;                               // (Shortcut) == FontStack.empty() ? IO.Font : FontStack.back()
    float                   FontSize;                           // (Shortcut) == FontBaseSize * g.CurrentWindow->FontWindowScale == window->FontSize(). Text height for current window.
    float                   FontBaseSize;                       // (Shortcut) == IO.FontGlobalScale * Font->Scale * Font->FontSize. Base text height.
    ImDrawListSharedData    DrawListSharedData;
    double                  Time;
    int                     FrameCount;
    int                     FrameCountEnded;
    int                     FrameCountRendered;
    bool                    WithinFrameScope;                   // Set by NewFrame(), cleared by EndFrame()
    bool                    WithinFrameScopeWithImplicitWindow; // Set by NewFrame(), cleared by EndFrame() when the implicit debug window has been pushed
    bool                    WithinEndChild;                     // Set within EndChild()

    // Windows state
    ImVector<ImGuiWindow*>  Windows;                            // Windows, sorted in display order, back to front
    ImVector<ImGuiWindow*>  WindowsFocusOrder;                  // Windows, sorted in focus order, back to front
    ImVector<ImGuiWindow*>  WindowsSortBuffer;
    ImVector<ImGuiWindow*>  CurrentWindowStack;
    ImGuiStorage            WindowsById;                        // Map window's ImGuiID to ImGuiWindow*
    int                     WindowsActiveCount;                 // Number of unique windows submitted by frame
    ImGuiWindow*            CurrentWindow;                      // Window being drawn into
    ImGuiWindow*            HoveredWindow;                      // Will catch mouse inputs
    ImGuiWindow*            HoveredRootWindow;                  // Will catch mouse inputs (for focus/move only)
    ImGuiWindow*            MovingWindow;                       // Track the window we clicked on (in order to preserve focus). The actually window that is moved is generally MovingWindow->RootWindow.
    ImGuiWindow*            WheelingWindow;                     // Track the window we started mouse-wheeling on. Until a timer elapse or mouse has moved, generally keep scrolling the same window even if during the course of scrolling the mouse ends up hovering a child window.
    ImVec2                  WheelingWindowRefMousePos;
    float                   WheelingWindowTimer;

    // Item/widgets state and tracking information
    ImGuiID                 HoveredId;                          // Hovered widget
    bool                    HoveredIdAllowOverlap;
    ImGuiID                 HoveredIdPreviousFrame;
    float                   HoveredIdTimer;                     // Measure contiguous hovering time
    float                   HoveredIdNotActiveTimer;            // Measure contiguous hovering time where the item has not been active
    ImGuiID                 ActiveId;                           // Active widget
    ImGuiID                 ActiveIdIsAlive;                    // Active widget has been seen this frame (we can't use a bool as the ActiveId may change within the frame)
    float                   ActiveIdTimer;
    bool                    ActiveIdIsJustActivated;            // Set at the time of activation for one frame
    bool                    ActiveIdAllowOverlap;               // Active widget allows another widget to steal active id (generally for overlapping widgets, but not always)
    bool                    ActiveIdHasBeenPressedBefore;       // Track whether the active id led to a press (this is to allow changing between PressOnClick and PressOnRelease without pressing twice). Used by range_select branch.
    bool                    ActiveIdHasBeenEditedBefore;        // Was the value associated to the widget Edited over the course of the Active state.
    bool                    ActiveIdHasBeenEditedThisFrame;
    ImU32                   ActiveIdUsingNavDirMask;            // Active widget will want to read those directional navigation requests (e.g. can activate a button and move away from it)
    ImU32                   ActiveIdUsingNavInputMask;          // Active widget will want to read those nav inputs.
    ImU64                   ActiveIdUsingKeyInputMask;          // Active widget will want to read those key inputs. When we grow the ImGuiKey enum we'll need to either to order the enum to make useful keys come first, either redesign this into e.g. a small array.
    ImVec2                  ActiveIdClickOffset;                // Clicked offset from upper-left corner, if applicable (currently only set by ButtonBehavior)
    ImGuiWindow*            ActiveIdWindow;
    ImGuiInputSource        ActiveIdSource;                     // Activating with mouse or nav (gamepad/keyboard)
    ImGuiID                 ActiveIdPreviousFrame;
    bool                    ActiveIdPreviousFrameIsAlive;
    bool                    ActiveIdPreviousFrameHasBeenEditedBefore;
    ImGuiWindow*            ActiveIdPreviousFrameWindow;
    ImGuiID                 LastActiveId;                       // Store the last non-zero ActiveId, useful for animation.
    float                   LastActiveIdTimer;                  // Store the last non-zero ActiveId timer since the beginning of activation, useful for animation.

    // Next window/item data
    ImGuiNextWindowData     NextWindowData;                     // Storage for SetNextWindow** functions
    ImGuiNextItemData       NextItemData;                       // Storage for SetNextItem** functions

    // Shared stacks
    ImVector<ImGuiColorMod> ColorModifiers;                     // Stack for PushStyleColor()/PopStyleColor()
    ImVector<ImGuiStyleMod> StyleModifiers;                     // Stack for PushStyleVar()/PopStyleVar()
    ImVector<ImFont*>       FontStack;                          // Stack for PushFont()/PopFont()
    ImVector<ImGuiPopupData>OpenPopupStack;                     // Which popups are open (persistent)
    ImVector<ImGuiPopupData>BeginPopupStack;                    // Which level of BeginPopup() we are in (reset every frame)

    // Navigation data (for gamepad/keyboard)
    ImGuiWindow*            NavWindow;                          // Focused window for navigation. Could be called 'FocusWindow'
    ImGuiID                 NavId;                              // Focused item for navigation
    ImGuiID                 NavActivateId;                      // ~~ (g.ActiveId == 0) && IsNavInputPressed(ImGuiNavInput_Activate) ? NavId : 0, also set when calling ActivateItem()
    ImGuiID                 NavActivateDownId;                  // ~~ IsNavInputDown(ImGuiNavInput_Activate) ? NavId : 0
    ImGuiID                 NavActivatePressedId;               // ~~ IsNavInputPressed(ImGuiNavInput_Activate) ? NavId : 0
    ImGuiID                 NavInputId;                         // ~~ IsNavInputPressed(ImGuiNavInput_Input) ? NavId : 0
    ImGuiID                 NavJustTabbedId;                    // Just tabbed to this id.
    ImGuiID                 NavJustMovedToId;                   // Just navigated to this id (result of a successfully MoveRequest).
    ImGuiID                 NavJustMovedToMultiSelectScopeId;   // Just navigated to this select scope id (result of a successfully MoveRequest).
    ImGuiID                 NavNextActivateId;                  // Set by ActivateItem(), queued until next frame.
    ImGuiInputSource        NavInputSource;                     // Keyboard or Gamepad mode? THIS WILL ONLY BE None or NavGamepad or NavKeyboard.
    ImRect                  NavScoringRectScreen;               // Rectangle used for scoring, in screen space. Based of window->DC.NavRefRectRel[], modified for directional navigation scoring.
    int                     NavScoringCount;                    // Metrics for debugging
    ImGuiWindow*            NavWindowingTarget;                 // When selecting a window (holding Menu+FocusPrev/Next, or equivalent of CTRL-TAB) this window is temporarily displayed top-most.
    ImGuiWindow*            NavWindowingTargetAnim;             // Record of last valid NavWindowingTarget until DimBgRatio and NavWindowingHighlightAlpha becomes 0.0f
    ImGuiWindow*            NavWindowingList;
    float                   NavWindowingTimer;
    float                   NavWindowingHighlightAlpha;
    bool                    NavWindowingToggleLayer;
    ImGuiNavLayer           NavLayer;                           // Layer we are navigating on. For now the system is hard-coded for 0=main contents and 1=menu/title bar, may expose layers later.
    int                     NavIdTabCounter;                    // == NavWindow->DC.FocusIdxTabCounter at time of NavId processing
    bool                    NavIdIsAlive;                       // Nav widget has been seen this frame ~~ NavRefRectRel is valid
    bool                    NavMousePosDirty;                   // When set we will update mouse position if (io.ConfigFlags & ImGuiConfigFlags_NavEnableSetMousePos) if set (NB: this not enabled by default)
    bool                    NavDisableHighlight;                // When user starts using mouse, we hide gamepad/keyboard highlight (NB: but they are still available, which is why NavDisableHighlight isn't always != NavDisableMouseHover)
    bool                    NavDisableMouseHover;               // When user starts using gamepad/keyboard, we hide mouse hovering highlight until mouse is touched again.
    bool                    NavAnyRequest;                      // ~~ NavMoveRequest || NavInitRequest
    bool                    NavInitRequest;                     // Init request for appearing window to select first item
    bool                    NavInitRequestFromMove;
    ImGuiID                 NavInitResultId;
    ImRect                  NavInitResultRectRel;
    bool                    NavMoveFromClampedRefRect;          // Set by manual scrolling, if we scroll to a point where NavId isn't visible we reset navigation from visible items
    bool                    NavMoveRequest;                     // Move request for this frame
    ImGuiNavMoveFlags       NavMoveRequestFlags;
    ImGuiNavForward         NavMoveRequestForward;              // None / ForwardQueued / ForwardActive (this is used to navigate sibling parent menus from a child menu)
    ImGuiDir                NavMoveDir, NavMoveDirLast;         // Direction of the move request (left/right/up/down), direction of the previous move request
    ImGuiDir                NavMoveClipDir;                     // FIXME-NAV: Describe the purpose of this better. Might want to rename?
    ImGuiNavMoveResult      NavMoveResultLocal;                 // Best move request candidate within NavWindow
    ImGuiNavMoveResult      NavMoveResultLocalVisibleSet;       // Best move request candidate within NavWindow that are mostly visible (when using ImGuiNavMoveFlags_AlsoScoreVisibleSet flag)
    ImGuiNavMoveResult      NavMoveResultOther;                 // Best move request candidate within NavWindow's flattened hierarchy (when using ImGuiWindowFlags_NavFlattened flag)

    // Tabbing system (older than Nav, active even if Nav is disabled. FIXME-NAV: This needs a redesign!)
    ImGuiWindow*            FocusRequestCurrWindow;             //
    ImGuiWindow*            FocusRequestNextWindow;             //
    int                     FocusRequestCurrCounterAll;         // Any item being requested for focus, stored as an index (we on layout to be stable between the frame pressing TAB and the next frame, semi-ouch)
    int                     FocusRequestCurrCounterTab;         // Tab item being requested for focus, stored as an index
    int                     FocusRequestNextCounterAll;         // Stored for next frame
    int                     FocusRequestNextCounterTab;         // "
    bool                    FocusTabPressed;                    //

    // Render
    ImDrawData              DrawData;                           // Main ImDrawData instance to pass render information to the user
    ImDrawDataBuilder       DrawDataBuilder;
    float                   DimBgRatio;                         // 0.0..1.0 animation when fading in a dimming background (for modal window and CTRL+TAB list)
    ImDrawList              BackgroundDrawList;                 // First draw list to be rendered.
    ImDrawList              ForegroundDrawList;                 // Last draw list to be rendered. This is where we the render software mouse cursor (if io.MouseDrawCursor is set) and most debug overlays.
    ImGuiMouseCursor        MouseCursor;

    // Drag and Drop
    bool                    DragDropActive;
    bool                    DragDropWithinSourceOrTarget;
    ImGuiDragDropFlags      DragDropSourceFlags;
    int                     DragDropSourceFrameCount;
    int                     DragDropMouseButton;
    ImGuiPayload            DragDropPayload;
    ImRect                  DragDropTargetRect;
    ImGuiID                 DragDropTargetId;
    ImGuiDragDropFlags      DragDropAcceptFlags;
    float                   DragDropAcceptIdCurrRectSurface;    // Target item surface (we resolve overlapping targets by prioritizing the smaller surface)
    ImGuiID                 DragDropAcceptIdCurr;               // Target item id (set at the time of accepting the payload)
    ImGuiID                 DragDropAcceptIdPrev;               // Target item id from previous frame (we need to store this to allow for overlapping drag and drop targets)
    int                     DragDropAcceptFrameCount;           // Last time a target expressed a desire to accept the source
    ImVector<unsigned char> DragDropPayloadBufHeap;             // We don't expose the ImVector<> directly
    unsigned char           DragDropPayloadBufLocal[16];        // Local buffer for small payloads

    // Tab bars
    ImGuiTabBar*                    CurrentTabBar;
    ImPool<ImGuiTabBar>             TabBars;
    ImVector<ImGuiPtrOrIndex>       CurrentTabBarStack;
    ImVector<ImGuiShrinkWidthItem>  ShrinkWidthBuffer;

    // Widget state
    ImVec2                  LastValidMousePos;
    ImGuiInputTextState     InputTextState;
    ImFont                  InputTextPasswordFont;
    ImGuiID                 TempInputTextId;                    // Temporary text input when CTRL+clicking on a slider, etc.
    ImGuiColorEditFlags     ColorEditOptions;                   // Store user options for color edit widgets
    float                   ColorEditLastHue;                   // Backup of last Hue associated to LastColor[3], so we can restore Hue in lossy RGB<>HSV round trips
    float                   ColorEditLastColor[3];
    ImVec4                  ColorPickerRef;                     // Initial/reference color at the time of opening the color picker.
    bool                    DragCurrentAccumDirty;
    float                   DragCurrentAccum;                   // Accumulator for dragging modification. Always high-precision, not rounded by end-user precision settings
    float                   DragSpeedDefaultRatio;              // If speed == 0.0f, uses (max-min) * DragSpeedDefaultRatio
    float                   ScrollbarClickDeltaToGrabCenter;    // Distance between mouse and center of grab box, normalized in parent space. Use storage?
    int                     TooltipOverrideCount;
    ImVector<char>          PrivateClipboard;                   // If no custom clipboard handler is defined

    // Range-Select/Multi-Select
    // [This is unused in this branch, but left here to facilitate merging/syncing multiple branches]
    ImGuiID                 MultiSelectScopeId;

    // Platform support
    ImVec2                  PlatformImePos;                     // Cursor position request & last passed to the OS Input Method Editor
    ImVec2                  PlatformImeLastPos;

    // Settings
    bool                    SettingsLoaded;
    float                   SettingsDirtyTimer;                 // Save .ini Settings to memory when time reaches zero
    ImGuiTextBuffer         SettingsIniData;                    // In memory .ini settings
    ImVector<ImGuiSettingsHandler>      SettingsHandlers;       // List of .ini settings handlers
    ImChunkStream<ImGuiWindowSettings>  SettingsWindows;        // ImGuiWindow .ini settings entries

    // Capture/Logging
    bool                    LogEnabled;
    ImGuiLogType            LogType;
    ImFileHandle            LogFile;                            // If != NULL log to stdout/ file
    ImGuiTextBuffer         LogBuffer;                          // Accumulation buffer when log to clipboard. This is pointer so our GImGui static constructor doesn't call heap allocators.
    float                   LogLinePosY;
    bool                    LogLineFirstItem;
    int                     LogDepthRef;
    int                     LogDepthToExpand;
    int                     LogDepthToExpandDefault;            // Default/stored value for LogDepthMaxExpand if not specified in the LogXXX function call.

    // Debug Tools
    bool                    DebugItemPickerActive;
    ImGuiID                 DebugItemPickerBreakID;             // Will call IM_DEBUG_BREAK() when encountering this id

    // Misc
    float                   FramerateSecPerFrame[120];          // Calculate estimate of framerate for user over the last 2 seconds.
    int                     FramerateSecPerFrameIdx;
    float                   FramerateSecPerFrameAccum;
    int                     WantCaptureMouseNextFrame;          // Explicit capture via CaptureKeyboardFromApp()/CaptureMouseFromApp() sets those flags
    int                     WantCaptureKeyboardNextFrame;
    int                     WantTextInputNextFrame;
    char                    TempBuffer[1024*3+1];               // Temporary text buffer

    ImGuiContext(ImFontAtlas* shared_font_atlas) : BackgroundDrawList(&DrawListSharedData), ForegroundDrawList(&DrawListSharedData)
    {
        Initialized = false;
        Font = NULL;
        FontSize = FontBaseSize = 0.0f;
        FontAtlasOwnedByContext = shared_font_atlas ? false : true;
        IO.Fonts = shared_font_atlas ? shared_font_atlas : IM_NEW(ImFontAtlas)();
        Time = 0.0f;
        FrameCount = 0;
        FrameCountEnded = FrameCountRendered = -1;
        WithinFrameScope = WithinFrameScopeWithImplicitWindow = WithinEndChild = false;

        WindowsActiveCount = 0;
        CurrentWindow = NULL;
        HoveredWindow = NULL;
        HoveredRootWindow = NULL;
        MovingWindow = NULL;
        WheelingWindow = NULL;
        WheelingWindowTimer = 0.0f;

        HoveredId = 0;
        HoveredIdAllowOverlap = false;
        HoveredIdPreviousFrame = 0;
        HoveredIdTimer = HoveredIdNotActiveTimer = 0.0f;
        ActiveId = 0;
        ActiveIdIsAlive = 0;
        ActiveIdTimer = 0.0f;
        ActiveIdIsJustActivated = false;
        ActiveIdAllowOverlap = false;
        ActiveIdHasBeenPressedBefore = false;
        ActiveIdHasBeenEditedBefore = false;
        ActiveIdHasBeenEditedThisFrame = false;
        ActiveIdUsingNavDirMask = 0x00;
        ActiveIdUsingNavInputMask = 0x00;
        ActiveIdUsingKeyInputMask = 0x00;
        ActiveIdClickOffset = ImVec2(-1,-1);
        ActiveIdWindow = NULL;
        ActiveIdSource = ImGuiInputSource_None;
        ActiveIdPreviousFrame = 0;
        ActiveIdPreviousFrameIsAlive = false;
        ActiveIdPreviousFrameHasBeenEditedBefore = false;
        ActiveIdPreviousFrameWindow = NULL;
        LastActiveId = 0;
        LastActiveIdTimer = 0.0f;

        NavWindow = NULL;
        NavId = NavActivateId = NavActivateDownId = NavActivatePressedId = NavInputId = 0;
        NavJustTabbedId = NavJustMovedToId = NavJustMovedToMultiSelectScopeId = NavNextActivateId = 0;
        NavInputSource = ImGuiInputSource_None;
        NavScoringRectScreen = ImRect();
        NavScoringCount = 0;
        NavWindowingTarget = NavWindowingTargetAnim = NavWindowingList = NULL;
        NavWindowingTimer = NavWindowingHighlightAlpha = 0.0f;
        NavWindowingToggleLayer = false;
        NavLayer = ImGuiNavLayer_Main;
        NavIdTabCounter = INT_MAX;
        NavIdIsAlive = false;
        NavMousePosDirty = false;
        NavDisableHighlight = true;
        NavDisableMouseHover = false;
        NavAnyRequest = false;
        NavInitRequest = false;
        NavInitRequestFromMove = false;
        NavInitResultId = 0;
        NavMoveFromClampedRefRect = false;
        NavMoveRequest = false;
        NavMoveRequestFlags = 0;
        NavMoveRequestForward = ImGuiNavForward_None;
        NavMoveDir = NavMoveDirLast = NavMoveClipDir = ImGuiDir_None;

        FocusRequestCurrWindow = FocusRequestNextWindow = NULL;
        FocusRequestCurrCounterAll = FocusRequestCurrCounterTab = INT_MAX;
        FocusRequestNextCounterAll = FocusRequestNextCounterTab = INT_MAX;
        FocusTabPressed = false;

        DimBgRatio = 0.0f;
        BackgroundDrawList._OwnerName = "##Background"; // Give it a name for debugging
        ForegroundDrawList._OwnerName = "##Foreground"; // Give it a name for debugging
        MouseCursor = ImGuiMouseCursor_Arrow;

        DragDropActive = DragDropWithinSourceOrTarget = false;
        DragDropSourceFlags = 0;
        DragDropSourceFrameCount = -1;
        DragDropMouseButton = -1;
        DragDropTargetId = 0;
        DragDropAcceptFlags = 0;
        DragDropAcceptIdCurrRectSurface = 0.0f;
        DragDropAcceptIdPrev = DragDropAcceptIdCurr = 0;
        DragDropAcceptFrameCount = -1;
        memset(DragDropPayloadBufLocal, 0, sizeof(DragDropPayloadBufLocal));

        CurrentTabBar = NULL;

        LastValidMousePos = ImVec2(0.0f, 0.0f);
        TempInputTextId = 0;
        ColorEditOptions = ImGuiColorEditFlags__OptionsDefault;
        ColorEditLastHue = 0.0f;
        ColorEditLastColor[0] = ColorEditLastColor[1] = ColorEditLastColor[2] = FLT_MAX;
        DragCurrentAccumDirty = false;
        DragCurrentAccum = 0.0f;
        DragSpeedDefaultRatio = 1.0f / 100.0f;
        ScrollbarClickDeltaToGrabCenter = 0.0f;
        TooltipOverrideCount = 0;

        MultiSelectScopeId = 0;

        PlatformImePos = PlatformImeLastPos = ImVec2(FLT_MAX, FLT_MAX);

        SettingsLoaded = false;
        SettingsDirtyTimer = 0.0f;

        LogEnabled = false;
        LogType = ImGuiLogType_None;
        LogFile = NULL;
        LogLinePosY = FLT_MAX;
        LogLineFirstItem = false;
        LogDepthRef = 0;
        LogDepthToExpand = LogDepthToExpandDefault = 2;

        DebugItemPickerActive = false;
        DebugItemPickerBreakID = 0;

        memset(FramerateSecPerFrame, 0, sizeof(FramerateSecPerFrame));
        FramerateSecPerFrameIdx = 0;
        FramerateSecPerFrameAccum = 0.0f;
        WantCaptureMouseNextFrame = WantCaptureKeyboardNextFrame = WantTextInputNextFrame = -1;
        memset(TempBuffer, 0, sizeof(TempBuffer));
    }
};

//-----------------------------------------------------------------------------
// ImGuiWindow
//-----------------------------------------------------------------------------

// Transient per-window data, reset at the beginning of the frame. This used to be called ImGuiDrawContext, hence the DC variable name in ImGuiWindow.
// FIXME: That's theory, in practice the delimitation between ImGuiWindow and ImGuiWindowTempData is quite tenuous and could be reconsidered.
struct IMGUI_API ImGuiWindowTempData
{
    ImVec2                  CursorPos;              // Current emitting position, in absolute coordinates.
    ImVec2                  CursorPosPrevLine;
    ImVec2                  CursorStartPos;         // Initial position after Begin(), generally ~ window position + WindowPadding.
    ImVec2                  CursorMaxPos;           // Used to implicitly calculate the size of our contents, always growing during the frame. Used to calculate window->ContentSize at the beginning of next frame
    ImVec2                  CurrLineSize;
    ImVec2                  PrevLineSize;
    float                   CurrLineTextBaseOffset; // Baseline offset (0.0f by default on a new line, generally == style.FramePadding.y when a framed item has been added).
    float                   PrevLineTextBaseOffset;
    int                     TreeDepth;                      // Current tree depth.
    ImU32                   TreeMayJumpToParentOnPopMask;   // Store a copy of !g.NavIdIsAlive for TreeDepth 0..31.. Could be turned into a ImU64 if necessary.
    ImGuiID                 LastItemId;             // ID for last item
    ImGuiItemStatusFlags    LastItemStatusFlags;    // Status flags for last item (see ImGuiItemStatusFlags_)
    ImRect                  LastItemRect;           // Interaction rect for last item
    ImRect                  LastItemDisplayRect;    // End-user display rect for last item (only valid if LastItemStatusFlags & ImGuiItemStatusFlags_HasDisplayRect)
    ImGuiNavLayer           NavLayerCurrent;        // Current layer, 0..31 (we currently only use 0..1)
    int                     NavLayerCurrentMask;    // = (1 << NavLayerCurrent) used by ItemAdd prior to clipping.
    int                     NavLayerActiveMask;     // Which layer have been written to (result from previous frame)
    int                     NavLayerActiveMaskNext; // Which layer have been written to (buffer for current frame)
    bool                    NavHideHighlightOneFrame;
    bool                    NavHasScroll;           // Set when scrolling can be used (ScrollMax > 0.0f)
    bool                    MenuBarAppending;       // FIXME: Remove this
    ImVec2                  MenuBarOffset;          // MenuBarOffset.x is sort of equivalent of a per-layer CursorPos.x, saved/restored as we switch to the menu bar. The only situation when MenuBarOffset.y is > 0 if when (SafeAreaPadding.y > FramePadding.y), often used on TVs.
    ImVector<ImGuiWindow*>  ChildWindows;
    ImGuiStorage*           StateStorage;           // Current persistent per-window storage (store e.g. tree node open/close state)
    ImGuiLayoutType         LayoutType;
    ImGuiLayoutType         ParentLayoutType;       // Layout type of parent window at the time of Begin()
    int                     FocusCounterAll;        // Counter for focus/tabbing system. Start at -1 and increase as assigned via FocusableItemRegister() (FIXME-NAV: Needs redesign)
    int                     FocusCounterTab;        // (same, but only count widgets which you can Tab through)

    // We store the current settings outside of the vectors to increase memory locality (reduce cache misses). The vectors are rarely modified. Also it allows us to not heap allocate for short-lived windows which are not using those settings.
    ImGuiItemFlags          ItemFlags;              // == ItemFlagsStack.back() [empty == ImGuiItemFlags_Default]
    float                   ItemWidth;              // == ItemWidthStack.back(). 0.0: default, >0.0: width in pixels, <0.0: align xx pixels to the right of window
    float                   TextWrapPos;            // == TextWrapPosStack.back() [empty == -1.0f]
    ImVector<ImGuiItemFlags>ItemFlagsStack;
    ImVector<float>         ItemWidthStack;
    ImVector<float>         TextWrapPosStack;
    ImVector<ImGuiGroupData>GroupStack;
    short                   StackSizesBackup[6];    // Store size of various stacks for asserting

    ImVec1                  Indent;                 // Indentation / start position from left of window (increased by TreePush/TreePop, etc.)
    ImVec1                  GroupOffset;
    ImVec1                  ColumnsOffset;          // Offset to the current column (if ColumnsCurrent > 0). FIXME: This and the above should be a stack to allow use cases like Tree->Column->Tree. Need revamp columns API.
    ImGuiColumns*           CurrentColumns;         // Current columns set

    ImGuiWindowTempData()
    {
        CursorPos = CursorPosPrevLine = CursorStartPos = CursorMaxPos = ImVec2(0.0f, 0.0f);
        CurrLineSize = PrevLineSize = ImVec2(0.0f, 0.0f);
        CurrLineTextBaseOffset = PrevLineTextBaseOffset = 0.0f;
        TreeDepth = 0;
        TreeMayJumpToParentOnPopMask = 0x00;
        LastItemId = 0;
        LastItemStatusFlags = 0;
        LastItemRect = LastItemDisplayRect = ImRect();
        NavLayerActiveMask = NavLayerActiveMaskNext = 0x00;
        NavLayerCurrent = ImGuiNavLayer_Main;
        NavLayerCurrentMask = (1 << ImGuiNavLayer_Main);
        NavHideHighlightOneFrame = false;
        NavHasScroll = false;
        MenuBarAppending = false;
        MenuBarOffset = ImVec2(0.0f, 0.0f);
        StateStorage = NULL;
        LayoutType = ParentLayoutType = ImGuiLayoutType_Vertical;
        FocusCounterAll = FocusCounterTab = -1;

        ItemFlags = ImGuiItemFlags_Default_;
        ItemWidth = 0.0f;
        TextWrapPos = -1.0f;
        memset(StackSizesBackup, 0, sizeof(StackSizesBackup));

        Indent = ImVec1(0.0f);
        GroupOffset = ImVec1(0.0f);
        ColumnsOffset = ImVec1(0.0f);
        CurrentColumns = NULL;
    }
};

// Storage for one window
struct IMGUI_API ImGuiWindow
{
    char*                   Name;
    ImGuiID                 ID;                                 // == ImHash(Name)
    ImGuiWindowFlags        Flags;                              // See enum ImGuiWindowFlags_
    ImVec2                  Pos;                                // Position (always rounded-up to nearest pixel)
    ImVec2                  Size;                               // Current size (==SizeFull or collapsed title bar size)
    ImVec2                  SizeFull;                           // Size when non collapsed
    ImVec2                  ContentSize;                        // Size of contents/scrollable client area (calculated from the extents reach of the cursor) from previous frame. Does not include window decoration or window padding.
    ImVec2                  ContentSizeExplicit;                // Size of contents/scrollable client area explicitly request by the user via SetNextWindowContentSize().
    ImVec2                  WindowPadding;                      // Window padding at the time of Begin().
    float                   WindowRounding;                     // Window rounding at the time of Begin().
    float                   WindowBorderSize;                   // Window border size at the time of Begin().
    int                     NameBufLen;                         // Size of buffer storing Name. May be larger than strlen(Name)!
    ImGuiID                 MoveId;                             // == window->GetID("#MOVE")
    ImGuiID                 ChildId;                            // ID of corresponding item in parent window (for navigation to return from child window to parent window)
    ImVec2                  Scroll;
    ImVec2                  ScrollMax;
    ImVec2                  ScrollTarget;                       // target scroll position. stored as cursor position with scrolling canceled out, so the highest point is always 0.0f. (FLT_MAX for no change)
    ImVec2                  ScrollTargetCenterRatio;            // 0.0f = scroll so that target position is at top, 0.5f = scroll so that target position is centered
    ImVec2                  ScrollbarSizes;                     // Size taken by scrollbars on each axis
    bool                    ScrollbarX, ScrollbarY;             // Are scrollbars visible?
    bool                    Active;                             // Set to true on Begin(), unless Collapsed
    bool                    WasActive;
    bool                    WriteAccessed;                      // Set to true when any widget access the current window
    bool                    Collapsed;                          // Set when collapsing window to become only title-bar
    bool                    WantCollapseToggle;
    bool                    SkipItems;                          // Set when items can safely be all clipped (e.g. window not visible or collapsed)
    bool                    Appearing;                          // Set during the frame where the window is appearing (or re-appearing)
    bool                    Hidden;                             // Do not display (== (HiddenFrames*** > 0))
    bool                    HasCloseButton;                     // Set when the window has a close button (p_open != NULL)
    signed char             ResizeBorderHeld;                   // Current border being held for resize (-1: none, otherwise 0-3)
    short                   BeginCount;                         // Number of Begin() during the current frame (generally 0 or 1, 1+ if appending via multiple Begin/End pairs)
    short                   BeginOrderWithinParent;             // Order within immediate parent window, if we are a child window. Otherwise 0.
    short                   BeginOrderWithinContext;            // Order within entire imgui context. This is mostly used for debugging submission order related issues.
    ImGuiID                 PopupId;                            // ID in the popup stack when this window is used as a popup/menu (because we use generic Name/ID for recycling)
    ImS8                    AutoFitFramesX, AutoFitFramesY;
    ImS8                    AutoFitChildAxises;
    bool                    AutoFitOnlyGrows;
    ImGuiDir                AutoPosLastDirection;
    int                     HiddenFramesCanSkipItems;           // Hide the window for N frames
    int                     HiddenFramesCannotSkipItems;        // Hide the window for N frames while allowing items to be submitted so we can measure their size
    ImGuiCond               SetWindowPosAllowFlags;             // store acceptable condition flags for SetNextWindowPos() use.
    ImGuiCond               SetWindowSizeAllowFlags;            // store acceptable condition flags for SetNextWindowSize() use.
    ImGuiCond               SetWindowCollapsedAllowFlags;       // store acceptable condition flags for SetNextWindowCollapsed() use.
    ImVec2                  SetWindowPosVal;                    // store window position when using a non-zero Pivot (position set needs to be processed when we know the window size)
    ImVec2                  SetWindowPosPivot;                  // store window pivot for positioning. ImVec2(0,0) when positioning from top-left corner; ImVec2(0.5f,0.5f) for centering; ImVec2(1,1) for bottom right.

    ImVector<ImGuiID>       IDStack;                            // ID stack. ID are hashes seeded with the value at the top of the stack. (In theory this should be in the TempData structure)
    ImGuiWindowTempData     DC;                                 // Temporary per-window data, reset at the beginning of the frame. This used to be called ImGuiDrawContext, hence the "DC" variable name.

    // The best way to understand what those rectangles are is to use the 'Metrics -> Tools -> Show windows rectangles' viewer.
    // The main 'OuterRect', omitted as a field, is window->Rect().
    ImRect                  OuterRectClipped;                   // == Window->Rect() just after setup in Begin(). == window->Rect() for root window.
    ImRect                  InnerRect;                          // Inner rectangle (omit title bar, menu bar, scroll bar)
    ImRect                  InnerClipRect;                      // == InnerRect shrunk by WindowPadding*0.5f on each side, clipped within viewport or parent clip rect.
    ImRect                  WorkRect;                           // Cover the whole scrolling region, shrunk by WindowPadding*1.0f on each side. This is meant to replace ContentRegionRect over time (from 1.71+ onward).
    ImRect                  ClipRect;                           // Current clipping/scissoring rectangle, evolve as we are using PushClipRect(), etc. == DrawList->clip_rect_stack.back().
    ImRect                  ContentRegionRect;                  // FIXME: This is currently confusing/misleading. It is essentially WorkRect but not handling of scrolling. We currently rely on it as right/bottom aligned sizing operation need some size to rely on.

    int                     LastFrameActive;                    // Last frame number the window was Active.
    float                   LastTimeActive;                     // Last timestamp the window was Active (using float as we don't need high precision there)
    float                   ItemWidthDefault;
    ImGuiMenuColumns        MenuColumns;                        // Simplified columns storage for menu items
    ImGuiStorage            StateStorage;
    ImVector<ImGuiColumns>  ColumnsStorage;
    float                   FontWindowScale;                    // User scale multiplier per-window, via SetWindowFontScale()
    int                     SettingsOffset;                     // Offset into SettingsWindows[] (offsets are always valid as we only grow the array from the back)

    ImDrawList*             DrawList;                           // == &DrawListInst (for backward compatibility reason with code using imgui_internal.h we keep this a pointer)
    ImDrawList              DrawListInst;
    ImGuiWindow*            ParentWindow;                       // If we are a child _or_ popup window, this is pointing to our parent. Otherwise NULL.
    ImGuiWindow*            RootWindow;                         // Point to ourself or first ancestor that is not a child window.
    ImGuiWindow*            RootWindowForTitleBarHighlight;     // Point to ourself or first ancestor which will display TitleBgActive color when this window is active.
    ImGuiWindow*            RootWindowForNav;                   // Point to ourself or first ancestor which doesn't have the NavFlattened flag.

    ImGuiWindow*            NavLastChildNavWindow;              // When going to the menu bar, we remember the child window we came from. (This could probably be made implicit if we kept g.Windows sorted by last focused including child window.)
    ImGuiID                 NavLastIds[ImGuiNavLayer_COUNT];    // Last known NavId for this window, per layer (0/1)
    ImRect                  NavRectRel[ImGuiNavLayer_COUNT];    // Reference rectangle, in window relative space

    bool                    MemoryCompacted;
    int                     MemoryDrawListIdxCapacity;
    int                     MemoryDrawListVtxCapacity;

public:
    ImGuiWindow(ImGuiContext* context, const char* name);
    ~ImGuiWindow();

    ImGuiID     GetID(const char* str, const char* str_end = NULL);
    ImGuiID     GetID(const void* ptr);
    ImGuiID     GetID(int n);
    ImGuiID     GetIDNoKeepAlive(const char* str, const char* str_end = NULL);
    ImGuiID     GetIDNoKeepAlive(const void* ptr);
    ImGuiID     GetIDNoKeepAlive(int n);
    ImGuiID     GetIDFromRectangle(const ImRect& r_abs);

    // We don't use g.FontSize because the window may be != g.CurrentWidow.
    ImRect      Rect() const                { return ImRect(Pos.x, Pos.y, Pos.x+Size.x, Pos.y+Size.y); }
    float       CalcFontSize() const        { ImGuiContext& g = *GImGui; float scale = g.FontBaseSize * FontWindowScale; if (ParentWindow) scale *= ParentWindow->FontWindowScale; return scale; }
    float       TitleBarHeight() const      { ImGuiContext& g = *GImGui; return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + g.Style.FramePadding.y * 2.0f; }
    ImRect      TitleBarRect() const        { return ImRect(Pos, ImVec2(Pos.x + SizeFull.x, Pos.y + TitleBarHeight())); }
    float       MenuBarHeight() const       { ImGuiContext& g = *GImGui; return (Flags & ImGuiWindowFlags_MenuBar) ? DC.MenuBarOffset.y + CalcFontSize() + g.Style.FramePadding.y * 2.0f : 0.0f; }
    ImRect      MenuBarRect() const         { float y1 = Pos.y + TitleBarHeight(); return ImRect(Pos.x, y1, Pos.x + SizeFull.x, y1 + MenuBarHeight()); }
};

// Backup and restore just enough data to be able to use IsItemHovered() on item A after another B in the same window has overwritten the data.
struct ImGuiItemHoveredDataBackup
{
    ImGuiID                 LastItemId;
    ImGuiItemStatusFlags    LastItemStatusFlags;
    ImRect                  LastItemRect;
    ImRect                  LastItemDisplayRect;

    ImGuiItemHoveredDataBackup() { Backup(); }
    void Backup()           { ImGuiWindow* window = GImGui->CurrentWindow; LastItemId = window->DC.LastItemId; LastItemStatusFlags = window->DC.LastItemStatusFlags; LastItemRect = window->DC.LastItemRect; LastItemDisplayRect = window->DC.LastItemDisplayRect; }
    void Restore() const    { ImGuiWindow* window = GImGui->CurrentWindow; window->DC.LastItemId = LastItemId; window->DC.LastItemStatusFlags = LastItemStatusFlags; window->DC.LastItemRect = LastItemRect; window->DC.LastItemDisplayRect = LastItemDisplayRect; }
};

//-----------------------------------------------------------------------------
// Tab bar, tab item
//-----------------------------------------------------------------------------

// Extend ImGuiTabBarFlags_
enum ImGuiTabBarFlagsPrivate_
{
    ImGuiTabBarFlags_DockNode                   = 1 << 20,  // Part of a dock node [we don't use this in the master branch but it facilitate branch syncing to keep this around]
    ImGuiTabBarFlags_IsFocused                  = 1 << 21,
    ImGuiTabBarFlags_SaveSettings               = 1 << 22   // FIXME: Settings are handled by the docking system, this only request the tab bar to mark settings dirty when reordering tabs
};

// Extend ImGuiTabItemFlags_
enum ImGuiTabItemFlagsPrivate_
{
    ImGuiTabItemFlags_NoCloseButton             = 1 << 20   // Track whether p_open was set or not (we'll need this info on the next frame to recompute ContentWidth during layout)
};

// Storage for one active tab item (sizeof() 26~32 bytes)
struct ImGuiTabItem
{
    ImGuiID             ID;
    ImGuiTabItemFlags   Flags;
    int                 LastFrameVisible;
    int                 LastFrameSelected;      // This allows us to infer an ordered list of the last activated tabs with little maintenance
    int                 NameOffset;             // When Window==NULL, offset to name within parent ImGuiTabBar::TabsNames
    float               Offset;                 // Position relative to beginning of tab
    float               Width;                  // Width currently displayed
    float               ContentWidth;           // Width of actual contents, stored during BeginTabItem() call

    ImGuiTabItem()      { ID = 0; Flags = 0; LastFrameVisible = LastFrameSelected = -1; NameOffset = -1; Offset = Width = ContentWidth = 0.0f; }
};

// Storage for a tab bar (sizeof() 92~96 bytes)
struct ImGuiTabBar
{
    ImVector<ImGuiTabItem> Tabs;
    ImGuiID             ID;                     // Zero for tab-bars used by docking
    ImGuiID             SelectedTabId;          // Selected tab
    ImGuiID             NextSelectedTabId;
    ImGuiID             VisibleTabId;           // Can occasionally be != SelectedTabId (e.g. when previewing contents for CTRL+TAB preview)
    int                 CurrFrameVisible;
    int                 PrevFrameVisible;
    ImRect              BarRect;
    float               LastTabContentHeight;   // Record the height of contents submitted below the tab bar
    float               OffsetMax;              // Distance from BarRect.Min.x, locked during layout
    float               OffsetMaxIdeal;         // Ideal offset if all tabs were visible and not clipped
    float               OffsetNextTab;          // Distance from BarRect.Min.x, incremented with each BeginTabItem() call, not used if ImGuiTabBarFlags_Reorderable if set.
    float               ScrollingAnim;
    float               ScrollingTarget;
    float               ScrollingTargetDistToVisibility;
    float               ScrollingSpeed;
    ImGuiTabBarFlags    Flags;
    ImGuiID             ReorderRequestTabId;
    ImS8                ReorderRequestDir;
    bool                WantLayout;
    bool                VisibleTabWasSubmitted;
    short               LastTabItemIdx;         // For BeginTabItem()/EndTabItem()
    ImVec2              FramePadding;           // style.FramePadding locked at the time of BeginTabBar()
    ImGuiTextBuffer     TabsNames;              // For non-docking tab bar we re-append names in a contiguous buffer.

    ImGuiTabBar();
    int                 GetTabOrder(const ImGuiTabItem* tab) const  { return Tabs.index_from_ptr(tab); }
    const char*         GetTabName(const ImGuiTabItem* tab) const
    {
        IM_ASSERT(tab->NameOffset != -1 && tab->NameOffset < TabsNames.Buf.Size);
        return TabsNames.Buf.Data + tab->NameOffset;
    }
};

//-----------------------------------------------------------------------------
// Internal API
// No guarantee of forward compatibility here.
//-----------------------------------------------------------------------------

namespace ImGui
{
    // We should always have a CurrentWindow in the stack (there is an implicit "Debug" window)
    // If this ever crash because g.CurrentWindow is NULL it means that either
    // - ImGui::NewFrame() has never been called, which is illegal.
    // - You are calling ImGui functions after ImGui::EndFrame()/ImGui::Render() and before the next ImGui::NewFrame(), which is also illegal.
    inline    ImGuiWindow*  GetCurrentWindowRead()      { ImGuiContext& g = *GImGui; return g.CurrentWindow; }
    inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }
    IMGUI_API ImGuiWindow*  FindWindowByID(ImGuiID id);
    IMGUI_API ImGuiWindow*  FindWindowByName(const char* name);
    IMGUI_API void          FocusWindow(ImGuiWindow* window);
    IMGUI_API void          FocusTopMostWindowUnderOne(ImGuiWindow* under_this_window, ImGuiWindow* ignore_window);
    IMGUI_API void          BringWindowToFocusFront(ImGuiWindow* window);
    IMGUI_API void          BringWindowToDisplayFront(ImGuiWindow* window);
    IMGUI_API void          BringWindowToDisplayBack(ImGuiWindow* window);
    IMGUI_API void          UpdateWindowParentAndRootLinks(ImGuiWindow* window, ImGuiWindowFlags flags, ImGuiWindow* parent_window);
    IMGUI_API ImVec2        CalcWindowExpectedSize(ImGuiWindow* window);
    IMGUI_API bool          IsWindowChildOf(ImGuiWindow* window, ImGuiWindow* potential_parent);
    IMGUI_API bool          IsWindowNavFocusable(ImGuiWindow* window);
    IMGUI_API ImRect        GetWindowAllowedExtentRect(ImGuiWindow* window);
    IMGUI_API void          SetWindowPos(ImGuiWindow* window, const ImVec2& pos, ImGuiCond cond = 0);
    IMGUI_API void          SetWindowSize(ImGuiWindow* window, const ImVec2& size, ImGuiCond cond = 0);
    IMGUI_API void          SetWindowCollapsed(ImGuiWindow* window, bool collapsed, ImGuiCond cond = 0);
    IMGUI_API void          GcCompactTransientWindowBuffers(ImGuiWindow* window);
    IMGUI_API void          GcAwakeTransientWindowBuffers(ImGuiWindow* window);

    IMGUI_API void          SetCurrentFont(ImFont* font);
    inline ImFont*          GetDefaultFont() { ImGuiContext& g = *GImGui; return g.IO.FontDefault ? g.IO.FontDefault : g.IO.Fonts->Fonts[0]; }
    inline ImDrawList*      GetForegroundDrawList(ImGuiWindow* window) { IM_UNUSED(window); ImGuiContext& g = *GImGui; return &g.ForegroundDrawList; } // This seemingly unnecessary wrapper simplifies compatibility between the 'master' and 'docking' branches.

    // Init
    IMGUI_API void          Initialize(ImGuiContext* context);
    IMGUI_API void          Shutdown(ImGuiContext* context);    // Since 1.60 this is a _private_ function. You can call DestroyContext() to destroy the context created by CreateContext().

    // NewFrame
    IMGUI_API void          UpdateHoveredWindowAndCaptureFlags();
    IMGUI_API void          StartMouseMovingWindow(ImGuiWindow* window);
    IMGUI_API void          UpdateMouseMovingWindowNewFrame();
    IMGUI_API void          UpdateMouseMovingWindowEndFrame();

    // Settings
    IMGUI_API void                  MarkIniSettingsDirty();
    IMGUI_API void                  MarkIniSettingsDirty(ImGuiWindow* window);
    IMGUI_API ImGuiWindowSettings*  CreateNewWindowSettings(const char* name);
    IMGUI_API ImGuiWindowSettings*  FindWindowSettings(ImGuiID id);
    IMGUI_API ImGuiWindowSettings*  FindOrCreateWindowSettings(const char* name);
    IMGUI_API ImGuiSettingsHandler* FindSettingsHandler(const char* type_name);

    // Scrolling
    IMGUI_API void          SetScrollX(ImGuiWindow* window, float new_scroll_x);
    IMGUI_API void          SetScrollY(ImGuiWindow* window, float new_scroll_y);
    IMGUI_API void          SetScrollFromPosX(ImGuiWindow* window, float local_x, float center_x_ratio = 0.5f);
    IMGUI_API void          SetScrollFromPosY(ImGuiWindow* window, float local_y, float center_y_ratio = 0.5f);
    IMGUI_API ImVec2        ScrollToBringRectIntoView(ImGuiWindow* window, const ImRect& item_rect);

    // Basic Accessors
    inline ImGuiID          GetItemID()     { ImGuiContext& g = *GImGui; return g.CurrentWindow->DC.LastItemId; }
    inline ImGuiID          GetActiveID()   { ImGuiContext& g = *GImGui; return g.ActiveId; }
    inline ImGuiID          GetFocusID()    { ImGuiContext& g = *GImGui; return g.NavId; }
    IMGUI_API void          SetActiveID(ImGuiID id, ImGuiWindow* window);
    IMGUI_API void          SetFocusID(ImGuiID id, ImGuiWindow* window);
    IMGUI_API void          ClearActiveID();
    IMGUI_API ImGuiID       GetHoveredID();
    IMGUI_API void          SetHoveredID(ImGuiID id);
    IMGUI_API void          KeepAliveID(ImGuiID id);
    IMGUI_API void          MarkItemEdited(ImGuiID id);
    IMGUI_API void          PushOverrideID(ImGuiID id);

    // Basic Helpers for widget code
    IMGUI_API void          ItemSize(const ImVec2& size, float text_baseline_y = -1.0f);
    IMGUI_API void          ItemSize(const ImRect& bb, float text_baseline_y = -1.0f);
    IMGUI_API bool          ItemAdd(const ImRect& bb, ImGuiID id, const ImRect* nav_bb = NULL);
    IMGUI_API bool          ItemHoverable(const ImRect& bb, ImGuiID id);
    IMGUI_API bool          IsClippedEx(const ImRect& bb, ImGuiID id, bool clip_even_when_logged);
    IMGUI_API bool          FocusableItemRegister(ImGuiWindow* window, ImGuiID id);   // Return true if focus is requested
    IMGUI_API void          FocusableItemUnregister(ImGuiWindow* window);
    IMGUI_API ImVec2        CalcItemSize(ImVec2 size, float default_w, float default_h);
    IMGUI_API float         CalcWrapWidthForPos(const ImVec2& pos, float wrap_pos_x);
    IMGUI_API void          PushMultiItemsWidths(int components, float width_full);
    IMGUI_API void          PushItemFlag(ImGuiItemFlags option, bool enabled);
    IMGUI_API void          PopItemFlag();
    IMGUI_API bool          IsItemToggledSelection();                           // Was the last item selection toggled? (after Selectable(), TreeNode() etc. We only returns toggle _event_ in order to handle clipping correctly)
    IMGUI_API ImVec2        GetContentRegionMaxAbs();
    IMGUI_API void          ShrinkWidths(ImGuiShrinkWidthItem* items, int count, float width_excess);

    // Logging/Capture
    IMGUI_API void          LogBegin(ImGuiLogType type, int auto_open_depth);   // -> BeginCapture() when we design v2 api, for now stay under the radar by using the old name.
    IMGUI_API void          LogToBuffer(int auto_open_depth = -1);              // Start logging/capturing to internal buffer

    // Popups, Modals, Tooltips
    IMGUI_API void          OpenPopupEx(ImGuiID id);
    IMGUI_API void          ClosePopupToLevel(int remaining, bool restore_focus_to_window_under_popup);
    IMGUI_API void          ClosePopupsOverWindow(ImGuiWindow* ref_window, bool restore_focus_to_window_under_popup);
    IMGUI_API bool          IsPopupOpen(ImGuiID id); // Test for id within current popup stack level (currently begin-ed into); this doesn't scan the whole popup stack!
    IMGUI_API bool          BeginPopupEx(ImGuiID id, ImGuiWindowFlags extra_flags);
    IMGUI_API void          BeginTooltipEx(ImGuiWindowFlags extra_flags, bool override_previous_tooltip = true);
    IMGUI_API ImGuiWindow*  GetTopMostPopupModal();
    IMGUI_API ImVec2        FindBestWindowPosForPopup(ImGuiWindow* window);
    IMGUI_API ImVec2        FindBestWindowPosForPopupEx(const ImVec2& ref_pos, const ImVec2& size, ImGuiDir* last_dir, const ImRect& r_outer, const ImRect& r_avoid, ImGuiPopupPositionPolicy policy = ImGuiPopupPositionPolicy_Default);

    // Navigation
    IMGUI_API void          NavInitWindow(ImGuiWindow* window, bool force_reinit);
    IMGUI_API bool          NavMoveRequestButNoResultYet();
    IMGUI_API void          NavMoveRequestCancel();
    IMGUI_API void          NavMoveRequestForward(ImGuiDir move_dir, ImGuiDir clip_dir, const ImRect& bb_rel, ImGuiNavMoveFlags move_flags);
    IMGUI_API void          NavMoveRequestTryWrapping(ImGuiWindow* window, ImGuiNavMoveFlags move_flags);
    IMGUI_API float         GetNavInputAmount(ImGuiNavInput n, ImGuiInputReadMode mode);
    IMGUI_API ImVec2        GetNavInputAmount2d(ImGuiNavDirSourceFlags dir_sources, ImGuiInputReadMode mode, float slow_factor = 0.0f, float fast_factor = 0.0f);
    IMGUI_API int           CalcTypematicRepeatAmount(float t0, float t1, float repeat_delay, float repeat_rate);
    IMGUI_API void          ActivateItem(ImGuiID id);   // Remotely activate a button, checkbox, tree node etc. given its unique ID. activation is queued and processed on the next frame when the item is encountered again.
    IMGUI_API void          SetNavID(ImGuiID id, int nav_layer);
    IMGUI_API void          SetNavIDWithRectRel(ImGuiID id, int nav_layer, const ImRect& rect_rel);

    // Inputs
    // FIXME: Eventually we should aim to move e.g. IsActiveIdUsingKey() into IsKeyXXX functions.
    inline bool             IsActiveIdUsingNavDir(ImGuiDir dir)                         { ImGuiContext& g = *GImGui; return (g.ActiveIdUsingNavDirMask & (1 << dir)) != 0; }
    inline bool             IsActiveIdUsingNavInput(ImGuiNavInput input)                { ImGuiContext& g = *GImGui; return (g.ActiveIdUsingNavInputMask & (1 << input)) != 0; }
    inline bool             IsActiveIdUsingKey(ImGuiKey key)                            { ImGuiContext& g = *GImGui; IM_ASSERT(key < 64); return (g.ActiveIdUsingKeyInputMask & ((ImU64)1 << key)) != 0; }
    IMGUI_API bool          IsMouseDragPastThreshold(ImGuiMouseButton button, float lock_threshold = -1.0f);
    inline bool             IsKeyPressedMap(ImGuiKey key, bool repeat = true)           { ImGuiContext& g = *GImGui; const int key_index = g.IO.KeyMap[key]; return (key_index >= 0) ? IsKeyPressed(key_index, repeat) : false; }
    inline bool             IsNavInputDown(ImGuiNavInput n)                             { ImGuiContext& g = *GImGui; return g.IO.NavInputs[n] > 0.0f; }
    inline bool             IsNavInputTest(ImGuiNavInput n, ImGuiInputReadMode rm)      { return (GetNavInputAmount(n, rm) > 0.0f); }

    // Drag and Drop
    IMGUI_API bool          BeginDragDropTargetCustom(const ImRect& bb, ImGuiID id);
    IMGUI_API void          ClearDragDrop();
    IMGUI_API bool          IsDragDropPayloadBeingAccepted();

    // New Columns API (FIXME-WIP)
    IMGUI_API void          BeginColumns(const char* str_id, int count, ImGuiColumnsFlags flags = 0); // setup number of columns. use an identifier to distinguish multiple column sets. close with EndColumns().
    IMGUI_API void          EndColumns();                                                             // close columns
    IMGUI_API void          PushColumnClipRect(int column_index);
    IMGUI_API void          PushColumnsBackground();
    IMGUI_API void          PopColumnsBackground();
    IMGUI_API ImGuiID       GetColumnsID(const char* str_id, int count);
    IMGUI_API ImGuiColumns* FindOrCreateColumns(ImGuiWindow* window, ImGuiID id);
    IMGUI_API float         GetColumnOffsetFromNorm(const ImGuiColumns* columns, float offset_norm);
    IMGUI_API float         GetColumnNormFromOffset(const ImGuiColumns* columns, float offset);

    // Tab Bars
    IMGUI_API bool          BeginTabBarEx(ImGuiTabBar* tab_bar, const ImRect& bb, ImGuiTabBarFlags flags);
    IMGUI_API ImGuiTabItem* TabBarFindTabByID(ImGuiTabBar* tab_bar, ImGuiID tab_id);
    IMGUI_API void          TabBarRemoveTab(ImGuiTabBar* tab_bar, ImGuiID tab_id);
    IMGUI_API void          TabBarCloseTab(ImGuiTabBar* tab_bar, ImGuiTabItem* tab);
    IMGUI_API void          TabBarQueueChangeTabOrder(ImGuiTabBar* tab_bar, const ImGuiTabItem* tab, int dir);
    IMGUI_API bool          TabItemEx(ImGuiTabBar* tab_bar, const char* label, bool* p_open, ImGuiTabItemFlags flags);
    IMGUI_API ImVec2        TabItemCalcSize(const char* label, bool has_close_button);
    IMGUI_API void          TabItemBackground(ImDrawList* draw_list, const ImRect& bb, ImGuiTabItemFlags flags, ImU32 col);
    IMGUI_API bool          TabItemLabelAndCloseButton(ImDrawList* draw_list, const ImRect& bb, ImGuiTabItemFlags flags, ImVec2 frame_padding, const char* label, ImGuiID tab_id, ImGuiID close_button_id);

    // Render helpers
    // AVOID USING OUTSIDE OF IMGUI.CPP! NOT FOR PUBLIC CONSUMPTION. THOSE FUNCTIONS ARE A MESS. THEIR SIGNATURE AND BEHAVIOR WILL CHANGE, THEY NEED TO BE REFACTORED INTO SOMETHING DECENT.
    // NB: All position are in absolute pixels coordinates (we are never using window coordinates internally)
    IMGUI_API void          RenderText(ImVec2 pos, const char* text, const char* text_end = NULL, bool hide_text_after_hash = true);
    IMGUI_API void          RenderTextWrapped(ImVec2 pos, const char* text, const char* text_end, float wrap_width);
    IMGUI_API void          RenderTextClipped(const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_end, const ImVec2* text_size_if_known, const ImVec2& align = ImVec2(0,0), const ImRect* clip_rect = NULL);
    IMGUI_API void          RenderTextClippedEx(ImDrawList* draw_list, const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_end, const ImVec2* text_size_if_known, const ImVec2& align = ImVec2(0, 0), const ImRect* clip_rect = NULL);
    IMGUI_API void          RenderTextEllipsis(ImDrawList* draw_list, const ImVec2& pos_min, const ImVec2& pos_max, float clip_max_x, float ellipsis_max_x, const char* text, const char* text_end, const ImVec2* text_size_if_known);
    IMGUI_API void          RenderFrame(ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, bool border = true, float rounding = 0.0f);
    IMGUI_API void          RenderFrameBorder(ImVec2 p_min, ImVec2 p_max, float rounding = 0.0f);
    IMGUI_API void          RenderColorRectWithAlphaCheckerboard(ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, float grid_step, ImVec2 grid_off, float rounding = 0.0f, int rounding_corners_flags = ~0);
    IMGUI_API void          RenderCheckMark(ImVec2 pos, ImU32 col, float sz);
    IMGUI_API void          RenderNavHighlight(const ImRect& bb, ImGuiID id, ImGuiNavHighlightFlags flags = ImGuiNavHighlightFlags_TypeDefault); // Navigation highlight
    IMGUI_API const char*   FindRenderedTextEnd(const char* text, const char* text_end = NULL); // Find the optional ## from which we stop displaying text.
    IMGUI_API void          LogRenderedText(const ImVec2* ref_pos, const char* text, const char* text_end = NULL);

    // Render helpers (those functions don't access any ImGui state!)
    IMGUI_API void          RenderArrow(ImDrawList* draw_list, ImVec2 pos, ImU32 col, ImGuiDir dir, float scale = 1.0f);
    IMGUI_API void          RenderBullet(ImDrawList* draw_list, ImVec2 pos, ImU32 col);
    IMGUI_API void          RenderMouseCursor(ImDrawList* draw_list, ImVec2 pos, float scale, ImGuiMouseCursor mouse_cursor, ImU32 col_fill, ImU32 col_border, ImU32 col_shadow);
    IMGUI_API void          RenderArrowPointingAt(ImDrawList* draw_list, ImVec2 pos, ImVec2 half_sz, ImGuiDir direction, ImU32 col);
    IMGUI_API void          RenderRectFilledRangeH(ImDrawList* draw_list, const ImRect& rect, ImU32 col, float x_start_norm, float x_end_norm, float rounding);

#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
    // [1.71: 2019/06/07: Updating prototypes of some of the internal functions. Leaving those for reference for a short while]
    inline void RenderArrow(ImVec2 pos, ImGuiDir dir, float scale=1.0f) { ImGuiWindow* window = GetCurrentWindow(); RenderArrow(window->DrawList, pos, GetColorU32(ImGuiCol_Text), dir, scale); }
    inline void RenderBullet(ImVec2 pos)                                { ImGuiWindow* window = GetCurrentWindow(); RenderBullet(window->DrawList, pos, GetColorU32(ImGuiCol_Text)); }
#endif

    // Widgets
    IMGUI_API void          TextEx(const char* text, const char* text_end = NULL, ImGuiTextFlags flags = 0);
    IMGUI_API bool          ButtonEx(const char* label, const ImVec2& size_arg = ImVec2(0,0), ImGuiButtonFlags flags = 0);
    IMGUI_API bool          CloseButton(ImGuiID id, const ImVec2& pos);
    IMGUI_API bool          CollapseButton(ImGuiID id, const ImVec2& pos);
    IMGUI_API bool          ArrowButtonEx(const char* str_id, ImGuiDir dir, ImVec2 size_arg, ImGuiButtonFlags flags);
    IMGUI_API void          Scrollbar(ImGuiAxis axis);
    IMGUI_API bool          ScrollbarEx(const ImRect& bb, ImGuiID id, ImGuiAxis axis, float* p_scroll_v, float avail_v, float contents_v, ImDrawCornerFlags rounding_corners);
    IMGUI_API ImGuiID       GetWindowScrollbarID(ImGuiWindow* window, ImGuiAxis axis);
    IMGUI_API ImGuiID       GetWindowResizeID(ImGuiWindow* window, int n); // 0..3: corners, 4..7: borders
    IMGUI_API void          SeparatorEx(ImGuiSeparatorFlags flags);

    // Widgets low-level behaviors
    IMGUI_API bool          ButtonBehavior(const ImRect& bb, ImGuiID id, bool* out_hovered, bool* out_held, ImGuiButtonFlags flags = 0);
    IMGUI_API bool          DragBehavior(ImGuiID id, ImGuiDataType data_type, void* p_v, float v_speed, const void* p_min, const void* p_max, const char* format, float power, ImGuiDragFlags flags);
    IMGUI_API bool          SliderBehavior(const ImRect& bb, ImGuiID id, ImGuiDataType data_type, void* p_v, const void* p_min, const void* p_max, const char* format, float power, ImGuiSliderFlags flags, ImRect* out_grab_bb);
    IMGUI_API bool          SplitterBehavior(const ImRect& bb, ImGuiID id, ImGuiAxis axis, float* size1, float* size2, float min_size1, float min_size2, float hover_extend = 0.0f, float hover_visibility_delay = 0.0f);
    IMGUI_API bool          TreeNodeBehavior(ImGuiID id, ImGuiTreeNodeFlags flags, const char* label, const char* label_end = NULL);
    IMGUI_API bool          TreeNodeBehaviorIsOpen(ImGuiID id, ImGuiTreeNodeFlags flags = 0);                     // Consume previous SetNextItemOpen() data, if any. May return true when logging
    IMGUI_API void          TreePushOverrideID(ImGuiID id);

    // Template functions are instantiated in imgui_widgets.cpp for a finite number of types.
    // To use them externally (for custom widget) you may need an "extern template" statement in your code in order to link to existing instances and silence Clang warnings (see #2036).
    // e.g. " extern template IMGUI_API float RoundScalarWithFormatT<float, float>(const char* format, ImGuiDataType data_type, float v); "
    template<typename T, typename SIGNED_T, typename FLOAT_T>   IMGUI_API bool  DragBehaviorT(ImGuiDataType data_type, T* v, float v_speed, T v_min, T v_max, const char* format, float power, ImGuiDragFlags flags);
    template<typename T, typename SIGNED_T, typename FLOAT_T>   IMGUI_API bool  SliderBehaviorT(const ImRect& bb, ImGuiID id, ImGuiDataType data_type, T* v, T v_min, T v_max, const char* format, float power, ImGuiSliderFlags flags, ImRect* out_grab_bb);
    template<typename T, typename FLOAT_T>                      IMGUI_API float SliderCalcRatioFromValueT(ImGuiDataType data_type, T v, T v_min, T v_max, float power, float linear_zero_pos);
    template<typename T, typename SIGNED_T>                     IMGUI_API T     RoundScalarWithFormatT(const char* format, ImGuiDataType data_type, T v);

    // Data type helpers
    IMGUI_API const ImGuiDataTypeInfo*  DataTypeGetInfo(ImGuiDataType data_type);
    IMGUI_API int           DataTypeFormatString(char* buf, int buf_size, ImGuiDataType data_type, const void* p_data, const char* format);
    IMGUI_API void          DataTypeApplyOp(ImGuiDataType data_type, int op, void* output, void* arg_1, const void* arg_2);
    IMGUI_API bool          DataTypeApplyOpFromText(const char* buf, const char* initial_value_buf, ImGuiDataType data_type, void* p_data, const char* format);

    // InputText
    IMGUI_API bool          InputTextEx(const char* label, const char* hint, char* buf, int buf_size, const ImVec2& size_arg, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback = NULL, void* user_data = NULL);
    IMGUI_API bool          TempInputTextScalar(const ImRect& bb, ImGuiID id, const char* label, ImGuiDataType data_type, void* p_data, const char* format);
    inline bool             TempInputTextIsActive(ImGuiID id) { ImGuiContext& g = *GImGui; return (g.ActiveId == id && g.TempInputTextId == id); }

    // Color
    IMGUI_API void          ColorTooltip(const char* text, const float* col, ImGuiColorEditFlags flags);
    IMGUI_API void          ColorEditOptionsPopup(const float* col, ImGuiColorEditFlags flags);
    IMGUI_API void          ColorPickerOptionsPopup(const float* ref_col, ImGuiColorEditFlags flags);

    // Plot
    IMGUI_API void          PlotEx(ImGuiPlotType plot_type, const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 frame_size);

    // Shade functions (write over already created vertices)
    IMGUI_API void          ShadeVertsLinearColorGradientKeepAlpha(ImDrawList* draw_list, int vert_start_idx, int vert_end_idx, ImVec2 gradient_p0, ImVec2 gradient_p1, ImU32 col0, ImU32 col1);
    IMGUI_API void          ShadeVertsLinearUV(ImDrawList* draw_list, int vert_start_idx, int vert_end_idx, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, bool clamp);

    // Debug Tools
    inline void             DebugDrawItemRect(ImU32 col = IM_COL32(255,0,0,255))    { ImGuiContext& g = *GImGui; ImGuiWindow* window = g.CurrentWindow; GetForegroundDrawList(window)->AddRect(window->DC.LastItemRect.Min, window->DC.LastItemRect.Max, col); }
    inline void             DebugStartItemPicker()                                  { ImGuiContext& g = *GImGui; g.DebugItemPickerActive = true; }

} // namespace ImGui

// ImFontAtlas internals
IMGUI_API bool              ImFontAtlasBuildWithStbTruetype(ImFontAtlas* atlas);
IMGUI_API void              ImFontAtlasBuildRegisterDefaultCustomRects(ImFontAtlas* atlas);
IMGUI_API void              ImFontAtlasBuildSetupFont(ImFontAtlas* atlas, ImFont* font, ImFontConfig* font_config, float ascent, float descent);
IMGUI_API void              ImFontAtlasBuildPackCustomRects(ImFontAtlas* atlas, void* stbrp_context_opaque);
IMGUI_API void              ImFontAtlasBuildFinish(ImFontAtlas* atlas);
IMGUI_API void              ImFontAtlasBuildMultiplyCalcLookupTable(unsigned char out_table[256], float in_multiply_factor);
IMGUI_API void              ImFontAtlasBuildMultiplyRectAlpha8(const unsigned char table[256], unsigned char* pixels, int x, int y, int w, int h, int stride);

// Debug Tools
// Use 'Metrics->Tools->Item Picker' to break into the call-stack of a specific item.
#ifndef IM_DEBUG_BREAK
#if defined(__clang__)
#define IM_DEBUG_BREAK()    __builtin_debugtrap()
#elif defined (_MSC_VER)
#define IM_DEBUG_BREAK()    __debugbreak()
#else
#define IM_DEBUG_BREAK()    IM_ASSERT(0)    // It is expected that you define IM_DEBUG_BREAK() into something that will break nicely in a debugger!
#endif
#endif // #ifndef IM_DEBUG_BREAK

// Test Engine Hooks (imgui_tests)
//#define IMGUI_ENABLE_TEST_ENGINE
#ifdef IMGUI_ENABLE_TEST_ENGINE
extern void                 ImGuiTestEngineHook_PreNewFrame(ImGuiContext* ctx);
extern void                 ImGuiTestEngineHook_PostNewFrame(ImGuiContext* ctx);
extern void                 ImGuiTestEngineHook_ItemAdd(ImGuiContext* ctx, const ImRect& bb, ImGuiID id);
extern void                 ImGuiTestEngineHook_ItemInfo(ImGuiContext* ctx, ImGuiID id, const char* label, ImGuiItemStatusFlags flags);
extern void                 ImGuiTestEngineHook_Log(ImGuiContext* ctx, const char* fmt, ...);
#define IMGUI_TEST_ENGINE_ITEM_ADD(_BB, _ID)                ImGuiTestEngineHook_ItemAdd(&g, _BB, _ID)               // Register item bounding box
#define IMGUI_TEST_ENGINE_ITEM_INFO(_ID, _LABEL, _FLAGS)    ImGuiTestEngineHook_ItemInfo(&g, _ID, _LABEL, _FLAGS)   // Register item label and status flags (optional)
#define IMGUI_TEST_ENGINE_LOG(_FMT, ...)                    ImGuiTestEngineHook_Log(&g, _FMT, __VA_ARGS__)          // Custom log entry from user land into test log
#else
#define IMGUI_TEST_ENGINE_ITEM_ADD(_BB, _ID)                do { } while (0)
#define IMGUI_TEST_ENGINE_ITEM_INFO(_ID, _LABEL, _FLAGS)    do { } while (0)
#define IMGUI_TEST_ENGINE_LOG(_FMT, ...)                    do { } while (0)
#endif

#if defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

#ifdef _MSC_VER
#pragma warning (pop)
#endif

```

`Artemis/ImGui/imstb_rectpack.h`:

```h
// [DEAR IMGUI]
// This is a slightly modified version of stb_rect_pack.h 1.00.
// Those changes would need to be pushed into nothings/stb:
// - Added STBRP__CDECL
// Grep for [DEAR IMGUI] to find the changes.

// stb_rect_pack.h - v1.00 - public domain - rectangle packing
// Sean Barrett 2014
//
// Useful for e.g. packing rectangular textures into an atlas.
// Does not do rotation.
//
// Not necessarily the awesomest packing method, but better than
// the totally naive one in stb_truetype (which is primarily what
// this is meant to replace).
//
// Has only had a few tests run, may have issues.
//
// More docs to come.
//
// No memory allocations; uses qsort() and assert() from stdlib.
// Can override those by defining STBRP_SORT and STBRP_ASSERT.
//
// This library currently uses the Skyline Bottom-Left algorithm.
//
// Please note: better rectangle packers are welcome! Please
// implement them to the same API, but with a different init
// function.
//
// Credits
//
//  Library
//    Sean Barrett
//  Minor features
//    Martins Mozeiko
//    github:IntellectualKitty
//    
//  Bugfixes / warning fixes
//    Jeremy Jaussaud
//    Fabian Giesen
//
// Version history:
//
//     1.00  (2019-02-25)  avoid small space waste; gracefully fail too-wide rectangles
//     0.99  (2019-02-07)  warning fixes
//     0.11  (2017-03-03)  return packing success/fail result
//     0.10  (2016-10-25)  remove cast-away-const to avoid warnings
//     0.09  (2016-08-27)  fix compiler warnings
//     0.08  (2015-09-13)  really fix bug with empty rects (w=0 or h=0)
//     0.07  (2015-09-13)  fix bug with empty rects (w=0 or h=0)
//     0.06  (2015-04-15)  added STBRP_SORT to allow replacing qsort
//     0.05:  added STBRP_ASSERT to allow replacing assert
//     0.04:  fixed minor bug in STBRP_LARGE_RECTS support
//     0.01:  initial release
//
// LICENSE
//
//   See end of file for license information.

//////////////////////////////////////////////////////////////////////////////
//
//       INCLUDE SECTION
//

#ifndef STB_INCLUDE_STB_RECT_PACK_H
#define STB_INCLUDE_STB_RECT_PACK_H

#define STB_RECT_PACK_VERSION  1

#ifdef STBRP_STATIC
#define STBRP_DEF static
#else
#define STBRP_DEF extern
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef struct stbrp_context stbrp_context;
typedef struct stbrp_node    stbrp_node;
typedef struct stbrp_rect    stbrp_rect;

#ifdef STBRP_LARGE_RECTS
typedef int            stbrp_coord;
#else
typedef unsigned short stbrp_coord;
#endif

STBRP_DEF int stbrp_pack_rects (stbrp_context *context, stbrp_rect *rects, int num_rects);
// Assign packed locations to rectangles. The rectangles are of type
// 'stbrp_rect' defined below, stored in the array 'rects', and there
// are 'num_rects' many of them.
//
// Rectangles which are successfully packed have the 'was_packed' flag
// set to a non-zero value and 'x' and 'y' store the minimum location
// on each axis (i.e. bottom-left in cartesian coordinates, top-left
// if you imagine y increasing downwards). Rectangles which do not fit
// have the 'was_packed' flag set to 0.
//
// You should not try to access the 'rects' array from another thread
// while this function is running, as the function temporarily reorders
// the array while it executes.
//
// To pack into another rectangle, you need to call stbrp_init_target
// again. To continue packing into the same rectangle, you can call
// this function again. Calling this multiple times with multiple rect
// arrays will probably produce worse packing results than calling it
// a single time with the full rectangle array, but the option is
// available.
//
// The function returns 1 if all of the rectangles were successfully
// packed and 0 otherwise.

struct stbrp_rect
{
   // reserved for your use:
   int            id;

   // input:
   stbrp_coord    w, h;

   // output:
   stbrp_coord    x, y;
   int            was_packed;  // non-zero if valid packing

}; // 16 bytes, nominally


STBRP_DEF void stbrp_init_target (stbrp_context *context, int width, int height, stbrp_node *nodes, int num_nodes);
// Initialize a rectangle packer to:
//    pack a rectangle that is 'width' by 'height' in dimensions
//    using temporary storage provided by the array 'nodes', which is 'num_nodes' long
//
// You must call this function every time you start packing into a new target.
//
// There is no "shutdown" function. The 'nodes' memory must stay valid for
// the following stbrp_pack_rects() call (or calls), but can be freed after
// the call (or calls) finish.
//
// Note: to guarantee best results, either:
//       1. make sure 'num_nodes' >= 'width'
//   or  2. call stbrp_allow_out_of_mem() defined below with 'allow_out_of_mem = 1'
//
// If you don't do either of the above things, widths will be quantized to multiples
// of small integers to guarantee the algorithm doesn't run out of temporary storage.
//
// If you do #2, then the non-quantized algorithm will be used, but the algorithm
// may run out of temporary storage and be unable to pack some rectangles.

STBRP_DEF void stbrp_setup_allow_out_of_mem (stbrp_context *context, int allow_out_of_mem);
// Optionally call this function after init but before doing any packing to
// change the handling of the out-of-temp-memory scenario, described above.
// If you call init again, this will be reset to the default (false).


STBRP_DEF void stbrp_setup_heuristic (stbrp_context *context, int heuristic);
// Optionally select which packing heuristic the library should use. Different
// heuristics will produce better/worse results for different data sets.
// If you call init again, this will be reset to the default.

enum
{
   STBRP_HEURISTIC_Skyline_default=0,
   STBRP_HEURISTIC_Skyline_BL_sortHeight = STBRP_HEURISTIC_Skyline_default,
   STBRP_HEURISTIC_Skyline_BF_sortHeight
};


//////////////////////////////////////////////////////////////////////////////
//
// the details of the following structures don't matter to you, but they must
// be visible so you can handle the memory allocations for them

struct stbrp_node
{
   stbrp_coord  x,y;
   stbrp_node  *next;
};

struct stbrp_context
{
   int width;
   int height;
   int align;
   int init_mode;
   int heuristic;
   int num_nodes;
   stbrp_node *active_head;
   stbrp_node *free_head;
   stbrp_node extra[2]; // we allocate two extra nodes so optimal user-node-count is 'width' not 'width+2'
};

#ifdef __cplusplus
}
#endif

#endif

//////////////////////////////////////////////////////////////////////////////
//
//     IMPLEMENTATION SECTION
//

#ifdef STB_RECT_PACK_IMPLEMENTATION
#ifndef STBRP_SORT
#include <stdlib.h>
#define STBRP_SORT qsort
#endif

#ifndef STBRP_ASSERT
#include <assert.h>
#define STBRP_ASSERT assert
#endif

// [DEAR IMGUI] Added STBRP__CDECL
#ifdef _MSC_VER
#define STBRP__NOTUSED(v)  (void)(v)
#define STBRP__CDECL __cdecl
#else
#define STBRP__NOTUSED(v)  (void)sizeof(v)
#define STBRP__CDECL
#endif

enum
{
   STBRP__INIT_skyline = 1
};

STBRP_DEF void stbrp_setup_heuristic(stbrp_context *context, int heuristic)
{
   switch (context->init_mode) {
      case STBRP__INIT_skyline:
         STBRP_ASSERT(heuristic == STBRP_HEURISTIC_Skyline_BL_sortHeight || heuristic == STBRP_HEURISTIC_Skyline_BF_sortHeight);
         context->heuristic = heuristic;
         break;
      default:
         STBRP_ASSERT(0);
   }
}

STBRP_DEF void stbrp_setup_allow_out_of_mem(stbrp_context *context, int allow_out_of_mem)
{
   if (allow_out_of_mem)
      // if it's ok to run out of memory, then don't bother aligning them;
      // this gives better packing, but may fail due to OOM (even though
      // the rectangles easily fit). @TODO a smarter approach would be to only
      // quantize once we've hit OOM, then we could get rid of this parameter.
      context->align = 1;
   else {
      // if it's not ok to run out of memory, then quantize the widths
      // so that num_nodes is always enough nodes.
      //
      // I.e. num_nodes * align >= width
      //                  align >= width / num_nodes
      //                  align = ceil(width/num_nodes)

      context->align = (context->width + context->num_nodes-1) / context->num_nodes;
   }
}

STBRP_DEF void stbrp_init_target(stbrp_context *context, int width, int height, stbrp_node *nodes, int num_nodes)
{
   int i;
#ifndef STBRP_LARGE_RECTS
   STBRP_ASSERT(width <= 0xffff && height <= 0xffff);
#endif

   for (i=0; i < num_nodes-1; ++i)
      nodes[i].next = &nodes[i+1];
   nodes[i].next = NULL;
   context->init_mode = STBRP__INIT_skyline;
   context->heuristic = STBRP_HEURISTIC_Skyline_default;
   context->free_head = &nodes[0];
   context->active_head = &context->extra[0];
   context->width = width;
   context->height = height;
   context->num_nodes = num_nodes;
   stbrp_setup_allow_out_of_mem(context, 0);

   // node 0 is the full width, node 1 is the sentinel (lets us not store width explicitly)
   context->extra[0].x = 0;
   context->extra[0].y = 0;
   context->extra[0].next = &context->extra[1];
   context->extra[1].x = (stbrp_coord) width;
#ifdef STBRP_LARGE_RECTS
   context->extra[1].y = (1<<30);
#else
   context->extra[1].y = 65535;
#endif
   context->extra[1].next = NULL;
}

// find minimum y position if it starts at x1
static int stbrp__skyline_find_min_y(stbrp_context *c, stbrp_node *first, int x0, int width, int *pwaste)
{
   stbrp_node *node = first;
   int x1 = x0 + width;
   int min_y, visited_width, waste_area;

   STBRP__NOTUSED(c);

   STBRP_ASSERT(first->x <= x0);

   #if 0
   // skip in case we're past the node
   while (node->next->x <= x0)
      ++node;
   #else
   STBRP_ASSERT(node->next->x > x0); // we ended up handling this in the caller for efficiency
   #endif

   STBRP_ASSERT(node->x <= x0);

   min_y = 0;
   waste_area = 0;
   visited_width = 0;
   while (node->x < x1) {
      if (node->y > min_y) {
         // raise min_y higher.
         // we've accounted for all waste up to min_y,
         // but we'll now add more waste for everything we've visted
         waste_area += visited_width * (node->y - min_y);
         min_y = node->y;
         // the first time through, visited_width might be reduced
         if (node->x < x0)
            visited_width += node->next->x - x0;
         else
            visited_width += node->next->x - node->x;
      } else {
         // add waste area
         int under_width = node->next->x - node->x;
         if (under_width + visited_width > width)
            under_width = width - visited_width;
         waste_area += under_width * (min_y - node->y);
         visited_width += under_width;
      }
      node = node->next;
   }

   *pwaste = waste_area;
   return min_y;
}

typedef struct
{
   int x,y;
   stbrp_node **prev_link;
} stbrp__findresult;

static stbrp__findresult stbrp__skyline_find_best_pos(stbrp_context *c, int width, int height)
{
   int best_waste = (1<<30), best_x, best_y = (1 << 30);
   stbrp__findresult fr;
   stbrp_node **prev, *node, *tail, **best = NULL;

   // align to multiple of c->align
   width = (width + c->align - 1);
   width -= width % c->align;
   STBRP_ASSERT(width % c->align == 0);

   // if it can't possibly fit, bail immediately
   if (width > c->width || height > c->height) {
      fr.prev_link = NULL;
      fr.x = fr.y = 0;
      return fr;
   }

   node = c->active_head;
   prev = &c->active_head;
   while (node->x + width <= c->width) {
      int y,waste;
      y = stbrp__skyline_find_min_y(c, node, node->x, width, &waste);
      if (c->heuristic == STBRP_HEURISTIC_Skyline_BL_sortHeight) { // actually just want to test BL
         // bottom left
         if (y < best_y) {
            best_y = y;
            best = prev;
         }
      } else {
         // best-fit
         if (y + height <= c->height) {
            // can only use it if it first vertically
            if (y < best_y || (y == best_y && waste < best_waste)) {
               best_y = y;
               best_waste = waste;
               best = prev;
            }
         }
      }
      prev = &node->next;
      node = node->next;
   }

   best_x = (best == NULL) ? 0 : (*best)->x;

   // if doing best-fit (BF), we also have to try aligning right edge to each node position
   //
   // e.g, if fitting
   //
   //     ____________________
   //    |____________________|
   //
   //            into
   //
   //   |                         |
   //   |             ____________|
   //   |____________|
   //
   // then right-aligned reduces waste, but bottom-left BL is always chooses left-aligned
   //
   // This makes BF take about 2x the time

   if (c->heuristic == STBRP_HEURISTIC_Skyline_BF_sortHeight) {
      tail = c->active_head;
      node = c->active_head;
      prev = &c->active_head;
      // find first node that's admissible
      while (tail->x < width)
         tail = tail->next;
      while (tail) {
         int xpos = tail->x - width;
         int y,waste;
         STBRP_ASSERT(xpos >= 0);
         // find the left position that matches this
         while (node->next->x <= xpos) {
            prev = &node->next;
            node = node->next;
         }
         STBRP_ASSERT(node->next->x > xpos && node->x <= xpos);
         y = stbrp__skyline_find_min_y(c, node, xpos, width, &waste);
         if (y + height <= c->height) {
            if (y <= best_y) {
               if (y < best_y || waste < best_waste || (waste==best_waste && xpos < best_x)) {
                  best_x = xpos;
                  STBRP_ASSERT(y <= best_y);
                  best_y = y;
                  best_waste = waste;
                  best = prev;
               }
            }
         }
         tail = tail->next;
      }         
   }

   fr.prev_link = best;
   fr.x = best_x;
   fr.y = best_y;
   return fr;
}

static stbrp__findresult stbrp__skyline_pack_rectangle(stbrp_context *context, int width, int height)
{
   // find best position according to heuristic
   stbrp__findresult res = stbrp__skyline_find_best_pos(context, width, height);
   stbrp_node *node, *cur;

   // bail if:
   //    1. it failed
   //    2. the best node doesn't fit (we don't always check this)
   //    3. we're out of memory
   if (res.prev_link == NULL || res.y + height > context->height || context->free_head == NULL) {
      res.prev_link = NULL;
      return res;
   }

   // on success, create new node
   node = context->free_head;
   node->x = (stbrp_coord) res.x;
   node->y = (stbrp_coord) (res.y + height);

   context->free_head = node->next;

   // insert the new node into the right starting point, and
   // let 'cur' point to the remaining nodes needing to be
   // stiched back in

   cur = *res.prev_link;
   if (cur->x < res.x) {
      // preserve the existing one, so start testing with the next one
      stbrp_node *next = cur->next;
      cur->next = node;
      cur = next;
   } else {
      *res.prev_link = node;
   }

   // from here, traverse cur and free the nodes, until we get to one
   // that shouldn't be freed
   while (cur->next && cur->next->x <= res.x + width) {
      stbrp_node *next = cur->next;
      // move the current node to the free list
      cur->next = context->free_head;
      context->free_head = cur;
      cur = next;
   }

   // stitch the list back in
   node->next = cur;

   if (cur->x < res.x + width)
      cur->x = (stbrp_coord) (res.x + width);

#ifdef _DEBUG
   cur = context->active_head;
   while (cur->x < context->width) {
      STBRP_ASSERT(cur->x < cur->next->x);
      cur = cur->next;
   }
   STBRP_ASSERT(cur->next == NULL);

   {
      int count=0;
      cur = context->active_head;
      while (cur) {
         cur = cur->next;
         ++count;
      }
      cur = context->free_head;
      while (cur) {
         cur = cur->next;
         ++count;
      }
      STBRP_ASSERT(count == context->num_nodes+2);
   }
#endif

   return res;
}

// [DEAR IMGUI] Added STBRP__CDECL
static int STBRP__CDECL rect_height_compare(const void *a, const void *b)
{
   const stbrp_rect *p = (const stbrp_rect *) a;
   const stbrp_rect *q = (const stbrp_rect *) b;
   if (p->h > q->h)
      return -1;
   if (p->h < q->h)
      return  1;
   return (p->w > q->w) ? -1 : (p->w < q->w);
}

// [DEAR IMGUI] Added STBRP__CDECL
static int STBRP__CDECL rect_original_order(const void *a, const void *b)
{
   const stbrp_rect *p = (const stbrp_rect *) a;
   const stbrp_rect *q = (const stbrp_rect *) b;
   return (p->was_packed < q->was_packed) ? -1 : (p->was_packed > q->was_packed);
}

#ifdef STBRP_LARGE_RECTS
#define STBRP__MAXVAL  0xffffffff
#else
#define STBRP__MAXVAL  0xffff
#endif

STBRP_DEF int stbrp_pack_rects(stbrp_context *context, stbrp_rect *rects, int num_rects)
{
   int i, all_rects_packed = 1;

   // we use the 'was_packed' field internally to allow sorting/unsorting
   for (i=0; i < num_rects; ++i) {
      rects[i].was_packed = i;
   }

   // sort according to heuristic
   STBRP_SORT(rects, num_rects, sizeof(rects[0]), rect_height_compare);

   for (i=0; i < num_rects; ++i) {
      if (rects[i].w == 0 || rects[i].h == 0) {
         rects[i].x = rects[i].y = 0;  // empty rect needs no space
      } else {
         stbrp__findresult fr = stbrp__skyline_pack_rectangle(context, rects[i].w, rects[i].h);
         if (fr.prev_link) {
            rects[i].x = (stbrp_coord) fr.x;
            rects[i].y = (stbrp_coord) fr.y;
         } else {
            rects[i].x = rects[i].y = STBRP__MAXVAL;
         }
      }
   }

   // unsort
   STBRP_SORT(rects, num_rects, sizeof(rects[0]), rect_original_order);

   // set was_packed flags and all_rects_packed status
   for (i=0; i < num_rects; ++i) {
      rects[i].was_packed = !(rects[i].x == STBRP__MAXVAL && rects[i].y == STBRP__MAXVAL);
      if (!rects[i].was_packed)
         all_rects_packed = 0;
   }

   // return the all_rects_packed status
   return all_rects_packed;
}
#endif

/*
------------------------------------------------------------------------------
This software is available under 2 licenses -- choose whichever you prefer.
------------------------------------------------------------------------------
ALTERNATIVE A - MIT License
Copyright (c) 2017 Sean Barrett
Permission is hereby granted, free of charge, to any person obtaining a copy of 
this software and associated documentation files (the "Software"), to deal in 
the Software without restriction, including without limitation the rights to 
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies 
of the Software, and to permit persons to whom the Software is furnished to do 
so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all 
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE 
SOFTWARE.
------------------------------------------------------------------------------
ALTERNATIVE B - Public Domain (www.unlicense.org)
This is free and unencumbered software released into the public domain.
Anyone is free to copy, modify, publish, use, compile, sell, or distribute this 
software, either in source code form or as a compiled binary, for any purpose, 
commercial or non-commercial, and by any means.
In jurisdictions that recognize copyright laws, the author or authors of this 
software dedicate any and all copyright interest in the software to the public 
domain. We make this dedication for the benefit of the public at large and to 
the detriment of our heirs and successors. We intend this dedication to be an 
overt act of relinquishment in perpetuity of all present and future rights to 
this software under copyright law.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN 
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
------------------------------------------------------------------------------
*/

```

`Artemis/ImGui/imstb_textedit.h`:

```h
// [DEAR IMGUI]
// This is a slightly modified version of stb_textedit.h 1.13. 
// Those changes would need to be pushed into nothings/stb:
// - Fix in stb_textedit_discard_redo (see https://github.com/nothings/stb/issues/321)
// Grep for [DEAR IMGUI] to find the changes.

// stb_textedit.h - v1.13  - public domain - Sean Barrett
// Development of this library was sponsored by RAD Game Tools
//
// This C header file implements the guts of a multi-line text-editing
// widget; you implement display, word-wrapping, and low-level string
// insertion/deletion, and stb_textedit will map user inputs into
// insertions & deletions, plus updates to the cursor position,
// selection state, and undo state.
//
// It is intended for use in games and other systems that need to build
// their own custom widgets and which do not have heavy text-editing
// requirements (this library is not recommended for use for editing large
// texts, as its performance does not scale and it has limited undo).
//
// Non-trivial behaviors are modelled after Windows text controls.
// 
//
// LICENSE
//
// See end of file for license information.
//
//
// DEPENDENCIES
//
// Uses the C runtime function 'memmove', which you can override
// by defining STB_TEXTEDIT_memmove before the implementation.
// Uses no other functions. Performs no runtime allocations.
//
//
// VERSION HISTORY
//
//   1.13 (2019-02-07) fix bug in undo size management
//   1.12 (2018-01-29) user can change STB_TEXTEDIT_KEYTYPE, fix redo to avoid crash
//   1.11 (2017-03-03) fix HOME on last line, dragging off single-line textfield
//   1.10 (2016-10-25) supress warnings about casting away const with -Wcast-qual
//   1.9  (2016-08-27) customizable move-by-word
//   1.8  (2016-04-02) better keyboard handling when mouse button is down
//   1.7  (2015-09-13) change y range handling in case baseline is non-0
//   1.6  (2015-04-15) allow STB_TEXTEDIT_memmove
//   1.5  (2014-09-10) add support for secondary keys for OS X
//   1.4  (2014-08-17) fix signed/unsigned warnings
//   1.3  (2014-06-19) fix mouse clicking to round to nearest char boundary
//   1.2  (2014-05-27) fix some RAD types that had crept into the new code
//   1.1  (2013-12-15) move-by-word (requires STB_TEXTEDIT_IS_SPACE )
//   1.0  (2012-07-26) improve documentation, initial public release
//   0.3  (2012-02-24) bugfixes, single-line mode; insert mode
//   0.2  (2011-11-28) fixes to undo/redo
//   0.1  (2010-07-08) initial version
//
// ADDITIONAL CONTRIBUTORS
//
//   Ulf Winklemann: move-by-word in 1.1
//   Fabian Giesen: secondary key inputs in 1.5
//   Martins Mozeiko: STB_TEXTEDIT_memmove in 1.6
//
//   Bugfixes:
//      Scott Graham
//      Daniel Keller
//      Omar Cornut
//      Dan Thompson
//
// USAGE
//
// This file behaves differently depending on what symbols you define
// before including it.
//
//
// Header-file mode:
//
//   If you do not define STB_TEXTEDIT_IMPLEMENTATION before including this,
//   it will operate in "header file" mode. In this mode, it declares a
//   single public symbol, STB_TexteditState, which encapsulates the current
//   state of a text widget (except for the string, which you will store
//   separately).
//
//   To compile in this mode, you must define STB_TEXTEDIT_CHARTYPE to a
//   primitive type that defines a single character (e.g. char, wchar_t, etc).
//
//   To save space or increase undo-ability, you can optionally define the
//   following things that are used by the undo system:
//
//      STB_TEXTEDIT_POSITIONTYPE         small int type encoding a valid cursor position
//      STB_TEXTEDIT_UNDOSTATECOUNT       the number of undo states to allow
//      STB_TEXTEDIT_UNDOCHARCOUNT        the number of characters to store in the undo buffer
//
//   If you don't define these, they are set to permissive types and
//   moderate sizes. The undo system does no memory allocations, so
//   it grows STB_TexteditState by the worst-case storage which is (in bytes):
//
//        [4 + 3 * sizeof(STB_TEXTEDIT_POSITIONTYPE)] * STB_TEXTEDIT_UNDOSTATE_COUNT
//      +          sizeof(STB_TEXTEDIT_CHARTYPE)      * STB_TEXTEDIT_UNDOCHAR_COUNT
//
//
// Implementation mode:
//
//   If you define STB_TEXTEDIT_IMPLEMENTATION before including this, it
//   will compile the implementation of the text edit widget, depending
//   on a large number of symbols which must be defined before the include.
//
//   The implementation is defined only as static functions. You will then
//   need to provide your own APIs in the same file which will access the
//   static functions.
//
//   The basic concept is that you provide a "string" object which
//   behaves like an array of characters. stb_textedit uses indices to
//   refer to positions in the string, implicitly representing positions
//   in the displayed textedit. This is true for both plain text and
//   rich text; even with rich text stb_truetype interacts with your
//   code as if there was an array of all the displayed characters.
//
// Symbols that must be the same in header-file and implementation mode:
//
//     STB_TEXTEDIT_CHARTYPE             the character type
//     STB_TEXTEDIT_POSITIONTYPE         small type that is a valid cursor position
//     STB_TEXTEDIT_UNDOSTATECOUNT       the number of undo states to allow
//     STB_TEXTEDIT_UNDOCHARCOUNT        the number of characters to store in the undo buffer
//
// Symbols you must define for implementation mode:
//
//    STB_TEXTEDIT_STRING               the type of object representing a string being edited,
//                                      typically this is a wrapper object with other data you need
//
//    STB_TEXTEDIT_STRINGLEN(obj)       the length of the string (ideally O(1))
//    STB_TEXTEDIT_LAYOUTROW(&r,obj,n)  returns the results of laying out a line of characters
//                                        starting from character #n (see discussion below)
//    STB_TEXTEDIT_GETWIDTH(obj,n,i)    returns the pixel delta from the xpos of the i'th character
//                                        to the xpos of the i+1'th char for a line of characters
//                                        starting at character #n (i.e. accounts for kerning
//                                        with previous char)
//    STB_TEXTEDIT_KEYTOTEXT(k)         maps a keyboard input to an insertable character
//                                        (return type is int, -1 means not valid to insert)
//    STB_TEXTEDIT_GETCHAR(obj,i)       returns the i'th character of obj, 0-based
//    STB_TEXTEDIT_NEWLINE              the character returned by _GETCHAR() we recognize
//                                        as manually wordwrapping for end-of-line positioning
//
//    STB_TEXTEDIT_DELETECHARS(obj,i,n)      delete n characters starting at i
//    STB_TEXTEDIT_INSERTCHARS(obj,i,c*,n)   insert n characters at i (pointed to by STB_TEXTEDIT_CHARTYPE*)
//
//    STB_TEXTEDIT_K_SHIFT       a power of two that is or'd in to a keyboard input to represent the shift key
//
//    STB_TEXTEDIT_K_LEFT        keyboard input to move cursor left
//    STB_TEXTEDIT_K_RIGHT       keyboard input to move cursor right
//    STB_TEXTEDIT_K_UP          keyboard input to move cursor up
//    STB_TEXTEDIT_K_DOWN        keyboard input to move cursor down
//    STB_TEXTEDIT_K_LINESTART   keyboard input to move cursor to start of line  // e.g. HOME
//    STB_TEXTEDIT_K_LINEEND     keyboard input to move cursor to end of line    // e.g. END
//    STB_TEXTEDIT_K_TEXTSTART   keyboard input to move cursor to start of text  // e.g. ctrl-HOME
//    STB_TEXTEDIT_K_TEXTEND     keyboard input to move cursor to end of text    // e.g. ctrl-END
//    STB_TEXTEDIT_K_DELETE      keyboard input to delete selection or character under cursor
//    STB_TEXTEDIT_K_BACKSPACE   keyboard input to delete selection or character left of cursor
//    STB_TEXTEDIT_K_UNDO        keyboard input to perform undo
//    STB_TEXTEDIT_K_REDO        keyboard input to perform redo
//
// Optional:
//    STB_TEXTEDIT_K_INSERT              keyboard input to toggle insert mode
//    STB_TEXTEDIT_IS_SPACE(ch)          true if character is whitespace (e.g. 'isspace'),
//                                          required for default WORDLEFT/WORDRIGHT handlers
//    STB_TEXTEDIT_MOVEWORDLEFT(obj,i)   custom handler for WORDLEFT, returns index to move cursor to
//    STB_TEXTEDIT_MOVEWORDRIGHT(obj,i)  custom handler for WORDRIGHT, returns index to move cursor to
//    STB_TEXTEDIT_K_WORDLEFT            keyboard input to move cursor left one word // e.g. ctrl-LEFT
//    STB_TEXTEDIT_K_WORDRIGHT           keyboard input to move cursor right one word // e.g. ctrl-RIGHT
//    STB_TEXTEDIT_K_LINESTART2          secondary keyboard input to move cursor to start of line
//    STB_TEXTEDIT_K_LINEEND2            secondary keyboard input to move cursor to end of line
//    STB_TEXTEDIT_K_TEXTSTART2          secondary keyboard input to move cursor to start of text
//    STB_TEXTEDIT_K_TEXTEND2            secondary keyboard input to move cursor to end of text
//
// Todo:
//    STB_TEXTEDIT_K_PGUP        keyboard input to move cursor up a page
//    STB_TEXTEDIT_K_PGDOWN      keyboard input to move cursor down a page
//
// Keyboard input must be encoded as a single integer value; e.g. a character code
// and some bitflags that represent shift states. to simplify the interface, SHIFT must
// be a bitflag, so we can test the shifted state of cursor movements to allow selection,
// i.e. (STB_TEXTED_K_RIGHT|STB_TEXTEDIT_K_SHIFT) should be shifted right-arrow.
//
// You can encode other things, such as CONTROL or ALT, in additional bits, and
// then test for their presence in e.g. STB_TEXTEDIT_K_WORDLEFT. For example,
// my Windows implementations add an additional CONTROL bit, and an additional KEYDOWN
// bit. Then all of the STB_TEXTEDIT_K_ values bitwise-or in the KEYDOWN bit,
// and I pass both WM_KEYDOWN and WM_CHAR events to the "key" function in the
// API below. The control keys will only match WM_KEYDOWN events because of the
// keydown bit I add, and STB_TEXTEDIT_KEYTOTEXT only tests for the KEYDOWN
// bit so it only decodes WM_CHAR events.
//
// STB_TEXTEDIT_LAYOUTROW returns information about the shape of one displayed
// row of characters assuming they start on the i'th character--the width and
// the height and the number of characters consumed. This allows this library
// to traverse the entire layout incrementally. You need to compute word-wrapping
// here.
//
// Each textfield keeps its own insert mode state, which is not how normal
// applications work. To keep an app-wide insert mode, update/copy the
// "insert_mode" field of STB_TexteditState before/after calling API functions.
//
// API
//
//    void stb_textedit_initialize_state(STB_TexteditState *state, int is_single_line)
//
//    void stb_textedit_click(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)
//    void stb_textedit_drag(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)
//    int  stb_textedit_cut(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
//    int  stb_textedit_paste(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_CHARTYPE *text, int len)
//    void stb_textedit_key(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXEDIT_KEYTYPE key)
//
//    Each of these functions potentially updates the string and updates the
//    state.
//
//      initialize_state:
//          set the textedit state to a known good default state when initially
//          constructing the textedit.
//
//      click:
//          call this with the mouse x,y on a mouse down; it will update the cursor
//          and reset the selection start/end to the cursor point. the x,y must
//          be relative to the text widget, with (0,0) being the top left.
//     
//      drag:
//          call this with the mouse x,y on a mouse drag/up; it will update the
//          cursor and the selection end point
//     
//      cut:
//          call this to delete the current selection; returns true if there was
//          one. you should FIRST copy the current selection to the system paste buffer.
//          (To copy, just copy the current selection out of the string yourself.)
//     
//      paste:
//          call this to paste text at the current cursor point or over the current
//          selection if there is one.
//     
//      key:
//          call this for keyboard inputs sent to the textfield. you can use it
//          for "key down" events or for "translated" key events. if you need to
//          do both (as in Win32), or distinguish Unicode characters from control
//          inputs, set a high bit to distinguish the two; then you can define the
//          various definitions like STB_TEXTEDIT_K_LEFT have the is-key-event bit
//          set, and make STB_TEXTEDIT_KEYTOCHAR check that the is-key-event bit is
//          clear. STB_TEXTEDIT_KEYTYPE defaults to int, but you can #define it to
//          anything other type you wante before including.
//
//     
//   When rendering, you can read the cursor position and selection state from
//   the STB_TexteditState.
//
//
// Notes:
//
// This is designed to be usable in IMGUI, so it allows for the possibility of
// running in an IMGUI that has NOT cached the multi-line layout. For this
// reason, it provides an interface that is compatible with computing the
// layout incrementally--we try to make sure we make as few passes through
// as possible. (For example, to locate the mouse pointer in the text, we
// could define functions that return the X and Y positions of characters
// and binary search Y and then X, but if we're doing dynamic layout this
// will run the layout algorithm many times, so instead we manually search
// forward in one pass. Similar logic applies to e.g. up-arrow and
// down-arrow movement.)
//
// If it's run in a widget that *has* cached the layout, then this is less
// efficient, but it's not horrible on modern computers. But you wouldn't
// want to edit million-line files with it.


////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////
////   Header-file mode
////
////

#ifndef INCLUDE_STB_TEXTEDIT_H
#define INCLUDE_STB_TEXTEDIT_H

////////////////////////////////////////////////////////////////////////
//
//     STB_TexteditState
//
// Definition of STB_TexteditState which you should store
// per-textfield; it includes cursor position, selection state,
// and undo state.
//

#ifndef STB_TEXTEDIT_UNDOSTATECOUNT
#define STB_TEXTEDIT_UNDOSTATECOUNT   99
#endif
#ifndef STB_TEXTEDIT_UNDOCHARCOUNT
#define STB_TEXTEDIT_UNDOCHARCOUNT   999
#endif
#ifndef STB_TEXTEDIT_CHARTYPE
#define STB_TEXTEDIT_CHARTYPE        int
#endif
#ifndef STB_TEXTEDIT_POSITIONTYPE
#define STB_TEXTEDIT_POSITIONTYPE    int
#endif

typedef struct
{
   // private data
   STB_TEXTEDIT_POSITIONTYPE  where;
   STB_TEXTEDIT_POSITIONTYPE  insert_length;
   STB_TEXTEDIT_POSITIONTYPE  delete_length;
   int                        char_storage;
} StbUndoRecord;

typedef struct
{
   // private data
   StbUndoRecord          undo_rec [STB_TEXTEDIT_UNDOSTATECOUNT];
   STB_TEXTEDIT_CHARTYPE  undo_char[STB_TEXTEDIT_UNDOCHARCOUNT];
   short undo_point, redo_point;
   int undo_char_point, redo_char_point;
} StbUndoState;

typedef struct
{
   /////////////////////
   //
   // public data
   //

   int cursor;
   // position of the text cursor within the string

   int select_start;          // selection start point
   int select_end;
   // selection start and end point in characters; if equal, no selection.
   // note that start may be less than or greater than end (e.g. when
   // dragging the mouse, start is where the initial click was, and you
   // can drag in either direction)

   unsigned char insert_mode;
   // each textfield keeps its own insert mode state. to keep an app-wide
   // insert mode, copy this value in/out of the app state

   /////////////////////
   //
   // private data
   //
   unsigned char cursor_at_end_of_line; // not implemented yet
   unsigned char initialized;
   unsigned char has_preferred_x;
   unsigned char single_line;
   unsigned char padding1, padding2, padding3;
   float preferred_x; // this determines where the cursor up/down tries to seek to along x
   StbUndoState undostate;
} STB_TexteditState;


////////////////////////////////////////////////////////////////////////
//
//     StbTexteditRow
//
// Result of layout query, used by stb_textedit to determine where
// the text in each row is.

// result of layout query
typedef struct
{
   float x0,x1;             // starting x location, end x location (allows for align=right, etc)
   float baseline_y_delta;  // position of baseline relative to previous row's baseline
   float ymin,ymax;         // height of row above and below baseline
   int num_chars;
} StbTexteditRow;
#endif //INCLUDE_STB_TEXTEDIT_H


////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////
////   Implementation mode
////
////


// implementation isn't include-guarded, since it might have indirectly
// included just the "header" portion
#ifdef STB_TEXTEDIT_IMPLEMENTATION

#ifndef STB_TEXTEDIT_memmove
#include <string.h>
#define STB_TEXTEDIT_memmove memmove
#endif


/////////////////////////////////////////////////////////////////////////////
//
//      Mouse input handling
//

// traverse the layout to locate the nearest character to a display position
static int stb_text_locate_coord(STB_TEXTEDIT_STRING *str, float x, float y)
{
   StbTexteditRow r;
   int n = STB_TEXTEDIT_STRINGLEN(str);
   float base_y = 0, prev_x;
   int i=0, k;

   r.x0 = r.x1 = 0;
   r.ymin = r.ymax = 0;
   r.num_chars = 0;

   // search rows to find one that straddles 'y'
   while (i < n) {
      STB_TEXTEDIT_LAYOUTROW(&r, str, i);
      if (r.num_chars <= 0)
         return n;

      if (i==0 && y < base_y + r.ymin)
         return 0;

      if (y < base_y + r.ymax)
         break;

      i += r.num_chars;
      base_y += r.baseline_y_delta;
   }

   // below all text, return 'after' last character
   if (i >= n)
      return n;

   // check if it's before the beginning of the line
   if (x < r.x0)
      return i;

   // check if it's before the end of the line
   if (x < r.x1) {
      // search characters in row for one that straddles 'x'
      prev_x = r.x0;
      for (k=0; k < r.num_chars; ++k) {
         float w = STB_TEXTEDIT_GETWIDTH(str, i, k);
         if (x < prev_x+w) {
            if (x < prev_x+w/2)
               return k+i;
            else
               return k+i+1;
         }
         prev_x += w;
      }
      // shouldn't happen, but if it does, fall through to end-of-line case
   }

   // if the last character is a newline, return that. otherwise return 'after' the last character
   if (STB_TEXTEDIT_GETCHAR(str, i+r.num_chars-1) == STB_TEXTEDIT_NEWLINE)
      return i+r.num_chars-1;
   else
      return i+r.num_chars;
}

// API click: on mouse down, move the cursor to the clicked location, and reset the selection
static void stb_textedit_click(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)
{
   // In single-line mode, just always make y = 0. This lets the drag keep working if the mouse
   // goes off the top or bottom of the text
   if( state->single_line )
   {
      StbTexteditRow r;
      STB_TEXTEDIT_LAYOUTROW(&r, str, 0);
      y = r.ymin;
   }

   state->cursor = stb_text_locate_coord(str, x, y);
   state->select_start = state->cursor;
   state->select_end = state->cursor;
   state->has_preferred_x = 0;
}

// API drag: on mouse drag, move the cursor and selection endpoint to the clicked location
static void stb_textedit_drag(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)
{
   int p = 0;

   // In single-line mode, just always make y = 0. This lets the drag keep working if the mouse
   // goes off the top or bottom of the text
   if( state->single_line )
   {
      StbTexteditRow r;
      STB_TEXTEDIT_LAYOUTROW(&r, str, 0);
      y = r.ymin;
   }

   if (state->select_start == state->select_end)
      state->select_start = state->cursor;

   p = stb_text_locate_coord(str, x, y);
   state->cursor = state->select_end = p;
}

/////////////////////////////////////////////////////////////////////////////
//
//      Keyboard input handling
//

// forward declarations
static void stb_text_undo(STB_TEXTEDIT_STRING *str, STB_TexteditState *state);
static void stb_text_redo(STB_TEXTEDIT_STRING *str, STB_TexteditState *state);
static void stb_text_makeundo_delete(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int length);
static void stb_text_makeundo_insert(STB_TexteditState *state, int where, int length);
static void stb_text_makeundo_replace(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int old_length, int new_length);

typedef struct
{
   float x,y;    // position of n'th character
   float height; // height of line
   int first_char, length; // first char of row, and length
   int prev_first;  // first char of previous row
} StbFindState;

// find the x/y location of a character, and remember info about the previous row in
// case we get a move-up event (for page up, we'll have to rescan)
static void stb_textedit_find_charpos(StbFindState *find, STB_TEXTEDIT_STRING *str, int n, int single_line)
{
   StbTexteditRow r;
   int prev_start = 0;
   int z = STB_TEXTEDIT_STRINGLEN(str);
   int i=0, first;

   if (n == z) {
      // if it's at the end, then find the last line -- simpler than trying to
      // explicitly handle this case in the regular code
      if (single_line) {
         STB_TEXTEDIT_LAYOUTROW(&r, str, 0);
         find->y = 0;
         find->first_char = 0;
         find->length = z;
         find->height = r.ymax - r.ymin;
         find->x = r.x1;
      } else {
         find->y = 0;
         find->x = 0;
         find->height = 1;
         while (i < z) {
            STB_TEXTEDIT_LAYOUTROW(&r, str, i);
            prev_start = i;
            i += r.num_chars;
         }
         find->first_char = i;
         find->length = 0;
         find->prev_first = prev_start;
      }
      return;
   }

   // search rows to find the one that straddles character n
   find->y = 0;

   for(;;) {
      STB_TEXTEDIT_LAYOUTROW(&r, str, i);
      if (n < i + r.num_chars)
         break;
      prev_start = i;
      i += r.num_chars;
      find->y += r.baseline_y_delta;
   }

   find->first_char = first = i;
   find->length = r.num_chars;
   find->height = r.ymax - r.ymin;
   find->prev_first = prev_start;

   // now scan to find xpos
   find->x = r.x0;
   for (i=0; first+i < n; ++i)
      find->x += STB_TEXTEDIT_GETWIDTH(str, first, i);
}

#define STB_TEXT_HAS_SELECTION(s)   ((s)->select_start != (s)->select_end)

// make the selection/cursor state valid if client altered the string
static void stb_textedit_clamp(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
{
   int n = STB_TEXTEDIT_STRINGLEN(str);
   if (STB_TEXT_HAS_SELECTION(state)) {
      if (state->select_start > n) state->select_start = n;
      if (state->select_end   > n) state->select_end = n;
      // if clamping forced them to be equal, move the cursor to match
      if (state->select_start == state->select_end)
         state->cursor = state->select_start;
   }
   if (state->cursor > n) state->cursor = n;
}

// delete characters while updating undo
static void stb_textedit_delete(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int len)
{
   stb_text_makeundo_delete(str, state, where, len);
   STB_TEXTEDIT_DELETECHARS(str, where, len);
   state->has_preferred_x = 0;
}

// delete the section
static void stb_textedit_delete_selection(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
{
   stb_textedit_clamp(str, state);
   if (STB_TEXT_HAS_SELECTION(state)) {
      if (state->select_start < state->select_end) {
         stb_textedit_delete(str, state, state->select_start, state->select_end - state->select_start);
         state->select_end = state->cursor = state->select_start;
      } else {
         stb_textedit_delete(str, state, state->select_end, state->select_start - state->select_end);
         state->select_start = state->cursor = state->select_end;
      }
      state->has_preferred_x = 0;
   }
}

// canoncialize the selection so start <= end
static void stb_textedit_sortselection(STB_TexteditState *state)
{
   if (state->select_end < state->select_start) {
      int temp = state->select_end;
      state->select_end = state->select_start;
      state->select_start = temp;
   }
}

// move cursor to first character of selection
static void stb_textedit_move_to_first(STB_TexteditState *state)
{
   if (STB_TEXT_HAS_SELECTION(state)) {
      stb_textedit_sortselection(state);
      state->cursor = state->select_start;
      state->select_end = state->select_start;
      state->has_preferred_x = 0;
   }
}

// move cursor to last character of selection
static void stb_textedit_move_to_last(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
{
   if (STB_TEXT_HAS_SELECTION(state)) {
      stb_textedit_sortselection(state);
      stb_textedit_clamp(str, state);
      state->cursor = state->select_end;
      state->select_start = state->select_end;
      state->has_preferred_x = 0;
   }
}

#ifdef STB_TEXTEDIT_IS_SPACE
static int is_word_boundary( STB_TEXTEDIT_STRING *str, int idx )
{
   return idx > 0 ? (STB_TEXTEDIT_IS_SPACE( STB_TEXTEDIT_GETCHAR(str,idx-1) ) && !STB_TEXTEDIT_IS_SPACE( STB_TEXTEDIT_GETCHAR(str, idx) ) ) : 1;
}

#ifndef STB_TEXTEDIT_MOVEWORDLEFT
static int stb_textedit_move_to_word_previous( STB_TEXTEDIT_STRING *str, int c )
{
   --c; // always move at least one character
   while( c >= 0 && !is_word_boundary( str, c ) )
      --c;

   if( c < 0 )
      c = 0;

   return c;
}
#define STB_TEXTEDIT_MOVEWORDLEFT stb_textedit_move_to_word_previous
#endif

#ifndef STB_TEXTEDIT_MOVEWORDRIGHT
static int stb_textedit_move_to_word_next( STB_TEXTEDIT_STRING *str, int c )
{
   const int len = STB_TEXTEDIT_STRINGLEN(str);
   ++c; // always move at least one character
   while( c < len && !is_word_boundary( str, c ) )
      ++c;

   if( c > len )
      c = len;

   return c;
}
#define STB_TEXTEDIT_MOVEWORDRIGHT stb_textedit_move_to_word_next
#endif

#endif

// update selection and cursor to match each other
static void stb_textedit_prep_selection_at_cursor(STB_TexteditState *state)
{
   if (!STB_TEXT_HAS_SELECTION(state))
      state->select_start = state->select_end = state->cursor;
   else
      state->cursor = state->select_end;
}

// API cut: delete selection
static int stb_textedit_cut(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
{
   if (STB_TEXT_HAS_SELECTION(state)) {
      stb_textedit_delete_selection(str,state); // implicitly clamps
      state->has_preferred_x = 0;
      return 1;
   }
   return 0;
}

// API paste: replace existing selection with passed-in text
static int stb_textedit_paste_internal(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_CHARTYPE *text, int len)
{
   // if there's a selection, the paste should delete it
   stb_textedit_clamp(str, state);
   stb_textedit_delete_selection(str,state);
   // try to insert the characters
   if (STB_TEXTEDIT_INSERTCHARS(str, state->cursor, text, len)) {
      stb_text_makeundo_insert(state, state->cursor, len);
      state->cursor += len;
      state->has_preferred_x = 0;
      return 1;
   }
   // remove the undo since we didn't actually insert the characters
   if (state->undostate.undo_point)
      --state->undostate.undo_point;
   return 0;
}

#ifndef STB_TEXTEDIT_KEYTYPE
#define STB_TEXTEDIT_KEYTYPE int
#endif

// API key: process a keyboard input
static void stb_textedit_key(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_KEYTYPE key)
{
retry:
   switch (key) {
      default: {
         int c = STB_TEXTEDIT_KEYTOTEXT(key);
         if (c > 0) {
            STB_TEXTEDIT_CHARTYPE ch = (STB_TEXTEDIT_CHARTYPE) c;

            // can't add newline in single-line mode
            if (c == '\n' && state->single_line)
               break;

            if (state->insert_mode && !STB_TEXT_HAS_SELECTION(state) && state->cursor < STB_TEXTEDIT_STRINGLEN(str)) {
               stb_text_makeundo_replace(str, state, state->cursor, 1, 1);
               STB_TEXTEDIT_DELETECHARS(str, state->cursor, 1);
               if (STB_TEXTEDIT_INSERTCHARS(str, state->cursor, &ch, 1)) {
                  ++state->cursor;
                  state->has_preferred_x = 0;
               }
            } else {
               stb_textedit_delete_selection(str,state); // implicitly clamps
               if (STB_TEXTEDIT_INSERTCHARS(str, state->cursor, &ch, 1)) {
                  stb_text_makeundo_insert(state, state->cursor, 1);
                  ++state->cursor;
                  state->has_preferred_x = 0;
               }
            }
         }
         break;
      }

#ifdef STB_TEXTEDIT_K_INSERT
      case STB_TEXTEDIT_K_INSERT:
         state->insert_mode = !state->insert_mode;
         break;
#endif
         
      case STB_TEXTEDIT_K_UNDO:
         stb_text_undo(str, state);
         state->has_preferred_x = 0;
         break;

      case STB_TEXTEDIT_K_REDO:
         stb_text_redo(str, state);
         state->has_preferred_x = 0;
         break;

      case STB_TEXTEDIT_K_LEFT:
         // if currently there's a selection, move cursor to start of selection
         if (STB_TEXT_HAS_SELECTION(state))
            stb_textedit_move_to_first(state);
         else 
            if (state->cursor > 0)
               --state->cursor;
         state->has_preferred_x = 0;
         break;

      case STB_TEXTEDIT_K_RIGHT:
         // if currently there's a selection, move cursor to end of selection
         if (STB_TEXT_HAS_SELECTION(state))
            stb_textedit_move_to_last(str, state);
         else
            ++state->cursor;
         stb_textedit_clamp(str, state);
         state->has_preferred_x = 0;
         break;

      case STB_TEXTEDIT_K_LEFT | STB_TEXTEDIT_K_SHIFT:
         stb_textedit_clamp(str, state);
         stb_textedit_prep_selection_at_cursor(state);
         // move selection left
         if (state->select_end > 0)
            --state->select_end;
         state->cursor = state->select_end;
         state->has_preferred_x = 0;
         break;

#ifdef STB_TEXTEDIT_MOVEWORDLEFT
      case STB_TEXTEDIT_K_WORDLEFT:
         if (STB_TEXT_HAS_SELECTION(state))
            stb_textedit_move_to_first(state);
         else {
            state->cursor = STB_TEXTEDIT_MOVEWORDLEFT(str, state->cursor);
            stb_textedit_clamp( str, state );
         }
         break;

      case STB_TEXTEDIT_K_WORDLEFT | STB_TEXTEDIT_K_SHIFT:
         if( !STB_TEXT_HAS_SELECTION( state ) )
            stb_textedit_prep_selection_at_cursor(state);

         state->cursor = STB_TEXTEDIT_MOVEWORDLEFT(str, state->cursor);
         state->select_end = state->cursor;

         stb_textedit_clamp( str, state );
         break;
#endif

#ifdef STB_TEXTEDIT_MOVEWORDRIGHT
      case STB_TEXTEDIT_K_WORDRIGHT:
         if (STB_TEXT_HAS_SELECTION(state)) 
            stb_textedit_move_to_last(str, state);
         else {
            state->cursor = STB_TEXTEDIT_MOVEWORDRIGHT(str, state->cursor);
            stb_textedit_clamp( str, state );
         }
         break;

      case STB_TEXTEDIT_K_WORDRIGHT | STB_TEXTEDIT_K_SHIFT:
         if( !STB_TEXT_HAS_SELECTION( state ) )
            stb_textedit_prep_selection_at_cursor(state);

         state->cursor = STB_TEXTEDIT_MOVEWORDRIGHT(str, state->cursor);
         state->select_end = state->cursor;

         stb_textedit_clamp( str, state );
         break;
#endif

      case STB_TEXTEDIT_K_RIGHT | STB_TEXTEDIT_K_SHIFT:
         stb_textedit_prep_selection_at_cursor(state);
         // move selection right
         ++state->select_end;
         stb_textedit_clamp(str, state);
         state->cursor = state->select_end;
         state->has_preferred_x = 0;
         break;

      case STB_TEXTEDIT_K_DOWN:
      case STB_TEXTEDIT_K_DOWN | STB_TEXTEDIT_K_SHIFT: {
         StbFindState find;
         StbTexteditRow row;
         int i, sel = (key & STB_TEXTEDIT_K_SHIFT) != 0;

         if (state->single_line) {
            // on windows, up&down in single-line behave like left&right
            key = STB_TEXTEDIT_K_RIGHT | (key & STB_TEXTEDIT_K_SHIFT);
            goto retry;
         }

         if (sel)
            stb_textedit_prep_selection_at_cursor(state);
         else if (STB_TEXT_HAS_SELECTION(state))
            stb_textedit_move_to_last(str,state);

         // compute current position of cursor point
         stb_textedit_clamp(str, state);
         stb_textedit_find_charpos(&find, str, state->cursor, state->single_line);

         // now find character position down a row
         if (find.length) {
            float goal_x = state->has_preferred_x ? state->preferred_x : find.x;
            float x;
            int start = find.first_char + find.length;
            state->cursor = start;
            STB_TEXTEDIT_LAYOUTROW(&row, str, state->cursor);
            x = row.x0;
            for (i=0; i < row.num_chars; ++i) {
               float dx = STB_TEXTEDIT_GETWIDTH(str, start, i);
               #ifdef STB_TEXTEDIT_GETWIDTH_NEWLINE
               if (dx == STB_TEXTEDIT_GETWIDTH_NEWLINE)
                  break;
               #endif
               x += dx;
               if (x > goal_x)
                  break;
               ++state->cursor;
            }
            stb_textedit_clamp(str, state);

            state->has_preferred_x = 1;
            state->preferred_x = goal_x;

            if (sel)
               state->select_end = state->cursor;
         }
         break;
      }
         
      case STB_TEXTEDIT_K_UP:
      case STB_TEXTEDIT_K_UP | STB_TEXTEDIT_K_SHIFT: {
         StbFindState find;
         StbTexteditRow row;
         int i, sel = (key & STB_TEXTEDIT_K_SHIFT) != 0;

         if (state->single_line) {
            // on windows, up&down become left&right
            key = STB_TEXTEDIT_K_LEFT | (key & STB_TEXTEDIT_K_SHIFT);
            goto retry;
         }

         if (sel)
            stb_textedit_prep_selection_at_cursor(state);
         else if (STB_TEXT_HAS_SELECTION(state))
            stb_textedit_move_to_first(state);

         // compute current position of cursor point
         stb_textedit_clamp(str, state);
         stb_textedit_find_charpos(&find, str, state->cursor, state->single_line);

         // can only go up if there's a previous row
         if (find.prev_first != find.first_char) {
            // now find character position up a row
            float goal_x = state->has_preferred_x ? state->preferred_x : find.x;
            float x;
            state->cursor = find.prev_first;
            STB_TEXTEDIT_LAYOUTROW(&row, str, state->cursor);
            x = row.x0;
            for (i=0; i < row.num_chars; ++i) {
               float dx = STB_TEXTEDIT_GETWIDTH(str, find.prev_first, i);
               #ifdef STB_TEXTEDIT_GETWIDTH_NEWLINE
               if (dx == STB_TEXTEDIT_GETWIDTH_NEWLINE)
                  break;
               #endif
               x += dx;
               if (x > goal_x)
                  break;
               ++state->cursor;
            }
            stb_textedit_clamp(str, state);

            state->has_preferred_x = 1;
            state->preferred_x = goal_x;

            if (sel)
               state->select_end = state->cursor;
         }
         break;
      }

      case STB_TEXTEDIT_K_DELETE:
      case STB_TEXTEDIT_K_DELETE | STB_TEXTEDIT_K_SHIFT:
         if (STB_TEXT_HAS_SELECTION(state))
            stb_textedit_delete_selection(str, state);
         else {
            int n = STB_TEXTEDIT_STRINGLEN(str);
            if (state->cursor < n)
               stb_textedit_delete(str, state, state->cursor, 1);
         }
         state->has_preferred_x = 0;
         break;

      case STB_TEXTEDIT_K_BACKSPACE:
      case STB_TEXTEDIT_K_BACKSPACE | STB_TEXTEDIT_K_SHIFT:
         if (STB_TEXT_HAS_SELECTION(state))
            stb_textedit_delete_selection(str, state);
         else {
            stb_textedit_clamp(str, state);
            if (state->cursor > 0) {
               stb_textedit_delete(str, state, state->cursor-1, 1);
               --state->cursor;
            }
         }
         state->has_preferred_x = 0;
         break;
         
#ifdef STB_TEXTEDIT_K_TEXTSTART2
      case STB_TEXTEDIT_K_TEXTSTART2:
#endif
      case STB_TEXTEDIT_K_TEXTSTART:
         state->cursor = state->select_start = state->select_end = 0;
         state->has_preferred_x = 0;
         break;

#ifdef STB_TEXTEDIT_K_TEXTEND2
      case STB_TEXTEDIT_K_TEXTEND2:
#endif
      case STB_TEXTEDIT_K_TEXTEND:
         state->cursor = STB_TEXTEDIT_STRINGLEN(str);
         state->select_start = state->select_end = 0;
         state->has_preferred_x = 0;
         break;
        
#ifdef STB_TEXTEDIT_K_TEXTSTART2
      case STB_TEXTEDIT_K_TEXTSTART2 | STB_TEXTEDIT_K_SHIFT:
#endif
      case STB_TEXTEDIT_K_TEXTSTART | STB_TEXTEDIT_K_SHIFT:
         stb_textedit_prep_selection_at_cursor(state);
         state->cursor = state->select_end = 0;
         state->has_preferred_x = 0;
         break;

#ifdef STB_TEXTEDIT_K_TEXTEND2
      case STB_TEXTEDIT_K_TEXTEND2 | STB_TEXTEDIT_K_SHIFT:
#endif
      case STB_TEXTEDIT_K_TEXTEND | STB_TEXTEDIT_K_SHIFT:
         stb_textedit_prep_selection_at_cursor(state);
         state->cursor = state->select_end = STB_TEXTEDIT_STRINGLEN(str);
         state->has_preferred_x = 0;
         break;


#ifdef STB_TEXTEDIT_K_LINESTART2
      case STB_TEXTEDIT_K_LINESTART2:
#endif
      case STB_TEXTEDIT_K_LINESTART:
         stb_textedit_clamp(str, state);
         stb_textedit_move_to_first(state);
         if (state->single_line)
            state->cursor = 0;
         else while (state->cursor > 0 && STB_TEXTEDIT_GETCHAR(str, state->cursor-1) != STB_TEXTEDIT_NEWLINE)
            --state->cursor;
         state->has_preferred_x = 0;
         break;

#ifdef STB_TEXTEDIT_K_LINEEND2
      case STB_TEXTEDIT_K_LINEEND2:
#endif
      case STB_TEXTEDIT_K_LINEEND: {
         int n = STB_TEXTEDIT_STRINGLEN(str);
         stb_textedit_clamp(str, state);
         stb_textedit_move_to_first(state);
         if (state->single_line)
             state->cursor = n;
         else while (state->cursor < n && STB_TEXTEDIT_GETCHAR(str, state->cursor) != STB_TEXTEDIT_NEWLINE)
             ++state->cursor;
         state->has_preferred_x = 0;
         break;
      }

#ifdef STB_TEXTEDIT_K_LINESTART2
      case STB_TEXTEDIT_K_LINESTART2 | STB_TEXTEDIT_K_SHIFT:
#endif
      case STB_TEXTEDIT_K_LINESTART | STB_TEXTEDIT_K_SHIFT:
         stb_textedit_clamp(str, state);
         stb_textedit_prep_selection_at_cursor(state);
         if (state->single_line)
            state->cursor = 0;
         else while (state->cursor > 0 && STB_TEXTEDIT_GETCHAR(str, state->cursor-1) != STB_TEXTEDIT_NEWLINE)
            --state->cursor;
         state->select_end = state->cursor;
         state->has_preferred_x = 0;
         break;

#ifdef STB_TEXTEDIT_K_LINEEND2
      case STB_TEXTEDIT_K_LINEEND2 | STB_TEXTEDIT_K_SHIFT:
#endif
      case STB_TEXTEDIT_K_LINEEND | STB_TEXTEDIT_K_SHIFT: {
         int n = STB_TEXTEDIT_STRINGLEN(str);
         stb_textedit_clamp(str, state);
         stb_textedit_prep_selection_at_cursor(state);
         if (state->single_line)
             state->cursor = n;
         else while (state->cursor < n && STB_TEXTEDIT_GETCHAR(str, state->cursor) != STB_TEXTEDIT_NEWLINE)
            ++state->cursor;
         state->select_end = state->cursor;
         state->has_preferred_x = 0;
         break;
      }

// @TODO:
//    STB_TEXTEDIT_K_PGUP      - move cursor up a page
//    STB_TEXTEDIT_K_PGDOWN    - move cursor down a page
   }
}

/////////////////////////////////////////////////////////////////////////////
//
//      Undo processing
//
// @OPTIMIZE: the undo/redo buffer should be circular

static void stb_textedit_flush_redo(StbUndoState *state)
{
   state->redo_point = STB_TEXTEDIT_UNDOSTATECOUNT;
   state->redo_char_point = STB_TEXTEDIT_UNDOCHARCOUNT;
}

// discard the oldest entry in the undo list
static void stb_textedit_discard_undo(StbUndoState *state)
{
   if (state->undo_point > 0) {
      // if the 0th undo state has characters, clean those up
      if (state->undo_rec[0].char_storage >= 0) {
         int n = state->undo_rec[0].insert_length, i;
         // delete n characters from all other records
         state->undo_char_point -= n;
         STB_TEXTEDIT_memmove(state->undo_char, state->undo_char + n, (size_t) (state->undo_char_point*sizeof(STB_TEXTEDIT_CHARTYPE)));
         for (i=0; i < state->undo_point; ++i)
            if (state->undo_rec[i].char_storage >= 0)
               state->undo_rec[i].char_storage -= n; // @OPTIMIZE: get rid of char_storage and infer it
      }
      --state->undo_point;
      STB_TEXTEDIT_memmove(state->undo_rec, state->undo_rec+1, (size_t) (state->undo_point*sizeof(state->undo_rec[0])));
   }
}

// discard the oldest entry in the redo list--it's bad if this
// ever happens, but because undo & redo have to store the actual
// characters in different cases, the redo character buffer can
// fill up even though the undo buffer didn't
static void stb_textedit_discard_redo(StbUndoState *state)
{
   int k = STB_TEXTEDIT_UNDOSTATECOUNT-1;

   if (state->redo_point <= k) {
      // if the k'th undo state has characters, clean those up
      if (state->undo_rec[k].char_storage >= 0) {
         int n = state->undo_rec[k].insert_length, i;
         // move the remaining redo character data to the end of the buffer
         state->redo_char_point += n;
         STB_TEXTEDIT_memmove(state->undo_char + state->redo_char_point, state->undo_char + state->redo_char_point-n, (size_t) ((STB_TEXTEDIT_UNDOCHARCOUNT - state->redo_char_point)*sizeof(STB_TEXTEDIT_CHARTYPE)));
         // adjust the position of all the other records to account for above memmove
         for (i=state->redo_point; i < k; ++i)
            if (state->undo_rec[i].char_storage >= 0)
               state->undo_rec[i].char_storage += n;
      }
      // now move all the redo records towards the end of the buffer; the first one is at 'redo_point'
      // {DEAR IMGUI]
      size_t move_size = (size_t)((STB_TEXTEDIT_UNDOSTATECOUNT - state->redo_point - 1) * sizeof(state->undo_rec[0]));
      const char* buf_begin = (char*)state->undo_rec; (void)buf_begin;
      const char* buf_end   = (char*)state->undo_rec + sizeof(state->undo_rec); (void)buf_end;
      IM_ASSERT(((char*)(state->undo_rec + state->redo_point)) >= buf_begin);
      IM_ASSERT(((char*)(state->undo_rec + state->redo_point + 1) + move_size) <= buf_end);
      STB_TEXTEDIT_memmove(state->undo_rec + state->redo_point+1, state->undo_rec + state->redo_point, move_size);

      // now move redo_point to point to the new one
      ++state->redo_point;
   }
}

static StbUndoRecord *stb_text_create_undo_record(StbUndoState *state, int numchars)
{
   // any time we create a new undo record, we discard redo
   stb_textedit_flush_redo(state);

   // if we have no free records, we have to make room, by sliding the
   // existing records down
   if (state->undo_point == STB_TEXTEDIT_UNDOSTATECOUNT)
      stb_textedit_discard_undo(state);

   // if the characters to store won't possibly fit in the buffer, we can't undo
   if (numchars > STB_TEXTEDIT_UNDOCHARCOUNT) {
      state->undo_point = 0;
      state->undo_char_point = 0;
      return NULL;
   }

   // if we don't have enough free characters in the buffer, we have to make room
   while (state->undo_char_point + numchars > STB_TEXTEDIT_UNDOCHARCOUNT)
      stb_textedit_discard_undo(state);

   return &state->undo_rec[state->undo_point++];
}

static STB_TEXTEDIT_CHARTYPE *stb_text_createundo(StbUndoState *state, int pos, int insert_len, int delete_len)
{
   StbUndoRecord *r = stb_text_create_undo_record(state, insert_len);
   if (r == NULL)
      return NULL;

   r->where = pos;
   r->insert_length = (STB_TEXTEDIT_POSITIONTYPE) insert_len;
   r->delete_length = (STB_TEXTEDIT_POSITIONTYPE) delete_len;

   if (insert_len == 0) {
      r->char_storage = -1;
      return NULL;
   } else {
      r->char_storage = state->undo_char_point;
      state->undo_char_point += insert_len;
      return &state->undo_char[r->char_storage];
   }
}

static void stb_text_undo(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
{
   StbUndoState *s = &state->undostate;
   StbUndoRecord u, *r;
   if (s->undo_point == 0)
      return;

   // we need to do two things: apply the undo record, and create a redo record
   u = s->undo_rec[s->undo_point-1];
   r = &s->undo_rec[s->redo_point-1];
   r->char_storage = -1;

   r->insert_length = u.delete_length;
   r->delete_length = u.insert_length;
   r->where = u.where;

   if (u.delete_length) {
      // if the undo record says to delete characters, then the redo record will
      // need to re-insert the characters that get deleted, so we need to store
      // them.

      // there are three cases:
      //    there's enough room to store the characters
      //    characters stored for *redoing* don't leave room for redo
      //    characters stored for *undoing* don't leave room for redo
      // if the last is true, we have to bail

      if (s->undo_char_point + u.delete_length >= STB_TEXTEDIT_UNDOCHARCOUNT) {
         // the undo records take up too much character space; there's no space to store the redo characters
         r->insert_length = 0;
      } else {
         int i;

         // there's definitely room to store the characters eventually
         while (s->undo_char_point + u.delete_length > s->redo_char_point) {
            // should never happen:
            if (s->redo_point == STB_TEXTEDIT_UNDOSTATECOUNT)
               return;
            // there's currently not enough room, so discard a redo record
            stb_textedit_discard_redo(s);
         }
         r = &s->undo_rec[s->redo_point-1];

         r->char_storage = s->redo_char_point - u.delete_length;
         s->redo_char_point = s->redo_char_point - u.delete_length;

         // now save the characters
         for (i=0; i < u.delete_length; ++i)
            s->undo_char[r->char_storage + i] = STB_TEXTEDIT_GETCHAR(str, u.where + i);
      }

      // now we can carry out the deletion
      STB_TEXTEDIT_DELETECHARS(str, u.where, u.delete_length);
   }

   // check type of recorded action:
   if (u.insert_length) {
      // easy case: was a deletion, so we need to insert n characters
      STB_TEXTEDIT_INSERTCHARS(str, u.where, &s->undo_char[u.char_storage], u.insert_length);
      s->undo_char_point -= u.insert_length;
   }

   state->cursor = u.where + u.insert_length;

   s->undo_point--;
   s->redo_point--;
}

static void stb_text_redo(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
{
   StbUndoState *s = &state->undostate;
   StbUndoRecord *u, r;
   if (s->redo_point == STB_TEXTEDIT_UNDOSTATECOUNT)
      return;

   // we need to do two things: apply the redo record, and create an undo record
   u = &s->undo_rec[s->undo_point];
   r = s->undo_rec[s->redo_point];

   // we KNOW there must be room for the undo record, because the redo record
   // was derived from an undo record

   u->delete_length = r.insert_length;
   u->insert_length = r.delete_length;
   u->where = r.where;
   u->char_storage = -1;

   if (r.delete_length) {
      // the redo record requires us to delete characters, so the undo record
      // needs to store the characters

      if (s->undo_char_point + u->insert_length > s->redo_char_point) {
         u->insert_length = 0;
         u->delete_length = 0;
      } else {
         int i;
         u->char_storage = s->undo_char_point;
         s->undo_char_point = s->undo_char_point + u->insert_length;

         // now save the characters
         for (i=0; i < u->insert_length; ++i)
            s->undo_char[u->char_storage + i] = STB_TEXTEDIT_GETCHAR(str, u->where + i);
      }

      STB_TEXTEDIT_DELETECHARS(str, r.where, r.delete_length);
   }

   if (r.insert_length) {
      // easy case: need to insert n characters
      STB_TEXTEDIT_INSERTCHARS(str, r.where, &s->undo_char[r.char_storage], r.insert_length);
      s->redo_char_point += r.insert_length;
   }

   state->cursor = r.where + r.insert_length;

   s->undo_point++;
   s->redo_point++;
}

static void stb_text_makeundo_insert(STB_TexteditState *state, int where, int length)
{
   stb_text_createundo(&state->undostate, where, 0, length);
}

static void stb_text_makeundo_delete(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int length)
{
   int i;
   STB_TEXTEDIT_CHARTYPE *p = stb_text_createundo(&state->undostate, where, length, 0);
   if (p) {
      for (i=0; i < length; ++i)
         p[i] = STB_TEXTEDIT_GETCHAR(str, where+i);
   }
}

static void stb_text_makeundo_replace(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int old_length, int new_length)
{
   int i;
   STB_TEXTEDIT_CHARTYPE *p = stb_text_createundo(&state->undostate, where, old_length, new_length);
   if (p) {
      for (i=0; i < old_length; ++i)
         p[i] = STB_TEXTEDIT_GETCHAR(str, where+i);
   }
}

// reset the state to default
static void stb_textedit_clear_state(STB_TexteditState *state, int is_single_line)
{
   state->undostate.undo_point = 0;
   state->undostate.undo_char_point = 0;
   state->undostate.redo_point = STB_TEXTEDIT_UNDOSTATECOUNT;
   state->undostate.redo_char_point = STB_TEXTEDIT_UNDOCHARCOUNT;
   state->select_end = state->select_start = 0;
   state->cursor = 0;
   state->has_preferred_x = 0;
   state->preferred_x = 0;
   state->cursor_at_end_of_line = 0;
   state->initialized = 1;
   state->single_line = (unsigned char) is_single_line;
   state->insert_mode = 0;
}

// API initialize
static void stb_textedit_initialize_state(STB_TexteditState *state, int is_single_line)
{
   stb_textedit_clear_state(state, is_single_line);
}

#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wcast-qual"
#endif

static int stb_textedit_paste(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_CHARTYPE const *ctext, int len)
{
   return stb_textedit_paste_internal(str, state, (STB_TEXTEDIT_CHARTYPE *) ctext, len);
}

#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic pop
#endif

#endif//STB_TEXTEDIT_IMPLEMENTATION

/*
------------------------------------------------------------------------------
This software is available under 2 licenses -- choose whichever you prefer.
------------------------------------------------------------------------------
ALTERNATIVE A - MIT License
Copyright (c) 2017 Sean Barrett
Permission is hereby granted, free of charge, to any person obtaining a copy of 
this software and associated documentation files (the "Software"), to deal in 
the Software without restriction, including without limitation the rights to 
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies 
of the Software, and to permit persons to whom the Software is furnished to do 
so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all 
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE 
SOFTWARE.
------------------------------------------------------------------------------
ALTERNATIVE B - Public Domain (www.unlicense.org)
This is free and unencumbered software released into the public domain.
Anyone is free to copy, modify, publish, use, compile, sell, or distribute this 
software, either in source code form or as a compiled binary, for any purpose, 
commercial or non-commercial, and by any means.
In jurisdictions that recognize copyright laws, the author or authors of this 
software dedicate any and all copyright interest in the software to the public 
domain. We make this dedication for the benefit of the public at large and to 
the detriment of our heirs and successors. We intend this dedication to be an 
overt act of relinquishment in perpetuity of all present and future rights to 
this software under copyright law.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN 
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
------------------------------------------------------------------------------
*/

```

`Artemis/ImGui/imstb_truetype.h`:

```h
// [DEAR IMGUI]
// This is a slightly modified version of stb_truetype.h 1.20.
// Mostly fixing for compiler and static analyzer warnings.
// Grep for [DEAR IMGUI] to find the changes.

// stb_truetype.h - v1.20 - public domain
// authored from 2009-2016 by Sean Barrett / RAD Game Tools
//
//   This library processes TrueType files:
//        parse files
//        extract glyph metrics
//        extract glyph shapes
//        render glyphs to one-channel bitmaps with antialiasing (box filter)
//        render glyphs to one-channel SDF bitmaps (signed-distance field/function)
//
//   Todo:
//        non-MS cmaps
//        crashproof on bad data
//        hinting? (no longer patented)
//        cleartype-style AA?
//        optimize: use simple memory allocator for intermediates
//        optimize: build edge-list directly from curves
//        optimize: rasterize directly from curves?
//
// ADDITIONAL CONTRIBUTORS
//
//   Mikko Mononen: compound shape support, more cmap formats
//   Tor Andersson: kerning, subpixel rendering
//   Dougall Johnson: OpenType / Type 2 font handling
//   Daniel Ribeiro Maciel: basic GPOS-based kerning
//
//   Misc other:
//       Ryan Gordon
//       Simon Glass
//       github:IntellectualKitty
//       Imanol Celaya
//       Daniel Ribeiro Maciel
//
//   Bug/warning reports/fixes:
//       "Zer" on mollyrocket       Fabian "ryg" Giesen
//       Cass Everitt               Martins Mozeiko
//       stoiko (Haemimont Games)   Cap Petschulat
//       Brian Hook                 Omar Cornut
//       Walter van Niftrik         github:aloucks
//       David Gow                  Peter LaValle
//       David Given                Sergey Popov
//       Ivan-Assen Ivanov          Giumo X. Clanjor
//       Anthony Pesch              Higor Euripedes
//       Johan Duparc               Thomas Fields
//       Hou Qiming                 Derek Vinyard
//       Rob Loach                  Cort Stratton
//       Kenney Phillis Jr.         github:oyvindjam
//       Brian Costabile            github:vassvik
//       
// VERSION HISTORY
//
//   1.20 (2019-02-07) PackFontRange skips missing codepoints; GetScaleFontVMetrics()
//   1.19 (2018-02-11) GPOS kerning, STBTT_fmod
//   1.18 (2018-01-29) add missing function
//   1.17 (2017-07-23) make more arguments const; doc fix
//   1.16 (2017-07-12) SDF support
//   1.15 (2017-03-03) make more arguments const
//   1.14 (2017-01-16) num-fonts-in-TTC function
//   1.13 (2017-01-02) support OpenType fonts, certain Apple fonts
//   1.12 (2016-10-25) suppress warnings about casting away const with -Wcast-qual
//   1.11 (2016-04-02) fix unused-variable warning
//   1.10 (2016-04-02) user-defined fabs(); rare memory leak; remove duplicate typedef
//   1.09 (2016-01-16) warning fix; avoid crash on outofmem; use allocation userdata properly
//   1.08 (2015-09-13) document stbtt_Rasterize(); fixes for vertical & horizontal edges
//   1.07 (2015-08-01) allow PackFontRanges to accept arrays of sparse codepoints;
//                     variant PackFontRanges to pack and render in separate phases;
//                     fix stbtt_GetFontOFfsetForIndex (never worked for non-0 input?);
//                     fixed an assert() bug in the new rasterizer
//                     replace assert() with STBTT_assert() in new rasterizer
//
//   Full history can be found at the end of this file.
//
// LICENSE
//
//   See end of file for license information.
//
// USAGE
//
//   Include this file in whatever places need to refer to it. In ONE C/C++
//   file, write:
//      #define STB_TRUETYPE_IMPLEMENTATION
//   before the #include of this file. This expands out the actual
//   implementation into that C/C++ file.
//
//   To make the implementation private to the file that generates the implementation,
//      #define STBTT_STATIC
//
//   Simple 3D API (don't ship this, but it's fine for tools and quick start)
//           stbtt_BakeFontBitmap()               -- bake a font to a bitmap for use as texture
//           stbtt_GetBakedQuad()                 -- compute quad to draw for a given char
//
//   Improved 3D API (more shippable):
//           #include "stb_rect_pack.h"           -- optional, but you really want it
//           stbtt_PackBegin()
//           stbtt_PackSetOversampling()          -- for improved quality on small fonts
//           stbtt_PackFontRanges()               -- pack and renders
//           stbtt_PackEnd()
//           stbtt_GetPackedQuad()
//
//   "Load" a font file from a memory buffer (you have to keep the buffer loaded)
//           stbtt_InitFont()
//           stbtt_GetFontOffsetForIndex()        -- indexing for TTC font collections
//           stbtt_GetNumberOfFonts()             -- number of fonts for TTC font collections
//
//   Render a unicode codepoint to a bitmap
//           stbtt_GetCodepointBitmap()           -- allocates and returns a bitmap
//           stbtt_MakeCodepointBitmap()          -- renders into bitmap you provide
//           stbtt_GetCodepointBitmapBox()        -- how big the bitmap must be
//
//   Character advance/positioning
//           stbtt_GetCodepointHMetrics()
//           stbtt_GetFontVMetrics()
//           stbtt_GetFontVMetricsOS2()
//           stbtt_GetCodepointKernAdvance()
//
//   Starting with version 1.06, the rasterizer was replaced with a new,
//   faster and generally-more-precise rasterizer. The new rasterizer more
//   accurately measures pixel coverage for anti-aliasing, except in the case
//   where multiple shapes overlap, in which case it overestimates the AA pixel
//   coverage. Thus, anti-aliasing of intersecting shapes may look wrong. If
//   this turns out to be a problem, you can re-enable the old rasterizer with
//        #define STBTT_RASTERIZER_VERSION 1
//   which will incur about a 15% speed hit.
//
// ADDITIONAL DOCUMENTATION
//
//   Immediately after this block comment are a series of sample programs.
//
//   After the sample programs is the "header file" section. This section
//   includes documentation for each API function.
//
//   Some important concepts to understand to use this library:
//
//      Codepoint
//         Characters are defined by unicode codepoints, e.g. 65 is
//         uppercase A, 231 is lowercase c with a cedilla, 0x7e30 is
//         the hiragana for "ma".
//
//      Glyph
//         A visual character shape (every codepoint is rendered as
//         some glyph)
//
//      Glyph index
//         A font-specific integer ID representing a glyph
//
//      Baseline
//         Glyph shapes are defined relative to a baseline, which is the
//         bottom of uppercase characters. Characters extend both above
//         and below the baseline.
//
//      Current Point
//         As you draw text to the screen, you keep track of a "current point"
//         which is the origin of each character. The current point's vertical
//         position is the baseline. Even "baked fonts" use this model.
//
//      Vertical Font Metrics
//         The vertical qualities of the font, used to vertically position
//         and space the characters. See docs for stbtt_GetFontVMetrics.
//
//      Font Size in Pixels or Points
//         The preferred interface for specifying font sizes in stb_truetype
//         is to specify how tall the font's vertical extent should be in pixels.
//         If that sounds good enough, skip the next paragraph.
//
//         Most font APIs instead use "points", which are a common typographic
//         measurement for describing font size, defined as 72 points per inch.
//         stb_truetype provides a point API for compatibility. However, true
//         "per inch" conventions don't make much sense on computer displays
//         since different monitors have different number of pixels per
//         inch. For example, Windows traditionally uses a convention that
//         there are 96 pixels per inch, thus making 'inch' measurements have
//         nothing to do with inches, and thus effectively defining a point to
//         be 1.333 pixels. Additionally, the TrueType font data provides
//         an explicit scale factor to scale a given font's glyphs to points,
//         but the author has observed that this scale factor is often wrong
//         for non-commercial fonts, thus making fonts scaled in points
//         according to the TrueType spec incoherently sized in practice.
//
// DETAILED USAGE:
//
//  Scale:
//    Select how high you want the font to be, in points or pixels.
//    Call ScaleForPixelHeight or ScaleForMappingEmToPixels to compute
//    a scale factor SF that will be used by all other functions.
//
//  Baseline:
//    You need to select a y-coordinate that is the baseline of where
//    your text will appear. Call GetFontBoundingBox to get the baseline-relative
//    bounding box for all characters. SF*-y0 will be the distance in pixels
//    that the worst-case character could extend above the baseline, so if
//    you want the top edge of characters to appear at the top of the
//    screen where y=0, then you would set the baseline to SF*-y0.
//
//  Current point:
//    Set the current point where the first character will appear. The
//    first character could extend left of the current point; this is font
//    dependent. You can either choose a current point that is the leftmost
//    point and hope, or add some padding, or check the bounding box or
//    left-side-bearing of the first character to be displayed and set
//    the current point based on that.
//
//  Displaying a character:
//    Compute the bounding box of the character. It will contain signed values
//    relative to <current_point, baseline>. I.e. if it returns x0,y0,x1,y1,
//    then the character should be displayed in the rectangle from
//    <current_point+SF*x0, baseline+SF*y0> to <current_point+SF*x1,baseline+SF*y1).
//
//  Advancing for the next character:
//    Call GlyphHMetrics, and compute 'current_point += SF * advance'.
// 
//
// ADVANCED USAGE
//
//   Quality:
//
//    - Use the functions with Subpixel at the end to allow your characters
//      to have subpixel positioning. Since the font is anti-aliased, not
//      hinted, this is very import for quality. (This is not possible with
//      baked fonts.)
//
//    - Kerning is now supported, and if you're supporting subpixel rendering
//      then kerning is worth using to give your text a polished look.
//
//   Performance:
//
//    - Convert Unicode codepoints to glyph indexes and operate on the glyphs;
//      if you don't do this, stb_truetype is forced to do the conversion on
//      every call.
//
//    - There are a lot of memory allocations. We should modify it to take
//      a temp buffer and allocate from the temp buffer (without freeing),
//      should help performance a lot.
//
// NOTES
//
//   The system uses the raw data found in the .ttf file without changing it
//   and without building auxiliary data structures. This is a bit inefficient
//   on little-endian systems (the data is big-endian), but assuming you're
//   caching the bitmaps or glyph shapes this shouldn't be a big deal.
//
//   It appears to be very hard to programmatically determine what font a
//   given file is in a general way. I provide an API for this, but I don't
//   recommend it.
//
//
// SOURCE STATISTICS (based on v0.6c, 2050 LOC)
//
//   Documentation & header file        520 LOC  \___ 660 LOC documentation
//   Sample code                        140 LOC  /
//   Truetype parsing                   620 LOC  ---- 620 LOC TrueType
//   Software rasterization             240 LOC  \.
//   Curve tessellation                 120 LOC   \__ 550 LOC Bitmap creation
//   Bitmap management                  100 LOC   /
//   Baked bitmap interface              70 LOC  /
//   Font name matching & access        150 LOC  ---- 150 
//   C runtime library abstraction       60 LOC  ----  60
//
//
// PERFORMANCE MEASUREMENTS FOR 1.06:
//
//                      32-bit     64-bit
//   Previous release:  8.83 s     7.68 s
//   Pool allocations:  7.72 s     6.34 s
//   Inline sort     :  6.54 s     5.65 s
//   New rasterizer  :  5.63 s     5.00 s

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
////
////  SAMPLE PROGRAMS
////
//
//  Incomplete text-in-3d-api example, which draws quads properly aligned to be lossless
//
#if 0
#define STB_TRUETYPE_IMPLEMENTATION  // force following include to generate implementation
#include "stb_truetype.h"

unsigned char ttf_buffer[1<<20];
unsigned char temp_bitmap[512*512];

stbtt_bakedchar cdata[96]; // ASCII 32..126 is 95 glyphs
GLuint ftex;

void my_stbtt_initfont(void)
{
   fread(ttf_buffer, 1, 1<<20, fopen("c:/windows/fonts/times.ttf", "rb"));
   stbtt_BakeFontBitmap(ttf_buffer,0, 32.0, temp_bitmap,512,512, 32,96, cdata); // no guarantee this fits!
   // can free ttf_buffer at this point
   glGenTextures(1, &ftex);
   glBindTexture(GL_TEXTURE_2D, ftex);
   glTexImage2D(GL_TEXTURE_2D, 0, GL_ALPHA, 512,512, 0, GL_ALPHA, GL_UNSIGNED_BYTE, temp_bitmap);
   // can free temp_bitmap at this point
   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
}

void my_stbtt_print(float x, float y, char *text)
{
   // assume orthographic projection with units = screen pixels, origin at top left
   glEnable(GL_TEXTURE_2D);
   glBindTexture(GL_TEXTURE_2D, ftex);
   glBegin(GL_QUADS);
   while (*text) {
      if (*text >= 32 && *text < 128) {
         stbtt_aligned_quad q;
         stbtt_GetBakedQuad(cdata, 512,512, *text-32, &x,&y,&q,1);//1=opengl & d3d10+,0=d3d9
         glTexCoord2f(q.s0,q.t1); glVertex2f(q.x0,q.y0);
         glTexCoord2f(q.s1,q.t1); glVertex2f(q.x1,q.y0);
         glTexCoord2f(q.s1,q.t0); glVertex2f(q.x1,q.y1);
         glTexCoord2f(q.s0,q.t0); glVertex2f(q.x0,q.y1);
      }
      ++text;
   }
   glEnd();
}
#endif
//
//
//////////////////////////////////////////////////////////////////////////////
//
// Complete program (this compiles): get a single bitmap, print as ASCII art
//
#if 0
#include <stdio.h>
#define STB_TRUETYPE_IMPLEMENTATION  // force following include to generate implementation
#include "stb_truetype.h"

char ttf_buffer[1<<25];

int main(int argc, char **argv)
{
   stbtt_fontinfo font;
   unsigned char *bitmap;
   int w,h,i,j,c = (argc > 1 ? atoi(argv[1]) : 'a'), s = (argc > 2 ? atoi(argv[2]) : 20);

   fread(ttf_buffer, 1, 1<<25, fopen(argc > 3 ? argv[3] : "c:/windows/fonts/arialbd.ttf", "rb"));

   stbtt_InitFont(&font, ttf_buffer, stbtt_GetFontOffsetForIndex(ttf_buffer,0));
   bitmap = stbtt_GetCodepointBitmap(&font, 0,stbtt_ScaleForPixelHeight(&font, s), c, &w, &h, 0,0);

   for (j=0; j < h; ++j) {
      for (i=0; i < w; ++i)
         putchar(" .:ioVM@"[bitmap[j*w+i]>>5]);
      putchar('\n');
   }
   return 0;
}
#endif 
//
// Output:
//
//     .ii.
//    @@@@@@.
//   V@Mio@@o
//   :i.  V@V
//     :oM@@M
//   :@@@MM@M
//   @@o  o@M
//  :@@.  M@M
//   @@@o@@@@
//   :M@@V:@@.
//  
//////////////////////////////////////////////////////////////////////////////
// 
// Complete program: print "Hello World!" banner, with bugs
//
#if 0
char buffer[24<<20];
unsigned char screen[20][79];

int main(int arg, char **argv)
{
   stbtt_fontinfo font;
   int i,j,ascent,baseline,ch=0;
   float scale, xpos=2; // leave a little padding in case the character extends left
   char *text = "Heljo World!"; // intentionally misspelled to show 'lj' brokenness

   fread(buffer, 1, 1000000, fopen("c:/windows/fonts/arialbd.ttf", "rb"));
   stbtt_InitFont(&font, buffer, 0);

   scale = stbtt_ScaleForPixelHeight(&font, 15);
   stbtt_GetFontVMetrics(&font, &ascent,0,0);
   baseline = (int) (ascent*scale);

   while (text[ch]) {
      int advance,lsb,x0,y0,x1,y1;
      float x_shift = xpos - (float) floor(xpos);
      stbtt_GetCodepointHMetrics(&font, text[ch], &advance, &lsb);
      stbtt_GetCodepointBitmapBoxSubpixel(&font, text[ch], scale,scale,x_shift,0, &x0,&y0,&x1,&y1);
      stbtt_MakeCodepointBitmapSubpixel(&font, &screen[baseline + y0][(int) xpos + x0], x1-x0,y1-y0, 79, scale,scale,x_shift,0, text[ch]);
      // note that this stomps the old data, so where character boxes overlap (e.g. 'lj') it's wrong
      // because this API is really for baking character bitmaps into textures. if you want to render
      // a sequence of characters, you really need to render each bitmap to a temp buffer, then
      // "alpha blend" that into the working buffer
      xpos += (advance * scale);
      if (text[ch+1])
         xpos += scale*stbtt_GetCodepointKernAdvance(&font, text[ch],text[ch+1]);
      ++ch;
   }

   for (j=0; j < 20; ++j) {
      for (i=0; i < 78; ++i)
         putchar(" .:ioVM@"[screen[j][i]>>5]);
      putchar('\n');
   }

   return 0;
}
#endif


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
////
////   INTEGRATION WITH YOUR CODEBASE
////
////   The following sections allow you to supply alternate definitions
////   of C library functions used by stb_truetype, e.g. if you don't
////   link with the C runtime library.

#ifdef STB_TRUETYPE_IMPLEMENTATION
   // #define your own (u)stbtt_int8/16/32 before including to override this
   #ifndef stbtt_uint8
   typedef unsigned char   stbtt_uint8;
   typedef signed   char   stbtt_int8;
   typedef unsigned short  stbtt_uint16;
   typedef signed   short  stbtt_int16;
   typedef unsigned int    stbtt_uint32;
   typedef signed   int    stbtt_int32;
   #endif

   typedef char stbtt__check_size32[sizeof(stbtt_int32)==4 ? 1 : -1];
   typedef char stbtt__check_size16[sizeof(stbtt_int16)==2 ? 1 : -1];

   // e.g. #define your own STBTT_ifloor/STBTT_iceil() to avoid math.h
   #ifndef STBTT_ifloor
   #include <math.h>
   #define STBTT_ifloor(x)   ((int) floor(x))
   #define STBTT_iceil(x)    ((int) ceil(x))
   #endif

   #ifndef STBTT_sqrt
   #include <math.h>
   #define STBTT_sqrt(x)      sqrt(x)
   #define STBTT_pow(x,y)     pow(x,y)
   #endif

   #ifndef STBTT_fmod
   #include <math.h>
   #define STBTT_fmod(x,y)    fmod(x,y)
   #endif

   #ifndef STBTT_cos
   #include <math.h>
   #define STBTT_cos(x)       cos(x)
   #define STBTT_acos(x)      acos(x)
   #endif

   #ifndef STBTT_fabs
   #include <math.h>
   #define STBTT_fabs(x)      fabs(x)
   #endif

   // #define your own functions "STBTT_malloc" / "STBTT_free" to avoid malloc.h
   #ifndef STBTT_malloc
   #include <stdlib.h>
   #define STBTT_malloc(x,u)  ((void)(u),malloc(x))
   #define STBTT_free(x,u)    ((void)(u),free(x))
   #endif

   #ifndef STBTT_assert
   #include <assert.h>
   #define STBTT_assert(x)    assert(x)
   #endif

   #ifndef STBTT_strlen
   #include <string.h>
   #define STBTT_strlen(x)    strlen(x)
   #endif

   #ifndef STBTT_memcpy
   #include <string.h>
   #define STBTT_memcpy       memcpy
   #define STBTT_memset       memset
   #endif
#endif

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
////
////   INTERFACE
////
////

#ifndef __STB_INCLUDE_STB_TRUETYPE_H__
#define __STB_INCLUDE_STB_TRUETYPE_H__

#ifdef STBTT_STATIC
#define STBTT_DEF static
#else
#define STBTT_DEF extern
#endif

#ifdef __cplusplus
extern "C" {
#endif

// private structure
typedef struct
{
   unsigned char *data;
   int cursor;
   int size;
} stbtt__buf;

//////////////////////////////////////////////////////////////////////////////
//
// TEXTURE BAKING API
//
// If you use this API, you only have to call two functions ever.
//

typedef struct
{
   unsigned short x0,y0,x1,y1; // coordinates of bbox in bitmap
   float xoff,yoff,xadvance;
} stbtt_bakedchar;

STBTT_DEF int stbtt_BakeFontBitmap(const unsigned char *data, int offset,  // font location (use offset=0 for plain .ttf)
                                float pixel_height,                     // height of font in pixels
                                unsigned char *pixels, int pw, int ph,  // bitmap to be filled in
                                int first_char, int num_chars,          // characters to bake
                                stbtt_bakedchar *chardata);             // you allocate this, it's num_chars long
// if return is positive, the first unused row of the bitmap
// if return is negative, returns the negative of the number of characters that fit
// if return is 0, no characters fit and no rows were used
// This uses a very crappy packing.

typedef struct
{
   float x0,y0,s0,t0; // top-left
   float x1,y1,s1,t1; // bottom-right
} stbtt_aligned_quad;

STBTT_DEF void stbtt_GetBakedQuad(const stbtt_bakedchar *chardata, int pw, int ph,  // same data as above
                               int char_index,             // character to display
                               float *xpos, float *ypos,   // pointers to current position in screen pixel space
                               stbtt_aligned_quad *q,      // output: quad to draw
                               int opengl_fillrule);       // true if opengl fill rule; false if DX9 or earlier
// Call GetBakedQuad with char_index = 'character - first_char', and it
// creates the quad you need to draw and advances the current position.
//
// The coordinate system used assumes y increases downwards.
//
// Characters will extend both above and below the current position;
// see discussion of "BASELINE" above.
//
// It's inefficient; you might want to c&p it and optimize it.

STBTT_DEF void stbtt_GetScaledFontVMetrics(const unsigned char *fontdata, int index, float size, float *ascent, float *descent, float *lineGap);
// Query the font vertical metrics without having to create a font first.


//////////////////////////////////////////////////////////////////////////////
//
// NEW TEXTURE BAKING API
//
// This provides options for packing multiple fonts into one atlas, not
// perfectly but better than nothing.

typedef struct
{
   unsigned short x0,y0,x1,y1; // coordinates of bbox in bitmap
   float xoff,yoff,xadvance;
   float xoff2,yoff2;
} stbtt_packedchar;

typedef struct stbtt_pack_context stbtt_pack_context;
typedef struct stbtt_fontinfo stbtt_fontinfo;
#ifndef STB_RECT_PACK_VERSION
typedef struct stbrp_rect stbrp_rect;
#endif

STBTT_DEF int  stbtt_PackBegin(stbtt_pack_context *spc, unsigned char *pixels, int width, int height, int stride_in_bytes, int padding, void *alloc_context);
// Initializes a packing context stored in the passed-in stbtt_pack_context.
// Future calls using this context will pack characters into the bitmap passed
// in here: a 1-channel bitmap that is width * height. stride_in_bytes is
// the distance from one row to the next (or 0 to mean they are packed tightly
// together). "padding" is the amount of padding to leave between each
// character (normally you want '1' for bitmaps you'll use as textures with
// bilinear filtering).
//
// Returns 0 on failure, 1 on success.

STBTT_DEF void stbtt_PackEnd  (stbtt_pack_context *spc);
// Cleans up the packing context and frees all memory.

#define STBTT_POINT_SIZE(x)   (-(x))

STBTT_DEF int  stbtt_PackFontRange(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, float font_size,
                                int first_unicode_char_in_range, int num_chars_in_range, stbtt_packedchar *chardata_for_range);
// Creates character bitmaps from the font_index'th font found in fontdata (use
// font_index=0 if you don't know what that is). It creates num_chars_in_range
// bitmaps for characters with unicode values starting at first_unicode_char_in_range
// and increasing. Data for how to render them is stored in chardata_for_range;
// pass these to stbtt_GetPackedQuad to get back renderable quads.
//
// font_size is the full height of the character from ascender to descender,
// as computed by stbtt_ScaleForPixelHeight. To use a point size as computed
// by stbtt_ScaleForMappingEmToPixels, wrap the point size in STBTT_POINT_SIZE()
// and pass that result as 'font_size':
//       ...,                  20 , ... // font max minus min y is 20 pixels tall
//       ..., STBTT_POINT_SIZE(20), ... // 'M' is 20 pixels tall

typedef struct
{
   float font_size;
   int first_unicode_codepoint_in_range;  // if non-zero, then the chars are continuous, and this is the first codepoint
   int *array_of_unicode_codepoints;       // if non-zero, then this is an array of unicode codepoints
   int num_chars;
   stbtt_packedchar *chardata_for_range; // output
   unsigned char h_oversample, v_oversample; // don't set these, they're used internally
} stbtt_pack_range;

STBTT_DEF int  stbtt_PackFontRanges(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, stbtt_pack_range *ranges, int num_ranges);
// Creates character bitmaps from multiple ranges of characters stored in
// ranges. This will usually create a better-packed bitmap than multiple
// calls to stbtt_PackFontRange. Note that you can call this multiple
// times within a single PackBegin/PackEnd.

STBTT_DEF void stbtt_PackSetOversampling(stbtt_pack_context *spc, unsigned int h_oversample, unsigned int v_oversample);
// Oversampling a font increases the quality by allowing higher-quality subpixel
// positioning, and is especially valuable at smaller text sizes.
//
// This function sets the amount of oversampling for all following calls to
// stbtt_PackFontRange(s) or stbtt_PackFontRangesGatherRects for a given
// pack context. The default (no oversampling) is achieved by h_oversample=1
// and v_oversample=1. The total number of pixels required is
// h_oversample*v_oversample larger than the default; for example, 2x2
// oversampling requires 4x the storage of 1x1. For best results, render
// oversampled textures with bilinear filtering. Look at the readme in
// stb/tests/oversample for information about oversampled fonts
//
// To use with PackFontRangesGather etc., you must set it before calls
// call to PackFontRangesGatherRects.

STBTT_DEF void stbtt_PackSetSkipMissingCodepoints(stbtt_pack_context *spc, int skip);
// If skip != 0, this tells stb_truetype to skip any codepoints for which
// there is no corresponding glyph. If skip=0, which is the default, then
// codepoints without a glyph recived the font's "missing character" glyph,
// typically an empty box by convention.

STBTT_DEF void stbtt_GetPackedQuad(const stbtt_packedchar *chardata, int pw, int ph,  // same data as above
                               int char_index,             // character to display
                               float *xpos, float *ypos,   // pointers to current position in screen pixel space
                               stbtt_aligned_quad *q,      // output: quad to draw
                               int align_to_integer);

STBTT_DEF int  stbtt_PackFontRangesGatherRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects);
STBTT_DEF void stbtt_PackFontRangesPackRects(stbtt_pack_context *spc, stbrp_rect *rects, int num_rects);
STBTT_DEF int  stbtt_PackFontRangesRenderIntoRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects);
// Calling these functions in sequence is roughly equivalent to calling
// stbtt_PackFontRanges(). If you more control over the packing of multiple
// fonts, or if you want to pack custom data into a font texture, take a look
// at the source to of stbtt_PackFontRanges() and create a custom version 
// using these functions, e.g. call GatherRects multiple times,
// building up a single array of rects, then call PackRects once,
// then call RenderIntoRects repeatedly. This may result in a
// better packing than calling PackFontRanges multiple times
// (or it may not).

// this is an opaque structure that you shouldn't mess with which holds
// all the context needed from PackBegin to PackEnd.
struct stbtt_pack_context {
   void *user_allocator_context;
   void *pack_info;
   int   width;
   int   height;
   int   stride_in_bytes;
   int   padding;
   int   skip_missing;
   unsigned int   h_oversample, v_oversample;
   unsigned char *pixels;
   void  *nodes;
};

//////////////////////////////////////////////////////////////////////////////
//
// FONT LOADING
//
//

STBTT_DEF int stbtt_GetNumberOfFonts(const unsigned char *data);
// This function will determine the number of fonts in a font file.  TrueType
// collection (.ttc) files may contain multiple fonts, while TrueType font
// (.ttf) files only contain one font. The number of fonts can be used for
// indexing with the previous function where the index is between zero and one
// less than the total fonts. If an error occurs, -1 is returned.

STBTT_DEF int stbtt_GetFontOffsetForIndex(const unsigned char *data, int index);
// Each .ttf/.ttc file may have more than one font. Each font has a sequential
// index number starting from 0. Call this function to get the font offset for
// a given index; it returns -1 if the index is out of range. A regular .ttf
// file will only define one font and it always be at offset 0, so it will
// return '0' for index 0, and -1 for all other indices.

// The following structure is defined publicly so you can declare one on
// the stack or as a global or etc, but you should treat it as opaque.
struct stbtt_fontinfo
{
   void           * userdata;
   unsigned char  * data;              // pointer to .ttf file
   int              fontstart;         // offset of start of font

   int numGlyphs;                     // number of glyphs, needed for range checking

   int loca,head,glyf,hhea,hmtx,kern,gpos; // table locations as offset from start of .ttf
   int index_map;                     // a cmap mapping for our chosen character encoding
   int indexToLocFormat;              // format needed to map from glyph index to glyph

   stbtt__buf cff;                    // cff font data
   stbtt__buf charstrings;            // the charstring index
   stbtt__buf gsubrs;                 // global charstring subroutines index
   stbtt__buf subrs;                  // private charstring subroutines index
   stbtt__buf fontdicts;              // array of font dicts
   stbtt__buf fdselect;               // map from glyph to fontdict
};

STBTT_DEF int stbtt_InitFont(stbtt_fontinfo *info, const unsigned char *data, int offset);
// Given an offset into the file that defines a font, this function builds
// the necessary cached info for the rest of the system. You must allocate
// the stbtt_fontinfo yourself, and stbtt_InitFont will fill it out. You don't
// need to do anything special to free it, because the contents are pure
// value data with no additional data structures. Returns 0 on failure.


//////////////////////////////////////////////////////////////////////////////
//
// CHARACTER TO GLYPH-INDEX CONVERSIOn

STBTT_DEF int stbtt_FindGlyphIndex(const stbtt_fontinfo *info, int unicode_codepoint);
// If you're going to perform multiple operations on the same character
// and you want a speed-up, call this function with the character you're
// going to process, then use glyph-based functions instead of the
// codepoint-based functions.
// Returns 0 if the character codepoint is not defined in the font.


//////////////////////////////////////////////////////////////////////////////
//
// CHARACTER PROPERTIES
//

STBTT_DEF float stbtt_ScaleForPixelHeight(const stbtt_fontinfo *info, float pixels);
// computes a scale factor to produce a font whose "height" is 'pixels' tall.
// Height is measured as the distance from the highest ascender to the lowest
// descender; in other words, it's equivalent to calling stbtt_GetFontVMetrics
// and computing:
//       scale = pixels / (ascent - descent)
// so if you prefer to measure height by the ascent only, use a similar calculation.

STBTT_DEF float stbtt_ScaleForMappingEmToPixels(const stbtt_fontinfo *info, float pixels);
// computes a scale factor to produce a font whose EM size is mapped to
// 'pixels' tall. This is probably what traditional APIs compute, but
// I'm not positive.

STBTT_DEF void stbtt_GetFontVMetrics(const stbtt_fontinfo *info, int *ascent, int *descent, int *lineGap);
// ascent is the coordinate above the baseline the font extends; descent
// is the coordinate below the baseline the font extends (i.e. it is typically negative)
// lineGap is the spacing between one row's descent and the next row's ascent...
// so you should advance the vertical position by "*ascent - *descent + *lineGap"
//   these are expressed in unscaled coordinates, so you must multiply by
//   the scale factor for a given size

STBTT_DEF int  stbtt_GetFontVMetricsOS2(const stbtt_fontinfo *info, int *typoAscent, int *typoDescent, int *typoLineGap);
// analogous to GetFontVMetrics, but returns the "typographic" values from the OS/2
// table (specific to MS/Windows TTF files).
//
// Returns 1 on success (table present), 0 on failure.

STBTT_DEF void stbtt_GetFontBoundingBox(const stbtt_fontinfo *info, int *x0, int *y0, int *x1, int *y1);
// the bounding box around all possible characters

STBTT_DEF void stbtt_GetCodepointHMetrics(const stbtt_fontinfo *info, int codepoint, int *advanceWidth, int *leftSideBearing);
// leftSideBearing is the offset from the current horizontal position to the left edge of the character
// advanceWidth is the offset from the current horizontal position to the next horizontal position
//   these are expressed in unscaled coordinates

STBTT_DEF int  stbtt_GetCodepointKernAdvance(const stbtt_fontinfo *info, int ch1, int ch2);
// an additional amount to add to the 'advance' value between ch1 and ch2

STBTT_DEF int stbtt_GetCodepointBox(const stbtt_fontinfo *info, int codepoint, int *x0, int *y0, int *x1, int *y1);
// Gets the bounding box of the visible part of the glyph, in unscaled coordinates

STBTT_DEF void stbtt_GetGlyphHMetrics(const stbtt_fontinfo *info, int glyph_index, int *advanceWidth, int *leftSideBearing);
STBTT_DEF int  stbtt_GetGlyphKernAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2);
STBTT_DEF int  stbtt_GetGlyphBox(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1);
// as above, but takes one or more glyph indices for greater efficiency


//////////////////////////////////////////////////////////////////////////////
//
// GLYPH SHAPES (you probably don't need these, but they have to go before
// the bitmaps for C declaration-order reasons)
//

#ifndef STBTT_vmove // you can predefine these to use different values (but why?)
   enum {
      STBTT_vmove=1,
      STBTT_vline,
      STBTT_vcurve,
      STBTT_vcubic
   };
#endif

#ifndef stbtt_vertex // you can predefine this to use different values
                   // (we share this with other code at RAD)
   #define stbtt_vertex_type short // can't use stbtt_int16 because that's not visible in the header file
   typedef struct
   {
      stbtt_vertex_type x,y,cx,cy,cx1,cy1;
      unsigned char type,padding;
   } stbtt_vertex;
#endif

STBTT_DEF int stbtt_IsGlyphEmpty(const stbtt_fontinfo *info, int glyph_index);
// returns non-zero if nothing is drawn for this glyph

STBTT_DEF int stbtt_GetCodepointShape(const stbtt_fontinfo *info, int unicode_codepoint, stbtt_vertex **vertices);
STBTT_DEF int stbtt_GetGlyphShape(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **vertices);
// returns # of vertices and fills *vertices with the pointer to them
//   these are expressed in "unscaled" coordinates
//
// The shape is a series of contours. Each one starts with
// a STBTT_moveto, then consists of a series of mixed
// STBTT_lineto and STBTT_curveto segments. A lineto
// draws a line from previous endpoint to its x,y; a curveto
// draws a quadratic bezier from previous endpoint to
// its x,y, using cx,cy as the bezier control point.

STBTT_DEF void stbtt_FreeShape(const stbtt_fontinfo *info, stbtt_vertex *vertices);
// frees the data allocated above

//////////////////////////////////////////////////////////////////////////////
//
// BITMAP RENDERING
//

STBTT_DEF void stbtt_FreeBitmap(unsigned char *bitmap, void *userdata);
// frees the bitmap allocated below

STBTT_DEF unsigned char *stbtt_GetCodepointBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int codepoint, int *width, int *height, int *xoff, int *yoff);
// allocates a large-enough single-channel 8bpp bitmap and renders the
// specified character/glyph at the specified scale into it, with
// antialiasing. 0 is no coverage (transparent), 255 is fully covered (opaque).
// *width & *height are filled out with the width & height of the bitmap,
// which is stored left-to-right, top-to-bottom.
//
// xoff/yoff are the offset it pixel space from the glyph origin to the top-left of the bitmap

STBTT_DEF unsigned char *stbtt_GetCodepointBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint, int *width, int *height, int *xoff, int *yoff);
// the same as stbtt_GetCodepoitnBitmap, but you can specify a subpixel
// shift for the character

STBTT_DEF void stbtt_MakeCodepointBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int codepoint);
// the same as stbtt_GetCodepointBitmap, but you pass in storage for the bitmap
// in the form of 'output', with row spacing of 'out_stride' bytes. the bitmap
// is clipped to out_w/out_h bytes. Call stbtt_GetCodepointBitmapBox to get the
// width and height and positioning info for it first.

STBTT_DEF void stbtt_MakeCodepointBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint);
// same as stbtt_MakeCodepointBitmap, but you can specify a subpixel
// shift for the character

STBTT_DEF void stbtt_MakeCodepointBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int oversample_x, int oversample_y, float *sub_x, float *sub_y, int codepoint);
// same as stbtt_MakeCodepointBitmapSubpixel, but prefiltering
// is performed (see stbtt_PackSetOversampling)

STBTT_DEF void stbtt_GetCodepointBitmapBox(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1);
// get the bbox of the bitmap centered around the glyph origin; so the
// bitmap width is ix1-ix0, height is iy1-iy0, and location to place
// the bitmap top left is (leftSideBearing*scale,iy0).
// (Note that the bitmap uses y-increases-down, but the shape uses
// y-increases-up, so CodepointBitmapBox and CodepointBox are inverted.)

STBTT_DEF void stbtt_GetCodepointBitmapBoxSubpixel(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1);
// same as stbtt_GetCodepointBitmapBox, but you can specify a subpixel
// shift for the character

// the following functions are equivalent to the above functions, but operate
// on glyph indices instead of Unicode codepoints (for efficiency)
STBTT_DEF unsigned char *stbtt_GetGlyphBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int glyph, int *width, int *height, int *xoff, int *yoff);
STBTT_DEF unsigned char *stbtt_GetGlyphBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int glyph, int *width, int *height, int *xoff, int *yoff);
STBTT_DEF void stbtt_MakeGlyphBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int glyph);
STBTT_DEF void stbtt_MakeGlyphBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int glyph);
STBTT_DEF void stbtt_MakeGlyphBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int oversample_x, int oversample_y, float *sub_x, float *sub_y, int glyph);
STBTT_DEF void stbtt_GetGlyphBitmapBox(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1);
STBTT_DEF void stbtt_GetGlyphBitmapBoxSubpixel(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y,float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1);


// @TODO: don't expose this structure
typedef struct
{
   int w,h,stride;
   unsigned char *pixels;
} stbtt__bitmap;

// rasterize a shape with quadratic beziers into a bitmap
STBTT_DEF void stbtt_Rasterize(stbtt__bitmap *result,        // 1-channel bitmap to draw into
                               float flatness_in_pixels,     // allowable error of curve in pixels
                               stbtt_vertex *vertices,       // array of vertices defining shape
                               int num_verts,                // number of vertices in above array
                               float scale_x, float scale_y, // scale applied to input vertices
                               float shift_x, float shift_y, // translation applied to input vertices
                               int x_off, int y_off,         // another translation applied to input
                               int invert,                   // if non-zero, vertically flip shape
                               void *userdata);              // context for to STBTT_MALLOC

//////////////////////////////////////////////////////////////////////////////
//
// Signed Distance Function (or Field) rendering

STBTT_DEF void stbtt_FreeSDF(unsigned char *bitmap, void *userdata);
// frees the SDF bitmap allocated below

STBTT_DEF unsigned char * stbtt_GetGlyphSDF(const stbtt_fontinfo *info, float scale, int glyph, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff);
STBTT_DEF unsigned char * stbtt_GetCodepointSDF(const stbtt_fontinfo *info, float scale, int codepoint, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff);
// These functions compute a discretized SDF field for a single character, suitable for storing
// in a single-channel texture, sampling with bilinear filtering, and testing against
// larger than some threshold to produce scalable fonts.
//        info              --  the font
//        scale             --  controls the size of the resulting SDF bitmap, same as it would be creating a regular bitmap
//        glyph/codepoint   --  the character to generate the SDF for
//        padding           --  extra "pixels" around the character which are filled with the distance to the character (not 0),
//                                 which allows effects like bit outlines
//        onedge_value      --  value 0-255 to test the SDF against to reconstruct the character (i.e. the isocontour of the character)
//        pixel_dist_scale  --  what value the SDF should increase by when moving one SDF "pixel" away from the edge (on the 0..255 scale)
//                                 if positive, > onedge_value is inside; if negative, < onedge_value is inside
//        width,height      --  output height & width of the SDF bitmap (including padding)
//        xoff,yoff         --  output origin of the character
//        return value      --  a 2D array of bytes 0..255, width*height in size
//
// pixel_dist_scale & onedge_value are a scale & bias that allows you to make
// optimal use of the limited 0..255 for your application, trading off precision
// and special effects. SDF values outside the range 0..255 are clamped to 0..255.
//
// Example:
//      scale = stbtt_ScaleForPixelHeight(22)
//      padding = 5
//      onedge_value = 180
//      pixel_dist_scale = 180/5.0 = 36.0
//
//      This will create an SDF bitmap in which the character is about 22 pixels
//      high but the whole bitmap is about 22+5+5=32 pixels high. To produce a filled
//      shape, sample the SDF at each pixel and fill the pixel if the SDF value
//      is greater than or equal to 180/255. (You'll actually want to antialias,
//      which is beyond the scope of this example.) Additionally, you can compute
//      offset outlines (e.g. to stroke the character border inside & outside,
//      or only outside). For example, to fill outside the character up to 3 SDF
//      pixels, you would compare against (180-36.0*3)/255 = 72/255. The above
//      choice of variables maps a range from 5 pixels outside the shape to
//      2 pixels inside the shape to 0..255; this is intended primarily for apply
//      outside effects only (the interior range is needed to allow proper
//      antialiasing of the font at *smaller* sizes)
//
// The function computes the SDF analytically at each SDF pixel, not by e.g.
// building a higher-res bitmap and approximating it. In theory the quality
// should be as high as possible for an SDF of this size & representation, but
// unclear if this is true in practice (perhaps building a higher-res bitmap
// and computing from that can allow drop-out prevention).
//
// The algorithm has not been optimized at all, so expect it to be slow
// if computing lots of characters or very large sizes. 



//////////////////////////////////////////////////////////////////////////////
//
// Finding the right font...
//
// You should really just solve this offline, keep your own tables
// of what font is what, and don't try to get it out of the .ttf file.
// That's because getting it out of the .ttf file is really hard, because
// the names in the file can appear in many possible encodings, in many
// possible languages, and e.g. if you need a case-insensitive comparison,
// the details of that depend on the encoding & language in a complex way
// (actually underspecified in truetype, but also gigantic).
//
// But you can use the provided functions in two possible ways:
//     stbtt_FindMatchingFont() will use *case-sensitive* comparisons on
//             unicode-encoded names to try to find the font you want;
//             you can run this before calling stbtt_InitFont()
//
//     stbtt_GetFontNameString() lets you get any of the various strings
//             from the file yourself and do your own comparisons on them.
//             You have to have called stbtt_InitFont() first.


STBTT_DEF int stbtt_FindMatchingFont(const unsigned char *fontdata, const char *name, int flags);
// returns the offset (not index) of the font that matches, or -1 if none
//   if you use STBTT_MACSTYLE_DONTCARE, use a font name like "Arial Bold".
//   if you use any other flag, use a font name like "Arial"; this checks
//     the 'macStyle' header field; i don't know if fonts set this consistently
#define STBTT_MACSTYLE_DONTCARE     0
#define STBTT_MACSTYLE_BOLD         1
#define STBTT_MACSTYLE_ITALIC       2
#define STBTT_MACSTYLE_UNDERSCORE   4
#define STBTT_MACSTYLE_NONE         8   // <= not same as 0, this makes us check the bitfield is 0

STBTT_DEF int stbtt_CompareUTF8toUTF16_bigendian(const char *s1, int len1, const char *s2, int len2);
// returns 1/0 whether the first string interpreted as utf8 is identical to
// the second string interpreted as big-endian utf16... useful for strings from next func

STBTT_DEF const char *stbtt_GetFontNameString(const stbtt_fontinfo *font, int *length, int platformID, int encodingID, int languageID, int nameID);
// returns the string (which may be big-endian double byte, e.g. for unicode)
// and puts the length in bytes in *length.
//
// some of the values for the IDs are below; for more see the truetype spec:
//     http://developer.apple.com/textfonts/TTRefMan/RM06/Chap6name.html
//     http://www.microsoft.com/typography/otspec/name.htm

enum { // platformID
   STBTT_PLATFORM_ID_UNICODE   =0,
   STBTT_PLATFORM_ID_MAC       =1,
   STBTT_PLATFORM_ID_ISO       =2,
   STBTT_PLATFORM_ID_MICROSOFT =3
};

enum { // encodingID for STBTT_PLATFORM_ID_UNICODE
   STBTT_UNICODE_EID_UNICODE_1_0    =0,
   STBTT_UNICODE_EID_UNICODE_1_1    =1,
   STBTT_UNICODE_EID_ISO_10646      =2,
   STBTT_UNICODE_EID_UNICODE_2_0_BMP=3,
   STBTT_UNICODE_EID_UNICODE_2_0_FULL=4
};

enum { // encodingID for STBTT_PLATFORM_ID_MICROSOFT
   STBTT_MS_EID_SYMBOL        =0,
   STBTT_MS_EID_UNICODE_BMP   =1,
   STBTT_MS_EID_SHIFTJIS      =2,
   STBTT_MS_EID_UNICODE_FULL  =10
};

enum { // encodingID for STBTT_PLATFORM_ID_MAC; same as Script Manager codes
   STBTT_MAC_EID_ROMAN        =0,   STBTT_MAC_EID_ARABIC       =4,
   STBTT_MAC_EID_JAPANESE     =1,   STBTT_MAC_EID_HEBREW       =5,
   STBTT_MAC_EID_CHINESE_TRAD =2,   STBTT_MAC_EID_GREEK        =6,
   STBTT_MAC_EID_KOREAN       =3,   STBTT_MAC_EID_RUSSIAN      =7
};

enum { // languageID for STBTT_PLATFORM_ID_MICROSOFT; same as LCID...
       // problematic because there are e.g. 16 english LCIDs and 16 arabic LCIDs
   STBTT_MS_LANG_ENGLISH     =0x0409,   STBTT_MS_LANG_ITALIAN     =0x0410,
   STBTT_MS_LANG_CHINESE     =0x0804,   STBTT_MS_LANG_JAPANESE    =0x0411,
   STBTT_MS_LANG_DUTCH       =0x0413,   STBTT_MS_LANG_KOREAN      =0x0412,
   STBTT_MS_LANG_FRENCH      =0x040c,   STBTT_MS_LANG_RUSSIAN     =0x0419,
   STBTT_MS_LANG_GERMAN      =0x0407,   STBTT_MS_LANG_SPANISH     =0x0409,
   STBTT_MS_LANG_HEBREW      =0x040d,   STBTT_MS_LANG_SWEDISH     =0x041D
};

enum { // languageID for STBTT_PLATFORM_ID_MAC
   STBTT_MAC_LANG_ENGLISH      =0 ,   STBTT_MAC_LANG_JAPANESE     =11,
   STBTT_MAC_LANG_ARABIC       =12,   STBTT_MAC_LANG_KOREAN       =23,
   STBTT_MAC_LANG_DUTCH        =4 ,   STBTT_MAC_LANG_RUSSIAN      =32,
   STBTT_MAC_LANG_FRENCH       =1 ,   STBTT_MAC_LANG_SPANISH      =6 ,
   STBTT_MAC_LANG_GERMAN       =2 ,   STBTT_MAC_LANG_SWEDISH      =5 ,
   STBTT_MAC_LANG_HEBREW       =10,   STBTT_MAC_LANG_CHINESE_SIMPLIFIED =33,
   STBTT_MAC_LANG_ITALIAN      =3 ,   STBTT_MAC_LANG_CHINESE_TRAD =19
};

#ifdef __cplusplus
}
#endif

#endif // __STB_INCLUDE_STB_TRUETYPE_H__

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
////
////   IMPLEMENTATION
////
////

#ifdef STB_TRUETYPE_IMPLEMENTATION

#ifndef STBTT_MAX_OVERSAMPLE
#define STBTT_MAX_OVERSAMPLE   8
#endif

#if STBTT_MAX_OVERSAMPLE > 255
#error "STBTT_MAX_OVERSAMPLE cannot be > 255"
#endif

typedef int stbtt__test_oversample_pow2[(STBTT_MAX_OVERSAMPLE & (STBTT_MAX_OVERSAMPLE-1)) == 0 ? 1 : -1];

#ifndef STBTT_RASTERIZER_VERSION
#define STBTT_RASTERIZER_VERSION 2
#endif

#ifdef _MSC_VER
#define STBTT__NOTUSED(v)  (void)(v)
#else
#define STBTT__NOTUSED(v)  (void)sizeof(v)
#endif

//////////////////////////////////////////////////////////////////////////
//
// stbtt__buf helpers to parse data from file
//

static stbtt_uint8 stbtt__buf_get8(stbtt__buf *b)
{
   if (b->cursor >= b->size)
      return 0;
   return b->data[b->cursor++];
}

static stbtt_uint8 stbtt__buf_peek8(stbtt__buf *b)
{
   if (b->cursor >= b->size)
      return 0;
   return b->data[b->cursor];
}

static void stbtt__buf_seek(stbtt__buf *b, int o)
{
   STBTT_assert(!(o > b->size || o < 0));
   b->cursor = (o > b->size || o < 0) ? b->size : o;
}

static void stbtt__buf_skip(stbtt__buf *b, int o)
{
   stbtt__buf_seek(b, b->cursor + o);
}

static stbtt_uint32 stbtt__buf_get(stbtt__buf *b, int n)
{
   stbtt_uint32 v = 0;
   int i;
   STBTT_assert(n >= 1 && n <= 4);
   for (i = 0; i < n; i++)
      v = (v << 8) | stbtt__buf_get8(b);
   return v;
}

static stbtt__buf stbtt__new_buf(const void *p, size_t size)
{
   stbtt__buf r;
   STBTT_assert(size < 0x40000000);
   r.data = (stbtt_uint8*) p;
   r.size = (int) size;
   r.cursor = 0;
   return r;
}

#define stbtt__buf_get16(b)  stbtt__buf_get((b), 2)
#define stbtt__buf_get32(b)  stbtt__buf_get((b), 4)

static stbtt__buf stbtt__buf_range(const stbtt__buf *b, int o, int s)
{
   stbtt__buf r = stbtt__new_buf(NULL, 0);
   if (o < 0 || s < 0 || o > b->size || s > b->size - o) return r;
   r.data = b->data + o;
   r.size = s;
   return r;
}

static stbtt__buf stbtt__cff_get_index(stbtt__buf *b)
{
   int count, start, offsize;
   start = b->cursor;
   count = stbtt__buf_get16(b);
   if (count) {
      offsize = stbtt__buf_get8(b);
      STBTT_assert(offsize >= 1 && offsize <= 4);
      stbtt__buf_skip(b, offsize * count);
      stbtt__buf_skip(b, stbtt__buf_get(b, offsize) - 1);
   }
   return stbtt__buf_range(b, start, b->cursor - start);
}

static stbtt_uint32 stbtt__cff_int(stbtt__buf *b)
{
   int b0 = stbtt__buf_get8(b);
   if (b0 >= 32 && b0 <= 246)       return b0 - 139;
   else if (b0 >= 247 && b0 <= 250) return (b0 - 247)*256 + stbtt__buf_get8(b) + 108;
   else if (b0 >= 251 && b0 <= 254) return -(b0 - 251)*256 - stbtt__buf_get8(b) - 108;
   else if (b0 == 28)               return stbtt__buf_get16(b);
   else if (b0 == 29)               return stbtt__buf_get32(b);
   STBTT_assert(0);
   return 0;
}

static void stbtt__cff_skip_operand(stbtt__buf *b) {
   int v, b0 = stbtt__buf_peek8(b);
   STBTT_assert(b0 >= 28);
   if (b0 == 30) {
      stbtt__buf_skip(b, 1);
      while (b->cursor < b->size) {
         v = stbtt__buf_get8(b);
         if ((v & 0xF) == 0xF || (v >> 4) == 0xF)
            break;
      }
   } else {
      stbtt__cff_int(b);
   }
}

static stbtt__buf stbtt__dict_get(stbtt__buf *b, int key)
{
   stbtt__buf_seek(b, 0);
   while (b->cursor < b->size) {
      int start = b->cursor, end, op;
      while (stbtt__buf_peek8(b) >= 28)
         stbtt__cff_skip_operand(b);
      end = b->cursor;
      op = stbtt__buf_get8(b);
      if (op == 12)  op = stbtt__buf_get8(b) | 0x100;
      if (op == key) return stbtt__buf_range(b, start, end-start);
   }
   return stbtt__buf_range(b, 0, 0);
}

static void stbtt__dict_get_ints(stbtt__buf *b, int key, int outcount, stbtt_uint32 *out)
{
   int i;
   stbtt__buf operands = stbtt__dict_get(b, key);
   for (i = 0; i < outcount && operands.cursor < operands.size; i++)
      out[i] = stbtt__cff_int(&operands);
}

static int stbtt__cff_index_count(stbtt__buf *b)
{
   stbtt__buf_seek(b, 0);
   return stbtt__buf_get16(b);
}

static stbtt__buf stbtt__cff_index_get(stbtt__buf b, int i)
{
   int count, offsize, start, end;
   stbtt__buf_seek(&b, 0);
   count = stbtt__buf_get16(&b);
   offsize = stbtt__buf_get8(&b);
   STBTT_assert(i >= 0 && i < count);
   STBTT_assert(offsize >= 1 && offsize <= 4);
   stbtt__buf_skip(&b, i*offsize);
   start = stbtt__buf_get(&b, offsize);
   end = stbtt__buf_get(&b, offsize);
   return stbtt__buf_range(&b, 2+(count+1)*offsize+start, end - start);
}

//////////////////////////////////////////////////////////////////////////
//
// accessors to parse data from file
//

// on platforms that don't allow misaligned reads, if we want to allow
// truetype fonts that aren't padded to alignment, define ALLOW_UNALIGNED_TRUETYPE

#define ttBYTE(p)     (* (stbtt_uint8 *) (p))
#define ttCHAR(p)     (* (stbtt_int8 *) (p))
#define ttFixed(p)    ttLONG(p)

static stbtt_uint16 ttUSHORT(stbtt_uint8 *p) { return p[0]*256 + p[1]; }
static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }
static stbtt_uint32 ttULONG(stbtt_uint8 *p)  { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }
static stbtt_int32 ttLONG(stbtt_uint8 *p)    { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }

#define stbtt_tag4(p,c0,c1,c2,c3) ((p)[0] == (c0) && (p)[1] == (c1) && (p)[2] == (c2) && (p)[3] == (c3))
#define stbtt_tag(p,str)           stbtt_tag4(p,str[0],str[1],str[2],str[3])

static int stbtt__isfont(stbtt_uint8 *font)
{
   // check the version number
   if (stbtt_tag4(font, '1',0,0,0))  return 1; // TrueType 1
   if (stbtt_tag(font, "typ1"))   return 1; // TrueType with type 1 font -- we don't support this!
   if (stbtt_tag(font, "OTTO"))   return 1; // OpenType with CFF
   if (stbtt_tag4(font, 0,1,0,0)) return 1; // OpenType 1.0
   if (stbtt_tag(font, "true"))   return 1; // Apple specification for TrueType fonts
   return 0;
}

// @OPTIMIZE: binary search
static stbtt_uint32 stbtt__find_table(stbtt_uint8 *data, stbtt_uint32 fontstart, const char *tag)
{
   stbtt_int32 num_tables = ttUSHORT(data+fontstart+4);
   stbtt_uint32 tabledir = fontstart + 12;
   stbtt_int32 i;
   for (i=0; i < num_tables; ++i) {
      stbtt_uint32 loc = tabledir + 16*i;
      if (stbtt_tag(data+loc+0, tag))
         return ttULONG(data+loc+8);
   }
   return 0;
}

static int stbtt_GetFontOffsetForIndex_internal(unsigned char *font_collection, int index)
{
   // if it's just a font, there's only one valid index
   if (stbtt__isfont(font_collection))
      return index == 0 ? 0 : -1;

   // check if it's a TTC
   if (stbtt_tag(font_collection, "ttcf")) {
      // version 1?
      if (ttULONG(font_collection+4) == 0x00010000 || ttULONG(font_collection+4) == 0x00020000) {
         stbtt_int32 n = ttLONG(font_collection+8);
         if (index >= n)
            return -1;
         return ttULONG(font_collection+12+index*4);
      }
   }
   return -1;
}

static int stbtt_GetNumberOfFonts_internal(unsigned char *font_collection)
{
   // if it's just a font, there's only one valid font
   if (stbtt__isfont(font_collection))
      return 1;

   // check if it's a TTC
   if (stbtt_tag(font_collection, "ttcf")) {
      // version 1?
      if (ttULONG(font_collection+4) == 0x00010000 || ttULONG(font_collection+4) == 0x00020000) {
         return ttLONG(font_collection+8);
      }
   }
   return 0;
}

static stbtt__buf stbtt__get_subrs(stbtt__buf cff, stbtt__buf fontdict)
{
   stbtt_uint32 subrsoff = 0, private_loc[2] = { 0, 0 };
   stbtt__buf pdict;
   stbtt__dict_get_ints(&fontdict, 18, 2, private_loc);
   if (!private_loc[1] || !private_loc[0]) return stbtt__new_buf(NULL, 0);
   pdict = stbtt__buf_range(&cff, private_loc[1], private_loc[0]);
   stbtt__dict_get_ints(&pdict, 19, 1, &subrsoff);
   if (!subrsoff) return stbtt__new_buf(NULL, 0);
   stbtt__buf_seek(&cff, private_loc[1]+subrsoff);
   return stbtt__cff_get_index(&cff);
}

static int stbtt_InitFont_internal(stbtt_fontinfo *info, unsigned char *data, int fontstart)
{
   stbtt_uint32 cmap, t;
   stbtt_int32 i,numTables;

   info->data = data;
   info->fontstart = fontstart;
   info->cff = stbtt__new_buf(NULL, 0);

   cmap = stbtt__find_table(data, fontstart, "cmap");       // required
   info->loca = stbtt__find_table(data, fontstart, "loca"); // required
   info->head = stbtt__find_table(data, fontstart, "head"); // required
   info->glyf = stbtt__find_table(data, fontstart, "glyf"); // required
   info->hhea = stbtt__find_table(data, fontstart, "hhea"); // required
   info->hmtx = stbtt__find_table(data, fontstart, "hmtx"); // required
   info->kern = stbtt__find_table(data, fontstart, "kern"); // not required
   info->gpos = stbtt__find_table(data, fontstart, "GPOS"); // not required

   if (!cmap || !info->head || !info->hhea || !info->hmtx)
      return 0;
   if (info->glyf) {
      // required for truetype
      if (!info->loca) return 0;
   } else {
      // initialization for CFF / Type2 fonts (OTF)
      stbtt__buf b, topdict, topdictidx;
      stbtt_uint32 cstype = 2, charstrings = 0, fdarrayoff = 0, fdselectoff = 0;
      stbtt_uint32 cff;

      cff = stbtt__find_table(data, fontstart, "CFF ");
      if (!cff) return 0;

      info->fontdicts = stbtt__new_buf(NULL, 0);
      info->fdselect = stbtt__new_buf(NULL, 0);

      // @TODO this should use size from table (not 512MB)
      info->cff = stbtt__new_buf(data+cff, 512*1024*1024);
      b = info->cff;

      // read the header
      stbtt__buf_skip(&b, 2);
      stbtt__buf_seek(&b, stbtt__buf_get8(&b)); // hdrsize

      // @TODO the name INDEX could list multiple fonts,
      // but we just use the first one.
      stbtt__cff_get_index(&b);  // name INDEX
      topdictidx = stbtt__cff_get_index(&b);
      topdict = stbtt__cff_index_get(topdictidx, 0);
      stbtt__cff_get_index(&b);  // string INDEX
      info->gsubrs = stbtt__cff_get_index(&b);

      stbtt__dict_get_ints(&topdict, 17, 1, &charstrings);
      stbtt__dict_get_ints(&topdict, 0x100 | 6, 1, &cstype);
      stbtt__dict_get_ints(&topdict, 0x100 | 36, 1, &fdarrayoff);
      stbtt__dict_get_ints(&topdict, 0x100 | 37, 1, &fdselectoff);
      info->subrs = stbtt__get_subrs(b, topdict);

      // we only support Type 2 charstrings
      if (cstype != 2) return 0;
      if (charstrings == 0) return 0;

      if (fdarrayoff) {
         // looks like a CID font
         if (!fdselectoff) return 0;
         stbtt__buf_seek(&b, fdarrayoff);
         info->fontdicts = stbtt__cff_get_index(&b);
         info->fdselect = stbtt__buf_range(&b, fdselectoff, b.size-fdselectoff);
      }

      stbtt__buf_seek(&b, charstrings);
      info->charstrings = stbtt__cff_get_index(&b);
   }

   t = stbtt__find_table(data, fontstart, "maxp");
   if (t)
      info->numGlyphs = ttUSHORT(data+t+4);
   else
      info->numGlyphs = 0xffff;

   // find a cmap encoding table we understand *now* to avoid searching
   // later. (todo: could make this installable)
   // the same regardless of glyph.
   numTables = ttUSHORT(data + cmap + 2);
   info->index_map = 0;
   for (i=0; i < numTables; ++i) {
      stbtt_uint32 encoding_record = cmap + 4 + 8 * i;
      // find an encoding we understand:
      switch(ttUSHORT(data+encoding_record)) {
         case STBTT_PLATFORM_ID_MICROSOFT:
            switch (ttUSHORT(data+encoding_record+2)) {
               case STBTT_MS_EID_UNICODE_BMP:
               case STBTT_MS_EID_UNICODE_FULL:
                  // MS/Unicode
                  info->index_map = cmap + ttULONG(data+encoding_record+4);
                  break;
            }
            break;
        case STBTT_PLATFORM_ID_UNICODE:
            // Mac/iOS has these
            // all the encodingIDs are unicode, so we don't bother to check it
            info->index_map = cmap + ttULONG(data+encoding_record+4);
            break;
      }
   }
   if (info->index_map == 0)
      return 0;

   info->indexToLocFormat = ttUSHORT(data+info->head + 50);
   return 1;
}

STBTT_DEF int stbtt_FindGlyphIndex(const stbtt_fontinfo *info, int unicode_codepoint)
{
   stbtt_uint8 *data = info->data;
   stbtt_uint32 index_map = info->index_map;

   stbtt_uint16 format = ttUSHORT(data + index_map + 0);
   if (format == 0) { // apple byte encoding
      stbtt_int32 bytes = ttUSHORT(data + index_map + 2);
      if (unicode_codepoint < bytes-6)
         return ttBYTE(data + index_map + 6 + unicode_codepoint);
      return 0;
   } else if (format == 6) {
      stbtt_uint32 first = ttUSHORT(data + index_map + 6);
      stbtt_uint32 count = ttUSHORT(data + index_map + 8);
      if ((stbtt_uint32) unicode_codepoint >= first && (stbtt_uint32) unicode_codepoint < first+count)
         return ttUSHORT(data + index_map + 10 + (unicode_codepoint - first)*2);
      return 0;
   } else if (format == 2) {
      STBTT_assert(0); // @TODO: high-byte mapping for japanese/chinese/korean
      return 0;
   } else if (format == 4) { // standard mapping for windows fonts: binary search collection of ranges
      stbtt_uint16 segcount = ttUSHORT(data+index_map+6) >> 1;
      stbtt_uint16 searchRange = ttUSHORT(data+index_map+8) >> 1;
      stbtt_uint16 entrySelector = ttUSHORT(data+index_map+10);
      stbtt_uint16 rangeShift = ttUSHORT(data+index_map+12) >> 1;

      // do a binary search of the segments
      stbtt_uint32 endCount = index_map + 14;
      stbtt_uint32 search = endCount;

      if (unicode_codepoint > 0xffff)
         return 0;

      // they lie from endCount .. endCount + segCount
      // but searchRange is the nearest power of two, so...
      if (unicode_codepoint >= ttUSHORT(data + search + rangeShift*2))
         search += rangeShift*2;

      // now decrement to bias correctly to find smallest
      search -= 2;
      while (entrySelector) {
         stbtt_uint16 end;
         searchRange >>= 1;
         end = ttUSHORT(data + search + searchRange*2);
         if (unicode_codepoint > end)
            search += searchRange*2;
         --entrySelector;
      }
      search += 2;

      {
         stbtt_uint16 offset, start;
         stbtt_uint16 item = (stbtt_uint16) ((search - endCount) >> 1);

         STBTT_assert(unicode_codepoint <= ttUSHORT(data + endCount + 2*item));
         start = ttUSHORT(data + index_map + 14 + segcount*2 + 2 + 2*item);
         if (unicode_codepoint < start)
            return 0;

         offset = ttUSHORT(data + index_map + 14 + segcount*6 + 2 + 2*item);
         if (offset == 0)
            return (stbtt_uint16) (unicode_codepoint + ttSHORT(data + index_map + 14 + segcount*4 + 2 + 2*item));

         return ttUSHORT(data + offset + (unicode_codepoint-start)*2 + index_map + 14 + segcount*6 + 2 + 2*item);
      }
   } else if (format == 12 || format == 13) {
      stbtt_uint32 ngroups = ttULONG(data+index_map+12);
      stbtt_int32 low,high;
      low = 0; high = (stbtt_int32)ngroups;
      // Binary search the right group.
      while (low < high) {
         stbtt_int32 mid = low + ((high-low) >> 1); // rounds down, so low <= mid < high
         stbtt_uint32 start_char = ttULONG(data+index_map+16+mid*12);
         stbtt_uint32 end_char = ttULONG(data+index_map+16+mid*12+4);
         if ((stbtt_uint32) unicode_codepoint < start_char)
            high = mid;
         else if ((stbtt_uint32) unicode_codepoint > end_char)
            low = mid+1;
         else {
            stbtt_uint32 start_glyph = ttULONG(data+index_map+16+mid*12+8);
            if (format == 12)
               return start_glyph + unicode_codepoint-start_char;
            else // format == 13
               return start_glyph;
         }
      }
      return 0; // not found
   }
   // @TODO
   STBTT_assert(0);
   return 0;
}

STBTT_DEF int stbtt_GetCodepointShape(const stbtt_fontinfo *info, int unicode_codepoint, stbtt_vertex **vertices)
{
   return stbtt_GetGlyphShape(info, stbtt_FindGlyphIndex(info, unicode_codepoint), vertices);
}

static void stbtt_setvertex(stbtt_vertex *v, stbtt_uint8 type, stbtt_int32 x, stbtt_int32 y, stbtt_int32 cx, stbtt_int32 cy)
{
   v->type = type;
   v->x = (stbtt_int16) x;
   v->y = (stbtt_int16) y;
   v->cx = (stbtt_int16) cx;
   v->cy = (stbtt_int16) cy;
}

static int stbtt__GetGlyfOffset(const stbtt_fontinfo *info, int glyph_index)
{
   int g1,g2;

   STBTT_assert(!info->cff.size);

   if (glyph_index >= info->numGlyphs) return -1; // glyph index out of range
   if (info->indexToLocFormat >= 2)    return -1; // unknown index->glyph map format

   if (info->indexToLocFormat == 0) {
      g1 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2) * 2;
      g2 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2 + 2) * 2;
   } else {
      g1 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4);
      g2 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4 + 4);
   }

   return g1==g2 ? -1 : g1; // if length is 0, return -1
}

static int stbtt__GetGlyphInfoT2(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1);

STBTT_DEF int stbtt_GetGlyphBox(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1)
{
   if (info->cff.size) {
      stbtt__GetGlyphInfoT2(info, glyph_index, x0, y0, x1, y1);
   } else {
      int g = stbtt__GetGlyfOffset(info, glyph_index);
      if (g < 0) return 0;

      if (x0) *x0 = ttSHORT(info->data + g + 2);
      if (y0) *y0 = ttSHORT(info->data + g + 4);
      if (x1) *x1 = ttSHORT(info->data + g + 6);
      if (y1) *y1 = ttSHORT(info->data + g + 8);
   }
   return 1;
}

STBTT_DEF int stbtt_GetCodepointBox(const stbtt_fontinfo *info, int codepoint, int *x0, int *y0, int *x1, int *y1)
{
   return stbtt_GetGlyphBox(info, stbtt_FindGlyphIndex(info,codepoint), x0,y0,x1,y1);
}

STBTT_DEF int stbtt_IsGlyphEmpty(const stbtt_fontinfo *info, int glyph_index)
{
   stbtt_int16 numberOfContours;
   int g;
   if (info->cff.size)
      return stbtt__GetGlyphInfoT2(info, glyph_index, NULL, NULL, NULL, NULL) == 0;
   g = stbtt__GetGlyfOffset(info, glyph_index);
   if (g < 0) return 1;
   numberOfContours = ttSHORT(info->data + g);
   return numberOfContours == 0;
}

static int stbtt__close_shape(stbtt_vertex *vertices, int num_vertices, int was_off, int start_off,
    stbtt_int32 sx, stbtt_int32 sy, stbtt_int32 scx, stbtt_int32 scy, stbtt_int32 cx, stbtt_int32 cy)
{
   if (start_off) {
      if (was_off)
         stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+scx)>>1, (cy+scy)>>1, cx,cy);
      stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, sx,sy,scx,scy);
   } else {
      if (was_off)
         stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve,sx,sy,cx,cy);
      else
         stbtt_setvertex(&vertices[num_vertices++], STBTT_vline,sx,sy,0,0);
   }
   return num_vertices;
}

static int stbtt__GetGlyphShapeTT(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)
{
   stbtt_int16 numberOfContours;
   stbtt_uint8 *endPtsOfContours;
   stbtt_uint8 *data = info->data;
   stbtt_vertex *vertices=0;
   int num_vertices=0;
   int g = stbtt__GetGlyfOffset(info, glyph_index);

   *pvertices = NULL;

   if (g < 0) return 0;

   numberOfContours = ttSHORT(data + g);

   if (numberOfContours > 0) {
      stbtt_uint8 flags=0,flagcount;
      stbtt_int32 ins, i,j=0,m,n, next_move, was_off=0, off, start_off=0;
      stbtt_int32 x,y,cx,cy,sx,sy, scx,scy;
      stbtt_uint8 *points;
      endPtsOfContours = (data + g + 10);
      ins = ttUSHORT(data + g + 10 + numberOfContours * 2);
      points = data + g + 10 + numberOfContours * 2 + 2 + ins;

      n = 1+ttUSHORT(endPtsOfContours + numberOfContours*2-2);

      m = n + 2*numberOfContours;  // a loose bound on how many vertices we might need
      vertices = (stbtt_vertex *) STBTT_malloc(m * sizeof(vertices[0]), info->userdata);
      if (vertices == 0)
         return 0;

      next_move = 0;
      flagcount=0;

      // in first pass, we load uninterpreted data into the allocated array
      // above, shifted to the end of the array so we won't overwrite it when
      // we create our final data starting from the front

      off = m - n; // starting offset for uninterpreted data, regardless of how m ends up being calculated

      // first load flags

      for (i=0; i < n; ++i) {
         if (flagcount == 0) {
            flags = *points++;
            if (flags & 8)
               flagcount = *points++;
         } else
            --flagcount;
         vertices[off+i].type = flags;
      }

      // now load x coordinates
      x=0;
      for (i=0; i < n; ++i) {
         flags = vertices[off+i].type;
         if (flags & 2) {
            stbtt_int16 dx = *points++;
            x += (flags & 16) ? dx : -dx; // ???
         } else {
            if (!(flags & 16)) {
               x = x + (stbtt_int16) (points[0]*256 + points[1]);
               points += 2;
            }
         }
         vertices[off+i].x = (stbtt_int16) x;
      }

      // now load y coordinates
      y=0;
      for (i=0; i < n; ++i) {
         flags = vertices[off+i].type;
         if (flags & 4) {
            stbtt_int16 dy = *points++;
            y += (flags & 32) ? dy : -dy; // ???
         } else {
            if (!(flags & 32)) {
               y = y + (stbtt_int16) (points[0]*256 + points[1]);
               points += 2;
            }
         }
         vertices[off+i].y = (stbtt_int16) y;
      }

      // now convert them to our format
      num_vertices=0;
      sx = sy = cx = cy = scx = scy = 0;
      for (i=0; i < n; ++i) {
         flags = vertices[off+i].type;
         x     = (stbtt_int16) vertices[off+i].x;
         y     = (stbtt_int16) vertices[off+i].y;

         if (next_move == i) {
            if (i != 0)
               num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx,sy,scx,scy,cx,cy);

            // now start the new one               
            start_off = !(flags & 1);
            if (start_off) {
               // if we start off with an off-curve point, then when we need to find a point on the curve
               // where we can start, and we need to save some state for when we wraparound.
               scx = x;
               scy = y;
               if (!(vertices[off+i+1].type & 1)) {
                  // next point is also a curve point, so interpolate an on-point curve
                  sx = (x + (stbtt_int32) vertices[off+i+1].x) >> 1;
                  sy = (y + (stbtt_int32) vertices[off+i+1].y) >> 1;
               } else {
                  // otherwise just use the next point as our start point
                  sx = (stbtt_int32) vertices[off+i+1].x;
                  sy = (stbtt_int32) vertices[off+i+1].y;
                  ++i; // we're using point i+1 as the starting point, so skip it
               }
            } else {
               sx = x;
               sy = y;
            }
            stbtt_setvertex(&vertices[num_vertices++], STBTT_vmove,sx,sy,0,0);
            was_off = 0;
            next_move = 1 + ttUSHORT(endPtsOfContours+j*2);
            ++j;
         } else {
            if (!(flags & 1)) { // if it's a curve
               if (was_off) // two off-curve control points in a row means interpolate an on-curve midpoint
                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+x)>>1, (cy+y)>>1, cx, cy);
               cx = x;
               cy = y;
               was_off = 1;
            } else {
               if (was_off)
                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, x,y, cx, cy);
               else
                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vline, x,y,0,0);
               was_off = 0;
            }
         }
      }
      num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx,sy,scx,scy,cx,cy);
   } else if (numberOfContours == -1) {
      // Compound shapes.
      int more = 1;
      stbtt_uint8 *comp = data + g + 10;
      num_vertices = 0;
      vertices = 0;
      while (more) {
         stbtt_uint16 flags, gidx;
         int comp_num_verts = 0, i;
         stbtt_vertex *comp_verts = 0, *tmp = 0;
         float mtx[6] = {1,0,0,1,0,0}, m, n;
         
         flags = ttSHORT(comp); comp+=2;
         gidx = ttSHORT(comp); comp+=2;

         if (flags & 2) { // XY values
            if (flags & 1) { // shorts
               mtx[4] = ttSHORT(comp); comp+=2;
               mtx[5] = ttSHORT(comp); comp+=2;
            } else {
               mtx[4] = ttCHAR(comp); comp+=1;
               mtx[5] = ttCHAR(comp); comp+=1;
            }
         }
         else {
            // @TODO handle matching point
            STBTT_assert(0);
         }
         if (flags & (1<<3)) { // WE_HAVE_A_SCALE
            mtx[0] = mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;
            mtx[1] = mtx[2] = 0;
         } else if (flags & (1<<6)) { // WE_HAVE_AN_X_AND_YSCALE
            mtx[0] = ttSHORT(comp)/16384.0f; comp+=2;
            mtx[1] = mtx[2] = 0;
            mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;
         } else if (flags & (1<<7)) { // WE_HAVE_A_TWO_BY_TWO
            mtx[0] = ttSHORT(comp)/16384.0f; comp+=2;
            mtx[1] = ttSHORT(comp)/16384.0f; comp+=2;
            mtx[2] = ttSHORT(comp)/16384.0f; comp+=2;
            mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;
         }
         
         // Find transformation scales.
         m = (float) STBTT_sqrt(mtx[0]*mtx[0] + mtx[1]*mtx[1]);
         n = (float) STBTT_sqrt(mtx[2]*mtx[2] + mtx[3]*mtx[3]);

         // Get indexed glyph.
         comp_num_verts = stbtt_GetGlyphShape(info, gidx, &comp_verts);
         if (comp_num_verts > 0) {
            // Transform vertices.
            for (i = 0; i < comp_num_verts; ++i) {
               stbtt_vertex* v = &comp_verts[i];
               stbtt_vertex_type x,y;
               x=v->x; y=v->y;
               v->x = (stbtt_vertex_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));
               v->y = (stbtt_vertex_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));
               x=v->cx; y=v->cy;
               v->cx = (stbtt_vertex_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));
               v->cy = (stbtt_vertex_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));
            }
            // Append vertices.
            tmp = (stbtt_vertex*)STBTT_malloc((num_vertices+comp_num_verts)*sizeof(stbtt_vertex), info->userdata);
            if (!tmp) {
               if (vertices) STBTT_free(vertices, info->userdata);
               if (comp_verts) STBTT_free(comp_verts, info->userdata);
               return 0;
            }
            if (num_vertices > 0) STBTT_memcpy(tmp, vertices, num_vertices*sizeof(stbtt_vertex)); //-V595
            STBTT_memcpy(tmp+num_vertices, comp_verts, comp_num_verts*sizeof(stbtt_vertex));
            if (vertices) STBTT_free(vertices, info->userdata);
            vertices = tmp;
            STBTT_free(comp_verts, info->userdata);
            num_vertices += comp_num_verts;
         }
         // More components ?
         more = flags & (1<<5);
      }
   } else if (numberOfContours < 0) {
      // @TODO other compound variations?
      STBTT_assert(0);
   } else {
      // numberOfCounters == 0, do nothing
   }

   *pvertices = vertices;
   return num_vertices;
}

typedef struct
{
   int bounds;
   int started;
   float first_x, first_y;
   float x, y;
   stbtt_int32 min_x, max_x, min_y, max_y;

   stbtt_vertex *pvertices;
   int num_vertices;
} stbtt__csctx;

#define STBTT__CSCTX_INIT(bounds) {bounds,0, 0,0, 0,0, 0,0,0,0, NULL, 0}

static void stbtt__track_vertex(stbtt__csctx *c, stbtt_int32 x, stbtt_int32 y)
{
   if (x > c->max_x || !c->started) c->max_x = x;
   if (y > c->max_y || !c->started) c->max_y = y;
   if (x < c->min_x || !c->started) c->min_x = x;
   if (y < c->min_y || !c->started) c->min_y = y;
   c->started = 1;
}

static void stbtt__csctx_v(stbtt__csctx *c, stbtt_uint8 type, stbtt_int32 x, stbtt_int32 y, stbtt_int32 cx, stbtt_int32 cy, stbtt_int32 cx1, stbtt_int32 cy1)
{
   if (c->bounds) {
      stbtt__track_vertex(c, x, y);
      if (type == STBTT_vcubic) {
         stbtt__track_vertex(c, cx, cy);
         stbtt__track_vertex(c, cx1, cy1);
      }
   } else {
      stbtt_setvertex(&c->pvertices[c->num_vertices], type, x, y, cx, cy);
      c->pvertices[c->num_vertices].cx1 = (stbtt_int16) cx1;
      c->pvertices[c->num_vertices].cy1 = (stbtt_int16) cy1;
   }
   c->num_vertices++;
}

static void stbtt__csctx_close_shape(stbtt__csctx *ctx)
{
   if (ctx->first_x != ctx->x || ctx->first_y != ctx->y)
      stbtt__csctx_v(ctx, STBTT_vline, (int)ctx->first_x, (int)ctx->first_y, 0, 0, 0, 0);
}

static void stbtt__csctx_rmove_to(stbtt__csctx *ctx, float dx, float dy)
{
   stbtt__csctx_close_shape(ctx);
   ctx->first_x = ctx->x = ctx->x + dx;
   ctx->first_y = ctx->y = ctx->y + dy;
   stbtt__csctx_v(ctx, STBTT_vmove, (int)ctx->x, (int)ctx->y, 0, 0, 0, 0);
}

static void stbtt__csctx_rline_to(stbtt__csctx *ctx, float dx, float dy)
{
   ctx->x += dx;
   ctx->y += dy;
   stbtt__csctx_v(ctx, STBTT_vline, (int)ctx->x, (int)ctx->y, 0, 0, 0, 0);
}

static void stbtt__csctx_rccurve_to(stbtt__csctx *ctx, float dx1, float dy1, float dx2, float dy2, float dx3, float dy3)
{
   float cx1 = ctx->x + dx1;
   float cy1 = ctx->y + dy1;
   float cx2 = cx1 + dx2;
   float cy2 = cy1 + dy2;
   ctx->x = cx2 + dx3;
   ctx->y = cy2 + dy3;
   stbtt__csctx_v(ctx, STBTT_vcubic, (int)ctx->x, (int)ctx->y, (int)cx1, (int)cy1, (int)cx2, (int)cy2);
}

static stbtt__buf stbtt__get_subr(stbtt__buf idx, int n)
{
   int count = stbtt__cff_index_count(&idx);
   int bias = 107;
   if (count >= 33900)
      bias = 32768;
   else if (count >= 1240)
      bias = 1131;
   n += bias;
   if (n < 0 || n >= count)
      return stbtt__new_buf(NULL, 0);
   return stbtt__cff_index_get(idx, n);
}

static stbtt__buf stbtt__cid_get_glyph_subrs(const stbtt_fontinfo *info, int glyph_index)
{
   stbtt__buf fdselect = info->fdselect;
   int nranges, start, end, v, fmt, fdselector = -1, i;

   stbtt__buf_seek(&fdselect, 0);
   fmt = stbtt__buf_get8(&fdselect);
   if (fmt == 0) {
      // untested
      stbtt__buf_skip(&fdselect, glyph_index);
      fdselector = stbtt__buf_get8(&fdselect);
   } else if (fmt == 3) {
      nranges = stbtt__buf_get16(&fdselect);
      start = stbtt__buf_get16(&fdselect);
      for (i = 0; i < nranges; i++) {
         v = stbtt__buf_get8(&fdselect);
         end = stbtt__buf_get16(&fdselect);
         if (glyph_index >= start && glyph_index < end) {
            fdselector = v;
            break;
         }
         start = end;
      }
   }
   if (fdselector == -1) stbtt__new_buf(NULL, 0);
   return stbtt__get_subrs(info->cff, stbtt__cff_index_get(info->fontdicts, fdselector));
}

static int stbtt__run_charstring(const stbtt_fontinfo *info, int glyph_index, stbtt__csctx *c)
{
   int in_header = 1, maskbits = 0, subr_stack_height = 0, sp = 0, v, i, b0;
   int has_subrs = 0, clear_stack;
   float s[48];
   stbtt__buf subr_stack[10], subrs = info->subrs, b;
   float f;

#define STBTT__CSERR(s) (0)

   // this currently ignores the initial width value, which isn't needed if we have hmtx
   b = stbtt__cff_index_get(info->charstrings, glyph_index);
   while (b.cursor < b.size) {
      i = 0;
      clear_stack = 1;
      b0 = stbtt__buf_get8(&b);
      switch (b0) {
      // @TODO implement hinting
      case 0x13: // hintmask
      case 0x14: // cntrmask
         if (in_header)
            maskbits += (sp / 2); // implicit "vstem"
         in_header = 0;
         stbtt__buf_skip(&b, (maskbits + 7) / 8);
         break;

      case 0x01: // hstem
      case 0x03: // vstem
      case 0x12: // hstemhm
      case 0x17: // vstemhm
         maskbits += (sp / 2);
         break;

      case 0x15: // rmoveto
         in_header = 0;
         if (sp < 2) return STBTT__CSERR("rmoveto stack");
         stbtt__csctx_rmove_to(c, s[sp-2], s[sp-1]);
         break;
      case 0x04: // vmoveto
         in_header = 0;
         if (sp < 1) return STBTT__CSERR("vmoveto stack");
         stbtt__csctx_rmove_to(c, 0, s[sp-1]);
         break;
      case 0x16: // hmoveto
         in_header = 0;
         if (sp < 1) return STBTT__CSERR("hmoveto stack");
         stbtt__csctx_rmove_to(c, s[sp-1], 0);
         break;

      case 0x05: // rlineto
         if (sp < 2) return STBTT__CSERR("rlineto stack");
         for (; i + 1 < sp; i += 2)
            stbtt__csctx_rline_to(c, s[i], s[i+1]);
         break;

      // hlineto/vlineto and vhcurveto/hvcurveto alternate horizontal and vertical
      // starting from a different place.

      case 0x07: // vlineto
         if (sp < 1) return STBTT__CSERR("vlineto stack");
         goto vlineto;
      case 0x06: // hlineto
         if (sp < 1) return STBTT__CSERR("hlineto stack");
         for (;;) {
            if (i >= sp) break;
            stbtt__csctx_rline_to(c, s[i], 0);
            i++;
      vlineto:
            if (i >= sp) break;
            stbtt__csctx_rline_to(c, 0, s[i]);
            i++;
         }
         break;

      case 0x1F: // hvcurveto
         if (sp < 4) return STBTT__CSERR("hvcurveto stack");
         goto hvcurveto;
      case 0x1E: // vhcurveto
         if (sp < 4) return STBTT__CSERR("vhcurveto stack");
         for (;;) {
            if (i + 3 >= sp) break;
            stbtt__csctx_rccurve_to(c, 0, s[i], s[i+1], s[i+2], s[i+3], (sp - i == 5) ? s[i + 4] : 0.0f);
            i += 4;
      hvcurveto:
            if (i + 3 >= sp) break;
            stbtt__csctx_rccurve_to(c, s[i], 0, s[i+1], s[i+2], (sp - i == 5) ? s[i+4] : 0.0f, s[i+3]);
            i += 4;
         }
         break;

      case 0x08: // rrcurveto
         if (sp < 6) return STBTT__CSERR("rcurveline stack");
         for (; i + 5 < sp; i += 6)
            stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);
         break;

      case 0x18: // rcurveline
         if (sp < 8) return STBTT__CSERR("rcurveline stack");
         for (; i + 5 < sp - 2; i += 6)
            stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);
         if (i + 1 >= sp) return STBTT__CSERR("rcurveline stack");
         stbtt__csctx_rline_to(c, s[i], s[i+1]);
         break;

      case 0x19: // rlinecurve
         if (sp < 8) return STBTT__CSERR("rlinecurve stack");
         for (; i + 1 < sp - 6; i += 2)
            stbtt__csctx_rline_to(c, s[i], s[i+1]);
         if (i + 5 >= sp) return STBTT__CSERR("rlinecurve stack");
         stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);
         break;

      case 0x1A: // vvcurveto
      case 0x1B: // hhcurveto
         if (sp < 4) return STBTT__CSERR("(vv|hh)curveto stack");
         f = 0.0;
         if (sp & 1) { f = s[i]; i++; }
         for (; i + 3 < sp; i += 4) {
            if (b0 == 0x1B)
               stbtt__csctx_rccurve_to(c, s[i], f, s[i+1], s[i+2], s[i+3], 0.0);
            else
               stbtt__csctx_rccurve_to(c, f, s[i], s[i+1], s[i+2], 0.0, s[i+3]);
            f = 0.0;
         }
         break;

      case 0x0A: // callsubr
         if (!has_subrs) {
            if (info->fdselect.size)
               subrs = stbtt__cid_get_glyph_subrs(info, glyph_index);
            has_subrs = 1;
         }
         // fallthrough
      case 0x1D: // callgsubr
         if (sp < 1) return STBTT__CSERR("call(g|)subr stack");
         v = (int) s[--sp];
         if (subr_stack_height >= 10) return STBTT__CSERR("recursion limit");
         subr_stack[subr_stack_height++] = b;
         b = stbtt__get_subr(b0 == 0x0A ? subrs : info->gsubrs, v);
         if (b.size == 0) return STBTT__CSERR("subr not found");
         b.cursor = 0;
         clear_stack = 0;
         break;

      case 0x0B: // return
         if (subr_stack_height <= 0) return STBTT__CSERR("return outside subr");
         b = subr_stack[--subr_stack_height];
         clear_stack = 0;
         break;

      case 0x0E: // endchar
         stbtt__csctx_close_shape(c);
         return 1;

      case 0x0C: { // two-byte escape
         float dx1, dx2, dx3, dx4, dx5, dx6, dy1, dy2, dy3, dy4, dy5, dy6;
         float dx, dy;
         int b1 = stbtt__buf_get8(&b);
         switch (b1) {
         // @TODO These "flex" implementations ignore the flex-depth and resolution,
         // and always draw beziers.
         case 0x22: // hflex
            if (sp < 7) return STBTT__CSERR("hflex stack");
            dx1 = s[0];
            dx2 = s[1];
            dy2 = s[2];
            dx3 = s[3];
            dx4 = s[4];
            dx5 = s[5];
            dx6 = s[6];
            stbtt__csctx_rccurve_to(c, dx1, 0, dx2, dy2, dx3, 0);
            stbtt__csctx_rccurve_to(c, dx4, 0, dx5, -dy2, dx6, 0);
            break;

         case 0x23: // flex
            if (sp < 13) return STBTT__CSERR("flex stack");
            dx1 = s[0];
            dy1 = s[1];
            dx2 = s[2];
            dy2 = s[3];
            dx3 = s[4];
            dy3 = s[5];
            dx4 = s[6];
            dy4 = s[7];
            dx5 = s[8];
            dy5 = s[9];
            dx6 = s[10];
            dy6 = s[11];
            //fd is s[12]
            stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, dy3);
            stbtt__csctx_rccurve_to(c, dx4, dy4, dx5, dy5, dx6, dy6);
            break;

         case 0x24: // hflex1
            if (sp < 9) return STBTT__CSERR("hflex1 stack");
            dx1 = s[0];
            dy1 = s[1];
            dx2 = s[2];
            dy2 = s[3];
            dx3 = s[4];
            dx4 = s[5];
            dx5 = s[6];
            dy5 = s[7];
            dx6 = s[8];
            stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, 0);
            stbtt__csctx_rccurve_to(c, dx4, 0, dx5, dy5, dx6, -(dy1+dy2+dy5));
            break;

         case 0x25: // flex1
            if (sp < 11) return STBTT__CSERR("flex1 stack");
            dx1 = s[0];
            dy1 = s[1];
            dx2 = s[2];
            dy2 = s[3];
            dx3 = s[4];
            dy3 = s[5];
            dx4 = s[6];
            dy4 = s[7];
            dx5 = s[8];
            dy5 = s[9];
            dx6 = dy6 = s[10];
            dx = dx1+dx2+dx3+dx4+dx5;
            dy = dy1+dy2+dy3+dy4+dy5;
            if (STBTT_fabs(dx) > STBTT_fabs(dy))
               dy6 = -dy;
            else
               dx6 = -dx;
            stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, dy3);
            stbtt__csctx_rccurve_to(c, dx4, dy4, dx5, dy5, dx6, dy6);
            break;

         default:
            return STBTT__CSERR("unimplemented");
         }
      } break;

      default:
         if (b0 != 255 && b0 != 28 && (b0 < 32 || b0 > 254)) //-V560
            return STBTT__CSERR("reserved operator");

         // push immediate
         if (b0 == 255) {
            f = (float)(stbtt_int32)stbtt__buf_get32(&b) / 0x10000;
         } else {
            stbtt__buf_skip(&b, -1);
            f = (float)(stbtt_int16)stbtt__cff_int(&b);
         }
         if (sp >= 48) return STBTT__CSERR("push stack overflow");
         s[sp++] = f;
         clear_stack = 0;
         break;
      }
      if (clear_stack) sp = 0;
   }
   return STBTT__CSERR("no endchar");

#undef STBTT__CSERR
}

static int stbtt__GetGlyphShapeT2(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)
{
   // runs the charstring twice, once to count and once to output (to avoid realloc)
   stbtt__csctx count_ctx = STBTT__CSCTX_INIT(1);
   stbtt__csctx output_ctx = STBTT__CSCTX_INIT(0);
   if (stbtt__run_charstring(info, glyph_index, &count_ctx)) {
      *pvertices = (stbtt_vertex*)STBTT_malloc(count_ctx.num_vertices*sizeof(stbtt_vertex), info->userdata);
      output_ctx.pvertices = *pvertices;
      if (stbtt__run_charstring(info, glyph_index, &output_ctx)) {
         STBTT_assert(output_ctx.num_vertices == count_ctx.num_vertices);
         return output_ctx.num_vertices;
      }
   }
   *pvertices = NULL;
   return 0;
}

static int stbtt__GetGlyphInfoT2(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1)
{
   stbtt__csctx c = STBTT__CSCTX_INIT(1);
   int r = stbtt__run_charstring(info, glyph_index, &c);
   if (x0)  *x0 = r ? c.min_x : 0;
   if (y0)  *y0 = r ? c.min_y : 0;
   if (x1)  *x1 = r ? c.max_x : 0;
   if (y1)  *y1 = r ? c.max_y : 0;
   return r ? c.num_vertices : 0;
}

STBTT_DEF int stbtt_GetGlyphShape(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)
{
   if (!info->cff.size)
      return stbtt__GetGlyphShapeTT(info, glyph_index, pvertices);
   else
      return stbtt__GetGlyphShapeT2(info, glyph_index, pvertices);
}

STBTT_DEF void stbtt_GetGlyphHMetrics(const stbtt_fontinfo *info, int glyph_index, int *advanceWidth, int *leftSideBearing)
{
   stbtt_uint16 numOfLongHorMetrics = ttUSHORT(info->data+info->hhea + 34);
   if (glyph_index < numOfLongHorMetrics) {
      if (advanceWidth)     *advanceWidth    = ttSHORT(info->data + info->hmtx + 4*glyph_index);
      if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4*glyph_index + 2);
   } else {
      if (advanceWidth)     *advanceWidth    = ttSHORT(info->data + info->hmtx + 4*(numOfLongHorMetrics-1));
      if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4*numOfLongHorMetrics + 2*(glyph_index - numOfLongHorMetrics));
   }
}

static int  stbtt__GetGlyphKernInfoAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2)
{
   stbtt_uint8 *data = info->data + info->kern;
   stbtt_uint32 needle, straw;
   int l, r, m;

   // we only look at the first table. it must be 'horizontal' and format 0.
   if (!info->kern)
      return 0;
   if (ttUSHORT(data+2) < 1) // number of tables, need at least 1
      return 0;
   if (ttUSHORT(data+8) != 1) // horizontal flag must be set in format
      return 0;

   l = 0;
   r = ttUSHORT(data+10) - 1;
   needle = glyph1 << 16 | glyph2;
   while (l <= r) {
      m = (l + r) >> 1;
      straw = ttULONG(data+18+(m*6)); // note: unaligned read
      if (needle < straw)
         r = m - 1;
      else if (needle > straw)
         l = m + 1;
      else
         return ttSHORT(data+22+(m*6));
   }
   return 0;
}

static stbtt_int32  stbtt__GetCoverageIndex(stbtt_uint8 *coverageTable, int glyph)
{
    stbtt_uint16 coverageFormat = ttUSHORT(coverageTable);
    switch(coverageFormat) {
        case 1: {
            stbtt_uint16 glyphCount = ttUSHORT(coverageTable + 2);

            // Binary search.
            stbtt_int32 l=0, r=glyphCount-1, m;
            int straw, needle=glyph;
            while (l <= r) {
                stbtt_uint8 *glyphArray = coverageTable + 4;
                stbtt_uint16 glyphID;
                m = (l + r) >> 1;
                glyphID = ttUSHORT(glyphArray + 2 * m);
                straw = glyphID;
                if (needle < straw)
                    r = m - 1;
                else if (needle > straw)
                    l = m + 1;
                else {
                     return m;
                }
            }
        } break;

        case 2: {
            stbtt_uint16 rangeCount = ttUSHORT(coverageTable + 2);
            stbtt_uint8 *rangeArray = coverageTable + 4;

            // Binary search.
            stbtt_int32 l=0, r=rangeCount-1, m;
            int strawStart, strawEnd, needle=glyph;
            while (l <= r) {
                stbtt_uint8 *rangeRecord;
                m = (l + r) >> 1;
                rangeRecord = rangeArray + 6 * m;
                strawStart = ttUSHORT(rangeRecord);
                strawEnd = ttUSHORT(rangeRecord + 2);
                if (needle < strawStart)
                    r = m - 1;
                else if (needle > strawEnd)
                    l = m + 1;
                else {
                    stbtt_uint16 startCoverageIndex = ttUSHORT(rangeRecord + 4);
                    return startCoverageIndex + glyph - strawStart;
                }
            }
        } break;

        default: {
            // There are no other cases.
            STBTT_assert(0);
        } break;
    }

    return -1;
}

static stbtt_int32  stbtt__GetGlyphClass(stbtt_uint8 *classDefTable, int glyph)
{
    stbtt_uint16 classDefFormat = ttUSHORT(classDefTable);
    switch(classDefFormat)
    {
        case 1: {
            stbtt_uint16 startGlyphID = ttUSHORT(classDefTable + 2);
            stbtt_uint16 glyphCount = ttUSHORT(classDefTable + 4);
            stbtt_uint8 *classDef1ValueArray = classDefTable + 6;

            if (glyph >= startGlyphID && glyph < startGlyphID + glyphCount)
                return (stbtt_int32)ttUSHORT(classDef1ValueArray + 2 * (glyph - startGlyphID));

            // [DEAR IMGUI] Commented to fix static analyzer warning
            //classDefTable = classDef1ValueArray + 2 * glyphCount;
        } break;

        case 2: {
            stbtt_uint16 classRangeCount = ttUSHORT(classDefTable + 2);
            stbtt_uint8 *classRangeRecords = classDefTable + 4;

            // Binary search.
            stbtt_int32 l=0, r=classRangeCount-1, m;
            int strawStart, strawEnd, needle=glyph;
            while (l <= r) {
                stbtt_uint8 *classRangeRecord;
                m = (l + r) >> 1;
                classRangeRecord = classRangeRecords + 6 * m;
                strawStart = ttUSHORT(classRangeRecord);
                strawEnd = ttUSHORT(classRangeRecord + 2);
                if (needle < strawStart)
                    r = m - 1;
                else if (needle > strawEnd)
                    l = m + 1;
                else
                    return (stbtt_int32)ttUSHORT(classRangeRecord + 4);
            }

            // [DEAR IMGUI] Commented to fix static analyzer warning
            //classDefTable = classRangeRecords + 6 * classRangeCount;
        } break;

        default: {
            // There are no other cases.
            STBTT_assert(0);
        } break;
    }

    return -1;
}

// Define to STBTT_assert(x) if you want to break on unimplemented formats.
#define STBTT_GPOS_TODO_assert(x)

static stbtt_int32  stbtt__GetGlyphGPOSInfoAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2)
{
    stbtt_uint16 lookupListOffset;
    stbtt_uint8 *lookupList;
    stbtt_uint16 lookupCount;
    stbtt_uint8 *data;
    stbtt_int32 i;

    if (!info->gpos) return 0;

    data = info->data + info->gpos;

    if (ttUSHORT(data+0) != 1) return 0; // Major version 1
    if (ttUSHORT(data+2) != 0) return 0; // Minor version 0

    lookupListOffset = ttUSHORT(data+8);
    lookupList = data + lookupListOffset;
    lookupCount = ttUSHORT(lookupList);

    for (i=0; i<lookupCount; ++i) {
        stbtt_uint16 lookupOffset = ttUSHORT(lookupList + 2 + 2 * i);
        stbtt_uint8 *lookupTable = lookupList + lookupOffset;

        stbtt_uint16 lookupType = ttUSHORT(lookupTable);
        stbtt_uint16 subTableCount = ttUSHORT(lookupTable + 4);
        stbtt_uint8 *subTableOffsets = lookupTable + 6;
        switch(lookupType) {
            case 2: { // Pair Adjustment Positioning Subtable
                stbtt_int32 sti;
                for (sti=0; sti<subTableCount; sti++) {
                    stbtt_uint16 subtableOffset = ttUSHORT(subTableOffsets + 2 * sti);
                    stbtt_uint8 *table = lookupTable + subtableOffset;
                    stbtt_uint16 posFormat = ttUSHORT(table);
                    stbtt_uint16 coverageOffset = ttUSHORT(table + 2);
                    stbtt_int32 coverageIndex = stbtt__GetCoverageIndex(table + coverageOffset, glyph1);
                    if (coverageIndex == -1) continue;

                    switch (posFormat) {
                        case 1: {
                            stbtt_int32 l, r, m;
                            int straw, needle;
                            stbtt_uint16 valueFormat1 = ttUSHORT(table + 4);
                            stbtt_uint16 valueFormat2 = ttUSHORT(table + 6);
                            stbtt_int32 valueRecordPairSizeInBytes = 2;
                            stbtt_uint16 pairSetCount = ttUSHORT(table + 8);
                            stbtt_uint16 pairPosOffset = ttUSHORT(table + 10 + 2 * coverageIndex);
                            stbtt_uint8 *pairValueTable = table + pairPosOffset;
                            stbtt_uint16 pairValueCount = ttUSHORT(pairValueTable);
                            stbtt_uint8 *pairValueArray = pairValueTable + 2;
                            // TODO: Support more formats.
                            STBTT_GPOS_TODO_assert(valueFormat1 == 4);
                            if (valueFormat1 != 4) return 0;
                            STBTT_GPOS_TODO_assert(valueFormat2 == 0);
                            if (valueFormat2 != 0) return 0;

                            STBTT_assert(coverageIndex < pairSetCount);
                            STBTT__NOTUSED(pairSetCount);

                            needle=glyph2;
                            r=pairValueCount-1;
                            l=0;

                            // Binary search.
                            while (l <= r) {
                                stbtt_uint16 secondGlyph;
                                stbtt_uint8 *pairValue;
                                m = (l + r) >> 1;
                                pairValue = pairValueArray + (2 + valueRecordPairSizeInBytes) * m;
                                secondGlyph = ttUSHORT(pairValue);
                                straw = secondGlyph;
                                if (needle < straw)
                                    r = m - 1;
                                else if (needle > straw)
                                    l = m + 1;
                                else {
                                    stbtt_int16 xAdvance = ttSHORT(pairValue + 2);
                                    return xAdvance;
                                }
                            }
                        } break;

                        case 2: {
                            stbtt_uint16 valueFormat1 = ttUSHORT(table + 4);
                            stbtt_uint16 valueFormat2 = ttUSHORT(table + 6);

                            stbtt_uint16 classDef1Offset = ttUSHORT(table + 8);
                            stbtt_uint16 classDef2Offset = ttUSHORT(table + 10);
                            int glyph1class = stbtt__GetGlyphClass(table + classDef1Offset, glyph1);
                            int glyph2class = stbtt__GetGlyphClass(table + classDef2Offset, glyph2);

                            stbtt_uint16 class1Count = ttUSHORT(table + 12);
                            stbtt_uint16 class2Count = ttUSHORT(table + 14);
                            STBTT_assert(glyph1class < class1Count);
                            STBTT_assert(glyph2class < class2Count);

                            // TODO: Support more formats.
                            STBTT_GPOS_TODO_assert(valueFormat1 == 4);
                            if (valueFormat1 != 4) return 0;
                            STBTT_GPOS_TODO_assert(valueFormat2 == 0);
                            if (valueFormat2 != 0) return 0;

                            if (glyph1class >= 0 && glyph1class < class1Count && glyph2class >= 0 && glyph2class < class2Count) {
                                stbtt_uint8 *class1Records = table + 16;
                                stbtt_uint8 *class2Records = class1Records + 2 * (glyph1class * class2Count);
                                stbtt_int16 xAdvance = ttSHORT(class2Records + 2 * glyph2class);
                                return xAdvance;
                            }
                        } break;

                        default: {
                            // There are no other cases.
                            STBTT_assert(0);
                            break;
                        };
                    }
                }
                break;
            };

            default:
                // TODO: Implement other stuff.
                break;
        }
    }

    return 0;
}

STBTT_DEF int  stbtt_GetGlyphKernAdvance(const stbtt_fontinfo *info, int g1, int g2)
{
   int xAdvance = 0;

   if (info->gpos)
      xAdvance += stbtt__GetGlyphGPOSInfoAdvance(info, g1, g2);

   if (info->kern)
      xAdvance += stbtt__GetGlyphKernInfoAdvance(info, g1, g2);

   return xAdvance;
}

STBTT_DEF int  stbtt_GetCodepointKernAdvance(const stbtt_fontinfo *info, int ch1, int ch2)
{
   if (!info->kern && !info->gpos) // if no kerning table, don't waste time looking up both codepoint->glyphs
      return 0;
   return stbtt_GetGlyphKernAdvance(info, stbtt_FindGlyphIndex(info,ch1), stbtt_FindGlyphIndex(info,ch2));
}

STBTT_DEF void stbtt_GetCodepointHMetrics(const stbtt_fontinfo *info, int codepoint, int *advanceWidth, int *leftSideBearing)
{
   stbtt_GetGlyphHMetrics(info, stbtt_FindGlyphIndex(info,codepoint), advanceWidth, leftSideBearing);
}

STBTT_DEF void stbtt_GetFontVMetrics(const stbtt_fontinfo *info, int *ascent, int *descent, int *lineGap)
{
   if (ascent ) *ascent  = ttSHORT(info->data+info->hhea + 4);
   if (descent) *descent = ttSHORT(info->data+info->hhea + 6);
   if (lineGap) *lineGap = ttSHORT(info->data+info->hhea + 8);
}

STBTT_DEF int  stbtt_GetFontVMetricsOS2(const stbtt_fontinfo *info, int *typoAscent, int *typoDescent, int *typoLineGap)
{
   int tab = stbtt__find_table(info->data, info->fontstart, "OS/2");
   if (!tab)
      return 0;
   if (typoAscent ) *typoAscent  = ttSHORT(info->data+tab + 68);
   if (typoDescent) *typoDescent = ttSHORT(info->data+tab + 70);
   if (typoLineGap) *typoLineGap = ttSHORT(info->data+tab + 72);
   return 1;
}

STBTT_DEF void stbtt_GetFontBoundingBox(const stbtt_fontinfo *info, int *x0, int *y0, int *x1, int *y1)
{
   *x0 = ttSHORT(info->data + info->head + 36);
   *y0 = ttSHORT(info->data + info->head + 38);
   *x1 = ttSHORT(info->data + info->head + 40);
   *y1 = ttSHORT(info->data + info->head + 42);
}

STBTT_DEF float stbtt_ScaleForPixelHeight(const stbtt_fontinfo *info, float height)
{
   int fheight = ttSHORT(info->data + info->hhea + 4) - ttSHORT(info->data + info->hhea + 6);
   return (float) height / fheight;
}

STBTT_DEF float stbtt_ScaleForMappingEmToPixels(const stbtt_fontinfo *info, float pixels)
{
   int unitsPerEm = ttUSHORT(info->data + info->head + 18);
   return pixels / unitsPerEm;
}

STBTT_DEF void stbtt_FreeShape(const stbtt_fontinfo *info, stbtt_vertex *v)
{
   STBTT_free(v, info->userdata);
}

//////////////////////////////////////////////////////////////////////////////
//
// antialiasing software rasterizer
//

STBTT_DEF void stbtt_GetGlyphBitmapBoxSubpixel(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y,float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)
{
   int x0=0,y0=0,x1,y1; // =0 suppresses compiler warning
   if (!stbtt_GetGlyphBox(font, glyph, &x0,&y0,&x1,&y1)) {
      // e.g. space character
      if (ix0) *ix0 = 0;
      if (iy0) *iy0 = 0;
      if (ix1) *ix1 = 0;
      if (iy1) *iy1 = 0;
   } else {
      // move to integral bboxes (treating pixels as little squares, what pixels get touched)?
      if (ix0) *ix0 = STBTT_ifloor( x0 * scale_x + shift_x);
      if (iy0) *iy0 = STBTT_ifloor(-y1 * scale_y + shift_y);
      if (ix1) *ix1 = STBTT_iceil ( x1 * scale_x + shift_x);
      if (iy1) *iy1 = STBTT_iceil (-y0 * scale_y + shift_y);
   }
}

STBTT_DEF void stbtt_GetGlyphBitmapBox(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)
{
   stbtt_GetGlyphBitmapBoxSubpixel(font, glyph, scale_x, scale_y,0.0f,0.0f, ix0, iy0, ix1, iy1);
}

STBTT_DEF void stbtt_GetCodepointBitmapBoxSubpixel(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)
{
   stbtt_GetGlyphBitmapBoxSubpixel(font, stbtt_FindGlyphIndex(font,codepoint), scale_x, scale_y,shift_x,shift_y, ix0,iy0,ix1,iy1);
}

STBTT_DEF void stbtt_GetCodepointBitmapBox(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)
{
   stbtt_GetCodepointBitmapBoxSubpixel(font, codepoint, scale_x, scale_y,0.0f,0.0f, ix0,iy0,ix1,iy1);
}

//////////////////////////////////////////////////////////////////////////////
//
//  Rasterizer

typedef struct stbtt__hheap_chunk
{
   struct stbtt__hheap_chunk *next;
} stbtt__hheap_chunk;

typedef struct stbtt__hheap
{
   struct stbtt__hheap_chunk *head;
   void   *first_free;
   int    num_remaining_in_head_chunk;
} stbtt__hheap;

static void *stbtt__hheap_alloc(stbtt__hheap *hh, size_t size, void *userdata)
{
   if (hh->first_free) {
      void *p = hh->first_free;
      hh->first_free = * (void **) p;
      return p;
   } else {
      if (hh->num_remaining_in_head_chunk == 0) {
         int count = (size < 32 ? 2000 : size < 128 ? 800 : 100);
         stbtt__hheap_chunk *c = (stbtt__hheap_chunk *) STBTT_malloc(sizeof(stbtt__hheap_chunk) + size * count, userdata);
         if (c == NULL)
            return NULL;
         c->next = hh->head;
         hh->head = c;
         hh->num_remaining_in_head_chunk = count;
      }
      --hh->num_remaining_in_head_chunk;
      return (char *) (hh->head) + sizeof(stbtt__hheap_chunk) + size * hh->num_remaining_in_head_chunk;
   }
}

static void stbtt__hheap_free(stbtt__hheap *hh, void *p)
{
   *(void **) p = hh->first_free;
   hh->first_free = p;
}

static void stbtt__hheap_cleanup(stbtt__hheap *hh, void *userdata)
{
   stbtt__hheap_chunk *c = hh->head;
   while (c) {
      stbtt__hheap_chunk *n = c->next;
      STBTT_free(c, userdata);
      c = n;
   }
}

typedef struct stbtt__edge {
   float x0,y0, x1,y1;
   int invert;
} stbtt__edge;


typedef struct stbtt__active_edge
{
   struct stbtt__active_edge *next;
   #if STBTT_RASTERIZER_VERSION==1
   int x,dx;
   float ey;
   int direction;
   #elif STBTT_RASTERIZER_VERSION==2
   float fx,fdx,fdy;
   float direction;
   float sy;
   float ey;
   #else
   #error "Unrecognized value of STBTT_RASTERIZER_VERSION"
   #endif
} stbtt__active_edge;

#if STBTT_RASTERIZER_VERSION == 1
#define STBTT_FIXSHIFT   10
#define STBTT_FIX        (1 << STBTT_FIXSHIFT)
#define STBTT_FIXMASK    (STBTT_FIX-1)

static stbtt__active_edge *stbtt__new_active(stbtt__hheap *hh, stbtt__edge *e, int off_x, float start_point, void *userdata)
{
   stbtt__active_edge *z = (stbtt__active_edge *) stbtt__hheap_alloc(hh, sizeof(*z), userdata);
   float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);
   STBTT_assert(z != NULL);
   if (!z) return z;
   
   // round dx down to avoid overshooting
   if (dxdy < 0)
      z->dx = -STBTT_ifloor(STBTT_FIX * -dxdy);
   else
      z->dx = STBTT_ifloor(STBTT_FIX * dxdy);

   z->x = STBTT_ifloor(STBTT_FIX * e->x0 + z->dx * (start_point - e->y0)); // use z->dx so when we offset later it's by the same amount
   z->x -= off_x * STBTT_FIX;

   z->ey = e->y1;
   z->next = 0;
   z->direction = e->invert ? 1 : -1;
   return z;
}
#elif STBTT_RASTERIZER_VERSION == 2
static stbtt__active_edge *stbtt__new_active(stbtt__hheap *hh, stbtt__edge *e, int off_x, float start_point, void *userdata)
{
   stbtt__active_edge *z = (stbtt__active_edge *) stbtt__hheap_alloc(hh, sizeof(*z), userdata);
   float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);
   STBTT_assert(z != NULL);
   //STBTT_assert(e->y0 <= start_point);
   if (!z) return z;
   z->fdx = dxdy;
   z->fdy = dxdy != 0.0f ? (1.0f/dxdy) : 0.0f;
   z->fx = e->x0 + dxdy * (start_point - e->y0);
   z->fx -= off_x;
   z->direction = e->invert ? 1.0f : -1.0f;
   z->sy = e->y0;
   z->ey = e->y1;
   z->next = 0;
   return z;
}
#else
#error "Unrecognized value of STBTT_RASTERIZER_VERSION"
#endif

#if STBTT_RASTERIZER_VERSION == 1
// note: this routine clips fills that extend off the edges... ideally this
// wouldn't happen, but it could happen if the truetype glyph bounding boxes
// are wrong, or if the user supplies a too-small bitmap
static void stbtt__fill_active_edges(unsigned char *scanline, int len, stbtt__active_edge *e, int max_weight)
{
   // non-zero winding fill
   int x0=0, w=0;

   while (e) {
      if (w == 0) {
         // if we're currently at zero, we need to record the edge start point
         x0 = e->x; w += e->direction;
      } else {
         int x1 = e->x; w += e->direction;
         // if we went to zero, we need to draw
         if (w == 0) {
            int i = x0 >> STBTT_FIXSHIFT;
            int j = x1 >> STBTT_FIXSHIFT;

            if (i < len && j >= 0) {
               if (i == j) {
                  // x0,x1 are the same pixel, so compute combined coverage
                  scanline[i] = scanline[i] + (stbtt_uint8) ((x1 - x0) * max_weight >> STBTT_FIXSHIFT);
               } else {
                  if (i >= 0) // add antialiasing for x0
                     scanline[i] = scanline[i] + (stbtt_uint8) (((STBTT_FIX - (x0 & STBTT_FIXMASK)) * max_weight) >> STBTT_FIXSHIFT);
                  else
                     i = -1; // clip

                  if (j < len) // add antialiasing for x1
                     scanline[j] = scanline[j] + (stbtt_uint8) (((x1 & STBTT_FIXMASK) * max_weight) >> STBTT_FIXSHIFT);
                  else
                     j = len; // clip

                  for (++i; i < j; ++i) // fill pixels between x0 and x1
                     scanline[i] = scanline[i] + (stbtt_uint8) max_weight;
               }
            }
         }
      }
      
      e = e->next;
   }
}

static void stbtt__rasterize_sorted_edges(stbtt__bitmap *result, stbtt__edge *e, int n, int vsubsample, int off_x, int off_y, void *userdata)
{
   stbtt__hheap hh = { 0, 0, 0 };
   stbtt__active_edge *active = NULL;
   int y,j=0;
   int max_weight = (255 / vsubsample);  // weight per vertical scanline
   int s; // vertical subsample index
   unsigned char scanline_data[512], *scanline;

   if (result->w > 512)
      scanline = (unsigned char *) STBTT_malloc(result->w, userdata);
   else
      scanline = scanline_data;

   y = off_y * vsubsample;
   e[n].y0 = (off_y + result->h) * (float) vsubsample + 1;

   while (j < result->h) {
      STBTT_memset(scanline, 0, result->w);
      for (s=0; s < vsubsample; ++s) {
         // find center of pixel for this scanline
         float scan_y = y + 0.5f;
         stbtt__active_edge **step = &active;

         // update all active edges;
         // remove all active edges that terminate before the center of this scanline
         while (*step) {
            stbtt__active_edge * z = *step;
            if (z->ey <= scan_y) {
               *step = z->next; // delete from list
               STBTT_assert(z->direction);
               z->direction = 0;
               stbtt__hheap_free(&hh, z);
            } else {
               z->x += z->dx; // advance to position for current scanline
               step = &((*step)->next); // advance through list
            }
         }

         // resort the list if needed
         for(;;) {
            int changed=0;
            step = &active;
            while (*step && (*step)->next) {
               if ((*step)->x > (*step)->next->x) {
                  stbtt__active_edge *t = *step;
                  stbtt__active_edge *q = t->next;

                  t->next = q->next;
                  q->next = t;
                  *step = q;
                  changed = 1;
               }
               step = &(*step)->next;
            }
            if (!changed) break;
         }

         // insert all edges that start before the center of this scanline -- omit ones that also end on this scanline
         while (e->y0 <= scan_y) {
            if (e->y1 > scan_y) {
               stbtt__active_edge *z = stbtt__new_active(&hh, e, off_x, scan_y, userdata);
               if (z != NULL) {
                  // find insertion point
                  if (active == NULL)
                     active = z;
                  else if (z->x < active->x) {
                     // insert at front
                     z->next = active;
                     active = z;
                  } else {
                     // find thing to insert AFTER
                     stbtt__active_edge *p = active;
                     while (p->next && p->next->x < z->x)
                        p = p->next;
                     // at this point, p->next->x is NOT < z->x
                     z->next = p->next;
                     p->next = z;
                  }
               }
            }
            ++e;
         }

         // now process all active edges in XOR fashion
         if (active)
            stbtt__fill_active_edges(scanline, result->w, active, max_weight);

         ++y;
      }
      STBTT_memcpy(result->pixels + j * result->stride, scanline, result->w);
      ++j;
   }

   stbtt__hheap_cleanup(&hh, userdata);

   if (scanline != scanline_data)
      STBTT_free(scanline, userdata);
}

#elif STBTT_RASTERIZER_VERSION == 2

// the edge passed in here does not cross the vertical line at x or the vertical line at x+1
// (i.e. it has already been clipped to those)
static void stbtt__handle_clipped_edge(float *scanline, int x, stbtt__active_edge *e, float x0, float y0, float x1, float y1)
{
   if (y0 == y1) return;
   STBTT_assert(y0 < y1);
   STBTT_assert(e->sy <= e->ey);
   if (y0 > e->ey) return;
   if (y1 < e->sy) return;
   if (y0 < e->sy) {
      x0 += (x1-x0) * (e->sy - y0) / (y1-y0);
      y0 = e->sy;
   }
   if (y1 > e->ey) {
      x1 += (x1-x0) * (e->ey - y1) / (y1-y0);
      y1 = e->ey;
   }

   if (x0 == x)
      STBTT_assert(x1 <= x+1);
   else if (x0 == x+1)
      STBTT_assert(x1 >= x);
   else if (x0 <= x)
      STBTT_assert(x1 <= x);
   else if (x0 >= x+1)
      STBTT_assert(x1 >= x+1);
   else
      STBTT_assert(x1 >= x && x1 <= x+1);

   if (x0 <= x && x1 <= x)
      scanline[x] += e->direction * (y1-y0);
   else if (x0 >= x+1 && x1 >= x+1)
      ;
   else {
      STBTT_assert(x0 >= x && x0 <= x+1 && x1 >= x && x1 <= x+1);
      scanline[x] += e->direction * (y1-y0) * (1-((x0-x)+(x1-x))/2); // coverage = 1 - average x position
   }
}

static void stbtt__fill_active_edges_new(float *scanline, float *scanline_fill, int len, stbtt__active_edge *e, float y_top)
{
   float y_bottom = y_top+1;

   while (e) {
      // brute force every pixel

      // compute intersection points with top & bottom
      STBTT_assert(e->ey >= y_top);

      if (e->fdx == 0) {
         float x0 = e->fx;
         if (x0 < len) {
            if (x0 >= 0) {
               stbtt__handle_clipped_edge(scanline,(int) x0,e, x0,y_top, x0,y_bottom);
               stbtt__handle_clipped_edge(scanline_fill-1,(int) x0+1,e, x0,y_top, x0,y_bottom);
            } else {
               stbtt__handle_clipped_edge(scanline_fill-1,0,e, x0,y_top, x0,y_bottom);
            }
         }
      } else {
         float x0 = e->fx;
         float dx = e->fdx;
         float xb = x0 + dx;
         float x_top, x_bottom;
         float sy0,sy1;
         float dy = e->fdy;
         STBTT_assert(e->sy <= y_bottom && e->ey >= y_top);

         // compute endpoints of line segment clipped to this scanline (if the
         // line segment starts on this scanline. x0 is the intersection of the
         // line with y_top, but that may be off the line segment.
         if (e->sy > y_top) {
            x_top = x0 + dx * (e->sy - y_top);
            sy0 = e->sy;
         } else {
            x_top = x0;
            sy0 = y_top;
         }
         if (e->ey < y_bottom) {
            x_bottom = x0 + dx * (e->ey - y_top);
            sy1 = e->ey;
         } else {
            x_bottom = xb;
            sy1 = y_bottom;
         }

         if (x_top >= 0 && x_bottom >= 0 && x_top < len && x_bottom < len) {
            // from here on, we don't have to range check x values

            if ((int) x_top == (int) x_bottom) {
               float height;
               // simple case, only spans one pixel
               int x = (int) x_top;
               height = sy1 - sy0;
               STBTT_assert(x >= 0 && x < len);
               scanline[x] += e->direction * (1-((x_top - x) + (x_bottom-x))/2)  * height;
               scanline_fill[x] += e->direction * height; // everything right of this pixel is filled
            } else {
               int x,x1,x2;
               float y_crossing, step, sign, area;
               // covers 2+ pixels
               if (x_top > x_bottom) {
                  // flip scanline vertically; signed area is the same
                  float t;
                  sy0 = y_bottom - (sy0 - y_top);
                  sy1 = y_bottom - (sy1 - y_top);
                  t = sy0, sy0 = sy1, sy1 = t;
                  t = x_bottom, x_bottom = x_top, x_top = t;
                  dx = -dx;
                  dy = -dy;
                  t = x0, x0 = xb, xb = t;
                  // [DEAR IMGUI] Fix static analyzer warning
                  (void)dx; // [ImGui: fix static analyzer warning]
               }

               x1 = (int) x_top;
               x2 = (int) x_bottom;
               // compute intersection with y axis at x1+1
               y_crossing = (x1+1 - x0) * dy + y_top;

               sign = e->direction;
               // area of the rectangle covered from y0..y_crossing
               area = sign * (y_crossing-sy0);
               // area of the triangle (x_top,y0), (x+1,y0), (x+1,y_crossing)
               scanline[x1] += area * (1-((x_top - x1)+(x1+1-x1))/2);

               step = sign * dy;
               for (x = x1+1; x < x2; ++x) {
                  scanline[x] += area + step/2;
                  area += step;
               }
               y_crossing += dy * (x2 - (x1+1));

               STBTT_assert(STBTT_fabs(area) <= 1.01f);

               scanline[x2] += area + sign * (1-((x2-x2)+(x_bottom-x2))/2) * (sy1-y_crossing);

               scanline_fill[x2] += sign * (sy1-sy0);
            }
         } else {
            // if edge goes outside of box we're drawing, we require
            // clipping logic. since this does not match the intended use
            // of this library, we use a different, very slow brute
            // force implementation
            int x;
            for (x=0; x < len; ++x) {
               // cases:
               //
               // there can be up to two intersections with the pixel. any intersection
               // with left or right edges can be handled by splitting into two (or three)
               // regions. intersections with top & bottom do not necessitate case-wise logic.
               //
               // the old way of doing this found the intersections with the left & right edges,
               // then used some simple logic to produce up to three segments in sorted order
               // from top-to-bottom. however, this had a problem: if an x edge was epsilon
               // across the x border, then the corresponding y position might not be distinct
               // from the other y segment, and it might ignored as an empty segment. to avoid
               // that, we need to explicitly produce segments based on x positions.

               // rename variables to clearly-defined pairs
               float y0 = y_top;
               float x1 = (float) (x);
               float x2 = (float) (x+1);
               float x3 = xb;
               float y3 = y_bottom;

               // x = e->x + e->dx * (y-y_top)
               // (y-y_top) = (x - e->x) / e->dx
               // y = (x - e->x) / e->dx + y_top
               float y1 = (x - x0) / dx + y_top;
               float y2 = (x+1 - x0) / dx + y_top;

               if (x0 < x1 && x3 > x2) {         // three segments descending down-right
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);
                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x2,y2);
                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);
               } else if (x3 < x1 && x0 > x2) {  // three segments descending down-left
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);
                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x1,y1);
                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);
               } else if (x0 < x1 && x3 > x1) {  // two segments across x, down-right
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);
                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);
               } else if (x3 < x1 && x0 > x1) {  // two segments across x, down-left
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);
                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);
               } else if (x0 < x2 && x3 > x2) {  // two segments across x+1, down-right
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);
                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);
               } else if (x3 < x2 && x0 > x2) {  // two segments across x+1, down-left
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);
                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);
               } else {  // one segment
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x3,y3);
               }
            }
         }
      }
      e = e->next;
   }
}

// directly AA rasterize edges w/o supersampling
static void stbtt__rasterize_sorted_edges(stbtt__bitmap *result, stbtt__edge *e, int n, int vsubsample, int off_x, int off_y, void *userdata)
{
   stbtt__hheap hh = { 0, 0, 0 };
   stbtt__active_edge *active = NULL;
   int y,j=0, i;
   float scanline_data[129], *scanline, *scanline2;

   STBTT__NOTUSED(vsubsample);

   if (result->w > 64)
      scanline = (float *) STBTT_malloc((result->w*2+1) * sizeof(float), userdata);
   else
      scanline = scanline_data;

   scanline2 = scanline + result->w;

   y = off_y;
   e[n].y0 = (float) (off_y + result->h) + 1;

   while (j < result->h) {
      // find center of pixel for this scanline
      float scan_y_top    = y + 0.0f;
      float scan_y_bottom = y + 1.0f;
      stbtt__active_edge **step = &active;

      STBTT_memset(scanline , 0, result->w*sizeof(scanline[0]));
      STBTT_memset(scanline2, 0, (result->w+1)*sizeof(scanline[0]));

      // update all active edges;
      // remove all active edges that terminate before the top of this scanline
      while (*step) {
         stbtt__active_edge * z = *step;
         if (z->ey <= scan_y_top) {
            *step = z->next; // delete from list
            STBTT_assert(z->direction);
            z->direction = 0;
            stbtt__hheap_free(&hh, z);
         } else {
            step = &((*step)->next); // advance through list
         }
      }

      // insert all edges that start before the bottom of this scanline
      while (e->y0 <= scan_y_bottom) {
         if (e->y0 != e->y1) {
            stbtt__active_edge *z = stbtt__new_active(&hh, e, off_x, scan_y_top, userdata);
            if (z != NULL) {
               if (j == 0 && off_y != 0) {
                  if (z->ey < scan_y_top) {
                     // this can happen due to subpixel positioning and some kind of fp rounding error i think
                     z->ey = scan_y_top;
                  }
               }
               STBTT_assert(z->ey >= scan_y_top); // if we get really unlucky a tiny bit of an edge can be out of bounds
               // insert at front
               z->next = active;
               active = z;
            }
         }
         ++e;
      }

      // now process all active edges
      if (active)
         stbtt__fill_active_edges_new(scanline, scanline2+1, result->w, active, scan_y_top);

      {
         float sum = 0;
         for (i=0; i < result->w; ++i) {
            float k;
            int m;
            sum += scanline2[i];
            k = scanline[i] + sum;
            k = (float) STBTT_fabs(k)*255 + 0.5f;
            m = (int) k;
            if (m > 255) m = 255;
            result->pixels[j*result->stride + i] = (unsigned char) m;
         }
      }
      // advance all the edges
      step = &active;
      while (*step) {
         stbtt__active_edge *z = *step;
         z->fx += z->fdx; // advance to position for current scanline
         step = &((*step)->next); // advance through list
      }

      ++y;
      ++j;
   }

   stbtt__hheap_cleanup(&hh, userdata);

   if (scanline != scanline_data)
      STBTT_free(scanline, userdata);
}
#else
#error "Unrecognized value of STBTT_RASTERIZER_VERSION"
#endif

#define STBTT__COMPARE(a,b)  ((a)->y0 < (b)->y0)

static void stbtt__sort_edges_ins_sort(stbtt__edge *p, int n)
{
   int i,j;
   for (i=1; i < n; ++i) {
      stbtt__edge t = p[i], *a = &t;
      j = i;
      while (j > 0) {
         stbtt__edge *b = &p[j-1];
         int c = STBTT__COMPARE(a,b);
         if (!c) break;
         p[j] = p[j-1];
         --j;
      }
      if (i != j)
         p[j] = t;
   }
}

static void stbtt__sort_edges_quicksort(stbtt__edge *p, int n)
{
   /* threshold for transitioning to insertion sort */
   while (n > 12) {
      stbtt__edge t;
      int c01,c12,c,m,i,j;

      /* compute median of three */
      m = n >> 1;
      c01 = STBTT__COMPARE(&p[0],&p[m]);
      c12 = STBTT__COMPARE(&p[m],&p[n-1]);
      /* if 0 >= mid >= end, or 0 < mid < end, then use mid */
      if (c01 != c12) {
         /* otherwise, we'll need to swap something else to middle */
         int z;
         c = STBTT__COMPARE(&p[0],&p[n-1]);
         /* 0>mid && mid<n:  0>n => n; 0<n => 0 */
         /* 0<mid && mid>n:  0>n => 0; 0<n => n */
         z = (c == c12) ? 0 : n-1;
         t = p[z];
         p[z] = p[m];
         p[m] = t;
      }
      /* now p[m] is the median-of-three */
      /* swap it to the beginning so it won't move around */
      t = p[0];
      p[0] = p[m];
      p[m] = t;

      /* partition loop */
      i=1;
      j=n-1;
      for(;;) {
         /* handling of equality is crucial here */
         /* for sentinels & efficiency with duplicates */
         for (;;++i) {
            if (!STBTT__COMPARE(&p[i], &p[0])) break;
         }
         for (;;--j) {
            if (!STBTT__COMPARE(&p[0], &p[j])) break;
         }
         /* make sure we haven't crossed */
         if (i >= j) break;
         t = p[i];
         p[i] = p[j];
         p[j] = t;

         ++i;
         --j;
      }
      /* recurse on smaller side, iterate on larger */
      if (j < (n-i)) {
         stbtt__sort_edges_quicksort(p,j);
         p = p+i;
         n = n-i;
      } else {
         stbtt__sort_edges_quicksort(p+i, n-i);
         n = j;
      }
   }
}

static void stbtt__sort_edges(stbtt__edge *p, int n)
{
   stbtt__sort_edges_quicksort(p, n);
   stbtt__sort_edges_ins_sort(p, n);
}

typedef struct
{
   float x,y;
} stbtt__point;

static void stbtt__rasterize(stbtt__bitmap *result, stbtt__point *pts, int *wcount, int windings, float scale_x, float scale_y, float shift_x, float shift_y, int off_x, int off_y, int invert, void *userdata)
{
   float y_scale_inv = invert ? -scale_y : scale_y;
   stbtt__edge *e;
   int n,i,j,k,m;
#if STBTT_RASTERIZER_VERSION == 1
   int vsubsample = result->h < 8 ? 15 : 5;
#elif STBTT_RASTERIZER_VERSION == 2
   int vsubsample = 1;
#else
   #error "Unrecognized value of STBTT_RASTERIZER_VERSION"
#endif
   // vsubsample should divide 255 evenly; otherwise we won't reach full opacity

   // now we have to blow out the windings into explicit edge lists
   n = 0;
   for (i=0; i < windings; ++i)
      n += wcount[i];

   e = (stbtt__edge *) STBTT_malloc(sizeof(*e) * (n+1), userdata); // add an extra one as a sentinel
   if (e == 0) return;
   n = 0;

   m=0;
   for (i=0; i < windings; ++i) {
      stbtt__point *p = pts + m;
      m += wcount[i];
      j = wcount[i]-1;
      for (k=0; k < wcount[i]; j=k++) {
         int a=k,b=j;
         // skip the edge if horizontal
         if (p[j].y == p[k].y)
            continue;
         // add edge from j to k to the list
         e[n].invert = 0;
         if (invert ? p[j].y > p[k].y : p[j].y < p[k].y) {
            e[n].invert = 1;
            a=j,b=k;
         }
         e[n].x0 = p[a].x * scale_x + shift_x;
         e[n].y0 = (p[a].y * y_scale_inv + shift_y) * vsubsample;
         e[n].x1 = p[b].x * scale_x + shift_x;
         e[n].y1 = (p[b].y * y_scale_inv + shift_y) * vsubsample;
         ++n;
      }
   }

   // now sort the edges by their highest point (should snap to integer, and then by x)
   //STBTT_sort(e, n, sizeof(e[0]), stbtt__edge_compare);
   stbtt__sort_edges(e, n);

   // now, traverse the scanlines and find the intersections on each scanline, use xor winding rule
   stbtt__rasterize_sorted_edges(result, e, n, vsubsample, off_x, off_y, userdata);

   STBTT_free(e, userdata);
}

static void stbtt__add_point(stbtt__point *points, int n, float x, float y)
{
   if (!points) return; // during first pass, it's unallocated
   points[n].x = x;
   points[n].y = y;
}

// tessellate until threshold p is happy... @TODO warped to compensate for non-linear stretching
static int stbtt__tesselate_curve(stbtt__point *points, int *num_points, float x0, float y0, float x1, float y1, float x2, float y2, float objspace_flatness_squared, int n)
{
   // midpoint
   float mx = (x0 + 2*x1 + x2)/4;
   float my = (y0 + 2*y1 + y2)/4;
   // versus directly drawn line
   float dx = (x0+x2)/2 - mx;
   float dy = (y0+y2)/2 - my;
   if (n > 16) // 65536 segments on one curve better be enough!
      return 1;
   if (dx*dx+dy*dy > objspace_flatness_squared) { // half-pixel error allowed... need to be smaller if AA
      stbtt__tesselate_curve(points, num_points, x0,y0, (x0+x1)/2.0f,(y0+y1)/2.0f, mx,my, objspace_flatness_squared,n+1);
      stbtt__tesselate_curve(points, num_points, mx,my, (x1+x2)/2.0f,(y1+y2)/2.0f, x2,y2, objspace_flatness_squared,n+1);
   } else {
      stbtt__add_point(points, *num_points,x2,y2);
      *num_points = *num_points+1;
   }
   return 1;
}

static void stbtt__tesselate_cubic(stbtt__point *points, int *num_points, float x0, float y0, float x1, float y1, float x2, float y2, float x3, float y3, float objspace_flatness_squared, int n)
{
   // @TODO this "flatness" calculation is just made-up nonsense that seems to work well enough
   float dx0 = x1-x0;
   float dy0 = y1-y0;
   float dx1 = x2-x1;
   float dy1 = y2-y1;
   float dx2 = x3-x2;
   float dy2 = y3-y2;
   float dx = x3-x0;
   float dy = y3-y0;
   float longlen = (float) (STBTT_sqrt(dx0*dx0+dy0*dy0)+STBTT_sqrt(dx1*dx1+dy1*dy1)+STBTT_sqrt(dx2*dx2+dy2*dy2));
   float shortlen = (float) STBTT_sqrt(dx*dx+dy*dy);
   float flatness_squared = longlen*longlen-shortlen*shortlen;

   if (n > 16) // 65536 segments on one curve better be enough!
      return;

   if (flatness_squared > objspace_flatness_squared) {
      float x01 = (x0+x1)/2;
      float y01 = (y0+y1)/2;
      float x12 = (x1+x2)/2;
      float y12 = (y1+y2)/2;
      float x23 = (x2+x3)/2;
      float y23 = (y2+y3)/2;

      float xa = (x01+x12)/2;
      float ya = (y01+y12)/2;
      float xb = (x12+x23)/2;
      float yb = (y12+y23)/2;

      float mx = (xa+xb)/2;
      float my = (ya+yb)/2;

      stbtt__tesselate_cubic(points, num_points, x0,y0, x01,y01, xa,ya, mx,my, objspace_flatness_squared,n+1);
      stbtt__tesselate_cubic(points, num_points, mx,my, xb,yb, x23,y23, x3,y3, objspace_flatness_squared,n+1);
   } else {
      stbtt__add_point(points, *num_points,x3,y3);
      *num_points = *num_points+1;
   }
}

// returns number of contours
static stbtt__point *stbtt_FlattenCurves(stbtt_vertex *vertices, int num_verts, float objspace_flatness, int **contour_lengths, int *num_contours, void *userdata)
{
   stbtt__point *points=0;
   int num_points=0;

   float objspace_flatness_squared = objspace_flatness * objspace_flatness;
   int i,n=0,start=0, pass;

   // count how many "moves" there are to get the contour count
   for (i=0; i < num_verts; ++i)
      if (vertices[i].type == STBTT_vmove)
         ++n;

   *num_contours = n;
   if (n == 0) return 0;

   *contour_lengths = (int *) STBTT_malloc(sizeof(**contour_lengths) * n, userdata);

   if (*contour_lengths == 0) {
      *num_contours = 0;
      return 0;
   }

   // make two passes through the points so we don't need to realloc
   for (pass=0; pass < 2; ++pass) {
      float x=0,y=0;
      if (pass == 1) {
         points = (stbtt__point *) STBTT_malloc(num_points * sizeof(points[0]), userdata);
         if (points == NULL) goto error;
      }
      num_points = 0;
      n= -1;
      for (i=0; i < num_verts; ++i) {
         switch (vertices[i].type) {
            case STBTT_vmove:
               // start the next contour
               if (n >= 0)
                  (*contour_lengths)[n] = num_points - start;
               ++n;
               start = num_points;

               x = vertices[i].x, y = vertices[i].y;
               stbtt__add_point(points, num_points++, x,y);
               break;
            case STBTT_vline:
               x = vertices[i].x, y = vertices[i].y;
               stbtt__add_point(points, num_points++, x, y);
               break;
            case STBTT_vcurve:
               stbtt__tesselate_curve(points, &num_points, x,y,
                                        vertices[i].cx, vertices[i].cy,
                                        vertices[i].x,  vertices[i].y,
                                        objspace_flatness_squared, 0);
               x = vertices[i].x, y = vertices[i].y;
               break;
            case STBTT_vcubic:
               stbtt__tesselate_cubic(points, &num_points, x,y,
                                        vertices[i].cx, vertices[i].cy,
                                        vertices[i].cx1, vertices[i].cy1,
                                        vertices[i].x,  vertices[i].y,
                                        objspace_flatness_squared, 0);
               x = vertices[i].x, y = vertices[i].y;
               break;
         }
      }
      (*contour_lengths)[n] = num_points - start;
   }

   return points;
error:
   STBTT_free(points, userdata);
   STBTT_free(*contour_lengths, userdata);
   *contour_lengths = 0;
   *num_contours = 0;
   return NULL;
}

STBTT_DEF void stbtt_Rasterize(stbtt__bitmap *result, float flatness_in_pixels, stbtt_vertex *vertices, int num_verts, float scale_x, float scale_y, float shift_x, float shift_y, int x_off, int y_off, int invert, void *userdata)
{
   float scale            = scale_x > scale_y ? scale_y : scale_x;
   int winding_count      = 0;
   int *winding_lengths   = NULL;
   stbtt__point *windings = stbtt_FlattenCurves(vertices, num_verts, flatness_in_pixels / scale, &winding_lengths, &winding_count, userdata);
   if (windings) {
      stbtt__rasterize(result, windings, winding_lengths, winding_count, scale_x, scale_y, shift_x, shift_y, x_off, y_off, invert, userdata);
      STBTT_free(winding_lengths, userdata);
      STBTT_free(windings, userdata);
   }
}

STBTT_DEF void stbtt_FreeBitmap(unsigned char *bitmap, void *userdata)
{
   STBTT_free(bitmap, userdata);
}

STBTT_DEF unsigned char *stbtt_GetGlyphBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int glyph, int *width, int *height, int *xoff, int *yoff)
{
   int ix0,iy0,ix1,iy1;
   stbtt__bitmap gbm;
   stbtt_vertex *vertices;   
   int num_verts = stbtt_GetGlyphShape(info, glyph, &vertices);

   if (scale_x == 0) scale_x = scale_y;
   if (scale_y == 0) {
      if (scale_x == 0) {
         STBTT_free(vertices, info->userdata);
         return NULL;
      }
      scale_y = scale_x;
   }

   stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale_x, scale_y, shift_x, shift_y, &ix0,&iy0,&ix1,&iy1);

   // now we get the size
   gbm.w = (ix1 - ix0);
   gbm.h = (iy1 - iy0);
   gbm.pixels = NULL; // in case we error

   if (width ) *width  = gbm.w;
   if (height) *height = gbm.h;
   if (xoff  ) *xoff   = ix0;
   if (yoff  ) *yoff   = iy0;
   
   if (gbm.w && gbm.h) {
      gbm.pixels = (unsigned char *) STBTT_malloc(gbm.w * gbm.h, info->userdata);
      if (gbm.pixels) {
         gbm.stride = gbm.w;

         stbtt_Rasterize(&gbm, 0.35f, vertices, num_verts, scale_x, scale_y, shift_x, shift_y, ix0, iy0, 1, info->userdata);
      }
   }
   STBTT_free(vertices, info->userdata);
   return gbm.pixels;
}   

STBTT_DEF unsigned char *stbtt_GetGlyphBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int glyph, int *width, int *height, int *xoff, int *yoff)
{
   return stbtt_GetGlyphBitmapSubpixel(info, scale_x, scale_y, 0.0f, 0.0f, glyph, width, height, xoff, yoff);
}

STBTT_DEF void stbtt_MakeGlyphBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int glyph)
{
   int ix0,iy0;
   stbtt_vertex *vertices;
   int num_verts = stbtt_GetGlyphShape(info, glyph, &vertices);
   stbtt__bitmap gbm;   

   stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale_x, scale_y, shift_x, shift_y, &ix0,&iy0,0,0);
   gbm.pixels = output;
   gbm.w = out_w;
   gbm.h = out_h;
   gbm.stride = out_stride;

   if (gbm.w && gbm.h)
      stbtt_Rasterize(&gbm, 0.35f, vertices, num_verts, scale_x, scale_y, shift_x, shift_y, ix0,iy0, 1, info->userdata);

   STBTT_free(vertices, info->userdata);
}

STBTT_DEF void stbtt_MakeGlyphBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int glyph)
{
   stbtt_MakeGlyphBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, 0.0f,0.0f, glyph);
}

STBTT_DEF unsigned char *stbtt_GetCodepointBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint, int *width, int *height, int *xoff, int *yoff)
{
   return stbtt_GetGlyphBitmapSubpixel(info, scale_x, scale_y,shift_x,shift_y, stbtt_FindGlyphIndex(info,codepoint), width,height,xoff,yoff);
}   

STBTT_DEF void stbtt_MakeCodepointBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int oversample_x, int oversample_y, float *sub_x, float *sub_y, int codepoint)
{
   stbtt_MakeGlyphBitmapSubpixelPrefilter(info, output, out_w, out_h, out_stride, scale_x, scale_y, shift_x, shift_y, oversample_x, oversample_y, sub_x, sub_y, stbtt_FindGlyphIndex(info,codepoint));
}

STBTT_DEF void stbtt_MakeCodepointBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint)
{
   stbtt_MakeGlyphBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, shift_x, shift_y, stbtt_FindGlyphIndex(info,codepoint));
}

STBTT_DEF unsigned char *stbtt_GetCodepointBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int codepoint, int *width, int *height, int *xoff, int *yoff)
{
   return stbtt_GetCodepointBitmapSubpixel(info, scale_x, scale_y, 0.0f,0.0f, codepoint, width,height,xoff,yoff);
}   

STBTT_DEF void stbtt_MakeCodepointBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int codepoint)
{
   stbtt_MakeCodepointBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, 0.0f,0.0f, codepoint);
}

//////////////////////////////////////////////////////////////////////////////
//
// bitmap baking
//
// This is SUPER-CRAPPY packing to keep source code small

static int stbtt_BakeFontBitmap_internal(unsigned char *data, int offset,  // font location (use offset=0 for plain .ttf)
                                float pixel_height,                     // height of font in pixels
                                unsigned char *pixels, int pw, int ph,  // bitmap to be filled in
                                int first_char, int num_chars,          // characters to bake
                                stbtt_bakedchar *chardata)
{
   float scale;
   int x,y,bottom_y, i;
   stbtt_fontinfo f;
   f.userdata = NULL;
   if (!stbtt_InitFont(&f, data, offset))
      return -1;
   STBTT_memset(pixels, 0, pw*ph); // background of 0 around pixels
   x=y=1;
   bottom_y = 1;

   scale = stbtt_ScaleForPixelHeight(&f, pixel_height);

   for (i=0; i < num_chars; ++i) {
      int advance, lsb, x0,y0,x1,y1,gw,gh;
      int g = stbtt_FindGlyphIndex(&f, first_char + i);
      stbtt_GetGlyphHMetrics(&f, g, &advance, &lsb);
      stbtt_GetGlyphBitmapBox(&f, g, scale,scale, &x0,&y0,&x1,&y1);
      gw = x1-x0;
      gh = y1-y0;
      if (x + gw + 1 >= pw)
         y = bottom_y, x = 1; // advance to next row
      if (y + gh + 1 >= ph) // check if it fits vertically AFTER potentially moving to next row
         return -i;
      STBTT_assert(x+gw < pw);
      STBTT_assert(y+gh < ph);
      stbtt_MakeGlyphBitmap(&f, pixels+x+y*pw, gw,gh,pw, scale,scale, g);
      chardata[i].x0 = (stbtt_int16) x;
      chardata[i].y0 = (stbtt_int16) y;
      chardata[i].x1 = (stbtt_int16) (x + gw);
      chardata[i].y1 = (stbtt_int16) (y + gh);
      chardata[i].xadvance = scale * advance;
      chardata[i].xoff     = (float) x0;
      chardata[i].yoff     = (float) y0;
      x = x + gw + 1;
      if (y+gh+1 > bottom_y)
         bottom_y = y+gh+1;
   }
   return bottom_y;
}

STBTT_DEF void stbtt_GetBakedQuad(const stbtt_bakedchar *chardata, int pw, int ph, int char_index, float *xpos, float *ypos, stbtt_aligned_quad *q, int opengl_fillrule)
{
   float d3d_bias = opengl_fillrule ? 0 : -0.5f;
   float ipw = 1.0f / pw, iph = 1.0f / ph;
   const stbtt_bakedchar *b = chardata + char_index;
   int round_x = STBTT_ifloor((*xpos + b->xoff) + 0.5f);
   int round_y = STBTT_ifloor((*ypos + b->yoff) + 0.5f);

   q->x0 = round_x + d3d_bias;
   q->y0 = round_y + d3d_bias;
   q->x1 = round_x + b->x1 - b->x0 + d3d_bias;
   q->y1 = round_y + b->y1 - b->y0 + d3d_bias;

   q->s0 = b->x0 * ipw;
   q->t0 = b->y0 * iph;
   q->s1 = b->x1 * ipw;
   q->t1 = b->y1 * iph;

   *xpos += b->xadvance;
}

//////////////////////////////////////////////////////////////////////////////
//
// rectangle packing replacement routines if you don't have stb_rect_pack.h
//

#ifndef STB_RECT_PACK_VERSION

typedef int stbrp_coord;

////////////////////////////////////////////////////////////////////////////////////
//                                                                                //
//                                                                                //
// COMPILER WARNING ?!?!?                                                         //
//                                                                                //
//                                                                                //
// if you get a compile warning due to these symbols being defined more than      //
// once, move #include "stb_rect_pack.h" before #include "stb_truetype.h"         //
//                                                                                //
////////////////////////////////////////////////////////////////////////////////////

typedef struct
{
   int width,height;
   int x,y,bottom_y;
} stbrp_context;

typedef struct
{
   unsigned char x;
} stbrp_node;

struct stbrp_rect
{
   stbrp_coord x,y;
   int id,w,h,was_packed;
};

static void stbrp_init_target(stbrp_context *con, int pw, int ph, stbrp_node *nodes, int num_nodes)
{
   con->width  = pw;
   con->height = ph;
   con->x = 0;
   con->y = 0;
   con->bottom_y = 0;
   STBTT__NOTUSED(nodes);
   STBTT__NOTUSED(num_nodes);   
}

static void stbrp_pack_rects(stbrp_context *con, stbrp_rect *rects, int num_rects)
{
   int i;
   for (i=0; i < num_rects; ++i) {
      if (con->x + rects[i].w > con->width) {
         con->x = 0;
         con->y = con->bottom_y;
      }
      if (con->y + rects[i].h > con->height)
         break;
      rects[i].x = con->x;
      rects[i].y = con->y;
      rects[i].was_packed = 1;
      con->x += rects[i].w;
      if (con->y + rects[i].h > con->bottom_y)
         con->bottom_y = con->y + rects[i].h;
   }
   for (   ; i < num_rects; ++i)
      rects[i].was_packed = 0;
}
#endif

//////////////////////////////////////////////////////////////////////////////
//
// bitmap baking
//
// This is SUPER-AWESOME (tm Ryan Gordon) packing using stb_rect_pack.h. If
// stb_rect_pack.h isn't available, it uses the BakeFontBitmap strategy.

STBTT_DEF int stbtt_PackBegin(stbtt_pack_context *spc, unsigned char *pixels, int pw, int ph, int stride_in_bytes, int padding, void *alloc_context)
{
   stbrp_context *context = (stbrp_context *) STBTT_malloc(sizeof(*context)            ,alloc_context);
   int            num_nodes = pw - padding;
   stbrp_node    *nodes   = (stbrp_node    *) STBTT_malloc(sizeof(*nodes  ) * num_nodes,alloc_context);

   if (context == NULL || nodes == NULL) {
      if (context != NULL) STBTT_free(context, alloc_context);
      if (nodes   != NULL) STBTT_free(nodes  , alloc_context);
      return 0;
   }

   spc->user_allocator_context = alloc_context;
   spc->width = pw;
   spc->height = ph;
   spc->pixels = pixels;
   spc->pack_info = context;
   spc->nodes = nodes;
   spc->padding = padding;
   spc->stride_in_bytes = stride_in_bytes != 0 ? stride_in_bytes : pw;
   spc->h_oversample = 1;
   spc->v_oversample = 1;
   spc->skip_missing = 0;

   stbrp_init_target(context, pw-padding, ph-padding, nodes, num_nodes);

   if (pixels)
      STBTT_memset(pixels, 0, pw*ph); // background of 0 around pixels

   return 1;
}

STBTT_DEF void stbtt_PackEnd  (stbtt_pack_context *spc)
{
   STBTT_free(spc->nodes    , spc->user_allocator_context);
   STBTT_free(spc->pack_info, spc->user_allocator_context);
}

STBTT_DEF void stbtt_PackSetOversampling(stbtt_pack_context *spc, unsigned int h_oversample, unsigned int v_oversample)
{
   STBTT_assert(h_oversample <= STBTT_MAX_OVERSAMPLE);
   STBTT_assert(v_oversample <= STBTT_MAX_OVERSAMPLE);
   if (h_oversample <= STBTT_MAX_OVERSAMPLE)
      spc->h_oversample = h_oversample;
   if (v_oversample <= STBTT_MAX_OVERSAMPLE)
      spc->v_oversample = v_oversample;
}

STBTT_DEF void stbtt_PackSetSkipMissingCodepoints(stbtt_pack_context *spc, int skip)
{
   spc->skip_missing = skip;
}

#define STBTT__OVER_MASK  (STBTT_MAX_OVERSAMPLE-1)

static void stbtt__h_prefilter(unsigned char *pixels, int w, int h, int stride_in_bytes, unsigned int kernel_width)
{
   unsigned char buffer[STBTT_MAX_OVERSAMPLE];
   int safe_w = w - kernel_width;
   int j;
   STBTT_memset(buffer, 0, STBTT_MAX_OVERSAMPLE); // suppress bogus warning from VS2013 -analyze
   for (j=0; j < h; ++j) {
      int i;
      unsigned int total;
      STBTT_memset(buffer, 0, kernel_width);

      total = 0;

      // make kernel_width a constant in common cases so compiler can optimize out the divide
      switch (kernel_width) {
         case 2:
            for (i=0; i <= safe_w; ++i) {
               total += pixels[i] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];
               pixels[i] = (unsigned char) (total / 2);
            }
            break;
         case 3:
            for (i=0; i <= safe_w; ++i) {
               total += pixels[i] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];
               pixels[i] = (unsigned char) (total / 3);
            }
            break;
         case 4:
            for (i=0; i <= safe_w; ++i) {
               total += pixels[i] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];
               pixels[i] = (unsigned char) (total / 4);
            }
            break;
         case 5:
            for (i=0; i <= safe_w; ++i) {
               total += pixels[i] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];
               pixels[i] = (unsigned char) (total / 5);
            }
            break;
         default:
            for (i=0; i <= safe_w; ++i) {
               total += pixels[i] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];
               pixels[i] = (unsigned char) (total / kernel_width);
            }
            break;
      }

      for (; i < w; ++i) {
         STBTT_assert(pixels[i] == 0);
         total -= buffer[i & STBTT__OVER_MASK];
         pixels[i] = (unsigned char) (total / kernel_width);
      }

      pixels += stride_in_bytes;
   }
}

static void stbtt__v_prefilter(unsigned char *pixels, int w, int h, int stride_in_bytes, unsigned int kernel_width)
{
   unsigned char buffer[STBTT_MAX_OVERSAMPLE];
   int safe_h = h - kernel_width;
   int j;
   STBTT_memset(buffer, 0, STBTT_MAX_OVERSAMPLE); // suppress bogus warning from VS2013 -analyze
   for (j=0; j < w; ++j) {
      int i;
      unsigned int total;
      STBTT_memset(buffer, 0, kernel_width);

      total = 0;

      // make kernel_width a constant in common cases so compiler can optimize out the divide
      switch (kernel_width) {
         case 2:
            for (i=0; i <= safe_h; ++i) {
               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];
               pixels[i*stride_in_bytes] = (unsigned char) (total / 2);
            }
            break;
         case 3:
            for (i=0; i <= safe_h; ++i) {
               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];
               pixels[i*stride_in_bytes] = (unsigned char) (total / 3);
            }
            break;
         case 4:
            for (i=0; i <= safe_h; ++i) {
               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];
               pixels[i*stride_in_bytes] = (unsigned char) (total / 4);
            }
            break;
         case 5:
            for (i=0; i <= safe_h; ++i) {
               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];
               pixels[i*stride_in_bytes] = (unsigned char) (total / 5);
            }
            break;
         default:
            for (i=0; i <= safe_h; ++i) {
               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];
               pixels[i*stride_in_bytes] = (unsigned char) (total / kernel_width);
            }
            break;
      }

      for (; i < h; ++i) {
         STBTT_assert(pixels[i*stride_in_bytes] == 0);
         total -= buffer[i & STBTT__OVER_MASK];
         pixels[i*stride_in_bytes] = (unsigned char) (total / kernel_width);
      }

      pixels += 1;
   }
}

static float stbtt__oversample_shift(int oversample)
{
   if (!oversample)
      return 0.0f;

   // The prefilter is a box filter of width "oversample",
   // which shifts phase by (oversample - 1)/2 pixels in
   // oversampled space. We want to shift in the opposite
   // direction to counter this.
   return (float)-(oversample - 1) / (2.0f * (float)oversample);
}

// rects array must be big enough to accommodate all characters in the given ranges
STBTT_DEF int stbtt_PackFontRangesGatherRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects)
{
   int i,j,k;

   k=0;
   for (i=0; i < num_ranges; ++i) {
      float fh = ranges[i].font_size;
      float scale = fh > 0 ? stbtt_ScaleForPixelHeight(info, fh) : stbtt_ScaleForMappingEmToPixels(info, -fh);
      ranges[i].h_oversample = (unsigned char) spc->h_oversample;
      ranges[i].v_oversample = (unsigned char) spc->v_oversample;
      for (j=0; j < ranges[i].num_chars; ++j) {
         int x0,y0,x1,y1;
         int codepoint = ranges[i].array_of_unicode_codepoints == NULL ? ranges[i].first_unicode_codepoint_in_range + j : ranges[i].array_of_unicode_codepoints[j];
         int glyph = stbtt_FindGlyphIndex(info, codepoint);
         if (glyph == 0 && spc->skip_missing) {
            rects[k].w = rects[k].h = 0;
         } else {
            stbtt_GetGlyphBitmapBoxSubpixel(info,glyph,
                                            scale * spc->h_oversample,
                                            scale * spc->v_oversample,
                                            0,0,
                                            &x0,&y0,&x1,&y1);
            rects[k].w = (stbrp_coord) (x1-x0 + spc->padding + spc->h_oversample-1);
            rects[k].h = (stbrp_coord) (y1-y0 + spc->padding + spc->v_oversample-1);
         }
         ++k;
      }
   }

   return k;
}

STBTT_DEF void stbtt_MakeGlyphBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int prefilter_x, int prefilter_y, float *sub_x, float *sub_y, int glyph)
{
   stbtt_MakeGlyphBitmapSubpixel(info,
                                 output,
                                 out_w - (prefilter_x - 1),
                                 out_h - (prefilter_y - 1),
                                 out_stride,
                                 scale_x,
                                 scale_y,
                                 shift_x,
                                 shift_y,
                                 glyph);

   if (prefilter_x > 1)
      stbtt__h_prefilter(output, out_w, out_h, out_stride, prefilter_x);

   if (prefilter_y > 1)
      stbtt__v_prefilter(output, out_w, out_h, out_stride, prefilter_y);

   *sub_x = stbtt__oversample_shift(prefilter_x);
   *sub_y = stbtt__oversample_shift(prefilter_y);
}

// rects array must be big enough to accommodate all characters in the given ranges
STBTT_DEF int stbtt_PackFontRangesRenderIntoRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects)
{
   int i,j,k, return_value = 1;

   // save current values
   int old_h_over = spc->h_oversample;
   int old_v_over = spc->v_oversample;

   k = 0;
   for (i=0; i < num_ranges; ++i) {
      float fh = ranges[i].font_size;
      float scale = fh > 0 ? stbtt_ScaleForPixelHeight(info, fh) : stbtt_ScaleForMappingEmToPixels(info, -fh);
      float recip_h,recip_v,sub_x,sub_y;
      spc->h_oversample = ranges[i].h_oversample;
      spc->v_oversample = ranges[i].v_oversample;
      recip_h = 1.0f / spc->h_oversample;
      recip_v = 1.0f / spc->v_oversample;
      sub_x = stbtt__oversample_shift(spc->h_oversample);
      sub_y = stbtt__oversample_shift(spc->v_oversample);
      for (j=0; j < ranges[i].num_chars; ++j) {
         stbrp_rect *r = &rects[k];
         if (r->was_packed && r->w != 0 && r->h != 0) {
            stbtt_packedchar *bc = &ranges[i].chardata_for_range[j];
            int advance, lsb, x0,y0,x1,y1;
            int codepoint = ranges[i].array_of_unicode_codepoints == NULL ? ranges[i].first_unicode_codepoint_in_range + j : ranges[i].array_of_unicode_codepoints[j];
            int glyph = stbtt_FindGlyphIndex(info, codepoint);
            stbrp_coord pad = (stbrp_coord) spc->padding;

            // pad on left and top
            r->x += pad;
            r->y += pad;
            r->w -= pad;
            r->h -= pad;
            stbtt_GetGlyphHMetrics(info, glyph, &advance, &lsb);
            stbtt_GetGlyphBitmapBox(info, glyph,
                                    scale * spc->h_oversample,
                                    scale * spc->v_oversample,
                                    &x0,&y0,&x1,&y1);
            stbtt_MakeGlyphBitmapSubpixel(info,
                                          spc->pixels + r->x + r->y*spc->stride_in_bytes,
                                          r->w - spc->h_oversample+1,
                                          r->h - spc->v_oversample+1,
                                          spc->stride_in_bytes,
                                          scale * spc->h_oversample,
                                          scale * spc->v_oversample,
                                          0,0,
                                          glyph);

            if (spc->h_oversample > 1)
               stbtt__h_prefilter(spc->pixels + r->x + r->y*spc->stride_in_bytes,
                                  r->w, r->h, spc->stride_in_bytes,
                                  spc->h_oversample);

            if (spc->v_oversample > 1)
               stbtt__v_prefilter(spc->pixels + r->x + r->y*spc->stride_in_bytes,
                                  r->w, r->h, spc->stride_in_bytes,
                                  spc->v_oversample);

            bc->x0       = (stbtt_int16)  r->x;
            bc->y0       = (stbtt_int16)  r->y;
            bc->x1       = (stbtt_int16) (r->x + r->w);
            bc->y1       = (stbtt_int16) (r->y + r->h);
            bc->xadvance =                scale * advance;
            bc->xoff     =       (float)  x0 * recip_h + sub_x;
            bc->yoff     =       (float)  y0 * recip_v + sub_y;
            bc->xoff2    =                (x0 + r->w) * recip_h + sub_x;
            bc->yoff2    =                (y0 + r->h) * recip_v + sub_y;
         } else {
            return_value = 0; // if any fail, report failure
         }

         ++k;
      }
   }

   // restore original values
   spc->h_oversample = old_h_over;
   spc->v_oversample = old_v_over;

   return return_value;
}

STBTT_DEF void stbtt_PackFontRangesPackRects(stbtt_pack_context *spc, stbrp_rect *rects, int num_rects)
{
   stbrp_pack_rects((stbrp_context *) spc->pack_info, rects, num_rects);
}

STBTT_DEF int stbtt_PackFontRanges(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, stbtt_pack_range *ranges, int num_ranges)
{
   stbtt_fontinfo info;
   int i,j,n, return_value = 1;
   //stbrp_context *context = (stbrp_context *) spc->pack_info;
   stbrp_rect    *rects;

   // flag all characters as NOT packed
   for (i=0; i < num_ranges; ++i)
      for (j=0; j < ranges[i].num_chars; ++j)
         ranges[i].chardata_for_range[j].x0 =
         ranges[i].chardata_for_range[j].y0 =
         ranges[i].chardata_for_range[j].x1 =
         ranges[i].chardata_for_range[j].y1 = 0;

   n = 0;
   for (i=0; i < num_ranges; ++i)
      n += ranges[i].num_chars;
         
   rects = (stbrp_rect *) STBTT_malloc(sizeof(*rects) * n, spc->user_allocator_context);
   if (rects == NULL)
      return 0;

   info.userdata = spc->user_allocator_context;
   stbtt_InitFont(&info, fontdata, stbtt_GetFontOffsetForIndex(fontdata,font_index));

   n = stbtt_PackFontRangesGatherRects(spc, &info, ranges, num_ranges, rects);

   stbtt_PackFontRangesPackRects(spc, rects, n);
  
   return_value = stbtt_PackFontRangesRenderIntoRects(spc, &info, ranges, num_ranges, rects);

   STBTT_free(rects, spc->user_allocator_context);
   return return_value;
}

STBTT_DEF int stbtt_PackFontRange(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, float font_size,
            int first_unicode_codepoint_in_range, int num_chars_in_range, stbtt_packedchar *chardata_for_range)
{
   stbtt_pack_range range;
   range.first_unicode_codepoint_in_range = first_unicode_codepoint_in_range;
   range.array_of_unicode_codepoints = NULL;
   range.num_chars                   = num_chars_in_range;
   range.chardata_for_range          = chardata_for_range;
   range.font_size                   = font_size;
   return stbtt_PackFontRanges(spc, fontdata, font_index, &range, 1);
}

STBTT_DEF void stbtt_GetScaledFontVMetrics(const unsigned char *fontdata, int index, float size, float *ascent, float *descent, float *lineGap)
{
   int i_ascent, i_descent, i_lineGap;
   float scale;
   stbtt_fontinfo info;
   stbtt_InitFont(&info, fontdata, stbtt_GetFontOffsetForIndex(fontdata, index));
   scale = size > 0 ? stbtt_ScaleForPixelHeight(&info, size) : stbtt_ScaleForMappingEmToPixels(&info, -size);
   stbtt_GetFontVMetrics(&info, &i_ascent, &i_descent, &i_lineGap);
   *ascent  = (float) i_ascent  * scale;
   *descent = (float) i_descent * scale;
   *lineGap = (float) i_lineGap * scale;
}

STBTT_DEF void stbtt_GetPackedQuad(const stbtt_packedchar *chardata, int pw, int ph, int char_index, float *xpos, float *ypos, stbtt_aligned_quad *q, int align_to_integer)
{
   float ipw = 1.0f / pw, iph = 1.0f / ph;
   const stbtt_packedchar *b = chardata + char_index;

   if (align_to_integer) {
      float x = (float) STBTT_ifloor((*xpos + b->xoff) + 0.5f);
      float y = (float) STBTT_ifloor((*ypos + b->yoff) + 0.5f);
      q->x0 = x;
      q->y0 = y;
      q->x1 = x + b->xoff2 - b->xoff;
      q->y1 = y + b->yoff2 - b->yoff;
   } else {
      q->x0 = *xpos + b->xoff;
      q->y0 = *ypos + b->yoff;
      q->x1 = *xpos + b->xoff2;
      q->y1 = *ypos + b->yoff2;
   }

   q->s0 = b->x0 * ipw;
   q->t0 = b->y0 * iph;
   q->s1 = b->x1 * ipw;
   q->t1 = b->y1 * iph;

   *xpos += b->xadvance;
}

//////////////////////////////////////////////////////////////////////////////
//
// sdf computation
//

#define STBTT_min(a,b)  ((a) < (b) ? (a) : (b))
#define STBTT_max(a,b)  ((a) < (b) ? (b) : (a))

static int stbtt__ray_intersect_bezier(float orig[2], float ray[2], float q0[2], float q1[2], float q2[2], float hits[2][2])
{
   float q0perp = q0[1]*ray[0] - q0[0]*ray[1];
   float q1perp = q1[1]*ray[0] - q1[0]*ray[1];
   float q2perp = q2[1]*ray[0] - q2[0]*ray[1];
   float roperp = orig[1]*ray[0] - orig[0]*ray[1];

   float a = q0perp - 2*q1perp + q2perp;
   float b = q1perp - q0perp;
   float c = q0perp - roperp;

   float s0 = 0., s1 = 0.;
   int num_s = 0;

   if (a != 0.0) {
      float discr = b*b - a*c;
      if (discr > 0.0) {
         float rcpna = -1 / a;
         float d = (float) STBTT_sqrt(discr);
         s0 = (b+d) * rcpna;
         s1 = (b-d) * rcpna;
         if (s0 >= 0.0 && s0 <= 1.0)
            num_s = 1;
         if (d > 0.0 && s1 >= 0.0 && s1 <= 1.0) {
            if (num_s == 0) s0 = s1;
            ++num_s;
         }
      }
   } else {
      // 2*b*s + c = 0
      // s = -c / (2*b)
      s0 = c / (-2 * b);
      if (s0 >= 0.0 && s0 <= 1.0)
         num_s = 1;
   }

   if (num_s == 0)
      return 0;
   else {
      float rcp_len2 = 1 / (ray[0]*ray[0] + ray[1]*ray[1]);
      float rayn_x = ray[0] * rcp_len2, rayn_y = ray[1] * rcp_len2;

      float q0d =   q0[0]*rayn_x +   q0[1]*rayn_y;
      float q1d =   q1[0]*rayn_x +   q1[1]*rayn_y;
      float q2d =   q2[0]*rayn_x +   q2[1]*rayn_y;
      float rod = orig[0]*rayn_x + orig[1]*rayn_y;

      float q10d = q1d - q0d;
      float q20d = q2d - q0d;
      float q0rd = q0d - rod;

      hits[0][0] = q0rd + s0*(2.0f - 2.0f*s0)*q10d + s0*s0*q20d;
      hits[0][1] = a*s0+b;

      if (num_s > 1) {
         hits[1][0] = q0rd + s1*(2.0f - 2.0f*s1)*q10d + s1*s1*q20d;
         hits[1][1] = a*s1+b;
         return 2;
      } else {
         return 1;
      }
   }
}

static int equal(float *a, float *b)
{
   return (a[0] == b[0] && a[1] == b[1]);
}

static int stbtt__compute_crossings_x(float x, float y, int nverts, stbtt_vertex *verts)
{
   int i;
   float orig[2], ray[2] = { 1, 0 };
   float y_frac;
   int winding = 0;

   orig[0] = x;
   //orig[1] = y; // [DEAR IMGUI] commmented double assignment

   // make sure y never passes through a vertex of the shape
   y_frac = (float) STBTT_fmod(y, 1.0f);
   if (y_frac < 0.01f)
      y += 0.01f;
   else if (y_frac > 0.99f)
      y -= 0.01f;
   orig[1] = y;

   // test a ray from (-infinity,y) to (x,y)
   for (i=0; i < nverts; ++i) {
      if (verts[i].type == STBTT_vline) {
         int x0 = (int) verts[i-1].x, y0 = (int) verts[i-1].y;
         int x1 = (int) verts[i  ].x, y1 = (int) verts[i  ].y;
         if (y > STBTT_min(y0,y1) && y < STBTT_max(y0,y1) && x > STBTT_min(x0,x1)) {
            float x_inter = (y - y0) / (y1 - y0) * (x1-x0) + x0;
            if (x_inter < x)  
               winding += (y0 < y1) ? 1 : -1;
         }
      }
      if (verts[i].type == STBTT_vcurve) {
         int x0 = (int) verts[i-1].x , y0 = (int) verts[i-1].y ;
         int x1 = (int) verts[i  ].cx, y1 = (int) verts[i  ].cy;
         int x2 = (int) verts[i  ].x , y2 = (int) verts[i  ].y ;
         int ax = STBTT_min(x0,STBTT_min(x1,x2)), ay = STBTT_min(y0,STBTT_min(y1,y2));
         int by = STBTT_max(y0,STBTT_max(y1,y2));
         if (y > ay && y < by && x > ax) {
            float q0[2],q1[2],q2[2];
            float hits[2][2];
            q0[0] = (float)x0;
            q0[1] = (float)y0;
            q1[0] = (float)x1;
            q1[1] = (float)y1;
            q2[0] = (float)x2;
            q2[1] = (float)y2;
            if (equal(q0,q1) || equal(q1,q2)) {
               x0 = (int)verts[i-1].x;
               y0 = (int)verts[i-1].y;
               x1 = (int)verts[i  ].x;
               y1 = (int)verts[i  ].y;
               if (y > STBTT_min(y0,y1) && y < STBTT_max(y0,y1) && x > STBTT_min(x0,x1)) {
                  float x_inter = (y - y0) / (y1 - y0) * (x1-x0) + x0;
                  if (x_inter < x)  
                     winding += (y0 < y1) ? 1 : -1;
               }
            } else {
               int num_hits = stbtt__ray_intersect_bezier(orig, ray, q0, q1, q2, hits);
               if (num_hits >= 1)
                  if (hits[0][0] < 0)
                     winding += (hits[0][1] < 0 ? -1 : 1);
               if (num_hits >= 2)
                  if (hits[1][0] < 0)
                     winding += (hits[1][1] < 0 ? -1 : 1);
            }
         } 
      }
   }
   return winding;
}

static float stbtt__cuberoot( float x )
{
   if (x<0)
      return -(float) STBTT_pow(-x,1.0f/3.0f);
   else
      return  (float) STBTT_pow( x,1.0f/3.0f);
}

// x^3 + c*x^2 + b*x + a = 0
static int stbtt__solve_cubic(float a, float b, float c, float* r)
{
	float s = -a / 3;
	float p = b - a*a / 3;
	float q = a * (2*a*a - 9*b) / 27 + c;
   float p3 = p*p*p;
	float d = q*q + 4*p3 / 27;
	if (d >= 0) {
		float z = (float) STBTT_sqrt(d);
		float u = (-q + z) / 2;
		float v = (-q - z) / 2;
		u = stbtt__cuberoot(u);
		v = stbtt__cuberoot(v);
		r[0] = s + u + v;
		return 1;
	} else {
	   float u = (float) STBTT_sqrt(-p/3);
	   float v = (float) STBTT_acos(-STBTT_sqrt(-27/p3) * q / 2) / 3; // p3 must be negative, since d is negative
	   float m = (float) STBTT_cos(v);
      float n = (float) STBTT_cos(v-3.141592/2)*1.732050808f;
	   r[0] = s + u * 2 * m;
	   r[1] = s - u * (m + n);
	   r[2] = s - u * (m - n);

      //STBTT_assert( STBTT_fabs(((r[0]+a)*r[0]+b)*r[0]+c) < 0.05f);  // these asserts may not be safe at all scales, though they're in bezier t parameter units so maybe?
      //STBTT_assert( STBTT_fabs(((r[1]+a)*r[1]+b)*r[1]+c) < 0.05f);
      //STBTT_assert( STBTT_fabs(((r[2]+a)*r[2]+b)*r[2]+c) < 0.05f);
   	return 3;
   }
}

STBTT_DEF unsigned char * stbtt_GetGlyphSDF(const stbtt_fontinfo *info, float scale, int glyph, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff)
{
   float scale_x = scale, scale_y = scale;
   int ix0,iy0,ix1,iy1;
   int w,h;
   unsigned char *data;

   // if one scale is 0, use same scale for both
   if (scale_x == 0) scale_x = scale_y;
   if (scale_y == 0) {
      if (scale_x == 0) return NULL;  // if both scales are 0, return NULL
      scale_y = scale_x;
   }

   stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale, scale, 0.0f,0.0f, &ix0,&iy0,&ix1,&iy1);

   // if empty, return NULL
   if (ix0 == ix1 || iy0 == iy1)
      return NULL;

   ix0 -= padding;
   iy0 -= padding;
   ix1 += padding;
   iy1 += padding;

   w = (ix1 - ix0);
   h = (iy1 - iy0);

   if (width ) *width  = w;
   if (height) *height = h;
   if (xoff  ) *xoff   = ix0;
   if (yoff  ) *yoff   = iy0;

   // invert for y-downwards bitmaps
   scale_y = -scale_y;
      
   {
      int x,y,i,j;
      float *precompute;
      stbtt_vertex *verts;
      int num_verts = stbtt_GetGlyphShape(info, glyph, &verts);
      data = (unsigned char *) STBTT_malloc(w * h, info->userdata);
      precompute = (float *) STBTT_malloc(num_verts * sizeof(float), info->userdata);

      for (i=0,j=num_verts-1; i < num_verts; j=i++) {
         if (verts[i].type == STBTT_vline) {
            float x0 = verts[i].x*scale_x, y0 = verts[i].y*scale_y;
            float x1 = verts[j].x*scale_x, y1 = verts[j].y*scale_y;
            float dist = (float) STBTT_sqrt((x1-x0)*(x1-x0) + (y1-y0)*(y1-y0));
            precompute[i] = (dist == 0) ? 0.0f : 1.0f / dist;
         } else if (verts[i].type == STBTT_vcurve) {
            float x2 = verts[j].x *scale_x, y2 = verts[j].y *scale_y;
            float x1 = verts[i].cx*scale_x, y1 = verts[i].cy*scale_y;
            float x0 = verts[i].x *scale_x, y0 = verts[i].y *scale_y;
            float bx = x0 - 2*x1 + x2, by = y0 - 2*y1 + y2;
            float len2 = bx*bx + by*by;
            if (len2 != 0.0f)
               precompute[i] = 1.0f / (bx*bx + by*by);
            else
               precompute[i] = 0.0f;
         } else
            precompute[i] = 0.0f;
      }

      for (y=iy0; y < iy1; ++y) {
         for (x=ix0; x < ix1; ++x) {
            float val;
            float min_dist = 999999.0f;
            float sx = (float) x + 0.5f;
            float sy = (float) y + 0.5f;
            float x_gspace = (sx / scale_x);
            float y_gspace = (sy / scale_y);

            int winding = stbtt__compute_crossings_x(x_gspace, y_gspace, num_verts, verts); // @OPTIMIZE: this could just be a rasterization, but needs to be line vs. non-tesselated curves so a new path

            for (i=0; i < num_verts; ++i) {
               float x0 = verts[i].x*scale_x, y0 = verts[i].y*scale_y;

               // check against every point here rather than inside line/curve primitives -- @TODO: wrong if multiple 'moves' in a row produce a garbage point, and given culling, probably more efficient to do within line/curve
               float dist2 = (x0-sx)*(x0-sx) + (y0-sy)*(y0-sy);
               if (dist2 < min_dist*min_dist)
                  min_dist = (float) STBTT_sqrt(dist2);

               if (verts[i].type == STBTT_vline) {
                  float x1 = verts[i-1].x*scale_x, y1 = verts[i-1].y*scale_y;

                  // coarse culling against bbox
                  //if (sx > STBTT_min(x0,x1)-min_dist && sx < STBTT_max(x0,x1)+min_dist &&
                  //    sy > STBTT_min(y0,y1)-min_dist && sy < STBTT_max(y0,y1)+min_dist)
                  float dist = (float) STBTT_fabs((x1-x0)*(y0-sy) - (y1-y0)*(x0-sx)) * precompute[i];
                  STBTT_assert(i != 0);
                  if (dist < min_dist) {
                     // check position along line
                     // x' = x0 + t*(x1-x0), y' = y0 + t*(y1-y0)
                     // minimize (x'-sx)*(x'-sx)+(y'-sy)*(y'-sy)
                     float dx = x1-x0, dy = y1-y0;
                     float px = x0-sx, py = y0-sy;
                     // minimize (px+t*dx)^2 + (py+t*dy)^2 = px*px + 2*px*dx*t + t^2*dx*dx + py*py + 2*py*dy*t + t^2*dy*dy
                     // derivative: 2*px*dx + 2*py*dy + (2*dx*dx+2*dy*dy)*t, set to 0 and solve
                     float t = -(px*dx + py*dy) / (dx*dx + dy*dy);
                     if (t >= 0.0f && t <= 1.0f)
                        min_dist = dist;
                  }
               } else if (verts[i].type == STBTT_vcurve) {
                  float x2 = verts[i-1].x *scale_x, y2 = verts[i-1].y *scale_y;
                  float x1 = verts[i  ].cx*scale_x, y1 = verts[i  ].cy*scale_y;
                  float box_x0 = STBTT_min(STBTT_min(x0,x1),x2);
                  float box_y0 = STBTT_min(STBTT_min(y0,y1),y2);
                  float box_x1 = STBTT_max(STBTT_max(x0,x1),x2);
                  float box_y1 = STBTT_max(STBTT_max(y0,y1),y2);
                  // coarse culling against bbox to avoid computing cubic unnecessarily
                  if (sx > box_x0-min_dist && sx < box_x1+min_dist && sy > box_y0-min_dist && sy < box_y1+min_dist) {
                     int num=0;
                     float ax = x1-x0, ay = y1-y0;
                     float bx = x0 - 2*x1 + x2, by = y0 - 2*y1 + y2;
                     float mx = x0 - sx, my = y0 - sy;
                     float res[3],px,py,t,it;
                     float a_inv = precompute[i];
                     if (a_inv == 0.0) { // if a_inv is 0, it's 2nd degree so use quadratic formula
                        float a = 3*(ax*bx + ay*by);
                        float b = 2*(ax*ax + ay*ay) + (mx*bx+my*by);
                        float c = mx*ax+my*ay;
                        if (a == 0.0) { // if a is 0, it's linear
                           if (b != 0.0) {
                              res[num++] = -c/b;
                           }
                        } else {
                           float discriminant = b*b - 4*a*c;
                           if (discriminant < 0)
                              num = 0;
                           else {
                              float root = (float) STBTT_sqrt(discriminant);
                              res[0] = (-b - root)/(2*a);
                              res[1] = (-b + root)/(2*a);
                              num = 2; // don't bother distinguishing 1-solution case, as code below will still work
                           }
                        }
                     } else {
                        float b = 3*(ax*bx + ay*by) * a_inv; // could precompute this as it doesn't depend on sample point
                        float c = (2*(ax*ax + ay*ay) + (mx*bx+my*by)) * a_inv;
                        float d = (mx*ax+my*ay) * a_inv;
                        num = stbtt__solve_cubic(b, c, d, res);
                     }
                     if (num >= 1 && res[0] >= 0.0f && res[0] <= 1.0f) {
                        t = res[0], it = 1.0f - t;
                        px = it*it*x0 + 2*t*it*x1 + t*t*x2;
                        py = it*it*y0 + 2*t*it*y1 + t*t*y2;
                        dist2 = (px-sx)*(px-sx) + (py-sy)*(py-sy);
                        if (dist2 < min_dist * min_dist)
                           min_dist = (float) STBTT_sqrt(dist2);
                     }
                     if (num >= 2 && res[1] >= 0.0f && res[1] <= 1.0f) {
                        t = res[1], it = 1.0f - t;
                        px = it*it*x0 + 2*t*it*x1 + t*t*x2;
                        py = it*it*y0 + 2*t*it*y1 + t*t*y2;
                        dist2 = (px-sx)*(px-sx) + (py-sy)*(py-sy);
                        if (dist2 < min_dist * min_dist)
                           min_dist = (float) STBTT_sqrt(dist2);
                     }
                     if (num >= 3 && res[2] >= 0.0f && res[2] <= 1.0f) {
                        t = res[2], it = 1.0f - t;
                        px = it*it*x0 + 2*t*it*x1 + t*t*x2;
                        py = it*it*y0 + 2*t*it*y1 + t*t*y2;
                        dist2 = (px-sx)*(px-sx) + (py-sy)*(py-sy);
                        if (dist2 < min_dist * min_dist)
                           min_dist = (float) STBTT_sqrt(dist2);
                     }
                  }
               }
            }
            if (winding == 0)
               min_dist = -min_dist;  // if outside the shape, value is negative
            val = onedge_value + pixel_dist_scale * min_dist;
            if (val < 0)
               val = 0;
            else if (val > 255)
               val = 255;
            data[(y-iy0)*w+(x-ix0)] = (unsigned char) val;
         }
      }
      STBTT_free(precompute, info->userdata);
      STBTT_free(verts, info->userdata);
   }
   return data;
}   

STBTT_DEF unsigned char * stbtt_GetCodepointSDF(const stbtt_fontinfo *info, float scale, int codepoint, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff)
{
   return stbtt_GetGlyphSDF(info, scale, stbtt_FindGlyphIndex(info, codepoint), padding, onedge_value, pixel_dist_scale, width, height, xoff, yoff);
}

STBTT_DEF void stbtt_FreeSDF(unsigned char *bitmap, void *userdata)
{
   STBTT_free(bitmap, userdata);
}

//////////////////////////////////////////////////////////////////////////////
//
// font name matching -- recommended not to use this
//

// check if a utf8 string contains a prefix which is the utf16 string; if so return length of matching utf8 string
static stbtt_int32 stbtt__CompareUTF8toUTF16_bigendian_prefix(stbtt_uint8 *s1, stbtt_int32 len1, stbtt_uint8 *s2, stbtt_int32 len2) 
{
   stbtt_int32 i=0;

   // convert utf16 to utf8 and compare the results while converting
   while (len2) {
      stbtt_uint16 ch = s2[0]*256 + s2[1];
      if (ch < 0x80) {
         if (i >= len1) return -1;
         if (s1[i++] != ch) return -1;
      } else if (ch < 0x800) {
         if (i+1 >= len1) return -1;
         if (s1[i++] != 0xc0 + (ch >> 6)) return -1;
         if (s1[i++] != 0x80 + (ch & 0x3f)) return -1;
      } else if (ch >= 0xd800 && ch < 0xdc00) {
         stbtt_uint32 c;
         stbtt_uint16 ch2 = s2[2]*256 + s2[3];
         if (i+3 >= len1) return -1;
         c = ((ch - 0xd800) << 10) + (ch2 - 0xdc00) + 0x10000;
         if (s1[i++] != 0xf0 + (c >> 18)) return -1;
         if (s1[i++] != 0x80 + ((c >> 12) & 0x3f)) return -1;
         if (s1[i++] != 0x80 + ((c >>  6) & 0x3f)) return -1;
         if (s1[i++] != 0x80 + ((c      ) & 0x3f)) return -1;
         s2 += 2; // plus another 2 below
         len2 -= 2;
      } else if (ch >= 0xdc00 && ch < 0xe000) {
         return -1;
      } else {
         if (i+2 >= len1) return -1;
         if (s1[i++] != 0xe0 + (ch >> 12)) return -1;
         if (s1[i++] != 0x80 + ((ch >> 6) & 0x3f)) return -1;
         if (s1[i++] != 0x80 + ((ch     ) & 0x3f)) return -1;
      }
      s2 += 2;
      len2 -= 2;
   }
   return i;
}

static int stbtt_CompareUTF8toUTF16_bigendian_internal(char *s1, int len1, char *s2, int len2) 
{
   return len1 == stbtt__CompareUTF8toUTF16_bigendian_prefix((stbtt_uint8*) s1, len1, (stbtt_uint8*) s2, len2);
}

// returns results in whatever encoding you request... but note that 2-byte encodings
// will be BIG-ENDIAN... use stbtt_CompareUTF8toUTF16_bigendian() to compare
STBTT_DEF const char *stbtt_GetFontNameString(const stbtt_fontinfo *font, int *length, int platformID, int encodingID, int languageID, int nameID)
{
   stbtt_int32 i,count,stringOffset;
   stbtt_uint8 *fc = font->data;
   stbtt_uint32 offset = font->fontstart;
   stbtt_uint32 nm = stbtt__find_table(fc, offset, "name");
   if (!nm) return NULL;

   count = ttUSHORT(fc+nm+2);
   stringOffset = nm + ttUSHORT(fc+nm+4);
   for (i=0; i < count; ++i) {
      stbtt_uint32 loc = nm + 6 + 12 * i;
      if (platformID == ttUSHORT(fc+loc+0) && encodingID == ttUSHORT(fc+loc+2)
          && languageID == ttUSHORT(fc+loc+4) && nameID == ttUSHORT(fc+loc+6)) {
         *length = ttUSHORT(fc+loc+8);
         return (const char *) (fc+stringOffset+ttUSHORT(fc+loc+10));
      }
   }
   return NULL;
}

static int stbtt__matchpair(stbtt_uint8 *fc, stbtt_uint32 nm, stbtt_uint8 *name, stbtt_int32 nlen, stbtt_int32 target_id, stbtt_int32 next_id)
{
   stbtt_int32 i;
   stbtt_int32 count = ttUSHORT(fc+nm+2);
   stbtt_int32 stringOffset = nm + ttUSHORT(fc+nm+4);

   for (i=0; i < count; ++i) {
      stbtt_uint32 loc = nm + 6 + 12 * i;
      stbtt_int32 id = ttUSHORT(fc+loc+6);
      if (id == target_id) {
         // find the encoding
         stbtt_int32 platform = ttUSHORT(fc+loc+0), encoding = ttUSHORT(fc+loc+2), language = ttUSHORT(fc+loc+4);

         // is this a Unicode encoding?
         if (platform == 0 || (platform == 3 && encoding == 1) || (platform == 3 && encoding == 10)) {
            stbtt_int32 slen = ttUSHORT(fc+loc+8);
            stbtt_int32 off = ttUSHORT(fc+loc+10);

            // check if there's a prefix match
            stbtt_int32 matchlen = stbtt__CompareUTF8toUTF16_bigendian_prefix(name, nlen, fc+stringOffset+off,slen);
            if (matchlen >= 0) {
               // check for target_id+1 immediately following, with same encoding & language
               if (i+1 < count && ttUSHORT(fc+loc+12+6) == next_id && ttUSHORT(fc+loc+12) == platform && ttUSHORT(fc+loc+12+2) == encoding && ttUSHORT(fc+loc+12+4) == language) {
                  slen = ttUSHORT(fc+loc+12+8);
                  off = ttUSHORT(fc+loc+12+10);
                  if (slen == 0) {
                     if (matchlen == nlen)
                        return 1;
                  } else if (matchlen < nlen && name[matchlen] == ' ') {
                     ++matchlen;
                     if (stbtt_CompareUTF8toUTF16_bigendian_internal((char*) (name+matchlen), nlen-matchlen, (char*)(fc+stringOffset+off),slen))
                        return 1;
                  }
               } else {
                  // if nothing immediately following
                  if (matchlen == nlen)
                     return 1;
               }
            }
         }

         // @TODO handle other encodings
      }
   }
   return 0;
}

static int stbtt__matches(stbtt_uint8 *fc, stbtt_uint32 offset, stbtt_uint8 *name, stbtt_int32 flags)
{
   stbtt_int32 nlen = (stbtt_int32) STBTT_strlen((char *) name);
   stbtt_uint32 nm,hd;
   if (!stbtt__isfont(fc+offset)) return 0;

   // check italics/bold/underline flags in macStyle...
   if (flags) {
      hd = stbtt__find_table(fc, offset, "head");
      if ((ttUSHORT(fc+hd+44) & 7) != (flags & 7)) return 0;
   }

   nm = stbtt__find_table(fc, offset, "name");
   if (!nm) return 0;

   if (flags) {
      // if we checked the macStyle flags, then just check the family and ignore the subfamily
      if (stbtt__matchpair(fc, nm, name, nlen, 16, -1))  return 1;
      if (stbtt__matchpair(fc, nm, name, nlen,  1, -1))  return 1;
      if (stbtt__matchpair(fc, nm, name, nlen,  3, -1))  return 1;
   } else {
      if (stbtt__matchpair(fc, nm, name, nlen, 16, 17))  return 1;
      if (stbtt__matchpair(fc, nm, name, nlen,  1,  2))  return 1;
      if (stbtt__matchpair(fc, nm, name, nlen,  3, -1))  return 1;
   }

   return 0;
}

static int stbtt_FindMatchingFont_internal(unsigned char *font_collection, char *name_utf8, stbtt_int32 flags)
{
   stbtt_int32 i;
   for (i=0;;++i) {
      stbtt_int32 off = stbtt_GetFontOffsetForIndex(font_collection, i);
      if (off < 0) return off;
      if (stbtt__matches((stbtt_uint8 *) font_collection, off, (stbtt_uint8*) name_utf8, flags))
         return off;
   }
}

#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wcast-qual"
#endif

STBTT_DEF int stbtt_BakeFontBitmap(const unsigned char *data, int offset,
                                float pixel_height, unsigned char *pixels, int pw, int ph,
                                int first_char, int num_chars, stbtt_bakedchar *chardata)
{
   return stbtt_BakeFontBitmap_internal((unsigned char *) data, offset, pixel_height, pixels, pw, ph, first_char, num_chars, chardata);
}

STBTT_DEF int stbtt_GetFontOffsetForIndex(const unsigned char *data, int index)
{
   return stbtt_GetFontOffsetForIndex_internal((unsigned char *) data, index);   
}

STBTT_DEF int stbtt_GetNumberOfFonts(const unsigned char *data)
{
   return stbtt_GetNumberOfFonts_internal((unsigned char *) data);
}

STBTT_DEF int stbtt_InitFont(stbtt_fontinfo *info, const unsigned char *data, int offset)
{
   return stbtt_InitFont_internal(info, (unsigned char *) data, offset);
}

STBTT_DEF int stbtt_FindMatchingFont(const unsigned char *fontdata, const char *name, int flags)
{
   return stbtt_FindMatchingFont_internal((unsigned char *) fontdata, (char *) name, flags);
}

STBTT_DEF int stbtt_CompareUTF8toUTF16_bigendian(const char *s1, int len1, const char *s2, int len2)
{
   return stbtt_CompareUTF8toUTF16_bigendian_internal((char *) s1, len1, (char *) s2, len2);
}

#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic pop
#endif

#endif // STB_TRUETYPE_IMPLEMENTATION


// FULL VERSION HISTORY
//
//   1.19 (2018-02-11) OpenType GPOS kerning (horizontal only), STBTT_fmod
//   1.18 (2018-01-29) add missing function
//   1.17 (2017-07-23) make more arguments const; doc fix
//   1.16 (2017-07-12) SDF support
//   1.15 (2017-03-03) make more arguments const
//   1.14 (2017-01-16) num-fonts-in-TTC function
//   1.13 (2017-01-02) support OpenType fonts, certain Apple fonts
//   1.12 (2016-10-25) suppress warnings about casting away const with -Wcast-qual
//   1.11 (2016-04-02) fix unused-variable warning
//   1.10 (2016-04-02) allow user-defined fabs() replacement
//                     fix memory leak if fontsize=0.0
//                     fix warning from duplicate typedef
//   1.09 (2016-01-16) warning fix; avoid crash on outofmem; use alloc userdata for PackFontRanges
//   1.08 (2015-09-13) document stbtt_Rasterize(); fixes for vertical & horizontal edges
//   1.07 (2015-08-01) allow PackFontRanges to accept arrays of sparse codepoints;
//                     allow PackFontRanges to pack and render in separate phases;
//                     fix stbtt_GetFontOFfsetForIndex (never worked for non-0 input?);
//                     fixed an assert() bug in the new rasterizer
//                     replace assert() with STBTT_assert() in new rasterizer
//   1.06 (2015-07-14) performance improvements (~35% faster on x86 and x64 on test machine)
//                     also more precise AA rasterizer, except if shapes overlap
//                     remove need for STBTT_sort
//   1.05 (2015-04-15) fix misplaced definitions for STBTT_STATIC
//   1.04 (2015-04-15) typo in example
//   1.03 (2015-04-12) STBTT_STATIC, fix memory leak in new packing, various fixes
//   1.02 (2014-12-10) fix various warnings & compile issues w/ stb_rect_pack, C++
//   1.01 (2014-12-08) fix subpixel position when oversampling to exactly match
//                        non-oversampled; STBTT_POINT_SIZE for packed case only
//   1.00 (2014-12-06) add new PackBegin etc. API, w/ support for oversampling
//   0.99 (2014-09-18) fix multiple bugs with subpixel rendering (ryg)
//   0.9  (2014-08-07) support certain mac/iOS fonts without an MS platformID
//   0.8b (2014-07-07) fix a warning
//   0.8  (2014-05-25) fix a few more warnings
//   0.7  (2013-09-25) bugfix: subpixel glyph bug fixed in 0.5 had come back
//   0.6c (2012-07-24) improve documentation
//   0.6b (2012-07-20) fix a few more warnings
//   0.6  (2012-07-17) fix warnings; added stbtt_ScaleForMappingEmToPixels,
//                        stbtt_GetFontBoundingBox, stbtt_IsGlyphEmpty
//   0.5  (2011-12-09) bugfixes:
//                        subpixel glyph renderer computed wrong bounding box
//                        first vertex of shape can be off-curve (FreeSans)
//   0.4b (2011-12-03) fixed an error in the font baking example
//   0.4  (2011-12-01) kerning, subpixel rendering (tor)
//                    bugfixes for:
//                        codepoint-to-glyph conversion using table fmt=12
//                        codepoint-to-glyph conversion using table fmt=4
//                        stbtt_GetBakedQuad with non-square texture (Zer)
//                    updated Hello World! sample to use kerning and subpixel
//                    fixed some warnings
//   0.3  (2009-06-24) cmap fmt=12, compound shapes (MM)
//                    userdata, malloc-from-userdata, non-zero fill (stb)
//   0.2  (2009-03-11) Fix unsigned/signed char warnings
//   0.1  (2009-03-09) First public release
//

/*
------------------------------------------------------------------------------
This software is available under 2 licenses -- choose whichever you prefer.
------------------------------------------------------------------------------
ALTERNATIVE A - MIT License
Copyright (c) 2017 Sean Barrett
Permission is hereby granted, free of charge, to any person obtaining a copy of 
this software and associated documentation files (the "Software"), to deal in 
the Software without restriction, including without limitation the rights to 
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies 
of the Software, and to permit persons to whom the Software is furnished to do 
so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all 
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE 
SOFTWARE.
------------------------------------------------------------------------------
ALTERNATIVE B - Public Domain (www.unlicense.org)
This is free and unencumbered software released into the public domain.
Anyone is free to copy, modify, publish, use, compile, sell, or distribute this 
software, either in source code form or as a compiled binary, for any purpose, 
commercial or non-commercial, and by any means.
In jurisdictions that recognize copyright laws, the author or authors of this 
software dedicate any and all copyright interest in the software to the public 
domain. We make this dedication for the benefit of the public at large and to 
the detriment of our heirs and successors. We intend this dedication to be an 
overt act of relinquishment in perpetuity of all present and future rights to 
this software under copyright law.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN 
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
------------------------------------------------------------------------------
*/

```

`Artemis/KeybindManager.cpp`:

```cpp
#include "pch.h"
#include "KeybindManager.h"

namespace Artemis {
	void IKeybind::Invoke() {
		if (GetAsyncKeyState((int)nKey) & (1 << (Aurora::Binary<SHORT>::BufferBitCount - 1)))
			OnKeyPress();
	}

	void KeybindManager::Invoke() {
		for (IKeybind* pKeybind : InvocableCollection)
			if (pKeybind)
				pKeybind->Invoke();
	}
}
```

`Artemis/KeybindManager.h`:

```h
#ifndef __ARTEMIS_KEYBIND_MANAGER_H__
#define __ARTEMIS_KEYBIND_MANAGER_H__

#include <Windows.h>

#include "Definitions.h"
#include "Manager.h"

namespace Artemis {
	enum class VirtualKey : int {
		LeftMouseButton = VK_LBUTTON,
		RightMouseButton = VK_RBUTTON,
		MiddleMouseButton = VK_MBUTTON,
		ExtraMouseButton1 = VK_XBUTTON1,
		ExtraMouseButton2 = VK_XBUTTON2,

		Backspace = VK_BACK,
		Tab = VK_TAB,
		Enter = VK_RETURN,
		Shift = VK_SHIFT,
		Control = VK_CONTROL,
		Alt = VK_MENU,
		Pause = VK_PAUSE,
		CapsLock = VK_CAPITAL,
		Escape = VK_ESCAPE,
		Space = VK_SPACE,
		PageUp = VK_PRIOR,
		PageDown = VK_NEXT,
		End = VK_END,
		Home = VK_HOME,

		LeftArrow = VK_LEFT,
		UpArrow = VK_UP,
		RightArrow = VK_RIGHT,
		DownArrow = VK_DOWN,

		PrintScreen = VK_SNAPSHOT,
		Insert = VK_INSERT,
		Delete = VK_DELETE,

		Zero = '0',
		One = '1',
		Two = '2',
		Three = '3',
		Four = '4',
		Five = '5',
		Six = '6',
		Seven = '7',
		Eight = '8',
		Nine = '9',

		A = 'A',
		B = 'B',
		C = 'C',
		D = 'D',
		E = 'E',
		F = 'F',
		G = 'G',
		H = 'H',
		I = 'I',
		J = 'J',
		K = 'K',
		L = 'L',
		M = 'M',
		N = 'N',
		O = 'O',
		P = 'P',
		Q = 'Q',
		R = 'R',
		S = 'S',
		T = 'T',
		U = 'U',
		V = 'V',
		W = 'W',
		X = 'X',
		Y = 'Y',
		Z = 'Z',

		LeftWindows = VK_LWIN,
		RightWindows = VK_RWIN,
		Apps = VK_APPS,
		NumpadZero = VK_NUMPAD0,
		NumpadOne = VK_NUMPAD1,
		NumpadTwo = VK_NUMPAD2,
		NumpadThree = VK_NUMPAD3,
		NumpadFour = VK_NUMPAD4,
		NumpadFive = VK_NUMPAD5,
		NumpadSix = VK_NUMPAD6,
		NumpadSeven = VK_NUMPAD7,
		NumpadEight = VK_NUMPAD8,
		NumpadNine = VK_NUMPAD9,
		Multiply = VK_MULTIPLY,
		Add = VK_ADD,
		Separator = VK_SEPARATOR,
		Subtract = VK_SUBTRACT,
		Decimal = VK_DECIMAL,
		Divide = VK_DIVIDE,

		F1 = VK_F1,
		F2 = VK_F2,
		F3 = VK_F3,
		F4 = VK_F4,
		F5 = VK_F5,
		F6 = VK_F6,
		F7 = VK_F7,
		F8 = VK_F8,
		F9 = VK_F9,
		F10 = VK_F10,
		F11 = VK_F11,
		F12 = VK_F12,

		NumLock = VK_NUMLOCK,
		ScrollLock = VK_SCROLL,
		LeftShift = VK_LSHIFT,
		RightShift = VK_RSHIFT,
		LeftControl = VK_LCONTROL,
		RightControl = VK_RCONTROL,
		LeftAlt = VK_LMENU,
		RightAlt = VK_RMENU,
		VolumeMute = VK_VOLUME_MUTE,
		VolumeDown = VK_VOLUME_DOWN,
		VolumeUp = VK_VOLUME_UP,
		NextTrack = VK_MEDIA_NEXT_TRACK,
		PreviousTrack = VK_MEDIA_PREV_TRACK,
		StopTrack = VK_MEDIA_STOP,
		PlayPause = VK_MEDIA_PLAY_PAUSE
	};

	class ARTEMIS_API IKeybind {
		VirtualKey nKey;
		bool bExclusive;

	public:
		constexpr IKeybind(_In_ VirtualKey nKey, _In_ bool bExclusive) noexcept : nKey(nKey), bExclusive(bExclusive) {}

		virtual void OnKeyPress() = 0;

		void Invoke();

		constexpr VirtualKey GetKey() const noexcept { return nKey; }
		constexpr bool IsExclusive() const noexcept { return bExclusive; }
	};

	using KeybindIndex = int;

#ifdef _ARTEMIS_EXPORT
	extern template class Manager<IKeybind, KeybindIndex>;
#endif // _ARTEMIS_EXPORT

	class ARTEMIS_API KeybindManager : public Manager<IKeybind, KeybindIndex> {
	public:
		void Invoke();
	};
}

#endif // !__ARTEMIS_KEYBIND_MANAGER_H__
```

`Artemis/Keybinds.cpp`:

```cpp
#include "pch.h"
#include "Keybinds.h"
#include "External.h"

ExitKeybind::ExitKeybind() : IKeybind(Artemis::VirtualKey::F1, true) {}

void ExitKeybind::OnKeyPress() { Artemis::Exit(); }
```

`Artemis/Keybinds.h`:

```h
#pragma once

#include "KeybindManager.h"

class ExitKeybind : public Artemis::IKeybind {
public:
	ExitKeybind();

	virtual void OnKeyPress() final;
};
```

`Artemis/Manager.cpp`:

```cpp
#include "pch.h"
#include "Manager.h"

#include "DrawManager.h"
#include "EventManager.h"
#include "KeybindManager.h"
#include "WindowManager.h"

namespace Artemis {
	template<AbstractClass IInvocable, Int32 InvocableIndex>
	Manager<IInvocable, InvocableIndex>::Manager() { ZeroMemory(InvocableCollection, sizeof(InvocableCollection)); }

	template<AbstractClass IInvocable, Int32 InvocableIndex>
	Manager<IInvocable, InvocableIndex>::~Manager() { this->Release(); }

	template<AbstractClass IInvocable, Int32 InvocableIndex>
	InvocableIndex Manager<IInvocable, InvocableIndex>::Add(_In_ IInvocable* pObject) {
		for (InvocableIndex i = 0; i < MAX_INVOKE; i++)
			if (!InvocableCollection[i]) {
				InvocableCollection[i] = pObject;
				return i;
			}

		delete pObject;
		return INVALID_INDEX;
	}

	template<AbstractClass IInvocable, Int32 InvocableIndex>
	void Manager<IInvocable, InvocableIndex>::Release(_In_range_(INVALID_INDEX, MAX_INVOKE) InvocableIndex nIndex) {
		if (nIndex == INVALID_INDEX) {
			for (IInvocable* pObject : InvocableCollection)
				if (pObject)
					delete pObject;
			memset(InvocableCollection, 0, sizeof(InvocableCollection));
		}
		else if (InvocableCollection[nIndex]) {
			delete InvocableCollection[nIndex];
			InvocableCollection[nIndex] = nullptr;
		}
	}

	template<AbstractClass IInvocable, Int32 InvocableIndex>
	_Ret_maybenull_ IInvocable* Manager<IInvocable, InvocableIndex>::Get(_In_range_(0, MAX_INVOKE) InvocableIndex nIndex) {
		if (nIndex > 64 || nIndex < 0) return nullptr;
		return InvocableCollection[nIndex];
	}

	template class ARTEMIS_EXPORT Manager<IDraw, DrawIndex>;
	template class ARTEMIS_EXPORT Manager<IEventEntry, EventEntryIndex>;
	template class ARTEMIS_EXPORT Manager<IKeybind, KeybindIndex>;
	template class ARTEMIS_EXPORT Manager<IWindow, WindowIndex>;
}
```

`Artemis/Manager.h`:

```h
#ifndef __ARTEMIS_MANAGER_H__
#define __ARTEMIS_MANAGER_H__

#include <type_traits>

#include "Definitions.h"

namespace Artemis {
	template<class T>
	concept AbstractClass = std::is_abstract<T>::value;

	template<class T>
	concept Int32 = std::is_same<T, int>::value;

	template<AbstractClass IInvocable, Int32 InvocableIndex>
	class Manager {
	protected:
		IInvocable* InvocableCollection[MAX_INVOKE];

	public:
		Manager();
		~Manager();

		InvocableIndex Add(_In_ IInvocable* pObject);

		void Release(_In_range_(INVALID_INDEX, MAX_INVOKE) InvocableIndex nIndex = INVALID_INDEX);

		_Ret_maybenull_ IInvocable* Get(_In_range_(0, MAX_INVOKE) InvocableIndex nIndex);
	};
}

#endif // !__ARTEMIS_MANAGER_H__
```

`Artemis/MinHook/MinHook.h`:

```h
/*
 *  MinHook - The Minimalistic API Hooking Library for x64/x86
 *  Copyright (C) 2009-2017 Tsuda Kageyu.
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *   1. Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 *  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 *  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
 *  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#pragma once

#ifdef _MH_EXPORT
#define MH_API __declspec(dllexport)
#else
#define MH_API __declspec(dllimport)
#endif

#if !(defined _M_IX86) && !(defined _M_X64) && !(defined __i386__) && !(defined __x86_64__)
    #error MinHook supports only x86 and x64 systems.
#endif

#include <windows.h>

// MinHook Error Codes.
typedef enum MH_STATUS
{
    // Unknown error. Should not be returned.
    MH_UNKNOWN = -1,

    // Successful.
    MH_OK = 0,

    // MinHook is already initialized.
    MH_ERROR_ALREADY_INITIALIZED,

    // MinHook is not initialized yet, or already uninitialized.
    MH_ERROR_NOT_INITIALIZED,

    // The hook for the specified target function is already created.
    MH_ERROR_ALREADY_CREATED,

    // The hook for the specified target function is not created yet.
    MH_ERROR_NOT_CREATED,

    // The hook for the specified target function is already enabled.
    MH_ERROR_ENABLED,

    // The hook for the specified target function is not enabled yet, or already
    // disabled.
    MH_ERROR_DISABLED,

    // The specified pointer is invalid. It points the address of non-allocated
    // and/or non-executable region.
    MH_ERROR_NOT_EXECUTABLE,

    // The specified target function cannot be hooked.
    MH_ERROR_UNSUPPORTED_FUNCTION,

    // Failed to allocate memory.
    MH_ERROR_MEMORY_ALLOC,

    // Failed to change the memory protection.
    MH_ERROR_MEMORY_PROTECT,

    // The specified module is not loaded.
    MH_ERROR_MODULE_NOT_FOUND,

    // The specified function is not found.
    MH_ERROR_FUNCTION_NOT_FOUND
}
MH_STATUS;

// Can be passed as a parameter to MH_EnableHook, MH_DisableHook,
// MH_QueueEnableHook or MH_QueueDisableHook.
#define MH_ALL_HOOKS NULL

#ifdef __cplusplus
extern "C" {
#endif

    // Initialize the MinHook library. You must call this function EXACTLY ONCE
    // at the beginning of your program.
    MH_API MH_STATUS WINAPI MH_Initialize(VOID);

    // Uninitialize the MinHook library. You must call this function EXACTLY
    // ONCE at the end of your program.
    MH_API MH_STATUS WINAPI MH_Uninitialize(VOID);

    // Creates a hook for the specified target function, in disabled state.
    // Parameters:
    //   pTarget     [in]  A pointer to the target function, which will be
    //                     overridden by the detour function.
    //   pDetour     [in]  A pointer to the detour function, which will override
    //                     the target function.
    //   ppOriginal  [out] A pointer to the trampoline function, which will be
    //                     used to call the original target function.
    //                     This parameter can be NULL.
    MH_API MH_STATUS WINAPI MH_CreateHook(LPVOID pTarget, LPVOID pDetour, LPVOID *ppOriginal);

    // Creates a hook for the specified API function, in disabled state.
    // Parameters:
    //   pszModule   [in]  A pointer to the loaded module name which contains the
    //                     target function.
    //   pszProcName [in]  A pointer to the target function name, which will be
    //                     overridden by the detour function.
    //   pDetour     [in]  A pointer to the detour function, which will override
    //                     the target function.
    //   ppOriginal  [out] A pointer to the trampoline function, which will be
    //                     used to call the original target function.
    //                     This parameter can be NULL.
    MH_API MH_STATUS WINAPI MH_CreateHookApi(
        LPCWSTR pszModule, LPCSTR pszProcName, LPVOID pDetour, LPVOID *ppOriginal);

    // Creates a hook for the specified API function, in disabled state.
    // Parameters:
    //   pszModule   [in]  A pointer to the loaded module name which contains the
    //                     target function.
    //   pszProcName [in]  A pointer to the target function name, which will be
    //                     overridden by the detour function.
    //   pDetour     [in]  A pointer to the detour function, which will override
    //                     the target function.
    //   ppOriginal  [out] A pointer to the trampoline function, which will be
    //                     used to call the original target function.
    //                     This parameter can be NULL.
    //   ppTarget    [out] A pointer to the target function, which will be used
    //                     with other functions.
    //                     This parameter can be NULL.
    MH_API MH_STATUS WINAPI MH_CreateHookApiEx(
        LPCWSTR pszModule, LPCSTR pszProcName, LPVOID pDetour, LPVOID *ppOriginal, LPVOID *ppTarget);

    // Removes an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    MH_API MH_STATUS WINAPI MH_RemoveHook(LPVOID pTarget);

    // Enables an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    //                If this parameter is MH_ALL_HOOKS, all created hooks are
    //                enabled in one go.
    MH_API MH_STATUS WINAPI MH_EnableHook(LPVOID pTarget);

    // Disables an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    //                If this parameter is MH_ALL_HOOKS, all created hooks are
    //                disabled in one go.
    MH_API MH_STATUS WINAPI MH_DisableHook(LPVOID pTarget);

    // Queues to enable an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    //                If this parameter is MH_ALL_HOOKS, all created hooks are
    //                queued to be enabled.
    MH_API MH_STATUS WINAPI MH_QueueEnableHook(LPVOID pTarget);

    // Queues to disable an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    //                If this parameter is MH_ALL_HOOKS, all created hooks are
    //                queued to be disabled.
    MH_API MH_STATUS WINAPI MH_QueueDisableHook(LPVOID pTarget);

    // Applies all queued changes in one go.
    MH_API MH_STATUS WINAPI MH_ApplyQueued(VOID);

    // Translates the MH_STATUS to its name as a string.
    MH_API const char * WINAPI MH_StatusToString(MH_STATUS status);

#ifdef __cplusplus
}
#endif

```

`Artemis/PresentHook.cpp`:

```cpp
#include "pch.h"
#include "PresentHook.h"
#include "External.h"

#include "Events.h"

#pragma comment(lib, "d3d11.lib")

typedef struct _ENUMWINDOWSPARAM {
	DWORD dwProcessId;
	HWND hWnd;
} ENUMWINDOWSPARAM, * PENUMWINDOWSPARAM;

BOOL WINAPI EnumWindowsCallback(HWND hWnd, LPARAM lParam) {
	PENUMWINDOWSPARAM pEnumWindowsParam = (PENUMWINDOWSPARAM)lParam;

	DWORD dwProcessId = 0;
	GetWindowThreadProcessId(hWnd, &dwProcessId);

	if (pEnumWindowsParam->dwProcessId != dwProcessId || !IsWindowVisible(hWnd))
		return TRUE;
	pEnumWindowsParam->hWnd = hWnd;
	return FALSE;
}

HWND GetGameWindow() {
	ENUMWINDOWSPARAM EnumWindowsParam;
	EnumWindowsParam.dwProcessId = GetCurrentProcessId();
	EnumWindowsParam.hWnd = nullptr;

	EnumWindows(EnumWindowsCallback, (LPARAM)&EnumWindowsParam);
	return EnumWindowsParam.hWnd;
}

LPVOID GetPresentFnPtr(_In_ HWND hGameWnd) {
	DXGI_SWAP_CHAIN_DESC sd;
	ZeroMemory(&sd, sizeof(sd));
	sd.BufferCount = 2;
	sd.BufferDesc.Width = 0;
	sd.BufferDesc.Height = 0;
	sd.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
	sd.BufferDesc.RefreshRate.Numerator = 60;
	sd.BufferDesc.RefreshRate.Denominator = 1;
	sd.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;
	sd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
	sd.OutputWindow = hGameWnd;
	sd.SampleDesc.Count = 1;
	sd.SampleDesc.Quality = 0;
	sd.Windowed = TRUE;
	sd.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;

	IDXGISwapChain* pSwapChain;
	ID3D11Device* pDevice;
	ID3D11DeviceContext* pDeviceContext;

	const D3D_FEATURE_LEVEL szFeatureLevels[2] = { D3D_FEATURE_LEVEL_11_0, D3D_FEATURE_LEVEL_10_0, };
	if (SUCCEEDED(D3D11CreateDeviceAndSwapChain(
		nullptr,
		D3D_DRIVER_TYPE_HARDWARE,
		nullptr,
		0,
		szFeatureLevels,
		2,
		D3D11_SDK_VERSION,
		&sd,
		&pSwapChain,
		&pDevice,
		nullptr,
		&pDeviceContext
	))) {
		void** ppVTable = *(void***)pSwapChain;
		pSwapChain->Release();
		pDevice->Release();
		pDeviceContext->Release();

		return ppVTable[8];
	}
	else return nullptr;
}

void ImGui_SetStyle() {
	ImGuiStyle& Style = ImGui::GetStyle();

	Style.WindowPadding = ImVec2(8.00f, 8.00f);
	Style.FramePadding = ImVec2(5.00f, 2.00f);
	Style.ItemSpacing = ImVec2(6.00f, 6.00f);
	Style.ItemInnerSpacing = ImVec2(6.00f, 6.00f);
	Style.TouchExtraPadding = ImVec2(0.00f, 0.00f);
	Style.IndentSpacing = 25;
	Style.ScrollbarSize = 15;
	Style.GrabMinSize = 10;
	Style.WindowBorderSize = 1;
	Style.ChildBorderSize = 1;
	Style.PopupBorderSize = 1;
	Style.FrameBorderSize = 1;
	Style.TabBorderSize = 1;
	Style.WindowRounding = 7;
	Style.ChildRounding = 4;
	Style.FrameRounding = 3;
	Style.PopupRounding = 4;
	Style.ScrollbarRounding = 9;
	Style.GrabRounding = 3;
	Style.TabRounding = 4;
	
	ImVec4(&Colors)[48] = Style.Colors;

	Colors[ImGuiCol_Text] = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);
	Colors[ImGuiCol_TextDisabled] = ImVec4(0.50f, 0.50f, 0.50f, 1.00f);
	Colors[ImGuiCol_WindowBg] = ImVec4(0.10f, 0.10f, 0.10f, 1.00f);
	Colors[ImGuiCol_ChildBg] = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
	Colors[ImGuiCol_PopupBg] = ImVec4(0.19f, 0.19f, 0.19f, 0.92f);
	Colors[ImGuiCol_Border] = ImVec4(0.19f, 0.19f, 0.19f, 0.29f);
	Colors[ImGuiCol_BorderShadow] = ImVec4(0.00f, 0.00f, 0.00f, 0.24f);
	Colors[ImGuiCol_FrameBg] = ImVec4(0.05f, 0.05f, 0.05f, 0.54f);
	Colors[ImGuiCol_FrameBgHovered] = ImVec4(0.19f, 0.19f, 0.19f, 0.54f);
	Colors[ImGuiCol_FrameBgActive] = ImVec4(0.20f, 0.22f, 0.23f, 1.00f);
	Colors[ImGuiCol_TitleBg] = ImVec4(0.00f, 0.00f, 0.00f, 1.00f);
	Colors[ImGuiCol_TitleBgActive] = ImVec4(0.06f, 0.06f, 0.06f, 1.00f);
	Colors[ImGuiCol_TitleBgCollapsed] = ImVec4(0.00f, 0.00f, 0.00f, 1.00f);
	Colors[ImGuiCol_MenuBarBg] = ImVec4(0.14f, 0.14f, 0.14f, 1.00f);
	Colors[ImGuiCol_ScrollbarBg] = ImVec4(0.05f, 0.05f, 0.05f, 0.54f);
	Colors[ImGuiCol_ScrollbarGrab] = ImVec4(0.34f, 0.34f, 0.34f, 0.54f);
	Colors[ImGuiCol_ScrollbarGrabHovered] = ImVec4(0.40f, 0.40f, 0.40f, 0.54f);
	Colors[ImGuiCol_ScrollbarGrabActive] = ImVec4(0.56f, 0.56f, 0.56f, 0.54f);
	Colors[ImGuiCol_CheckMark] = ImVec4(0.33f, 0.67f, 0.86f, 1.00f);
	Colors[ImGuiCol_SliderGrab] = ImVec4(0.34f, 0.34f, 0.34f, 0.54f);
	Colors[ImGuiCol_SliderGrabActive] = ImVec4(0.56f, 0.56f, 0.56f, 0.54f);
	Colors[ImGuiCol_Button] = ImVec4(0.05f, 0.05f, 0.05f, 0.54f);
	Colors[ImGuiCol_ButtonHovered] = ImVec4(0.19f, 0.19f, 0.19f, 0.54f);
	Colors[ImGuiCol_ButtonActive] = ImVec4(0.20f, 0.22f, 0.23f, 1.00f);
	Colors[ImGuiCol_Header] = ImVec4(0.00f, 0.00f, 0.00f, 0.52f);
	Colors[ImGuiCol_HeaderHovered] = ImVec4(0.00f, 0.00f, 0.00f, 0.36f);
	Colors[ImGuiCol_HeaderActive] = ImVec4(0.20f, 0.22f, 0.23f, 0.33f);
	Colors[ImGuiCol_Separator] = ImVec4(0.28f, 0.28f, 0.28f, 0.29f);
	Colors[ImGuiCol_SeparatorHovered] = ImVec4(0.44f, 0.44f, 0.44f, 0.29f);
	Colors[ImGuiCol_SeparatorActive] = ImVec4(0.40f, 0.44f, 0.47f, 1.00f);
	Colors[ImGuiCol_ResizeGrip] = ImVec4(0.28f, 0.28f, 0.28f, 0.29f);
	Colors[ImGuiCol_ResizeGripHovered] = ImVec4(0.44f, 0.44f, 0.44f, 0.29f);
	Colors[ImGuiCol_ResizeGripActive] = ImVec4(0.40f, 0.44f, 0.47f, 1.00f);
	Colors[ImGuiCol_Tab] = ImVec4(0.00f, 0.00f, 0.00f, 0.52f);
	Colors[ImGuiCol_TabHovered] = ImVec4(0.14f, 0.14f, 0.14f, 1.00f);
	Colors[ImGuiCol_TabActive] = ImVec4(0.20f, 0.20f, 0.20f, 0.36f);
	Colors[ImGuiCol_TabUnfocused] = ImVec4(0.00f, 0.00f, 0.00f, 0.52f);
	Colors[ImGuiCol_TabUnfocusedActive] = ImVec4(0.14f, 0.14f, 0.14f, 1.00f);
	Colors[ImGuiCol_PlotLines] = ImVec4(1.00f, 0.00f, 0.00f, 1.00f);
	Colors[ImGuiCol_PlotLinesHovered] = ImVec4(1.00f, 0.00f, 0.00f, 1.00f);
	Colors[ImGuiCol_PlotHistogram] = ImVec4(1.00f, 0.00f, 0.00f, 1.00f);
	Colors[ImGuiCol_PlotHistogramHovered] = ImVec4(1.00f, 0.00f, 0.00f, 1.00f);
	Colors[ImGuiCol_TextSelectedBg] = ImVec4(0.20f, 0.22f, 0.23f, 1.00f);
	Colors[ImGuiCol_DragDropTarget] = ImVec4(0.33f, 0.67f, 0.86f, 1.00f);
	Colors[ImGuiCol_NavHighlight] = ImVec4(1.00f, 0.00f, 0.00f, 1.00f);
	Colors[ImGuiCol_NavWindowingHighlight] = ImVec4(1.00f, 0.00f, 0.00f, 0.70f);
	Colors[ImGuiCol_NavWindowingDimBg] = ImVec4(1.00f, 0.00f, 0.00f, 0.20f);
	Colors[ImGuiCol_ModalWindowDimBg] = ImVec4(1.00f, 0.00f, 0.00f, 0.35f);
}

typedef HRESULT(APIENTRY* tPresent)(IDXGISwapChain*, UINT, UINT);
tPresent oPresent;
WNDPROC oWndProc;

LRESULT CALLBACK WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
	if (ImGui_ImplWin32_WndProcHandler(hWnd, uMsg, wParam, lParam)) return TRUE;
	return CallWindowProcW(oWndProc, hWnd, uMsg, wParam, lParam);
}

ID3D11DeviceContext* pDeviceContext = nullptr;
ID3D11RenderTargetView* pRenderTargetView = nullptr;

HWND hWnd;

bool bInitialized = false;

HRESULT APIENTRY hkPresent(IDXGISwapChain* pSwapChain, UINT SyncInterval, UINT Flags) {
	if (!bInitialized) {
		ID3D11Device* pDevice = nullptr;

		if (SUCCEEDED(pSwapChain->GetDevice(__uuidof(ID3D11Device), (void**)&pDevice))) {
			pDevice->GetImmediateContext(&pDeviceContext);

			DXGI_SWAP_CHAIN_DESC sd;
			pSwapChain->GetDesc(&sd);
			hWnd = sd.OutputWindow;

			ID3D11Texture2D* pBackBuffer;
			pSwapChain->GetBuffer(0, __uuidof(ID3D11Texture2D), (LPVOID*)&pBackBuffer);
			if (!pBackBuffer) return oPresent(pSwapChain, SyncInterval, Flags);
			pDevice->CreateRenderTargetView(pBackBuffer, NULL, &pRenderTargetView);
			pBackBuffer->Release();

			oWndProc = (WNDPROC)SetWindowLongPtrW(hWnd, GWLP_WNDPROC, (LONG_PTR)WndProc);

			ImGui::CreateContext();
			ImGuiIO& io = ImGui::GetIO();
			io.ConfigFlags = ImGuiConfigFlags_NoMouseCursorChange;
			io.WantCaptureMouse = true;
			io.WantCaptureKeyboard = true;

			ImGui_SetStyle();

			ImGui_ImplWin32_Init(hWnd);
			ImGui_ImplDX11_Init(pDevice, pDeviceContext);

			bInitialized = true;
		}
		else return oPresent(pSwapChain, SyncInterval, Flags);
	}

	ImGui_ImplDX11_NewFrame();
	ImGui_ImplWin32_NewFrame();
	ImGui::NewFrame();

	Artemis::Engine::Events::OnNewFrameEventArgs e;
	Artemis::Engine::Events::OnNewFrameEvent.Invoke(nullptr, &e);

	Artemis::DrawManagers.PresentAll(ImGui::GetForegroundDrawList(), ImGui::GetBackgroundDrawList());
	Artemis::EventEntries.Invoke();
	Artemis::Windows.PresentAll();

	ImGui::ShowStyleEditor();
	ImGui::ShowDemoWindow();

	ImGui::EndFrame();
	ImGui::Render();
	pDeviceContext->OMSetRenderTargets(1, &pRenderTargetView, nullptr);
	ImGui_ImplDX11_RenderDrawData(ImGui::GetDrawData());

	return oPresent(pSwapChain, SyncInterval, Flags);
}

PresentHook::PresentHook() {
	HWND hWnd = GetGameWindow();
	pTarget = GetPresentFnPtr(hWnd);

	MH_STATUS status = MH_CreateHook(pTarget, hkPresent, (void**)&oPresent);
	if (status != MH_OK) Artemis::Log.LogError(__FUNCTION__, "Failed to create present hook: %s", MH_StatusToString(status));
	else Artemis::Log.LogSuccess(__FUNCTION__, "Successfully created present hook.");
}

PresentHook::~PresentHook() {
	SetWindowLongPtrW(hWnd, GWLP_WNDPROC, (LONG_PTR)oWndProc);

	MH_STATUS status = MH_RemoveHook(pTarget);
	if (status != MH_OK) Artemis::Log.LogError(__FUNCTION__, "Failed to remove present hook: %s", MH_StatusToString(status));
	else Artemis::Log.LogSuccess(__FUNCTION__, "Successfully removed present hook.");
}

PresentHook* PresentHook::Create() { return new PresentHook(); }

void PresentHook::Enable() {
	MH_STATUS status = MH_EnableHook(pTarget);
	if (status != MH_OK) Artemis::Log.LogError(__FUNCTION__, "Failed to enable present hook: %s", MH_StatusToString(status));
	else Artemis::Log.LogSuccess(__FUNCTION__, "Successfully enabled present hook.");
}

void PresentHook::Disable() {
	MH_STATUS status = MH_DisableHook(pTarget);
	if (status != MH_OK) Artemis::Log.LogError(__FUNCTION__, "Failed to disable present hook: %s", MH_StatusToString(status));
	else Artemis::Log.LogSuccess(__FUNCTION__, "Successfully disabled present hook.");
}

void PresentHook::Release() { delete this; }
```

`Artemis/PresentHook.h`:

```h
#pragma once

#include "pch.h"
#include "Definitions.h"

class PresentHook {
	LPVOID pTarget;

	PresentHook();
	~PresentHook();

public:
	static PresentHook* Create();
	void Enable();
	void Disable();
	void Release();
};
```

`Artemis/WindowManager.cpp`:

```cpp
#include "pch.h"
#include "WindowManager.h"

namespace Artemis {
	bool g_bVisible = true;

	IWindow::IWindow(_In_z_ const char* lpWindowName, bool bVisible) {
		strcpy_s(szWindowName, lpWindowName);
		this->bVisible = bVisible;
	}

	const char* IWindow::GetWindowName() const { return szWindowName; }

	bool IWindow::GetWindowVisibility() const { return bVisible; }
	bool* IWindow::GetWindowVisibilityPtr() { return &bVisible; }

	void IWindow::SetWindowVisibility(bool bVisible) { this->bVisible = bVisible; }

	void IWindow::Present() {
		if (g_bVisible && bVisible) {
			if (ImGui::Begin(szWindowName))
				Window();
			ImGui::End();
		}
	}

	void WindowManager::PresentAll() {
		for (IWindow* pWindow : InvocableCollection)
			if (pWindow)
				pWindow->Present();
	}
}
```

`Artemis/WindowManager.h`:

```h
#ifndef __ARTEMIS_WINDOW_MANAGER_H__
#define __ARTEMIS_WINDOW_MANAGER_H__

#include <Aurora/Definitions.h>

#include "Definitions.h"
#include "Manager.h"

namespace Artemis {
	class ARTEMIS_API IWindow {
		bool bVisible;
		char szWindowName[MAX_NAME];

	public:
		IWindow(_In_z_ const char* lpWindowName, bool bVisible);

		const char* GetWindowName() const;

		bool GetWindowVisibility() const;
		bool* GetWindowVisibilityPtr();

		void SetWindowVisibility(bool bVisible);

		virtual void Window() = 0;

		void Present();
	};

	using WindowIndex = int;

#ifdef _ARTEMIS_EXPORT
	extern template class Manager<IWindow, WindowIndex>;
#else
	template class ARTEMIS_IMPORT Manager<IWindow, WindowIndex>;
#endif // _ARTEMIS_EXPORT

	class ARTEMIS_API WindowManager : public Manager<IWindow, WindowIndex> {
	public:
		static bool GetGlobalWindowVisibility();
		static void SetGlobalWindowVisibility(bool bVisibility);

		void PresentAll();
	};
}

#endif // !__ARTEMIS_WINDOW_MANAGER_H__
```

`Artemis/Windows.cpp`:

```cpp
#include "pch.h"
#include "Windows.h"

#include "External.h"
#include "GameManager.h"

MainWindow::MainWindow() : IWindow("Main Window", true) {}

void MainWindow::Window() {
	ImGui::Text("Artemis RT test 1.0");
}
```

`Artemis/Windows.h`:

```h
#pragma once

#include "WindowManager.h"

class MainWindow : public Artemis::IWindow {
public:
	MainWindow();

	virtual void Window() final;
};
```

`Artemis/dllmain.cpp`:

```cpp
#include "pch.h"

#include "External.h"
#include "ExtensionManager.h"

#include "PresentHook.h"
#include "EventEntries.h"
#include "Keybinds.h"
#include "Windows.h"

#include "Events.h"

using namespace Artemis;

const char* const lpszAsciiArt[13] = {
		"<------------------------------------------------------------------------------------------------------>",
		"|                 .........     .......................   ....              ....   ....       ...      |",
		"|       ,d'      .xKKKKKKK0ko, .oKKKKKKKKKKxoOKKKKKK0Kx. .oKKO:           .l0KKc  .xKKo.   ,ok0K0Od:.  |",
		"|      .OWx.     .oOOOOOOOXWMNo.:xxxxxxxxxxloXMWXOOOkOo. .kMMMX:          lNMMMo  '0MMx. .dNMN0O0NMWk. |",
		"|     .dWMNl              .xWMX;            :NMWl        .kMMMMX:        cNMMMMo  '0MMx. cWMNl. .;kK0: |",
		"|     cNMMMX:            .'kWMX;    '::,.   :NMWo....... .kMMMMMK;      :XMMMMMo  '0MMx. cNMNo..   ..  |",
		"|    ;KMX0NM0'   .oOOOOOO0XWMXl.   .dMM0'   :NMMX0000000OoOMMXKWMK;    :XMWXNMMo  '0MMx. .dNMWX0Oxo,   |",
		"|   .OMWo.xWWk.  .OMMNKXWMMXd'      dMM0'   :NMMX0OOO000koOMMk;xWMK;  ;KMWdcKMMo  '0MMx.   'lxkOKWMNx. |",
		"|  .xWMO. '0MWo. 'OMMk'.dWMNc       dMM0'   :NMWo.       .kMMO..xWMK;;KMWx.,KMMo  '0MMx.        .lXMWo |",
		"|  lNMX;   cXMNc 'OMMx. .dWMXc      dMM0'   :NMWo        .kMMk. .xWMXXMWx. .coo,  '0MMx.        .cXMWo |",
		"| :XMWo    .dWMK,'OMMx.  .xWMX:     dMM0'   :NMMXOOOOOd. .kMMO.  .xWMMWx.       'dONMMXkl.     ,ONMWk' |",
		"| dKKd.     .xKKo,dKKo.   .xKKx'    lKKx.   ,OKKKKKKKKx. .oKKd.   .cooc.        ,OKKKKKKx.     ;0Od:.  |",
		"<------------------------------------------------------------------------------------------------------>"
};

static bool bRunning = true;
static PresentHook* pHook = nullptr;

ARTEMIS_API void Artemis::Exit() { bRunning = false; }

void LogBasicInformation(const char* lpSender, const Aurora::ProcessInfo& CurrentProcess) {
	Log.LogInfo(lpSender, "Welcome to Artemis!");
	Log.LogInfo(lpSender, "Current process:");
	Log.LogInfo(lpSender, "\t%s : %s", CurrentProcess.GetProcessName(), CurrentProcess.GetProcessPath());
	Log.LogInfo(lpSender, "Process Id: 0x%lX", CurrentProcess.GetProcessId());
	Log.LogInfo(lpSender, "Process Handle: 0x%p\n", CurrentProcess.GetProcessHandle());

	const Aurora::ModuleInfo& Module = CurrentProcess.GetModule();

	Log.LogInfo(lpSender, "Module handle: 0x%p", Module.GetModuleHandle());
	Log.LogInfo(lpSender, "Module base address: 0x%llX", Module.GetModuleBaseAddress());
	Log.LogInfo(lpSender, "Module size: 0x%lX", Module.GetModuleSize());
}

DWORD APIENTRY Main(HMODULE hModule) {
#ifdef _DEBUG
	Aurora::CreateConsole();
	Aurora::OpenStream(Aurora::StandardStream::Out);
#endif // _DEBUG

	for (const char* lpString : lpszAsciiArt)
		printf("%s\n", lpString);

	LogBasicInformation(__FUNCTION__, Aurora::GetCurrentProcessInfo());

	if (Keybinds.Add(new ExitKeybind()) == INVALID_INDEX) {
		Log.LogError(__FUNCTION__, "Exit keybind could not be added.");
		bRunning = false;
	}
	else
		Log.LogSuccess(__FUNCTION__, "Successfully registered the exit keybind.");

	if (Windows.Add(new MainWindow()) == INVALID_INDEX)
		Log.LogError(__FUNCTION__, "Main window could not be added.");
	else
		Log.LogSuccess(__FUNCTION__, "Successfully registered the main window.");

	if (EventEntries.Add(new EnterMainMenuEventEntry()) == INVALID_INDEX)
		Log.LogError(__FUNCTION__, "Enter main menu event entry could not be added.");
	else
		Log.LogSuccess(__FUNCTION__, "Successfully registered the enter main menu event.");

	if (EventEntries.Add(new EnterCustomGameLobbyEventEntry()) == INVALID_INDEX)
		Log.LogError(__FUNCTION__, "Enter custom game lobby event entry could not be added.");
	else
		Log.LogSuccess(__FUNCTION__, "Successfully registered the enter custom game event.");

	if (EventEntries.Add(new EnterPickPhaseEventEntry()) == INVALID_INDEX)
		Log.LogError(__FUNCTION__, "Enter pick phase event entry could not be added.");
	else
		Log.LogSuccess(__FUNCTION__, "Successfully registered the enter pick phase event.");

	if (EventEntries.Add(new EnterGameEventEntry()) == INVALID_INDEX)
		Log.LogError(__FUNCTION__, "Enter game event entry could not be added.");
	else
		Log.LogSuccess(__FUNCTION__, "Successfully registered the enter game event.");

	MH_STATUS status = MH_Initialize();
	if (status != MH_OK) {
		Log.LogError(__FUNCTION__, "Failed to initialize minhook: %s", MH_StatusToString(status));
		bRunning = false;
	}
	else {
		Log.LogSuccess(__FUNCTION__, "Successfully initialized MinHook.");
		pHook = PresentHook::Create();
		pHook->Enable();
	}

	while (bRunning)
		Keybinds.Invoke();

	if (pHook)
		pHook->Release();
	MH_Uninitialize();

#ifdef _DEBUG
	Aurora::CloseStream(Aurora::StandardStream::Out);
	Aurora::ReleaseConsole();
#endif // _DEBUG

	FreeLibraryAndExitThread(hModule, 0);
	return 0;
}

BOOL APIENTRY DllMain(HMODULE hModule, DWORD dwReasonForCall, LPVOID lpReserved) {
	HANDLE hThread = nullptr;
	
	switch (dwReasonForCall) {
	case DLL_PROCESS_ATTACH:
		hThread = CreateThread(
			nullptr,
			0,
			(LPTHREAD_START_ROUTINE)Main,
			hModule,
			0,
			nullptr
		);

		if (!hThread) return FALSE;
		else break;

	case DLL_PROCESS_DETACH:
		break;
	}
	return TRUE;
}
```

`Artemis/pch.cpp`:

```cpp
// pch.cpp: source file corresponding to the pre-compiled header

#include "pch.h"

// When you are using pre-compiled headers, this source file is necessary for compilation to succeed.

```

`Artemis/pch.h`:

```h
// pch.h: This is a precompiled header file.
// Files listed below are compiled only once, improving build performance for future builds.
// This also affects IntelliSense performance, including code completion and many code browsing features.
// However, files listed here are ALL re-compiled if any one of them is updated between builds.
// Do not add files here that you will be updating frequently as this negates the performance advantage.

#ifndef PCH_H
#define PCH_H

// Windows Header Files
#include <Windows.h>
#include <TlHelp32.h>
#include <Psapi.h>

#include <d3d11.h>
#include <dxgi.h>

// Aurora Headers
#include <Aurora/Array.h>
#include <Aurora/Binary.h>
#include <Aurora/CodeInjection.h>
#include <Aurora/Color.h>
#include <Aurora/Console.h>
#include <Aurora/ConstexprMath.h>
#include <Aurora/Definitions.h>
#include <Aurora/DllInjection.h>
#include <Aurora/Events.h>
#include <Aurora/Exceptions.h>
#include <Aurora/FileSystem.h>
#include <Aurora/Logger.h>
#include <Aurora/Memory.h>
#include <Aurora/MemoryTypes.h>
#include <Aurora/MemoryWin32.h>
#include <Aurora/Pipe.h>
#include <Aurora/ProcessInfo.h>
#include <Aurora/Property.h>
#include <Aurora/Shapes.h>
#include <Aurora/SharedHandle.h>
#include <Aurora/Signal.h>
#include <Aurora/Thread.h>
#include <Aurora/Time.h>
#include <Aurora/Trampoline.h>
#include <Aurora/Vector.h>

// ImGui header files.
#include <ImGui/imconfig.h>
#include <ImGui/imgui.h>
#include <ImGui/imgui_impl_dx11.h>
#include <ImGui/imgui_impl_win32.h>
#include <ImGui/imstb_rectpack.h>
#include <ImGui/imstb_textedit.h>
#include <ImGui/imstb_truetype.h>

// MinHook header file.
#include <MinHook/MinHook.h>

#endif //PCH_H

```

`LICENSE.md`:

```md
MIT License

Copyright (c) 2022-2023 Artemis Group

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
![Artemis](https://github.com/ArtemisDevGroup/Artemis-Resources/blob/main/Text/ArtemisWithLogo.png)
# Artemis
Artemis is the main project worked on by this organization. It is a tool for Rainbow Six: Siege - Shadow Legacy intended to bring a bunch of different modifications to the game.  
It is also intended to bring support for user made extensions, providing an intuitive and easy to use framework to work with.

```