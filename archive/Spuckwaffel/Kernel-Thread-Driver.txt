Project Path: arc_Spuckwaffel_Kernel-Thread-Driver_h5v62ov_

Source Tree:

```txt
arc_Spuckwaffel_Kernel-Thread-Driver_h5v62ov_
├── Driver
│   ├── defines.h
│   ├── events.h
│   ├── funcs.h
│   ├── main.cpp
│   ├── sheesh.vcxproj
│   ├── sheesh.vcxproj.filters
│   ├── sheesh.vcxproj.user
│   ├── skCrypter.h
│   ├── stdint.h
│   └── utilities.h
├── README.md
└── UM
    ├── Driver.h
    ├── UM.cpp
    ├── UM.vcxproj
    ├── UM.vcxproj.filters
    ├── UM.vcxproj.user
    └── stdafx.h

```

`Driver/defines.h`:

```h
#pragma once
#include <ntifs.h>
#include <ntddk.h>
#include <IntSafe.h>
#include <ntimage.h>

ULONG64 CODE_ADDRESS;
ULONG64 OUTPUT_ADDRESS;


PCWSTR SREGP = {};
PCWSTR SCODE = {};
PCWSTR SADDY = {};


#define print(fmt, ...) DbgPrintEx(0, 0, fmt, ##__VA_ARGS__)

#include "skCrypter.h"

#include "stdint.h"

#include "funcs.h"
#include "utilities.h"
#include "events.h"



```

`Driver/events.h`:

```h
#pragma once


bool Connect() {

	process::base_address = (ULONG64)PsGetProcessSectionBaseAddress(process::process);
	//print("\n[+] base address:    0x%llX", process::base_address);

	process::STRUCT_OFFSET_ADDRESS = ULONG64(process::base_address + OUTPUT_ADDRESS);
	//print("\n[+] struct address:  0x%llX -> offset: 0x%llX", process::STRUCT_OFFSET_ADDRESS, (ULONG64)(process::STRUCT_OFFSET_ADDRESS - process::base_address)); //address where the struct address get stored

	process::STATUS_CODE_ADDRESS = ULONG64(process::base_address + CODE_ADDRESS);
	process::STATUS_CODE_ADDRESS_REAL = readlocal<ULONG64>(process::STATUS_CODE_ADDRESS); //get the real address
	//print("\n[+] code address:    0x%llX -> offset: 0x%llX => 0x%llX", process::STATUS_CODE_ADDRESS, (ULONG64)(process::STATUS_CODE_ADDRESS - process::base_address), process::STATUS_CODE_ADDRESS_REAL); //this just saves the address to the status 
	

	int CURRCODE = readlocal<int>(process::STATUS_CODE_ADDRESS_REAL); // read it
	//print("\n[+] code: %d", CURRCODE);
	
	if (CURRCODE != 3) {
		return false;
	}
	//print("\n[+] connected!");
	status::ONLINE();

	return true;
}

void Disconnect() {
	//print("\n[+] stopping thread and closing...");
	

	PVOID Kthread = reinterpret_cast<PVOID>(KeGetCurrentThread());
	PVOID InitialStack		= (PVOID)((ULONG64)Kthread + GInitialStack);
	PVOID VCreateTime		= (PVOID)((ULONG64)Kthread + GVCreateTime);
	PVOID StartAddress		= (PVOID)((ULONG64)Kthread + GStartAddress);
	PVOID Win32StartAddress	= (PVOID)((ULONG64)Kthread + GWin32StartAddress);
	PVOID KernelStack		= (PVOID)((ULONG64)Kthread + GKernelStack);
	PVOID ExitStatus		= (PVOID)((ULONG64)Kthread + GExitStatus);
	PVOID CID				= (PVOID)((ULONG64)Kthread + GCID);


	//print("\n[+] resetting vars....");
	*(PVOID*)(VCreateTime)			= _VCreateTime;
	*(PVOID*)(StartAddress)			= _StartAddress;
	*(PVOID*)(Win32StartAddress)	= _Win32StartAddress;
	*(PVOID*)(KernelStack)			= _KernelStack;
	*(PVOID*)(ExitStatus)			= _ExitStatus;
	*(PVOID*)(CID)					= _CID;

	//print("\n[+] Bye!");
	PsTerminateSystemThread(STATUS_SUCCESS);
}

void InitTarget() {
	process::target_pid = readlocal<ULONG64>(readlocal<ULONG64>(process::STRUCT_OFFSET_ADDRESS));//double reading because STRUCT_OFFSET_ADDRESS saves a pointer that has pid
	//print("\n[+] process::target_pid: %d", process::target_pid);
	if (process::target_pid != 0) {
		status::SUCESSFUL();
	}
	else {
		status::ERROR();
	}
}

void GetBase() {
	if (NT_SUCCESS(PsLookupProcessByProcessId((HANDLE)process::target_pid, &process::target_process))) {
		ULONG64 base = (ULONG64)PsGetProcessSectionBaseAddress(process::target_process);
		ULONG64 StructAddress = readlocal<ULONG64>(process::STRUCT_OFFSET_ADDRESS); //no double because direct writing
		writelocal<ULONG64>(&base, (PVOID)StructAddress);
		status::SUCESSFUL();
	}
	else {
		status::ERROR();
	}
}

void Read() {
	readd StructAddress = {};
	SIZE_T BytesRead{ 0 };
	(MmCopyVirtualMemory(process::process, (PVOID)readlocal<ULONG64>(process::STRUCT_OFFSET_ADDRESS), PsGetCurrentProcess(), &StructAddress, sizeof(readd), KernelMode, &BytesRead));

	//StructAddress = readlocal<readd>(readlocal<ULONG64>(process::STRUCT_OFFSET_ADDRESS)); //double reading because STRUCT_OFFSET_ADDRESS points to the struct and then we read the content
	if (StructAddress.address < 0x7FFFFFFFFFFF && StructAddress.address > 0 && StructAddress.size > 0 && StructAddress.size < 200) {
		read(StructAddress.address, StructAddress.output, StructAddress.size);
	}
	
	status::SUCESSFUL(); //we cant check if its unsuccessful
}
```

`Driver/funcs.h`:

```h
#pragma once

//up because theyre all the same (19000 - ...)


#define InitialStack_1909		0x28
#define KernelStack_1909		0x58
#define VCreateTime_1909		0x600
#define StartAddress_1909		0x620
#define CID_1909				0x648
#define Win32StartAddress_1909	0x6a0
#define ExitStatus_1909			0x710



#define InitialStack_UP			0x28
#define KernelStack_UP			0x58
#define VCreateTime_UP			0x430
#define StartAddress_UP			0x450
#define CID_UP					0x478
#define Win32StartAddress_UP	0x4d0
#define ExitStatus_UP			0x548

#define ImageFileName_1909		0x450
#define ActiveThreads_1909		0x498
#define ActiveProcessLinks_1909	0x2F0

#define ImageFileName_UP		0x5a8
#define ActiveThreads_UP		0x5f0
#define ActiveProcessLinks_UP	0x448

namespace process
{
	ULONG pid;
	ULONG target_pid;
	PEPROCESS process;
	PEPROCESS target_process;
	ULONG64 base_address;
	ULONG64 STATUS_CODE_ADDRESS;
	ULONG64 STRUCT_OFFSET_ADDRESS;
	ULONG64 STATUS_CODE_ADDRESS_REAL;
}

ULONG GInitialStack;
ULONG GVCreateTime;
ULONG GStartAddress;
ULONG GWin32StartAddress;
ULONG GKernelStack;
ULONG GImageFileName;
ULONG GActiveThreads;
ULONG GActiveProcessLinks;
ULONG GExitStatus;
ULONG GCID;

PVOID _VCreateTime;
PVOID _StartAddress;
PVOID _Win32StartAddress;
PVOID _KernelStack;
PVOID _ExitStatus;
PVOID _CID;

typedef struct readd {
	ULONG64 address;
	ULONGLONG size;
	ULONG64 output;
};

typedef enum _SYSTEM_INFORMATION_CLASS
{
	SystemBasicInformation,
	SystemProcessorInformation,
	SystemPerformanceInformation,
	SystemTimeOfDayInformation,
	SystemPathInformation,
	SystemProcessInformation,
	SystemCallCountInformation,
	SystemDeviceInformation,
	SystemProcessorPerformanceInformation,
	SystemFlagsInformation,
	SystemCallTimeInformation,
	SystemModuleInformation = 0x0B
} SYSTEM_INFORMATION_CLASS, * PSYSTEM_INFORMATION_CLASS;

typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
	HANDLE Section;
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR  FullPathName[256];
} RTL_PROCESS_MODULE_INFORMATION, * PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES
{
	ULONG NumberOfModules;
	RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, * PRTL_PROCESS_MODULES;

extern "C"
{
	NTKERNELAPI
		PVOID
		PsGetProcessSectionBaseAddress(
			PEPROCESS Process
		);

	NTKERNELAPI
		PPEB
		NTAPI
		PsGetProcessPeb(
			PEPROCESS Process
		);

	NTSTATUS NTAPI MmCopyVirtualMemory(
		PEPROCESS SourceProcess,
		PVOID SourceAddress,
		PEPROCESS TargetProcess,
		PVOID TargetAddress,
		SIZE_T BufferSize,
		KPROCESSOR_MODE PreviousMode,
		PSIZE_T ReturnSize
	);

	NTSYSCALLAPI
		NTSTATUS
		NTAPI
		ZwQuerySystemInformation(
			ULONG InfoClass,
			PVOID Buffer,
			ULONG Length,
			PULONG ReturnLength
		);

	NTSYSCALLAPI
		NTSTATUS
		ZwQueryInformationProcess(
			HANDLE ProcessHandle,
			PROCESSINFOCLASS ProcessInformationClass,
			PVOID ProcessInformation,
			ULONG ProcessInformationLength,
			PULONG ReturnLength
		);

	NTSYSCALLAPI
		NTSTATUS
		NTAPI
		ZwProtectVirtualMemory(
			HANDLE ProcessHandle,
			PVOID* BaseAddress,
			PSIZE_T RegionSize,
			ULONG NewAccessProtection,
			PULONG OldAccessProtection
		);

	NTKERNELAPI
		PVOID
		NTAPI
		RtlFindExportedRoutineByName(
			_In_ PVOID ImageBase,
			_In_ PCCH RoutineName
		);
}
```

`Driver/main.cpp`:

```cpp
#include "defines.h"




void Check() {
	while (!NT_SUCCESS(PsLookupProcessByProcessId((HANDLE)process::pid, &process::process))) {
		ObDereferenceObject(process::process);
		sleep(995);
	}
	//process::pid = reinterpret_cast<ULONG>(PsGetProcessId(process::process));
	print("\n[+] found process! Pid: %i", process::pid);

}

template< typename T >
void SpoofAddress(PVOID address, PVOID* save, PVOID target = 0) {
	*save = *(PVOID*)(address); //save current stuff
	//print("\n[+] saved orig data");
	*(PVOID*)(address) = target; //overwrite
	T spoof = *(T*)((ULONG64)address);
	//print("\n[+] spoofed! -> 0x%llX (%d)", spoof, spoof);
}

void HideThread() {

	//this is not needed lol, i just use this to get a random address ill set the start address to
	PVOID ntoskrnlbase = (PVOID)((ULONG64)get_system_module_base(skCrypt("\\SystemRoot\\system32\\ntoskrnl.exe")) + 0x23810a);
	//PVOID ntoskrnlbase = (PVOID)((ULONG64)get_system_module_base("\\SystemRoot\\system32\\ntoskrnl.exe"));
	//print("\n[+] Base: 0x%llX", ntoskrnlbase);
	PVOID Kthread = reinterpret_cast<PVOID>(KeGetCurrentThread());
	//print("\n[+] Kthread: 0x%llX", Kthread);

	PVOID InitialStack		= (PVOID)((ULONG64)Kthread + GInitialStack);
	PVOID VCreateTime		= (PVOID)((ULONG64)Kthread + GVCreateTime);
	PVOID StartAddress		= (PVOID)((ULONG64)Kthread + GStartAddress);
	PVOID Win32StartAddress = (PVOID)((ULONG64)Kthread + GWin32StartAddress);
	PVOID KernelStack		= (PVOID)((ULONG64)Kthread + GKernelStack);
	PVOID CID				= (PVOID)((ULONG64)Kthread + GCID);
	PVOID ExitStatus		= (PVOID)((ULONG64)Kthread + GExitStatus);
	
	//print("\n[+] CreateTime: 0x%llX", VCreateTime);
	SpoofAddress<LARGE_INTEGER>(VCreateTime, &_VCreateTime, (PVOID)2147483247);

	//print("\n[+] StartAddress: 0x%llX", StartAddress);
	SpoofAddress<void*>(StartAddress, &_StartAddress, ntoskrnlbase);

	//print("\n[+] Win32StartAddress: 0x%llX", Win32StartAddress);
	SpoofAddress<void*>(Win32StartAddress, &_Win32StartAddress, ntoskrnlbase);

	//print("\n[+] KernelStack: 0x%llX", KernelStack);
	SpoofAddress<LARGE_INTEGER>(KernelStack, &_KernelStack);

	SpoofAddress<CLIENT_ID>(CID, &_CID);


	SpoofAddress<LONG>(ExitStatus, &_ExitStatus);

}

int errors = 0;
int CheckCode() {

	return readlocal<int>(process::STATUS_CODE_ADDRESS_REAL);
}
OSVERSIONINFOW GetOSVersion() {
	OSVERSIONINFOW OSInfo{ 0 };
	RtlGetVersion(&OSInfo);
	return OSInfo;
}

void mainthread()
{
	//KeSetBasePriorityThread(KeGetCurrentThread(), 31);

	auto OsInfo = GetOSVersion();

	if (OsInfo.dwBuildNumber > 19000) { //above 1909
		GInitialStack		= InitialStack_UP;
		GVCreateTime		= VCreateTime_UP;
		GStartAddress		= StartAddress_UP;
		GWin32StartAddress	= Win32StartAddress_UP;
		GImageFileName		= ImageFileName_UP;
		GActiveThreads		= ActiveThreads_UP;
		GActiveProcessLinks = ActiveProcessLinks_UP;
		GKernelStack		= KernelStack_UP;
		GExitStatus			= ExitStatus_UP;
		GCID				= CID_UP;
	}
	else {
		GInitialStack		= InitialStack_1909;
		GVCreateTime		= VCreateTime_1909;
		GStartAddress		= StartAddress_1909;
		GWin32StartAddress	= Win32StartAddress_1909;
		GImageFileName		= ImageFileName_1909;
		GActiveThreads		= ActiveThreads_1909;
		GActiveProcessLinks = ActiveProcessLinks_1909;
		GKernelStack		= KernelStack_1909;
		GExitStatus			= ExitStatus_1909;
		GCID				= CID_1909;
	}

	HideThread();
	//print("\n[+] waiting for program");

	sleep(1000);
	Check();
	sleep(3000);
	if (Connect()) {
		while (true) {
			int code = CheckCode();
			switch (code) {
			case 3:
				Disconnect();
				break;
			case 4: 
				Read();
				break;
			case 5:
				GetBase();
				break;
			case 6:
				InitTarget();
				break;
			default:
				break;
			}
		}
	}
	else {
		//print("\n[+] Failed to connect! Disconnecting....");
		Disconnect();
	}


}


NTSTATUS EntryPoint(ULONG64 mdl, ULONG64 code, ULONG64 output, ULONG64 PID)
{
	OUTPUT_ADDRESS = output;
	CODE_ADDRESS = code;

	MDL* mdlptr = reinterpret_cast<MDL*>(mdl);
	if (!null_pfn(mdlptr)) {
		return STATUS_UNSUCCESSFUL;
	}
	HANDLE thread_handle = nullptr;
	print("[+] PID: %d", PID);
	print("[+] code: %d", code);
	print("[+] output: %d", output);
	process::pid = PID;

	OBJECT_ATTRIBUTES object_attribues{ };
	InitializeObjectAttributes(&object_attribues, nullptr, OBJ_KERNEL_HANDLE, nullptr, nullptr);

	NTSTATUS status = PsCreateSystemThread(&thread_handle, 0, &object_attribues, nullptr, nullptr, reinterpret_cast<PKSTART_ROUTINE>(&mainthread), nullptr);
	//ZwClose(thread_handle);
	//print("\n[+] Bye bye DriverEntry!");
	return STATUS_UNSUCCESSFUL;
}

//NTSTATUS DriverEntry(PDRIVER_OBJECT driver_object, PUNICODE_STRING registry_path) {
//
//	UNREFERENCED_PARAMETER(driver_object);
//	UNREFERENCED_PARAMETER(registry_path);
//
//	//print("\n[+] Started driver!");
//
//	HANDLE thread_handle = nullptr;
//	OBJECT_ATTRIBUTES object_attribues{ };
//	InitializeObjectAttributes(&object_attribues, nullptr, OBJ_KERNEL_HANDLE, nullptr, nullptr);
//
//	NTSTATUS status = PsCreateSystemThread(&thread_handle, 0, &object_attribues, nullptr, nullptr, reinterpret_cast<PKSTART_ROUTINE>(&mainthread), nullptr);
//	//print("\n[+] Bye bye DriverEntry!");
//	return STATUS_SUCCESS;
//
//}
```

`Driver/sheesh.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{AB373DEE-9A1C-47EC-96A9-BBEC340CD264}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>sheesh</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>Spectre</Driver_SpectreMitigation>
    <ALLOW_DATE_TIME>1</ALLOW_DATE_TIME>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings" />
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
    </ClCompile>
    <Link>
      <EntryPointSymbol>EntryPoint</EntryPointSymbol>
      <TreatLinkerWarningAsErrors>false</TreatLinkerWarningAsErrors>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="defines.h" />
    <ClInclude Include="events.h" />
    <ClInclude Include="funcs.h" />
    <ClInclude Include="skCrypter.h" />
    <ClInclude Include="stdint.h" />
    <ClInclude Include="utilities.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets" />
</Project>
```

`Driver/sheesh.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="defines.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="funcs.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="utilities.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="stdint.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="events.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="skCrypter.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`Driver/sheesh.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <SignMode>Off</SignMode>
  </PropertyGroup>
</Project>
```

`Driver/skCrypter.h`:

```h
#pragma once

/*____________________________________________________________________________________________________________
Original Author: skadro
Github: https://github.com/skadro-official
License: See end of file
skCrypter
		Compile-time, Usermode + Kernelmode, safe and lightweight string crypter library for C++11+
							*Not removing this part is appreciated*
____________________________________________________________________________________________________________*/

#ifdef _KERNEL_MODE
namespace std
{
	// STRUCT TEMPLATE remove_reference
	template <class _Ty>
	struct remove_reference {
		using type = _Ty;
	};

	template <class _Ty>
	struct remove_reference<_Ty&> {
		using type = _Ty;
	};

	template <class _Ty>
	struct remove_reference<_Ty&&> {
		using type = _Ty;
	};

	template <class _Ty>
	using remove_reference_t = typename remove_reference<_Ty>::type;

	// STRUCT TEMPLATE remove_const
	template <class _Ty>
	struct remove_const { // remove top-level const qualifier
		using type = _Ty;
	};

	template <class _Ty>
	struct remove_const<const _Ty> {
		using type = _Ty;
	};

	template <class _Ty>
	using remove_const_t = typename remove_const<_Ty>::type;
}
#else
#include <type_traits>
#endif

namespace skc
{
	template<class _Ty>
	using clean_type = typename std::remove_const_t<std::remove_reference_t<_Ty>>;

	template <int _size, char _key1, char _key2, typename T>
	class skCrypter
	{
	public:
		__forceinline constexpr skCrypter(T* data)
		{
			crypt(data);
		}

		__forceinline T* get()
		{
			return _storage;
		}

		__forceinline int size() // (w)char count
		{
			return _size;
		}

		__forceinline  char key()
		{
			return _key1;
		}

		__forceinline  T* encrypt()
		{
			if (!isEncrypted())
				crypt(_storage);

			return _storage;
		}

		__forceinline  T* decrypt()
		{
			if (isEncrypted())
				crypt(_storage);

			return _storage;
		}

		__forceinline bool isEncrypted()
		{
			return _storage[_size - 1] != 0;
		}

		__forceinline void clear() // set full storage to 0
		{
			for (int i = 0; i < _size; i++)
			{
				_storage[i] = 0;
			}
		}

		__forceinline operator T* ()
		{
			decrypt();

			return _storage;
		}

	private:
		__forceinline constexpr void crypt(T* data)
		{
			for (int i = 0; i < _size; i++)
			{
				_storage[i] = data[i] ^ (_key1 + i % (1 + _key2));
			}
		}

		T _storage[_size]{};
	};
}

#define skCrypt(str) skCrypt_key(str, __TIME__[4], __TIME__[7])
#define skCrypt_key(str, key1, key2) []() { \
			constexpr static auto crypted = skc::skCrypter \
				<sizeof(str) / sizeof(str[0]), key1, key2, skc::clean_type<decltype(str[0])>>((skc::clean_type<decltype(str[0])>*)str); \
					return crypted; }()

/*________________________________________________________________________________
MIT License
Copyright (c) 2020 skadro
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
________________________________________________________________________________*/
```

`Driver/stdint.h`:

```h
/*
 * Copyright (c) 2008 Travis Geiselbrecht
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
#ifndef __STDINT_H
#define __STDINT_H
#include <limits.h> // for ULONG_MAX
typedef unsigned char      uint8_t;
typedef unsigned short     uint16_t;
typedef unsigned int       uint32_t;
typedef unsigned long long uint64_t;
typedef signed char int8_t;
typedef short     int16_t;
typedef int       int32_t;
typedef long long int64_t;
typedef int8_t int_least8_t;
typedef int16_t int_least16_t;
typedef int32_t int_least32_t;
typedef int64_t int_least64_t;
typedef uint8_t uint_least8_t;
typedef uint16_t uint_least16_t;
typedef uint32_t uint_least32_t;
typedef uint64_t uint_least64_t;
typedef int8_t int_fast8_t;
typedef int32_t int_fast32_t;
typedef int64_t int_fast64_t;
typedef uint8_t uint_fast8_t;
typedef uint32_t uint_fast32_t;
typedef uint64_t uint_fast64_t;
typedef long long intmax_t;
typedef unsigned long long uintmax_t;
#define SIZE_MAX ULONG_MAX
#endif
```

`Driver/utilities.h`:

```h
#pragma once


void sleep(int ms) { 
	
	LARGE_INTEGER time;  
	time.QuadPart = -(ms) * 10 * 1000; //10000 = 1ms 1000= 100ys 100 = 10ys 10= 1ys 
	KeDelayExecutionThread(KernelMode, TRUE, &time); 
}



NTSTATUS process_by_name(CHAR* process_name, PEPROCESS* process)
{
    PEPROCESS sys_process = PsInitialSystemProcess;
    PEPROCESS cur_entry = sys_process;
    CHAR image_name[15];

    do
    {
        RtlCopyMemory((PVOID)(&image_name), (PVOID)((uintptr_t)cur_entry + GImageFileName) /*EPROCESS->ImageFileName*/, sizeof(image_name));

        if (strstr(image_name, process_name))
        {
            ULONG active_threads;
            RtlCopyMemory((PVOID)&active_threads, (PVOID)((uintptr_t)cur_entry + GActiveThreads) /*EPROCESS->ActiveThreads*/, sizeof(active_threads));
            if (active_threads)
            {
                *process = cur_entry;
                return STATUS_SUCCESS;
            }
        }

        PLIST_ENTRY list = (PLIST_ENTRY)((uintptr_t)(cur_entry) + GActiveProcessLinks) /*EPROCESS->ActiveProcessLinks*/;
        cur_entry = (PEPROCESS)((uintptr_t)list->Flink - GActiveProcessLinks);

    } while (cur_entry != sys_process);

    return STATUS_NOT_FOUND;
}

PVOID get_system_module_base(const char* module_name)
{
    ULONG bytes = 0;
    NTSTATUS status = ZwQuerySystemInformation(SystemModuleInformation, NULL, bytes, &bytes);

    if (!bytes)
        return NULL;

    PRTL_PROCESS_MODULES modules = (PRTL_PROCESS_MODULES)ExAllocatePoolWithTag(NonPagedPool, bytes, 0x4e554c4c);

    status = ZwQuerySystemInformation(SystemModuleInformation, modules, bytes, &bytes);

    if (!NT_SUCCESS(status))
        return NULL;

    PRTL_PROCESS_MODULE_INFORMATION module = modules->Modules;
    PVOID module_base = 0, module_size = 0;

    for (ULONG i = 0; i < modules->NumberOfModules; i++) {
        if (strcmp((char*)module[i].FullPathName, module_name) == NULL) {
            module_base = module[i].ImageBase;
            module_size = (PVOID)module[i].ImageSize;
            break;
        }
    }

    if (0 == 0) {
        PEPROCESS process1;
    }

    if (modules)
        ExFreePoolWithTag(modules, NULL);

    if (module_base <= NULL)
        return NULL;

    return module_base;
}

PVOID get_system_module_export(const char* module_name, LPCSTR routine_name)
{
    PVOID lpModule = get_system_module_base(module_name);

    if (!lpModule)
        return NULL;

    return RtlFindExportedRoutineByName(lpModule, routine_name);
}

NTSTATUS  write_virtual_memory(ULONG pid, PEPROCESS process, PVOID source_address, PVOID target_address, SIZE_T size)
{
    SIZE_T bytes = 0;
    //print("writing to target: 0x%llX", target_address);
    if (NT_SUCCESS(MmCopyVirtualMemory(PsGetCurrentProcess(), source_address, process, target_address, size, KernelMode, &bytes)))
        return STATUS_SUCCESS;

    return STATUS_UNSUCCESSFUL;
}

NTSTATUS read_virtual_memory(ULONG pid, PEPROCESS process, PVOID source_address, PVOID target_address, SIZE_T size)
{
    SIZE_T bytes = 0;
    
    if (NT_SUCCESS(MmCopyVirtualMemory(process, source_address, PsGetCurrentProcess(), target_address, size, KernelMode, &bytes)))
        return STATUS_SUCCESS;

     return STATUS_SUCCESS;
}

template< typename T >
T readlocal(uintptr_t address)
{
    T buffer{};
    read_virtual_memory(process::pid, process::process, (void*)address, &buffer, sizeof(T));
    return buffer;
}

void read(uintptr_t from, uintptr_t to, ULONGLONG size)
{
    SIZE_T bytes = 0;
    if (size || to || from) MmCopyVirtualMemory(process::target_process, (PVOID)from, process::process, (PVOID)to, size, KernelMode, &bytes);
       
}

template< typename T >
void writelocal(PVOID from, PVOID to)
{
    write_virtual_memory(process::pid, process::process, from, to, sizeof(T));
}



namespace status {
    void SUCESSFUL() {
        int i = 1;
        write_virtual_memory(process::pid, process::process, &i, (PVOID)process::STATUS_CODE_ADDRESS_REAL, sizeof(i));
    }
    void ONLINE() { //idle
        int i = 0;
        write_virtual_memory(process::pid, process::process, &i, (PVOID)process::STATUS_CODE_ADDRESS_REAL, sizeof(i));
    }
    void ERROR() {
        int i = 2;
        write_virtual_memory(process::pid, process::process, &i, (PVOID)process::STATUS_CODE_ADDRESS_REAL, sizeof(i));
    }
}

bool null_pfn(PMDL mdl)
{
    PPFN_NUMBER mdl_pages = MmGetMdlPfnArray(mdl);
    if (!mdl_pages) { return false; }

    ULONG mdl_page_count = ADDRESS_AND_SIZE_TO_SPAN_PAGES(MmGetMdlVirtualAddress(mdl), MmGetMdlByteCount(mdl));
    //print("[+] mdl_page_count: %d", mdl_page_count);
    ULONG null_pfn = 0x0;
    MM_COPY_ADDRESS source_address = { 0 };
    source_address.VirtualAddress = &null_pfn;

    for (ULONG i = 0; i < mdl_page_count; i++)
    {
        size_t bytes = 0;
        MmCopyMemory(&mdl_pages[i], source_address, sizeof(ULONG), MM_COPY_MEMORY_VIRTUAL, &bytes);
    }
    return true;
}

```

`README.md`:

```md
# Kernel-Thread-Driver
This is a simple project of a driver + usermode.

Check out the UC post: https://www.unknowncheats.me/forum/general-programming-and-reversing/487919-kernel-thread-driver.html#post3358074

I decided to release my driver I used for quite a while (for BE and EAC games), especially for Fortnite, and it worked pretty well for me (I didn't share the driver).
I know kernel thread drivers are quite popular, but I wanted to contribute this to this awesome community, it wouldn't be possible without hundreds of older threads here that gave me the needed information.

Special Thanks to these people, I used some of their code/information in my project:
@zach898
@nbq
@Frostiest
@Swiftik
@ShoaShekelberg

The reason this driver is different from other kernel thread drivers, that it's not a full kernel cheat, it communicates with the usermode program too.

The driverentry takes 4 params:
NTSTATUS EntryPoint(ULONG64 mdl, ULONG64 code, ULONG64 output, ULONG64 PID)

mdl is the mdl pointer, because im not allocating a pool for my driver.
code saves the address what the current status code is. (0 = connected, 1 = success, 2 = error, 3 = disconnected, 4 = reading, 5 = getting base, 6 = init target process)
and output saves the address for the UM struct.

Basically it works like this:

I start the UM program.
Give the mapper the mdl pointer, code status address, the struct and usermode pid.
My kernel driver gets started and nulls the fps, creates a system thread and sets the status code to 0 (connected).
While this happens my UM programs stays in a loop until the status code is 0 and then it knows the kernel driver is running.
After that i send the target pid to my driver (set the code to 6, my kernel driver is in a permanent loop and always reads the status code and if it's 6, it saves the target pid.)
Then I can use basic stuff like reading memory and getting the base address.
For disconnecting the usermode, I send the code 3 to my driver, so it knows it should exit the system thread and won't read any more memory from our UM process.

Sidenote:
This kernel driver changes
InitialStack
VCreateTime
StartAddress
Win32StartAddress
KernelStack
CID
ExitStatus
from its current thread.

It supports 1909-21H1.

Obviously this isn't perfect, but it is good for beginners to learn from it.
This project shows that this forum is also great for information what the anticheats detect and how to bypass those checks.

The code might be messy, but oh well.

```

`UM/Driver.h`:

```h
#pragma once
#include "stdafx.h"

void* STATUS_CODE_ADDRESS;
void* STRUCT_OFFSET_ADDRESS;

/*
0 = connected
1 = success
2 = error
3 = disconnected
4 = reading
5 = getting base
6 = init target
*/
int STATUS_CODE = 3;

//out struct we use
typedef struct readd {
	ULONG64 address;
	ULONGLONG size;
	ULONG64 output;
};


bool Await_Approval() {
	while (STATUS_CODE == 4 || STATUS_CODE == 5 || STATUS_CODE == 6) {
		Sleep(0);
	}
	if (STATUS_CODE == 1) { //success
		return true;
	}
	if (STATUS_CODE == 2) { //error
		return false;
	}
}

void Disconnect() {
	std::cout << "disconnecting..." << std::endl;

	STATUS_CODE = 3;
	Sleep(300);

	std::cout << "disconnected!" << std::endl;
}

template<class T>
T Read(uint64_t read_address) {
	readd Data;
	T response = {  };
	Data.output = (ULONG64)&response;

	Data.address = read_address;

	Data.size = sizeof(response);

	STRUCT_OFFSET_ADDRESS = &Data;
	STATUS_CODE = 4;
	if (Await_Approval()) {
		return response;
	}
	return response;
}


void Connect() {
	int i = 3355;
	STATUS_CODE_ADDRESS = &STATUS_CODE;
	STRUCT_OFFSET_ADDRESS = &i;

	//just some info
	std::cout << "base address:        0x" << std::hex << GetModuleHandle(NULL) << std::endl;
	std::cout << "code address:        0x" << std::hex << &STATUS_CODE_ADDRESS << " -> offset: 0x" << (ULONG64)((ULONG64)&STATUS_CODE_ADDRESS - (ULONG64)GetModuleHandle(NULL)) << " => " << STATUS_CODE_ADDRESS << std::endl;
	std::cout << "test output address: 0x" << std::hex << &STRUCT_OFFSET_ADDRESS << " -> offset: 0x" << (ULONG64)((ULONG64)&STRUCT_OFFSET_ADDRESS - (ULONG64)GetModuleHandle(NULL)) << " => " << STRUCT_OFFSET_ADDRESS << std::endl;

	while (STATUS_CODE != 0) {
		Sleep(500);
		std::cout << "code: " << STATUS_CODE << std::endl;
		std::cout << "waiting for communication!" << std::endl;

	}
	std::cout << "connected!\n";
}

bool initTarget(DWORD pid) {

	DWORD procid = pid;
	STRUCT_OFFSET_ADDRESS = &procid;
	STATUS_CODE = 6; //work! //but init
	if (Await_Approval()) {
		return true;
	}
	return false;
}

ULONG64 GetBase() {
	ULONG64 base = 0;
	STRUCT_OFFSET_ADDRESS = &base;
	STATUS_CODE = 5; //work! //but base
	if (Await_Approval()) {
		return base;
	}
}


static HWND get_process_wnd(uint32_t pid) {
	std::pair<HWND, uint32_t> params = { 0, pid };

	BOOL bResult = EnumWindows([](HWND hwnd, LPARAM lParam) -> BOOL {
		auto pParams = (std::pair<HWND, uint32_t>*)(lParam);
		uint32_t processId = 0;

		if (GetWindowThreadProcessId(hwnd, reinterpret_cast<LPDWORD>(&processId)) && processId == pParams->second) {
			SetLastError((uint32_t)-1);
			pParams->first = hwnd;
			return FALSE;
		}

		return TRUE;

		}, (LPARAM)&params);

	if (!bResult && GetLastError() == -1 && params.first)
		return params.first;

	return NULL;
}

DWORD GetProcessId(const wchar_t* ImageName) {
	HANDLE Snapshot{ CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0) };
	PROCESSENTRY32W Process{ sizeof(PROCESSENTRY32W) };

	if (Process32FirstW(Snapshot, &Process)) {
		do {
			if (!wcscmp(ImageName, Process.szExeFile)) {
				CloseHandle(Snapshot);
				return Process.th32ProcessID;
			}
		} while (Process32NextW(Snapshot, &Process));
	}

	CloseHandle(Snapshot);
	return NULL;
}

```

`UM/UM.cpp`:

```cpp
#include "stdafx.h"

DWORD pid;
DWORD64 baseaddress;

int main()
{
	//use your mapper code here:

	//send your driver following stuff: (use kdmapper or something else)

	//					  mdl pointer, STATUS_CODE_ADDRESS, STRUCT_OFFSET_ADDRESS,  pid
	//NTSTATUS EntryPoint(ULONG64 mdl, ULONG64 code,		ULONG64 output,			ULONG64 PID)


	std::cout << "Hello world!" << std::endl;
	Connect();

	pid = GetProcessId(L"FortniteClient-Win64-Shipping.exe");

	std::cout << "PID:" << pid << std::endl;
	//init our target
	if (!initTarget(pid)) return 1;

	baseaddress = GetBase();

	std::cout << "base: 0x" << std::hex << baseaddress << std::endl;

	//a test
	uint64_t UWORLD = Read<uint64_t>(0xB78BC70 + baseaddress);

	std::cout << "test: 0x" << std::hex << UWORLD << std::endl;

	Disconnect();

}
```

`UM/UM.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{6c3807a5-cbbf-4434-8c19-ed4c6e70d08a}</ProjectGuid>
    <RootNamespace>UM</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="UM.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Driver.h" />
    <ClInclude Include="stdafx.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`UM/UM.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Quelldateien">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Headerdateien">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Ressourcendateien">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="UM.cpp">
      <Filter>Quelldateien</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Driver.h">
      <Filter>Headerdateien</Filter>
    </ClInclude>
    <ClInclude Include="stdafx.h">
      <Filter>Headerdateien</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`UM/UM.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`UM/stdafx.h`:

```h
#include <iostream>
#include <Windows.h>
#include <winternl.h>
#include <TlHelp32.h>

#include "Driver.h"

```