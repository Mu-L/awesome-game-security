Project Path: arc_Spuckwaffel_Simple-MmcopyMemory-Hook_qn16mgcg

Source Tree:

```txt
arc_Spuckwaffel_Simple-MmcopyMemory-Hook_qn16mgcg
├── HookDriver
│   ├── HookDriver.vcxproj
│   ├── HookDriver.vcxproj.filters
│   ├── HookDriver.vcxproj.user
│   ├── defines.h
│   ├── funcs.cpp
│   ├── funcs.h
│   ├── kernel.h
│   ├── main.cpp
│   ├── note
│   └── skCrypter.h
├── HookDriver.sln
└── README.md

```

`HookDriver.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.32126.315
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "HookDriver", "HookDriver\HookDriver.vcxproj", "{A03AB601-208A-48EE-9DEE-A3308DFA6885}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{A03AB601-208A-48EE-9DEE-A3308DFA6885}.Debug|ARM.ActiveCfg = Debug|ARM
		{A03AB601-208A-48EE-9DEE-A3308DFA6885}.Debug|ARM.Build.0 = Debug|ARM
		{A03AB601-208A-48EE-9DEE-A3308DFA6885}.Debug|ARM.Deploy.0 = Debug|ARM
		{A03AB601-208A-48EE-9DEE-A3308DFA6885}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{A03AB601-208A-48EE-9DEE-A3308DFA6885}.Debug|ARM64.Build.0 = Debug|ARM64
		{A03AB601-208A-48EE-9DEE-A3308DFA6885}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{A03AB601-208A-48EE-9DEE-A3308DFA6885}.Debug|x64.ActiveCfg = Debug|x64
		{A03AB601-208A-48EE-9DEE-A3308DFA6885}.Debug|x64.Build.0 = Debug|x64
		{A03AB601-208A-48EE-9DEE-A3308DFA6885}.Debug|x64.Deploy.0 = Debug|x64
		{A03AB601-208A-48EE-9DEE-A3308DFA6885}.Debug|x86.ActiveCfg = Debug|Win32
		{A03AB601-208A-48EE-9DEE-A3308DFA6885}.Debug|x86.Build.0 = Debug|Win32
		{A03AB601-208A-48EE-9DEE-A3308DFA6885}.Debug|x86.Deploy.0 = Debug|Win32
		{A03AB601-208A-48EE-9DEE-A3308DFA6885}.Release|ARM.ActiveCfg = Release|ARM
		{A03AB601-208A-48EE-9DEE-A3308DFA6885}.Release|ARM.Build.0 = Release|ARM
		{A03AB601-208A-48EE-9DEE-A3308DFA6885}.Release|ARM.Deploy.0 = Release|ARM
		{A03AB601-208A-48EE-9DEE-A3308DFA6885}.Release|ARM64.ActiveCfg = Release|ARM64
		{A03AB601-208A-48EE-9DEE-A3308DFA6885}.Release|ARM64.Build.0 = Release|ARM64
		{A03AB601-208A-48EE-9DEE-A3308DFA6885}.Release|ARM64.Deploy.0 = Release|ARM64
		{A03AB601-208A-48EE-9DEE-A3308DFA6885}.Release|x64.ActiveCfg = Release|x64
		{A03AB601-208A-48EE-9DEE-A3308DFA6885}.Release|x64.Build.0 = Release|x64
		{A03AB601-208A-48EE-9DEE-A3308DFA6885}.Release|x64.Deploy.0 = Release|x64
		{A03AB601-208A-48EE-9DEE-A3308DFA6885}.Release|x86.ActiveCfg = Release|Win32
		{A03AB601-208A-48EE-9DEE-A3308DFA6885}.Release|x86.Build.0 = Release|Win32
		{A03AB601-208A-48EE-9DEE-A3308DFA6885}.Release|x86.Deploy.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {FEBD0CC4-07D5-4A00-B477-89CE64E6B768}
	EndGlobalSection
EndGlobal

```

`HookDriver/HookDriver.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{A03AB601-208A-48EE-9DEE-A3308DFA6885}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>HookDriver</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <ALLOW_DATE_TIME>1</ALLOW_DATE_TIME>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <ApiValidator_Enable>false</ApiValidator_Enable>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
      <MergeSections>.text=.EAC;</MergeSections>
    </Link>
    <ClCompile>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
    </ClCompile>
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="funcs.cpp" />
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="defines.h" />
    <ClInclude Include="funcs.h" />
    <ClInclude Include="skCrypter.h" />
    <ClInclude Include="kernel.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`HookDriver/HookDriver.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
    <Filter Include="Hooking">
      <UniqueIdentifier>{e5a67b56-a7cc-491d-98c9-638efc4bdf9e}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="funcs.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="defines.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="funcs.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="skCrypter.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="kernel.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`HookDriver/HookDriver.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <SignMode>Off</SignMode>
  </PropertyGroup>
</Project>
```

`HookDriver/defines.h`:

```h
#pragma once
#include <ntifs.h>
#include <ntddk.h>
#include <IntSafe.h>
#include <ntimage.h>

#define print(fmt, ...) DbgPrintEx(0, 0, fmt, ##__VA_ARGS__)

#include "skCrypter.h"
#include "funcs.h"
```

`HookDriver/funcs.cpp`:

```cpp
#include <ntifs.h>
#include <IntSafe.h>
#include <ntimage.h>
#include "funcs.h"
#include "kernel.h"
namespace funcs {

	CHAR* LowerStr(CHAR* Str) {
		for (CHAR* S = Str; *S; ++S) {
			*S = (CHAR)tolower(*S);
		}
		return Str;
	}


	template <typename T = PVOID>
	T AllocatePool(SIZE_T Size) {
		return reinterpret_cast<T>(ExAllocatePool(NonPagedPool, Size));
	}

	VOID FreePool(PVOID Buffer) {
		ExFreePool(Buffer);
	}

	//get ImageBase of a loaded module
	char* GetModuleInfo(const char* Name) {
		PVOID Base = nullptr;
		DWORD RequiredSize = 0;

		//get add loaded modules

		if (ZwQuerySystemInformation(SystemModuleInformation,
			nullptr,
			NULL,
			&RequiredSize) != STATUS_INFO_LENGTH_MISMATCH) {

			return 0;
		}

		auto Modules = AllocatePool<SYSTEM_MODULE_INFORMATION*>(RequiredSize);

		//in case allocating a pool fails
		if (!Modules) {
			return 0;
		}

		if (!NT_SUCCESS(ZwQuerySystemInformation(SystemModuleInformation,
			Modules,
			RequiredSize,
			nullptr))) {
			FreePool(Modules);
			return 0;
		}

		//now loop through all loaded modules

		for (DWORD i = 0; i < Modules->NumberOfModules; ++i) {
			SYSTEM_MODULE CurModule{ Modules->Modules[i] };

			//check if module name matches the module were looking for (lower string just to make sure)
			if (strstr(LowerStr((CHAR*)CurModule.FullPathName), LowerStr((CHAR*)Name)))
			{
				//get ImageBase
				Base = CurModule.ImageBase;

				//break the loop, we have our module
				break;
			}
		}

		//free the pool
		FreePool(Modules);
		return reinterpret_cast<char*>(Base);
	}


	//check mask for wildcards
	BOOLEAN CheckMask(CHAR* Base, CHAR* Pattern, CHAR* Mask) {
		for (; *Mask; ++Base, ++Pattern, ++Mask) {
			if (*Mask == 'x' && *Base != *Pattern) {
				return FALSE;
			}
		}

		return TRUE;
	}

	//find a pattern in a given region and size
	PVOID FindPattern(CHAR* Base, DWORD Length, CHAR* Pattern, CHAR* Mask) {
		Length -= (DWORD)strlen(Mask);

		for (DWORD i = 0; i <= Length; ++i) {
			PVOID Addr{ &Base[i] };

			if (CheckMask(static_cast<PCHAR>(Addr), Pattern, Mask)) {
				return Addr;
			}
		}

		return 0;
	}

	//basic pattern search function
	PVOID FindPatternImage(CHAR* Base, CHAR* Pattern, CHAR* Mask)
	{
		PVOID Match{ 0 };

		IMAGE_NT_HEADERS* Headers{ (PIMAGE_NT_HEADERS)(Base + ((PIMAGE_DOS_HEADER)Base)->e_lfanew) };
		IMAGE_SECTION_HEADER* Sections{ IMAGE_FIRST_SECTION(Headers) };

		for (DWORD i = 0; i < Headers->FileHeader.NumberOfSections; ++i) {
			IMAGE_SECTION_HEADER* Section{ &Sections[i] };

			if (*(INT*)Section->Name == 'EGAP' || memcmp(Section->Name, ".text", 5) == 0) {
				Match = FindPattern(Base + Section->VirtualAddress, Section->Misc.VirtualSize, Pattern, Mask);

				if (Match) {
					break;
				}
			}
		}

		return Match;
	}

	//basic write to readonly memory function
	bool write_to_read_only_memory(void* address, void* buffer, size_t size) {
		PMDL Mdl = IoAllocateMdl(address, size, FALSE, FALSE, NULL);
		if (!Mdl)
			return false;

		MmProbeAndLockPages(Mdl, KernelMode, IoReadAccess);
		PVOID Mapping = MmMapLockedPagesSpecifyCache(Mdl, KernelMode, MmNonCached, NULL, FALSE, NormalPagePriority);
		MmProtectMdlSystemAddress(Mdl, PAGE_READWRITE);

		memcpy(Mapping, buffer, size);
		MmUnmapLockedPages(Mapping, Mdl);
		MmUnlockPages(Mdl);
		IoFreeMdl(Mdl);

		return true;
	}

	//basic Hook
	bool HookFunction(PVOID function, PVOID outfunction)
	{
		//place a r11 jmp hook that returns STATUS_UNSUCCESSFUL
		unsigned char shell_code[] = {
				0x49, 0xBB, //mov r11
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //ptr
				0x41, 0xff, 0xe3,  //jmp r11
				0xb8,  0x01,  0x00,  0x00, 0xc0, //mov eax, STATUS_UNSUCCESSFUL
				0xc3 // ret
		};

		uintptr_t hook_address = reinterpret_cast<uintptr_t>(outfunction);

		//place the hook address in the shellcode
		memcpy(shell_code + 2, &hook_address, sizeof(hook_address));

		return write_to_read_only_memory(function, &shell_code, sizeof(shell_code));
	}
}

```

`HookDriver/funcs.h`:

```h
#pragma once

//we dont have to put every function in here from funcs.cpp as they're not needed 
namespace funcs {
	char* GetModuleInfo(const char* Name);
	PVOID FindPatternImage(CHAR* Base, CHAR* Pattern, CHAR* Mask);
	bool HookFunction(PVOID function, PVOID outfunction);
}

```

`HookDriver/kernel.h`:

```h

//structs
typedef enum _SYSTEM_INFORMATION_CLASS
{
	SystemBasicInformation,
	SystemProcessorInformation,
	SystemPerformanceInformation,
	SystemTimeOfDayInformation,
	SystemPathInformation,
	SystemProcessInformation,
	SystemCallCountInformation,
	SystemDeviceInformation,
	SystemProcessorPerformanceInformation,
	SystemFlagsInformation,
	SystemCallTimeInformation,
	SystemModuleInformation,
	SystemLocksInformation,
	SystemStackTraceInformation,
	SystemPagedPoolInformation,
	SystemNonPagedPoolInformation,
	SystemHandleInformation,
	SystemObjectInformation,
	SystemPageFileInformation,
	SystemVdmInstemulInformation,
	SystemVdmBopInformation,
	SystemFileCacheInformation,
	SystemPoolTagInformation,
	SystemInterruptInformation,
	SystemDpcBehaviorInformation,
	SystemFullMemoryInformation,
	SystemLoadGdiDriverInformation,
	SystemUnloadGdiDriverInformation,
	SystemTimeAdjustmentInformation,
	SystemSummaryMemoryInformation,
	SystemNextEventIdInformation,
	SystemEventIdsInformation,
	SystemCrashDumpInformation,
	SystemExceptionInformation,
	SystemCrashDumpStateInformation,
	SystemKernelDebuggerInformation,
	SystemContextSwitchInformation,
	SystemRegistryQuotaInformation,
	SystemExtendServiceTableInformation,
	SystemPrioritySeperation,
	SystemPlugPlayBusInformation,
	SystemDockInformation,
	SystemProcessorSpeedInformation,
	SystemCurrentTimeZoneInformation,
	SystemLookasideInformation
} SYSTEM_INFORMATION_CLASS, * PSYSTEM_INFORMATION_CLASS;

typedef struct _SYSTEM_MODULE
{
	HANDLE Section;
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR  FullPathName[MAXIMUM_FILENAME_LENGTH];
} SYSTEM_MODULE, * PSYSTEM_MODULE;

typedef struct _SYSTEM_MODULE_INFORMATION
{
	ULONG NumberOfModules;
	SYSTEM_MODULE Modules[1];
} SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
	HANDLE Section;
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR  FullPathName[256];
} RTL_PROCESS_MODULE_INFORMATION, * PRTL_PROCESS_MODULE_INFORMATION;


typedef struct _RTL_PROCESS_MODULES
{
	ULONG NumberOfModules;
	RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, * PRTL_PROCESS_MODULES;


//functions
extern "C"
{
	

	NTKERNELAPI
		PPEB
		NTAPI
		PsGetProcessPeb(
			PEPROCESS Process
		);


	NTSYSCALLAPI
		NTSTATUS
		NTAPI
		ZwQuerySystemInformation(
			ULONG InfoClass,
			PVOID Buffer,
			ULONG Length,
			PULONG ReturnLength
		);

	NTSYSCALLAPI
		NTSTATUS
		ZwQueryInformationProcess(
			HANDLE ProcessHandle,
			PROCESSINFOCLASS ProcessInformationClass,
			PVOID ProcessInformation,
			ULONG ProcessInformationLength,
			PULONG ReturnLength
		);

	NTSYSCALLAPI
		NTSTATUS
		NTAPI
		ZwProtectVirtualMemory(
			HANDLE ProcessHandle,
			PVOID* BaseAddress,
			PSIZE_T RegionSize,
			ULONG NewAccessProtection,
			PULONG OldAccessProtection
		);

	NTKERNELAPI
		PVOID
		NTAPI
		RtlFindExportedRoutineByName(
			_In_ PVOID ImageBase,
			_In_ PCCH RoutineName
		);
}
```

`HookDriver/main.cpp`:

```cpp
#include "defines.h"


//print out MmCopyMemory args
NTSTATUS __fastcall MmCopyMemHook(PVOID Buffer, PVOID BaseAddress, SIZE_T NumberOfBytesToRead, int mode, PSIZE_T NumberOfBytesRead) {
	print(skCrypt("[HOOKER] MMcopymemory called!\n"));
	print(skCrypt("[HOOKER] Buffer: 0x%llX\n"), Buffer);
	print(skCrypt("[HOOKER] Address: 0x%llX\n"), BaseAddress);
	print(skCrypt("[HOOKER] Size: 0x%d\n"), NumberOfBytesToRead);

	switch (mode) {
	case MM_COPY_MEMORY_PHYSICAL:
		print(skCrypt("[HOOKER] Flag: MM_COPY_MEMORY_PHYSICAL\n"));
		break;

	case MM_COPY_MEMORY_VIRTUAL:
		print(skCrypt("[HOOKER] Flag: MM_COPY_MEMORY_VIRTUAL\n"));
		break;

	default:
		print(skCrypt("[HOOKER] Mode: 0x%d\n"), mode);
	}
	return STATUS_UNSUCCESSFUL;
}

auto Main() -> NTSTATUS {
	print("[HOOKER] Started driver!");

	//get the ImageBase
	CHAR* base = funcs::GetModuleInfo(skCrypt("ntoskrnl.exe"));

	if (!base) {
		print("[HOOKER] The requested module was not found!");
		return STATUS_UNSUCCESSFUL;
	}

	//long ass MmCopyMemory pattern (here is a pattern in case the function gets replaced with a different one)
	PVOID function = funcs::FindPatternImage(base, skCrypt("\x48\x89\x5C\x24\x00\x55\x56\x57\x41\x54\x41\x55\x41\x56\x41\x57\x48\x8D\x6C\x24\x00\x48\x81\xEC\x00\x00\x00\x00\x48\x8B\x05\x00\x00\x00\x00\x48\x33\xC4\x48\x89\x45\x20\x4C\x8B\xAD\x00\x00\x00\x00"),
		skCrypt("xxxx?xxxxxxxxxxxxxxx?xxx????xxx????xxxxxxxxxx????"));

	if (!function) {
		print("[HOOKER] The requested function was not found!");
		return STATUS_UNSUCCESSFUL;
	}

	print(skCrypt("[HOOKER] MmCopyMemory: 0x%llX\n"), function);

	if (!funcs::HookFunction(function, &MmCopyMemHook)) {
		print("[HOOKER] The hook could not be placed!");
		return STATUS_UNSUCCESSFUL;
	}

	print("[HOOKER] Hook place success!");
	return STATUS_SUCCESS;
}

//driver entry function
NTSTATUS DriverEntry(PDRIVER_OBJECT driver_object, PUNICODE_STRING registry_path) {

	UNREFERENCED_PARAMETER(driver_object);
	UNREFERENCED_PARAMETER(registry_path);
	return Main();
}
```

`HookDriver/skCrypter.h`:

```h
#pragma once

/*____________________________________________________________________________________________________________
Original Author: skadro
Github: https://github.com/skadro-official
License: See end of file
skCrypter
		Compile-time, Usermode + Kernelmode, safe and lightweight string crypter library for C++11+
							*Not removing this part is appreciated*
____________________________________________________________________________________________________________*/

#ifdef _KERNEL_MODE
namespace std
{
	// STRUCT TEMPLATE remove_reference
	template <class _Ty>
	struct remove_reference {
		using type = _Ty;
	};

	template <class _Ty>
	struct remove_reference<_Ty&> {
		using type = _Ty;
	};

	template <class _Ty>
	struct remove_reference<_Ty&&> {
		using type = _Ty;
	};

	template <class _Ty>
	using remove_reference_t = typename remove_reference<_Ty>::type;

	// STRUCT TEMPLATE remove_const
	template <class _Ty>
	struct remove_const { // remove top-level const qualifier
		using type = _Ty;
	};

	template <class _Ty>
	struct remove_const<const _Ty> {
		using type = _Ty;
	};

	template <class _Ty>
	using remove_const_t = typename remove_const<_Ty>::type;
}
#else
#include <type_traits>
#endif

namespace skc
{
	template<class _Ty>
	using clean_type = typename std::remove_const_t<std::remove_reference_t<_Ty>>;

	template <int _size, char _key1, char _key2, typename T>
	class skCrypter
	{
	public:
		__forceinline constexpr skCrypter(T* data)
		{
			crypt(data);
		}

		__forceinline T* get()
		{
			return _storage;
		}

		__forceinline int size() // (w)char count
		{
			return _size;
		}

		__forceinline  char key()
		{
			return _key1;
		}

		__forceinline  T* encrypt()
		{
			if (!isEncrypted())
				crypt(_storage);

			return _storage;
		}

		__forceinline  T* decrypt()
		{
			if (isEncrypted())
				crypt(_storage);

			return _storage;
		}

		__forceinline bool isEncrypted()
		{
			return _storage[_size - 1] != 0;
		}

		__forceinline void clear() // set full storage to 0
		{
			for (int i = 0; i < _size; i++)
			{
				_storage[i] = 0;
			}
		}

		__forceinline operator T* ()
		{
			decrypt();

			return _storage;
		}

	private:
		__forceinline constexpr void crypt(T* data)
		{
			for (int i = 0; i < _size; i++)
			{
				_storage[i] = data[i] ^ (_key1 + i % (1 + _key2));
			}
		}

		T _storage[_size]{};
	};
}

#define skCrypt(str) skCrypt_key(str, __TIME__[4], __TIME__[7])
#define skCrypt_key(str, key1, key2) []() { \
			constexpr static auto crypted = skc::skCrypter \
				<sizeof(str) / sizeof(str[0]), key1, key2, skc::clean_type<decltype(str[0])>>((skc::clean_type<decltype(str[0])>*)str); \
					return crypted; }()

/*________________________________________________________________________________
MIT License
Copyright (c) 2020 skadro
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
________________________________________________________________________________*/
```

`README.md`:

```md
# Simple-MmcopyMemory-Hook
A simple MmCopyMemory hook.

check out the UC post.
with this Release (dedicated to the kernel newbies) I will show you how basic hooks work.
Before any flaming happens, this will:


*blue screen you because of pg within a hour
*this will get you banned (it is detected)
*this is a basic mov rax hook


# Why did i release it then?
Drivers that place hooks in some syscall function are nothing new, but in this project I'm hooking a function such as MmCopyMemory that EAC uses to scan the kernel memory to find manually mapped driver.
The source code of the driver will hook this function and will print out the info and what EAC copies.
I've just seen many people saying "just hook MmCopyMemory to see what EAC is scanning" but for some people this might sound like a hard or impossible task.
In this community are still many people who don't know how a hook even works and this might help you out a lot.

With this well documented driver you can place a hook on any function.

# Let's take a look at MmCopyMemory:
MmCopyMemory is located in ntoskrnl.
```c++
NTSTATUS __fastcall MmCopyMemory(PVOID TargetAddress, unsigned __int64 sourceaddress, unsigned __int64 size, int virtorphys, _QWORD *numberofbytestransferred)

//or from microsoft docs
NTSTATUS MmCopyMemory(
  [in]  PVOID           TargetAddress,
  [in]  MM_COPY_ADDRESS SourceAddress,
  [in]  SIZE_T          NumberOfBytes,
  [in]  ULONG           Flags,
  [out] PSIZE_T         NumberOfBytesTransferred
);
```

TargetAddress
A pointer to a caller-supplied buffer. This buffer must be in nonpageable memory.

SourceAddress
An MM_COPY_ADDRESS structure, passed by value, that contains either the virtual address or the physical address of the data to be copied to the buffer pointed to by TargetAddress.

NumberOfBytes
The number of bytes to copy from SourceAddress to TargetAddress.

Flags
Flags that indicate whether SourceAddress is a virtual address or a physical address. The following flag bits are defined for this parameter.

Flag
MM_COPY_MEMORY_PHYSICAL	SourceAddress specifies a physical address.
MM_COPY_MEMORY_VIRTUAL	SourceAddress specifies a virtual address.
 
These two flag bits are mutually exclusive. The caller must set one or the other, but not both.

NumberOfBytesTransferred
A pointer to a location to which the routine writes the number of bytes successfully copied from the SourceAddress location to the buffer at TargetAddress.

Sounds pretty easy to hook. 5 args! Let's make a function in our driver:
```c++
NTSTATUS __fastcall MmCopyMemHook(PVOID Buffer, PVOID BaseAddress, SIZE_T NumberOfBytesToRead, int mode, PSIZE_T NumberOfBytesRead) {
	print(skCrypt("[HOOKER] MMcopymemory called!\n"));
	print(skCrypt("[HOOKER] Buffer: 0x%llX\n"), Buffer);
	print(skCrypt("[HOOKER] Address: 0x%llX\n"), BaseAddress);
	print(skCrypt("[HOOKER] Size: 0x%d\n"), NumberOfBytesToRead);

	switch (mode) {
	case MM_COPY_MEMORY_PHYSICAL:
		print(skCrypt("[HOOKER] Flag: MM_COPY_MEMORY_PHYSICAL\n"));
		break;

	case MM_COPY_MEMORY_VIRTUAL:
		print(skCrypt("[HOOKER] Flag: MM_COPY_MEMORY_VIRTUAL\n"));
		break;

	default:
		print(skCrypt("[HOOKER] Mode: 0x%d\n"), mode);
	}
	return STATUS_UNSUCCESSFUL;
}
```

Now in our driver we just have to locate the function (for example using a pattern) and hook it with a simple hook that will return at the end STATUS_UNSUCCESSFUL like following:
```c++
		//place a r11 jmp hook that returns STATUS_UNSUCCESSFUL
		unsigned char shell_code[] = {
				0x49, 0xBB, //mov r11
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //ptr
				0x41, 0xff, 0xe3,  //jmp r11
				0xb8,  0x01,  0x00,  0x00, 0xc0, //mov eax, STATUS_UNSUCCESSFUL
				0xc3 // ret
		};
```
Why? After our hook, we want to return asap because the rest of the MmCopyMemory function will be broken. I've used the r11 register instead of rax just to prove there's more than just rax (technically useless).

Patterns to the function can be easily created with the SigMaker plugin for IDA pro.

Now we just have to write the shellcode to the function and whenever MmCopyMemory will be called, we will see a message apprearing in DbgView (obviously enable kernel output).

That's about it! Just map the driver with kdmapper or any mappers.
The pattern in the driver is for 20H2.

```