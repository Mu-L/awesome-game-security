Project Path: arc_Unkn0wnH4ck3r_GameOverlayUIHook_xsga013d

Source Tree:

```txt
arc_Unkn0wnH4ck3r_GameOverlayUIHook_xsga013d
├── GameOverlayUIHook
│   ├── GameOverlayUIHook.vcxproj
│   ├── GameOverlayUIHook.vcxproj.filters
│   ├── GameOverlayUIHook.vcxproj.user
│   ├── SDK.h
│   ├── VMProtectSDK.h
│   ├── dllmain.cpp
│   └── obfuscation.h
├── GameOverlayUIHook.sln
└── README.md

```

`GameOverlayUIHook.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.28010.2048
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "GameOverlayUIHook", "GameOverlayUIHook\GameOverlayUIHook.vcxproj", "{5C809C14-F6A4-470F-A2EA-7BEC2B89D01D}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{5C809C14-F6A4-470F-A2EA-7BEC2B89D01D}.Debug|x64.ActiveCfg = Debug|x64
		{5C809C14-F6A4-470F-A2EA-7BEC2B89D01D}.Debug|x64.Build.0 = Debug|x64
		{5C809C14-F6A4-470F-A2EA-7BEC2B89D01D}.Debug|x86.ActiveCfg = Debug|Win32
		{5C809C14-F6A4-470F-A2EA-7BEC2B89D01D}.Debug|x86.Build.0 = Debug|Win32
		{5C809C14-F6A4-470F-A2EA-7BEC2B89D01D}.Release|x64.ActiveCfg = Release|x64
		{5C809C14-F6A4-470F-A2EA-7BEC2B89D01D}.Release|x64.Build.0 = Release|x64
		{5C809C14-F6A4-470F-A2EA-7BEC2B89D01D}.Release|x86.ActiveCfg = Release|Win32
		{5C809C14-F6A4-470F-A2EA-7BEC2B89D01D}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {ADAF97CE-3792-4F65-A3D7-973EF5950F50}
	EndGlobalSection
EndGlobal

```

`GameOverlayUIHook/GameOverlayUIHook.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{5C809C14-F6A4-470F-A2EA-7BEC2B89D01D}</ProjectGuid>
    <RootNamespace>GameOverlayUIHook</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.17763.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>false</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>LLVM-vs2017</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <GenerateManifest>false</GenerateManifest>
    <EmbedManifest>false</EmbedManifest>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>false</SDLCheck>
      <ConformanceMode>false</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="dllmain.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="obfuscation.h" />
    <ClInclude Include="SDK.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`GameOverlayUIHook/GameOverlayUIHook.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="源文件">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="头文件">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="资源文件">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="dllmain.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="SDK.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="obfuscation.h">
      <Filter>头文件</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`GameOverlayUIHook/GameOverlayUIHook.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`GameOverlayUIHook/SDK.h`:

```h
#include <windows.h>

typedef void* (*CreateInterfaceFn)(const char *pName, int *pReturnCode);

typedef int HInputContext;

struct InputEvent_t
{
	int m_nType;				// Type of the event (see InputEventType_t)
	int m_nTick;				// Tick on which the event occurred
	int m_nData;				// Generic 32-bit data, what it contains depends on the event
	int m_nData2;				// Generic 32-bit data, what it contains depends on the event
	int m_nData3;				// Generic 32-bit data, what it contains depends on the event
};

enum
{
	MAX_JOYSTICKS = 1,
	MOUSE_BUTTON_COUNT = 5,
};

enum JoystickAxis_t
{
	JOY_AXIS_X = 0,
	JOY_AXIS_Y,
	JOY_AXIS_Z,
	JOY_AXIS_R,
	JOY_AXIS_U,
	JOY_AXIS_V,
	MAX_JOYSTICK_AXES,
};

enum
{
	JOYSTICK_MAX_BUTTON_COUNT = 32,
	JOYSTICK_POV_BUTTON_COUNT = 4,
	JOYSTICK_AXIS_BUTTON_COUNT = MAX_JOYSTICK_AXES * 2,
};

enum MouseCodeState_t
{
	BUTTON_RELEASED = 0,
	BUTTON_PRESSED,
	BUTTON_DOUBLECLICKED,
};

#define JOYSTICK_BUTTON_INTERNAL( _joystick, _button ) ( JOYSTICK_FIRST_BUTTON + ((_joystick) * JOYSTICK_MAX_BUTTON_COUNT) + (_button) )
#define JOYSTICK_POV_BUTTON_INTERNAL( _joystick, _button ) ( JOYSTICK_FIRST_POV_BUTTON + ((_joystick) * JOYSTICK_POV_BUTTON_COUNT) + (_button) )
#define JOYSTICK_AXIS_BUTTON_INTERNAL( _joystick, _button ) ( JOYSTICK_FIRST_AXIS_BUTTON + ((_joystick) * JOYSTICK_AXIS_BUTTON_COUNT) + (_button) )

#define JOYSTICK_BUTTON( _joystick, _button ) ( (ButtonCode_t)JOYSTICK_BUTTON_INTERNAL( _joystick, _button ) )
#define JOYSTICK_POV_BUTTON( _joystick, _button ) ( (ButtonCode_t)JOYSTICK_POV_BUTTON_INTERNAL( _joystick, _button ) )
#define JOYSTICK_AXIS_BUTTON( _joystick, _button ) ( (ButtonCode_t)JOYSTICK_AXIS_BUTTON_INTERNAL( _joystick, _button ) )

enum ButtonCode_t
{
	BUTTON_CODE_INVALID = -1,
	BUTTON_CODE_NONE = 0,

	KEY_FIRST = 0,

	KEY_NONE = KEY_FIRST,
	KEY_0,
	KEY_1,
	KEY_2,
	KEY_3,
	KEY_4,
	KEY_5,
	KEY_6,
	KEY_7,
	KEY_8,
	KEY_9,
	KEY_A,
	KEY_B,
	KEY_C,
	KEY_D,
	KEY_E,
	KEY_F,
	KEY_G,
	KEY_H,
	KEY_I,
	KEY_J,
	KEY_K,
	KEY_L,
	KEY_M,
	KEY_N,
	KEY_O,
	KEY_P,
	KEY_Q,
	KEY_R,
	KEY_S,
	KEY_T,
	KEY_U,
	KEY_V,
	KEY_W,
	KEY_X,
	KEY_Y,
	KEY_Z,
	KEY_PAD_0,
	KEY_PAD_1,
	KEY_PAD_2,
	KEY_PAD_3,
	KEY_PAD_4,
	KEY_PAD_5,
	KEY_PAD_6,
	KEY_PAD_7,
	KEY_PAD_8,
	KEY_PAD_9,
	KEY_PAD_DIVIDE,
	KEY_PAD_MULTIPLY,
	KEY_PAD_MINUS,
	KEY_PAD_PLUS,
	KEY_PAD_ENTER,
	KEY_PAD_DECIMAL,
	KEY_LBRACKET,
	KEY_RBRACKET,
	KEY_SEMICOLON,
	KEY_APOSTROPHE,
	KEY_BACKQUOTE,
	KEY_COMMA,
	KEY_PERIOD,
	KEY_SLASH,
	KEY_BACKSLASH,
	KEY_MINUS,
	KEY_EQUAL,
	KEY_ENTER,
	KEY_SPACE,
	KEY_BACKSPACE,
	KEY_TAB,
	KEY_CAPSLOCK,
	KEY_NUMLOCK,
	KEY_ESCAPE,
	KEY_SCROLLLOCK,
	KEY_INSERT,
	KEY_DELETE,
	KEY_HOME,
	KEY_END,
	KEY_PAGEUP,
	KEY_PAGEDOWN,
	KEY_BREAK,
	KEY_LSHIFT,
	KEY_RSHIFT,
	KEY_LALT,
	KEY_RALT,
	KEY_LCONTROL,
	KEY_RCONTROL,
	KEY_LWIN,
	KEY_RWIN,
	KEY_APP,
	KEY_UP,
	KEY_LEFT,
	KEY_DOWN,
	KEY_RIGHT,
	KEY_F1,
	KEY_F2,
	KEY_F3,
	KEY_F4,
	KEY_F5,
	KEY_F6,
	KEY_F7,
	KEY_F8,
	KEY_F9,
	KEY_F10,
	KEY_F11,
	KEY_F12,
	KEY_CAPSLOCKTOGGLE,
	KEY_NUMLOCKTOGGLE,
	KEY_SCROLLLOCKTOGGLE,

	KEY_LAST = KEY_SCROLLLOCKTOGGLE,
	KEY_COUNT = KEY_LAST - KEY_FIRST + 1,

	// Mouse
	MOUSE_FIRST = KEY_LAST + 1,

	MOUSE_LEFT = MOUSE_FIRST,
	MOUSE_RIGHT,
	MOUSE_MIDDLE,
	MOUSE_4,
	MOUSE_5,
	MOUSE_WHEEL_UP,		// A fake button which is 'pressed' and 'released' when the wheel is moved up 
	MOUSE_WHEEL_DOWN,	// A fake button which is 'pressed' and 'released' when the wheel is moved down

	MOUSE_LAST = MOUSE_WHEEL_DOWN,
	MOUSE_COUNT = MOUSE_LAST - MOUSE_FIRST + 1,

	// Joystick
	JOYSTICK_FIRST = MOUSE_LAST + 1,

	JOYSTICK_FIRST_BUTTON = JOYSTICK_FIRST,
	JOYSTICK_LAST_BUTTON = JOYSTICK_BUTTON_INTERNAL(MAX_JOYSTICKS - 1, JOYSTICK_MAX_BUTTON_COUNT - 1),
	JOYSTICK_FIRST_POV_BUTTON,
	JOYSTICK_LAST_POV_BUTTON = JOYSTICK_POV_BUTTON_INTERNAL(MAX_JOYSTICKS - 1, JOYSTICK_POV_BUTTON_COUNT - 1),
	JOYSTICK_FIRST_AXIS_BUTTON,
	JOYSTICK_LAST_AXIS_BUTTON = JOYSTICK_AXIS_BUTTON_INTERNAL(MAX_JOYSTICKS - 1, JOYSTICK_AXIS_BUTTON_COUNT - 1),

	JOYSTICK_LAST = JOYSTICK_LAST_AXIS_BUTTON,

	BUTTON_CODE_LAST,
	BUTTON_CODE_COUNT = BUTTON_CODE_LAST - KEY_FIRST + 1,

	// Helpers for XBox 360
	KEY_XBUTTON_UP = JOYSTICK_FIRST_POV_BUTTON,	// POV buttons
	KEY_XBUTTON_RIGHT,
	KEY_XBUTTON_DOWN,
	KEY_XBUTTON_LEFT,

	KEY_XBUTTON_A = JOYSTICK_FIRST_BUTTON,		// Buttons
	KEY_XBUTTON_B,
	KEY_XBUTTON_X,
	KEY_XBUTTON_Y,
	KEY_XBUTTON_LEFT_SHOULDER,
	KEY_XBUTTON_RIGHT_SHOULDER,
	KEY_XBUTTON_BACK,
	KEY_XBUTTON_START,
	KEY_XBUTTON_STICK1,
	KEY_XBUTTON_STICK2,

	KEY_XSTICK1_RIGHT = JOYSTICK_FIRST_AXIS_BUTTON,	// XAXIS POSITIVE
	KEY_XSTICK1_LEFT,							// XAXIS NEGATIVE
	KEY_XSTICK1_DOWN,							// YAXIS POSITIVE
	KEY_XSTICK1_UP,								// YAXIS NEGATIVE
	KEY_XBUTTON_LTRIGGER,						// ZAXIS POSITIVE
	KEY_XBUTTON_RTRIGGER,						// ZAXIS NEGATIVE
	KEY_XSTICK2_RIGHT,							// UAXIS POSITIVE
	KEY_XSTICK2_LEFT,							// UAXIS NEGATIVE
	KEY_XSTICK2_DOWN,							// VAXIS POSITIVE
	KEY_XSTICK2_UP,								// VAXIS NEGATIVE
};

namespace vgui
{
	// handle to an internal vgui panel
	// this is the only handle to a panel that is valid across dll boundaries
	typedef unsigned int VPANEL;

	// handles to vgui objects
	// NULL values signify an invalid value
	typedef unsigned long HScheme;
	typedef unsigned long HTexture;
	typedef unsigned long HCursor;
	typedef unsigned long HPanel;
	typedef ButtonCode_t MouseCode;
	typedef ButtonCode_t KeyCode;
	const HPanel INVALID_PANEL = 0xffffffff;
	typedef unsigned long HFont;
	const HFont INVALID_FONT = 0; // the value of an invalid font handle
}

using namespace vgui;

typedef float vec_t;

class Vector2D					
{
public:
	vec_t x, y;
};

struct Vertex_t
{
	Vector2D	m_Position;
	Vector2D	m_TexCoord;
};

class Color
{
public:
	// constructors
	Color()
	{
		*((int *)this) = 0;
	}
	Color(int r,int g,int b)
	{
		SetColor(r, g, b, 0);
	}
	Color(int r,int g,int b,int a)
	{
		SetColor(r, g, b, a);
	}
	
	// set the color
	// r - red component (0-255)
	// g - green component (0-255)
	// b - blue component (0-255)
	// a - alpha component, controls transparency (0 - transparent, 255 - opaque);
	void SetColor(int r, int g, int b, int a = 0)
	{
		_color[0] = (unsigned char)r;
		_color[1] = (unsigned char)g;
		_color[2] = (unsigned char)b;
		_color[3] = (unsigned char)a;
	}

	void GetColor(int &r, int &g, int &b, int &a) const
	{
		r = _color[0];
		g = _color[1];
		b = _color[2];
		a = _color[3];
	}

	void SetRawColor( int color32 )
	{
		*((int *)this) = color32;
	}

	int GetRawColor() const
	{
		return *((int *)this);
	}

	inline int r() const	{ return _color[0]; }
	inline int g() const	{ return _color[1]; }
	inline int b() const	{ return _color[2]; }
	inline int a() const	{ return _color[3]; }
	
	unsigned char &operator[](int index)
	{
		return _color[index];
	}

	const unsigned char &operator[](int index) const
	{
		return _color[index];
	}

	bool operator == (const Color &rhs) const
	{
		return ( *((int *)this) == *((int *)&rhs) );
	}

	bool operator != (const Color &rhs) const
	{
		return !(operator==(rhs));
	}

	Color &operator=( const Color &rhs )
	{
		SetRawColor( rhs.GetRawColor() );
		return *this;
	}

private:
	unsigned char _color[4];
};

struct IntRect
{
	int x0;
	int y0;
	int x1;
	int y1;
};

enum FontDrawType_t
{
	// Use the "additive" value from the scheme file
	FONT_DRAW_DEFAULT = 0,

	// Overrides
	FONT_DRAW_NONADDITIVE,
	FONT_DRAW_ADDITIVE,

	FONT_DRAW_TYPE_COUNT = 2,
};

struct CharRenderInfo
{
	// In:
	FontDrawType_t	drawType;
	wchar_t			ch;

	// Out
	bool			valid;

	// In/Out (true by default)
	bool			shouldclip;
	// Text pos
	int				x, y;
	// Top left and bottom right
	Vertex_t		verts[ 2 ];
	int				textureId;
	int				abcA;
	int				abcB;
	int				abcC;
	int				fontTall;
	vgui::HFont		currentFont;
};

struct ISurface
{
	void(__stdcall *Unknown000)();																	//0000
	void(__stdcall *Unknown001)();  																//0004
	void(__stdcall *Unknown002)();								        							//0008
	void(__stdcall *Unknown003)();																	//000C
	void(__stdcall *Unknown004)();																	//0010
	void(__stdcall *Unknown005)();																	//0014
	void(__stdcall *Unknown006)();																	//0018
	void(__stdcall *Unknown007)();											                		//001C
	void(__stdcall *Unknown008)();													        		//0020
	void(__stdcall *Unknown009)();	 			                    								//0024
	void(__stdcall *PushMakeCurrent)(VPANEL panel, bool useInsets);									//0028
	void(__stdcall *PopMakeCurrent)(VPANEL panel);													//002C
	void(__stdcall *DrawSetColor001)(Color col); 									                //0030
	void(__stdcall *DrawSetColor002)(int r, int g, int b, int a);									//0034
	void(__stdcall *DrawFilledRect)(int x0, int y0, int x1, int y1);								//0038
	void(__stdcall *DrawFilledRectArray)(IntRect *pRects, int numRects);							//003C
	void(__stdcall *DrawOutlinedRect)(int x0, int y0, int x1, int y1);								//0040
	void(__stdcall *DrawLine)(int x0, int y0, int x1, int y1);										//0044
	void(__stdcall *DrawPolyLine)(int *px, int *py, int numPoints);									//0048
	void(__stdcall *DrawSetTextFont)(HFont font);													//004C
	void(__stdcall *DrawSetTextColor001)(int col); 								                    //0050
	void(__stdcall *DrawSetTextColor002)(int r, int g, int b, int a);								//0054
	void(__stdcall *DrawSetTextPos)(int x, int y);													//0058
	void(__stdcall *DrawGetTextPos)(int& x, int& y);												//005C
	void(__stdcall *DrawPrintText)(const wchar_t *text, int textLen, FontDrawType_t drawType);		//0060
	void(__stdcall *DrawUnicodeChar)(wchar_t wch, FontDrawType_t drawType);							//0064
	void(__stdcall *DrawUnicodeString)(wchar_t *pString, int len);									//0068
	void(__stdcall *Unknown0001)();																	//006C
	void(__stdcall *Unknown0002)();																	//0070
	void(__stdcall *Unknown0003)();																	//0074
	void(__stdcall *Unknown0004)();																	//0078
	void(__stdcall *Unknown0005)();																	//007C
	void(__stdcall *Unknown0006)();																	//0080
	void(__stdcall *Unknown0007)();																	//0084
	void(__stdcall *Unknown0008)();																	//0088
	void(__stdcall *Unknown0009)();																	//008C
	void(__stdcall *Unknown0010)();																	//0090
	void(__stdcall *Unknown0011)();																	//0094
	void(__stdcall*UnknowDraw2)(int x0, int y0, int x1, int y1);		        					//0098
	void(__stdcall *Unknown0013)();																	//009C
	void(__stdcall*UnknowDraw1)(int x0, int y0, int x1, int y1);									//00A0
	void(__stdcall *Unknown0015)();                     							    	        //00A4
	void(__stdcall *Unknown0016)();																	//00A8
	void(__stdcall *Unknown0017)();																	//00AC
	void(__stdcall *Unknown0018)();																	//00B0
	void(__stdcall *Unknown0019)();																	//00B4
	void(__stdcall *Unknown0020)();																	//00B8
	void(__stdcall *Unknown0021)();																	//00BC
	void(__stdcall *Unknown0022)();																	//00C0
	void(__stdcall *Unknown0023)();																	//00C4
	void(__stdcall *Unknown0024)();																	//00C8
	void(__stdcall *Unknown0025)();																	//00CC
	void(__stdcall *Unknown0026)();																	//00D0
	void(__stdcall *Unknown0027)();																	//00D4
	void(__stdcall *Unknown0028)();																	//00D8
	void(__stdcall *Unknown0029)();																	//00DC
	void(__stdcall *Unknown0030)();																	//00E0
	void(__stdcall *Unknown0031)();																	//00E4
	void(__stdcall *Unknown0032)();																	//00E8
	void(__stdcall *Unknown0033)();																	//00EC
	void(__stdcall *Unknown0034)();																	//00F0
	void(__stdcall *Unknown0035)();																	//00F4
	void(__stdcall *Unknown0036)();																	//00F8
	void(__stdcall *Unknown0037)();																	//00FC
	void(__stdcall *Unknown0038)();																	//0100
	void(__stdcall *Unknown0039)();																	//0104
	void(__stdcall *Unknown0040)();																	//0108
	bool(__stdcall *SupportsFeature)(int feature);													//010C
	void(__stdcall *RestrictPaintToSinglePanel)(VPANEL panel);										//0110
	void(__stdcall *Unknown0041)();																	//0114
	void(__stdcall *Unknown0042)();																	//0118
	void(__stdcall *Unknown0043)();																	//011C
	void(__stdcall *Unknown0044)();																	//0120
	void(__stdcall *Unknown0045)();																	//0124
	void(__stdcall *Unknown0046)();																	//0128
	void(__stdcall *Unknown0047)();																	//012C
	HFont(__stdcall *CreateFont)();																	//0130
	bool(__stdcall *SetFontGlyphSet)(HFont font, const char *windowsFontName,
		int tall, int weight, int blur, int scanlines, int flags);										//0130
	bool(__stdcall *AddCustomFontFile)(const char *fontFileName);										//0134
	void(__stdcall *Unknown0048)();																	//0138
	void(__stdcall *Unknown0049)();																	//013C
	void(__stdcall *Unknown0050)();																	//0140
	void(__stdcall *Unknown0051)();																	//0144
	void(__stdcall *Unknown0052)();																	//0148
	void(__stdcall *Unknown0053)();																	//014C
	void(__stdcall *Unknown0054)();																	//0150
	void(__stdcall *Unknown0055)();																	//0154
	void(__stdcall *Unknown0056)();																	//0158
	void(__stdcall *Unknown0057)();																	//015C
	void(__stdcall *Unknown0058)();																	//0160
	void(__stdcall *Unknown0059)();																	//0164
	void(__stdcall *PaintTraverse)(VPANEL panel);														//0168
	void(__stdcall *Unknown0060)();																	//016C
	void(__stdcall *Unknown0061)();																	//0170
	void(__stdcall *Unknown0062)();																	//0174
	void(__stdcall *Unknown0063)();																	//0178
	void(__stdcall *Unknown0064)();																	//017C
	void(__stdcall *Unknown0065)();																	//0180
	void(__stdcall *Unknown0066)();																	//0184
	void(__stdcall *Unknown0067)();																	//0188
	void(__stdcall *Unknown0068)();																	//018C
	void(__stdcall *GetProportionalBase)(int &width, int &height);									//0190
	void(__stdcall *CalculateMouseVisible)();															//0194
	bool(__stdcall *NeedKBInput)();																	//0198
	bool(__stdcall *HasCursorPosFunctions)();															//019C
	void(__stdcall *SurfaceGetCursorPos)(int &x, int &y);												//01A0
	void(__stdcall *SurfaceSetCursorPos)(int x, int y);												//01A4
	void(__stdcall *DrawTexturedLine)(const Vertex_t &a, const Vertex_t &b);						//01A8
	void(__stdcall *DrawOutlinedCircle)(int x, int y, int radius, int segments);					//01AC
	void(__stdcall *DrawTexturedPolyLine)(const Vertex_t *p, int n);								//01B0
	void(__stdcall *DrawTexturedSubRect)(int x0, int y0, int x1, int y1,
		float texs0, float text0, float texs1, float text1);										//01B4
	void(__stdcall *DrawTexturedPolygon)(int n, Vertex_t *pVertices);								//01B8
	const wchar_t* (__stdcall *GetTitle)(VPANEL panel);												//01BC
	bool(__stdcall *IsCursorLocked)(void);															//01C0
	void(__stdcall *SetWorkspaceInsets)(int left, int top, int right, int bottom);					//01C4
	bool(__stdcall *DrawGetUnicodeCharRenderInfo)(wchar_t ch, CharRenderInfo& info);				//01C8
	void(__stdcall *DrawRenderCharFromInfo)(const CharRenderInfo& info);							//01CC
	void(__stdcall *DrawSetAlphaMultiplier)(float alpha /* [0..1] */);								//01D0
	float(__stdcall *DrawGetAlphaMultiplier)();														//01D4
	void(__stdcall *SetAllowHTMLJavaScript)(bool state);											//01D8
	void(__stdcall *OnScreenSizeChanged)(int nOldWidth, int nOldHeight);							//01DC
	void(__stdcall *Unknown0069)();																	//01E0
	void(__stdcall *Unknown0070)();																	//01E4
	void(__stdcall *PaintTraverseEx)(VPANEL panel, bool paintPopups);								//01E8
};

class ISurface039
{
public:

	virtual void Unknown000() = 0;																	//0000
	virtual void Unknown001() = 0;  																//0004
	virtual void Unknown002() = 0;								        							//0008
	virtual void Unknown003() = 0;																	//000C
	virtual void Unknown004() = 0;																	//0010
	virtual void Unknown005() = 0;																	//0014
	virtual void Unknown006() = 0;																	//0018
	virtual void Unknown007() = 0;											                		//001C
	virtual void Unknown008() = 0;													        		//0020
	virtual void Unknown009() = 0;	 			                    								//0024
	virtual void PushMakeCurrent(VPANEL panel, bool useInsets) = 0;									//0028
	virtual void PopMakeCurrent(VPANEL panel) = 0;													//002C
	virtual void DrawSetColor001(Color col) = 0; 									                //0030
	virtual void DrawSetColor002(int r, int g, int b, int a) = 0;									//0034
	virtual void DrawFilledRect(int x0, int y0, int x1, int y1) = 0;								//0038
	virtual void DrawFilledRectArray(IntRect *pRects, int numRects) = 0;							//003C
	virtual void DrawOutlinedRect(int x0, int y0, int x1, int y1) = 0;								//0040
	virtual void DrawLine(int x0, int y0, int x1, int y1) = 0;										//0044
	virtual void DrawPolyLine(int *px, int *py, int numPoints) = 0;									//0048
	virtual void DrawSetTextFont(HFont font) = 0;													//004C
	virtual void DrawSetTextColor001(int col) = 0; 								                    //0050
	virtual void DrawSetTextColor002(int r, int g, int b, int a) = 0;								//0054
	virtual void DrawSetTextPos(int x, int y) = 0;													//0058
	virtual void DrawGetTextPos(int& x, int& y) = 0;												//005C
	virtual void DrawPrintText(const wchar_t *text, int textLen, FontDrawType_t drawType) = 0;		//0060
	virtual void DrawUnicodeChar(wchar_t wch, FontDrawType_t drawType) = 0;							//0064
	virtual void DrawUnicodeString(wchar_t *pString, int len) = 0;									//0068
	virtual void Unknown010() = 0;																	//006C
	virtual void Unknown011() = 0;  																//0070
	virtual void Unknown012() = 0;								        							//0074
	virtual void Unknown013() = 0;																	//0078
	virtual void Unknown014() = 0;																	//007C
	virtual void Unknown015() = 0;																	//0080
	virtual void Unknown016() = 0;																	//0084
	virtual void Unknown017() = 0;											                		//0088
	virtual void Unknown018() = 0;													        		//008C
	virtual void Unknown019() = 0;	 			                    								//0090
	virtual void Unknown020() = 0;																	//0094
	virtual void Unknown021() = 0;  																//0098
	virtual void Unknown022() = 0;								        							//009C
	virtual void Unknown023() = 0;																	//00A0
	virtual void Unknown024() = 0;																	//00A4
	virtual void Unknown025() = 0;																	//00A8
	virtual void Unknown026() = 0;																	//00AC
	virtual void Unknown027() = 0;											                		//00B0
	virtual void Unknown028() = 0;													        		//00B4
	virtual void Unknown029() = 0;	 			                    								//00B8
	virtual void Unknown030() = 0;																	//00BC
	virtual void Unknown031() = 0;  																//00C0
	virtual void Unknown032() = 0;								        							//00C4
	virtual void Unknown033() = 0;																	//00C8
	virtual void Unknown034() = 0;																	//00CC
	virtual void Unknown035() = 0;																	//00D0
	virtual void Unknown036() = 0;																	//00D4
	virtual void Unknown037() = 0;											                		//00D8
	virtual void Unknown038() = 0;													        		//00DC
	virtual void Unknown039() = 0;	 			                    								//00E0
	virtual void Unknown040() = 0;																	//00E4
	virtual void Unknown041() = 0;  																//00E8
	virtual void Unknown042() = 0;								        							//00EC
	virtual void Unknown043() = 0;																	//00F0
	virtual void Unknown044() = 0;																	//00F4
	virtual void Unknown045() = 0;																	//00F8
	virtual void Unknown046() = 0;																	//00FC
	virtual void Unknown047() = 0;											                		//0100
	virtual void Unknown048() = 0;													        		//0104
	virtual void Unknown049() = 0;	 			                    								//0108
	virtual void Unknown050() = 0;																	//010C
	virtual void Unknown051() = 0;  																//0110
	virtual void Unknown052() = 0;								        							//0114
	virtual void Unknown053() = 0;																	//0118
	virtual void Unknown054() = 0;																	//011C
	virtual void Unknown055() = 0;																	//0120
	virtual void Unknown056() = 0;																	//0124
	virtual void Unknown057() = 0;											                		//0128
	virtual void Unknown058() = 0;													        		//012C
	virtual void Unknown059() = 0;	 			                    								//0130
	virtual void Unknown060() = 0;																	//0134
	virtual void Unknown061() = 0;  																//0138
	virtual void Unknown062() = 0;								        							//013C
	virtual void Unknown063() = 0;																	//0140
	virtual void Unknown064() = 0;																	//0144
	virtual void Unknown065() = 0;																	//0148
	virtual void Unknown066() = 0;																	//014C
	virtual void Unknown067() = 0;											                		//0150
	virtual void Unknown068() = 0;													        		//0154
	virtual void Unknown069() = 0;	 			                    								//0158
	virtual void Unknown070() = 0;																	//015C
	virtual void Unknown071() = 0;  																//0160
	virtual void Unknown072() = 0;								        							//0164
	virtual void Unknown073() = 0;																	//0168
	virtual void Unknown074() = 0;																	//016C
	virtual void Unknown075() = 0;																	//0170
	virtual void Unknown076() = 0;																	//0174
	virtual void Unknown077() = 0;											                		//0178
	virtual void Unknown078() = 0;													        		//017C
	virtual void Unknown079() = 0;	 			                    								//0180
	virtual void Unknown080() = 0;																	//0184
	virtual void Unknown081() = 0;  																//0188
	virtual void Unknown082() = 0;								        							//018C
	virtual void Unknown083() = 0;																	//0190
	virtual void Unknown084() = 0;																	//0194
	virtual void Unknown085() = 0;																	//0198
	virtual void Unknown086() = 0;																	//019C
	virtual void PaintTraverse(VPANEL panel) = 0;													//01A0
	virtual void Unknown0060() = 0;																	//01A4
	virtual void Unknown0061() = 0;																	//01A8
	virtual void Unknown0062() = 0;																	//01AC
	virtual void Unknown0063() = 0;																	//01B0
	virtual void Unknown0064() = 0;																	//01B4
	virtual void Unknown0065() = 0;																	//01B8
	virtual void Unknown0066() = 0;																	//01BC
	virtual void Unknown0067() = 0;																	//01C0
	virtual void Unknown0068() = 0;																	//01C4
	virtual void GetProportionalBase(int &width, int &height) = 0;									//01C8
	virtual void CalculateMouseVisible() = 0;														//01CC
	virtual bool NeedKBInput() = 0;																	//01D0
	virtual bool HasCursorPosFunctions() = 0;														//01D4
	virtual void SurfaceGetCursorPos(int &x, int &y) = 0;											//01D8
	virtual void SurfaceSetCursorPos(int x, int y) = 0;												//01DC
	virtual void DrawTexturedLine(const Vertex_t &a, const Vertex_t &b) = 0;						//01E0
	virtual void DrawOutlinedCircle(int x, int y, int radius, int segments) = 0;					//01E4
	virtual void DrawTexturedPolyLine(const Vertex_t *p, int n) = 0;								//01E8
	virtual void DrawTexturedSubRect(int x0, int y0, int x1, int y1,
		float texs0, float text0, float texs1, float text1) = 0;									//01EC
	virtual void DrawTexturedPolygon(int n, Vertex_t *pVertices) = 0;								//01F0
	virtual const wchar_t* GetTitle(VPANEL panel) = 0;												//01F4
	virtual bool IsCursorLocked(void) = 0;															//01F8
	virtual void SetWorkspaceInsets(int left, int top, int right, int bottom) = 0;					//01FC
	virtual bool DrawGetUnicodeCharRenderInfo(wchar_t ch, CharRenderInfo& info) = 0;				//0200
	virtual void DrawRenderCharFromInfo(const CharRenderInfo& info) = 0;							//0204
	virtual void DrawSetAlphaMultiplier(float alpha /* [0..1] */) = 0;								//0208
	virtual float DrawGetAlphaMultiplier() = 0;														//020C
	virtual void SetAllowHTMLJavaScript(bool state) = 0;											//0210
	virtual void OnScreenSizeChanged(int nOldWidth, int nOldHeight) = 0;							//0214
	virtual void Unknown0087() = 0;																	//0218
	virtual void Unknown0088() = 0;																	//021C
	virtual void PaintTraverseEx(VPANEL panel, bool paintPopups) = 0;								//0220
};

class IBaseInterface
{
public:
	virtual	~IBaseInterface() {}
};

class IPanel : public IBaseInterface
{
public:
	virtual void Init(VPANEL vguiPanel, void *panel) = 0;

	// methods
	virtual void SetPos(VPANEL vguiPanel, int x, int y) = 0;
	virtual void GetPos(VPANEL vguiPanel, int &x, int &y) = 0;
	virtual void Unknown001() = 0;
	virtual void SetSize(VPANEL vguiPanel, int wide, int tall) = 0;
	virtual void GetSize(VPANEL vguiPanel, int &wide, int &tall) = 0;
	virtual void SetMinimumSize(VPANEL vguiPanel, int wide, int tall) = 0;
	virtual void GetMinimumSize(VPANEL vguiPanel, int &wide, int &tall) = 0;
	virtual void SetZPos(VPANEL vguiPanel, int z) = 0;
	virtual int  GetZPos(VPANEL vguiPanel) = 0;
	virtual void GetAbsPos(VPANEL vguiPanel, int &x, int &y) = 0;
	virtual void GetClipRect(VPANEL vguiPanel, int &x0, int &y0, int &x1, int &y1) = 0;
	virtual void SetInset(VPANEL vguiPanel, int left, int top, int right, int bottom) = 0;
	virtual void GetInset(VPANEL vguiPanel, int &left, int &top, int &right, int &bottom) = 0;
	virtual void SetVisible(VPANEL vguiPanel, bool state) = 0;
	virtual bool IsVisible(VPANEL vguiPanel) = 0;
	virtual void SetParent(VPANEL vguiPanel, VPANEL newParent) = 0;
	virtual int GetChildCount(VPANEL vguiPanel) = 0;
	virtual VPANEL GetChild(VPANEL vguiPanel, int index) = 0;
	virtual VPANEL GetParent(VPANEL vguiPanel) = 0;
	virtual void MoveToFront(VPANEL vguiPanel) = 0;
	virtual void MoveToBack(VPANEL vguiPanel) = 0;
	virtual bool HasParent(VPANEL vguiPanel, VPANEL potentialParent) = 0;
	virtual bool IsPopup(VPANEL vguiPanel) = 0;
	virtual void SetPopup(VPANEL vguiPanel, bool state) = 0;
	virtual bool IsFullyVisible(VPANEL vguiPanel) = 0;
	virtual HScheme GetScheme(VPANEL vguiPanel) = 0;
	virtual bool IsProportional(VPANEL vguiPanel) = 0;
	virtual bool IsAutoDeleteSet(VPANEL vguiPanel) = 0;
	virtual void DeletePanel(VPANEL vguiPanel) = 0;
	virtual void Unknown002() = 0;
	virtual void Unknown003() = 0;
	virtual void SetKeyBoardInputEnabled(VPANEL vguiPanel, bool state) = 0;
	virtual void SetMouseInputEnabled(VPANEL vguiPanel, bool state) = 0;
	virtual bool IsKeyBoardInputEnabled(VPANEL vguiPanel) = 0;
	virtual bool IsMouseInputEnabled(VPANEL vguiPanel) = 0;
	virtual void Solve(VPANEL vguiPanel) = 0;
	virtual const char *GetName(VPANEL vguiPanel) = 0;
	virtual const char *GetClassName(VPANEL vguiPanel) = 0;
	virtual void SendMessage(VPANEL vguiPanel, void *params, VPANEL ifromPanel) = 0;
	virtual void Think(VPANEL vguiPanel) = 0;
	virtual void PerformApplySchemeSettings(VPANEL vguiPanel) = 0;
	virtual void PaintTraverse(VPANEL vguiPanel, bool forceRepaint, bool allowForce = true) = 0;
	virtual void Repaint(VPANEL vguiPanel) = 0;
	virtual VPANEL IsWithinTraverse(VPANEL vguiPanel, int x, int y, bool traversePopups) = 0;
	virtual void OnChildAdded(VPANEL vguiPanel, VPANEL child) = 0;
	virtual void OnSizeChanged(VPANEL vguiPanel, int newWide, int newTall) = 0;
	virtual void InternalFocusChanged(VPANEL vguiPanel, bool lost) = 0;
	virtual bool RequestInfo(VPANEL vguiPanel, void *outputData) = 0;
	virtual void RequestFocus(VPANEL vguiPanel, int direction = 0) = 0;
	virtual bool RequestFocusPrev(VPANEL vguiPanel, VPANEL existingPanel) = 0;
	virtual bool RequestFocusNext(VPANEL vguiPanel, VPANEL existingPanel) = 0;
	virtual VPANEL GetCurrentKeyFocus(VPANEL vguiPanel) = 0;
	virtual int GetTabPosition(VPANEL vguiPanel) = 0;
	virtual void *Plat(VPANEL vguiPanel) = 0;
	virtual void SetPlat(VPANEL vguiPanel, void *Plat) = 0;
	virtual void *GetPanel(VPANEL vguiPanel, const char *destinationModule) = 0;
	virtual bool IsEnabled(VPANEL vguiPanel) = 0;
	virtual void SetEnabled(VPANEL vguiPanel, bool state) = 0;
};

class ISetup
{
public:
	virtual void Unknown01() = 0;
	virtual void Unknown02() = 0;
	virtual void Unknown03() = 0;
	virtual void Unknown04() = 0;
	virtual ISurface* CreateSurfaceInterface(char* Version) = 0;
};

class IInput : public IBaseInterface
{
public:
	virtual void SetMouseFocus(VPANEL newMouseFocus) = 0;
	virtual void SetMouseCapture(VPANEL panel) = 0;
	virtual void GetKeyCodeText(KeyCode code, char *buf, int buflen) = 0;
	virtual VPANEL GetFocus() = 0;
	virtual VPANEL GetMouseOver() = 0;		// returns the panel the mouse is currently over, ignoring mouse capture
	virtual void SetCursorPos(int x, int y) = 0;
	virtual void GetCursorPos(int &x, int &y) = 0;
	virtual bool WasMousePressed(MouseCode code) = 0;
	virtual bool WasMouseDoublePressed(MouseCode code) = 0;
	virtual bool IsMouseDown(MouseCode code) = 0;
	virtual void SetCursorOveride(HCursor cursor) = 0;
	virtual HCursor GetCursorOveride() = 0;
	virtual bool WasMouseReleased(MouseCode code) = 0;
	virtual bool WasKeyPressed(KeyCode code) = 0;
	virtual bool IsKeyDown(KeyCode code) = 0;
	virtual bool WasKeyTyped(KeyCode code) = 0;
	virtual bool WasKeyReleased(KeyCode code) = 0;
	virtual VPANEL GetAppModalSurface() = 0;
	virtual void SetAppModalSurface(VPANEL panel) = 0;
	virtual void ReleaseAppModalSurface() = 0;
	virtual void GetCursorPosition(int &x, int &y) = 0;
	virtual void SetIMEWindow(void *hwnd) = 0;
	virtual void *GetIMEWindow() = 0;
	virtual void OnChangeIME(bool forward) = 0;
	virtual int  GetCurrentIMEHandle() = 0;
	virtual int  GetEnglishIMEHandle() = 0;
	virtual void GetIMELanguageName(wchar_t *buf, int unicodeBufferSizeInBytes) = 0;
	virtual void GetIMELanguageShortCode(wchar_t *buf, int unicodeBufferSizeInBytes) = 0;

	struct LanguageItem
	{
		wchar_t		shortname[4];
		wchar_t		menuname[128];
		int			handleValue;
		bool		active;
	};

	struct ConversionModeItem
	{
		wchar_t		menuname[128];
		int			handleValue;
		bool		active;
	};

	struct SentenceModeItem
	{
		wchar_t		menuname[128];
		int			handleValue;
		bool		active;
	};

	virtual int	 GetIMELanguageList(LanguageItem *dest, int destcount) = 0;
	virtual int	 GetIMEConversionModes(ConversionModeItem *dest, int destcount) = 0;
	virtual int	 GetIMESentenceModes(SentenceModeItem *dest, int destcount) = 0;
	virtual void OnChangeIMEByHandle(int handleValue) = 0;
	virtual void OnChangeIMEConversionModeByHandle(int handleValue) = 0;
	virtual void OnChangeIMESentenceModeByHandle(int handleValue) = 0;
	virtual void OnInputLanguageChanged() = 0;
	virtual void OnIMEStartComposition() = 0;
	virtual void OnIMEComposition(int flags) = 0;
	virtual void OnIMEEndComposition() = 0;
	virtual void OnIMEShowCandidates() = 0;
	virtual void OnIMEChangeCandidates() = 0;
	virtual void OnIMECloseCandidates() = 0;
	virtual void OnIMERecomputeModes() = 0;
	virtual int  GetCandidateListCount() = 0;
	virtual void GetCandidate(int num, wchar_t *dest, int destSizeBytes) = 0;
	virtual int  GetCandidateListSelectedItem() = 0;
	virtual int  GetCandidateListPageSize() = 0;
	virtual int  GetCandidateListPageStart() = 0;
	virtual void SetCandidateWindowPos(int x, int y) = 0;
	virtual bool GetShouldInvertCompositionString() = 0;
	virtual bool CandidateListStartsAtOne() = 0;
	virtual void SetCandidateListPageStart(int start) = 0;
	virtual void SetMouseCaptureEx(VPANEL panel, MouseCode captureStartMouseCode) = 0;
	virtual void RegisterKeyCodeUnhandledListener(VPANEL panel) = 0;
	virtual void UnregisterKeyCodeUnhandledListener(VPANEL panel) = 0;
	virtual void OnKeyCodeUnhandled(int keyCode) = 0;
	virtual void	SetModalSubTree(VPANEL subTree, VPANEL unhandledMouseClickListener, bool restrictMessagesToSubTree = true) = 0;
	virtual void	ReleaseModalSubTree() = 0;
	virtual VPANEL	GetModalSubTree() = 0;
	virtual void	SetModalSubTreeReceiveMessages(bool state) = 0;
	virtual bool	ShouldModalSubTreeReceiveMessages() const = 0;
	virtual VPANEL 	GetMouseCapture() = 0;
};

class IInputInternal : public IInput
{
public:
	virtual void RunFrame() = 0;
	virtual void UpdateMouseFocus(int x, int y) = 0;
	virtual void PanelDeleted(VPANEL panel) = 0;
	virtual bool InternalCursorMoved(int x, int y) = 0; //expects input in surface space
	virtual bool InternalMousePressed(MouseCode code) = 0;
	virtual bool InternalMouseDoublePressed(MouseCode code) = 0;
	virtual bool InternalMouseReleased(MouseCode code) = 0;
	virtual bool InternalMouseWheeled(int delta) = 0;
	virtual bool InternalKeyCodePressed(KeyCode code) = 0;
	virtual void InternalKeyCodeTyped(KeyCode code) = 0;
	virtual void InternalKeyTyped(wchar_t unichar) = 0;
	virtual bool InternalKeyCodeReleased(KeyCode code) = 0;
	virtual HInputContext CreateInputContext() = 0;
	virtual void DestroyInputContext(HInputContext context) = 0;
	virtual void AssociatePanelWithInputContext(HInputContext context, VPANEL pRoot) = 0;
	virtual void ActivateInputContext(HInputContext context) = 0;
	virtual void PostCursorMessage() = 0;
	virtual void UpdateCursorPosInternal(int x, int y) = 0;
	virtual void HandleExplicitSetCursor() = 0;
	virtual void SetKeyCodeState(KeyCode code, bool bPressed) = 0;
	virtual void SetMouseCodeState(MouseCode code, MouseCodeState_t state) = 0;
	virtual void UpdateButtonState(const InputEvent_t &event) = 0;
};
```

`GameOverlayUIHook/VMProtectSDK.h`:

```h
#pragma once

#if defined(__APPLE__) || defined(__unix__)
#define VMP_IMPORT 
#define VMP_API
#define VMP_WCHAR unsigned short
#else
#define VMP_IMPORT __declspec(dllimport)
#define VMP_API __stdcall
#define VMP_WCHAR wchar_t
#ifdef _WIN64
	#pragma comment(lib, "VMProtectSDK64.lib")
#else
	#pragma comment(lib, "VMProtectSDK32.lib")
#endif // _WIN64
#endif // __APPLE__ || __unix__

#ifdef __cplusplus
extern "C" {
#endif

// protection
VMP_IMPORT void VMP_API VMProtectBegin(const char *);
VMP_IMPORT void VMP_API VMProtectBeginVirtualization(const char *);
VMP_IMPORT void VMP_API VMProtectBeginMutation(const char *);
VMP_IMPORT void VMP_API VMProtectBeginUltra(const char *);
VMP_IMPORT void VMP_API VMProtectBeginVirtualizationLockByKey(const char *);
VMP_IMPORT void VMP_API VMProtectBeginUltraLockByKey(const char *);
VMP_IMPORT void VMP_API VMProtectEnd(void);

// utils
VMP_IMPORT bool VMP_API VMProtectIsProtected();
VMP_IMPORT bool VMP_API VMProtectIsDebuggerPresent(bool);
VMP_IMPORT bool VMP_API VMProtectIsVirtualMachinePresent(void);
VMP_IMPORT bool VMP_API VMProtectIsValidImageCRC(void);
VMP_IMPORT const char * VMP_API VMProtectDecryptStringA(const char *value);
VMP_IMPORT const VMP_WCHAR * VMP_API VMProtectDecryptStringW(const VMP_WCHAR *value);
VMP_IMPORT bool VMP_API VMProtectFreeString(const void *value);

// licensing
enum VMProtectSerialStateFlags
{
	SERIAL_STATE_SUCCESS				= 0,
	SERIAL_STATE_FLAG_CORRUPTED			= 0x00000001,
	SERIAL_STATE_FLAG_INVALID			= 0x00000002,
	SERIAL_STATE_FLAG_BLACKLISTED		= 0x00000004,
	SERIAL_STATE_FLAG_DATE_EXPIRED		= 0x00000008,
	SERIAL_STATE_FLAG_RUNNING_TIME_OVER	= 0x00000010,
	SERIAL_STATE_FLAG_BAD_HWID			= 0x00000020,
	SERIAL_STATE_FLAG_MAX_BUILD_EXPIRED	= 0x00000040,
};

#pragma pack(push, 1)
typedef struct
{
	unsigned short	wYear;
	unsigned char	bMonth;
	unsigned char	bDay;
} VMProtectDate;

typedef struct
{
	int				nState;				// VMProtectSerialStateFlags
	VMP_WCHAR		wUserName[256];		// user name
	VMP_WCHAR		wEMail[256];		// email
	VMProtectDate	dtExpire;			// date of serial number expiration
	VMProtectDate	dtMaxBuild;			// max date of build, that will accept this key
	int				bRunningTime;		// running time in minutes
	unsigned char	nUserDataLength;	// length of user data in bUserData
	unsigned char	bUserData[255];		// up to 255 bytes of user data
} VMProtectSerialNumberData;
#pragma pack(pop)

VMP_IMPORT int VMP_API VMProtectSetSerialNumber(const char *serial);
VMP_IMPORT int VMP_API VMProtectGetSerialNumberState();
VMP_IMPORT bool VMP_API VMProtectGetSerialNumberData(VMProtectSerialNumberData *data, int size);
VMP_IMPORT int VMP_API VMProtectGetCurrentHWID(char *hwid, int size);

// activation
enum VMProtectActivationFlags
{
	ACTIVATION_OK = 0,
	ACTIVATION_SMALL_BUFFER,
	ACTIVATION_NO_CONNECTION,
	ACTIVATION_BAD_REPLY,
	ACTIVATION_BANNED,
	ACTIVATION_CORRUPTED,
	ACTIVATION_BAD_CODE,
	ACTIVATION_ALREADY_USED,
	ACTIVATION_SERIAL_UNKNOWN,
	ACTIVATION_EXPIRED,
	ACTIVATION_NOT_AVAILABLE
};

VMP_IMPORT int VMP_API VMProtectActivateLicense(const char *code, char *serial, int size);
VMP_IMPORT int VMP_API VMProtectDeactivateLicense(const char *serial);
VMP_IMPORT int VMP_API VMProtectGetOfflineActivationString(const char *code, char *buf, int size);
VMP_IMPORT int VMP_API VMProtectGetOfflineDeactivationString(const char *serial, char *buf, int size);

#ifdef __cplusplus
}
#endif

```

`GameOverlayUIHook/dllmain.cpp`:

```cpp
#include <windows.h>
#include <iostream>
#include <tlhelp32.h>
#include "VMProtectSDK.h"
#pragma comment(lib,"VMProtectSDK32.lib")
#include "obfuscation.h"
using namespace std;
#include "SDK.h"
//#include "breakpoint.h"

__forceinline void SMKOZGZ070P8()
{
	//junkcode
	int D2H4DJESOA7CJ = 251367161;
	if (D2H4DJESOA7CJ > 251367154)
		D2H4DJESOA7CJ = 251367128;
	else if (D2H4DJESOA7CJ <= 251367168)
		D2H4DJESOA7CJ++;
	else
		D2H4DJESOA7CJ = (251367179 / 251367166);
	bool DG6SK98740CKP = true;
	if (!DG6SK98740CKP)
		DG6SK98740CKP = true;
	else if (DG6SK98740CKP = true)
		DG6SK98740CKP = true;
	else
		DG6SK98740CKP = true;
	bool D16R2A4ZA5WKR = false;
	if (!D16R2A4ZA5WKR)
		D16R2A4ZA5WKR = true;
	else if (D16R2A4ZA5WKR = true)
		D16R2A4ZA5WKR = true;
	else
		D16R2A4ZA5WKR = true;
	int DDSES5C3IXB0B = 251367187;
	if (DDSES5C3IXB0B > 251367118)
		DDSES5C3IXB0B = 251367108;
	else if (DDSES5C3IXB0B <= 251367123)
		DDSES5C3IXB0B++;
	else
		DDSES5C3IXB0B = (251367110 / 251367107);
	int DJD55RON4Y04R = 251367109;
	if (DJD55RON4Y04R > 251367194)
		DJD55RON4Y04R = 251367155;
	else if (DJD55RON4Y04R <= 251367133)
		DJD55RON4Y04R++;
	else
		DJD55RON4Y04R = (251367117 / 251367112);
	bool D9L8D16I270S3 = true;
	if (!D9L8D16I270S3)
		D9L8D16I270S3 = false;
	else if (D9L8D16I270S3 = true)
		D9L8D16I270S3 = true;
	else
		D9L8D16I270S3 = true;
	bool DBA11L04RS4HA = false;
	if (!DBA11L04RS4HA)
		DBA11L04RS4HA = false;
	else if (DBA11L04RS4HA = true)
		DBA11L04RS4HA = false;
	else
		DBA11L04RS4HA = false;
	bool D8YI6PBH70M7H = true;
	if (!D8YI6PBH70M7H)
		D8YI6PBH70M7H = false;
	else if (D8YI6PBH70M7H = true)
		D8YI6PBH70M7H = true;
	else
		D8YI6PBH70M7H = true;
	int D93IEQGCBJP4L = 251367116;
	if (D93IEQGCBJP4L > 251367193)
		D93IEQGCBJP4L = 251367102;
	else if (D93IEQGCBJP4L <= 251367125)
		D93IEQGCBJP4L++;
	else
		D93IEQGCBJP4L = (251367157 / 251367177);
	bool DF5BGNPC2HYZY = true;
	if (!DF5BGNPC2HYZY)
		DF5BGNPC2HYZY = true;
	else if (DF5BGNPC2HYZY = false)
		DF5BGNPC2HYZY = true;
	else
		DF5BGNPC2HYZY = true;
	bool D2WM5I40F5N7G = true;
	if (!D2WM5I40F5N7G)
		D2WM5I40F5N7G = true;
	else if (D2WM5I40F5N7G = true)
		D2WM5I40F5N7G = false;
	else
		D2WM5I40F5N7G = true;
	int DHHY670IZGMSZ = 251367112;
	if (DHHY670IZGMSZ > 251367160)
		DHHY670IZGMSZ = 251367166;
	else if (DHHY670IZGMSZ <= 251367162)
		DHHY670IZGMSZ++;
	else
		DHHY670IZGMSZ = (251367195 / 251367179);
	int DOSOO6KDSJ525 = 251367155;
	if (DOSOO6KDSJ525 > 251367143)
		DOSOO6KDSJ525 = 251367140;
	else if (DOSOO6KDSJ525 <= 251367191)
		DOSOO6KDSJ525++;
	else
		DOSOO6KDSJ525 = (251367160 / 251367183);
	bool D3GPX093G35EQ = true;
	if (!D3GPX093G35EQ)
		D3GPX093G35EQ = true;
	else if (D3GPX093G35EQ = true)
		D3GPX093G35EQ = false;
	else
		D3GPX093G35EQ = false;
	bool DGELE95I8DP95 = false;
	if (!DGELE95I8DP95)
		DGELE95I8DP95 = false;
	else if (DGELE95I8DP95 = true)
		DGELE95I8DP95 = false;
	else
		DGELE95I8DP95 = true;
	int DGCEZXPN9FKIS = 251367129;
	if (DGCEZXPN9FKIS > 251367167)
		DGCEZXPN9FKIS = 251367193;
	else if (DGCEZXPN9FKIS <= 251367155)
		DGCEZXPN9FKIS++;
	else
		DGCEZXPN9FKIS = (251367119 / 251367167);
	int D09KC604Z9GOC = 251367136;
	if (D09KC604Z9GOC > 251367112)
		D09KC604Z9GOC = 251367143;
	else if (D09KC604Z9GOC <= 251367131)
		D09KC604Z9GOC++;
	else
		D09KC604Z9GOC = (251367177 / 251367135);
	bool D7MKKCJ7OE5CW = true;
	if (!D7MKKCJ7OE5CW)
		D7MKKCJ7OE5CW = false;
	else if (D7MKKCJ7OE5CW = true)
		D7MKKCJ7OE5CW = false;
	else
		D7MKKCJ7OE5CW = true;
	bool DE78OSX4PF3X6 = false;
	if (!DE78OSX4PF3X6)
		DE78OSX4PF3X6 = true;
	else if (DE78OSX4PF3X6 = false)
		DE78OSX4PF3X6 = true;
	else
		DE78OSX4PF3X6 = false;
	int DG2H1W3M9CMGE = 251367122;
	if (DG2H1W3M9CMGE > 251367129)
		DG2H1W3M9CMGE = 251367171;
	else if (DG2H1W3M9CMGE <= 251367176)
		DG2H1W3M9CMGE++;
	else
		DG2H1W3M9CMGE = (251367125 / 251367192);
	bool DALD5LWQZ09AE = false;
	if (!DALD5LWQZ09AE)
		DALD5LWQZ09AE = true;
	else if (DALD5LWQZ09AE = false)
		DALD5LWQZ09AE = true;
	else
		DALD5LWQZ09AE = false;
	bool DC2JQWRCERB0P = true;
	if (!DC2JQWRCERB0P)
		DC2JQWRCERB0P = true;
	else if (DC2JQWRCERB0P = false)
		DC2JQWRCERB0P = true;
	else
		DC2JQWRCERB0P = false;
	int DRXHCRLWNISB8 = 251367190;
	if (DRXHCRLWNISB8 > 251367107)
		DRXHCRLWNISB8 = 251367188;
	else if (DRXHCRLWNISB8 <= 251367160)
		DRXHCRLWNISB8++;
	else
		DRXHCRLWNISB8 = (251367134 / 251367163);
	int DNQ0H7PF1G1FA = 251367170;
	if (DNQ0H7PF1G1FA > 251367126)
		DNQ0H7PF1G1FA = 251367154;
	else if (DNQ0H7PF1G1FA <= 251367146)
		DNQ0H7PF1G1FA++;
	else
		DNQ0H7PF1G1FA = (251367126 / 251367101);
	bool D55H41HJE700J = false;
	if (!D55H41HJE700J)
		D55H41HJE700J = true;
	else if (D55H41HJE700J = true)
		D55H41HJE700J = true;
	else
		D55H41HJE700J = true;
	int D4ZKM96EG7EN0 = 251367178;
	if (D4ZKM96EG7EN0 > 251367160)
		D4ZKM96EG7EN0 = 251367129;
	else if (D4ZKM96EG7EN0 <= 251367175)
		D4ZKM96EG7EN0++;
	else
		D4ZKM96EG7EN0 = (251367195 / 251367186);
	bool D6CZ693M604QP = true;
	if (!D6CZ693M604QP)
		D6CZ693M604QP = true;
	else if (D6CZ693M604QP = false)
		D6CZ693M604QP = true;
	else
		D6CZ693M604QP = true;
	bool DIG4SR0I5E3FN = true;
	if (!DIG4SR0I5E3FN)
		DIG4SR0I5E3FN = false;
	else if (DIG4SR0I5E3FN = true)
		DIG4SR0I5E3FN = false;
	else
		DIG4SR0I5E3FN = true;
	int DAR13LN9XH2CO = 251367111;
	if (DAR13LN9XH2CO > 251367194)
		DAR13LN9XH2CO = 251367131;
	else if (DAR13LN9XH2CO <= 251367176)
		DAR13LN9XH2CO++;
	else
		DAR13LN9XH2CO = (251367131 / 251367178);
	int DFHM2833G8RWY = 251367111;
	if (DFHM2833G8RWY > 251367147)
		DFHM2833G8RWY = 251367125;
	else if (DFHM2833G8RWY <= 251367124)
		DFHM2833G8RWY++;
	else
		DFHM2833G8RWY = (251367104 / 251367197);
	int DJ5M0EMKW0GXP = 251367171;
	if (DJ5M0EMKW0GXP > 251367115)
		DJ5M0EMKW0GXP = 251367153;
	else if (DJ5M0EMKW0GXP <= 251367193)
		DJ5M0EMKW0GXP++;
	else
		DJ5M0EMKW0GXP = (251367157 / 251367153);
	bool DJMPPX18D4KX6 = true;
	if (!DJMPPX18D4KX6)
		DJMPPX18D4KX6 = true;
	else if (DJMPPX18D4KX6 = true)
		DJMPPX18D4KX6 = true;
	else
		DJMPPX18D4KX6 = false;
}

ISetup* g_pSetup = NULL;
ISurface* g_pSerializedSurface = NULL;
ISurface039* p_ISurface039 = NULL;
IPanel* g_pPanel = NULL;
IInputInternal* g_pIInput = NULL;
typedef void(__stdcall* PaintTraverse_t)(VPANEL panel);
PaintTraverse_t pPaintTraverse = NULL;
DWORD TableAddr;
LPVOID exposeCache;
LPVOID internalCache;
LPVOID informationCache;
HANDLE g_dwMainThread;
HANDLE hFile;
LPTSTR hText;

typedef struct drawType_FilledRect
{
	short int x;
	short int y;
	short int width;
	short int height;
	BYTE r, g, b, a;
};
typedef struct drawType_OutlinedRect
{
	short int x;
	short int y;
	short int width;
	short int height;
	BYTE r, g, b, a;
};
typedef struct drawType_Line
{
	short int x1;
	short int y1;
	short int x2;
	short int y2;
	BYTE r, g, b, a;
};
typedef struct drawType_Circle
{
	short int x;
	short int y;
	short int radius;
	BYTE r, g, b, a;
};
typedef struct drawType_Text
{
	short int x;
	short int y;
	BYTE fonttype;
	BYTE r, g, b, a;
};
void d2l_Bresenham(int p1_x, int p1_y, int p2_x, int p2_y, int r, int g, int b, int a)
{
	int dx = p2_x - p1_x;
	int dy = p2_y - p1_y;
	int ux = ((dx > 0) << 1) - 1;
	int uy = ((dy > 0) << 1) - 1;
	int x = p1_x, y = p1_y, eps;
	int p_x;
	int p_y;
	eps = 0;
	dx = abs(dx);
	dy = abs(dy);
	if (dx > dy) {
		for (x = p1_x; x != p2_x; x += ux) {
			p_x = x;
			p_y = y;
			p_ISurface039->DrawSetColor002(r, g, b, a);
			p_ISurface039->DrawFilledRect(p_x, p_y, p_x + 1, p_y + 1);
			eps += dy;
			if ((eps << 1) >= dx) {
				y += uy;
				eps -= dx;
			}
		}
	}
	else {
		for (y = p1_y; y != p2_y; y += uy) {
			p_x = x;
			p_y = y;
			p_ISurface039->DrawSetColor002(r, g, b, a);
			p_ISurface039->DrawFilledRect(p_x, p_y, p_x + 1, p_y + 1);
			eps += dx;
			if ((eps << 1) >= dy) {
				x += ux;
				eps -= dy;
			}
		}
	}
}
void draw_circle_8(int xc, int yc, int x, int y, int r, int g, int b, int a)
{
	p_ISurface039->DrawSetColor002(r, g, b, a);
	p_ISurface039->DrawFilledRect(xc + x, yc + y, xc + x + 1, yc + y + 1);
	p_ISurface039->DrawSetColor002(r, g, b, a);
	p_ISurface039->DrawFilledRect(xc - x, yc + y, xc - x + 1, yc + y + 1);
	p_ISurface039->DrawSetColor002(r, g, b, a);
	p_ISurface039->DrawFilledRect(xc + x, yc - y, xc + x + 1, yc - y + 1);
	p_ISurface039->DrawSetColor002(r, g, b, a);
	p_ISurface039->DrawFilledRect(xc - x, yc - y, xc - x + 1, yc - y + 1);
	p_ISurface039->DrawSetColor002(r, g, b, a);
	p_ISurface039->DrawFilledRect(xc + y, yc + x, xc + y + 1, yc + x + 1);
	p_ISurface039->DrawSetColor002(r, g, b, a);
	p_ISurface039->DrawFilledRect(xc - y, yc + x, xc - y + 1, yc + x + 1);
	p_ISurface039->DrawSetColor002(r, g, b, a);
	p_ISurface039->DrawFilledRect(xc + y, yc - x, xc + y + 1, yc - x + 1);
	p_ISurface039->DrawSetColor002(r, g, b, a);
	p_ISurface039->DrawFilledRect(xc - y, yc - x, xc - y + 1, yc - x + 1);
}
void d2c_Bresenham(int xc, int yc, int radius, int fill, int r, int g, int b, int a)
{
	int x = 0, y = radius, yi, d;
	d = 3 - 2 * radius;
	if (fill) 
	{
		while (x <= y) {
			for (yi = x; yi <= y; yi++)
				draw_circle_8(xc, yc, x, yi, r, g, b, a);

			if (d < 0) {
				d = d + 4 * x + 6;
			}
			else {
				d = d + 4 * (x - y) + 10;
				y--;
			}
			x++;
		}
	}
	else 
	{
		while (x <= y) {
			draw_circle_8(xc, yc, x, y, r, g, b, a);
			if (d < 0) {
				d = d + 4 * x + 6;
			}
			else {
				d = d + 4 * (x - y) + 10;
				y--;
			}
			x++;
		}
	}
}
int Fps()
{
	static int fps = 0;
	static int lastTime = GetTickCount();// ms
	static int frameCount = 0;
	++frameCount;
	int curTime = GetTickCount();
	if (curTime - lastTime > 1000)
	{
		fps = frameCount;
		frameCount = 0;
		lastTime = curTime;
	}
	return fps;
}
void __stdcall RenderScreen(VPANEL panel)
{
	SMKOZGZ070P8();
	if (!_stricmp(g_pPanel->GetName(panel), XorString("BaseDashboardPanel")) && *(DWORD*)TableAddr == 0 && *(DWORD*)(TableAddr + 4) == 0)
	{
		int width, height;
		g_pPanel->GetSize(panel, width, height);
		*(DWORD*)((DWORD)informationCache + 4) = width;
		*(DWORD*)((DWORD)informationCache + 8) = height;

		memcpy(internalCache, exposeCache, 0x10000);
		DWORD itemcount = *(DWORD*)internalCache;

		int currentposition = 4;
		for (int i = 0; i < itemcount; i++)
		{
			BYTE itemlength = *(BYTE*)((DWORD)internalCache + currentposition);
			BYTE itemtype = *(BYTE*)((DWORD)internalCache + currentposition + 1);
			if (itemtype == 1)
			{
				drawType_FilledRect item;
				memcpy(&item, (LPVOID)((DWORD)internalCache + currentposition + 2), itemlength);
				p_ISurface039->DrawSetColor002(item.r, item.g, item.b, item.a);
				p_ISurface039->DrawFilledRect(item.x, item.y, item.x + item.width, item.y + item.height);
			}
			else if (itemtype == 2)
			{
				drawType_OutlinedRect item;
				memcpy(&item, (LPVOID)((DWORD)internalCache + currentposition + 2), itemlength);
				p_ISurface039->DrawSetColor002(item.r, item.g, item.b, item.a);
				p_ISurface039->DrawOutlinedRect(item.x, item.y, item.x + item.width, item.y + item.height);
			}
			else if (itemtype == 3)
			{
				drawType_Line item;
				memcpy(&item, (LPVOID)((DWORD)internalCache + currentposition + 2), itemlength);
				d2l_Bresenham(item.x1, item.y1, item.x2, item.y2, item.r, item.g, item.b, item.a);
			}
			else if (itemtype == 4)
			{
				drawType_Circle item;
				memcpy(&item, (LPVOID)((DWORD)internalCache + currentposition + 2), itemlength);
				d2c_Bresenham(item.x, item.y, item.radius, 0, item.r, item.g, item.b, item.a);
			}
			else if (itemtype == 5)
			{
				drawType_Text item;
				memcpy(&item, (LPVOID)((DWORD)internalCache + currentposition + 2), itemlength);
				wchar_t szText[255];
				memcpy(&szText, (LPVOID)((DWORD)internalCache + currentposition + 13), itemlength - sizeof(drawType_Text));

				p_ISurface039->DrawSetTextColor002(0, 0, 0, item.a);
				p_ISurface039->DrawSetTextFont(item.fonttype);
				p_ISurface039->DrawSetTextPos(item.x + 1, item.y);
				p_ISurface039->DrawPrintText(szText, (int)wcslen(szText), FONT_DRAW_DEFAULT);

				p_ISurface039->DrawSetTextColor002(0, 0, 0, item.a);
				p_ISurface039->DrawSetTextFont(item.fonttype);
				p_ISurface039->DrawSetTextPos(item.x - 1, item.y);
				p_ISurface039->DrawPrintText(szText, (int)wcslen(szText), FONT_DRAW_DEFAULT);

				p_ISurface039->DrawSetTextColor002(0, 0, 0, item.a);
				p_ISurface039->DrawSetTextFont(item.fonttype);
				p_ISurface039->DrawSetTextPos(item.x, item.y + 1);
				p_ISurface039->DrawPrintText(szText, (int)wcslen(szText), FONT_DRAW_DEFAULT);

				p_ISurface039->DrawSetTextColor002(0, 0, 0, item.a);
				p_ISurface039->DrawSetTextFont(item.fonttype);
				p_ISurface039->DrawSetTextPos(item.x, item.y - 1);
				p_ISurface039->DrawPrintText(szText, (int)wcslen(szText), FONT_DRAW_DEFAULT);

				p_ISurface039->DrawSetTextColor002(item.r, item.g, item.b, item.a);
				p_ISurface039->DrawSetTextFont(item.fonttype);
				p_ISurface039->DrawSetTextPos(item.x, item.y);
				p_ISurface039->DrawPrintText(szText, (int)wcslen(szText), FONT_DRAW_DEFAULT);
			}
			currentposition += (itemlength + 2);
		}

		p_ISurface039->DrawSetTextColor002(0, 255, 0, 255);
		p_ISurface039->DrawSetTextFont(13);
		p_ISurface039->DrawSetTextPos(0, 0);

		wchar_t szText[255];
		int Framerate = Fps();
		wsprintfW(szText, XorStringW(L"FPS:%d"), Framerate < 99 ? Framerate : 99);
		p_ISurface039->DrawPrintText(szText, (int)wcslen(szText), FONT_DRAW_DEFAULT);
		//example
		p_ISurface039->DrawSetColor002(255, 255, 255, 255);
		p_ISurface039->DrawFilledRect(200, 200, 400, 400);//render rect

		p_ISurface039->DrawSetColor002(255, 0, 0, 255);
		p_ISurface039->DrawOutlinedRect(400, 400, 450, 450);//render outlined rect

		d2l_Bresenham(400, 400, 450, 450, 255, 255, 0, 255);//bresenham line

		p_ISurface039->DrawSetTextColor002(0, 255, 0, 255);
		p_ISurface039->DrawSetTextFont(13);
		p_ISurface039->DrawSetTextPos(500, 500);
		p_ISurface039->DrawPrintText(XorStringW(L"Abc123?!"), (int)wcslen(XorStringW(L"Abc123?!")), FONT_DRAW_DEFAULT);//render text
	}
	char str[255] = { 0 };
	sprintf(str, XorString("%d,%d"), exposeCache, informationCache);
	CopyMemory(hText, str, sizeof(str));//expose to process
}
void __stdcall new_PaintTraverse(VPANEL panel)
{
	_asm push ecx;
	//Pre-Render
	_asm pop ecx;
	pPaintTraverse(panel);
	_asm pushad;
	//Post-Render
	RenderScreen(panel);
	_asm popad;
}
bool DataCompare(const BYTE* pData, const BYTE* bMask, const char* szMask)
{
	for (; *szMask; ++szMask, ++pData, ++bMask)
		if (*szMask == 'x' && *pData != *bMask)
			return false;
	return (*szMask) == NULL;
}
DWORD FindPattern(DWORD dwAddress, DWORD dwLen, BYTE *bMask, char * szMask)
{
	for (DWORD i = 0; i < dwLen; i++)
		if (DataCompare((BYTE*)(dwAddress + i), bMask, szMask))
			return (DWORD)(dwAddress + i);

	return 0;
}
DWORD WINAPI lpMainThread(LPVOID lpParam)
{
	VMProtectBegin(__FUNCTION__);
	SMKOZGZ070P8();
	HMODULE hModule = (HMODULE)lpParam;
	//printf("[*] GameOverlayHook\n");
	HMODULE hVGUI = NULL;
	while (hVGUI == NULL)
	{
		hVGUI = GetModuleHandleA(XorString("vgui2_s.dll"));
		Sleep(100);
	}
	//printf("[*] hVGUI = %p\n", hVGUI);
	HMODULE hGAME = NULL;
	while (hGAME == NULL)
	{
		hGAME = GetModuleHandleA(XorString("gameoverlayui.dll"));
		Sleep(100);
	}
	//printf("[*] hGAME = %p\n", hGAME);
	TableAddr = *(DWORD*)(FindPattern((DWORD)hVGUI, 0x10000, (BYTE*)"\x8B\x45\x08\xA3\x00\x00\x00\x00\x8B\x45\x0C\xA3\x00\x00\x00\x00\x8B\x45\x10\xA3\x00\x00\x00\x00\x8B\x45\x14\xA3", "xxxx????xxxx????xxxx????xxxx") + 4);
	//printf("[*] TableAddr = %p\n", TableAddr);
	CreateInterfaceFn VGUIInterface = NULL;
	while (VGUIInterface == NULL)
	{
		VGUIInterface = (CreateInterfaceFn)GetProcAddress(hVGUI, XorString("CreateInterface"));
		Sleep(100);
	}
	//printf("[*] VGUIInterface = %p\n", VGUIInterface);
	while (g_pSetup == NULL)
	{
		g_pSetup = (ISetup*)VGUIInterface(XorString("VGUI_Setup001"), NULL);
		Sleep(100);
	}
	//printf("[*] g_pSetup = %p\n", g_pSetup);
	while (g_pPanel == NULL)
	{
		g_pPanel = (IPanel*)VGUIInterface(XorString("VGUI_Panel010"), NULL);
	}
	//printf("[*] g_pPanel = %p\n", g_pPanel);
	while (g_pIInput == NULL)
	{
		g_pIInput = (IInputInternal*)VGUIInterface(XorString("VGUI_InputInternal001"), NULL);
	}
	//printf("[*] g_pIInput = %p\n", g_pIInput);

	while (g_pSerializedSurface == NULL)
	{
		g_pSerializedSurface = (ISurface*)*(DWORD*)g_pSetup->CreateSurfaceInterface(XorString("VGUI_Surface039"));
		p_ISurface039 = reinterpret_cast<ISurface039*>(g_pSetup->CreateSurfaceInterface(XorString("VGUI_Surface039")));
		//printf("[*] p_ISurface039 = %p\n", p_ISurface039);
		Sleep(100);
	}
	//printf("[*] g_pSerializedSurface = %p\n", g_pSerializedSurface);

	exposeCache = VirtualAlloc(NULL, 0x10000, MEM_COMMIT, PAGE_EXECUTE_READWRITE);//this memory pool is for communication
	//printf("[*] exposeCache = %p\n", exposeCache);
	internalCache = VirtualAlloc(NULL, 0x10000, MEM_COMMIT, PAGE_EXECUTE_READWRITE);//sync for all render command
	//printf("[*] internalCache = %p\n", internalCache);
	informationCache = VirtualAlloc(NULL, 0x1024, MEM_COMMIT, PAGE_EXECUTE_READWRITE);//other process can reading this memory to query info
	//printf("[*] informationCache = %p\n", informationCache);
	*(DWORD*)((DWORD)informationCache) = 1;

	pPaintTraverse = (PaintTraverse_t) *(DWORD*)((DWORD)g_pSerializedSurface + 0x1A4);

	MEMORY_BASIC_INFORMATION mbi;
	VirtualQuery((LPCVOID)pPaintTraverse, &mbi, sizeof(mbi));
	VirtualProtect(mbi.BaseAddress, mbi.RegionSize, PAGE_EXECUTE_READWRITE, &mbi.Protect);
	BYTE Payload[] = { 0xB8,0x00,0x00,0x00,0x00,0xFF,0xE0 };
	*(DWORD*)(Payload + 1) = (DWORD)new_PaintTraverse;
	memcpy((void*)((DWORD)pPaintTraverse + 0x39), Payload, sizeof(Payload));
	VirtualProtect(mbi.BaseAddress, mbi.RegionSize, mbi.Protect, &mbi.Protect);

	VirtualQuery((LPCVOID)((DWORD)g_pSerializedSurface), &mbi, sizeof(mbi));
	VirtualProtect(mbi.BaseAddress, mbi.RegionSize, PAGE_EXECUTE_READWRITE, &mbi.Protect);

	//printf("[*] pPaintTraverse = %p\n", pPaintTraverse);
	*(DWORD*)((DWORD)g_pSerializedSurface + 0x1A4) = (DWORD)pPaintTraverse + 0x39;

	//breakpoints_s bplist;//setting bp
	//MODIFY_BREAKPOINT(0, *(DWORD*)((DWORD)g_pSerializedSurface + 0x1A4), new_PaintTraverse);
	//bplist.hThread = g_dwMainThread;
	//bpInitialize(&bplist);
	//bpSetHooks();

	VirtualProtect(mbi.BaseAddress, mbi.RegionSize, mbi.Protect, &mbi.Protect);
	//printf("[*] Hooked!\n");
	return 0;
	VMProtectEnd();
}
void GetMainThread()
{
	THREADENTRY32 te = { sizeof(THREADENTRY32) };
	HANDLE handleSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
	if (INVALID_HANDLE_VALUE == handleSnap)
		return;
	if (Thread32First(handleSnap, &te)) {
		do {
			if (te.th32OwnerProcessID == GetCurrentProcessId()) {
				g_dwMainThread = OpenThread(THREAD_ALL_ACCESS, FALSE, te.th32ThreadID);
				break;
			}
		} while (Thread32Next(handleSnap, &te));
	}
	CloseHandle(handleSnap);
}
BOOL APIENTRY DllMain(HMODULE hModule, DWORD dwReason, LPVOID lpReserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		//AllocConsole();
		//freopen("CONOUT$", "w", stdout);
		//GetMainThread();
		hFile = CreateFileMappingA(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, 1024, XorString("CreateInterface"));//create a communication
		if (hFile != NULL)
			hText = (LPTSTR)MapViewOfFile(hFile, FILE_MAP_ALL_ACCESS, 0, 0, 0);
		if (hText == NULL)
		{
			CloseHandle(hFile);
			UnmapViewOfFile(hText);
			exit(0);
		}
		CreateThread(0, 0, lpMainThread, hModule, 0, 0);
	}
	return TRUE;
}
```

`GameOverlayUIHook/obfuscation.h`:

```h
#pragma once
#ifndef OBFS_STRING_FUNC
#define OBFS_STRING_FUNC
#include <stdint.h>

//-------------------------------------------------------------//
// "Malware related compile-time hacks with C++11" by LeFF   //
// You can use this code however you like, I just don't really //
// give a shit, but if you feel some respect for me, please //
// don't cut off this comment when copy-pasting... ;-)       //
//-------------------------------------------------------------//

////////////////////////////////////////////////////////////////////
template <int X> struct EnsureCompileTime {
	enum : int {
		Value = X
	};
};
////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////
//Use Compile-Time as Myseed
#define Myseed ((__TIME__[7] - '0') * 1  + (__TIME__[6] - '0') * 10  + \
                  (__TIME__[4] - '0') * 60   + (__TIME__[3] - '0') * 600 + \
                  (__TIME__[1] - '0') * 3600 + (__TIME__[0] - '0') * 36000)
////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////
constexpr int LinearCongruentGenerator(int Rounds) {
	return 1013904223 + 1664525 * ((Rounds> 0) ? LinearCongruentGenerator(Rounds - 1) : Myseed & 0xFFFFFFFF);
}
#define Random() EnsureCompileTime<LinearCongruentGenerator(10)>::Value //10 Rounds
#define RandomNumber(Min, Max) (Min + (Random() % (Max - Min + 1)))
////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////
template <int... Pack> struct IndexList {};
////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////
template <typename IndexList, int Right> struct Append;
template <int... Left, int Right> struct Append<IndexList<Left...>, Right> {
	typedef IndexList<Left..., Right> Result;
};
////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////
template <int N> struct ConstructIndexList {
	typedef typename Append<typename ConstructIndexList<N - 1>::Result, N - 1>::Result Result;
};
template <> struct ConstructIndexList<0> {
	typedef IndexList<> Result;
};
////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////
const char XORKEY = static_cast<char>(RandomNumber(0, 0xFF));
__forceinline constexpr char EncryptCharacter(const char Character, int Index) {
	return Character ^ (XORKEY + Index);
}
template <typename IndexList> class CXorString;
template <int... Index> class CXorString<IndexList<Index...> > {
private:
	char Value[sizeof...(Index)+1];
public:
	__forceinline constexpr CXorString(const char* const String)
		: Value{ EncryptCharacter(String[Index], Index)... } {}

	__forceinline char* decrypt() {
		for (int t = 0; t < sizeof...(Index); t++) {
			Value[t] = Value[t] ^ (XORKEY + t);
		}
		Value[sizeof...(Index)] = '\0';
		return Value;
	}

	__forceinline char* get() {
		return Value;
	}
};

const wchar_t XORKEYW = static_cast<wchar_t>(RandomNumber(0, 0xFFFF));
__forceinline constexpr wchar_t EncryptCharacterW(const wchar_t Character, int Index) {
	return Character ^ (XORKEYW + Index);
}
template <typename IndexList> class CXorStringW;
template <int... Index> class CXorStringW<IndexList<Index...> > {
private:
	wchar_t Value[sizeof...(Index)+1];
public:
	__forceinline constexpr CXorStringW(const wchar_t* const String)
		: Value{ EncryptCharacterW(String[Index], Index)... } {}

	__forceinline wchar_t* decrypt() {
		for (int t = 0; t < sizeof...(Index); t++) {
			Value[t] = Value[t] ^ (XORKEYW + t);
		}
		Value[sizeof...(Index)] = '\0';
		return Value;
	}

	__forceinline wchar_t* get() {
		return Value;
	}
};

#define XorS(X, String) CXorString<ConstructIndexList<sizeof(String)-1>::Result> X(String)
#define XorString( String ) ( CXorString<ConstructIndexList<sizeof( String ) - 1>::Result>( String ).decrypt() )
#define XorSW(X, String) CXorStringW<ConstructIndexList<sizeof(String)-1>::Result> X(String)
#define XorStringW( String ) ( CXorStringW<ConstructIndexList<sizeof( String ) - 1>::Result>( String ).decrypt() )
////////////////////////////////////////////////////////////////////
#endif
```

`README.md`:

```md
# steam game overlay (GameOverlayUI.exe) hook example⚡

## vgui2.dll hook example

use any usermode injector to inject into gameoverlayui. then using memory share to render your items.

## screenshot
![demo](https://i.loli.net/2020/03/27/5HgNOzxLbwKks6M.png)

## NOTE

1. hook VGUI_Surface039->**PaintTraverse** to render on screen.

2. source is building on **Visual Studio 2017 Release x86**. not sure about other platform.

3. alloc a free memory to create a shared memory field for communication.

4. the original steam overlay are not support DrawLine or DrawOutlinedCircle and some functions, so in this source DrawLine and **DrawCircle** is based on **DrawFilledRect**.(Bresenham algorithm)

5. do not using too much draw-functions in one loop maybe cause GameOverlayUI.exe crash.

## inject a specific game

1.  on usermode inject `GameOverlayUIHook.dll` from directory `\Release` to `GameOverlayUI.exe`.

## todo
1.  is this can bypass BE/EAC anti-cheat system? the answer is: idk.

2.  this is an example. there are lots of ways to achieve hook PaintTraverse. using veh or other virtual table.

```