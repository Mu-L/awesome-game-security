Project Path: arc_igozdev_xorlit_f5odk732

Source Tree:

```txt
arc_igozdev_xorlit_f5odk732
├── LICENSE
├── README.md
└── include
    └── xorlit.hpp

```

`LICENSE`:

```
MIT License

Copyright (c) 2023 igozdev

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# xorlit
> Compile time string literal encryptor for C++.

[![license][badge.license]][license]
[![release][badge.release]][release]
[![godbolt][badge.godbolt]][godbolt]

[badge.license]: https://img.shields.io/badge/license-mit-green.svg
[license]: https://github.com/igozdev/xorlit/blob/main/LICENSE
[badge.release]: https://img.shields.io/github/release/igozdev/xorlit.svg
[release]: https://github.com/igozdev/xorlit/releases/latest
[badge.godbolt]: https://img.shields.io/badge/try_it-on_godbolt-indigo.svg
[godbolt]: https://godbolt.org/z/Ksd36MMo7

* [Usage](#usage)
* [Example](#example)

# Usage
## XORLIT
The `XORLIT` macro can be used to create an encrypted string which evaluates to its original contents (e.g. `XORLIT("foo")` would evalute as the string "foo", but be stored as some other encrypted value). As it wraps `xorlit::make_str`, one can pass either one argument, a string literal, or two arguments, a string literal and a key. In the case that one argument is passed, the key used will default to `xorlit::seed`.
> [!WARNING]
> Exercise caution when using `XORLIT`, `xorlit::make_str(__VA_ARGS__).rexor()`, or `xorlit::string`s in any context where they are not explicitly stored, as some compilers, such as MSVC, may sporadically encrypt strings non-constexpr-ly depending on the string literal's content or the context of its usage. It may be advisable to search binary contents for any unencrypted string literals in this case.

## xorlit::seed
`xorlit::seed` is a `constexpr std::uint_least32_t` which is based on the predefined `__TIME__` macro to generate values. It is the default value used by `xorlit::make_str` and by extension `XORLIT` for the key. Since `xorlit::seed` or `static_cast<char>(xorlit::seed)` may evaluate to 0, which, in such a case, would lead to an unencrypted string, by defining `XORLIT_SEED_STATIC_ASSERT` before including the `xorlit.hpp` header, a static assertion by the compiler will be enabled to check if `xorlit::seed` is equal to 0.

## xorlit::string
`xorlit::string` is the provided type for storing encrypted strings. A `xorlit::string` should always be decorated with the `constexpr` specifier to ensure it is stored in its encrypted form. 
`xorlit::string` defines the following member functions:
* `xorlit::string::rexor()`: xors the data of the string and returns it.
* `xorlit::string::xor_data()`: returns a new `const char*` with a copy of the string's data xored.
* `xorlit::string::data`: returns the data stored in the string. `const` and non-`const` variants are provided.
* `xorlit::string::key`: returns the key stored in the string.
> [!IMPORTANT]
> Results of `xorlit::string::xor_data()` must be managed manually, whether that be via `delete`, smart pointers, etc.

# Example
```c++
#include <string>
#include <iostream>
#include <format>
#define XORLIT_SEED_STATIC_ASSERT // enable compiler check if xorlit::seed is 0
#include <xorlit.hpp>

int main()
{
    std::cout
        << XORLIT("Default, xorlit::seed is passed as the key\n")
        << XORLIT("Or you can use xorlit::seed yourself\n", xorlit::seed + __LINE__) // when passing your own seeds, you should check that they aren't 0
        << XORLIT("Or you can choose your own key\n", 12) << std::endl;

    constexpr auto s = xorlit::make_str("You can manually store a xorlit::string"); // always declare the results of xorlit::make_str constexpr
    const std::string raw(s.data(), decltype(s)::size);
    const char* original_data = s.xor_data(); // results of xorlit::string::xor_data must be manually managed, smart pointers are recommended
    const std::string original(original_data, decltype(s)::size);
    delete[] original_data;
    std::cout << std::format("Raw: {}\nOriginal: {}", raw, original) << std::endl;
}

////////////////// Possible output: //////////////////
// Default, xorlit::seed is passed as the key
// Or you can use xorlit::seed yourself
// Or you can choose your own seed
//
// Raw:    ?%p31>p=1>%1<<)p#$?"5p1p(?"<9$jj#$"9>7P
// Original: You can manually store a xorlit::string
```

```

`include/xorlit.hpp`:

```hpp
/*
* MIT License
*
* Copyright (c) 2023 igozdev
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in all
* copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
* SOFTWARE.
*/

#pragma once

#include <cstdint>
#include <cstddef>

namespace xorlit
{
	constexpr std::uint_least32_t seed =
		static_cast<std::uint_least32_t>(__TIME__[0] - '0') |
		static_cast<std::uint_least32_t>(__TIME__[1] - '0') << 4 |
		static_cast<std::uint_least32_t>(__TIME__[3] - '0') << 8 |
		static_cast<std::uint_least32_t>(__TIME__[4] - '0') << 12 |
		static_cast<std::uint_least32_t>(__TIME__[6] - '0') << 16 |
		static_cast<std::uint_least32_t>(__TIME__[7] - '0') << 20;
#if defined(XORLIT_SEED_STATIC_ASSERT)
	#if defined(__cpp_static_assert) && __cpp_static_assert >= 200410L
	static_assert(static_cast<char>(seed) != 0, "xorlit::seed acts as zero! Default usage of xorlit::make_str will result in an unchanged string!");
	#endif
#endif

	template <std::size_t I>
#if defined(_MSC_VER)
	__forceinline
#else
	__attribute__((always_inline))
#endif
	constexpr void xor_str(char* d, char key, const char* s)
	{
		d[I] = s[I] ^ key;
		xor_str<I - 1>(d, key, s);
	}
	template <>
#if defined(_MSC_VER)
	__forceinline
#else
	__attribute__((always_inline))
#endif
	constexpr void xor_str<0>(char* d, char key, const char* s)
	{
		d[0] = s[0] ^ key;
	}

	template <std::size_t Size>
	struct string
	{
	public:
#if defined(_MSC_VER)
		__forceinline
#else
		__attribute__((always_inline))
#endif
		constexpr string(const char(&s)[Size], char key)
			: m_data(), m_key(key)
		{
			xor_str<Size - 1>(m_data, m_key, s);
		}

#if defined(_MSC_VER)
		__forceinline
#else
		__attribute__((always_inline))
#endif
		const char* rexor()
		{
			for (char& c : m_data) {
				c ^= m_key;
			}
			return m_data;
		}
#if defined(__cpp_attributes) && __cpp_attributes >= 200809L
		[[nodiscard]]
#endif
#if defined(_MSC_VER)
		__forceinline
#else
		__attribute__((always_inline))
#endif
		const char* xor_data() const
		{
			char* data = new char[Size];
			for (std::size_t i = 0; i < Size; i++) {
				data[i] = m_data[i] ^ m_key;
			}
			return data;
		}
		
#if defined(__cpp_attributes) && __cpp_attributes >= 200809L
		[[nodiscard]]
#endif
#if defined(_MSC_VER)
		__forceinline
#else
		__attribute__((always_inline))
#endif
		char* data()
#if defined(__cpp_noexcept_function_type) && __cpp_noexcept_function_type >= 201510L
			noexcept
#endif
		{
			return m_data;
		}
#if defined(__cpp_attributes) && __cpp_attributes >= 200809L
		[[nodiscard]]
#endif
#if defined(_MSC_VER)
		__forceinline
#else
		__attribute__((always_inline))
#endif
		const char* data() const
#if defined(__cpp_noexcept_function_type) && __cpp_noexcept_function_type >= 201510L
			noexcept
#endif
		{
			return m_data;
		}

#if defined(__cpp_attributes) && __cpp_attributes >= 200809L
		[[nodiscard]]
#endif
#if defined(_MSC_VER)
		__forceinline
#else
		__attribute__((always_inline))
#endif
		char key() const
#if defined(__cpp_noexcept_function_type) && __cpp_noexcept_function_type >= 201510L
			noexcept
#endif
		{
			return m_key;
		}

		constexpr static std::size_t size = Size;

	private:
		const char m_key;
		char m_data[Size];
	};

	template <std::size_t Size>
#if defined(__cpp_attributes) && __cpp_attributes >= 200809L
	[[nodiscard]]
#endif
#if defined(_MSC_VER)
	__forceinline
#else
	__attribute__((always_inline))
#endif
	constexpr string<Size> make_str(const char(&s)[Size], char key = static_cast<char>(xorlit::seed))
	{
		return string<Size>(s, key);
	}
}

#define XORLIT(...) ::xorlit::make_str(__VA_ARGS__).rexor()

```