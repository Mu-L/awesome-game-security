Project Path: arc_emoose_idaxex_2dzn1kxh

Source Tree:

```txt
arc_emoose_idaxex_2dzn1kxh
├── 3rdparty
│   ├── XbSymbolDatabase
│   ├── byte_order.hpp
│   ├── cxxopts.hpp
│   ├── date.hpp
│   ├── excrypt
│   ├── lzx.cpp
│   ├── mspack
│   │   ├── COPYING.LIB
│   │   ├── config.h
│   │   ├── lzx.h
│   │   ├── lzxd.c
│   │   ├── mspack.h
│   │   ├── readbits.h
│   │   ├── readhuff.h
│   │   ├── system.c
│   │   └── system.h
│   └── xtlid
│       ├── SOURCE.md
│       ├── result.cpp
│       ├── xml-to-cpp-map.py
│       └── xtlid.xml
├── CMakeLists.txt
├── LICENSE
├── README.md
├── formats
│   ├── pe_structs.hpp
│   ├── xbe.cpp
│   ├── xbe.hpp
│   ├── xbe_keys.hpp
│   ├── xbe_structs.hpp
│   ├── xdbf.cpp
│   ├── xdbf.hpp
│   ├── xdbf_structs.hpp
│   ├── xex.cpp
│   ├── xex.hpp
│   ├── xex_headerids.hpp
│   ├── xex_keys.hpp
│   ├── xex_optheaders.hpp
│   └── xex_structs.hpp
├── idaloader.cpp
├── idaloader_xbe.cpp
├── idaxex.sln
├── idaxex.vcxproj
├── idaxex.vcxproj.filters
├── namegen.cpp
├── namegen_xtlid.cpp
├── xex1tool
│   └── CMakeLists.txt
├── xex1tool.cpp
├── xex1tool.vcxproj
└── xex1tool.vcxproj.filters

```

`3rdparty/byte_order.hpp`:

```hpp
/* byte_order.hpp from xenia project: */
/* https://github.com/xenia-project/xenia/blob/master/src/xenia/base/byte_order.h */

/**
 ******************************************************************************
 * Xenia : Xbox 360 Emulator Research Project                                 *
 ******************************************************************************
 * Copyright 2014 Ben Vanik. All rights reserved.                             *
 * Released under the BSD license - see LICENSE in the root for more details. *
 ******************************************************************************
 */

#ifndef XENIA_BASE_BYTE_ORDER_H_
#define XENIA_BASE_BYTE_ORDER_H_

#include <cstdint>
#include <stdlib.h>

namespace xe {

#if _WIN32
#define XENIA_BASE_BYTE_SWAP_16 _byteswap_ushort
#define XENIA_BASE_BYTE_SWAP_32 _byteswap_ulong
#define XENIA_BASE_BYTE_SWAP_64 _byteswap_uint64
#elif XE_PLATFORM_MAC
#define XENIA_BASE_BYTE_SWAP_16 OSSwapInt16
#define XENIA_BASE_BYTE_SWAP_32 OSSwapInt32
#define XENIA_BASE_BYTE_SWAP_64 OSSwapInt64
#else
#define XENIA_BASE_BYTE_SWAP_16 __bswap_16
#define XENIA_BASE_BYTE_SWAP_32 __bswap_32
#define XENIA_BASE_BYTE_SWAP_64 __bswap_64
#endif  // XE_PLATFORM_WIN32

  inline int8_t byte_swap(int8_t value) { return value; }
  inline uint8_t byte_swap(uint8_t value) { return value; }
  inline int16_t byte_swap(int16_t value) {
    return static_cast<int16_t>(
      XENIA_BASE_BYTE_SWAP_16(static_cast<int16_t>(value)));
  }
  inline uint16_t byte_swap(uint16_t value) {
    return XENIA_BASE_BYTE_SWAP_16(value);
  }
  inline uint16_t byte_swap(wchar_t value) {
    return static_cast<wchar_t>(XENIA_BASE_BYTE_SWAP_16(value));
  }
  inline int32_t byte_swap(int32_t value) {
    return static_cast<int32_t>(
      XENIA_BASE_BYTE_SWAP_32(static_cast<int32_t>(value)));
  }
  inline uint32_t byte_swap(uint32_t value) {
    return XENIA_BASE_BYTE_SWAP_32(value);
  }
  inline int64_t byte_swap(int64_t value) {
    return static_cast<int64_t>(
      XENIA_BASE_BYTE_SWAP_64(static_cast<int64_t>(value)));
  }
  inline uint64_t byte_swap(uint64_t value) {
    return XENIA_BASE_BYTE_SWAP_64(value);
  }
  inline float byte_swap(float value) {
    uint32_t temp = byte_swap(*reinterpret_cast<uint32_t*>(&value));
    return *reinterpret_cast<float*>(&temp);
  }
  inline double byte_swap(double value) {
    uint64_t temp = byte_swap(*reinterpret_cast<uint64_t*>(&value));
    return *reinterpret_cast<double*>(&temp);
  }
  template <typename T>
  inline T byte_swap(T value) {
    if (sizeof(T) == 4) {
      return static_cast<T>(byte_swap(static_cast<uint32_t>(value)));
    }
    else if (sizeof(T) == 2) {
      return static_cast<T>(byte_swap(static_cast<uint16_t>(value)));
    }
    else if (sizeof(T) == 8) {
      return static_cast<T>(byte_swap(static_cast<uint64_t>(value)));
    }
    else {
      //assert_always("not handled");
    }
  }

  template <typename T>
  struct be {
    be() = default;
    be(const T& src) : value(xe::byte_swap(src)) {}  // NOLINT(runtime/explicit)
    be(const be& other) { value = other.value; }     // NOLINT(runtime/explicit)
    operator T() const { return xe::byte_swap(value); }

    be<T>& operator+=(int a) {
      *this = *this + a;
      return *this;
    }
    be<T>& operator-=(int a) {
      *this = *this - a;
      return *this;
    }
    be<T>& operator++() {
      *this += 1;
      return *this;
    }  // ++a
    be<T> operator++(int) {
      *this += 1;
      return (*this - 1);
    }  // a++
    be<T>& operator--() {
      *this -= 1;
      return *this;
    }  // --a
    be<T> operator--(int) {
      *this -= 1;
      return (*this + 1);
    }  // a--

    T value;
  };

}  // namespace xe

#endif  // XENIA_BASE_BYTE_ORDER_H_

```

`3rdparty/cxxopts.hpp`:

```hpp
/*

Copyright (c) 2014, 2015, 2016, 2017 Jarryd Beck

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

#ifndef CXXOPTS_HPP_INCLUDED
#define CXXOPTS_HPP_INCLUDED

#include <cstring>
#include <cctype>
#include <exception>
#include <iostream>
#include <limits>
#include <map>
#include <memory>
#include <regex>
#include <sstream>
#include <string>
#include <unordered_map>
#include <unordered_set>
#include <vector>

#ifdef __cpp_lib_optional
#include <optional>
#define CXXOPTS_HAS_OPTIONAL
#endif

#ifndef CXXOPTS_VECTOR_DELIMITER
#define CXXOPTS_VECTOR_DELIMITER ','
#endif

#define CXXOPTS__VERSION_MAJOR 2
#define CXXOPTS__VERSION_MINOR 2
#define CXXOPTS__VERSION_PATCH 0

namespace cxxopts
{
  static constexpr struct {
    uint8_t major, minor, patch;
  } version = {
    CXXOPTS__VERSION_MAJOR,
    CXXOPTS__VERSION_MINOR,
    CXXOPTS__VERSION_PATCH
  };
}

//when we ask cxxopts to use Unicode, help strings are processed using ICU,
//which results in the correct lengths being computed for strings when they
//are formatted for the help output
//it is necessary to make sure that <unicode/unistr.h> can be found by the
//compiler, and that icu-uc is linked in to the binary.

#ifdef CXXOPTS_USE_UNICODE
#include <unicode/unistr.h>

namespace cxxopts
{
  typedef icu::UnicodeString String;

  inline
    String
    toLocalString(std::string s)
  {
    return icu::UnicodeString::fromUTF8(std::move(s));
  }

  class UnicodeStringIterator : public
    std::iterator<std::forward_iterator_tag, int32_t>
  {
  public:

    UnicodeStringIterator(const icu::UnicodeString* string, int32_t pos)
      : s(string)
      , i(pos)
    {
    }

    value_type
      operator*() const
    {
      return s->char32At(i);
    }

    bool
      operator==(const UnicodeStringIterator& rhs) const
    {
      return s == rhs.s && i == rhs.i;
    }

    bool
      operator!=(const UnicodeStringIterator& rhs) const
    {
      return !(*this == rhs);
    }

    UnicodeStringIterator&
      operator++()
    {
      ++i;
      return *this;
    }

    UnicodeStringIterator
      operator+(int32_t v)
    {
      return UnicodeStringIterator(s, i + v);
    }

  private:
    const icu::UnicodeString* s;
    int32_t i;
  };

  inline
    String&
    stringAppend(String& s, String a)
  {
    return s.append(std::move(a));
  }

  inline
    String&
    stringAppend(String& s, int n, UChar32 c)
  {
    for (int i = 0; i != n; ++i)
    {
      s.append(c);
    }

    return s;
  }

  template <typename Iterator>
  String&
    stringAppend(String& s, Iterator begin, Iterator end)
  {
    while (begin != end)
    {
      s.append(*begin);
      ++begin;
    }

    return s;
  }

  inline
    size_t
    stringLength(const String& s)
  {
    return s.length();
  }

  inline
    std::string
    toUTF8String(const String& s)
  {
    std::string result;
    s.toUTF8String(result);

    return result;
  }

  inline
    bool
    empty(const String& s)
  {
    return s.isEmpty();
  }
}

namespace std
{
  inline
    cxxopts::UnicodeStringIterator
    begin(const icu::UnicodeString& s)
  {
    return cxxopts::UnicodeStringIterator(&s, 0);
  }

  inline
    cxxopts::UnicodeStringIterator
    end(const icu::UnicodeString& s)
  {
    return cxxopts::UnicodeStringIterator(&s, s.length());
  }
}

//ifdef CXXOPTS_USE_UNICODE
#else

namespace cxxopts
{
  typedef std::string String;

  template <typename T>
  T
    toLocalString(T&& t)
  {
    return std::forward<T>(t);
  }

  inline
    size_t
    stringLength(const String& s)
  {
    return s.length();
  }

  inline
    String&
    stringAppend(String& s, String a)
  {
    return s.append(std::move(a));
  }

  inline
    String&
    stringAppend(String& s, size_t n, char c)
  {
    return s.append(n, c);
  }

  template <typename Iterator>
  String&
    stringAppend(String& s, Iterator begin, Iterator end)
  {
    return s.append(begin, end);
  }

  template <typename T>
  std::string
    toUTF8String(T&& t)
  {
    return std::forward<T>(t);
  }

  inline
    bool
    empty(const std::string& s)
  {
    return s.empty();
  }
}

//ifdef CXXOPTS_USE_UNICODE
#endif

namespace cxxopts
{
  namespace
  {
#ifdef _WIN32
    const std::string LQUOTE("\'");
    const std::string RQUOTE("\'");
#else
    const std::string LQUOTE("‘");
    const std::string RQUOTE("’");
#endif
  }

  class Value : public std::enable_shared_from_this<Value>
  {
  public:

    virtual ~Value() = default;

    virtual
      std::shared_ptr<Value>
      clone() const = 0;

    virtual void
      parse(const std::string& text) const = 0;

    virtual void
      parse() const = 0;

    virtual bool
      has_default() const = 0;

    virtual bool
      is_container() const = 0;

    virtual bool
      has_implicit() const = 0;

    virtual std::string
      get_default_value() const = 0;

    virtual std::string
      get_implicit_value() const = 0;

    virtual std::shared_ptr<Value>
      default_value(const std::string& value) = 0;

    virtual std::shared_ptr<Value>
      implicit_value(const std::string& value) = 0;

    virtual std::shared_ptr<Value>
      no_implicit_value() = 0;

    virtual bool
      is_boolean() const = 0;
  };

  class OptionException : public std::exception
  {
  public:
    OptionException(const std::string& message)
      : m_message(message)
    {
    }

    virtual const char*
      what() const noexcept
    {
      return m_message.c_str();
    }

  private:
    std::string m_message;
  };

  class OptionSpecException : public OptionException
  {
  public:

    OptionSpecException(const std::string& message)
      : OptionException(message)
    {
    }
  };

  class OptionParseException : public OptionException
  {
  public:
    OptionParseException(const std::string& message)
      : OptionException(message)
    {
    }
  };

  class option_exists_error : public OptionSpecException
  {
  public:
    option_exists_error(const std::string& option)
      : OptionSpecException("Option " + LQUOTE + option + RQUOTE + " already exists")
    {
    }
  };

  class invalid_option_format_error : public OptionSpecException
  {
  public:
    invalid_option_format_error(const std::string& format)
      : OptionSpecException("Invalid option format " + LQUOTE + format + RQUOTE)
    {
    }
  };

  class option_syntax_exception : public OptionParseException {
  public:
    option_syntax_exception(const std::string& text)
      : OptionParseException("Argument " + LQUOTE + text + RQUOTE +
        " starts with a - but has incorrect syntax")
    {
    }
  };

  class option_not_exists_exception : public OptionParseException
  {
  public:
    option_not_exists_exception(const std::string& option)
      : OptionParseException("Option " + LQUOTE + option + RQUOTE + " does not exist")
    {
    }
  };

  class missing_argument_exception : public OptionParseException
  {
  public:
    missing_argument_exception(const std::string& option)
      : OptionParseException(
        "Option " + LQUOTE + option + RQUOTE + " is missing an argument"
      )
    {
    }
  };

  class option_requires_argument_exception : public OptionParseException
  {
  public:
    option_requires_argument_exception(const std::string& option)
      : OptionParseException(
        "Option " + LQUOTE + option + RQUOTE + " requires an argument"
      )
    {
    }
  };

  class option_not_has_argument_exception : public OptionParseException
  {
  public:
    option_not_has_argument_exception
    (
      const std::string& option,
      const std::string& arg
    )
      : OptionParseException(
        "Option " + LQUOTE + option + RQUOTE +
        " does not take an argument, but argument " +
        LQUOTE + arg + RQUOTE + " given"
      )
    {
    }
  };

  class option_not_present_exception : public OptionParseException
  {
  public:
    option_not_present_exception(const std::string& option)
      : OptionParseException("Option " + LQUOTE + option + RQUOTE + " not present")
    {
    }
  };

  class argument_incorrect_type : public OptionParseException
  {
  public:
    argument_incorrect_type
    (
      const std::string& arg
    )
      : OptionParseException(
        "Argument " + LQUOTE + arg + RQUOTE + " failed to parse"
      )
    {
    }
  };

  class option_required_exception : public OptionParseException
  {
  public:
    option_required_exception(const std::string& option)
      : OptionParseException(
        "Option " + LQUOTE + option + RQUOTE + " is required but not present"
      )
    {
    }
  };

  template <typename T>
  void throw_or_mimic(const std::string& text)
  {
    static_assert(std::is_base_of<std::exception, T>::value,
      "throw_or_mimic only works on std::exception and "
      "deriving classes");

#ifndef CXXOPTS_NO_EXCEPTIONS
    // If CXXOPTS_NO_EXCEPTIONS is not defined, just throw
    throw T{ text };
#else
    // Otherwise manually instantiate the exception, print what() to stderr,
    // and abort
    T exception{ text };
    std::cerr << exception.what() << std::endl;
    std::cerr << "Aborting (exceptions disabled)..." << std::endl;
    std::abort();
#endif
  }

  namespace values
  {
    namespace
    {
      std::basic_regex<char> integer_pattern
      ("(-)?(0x)?([0-9a-zA-Z]+)|((0x)?0)");
      std::basic_regex<char> truthy_pattern
      ("(t|T)(rue)?|1");
      std::basic_regex<char> falsy_pattern
      ("(f|F)(alse)?|0");
    }

    namespace detail
    {
      template <typename T, bool B>
      struct SignedCheck;

      template <typename T>
      struct SignedCheck<T, true>
      {
        template <typename U>
        void
          operator()(bool negative, U u, const std::string& text)
        {
          if (negative)
          {
            if (u > static_cast<U>((std::numeric_limits<T>::min)()))
            {
              throw_or_mimic<argument_incorrect_type>(text);
            }
          }
          else
          {
            if (u > static_cast<U>((std::numeric_limits<T>::max)()))
            {
              throw_or_mimic<argument_incorrect_type>(text);
            }
          }
        }
      };

      template <typename T>
      struct SignedCheck<T, false>
      {
        template <typename U>
        void
          operator()(bool, U, const std::string&) {}
      };

      template <typename T, typename U>
      void
        check_signed_range(bool negative, U value, const std::string& text)
      {
        SignedCheck<T, std::numeric_limits<T>::is_signed>()(negative, value, text);
      }
    }

    template <typename R, typename T>
    R
      checked_negate(T&& t, const std::string&, std::true_type)
    {
      // if we got to here, then `t` is a positive number that fits into
      // `R`. So to avoid MSVC C4146, we first cast it to `R`.
      // See https://github.com/jarro2783/cxxopts/issues/62 for more details.
      return static_cast<R>(-static_cast<R>(t - 1) - 1);
    }

    template <typename R, typename T>
    T
      checked_negate(T&& t, const std::string& text, std::false_type)
    {
      throw_or_mimic<argument_incorrect_type>(text);
      return t;
    }

    template <typename T>
    void
      integer_parser(const std::string& text, T& value)
    {
      std::smatch match;
      std::regex_match(text, match, integer_pattern);

      if (match.length() == 0)
      {
        throw_or_mimic<argument_incorrect_type>(text);
      }

      if (match.length(4) > 0)
      {
        value = 0;
        return;
      }

      using US = typename std::make_unsigned<T>::type;

      constexpr bool is_signed = std::numeric_limits<T>::is_signed;
      const bool negative = match.length(1) > 0;
      const uint8_t base = match.length(2) > 0 ? 16 : 10;

      auto value_match = match[3];

      US result = 0;

      for (auto iter = value_match.first; iter != value_match.second; ++iter)
      {
        US digit = 0;

        if (*iter >= '0' && *iter <= '9')
        {
          digit = static_cast<US>(*iter - '0');
        }
        else if (base == 16 && *iter >= 'a' && *iter <= 'f')
        {
          digit = static_cast<US>(*iter - 'a' + 10);
        }
        else if (base == 16 && *iter >= 'A' && *iter <= 'F')
        {
          digit = static_cast<US>(*iter - 'A' + 10);
        }
        else
        {
          throw_or_mimic<argument_incorrect_type>(text);
        }

        const US next = static_cast<US>(result * base + digit);
        if (result > next)
        {
          throw_or_mimic<argument_incorrect_type>(text);
        }

        result = next;
      }

      detail::check_signed_range<T>(negative, result, text);

      if (negative)
      {
        value = checked_negate<T>(result,
          text,
          std::integral_constant<bool, is_signed>());
      }
      else
      {
        value = static_cast<T>(result);
      }
    }

    template <typename T>
    void stringstream_parser(const std::string& text, T& value)
    {
      std::stringstream in(text);
      in >> value;
      if (!in) {
        throw_or_mimic<argument_incorrect_type>(text);
      }
    }

    inline
      void
      parse_value(const std::string& text, uint8_t& value)
    {
      integer_parser(text, value);
    }

    inline
      void
      parse_value(const std::string& text, int8_t& value)
    {
      integer_parser(text, value);
    }

    inline
      void
      parse_value(const std::string& text, uint16_t& value)
    {
      integer_parser(text, value);
    }

    inline
      void
      parse_value(const std::string& text, int16_t& value)
    {
      integer_parser(text, value);
    }

    inline
      void
      parse_value(const std::string& text, uint32_t& value)
    {
      integer_parser(text, value);
    }

    inline
      void
      parse_value(const std::string& text, int32_t& value)
    {
      integer_parser(text, value);
    }

    inline
      void
      parse_value(const std::string& text, uint64_t& value)
    {
      integer_parser(text, value);
    }

    inline
      void
      parse_value(const std::string& text, int64_t& value)
    {
      integer_parser(text, value);
    }

    inline
      void
      parse_value(const std::string& text, bool& value)
    {
      std::smatch result;
      std::regex_match(text, result, truthy_pattern);

      if (!result.empty())
      {
        value = true;
        return;
      }

      std::regex_match(text, result, falsy_pattern);
      if (!result.empty())
      {
        value = false;
        return;
      }

      throw_or_mimic<argument_incorrect_type>(text);
    }

    inline
      void
      parse_value(const std::string& text, std::string& value)
    {
      value = text;
    }

    // The fallback parser. It uses the stringstream parser to parse all types
    // that have not been overloaded explicitly.  It has to be placed in the
    // source code before all other more specialized templates.
    template <typename T>
    void
      parse_value(const std::string& text, T& value) {
      stringstream_parser(text, value);
    }

    template <typename T>
    void
      parse_value(const std::string& text, std::vector<T>& value)
    {
      std::stringstream in(text);
      std::string token;
      while (in.eof() == false && std::getline(in, token, CXXOPTS_VECTOR_DELIMITER)) {
        T v;
        parse_value(token, v);
        value.emplace_back(std::move(v));
      }
    }

#ifdef CXXOPTS_HAS_OPTIONAL
    template <typename T>
    void
      parse_value(const std::string& text, std::optional<T>& value)
    {
      T result;
      parse_value(text, result);
      value = std::move(result);
    }
#endif

    inline
      void parse_value(const std::string& text, char& c)
    {
      if (text.length() != 1)
      {
        throw_or_mimic<argument_incorrect_type>(text);
      }

      c = text[0];
    }

    template <typename T>
    struct type_is_container
    {
      static constexpr bool value = false;
    };

    template <typename T>
    struct type_is_container<std::vector<T>>
    {
      static constexpr bool value = true;
    };

    template <typename T>
    class abstract_value : public Value
    {
      using Self = abstract_value<T>;

    public:
      abstract_value()
        : m_result(std::make_shared<T>())
        , m_store(m_result.get())
      {
      }

      abstract_value(T* t)
        : m_store(t)
      {
      }

      virtual ~abstract_value() = default;

      abstract_value(const abstract_value& rhs)
      {
        if (rhs.m_result)
        {
          m_result = std::make_shared<T>();
          m_store = m_result.get();
        }
        else
        {
          m_store = rhs.m_store;
        }

        m_default = rhs.m_default;
        m_implicit = rhs.m_implicit;
        m_default_value = rhs.m_default_value;
        m_implicit_value = rhs.m_implicit_value;
      }

      void
        parse(const std::string& text) const
      {
        parse_value(text, *m_store);
      }

      bool
        is_container() const
      {
        return type_is_container<T>::value;
      }

      void
        parse() const
      {
        parse_value(m_default_value, *m_store);
      }

      bool
        has_default() const
      {
        return m_default;
      }

      bool
        has_implicit() const
      {
        return m_implicit;
      }

      std::shared_ptr<Value>
        default_value(const std::string& value)
      {
        m_default = true;
        m_default_value = value;
        return shared_from_this();
      }

      std::shared_ptr<Value>
        implicit_value(const std::string& value)
      {
        m_implicit = true;
        m_implicit_value = value;
        return shared_from_this();
      }

      std::shared_ptr<Value>
        no_implicit_value()
      {
        m_implicit = false;
        return shared_from_this();
      }

      std::string
        get_default_value() const
      {
        return m_default_value;
      }

      std::string
        get_implicit_value() const
      {
        return m_implicit_value;
      }

      bool
        is_boolean() const
      {
        return std::is_same<T, bool>::value;
      }

      const T&
        get() const
      {
        if (m_store == nullptr)
        {
          return *m_result;
        }
        else
        {
          return *m_store;
        }
      }

    protected:
      std::shared_ptr<T> m_result;
      T* m_store;

      bool m_default = false;
      bool m_implicit = false;

      std::string m_default_value;
      std::string m_implicit_value;
    };

    template <typename T>
    class standard_value : public abstract_value<T>
    {
    public:
      using abstract_value<T>::abstract_value;

      std::shared_ptr<Value>
        clone() const
      {
        return std::make_shared<standard_value<T>>(*this);
      }
    };

    template <>
    class standard_value<bool> : public abstract_value<bool>
    {
    public:
      ~standard_value() = default;

      standard_value()
      {
        set_default_and_implicit();
      }

      standard_value(bool* b)
        : abstract_value(b)
      {
        set_default_and_implicit();
      }

      std::shared_ptr<Value>
        clone() const
      {
        return std::make_shared<standard_value<bool>>(*this);
      }

    private:

      void
        set_default_and_implicit()
      {
        m_default = true;
        m_default_value = "false";
        m_implicit = true;
        m_implicit_value = "true";
      }
    };
  }

  template <typename T>
  std::shared_ptr<Value>
    value()
  {
    return std::make_shared<values::standard_value<T>>();
  }

  template <typename T>
  std::shared_ptr<Value>
    value(T& t)
  {
    return std::make_shared<values::standard_value<T>>(&t);
  }

  class OptionAdder;

  class OptionDetails
  {
  public:
    OptionDetails
    (
      const std::string& short_,
      const std::string& long_,
      const String& desc,
      std::shared_ptr<const Value> val
    )
      : m_short(short_)
      , m_long(long_)
      , m_desc(desc)
      , m_value(val)
      , m_count(0)
    {
    }

    OptionDetails(const OptionDetails& rhs)
      : m_desc(rhs.m_desc)
      , m_count(rhs.m_count)
    {
      m_value = rhs.m_value->clone();
    }

    OptionDetails(OptionDetails&& rhs) = default;

    const String&
      description() const
    {
      return m_desc;
    }

    const Value& value() const {
      return *m_value;
    }

    std::shared_ptr<Value>
      make_storage() const
    {
      return m_value->clone();
    }

    const std::string&
      short_name() const
    {
      return m_short;
    }

    const std::string&
      long_name() const
    {
      return m_long;
    }

  private:
    std::string m_short;
    std::string m_long;
    String m_desc;
    std::shared_ptr<const Value> m_value;
    int m_count;
  };

  struct HelpOptionDetails
  {
    std::string s;
    std::string l;
    String desc;
    bool has_default;
    std::string default_value;
    bool has_implicit;
    std::string implicit_value;
    std::string arg_help;
    bool is_container;
    bool is_boolean;
  };

  struct HelpGroupDetails
  {
    std::string name;
    std::string description;
    std::vector<HelpOptionDetails> options;
  };

  class OptionValue
  {
  public:
    void
      parse
      (
        std::shared_ptr<const OptionDetails> details,
        const std::string& text
      )
    {
      ensure_value(details);
      ++m_count;
      m_value->parse(text);
    }

    void
      parse_default(std::shared_ptr<const OptionDetails> details)
    {
      ensure_value(details);
      m_default = true;
      m_value->parse();
    }

    size_t
      count() const noexcept
    {
      return m_count;
    }

    // TODO: maybe default options should count towards the number of arguments
    bool
      has_default() const noexcept
    {
      return m_default;
    }

    template <typename T>
    const T&
      as() const
    {
      if (m_value == nullptr) {
        throw_or_mimic<std::domain_error>("No value");
      }

#ifdef CXXOPTS_NO_RTTI
      return static_cast<const values::standard_value<T>&>(*m_value).get();
#else
      return dynamic_cast<const values::standard_value<T>&>(*m_value).get();
#endif
    }

  private:
    void
      ensure_value(std::shared_ptr<const OptionDetails> details)
    {
      if (m_value == nullptr)
      {
        m_value = details->make_storage();
      }
    }

    std::shared_ptr<Value> m_value;
    size_t m_count = 0;
    bool m_default = false;
  };

  class KeyValue
  {
  public:
    KeyValue(std::string key_, std::string value_)
      : m_key(std::move(key_))
      , m_value(std::move(value_))
    {
    }

    const
      std::string&
      key() const
    {
      return m_key;
    }

    const
      std::string&
      value() const
    {
      return m_value;
    }

    template <typename T>
    T
      as() const
    {
      T result;
      values::parse_value(m_value, result);
      return result;
    }

  private:
    std::string m_key;
    std::string m_value;
  };

  class ParseResult
  {
  public:

    ParseResult(
      const std::shared_ptr<
      std::unordered_map<std::string, std::shared_ptr<OptionDetails>>
      >,
      std::vector<std::string>,
      bool allow_unrecognised,
      int&, char**&);

    size_t
      count(const std::string& o) const
    {
      auto iter = m_options->find(o);
      if (iter == m_options->end())
      {
        return 0;
      }

      auto riter = m_results.find(iter->second);

      return riter->second.count();
    }

    const OptionValue&
      operator[](const std::string& option) const
    {
      auto iter = m_options->find(option);

      if (iter == m_options->end())
      {
        throw_or_mimic<option_not_present_exception>(option);
      }

      auto riter = m_results.find(iter->second);

      return riter->second;
    }

    const std::vector<KeyValue>&
      arguments() const
    {
      return m_sequential;
    }

  private:

    void
      parse(int& argc, char**& argv);

    void
      add_to_option(const std::string& option, const std::string& arg);

    bool
      consume_positional(std::string a);

    void
      parse_option
      (
        std::shared_ptr<OptionDetails> value,
        const std::string& name,
        const std::string& arg = ""
      );

    void
      parse_default(std::shared_ptr<OptionDetails> details);

    void
      checked_parse_arg
      (
        int argc,
        char* argv[],
        int& current,
        std::shared_ptr<OptionDetails> value,
        const std::string& name
      );

    const std::shared_ptr<
      std::unordered_map<std::string, std::shared_ptr<OptionDetails>>
    > m_options;
    std::vector<std::string> m_positional;
    std::vector<std::string>::iterator m_next_positional;
    std::unordered_set<std::string> m_positional_set;
    std::unordered_map<std::shared_ptr<OptionDetails>, OptionValue> m_results;

    bool m_allow_unrecognised;

    std::vector<KeyValue> m_sequential;
  };

  struct Option
  {
    Option
    (
      const std::string& opts,
      const std::string& desc,
      const std::shared_ptr<const Value>& value = ::cxxopts::value<bool>(),
      const std::string& arg_help = ""
    )
      : opts_(opts)
      , desc_(desc)
      , value_(value)
      , arg_help_(arg_help)
    {
    }

    std::string opts_;
    std::string desc_;
    std::shared_ptr<const Value> value_;
    std::string arg_help_;
  };

  class Options
  {
    typedef std::unordered_map<std::string, std::shared_ptr<OptionDetails>>
      OptionMap;
  public:

    Options(std::string program, std::string help_string = "")
      : m_program(std::move(program))
      , m_help_string(toLocalString(std::move(help_string)))
      , m_custom_help("[OPTION...]")
      , m_positional_help("positional parameters")
      , m_show_positional(false)
      , m_allow_unrecognised(false)
      , m_options(std::make_shared<OptionMap>())
      , m_next_positional(m_positional.end())
    {
    }

    Options&
      positional_help(std::string help_text)
    {
      m_positional_help = std::move(help_text);
      return *this;
    }

    Options&
      custom_help(std::string help_text)
    {
      m_custom_help = std::move(help_text);
      return *this;
    }

    Options&
      show_positional_help()
    {
      m_show_positional = true;
      return *this;
    }

    Options&
      allow_unrecognised_options()
    {
      m_allow_unrecognised = true;
      return *this;
    }

    ParseResult
      parse(int& argc, char**& argv);

    OptionAdder
      add_options(std::string group = "");

    void
      add_options
      (
        const std::string& group,
        std::initializer_list<Option> options
      );

    void
      add_option
      (
        const std::string& group,
        const Option& option
      );

    void
      add_option
      (
        const std::string& group,
        const std::string& s,
        const std::string& l,
        std::string desc,
        std::shared_ptr<const Value> value,
        std::string arg_help
      );

    //parse positional arguments into the given option
    void
      parse_positional(std::string option);

    void
      parse_positional(std::vector<std::string> options);

    void
      parse_positional(std::initializer_list<std::string> options);

    template <typename Iterator>
    void
      parse_positional(Iterator begin, Iterator end) {
      parse_positional(std::vector<std::string>{begin, end});
    }

    std::string
      help(const std::vector<std::string>& groups = {}) const;

    const std::vector<std::string>
      groups() const;

    const HelpGroupDetails&
      group_help(const std::string& group) const;

  private:

    void
      add_one_option
      (
        const std::string& option,
        std::shared_ptr<OptionDetails> details
      );

    String
      help_one_group(const std::string& group) const;

    void
      generate_group_help
      (
        String& result,
        const std::vector<std::string>& groups
      ) const;

    void
      generate_all_groups_help(String& result) const;

    std::string m_program;
    String m_help_string;
    std::string m_custom_help;
    std::string m_positional_help;
    bool m_show_positional;
    bool m_allow_unrecognised;

    std::shared_ptr<OptionMap> m_options;
    std::vector<std::string> m_positional;
    std::vector<std::string>::iterator m_next_positional;
    std::unordered_set<std::string> m_positional_set;

    //mapping from groups to help options
    std::map<std::string, HelpGroupDetails> m_help;
  };

  class OptionAdder
  {
  public:

    OptionAdder(Options& options, std::string group)
      : m_options(options), m_group(std::move(group))
    {
    }

    OptionAdder&
      operator()
      (
        const std::string& opts,
        const std::string& desc,
        std::shared_ptr<const Value> value
        = ::cxxopts::value<bool>(),
        std::string arg_help = ""
        );

  private:
    Options& m_options;
    std::string m_group;
  };

  namespace
  {
    constexpr int OPTION_LONGEST = 30;
    constexpr int OPTION_DESC_GAP = 2;

    std::basic_regex<char> option_matcher
    ("--([[:alnum:]][-_[:alnum:]]+)(=(.*))?|-([[:alnum:]]+)");

    std::basic_regex<char> option_specifier
    ("(([[:alnum:]]),)?[ ]*([[:alnum:]][-_[:alnum:]]*)?");

    String
      format_option
      (
        const HelpOptionDetails& o
      )
    {
      auto& s = o.s;
      auto& l = o.l;

      String result = "  ";

      if (s.size() > 0)
      {
        result += "-" + toLocalString(s) + ",";
      }
      else
      {
        result += "   ";
      }

      if (l.size() > 0)
      {
        result += " --" + toLocalString(l);
      }

      auto arg = o.arg_help.size() > 0 ? toLocalString(o.arg_help) : "arg";

      if (!o.is_boolean)
      {
        if (o.has_implicit)
        {
          result += " [=" + arg + "(=" + toLocalString(o.implicit_value) + ")]";
        }
        else
        {
          result += " " + arg;
        }
      }

      return result;
    }

    String
      format_description
      (
        const HelpOptionDetails& o,
        size_t start,
        size_t width
      )
    {
      auto desc = o.desc;

      if (o.has_default && (!o.is_boolean || o.default_value != "false"))
      {
        if (o.default_value != "")
        {
          desc += toLocalString(" (default: " + o.default_value + ")");
        }
        else
        {
          desc += toLocalString(" (default: \"\")");
        }
      }

      String result;

      auto current = std::begin(desc);
      auto startLine = current;
      auto lastSpace = current;

      auto size = size_t{};

      while (current != std::end(desc))
      {
        if (*current == ' ')
        {
          lastSpace = current;
        }

        if (*current == '\n')
        {
          startLine = current + 1;
          lastSpace = startLine;
        }
        else if (size > width)
        {
          if (lastSpace == startLine)
          {
            stringAppend(result, startLine, current + 1);
            stringAppend(result, "\n");
            stringAppend(result, start, ' ');
            startLine = current + 1;
            lastSpace = startLine;
          }
          else
          {
            stringAppend(result, startLine, lastSpace);
            stringAppend(result, "\n");
            stringAppend(result, start, ' ');
            startLine = lastSpace + 1;
            lastSpace = startLine;
          }
          size = 0;
        }
        else
        {
          ++size;
        }

        ++current;
      }

      //append whatever is left
      stringAppend(result, startLine, current);

      return result;
    }
  }

  inline
    ParseResult::ParseResult
    (
      const std::shared_ptr<
      std::unordered_map<std::string, std::shared_ptr<OptionDetails>>
      > options,
      std::vector<std::string> positional,
      bool allow_unrecognised,
      int& argc, char**& argv
    )
    : m_options(options)
    , m_positional(std::move(positional))
    , m_next_positional(m_positional.begin())
    , m_allow_unrecognised(allow_unrecognised)
  {
    parse(argc, argv);
  }

  inline
    void
    Options::add_options
    (
      const std::string& group,
      std::initializer_list<Option> options
    )
  {
    OptionAdder option_adder(*this, group);
    for (const auto& option : options)
    {
      option_adder(option.opts_, option.desc_, option.value_, option.arg_help_);
    }
  }

  inline
    OptionAdder
    Options::add_options(std::string group)
  {
    return OptionAdder(*this, std::move(group));
  }

  inline
    OptionAdder&
    OptionAdder::operator()
    (
      const std::string& opts,
      const std::string& desc,
      std::shared_ptr<const Value> value,
      std::string arg_help
      )
  {
    std::match_results<const char*> result;
    std::regex_match(opts.c_str(), result, option_specifier);

    if (result.empty())
    {
      throw_or_mimic<invalid_option_format_error>(opts);
    }

    const auto& short_match = result[2];
    const auto& long_match = result[3];

    if (!short_match.length() && !long_match.length())
    {
      throw_or_mimic<invalid_option_format_error>(opts);
    }
    else if (long_match.length() == 1 && short_match.length())
    {
      throw_or_mimic<invalid_option_format_error>(opts);
    }

    auto option_names = []
    (
      const std::sub_match<const char*>& short_,
      const std::sub_match<const char*>& long_
      )
    {
      if (long_.length() == 1)
      {
        return std::make_tuple(long_.str(), short_.str());
      }
      else
      {
        return std::make_tuple(short_.str(), long_.str());
      }
    }(short_match, long_match);

    m_options.add_option
    (
      m_group,
      std::get<0>(option_names),
      std::get<1>(option_names),
      desc,
      value,
      std::move(arg_help)
    );

    return *this;
  }

  inline
    void
    ParseResult::parse_default(std::shared_ptr<OptionDetails> details)
  {
    m_results[details].parse_default(details);
  }

  inline
    void
    ParseResult::parse_option
    (
      std::shared_ptr<OptionDetails> value,
      const std::string& /*name*/,
      const std::string& arg
    )
  {
    auto& result = m_results[value];
    result.parse(value, arg);

    m_sequential.emplace_back(value->long_name(), arg);
  }

  inline
    void
    ParseResult::checked_parse_arg
    (
      int argc,
      char* argv[],
      int& current,
      std::shared_ptr<OptionDetails> value,
      const std::string& name
    )
  {
    if (current + 1 >= argc)
    {
      if (value->value().has_implicit())
      {
        parse_option(value, name, value->value().get_implicit_value());
      }
      else
      {
        throw_or_mimic<missing_argument_exception>(name);
      }
    }
    else
    {
      if (value->value().has_implicit())
      {
        parse_option(value, name, value->value().get_implicit_value());
      }
      else
      {
        parse_option(value, name, argv[current + 1]);
        ++current;
      }
    }
  }

  inline
    void
    ParseResult::add_to_option(const std::string& option, const std::string& arg)
  {
    auto iter = m_options->find(option);

    if (iter == m_options->end())
    {
      throw_or_mimic<option_not_exists_exception>(option);
    }

    parse_option(iter->second, option, arg);
  }

  inline
    bool
    ParseResult::consume_positional(std::string a)
  {
    while (m_next_positional != m_positional.end())
    {
      auto iter = m_options->find(*m_next_positional);
      if (iter != m_options->end())
      {
        auto& result = m_results[iter->second];
        if (!iter->second->value().is_container())
        {
          if (result.count() == 0)
          {
            add_to_option(*m_next_positional, a);
            ++m_next_positional;
            return true;
          }
          else
          {
            ++m_next_positional;
            continue;
          }
        }
        else
        {
          add_to_option(*m_next_positional, a);
          return true;
        }
      }
      else
      {
        throw_or_mimic<option_not_exists_exception>(*m_next_positional);
      }
    }

    return false;
  }

  inline
    void
    Options::parse_positional(std::string option)
  {
    parse_positional(std::vector<std::string>{std::move(option)});
  }

  inline
    void
    Options::parse_positional(std::vector<std::string> options)
  {
    m_positional = std::move(options);
    m_next_positional = m_positional.begin();

    m_positional_set.insert(m_positional.begin(), m_positional.end());
  }

  inline
    void
    Options::parse_positional(std::initializer_list<std::string> options)
  {
    parse_positional(std::vector<std::string>(std::move(options)));
  }

  inline
    ParseResult
    Options::parse(int& argc, char**& argv)
  {
    ParseResult result(m_options, m_positional, m_allow_unrecognised, argc, argv);
    return result;
  }

  inline
    void
    ParseResult::parse(int& argc, char**& argv)
  {
    int current = 1;

    int nextKeep = 1;

    bool consume_remaining = false;

    while (current != argc)
    {
      if (strcmp(argv[current], "--") == 0)
      {
        consume_remaining = true;
        ++current;
        break;
      }

      std::match_results<const char*> result;
      std::regex_match(argv[current], result, option_matcher);

      if (result.empty())
      {
        //not a flag

        // but if it starts with a `-`, then it's an error
        if (argv[current][0] == '-' && argv[current][1] != '\0') {
          if (!m_allow_unrecognised) {
            throw_or_mimic<option_syntax_exception>(argv[current]);
          }
        }

        //if true is returned here then it was consumed, otherwise it is
        //ignored
        if (consume_positional(argv[current]))
        {
        }
        else
        {
          argv[nextKeep] = argv[current];
          ++nextKeep;
        }
        //if we return from here then it was parsed successfully, so continue
      }
      else
      {
        //short or long option?
        if (result[4].length() != 0)
        {
          const std::string& s = result[4];

          for (std::size_t i = 0; i != s.size(); ++i)
          {
            std::string name(1, s[i]);
            auto iter = m_options->find(name);

            if (iter == m_options->end())
            {
              if (m_allow_unrecognised)
              {
                continue;
              }
              else
              {
                //error
                throw_or_mimic<option_not_exists_exception>(name);
              }
            }

            auto value = iter->second;

            if (i + 1 == s.size())
            {
              //it must be the last argument
              checked_parse_arg(argc, argv, current, value, name);
            }
            else if (value->value().has_implicit())
            {
              parse_option(value, name, value->value().get_implicit_value());
            }
            else
            {
              //error
              throw_or_mimic<option_requires_argument_exception>(name);
            }
          }
        }
        else if (result[1].length() != 0)
        {
          const std::string& name = result[1];

          auto iter = m_options->find(name);

          if (iter == m_options->end())
          {
            if (m_allow_unrecognised)
            {
              // keep unrecognised options in argument list, skip to next argument
              argv[nextKeep] = argv[current];
              ++nextKeep;
              ++current;
              continue;
            }
            else
            {
              //error
              throw_or_mimic<option_not_exists_exception>(name);
            }
          }

          auto opt = iter->second;

          //equals provided for long option?
          if (result[2].length() != 0)
          {
            //parse the option given

            parse_option(opt, name, result[3]);
          }
          else
          {
            //parse the next argument
            checked_parse_arg(argc, argv, current, opt, name);
          }
        }

      }

      ++current;
    }

    for (auto& opt : *m_options)
    {
      auto& detail = opt.second;
      auto& value = detail->value();

      auto& store = m_results[detail];

      if (value.has_default() && !store.count() && !store.has_default()) {
        parse_default(detail);
      }
    }

    if (consume_remaining)
    {
      while (current < argc)
      {
        if (!consume_positional(argv[current])) {
          break;
        }
        ++current;
      }

      //adjust argv for any that couldn't be swallowed
      while (current != argc) {
        argv[nextKeep] = argv[current];
        ++nextKeep;
        ++current;
      }
    }

    argc = nextKeep;

  }

  inline
    void
    Options::add_option
    (
      const std::string& group,
      const Option& option
    )
  {
    add_options(group, { option });
  }

  inline
    void
    Options::add_option
    (
      const std::string& group,
      const std::string& s,
      const std::string& l,
      std::string desc,
      std::shared_ptr<const Value> value,
      std::string arg_help
    )
  {
    auto stringDesc = toLocalString(std::move(desc));
    auto option = std::make_shared<OptionDetails>(s, l, stringDesc, value);

    if (s.size() > 0)
    {
      add_one_option(s, option);
    }

    if (l.size() > 0)
    {
      add_one_option(l, option);
    }

    //add the help details
    auto& options = m_help[group];

    options.options.emplace_back(HelpOptionDetails{ s, l, stringDesc,
        value->has_default(), value->get_default_value(),
        value->has_implicit(), value->get_implicit_value(),
        std::move(arg_help),
        value->is_container(),
        value->is_boolean() });
  }

  inline
    void
    Options::add_one_option
    (
      const std::string& option,
      std::shared_ptr<OptionDetails> details
    )
  {
    auto in = m_options->emplace(option, details);

    if (!in.second)
    {
      throw_or_mimic<option_exists_error>(option);
    }
  }

  inline
    String
    Options::help_one_group(const std::string& g) const
  {
    typedef std::vector<std::pair<String, String>> OptionHelp;

    auto group = m_help.find(g);
    if (group == m_help.end())
    {
      return "";
    }

    OptionHelp format;

    size_t longest = 0;

    String result;

    if (!g.empty())
    {
      result += toLocalString(" " + g + " options:\n");
    }

    for (const auto& o : group->second.options)
    {
      if (m_positional_set.find(o.l) != m_positional_set.end() &&
        !m_show_positional)
      {
        continue;
      }

      auto s = format_option(o);
      longest = (std::max)(longest, stringLength(s));
      format.push_back(std::make_pair(s, String()));
    }

    longest = (std::min)(longest, static_cast<size_t>(OPTION_LONGEST));

    //widest allowed description
    auto allowed = size_t{ 76 } -longest - OPTION_DESC_GAP;

    auto fiter = format.begin();
    for (const auto& o : group->second.options)
    {
      if (m_positional_set.find(o.l) != m_positional_set.end() &&
        !m_show_positional)
      {
        continue;
      }

      auto d = format_description(o, longest + OPTION_DESC_GAP, allowed);

      result += fiter->first;
      if (stringLength(fiter->first) > longest)
      {
        result += '\n';
        result += toLocalString(std::string(longest + OPTION_DESC_GAP, ' '));
      }
      else
      {
        result += toLocalString(std::string(longest + OPTION_DESC_GAP -
          stringLength(fiter->first),
          ' '));
      }
      result += d;
      result += '\n';

      ++fiter;
    }

    return result;
  }

  inline
    void
    Options::generate_group_help
    (
      String& result,
      const std::vector<std::string>& print_groups
    ) const
  {
    for (size_t i = 0; i != print_groups.size(); ++i)
    {
      const String& group_help_text = help_one_group(print_groups[i]);
      if (empty(group_help_text))
      {
        continue;
      }
      result += group_help_text;
      if (i < print_groups.size() - 1)
      {
        result += '\n';
      }
    }
  }

  inline
    void
    Options::generate_all_groups_help(String& result) const
  {
    std::vector<std::string> all_groups;
    all_groups.reserve(m_help.size());

    for (auto& group : m_help)
    {
      all_groups.push_back(group.first);
    }

    generate_group_help(result, all_groups);
  }

  inline
    std::string
    Options::help(const std::vector<std::string>& help_groups) const
  {
    String result = m_help_string + "\nUsage:\n  " +
      toLocalString(m_program) + " " + toLocalString(m_custom_help);

    if (m_positional.size() > 0 && m_positional_help.size() > 0) {
      result += " " + toLocalString(m_positional_help);
    }

    result += "\n\n";

    if (help_groups.size() == 0)
    {
      generate_all_groups_help(result);
    }
    else
    {
      generate_group_help(result, help_groups);
    }

    return toUTF8String(result);
  }

  inline
    const std::vector<std::string>
    Options::groups() const
  {
    std::vector<std::string> g;

    std::transform(
      m_help.begin(),
      m_help.end(),
      std::back_inserter(g),
      [](const std::map<std::string, HelpGroupDetails>::value_type& pair)
      {
        return pair.first;
      }
    );

    return g;
  }

  inline
    const HelpGroupDetails&
    Options::group_help(const std::string& group) const
  {
    return m_help.at(group);
  }

}

#endif //CXXOPTS_HPP_INCLUDED

```

`3rdparty/date.hpp`:

```hpp
#ifndef DATE_H
#define DATE_H

// The MIT License (MIT)
//
// Copyright (c) 2015, 2016, 2017 Howard Hinnant
// Copyright (c) 2016 Adrian Colomitchi
// Copyright (c) 2017 Florian Dang
// Copyright (c) 2017 Paul Thompson
// Copyright (c) 2018, 2019 Tomasz Kamiński
// Copyright (c) 2019 Jiangang Zhuang
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
// Our apologies.  When the previous paragraph was written, lowercase had not yet
// been invented (that would involve another several millennia of evolution).
// We did not mean to shout.

#ifndef HAS_STRING_VIEW
#  if __cplusplus >= 201703 || (defined(_MSVC_LANG) && _MSVC_LANG >= 201703L)
#    define HAS_STRING_VIEW 1
#  else
#    define HAS_STRING_VIEW 0
#  endif
#endif  // HAS_STRING_VIEW

#include <cassert>
#include <algorithm>
#include <cctype>
#include <chrono>
#include <climits>
#if !(__cplusplus >= 201402)
#  include <cmath>
#endif
#include <cstddef>
#include <cstdint>
#include <cstdlib>
#include <ctime>
#include <ios>
#include <istream>
#include <iterator>
#include <limits>
#include <locale>
#include <memory>
#include <ostream>
#include <ratio>
#include <sstream>
#include <stdexcept>
#include <string>
#if HAS_STRING_VIEW
# include <string_view>
#endif
#include <utility>
#include <type_traits>

#ifdef __GNUC__
# pragma GCC diagnostic push
# if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR > 7)
#  pragma GCC diagnostic ignored "-Wpedantic"
# endif
# if __GNUC__ < 5
   // GCC 4.9 Bug 61489 Wrong warning with -Wmissing-field-initializers
#  pragma GCC diagnostic ignored "-Wmissing-field-initializers"
# endif
#endif

#ifdef _MSC_VER
#   pragma warning(push)
// warning C4127: conditional expression is constant
#   pragma warning(disable : 4127)
#endif

namespace date
{

  //---------------+
  // Configuration |
  //---------------+

#ifndef ONLY_C_LOCALE
#  define ONLY_C_LOCALE 0
#endif

#if defined(_MSC_VER) && (!defined(__clang__) || (_MSC_VER < 1910))
// MSVC
#  ifndef _SILENCE_CXX17_UNCAUGHT_EXCEPTION_DEPRECATION_WARNING
#    define _SILENCE_CXX17_UNCAUGHT_EXCEPTION_DEPRECATION_WARNING
#  endif
#  if _MSC_VER < 1910
//   before VS2017
#    define CONSTDATA const
#    define CONSTCD11
#    define CONSTCD14
#    define NOEXCEPT _NOEXCEPT
#  else
//   VS2017 and later
#    define CONSTDATA constexpr const
#    define CONSTCD11 constexpr
#    define CONSTCD14 constexpr
#    define NOEXCEPT noexcept
#  endif

#elif defined(__SUNPRO_CC) && __SUNPRO_CC <= 0x5150
// Oracle Developer Studio 12.6 and earlier
#  define CONSTDATA constexpr const
#  define CONSTCD11 constexpr
#  define CONSTCD14
#  define NOEXCEPT noexcept

#elif __cplusplus >= 201402
// C++14
#  define CONSTDATA constexpr const
#  define CONSTCD11 constexpr
#  define CONSTCD14 constexpr
#  define NOEXCEPT noexcept
#else
// C++11
#  define CONSTDATA constexpr const
#  define CONSTCD11 constexpr
#  define CONSTCD14
#  define NOEXCEPT noexcept
#endif

#ifndef HAS_UNCAUGHT_EXCEPTIONS
#  if __cplusplus > 201703 || (defined(_MSVC_LANG) && _MSVC_LANG > 201703L)
#    define HAS_UNCAUGHT_EXCEPTIONS 1
#  else
#    define HAS_UNCAUGHT_EXCEPTIONS 0
#  endif
#endif  // HAS_UNCAUGHT_EXCEPTIONS

#ifndef HAS_VOID_T
#  if __cplusplus >= 201703 || (defined(_MSVC_LANG) && _MSVC_LANG >= 201703L)
#    define HAS_VOID_T 1
#  else
#    define HAS_VOID_T 0
#  endif
#endif  // HAS_VOID_T

// Protect from Oracle sun macro
#ifdef sun
#  undef sun
#endif

// Work around for a NVCC compiler bug which causes it to fail
// to compile std::ratio_{multiply,divide} when used directly
// in the std::chrono::duration template instantiations below
  namespace detail {
    template <typename R1, typename R2>
    using ratio_multiply = decltype(std::ratio_multiply<R1, R2>{});

    template <typename R1, typename R2>
    using ratio_divide = decltype(std::ratio_divide<R1, R2>{});
  }  // namespace detail

  //-----------+
  // Interface |
  //-----------+

  // durations

  using days = std::chrono::duration
    <int, detail::ratio_multiply<std::ratio<24>, std::chrono::hours::period>>;

  using weeks = std::chrono::duration
    <int, detail::ratio_multiply<std::ratio<7>, days::period>>;

  using years = std::chrono::duration
    <int, detail::ratio_multiply<std::ratio<146097, 400>, days::period>>;

  using months = std::chrono::duration
    <int, detail::ratio_divide<years::period, std::ratio<12>>>;

  // time_point

  template <class Duration>
  using sys_time = std::chrono::time_point<std::chrono::system_clock, Duration>;

  using sys_days = sys_time<days>;
  using sys_seconds = sys_time<std::chrono::seconds>;

  struct local_t {};

  template <class Duration>
  using local_time = std::chrono::time_point<local_t, Duration>;

  using local_seconds = local_time<std::chrono::seconds>;
  using local_days = local_time<days>;

  // types

  struct last_spec
  {
    explicit last_spec() = default;
  };

  class day;
  class month;
  class year;

  class weekday;
  class weekday_indexed;
  class weekday_last;

  class month_day;
  class month_day_last;
  class month_weekday;
  class month_weekday_last;

  class year_month;

  class year_month_day;
  class year_month_day_last;
  class year_month_weekday;
  class year_month_weekday_last;

  // date composition operators

  CONSTCD11 year_month operator/(const year& y, const month& m) NOEXCEPT;
  CONSTCD11 year_month operator/(const year& y, int          m) NOEXCEPT;

  CONSTCD11 month_day operator/(const day& d, const month& m) NOEXCEPT;
  CONSTCD11 month_day operator/(const day& d, int          m) NOEXCEPT;
  CONSTCD11 month_day operator/(const month& m, const day& d) NOEXCEPT;
  CONSTCD11 month_day operator/(const month& m, int        d) NOEXCEPT;
  CONSTCD11 month_day operator/(int          m, const day& d) NOEXCEPT;

  CONSTCD11 month_day_last operator/(const month& m, last_spec) NOEXCEPT;
  CONSTCD11 month_day_last operator/(int          m, last_spec) NOEXCEPT;
  CONSTCD11 month_day_last operator/(last_spec, const month& m) NOEXCEPT;
  CONSTCD11 month_day_last operator/(last_spec, int          m) NOEXCEPT;

  CONSTCD11 month_weekday operator/(const month& m, const weekday_indexed& wdi) NOEXCEPT;
  CONSTCD11 month_weekday operator/(int          m, const weekday_indexed& wdi) NOEXCEPT;
  CONSTCD11 month_weekday operator/(const weekday_indexed& wdi, const month& m) NOEXCEPT;
  CONSTCD11 month_weekday operator/(const weekday_indexed& wdi, int          m) NOEXCEPT;

  CONSTCD11 month_weekday_last operator/(const month& m, const weekday_last& wdl) NOEXCEPT;
  CONSTCD11 month_weekday_last operator/(int          m, const weekday_last& wdl) NOEXCEPT;
  CONSTCD11 month_weekday_last operator/(const weekday_last& wdl, const month& m) NOEXCEPT;
  CONSTCD11 month_weekday_last operator/(const weekday_last& wdl, int          m) NOEXCEPT;

  CONSTCD11 year_month_day operator/(const year_month& ym, const day& d) NOEXCEPT;
  CONSTCD11 year_month_day operator/(const year_month& ym, int        d) NOEXCEPT;
  CONSTCD11 year_month_day operator/(const year& y, const month_day& md) NOEXCEPT;
  CONSTCD11 year_month_day operator/(int         y, const month_day& md) NOEXCEPT;
  CONSTCD11 year_month_day operator/(const month_day& md, const year& y) NOEXCEPT;
  CONSTCD11 year_month_day operator/(const month_day& md, int         y) NOEXCEPT;

  CONSTCD11
    year_month_day_last operator/(const year_month& ym, last_spec) NOEXCEPT;
  CONSTCD11
    year_month_day_last operator/(const year& y, const month_day_last& mdl) NOEXCEPT;
  CONSTCD11
    year_month_day_last operator/(int         y, const month_day_last& mdl) NOEXCEPT;
  CONSTCD11
    year_month_day_last operator/(const month_day_last& mdl, const year& y) NOEXCEPT;
  CONSTCD11
    year_month_day_last operator/(const month_day_last& mdl, int         y) NOEXCEPT;

  CONSTCD11
    year_month_weekday
    operator/(const year_month& ym, const weekday_indexed& wdi) NOEXCEPT;

  CONSTCD11
    year_month_weekday
    operator/(const year& y, const month_weekday& mwd) NOEXCEPT;

  CONSTCD11
    year_month_weekday
    operator/(int                y, const month_weekday& mwd) NOEXCEPT;

  CONSTCD11
    year_month_weekday
    operator/(const month_weekday& mwd, const year& y) NOEXCEPT;

  CONSTCD11
    year_month_weekday
    operator/(const month_weekday& mwd, int                  y) NOEXCEPT;

  CONSTCD11
    year_month_weekday_last
    operator/(const year_month& ym, const weekday_last& wdl) NOEXCEPT;

  CONSTCD11
    year_month_weekday_last
    operator/(const year& y, const month_weekday_last& mwdl) NOEXCEPT;

  CONSTCD11
    year_month_weekday_last
    operator/(int         y, const month_weekday_last& mwdl) NOEXCEPT;

  CONSTCD11
    year_month_weekday_last
    operator/(const month_weekday_last& mwdl, const year& y) NOEXCEPT;

  CONSTCD11
    year_month_weekday_last
    operator/(const month_weekday_last& mwdl, int         y) NOEXCEPT;

  // Detailed interface

  // day

  class day
  {
    unsigned char d_;

  public:
    day() = default;
    explicit CONSTCD11 day(unsigned d) NOEXCEPT;

    CONSTCD14 day& operator++()    NOEXCEPT;
    CONSTCD14 day  operator++(int) NOEXCEPT;
    CONSTCD14 day& operator--()    NOEXCEPT;
    CONSTCD14 day  operator--(int) NOEXCEPT;

    CONSTCD14 day& operator+=(const days& d) NOEXCEPT;
    CONSTCD14 day& operator-=(const days& d) NOEXCEPT;

    CONSTCD11 explicit operator unsigned() const NOEXCEPT;
    CONSTCD11 bool ok() const NOEXCEPT;
  };

  CONSTCD11 bool operator==(const day& x, const day& y) NOEXCEPT;
  CONSTCD11 bool operator!=(const day& x, const day& y) NOEXCEPT;
  CONSTCD11 bool operator< (const day& x, const day& y) NOEXCEPT;
  CONSTCD11 bool operator> (const day& x, const day& y) NOEXCEPT;
  CONSTCD11 bool operator<=(const day& x, const day& y) NOEXCEPT;
  CONSTCD11 bool operator>=(const day& x, const day& y) NOEXCEPT;

  CONSTCD11 day  operator+(const day& x, const days& y) NOEXCEPT;
  CONSTCD11 day  operator+(const days& x, const day& y) NOEXCEPT;
  CONSTCD11 day  operator-(const day& x, const days& y) NOEXCEPT;
  CONSTCD11 days operator-(const day& x, const day& y) NOEXCEPT;

  template<class CharT, class Traits>
  std::basic_ostream<CharT, Traits>&
    operator<<(std::basic_ostream<CharT, Traits>& os, const day& d);

  // month

  class month
  {
    unsigned char m_;

  public:
    month() = default;
    explicit CONSTCD11 month(unsigned m) NOEXCEPT;

    CONSTCD14 month& operator++()    NOEXCEPT;
    CONSTCD14 month  operator++(int) NOEXCEPT;
    CONSTCD14 month& operator--()    NOEXCEPT;
    CONSTCD14 month  operator--(int) NOEXCEPT;

    CONSTCD14 month& operator+=(const months& m) NOEXCEPT;
    CONSTCD14 month& operator-=(const months& m) NOEXCEPT;

    CONSTCD11 explicit operator unsigned() const NOEXCEPT;
    CONSTCD11 bool ok() const NOEXCEPT;
  };

  CONSTCD11 bool operator==(const month& x, const month& y) NOEXCEPT;
  CONSTCD11 bool operator!=(const month& x, const month& y) NOEXCEPT;
  CONSTCD11 bool operator< (const month& x, const month& y) NOEXCEPT;
  CONSTCD11 bool operator> (const month& x, const month& y) NOEXCEPT;
  CONSTCD11 bool operator<=(const month& x, const month& y) NOEXCEPT;
  CONSTCD11 bool operator>=(const month& x, const month& y) NOEXCEPT;

  CONSTCD14 month  operator+(const month& x, const months& y) NOEXCEPT;
  CONSTCD14 month  operator+(const months& x, const month& y) NOEXCEPT;
  CONSTCD14 month  operator-(const month& x, const months& y) NOEXCEPT;
  CONSTCD14 months operator-(const month& x, const month& y) NOEXCEPT;

  template<class CharT, class Traits>
  std::basic_ostream<CharT, Traits>&
    operator<<(std::basic_ostream<CharT, Traits>& os, const month& m);

  // year

  class year
  {
    short y_;

  public:
    year() = default;
    explicit CONSTCD11 year(int y) NOEXCEPT;

    CONSTCD14 year& operator++()    NOEXCEPT;
    CONSTCD14 year  operator++(int) NOEXCEPT;
    CONSTCD14 year& operator--()    NOEXCEPT;
    CONSTCD14 year  operator--(int) NOEXCEPT;

    CONSTCD14 year& operator+=(const years& y) NOEXCEPT;
    CONSTCD14 year& operator-=(const years& y) NOEXCEPT;

    CONSTCD11 year operator-() const NOEXCEPT;
    CONSTCD11 year operator+() const NOEXCEPT;

    CONSTCD11 bool is_leap() const NOEXCEPT;

    CONSTCD11 explicit operator int() const NOEXCEPT;
    CONSTCD11 bool ok() const NOEXCEPT;

    static CONSTCD11 year min() NOEXCEPT { return year{ -32767 }; }
    static CONSTCD11 year max() NOEXCEPT { return year{ 32767 }; }
  };

  CONSTCD11 bool operator==(const year& x, const year& y) NOEXCEPT;
  CONSTCD11 bool operator!=(const year& x, const year& y) NOEXCEPT;
  CONSTCD11 bool operator< (const year& x, const year& y) NOEXCEPT;
  CONSTCD11 bool operator> (const year& x, const year& y) NOEXCEPT;
  CONSTCD11 bool operator<=(const year& x, const year& y) NOEXCEPT;
  CONSTCD11 bool operator>=(const year& x, const year& y) NOEXCEPT;

  CONSTCD11 year  operator+(const year& x, const years& y) NOEXCEPT;
  CONSTCD11 year  operator+(const years& x, const year& y) NOEXCEPT;
  CONSTCD11 year  operator-(const year& x, const years& y) NOEXCEPT;
  CONSTCD11 years operator-(const year& x, const year& y) NOEXCEPT;

  template<class CharT, class Traits>
  std::basic_ostream<CharT, Traits>&
    operator<<(std::basic_ostream<CharT, Traits>& os, const year& y);

  // weekday

  class weekday
  {
    unsigned char wd_;
  public:
    weekday() = default;
    explicit CONSTCD11 weekday(unsigned wd) NOEXCEPT;
    CONSTCD14 weekday(const sys_days& dp) NOEXCEPT;
    CONSTCD14 explicit weekday(const local_days& dp) NOEXCEPT;

    CONSTCD14 weekday& operator++()    NOEXCEPT;
    CONSTCD14 weekday  operator++(int) NOEXCEPT;
    CONSTCD14 weekday& operator--()    NOEXCEPT;
    CONSTCD14 weekday  operator--(int) NOEXCEPT;

    CONSTCD14 weekday& operator+=(const days& d) NOEXCEPT;
    CONSTCD14 weekday& operator-=(const days& d) NOEXCEPT;

    CONSTCD11 bool ok() const NOEXCEPT;

    CONSTCD11 unsigned c_encoding() const NOEXCEPT;
    CONSTCD11 unsigned iso_encoding() const NOEXCEPT;

    CONSTCD11 weekday_indexed operator[](unsigned index) const NOEXCEPT;
    CONSTCD11 weekday_last    operator[](last_spec)      const NOEXCEPT;

  private:
    static CONSTCD14 unsigned char weekday_from_days(int z) NOEXCEPT;

    friend CONSTCD11 bool operator==(const weekday& x, const weekday& y) NOEXCEPT;
    friend CONSTCD14 days operator-(const weekday& x, const weekday& y) NOEXCEPT;
    friend CONSTCD14 weekday operator+(const weekday& x, const days& y) NOEXCEPT;
    template<class CharT, class Traits>
    friend std::basic_ostream<CharT, Traits>&
      operator<<(std::basic_ostream<CharT, Traits>& os, const weekday& wd);
    friend class weekday_indexed;
  };

  CONSTCD11 bool operator==(const weekday& x, const weekday& y) NOEXCEPT;
  CONSTCD11 bool operator!=(const weekday& x, const weekday& y) NOEXCEPT;

  CONSTCD14 weekday operator+(const weekday& x, const days& y) NOEXCEPT;
  CONSTCD14 weekday operator+(const days& x, const weekday& y) NOEXCEPT;
  CONSTCD14 weekday operator-(const weekday& x, const days& y) NOEXCEPT;
  CONSTCD14 days    operator-(const weekday& x, const weekday& y) NOEXCEPT;

  template<class CharT, class Traits>
  std::basic_ostream<CharT, Traits>&
    operator<<(std::basic_ostream<CharT, Traits>& os, const weekday& wd);

  // weekday_indexed

  class weekday_indexed
  {
    unsigned char wd_ : 4;
    unsigned char index_ : 4;

  public:
    weekday_indexed() = default;
    CONSTCD11 weekday_indexed(const date::weekday& wd, unsigned index) NOEXCEPT;

    CONSTCD11 date::weekday weekday() const NOEXCEPT;
    CONSTCD11 unsigned index() const NOEXCEPT;
    CONSTCD11 bool ok() const NOEXCEPT;
  };

  CONSTCD11 bool operator==(const weekday_indexed& x, const weekday_indexed& y) NOEXCEPT;
  CONSTCD11 bool operator!=(const weekday_indexed& x, const weekday_indexed& y) NOEXCEPT;

  template<class CharT, class Traits>
  std::basic_ostream<CharT, Traits>&
    operator<<(std::basic_ostream<CharT, Traits>& os, const weekday_indexed& wdi);

  // weekday_last

  class weekday_last
  {
    date::weekday wd_;

  public:
    explicit CONSTCD11 weekday_last(const date::weekday& wd) NOEXCEPT;

    CONSTCD11 date::weekday weekday() const NOEXCEPT;
    CONSTCD11 bool ok() const NOEXCEPT;
  };

  CONSTCD11 bool operator==(const weekday_last& x, const weekday_last& y) NOEXCEPT;
  CONSTCD11 bool operator!=(const weekday_last& x, const weekday_last& y) NOEXCEPT;

  template<class CharT, class Traits>
  std::basic_ostream<CharT, Traits>&
    operator<<(std::basic_ostream<CharT, Traits>& os, const weekday_last& wdl);

  namespace detail
  {

    struct unspecified_month_disambiguator {};

  }  // namespace detail

  // year_month

  class year_month
  {
    date::year  y_;
    date::month m_;

  public:
    year_month() = default;
    CONSTCD11 year_month(const date::year& y, const date::month& m) NOEXCEPT;

    CONSTCD11 date::year  year()  const NOEXCEPT;
    CONSTCD11 date::month month() const NOEXCEPT;

    template<class = detail::unspecified_month_disambiguator>
    CONSTCD14 year_month& operator+=(const months& dm) NOEXCEPT;
    template<class = detail::unspecified_month_disambiguator>
    CONSTCD14 year_month& operator-=(const months& dm) NOEXCEPT;
    CONSTCD14 year_month& operator+=(const years& dy) NOEXCEPT;
    CONSTCD14 year_month& operator-=(const years& dy) NOEXCEPT;

    CONSTCD11 bool ok() const NOEXCEPT;
  };

  CONSTCD11 bool operator==(const year_month& x, const year_month& y) NOEXCEPT;
  CONSTCD11 bool operator!=(const year_month& x, const year_month& y) NOEXCEPT;
  CONSTCD11 bool operator< (const year_month& x, const year_month& y) NOEXCEPT;
  CONSTCD11 bool operator> (const year_month& x, const year_month& y) NOEXCEPT;
  CONSTCD11 bool operator<=(const year_month& x, const year_month& y) NOEXCEPT;
  CONSTCD11 bool operator>=(const year_month& x, const year_month& y) NOEXCEPT;

  template<class = detail::unspecified_month_disambiguator>
  CONSTCD14 year_month operator+(const year_month& ym, const months& dm) NOEXCEPT;
  template<class = detail::unspecified_month_disambiguator>
  CONSTCD14 year_month operator+(const months& dm, const year_month& ym) NOEXCEPT;
  template<class = detail::unspecified_month_disambiguator>
  CONSTCD14 year_month operator-(const year_month& ym, const months& dm) NOEXCEPT;

  CONSTCD11 months operator-(const year_month& x, const year_month& y) NOEXCEPT;
  CONSTCD11 year_month operator+(const year_month& ym, const years& dy) NOEXCEPT;
  CONSTCD11 year_month operator+(const years& dy, const year_month& ym) NOEXCEPT;
  CONSTCD11 year_month operator-(const year_month& ym, const years& dy) NOEXCEPT;

  template<class CharT, class Traits>
  std::basic_ostream<CharT, Traits>&
    operator<<(std::basic_ostream<CharT, Traits>& os, const year_month& ym);

  // month_day

  class month_day
  {
    date::month m_;
    date::day   d_;

  public:
    month_day() = default;
    CONSTCD11 month_day(const date::month& m, const date::day& d) NOEXCEPT;

    CONSTCD11 date::month month() const NOEXCEPT;
    CONSTCD11 date::day   day() const NOEXCEPT;

    CONSTCD14 bool ok() const NOEXCEPT;
  };

  CONSTCD11 bool operator==(const month_day& x, const month_day& y) NOEXCEPT;
  CONSTCD11 bool operator!=(const month_day& x, const month_day& y) NOEXCEPT;
  CONSTCD11 bool operator< (const month_day& x, const month_day& y) NOEXCEPT;
  CONSTCD11 bool operator> (const month_day& x, const month_day& y) NOEXCEPT;
  CONSTCD11 bool operator<=(const month_day& x, const month_day& y) NOEXCEPT;
  CONSTCD11 bool operator>=(const month_day& x, const month_day& y) NOEXCEPT;

  template<class CharT, class Traits>
  std::basic_ostream<CharT, Traits>&
    operator<<(std::basic_ostream<CharT, Traits>& os, const month_day& md);

  // month_day_last

  class month_day_last
  {
    date::month m_;

  public:
    CONSTCD11 explicit month_day_last(const date::month& m) NOEXCEPT;

    CONSTCD11 date::month month() const NOEXCEPT;
    CONSTCD11 bool ok() const NOEXCEPT;
  };

  CONSTCD11 bool operator==(const month_day_last& x, const month_day_last& y) NOEXCEPT;
  CONSTCD11 bool operator!=(const month_day_last& x, const month_day_last& y) NOEXCEPT;
  CONSTCD11 bool operator< (const month_day_last& x, const month_day_last& y) NOEXCEPT;
  CONSTCD11 bool operator> (const month_day_last& x, const month_day_last& y) NOEXCEPT;
  CONSTCD11 bool operator<=(const month_day_last& x, const month_day_last& y) NOEXCEPT;
  CONSTCD11 bool operator>=(const month_day_last& x, const month_day_last& y) NOEXCEPT;

  template<class CharT, class Traits>
  std::basic_ostream<CharT, Traits>&
    operator<<(std::basic_ostream<CharT, Traits>& os, const month_day_last& mdl);

  // month_weekday

  class month_weekday
  {
    date::month           m_;
    date::weekday_indexed wdi_;
  public:
    CONSTCD11 month_weekday(const date::month& m,
      const date::weekday_indexed& wdi) NOEXCEPT;

    CONSTCD11 date::month           month()           const NOEXCEPT;
    CONSTCD11 date::weekday_indexed weekday_indexed() const NOEXCEPT;

    CONSTCD11 bool ok() const NOEXCEPT;
  };

  CONSTCD11 bool operator==(const month_weekday& x, const month_weekday& y) NOEXCEPT;
  CONSTCD11 bool operator!=(const month_weekday& x, const month_weekday& y) NOEXCEPT;

  template<class CharT, class Traits>
  std::basic_ostream<CharT, Traits>&
    operator<<(std::basic_ostream<CharT, Traits>& os, const month_weekday& mwd);

  // month_weekday_last

  class month_weekday_last
  {
    date::month        m_;
    date::weekday_last wdl_;

  public:
    CONSTCD11 month_weekday_last(const date::month& m,
      const date::weekday_last& wd) NOEXCEPT;

    CONSTCD11 date::month        month()        const NOEXCEPT;
    CONSTCD11 date::weekday_last weekday_last() const NOEXCEPT;

    CONSTCD11 bool ok() const NOEXCEPT;
  };

  CONSTCD11
    bool operator==(const month_weekday_last& x, const month_weekday_last& y) NOEXCEPT;
  CONSTCD11
    bool operator!=(const month_weekday_last& x, const month_weekday_last& y) NOEXCEPT;

  template<class CharT, class Traits>
  std::basic_ostream<CharT, Traits>&
    operator<<(std::basic_ostream<CharT, Traits>& os, const month_weekday_last& mwdl);

  // class year_month_day

  class year_month_day
  {
    date::year  y_;
    date::month m_;
    date::day   d_;

  public:
    year_month_day() = default;
    CONSTCD11 year_month_day(const date::year& y, const date::month& m,
      const date::day& d) NOEXCEPT;
    CONSTCD14 year_month_day(const year_month_day_last& ymdl) NOEXCEPT;

    CONSTCD14 year_month_day(sys_days dp) NOEXCEPT;
    CONSTCD14 explicit year_month_day(local_days dp) NOEXCEPT;

    template<class = detail::unspecified_month_disambiguator>
    CONSTCD14 year_month_day& operator+=(const months& m) NOEXCEPT;
    template<class = detail::unspecified_month_disambiguator>
    CONSTCD14 year_month_day& operator-=(const months& m) NOEXCEPT;
    CONSTCD14 year_month_day& operator+=(const years& y)  NOEXCEPT;
    CONSTCD14 year_month_day& operator-=(const years& y)  NOEXCEPT;

    CONSTCD11 date::year  year()  const NOEXCEPT;
    CONSTCD11 date::month month() const NOEXCEPT;
    CONSTCD11 date::day   day()   const NOEXCEPT;

    CONSTCD14 operator sys_days() const NOEXCEPT;
    CONSTCD14 explicit operator local_days() const NOEXCEPT;
    CONSTCD14 bool ok() const NOEXCEPT;

  private:
    static CONSTCD14 year_month_day from_days(days dp) NOEXCEPT;
    CONSTCD14 days to_days() const NOEXCEPT;
  };

  CONSTCD11 bool operator==(const year_month_day& x, const year_month_day& y) NOEXCEPT;
  CONSTCD11 bool operator!=(const year_month_day& x, const year_month_day& y) NOEXCEPT;
  CONSTCD11 bool operator< (const year_month_day& x, const year_month_day& y) NOEXCEPT;
  CONSTCD11 bool operator> (const year_month_day& x, const year_month_day& y) NOEXCEPT;
  CONSTCD11 bool operator<=(const year_month_day& x, const year_month_day& y) NOEXCEPT;
  CONSTCD11 bool operator>=(const year_month_day& x, const year_month_day& y) NOEXCEPT;

  template<class = detail::unspecified_month_disambiguator>
  CONSTCD14 year_month_day operator+(const year_month_day& ymd, const months& dm) NOEXCEPT;
  template<class = detail::unspecified_month_disambiguator>
  CONSTCD14 year_month_day operator+(const months& dm, const year_month_day& ymd) NOEXCEPT;
  template<class = detail::unspecified_month_disambiguator>
  CONSTCD14 year_month_day operator-(const year_month_day& ymd, const months& dm) NOEXCEPT;
  CONSTCD11 year_month_day operator+(const year_month_day& ymd, const years& dy)  NOEXCEPT;
  CONSTCD11 year_month_day operator+(const years& dy, const year_month_day& ymd)  NOEXCEPT;
  CONSTCD11 year_month_day operator-(const year_month_day& ymd, const years& dy)  NOEXCEPT;

  template<class CharT, class Traits>
  std::basic_ostream<CharT, Traits>&
    operator<<(std::basic_ostream<CharT, Traits>& os, const year_month_day& ymd);

  // year_month_day_last

  class year_month_day_last
  {
    date::year           y_;
    date::month_day_last mdl_;

  public:
    CONSTCD11 year_month_day_last(const date::year& y,
      const date::month_day_last& mdl) NOEXCEPT;

    template<class = detail::unspecified_month_disambiguator>
    CONSTCD14 year_month_day_last& operator+=(const months& m) NOEXCEPT;
    template<class = detail::unspecified_month_disambiguator>
    CONSTCD14 year_month_day_last& operator-=(const months& m) NOEXCEPT;
    CONSTCD14 year_month_day_last& operator+=(const years& y)  NOEXCEPT;
    CONSTCD14 year_month_day_last& operator-=(const years& y)  NOEXCEPT;

    CONSTCD11 date::year           year()           const NOEXCEPT;
    CONSTCD11 date::month          month()          const NOEXCEPT;
    CONSTCD11 date::month_day_last month_day_last() const NOEXCEPT;
    CONSTCD14 date::day            day()            const NOEXCEPT;

    CONSTCD14 operator sys_days() const NOEXCEPT;
    CONSTCD14 explicit operator local_days() const NOEXCEPT;
    CONSTCD11 bool ok() const NOEXCEPT;
  };

  CONSTCD11
    bool operator==(const year_month_day_last& x, const year_month_day_last& y) NOEXCEPT;
  CONSTCD11
    bool operator!=(const year_month_day_last& x, const year_month_day_last& y) NOEXCEPT;
  CONSTCD11
    bool operator< (const year_month_day_last& x, const year_month_day_last& y) NOEXCEPT;
  CONSTCD11
    bool operator> (const year_month_day_last& x, const year_month_day_last& y) NOEXCEPT;
  CONSTCD11
    bool operator<=(const year_month_day_last& x, const year_month_day_last& y) NOEXCEPT;
  CONSTCD11
    bool operator>=(const year_month_day_last& x, const year_month_day_last& y) NOEXCEPT;

  template<class = detail::unspecified_month_disambiguator>
  CONSTCD14
    year_month_day_last
    operator+(const year_month_day_last& ymdl, const months& dm) NOEXCEPT;

  template<class = detail::unspecified_month_disambiguator>
  CONSTCD14
    year_month_day_last
    operator+(const months& dm, const year_month_day_last& ymdl) NOEXCEPT;

  CONSTCD11
    year_month_day_last
    operator+(const year_month_day_last& ymdl, const years& dy) NOEXCEPT;

  CONSTCD11
    year_month_day_last
    operator+(const years& dy, const year_month_day_last& ymdl) NOEXCEPT;

  template<class = detail::unspecified_month_disambiguator>
  CONSTCD14
    year_month_day_last
    operator-(const year_month_day_last& ymdl, const months& dm) NOEXCEPT;

  CONSTCD11
    year_month_day_last
    operator-(const year_month_day_last& ymdl, const years& dy) NOEXCEPT;

  template<class CharT, class Traits>
  std::basic_ostream<CharT, Traits>&
    operator<<(std::basic_ostream<CharT, Traits>& os, const year_month_day_last& ymdl);

  // year_month_weekday

  class year_month_weekday
  {
    date::year            y_;
    date::month           m_;
    date::weekday_indexed wdi_;

  public:
    year_month_weekday() = default;
    CONSTCD11 year_month_weekday(const date::year& y, const date::month& m,
      const date::weekday_indexed& wdi) NOEXCEPT;
    CONSTCD14 year_month_weekday(const sys_days& dp) NOEXCEPT;
    CONSTCD14 explicit year_month_weekday(const local_days& dp) NOEXCEPT;

    template<class = detail::unspecified_month_disambiguator>
    CONSTCD14 year_month_weekday& operator+=(const months& m) NOEXCEPT;
    template<class = detail::unspecified_month_disambiguator>
    CONSTCD14 year_month_weekday& operator-=(const months& m) NOEXCEPT;
    CONSTCD14 year_month_weekday& operator+=(const years& y)  NOEXCEPT;
    CONSTCD14 year_month_weekday& operator-=(const years& y)  NOEXCEPT;

    CONSTCD11 date::year year() const NOEXCEPT;
    CONSTCD11 date::month month() const NOEXCEPT;
    CONSTCD11 date::weekday weekday() const NOEXCEPT;
    CONSTCD11 unsigned index() const NOEXCEPT;
    CONSTCD11 date::weekday_indexed weekday_indexed() const NOEXCEPT;

    CONSTCD14 operator sys_days() const NOEXCEPT;
    CONSTCD14 explicit operator local_days() const NOEXCEPT;
    CONSTCD14 bool ok() const NOEXCEPT;

  private:
    static CONSTCD14 year_month_weekday from_days(days dp) NOEXCEPT;
    CONSTCD14 days to_days() const NOEXCEPT;
  };

  CONSTCD11
    bool operator==(const year_month_weekday& x, const year_month_weekday& y) NOEXCEPT;
  CONSTCD11
    bool operator!=(const year_month_weekday& x, const year_month_weekday& y) NOEXCEPT;

  template<class = detail::unspecified_month_disambiguator>
  CONSTCD14
    year_month_weekday
    operator+(const year_month_weekday& ymwd, const months& dm) NOEXCEPT;

  template<class = detail::unspecified_month_disambiguator>
  CONSTCD14
    year_month_weekday
    operator+(const months& dm, const year_month_weekday& ymwd) NOEXCEPT;

  CONSTCD11
    year_month_weekday
    operator+(const year_month_weekday& ymwd, const years& dy) NOEXCEPT;

  CONSTCD11
    year_month_weekday
    operator+(const years& dy, const year_month_weekday& ymwd) NOEXCEPT;

  template<class = detail::unspecified_month_disambiguator>
  CONSTCD14
    year_month_weekday
    operator-(const year_month_weekday& ymwd, const months& dm) NOEXCEPT;

  CONSTCD11
    year_month_weekday
    operator-(const year_month_weekday& ymwd, const years& dy) NOEXCEPT;

  template<class CharT, class Traits>
  std::basic_ostream<CharT, Traits>&
    operator<<(std::basic_ostream<CharT, Traits>& os, const year_month_weekday& ymwdi);

  // year_month_weekday_last

  class year_month_weekday_last
  {
    date::year y_;
    date::month m_;
    date::weekday_last wdl_;

  public:
    CONSTCD11 year_month_weekday_last(const date::year& y, const date::month& m,
      const date::weekday_last& wdl) NOEXCEPT;

    template<class = detail::unspecified_month_disambiguator>
    CONSTCD14 year_month_weekday_last& operator+=(const months& m) NOEXCEPT;
    template<class = detail::unspecified_month_disambiguator>
    CONSTCD14 year_month_weekday_last& operator-=(const months& m) NOEXCEPT;
    CONSTCD14 year_month_weekday_last& operator+=(const years& y) NOEXCEPT;
    CONSTCD14 year_month_weekday_last& operator-=(const years& y) NOEXCEPT;

    CONSTCD11 date::year year() const NOEXCEPT;
    CONSTCD11 date::month month() const NOEXCEPT;
    CONSTCD11 date::weekday weekday() const NOEXCEPT;
    CONSTCD11 date::weekday_last weekday_last() const NOEXCEPT;

    CONSTCD14 operator sys_days() const NOEXCEPT;
    CONSTCD14 explicit operator local_days() const NOEXCEPT;
    CONSTCD11 bool ok() const NOEXCEPT;

  private:
    CONSTCD14 days to_days() const NOEXCEPT;
  };

  CONSTCD11
    bool
    operator==(const year_month_weekday_last& x, const year_month_weekday_last& y) NOEXCEPT;

  CONSTCD11
    bool
    operator!=(const year_month_weekday_last& x, const year_month_weekday_last& y) NOEXCEPT;

  template<class = detail::unspecified_month_disambiguator>
  CONSTCD14
    year_month_weekday_last
    operator+(const year_month_weekday_last& ymwdl, const months& dm) NOEXCEPT;

  template<class = detail::unspecified_month_disambiguator>
  CONSTCD14
    year_month_weekday_last
    operator+(const months& dm, const year_month_weekday_last& ymwdl) NOEXCEPT;

  CONSTCD11
    year_month_weekday_last
    operator+(const year_month_weekday_last& ymwdl, const years& dy) NOEXCEPT;

  CONSTCD11
    year_month_weekday_last
    operator+(const years& dy, const year_month_weekday_last& ymwdl) NOEXCEPT;

  template<class = detail::unspecified_month_disambiguator>
  CONSTCD14
    year_month_weekday_last
    operator-(const year_month_weekday_last& ymwdl, const months& dm) NOEXCEPT;

  CONSTCD11
    year_month_weekday_last
    operator-(const year_month_weekday_last& ymwdl, const years& dy) NOEXCEPT;

  template<class CharT, class Traits>
  std::basic_ostream<CharT, Traits>&
    operator<<(std::basic_ostream<CharT, Traits>& os, const year_month_weekday_last& ymwdl);

#if !defined(_MSC_VER) || (_MSC_VER >= 1900)
  inline namespace literals
  {

    CONSTCD11 date::day  operator "" _d(unsigned long long d) NOEXCEPT;
    CONSTCD11 date::year operator "" _y(unsigned long long y) NOEXCEPT;

  }  // inline namespace literals
#endif // !defined(_MSC_VER) || (_MSC_VER >= 1900)

// CONSTDATA date::month January{1};
// CONSTDATA date::month February{2};
// CONSTDATA date::month March{3};
// CONSTDATA date::month April{4};
// CONSTDATA date::month May{5};
// CONSTDATA date::month June{6};
// CONSTDATA date::month July{7};
// CONSTDATA date::month August{8};
// CONSTDATA date::month September{9};
// CONSTDATA date::month October{10};
// CONSTDATA date::month November{11};
// CONSTDATA date::month December{12};
//
// CONSTDATA date::weekday Sunday{0u};
// CONSTDATA date::weekday Monday{1u};
// CONSTDATA date::weekday Tuesday{2u};
// CONSTDATA date::weekday Wednesday{3u};
// CONSTDATA date::weekday Thursday{4u};
// CONSTDATA date::weekday Friday{5u};
// CONSTDATA date::weekday Saturday{6u};

#if HAS_VOID_T

  template <class T, class = std::void_t<>>
  struct is_clock
    : std::false_type
  {};

  template <class T>
  struct is_clock<T, std::void_t<decltype(T::now()), typename T::rep, typename T::period,
    typename T::duration, typename T::time_point,
    decltype(T::is_steady)>>
    : std::true_type
  {};

#endif  // HAS_VOID_T

  //----------------+
  // Implementation |
  //----------------+

  // utilities
  namespace detail {

    template<class CharT, class Traits = std::char_traits<CharT>>
    class save_istream
    {
    protected:
      std::basic_ios<CharT, Traits>& is_;
      CharT fill_;
      std::ios::fmtflags flags_;
      std::streamsize width_;
      std::basic_ostream<CharT, Traits>* tie_;
      std::locale loc_;

    public:
      ~save_istream()
      {
        is_.fill(fill_);
        is_.flags(flags_);
        is_.width(width_);
        is_.imbue(loc_);
        is_.tie(tie_);
      }

      save_istream(const save_istream&) = delete;
      save_istream& operator=(const save_istream&) = delete;

      explicit save_istream(std::basic_ios<CharT, Traits>& is)
        : is_(is)
        , fill_(is.fill())
        , flags_(is.flags())
        , width_(is.width(0))
        , tie_(is.tie(nullptr))
        , loc_(is.getloc())
      {
        if (tie_ != nullptr)
          tie_->flush();
      }
    };

    template<class CharT, class Traits = std::char_traits<CharT>>
    class save_ostream
      : private save_istream<CharT, Traits>
    {
    public:
      ~save_ostream()
      {
        if ((this->flags_ & std::ios::unitbuf) &&
#if HAS_UNCAUGHT_EXCEPTIONS
          std::uncaught_exceptions() == 0 &&
#else
          !std::uncaught_exceptions() &&
#endif
          this->is_.good())
          this->is_.rdbuf()->pubsync();
      }

      save_ostream(const save_ostream&) = delete;
      save_ostream& operator=(const save_ostream&) = delete;

      explicit save_ostream(std::basic_ios<CharT, Traits>& os)
        : save_istream<CharT, Traits>(os)
      {
      }
    };

    template <class T>
    struct choose_trunc_type
    {
      static const int digits = std::numeric_limits<T>::digits;
      using type = typename std::conditional
        <
        digits < 32,
        std::int32_t,
        typename std::conditional
        <
        digits < 64,
        std::int64_t,
#ifdef __SIZEOF_INT128__
        __int128
#else
        std::int64_t
#endif
        >::type
        >::type;
    };

    template <class T>
    CONSTCD11
      inline
      typename std::enable_if
      <
      !std::chrono::treat_as_floating_point<T>::value,
      T
      >::type
      trunc(T t) NOEXCEPT
    {
      return t;
    }

    template <class T>
    CONSTCD14
      inline
      typename std::enable_if
      <
      std::chrono::treat_as_floating_point<T>::value,
      T
      >::type
      trunc(T t) NOEXCEPT
    {
      using std::numeric_limits;
      using I = typename choose_trunc_type<T>::type;
      CONSTDATA auto digits = numeric_limits<T>::digits;
      static_assert(digits < numeric_limits<I>::digits, "");
      CONSTDATA auto max = I{ 1 } << (digits - 1);
      CONSTDATA auto min = -max;
      const auto negative = t < T{ 0 };
      if (min <= t && t <= max && t != 0 && t == t)
      {
        t = static_cast<T>(static_cast<I>(t));
        if (t == 0 && negative)
          t = -t;
      }
      return t;
    }

    template <std::intmax_t Xp, std::intmax_t Yp>
    struct static_gcd
    {
      static const std::intmax_t value = static_gcd<Yp, Xp % Yp>::value;
    };

    template <std::intmax_t Xp>
    struct static_gcd<Xp, 0>
    {
      static const std::intmax_t value = Xp;
    };

    template <>
    struct static_gcd<0, 0>
    {
      static const std::intmax_t value = 1;
    };

    template <class R1, class R2>
    struct no_overflow
    {
    private:
      static const std::intmax_t gcd_n1_n2 = static_gcd<R1::num, R2::num>::value;
      static const std::intmax_t gcd_d1_d2 = static_gcd<R1::den, R2::den>::value;
      static const std::intmax_t n1 = R1::num / gcd_n1_n2;
      static const std::intmax_t d1 = R1::den / gcd_d1_d2;
      static const std::intmax_t n2 = R2::num / gcd_n1_n2;
      static const std::intmax_t d2 = R2::den / gcd_d1_d2;
      static const std::intmax_t max = std::numeric_limits<std::intmax_t>::max();

      template <std::intmax_t Xp, std::intmax_t Yp, bool overflow>
      struct mul    // overflow == false
      {
        static const std::intmax_t value = Xp * Yp;
      };

      template <std::intmax_t Xp, std::intmax_t Yp>
      struct mul<Xp, Yp, true>
      {
        static const std::intmax_t value = 1;
      };

    public:
      static const bool value = (n1 <= max / d2) && (n2 <= max / d1);
      typedef std::ratio<mul<n1, d2, !value>::value,
        mul<n2, d1, !value>::value> type;
    };

  }  // detail

  // trunc towards zero
  template <class To, class Rep, class Period>
  CONSTCD11
    inline
    typename std::enable_if
    <
    detail::no_overflow<Period, typename To::period>::value,
    To
    >::type
    trunc(const std::chrono::duration<Rep, Period>& d)
  {
    return To{ detail::trunc(std::chrono::duration_cast<To>(d).count()) };
  }

  template <class To, class Rep, class Period>
  CONSTCD11
    inline
    typename std::enable_if
    <
    !detail::no_overflow<Period, typename To::period>::value,
    To
    >::type
    trunc(const std::chrono::duration<Rep, Period>& d)
  {
    using std::chrono::duration_cast;
    using std::chrono::duration;
    using rep = typename std::common_type<Rep, typename To::rep>::type;
    return To{ detail::trunc(duration_cast<To>(duration_cast<duration<rep>>(d)).count()) };
  }

#ifndef HAS_CHRONO_ROUNDING
#  if defined(_MSC_FULL_VER) && (_MSC_FULL_VER >= 190023918 || (_MSC_FULL_VER >= 190000000 && defined (__clang__)))
#    define HAS_CHRONO_ROUNDING 1
#  elif defined(__cpp_lib_chrono) && __cplusplus > 201402 && __cpp_lib_chrono >= 201510
#    define HAS_CHRONO_ROUNDING 1
#  elif defined(_LIBCPP_VERSION) && __cplusplus > 201402 && _LIBCPP_VERSION >= 3800
#    define HAS_CHRONO_ROUNDING 1
#  else
#    define HAS_CHRONO_ROUNDING 0
#  endif
#endif  // HAS_CHRONO_ROUNDING

#if HAS_CHRONO_ROUNDING == 0

  // round down
  template <class To, class Rep, class Period>
  CONSTCD14
    inline
    typename std::enable_if
    <
    detail::no_overflow<Period, typename To::period>::value,
    To
    >::type
    floor(const std::chrono::duration<Rep, Period>& d)
  {
    auto t = trunc<To>(d);
    if (t > d)
      return t - To{ 1 };
    return t;
  }

  template <class To, class Rep, class Period>
  CONSTCD14
    inline
    typename std::enable_if
    <
    !detail::no_overflow<Period, typename To::period>::value,
    To
    >::type
    floor(const std::chrono::duration<Rep, Period>& d)
  {
    using rep = typename std::common_type<Rep, typename To::rep>::type;
    return floor<To>(floor<std::chrono::duration<rep>>(d));
  }

  // round to nearest, to even on tie
  template <class To, class Rep, class Period>
  CONSTCD14
    inline
    To
    round(const std::chrono::duration<Rep, Period>& d)
  {
    auto t0 = floor<To>(d);
    auto t1 = t0 + To{ 1 };
    if (t1 == To{ 0 } && t0 < To{ 0 })
      t1 = -t1;
    auto diff0 = d - t0;
    auto diff1 = t1 - d;
    if (diff0 == diff1)
    {
      if (t0 - trunc<To>(t0 / 2) * 2 == To{ 0 })
        return t0;
      return t1;
    }
    if (diff0 < diff1)
      return t0;
    return t1;
  }

  // round up
  template <class To, class Rep, class Period>
  CONSTCD14
    inline
    To
    ceil(const std::chrono::duration<Rep, Period>& d)
  {
    auto t = trunc<To>(d);
    if (t < d)
      return t + To{ 1 };
    return t;
  }

  template <class Rep, class Period,
    class = typename std::enable_if
    <
    std::numeric_limits<Rep>::is_signed
  >::type>
    CONSTCD11
    std::chrono::duration<Rep, Period>
    abs(std::chrono::duration<Rep, Period> d)
  {
    return d >= d.zero() ? d : -d;
  }

  // round down
  template <class To, class Clock, class FromDuration>
  CONSTCD11
    inline
    std::chrono::time_point<Clock, To>
    floor(const std::chrono::time_point<Clock, FromDuration>& tp)
  {
    using std::chrono::time_point;
    return time_point<Clock, To>{date::floor<To>(tp.time_since_epoch())};
  }

  // round to nearest, to even on tie
  template <class To, class Clock, class FromDuration>
  CONSTCD11
    inline
    std::chrono::time_point<Clock, To>
    round(const std::chrono::time_point<Clock, FromDuration>& tp)
  {
    using std::chrono::time_point;
    return time_point<Clock, To>{round<To>(tp.time_since_epoch())};
  }

  // round up
  template <class To, class Clock, class FromDuration>
  CONSTCD11
    inline
    std::chrono::time_point<Clock, To>
    ceil(const std::chrono::time_point<Clock, FromDuration>& tp)
  {
    using std::chrono::time_point;
    return time_point<Clock, To>{ceil<To>(tp.time_since_epoch())};
  }

#else  // HAS_CHRONO_ROUNDING == 1

  using std::chrono::floor;
  using std::chrono::ceil;
  using std::chrono::round;
  using std::chrono::abs;

#endif  // HAS_CHRONO_ROUNDING

  // trunc towards zero
  template <class To, class Clock, class FromDuration>
  CONSTCD11
    inline
    std::chrono::time_point<Clock, To>
    trunc(const std::chrono::time_point<Clock, FromDuration>& tp)
  {
    using std::chrono::time_point;
    return time_point<Clock, To>{trunc<To>(tp.time_since_epoch())};
  }

  // day

  CONSTCD11 inline day::day(unsigned d) NOEXCEPT : d_(static_cast<decltype(d_)>(d)) {}
  CONSTCD14 inline day& day::operator++() NOEXCEPT { ++d_; return *this; }
  CONSTCD14 inline day day::operator++(int) NOEXCEPT { auto tmp(*this); ++(*this); return tmp; }
  CONSTCD14 inline day& day::operator--() NOEXCEPT { --d_; return *this; }
  CONSTCD14 inline day day::operator--(int) NOEXCEPT { auto tmp(*this); --(*this); return tmp; }
  CONSTCD14 inline day& day::operator+=(const days& d) NOEXCEPT { *this = *this + d; return *this; }
  CONSTCD14 inline day& day::operator-=(const days& d) NOEXCEPT { *this = *this - d; return *this; }
  CONSTCD11 inline day::operator unsigned() const NOEXCEPT { return d_; }
  CONSTCD11 inline bool day::ok() const NOEXCEPT { return 1 <= d_ && d_ <= 31; }

  CONSTCD11
    inline
    bool
    operator==(const day& x, const day& y) NOEXCEPT
  {
    return static_cast<unsigned>(x) == static_cast<unsigned>(y);
  }

  CONSTCD11
    inline
    bool
    operator!=(const day& x, const day& y) NOEXCEPT
  {
    return !(x == y);
  }

  CONSTCD11
    inline
    bool
    operator<(const day& x, const day& y) NOEXCEPT
  {
    return static_cast<unsigned>(x) < static_cast<unsigned>(y);
  }

  CONSTCD11
    inline
    bool
    operator>(const day& x, const day& y) NOEXCEPT
  {
    return y < x;
  }

  CONSTCD11
    inline
    bool
    operator<=(const day& x, const day& y) NOEXCEPT
  {
    return !(y < x);
  }

  CONSTCD11
    inline
    bool
    operator>=(const day& x, const day& y) NOEXCEPT
  {
    return !(x < y);
  }

  CONSTCD11
    inline
    days
    operator-(const day& x, const day& y) NOEXCEPT
  {
    return days{ static_cast<days::rep>(static_cast<unsigned>(x)
                                     - static_cast<unsigned>(y)) };
  }

  CONSTCD11
    inline
    day
    operator+(const day& x, const days& y) NOEXCEPT
  {
    return day{ static_cast<unsigned>(x) + static_cast<unsigned>(y.count()) };
  }

  CONSTCD11
    inline
    day
    operator+(const days& x, const day& y) NOEXCEPT
  {
    return y + x;
  }

  CONSTCD11
    inline
    day
    operator-(const day& x, const days& y) NOEXCEPT
  {
    return x + -y;
  }

  template<class CharT, class Traits>
  inline
    std::basic_ostream<CharT, Traits>&
    operator<<(std::basic_ostream<CharT, Traits>& os, const day& d)
  {
    detail::save_ostream<CharT, Traits> _(os);
    os.fill('0');
    os.flags(std::ios::dec | std::ios::right);
    os.width(2);
    os << static_cast<unsigned>(d);
    if (!d.ok())
      os << " is not a valid day";
    return os;
  }

  // month

  CONSTCD11 inline month::month(unsigned m) NOEXCEPT : m_(static_cast<decltype(m_)>(m)) {}
  CONSTCD14 inline month& month::operator++() NOEXCEPT { *this += months{ 1 }; return *this; }
  CONSTCD14 inline month month::operator++(int) NOEXCEPT { auto tmp(*this); ++(*this); return tmp; }
  CONSTCD14 inline month& month::operator--() NOEXCEPT { *this -= months{ 1 }; return *this; }
  CONSTCD14 inline month month::operator--(int) NOEXCEPT { auto tmp(*this); --(*this); return tmp; }

  CONSTCD14
    inline
    month&
    month::operator+=(const months& m) NOEXCEPT
  {
    *this = *this + m;
    return *this;
  }

  CONSTCD14
    inline
    month&
    month::operator-=(const months& m) NOEXCEPT
  {
    *this = *this - m;
    return *this;
  }

  CONSTCD11 inline month::operator unsigned() const NOEXCEPT { return m_; }
  CONSTCD11 inline bool month::ok() const NOEXCEPT { return 1 <= m_ && m_ <= 12; }

  CONSTCD11
    inline
    bool
    operator==(const month& x, const month& y) NOEXCEPT
  {
    return static_cast<unsigned>(x) == static_cast<unsigned>(y);
  }

  CONSTCD11
    inline
    bool
    operator!=(const month& x, const month& y) NOEXCEPT
  {
    return !(x == y);
  }

  CONSTCD11
    inline
    bool
    operator<(const month& x, const month& y) NOEXCEPT
  {
    return static_cast<unsigned>(x) < static_cast<unsigned>(y);
  }

  CONSTCD11
    inline
    bool
    operator>(const month& x, const month& y) NOEXCEPT
  {
    return y < x;
  }

  CONSTCD11
    inline
    bool
    operator<=(const month& x, const month& y) NOEXCEPT
  {
    return !(y < x);
  }

  CONSTCD11
    inline
    bool
    operator>=(const month& x, const month& y) NOEXCEPT
  {
    return !(x < y);
  }

  CONSTCD14
    inline
    months
    operator-(const month& x, const month& y) NOEXCEPT
  {
    auto const d = static_cast<unsigned>(x) - static_cast<unsigned>(y);
    return months(d <= 11 ? d : d + 12);
  }

  CONSTCD14
    inline
    month
    operator+(const month& x, const months& y) NOEXCEPT
  {
    auto const mu = static_cast<long long>(static_cast<unsigned>(x)) + y.count() - 1;
    auto const yr = (mu >= 0 ? mu : mu - 11) / 12;
    return month{ static_cast<unsigned>(mu - yr * 12 + 1) };
  }

  CONSTCD14
    inline
    month
    operator+(const months& x, const month& y) NOEXCEPT
  {
    return y + x;
  }

  CONSTCD14
    inline
    month
    operator-(const month& x, const months& y) NOEXCEPT
  {
    return x + -y;
  }

  template<class CharT, class Traits>
  inline
    std::basic_ostream<CharT, Traits>&
    operator<<(std::basic_ostream<CharT, Traits>& os, const month& m)
  {
    if (m.ok())
    {
      CharT fmt[] = { '%', 'b', 0 };
      os << format(os.getloc(), fmt, m);
    }
    else
      os << static_cast<unsigned>(m) << " is not a valid month";
    return os;
  }

  // year

  CONSTCD11 inline year::year(int y) NOEXCEPT : y_(static_cast<decltype(y_)>(y)) {}
  CONSTCD14 inline year& year::operator++() NOEXCEPT { ++y_; return *this; }
  CONSTCD14 inline year year::operator++(int) NOEXCEPT { auto tmp(*this); ++(*this); return tmp; }
  CONSTCD14 inline year& year::operator--() NOEXCEPT { --y_; return *this; }
  CONSTCD14 inline year year::operator--(int) NOEXCEPT { auto tmp(*this); --(*this); return tmp; }
  CONSTCD14 inline year& year::operator+=(const years& y) NOEXCEPT { *this = *this + y; return *this; }
  CONSTCD14 inline year& year::operator-=(const years& y) NOEXCEPT { *this = *this - y; return *this; }
  CONSTCD11 inline year year::operator-() const NOEXCEPT { return year{ -y_ }; }
  CONSTCD11 inline year year::operator+() const NOEXCEPT { return *this; }

  CONSTCD11
    inline
    bool
    year::is_leap() const NOEXCEPT
  {
    return y_ % 4 == 0 && (y_ % 100 != 0 || y_ % 400 == 0);
  }

  CONSTCD11 inline year::operator int() const NOEXCEPT { return y_; }

  CONSTCD11
    inline
    bool
    year::ok() const NOEXCEPT
  {
    return y_ != std::numeric_limits<short>::min();
  }

  CONSTCD11
    inline
    bool
    operator==(const year& x, const year& y) NOEXCEPT
  {
    return static_cast<int>(x) == static_cast<int>(y);
  }

  CONSTCD11
    inline
    bool
    operator!=(const year& x, const year& y) NOEXCEPT
  {
    return !(x == y);
  }

  CONSTCD11
    inline
    bool
    operator<(const year& x, const year& y) NOEXCEPT
  {
    return static_cast<int>(x) < static_cast<int>(y);
  }

  CONSTCD11
    inline
    bool
    operator>(const year& x, const year& y) NOEXCEPT
  {
    return y < x;
  }

  CONSTCD11
    inline
    bool
    operator<=(const year& x, const year& y) NOEXCEPT
  {
    return !(y < x);
  }

  CONSTCD11
    inline
    bool
    operator>=(const year& x, const year& y) NOEXCEPT
  {
    return !(x < y);
  }

  CONSTCD11
    inline
    years
    operator-(const year& x, const year& y) NOEXCEPT
  {
    return years{ static_cast<int>(x) - static_cast<int>(y) };
  }

  CONSTCD11
    inline
    year
    operator+(const year& x, const years& y) NOEXCEPT
  {
    return year{ static_cast<int>(x) + y.count() };
  }

  CONSTCD11
    inline
    year
    operator+(const years& x, const year& y) NOEXCEPT
  {
    return y + x;
  }

  CONSTCD11
    inline
    year
    operator-(const year& x, const years& y) NOEXCEPT
  {
    return year{ static_cast<int>(x) - y.count() };
  }

  template<class CharT, class Traits>
  inline
    std::basic_ostream<CharT, Traits>&
    operator<<(std::basic_ostream<CharT, Traits>& os, const year& y)
  {
    detail::save_ostream<CharT, Traits> _(os);
    os.fill('0');
    os.flags(std::ios::dec | std::ios::internal);
    os.width(4 + (y < year{ 0 }));
    os.imbue(std::locale::classic());
    os << static_cast<int>(y);
    if (!y.ok())
      os << " is not a valid year";
    return os;
  }

  // weekday

  CONSTCD14
    inline
    unsigned char
    weekday::weekday_from_days(int z) NOEXCEPT
  {
    auto u = static_cast<unsigned>(z);
    return static_cast<unsigned char>(z >= -4 ? (u + 4) % 7 : u % 7);
  }

  CONSTCD11
    inline
    weekday::weekday(unsigned wd) NOEXCEPT
    : wd_(static_cast<decltype(wd_)>(wd != 7 ? wd : 0))
  {}

  CONSTCD14
    inline
    weekday::weekday(const sys_days& dp) NOEXCEPT
    : wd_(weekday_from_days(dp.time_since_epoch().count()))
  {}

  CONSTCD14
    inline
    weekday::weekday(const local_days& dp) NOEXCEPT
    : wd_(weekday_from_days(dp.time_since_epoch().count()))
  {}

  CONSTCD14 inline weekday& weekday::operator++() NOEXCEPT { *this += days{ 1 }; return *this; }
  CONSTCD14 inline weekday weekday::operator++(int) NOEXCEPT { auto tmp(*this); ++(*this); return tmp; }
  CONSTCD14 inline weekday& weekday::operator--() NOEXCEPT { *this -= days{ 1 }; return *this; }
  CONSTCD14 inline weekday weekday::operator--(int) NOEXCEPT { auto tmp(*this); --(*this); return tmp; }

  CONSTCD14
    inline
    weekday&
    weekday::operator+=(const days& d) NOEXCEPT
  {
    *this = *this + d;
    return *this;
  }

  CONSTCD14
    inline
    weekday&
    weekday::operator-=(const days& d) NOEXCEPT
  {
    *this = *this - d;
    return *this;
  }

  CONSTCD11 inline bool weekday::ok() const NOEXCEPT { return wd_ <= 6; }

  CONSTCD11
    inline
    unsigned weekday::c_encoding() const NOEXCEPT
  {
    return unsigned{ wd_ };
  }

  CONSTCD11
    inline
    unsigned weekday::iso_encoding() const NOEXCEPT
  {
    return unsigned{ ((wd_ == 0u) ? 7u : wd_) };
  }

  CONSTCD11
    inline
    bool
    operator==(const weekday& x, const weekday& y) NOEXCEPT
  {
    return x.wd_ == y.wd_;
  }

  CONSTCD11
    inline
    bool
    operator!=(const weekday& x, const weekday& y) NOEXCEPT
  {
    return !(x == y);
  }

  CONSTCD14
    inline
    days
    operator-(const weekday& x, const weekday& y) NOEXCEPT
  {
    auto const wdu = x.wd_ - y.wd_;
    auto const wk = (wdu >= 0 ? wdu : wdu - 6) / 7;
    return days{ wdu - wk * 7 };
  }

  CONSTCD14
    inline
    weekday
    operator+(const weekday& x, const days& y) NOEXCEPT
  {
    auto const wdu = static_cast<long long>(static_cast<unsigned>(x.wd_)) + y.count();
    auto const wk = (wdu >= 0 ? wdu : wdu - 6) / 7;
    return weekday{ static_cast<unsigned>(wdu - wk * 7) };
  }

  CONSTCD14
    inline
    weekday
    operator+(const days& x, const weekday& y) NOEXCEPT
  {
    return y + x;
  }

  CONSTCD14
    inline
    weekday
    operator-(const weekday& x, const days& y) NOEXCEPT
  {
    return x + -y;
  }

  template<class CharT, class Traits>
  inline
    std::basic_ostream<CharT, Traits>&
    operator<<(std::basic_ostream<CharT, Traits>& os, const weekday& wd)
  {
    if (wd.ok())
    {
      CharT fmt[] = { '%', 'a', 0 };
      os << format(fmt, wd);
    }
    else
      os << static_cast<unsigned>(wd.wd_) << " is not a valid weekday";
    return os;
  }

#if !defined(_MSC_VER) || (_MSC_VER >= 1900)
  inline namespace literals
  {

    CONSTCD11
      inline
      date::day
      operator "" _d(unsigned long long d) NOEXCEPT
    {
      return date::day{ static_cast<unsigned>(d) };
    }

    CONSTCD11
      inline
      date::year
      operator "" _y(unsigned long long y) NOEXCEPT
    {
      return date::year(static_cast<int>(y));
    }
#endif  // !defined(_MSC_VER) || (_MSC_VER >= 1900)

    CONSTDATA date::last_spec last{};

    CONSTDATA date::month jan{ 1 };
    CONSTDATA date::month feb{ 2 };
    CONSTDATA date::month mar{ 3 };
    CONSTDATA date::month apr{ 4 };
    CONSTDATA date::month may{ 5 };
    CONSTDATA date::month jun{ 6 };
    CONSTDATA date::month jul{ 7 };
    CONSTDATA date::month aug{ 8 };
    CONSTDATA date::month sep{ 9 };
    CONSTDATA date::month oct{ 10 };
    CONSTDATA date::month nov{ 11 };
    CONSTDATA date::month dec{ 12 };

    CONSTDATA date::weekday sun{ 0u };
    CONSTDATA date::weekday mon{ 1u };
    CONSTDATA date::weekday tue{ 2u };
    CONSTDATA date::weekday wed{ 3u };
    CONSTDATA date::weekday thu{ 4u };
    CONSTDATA date::weekday fri{ 5u };
    CONSTDATA date::weekday sat{ 6u };

#if !defined(_MSC_VER) || (_MSC_VER >= 1900)
  }  // inline namespace literals
#endif

  CONSTDATA date::month January{ 1 };
  CONSTDATA date::month February{ 2 };
  CONSTDATA date::month March{ 3 };
  CONSTDATA date::month April{ 4 };
  CONSTDATA date::month May{ 5 };
  CONSTDATA date::month June{ 6 };
  CONSTDATA date::month July{ 7 };
  CONSTDATA date::month August{ 8 };
  CONSTDATA date::month September{ 9 };
  CONSTDATA date::month October{ 10 };
  CONSTDATA date::month November{ 11 };
  CONSTDATA date::month December{ 12 };

  CONSTDATA date::weekday Monday{ 1 };
  CONSTDATA date::weekday Tuesday{ 2 };
  CONSTDATA date::weekday Wednesday{ 3 };
  CONSTDATA date::weekday Thursday{ 4 };
  CONSTDATA date::weekday Friday{ 5 };
  CONSTDATA date::weekday Saturday{ 6 };
  CONSTDATA date::weekday Sunday{ 7 };

  // weekday_indexed

  CONSTCD11
    inline
    weekday
    weekday_indexed::weekday() const NOEXCEPT
  {
    return date::weekday{ static_cast<unsigned>(wd_) };
  }

  CONSTCD11 inline unsigned weekday_indexed::index() const NOEXCEPT { return index_; }

  CONSTCD11
    inline
    bool
    weekday_indexed::ok() const NOEXCEPT
  {
    return weekday().ok() && 1 <= index_ && index_ <= 5;
  }

#ifdef __GNUC__
#  pragma GCC diagnostic push
#  pragma GCC diagnostic ignored "-Wconversion"
#endif  // __GNUC__

  CONSTCD11
    inline
    weekday_indexed::weekday_indexed(const date::weekday& wd, unsigned index) NOEXCEPT
    : wd_(static_cast<decltype(wd_)>(static_cast<unsigned>(wd.wd_)))
    , index_(static_cast<decltype(index_)>(index))
  {}

#ifdef __GNUC__
#  pragma GCC diagnostic pop
#endif  // __GNUC__

  template<class CharT, class Traits>
  inline
    std::basic_ostream<CharT, Traits>&
    operator<<(std::basic_ostream<CharT, Traits>& os, const weekday_indexed& wdi)
  {
    os << wdi.weekday() << '[' << wdi.index();
    if (!(1 <= wdi.index() && wdi.index() <= 5))
      os << " is not a valid index";
    os << ']';
    return os;
  }

  CONSTCD11
    inline
    weekday_indexed
    weekday::operator[](unsigned index) const NOEXCEPT
  {
    return { *this, index };
  }

  CONSTCD11
    inline
    bool
    operator==(const weekday_indexed& x, const weekday_indexed& y) NOEXCEPT
  {
    return x.weekday() == y.weekday() && x.index() == y.index();
  }

  CONSTCD11
    inline
    bool
    operator!=(const weekday_indexed& x, const weekday_indexed& y) NOEXCEPT
  {
    return !(x == y);
  }

  // weekday_last

  CONSTCD11 inline date::weekday weekday_last::weekday() const NOEXCEPT { return wd_; }
  CONSTCD11 inline bool weekday_last::ok() const NOEXCEPT { return wd_.ok(); }
  CONSTCD11 inline weekday_last::weekday_last(const date::weekday& wd) NOEXCEPT : wd_(wd) {}

  CONSTCD11
    inline
    bool
    operator==(const weekday_last& x, const weekday_last& y) NOEXCEPT
  {
    return x.weekday() == y.weekday();
  }

  CONSTCD11
    inline
    bool
    operator!=(const weekday_last& x, const weekday_last& y) NOEXCEPT
  {
    return !(x == y);
  }

  template<class CharT, class Traits>
  inline
    std::basic_ostream<CharT, Traits>&
    operator<<(std::basic_ostream<CharT, Traits>& os, const weekday_last& wdl)
  {
    return os << wdl.weekday() << "[last]";
  }

  CONSTCD11
    inline
    weekday_last
    weekday::operator[](last_spec) const NOEXCEPT
  {
    return weekday_last{ *this };
  }

  // year_month

  CONSTCD11
    inline
    year_month::year_month(const date::year& y, const date::month& m) NOEXCEPT
    : y_(y)
    , m_(m)
  {}

  CONSTCD11 inline year year_month::year() const NOEXCEPT { return y_; }
  CONSTCD11 inline month year_month::month() const NOEXCEPT { return m_; }
  CONSTCD11 inline bool year_month::ok() const NOEXCEPT { return y_.ok() && m_.ok(); }

  template<class>
  CONSTCD14
    inline
    year_month&
    year_month::operator+=(const months& dm) NOEXCEPT
  {
    *this = *this + dm;
    return *this;
  }

  template<class>
  CONSTCD14
    inline
    year_month&
    year_month::operator-=(const months& dm) NOEXCEPT
  {
    *this = *this - dm;
    return *this;
  }

  CONSTCD14
    inline
    year_month&
    year_month::operator+=(const years& dy) NOEXCEPT
  {
    *this = *this + dy;
    return *this;
  }

  CONSTCD14
    inline
    year_month&
    year_month::operator-=(const years& dy) NOEXCEPT
  {
    *this = *this - dy;
    return *this;
  }

  CONSTCD11
    inline
    bool
    operator==(const year_month& x, const year_month& y) NOEXCEPT
  {
    return x.year() == y.year() && x.month() == y.month();
  }

  CONSTCD11
    inline
    bool
    operator!=(const year_month& x, const year_month& y) NOEXCEPT
  {
    return !(x == y);
  }

  CONSTCD11
    inline
    bool
    operator<(const year_month& x, const year_month& y) NOEXCEPT
  {
    return x.year() < y.year() ? true
      : (x.year() > y.year() ? false
        : (x.month() < y.month()));
  }

  CONSTCD11
    inline
    bool
    operator>(const year_month& x, const year_month& y) NOEXCEPT
  {
    return y < x;
  }

  CONSTCD11
    inline
    bool
    operator<=(const year_month& x, const year_month& y) NOEXCEPT
  {
    return !(y < x);
  }

  CONSTCD11
    inline
    bool
    operator>=(const year_month& x, const year_month& y) NOEXCEPT
  {
    return !(x < y);
  }

  template<class>
  CONSTCD14
    inline
    year_month
    operator+(const year_month& ym, const months& dm) NOEXCEPT
  {
    auto dmi = static_cast<int>(static_cast<unsigned>(ym.month())) - 1 + dm.count();
    auto dy = (dmi >= 0 ? dmi : dmi - 11) / 12;
    dmi = dmi - dy * 12 + 1;
    return (ym.year() + years(dy)) / month(static_cast<unsigned>(dmi));
  }

  template<class>
  CONSTCD14
    inline
    year_month
    operator+(const months& dm, const year_month& ym) NOEXCEPT
  {
    return ym + dm;
  }

  template<class>
  CONSTCD14
    inline
    year_month
    operator-(const year_month& ym, const months& dm) NOEXCEPT
  {
    return ym + -dm;
  }

  CONSTCD11
    inline
    months
    operator-(const year_month& x, const year_month& y) NOEXCEPT
  {
    return (x.year() - y.year()) +
      months(static_cast<unsigned>(x.month()) - static_cast<unsigned>(y.month()));
  }

  CONSTCD11
    inline
    year_month
    operator+(const year_month& ym, const years& dy) NOEXCEPT
  {
    return (ym.year() + dy) / ym.month();
  }

  CONSTCD11
    inline
    year_month
    operator+(const years& dy, const year_month& ym) NOEXCEPT
  {
    return ym + dy;
  }

  CONSTCD11
    inline
    year_month
    operator-(const year_month& ym, const years& dy) NOEXCEPT
  {
    return ym + -dy;
  }

  template<class CharT, class Traits>
  inline
    std::basic_ostream<CharT, Traits>&
    operator<<(std::basic_ostream<CharT, Traits>& os, const year_month& ym)
  {
    return os << ym.year() << '/' << ym.month();
  }

  // month_day

  CONSTCD11
    inline
    month_day::month_day(const date::month& m, const date::day& d) NOEXCEPT
    : m_(m)
    , d_(d)
  {}

  CONSTCD11 inline date::month month_day::month() const NOEXCEPT { return m_; }
  CONSTCD11 inline date::day month_day::day() const NOEXCEPT { return d_; }

  CONSTCD14
    inline
    bool
    month_day::ok() const NOEXCEPT
  {
    CONSTDATA date::day d[] =
    {
        date::day(31), date::day(29), date::day(31),
        date::day(30), date::day(31), date::day(30),
        date::day(31), date::day(31), date::day(30),
        date::day(31), date::day(30), date::day(31)
    };
    return m_.ok() && date::day{ 1 } <= d_ && d_ <= d[static_cast<unsigned>(m_) - 1];
  }

  CONSTCD11
    inline
    bool
    operator==(const month_day& x, const month_day& y) NOEXCEPT
  {
    return x.month() == y.month() && x.day() == y.day();
  }

  CONSTCD11
    inline
    bool
    operator!=(const month_day& x, const month_day& y) NOEXCEPT
  {
    return !(x == y);
  }

  CONSTCD11
    inline
    bool
    operator<(const month_day& x, const month_day& y) NOEXCEPT
  {
    return x.month() < y.month() ? true
      : (x.month() > y.month() ? false
        : (x.day() < y.day()));
  }

  CONSTCD11
    inline
    bool
    operator>(const month_day& x, const month_day& y) NOEXCEPT
  {
    return y < x;
  }

  CONSTCD11
    inline
    bool
    operator<=(const month_day& x, const month_day& y) NOEXCEPT
  {
    return !(y < x);
  }

  CONSTCD11
    inline
    bool
    operator>=(const month_day& x, const month_day& y) NOEXCEPT
  {
    return !(x < y);
  }

  template<class CharT, class Traits>
  inline
    std::basic_ostream<CharT, Traits>&
    operator<<(std::basic_ostream<CharT, Traits>& os, const month_day& md)
  {
    return os << md.month() << '/' << md.day();
  }

  // month_day_last

  CONSTCD11 inline month month_day_last::month() const NOEXCEPT { return m_; }
  CONSTCD11 inline bool month_day_last::ok() const NOEXCEPT { return m_.ok(); }
  CONSTCD11 inline month_day_last::month_day_last(const date::month& m) NOEXCEPT : m_(m) {}

  CONSTCD11
    inline
    bool
    operator==(const month_day_last& x, const month_day_last& y) NOEXCEPT
  {
    return x.month() == y.month();
  }

  CONSTCD11
    inline
    bool
    operator!=(const month_day_last& x, const month_day_last& y) NOEXCEPT
  {
    return !(x == y);
  }

  CONSTCD11
    inline
    bool
    operator<(const month_day_last& x, const month_day_last& y) NOEXCEPT
  {
    return x.month() < y.month();
  }

  CONSTCD11
    inline
    bool
    operator>(const month_day_last& x, const month_day_last& y) NOEXCEPT
  {
    return y < x;
  }

  CONSTCD11
    inline
    bool
    operator<=(const month_day_last& x, const month_day_last& y) NOEXCEPT
  {
    return !(y < x);
  }

  CONSTCD11
    inline
    bool
    operator>=(const month_day_last& x, const month_day_last& y) NOEXCEPT
  {
    return !(x < y);
  }

  template<class CharT, class Traits>
  inline
    std::basic_ostream<CharT, Traits>&
    operator<<(std::basic_ostream<CharT, Traits>& os, const month_day_last& mdl)
  {
    return os << mdl.month() << "/last";
  }

  // month_weekday

  CONSTCD11
    inline
    month_weekday::month_weekday(const date::month& m,
      const date::weekday_indexed& wdi) NOEXCEPT
    : m_(m)
    , wdi_(wdi)
  {}

  CONSTCD11 inline month month_weekday::month() const NOEXCEPT { return m_; }

  CONSTCD11
    inline
    weekday_indexed
    month_weekday::weekday_indexed() const NOEXCEPT
  {
    return wdi_;
  }

  CONSTCD11
    inline
    bool
    month_weekday::ok() const NOEXCEPT
  {
    return m_.ok() && wdi_.ok();
  }

  CONSTCD11
    inline
    bool
    operator==(const month_weekday& x, const month_weekday& y) NOEXCEPT
  {
    return x.month() == y.month() && x.weekday_indexed() == y.weekday_indexed();
  }

  CONSTCD11
    inline
    bool
    operator!=(const month_weekday& x, const month_weekday& y) NOEXCEPT
  {
    return !(x == y);
  }

  template<class CharT, class Traits>
  inline
    std::basic_ostream<CharT, Traits>&
    operator<<(std::basic_ostream<CharT, Traits>& os, const month_weekday& mwd)
  {
    return os << mwd.month() << '/' << mwd.weekday_indexed();
  }

  // month_weekday_last

  CONSTCD11
    inline
    month_weekday_last::month_weekday_last(const date::month& m,
      const date::weekday_last& wdl) NOEXCEPT
    : m_(m)
    , wdl_(wdl)
  {}

  CONSTCD11 inline month month_weekday_last::month() const NOEXCEPT { return m_; }

  CONSTCD11
    inline
    weekday_last
    month_weekday_last::weekday_last() const NOEXCEPT
  {
    return wdl_;
  }

  CONSTCD11
    inline
    bool
    month_weekday_last::ok() const NOEXCEPT
  {
    return m_.ok() && wdl_.ok();
  }

  CONSTCD11
    inline
    bool
    operator==(const month_weekday_last& x, const month_weekday_last& y) NOEXCEPT
  {
    return x.month() == y.month() && x.weekday_last() == y.weekday_last();
  }

  CONSTCD11
    inline
    bool
    operator!=(const month_weekday_last& x, const month_weekday_last& y) NOEXCEPT
  {
    return !(x == y);
  }

  template<class CharT, class Traits>
  inline
    std::basic_ostream<CharT, Traits>&
    operator<<(std::basic_ostream<CharT, Traits>& os, const month_weekday_last& mwdl)
  {
    return os << mwdl.month() << '/' << mwdl.weekday_last();
  }

  // year_month_day_last

  CONSTCD11
    inline
    year_month_day_last::year_month_day_last(const date::year& y,
      const date::month_day_last& mdl) NOEXCEPT
    : y_(y)
    , mdl_(mdl)
  {}

  template<class>
  CONSTCD14
    inline
    year_month_day_last&
    year_month_day_last::operator+=(const months& m) NOEXCEPT
  {
    *this = *this + m;
    return *this;
  }

  template<class>
  CONSTCD14
    inline
    year_month_day_last&
    year_month_day_last::operator-=(const months& m) NOEXCEPT
  {
    *this = *this - m;
    return *this;
  }

  CONSTCD14
    inline
    year_month_day_last&
    year_month_day_last::operator+=(const years& y) NOEXCEPT
  {
    *this = *this + y;
    return *this;
  }

  CONSTCD14
    inline
    year_month_day_last&
    year_month_day_last::operator-=(const years& y) NOEXCEPT
  {
    *this = *this - y;
    return *this;
  }

  CONSTCD11 inline year year_month_day_last::year() const NOEXCEPT { return y_; }
  CONSTCD11 inline month year_month_day_last::month() const NOEXCEPT { return mdl_.month(); }

  CONSTCD11
    inline
    month_day_last
    year_month_day_last::month_day_last() const NOEXCEPT
  {
    return mdl_;
  }

  CONSTCD14
    inline
    day
    year_month_day_last::day() const NOEXCEPT
  {
    CONSTDATA date::day d[] =
    {
        date::day(31), date::day(28), date::day(31),
        date::day(30), date::day(31), date::day(30),
        date::day(31), date::day(31), date::day(30),
        date::day(31), date::day(30), date::day(31)
    };
    return (month() != February || !y_.is_leap()) && mdl_.ok() ?
      d[static_cast<unsigned>(month()) - 1] : date::day{ 29 };
  }

  CONSTCD14
    inline
    year_month_day_last::operator sys_days() const NOEXCEPT
  {
    return sys_days(year() / month() / day());
  }

  CONSTCD14
    inline
    year_month_day_last::operator local_days() const NOEXCEPT
  {
    return local_days(year() / month() / day());
  }

  CONSTCD11
    inline
    bool
    year_month_day_last::ok() const NOEXCEPT
  {
    return y_.ok() && mdl_.ok();
  }

  CONSTCD11
    inline
    bool
    operator==(const year_month_day_last& x, const year_month_day_last& y) NOEXCEPT
  {
    return x.year() == y.year() && x.month_day_last() == y.month_day_last();
  }

  CONSTCD11
    inline
    bool
    operator!=(const year_month_day_last& x, const year_month_day_last& y) NOEXCEPT
  {
    return !(x == y);
  }

  CONSTCD11
    inline
    bool
    operator<(const year_month_day_last& x, const year_month_day_last& y) NOEXCEPT
  {
    return x.year() < y.year() ? true
      : (x.year() > y.year() ? false
        : (x.month_day_last() < y.month_day_last()));
  }

  CONSTCD11
    inline
    bool
    operator>(const year_month_day_last& x, const year_month_day_last& y) NOEXCEPT
  {
    return y < x;
  }

  CONSTCD11
    inline
    bool
    operator<=(const year_month_day_last& x, const year_month_day_last& y) NOEXCEPT
  {
    return !(y < x);
  }

  CONSTCD11
    inline
    bool
    operator>=(const year_month_day_last& x, const year_month_day_last& y) NOEXCEPT
  {
    return !(x < y);
  }

  template<class CharT, class Traits>
  inline
    std::basic_ostream<CharT, Traits>&
    operator<<(std::basic_ostream<CharT, Traits>& os, const year_month_day_last& ymdl)
  {
    return os << ymdl.year() << '/' << ymdl.month_day_last();
  }

  template<class>
  CONSTCD14
    inline
    year_month_day_last
    operator+(const year_month_day_last& ymdl, const months& dm) NOEXCEPT
  {
    return (ymdl.year() / ymdl.month() + dm) / last;
  }

  template<class>
  CONSTCD14
    inline
    year_month_day_last
    operator+(const months& dm, const year_month_day_last& ymdl) NOEXCEPT
  {
    return ymdl + dm;
  }

  template<class>
  CONSTCD14
    inline
    year_month_day_last
    operator-(const year_month_day_last& ymdl, const months& dm) NOEXCEPT
  {
    return ymdl + (-dm);
  }

  CONSTCD11
    inline
    year_month_day_last
    operator+(const year_month_day_last& ymdl, const years& dy) NOEXCEPT
  {
    return { ymdl.year() + dy, ymdl.month_day_last() };
  }

  CONSTCD11
    inline
    year_month_day_last
    operator+(const years& dy, const year_month_day_last& ymdl) NOEXCEPT
  {
    return ymdl + dy;
  }

  CONSTCD11
    inline
    year_month_day_last
    operator-(const year_month_day_last& ymdl, const years& dy) NOEXCEPT
  {
    return ymdl + (-dy);
  }

  // year_month_day

  CONSTCD11
    inline
    year_month_day::year_month_day(const date::year& y, const date::month& m,
      const date::day& d) NOEXCEPT
    : y_(y)
    , m_(m)
    , d_(d)
  {}

  CONSTCD14
    inline
    year_month_day::year_month_day(const year_month_day_last& ymdl) NOEXCEPT
    : y_(ymdl.year())
    , m_(ymdl.month())
    , d_(ymdl.day())
  {}

  CONSTCD14
    inline
    year_month_day::year_month_day(sys_days dp) NOEXCEPT
    : year_month_day(from_days(dp.time_since_epoch()))
  {}

  CONSTCD14
    inline
    year_month_day::year_month_day(local_days dp) NOEXCEPT
    : year_month_day(from_days(dp.time_since_epoch()))
  {}

  CONSTCD11 inline year year_month_day::year() const NOEXCEPT { return y_; }
  CONSTCD11 inline month year_month_day::month() const NOEXCEPT { return m_; }
  CONSTCD11 inline day year_month_day::day() const NOEXCEPT { return d_; }

  template<class>
  CONSTCD14
    inline
    year_month_day&
    year_month_day::operator+=(const months& m) NOEXCEPT
  {
    *this = *this + m;
    return *this;
  }

  template<class>
  CONSTCD14
    inline
    year_month_day&
    year_month_day::operator-=(const months& m) NOEXCEPT
  {
    *this = *this - m;
    return *this;
  }

  CONSTCD14
    inline
    year_month_day&
    year_month_day::operator+=(const years& y) NOEXCEPT
  {
    *this = *this + y;
    return *this;
  }

  CONSTCD14
    inline
    year_month_day&
    year_month_day::operator-=(const years& y) NOEXCEPT
  {
    *this = *this - y;
    return *this;
  }

  CONSTCD14
    inline
    days
    year_month_day::to_days() const NOEXCEPT
  {
    static_assert(std::numeric_limits<unsigned>::digits >= 18,
      "This algorithm has not been ported to a 16 bit unsigned integer");
    static_assert(std::numeric_limits<int>::digits >= 20,
      "This algorithm has not been ported to a 16 bit signed integer");
    auto const y = static_cast<int>(y_) - (m_ <= February);
    auto const m = static_cast<unsigned>(m_);
    auto const d = static_cast<unsigned>(d_);
    auto const era = (y >= 0 ? y : y - 399) / 400;
    auto const yoe = static_cast<unsigned>(y - era * 400);       // [0, 399]
    auto const doy = (153 * (m > 2 ? m - 3 : m + 9) + 2) / 5 + d - 1;      // [0, 365]
    auto const doe = yoe * 365 + yoe / 4 - yoe / 100 + doy;          // [0, 146096]
    return days{ era * 146097 + static_cast<int>(doe) - 719468 };
  }

  CONSTCD14
    inline
    year_month_day::operator sys_days() const NOEXCEPT
  {
    return sys_days{ to_days() };
  }

  CONSTCD14
    inline
    year_month_day::operator local_days() const NOEXCEPT
  {
    return local_days{ to_days() };
  }

  CONSTCD14
    inline
    bool
    year_month_day::ok() const NOEXCEPT
  {
    if (!(y_.ok() && m_.ok()))
      return false;
    return date::day{ 1 } <= d_ && d_ <= (y_ / m_ / last).day();
  }

  CONSTCD11
    inline
    bool
    operator==(const year_month_day& x, const year_month_day& y) NOEXCEPT
  {
    return x.year() == y.year() && x.month() == y.month() && x.day() == y.day();
  }

  CONSTCD11
    inline
    bool
    operator!=(const year_month_day& x, const year_month_day& y) NOEXCEPT
  {
    return !(x == y);
  }

  CONSTCD11
    inline
    bool
    operator<(const year_month_day& x, const year_month_day& y) NOEXCEPT
  {
    return x.year() < y.year() ? true
      : (x.year() > y.year() ? false
        : (x.month() < y.month() ? true
          : (x.month() > y.month() ? false
            : (x.day() < y.day()))));
  }

  CONSTCD11
    inline
    bool
    operator>(const year_month_day& x, const year_month_day& y) NOEXCEPT
  {
    return y < x;
  }

  CONSTCD11
    inline
    bool
    operator<=(const year_month_day& x, const year_month_day& y) NOEXCEPT
  {
    return !(y < x);
  }

  CONSTCD11
    inline
    bool
    operator>=(const year_month_day& x, const year_month_day& y) NOEXCEPT
  {
    return !(x < y);
  }

  template<class CharT, class Traits>
  inline
    std::basic_ostream<CharT, Traits>&
    operator<<(std::basic_ostream<CharT, Traits>& os, const year_month_day& ymd)
  {
    detail::save_ostream<CharT, Traits> _(os);
    os.fill('0');
    os.flags(std::ios::dec | std::ios::right);
    os.imbue(std::locale::classic());
    os << ymd.year() << '-';
    os.width(2);
    os << static_cast<unsigned>(ymd.month()) << '-';
    os << ymd.day();
    if (!ymd.ok())
      os << " is not a valid date";
    return os;
  }

  CONSTCD14
    inline
    year_month_day
    year_month_day::from_days(days dp) NOEXCEPT
  {
    static_assert(std::numeric_limits<unsigned>::digits >= 18,
      "This algorithm has not been ported to a 16 bit unsigned integer");
    static_assert(std::numeric_limits<int>::digits >= 20,
      "This algorithm has not been ported to a 16 bit signed integer");
    auto const z = dp.count() + 719468;
    auto const era = (z >= 0 ? z : z - 146096) / 146097;
    auto const doe = static_cast<unsigned>(z - era * 146097);          // [0, 146096]
    auto const yoe = (doe - doe / 1460 + doe / 36524 - doe / 146096) / 365;  // [0, 399]
    auto const y = static_cast<days::rep>(yoe) + era * 400;
    auto const doy = doe - (365 * yoe + yoe / 4 - yoe / 100);                // [0, 365]
    auto const mp = (5 * doy + 2) / 153;                                   // [0, 11]
    auto const d = doy - (153 * mp + 2) / 5 + 1;                             // [1, 31]
    auto const m = mp < 10 ? mp + 3 : mp - 9;                              // [1, 12]
    return year_month_day{ date::year{y + (m <= 2)}, date::month(m), date::day(d) };
  }

  template<class>
  CONSTCD14
    inline
    year_month_day
    operator+(const year_month_day& ymd, const months& dm) NOEXCEPT
  {
    return (ymd.year() / ymd.month() + dm) / ymd.day();
  }

  template<class>
  CONSTCD14
    inline
    year_month_day
    operator+(const months& dm, const year_month_day& ymd) NOEXCEPT
  {
    return ymd + dm;
  }

  template<class>
  CONSTCD14
    inline
    year_month_day
    operator-(const year_month_day& ymd, const months& dm) NOEXCEPT
  {
    return ymd + (-dm);
  }

  CONSTCD11
    inline
    year_month_day
    operator+(const year_month_day& ymd, const years& dy) NOEXCEPT
  {
    return (ymd.year() + dy) / ymd.month() / ymd.day();
  }

  CONSTCD11
    inline
    year_month_day
    operator+(const years& dy, const year_month_day& ymd) NOEXCEPT
  {
    return ymd + dy;
  }

  CONSTCD11
    inline
    year_month_day
    operator-(const year_month_day& ymd, const years& dy) NOEXCEPT
  {
    return ymd + (-dy);
  }

  // year_month_weekday

  CONSTCD11
    inline
    year_month_weekday::year_month_weekday(const date::year& y, const date::month& m,
      const date::weekday_indexed& wdi)
    NOEXCEPT
    : y_(y)
    , m_(m)
    , wdi_(wdi)
  {}

  CONSTCD14
    inline
    year_month_weekday::year_month_weekday(const sys_days& dp) NOEXCEPT
    : year_month_weekday(from_days(dp.time_since_epoch()))
  {}

  CONSTCD14
    inline
    year_month_weekday::year_month_weekday(const local_days& dp) NOEXCEPT
    : year_month_weekday(from_days(dp.time_since_epoch()))
  {}

  template<class>
  CONSTCD14
    inline
    year_month_weekday&
    year_month_weekday::operator+=(const months& m) NOEXCEPT
  {
    *this = *this + m;
    return *this;
  }

  template<class>
  CONSTCD14
    inline
    year_month_weekday&
    year_month_weekday::operator-=(const months& m) NOEXCEPT
  {
    *this = *this - m;
    return *this;
  }

  CONSTCD14
    inline
    year_month_weekday&
    year_month_weekday::operator+=(const years& y) NOEXCEPT
  {
    *this = *this + y;
    return *this;
  }

  CONSTCD14
    inline
    year_month_weekday&
    year_month_weekday::operator-=(const years& y) NOEXCEPT
  {
    *this = *this - y;
    return *this;
  }

  CONSTCD11 inline year year_month_weekday::year() const NOEXCEPT { return y_; }
  CONSTCD11 inline month year_month_weekday::month() const NOEXCEPT { return m_; }

  CONSTCD11
    inline
    weekday
    year_month_weekday::weekday() const NOEXCEPT
  {
    return wdi_.weekday();
  }

  CONSTCD11
    inline
    unsigned
    year_month_weekday::index() const NOEXCEPT
  {
    return wdi_.index();
  }

  CONSTCD11
    inline
    weekday_indexed
    year_month_weekday::weekday_indexed() const NOEXCEPT
  {
    return wdi_;
  }

  CONSTCD14
    inline
    year_month_weekday::operator sys_days() const NOEXCEPT
  {
    return sys_days{ to_days() };
  }

  CONSTCD14
    inline
    year_month_weekday::operator local_days() const NOEXCEPT
  {
    return local_days{ to_days() };
  }

  CONSTCD14
    inline
    bool
    year_month_weekday::ok() const NOEXCEPT
  {
    if (!y_.ok() || !m_.ok() || !wdi_.weekday().ok() || wdi_.index() < 1)
      return false;
    if (wdi_.index() <= 4)
      return true;
    auto d2 = wdi_.weekday() - date::weekday(static_cast<sys_days>(y_ / m_ / 1)) +
      days((wdi_.index() - 1) * 7 + 1);
    return static_cast<unsigned>(d2.count()) <= static_cast<unsigned>((y_ / m_ / last).day());
  }

  CONSTCD14
    inline
    year_month_weekday
    year_month_weekday::from_days(days d) NOEXCEPT
  {
    sys_days dp{ d };
    auto const wd = date::weekday(dp);
    auto const ymd = year_month_day(dp);
    return { ymd.year(), ymd.month(), wd[(static_cast<unsigned>(ymd.day()) - 1) / 7 + 1] };
  }

  CONSTCD14
    inline
    days
    year_month_weekday::to_days() const NOEXCEPT
  {
    auto d = sys_days(y_ / m_ / 1);
    return (d + (wdi_.weekday() - date::weekday(d) + days{ (wdi_.index() - 1) * 7 })
      ).time_since_epoch();
  }

  CONSTCD11
    inline
    bool
    operator==(const year_month_weekday& x, const year_month_weekday& y) NOEXCEPT
  {
    return x.year() == y.year() && x.month() == y.month() &&
      x.weekday_indexed() == y.weekday_indexed();
  }

  CONSTCD11
    inline
    bool
    operator!=(const year_month_weekday& x, const year_month_weekday& y) NOEXCEPT
  {
    return !(x == y);
  }

  template<class CharT, class Traits>
  inline
    std::basic_ostream<CharT, Traits>&
    operator<<(std::basic_ostream<CharT, Traits>& os, const year_month_weekday& ymwdi)
  {
    return os << ymwdi.year() << '/' << ymwdi.month()
      << '/' << ymwdi.weekday_indexed();
  }

  template<class>
  CONSTCD14
    inline
    year_month_weekday
    operator+(const year_month_weekday& ymwd, const months& dm) NOEXCEPT
  {
    return (ymwd.year() / ymwd.month() + dm) / ymwd.weekday_indexed();
  }

  template<class>
  CONSTCD14
    inline
    year_month_weekday
    operator+(const months& dm, const year_month_weekday& ymwd) NOEXCEPT
  {
    return ymwd + dm;
  }

  template<class>
  CONSTCD14
    inline
    year_month_weekday
    operator-(const year_month_weekday& ymwd, const months& dm) NOEXCEPT
  {
    return ymwd + (-dm);
  }

  CONSTCD11
    inline
    year_month_weekday
    operator+(const year_month_weekday& ymwd, const years& dy) NOEXCEPT
  {
    return { ymwd.year() + dy, ymwd.month(), ymwd.weekday_indexed() };
  }

  CONSTCD11
    inline
    year_month_weekday
    operator+(const years& dy, const year_month_weekday& ymwd) NOEXCEPT
  {
    return ymwd + dy;
  }

  CONSTCD11
    inline
    year_month_weekday
    operator-(const year_month_weekday& ymwd, const years& dy) NOEXCEPT
  {
    return ymwd + (-dy);
  }

  // year_month_weekday_last

  CONSTCD11
    inline
    year_month_weekday_last::year_month_weekday_last(const date::year& y,
      const date::month& m,
      const date::weekday_last& wdl) NOEXCEPT
    : y_(y)
    , m_(m)
    , wdl_(wdl)
  {}

  template<class>
  CONSTCD14
    inline
    year_month_weekday_last&
    year_month_weekday_last::operator+=(const months& m) NOEXCEPT
  {
    *this = *this + m;
    return *this;
  }

  template<class>
  CONSTCD14
    inline
    year_month_weekday_last&
    year_month_weekday_last::operator-=(const months& m) NOEXCEPT
  {
    *this = *this - m;
    return *this;
  }

  CONSTCD14
    inline
    year_month_weekday_last&
    year_month_weekday_last::operator+=(const years& y) NOEXCEPT
  {
    *this = *this + y;
    return *this;
  }

  CONSTCD14
    inline
    year_month_weekday_last&
    year_month_weekday_last::operator-=(const years& y) NOEXCEPT
  {
    *this = *this - y;
    return *this;
  }

  CONSTCD11 inline year year_month_weekday_last::year() const NOEXCEPT { return y_; }
  CONSTCD11 inline month year_month_weekday_last::month() const NOEXCEPT { return m_; }

  CONSTCD11
    inline
    weekday
    year_month_weekday_last::weekday() const NOEXCEPT
  {
    return wdl_.weekday();
  }

  CONSTCD11
    inline
    weekday_last
    year_month_weekday_last::weekday_last() const NOEXCEPT
  {
    return wdl_;
  }

  CONSTCD14
    inline
    year_month_weekday_last::operator sys_days() const NOEXCEPT
  {
    return sys_days{ to_days() };
  }

  CONSTCD14
    inline
    year_month_weekday_last::operator local_days() const NOEXCEPT
  {
    return local_days{ to_days() };
  }

  CONSTCD11
    inline
    bool
    year_month_weekday_last::ok() const NOEXCEPT
  {
    return y_.ok() && m_.ok() && wdl_.ok();
  }

  CONSTCD14
    inline
    days
    year_month_weekday_last::to_days() const NOEXCEPT
  {
    auto const d = sys_days(y_ / m_ / last);
    return (d - (date::weekday{ d } -wdl_.weekday())).time_since_epoch();
  }

  CONSTCD11
    inline
    bool
    operator==(const year_month_weekday_last& x, const year_month_weekday_last& y) NOEXCEPT
  {
    return x.year() == y.year() && x.month() == y.month() &&
      x.weekday_last() == y.weekday_last();
  }

  CONSTCD11
    inline
    bool
    operator!=(const year_month_weekday_last& x, const year_month_weekday_last& y) NOEXCEPT
  {
    return !(x == y);
  }

  template<class CharT, class Traits>
  inline
    std::basic_ostream<CharT, Traits>&
    operator<<(std::basic_ostream<CharT, Traits>& os, const year_month_weekday_last& ymwdl)
  {
    return os << ymwdl.year() << '/' << ymwdl.month() << '/' << ymwdl.weekday_last();
  }

  template<class>
  CONSTCD14
    inline
    year_month_weekday_last
    operator+(const year_month_weekday_last& ymwdl, const months& dm) NOEXCEPT
  {
    return (ymwdl.year() / ymwdl.month() + dm) / ymwdl.weekday_last();
  }

  template<class>
  CONSTCD14
    inline
    year_month_weekday_last
    operator+(const months& dm, const year_month_weekday_last& ymwdl) NOEXCEPT
  {
    return ymwdl + dm;
  }

  template<class>
  CONSTCD14
    inline
    year_month_weekday_last
    operator-(const year_month_weekday_last& ymwdl, const months& dm) NOEXCEPT
  {
    return ymwdl + (-dm);
  }

  CONSTCD11
    inline
    year_month_weekday_last
    operator+(const year_month_weekday_last& ymwdl, const years& dy) NOEXCEPT
  {
    return { ymwdl.year() + dy, ymwdl.month(), ymwdl.weekday_last() };
  }

  CONSTCD11
    inline
    year_month_weekday_last
    operator+(const years& dy, const year_month_weekday_last& ymwdl) NOEXCEPT
  {
    return ymwdl + dy;
  }

  CONSTCD11
    inline
    year_month_weekday_last
    operator-(const year_month_weekday_last& ymwdl, const years& dy) NOEXCEPT
  {
    return ymwdl + (-dy);
  }

  // year_month from operator/()

  CONSTCD11
    inline
    year_month
    operator/(const year& y, const month& m) NOEXCEPT
  {
    return { y, m };
  }

  CONSTCD11
    inline
    year_month
    operator/(const year& y, int   m) NOEXCEPT
  {
    return y / month(static_cast<unsigned>(m));
  }

  // month_day from operator/()

  CONSTCD11
    inline
    month_day
    operator/(const month& m, const day& d) NOEXCEPT
  {
    return { m, d };
  }

  CONSTCD11
    inline
    month_day
    operator/(const day& d, const month& m) NOEXCEPT
  {
    return m / d;
  }

  CONSTCD11
    inline
    month_day
    operator/(const month& m, int d) NOEXCEPT
  {
    return m / day(static_cast<unsigned>(d));
  }

  CONSTCD11
    inline
    month_day
    operator/(int m, const day& d) NOEXCEPT
  {
    return month(static_cast<unsigned>(m)) / d;
  }

  CONSTCD11 inline month_day operator/(const day& d, int m) NOEXCEPT { return m / d; }

  // month_day_last from operator/()

  CONSTCD11
    inline
    month_day_last
    operator/(const month& m, last_spec) NOEXCEPT
  {
    return month_day_last{ m };
  }

  CONSTCD11
    inline
    month_day_last
    operator/(last_spec, const month& m) NOEXCEPT
  {
    return m / last;
  }

  CONSTCD11
    inline
    month_day_last
    operator/(int m, last_spec) NOEXCEPT
  {
    return month(static_cast<unsigned>(m)) / last;
  }

  CONSTCD11
    inline
    month_day_last
    operator/(last_spec, int m) NOEXCEPT
  {
    return m / last;
  }

  // month_weekday from operator/()

  CONSTCD11
    inline
    month_weekday
    operator/(const month& m, const weekday_indexed& wdi) NOEXCEPT
  {
    return { m, wdi };
  }

  CONSTCD11
    inline
    month_weekday
    operator/(const weekday_indexed& wdi, const month& m) NOEXCEPT
  {
    return m / wdi;
  }

  CONSTCD11
    inline
    month_weekday
    operator/(int m, const weekday_indexed& wdi) NOEXCEPT
  {
    return month(static_cast<unsigned>(m)) / wdi;
  }

  CONSTCD11
    inline
    month_weekday
    operator/(const weekday_indexed& wdi, int m) NOEXCEPT
  {
    return m / wdi;
  }

  // month_weekday_last from operator/()

  CONSTCD11
    inline
    month_weekday_last
    operator/(const month& m, const weekday_last& wdl) NOEXCEPT
  {
    return { m, wdl };
  }

  CONSTCD11
    inline
    month_weekday_last
    operator/(const weekday_last& wdl, const month& m) NOEXCEPT
  {
    return m / wdl;
  }

  CONSTCD11
    inline
    month_weekday_last
    operator/(int m, const weekday_last& wdl) NOEXCEPT
  {
    return month(static_cast<unsigned>(m)) / wdl;
  }

  CONSTCD11
    inline
    month_weekday_last
    operator/(const weekday_last& wdl, int m) NOEXCEPT
  {
    return m / wdl;
  }

  // year_month_day from operator/()

  CONSTCD11
    inline
    year_month_day
    operator/(const year_month& ym, const day& d) NOEXCEPT
  {
    return { ym.year(), ym.month(), d };
  }

  CONSTCD11
    inline
    year_month_day
    operator/(const year_month& ym, int d)  NOEXCEPT
  {
    return ym / day(static_cast<unsigned>(d));
  }

  CONSTCD11
    inline
    year_month_day
    operator/(const year& y, const month_day& md) NOEXCEPT
  {
    return y / md.month() / md.day();
  }

  CONSTCD11
    inline
    year_month_day
    operator/(int y, const month_day& md) NOEXCEPT
  {
    return year(y) / md;
  }

  CONSTCD11
    inline
    year_month_day
    operator/(const month_day& md, const year& y)  NOEXCEPT
  {
    return y / md;
  }

  CONSTCD11
    inline
    year_month_day
    operator/(const month_day& md, int y) NOEXCEPT
  {
    return year(y) / md;
  }

  // year_month_day_last from operator/()

  CONSTCD11
    inline
    year_month_day_last
    operator/(const year_month& ym, last_spec) NOEXCEPT
  {
    return { ym.year(), month_day_last{ym.month()} };
  }

  CONSTCD11
    inline
    year_month_day_last
    operator/(const year& y, const month_day_last& mdl) NOEXCEPT
  {
    return { y, mdl };
  }

  CONSTCD11
    inline
    year_month_day_last
    operator/(int y, const month_day_last& mdl) NOEXCEPT
  {
    return year(y) / mdl;
  }

  CONSTCD11
    inline
    year_month_day_last
    operator/(const month_day_last& mdl, const year& y) NOEXCEPT
  {
    return y / mdl;
  }

  CONSTCD11
    inline
    year_month_day_last
    operator/(const month_day_last& mdl, int y) NOEXCEPT
  {
    return year(y) / mdl;
  }

  // year_month_weekday from operator/()

  CONSTCD11
    inline
    year_month_weekday
    operator/(const year_month& ym, const weekday_indexed& wdi) NOEXCEPT
  {
    return { ym.year(), ym.month(), wdi };
  }

  CONSTCD11
    inline
    year_month_weekday
    operator/(const year& y, const month_weekday& mwd) NOEXCEPT
  {
    return { y, mwd.month(), mwd.weekday_indexed() };
  }

  CONSTCD11
    inline
    year_month_weekday
    operator/(int y, const month_weekday& mwd) NOEXCEPT
  {
    return year(y) / mwd;
  }

  CONSTCD11
    inline
    year_month_weekday
    operator/(const month_weekday& mwd, const year& y) NOEXCEPT
  {
    return y / mwd;
  }

  CONSTCD11
    inline
    year_month_weekday
    operator/(const month_weekday& mwd, int y) NOEXCEPT
  {
    return year(y) / mwd;
  }

  // year_month_weekday_last from operator/()

  CONSTCD11
    inline
    year_month_weekday_last
    operator/(const year_month& ym, const weekday_last& wdl) NOEXCEPT
  {
    return { ym.year(), ym.month(), wdl };
  }

  CONSTCD11
    inline
    year_month_weekday_last
    operator/(const year& y, const month_weekday_last& mwdl) NOEXCEPT
  {
    return { y, mwdl.month(), mwdl.weekday_last() };
  }

  CONSTCD11
    inline
    year_month_weekday_last
    operator/(int y, const month_weekday_last& mwdl) NOEXCEPT
  {
    return year(y) / mwdl;
  }

  CONSTCD11
    inline
    year_month_weekday_last
    operator/(const month_weekday_last& mwdl, const year& y) NOEXCEPT
  {
    return y / mwdl;
  }

  CONSTCD11
    inline
    year_month_weekday_last
    operator/(const month_weekday_last& mwdl, int y) NOEXCEPT
  {
    return year(y) / mwdl;
  }

  template <class Duration>
  struct fields;

  template <class CharT, class Traits, class Duration>
  std::basic_ostream<CharT, Traits>&
    to_stream(std::basic_ostream<CharT, Traits>& os, const CharT* fmt,
      const fields<Duration>& fds, const std::string* abbrev = nullptr,
      const std::chrono::seconds* offset_sec = nullptr);

  template <class CharT, class Traits, class Duration, class Alloc>
  std::basic_istream<CharT, Traits>&
    from_stream(std::basic_istream<CharT, Traits>& is, const CharT* fmt,
      fields<Duration>& fds, std::basic_string<CharT, Traits, Alloc>* abbrev = nullptr,
      std::chrono::minutes* offset = nullptr);

  // hh_mm_ss

  namespace detail
  {

    struct undocumented { explicit undocumented() = default; };

    // width<n>::value is the number of fractional decimal digits in 1/n
    // width<0>::value and width<1>::value are defined to be 0
    // If 1/n takes more than 18 fractional decimal digits,
    //   the result is truncated to 19.
    // Example:  width<2>::value    ==  1
    // Example:  width<3>::value    == 19
    // Example:  width<4>::value    ==  2
    // Example:  width<10>::value   ==  1
    // Example:  width<1000>::value ==  3
    template <std::uint64_t n, std::uint64_t d = 10, unsigned w = 0,
      bool should_continue = !(n < 2) && d != 0 && (w < 19)>
      struct width
    {
      static CONSTDATA unsigned value = 1 + width<n, d % n * 10, w + 1>::value;
    };

    template <std::uint64_t n, std::uint64_t d, unsigned w>
    struct width<n, d, w, false>
    {
      static CONSTDATA unsigned value = 0;
    };

    template <unsigned exp>
    struct static_pow10
    {
    private:
      static CONSTDATA std::uint64_t h = static_pow10<exp / 2>::value;
    public:
      static CONSTDATA std::uint64_t value = h * h * (exp % 2 ? 10 : 1);
    };

    template <>
    struct static_pow10<0>
    {
      static CONSTDATA std::uint64_t value = 1;
    };

    template <class Duration>
    class decimal_format_seconds
    {
      using CT = typename std::common_type<Duration, std::chrono::seconds>::type;
      using rep = typename CT::rep;
    public:
      static unsigned constexpr width = detail::width<CT::period::den>::value < 19 ?
        detail::width<CT::period::den>::value : 6u;
      using precision = std::chrono::duration<rep,
        std::ratio<1, static_pow10<width>::value>>;

    private:
      std::chrono::seconds s_;
      precision            sub_s_;

    public:
      CONSTCD11 decimal_format_seconds()
        : s_()
        , sub_s_()
      {}

      CONSTCD11 explicit decimal_format_seconds(const Duration& d) NOEXCEPT
        : s_(std::chrono::duration_cast<std::chrono::seconds>(d))
        , sub_s_(std::chrono::treat_as_floating_point<rep>::value ? d - s_ :
          std::chrono::duration_cast<precision>(d - s_))
      {}

      CONSTCD14 std::chrono::seconds& seconds() NOEXCEPT { return s_; }
      CONSTCD11 std::chrono::seconds seconds() const NOEXCEPT { return s_; }
      CONSTCD11 precision subseconds() const NOEXCEPT { return sub_s_; }

      CONSTCD14 precision to_duration() const NOEXCEPT
      {
        return s_ + sub_s_;
      }

      CONSTCD11 bool in_conventional_range() const NOEXCEPT
      {
        return sub_s_ < std::chrono::seconds{ 1 } && s_ < std::chrono::minutes{ 1 };
      }

      template <class CharT, class Traits>
      friend
        std::basic_ostream<CharT, Traits>&
        operator<<(std::basic_ostream<CharT, Traits>& os, const decimal_format_seconds& x)
      {
        return x.print(os, std::chrono::treat_as_floating_point<rep>{});
      }

      template <class CharT, class Traits>
      std::basic_ostream<CharT, Traits>&
        print(std::basic_ostream<CharT, Traits>& os, std::true_type) const
      {
        date::detail::save_ostream<CharT, Traits> _(os);
        std::chrono::duration<rep> d = s_ + sub_s_;
        if (d < std::chrono::seconds{ 10 })
          os << '0';
        os << std::fixed << d.count();
        return os;
      }

      template <class CharT, class Traits>
      std::basic_ostream<CharT, Traits>&
        print(std::basic_ostream<CharT, Traits>& os, std::false_type) const
      {
        date::detail::save_ostream<CharT, Traits> _(os);
        os.fill('0');
        os.flags(std::ios::dec | std::ios::right);
        os.width(2);
        os << s_.count();
        if (width > 0)
        {
#if !ONLY_C_LOCALE
          os << std::use_facet<std::numpunct<CharT>>(os.getloc()).decimal_point();
#else
          os << '.';
#endif
          date::detail::save_ostream<CharT, Traits> _s(os);
          os.imbue(std::locale::classic());
          os.width(width);
          os << sub_s_.count();
        }
        return os;
      }
    };

    template <class Rep, class Period>
    inline
      CONSTCD11
      typename std::enable_if
      <
      std::numeric_limits<Rep>::is_signed,
      std::chrono::duration<Rep, Period>
      >::type
      abs(std::chrono::duration<Rep, Period> d)
    {
      return d >= d.zero() ? +d : -d;
    }

    template <class Rep, class Period>
    inline
      CONSTCD11
      typename std::enable_if
      <
      !std::numeric_limits<Rep>::is_signed,
      std::chrono::duration<Rep, Period>
      >::type
      abs(std::chrono::duration<Rep, Period> d)
    {
      return d;
    }

  }  // namespace detail

  template <class Duration>
  class hh_mm_ss
  {
    using dfs = detail::decimal_format_seconds<typename std::common_type<Duration,
      std::chrono::seconds>::type>;

    std::chrono::hours h_;
    std::chrono::minutes m_;
    dfs s_;
    bool neg_;

  public:
    static unsigned CONSTDATA fractional_width = dfs::width;
    using precision = typename dfs::precision;

    CONSTCD11 hh_mm_ss() NOEXCEPT
      : hh_mm_ss(Duration::zero())
    {}

    CONSTCD11 explicit hh_mm_ss(Duration d) NOEXCEPT
      : h_(std::chrono::duration_cast<std::chrono::hours>(detail::abs(d)))
      , m_(std::chrono::duration_cast<std::chrono::minutes>(detail::abs(d)) - h_)
      , s_(detail::abs(d) - h_ - m_)
      , neg_(d < Duration::zero())
    {}

    CONSTCD11 std::chrono::hours hours() const NOEXCEPT { return h_; }
    CONSTCD11 std::chrono::minutes minutes() const NOEXCEPT { return m_; }
    CONSTCD11 std::chrono::seconds seconds() const NOEXCEPT { return s_.seconds(); }
    CONSTCD14 std::chrono::seconds&
      seconds(detail::undocumented) NOEXCEPT { return s_.seconds(); }
    CONSTCD11 precision subseconds() const NOEXCEPT { return s_.subseconds(); }
    CONSTCD11 bool is_negative() const NOEXCEPT { return neg_; }

    CONSTCD11 explicit operator precision()   const NOEXCEPT { return to_duration(); }
    CONSTCD11          precision to_duration() const NOEXCEPT
    {
      return (s_.to_duration() + m_ + h_) * (1 - 2 * neg_);
    }

    CONSTCD11 bool in_conventional_range() const NOEXCEPT
    {
      return !neg_ && h_ < days{ 1 } && m_ < std::chrono::hours{ 1 } &&
        s_.in_conventional_range();
    }

  private:

    template <class charT, class traits>
    friend
      std::basic_ostream<charT, traits>&
      operator<<(std::basic_ostream<charT, traits>& os, hh_mm_ss const& tod)
    {
      if (tod.is_negative())
        os << '-';
      if (tod.h_ < std::chrono::hours{ 10 })
        os << '0';
      os << tod.h_.count() << ':';
      if (tod.m_ < std::chrono::minutes{ 10 })
        os << '0';
      os << tod.m_.count() << ':' << tod.s_;
      return os;
    }

    template <class CharT, class Traits, class Duration2>
    friend
      std::basic_ostream<CharT, Traits>&
      date::to_stream(std::basic_ostream<CharT, Traits>& os, const CharT* fmt,
        const fields<Duration2>& fds, const std::string* abbrev,
        const std::chrono::seconds* offset_sec);

    template <class CharT, class Traits, class Duration2, class Alloc>
    friend
      std::basic_istream<CharT, Traits>&
      date::from_stream(std::basic_istream<CharT, Traits>& is, const CharT* fmt,
        fields<Duration2>& fds,
        std::basic_string<CharT, Traits, Alloc>* abbrev, std::chrono::minutes* offset);
  };

  inline
    CONSTCD14
    bool
    is_am(std::chrono::hours const& h) NOEXCEPT
  {
    using std::chrono::hours;
    return hours{ 0 } <= h && h < hours{ 12 };
  }

  inline
    CONSTCD14
    bool
    is_pm(std::chrono::hours const& h) NOEXCEPT
  {
    using std::chrono::hours;
    return hours{ 12 } <= h && h < hours{ 24 };
  }

  inline
    CONSTCD14
    std::chrono::hours
    make12(std::chrono::hours h) NOEXCEPT
  {
    using std::chrono::hours;
    if (h < hours{ 12 })
    {
      if (h == hours{ 0 })
        h = hours{ 12 };
    }
    else
    {
      if (h != hours{ 12 })
        h = h - hours{ 12 };
    }
    return h;
  }

  inline
    CONSTCD14
    std::chrono::hours
    make24(std::chrono::hours h, bool is_pm) NOEXCEPT
  {
    using std::chrono::hours;
    if (is_pm)
    {
      if (h != hours{ 12 })
        h = h + hours{ 12 };
    }
    else if (h == hours{ 12 })
      h = hours{ 0 };
    return h;
  }

  template <class Duration>
  using time_of_day = hh_mm_ss<Duration>;

  template <class Rep, class Period,
    class = typename std::enable_if
    <!std::chrono::treat_as_floating_point<Rep>::value>::type>
    CONSTCD11
    inline
    hh_mm_ss<std::chrono::duration<Rep, Period>>
    make_time(const std::chrono::duration<Rep, Period>& d)
  {
    return hh_mm_ss<std::chrono::duration<Rep, Period>>(d);
  }

  template <class CharT, class Traits, class Duration>
  inline
    typename std::enable_if
    <
    !std::chrono::treat_as_floating_point<typename Duration::rep>::value &&
    std::ratio_less<typename Duration::period, days::period>::value
    , std::basic_ostream<CharT, Traits>&
    >::type
    operator<<(std::basic_ostream<CharT, Traits>& os, const sys_time<Duration>& tp)
  {
    auto const dp = date::floor<days>(tp);
    return os << year_month_day(dp) << ' ' << make_time(tp - dp);
  }

  template <class CharT, class Traits>
  inline
    std::basic_ostream<CharT, Traits>&
    operator<<(std::basic_ostream<CharT, Traits>& os, const sys_days& dp)
  {
    return os << year_month_day(dp);
  }

  template <class CharT, class Traits, class Duration>
  inline
    std::basic_ostream<CharT, Traits>&
    operator<<(std::basic_ostream<CharT, Traits>& os, const local_time<Duration>& ut)
  {
    return (os << sys_time<Duration>{ut.time_since_epoch()});
  }

  namespace detail
  {

    template <class CharT, std::size_t N>
    class string_literal;

    template <class CharT1, class CharT2, std::size_t N1, std::size_t N2>
    inline
      CONSTCD14
      string_literal<typename std::conditional<sizeof(CharT2) <= sizeof(CharT1), CharT1, CharT2>::type,
      N1 + N2 - 1>
      operator+(const string_literal<CharT1, N1>& x, const string_literal<CharT2, N2>& y) NOEXCEPT;

    template <class CharT, std::size_t N>
    class string_literal
    {
      CharT p_[N];

      CONSTCD11 string_literal() NOEXCEPT
        : p_{}
      {}

    public:
      using const_iterator = const CharT*;

      string_literal(string_literal const&) = default;
      string_literal& operator=(string_literal const&) = delete;

      template <std::size_t N1 = 2,
        class = typename std::enable_if<N1 == N>::type>
        CONSTCD11 string_literal(CharT c) NOEXCEPT
        : p_{ c }
      {
      }

      template <std::size_t N1 = 3,
        class = typename std::enable_if<N1 == N>::type>
        CONSTCD11 string_literal(CharT c1, CharT c2) NOEXCEPT
        : p_{ c1, c2 }
      {
      }

      template <std::size_t N1 = 4,
        class = typename std::enable_if<N1 == N>::type>
        CONSTCD11 string_literal(CharT c1, CharT c2, CharT c3) NOEXCEPT
        : p_{ c1, c2, c3 }
      {
      }

      CONSTCD14 string_literal(const CharT(&a)[N]) NOEXCEPT
        : p_{}
      {
        for (std::size_t i = 0; i < N; ++i)
          p_[i] = a[i];
      }

      template <class U = CharT,
        class = typename std::enable_if<(1 < sizeof(U))>::type>
        CONSTCD14 string_literal(const char(&a)[N]) NOEXCEPT
        : p_ {}
      {
        for (std::size_t i = 0; i < N; ++i)
          p_[i] = a[i];
      }

      template <class CharT2,
        class = typename std::enable_if<!std::is_same<CharT2, CharT>::value>::type>
        CONSTCD14 string_literal(string_literal<CharT2, N> const& a) NOEXCEPT
        : p_{}
      {
        for (std::size_t i = 0; i < N; ++i)
          p_[i] = a[i];
      }

      CONSTCD11 const CharT* data() const NOEXCEPT { return p_; }
      CONSTCD11 std::size_t size() const NOEXCEPT { return N - 1; }

      CONSTCD11 const_iterator begin() const NOEXCEPT { return p_; }
      CONSTCD11 const_iterator end()   const NOEXCEPT { return p_ + N - 1; }

      CONSTCD11 CharT const& operator[](std::size_t n) const NOEXCEPT
      {
        return p_[n];
      }

      template <class Traits>
      friend
        std::basic_ostream<CharT, Traits>&
        operator<<(std::basic_ostream<CharT, Traits>& os, const string_literal& s)
      {
        return os << s.p_;
      }

      template <class CharT1, class CharT2, std::size_t N1, std::size_t N2>
      friend
        CONSTCD14
        string_literal<typename std::conditional<sizeof(CharT2) <= sizeof(CharT1), CharT1, CharT2>::type,
        N1 + N2 - 1>
        operator+(const string_literal<CharT1, N1>& x, const string_literal<CharT2, N2>& y) NOEXCEPT;
    };

    template <class CharT>
    CONSTCD11
      inline
      string_literal<CharT, 3>
      operator+(const string_literal<CharT, 2>& x, const string_literal<CharT, 2>& y) NOEXCEPT
    {
      return string_literal<CharT, 3>(x[0], y[0]);
    }

    template <class CharT>
    CONSTCD11
      inline
      string_literal<CharT, 4>
      operator+(const string_literal<CharT, 3>& x, const string_literal<CharT, 2>& y) NOEXCEPT
    {
      return string_literal<CharT, 4>(x[0], x[1], y[0]);
    }

    template <class CharT1, class CharT2, std::size_t N1, std::size_t N2>
    CONSTCD14
      inline
      string_literal<typename std::conditional<sizeof(CharT2) <= sizeof(CharT1), CharT1, CharT2>::type,
      N1 + N2 - 1>
      operator+(const string_literal<CharT1, N1>& x, const string_literal<CharT2, N2>& y) NOEXCEPT
    {
      using CT = typename std::conditional<sizeof(CharT2) <= sizeof(CharT1), CharT1, CharT2>::type;

      string_literal<CT, N1 + N2 - 1> r;
      std::size_t i = 0;
      for (; i < N1 - 1; ++i)
        r.p_[i] = CT(x.p_[i]);
      for (std::size_t j = 0; j < N2; ++j, ++i)
        r.p_[i] = CT(y.p_[j]);

      return r;
    }


    template <class CharT, class Traits, class Alloc, std::size_t N>
    inline
      std::basic_string<CharT, Traits, Alloc>
      operator+(std::basic_string<CharT, Traits, Alloc> x, const string_literal<CharT, N>& y)
    {
      x.append(y.data(), y.size());
      return x;
    }

#if __cplusplus >= 201402  && (!defined(__EDG_VERSION__) || __EDG_VERSION__ > 411) \
                           && (!defined(__SUNPRO_CC) || __SUNPRO_CC > 0x5150)

    template <class CharT,
      class = std::enable_if_t < std::is_same<CharT, char>{} ||
      std::is_same<CharT, wchar_t>{} ||
      std::is_same<CharT, char16_t>{} ||
      std::is_same<CharT, char32_t>{} >>
      CONSTCD14
      inline
      string_literal<CharT, 2>
      msl(CharT c) NOEXCEPT
    {
      return string_literal<CharT, 2>{c};
    }

    CONSTCD14
      inline
      std::size_t
      to_string_len(std::intmax_t i)
    {
      std::size_t r = 0;
      do
      {
        i /= 10;
        ++r;
      } while (i > 0);
      return r;
    }

    template <std::intmax_t N>
    CONSTCD14
      inline
      std::enable_if_t
      <
      N < 10,
      string_literal<char, to_string_len(N) + 1>
      >
      msl() NOEXCEPT
    {
      return msl(char(N % 10 + '0'));
    }

    template <std::intmax_t N>
    CONSTCD14
      inline
      std::enable_if_t
      <
      10 <= N,
      string_literal<char, to_string_len(N) + 1>
      >
      msl() NOEXCEPT
    {
      return msl<N / 10>() + msl(char(N % 10 + '0'));
    }

    template <class CharT, std::intmax_t N, std::intmax_t D>
    CONSTCD14
      inline
      std::enable_if_t
      <
      std::ratio<N, D>::type::den != 1,
      string_literal<CharT, to_string_len(std::ratio<N, D>::type::num) +
      to_string_len(std::ratio<N, D>::type::den) + 4>
      >
      msl(std::ratio<N, D>) NOEXCEPT
    {
      using R = typename std::ratio<N, D>::type;
      return msl(CharT{ '[' }) + msl<R::num>() + msl(CharT{ '/' }) +
        msl<R::den>() + msl(CharT{ ']' });
    }

    template <class CharT, std::intmax_t N, std::intmax_t D>
    CONSTCD14
      inline
      std::enable_if_t
      <
      std::ratio<N, D>::type::den == 1,
      string_literal<CharT, to_string_len(std::ratio<N, D>::type::num) + 3>
      >
      msl(std::ratio<N, D>) NOEXCEPT
    {
      using R = typename std::ratio<N, D>::type;
      return msl(CharT{ '[' }) + msl<R::num>() + msl(CharT{ ']' });
    }


#else  // __cplusplus < 201402 || (defined(__EDG_VERSION__) && __EDG_VERSION__ <= 411)

    inline
      std::string
      to_string(std::uint64_t x)
    {
      return std::to_string(x);
    }

    template <class CharT>
    inline
      std::basic_string<CharT>
      to_string(std::uint64_t x)
    {
      auto y = std::to_string(x);
      return std::basic_string<CharT>(y.begin(), y.end());
    }

    template <class CharT, std::intmax_t N, std::intmax_t D>
    inline
      typename std::enable_if
      <
      std::ratio<N, D>::type::den != 1,
      std::basic_string<CharT>
      >::type
      msl(std::ratio<N, D>)
    {
      using R = typename std::ratio<N, D>::type;
      return std::basic_string<CharT>(1, '[') + to_string<CharT>(R::num) + CharT{ '/' } +
        to_string<CharT>(R::den) + CharT{ ']' };
    }

    template <class CharT, std::intmax_t N, std::intmax_t D>
    inline
      typename std::enable_if
      <
      std::ratio<N, D>::type::den == 1,
      std::basic_string<CharT>
      >::type
      msl(std::ratio<N, D>)
    {
      using R = typename std::ratio<N, D>::type;
      return std::basic_string<CharT>(1, '[') + to_string<CharT>(R::num) + CharT{ ']' };
    }

#endif  // __cplusplus < 201402 || (defined(__EDG_VERSION__) && __EDG_VERSION__ <= 411)

    template <class CharT>
    CONSTCD11
      inline
      string_literal<CharT, 2>
      msl(std::atto) NOEXCEPT
    {
      return string_literal<CharT, 2>{'a'};
    }

    template <class CharT>
    CONSTCD11
      inline
      string_literal<CharT, 2>
      msl(std::femto) NOEXCEPT
    {
      return string_literal<CharT, 2>{'f'};
    }

    template <class CharT>
    CONSTCD11
      inline
      string_literal<CharT, 2>
      msl(std::pico) NOEXCEPT
    {
      return string_literal<CharT, 2>{'p'};
    }

    template <class CharT>
    CONSTCD11
      inline
      string_literal<CharT, 2>
      msl(std::nano) NOEXCEPT
    {
      return string_literal<CharT, 2>{'n'};
    }

    template <class CharT>
    CONSTCD11
      inline
      typename std::enable_if
      <
      std::is_same<CharT, char>::value,
      string_literal<char, 3>
      >::type
      msl(std::micro) NOEXCEPT
    {
      return string_literal<char, 3>{'\xC2', '\xB5'};
    }

    template <class CharT>
    CONSTCD11
      inline
      typename std::enable_if
      <
      !std::is_same<CharT, char>::value,
      string_literal<CharT, 2>
      >::type
      msl(std::micro) NOEXCEPT
    {
      return string_literal<CharT, 2>{CharT{ static_cast<unsigned char>('\xB5') }};
    }

    template <class CharT>
    CONSTCD11
      inline
      string_literal<CharT, 2>
      msl(std::milli) NOEXCEPT
    {
      return string_literal<CharT, 2>{'m'};
    }

    template <class CharT>
    CONSTCD11
      inline
      string_literal<CharT, 2>
      msl(std::centi) NOEXCEPT
    {
      return string_literal<CharT, 2>{'c'};
    }

    template <class CharT>
    CONSTCD11
      inline
      string_literal<CharT, 3>
      msl(std::deca) NOEXCEPT
    {
      return string_literal<CharT, 3>{'d', 'a'};
    }

    template <class CharT>
    CONSTCD11
      inline
      string_literal<CharT, 2>
      msl(std::deci) NOEXCEPT
    {
      return string_literal<CharT, 2>{'d'};
    }

    template <class CharT>
    CONSTCD11
      inline
      string_literal<CharT, 2>
      msl(std::hecto) NOEXCEPT
    {
      return string_literal<CharT, 2>{'h'};
    }

    template <class CharT>
    CONSTCD11
      inline
      string_literal<CharT, 2>
      msl(std::kilo) NOEXCEPT
    {
      return string_literal<CharT, 2>{'k'};
    }

    template <class CharT>
    CONSTCD11
      inline
      string_literal<CharT, 2>
      msl(std::mega) NOEXCEPT
    {
      return string_literal<CharT, 2>{'M'};
    }

    template <class CharT>
    CONSTCD11
      inline
      string_literal<CharT, 2>
      msl(std::giga) NOEXCEPT
    {
      return string_literal<CharT, 2>{'G'};
    }

    template <class CharT>
    CONSTCD11
      inline
      string_literal<CharT, 2>
      msl(std::tera) NOEXCEPT
    {
      return string_literal<CharT, 2>{'T'};
    }

    template <class CharT>
    CONSTCD11
      inline
      string_literal<CharT, 2>
      msl(std::peta) NOEXCEPT
    {
      return string_literal<CharT, 2>{'P'};
    }

    template <class CharT>
    CONSTCD11
      inline
      string_literal<CharT, 2>
      msl(std::exa) NOEXCEPT
    {
      return string_literal<CharT, 2>{'E'};
    }

    template <class CharT, class Period>
    CONSTCD11
      inline
      auto
      get_units(Period p)
      -> decltype(msl<CharT>(p) + string_literal<CharT, 2>{'s'})
    {
      return msl<CharT>(p) + string_literal<CharT, 2>{'s'};
    }

    template <class CharT>
    CONSTCD11
      inline
      string_literal<CharT, 2>
      get_units(std::ratio<1>)
    {
      return string_literal<CharT, 2>{'s'};
    }

    template <class CharT>
    CONSTCD11
      inline
      string_literal<CharT, 2>
      get_units(std::ratio<3600>)
    {
      return string_literal<CharT, 2>{'h'};
    }

    template <class CharT>
    CONSTCD11
      inline
      string_literal<CharT, 4>
      get_units(std::ratio<60>)
    {
      return string_literal<CharT, 4>{'m', 'i', 'n'};
    }

    template <class CharT>
    CONSTCD11
      inline
      string_literal<CharT, 2>
      get_units(std::ratio<86400>)
    {
      return string_literal<CharT, 2>{'d'};
    }

    template <class CharT, class Traits = std::char_traits<CharT>>
    struct make_string;

    template <>
    struct make_string<char>
    {
      template <class Rep>
      static
        std::string
        from(Rep n)
      {
        return std::to_string(n);
      }
    };

    template <class Traits>
    struct make_string<char, Traits>
    {
      template <class Rep>
      static
        std::basic_string<char, Traits>
        from(Rep n)
      {
        auto s = std::to_string(n);
        return std::basic_string<char, Traits>(s.begin(), s.end());
      }
    };

    template <>
    struct make_string<wchar_t>
    {
      template <class Rep>
      static
        std::wstring
        from(Rep n)
      {
        return std::to_wstring(n);
      }
    };

    template <class Traits>
    struct make_string<wchar_t, Traits>
    {
      template <class Rep>
      static
        std::basic_string<wchar_t, Traits>
        from(Rep n)
      {
        auto s = std::to_wstring(n);
        return std::basic_string<wchar_t, Traits>(s.begin(), s.end());
      }
    };

  }  // namespace detail

  // to_stream

  CONSTDATA year nanyear{ -32768 };

  template <class Duration>
  struct fields
  {
    year_month_day        ymd{ nanyear / 0 / 0 };
    weekday               wd{ 8u };
    hh_mm_ss<Duration>    tod{};
    bool                  has_tod = false;

    fields() = default;

    fields(year_month_day ymd_) : ymd(ymd_) {}
    fields(weekday wd_) : wd(wd_) {}
    fields(hh_mm_ss<Duration> tod_) : tod(tod_), has_tod(true) {}

    fields(year_month_day ymd_, weekday wd_) : ymd(ymd_), wd(wd_) {}
    fields(year_month_day ymd_, hh_mm_ss<Duration> tod_) : ymd(ymd_), tod(tod_),
      has_tod(true) {}

    fields(weekday wd_, hh_mm_ss<Duration> tod_) : wd(wd_), tod(tod_), has_tod(true) {}

    fields(year_month_day ymd_, weekday wd_, hh_mm_ss<Duration> tod_)
      : ymd(ymd_)
      , wd(wd_)
      , tod(tod_)
      , has_tod(true)
    {}
  };

  namespace detail
  {

    template <class CharT, class Traits, class Duration>
    unsigned
      extract_weekday(std::basic_ostream<CharT, Traits>& os, const fields<Duration>& fds)
    {
      if (!fds.ymd.ok() && !fds.wd.ok())
      {
        // fds does not contain a valid weekday
        os.setstate(std::ios::failbit);
        return 8;
      }
      weekday wd;
      if (fds.ymd.ok())
      {
        wd = weekday{ sys_days(fds.ymd) };
        if (fds.wd.ok() && wd != fds.wd)
        {
          // fds.ymd and fds.wd are inconsistent
          os.setstate(std::ios::failbit);
          return 8;
        }
      }
      else
        wd = fds.wd;
      return static_cast<unsigned>((wd - Sunday).count());
    }

    template <class CharT, class Traits, class Duration>
    unsigned
      extract_month(std::basic_ostream<CharT, Traits>& os, const fields<Duration>& fds)
    {
      if (!fds.ymd.month().ok())
      {
        // fds does not contain a valid month
        os.setstate(std::ios::failbit);
        return 0;
      }
      return static_cast<unsigned>(fds.ymd.month());
    }

  }  // namespace detail

#if ONLY_C_LOCALE

  namespace detail
  {

    inline
      std::pair<const std::string*, const std::string*>
      weekday_names()
    {
      static const std::string nm[] =
      {
          "Sunday",
          "Monday",
          "Tuesday",
          "Wednesday",
          "Thursday",
          "Friday",
          "Saturday",
          "Sun",
          "Mon",
          "Tue",
          "Wed",
          "Thu",
          "Fri",
          "Sat"
      };
      return std::make_pair(nm, nm + sizeof(nm) / sizeof(nm[0]));
    }

    inline
      std::pair<const std::string*, const std::string*>
      month_names()
    {
      static const std::string nm[] =
      {
          "January",
          "February",
          "March",
          "April",
          "May",
          "June",
          "July",
          "August",
          "September",
          "October",
          "November",
          "December",
          "Jan",
          "Feb",
          "Mar",
          "Apr",
          "May",
          "Jun",
          "Jul",
          "Aug",
          "Sep",
          "Oct",
          "Nov",
          "Dec"
      };
      return std::make_pair(nm, nm + sizeof(nm) / sizeof(nm[0]));
    }

    inline
      std::pair<const std::string*, const std::string*>
      ampm_names()
    {
      static const std::string nm[] =
      {
          "AM",
          "PM"
      };
      return std::make_pair(nm, nm + sizeof(nm) / sizeof(nm[0]));
    }

    template <class CharT, class Traits, class FwdIter>
    FwdIter
      scan_keyword(std::basic_istream<CharT, Traits>& is, FwdIter kb, FwdIter ke)
    {
      size_t nkw = static_cast<size_t>(std::distance(kb, ke));
      const unsigned char doesnt_match = '\0';
      const unsigned char might_match = '\1';
      const unsigned char does_match = '\2';
      unsigned char statbuf[100];
      unsigned char* status = statbuf;
      std::unique_ptr<unsigned char, void(*)(void*)> stat_hold(0, free);
      if (nkw > sizeof(statbuf))
      {
        status = (unsigned char*)std::malloc(nkw);
        if (status == nullptr)
          throw std::bad_alloc();
        stat_hold.reset(status);
      }
      size_t n_might_match = nkw;  // At this point, any keyword might match
      size_t n_does_match = 0;     // but none of them definitely do
      // Initialize all statuses to might_match, except for "" keywords are does_match
      unsigned char* st = status;
      for (auto ky = kb; ky != ke; ++ky, ++st)
      {
        if (!ky->empty())
          *st = might_match;
        else
        {
          *st = does_match;
          --n_might_match;
          ++n_does_match;
        }
      }
      // While there might be a match, test keywords against the next CharT
      for (size_t indx = 0; is && n_might_match > 0; ++indx)
      {
        // Peek at the next CharT but don't consume it
        auto ic = is.peek();
        if (ic == EOF)
        {
          is.setstate(std::ios::eofbit);
          break;
        }
        auto c = static_cast<char>(toupper(ic));
        bool consume = false;
        // For each keyword which might match, see if the indx character is c
        // If a match if found, consume c
        // If a match is found, and that is the last character in the keyword,
        //    then that keyword matches.
        // If the keyword doesn't match this character, then change the keyword
        //    to doesn't match
        st = status;
        for (auto ky = kb; ky != ke; ++ky, ++st)
        {
          if (*st == might_match)
          {
            if (c == static_cast<char>(toupper((*ky)[indx])))
            {
              consume = true;
              if (ky->size() == indx + 1)
              {
                *st = does_match;
                --n_might_match;
                ++n_does_match;
              }
            }
            else
            {
              *st = doesnt_match;
              --n_might_match;
            }
          }
        }
        // consume if we matched a character
        if (consume)
        {
          (void)is.get();
          // If we consumed a character and there might be a matched keyword that
          //   was marked matched on a previous iteration, then such keywords
          //   are now marked as not matching.
          if (n_might_match + n_does_match > 1)
          {
            st = status;
            for (auto ky = kb; ky != ke; ++ky, ++st)
            {
              if (*st == does_match && ky->size() != indx + 1)
              {
                *st = doesnt_match;
                --n_does_match;
              }
            }
          }
        }
      }
      // We've exited the loop because we hit eof and/or we have no more "might matches".
      // Return the first matching result
      for (st = status; kb != ke; ++kb, ++st)
        if (*st == does_match)
          break;
      if (kb == ke)
        is.setstate(std::ios::failbit);
      return kb;
    }

  }  // namespace detail

#endif  // ONLY_C_LOCALE

  template <class CharT, class Traits, class Duration>
  std::basic_ostream<CharT, Traits>&
    to_stream(std::basic_ostream<CharT, Traits>& os, const CharT* fmt,
      const fields<Duration>& fds, const std::string* abbrev,
      const std::chrono::seconds* offset_sec)
  {
#if ONLY_C_LOCALE
    using detail::weekday_names;
    using detail::month_names;
    using detail::ampm_names;
#endif
    using detail::save_ostream;
    using detail::get_units;
    using detail::extract_weekday;
    using detail::extract_month;
    using std::ios;
    using std::chrono::duration_cast;
    using std::chrono::seconds;
    using std::chrono::minutes;
    using std::chrono::hours;
    date::detail::save_ostream<CharT, Traits> ss(os);
    os.fill(' ');
    os.flags(std::ios::skipws | std::ios::dec);
    os.width(0);
    tm tm{};
    bool insert_negative = fds.has_tod && fds.tod.to_duration() < Duration::zero();
#if !ONLY_C_LOCALE
    auto& facet = std::use_facet<std::time_put<CharT>>(os.getloc());
#endif
    const CharT* command = nullptr;
    CharT modified = CharT{};
    for (; *fmt; ++fmt)
    {
      switch (*fmt)
      {
      case 'a':
      case 'A':
        if (command)
        {
          if (modified == CharT{})
          {
            tm.tm_wday = static_cast<int>(extract_weekday(os, fds));
            if (os.fail())
              return os;
#if !ONLY_C_LOCALE
            const CharT f[] = { '%', *fmt };
            facet.put(os, os, os.fill(), &tm, std::begin(f), std::end(f));
#else  // ONLY_C_LOCALE
            os << weekday_names().first[tm.tm_wday + 7 * (*fmt == 'a')];
#endif  // ONLY_C_LOCALE
          }
          else
          {
            os << CharT{ '%' } << modified << *fmt;
            modified = CharT{};
          }
          command = nullptr;
        }
        else
          os << *fmt;
        break;
      case 'b':
      case 'B':
      case 'h':
        if (command)
        {
          if (modified == CharT{})
          {
            tm.tm_mon = static_cast<int>(extract_month(os, fds)) - 1;
#if !ONLY_C_LOCALE
            const CharT f[] = { '%', *fmt };
            facet.put(os, os, os.fill(), &tm, std::begin(f), std::end(f));
#else  // ONLY_C_LOCALE
            os << month_names().first[tm.tm_mon + 12 * (*fmt != 'B')];
#endif  // ONLY_C_LOCALE
          }
          else
          {
            os << CharT{ '%' } << modified << *fmt;
            modified = CharT{};
          }
          command = nullptr;
        }
        else
          os << *fmt;
        break;
      case 'c':
      case 'x':
        if (command)
        {
          if (modified == CharT{ 'O' })
            os << CharT{ '%' } << modified << *fmt;
          else
          {
            if (!fds.ymd.ok())
              os.setstate(std::ios::failbit);
            if (*fmt == 'c' && !fds.has_tod)
              os.setstate(std::ios::failbit);
#if !ONLY_C_LOCALE
            tm = std::tm{};
            auto const& ymd = fds.ymd;
            auto ld = local_days(ymd);
            if (*fmt == 'c')
            {
              tm.tm_sec = static_cast<int>(fds.tod.seconds().count());
              tm.tm_min = static_cast<int>(fds.tod.minutes().count());
              tm.tm_hour = static_cast<int>(fds.tod.hours().count());
            }
            tm.tm_mday = static_cast<int>(static_cast<unsigned>(ymd.day()));
            tm.tm_mon = static_cast<int>(extract_month(os, fds) - 1);
            tm.tm_year = static_cast<int>(ymd.year()) - 1900;
            tm.tm_wday = static_cast<int>(extract_weekday(os, fds));
            if (os.fail())
              return os;
            tm.tm_yday = static_cast<int>((ld - local_days(ymd.year() / 1 / 1)).count());
            CharT f[3] = { '%' };
            auto fe = std::begin(f) + 1;
            if (modified == CharT{ 'E' })
              *fe++ = modified;
            *fe++ = *fmt;
            facet.put(os, os, os.fill(), &tm, std::begin(f), fe);
#else  // ONLY_C_LOCALE
            if (*fmt == 'c')
            {
              auto wd = static_cast<int>(extract_weekday(os, fds));
              os << weekday_names().first[static_cast<unsigned>(wd) + 7]
                << ' ';
              os << month_names().first[extract_month(os, fds) - 1 + 12] << ' ';
              auto d = static_cast<int>(static_cast<unsigned>(fds.ymd.day()));
              if (d < 10)
                os << ' ';
              os << d << ' '
                << make_time(duration_cast<seconds>(fds.tod.to_duration()))
                << ' ' << fds.ymd.year();

            }
            else  // *fmt == 'x'
            {
              auto const& ymd = fds.ymd;
              save_ostream<CharT, Traits> _(os);
              os.fill('0');
              os.flags(std::ios::dec | std::ios::right);
              os.width(2);
              os << static_cast<unsigned>(ymd.month()) << CharT{ '/' };
              os.width(2);
              os << static_cast<unsigned>(ymd.day()) << CharT{ '/' };
              os.width(2);
              os << static_cast<int>(ymd.year()) % 100;
            }
#endif  // ONLY_C_LOCALE
          }
          command = nullptr;
          modified = CharT{};
        }
        else
          os << *fmt;
        break;
      case 'C':
        if (command)
        {
          if (modified == CharT{ 'O' })
            os << CharT{ '%' } << modified << *fmt;
          else
          {
            if (!fds.ymd.year().ok())
              os.setstate(std::ios::failbit);
            auto y = static_cast<int>(fds.ymd.year());
#if !ONLY_C_LOCALE
            if (modified == CharT{})
#endif
            {
              save_ostream<CharT, Traits> _(os);
              os.fill('0');
              os.flags(std::ios::dec | std::ios::right);
              if (y >= 0)
              {
                os.width(2);
                os << y / 100;
              }
              else
              {
                os << CharT{ '-' };
                os.width(2);
                os << -(y - 99) / 100;
              }
            }
#if !ONLY_C_LOCALE
            else if (modified == CharT{ 'E' })
            {
              tm.tm_year = y - 1900;
              CharT f[3] = { '%', 'E', 'C' };
              facet.put(os, os, os.fill(), &tm, std::begin(f), std::end(f));
            }
#endif
          }
          command = nullptr;
          modified = CharT{};
        }
        else
          os << *fmt;
        break;
      case 'd':
      case 'e':
        if (command)
        {
          if (modified == CharT{ 'E' })
            os << CharT{ '%' } << modified << *fmt;
          else
          {
            if (!fds.ymd.day().ok())
              os.setstate(std::ios::failbit);
            auto d = static_cast<int>(static_cast<unsigned>(fds.ymd.day()));
#if !ONLY_C_LOCALE
            if (modified == CharT{})
#endif
            {
              save_ostream<CharT, Traits> _(os);
              if (*fmt == CharT{ 'd' })
                os.fill('0');
              else
                os.fill(' ');
              os.flags(std::ios::dec | std::ios::right);
              os.width(2);
              os << d;
            }
#if !ONLY_C_LOCALE
            else if (modified == CharT{ 'O' })
            {
              tm.tm_mday = d;
              CharT f[3] = { '%', 'O', *fmt };
              facet.put(os, os, os.fill(), &tm, std::begin(f), std::end(f));
            }
#endif
          }
          command = nullptr;
          modified = CharT{};
        }
        else
          os << *fmt;
        break;
      case 'D':
        if (command)
        {
          if (modified == CharT{})
          {
            if (!fds.ymd.ok())
              os.setstate(std::ios::failbit);
            auto const& ymd = fds.ymd;
            save_ostream<CharT, Traits> _(os);
            os.fill('0');
            os.flags(std::ios::dec | std::ios::right);
            os.width(2);
            os << static_cast<unsigned>(ymd.month()) << CharT{ '/' };
            os.width(2);
            os << static_cast<unsigned>(ymd.day()) << CharT{ '/' };
            os.width(2);
            os << static_cast<int>(ymd.year()) % 100;
          }
          else
          {
            os << CharT{ '%' } << modified << *fmt;
            modified = CharT{};
          }
          command = nullptr;
        }
        else
          os << *fmt;
        break;
      case 'F':
        if (command)
        {
          if (modified == CharT{})
          {
            if (!fds.ymd.ok())
              os.setstate(std::ios::failbit);
            auto const& ymd = fds.ymd;
            save_ostream<CharT, Traits> _(os);
            os.imbue(std::locale::classic());
            os.fill('0');
            os.flags(std::ios::dec | std::ios::right);
            os.width(4);
            os << static_cast<int>(ymd.year()) << CharT{ '-' };
            os.width(2);
            os << static_cast<unsigned>(ymd.month()) << CharT{ '-' };
            os.width(2);
            os << static_cast<unsigned>(ymd.day());
          }
          else
          {
            os << CharT{ '%' } << modified << *fmt;
            modified = CharT{};
          }
          command = nullptr;
        }
        else
          os << *fmt;
        break;
      case 'g':
      case 'G':
        if (command)
        {
          if (modified == CharT{})
          {
            if (!fds.ymd.ok())
              os.setstate(std::ios::failbit);
            auto ld = local_days(fds.ymd);
            auto y = year_month_day{ ld + days{3} }.year();
            auto start = local_days((y - years{ 1 }) / December / Thursday[last]) +
              (Monday - Thursday);
            if (ld < start)
              --y;
            if (*fmt == CharT{ 'G' })
              os << y;
            else
            {
              save_ostream<CharT, Traits> _(os);
              os.fill('0');
              os.flags(std::ios::dec | std::ios::right);
              os.width(2);
              os << std::abs(static_cast<int>(y)) % 100;
            }
          }
          else
          {
            os << CharT{ '%' } << modified << *fmt;
            modified = CharT{};
          }
          command = nullptr;
        }
        else
          os << *fmt;
        break;
      case 'H':
      case 'I':
        if (command)
        {
          if (modified == CharT{ 'E' })
            os << CharT{ '%' } << modified << *fmt;
          else
          {
            if (!fds.has_tod)
              os.setstate(std::ios::failbit);
            if (insert_negative)
            {
              os << '-';
              insert_negative = false;
            }
            auto hms = fds.tod;
#if !ONLY_C_LOCALE
            if (modified == CharT{})
#endif
            {
              auto h = *fmt == CharT{ 'I' } ? date::make12(hms.hours()) : hms.hours();
              if (h < hours{ 10 })
                os << CharT{ '0' };
              os << h.count();
            }
#if !ONLY_C_LOCALE
            else if (modified == CharT{ 'O' })
            {
              const CharT f[] = { '%', modified, *fmt };
              tm.tm_hour = static_cast<int>(hms.hours().count());
              facet.put(os, os, os.fill(), &tm, std::begin(f), std::end(f));
            }
#endif
          }
          modified = CharT{};
          command = nullptr;
        }
        else
          os << *fmt;
        break;
      case 'j':
        if (command)
        {
          if (modified == CharT{})
          {
            if (fds.ymd.ok() || fds.has_tod)
            {
              days doy;
              if (fds.ymd.ok())
              {
                auto ld = local_days(fds.ymd);
                auto y = fds.ymd.year();
                doy = ld - local_days(y / January / 1) + days{ 1 };
              }
              else
              {
                doy = duration_cast<days>(fds.tod.to_duration());
              }
              save_ostream<CharT, Traits> _(os);
              os.fill('0');
              os.flags(std::ios::dec | std::ios::right);
              os.width(3);
              os << doy.count();
            }
            else
            {
              os.setstate(std::ios::failbit);
            }
          }
          else
          {
            os << CharT{ '%' } << modified << *fmt;
            modified = CharT{};
          }
          command = nullptr;
        }
        else
          os << *fmt;
        break;
      case 'm':
        if (command)
        {
          if (modified == CharT{ 'E' })
            os << CharT{ '%' } << modified << *fmt;
          else
          {
            if (!fds.ymd.month().ok())
              os.setstate(std::ios::failbit);
            auto m = static_cast<unsigned>(fds.ymd.month());
#if !ONLY_C_LOCALE
            if (modified == CharT{})
#endif
            {
              if (m < 10)
                os << CharT{ '0' };
              os << m;
            }
#if !ONLY_C_LOCALE
            else if (modified == CharT{ 'O' })
            {
              const CharT f[] = { '%', modified, *fmt };
              tm.tm_mon = static_cast<int>(m - 1);
              facet.put(os, os, os.fill(), &tm, std::begin(f), std::end(f));
            }
#endif
          }
          modified = CharT{};
          command = nullptr;
        }
        else
          os << *fmt;
        break;
      case 'M':
        if (command)
        {
          if (modified == CharT{ 'E' })
            os << CharT{ '%' } << modified << *fmt;
          else
          {
            if (!fds.has_tod)
              os.setstate(std::ios::failbit);
            if (insert_negative)
            {
              os << '-';
              insert_negative = false;
            }
#if !ONLY_C_LOCALE
            if (modified == CharT{})
#endif
            {
              if (fds.tod.minutes() < minutes{ 10 })
                os << CharT{ '0' };
              os << fds.tod.minutes().count();
            }
#if !ONLY_C_LOCALE
            else if (modified == CharT{ 'O' })
            {
              const CharT f[] = { '%', modified, *fmt };
              tm.tm_min = static_cast<int>(fds.tod.minutes().count());
              facet.put(os, os, os.fill(), &tm, std::begin(f), std::end(f));
            }
#endif
          }
          modified = CharT{};
          command = nullptr;
        }
        else
          os << *fmt;
        break;
      case 'n':
        if (command)
        {
          if (modified == CharT{})
            os << CharT{ '\n' };
          else
          {
            os << CharT{ '%' } << modified << *fmt;
            modified = CharT{};
          }
          command = nullptr;
        }
        else
          os << *fmt;
        break;
      case 'p':
        if (command)
        {
          if (modified == CharT{})
          {
            if (!fds.has_tod)
              os.setstate(std::ios::failbit);
#if !ONLY_C_LOCALE
            const CharT f[] = { '%', *fmt };
            tm.tm_hour = static_cast<int>(fds.tod.hours().count());
            facet.put(os, os, os.fill(), &tm, std::begin(f), std::end(f));
#else
            if (date::is_am(fds.tod.hours()))
              os << ampm_names().first[0];
            else
              os << ampm_names().first[1];
#endif
          }
          else
          {
            os << CharT{ '%' } << modified << *fmt;
          }
          modified = CharT{};
          command = nullptr;
        }
        else
          os << *fmt;
        break;
      case 'Q':
      case 'q':
        if (command)
        {
          if (modified == CharT{})
          {
            if (!fds.has_tod)
              os.setstate(std::ios::failbit);
            auto d = fds.tod.to_duration();
            if (*fmt == 'q')
              os << get_units<CharT>(typename decltype(d)::period::type{});
            else
              os << d.count();
          }
          else
          {
            os << CharT{ '%' } << modified << *fmt;
          }
          modified = CharT{};
          command = nullptr;
        }
        else
          os << *fmt;
        break;
      case 'r':
        if (command)
        {
          if (modified == CharT{})
          {
            if (!fds.has_tod)
              os.setstate(std::ios::failbit);
#if !ONLY_C_LOCALE
            const CharT f[] = { '%', *fmt };
            tm.tm_hour = static_cast<int>(fds.tod.hours().count());
            tm.tm_min = static_cast<int>(fds.tod.minutes().count());
            tm.tm_sec = static_cast<int>(fds.tod.seconds().count());
            facet.put(os, os, os.fill(), &tm, std::begin(f), std::end(f));
#else
            hh_mm_ss<seconds> tod(duration_cast<seconds>(fds.tod.to_duration()));
            save_ostream<CharT, Traits> _(os);
            os.fill('0');
            os.width(2);
            os << date::make12(tod.hours()).count() << CharT{ ':' };
            os.width(2);
            os << tod.minutes().count() << CharT{ ':' };
            os.width(2);
            os << tod.seconds().count() << CharT{ ' ' };
            if (date::is_am(tod.hours()))
              os << ampm_names().first[0];
            else
              os << ampm_names().first[1];
#endif
          }
          else
          {
            os << CharT{ '%' } << modified << *fmt;
          }
          modified = CharT{};
          command = nullptr;
        }
        else
          os << *fmt;
        break;
      case 'R':
        if (command)
        {
          if (modified == CharT{})
          {
            if (!fds.has_tod)
              os.setstate(std::ios::failbit);
            if (fds.tod.hours() < hours{ 10 })
              os << CharT{ '0' };
            os << fds.tod.hours().count() << CharT{ ':' };
            if (fds.tod.minutes() < minutes{ 10 })
              os << CharT{ '0' };
            os << fds.tod.minutes().count();
          }
          else
          {
            os << CharT{ '%' } << modified << *fmt;
            modified = CharT{};
          }
          command = nullptr;
        }
        else
          os << *fmt;
        break;
      case 'S':
        if (command)
        {
          if (modified == CharT{ 'E' })
            os << CharT{ '%' } << modified << *fmt;
          else
          {
            if (!fds.has_tod)
              os.setstate(std::ios::failbit);
            if (insert_negative)
            {
              os << '-';
              insert_negative = false;
            }
#if !ONLY_C_LOCALE
            if (modified == CharT{})
#endif
            {
              os << fds.tod.s_;
            }
#if !ONLY_C_LOCALE
            else if (modified == CharT{ 'O' })
            {
              const CharT f[] = { '%', modified, *fmt };
              tm.tm_sec = static_cast<int>(fds.tod.s_.seconds().count());
              facet.put(os, os, os.fill(), &tm, std::begin(f), std::end(f));
            }
#endif
          }
          modified = CharT{};
          command = nullptr;
        }
        else
          os << *fmt;
        break;
      case 't':
        if (command)
        {
          if (modified == CharT{})
            os << CharT{ '\t' };
          else
          {
            os << CharT{ '%' } << modified << *fmt;
            modified = CharT{};
          }
          command = nullptr;
        }
        else
          os << *fmt;
        break;
      case 'T':
        if (command)
        {
          if (modified == CharT{})
          {
            if (!fds.has_tod)
              os.setstate(std::ios::failbit);
            os << fds.tod;
          }
          else
          {
            os << CharT{ '%' } << modified << *fmt;
            modified = CharT{};
          }
          command = nullptr;
        }
        else
          os << *fmt;
        break;
      case 'u':
        if (command)
        {
          if (modified == CharT{ 'E' })
            os << CharT{ '%' } << modified << *fmt;
          else
          {
            auto wd = extract_weekday(os, fds);
#if !ONLY_C_LOCALE
            if (modified == CharT{})
#endif
            {
              os << (wd != 0 ? wd : 7u);
            }
#if !ONLY_C_LOCALE
            else if (modified == CharT{ 'O' })
            {
              const CharT f[] = { '%', modified, *fmt };
              tm.tm_wday = static_cast<int>(wd);
              facet.put(os, os, os.fill(), &tm, std::begin(f), std::end(f));
            }
#endif
          }
          modified = CharT{};
          command = nullptr;
        }
        else
          os << *fmt;
        break;
      case 'U':
        if (command)
        {
          if (modified == CharT{ 'E' })
            os << CharT{ '%' } << modified << *fmt;
          else
          {
            auto const& ymd = fds.ymd;
            if (!ymd.ok())
              os.setstate(std::ios::failbit);
            auto ld = local_days(ymd);
#if !ONLY_C_LOCALE
            if (modified == CharT{})
#endif
            {
              auto st = local_days(Sunday[1] / January / ymd.year());
              if (ld < st)
                os << CharT{ '0' } << CharT{ '0' };
              else
              {
                auto wn = duration_cast<weeks>(ld - st).count() + 1;
                if (wn < 10)
                  os << CharT{ '0' };
                os << wn;
              }
            }
#if !ONLY_C_LOCALE
            else if (modified == CharT{ 'O' })
            {
              const CharT f[] = { '%', modified, *fmt };
              tm.tm_year = static_cast<int>(ymd.year()) - 1900;
              tm.tm_wday = static_cast<int>(extract_weekday(os, fds));
              if (os.fail())
                return os;
              tm.tm_yday = static_cast<int>((ld - local_days(ymd.year() / 1 / 1)).count());
              facet.put(os, os, os.fill(), &tm, std::begin(f), std::end(f));
            }
#endif
          }
          modified = CharT{};
          command = nullptr;
        }
        else
          os << *fmt;
        break;
      case 'V':
        if (command)
        {
          if (modified == CharT{ 'E' })
            os << CharT{ '%' } << modified << *fmt;
          else
          {
            if (!fds.ymd.ok())
              os.setstate(std::ios::failbit);
            auto ld = local_days(fds.ymd);
#if !ONLY_C_LOCALE
            if (modified == CharT{})
#endif
            {
              auto y = year_month_day{ ld + days{3} }.year();
              auto st = local_days((y - years{ 1 }) / 12 / Thursday[last]) +
                (Monday - Thursday);
              if (ld < st)
              {
                --y;
                st = local_days((y - years{ 1 }) / 12 / Thursday[last]) +
                  (Monday - Thursday);
              }
              auto wn = duration_cast<weeks>(ld - st).count() + 1;
              if (wn < 10)
                os << CharT{ '0' };
              os << wn;
            }
#if !ONLY_C_LOCALE
            else if (modified == CharT{ 'O' })
            {
              const CharT f[] = { '%', modified, *fmt };
              auto const& ymd = fds.ymd;
              tm.tm_year = static_cast<int>(ymd.year()) - 1900;
              tm.tm_wday = static_cast<int>(extract_weekday(os, fds));
              if (os.fail())
                return os;
              tm.tm_yday = static_cast<int>((ld - local_days(ymd.year() / 1 / 1)).count());
              facet.put(os, os, os.fill(), &tm, std::begin(f), std::end(f));
            }
#endif
          }
          modified = CharT{};
          command = nullptr;
        }
        else
          os << *fmt;
        break;
      case 'w':
        if (command)
        {
          auto wd = extract_weekday(os, fds);
          if (os.fail())
            return os;
#if !ONLY_C_LOCALE
          if (modified == CharT{})
#else
          if (modified != CharT{ 'E' })
#endif
          {
            os << wd;
          }
#if !ONLY_C_LOCALE
          else if (modified == CharT{ 'O' })
          {
            const CharT f[] = { '%', modified, *fmt };
            tm.tm_wday = static_cast<int>(wd);
            facet.put(os, os, os.fill(), &tm, std::begin(f), std::end(f));
          }
#endif
          else
          {
            os << CharT{ '%' } << modified << *fmt;
          }
          modified = CharT{};
          command = nullptr;
        }
        else
          os << *fmt;
        break;
      case 'W':
        if (command)
        {
          if (modified == CharT{ 'E' })
            os << CharT{ '%' } << modified << *fmt;
          else
          {
            auto const& ymd = fds.ymd;
            if (!ymd.ok())
              os.setstate(std::ios::failbit);
            auto ld = local_days(ymd);
#if !ONLY_C_LOCALE
            if (modified == CharT{})
#endif
            {
              auto st = local_days(Monday[1] / January / ymd.year());
              if (ld < st)
                os << CharT{ '0' } << CharT{ '0' };
              else
              {
                auto wn = duration_cast<weeks>(ld - st).count() + 1;
                if (wn < 10)
                  os << CharT{ '0' };
                os << wn;
              }
            }
#if !ONLY_C_LOCALE
            else if (modified == CharT{ 'O' })
            {
              const CharT f[] = { '%', modified, *fmt };
              tm.tm_year = static_cast<int>(ymd.year()) - 1900;
              tm.tm_wday = static_cast<int>(extract_weekday(os, fds));
              if (os.fail())
                return os;
              tm.tm_yday = static_cast<int>((ld - local_days(ymd.year() / 1 / 1)).count());
              facet.put(os, os, os.fill(), &tm, std::begin(f), std::end(f));
            }
#endif
          }
          modified = CharT{};
          command = nullptr;
        }
        else
          os << *fmt;
        break;
      case 'X':
        if (command)
        {
          if (modified == CharT{ 'O' })
            os << CharT{ '%' } << modified << *fmt;
          else
          {
            if (!fds.has_tod)
              os.setstate(std::ios::failbit);
#if !ONLY_C_LOCALE
            tm = std::tm{};
            tm.tm_sec = static_cast<int>(fds.tod.seconds().count());
            tm.tm_min = static_cast<int>(fds.tod.minutes().count());
            tm.tm_hour = static_cast<int>(fds.tod.hours().count());
            CharT f[3] = { '%' };
            auto fe = std::begin(f) + 1;
            if (modified == CharT{ 'E' })
              *fe++ = modified;
            *fe++ = *fmt;
            facet.put(os, os, os.fill(), &tm, std::begin(f), fe);
#else
            os << fds.tod;
#endif
          }
          command = nullptr;
          modified = CharT{};
        }
        else
          os << *fmt;
        break;
      case 'y':
        if (command)
        {
          if (!fds.ymd.year().ok())
            os.setstate(std::ios::failbit);
          auto y = static_cast<int>(fds.ymd.year());
#if !ONLY_C_LOCALE
          if (modified == CharT{})
          {
#endif
            y = std::abs(y) % 100;
            if (y < 10)
              os << CharT{ '0' };
            os << y;
#if !ONLY_C_LOCALE
          }
          else
          {
            const CharT f[] = { '%', modified, *fmt };
            tm.tm_year = y - 1900;
            facet.put(os, os, os.fill(), &tm, std::begin(f), std::end(f));
          }
#endif
          modified = CharT{};
          command = nullptr;
        }
        else
          os << *fmt;
        break;
      case 'Y':
        if (command)
        {
          if (modified == CharT{ 'O' })
            os << CharT{ '%' } << modified << *fmt;
          else
          {
            if (!fds.ymd.year().ok())
              os.setstate(std::ios::failbit);
            auto y = fds.ymd.year();
#if !ONLY_C_LOCALE
            if (modified == CharT{})
#endif
            {
              save_ostream<CharT, Traits> _(os);
              os.imbue(std::locale::classic());
              os << y;
            }
#if !ONLY_C_LOCALE
            else if (modified == CharT{ 'E' })
            {
              const CharT f[] = { '%', modified, *fmt };
              tm.tm_year = static_cast<int>(y) - 1900;
              facet.put(os, os, os.fill(), &tm, std::begin(f), std::end(f));
            }
#endif
          }
          modified = CharT{};
          command = nullptr;
        }
        else
          os << *fmt;
        break;
      case 'z':
        if (command)
        {
          if (offset_sec == nullptr)
          {
            // Can not format %z with unknown offset
            os.setstate(ios::failbit);
            return os;
          }
          auto m = duration_cast<minutes>(*offset_sec);
          auto neg = m < minutes{ 0 };
          m = date::abs(m);
          auto h = duration_cast<hours>(m);
          m -= h;
          if (neg)
            os << CharT{ '-' };
          else
            os << CharT{ '+' };
          if (h < hours{ 10 })
            os << CharT{ '0' };
          os << h.count();
          if (modified != CharT{})
            os << CharT{ ':' };
          if (m < minutes{ 10 })
            os << CharT{ '0' };
          os << m.count();
          command = nullptr;
          modified = CharT{};
        }
        else
          os << *fmt;
        break;
      case 'Z':
        if (command)
        {
          if (modified == CharT{})
          {
            if (abbrev == nullptr)
            {
              // Can not format %Z with unknown time_zone
              os.setstate(ios::failbit);
              return os;
            }
            for (auto c : *abbrev)
              os << CharT(c);
          }
          else
          {
            os << CharT{ '%' } << modified << *fmt;
            modified = CharT{};
          }
          command = nullptr;
        }
        else
          os << *fmt;
        break;
      case 'E':
      case 'O':
        if (command)
        {
          if (modified == CharT{})
          {
            modified = *fmt;
          }
          else
          {
            os << CharT{ '%' } << modified << *fmt;
            command = nullptr;
            modified = CharT{};
          }
        }
        else
          os << *fmt;
        break;
      case '%':
        if (command)
        {
          if (modified == CharT{})
          {
            os << CharT{ '%' };
            command = nullptr;
          }
          else
          {
            os << CharT{ '%' } << modified << CharT{ '%' };
            command = nullptr;
            modified = CharT{};
          }
        }
        else
          command = fmt;
        break;
      default:
        if (command)
        {
          os << CharT{ '%' };
          command = nullptr;
        }
        if (modified != CharT{})
        {
          os << modified;
          modified = CharT{};
        }
        os << *fmt;
        break;
      }
    }
    if (command)
      os << CharT{ '%' };
    if (modified != CharT{})
      os << modified;
    return os;
  }

  template <class CharT, class Traits>
  inline
    std::basic_ostream<CharT, Traits>&
    to_stream(std::basic_ostream<CharT, Traits>& os, const CharT* fmt, const year& y)
  {
    using CT = std::chrono::seconds;
    fields<CT> fds{ y / 0 / 0 };
    return to_stream(os, fmt, fds);
  }

  template <class CharT, class Traits>
  inline
    std::basic_ostream<CharT, Traits>&
    to_stream(std::basic_ostream<CharT, Traits>& os, const CharT* fmt, const month& m)
  {
    using CT = std::chrono::seconds;
    fields<CT> fds{ m / 0 / nanyear };
    return to_stream(os, fmt, fds);
  }

  template <class CharT, class Traits>
  inline
    std::basic_ostream<CharT, Traits>&
    to_stream(std::basic_ostream<CharT, Traits>& os, const CharT* fmt, const day& d)
  {
    using CT = std::chrono::seconds;
    fields<CT> fds{ d / 0 / nanyear };
    return to_stream(os, fmt, fds);
  }

  template <class CharT, class Traits>
  inline
    std::basic_ostream<CharT, Traits>&
    to_stream(std::basic_ostream<CharT, Traits>& os, const CharT* fmt, const weekday& wd)
  {
    using CT = std::chrono::seconds;
    fields<CT> fds{ wd };
    return to_stream(os, fmt, fds);
  }

  template <class CharT, class Traits>
  inline
    std::basic_ostream<CharT, Traits>&
    to_stream(std::basic_ostream<CharT, Traits>& os, const CharT* fmt, const year_month& ym)
  {
    using CT = std::chrono::seconds;
    fields<CT> fds{ ym / 0 };
    return to_stream(os, fmt, fds);
  }

  template <class CharT, class Traits>
  inline
    std::basic_ostream<CharT, Traits>&
    to_stream(std::basic_ostream<CharT, Traits>& os, const CharT* fmt, const month_day& md)
  {
    using CT = std::chrono::seconds;
    fields<CT> fds{ md / nanyear };
    return to_stream(os, fmt, fds);
  }

  template <class CharT, class Traits>
  inline
    std::basic_ostream<CharT, Traits>&
    to_stream(std::basic_ostream<CharT, Traits>& os, const CharT* fmt,
      const year_month_day& ymd)
  {
    using CT = std::chrono::seconds;
    fields<CT> fds{ ymd };
    return to_stream(os, fmt, fds);
  }

  template <class CharT, class Traits, class Rep, class Period>
  inline
    std::basic_ostream<CharT, Traits>&
    to_stream(std::basic_ostream<CharT, Traits>& os, const CharT* fmt,
      const std::chrono::duration<Rep, Period>& d)
  {
    using Duration = std::chrono::duration<Rep, Period>;
    using CT = typename std::common_type<Duration, std::chrono::seconds>::type;
    fields<CT> fds{ hh_mm_ss<CT>{d} };
    return to_stream(os, fmt, fds);
  }

  template <class CharT, class Traits, class Duration>
  std::basic_ostream<CharT, Traits>&
    to_stream(std::basic_ostream<CharT, Traits>& os, const CharT* fmt,
      const local_time<Duration>& tp, const std::string* abbrev = nullptr,
      const std::chrono::seconds* offset_sec = nullptr)
  {
    using CT = typename std::common_type<Duration, std::chrono::seconds>::type;
    auto ld = floor<days>(tp);
    fields<CT> fds{ year_month_day{ld}, hh_mm_ss<CT>{tp - local_seconds{ld}} };
    return to_stream(os, fmt, fds, abbrev, offset_sec);
  }

  template <class CharT, class Traits, class Duration>
  std::basic_ostream<CharT, Traits>&
    to_stream(std::basic_ostream<CharT, Traits>& os, const CharT* fmt,
      const sys_time<Duration>& tp)
  {
    using std::chrono::seconds;
    using CT = typename std::common_type<Duration, seconds>::type;
    const std::string abbrev("UTC");
    CONSTDATA seconds offset{ 0 };
    auto sd = floor<days>(tp);
    fields<CT> fds{ year_month_day{sd}, hh_mm_ss<CT>{tp - sys_seconds{sd}} };
    return to_stream(os, fmt, fds, &abbrev, &offset);
  }

  // format

  template <class CharT, class Streamable>
  auto
    format(const std::locale& loc, const CharT* fmt, const Streamable& tp)
    -> decltype(to_stream(std::declval<std::basic_ostream<CharT>&>(), fmt, tp),
      std::basic_string<CharT>{})
  {
    std::basic_ostringstream<CharT> os;
    os.exceptions(std::ios::failbit | std::ios::badbit);
    os.imbue(loc);
    to_stream(os, fmt, tp);
    return os.str();
  }

  template <class CharT, class Streamable>
  auto
    format(const CharT* fmt, const Streamable& tp)
    -> decltype(to_stream(std::declval<std::basic_ostream<CharT>&>(), fmt, tp),
      std::basic_string<CharT>{})
  {
    std::basic_ostringstream<CharT> os;
    os.exceptions(std::ios::failbit | std::ios::badbit);
    to_stream(os, fmt, tp);
    return os.str();
  }

  template <class CharT, class Traits, class Alloc, class Streamable>
  auto
    format(const std::locale& loc, const std::basic_string<CharT, Traits, Alloc>& fmt,
      const Streamable& tp)
    -> decltype(to_stream(std::declval<std::basic_ostream<CharT, Traits>&>(), fmt.c_str(), tp),
      std::basic_string<CharT, Traits, Alloc>{})
  {
    std::basic_ostringstream<CharT, Traits, Alloc> os;
    os.exceptions(std::ios::failbit | std::ios::badbit);
    os.imbue(loc);
    to_stream(os, fmt.c_str(), tp);
    return os.str();
  }

  template <class CharT, class Traits, class Alloc, class Streamable>
  auto
    format(const std::basic_string<CharT, Traits, Alloc>& fmt, const Streamable& tp)
    -> decltype(to_stream(std::declval<std::basic_ostream<CharT, Traits>&>(), fmt.c_str(), tp),
      std::basic_string<CharT, Traits, Alloc>{})
  {
    std::basic_ostringstream<CharT, Traits, Alloc> os;
    os.exceptions(std::ios::failbit | std::ios::badbit);
    to_stream(os, fmt.c_str(), tp);
    return os.str();
  }

  // parse

  namespace detail
  {

    template <class CharT, class Traits>
    bool
      read_char(std::basic_istream<CharT, Traits>& is, CharT fmt, std::ios::iostate& err)
    {
      auto ic = is.get();
      if (Traits::eq_int_type(ic, Traits::eof()) ||
        !Traits::eq(Traits::to_char_type(ic), fmt))
      {
        err |= std::ios::failbit;
        is.setstate(std::ios::failbit);
        return false;
      }
      return true;
    }

    template <class CharT, class Traits>
    unsigned
      read_unsigned(std::basic_istream<CharT, Traits>& is, unsigned m = 1, unsigned M = 10)
    {
      unsigned x = 0;
      unsigned count = 0;
      while (true)
      {
        auto ic = is.peek();
        if (Traits::eq_int_type(ic, Traits::eof()))
          break;
        auto c = static_cast<char>(Traits::to_char_type(ic));
        if (!('0' <= c && c <= '9'))
          break;
        (void)is.get();
        ++count;
        x = 10 * x + static_cast<unsigned>(c - '0');
        if (count == M)
          break;
      }
      if (count < m)
        is.setstate(std::ios::failbit);
      return x;
    }

    template <class CharT, class Traits>
    int
      read_signed(std::basic_istream<CharT, Traits>& is, unsigned m = 1, unsigned M = 10)
    {
      auto ic = is.peek();
      if (!Traits::eq_int_type(ic, Traits::eof()))
      {
        auto c = static_cast<char>(Traits::to_char_type(ic));
        if (('0' <= c && c <= '9') || c == '-' || c == '+')
        {
          if (c == '-' || c == '+')
            (void)is.get();
          auto x = static_cast<int>(read_unsigned(is, std::max(m, 1u), M));
          if (!is.fail())
          {
            if (c == '-')
              x = -x;
            return x;
          }
        }
      }
      if (m > 0)
        is.setstate(std::ios::failbit);
      return 0;
    }

    template <class CharT, class Traits>
    long double
      read_long_double(std::basic_istream<CharT, Traits>& is, unsigned m = 1, unsigned M = 10)
    {
      unsigned count = 0;
      auto decimal_point = Traits::to_int_type(
        std::use_facet<std::numpunct<CharT>>(is.getloc()).decimal_point());
      std::string buf;
      while (true)
      {
        auto ic = is.peek();
        if (Traits::eq_int_type(ic, Traits::eof()))
          break;
        if (Traits::eq_int_type(ic, decimal_point))
        {
          buf += '.';
          decimal_point = Traits::eof();
          is.get();
        }
        else
        {
          auto c = static_cast<char>(Traits::to_char_type(ic));
          if (!('0' <= c && c <= '9'))
            break;
          buf += c;
          (void)is.get();
        }
        if (++count == M)
          break;
      }
      if (count < m)
      {
        is.setstate(std::ios::failbit);
        return 0;
      }
      return std::stold(buf);
    }

    struct rs
    {
      int& i;
      unsigned m;
      unsigned M;
    };

    struct ru
    {
      int& i;
      unsigned m;
      unsigned M;
    };

    struct rld
    {
      long double& i;
      unsigned m;
      unsigned M;
    };

    template <class CharT, class Traits>
    void
      read(std::basic_istream<CharT, Traits>&)
    {
    }

    template <class CharT, class Traits, class ...Args>
    void
      read(std::basic_istream<CharT, Traits>& is, CharT a0, Args&& ...args);

    template <class CharT, class Traits, class ...Args>
    void
      read(std::basic_istream<CharT, Traits>& is, rs a0, Args&& ...args);

    template <class CharT, class Traits, class ...Args>
    void
      read(std::basic_istream<CharT, Traits>& is, ru a0, Args&& ...args);

    template <class CharT, class Traits, class ...Args>
    void
      read(std::basic_istream<CharT, Traits>& is, int a0, Args&& ...args);

    template <class CharT, class Traits, class ...Args>
    void
      read(std::basic_istream<CharT, Traits>& is, rld a0, Args&& ...args);

    template <class CharT, class Traits, class ...Args>
    void
      read(std::basic_istream<CharT, Traits>& is, CharT a0, Args&& ...args)
    {
      // No-op if a0 == CharT{}
      if (a0 != CharT{})
      {
        auto ic = is.peek();
        if (Traits::eq_int_type(ic, Traits::eof()))
        {
          is.setstate(std::ios::failbit | std::ios::eofbit);
          return;
        }
        if (!Traits::eq(Traits::to_char_type(ic), a0))
        {
          is.setstate(std::ios::failbit);
          return;
        }
        (void)is.get();
      }
      read(is, std::forward<Args>(args)...);
    }

    template <class CharT, class Traits, class ...Args>
    void
      read(std::basic_istream<CharT, Traits>& is, rs a0, Args&& ...args)
    {
      auto x = read_signed(is, a0.m, a0.M);
      if (is.fail())
        return;
      a0.i = x;
      read(is, std::forward<Args>(args)...);
    }

    template <class CharT, class Traits, class ...Args>
    void
      read(std::basic_istream<CharT, Traits>& is, ru a0, Args&& ...args)
    {
      auto x = read_unsigned(is, a0.m, a0.M);
      if (is.fail())
        return;
      a0.i = static_cast<int>(x);
      read(is, std::forward<Args>(args)...);
    }

    template <class CharT, class Traits, class ...Args>
    void
      read(std::basic_istream<CharT, Traits>& is, int a0, Args&& ...args)
    {
      if (a0 != -1)
      {
        auto u = static_cast<unsigned>(a0);
        CharT buf[std::numeric_limits<unsigned>::digits10 + 2u] = {};
        auto e = buf;
        do
        {
          *e++ = static_cast<CharT>(CharT(u % 10) + CharT{ '0' });
          u /= 10;
        } while (u > 0);
        std::reverse(buf, e);
        for (auto p = buf; p != e && is.rdstate() == std::ios::goodbit; ++p)
          read(is, *p);
      }
      if (is.rdstate() == std::ios::goodbit)
        read(is, std::forward<Args>(args)...);
    }

    template <class CharT, class Traits, class ...Args>
    void
      read(std::basic_istream<CharT, Traits>& is, rld a0, Args&& ...args)
    {
      auto x = read_long_double(is, a0.m, a0.M);
      if (is.fail())
        return;
      a0.i = x;
      read(is, std::forward<Args>(args)...);
    }

    template <class T, class CharT, class Traits>
    inline
      void
      checked_set(T& value, T from, T not_a_value, std::basic_ios<CharT, Traits>& is)
    {
      if (!is.fail())
      {
        if (value == not_a_value)
          value = std::move(from);
        else if (value != from)
          is.setstate(std::ios::failbit);
      }
    }

  }  // namespace detail;

  template <class CharT, class Traits, class Duration, class Alloc = std::allocator<CharT>>
  std::basic_istream<CharT, Traits>&
    from_stream(std::basic_istream<CharT, Traits>& is, const CharT* fmt,
      fields<Duration>& fds, std::basic_string<CharT, Traits, Alloc>* abbrev,
      std::chrono::minutes* offset)
  {
    using std::numeric_limits;
    using std::ios;
    using std::chrono::duration;
    using std::chrono::duration_cast;
    using std::chrono::seconds;
    using std::chrono::minutes;
    using std::chrono::hours;
    typename std::basic_istream<CharT, Traits>::sentry ok{ is, true };
    if (ok)
    {
      date::detail::save_istream<CharT, Traits> ss(is);
      is.fill(' ');
      is.flags(std::ios::skipws | std::ios::dec);
      is.width(0);
#if !ONLY_C_LOCALE
      auto& f = std::use_facet<std::time_get<CharT>>(is.getloc());
      std::tm tm{};
#endif
      const CharT* command = nullptr;
      auto modified = CharT{};
      auto width = -1;

      CONSTDATA int not_a_year = numeric_limits<int>::min();
      CONSTDATA int not_a_2digit_year = 100;
      CONSTDATA int not_a_century = not_a_year / 100;
      CONSTDATA int not_a_month = 0;
      CONSTDATA int not_a_day = 0;
      CONSTDATA int not_a_hour = numeric_limits<int>::min();
      CONSTDATA int not_a_hour_12_value = 0;
      CONSTDATA int not_a_minute = not_a_hour;
      CONSTDATA Duration not_a_second = Duration::min();
      CONSTDATA int not_a_doy = -1;
      CONSTDATA int not_a_weekday = 8;
      CONSTDATA int not_a_week_num = 100;
      CONSTDATA int not_a_ampm = -1;
      CONSTDATA minutes not_a_offset = minutes::min();

      int Y = not_a_year;             // c, F, Y                   *
      int y = not_a_2digit_year;      // D, x, y                   *
      int g = not_a_2digit_year;      // g                         *
      int G = not_a_year;             // G                         *
      int C = not_a_century;          // C                         *
      int m = not_a_month;            // b, B, h, m, c, D, F, x    *
      int d = not_a_day;              // c, d, D, e, F, x          *
      int j = not_a_doy;              // j                         *
      int wd = not_a_weekday;         // a, A, u, w                *
      int H = not_a_hour;             // c, H, R, T, X             *
      int I = not_a_hour_12_value;    // I, r                      *
      int p = not_a_ampm;             // p, r                      *
      int M = not_a_minute;           // c, M, r, R, T, X          *
      Duration s = not_a_second;      // c, r, S, T, X             *
      int U = not_a_week_num;         // U                         *
      int V = not_a_week_num;         // V                         *
      int W = not_a_week_num;         // W                         *
      std::basic_string<CharT, Traits, Alloc> temp_abbrev;  // Z   *
      minutes temp_offset = not_a_offset;  // z                    *

      using detail::read;
      using detail::rs;
      using detail::ru;
      using detail::rld;
      using detail::checked_set;
      for (; *fmt != CharT{} && !is.fail(); ++fmt)
      {
        switch (*fmt)
        {
        case 'a':
        case 'A':
        case 'u':
        case 'w':  // wd:  a, A, u, w
          if (command)
          {
            int trial_wd = not_a_weekday;
            if (*fmt == 'a' || *fmt == 'A')
            {
              if (modified == CharT{})
              {
#if !ONLY_C_LOCALE
                ios::iostate err = ios::goodbit;
                f.get(is, nullptr, is, err, &tm, command, fmt + 1);
                is.setstate(err);
                if (!is.fail())
                  trial_wd = tm.tm_wday;
#else
                auto nm = detail::weekday_names();
                auto i = detail::scan_keyword(is, nm.first, nm.second) - nm.first;
                if (!is.fail())
                  trial_wd = i % 7;
#endif
              }
              else
                read(is, CharT{ '%' }, width, modified, *fmt);
            }
            else  // *fmt == 'u' || *fmt == 'w'
            {
#if !ONLY_C_LOCALE
              if (modified == CharT{})
#else
              if (modified != CharT{ 'E' })
#endif
              {
                read(is, ru{ trial_wd, 1, width == -1 ?
                                          1u : static_cast<unsigned>(width) });
                if (!is.fail())
                {
                  if (*fmt == 'u')
                  {
                    if (!(1 <= trial_wd && trial_wd <= 7))
                    {
                      trial_wd = not_a_weekday;
                      is.setstate(ios::failbit);
                    }
                    else if (trial_wd == 7)
                      trial_wd = 0;
                  }
                  else  // *fmt == 'w'
                  {
                    if (!(0 <= trial_wd && trial_wd <= 6))
                    {
                      trial_wd = not_a_weekday;
                      is.setstate(ios::failbit);
                    }
                  }
                }
              }
#if !ONLY_C_LOCALE
              else if (modified == CharT{ 'O' })
              {
                ios::iostate err = ios::goodbit;
                f.get(is, nullptr, is, err, &tm, command, fmt + 1);
                is.setstate(err);
                if (!is.fail())
                  trial_wd = tm.tm_wday;
              }
#endif
              else
                read(is, CharT{ '%' }, width, modified, *fmt);
            }
            if (trial_wd != not_a_weekday)
              checked_set(wd, trial_wd, not_a_weekday, is);
          }
          else  // !command
            read(is, *fmt);
          command = nullptr;
          width = -1;
          modified = CharT{};
          break;
        case 'b':
        case 'B':
        case 'h':
          if (command)
          {
            if (modified == CharT{})
            {
              int ttm = not_a_month;
#if !ONLY_C_LOCALE
              ios::iostate err = ios::goodbit;
              f.get(is, nullptr, is, err, &tm, command, fmt + 1);
              if ((err & ios::failbit) == 0)
                ttm = tm.tm_mon + 1;
              is.setstate(err);
#else
              auto nm = detail::month_names();
              auto i = detail::scan_keyword(is, nm.first, nm.second) - nm.first;
              if (!is.fail())
                ttm = i % 12 + 1;
#endif
              checked_set(m, ttm, not_a_month, is);
            }
            else
              read(is, CharT{ '%' }, width, modified, *fmt);
            command = nullptr;
            width = -1;
            modified = CharT{};
          }
          else
            read(is, *fmt);
          break;
        case 'c':
          if (command)
          {
            if (modified != CharT{ 'O' })
            {
#if !ONLY_C_LOCALE
              ios::iostate err = ios::goodbit;
              f.get(is, nullptr, is, err, &tm, command, fmt + 1);
              if ((err & ios::failbit) == 0)
              {
                checked_set(Y, tm.tm_year + 1900, not_a_year, is);
                checked_set(m, tm.tm_mon + 1, not_a_month, is);
                checked_set(d, tm.tm_mday, not_a_day, is);
                checked_set(H, tm.tm_hour, not_a_hour, is);
                checked_set(M, tm.tm_min, not_a_minute, is);
                checked_set(s, duration_cast<Duration>(seconds{ tm.tm_sec }),
                  not_a_second, is);
              }
              is.setstate(err);
#else
              // "%a %b %e %T %Y"
              auto nm = detail::weekday_names();
              auto i = detail::scan_keyword(is, nm.first, nm.second) - nm.first;
              checked_set(wd, static_cast<int>(i % 7), not_a_weekday, is);
              ws(is);
              nm = detail::month_names();
              i = detail::scan_keyword(is, nm.first, nm.second) - nm.first;
              checked_set(m, static_cast<int>(i % 12 + 1), not_a_month, is);
              ws(is);
              int td = not_a_day;
              read(is, rs{ td, 1, 2 });
              checked_set(d, td, not_a_day, is);
              ws(is);
              using dfs = detail::decimal_format_seconds<Duration>;
              CONSTDATA auto w = Duration::period::den == 1 ? 2 : 3 + dfs::width;
              int tH;
              int tM;
              long double S;
              read(is, ru{ tH, 1, 2 }, CharT{ ':' }, ru{ tM, 1, 2 },
                CharT{ ':' }, rld{ S, 1, w });
              checked_set(H, tH, not_a_hour, is);
              checked_set(M, tM, not_a_minute, is);
              checked_set(s, round<Duration>(duration<long double>{S}),
                not_a_second, is);
              ws(is);
              int tY = not_a_year;
              read(is, rs{ tY, 1, 4u });
              checked_set(Y, tY, not_a_year, is);
#endif
            }
            else
              read(is, CharT{ '%' }, width, modified, *fmt);
            command = nullptr;
            width = -1;
            modified = CharT{};
          }
          else
            read(is, *fmt);
          break;
        case 'x':
          if (command)
          {
            if (modified != CharT{ 'O' })
            {
#if !ONLY_C_LOCALE
              ios::iostate err = ios::goodbit;
              f.get(is, nullptr, is, err, &tm, command, fmt + 1);
              if ((err & ios::failbit) == 0)
              {
                checked_set(Y, tm.tm_year + 1900, not_a_year, is);
                checked_set(m, tm.tm_mon + 1, not_a_month, is);
                checked_set(d, tm.tm_mday, not_a_day, is);
              }
              is.setstate(err);
#else
              // "%m/%d/%y"
              int ty = not_a_2digit_year;
              int tm = not_a_month;
              int td = not_a_day;
              read(is, ru{ tm, 1, 2 }, CharT{ '/' }, ru{ td, 1, 2 }, CharT{ '/' },
                rs{ ty, 1, 2 });
              checked_set(y, ty, not_a_2digit_year, is);
              checked_set(m, tm, not_a_month, is);
              checked_set(d, td, not_a_day, is);
#endif
            }
            else
              read(is, CharT{ '%' }, width, modified, *fmt);
            command = nullptr;
            width = -1;
            modified = CharT{};
          }
          else
            read(is, *fmt);
          break;
        case 'X':
          if (command)
          {
            if (modified != CharT{ 'O' })
            {
#if !ONLY_C_LOCALE
              ios::iostate err = ios::goodbit;
              f.get(is, nullptr, is, err, &tm, command, fmt + 1);
              if ((err & ios::failbit) == 0)
              {
                checked_set(H, tm.tm_hour, not_a_hour, is);
                checked_set(M, tm.tm_min, not_a_minute, is);
                checked_set(s, duration_cast<Duration>(seconds{ tm.tm_sec }),
                  not_a_second, is);
              }
              is.setstate(err);
#else
              // "%T"
              using dfs = detail::decimal_format_seconds<Duration>;
              CONSTDATA auto w = Duration::period::den == 1 ? 2 : 3 + dfs::width;
              int tH = not_a_hour;
              int tM = not_a_minute;
              long double S;
              read(is, ru{ tH, 1, 2 }, CharT{ ':' }, ru{ tM, 1, 2 },
                CharT{ ':' }, rld{ S, 1, w });
              checked_set(H, tH, not_a_hour, is);
              checked_set(M, tM, not_a_minute, is);
              checked_set(s, round<Duration>(duration<long double>{S}),
                not_a_second, is);
#endif
            }
            else
              read(is, CharT{ '%' }, width, modified, *fmt);
            command = nullptr;
            width = -1;
            modified = CharT{};
          }
          else
            read(is, *fmt);
          break;
        case 'C':
          if (command)
          {
            int tC = not_a_century;
#if !ONLY_C_LOCALE
            if (modified == CharT{})
            {
#endif
              read(is, rs{ tC, 1, width == -1 ? 2u : static_cast<unsigned>(width) });
#if !ONLY_C_LOCALE
            }
            else
            {
              ios::iostate err = ios::goodbit;
              f.get(is, nullptr, is, err, &tm, command, fmt + 1);
              if ((err & ios::failbit) == 0)
              {
                auto tY = tm.tm_year + 1900;
                tC = (tY >= 0 ? tY : tY - 99) / 100;
              }
              is.setstate(err);
            }
#endif
            checked_set(C, tC, not_a_century, is);
            command = nullptr;
            width = -1;
            modified = CharT{};
          }
          else
            read(is, *fmt);
          break;
        case 'D':
          if (command)
          {
            if (modified == CharT{})
            {
              int tn = not_a_month;
              int td = not_a_day;
              int ty = not_a_2digit_year;
              read(is, ru{ tn, 1, 2 }, CharT{ '\0' }, CharT{ '/' }, CharT{ '\0' },
                ru{ td, 1, 2 }, CharT{ '\0' }, CharT{ '/' }, CharT{ '\0' },
                rs{ ty, 1, 2 });
              checked_set(y, ty, not_a_2digit_year, is);
              checked_set(m, tn, not_a_month, is);
              checked_set(d, td, not_a_day, is);
            }
            else
              read(is, CharT{ '%' }, width, modified, *fmt);
            command = nullptr;
            width = -1;
            modified = CharT{};
          }
          else
            read(is, *fmt);
          break;
        case 'F':
          if (command)
          {
            if (modified == CharT{})
            {
              int tY = not_a_year;
              int tn = not_a_month;
              int td = not_a_day;
              read(is, rs{ tY, 1, width == -1 ? 4u : static_cast<unsigned>(width) },
                CharT{ '-' }, ru{ tn, 1, 2 }, CharT{ '-' }, ru{ td, 1, 2 });
              checked_set(Y, tY, not_a_year, is);
              checked_set(m, tn, not_a_month, is);
              checked_set(d, td, not_a_day, is);
            }
            else
              read(is, CharT{ '%' }, width, modified, *fmt);
            command = nullptr;
            width = -1;
            modified = CharT{};
          }
          else
            read(is, *fmt);
          break;
        case 'd':
        case 'e':
          if (command)
          {
#if !ONLY_C_LOCALE
            if (modified == CharT{})
#else
            if (modified != CharT{ 'E' })
#endif
            {
              int td = not_a_day;
              read(is, rs{ td, 1, width == -1 ? 2u : static_cast<unsigned>(width) });
              checked_set(d, td, not_a_day, is);
            }
#if !ONLY_C_LOCALE
            else if (modified == CharT{ 'O' })
            {
              ios::iostate err = ios::goodbit;
              f.get(is, nullptr, is, err, &tm, command, fmt + 1);
              command = nullptr;
              width = -1;
              modified = CharT{};
              if ((err & ios::failbit) == 0)
                checked_set(d, tm.tm_mday, not_a_day, is);
              is.setstate(err);
            }
#endif
            else
              read(is, CharT{ '%' }, width, modified, *fmt);
            command = nullptr;
            width = -1;
            modified = CharT{};
          }
          else
            read(is, *fmt);
          break;
        case 'H':
          if (command)
          {
#if !ONLY_C_LOCALE
            if (modified == CharT{})
#else
            if (modified != CharT{ 'E' })
#endif
            {
              int tH = not_a_hour;
              read(is, ru{ tH, 1, width == -1 ? 2u : static_cast<unsigned>(width) });
              checked_set(H, tH, not_a_hour, is);
            }
#if !ONLY_C_LOCALE
            else if (modified == CharT{ 'O' })
            {
              ios::iostate err = ios::goodbit;
              f.get(is, nullptr, is, err, &tm, command, fmt + 1);
              if ((err & ios::failbit) == 0)
                checked_set(H, tm.tm_hour, not_a_hour, is);
              is.setstate(err);
            }
#endif
            else
              read(is, CharT{ '%' }, width, modified, *fmt);
            command = nullptr;
            width = -1;
            modified = CharT{};
          }
          else
            read(is, *fmt);
          break;
        case 'I':
          if (command)
          {
            if (modified == CharT{})
            {
              int tI = not_a_hour_12_value;
              // reads in an hour into I, but most be in [1, 12]
              read(is, rs{ tI, 1, width == -1 ? 2u : static_cast<unsigned>(width) });
              if (!(1 <= tI && tI <= 12))
                is.setstate(ios::failbit);
              checked_set(I, tI, not_a_hour_12_value, is);
            }
            else
              read(is, CharT{ '%' }, width, modified, *fmt);
            command = nullptr;
            width = -1;
            modified = CharT{};
          }
          else
            read(is, *fmt);
          break;
        case 'j':
          if (command)
          {
            if (modified == CharT{})
            {
              int tj = not_a_doy;
              read(is, ru{ tj, 1, width == -1 ? 3u : static_cast<unsigned>(width) });
              checked_set(j, tj, not_a_doy, is);
            }
            else
              read(is, CharT{ '%' }, width, modified, *fmt);
            command = nullptr;
            width = -1;
            modified = CharT{};
          }
          else
            read(is, *fmt);
          break;
        case 'M':
          if (command)
          {
#if !ONLY_C_LOCALE
            if (modified == CharT{})
#else
            if (modified != CharT{ 'E' })
#endif
            {
              int tM = not_a_minute;
              read(is, ru{ tM, 1, width == -1 ? 2u : static_cast<unsigned>(width) });
              checked_set(M, tM, not_a_minute, is);
            }
#if !ONLY_C_LOCALE
            else if (modified == CharT{ 'O' })
            {
              ios::iostate err = ios::goodbit;
              f.get(is, nullptr, is, err, &tm, command, fmt + 1);
              if ((err & ios::failbit) == 0)
                checked_set(M, tm.tm_min, not_a_minute, is);
              is.setstate(err);
            }
#endif
            else
              read(is, CharT{ '%' }, width, modified, *fmt);
            command = nullptr;
            width = -1;
            modified = CharT{};
          }
          else
            read(is, *fmt);
          break;
        case 'm':
          if (command)
          {
#if !ONLY_C_LOCALE
            if (modified == CharT{})
#else
            if (modified != CharT{ 'E' })
#endif
            {
              int tn = not_a_month;
              read(is, rs{ tn, 1, width == -1 ? 2u : static_cast<unsigned>(width) });
              checked_set(m, tn, not_a_month, is);
            }
#if !ONLY_C_LOCALE
            else if (modified == CharT{ 'O' })
            {
              ios::iostate err = ios::goodbit;
              f.get(is, nullptr, is, err, &tm, command, fmt + 1);
              if ((err & ios::failbit) == 0)
                checked_set(m, tm.tm_mon + 1, not_a_month, is);
              is.setstate(err);
            }
#endif
            else
              read(is, CharT{ '%' }, width, modified, *fmt);
            command = nullptr;
            width = -1;
            modified = CharT{};
          }
          else
            read(is, *fmt);
          break;
        case 'n':
        case 't':
          if (command)
          {
            if (modified == CharT{})
            {
              // %n matches a single white space character
              // %t matches 0 or 1 white space characters
              auto ic = is.peek();
              if (Traits::eq_int_type(ic, Traits::eof()))
              {
                ios::iostate err = ios::eofbit;
                if (*fmt == 'n')
                  err |= ios::failbit;
                is.setstate(err);
                break;
              }
              if (isspace(ic))
              {
                (void)is.get();
              }
              else if (*fmt == 'n')
                is.setstate(ios::failbit);
            }
            else
              read(is, CharT{ '%' }, width, modified, *fmt);
            command = nullptr;
            width = -1;
            modified = CharT{};
          }
          else
            read(is, *fmt);
          break;
        case 'p':
          if (command)
          {
            if (modified == CharT{})
            {
              int tp = not_a_ampm;
#if !ONLY_C_LOCALE
              tm = std::tm{};
              tm.tm_hour = 1;
              ios::iostate err = ios::goodbit;
              f.get(is, nullptr, is, err, &tm, command, fmt + 1);
              is.setstate(err);
              if (tm.tm_hour == 1)
                tp = 0;
              else if (tm.tm_hour == 13)
                tp = 1;
              else
                is.setstate(err);
#else
              auto nm = detail::ampm_names();
              auto i = detail::scan_keyword(is, nm.first, nm.second) - nm.first;
              tp = i;
#endif
              checked_set(p, tp, not_a_ampm, is);
            }
            else
              read(is, CharT{ '%' }, width, modified, *fmt);
            command = nullptr;
            width = -1;
            modified = CharT{};
          }
          else
            read(is, *fmt);

          break;
        case 'r':
          if (command)
          {
            if (modified == CharT{})
            {
#if !ONLY_C_LOCALE
              ios::iostate err = ios::goodbit;
              f.get(is, nullptr, is, err, &tm, command, fmt + 1);
              if ((err & ios::failbit) == 0)
              {
                checked_set(H, tm.tm_hour, not_a_hour, is);
                checked_set(M, tm.tm_min, not_a_hour, is);
                checked_set(s, duration_cast<Duration>(seconds{ tm.tm_sec }),
                  not_a_second, is);
              }
              is.setstate(err);
#else
              // "%I:%M:%S %p"
              using dfs = detail::decimal_format_seconds<Duration>;
              CONSTDATA auto w = Duration::period::den == 1 ? 2 : 3 + dfs::width;
              long double S;
              int tI = not_a_hour_12_value;
              int tM = not_a_minute;
              read(is, ru{ tI, 1, 2 }, CharT{ ':' }, ru{ tM, 1, 2 },
                CharT{ ':' }, rld{ S, 1, w });
              checked_set(I, tI, not_a_hour_12_value, is);
              checked_set(M, tM, not_a_minute, is);
              checked_set(s, round<Duration>(duration<long double>{S}),
                not_a_second, is);
              ws(is);
              auto nm = detail::ampm_names();
              auto i = detail::scan_keyword(is, nm.first, nm.second) - nm.first;
              checked_set(p, static_cast<int>(i), not_a_ampm, is);
#endif
            }
            else
              read(is, CharT{ '%' }, width, modified, *fmt);
            command = nullptr;
            width = -1;
            modified = CharT{};
          }
          else
            read(is, *fmt);
          break;
        case 'R':
          if (command)
          {
            if (modified == CharT{})
            {
              int tH = not_a_hour;
              int tM = not_a_minute;
              read(is, ru{ tH, 1, 2 }, CharT{ '\0' }, CharT{ ':' }, CharT{ '\0' },
                ru{ tM, 1, 2 }, CharT{ '\0' });
              checked_set(H, tH, not_a_hour, is);
              checked_set(M, tM, not_a_minute, is);
            }
            else
              read(is, CharT{ '%' }, width, modified, *fmt);
            command = nullptr;
            width = -1;
            modified = CharT{};
          }
          else
            read(is, *fmt);
          break;
        case 'S':
          if (command)
          {
#if !ONLY_C_LOCALE
            if (modified == CharT{})
#else
            if (modified != CharT{ 'E' })
#endif
            {
              using dfs = detail::decimal_format_seconds<Duration>;
              CONSTDATA auto w = Duration::period::den == 1 ? 2 : 3 + dfs::width;
              long double S;
              read(is, rld{ S, 1, width == -1 ? w : static_cast<unsigned>(width) });
              checked_set(s, round<Duration>(duration<long double>{S}),
                not_a_second, is);
            }
#if !ONLY_C_LOCALE
            else if (modified == CharT{ 'O' })
            {
              ios::iostate err = ios::goodbit;
              f.get(is, nullptr, is, err, &tm, command, fmt + 1);
              if ((err & ios::failbit) == 0)
                checked_set(s, duration_cast<Duration>(seconds{ tm.tm_sec }),
                  not_a_second, is);
              is.setstate(err);
            }
#endif
            else
              read(is, CharT{ '%' }, width, modified, *fmt);
            command = nullptr;
            width = -1;
            modified = CharT{};
          }
          else
            read(is, *fmt);
          break;
        case 'T':
          if (command)
          {
            if (modified == CharT{})
            {
              using dfs = detail::decimal_format_seconds<Duration>;
              CONSTDATA auto w = Duration::period::den == 1 ? 2 : 3 + dfs::width;
              int tH = not_a_hour;
              int tM = not_a_minute;
              long double S;
              read(is, ru{ tH, 1, 2 }, CharT{ ':' }, ru{ tM, 1, 2 },
                CharT{ ':' }, rld{ S, 1, w });
              checked_set(H, tH, not_a_hour, is);
              checked_set(M, tM, not_a_minute, is);
              checked_set(s, round<Duration>(duration<long double>{S}),
                not_a_second, is);
            }
            else
              read(is, CharT{ '%' }, width, modified, *fmt);
            command = nullptr;
            width = -1;
            modified = CharT{};
          }
          else
            read(is, *fmt);
          break;
        case 'Y':
          if (command)
          {
#if !ONLY_C_LOCALE
            if (modified == CharT{})
#else
            if (modified != CharT{ 'O' })
#endif
            {
              int tY = not_a_year;
              read(is, rs{ tY, 1, width == -1 ? 4u : static_cast<unsigned>(width) });
              checked_set(Y, tY, not_a_year, is);
            }
#if !ONLY_C_LOCALE
            else if (modified == CharT{ 'E' })
            {
              ios::iostate err = ios::goodbit;
              f.get(is, nullptr, is, err, &tm, command, fmt + 1);
              if ((err & ios::failbit) == 0)
                checked_set(Y, tm.tm_year + 1900, not_a_year, is);
              is.setstate(err);
            }
#endif
            else
              read(is, CharT{ '%' }, width, modified, *fmt);
            command = nullptr;
            width = -1;
            modified = CharT{};
          }
          else
            read(is, *fmt);
          break;
        case 'y':
          if (command)
          {
#if !ONLY_C_LOCALE
            if (modified == CharT{})
#endif
            {
              int ty = not_a_2digit_year;
              read(is, ru{ ty, 1, width == -1 ? 2u : static_cast<unsigned>(width) });
              checked_set(y, ty, not_a_2digit_year, is);
            }
#if !ONLY_C_LOCALE
            else
            {
              ios::iostate err = ios::goodbit;
              f.get(is, nullptr, is, err, &tm, command, fmt + 1);
              if ((err & ios::failbit) == 0)
                checked_set(Y, tm.tm_year + 1900, not_a_year, is);
              is.setstate(err);
            }
#endif
            command = nullptr;
            width = -1;
            modified = CharT{};
          }
          else
            read(is, *fmt);
          break;
        case 'g':
          if (command)
          {
            if (modified == CharT{})
            {
              int tg = not_a_2digit_year;
              read(is, ru{ tg, 1, width == -1 ? 2u : static_cast<unsigned>(width) });
              checked_set(g, tg, not_a_2digit_year, is);
            }
            else
              read(is, CharT{ '%' }, width, modified, *fmt);
            command = nullptr;
            width = -1;
            modified = CharT{};
          }
          else
            read(is, *fmt);
          break;
        case 'G':
          if (command)
          {
            if (modified == CharT{})
            {
              int tG = not_a_year;
              read(is, rs{ tG, 1, width == -1 ? 4u : static_cast<unsigned>(width) });
              checked_set(G, tG, not_a_year, is);
            }
            else
              read(is, CharT{ '%' }, width, modified, *fmt);
            command = nullptr;
            width = -1;
            modified = CharT{};
          }
          else
            read(is, *fmt);
          break;
        case 'U':
          if (command)
          {
            if (modified == CharT{})
            {
              int tU = not_a_week_num;
              read(is, ru{ tU, 1, width == -1 ? 2u : static_cast<unsigned>(width) });
              checked_set(U, tU, not_a_week_num, is);
            }
            else
              read(is, CharT{ '%' }, width, modified, *fmt);
            command = nullptr;
            width = -1;
            modified = CharT{};
          }
          else
            read(is, *fmt);
          break;
        case 'V':
          if (command)
          {
            if (modified == CharT{})
            {
              int tV = not_a_week_num;
              read(is, ru{ tV, 1, width == -1 ? 2u : static_cast<unsigned>(width) });
              checked_set(V, tV, not_a_week_num, is);
            }
            else
              read(is, CharT{ '%' }, width, modified, *fmt);
            command = nullptr;
            width = -1;
            modified = CharT{};
          }
          else
            read(is, *fmt);
          break;
        case 'W':
          if (command)
          {
            if (modified == CharT{})
            {
              int tW = not_a_week_num;
              read(is, ru{ tW, 1, width == -1 ? 2u : static_cast<unsigned>(width) });
              checked_set(W, tW, not_a_week_num, is);
            }
            else
              read(is, CharT{ '%' }, width, modified, *fmt);
            command = nullptr;
            width = -1;
            modified = CharT{};
          }
          else
            read(is, *fmt);
          break;
        case 'E':
        case 'O':
          if (command)
          {
            if (modified == CharT{})
            {
              modified = *fmt;
            }
            else
            {
              read(is, CharT{ '%' }, width, modified, *fmt);
              command = nullptr;
              width = -1;
              modified = CharT{};
            }
          }
          else
            read(is, *fmt);
          break;
        case '%':
          if (command)
          {
            if (modified == CharT{})
              read(is, *fmt);
            else
              read(is, CharT{ '%' }, width, modified, *fmt);
            command = nullptr;
            width = -1;
            modified = CharT{};
          }
          else
            command = fmt;
          break;
        case 'z':
          if (command)
          {
            int tH, tM;
            minutes toff = not_a_offset;
            bool neg = false;
            auto ic = is.peek();
            if (!Traits::eq_int_type(ic, Traits::eof()))
            {
              auto c = static_cast<char>(Traits::to_char_type(ic));
              if (c == '-')
                neg = true;
            }
            if (modified == CharT{})
            {
              read(is, rs{ tH, 2, 2 });
              if (!is.fail())
                toff = hours{ std::abs(tH) };
              if (is.good())
              {
                ic = is.peek();
                if (!Traits::eq_int_type(ic, Traits::eof()))
                {
                  auto c = static_cast<char>(Traits::to_char_type(ic));
                  if ('0' <= c && c <= '9')
                  {
                    read(is, ru{ tM, 2, 2 });
                    if (!is.fail())
                      toff += minutes{ tM };
                  }
                }
              }
            }
            else
            {
              read(is, rs{ tH, 1, 2 });
              if (!is.fail())
                toff = hours{ std::abs(tH) };
              if (is.good())
              {
                ic = is.peek();
                if (!Traits::eq_int_type(ic, Traits::eof()))
                {
                  auto c = static_cast<char>(Traits::to_char_type(ic));
                  if (c == ':')
                  {
                    (void)is.get();
                    read(is, ru{ tM, 2, 2 });
                    if (!is.fail())
                      toff += minutes{ tM };
                  }
                }
              }
            }
            if (neg)
              toff = -toff;
            checked_set(temp_offset, toff, not_a_offset, is);
            command = nullptr;
            width = -1;
            modified = CharT{};
          }
          else
            read(is, *fmt);
          break;
        case 'Z':
          if (command)
          {
            if (modified == CharT{})
            {
              std::basic_string<CharT, Traits, Alloc> buf;
              while (is.rdstate() == std::ios::goodbit)
              {
                auto i = is.rdbuf()->sgetc();
                if (Traits::eq_int_type(i, Traits::eof()))
                {
                  is.setstate(ios::eofbit);
                  break;
                }
                auto wc = Traits::to_char_type(i);
                auto c = static_cast<char>(wc);
                // is c a valid time zone name or abbreviation character?
                if (!(CharT{ 1 } < wc && wc < CharT{ 127 }) || !(isalnum(c) ||
                  c == '_' || c == '/' || c == '-' || c == '+'))
                  break;
                buf.push_back(c);
                is.rdbuf()->sbumpc();
              }
              if (buf.empty())
                is.setstate(ios::failbit);
              checked_set(temp_abbrev, buf, {}, is);
            }
            else
              read(is, CharT{ '%' }, width, modified, *fmt);
            command = nullptr;
            width = -1;
            modified = CharT{};
          }
          else
            read(is, *fmt);
          break;
        default:
          if (command)
          {
            if (width == -1 && modified == CharT{} && '0' <= *fmt && *fmt <= '9')
            {
              width = static_cast<char>(*fmt) - '0';
              while ('0' <= fmt[1] && fmt[1] <= '9')
                width = 10 * width + static_cast<char>(*++fmt) - '0';
            }
            else
            {
              if (modified == CharT{})
                read(is, CharT{ '%' }, width, *fmt);
              else
                read(is, CharT{ '%' }, width, modified, *fmt);
              command = nullptr;
              width = -1;
              modified = CharT{};
            }
          }
          else  // !command
          {
            if (isspace(static_cast<unsigned char>(*fmt)))
            {
              // space matches 0 or more white space characters
              if (is.good())
                ws(is);
            }
            else
              read(is, *fmt);
          }
          break;
        }
      }
      // is.fail() || *fmt == CharT{}
      if (is.rdstate() == ios::goodbit && command)
      {
        if (modified == CharT{})
          read(is, CharT{ '%' }, width);
        else
          read(is, CharT{ '%' }, width, modified);
      }
      if (!is.fail())
      {
        if (y != not_a_2digit_year)
        {
          // Convert y and an optional C to Y
          if (!(0 <= y && y <= 99))
            goto broken;
          if (C == not_a_century)
          {
            if (Y == not_a_year)
            {
              if (y >= 69)
                C = 19;
              else
                C = 20;
            }
            else
            {
              C = (Y >= 0 ? Y : Y - 100) / 100;
            }
          }
          int tY;
          if (C >= 0)
            tY = 100 * C + y;
          else
            tY = 100 * (C + 1) - (y == 0 ? 100 : y);
          if (Y != not_a_year && Y != tY)
            goto broken;
          Y = tY;
        }
        if (g != not_a_2digit_year)
        {
          // Convert g and an optional C to G
          if (!(0 <= g && g <= 99))
            goto broken;
          if (C == not_a_century)
          {
            if (G == not_a_year)
            {
              if (g >= 69)
                C = 19;
              else
                C = 20;
            }
            else
            {
              C = (G >= 0 ? G : G - 100) / 100;
            }
          }
          int tG;
          if (C >= 0)
            tG = 100 * C + g;
          else
            tG = 100 * (C + 1) - (g == 0 ? 100 : g);
          if (G != not_a_year && G != tG)
            goto broken;
          G = tG;
        }
        if (Y < static_cast<int>(year::min()) || Y > static_cast<int>(year::max()))
          Y = not_a_year;
        bool computed = false;
        if (G != not_a_year && V != not_a_week_num && wd != not_a_weekday)
        {
          year_month_day ymd_trial = sys_days(year{ G - 1 } / December / Thursday[last]) +
            (Monday - Thursday) + weeks{ V - 1 } +
            (weekday{ static_cast<unsigned>(wd) }-Monday);
          if (Y == not_a_year)
            Y = static_cast<int>(ymd_trial.year());
          else if (year{ Y } != ymd_trial.year())
            goto broken;
          if (m == not_a_month)
            m = static_cast<int>(static_cast<unsigned>(ymd_trial.month()));
          else if (month(static_cast<unsigned>(m)) != ymd_trial.month())
            goto broken;
          if (d == not_a_day)
            d = static_cast<int>(static_cast<unsigned>(ymd_trial.day()));
          else if (day(static_cast<unsigned>(d)) != ymd_trial.day())
            goto broken;
          computed = true;
        }
        if (Y != not_a_year && U != not_a_week_num && wd != not_a_weekday)
        {
          year_month_day ymd_trial = sys_days(year{ Y } / January / Sunday[1]) +
            weeks{ U - 1 } +
            (weekday{ static_cast<unsigned>(wd) } -Sunday);
          if (Y == not_a_year)
            Y = static_cast<int>(ymd_trial.year());
          else if (year{ Y } != ymd_trial.year())
            goto broken;
          if (m == not_a_month)
            m = static_cast<int>(static_cast<unsigned>(ymd_trial.month()));
          else if (month(static_cast<unsigned>(m)) != ymd_trial.month())
            goto broken;
          if (d == not_a_day)
            d = static_cast<int>(static_cast<unsigned>(ymd_trial.day()));
          else if (day(static_cast<unsigned>(d)) != ymd_trial.day())
            goto broken;
          computed = true;
        }
        if (Y != not_a_year && W != not_a_week_num && wd != not_a_weekday)
        {
          year_month_day ymd_trial = sys_days(year{ Y } / January / Monday[1]) +
            weeks{ W - 1 } +
            (weekday{ static_cast<unsigned>(wd) } -Monday);
          if (Y == not_a_year)
            Y = static_cast<int>(ymd_trial.year());
          else if (year{ Y } != ymd_trial.year())
            goto broken;
          if (m == not_a_month)
            m = static_cast<int>(static_cast<unsigned>(ymd_trial.month()));
          else if (month(static_cast<unsigned>(m)) != ymd_trial.month())
            goto broken;
          if (d == not_a_day)
            d = static_cast<int>(static_cast<unsigned>(ymd_trial.day()));
          else if (day(static_cast<unsigned>(d)) != ymd_trial.day())
            goto broken;
          computed = true;
        }
        if (j != not_a_doy && Y != not_a_year)
        {
          auto ymd_trial = year_month_day{ local_days(year{Y} / 1 / 1) + days{j - 1} };
          if (m == 0)
            m = static_cast<int>(static_cast<unsigned>(ymd_trial.month()));
          else if (month(static_cast<unsigned>(m)) != ymd_trial.month())
            goto broken;
          if (d == 0)
            d = static_cast<int>(static_cast<unsigned>(ymd_trial.day()));
          else if (day(static_cast<unsigned>(d)) != ymd_trial.day())
            goto broken;
          j = not_a_doy;
        }
        auto ymd = year{ Y } / m / d;
        if (ymd.ok())
        {
          if (wd == not_a_weekday)
            wd = static_cast<int>((weekday(sys_days(ymd)) - Sunday).count());
          else if (wd != static_cast<int>((weekday(sys_days(ymd)) - Sunday).count()))
            goto broken;
          if (!computed)
          {
            if (G != not_a_year || V != not_a_week_num)
            {
              sys_days sd = ymd;
              auto G_trial = year_month_day{ sd + days{3} }.year();
              auto start = sys_days((G_trial - years{ 1 }) / December / Thursday[last]) +
                (Monday - Thursday);
              if (sd < start)
              {
                --G_trial;
                if (V != not_a_week_num)
                  start = sys_days((G_trial - years{ 1 }) / December / Thursday[last])
                  + (Monday - Thursday);
              }
              if (G != not_a_year && G != static_cast<int>(G_trial))
                goto broken;
              if (V != not_a_week_num)
              {
                auto V_trial = duration_cast<weeks>(sd - start).count() + 1;
                if (V != V_trial)
                  goto broken;
              }
            }
            if (U != not_a_week_num)
            {
              auto start = sys_days(Sunday[1] / January / ymd.year());
              auto U_trial = floor<weeks>(sys_days(ymd) - start).count() + 1;
              if (U != U_trial)
                goto broken;
            }
            if (W != not_a_week_num)
            {
              auto start = sys_days(Monday[1] / January / ymd.year());
              auto W_trial = floor<weeks>(sys_days(ymd) - start).count() + 1;
              if (W != W_trial)
                goto broken;
            }
          }
        }
        fds.ymd = ymd;
        if (I != not_a_hour_12_value)
        {
          if (!(1 <= I && I <= 12))
            goto broken;
          if (p != not_a_ampm)
          {
            // p is in [0, 1] == [AM, PM]
            // Store trial H in I
            if (I == 12)
              --p;
            I += p * 12;
            // Either set H from I or make sure H and I are consistent
            if (H == not_a_hour)
              H = I;
            else if (I != H)
              goto broken;
          }
          else  // p == not_a_ampm
          {
            // if H, make sure H and I could be consistent
            if (H != not_a_hour)
            {
              if (I == 12)
              {
                if (H != 0 && H != 12)
                  goto broken;
              }
              else if (!(I == H || I == H + 12))
              {
                goto broken;
              }
            }
          }
        }
        if (H != not_a_hour)
        {
          fds.has_tod = true;
          fds.tod = hh_mm_ss<Duration>{ hours{H} };
        }
        if (M != not_a_minute)
        {
          fds.has_tod = true;
          fds.tod.m_ = minutes{ M };
        }
        if (s != not_a_second)
        {
          fds.has_tod = true;
          fds.tod.s_ = detail::decimal_format_seconds<Duration>{ s };
        }
        if (j != not_a_doy)
        {
          fds.has_tod = true;
          fds.tod.h_ += hours{ days{j} };
        }
        if (wd != not_a_weekday)
          fds.wd = weekday{ static_cast<unsigned>(wd) };
        if (abbrev != nullptr)
          *abbrev = std::move(temp_abbrev);
        if (offset != nullptr && temp_offset != not_a_offset)
          *offset = temp_offset;
      }
      return is;
    }
  broken:
    is.setstate(ios::failbit);
    return is;
  }

  template <class CharT, class Traits, class Alloc = std::allocator<CharT>>
  std::basic_istream<CharT, Traits>&
    from_stream(std::basic_istream<CharT, Traits>& is, const CharT* fmt, year& y,
      std::basic_string<CharT, Traits, Alloc>* abbrev = nullptr,
      std::chrono::minutes* offset = nullptr)
  {
    using CT = std::chrono::seconds;
    fields<CT> fds{};
    from_stream(is, fmt, fds, abbrev, offset);
    if (!fds.ymd.year().ok())
      is.setstate(std::ios::failbit);
    if (!is.fail())
      y = fds.ymd.year();
    return is;
  }

  template <class CharT, class Traits, class Alloc = std::allocator<CharT>>
  std::basic_istream<CharT, Traits>&
    from_stream(std::basic_istream<CharT, Traits>& is, const CharT* fmt, month& m,
      std::basic_string<CharT, Traits, Alloc>* abbrev = nullptr,
      std::chrono::minutes* offset = nullptr)
  {
    using CT = std::chrono::seconds;
    fields<CT> fds{};
    from_stream(is, fmt, fds, abbrev, offset);
    if (!fds.ymd.month().ok())
      is.setstate(std::ios::failbit);
    if (!is.fail())
      m = fds.ymd.month();
    return is;
  }

  template <class CharT, class Traits, class Alloc = std::allocator<CharT>>
  std::basic_istream<CharT, Traits>&
    from_stream(std::basic_istream<CharT, Traits>& is, const CharT* fmt, day& d,
      std::basic_string<CharT, Traits, Alloc>* abbrev = nullptr,
      std::chrono::minutes* offset = nullptr)
  {
    using CT = std::chrono::seconds;
    fields<CT> fds{};
    from_stream(is, fmt, fds, abbrev, offset);
    if (!fds.ymd.day().ok())
      is.setstate(std::ios::failbit);
    if (!is.fail())
      d = fds.ymd.day();
    return is;
  }

  template <class CharT, class Traits, class Alloc = std::allocator<CharT>>
  std::basic_istream<CharT, Traits>&
    from_stream(std::basic_istream<CharT, Traits>& is, const CharT* fmt, weekday& wd,
      std::basic_string<CharT, Traits, Alloc>* abbrev = nullptr,
      std::chrono::minutes* offset = nullptr)
  {
    using CT = std::chrono::seconds;
    fields<CT> fds{};
    from_stream(is, fmt, fds, abbrev, offset);
    if (!fds.wd.ok())
      is.setstate(std::ios::failbit);
    if (!is.fail())
      wd = fds.wd;
    return is;
  }

  template <class CharT, class Traits, class Alloc = std::allocator<CharT>>
  std::basic_istream<CharT, Traits>&
    from_stream(std::basic_istream<CharT, Traits>& is, const CharT* fmt, year_month& ym,
      std::basic_string<CharT, Traits, Alloc>* abbrev = nullptr,
      std::chrono::minutes* offset = nullptr)
  {
    using CT = std::chrono::seconds;
    fields<CT> fds{};
    from_stream(is, fmt, fds, abbrev, offset);
    if (!fds.ymd.month().ok())
      is.setstate(std::ios::failbit);
    if (!is.fail())
      ym = fds.ymd.year() / fds.ymd.month();
    return is;
  }

  template <class CharT, class Traits, class Alloc = std::allocator<CharT>>
  std::basic_istream<CharT, Traits>&
    from_stream(std::basic_istream<CharT, Traits>& is, const CharT* fmt, month_day& md,
      std::basic_string<CharT, Traits, Alloc>* abbrev = nullptr,
      std::chrono::minutes* offset = nullptr)
  {
    using CT = std::chrono::seconds;
    fields<CT> fds{};
    from_stream(is, fmt, fds, abbrev, offset);
    if (!fds.ymd.month().ok() || !fds.ymd.day().ok())
      is.setstate(std::ios::failbit);
    if (!is.fail())
      md = fds.ymd.month() / fds.ymd.day();
    return is;
  }

  template <class CharT, class Traits, class Alloc = std::allocator<CharT>>
  std::basic_istream<CharT, Traits>&
    from_stream(std::basic_istream<CharT, Traits>& is, const CharT* fmt,
      year_month_day& ymd, std::basic_string<CharT, Traits, Alloc>* abbrev = nullptr,
      std::chrono::minutes* offset = nullptr)
  {
    using CT = std::chrono::seconds;
    fields<CT> fds{};
    from_stream(is, fmt, fds, abbrev, offset);
    if (!fds.ymd.ok())
      is.setstate(std::ios::failbit);
    if (!is.fail())
      ymd = fds.ymd;
    return is;
  }

  template <class Duration, class CharT, class Traits, class Alloc = std::allocator<CharT>>
  std::basic_istream<CharT, Traits>&
    from_stream(std::basic_istream<CharT, Traits>& is, const CharT* fmt,
      sys_time<Duration>& tp, std::basic_string<CharT, Traits, Alloc>* abbrev = nullptr,
      std::chrono::minutes* offset = nullptr)
  {
    using CT = typename std::common_type<Duration, std::chrono::seconds>::type;
    std::chrono::minutes offset_local{};
    auto offptr = offset ? offset : &offset_local;
    fields<CT> fds{};
    fds.has_tod = true;
    from_stream(is, fmt, fds, abbrev, offptr);
    if (!fds.ymd.ok() || !fds.tod.in_conventional_range())
      is.setstate(std::ios::failbit);
    if (!is.fail())
      tp = round<Duration>(sys_days(fds.ymd) - *offptr + fds.tod.to_duration());
    return is;
  }

  template <class Duration, class CharT, class Traits, class Alloc = std::allocator<CharT>>
  std::basic_istream<CharT, Traits>&
    from_stream(std::basic_istream<CharT, Traits>& is, const CharT* fmt,
      local_time<Duration>& tp, std::basic_string<CharT, Traits, Alloc>* abbrev = nullptr,
      std::chrono::minutes* offset = nullptr)
  {
    using CT = typename std::common_type<Duration, std::chrono::seconds>::type;
    fields<CT> fds{};
    fds.has_tod = true;
    from_stream(is, fmt, fds, abbrev, offset);
    if (!fds.ymd.ok() || !fds.tod.in_conventional_range())
      is.setstate(std::ios::failbit);
    if (!is.fail())
      tp = round<Duration>(local_seconds{ local_days(fds.ymd) } +fds.tod.to_duration());
    return is;
  }

  template <class Rep, class Period, class CharT, class Traits, class Alloc = std::allocator<CharT>>
  std::basic_istream<CharT, Traits>&
    from_stream(std::basic_istream<CharT, Traits>& is, const CharT* fmt,
      std::chrono::duration<Rep, Period>& d,
      std::basic_string<CharT, Traits, Alloc>* abbrev = nullptr,
      std::chrono::minutes* offset = nullptr)
  {
    using Duration = std::chrono::duration<Rep, Period>;
    using CT = typename std::common_type<Duration, std::chrono::seconds>::type;
    fields<CT> fds{};
    from_stream(is, fmt, fds, abbrev, offset);
    if (!fds.has_tod)
      is.setstate(std::ios::failbit);
    if (!is.fail())
      d = std::chrono::duration_cast<Duration>(fds.tod.to_duration());
    return is;
  }

  template <class Parsable, class CharT, class Traits = std::char_traits<CharT>,
    class Alloc = std::allocator<CharT>>
    struct parse_manip
  {
    const std::basic_string<CharT, Traits, Alloc> format_;
    Parsable& tp_;
    std::basic_string<CharT, Traits, Alloc>* abbrev_;
    std::chrono::minutes* offset_;

  public:
    parse_manip(std::basic_string<CharT, Traits, Alloc> format, Parsable& tp,
      std::basic_string<CharT, Traits, Alloc>* abbrev = nullptr,
      std::chrono::minutes* offset = nullptr)
      : format_(std::move(format))
      , tp_(tp)
      , abbrev_(abbrev)
      , offset_(offset)
    {}

  };

  template <class Parsable, class CharT, class Traits, class Alloc>
  std::basic_istream<CharT, Traits>&
    operator>>(std::basic_istream<CharT, Traits>& is,
      const parse_manip<Parsable, CharT, Traits, Alloc>& x)
  {
    return from_stream(is, x.format_.c_str(), x.tp_, x.abbrev_, x.offset_);
  }

  template <class Parsable, class CharT, class Traits, class Alloc>
  inline
    auto
    parse(const std::basic_string<CharT, Traits, Alloc>& format, Parsable& tp)
    -> decltype(from_stream(std::declval<std::basic_istream<CharT, Traits>&>(),
      format.c_str(), tp),
      parse_manip<Parsable, CharT, Traits, Alloc>{format, tp})
  {
    return { format, tp };
  }

  template <class Parsable, class CharT, class Traits, class Alloc>
  inline
    auto
    parse(const std::basic_string<CharT, Traits, Alloc>& format, Parsable& tp,
      std::basic_string<CharT, Traits, Alloc>& abbrev)
    -> decltype(from_stream(std::declval<std::basic_istream<CharT, Traits>&>(),
      format.c_str(), tp, &abbrev),
      parse_manip<Parsable, CharT, Traits, Alloc>{format, tp, & abbrev})
  {
    return { format, tp, &abbrev };
  }

  template <class Parsable, class CharT, class Traits, class Alloc>
  inline
    auto
    parse(const std::basic_string<CharT, Traits, Alloc>& format, Parsable& tp,
      std::chrono::minutes& offset)
    -> decltype(from_stream(std::declval<std::basic_istream<CharT, Traits>&>(),
      format.c_str(), tp,
      std::declval<std::basic_string<CharT, Traits, Alloc>*>(),
      &offset),
      parse_manip<Parsable, CharT, Traits, Alloc>{format, tp, nullptr, & offset})
  {
    return { format, tp, nullptr, &offset };
  }

  template <class Parsable, class CharT, class Traits, class Alloc>
  inline
    auto
    parse(const std::basic_string<CharT, Traits, Alloc>& format, Parsable& tp,
      std::basic_string<CharT, Traits, Alloc>& abbrev, std::chrono::minutes& offset)
    -> decltype(from_stream(std::declval<std::basic_istream<CharT, Traits>&>(),
      format.c_str(), tp, &abbrev, &offset),
      parse_manip<Parsable, CharT, Traits, Alloc>{format, tp, & abbrev, & offset})
  {
    return { format, tp, &abbrev, &offset };
  }

  // const CharT* formats

  template <class Parsable, class CharT>
  inline
    auto
    parse(const CharT* format, Parsable& tp)
    -> decltype(from_stream(std::declval<std::basic_istream<CharT>&>(), format, tp),
      parse_manip<Parsable, CharT>{format, tp})
  {
    return { format, tp };
  }

  template <class Parsable, class CharT, class Traits, class Alloc>
  inline
    auto
    parse(const CharT* format, Parsable& tp, std::basic_string<CharT, Traits, Alloc>& abbrev)
    -> decltype(from_stream(std::declval<std::basic_istream<CharT, Traits>&>(), format,
      tp, &abbrev),
      parse_manip<Parsable, CharT, Traits, Alloc>{format, tp, & abbrev})
  {
    return { format, tp, &abbrev };
  }

  template <class Parsable, class CharT>
  inline
    auto
    parse(const CharT* format, Parsable& tp, std::chrono::minutes& offset)
    -> decltype(from_stream(std::declval<std::basic_istream<CharT>&>(), format,
      tp, std::declval<std::basic_string<CharT>*>(), &offset),
      parse_manip<Parsable, CharT>{format, tp, nullptr, & offset})
  {
    return { format, tp, nullptr, &offset };
  }

  template <class Parsable, class CharT, class Traits, class Alloc>
  inline
    auto
    parse(const CharT* format, Parsable& tp,
      std::basic_string<CharT, Traits, Alloc>& abbrev, std::chrono::minutes& offset)
    -> decltype(from_stream(std::declval<std::basic_istream<CharT, Traits>&>(), format,
      tp, &abbrev, &offset),
      parse_manip<Parsable, CharT, Traits, Alloc>{format, tp, & abbrev, & offset})
  {
    return { format, tp, &abbrev, &offset };
  }

  // duration streaming

  template <class CharT, class Traits, class Rep, class Period>
  inline
    std::basic_ostream<CharT, Traits>&
    operator<<(std::basic_ostream<CharT, Traits>& os,
      const std::chrono::duration<Rep, Period>& d)
  {
    return os << detail::make_string<CharT, Traits>::from(d.count()) +
      detail::get_units<CharT>(typename Period::type{});
  }

}  // namespace date

#ifdef _MSC_VER
#   pragma warning(pop)
#endif

#ifdef __GNUC__
# pragma GCC diagnostic pop
#endif

#endif  // DATE_H

```

`3rdparty/lzx.cpp`:

```cpp
/**
 ******************************************************************************
 * Xenia : Xbox 360 Emulator Research Project                                 *
 ******************************************************************************
 * Copyright 2013 Ben Vanik. All rights reserved.                             *
 * Released under the BSD license - see LICENSE in the root for more details. *
 ******************************************************************************
 */

#include <algorithm>
#include <climits>
#include <cstdint>
#include <cstring>

#include "../3rdparty/mspack/lzx.h"
#include "../3rdparty/mspack/mspack.h"

 // BitScanForward (bsf).
 // Search the value from least significant bit (LSB) to the most significant bit
 // (MSB) for a set bit (1).
 // Returns false if no bits are set and the output index is invalid.
#ifdef _WIN32
inline bool bit_scan_forward(uint32_t v, uint32_t* out_first_set_index) {
    return _BitScanForward(reinterpret_cast<unsigned long*>(out_first_set_index),
        v) != 0;
}
inline bool bit_scan_forward(uint64_t v, uint32_t* out_first_set_index) {
    return _BitScanForward64(
        reinterpret_cast<unsigned long*>(out_first_set_index), v) != 0;
}
#else
inline bool bit_scan_forward(uint32_t v, uint32_t* out_first_set_index) {
    int i = ffs(v);
    *out_first_set_index = i - 1;
    return i != 0;
}
inline bool bit_scan_forward(uint64_t v, uint32_t* out_first_set_index) {
    int i = __builtin_ffsll(v);
    *out_first_set_index = i - 1;
    return i != 0;
}
#endif  // _WIN32

typedef struct mspack_memory_file_t {
    mspack_system sys;
    void* buffer;
    off_t buffer_size;
    off_t offset;
} mspack_memory_file;

mspack_memory_file* mspack_memory_open(mspack_system* sys, void* buffer,
    const size_t buffer_size) {
    if (buffer_size >= INT_MAX) {
        return NULL;
    }
    auto memfile =
        (mspack_memory_file*)std::calloc(1, sizeof(mspack_memory_file));
    if (!memfile) {
        return NULL;
    }
    memfile->buffer = buffer;
    memfile->buffer_size = (off_t)buffer_size;
    memfile->offset = 0;
    return memfile;
}

void mspack_memory_close(mspack_memory_file* file) {
    auto memfile = (mspack_memory_file*)file;
    std::free(memfile);
}

int mspack_memory_read(mspack_file* file, void* buffer, int chars) {
    auto memfile = (mspack_memory_file*)file;
    const off_t remaining = memfile->buffer_size - memfile->offset;
    const off_t total = std::min(static_cast<off_t>(chars), remaining);
    std::memcpy(buffer, (uint8_t*)memfile->buffer + memfile->offset, total);
    memfile->offset += total;
    return (int)total;
}

int mspack_memory_write(mspack_file* file, void* buffer, int chars) {
    auto memfile = (mspack_memory_file*)file;
    const off_t remaining = memfile->buffer_size - memfile->offset;
    const off_t total = std::min(static_cast<off_t>(chars), remaining);
    std::memcpy((uint8_t*)memfile->buffer + memfile->offset, buffer, total);
    memfile->offset += total;
    return (int)total;
}

void* mspack_memory_alloc(mspack_system* sys, size_t chars) {
    return std::calloc(chars, 1);
}

void mspack_memory_free(void* ptr) { std::free(ptr); }

void mspack_memory_copy(void* src, void* dest, size_t chars) {
    std::memcpy(dest, src, chars);
}

mspack_system* mspack_memory_sys_create() {
    auto sys = (mspack_system*)std::calloc(1, sizeof(mspack_system));
    if (!sys) {
        return NULL;
    }
    sys->read = mspack_memory_read;
    sys->write = mspack_memory_write;
    sys->alloc = mspack_memory_alloc;
    sys->free = mspack_memory_free;
    sys->copy = mspack_memory_copy;
    return sys;
}

void mspack_memory_sys_destroy(struct mspack_system* sys) { free(sys); }

int lzx_decompress(const void* lzx_data, size_t lzx_len, void* dest,
    size_t dest_len, uint32_t window_size, void* window_data,
    size_t window_data_len) {
    int result_code = 1;

    uint32_t window_bits;
    if (!bit_scan_forward(window_size, &window_bits)) {
        return result_code;
    }

    mspack_system* sys = mspack_memory_sys_create();
    mspack_memory_file* lzxsrc =
        mspack_memory_open(sys, (void*)lzx_data, lzx_len);
    mspack_memory_file* lzxdst = mspack_memory_open(sys, dest, dest_len);
    lzxd_stream* lzxd = lzxd_init(sys, (mspack_file*)lzxsrc, (mspack_file*)lzxdst,
        window_bits, 0, 0x8000, (off_t)dest_len, 0);

    if (lzxd) {
        if (window_data) {
            // zero the window and then copy window_data to the end of it
            auto padding_len = window_size - window_data_len;
            std::memset(&lzxd->window[0], 0, padding_len);
            std::memcpy(&lzxd->window[padding_len], window_data, window_data_len);
            // TODO(gibbed): should this be set regardless if source window data is
            // available or not?
            lzxd->ref_data_size = window_size;
        }

        result_code = lzxd_decompress(lzxd, (off_t)dest_len);

        lzxd_free(lzxd);
        lzxd = NULL;
    }

    if (lzxsrc) {
        mspack_memory_close(lzxsrc);
        lzxsrc = NULL;
    }

    if (lzxdst) {
        mspack_memory_close(lzxdst);
        lzxdst = NULL;
    }

    if (sys) {
        mspack_memory_sys_destroy(sys);
        sys = NULL;
    }

    return result_code;
}

```

`3rdparty/mspack/COPYING.LIB`:

```LIB
		  GNU LESSER GENERAL PUBLIC LICENSE
		       Version 2.1, February 1999

 Copyright (C) 1991, 1999 Free Software Foundation, Inc.
     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

[This is the first released version of the Lesser GPL.  It also counts
 as the successor of the GNU Library Public License, version 2, hence
 the version number 2.1.]

			    Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
Licenses are intended to guarantee your freedom to share and change
free software--to make sure the software is free for all its users.

  This license, the Lesser General Public License, applies to some
specially designated software packages--typically libraries--of the
Free Software Foundation and other authors who decide to use it.  You
can use it too, but we suggest you first think carefully about whether
this license or the ordinary General Public License is the better
strategy to use in any particular case, based on the explanations below.

  When we speak of free software, we are referring to freedom of use,
not price.  Our General Public Licenses are designed to make sure that
you have the freedom to distribute copies of free software (and charge
for this service if you wish); that you receive source code or can get
it if you want it; that you can change the software and use pieces of
it in new free programs; and that you are informed that you can do
these things.

  To protect your rights, we need to make restrictions that forbid
distributors to deny you these rights or to ask you to surrender these
rights.  These restrictions translate to certain responsibilities for
you if you distribute copies of the library or if you modify it.

  For example, if you distribute copies of the library, whether gratis
or for a fee, you must give the recipients all the rights that we gave
you.  You must make sure that they, too, receive or can get the source
code.  If you link other code with the library, you must provide
complete object files to the recipients, so that they can relink them
with the library after making changes to the library and recompiling
it.  And you must show them these terms so they know their rights.

  We protect your rights with a two-step method: (1) we copyright the
library, and (2) we offer you this license, which gives you legal
permission to copy, distribute and/or modify the library.

  To protect each distributor, we want to make it very clear that
there is no warranty for the free library.  Also, if the library is
modified by someone else and passed on, the recipients should know
that what they have is not the original version, so that the original
author's reputation will not be affected by problems that might be
introduced by others.

  Finally, software patents pose a constant threat to the existence of
any free program.  We wish to make sure that a company cannot
effectively restrict the users of a free program by obtaining a
restrictive license from a patent holder.  Therefore, we insist that
any patent license obtained for a version of the library must be
consistent with the full freedom of use specified in this license.

  Most GNU software, including some libraries, is covered by the
ordinary GNU General Public License.  This license, the GNU Lesser
General Public License, applies to certain designated libraries, and
is quite different from the ordinary General Public License.  We use
this license for certain libraries in order to permit linking those
libraries into non-free programs.

  When a program is linked with a library, whether statically or using
a shared library, the combination of the two is legally speaking a
combined work, a derivative of the original library.  The ordinary
General Public License therefore permits such linking only if the
entire combination fits its criteria of freedom.  The Lesser General
Public License permits more lax criteria for linking other code with
the library.

  We call this license the "Lesser" General Public License because it
does Less to protect the user's freedom than the ordinary General
Public License.  It also provides other free software developers Less
of an advantage over competing non-free programs.  These disadvantages
are the reason we use the ordinary General Public License for many
libraries.  However, the Lesser license provides advantages in certain
special circumstances.

  For example, on rare occasions, there may be a special need to
encourage the widest possible use of a certain library, so that it becomes
a de-facto standard.  To achieve this, non-free programs must be
allowed to use the library.  A more frequent case is that a free
library does the same job as widely used non-free libraries.  In this
case, there is little to gain by limiting the free library to free
software only, so we use the Lesser General Public License.

  In other cases, permission to use a particular library in non-free
programs enables a greater number of people to use a large body of
free software.  For example, permission to use the GNU C Library in
non-free programs enables many more people to use the whole GNU
operating system, as well as its variant, the GNU/Linux operating
system.

  Although the Lesser General Public License is Less protective of the
users' freedom, it does ensure that the user of a program that is
linked with the Library has the freedom and the wherewithal to run
that program using a modified version of the Library.

  The precise terms and conditions for copying, distribution and
modification follow.  Pay close attention to the difference between a
"work based on the library" and a "work that uses the library".  The
former contains code derived from the library, whereas the latter must
be combined with the library in order to run.

		  GNU LESSER GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License Agreement applies to any software library or other
program which contains a notice placed by the copyright holder or
other authorized party saying it may be distributed under the terms of
this Lesser General Public License (also called "this License").
Each licensee is addressed as "you".

  A "library" means a collection of software functions and/or data
prepared so as to be conveniently linked with application programs
(which use some of those functions and data) to form executables.

  The "Library", below, refers to any such software library or work
which has been distributed under these terms.  A "work based on the
Library" means either the Library or any derivative work under
copyright law: that is to say, a work containing the Library or a
portion of it, either verbatim or with modifications and/or translated
straightforwardly into another language.  (Hereinafter, translation is
included without limitation in the term "modification".)

  "Source code" for a work means the preferred form of the work for
making modifications to it.  For a library, complete source code means
all the source code for all modules it contains, plus any associated
interface definition files, plus the scripts used to control compilation
and installation of the library.

  Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running a program using the Library is not restricted, and output from
such a program is covered only if its contents constitute a work based
on the Library (independent of the use of the Library in a tool for
writing it).  Whether that is true depends on what the Library does
and what the program that uses the Library does.
  
  1. You may copy and distribute verbatim copies of the Library's
complete source code as you receive it, in any medium, provided that
you conspicuously and appropriately publish on each copy an
appropriate copyright notice and disclaimer of warranty; keep intact
all the notices that refer to this License and to the absence of any
warranty; and distribute a copy of this License along with the
Library.

  You may charge a fee for the physical act of transferring a copy,
and you may at your option offer warranty protection in exchange for a
fee.

  2. You may modify your copy or copies of the Library or any portion
of it, thus forming a work based on the Library, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) The modified work must itself be a software library.

    b) You must cause the files modified to carry prominent notices
    stating that you changed the files and the date of any change.

    c) You must cause the whole of the work to be licensed at no
    charge to all third parties under the terms of this License.

    d) If a facility in the modified Library refers to a function or a
    table of data to be supplied by an application program that uses
    the facility, other than as an argument passed when the facility
    is invoked, then you must make a good faith effort to ensure that,
    in the event an application does not supply such function or
    table, the facility still operates, and performs whatever part of
    its purpose remains meaningful.

    (For example, a function in a library to compute square roots has
    a purpose that is entirely well-defined independent of the
    application.  Therefore, Subsection 2d requires that any
    application-supplied function or table used by this function must
    be optional: if the application does not supply it, the square
    root function must still compute square roots.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Library,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Library, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote
it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Library.

In addition, mere aggregation of another work not based on the Library
with the Library (or with a work based on the Library) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may opt to apply the terms of the ordinary GNU General Public
License instead of this License to a given copy of the Library.  To do
this, you must alter all the notices that refer to this License, so
that they refer to the ordinary GNU General Public License, version 2,
instead of to this License.  (If a newer version than version 2 of the
ordinary GNU General Public License has appeared, then you can specify
that version instead if you wish.)  Do not make any other change in
these notices.

  Once this change is made in a given copy, it is irreversible for
that copy, so the ordinary GNU General Public License applies to all
subsequent copies and derivative works made from that copy.

  This option is useful when you wish to copy part of the code of
the Library into a program that is not a library.

  4. You may copy and distribute the Library (or a portion or
derivative of it, under Section 2) in object code or executable form
under the terms of Sections 1 and 2 above provided that you accompany
it with the complete corresponding machine-readable source code, which
must be distributed under the terms of Sections 1 and 2 above on a
medium customarily used for software interchange.

  If distribution of object code is made by offering access to copy
from a designated place, then offering equivalent access to copy the
source code from the same place satisfies the requirement to
distribute the source code, even though third parties are not
compelled to copy the source along with the object code.

  5. A program that contains no derivative of any portion of the
Library, but is designed to work with the Library by being compiled or
linked with it, is called a "work that uses the Library".  Such a
work, in isolation, is not a derivative work of the Library, and
therefore falls outside the scope of this License.

  However, linking a "work that uses the Library" with the Library
creates an executable that is a derivative of the Library (because it
contains portions of the Library), rather than a "work that uses the
library".  The executable is therefore covered by this License.
Section 6 states terms for distribution of such executables.

  When a "work that uses the Library" uses material from a header file
that is part of the Library, the object code for the work may be a
derivative work of the Library even though the source code is not.
Whether this is true is especially significant if the work can be
linked without the Library, or if the work is itself a library.  The
threshold for this to be true is not precisely defined by law.

  If such an object file uses only numerical parameters, data
structure layouts and accessors, and small macros and small inline
functions (ten lines or less in length), then the use of the object
file is unrestricted, regardless of whether it is legally a derivative
work.  (Executables containing this object code plus portions of the
Library will still fall under Section 6.)

  Otherwise, if the work is a derivative of the Library, you may
distribute the object code for the work under the terms of Section 6.
Any executables containing that work also fall under Section 6,
whether or not they are linked directly with the Library itself.

  6. As an exception to the Sections above, you may also combine or
link a "work that uses the Library" with the Library to produce a
work containing portions of the Library, and distribute that work
under terms of your choice, provided that the terms permit
modification of the work for the customer's own use and reverse
engineering for debugging such modifications.

  You must give prominent notice with each copy of the work that the
Library is used in it and that the Library and its use are covered by
this License.  You must supply a copy of this License.  If the work
during execution displays copyright notices, you must include the
copyright notice for the Library among them, as well as a reference
directing the user to the copy of this License.  Also, you must do one
of these things:

    a) Accompany the work with the complete corresponding
    machine-readable source code for the Library including whatever
    changes were used in the work (which must be distributed under
    Sections 1 and 2 above); and, if the work is an executable linked
    with the Library, with the complete machine-readable "work that
    uses the Library", as object code and/or source code, so that the
    user can modify the Library and then relink to produce a modified
    executable containing the modified Library.  (It is understood
    that the user who changes the contents of definitions files in the
    Library will not necessarily be able to recompile the application
    to use the modified definitions.)

    b) Use a suitable shared library mechanism for linking with the
    Library.  A suitable mechanism is one that (1) uses at run time a
    copy of the library already present on the user's computer system,
    rather than copying library functions into the executable, and (2)
    will operate properly with a modified version of the library, if
    the user installs one, as long as the modified version is
    interface-compatible with the version that the work was made with.

    c) Accompany the work with a written offer, valid for at
    least three years, to give the same user the materials
    specified in Subsection 6a, above, for a charge no more
    than the cost of performing this distribution.

    d) If distribution of the work is made by offering access to copy
    from a designated place, offer equivalent access to copy the above
    specified materials from the same place.

    e) Verify that the user has already received a copy of these
    materials or that you have already sent this user a copy.

  For an executable, the required form of the "work that uses the
Library" must include any data and utility programs needed for
reproducing the executable from it.  However, as a special exception,
the materials to be distributed need not include anything that is
normally distributed (in either source or binary form) with the major
components (compiler, kernel, and so on) of the operating system on
which the executable runs, unless that component itself accompanies
the executable.

  It may happen that this requirement contradicts the license
restrictions of other proprietary libraries that do not normally
accompany the operating system.  Such a contradiction means you cannot
use both them and the Library together in an executable that you
distribute.

  7. You may place library facilities that are a work based on the
Library side-by-side in a single library together with other library
facilities not covered by this License, and distribute such a combined
library, provided that the separate distribution of the work based on
the Library and of the other library facilities is otherwise
permitted, and provided that you do these two things:

    a) Accompany the combined library with a copy of the same work
    based on the Library, uncombined with any other library
    facilities.  This must be distributed under the terms of the
    Sections above.

    b) Give prominent notice with the combined library of the fact
    that part of it is a work based on the Library, and explaining
    where to find the accompanying uncombined form of the same work.

  8. You may not copy, modify, sublicense, link with, or distribute
the Library except as expressly provided under this License.  Any
attempt otherwise to copy, modify, sublicense, link with, or
distribute the Library is void, and will automatically terminate your
rights under this License.  However, parties who have received copies,
or rights, from you under this License will not have their licenses
terminated so long as such parties remain in full compliance.

  9. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Library or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Library (or any work based on the
Library), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Library or works based on it.

  10. Each time you redistribute the Library (or any work based on the
Library), the recipient automatically receives a license from the
original licensor to copy, distribute, link with or modify the Library
subject to these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties with
this License.

  11. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Library at all.  For example, if a patent
license would not permit royalty-free redistribution of the Library by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Library.

If any portion of this section is held invalid or unenforceable under any
particular circumstance, the balance of the section is intended to apply,
and the section as a whole is intended to apply in other circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  12. If the distribution and/or use of the Library is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Library under this License may add
an explicit geographical distribution limitation excluding those countries,
so that distribution is permitted only in or among countries not thus
excluded.  In such case, this License incorporates the limitation as if
written in the body of this License.

  13. The Free Software Foundation may publish revised and/or new
versions of the Lesser General Public License from time to time.
Such new versions will be similar in spirit to the present version,
but may differ in detail to address new problems or concerns.

Each version is given a distinguishing version number.  If the Library
specifies a version number of this License which applies to it and
"any later version", you have the option of following the terms and
conditions either of that version or of any later version published by
the Free Software Foundation.  If the Library does not specify a
license version number, you may choose any version ever published by
the Free Software Foundation.

  14. If you wish to incorporate parts of the Library into other free
programs whose distribution conditions are incompatible with these,
write to the author to ask for permission.  For software which is
copyrighted by the Free Software Foundation, write to the Free
Software Foundation; we sometimes make exceptions for this.  Our
decision will be guided by the two goals of preserving the free status
of all derivatives of our free software and of promoting the sharing
and reuse of software generally.

			    NO WARRANTY

  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
DAMAGES.

		     END OF TERMS AND CONDITIONS

           How to Apply These Terms to Your New Libraries

  If you develop a new library, and you want it to be of the greatest
possible use to the public, we recommend making it free software that
everyone can redistribute and change.  You can do so by permitting
redistribution under these terms (or, alternatively, under the terms of the
ordinary General Public License).

  To apply these terms, attach the following notices to the library.  It is
safest to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least the
"copyright" line and a pointer to where the full notice is found.

    <one line to give the library's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

Also add information on how to contact you by electronic and paper mail.

You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the library, if
necessary.  Here is a sample; alter the names:

  Yoyodyne, Inc., hereby disclaims all copyright interest in the
  library `Frob' (a library for tweaking knobs) written by James Random Hacker.

  <signature of Ty Coon>, 1 April 1990
  Ty Coon, President of Vice

That's all there is to it!



```

`3rdparty/mspack/config.h`:

```h
/* config.h.in.  Generated from configure.ac by autoheader.  */

/* Turn debugging mode on? */
#undef DEBUG

/* Define to 1 if you have the <dlfcn.h> header file. */
#undef HAVE_DLFCN_H

/* Define to 1 if fseeko (and presumably ftello) exists and is declared. */
#undef HAVE_FSEEKO

/* Define to 1 if you have the <inttypes.h> header file. */
#define HAVE_INTTYPES_H 1

/* Define to 1 if you have the <memory.h> header file. */
#undef HAVE_MEMORY_H

/* Define to 1 if you have the `mkdir' function. */
#undef HAVE_MKDIR

/* Define to 1 if you have the <stdint.h> header file. */
#define HAVE_STDINT_H 1

/* Define to 1 if you have the <stdlib.h> header file. */
#define HAVE_STDLIB_H 1

/* Define to 1 if you have the <strings.h> header file. */
#undef HAVE_STRINGS_H

/* Define to 1 if you have the <string.h> header file. */
#define HAVE_STRING_H 1

/* Define to 1 if you have the <sys/stat.h> header file. */
#undef HAVE_SYS_STAT_H

/* Define to 1 if you have the <sys/types.h> header file. */
#undef HAVE_SYS_TYPES_H

/* Define to 1 if you have the `towlower' function. */
#undef HAVE_TOWLOWER

/* Define to 1 if you have the <unistd.h> header file. */
#undef HAVE_UNISTD_H

/* Define to 1 if you have the `_mkdir' function. */
#undef HAVE__MKDIR

/* Define to the sub-directory where libtool stores uninstalled libraries. */
#undef LT_OBJDIR

/* Define if mkdir takes only one argument. */
#undef MKDIR_TAKES_ONE_ARG

/* Name of package */
#undef PACKAGE

/* Define to the address where bug reports for this package should be sent. */
#undef PACKAGE_BUGREPORT

/* Define to the full name of this package. */
#undef PACKAGE_NAME

/* Define to the full name and version of this package. */
#undef PACKAGE_STRING

/* Define to the one symbol short name of this package. */
#undef PACKAGE_TARNAME

/* Define to the home page for this package. */
#undef PACKAGE_URL

/* Define to the version of this package. */
#undef PACKAGE_VERSION

/* The size of `off_t', as computed by sizeof. */
#undef SIZEOF_OFF_T

/* Define to 1 if you have the ANSI C header files. */
#undef STDC_HEADERS

/* Version number of package */
#undef VERSION

/* Enable large inode numbers on Mac OS X 10.5.  */
#ifndef _DARWIN_USE_64_BIT_INODE
# define _DARWIN_USE_64_BIT_INODE 1
#endif

/* Number of bits in a file offset, on hosts where this is settable. */
#undef _FILE_OFFSET_BITS

/* Define to 1 to make fseeko visible on some hosts (e.g. glibc 2.2). */
#undef _LARGEFILE_SOURCE

/* Define for large files, on AIX-style hosts. */
#undef _LARGE_FILES

/* Define to empty if `const' does not conform to ANSI C. */
#undef const

/* Define to `__inline__' or `__inline' if that's what the C compiler
   calls it, or to nothing if 'inline' is not supported under any name.  */
#ifndef __cplusplus
#undef inline
#endif

/* Define to `int' if <sys/types.h> does not define. */
#undef mode_t

/* Define to `long int' if <sys/types.h> does not define. */
#undef off_t

/* Define to `unsigned int' if <sys/types.h> does not define. */
#undef size_t

```

`3rdparty/mspack/lzx.h`:

```h
/* This file is part of libmspack.
 * (C) 2003-2013 Stuart Caie.
 *
 * The LZX method was created by Jonathan Forbes and Tomi Poutanen, adapted
 * by Microsoft Corporation.
 *
 * libmspack is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License (LGPL) version 2.1
 *
 * For further details, see the file COPYING.LIB distributed with libmspack
 */

#ifndef MSPACK_LZX_H
#define MSPACK_LZX_H 1

#ifdef __cplusplus
extern "C" {
#endif

/* LZX compression / decompression definitions */

/* some constants defined by the LZX specification */
#define LZX_MIN_MATCH                (2)
#define LZX_MAX_MATCH                (257)
#define LZX_NUM_CHARS                (256)
#define LZX_BLOCKTYPE_INVALID        (0)   /* also blocktypes 4-7 invalid */
#define LZX_BLOCKTYPE_VERBATIM       (1)
#define LZX_BLOCKTYPE_ALIGNED        (2)
#define LZX_BLOCKTYPE_UNCOMPRESSED   (3)
#define LZX_PRETREE_NUM_ELEMENTS     (20)
#define LZX_ALIGNED_NUM_ELEMENTS     (8)   /* aligned offset tree #elements */
#define LZX_NUM_PRIMARY_LENGTHS      (7)   /* this one missing from spec! */
#define LZX_NUM_SECONDARY_LENGTHS    (249) /* length tree #elements */

/* LZX huffman defines: tweak tablebits as desired */
#define LZX_PRETREE_MAXSYMBOLS  (LZX_PRETREE_NUM_ELEMENTS)
#define LZX_PRETREE_TABLEBITS   (6)
#define LZX_MAINTREE_MAXSYMBOLS (LZX_NUM_CHARS + 290*8)
#define LZX_MAINTREE_TABLEBITS  (12)
#define LZX_LENGTH_MAXSYMBOLS   (LZX_NUM_SECONDARY_LENGTHS+1)
#define LZX_LENGTH_TABLEBITS    (12)
#define LZX_ALIGNED_MAXSYMBOLS  (LZX_ALIGNED_NUM_ELEMENTS)
#define LZX_ALIGNED_TABLEBITS   (7)
#define LZX_LENTABLE_SAFETY (64)  /* table decoding overruns are allowed */

#define LZX_FRAME_SIZE (32768) /* the size of a frame in LZX */

struct lzxd_stream {
  struct mspack_system *sys;      /* I/O routines                            */
  struct mspack_file   *input;    /* input file handle                       */
  struct mspack_file   *output;   /* output file handle                      */

  off_t   offset;                 /* number of bytes actually output         */
  off_t   length;                 /* overall decompressed length of stream   */

  unsigned char *window;          /* decoding window                         */
  unsigned int   window_size;     /* window size                             */
  unsigned int   ref_data_size;   /* LZX DELTA reference data size           */
  unsigned int   num_offsets;     /* number of match_offset entries in table */
  unsigned int   window_posn;     /* decompression offset within window      */
  unsigned int   frame_posn;      /* current frame offset within in window   */
  unsigned int   frame;           /* the number of 32kb frames processed     */
  unsigned int   reset_interval;  /* which frame do we reset the compressor? */

  unsigned int   R0, R1, R2;      /* for the LRU offset system               */
  unsigned int   block_length;    /* uncompressed length of this LZX block   */
  unsigned int   block_remaining; /* uncompressed bytes still left to decode */

  signed int     intel_filesize;  /* magic header value used for transform   */
  signed int     intel_curpos;    /* current offset in transform space       */

  unsigned char  intel_started;   /* has intel E8 decoding started?          */
  unsigned char  block_type;      /* type of the current block               */
  unsigned char  header_read;     /* have we started decoding at all yet?    */
  unsigned char  input_end;       /* have we reached the end of input?       */
  unsigned char  is_delta;        /* does stream follow LZX DELTA spec?      */

  int error;

  /* I/O buffering */
  unsigned char *inbuf, *i_ptr, *i_end, *o_ptr, *o_end;
  unsigned int  bit_buffer, bits_left, inbuf_size;

  /* huffman code lengths */
  unsigned char PRETREE_len  [LZX_PRETREE_MAXSYMBOLS  + LZX_LENTABLE_SAFETY];
  unsigned char MAINTREE_len [LZX_MAINTREE_MAXSYMBOLS + LZX_LENTABLE_SAFETY];
  unsigned char LENGTH_len   [LZX_LENGTH_MAXSYMBOLS   + LZX_LENTABLE_SAFETY];
  unsigned char ALIGNED_len  [LZX_ALIGNED_MAXSYMBOLS  + LZX_LENTABLE_SAFETY];

  /* huffman decoding tables */
  unsigned short PRETREE_table [(1 << LZX_PRETREE_TABLEBITS) +
                                (LZX_PRETREE_MAXSYMBOLS * 2)];
  unsigned short MAINTREE_table[(1 << LZX_MAINTREE_TABLEBITS) +
                                (LZX_MAINTREE_MAXSYMBOLS * 2)];
  unsigned short LENGTH_table  [(1 << LZX_LENGTH_TABLEBITS) +
                                (LZX_LENGTH_MAXSYMBOLS * 2)];
  unsigned short ALIGNED_table [(1 << LZX_ALIGNED_TABLEBITS) +
                                (LZX_ALIGNED_MAXSYMBOLS * 2)];
  unsigned char LENGTH_empty;

  /* this is used purely for doing the intel E8 transform */
  unsigned char  e8_buf[LZX_FRAME_SIZE];
};

/**
 * Allocates and initialises LZX decompression state for decoding an LZX
 * stream.
 *
 * This routine uses system->alloc() to allocate memory. If memory
 * allocation fails, or the parameters to this function are invalid,
 * NULL is returned.
 *
 * @param system             an mspack_system structure used to read from
 *                           the input stream and write to the output
 *                           stream, also to allocate and free memory.
 * @param input              an input stream with the LZX data.
 * @param output             an output stream to write the decoded data to.
 * @param window_bits        the size of the decoding window, which must be
 *                           between 15 and 21 inclusive for regular LZX
 *                           data, or between 17 and 25 inclusive for
 *                           LZX DELTA data.
 * @param reset_interval     the interval at which the LZX bitstream is
 *                           reset, in multiples of LZX frames (32678
 *                           bytes), e.g. a value of 2 indicates the input
 *                           stream resets after every 65536 output bytes.
 *                           A value of 0 indicates that the bitstream never
 *                           resets, such as in CAB LZX streams.
 * @param input_buffer_size  the number of bytes to use as an input
 *                           bitstream buffer.
 * @param output_length      the length in bytes of the entirely
 *                           decompressed output stream, if known in
 *                           advance. It is used to correctly perform the
 *                           Intel E8 transformation, which must stop 6
 *                           bytes before the very end of the
 *                           decompressed stream. It is not otherwise used
 *                           or adhered to. If the full decompressed
 *                           length is known in advance, set it here.
 *                           If it is NOT known, use the value 0, and call
 *                           lzxd_set_output_length() once it is
 *                           known. If never set, 4 of the final 6 bytes
 *                           of the output stream may be incorrect.
 * @param is_delta           should be zero for all regular LZX data,
 *                           non-zero for LZX DELTA encoded data.
 * @return a pointer to an initialised lzxd_stream structure, or NULL if
 * there was not enough memory or parameters to the function were wrong.
 */
extern struct lzxd_stream *lzxd_init(struct mspack_system *system,
                                     struct mspack_file *input,
                                     struct mspack_file *output,
                                     int window_bits,
                                     int reset_interval,
                                     int input_buffer_size,
                                     off_t output_length,
                                     char is_delta);

/* see description of output_length in lzxd_init() */
extern void lzxd_set_output_length(struct lzxd_stream *lzx,
                                   off_t output_length);

/**
 * Reads LZX DELTA reference data into the window and allows
 * lzxd_decompress() to reference it.
 *
 * Call this before the first call to lzxd_decompress().

 * @param lzx    the LZX stream to apply this reference data to
 * @param system an mspack_system implementation to use with the
 *               input param. Only read() will be called.
 * @param input  an input file handle to read reference data using
 *               system->read().
 * @param length the length of the reference data. Cannot be longer
 *               than the LZX window size.
 * @return an error code, or MSPACK_ERR_OK if successful
 */
extern int lzxd_set_reference_data(struct lzxd_stream *lzx,
                                   struct mspack_system *system,
                                   struct mspack_file *input,
                                   unsigned int length);

/**
 * Decompresses entire or partial LZX streams.
 *
 * The number of bytes of data that should be decompressed is given as the
 * out_bytes parameter. If more bytes are decoded than are needed, they
 * will be kept over for a later invocation.
 *
 * The output bytes will be passed to the system->write() function given in
 * lzxd_init(), using the output file handle given in lzxd_init(). More than
 * one call may be made to system->write().

 * Input bytes will be read in as necessary using the system->read()
 * function given in lzxd_init(), using the input file handle given in
 * lzxd_init().  This will continue until system->read() returns 0 bytes,
 * or an error. Errors will be passed out of the function as
 * MSPACK_ERR_READ errors.  Input streams should convey an "end of input
 * stream" by refusing to supply all the bytes that LZX asks for when they
 * reach the end of the stream, rather than return an error code.
 *
 * If any error code other than MSPACK_ERR_OK is returned, the stream
 * should be considered unusable and lzxd_decompress() should not be
 * called again on this stream.
 *
 * @param lzx       LZX decompression state, as allocated by lzxd_init().
 * @param out_bytes the number of bytes of data to decompress.
 * @return an error code, or MSPACK_ERR_OK if successful
 */
extern int lzxd_decompress(struct lzxd_stream *lzx, off_t out_bytes);

/**
 * Frees all state associated with an LZX data stream. This will call
 * system->free() using the system pointer given in lzxd_init().
 *
 * @param lzx LZX decompression state to free.
 */
void lzxd_free(struct lzxd_stream *lzx);

#ifdef __cplusplus
}
#endif

#endif

```

`3rdparty/mspack/lzxd.c`:

```c
/* This file is part of libmspack.
 * (C) 2003-2013 Stuart Caie.
 *
 * The LZX method was created by Jonathan Forbes and Tomi Poutanen, adapted
 * by Microsoft Corporation.
 *
 * libmspack is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License (LGPL) version 2.1
 *
 * For further details, see the file COPYING.LIB distributed with libmspack
 */

/* LZX decompression implementation */

#include "system.h"
#include "lzx.h"

#undef D
#define D(x) do { } while (0);

/* Microsoft's LZX document (in cab-sdk.exe) and their implementation
 * of the com.ms.util.cab Java package do not concur.
 *
 * In the LZX document, there is a table showing the correlation between
 * window size and the number of position slots. It states that the 1MB
 * window = 40 slots and the 2MB window = 42 slots. In the implementation,
 * 1MB = 42 slots, 2MB = 50 slots. The actual calculation is 'find the
 * first slot whose position base is equal to or more than the required
 * window size'. This would explain why other tables in the document refer
 * to 50 slots rather than 42.
 *
 * The constant NUM_PRIMARY_LENGTHS used in the decompression pseudocode
 * is not defined in the specification.
 *
 * The LZX document does not state the uncompressed block has an
 * uncompressed length field. Where does this length field come from, so
 * we can know how large the block is? The implementation has it as the 24
 * bits following after the 3 blocktype bits, before the alignment
 * padding.
 *
 * The LZX document states that aligned offset blocks have their aligned
 * offset huffman tree AFTER the main and length trees. The implementation
 * suggests that the aligned offset tree is BEFORE the main and length
 * trees.
 *
 * The LZX document decoding algorithm states that, in an aligned offset
 * block, if an extra_bits value is 1, 2 or 3, then that number of bits
 * should be read and the result added to the match offset. This is
 * correct for 1 and 2, but not 3, where just a huffman symbol (using the
 * aligned tree) should be read.
 *
 * Regarding the E8 preprocessing, the LZX document states 'No translation
 * may be performed on the last 6 bytes of the input block'. This is
 * correct.  However, the pseudocode provided checks for the *E8 leader*
 * up to the last 6 bytes. If the leader appears between -10 and -7 bytes
 * from the end, this would cause the next four bytes to be modified, at
 * least one of which would be in the last 6 bytes, which is not allowed
 * according to the spec.
 *
 * The specification states that the huffman trees must always contain at
 * least one element. However, many CAB files contain blocks where the
 * length tree is completely empty (because there are no matches), and
 * this is expected to succeed.
 *
 * The errors in LZX documentation appear have been corrected in the
 * new documentation for the LZX DELTA format.
 *
 *     http://msdn.microsoft.com/en-us/library/cc483133.aspx
 *
 * However, this is a different format, an extension of regular LZX.
 * I have noticed the following differences, there may be more:
 *
 * The maximum window size has increased from 2MB to 32MB. This also
 * increases the maximum number of position slots, etc.
 *
 * If the match length is 257 (the maximum possible), this signals
 * a further length decoding step, that allows for matches up to
 * 33024 bytes long.
 *
 * The format now allows for "reference data", supplied by the caller.
 * If match offsets go further back than the number of bytes
 * decompressed so far, that is them accessing the reference data.
 */

/* import bit-reading macros and code */
#define BITS_TYPE struct lzxd_stream
#define BITS_VAR lzx
#define BITS_ORDER_MSB
#define READ_BYTES do {                 \
    unsigned char b0, b1;               \
    READ_IF_NEEDED; b0 = *i_ptr++;      \
    READ_IF_NEEDED; b1 = *i_ptr++;      \
    INJECT_BITS((b1 << 8) | b0, 16);    \
} while (0)
#include "readbits.h"

/* import huffman-reading macros and code */
#define TABLEBITS(tbl)      LZX_##tbl##_TABLEBITS
#define MAXSYMBOLS(tbl)     LZX_##tbl##_MAXSYMBOLS
#define HUFF_TABLE(tbl,idx) lzx->tbl##_table[idx]
#define HUFF_LEN(tbl,idx)   lzx->tbl##_len[idx]
#define HUFF_ERROR          return lzx->error = MSPACK_ERR_DECRUNCH
#include "readhuff.h"

/* BUILD_TABLE(tbl) builds a huffman lookup table from code lengths */
#define BUILD_TABLE(tbl)                                                \
    if (make_decode_table(MAXSYMBOLS(tbl), TABLEBITS(tbl),              \
                          &HUFF_LEN(tbl,0), &HUFF_TABLE(tbl,0)))        \
    {                                                                   \
        D(("failed to build %s table", #tbl))                           \
        return lzx->error = MSPACK_ERR_DECRUNCH;                        \
    }

#define BUILD_TABLE_MAYBE_EMPTY(tbl) do {                               \
    lzx->tbl##_empty = 0;                                               \
    if (make_decode_table(MAXSYMBOLS(tbl), TABLEBITS(tbl),              \
                          &HUFF_LEN(tbl,0), &HUFF_TABLE(tbl,0)))        \
    {                                                                   \
        for (i = 0; i < MAXSYMBOLS(tbl); i++) {                         \
            if (HUFF_LEN(tbl, i) > 0) {                                 \
                D(("failed to build %s table", #tbl))                   \
                return lzx->error = MSPACK_ERR_DECRUNCH;                \
            }                                                           \
        }                                                               \
        /* empty tree - allow it, but don't decode symbols with it */   \
        lzx->tbl##_empty = 1;                                           \
    }                                                                   \
} while (0)

/* READ_LENGTHS(tablename, first, last) reads in code lengths for symbols
 * first to last in the given table. The code lengths are stored in their
 * own special LZX way.
 */
#define READ_LENGTHS(tbl, first, last) do {             \
  STORE_BITS;                                           \
  if (lzxd_read_lens(lzx, &HUFF_LEN(tbl, 0), (first),   \
    (unsigned int)(last))) return lzx->error;           \
  RESTORE_BITS;                                         \
} while (0)

static int lzxd_read_lens(struct lzxd_stream *lzx, unsigned char *lens,
                          unsigned int first, unsigned int last)
{
  /* bit buffer and huffman symbol decode variables */
  unsigned int bit_buffer;
  int bits_left, i;
  unsigned short sym;
  unsigned char *i_ptr, *i_end;

  unsigned int x, y;
  int z;

  RESTORE_BITS;
  
  /* read lengths for pretree (20 symbols, lengths stored in fixed 4 bits) */
  for (x = 0; x < 20; x++) {
    READ_BITS(y, 4);
    lzx->PRETREE_len[x] = y;
  }
  BUILD_TABLE(PRETREE);

  for (x = first; x < last; ) {
    READ_HUFFSYM(PRETREE, z);
    if (z == 17) {
      /* code = 17, run of ([read 4 bits]+4) zeros */
      READ_BITS(y, 4); y += 4;
      while (y--) lens[x++] = 0;
    }
    else if (z == 18) {
      /* code = 18, run of ([read 5 bits]+20) zeros */
      READ_BITS(y, 5); y += 20;
      while (y--) lens[x++] = 0;
    }
    else if (z == 19) {
      /* code = 19, run of ([read 1 bit]+4) [read huffman symbol] */
      READ_BITS(y, 1); y += 4;
      READ_HUFFSYM(PRETREE, z);
      z = lens[x] - z; if (z < 0) z += 17;
      while (y--) lens[x++] = z;
    }
    else {
      /* code = 0 to 16, delta current length entry */
      z = lens[x] - z; if (z < 0) z += 17;
      lens[x++] = z;
    }
  }

  STORE_BITS;

  return MSPACK_ERR_OK;
}

/* LZX static data tables:
 *
 * LZX uses 'position slots' to represent match offsets.  For every match,
 * a small 'position slot' number and a small offset from that slot are
 * encoded instead of one large offset.
 *
 * The number of slots is decided by how many are needed to encode the
 * largest offset for a given window size. This is easy when the gap between
 * slots is less than 128Kb, it's a linear relationship. But when extra_bits
 * reaches its limit of 17 (because LZX can only ensure reading 17 bits of
 * data at a time), we can only jump 128Kb at a time and have to start
 * using more and more position slots as each window size doubles.
 *
 * position_base[] is an index to the position slot bases
 *
 * extra_bits[] states how many bits of offset-from-base data is needed.
 *
 * They are calculated as follows:
 * extra_bits[i] = 0 where i < 4
 * extra_bits[i] = floor(i/2)-1 where i >= 4 && i < 36
 * extra_bits[i] = 17 where i >= 36
 * position_base[0] = 0
 * position_base[i] = position_base[i-1] + (1 << extra_bits[i-1])
 */
static const unsigned int position_slots[11] = {
    30, 32, 34, 36, 38, 42, 50, 66, 98, 162, 290
};
static const unsigned char extra_bits[36] = {
    0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8,
    9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16
};
static const unsigned int position_base[290] = {
    0, 1, 2, 3, 4, 6, 8, 12, 16, 24, 32, 48, 64, 96, 128, 192, 256, 384, 512,
    768, 1024, 1536, 2048, 3072, 4096, 6144, 8192, 12288, 16384, 24576, 32768,
    49152, 65536, 98304, 131072, 196608, 262144, 393216, 524288, 655360,
    786432, 917504, 1048576, 1179648, 1310720, 1441792, 1572864, 1703936,
    1835008, 1966080, 2097152, 2228224, 2359296, 2490368, 2621440, 2752512,
    2883584, 3014656, 3145728, 3276800, 3407872, 3538944, 3670016, 3801088,
    3932160, 4063232, 4194304, 4325376, 4456448, 4587520, 4718592, 4849664,
    4980736, 5111808, 5242880, 5373952, 5505024, 5636096, 5767168, 5898240,
    6029312, 6160384, 6291456, 6422528, 6553600, 6684672, 6815744, 6946816,
    7077888, 7208960, 7340032, 7471104, 7602176, 7733248, 7864320, 7995392,
    8126464, 8257536, 8388608, 8519680, 8650752, 8781824, 8912896, 9043968,
    9175040, 9306112, 9437184, 9568256, 9699328, 9830400, 9961472, 10092544,
    10223616, 10354688, 10485760, 10616832, 10747904, 10878976, 11010048,
    11141120, 11272192, 11403264, 11534336, 11665408, 11796480, 11927552,
    12058624, 12189696, 12320768, 12451840, 12582912, 12713984, 12845056,
    12976128, 13107200, 13238272, 13369344, 13500416, 13631488, 13762560,
    13893632, 14024704, 14155776, 14286848, 14417920, 14548992, 14680064,
    14811136, 14942208, 15073280, 15204352, 15335424, 15466496, 15597568,
    15728640, 15859712, 15990784, 16121856, 16252928, 16384000, 16515072,
    16646144, 16777216, 16908288, 17039360, 17170432, 17301504, 17432576,
    17563648, 17694720, 17825792, 17956864, 18087936, 18219008, 18350080,
    18481152, 18612224, 18743296, 18874368, 19005440, 19136512, 19267584,
    19398656, 19529728, 19660800, 19791872, 19922944, 20054016, 20185088,
    20316160, 20447232, 20578304, 20709376, 20840448, 20971520, 21102592,
    21233664, 21364736, 21495808, 21626880, 21757952, 21889024, 22020096,
    22151168, 22282240, 22413312, 22544384, 22675456, 22806528, 22937600,
    23068672, 23199744, 23330816, 23461888, 23592960, 23724032, 23855104,
    23986176, 24117248, 24248320, 24379392, 24510464, 24641536, 24772608,
    24903680, 25034752, 25165824, 25296896, 25427968, 25559040, 25690112,
    25821184, 25952256, 26083328, 26214400, 26345472, 26476544, 26607616,
    26738688, 26869760, 27000832, 27131904, 27262976, 27394048, 27525120,
    27656192, 27787264, 27918336, 28049408, 28180480, 28311552, 28442624,
    28573696, 28704768, 28835840, 28966912, 29097984, 29229056, 29360128,
    29491200, 29622272, 29753344, 29884416, 30015488, 30146560, 30277632,
    30408704, 30539776, 30670848, 30801920, 30932992, 31064064, 31195136,
    31326208, 31457280, 31588352, 31719424, 31850496, 31981568, 32112640,
    32243712, 32374784, 32505856, 32636928, 32768000, 32899072, 33030144,
    33161216, 33292288, 33423360
};

static void lzxd_reset_state(struct lzxd_stream *lzx) {
  int i;

  lzx->R0              = 1;
  lzx->R1              = 1;
  lzx->R2              = 1;
  lzx->header_read     = 0;
  lzx->block_remaining = 0;
  lzx->block_type      = LZX_BLOCKTYPE_INVALID;

  /* initialise tables to 0 (because deltas will be applied to them) */
  for (i = 0; i < LZX_MAINTREE_MAXSYMBOLS; i++) lzx->MAINTREE_len[i] = 0;
  for (i = 0; i < LZX_LENGTH_MAXSYMBOLS; i++)   lzx->LENGTH_len[i]   = 0;
}

/*-------- main LZX code --------*/

struct lzxd_stream *lzxd_init(struct mspack_system *system,
                              struct mspack_file *input,
                              struct mspack_file *output,
                              int window_bits,
                              int reset_interval,
                              int input_buffer_size,
                              off_t output_length,
                              char is_delta)
{
  unsigned int window_size = 1 << window_bits;
  struct lzxd_stream *lzx;

  if (!system) return NULL;

  /* LZX DELTA window sizes are between 2^17 (128KiB) and 2^25 (32MiB),
   * regular LZX windows are between 2^15 (32KiB) and 2^21 (2MiB)
   */
  if (is_delta) {
      if (window_bits < 17 || window_bits > 25) return NULL;
  }
  else {
      if (window_bits < 15 || window_bits > 21) return NULL;
  }

  if (reset_interval < 0 || output_length < 0) {
      D(("reset interval or output length < 0"))
      return NULL;
  }

  /* round up input buffer size to multiple of two */
  input_buffer_size = (input_buffer_size + 1) & -2;
  if (input_buffer_size < 2) return NULL;

  /* allocate decompression state */
  if (!(lzx = (struct lzxd_stream *) system->alloc(system, sizeof(struct lzxd_stream)))) {
    return NULL;
  }

  /* allocate decompression window and input buffer */
  lzx->window = (unsigned char *) system->alloc(system, (size_t) window_size);
  lzx->inbuf  = (unsigned char *) system->alloc(system, (size_t) input_buffer_size);
  if (!lzx->window || !lzx->inbuf) {
    system->free(lzx->window);
    system->free(lzx->inbuf);
    system->free(lzx);
    return NULL;
  }

  /* initialise decompression state */
  lzx->sys             = system;
  lzx->input           = input;
  lzx->output          = output;
  lzx->offset          = 0;
  lzx->length          = output_length;

  lzx->inbuf_size      = input_buffer_size;
  lzx->window_size     = 1 << window_bits;
  lzx->ref_data_size   = 0;
  lzx->window_posn     = 0;
  lzx->frame_posn      = 0;
  lzx->frame           = 0;
  lzx->reset_interval  = reset_interval;
  lzx->intel_filesize  = 0;
  lzx->intel_curpos    = 0;
  lzx->intel_started   = 0;
  lzx->error           = MSPACK_ERR_OK;
  lzx->num_offsets     = position_slots[window_bits - 15] << 3;
  lzx->is_delta        = is_delta;

  lzx->o_ptr = lzx->o_end = &lzx->e8_buf[0];
  lzxd_reset_state(lzx);
  INIT_BITS;
  return lzx;
}

int lzxd_set_reference_data(struct lzxd_stream *lzx,
                            struct mspack_system *system,
                            struct mspack_file *input,
                            unsigned int length)
{
    if (!lzx) return MSPACK_ERR_ARGS;

    if (!lzx->is_delta) {
        D(("only LZX DELTA streams support reference data"))
        return MSPACK_ERR_ARGS;
    }
    if (lzx->offset) {
        D(("too late to set reference data after decoding starts"))
        return MSPACK_ERR_ARGS;
    }
    if (length > lzx->window_size) {
        D(("reference length (%u) is longer than the window", length))
        return MSPACK_ERR_ARGS;
    }
    if (length > 0 && (!system || !input)) {
        D(("length > 0 but no system or input"))
        return MSPACK_ERR_ARGS;
    }

    lzx->ref_data_size = length;
    if (length > 0) {
        /* copy reference data */
        unsigned char *pos = &lzx->window[lzx->window_size - length];
        int bytes = system->read(input, pos, length);
        /* length can't be more than 2^25, so no signedness problem */
        if (bytes < (int)length) return MSPACK_ERR_READ;
    }
    lzx->ref_data_size = length;
    return MSPACK_ERR_OK;
}

void lzxd_set_output_length(struct lzxd_stream *lzx, off_t out_bytes) {
  if (lzx && out_bytes > 0) lzx->length = out_bytes;
}

int lzxd_decompress(struct lzxd_stream *lzx, off_t out_bytes) {
  /* bitstream and huffman reading variables */
  unsigned int bit_buffer;
  int bits_left, i=0;
  unsigned char *i_ptr, *i_end;
  unsigned short sym;

  int match_length, length_footer, extra, verbatim_bits, bytes_todo;
  int this_run, main_element, aligned_bits, j, warned = 0;
  unsigned char *window, *runsrc, *rundest, buf[12];
  unsigned int frame_size=0, end_frame, match_offset, window_posn;
  unsigned int R0, R1, R2;

  /* easy answers */
  if (!lzx || (out_bytes < 0)) return MSPACK_ERR_ARGS;
  if (lzx->error) return lzx->error;

  /* flush out any stored-up bytes before we begin */
  i = (int)(lzx->o_end - lzx->o_ptr);
  if ((off_t) i > out_bytes) i = (int) out_bytes;
  if (i) {
    if (lzx->sys->write(lzx->output, lzx->o_ptr, i) != i) {
      return lzx->error = MSPACK_ERR_WRITE;
    }
    lzx->o_ptr  += i;
    lzx->offset += i;
    out_bytes   -= i;
  }
  if (out_bytes == 0) return MSPACK_ERR_OK;

  /* restore local state */
  RESTORE_BITS;
  window = lzx->window;
  window_posn = lzx->window_posn;
  R0 = lzx->R0;
  R1 = lzx->R1;
  R2 = lzx->R2;

  end_frame = (unsigned int)((lzx->offset + out_bytes) / LZX_FRAME_SIZE) + 1;

  while (lzx->frame < end_frame) {
    /* have we reached the reset interval? (if there is one?) */
    if (lzx->reset_interval && ((lzx->frame % lzx->reset_interval) == 0)) {
      if (lzx->block_remaining) {
        /* this is a file format error, we can make a best effort to extract what we can */
        D(("%d bytes remaining at reset interval", lzx->block_remaining))
        if (!warned) {
          lzx->sys->message(NULL, "WARNING; invalid reset interval detected during LZX decompression");
          warned++;
        }
      }

      /* re-read the intel header and reset the huffman lengths */
      lzxd_reset_state(lzx);
      R0 = lzx->R0;
      R1 = lzx->R1;
      R2 = lzx->R2;
    }

    /* LZX DELTA format has chunk_size, not present in LZX format */
    if (lzx->is_delta) {
      ENSURE_BITS(16);
      REMOVE_BITS(16);
    }

    /* read header if necessary */
    if (!lzx->header_read) {
      /* read 1 bit. if bit=0, intel filesize = 0.
       * if bit=1, read intel filesize (32 bits) */
      j = 0; READ_BITS(i, 1); if (i) { READ_BITS(i, 16); READ_BITS(j, 16); }
      lzx->intel_filesize = (i << 16) | j;
      lzx->header_read = 1;
    } 

    /* calculate size of frame: all frames are 32k except the final frame
     * which is 32kb or less. this can only be calculated when lzx->length
     * has been filled in. */
    frame_size = LZX_FRAME_SIZE;
    if (lzx->length && (lzx->length - lzx->offset) < (off_t)frame_size) {
      frame_size = lzx->length - lzx->offset;
    }

    /* decode until one more frame is available */
    bytes_todo = lzx->frame_posn + frame_size - window_posn;
    while (bytes_todo > 0) {
      /* initialise new block, if one is needed */
      if (lzx->block_remaining == 0) {
        /* realign if previous block was an odd-sized UNCOMPRESSED block */
        if ((lzx->block_type == LZX_BLOCKTYPE_UNCOMPRESSED) &&
            (lzx->block_length & 1))
        {
          READ_IF_NEEDED;
          i_ptr++;
        }

        /* read block type (3 bits) and block length (24 bits) */
        READ_BITS(lzx->block_type, 3);
        READ_BITS(i, 16); READ_BITS(j, 8);
        lzx->block_remaining = lzx->block_length = (i << 8) | j;
        /*D(("new block t%d len %u", lzx->block_type, lzx->block_length))*/

        /* read individual block headers */
        switch (lzx->block_type) {
        case LZX_BLOCKTYPE_ALIGNED:
          /* read lengths of and build aligned huffman decoding tree */
          for (i = 0; i < 8; i++) { READ_BITS(j, 3); lzx->ALIGNED_len[i] = j; }
          BUILD_TABLE(ALIGNED);
          /* rest of aligned header is same as verbatim */ /*@fallthrough@*/
        case LZX_BLOCKTYPE_VERBATIM:
          /* read lengths of and build main huffman decoding tree */
          READ_LENGTHS(MAINTREE, 0, 256);
          READ_LENGTHS(MAINTREE, 256, LZX_NUM_CHARS + lzx->num_offsets);
          BUILD_TABLE(MAINTREE);
          /* if the literal 0xE8 is anywhere in the block... */
          if (lzx->MAINTREE_len[0xE8] != 0) lzx->intel_started = 1;
          /* read lengths of and build lengths huffman decoding tree */
          READ_LENGTHS(LENGTH, 0, LZX_NUM_SECONDARY_LENGTHS);
          BUILD_TABLE_MAYBE_EMPTY(LENGTH);
          break;

        case LZX_BLOCKTYPE_UNCOMPRESSED:
          /* because we can't assume otherwise */
          lzx->intel_started = 1;

          /* read 1-16 (not 0-15) bits to align to bytes */
          if (bits_left == 0) ENSURE_BITS(16);
          bits_left = 0; bit_buffer = 0;

          /* read 12 bytes of stored R0 / R1 / R2 values */
          for (rundest = &buf[0], i = 0; i < 12; i++) {
            READ_IF_NEEDED;
            *rundest++ = *i_ptr++;
          }
          R0 = buf[0] | (buf[1] << 8) | (buf[2]  << 16) | (buf[3]  << 24);
          R1 = buf[4] | (buf[5] << 8) | (buf[6]  << 16) | (buf[7]  << 24);
          R2 = buf[8] | (buf[9] << 8) | (buf[10] << 16) | (buf[11] << 24);
          break;

        default:
          D(("bad block type"))
          return lzx->error = MSPACK_ERR_DECRUNCH;
        }
      }

      /* decode more of the block:
       * run = min(what's available, what's needed) */
      this_run = lzx->block_remaining;
      if (this_run > bytes_todo) this_run = bytes_todo;

      /* assume we decode exactly this_run bytes, for now */
      bytes_todo           -= this_run;
      lzx->block_remaining -= this_run;

      /* decode at least this_run bytes */
      switch (lzx->block_type) {
      case LZX_BLOCKTYPE_VERBATIM:
        while (this_run > 0) {
          READ_HUFFSYM(MAINTREE, main_element);
          if (main_element < LZX_NUM_CHARS) {
            /* literal: 0 to LZX_NUM_CHARS-1 */
            window[window_posn++] = main_element;
            this_run--;
          }
          else {
            /* match: LZX_NUM_CHARS + ((slot<<3) | length_header (3 bits)) */
            main_element -= LZX_NUM_CHARS;

            /* get match length */
            match_length = main_element & LZX_NUM_PRIMARY_LENGTHS;
            if (match_length == LZX_NUM_PRIMARY_LENGTHS) {
              if (lzx->LENGTH_empty) {
                D(("LENGTH symbol needed but tree is empty"))
                return lzx->error = MSPACK_ERR_DECRUNCH;
              }
              READ_HUFFSYM(LENGTH, length_footer);
              match_length += length_footer;
            }
            match_length += LZX_MIN_MATCH;

            /* get match offset */
            switch ((match_offset = (main_element >> 3))) {
            case 0: match_offset = R0;                                  break;
            case 1: match_offset = R1; R1=R0;        R0 = match_offset; break;
            case 2: match_offset = R2; R2=R0;        R0 = match_offset; break;
            case 3: match_offset = 1;  R2=R1; R1=R0; R0 = match_offset; break;
            default:
              extra = (match_offset >= 36) ? 17 : extra_bits[match_offset];
              READ_BITS(verbatim_bits, extra);
              match_offset = position_base[match_offset] - 2 + verbatim_bits;
              R2 = R1; R1 = R0; R0 = match_offset;
            }

            /* LZX DELTA uses max match length to signal even longer match */
            if (match_length == LZX_MAX_MATCH && lzx->is_delta) {
                int extra_len = 0;
                ENSURE_BITS(3); /* 4 entry huffman tree */
                if (PEEK_BITS(1) == 0) {
                    REMOVE_BITS(1); /* '0' -> 8 extra length bits */
                    READ_BITS(extra_len, 8);
                }
                else if (PEEK_BITS(2) == 2) {
                    REMOVE_BITS(2); /* '10' -> 10 extra length bits + 0x100 */
                    READ_BITS(extra_len, 10);
                    extra_len += 0x100;
                }
                else if (PEEK_BITS(3) == 6) {
                    REMOVE_BITS(3); /* '110' -> 12 extra length bits + 0x500 */
                    READ_BITS(extra_len, 12);
                    extra_len += 0x500;
                }
                else {
                    REMOVE_BITS(3); /* '111' -> 15 extra length bits */
                    READ_BITS(extra_len, 15);
                }
                match_length += extra_len;
            }

            if ((window_posn + match_length) > lzx->window_size) {
              D(("match ran over window wrap"))
              return lzx->error = MSPACK_ERR_DECRUNCH;
            }
            
            /* copy match */
            rundest = &window[window_posn];
            i = match_length;
            /* does match offset wrap the window? */
            if (match_offset > window_posn) {
              if ((off_t)match_offset > lzx->offset &&
                  (match_offset - window_posn) > lzx->ref_data_size)
              {
                D(("match offset beyond LZX stream"))
                return lzx->error = MSPACK_ERR_DECRUNCH;
              }
              /* j = length from match offset to end of window */
              j = match_offset - window_posn;
              if (j > (int) lzx->window_size) {
                D(("match offset beyond window boundaries"))
                return lzx->error = MSPACK_ERR_DECRUNCH;
              }
              runsrc = &window[lzx->window_size - j];
              if (j < i) {
                /* if match goes over the window edge, do two copy runs */
                i -= j; while (j-- > 0) *rundest++ = *runsrc++;
                runsrc = window;
              }
              while (i-- > 0) *rundest++ = *runsrc++;
            }
            else {
              runsrc = rundest - match_offset;
              while (i-- > 0) *rundest++ = *runsrc++;
            }

            this_run    -= match_length;
            window_posn += match_length;
          }
        } /* while (this_run > 0) */
        break;

      case LZX_BLOCKTYPE_ALIGNED:
        while (this_run > 0) {
          READ_HUFFSYM(MAINTREE, main_element);
          if (main_element < LZX_NUM_CHARS) {
            /* literal: 0 to LZX_NUM_CHARS-1 */
            window[window_posn++] = main_element;
            this_run--;
          }
          else {
            /* match: LZX_NUM_CHARS + ((slot<<3) | length_header (3 bits)) */
            main_element -= LZX_NUM_CHARS;

            /* get match length */
            match_length = main_element & LZX_NUM_PRIMARY_LENGTHS;
            if (match_length == LZX_NUM_PRIMARY_LENGTHS) {
              if (lzx->LENGTH_empty) {
                D(("LENGTH symbol needed but tree is empty"))
                return lzx->error = MSPACK_ERR_DECRUNCH;
              } 
              READ_HUFFSYM(LENGTH, length_footer);
              match_length += length_footer;
            }
            match_length += LZX_MIN_MATCH;

            /* get match offset */
            switch ((match_offset = (main_element >> 3))) {
            case 0: match_offset = R0;                             break;
            case 1: match_offset = R1; R1 = R0; R0 = match_offset; break;
            case 2: match_offset = R2; R2 = R0; R0 = match_offset; break;
            default:
              extra = (match_offset >= 36) ? 17 : extra_bits[match_offset];
              match_offset = position_base[match_offset] - 2;
              if (extra > 3) {
                /* verbatim and aligned bits */
                extra -= 3;
                READ_BITS(verbatim_bits, extra);
                match_offset += (verbatim_bits << 3);
                READ_HUFFSYM(ALIGNED, aligned_bits);
                match_offset += aligned_bits;
              }
              else if (extra == 3) {
                /* aligned bits only */
                READ_HUFFSYM(ALIGNED, aligned_bits);
                match_offset += aligned_bits;
              }
              else if (extra > 0) { /* extra==1, extra==2 */
                /* verbatim bits only */
                READ_BITS(verbatim_bits, extra);
                match_offset += verbatim_bits;
              }
              else /* extra == 0 */ {
                /* ??? not defined in LZX specification! */
                match_offset = 1;
              }
              /* update repeated offset LRU queue */
              R2 = R1; R1 = R0; R0 = match_offset;
            }

            /* LZX DELTA uses max match length to signal even longer match */
            if (match_length == LZX_MAX_MATCH && lzx->is_delta) {
                int extra_len = 0;
                ENSURE_BITS(3); /* 4 entry huffman tree */
                if (PEEK_BITS(1) == 0) {
                    REMOVE_BITS(1); /* '0' -> 8 extra length bits */
                    READ_BITS(extra_len, 8);
                }
                else if (PEEK_BITS(2) == 2) {
                    REMOVE_BITS(2); /* '10' -> 10 extra length bits + 0x100 */
                    READ_BITS(extra_len, 10);
                    extra_len += 0x100;
                }
                else if (PEEK_BITS(3) == 6) {
                    REMOVE_BITS(3); /* '110' -> 12 extra length bits + 0x500 */
                    READ_BITS(extra_len, 12);
                    extra_len += 0x500;
                }
                else {
                    REMOVE_BITS(3); /* '111' -> 15 extra length bits */
                    READ_BITS(extra_len, 15);
                }
                match_length += extra_len;
            }

            if ((window_posn + match_length) > lzx->window_size) {
              D(("match ran over window wrap"))
              return lzx->error = MSPACK_ERR_DECRUNCH;
            }

            /* copy match */
            rundest = &window[window_posn];
            i = match_length;
            /* does match offset wrap the window? */
            if (match_offset > window_posn) {
              if ((off_t)match_offset > lzx->offset &&
                  (match_offset - window_posn) > lzx->ref_data_size)
              {
                D(("match offset beyond LZX stream"))
                return lzx->error = MSPACK_ERR_DECRUNCH;
              }
              /* j = length from match offset to end of window */
              j = match_offset - window_posn;
              if (j > (int) lzx->window_size) {
                D(("match offset beyond window boundaries"))
                return lzx->error = MSPACK_ERR_DECRUNCH;
              }
              runsrc = &window[lzx->window_size - j];
              if (j < i) {
                /* if match goes over the window edge, do two copy runs */
                i -= j; while (j-- > 0) *rundest++ = *runsrc++;
                runsrc = window;
              }
              while (i-- > 0) *rundest++ = *runsrc++;
            }
            else {
              runsrc = rundest - match_offset;
              while (i-- > 0) *rundest++ = *runsrc++;
            }

            this_run    -= match_length;
            window_posn += match_length;
          }
        } /* while (this_run > 0) */
        break;

      case LZX_BLOCKTYPE_UNCOMPRESSED:
        /* as this_run is limited not to wrap a frame, this also means it
         * won't wrap the window (as the window is a multiple of 32k) */
        rundest = &window[window_posn];
        window_posn += this_run;
        while (this_run > 0) {
          if ((i = (int)(i_end - i_ptr)) == 0) {
            READ_IF_NEEDED;
          }
          else {
            if (i > this_run) i = this_run;
            lzx->sys->copy(i_ptr, rundest, (size_t) i);
            rundest  += i;
            i_ptr    += i;
            this_run -= i;
          }
        }
        break;

      default:
        return lzx->error = MSPACK_ERR_DECRUNCH; /* might as well */
      }

      /* did the final match overrun our desired this_run length? */
      if (this_run < 0) {
        if ((unsigned int)(-this_run) > lzx->block_remaining) {
          D(("overrun went past end of block by %d (%d remaining)",
             -this_run, lzx->block_remaining ))
          return lzx->error = MSPACK_ERR_DECRUNCH;
        }
        lzx->block_remaining -= -this_run;
      }
    } /* while (bytes_todo > 0) */

    /* streams don't extend over frame boundaries */
    if ((window_posn - lzx->frame_posn) != frame_size) {
      D(("decode beyond output frame limits! %d != %d",
         window_posn - lzx->frame_posn, frame_size))
      return lzx->error = MSPACK_ERR_DECRUNCH;
    }

    /* re-align input bitstream */
    if (bits_left > 0) ENSURE_BITS(16);
    if (bits_left & 15) REMOVE_BITS(bits_left & 15);

    /* check that we've used all of the previous frame first */
    if (lzx->o_ptr != lzx->o_end) {
      D(("%ld avail bytes, new %d frame",
          (long)(lzx->o_end - lzx->o_ptr), frame_size))
      return lzx->error = MSPACK_ERR_DECRUNCH;
    }

    /* does this intel block _really_ need decoding? */
    if (lzx->intel_started && lzx->intel_filesize &&
        (lzx->frame <= 32768) && (frame_size > 10))
    {
      unsigned char *data    = &lzx->e8_buf[0];
      unsigned char *dataend = &lzx->e8_buf[frame_size - 10];
      signed int curpos      = lzx->intel_curpos;
      signed int filesize    = lzx->intel_filesize;
      signed int abs_off, rel_off;

      /* copy e8 block to the e8 buffer and tweak if needed */
      lzx->o_ptr = data;
      lzx->sys->copy(&lzx->window[lzx->frame_posn], data, frame_size);

      while (data < dataend) {
        if (*data++ != 0xE8) { curpos++; continue; }
        abs_off = data[0] | (data[1]<<8) | (data[2]<<16) | (data[3]<<24);
        if ((abs_off >= -curpos) && (abs_off < filesize)) {
          rel_off = (abs_off >= 0) ? abs_off - curpos : abs_off + filesize;
          data[0] = (unsigned char) rel_off;
          data[1] = (unsigned char) (rel_off >> 8);
          data[2] = (unsigned char) (rel_off >> 16);
          data[3] = (unsigned char) (rel_off >> 24);
        }
        data += 4;
        curpos += 5;
      }
      lzx->intel_curpos += frame_size;
    }
    else {
      lzx->o_ptr = &lzx->window[lzx->frame_posn];
      if (lzx->intel_filesize) lzx->intel_curpos += frame_size;
    }
    lzx->o_end = &lzx->o_ptr[frame_size];

    /* write a frame */
    i = (out_bytes < (off_t)frame_size) ? (unsigned int)out_bytes : frame_size;
    if (lzx->sys->write(lzx->output, lzx->o_ptr, i) != i) {
      return lzx->error = MSPACK_ERR_WRITE;
    }
    lzx->o_ptr  += i;
    lzx->offset += i;
    out_bytes   -= i;

    /* advance frame start position */
    lzx->frame_posn += frame_size;
    lzx->frame++;

    /* wrap window / frame position pointers */
    if (window_posn == lzx->window_size)     window_posn = 0;
    if (lzx->frame_posn == lzx->window_size) lzx->frame_posn = 0;

  } /* while (lzx->frame < end_frame) */

  if (out_bytes) {
    D(("bytes left to output"))
    return lzx->error = MSPACK_ERR_DECRUNCH;
  }

  /* store local state */
  STORE_BITS;
  lzx->window_posn = window_posn;
  lzx->R0 = R0;
  lzx->R1 = R1;
  lzx->R2 = R2;

  return MSPACK_ERR_OK;
}

void lzxd_free(struct lzxd_stream *lzx) {
  struct mspack_system *sys;
  if (lzx) {
    sys = lzx->sys;
    sys->free(lzx->inbuf);
    sys->free(lzx->window);
    sys->free(lzx);
  }
}

```

`3rdparty/mspack/mspack.h`:

```h
/* libmspack -- a library for working with Microsoft compression formats.
 * (C) 2003-2016 Stuart Caie <kyzer@cabextract.org.uk>
 *
 * libmspack is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License (LGPL) version 2.1
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/** \mainpage
 *
 * \section intro Introduction
 *
 * libmspack is a library which provides compressors and decompressors,
 * archivers and dearchivers for Microsoft compression formats.
 *
 * \section formats Formats supported
 *
 * The following file formats are supported:
 * - SZDD files, which use LZSS compression
 * - KWAJ files, which use LZSS, LZSS+Huffman or deflate compression
 * - .HLP (MS Help) files, which use LZSS compression
 * - .CAB (MS Cabinet) files, which use deflate, LZX or Quantum compression
 * - .CHM (HTML Help) files, which use LZX compression
 * - .LIT (MS EBook) files, which use LZX compression and DES encryption
 * - .LZX (Exchange Offline Addressbook) files, which use LZX compression
 *
 * To determine the capabilities of the library, and the binary
 * compatibility version of any particular compressor or decompressor, use
 * the mspack_version() function. The UNIX library interface version is
 * defined as the highest-versioned library component.
 *
 * \section starting Getting started
 *
 * The macro MSPACK_SYS_SELFTEST() should be used to ensure the library can
 * be used. In particular, it checks if the caller is using 32-bit file I/O
 * when the library is compiled for 64-bit file I/O and vice versa.
 *
 * If compiled normally, the library includes basic file I/O and memory
 * management functionality using the standard C library. This can be
 * customised and replaced entirely by creating a mspack_system structure.
 *
 * A compressor or decompressor for the required format must be
 * instantiated before it can be used. Each construction function takes
 * one parameter, which is either a pointer to a custom mspack_system
 * structure, or NULL to use the default. The instantiation returned, if
 * not NULL, contains function pointers (methods) to work with the given
 * file format.
 * 
 * For compression:
 * - mspack_create_cab_compressor() creates a mscab_compressor
 * - mspack_create_chm_compressor() creates a mschm_compressor
 * - mspack_create_lit_compressor() creates a mslit_compressor
 * - mspack_create_hlp_compressor() creates a mshlp_compressor
 * - mspack_create_szdd_compressor() creates a msszdd_compressor
 * - mspack_create_kwaj_compressor() creates a mskwaj_compressor
 * - mspack_create_oab_compressor() creates a msoab_compressor
 *
 * For decompression:
 * - mspack_create_cab_decompressor() creates a mscab_decompressor
 * - mspack_create_chm_decompressor() creates a mschm_decompressor
 * - mspack_create_lit_decompressor() creates a mslit_decompressor
 * - mspack_create_hlp_decompressor() creates a mshlp_decompressor
 * - mspack_create_szdd_decompressor() creates a msszdd_decompressor
 * - mspack_create_kwaj_decompressor() creates a mskwaj_decompressor
 * - mspack_create_oab_decompressor() creates a msoab_decompressor
 *
 * Once finished working with a format, each kind of
 * compressor/decompressor has its own specific destructor:
 * - mspack_destroy_cab_compressor()
 * - mspack_destroy_cab_decompressor()
 * - mspack_destroy_chm_compressor()
 * - mspack_destroy_chm_decompressor()
 * - mspack_destroy_lit_compressor()
 * - mspack_destroy_lit_decompressor()
 * - mspack_destroy_hlp_compressor()
 * - mspack_destroy_hlp_decompressor()
 * - mspack_destroy_szdd_compressor()
 * - mspack_destroy_szdd_decompressor()
 * - mspack_destroy_kwaj_compressor()
 * - mspack_destroy_kwaj_decompressor()
 * - mspack_destroy_oab_compressor()
 * - mspack_destroy_oab_decompressor()
 *
 * Destroying a compressor or decompressor does not destroy any objects,
 * structures or handles that have been created using that compressor or
 * decompressor. Ensure that everything created or opened is destroyed or
 * closed before compressor/decompressor is itself destroyed.
 *
 * \section errors Error codes
 *
 * All compressors and decompressors use the same set of error codes. Most
 * methods return an error code directly. For methods which do not
 * return error codes directly, the error code can be obtained with the
 * last_error() method.
 *
 * - #MSPACK_ERR_OK is used to indicate success. This error code is defined
 *   as zero, all other code are non-zero.
 * - #MSPACK_ERR_ARGS indicates that a method was called with inappropriate
 *   arguments.
 * - #MSPACK_ERR_OPEN indicates that mspack_system::open() failed.
 * - #MSPACK_ERR_READ indicates that mspack_system::read() failed.
 * - #MSPACK_ERR_WRITE indicates that mspack_system::write() failed.
 * - #MSPACK_ERR_SEEK indicates that mspack_system::seek() failed.
 * - #MSPACK_ERR_NOMEMORY indicates that mspack_system::alloc() failed.
 * - #MSPACK_ERR_SIGNATURE indicates that the file being read does not
 *   have the correct "signature". It is probably not a valid file for
 *   whatever format is being read.
 * - #MSPACK_ERR_DATAFORMAT indicates that the file being used or read
 *   is corrupt.
 * - #MSPACK_ERR_CHECKSUM indicates that a data checksum has failed.
 * - #MSPACK_ERR_CRUNCH indicates an error occured during compression.
 * - #MSPACK_ERR_DECRUNCH indicates an error occured during decompression.
 *
 * \section threading Multi-threading
 *
 * libmspack methods are reentrant and multithreading-safe when each
 * thread has its own compressor or decompressor.

 * You should not call multiple methods simultaneously on a single
 * compressor or decompressor instance.
 *
 * If this may happen, you can either use one compressor or
 * decompressor per thread, or you can use your preferred lock,
 * semaphore or mutex library to ensure no more than one method on a
 * compressor/decompressor is called simultaneously. libmspack will
 * not do this locking for you.
 *
 * Example of incorrect behaviour:
 * - thread 1 calls mspack_create_cab_decompressor()
 * - thread 1 calls open()
 * - thread 1 calls extract() for one file
 * - thread 2 simultaneously calls extract() for another file
 *
 * Correct behaviour:
 * - thread 1 calls mspack_create_cab_decompressor()
 * - thread 2 calls mspack_create_cab_decompressor()
 * - thread 1 calls its own open() / extract()
 * - thread 2 simultaneously calls its own open() / extract()
 *
 * Also correct behaviour:
 * - thread 1 calls mspack_create_cab_decompressor()
 * - thread 1 locks a mutex for with the decompressor before
 *   calling any methods on it, and unlocks the mutex after each
 *   method returns.
 * - thread 1 can share the results of open() with thread 2, and both
 *   can call extract(), provided they both guard against simultaneous
 *   use of extract(), and any other methods, with the mutex
 */

#ifndef LIB_MSPACK_H
#define LIB_MSPACK_H 1

#ifdef __cplusplus
extern "C" {
#endif

#include <sys/types.h>
#include <stdlib.h>

/**
 * System self-test function, to ensure both library and calling program
 * can use one another.
 *
 * A result of MSPACK_ERR_OK means the library and caller are
 * compatible. Any other result indicates that the library and caller are
 * not compatible and should not be used. In particular, a value of
 * MSPACK_ERR_SEEK means the library and caller use different off_t
 * datatypes.
 *
 * It should be used like so:
 *
 * @code
 * int selftest_result;
 * MSPACK_SYS_SELFTEST(selftest_result);
 * if (selftest_result != MSPACK_ERR_OK) {
 *   fprintf(stderr, "incompatible with this build of libmspack\n");
 *   exit(0);
 * }
 * @endcode
 *
 * @param  result   an int variable to store the result of the self-test
 */
#define MSPACK_SYS_SELFTEST(result)  do { \
  (result) = mspack_sys_selftest_internal(sizeof(off_t)); \
} while (0)

/** Part of the MSPACK_SYS_SELFTEST() macro, must not be used directly. */
extern int mspack_sys_selftest_internal(int);

/**
 * Enquire about the binary compatibility version of a specific interface in
 * the library. Currently, the following interfaces are defined:
 *
 * - #MSPACK_VER_LIBRARY: the overall library
 * - #MSPACK_VER_SYSTEM: the mspack_system interface
 * - #MSPACK_VER_MSCABD: the mscab_decompressor interface
 * - #MSPACK_VER_MSCABC: the mscab_compressor interface
 * - #MSPACK_VER_MSCHMD: the mschm_decompressor interface
 * - #MSPACK_VER_MSCHMC: the mschm_compressor interface
 * - #MSPACK_VER_MSLITD: the mslit_decompressor interface
 * - #MSPACK_VER_MSLITC: the mslit_compressor interface
 * - #MSPACK_VER_MSHLPD: the mshlp_decompressor interface
 * - #MSPACK_VER_MSHLPC: the mshlp_compressor interface
 * - #MSPACK_VER_MSSZDDD: the msszdd_decompressor interface
 * - #MSPACK_VER_MSSZDDC: the msszdd_compressor interface
 * - #MSPACK_VER_MSKWAJD: the mskwaj_decompressor interface
 * - #MSPACK_VER_MSKWAJC: the mskwaj_compressor interface
 * - #MSPACK_VER_MSOABD: the msoab_decompressor interface
 * - #MSPACK_VER_MSOABC: the msoab_compressor interface
 *
 * The result of the function should be interpreted as follows:
 * - -1: this interface is completely unknown to the library
 * - 0: this interface is known, but non-functioning
 * - 1: this interface has all basic functionality
 * - 2, 3, ...: this interface has additional functionality, clearly marked
 *   in the documentation as "version 2", "version 3" and so on.
 *
 * @param entity the interface to request current version of
 * @return the version of the requested interface
 */
extern int mspack_version(int entity);

/** Pass to mspack_version() to get the overall library version */
#define MSPACK_VER_LIBRARY   (0)
/** Pass to mspack_version() to get the mspack_system version */
#define MSPACK_VER_SYSTEM    (1)
/** Pass to mspack_version() to get the mscab_decompressor version */
#define MSPACK_VER_MSCABD    (2)
/** Pass to mspack_version() to get the mscab_compressor version */
#define MSPACK_VER_MSCABC    (3)
/** Pass to mspack_version() to get the mschm_decompressor version */
#define MSPACK_VER_MSCHMD    (4)
/** Pass to mspack_version() to get the mschm_compressor version */
#define MSPACK_VER_MSCHMC    (5)
/** Pass to mspack_version() to get the mslit_decompressor version */
#define MSPACK_VER_MSLITD    (6)
/** Pass to mspack_version() to get the mslit_compressor version */
#define MSPACK_VER_MSLITC    (7)
/** Pass to mspack_version() to get the mshlp_decompressor version */
#define MSPACK_VER_MSHLPD    (8)
/** Pass to mspack_version() to get the mshlp_compressor version */
#define MSPACK_VER_MSHLPC    (9)
/** Pass to mspack_version() to get the msszdd_decompressor version */
#define MSPACK_VER_MSSZDDD   (10)
/** Pass to mspack_version() to get the msszdd_compressor version */
#define MSPACK_VER_MSSZDDC   (11)
/** Pass to mspack_version() to get the mskwaj_decompressor version */
#define MSPACK_VER_MSKWAJD   (12)
/** Pass to mspack_version() to get the mskwaj_compressor version */
#define MSPACK_VER_MSKWAJC   (13)
/** Pass to mspack_version() to get the msoab_decompressor version */
#define MSPACK_VER_MSOABD    (14)
/** Pass to mspack_version() to get the msoab_compressor version */
#define MSPACK_VER_MSOABC    (15)

/* --- file I/O abstraction ------------------------------------------------ */

/**
 * A structure which abstracts file I/O and memory management.
 *
 * The library always uses the mspack_system structure for interaction
 * with the file system and to allocate, free and copy all memory. It also
 * uses it to send literal messages to the library user.
 *
 * When the library is compiled normally, passing NULL to a compressor or
 * decompressor constructor will result in a default mspack_system being
 * used, where all methods are implemented with the standard C library.
 * However, all constructors support being given a custom created
 * mspack_system structure, with the library user's own methods. This
 * allows for more abstract interaction, such as reading and writing files
 * directly to memory, or from a network socket or pipe.
 *
 * Implementors of an mspack_system structure should read all
 * documentation entries for every structure member, and write methods
 * which conform to those standards.
 */
struct mspack_system {
  /**
   * Opens a file for reading, writing, appending or updating.
   *
   * @param self     a self-referential pointer to the mspack_system
   *                 structure whose open() method is being called. If
   *                 this pointer is required by close(), read(), write(),
   *                 seek() or tell(), it should be stored in the result
   *                 structure at this time.
   * @param filename the file to be opened. It is passed directly from the
   *                 library caller without being modified, so it is up to
   *                 the caller what this parameter actually represents.
   * @param mode     one of #MSPACK_SYS_OPEN_READ (open an existing file
   *                 for reading), #MSPACK_SYS_OPEN_WRITE (open a new file
   *                 for writing), #MSPACK_SYS_OPEN_UPDATE (open an existing
   *                 file for reading/writing from the start of the file) or
   *                 #MSPACK_SYS_OPEN_APPEND (open an existing file for
   *                 reading/writing from the end of the file)
   * @return a pointer to a mspack_file structure. This structure officially
   *         contains no members, its true contents are up to the
   *         mspack_system implementor. It should contain whatever is needed
   *         for other mspack_system methods to operate. Returning the NULL
   *         pointer indicates an error condition.
   * @see close(), read(), write(), seek(), tell(), message()
   */
  struct mspack_file * (*open)(struct mspack_system *self,
                               const char *filename,
                               int mode);

  /**
   * Closes a previously opened file. If any memory was allocated for this
   * particular file handle, it should be freed at this time.
   * 
   * @param file the file to close
   * @see open()
   */
  void (*close)(struct mspack_file *file);

  /**
   * Reads a given number of bytes from an open file.
   *
   * @param file    the file to read from
   * @param buffer  the location where the read bytes should be stored
   * @param bytes   the number of bytes to read from the file.
   * @return the number of bytes successfully read (this can be less than
   *         the number requested), zero to mark the end of file, or less
   *         than zero to indicate an error. The library does not "retry"
   *         reads and assumes short reads are due to EOF, so you should
   *         avoid returning short reads because of transient errors.
   * @see open(), write()
   */
  int (*read)(struct mspack_file *file,
              void *buffer,
              int bytes);

  /**
   * Writes a given number of bytes to an open file.
   *
   * @param file    the file to write to
   * @param buffer  the location where the written bytes should be read from
   * @param bytes   the number of bytes to write to the file.
   * @return the number of bytes successfully written, this can be less
   *         than the number requested. Zero or less can indicate an error
   *         where no bytes at all could be written. All cases where less
   *         bytes were written than requested are considered by the library
   *         to be an error.
   * @see open(), read()
   */
  int (*write)(struct mspack_file *file,
               void *buffer,
               int bytes);

  /**
   * Seeks to a specific file offset within an open file.
   *
   * Sometimes the library needs to know the length of a file. It does
   * this by seeking to the end of the file with seek(file, 0,
   * MSPACK_SYS_SEEK_END), then calling tell(). Implementations may want
   * to make a special case for this.
   *
   * Due to the potentially varying 32/64 bit datatype off_t on some
   * architectures, the #MSPACK_SYS_SELFTEST macro MUST be used before
   * using the library. If not, the error caused by the library passing an
   * inappropriate stackframe to seek() is subtle and hard to trace.
   *
   * @param file   the file to be seeked
   * @param offset an offset to seek, measured in bytes
   * @param mode   one of #MSPACK_SYS_SEEK_START (the offset should be
   *               measured from the start of the file), #MSPACK_SYS_SEEK_CUR
   *               (the offset should be measured from the current file offset)
   *               or #MSPACK_SYS_SEEK_END (the offset should be measured from
   *               the end of the file)
   * @return zero for success, non-zero for an error
   * @see open(), tell()
   */
  int (*seek)(struct mspack_file *file,
              off_t offset,
              int mode);

  /**
   * Returns the current file position (in bytes) of the given file.
   *
   * @param file the file whose file position is wanted
   * @return the current file position of the file
   * @see open(), seek()
   */
  off_t (*tell)(struct mspack_file *file);
  
  /**
   * Used to send messages from the library to the user.
   *
   * Occasionally, the library generates warnings or other messages in
   * plain english to inform the human user. These are informational only
   * and can be ignored if not wanted.
   *
   * @param file   may be a file handle returned from open() if this message
   *               pertains to a specific open file, or NULL if not related to
   *               a specific file.
   * @param format a printf() style format string. It does NOT include a
   *               trailing newline.
   * @see open()
   */
  void (*message)(struct mspack_file *file,
                  const char *format,
                  ...);

  /**
   * Allocates memory.
   *
   * @param self     a self-referential pointer to the mspack_system
   *                 structure whose alloc() method is being called.
   * @param bytes    the number of bytes to allocate
   * @result a pointer to the requested number of bytes, or NULL if
   *         not enough memory is available
   * @see free()
   */
  void * (*alloc)(struct mspack_system *self,
                  size_t bytes);
  
  /**
   * Frees memory.
   * 
   * @param ptr the memory to be freed. NULL is accepted and ignored.
   * @see alloc()
   */
  void (*free)(void *ptr);

  /**
   * Copies from one region of memory to another.
   * 
   * The regions of memory are guaranteed not to overlap, are usually less
   * than 256 bytes, and may not be aligned. Please note that the source
   * parameter comes before the destination parameter, unlike the standard
   * C function memcpy().
   *
   * @param src   the region of memory to copy from
   * @param dest  the region of memory to copy to
   * @param bytes the size of the memory region, in bytes
   */
  void (*copy)(void *src,
               void *dest,
               size_t bytes);

  /**
   * A null pointer to mark the end of mspack_system. It must equal NULL.
   *
   * Should the mspack_system structure extend in the future, this NULL
   * will be seen, rather than have an invalid method pointer called.
   */
  void *null_ptr;
};

/** mspack_system::open() mode: open existing file for reading. */
#define MSPACK_SYS_OPEN_READ   (0)
/** mspack_system::open() mode: open new file for writing */
#define MSPACK_SYS_OPEN_WRITE  (1)
/** mspack_system::open() mode: open existing file for writing */
#define MSPACK_SYS_OPEN_UPDATE (2)
/** mspack_system::open() mode: open existing file for writing */
#define MSPACK_SYS_OPEN_APPEND (3)

/** mspack_system::seek() mode: seek relative to start of file */
#define MSPACK_SYS_SEEK_START  (0)
/** mspack_system::seek() mode: seek relative to current offset */
#define MSPACK_SYS_SEEK_CUR    (1)
/** mspack_system::seek() mode: seek relative to end of file */
#define MSPACK_SYS_SEEK_END    (2)

/** 
 * A structure which represents an open file handle. The contents of this
 * structure are determined by the implementation of the
 * mspack_system::open() method.
 */
struct mspack_file {
  int dummy;
};

/* --- error codes --------------------------------------------------------- */

/** Error code: no error */
#define MSPACK_ERR_OK          (0)
/** Error code: bad arguments to method */
#define MSPACK_ERR_ARGS        (1)
/** Error code: error opening file */
#define MSPACK_ERR_OPEN        (2)
/** Error code: error reading file */
#define MSPACK_ERR_READ        (3)
/** Error code: error writing file */
#define MSPACK_ERR_WRITE       (4)
/** Error code: seek error */
#define MSPACK_ERR_SEEK        (5)
/** Error code: out of memory */
#define MSPACK_ERR_NOMEMORY    (6)
/** Error code: bad "magic id" in file */
#define MSPACK_ERR_SIGNATURE   (7)
/** Error code: bad or corrupt file format */
#define MSPACK_ERR_DATAFORMAT  (8)
/** Error code: bad checksum or CRC */
#define MSPACK_ERR_CHECKSUM    (9)
/** Error code: error during compression */
#define MSPACK_ERR_CRUNCH      (10)
/** Error code: error during decompression */
#define MSPACK_ERR_DECRUNCH    (11)

/* --- functions available in library -------------------------------------- */

/** Creates a new CAB compressor.
 * @param sys a custom mspack_system structure, or NULL to use the default
 * @return a #mscab_compressor or NULL
 */
extern struct mscab_compressor *
  mspack_create_cab_compressor(struct mspack_system *sys);

/** Creates a new CAB decompressor.
 * @param sys a custom mspack_system structure, or NULL to use the default
 * @return a #mscab_decompressor or NULL
 */
extern struct mscab_decompressor *
  mspack_create_cab_decompressor(struct mspack_system *sys);

/** Destroys an existing CAB compressor.
 * @param self the #mscab_compressor to destroy
 */
extern void mspack_destroy_cab_compressor(struct mscab_compressor *self);

/** Destroys an existing CAB decompressor.
 * @param self the #mscab_decompressor to destroy
 */
extern void mspack_destroy_cab_decompressor(struct mscab_decompressor *self);


/** Creates a new CHM compressor.
 * @param sys a custom mspack_system structure, or NULL to use the default
 * @return a #mschm_compressor or NULL
 */
extern struct mschm_compressor *
  mspack_create_chm_compressor(struct mspack_system *sys);

/** Creates a new CHM decompressor.
 * @param sys a custom mspack_system structure, or NULL to use the default
 * @return a #mschm_decompressor or NULL
 */
extern struct mschm_decompressor *
  mspack_create_chm_decompressor(struct mspack_system *sys);

/** Destroys an existing CHM compressor.
 * @param self the #mschm_compressor to destroy
 */
extern void mspack_destroy_chm_compressor(struct mschm_compressor *self);

/** Destroys an existing CHM decompressor.
 * @param self the #mschm_decompressor to destroy
 */
extern void mspack_destroy_chm_decompressor(struct mschm_decompressor *self);


/** Creates a new LIT compressor.
 * @param sys a custom mspack_system structure, or NULL to use the default
 * @return a #mslit_compressor or NULL
 */
extern struct mslit_compressor *
  mspack_create_lit_compressor(struct mspack_system *sys);

/** Creates a new LIT decompressor.
 * @param sys a custom mspack_system structure, or NULL to use the default
 * @return a #mslit_decompressor or NULL
 */
extern struct mslit_decompressor *
  mspack_create_lit_decompressor(struct mspack_system *sys);

/** Destroys an existing LIT compressor.
 * @param self the #mslit_compressor to destroy
 */
extern void mspack_destroy_lit_compressor(struct mslit_compressor *self);

/** Destroys an existing LIT decompressor.
 * @param self the #mslit_decompressor to destroy
 */
extern void mspack_destroy_lit_decompressor(struct mslit_decompressor *self);


/** Creates a new HLP compressor.
 * @param sys a custom mspack_system structure, or NULL to use the default
 * @return a #mshlp_compressor or NULL
 */
extern struct mshlp_compressor *
  mspack_create_hlp_compressor(struct mspack_system *sys);

/** Creates a new HLP decompressor.
 * @param sys a custom mspack_system structure, or NULL to use the default
 * @return a #mshlp_decompressor or NULL
 */
extern struct mshlp_decompressor *
  mspack_create_hlp_decompressor(struct mspack_system *sys);

/** Destroys an existing hlp compressor.
 * @param self the #mshlp_compressor to destroy
 */
extern void mspack_destroy_hlp_compressor(struct mshlp_compressor *self);

/** Destroys an existing hlp decompressor.
 * @param self the #mshlp_decompressor to destroy
 */
extern void mspack_destroy_hlp_decompressor(struct mshlp_decompressor *self);


/** Creates a new SZDD compressor.
 * @param sys a custom mspack_system structure, or NULL to use the default
 * @return a #msszdd_compressor or NULL
 */
extern struct msszdd_compressor *
  mspack_create_szdd_compressor(struct mspack_system *sys);

/** Creates a new SZDD decompressor.
 * @param sys a custom mspack_system structure, or NULL to use the default
 * @return a #msszdd_decompressor or NULL
 */
extern struct msszdd_decompressor *
  mspack_create_szdd_decompressor(struct mspack_system *sys);

/** Destroys an existing SZDD compressor.
 * @param self the #msszdd_compressor to destroy
 */
extern void mspack_destroy_szdd_compressor(struct msszdd_compressor *self);

/** Destroys an existing SZDD decompressor.
 * @param self the #msszdd_decompressor to destroy
 */
extern void mspack_destroy_szdd_decompressor(struct msszdd_decompressor *self);


/** Creates a new KWAJ compressor.
 * @param sys a custom mspack_system structure, or NULL to use the default
 * @return a #mskwaj_compressor or NULL
 */
extern struct mskwaj_compressor *
  mspack_create_kwaj_compressor(struct mspack_system *sys);

/** Creates a new KWAJ decompressor.
 * @param sys a custom mspack_system structure, or NULL to use the default
 * @return a #mskwaj_decompressor or NULL
 */
extern struct mskwaj_decompressor *
  mspack_create_kwaj_decompressor(struct mspack_system *sys);

/** Destroys an existing KWAJ compressor.
 * @param self the #mskwaj_compressor to destroy
 */
extern void mspack_destroy_kwaj_compressor(struct mskwaj_compressor *self);

/** Destroys an existing KWAJ decompressor.
 * @param self the #mskwaj_decompressor to destroy
 */
extern void mspack_destroy_kwaj_decompressor(struct mskwaj_decompressor *self);


/** Creates a new OAB compressor.
 * @param sys a custom mspack_system structure, or NULL to use the default
 * @return a #msoab_compressor or NULL
 */
extern struct msoab_compressor *
  mspack_create_oab_compressor(struct mspack_system *sys);

/** Creates a new OAB decompressor.
 * @param sys a custom mspack_system structure, or NULL to use the default
 * @return a #msoab_decompressor or NULL
 */
extern struct msoab_decompressor *
  mspack_create_oab_decompressor(struct mspack_system *sys);

/** Destroys an existing OAB compressor.
 * @param self the #msoab_compressor to destroy
 */
extern void mspack_destroy_oab_compressor(struct msoab_compressor *self);

/** Destroys an existing OAB decompressor.
 * @param self the #msoab_decompressor to destroy
 */
extern void mspack_destroy_oab_decompressor(struct msoab_decompressor *self);


/* --- support for .CAB (MS Cabinet) file format --------------------------- */

/**
 * A structure which represents a single cabinet file.
 *
 * All fields are READ ONLY.
 *
 * If this cabinet is part of a merged cabinet set, the #files and #folders
 * fields are common to all cabinets in the set, and will be identical.
 *
 * @see mscab_decompressor::open(), mscab_decompressor::close(),
 *      mscab_decompressor::search()
 */
struct mscabd_cabinet {
  /**
   * The next cabinet in a chained list, if this cabinet was opened with
   * mscab_decompressor::search(). May be NULL to mark the end of the
   * list.
   */
  struct mscabd_cabinet *next;

  /**
   * The filename of the cabinet. More correctly, the filename of the
   * physical file that the cabinet resides in. This is given by the
   * library user and may be in any format.
   */
  const char *filename;
  
  /** The file offset of cabinet within the physical file it resides in. */
  off_t base_offset;

  /** The length of the cabinet file in bytes. */
  unsigned int length;

  /** The previous cabinet in a cabinet set, or NULL. */
  struct mscabd_cabinet *prevcab;

  /** The next cabinet in a cabinet set, or NULL. */
  struct mscabd_cabinet *nextcab;

  /** The filename of the previous cabinet in a cabinet set, or NULL. */
  char *prevname;

  /** The filename of the next cabinet in a cabinet set, or NULL. */
  char *nextname;

  /** The name of the disk containing the previous cabinet in a cabinet
   * set, or NULL.
   */
  char *previnfo;

  /** The name of the disk containing the next cabinet in a cabinet set,
   * or NULL.
   */
  char *nextinfo;

  /** A list of all files in the cabinet or cabinet set. */
  struct mscabd_file *files;

  /** A list of all folders in the cabinet or cabinet set. */
  struct mscabd_folder *folders;

  /** 
   * The set ID of the cabinet. All cabinets in the same set should have
   * the same set ID.
   */
  unsigned short set_id;

  /**
   * The index number of the cabinet within the set. Numbering should
   * start from 0 for the first cabinet in the set, and increment by 1 for
   * each following cabinet.
   */
  unsigned short set_index;

  /**
   * The number of bytes reserved in the header area of the cabinet.
   *
   * If this is non-zero and flags has MSCAB_HDR_RESV set, this data can
   * be read by the calling application. It is of the given length,
   * located at offset (base_offset + MSCAB_HDR_RESV_OFFSET) in the
   * cabinet file.
   *
   * @see flags
   */
  unsigned short header_resv;

  /**
   * Header flags.
   *
   * - MSCAB_HDR_PREVCAB indicates the cabinet is part of a cabinet set, and
   *                     has a predecessor cabinet.
   * - MSCAB_HDR_NEXTCAB indicates the cabinet is part of a cabinet set, and
   *                     has a successor cabinet.
   * - MSCAB_HDR_RESV indicates the cabinet has reserved header space.
   *
   * @see prevname, previnfo, nextname, nextinfo, header_resv
   */
  int flags;
};

/** Offset from start of cabinet to the reserved header data (if present). */
#define MSCAB_HDR_RESV_OFFSET (0x28)

/** Cabinet header flag: cabinet has a predecessor */
#define MSCAB_HDR_PREVCAB (0x01)
/** Cabinet header flag: cabinet has a successor */
#define MSCAB_HDR_NEXTCAB (0x02)
/** Cabinet header flag: cabinet has reserved header space */
#define MSCAB_HDR_RESV    (0x04)

/**
 * A structure which represents a single folder in a cabinet or cabinet set.
 *
 * All fields are READ ONLY.
 *
 * A folder is a single compressed stream of data. When uncompressed, it
 * holds the data of one or more files. A folder may be split across more
 * than one cabinet.
 */
struct mscabd_folder {
  /**
   * A pointer to the next folder in this cabinet or cabinet set, or NULL
   * if this is the final folder.
   */
  struct mscabd_folder *next;

  /** 
   * The compression format used by this folder.
   *
   * The macro MSCABD_COMP_METHOD() should be used on this field to get
   * the algorithm used. The macro MSCABD_COMP_LEVEL() should be used to get
   * the "compression level".
   *
   * @see MSCABD_COMP_METHOD(), MSCABD_COMP_LEVEL()
   */
  int comp_type;

  /**
   * The total number of data blocks used by this folder. This includes
   * data blocks present in other files, if this folder spans more than
   * one cabinet.
   */
  unsigned int num_blocks;
};

/**
 * Returns the compression method used by a folder.
 *
 * @param comp_type a mscabd_folder::comp_type value
 * @return one of #MSCAB_COMP_NONE, #MSCAB_COMP_MSZIP, #MSCAB_COMP_QUANTUM
 *         or #MSCAB_COMP_LZX
 */
#define MSCABD_COMP_METHOD(comp_type) ((comp_type) & 0x0F)
/**
 * Returns the compression level used by a folder.
 *
 * @param comp_type a mscabd_folder::comp_type value
 * @return the compression level. This is only defined by LZX and Quantum
 *         compression
 */
#define MSCABD_COMP_LEVEL(comp_type) (((comp_type) >> 8) & 0x1F)

/** Compression mode: no compression. */
#define MSCAB_COMP_NONE       (0)
/** Compression mode: MSZIP (deflate) compression. */
#define MSCAB_COMP_MSZIP      (1)
/** Compression mode: Quantum compression */
#define MSCAB_COMP_QUANTUM    (2)
/** Compression mode: LZX compression */
#define MSCAB_COMP_LZX        (3)

/**
 * A structure which represents a single file in a cabinet or cabinet set.
 *
 * All fields are READ ONLY.
 */
struct mscabd_file {
  /**
   * The next file in the cabinet or cabinet set, or NULL if this is the
   * final file.
   */
  struct mscabd_file *next;

  /**
   * The filename of the file.
   *
   * A null terminated string of up to 255 bytes in length, it may be in
   * either ISO-8859-1 or UTF8 format, depending on the file attributes.
   *
   * @see attribs
   */
  char *filename;

  /** The uncompressed length of the file, in bytes. */
  unsigned int length;

  /**
   * File attributes.
   *
   * The following attributes are defined:
   * - #MSCAB_ATTRIB_RDONLY indicates the file is write protected.
   * - #MSCAB_ATTRIB_HIDDEN indicates the file is hidden.
   * - #MSCAB_ATTRIB_SYSTEM indicates the file is a operating system file.
   * - #MSCAB_ATTRIB_ARCH indicates the file is "archived".
   * - #MSCAB_ATTRIB_EXEC indicates the file is an executable program.
   * - #MSCAB_ATTRIB_UTF_NAME indicates the filename is in UTF8 format rather
   *   than ISO-8859-1.
   */
  int attribs;

  /** File's last modified time, hour field. */
  char time_h;
  /** File's last modified time, minute field. */
  char time_m;
  /** File's last modified time, second field. */
  char time_s;

  /** File's last modified date, day field. */
  char date_d;
  /** File's last modified date, month field. */
  char date_m;
  /** File's last modified date, year field. */
  int date_y;

  /** A pointer to the folder that contains this file. */
  struct mscabd_folder *folder;

  /** The uncompressed offset of this file in its folder. */
  unsigned int offset;
};

/** mscabd_file::attribs attribute: file is read-only. */
#define MSCAB_ATTRIB_RDONLY   (0x01)
/** mscabd_file::attribs attribute: file is hidden. */
#define MSCAB_ATTRIB_HIDDEN   (0x02)
/** mscabd_file::attribs attribute: file is an operating system file. */
#define MSCAB_ATTRIB_SYSTEM   (0x04)
/** mscabd_file::attribs attribute: file is "archived". */
#define MSCAB_ATTRIB_ARCH     (0x20)
/** mscabd_file::attribs attribute: file is an executable program. */
#define MSCAB_ATTRIB_EXEC     (0x40)
/** mscabd_file::attribs attribute: filename is UTF8, not ISO-8859-1. */
#define MSCAB_ATTRIB_UTF_NAME (0x80)

/** mscab_decompressor::set_param() parameter: search buffer size. */
#define MSCABD_PARAM_SEARCHBUF (0)
/** mscab_decompressor::set_param() parameter: repair MS-ZIP streams? */
#define MSCABD_PARAM_FIXMSZIP  (1)
/** mscab_decompressor::set_param() parameter: size of decompression buffer */
#define MSCABD_PARAM_DECOMPBUF (2)
/** mscab_decompressor::set_param() parameter: salvage data from bad cabinets?
 * If enabled, open() will skip file with bad folder indices or filenames
 * rather than reject the whole cabinet, and extract() will limit rather than
 * reject files with invalid offsets and lengths, and bad data block checksums
 * will be ignored. Available only in CAB decoder version 2 and above.
 */
#define MSCABD_PARAM_SALVAGE   (3)

/** TODO */
struct mscab_compressor {
  int dummy; 
};

/**
 * A decompressor for .CAB (Microsoft Cabinet) files
 *
 * All fields are READ ONLY.
 *
 * @see mspack_create_cab_decompressor(), mspack_destroy_cab_decompressor()
 */
struct mscab_decompressor {
  /**
   * Opens a cabinet file and reads its contents.
   *
   * If the file opened is a valid cabinet file, all headers will be read
   * and a mscabd_cabinet structure will be returned, with a full list of
   * folders and files.
   *
   * In the case of an error occuring, NULL is returned and the error code
   * is available from last_error().
   *
   * The filename pointer should be considered "in use" until close() is
   * called on the cabinet.
   *
   * @param  self     a self-referential pointer to the mscab_decompressor
   *                  instance being called
   * @param  filename the filename of the cabinet file. This is passed
   *                  directly to mspack_system::open().
   * @return a pointer to a mscabd_cabinet structure, or NULL on failure
   * @see close(), search(), last_error()
   */
  struct mscabd_cabinet * (*open) (struct mscab_decompressor *self,
                                   const char *filename);

  /**
   * Closes a previously opened cabinet or cabinet set.
   *
   * This closes a cabinet, all cabinets associated with it via the
   * mscabd_cabinet::next, mscabd_cabinet::prevcab and
   * mscabd_cabinet::nextcab pointers, and all folders and files. All
   * memory used by these entities is freed.
   *
   * The cabinet pointer is now invalid and cannot be used again. All
   * mscabd_folder and mscabd_file pointers from that cabinet or cabinet
   * set are also now invalid, and cannot be used again.
   *
   * If the cabinet pointer given was created using search(), it MUST be
   * the cabinet pointer returned by search() and not one of the later
   * cabinet pointers further along the mscabd_cabinet::next chain.

   * If extra cabinets have been added using append() or prepend(), these
   * will all be freed, even if the cabinet pointer given is not the first
   * cabinet in the set. Do NOT close() more than one cabinet in the set.
   *
   * The mscabd_cabinet::filename is not freed by the library, as it is
   * not allocated by the library. The caller should free this itself if
   * necessary, before it is lost forever.
   *
   * @param  self     a self-referential pointer to the mscab_decompressor
   *                  instance being called
   * @param  cab      the cabinet to close
   * @see open(), search(), append(), prepend()
   */
  void (*close)(struct mscab_decompressor *self,
                struct mscabd_cabinet *cab);

  /**
   * Searches a regular file for embedded cabinets.
   *
   * This opens a normal file with the given filename and will search the
   * entire file for embedded cabinet files
   *
   * If any cabinets are found, the equivalent of open() is called on each
   * potential cabinet file at the offset it was found. All successfully
   * open()ed cabinets are kept in a list.
   *
   * The first cabinet found will be returned directly as the result of
   * this method. Any further cabinets found will be chained in a list
   * using the mscabd_cabinet::next field.
   *
   * In the case of an error occuring anywhere other than the simulated
   * open(), NULL is returned and the error code is available from
   * last_error().
   *
   * If no error occurs, but no cabinets can be found in the file, NULL is
   * returned and last_error() returns MSPACK_ERR_OK.
   *
   * The filename pointer should be considered in use until close() is
   * called on the cabinet.
   *
   * close() should only be called on the result of search(), not on any
   * subsequent cabinets in the mscabd_cabinet::next chain.
   *
   * @param  self     a self-referential pointer to the mscab_decompressor
   *                  instance being called
   * @param  filename the filename of the file to search for cabinets. This
   *                  is passed directly to mspack_system::open().
   * @return a pointer to a mscabd_cabinet structure, or NULL
   * @see close(), open(), last_error()
   */
  struct mscabd_cabinet * (*search) (struct mscab_decompressor *self,
                                     const char *filename);

  /**
   * Appends one mscabd_cabinet to another, forming or extending a cabinet
   * set.
   *
   * This will attempt to append one cabinet to another such that
   * <tt>(cab->nextcab == nextcab) && (nextcab->prevcab == cab)</tt> and
   * any folders split between the two cabinets are merged.
   *
   * The cabinets MUST be part of a cabinet set -- a cabinet set is a
   * cabinet that spans more than one physical cabinet file on disk -- and
   * must be appropriately matched.
   *
   * It can be determined if a cabinet has further parts to load by
   * examining the mscabd_cabinet::flags field:
   *
   * - if <tt>(flags & MSCAB_HDR_PREVCAB)</tt> is non-zero, there is a
   *   predecessor cabinet to open() and prepend(). Its MS-DOS
   *   case-insensitive filename is mscabd_cabinet::prevname
   * - if <tt>(flags & MSCAB_HDR_NEXTCAB)</tt> is non-zero, there is a
   *   successor cabinet to open() and append(). Its MS-DOS case-insensitive
   *   filename is mscabd_cabinet::nextname
   *
   * If the cabinets do not match, an error code will be returned. Neither
   * cabinet has been altered, and both should be closed seperately.
   *
   * Files and folders in a cabinet set are a single entity. All cabinets
   * in a set use the same file list, which is updated as cabinets in the
   * set are added. All pointers to mscabd_folder and mscabd_file
   * structures in either cabinet must be discarded and re-obtained after
   * merging.
   *
   * @param  self     a self-referential pointer to the mscab_decompressor
   *                  instance being called
   * @param  cab      the cabinet which will be appended to,
   *                  predecessor of nextcab
   * @param  nextcab  the cabinet which will be appended,
   *                  successor of cab
   * @return an error code, or MSPACK_ERR_OK if successful
   * @see prepend(), open(), close()
   */
  int (*append) (struct mscab_decompressor *self,
                 struct mscabd_cabinet *cab,
                 struct mscabd_cabinet *nextcab);

  /**
   * Prepends one mscabd_cabinet to another, forming or extending a
   * cabinet set.
   *
   * This will attempt to prepend one cabinet to another, such that
   * <tt>(cab->prevcab == prevcab) && (prevcab->nextcab == cab)</tt>. In
   * all other respects, it is identical to append(). See append() for the
   * full documentation.
   *
   * @param  self     a self-referential pointer to the mscab_decompressor
   *                  instance being called
   * @param  cab      the cabinet which will be prepended to,
   *                  successor of prevcab
   * @param  prevcab  the cabinet which will be prepended,
   *                  predecessor of cab
   * @return an error code, or MSPACK_ERR_OK if successful
   * @see append(), open(), close()
   */
  int (*prepend) (struct mscab_decompressor *self,
                  struct mscabd_cabinet *cab,
                  struct mscabd_cabinet *prevcab);

  /**
   * Extracts a file from a cabinet or cabinet set.
   *
   * This extracts a compressed file in a cabinet and writes it to the given
   * filename.
   *
   * The MS-DOS filename of the file, mscabd_file::filename, is NOT USED
   * by extract(). The caller must examine this MS-DOS filename, copy and
   * change it as necessary, create directories as necessary, and provide
   * the correct filename as a parameter, which will be passed unchanged
   * to the decompressor's mspack_system::open()
   *
   * If the file belongs to a split folder in a multi-part cabinet set,
   * and not enough parts of the cabinet set have been loaded and appended
   * or prepended, an error will be returned immediately.
   *
   * @param  self     a self-referential pointer to the mscab_decompressor
   *                  instance being called
   * @param  file     the file to be decompressed
   * @param  filename the filename of the file being written to
   * @return an error code, or MSPACK_ERR_OK if successful
   */
  int (*extract)(struct mscab_decompressor *self,
                 struct mscabd_file *file,
                 const char *filename);

  /**
   * Sets a CAB decompression engine parameter.
   *
   * The following parameters are defined:
   * - #MSCABD_PARAM_SEARCHBUF: How many bytes should be allocated as a
   *   buffer when using search()? The minimum value is 4.  The default
   *   value is 32768.
   * - #MSCABD_PARAM_FIXMSZIP: If non-zero, extract() will ignore bad
   *   checksums and recover from decompression errors in MS-ZIP
   *   compressed folders. The default value is 0 (don't recover).
   * - #MSCABD_PARAM_DECOMPBUF: How many bytes should be used as an input
   *   bit buffer by decompressors? The minimum value is 4. The default
   *   value is 4096.
   *
   * @param  self     a self-referential pointer to the mscab_decompressor
   *                  instance being called
   * @param  param    the parameter to set
   * @param  value    the value to set the parameter to
   * @return MSPACK_ERR_OK if all is OK, or MSPACK_ERR_ARGS if there
   *         is a problem with either parameter or value.
   * @see search(), extract()
   */
  int (*set_param)(struct mscab_decompressor *self,
                   int param,
                   int value);

  /**
   * Returns the error code set by the most recently called method.
   *
   * This is useful for open() and search(), which do not return an error
   * code directly.
   *
   * @param  self     a self-referential pointer to the mscab_decompressor
   *                  instance being called
   * @return the most recent error code
   * @see open(), search()
   */
  int (*last_error)(struct mscab_decompressor *self);
};

/* --- support for .CHM (HTMLHelp) file format ----------------------------- */

/**
 * A structure which represents a file to be placed in a CHM helpfile.
 *
 * A contiguous array of these structures should be passed to
 * mschm_compressor::generate(). The array list is terminated with an
 * entry whose mschmc_file::section field is set to #MSCHMC_ENDLIST, the
 * other fields in this entry are ignored.
 */
struct mschmc_file {
  /** One of #MSCHMC_ENDLIST, #MSCHMC_UNCOMP or #MSCHMC_MSCOMP. */
  int section;

  /** The filename of the source file that will be added to the CHM. This
   * is passed directly to mspack_system::open(). */
  const char *filename;

  /** The full path and filename of the file within the CHM helpfile, a
   * UTF-1 encoded null-terminated string. */
  char *chm_filename;

  /** The length of the file, in bytes. This will be adhered to strictly
   * and a read error will be issued if this many bytes cannot be read
   * from the real file at CHM generation time. */
  off_t length;
};

/**
 * A structure which represents a section of a CHM helpfile.
 *
 * All fields are READ ONLY.
 *
 * Not used directly, but used as a generic base type for
 * mschmd_sec_uncompressed and mschmd_sec_mscompressed.
 */
struct mschmd_section {
  /** A pointer to the CHM helpfile that contains this section. */
  struct mschmd_header *chm;

  /**
   * The section ID. Either 0 for the uncompressed section
   * mschmd_sec_uncompressed, or 1 for the LZX compressed section
   * mschmd_sec_mscompressed. No other section IDs are known.
   */
  unsigned int id;
};

/**
 * A structure which represents the uncompressed section of a CHM helpfile.
 * 
 * All fields are READ ONLY.
 */
struct mschmd_sec_uncompressed {
  /** Generic section data. */
  struct mschmd_section base;

  /** The file offset of where this section begins in the CHM helpfile. */
  off_t offset;
};

/**
 * A structure which represents the LZX compressed section of a CHM helpfile. 
 * 
 * All fields are READ ONLY.
 */
struct mschmd_sec_mscompressed {
  /** Generic section data. */
  struct mschmd_section base;

  /** A pointer to the meta-file which represents all LZX compressed data. */
  struct mschmd_file *content;

  /** A pointer to the file which contains the LZX control data. */
  struct mschmd_file *control;

  /** A pointer to the file which contains the LZX reset table. */
  struct mschmd_file *rtable;

  /** A pointer to the file which contains the LZX span information.
   * Available only in CHM decoder version 2 and above.
   */
  struct mschmd_file *spaninfo;
};

/**
 * A structure which represents a CHM helpfile.
 * 
 * All fields are READ ONLY.
 */
struct mschmd_header {
  /** The version of the CHM file format used in this file. */
  unsigned int version;

  /**
   * The "timestamp" of the CHM helpfile. 
   *
   * It is the lower 32 bits of a 64-bit value representing the number of
   * centiseconds since 1601-01-01 00:00:00 UTC, plus 42. It is not useful
   * as a timestamp, but it is useful as a semi-unique ID.
   */
  unsigned int timestamp;
      
  /**
   * The default Language and Country ID (LCID) of the user who ran the
   * HTMLHelp Compiler. This is not the language of the CHM file itself.
   */
  unsigned int language;

  /**
   * The filename of the CHM helpfile. This is given by the library user
   * and may be in any format.
   */
  const char *filename;

  /** The length of the CHM helpfile, in bytes. */
  off_t length;

  /** A list of all non-system files in the CHM helpfile. */
  struct mschmd_file *files;

  /**
   * A list of all system files in the CHM helpfile.
   *
   * System files are files which begin with "::". They are meta-files
   * generated by the CHM creation process.
   */
  struct mschmd_file *sysfiles;

  /** The section 0 (uncompressed) data in this CHM helpfile. */
  struct mschmd_sec_uncompressed sec0;

  /** The section 1 (MSCompressed) data in this CHM helpfile. */
  struct mschmd_sec_mscompressed sec1;

  /** The file offset of the first PMGL/PMGI directory chunk. */
  off_t dir_offset;

  /** The number of PMGL/PMGI directory chunks in this CHM helpfile. */
  unsigned int num_chunks;

  /** The size of each PMGL/PMGI chunk, in bytes. */
  unsigned int chunk_size;

  /** The "density" of the quick-reference section in PMGL/PMGI chunks. */
  unsigned int density;

  /** The depth of the index tree.
   *
   * - if 1, there are no PMGI chunks, only PMGL chunks.
   * - if 2, there is 1 PMGI chunk. All chunk indices point to PMGL chunks.
   * - if 3, the root PMGI chunk points to secondary PMGI chunks, which in
   *         turn point to PMGL chunks.
   * - and so on...
   */
  unsigned int depth;

  /**
   * The number of the root PMGI chunk.
   *
   * If there is no index in the CHM helpfile, this will be 0xFFFFFFFF.
   */
  unsigned int index_root;

  /**
   * The number of the first PMGL chunk. Usually zero.
   * Available only in CHM decoder version 2 and above.
   */
  unsigned int first_pmgl;

  /**
   * The number of the last PMGL chunk. Usually num_chunks-1.
   * Available only in CHM decoder version 2 and above.
   */
  unsigned int last_pmgl;

  /**
   * A cache of loaded chunks, filled in by mschm_decoder::fast_find().
   * Available only in CHM decoder version 2 and above.
   */
  unsigned char **chunk_cache;
};

/**
 * A structure which represents a file stored in a CHM helpfile.
 * 
 * All fields are READ ONLY.
 */
struct mschmd_file {
  /**
   * A pointer to the next file in the list, or NULL if this is the final
   * file.
   */
  struct mschmd_file *next;

  /**
   * A pointer to the section that this file is located in. Indirectly,
   * it also points to the CHM helpfile the file is located in.
   */
  struct mschmd_section *section;

  /** The offset within the section data that this file is located at. */
  off_t offset;

  /** The length of this file, in bytes */
  off_t length;

  /** The filename of this file -- a null terminated string in UTF-8. */
  char *filename;
};

/** mschmc_file::section value: end of CHM file list */
#define MSCHMC_ENDLIST   (0)
/** mschmc_file::section value: this file is in the Uncompressed section */
#define MSCHMC_UNCOMP    (1)
/** mschmc_file::section value: this file is in the MSCompressed section */
#define MSCHMC_MSCOMP    (2)
 
/** mschm_compressor::set_param() parameter: "timestamp" header */
#define MSCHMC_PARAM_TIMESTAMP  (0)
/** mschm_compressor::set_param() parameter: "language" header */
#define MSCHMC_PARAM_LANGUAGE   (1)
/** mschm_compressor::set_param() parameter: LZX window size */
#define MSCHMC_PARAM_LZXWINDOW  (2)
/** mschm_compressor::set_param() parameter: intra-chunk quickref density */
#define MSCHMC_PARAM_DENSITY    (3)
/** mschm_compressor::set_param() parameter: whether to create indices */
#define MSCHMC_PARAM_INDEX      (4)

/**
 * A compressor for .CHM (Microsoft HTMLHelp) files.
 *
 * All fields are READ ONLY.
 *
 * @see mspack_create_chm_compressor(), mspack_destroy_chm_compressor()
 */
struct mschm_compressor {
  /**
   * Generates a CHM help file.
   *
   * The help file will contain up to two sections, an Uncompressed
   * section and potentially an MSCompressed (LZX compressed)
   * section.
   *
   * While the contents listing of a CHM file is always in lexical order,
   * the file list passed in will be taken as the correct order for files
   * within the sections.  It is in your interest to place similar files
   * together for better compression.
   *
   * There are two modes of generation, to use a temporary file or not to
   * use one. See use_temporary_file() for the behaviour of generate() in
   * these two different modes.
   *
   * @param  self        a self-referential pointer to the mschm_compressor
   *                     instance being called
   * @param  file_list   an array of mschmc_file structures, terminated
   *                     with an entry whose mschmc_file::section field is
   *                     #MSCHMC_ENDLIST. The order of the list is
   *                     preserved within each section. The length of any
   *                     mschmc_file::chm_filename string cannot exceed
   *                     roughly 4096 bytes. Each source file must be able
   *                     to supply as many bytes as given in the
   *                     mschmc_file::length field.
   * @param  output_file the file to write the generated CHM helpfile to.
   *                     This is passed directly to mspack_system::open()
   * @return an error code, or MSPACK_ERR_OK if successful
   * @see use_temporary_file() set_param()
   */
  int (*generate)(struct mschm_compressor *self,
                  struct mschmc_file file_list[],
                  const char *output_file);

  /**
   * Specifies whether a temporary file is used during CHM generation.
   *
   * The CHM file format includes data about the compressed section (such
   * as its overall size) that is stored in the output CHM file prior to
   * the compressed section itself. This unavoidably requires that the
   * compressed section has to be generated, before these details can be
   * set. There are several ways this can be handled. Firstly, the
   * compressed section could be generated entirely in memory before
   * writing any of the output CHM file. This approach is not used in
   * libmspack, as the compressed section can exceed the addressable
   * memory space on most architectures.
   *
   * libmspack has two options, either to write these unknowable sections
   * with blank data, generate the compressed section, then re-open the
   * output file for update once the compressed section has been
   * completed, or to write the compressed section to a temporary file,
   * then write the entire output file at once, performing a simple
   * file-to-file copy for the compressed section.
   *
   * The simple solution of buffering the entire compressed section in
   * memory can still be used, if desired. As the temporary file's
   * filename is passed directly to mspack_system::open(), it is possible
   * for a custom mspack_system implementation to hold this file in memory,
   * without writing to a disk.
   *
   * If a temporary file is set, generate() performs the following
   * sequence of events: the temporary file is opened for writing, the
   * compression algorithm writes to the temporary file, the temporary
   * file is closed.  Then the output file is opened for writing and the
   * temporary file is re-opened for reading. The output file is written
   * and the temporary file is read from. Both files are then closed. The
   * temporary file itself is not deleted. If that is desired, the
   * temporary file should be deleted after the completion of generate(),
   * if it exists.
   *
   * If a temporary file is set not to be used, generate() performs the
   * following sequence of events: the output file is opened for writing,
   * then it is written and closed. The output file is then re-opened for
   * update, the appropriate sections are seek()ed to and re-written, then
   * the output file is closed.
   *
   * @param  self          a self-referential pointer to the
   *                       mschm_compressor instance being called
   * @param  use_temp_file non-zero if the temporary file should be used,
   *                       zero if the temporary file should not be used.
   * @param  temp_file     a file to temporarily write compressed data to,
   *                       before opening it for reading and copying the
   *                       contents to the output file. This is passed
   *                       directly to mspack_system::open().
   * @return an error code, or MSPACK_ERR_OK if successful
   * @see generate()
   */
  int (*use_temporary_file)(struct mschm_compressor *self,
                            int use_temp_file,
                            const char *temp_file);
  /**
   * Sets a CHM compression engine parameter.
   *
   * The following parameters are defined:

   * - #MSCHMC_PARAM_TIMESTAMP: Sets the "timestamp" of the CHM file
   *   generated. This is not a timestamp, see mschmd_header::timestamp
   *   for a description. If this timestamp is 0, generate() will use its
   *   own algorithm for making a unique ID, based on the lengths and
   *   names of files in the CHM itself. Defaults to 0, any value between
   *   0 and (2^32)-1 is valid.
   * - #MSCHMC_PARAM_LANGUAGE: Sets the "language" of the CHM file
   *   generated.  This is not the language used in the CHM file, but the
   *   language setting of the user who ran the HTMLHelp compiler. It
   *   defaults to 0x0409. The valid range is between 0x0000 and 0x7F7F.
   * - #MSCHMC_PARAM_LZXWINDOW: Sets the size of the LZX history window,
   *   which is also the interval at which the compressed data stream can be
   *   randomly accessed. The value is not a size in bytes, but a power of
   *   two. The default value is 16 (which makes the window 2^16 bytes, or
   *   64 kilobytes), the valid range is from 15 (32 kilobytes) to 21 (2
   *   megabytes).
   * - #MSCHMC_PARAM_DENSITY: Sets the "density" of quick reference
   *   entries stored at the end of directory listing chunk. Each chunk is
   *   4096 bytes in size, and contains as many file entries as there is
   *   room for. At the other end of the chunk, a list of "quick reference"
   *   pointers is included. The offset of every 'N'th file entry is given a
   *   quick reference, where N = (2^density) + 1. The default density is
   *   2. The smallest density is 0 (N=2), the maximum is 10 (N=1025). As
   *   each file entry requires at least 5 bytes, the maximum number of
   *   entries in a single chunk is roughly 800, so the maximum value 10
   *   can be used to indicate there are no quickrefs at all.
   * - #MSCHMC_PARAM_INDEX: Sets whether or not to include quick lookup
   *   index chunk(s), in addition to normal directory listing chunks. A
   *   value of zero means no index chunks will be created, a non-zero value
   *   means index chunks will be created. The default is zero, "don't
   *   create an index".
   *
   * @param  self     a self-referential pointer to the mschm_compressor
   *                  instance being called
   * @param  param    the parameter to set
   * @param  value    the value to set the parameter to
   * @return MSPACK_ERR_OK if all is OK, or MSPACK_ERR_ARGS if there
   *         is a problem with either parameter or value.
   * @see generate()
   */
  int (*set_param)(struct mschm_compressor *self,
                   int param,
                   unsigned int value);

  /**
   * Returns the error code set by the most recently called method.
   *
   * @param  self     a self-referential pointer to the mschm_compressor
   *                  instance being called
   * @return the most recent error code
   * @see set_param(), generate()
   */
  int (*last_error)(struct mschm_compressor *self);
};

/**
 * A decompressor for .CHM (Microsoft HTMLHelp) files
 *
 * All fields are READ ONLY.
 *
 * @see mspack_create_chm_decompressor(), mspack_destroy_chm_decompressor()
 */
struct mschm_decompressor {
  /**
   * Opens a CHM helpfile and reads its contents.
   *
   * If the file opened is a valid CHM helpfile, all headers will be read
   * and a mschmd_header structure will be returned, with a full list of
   * files.
   *
   * In the case of an error occuring, NULL is returned and the error code
   * is available from last_error().
   *
   * The filename pointer should be considered "in use" until close() is
   * called on the CHM helpfile.
   *
   * @param  self     a self-referential pointer to the mschm_decompressor
   *                  instance being called
   * @param  filename the filename of the CHM helpfile. This is passed
   *                  directly to mspack_system::open().
   * @return a pointer to a mschmd_header structure, or NULL on failure
   * @see close()
   */
  struct mschmd_header *(*open)(struct mschm_decompressor *self,
                                const char *filename);

  /**
   * Closes a previously opened CHM helpfile.
   *
   * This closes a CHM helpfile, frees the mschmd_header and all
   * mschmd_file structures associated with it (if any). This works on
   * both helpfiles opened with open() and helpfiles opened with
   * fast_open().
   *
   * The CHM header pointer is now invalid and cannot be used again. All
   * mschmd_file pointers referencing that CHM are also now invalid, and
   * cannot be used again.
   *
   * @param  self     a self-referential pointer to the mschm_decompressor
   *                  instance being called
   * @param  chm      the CHM helpfile to close
   * @see open(), fast_open()
   */
  void (*close)(struct mschm_decompressor *self,
                struct mschmd_header *chm);

  /**
   * Extracts a file from a CHM helpfile.
   *
   * This extracts a file from a CHM helpfile and writes it to the given
   * filename. The filename of the file, mscabd_file::filename, is not
   * used by extract(), but can be used by the caller as a guide for
   * constructing an appropriate filename.
   *
   * This method works both with files found in the mschmd_header::files
   * and mschmd_header::sysfiles list and mschmd_file structures generated
   * on the fly by fast_find().
   *
   * @param  self     a self-referential pointer to the mschm_decompressor
   *                  instance being called
   * @param  file     the file to be decompressed
   * @param  filename the filename of the file being written to
   * @return an error code, or MSPACK_ERR_OK if successful
   */
  int (*extract)(struct mschm_decompressor *self,
                 struct mschmd_file *file,
                 const char *filename);

  /**
   * Returns the error code set by the most recently called method.
   *
   * This is useful for open() and fast_open(), which do not return an
   * error code directly.
   *
   * @param  self     a self-referential pointer to the mschm_decompressor
   *                  instance being called
   * @return the most recent error code
   * @see open(), extract()
   */
  int (*last_error)(struct mschm_decompressor *self);

  /**
   * Opens a CHM helpfile quickly.
   *
   * If the file opened is a valid CHM helpfile, only essential headers
   * will be read. A mschmd_header structure will be still be returned, as
   * with open(), but the mschmd_header::files field will be NULL. No
   * files details will be automatically read.  The fast_find() method
   * must be used to obtain file details.
   *
   * In the case of an error occuring, NULL is returned and the error code
   * is available from last_error().
   *
   * The filename pointer should be considered "in use" until close() is
   * called on the CHM helpfile.
   *
   * @param  self     a self-referential pointer to the mschm_decompressor
   *                  instance being called
   * @param  filename the filename of the CHM helpfile. This is passed
   *                  directly to mspack_system::open().
   * @return a pointer to a mschmd_header structure, or NULL on failure
   * @see open(), close(), fast_find(), extract()
   */
  struct mschmd_header *(*fast_open)(struct mschm_decompressor *self,
                                     const char *filename);

  /**
   * Finds file details quickly.
   *
   * Instead of reading all CHM helpfile headers and building a list of
   * files, fast_open() and fast_find() are intended for finding file
   * details only when they are needed. The CHM file format includes an
   * on-disk file index to allow this.
   *
   * Given a case-sensitive filename, fast_find() will search the on-disk
   * index for that file.
   *
   * If the file was found, the caller-provided mschmd_file structure will
   * be filled out like so:
   * - section: the correct value for the found file
   * - offset: the correct value for the found file
   * - length: the correct value for the found file
   * - all other structure elements: NULL or 0
   *
   * If the file was not found, MSPACK_ERR_OK will still be returned as the
   * result, but the caller-provided structure will be filled out like so:
   * - section: NULL
   * - offset: 0
   * - length: 0
   * - all other structure elements: NULL or 0
   *
   * This method is intended to be used in conjunction with CHM helpfiles
   * opened with fast_open(), but it also works with helpfiles opened
   * using the regular open().
   *
   * @param  self     a self-referential pointer to the mschm_decompressor
   *                  instance being called
   * @param  chm      the CHM helpfile to search for the file
   * @param  filename the filename of the file to search for
   * @param  f_ptr    a pointer to a caller-provded mschmd_file structure
   * @param  f_size   <tt>sizeof(struct mschmd_file)</tt>
   * @return an error code, or MSPACK_ERR_OK if successful
   * @see open(), close(), fast_find(), extract()
   */
  int (*fast_find)(struct mschm_decompressor *self,
                   struct mschmd_header *chm,
                   const char *filename,
                   struct mschmd_file *f_ptr,
                   int f_size);
};

/* --- support for .LIT (EBook) file format -------------------------------- */

/** TODO */
struct mslit_compressor {
  int dummy; 
};

/** TODO */
struct mslit_decompressor {
  int dummy; 
};


/* --- support for .HLP (MS Help) file format ------------------------------ */

/** TODO */
struct mshlp_compressor {
  int dummy; 
};

/** TODO */
struct mshlp_decompressor {
  int dummy; 
};


/* --- support for SZDD file format ---------------------------------------- */

/** msszdd_compressor::set_param() parameter: the missing character */
#define MSSZDDC_PARAM_MISSINGCHAR (0)

/** msszddd_header::format value - a regular SZDD file */
#define MSSZDD_FMT_NORMAL (0)

/** msszddd_header::format value - a special QBasic SZDD file */
#define MSSZDD_FMT_QBASIC (1)

/**
 * A structure which represents an SZDD compressed file.
 *
 * All fields are READ ONLY.
 */
struct msszddd_header {
  /** The file format; either #MSSZDD_FMT_NORMAL or #MSSZDD_FMT_QBASIC */
  int format;

  /** The amount of data in the SZDD file once uncompressed. */
  off_t length;

  /**
   * The last character in the filename, traditionally replaced with an
   * underscore to show the file is compressed. The null character is used
   * to show that this character has not been stored (e.g. because the
   * filename is not known). Generally, only characters that may appear in
   * an MS-DOS filename (except ".") are valid.
   */
  char missing_char;
};

/**
 * A compressor for the SZDD file format.
 *
 * All fields are READ ONLY.
 *
 * @see mspack_create_szdd_compressor(), mspack_destroy_szdd_compressor()
 */
struct msszdd_compressor {
  /**
   * Reads an input file and creates a compressed output file in the
   * SZDD compressed file format. The SZDD compression format is quick
   * but gives poor compression. It is possible for the compressed output
   * file to be larger than the input file.
   *
   * Conventionally, SZDD compressed files have the final character in
   * their filename replaced with an underscore, to show they are
   * compressed.  The missing character is stored in the compressed file
   * itself. This is due to the restricted filename conventions of MS-DOS,
   * most operating systems, such as UNIX, simply append another file
   * extension to the existing filename. As mspack does not deal with
   * filenames, this is left up to you. If you wish to set the missing
   * character stored in the file header, use set_param() with the
   * #MSSZDDC_PARAM_MISSINGCHAR parameter.
   *
   * "Stream" compression (where the length of the input data is not
   * known) is not possible. The length of the input data is stored in the
   * header of the SZDD file and must therefore be known before any data
   * is compressed. Due to technical limitations of the file format, the
   * maximum size of uncompressed file that will be accepted is 2147483647
   * bytes.
   *
   * @param  self    a self-referential pointer to the msszdd_compressor
   *                 instance being called
   * @param  input   the name of the file to compressed. This is passed
   *                 passed directly to mspack_system::open()
   * @param  output  the name of the file to write compressed data to.
   *                 This is passed directly to mspack_system::open().
   * @param  length  the length of the uncompressed file, or -1 to indicate
   *                 that this should be determined automatically by using
   *                 mspack_system::seek() on the input file.
   * @return an error code, or MSPACK_ERR_OK if successful
   * @see set_param()
   */
  int (*compress)(struct msszdd_compressor *self,
                  const char *input,
                  const char *output,
                  off_t length);

  /**
   * Sets an SZDD compression engine parameter.
   *
   * The following parameters are defined:

   * - #MSSZDDC_PARAM_CHARACTER: the "missing character", the last character
   *   in the uncompressed file's filename, which is traditionally replaced
   *   with an underscore to show the file is compressed. Traditionally,
   *   this can only be a character that is a valid part of an MS-DOS,
   *   filename, but libmspack permits any character between 0x00 and 0xFF
   *   to be stored. 0x00 is the default, and it represents "no character
   *   stored".
   *
   * @param  self     a self-referential pointer to the msszdd_compressor
   *                  instance being called
   * @param  param    the parameter to set
   * @param  value    the value to set the parameter to
   * @return MSPACK_ERR_OK if all is OK, or MSPACK_ERR_ARGS if there
   *         is a problem with either parameter or value.
   * @see compress()
   */
  int (*set_param)(struct msszdd_compressor *self,
                   int param,
                   unsigned int value);

  /**
   * Returns the error code set by the most recently called method.
   *
   * @param  self     a self-referential pointer to the msszdd_compressor
   *                  instance being called
   * @return the most recent error code
   * @see compress()
   */
  int (*last_error)(struct mschm_decompressor *self);
};

/**
 * A decompressor for SZDD compressed files.
 *
 * All fields are READ ONLY.
 *
 * @see mspack_create_szdd_decompressor(), mspack_destroy_szdd_decompressor()
 */
struct msszdd_decompressor {
  /**
   * Opens a SZDD file and reads the header.
   *
   * If the file opened is a valid SZDD file, all headers will be read and
   * a msszddd_header structure will be returned.
   *
   * In the case of an error occuring, NULL is returned and the error code
   * is available from last_error().
   *
   * The filename pointer should be considered "in use" until close() is
   * called on the SZDD file.
   *
   * @param  self     a self-referential pointer to the msszdd_decompressor
   *                  instance being called
   * @param  filename the filename of the SZDD compressed file. This is
   *                  passed directly to mspack_system::open().
   * @return a pointer to a msszddd_header structure, or NULL on failure
   * @see close()
   */
  struct msszddd_header *(*open)(struct msszdd_decompressor *self,
                                 const char *filename);

  /**
   * Closes a previously opened SZDD file.
   *
   * This closes a SZDD file and frees the msszddd_header associated with
   * it.
   *
   * The SZDD header pointer is now invalid and cannot be used again.
   *
   * @param  self     a self-referential pointer to the msszdd_decompressor
   *                  instance being called
   * @param  szdd     the SZDD file to close
   * @see open()
   */
  void (*close)(struct msszdd_decompressor *self,
                struct msszddd_header *szdd);

  /**
   * Extracts the compressed data from a SZDD file.
   *
   * This decompresses the compressed SZDD data stream and writes it to
   * an output file.
   *
   * @param  self     a self-referential pointer to the msszdd_decompressor
   *                  instance being called
   * @param  szdd     the SZDD file to extract data from
   * @param  filename the filename to write the decompressed data to. This
   *                  is passed directly to mspack_system::open().
   * @return an error code, or MSPACK_ERR_OK if successful
   */
  int (*extract)(struct msszdd_decompressor *self,
                 struct msszddd_header *szdd,
                 const char *filename);

  /**
   * Decompresses an SZDD file to an output file in one step.
   *
   * This opens an SZDD file as input, reads the header, then decompresses
   * the compressed data immediately to an output file, finally closing
   * both the input and output file. It is more convenient to use than
   * open() then extract() then close(), if you do not need to know the
   * SZDD output size or missing character.
   *
   * @param  self     a self-referential pointer to the msszdd_decompressor
   *                  instance being called
   * @param  input    the filename of the input SZDD file. This is passed
   *                  directly to mspack_system::open().
   * @param  output   the filename to write the decompressed data to. This
   *                  is passed directly to mspack_system::open().
   * @return an error code, or MSPACK_ERR_OK if successful
   */
  int (*decompress)(struct msszdd_decompressor *self,
                    const char *input,
                    const char *output);

  /**
   * Returns the error code set by the most recently called method.
   *
   * This is useful for open() which does not return an
   * error code directly.
   *
   * @param  self     a self-referential pointer to the msszdd_decompressor
   *                  instance being called
   * @return the most recent error code
   * @see open(), extract(), decompress()
   */
  int (*last_error)(struct msszdd_decompressor *self);
};

/* --- support for KWAJ file format ---------------------------------------- */

/** mskwaj_compressor::set_param() parameter: compression type */
#define MSKWAJC_PARAM_COMP_TYPE  (0)

/** mskwaj_compressor::set_param() parameter: include the length of the
 * uncompressed file in the header?
 */
#define MSKWAJC_PARAM_INCLUDE_LENGTH (1)

/** KWAJ compression type: no compression. */
#define MSKWAJ_COMP_NONE (0)
/** KWAJ compression type: no compression, 0xFF XOR "encryption". */
#define MSKWAJ_COMP_XOR (1)
/** KWAJ compression type: LZSS (same method as SZDD) */
#define MSKWAJ_COMP_SZDD (2)
/** KWAJ compression type: LZ+Huffman compression */
#define MSKWAJ_COMP_LZH (3)
/** KWAJ compression type: MSZIP */
#define MSKWAJ_COMP_MSZIP (4)

/** KWAJ optional header flag: decompressed file length is included */
#define MSKWAJ_HDR_HASLENGTH (0x01)

/** KWAJ optional header flag: unknown 2-byte structure is included */
#define MSKWAJ_HDR_HASUNKNOWN1 (0x02)

/** KWAJ optional header flag: unknown multi-sized structure is included */
#define MSKWAJ_HDR_HASUNKNOWN2 (0x04)

/** KWAJ optional header flag: file name (no extension) is included */
#define MSKWAJ_HDR_HASFILENAME (0x08)

/** KWAJ optional header flag: file extension is included */
#define MSKWAJ_HDR_HASFILEEXT (0x10)

/** KWAJ optional header flag: extra text is included */
#define MSKWAJ_HDR_HASEXTRATEXT (0x20)

/**
 * A structure which represents an KWAJ compressed file.
 *
 * All fields are READ ONLY.
 */
struct mskwajd_header {
  /** The compression type; should be one of #MSKWAJ_COMP_NONE,
   * #MSKWAJ_COMP_XOR, #MSKWAJ_COMP_SZDD or #MSKWAJ_COMP_LZH
   */
  unsigned short comp_type;

  /** The offset in the file where the compressed data stream begins */
  off_t data_offset;

  /** Flags indicating which optional headers were included. */
  int headers;

  /** The amount of uncompressed data in the file, or 0 if not present. */
  off_t length;

  /** output filename, or NULL if not present */
  char *filename;

  /** extra uncompressed data (usually text) in the header.
   * This data can contain nulls so use extra_length to get the size.
   */
  char *extra;

  /** length of extra uncompressed data in the header */
  unsigned short extra_length;
};

/**
 * A compressor for the KWAJ file format.
 *
 * All fields are READ ONLY.
 *
 * @see mspack_create_kwaj_compressor(), mspack_destroy_kwaj_compressor()
 */
struct mskwaj_compressor {
  /**
   * Reads an input file and creates a compressed output file in the
   * KWAJ compressed file format. The KWAJ compression format is quick
   * but gives poor compression. It is possible for the compressed output
   * file to be larger than the input file.
   *
   * @param  self    a self-referential pointer to the mskwaj_compressor
   *                 instance being called
   * @param  input   the name of the file to compressed. This is passed
   *                 passed directly to mspack_system::open()
   * @param  output  the name of the file to write compressed data to.
   *                 This is passed directly to mspack_system::open().
   * @param  length  the length of the uncompressed file, or -1 to indicate
   *                 that this should be determined automatically by using
   *                 mspack_system::seek() on the input file.
   * @return an error code, or MSPACK_ERR_OK if successful
   * @see set_param()
   */
  int (*compress)(struct mskwaj_compressor *self,
                  const char *input,
                  const char *output,
                  off_t length);

  /**
   * Sets an KWAJ compression engine parameter.
   *
   * The following parameters are defined:
   *
   * - #MSKWAJC_PARAM_COMP_TYPE: the compression method to use. Must
   *   be one of #MSKWAJC_COMP_NONE, #MSKWAJC_COMP_XOR, #MSKWAJ_COMP_SZDD
   *   or #MSKWAJ_COMP_LZH. The default is #MSKWAJ_COMP_LZH.
   *
   * - #MSKWAJC_PARAM_INCLUDE_LENGTH: a boolean; should the compressed
   *   output file should include the uncompressed length of the input
   *   file in the header? This adds 4 bytes to the size of the output
   *   file. A value of zero says "no", non-zero says "yes". The default
   *   is "no".
   *
   * @param  self     a self-referential pointer to the mskwaj_compressor
   *                  instance being called
   * @param  param    the parameter to set
   * @param  value    the value to set the parameter to
   * @return MSPACK_ERR_OK if all is OK, or MSPACK_ERR_ARGS if there
   *         is a problem with either parameter or value.
   * @see generate()
   */
  int (*set_param)(struct mskwaj_compressor *self,
                   int param,
                   unsigned int value);


  /**
   * Sets the original filename of the file before compression,
   * which will be stored in the header of the output file.
   *
   * The filename should be a null-terminated string, it must be an
   * MS-DOS "8.3" type filename (up to 8 bytes for the filename, then
   * optionally a "." and up to 3 bytes for a filename extension).
   *
   * If NULL is passed as the filename, no filename is included in the
   * header. This is the default.
   *
   * @param  self     a self-referential pointer to the mskwaj_compressor
   *                  instance being called
   * @param  filename the original filename to use
   * @return MSPACK_ERR_OK if all is OK, or MSPACK_ERR_ARGS if the
   *         filename is too long
   */
  int (*set_filename)(struct mskwaj_compressor *self,
                      const char *filename);

  /**
   * Sets arbitrary data that will be stored in the header of the
   * output file, uncompressed. It can be up to roughly 64 kilobytes,
   * as the overall size of the header must not exceed 65535 bytes.
   * The data can contain null bytes if desired.
   *
   * If NULL is passed as the data pointer, or zero is passed as the
   * length, no extra data is included in the header. This is the
   * default.
   *
   * @param  self     a self-referential pointer to the mskwaj_compressor
   *                  instance being called
   * @param  data     a pointer to the data to be stored in the header
   * @param  bytes    the length of the data in bytes
   * @return MSPACK_ERR_OK if all is OK, or MSPACK_ERR_ARGS extra data
   *         is too long
   */
  int (*set_extra_data)(struct mskwaj_compressor *self,
                        void *data,
                        size_t bytes);

  /**
   * Returns the error code set by the most recently called method.
   *
   * @param  self     a self-referential pointer to the mskwaj_compressor
   *                  instance being called
   * @return the most recent error code
   * @see compress()
   */
  int (*last_error)(struct mschm_decompressor *self);
};

/**
 * A decompressor for KWAJ compressed files.
 *
 * All fields are READ ONLY.
 *
 * @see mspack_create_kwaj_decompressor(), mspack_destroy_kwaj_decompressor()
 */
struct mskwaj_decompressor {
  /**
   * Opens a KWAJ file and reads the header.
   *
   * If the file opened is a valid KWAJ file, all headers will be read and
   * a mskwajd_header structure will be returned.
   *
   * In the case of an error occuring, NULL is returned and the error code
   * is available from last_error().
   *
   * The filename pointer should be considered "in use" until close() is
   * called on the KWAJ file.
   *
   * @param  self     a self-referential pointer to the mskwaj_decompressor
   *                  instance being called
   * @param  filename the filename of the KWAJ compressed file. This is
   *                  passed directly to mspack_system::open().
   * @return a pointer to a mskwajd_header structure, or NULL on failure
   * @see close()
   */
  struct mskwajd_header *(*open)(struct mskwaj_decompressor *self,
                                 const char *filename);

  /**
   * Closes a previously opened KWAJ file.
   *
   * This closes a KWAJ file and frees the mskwajd_header associated
   * with it. The KWAJ header pointer is now invalid and cannot be
   * used again.
   *
   * @param  self     a self-referential pointer to the mskwaj_decompressor
   *                  instance being called
   * @param  kwaj     the KWAJ file to close
   * @see open()
   */
  void (*close)(struct mskwaj_decompressor *self,
                struct mskwajd_header *kwaj);

  /**
   * Extracts the compressed data from a KWAJ file.
   *
   * This decompresses the compressed KWAJ data stream and writes it to
   * an output file.
   *
   * @param  self     a self-referential pointer to the mskwaj_decompressor
   *                  instance being called
   * @param  kwaj     the KWAJ file to extract data from
   * @param  filename the filename to write the decompressed data to. This
   *                  is passed directly to mspack_system::open().
   * @return an error code, or MSPACK_ERR_OK if successful
   */
  int (*extract)(struct mskwaj_decompressor *self,
                 struct mskwajd_header *kwaj,
                 const char *filename);

  /**
   * Decompresses an KWAJ file to an output file in one step.
   *
   * This opens an KWAJ file as input, reads the header, then decompresses
   * the compressed data immediately to an output file, finally closing
   * both the input and output file. It is more convenient to use than
   * open() then extract() then close(), if you do not need to know the
   * KWAJ output size or output filename.
   *
   * @param  self     a self-referential pointer to the mskwaj_decompressor
   *                  instance being called
   * @param  input    the filename of the input KWAJ file. This is passed
   *                  directly to mspack_system::open().
   * @param  output   the filename to write the decompressed data to. This
   *                  is passed directly to mspack_system::open().
   * @return an error code, or MSPACK_ERR_OK if successful
   */
  int (*decompress)(struct mskwaj_decompressor *self,
                    const char *input,
                    const char *output);

  /**
   * Returns the error code set by the most recently called method.
   *
   * This is useful for open() which does not return an
   * error code directly.
   *
   * @param  self     a self-referential pointer to the mskwaj_decompressor
   *                  instance being called
   * @return the most recent error code
   * @see open(), search()
   */
  int (*last_error)(struct mskwaj_decompressor *self);
};

/* --- support for .LZX (Offline Address Book) file format ----------------- */

/**
 * A compressor for the Offline Address Book (OAB) format.
 *
 * All fields are READ ONLY.
 *
 * @see mspack_create_oab_compressor(), mspack_destroy_oab_compressor()
 */
struct msoab_compressor {
  /**
   * Compress a full OAB file.
   *
   * The input file will be read and the compressed contents written to the
   * output file.
   *
   * @param  self     a self-referential pointer to the msoab_decompressor
   *                  instance being called
   * @param  input    the filename of the input file. This is passed
   *                  directly to mspack_system::open().
   * @param  output   the filename of the output file. This is passed
   *                  directly to mspack_system::open().
   * @return an error code, or MSPACK_ERR_OK if successful
   */
  int (*compress) (struct msoab_compressor *self,
                   const char *input,
                   const char *output);

  /**
   * Generate a compressed incremental OAB patch file.
   *
   * The two uncompressed files "input" and "base" will be read, and an
   * incremental patch to generate "input" from "base" will be written to
   * the output file.
   *
   * @param  self     a self-referential pointer to the msoab_compressor
   *                  instance being called
   * @param  input    the filename of the input file containing the new
   *                  version of its contents. This is passed directly
   *                  to mspack_system::open().
   * @param  base     the filename of the original base file containing
   *                  the old version of its contents, against which the
   *                  incremental patch shall generated. This is passed
   *                  directly to mspack_system::open().
   * @param  output   the filename of the output file. This is passed
   *                  directly to mspack_system::open().
   * @return an error code, or MSPACK_ERR_OK if successful
   */
  int (*compress_incremental) (struct msoab_compressor *self,
                               const char *input,
                               const char *base,
                               const char *output);
};

/**
 * A decompressor for .LZX (Offline Address Book) files
 *
 * All fields are READ ONLY.
 *
 * @see mspack_create_oab_decompressor(), mspack_destroy_oab_decompressor()
 */
struct msoab_decompressor {
  /**
   * Decompresses a full Offline Address Book file.
   *
   * If the input file is a valid compressed Offline Address Book file, 
   * it will be read and the decompressed contents will be written to
   * the output file.
   *
   * @param  self     a self-referential pointer to the msoab_decompressor
   *                  instance being called
   * @param  input    the filename of the input file. This is passed
   *                  directly to mspack_system::open().
   * @param  output   the filename of the output file. This is passed
   *                  directly to mspack_system::open().
   * @return an error code, or MSPACK_ERR_OK if successful
   */
  int (*decompress) (struct msoab_decompressor *self,
                     const char *input,
                     const char *output);

  /**
   * Decompresses an Offline Address Book with an incremental patch file.
   *
   * This requires both a full UNCOMPRESSED Offline Address Book file to
   * act as the "base", and a compressed incremental patch file as input.
   * If the input file is valid, it will be decompressed with reference to
   * the base file, and the decompressed contents will be written to the
   * output file.
   *
   * There is no way to tell what the right base file is for the given
   * incremental patch, but if you get it wrong, this will usually result
   * in incorrect data being decompressed, which will then fail a checksum
   * test.
   *
   * @param  self     a self-referential pointer to the msoab_decompressor
   *                  instance being called
   * @param  input    the filename of the input file. This is passed
   *                  directly to mspack_system::open().
   * @param  base     the filename of the base file to which the
   *                  incremental patch shall be applied. This is passed
   *                  directly to mspack_system::open().
   * @param  output   the filename of the output file. This is passed
   *                  directly to mspack_system::open().
   * @return an error code, or MSPACK_ERR_OK if successful
   */
  int (*decompress_incremental) (struct msoab_decompressor *self,
                                 const char *input,
                                 const char *base,
                                 const char *output);
};

#ifdef __cplusplus
}
#endif

#endif

```

`3rdparty/mspack/readbits.h`:

```h
/* This file is part of libmspack.
 * (C) 2003-2010 Stuart Caie.
 *
 * libmspack is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License (LGPL) version 2.1
 *
 * For further details, see the file COPYING.LIB distributed with libmspack
 */

#ifndef MSPACK_READBITS_H
#define MSPACK_READBITS_H 1

/* this header defines macros that read data streams by
 * the individual bits
 *
 * INIT_BITS         initialises bitstream state in state structure
 * STORE_BITS        stores bitstream state in state structure
 * RESTORE_BITS      restores bitstream state from state structure
 * ENSURE_BITS(n)    ensure there are at least N bits in the bit buffer
 * READ_BITS(var,n)  takes N bits from the buffer and puts them in var
 * PEEK_BITS(n)      extracts without removing N bits from the bit buffer
 * REMOVE_BITS(n)    removes N bits from the bit buffer
 *
 * READ_BITS simply calls ENSURE_BITS, PEEK_BITS and REMOVE_BITS,
 * which means it's limited to reading the number of bits you can
 * ensure at any one time. It also fails if asked to read zero bits.
 * If you need to read zero bits, or more bits than can be ensured in
 * one go, use READ_MANY_BITS instead.
 *
 * These macros have variable names baked into them, so to use them
 * you have to define some macros:
 * - BITS_TYPE: the type name of your state structure
 * - BITS_VAR: the variable that points to your state structure
 * - define BITS_ORDER_MSB if bits are read from the MSB, or
 *   define BITS_ORDER_LSB if bits are read from the LSB
 * - READ_BYTES: some code that reads more data into the bit buffer,
 *   it should use READ_IF_NEEDED (calls read_input if the byte buffer
 *   is empty), then INJECT_BITS(data,n) to put data from the byte
 *   buffer into the bit buffer.
 *
 * You also need to define some variables and structure members:
 * - unsigned char *i_ptr;    // current position in the byte buffer
 * - unsigned char *i_end;    // end of the byte buffer
 * - unsigned int bit_buffer; // the bit buffer itself
 * - unsigned int bits_left;  // number of bits remaining
 *
 * If you use read_input() and READ_IF_NEEDED, they also expect these
 * structure members:
 * - struct mspack_system *sys;  // to access sys->read()
 * - unsigned int error;         // to record/return read errors
 * - unsigned char input_end;    // to mark reaching the EOF
 * - unsigned char *inbuf;       // the input byte buffer
 * - unsigned int inbuf_size;    // the size of the input byte buffer
 *
 * Your READ_BYTES implementation should read data from *i_ptr and
 * put them in the bit buffer. READ_IF_NEEDED will call read_input()
 * if i_ptr reaches i_end, and will fill up inbuf and set i_ptr to
 * the start of inbuf and i_end to the end of inbuf.
 *
 * If you're reading in MSB order, the routines work by using the area
 * beyond the MSB and the LSB of the bit buffer as a free source of
 * zeroes when shifting. This avoids having to mask any bits. So we
 * have to know the bit width of the bit buffer variable. We use
 * <limits.h> and CHAR_BIT to find the size of the bit buffer in bits.
 *
 * If you are reading in LSB order, bits need to be masked. Normally
 * this is done by computing the mask: N bits are masked by the value
 * (1<<N)-1). However, you can define BITS_LSB_TABLE to use a lookup
 * table instead of computing this. This adds two new macros,
 * PEEK_BITS_T and READ_BITS_T which work the same way as PEEK_BITS
 * and READ_BITS, except they use this lookup table. This is useful if
 * you need to look up a number of bits that are only known at
 * runtime, so the bit mask can't be turned into a constant by the
 * compiler.

 * The bit buffer datatype should be at least 32 bits wide: it must be
 * possible to ENSURE_BITS(17), so it must be possible to add 16 new bits
 * to the bit buffer when the bit buffer already has 1 to 15 bits left.
 */

#ifndef BITS_VAR
# error "define BITS_VAR as the state structure poiner variable name"
#endif
#ifndef BITS_TYPE
# error "define BITS_TYPE as the state structure type"
#endif
#if defined(BITS_ORDER_MSB) && defined(BITS_ORDER_LSB)
# error "you must define either BITS_ORDER_MSB or BITS_ORDER_LSB"
#else
# if !(defined(BITS_ORDER_MSB) || defined(BITS_ORDER_LSB))
#  error "you must define BITS_ORDER_MSB or BITS_ORDER_LSB"
# endif
#endif

#if HAVE_LIMITS_H
# include <limits.h>
#endif
#ifndef CHAR_BIT
# define CHAR_BIT (8)
#endif
#define BITBUF_WIDTH (sizeof(bit_buffer) * CHAR_BIT)

#define INIT_BITS do {                          \
    BITS_VAR->i_ptr      = &BITS_VAR->inbuf[0]; \
    BITS_VAR->i_end      = &BITS_VAR->inbuf[0]; \
    BITS_VAR->bit_buffer = 0;                   \
    BITS_VAR->bits_left  = 0;                   \
    BITS_VAR->input_end  = 0;                   \
} while (0)

#define STORE_BITS do {                 \
    BITS_VAR->i_ptr      = i_ptr;       \
    BITS_VAR->i_end      = i_end;       \
    BITS_VAR->bit_buffer = bit_buffer;  \
    BITS_VAR->bits_left  = bits_left;   \
} while (0)

#define RESTORE_BITS do {               \
    i_ptr      = BITS_VAR->i_ptr;       \
    i_end      = BITS_VAR->i_end;       \
    bit_buffer = BITS_VAR->bit_buffer;  \
    bits_left  = BITS_VAR->bits_left;   \
} while (0)

#define ENSURE_BITS(nbits) do {                 \
    while (bits_left < (nbits)) READ_BYTES;     \
} while (0)

#define READ_BITS(val, nbits) do {              \
    ENSURE_BITS(nbits);                         \
    (val) = PEEK_BITS(nbits);                   \
    REMOVE_BITS(nbits);                         \
} while (0)

#define READ_MANY_BITS(val, bits) do {                          \
    unsigned char needed = (bits), bitrun;                      \
    (val) = 0;                                                  \
    while (needed > 0) {                                        \
        if (bits_left <= (BITBUF_WIDTH - 16)) READ_BYTES;       \
        bitrun = (bits_left < needed) ? bits_left : needed;     \
        (val) = ((val) << bitrun) | PEEK_BITS(bitrun);          \
        REMOVE_BITS(bitrun);                                    \
        needed -= bitrun;                                       \
    }                                                           \
} while (0)

#ifdef BITS_ORDER_MSB
# define PEEK_BITS(nbits)   (bit_buffer >> (BITBUF_WIDTH - (nbits)))
# define REMOVE_BITS(nbits) ((bit_buffer <<= (nbits)), (bits_left -= (nbits)))
# define INJECT_BITS(bitdata,nbits) ((bit_buffer |= \
    (bitdata) << (BITBUF_WIDTH - (nbits) - bits_left)), (bits_left += (nbits)))
#else /* BITS_ORDER_LSB */
# define PEEK_BITS(nbits)   (bit_buffer & ((1 << (nbits))-1))
# define REMOVE_BITS(nbits) ((bit_buffer >>= (nbits)), (bits_left -= (nbits)))
# define INJECT_BITS(bitdata,nbits) ((bit_buffer |= \
    (bitdata) << bits_left), (bits_left += (nbits)))
#endif

#ifdef BITS_LSB_TABLE
/* lsb_bit_mask[n] = (1 << n) - 1 */
static const unsigned short lsb_bit_mask[17] = {
    0x0000, 0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff,
    0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff
};
# define PEEK_BITS_T(nbits) (bit_buffer & lsb_bit_mask[(nbits)])
# define READ_BITS_T(val, nbits) do {   \
    ENSURE_BITS(nbits);                 \
    (val) = PEEK_BITS_T(nbits);         \
    REMOVE_BITS(nbits);                 \
} while (0)
#endif

#ifndef BITS_NO_READ_INPUT
# define READ_IF_NEEDED do {            \
    if (i_ptr >= i_end) {               \
        if (read_input(BITS_VAR))       \
            return BITS_VAR->error;     \
        i_ptr = BITS_VAR->i_ptr;        \
        i_end = BITS_VAR->i_end;        \
    }                                   \
} while (0)

static int read_input(BITS_TYPE *p) {
    int read = p->sys->read(p->input, &p->inbuf[0], (int)p->inbuf_size);
    if (read < 0) return p->error = MSPACK_ERR_READ;

    /* we might overrun the input stream by asking for bits we don't use,
     * so fake 2 more bytes at the end of input */
    if (read == 0) {
        if (p->input_end) {
            D(("out of input bytes"))
            return p->error = MSPACK_ERR_READ;
        }
        else {
            read = 2;
            p->inbuf[0] = p->inbuf[1] = 0;
            p->input_end = 1;
        }
    }

    /* update i_ptr and i_end */
    p->i_ptr = &p->inbuf[0];
    p->i_end = &p->inbuf[read];
    return MSPACK_ERR_OK;
}
#endif
#endif

```

`3rdparty/mspack/readhuff.h`:

```h
/* This file is part of libmspack.
 * (C) 2003-2014 Stuart Caie.
 *
 * libmspack is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License (LGPL) version 2.1
 *
 * For further details, see the file COPYING.LIB distributed with libmspack
 */

#ifndef MSPACK_READHUFF_H
#define MSPACK_READHUFF_H 1

/* This implements a fast Huffman tree decoding system. */

#if !(defined(BITS_ORDER_MSB) || defined(BITS_ORDER_LSB))
# error "readhuff.h is used in conjunction with readbits.h, include that first"
#endif
#if !(defined(TABLEBITS) && defined(MAXSYMBOLS))
# error "define TABLEBITS(tbl) and MAXSYMBOLS(tbl) before using readhuff.h"
#endif
#if !(defined(HUFF_TABLE) && defined(HUFF_LEN))
# error "define HUFF_TABLE(tbl) and HUFF_LEN(tbl) before using readhuff.h"
#endif
#ifndef HUFF_ERROR
# error "define HUFF_ERROR before using readhuff.h"
#endif
#ifndef HUFF_MAXBITS
# define HUFF_MAXBITS 16
#endif

/* Decodes the next huffman symbol from the input bitstream into var.
 * Do not use this macro on a table unless build_decode_table() succeeded.
 */
#define READ_HUFFSYM(tbl, var) do {                     \
    ENSURE_BITS(HUFF_MAXBITS);                          \
    sym = HUFF_TABLE(tbl, PEEK_BITS(TABLEBITS(tbl)));   \
    if (sym >= MAXSYMBOLS(tbl)) HUFF_TRAVERSE(tbl);     \
    (var) = sym;                                        \
    i = HUFF_LEN(tbl, sym);                             \
    REMOVE_BITS(i);                                     \
} while (0)

#ifdef BITS_ORDER_LSB
# define HUFF_TRAVERSE(tbl) do {                        \
    i = TABLEBITS(tbl) - 1;                             \
    do {                                                \
        if (i++ > HUFF_MAXBITS) HUFF_ERROR;             \
        sym = HUFF_TABLE(tbl,                           \
            (sym << 1) | ((bit_buffer >> i) & 1));      \
    } while (sym >= MAXSYMBOLS(tbl));                   \
} while (0)
#else
#define HUFF_TRAVERSE(tbl) do {                         \
    i = 1 << (BITBUF_WIDTH - TABLEBITS(tbl));           \
    do {                                                \
        if ((i >>= 1) == 0) HUFF_ERROR;                 \
        sym = HUFF_TABLE(tbl,                           \
            (sym << 1) | ((bit_buffer & i) ? 1 : 0));   \
    } while (sym >= MAXSYMBOLS(tbl));                   \
} while (0)
#endif

/* make_decode_table(nsyms, nbits, length[], table[])
 *
 * This function was originally coded by David Tritscher.
 * It builds a fast huffman decoding table from
 * a canonical huffman code lengths table.
 *
 * nsyms  = total number of symbols in this huffman tree.
 * nbits  = any symbols with a code length of nbits or less can be decoded
 *          in one lookup of the table.
 * length = A table to get code lengths from [0 to nsyms-1]
 * table  = The table to fill up with decoded symbols and pointers.
 *          Should be ((1<<nbits) + (nsyms*2)) in length.
 *
 * Returns 0 for OK or 1 for error
 */
static int make_decode_table(unsigned int nsyms, unsigned int nbits,
                             unsigned char *length, unsigned short *table)
{
    register unsigned short sym, next_symbol;
    register unsigned int leaf, fill;
#ifdef BITS_ORDER_LSB
    register unsigned int reverse;
#endif
    register unsigned char bit_num;
    unsigned int pos         = 0; /* the current position in the decode table */
    unsigned int table_mask  = 1 << nbits;
    unsigned int bit_mask    = table_mask >> 1; /* don't do 0 length codes */

    /* fill entries for codes short enough for a direct mapping */
    for (bit_num = 1; bit_num <= nbits; bit_num++) {
        for (sym = 0; sym < nsyms; sym++) {
            if (length[sym] != bit_num) continue;
#ifdef BITS_ORDER_MSB
            leaf = pos;
#else
            /* reverse the significant bits */
            fill = length[sym]; reverse = pos >> (nbits - fill); leaf = 0;
            do {leaf <<= 1; leaf |= reverse & 1; reverse >>= 1;} while (--fill);
#endif

            if((pos += bit_mask) > table_mask) return 1; /* table overrun */

            /* fill all possible lookups of this symbol with the symbol itself */
#ifdef BITS_ORDER_MSB
            for (fill = bit_mask; fill-- > 0;) table[leaf++] = sym;
#else
            fill = bit_mask; next_symbol = 1 << bit_num;
            do { table[leaf] = sym; leaf += next_symbol; } while (--fill);
#endif
        }
        bit_mask >>= 1;
    }

    /* exit with success if table is now complete */
    if (pos == table_mask) return 0;

    /* mark all remaining table entries as unused */
    for (sym = pos; sym < table_mask; sym++) {
#ifdef BITS_ORDER_MSB
        table[sym] = 0xFFFF;
#else
        reverse = sym; leaf = 0; fill = nbits;
        do { leaf <<= 1; leaf |= reverse & 1; reverse >>= 1; } while (--fill);
        table[leaf] = 0xFFFF;
#endif
    }

    /* next_symbol = base of allocation for long codes */
    next_symbol = ((table_mask >> 1) < nsyms) ? nsyms : (table_mask >> 1);

    /* give ourselves room for codes to grow by up to 16 more bits.
     * codes now start at bit nbits+16 and end at (nbits+16-codelength) */
    pos <<= 16;
    table_mask <<= 16;
    bit_mask = 1 << 15;

    for (bit_num = nbits+1; bit_num <= HUFF_MAXBITS; bit_num++) {
        for (sym = 0; sym < nsyms; sym++) {
            if (length[sym] != bit_num) continue;
            if (pos >= table_mask) return 1; /* table overflow */

#ifdef BITS_ORDER_MSB
            leaf = pos >> 16;
#else
            /* leaf = the first nbits of the code, reversed */
            reverse = pos >> 16; leaf = 0; fill = nbits;
            do {leaf <<= 1; leaf |= reverse & 1; reverse >>= 1;} while (--fill);
#endif
            for (fill = 0; fill < (bit_num - nbits); fill++) {
                /* if this path hasn't been taken yet, 'allocate' two entries */
                if (table[leaf] == 0xFFFF) {
                    table[(next_symbol << 1)     ] = 0xFFFF;
                    table[(next_symbol << 1) + 1 ] = 0xFFFF;
                    table[leaf] = next_symbol++;
                }

                /* follow the path and select either left or right for next bit */
                leaf = table[leaf] << 1;
                if ((pos >> (15-fill)) & 1) leaf++;
            }
            table[leaf] = sym;
            pos += bit_mask;
        }
        bit_mask >>= 1;
    }

    /* full table? */
    return (pos == table_mask) ? 0 : 1;
}
#endif

```

`3rdparty/mspack/system.c`:

```c
/* This file is part of libmspack.
 * (C) 2003-2004 Stuart Caie.
 *
 * libmspack is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License (LGPL) version 2.1
 *
 * For further details, see the file COPYING.LIB distributed with libmspack
 */

#ifdef HAVE_CONFIG_H
# include <config.h>
#endif

#include "system.h"

#if !LARGEFILE_SUPPORT
const char *largefile_msg = "library not compiled to support large files.";
#endif


int mspack_version(int entity) {
  switch (entity) {
   /* CHM decoder version 1 -> 2 changes:
    * - added mschmd_sec_mscompressed::spaninfo
    * - added mschmd_header::first_pmgl
    * - added mschmd_header::last_pmgl
    * - added mschmd_header::chunk_cache;
    */
  case MSPACK_VER_MSCHMD:
  /* CAB decoder version 1 -> 2 changes:
   * - added MSCABD_PARAM_SALVAGE
   */
  case MSPACK_VER_MSCABD:
    return 2;
  case MSPACK_VER_LIBRARY:
  case MSPACK_VER_SYSTEM:
  case MSPACK_VER_MSSZDDD:
  case MSPACK_VER_MSKWAJD:
  case MSPACK_VER_MSOABD:
    return 1;
  case MSPACK_VER_MSCABC:
  case MSPACK_VER_MSCHMC:
  case MSPACK_VER_MSLITD:
  case MSPACK_VER_MSLITC:
  case MSPACK_VER_MSHLPD:
  case MSPACK_VER_MSHLPC:
  case MSPACK_VER_MSSZDDC:
  case MSPACK_VER_MSKWAJC:
  case MSPACK_VER_MSOABC:
    return 0;
  }
  return -1;
}

int mspack_sys_selftest_internal(int offt_size) {
  return (sizeof(off_t) == offt_size) ? MSPACK_ERR_OK : MSPACK_ERR_SEEK;
}

/* validates a system structure */
int mspack_valid_system(struct mspack_system *sys) {
  return (sys != NULL) && (sys->open != NULL) && (sys->close != NULL) &&
    (sys->read != NULL) && (sys->write != NULL) && (sys->seek != NULL) &&
    (sys->tell != NULL) && (sys->message != NULL) && (sys->alloc != NULL) &&
    (sys->free != NULL) && (sys->copy != NULL) && (sys->null_ptr == NULL);
}

/* returns the length of a file opened for reading */
int mspack_sys_filelen(struct mspack_system *system,
                       struct mspack_file *file, off_t *length)
{
  off_t current;

  if (!system || !file || !length) return MSPACK_ERR_OPEN;

  /* get current offset */
  current = system->tell(file);

  /* seek to end of file */
  if (system->seek(file, (off_t) 0, MSPACK_SYS_SEEK_END)) {
    return MSPACK_ERR_SEEK;
  }

  /* get offset of end of file */
  *length = system->tell(file);

  /* seek back to original offset */
  if (system->seek(file, current, MSPACK_SYS_SEEK_START)) {
    return MSPACK_ERR_SEEK;
  }

  return MSPACK_ERR_OK;
}



/* definition of mspack_default_system -- if the library is compiled with
 * MSPACK_NO_DEFAULT_SYSTEM, no default system will be provided. Otherwise,
 * an appropriate default system (e.g. the standard C library, or some native
 * API calls)
 */

#ifdef MSPACK_NO_DEFAULT_SYSTEM
struct mspack_system *mspack_default_system = NULL;
#else

/* implementation of mspack_default_system for standard C library */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

struct mspack_file_p {
  FILE *fh;
  const char *name;
};

static struct mspack_file *msp_open(struct mspack_system *self,
                                    const char *filename, int mode)
{
  struct mspack_file_p *fh;
  const char *fmode;

  switch (mode) {
  case MSPACK_SYS_OPEN_READ:   fmode = "rb";  break;
  case MSPACK_SYS_OPEN_WRITE:  fmode = "wb";  break;
  case MSPACK_SYS_OPEN_UPDATE: fmode = "r+b"; break;
  case MSPACK_SYS_OPEN_APPEND: fmode = "ab";  break;
  default: return NULL;
  }

  if ((fh = (struct mspack_file_p *) malloc(sizeof(struct mspack_file_p)))) {
    fh->name = filename;
    if ((fh->fh = fopen(filename, fmode))) return (struct mspack_file *) fh;
    free(fh);
  }
  return NULL;
}

static void msp_close(struct mspack_file *file) {
  struct mspack_file_p *self = (struct mspack_file_p *) file;
  if (self) {
    fclose(self->fh);
    free(self);
  }
}

static int msp_read(struct mspack_file *file, void *buffer, int bytes) {
  struct mspack_file_p *self = (struct mspack_file_p *) file;
  if (self && buffer && bytes >= 0) {
    size_t count = fread(buffer, 1, (size_t) bytes, self->fh);
    if (!ferror(self->fh)) return (int) count;
  }
  return -1;
}

static int msp_write(struct mspack_file *file, void *buffer, int bytes) {
  struct mspack_file_p *self = (struct mspack_file_p *) file;
  if (self && buffer && bytes >= 0) {
    size_t count = fwrite(buffer, 1, (size_t) bytes, self->fh);
    if (!ferror(self->fh)) return (int) count;
  }
  return -1;
}

static int msp_seek(struct mspack_file *file, off_t offset, int mode) {
  struct mspack_file_p *self = (struct mspack_file_p *) file;
  if (self) {
    switch (mode) {
    case MSPACK_SYS_SEEK_START: mode = SEEK_SET; break;
    case MSPACK_SYS_SEEK_CUR:   mode = SEEK_CUR; break;
    case MSPACK_SYS_SEEK_END:   mode = SEEK_END; break;
    default: return -1;
    }
#if HAVE_FSEEKO
    return fseeko(self->fh, offset, mode);
#else
    return fseek(self->fh, offset, mode);
#endif
  }
  return -1;
}

static off_t msp_tell(struct mspack_file *file) {
  struct mspack_file_p *self = (struct mspack_file_p *) file;
#if HAVE_FSEEKO
  return (self) ? (off_t) ftello(self->fh) : 0;
#else
  return (self) ? (off_t) ftell(self->fh) : 0;
#endif
}

static void msp_msg(struct mspack_file *file, const char *format, ...) {
  va_list ap;
  if (file) fprintf(stderr, "%s: ", ((struct mspack_file_p *) file)->name);
  va_start(ap, format);
  vfprintf(stderr, format, ap);
  va_end(ap);
  fputc((int) '\n', stderr);
  fflush(stderr);
}

static void *msp_alloc(struct mspack_system *self, size_t bytes) {
#if DEBUG
  /* make uninitialised data obvious */
  char *buf = malloc(bytes + 8);
  if (buf) memset(buf, 0xDC, bytes);
  *((size_t *)buf) = bytes;
  return &buf[8];
#else
  return malloc(bytes);
#endif
}

static void msp_free(void *buffer) {
#if DEBUG
  char *buf = buffer;
  size_t bytes;
  if (buf) {
    buf -= 8;
    bytes = *((size_t *)buf);
    /* make freed data obvious */
    memset(buf, 0xED, bytes);
    free(buf);
  }
#else
  free(buffer);
#endif
}

static void msp_copy(void *src, void *dest, size_t bytes) {
  memcpy(dest, src, bytes);
}

static struct mspack_system msp_system = {
  &msp_open, &msp_close, &msp_read,  &msp_write, &msp_seek,
  &msp_tell, &msp_msg, &msp_alloc, &msp_free, &msp_copy, NULL
};

struct mspack_system *mspack_default_system = &msp_system;

#endif

```

`3rdparty/mspack/system.h`:

```h
/* This file is part of libmspack.
 * (C) 2003-2018 Stuart Caie.
 *
 * libmspack is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License (LGPL) version 2.1
 *
 * For further details, see the file COPYING.LIB distributed with libmspack
 */

#ifndef MSPACK_SYSTEM_H
#define MSPACK_SYSTEM_H 1

#ifdef __cplusplus
extern "C" {
#endif

/* ensure config.h is read before mspack.h */
#ifdef HAVE_CONFIG_H
# include <config.h>
#endif

#include "mspack.h"

/* assume <string.h> exists */
#include <string.h>

/* fix for problem with GCC 4 and glibc (thanks to Ville Skytta)
 * http://bugzilla.redhat.com/bugzilla/show_bug.cgi?id=150429
 */
#ifdef read
# undef read
#endif

/* Old GCCs don't have __func__, but __FUNCTION__:
 * http://gcc.gnu.org/onlinedocs/gcc/Function-Names.html
 */
#if __STDC_VERSION__ < 199901L
# if __GNUC__ >= 2
#  define __func__ __FUNCTION__
# else
#  define __func__ "<unknown>"
# endif
#endif

#if DEBUG
# include <stdio.h>
# define D(x) do { printf("%s:%d (%s) ",__FILE__, __LINE__, __func__); \
                   printf x ; fputc('\n', stdout); fflush(stdout);} while (0);
#else
# define D(x)
#endif

/* CAB supports searching through files over 4GB in size, and the CHM file
 * format actively uses 64-bit offsets. These can only be fully supported
 * if the system the code runs on supports large files. If not, the library
 * will work as normal using only 32-bit arithmetic, but if an offset
 * greater than 2GB is detected, an error message indicating the library
 * can't support the file should be printed.
 */
#if HAVE_INTTYPES_H
# include <inttypes.h>
#else
# define PRId64 "lld"
# define PRIu64 "llu"
# define PRId32 "ld"
# define PRIu32 "lu"
#endif

#include <limits.h>
#if ((defined(_FILE_OFFSET_BITS) && _FILE_OFFSET_BITS >= 64) || \
     (defined(FILESIZEBITS)      && FILESIZEBITS      >= 64) || \
     defined(_LARGEFILE_SOURCE) || defined(_LARGEFILE64_SOURCE) || \
     SIZEOF_OFF_T >= 8)
# define LARGEFILE_SUPPORT 1
# define LD PRId64
# define LU PRIu64
#else
extern const char *largefile_msg;
# define LD PRId32
# define LU PRIu32
#endif

/* endian-neutral reading of little-endian data */
#define __egi32(a,n) ( ((((unsigned char *) a)[n+3]) << 24) | \
                       ((((unsigned char *) a)[n+2]) << 16) | \
                       ((((unsigned char *) a)[n+1]) <<  8) | \
                       ((((unsigned char *) a)[n+0])))
#define EndGetI64(a) ((((unsigned long long int) __egi32(a,4)) << 32) | \
                      ((unsigned int) __egi32(a,0)))
#define EndGetI32(a) __egi32(a,0)
#define EndGetI16(a) ((((a)[1])<<8)|((a)[0]))

/* endian-neutral reading of big-endian data */
#define EndGetM32(a) (((((unsigned char *) a)[0]) << 24) | \
                      ((((unsigned char *) a)[1]) << 16) | \
                      ((((unsigned char *) a)[2]) <<  8) | \
                      ((((unsigned char *) a)[3])))
#define EndGetM16(a) ((((a)[0])<<8)|((a)[1]))

extern struct mspack_system *mspack_default_system;

/* returns the length of a file opened for reading */
extern int mspack_sys_filelen(struct mspack_system *system,
                              struct mspack_file *file, off_t *length);

/* validates a system structure */
extern int mspack_valid_system(struct mspack_system *sys);

#ifdef __cplusplus
}
#endif

#endif

```

`3rdparty/xtlid/SOURCE.md`:

```md
xtlid.xml from https://github.com/XboxDev/xtlid/blob/4c76295326efd4fa16c3298635909c9767c180f2/src/xtlid.xml

```

`3rdparty/xtlid/result.cpp`:

```cpp
// Function mappings for D3DX8
std::unordered_map<uint32_t, std::string> functions_D3DX8 = {
  { 0x90001, "D3DXBoxBoundProbe" },
  { 0x90002, "D3DXCheckCubeTextureRequirements" },
  { 0x90003, "D3DXCheckTextureRequirements" },
  { 0x90004, "D3DXCheckVolumeTextureRequirements" },
  { 0x90005, "D3DXCleanMesh" },
  { 0x90006, "D3DXColorAdd" },
  { 0x90007, "D3DXColorAdjustContrast" },
  { 0x90008, "D3DXColorAdjustSaturation" },
  { 0x90009, "D3DXColorLerp" },
  { 0x9000a, "D3DXColorModulate" },
  { 0x9000b, "D3DXColorNegative" },
  { 0x9000c, "D3DXColorScale" },
  { 0x9000d, "D3DXColorSubtract" },
  { 0x9000e, "D3DXCompileEffect" },
  { 0x9000f, "D3DXCompileEffectFromFileA" },
  { 0x90010, "D3DXComputeBoundingBox" },
  { 0x90011, "D3DXComputeBoundingSphere" },
  { 0x90012, "D3DXComputeNormals" },
  { 0x90013, "D3DXCreateBox" },
  { 0x90014, "D3DXCreateBuffer" },
  { 0x90015, "D3DXCreateCubeTexture" },
  { 0x90016, "D3DXCreateCubeTextureFromFileA" },
  { 0x90017, "D3DXCreateCubeTextureFromFileExA" },
  { 0x90018, "D3DXCreateCubeTextureFromFileInMemory" },
  { 0x90019, "D3DXCreateCubeTextureFromFileInMemoryEx" },
  { 0x9001a, "D3DXCreateCylinder" },
  { 0x9001b, "D3DXCreateEffect" },
  { 0x9001c, "D3DXCreateMatrixStack" },
  { 0x9001d, "D3DXCreateMesh" },
  { 0x9001e, "D3DXCreateMeshFVF" },
  { 0x9001f, "D3DXCreatePMeshFromStream" },
  { 0x90020, "D3DXCreatePolygon" },
  { 0x90021, "D3DXCreateSkinMesh" },
  { 0x90022, "D3DXCreateSkinMeshFromMesh" },
  { 0x90023, "D3DXCreateSkinMeshFVF" },
  { 0x90024, "D3DXCreateSphere" },
  { 0x90025, "D3DXCreateSPMesh" },
  { 0x90026, "D3DXCreateTeapot" },
  { 0x90027, "D3DXCreateTexture" },
  { 0x90028, "D3DXCreateTextureFromFileA" },
  { 0x90029, "D3DXCreateTextureFromFileExA" },
  { 0x9002a, "D3DXCreateTextureFromFileInMemory" },
  { 0x9002b, "D3DXCreateTextureFromFileInMemoryEx" },
  { 0x9002c, "D3DXCreateTorus" },
  { 0x9002d, "D3DXCreateVolumeTexture" },
  { 0x9002e, "D3DXDeclaratorFromFVF" },
  { 0x9002f, "D3DXFilterCubeTexture" },
  { 0x90030, "D3DXFilterTexture" },
  { 0x90031, "D3DXFilterVolumeTexture" },
  { 0x90032, "D3DXFVFFromDeclarator" },
  { 0x90033, "D3DXGeneratePMesh" },
  { 0x90034, "D3DXGetDXT3DXT5" },
  { 0x90035, "D3DXIntersect" },
  { 0x90036, "D3DXLoadMeshFromX" },
  { 0x90037, "D3DXLoadMeshFromXof" },
  { 0x90038, "D3DXLoadSkinMeshFromXof" },
  { 0x90039, "D3DXLoadSurfaceFromFileA" },
  { 0x9003a, "D3DXLoadSurfaceFromFileInMemory" },
  { 0x9003b, "D3DXLoadSurfaceFromMemory" },
  { 0x9003c, "D3DXLoadSurfaceFromSurface" },
  { 0x9003d, "D3DXLoadVolumeFromMemory" },
  { 0x9003e, "D3DXLoadVolumeFromVolume" },
  { 0x9003f, "D3DXMatrixAffineTransformation" },
  { 0x90040, "D3DXMatrixfDeterminant" },
  { 0x90041, "D3DXMatrixIdentity" },
  { 0x90042, "D3DXMatrixInverse" },
  { 0x90043, "D3DXMatrixIsIdentity" },
  { 0x90044, "D3DXMatrixLookAtLH" },
  { 0x90045, "D3DXMatrixLookAtRH" },
  { 0x90046, "D3DXMatrixMultiply" },
  { 0x90047, "D3DXMatrixOrthoLH" },
  { 0x90048, "D3DXMatrixOrthoOffCenterLH" },
  { 0x90049, "D3DXMatrixOrthoOffCenterRH" },
  { 0x9004a, "D3DXMatrixOrthoRH" },
  { 0x9004b, "D3DXMatrixPerspectiveFovLH" },
  { 0x9004c, "D3DXMatrixPerspectiveFovRH" },
  { 0x9004d, "D3DXMatrixPerspectiveLH" },
  { 0x9004e, "D3DXMatrixPerspectiveOffCenterLH" },
  { 0x9004f, "D3DXMatrixPerspectiveOffCenterRH" },
  { 0x90050, "D3DXMatrixPerspectiveRH" },
  { 0x90051, "D3DXMatrixReflect" },
  { 0x90052, "D3DXMatrixRotationAxis" },
  { 0x90053, "D3DXMatrixRotationQuaternion" },
  { 0x90054, "D3DXMatrixRotationX" },
  { 0x90055, "D3DXMatrixRotationY" },
  { 0x90056, "D3DXMatrixRotationYawPitchRoll" },
  { 0x90057, "D3DXMatrixRotationZ" },
  { 0x90058, "D3DXMatrixScaling" },
  { 0x90059, "D3DXMatrixShadow" },
  { 0x9005a, "D3DXMatrixTransformation" },
  { 0x9005b, "D3DXMatrixTranslation" },
  { 0x9005c, "D3DXMatrixTranspose" },
  { 0x9005d, "D3DXPlaneDot" },
  { 0x9005e, "D3DXPlaneDotCoord" },
  { 0x9005f, "D3DXPlaneDotNormal" },
  { 0x90060, "D3DXPlaneFromPointNormal" },
  { 0x90061, "D3DXPlaneFromPoints" },
  { 0x90062, "D3DXPlaneIntersectLine" },
  { 0x90063, "D3DXPlaneNormalize" },
  { 0x90064, "D3DXPlaneTransform" },
  { 0x90065, "D3DXQuaternionBaryCentric" },
  { 0x90066, "D3DXQuaternionConjugate" },
  { 0x90067, "D3DXQuaternionDot" },
  { 0x90068, "D3DXQuaternionExp" },
  { 0x90069, "D3DXQuaternionIdentity" },
  { 0x9006a, "D3DXQuaternionInverse" },
  { 0x9006b, "D3DXQuaternionIsIdentity" },
  { 0x9006c, "D3DXQuaternionLength" },
  { 0x9006d, "D3DXQuaternionLengthSq" },
  { 0x9006e, "D3DXQuaternionLn" },
  { 0x9006f, "D3DXQuaternionMultiply" },
  { 0x90070, "D3DXQuaternionNormalize" },
  { 0x90071, "D3DXQuaternionRotationAxis" },
  { 0x90072, "D3DXQuaternionRotationMatrix" },
  { 0x90073, "D3DXQuaternionRotationYawPitchRoll" },
  { 0x90074, "D3DXQuaternionSlerp" },
  { 0x90075, "D3DXQuaternionSquad" },
  { 0x90076, "D3DXQuaternionToAxisAngle" },
  { 0x90077, "D3DXSaveMeshToX" },
  { 0x90078, "D3DXSetDXT3DXT5" },
  { 0x90079, "D3DXSimplifyMesh" },
  { 0x9007a, "D3DXSphereBoundProbe" },
  { 0x9007b, "D3DXTesselateMesh" },
  { 0x9007c, "D3DXValidMesh" },
  { 0x9007d, "D3DXVec2Add" },
  { 0x9007e, "D3DXVec2BaryCentric" },
  { 0x9007f, "D3DXVec2CatmullRom" },
  { 0x90080, "D3DXVec2CCW" },
  { 0x90081, "D3DXVec2Dot" },
  { 0x90082, "D3DXVec2Hermite" },
  { 0x90083, "D3DXVec2Length" },
  { 0x90084, "D3DXVec2LengthSq" },
  { 0x90085, "D3DXVec2Lerp" },
  { 0x90086, "D3DXVec2Maximize" },
  { 0x90087, "D3DXVec2Minimize" },
  { 0x90088, "D3DXVec2Normalize" },
  { 0x90089, "D3DXVec2Scale" },
  { 0x9008a, "D3DXVec2Subtract" },
  { 0x9008b, "D3DXVec2Transform" },
  { 0x9008c, "D3DXVec2TransformCoord" },
  { 0x9008d, "D3DXVec2TransformNormal" },
  { 0x9008e, "D3DXVec3Add" },
  { 0x9008f, "D3DXVec3BaryCentric" },
  { 0x90090, "D3DXVec3CatmullRom" },
  { 0x90091, "D3DXVec3Cross" },
  { 0x90092, "D3DXVec3Dot" },
  { 0x90093, "D3DXVec3Hermite" },
  { 0x90094, "D3DXVec3Length" },
  { 0x90095, "D3DXVec3LengthSq" },
  { 0x90096, "D3DXVec3Lerp" },
  { 0x90097, "D3DXVec3Maximize" },
  { 0x90098, "D3DXVec3Minimize" },
  { 0x90099, "D3DXVec3Normalize" },
  { 0x9009a, "D3DXVec3Project" },
  { 0x9009b, "D3DXVec3Scale" },
  { 0x9009c, "D3DXVec3Subtract" },
  { 0x9009d, "D3DXVec3Transform" },
  { 0x9009e, "D3DXVec3TransformCoord" },
  { 0x9009f, "D3DXVec3TransformNormal" },
  { 0x900a0, "D3DXVec3Unproject" },
  { 0x900a1, "D3DXVec4Add" },
  { 0x900a2, "D3DXVec4BaryCentric" },
  { 0x900a3, "D3DXVec4CatmullRom" },
  { 0x900a4, "D3DXVec4Cross" },
  { 0x900a5, "D3DXVec4Dot" },
  { 0x900a6, "D3DXVec4Hermite" },
  { 0x900a7, "D3DXVec4Length" },
  { 0x900a8, "D3DXVec4LengthSq" },
  { 0x900a9, "D3DXVec4Lerp" },
  { 0x900aa, "D3DXVec4Maximize" },
  { 0x900ab, "D3DXVec4Minimize" },
  { 0x900ac, "D3DXVec4Normalize" },
  { 0x900ad, "D3DXVec4Scale" },
  { 0x900ae, "D3DXVec4Subtract" },
  { 0x900af, "D3DXVec4Transform" },
  { 0x900b0, "D3DXWeldVertices" }
};

// Function mappings for DMUSIC
std::unordered_map<uint32_t, std::string> functions_DMUSIC = {
  { 0xa0001, "DirectMusicAlloc" },
  { 0xa0002, "DirectMusicCreateDefaultHeap" },
  { 0xa0003, "DirectMusicCreateDefaultPhysicalHeap" },
  { 0xa0004, "DirectMusicCreateFixedSizeHeap" },
  { 0xa0005, "DirectMusicCreateFixedSizePhysicalHeap" },
  { 0xa0006, "DirectMusicCreateInstance" },
  { 0xa0007, "DirectMusicDefaultFactory" },
  { 0xa0008, "DirectMusicDoWork" },
  { 0xa0009, "DirectMusicFree" },
  { 0xa000a, "DirectMusicInitialize" },
  { 0xa000b, "DirectMusicInitializeEx" },
  { 0xa000c, "DirectMusicInitializeFixedSizeHeaps" },
  { 0xa000d, "DirectMusicMemCheck" },
  { 0xa000e, "DirectMusicMemDump" },
  { 0xa000f, "DirectMusicPhysicalAlloc" },
  { 0xa0010, "DirectMusicPhysicalFree" },
  { 0xa0011, "DirectMusicSetDebugLevel" }
};

// Function mappings for DSOUND
std::unordered_map<uint32_t, std::string> functions_DSOUND = {
  { 0xb0001, "Ac97CreateMediaObject" },
  { 0xb0002, "DirectSoundCreate" },
  { 0xb0003, "DirectSoundCreateBuffer" },
  { 0xb0004, "DirectSoundCreateStream" },
  { 0xb0005, "DirectSoundDefaulMixBins_5Channel3D_PlusLFE" },
  { 0xb0006, "DirectSoundDefault3DBuffer" },
  { 0xb0007, "DirectSoundDefault3DListener" },
  { 0xb0008, "DirectSoundDefaultI3DL2Buffer" },
  { 0xb0009, "DirectSoundDefaultMixBins_3D" },
  { 0xb000a, "DirectSoundDefaultMixBins_4Channel" },
  { 0xb000b, "DirectSoundDefaultMixBins_5Channel3D" },
  { 0xb000c, "DirectSoundDefaultMixBins_6Channel" },
  { 0xb000d, "DirectSoundDefaultMixBins_Mono" },
  { 0xb000e, "DirectSoundDefaultMixBins_Stereo" },
  { 0xb000f, "DirectSoundDoWork" },
  { 0xb0010, "DirectSoundDumpMemoryUsage" },
  { 0xb0011, "DirectSoundGetSampleTime" },
  { 0xb0012, "DirectSoundI3DL2ListenerPreset_Alley" },
  { 0xb0013, "DirectSoundI3DL2ListenerPreset_Arena" },
  { 0xb0014, "DirectSoundI3DL2ListenerPreset_Auditorium" },
  { 0xb0015, "DirectSoundI3DL2ListenerPreset_Bathroom" },
  { 0xb0016, "DirectSoundI3DL2ListenerPreset_CarpetedHallway" },
  { 0xb0017, "DirectSoundI3DL2ListenerPreset_Cave" },
  { 0xb0018, "DirectSoundI3DL2ListenerPreset_City" },
  { 0xb0019, "DirectSoundI3DL2ListenerPreset_ConcertHall" },
  { 0xb001a, "DirectSoundI3DL2ListenerPreset_Default" },
  { 0xb001b, "DirectSoundI3DL2ListenerPreset_Default2" },
  { 0xb001c, "DirectSoundI3DL2ListenerPreset_Forest" },
  { 0xb001d, "DirectSoundI3DL2ListenerPreset_Generic" },
  { 0xb001e, "DirectSoundI3DL2ListenerPreset_Hallway" },
  { 0xb001f, "DirectSoundI3DL2ListenerPreset_Hangar" },
  { 0xb0020, "DirectSoundI3DL2ListenerPreset_LivingRoom" },
  { 0xb0021, "DirectSoundI3DL2ListenerPreset_Mountains" },
  { 0xb0022, "DirectSoundI3DL2ListenerPreset_NoReverb" },
  { 0xb0023, "DirectSoundI3DL2ListenerPreset_PaddedCell" },
  { 0xb0024, "DirectSoundI3DL2ListenerPreset_ParkingLot" },
  { 0xb0025, "DirectSoundI3DL2ListenerPreset_Plain" },
  { 0xb0026, "DirectSoundI3DL2ListenerPreset_Quarry" },
  { 0xb0027, "DirectSoundI3DL2ListenerPreset_Room" },
  { 0xb0028, "DirectSoundI3DL2ListenerPreset_SewerPipe" },
  { 0xb0029, "DirectSoundI3DL2ListenerPreset_StoneCorridor" },
  { 0xb002a, "DirectSoundI3DL2ListenerPreset_StoneRoom" },
  { 0xb002b, "DirectSoundI3DL2ListenerPreset_Underwater" },
  { 0xb002c, "DirectSoundOverrideSpeakerConfig" },
  { 0xb002d, "DirectSoundRequiredMixBins_3D" },
  { 0xb002e, "DirectSoundRequiredMixBins_5Channel3D" },
  { 0xb002f, "DirectSoundUseFullHRTF" },
  { 0xb0030, "DirectSoundUseFullHRTF4Channel" },
  { 0xb0031, "DirectSoundUseLightHRTF" },
  { 0xb0032, "DirectSoundUseLightHRTF4Channel" },
  { 0xb0033, "g_dwDirectSoundDebugBreakLevel" },
  { 0xb0034, "g_dwDirectSoundDebugLevel" },
  { 0xb0035, "g_pfnDirectSoundDebugCallback" },
  { 0xb0036, "IDirectSound_AddRef" },
  { 0xb0037, "IDirectSound_CommitDeferredSettings" },
  { 0xb0038, "IDirectSound_CommitEffectData" },
  { 0xb0039, "IDirectSound_Compact" },
  { 0xb003a, "IDirectSound_CreateSoundBuffer" },
  { 0xb003b, "IDirectSound_CreateSoundStream" },
  { 0xb003c, "IDirectSound_DownloadEffectsImage" },
  { 0xb003d, "IDirectSound_EnableHeadphones" },
  { 0xb003e, "IDirectSound_GetCaps" },
  { 0xb003f, "IDirectSound_GetEffectData" },
  { 0xb0040, "IDirectSound_GetOutputLevels" },
  { 0xb0041, "IDirectSound_GetSpeakerConfig" },
  { 0xb0042, "IDirectSound_GetTime" },
  { 0xb0043, "IDirectSound_QueryInterface" },
  { 0xb0044, "IDirectSound_QueryInterfaceC" },
  { 0xb0045, "IDirectSound_Release" },
  { 0xb0046, "IDirectSound_SetAllParameters" },
  { 0xb0047, "IDirectSound_SetCooperativeLevel" },
  { 0xb0048, "IDirectSound_SetDistanceFactor" },
  { 0xb0049, "IDirectSound_SetDopplerFactor" },
  { 0xb004a, "IDirectSound_SetEffectData" },
  { 0xb004b, "IDirectSound_SetI3DL2Listener" },
  { 0xb004c, "IDirectSound_SetMixBinHeadroom" },
  { 0xb004d, "IDirectSound_SetOrientation" },
  { 0xb004e, "IDirectSound_SetPosition" },
  { 0xb004f, "IDirectSound_SetRolloffFactor" },
  { 0xb0050, "IDirectSound_SetVelocity" },
  { 0xb0051, "IDirectSound_SynchPlayback" },
  { 0xb0052, "IDirectSoundBuffer_AddRef" },
  { 0xb0053, "IDirectSoundBuffer_GetCurrentPosition" },
  { 0xb0054, "IDirectSoundBuffer_GetStatus" },
  { 0xb0055, "IDirectSoundBuffer_GetVoiceProperties" },
  { 0xb0056, "IDirectSoundBuffer_Lock" },
  { 0xb0057, "IDirectSoundBuffer_Pause" },
  { 0xb0058, "IDirectSoundBuffer_PauseEx" },
  { 0xb0059, "IDirectSoundBuffer_Play" },
  { 0xb005a, "IDirectSoundBuffer_PlayEx" },
  { 0xb005b, "IDirectSoundBuffer_QueryInterface" },
  { 0xb005c, "IDirectSoundBuffer_QueryInterfaceC" },
  { 0xb005d, "IDirectSoundBuffer_Release" },
  { 0xb005e, "IDirectSoundBuffer_Restore" },
  { 0xb005f, "IDirectSoundBuffer_SetAllParameters" },
  { 0xb0060, "IDirectSoundBuffer_SetBufferData" },
  { 0xb0061, "IDirectSoundBuffer_SetConeAngles" },
  { 0xb0062, "IDirectSoundBuffer_SetConeOrientation" },
  { 0xb0063, "IDirectSoundBuffer_SetConeOutsideVolume" },
  { 0xb0064, "IDirectSoundBuffer_SetCurrentPosition" },
  { 0xb0065, "IDirectSoundBuffer_SetDistanceFactor" },
  { 0xb0066, "IDirectSoundBuffer_SetDopplerFactor" },
  { 0xb0067, "IDirectSoundBuffer_SetEG" },
  { 0xb0068, "IDirectSoundBuffer_SetFilter" },
  { 0xb0069, "IDirectSoundBuffer_SetFormat" },
  { 0xb006a, "IDirectSoundBuffer_SetFrequency" },
  { 0xb006b, "IDirectSoundBuffer_SetHeadroom" },
  { 0xb006c, "IDirectSoundBuffer_SetI3DL2Source" },
  { 0xb006d, "IDirectSoundBuffer_SetLFO" },
  { 0xb006e, "IDirectSoundBuffer_SetLoopRegion" },
  { 0xb006f, "IDirectSoundBuffer_SetMaxDistance" },
  { 0xb0070, "IDirectSoundBuffer_SetMinDistance" },
  { 0xb0071, "IDirectSoundBuffer_SetMixBins" },
  { 0xb0072, "IDirectSoundBuffer_SetMixBinVolumes" },
  { 0xb0073, "IDirectSoundBuffer_SetMode" },
  { 0xb0074, "IDirectSoundBuffer_SetNotificationPositions" },
  { 0xb0075, "IDirectSoundBuffer_SetOutputBuffer" },
  { 0xb0076, "IDirectSoundBuffer_SetPitch" },
  { 0xb0077, "IDirectSoundBuffer_SetPlayRegion" },
  { 0xb0078, "IDirectSoundBuffer_SetPosition" },
  { 0xb0079, "IDirectSoundBuffer_SetRolloffCurve" },
  { 0xb007a, "IDirectSoundBuffer_SetRolloffFactor" },
  { 0xb007b, "IDirectSoundBuffer_SetVelocity" },
  { 0xb007c, "IDirectSoundBuffer_SetVolume" },
  { 0xb007d, "IDirectSoundBuffer_Stop" },
  { 0xb007e, "IDirectSoundBuffer_StopEx" },
  { 0xb007f, "IDirectSoundBuffer_Unlock" },
  { 0xb0080, "IDirectSoundStream_FlushEx" },
  { 0xb0081, "IDirectSoundStream_GetVoiceProperties" },
  { 0xb0082, "IDirectSoundStream_Pause" },
  { 0xb0083, "IDirectSoundStream_PauseEx" },
  { 0xb0084, "IDirectSoundStream_QueryInterface" },
  { 0xb0085, "IDirectSoundStream_QueryInterfaceC" },
  { 0xb0086, "IDirectSoundStream_SetAllParameters" },
  { 0xb0087, "IDirectSoundStream_SetConeAngles" },
  { 0xb0088, "IDirectSoundStream_SetConeOrientation" },
  { 0xb0089, "IDirectSoundStream_SetConeOutsideVolume" },
  { 0xb008a, "IDirectSoundStream_SetDistanceFactor" },
  { 0xb008b, "IDirectSoundStream_SetDopplerFactor" },
  { 0xb008c, "IDirectSoundStream_SetEG" },
  { 0xb008d, "IDirectSoundStream_SetFilter" },
  { 0xb008e, "IDirectSoundStream_SetFormat" },
  { 0xb008f, "IDirectSoundStream_SetFrequency" },
  { 0xb0090, "IDirectSoundStream_SetHeadroom" },
  { 0xb0091, "IDirectSoundStream_SetI3DL2Source" },
  { 0xb0092, "IDirectSoundStream_SetLFO" },
  { 0xb0093, "IDirectSoundStream_SetMaxDistance" },
  { 0xb0094, "IDirectSoundStream_SetMinDistance" },
  { 0xb0095, "IDirectSoundStream_SetMixBins" },
  { 0xb0096, "IDirectSoundStream_SetMixBinVolumes" },
  { 0xb0097, "IDirectSoundStream_SetMode" },
  { 0xb0098, "IDirectSoundStream_SetOutputBuffer" },
  { 0xb0099, "IDirectSoundStream_SetPitch" },
  { 0xb009a, "IDirectSoundStream_SetPosition" },
  { 0xb009b, "IDirectSoundStream_SetRolloffCurve" },
  { 0xb009c, "IDirectSoundStream_SetRolloffFactor" },
  { 0xb009d, "IDirectSoundStream_SetVelocity" },
  { 0xb009e, "IDirectSoundStream_SetVolume" },
  { 0xb009f, "WmaCreateDecoder" },
  { 0xb00a0, "WmaCreateDecoderEx" },
  { 0xb00a1, "WmaCreateInMemoryDecoder" },
  { 0xb00a2, "WmaCreateInMemoryDecoderEx" },
  { 0xb00a3, "XAudioCalculatePitch" },
  { 0xb00a4, "XAudioCreateAdpcmFormat" },
  { 0xb00a5, "XAudioCreatePcmFormat" },
  { 0xb00a6, "XAudioDownloadEffectsImage" },
  { 0xb00a7, "XAudioSetEffectData" },
  { 0xb00a8, "XFileCreateMediaObject" },
  { 0xb00a9, "XFileCreateMediaObjectAsync" },
  { 0xb00aa, "XFileCreateMediaObjectEx" },
  { 0xb00ab, "XWaveFileCreateMediaObject" },
  { 0xb00ac, "XWaveFileCreateMediaObjectEx" },
  { 0xb00ad, "XWmaDecoderCreateMediaObject" }
};

// Function mappings for KEYBOARD
std::unordered_map<uint32_t, std::string> functions_KEYBOARD = {
  { 0x60001, "XDEVICE_TYPE_KEYBOARD_TABLE" },
  { 0x60002, "XInputGetKeyboardDeviceLanguage" },
  { 0x60003, "XInputGetKeyboardOptions" },
  { 0x60004, "XInputGetKeystroke" },
  { 0x60005, "XInputRegisterLanguages" },
  { 0x60006, "XInputSetKeyboardOptions" }
};

// Function mappings for XACT
std::unordered_map<uint32_t, std::string> functions_XACT = {
  { 0xc0001, "IXACTEngine_AddRef" },
  { 0xc0002, "IXACTEngine_CommitDeferredSettings" },
  { 0xc0003, "IXACTEngine_CreateSoundBank" },
  { 0xc0004, "IXACTEngine_CreateSoundSource" },
  { 0xc0005, "IXACTEngine_DownloadEffectsImage" },
  { 0xc0006, "IXACTEngine_EnableHeadphones" },
  { 0xc0007, "IXACTEngine_FlushNotification" },
  { 0xc0008, "IXACTEngine_GetNotification" },
  { 0xc0009, "IXACTEngine_GlobalPause" },
  { 0xc000a, "IXACTEngine_RegisterNotification" },
  { 0xc000b, "IXACTEngine_RegisterStreamedWaveBank" },
  { 0xc000c, "IXACTEngine_RegisterWaveBank" },
  { 0xc000d, "IXACTEngine_Release" },
  { 0xc000e, "IXACTEngine_SetI3dl2Listener" },
  { 0xc000f, "IXACTEngine_SetListenerOrientation" },
  { 0xc0010, "IXACTEngine_SetListenerPosition" },
  { 0xc0011, "IXACTEngine_SetListenerVelocity" },
  { 0xc0012, "IXACTEngine_SetMasterVolume" },
  { 0xc0013, "IXACTEngine_SetParameterControl" },
  { 0xc0014, "IXACTEngine_UnRegisterNotification" },
  { 0xc0015, "IXACTEngine_UnRegisterWaveBank" },
  { 0xc0016, "IXACTSoundBank_AddRef" },
  { 0xc0017, "IXACTSoundBank_CreateWmaPlayList" },
  { 0xc0018, "IXACTSoundBank_GetSoundCueIndexFromFriendlyName" },
  { 0xc0019, "IXACTSoundBank_GetSoundCueProperties" },
  { 0xc001a, "IXACTSoundBank_PauseSoundCue" },
  { 0xc001b, "IXACTSoundBank_Play" },
  { 0xc001c, "IXACTSoundBank_PlayEx" },
  { 0xc001d, "IXACTSoundBank_Prepare" },
  { 0xc001e, "IXACTSoundBank_PrepareEx" },
  { 0xc001f, "IXACTSoundBank_Release" },
  { 0xc0020, "IXACTSoundBank_SelectVariation" },
  { 0xc0021, "IXACTSoundBank_Stop" },
  { 0xc0022, "IXACTSoundSource_AddRef" },
  { 0xc0023, "IXACTSoundSource_GetProperties" },
  { 0xc0024, "IXACTSoundSource_GetStatus" },
  { 0xc0025, "IXACTSoundSource_Release" },
  { 0xc0026, "IXACTSoundSource_SetConeOrientation" },
  { 0xc0027, "IXACTSoundSource_SetFilter" },
  { 0xc0028, "IXACTSoundSource_SetI3DL2Source" },
  { 0xc0029, "IXACTSoundSource_SetMixBins" },
  { 0xc002a, "IXACTSoundSource_SetMixBinVolumes" },
  { 0xc002b, "IXACTSoundSource_SetMode" },
  { 0xc002c, "IXACTSoundSource_SetPitch" },
  { 0xc002d, "IXACTSoundSource_SetPosition" },
  { 0xc002e, "IXACTSoundSource_SetVelocity" },
  { 0xc002f, "IXACTSoundSource_StopSoundCues" },
  { 0xc0030, "IXACTWmaPlayList_Add" },
  { 0xc0031, "IXACTWmaPlayList_AddRef" },
  { 0xc0032, "IXACTWmaPlayList_GetCurrentSongInfo" },
  { 0xc0033, "IXACTWmaPlayList_GetCurrentSongInfoEx" },
  { 0xc0034, "IXACTWmaPlayList_GetProperties" },
  { 0xc0035, "IXACTWmaPlayList_Next" },
  { 0xc0036, "IXACTWmaPlayList_Previous" },
  { 0xc0037, "IXACTWmaPlayList_Release" },
  { 0xc0038, "IXACTWmaPlayList_Remove" },
  { 0xc0039, "IXACTWmaPlayList_SetCurrent" },
  { 0xc003a, "IXACTWmaPlayList_SetPlaybackBehavior" },
  { 0xc003b, "XACTEngineCreate" },
  { 0xc003c, "XACTEngineDoWork" },
  { 0xc003d, "XACTEngineSetFileIOCallbacks" }
};

// Function mappings for XAPILIB
std::unordered_map<uint32_t, std::string> functions_XAPILIB = {
  { 0x10001, "XLoadSection" },
  { 0x10002, "XFreeSection" },
  { 0x10003, "XGetSectionHandle" },
  { 0x10004, "XLoadSectionByHandle" },
  { 0x10005, "XFreeSectionByHandle" },
  { 0x10006, "XGetSectionSize" },
  { 0x10007, "XGetDisplayBlocks" },
  { 0x10008, "XCreateSaveGame" },
  { 0x10009, "XDeleteSaveGame" },
  { 0x1000a, "XFindFirstSaveGame" },
  { 0x1000b, "XFindNextSaveGame" },
  { 0x1000c, "XFindClose" },
  { 0x1000d, "XSetNickname" },
  { 0x1000e, "XFindFirstNickname" },
  { 0x1000f, "XFindNextNickname" },
  { 0x10010, "XFindFirstContent" },
  { 0x10011, "XFindNextContent" },
  { 0x10012, "XGetContentInstallLocation" },
  { 0x10013, "XGetContentInstallLocationFromIDs" },
  { 0x10014, "XInstallContentSignatures" },
  { 0x10015, "XCreateContentSimple" },
  { 0x10016, "XRemoveContent" },
  { 0x10017, "XLoadContentSignaturesWithFileName" },
  { 0x10018, "XLocateSignatureByNameEx" },
  { 0x10019, "XLocateNextSignature" },
  { 0x1001a, "XInstallContentSignaturesWithFileName" },
  { 0x1001b, "XInstallContentSignaturesEx" },
  { 0x1001c, "XLoadContentSignaturesEx" },
  { 0x1001d, "XLocateSignatureByIndex" },
  { 0x1001e, "XLocateSignatureByName" },
  { 0x1001f, "XCalculateContentSignature" },
  { 0x10020, "XCloseContentSignatures" },
  { 0x10021, "XComputeContentSignatureKey" },
  { 0x10022, "XFindFirstSoundtrack" },
  { 0x10023, "XFindNextSoundtrack" },
  { 0x10024, "XOpenSoundtrackSong" },
  { 0x10025, "XGetSoundtrackSongInfo" },
  { 0x10026, "XAddSoundtrack" },
  { 0x10027, "XAddSongToSoundtrack" },
  { 0x10028, "XGetLanguage" },
  { 0x10029, "XGetAVPack" },
  { 0x1002a, "XGetVideoStandard" },
  { 0x1002b, "XGetVideoFlags" },
  { 0x1002c, "XGetAudioFlags" },
  { 0x1002d, "XGetParentalControlSetting" },
  { 0x1002e, "XGetGameRegion" },
  { 0x1002f, "XSetValue" },
  { 0x10030, "XQueryValue" },
  { 0x10031, "XInitDevices" },
  { 0x10032, "XGetDevices" },
  { 0x10033, "XGetDeviceChanges" },
  { 0x10034, "XPeekDevices" },
  { 0x10035, "XGetDeviceEnumerationStatus" },
  { 0x10036, "XInputOpen" },
  { 0x10037, "XInputClose" },
  { 0x10038, "XInputGetState" },
  { 0x10039, "XInputPoll" },
  { 0x1003a, "XInputSetState" },
  { 0x1003b, "XInputGetCapabilities" },
  { 0x1003c, "XInputGetDeviceDescription" },
  { 0x1003d, "XInputSetLightgunCalibration" },
  { 0x1003e, "XMountMUA" },
  { 0x1003f, "XMountMURoot" },
  { 0x10040, "XUnmountMU" },
  { 0x10041, "XMUPortFromDriveLetter" },
  { 0x10042, "XMUSlotFromDriveLetter" },
  { 0x10043, "XMUNameFromDriveLetter" },
  { 0x10044, "XMUNameFromPortSlot" },
  { 0x10045, "XReadMUMetaData" },
  { 0x10046, "XMUWriteNameToDriveLetter" },
  { 0x10047, "XCleanMUFromRoot" },
  { 0x10048, "XCleanDrive" },
  { 0x10049, "XMountUtilityDrive" },
  { 0x1004a, "XFormatUtilityDrive" },
  { 0x1004b, "XMountAlternateTitle" },
  { 0x1004c, "XUnmountAlternateTitle" },
  { 0x1004d, "XGetDiskSectorSize" },
  { 0x1004e, "XGetDiskClusterSize" },
  { 0x1004f, "XDCSGetInformation" },
  { 0x10050, "XDCSDownloadCode" },
  { 0x10051, "XDCSDownloadCodeAsync" },
  { 0x10052, "XAutoPowerDownSet" },
  { 0x10053, "XAutoPowerDownGet" },
  { 0x10054, "XAutoPowerDownResetTimer" },
  { 0x10055, "XAutoPowerDownDebugSetTimeout" },
  { 0x10056, "XapiSetLocalTime" },
  { 0x10057, "XapipQueryTimeZoneInformation" },
  { 0x10058, "XapipSetTimeZoneInformation" },
  { 0x10059, "XapipUseDaylightSavingTime" },
  { 0x1005a, "XLaunchNewImageA" },
  { 0x1005b, "XGetLaunchInfo" },
  { 0x1005c, "XWriteTitleInfoAndReboot" },
  { 0x1005d, "XRegisterThreadNotifyRoutine" },
  { 0x1005e, "XSetProcessQuantumLength" },
  { 0x1005f, "XGetProcessQuantumLength" },
  { 0x10060, "XSetFileCacheSize" },
  { 0x10061, "XGetFileCacheSize" },
  { 0x10062, "XSaveFloatingPointStateForDpc" },
  { 0x10063, "XRestoreFloatingPointStateForDpc" },
  { 0x10064, "XPhysicalAlloc" },
  { 0x10065, "XPhysicalSize" },
  { 0x10066, "XPhysicalProtect" },
  { 0x10067, "XPhysicalFree" },
  { 0x10068, "XQueryMemoryProtect" },
  { 0x10069, "XMemAlloc" },
  { 0x1006a, "XMemFree" },
  { 0x1006b, "XMemSize" },
  { 0x1006c, "XSetAttributesOnHeapAlloc" },
  { 0x1006d, "XGetAttributesOnHeapAlloc" },
  { 0x1006e, "XDebugGetSystemVersion" },
  { 0x1006f, "XDebugGetXTLVersion" },
  { 0x10070, "XCalculateSignatureBegin" },
  { 0x10071, "XCalculateSignatureBeginEx" },
  { 0x10072, "XCalculateSignatureUpdate" },
  { 0x10073, "XCalculateSignatureEnd" },
  { 0x10074, "XAutoPowerDownTimeRemaining" },
  { 0x10075, "XapiFlashKernelImage" },
  { 0x10076, "XapiReplaceRootDirectoryFile" },
  { 0x10077, "XapiGetKernelExportAddress" },
  { 0x10078, "XMemAllocDefault" },
  { 0x10079, "XMemFreeDefault" },
  { 0x1007a, "XMemSizeDefault" },
  { 0x1007b, "XDEVICE_TYPE_DEBUG_MOUSE_TABLE" },
  { 0x1007c, "XDEVICE_TYPE_GAMEPAD_TABLE" },
  { 0x1007d, "XDEVICE_TYPE_IR_REMOTE_TABLE" },
  { 0x1007e, "XDEVICE_TYPE_MEMORY_UNIT_TABLE" },
  { 0x20001, "GetCurrentTime" },
  { 0x20002, "Yield" },
  { 0x20003, "MoveMemory" },
  { 0x20004, "CopyMemory" },
  { 0x20005, "FillMemory" },
  { 0x20006, "ZeroMemory" },
  { 0x2000f, "InterlockedIncrement" },
  { 0x20010, "InterlockedDecrement" },
  { 0x20011, "InterlockedExchange" },
  { 0x20012, "InterlockedExchangePointerTarget" },
  { 0x20013, "InterlockedExchangeAdd" },
  { 0x20014, "InterlockedCompareExchange" },
  { 0x20015, "InterlockedCompareExchangePointer" },
  { 0x20016, "FreeResource" },
  { 0x20017, "LockResource" },
  { 0x20018, "UnlockResourcehResData" },
  { 0x20019, "WinMain" },
  { 0x2001a, "FreeLibrary" },
  { 0x2001b, "FreeLibraryAndExitThread" },
  { 0x2001c, "DisableThreadLibraryCalls" },
  { 0x2001d, "GetProcAddress" },
  { 0x2001e, "GlobalAlloc" },
  { 0x2001f, "GlobalReAlloc" },
  { 0x20020, "GlobalFlags" },
  { 0x20021, "GlobalSize" },
  { 0x20022, "GlobalLock" },
  { 0x20023, "GlobalHandle" },
  { 0x20024, "GlobalUnlock" },
  { 0x20025, "GlobalFree" },
  { 0x20026, "GlobalCompact" },
  { 0x20027, "GlobalFix" },
  { 0x20028, "GlobalUnfix" },
  { 0x20029, "GlobalWire" },
  { 0x2002a, "GlobalUnWire" },
  { 0x2002b, "GlobalMemoryStatus" },
  { 0x2002c, "GlobalMemoryStatusEx" },
  { 0x2002d, "LocalAlloc" },
  { 0x2002e, "LocalReAlloc" },
  { 0x2002f, "LocalLock" },
  { 0x20030, "LocalHandle" },
  { 0x20031, "LocalUnlock" },
  { 0x20032, "LocalSize" },
  { 0x20033, "LocalFlags" },
  { 0x20034, "LocalFree" },
  { 0x20035, "LocalShrink" },
  { 0x20036, "LocalCompact" },
  { 0x20037, "VirtualAlloc" },
  { 0x20038, "VirtualFree" },
  { 0x20039, "VirtualProtect" },
  { 0x2003a, "VirtualQuery" },
  { 0x2003b, "VirtualAllocEx" },
  { 0x2003c, "VirtualFreeEx" },
  { 0x2003d, "VirtualProtectEx" },
  { 0x2003e, "VirtualQueryEx" },
  { 0x2003f, "HeapCreate" },
  { 0x20040, "HeapDestroy" },
  { 0x20041, "HeapCreateTagsW" },
  { 0x20042, "HeapQueryTagW" },
  { 0x20043, "HeapAlloc" },
  { 0x20044, "HeapReAlloc" },
  { 0x20045, "HeapSize" },
  { 0x20046, "HeapFree" },
  { 0x20047, "HeapValidate" },
  { 0x20048, "HeapCompact" },
  { 0x20049, "GetProcessHeapVOID" },
  { 0x2004a, "GetProcessHeaps" },
  { 0x2004b, "HeapLock" },
  { 0x2004c, "HeapUnlock" },
  { 0x2004d, "HeapSummary" },
  { 0x2004e, "HeapExtend" },
  { 0x2004f, "HeapUsage" },
  { 0x20050, "HeapWalk" },
  { 0x20051, "GetShortPathNameA" },
  { 0x20052, "GetShortPathNameW" },
  { 0x20053, "GetLongPathNameA" },
  { 0x20054, "GetLongPathNameW" },
  { 0x20055, "GetProcessTimes" },
  { 0x20056, "GetCurrentProcess" },
  { 0x20057, "GetCurrentProcessId" },
  { 0x20058, "ExitProcess" },
  { 0x20059, "TerminateProcess" },
  { 0x2005a, "GetExitCodeProcess" },
  { 0x2005b, "FatalExit" },
  { 0x2005c, "RaiseException" },
  { 0x2005d, "UnhandledExceptionFilter" },
  { 0x2005e, "SetUnhandledExceptionFilter" },
  { 0x2005f, "CreateFiber" },
  { 0x20060, "DeleteFiber" },
  { 0x20061, "ConvertThreadToFiber" },
  { 0x20062, "SwitchToFiber" },
  { 0x20063, "SwitchToThread" },
  { 0x20064, "CreateThread" },
  { 0x20065, "GetCurrentThread" },
  { 0x20066, "GetCurrentThreadId" },
  { 0x20067, "SetProcessPriorityBoost" },
  { 0x20068, "GetProcessPriorityBoost" },
  { 0x20069, "OpenThread" },
  { 0x2006a, "SetThreadPriority" },
  { 0x2006b, "SetThreadPriorityBoost" },
  { 0x2006c, "GetThreadPriorityBoost" },
  { 0x2006d, "GetThreadPriority" },
  { 0x2006e, "GetThreadTimes" },
  { 0x2006f, "ExitThread" },
  { 0x20070, "TerminateThread" },
  { 0x20071, "GetExitCodeThread" },
  { 0x20072, "GetLastError" },
  { 0x20073, "SetLastError" },
  { 0x20074, "HasOverlappedIoCompletedlpOverlapped" },
  { 0x20075, "GetOverlappedResult" },
  { 0x20076, "CreateIoCompletionPort" },
  { 0x20077, "GetQueuedCompletionStatus" },
  { 0x20078, "PostQueuedCompletionStatus" },
  { 0x20079, "SetErrorMode" },
  { 0x2007a, "GetThreadContext" },
  { 0x2007b, "SetThreadContext" },
  { 0x2007c, "SuspendThread" },
  { 0x2007d, "ResumeThread" },
  { 0x2007e, "QueueUserAPC" },
  { 0x2007f, "IsDebuggerPresent" },
  { 0x20080, "DebugBreak" },
  { 0x20081, "WaitForDebugEvent" },
  { 0x20082, "ContinueDebugEvent" },
  { 0x20083, "DebugActiveProcess" },
  { 0x20084, "InitializeCriticalSection" },
  { 0x20085, "EnterCriticalSection" },
  { 0x20086, "LeaveCriticalSection" },
  { 0x20087, "TryEnterCriticalSection" },
  { 0x20088, "DeleteCriticalSection" },
  { 0x20089, "SetEvent" },
  { 0x2008a, "ResetEvent" },
  { 0x2008b, "PulseEvent" },
  { 0x2008c, "ReleaseSemaphore" },
  { 0x2008d, "ReleaseMutex" },
  { 0x2008e, "WaitForSingleObject" },
  { 0x2008f, "WaitForMultipleObjects" },
  { 0x20090, "Sleep" },
  { 0x20091, "LoadResource" },
  { 0x20092, "SizeofResource" },
  { 0x20093, "GetLogicalDrives" },
  { 0x20094, "GetFileInformationByHandle" },
  { 0x20095, "GetFileType" },
  { 0x20096, "GetFileSize" },
  { 0x20097, "GetFileSizeEx" },
  { 0x20098, "WriteFile" },
  { 0x20099, "ReadFile" },
  { 0x2009a, "FlushFileBuffers" },
  { 0x2009b, "DeviceIoControl" },
  { 0x2009c, "SetEndOfFile" },
  { 0x2009d, "SetFilePointer" },
  { 0x2009e, "SetFilePointerEx" },
  { 0x2009f, "GetFileTime" },
  { 0x200a0, "SetFileTime" },
  { 0x200a1, "CloseHandle" },
  { 0x200a2, "DuplicateHandle" },
  { 0x200a3, "LoadModule" },
  { 0x200a4, "MulDiv" },
  { 0x200a5, "GetSystemTime" },
  { 0x200a6, "GetSystemTimeAsFileTime" },
  { 0x200a7, "SetSystemTime" },
  { 0x200a8, "GetLocalTime" },
  { 0x200a9, "SetLocalTime" },
  { 0x200aa, "GetSystemInfo" },
  { 0x200ab, "SystemTimeToTzSpecificLocalTime" },
  { 0x200ac, "GetTimeZoneInformation" },
  { 0x200ad, "SetTimeZoneInformation" },
  { 0x200ae, "SystemTimeToFileTime" },
  { 0x200af, "FileTimeToLocalFileTime" },
  { 0x200b0, "LocalFileTimeToFileTime" },
  { 0x200b1, "FileTimeToSystemTime" },
  { 0x200b2, "CompareFileTime" },
  { 0x200b3, "FileTimeToDosDateTime" },
  { 0x200b4, "DosDateTimeToFileTime" },
  { 0x200b5, "GetTickCount" },
  { 0x200b6, "SetSystemTimeAdjustment" },
  { 0x200b7, "GetSystemTimeAdjustment" },
  { 0x200b8, "FormatMessageA" },
  { 0x200b9, "FormatMessageW" },
  { 0x200ba, "lstrcmpA" },
  { 0x200bb, "lstrcmpW" },
  { 0x200bc, "lstrcmpiA" },
  { 0x200bd, "lstrcmpiW" },
  { 0x200be, "lstrcpynA" },
  { 0x200bf, "lstrcpynW" },
  { 0x200c0, "lstrcpyA" },
  { 0x200c1, "lstrcpyW" },
  { 0x200c2, "lstrcatA" },
  { 0x200c3, "lstrcatW" },
  { 0x200c4, "lstrlenA" },
  { 0x200c5, "lstrlenW" },
  { 0x200c6, "OpenFile" },
  { 0x200c7, "_lopen" },
  { 0x200c8, "_lcreat" },
  { 0x200c9, "_lread" },
  { 0x200ca, "_lwrite" },
  { 0x200cb, "_hread" },
  { 0x200cc, "_hwrite" },
  { 0x200cd, "_lclose" },
  { 0x200ce, "_llseek" },
  { 0x200cf, "IsTextUnicode" },
  { 0x200d0, "TlsAlloc" },
  { 0x200d1, "TlsGetValue" },
  { 0x200d2, "TlsSetValue" },
  { 0x200d3, "TlsFree" },
  { 0x200d4, "SleepEx" },
  { 0x200d5, "WaitForSingleObjectEx" },
  { 0x200d6, "WaitForMultipleObjectsEx" },
  { 0x200d7, "SignalObjectAndWait" },
  { 0x200d8, "ReadFileEx" },
  { 0x200d9, "WriteFileEx" },
  { 0x200da, "ReadFileScatter" },
  { 0x200db, "WriteFileGather" },
  { 0x200dc, "CreateMutex" },
  { 0x200dd, "OpenMutex" },
  { 0x200de, "CreateEvent" },
  { 0x200df, "OpenEvent" },
  { 0x200e0, "CreateSemaphore" },
  { 0x200e1, "OpenSemaphore" },
  { 0x200e2, "CreateWaitableTimer" },
  { 0x200e3, "OpenWaitableTimer" },
  { 0x200e4, "SetWaitableTimer" },
  { 0x200e5, "CancelWaitableTimer" },
  { 0x200e6, "GetLogicalDriveStringsA" },
  { 0x200e7, "GetLogicalDriveStringsW" },
  { 0x200e8, "LoadLibraryA" },
  { 0x200e9, "LoadLibraryW" },
  { 0x200ea, "LoadLibraryExA" },
  { 0x200eb, "LoadLibraryExW" },
  { 0x200ec, "GetModuleFileNameA" },
  { 0x200ed, "GetModuleFileNameW" },
  { 0x200ee, "GetModuleHandleA" },
  { 0x200ef, "GetModuleHandleW" },
  { 0x200f0, "OutputDebugStringA" },
  { 0x200f1, "OutputDebugStringW" },
  { 0x200f2, "FindResourceA" },
  { 0x200f3, "FindResourceW" },
  { 0x200f4, "FindResourceExA" },
  { 0x200f5, "FindResourceExW" },
  { 0x200f6, "EnumResourceTypesA" },
  { 0x200f7, "EnumResourceTypesW" },
  { 0x200f8, "EnumResourceNamesA" },
  { 0x200f9, "EnumResourceNamesW" },
  { 0x200fa, "EnumResourceLanguagesA" },
  { 0x200fb, "EnumResourceLanguagesW" },
  { 0x200fc, "GetProfileIntA" },
  { 0x200fd, "GetProfileIntW" },
  { 0x200fe, "GetProfileStringA" },
  { 0x200ff, "GetProfileStringW" },
  { 0x20100, "WriteProfileStringA" },
  { 0x20101, "WriteProfileStringW" },
  { 0x20102, "GetProfileSectionA" },
  { 0x20103, "GetProfileSectionW" },
  { 0x20104, "WriteProfileSectionA" },
  { 0x20105, "WriteProfileSectionW" },
  { 0x20106, "GetPrivateProfileIntA" },
  { 0x20107, "GetPrivateProfileIntW" },
  { 0x20108, "GetPrivateProfileStringA" },
  { 0x20109, "GetPrivateProfileStringW" },
  { 0x2010a, "WritePrivateProfileStringA" },
  { 0x2010b, "WritePrivateProfileStringW" },
  { 0x2010c, "GetPrivateProfileSectionA" },
  { 0x2010d, "GetPrivateProfileSectionW" },
  { 0x2010e, "WritePrivateProfileSectionA" },
  { 0x2010f, "WritePrivateProfileSectionW" },
  { 0x20110, "GetPrivateProfileSectionNamesA" },
  { 0x20111, "GetPrivateProfileSectionNamesW" },
  { 0x20112, "GetPrivateProfileStructA" },
  { 0x20113, "GetPrivateProfileStructW" },
  { 0x20114, "WritePrivateProfileStructA" },
  { 0x20115, "WritePrivateProfileStructW" },
  { 0x20116, "GetDriveTypeA" },
  { 0x20117, "GetDriveTypeW" },
  { 0x20118, "GetSystemDirectoryA" },
  { 0x20119, "GetSystemDirectoryW" },
  { 0x2011a, "GetTempPathA" },
  { 0x2011b, "GetTempPathW" },
  { 0x2011c, "GetTempFileNameA" },
  { 0x2011d, "GetTempFileNameW" },
  { 0x2011e, "SetCurrentDirectoryA" },
  { 0x2011f, "GetCurrentDirectoryW" },
  { 0x20120, "GetDiskFreeSpaceA" },
  { 0x20121, "GetDiskFreeSpaceW" },
  { 0x20122, "GetDiskFreeSpaceEx" },
  { 0x20123, "CreateDirectory" },
  { 0x20124, "CreateDirectoryExA" },
  { 0x20125, "CreateDirectoryExW" },
  { 0x20126, "RemoveDirectory" },
  { 0x20127, "GetFullPathNameA" },
  { 0x20128, "GetFullPathNameW" },
  { 0x20129, "CreateFile" },
  { 0x2012a, "SetFileAttributes" },
  { 0x2012b, "GetFileAttributes" },
  { 0x2012c, "GetFileAttributesEx" },
  { 0x2012d, "DeleteFile" },
  { 0x2012e, "FindFirstFile" },
  { 0x2012f, "FindNextFile" },
  { 0x20130, "SearchPathA" },
  { 0x20131, "SearchPathW" },
  { 0x20132, "CopyFile" },
  { 0x20133, "CopyFileEx" },
  { 0x20134, "MoveFile" },
  { 0x20135, "MoveFileEx" },
  { 0x20136, "MoveFileWithProgress" },
  { 0x20137, "SetVolumeLabelA" },
  { 0x20138, "SetVolumeLabelW" },
  { 0x20139, "SetFileApisToOEMVOID" },
  { 0x2013a, "SetFileApisToANSIVOID" },
  { 0x2013b, "AreFileApisANSIVOID" },
  { 0x2013c, "GetVolumeInformation" },
  { 0x2013d, "CancelIo" },
  { 0x2013e, "SetPriorityClass" },
  { 0x2013f, "GetPriorityClass" },
  { 0x20140, "IsBadReadPtr" },
  { 0x20141, "IsBadWritePtr" },
  { 0x20142, "IsBadHugeReadPtr" },
  { 0x20143, "IsBadHugeWritePtr" },
  { 0x20144, "IsBadCodePtr" },
  { 0x20145, "IsBadStringPtrA" },
  { 0x20146, "IsBadStringPtrW" },
  { 0x20147, "GetComputerNameA" },
  { 0x20148, "GetComputerNameW" },
  { 0x20149, "SetComputerNameA" },
  { 0x2014a, "SetComputerNameW" },
  { 0x2014b, "GetComputerNameExA" },
  { 0x2014c, "GetComputerNameExW" },
  { 0x2014d, "SetComputerNameExA" },
  { 0x2014e, "SetComputerNameExW" },
  { 0x2014f, "DnsHostnameToComputerNameA" },
  { 0x20150, "DnsHostnameToComputerNameW" },
  { 0x20151, "GetUserNameA" },
  { 0x20152, "GetUserNameW" },
  { 0x20153, "RegisterWaitForSingleObject" },
  { 0x20154, "RegisterWaitForSingleObjectEx" },
  { 0x20155, "UnregisterWait" },
  { 0x20156, "UnregisterWaitEx" },
  { 0x20157, "QueueUserWorkItem" },
  { 0x20158, "BindIoCompletionCallback" },
  { 0x20159, "CreateTimerQueue" },
  { 0x2015a, "CreateTimerQueueTimer" },
  { 0x2015b, "ChangeTimerQueueTimer" },
  { 0x2015c, "DeleteTimerQueueTimer" },
  { 0x2015d, "DeleteTimerQueueEx" },
  { 0x2015e, "SetTimerQueueTimer" },
  { 0x2015f, "CancelTimerQueueTimer" },
  { 0x20160, "DeleteTimerQueue" },
  { 0x20161, "QueryPerformanceCounter" },
  { 0x20162, "QueryPerformanceFrequency" },
  { 0x20163, "FindFirstVolumeA" },
  { 0x20164, "FindFirstVolumeW" },
  { 0x20165, "FindNextVolumeA" },
  { 0x20166, "FindNextVolumeW" },
  { 0x20167, "FindVolumeClose" },
  { 0x20168, "GetVolumePathNameA" },
  { 0x20169, "GetVolumePathNameW" },
  { 0x2016a, "GetDaylightFlagVOID" },
  { 0x2016b, "SetDaylightFlag" },
  { 0x2016c, "wvsprintfA" },
  { 0x2016d, "wvsprintfW" },
  { 0x2016e, "wsprintfA" },
  { 0x2016f, "wsprintfW" },
  { 0x20170, "MultiByteToWideChar" },
  { 0x20171, "WideCharToMultiByte" },
  { 0x20172, "CharUpperA" },
  { 0x20173, "CharUpperW" },
  { 0x20174, "CharLowerA" },
  { 0x20175, "CharLowerW" },
  { 0x20176, "SetRect" },
  { 0x20177, "SetRectEmpty" },
  { 0x20178, "CopyRect" },
  { 0x20179, "InflateRect" },
  { 0x2017a, "IntersectRect" },
  { 0x2017b, "UnionRect" },
  { 0x2017c, "SubtractRect" },
  { 0x2017d, "OffsetRect" },
  { 0x2017e, "IsRectEmpty" },
  { 0x2017f, "EqualRect" },
  { 0x20180, "PtInRect" }
};

// Function mappings for XGRAPHICS
std::unordered_map<uint32_t, std::string> functions_XGRAPHICS = {
  { 0xd0001, "XGAssembleShader" },
  { 0xd0002, "XGBuffer_AddRef" },
  { 0xd0003, "XGBuffer_GetBufferPointer" },
  { 0xd0004, "XGBuffer_GetBufferSize" },
  { 0xd0005, "XGBuffer_Release" },
  { 0xd0006, "XGBufferCreate" },
  { 0xd0007, "XGBytesPerPixelFromFormat" },
  { 0xd0008, "XGCompileDrawIndexedVertices" },
  { 0xd0009, "XGCompileShader" },
  { 0xd000a, "XGCompressRect" },
  { 0xd000b, "XGIsSwizzledFormat" },
  { 0xd000c, "XGSetCubeTextureHeader" },
  { 0xd000d, "XGSetFixupHeader" },
  { 0xd000e, "XGSetIndexBufferHeader" },
  { 0xd000f, "XGSetPaletteHeader" },
  { 0xd0010, "XGSetPushBufferHeader" },
  { 0xd0011, "XGSetSurfaceHeader" },
  { 0xd0012, "XGSetTextureHeader" },
  { 0xd0013, "XGSetVertexBufferHeader" },
  { 0xd0014, "XGSetVolumeTextureHeader" },
  { 0xd0015, "XGSpliceVertexShaders" },
  { 0xd0016, "XGSUCode_CompareVertexShaders" },
  { 0xd0017, "XGSUCode_GetVertexShaderLength" },
  { 0xd0018, "XGSUCode_GetVertexShaderType" },
  { 0xd0019, "XGSwizzleBox" },
  { 0xd001a, "XGSwizzleRect" },
  { 0xd001b, "XGUnswizzleBox" },
  { 0xd001c, "XGUnswizzleRect" },
  { 0xd001d, "XGWriteSurfaceOrTextureToXPR" },
  { 0xd001e, "XGWriteSurfaceToFile" }
};

// Function mappings for XKBD
std::unordered_map<uint32_t, std::string> functions_XKBD = {
  { 0x50001, "XDEVICE_TYPE_DEBUG_KEYBOARD_TABLE" },
  { 0x50002, "XInputDebugGetKeystroke" },
  { 0x50003, "XInputDebugInitKeyboardQueue" }
};

// Function mappings for XMV
std::unordered_map<uint32_t, std::string> functions_XMV = {
  { 0xe0001, "XMVDecoder_CloseDecoder" },
  { 0xe0002, "XMVDecoder_CreateDecoderForFile" },
  { 0xe0003, "XMVDecoder_CreateDecoderForPackets" },
  { 0xe0004, "XMVDecoder_DisableAudioStream" },
  { 0xe0005, "XMVDecoder_EnableAudioStream" },
  { 0xe0006, "XMVDecoder_GetAudioDescriptor" },
  { 0xe0007, "XMVDecoder_GetAudioStream" },
  { 0xe0008, "XMVDecoder_GetNextFrame" },
  { 0xe0009, "XMVDecoder_GetSynchronizationStream" },
  { 0xe000a, "XMVDecoder_GetTimeFromStart" },
  { 0xe000b, "XMVDecoder_GetVideoDescriptor" },
  { 0xe000c, "XMVDecoder_Play" },
  { 0xe000d, "XMVDecoder_Reset" },
  { 0xe000e, "XMVDecoder_SetSynchronizationStream" },
  { 0xe000f, "XMVDecoder_TerminateImmediately" },
  { 0xe0010, "XMVDecoder_TerminateLoop" },
  { 0xe0011, "XMVDecoder_TerminatePlayback" }
};

// Function mappings for XONLINES
std::unordered_map<uint32_t, std::string> functions_XONLINES = {
  { 0x30001, "XOnlineStartup" },
  { 0x30002, "XOnlineCleanup" },
  { 0x30003, "XOnlineTaskContinue" },
  { 0x30004, "XOnlineTaskClose" },
  { 0x30005, "XOnlineGetUsers" },
  { 0x30006, "XOnlineLogon" },
  { 0x30007, "XOnlineLogonTaskGetResults" },
  { 0x30008, "XOnlineChangeLogonUsers" },
  { 0x30009, "XOnlineChangeLogonUsersTaskGetResults" },
  { 0x3000a, "XOnlineGetLogonUsers" },
  { 0x3000b, "XOnlineGetServiceInfo" },
  { 0x3000c, "XOnlineSaveLogonState" },
  { 0x3000d, "XOnlineRetrieveLogonState" },
  { 0x3000e, "XOnlineDashUpdate" },
  { 0x3000f, "XOnlineTitleUpdate" },
  { 0x30010, "XOnlineTitleUpdateEx" },
  { 0x30011, "XOnlineOfferingPurchase" },
  { 0x30012, "XOnlineOfferingCancel" },
  { 0x30013, "XOnlineOfferingDetails" },
  { 0x30014, "XOnlineOfferingDetailsGetResults" },
  { 0x30015, "XOnlineOfferingDetailsMaxSize" },
  { 0x30016, "XOnlineOfferingPriceFormat" },
  { 0x30017, "XOnlineOfferingVerifyLicense" },
  { 0x30018, "XOnlineOfferingIsNewContentAvailable" },
  { 0x30019, "XOnlineOfferingEnumerate" },
  { 0x3001a, "XOnlineOfferingEnumerateGetResults" },
  { 0x3001b, "XOnlineOfferingEnumerateMaxSize" },
  { 0x3001c, "XOnlineContentInstall" },
  { 0x3001d, "XOnlineContentInstallFromDVD" },
  { 0x3001e, "XOnlineContentInstallGetProgress" },
  { 0x3001f, "XOnlineContentSetSecurityKey" },
  { 0x30020, "XOnlineMatchSessionCreate" },
  { 0x30021, "XOnlineMatchSessionUpdate" },
  { 0x30022, "XOnlineMatchSessionGetInfo" },
  { 0x30023, "XOnlineMatchSessionDelete" },
  { 0x30024, "XOnlineMatchSessionFindFromID" },
  { 0x30025, "XOnlineMatchSearch" },
  { 0x30026, "XOnlineMatchSearchGetResults" },
  { 0x30027, "XOnlineMatchSearchParse" },
  { 0x30028, "XOnlineMatchSearchResultsLen" },
  { 0x30029, "XOnlineTitleNameStartup" },
  { 0x3002a, "XOnlineTitleNameLookup" },
  { 0x3002b, "XOnlineTitleNameSetName" },
  { 0x3002c, "XOnlineTitleNameReset" },
  { 0x3002d, "XOnlineTitleIdIsSameTitle" },
  { 0x3002e, "XOnlineTitleIdIsSamePublisher" },
  { 0x3002f, "XOnlineNotificationSetState" },
  { 0x30030, "XOnlineNotificationSetUserData" },
  { 0x30031, "XOnlineGetNotification" },
  { 0x30032, "XOnlineFriendsStartup" },
  { 0x30033, "XOnlineFriendsEnumerate" },
  { 0x30034, "XOnlineFriendsEnumerateFinish" },
  { 0x30035, "XOnlineFriendsGetLatest" },
  { 0x30036, "XOnlineFriendsGetLatestByRange" },
  { 0x30037, "XOnlineFriendsGetLatestByFocus" },
  { 0x30038, "XOnlineFriendsGetTitleName" },
  { 0x30039, "XOnlineFriendsRemove" },
  { 0x3003a, "XOnlineFriendsRequest" },
  { 0x3003b, "XOnlineFriendsRequestByName" },
  { 0x3003c, "XOnlineFriendsGameInvite" },
  { 0x3003d, "XOnlineFriendsRevokeGameInvite" },
  { 0x3003e, "XOnlineFriendsAnswerRequest" },
  { 0x3003f, "XOnlineFriendsAnswerGameInvite" },
  { 0x30040, "XOnlineFriendsJoinGame" },
  { 0x30041, "XOnlineFriendsGetAcceptedGameInvite" },
  { 0x30042, "XOnlineMutelistGet" },
  { 0x30043, "XOnlineMutelistStartup" },
  { 0x30044, "XOnlineMutelistAdd" },
  { 0x30045, "XOnlineMutelistRemove" },
  { 0x30046, "XOnlineFeedbackSend" },
  { 0x30047, "XOnlineStringGet" },
  { 0x30048, "XOnlineMessageGet" },
  { 0x30049, "XOnlineEnumerateTitlesBegin" },
  { 0x3004a, "XOnlineEnumerateTitlesContinue" },
  { 0x3004b, "XOnlineEnumerateTitlesGetResults" },
  { 0x3004c, "XOnlineDownloadToMemory" },
  { 0x3004d, "XOnlineDownloadFile" },
  { 0x3004e, "XOnlineDownloadGetProgress" },
  { 0x3004f, "XOnlineDownloadGetResults" },
  { 0x30050, "XOnlineUploadFromMemory" },
  { 0x30051, "XOnlineUploadFile" },
  { 0x30052, "XOnlineUploadFileByHandle" },
  { 0x30053, "XOnlineUploadGetProgress" },
  { 0x30054, "XOnlineUploadGetResults" },
  { 0x30055, "XOnlineVerifyNickname" },
  { 0x30056, "XOnlineStatWrite" },
  { 0x30057, "XOnlineStatRead" },
  { 0x30058, "XOnlineStatReadGetResult" },
  { 0x30059, "XOnlineStatLeaderEnumerate" },
  { 0x3005a, "XOnlineStatLeaderEnumerateGetResults" },
  { 0x3005b, "XOnlineStatReset" },
  { 0x3005c, "_XOnlineLogonTaskGetStatus" },
  { 0x3005d, "_XOnlineGetLogonUserPrivateFlags" },
  { 0x3005e, "_XOnlineDontUseTicketCacheOnNextLogon" },
  { 0x3005f, "_XOnlineGetMachineID" },
  { 0x30060, "_XOnlineGetSerialNumber" },
  { 0x30061, "_XOnlineGetUsersFromHD" },
  { 0x30062, "_XOnlineGetUserFromMU" },
  { 0x30063, "_XOnlineAddUserToHD" },
  { 0x30064, "_XOnlineSetUserInMU" },
  { 0x30065, "_XOnlineRemoveUserFromHD" },
  { 0x30066, "_XOnlineIsUserCredentialPresent" },
  { 0x30067, "_XOnlineIsLoggedOn" },
  { 0x30068, "_XOnlineOverrideInfo" },
  { 0x30069, "_XOnlineCleanupAsyncIO" },
  { 0x3006a, "_XOnlineGetTitleId" },
  { 0x3006b, "_XOnlineGetTitleVersion" },
  { 0x3006c, "_XOnlineSetTitleId" },
  { 0x3006d, "_XOnlineSetTitleVersion" },
  { 0x3006e, "_XOnlineSetTitleGameRegion" },
  { 0x3006f, "_XOnlineReserveName" },
  { 0x30070, "_XOnlineGetReserveNameResults" },
  { 0x30071, "_XOnlineCreateOwnerAccount" },
  { 0x30072, "_XOnlineGetCreateOwnerAccountResults" },
  { 0x30073, "_XOnlineOfferingPurchaseInternal" },
  { 0x30074, "_XOnlineOfferingEnumerateInternal" },
  { 0x30075, "_XOnlineGetPaymentInfo" },
  { 0x30076, "_XOnlineGetPaymentInfoResults" },
  { 0x30077, "_XOnlineSetPaymentInfo" },
  { 0x30078, "_XOnlineSetUserSettings" },
  { 0x30079, "_XOnlineSetUserPIN" },
  { 0x3007a, "_XOnlineSetUserPINResults" },
  { 0x3007b, "_XOnlineVerifyBillingPIN" },
  { 0x3007c, "_XOnlineVerifyVoucher" },
  { 0x3007d, "_XOnlineRestoreAccount" },
  { 0x3007e, "_XOnlineRestoreAccountResults" },
  { 0x3007f, "_XOnlineChangeGamerTag" },
  { 0x30080, "_XOnlineChangeGamerTagResults" },
  { 0x30081, "_XOnlineSetUserAccountStatus" },
  { 0x30082, "_XOnlineClearSubscriptions" },
  { 0x30083, "_XOnlineAcceptTermsOfUse" },
  { 0x30084, "_XOnlineTroubleshootAccount" },
  { 0x30085, "_XOnlineTroubleshootAccountResults" },
  { 0x30086, "XOnlineCompetitionCreate" },
  { 0x30088, "XOnlineCompetitionCreateGetResults" },
  { 0x30089, "XOnlineStatWriteGetResult" },
  { 0x3008a, "XOnlineSignatureVerify" },
  { 0x3008b, "XOnlineSignatureVerifyGetResults" },
  { 0x3008c, "XOnlineStorageUpload" },
  { 0x3008d, "XOnlineStorageDownload" },
  { 0x3008e, "XOnlineStorageGetProgress" },
  { 0x3008f, "_XOnlineStorageResolveName" },
  { 0x30090, "_XOnlineStorageResolveNameResults" },
  { 0x30091, "_XOnlineStorageReportBrokenLink" },
  { 0x30092, "_XOnlineCreateRemoteFileReference" },
  { 0x30093, "_XOnlineDestroyRemoteFileReference" },
  { 0x30094, "_XOnlineStorageGetInstallLocation" },
  { 0x40001, "accept" },
  { 0x40002, "bind" },
  { 0x40003, "closesocket" },
  { 0x40004, "connect" },
  { 0x40005, "getpeername" },
  { 0x40006, "getsockname" },
  { 0x40007, "getsockopt" },
  { 0x40008, "htonl" },
  { 0x40009, "htons" },
  { 0x4000a, "inet_addr" },
  { 0x4000b, "ioctlsocket" },
  { 0x4000c, "listen" },
  { 0x4000d, "ntohl" },
  { 0x4000e, "ntohs" },
  { 0x4000f, "recv" },
  { 0x40010, "recvfrom" },
  { 0x40011, "select" },
  { 0x40012, "send" },
  { 0x40013, "sendto" },
  { 0x40014, "setsockopt" },
  { 0x40015, "shutdown" },
  { 0x40016, "socket" },
  { 0x40017, "__WSAFDIsSet" },
  { 0x40018, "WSAStartup" },
  { 0x40019, "WSACleanup" },
  { 0x4001a, "WSASetLastError" },
  { 0x4001b, "WSAGetLastError" },
  { 0x4001c, "WSACloseEvent" },
  { 0x4001d, "WSACreateEvent" },
  { 0x4001e, "WSAGetOverlappedResult" },
  { 0x4001f, "WSARecv" },
  { 0x40020, "WSARecvFrom" },
  { 0x40021, "WSAResetEvent" },
  { 0x40022, "WSASend" },
  { 0x40023, "WSASendTo" },
  { 0x40024, "WSASetEvent" },
  { 0x40025, "WSAWaitForMultipleEvents" },
  { 0x40026, "XNetStartup" },
  { 0x40027, "XNetCleanup" },
  { 0x40028, "XNetRandom" },
  { 0x40029, "XNetCreateKey" },
  { 0x4002a, "XNetRegisterKey" },
  { 0x4002b, "XNetUnregisterKey" },
  { 0x4002c, "XNetXnAddrToInAddr" },
  { 0x4002d, "XNetServerToInAddr" },
  { 0x4002e, "XNetInAddrToXnAddr" },
  { 0x4002f, "XNetInAddrToString" },
  { 0x40030, "XNetUnregisterInAddr" },
  { 0x40031, "XNetConnect" },
  { 0x40032, "XNetGetConnectStatus" },
  { 0x40033, "XNetDnsLookup" },
  { 0x40034, "XNetDnsRelease" },
  { 0x40035, "XNetQosListen" },
  { 0x40036, "XNetQosLookup" },
  { 0x40037, "XNetQosRelease" },
  { 0x40038, "XNetGetTitleXnAddr" },
  { 0x40039, "XNetGetDebugXnAddr" },
  { 0x4003a, "XNetGetEthernetLinkStatus" },
  { 0x4003b, "WSACancelOverlappedIO" },
  { 0x4003c, "XnInit" },
  { 0x4003d, "XnTerm" },
  { 0x4003e, "XNetOpenConfigVolume" },
  { 0x4003f, "XNetLoadConfigSector" },
  { 0x40040, "XNetSaveConfigSector" },
  { 0x40041, "XNetCloseConfigVolume" },
  { 0x40042, "XNetLoadConfigParams" },
  { 0x40043, "XNetSaveConfigParams" },
  { 0x40044, "XNetUpdateConfigParams" },
  { 0x40045, "XNetConfigUPnP" },
  { 0x40046, "XNetConfig" },
  { 0x40047, "XNetGetConfigStatus" },
  { 0x40048, "XNetCapture" }
};

// Function mappings for D3D
std::unordered_map<uint32_t, std::string> functions_D3D = {
  { 0x80001, "D3D__Device" },
  { 0x80002, "D3D__NullHardware" },
  { 0x80003, "D3D__pDevice" },
  { 0x80004, "D3D__SingleStepPusher" },
  { 0x80005, "D3D_AllocContiguousMemory" },
  { 0x80006, "D3D_CopyContiguousMemoryToVideo" },
  { 0x80007, "D3D_FreeContiguousMemory" },
  { 0x80008, "D3DBaseTexture_AddRef" },
  { 0x80009, "D3DBaseTexture_BlockUntilNotBusy" },
  { 0x8000a, "D3DBaseTexture_FreePrivateData" },
  { 0x8000b, "D3DBaseTexture_GetDevice" },
  { 0x8000c, "D3DBaseTexture_GetLevelCount" },
  { 0x8000d, "D3DBaseTexture_GetPrivateData" },
  { 0x8000e, "D3DBaseTexture_GetType" },
  { 0x8000f, "D3DBaseTexture_IsBusy" },
  { 0x80010, "D3DBaseTexture_MoveResourceMemory" },
  { 0x80011, "D3DBaseTexture_Register" },
  { 0x80012, "D3DBaseTexture_Release" },
  { 0x80013, "D3DBaseTexture_SetPrivateData" },
  { 0x80014, "D3DCubeTexture_AddRef" },
  { 0x80015, "D3DCubeTexture_BlockUntilNotBusy" },
  { 0x80016, "D3DCubeTexture_FreePrivateData" },
  { 0x80017, "D3DCubeTexture_GetCubeMapSurface2" },
  { 0x80018, "D3DCubeTexture_GetDevice" },
  { 0x80019, "D3DCubeTexture_GetLevelCount" },
  { 0x8001a, "D3DCubeTexture_GetLevelDesc" },
  { 0x8001b, "D3DCubeTexture_GetPrivateData" },
  { 0x8001c, "D3DCubeTexture_GetType" },
  { 0x8001d, "D3DCubeTexture_IsBusy" },
  { 0x8001e, "D3DCubeTexture_LockRect" },
  { 0x8001f, "D3DCubeTexture_MoveResourceMemory" },
  { 0x80020, "D3DCubeTexture_Register" },
  { 0x80021, "D3DCubeTexture_Release" },
  { 0x80022, "D3DCubeTexture_SetPrivateData" },
  { 0x80023, "D3DCubeTexture_UnlockRect" },
  { 0x80024, "D3DFixup_AddRef" },
  { 0x80025, "D3DFixup_BlockUntilNotBusy" },
  { 0x80026, "D3DFixup_FreePrivateData" },
  { 0x80027, "D3DFixup_GetDevice" },
  { 0x80028, "D3DFixup_GetPrivateData" },
  { 0x80029, "D3DFixup_GetSize" },
  { 0x8002a, "D3DFixup_GetSpace" },
  { 0x8002b, "D3DFixup_GetType" },
  { 0x8002c, "D3DFixup_IsBusy" },
  { 0x8002d, "D3DFixup_MoveResourceMemory" },
  { 0x8002e, "D3DFixup_Register" },
  { 0x8002f, "D3DFixup_Release" },
  { 0x80030, "D3DFixup_Reset" },
  { 0x80031, "D3DFixup_SetPrivateData" },
  { 0x80032, "D3DIndexBuffer_AddRef" },
  { 0x80033, "D3DIndexBuffer_BlockUntilNotBusy" },
  { 0x80034, "D3DIndexBuffer_FreePrivateData" },
  { 0x80035, "D3DIndexBuffer_GetDesc" },
  { 0x80036, "D3DIndexBuffer_GetDevice" },
  { 0x80037, "D3DIndexBuffer_GetPrivateData" },
  { 0x80038, "D3DIndexBuffer_GetType" },
  { 0x80039, "D3DIndexBuffer_IsBusy" },
  { 0x8003a, "D3DIndexBuffer_Lock" },
  { 0x8003b, "D3DIndexBuffer_MoveResourceMemory" },
  { 0x8003c, "D3DIndexBuffer_Register" },
  { 0x8003d, "D3DIndexBuffer_Release" },
  { 0x8003e, "D3DIndexBuffer_SetPrivateData" },
  { 0x8003f, "D3DIndexBuffer_Unlock" },
  { 0x80040, "D3DPalette_AddRef" },
  { 0x80041, "D3DPalette_BlockUntilNotBusy" },
  { 0x80042, "D3DPalette_FreePrivateData" },
  { 0x80043, "D3DPalette_GetDevice" },
  { 0x80044, "D3DPalette_GetPrivateData" },
  { 0x80045, "D3DPalette_GetSize" },
  { 0x80046, "D3DPalette_GetType" },
  { 0x80047, "D3DPalette_IsBusy" },
  { 0x80048, "D3DPalette_Lock2" },
  { 0x80049, "D3DPalette_MoveResourceMemory" },
  { 0x8004a, "D3DPalette_Register" },
  { 0x8004b, "D3DPalette_Release" },
  { 0x8004c, "D3DPalette_SetPrivateData" },
  { 0x8004d, "D3DPalette_Unlock" },
  { 0x8004e, "D3DPushBuffer_AddRef" },
  { 0x8004f, "D3DPushBuffer_BeginFixup" },
  { 0x80050, "D3DPushBuffer_BlockUntilNotBusy" },
  { 0x80051, "D3DPushBuffer_CopyRects" },
  { 0x80052, "D3DPushBuffer_EndFixup" },
  { 0x80053, "D3DPushBuffer_EndVisibilityTest" },
  { 0x80054, "D3DPushBuffer_FreePrivateData" },
  { 0x80055, "D3DPushBuffer_GetDevice" },
  { 0x80056, "D3DPushBuffer_GetPrivateData" },
  { 0x80057, "D3DPushBuffer_GetType" },
  { 0x80058, "D3DPushBuffer_IsBusy" },
  { 0x80059, "D3DPushBuffer_Jump" },
  { 0x8005a, "D3DPushBuffer_MoveResourceMemory" },
  { 0x8005b, "D3DPushBuffer_Register" },
  { 0x8005c, "D3DPushBuffer_Release" },
  { 0x8005d, "D3DPushBuffer_RunPushBuffer" },
  { 0x8005e, "D3DPushBuffer_SetModelView" },
  { 0x8005f, "D3DPushBuffer_SetPalette" },
  { 0x80060, "D3DPushBuffer_SetPrivateData" },
  { 0x80061, "D3DPushBuffer_SetRenderState" },
  { 0x80062, "D3DPushBuffer_SetRenderTarget" },
  { 0x80063, "D3DPushBuffer_SetTexture" },
  { 0x80064, "D3DPushBuffer_SetVertexBlendModelView" },
  { 0x80065, "D3DPushBuffer_SetVertexShaderConstant" },
  { 0x80066, "D3DPushBuffer_SetVertexShaderInput" },
  { 0x80067, "D3DPushBuffer_SetVertexShaderInputDirect" },
  { 0x80068, "D3DPushBuffer_Verify" },
  { 0x80069, "D3DResource_AddRef" },
  { 0x8006a, "D3DResource_BlockUntilNotBusy" },
  { 0x8006b, "D3DResource_FreePrivateData" },
  { 0x8006c, "D3DResource_GetDevice" },
  { 0x8006d, "D3DResource_GetPrivateData" },
  { 0x8006e, "D3DResource_GetType" },
  { 0x8006f, "D3DResource_IsBusy" },
  { 0x80070, "D3DResource_MoveResourceMemory" },
  { 0x80071, "D3DResource_Register" },
  { 0x80072, "D3DResource_Release" },
  { 0x80073, "D3DResource_SetPrivateData" },
  { 0x80074, "D3DSurface_AddRef" },
  { 0x80075, "D3DSurface_BlockUntilNotBusy" },
  { 0x80076, "D3DSurface_FreePrivateData" },
  { 0x80077, "D3DSurface_GetContainer2" },
  { 0x80078, "D3DSurface_GetDesc" },
  { 0x80079, "D3DSurface_GetDevice" },
  { 0x8007a, "D3DSurface_GetPrivateData" },
  { 0x8007b, "D3DSurface_GetType" },
  { 0x8007c, "D3DSurface_IsBusy" },
  { 0x8007d, "D3DSurface_LockRect" },
  { 0x8007e, "D3DSurface_MoveResourceMemory" },
  { 0x8007f, "D3DSurface_Register" },
  { 0x80080, "D3DSurface_Release" },
  { 0x80081, "D3DSurface_SetPrivateData" },
  { 0x80082, "D3DSurface_UnlockRect" },
  { 0x80083, "D3DTexture_AddRef" },
  { 0x80084, "D3DTexture_BlockUntilNotBusy" },
  { 0x80085, "D3DTexture_FreePrivateData" },
  { 0x80086, "D3DTexture_GetDevice" },
  { 0x80087, "D3DTexture_GetLevelCount" },
  { 0x80088, "D3DTexture_GetLevelDesc" },
  { 0x80089, "D3DTexture_GetPrivateData" },
  { 0x8008a, "D3DTexture_GetSurfaceLevel2" },
  { 0x8008b, "D3DTexture_GetType" },
  { 0x8008c, "D3DTexture_IsBusy" },
  { 0x8008d, "D3DTexture_LockRect" },
  { 0x8008e, "D3DTexture_MoveResourceMemory" },
  { 0x8008f, "D3DTexture_Register" },
  { 0x80090, "D3DTexture_Release" },
  { 0x80091, "D3DTexture_SetPrivateData" },
  { 0x80092, "D3DTexture_UnlockRect" },
  { 0x80093, "D3DVertexBuffer_AddRef" },
  { 0x80094, "D3DVertexBuffer_BlockUntilNotBusy" },
  { 0x80095, "D3DVertexBuffer_FreePrivateData" },
  { 0x80096, "D3DVertexBuffer_GetDesc" },
  { 0x80097, "D3DVertexBuffer_GetDevice" },
  { 0x80098, "D3DVertexBuffer_GetPrivateData" },
  { 0x80099, "D3DVertexBuffer_GetType" },
  { 0x8009a, "D3DVertexBuffer_IsBusy" },
  { 0x8009b, "D3DVertexBuffer_Lock2" },
  { 0x8009c, "D3DVertexBuffer_MoveResourceMemory" },
  { 0x8009d, "D3DVertexBuffer_Register" },
  { 0x8009e, "D3DVertexBuffer_Release" },
  { 0x8009f, "D3DVertexBuffer_SetPrivateData" },
  { 0x800a0, "D3DVertexBuffer_Unlock" },
  { 0x800a1, "D3DVolume_AddRef" },
  { 0x800a2, "D3DVolume_BlockUntilNotBusy" },
  { 0x800a3, "D3DVolume_FreePrivateData" },
  { 0x800a4, "D3DVolume_GetContainer2" },
  { 0x800a5, "D3DVolume_GetDesc" },
  { 0x800a6, "D3DVolume_GetDevice" },
  { 0x800a7, "D3DVolume_GetPrivateData" },
  { 0x800a8, "D3DVolume_GetType" },
  { 0x800a9, "D3DVolume_IsBusy" },
  { 0x800aa, "D3DVolume_LockBox" },
  { 0x800ab, "D3DVolume_MoveResourceMemory" },
  { 0x800ac, "D3DVolume_Register" },
  { 0x800ad, "D3DVolume_Release" },
  { 0x800ae, "D3DVolume_SetPrivateData" },
  { 0x800af, "D3DVolume_UnlockBox" },
  { 0x800b0, "D3DVolumeTexture_AddRef" },
  { 0x800b1, "D3DVolumeTexture_BlockUntilNotBusy" },
  { 0x800b2, "D3DVolumeTexture_FreePrivateData" },
  { 0x800b3, "D3DVolumeTexture_GetDevice" },
  { 0x800b4, "D3DVolumeTexture_GetLevelCount" },
  { 0x800b5, "D3DVolumeTexture_GetLevelDesc" },
  { 0x800b6, "D3DVolumeTexture_GetPrivateData" },
  { 0x800b7, "D3DVolumeTexture_GetType" },
  { 0x800b8, "D3DVolumeTexture_GetVolumeLevel2" },
  { 0x800b9, "D3DVolumeTexture_IsBusy" },
  { 0x800ba, "D3DVolumeTexture_LockBox" },
  { 0x800bb, "D3DVolumeTexture_MoveResourceMemory" },
  { 0x800bc, "D3DVolumeTexture_Register" },
  { 0x800bd, "D3DVolumeTexture_Release" },
  { 0x800be, "D3DVolumeTexture_SetPrivateData" },
  { 0x800bf, "D3DVolumeTexture_UnlockBox" },
  { 0x800c0, "Direct3D_AddRef" },
  { 0x800c1, "Direct3D_CheckDepthStencilMatch" },
  { 0x800c2, "Direct3D_CheckDeviceFormat" },
  { 0x800c3, "Direct3D_CheckDeviceMultiSampleType" },
  { 0x800c4, "Direct3D_CheckDeviceType" },
  { 0x800c5, "Direct3D_CreateDevice" },
  { 0x800c6, "Direct3D_EnumAdapterModes" },
  { 0x800c7, "Direct3D_GetAdapterCount" },
  { 0x800c8, "Direct3D_GetAdapterDisplayMode" },
  { 0x800c9, "Direct3D_GetAdapterIdentifier" },
  { 0x800ca, "Direct3D_GetAdapterModeCount" },
  { 0x800cb, "Direct3D_GetDeviceCaps" },
  { 0x800cc, "Direct3D_Release" },
  { 0x800cd, "Direct3D_SetPushBufferSize" },
  { 0x800ce, "IDirect3D8_AddRef" },
  { 0x800cf, "IDirect3D8_CheckDepthStencilMatch" },
  { 0x800d0, "IDirect3D8_CheckDeviceFormat" },
  { 0x800d1, "IDirect3D8_CheckDeviceMultiSampleType" },
  { 0x800d2, "IDirect3D8_CheckDeviceType" },
  { 0x800d3, "IDirect3D8_CreateDevice" },
  { 0x800d4, "IDirect3D8_EnumAdapterModes" },
  { 0x800d5, "IDirect3D8_GetAdapterCount" },
  { 0x800d6, "IDirect3D8_GetAdapterDisplayMode" },
  { 0x800d7, "IDirect3D8_GetAdapterIdentifier" },
  { 0x800d8, "IDirect3D8_GetAdapterModeCount" },
  { 0x800d9, "IDirect3D8_GetDeviceCaps" },
  { 0x800da, "IDirect3D8_Release" },
  { 0x800db, "IDirect3D8_SetPushBufferSize" },
  { 0x800dc, "IDirect3DBaseTexture8_AddRef" },
  { 0x800dd, "IDirect3DBaseTexture8_BlockUntilNotBusy" },
  { 0x800de, "IDirect3DBaseTexture8_FreePrivateData" },
  { 0x800df, "IDirect3DBaseTexture8_GetDevice" },
  { 0x800e0, "IDirect3DBaseTexture8_GetLevelCount" },
  { 0x800e1, "IDirect3DBaseTexture8_GetPrivateData" },
  { 0x800e2, "IDirect3DBaseTexture8_GetType" },
  { 0x800e3, "IDirect3DBaseTexture8_IsBusy" },
  { 0x800e4, "IDirect3DBaseTexture8_MoveResourceMemory" },
  { 0x800e5, "IDirect3DBaseTexture8_Register" },
  { 0x800e6, "IDirect3DBaseTexture8_Release" },
  { 0x800e7, "IDirect3DBaseTexture8_SetPrivateData" },
  { 0x800e8, "IDirect3DCubeTexture8_AddRef" },
  { 0x800e9, "IDirect3DCubeTexture8_BlockUntilNotBusy" },
  { 0x800ea, "IDirect3DCubeTexture8_FreePrivateData" },
  { 0x800eb, "IDirect3DCubeTexture8_GetCubeMapSurface" },
  { 0x800ec, "IDirect3DCubeTexture8_GetDevice" },
  { 0x800ed, "IDirect3DCubeTexture8_GetLevelCount" },
  { 0x800ee, "IDirect3DCubeTexture8_GetLevelDesc" },
  { 0x800ef, "IDirect3DCubeTexture8_GetPrivateData" },
  { 0x800f0, "IDirect3DCubeTexture8_GetType" },
  { 0x800f1, "IDirect3DCubeTexture8_IsBusy" },
  { 0x800f2, "IDirect3DCubeTexture8_LockRect" },
  { 0x800f3, "IDirect3DCubeTexture8_MoveResourceMemory" },
  { 0x800f4, "IDirect3DCubeTexture8_Register" },
  { 0x800f5, "IDirect3DCubeTexture8_Release" },
  { 0x800f6, "IDirect3DCubeTexture8_SetPrivateData" },
  { 0x800f7, "IDirect3DCubeTexture8_UnlockRect" },
  { 0x800f8, "IDirect3DFixup8_AddRef" },
  { 0x800f9, "IDirect3DFixup8_BlockUntilNotBusy" },
  { 0x800fa, "IDirect3DFixup8_FreePrivateData" },
  { 0x800fb, "IDirect3DFixup8_GetDevice" },
  { 0x800fc, "IDirect3DFixup8_GetPrivateData" },
  { 0x800fd, "IDirect3DFixup8_GetSize" },
  { 0x800fe, "IDirect3DFixup8_GetSpace" },
  { 0x800ff, "IDirect3DFixup8_GetType" },
  { 0x80100, "IDirect3DFixup8_IsBusy" },
  { 0x80101, "IDirect3DFixup8_MoveResourceMemory" },
  { 0x80102, "IDirect3DFixup8_Register" },
  { 0x80103, "IDirect3DFixup8_Release" },
  { 0x80104, "IDirect3DFixup8_Reset" },
  { 0x80105, "IDirect3DFixup8_SetPrivateData" },
  { 0x80106, "IDirect3DIndexBuffer8_AddRef" },
  { 0x80107, "IDirect3DIndexBuffer8_BlockUntilNotBusy" },
  { 0x80108, "IDirect3DIndexBuffer8_FreePrivateData" },
  { 0x80109, "IDirect3DIndexBuffer8_GetDesc" },
  { 0x8010a, "IDirect3DIndexBuffer8_GetDevice" },
  { 0x8010b, "IDirect3DIndexBuffer8_GetPrivateData" },
  { 0x8010c, "IDirect3DIndexBuffer8_GetType" },
  { 0x8010d, "IDirect3DIndexBuffer8_IsBusy" },
  { 0x8010e, "IDirect3DIndexBuffer8_Lock" },
  { 0x8010f, "IDirect3DIndexBuffer8_MoveResourceMemory" },
  { 0x80110, "IDirect3DIndexBuffer8_Register" },
  { 0x80111, "IDirect3DIndexBuffer8_Release" },
  { 0x80112, "IDirect3DIndexBuffer8_SetPrivateData" },
  { 0x80113, "IDirect3DIndexBuffer8_Unlock" },
  { 0x80114, "IDirect3DPalette8_AddRef" },
  { 0x80115, "IDirect3DPalette8_BlockUntilNotBusy" },
  { 0x80116, "IDirect3DPalette8_FreePrivateData" },
  { 0x80117, "IDirect3DPalette8_GetDevice" },
  { 0x80118, "IDirect3DPalette8_GetPrivateData" },
  { 0x80119, "IDirect3DPalette8_GetSize" },
  { 0x8011a, "IDirect3DPalette8_GetType" },
  { 0x8011b, "IDirect3DPalette8_IsBusy" },
  { 0x8011c, "IDirect3DPalette8_Lock" },
  { 0x8011d, "IDirect3DPalette8_MoveResourceMemory" },
  { 0x8011e, "IDirect3DPalette8_Register" },
  { 0x8011f, "IDirect3DPalette8_Release" },
  { 0x80120, "IDirect3DPalette8_SetPrivateData" },
  { 0x80121, "IDirect3DPalette8_Unlock" },
  { 0x80122, "IDirect3DPushBuffer8_AddRef" },
  { 0x80123, "IDirect3DPushBuffer8_BeginFixup" },
  { 0x80124, "IDirect3DPushBuffer8_BlockUntilNotBusy" },
  { 0x80125, "IDirect3DPushBuffer8_CopyRects" },
  { 0x80126, "IDirect3DPushBuffer8_EndFixup" },
  { 0x80127, "IDirect3DPushBuffer8_EndVisibilityTest" },
  { 0x80128, "IDirect3DPushBuffer8_FreePrivateData" },
  { 0x80129, "IDirect3DPushBuffer8_GetDevice" },
  { 0x8012a, "IDirect3DPushBuffer8_GetPrivateData" },
  { 0x8012b, "IDirect3DPushBuffer8_GetSize" },
  { 0x8012c, "IDirect3DPushBuffer8_GetType" },
  { 0x8012d, "IDirect3DPushBuffer8_IsBusy" },
  { 0x8012e, "IDirect3DPushBuffer8_Jump" },
  { 0x8012f, "IDirect3DPushBuffer8_MoveResourceMemory" },
  { 0x80130, "IDirect3DPushBuffer8_Register" },
  { 0x80131, "IDirect3DPushBuffer8_Release" },
  { 0x80132, "IDirect3DPushBuffer8_RunPushBuffer" },
  { 0x80133, "IDirect3DPushBuffer8_SetModelView" },
  { 0x80134, "IDirect3DPushBuffer8_SetPalette" },
  { 0x80135, "IDirect3DPushBuffer8_SetPrivateData" },
  { 0x80136, "IDirect3DPushBuffer8_SetRenderState" },
  { 0x80137, "IDirect3DPushBuffer8_SetRenderTarget" },
  { 0x80138, "IDirect3DPushBuffer8_SetTexture" },
  { 0x80139, "IDirect3DPushBuffer8_SetVertexBlendModelView" },
  { 0x8013a, "IDirect3DPushBuffer8_SetVertexShaderConstant" },
  { 0x8013b, "IDirect3DPushBuffer8_SetVertexShaderInput" },
  { 0x8013c, "IDirect3DPushBuffer8_SetVertexShaderInputDirect" },
  { 0x8013d, "IDirect3DPushBuffer8_Verify" },
  { 0x8013e, "IDirect3DResource8_AddRef" },
  { 0x8013f, "IDirect3DResource8_BlockUntilNotBusy" },
  { 0x80140, "IDirect3DResource8_FreePrivateData" },
  { 0x80141, "IDirect3DResource8_GetDevice" },
  { 0x80142, "IDirect3DResource8_GetPrivateData" },
  { 0x80143, "IDirect3DResource8_GetType" },
  { 0x80144, "IDirect3DResource8_IsBusy" },
  { 0x80145, "IDirect3DResource8_MoveResourceMemory" },
  { 0x80146, "IDirect3DResource8_Register" },
  { 0x80147, "IDirect3DResource8_Release" },
  { 0x80148, "IDirect3DResource8_SetPrivateData" },
  { 0x80149, "IDirect3DSurface8_AddRef" },
  { 0x8014a, "IDirect3DSurface8_BlockUntilNotBusy" },
  { 0x8014b, "IDirect3DSurface8_FreePrivateData" },
  { 0x8014c, "IDirect3DSurface8_GetContainer" },
  { 0x8014d, "IDirect3DSurface8_GetDesc" },
  { 0x8014e, "IDirect3DSurface8_GetDevice" },
  { 0x8014f, "IDirect3DSurface8_GetPrivateData" },
  { 0x80150, "IDirect3DSurface8_GetType" },
  { 0x80151, "IDirect3DSurface8_IsBusy" },
  { 0x80152, "IDirect3DSurface8_LockRect" },
  { 0x80153, "IDirect3DSurface8_MoveResourceMemory" },
  { 0x80154, "IDirect3DSurface8_Register" },
  { 0x80155, "IDirect3DSurface8_Release" },
  { 0x80156, "IDirect3DSurface8_SetPrivateData" },
  { 0x80157, "IDirect3DSurface8_UnlockRect" },
  { 0x80158, "IDirect3DTexture8_AddRef" },
  { 0x80159, "IDirect3DTexture8_BlockUntilNotBusy" },
  { 0x8015a, "IDirect3DTexture8_FreePrivateData" },
  { 0x8015b, "IDirect3DTexture8_GetDevice" },
  { 0x8015c, "IDirect3DTexture8_GetLevelCount" },
  { 0x8015d, "IDirect3DTexture8_GetLevelDesc" },
  { 0x8015e, "IDirect3DTexture8_GetPrivateData" },
  { 0x8015f, "IDirect3DTexture8_GetSurfaceLevel" },
  { 0x80160, "IDirect3DTexture8_GetType" },
  { 0x80161, "IDirect3DTexture8_IsBusy" },
  { 0x80162, "IDirect3DTexture8_LockRect" },
  { 0x80163, "IDirect3DTexture8_MoveResourceMemory" },
  { 0x80164, "IDirect3DTexture8_Register" },
  { 0x80165, "IDirect3DTexture8_Release" },
  { 0x80166, "IDirect3DTexture8_SetPrivateData" },
  { 0x80167, "IDirect3DTexture8_UnlockRect" },
  { 0x80168, "IDirect3DVertexBuffer8_AddRef" },
  { 0x80169, "IDirect3DVertexBuffer8_BlockUntilNotBusy" },
  { 0x8016a, "IDirect3DVertexBuffer8_FreePrivateData" },
  { 0x8016b, "IDirect3DVertexBuffer8_GetDesc" },
  { 0x8016c, "IDirect3DVertexBuffer8_GetDevice" },
  { 0x8016d, "IDirect3DVertexBuffer8_GetPrivateData" },
  { 0x8016e, "IDirect3DVertexBuffer8_GetType" },
  { 0x8016f, "IDirect3DVertexBuffer8_IsBusy" },
  { 0x80170, "IDirect3DVertexBuffer8_Lock" },
  { 0x80171, "IDirect3DVertexBuffer8_MoveResourceMemory" },
  { 0x80172, "IDirect3DVertexBuffer8_Register" },
  { 0x80173, "IDirect3DVertexBuffer8_Release" },
  { 0x80174, "IDirect3DVertexBuffer8_SetPrivateData" },
  { 0x80175, "IDirect3DVertexBuffer8_Unlock" },
  { 0x80176, "IDirect3DVolume8_AddRef" },
  { 0x80177, "IDirect3DVolume8_BlockUntilNotBusy" },
  { 0x80178, "IDirect3DVolume8_FreePrivateData" },
  { 0x80179, "IDirect3DVolume8_GetContainer" },
  { 0x8017a, "IDirect3DVolume8_GetDesc" },
  { 0x8017b, "IDirect3DVolume8_GetDevice" },
  { 0x8017c, "IDirect3DVolume8_GetPrivateData" },
  { 0x8017d, "IDirect3DVolume8_GetType" },
  { 0x8017e, "IDirect3DVolume8_IsBusy" },
  { 0x8017f, "IDirect3DVolume8_LockBox" },
  { 0x80180, "IDirect3DVolume8_MoveResourceMemory" },
  { 0x80181, "IDirect3DVolume8_Register" },
  { 0x80182, "IDirect3DVolume8_Release" },
  { 0x80183, "IDirect3DVolume8_SetPrivateData" },
  { 0x80184, "IDirect3DVolume8_UnlockBox" },
  { 0x80185, "IDirect3DVolumeTexture8_AddRef" },
  { 0x80186, "IDirect3DVolumeTexture8_BlockUntilNotBusy" },
  { 0x80187, "IDirect3DVolumeTexture8_FreePrivateData" },
  { 0x80188, "IDirect3DVolumeTexture8_GetDevice" },
  { 0x80189, "IDirect3DVolumeTexture8_GetLevelCount" },
  { 0x8018a, "IDirect3DVolumeTexture8_GetLevelDesc" },
  { 0x8018b, "IDirect3DVolumeTexture8_GetPrivateData" },
  { 0x8018c, "IDirect3DVolumeTexture8_GetType" },
  { 0x8018d, "IDirect3DVolumeTexture8_GetVolumeLevel" },
  { 0x8018e, "IDirect3DVolumeTexture8_IsBusy" },
  { 0x8018f, "IDirect3DVolumeTexture8_LockBox" },
  { 0x80191, "IDirect3DVolumeTexture8_MoveResourceMemory" },
  { 0x80192, "IDirect3DVolumeTexture8_Register" },
  { 0x80193, "IDirect3DVolumeTexture8_Release" },
  { 0x80194, "IDirect3DVolumeTexture8_SetPrivateData" },
  { 0x80195, "IDirect3DVolumeTexture8_UnlockBox" }
};

// Function mappings for XVOICE
std::unordered_map<uint32_t, std::string> functions_XVOICE = {
  { 0x70001, "XDEVICE_TYPE_HIGHFIDELITY_MICROPHONE_TABLE" },
  { 0x70002, "XDEVICE_TYPE_VOICE_HEADPHONE_TABLE" },
  { 0x70003, "XDEVICE_TYPE_VOICE_MICROPHONE_TABLE" },
  { 0x70004, "XVoiceCreateFourToFourFullDecoder" },
  { 0x70005, "XVoiceCreateFourToFourFullEncoder" },
  { 0x70006, "XVoiceCreateFourToFourRoundRobinEncoder" },
  { 0x70007, "XVoiceCreateFourToOneMixingDecoder" },
  { 0x70008, "XVoiceCreateMediaObject" },
  { 0x70009, "XVoiceCreateMediaObjectEx" },
  { 0x7000a, "XVoiceCreateOneToOneDecoder" },
  { 0x7000b, "XVoiceCreateOneToOneEncoder" },
  { 0x7000c, "XVoiceCreateTwoToOneMixingDecoder" },
  { 0x7000d, "XVoiceCreateTwoToTwoEncoder" },
  { 0x7000e, "XVoiceGetEncodedPacketEnergy" },
  { 0x7000f, "XVoiceQueueCreateMediaObject" },
  { 0x70010, "XVoiceSynchronizedQueueCreateMediaObject" }
};


```

`3rdparty/xtlid/xml-to-cpp-map.py`:

```py
import xml.etree.ElementTree as ET
from typing import Dict
import sys

def parse_xml_file_to_cpp_map(filename: str) -> Dict[str, Dict[str, str]]:
    """
    Parse XML file and return a dictionary of library names and their function mappings
    """
    try:
        # Parse the XML file
        tree = ET.parse(filename)
        root = tree.getroot()
        
        # Dictionary to store results for each library
        results = {}
        
        # Process each library
        for lib in root.findall('lib'):
            lib_name = lib.get('name')
            functions = {}
            
            # Process each function in the library
            for func in lib.findall('func'):
                # Convert the hex string to int and back to hex for consistent formatting
                func_id = int(func.get('id'), 16)
                func_name = func.get('name')
                functions[func_id] = func_name
                
            results[lib_name] = functions
            
        return results
    except FileNotFoundError:
        print(f"Error: Could not find file '{filename}'")
        sys.exit(1)
    except ET.ParseError as e:
        print(f"Error: Invalid XML in file '{filename}': {e}")
        sys.exit(1)
    except Exception as e:
        print(f"Error: An unexpected error occurred: {e}")
        sys.exit(1)

def generate_cpp_maps(mappings: Dict[str, Dict[str, str]]) -> str:
    """
    Generate C++ unordered_map declarations from the parsed data
    """
    cpp_output = []
    
    for lib_name, functions in mappings.items():
        # Create map declaration
        cpp_output.append(f"// Function mappings for {lib_name}")
        cpp_output.append(f"std::unordered_map<uint32_t, std::string> functions_{lib_name} = {{")
        
        # Add each function mapping
        entries = []
        for func_id, func_name in sorted(functions.items()):
            entries.append(f"  {{ 0x{func_id:x}, \"{func_name}\" }}")
            
        # Join entries with commas
        cpp_output.append(",\n".join(entries))
        
        # Close the map declaration
        cpp_output.append("};")
        cpp_output.append("")  # Empty line between libraries
        
    return "\n".join(cpp_output)

def main():
    # Use xtlid.xml as the input file
    filename = "xtlid.xml"
    
    try:
        # Parse XML file and generate output
        mappings = parse_xml_file_to_cpp_map(filename)
        cpp_output = generate_cpp_maps(mappings)
        print(cpp_output)
        
    except Exception as e:
        print(f"Error: Failed to process XML file: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()

```

`3rdparty/xtlid/xtlid.xml`:

```xml
<xtlid>
    <lib name="D3DX8" libnames="d3dx8 d3dx8d">
        <func id="0x90001" name="D3DXBoxBoundProbe" />
        <func id="0x90002" name="D3DXCheckCubeTextureRequirements" />
        <func id="0x90003" name="D3DXCheckTextureRequirements" />
        <func id="0x90004" name="D3DXCheckVolumeTextureRequirements" />
        <func id="0x90005" name="D3DXCleanMesh" />
        <func id="0x90006" name="D3DXColorAdd" />
        <func id="0x90007" name="D3DXColorAdjustContrast" />
        <func id="0x90008" name="D3DXColorAdjustSaturation" />
        <func id="0x90009" name="D3DXColorLerp" />
        <func id="0x9000a" name="D3DXColorModulate" />
        <func id="0x9000b" name="D3DXColorNegative" />
        <func id="0x9000c" name="D3DXColorScale" />
        <func id="0x9000d" name="D3DXColorSubtract" />
        <func id="0x9000e" name="D3DXCompileEffect" />
        <func id="0x9000f" name="D3DXCompileEffectFromFileA" />
        <func id="0x90010" name="D3DXComputeBoundingBox" />
        <func id="0x90011" name="D3DXComputeBoundingSphere" />
        <func id="0x90012" name="D3DXComputeNormals" />
        <func id="0x90013" name="D3DXCreateBox" />
        <func id="0x90014" name="D3DXCreateBuffer" />
        <func id="0x90015" name="D3DXCreateCubeTexture" />
        <func id="0x90016" name="D3DXCreateCubeTextureFromFileA" />
        <func id="0x90017" name="D3DXCreateCubeTextureFromFileExA" />
        <func id="0x90018" name="D3DXCreateCubeTextureFromFileInMemory" />
        <func id="0x90019" name="D3DXCreateCubeTextureFromFileInMemoryEx" />
        <func id="0x9001a" name="D3DXCreateCylinder" />
        <func id="0x9001b" name="D3DXCreateEffect" />
        <func id="0x9001c" name="D3DXCreateMatrixStack" />
        <func id="0x9001d" name="D3DXCreateMesh" />
        <func id="0x9001e" name="D3DXCreateMeshFVF" />
        <func id="0x9001f" name="D3DXCreatePMeshFromStream" />
        <func id="0x90020" name="D3DXCreatePolygon" />
        <func id="0x90021" name="D3DXCreateSkinMesh" />
        <func id="0x90022" name="D3DXCreateSkinMeshFromMesh" />
        <func id="0x90023" name="D3DXCreateSkinMeshFVF" />
        <func id="0x90024" name="D3DXCreateSphere" />
        <func id="0x90025" name="D3DXCreateSPMesh" />
        <func id="0x90026" name="D3DXCreateTeapot" />
        <func id="0x90027" name="D3DXCreateTexture" />
        <func id="0x90028" name="D3DXCreateTextureFromFileA" />
        <func id="0x90029" name="D3DXCreateTextureFromFileExA" />
        <func id="0x9002a" name="D3DXCreateTextureFromFileInMemory" />
        <func id="0x9002b" name="D3DXCreateTextureFromFileInMemoryEx" />
        <func id="0x9002c" name="D3DXCreateTorus" />
        <func id="0x9002d" name="D3DXCreateVolumeTexture" />
        <func id="0x9002e" name="D3DXDeclaratorFromFVF" />
        <func id="0x9002f" name="D3DXFilterCubeTexture" />
        <func id="0x90030" name="D3DXFilterTexture" />
        <func id="0x90031" name="D3DXFilterVolumeTexture" />
        <func id="0x90032" name="D3DXFVFFromDeclarator" />
        <func id="0x90033" name="D3DXGeneratePMesh" />
        <func id="0x90034" name="D3DXGetDXT3DXT5" />
        <func id="0x90035" name="D3DXIntersect" />
        <func id="0x90036" name="D3DXLoadMeshFromX" />
        <func id="0x90037" name="D3DXLoadMeshFromXof" />
        <func id="0x90038" name="D3DXLoadSkinMeshFromXof" />
        <func id="0x90039" name="D3DXLoadSurfaceFromFileA" />
        <func id="0x9003a" name="D3DXLoadSurfaceFromFileInMemory" />
        <func id="0x9003b" name="D3DXLoadSurfaceFromMemory" />
        <func id="0x9003c" name="D3DXLoadSurfaceFromSurface" />
        <func id="0x9003d" name="D3DXLoadVolumeFromMemory" />
        <func id="0x9003e" name="D3DXLoadVolumeFromVolume" />
        <func id="0x9003f" name="D3DXMatrixAffineTransformation" />
        <func id="0x90040" name="D3DXMatrixfDeterminant" />
        <func id="0x90041" name="D3DXMatrixIdentity" />
        <func id="0x90042" name="D3DXMatrixInverse" />
        <func id="0x90043" name="D3DXMatrixIsIdentity" />
        <func id="0x90044" name="D3DXMatrixLookAtLH" />
        <func id="0x90045" name="D3DXMatrixLookAtRH" />
        <func id="0x90046" name="D3DXMatrixMultiply" />
        <func id="0x90047" name="D3DXMatrixOrthoLH" />
        <func id="0x90048" name="D3DXMatrixOrthoOffCenterLH" />
        <func id="0x90049" name="D3DXMatrixOrthoOffCenterRH" />
        <func id="0x9004a" name="D3DXMatrixOrthoRH" />
        <func id="0x9004b" name="D3DXMatrixPerspectiveFovLH" />
        <func id="0x9004c" name="D3DXMatrixPerspectiveFovRH" />
        <func id="0x9004d" name="D3DXMatrixPerspectiveLH" />
        <func id="0x9004e" name="D3DXMatrixPerspectiveOffCenterLH" />
        <func id="0x9004f" name="D3DXMatrixPerspectiveOffCenterRH" />
        <func id="0x90050" name="D3DXMatrixPerspectiveRH" />
        <func id="0x90051" name="D3DXMatrixReflect" />
        <func id="0x90052" name="D3DXMatrixRotationAxis" />
        <func id="0x90053" name="D3DXMatrixRotationQuaternion" />
        <func id="0x90054" name="D3DXMatrixRotationX" />
        <func id="0x90055" name="D3DXMatrixRotationY" />
        <func id="0x90056" name="D3DXMatrixRotationYawPitchRoll" />
        <func id="0x90057" name="D3DXMatrixRotationZ" />
        <func id="0x90058" name="D3DXMatrixScaling" />
        <func id="0x90059" name="D3DXMatrixShadow" />
        <func id="0x9005a" name="D3DXMatrixTransformation" />
        <func id="0x9005b" name="D3DXMatrixTranslation" />
        <func id="0x9005c" name="D3DXMatrixTranspose" />
        <func id="0x9005d" name="D3DXPlaneDot" />
        <func id="0x9005e" name="D3DXPlaneDotCoord" />
        <func id="0x9005f" name="D3DXPlaneDotNormal" />
        <func id="0x90060" name="D3DXPlaneFromPointNormal" />
        <func id="0x90061" name="D3DXPlaneFromPoints" />
        <func id="0x90062" name="D3DXPlaneIntersectLine" />
        <func id="0x90063" name="D3DXPlaneNormalize" />
        <func id="0x90064" name="D3DXPlaneTransform" />
        <func id="0x90065" name="D3DXQuaternionBaryCentric" />
        <func id="0x90066" name="D3DXQuaternionConjugate" />
        <func id="0x90067" name="D3DXQuaternionDot" />
        <func id="0x90068" name="D3DXQuaternionExp" />
        <func id="0x90069" name="D3DXQuaternionIdentity" />
        <func id="0x9006a" name="D3DXQuaternionInverse" />
        <func id="0x9006b" name="D3DXQuaternionIsIdentity" />
        <func id="0x9006c" name="D3DXQuaternionLength" />
        <func id="0x9006d" name="D3DXQuaternionLengthSq" />
        <func id="0x9006e" name="D3DXQuaternionLn" />
        <func id="0x9006f" name="D3DXQuaternionMultiply" />
        <func id="0x90070" name="D3DXQuaternionNormalize" />
        <func id="0x90071" name="D3DXQuaternionRotationAxis" />
        <func id="0x90072" name="D3DXQuaternionRotationMatrix" />
        <func id="0x90073" name="D3DXQuaternionRotationYawPitchRoll" />
        <func id="0x90074" name="D3DXQuaternionSlerp" />
        <func id="0x90075" name="D3DXQuaternionSquad" />
        <func id="0x90076" name="D3DXQuaternionToAxisAngle" />
        <func id="0x90077" name="D3DXSaveMeshToX" />
        <func id="0x90078" name="D3DXSetDXT3DXT5" />
        <func id="0x90079" name="D3DXSimplifyMesh" />
        <func id="0x9007a" name="D3DXSphereBoundProbe" />
        <func id="0x9007b" name="D3DXTesselateMesh" />
        <func id="0x9007c" name="D3DXValidMesh" />
        <func id="0x9007d" name="D3DXVec2Add" />
        <func id="0x9007e" name="D3DXVec2BaryCentric" />
        <func id="0x9007f" name="D3DXVec2CatmullRom" />
        <func id="0x90080" name="D3DXVec2CCW" />
        <func id="0x90081" name="D3DXVec2Dot" />
        <func id="0x90082" name="D3DXVec2Hermite" />
        <func id="0x90083" name="D3DXVec2Length" />
        <func id="0x90084" name="D3DXVec2LengthSq" />
        <func id="0x90085" name="D3DXVec2Lerp" />
        <func id="0x90086" name="D3DXVec2Maximize" />
        <func id="0x90087" name="D3DXVec2Minimize" />
        <func id="0x90088" name="D3DXVec2Normalize" />
        <func id="0x90089" name="D3DXVec2Scale" />
        <func id="0x9008a" name="D3DXVec2Subtract" />
        <func id="0x9008b" name="D3DXVec2Transform" />
        <func id="0x9008c" name="D3DXVec2TransformCoord" />
        <func id="0x9008d" name="D3DXVec2TransformNormal" />
        <func id="0x9008e" name="D3DXVec3Add" />
        <func id="0x9008f" name="D3DXVec3BaryCentric" />
        <func id="0x90090" name="D3DXVec3CatmullRom" />
        <func id="0x90091" name="D3DXVec3Cross" />
        <func id="0x90092" name="D3DXVec3Dot" />
        <func id="0x90093" name="D3DXVec3Hermite" />
        <func id="0x90094" name="D3DXVec3Length" />
        <func id="0x90095" name="D3DXVec3LengthSq" />
        <func id="0x90096" name="D3DXVec3Lerp" />
        <func id="0x90097" name="D3DXVec3Maximize" />
        <func id="0x90098" name="D3DXVec3Minimize" />
        <func id="0x90099" name="D3DXVec3Normalize" />
        <func id="0x9009a" name="D3DXVec3Project" />
        <func id="0x9009b" name="D3DXVec3Scale" />
        <func id="0x9009c" name="D3DXVec3Subtract" />
        <func id="0x9009d" name="D3DXVec3Transform" />
        <func id="0x9009e" name="D3DXVec3TransformCoord" />
        <func id="0x9009f" name="D3DXVec3TransformNormal" />
        <func id="0x900a0" name="D3DXVec3Unproject" />
        <func id="0x900a1" name="D3DXVec4Add" />
        <func id="0x900a2" name="D3DXVec4BaryCentric" />
        <func id="0x900a3" name="D3DXVec4CatmullRom" />
        <func id="0x900a4" name="D3DXVec4Cross" />
        <func id="0x900a5" name="D3DXVec4Dot" />
        <func id="0x900a6" name="D3DXVec4Hermite" />
        <func id="0x900a7" name="D3DXVec4Length" />
        <func id="0x900a8" name="D3DXVec4LengthSq" />
        <func id="0x900a9" name="D3DXVec4Lerp" />
        <func id="0x900aa" name="D3DXVec4Maximize" />
        <func id="0x900ab" name="D3DXVec4Minimize" />
        <func id="0x900ac" name="D3DXVec4Normalize" />
        <func id="0x900ad" name="D3DXVec4Scale" />
        <func id="0x900ae" name="D3DXVec4Subtract" />
        <func id="0x900af" name="D3DXVec4Transform" />
        <func id="0x900b0" name="D3DXWeldVertices" />
    </lib>
    <lib name="DMUSIC" libnames="dmusic dmusicd dmusici dmusicltcg">
        <func id="0xa0001" name="DirectMusicAlloc" />
        <func id="0xa0002" name="DirectMusicCreateDefaultHeap" />
        <func id="0xa0003" name="DirectMusicCreateDefaultPhysicalHeap" />
        <func id="0xa0004" name="DirectMusicCreateFixedSizeHeap" />
        <func id="0xa0005" name="DirectMusicCreateFixedSizePhysicalHeap" />
        <func id="0xa0006" name="DirectMusicCreateInstance" />
        <func id="0xa0007" name="DirectMusicDefaultFactory" />
        <func id="0xa0008" name="DirectMusicDoWork" />
        <func id="0xa0009" name="DirectMusicFree" />
        <func id="0xa000a" name="DirectMusicInitialize" />
        <func id="0xa000b" name="DirectMusicInitializeEx" />
        <func id="0xa000c" name="DirectMusicInitializeFixedSizeHeaps" />
        <func id="0xa000d" name="DirectMusicMemCheck" />
        <func id="0xa000e" name="DirectMusicMemDump" />
        <func id="0xa000f" name="DirectMusicPhysicalAlloc" />
        <func id="0xa0010" name="DirectMusicPhysicalFree" />
        <func id="0xa0011" name="DirectMusicSetDebugLevel" />
    </lib>
    <lib name="DSOUND" libnames="dsound dsoundd">
        <func id="0xb0001" name="Ac97CreateMediaObject" />
        <func id="0xb0002" name="DirectSoundCreate" />
        <func id="0xb0003" name="DirectSoundCreateBuffer" />
        <func id="0xb0004" name="DirectSoundCreateStream" />
        <func id="0xb0005" name="DirectSoundDefaulMixBins_5Channel3D_PlusLFE" />
        <func id="0xb0006" name="DirectSoundDefault3DBuffer" />
        <func id="0xb0007" name="DirectSoundDefault3DListener" />
        <func id="0xb0008" name="DirectSoundDefaultI3DL2Buffer" />
        <func id="0xb0009" name="DirectSoundDefaultMixBins_3D" />
        <func id="0xb000a" name="DirectSoundDefaultMixBins_4Channel" />
        <func id="0xb000b" name="DirectSoundDefaultMixBins_5Channel3D" />
        <func id="0xb000c" name="DirectSoundDefaultMixBins_6Channel" />
        <func id="0xb000d" name="DirectSoundDefaultMixBins_Mono" />
        <func id="0xb000e" name="DirectSoundDefaultMixBins_Stereo" />
        <func id="0xb000f" name="DirectSoundDoWork" />
        <func id="0xb0010" name="DirectSoundDumpMemoryUsage" />
        <func id="0xb0011" name="DirectSoundGetSampleTime" />
        <func id="0xb0012" name="DirectSoundI3DL2ListenerPreset_Alley" />
        <func id="0xb0013" name="DirectSoundI3DL2ListenerPreset_Arena" />
        <func id="0xb0014" name="DirectSoundI3DL2ListenerPreset_Auditorium" />
        <func id="0xb0015" name="DirectSoundI3DL2ListenerPreset_Bathroom" />
        <func id="0xb0016" name="DirectSoundI3DL2ListenerPreset_CarpetedHallway" />
        <func id="0xb0017" name="DirectSoundI3DL2ListenerPreset_Cave" />
        <func id="0xb0018" name="DirectSoundI3DL2ListenerPreset_City" />
        <func id="0xb0019" name="DirectSoundI3DL2ListenerPreset_ConcertHall" />
        <func id="0xb001a" name="DirectSoundI3DL2ListenerPreset_Default" />
        <func id="0xb001b" name="DirectSoundI3DL2ListenerPreset_Default2" />
        <func id="0xb001c" name="DirectSoundI3DL2ListenerPreset_Forest" />
        <func id="0xb001d" name="DirectSoundI3DL2ListenerPreset_Generic" />
        <func id="0xb001e" name="DirectSoundI3DL2ListenerPreset_Hallway" />
        <func id="0xb001f" name="DirectSoundI3DL2ListenerPreset_Hangar" />
        <func id="0xb0020" name="DirectSoundI3DL2ListenerPreset_LivingRoom" />
        <func id="0xb0021" name="DirectSoundI3DL2ListenerPreset_Mountains" />
        <func id="0xb0022" name="DirectSoundI3DL2ListenerPreset_NoReverb" />
        <func id="0xb0023" name="DirectSoundI3DL2ListenerPreset_PaddedCell" />
        <func id="0xb0024" name="DirectSoundI3DL2ListenerPreset_ParkingLot" />
        <func id="0xb0025" name="DirectSoundI3DL2ListenerPreset_Plain" />
        <func id="0xb0026" name="DirectSoundI3DL2ListenerPreset_Quarry" />
        <func id="0xb0027" name="DirectSoundI3DL2ListenerPreset_Room" />
        <func id="0xb0028" name="DirectSoundI3DL2ListenerPreset_SewerPipe" />
        <func id="0xb0029" name="DirectSoundI3DL2ListenerPreset_StoneCorridor" />
        <func id="0xb002a" name="DirectSoundI3DL2ListenerPreset_StoneRoom" />
        <func id="0xb002b" name="DirectSoundI3DL2ListenerPreset_Underwater" />
        <func id="0xb002c" name="DirectSoundOverrideSpeakerConfig" />
        <func id="0xb002d" name="DirectSoundRequiredMixBins_3D" />
        <func id="0xb002e" name="DirectSoundRequiredMixBins_5Channel3D" />
        <func id="0xb002f" name="DirectSoundUseFullHRTF" />
        <func id="0xb0030" name="DirectSoundUseFullHRTF4Channel" />
        <func id="0xb0031" name="DirectSoundUseLightHRTF" />
        <func id="0xb0032" name="DirectSoundUseLightHRTF4Channel" />
        <func id="0xb0033" name="g_dwDirectSoundDebugBreakLevel" />
        <func id="0xb0034" name="g_dwDirectSoundDebugLevel" />
        <func id="0xb0035" name="g_pfnDirectSoundDebugCallback" />
        <func id="0xb0036" name="IDirectSound_AddRef" />
        <func id="0xb0037" name="IDirectSound_CommitDeferredSettings" />
        <func id="0xb0038" name="IDirectSound_CommitEffectData" />
        <func id="0xb0039" name="IDirectSound_Compact" />
        <func id="0xb003a" name="IDirectSound_CreateSoundBuffer" />
        <func id="0xb003b" name="IDirectSound_CreateSoundStream" />
        <func id="0xb003c" name="IDirectSound_DownloadEffectsImage" />
        <func id="0xb003d" name="IDirectSound_EnableHeadphones" />
        <func id="0xb003e" name="IDirectSound_GetCaps" />
        <func id="0xb003f" name="IDirectSound_GetEffectData" />
        <func id="0xb0040" name="IDirectSound_GetOutputLevels" />
        <func id="0xb0041" name="IDirectSound_GetSpeakerConfig" />
        <func id="0xb0042" name="IDirectSound_GetTime" />
        <func id="0xb0043" name="IDirectSound_QueryInterface" />
        <func id="0xb0044" name="IDirectSound_QueryInterfaceC" />
        <func id="0xb0045" name="IDirectSound_Release" />
        <func id="0xb0046" name="IDirectSound_SetAllParameters" />
        <func id="0xb0047" name="IDirectSound_SetCooperativeLevel" />
        <func id="0xb0048" name="IDirectSound_SetDistanceFactor" />
        <func id="0xb0049" name="IDirectSound_SetDopplerFactor" />
        <func id="0xb004a" name="IDirectSound_SetEffectData" />
        <func id="0xb004b" name="IDirectSound_SetI3DL2Listener" />
        <func id="0xb004c" name="IDirectSound_SetMixBinHeadroom" />
        <func id="0xb004d" name="IDirectSound_SetOrientation" />
        <func id="0xb004e" name="IDirectSound_SetPosition" />
        <func id="0xb004f" name="IDirectSound_SetRolloffFactor" />
        <func id="0xb0050" name="IDirectSound_SetVelocity" />
        <func id="0xb0051" name="IDirectSound_SynchPlayback" />
        <func id="0xb0052" name="IDirectSoundBuffer_AddRef" />
        <func id="0xb0053" name="IDirectSoundBuffer_GetCurrentPosition" />
        <func id="0xb0054" name="IDirectSoundBuffer_GetStatus" />
        <func id="0xb0055" name="IDirectSoundBuffer_GetVoiceProperties" />
        <func id="0xb0056" name="IDirectSoundBuffer_Lock" />
        <func id="0xb0057" name="IDirectSoundBuffer_Pause" />
        <func id="0xb0058" name="IDirectSoundBuffer_PauseEx" />
        <func id="0xb0059" name="IDirectSoundBuffer_Play" />
        <func id="0xb005a" name="IDirectSoundBuffer_PlayEx" />
        <func id="0xb005b" name="IDirectSoundBuffer_QueryInterface" />
        <func id="0xb005c" name="IDirectSoundBuffer_QueryInterfaceC" />
        <func id="0xb005d" name="IDirectSoundBuffer_Release" />
        <func id="0xb005e" name="IDirectSoundBuffer_Restore" />
        <func id="0xb005f" name="IDirectSoundBuffer_SetAllParameters" />
        <func id="0xb0060" name="IDirectSoundBuffer_SetBufferData" />
        <func id="0xb0061" name="IDirectSoundBuffer_SetConeAngles" />
        <func id="0xb0062" name="IDirectSoundBuffer_SetConeOrientation" />
        <func id="0xb0063" name="IDirectSoundBuffer_SetConeOutsideVolume" />
        <func id="0xb0064" name="IDirectSoundBuffer_SetCurrentPosition" />
        <func id="0xb0065" name="IDirectSoundBuffer_SetDistanceFactor" />
        <func id="0xb0066" name="IDirectSoundBuffer_SetDopplerFactor" />
        <func id="0xb0067" name="IDirectSoundBuffer_SetEG" />
        <func id="0xb0068" name="IDirectSoundBuffer_SetFilter" />
        <func id="0xb0069" name="IDirectSoundBuffer_SetFormat" />
        <func id="0xb006a" name="IDirectSoundBuffer_SetFrequency" />
        <func id="0xb006b" name="IDirectSoundBuffer_SetHeadroom" />
        <func id="0xb006c" name="IDirectSoundBuffer_SetI3DL2Source" />
        <func id="0xb006d" name="IDirectSoundBuffer_SetLFO" />
        <func id="0xb006e" name="IDirectSoundBuffer_SetLoopRegion" />
        <func id="0xb006f" name="IDirectSoundBuffer_SetMaxDistance" />
        <func id="0xb0070" name="IDirectSoundBuffer_SetMinDistance" />
        <func id="0xb0071" name="IDirectSoundBuffer_SetMixBins" />
        <func id="0xb0072" name="IDirectSoundBuffer_SetMixBinVolumes" />
        <func id="0xb0073" name="IDirectSoundBuffer_SetMode" />
        <func id="0xb0074" name="IDirectSoundBuffer_SetNotificationPositions" />
        <func id="0xb0075" name="IDirectSoundBuffer_SetOutputBuffer" />
        <func id="0xb0076" name="IDirectSoundBuffer_SetPitch" />
        <func id="0xb0077" name="IDirectSoundBuffer_SetPlayRegion" />
        <func id="0xb0078" name="IDirectSoundBuffer_SetPosition" />
        <func id="0xb0079" name="IDirectSoundBuffer_SetRolloffCurve" />
        <func id="0xb007a" name="IDirectSoundBuffer_SetRolloffFactor" />
        <func id="0xb007b" name="IDirectSoundBuffer_SetVelocity" />
        <func id="0xb007c" name="IDirectSoundBuffer_SetVolume" />
        <func id="0xb007d" name="IDirectSoundBuffer_Stop" />
        <func id="0xb007e" name="IDirectSoundBuffer_StopEx" />
        <func id="0xb007f" name="IDirectSoundBuffer_Unlock" />
        <func id="0xb0080" name="IDirectSoundStream_FlushEx" />
        <func id="0xb0081" name="IDirectSoundStream_GetVoiceProperties" />
        <func id="0xb0082" name="IDirectSoundStream_Pause" />
        <func id="0xb0083" name="IDirectSoundStream_PauseEx" />
        <func id="0xb0084" name="IDirectSoundStream_QueryInterface" />
        <func id="0xb0085" name="IDirectSoundStream_QueryInterfaceC" />
        <func id="0xb0086" name="IDirectSoundStream_SetAllParameters" />
        <func id="0xb0087" name="IDirectSoundStream_SetConeAngles" />
        <func id="0xb0088" name="IDirectSoundStream_SetConeOrientation" />
        <func id="0xb0089" name="IDirectSoundStream_SetConeOutsideVolume" />
        <func id="0xb008a" name="IDirectSoundStream_SetDistanceFactor" />
        <func id="0xb008b" name="IDirectSoundStream_SetDopplerFactor" />
        <func id="0xb008c" name="IDirectSoundStream_SetEG" />
        <func id="0xb008d" name="IDirectSoundStream_SetFilter" />
        <func id="0xb008e" name="IDirectSoundStream_SetFormat" />
        <func id="0xb008f" name="IDirectSoundStream_SetFrequency" />
        <func id="0xb0090" name="IDirectSoundStream_SetHeadroom" />
        <func id="0xb0091" name="IDirectSoundStream_SetI3DL2Source" />
        <func id="0xb0092" name="IDirectSoundStream_SetLFO" />
        <func id="0xb0093" name="IDirectSoundStream_SetMaxDistance" />
        <func id="0xb0094" name="IDirectSoundStream_SetMinDistance" />
        <func id="0xb0095" name="IDirectSoundStream_SetMixBins" />
        <func id="0xb0096" name="IDirectSoundStream_SetMixBinVolumes" />
        <func id="0xb0097" name="IDirectSoundStream_SetMode" />
        <func id="0xb0098" name="IDirectSoundStream_SetOutputBuffer" />
        <func id="0xb0099" name="IDirectSoundStream_SetPitch" />
        <func id="0xb009a" name="IDirectSoundStream_SetPosition" />
        <func id="0xb009b" name="IDirectSoundStream_SetRolloffCurve" />
        <func id="0xb009c" name="IDirectSoundStream_SetRolloffFactor" />
        <func id="0xb009d" name="IDirectSoundStream_SetVelocity" />
        <func id="0xb009e" name="IDirectSoundStream_SetVolume" />
        <func id="0xb009f" name="WmaCreateDecoder" />
        <func id="0xb00a0" name="WmaCreateDecoderEx" />
        <func id="0xb00a1" name="WmaCreateInMemoryDecoder" />
        <func id="0xb00a2" name="WmaCreateInMemoryDecoderEx" />
        <func id="0xb00a3" name="XAudioCalculatePitch" />
        <func id="0xb00a4" name="XAudioCreateAdpcmFormat" />
        <func id="0xb00a5" name="XAudioCreatePcmFormat" />
        <func id="0xb00a6" name="XAudioDownloadEffectsImage" />
        <func id="0xb00a7" name="XAudioSetEffectData" />
        <func id="0xb00a8" name="XFileCreateMediaObject" />
        <func id="0xb00a9" name="XFileCreateMediaObjectAsync" />
        <func id="0xb00aa" name="XFileCreateMediaObjectEx" />
        <func id="0xb00ab" name="XWaveFileCreateMediaObject" />
        <func id="0xb00ac" name="XWaveFileCreateMediaObjectEx" />
        <func id="0xb00ad" name="XWmaDecoderCreateMediaObject" />
    </lib>
    <lib name="KEYBOARD" libnames="keyboard keyboardd">
        <func id="0x60001" name="XDEVICE_TYPE_KEYBOARD_TABLE" />
        <func id="0x60002" name="XInputGetKeyboardDeviceLanguage" />
        <func id="0x60003" name="XInputGetKeyboardOptions" />
        <func id="0x60004" name="XInputGetKeystroke" />
        <func id="0x60005" name="XInputRegisterLanguages" />
        <func id="0x60006" name="XInputSetKeyboardOptions" />
    </lib>
    <lib name="XACT" libnames="xacteng xactengd xactengi xactengltcg">
        <func id="0xc0001" name="IXACTEngine_AddRef" />
        <func id="0xc0002" name="IXACTEngine_CommitDeferredSettings" />
        <func id="0xc0003" name="IXACTEngine_CreateSoundBank" />
        <func id="0xc0004" name="IXACTEngine_CreateSoundSource" />
        <func id="0xc0005" name="IXACTEngine_DownloadEffectsImage" />
        <func id="0xc0006" name="IXACTEngine_EnableHeadphones" />
        <func id="0xc0007" name="IXACTEngine_FlushNotification" />
        <func id="0xc0008" name="IXACTEngine_GetNotification" />
        <func id="0xc0009" name="IXACTEngine_GlobalPause" />
        <func id="0xc000a" name="IXACTEngine_RegisterNotification" />
        <func id="0xc000b" name="IXACTEngine_RegisterStreamedWaveBank" />
        <func id="0xc000c" name="IXACTEngine_RegisterWaveBank" />
        <func id="0xc000d" name="IXACTEngine_Release" />
        <func id="0xc000e" name="IXACTEngine_SetI3dl2Listener" />
        <func id="0xc000f" name="IXACTEngine_SetListenerOrientation" />
        <func id="0xc0010" name="IXACTEngine_SetListenerPosition" />
        <func id="0xc0011" name="IXACTEngine_SetListenerVelocity" />
        <func id="0xc0012" name="IXACTEngine_SetMasterVolume" />
        <func id="0xc0013" name="IXACTEngine_SetParameterControl" />
        <func id="0xc0014" name="IXACTEngine_UnRegisterNotification" />
        <func id="0xc0015" name="IXACTEngine_UnRegisterWaveBank" />
        <func id="0xc0016" name="IXACTSoundBank_AddRef" />
        <func id="0xc0017" name="IXACTSoundBank_CreateWmaPlayList" />
        <func id="0xc0018" name="IXACTSoundBank_GetSoundCueIndexFromFriendlyName" />
        <func id="0xc0019" name="IXACTSoundBank_GetSoundCueProperties" />
        <func id="0xc001a" name="IXACTSoundBank_PauseSoundCue" />
        <func id="0xc001b" name="IXACTSoundBank_Play" />
        <func id="0xc001c" name="IXACTSoundBank_PlayEx" />
        <func id="0xc001d" name="IXACTSoundBank_Prepare" />
        <func id="0xc001e" name="IXACTSoundBank_PrepareEx" />
        <func id="0xc001f" name="IXACTSoundBank_Release" />
        <func id="0xc0020" name="IXACTSoundBank_SelectVariation" />
        <func id="0xc0021" name="IXACTSoundBank_Stop" />
        <func id="0xc0022" name="IXACTSoundSource_AddRef" />
        <func id="0xc0023" name="IXACTSoundSource_GetProperties" />
        <func id="0xc0024" name="IXACTSoundSource_GetStatus" />
        <func id="0xc0025" name="IXACTSoundSource_Release" />
        <func id="0xc0026" name="IXACTSoundSource_SetConeOrientation" />
        <func id="0xc0027" name="IXACTSoundSource_SetFilter" />
        <func id="0xc0028" name="IXACTSoundSource_SetI3DL2Source" />
        <func id="0xc0029" name="IXACTSoundSource_SetMixBins" />
        <func id="0xc002a" name="IXACTSoundSource_SetMixBinVolumes" />
        <func id="0xc002b" name="IXACTSoundSource_SetMode" />
        <func id="0xc002c" name="IXACTSoundSource_SetPitch" />
        <func id="0xc002d" name="IXACTSoundSource_SetPosition" />
        <func id="0xc002e" name="IXACTSoundSource_SetVelocity" />
        <func id="0xc002f" name="IXACTSoundSource_StopSoundCues" />
        <func id="0xc0030" name="IXACTWmaPlayList_Add" />
        <func id="0xc0031" name="IXACTWmaPlayList_AddRef" />
        <func id="0xc0032" name="IXACTWmaPlayList_GetCurrentSongInfo" />
        <func id="0xc0033" name="IXACTWmaPlayList_GetCurrentSongInfoEx" />
        <func id="0xc0034" name="IXACTWmaPlayList_GetProperties" />
        <func id="0xc0035" name="IXACTWmaPlayList_Next" />
        <func id="0xc0036" name="IXACTWmaPlayList_Previous" />
        <func id="0xc0037" name="IXACTWmaPlayList_Release" />
        <func id="0xc0038" name="IXACTWmaPlayList_Remove" />
        <func id="0xc0039" name="IXACTWmaPlayList_SetCurrent" />
        <func id="0xc003a" name="IXACTWmaPlayList_SetPlaybackBehavior" />
        <func id="0xc003b" name="XACTEngineCreate" />
        <func id="0xc003c" name="XACTEngineDoWork" />
        <func id="0xc003d" name="XACTEngineSetFileIOCallbacks" />
    </lib>
    <lib name="XAPILIB" libnames="xapilib xapilibd xsndtrk xsndtrkd">
        <func id="0x10027" name="XAddSongToSoundtrack" />
        <func id="0x10026" name="XAddSoundtrack" />
        <func id="0x10075" name="XapiFlashKernelImage" />
        <func id="0x10077" name="XapiGetKernelExportAddress" />
        <func id="0x10057" name="XapipQueryTimeZoneInformation" />
        <func id="0x10058" name="XapipSetTimeZoneInformation" />
        <func id="0x10059" name="XapipUseDaylightSavingTime" />
        <func id="0x10076" name="XapiReplaceRootDirectoryFile" />
        <func id="0x10056" name="XapiSetLocalTime" />
        <func id="0x10055" name="XAutoPowerDownDebugSetTimeout" />
        <func id="0x10053" name="XAutoPowerDownGet" />
        <func id="0x10054" name="XAutoPowerDownResetTimer" />
        <func id="0x10052" name="XAutoPowerDownSet" />
        <func id="0x10074" name="XAutoPowerDownTimeRemaining" />
        <func id="0x1001f" name="XCalculateContentSignature" />
        <func id="0x10070" name="XCalculateSignatureBegin" />
        <func id="0x10071" name="XCalculateSignatureBeginEx" />
        <func id="0x10073" name="XCalculateSignatureEnd" />
        <func id="0x10072" name="XCalculateSignatureUpdate" />
        <func id="0x10048" name="XCleanDrive" />
        <func id="0x10047" name="XCleanMUFromRoot" />
        <func id="0x10020" name="XCloseContentSignatures" />
        <func id="0x10021" name="XComputeContentSignatureKey" />
        <func id="0x10015" name="XCreateContentSimple" />
        <func id="0x10008" name="XCreateSaveGame" />
        <func id="0x10050" name="XDCSDownloadCode" />
        <func id="0x10051" name="XDCSDownloadCodeAsync" />
        <func id="0x1004f" name="XDCSGetInformation" />
        <func id="0x1006e" name="XDebugGetSystemVersion" />
        <func id="0x1006f" name="XDebugGetXTLVersion" />
        <func id="0x10009" name="XDeleteSaveGame" />
        <func id="0x1007b" name="XDEVICE_TYPE_DEBUG_MOUSE_TABLE" />
        <func id="0x1007c" name="XDEVICE_TYPE_GAMEPAD_TABLE" />
        <func id="0x1007d" name="XDEVICE_TYPE_IR_REMOTE_TABLE" />
        <func id="0x1007e" name="XDEVICE_TYPE_MEMORY_UNIT_TABLE" />
        <func id="0x1000c" name="XFindClose" />
        <func id="0x10010" name="XFindFirstContent" />
        <func id="0x1000e" name="XFindFirstNickname" />
        <func id="0x1000a" name="XFindFirstSaveGame" />
        <func id="0x10022" name="XFindFirstSoundtrack" />
        <func id="0x10011" name="XFindNextContent" />
        <func id="0x1000f" name="XFindNextNickname" />
        <func id="0x1000b" name="XFindNextSaveGame" />
        <func id="0x10023" name="XFindNextSoundtrack" />
        <func id="0x1004a" name="XFormatUtilityDrive" />
        <func id="0x10002" name="XFreeSection" />
        <func id="0x10005" name="XFreeSectionByHandle" />
        <func id="0x1006d" name="XGetAttributesOnHeapAlloc" />
        <func id="0x1002c" name="XGetAudioFlags" />
        <func id="0x10029" name="XGetAVPack" />
        <func id="0x10012" name="XGetContentInstallLocation" />
        <func id="0x10013" name="XGetContentInstallLocationFromIDs" />
        <func id="0x10033" name="XGetDeviceChanges" />
        <func id="0x10035" name="XGetDeviceEnumerationStatus" />
        <func id="0x10032" name="XGetDevices" />
        <func id="0x1004e" name="XGetDiskClusterSize" />
        <func id="0x1004d" name="XGetDiskSectorSize" />
        <func id="0x10007" name="XGetDisplayBlocks" />
        <func id="0x10061" name="XGetFileCacheSize" />
        <func id="0x1002e" name="XGetGameRegion" />
        <func id="0x10028" name="XGetLanguage" />
        <func id="0x1005b" name="XGetLaunchInfo" />
        <func id="0x1002d" name="XGetParentalControlSetting" />
        <func id="0x1005f" name="XGetProcessQuantumLength" />
        <func id="0x10003" name="XGetSectionHandle" />
        <func id="0x10006" name="XGetSectionSize" />
        <func id="0x10025" name="XGetSoundtrackSongInfo" />
        <func id="0x1002b" name="XGetVideoFlags" />
        <func id="0x1002a" name="XGetVideoStandard" />
        <func id="0x10031" name="XInitDevices" />
        <func id="0x10037" name="XInputClose" />
        <func id="0x1003b" name="XInputGetCapabilities" />
        <func id="0x1003c" name="XInputGetDeviceDescription" />
        <func id="0x10038" name="XInputGetState" />
        <func id="0x10036" name="XInputOpen" />
        <func id="0x10039" name="XInputPoll" />
        <func id="0x1003d" name="XInputSetLightgunCalibration" />
        <func id="0x1003a" name="XInputSetState" />
        <func id="0x10014" name="XInstallContentSignatures" />
        <func id="0x1001b" name="XInstallContentSignaturesEx" />
        <func id="0x1001a" name="XInstallContentSignaturesWithFileName" />
        <func id="0x1005a" name="XLaunchNewImageA" />
        <func id="0x1001c" name="XLoadContentSignaturesEx" />
        <func id="0x10017" name="XLoadContentSignaturesWithFileName" />
        <func id="0x10001" name="XLoadSection" />
        <func id="0x10004" name="XLoadSectionByHandle" />
        <func id="0x10019" name="XLocateNextSignature" />
        <func id="0x1001d" name="XLocateSignatureByIndex" />
        <func id="0x1001e" name="XLocateSignatureByName" />
        <func id="0x10018" name="XLocateSignatureByNameEx" />
        <func id="0x10069" name="XMemAlloc" />
        <func id="0x10078" name="XMemAllocDefault" />
        <func id="0x1006a" name="XMemFree" />
        <func id="0x10079" name="XMemFreeDefault" />
        <func id="0x1006b" name="XMemSize" />
        <func id="0x1007a" name="XMemSizeDefault" />
        <func id="0x1004b" name="XMountAlternateTitle" />
        <func id="0x1003e" name="XMountMUA" />
        <func id="0x1003f" name="XMountMURoot" />
        <func id="0x10049" name="XMountUtilityDrive" />
        <func id="0x10043" name="XMUNameFromDriveLetter" />
        <func id="0x10044" name="XMUNameFromPortSlot" />
        <func id="0x10041" name="XMUPortFromDriveLetter" />
        <func id="0x10042" name="XMUSlotFromDriveLetter" />
        <func id="0x10046" name="XMUWriteNameToDriveLetter" />
        <func id="0x10024" name="XOpenSoundtrackSong" />
        <func id="0x10034" name="XPeekDevices" />
        <func id="0x10064" name="XPhysicalAlloc" />
        <func id="0x10067" name="XPhysicalFree" />
        <func id="0x10066" name="XPhysicalProtect" />
        <func id="0x10065" name="XPhysicalSize" />
        <func id="0x10068" name="XQueryMemoryProtect" />
        <func id="0x10030" name="XQueryValue" />
        <func id="0x10045" name="XReadMUMetaData" />
        <func id="0x1005d" name="XRegisterThreadNotifyRoutine" />
        <func id="0x10016" name="XRemoveContent" />
        <func id="0x10063" name="XRestoreFloatingPointStateForDpc" />
        <func id="0x10062" name="XSaveFloatingPointStateForDpc" />
        <func id="0x1006c" name="XSetAttributesOnHeapAlloc" />
        <func id="0x10060" name="XSetFileCacheSize" />
        <func id="0x1000d" name="XSetNickname" />
        <func id="0x1005e" name="XSetProcessQuantumLength" />
        <func id="0x1002f" name="XSetValue" />
        <func id="0x1004c" name="XUnmountAlternateTitle" />
        <func id="0x10040" name="XUnmountMU" />
        <func id="0x1005c" name="XWriteTitleInfoAndReboot" />
        <func id="0x200cb" name="_hread" />
        <func id="0x200cc" name="_hwrite" />
        <func id="0x200cd" name="_lclose" />
        <func id="0x200c8" name="_lcreat" />
        <func id="0x200ce" name="_llseek" />
        <func id="0x200c7" name="_lopen" />
        <func id="0x200c9" name="_lread" />
        <func id="0x200ca" name="_lwrite" />
        <func id="0x2013b" name="AreFileApisANSIVOID" />
        <func id="0x20158" name="BindIoCompletionCallback" />
        <func id="0x2013d" name="CancelIo" />
        <func id="0x2015f" name="CancelTimerQueueTimer" />
        <func id="0x200e5" name="CancelWaitableTimer" />
        <func id="0x2015b" name="ChangeTimerQueueTimer" />
        <func id="0x20174" name="CharLowerA" />
        <func id="0x20175" name="CharLowerW" />
        <func id="0x20172" name="CharUpperA" />
        <func id="0x20173" name="CharUpperW" />
        <func id="0x200a1" name="CloseHandle" />
        <func id="0x200b2" name="CompareFileTime" />
        <func id="0x20082" name="ContinueDebugEvent" />
        <func id="0x20061" name="ConvertThreadToFiber" />
        <func id="0x20132" name="CopyFile" />
        <func id="0x20133" name="CopyFileEx" />
        <func id="0x20004" name="CopyMemory" />
        <func id="0x20178" name="CopyRect" />
        <func id="0x20123" name="CreateDirectory" />
        <func id="0x20124" name="CreateDirectoryExA" />
        <func id="0x20125" name="CreateDirectoryExW" />
        <func id="0x200de" name="CreateEvent" />
        <func id="0x2005f" name="CreateFiber" />
        <func id="0x20129" name="CreateFile" />
        <func id="0x20076" name="CreateIoCompletionPort" />
        <func id="0x200dc" name="CreateMutex" />
        <func id="0x200e0" name="CreateSemaphore" />
        <func id="0x20064" name="CreateThread" />
        <func id="0x20159" name="CreateTimerQueue" />
        <func id="0x2015a" name="CreateTimerQueueTimer" />
        <func id="0x200e2" name="CreateWaitableTimer" />
        <func id="0x20083" name="DebugActiveProcess" />
        <func id="0x20080" name="DebugBreak" />
        <func id="0x20088" name="DeleteCriticalSection" />
        <func id="0x20060" name="DeleteFiber" />
        <func id="0x2012d" name="DeleteFile" />
        <func id="0x20160" name="DeleteTimerQueue" />
        <func id="0x2015d" name="DeleteTimerQueueEx" />
        <func id="0x2015c" name="DeleteTimerQueueTimer" />
        <func id="0x2009b" name="DeviceIoControl" />
        <func id="0x2001c" name="DisableThreadLibraryCalls" />
        <func id="0x2014f" name="DnsHostnameToComputerNameA" />
        <func id="0x20150" name="DnsHostnameToComputerNameW" />
        <func id="0x200b4" name="DosDateTimeToFileTime" />
        <func id="0x200a2" name="DuplicateHandle" />
        <func id="0x20085" name="EnterCriticalSection" />
        <func id="0x200fa" name="EnumResourceLanguagesA" />
        <func id="0x200fb" name="EnumResourceLanguagesW" />
        <func id="0x200f8" name="EnumResourceNamesA" />
        <func id="0x200f9" name="EnumResourceNamesW" />
        <func id="0x200f6" name="EnumResourceTypesA" />
        <func id="0x200f7" name="EnumResourceTypesW" />
        <func id="0x2017f" name="EqualRect" />
        <func id="0x20058" name="ExitProcess" />
        <func id="0x2006f" name="ExitThread" />
        <func id="0x2005b" name="FatalExit" />
        <func id="0x200b3" name="FileTimeToDosDateTime" />
        <func id="0x200af" name="FileTimeToLocalFileTime" />
        <func id="0x200b1" name="FileTimeToSystemTime" />
        <func id="0x20005" name="FillMemory" />
        <func id="0x2012e" name="FindFirstFile" />
        <func id="0x20163" name="FindFirstVolumeA" />
        <func id="0x20164" name="FindFirstVolumeW" />
        <func id="0x2012f" name="FindNextFile" />
        <func id="0x20165" name="FindNextVolumeA" />
        <func id="0x20166" name="FindNextVolumeW" />
        <func id="0x200f2" name="FindResourceA" />
        <func id="0x200f4" name="FindResourceExA" />
        <func id="0x200f5" name="FindResourceExW" />
        <func id="0x200f3" name="FindResourceW" />
        <func id="0x20167" name="FindVolumeClose" />
        <func id="0x2009a" name="FlushFileBuffers" />
        <func id="0x200b8" name="FormatMessageA" />
        <func id="0x200b9" name="FormatMessageW" />
        <func id="0x2001a" name="FreeLibrary" />
        <func id="0x2001b" name="FreeLibraryAndExitThread" />
        <func id="0x20016" name="FreeResource" />
        <func id="0x20147" name="GetComputerNameA" />
        <func id="0x2014b" name="GetComputerNameExA" />
        <func id="0x2014c" name="GetComputerNameExW" />
        <func id="0x20148" name="GetComputerNameW" />
        <func id="0x2011f" name="GetCurrentDirectoryW" />
        <func id="0x20056" name="GetCurrentProcess" />
        <func id="0x20057" name="GetCurrentProcessId" />
        <func id="0x20065" name="GetCurrentThread" />
        <func id="0x20066" name="GetCurrentThreadId" />
        <func id="0x20001" name="GetCurrentTime" />
        <func id="0x2016a" name="GetDaylightFlagVOID" />
        <func id="0x20120" name="GetDiskFreeSpaceA" />
        <func id="0x20122" name="GetDiskFreeSpaceEx" />
        <func id="0x20121" name="GetDiskFreeSpaceW" />
        <func id="0x20116" name="GetDriveTypeA" />
        <func id="0x20117" name="GetDriveTypeW" />
        <func id="0x2005a" name="GetExitCodeProcess" />
        <func id="0x20071" name="GetExitCodeThread" />
        <func id="0x2012b" name="GetFileAttributes" />
        <func id="0x2012c" name="GetFileAttributesEx" />
        <func id="0x20094" name="GetFileInformationByHandle" />
        <func id="0x20096" name="GetFileSize" />
        <func id="0x20097" name="GetFileSizeEx" />
        <func id="0x2009f" name="GetFileTime" />
        <func id="0x20095" name="GetFileType" />
        <func id="0x20127" name="GetFullPathNameA" />
        <func id="0x20128" name="GetFullPathNameW" />
        <func id="0x20072" name="GetLastError" />
        <func id="0x200a8" name="GetLocalTime" />
        <func id="0x20093" name="GetLogicalDrives" />
        <func id="0x200e6" name="GetLogicalDriveStringsA" />
        <func id="0x200e7" name="GetLogicalDriveStringsW" />
        <func id="0x20053" name="GetLongPathNameA" />
        <func id="0x20054" name="GetLongPathNameW" />
        <func id="0x200ec" name="GetModuleFileNameA" />
        <func id="0x200ed" name="GetModuleFileNameW" />
        <func id="0x200ee" name="GetModuleHandleA" />
        <func id="0x200ef" name="GetModuleHandleW" />
        <func id="0x20075" name="GetOverlappedResult" />
        <func id="0x2013f" name="GetPriorityClass" />
        <func id="0x20106" name="GetPrivateProfileIntA" />
        <func id="0x20107" name="GetPrivateProfileIntW" />
        <func id="0x2010c" name="GetPrivateProfileSectionA" />
        <func id="0x20110" name="GetPrivateProfileSectionNamesA" />
        <func id="0x20111" name="GetPrivateProfileSectionNamesW" />
        <func id="0x2010d" name="GetPrivateProfileSectionW" />
        <func id="0x20108" name="GetPrivateProfileStringA" />
        <func id="0x20109" name="GetPrivateProfileStringW" />
        <func id="0x20112" name="GetPrivateProfileStructA" />
        <func id="0x20113" name="GetPrivateProfileStructW" />
        <func id="0x2001d" name="GetProcAddress" />
        <func id="0x2004a" name="GetProcessHeaps" />
        <func id="0x20049" name="GetProcessHeapVOID" />
        <func id="0x20068" name="GetProcessPriorityBoost" />
        <func id="0x20055" name="GetProcessTimes" />
        <func id="0x200fc" name="GetProfileIntA" />
        <func id="0x200fd" name="GetProfileIntW" />
        <func id="0x20102" name="GetProfileSectionA" />
        <func id="0x20103" name="GetProfileSectionW" />
        <func id="0x200fe" name="GetProfileStringA" />
        <func id="0x200ff" name="GetProfileStringW" />
        <func id="0x20077" name="GetQueuedCompletionStatus" />
        <func id="0x20051" name="GetShortPathNameA" />
        <func id="0x20052" name="GetShortPathNameW" />
        <func id="0x20118" name="GetSystemDirectoryA" />
        <func id="0x20119" name="GetSystemDirectoryW" />
        <func id="0x200aa" name="GetSystemInfo" />
        <func id="0x200a5" name="GetSystemTime" />
        <func id="0x200b7" name="GetSystemTimeAdjustment" />
        <func id="0x200a6" name="GetSystemTimeAsFileTime" />
        <func id="0x2011c" name="GetTempFileNameA" />
        <func id="0x2011d" name="GetTempFileNameW" />
        <func id="0x2011a" name="GetTempPathA" />
        <func id="0x2011b" name="GetTempPathW" />
        <func id="0x2007a" name="GetThreadContext" />
        <func id="0x2006d" name="GetThreadPriority" />
        <func id="0x2006c" name="GetThreadPriorityBoost" />
        <func id="0x2006e" name="GetThreadTimes" />
        <func id="0x200b5" name="GetTickCount" />
        <func id="0x200ac" name="GetTimeZoneInformation" />
        <func id="0x20151" name="GetUserNameA" />
        <func id="0x20152" name="GetUserNameW" />
        <func id="0x2013c" name="GetVolumeInformation" />
        <func id="0x20168" name="GetVolumePathNameA" />
        <func id="0x20169" name="GetVolumePathNameW" />
        <func id="0x2001e" name="GlobalAlloc" />
        <func id="0x20026" name="GlobalCompact" />
        <func id="0x20027" name="GlobalFix" />
        <func id="0x20020" name="GlobalFlags" />
        <func id="0x20025" name="GlobalFree" />
        <func id="0x20023" name="GlobalHandle" />
        <func id="0x20022" name="GlobalLock" />
        <func id="0x2002b" name="GlobalMemoryStatus" />
        <func id="0x2002c" name="GlobalMemoryStatusEx" />
        <func id="0x2001f" name="GlobalReAlloc" />
        <func id="0x20021" name="GlobalSize" />
        <func id="0x20028" name="GlobalUnfix" />
        <func id="0x20024" name="GlobalUnlock" />
        <func id="0x2002a" name="GlobalUnWire" />
        <func id="0x20029" name="GlobalWire" />
        <func id="0x20074" name="HasOverlappedIoCompletedlpOverlapped" />
        <func id="0x20043" name="HeapAlloc" />
        <func id="0x20048" name="HeapCompact" />
        <func id="0x2003f" name="HeapCreate" />
        <func id="0x20041" name="HeapCreateTagsW" />
        <func id="0x20040" name="HeapDestroy" />
        <func id="0x2004e" name="HeapExtend" />
        <func id="0x20046" name="HeapFree" />
        <func id="0x2004b" name="HeapLock" />
        <func id="0x20042" name="HeapQueryTagW" />
        <func id="0x20044" name="HeapReAlloc" />
        <func id="0x20045" name="HeapSize" />
        <func id="0x2004d" name="HeapSummary" />
        <func id="0x2004c" name="HeapUnlock" />
        <func id="0x2004f" name="HeapUsage" />
        <func id="0x20047" name="HeapValidate" />
        <func id="0x20050" name="HeapWalk" />
        <func id="0x20179" name="InflateRect" />
        <func id="0x20084" name="InitializeCriticalSection" />
        <func id="0x20014" name="InterlockedCompareExchange" />
        <func id="0x20015" name="InterlockedCompareExchangePointer" />
        <func id="0x20010" name="InterlockedDecrement" />
        <func id="0x20011" name="InterlockedExchange" />
        <func id="0x20013" name="InterlockedExchangeAdd" />
        <func id="0x20012" name="InterlockedExchangePointerTarget" />
        <func id="0x2000f" name="InterlockedIncrement" />
        <func id="0x2017a" name="IntersectRect" />
        <func id="0x20144" name="IsBadCodePtr" />
        <func id="0x20142" name="IsBadHugeReadPtr" />
        <func id="0x20143" name="IsBadHugeWritePtr" />
        <func id="0x20140" name="IsBadReadPtr" />
        <func id="0x20145" name="IsBadStringPtrA" />
        <func id="0x20146" name="IsBadStringPtrW" />
        <func id="0x20141" name="IsBadWritePtr" />
        <func id="0x2007f" name="IsDebuggerPresent" />
        <func id="0x2017e" name="IsRectEmpty" />
        <func id="0x200cf" name="IsTextUnicode" />
        <func id="0x20086" name="LeaveCriticalSection" />
        <func id="0x200e8" name="LoadLibraryA" />
        <func id="0x200ea" name="LoadLibraryExA" />
        <func id="0x200eb" name="LoadLibraryExW" />
        <func id="0x200e9" name="LoadLibraryW" />
        <func id="0x200a3" name="LoadModule" />
        <func id="0x20091" name="LoadResource" />
        <func id="0x2002d" name="LocalAlloc" />
        <func id="0x20036" name="LocalCompact" />
        <func id="0x200b0" name="LocalFileTimeToFileTime" />
        <func id="0x20033" name="LocalFlags" />
        <func id="0x20034" name="LocalFree" />
        <func id="0x20030" name="LocalHandle" />
        <func id="0x2002f" name="LocalLock" />
        <func id="0x2002e" name="LocalReAlloc" />
        <func id="0x20035" name="LocalShrink" />
        <func id="0x20032" name="LocalSize" />
        <func id="0x20031" name="LocalUnlock" />
        <func id="0x20017" name="LockResource" />
        <func id="0x200c2" name="lstrcatA" />
        <func id="0x200c3" name="lstrcatW" />
        <func id="0x200ba" name="lstrcmpA" />
        <func id="0x200bc" name="lstrcmpiA" />
        <func id="0x200bd" name="lstrcmpiW" />
        <func id="0x200bb" name="lstrcmpW" />
        <func id="0x200c0" name="lstrcpyA" />
        <func id="0x200be" name="lstrcpynA" />
        <func id="0x200bf" name="lstrcpynW" />
        <func id="0x200c1" name="lstrcpyW" />
        <func id="0x200c4" name="lstrlenA" />
        <func id="0x200c5" name="lstrlenW" />
        <func id="0x20134" name="MoveFile" />
        <func id="0x20135" name="MoveFileEx" />
        <func id="0x20136" name="MoveFileWithProgress" />
        <func id="0x20003" name="MoveMemory" />
        <func id="0x200a4" name="MulDiv" />
        <func id="0x20170" name="MultiByteToWideChar" />
        <func id="0x2017d" name="OffsetRect" />
        <func id="0x200df" name="OpenEvent" />
        <func id="0x200c6" name="OpenFile" />
        <func id="0x200dd" name="OpenMutex" />
        <func id="0x200e1" name="OpenSemaphore" />
        <func id="0x20069" name="OpenThread" />
        <func id="0x200e3" name="OpenWaitableTimer" />
        <func id="0x200f0" name="OutputDebugStringA" />
        <func id="0x200f1" name="OutputDebugStringW" />
        <func id="0x20078" name="PostQueuedCompletionStatus" />
        <func id="0x20180" name="PtInRect" />
        <func id="0x2008b" name="PulseEvent" />
        <func id="0x20161" name="QueryPerformanceCounter" />
        <func id="0x20162" name="QueryPerformanceFrequency" />
        <func id="0x2007e" name="QueueUserAPC" />
        <func id="0x20157" name="QueueUserWorkItem" />
        <func id="0x2005c" name="RaiseException" />
        <func id="0x20099" name="ReadFile" />
        <func id="0x200d8" name="ReadFileEx" />
        <func id="0x200da" name="ReadFileScatter" />
        <func id="0x20153" name="RegisterWaitForSingleObject" />
        <func id="0x20154" name="RegisterWaitForSingleObjectEx" />
        <func id="0x2008d" name="ReleaseMutex" />
        <func id="0x2008c" name="ReleaseSemaphore" />
        <func id="0x20126" name="RemoveDirectory" />
        <func id="0x2008a" name="ResetEvent" />
        <func id="0x2007d" name="ResumeThread" />
        <func id="0x20130" name="SearchPathA" />
        <func id="0x20131" name="SearchPathW" />
        <func id="0x20149" name="SetComputerNameA" />
        <func id="0x2014d" name="SetComputerNameExA" />
        <func id="0x2014e" name="SetComputerNameExW" />
        <func id="0x2014a" name="SetComputerNameW" />
        <func id="0x2011e" name="SetCurrentDirectoryA" />
        <func id="0x2016b" name="SetDaylightFlag" />
        <func id="0x2009c" name="SetEndOfFile" />
        <func id="0x20079" name="SetErrorMode" />
        <func id="0x20089" name="SetEvent" />
        <func id="0x2013a" name="SetFileApisToANSIVOID" />
        <func id="0x20139" name="SetFileApisToOEMVOID" />
        <func id="0x2012a" name="SetFileAttributes" />
        <func id="0x2009d" name="SetFilePointer" />
        <func id="0x2009e" name="SetFilePointerEx" />
        <func id="0x200a0" name="SetFileTime" />
        <func id="0x20073" name="SetLastError" />
        <func id="0x200a9" name="SetLocalTime" />
        <func id="0x2013e" name="SetPriorityClass" />
        <func id="0x20067" name="SetProcessPriorityBoost" />
        <func id="0x20176" name="SetRect" />
        <func id="0x20177" name="SetRectEmpty" />
        <func id="0x200a7" name="SetSystemTime" />
        <func id="0x200b6" name="SetSystemTimeAdjustment" />
        <func id="0x2007b" name="SetThreadContext" />
        <func id="0x2006a" name="SetThreadPriority" />
        <func id="0x2006b" name="SetThreadPriorityBoost" />
        <func id="0x2015e" name="SetTimerQueueTimer" />
        <func id="0x200ad" name="SetTimeZoneInformation" />
        <func id="0x2005e" name="SetUnhandledExceptionFilter" />
        <func id="0x20137" name="SetVolumeLabelA" />
        <func id="0x20138" name="SetVolumeLabelW" />
        <func id="0x200e4" name="SetWaitableTimer" />
        <func id="0x200d7" name="SignalObjectAndWait" />
        <func id="0x20092" name="SizeofResource" />
        <func id="0x20090" name="Sleep" />
        <func id="0x200d4" name="SleepEx" />
        <func id="0x2017c" name="SubtractRect" />
        <func id="0x2007c" name="SuspendThread" />
        <func id="0x20062" name="SwitchToFiber" />
        <func id="0x20063" name="SwitchToThread" />
        <func id="0x200ae" name="SystemTimeToFileTime" />
        <func id="0x200ab" name="SystemTimeToTzSpecificLocalTime" />
        <func id="0x20059" name="TerminateProcess" />
        <func id="0x20070" name="TerminateThread" />
        <func id="0x200d0" name="TlsAlloc" />
        <func id="0x200d3" name="TlsFree" />
        <func id="0x200d1" name="TlsGetValue" />
        <func id="0x200d2" name="TlsSetValue" />
        <func id="0x20087" name="TryEnterCriticalSection" />
        <func id="0x2005d" name="UnhandledExceptionFilter" />
        <func id="0x2017b" name="UnionRect" />
        <func id="0x20018" name="UnlockResourcehResData" />
        <func id="0x20155" name="UnregisterWait" />
        <func id="0x20156" name="UnregisterWaitEx" />
        <func id="0x20037" name="VirtualAlloc" />
        <func id="0x2003b" name="VirtualAllocEx" />
        <func id="0x20038" name="VirtualFree" />
        <func id="0x2003c" name="VirtualFreeEx" />
        <func id="0x20039" name="VirtualProtect" />
        <func id="0x2003d" name="VirtualProtectEx" />
        <func id="0x2003a" name="VirtualQuery" />
        <func id="0x2003e" name="VirtualQueryEx" />
        <func id="0x20081" name="WaitForDebugEvent" />
        <func id="0x2008f" name="WaitForMultipleObjects" />
        <func id="0x200d6" name="WaitForMultipleObjectsEx" />
        <func id="0x2008e" name="WaitForSingleObject" />
        <func id="0x200d5" name="WaitForSingleObjectEx" />
        <func id="0x20171" name="WideCharToMultiByte" />
        <func id="0x20019" name="WinMain" />
        <func id="0x20098" name="WriteFile" />
        <func id="0x200d9" name="WriteFileEx" />
        <func id="0x200db" name="WriteFileGather" />
        <func id="0x2010e" name="WritePrivateProfileSectionA" />
        <func id="0x2010f" name="WritePrivateProfileSectionW" />
        <func id="0x2010a" name="WritePrivateProfileStringA" />
        <func id="0x2010b" name="WritePrivateProfileStringW" />
        <func id="0x20114" name="WritePrivateProfileStructA" />
        <func id="0x20115" name="WritePrivateProfileStructW" />
        <func id="0x20104" name="WriteProfileSectionA" />
        <func id="0x20105" name="WriteProfileSectionW" />
        <func id="0x20100" name="WriteProfileStringA" />
        <func id="0x20101" name="WriteProfileStringW" />
        <func id="0x2016e" name="wsprintfA" />
        <func id="0x2016f" name="wsprintfW" />
        <func id="0x2016c" name="wvsprintfA" />
        <func id="0x2016d" name="wvsprintfW" />
        <func id="0x20002" name="Yield" />
        <func id="0x20006" name="ZeroMemory" />
    </lib>
    <lib name="XGRAPHICS" libnames="xgraphics xgraphicsd xgraphicsltcg">
        <func id="0xd0001" name="XGAssembleShader" />
        <func id="0xd0002" name="XGBuffer_AddRef" />
        <func id="0xd0003" name="XGBuffer_GetBufferPointer" />
        <func id="0xd0004" name="XGBuffer_GetBufferSize" />
        <func id="0xd0005" name="XGBuffer_Release" />
        <func id="0xd0006" name="XGBufferCreate" />
        <func id="0xd0007" name="XGBytesPerPixelFromFormat" />
        <func id="0xd0008" name="XGCompileDrawIndexedVertices" />
        <func id="0xd0009" name="XGCompileShader" />
        <func id="0xd000a" name="XGCompressRect" />
        <func id="0xd000b" name="XGIsSwizzledFormat" />
        <func id="0xd000c" name="XGSetCubeTextureHeader" />
        <func id="0xd000d" name="XGSetFixupHeader" />
        <func id="0xd000e" name="XGSetIndexBufferHeader" />
        <func id="0xd000f" name="XGSetPaletteHeader" />
        <func id="0xd0010" name="XGSetPushBufferHeader" />
        <func id="0xd0011" name="XGSetSurfaceHeader" />
        <func id="0xd0012" name="XGSetTextureHeader" />
        <func id="0xd0013" name="XGSetVertexBufferHeader" />
        <func id="0xd0014" name="XGSetVolumeTextureHeader" />
        <func id="0xd0015" name="XGSpliceVertexShaders" />
        <func id="0xd0016" name="XGSUCode_CompareVertexShaders" />
        <func id="0xd0017" name="XGSUCode_GetVertexShaderLength" />
        <func id="0xd0018" name="XGSUCode_GetVertexShaderType" />
        <func id="0xd0019" name="XGSwizzleBox" />
        <func id="0xd001a" name="XGSwizzleRect" />
        <func id="0xd001b" name="XGUnswizzleBox" />
        <func id="0xd001c" name="XGUnswizzleRect" />
        <func id="0xd001d" name="XGWriteSurfaceOrTextureToXPR" />
        <func id="0xd001e" name="XGWriteSurfaceToFile" />
    </lib>
    <lib name="XKBD" libnames="xkbd xkbdd">
        <func id="0x50001" name="XDEVICE_TYPE_DEBUG_KEYBOARD_TABLE" />
        <func id="0x50002" name="XInputDebugGetKeystroke" />
        <func id="0x50003" name="XInputDebugInitKeyboardQueue" />
    </lib>
    <lib name="XMV" libnames="xmv xmvd">
        <func id="0xe0001" name="XMVDecoder_CloseDecoder" />
        <func id="0xe0002" name="XMVDecoder_CreateDecoderForFile" />
        <func id="0xe0003" name="XMVDecoder_CreateDecoderForPackets" />
        <func id="0xe0004" name="XMVDecoder_DisableAudioStream" />
        <func id="0xe0005" name="XMVDecoder_EnableAudioStream" />
        <func id="0xe0006" name="XMVDecoder_GetAudioDescriptor" />
        <func id="0xe0007" name="XMVDecoder_GetAudioStream" />
        <func id="0xe0008" name="XMVDecoder_GetNextFrame" />
        <func id="0xe0009" name="XMVDecoder_GetSynchronizationStream" />
        <func id="0xe000a" name="XMVDecoder_GetTimeFromStart" />
        <func id="0xe000b" name="XMVDecoder_GetVideoDescriptor" />
        <func id="0xe000c" name="XMVDecoder_Play" />
        <func id="0xe000d" name="XMVDecoder_Reset" />
        <func id="0xe000e" name="XMVDecoder_SetSynchronizationStream" />
        <func id="0xe000f" name="XMVDecoder_TerminateImmediately" />
        <func id="0xe0010" name="XMVDecoder_TerminateLoop" />
        <func id="0xe0011" name="XMVDecoder_TerminatePlayback" />
    </lib>
    <lib name="XONLINES" libnames="xnet xnetd xnetn xnetnd xnets xnetsd xonline xonlined xonlinels xonlinelsd xonlinen xonlinend xonlinesd">
        <func id="0x30083" name="_XOnlineAcceptTermsOfUse" />
        <func id="0x30063" name="_XOnlineAddUserToHD" />
        <func id="0x3007f" name="_XOnlineChangeGamerTag" />
        <func id="0x30080" name="_XOnlineChangeGamerTagResults" />
        <func id="0x30069" name="_XOnlineCleanupAsyncIO" />
        <func id="0x30082" name="_XOnlineClearSubscriptions" />
        <func id="0x30071" name="_XOnlineCreateOwnerAccount" />
        <func id="0x30092" name="_XOnlineCreateRemoteFileReference" />
        <func id="0x30093" name="_XOnlineDestroyRemoteFileReference" />
        <func id="0x3005e" name="_XOnlineDontUseTicketCacheOnNextLogon" />
        <func id="0x30072" name="_XOnlineGetCreateOwnerAccountResults" />
        <func id="0x3005d" name="_XOnlineGetLogonUserPrivateFlags" />
        <func id="0x3005f" name="_XOnlineGetMachineID" />
        <func id="0x30075" name="_XOnlineGetPaymentInfo" />
        <func id="0x30076" name="_XOnlineGetPaymentInfoResults" />
        <func id="0x30070" name="_XOnlineGetReserveNameResults" />
        <func id="0x30060" name="_XOnlineGetSerialNumber" />
        <func id="0x3006a" name="_XOnlineGetTitleId" />
        <func id="0x3006b" name="_XOnlineGetTitleVersion" />
        <func id="0x30062" name="_XOnlineGetUserFromMU" />
        <func id="0x30061" name="_XOnlineGetUsersFromHD" />
        <func id="0x30067" name="_XOnlineIsLoggedOn" />
        <func id="0x30066" name="_XOnlineIsUserCredentialPresent" />
        <func id="0x3005c" name="_XOnlineLogonTaskGetStatus" />
        <func id="0x30074" name="_XOnlineOfferingEnumerateInternal" />
        <func id="0x30073" name="_XOnlineOfferingPurchaseInternal" />
        <func id="0x30068" name="_XOnlineOverrideInfo" />
        <func id="0x30065" name="_XOnlineRemoveUserFromHD" />
        <func id="0x3006f" name="_XOnlineReserveName" />
        <func id="0x3007d" name="_XOnlineRestoreAccount" />
        <func id="0x3007e" name="_XOnlineRestoreAccountResults" />
        <func id="0x30077" name="_XOnlineSetPaymentInfo" />
        <func id="0x3006e" name="_XOnlineSetTitleGameRegion" />
        <func id="0x3006c" name="_XOnlineSetTitleId" />
        <func id="0x3006d" name="_XOnlineSetTitleVersion" />
        <func id="0x30081" name="_XOnlineSetUserAccountStatus" />
        <func id="0x30064" name="_XOnlineSetUserInMU" />
        <func id="0x30079" name="_XOnlineSetUserPIN" />
        <func id="0x3007a" name="_XOnlineSetUserPINResults" />
        <func id="0x30078" name="_XOnlineSetUserSettings" />
        <func id="0x30094" name="_XOnlineStorageGetInstallLocation" />
        <func id="0x30091" name="_XOnlineStorageReportBrokenLink" />
        <func id="0x3008f" name="_XOnlineStorageResolveName" />
        <func id="0x30090" name="_XOnlineStorageResolveNameResults" />
        <func id="0x30084" name="_XOnlineTroubleshootAccount" />
        <func id="0x30085" name="_XOnlineTroubleshootAccountResults" />
        <func id="0x3007b" name="_XOnlineVerifyBillingPIN" />
        <func id="0x3007c" name="_XOnlineVerifyVoucher" />
        <func id="0x30008" name="XOnlineChangeLogonUsers" />
        <func id="0x30009" name="XOnlineChangeLogonUsersTaskGetResults" />
        <func id="0x30002" name="XOnlineCleanup" />
        <func id="0x30086" name="XOnlineCompetitionCreate" />
        <func id="0x30088" name="XOnlineCompetitionCreateGetResults" />
        <func id="0x3001c" name="XOnlineContentInstall" />
        <func id="0x3001d" name="XOnlineContentInstallFromDVD" />
        <func id="0x3001e" name="XOnlineContentInstallGetProgress" />
        <func id="0x3001f" name="XOnlineContentSetSecurityKey" />
        <func id="0x3000e" name="XOnlineDashUpdate" />
        <func id="0x3004d" name="XOnlineDownloadFile" />
        <func id="0x3004e" name="XOnlineDownloadGetProgress" />
        <func id="0x3004f" name="XOnlineDownloadGetResults" />
        <func id="0x3004c" name="XOnlineDownloadToMemory" />
        <func id="0x30049" name="XOnlineEnumerateTitlesBegin" />
        <func id="0x3004a" name="XOnlineEnumerateTitlesContinue" />
        <func id="0x3004b" name="XOnlineEnumerateTitlesGetResults" />
        <func id="0x30046" name="XOnlineFeedbackSend" />
        <func id="0x3003f" name="XOnlineFriendsAnswerGameInvite" />
        <func id="0x3003e" name="XOnlineFriendsAnswerRequest" />
        <func id="0x30033" name="XOnlineFriendsEnumerate" />
        <func id="0x30034" name="XOnlineFriendsEnumerateFinish" />
        <func id="0x3003c" name="XOnlineFriendsGameInvite" />
        <func id="0x30041" name="XOnlineFriendsGetAcceptedGameInvite" />
        <func id="0x30035" name="XOnlineFriendsGetLatest" />
        <func id="0x30037" name="XOnlineFriendsGetLatestByFocus" />
        <func id="0x30036" name="XOnlineFriendsGetLatestByRange" />
        <func id="0x30038" name="XOnlineFriendsGetTitleName" />
        <func id="0x30040" name="XOnlineFriendsJoinGame" />
        <func id="0x30039" name="XOnlineFriendsRemove" />
        <func id="0x3003a" name="XOnlineFriendsRequest" />
        <func id="0x3003b" name="XOnlineFriendsRequestByName" />
        <func id="0x3003d" name="XOnlineFriendsRevokeGameInvite" />
        <func id="0x30032" name="XOnlineFriendsStartup" />
        <func id="0x3000a" name="XOnlineGetLogonUsers" />
        <func id="0x30031" name="XOnlineGetNotification" />
        <func id="0x3000b" name="XOnlineGetServiceInfo" />
        <func id="0x30005" name="XOnlineGetUsers" />
        <func id="0x30006" name="XOnlineLogon" />
        <func id="0x30007" name="XOnlineLogonTaskGetResults" />
        <func id="0x30025" name="XOnlineMatchSearch" />
        <func id="0x30026" name="XOnlineMatchSearchGetResults" />
        <func id="0x30027" name="XOnlineMatchSearchParse" />
        <func id="0x30028" name="XOnlineMatchSearchResultsLen" />
        <func id="0x30020" name="XOnlineMatchSessionCreate" />
        <func id="0x30023" name="XOnlineMatchSessionDelete" />
        <func id="0x30024" name="XOnlineMatchSessionFindFromID" />
        <func id="0x30022" name="XOnlineMatchSessionGetInfo" />
        <func id="0x30021" name="XOnlineMatchSessionUpdate" />
        <func id="0x30048" name="XOnlineMessageGet" />
        <func id="0x30044" name="XOnlineMutelistAdd" />
        <func id="0x30042" name="XOnlineMutelistGet" />
        <func id="0x30045" name="XOnlineMutelistRemove" />
        <func id="0x30043" name="XOnlineMutelistStartup" />
        <func id="0x3002f" name="XOnlineNotificationSetState" />
        <func id="0x30030" name="XOnlineNotificationSetUserData" />
        <func id="0x30012" name="XOnlineOfferingCancel" />
        <func id="0x30013" name="XOnlineOfferingDetails" />
        <func id="0x30014" name="XOnlineOfferingDetailsGetResults" />
        <func id="0x30015" name="XOnlineOfferingDetailsMaxSize" />
        <func id="0x30019" name="XOnlineOfferingEnumerate" />
        <func id="0x3001a" name="XOnlineOfferingEnumerateGetResults" />
        <func id="0x3001b" name="XOnlineOfferingEnumerateMaxSize" />
        <func id="0x30018" name="XOnlineOfferingIsNewContentAvailable" />
        <func id="0x30016" name="XOnlineOfferingPriceFormat" />
        <func id="0x30011" name="XOnlineOfferingPurchase" />
        <func id="0x30017" name="XOnlineOfferingVerifyLicense" />
        <func id="0x3000d" name="XOnlineRetrieveLogonState" />
        <func id="0x3000c" name="XOnlineSaveLogonState" />
        <func id="0x3008a" name="XOnlineSignatureVerify" />
        <func id="0x3008b" name="XOnlineSignatureVerifyGetResults" />
        <func id="0x30001" name="XOnlineStartup" />
        <func id="0x30059" name="XOnlineStatLeaderEnumerate" />
        <func id="0x3005a" name="XOnlineStatLeaderEnumerateGetResults" />
        <func id="0x30057" name="XOnlineStatRead" />
        <func id="0x30058" name="XOnlineStatReadGetResult" />
        <func id="0x3005b" name="XOnlineStatReset" />
        <func id="0x30056" name="XOnlineStatWrite" />
        <func id="0x30089" name="XOnlineStatWriteGetResult" />
        <func id="0x3008d" name="XOnlineStorageDownload" />
        <func id="0x3008e" name="XOnlineStorageGetProgress" />
        <func id="0x3008c" name="XOnlineStorageUpload" />
        <func id="0x30047" name="XOnlineStringGet" />
        <func id="0x30004" name="XOnlineTaskClose" />
        <func id="0x30003" name="XOnlineTaskContinue" />
        <func id="0x3002e" name="XOnlineTitleIdIsSamePublisher" />
        <func id="0x3002d" name="XOnlineTitleIdIsSameTitle" />
        <func id="0x3002a" name="XOnlineTitleNameLookup" />
        <func id="0x3002c" name="XOnlineTitleNameReset" />
        <func id="0x3002b" name="XOnlineTitleNameSetName" />
        <func id="0x30029" name="XOnlineTitleNameStartup" />
        <func id="0x3000f" name="XOnlineTitleUpdate" />
        <func id="0x30010" name="XOnlineTitleUpdateEx" />
        <func id="0x30051" name="XOnlineUploadFile" />
        <func id="0x30052" name="XOnlineUploadFileByHandle" />
        <func id="0x30050" name="XOnlineUploadFromMemory" />
        <func id="0x30053" name="XOnlineUploadGetProgress" />
        <func id="0x30054" name="XOnlineUploadGetResults" />
        <func id="0x30055" name="XOnlineVerifyNickname" />
        <func id="0x40017" name="__WSAFDIsSet" />
        <func id="0x40001" name="accept" />
        <func id="0x40002" name="bind" />
        <func id="0x40003" name="closesocket" />
        <func id="0x40004" name="connect" />
        <func id="0x40005" name="getpeername" />
        <func id="0x40006" name="getsockname" />
        <func id="0x40007" name="getsockopt" />
        <func id="0x40008" name="htonl" />
        <func id="0x40009" name="htons" />
        <func id="0x4000a" name="inet_addr" />
        <func id="0x4000b" name="ioctlsocket" />
        <func id="0x4000c" name="listen" />
        <func id="0x4000d" name="ntohl" />
        <func id="0x4000e" name="ntohs" />
        <func id="0x4000f" name="recv" />
        <func id="0x40010" name="recvfrom" />
        <func id="0x40011" name="select" />
        <func id="0x40012" name="send" />
        <func id="0x40013" name="sendto" />
        <func id="0x40014" name="setsockopt" />
        <func id="0x40015" name="shutdown" />
        <func id="0x40016" name="socket" />
        <func id="0x4003b" name="WSACancelOverlappedIO" />
        <func id="0x40019" name="WSACleanup" />
        <func id="0x4001c" name="WSACloseEvent" />
        <func id="0x4001d" name="WSACreateEvent" />
        <func id="0x4001b" name="WSAGetLastError" />
        <func id="0x4001e" name="WSAGetOverlappedResult" />
        <func id="0x4001f" name="WSARecv" />
        <func id="0x40020" name="WSARecvFrom" />
        <func id="0x40021" name="WSAResetEvent" />
        <func id="0x40022" name="WSASend" />
        <func id="0x40023" name="WSASendTo" />
        <func id="0x40024" name="WSASetEvent" />
        <func id="0x4001a" name="WSASetLastError" />
        <func id="0x40018" name="WSAStartup" />
        <func id="0x40025" name="WSAWaitForMultipleEvents" />
        <func id="0x40048" name="XNetCapture" />
        <func id="0x40027" name="XNetCleanup" />
        <func id="0x40041" name="XNetCloseConfigVolume" />
        <func id="0x40046" name="XNetConfig" />
        <func id="0x40045" name="XNetConfigUPnP" />
        <func id="0x40031" name="XNetConnect" />
        <func id="0x40029" name="XNetCreateKey" />
        <func id="0x40033" name="XNetDnsLookup" />
        <func id="0x40034" name="XNetDnsRelease" />
        <func id="0x40047" name="XNetGetConfigStatus" />
        <func id="0x40032" name="XNetGetConnectStatus" />
        <func id="0x40039" name="XNetGetDebugXnAddr" />
        <func id="0x4003a" name="XNetGetEthernetLinkStatus" />
        <func id="0x40038" name="XNetGetTitleXnAddr" />
        <func id="0x4002f" name="XNetInAddrToString" />
        <func id="0x4002e" name="XNetInAddrToXnAddr" />
        <func id="0x40042" name="XNetLoadConfigParams" />
        <func id="0x4003f" name="XNetLoadConfigSector" />
        <func id="0x4003e" name="XNetOpenConfigVolume" />
        <func id="0x40035" name="XNetQosListen" />
        <func id="0x40036" name="XNetQosLookup" />
        <func id="0x40037" name="XNetQosRelease" />
        <func id="0x40028" name="XNetRandom" />
        <func id="0x4002a" name="XNetRegisterKey" />
        <func id="0x40043" name="XNetSaveConfigParams" />
        <func id="0x40040" name="XNetSaveConfigSector" />
        <func id="0x4002d" name="XNetServerToInAddr" />
        <func id="0x40026" name="XNetStartup" />
        <func id="0x40030" name="XNetUnregisterInAddr" />
        <func id="0x4002b" name="XNetUnregisterKey" />
        <func id="0x40044" name="XNetUpdateConfigParams" />
        <func id="0x4002c" name="XNetXnAddrToInAddr" />
        <func id="0x4003c" name="XnInit" />
        <func id="0x4003d" name="XnTerm" />
    </lib>
    <lib name="D3D" libnames=" d3d8 d3d8d d3d8i d3d8ltcg">
        <func id="0x80001" name="D3D__Device" />
        <func id="0x80002" name="D3D__NullHardware" />
        <func id="0x80003" name="D3D__pDevice" />
        <func id="0x80004" name="D3D__SingleStepPusher" />
        <func id="0x80005" name="D3D_AllocContiguousMemory" />
        <func id="0x80006" name="D3D_CopyContiguousMemoryToVideo" />
        <func id="0x80007" name="D3D_FreeContiguousMemory" />
        <func id="0x80008" name="D3DBaseTexture_AddRef" />
        <func id="0x80009" name="D3DBaseTexture_BlockUntilNotBusy" />
        <func id="0x8000a" name="D3DBaseTexture_FreePrivateData" />
        <func id="0x8000b" name="D3DBaseTexture_GetDevice" />
        <func id="0x8000c" name="D3DBaseTexture_GetLevelCount" />
        <func id="0x8000d" name="D3DBaseTexture_GetPrivateData" />
        <func id="0x8000e" name="D3DBaseTexture_GetType" />
        <func id="0x8000f" name="D3DBaseTexture_IsBusy" />
        <func id="0x80010" name="D3DBaseTexture_MoveResourceMemory" />
        <func id="0x80011" name="D3DBaseTexture_Register" />
        <func id="0x80012" name="D3DBaseTexture_Release" />
        <func id="0x80013" name="D3DBaseTexture_SetPrivateData" />
        <func id="0x80014" name="D3DCubeTexture_AddRef" />
        <func id="0x80015" name="D3DCubeTexture_BlockUntilNotBusy" />
        <func id="0x80016" name="D3DCubeTexture_FreePrivateData" />
        <func id="0x80017" name="D3DCubeTexture_GetCubeMapSurface2" />
        <func id="0x80018" name="D3DCubeTexture_GetDevice" />
        <func id="0x80019" name="D3DCubeTexture_GetLevelCount" />
        <func id="0x8001a" name="D3DCubeTexture_GetLevelDesc" />
        <func id="0x8001b" name="D3DCubeTexture_GetPrivateData" />
        <func id="0x8001c" name="D3DCubeTexture_GetType" />
        <func id="0x8001d" name="D3DCubeTexture_IsBusy" />
        <func id="0x8001e" name="D3DCubeTexture_LockRect" />
        <func id="0x8001f" name="D3DCubeTexture_MoveResourceMemory" />
        <func id="0x80020" name="D3DCubeTexture_Register" />
        <func id="0x80021" name="D3DCubeTexture_Release" />
        <func id="0x80022" name="D3DCubeTexture_SetPrivateData" />
        <func id="0x80023" name="D3DCubeTexture_UnlockRect" />
        <func id="0x80024" name="D3DFixup_AddRef" />
        <func id="0x80025" name="D3DFixup_BlockUntilNotBusy" />
        <func id="0x80026" name="D3DFixup_FreePrivateData" />
        <func id="0x80027" name="D3DFixup_GetDevice" />
        <func id="0x80028" name="D3DFixup_GetPrivateData" />
        <func id="0x80029" name="D3DFixup_GetSize" />
        <func id="0x8002a" name="D3DFixup_GetSpace" />
        <func id="0x8002b" name="D3DFixup_GetType" />
        <func id="0x8002c" name="D3DFixup_IsBusy" />
        <func id="0x8002d" name="D3DFixup_MoveResourceMemory" />
        <func id="0x8002e" name="D3DFixup_Register" />
        <func id="0x8002f" name="D3DFixup_Release" />
        <func id="0x80030" name="D3DFixup_Reset" />
        <func id="0x80031" name="D3DFixup_SetPrivateData" />
        <func id="0x80032" name="D3DIndexBuffer_AddRef" />
        <func id="0x80033" name="D3DIndexBuffer_BlockUntilNotBusy" />
        <func id="0x80034" name="D3DIndexBuffer_FreePrivateData" />
        <func id="0x80035" name="D3DIndexBuffer_GetDesc" />
        <func id="0x80036" name="D3DIndexBuffer_GetDevice" />
        <func id="0x80037" name="D3DIndexBuffer_GetPrivateData" />
        <func id="0x80038" name="D3DIndexBuffer_GetType" />
        <func id="0x80039" name="D3DIndexBuffer_IsBusy" />
        <func id="0x8003a" name="D3DIndexBuffer_Lock" />
        <func id="0x8003b" name="D3DIndexBuffer_MoveResourceMemory" />
        <func id="0x8003c" name="D3DIndexBuffer_Register" />
        <func id="0x8003d" name="D3DIndexBuffer_Release" />
        <func id="0x8003e" name="D3DIndexBuffer_SetPrivateData" />
        <func id="0x8003f" name="D3DIndexBuffer_Unlock" />
        <func id="0x80040" name="D3DPalette_AddRef" />
        <func id="0x80041" name="D3DPalette_BlockUntilNotBusy" />
        <func id="0x80042" name="D3DPalette_FreePrivateData" />
        <func id="0x80043" name="D3DPalette_GetDevice" />
        <func id="0x80044" name="D3DPalette_GetPrivateData" />
        <func id="0x80045" name="D3DPalette_GetSize" />
        <func id="0x80046" name="D3DPalette_GetType" />
        <func id="0x80047" name="D3DPalette_IsBusy" />
        <func id="0x80048" name="D3DPalette_Lock2" />
        <func id="0x80049" name="D3DPalette_MoveResourceMemory" />
        <func id="0x8004a" name="D3DPalette_Register" />
        <func id="0x8004b" name="D3DPalette_Release" />
        <func id="0x8004c" name="D3DPalette_SetPrivateData" />
        <func id="0x8004d" name="D3DPalette_Unlock" />
        <func id="0x8004e" name="D3DPushBuffer_AddRef" />
        <func id="0x8004f" name="D3DPushBuffer_BeginFixup" />
        <func id="0x80050" name="D3DPushBuffer_BlockUntilNotBusy" />
        <func id="0x80051" name="D3DPushBuffer_CopyRects" />
        <func id="0x80052" name="D3DPushBuffer_EndFixup" />
        <func id="0x80053" name="D3DPushBuffer_EndVisibilityTest" />
        <func id="0x80054" name="D3DPushBuffer_FreePrivateData" />
        <func id="0x80055" name="D3DPushBuffer_GetDevice" />
        <func id="0x80056" name="D3DPushBuffer_GetPrivateData" />
        <func id="0x80057" name="D3DPushBuffer_GetType" />
        <func id="0x80058" name="D3DPushBuffer_IsBusy" />
        <func id="0x80059" name="D3DPushBuffer_Jump" />
        <func id="0x8005a" name="D3DPushBuffer_MoveResourceMemory" />
        <func id="0x8005b" name="D3DPushBuffer_Register" />
        <func id="0x8005c" name="D3DPushBuffer_Release" />
        <func id="0x8005d" name="D3DPushBuffer_RunPushBuffer" />
        <func id="0x8005e" name="D3DPushBuffer_SetModelView" />
        <func id="0x8005f" name="D3DPushBuffer_SetPalette" />
        <func id="0x80060" name="D3DPushBuffer_SetPrivateData" />
        <func id="0x80061" name="D3DPushBuffer_SetRenderState" />
        <func id="0x80062" name="D3DPushBuffer_SetRenderTarget" />
        <func id="0x80063" name="D3DPushBuffer_SetTexture" />
        <func id="0x80064" name="D3DPushBuffer_SetVertexBlendModelView" />
        <func id="0x80065" name="D3DPushBuffer_SetVertexShaderConstant" />
        <func id="0x80066" name="D3DPushBuffer_SetVertexShaderInput" />
        <func id="0x80067" name="D3DPushBuffer_SetVertexShaderInputDirect" />
        <func id="0x80068" name="D3DPushBuffer_Verify" />
        <func id="0x80069" name="D3DResource_AddRef" />
        <func id="0x8006a" name="D3DResource_BlockUntilNotBusy" />
        <func id="0x8006b" name="D3DResource_FreePrivateData" />
        <func id="0x8006c" name="D3DResource_GetDevice" />
        <func id="0x8006d" name="D3DResource_GetPrivateData" />
        <func id="0x8006e" name="D3DResource_GetType" />
        <func id="0x8006f" name="D3DResource_IsBusy" />
        <func id="0x80070" name="D3DResource_MoveResourceMemory" />
        <func id="0x80071" name="D3DResource_Register" />
        <func id="0x80072" name="D3DResource_Release" />
        <func id="0x80073" name="D3DResource_SetPrivateData" />
        <func id="0x80074" name="D3DSurface_AddRef" />
        <func id="0x80075" name="D3DSurface_BlockUntilNotBusy" />
        <func id="0x80076" name="D3DSurface_FreePrivateData" />
        <func id="0x80077" name="D3DSurface_GetContainer2" />
        <func id="0x80078" name="D3DSurface_GetDesc" />
        <func id="0x80079" name="D3DSurface_GetDevice" />
        <func id="0x8007a" name="D3DSurface_GetPrivateData" />
        <func id="0x8007b" name="D3DSurface_GetType" />
        <func id="0x8007c" name="D3DSurface_IsBusy" />
        <func id="0x8007d" name="D3DSurface_LockRect" />
        <func id="0x8007e" name="D3DSurface_MoveResourceMemory" />
        <func id="0x8007f" name="D3DSurface_Register" />
        <func id="0x80080" name="D3DSurface_Release" />
        <func id="0x80081" name="D3DSurface_SetPrivateData" />
        <func id="0x80082" name="D3DSurface_UnlockRect" />
        <func id="0x80083" name="D3DTexture_AddRef" />
        <func id="0x80084" name="D3DTexture_BlockUntilNotBusy" />
        <func id="0x80085" name="D3DTexture_FreePrivateData" />
        <func id="0x80086" name="D3DTexture_GetDevice" />
        <func id="0x80087" name="D3DTexture_GetLevelCount" />
        <func id="0x80088" name="D3DTexture_GetLevelDesc" />
        <func id="0x80089" name="D3DTexture_GetPrivateData" />
        <func id="0x8008a" name="D3DTexture_GetSurfaceLevel2" />
        <func id="0x8008b" name="D3DTexture_GetType" />
        <func id="0x8008c" name="D3DTexture_IsBusy" />
        <func id="0x8008d" name="D3DTexture_LockRect" />
        <func id="0x8008e" name="D3DTexture_MoveResourceMemory" />
        <func id="0x8008f" name="D3DTexture_Register" />
        <func id="0x80090" name="D3DTexture_Release" />
        <func id="0x80091" name="D3DTexture_SetPrivateData" />
        <func id="0x80092" name="D3DTexture_UnlockRect" />
        <func id="0x80093" name="D3DVertexBuffer_AddRef" />
        <func id="0x80094" name="D3DVertexBuffer_BlockUntilNotBusy" />
        <func id="0x80095" name="D3DVertexBuffer_FreePrivateData" />
        <func id="0x80096" name="D3DVertexBuffer_GetDesc" />
        <func id="0x80097" name="D3DVertexBuffer_GetDevice" />
        <func id="0x80098" name="D3DVertexBuffer_GetPrivateData" />
        <func id="0x80099" name="D3DVertexBuffer_GetType" />
        <func id="0x8009a" name="D3DVertexBuffer_IsBusy" />
        <func id="0x8009b" name="D3DVertexBuffer_Lock2" />
        <func id="0x8009c" name="D3DVertexBuffer_MoveResourceMemory" />
        <func id="0x8009d" name="D3DVertexBuffer_Register" />
        <func id="0x8009e" name="D3DVertexBuffer_Release" />
        <func id="0x8009f" name="D3DVertexBuffer_SetPrivateData" />
        <func id="0x800a0" name="D3DVertexBuffer_Unlock" />
        <func id="0x800a1" name="D3DVolume_AddRef" />
        <func id="0x800a2" name="D3DVolume_BlockUntilNotBusy" />
        <func id="0x800a3" name="D3DVolume_FreePrivateData" />
        <func id="0x800a4" name="D3DVolume_GetContainer2" />
        <func id="0x800a5" name="D3DVolume_GetDesc" />
        <func id="0x800a6" name="D3DVolume_GetDevice" />
        <func id="0x800a7" name="D3DVolume_GetPrivateData" />
        <func id="0x800a8" name="D3DVolume_GetType" />
        <func id="0x800a9" name="D3DVolume_IsBusy" />
        <func id="0x800aa" name="D3DVolume_LockBox" />
        <func id="0x800ab" name="D3DVolume_MoveResourceMemory" />
        <func id="0x800ac" name="D3DVolume_Register" />
        <func id="0x800ad" name="D3DVolume_Release" />
        <func id="0x800ae" name="D3DVolume_SetPrivateData" />
        <func id="0x800af" name="D3DVolume_UnlockBox" />
        <func id="0x800b0" name="D3DVolumeTexture_AddRef" />
        <func id="0x800b1" name="D3DVolumeTexture_BlockUntilNotBusy" />
        <func id="0x800b2" name="D3DVolumeTexture_FreePrivateData" />
        <func id="0x800b3" name="D3DVolumeTexture_GetDevice" />
        <func id="0x800b4" name="D3DVolumeTexture_GetLevelCount" />
        <func id="0x800b5" name="D3DVolumeTexture_GetLevelDesc" />
        <func id="0x800b6" name="D3DVolumeTexture_GetPrivateData" />
        <func id="0x800b7" name="D3DVolumeTexture_GetType" />
        <func id="0x800b8" name="D3DVolumeTexture_GetVolumeLevel2" />
        <func id="0x800b9" name="D3DVolumeTexture_IsBusy" />
        <func id="0x800ba" name="D3DVolumeTexture_LockBox" />
        <func id="0x800bb" name="D3DVolumeTexture_MoveResourceMemory" />
        <func id="0x800bc" name="D3DVolumeTexture_Register" />
        <func id="0x800bd" name="D3DVolumeTexture_Release" />
        <func id="0x800be" name="D3DVolumeTexture_SetPrivateData" />
        <func id="0x800bf" name="D3DVolumeTexture_UnlockBox" />
        <func id="0x800c0" name="Direct3D_AddRef" />
        <func id="0x800c1" name="Direct3D_CheckDepthStencilMatch" />
        <func id="0x800c2" name="Direct3D_CheckDeviceFormat" />
        <func id="0x800c3" name="Direct3D_CheckDeviceMultiSampleType" />
        <func id="0x800c4" name="Direct3D_CheckDeviceType" />
        <func id="0x800c5" name="Direct3D_CreateDevice" />
        <func id="0x800c6" name="Direct3D_EnumAdapterModes" />
        <func id="0x800c7" name="Direct3D_GetAdapterCount" />
        <func id="0x800c8" name="Direct3D_GetAdapterDisplayMode" />
        <func id="0x800c9" name="Direct3D_GetAdapterIdentifier" />
        <func id="0x800ca" name="Direct3D_GetAdapterModeCount" />
        <func id="0x800cb" name="Direct3D_GetDeviceCaps" />
        <func id="0x800cc" name="Direct3D_Release" />
        <func id="0x800cd" name="Direct3D_SetPushBufferSize" />
        <func id="0x800ce" name="IDirect3D8_AddRef" />
        <func id="0x800cf" name="IDirect3D8_CheckDepthStencilMatch" />
        <func id="0x800d0" name="IDirect3D8_CheckDeviceFormat" />
        <func id="0x800d1" name="IDirect3D8_CheckDeviceMultiSampleType" />
        <func id="0x800d2" name="IDirect3D8_CheckDeviceType" />
        <func id="0x800d3" name="IDirect3D8_CreateDevice" />
        <func id="0x800d4" name="IDirect3D8_EnumAdapterModes" />
        <func id="0x800d5" name="IDirect3D8_GetAdapterCount" />
        <func id="0x800d6" name="IDirect3D8_GetAdapterDisplayMode" />
        <func id="0x800d7" name="IDirect3D8_GetAdapterIdentifier" />
        <func id="0x800d8" name="IDirect3D8_GetAdapterModeCount" />
        <func id="0x800d9" name="IDirect3D8_GetDeviceCaps" />
        <func id="0x800da" name="IDirect3D8_Release" />
        <func id="0x800db" name="IDirect3D8_SetPushBufferSize" />
        <func id="0x800dc" name="IDirect3DBaseTexture8_AddRef" />
        <func id="0x800dd" name="IDirect3DBaseTexture8_BlockUntilNotBusy" />
        <func id="0x800de" name="IDirect3DBaseTexture8_FreePrivateData" />
        <func id="0x800df" name="IDirect3DBaseTexture8_GetDevice" />
        <func id="0x800e0" name="IDirect3DBaseTexture8_GetLevelCount" />
        <func id="0x800e1" name="IDirect3DBaseTexture8_GetPrivateData" />
        <func id="0x800e2" name="IDirect3DBaseTexture8_GetType" />
        <func id="0x800e3" name="IDirect3DBaseTexture8_IsBusy" />
        <func id="0x800e4" name="IDirect3DBaseTexture8_MoveResourceMemory" />
        <func id="0x800e5" name="IDirect3DBaseTexture8_Register" />
        <func id="0x800e6" name="IDirect3DBaseTexture8_Release" />
        <func id="0x800e7" name="IDirect3DBaseTexture8_SetPrivateData" />
        <func id="0x800e8" name="IDirect3DCubeTexture8_AddRef" />
        <func id="0x800e9" name="IDirect3DCubeTexture8_BlockUntilNotBusy" />
        <func id="0x800ea" name="IDirect3DCubeTexture8_FreePrivateData" />
        <func id="0x800eb" name="IDirect3DCubeTexture8_GetCubeMapSurface" />
        <func id="0x800ec" name="IDirect3DCubeTexture8_GetDevice" />
        <func id="0x800ed" name="IDirect3DCubeTexture8_GetLevelCount" />
        <func id="0x800ee" name="IDirect3DCubeTexture8_GetLevelDesc" />
        <func id="0x800ef" name="IDirect3DCubeTexture8_GetPrivateData" />
        <func id="0x800f0" name="IDirect3DCubeTexture8_GetType" />
        <func id="0x800f1" name="IDirect3DCubeTexture8_IsBusy" />
        <func id="0x800f2" name="IDirect3DCubeTexture8_LockRect" />
        <func id="0x800f3" name="IDirect3DCubeTexture8_MoveResourceMemory" />
        <func id="0x800f4" name="IDirect3DCubeTexture8_Register" />
        <func id="0x800f5" name="IDirect3DCubeTexture8_Release" />
        <func id="0x800f6" name="IDirect3DCubeTexture8_SetPrivateData" />
        <func id="0x800f7" name="IDirect3DCubeTexture8_UnlockRect" />
        <func id="0x800f8" name="IDirect3DFixup8_AddRef" />
        <func id="0x800f9" name="IDirect3DFixup8_BlockUntilNotBusy" />
        <func id="0x800fa" name="IDirect3DFixup8_FreePrivateData" />
        <func id="0x800fb" name="IDirect3DFixup8_GetDevice" />
        <func id="0x800fc" name="IDirect3DFixup8_GetPrivateData" />
        <func id="0x800fd" name="IDirect3DFixup8_GetSize" />
        <func id="0x800fe" name="IDirect3DFixup8_GetSpace" />
        <func id="0x800ff" name="IDirect3DFixup8_GetType" />
        <func id="0x80100" name="IDirect3DFixup8_IsBusy" />
        <func id="0x80101" name="IDirect3DFixup8_MoveResourceMemory" />
        <func id="0x80102" name="IDirect3DFixup8_Register" />
        <func id="0x80103" name="IDirect3DFixup8_Release" />
        <func id="0x80104" name="IDirect3DFixup8_Reset" />
        <func id="0x80105" name="IDirect3DFixup8_SetPrivateData" />
        <func id="0x80106" name="IDirect3DIndexBuffer8_AddRef" />
        <func id="0x80107" name="IDirect3DIndexBuffer8_BlockUntilNotBusy" />
        <func id="0x80108" name="IDirect3DIndexBuffer8_FreePrivateData" />
        <func id="0x80109" name="IDirect3DIndexBuffer8_GetDesc" />
        <func id="0x8010a" name="IDirect3DIndexBuffer8_GetDevice" />
        <func id="0x8010b" name="IDirect3DIndexBuffer8_GetPrivateData" />
        <func id="0x8010c" name="IDirect3DIndexBuffer8_GetType" />
        <func id="0x8010d" name="IDirect3DIndexBuffer8_IsBusy" />
        <func id="0x8010e" name="IDirect3DIndexBuffer8_Lock" />
        <func id="0x8010f" name="IDirect3DIndexBuffer8_MoveResourceMemory" />
        <func id="0x80110" name="IDirect3DIndexBuffer8_Register" />
        <func id="0x80111" name="IDirect3DIndexBuffer8_Release" />
        <func id="0x80112" name="IDirect3DIndexBuffer8_SetPrivateData" />
        <func id="0x80113" name="IDirect3DIndexBuffer8_Unlock" />
        <func id="0x80114" name="IDirect3DPalette8_AddRef" />
        <func id="0x80115" name="IDirect3DPalette8_BlockUntilNotBusy" />
        <func id="0x80116" name="IDirect3DPalette8_FreePrivateData" />
        <func id="0x80117" name="IDirect3DPalette8_GetDevice" />
        <func id="0x80118" name="IDirect3DPalette8_GetPrivateData" />
        <func id="0x80119" name="IDirect3DPalette8_GetSize" />
        <func id="0x8011a" name="IDirect3DPalette8_GetType" />
        <func id="0x8011b" name="IDirect3DPalette8_IsBusy" />
        <func id="0x8011c" name="IDirect3DPalette8_Lock" />
        <func id="0x8011d" name="IDirect3DPalette8_MoveResourceMemory" />
        <func id="0x8011e" name="IDirect3DPalette8_Register" />
        <func id="0x8011f" name="IDirect3DPalette8_Release" />
        <func id="0x80120" name="IDirect3DPalette8_SetPrivateData" />
        <func id="0x80121" name="IDirect3DPalette8_Unlock" />
        <func id="0x80122" name="IDirect3DPushBuffer8_AddRef" />
        <func id="0x80123" name="IDirect3DPushBuffer8_BeginFixup" />
        <func id="0x80124" name="IDirect3DPushBuffer8_BlockUntilNotBusy" />
        <func id="0x80125" name="IDirect3DPushBuffer8_CopyRects" />
        <func id="0x80126" name="IDirect3DPushBuffer8_EndFixup" />
        <func id="0x80127" name="IDirect3DPushBuffer8_EndVisibilityTest" />
        <func id="0x80128" name="IDirect3DPushBuffer8_FreePrivateData" />
        <func id="0x80129" name="IDirect3DPushBuffer8_GetDevice" />
        <func id="0x8012a" name="IDirect3DPushBuffer8_GetPrivateData" />
        <func id="0x8012b" name="IDirect3DPushBuffer8_GetSize" />
        <func id="0x8012c" name="IDirect3DPushBuffer8_GetType" />
        <func id="0x8012d" name="IDirect3DPushBuffer8_IsBusy" />
        <func id="0x8012e" name="IDirect3DPushBuffer8_Jump" />
        <func id="0x8012f" name="IDirect3DPushBuffer8_MoveResourceMemory" />
        <func id="0x80130" name="IDirect3DPushBuffer8_Register" />
        <func id="0x80131" name="IDirect3DPushBuffer8_Release" />
        <func id="0x80132" name="IDirect3DPushBuffer8_RunPushBuffer" />
        <func id="0x80133" name="IDirect3DPushBuffer8_SetModelView" />
        <func id="0x80134" name="IDirect3DPushBuffer8_SetPalette" />
        <func id="0x80135" name="IDirect3DPushBuffer8_SetPrivateData" />
        <func id="0x80136" name="IDirect3DPushBuffer8_SetRenderState" />
        <func id="0x80137" name="IDirect3DPushBuffer8_SetRenderTarget" />
        <func id="0x80138" name="IDirect3DPushBuffer8_SetTexture" />
        <func id="0x80139" name="IDirect3DPushBuffer8_SetVertexBlendModelView" />
        <func id="0x8013a" name="IDirect3DPushBuffer8_SetVertexShaderConstant" />
        <func id="0x8013b" name="IDirect3DPushBuffer8_SetVertexShaderInput" />
        <func id="0x8013c" name="IDirect3DPushBuffer8_SetVertexShaderInputDirect" />
        <func id="0x8013d" name="IDirect3DPushBuffer8_Verify" />
        <func id="0x8013e" name="IDirect3DResource8_AddRef" />
        <func id="0x8013f" name="IDirect3DResource8_BlockUntilNotBusy" />
        <func id="0x80140" name="IDirect3DResource8_FreePrivateData" />
        <func id="0x80141" name="IDirect3DResource8_GetDevice" />
        <func id="0x80142" name="IDirect3DResource8_GetPrivateData" />
        <func id="0x80143" name="IDirect3DResource8_GetType" />
        <func id="0x80144" name="IDirect3DResource8_IsBusy" />
        <func id="0x80145" name="IDirect3DResource8_MoveResourceMemory" />
        <func id="0x80146" name="IDirect3DResource8_Register" />
        <func id="0x80147" name="IDirect3DResource8_Release" />
        <func id="0x80148" name="IDirect3DResource8_SetPrivateData" />
        <func id="0x80149" name="IDirect3DSurface8_AddRef" />
        <func id="0x8014a" name="IDirect3DSurface8_BlockUntilNotBusy" />
        <func id="0x8014b" name="IDirect3DSurface8_FreePrivateData" />
        <func id="0x8014c" name="IDirect3DSurface8_GetContainer" />
        <func id="0x8014d" name="IDirect3DSurface8_GetDesc" />
        <func id="0x8014e" name="IDirect3DSurface8_GetDevice" />
        <func id="0x8014f" name="IDirect3DSurface8_GetPrivateData" />
        <func id="0x80150" name="IDirect3DSurface8_GetType" />
        <func id="0x80151" name="IDirect3DSurface8_IsBusy" />
        <func id="0x80152" name="IDirect3DSurface8_LockRect" />
        <func id="0x80153" name="IDirect3DSurface8_MoveResourceMemory" />
        <func id="0x80154" name="IDirect3DSurface8_Register" />
        <func id="0x80155" name="IDirect3DSurface8_Release" />
        <func id="0x80156" name="IDirect3DSurface8_SetPrivateData" />
        <func id="0x80157" name="IDirect3DSurface8_UnlockRect" />
        <func id="0x80158" name="IDirect3DTexture8_AddRef" />
        <func id="0x80159" name="IDirect3DTexture8_BlockUntilNotBusy" />
        <func id="0x8015a" name="IDirect3DTexture8_FreePrivateData" />
        <func id="0x8015b" name="IDirect3DTexture8_GetDevice" />
        <func id="0x8015c" name="IDirect3DTexture8_GetLevelCount" />
        <func id="0x8015d" name="IDirect3DTexture8_GetLevelDesc" />
        <func id="0x8015e" name="IDirect3DTexture8_GetPrivateData" />
        <func id="0x8015f" name="IDirect3DTexture8_GetSurfaceLevel" />
        <func id="0x80160" name="IDirect3DTexture8_GetType" />
        <func id="0x80161" name="IDirect3DTexture8_IsBusy" />
        <func id="0x80162" name="IDirect3DTexture8_LockRect" />
        <func id="0x80163" name="IDirect3DTexture8_MoveResourceMemory" />
        <func id="0x80164" name="IDirect3DTexture8_Register" />
        <func id="0x80165" name="IDirect3DTexture8_Release" />
        <func id="0x80166" name="IDirect3DTexture8_SetPrivateData" />
        <func id="0x80167" name="IDirect3DTexture8_UnlockRect" />
        <func id="0x80168" name="IDirect3DVertexBuffer8_AddRef" />
        <func id="0x80169" name="IDirect3DVertexBuffer8_BlockUntilNotBusy" />
        <func id="0x8016a" name="IDirect3DVertexBuffer8_FreePrivateData" />
        <func id="0x8016b" name="IDirect3DVertexBuffer8_GetDesc" />
        <func id="0x8016c" name="IDirect3DVertexBuffer8_GetDevice" />
        <func id="0x8016d" name="IDirect3DVertexBuffer8_GetPrivateData" />
        <func id="0x8016e" name="IDirect3DVertexBuffer8_GetType" />
        <func id="0x8016f" name="IDirect3DVertexBuffer8_IsBusy" />
        <func id="0x80170" name="IDirect3DVertexBuffer8_Lock" />
        <func id="0x80171" name="IDirect3DVertexBuffer8_MoveResourceMemory" />
        <func id="0x80172" name="IDirect3DVertexBuffer8_Register" />
        <func id="0x80173" name="IDirect3DVertexBuffer8_Release" />
        <func id="0x80174" name="IDirect3DVertexBuffer8_SetPrivateData" />
        <func id="0x80175" name="IDirect3DVertexBuffer8_Unlock" />
        <func id="0x80176" name="IDirect3DVolume8_AddRef" />
        <func id="0x80177" name="IDirect3DVolume8_BlockUntilNotBusy" />
        <func id="0x80178" name="IDirect3DVolume8_FreePrivateData" />
        <func id="0x80179" name="IDirect3DVolume8_GetContainer" />
        <func id="0x8017a" name="IDirect3DVolume8_GetDesc" />
        <func id="0x8017b" name="IDirect3DVolume8_GetDevice" />
        <func id="0x8017c" name="IDirect3DVolume8_GetPrivateData" />
        <func id="0x8017d" name="IDirect3DVolume8_GetType" />
        <func id="0x8017e" name="IDirect3DVolume8_IsBusy" />
        <func id="0x8017f" name="IDirect3DVolume8_LockBox" />
        <func id="0x80180" name="IDirect3DVolume8_MoveResourceMemory" />
        <func id="0x80181" name="IDirect3DVolume8_Register" />
        <func id="0x80182" name="IDirect3DVolume8_Release" />
        <func id="0x80183" name="IDirect3DVolume8_SetPrivateData" />
        <func id="0x80184" name="IDirect3DVolume8_UnlockBox" />
        <func id="0x80185" name="IDirect3DVolumeTexture8_AddRef" />
        <func id="0x80186" name="IDirect3DVolumeTexture8_BlockUntilNotBusy" />
        <func id="0x80187" name="IDirect3DVolumeTexture8_FreePrivateData" />
        <func id="0x80188" name="IDirect3DVolumeTexture8_GetDevice" />
        <func id="0x80189" name="IDirect3DVolumeTexture8_GetLevelCount" />
        <func id="0x8018a" name="IDirect3DVolumeTexture8_GetLevelDesc" />
        <func id="0x8018b" name="IDirect3DVolumeTexture8_GetPrivateData" />
        <func id="0x8018c" name="IDirect3DVolumeTexture8_GetType" />
        <func id="0x8018d" name="IDirect3DVolumeTexture8_GetVolumeLevel" />
        <func id="0x8018e" name="IDirect3DVolumeTexture8_IsBusy" />
        <func id="0x8018f" name="IDirect3DVolumeTexture8_LockBox" />
        <func id="0x80191" name="IDirect3DVolumeTexture8_MoveResourceMemory" />
        <func id="0x80192" name="IDirect3DVolumeTexture8_Register" />
        <func id="0x80193" name="IDirect3DVolumeTexture8_Release" />
        <func id="0x80194" name="IDirect3DVolumeTexture8_SetPrivateData" />
        <func id="0x80195" name="IDirect3DVolumeTexture8_UnlockBox" />
    </lib>
    <lib name="XVOICE" libnames="xvoice xvoiced">
        <func id="0x70001" name="XDEVICE_TYPE_HIGHFIDELITY_MICROPHONE_TABLE" />
        <func id="0x70002" name="XDEVICE_TYPE_VOICE_HEADPHONE_TABLE" />
        <func id="0x70003" name="XDEVICE_TYPE_VOICE_MICROPHONE_TABLE" />
        <func id="0x70004" name="XVoiceCreateFourToFourFullDecoder" />
        <func id="0x70005" name="XVoiceCreateFourToFourFullEncoder" />
        <func id="0x70006" name="XVoiceCreateFourToFourRoundRobinEncoder" />
        <func id="0x70007" name="XVoiceCreateFourToOneMixingDecoder" />
        <func id="0x70008" name="XVoiceCreateMediaObject" />
        <func id="0x70009" name="XVoiceCreateMediaObjectEx" />
        <func id="0x7000a" name="XVoiceCreateOneToOneDecoder" />
        <func id="0x7000b" name="XVoiceCreateOneToOneEncoder" />
        <func id="0x7000c" name="XVoiceCreateTwoToOneMixingDecoder" />
        <func id="0x7000d" name="XVoiceCreateTwoToTwoEncoder" />
        <func id="0x7000e" name="XVoiceGetEncodedPacketEnergy" />
        <func id="0x7000f" name="XVoiceQueueCreateMediaObject" />
        <func id="0x70010" name="XVoiceSynchronizedQueueCreateMediaObject" />
    </lib>
</xtlid>

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.27 FATAL_ERROR)

project(idaxex)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_C_STANDARD 11)

# Enable AES NI intrinsic
set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -maes")
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -maes")

include($ENV{IDASDK}/ida-cmake/common.cmake)

set(LOADER_NAME idaxex)
set(LOADER_SOURCES
  idaloader.cpp
  idaloader_xbe.cpp
  namegen.cpp
  namegen_xtlid.cpp
  formats/xbe.cpp
  formats/xex.cpp
  3rdparty/excrypt/src/excrypt_aes.c
  3rdparty/excrypt/src/rijndael.c
  3rdparty/excrypt/src/excrypt_sha.c
  3rdparty/lzx.cpp
  3rdparty/mspack/lzxd.c
  3rdparty/mspack/system.c
  3rdparty/XbSymbolDatabase/src/lib/libXbSymbolDatabase.c
  3rdparty/XbSymbolDatabase/src/OOVPADatabase/D3D8_OOVPA.c
  3rdparty/XbSymbolDatabase/src/OOVPADatabase/D3D8LTCG_OOVPA.c
  3rdparty/XbSymbolDatabase/src/OOVPADatabase/DSound_OOVPA.c
  3rdparty/XbSymbolDatabase/src/OOVPADatabase/JVS_OOVPA.c
  3rdparty/XbSymbolDatabase/src/OOVPADatabase/XActEng_OOVPA.c
  3rdparty/XbSymbolDatabase/src/OOVPADatabase/Xapi_OOVPA.c
  3rdparty/XbSymbolDatabase/src/OOVPADatabase/XGraphic_OOVPA.c
  3rdparty/XbSymbolDatabase/src/OOVPADatabase/XNet_OOVPA.c
  3rdparty/XbSymbolDatabase/src/OOVPADatabase/XOnline_OOVPA.c
)
set(LOADER_INCLUDE_DIRECTORIES 3rdparty/excrypt/src 3rdparty/XbSymbolDatabase/include 3rdparty/XbSymbolDatabase/src/OOVPADatabase $ENV{IDASDK}/ldr/pe)
add_compile_definitions(IDALDR=1)

generate()
disable_ida_warnings(idaxex)

```

`LICENSE`:

```
BSD 3-Clause License

Copyright (c) 2019, emoose
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its
   contributors may be used to endorse or promote products derived from
   this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

```

`README.md`:

```md
# idaxex

idaxex is a native loader plugin for IDA Pro, adding support for loading in Xbox360 XEX & Xbox XBE executables.

Originally started as an [IDAPython loader](https://github.com/emoose/reversing/blob/master/xbox360.py), work was continued as a native DLL to solve the shortcomings of it.

This should have the same features as xorloser's great Xex Loader (for IDA 6 and older), along with additional support for some early non-XEX2 formats, such as XEX1 used on beta-kits.

XBE files are additionally supported, adding a few extra features over the loader included with IDA.

## Supported formats

Includes support for the following Xbox executables:
- XEX2 (>= kernel 1861)
- XEX1 (>= 1838)
- XEX% (>= 1746)
- XEX- (>= 1640)
- XEX? (>= 1529)
- XEX0 (>= 1332)
- XBE (>= XboxOG ~3729)

## Features

- Can handle compressed/uncompressed images, and encrypted/decrypted (with support for retail, devkit & pre-release encryption keys)
- Reads in imports & exports into the appropriate IDA import/export views.
- Automatically names imports that are well-known, such as imports from the kernel & XAM, just like xorloser's loader would.
- PE sections are created & marked with the appropriate permissions as given by the PE headers.
- AES-NI support to help improve load times of larger XEXs.
- Marks functions from .pdata exception directory & allows IDA's eh_parse plugin to read exception information.
- Passes codeview information over to IDA, allowing it to prompt for & load PDBs without warnings/errors.
- Patched bytes can be written back to input file via IDA `Apply patches to input` option (works for all XBEs, XEX must be both uncompressed & decrypted using `xextool -eu -cu input.xex` first)
- XBE: adds kernel imports to IDA imports view
- XBE: tries naming SDK library functions using [XbSymbolDatabase](https://github.com/Cxbx-Reloaded/XbSymbolDatabase) & data from XTLID section

## Install
Builds for IDA 9 are available in the releases section.

To install the loader just extract the contents of the folder for your IDA version into IDA's install folder (eg. C:\Program Files\IDA Professional 9.0\)

I recommend pairing this loader with the PPCAltivec plugin, an updated version for IDA 7 is available at hayleyxyz's repo here: https://github.com/hayleyxyz/PPC-Altivec-IDA

## Building

Make sure to clone repo recursively for excrypt submodule to get pulled in.

**Windows**

Clone the repo into your idasdk\ldr\ folder and then build idaxex.sln with VS2022.

**Linux**

- Setup [ida-cmake](https://github.com/allthingsida/ida-cmake) in your idasdk folder
- Make sure IDASDK env var points to your idasdk folder
- Clone idaxex repo
- Run `cmake . -DEA64=YES` inside idaxex folder
- Run `make`
- To build xex1tool run cmake/make inside the xex1tool folder

On newest IDA you may need to edit ida-cmake common.cmake and change `libida64.so` to `libida.so` for build to link properly.

## Credits
Based on work by the Xenia project, XEX2.bt by Anthony, xextool 0.1 by xor37h, Xex Loader & x360_imports.idc by xorloser, xkelib, and probably many others I forgot to name.

Thanks to everyone involved in the Xbox 360 modding/reverse-engineering community!

XTLID parsing supported thanks to the [XboxDev/xtlid project](https://github.com/XboxDev/xtlid).

# xex1tool
Also included is an attempt at recreating xorloser's XexTool, for working with older pre-XEX2 executables.  
(The name is only to differentiate it from the original XexTool - it'll still support XEX2 files fine)

So far it can print info about the various XEX headers via `-l`, and extract the basefile (PE/XUIZ) from inside the XEX.

For XEX files that are both decrypted & decompressed xex1tool can also convert a VA address to a file offset for you, making file patching a little easier.

Support for other XexTool features may slowly be added over time (of course any help is appreciated!)

```

`formats/pe_structs.hpp`:

```hpp
#pragma once
#include <cstdint>

#define EXE_MZ_SIGNATURE 0x5A4D
#define EXE_NT_SIGNATURE 0x4550

typedef struct _IMAGE_DOS_HEADER
{
  uint16_t MZSignature;
  uint16_t UsedBytesInTheLastPage;
  uint16_t FileSizeInPages;
  uint16_t NumberOfRelocationItems;
  uint16_t HeaderSizeInParagraphs;
  uint16_t MinimumExtraParagraphs;
  uint16_t MaximumExtraParagraphs;
  uint16_t InitialRelativeSS;
  uint16_t InitialSP;
  uint16_t Checksum;
  uint16_t InitialIP;
  uint16_t InitialRelativeCS;
  uint16_t AddressOfRelocationTable;
  uint16_t OverlayNumber;
  uint16_t Reserved[4];
  uint16_t OEMid;
  uint16_t OEMinfo;
  uint16_t Reserved2[10];
  uint32_t AddressOfNewExeHeader;
} IMAGE_DOS_HEADER;
static_assert(sizeof(IMAGE_DOS_HEADER) == 0x40, "IMAGE_DOS_HEADER");

//
// Directory format.
//

typedef struct _IMAGE_DATA_DIRECTORY {
  uint32_t VirtualAddress;
  uint32_t Size;
} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;
static_assert(sizeof(IMAGE_DATA_DIRECTORY) == 8, "IMAGE_DATA_DIRECTORY");

#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES    16

typedef struct _IMAGE_OPTIONAL_HEADER32
{
  uint16_t Magic;
  uint8_t  MajorLinkerVersion;
  uint8_t  MinorLinkerVersion;
  uint32_t SizeOfCode;
  uint32_t SizeOfInitializedData;
  uint32_t SizeOfUninitializedData;
  uint32_t AddressOfEntryPoint;
  uint32_t BaseOfCode;
  uint32_t BaseOfData;
  uint32_t ImageBase;
  uint32_t SectionAlignment;
  uint32_t FileAlignment;
  uint16_t MajorOperatingSystemVersion;
  uint16_t MinorOperatingSystemVersion;
  uint16_t MajorImageVersion;
  uint16_t MinorImageVersion;
  uint16_t MajorSubsystemVersion;
  uint16_t MinorSubsystemVersion;
  uint32_t Win32VersionValue;
  uint32_t SizeOfImage;
  uint32_t SizeOfHeaders;
  uint32_t CheckSum;
  uint16_t Subsystem;
  uint16_t DllCharacteristics;
  uint32_t SizeOfStackReserve;
  uint32_t SizeOfStackCommit;
  uint32_t SizeOfHeapReserve;
  uint32_t SizeOfHeapCommit;
  uint32_t LoaderFlags;
  uint32_t NumberOfRvaAndSizes;
  IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER32;
static_assert(sizeof(IMAGE_OPTIONAL_HEADER32) == 0xE0, "IMAGE_OPTIONAL_HEADER32");

typedef struct _IMAGE_FILE_HEADER
{
  uint16_t Machine;
  uint16_t NumberOfSections;
  uint32_t TimeDateStamp;
  uint32_t PointerToSymbolTable;
  uint32_t NumberOfSymbols;
  uint16_t SizeOfOptionalHeader;
  uint16_t Characteristics;
} IMAGE_FILE_HEADER;
static_assert(sizeof(IMAGE_FILE_HEADER) == 0x14, "IMAGE_FILE_HEADER");

typedef struct _IMAGE_NT_HEADERS
{
  uint32_t Signature;
  IMAGE_FILE_HEADER FileHeader;
  IMAGE_OPTIONAL_HEADER32 OptionalHeader;
} IMAGE_NT_HEADERS;
static_assert(sizeof(IMAGE_NT_HEADERS) == 0xF8, "IMAGE_NT_HEADERS");

typedef struct _IMAGE_SECTION_HEADER
{
  char Name[8];
  uint32_t VirtualSize;
  uint32_t VirtualAddress;
  uint32_t SizeOfRawData;
  uint32_t PointerToRawData;
  uint32_t PointerToRelocations;
  uint32_t PointerToLinenumbers;
  uint16_t NumberOfRelocations;
  uint16_t NumberOfLineNumbers;
  uint32_t Characteristics;
} IMAGE_SECTION_HEADER;
static_assert(sizeof(IMAGE_SECTION_HEADER) == 0x28, "IMAGE_SECTION_HEADER");

// Characteristics flags
#define IMAGE_SCN_CNT_CODE 0x20
#define IMAGE_SCN_CNT_INITIALIZED_DATA 0x40
#define IMAGE_SCN_CNT_UNINITIALIZED_DATA 0x80
#define IMAGE_SCN_MEM_EXECUTE 0x20000000
#define IMAGE_SCN_MEM_READ 0x40000000
#define IMAGE_SCN_MEM_WRITE 0x80000000

// Data directory indices
#define IMAGE_DIRECTORY_ENTRY_EXPORT          0   // Export Directory
#define IMAGE_DIRECTORY_ENTRY_IMPORT          1   // Import Directory
#define IMAGE_DIRECTORY_ENTRY_RESOURCE        2   // Resource Directory
#define IMAGE_DIRECTORY_ENTRY_EXCEPTION       3   // Exception Directory
#define IMAGE_DIRECTORY_ENTRY_SECURITY        4   // Security Directory
#define IMAGE_DIRECTORY_ENTRY_BASERELOC       5   // Base Relocation Table
#define IMAGE_DIRECTORY_ENTRY_DEBUG           6   // Debug Directory
//      IMAGE_DIRECTORY_ENTRY_COPYRIGHT       7   // (X86 usage)
#define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7   // Architecture Specific Data
#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8   // RVA of GP
#define IMAGE_DIRECTORY_ENTRY_TLS             9   // TLS Directory
#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10   // Load Configuration Directory
#define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11   // Bound Import Directory in headers
#define IMAGE_DIRECTORY_ENTRY_IAT            12   // Import Address Table
#define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13   // Delay Load Import Descriptors
#define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14   // COM Runtime descriptor

typedef struct _IMAGE_IMPORT_DESCRIPTOR {
  union {
    uint32_t Characteristics; // 0 for terminating null import descriptor
    uint32_t OriginalFirstThunk; // RVA to INT
  };
  uint32_t TimeDateStamp; // Time/Date of module, or other properties (see below)
  uint32_t ForwarderChain; // Forwarder chain ID
  uint32_t Name; // Module name
  uint32_t FirstThunk; // RVA to IAT (if bound this IAT has actual addresses)
} IMAGE_IMPORT_DESCRIPTOR, *PIMAGE_IMPORT_DESCRIPTOR;
static_assert(sizeof(IMAGE_IMPORT_DESCRIPTOR) == 0x14, "IMAGE_IMPORT_DESCRIPTOR");

typedef struct _IMAGE_EXPORT_DIRECTORY
{
  uint32_t Characteristics;
  uint32_t TimeDateStamp;
  uint16_t MajorVersion;
  uint16_t MinorVersion;
  uint32_t Name;
  uint32_t Base;
  uint32_t NumberOfFunctions;
  uint32_t NumberOfNames;
  uint32_t AddressOfFunctions;
  uint32_t AddressOfNames;
  uint32_t AddressOfNameOrdinals;
} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;
static_assert(sizeof(IMAGE_EXPORT_DIRECTORY) == 0x28, "IMAGE_EXPORT_DIRECTORY");

typedef struct _IMAGE_DEBUG_DIRECTORY {
  uint32_t Characteristics;
  uint32_t TimeDateStamp;
  uint16_t MajorVersion;
  uint16_t MinorVersion;
  uint32_t Type;
  uint32_t SizeOfData;
  uint32_t AddressOfRawData;
  uint32_t PointerToRawData;
} IMAGE_DEBUG_DIRECTORY, * PIMAGE_DEBUG_DIRECTORY;
static_assert(sizeof(IMAGE_DEBUG_DIRECTORY) == 0x1C, "IMAGE_DEBUG_DIRECTORY");

#define CV_INFO_RSDS_SIGNATURE 0x53445352
struct CV_INFO_PDB70
{
  uint32_t CvSignature;
  uint8_t Signature[0x10];
  uint32_t Age;
  // followed by filename
  //BYTE PdbFileName[];
};
static_assert(sizeof(CV_INFO_PDB70) == 0x18, "CV_INFO_PDB70");

typedef struct _IMAGE_TLS_DIRECTORY32 {
  xe::be<uint32_t> StartAddressOfRawData;
  xe::be<uint32_t> EndAddressOfRawData;
  xe::be<uint32_t> AddressOfIndex;             // PDWORD
  xe::be<uint32_t> AddressOfCallBacks;         // PIMAGE_TLS_CALLBACK *
  xe::be<uint32_t> SizeOfZeroFill;
  xe::be<uint32_t> Characteristics;
} IMAGE_TLS_DIRECTORY32;
typedef IMAGE_TLS_DIRECTORY32* PIMAGE_TLS_DIRECTORY32;
static_assert(sizeof(IMAGE_TLS_DIRECTORY32) == 0x18, "IMAGE_TLS_DIRECTORY32");

```

`formats/xbe.cpp`:

```cpp
#ifdef IDALDR
#include <ida.hpp>
#include <diskio.hpp>
#include <typeinf.hpp>
#else
#include <cstdarg>
#endif
#include <array>

#include "xbe.hpp"

std::array<uint32_t, 4> kKernelThunkXORKeys = {
  kXbeXorKernel_Retail,
  kXbeXorKernel_Debug,
  kXbeXorKernel_XBLBeta,
  kXbeXorKernel_Chihiro,
};
std::array<uint32_t, 4> kEntryPointXORKeys = {
  kXbeXorEntry_Retail,
  kXbeXorEntry_Debug,
  kXbeXorEntry_XBLBeta,
  kXbeXorEntry_Chihiro,
};
std::array<const char*, 4> kXORKeyNames = {
  "Retail",
  "Debug",
  "Beta",
  "Chihiro"
};

const char* XBEFile::key_name(int xor_key_idx)
{
  if (xor_key_idx >= 0 && xor_key_idx < kXORKeyNames.size())
    return kXORKeyNames[xor_key_idx];
  return "Unknown";
}

bool XBEFile::is_xorkey_beta()
{
  if (xorkey_index_ < 0 || xorkey_index_ >= kKernelThunkXORKeys.size())
    return false;

  return kKernelThunkXORKeys[xorkey_index_] == kXbeXorKernel_XBLBeta;
}

bool XBEFile::load(void* file)
{
  seek(file, 0, SEEK_END);
  image_length_ = tell(file);
  seek(file, 0, SEEK_SET);

  // keep a copy of the full XBE so we can pass it to XbSymbolDatabase later
  xbe_data_.resize(image_length_);
  read(xbe_data_.data(), 1, image_length_, file);
  seek(file, 0, SEEK_SET);

  sections_.clear();
  load_error_ = uint32_t(XBELoadError::Unfinished);

  // Read XBE header
  read(&xbe_header_, sizeof(xbe::XbeHeader), 1, file);
  if (xbe_header_.Signature != MAGIC_XBEH)
  {
    load_error_ = uint32_t(XBELoadError::InvalidMagic);
    return false;
  }

  // Read header bytes
  seek(file, 0, SEEK_SET);
  header_data_.resize(xbe_header_.SizeOfHeaders);
  read(header_data_.data(), 1, xbe_header_.SizeOfHeaders, file);

  // Read XBE sections
  uint32_t sections_begin = xbe_va_to_offset(xbe_header_.SectionHeadersOffset);
  seek(file, sections_begin, SEEK_SET);
  for (uint32_t i = 0; i < xbe_header_.NumberOfSections; i++)
  {
    XBESection section;
    read(&section.Info, sizeof(xbe::XbeSection), 1, file);
    auto pos = tell(file);

    // Read section name
    seek(file, xbe_va_to_offset(section.Info.SectionNameOffset), SEEK_SET);
    section.Name = read_null_terminated(file, 64);

    // Figure out section data size
    section.DataSize = section.Info.VirtualSize;

    // If virtual size is beyond file bounds, resize it to what we can fit
    // TODO: should probably check against offset of other sections too, so we don't include their data
    if (section.Info.PointerToRawData + section.DataSize > image_length_)
      section.DataSize = image_length_ - section.Info.PointerToRawData;

    sections_.push_back(section);

    // Seek back to end of XbeSection
    seek(file, pos, SEEK_SET);
  }

  // Read library info
  libraries_.clear();
  if (xbe_header_.LibraryVersionsOffset && xbe_header_.NumberOfLibraryVersions)
  {
    auto lib_versions_offset = xbe_va_to_offset(xbe_header_.LibraryVersionsOffset);
    if (image_length_ > lib_versions_offset)
    {
      seek(file, lib_versions_offset, SEEK_SET);
      for (uint32_t i = 0; i < xbe_header_.NumberOfLibraryVersions; i++)
      {
        xbe::XbeLibraryVersion version;
        read(&version, sizeof(xbe::XbeLibraryVersion), 1, file);
        libraries_.push_back(version);
      }
    }
  }

  // Read PE name
  if (xbe_header_.DebugPathNameOffset)
  {
    auto path_offset = xbe_va_to_offset(xbe_header_.DebugPathNameOffset);
    if (image_length_ > path_offset)
    {
      seek(file, path_offset, SEEK_SET);
      pe_module_name_ = read_null_terminated(file, 256);
    }
  }

  // Read in callbacks from TLS directory if exists
  if (xbe_header_.TlsDirectoryOffset)
  {
    auto tls_dir_offset = xbe_va_to_offset(xbe_header_.TlsDirectoryOffset);
    if (image_length_ > tls_dir_offset)
    {
      tls_directory_va_ = xbe_header_.TlsDirectoryOffset;
      seek(file, tls_dir_offset, 0);
      read(&tls_directory_, sizeof(IMAGE_TLS_DIRECTORY32), 1, file);
      if (tls_directory_.AddressOfCallBacks)
      {
        auto callback_offset = xbe_va_to_offset(tls_directory_.AddressOfCallBacks);
        dbgmsg("[+] Reading TLS callbacks from 0x%X (directory: 0x%X)\n", tls_directory_.AddressOfCallBacks, tls_directory_va_);

        if (image_length_ >= (callback_offset + sizeof(uint32_t)))
        {
          seek(file, callback_offset, 0);
          uint32_t callback = 0;
          read(&callback, sizeof(uint32_t), 1, file);
          while (callback)
          {
            tls_callbacks_.push_back(callback);
            read(&callback, sizeof(uint32_t), 1, file);
          }
        }
      }
    }
  }

  // Read debug info
  // TODO: scan for codeview RSDS header in older XBEs which don't include codeview offset in headers?
  if (xbe_header_.has_codeview_offset() && xbe_header_.CodeViewDebugInfoOffset)
  {
    auto codeview_offset = xbe_va_to_offset(xbe_header_.CodeViewDebugInfoOffset);
    if (image_length_ > codeview_offset)
    {
      CV_INFO_PDB70 cv_info;
      seek(file, codeview_offset, 0);
      read(&cv_info, sizeof(CV_INFO_PDB70), 1, file);
      if (cv_info.CvSignature == CV_INFO_RSDS_SIGNATURE)
      {
        std::string cv_fname = read_null_terminated(file, 256);

        std::vector<uint8_t> cv_data;
        cv_data.resize(sizeof(CV_INFO_PDB70) + cv_fname.length() + 1);
        std::copy_n((uint8_t*)&cv_info, sizeof(CV_INFO_PDB70), cv_data.data());
        std::copy_n(cv_fname.c_str(), cv_fname.length(), cv_data.data() + sizeof(CV_INFO_PDB70));
        cv_data[sizeof(CV_INFO_PDB70) + cv_fname.length()] = 0;

        codeview_data_.push_back(cv_data);
      }
    }
  }

  // Try figuring out the XOR key to use
  xorkey_index_ = -1;
  for (int i = 0; i < kKernelThunkXORKeys.size(); i++)
  {
    uint32_t decrypted_thunk = xbe_header_.XboxKernelThunkDataOffset ^ kKernelThunkXORKeys[i];
    uint32_t decrypted_ep = xbe_header_.AddressOfEntryPoint ^ kEntryPointXORKeys[i];

    // If decrypted_thunk & decrypted_ep are between baseaddr and sizeofimage it's likely valid
    // TODO: should probably verify that ordinals look good though
    bool valid_thunk = decrypted_thunk >= xbe_header_.BaseAddress && decrypted_thunk < (xbe_header_.BaseAddress + xbe_header_.SizeOfImage);
    bool valid_ep = decrypted_ep >= xbe_header_.BaseAddress && decrypted_ep < (xbe_header_.BaseAddress + xbe_header_.SizeOfImage);
    if (valid_thunk && valid_ep)
    {
      xorkey_index_ = i;
      xbe_header_.XboxKernelThunkDataOffset = decrypted_thunk;
      xbe_header_.AddressOfEntryPoint = decrypted_ep;
      break;
    }
  }

  if (xorkey_index_ < 0)
  {
    load_error_ = uint32_t(XBELoadError::UnknownXORKey);
    return false;
  }

  // Read kernel imports
  {
    uint32_t kernel_thunk_offset = xbe_va_to_offset(xbe_header_.XboxKernelThunkDataOffset);
    if (image_length_ > kernel_thunk_offset)
    {
      seek(file, kernel_thunk_offset, 0);

      int num = 0;
      while (num < 400)
      {
        uint32_t ordinal = 0;
        read(&ordinal, sizeof(uint32_t), 1, file);
        if (!ordinal)
          break;

        if ((ordinal & IMAGE_ORDINAL_FLAG32) == IMAGE_ORDINAL_FLAG32)
        {
          kernel_imports_.insert({ xbe_header_.XboxKernelThunkDataOffset + (num * 4), IMAGE_ORDINAL32(ordinal) });
        }
        else
        {
          // TODO: error? these should always have ordinal flag
        }
        num++;
      }
    }
  }

  load_error_ = uint32_t(XBELoadError::Success);
  return true;
}

uint32_t XBEFile::xbe_va_to_offset(uint32_t va)
{
  if (va < xbe_header_.BaseAddress)
    return va;

  for (auto& section : sections_)
  {
    uint32_t section_end = section.Info.VirtualAddress + section.Info.VirtualSize;
    if (section.Info.VirtualAddress > va || va >= section_end)
      continue;
    return (va - section.Info.VirtualAddress) + section.Info.PointerToRawData;
  }
  return va - xbe_header_.BaseAddress;
}

std::string XBEFile::read_null_terminated(void* file, size_t maxlen) {
  std::string result;
  char ch;
  std::size_t count = 0;

  // Read one character at a time using fread, stopping at maxlen or null terminator
  while (count < maxlen && read(&ch, sizeof(char), 1, file) == 1) {
    if (ch == '\0') {
      break;
    }
    result += ch;
    ++count;
  }

  return result;
}

#ifdef IDALDR
// Shim function to allow using IDA's qlread function
size_t idaread_xbe(void* buffer, size_t element_size, size_t element_count, void* file)
{
  return qlread((linput_t*)file, buffer, element_size * element_count);
}

void XBEFile::use_ida_io()
{
  read = idaread_xbe;
  seek = (seek_fn)qlseek;
  tell = (tell_fn)qltell;
  dbgmsg = msg;
}
#endif

```

`formats/xbe.hpp`:

```hpp
#pragma once
#include <cstdint>
#include <vector>
#include <algorithm>
#include <map>
#include <string>

#include "xbe_keys.hpp"
#include "xbe_structs.hpp"
#include "xex.hpp" // stdio crap

#define MAGIC_XBEH 0x48454258
#define MAGIC_XBEH_BE 0x58424548

struct XBESection
{
  std::string Name;
  xbe::XbeSection Info;
  uint32_t DataSize;
};

enum class XBELoadError
{
  Success,
  Unfinished,
  InvalidMagic,
  UnknownXORKey,
  Count
};

class XBEFile
{
  // IO function pointers
  read_fn read = nullptr;
  seek_fn seek = nullptr;
  tell_fn tell = nullptr;
  dbgmsg_fn dbgmsg = nullptr;

  size_t image_length_ = 0; // length of xbe file

  xbe::XbeHeader xbe_header_ = {};
  std::vector<uint8_t> xbe_data_;
  std::vector<uint8_t> header_data_;

  std::vector<XBESection> sections_;
  std::map<uint32_t, uint32_t> kernel_imports_;
  std::vector<std::vector<uint8_t>> codeview_data_;
  uint32_t tls_directory_va_ = 0;
  IMAGE_TLS_DIRECTORY32 tls_directory_{};
  std::vector<uint32_t> tls_callbacks_;

  std::vector<xbe::XbeLibraryVersion> libraries_; // Versions of libraries this was linked against
  std::string pe_module_name_ = "";

  int load_error_ = 0;

  int xorkey_index_ = -1;

  std::string read_null_terminated(void* file, std::size_t maxlen);

public:
  XBEFile() {
#ifndef IDALDR
#ifdef _MSC_VER
    read = (read_fn)fread; seek = (seek_fn)_fseeki64; tell = (tell_fn)_ftelli64; dbgmsg = stdio_msg;
#else
    read = (read_fn)fread; seek = (seek_fn)fseeko64; tell = (tell_fn)ftello64; dbgmsg = stdio_msg;
#endif
#endif
  }

  static const char* key_name(int xor_key_idx);

  uint32_t base_address() { return xbe_header_.BaseAddress; }
  uint32_t entry_point() { return xbe_header_.AddressOfEntryPoint; }
  uint32_t image_size() { return xbe_header_.SizeOfImage; }
  int xorkey_index() { return xorkey_index_; }
  bool is_xorkey_beta();

  const std::string& pe_module_name() { return pe_module_name_; }

  uint32_t tls_directory_va() { return tls_directory_va_; }
  IMAGE_TLS_DIRECTORY32 tls_directory() { return tls_directory_; }
  const std::vector<uint32_t>& tls_callbacks() { return tls_callbacks_; }

  const std::vector<uint8_t>& xbe_data() { return xbe_data_; }
  const std::vector<uint8_t>& header_data() { return header_data_; }
  const std::vector<XBESection>& sections() { return sections_; }
  const std::map<uint32_t, uint32_t>& kernel_imports() { return kernel_imports_; }
  const uint8_t* codeview_data(int idx, size_t* size = nullptr) {
    if (codeview_data_.size() > idx)
    {
      if (size)
        *size = codeview_data_[idx].size();
      return codeview_data_[idx].data();
    }
    return nullptr;
  }
  const std::vector<xbe::XbeLibraryVersion>& libraries() { return libraries_; }

  uint32_t xbe_va_to_offset(uint32_t va);

  int load_error() { return load_error_; }

  // Sets our IO function pointers to use IDA's IO functions
  void use_ida_io();

  // Loads in the file - note that "file" should be a FILE object, not a pointer to raw data!
  bool load(void* file);

  const xbe::XbeHeader& header() { return xbe_header_; }
};

```

`formats/xbe_keys.hpp`:

```hpp
#include <cstdint>

// XBE thunk/EP keys are derived from the RSA public keys used to verify XBE signatures
// So far we have pubkeys for retail/debug/chihiro
// but currently missing XBL beta pubkey
// TODO: are there any dumps of XBL beta bios/kernel we can extract pubkey from?
// (will also be needed for verifying beta XBE signatures in future...)

// Keys using RSA_PUBLIC_KEY / NT BSAFE_PUB_KEY format

constexpr uint8_t kXePublicKeyData_Retail[284] = {
	0x52, 0x53, 0x41, 0x31, // magic
	0x08, 0x01, 0x00, 0x00, // keylen
	0x00, 0x08, 0x00, 0x00, // bitlen
	0xFF, 0x00, 0x00, 0x00, // datalen
	0x01, 0x00, 0x01, 0x00, // pubexp
	0xD3, 0xD7, 0x4E, 0xE5, 0x66, 0x3D, 0xD7, 0xE6, 0xC2, 0xD4, 0xA3, 0xA1, 0xF2, 0x17, 0x36, 0xD4,
	0x2E, 0x52, 0xF6, 0xD2, 0x02, 0x10, 0xF5, 0x64, 0x9C, 0x34, 0x7B, 0xFF, 0xEF, 0x7F, 0xC2, 0xEE,
	0xBD, 0x05, 0x8B, 0xDE, 0x79, 0xB4, 0x77, 0x8E, 0x5B, 0x8C, 0x14, 0x99, 0xE3, 0xAE, 0xC6, 0x73,
	0x72, 0x73, 0xB5, 0xFB, 0x01, 0x5B, 0x58, 0x46, 0x6D, 0xFC, 0x8A, 0xD6, 0x95, 0xDA, 0xED, 0x1B,
	0x2E, 0x2F, 0xA2, 0x29, 0xE1, 0x3F, 0xF1, 0xB9, 0x5B, 0x64, 0x51, 0x2E, 0xA2, 0xC0, 0xF7, 0xBA,
	0xB3, 0x3E, 0x8A, 0x75, 0xFF, 0x06, 0x92, 0x5C, 0x07, 0x26, 0x75, 0x79, 0x10, 0x5D, 0x47, 0xBE,
	0xD1, 0x6A, 0x52, 0x90, 0x0B, 0xAE, 0x6A, 0x0B, 0x33, 0x44, 0x93, 0x5E, 0xF9, 0x9D, 0xFB, 0x15,
	0xD9, 0xA4, 0x1C, 0xCF, 0x6F, 0xE4, 0x71, 0x94, 0xBE, 0x13, 0x00, 0xA8, 0x52, 0xCA, 0x07, 0xBD,
	0x27, 0x98, 0x01, 0xA1, 0x9E, 0x4F, 0xA3, 0xED, 0x9F, 0xA0, 0xAA, 0x73, 0xC4, 0x71, 0xF3, 0xE9,
	0x4E, 0x72, 0x42, 0x9C, 0xF0, 0x39, 0xCE, 0xBE, 0x03, 0x76, 0xFA, 0x2B, 0x89, 0x14, 0x9A, 0x81,
	0x16, 0xC1, 0x80, 0x8C, 0x3E, 0x6B, 0xAA, 0x05, 0xEC, 0x67, 0x5A, 0xCF, 0xA5, 0x70, 0xBD, 0x60,
	0x0C, 0xE8, 0x37, 0x9D, 0xEB, 0xF4, 0x52, 0xEA, 0x4E, 0x60, 0x9F, 0xE4, 0x69, 0xCF, 0x52, 0xDB,
	0x68, 0xF5, 0x11, 0xCB, 0x57, 0x8F, 0x9D, 0xA1, 0x38, 0x0A, 0x0C, 0x47, 0x1B, 0xB4, 0x6C, 0x5A,
	0x53, 0x6E, 0x26, 0x98, 0xF1, 0x88, 0xAE, 0x7C, 0x96, 0xBC, 0xF6, 0xBF, 0xB0, 0x47, 0x9A, 0x8D,
	0xE4, 0xB3, 0xE2, 0x98, 0x85, 0x61, 0xB1, 0xCA, 0x5F, 0xF7, 0x98, 0x51, 0x2D, 0x83, 0x81, 0x76,
	0x0C, 0x88, 0xBA, 0xD4, 0xC2, 0xD5, 0x3C, 0x14, 0xC7, 0x72, 0xDA, 0x7E, 0xBD, 0x1B, 0x4B, 0xA4,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
constexpr uint32_t kXePublicKeyData_Retail_0x80 = 0x15fb9df9;
constexpr uint32_t kXePublicKeyData_Retail_0x84 = 0xcf1ca4d9;
constexpr uint32_t kXePublicKeyData_Retail_0x88 = 0x9471e46f;
constexpr uint32_t kXePublicKeyData_Retail_0x90 = 0xbd07ca52;

// Debug Public Key
constexpr uint8_t kXePublicKeyData_Debug[284] = {
	0x52, 0x53, 0x41, 0x31, // magic
	0x08, 0x01, 0x00, 0x00, // keylen
	0x00, 0x08, 0x00, 0x00, // bitlen
	0xFF, 0x00, 0x00, 0x00, // datalen
	0x01, 0x00, 0x01, 0x00, // pubexp
	0x9B, 0x83, 0xD4, 0xD5, 0xDE, 0x16, 0x25, 0x8E, 0xE5, 0x15, 0xF2, 0x18, 0x9D, 0x19, 0x1C, 0xF8,
	0xFE, 0x91, 0xA5, 0x83, 0xAE, 0xA5, 0xA8, 0x95, 0x3F, 0x01, 0xB2, 0xC9, 0x34, 0xFB, 0xC7, 0x51,
	0x2D, 0xAC, 0xFF, 0x38, 0xE6, 0xB6, 0x7B, 0x08, 0x4A, 0xDF, 0x98, 0xA3, 0xFD, 0x31, 0x81, 0xBF,
	0xAA, 0xD1, 0x62, 0x58, 0xC0, 0x6C, 0x8F, 0x8E, 0xCD, 0x96, 0xCE, 0x6D, 0x03, 0x44, 0x59, 0x93,
	0xCE, 0xEA, 0x8D, 0xF4, 0xD4, 0x6F, 0x6F, 0x34, 0x5D, 0x50, 0xF1, 0xAE, 0x99, 0x7F, 0x1D, 0x92,
	0x15, 0xF3, 0x6B, 0xDB, 0xF9, 0x95, 0x8B, 0x3F, 0x54, 0xAD, 0x37, 0xB5, 0x4F, 0x0A, 0x58, 0x7B,
	0x48, 0xA2, 0x9F, 0x9E, 0xA3, 0x16, 0xC8, 0xBD, 0x37, 0xDA, 0x9A, 0x37, 0xE6, 0x3F, 0x10, 0x1B,
	0xA8, 0x4F, 0xA3, 0x14, 0xFA, 0xBE, 0x12, 0xFB, 0xD7, 0x19, 0x4C, 0xED, 0xAD, 0xA2, 0x95, 0x8F,
	0x39, 0x8C, 0xC4, 0x69, 0x0F, 0x7D, 0xB8, 0x84, 0x0A, 0x99, 0x5C, 0x53, 0x2F, 0xDE, 0xF2, 0x1B,
	0xC5, 0x1D, 0x4C, 0x43, 0x3C, 0x97, 0xA7, 0xBA, 0x8F, 0xC3, 0x22, 0x67, 0x39, 0xC2, 0x62, 0x74,
	0x3A, 0x0C, 0xB5, 0x57, 0x01, 0x3A, 0x67, 0xC6, 0xDE, 0x0C, 0x0B, 0xF6, 0x08, 0x01, 0x64, 0xDB,
	0xBD, 0x81, 0xE4, 0xDC, 0x09, 0x2E, 0xD0, 0xF1, 0xD0, 0xD6, 0x1E, 0xBA, 0x38, 0x36, 0xF4, 0x4A,
	0xDD, 0xCA, 0x39, 0xEB, 0x76, 0xCF, 0x95, 0xDC, 0x48, 0x4C, 0xF2, 0x43, 0x8C, 0xD9, 0x44, 0x26,
	0x7A, 0x9E, 0xEB, 0x99, 0xA3, 0xD8, 0xFB, 0x30, 0xA8, 0x14, 0x42, 0x82, 0x8D, 0xB4, 0x31, 0xB3,
	0x1A, 0xD5, 0x2B, 0xF6, 0x32, 0xBC, 0x62, 0xC0, 0xFE, 0x81, 0x20, 0x49, 0xE7, 0xF7, 0x58, 0x2F,
	0x2D, 0xA6, 0x1B, 0x41, 0x62, 0xC7, 0xE0, 0x32, 0x02, 0x5D, 0x82, 0xEC, 0xA3, 0xE4, 0x6C, 0x9B,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
constexpr uint32_t kXePublicKeyData_Debug_0x80 = 0x1b103fe6;
constexpr uint32_t kXePublicKeyData_Debug_0x84 = 0x14a34fa8;
constexpr uint32_t kXePublicKeyData_Debug_0x88 = 0xfb12befa;
constexpr uint32_t kXePublicKeyData_Debug_0x90 = 0x8f95a2ad;

// Chihiro public key (Segaboot)
constexpr uint8_t kXePublicKeyData_Chihiro[284] = {
	0x52, 0x53, 0x41, 0x31, // magic
	0x08, 0x01, 0x00, 0x00, // keylen
	0x00, 0x08, 0x00, 0x00, // bitlen
	0xFF, 0x00, 0x00, 0x00, // datalen
	0x01, 0x00, 0x01, 0x00, // pubexp
	0x6B, 0x7B, 0x38, 0x78, 0xE3, 0x16, 0x04, 0x88, 0x1D, 0xAF, 0x63, 0x4E, 0x23, 0xDB, 0x10, 0x14,
	0xB4, 0x52, 0x87, 0xEB, 0xE3, 0x37, 0xC2, 0x35, 0x6E, 0x38, 0x08, 0xDC, 0x07, 0xC5, 0x92, 0x17,
	0xC0, 0xBF, 0xDB, 0xF5, 0x9E, 0x72, 0xDB, 0x2F, 0x98, 0x93, 0x6E, 0x98, 0x5E, 0xD9, 0x69, 0x80,
	0x17, 0xFC, 0x0C, 0x72, 0x2E, 0xE6, 0x75, 0x85, 0x48, 0xEA, 0xBD, 0xDA, 0x6E, 0x82, 0xD9, 0xFB,
	0x10, 0xAA, 0x11, 0xEE, 0xB5, 0xC1, 0xF2, 0x53, 0xD6, 0xF0, 0xD3, 0x4B, 0xC2, 0x11, 0x4F, 0x8A,
	0x18, 0xFB, 0xB7, 0x36, 0xFC, 0xDD, 0xD0, 0xBF, 0x5C, 0x32, 0x44, 0x40, 0xEB, 0x92, 0x70, 0xA4,
	0xEF, 0x3A, 0xAB, 0x78, 0x66, 0x1A, 0x03, 0x0A, 0x9E, 0xC5, 0x3A, 0xB7, 0x8F, 0xE5, 0xB1, 0x5E,
	0x44, 0x15, 0xBA, 0x42, 0xD9, 0x10, 0x2A, 0x60, 0x93, 0x47, 0x4C, 0x5B, 0xE1, 0x24, 0x04, 0x1E,
	0x5C, 0x95, 0xB2, 0x17, 0x34, 0xD2, 0x37, 0x5F, 0x85, 0x83, 0x62, 0x8D, 0x6E, 0x90, 0x69, 0x06,
	0xB9, 0xFB, 0x7A, 0x24, 0x8A, 0xE6, 0xCC, 0x77, 0x1E, 0x0A, 0x8C, 0x2B, 0x3B, 0xA2, 0x33, 0x79,
	0x24, 0x8C, 0xD3, 0x88, 0x01, 0x3A, 0x38, 0x7F, 0xF0, 0xAB, 0x9E, 0x2F, 0x74, 0xCE, 0x50, 0xD1,
	0xC2, 0x00, 0x57, 0xD3, 0xA7, 0x09, 0x45, 0x36, 0xFA, 0xC1, 0xC7, 0x1B, 0x65, 0xAD, 0x98, 0x9C,
	0x63, 0xED, 0xBA, 0x99, 0x9B, 0x07, 0x3E, 0x57, 0xBD, 0xB5, 0x52, 0x44, 0x72, 0x09, 0x43, 0xE0,
	0x5C, 0x35, 0xCC, 0xE4, 0xE0, 0x85, 0x6A, 0x61, 0xAA, 0xF5, 0x0D, 0x1E, 0xE7, 0x8F, 0xB0, 0xB9,
	0xE3, 0xC3, 0x83, 0x10, 0x6C, 0x2F, 0x5D, 0xD4, 0xAB, 0x2D, 0xAB, 0x4D, 0xCE, 0xC9, 0x7F, 0x52,
	0x39, 0x13, 0xED, 0x44, 0x06, 0x23, 0x2F, 0x62, 0xFF, 0xA1, 0x2B, 0xEE, 0x07, 0x98, 0x7D, 0xBC,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
constexpr uint32_t kXePublicKeyData_Chihiro_0x80 = 0x5eb1e58f;
constexpr uint32_t kXePublicKeyData_Chihiro_0x84 = 0x42ba1544;
constexpr uint32_t kXePublicKeyData_Chihiro_0x88 = 0x602a10d9;
constexpr uint32_t kXePublicKeyData_Chihiro_0x90 = 0x1e0424e1;

// Keys are derived via: 
//   uint32_t* key_base = (uint32_t*)&XePublicKeyData[0x80]
//   KernelThunkKey = key_base[1] ^ key_base[2];
//   EntryPointKey = key_base[0] ^ key_base[4];
// Where XePublicKeyData is export 355 from kernel, beginning with RSA1 header

constexpr uint32_t kXbeXorKernel_Retail = kXePublicKeyData_Retail_0x84 ^ kXePublicKeyData_Retail_0x88;
constexpr uint32_t kXbeXorEntry_Retail = kXePublicKeyData_Retail_0x80 ^ kXePublicKeyData_Retail_0x90;
static_assert(kXbeXorKernel_Retail == 0x5B6D40B6);
static_assert(kXbeXorEntry_Retail == 0xA8FC57AB);

constexpr uint32_t kXbeXorKernel_Debug = kXePublicKeyData_Debug_0x84 ^ kXePublicKeyData_Debug_0x88;
constexpr uint32_t kXbeXorEntry_Debug = kXePublicKeyData_Debug_0x80 ^ kXePublicKeyData_Debug_0x90;
static_assert(kXbeXorKernel_Debug == 0xEFB1F152);
static_assert(kXbeXorEntry_Debug == 0x94859D4B);

constexpr uint32_t kXbeXorKernel_Chihiro = kXePublicKeyData_Chihiro_0x84 ^ kXePublicKeyData_Chihiro_0x88;
constexpr uint32_t kXbeXorEntry_Chihiro = kXePublicKeyData_Chihiro_0x80 ^ kXePublicKeyData_Chihiro_0x90;
static_assert(kXbeXorKernel_Chihiro == 0x2290059D);
static_assert(kXbeXorEntry_Chihiro == 0x40B5C16E);

// TODO: are there any dumps of XBL beta bios/kernel we can extract pubkey from?
constexpr uint32_t kXbeXorKernel_XBLBeta = 0x46437DCD;
constexpr uint32_t kXbeXorEntry_XBLBeta = 0xE682F45B;
static_assert(kXbeXorKernel_XBLBeta == 0x46437DCD);
static_assert(kXbeXorEntry_XBLBeta == 0xE682F45B);

```

`formats/xbe_structs.hpp`:

```hpp
#pragma once
#include <cstdint>
#include <cassert>

#define IMAGE_ORDINAL_FLAG32 0x80000000
#define IMAGE_ORDINAL32(Ordinal) (Ordinal & 0xffff)

namespace xbe
{
  struct XbeInitFlags {
    /* 0x01 */ uint32_t MountUtilityDrive : 1;
    /* 0x02 */ uint32_t FormatUtilityDrive : 1;
    /* 0x04 */ uint32_t LimitDevkitMemory : 1;
    /* 0x08 */ uint32_t NoSetupHardDisk : 1;
    /* 0x10 */ uint32_t DontModifyHardDisk : 1;
    // Cluster size follows from 0x40000000 - 0xC0000000
  };
  static_assert(sizeof(XbeInitFlags) == 4, "xbe::XbeInitFlags");

  struct XbeHeader {
    uint32_t Signature;
    uint8_t EncryptedDigest[256];
    uint32_t BaseAddress;
    uint32_t SizeOfHeaders;
    uint32_t SizeOfImage;
    uint32_t SizeOfImageHeader;
    uint32_t TimeDateStamp;
    uint32_t CertificateOffset;
    uint32_t NumberOfSections;
    uint32_t SectionHeadersOffset;
    XbeInitFlags InitFlags;
    uint32_t AddressOfEntryPoint;
    uint32_t TlsDirectoryOffset;
    uint32_t SizeOfStackCommit;
    uint32_t SizeOfHeapReserve;
    uint32_t SizeOfHeapCommit;
    uint32_t NtBaseOfDll;
    uint32_t NtSizeOfImage;
    uint32_t NtCheckSum;
    uint32_t NtTimeDateStamp;
    uint32_t DebugPathNameOffset;
    uint32_t DebugFileNameOffset;
    uint32_t DebugUnicodeFileNameOffset;
    uint32_t XboxKernelThunkDataOffset;
    uint32_t ImportDirectoryOffset;
    uint32_t NumberOfLibraryVersions;
    uint32_t LibraryVersionsOffset; // PXBEIMAGE_LIBRARY_VERSION
    uint32_t XboxKernelLibraryVersionOffset; // PXBEIMAGE_LIBRARY_VERSION
    uint32_t XapiLibraryVersionOffset; // PXBEIMAGE_LIBRARY_VERSION
    uint32_t MicrosoftLogoOffset;
    uint32_t SizeOfMicrosoftLogo;

    uint32_t LibraryFeaturesOffset; // PXBEIMAGE_LIBRARY_VERSION "only exists on XBEs built with an XDK version >= 5028."
    uint32_t NumberOfLibraryFeatures; // "only exists on XBEs built with an XDK version >= 5028."
    uint32_t CodeViewDebugInfoOffset; // "only exists on XBEs built with an XDK version >= 5455."
    
    inline bool has_library_features() { return SizeOfImageHeader >= 0x180; }
    inline bool has_codeview_offset() { return SizeOfImageHeader >= 0x184; }
  };
  static_assert(sizeof(XbeHeader) == 0x184, "xbe::XbeHeader");

  struct XbeSectionFlags
  {
    uint32_t Writable : 1;
    uint32_t Preload : 1;
    uint32_t Executable : 1;
    uint32_t InsertedFile : 1;
    uint32_t HeadPageReadOnly : 1;
    uint32_t TailPageReadOnly : 1;
  };
  static_assert(sizeof(XbeSectionFlags) == 4, "xbe::XbeSectionFlags");

  struct XbeSection {
    XbeSectionFlags SectionFlags;
    uint32_t VirtualAddress;
    uint32_t VirtualSize;
    uint32_t PointerToRawData;
    uint32_t SizeOfRawData;
    uint32_t SectionNameOffset;
    uint32_t SectionReferenceCount;
    uint32_t HeadSharedPageReferenceCountOffset;
    uint32_t TailSharedPageReferenceCountOffset;
    uint8_t SectionDigest[20];
  };
  static_assert(sizeof(XbeSection) == 0x38, "xbe::XbeSection");

  struct XbeLibraryVersion {
    char LibraryName[8];
    uint16_t MajorVersion;
    uint16_t MinorVersion;
    uint16_t BuildVersion;
    uint16_t QFEVersion : 8;
    uint16_t Unused : 3;
    uint16_t LibFeature : 1;
    uint16_t XBEVersion : 1;
    uint16_t ApprovedLibrary : 2;
    uint16_t DebugBuild : 1;
  };
  static_assert(sizeof(XbeLibraryVersion) == 0x10, "xbe::XbeLibraryVersion");

  struct ImageThunkData
  {
    union {
      uint32_t ForwarderString;      // PBYTE 
      uint32_t Function;             // PDWORD
      uint32_t Ordinal;
      uint32_t AddressOfData;        // PIMAGE_IMPORT_BY_NAME
    } u1;
  };
  static_assert(sizeof(ImageThunkData) == 4, "xbe::ImageThunkData");
};

namespace xe // Xbox alpha, based on 3521 structs
{
  struct XeOptionalHeader {
    uint16_t MajorImageVersion;
    uint16_t MinorImageVersion;
    uint16_t KernelVersion[4];
    uint16_t XAPIVersion[4];
    uint32_t InitFlags;
    uint32_t SizeOfStackCommit;
    uint32_t SizeOfHeapReserve;
    uint32_t SizeOfHeapCommit;
    uint32_t TlsDirectory;
    uint16_t NumberOfModules;
    uint16_t NumberOfSections;
    uint16_t NumberOfDigests;
    uint16_t NumberOfImports;
    uint16_t SizeOfMiscData;
    uint16_t SizeOfCertInfo;
    uint16_t SizeOfEncHeaderDigest;
    uint16_t Reserved;
  };
  static_assert(sizeof(XeOptionalHeader) == 0x38, "xe::XeOptionalHeader");

  struct XeHeader {
    uint32_t Signature;
    uint32_t HeadersBase;
    uint32_t SectionsBase;
    uint32_t PagesInHeaders;
    uint32_t PagesInSections;
    uint32_t SizeOfImage;
    uint32_t SectionAlignment;
    uint32_t TimeDateStamp;
    uint32_t Checksum;
    uint32_t SizeOfOptionalHeader;
    XeOptionalHeader OptionalHeader;
  };
  static_assert(sizeof(XeHeader) == 0x60, "xe::XeHeader");

  struct XeModuleHeader {
    uint32_t ImageBase;
    uint32_t AddressOfEntryPoint;
    uint32_t ModuleFlags;
    uint32_t OrgSizeOfImage;
    uint32_t OrgCheckSum;
    uint32_t OrgTimestamp;
    uint16_t NameOfs;
    uint16_t DependStrOfs;
  };
  static_assert(sizeof(XeModuleHeader) == 0x1C, "xe::XeModuleHeader");

  struct XeImportHeader {
    uint16_t ExportModuleIndex;
    uint16_t ImportModuleIndex;
    uint32_t IATRVA;
    uint32_t Ordinal;
    uint32_t NameOfs;
  };
  static_assert(sizeof(XeImportHeader) == 0x10, "xe::XeImportHeader");

  struct XeSectionHeader {
    char Name[8];
    uint32_t VirtualAddress;
    uint32_t VirtualSize;
    uint16_t ModuleIndex;
    uint16_t SectionFlags;
    uint32_t HeadPage;
    uint32_t BodyPage;
    uint32_t TailPage;
  };
  static_assert(sizeof(XeSectionHeader) == 0x20, "xe::XeSectionHeader");

  struct XeXboxCert {
    uint16_t CertSig;
    uint16_t Reserved1;
    uint32_t TitleID;
    uint32_t SignatureTimeDate;
    uint32_t AllowedMedia;
    uint32_t ContentType;
    uint16_t ParentalControl;
    uint8_t GameRegion;
    uint8_t Reserved2;
    uint32_t AltTitleIds[16];
    uint16_t TitleName[40];
    uint16_t PublisherName[32];
  };
  static_assert(sizeof(XeXboxCert) == 0xE8, "xe::XeXboxCert");
};

```

`formats/xdbf.cpp`:

```cpp
/**
 ******************************************************************************
 * Xenia : Xbox 360 Emulator Research Project                                 *
 ******************************************************************************
 * Copyright 2016 Ben Vanik. All rights reserved.                             *
 * Released under the BSD license - see LICENSE in the root for more details. *
 ******************************************************************************
 */

#include <cstring>
#include "xex.hpp"
#include "xdbf.hpp"
#include "xdbf_structs.hpp"

namespace xe {
namespace kernel {
namespace xam {
namespace xdbf {

bool XdbfFile::Read(const uint8_t* data, size_t data_size) {
  if (!data || data_size <= sizeof(X_XDBF_HEADER)) {
    return false;
  }

  auto* ptr = data;
  memcpy(&header_, ptr, sizeof(X_XDBF_HEADER));
  if (header_.magic != kXdbfMagicXdbf) {
    return false;
  }

  ptr += sizeof(X_XDBF_HEADER);

  auto* free_ptr = (const X_XDBF_FILELOC*)(ptr + (sizeof(X_XDBF_ENTRY) *
                                                  header_.entry_count));
  auto* data_ptr =
      (uint8_t*)free_ptr + (sizeof(X_XDBF_FILELOC) * header_.free_count);

  for (uint32_t i = 0; i < header_.entry_used; i++) {
    Entry entry;
    memcpy(&entry.info, ptr, sizeof(X_XDBF_ENTRY));
    entry.data.resize(entry.info.size);
    memcpy(entry.data.data(), data_ptr + entry.info.offset, entry.info.size);
    entries_.push_back(entry);

    ptr += sizeof(X_XDBF_ENTRY);
  }

  for (uint32_t i = 0; i < header_.free_used; i++) {
    free_entries_.push_back(*free_ptr);
    free_ptr++;
  }

  return true;
}

bool XdbfFile::Write(uint8_t* data, size_t* data_size) {
  *data_size = 0;

  *data_size += sizeof(X_XDBF_HEADER);
  *data_size += entries_.size() * sizeof(X_XDBF_ENTRY);
  *data_size += 1 * sizeof(X_XDBF_FILELOC);

  size_t entries_size = 0;
  for (auto ent : entries_) {
    entries_size += ent.data.size();
  }

  *data_size += entries_size;

  if (!data) {
    return true;
  }

  header_.entry_count = header_.entry_used = (uint32_t)entries_.size();
  header_.free_count = header_.free_used = 1;

  auto* ptr = data;
  memcpy(ptr, &header_, sizeof(X_XDBF_HEADER));
  ptr += sizeof(X_XDBF_HEADER);

  auto* free_ptr =
      (X_XDBF_FILELOC*)(ptr + (sizeof(X_XDBF_ENTRY) * header_.entry_count));
  auto* data_start =
      (uint8_t*)free_ptr + (sizeof(X_XDBF_FILELOC) * header_.free_count);

  auto* data_ptr = data_start;
  for (auto ent : entries_) {
    ent.info.offset = (uint32_t)(data_ptr - data_start);
    ent.info.size = (uint32_t)ent.data.size();
    memcpy(ptr, &ent.info, sizeof(X_XDBF_ENTRY));

    memcpy(data_ptr, ent.data.data(), ent.data.size());
    data_ptr += ent.data.size();
    ptr += sizeof(X_XDBF_ENTRY);
  }

  free_entries_.clear();
  X_XDBF_FILELOC free_ent;
  free_ent.offset = (uint32_t)*data_size - sizeof(X_XDBF_HEADER) -
                    (sizeof(X_XDBF_ENTRY) * header_.entry_count) -
                    (sizeof(X_XDBF_FILELOC) * header_.free_count);

  free_ent.size = 0 - free_ent.offset;
  free_entries_.push_back(free_ent);

  for (auto ent : free_entries_) {
    memcpy(free_ptr, &ent, sizeof(X_XDBF_FILELOC));
    free_ptr++;
  }

  return true;
}

Entry* XdbfFile::GetEntry(uint16_t section, uint64_t id) const {
  for (size_t i = 0; i < entries_.size(); i++) {
    auto* entry = (Entry*)&entries_[i];
    if (entry->info.section != section || entry->info.id != id) {
      continue;
    }

    return entry;
  }

  return nullptr;
}

bool XdbfFile::UpdateEntry(const Entry& entry) {
  for (size_t i = 0; i < entries_.size(); i++) {
    auto* ent = (Entry*)&entries_[i];
    if (ent->info.section != entry.info.section ||
        ent->info.id != entry.info.id) {
      continue;
    }

    ent->data = entry.data;
    ent->info.size = (uint32_t)entry.data.size();
    return true;
  }

  Entry new_entry;
  new_entry.info.section = entry.info.section;
  new_entry.info.id = entry.info.id;
  new_entry.info.size = (uint32_t)entry.data.size();
  new_entry.data = entry.data;

  entries_.push_back(new_entry);
  return true;
}

std::string GetStringTableEntry_(const uint8_t* table_start, uint16_t string_id,
                                 uint16_t count) {
  auto* ptr = table_start;
  for (uint16_t i = 0; i < count; ++i) {
    auto entry = reinterpret_cast<const XdbfStringTableEntry*>(ptr);
    ptr += sizeof(XdbfStringTableEntry);
    if (entry->id == string_id) {
      return std::string(reinterpret_cast<const char*>(ptr),
                         entry->string_length);
    }
    ptr += entry->string_length;
  }
  return "";
}

std::string SpaFile::GetStringTableEntry(XLanguage language,
                                         uint16_t string_id) const {
  auto xstr_table = GetEntry(static_cast<uint16_t>(SpaSection::kStringTable),
                             static_cast<uint64_t>(language));
  if (!xstr_table) {
    return "";
  }

  auto xstr_head =
      reinterpret_cast<const X_XDBF_TABLE_HEADER*>(xstr_table->data.data());
  //assert_truexstr_head->header.magic == static_cast<uint32_t>(SpaID::Xstr));
  //assert_truexstr_head->header.version == 1);

  const uint8_t* ptr = xstr_table->data.data() + sizeof(X_XDBF_TABLE_HEADER);

  return GetStringTableEntry_(ptr, string_id, xstr_head->count);
}

uint32_t SpaFile::GetAchievements(
    XLanguage lang, std::vector<Achievement>* achievements) const {
  auto xach_table = GetEntry(static_cast<uint16_t>(SpaSection::kMetadata),
                             static_cast<uint64_t>(SpaID::Xach));
  if (!xach_table) {
    return 0;
  }

  auto xach_head =
      reinterpret_cast<const X_XDBF_TABLE_HEADER*>(xach_table->data.data());
  //assert_truexach_head->header.magic == static_cast<uint32_t>(SpaID::Xach));
  //assert_truexach_head->header.version == 1);

  auto xstr_table = GetEntry(static_cast<uint16_t>(SpaSection::kStringTable),
                             static_cast<uint64_t>(lang));
  if (!xstr_table) {
    return 0;
  }

  auto xstr_head =
      reinterpret_cast<const X_XDBF_TABLE_HEADER*>(xstr_table->data.data());
  //assert_truexstr_head->header.magic == static_cast<uint32_t>(SpaID::Xstr));
  //assert_truexstr_head->header.version == 1);

  const uint8_t* xstr_ptr =
      xstr_table->data.data() + sizeof(X_XDBF_TABLE_HEADER);

  if (achievements) {
    auto* ach_data =
        reinterpret_cast<const X_XDBF_SPA_ACHIEVEMENT*>(xach_head + 1);
    for (uint32_t i = 0; i < xach_head->count; i++) {
      Achievement ach;
      ach.id = ach_data->id;
      ach.image_id = ach_data->image_id;
      ach.gamerscore = ach_data->gamerscore;
      ach.flags = ach_data->flags;
      ach.flags |= static_cast<uint32_t>(AchievementPlatform::kX360);

      ach.label = GetStringTableEntry_(xstr_ptr, ach_data->label_id, xstr_head->count);

      ach.description = GetStringTableEntry_(
          xstr_ptr, ach_data->description_id, xstr_head->count);

      ach.unachieved_desc = GetStringTableEntry_(
          xstr_ptr, ach_data->unachieved_id, xstr_head->count);

      achievements->push_back(ach);
      ach_data++;
    }
  }

  return xach_head->count;
}

Entry* SpaFile::GetIcon() const {
  return GetEntry(static_cast<uint16_t>(SpaSection::kImage),
                  static_cast<uint64_t>(SpaID::Title));
}

XLanguage SpaFile::GetDefaultLanguage() const {
  auto block = GetEntry(static_cast<uint16_t>(SpaSection::kMetadata),
                        static_cast<uint64_t>(SpaID::Xstc));
  if (!block) {
    return XLanguage::kEnglish;
  }

  auto xstc = reinterpret_cast<const X_XDBF_XSTC_DATA*>(block->data.data());
  //assert_truexstc->header.magic == static_cast<uint32_t>(SpaID::Xstc));

  return static_cast<XLanguage>(static_cast<uint32_t>(xstc->default_language));
}

std::string SpaFile::GetTitleName() const {
  return GetStringTableEntry(GetDefaultLanguage(),
                             static_cast<uint16_t>(SpaID::Title));
}

bool SpaFile::GetTitleData(X_XDBF_XTHD_DATA* title_data) const {
  auto block = GetEntry(static_cast<uint16_t>(SpaSection::kMetadata),
                        static_cast<uint64_t>(SpaID::Xthd));
  if (!block) {
    return false;
  }

  auto xthd = reinterpret_cast<const X_XDBF_XTHD_DATA*>(block->data.data());
  //assert_truexthd->header.magic == static_cast<uint32_t>(SpaID::Xthd));

  if (title_data) {
    *title_data = *xthd;
  }
  return true;
}

}  // namespace xdbf
}  // namespace xam
}  // namespace kernel
}  // namespace xe

```

`formats/xdbf.hpp`:

```hpp
/**
 ******************************************************************************
 * Xenia : Xbox 360 Emulator Research Project                                 *
 ******************************************************************************
 * Copyright 2016 Ben Vanik. All rights reserved.                             *
 * Released under the BSD license - see LICENSE in the root for more details. *
 ******************************************************************************
 */

#ifndef XENIA_KERNEL_XAM_XDBF_XDBF_H_
#define XENIA_KERNEL_XAM_XDBF_XDBF_H_

#include <string>
#include <vector>

#include "xdbf_structs.hpp"

namespace xe {
namespace kernel {
namespace xam {
namespace xdbf {

// https://github.com/oukiar/freestyledash/blob/master/Freestyle/Tools/XEX/SPA.h
// https://github.com/oukiar/freestyledash/blob/master/Freestyle/Tools/XEX/SPA.cpp

constexpr uint32_t kXdbfMagicXdbf = 0x46424458; // XDBF

enum class SpaID : uint64_t {
  Xach = 0x48434158, // XACH
  Xstr = 0x52545358, // XSTR
  Xstc = 0x43545358, // XSTC
  Xthd = 0x44485458, // XTHD
  Title = 0x8000,
};

enum class SpaSection : uint16_t {
  kMetadata = 0x1,
  kImage = 0x2,
  kStringTable = 0x3,
};

enum class GpdSection : uint16_t {
  kAchievement = 0x1,
  kImage = 0x2,
  kSetting = 0x3,
  kTitle = 0x4,
  kString = 0x5,
  kProtectedAchievement = 0x6,  // GFWL only
};

inline std::wstring ReadNullTermString(const wchar_t* ptr) {
  std::wstring retval;
  wchar_t data = xe::byte_swap(*ptr);
  while (data != 0) {
    retval += data;
    ptr++;
    data = xe::byte_swap(*ptr);
  }
  return retval;
}

struct TitlePlayed {
  uint32_t title_id = 0;
  std::wstring title_name;
  uint32_t achievements_possible = 0;
  uint32_t achievements_earned = 0;
  uint32_t gamerscore_total = 0;
  uint32_t gamerscore_earned = 0;
  uint16_t reserved_achievement_count = 0;
  X_XDBF_AVATARAWARDS_COUNTER all_avatar_awards = {};
  X_XDBF_AVATARAWARDS_COUNTER male_avatar_awards = {};
  X_XDBF_AVATARAWARDS_COUNTER female_avatar_awards = {};
  uint32_t reserved_flags = 0;
  uint64_t last_played = 0;
};

enum class AchievementType : uint32_t {
  kCompletion = 1,
  kLeveling = 2,
  kUnlock = 3,
  kEvent = 4,
  kTournament = 5,
  kCheckpoint = 6,
  kOther = 7,
};

enum class AchievementPlatform : uint32_t {
  kX360 = 0x100000,
  kPC = 0x200000,
  kMobile = 0x300000,
  kWebGames = 0x400000,
};

enum class AchievementFlags : uint32_t {
  kTypeMask = 0x7,
  kShowUnachieved = 0x8,
  kAchievedOnline = 0x10000,
  kAchieved = 0x20000,
  kNotAchievable = 0x40000,
  kWasNotAchievable = 0x80000,
  kPlatformMask = 0x700000,
  kColorizable = 0x1000000,  // avatar awards only?
};

struct Achievement {
  uint16_t id = 0;
  std::string label;
  std::string description;
  std::string unachieved_desc;
  uint32_t image_id = 0;
  uint32_t gamerscore = 0;
  uint32_t flags = 0;
  uint64_t unlock_time = 0;

  AchievementType GetType() {
    return static_cast<AchievementType>(
        flags & static_cast<uint32_t>(AchievementFlags::kTypeMask));
  }

  AchievementPlatform GetPlatform() {
    return static_cast<AchievementPlatform>(
        flags & static_cast<uint32_t>(AchievementFlags::kPlatformMask));
  }

  bool IsUnlockable() {
    return !(flags & static_cast<uint32_t>(AchievementFlags::kNotAchievable)) ||
           (flags & static_cast<uint32_t>(AchievementFlags::kWasNotAchievable));
  }

  bool IsUnlocked() {
    return flags & static_cast<uint32_t>(AchievementFlags::kAchieved);
  }

  bool IsUnlockedOnline() {
    return flags & static_cast<uint32_t>(AchievementFlags::kAchievedOnline);
  }

  void Unlock(bool online = false) {
    if (!IsUnlockable()) {
      return;
    }

    flags |= static_cast<uint32_t>(AchievementFlags::kAchieved);
    if (online) {
      flags |= static_cast<uint32_t>(AchievementFlags::kAchievedOnline);
    }
  }

  void Lock() {
    flags = flags & ~(static_cast<uint32_t>(AchievementFlags::kAchieved));
    flags = flags & ~(static_cast<uint32_t>(AchievementFlags::kAchievedOnline));
    unlock_time = 0;
  }
};

struct Entry {
  X_XDBF_ENTRY info;
  std::vector<uint8_t> data;
};

// Parses/creates an XDBF (XboxDataBaseFormat) file
// http://www.free60.org/wiki/XDBF
class XdbfFile {
 public:
  XdbfFile() {
    header_.magic = kXdbfMagicXdbf;
    header_.version = 1;
  }

  bool Read(const uint8_t* data, size_t data_size);
  bool Write(uint8_t* data, size_t* data_size);

  Entry* GetEntry(uint16_t section, uint64_t id) const;

  // Updates (or adds) an entry
  bool UpdateEntry(const Entry& entry);

 protected:
  X_XDBF_HEADER header_;
  std::vector<Entry> entries_;
  std::vector<X_XDBF_FILELOC> free_entries_;
};

class SpaFile : public XdbfFile {
 public:
  std::string GetStringTableEntry(XLanguage lang, uint16_t string_id) const;

  uint32_t GetAchievements(XLanguage lang,
                           std::vector<Achievement>* achievements) const;

  Entry* GetIcon() const;
  XLanguage GetDefaultLanguage() const;
  std::string GetTitleName() const;
  bool GetTitleData(X_XDBF_XTHD_DATA* title_data) const;
};

}  // namespace xdbf
}  // namespace xam
}  // namespace kernel
}  // namespace xe

#endif  // XENIA_KERNEL_XAM_XDBF_XDBF_H_

```

`formats/xdbf_structs.hpp`:

```hpp
/**
 ******************************************************************************
 * Xenia : Xbox 360 Emulator Research Project                                 *
 ******************************************************************************
 * Copyright 2016 Ben Vanik. All rights reserved.                             *
 * Released under the BSD license - see LICENSE in the root for more details. *
 ******************************************************************************
 */

#ifndef XENIA_KERNEL_XAM_XDBF_XDBF_XBOX_H_
#define XENIA_KERNEL_XAM_XDBF_XDBF_XBOX_H_

namespace xe {
namespace kernel {
namespace xam {
namespace xdbf {

/* Native XDBF structs used by 360 are in this file */

struct XdbfStringTableEntry {
  xe::be<uint16_t> id;
  xe::be<uint16_t> string_length;
};
//static_assert_size(XdbfStringTableEntry, 4);

#pragma pack(push, 1)
struct X_XDBF_HEADER {
  xe::be<uint32_t> magic;
  xe::be<uint32_t> version;
  xe::be<uint32_t> entry_count;
  xe::be<uint32_t> entry_used;
  xe::be<uint32_t> free_count;
  xe::be<uint32_t> free_used;
};
//static_assert_size(X_XDBF_HEADER, 24);

struct X_XDBF_ENTRY {
  xe::be<uint16_t> section;
  xe::be<uint64_t> id;
  xe::be<uint32_t> offset;
  xe::be<uint32_t> size;
};
//static_assert_size(X_XDBF_ENTRY, 18);

struct X_XDBF_FILELOC {
  xe::be<uint32_t> offset;
  xe::be<uint32_t> size;
};
//static_assert_size(X_XDBF_FILELOC, 8);

struct X_XDBF_SECTION_HEADER {
  xe::be<uint32_t> magic;
  xe::be<uint32_t> version;
  xe::be<uint32_t> size;
};
//static_assert_size(X_XDBF_SECTION_HEADER, 12);

struct X_XDBF_XSTC_DATA {
  X_XDBF_SECTION_HEADER header;
  xe::be<uint32_t> default_language;
};
//static_assert_size(X_XDBF_XSTC_DATA, 16);

struct X_XDBF_XTHD_DATA {
  enum TitleType : uint32_t {
    kSystem = 0,
    kFull = 1,
    kDemo = 2,
    kDownload = 3,
  };
  enum class Flags {
    kAlwaysIncludeInProfile = 1,
    kNeverIncludeInProfile = 2,
  };
  X_XDBF_SECTION_HEADER header;
  xe::be<uint32_t> title_id;
  xe::be<TitleType> title_type;
  xe::be<uint16_t> title_version_major;
  xe::be<uint16_t> title_version_minor;
  xe::be<uint16_t> title_version_build;
  xe::be<uint16_t> title_version_revision;
  xe::be<uint32_t> flags;
  xe::be<uint32_t> unk20;
  xe::be<uint32_t> unk24;
  xe::be<uint32_t> unk28;
};
//static_assert_size(X_XDBF_XTHD_DATA, 0x2C);

struct X_XDBF_TABLE_HEADER {
  X_XDBF_SECTION_HEADER header;
  xe::be<uint16_t> count;
};
//static_assert_size(X_XDBF_TABLE_HEADER, 14);

struct X_XDBF_SPA_ACHIEVEMENT {
  xe::be<uint16_t> id;
  xe::be<uint16_t> label_id;
  xe::be<uint16_t> description_id;
  xe::be<uint16_t> unachieved_id;
  xe::be<uint32_t> image_id;
  xe::be<uint16_t> gamerscore;
  xe::be<uint16_t> unkE;
  xe::be<uint32_t> flags;
  xe::be<uint32_t> unk14;
  xe::be<uint32_t> unk18;
  xe::be<uint32_t> unk1C;
  xe::be<uint32_t> unk20;
};
//static_assert_size(X_XDBF_SPA_ACHIEVEMENT, 0x24);

struct X_XDBF_GPD_ACHIEVEMENT {
  xe::be<uint32_t> magic;
  xe::be<uint32_t> id;
  xe::be<uint32_t> image_id;
  xe::be<uint32_t> gamerscore;
  xe::be<uint32_t> flags;
  xe::be<uint64_t> unlock_time;
  // wchar_t* title;
  // wchar_t* description;
  // wchar_t* unlocked_description;
};
//static_assert_size(X_XDBF_GPD_ACHIEVEMENT, 0x1C);

struct X_XDBF_AVATARAWARDS_COUNTER {
  uint8_t earned;
  uint8_t possible;
};
//static_assert_size(X_XDBF_AVATARAWARDS_COUNTER, 2);

// from https://github.com/xemio/testdev/blob/master/xkelib/xam/_xamext.h
struct X_XDBF_GPD_TITLEPLAYED {
  xe::be<uint32_t> title_id;
  xe::be<uint32_t> achievements_possible;
  xe::be<uint32_t> achievements_earned;
  xe::be<uint32_t> gamerscore_total;
  xe::be<uint32_t> gamerscore_earned;
  xe::be<uint16_t> reserved_achievement_count;

  X_XDBF_AVATARAWARDS_COUNTER all_avatar_awards;
  X_XDBF_AVATARAWARDS_COUNTER male_avatar_awards;
  X_XDBF_AVATARAWARDS_COUNTER female_avatar_awards;
  xe::be<uint32_t> reserved_flags;
  xe::be<uint64_t> last_played;

  // xe::be<wchar_t> title_name[64]; // size seems to be variable inside GPDs,
  // r/w this seperately
};
//static_assert_size(X_XDBF_GPD_TITLEPLAYED, 0x28);
#pragma pack(pop)

enum class X_XUSER_DATA_TYPE : uint8_t {
  kContext,
  kInt32,
  kInt64,
  kDouble,
  kUnicode,
  kFloat,
  kBinary,
  kDateTime,
  kNull = 0xFF
};

struct X_XUSER_DATA {
  X_XUSER_DATA() {}
  X_XUSER_DATA(const X_XUSER_DATA& data) {
    type = data.type;
    i64Data = data.i64Data;
  }

  X_XUSER_DATA_TYPE type;
  // 7 bytes padding
  union {
    xe::be<uint32_t> nData;    // X_XUSER_DATA_TYPE::kInt32
    xe::be<uint64_t> i64Data;  // X_XUSER_DATA_TYPE::kInt64
    xe::be<double> dblData;    // X_XUSER_DATA_TYPE::kDouble
    struct                     // X_XUSER_DATA_TYPE::kUnicode
    {
      xe::be<uint32_t> cbData;  // Includes null-terminator
      xe::be<uint32_t> pwszData;
    } string;
    xe::be<float> fData;  // X_XUSER_DATA_TYPE::kFloat
    struct                // X_XUSER_DATA_TYPE::kBinary
    {
      xe::be<uint32_t> cbData;
      xe::be<uint32_t> pbData;
    } binary;
    xe::be<uint64_t> ftData;  // X_XUSER_DATA_TYPE::kDateTime
  };
};
//static_assert_size(X_XUSER_DATA, 0x10);

// Create 32-bit ID from type/size/id combination
#define XPROFILEID(type, size, id) \
  ((((uint32_t)type & 0xF) << 28) | ((size & 0xFFF) << 16) | (id & 0x3FFF))

// Extract type from 32-bit ID
#define XPROFILEID_TYPE(id) ((X_XUSER_DATA_TYPE)(((uint32_t)id >> 28) & 0xF))

// Extract size from 32-bit ID
#define XPROFILEID_SIZE(id) (((uint32_t)id >> 16) & 0xFFF)

enum X_XDBF_SETTING_ID : uint32_t {
  XPROFILE_PERMISSIONS = XPROFILEID(X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t),
                                    0),  // 0x10040000,
  XPROFILE_GAMER_TYPE = XPROFILEID(X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t),
                                   1),  // 0x10040001,
  XPROFILE_GAMER_YAXIS_INVERSION = XPROFILEID(
      X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t), 2),  // 0x10040002,
  XPROFILE_OPTION_CONTROLLER_VIBRATION = XPROFILEID(
      X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t), 3),  // 0x10040003,
  XPROFILE_TITLE_SPECIFIC1 =
      XPROFILEID(X_XUSER_DATA_TYPE::kBinary, 0x3E8, 0x3FFF),  // 0x63E83FFF,
  XPROFILE_TITLE_SPECIFIC2 =
      XPROFILEID(X_XUSER_DATA_TYPE::kBinary, 0x3E8, 0x3FFE),  // 0x63E83FFE,
  XPROFILE_TITLE_SPECIFIC3 =
      XPROFILEID(X_XUSER_DATA_TYPE::kBinary, 0x3E8, 0x3FFD),  // 0x63E83FFD,
  XPROFILE_GAMERCARD_ZONE = XPROFILEID(X_XUSER_DATA_TYPE::kInt32,
                                       sizeof(uint32_t), 4),  // 0x10040004,
  XPROFILE_GAMERCARD_REGION = XPROFILEID(X_XUSER_DATA_TYPE::kInt32,
                                         sizeof(uint32_t), 5),  // 0x10040005,
  XPROFILE_GAMERCARD_CRED = XPROFILEID(X_XUSER_DATA_TYPE::kInt32,
                                       sizeof(uint32_t), 6),  // 0x10040006,
  XPROFILE_GAMER_PRESENCE_USER_STATE = XPROFILEID(
      X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t), 7),  // 0x10040007,
  XPROFILE_GAMERCARD_HAS_VISION = XPROFILEID(
      X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t), 8),  // 0x10040008,
  XPROFILE_GAMERCARD_REP =
      XPROFILEID(X_XUSER_DATA_TYPE::kFloat, sizeof(float), 0xB),  // 0x5004000B,
  XPROFILE_OPTION_VOICE_MUTED = XPROFILEID(
      X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t), 0xC),  // 0x1004000C,
  XPROFILE_OPTION_VOICE_THRU_SPEAKERS = XPROFILEID(
      X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t), 0xD),  // 0x1004000D,
  XPROFILE_OPTION_VOICE_VOLUME = XPROFILEID(
      X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t), 0xE),  // 0x1004000E,
  XPROFILE_GAMERCARD_PICTURE_KEY =
      XPROFILEID(X_XUSER_DATA_TYPE::kUnicode, 0x64, 0xF),  // 0x4064000F,
  XPROFILE_GAMERCARD_PERSONAL_PICTURE =
      XPROFILEID(X_XUSER_DATA_TYPE::kUnicode, 0x64, 0x10),  // 0x40640010,
  XPROFILE_GAMERCARD_MOTTO =
      XPROFILEID(X_XUSER_DATA_TYPE::kUnicode, 0x2C, 0x11),  // 0x402C0011,
  XPROFILE_GAMERCARD_TITLES_PLAYED = XPROFILEID(
      X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t), 0x12),  // 0x10040012,
  XPROFILE_GAMERCARD_ACHIEVEMENTS_EARNED = XPROFILEID(
      X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t), 0x13),  // 0x10040013,
  XPROFILE_GAMER_DIFFICULTY = XPROFILEID(
      X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t), 0x15),  // 0x10040015,
  XPROFILE_GAMER_CONTROL_SENSITIVITY = XPROFILEID(
      X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t), 0x18),  // 0x10040018,
  XPROFILE_GAMER_PREFERRED_COLOR_FIRST = XPROFILEID(
      X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t), 0x1D),  // 0x1004001D,
  XPROFILE_GAMER_PREFERRED_COLOR_SECOND = XPROFILEID(
      X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t), 0x1E),  // 0x1004001E,
  XPROFILE_GAMER_ACTION_AUTO_AIM = XPROFILEID(
      X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t), 0x22),  // 0x10040022,
  XPROFILE_GAMER_ACTION_AUTO_CENTER = XPROFILEID(
      X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t), 0x23),  // 0x10040023,
  XPROFILE_GAMER_ACTION_MOVEMENT_CONTROL = XPROFILEID(
      X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t), 0x24),  // 0x10040024,
  XPROFILE_GAMER_RACE_TRANSMISSION = XPROFILEID(
      X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t), 0x26),  // 0x10040026,
  XPROFILE_GAMER_RACE_CAMERA_LOCATION = XPROFILEID(
      X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t), 0x27),  // 0x10040027,
  XPROFILE_GAMER_RACE_BRAKE_CONTROL = XPROFILEID(
      X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t), 0x28),  // 0x10040028,
  XPROFILE_GAMER_RACE_ACCELERATOR_CONTROL = XPROFILEID(
      X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t), 0x29),  // 0x10040029,
  XPROFILE_GAMERCARD_TITLE_CRED_EARNED = XPROFILEID(
      X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t), 0x38),  // 0x10040038,
  XPROFILE_GAMERCARD_TITLE_ACHIEVEMENTS_EARNED = XPROFILEID(
      X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t), 0x39),  // 0x10040039,
  XPROFILE_GAMER_TIER = XPROFILEID(X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t),
                                   0x3A),  // 0x1004003A,
  XPROFILE_MESSENGER_SIGNUP_STATE = XPROFILEID(
      X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t), 0x3B),  // 0x1004003B,
  XPROFILE_MESSENGER_AUTO_SIGNIN = XPROFILEID(
      X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t), 0x3C),  // 0x1004003C,
  XPROFILE_SAVE_WINDOWS_LIVE_PASSWORD = XPROFILEID(
      X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t), 0x3D),  // 0x1004003D,
  XPROFILE_FRIENDSAPP_SHOW_BUDDIES = XPROFILEID(
      X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t), 0x3E),  // 0x1004003E,
  XPROFILE_GAMERCARD_SERVICE_TYPE_FLAGS = XPROFILEID(
      X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t), 0x3F),  // 0x1004003F,
  XPROFILE_GAMERCARD_USER_NAME =
      XPROFILEID(X_XUSER_DATA_TYPE::kUnicode, 0x104, 0x40),  // 0x41040040,
  XPROFILE_GAMERCARD_USER_LOCATION =
      XPROFILEID(X_XUSER_DATA_TYPE::kUnicode, 0x52, 0x41),  // 0x40520041,
  XPROFILE_GAMERCARD_USER_URL =
      XPROFILEID(X_XUSER_DATA_TYPE::kUnicode, 0x190, 0x42),  // 0x41900042,
  XPROFILE_GAMERCARD_USER_BIO =
      XPROFILEID(X_XUSER_DATA_TYPE::kUnicode, 0x3E8, 0x43),  // 0x43E80043,
  XPROFILE_GAMERCARD_AVATAR_INFO_1 =
      XPROFILEID(X_XUSER_DATA_TYPE::kBinary, 0x3E8, 0x44),  // 0x63E80044,
  XPROFILE_GAMERCARD_AVATAR_INFO_2 =
      XPROFILEID(X_XUSER_DATA_TYPE::kBinary, 0x3E8, 0x45),  // 0x63E80045,
  XPROFILE_GAMERCARD_PARTY_INFO =
      XPROFILEID(X_XUSER_DATA_TYPE::kBinary, 0x100, 0x46),  // 0x61000046,

  // IDs exclusive to GFWL, some seem to conflict with X360 IDs though,
  // commented out the conflicting IDs All are apparently local-only, and don't
  // get synced to the server
  // XPROFILE_GFWL_AUTOMIX =
  //  XPROFILEID(X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t), 0x47 ),
  //  //0x10040047,
  // XPROFILE_GFWL_MICBOOST =
  //  XPROFILEID(X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t), 0x48 ),
  //  //0x10040048,
  XPROFILE_GFWL_RECDEVICEDESC =
      XPROFILEID(X_XUSER_DATA_TYPE::kUnicode, 200, 0x49),  // 0x40C80049,
  XPROFILE_GFWL_PLAYDEVICE =
      XPROFILEID(X_XUSER_DATA_TYPE::kBinary, 0x10, 0x4A),  // 0x6010004A,
  XPROFILE_GFWL_PLAYDEVICEDESC =
      XPROFILEID(X_XUSER_DATA_TYPE::kUnicode, 200, 0x4B),  // 0x40C8004B,
  XPROFILE_GFWL_VOLUMELEVEL = XPROFILEID(X_XUSER_DATA_TYPE::kFloat,
                                         sizeof(float), 0x4C),  // 0x5004004C,
  XPROFILE_GFWL_RECLEVEL = XPROFILEID(X_XUSER_DATA_TYPE::kFloat, sizeof(float),
                                      0x4D),  // 0x5004004D,
  // XPROFILE_GFWL_VADHIGH =
  //  XPROFILEID(X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t), 0x4E ),
  //  //0x1004004E,
  XPROFILE_GFWL_VADNORMAL = XPROFILEID(X_XUSER_DATA_TYPE::kInt32,
                                       sizeof(uint32_t), 0x4F),  // 0x1004004F,

  XPROFILE_TENURE_LEVEL = XPROFILEID(X_XUSER_DATA_TYPE::kInt32,
                                     sizeof(uint32_t), 0x47),  // 0x10040047,
  XPROFILE_TENURE_MILESTONE = XPROFILEID(
      X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t), 0x48),  // 0x10040048,
  XPROFILE_TENURE_NEXT_MILESTONE_DATE =
      XPROFILEID(X_XUSER_DATA_TYPE::kDateTime, sizeof(uint64_t),
                 0x49),  // 0x70080049, aka ProfileDateTimeCreated?
  XPROFILE_VIDEO_METADATA =
      XPROFILEID(X_XUSER_DATA_TYPE::kBinary, 0x20, 0x4A),  // 0x6020004A,
  XPROFILE_SUBSCRIPTION_TYPE_LENGTH_IN_MONTHS = XPROFILEID(
      X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t), 0x4B),  // 0x1004004B,
  XPROFILE_SUBSCRIPTION_PAYMENT_TYPE = XPROFILEID(
      X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t), 0x4C),  // 0x1004004C,
  XPROFILE_PEC_INFO = XPROFILEID(X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t),
                                 0x4D),  // 0x1004004D,
  XPROFILE_NUI_BIOMETRIC_SIGNIN =
      XPROFILEID(X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t),
                 0x4E),  // 0x1004004E, set by XamUserNuiEnableBiometric

  // 2 unknowns requested by NXE dash
  XPROFILE_LAST_LIVE_SIGNIN =
      XPROFILEID(X_XUSER_DATA_TYPE::kDateTime, sizeof(uint64_t),
                 0x4F),  // 0x7008004F, named "LastOnLIVE" in Velocity
  XPROFILE_UNK_61180050 =
      XPROFILEID(X_XUSER_DATA_TYPE::kBinary, 280, 0x50),  // 0x61180050,

  XPROFILE_JUMP_IN_LIST =
      XPROFILEID(X_XUSER_DATA_TYPE::kBinary, 0x3E8, 0x51),  // 0x63E80051,
  XPROFILE_BEACONS_SOCIAL_NETWORK_SHARING = XPROFILEID(
      X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t), 0x52),  // 0x10040052,
  XPROFILE_USER_PREFERENCES = XPROFILEID(
      X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t), 0x53),  // 0x10040053,
  XPROFILE_GAMERCARD_PARTY_ADDR =
      XPROFILEID(X_XUSER_DATA_TYPE::kBinary, 0x62, 0x54),  // 0x60620054,

  XPROFILE_XBOXONE_GAMERSCORE =
      XPROFILEID(X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t),
                 0x57),  // 0x10040057, "XboxOneGamerscore" inside dash.xex

  WEB_EMAIL_FORMAT = XPROFILEID(X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t),
                                0x2000),  // 0x10042000,
  WEB_FLAGS = XPROFILEID(X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t),
                         0x2001),  // 0x10042001,
  WEB_SPAM = XPROFILEID(X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t),
                        0x2002),  // 0x10042002,
  WEB_FAVORITE_GENRE = XPROFILEID(X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t),
                                  0x2003),  // 0x10042003,
  WEB_FAVORITE_GAME = XPROFILEID(X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t),
                                 0x2004),  // 0x10042004,
  WEB_FAVORITE_GAME1 = XPROFILEID(X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t),
                                  0x2005),  // 0x10042005,
  WEB_FAVORITE_GAME2 = XPROFILEID(X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t),
                                  0x2006),  // 0x10042006,
  WEB_FAVORITE_GAME3 = XPROFILEID(X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t),
                                  0x2007),  // 0x10042007,
  WEB_FAVORITE_GAME4 = XPROFILEID(X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t),
                                  0x2008),  // 0x10042008,
  WEB_FAVORITE_GAME5 = XPROFILEID(X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t),
                                  0x2009),  // 0x10042009,
  WEB_PLATFORMS_OWNED = XPROFILEID(X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t),
                                   0x200A),  // 0x1004200A,
  WEB_CONNECTION_SPEED = XPROFILEID(X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t),
                                    0x200B),  // 0x1004200B,
  WEB_FLASH = XPROFILEID(X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t),
                         0x200C),  // 0x1004200C,
  WEB_VIDEO_PREFERENCE = XPROFILEID(X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t),
                                    0x200D),  // 0x1004200D,

  XPROFILE_CRUX_MEDIA_PICTURE =
      XPROFILEID(X_XUSER_DATA_TYPE::kUnicode, 0x64, 0x3E8),  // 0x406403E8,
  XPROFILE_CRUX_MEDIA_STYLE1 = XPROFILEID(
      X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t), 0x3EA),  // 0x100403EA,
  XPROFILE_CRUX_MEDIA_STYLE2 = XPROFILEID(
      X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t), 0x3EB),  // 0x100403EB,
  XPROFILE_CRUX_MEDIA_STYLE3 = XPROFILEID(
      X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t), 0x3EC),  // 0x100403EC,
  XPROFILE_CRUX_TOP_ALBUM1 = XPROFILEID(
      X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t), 0x3ED),  // 0x100403ED,
  XPROFILE_CRUX_TOP_ALBUM2 = XPROFILEID(
      X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t), 0x3EE),  // 0x100403EE,
  XPROFILE_CRUX_TOP_ALBUM3 = XPROFILEID(
      X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t), 0x3EF),  // 0x100403EF,
  XPROFILE_CRUX_TOP_ALBUM4 = XPROFILEID(
      X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t), 0x3F0),  // 0x100403F0,
  XPROFILE_CRUX_TOP_ALBUM5 = XPROFILEID(
      X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t), 0x3F1),  // 0x100403F1,
  XPROFILE_CRUX_OFFLINE_ID =
      XPROFILEID(X_XUSER_DATA_TYPE::kBinary, 0x34, 0x3F2),  // 0x603403F2,
  XPROFILE_CRUX_BKGD_IMAGE = XPROFILEID(
      X_XUSER_DATA_TYPE::kInt32, sizeof(uint32_t), 0x3F3),  // 0x100403F3,
  XPROFILE_CRUX_LAST_CHANGE_TIME = XPROFILEID(
      X_XUSER_DATA_TYPE::kDateTime, sizeof(uint64_t), 0x3F4),  // 0x700803F4,
  XPROFILE_CRUX_TOP_MUSIC =
      XPROFILEID(X_XUSER_DATA_TYPE::kBinary, 0xA8, 0x3F5),  // 0x60A803F5,
  XPROFILE_CRUX_MEDIA_MOTTO =
      XPROFILEID(X_XUSER_DATA_TYPE::kUnicode, 0x100, 0x3F6),  // 0x410003F6,
  XPROFILE_CRUX_TOP_MEDIAID1 =
      XPROFILEID(X_XUSER_DATA_TYPE::kBinary, 0x10, 0x3F7),  // 0x601003F7,
  XPROFILE_CRUX_TOP_MEDIAID2 =
      XPROFILEID(X_XUSER_DATA_TYPE::kBinary, 0x10, 0x3F8),  // 0x601003F8,
  XPROFILE_CRUX_TOP_MEDIAID3 =
      XPROFILEID(X_XUSER_DATA_TYPE::kBinary, 0x10, 0x3F9),  // 0x601003F9,
  XPROFILE_CRUX_BIO =
      XPROFILEID(X_XUSER_DATA_TYPE::kUnicode, 0x3E8, 0x3FA),  // 0x43E803FA,
  XPROFILE_CRUX_BG_SMALL_PRIVATE =
      XPROFILEID(X_XUSER_DATA_TYPE::kUnicode, 0x64, 0x3FB),  // 0x406403FB,
  XPROFILE_CRUX_BG_LARGE_PRIVATE =
      XPROFILEID(X_XUSER_DATA_TYPE::kUnicode, 0x64, 0x3FC),  // 0x406403FC,
  XPROFILE_CRUX_BG_SMALL_PUBLIC =
      XPROFILEID(X_XUSER_DATA_TYPE::kUnicode, 0x64, 0x3FD),  // 0x406403FD,
  XPROFILE_CRUX_BG_LARGE_PUBLIC =
      XPROFILEID(X_XUSER_DATA_TYPE::kUnicode, 0x64, 0x3FE),  // 0x406403FE
};

struct X_XDBF_GPD_SETTING {
  xe::be<X_XDBF_SETTING_ID> setting_id;
  // 4 bytes padding
  X_XUSER_DATA value;
  // usually followed by value.binary.cbData / value.string.pwszData bytes
};
//static_assert_size(X_XDBF_GPD_SETTING, 0x18);

// Found by dumping the kSectionStringTable sections of various games:
enum class XLanguage : uint32_t {
  kInvalid,
  kEnglish,
  kJapanese,
  kGerman,
  kFrench,
  kSpanish,
  kItalian,
  kKorean,
  kTChinese,
  kPortuguese,
  kUnknown10,  // unused?
  kPolish,
  kRussian,
  kMaxLanguages  // STFS headers can't support any more languages than these?
};

}  // namespace xdbf
}  // namespace xam
}  // namespace kernel
}  // namespace xe

#endif  // XENIA_KERNEL_XAM_XDBF_XDBF_XBOX_H_

```

`formats/xex.cpp`:

```cpp
#ifdef IDALDR
#include <ida.hpp>
#include <diskio.hpp>
#include <typeinf.hpp>
#else
#include <cstdarg>
#endif

#include "xex.hpp"
#include "xex_headerids.hpp"
#include "xex_keys.hpp"

#include <cstring>
#include <cstdio>
#include <memory>
#include <cstdlib>

#include <excrypt.h>

int lzx_decompress(const void* lzx_data, size_t lzx_len, void* dest,
    size_t dest_len, uint32_t window_size, void* window_data,
    size_t window_data_len); // lzx.cpp

bool xex_log_verbose = true;

bool XEXFile::load(void* file)
{
  seek(file, 0, SEEK_END);
  auto fsize = tell(file);
  seek(file, 0, SEEK_SET);

  load_error_ = uint32_t(XEXLoadError::Unfinished);

  read(&xex_header_, sizeof(xex::XexHeader), 1, file);
  xex_header_.endian_swap();

  if (xex_header_.Magic != MAGIC_XEX2 && xex_header_.Magic != MAGIC_XEX1 && 
    xex_header_.Magic != MAGIC_XEX25 && xex_header_.Magic != MAGIC_XEX2D && 
    xex_header_.Magic != MAGIC_XEX3F && xex_header_.Magic != MAGIC_XEX0)
  {
    load_error_ = uint32_t(XEXLoadError::InvalidMagic);
    return false;
  }

  // Convert XEX0/XEX3F header to XEX2
  int dirHeaderOffset = sizeof(xex::XexHeader);
  if (xex_header_.Magic == MAGIC_XEX0)
  {
    xex0::XexHeader header0;

    seek(file, 0, SEEK_SET);
    read(&header0, sizeof(xex0::XexHeader), 1, file);

    memset(&xex_header_, 0, sizeof(xex::XexHeader));

    xex_header_.Magic = header0.Magic;
    xex_header_.SizeOfHeaders = header0.SizeOfHeaders;
    security_info_.ImageInfo.LoadAddress = header0.LoadAddress;
    security_info_.ImageSize = header0.ImageSize;
    xex_header_.HeaderDirectoryEntryCount = header0.HeaderDirectoryEntryCount;

    dirHeaderOffset = sizeof(xex0::XexHeader);
  }
  else if (xex_header_.Magic == MAGIC_XEX3F)
  {
    xex3f::XexHeader header3f;

    seek(file, 0, SEEK_SET);
    read(&header3f, sizeof(xex3f::XexHeader), 1, file);

    memset(&xex_header_, 0, sizeof(xex::XexHeader));

    xex_header_.Magic = header3f.Magic;
    // TODO: convert flags from pre-XEX1 to XEX1+?
    *(uint32_t*)&xex_header_.ModuleFlags =
      xe::byte_swap(*(uint32_t*)&header3f.ModuleFlags);

    xex_header_.SizeOfHeaders = header3f.SizeOfHeaders;
    xex_header_.SizeOfDiscardableHeaders = header3f.SizeOfDiscardableHeaders;
    security_info_.ImageInfo.LoadAddress = header3f.LoadAddress;
    security_info_.ImageSize = header3f.ImageSize;
    xex_header_.HeaderDirectoryEntryCount = header3f.HeaderDirectoryEntryCount;

    dirHeaderOffset = sizeof(xex3f::XexHeader);
  }

  // Read in XEX header section
  xex_headers_.resize(xex_header_.SizeOfHeaders);

  seek(file, 0, SEEK_SET);
  read(xex_headers_.data(), 1, xex_header_.SizeOfHeaders, file);

  data_length_ = (uint32_t)(fsize - xex_header_.SizeOfHeaders);

  seek(file, dirHeaderOffset, SEEK_SET);

  // Read in directory entry / optional header keyvalues
  for (uint32_t i = 0; i < xex_header_.HeaderDirectoryEntryCount; i++)
  {
    xex::XexDirectoryEntry header;
    read(&header, sizeof(xex::XexDirectoryEntry), 1, file);

    directory_entries_[header.Key] = header.Value;

    // XEX25 (and probably XEX2D) use a different imports key
    // some part of them isn't loading properly though, so disable loading imports for those for now
#ifndef IDALDR
    if (header.Key == XEX_HEADER_IMPORTS_BETA)
      directory_entries_[XEX_HEADER_IMPORTS] = header.Value;
#endif
    if (header.Key == XEX_HEADER_BUILD_VERSIONS_BETA)
      directory_entries_[XEX_HEADER_BUILD_VERSIONS] = header.Value;
    if (header.Key == XEX_HEADER_TLS_DATA_BETA)
      directory_entries_[XEX_HEADER_TLS_DATA] = header.Value;
    if (header.Key == XEX_HEADER_STACK_SIZE_BETA)
      directory_entries_[XEX_HEADER_STACK_SIZE] = header.Value;

    // Not sure if we should do this:
    if (header.Key == XEX_HEADER_PE_EXPORTS_BETA)
      directory_entries_[XEX_HEADER_PE_EXPORTS] = header.Value;
  }

  // Read security info
  has_secinfo_ = read_secinfo(file);
  if (has_secinfo_) {
    uint32_t state = verify_secinfo(file);

    // Kinda hacky way to get the security info size...
    // Maybe should save this somewhere when reading instead?
    auto page_desc_size = security_info_.PageDescriptorCount * sizeof(xex::HvPageInfo);
    auto secinfo_size = security_info_.Size - page_desc_size;

    seek(file, xex_header_.SecurityInfo + secinfo_size, SEEK_SET);
    for (uint32_t i = 0; i < security_info_.PageDescriptorCount; i++) {
      xex::HvPageInfo page_desc;
      read(&page_desc, sizeof(xex::HvPageInfo), 1, file);
      page_desc.endian_swap();
      page_descriptors_.push_back(page_desc);
    }
  }

  // Read various optional headers
  if (directory_entries_.count(XEX_HEADER_PE_BASE))
    opt_base_address_ = directory_entries_[XEX_HEADER_PE_BASE];

  if (directory_entries_.count(XEX_HEADER_ENTRY_POINT))
    entry_point_ = directory_entries_[XEX_HEADER_ENTRY_POINT];

  *(uint32_t*)&privileges_ = opt_header(XEX_HEADER_PRIVILEGES);
  *(uint32_t*)&privileges32_ = opt_header(XEX_HEADER_PRIVILEGES_32);

  execution_id_ = opt_header_ptr<xex_opt::XexExecutionId>(XEX_HEADER_EXECUTION_ID);
  if (execution_id_)
  {
    if (header().Magic != MAGIC_XEX2D)
    {
      execution_id_->endian_swap();
    }
    else
    {
      auto* exec_2d = (xex_opt::xex2d::XexExecutionId*)execution_id_;
      exec_2d->endian_swap();
    }
  }

  auto exec_id_25 = opt_header_ptr<xex_opt::xex25::XexExecutionId>(XEX_HEADER_EXECUTION_ID_BETA);
  if (exec_id_25)
    exec_id_25->endian_swap();

  vital_stats_ = opt_header_ptr<xex_opt::XexVitalStats>(XEX_HEADER_VITAL_STATS);
  tls_data_ = opt_header_ptr<xex_opt::XexTlsData>(XEX_HEADER_TLS_DATA);

  data_descriptor_ = opt_header_ptr<xex_opt::XexFileDataDescriptor>(XEX_FILE_DATA_DESCRIPTOR_HEADER);

  auto libs = opt_header_ptr<xex_opt::XexImageLibraryVersions>(XEX_HEADER_BUILD_VERSIONS);
  if (libs)
  {
    auto count = (libs->Size - 4) / sizeof(xex_opt::XexImageLibraryVersion);
    for (uint32_t i = 0; i < count; i++)
      libraries_.push_back(libs->Libraries[i]);
  }

  if (directory_entries_.count(XEX_HEADER_PE_MODULE_NAME))
  {
    auto* header = opt_header_ptr<xex_opt::XexStringHeader>(XEX_HEADER_PE_MODULE_NAME);
    if (header)
      pe_module_name_ = std::string(header->Data, (uint32_t)header->Size);
  }

  // Try decrypting/decompressing the basefile
  if (!read_basefile(file, 0) && !read_basefile(file, 1) && !read_basefile(file, 2) && !read_basefile(file, 3))
    return false;

  // Basefile seems to have read fine, try reading the PE headers
  if (basefile_is_pe())
    if (!pe_load(pe_data_.data()))
      return false;

  // Let's map in the XEX sections too, seeing as there's no tools for pre-XEX2 to view these with
  auto sects = opt_header_ptr<xex_opt::XexSectionHeaders>(XEX_HEADER_SECTION_TABLE);
  if (sects)
  {
    auto count = (sects->Size - 4) / sizeof(xex_opt::XexSectionHeader);
    for (uint32_t i = 0; i < count; i++)
    {
      auto& section = sects->Sections[i];

      IMAGE_SECTION_HEADER pe_sec = {};
      pe_sec.Characteristics = IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ;
      pe_sec.VirtualAddress = section.VirtualAddress - base_address();
      pe_sec.VirtualSize = section.VirtualSize;
      pe_sec.SizeOfRawData = section.VirtualSize;
      std::copy_n(section.SectionName, 8, pe_sec.Name);

      xex_sections_.push_back(pe_sec);
    }
  }

  // XEX3F stores resources with PE sections in a different table:
  auto sects_beta = opt_header_ptr<xex_opt::xex3f::XexSectionHeaders>(XEX_HEADER_SECTION_TABLE_BETA);
  if (sects_beta)
  {
    auto count = (sects_beta->Size - 4) / sizeof(xex_opt::xex3f::XexSectionHeader);
    auto start_index = sections_.size(); // skip PE sections
    for (auto i = start_index; i < count; i++)
    {
      auto& section = sects_beta->Sections[i];

      IMAGE_SECTION_HEADER pe_sec = {};

      pe_sec.Characteristics = IMAGE_SCN_CNT_INITIALIZED_DATA;
      if ((section.PageInfoFlags & xex::HvPageInfoFlags::PageInfoFlag_NoWrite))
      {
        if (!(section.PageInfoFlags & xex::HvPageInfoFlags::PageInfoFlag_NoExecute))
          pe_sec.Characteristics = IMAGE_SCN_CNT_CODE;
      }

      pe_sec.Characteristics |= IMAGE_SCN_MEM_READ;

      if (!(section.PageInfoFlags & xex::HvPageInfoFlags::PageInfoFlag_NoWrite))
        pe_sec.Characteristics |= IMAGE_SCN_MEM_WRITE;
      if (!(section.PageInfoFlags & xex::HvPageInfoFlags::PageInfoFlag_NoExecute))
        pe_sec.Characteristics |= IMAGE_SCN_MEM_EXECUTE;

      pe_sec.VirtualAddress = section.VirtualAddress;
      pe_sec.VirtualSize = section.VirtualSize;
      pe_sec.SizeOfRawData = section.SizeOfRawData;
      pe_sec.PointerToRawData = section.PointerToRawData - xex_header_.SizeOfHeaders;
      std::copy_n(section.SectionName, 8, pe_sec.Name);

      xex_sections_.push_back(pe_sec);
    }
  }

  if (basefile_is_pe())
  {
    // Try reading imports & exports
    read_imports(file);
    read_exports(file);
  }
  else
  {
    // No image to hash, treat it as valid...
    valid_image_hash_ = true;
  }

  if (!security_info_.ImageInfo.ImportTableCount) {
    // No import tables to hash, so treat it as valid...
    valid_imports_hash_ = true;
  }

  load_error_ = uint32_t(XEXLoadError::Success);
  return true;
}

// Reads import libraries & function info from XEX import table
bool XEXFile::read_imports(void* file)
{
  if (!directory_entries_.count(XEX_HEADER_IMPORTS))
    return false;

  if (!directory_entries_[XEX_HEADER_IMPORTS])
    return false;

  seek(file, directory_entries_[XEX_HEADER_IMPORTS], SEEK_SET);

  xex_opt::XexImportDescriptor import_desc;
  read(&import_desc, sizeof(xex_opt::XexImportDescriptor), 1, file);

  // Seperate the library names in the name table
  std::vector<std::string> import_libs;
  std::string cur_lib = "";
  for (uint32_t i = 0; i < import_desc.NameTableSize; i++)
  {
    if (!cur_lib.length())
    {
      // align to 4 bytes
      if ((i % 4) != 0)
      {
        uint32_t align = 4 - (i % 4);
        align = std::min(align, import_desc.NameTableSize - i); // don't let us align past end of nametable
        i += align - 1; // minus 1 since for loop will add 1 to it too
        seek(file, align, SEEK_CUR);

        continue;
      }
    }

    char name_char;
    read(&name_char, 1, 1, file);

    if (name_char == '\0' || name_char == '\xCD')
    {
      if (cur_lib.length())
      {
        import_libs.push_back(cur_lib);
        cur_lib = "";
      }
    }
    else
      cur_lib += name_char;
  }

  // Get import table hashes ready for verifying...
  // (Hash is of +4 into the table, ie skipping the TableSize field)
  uint8_t hash_expected[20];
  uint8_t hash[20];
  std::copy_n(security_info_.ImageInfo.ImportDigest, 20, hash_expected);

  valid_imports_hash_ = true;

  // Read in each import library
  for (uint32_t i = 0; i < import_desc.ModuleCount; i++)
  {
    auto table_addr = tell(file);

#ifndef IDALDR
    // Check hash of table against expected hash
    // TODO: this only seems to work for XEX2 atm, need to find method for XEX1...
    if (valid_imports_hash_) // Only check import hashes while they're valid
    {
      xe::be<uint32_t> table_size;
      read(&table_size, 4, 1, file);

      auto table_data = std::make_unique<uint8_t[]>(table_size - 4);
      read(table_data.get(), table_size - 4, 1, file);

      ExCryptSha(table_data.get(), table_size - 4, 0, 0, 0, 0, hash, 20);
      valid_imports_hash_ = ExCryptMemDiff(hash, hash_expected, 20) == 0;

      // Copy the next tables hash from NextImportDigest
      std::copy_n(table_data.get(), 20, hash_expected);
    }
#endif

    seek(file, table_addr, SEEK_SET);

    // Read in import table header
    xex_opt::XexImportTable table_header;
    if (header().Magic == MAGIC_XEX2D) {
      // XEX2D has a slightly smaller import table, read it and copy stuff over...
      xex_opt::xex2d::XexImportTable table_header_2d;
      read(&table_header_2d, sizeof(xex_opt::xex2d::XexImportTable), 1, file);

      // Copy over to normal table header
      table_header.TableSize = table_header_2d.TableSize;
      std::copy_n(table_header_2d.NextImportDigest, 0x14, table_header.NextImportDigest);
      table_header.ModuleNumber = table_header_2d.ModuleNumber;
      *(uint32_t*)&table_header.Version = xe::byte_swap(*(uint32_t*)&table_header_2d.Version);
      *(uint32_t*)&table_header.VersionMin = 0;
      table_header.Unused = table_header_2d.Unused;
      table_header.ModuleIndex = table_header_2d.ModuleIndex;
      table_header.ImportCount = table_header_2d.ImportCount;
    }
    else
    {
      read(&table_header, sizeof(xex_opt::XexImportTable), 1, file);
      table_header.endian_swap();
    }
    auto& libname = import_libs.at(table_header.ModuleIndex);

    if (!imports_.count(libname))
      imports_[libname] = std::map<uint32_t, XEXFunction>();

    if (!import_tables_.count(libname))
      import_tables_[libname] = table_header;

    for (uint32_t j = 0; j < table_header.ImportCount; j++)
    {
      xe::be<uint32_t> record_addr;
      read(&record_addr, sizeof(uint32_t), 1, file);
      if (!record_addr)
        continue;

      // Read import data from basefile
      auto record_offset = pe_rva_to_offset(record_addr);

      auto record_value = *(uint32_t*)(pe_data() + record_offset);
      record_value = xe::byte_swap(record_value);

      auto record_type = (record_value & 0xFF000000) >> 24;
      auto ordinal = record_value & 0xFFFF;

      XEXFunction imp;
      if (imports_[libname].count(ordinal))
        imp = imports_[libname][ordinal];

      if (record_type == 0)
      {
        // variable
        imp.ThunkAddr = record_addr;
      }
      else if (record_type == 1)
      {
        // function
        imp.FuncAddr = record_addr;

        // have to rewrite code to set r3 & r4 like xorlosers loader does
        // r3 = module index
        // r4 = ordinal
        // important to note that basefiles extracted via xextool have this rewrite done already, but raw basefile from XEX doesn't!
        *(uint32_t*)(pe_data() + record_offset + 0) = xe::byte_swap(0x38600000 | table_header.ModuleIndex);
        *(uint32_t*)(pe_data() + record_offset + 4) = xe::byte_swap(0x38800000 | ordinal);
      }
      else // todo: does this ever appear?
        dbgmsg("[+] %s import %d (@ 0x%X) unknown type %d!\n", libname.c_str(), ordinal, record_addr, record_type);

      imports_[libname][ordinal] = imp;
    }

    // Seek to end of this import table
    seek(file, table_addr + table_header.TableSize, SEEK_SET);
  }

  // Handle callcap imports
  if (directory_entries_.count(XEX_HEADER_CALLCAP_IMPORTS))
  {
    xex_opt::XexCallcapImports callcap;

    std::copy_n(
      reinterpret_cast<xex_opt::XexCallcapImports*>(xex_headers_.data() + directory_entries_[XEX_HEADER_CALLCAP_IMPORTS]),
      1,
      &callcap);

    if (!callcap.BeginFunctionThunkAddress || !callcap.EndFunctionThunkAddress)
      return true;

    dbgmsg("[+] Naming callcap imports... (%X-%X)\n", uint32_t(callcap.BeginFunctionThunkAddress), uint32_t(callcap.EndFunctionThunkAddress));
    for (auto& addr : { callcap.BeginFunctionThunkAddress, callcap.EndFunctionThunkAddress })
    {
      if (!addr)
        continue;

      uint32_t import_offset = pe_rva_to_offset(addr);

      uint32_t info_1 = *(uint32_t*)(pe_data() + import_offset);
      uint32_t info_2 = *(uint32_t*)(pe_data() + import_offset + 4);
      info_1 = xe::byte_swap(info_1);
      info_2 = xe::byte_swap(info_2);

      auto ordinal_1 = info_1 & 0xFFFF;
      auto ordinal_2 = info_2 & 0xFFFF;
      auto moduleidx_1 = (info_1 & 0xFF0000) >> 16;
      auto moduleidx_2 = (info_2 & 0xFF0000) >> 16;

      // Sanity check the callcap info, values from first dword should match values in second
      if (ordinal_1 != ordinal_2 || moduleidx_1 != moduleidx_2)
      {
        dbgmsg("[!] Invalid callcap at 0x%X? (%X %X %X %X)\n", addr, ordinal_1, ordinal_2, moduleidx_1, moduleidx_2);
        continue;
      }

      // Not sure if it should always be xbdm or not...
      std::string libname = "xbdm.xex";
      if (import_libs.size() > moduleidx_1)
        libname = import_libs.at(moduleidx_1);

      if (!imports_.count(libname))
        imports_[libname] = std::map<uint32_t, XEXFunction>();

      XEXFunction imp;
      if (imports_[libname].count(ordinal_1))
        imp = imports_[libname][ordinal_1];

      imp.ThunkAddr = addr;
      imp.FuncAddr = addr;

      *(uint32_t*)(pe_data() + import_offset + 0) = xe::byte_swap(0x38600000 | moduleidx_1);
      *(uint32_t*)(pe_data() + import_offset + 4) = xe::byte_swap(0x38800000 | ordinal_1);

      imports_[libname][ordinal_1] = imp;
    }
  }

  return true;
}

// Reads function info defined inside XEX export table
bool XEXFile::read_exports(void* file)
{
  uint32_t exports_va = security_info_.ImageInfo.ExportTableAddress;
  if (xex_header_.Magic == MAGIC_XEX1 && directory_entries_.count(XEX_HEADER_EXPORTS_XEX1))
    exports_va = directory_entries_[XEX_HEADER_EXPORTS_XEX1];

  if (!exports_va)
    return false;

  auto export_table_offset = pe_rva_to_offset(exports_va);

  xex_opt::HvImageExportTable export_table;
  std::copy_n(
    reinterpret_cast<const xex_opt::HvImageExportTable*>(pe_data() + export_table_offset), 1, 
    &export_table);

  if (export_table.Magic[0] != XEX_HV_MAGIC_0 ||
    export_table.Magic[1] != XEX_HV_MAGIC_HVE ||
    export_table.Magic[2] != XEX_HV_MAGIC_2)
  {
    dbgmsg("[+] Export table magic is invalid! (0x%X 0x%X 0x%X)\n", export_table.Magic[0], export_table.Magic[1], export_table.Magic[2]);
    return false;
  }

  dbgmsg("[+] Loading module exports...\n");
#ifdef IDALDR
  char module_name[256];
  get_root_filename(module_name, 256);
#endif

  auto ordinal_addrs_va = exports_va + sizeof(xex_opt::HvImageExportTable);
  auto ordinal_addrs_offset = export_table_offset + sizeof(xex_opt::HvImageExportTable);
  for (uint32_t i = 0; i < export_table.Count; i++)
  {
    auto ordinal = export_table.Base + i;

    XEXFunction exp;
    if (exports_.count(ordinal))
      exp = exports_[ordinal];

    exp.ThunkAddr = (uint32_t)(ordinal_addrs_va + (i * 4));
    exp.FuncAddr = *(uint32_t*)(pe_data() + ordinal_addrs_offset + (i * 4));
    exp.FuncAddr = xe::byte_swap(exp.FuncAddr);
    if (!exp.FuncAddr)
      continue;

    exp.FuncAddr += (export_table.ImageBaseAddress << 16);

    exports_[ordinal] = exp;
  }

  return true;
}

uint32_t XEXFile::verify_secinfo(void* file)
{
  valid_signature_ = false;
  valid_header_hash_ = false;

  if (xex_header_.Magic != MAGIC_XEX2)
    return 0; // TODO: figure out how to verify XEX1 etc...

#ifndef IDALDR
  int imageinfo_offset = 8;
  if (xex_header_.Magic == MAGIC_XEX2D)
    imageinfo_offset = 4;

  int imageinfo_size = sizeof(xex2::HvImageInfo);
  switch (xex_header_.Magic) {
  case MAGIC_XEX1:
    imageinfo_size = sizeof(xex1::HvImageInfo);
    break;
  case MAGIC_XEX25:
    imageinfo_size = sizeof(xex25::HvImageInfo);
    break;
  case MAGIC_XEX2D:
    imageinfo_size = sizeof(xex2d::SecurityInfo) - 4; // probably wrong, doesn't matter since XEX2D signatures are null anyway
    break;
  }

  // "XEX: XexpVerifyXexHeaders: SecurityInfo offset invalid\n";
  uint32_t header_remainder = xex_header_.SizeOfHeaders - xex_header_.SecurityInfo;
  bool valid_offset = true;
  if (xex_header_.SecurityInfo > xex_header_.SizeOfHeaders || header_remainder < 4)
    valid_offset = false;

  // "XEX: XexpVerifyXexHeaders: SecurityInfo size invalid\n"
  bool valid_size = true;
  if (security_info_.Size < 0x184 || security_info_.Size > header_remainder)
    valid_size = false;

  uint8_t hash[20];
  if (valid_offset && valid_size)
  {
    // Check signature validity
    auto imageinfo = std::make_unique<uint8_t[]>(imageinfo_size);
    seek(file, (uint64_t)xex_header_.SecurityInfo + imageinfo_offset, SEEK_SET);
    read(imageinfo.get(), imageinfo_size, 1, file);

    ExCryptRotSumSha(imageinfo.get() + 0x100, imageinfo_size - 0x100, 0, 0, hash, 20);

    auto* salt = "XBOX360XEX";
    if (security_info_.ImageInfo.ImageFlags.RevocationCheckRequired)
      salt = "XBOX360REV";

    int pubkey_idx = 0;
    for (; pubkey_idx < num_pubkeys; pubkey_idx++)
    {
      EXCRYPT_SIG tmp;
      std::copy_n(reinterpret_cast<EXCRYPT_SIG*>(imageinfo.get()), 1, &tmp);

      valid_signature_ = ExCryptBnQwBeSigVerify(&tmp, hash, (uint8_t*)salt, (EXCRYPT_RSA*)pubkey_bytes[pubkey_idx]);
      if (valid_signature_)
      {
        signkey_index_ = pubkey_idx;
        break;
      }
    }

    // Check header hash
    uint32_t imageinfo_end = xex_header_.SecurityInfo + imageinfo_offset + imageinfo_size;
    uint32_t header_remainsize = xex_header_.SizeOfHeaders - imageinfo_end;
    auto header_remainbytes = std::make_unique<uint8_t[]>(header_remainsize);
    seek(file, imageinfo_end, SEEK_SET);
    read(header_remainbytes.get(), header_remainsize, 1, file);

    auto xex_header_raw = std::make_unique<uint8_t[]>((uint64_t)xex_header_.SecurityInfo + 8);
    seek(file, 0, SEEK_SET);
    read(xex_header_raw.get(), 1, (uint64_t)xex_header_.SecurityInfo + 8, file);

    ExCryptSha(header_remainbytes.get(), header_remainsize, xex_header_raw.get(), xex_header_.SecurityInfo + 8, 0, 0, hash, 20);
    valid_header_hash_ = ExCryptMemDiff(hash, security_info_.ImageInfo.HeaderHash, 20) == 0;
  }

  return valid_signature_ && valid_header_hash_;
#endif
  return 0;
}

// Reads in the different XEX formats SecurityInfo into the XEX2 SecurityInfo struct
bool XEXFile::read_secinfo(void* file)
{
  auto magic = xex_header_.Magic;

  if (magic == MAGIC_XEX3F || magic == MAGIC_XEX0)
    return false; // XEX3F/XEX0 doesn't have securityinfo header!

  if (magic == MAGIC_XEX2)
  {
    seek(file, xex_header_.SecurityInfo, SEEK_SET);
    read(&security_info_, sizeof(xex2::SecurityInfo), 1, file);
    security_info_.endian_swap();
    return true;
  }

  // Not an XEX2 - have to "convert" them into XEX2's securityinfo format

  // SecurityInfo.Size - always at SecurityInfo[0]
  seek(file, xex_header_.SecurityInfo, SEEK_SET);

  // Special case for XEX2D as security info is formatted a lot differently there
  if (magic == MAGIC_XEX2D)
  {
    xex2d::SecurityInfo secInfo2D;
    read(&secInfo2D, sizeof(xex2d::SecurityInfo), 1, file);

    memset(&security_info_, 0, sizeof(xex2::SecurityInfo));

    security_info_.Size = secInfo2D.Size;
    std::copy_n(secInfo2D.Signature, 0x100, security_info_.ImageInfo.Signature);
    // HeaderHash
    std::copy_n(secInfo2D.ImageHash, 0x14, security_info_.ImageInfo.ImageHash);
    security_info_.ImageInfo.LoadAddress = secInfo2D.LoadAddress;
    security_info_.ImageSize = secInfo2D.ImageSize;
    // CurrentVersion
    // LowestAcceptableVersion
    security_info_.PageDescriptorCount = (uint32_t)secInfo2D.PageDescriptorCount;
    *(uint32_t*)&security_info_.ImageInfo.ImageFlags = (uint32_t)secInfo2D.ImageFlags; // todo: convert flags on-the-fly?

    return true;
  }

  read(&security_info_.Size, sizeof(uint32_t), 1, file);

  // SecurityInfo.ImageSize - mostly at SecurityInfo[4]
  seek(file, xex_header_.SecurityInfo + 4, SEEK_SET);
  read(&security_info_.ImageSize, sizeof(uint32_t), 1, file);

  // Read fields common to all XEX versions
  // TODO: find some nicer way to handle all this!
  std::map<uint32_t, size_t> offsets;

  {
#define READ_FIELD(n, sz) offsets = { \
    {MAGIC_XEX1, offsetof(xex1::SecurityInfo, n)}, \
    {MAGIC_XEX25, offsetof(xex25::SecurityInfo, n)}, \
  }; \
  seek(file, xex_header_.SecurityInfo + offsets[magic], SEEK_SET); \
  read(&security_info_.n, sz, 1, file);
    READ_FIELD(ImageInfo.Signature, 0x100);
    READ_FIELD(ImageInfo.ImageFlags, sizeof(uint32_t));
    READ_FIELD(ImageInfo.LoadAddress, sizeof(uint32_t));
    READ_FIELD(ImageInfo.ImageHash, 0x14);
    READ_FIELD(ImageInfo.ImportDigest, 0x14);
    READ_FIELD(ImageInfo.ImageKey, 0x10);

    READ_FIELD(AllowedMediaTypes, sizeof(xex::AllowedMediaTypes));
    READ_FIELD(PageDescriptorCount, sizeof(uint32_t));
    security_info_.endian_swap();
#undef READ_FIELD
  }

  if (magic == MAGIC_XEX25)
  {
    // Read fields shared between XEX2 and XEX25
    auto offset_exportTable = offsetof(xex25::SecurityInfo, ImageInfo.ExportTableAddress);
    seek(file, xex_header_.SecurityInfo + offset_exportTable, SEEK_SET);
    read(&security_info_.ImageInfo.ExportTableAddress, 1, sizeof(uint32_t), file);
  }
  else if (magic == MAGIC_XEX1)
  {
    // Read fields shared between XEX2 and XEX1
    auto offset_mediaId = offsetof(xex1::SecurityInfo, ImageInfo.MediaID);
    seek(file, xex_header_.SecurityInfo + offset_mediaId, SEEK_SET);
    read(&security_info_.ImageInfo.MediaID, 0x10, 1, file);

    auto offset_gameRegion = offsetof(xex1::SecurityInfo, ImageInfo.GameRegion);
    seek(file, xex_header_.SecurityInfo + offset_gameRegion, SEEK_SET);
    read(&security_info_.ImageInfo.GameRegion, sizeof(xex::GameRegion), 1, file);
  }

  return true;
}

// Reads (and optionally decrypts) the basefile from the XEX in "raw" format
bool XEXFile::read_basefile_raw(void* file, bool encrypted)
{
  pe_data_.resize(image_size());

  seek(file, xex_header_.SizeOfHeaders, SEEK_SET);
  read(pe_data_.data(), 1, data_length_, file);

  if (encrypted)
  {
    uint8_t aes_iv[0x10] = { 0 };
    EXCRYPT_AES_STATE aes_state;
    ExCryptAesKey(&aes_state, session_key_);
    ExCryptAesCbc(&aes_state, pe_data_.data(), data_length_, pe_data_.data(), aes_iv, false);
  }

  return true;
}

// Reads (and optionally decrypts) the basefile from the XEX in uncompressed format
bool XEXFile::read_basefile_uncompressed(void* file, bool encrypted)
{
  if (!data_descriptor_)
  {
    load_error_ = uint32_t(XEXLoadError::MissingDataDescriptor);
    return false;
  }

  int num_blocks = (data_descriptor_->Size - 8) / 8;
  auto xex_blocks = std::make_unique<xex_opt::XexRawDataDescriptor[]>(num_blocks);

  std::copy_n(
    reinterpret_cast<xex_opt::XexRawDataDescriptor*>(xex_headers_.data() + directory_entries_[XEX_FILE_DATA_DESCRIPTOR_HEADER] + 8),
    num_blocks,
    xex_blocks.get());

  uint8_t aes_iv[0x10] = { 0 };
  EXCRYPT_AES_STATE aes_state;
  if (encrypted)
    ExCryptAesKey(&aes_state, session_key_);

  pe_data_.resize(image_size());
  uint32_t position = 0;
  seek(file, xex_header_.SizeOfHeaders, SEEK_SET);
  for (int i = 0; i < num_blocks; i++)
  {
    // if it's the first block & encrypted, we'll test-decrypt the first 16 bytes
    // so we can test if it decrypted properly with this key, without needing to process the entire block
    if (i == 0 && encrypted)
    {
      // Read first 16 bytes of block and decrypt
      auto pos = tell(file);
      read(pe_data_.data(), 1, 0x10, file);
      ExCryptAesEcb(&aes_state, pe_data_.data(), pe_data_.data(), false);

#ifdef IDALDR
      // Check basefile header - needed for IDALDR since we don't compute image hash for that
      if (!basefile_is_valid())
      {
        pe_data_.clear();

        load_error_ = uint32_t(XEXLoadError::InvalidBaseFile);
        return false;
      }
#endif

      // Reinit AES & seek back to start of block
      ExCryptAesKey(&aes_state, session_key_);
      seek(file, pos, SEEK_SET);
    }

    read(pe_data_.data() + position, 1, xex_blocks[i].DataSize, file);

    if (encrypted)
      ExCryptAesCbc(&aes_state, pe_data_.data() + position, xex_blocks[i].DataSize, pe_data_.data() + position, aes_iv, false);

    position += xex_blocks[i].DataSize;
    memset(pe_data_.data() + position, 0, xex_blocks[i].ZeroSize);
    position += xex_blocks[i].ZeroSize;
  }
  // todo: verify block size sum == ImageSize ?

  return true;
}

// Reads (and optionally decrypts) the basefile from the XEX in LZX-compressed format
bool XEXFile::read_basefile_compressed(void* file, bool encrypted)
{
  uint8_t aes_iv[0x10] = { 0 };
  EXCRYPT_AES_STATE aes_state;
  if (encrypted)
    ExCryptAesKey(&aes_state, session_key_);

  // read windowsize & first block from file_data_descriptor header
  xex_opt::XexCompressedDataDescriptor compression_info = 
      *reinterpret_cast<xex_opt::XexCompressedDataDescriptor*>(
          xex_headers_.data() + directory_entries_[XEX_FILE_DATA_DESCRIPTOR_HEADER] + 8);

  auto* cur_block = &compression_info.FirstDescriptor;

  // Alloc memory for the PE
  pe_data_.resize(image_size());

  // LZX init...
  std::unique_ptr<uint8_t[]> comp_buffer = std::make_unique<uint8_t[]>(data_length_);
  if (!comp_buffer || !comp_buffer.get())
  {
    load_error_ = uint32_t(XEXLoadError::AllocFailed);
    dbgmsg("[!] Error: failed to allocate decompression buffer!?\n");
    return false;
  }

  uint8_t* d = comp_buffer.get();

  int retcode = 0;

  // Start decompressing
  seek(file, xex_header_.SizeOfHeaders, SEEK_SET);
  xex_opt::XexDataDescriptor next_block;
  uint8_t* block_data = 0;
  while (cur_block->Size)
  {
    block_data = (uint8_t*)malloc(cur_block->Size);
    read(block_data, 1, cur_block->Size, file);

    if (encrypted)
      ExCryptAesCbc(&aes_state, block_data, cur_block->Size, block_data, aes_iv, false);

    // Check hash of the block - don't want to attempt decompressing invalid data!
    uint8_t sha_hash[0x14];
    ExCryptSha(block_data, cur_block->Size, nullptr, 0, nullptr, 0, sha_hash, sizeof(sha_hash));

    if (memcmp(sha_hash, cur_block->DataDigest, 0x14) != 0)
    {
      retcode = 2;
      load_error_ = uint32_t(XEXLoadError::BadBlockHash);
      goto end;
    }

    std::copy_n(reinterpret_cast<xex_opt::XexDataDescriptor*>(block_data), 1, &next_block);
    uint8_t* p = block_data + sizeof(xex_opt::XexDataDescriptor);
    while (true)
    {
      uint16_t comp_size = *(uint16_t*)p;
      p += 2;
      if (!comp_size)
        break;

      comp_size = xe::byte_swap(comp_size);
      if (comp_size > 0x9800) // sanity check: shouldn't be above 0x9800
      {
        retcode = 1;
        load_error_ = uint32_t(XEXLoadError::BadBlockSize);
        goto end;
      }
      // Read in LZX buffer
      std::copy_n(p, comp_size, d);
      p += comp_size;
      d += comp_size;
    }
    std::copy_n(reinterpret_cast<xex_opt::XexDataDescriptor*>(&next_block), 1, cur_block);

    free(block_data);
    block_data = 0;
  }

  retcode = lzx_decompress(comp_buffer.get(), d - comp_buffer.get(), pe_data_.data(), pe_data_.size(), compression_info.WindowSize, nullptr, 0);

end:
  if (block_data)
    free(block_data);

  if (retcode != 0)
  {
    load_error_ = retcode;
    dbgmsg("[!] read_basefile_compressed error code = %d!\n", retcode);
  }

  return retcode == 0;
}

// TODO: fix this to work with older XEX formats
uint32_t XEXFile::xex_va_to_offset(uint32_t va)
{
  if (!data_descriptor_)
    return false;

  auto comp_format = data_descriptor_->DataFormat();

  // convert VA to RVA if necessary
  if (va >= base_address())
    va -= base_address();

  if (comp_format == xex_opt::XexDataFormat::None)
    return xex_header_.SizeOfHeaders + va;

  if (comp_format != xex_opt::XexDataFormat::Raw)
    return 0; // can't get offset for compressed XEXs

  int num_blocks = (data_descriptor_->Size - 8) / 8;
  xex_opt::XexRawDataDescriptor* xex_blocks =
    reinterpret_cast<xex_opt::XexRawDataDescriptor*>(xex_headers_.data() + directory_entries_[XEX_FILE_DATA_DESCRIPTOR_HEADER] + 8);

  // Uncompressed blocks can have any number of zeroes appended to them, instead of these zeroes being stored in the XEX
  // To locate the RVA just track the block size + zero size together, and then return its proper address without zeroes.
  uint32_t address = 0;
  uint32_t real_position = 0;
  for (int i = 0; i < num_blocks; i++)
  {
    const auto& block = xex_blocks[i];
    auto block_end = address + block.DataSize;
    if (va >= address && va < block_end)
      return xex_header_.SizeOfHeaders + real_position + (va - address);

    address += block.DataSize + block.ZeroSize;
    real_position += block.DataSize;
  }

  return 0;
}

// TODO: fix this to work with older XEX formats
uint32_t XEXFile::xex_offset_to_va(uint32_t offset)
{
  if (!data_descriptor_)
    return false;

  auto comp_format = data_descriptor_->DataFormat();

  if (xex_header_.SizeOfHeaders > offset)
    return 0;

  offset -= xex_header_.SizeOfHeaders;

  if (comp_format == xex_opt::XexDataFormat::None)
    return base_address() + offset;

  if (comp_format != xex_opt::XexDataFormat::Raw)
    return 0; // can't get offset for compressed XEXs

  int num_blocks = (data_descriptor_->Size - 8) / 8;
  auto xex_blocks = std::make_unique<xex_opt::XexRawDataDescriptor[]>(num_blocks);

  std::copy_n(
    reinterpret_cast<xex_opt::XexRawDataDescriptor*>(xex_headers_.data() + directory_entries_[XEX_FILE_DATA_DESCRIPTOR_HEADER] + 8),
    num_blocks,
    xex_blocks.get());

  // Uncompressed blocks can have any number of zeroes appended to them, instead of these zeroes being stored in the XEX
  // To locate the RVA just track the block size + zero size together, and then return its proper address without zeroes.
  uint32_t address = 0;
  uint32_t real_position = 0;
  for (int i = 0; i < num_blocks; i++)
  {
    const auto& block = xex_blocks[i];
    auto block_end = real_position + block.DataSize;
    if (offset >= real_position && offset < block_end)
      return base_address() + address + (offset - real_position);

    address += block.DataSize + block.ZeroSize;
    real_position += block.DataSize;
  }

  return 0;
}

// Reads import libraries & function info from PE headers
bool XEXFile::pe_load_imports(const uint8_t* data)
{
  IMAGE_DOS_HEADER* dos_header = (IMAGE_DOS_HEADER*)data;
  if (dos_header->MZSignature != EXE_MZ_SIGNATURE)
    return false;

  IMAGE_NT_HEADERS* nt_header = (IMAGE_NT_HEADERS*)(data + dos_header->AddressOfNewExeHeader);
  if (nt_header->Signature != EXE_NT_SIGNATURE)
    return false;

  auto imports_addr = pe_rva_to_offset(nt_header->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);
  if (!imports_addr)
    return false;

  // Loop through import descriptors...
  auto* import_desc = (IMAGE_IMPORT_DESCRIPTOR*)(data + imports_addr);
  while (import_desc->FirstThunk)
  {
    auto module_name_addr = pe_rva_to_offset(import_desc->Name);
    if (module_name_addr)
    {
      char* libname = (char*)(data + module_name_addr);

      imports_addr = pe_rva_to_offset(import_desc->FirstThunk);
      if (imports_addr)
      {
        if (!imports_.count(libname))
          imports_[libname] = std::map<uint32_t, XEXFunction>();

        // Loop through imports...
        uint32_t import_offset = 0;
        auto* import_data = (uint32_t*)(data + imports_addr);
        while (*import_data++)
        {
          auto ordinal = *import_data & 0xFFFF;

          XEXFunction imp;
          if (imports_[libname].count(ordinal))
            imp = imports_[libname][ordinal];

          imp.ThunkAddr = base_address() + import_desc->FirstThunk + import_offset;

          imports_[libname][ordinal] = imp;
          import_offset += 4;

          // todo: search code for references to ThunkAddr
        }
      }
    }
    import_desc++;
  }

  return true;
}

// Reads function info defined inside PE headers
bool XEXFile::pe_load_exports(const uint8_t* data)
{
  IMAGE_DOS_HEADER* dos_header = (IMAGE_DOS_HEADER*)data;
  if (dos_header->MZSignature != EXE_MZ_SIGNATURE)
    return false;

  IMAGE_NT_HEADERS* nt_header = (IMAGE_NT_HEADERS*)(data + dos_header->AddressOfNewExeHeader);
  if (nt_header->Signature != EXE_NT_SIGNATURE)
    return false;

  auto exports_addr = pe_rva_to_offset(nt_header->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
  if (!exports_addr)
    return false;

  auto* exports_desc = (IMAGE_EXPORT_DIRECTORY*)(data + exports_addr);

  auto module_name_addr = pe_rva_to_offset(exports_desc->Name);
  if (!module_name_addr)
    return false;

  exports_libname_ = (char*)(data + module_name_addr);
  auto exports_ptr_addr = pe_rva_to_offset(exports_desc->AddressOfFunctions);
  for (uint32_t i = 0; i < exports_desc->NumberOfFunctions; i++)
  {
    auto ordinal = exports_desc->Base + i;
    XEXFunction exp;
    if (exports_.count(ordinal))
      exp = exports_[ordinal];

    exp.ThunkAddr = base_address() + exports_desc->AddressOfFunctions + (i * 4);
    exp.FuncAddr = *(uint32_t*)(data + exports_ptr_addr + (i * 4));
    if (!exp.FuncAddr)
      continue;

    exp.FuncAddr += base_address();

    exports_[ordinal] = exp;
  }

  return true;
}

// Reads information from PE headers (section info, entrypoint, base addr...)
bool XEXFile::pe_load(const uint8_t* data)
{
  IMAGE_DOS_HEADER* dos_header = (IMAGE_DOS_HEADER*)data;
  if (dos_header->MZSignature != EXE_MZ_SIGNATURE)
  {
    load_error_ = uint32_t(XEXLoadError::PEMissingMZ);
    return false;
  }

  IMAGE_NT_HEADERS* nt_header = (IMAGE_NT_HEADERS*)(data + dos_header->AddressOfNewExeHeader);
  if (nt_header->Signature != EXE_NT_SIGNATURE)
  {
    load_error_ = uint32_t(XEXLoadError::PEMissingNTHeaders);
    return false;
  }

  // Get base address/entrypoint from optionalheader if we don't already have them
  if (!base_address())
    opt_base_address_ = nt_header->OptionalHeader.ImageBase;

  if (!entry_point_)
    entry_point_ = base_address() + nt_header->OptionalHeader.AddressOfEntryPoint;

  // Read in PE sections
  IMAGE_SECTION_HEADER* sects = (IMAGE_SECTION_HEADER*)(data +
    dos_header->AddressOfNewExeHeader +
    sizeof(IMAGE_NT_HEADERS));

  for (int i = 0; i < nt_header->FileHeader.NumberOfSections; i++)
      sections_.push_back(sects[i]);

  if (xex_header_.Magic == MAGIC_XEX3F || xex_header_.Magic == MAGIC_XEX0)
  {
    if (nt_header->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size)
      pe_load_imports(data);

    if (nt_header->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size)
      pe_load_exports(data);
  }

  // Read in callbacks from TLS directory if exists
  auto& tls_directory = nt_header->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS];
  if (tls_directory.Size)
  {
    auto tls_dir_offset = pe_rva_to_offset(tls_directory.VirtualAddress);
    if (pe_data_.size() >= (tls_dir_offset + sizeof(IMAGE_TLS_DIRECTORY32)))
    {
      tls_directory_va_ = base_address() + tls_dir_offset;
      tls_directory_ = *(IMAGE_TLS_DIRECTORY32*)(data + tls_dir_offset);
      if (tls_directory_.AddressOfCallBacks)
      {
        auto callback_offset = pe_rva_to_offset(tls_directory_.AddressOfCallBacks);
        dbgmsg("[+] Reading TLS callbacks from 0x%X (directory: 0x%X)\n", base_address() + callback_offset, base_address() + tls_dir_offset);

        if (pe_data_.size() >= (callback_offset + sizeof(uint32_t)))
        {
          auto* callbacks = reinterpret_cast<const xe::be<uint32_t>*>(data + callback_offset);
          while (*callbacks)
          {
            uint32_t callback = *callbacks;
            tls_callbacks_.push_back(*callbacks);
            callbacks++;
          }
        }
      }
    }
  }

  // Read in debug directory if exists (and valid)
  auto& debug_directory = nt_header->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG];
  if (debug_directory.Size)
  {
    int num_directories = debug_directory.Size / sizeof(IMAGE_DEBUG_DIRECTORY);
    auto debug_dir_offset = pe_rva_to_offset(debug_directory.VirtualAddress);
    if (pe_data_.size() >= (debug_dir_offset + (sizeof(IMAGE_DEBUG_DIRECTORY) * num_directories)))
    {
      IMAGE_DEBUG_DIRECTORY* dir_ptr = (IMAGE_DEBUG_DIRECTORY*)(data + debug_dir_offset);
      for (int i = 0; i < num_directories; i++)
      {
        auto dir = *dir_ptr;
        dir_ptr++;

        debug_directories_.push_back(dir);

        if (dir.Type != 2 /* CODEVIEW */ || dir.SizeOfData == 0)
          continue;

        // Both AddressOfRawData & PointerToRawData usually seem to point to same offset, but not sure if that's always the case
        // Check if either of them point to valid CV_INFO
        CV_INFO_PDB70* cv_ptr = nullptr;
        for (auto& addr : { dir.AddressOfRawData, dir.PointerToRawData, pe_rva_to_offset(dir.AddressOfRawData), pe_rva_to_offset(dir.PointerToRawData) })
        {
          if (addr > 0 && pe_data_.size() >= (addr + dir.SizeOfData))
          {
            auto* test_ptr = (CV_INFO_PDB70*)(data + addr);
            if (test_ptr->CvSignature == CV_INFO_RSDS_SIGNATURE)
            {
              cv_ptr = test_ptr;
              break;
            }
          }
        }

        // Bail out if neither are valid
        if (!cv_ptr)
          continue;

        std::vector<uint8_t> data;
        data.resize(dir.SizeOfData);
        std::copy_n((uint8_t*)cv_ptr, dir.SizeOfData, data.data());

        codeview_data_.push_back(data);
      }
    }
  }

  return true;
}

// Converts an RVA into a file offset
uint32_t XEXFile::pe_rva_to_offset(uint32_t rva)
{
  if (rva > base_address())
    rva -= base_address();
  if (xex_header_.Magic != MAGIC_XEX3F && xex_header_.Magic != MAGIC_XEX0)
    return rva; // all formats besides XEX3F/XEX0 seem to keep raw data lined up with in-memory PE?

  for (const auto& section : sections_)
  {
    if (rva >= section.VirtualAddress && rva < section.VirtualAddress + section.VirtualSize)
      return rva - section.VirtualAddress + section.PointerToRawData;
  }

  return 0;
}

bool XEXFile::has_header(uint32_t id)
{
  return directory_entries_.count(id) > 0;
}

uint32_t XEXFile::opt_header(uint32_t id)
{
  if (!directory_entries_.count(id))
    return 0;
  
  return directory_entries_[id];
}

void* XEXFile::opt_header_ptr(uint32_t id)
{
  auto val = opt_header(id);
  if (!val)
    return 0;

  // TODO: check if the value is stored in the directory_entries_ section
  // and return pointer to it if so?

  return xex_headers_.data() + val;
}

// Reads in, decrypts, decompresses & verifies the basefile from the XEX image
bool XEXFile::read_basefile(void* file, int key_index)
{
  xex_opt::XexDataFormat comp_format = xex_opt::XexDataFormat::None;
  uint16_t enc_flag = 0;

  // Read compression/encryption info from data descriptor header if we have one
  if (data_descriptor_)
  {
    comp_format = data_descriptor_->DataFormat();
    enc_flag = data_descriptor_->Flags;
  }

  key_index_ = key_index;
  if (key_index == 0) // only print this on first invocation of read_basefile
  {
    const char* format = "Raw";
    if (comp_format == xex_opt::XexDataFormat::Compressed)
      format = "Compressed";
    else if (comp_format == xex_opt::XexDataFormat::DeltaCompressed)
      format = "Delta Compressed";
    else if (comp_format == xex_opt::XexDataFormat::Raw)
      format = "Not Compressed";

    dbgmsg("[+] %s\n", format);
    dbgmsg("[+] %s\n", (enc_flag != 0) ? "Encrypted" : "Not Encrypted");
  }

  // Setup session key
  if (enc_flag)
  {
    dbgmsg("[+] Attempting decrypt with %s key...\n", key_names[key_index]);
    std::copy_n(security_info_.ImageInfo.ImageKey, 0x10, session_key_);
    EXCRYPT_AES_STATE aes_state;
    ExCryptAesKey(&aes_state, key_bytes[key_index]);
    ExCryptAesEcb(&aes_state, session_key_, session_key_, false);
  }

  bool result = false;
  if (comp_format == xex_opt::XexDataFormat::None)
    result = read_basefile_raw(file, enc_flag);
  else if (comp_format == xex_opt::XexDataFormat::Raw)
    result = read_basefile_uncompressed(file, enc_flag);
  else if (comp_format == xex_opt::XexDataFormat::Compressed)
    result = read_basefile_compressed(file, enc_flag);
  else if (comp_format == xex_opt::XexDataFormat::DeltaCompressed)
    return true; // TODO: any way to validate this?
  else
  {
    load_error_ = uint32_t(XEXLoadError::InvalidCompression);
    dbgmsg("[!] Error: XEX uses invalid compression format %hd!\n", (uint16_t)comp_format);
    result = false;
  }

  // if reading was "successful", try validating the basefile
#ifndef IDALDR
  if (result)
    if (basefile_verify())
      return true;
  // if basefile_verify failed (wrong hash, maybe XEX was modded), fall back to below:
#endif

  if (result)
  {
    if (!basefile_is_valid())
    {
      load_error_ = uint32_t(XEXLoadError::InvalidBaseFile);
      return false;
    }
    return true;
  }

  return result;
}

bool XEXFile::basefile_verify()
{
  // Try checking the image page hashes, hash = SHA1(page, page_descriptor)
  // Page descriptors contain the size of the current page, and the hash of the next page
  // (ImageHash inside HvImageInfo contains the first pages hash)
  valid_image_hash_ = !has_secinfo_;

  // XEX2D ImageHash field is never set, can't check it sadly..
  if (xex_header_.Magic == MAGIC_XEX2D)
    return valid_image_hash_ = true;

#ifdef IDALDR
  valid_image_hash_ = true;
#else
  if (has_secinfo_)
  {
    auto page_size = base_address() < 0x90000000 ? 64 * 1024 : 4 * 1024;

    uint8_t hash[20];
    uint8_t expected_hash[20];
    std::copy_n(security_info_.ImageInfo.ImageHash, 20, expected_hash);

    auto* data = pe_data();
    xex::HvPageInfo tmp_page;
    for (const auto& page : page_descriptors_)
    {
      int size = page_size * page.Size;

      // we byteswapped the descriptor when we read it in, so swap it back
      tmp_page = page;
      tmp_page.SizeInfo = xe::byte_swap(tmp_page.SizeInfo);

      ExCryptSha(data, size, (const uint8_t*)&tmp_page, sizeof(xex::HvPageInfo), 0, 0, hash, 20);
      valid_image_hash_ = ExCryptMemDiff(hash, expected_hash, 20) == 0;
      if (!valid_image_hash_)
        break;

      // descriptor contains the hash of the next page
      std::copy_n(tmp_page.DataDigest, 20, expected_hash);
      data += size;
    }
  }
#endif

  return valid_image_hash_;
}

const char* XEXFile::sign_key_name()
{
  if (signkey_index_ < 0 || signkey_index_ >= num_pubkeys)
    return "unknown";
  return pubkey_names[signkey_index_];
}

// Shim function to allow using vprintf cstdio function
int stdio_msg(const char* format, ...)
{
  if (!xex_log_verbose)
    return 0;

  va_list argp;
  va_start(argp, format);

  int retval = vprintf(format, argp);

  va_end(argp);

  return retval;
}

#ifdef IDALDR
// Shim function to allow using IDA's qlread function
size_t idaread(void* buffer, size_t element_size, size_t element_count, void* file)
{
  return qlread((linput_t*)file, buffer, element_size * element_count);
}

void XEXFile::use_ida_io()
{
  read = idaread;
  seek = (seek_fn)qlseek;
  tell = (tell_fn)qltell;
  dbgmsg = msg;
}
#endif

```

`formats/xex.hpp`:

```hpp
#pragma once
#include <cstdint>
#include <vector>
#include <algorithm>
#include <map>
#include <string>

#include "xex_optheaders.hpp"
#include "pe_structs.hpp"

// XEX header magic values
#define MAGIC_XEX0 0x58455830  // 'XEX0'
#define MAGIC_XEX3F 0x5845583F // 'XEX?'
#define MAGIC_XEX2D 0x5845582D // 'XEX-'
#define MAGIC_XEX25 0x58455825 // 'XEX%'
#define MAGIC_XEX1 0x58455831  // 'XEX1'
#define MAGIC_XEX2 0x58455832  // 'XEX2'

// Basefile magic values
#define MAGIC_XUIZ 0x5A495558  // 'ZIUX'

// Function pointer types, these let us support both IDA's IO functions & regular C's IO
typedef size_t(*read_fn)(void* buffer, size_t element_size, size_t element_count, void* file);
typedef int(*seek_fn)(void* file, long long offset, int origin);
typedef long long(*tell_fn)(void* file);
typedef int(*dbgmsg_fn)(const char* format, ...);
int stdio_msg(const char* format, ...); // xex2.cpp

struct XEXFunction
{
  uint32_t ThunkAddr = 0;
  uint32_t FuncAddr = 0;
};

enum class XEXLoadError
{
  Success,
  Unfinished,
  InvalidMagic,
  InvalidCompression,
  InvalidBaseFile,
  MissingDataDescriptor,
  AllocFailed,
  BadBlockHash,
  BadBlockSize,
  PEMissingMZ,
  PEMissingNTHeaders,
  Count
};

class XEXFile
{
  // IO function pointers
  read_fn read = nullptr;
  seek_fn seek = nullptr;
  tell_fn tell = nullptr;
  dbgmsg_fn dbgmsg = nullptr;

  uint32_t data_length_ = 0; // length of file data (filesize - headersize)

  xex::XexHeader xex_header_ = {};
  std::map<uint32_t, uint32_t> directory_entries_;
  xex2::SecurityInfo security_info_ = {};
  std::vector<xex::HvPageInfo> page_descriptors_;

  bool has_secinfo_ = false;

  int signkey_index_ = -1;
  bool valid_signature_ = false;
  bool valid_header_hash_ = false;
  bool valid_image_hash_ = false;
  bool valid_imports_hash_ = false;

  int key_index_ = -1;
  uint8_t session_key_[0x10];

  std::vector<uint8_t> xex_headers_;
  std::vector<uint8_t> pe_data_;

  // Values of various optional headers
  xe::be<uint32_t> opt_base_address_ = 0;
  xe::be<uint32_t> entry_point_ = 0;
  xex_opt::XexFileDataDescriptor* data_descriptor_ = nullptr;
  xex_opt::XexPrivileges privileges_ = {};
  xex_opt::XexPrivileges32 privileges32_ = {};
  xex_opt::XexExecutionId* execution_id_ = nullptr;
  xex_opt::XexVitalStats* vital_stats_ = nullptr;
  xex_opt::XexTlsData* tls_data_ = nullptr;
  std::vector<xex_opt::XexImageLibraryVersion> libraries_; // Versions of libraries this was linked against
  std::string pe_module_name_ = "";

  // Imports & Exports
  std::map<std::string, std::map<uint32_t, XEXFunction>> imports_;
  std::map<uint32_t, XEXFunction> exports_;
  std::map<std::string, xex_opt::XexImportTable> import_tables_;
  std::string exports_libname_ = "";

  // Sections from XEX headers
  std::vector<IMAGE_SECTION_HEADER> xex_sections_;

  // Sections from PE headers (includes XEX sections above)
  std::vector<IMAGE_SECTION_HEADER> sections_;
  std::vector<IMAGE_DEBUG_DIRECTORY> debug_directories_;
  std::vector<std::vector<uint8_t>> codeview_data_;
  uint32_t tls_directory_va_ = 0;
  IMAGE_TLS_DIRECTORY32 tls_directory_{};
  std::vector<uint32_t> tls_callbacks_;

  int load_error_ = 0;

  // Note: "void* file" below is a pointer to a FILE object, not to raw file data!
  bool read_imports(void* file);
  bool read_exports(void* file);

  bool read_secinfo(void* file);
  uint32_t verify_secinfo(void* file);

  bool read_basefile(void* file, int key_index);
  bool read_basefile_raw(void* file, bool encrypted);
  bool read_basefile_uncompressed(void* file, bool encrypted);
  bool read_basefile_compressed(void* file, bool encrypted);

  bool basefile_verify();

  bool pe_load(const uint8_t* data);
  bool pe_load_imports(const uint8_t* data);
  bool pe_load_exports(const uint8_t* data);

public:
  XEXFile() { 
#ifndef IDALDR
#ifdef _MSC_VER
    read = (read_fn)fread; seek = (seek_fn)_fseeki64; tell = (tell_fn)_ftelli64; dbgmsg = stdio_msg;
#else
    read = (read_fn)fread; seek = (seek_fn)fseeko64; tell = (tell_fn)ftello64; dbgmsg = stdio_msg;
#endif
#endif
  }

  int load_error() { return load_error_; }

  // Sets our IO function pointers to use IDA's IO functions
  void use_ida_io();

  // Loads in the XEX - note that "file" should be a FILE object, not a pointer to raw data!
  bool load(void* file);

  const xex::XexHeader& header() { return xex_header_; }
  const xex2::SecurityInfo& security_info() { return security_info_; }
  const std::vector<xex::HvPageInfo>& page_descriptors() { return page_descriptors_; }

  const uint8_t* xex_headers() { return xex_headers_.data(); }
  const uint8_t* pe_data() { return pe_data_.data(); }

  uint32_t pe_rva_to_offset(uint32_t rva);

  uint32_t xex_va_to_offset(uint32_t va);
  uint32_t xex_offset_to_va(uint32_t offset);

  // Length of the pe_data member, not the same as image_size!
  size_t pe_data_length() { return pe_data_.size(); }

  bool basefile_is_pe() {
    return pe_data_length() > 4 && *(uint16_t*)pe_data() == EXE_MZ_SIGNATURE;
  }

  bool basefile_is_xuiz() {
    return pe_data_length() > 4 && *(uint32_t*)pe_data() == MAGIC_XUIZ;
  }

  bool basefile_is_valid() {
    return basefile_is_pe() || basefile_is_xuiz();
  }

  const std::vector<IMAGE_SECTION_HEADER>& sections() { return sections_; }
  const std::vector<IMAGE_SECTION_HEADER>& xex_sections() { return xex_sections_; }

  const std::map<std::string, std::map<uint32_t, XEXFunction>>& imports() { return imports_; }
  const std::map<uint32_t, XEXFunction>& exports() { return exports_; }

  const std::map<std::string, xex_opt::XexImportTable>& import_tables() { return import_tables_; }
  const std::string& exports_libname() { return exports_libname_; }

  bool has_header(uint32_t id);

  // Returns value of an optional header, if exists
  uint32_t opt_header(uint32_t id);

  // Returns pointer to an optional headers value, if exists
  void* opt_header_ptr(uint32_t id);

  template<typename T>
  T* opt_header_ptr(uint32_t id) {
    return (T*)opt_header_ptr(id);
  }

  const char* sign_key_name();
  uint32_t sign_key_index() { return signkey_index_; }
  bool valid_signature() { return valid_signature_; }
  bool valid_header_hash() { return valid_header_hash_; }
  bool valid_image_hash() { return valid_image_hash_; }
  bool valid_imports_hash() { return valid_imports_hash_; }

  uint32_t encryption_key_index() { return key_index_; }
  uint8_t* session_key() { return session_key_; }

  bool is_encrypted() { return data_descriptor_->Flags != 0; }
  bool is_compressed() {
    return (data_descriptor_->DataFormat() == xex_opt::XexDataFormat::Compressed || 
      data_descriptor_->DataFormat() == xex_opt::XexDataFormat::DeltaCompressed);
  }

  // Optional headers
  uint32_t image_size() {
    return std::max(data_length_, (uint32_t)security_info_.ImageSize);
  }

  uint32_t base_address() { return opt_base_address_ ? opt_base_address_ : security_info_.ImageInfo.LoadAddress; }
  uint32_t opt_base_address() { return opt_base_address_; }
  uint32_t entry_point() { return entry_point_; }

  const std::string& pe_module_name() { return pe_module_name_; }
  const xex_opt::XexVitalStats* vital_stats() { return vital_stats_; }
  const xex_opt::XexFileDataDescriptor* data_descriptor() { return data_descriptor_; }

  const uint8_t* codeview_data(int idx, size_t* size = nullptr) {
    if (codeview_data_.size() > idx)
    {
      if (size)
        *size = codeview_data_[idx].size();
      return codeview_data_[idx].data();
    }
    return nullptr;
  }

  uint32_t tls_directory_va() { return tls_directory_va_; }
  IMAGE_TLS_DIRECTORY32 tls_directory() { return tls_directory_; }
  const std::vector<uint32_t>& tls_callbacks() { return tls_callbacks_; }

  uint32_t min_kernel_version() {
    switch (xex_header_.Magic) {
      case MAGIC_XEX0:  return 1332;
      case MAGIC_XEX3F: return 1529;
      case MAGIC_XEX2D: return 1640;
      case MAGIC_XEX25: return 1746;
      case MAGIC_XEX1:  return 1838;
      case MAGIC_XEX2:  return 1861;
    }
    return 0;
  }
};

```

`formats/xex_headerids.hpp`:

```hpp
#pragma once

// XEX header types
#define XEX_HEADER_STRUCT(key, struct)    (((key) << 8) | (sizeof (struct) >> 2))
#define XEX_HEADER_FIXED_SIZE(key, size)  (((key) << 8) | ((size) >> 2))
#define XEX_HEADER_ULONG(key)             (((key) << 8) | 1)
#define XEX_HEADER_FLAG(key)              ((key) << 8)
#define XEX_HEADER_SIZEDSTRUCT(key)       (((key) << 8) | 0xFF)
#define XEX_HEADER_STRING(key)            XEX_HEADER_SIZEDSTRUCT(key)

// XEX header IDs (todo: tidy up, add missing IDs?)
#define XEX_HEADER_SECTION_TABLE_BETA     XEX_HEADER_SIZEDSTRUCT (0x0001)
#define XEX_HEADER_SECTION_TABLE          XEX_HEADER_SIZEDSTRUCT (0x0002)
#define XEX_FILE_DATA_DESCRIPTOR_HEADER   XEX_HEADER_SIZEDSTRUCT (0x0003)
#define XEX_PATCH_FILE_BASE_REFERENCE     XEX_HEADER_FIXED_SIZE  (0x0004, 20)
#define XEX_HEADER_DELTA_PATCH_DESCRIPTOR XEX_HEADER_SIZEDSTRUCT (0x0005)

#define XEX_HEADER_KEY_VAULT_PRIVS        XEX_HEADER_STRUCT      (0x0040, xex_opt::XexKeyVaultPrivileges)
#define XEX_HEADER_KEY_VAULT_PRIVS_ALT    XEX_HEADER_SIZEDSTRUCT (0x0040) // alternate keyvault privs header ID? (source: ???)
#define XEX_HEADER_TIME_RANGE             XEX_HEADER_STRUCT      (0x0041, xex_opt::XexSystemTimeRange)
#define XEX_HEADER_TIME_RANGE_ALT         XEX_HEADER_SIZEDSTRUCT (0x0041) // alternate time range header ID?? (source: ???)
#define XEX_HEADER_CONSOLE_ID_TABLE       XEX_HEADER_SIZEDSTRUCT (0x0042) // blocked console ID list?
#define XEX_HEADER_DISC_PROFILE_ID        XEX_HEADER_FIXED_SIZE  (0x0043, 16)

#define XEX_HEADER_BOUND_PATH             XEX_HEADER_STRING      (0x0080)
#define XEX_HEADER_PE_EXPORTS_BETA        XEX_HEADER_STRUCT      (0x0081, IMAGE_DATA_DIRECTORY) // unsure! may be PE exports header in some pre-XEX2, can't remember which
#define XEX_HEADER_DEVICE_ID              XEX_HEADER_FIXED_SIZE  (0x0081, 20)

#define XEX_HEADER_EXECUTION_ID_BETA3F    XEX_HEADER_STRUCT      (0x0100, xex_opt::xex3f::XexExecutionId)

#define XEX_HEADER_ORIGINAL_BASE_ADDRESS  XEX_HEADER_ULONG       (0x0100)
#define XEX_HEADER_ENTRY_POINT            XEX_HEADER_FLAG        (0x0101)
#define XEX_HEADER_PE_BASE                XEX_HEADER_ULONG       (0x0102)
#define XEX_HEADER_IMPORTS_BETA           XEX_HEADER_SIZEDSTRUCT (0x0102) // XEX25
#define XEX_HEADER_IMPORTS                XEX_HEADER_SIZEDSTRUCT (0x0103)
#define XEX_HEADER_STACK_SIZE_BETA        XEX_HEADER_FLAG        (0x0104) // XEX25
#define XEX_HEADER_EXPORTS_XEX1           XEX_HEADER_FLAG        (0x0104) // XEX1
#define XEX_HEADER_TLS_DATA_BETA          XEX_HEADER_STRUCT      (0x0105, xex_opt::XexTlsData) // XEX25

#define XEX_HEADER_VITAL_STATS            XEX_HEADER_STRUCT      (0x0180, xex_opt::XexVitalStats)
#define XEX_HEADER_CALLCAP_IMPORTS        XEX_HEADER_STRUCT      (0x0181, xex_opt::XexCallcapImports)
#define XEX_HEADER_FASTCAP_ENABLED        XEX_HEADER_FLAG        (0x0182)
#define XEX_HEADER_PE_MODULE_NAME         XEX_HEADER_STRING      (0x0183)

#define XEX_HEADER_BUILD_VERSIONS         XEX_HEADER_SIZEDSTRUCT (0x0200)
#define XEX_HEADER_BUILD_VERSIONS_BETA    XEX_HEADER_SIZEDSTRUCT (0x0201) // XEX25

#define XEX_HEADER_TLS_DATA               XEX_HEADER_STRUCT      (0x0201, xex_opt::XexTlsData)
#define XEX_HEADER_STACK_SIZE             XEX_HEADER_FLAG        (0x0202)
#define XEX_HEADER_FSCACHE_SIZE           XEX_HEADER_ULONG       (0x0203)
#define XEX_HEADER_XAPI_HEAP_SIZE         XEX_HEADER_ULONG       (0x0204)

#define XEX_HEADER_PAGE_HEAP_SIZE_FLAGS   XEX_HEADER_STRUCT      (0x0280, xex_opt::XexPageHeapOptions)

#define XEX_HEADER_PRIVILEGES             XEX_HEADER_FLAG        (0x0300)
#define XEX_HEADER_PRIVILEGES_32          XEX_HEADER_FLAG        (0x0301) // privilege IDs 32 onward
#define XEX_HEADER_PRIVILEGES_64          XEX_HEADER_FLAG        (0x0302) // privilege IDs 64 onward

#define XEX_HEADER_EXECUTION_ID           XEX_HEADER_STRUCT      (0x0400, xex_opt::XexExecutionId)
#define XEX_HEADER_EXECUTION_ID_BETA      XEX_HEADER_STRUCT      (0x0400, xex_opt::xex25::XexExecutionId) // XEX25
#define XEX_HEADER_SERVICE_ID_LIST        XEX_HEADER_SIZEDSTRUCT (0x0401)
#define XEX_HEADER_WORKSPACE_SIZE         XEX_HEADER_ULONG       (0x0402)
#define XEX_HEADER_GAME_RATINGS           XEX_HEADER_FIXED_SIZE  (0x0403, 64)
#define XEX_HEADER_LAN_KEY                XEX_HEADER_FIXED_SIZE  (0x0404, 16)
#define XEX_HEADER_MSLOGO                 XEX_HEADER_SIZEDSTRUCT (0x0405)
#define XEX_HEADER_MULTIDISK_MEDIA_IDS    XEX_HEADER_SIZEDSTRUCT (0x0406)
#define XEX_HEADER_ALTERNATE_TITLE_IDS    XEX_HEADER_SIZEDSTRUCT (0x0407)
#define XEX_HEADER_ADDITIONAL_TITLE_MEM   XEX_HEADER_ULONG       (0x0408)

#define XEX_HEADER_PE_IMPORTS             XEX_HEADER_STRUCT      (0xE103, IMAGE_DATA_DIRECTORY) // unsure if this is correct struct!
#define XEX_HEADER_PE_EXPORTS             XEX_HEADER_STRUCT      (0xE104, IMAGE_DATA_DIRECTORY)
#define XEX_HEADER_USERMODE_IMPORTS       XEX_HEADER_SIZEDSTRUCT (0xE105)

```

`formats/xex_keys.hpp`:

```hpp
#pragma once

// Various encryption keys used to decrypt XEX image key
// There's no indication inside the XEX which key is used though :(
// Only way to know is to try decrypting and check if the resulting data is valid
const uint8_t retail_key[16] = {
  0x20, 0xB1, 0x85, 0xA5, 0x9D, 0x28, 0xFD, 0xC3,
  0x40, 0x58, 0x3F, 0xBB, 0x08, 0x96, 0xBF, 0x91
};
const uint8_t devkit_key[16] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// unsure if any of the xex1 keys get used, we'll still try them as last resort anyway
const uint8_t retail_key_xex1[16] = {
  0xA2, 0x6C, 0x10, 0xF7, 0x1F, 0xD9, 0x35, 0xE9,
  0x8B, 0x99, 0x92, 0x2C, 0xE9, 0x32, 0x15, 0x72
};
const uint8_t devkit_key_xex1[16] = {
  0xA8, 0xB0, 0x05, 0x12, 0xED, 0xE3, 0x63, 0x8D,
  0xC6, 0x58, 0xB3, 0x10, 0x1F, 0x9F, 0x50, 0xD1
};

const int num_enckeys = 4;
const uint8_t* key_bytes[num_enckeys] = {
  retail_key,
  devkit_key,
  retail_key_xex1,
  devkit_key_xex1
};
const char* key_names[num_enckeys] = {
  "retail",
  "devkit",
  "retail-XEX1",
  "devkit-XEX1"
};

const uint8_t pirs_retail_public[] = {
    0x00, 0x00, 0x00, 0x20, // cqw
    0x00, 0x00, 0x00, 0x03, // dwPubExp
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // qwReserved
    // aqwM
    0xE6, 0x3B, 0x32, 0xB2, 0x8D, 0x9E, 0x9E, 0xE7, 0x9D, 0xFC, 0x5C, 0x72, 0x41, 0x94, 0x58, 0x47,
    0xDE, 0x0D, 0x18, 0x40, 0x72, 0xD6, 0xE3, 0x46, 0x8E, 0xBA, 0x8E, 0xBC, 0x1A, 0x90, 0xAC, 0x20,
    0xBA, 0x03, 0x85, 0xB5, 0x1A, 0x3E, 0x25, 0xF9, 0xA6, 0x58, 0xEB, 0xB6, 0xA3, 0xC4, 0xA3, 0xEE,
    0xB2, 0xB0, 0xAE, 0x97, 0x69, 0xEB, 0xFE, 0x71, 0xFC, 0x02, 0xAB, 0x77, 0xBA, 0xC8, 0xE6, 0x74,
    0xE6, 0x7C, 0x63, 0x0E, 0xAF, 0x4C, 0xF7, 0xE7, 0x11, 0x4A, 0x80, 0x24, 0x72, 0x05, 0x7A, 0x63,
    0xD0, 0xF8, 0x91, 0x02, 0xA6, 0xE7, 0x7D, 0x77, 0xC5, 0xA7, 0x9B, 0x08, 0x11, 0x2E, 0xA0, 0x64,
    0x45, 0x60, 0x46, 0xBC, 0x36, 0xE1, 0x17, 0x71, 0xBE, 0x66, 0x49, 0x2F, 0xAE, 0x20, 0xA4, 0x76,
    0x9C, 0x27, 0x51, 0xCF, 0x4B, 0x34, 0x7A, 0x35, 0xBC, 0xA4, 0xAA, 0x1C, 0x47, 0x4B, 0xF4, 0x97,
    0x22, 0x4E, 0x13, 0x24, 0xD3, 0xC1, 0x57, 0xDF, 0x4D, 0x84, 0xB9, 0x18, 0x97, 0x99, 0xAC, 0x00,
    0xB3, 0x3D, 0x03, 0x25, 0x60, 0xC8, 0x7A, 0x59, 0xFE, 0x48, 0xFF, 0x28, 0x3D, 0x10, 0xBB, 0x9E,
    0x09, 0x06, 0x2A, 0x61, 0x20, 0x2C, 0xF8, 0x72, 0xEB, 0x87, 0xE6, 0xD1, 0xFB, 0xB3, 0x66, 0xFC,
    0x4A, 0x02, 0xAE, 0xD4, 0xD8, 0x37, 0xCF, 0xA6, 0x32, 0x25, 0x79, 0x36, 0x0E, 0xF4, 0xED, 0x19,
    0xA2, 0x10, 0x27, 0x96, 0x2F, 0x9F, 0xA9, 0x3D, 0xA4, 0x37, 0x30, 0x11, 0x51, 0x83, 0xBD, 0xF7,
    0xC7, 0xE5, 0xCE, 0xAA, 0xEC, 0xDE, 0x48, 0xA0, 0x84, 0xF7, 0xB0, 0xF6, 0x4B, 0x8E, 0xF0, 0x89,
    0xBD, 0x47, 0x7C, 0x90, 0xDD, 0x88, 0x12, 0x17, 0x40, 0xD2, 0x4E, 0xA6, 0xC6, 0x11, 0x04, 0x1B,
    0x57, 0xA8, 0x68, 0xB4, 0x61, 0xF4, 0x1B, 0xC6, 0x8B, 0xE8, 0xD9, 0x20, 0xF2, 0x05, 0xE0, 0x70
};

const uint8_t live_retail_public[] = {
    0x00, 0x00, 0x00, 0x20, // cqw
    0x00, 0x01, 0x00, 0x01, // dwPubExp
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // qwReserved
    // aqwM
    0xF2, 0xE5, 0x3E, 0x3F, 0x03, 0x75, 0xC2, 0xB3, 0x20, 0xB6, 0xAB, 0x41, 0x90, 0x78, 0x9D, 0xA1,
    0x04, 0x4E, 0x58, 0x6D, 0xFC, 0xFF, 0x16, 0x1C, 0x9E, 0x01, 0x1D, 0xDA, 0x5D, 0x16, 0x7E, 0x54,
    0xCB, 0x2A, 0xF2, 0xA7, 0x02, 0x83, 0xE8, 0xAD, 0xCD, 0xA1, 0x00, 0xF8, 0x9C, 0xC4, 0xAD, 0x2D,
    0x4C, 0xAF, 0x2E, 0x18, 0x01, 0x9F, 0x38, 0xB1, 0x3D, 0xFA, 0xC9, 0xA6, 0xCF, 0x2A, 0xA8, 0x4E,
    0xE0, 0x7E, 0x17, 0x23, 0x61, 0xFB, 0xFD, 0x36, 0x2E, 0x22, 0x17, 0xFA, 0x75, 0x71, 0xA0, 0x74,
    0xF9, 0xF7, 0x10, 0x85, 0x7E, 0xEC, 0x5C, 0x35, 0xF5, 0xB0, 0xAC, 0xAB, 0xC1, 0x0B, 0x09, 0x1D,
    0x9A, 0x7A, 0xBE, 0xB9, 0xB7, 0x91, 0x78, 0x0A, 0x5D, 0xCA, 0xCB, 0xF9, 0x98, 0x4B, 0x68, 0x15,
    0x75, 0x77, 0x1C, 0xB0, 0xCC, 0xFA, 0x04, 0xA3, 0xEC, 0x08, 0xDD, 0x68, 0x5F, 0xEA, 0x69, 0xAF,
    0x9D, 0x98, 0xB9, 0xBF, 0xF3, 0x72, 0xFC, 0xC0, 0x1E, 0x5B, 0x15, 0x5B, 0x49, 0xAA, 0x6A, 0xDC,
    0x55, 0x35, 0x39, 0x3F, 0x8C, 0xDC, 0xC7, 0x57, 0xA7, 0x75, 0x21, 0x41, 0x08, 0xBB, 0x9B, 0x74,
    0x6C, 0xFB, 0xF6, 0x89, 0xC4, 0xB3, 0xEB, 0xD0, 0x7E, 0xAF, 0xA7, 0xA7, 0x27, 0x25, 0x41, 0x70,
    0x59, 0xAC, 0x96, 0x18, 0x16, 0x0E, 0xE9, 0x6B, 0x11, 0xC7, 0xEE, 0x35, 0x52, 0x72, 0xA4, 0xC2,
    0xB3, 0x1E, 0x20, 0x05, 0xC5, 0xC0, 0x9C, 0x5D, 0xC7, 0xCF, 0x5B, 0x81, 0xBE, 0xB2, 0xB3, 0xAF,
    0x83, 0x85, 0xDE, 0x73, 0x6E, 0x7A, 0x0E, 0xAC, 0x59, 0x0D, 0x46, 0x73, 0xFB, 0x7B, 0x78, 0x88,
    0x29, 0x87, 0x5A, 0xE6, 0x7B, 0x2E, 0x7D, 0x86, 0x82, 0x55, 0xBE, 0x12, 0x12, 0xD9, 0x87, 0xB3,
    0xBD, 0x3D, 0x41, 0xC8, 0xD0, 0x00, 0xF5, 0x7D, 0xC9, 0x7B, 0x51, 0x8E, 0xC7, 0x35, 0xDC, 0xEF
};

const uint8_t pirs_devkit_public[] = {
    0x00, 0x00, 0x00, 0x20, // cqw
    0x00, 0x00, 0x00, 0x03, // dwPubExp
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // qwReserved
    // aqwM
    0xC9, 0x1C, 0x35, 0x77, 0xC8, 0xBF, 0xA0, 0x6B, 0x64, 0x2F, 0x4E, 0x6C, 0x73, 0x99, 0xAC, 0xE5,
    0x84, 0xE7, 0xAB, 0x2E, 0xE4, 0xDB, 0xAE, 0x1E, 0x3E, 0x06, 0x70, 0x62, 0x4A, 0xA2, 0xAD, 0x99,
    0xE1, 0x76, 0x70, 0x61, 0xE6, 0xBE, 0x93, 0x27, 0x6D, 0x5D, 0x97, 0xFD, 0x73, 0x30, 0x76, 0x3A,
    0xB8, 0x70, 0x5C, 0xC0, 0xBE, 0x8F, 0x1B, 0x3D, 0x4C, 0x5D, 0x85, 0x65, 0x98, 0x8C, 0x4C, 0x6B,
    0xCC, 0xBE, 0xD0, 0xC5, 0xA7, 0x43, 0xAA, 0x6C, 0x56, 0x91, 0x0F, 0xF8, 0xE8, 0xBD, 0x90, 0x4D,
    0xB8, 0xD9, 0xA3, 0xF1, 0x3B, 0x6E, 0x71, 0xDB, 0xB0, 0xE0, 0xF5, 0x1A, 0x8E, 0x80, 0x39, 0xC2,
    0x4E, 0x3A, 0x81, 0x42, 0xC5, 0x6E, 0xB9, 0x49, 0x44, 0xF4, 0x8D, 0xC5, 0x84, 0x51, 0xC8, 0x1B,
    0x7D, 0xBC, 0x45, 0x59, 0xD0, 0xE3, 0xF2, 0x97, 0xEF, 0xA0, 0x39, 0xEA, 0x1C, 0xF9, 0x48, 0x66,
    0x66, 0x4E, 0x8B, 0xD0, 0x22, 0xAB, 0xDB, 0x90, 0x1E, 0xBC, 0xD8, 0x3D, 0x91, 0xA7, 0x89, 0x7C,
    0x72, 0x07, 0xDA, 0x63, 0xAA, 0xF3, 0x3E, 0xED, 0xD5, 0x87, 0x66, 0x7B, 0xF2, 0x28, 0x9C, 0xB3,
    0x40, 0x54, 0x22, 0x65, 0x44, 0x10, 0x2A, 0xD2, 0xB0, 0x48, 0x4C, 0xF9, 0x9E, 0x6F, 0xA4, 0x76,
    0x9F, 0x18, 0xD0, 0x4D, 0xAD, 0xA5, 0x6E, 0xFC, 0x9E, 0xC2, 0xA4, 0xCF, 0xB3, 0xEC, 0xC8, 0x05,
    0xED, 0x8C, 0x08, 0xED, 0x25, 0x13, 0xCC, 0xBB, 0x16, 0x60, 0x1A, 0x8A, 0xC7, 0x4B, 0x68, 0x93,
    0x7F, 0x95, 0x27, 0x1A, 0xCC, 0x7B, 0xAC, 0x29, 0xD4, 0xB7, 0x41, 0x9B, 0x0A, 0x99, 0x60, 0x02,
    0xA6, 0xE9, 0xA7, 0xC2, 0x78, 0xF5, 0xC0, 0xB8, 0xBB, 0x9D, 0x88, 0x16, 0x71, 0x64, 0x81, 0x07,
    0x2C, 0x5B, 0x33, 0xE5, 0x1C, 0xFA, 0x00, 0x02, 0xD7, 0x49, 0x2F, 0x13, 0xB1, 0xC1, 0x7F, 0xBF
};

const uint8_t live_devkit_public[] = {
    0x00, 0x00, 0x00, 0x20, // cqw
    0x00, 0x00, 0x00, 0x03, // dwPubExp
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // qwReserved
    // aqwM
    0x92, 0x12, 0xCD, 0x87, 0x27, 0xF1, 0x29, 0xA5, 0xB3, 0xBA, 0xD1, 0xDD, 0x2F, 0x59, 0xA8, 0x3F,
    0x65, 0x30, 0x62, 0xB2, 0xD1, 0xB4, 0x2D, 0x7E, 0x2F, 0x5B, 0x2F, 0x7F, 0x63, 0x89, 0xA9, 0x94,
    0xC1, 0x0A, 0x46, 0x16, 0x66, 0x54, 0x43, 0xAC, 0x78, 0x07, 0x38, 0xB2, 0xF9, 0xEB, 0x64, 0x18,
    0xC4, 0x26, 0xC8, 0x39, 0x61, 0x3C, 0xEC, 0xE5, 0x62, 0xDD, 0x92, 0x59, 0x42, 0x6D, 0xE9, 0x3E,
    0xCA, 0xAE, 0x81, 0x04, 0x19, 0x29, 0xF0, 0x04, 0x6D, 0xC5, 0x86, 0xAE, 0x48, 0x4C, 0xF9, 0x19,
    0xFB, 0x8A, 0x31, 0x54, 0x32, 0xCC, 0x52, 0x88, 0x25, 0x9E, 0x98, 0x42, 0x43, 0x3C, 0xB2, 0x63,
    0x07, 0xCA, 0x71, 0xA3, 0x97, 0x3E, 0xD3, 0x8D, 0x4E, 0x44, 0xA9, 0x56, 0xA3, 0xD2, 0xFD, 0x40,
    0xB8, 0x1A, 0x5E, 0xEE, 0x23, 0x92, 0x7D, 0xB4, 0xA8, 0xF7, 0x04, 0xC7, 0x02, 0xF9, 0xF3, 0x95,
    0x77, 0x82, 0xE2, 0x5C, 0x30, 0x90, 0x24, 0xCE, 0x7D, 0x05, 0x19, 0x4F, 0xBE, 0x39, 0x99, 0x77,
    0x82, 0xEF, 0x91, 0x74, 0x68, 0xB0, 0x55, 0x5D, 0xA7, 0x4D, 0xFA, 0x7B, 0x91, 0x11, 0xF5, 0xA9,
    0xDD, 0xA1, 0x3F, 0x87, 0x21, 0x76, 0xB0, 0xB1, 0x7D, 0xD6, 0x9D, 0x90, 0xBD, 0xDC, 0xD1, 0x56,
    0x5C, 0xA7, 0xEE, 0x6F, 0x80, 0xDA, 0x78, 0x33, 0x63, 0xD2, 0x61, 0x5B, 0x31, 0xBA, 0xDD, 0xB4,
    0x8E, 0xFC, 0x76, 0x2A, 0x97, 0xC5, 0xE8, 0x00, 0x6E, 0x3C, 0x7A, 0xFF, 0x18, 0xB3, 0xAA, 0xFE,
    0x78, 0xE8, 0x98, 0xA8, 0xEF, 0xA8, 0x63, 0x6E, 0x96, 0x02, 0xF7, 0x82, 0xCC, 0x49, 0xBC, 0xF7,
    0x77, 0x58, 0xD6, 0x84, 0x4E, 0x58, 0x88, 0xC6, 0x1F, 0x3F, 0x35, 0xD5, 0x30, 0xA1, 0x4A, 0xC0,
    0xDD, 0xA0, 0xF6, 0xE6, 0x06, 0x8E, 0x1C, 0x84, 0xB5, 0xFF, 0x62, 0xEB, 0xEC, 0x7B, 0xC3, 0x3D
};

const int num_pubkeys = 4;
const uint8_t* pubkey_bytes[num_pubkeys] = {
  pirs_retail_public,
  pirs_devkit_public,
  live_retail_public,
  live_devkit_public
};
const char* pubkey_names[num_pubkeys] = {
  "retail",
  "devkit",
  "retail-LIVE",
  "devkit-LIVE"
};

const uint8_t pirs_devkit_private[] = {
    0x00, 0x00, 0x00, 0x20, // cqw
    0x00, 0x00, 0x00, 0x03, // dwPubExp
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // qwReserved
    // aqwM
    0xC9, 0x1C, 0x35, 0x77, 0xC8, 0xBF, 0xA0, 0x6B, 0x64, 0x2F, 0x4E, 0x6C, 0x73, 0x99, 0xAC, 0xE5,
    0x84, 0xE7, 0xAB, 0x2E, 0xE4, 0xDB, 0xAE, 0x1E, 0x3E, 0x06, 0x70, 0x62, 0x4A, 0xA2, 0xAD, 0x99,
    0xE1, 0x76, 0x70, 0x61, 0xE6, 0xBE, 0x93, 0x27, 0x6D, 0x5D, 0x97, 0xFD, 0x73, 0x30, 0x76, 0x3A,
    0xB8, 0x70, 0x5C, 0xC0, 0xBE, 0x8F, 0x1B, 0x3D, 0x4C, 0x5D, 0x85, 0x65, 0x98, 0x8C, 0x4C, 0x6B,
    0xCC, 0xBE, 0xD0, 0xC5, 0xA7, 0x43, 0xAA, 0x6C, 0x56, 0x91, 0x0F, 0xF8, 0xE8, 0xBD, 0x90, 0x4D,
    0xB8, 0xD9, 0xA3, 0xF1, 0x3B, 0x6E, 0x71, 0xDB, 0xB0, 0xE0, 0xF5, 0x1A, 0x8E, 0x80, 0x39, 0xC2,
    0x4E, 0x3A, 0x81, 0x42, 0xC5, 0x6E, 0xB9, 0x49, 0x44, 0xF4, 0x8D, 0xC5, 0x84, 0x51, 0xC8, 0x1B,
    0x7D, 0xBC, 0x45, 0x59, 0xD0, 0xE3, 0xF2, 0x97, 0xEF, 0xA0, 0x39, 0xEA, 0x1C, 0xF9, 0x48, 0x66,
    0x66, 0x4E, 0x8B, 0xD0, 0x22, 0xAB, 0xDB, 0x90, 0x1E, 0xBC, 0xD8, 0x3D, 0x91, 0xA7, 0x89, 0x7C,
    0x72, 0x07, 0xDA, 0x63, 0xAA, 0xF3, 0x3E, 0xED, 0xD5, 0x87, 0x66, 0x7B, 0xF2, 0x28, 0x9C, 0xB3,
    0x40, 0x54, 0x22, 0x65, 0x44, 0x10, 0x2A, 0xD2, 0xB0, 0x48, 0x4C, 0xF9, 0x9E, 0x6F, 0xA4, 0x76,
    0x9F, 0x18, 0xD0, 0x4D, 0xAD, 0xA5, 0x6E, 0xFC, 0x9E, 0xC2, 0xA4, 0xCF, 0xB3, 0xEC, 0xC8, 0x05,
    0xED, 0x8C, 0x08, 0xED, 0x25, 0x13, 0xCC, 0xBB, 0x16, 0x60, 0x1A, 0x8A, 0xC7, 0x4B, 0x68, 0x93,
    0x7F, 0x95, 0x27, 0x1A, 0xCC, 0x7B, 0xAC, 0x29, 0xD4, 0xB7, 0x41, 0x9B, 0x0A, 0x99, 0x60, 0x02,
    0xA6, 0xE9, 0xA7, 0xC2, 0x78, 0xF5, 0xC0, 0xB8, 0xBB, 0x9D, 0x88, 0x16, 0x71, 0x64, 0x81, 0x07,
    0x2C, 0x5B, 0x33, 0xE5, 0x1C, 0xFA, 0x00, 0x02, 0xD7, 0x49, 0x2F, 0x13, 0xB1, 0xC1, 0x7F, 0xBF,
    // aqwP
    0x4D, 0x4D, 0x16, 0x27, 0x77, 0x9E, 0x3C, 0x97, 0x2D, 0xBE, 0x03, 0x13, 0xCB, 0x82, 0x9E, 0x5D,
    0x9F, 0xA8, 0x1C, 0x79, 0x6E, 0x40, 0x9F, 0x29, 0x76, 0x46, 0xA9, 0xB4, 0xC9, 0xFA, 0x6F, 0xA4,
    0x5B, 0xCD, 0x1C, 0x49, 0x7B, 0x4E, 0xCC, 0xB3, 0xFF, 0xC8, 0x1F, 0x08, 0x03, 0x34, 0x2D, 0x90,
    0x7F, 0x39, 0x41, 0xA3, 0x47, 0x64, 0x95, 0xD1, 0x18, 0xB7, 0x7C, 0x8D, 0x52, 0x04, 0x0F, 0xDF,
    0xB4, 0x03, 0xB0, 0x24, 0x65, 0xFA, 0x7F, 0xF3, 0xEA, 0x48, 0xB3, 0xA5, 0xCB, 0x30, 0xE9, 0x9F,
    0x72, 0x73, 0xC4, 0x3A, 0x7A, 0xC8, 0xAA, 0x05, 0x48, 0x1D, 0xD1, 0x73, 0xEF, 0xFF, 0xF3, 0xE8,
    0xFD, 0x50, 0x4E, 0xC5, 0xE8, 0x6E, 0x74, 0x55, 0x08, 0x0B, 0xE2, 0xE8, 0x11, 0x0A, 0x4B, 0x01,
    0xE0, 0x64, 0xCE, 0x0D, 0x6C, 0x4B, 0x49, 0xA0, 0xF7, 0x5B, 0x98, 0x10, 0x62, 0x49, 0x5F, 0x19,
    // aqwQ
    0xEF, 0x3A, 0xAF, 0xB9, 0x5D, 0x35, 0xB1, 0x4D, 0xDB, 0x82, 0xE4, 0x77, 0x4D, 0xCA, 0x8A, 0x34,
    0x4B, 0x1D, 0xCF, 0xCF, 0x32, 0xCE, 0x0D, 0x9D, 0x50, 0x3A, 0xA0, 0x68, 0x23, 0xD8, 0x80, 0x72,
    0xE3, 0xCD, 0xB6, 0xB6, 0xE1, 0xD9, 0x2A, 0x26, 0xCC, 0x3C, 0xA7, 0x17, 0x9E, 0x05, 0xD4, 0xAA,
    0x6E, 0xD5, 0x61, 0x6A, 0x64, 0x68, 0x59, 0x80, 0xD2, 0x1C, 0xD0, 0x8C, 0xD8, 0xD4, 0x92, 0xBD,
    0x84, 0xAD, 0xE7, 0x54, 0x92, 0x13, 0x7A, 0x9E, 0x92, 0x8A, 0x8C, 0x6E, 0xF6, 0x5D, 0x29, 0xE4,
    0xB9, 0xEB, 0x51, 0x34, 0xB6, 0xE5, 0x0B, 0x67, 0x41, 0x43, 0x45, 0x45, 0xB8, 0x5E, 0x25, 0x73,
    0x6D, 0xF3, 0x11, 0x12, 0x79, 0xCB, 0xE6, 0x9F, 0x4F, 0xA1, 0x91, 0xCA, 0x3E, 0x9F, 0x2D, 0xDF,
    0x34, 0x2F, 0x23, 0x32, 0x86, 0xB4, 0x3E, 0x10, 0xDE, 0xCE, 0xBB, 0xD8, 0x86, 0x85, 0x0E, 0xF0,
    // aqwDP
    0xDE, 0x33, 0x64, 0x1A, 0x4F, 0xBE, 0xD3, 0x0F, 0x1E, 0x7E, 0xAC, 0xB7, 0xDD, 0x01, 0xBE, 0xE8,
    0xBF, 0xC5, 0x68, 0x50, 0xF4, 0x2B, 0x14, 0xC6, 0xA4, 0x2F, 0x1B, 0xCD, 0xDB, 0xFC, 0x4A, 0x6D,
    0x92, 0x88, 0xBD, 0x86, 0x52, 0x34, 0x88, 0x77, 0xFF, 0xDA, 0xBF, 0x5A, 0xAC, 0xCD, 0x73, 0xB5,
    0x54, 0xD0, 0xD6, 0x6C, 0xDA, 0x43, 0x0E, 0x8B, 0x65, 0xCF, 0xA8, 0x5E, 0x36, 0xAD, 0x5F, 0xEA,
    0xCD, 0x57, 0xCA, 0xC2, 0xEE, 0xA6, 0xFF, 0xF7, 0xF1, 0x85, 0xCD, 0x19, 0x32, 0x20, 0x9B, 0xBF,
    0x4C, 0x4D, 0x2D, 0x7C, 0x51, 0xDB, 0x1C, 0x03, 0xDA, 0xBE, 0x8B, 0xA2, 0x9F, 0xFF, 0xF7, 0xF0,
    0xFE, 0x35, 0x89, 0xD9, 0x45, 0x9E, 0xF8, 0x38, 0xB0, 0x07, 0xEC, 0x9A, 0xB6, 0x06, 0xDC, 0xAB,
    0xEA, 0xED, 0xDE, 0xB3, 0x9D, 0x87, 0x86, 0x6A, 0xA4, 0xE7, 0xBA, 0xB5, 0x96, 0xDB, 0x94, 0xBB,
    // aqwDQ
    0x4A, 0x27, 0x1F, 0xD0, 0xE8, 0xCE, 0x76, 0x33, 0x92, 0x57, 0x42, 0xFA, 0x33, 0xDC, 0x5C, 0x23,
    0xDC, 0xBE, 0x8A, 0x8A, 0x21, 0xDE, 0xB3, 0xBE, 0x35, 0x7C, 0x6A, 0xF0, 0x17, 0xE5, 0xAA, 0xF6,
    0xED, 0x33, 0xCF, 0x24, 0x96, 0x90, 0xC6, 0xC4, 0xDD, 0x7D, 0xC4, 0xBA, 0x69, 0x59, 0x38, 0x71,
    0x49, 0xE3, 0x96, 0x46, 0xED, 0x9A, 0xE6, 0x55, 0x36, 0xBD, 0xE0, 0x5D, 0xE5, 0xE3, 0x0C, 0x7E,
    0x03, 0x1E, 0x9A, 0x38, 0x61, 0x62, 0x51, 0xBF, 0xB7, 0x07, 0x08, 0x49, 0xF9, 0x93, 0x71, 0x43,
    0x26, 0x9C, 0xE0, 0xCD, 0xCF, 0x43, 0x5C, 0xEF, 0x2B, 0x82, 0x2E, 0x2E, 0x7A, 0xE9, 0x6E, 0x4D,
    0xF3, 0xF7, 0x60, 0xB6, 0xFB, 0xDD, 0x44, 0x6A, 0x8A, 0x6B, 0xB6, 0x86, 0xD4, 0x6A, 0x1E, 0x94,
    0x78, 0x1F, 0x6C, 0xCC, 0x59, 0xCD, 0x7E, 0xB5, 0x94, 0x89, 0xD2, 0x90, 0x59, 0xAE, 0x09, 0xF5,
    // aqwCR
    0xC9, 0xA2, 0xB3, 0xAE, 0xDE, 0x77, 0x71, 0xFA, 0x39, 0xF7, 0x89, 0x93, 0xBB, 0x6A, 0xA9, 0x3C,
    0x8D, 0x79, 0xE3, 0x3D, 0x35, 0x06, 0x0F, 0x76, 0x2D, 0xA5, 0x8B, 0xCC, 0x4D, 0xAF, 0xDF, 0xFC,
    0xD3, 0x03, 0xBB, 0xA4, 0xA0, 0x51, 0x80, 0x58, 0x3C, 0xCF, 0x62, 0xE3, 0x09, 0xBC, 0x63, 0x9E,
    0xB3, 0xEF, 0x29, 0x41, 0x55, 0x23, 0x0B, 0x2A, 0x2A, 0x31, 0xB8, 0xDA, 0xD6, 0x13, 0xE4, 0xBE,
    0xAB, 0xCA, 0x58, 0xBF, 0x24, 0xB5, 0x60, 0xD2, 0xB7, 0x9E, 0x00, 0x30, 0x15, 0xFD, 0xFA, 0x05,
    0xA7, 0x5C, 0x3B, 0x44, 0x78, 0xBA, 0x5B, 0x91, 0x2C, 0xB4, 0x16, 0x16, 0x3A, 0x6E, 0xBA, 0x40,
    0x15, 0xA2, 0xB3, 0x61, 0x05, 0xCB, 0xC6, 0xC0, 0x86, 0x92, 0xD9, 0x57, 0x34, 0x92, 0x15, 0x86,
    0x79, 0x21, 0xBB, 0x43, 0xE6, 0xFC, 0xA4, 0xC8, 0x75, 0x8D, 0x75, 0x1B, 0x93, 0x53, 0xDD, 0xF4
};

const uint8_t live_devkit_private[] = {
    0x00, 0x00, 0x00, 0x20, // cqw
    0x00, 0x00, 0x00, 0x03, // dwPubExp
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // qwReserved
    // aqwM
    0x92, 0x12, 0xCD, 0x87, 0x27, 0xF1, 0x29, 0xA5, 0xB3, 0xBA, 0xD1, 0xDD, 0x2F, 0x59, 0xA8, 0x3F,
    0x65, 0x30, 0x62, 0xB2, 0xD1, 0xB4, 0x2D, 0x7E, 0x2F, 0x5B, 0x2F, 0x7F, 0x63, 0x89, 0xA9, 0x94,
    0xC1, 0x0A, 0x46, 0x16, 0x66, 0x54, 0x43, 0xAC, 0x78, 0x07, 0x38, 0xB2, 0xF9, 0xEB, 0x64, 0x18,
    0xC4, 0x26, 0xC8, 0x39, 0x61, 0x3C, 0xEC, 0xE5, 0x62, 0xDD, 0x92, 0x59, 0x42, 0x6D, 0xE9, 0x3E,
    0xCA, 0xAE, 0x81, 0x04, 0x19, 0x29, 0xF0, 0x04, 0x6D, 0xC5, 0x86, 0xAE, 0x48, 0x4C, 0xF9, 0x19,
    0xFB, 0x8A, 0x31, 0x54, 0x32, 0xCC, 0x52, 0x88, 0x25, 0x9E, 0x98, 0x42, 0x43, 0x3C, 0xB2, 0x63,
    0x07, 0xCA, 0x71, 0xA3, 0x97, 0x3E, 0xD3, 0x8D, 0x4E, 0x44, 0xA9, 0x56, 0xA3, 0xD2, 0xFD, 0x40,
    0xB8, 0x1A, 0x5E, 0xEE, 0x23, 0x92, 0x7D, 0xB4, 0xA8, 0xF7, 0x04, 0xC7, 0x02, 0xF9, 0xF3, 0x95,
    0x77, 0x82, 0xE2, 0x5C, 0x30, 0x90, 0x24, 0xCE, 0x7D, 0x05, 0x19, 0x4F, 0xBE, 0x39, 0x99, 0x77,
    0x82, 0xEF, 0x91, 0x74, 0x68, 0xB0, 0x55, 0x5D, 0xA7, 0x4D, 0xFA, 0x7B, 0x91, 0x11, 0xF5, 0xA9,
    0xDD, 0xA1, 0x3F, 0x87, 0x21, 0x76, 0xB0, 0xB1, 0x7D, 0xD6, 0x9D, 0x90, 0xBD, 0xDC, 0xD1, 0x56,
    0x5C, 0xA7, 0xEE, 0x6F, 0x80, 0xDA, 0x78, 0x33, 0x63, 0xD2, 0x61, 0x5B, 0x31, 0xBA, 0xDD, 0xB4,
    0x8E, 0xFC, 0x76, 0x2A, 0x97, 0xC5, 0xE8, 0x00, 0x6E, 0x3C, 0x7A, 0xFF, 0x18, 0xB3, 0xAA, 0xFE,
    0x78, 0xE8, 0x98, 0xA8, 0xEF, 0xA8, 0x63, 0x6E, 0x96, 0x02, 0xF7, 0x82, 0xCC, 0x49, 0xBC, 0xF7,
    0x77, 0x58, 0xD6, 0x84, 0x4E, 0x58, 0x88, 0xC6, 0x1F, 0x3F, 0x35, 0xD5, 0x30, 0xA1, 0x4A, 0xC0,
    0xDD, 0xA0, 0xF6, 0xE6, 0x06, 0x8E, 0x1C, 0x84, 0xB5, 0xFF, 0x62, 0xEB, 0xEC, 0x7B, 0xC3, 0x3D,
    // aqwP
    0x5B, 0x0E, 0x3F, 0xDF, 0x19, 0x1B, 0xED, 0x7B, 0xAE, 0x7E, 0x04, 0x9B, 0x5A, 0x0B, 0xBA, 0xE2,
    0x03, 0xAC, 0x6E, 0x20, 0xDB, 0x8E, 0x4F, 0xE7, 0xBC, 0xEC, 0xDD, 0x18, 0x23, 0x54, 0x83, 0x49,
    0x47, 0xDF, 0x1E, 0xA7, 0x7D, 0x39, 0x2F, 0x3B, 0xA6, 0x51, 0x11, 0x6A, 0x2B, 0xBF, 0x84, 0xCA,
    0xCD, 0x0C, 0xF6, 0x1E, 0x2B, 0xCA, 0xF4, 0x2D, 0x26, 0x53, 0x0E, 0x45, 0x84, 0x5C, 0xA8, 0x6C,
    0x4F, 0x2F, 0x67, 0x9B, 0xB9, 0x01, 0x85, 0xB0, 0x77, 0x66, 0xFF, 0xCC, 0xEA, 0x1E, 0x9D, 0x83,
    0x0E, 0xFF, 0xA8, 0x1A, 0x07, 0x22, 0x9F, 0x27, 0x9E, 0x91, 0x81, 0xD2, 0x33, 0x06, 0x3A, 0x3D,
    0x76, 0x9A, 0x1B, 0xD3, 0x0D, 0xE0, 0x0F, 0x09, 0x4A, 0xFC, 0x54, 0x5F, 0x7C, 0x6C, 0x04, 0x17,
    0xA9, 0x9C, 0xBB, 0x79, 0x4E, 0x38, 0xA1, 0x9C, 0xEA, 0xB7, 0x17, 0x6D, 0x35, 0x20, 0xD7, 0xD6,
    // aqwQ
    0x8B, 0xEB, 0x8D, 0xED, 0x61, 0xB3, 0x4B, 0x5F, 0x50, 0x05, 0xC7, 0xA5, 0xB6, 0x4F, 0xF7, 0xCF,
    0x9E, 0xA6, 0xEA, 0xF0, 0xB7, 0x6D, 0x00, 0xAD, 0xBC, 0xFD, 0x3F, 0x19, 0xAE, 0xF2, 0xA8, 0xC5,
    0xFA, 0xCF, 0x3A, 0x18, 0x8D, 0x2F, 0xF1, 0xA9, 0xB4, 0xFD, 0xAB, 0xF2, 0x47, 0x04, 0xE0, 0x25,
    0x4A, 0x0D, 0x65, 0xB0, 0xA6, 0x9B, 0x0D, 0x9B, 0xFD, 0x17, 0xE6, 0xCE, 0x29, 0xAA, 0x2D, 0xC0,
    0xF8, 0xC7, 0xD7, 0xE9, 0x38, 0x87, 0xCC, 0xDF, 0x39, 0xEC, 0xC8, 0x8E, 0xE6, 0xCB, 0xBE, 0x4B,
    0x38, 0xD9, 0x06, 0xB6, 0xB2, 0x03, 0x4C, 0xF1, 0xC8, 0xFE, 0x5E, 0x51, 0xAC, 0x0D, 0xEE, 0x47,
    0xFB, 0x89, 0x26, 0xCD, 0xB0, 0xD2, 0x5E, 0xE7, 0x16, 0x9A, 0xEC, 0xFD, 0xCB, 0xAE, 0x23, 0xD2,
    0xF3, 0x50, 0xE1, 0x7B, 0x8E, 0xFE, 0x04, 0x4C, 0xC6, 0x80, 0x74, 0xFB, 0xB5, 0xC5, 0x4B, 0x8E,
    // aqwDP
    0x3C, 0xB4, 0x2A, 0x94, 0xBB, 0x67, 0xF3, 0xA7, 0x74, 0x54, 0x03, 0x12, 0x3C, 0x07, 0xD1, 0xEC,
    0x57, 0xC8, 0x49, 0x6B, 0x3D, 0x09, 0x8A, 0x9A, 0x7D, 0xF3, 0x3E, 0x10, 0x17, 0x8D, 0xAC, 0xDB,
    0xDA, 0x94, 0xBF, 0x1A, 0x53, 0x7B, 0x74, 0xD2, 0xC4, 0x36, 0x0B, 0x9C, 0x1D, 0x2A, 0x58, 0x86,
    0x33, 0x5D, 0xF9, 0x69, 0x72, 0x87, 0x4D, 0x73, 0x6E, 0xE2, 0x09, 0x83, 0xAD, 0x93, 0x1A, 0xF3,
    0x8A, 0x1F, 0x9A, 0x67, 0xD0, 0xAB, 0xAE, 0x75, 0x4F, 0x99, 0xFF, 0xDD, 0xF1, 0x69, 0xBE, 0x57,
    0x09, 0xFF, 0xC5, 0x66, 0xAF, 0x6C, 0x6A, 0x1A, 0x14, 0x61, 0x01, 0x36, 0xCC, 0xAE, 0xD1, 0x7E,
    0xF9, 0xBC, 0x12, 0x8C, 0xB3, 0xEA, 0xB4, 0xB1, 0x87, 0x52, 0xE2, 0xEA, 0x52, 0xF2, 0xAD, 0x64,
    0x1B, 0xBD, 0xD2, 0x50, 0xDE, 0xD0, 0x6B, 0xBD, 0x9C, 0x7A, 0x0F, 0x9E, 0x23, 0x6B, 0x3A, 0x8F,
    // aqwDQ
    0x07, 0xF2, 0x5E, 0x9E, 0x41, 0x22, 0x32, 0x3F, 0xE0, 0x03, 0xDA, 0x6E, 0x79, 0x8A, 0xA5, 0x35,
    0x14, 0x6F, 0x47, 0x4B, 0x24, 0xF3, 0x55, 0xC8, 0xD3, 0x53, 0x7F, 0x66, 0x74, 0xA1, 0xC5, 0xD9,
    0xFC, 0x8A, 0x26, 0xBB, 0x08, 0xCA, 0xA1, 0x1B, 0xCD, 0xFE, 0x72, 0xA1, 0x84, 0xAD, 0xEA, 0xC3,
    0xDC, 0x08, 0xEE, 0x75, 0xC4, 0x67, 0x5E, 0x67, 0xFE, 0x0F, 0xEF, 0x34, 0x1B, 0xC6, 0xC9, 0x2A,
    0x50, 0x85, 0x3A, 0x9B, 0x7B, 0x05, 0x33, 0x3F, 0x26, 0x9D, 0xDB, 0x09, 0xEF, 0x32, 0x7E, 0xDD,
    0xD0, 0x90, 0xAF, 0x24, 0x76, 0xAC, 0xDD, 0xF6, 0x85, 0xFE, 0xE9, 0x8B, 0xC8, 0x09, 0x49, 0x84,
    0xFD, 0x06, 0x19, 0xDE, 0x75, 0xE1, 0x94, 0x9A, 0x64, 0x67, 0x48, 0xA9, 0x32, 0x74, 0x17, 0xE1,
    0x4C, 0xE0, 0x96, 0x52, 0x5F, 0x54, 0x02, 0xDD, 0x84, 0x55, 0xA3, 0x52, 0x79, 0x2E, 0x32, 0x5F,
    // aqwCR
    0xA5, 0xA5, 0xC7, 0x37, 0x92, 0xD0, 0xD8, 0x8D, 0x2B, 0xD0, 0x3C, 0x4E, 0x27, 0x8F, 0x47, 0x24,
    0x6E, 0x31, 0x2C, 0xFE, 0x4C, 0xD8, 0xFD, 0x9E, 0xA3, 0xED, 0xE4, 0xC4, 0x41, 0xD2, 0x33, 0x8E,
    0x5E, 0x83, 0xAD, 0x47, 0xB5, 0xFF, 0x09, 0x35, 0x58, 0x61, 0xB8, 0xDC, 0x33, 0xD3, 0x4E, 0x15,
    0x7A, 0x8E, 0x66, 0x1C, 0x21, 0x10, 0xA8, 0x66, 0x61, 0xC2, 0xDA, 0x82, 0x0B, 0xA5, 0xFB, 0xF8,
    0x3B, 0x28, 0x1B, 0xF8, 0xF5, 0x33, 0xA9, 0xA8, 0xE0, 0xA7, 0xE1, 0x86, 0x04, 0xD9, 0xD5, 0xEF,
    0xEA, 0xCB, 0x13, 0xC9, 0x1A, 0x78, 0xC7, 0x92, 0x3D, 0xD5, 0x2B, 0xBB, 0xB4, 0xCC, 0xE8, 0x15,
    0x72, 0xA3, 0x63, 0xCA, 0x4C, 0xBC, 0x54, 0x3D, 0x2B, 0x12, 0xDD, 0xB5, 0x05, 0x0C, 0x7F, 0x49,
    0x0A, 0x96, 0x1A, 0xC4, 0x78, 0x5C, 0x83, 0x0A, 0x5B, 0xFE, 0x79, 0xF4, 0x19, 0x29, 0xA9, 0x7F
};
```

`formats/xex_optheaders.hpp`:

```hpp
#pragma once
#include <cstdint>
#include <cassert>
#include "../3rdparty/byte_order.hpp"
#include "xex_structs.hpp"

namespace xex_opt {
  struct XexImportDescriptor {
    xe::be<uint32_t> Size;
    xe::be<uint32_t> NameTableSize;
    xe::be<uint32_t> ModuleCount;
  };
  static_assert(sizeof(XexImportDescriptor) == 0xC, "xex_opt::XexImportDescriptor");

  struct XexImportTable {
    xe::be<uint32_t> TableSize;
    uint8_t NextImportDigest[0x14];
    xe::be<uint32_t> ModuleNumber;
    xex::Version Version;
    xex::Version VersionMin;
    uint8_t Unused;
    uint8_t ModuleIndex;
    xe::be<uint16_t> ImportCount;

    inline void endian_swap()
    {
      *(uint32_t*)&Version = xe::byte_swap(*(uint32_t*)&Version);
      *(uint32_t*)&VersionMin = xe::byte_swap(*(uint32_t*)&VersionMin);
    }

  };
  static_assert(sizeof(XexImportTable) == 0x28, "xex_opt::XexImportTable");

  namespace xex2d {
    struct XexImportTable {
      xe::be<uint32_t> TableSize;
      uint8_t NextImportDigest[0x14];
      xe::be<uint32_t> ModuleNumber;
      xex::Version Version;
      uint8_t Unused;
      uint8_t ModuleIndex;
      xe::be<uint16_t> ImportCount;
    };
    static_assert(sizeof(XexImportTable) == 0x24, "xex_opt::xex2d::XexImportTable");
  }
  struct XexCallcapImports {
    xe::be<uint32_t> BeginFunctionThunkAddress;
    xe::be<uint32_t> EndFunctionThunkAddress;
  };
  static_assert(sizeof(XexCallcapImports) == 0x8, "xex_opt::XexCallcapImports");

  struct XexExecutionId {
    xe::be<uint32_t> MediaID; // 0x0 sz:0x4
    xex::Version Version; // 0x4 sz:0x4
    xex::Version BaseVersion; // 0x8 sz:0x4
    union {
      xe::be<uint32_t> TitleID; // 0xC sz:0x4
#ifdef _MSC_VER // clang doesn't like these being in union...
      struct {
        xe::be<uint16_t> PublisherID; // 0xC sz:0x2
        xe::be<uint16_t> GameID; // 0xE sz:0x2
      };
#endif
    };
    uint8_t Platform; // 0x10 sz:0x1
    uint8_t ExecutableType; // 0x11 sz:0x1
    uint8_t DiscNum; // 0x12 sz:0x1
    uint8_t DiscsInSet; // 0x13 sz:0x1
    xe::be<uint32_t> SaveGameID; // 0x14 sz:0x4

    inline void endian_swap()
    {
      *(uint32_t*)&BaseVersion = xe::byte_swap(*(uint32_t*)&BaseVersion);
      *(uint32_t*)&Version = xe::byte_swap(*(uint32_t*)&Version);
    }

  }; // size 24
  static_assert(sizeof(XexExecutionId) == 0x18, "xex_opt::XexExecutionId");

  namespace xex25 {
    // xex25 version of execution ID is missing base version, and has 3 extra DWORDs
    // changing the uint8_t fields to uint32_t seems to fill in those extra DWORDs nicely
    struct XexExecutionId {
      xe::be<uint32_t> MediaID;
      xex::Version Version;
      union {
        xe::be<uint32_t> TitleID;
#ifdef _MSC_VER
        struct {
          xe::be<uint16_t> PublisherID;
          xe::be<uint16_t> GameID;
        };
#endif
      };
      xe::be<uint32_t> Platform;
      xe::be<uint32_t> ExecutableType;
      xe::be<uint32_t> DiscNum;
      xe::be<uint32_t> DiscsInSet;
      xe::be<uint32_t> SaveGameID;

      inline void endian_swap()
      {
        *(uint32_t*)&Version = xe::byte_swap(*(uint32_t*)&Version);
      }

    }; // size 32
    static_assert(sizeof(XexExecutionId) == 32, "xex_opt::xex25::XexExecutionId");
  }

  namespace xex2d {
    // xex2d version of execution ID is missing base version and has some extra data removed in later versions
    struct XexExecutionId {
      xe::be<uint32_t> MediaID;
      xex::Version Version;
      union {
        xe::be<uint32_t> TitleID;
#ifdef _MSC_VER
        struct {
          xe::be<uint16_t> PublisherID;
          xe::be<uint16_t> GameID;
        };
#endif
      };
      xe::be<uint16_t> UpdatedVersion;
      xe::be<uint16_t> Region;
      xe::be<uint32_t> Rating;
      uint8_t Platform;
      uint8_t ExecutableType;
      uint8_t SaveGameID;
      uint8_t DiscNum;

      inline void endian_swap()
      {
        *(uint32_t*)&Version = xe::byte_swap(*(uint32_t*)&Version);
      }

    }; // size 24
    static_assert(sizeof(xex_opt::xex2d::XexExecutionId) == 0x18, "xex_opt::xex25::XexExecutionId");
  }

  namespace xex3f {
    struct XexExecutionId {
      xe::be<uint32_t> MediaID;
      xex::Version Version;
      union {
        xe::be<uint32_t> TitleID;
#ifdef _MSC_VER
        struct {
          xe::be<uint16_t> PublisherID;
          xe::be<uint16_t> GameID;
        };
#endif
      };
      xe::be<uint16_t> UpdatedVersion;
      xe::be<uint16_t> Region;
      uint8_t Platform;
      uint8_t ExecutableType;
      uint8_t SaveGameID;
      uint8_t DiscNum;
    }; // size 20
    static_assert(sizeof(xex_opt::xex3f::XexExecutionId) == 0x14, "xex_opt::xex3f::XexExecutionId");
  }

  namespace xex0 {
    struct XexExecutionId {
      xe::be<uint32_t> MediaID;
      xex::Version Version;
      union {
        xe::be<uint32_t> TitleID;
#ifdef _MSC_VER
        struct {
          xe::be<uint16_t> PublisherID;
          xe::be<uint16_t> GameID;
        };
#endif
      };
      xe::be<uint16_t> UpdatedVersion;
      xe::be<uint16_t> Region;
      uint8_t Platform;
      uint8_t ContentType;
      uint8_t SaveGameID;
      uint8_t DiscNum;
    }; // size 20
    static_assert(sizeof(xex_opt::xex0::XexExecutionId) == 0x14, "xex_opt::xex0::XexExecutionId");
  }

  struct XexSectionHeader {
    char SectionName[0x8]; // 0x0 sz:0x8
    xe::be<uint32_t> VirtualAddress; // 0x8 sz:0x4
    xe::be<uint32_t> VirtualSize; // 0xC sz:0x4
  }; // size 16
  static_assert(sizeof(XexSectionHeader) == 0x10, "xex_opt::XexSectionHeader");

  struct XexSectionHeaders {
    xe::be<uint32_t> Size;
    XexSectionHeader Sections[1];
  };
  static_assert(sizeof(XexSectionHeaders) == 0x14, "xex_opt::XexSectionHeaders");

  struct XexImageLibraryVersion {
    char LibraryName[8];
    struct LIBVERSION {
      xe::be<uint16_t> Major;
      xe::be<uint16_t> Minor;
      xe::be<uint16_t> Build;
      xex::ApprovalType ApprovalType;
      uint8_t QFE;
    } Version;
  };
  static_assert(sizeof(XexImageLibraryVersion) == 0x10, "xex_opt::XexImageLibraryVersion");

  struct XexImageLibraryVersions {
    xe::be<uint32_t> Size;
    XexImageLibraryVersion Libraries[1];
  };
  static_assert(sizeof(XexImageLibraryVersions) == 0x14, "xex_opt::XexImageLibraryVersions");

  struct XexPrivileges {
    uint32_t NoForceReboot                   : 1; //= 0x00000001
    uint32_t ForegroundTasks                 : 1; //= 0x00000002
    uint32_t NoOddMapping                    : 1; //= 0x00000004
    uint32_t HandleMceInput                  : 1; //= 0x00000008
    uint32_t RestrictHudFeatures             : 1; //= 0x00000010
    uint32_t HandleGamepadDisconnect         : 1; //= 0x00000020
    uint32_t InsecureSockets                 : 1; //= 0x00000040
    uint32_t Xbox1XspInterop                 : 1; //= 0x00000080
    uint32_t SetDashContext                  : 1; //= 0x00000100
    uint32_t TitleUsesGameVoiceChannel       : 1; //= 0x00000200
    uint32_t TitlePal50Incompatible          : 1; //= 0x00000400
    uint32_t TitleInsecureUtilityDrive       : 1; //= 0x00000800
    uint32_t TitleXamHooks                   : 1; //= 0x00001000
    uint32_t TitlePii                        : 1; //= 0x00002000
    uint32_t CrossplatformSystemLink         : 1; //= 0x00004000
    uint32_t MultidiscSwap                   : 1; //= 0x00008000
    uint32_t MultidiscInsecureMedia          : 1; //= 0x00010000
    uint32_t Ap25Media                       : 1; //= 0x00020000
    uint32_t NoConfirmExit                   : 1; //= 0x00040000
    uint32_t AllowBackgroundDownload         : 1; //= 0x00080000
    uint32_t CreatePersistableRamdrive       : 1; //= 0x00100000
    uint32_t InheritPersistedRamdrive        : 1; //= 0x00200000
    uint32_t AllowHudVibration               : 1; //= 0x00400000
    uint32_t TitleBothUtilityPartitions      : 1; //= 0x00800000
    uint32_t HandleIPTVInput                 : 1; //= 0x01000000
    uint32_t PreferBigButtonInput            : 1; //= 0x02000000
    uint32_t AllowXsamReservation            : 1; //= 0x04000000
    uint32_t MultidiscCrossTitle             : 1; //= 0x08000000
    uint32_t TitleInstallIncompatible        : 1; //= 0x10000000
    uint32_t AllowAvatarGetMetadataByXUID    : 1; //= 0x20000000
    uint32_t AllowControllerSwapping         : 1; //= 0x40000000
    uint32_t DashExtensibilityModule         : 1; //= 0x80000000
  };
  static_assert(sizeof(XexPrivileges) == 4, "xex_opt::XexPrivileges");

  struct XexPrivileges32 {
    uint32_t AllowNetworkReadCancel          : 1; //= 0x00000001
    uint32_t UninterruptableReads            : 1; //= 0x00000002
    uint32_t RequireExperienceFull           : 1; //= 0x00000004
    uint32_t GameVoiceRequiredUI             : 1; //= 0x00000008
    uint32_t TitleSetPresenceString          : 1; //= 0x00000010
    uint32_t NatalTiltControl                : 1; //= 0x00000020
    uint32_t TitleRequiresSkeletalTracking   : 1; //= 0x00000040
    uint32_t TitleSupportsSkeletalTracking   : 1; //= 0x00000080
    uint32_t UseLargeHDsFileCache            : 1; //= 0x00000100
    uint32_t TitleSupportsDeepLink           : 1; //= 0x00000200
    uint32_t TitleBodyProfile                : 1; //= 0x00000400
    uint32_t TitleWinUSB                     : 1; //= 0x00000800
    uint32_t TitleSupportsDeepLinkRefresh    : 1; //= 0x00001000
    uint32_t LocalOnlySockets                : 1; //= 0x00002000
    uint32_t TitleContentAcquireAndDownload  : 1; //= 0x00004000
    uint32_t AllowSystemForeground           : 1; //= 0x00008000
  };
  static_assert(sizeof(XexPrivileges32) == 4, "xex_opt::XexPrivileges32");

  enum XexDataFormat : uint16_t {
    None = 0,
    Raw = 1,
    Compressed = 2,
    DeltaCompressed = 3
  };

  struct XexFileDataDescriptor {
    xe::be<uint32_t> Size;
    xe::be<uint16_t> Flags;
    xe::be<uint16_t> Format;

    XexDataFormat DataFormat() const
    {
      return static_cast<XexDataFormat>((uint16_t)Format);
    }
  };
  static_assert(sizeof(XexFileDataDescriptor) == 8, "xex_opt::XexFileDataDescriptor");

  // After XexFileDataDescriptor when Format == 1 (aka "uncompressed")
  struct XexRawDataDescriptor {
    xe::be<uint32_t> DataSize;
    xe::be<uint32_t> ZeroSize;
  };
  static_assert(sizeof(XexRawDataDescriptor) == 8, "xex_opt::XexRawDataDescriptor");

  struct XexDataDescriptor {
    xe::be<uint32_t> Size;
    uint8_t DataDigest[0x14];
  };
  static_assert(sizeof(XexDataDescriptor) == 0x18, "xex_opt::XexDataDescriptor");

  // After XexFileDataDescriptor when Format == 2 (aka compressed)
  struct XexCompressedDataDescriptor {
    xe::be<uint32_t> WindowSize;
    XexDataDescriptor FirstDescriptor;
  };
  static_assert(sizeof(XexCompressedDataDescriptor) == 0x1C, "xex_opt::XexCompressedDataDescriptor");

  struct XexVitalStats {
    xe::be<uint32_t> Checksum;
    xe::be<uint32_t> Timestamp; // UNIX timestamp
  };
  static_assert(sizeof(XexVitalStats) == 8, "xex_opt::XexVitalStats");

#define XEX_HV_MAGIC_0      0x48000000
#define XEX_HV_MAGIC_HVE      0x00485645
#define XEX_HV_MAGIC_HVI      0x00485649
#define XEX_HV_MAGIC_2      0x48000000

  struct HvImageExportTable { // XEX_HV_MAGIC_HVE magic
    xe::be<uint32_t> Magic[3];
    xe::be<uint32_t> ModuleNumber[2];
    xe::be<uint32_t> Version[3];
    xe::be<uint32_t> ImageBaseAddress;
    xe::be<uint32_t> Count;
    xe::be<uint32_t> Base;
  };
  static_assert(sizeof(HvImageExportTable) == 0x2C, "xex_opt::HvImageExportTable");

  namespace xex1 {
    struct HvImageRootImport { // XEX_HV_MAGIC_HVI magic, only used in XEX1, offset from ImageInfo.RootImportAddress
      xe::be<uint32_t> Magic[3];
      xe::be<uint32_t> ImageBaseAddress;
      xe::be<uint32_t> ImportTableCount;
      uint32_t FirstImportDigest[7]; // contains 0x14 byte hash + 2 uint32s?
    };
    static_assert(sizeof(HvImageRootImport) == 0x30, "xex_opt::xex1::HvImageRootImport");
  }

  struct XexServiceIdList {
    xe::be<uint32_t> Size;
    xe::be<uint32_t> CustomServiceIDs[4];
  };
  static_assert(sizeof(XexServiceIdList) == 0x14, "xex_opt::XexServiceIdList");

  struct XexSystemTimeRange {
    xe::be<uint64_t> Start;
    xe::be<uint64_t> End;
  };
  static_assert(sizeof(XexSystemTimeRange) == 0x10, "xex_opt::XexSystemTimeRange");

  struct XexTlsData {
    xe::be<uint32_t> TlsSlotCount;
    xe::be<uint32_t> AddressOfRawData;
    xe::be<uint32_t> SizeOfRawData;
    xe::be<uint32_t> SizeOfTlsData;
  };
  static_assert(sizeof(XexTlsData) == 0x10, "xex_opt::XexTlsData");

  struct XexKeyVaultPrivileges {
    xe::be<uint64_t> Mask;
    xe::be<uint64_t> Match;
  };
  static_assert(sizeof(XexKeyVaultPrivileges) == 0x10, "xex_opt::XexKeyVaultPrivileges");

  struct XexPageHeapOptions {
    xe::be<uint32_t> Size;
    xe::be<uint32_t> Flags;
  };
  static_assert(sizeof(XexPageHeapOptions) == 0x8, "xex_opt::XexPageHeapOptions");

  struct XexConsoleIdTable {
    xe::be<uint32_t> Size;
    uint8_t ConsoleId[0x5][1];
  };
  static_assert(sizeof(XexConsoleIdTable) == 0xC, "xex_opt::XexConsoleIdTable");

  struct XexDeltaPatchDescriptor {
    xe::be<uint32_t> Size;
    xex::Version TargetVersion;
    xex::Version SourceVersion;
    uint8_t DigestSource[20];
    uint8_t ImageKeySource[16];
    xe::be<uint32_t> SizeOfTargetHeaders;
    xe::be<uint32_t> DeltaHeadersSourceOffset;
    xe::be<uint32_t> DeltaHeadersSourceSize;
    xe::be<uint32_t> DeltaHeadersTargetOffset;
    xe::be<uint32_t> DeltaImageSourceOffset;
    xe::be<uint32_t> DeltaImageSourceSize;
    xe::be<uint32_t> DeltaImageTargetOffset;
  };
  static_assert(sizeof(XexDeltaPatchDescriptor) == 0x4C, "xex_opt::XexDeltaPatchDescriptor");

  struct XexLanKey {
    uint8_t Key[0x10];
  };
  static_assert(sizeof(XexLanKey) == 0x10, "xex_opt::XexLanKey");

  struct XexGameRatings {
    uint8_t Ratings[0x40];
  };
  static_assert(sizeof(XexGameRatings) == 0x40, "xex_opt::XexGameRatings");

#pragma pack(push, 1)
  struct XexStringHeader {
    xe::be<uint32_t> Size;
    char Data[1]; // should be null terminated hopefully
  };
  static_assert(sizeof(XexStringHeader) == 5, "xex_opt::XexStringHeader");
#pragma pack(pop)

  namespace xex3f {
    struct XexSectionHeader {
      char SectionName[8];
      xe::be<uint32_t> VirtualAddress;
      xe::be<uint32_t> VirtualSize;
      xe::be<uint32_t> PointerToRawData;
      xe::be<uint32_t> SizeOfRawData;
      xe::be<uint32_t> PageInfoFlags; // HvPageInfoFlags
      xe::be<uint32_t> Unknown1C;
    };
    static_assert(sizeof(xex3f::XexSectionHeader) == 0x20, "xex_opt::xex3f::XexSectionHeader");
  
    struct XexSectionHeaders {
      xe::be<uint32_t> Size; // (Size - 4) / 0x20 = count
      XexSectionHeader Sections[1];
    };
  }
};

```

`formats/xex_structs.hpp`:

```hpp
#pragma once
#include <cstdint>
#include <cassert>
#include "../3rdparty/byte_order.hpp"

namespace xex {
  struct XexModuleFlags {
    uint32_t TitleProcess               : 1; //= 0x00000001
    uint32_t TitleImports               : 1; //= 0x00000002
    uint32_t Debugger                   : 1; //= 0x00000004
    uint32_t Dll                        : 1; //= 0x00000008
    uint32_t Patch                      : 1; //= 0x00000010
    uint32_t PatchFull                  : 1; //= 0x00000020
    uint32_t PatchDelta                 : 1; //= 0x00000040
    uint32_t UserMode                   : 1; //= 0x00000080
    uint32_t                            : 22; //= 0x00000100-0x20000000
    uint32_t BoundPath                  : 1; //= 0x40000000
    uint32_t SilentLoad                 : 1; //= 0x80000000
  };
  static_assert(sizeof(XexModuleFlags) == 4, "xex::XexModuleFlags");

  struct XexHeader {
    xe::be<uint32_t> Magic; // 0x0 sz:0x4
    XexModuleFlags ModuleFlags; // 0x4 sz:0x4
    xe::be<uint32_t> SizeOfHeaders; // 0x8 sz:0x4
    xe::be<uint32_t> SizeOfDiscardableHeaders; // 0xC sz:0x4
    xe::be<uint32_t> SecurityInfo; // 0x10 sz:0x4
    xe::be<uint32_t> HeaderDirectoryEntryCount; // 0x14 sz:0x4

    inline void endian_swap() {
      *(uint32_t*)&ModuleFlags = xe::byte_swap(*(uint32_t*)&ModuleFlags);
    }
  }; // size 0x18
  static_assert(sizeof(XexHeader) == 0x18, "xex::XexHeader");

  struct ImageFlags {
    uint32_t Unknown1                   : 1; //= 0x00000001
    uint32_t ManufacturingUtility       : 1; //= 0x00000002
    uint32_t ManufacturingSupportTool   : 1; //= 0x00000004
          // ManufacturingAwareModule          = 0x00000006
    uint32_t Xgd2MediaOnly              : 1; //= 0x00000008
    uint32_t DataCenterRequired         : 1; //= 0x00000010
    uint32_t DataCenterAware            : 1; //= 0x00000020
    uint32_t                            : 2; //= 0x00000040-0x00000080

    // HV privileges section:
    uint32_t CardeaKey                  : 1; //= 0x00000100
    uint32_t XeikaKey                   : 1; //= 0x00000200
    uint32_t TitleUserMode              : 1; //= 0x00000400
    uint32_t SystemUserMode             : 1; //= 0x00000800
    uint32_t Orange0                    : 1; //= 0x000010001
    uint32_t Orange1                    : 1; //= 0x00002000
    uint32_t Orange2                    : 1; //= 0x00004000
    uint32_t SignedKeyVaultRequired     : 1; //= 0x00008000
    uint32_t IptvSignupApplication      : 1; //= 0x00010000
    uint32_t IptvTitleApplication       : 1; //= 0x00020000
    uint32_t NccpKeys                   : 1; //= 0x00040000

    uint32_t                            : 7; //= 0x00040000-0x02000000
    uint32_t KeyVaultPrivilegesRequired : 1; //= 0x04000000
    uint32_t OnlineActivationRequired   : 1; //= 0x08000000
    uint32_t PageSize4Kb                : 1; //= 0x10000000
    uint32_t NoGameRegion               : 1; //= 0x20000000
    uint32_t RevocationCheckOptional    : 1; //= 0x40000000
    uint32_t RevocationCheckRequired    : 1; //= 0x80000000
  };
  static_assert(sizeof(ImageFlags) == 4, "xex::ImageFlags");

  enum GameRegion : uint32_t
  {
    Region_NorthAmerica = 0x000000FF,
    Region_Japan = 0x00000100,
    Region_China = 0x00000200,
    Region_RestOfAsia = 0x0000FC00,
    Region_AustraliaNewZealand = 0x00010000,
    Region_RestOfEurope = 0x00FE0000,
    Region_Europe = 0xFF0000,
    Region_RestOfWorld = 0xFF000000,
    Region_All = 0xFFFFFFFF
  };
  static_assert(sizeof(GameRegion) == 4, "xex::GameRegion");

  enum ApprovalType : uint8_t
  {
    ApprovalType_Unapproved = 0x00,
    ApprovalType_Tool = 0x4,
    ApprovalType_Executable = 0x10,
    ApprovalType_PossiblyApproved = 0x20,
    ApprovalType_Approved = 0x40,
    ApprovalType_Expired = 0x60,
    ApprovalType_Debug = 0x80,
  };
  static_assert(sizeof(ApprovalType) == 1, "xex::ApprovalType");

  struct AllowedMediaTypes {
    uint32_t HardDisk                    : 1; //= 0x00000001
    uint32_t DvdX2                       : 1; //= 0x00000002
    uint32_t DvdCd                       : 1; //= 0x00000004
    uint32_t Dvd5                        : 1; //= 0x00000008
    uint32_t Dvd9                        : 1; //= 0x00000010
    uint32_t SystemFlash                 : 1; //= 0x00000020
    uint32_t _Unknown40                  : 1; //= 0x00000040
    uint32_t MemoryUnit                  : 1; //= 0x00000080
    uint32_t MassStorageDevice           : 1; //= 0x00000100
    uint32_t SmbFilesystem               : 1; //= 0x00000200
    uint32_t DirectFromRam               : 1; //= 0x00000400
    uint32_t _Unknown800                 : 1; //= 0x00000800
    uint32_t SecureVirtualOpticalDevice  : 1; //= 0x00001000
    uint32_t WirelessNStorageDevice      : 1; //= 0x00002000 (\Device\Nomnil)
    uint32_t SystemExtendedPartition     : 1; //= 0x00004000 (SEP)
    uint32_t SystemAuxiliaryPartition    : 1; //= 0x00008000 (SAP)
    uint32_t                             : 8; //= 0x00010000-0x00800000
    uint32_t InsecurePackage             : 1; //= 0x01000000
    uint32_t SaveGamePackage             : 1; //= 0x02000000
    uint32_t LocallySignedPackage        : 1; //= 0x04000000
    uint32_t LiveSignedPackage           : 1; //= 0x08000000
    uint32_t XboxPlatformPackage         : 1; //= 0x10000000
  };
  static_assert(sizeof(AllowedMediaTypes) == 4, "xex::AllowedMediaTypes");

  struct Version {
    uint32_t QFE : 8;
    uint32_t Build : 16;
    uint32_t Minor : 4;
    uint32_t Major : 4;
  };
  static_assert(sizeof(Version) == 4, "xex::Version");

  struct XexDirectoryEntry {
    xe::be<uint32_t> Key; // 0x0 sz:0x4
    xe::be<uint32_t> Value; // 0x4 sz:0x4
  }; // size 8
  static_assert(sizeof(XexDirectoryEntry) == 8, "xex::XexDirectoryEntry");

  enum HvPageInfoFlags
  {
    PageInfoFlag_NoWrite = 1,
    PageInfoFlag_NoExecute = 2,
    PageInfoFlag_Protect = 4,
    PageInfoFlag_Encrypt = 8,
  };

  struct HvPageInfo {
    union {
      struct {
        uint32_t Info : 4;
        uint32_t Size : 28;
      };
      uint32_t SizeInfo;
    };
    uint8_t DataDigest[0x14]; // Digest of the next page + next page descriptor

    inline void endian_swap()
    {
      SizeInfo = xe::byte_swap(SizeInfo);
    }
  };
  static_assert(sizeof(HvPageInfo) == 0x18, "xex:HvPageInfo");

  // FunctionType inside RUNTIME_FUNCTION
  enum class RuntimeFunctionType
  {
    SaveMillicode = 0x0,
    NoHandler = 0x1,
    RestoreMillicode = 0x2,
    Handler = 0x3,
  };
};

namespace xex2 {
  struct HvImageInfo {
    uint8_t Signature[0x100];
    xe::be<uint32_t> InfoSize;
    xex::ImageFlags ImageFlags;
    xe::be<uint32_t> LoadAddress;
    uint8_t ImageHash[0x14]; // SHA1(first_page, first_page_descriptor)
    xe::be<uint32_t> ImportTableCount;
    uint8_t ImportDigest[0x14]; // SHA1(import_table[4:])
    uint8_t MediaID[0x10];
    uint8_t ImageKey[0x10];
    xe::be<uint32_t> ExportTableAddress;
    uint8_t HeaderHash[0x14]; // SHA1(xex_headers[0:SizeOfHeaders]) - except for this HvImageInfo section itself, this section is explicitly excluded from the hash!
    xe::be<xex::GameRegion> GameRegion;
  };
  static_assert(sizeof(HvImageInfo) == 0x174, "xex2::HvImageInfo");

  struct SecurityInfo {
    xe::be<uint32_t> Size;
    xe::be<uint32_t> ImageSize;
    HvImageInfo ImageInfo;
    xex::AllowedMediaTypes AllowedMediaTypes;
    xe::be<uint32_t> PageDescriptorCount;

    void endian_swap()
    {
      *(uint32_t*)&ImageInfo.ImageFlags = xe::byte_swap(*(uint32_t*)&ImageInfo.ImageFlags);
      *(uint32_t*)&AllowedMediaTypes = xe::byte_swap(*(uint32_t*)&AllowedMediaTypes);
    }
  };
  static_assert(sizeof(SecurityInfo) == 0x184, "xex2::SecurityInfo");
};

namespace xex1 {
  struct HvImageInfo {
    uint8_t Signature[0x100];
    uint8_t ImportDigest[0x14];
    uint8_t ImageHash[0x14]; // confirmed
    xe::be<uint32_t> LoadAddress;
    uint8_t ImageKey[0x10];
    uint8_t MediaID[0x10];
    xe::be<xex::GameRegion> GameRegion;
    xex::ImageFlags ImageFlags;
  };
  static_assert(sizeof(HvImageInfo) == 0x154, "xex1::HvImageInfo");

  struct SecurityInfo {
    xe::be<uint32_t> Size;
    xe::be<uint32_t> ImageSize;
    HvImageInfo ImageInfo;
    xe::be<uint32_t> RootImportAddress; // points to "HVI" import table (xex_opt::xex1::HvImageRootImport)
    xex::AllowedMediaTypes AllowedMediaTypes;
    xe::be<uint32_t> PageDescriptorCount;
  };
  static_assert(sizeof(SecurityInfo) == 0x168, "xex1::SecurityInfo");
};

namespace xex25 {
  struct HvImageInfo {
    uint8_t Signature[0x100];
    uint8_t ImportDigest[0x14];
    uint8_t ImageHash[0x14];
    xe::be<uint32_t> LoadAddress;
    uint8_t ImageKey[0x10];
    xex::ImageFlags ImageFlags;
    xe::be<uint32_t> ExportTableAddress;
  };
  static_assert(sizeof(HvImageInfo) == 0x144, "xex25::HvImageInfo");

  struct SecurityInfo {
    xe::be<uint32_t> Size;
    xe::be<uint32_t> ImageSize;
    HvImageInfo ImageInfo;
    xex::AllowedMediaTypes AllowedMediaTypes;
    xe::be<uint32_t> PageDescriptorCount;
  };
  static_assert(sizeof(SecurityInfo) == 0x154, "xex25::SecurityInfo");
};

namespace xex2d {
  struct SecurityInfo {
    xe::be<uint32_t> Size;
    uint8_t Signature[0x100];
    uint8_t HeaderHash[0x14];
    uint8_t ImageHash[0x14];
    xe::be<uint32_t> LoadAddress;
    xe::be<uint32_t> ImageSize;
    xe::be<uint32_t> CurrentVersion;
    xe::be<uint32_t> LowestAcceptableVersion;
    xe::be<uint16_t> PageDescriptorCount;
    xe::be<uint16_t> ImageFlags;
  };
  static_assert(sizeof(SecurityInfo) == 0x140, "xex2d::SecurityInfo");
};

namespace xex0 {
  struct ModuleFlags {
    /* 0x01 */ uint32_t SystemProcess : 1;
    /* 0x02 */ uint32_t TitleProcess : 1;
    /* 0x04 */ uint32_t Dll : 1;
    /* 0x08 */ uint32_t Debugger : 1; // xex3f only
  };
  static_assert(sizeof(ModuleFlags) == 4, "xex::ModuleFlags");

  struct XexHeader {
    /* 0x00 */ xe::be<uint32_t> Magic;
    /* 0x04 */ xe::be<uint32_t> SizeOfHeaders;
    /* 0x08 */ xe::be<uint32_t> LoadAddress;
    /* 0x0C */ xe::be<uint32_t> ImageSize;
    /* 0x10 */ xe::be<uint32_t> HeaderDirectoryEntryCount;
  }; // size 0x14
  static_assert(sizeof(XexHeader) == 0x14, "xex0::XexHeader");
};

namespace xex3f {
  struct XexHeader {
    /* 0x00 */ xe::be<uint32_t> Magic;
    /* 0x04 */ xex0::ModuleFlags ModuleFlags;
    /* 0x08 */ xe::be<uint32_t> SizeOfHeaders;
    /* 0x0C */ xe::be<uint32_t> SizeOfDiscardableHeaders;
    /* 0x10 */ xe::be<uint32_t> LoadAddress;
    /* 0x14 */ xe::be<uint32_t> ImageSize;
    /* 0x18 */ xe::be<uint32_t> HeaderDirectoryEntryCount;
  }; // size 0x1C
  static_assert(sizeof(XexHeader) == 0x1C, "xex3f::XexHeader");
};

```

`idaloader.cpp`:

```cpp
// TODO:
// - fix export loading so that a segment isn't required (read from linput_t instead of reading thru IDA?)
// - add validate_array_count checks
// - test XEX2D / XEX3F
// - fix XEX1 exports

#include <ida.hpp>
#include <idp.hpp>
#include <loader.hpp>
#include <auto.hpp>
#include <diskio.hpp>
#include <entry.hpp>
#include <typeinf.hpp>
#include <bytes.hpp>

struct exehdr {}; // needed for pe.h
#include <pe.h>
#include <common.h>

#include <filesystem>
#include <list>

#include "formats/xex.hpp"
#include "formats/xex_headerids.hpp"

#include "formats/xbe.hpp"

ignore_micro_t ignore_micro;

bool exclude_unneeded_sections = true;

std::string DoNameGen(const std::string& libName, int id, int version); // namegen.cpp

struct saverest_pattern
{
  const char* name;
  const std::vector<uint8_t> pattern;
  bool is_prolog;
  int start_reg;
  int end_reg;
  int fn_size;
  int final_size;
};

std::list<saverest_pattern> patterns =
{
  { "__savegprlr_%d", {0xF9, 0xC1, 0xFF, 0x68, 0xF9, 0xE1, 0xFF, 0x70}, true, 14, 32, 4, 12 },
  { "__restgprlr_%d", {0xE9, 0xC1, 0xFF, 0x68, 0xE9, 0xE1, 0xFF, 0x70}, false, 14, 32, 4, 16 },

  { "__savefpr_%d", {0xD9, 0xCC, 0xFF, 0x70, 0xD9, 0xEC, 0xFF, 0x78}, true, 14, 32, 4, 8 },
  { "__restfpr_%d", {0xC9, 0xCC, 0xFF, 0x70, 0xC9, 0xEC, 0xFF, 0x78}, false, 14, 32, 4, 8 },

  { "__savevmx_%d", {0x39, 0x60, 0xFE, 0xE0, 0x7D, 0xCB, 0x61, 0xCE}, true, 14, 32, 8, 12 },
  { "__restvmx_%d", {0x39, 0x60, 0xFE, 0xE0, 0x7D, 0xCB, 0x60, 0xCE}, false, 14, 32, 8, 12 },

  // vmx128, same name as above
  { "__savevmx_%d", {0x39, 0x60, 0xFC, 0x00, 0x10, 0x0B, 0x61, 0xCB}, true, 64, 128, 8, 12 },
  { "__restvmx_%d", {0x39, 0x60, 0xFC, 0x00, 0x10, 0x0B, 0x60, 0xCB}, false, 64, 128, 8, 12 },
};

void label_regsaveloads(ea_t start, ea_t end)
{
  for (auto& pattern : patterns)
  {
    ea_t addr = start;

    while (addr != BADADDR)
    {
      addr = bin_search(addr, end, pattern.pattern.data(), NULL, 8, BIN_SEARCH_CASE | BIN_SEARCH_FORWARD);
      if (addr == BADADDR)
        break;

      for (int i = pattern.start_reg; i < pattern.end_reg; i++)
      {
        int size = pattern.fn_size;
        if (i + 1 == pattern.end_reg)
          size = pattern.final_size;

        // reset addr
        del_items(addr, 0, 8);
        create_insn(addr);

        set_name(addr, qstring().sprnt(pattern.name, i).c_str(), SN_FORCE);

        func_t fn(addr, addr + size);
        fn.flags |= FUNC_OUTLINE | FUNC_HIDDEN;
        add_func_ex(&fn);

        // Mark save/rest functions as prolog/epilog to hide them from decompiler
        int hide_size = size;
        if (i + 1 == pattern.end_reg)
          hide_size -= 4; // don't hide last blr
        for (int insn = 0; insn < hide_size; insn += 4)
        {
          if (pattern.is_prolog)
            ignore_micro.mark_prolog_insn(addr + insn);
          else
            ignore_micro.mark_epilog_insn(addr + insn);
        }

        addr += size;
      }
    }
  }
}

void pe_add_sections(linput_t* li, XEXFile& file)
{
  ignore_micro.init_ignore_micro();

  uint32_t first_segment_address = 0;
  for (const auto& section : file.sections())
  {
    // New buffer for section name so we can null-terminate it
    char name[9];
    std::copy_n(section.Name, 8, name);
    name[8] = '\0';

    // Exclude some sections from being added - don't know the reason, but xorlosers loader seems to
    // they don't seem important anyway, so i guess it's a good idea?
    // TODO: actually this probably wasn't a good idea, will need to figure out a better way of excluding sections
    if (exclude_unneeded_sections)
    {
      if (!strcmp(name, ".edata"))
        continue;
      if (!strcmp(name, ".XBLD"))
        continue;
      if (!strcmp(name, ".reloc"))
        continue;
    }

    ea_t seg_addr = (ea_t)file.base_address() + (ea_t)section.VirtualAddress;
    uint32 seg_offset = section.VirtualAddress;
    uint32 seg_size = section.VirtualSize;

    if (file.header().Magic == MAGIC_XEX3F || file.header().Magic == MAGIC_XEX0)
    {
      seg_offset = section.PointerToRawData;
      seg_size = section.SizeOfRawData; // TODO: verify this?
    }

    // Size could be beyond file bounds, if so fix the size to what we can fit
    if (seg_offset + seg_size > file.image_size())
      seg_size = file.image_size() - seg_offset;

    // Add section as IDA segment
    uint32 seg_perms = 0;
    if (section.Characteristics & IMAGE_SCN_MEM_EXECUTE)
      seg_perms |= SEGPERM_EXEC;
    if (section.Characteristics & IMAGE_SCN_MEM_READ)
      seg_perms |= SEGPERM_READ;
    if (section.Characteristics & IMAGE_SCN_MEM_WRITE)
      seg_perms |= SEGPERM_WRITE;

    bool has_code = (section.Characteristics & IMAGE_SCN_CNT_CODE);
    bool has_data = (section.Characteristics & IMAGE_SCN_CNT_INITIALIZED_DATA) || (section.Characteristics & IMAGE_SCN_CNT_UNINITIALIZED_DATA);

    const char* seg_class = has_code ? "CODE" : "DATA";

    segment_t segm;
    segm.start_ea = seg_addr;
    segm.end_ea = seg_addr + section.VirtualSize;
    segm.align = saRelDble;
    segm.bitness = 1;
    segm.perm = seg_perms;
    add_segm_ex(&segm, name, seg_class, 0);

    // Load data into IDA
    if (seg_size > 0 && file.pe_data_length() > seg_offset)
    {
      if (!first_segment_address || first_segment_address > seg_addr)
        first_segment_address = seg_addr;

      mem2base(file.pe_data() + seg_offset, seg_addr, seg_addr + seg_size, -1);

      if (has_code)
        label_regsaveloads(seg_addr, seg_addr + section.VirtualSize);
    }
  }

  if (file.is_compressed() || file.is_encrypted())
    return;

  // TODO: check if this works for other XEX formats
  if (file.header().Magic != MAGIC_XEX2)
    return;

  // Not compressed/encrypted, lets inform IDA of file mappings
  msg("[+] XEX isn't compressed or encrypted, setting up file mappings to allow applying patches back to file\n");

  const auto* data_descriptor = file.data_descriptor();

  if (data_descriptor->DataFormat() == xex_opt::XexDataFormat::None)
  {
    // TODO: find a file to check this with (might be pre-XEX2 only...)
    auto first_segment_offset = first_segment_address - file.base_address();
    auto end_address = file.base_address() + file.image_size();
    file2base(li, file.header().SizeOfHeaders + first_segment_offset, first_segment_address, end_address, FILEREG_PATCHABLE);
    return;
  }

  const xex_opt::XexRawDataDescriptor* xex_blocks = 
    (const xex_opt::XexRawDataDescriptor*)(file.xex_headers() + file.opt_header(XEX_FILE_DATA_DESCRIPTOR_HEADER) + 8);
  int num_blocks = (data_descriptor->Size - 8) / 8;

  uint32_t address = 0;
  uint32_t file_position = 0;
  for (int i = 0; i < num_blocks; i++)
  {
    const auto& block = xex_blocks[i];
    auto block_end = address + block.DataSize;

    uint32_t addr_start = file.base_address() + address;
    uint32_t addr_end = file.base_address() + block_end;

    uint32_t block_offset = 0;

    // If first segment is inside this block, offset the data we read so prior data (PE headers etc) won't be added to DB
    if (first_segment_address >= addr_start && addr_end > first_segment_address)
      block_offset = first_segment_address - addr_start;

    if (addr_start + block_offset >= first_segment_address)
      file2base(li, file.header().SizeOfHeaders + file_position + block_offset, addr_start + block_offset, addr_end, FILEREG_PATCHABLE);

    address += block.DataSize + block.ZeroSize;
    file_position += block.DataSize;
  }
}

void pe_parse_pdata(XEXFile& file)
{
  // Hybrid pdata parser:
  // - our code will first read from pdata and create functions based on it
  // - then defer to eh_parse which will create .pdata dwords & set up exception handlers
  // From testing this results in more functions getting created, and allows autoanalysis to parse functions much earlier

  bool has_pdata = false;

  // Try reading & marking functions from .pdata section
  for (const auto& section : file.sections())
  {
    // New buffer for section name so we can null-terminate it
    char name[9];
    std::copy_n(section.Name, 8, name);
    name[8] = '\0';
    if (strcmp(name, ".pdata"))
      continue;

    has_pdata = true;

    uint32 sec_addr = section.VirtualAddress;
    uint32 sec_size = section.VirtualSize;
    if (file.header().Magic == MAGIC_XEX3F || file.header().Magic == MAGIC_XEX0)
    {
      sec_addr = section.PointerToRawData;
      sec_size = section.SizeOfRawData; // TODO: verify this?
    }
    ea_t seg_addr = (ea_t)file.base_address() + (ea_t)section.VirtualAddress;
    // Size could be beyond file bounds, if so fix the size to what we can fit
    if (sec_addr + sec_size > file.image_size())
      sec_size = file.image_size() - sec_addr;

    struct RUNTIME_FUNCTION_INFO // bitfield portion of RUNTIME_FUNCTION
    {
      uint32_t PrologLength : 8;
      uint32_t FunctionLength : 22;
      uint32_t FunctionType : 2;
      inline xex::RuntimeFunctionType RuntimeFunctionType() {
        return (xex::RuntimeFunctionType)FunctionType;
      }
    };

    // Read function addrs from .pdata into vector so we can get a count before asking IDA to create functions for them
    std::unordered_map<uint32_t, RUNTIME_FUNCTION_INFO> funcs;
    int offset = 0;
    while (offset < sec_size)
    {
      auto* fn_ptr = reinterpret_cast<const xe::be<uint32_t>*>(file.pe_data() + sec_addr + offset);
      uint32_t fn_ea = fn_ptr[0];
      if (fn_ea)
      {
        uint32_t fn_info_raw = fn_ptr[1]; // endian-swap the field for us
        RUNTIME_FUNCTION_INFO fn_info = *(RUNTIME_FUNCTION_INFO*)&fn_info_raw; // and then convert to RUNTIME_FUNCTION_INFO
        funcs.insert({ fn_ea, fn_info });
      }
      offset += 8;
    }

    msg("Parsing .pdata and creating %d functions...\n", int(funcs.size()));

    // display messagebox prompt to user so they can cancel if needed
    show_wait_box("Marking functions from .pdata... (0/%d)", int(funcs.size()));
    size_t num = 0;
    for (auto& kvp : funcs)
    {
      if (kvp.second.FunctionLength && !get_fchunk(kvp.first))
      {
        if (create_insn(kvp.first))
        {
          show_auto(kvp.first);
          // Don't create function for savevmx/restvmx, we handle it in label_regsaveloads
          auto fn_type = kvp.second.RuntimeFunctionType();
          if (fn_type != xex::RuntimeFunctionType::SaveMillicode && fn_type != xex::RuntimeFunctionType::RestoreMillicode)
          {
            func_t fn(kvp.first, kvp.first + (kvp.second.FunctionLength * 4));
            add_func_ex(&fn);
          }
        }
      }
      if (user_cancelled())
        break;
      // update every few funcs
      if (++num % 50 == 0)
      {
        replace_wait_box("Marking functions from .pdata... (%d/%d)", int(num), int(funcs.size()));
      }
    }

    hide_wait_box();
    break;
  }

  // Ask eh_parse to parse .pdata, for it to mark xrefs & EH
  // Load it here early so user won't need to wait for autoanalysis to complete
  if (has_pdata)
  {
    auto* plugin = find_plugin("eh_parse", true);
    if (plugin)
    {
      msg("Reading exception directory (.pdata)...\n");
      run_plugin(plugin, 0);
    }
  }
}

void pe_setup_netnode(XEXFile& file)
{
  netnode penode;
  penode.create(PE_NODE);

  const uint8_t* pe_data = file.pe_data();
  IMAGE_DOS_HEADER* dos_header = (IMAGE_DOS_HEADER*)pe_data;

  // Set PE header node data
  // Make a copy of PE header and update with correct values first, since IDA/eh_parse reads some info from this
  IMAGE_NT_HEADERS nt_header = *(IMAGE_NT_HEADERS*)(pe_data + dos_header->AddressOfNewExeHeader);
  nt_header.OptionalHeader.ImageBase = file.base_address();

  penode.set(&nt_header, sizeof(IMAGE_NT_HEADERS));

  // Update imagebase
  penode.altset(PE_ALT_IMAGEBASE, file.base_address());

  // Parse pdata if it exists
  pe_parse_pdata(file);

  // Update IDA with any codeview data
  size_t cv_length = 0;
  auto* cv_data = file.codeview_data(0, &cv_length);
  if (cv_data)
  {
    // Set PDB filename to whatever cv_data[0] says
    const char* pdb_path = (const char*)(cv_data + sizeof(CV_INFO_PDB70));

    // Try using filename instead of full path, else it may fail to load in
    const char* pdb_name = strrchr(pdb_path, '\\');
    if (pdb_name)
      pdb_path = pdb_name + 1; // get name past the backslash

    penode.supset(PE_SUPSTR_PDBNM, pdb_path);

    // Copy cv_data into RSDS tag
    penode.setblob(cv_data, cv_length, 0, RSDS_TAG);

    // Prompt for PDB load
    msg("Prompting for PDB load...\n(full X360 type loading may require pdb.cfg PDB_PROVIDER = PDB_PROVIDER_MSDIA !)\n");
    auto* plugin = find_plugin("pdb", true);
    run_plugin(plugin, 1LL);
  }
}

bool load_application(linput_t* li)
{
  qlseek(li, 0);

  XEXFile file;
  file.use_ida_io();
  if (!file.load(li))
  {
    msg("[+] XEX load failed with XEXLoadError code %d\n", file.load_error());
    return false;
  }

  inf_set_filetype(f_PE);
  inf_set_baseaddr(file.base_address() >> 4);
  set_imagebase(file.base_address());

  // If this is XEX2 try loading in x360.til, in case we have one
  if (file.header().Magic == MAGIC_XEX2)
  {
      add_til("x360.til", ADDTIL_INCOMP);
      add_til("xkelib.til", ADDTIL_INCOMP);
  }

  pe_add_sections(li, file);

  if (file.entry_point())
  {
    add_entry(0, file.entry_point(), "start", 1);
    inf_set_main(file.entry_point());
  }

  auto& pe_module_name = file.pe_module_name();
  if (!pe_module_name.empty())
    add_pgm_cmt("PE module name: %s", pe_module_name.c_str());

  auto tls_directory_va = file.tls_directory_va();
  if (tls_directory_va)
  {
    auto tls_directory = file.tls_directory();
    auto& tls_callbacks = file.tls_callbacks();

    if (tls_directory.StartAddressOfRawData)
      set_name(tls_directory.StartAddressOfRawData, "_tls_start");
    if (tls_directory.EndAddressOfRawData)
      set_name(tls_directory.EndAddressOfRawData, "_tls_end");
    if (tls_directory.AddressOfIndex)
      set_name(tls_directory.AddressOfIndex, "_tls_index");
    if (tls_directory.AddressOfCallBacks)
    {
      set_name(tls_directory.AddressOfCallBacks, "_tls_callbacks"); // not actual name, usually something useless like __xl_b
      if(tls_callbacks.size())
        create_dword(tls_directory.AddressOfCallBacks, tls_callbacks.size() * 4);
    }

    for (size_t i = 0; i < tls_callbacks.size(); i++)
      set_name(tls_callbacks[i], qstring().sprnt("TlsCallback_%d", int(i)).c_str());

    // Create IMAGE_TLS_DIRECTORY32 and set directory name/type
    static const char IMAGE_TLS_DIRECTORY32_type[] =
      R"(#pragma pack(push, 4)
typedef struct _IMAGE_TLS_DIRECTORY32
{
  void *StartAddressOfRawData;
  void *EndAddressOfRawData;
  void *AddressOfIndex;
  void *AddressOfCallBacks;
  unsigned int SizeOfZeroFill;
  unsigned int Characteristics;
} IMAGE_TLS_DIRECTORY32;
#pragma pack(pop)
)";

    h2ti(nullptr, nullptr, IMAGE_TLS_DIRECTORY32_type, HTI_DCL, nullptr, nullptr, msg);
    set_name(tls_directory_va, "_tls_used");
    apply_cdecl(nullptr, tls_directory_va, "IMAGE_TLS_DIRECTORY32 _tls_used;");
  }

  auto vital_stats = file.vital_stats();
  if (vital_stats)
  {
    time_t timestamp = vital_stats->Timestamp;
    char* timestamp_string = asctime(localtime(&timestamp));
    if (timestamp_string)
    {
      timestamp_string[strlen(timestamp_string) - 1] = 0; // remove newline from timestamp_string
      add_pgm_cmt("XEX timestamp: %s", timestamp_string);
    }

    add_pgm_cmt("XEX checksum: %x", (uint32_t)vital_stats->Checksum);
  }

  auto exports_libname = file.exports_libname();
  if (exports_libname.empty())
  {
    exports_libname = pe_module_name;
    if (exports_libname.empty())
    {
      char module_name[256];
      memset(module_name, 0, 256);

      get_root_filename(module_name, 256);
      exports_libname = module_name;
    }
  }

  auto exports_version = file.min_kernel_version();
  if (file.header().Magic != MAGIC_XEX2D)
  {
    auto* exec_info = file.opt_header_ptr<xex_opt::XexExecutionId>(XEX_HEADER_EXECUTION_ID);
    if (exec_info)
    {
      exports_version = exec_info->Version.Build;
    }
  }
  else
  {
    auto* exec_info = file.opt_header_ptr<xex_opt::xex2d::XexExecutionId>(XEX_HEADER_EXECUTION_ID);
    if (exec_info)
    {
      exports_version = exec_info->Version.Build;
    }
  }

  auto* exec_info25 = file.opt_header_ptr<xex_opt::xex25::XexExecutionId>(XEX_HEADER_EXECUTION_ID_BETA);
  if (exec_info25)
  {
    exports_version = exec_info25->Version.Build;
  }

  auto* exec_info3f = file.opt_header_ptr<xex_opt::xex3f::XexExecutionId>(XEX_HEADER_EXECUTION_ID_BETA3F);
  if (exec_info3f)
  {
    exports_version = exec_info3f->Version.Build;
  }

  for (auto& exp : file.exports())
  {
    auto exp_name = DoNameGen(exports_libname, exp.first, exports_version);
    auto exp_addr = exp.second.FuncAddr;

    // Mark as func export if inside a code section
    qstring func_segmclass;
    get_segm_class(&func_segmclass, getseg(exp_addr));

    bool func_iscode = func_segmclass == "CODE";
    add_entry(exp.first, exp_addr, exp_name.c_str(), func_iscode);

    if (func_iscode)
      add_func(exp_addr); // make doubly sure it gets marked as code
  }

  for (auto& lib : file.imports())
  {
    auto& libname = lib.first;

    netnode module_node;
    module_node.create();

    // Track lowest record addr so we can add import module comment to it later
    ea_t lowest_addr = BADADDR;

    int lib_version = file.min_kernel_version();

    auto& tables = file.import_tables();
    if (tables.count(libname))
    {
      lib_version = tables.at(libname).Version.Build;
    }

    for (auto& imp : lib.second)
    {
      auto imp_name = DoNameGen(libname, imp.first, lib_version);
      auto imp_addr = imp.second.ThunkAddr;

      if (imp.second.ThunkAddr && imp.second.ThunkAddr != imp.second.FuncAddr)
      {
        auto thunk_name = "__imp_" + imp_name;
        if (!imp.second.FuncAddr)
          thunk_name = imp_name;

        set_name(imp.second.ThunkAddr, thunk_name.c_str(), SN_FORCE);
        create_word(imp.second.ThunkAddr, 2 * 2);

        if (lowest_addr == BADADDR || lowest_addr > imp.second.ThunkAddr)
          lowest_addr = imp.second.ThunkAddr;
      }

      if (imp.second.FuncAddr)
      {
        imp_addr = imp.second.FuncAddr;
        set_name(imp_addr, imp_name.c_str(), SN_FORCE);

        // add comment to thunk like xorloser's loader
        set_cmt(imp_addr + 4, qstring().sprnt("%s :: %s", libname.c_str(), imp_name.c_str()).c_str(), 1);

        // force IDA to recognize addr as code, so we can add it as a library function
        auto_make_code(imp_addr);
        auto_recreate_insn(imp_addr);
        func_t func(imp_addr, imp_addr + 0x10, FUNC_LIB);
        add_func_ex(&func);
      }

      set_import_name(module_node, imp_addr, imp_name.c_str());
      set_import_ordinal(module_node, imp_addr, imp.first);
    }

    if (lowest_addr != BADADDR)
    {
      if (tables.count(libname))
      {
        auto& table_header = tables.at(libname);

        add_extra_line(lowest_addr, true, "\n\nImports from %s v%d.%d.%d.%d (minimum v%d.%d.%d.%d)\n", libname.c_str(),
          table_header.Version.Major, table_header.Version.Minor, table_header.Version.Build, table_header.Version.QFE,
          table_header.VersionMin.Major, table_header.VersionMin.Minor, table_header.VersionMin.Build, table_header.VersionMin.QFE);
      }
    }

    if (lib.second.size())
    {
      // Add module to imports window
      import_module(libname.c_str(), NULL, module_node, NULL, "x360");
    }
  }

  pe_setup_netnode(file);

  return true;
}

void idaapi load_file_xbe(linput_t* li, ushort _neflags, const char* fileformatname);

//------------------------------------------------------------------------------
void idaapi load_file(linput_t *li, ushort _neflags, const char* fileformatname)
{
  uint32 magic;
  qlseek(li, 0);
  qlread(li, &magic, sizeof(uint32));
  qlseek(li, 0);

  if (magic == MAGIC_XBEH)
  {
    load_file_xbe(li, _neflags, fileformatname);
    return;
  }

  // Set processor to PPC
  set_processor_type("ppc:vmx128", SETPROC_LOADER);

  // Set PPC_LISOFF to true
  // should help analyzer convert "lis r11, -0x7C46" to "lis r11, unk_83BA5600@h"
  uint32 val = 1;
  PH.set_idp_options("PPC_LISOFF", IDPOPT_BIT, &val);

  // Set compiler info
  compiler_info_t comp;
  comp.id = COMP_MS;
  comp.cm = CM_N32_F48 | CM_CC_FASTCALL;
  comp.size_i = 4;
  comp.size_b = 1;
  comp.size_e = 4;
  comp.defalign = 0;
  comp.size_s = 2;
  comp.size_l = 4;
  comp.size_ll = 8;
  comp.size_ldbl = 0;
  set_compiler(comp, SETCOMP_OVERRIDE);

  // load in the xex
  if (load_application(li))
  {
    // set as 32-bit for hexrays support
    EAH.setup(false);   // file format does not support 64-bit data
    inf_set_app_bitness(32);
  }
}

//--------------------------------------------------------------------------
static int idaapi accept_file(
        qstring *fileformatname,
        qstring *processor,
        linput_t *li,
        const char *)
{
  qlseek(li, 0);
  xe::be<uint32> magic;
  if (qlread(li, &magic, sizeof(uint32)) != sizeof(uint32))
    return 0;

  int valid = 0;
  if (magic == MAGIC_XEX2)
  {
    valid = 1;
    *fileformatname = "Xbox360 XEX2 File";
  }
  else if (magic == MAGIC_XEX1)
  {
    valid = 1;
    *fileformatname = "Xbox360 XEX1 File (>=1838)";
  }
  else if(magic == MAGIC_XEX25)
  {
    valid = 1;
    *fileformatname = "Xbox360 XEX%/XEX25 File (>=1746)";
  }
  else if(magic == MAGIC_XEX2D)
  {
    valid = 1;
    *fileformatname = "Xbox360 XEX-/XEX2D File (>=1640)";
  }
  else if (magic == MAGIC_XEX3F)
  {
    valid = 1;
    *fileformatname = "Xbox360 XEX?/XEX3F File (>=1434)";
  }
  else if (magic == MAGIC_XEX0)
  {
    valid = 1;
    *fileformatname = "Xbox360 XEX0 File (>=1332)";
  }

  if (valid)
    *processor = "PPC";
  else
  {
    if (magic == MAGIC_XBEH_BE)
    {
      *fileformatname = "Xbox XBE file";
      *processor = "metapc";
      valid = 1;
    }
  }

  return valid;
}

idaman loader_t ida_module_data LDSC;

//--------------------------------------------------------------------------
loader_t LDSC =
{
  IDP_INTERFACE_VERSION,
  0,                            // loader flags
//
//      check input file format. if recognized, then return 1
//      and fill 'fileformatname'.
//      otherwise return 0
//
  accept_file,
//
//      load file into the database.
//
  load_file,
//
//      create output file from the database.
//      this function may be absent.
//
  NULL,
//      take care of a moved segment (fix up relocations, for example)
  NULL,
  NULL,
};

```

`idaloader_xbe.cpp`:

```cpp
#include <ida.hpp>
#include <idp.hpp>
#include <loader.hpp>
#include <auto.hpp>
#include <diskio.hpp>
#include <entry.hpp>
#include <typeinf.hpp>
#include <bytes.hpp>
#include <segregs.hpp>

struct exehdr {}; // needed for pe.h
#include <pe.h>
#include <common.h>

#include <filesystem>
#include <list>
#include <array>

#include <libXbSymbolDatabase.h>

#include "formats/xbe.hpp"

#ifdef _WIN32
#define strncasecmp _strnicmp
#endif

std::string DoNameGen(const std::string& libName, int id, int version); // namegen.cpp
std::string DoXTLIDNameGen(uint32_t id); // namegen_xtlid.cpp

std::array<std::string, 11> kDataSectionNames = {
  ".rdata",
  ".data",
  ".data1",
  "DOLBY",
  "XON_RD",
  "WMADEC",
  ".XBLD",
  "D3D_RW",
  "D3DX_RW",
  "XGRPH_RW",
  "XTIMAGE",
};

void xbe_add_sections(linput_t* li, XBEFile& file)
{
  auto& xbe_header = file.header_data();

  // TODO: adding a HEADER segment is likely needed for PDB loading
  // though PDBs currently can't load properly due to other segment issues (see note at end of xbe_setup_netnode)
  // so we'll skip adding this for now
  /*
  segment_t xbe_segm;
  xbe_segm.start_ea = 0x10000;
  xbe_segm.end_ea = 0x10000 + xbe_header.size();
  xbe_segm.align = saRelDble;
  xbe_segm.bitness = 1;
  xbe_segm.perm = SEGPERM_READ | SEGPERM_WRITE;
  add_segm_ex(&xbe_segm, "HEADER", "DATA", 0);
  mem2base(xbe_header.data(), xbe_segm.start_ea, xbe_segm.end_ea, -1);*/

  sel_t ds = BADADDR;

  for (const auto& section : file.sections())
  {
    // Add section as IDA segment
    uint32 seg_perms = 0;
    seg_perms |= SEGPERM_READ;
    if (section.Info.SectionFlags.Executable)
      seg_perms |= SEGPERM_EXEC;
    if (section.Info.SectionFlags.Writable)
      seg_perms |= SEGPERM_WRITE;

    bool has_code = (section.Info.SectionFlags.Executable);

    // Unfortunately flags aren't always reliable to tell if section has code or not
    // Check against some known data-section names and remove flag if matches
    if (has_code)
      for (auto& name : kDataSectionNames)
      {
        if (name == section.Name) {
          has_code = false;
          break;
        }
      }

    const char* seg_class = has_code ? "CODE" : "DATA";

    uint32 seg_addr = section.Info.VirtualAddress;
    size_t seg_size = section.DataSize;

    segment_t segm;
    segm.start_ea = seg_addr;
    segm.end_ea = seg_addr + section.Info.VirtualSize;
    segm.align = saRelByte;
    segm.bitness = 1;
    segm.perm = seg_perms;
    segm.sel = allocate_selector(0);
    for (int i = 0; i < SREG_NUM; i++)
      segm.defsr[i] = BADADDR;

    if (section.Name == ".data")
      ds = segm.sel;

    add_segm_ex(&segm, section.Name.c_str(), seg_class, 0);

    // Load data into IDA
    if (seg_size > 0)
      file2base(li, section.Info.PointerToRawData, seg_addr, seg_addr + seg_size, FILEREG_PATCHABLE);
  }

  if (ds != BADADDR)
    set_default_dataseg(ds);
}

void xbe_setup_netnode(XBEFile& file)
{
  netnode penode;
  penode.create(PE_NODE);

  // Set PE header node data
  // Make a copy of PE header and update with correct values first, since IDA/eh_parse reads some info from this
  
  auto& xbe_header = file.header();
  
  IMAGE_NT_HEADERS nt_header{ 0 };
  nt_header.Signature = 0x4550;
  nt_header.FileHeader.Machine = 0x14C;
  nt_header.FileHeader.NumberOfSections = file.sections().size();
  nt_header.FileHeader.TimeDateStamp = xbe_header.NtTimeDateStamp;
  nt_header.FileHeader.SizeOfOptionalHeader = sizeof(IMAGE_OPTIONAL_HEADER32);

  auto& opt = nt_header.OptionalHeader;
  opt.Magic = 0x10B;
  opt.MajorLinkerVersion = 8;
  opt.AddressOfEntryPoint = xbe_header.AddressOfEntryPoint;
  opt.ImageBase = xbe_header.BaseAddress;
  opt.SectionAlignment = 0x1000;
  opt.FileAlignment = 0x400;
  opt.MajorOperatingSystemVersion = 4;
  opt.MajorSubsystemVersion = 4;
  opt.SizeOfImage = xbe_header.NtSizeOfImage;
  opt.SizeOfHeaders = xbe_header.SizeOfHeaders;
  opt.Subsystem = 2;
  opt.SizeOfStackCommit = xbe_header.SizeOfStackCommit;
  opt.SizeOfHeapReserve = xbe_header.SizeOfHeapReserve;
  opt.SizeOfHeapCommit = xbe_header.SizeOfHeapCommit;
  opt.NumberOfRvaAndSizes = 16;

  penode.set(&nt_header, sizeof(IMAGE_NT_HEADERS));

  // Update imagebase
  penode.altset(PE_ALT_IMAGEBASE, file.base_address());

  // Update IDA with any codeview data
  size_t cv_length = 0;
  auto* cv_data = file.codeview_data(0, &cv_length);
  if (cv_data)
  {
    // Set PDB filename to whatever cv_data[0] says
    const char* pdb_path = (const char*)(cv_data + sizeof(CV_INFO_PDB70));

    // Try using filename instead of full path, else it may fail to load in
    const char* pdb_name = strrchr(pdb_path, '\\');
    if (pdb_name)
      pdb_path = pdb_name + 1; // get name past the backslash

    penode.supset(PE_SUPSTR_PDBNM, pdb_path);

    // Copy cv_data into RSDS tag
    penode.setblob(cv_data, cv_length, 0, RSDS_TAG);

    // TODO: pdb loading doesn't currently work for xbe files
    // Even though cvdump shows that the symbols are relative to each segment
    // It looks like DIA (and PDBIDA) both lookup the segment address from something inside the PDB, rather than from the IDB
    // PDB segments are based on the original EXE layout, not the XBE version, so this causes it to use wrong address for symbols
    // 
    // (guess there must be some way for DIA to adjust segment addrs since XboxSDK allows XBE+PDB debugging
    // but IDA probably isn't setup to make use of that, or if it is I haven't seen a way for us to change it...)
#if 0
    // Prompt for PDB load
    msg("Prompting for PDB load...\n(full X360 type loading may require pdb.cfg PDB_PROVIDER = PDB_PROVIDER_MSDIA !)\n");
    auto* plugin = find_plugin("pdb", true);
    run_plugin(plugin, 1LL);
#endif
  }
}

void mark_lib_func(ea_t func_ea)
{
  // workaround IDA insisting on creating mainXapiStartup as dword
  show_auto(func_ea);
  del_items(func_ea);
  auto_make_proc(func_ea);

  func_t* existing = get_func(func_ea);
  if (existing)
  {
    existing->flags |= FUNC_LIB;
    update_func(existing);
  }
  else
  {
    func_t func(func_ea, BADADDR, FUNC_LIB);
    add_func_ex(&func);
  }
}

static int num_dbsymbols = 0;

static void reg_cb(const char* library_str,
  uint32_t library_flag,
  uint32_t xref_index,
  const char* symbol_str,
  xbaddr address,
  uint32_t build_version,
  uint32_t symbol_type,
  uint32_t call_type,
  uint32_t param_count,
  const XbSDBSymbolParam* param_list)
{
  num_dbsymbols++;
  const char* symbol_name = XbSDB_SymbolReferenceToString(xref_index);
  set_name(address, symbol_name);

  if (symbol_type == symbol_function)
  {
    mark_lib_func(address);
  }
}

bool xbe_scan_symboldb(XBEFile& file)
{
  msg("[XbSymbolDatabase] Scanning for library symbols, database version %x\n", XbSDB_LibraryVersion());
  num_dbsymbols = 0;

  // Make copy of xbe_data so we can apply transformations before passing to XbSymbolDatabase
  std::vector<uint8_t> xbe_data = file.xbe_data();
  xbe::XbeHeader* xbe_header = (xbe::XbeHeader*)xbe_data.data();

  if (file.is_xorkey_beta())
  {
    // Recrypt beta keys to retail, to workaround XbSymbolDatabase lacking beta keys
    xbe_header->XboxKernelThunkDataOffset =
      file.header().XboxKernelThunkDataOffset /* decrypted */
      ^ kXbeXorKernel_Retail; /* retail thunk key (TODO: if any beta games use debug libs we should switch to debug key here?) */

    xbe_header->AddressOfEntryPoint =
      file.header().AddressOfEntryPoint /* decrypted */
      ^ kXbeXorEntry_Retail;
  }

  XbSDBLibraryHeader lib_header = {
      .count = XbSDB_GenerateLibraryFilter(xbe_header, NULL),
      .filters = (XbSDBLibrary*)malloc(lib_header.count * sizeof(XbSDBLibrary))
  };
  if (!lib_header.filters) {
    return false;
  }
  XbSDB_GenerateLibraryFilter(xbe_header, &lib_header);

  XbSDBSectionHeader sect_header = {
      .count = XbSDB_GenerateSectionFilter(xbe_header, NULL, 1),
      .filters = (XbSDBSection*)malloc(sect_header.count * sizeof(XbSDBSection))
  };
  if (!sect_header.filters) {
    free(lib_header.filters);
    return false;
  }
  XbSDB_GenerateSectionFilter(xbe_header, &sect_header, 1);

  XbSDBContextHandle ctx;
  bool status = XbSDB_CreateContext(&ctx, reg_cb, lib_header, sect_header, XbSDB_GetKernelThunkAddress(xbe_header));
  if (status)
  {
    XbSDBContext_ScanManual(ctx);
    XbSDBContext_ScanAllLibraryFilter(ctx);
    XbSDBContext_RegisterXRefs(ctx);
    msg("[XbSymbolDatabase] Scan complete, %d symbols named\n", num_dbsymbols);
  }
  else
  {
    msg("[XbSymbolDatabase] CreateXbSymbolContext failed...\n");
  }

  if(ctx)
    XbSDBContext_Release(ctx);

  free(sect_header.filters);
  free(lib_header.filters);

  return true;
}

void xbe_parse_xtlid(XBEFile& file)
{
  for (const auto& section : file.sections())
  {
    if (section.Name != ".XTLID")
      continue;

    uint32_t* xtlid = (uint32_t*)(file.xbe_data().data() + section.Info.PointerToRawData);

    // xtlid header
    uint32_t unk0 = *(xtlid++);
    uint32_t lib_version = *(xtlid++);

    uint32_t num_fns = (section.DataSize - 8) / 8;

    if (unk0 != 0 || (lib_version == 0 || lib_version > 5933))
    {
      msg("[XTLID] Failed to parse XTLID, unexpected header values: %x %x\n", unk0, lib_version);
      return;
    }

    add_extra_line(section.Info.VirtualAddress, true, "XTLID function count: %d\nXTLID library version: %d", int(num_fns), int(lib_version));

    // create dword for version field
    create_dword(section.Info.VirtualAddress + 4, 4, true);
    set_op_type(section.Info.VirtualAddress + 4, dec_flag(), 0);
    set_cmt(section.Info.VirtualAddress + 4, qstring().sprnt("XTLID library version: %d", int(lib_version)).c_str(), false);

    msg("[XTLID] Library version from XTLID: %d\n", int(lib_version));
    msg("[XTLID] Naming %d library functions from XTLID data...\n", int(num_fns));
    int named_fns = 0;
    for (uint32_t i = 0; i < num_fns; i++)
    {
      uint32_t xtlid_ea = section.Info.VirtualAddress + 8 + (i * 8);
      create_dword(xtlid_ea, 4, true);
      set_op_type(xtlid_ea, hex_flag(), 0); // force the ID to be hex number without creating random xrefs
      create_dword(xtlid_ea + 4, 4, true);

      uint32_t fn_id = *(xtlid++);
      uint32_t fn_addr = *(xtlid++);

      auto fn_name = DoXTLIDNameGen(fn_id);
      if (fn_name.empty())
      {
        msg("[XTLID] Name for XTLID 0x%x not found\n", fn_id);
        continue;
      }
      set_name(fn_addr, fn_name.c_str(), SN_FORCE);
      named_fns++;

      // Check if we should create func for this XTLID
      // List of some known non-function XTLIDs
      static std::vector<uint32_t> kDataXTLIDs = {
        0xb002d, // DirectSoundRequiredMixBins_3D
        0xb002e, // DirectSoundRequiredMixBins_5Channel3D
        0xb0033, // g_dwDirectSoundDebugBreakLevel
        0xb0034, // g_dwDirectSoundDebugLevel
        0xb0035, // g_pfnDirectSoundDebugCallback
        0x60001, // XDEVICE_TYPE_KEYBOARD_TABLE
        0x1007b, // XDEVICE_TYPE_DEBUG_MOUSE_TABLE
        0x1007c, // XDEVICE_TYPE_GAMEPAD_TABLE
        0x1007d, // XDEVICE_TYPE_IR_REMOTE_TABLE
        0x1007e, // XDEVICE_TYPE_MEMORY_UNIT_TABLE
        0x1007b, // XDEVICE_TYPE_DEBUG_MOUSE_TABLE
        0x50001, // XDEVICE_TYPE_DEBUG_KEYBOARD_TABLE
        0x80001, // D3D__Device
        0x80002, // D3D__NullHardware
        0x80003, // D3D__pDevice
        0x80004, // D3D__SingleStepPusher
        0x70001, // XDEVICE_TYPE_HIGHFIDELITY_MICROPHONE_TABLE
        0x70002, // XDEVICE_TYPE_VOICE_HEADPHONE_TABLE
        0x70003, // XDEVICE_TYPE_VOICE_MICROPHONE_TABLE
      };

      bool isDSoundData =
        (fn_id >= 0xb0005 && fn_id <= 0xb000e) ||
        (fn_id >= 0xb0012 && fn_id <= 0xb002b);

      if (isDSoundData || std::find(kDataXTLIDs.begin(), kDataXTLIDs.end(), fn_id) != kDataXTLIDs.end())
        continue;

      // Make sure func is inside a code segment
      auto* seg = getseg(fn_addr);
      qstring name;
      get_segm_class(&name, seg);
      if (name == "CODE")
        mark_lib_func(fn_addr);
    }

    msg("[XTLID] XTLID naming finished, %d names added\n", named_fns);
    break;
  }
}

bool load_application_xbe(linput_t* li)
{
  qlseek(li, 0);

  XBEFile file;
  file.use_ida_io();
  if (!file.load(li))
  {
    msg("[+] XBE file load failed with XBELoadError code %d\n", file.load_error());
    return false;
  }
  msg("[+] XBE encryption key: %s\n", XBEFile::key_name(file.xorkey_index()));

  inf_set_filetype(f_PE);
  inf_set_baseaddr(file.base_address() >> 4);
  set_imagebase(file.base_address());

  xbe_add_sections(li, file);

  if (file.entry_point())
  {
    add_func(file.entry_point());
    add_entry(0, file.entry_point(), "start", 1);
    inf_set_main(file.entry_point());
    inf_set_start_ip(file.entry_point());

    sel_t cs = 0;
    segment_t* cs_seg = getseg(file.entry_point());
    if (cs_seg)
      cs = cs_seg->sel;

    inf_set_start_cs(cs);
  }

  auto& header = file.header();

  auto& pe_module_name = file.pe_module_name();
  if (!pe_module_name.empty())
    add_pgm_cmt("PE module name: %s", pe_module_name.c_str());

  add_pgm_cmt("PE checksum: %x", (uint32_t)header.NtCheckSum);

  time_t pe_timestamp = header.NtTimeDateStamp;
  char* pe_timestamp_string = asctime(localtime(&pe_timestamp));
  if (pe_timestamp_string)
  {
    pe_timestamp_string[strlen(pe_timestamp_string) - 1] = 0; // remove newline from timestamp_string
    add_pgm_cmt("PE timestamp: %s", pe_timestamp_string);
  }

  time_t xbe_timestamp = header.TimeDateStamp;
  char* xbe_timestamp_string = asctime(localtime(&xbe_timestamp));
  if (xbe_timestamp_string)
  {
    xbe_timestamp_string[strlen(xbe_timestamp_string) - 1] = 0; // remove newline from timestamp_string
    add_pgm_cmt("XBE timestamp: %s", xbe_timestamp_string);
  }

  const xbe::XbeLibraryVersion* kernel_lib = nullptr;
  add_pgm_cmt("\nXTL versions:");
  for (auto& library : file.libraries())
  {
    if (!strncasecmp("XBOXKRNL", library.LibraryName, 8))
      kernel_lib = &library;

    char name[9];
    std::copy_n(library.LibraryName, 8, name);
    name[8] = '\0';

    add_pgm_cmt(" %s v%d.%d.%d.%d", name, library.MajorVersion, library.MinorVersion, library.BuildVersion, library.QFEVersion);
  }

  auto tls_directory_va = file.tls_directory_va();
  if (tls_directory_va)
  {
    auto tls_directory = file.tls_directory();
    auto& tls_callbacks = file.tls_callbacks();

    if (tls_directory.StartAddressOfRawData)
      set_name(tls_directory.StartAddressOfRawData, "_tls_start");
    if (tls_directory.EndAddressOfRawData)
      set_name(tls_directory.EndAddressOfRawData, "_tls_end");
    if (tls_directory.AddressOfIndex)
      set_name(tls_directory.AddressOfIndex, "_tls_index");
    if (tls_directory.AddressOfCallBacks)
    {
      set_name(tls_directory.AddressOfCallBacks, "_tls_callbacks"); // not actual name, usually something useless like __xl_b
      if (tls_callbacks.size())
        create_dword(tls_directory.AddressOfCallBacks, tls_callbacks.size() * 4);
    }

    for (size_t i = 0; i < tls_callbacks.size(); i++)
      set_name(tls_callbacks[i], qstring().sprnt("TlsCallback_%d", int(i)).c_str());

    // Create IMAGE_TLS_DIRECTORY32 and set directory name/type
    static const char IMAGE_TLS_DIRECTORY32_type[] =
      R"(typedef struct _IMAGE_TLS_DIRECTORY32
{
  void *StartAddressOfRawData;
  void *EndAddressOfRawData;
  void *AddressOfIndex;
  void *AddressOfCallBacks;
  unsigned int SizeOfZeroFill;
  unsigned int Characteristics;
} IMAGE_TLS_DIRECTORY32;
)";

    h2ti(nullptr, nullptr, IMAGE_TLS_DIRECTORY32_type, HTI_DCL, nullptr, nullptr, msg);
    set_name(tls_directory_va, "_tls_used");
    apply_cdecl(nullptr, tls_directory_va, "IMAGE_TLS_DIRECTORY32 _tls_used;");
  }

  // TODO: how are exports handled?

  netnode kernel_node;
  kernel_node.create();

  // Track lowest record addr so we can add import module comment to it later
  ea_t lowest_addr = BADADDR;

  for (auto imp : file.kernel_imports())
  {
    auto imp_name = DoNameGen("xbox1krnl", imp.second, 0);
    auto imp_addr = imp.first;

    if (imp_addr)
    {
      set_name(imp_addr, imp_name.c_str(), SN_FORCE);
      set_cmt(imp_addr, qstring().sprnt("%s :: %s", "xboxkrnl", imp_name.c_str()).c_str(), 1);
      create_dword(imp_addr, 4, true);

      set_import_name(kernel_node, imp_addr, imp_name.c_str());
      set_import_ordinal(kernel_node, imp_addr, imp.second);

      if (lowest_addr == BADADDR || lowest_addr > imp_addr)
        lowest_addr = imp_addr;
    }
  }

  if (lowest_addr != BADADDR)
  {
    if (kernel_lib)
    {
      add_extra_line(lowest_addr, true, "\n\nImports from %s v%d.%d.%d.%d\n", "xboxkrnl",
        kernel_lib->MajorVersion, kernel_lib->MinorVersion, kernel_lib->BuildVersion, kernel_lib->QFEVersion);
    }
  }

  import_module("xboxkrnl", NULL, kernel_node, NULL, "xbox");

  xbe_setup_netnode(file);

  xbe_scan_symboldb(file);
  xbe_parse_xtlid(file);

  return true;
}

//------------------------------------------------------------------------------
void idaapi load_file_xbe(linput_t* li, ushort _neflags, const char* fileformatname)
{
  bool reloading = (_neflags & NEF_RELOAD) == NEF_RELOAD;

  if (!reloading)
  {
    set_processor_type("metapc", SETPROC_LOADER);
    inf_set_specsegs(4);
  }

  // load in the xbe
  if (load_application_xbe(li))
  {
    if (!reloading)
    {
      // set as 32-bit for hexrays support
      EAH.setup(false);   // file format does not support 64-bit data
      inf_set_app_bitness(32);

      add_til("mssdk_win7", ADDTIL_SILENT);
    }
  }
}

```

`idaxex.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.0.32014.148
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "idaxex", "idaxex.vcxproj", "{6104AB02-F465-4FBA-B66E-232EF0925C65}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "xex1tool", "xex1tool.vcxproj", "{67F256A0-C7FB-448F-9B8F-362AE793C5B4}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{6104AB02-F465-4FBA-B66E-232EF0925C65}.Debug|x64.ActiveCfg = Debug|x64
		{6104AB02-F465-4FBA-B66E-232EF0925C65}.Debug|x64.Build.0 = Debug|x64
		{6104AB02-F465-4FBA-B66E-232EF0925C65}.Release|x64.ActiveCfg = Release|x64
		{6104AB02-F465-4FBA-B66E-232EF0925C65}.Release|x64.Build.0 = Release|x64
		{67F256A0-C7FB-448F-9B8F-362AE793C5B4}.Debug|x64.ActiveCfg = Debug|x64
		{67F256A0-C7FB-448F-9B8F-362AE793C5B4}.Debug|x64.Build.0 = Debug|x64
		{67F256A0-C7FB-448F-9B8F-362AE793C5B4}.Release|x64.ActiveCfg = Release|x64
		{67F256A0-C7FB-448F-9B8F-362AE793C5B4}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {2D699616-57E8-408D-B1AA-67CAF83E0B70}
	EndGlobalSection
EndGlobal

```

`idaxex.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{6104AB02-F465-4FBA-B66E-232EF0925C65}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <AdditionalIncludeDirectories>..\..\include;..\..\ldr\pe;3rdparty\XbSymbolDatabase\src\OOVPADatabase;3rdparty\XbSymbolDatabase\include;3rdparty/excrypt/src;3rdparty/mspack;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>__NT__;IDALDR;__EA64__;_WINDLL;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <LanguageStandard_C>stdc11</LanguageStandard_C>
    </ClCompile>
    <Link>
      <AdditionalDependencies>..\..\lib\x64_win_vc_64\ida.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <AdditionalIncludeDirectories>..\..\include;..\..\ldr\pe;3rdparty\XbSymbolDatabase\src\OOVPADatabase;3rdparty\XbSymbolDatabase\include;3rdparty/excrypt/src;3rdparty/mspack;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>__NT__;IDALDR;__EA64__;_WINDLL;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <LanguageStandard_C>stdc11</LanguageStandard_C>
    </ClCompile>
    <Link>
      <AdditionalDependencies>..\..\lib\x64_win_vc_64\ida.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="3rdparty\excrypt\src\excrypt_aes.c" />
    <ClCompile Include="3rdparty\excrypt\src\excrypt_sha.c" />
    <ClCompile Include="3rdparty\excrypt\src\rijndael.c" />
    <ClCompile Include="3rdparty\lzx.cpp" />
    <ClCompile Include="3rdparty\mspack\lzxd.c" />
    <ClCompile Include="3rdparty\mspack\system.c" />
    <ClCompile Include="3rdparty\XbSymbolDatabase\src\lib\libXbSymbolDatabase.c" />
    <ClCompile Include="3rdparty\XbSymbolDatabase\src\OOVPADatabase\D3D8LTCG_OOVPA.c" />
    <ClCompile Include="3rdparty\XbSymbolDatabase\src\OOVPADatabase\D3D8_OOVPA.c" />
    <ClCompile Include="3rdparty\XbSymbolDatabase\src\OOVPADatabase\DSound_OOVPA.c" />
    <ClCompile Include="3rdparty\XbSymbolDatabase\src\OOVPADatabase\JVS_OOVPA.c" />
    <ClCompile Include="3rdparty\XbSymbolDatabase\src\OOVPADatabase\XActEng_OOVPA.c" />
    <ClCompile Include="3rdparty\XbSymbolDatabase\src\OOVPADatabase\Xapi_OOVPA.c" />
    <ClCompile Include="3rdparty\XbSymbolDatabase\src\OOVPADatabase\XGraphic_OOVPA.c" />
    <ClCompile Include="3rdparty\XbSymbolDatabase\src\OOVPADatabase\XNet_OOVPA.c" />
    <ClCompile Include="3rdparty\XbSymbolDatabase\src\OOVPADatabase\XOnline_OOVPA.c" />
    <ClCompile Include="formats\xbe.cpp" />
    <ClCompile Include="formats\xex.cpp" />
    <ClCompile Include="idaloader.cpp" />
    <ClCompile Include="idaloader_xbe.cpp" />
    <ClCompile Include="namegen.cpp" />
    <ClCompile Include="namegen_xtlid.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="3rdparty\byte_order.hpp" />
    <ClInclude Include="formats\pe_structs.hpp" />
    <ClInclude Include="formats\xbe.hpp" />
    <ClInclude Include="formats\xbe_keys.hpp" />
    <ClInclude Include="formats\xbe_structs.hpp" />
    <ClInclude Include="formats\xex.hpp" />
    <ClInclude Include="formats\xex_headerids.hpp" />
    <ClInclude Include="formats\xex_keys.hpp" />
    <ClInclude Include="formats\xex_optheaders.hpp" />
    <ClInclude Include="formats\xex_structs.hpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`idaxex.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav</Extensions>
    </Filter>
    <Filter Include="Header Files\formats">
      <UniqueIdentifier>{b9a1b327-7db0-4490-abf7-1b7deabf3b71}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\formats">
      <UniqueIdentifier>{a4c096a6-e13b-4af5-8a6c-776b53f9acd5}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\excrypt">
      <UniqueIdentifier>{2e3fab5a-2e7a-443e-8abb-92c47a5ca017}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\lzx">
      <UniqueIdentifier>{eb5158b2-1fed-4520-848c-17295b1940e8}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="namegen.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="idaloader.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="idaloader_xbe.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="namegen_xtlid.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="3rdparty\XbSymbolDatabase\src\lib\libXbSymbolDatabase.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="formats\xex.cpp">
      <Filter>Source Files\formats</Filter>
    </ClCompile>
    <ClCompile Include="formats\xbe.cpp">
      <Filter>Source Files\formats</Filter>
    </ClCompile>
    <ClCompile Include="3rdparty\excrypt\src\excrypt_aes.c">
      <Filter>Source Files\excrypt</Filter>
    </ClCompile>
    <ClCompile Include="3rdparty\excrypt\src\excrypt_sha.c">
      <Filter>Source Files\excrypt</Filter>
    </ClCompile>
    <ClCompile Include="3rdparty\excrypt\src\rijndael.c">
      <Filter>Source Files\excrypt</Filter>
    </ClCompile>
    <ClCompile Include="3rdparty\mspack\lzxd.c">
      <Filter>Source Files\lzx</Filter>
    </ClCompile>
    <ClCompile Include="3rdparty\mspack\system.c">
      <Filter>Source Files\lzx</Filter>
    </ClCompile>
    <ClCompile Include="3rdparty\lzx.cpp">
      <Filter>Source Files\lzx</Filter>
    </ClCompile>
    <ClCompile Include="3rdparty\XbSymbolDatabase\src\OOVPADatabase\D3D8_OOVPA.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="3rdparty\XbSymbolDatabase\src\OOVPADatabase\D3D8LTCG_OOVPA.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="3rdparty\XbSymbolDatabase\src\OOVPADatabase\DSound_OOVPA.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="3rdparty\XbSymbolDatabase\src\OOVPADatabase\JVS_OOVPA.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="3rdparty\XbSymbolDatabase\src\OOVPADatabase\XActEng_OOVPA.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="3rdparty\XbSymbolDatabase\src\OOVPADatabase\Xapi_OOVPA.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="3rdparty\XbSymbolDatabase\src\OOVPADatabase\XGraphic_OOVPA.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="3rdparty\XbSymbolDatabase\src\OOVPADatabase\XNet_OOVPA.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="3rdparty\XbSymbolDatabase\src\OOVPADatabase\XOnline_OOVPA.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="3rdparty\byte_order.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="formats\pe_structs.hpp">
      <Filter>Header Files\formats</Filter>
    </ClInclude>
    <ClInclude Include="formats\xbe.hpp">
      <Filter>Header Files\formats</Filter>
    </ClInclude>
    <ClInclude Include="formats\xbe_keys.hpp">
      <Filter>Header Files\formats</Filter>
    </ClInclude>
    <ClInclude Include="formats\xbe_structs.hpp">
      <Filter>Header Files\formats</Filter>
    </ClInclude>
    <ClInclude Include="formats\xex.hpp">
      <Filter>Header Files\formats</Filter>
    </ClInclude>
    <ClInclude Include="formats\xex_headerids.hpp">
      <Filter>Header Files\formats</Filter>
    </ClInclude>
    <ClInclude Include="formats\xex_keys.hpp">
      <Filter>Header Files\formats</Filter>
    </ClInclude>
    <ClInclude Include="formats\xex_optheaders.hpp">
      <Filter>Header Files\formats</Filter>
    </ClInclude>
    <ClInclude Include="formats\xex_structs.hpp">
      <Filter>Header Files\formats</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`namegen.cpp`:

```cpp
#include <string>
#include <sstream>
#include <iomanip>

// TODO: allow using namegen from an external file instead?
// eg. x360_imports.idc ala xorlosers loader?

const char* connectxNameGen(int id)
{
  if (id == 0x00000001) return "CxGetVersion";
  if (id == 0x00000002) return "NbtNetbios";
  if (id == 0x00000003) return "SmbCloseHandle";
  if (id == 0x00000004) return "SmbCreateDirectoryW";
  if (id == 0x00000005) return "SmbCreateFileW";
  if (id == 0x00000006) return "SmbDeleteFileW";
  if (id == 0x00000007) return "SmbFindClose";
  if (id == 0x00000008) return "SmbFindFirstFileW";
  if (id == 0x00000009) return "SmbFindNextFile";
  if (id == 0x0000000A) return "SmbFlushFileBuffers";
  if (id == 0x0000000B) return "SmbGetDiskFreeSpaceW";
  if (id == 0x0000000C) return "SmbGetFileAttributesW";
  if (id == 0x0000000D) return "SmbGetFileInformationByHandle";
  if (id == 0x0000000E) return "SmbGetFileSize";
  if (id == 0x0000000F) return "SmbGetFileTime";
  if (id == 0x00000010) return "SmbMoveFileW";
  if (id == 0x00000011) return "SmbReadFile";
  if (id == 0x00000012) return "SmbRemoveDirectoryW";
  if (id == 0x00000013) return "SmbSetEndOfFile";
  if (id == 0x00000014) return "SmbSetFileAttributesW";
  if (id == 0x00000015) return "SmbSetFilePointer";
  if (id == 0x00000016) return "SmbSetFileTime";
  if (id == 0x00000017) return "SmbStartup";
  if (id == 0x00000018) return "SmbWriteFile";

  return nullptr;
}

const char* createprofileNameGen(int id)
{
  if (id == 0x00000001) return "CreateProfile_Register";
  if (id == 0x00000002) return "CreateProfile_Unregister";

  return nullptr;
}

const char* vkNameGen(int id)
{
  if (id == 0x00000001) return "RegisterXuiClasses";
  if (id == 0x00000002) return "VK_UnInit";
  if (id == 0x00000003) return "VK_CreateScene";
  if (id == 0x00000004) return "VK_GetUserCancelled";

  return nullptr;
}

const char* xamNameGen_1640(int id)
{
  if (id == 0x00000002) return "XSolidFiller_Finalize";
  if (id == 0x00000003) return "DbgInit";
  if (id == 0x00000004) return "XSolidFiller_Finalize2";
  if (id == 0x00000005) return "DbgAssertSzFmt";
  if (id == 0x0000000A) return "XamInputGetCapabilities";
  if (id == 0x0000000B) return "XamInputGetState";
  if (id == 0x0000000C) return "XamInputSetState";
  if (id == 0x0000000D) return "XamInputGetKeystroke";
  if (id == 0x0000000E) return "XamInputEnableAutobind";
  if (id == 0x0000000F) return "?XamInputRawState@@YAKKKHPAU_XINPUT_RAW@@@Z";
  if (id == 0x00000010) return "XamEnableSystemAppInput";
  if (id == 0x00000011) return "XamInputGetDeviceStats";
  if (id == 0x00000012) return "XamInputGetKeystrokeEx";
  if (id == 0x00000014) return "XLaunchNewImage";
  if (id == 0x00000015) return "XLaunchNewImageEx";
  if (id == 0x00000016) return "XSetLaunchData";
  if (id == 0x00000017) return "XGetLaunchDataSize";
  if (id == 0x00000018) return "XGetLaunchData";
  if (id == 0x00000019) return "XamTerminateTitle";
  if (id == 0x0000001D) return "XamExecutingOnBehalfOfTitle";
  if (id == 0x0000001E) return "XamTaskCreateQueue";
  if (id == 0x0000001F) return "XamTaskSchedule";
  if (id == 0x00000020) return "XamTaskReschedule";
  if (id == 0x00000021) return "XamTaskCloseHandle";
  if (id == 0x00000022) return "XamTaskCancel";
  if (id == 0x00000023) return "XamTaskShouldExit";
  if (id == 0x00000024) return "XamTaskWaitOnCompletion";
  if (id == 0x00000025) return "XamTaskModify";
  if (id == 0x00000026) return "XamTaskGetCurrentTask";
  if (id == 0x00000027) return "XamTaskGetAttributes";
  if (id == 0x00000028) return "XamApplySkin";
  if (id == 0x00000029) return "XamGetRootObj";
  if (id == 0x0000002A) return "XamFormatMessage";
  if (id == 0x0000002B) return "XamBuildResourceLocator";
  if (id == 0x0000002C) return "XamShowMessageBox";
  if (id == 0x0000002D) return "XCustomGetBannerImage";
  if (id == 0x0000002E) return "XCustomSetBannerImage";
  if (id == 0x0000002F) return "XCustomSetAction";
  if (id == 0x00000030) return "XCustomGetLastActionPress";
  if (id == 0x00000031) return "XCustomGetActionSetting";
  if (id == 0x00000032) return "XCustomBroadcastActionEvent";
  if (id == 0x00000033) return "XamGetBkgndDefault";
  if (id == 0x00000037) return "XamAlloc";
  if (id == 0x00000038) return "XamAllocEx";
  if (id == 0x00000039) return "XamFree";
  if (id == 0x0000003A) return "XamAllocSize";
  if (id == 0x0000003C) return "XMsgInProcessCall";
  if (id == 0x0000003D) return "XMsgCompleteIORequest";
  if (id == 0x0000003E) return "XMsgSystemProcessCall";
  if (id == 0x0000003F) return "XMsgStartIORequest";
  if (id == 0x00000040) return "XMsgCancelIORequest";
  if (id == 0x00000041) return "XMsgAcquireAsyncMessageFromOverlapped";
  if (id == 0x00000042) return "XMsgReleaseAsyncMessageToOverlapped";
  if (id == 0x00000043) return "XamGetOverlappedResult";
  if (id == 0x00000046) return "XamUserGetDeviceContext";
  if (id == 0x00000047) return "XamUserLookupDevice";
  if (id == 0x00000048) return "XamUserGetXUID";
  if (id == 0x00000049) return "XamUserLogon";
  if (id == 0x0000004A) return "XamUserGetGamerTag";
  if (id == 0x0000004B) return "XamUserGetUserIndexMask";
  if (id == 0x0000004C) return "XamUserGetName";
  if (id == 0x0000004E) return "XamUserGetSigninState";
  if (id == 0x0000004F) return "XamUserGetIndexFromXUID";
  if (id == 0x00000050) return "XamUserCheckPrivilege";
  if (id == 0x00000051) return "XamUserAreUsersFriends";
  if (id == 0x00000052) return "XamSetUserPresetPresenceState";
  if (id == 0x00000053) return "XamGetUserPresetPresenceState";
  if (id == 0x00000054) return "XamUserGetUserFlagsFromXUID";
  if (id == 0x00000055) return "XamUserGetMembershipTierFromXUID";
  if (id == 0x00000056) return "XamUserGetOnlineCountryFromXUID";
  if (id == 0x00000057) return "XamUserReadProfileSettings";
  if (id == 0x00000058) return "XamUserWriteProfileSettings";
  if (id == 0x00000059) return "XamUserGetMembershipTier";
  if (id == 0x0000005A) return "XamUserGetUserFlags";
  if (id == 0x0000005B) return "XamUserGetRequestedUserIndexMask";
  if (id == 0x0000005C) return "XamUserIsGuest";
  if (id == 0x00000064) return "XamProfileCreate";
  if (id == 0x00000065) return "XamProfileCreateEnumerator";
  if (id == 0x00000066) return "XamProfileEnumerate";
  if (id == 0x00000067) return "XamProfileEnumerateCD";
  if (id == 0x00000068) return "XamProfileDelete";
  if (id == 0x00000069) return "XamProfileGetCreationStatus";
  if (id == 0x0000006A) return "XamProfileFindAccount";
  if (id == 0x0000006B) return "XamProfileRenameAccount";
  if (id == 0x0000006C) return "XamProfileOpen";
  if (id == 0x0000006D) return "XamProfileClose";
  if (id == 0x0000006E) return "XamAppLoad";
  if (id == 0x00000070) return "XamAppUnloadSelf";
  if (id == 0x00000071) return "XamAppUnloadStack";
  if (id == 0x00000072) return "XamSendMessageToLoadedApps";
  if (id == 0x00000073) return "XamAppRequestLoad";
  if (id == 0x00000074) return "XamAppUnrequestLoad";
  if (id == 0x00000075) return "XamNavigate";
  if (id == 0x00000078) return "?XamVoiceCreate@@YAJKKPAPAX@Z";
  if (id == 0x00000079) return "?XamVoiceSubmitPacket@@YAJPAXHPAUXMEDIAPACKET@@@Z";
  if (id == 0x0000007A) return "?XamVoiceClose@@YAHPAX@Z";
  if (id == 0x00000082) return "XamContentCreate";
  if (id == 0x00000083) return "XamContentDelete";
  if (id == 0x00000084) return "XamContentClose";
  if (id == 0x00000085) return "XamContentCreateEnumerator";
  if (id == 0x00000086) return "XamContentCreateDeviceEnumerator";
  if (id == 0x00000087) return "XamContentGetDeviceData";
  if (id == 0x00000088) return "XamContentGetDeviceName";
  if (id == 0x00000089) return "XamContentCopyInternal";
  if (id == 0x0000008A) return "XamContentMoveInternal";
  if (id == 0x0000008B) return "XamContentGetMetaDataInternal";
  if (id == 0x0000008C) return "XamContentCreateEnumeratorInternal";
  if (id == 0x0000008D) return "XamContentAggregateCreateEnumerator";
  if (id == 0x0000008E) return "XamContentDeleteInternal";
  if (id == 0x0000008F) return "XamContentCreateInternal";
  if (id == 0x00000090) return "XamContentCreatePackage";
  if (id == 0x00000096) return "XamNotifyCreateListener";
  if (id == 0x00000097) return "XNotifyGetNext";
  if (id == 0x00000098) return "XNotifyPositionUI";
  if (id == 0x00000099) return "XNotifyDelayUI";
  if (id == 0x0000009A) return "XNotifyBroadcast";
  if (id == 0x0000009B) return "XNotifyRegisterArea";
  if (id == 0x0000009C) return "XNotifyQueueUI";
  if (id == 0x0000009D) return "XamNotifyCreateListenerInternal";
  if (id == 0x0000009E) return "XNotifyUISetOptions";
  if (id == 0x0000009F) return "XNotifyUIGetOptions";
  if (id == 0x000000A0) return "XamEnableInactivityProcessing";
  if (id == 0x000000A1) return "XamSetInactivityTime";
  if (id == 0x000000A4) return "XamCreateEnumeratorHandle";
  if (id == 0x000000A5) return "XamGetPrivateEnumStructureFromHandle";
  if (id == 0x000000A6) return "XamEnumerate";
  if (id == 0x000000AA) return "XamUpdateStart";
  if (id == 0x000000AB) return "XamUpdateGetProgress";
  if (id == 0x000000AC) return "XamUpdateGetExtenderInstance";
  if (id == 0x000000AD) return "XamUpdateFinish";
  if (id == 0x000000C9) return "XamShowSigninUI";
  if (id == 0x000000CA) return "XamShowSigninUIp";
  if (id == 0x000000CB) return "XamShowFriendsUI";
  if (id == 0x000000CC) return "XamShowMessagesUI";
  if (id == 0x000000CD) return "XamShowKeyboardUI";
  if (id == 0x000000CE) return "XamShowQuickChatUI";
  if (id == 0x000000CF) return "XamShowVoiceMailUI";
  if (id == 0x000000D0) return "XamShowGamerCardUI";
  if (id == 0x000000D1) return "XamShowAchievementsUI";
  if (id == 0x000000D2) return "XamShowPlayerReviewUI";
  if (id == 0x000000D3) return "XamShowMarketplaceUI";
  if (id == 0x000000D4) return "XamShowPlayersUI";
  if (id == 0x000000D5) return "XamShowUpdaterUI";
  if (id == 0x000000D6) return "XamShowMessageBoxUI";
  if (id == 0x000000D7) return "XamShowDeviceSelectorUI";
  if (id == 0x000000D8) return "XamShowMessageComposeUI";
  if (id == 0x000000D9) return "XamShowGameInviteUI";
  if (id == 0x000000DA) return "XamShowFriendRequestUI";
  if (id == 0x000000DB) return "XamShowCreateProfileUI";
  if (id == 0x000000DC) return "XamShowGamesUI";
  if (id == 0x000000DD) return "XamShowLiveSignupUI";
  if (id == 0x000000DE) return "XamShowFriendsUIp";
  if (id == 0x000000DF) return "XamShowComplaintUI";
  if (id == 0x000000E0) return "XamShowReputationUI";
  if (id == 0x000000E1) return "XamShowGamerCardUIForXUID";
  if (id == 0x000000FA) return "XamUserCreateAchievementEnumerator";
  if (id == 0x000000FB) return "XamReadTile";
  if (id == 0x000000FC) return "XamWriteGamerTile";
  if (id == 0x000000FD) return "XamWriteTile";
  if (id == 0x000000FE) return "?XamReadImage@@YAJW4XTILETYPE@@KK_KPAPAU_XUIBRUSH@@@Z";
  if (id == 0x000000FF) return "XamUserCreateTitlesPlayedEnumerator";
  if (id == 0x00000100) return "XamDecompressPNGToTexture";
  if (id == 0x00000101) return "XamReadTileToTexture";
  if (id == 0x00000102) return "XamReadString";
  if (id == 0x00000103) return "XamUserCreateStatsEnumerator";
  if (id == 0x00000104) return "XamUserAddRecentPlayer";
  if (id == 0x00000105) return "XamUserUpdateRecentPlayer";
  if (id == 0x00000106) return "XamUserCreatePlayerEnumerator";
  if (id == 0x00000107) return "XamParseGamerTileKey";
  if (id == 0x0000012C) return "XamCacheStoreFile";
  if (id == 0x0000012D) return "XamCacheFetchFile";
  if (id == 0x0000012E) return "XamCacheOpenFile";
  if (id == 0x0000012F) return "XamCacheCloseFile";
  if (id == 0x00000130) return "XamGetCachedTitleName";
  if (id == 0x000001F4) return "XuiAnimRun";
  if (id == 0x000001F5) return "XuiApplyLocale";
  if (id == 0x000001F6) return "XuiBubbleMessage";
  if (id == 0x000001F7) return "XuiControlIsBackButton";
  if (id == 0x000001F8) return "XuiControlIsNavButton";
  if (id == 0x000001F9) return "XuiCreateObject";
  if (id == 0x000001FA) return "XuiDestroyObject";
  if (id == 0x000001FB) return "XuiDynamicCast";
  if (id == 0x000001FC) return "XuiElementAddChild";
  if (id == 0x000001FD) return "XuiElementFindNamedFrame";
  if (id == 0x000001FE) return "XuiElementGetChildById";
  if (id == 0x000001FF) return "XuiElementGetFirstChild";
  if (id == 0x00000200) return "XuiElementGetFocus";
  if (id == 0x00000201) return "XuiElementGetFocusUser";
  if (id == 0x00000202) return "XuiElementGetId";
  if (id == 0x00000203) return "XuiElementGetLastChild";
  if (id == 0x00000204) return "XuiElementGetNext";
  if (id == 0x00000205) return "XuiElementGetParent";
  if (id == 0x00000206) return "XuiElementGetUserFocus";
  if (id == 0x00000207) return "XuiElementInitFocus";
  if (id == 0x00000208) return "XuiElementInitUserFocus";
  if (id == 0x00000209) return "XuiElementPlayTimeline";
  if (id == 0x0000020A) return "XuiElementSetBounds";
  if (id == 0x0000020B) return "XuiElementSetFocus";
  if (id == 0x0000020C) return "XuiElementSetUserFocus";
  if (id == 0x0000020D) return "XuiElementTreeGetFocus";
  if (id == 0x0000020E) return "XuiFindClass";
  if (id == 0x0000020F) return "XuiFreeStringTable";
  if (id == 0x00000210) return "XuiGetBaseObject";
  if (id == 0x00000211) return "XuiGetClass";
  if (id == 0x00000212) return "XuiGetObjectClass";
  if (id == 0x00000213) return "XuiGetOuter";
  if (id == 0x00000214) return "XuiInit";
  if (id == 0x00000215) return "XuiLoadFromBinary";
  if (id == 0x00000216) return "XuiLoadStringTableFromFile";
  if (id == 0x00000217) return "XuiVisualGetBasePath";
  if (id == 0x00000218) return "XuiLookupStringTable";
  if (id == 0x00000219) return "XuiNavButtonGetPressPath";
  if (id == 0x0000021A) return "XuiObjectFromHandle";
  if (id == 0x0000021B) return "XuiObjectGetProperty";
  if (id == 0x0000021C) return "XuiObjectGetPropertyId";
  if (id == 0x0000021D) return "XuiProcessInput";
  if (id == 0x0000021E) return "XuiRegisterClass";
  if (id == 0x0000021F) return "XuiRenderBegin";
  if (id == 0x00000220) return "XuiRenderCreateDC";
  if (id == 0x00000221) return "XuiRenderDCDeviceChanged";
  if (id == 0x00000222) return "XuiRenderDestroyDC";
  if (id == 0x00000223) return "XuiRenderEnd";
  if (id == 0x00000224) return "XuiRenderGetBackBufferSize";
  if (id == 0x00000225) return "XuiRenderInit";
  if (id == 0x00000226) return "XuiRenderInitShared";
  if (id == 0x00000227) return "XuiRenderPresent";
  if (id == 0x00000228) return "XuiRenderSetViewTransform";
  if (id == 0x00000229) return "XuiRenderUninit";
  if (id == 0x0000022B) return "XuiSceneCreate";
  if (id == 0x0000022C) return "XuiSceneNavigateBack";
  if (id == 0x0000022D) return "XuiSceneNavigateFirst";
  if (id == 0x0000022E) return "XuiSceneNavigateForward";
  if (id == 0x0000022F) return "XuiScenePlayBackFromTransition";
  if (id == 0x00000230) return "XuiScenePlayBackToTransition";
  if (id == 0x00000231) return "XuiScenePlayFromTransition";
  if (id == 0x00000232) return "XuiScenePlayToTransition";
  if (id == 0x00000233) return "XuiSendMessage";
  if (id == 0x00000234) return "XuiSetLocale";
  if (id == 0x00000235) return "XuiUninit";
  if (id == 0x00000236) return "XuiUnregisterClass";
  if (id == 0x00000237) return "XuiTextElementSetText";
  if (id == 0x00000238) return "XuiSetTimer";
  if (id == 0x00000239) return "XuiTimersRun";
  if (id == 0x0000023A) return "XuiTextElementGetText";
  if (id == 0x0000023B) return "XuiVisualSetBasePath";
  if (id == 0x0000023C) return "XuiHandleIsValid";
  if (id == 0x0000023D) return "XuiAlloc";
  if (id == 0x0000023E) return "XuiFree";
  if (id == 0x0000023F) return "XuiDefault_True";
  if (id == 0x00000240) return "XuiDefault_EmptyString";
  if (id == 0x00000241) return "XuiDefault_IntegerZero";
  if (id == 0x00000242) return "XuiCopyString";
  if (id == 0x00000243) return "XuiRealloc";
  if (id == 0x00000244) return "XuiControlPlayOptionalVisual";
  if (id == 0x00000245) return "XuiKillTimer";
  if (id == 0x00000246) return "XuiElementEnableInput";
  if (id == 0x00000247) return "XuiElementInputEnabled";
  if (id == 0x00000248) return "XuiIsInstanceOf";
  if (id == 0x00000249) return "XuiResourceComposeLocator";
  if (id == 0x0000024A) return "XuiResourceLocatorIsAbsolute";
  if (id == 0x0000024B) return "XuiBroadcastMessage";
  if (id == 0x0000024C) return "XuiElementDisallowRecursiveTimelineControl";
  if (id == 0x0000024D) return "XUIElementPropVal_Construct";
  if (id == 0x0000024E) return "XUIElementPropVal_Destruct";
  if (id == 0x0000024F) return "XUIElementPropVal_SetString";
  if (id == 0x00000250) return "XuiObjectSetProperty";
  if (id == 0x00000251) return "XuiElementGetOpacity";
  if (id == 0x00000252) return "XuiElementSetOpacity";
  if (id == 0x00000253) return "XuiEditSetTextLimit";
  if (id == 0x00000254) return "XuiEditGetTextLimit";
  if (id == 0x00000255) return "XuiSliderSetValue";
  if (id == 0x00000256) return "XuiSliderGetValue";
  if (id == 0x00000257) return "XuiSliderSetRange";
  if (id == 0x00000258) return "XuiElementUnlink";
  if (id == 0x00000259) return "XuiElementInsertChild";
  if (id == 0x0000025A) return "XuiSceneNavigateBackToFirst";
  if (id == 0x0000025B) return "XuiProgressBarSetRange";
  if (id == 0x0000025C) return "XuiProgressBarSetValue";
  if (id == 0x0000025D) return "XuiProgressBarGetValue";
  if (id == 0x0000025E) return "XuiControlAttachVisual";
  if (id == 0x0000025F) return "XuiCreateTextureBrush";
  if (id == 0x00000260) return "XuiDestroyBrush";
  if (id == 0x00000261) return "XUIElementPropVal_SetColorFromUint";
  if (id == 0x00000262) return "XuiFigureSetFill";
  if (id == 0x00000263) return "XuiSliderGetRange";
  if (id == 0x00000264) return "XuiFigureSetTexture";
  if (id == 0x00000265) return "XuiControlGetItemAssociation";
  if (id == 0x00000266) return "XuiResourceLoadAll";
  if (id == 0x00000267) return "XuiImageElementSetImagePath";
  if (id == 0x00000268) return "XuiImageElementGetImagePath";
  if (id == 0x00000269) return "XuiControlGetVisual";
  if (id == 0x0000026A) return "XuiControlGetNavigation";
  if (id == 0x0000026B) return "XuiLookupStringTableByIndex";
  if (id == 0x0000026C) return "XUIElementPropVal_SetBool";
  if (id == 0x0000026D) return "XuiElementHasFocus";
  if (id == 0x0000026E) return "XUIElementPropVal_SetUint";
  if (id == 0x0000026F) return "XUIElementPropVal_Clear";
  if (id == 0x00000270) return "XuiEditSetTextFormatInfo";
  if (id == 0x00000271) return "XuiCreateSolidBrush";
  if (id == 0x00000272) return "XuiSceneInterruptTransitions";
  if (id == 0x00000273) return "XuiResourceOpen";
  if (id == 0x00000274) return "XuiResourceRead";
  if (id == 0x00000275) return "XuiResourceClose";
  if (id == 0x000002BC) return "XGetAudioFlags";
  if (id == 0x000002BD) return "XGetAVPack";
  if (id == 0x000002BE) return "XGetGameRegion";
  if (id == 0x000002BF) return "XGetLanguage";
  if (id == 0x000002C0) return "XGetParentalControlSetting";
  if (id == 0x000002C1) return "XGetVideoFlags";
  if (id == 0x000002C2) return "XGetVideoStandard";
  if (id == 0x000002C3) return "XGetVideoMode";
  if (id == 0x000002D0) return "XamSetDashContext";
  if (id == 0x000002D1) return "XamGetDashContext";
  if (id == 0x00000320) return "XamSetAutomation";
  if (id == 0x00000321) return "XAutomationpBindController";
  if (id == 0x00000322) return "XAutomationpUnbindController";
  if (id == 0x00000323) return "XAutomationpInputXenonButton";
  if (id == 0x00000324) return "XAutomationpInputPress";
  if (id == 0x00000325) return "XAutomationpInputSetState";
  if (id == 0x00000326) return "XamEnableOverdraw";
  if (id == 0x0000032A) return "g_XuiAutomation";
  if (id == 0x00000384) return "XamGetExecutionId";
  if (id == 0x00000385) return "XamGetSPAName";
  if (id == 0x0000038E) return "XamGetWCNConfigFile";
  if (id == 0x000003E8) return "RtlFindFirstFile";
  if (id == 0x000003E9) return "RtlFindNextFile";
  if (id == 0x000003EA) return "RtlGetModuleFileName";
  if (id == 0x000003EB) return "RtlOutputDebugString";
  if (id == 0x000003EC) return "RtlRemoveDirectory";
  if (id == 0x000003ED) return "RtlSleep";
  if (id == 0x000003EE) return "RtlGetLastError";
  if (id == 0x000003EF) return "RtlSetLastError";
  if (id == 0x000003F0) return "RtlSetLastNTError";
  if (id == 0x000003F7) return "RtlGetAttributesOnHeapAlloc";
  if (id == 0x000003F8) return "RtlSetAttributesOnHeapAlloc";
  if (id == 0x000003FA) return "RtlCreateHeap";
  if (id == 0x000003FB) return "RtlDestroyHeap";
  if (id == 0x000003FC) return "RtlAllocateHeap";
  if (id == 0x000003FD) return "RtlAllocateHeapSlowly";
  if (id == 0x000003FE) return "RtlReAllocateHeap";
  if (id == 0x000003FF) return "RtlFreeHeap";
  if (id == 0x00000400) return "RtlFreeHeapSlowly";
  if (id == 0x00000401) return "RtlSizeHeap";
  if (id == 0x00000402) return "RtlZeroHeap";
  if (id == 0x0000040E) return "OutputDebugStringA";
  if (id == 0x0000040F) return "DebugBreak";
  if (id == 0x00000410) return "GetCurrentThreadId";
  if (id == 0x00000414) return "CloseHandle";
  if (id == 0x00000415) return "GetTickCount";
  if (id == 0x00000416) return "GetLastError";
  if (id == 0x00000417) return "SetFilePointer";
  if (id == 0x00000418) return "SetFilePointerEx";
  if (id == 0x00000419) return "SetLastError";
  if (id == 0x0000041A) return "MultiByteToWideChar";
  if (id == 0x0000041B) return "WideCharToMultiByte";
  if (id == 0x0000041C) return "ReadFile";
  if (id == 0x0000041D) return "FlushFileBuffers";
  if (id == 0x0000041E) return "WriteFile";
  if (id == 0x0000041F) return "OutputDebugStringW";
  if (id == 0x00000420) return "SetEvent";
  if (id == 0x00000421) return "XapiFormatTimeOut";
  if (id == 0x00000422) return "CreateMutexA";
  if (id == 0x00000423) return "OpenMutexA";
  if (id == 0x00000424) return "ReleaseMutex";
  if (id == 0x00000425) return "WaitForSingleObject";
  if (id == 0x00000426) return "WaitForSingleObjectEx";
  if (id == 0x00000427) return "GetFileSize";
  if (id == 0x00000428) return "GetFileSizeEx";
  if (id == 0x00000429) return "XapiDirectoryInformationToFindData";
  if (id == 0x0000042A) return "XapiFormatObjectAttributes";
  if (id == 0x0000042B) return "ResetEvent";
  if (id == 0x0000042C) return "wsprintfA";
  if (id == 0x0000042D) return "wsprintfW";
  if (id == 0x0000042E) return "GetOverlappedResult";
  if (id == 0x0000042F) return "QueryPerformanceCounter";
  if (id == 0x00000430) return "QueryPerformanceFrequency";
  if (id == 0x00000431) return "LocalAlloc";
  if (id == 0x00000432) return "LocalFree";
  if (id == 0x00000433) return "RaiseException";
  if (id == 0x00000434) return "RtlUniform";
  if (id == 0x00000435) return "RtlRandom";
  if (id == 0x00000436) return "Sleep";
  if (id == 0x00000437) return "SleepEx";
  if (id == 0x00000438) return "XMemSet";
  if (id == 0x00000439) return "XRegisterThreadNotifyRoutine";
  if (id == 0x0000043A) return "XGetOverlappedExtendedError";
  if (id == 0x0000043B) return "XGetOverlappedResult";
  if (id == 0x0000043C) return "CreateThread";
  if (id == 0x0000043D) return "ResumeThread";
  if (id == 0x0000043E) return "ExitThread";
  if (id == 0x0000043F) return "GetTimeZoneInformation";
  if (id == 0x00000440) return "GetSystemTimeAsFileTime";
  if (id == 0x00000441) return "SystemTimeToFileTime";
  if (id == 0x00000442) return "FileTimeToSystemTime";
  if (id == 0x00000443) return "GetSystemTime";
  if (id == 0x00000444) return "GetLocalTime";
  if (id == 0x00000445) return "CreateDirectoryA";
  if (id == 0x00000446) return "CreateEventA";
  if (id == 0x00000447) return "CreateFileA";
  if (id == 0x00000448) return "DeleteFileA";
  if (id == 0x00000449) return "FindFirstFileA";
  if (id == 0x0000044A) return "FindNextFileA";
  if (id == 0x0000044B) return "GetFileAttributesA";
  if (id == 0x0000044D) return "GetFileAttributesExA";
  if (id == 0x0000044E) return "GetModuleHandleA";
  if (id == 0x0000044F) return "GetDiskFreeSpaceExA";
  if (id == 0x00000450) return "PIXAddEvent";
  if (id == 0x00000451) return "PIXBeginEvent";
  if (id == 0x00000452) return "PIXEndEvent";
  if (id == 0x00000453) return "PIXBeginCapture";
  if (id == 0x00000454) return "PIXEndCapture";
  if (id == 0x00000455) return "PIXAddCounter";
  if (id == 0x00000456) return "PIXWriteData";
  if (id == 0x00000457) return "SetWaitableTimer";
  if (id == 0x00000458) return "CancelWaitableTimer";
  if (id == 0x00000459) return "CreateWaitableTimerA";
  if (id == 0x0000045A) return "DuplicateHandle";
  if (id == 0x0000045B) return "XapipCreateThread";
  if (id == 0x0000045C) return "lstrcpyA";
  if (id == 0x0000045D) return "lstrcpyW";
  if (id == 0x0000045E) return "lstrcpynA";
  if (id == 0x0000045F) return "lstrcpynW";
  if (id == 0x00000460) return "lstrcatA";
  if (id == 0x00000461) return "lstrcatW";
  if (id == 0x00000462) return "lstrlenA";
  if (id == 0x00000463) return "lstrlenW";
  if (id == 0x00000464) return "IsBadReadPtr";
  if (id == 0x00000465) return "IsBadWritePtr";
  if (id == 0x000007D2) return "GetProcessHeap";
  if (id == 0x000007D3) return "UnhandledExceptionFilter";
  if (id == 0x000007D4) return "SetUnhandledExceptionFilter";

  return nullptr;
}

const char* xamNameGen_1746(int id)
{
  if (id == 0x00000001) return "NetDll_WSAStartup";
  if (id == 0x00000002) return "NetDll_WSACleanup";
  if (id == 0x00000003) return "NetDll_socket";
  if (id == 0x00000004) return "NetDll_closesocket";
  if (id == 0x00000005) return "NetDll_shutdown";
  if (id == 0x00000006) return "NetDll_ioctlsocket";
  if (id == 0x00000007) return "NetDll_setsockopt";
  if (id == 0x00000008) return "NetDll_getsockopt";
  if (id == 0x00000009) return "NetDll_getsockname";
  if (id == 0x0000000A) return "NetDll_getpeername";
  if (id == 0x0000000B) return "NetDll_bind";
  if (id == 0x0000000C) return "NetDll_connect";
  if (id == 0x0000000D) return "NetDll_listen";
  if (id == 0x0000000E) return "NetDll_accept";
  if (id == 0x0000000F) return "NetDll_select";
  if (id == 0x00000010) return "NetDll_WSAGetOverlappedResult";
  if (id == 0x00000011) return "NetDll_WSACancelOverlappedIO";
  if (id == 0x00000012) return "NetDll_recv";
  if (id == 0x00000013) return "NetDll_WSARecv";
  if (id == 0x00000014) return "NetDll_recvfrom";
  if (id == 0x00000015) return "NetDll_WSARecvFrom";
  if (id == 0x00000016) return "NetDll_send";
  if (id == 0x00000017) return "NetDll_WSASend";
  if (id == 0x00000018) return "NetDll_sendto";
  if (id == 0x00000019) return "NetDll_WSASendTo";
  if (id == 0x0000001A) return "NetDll_inet_addr";
  if (id == 0x0000001B) return "NetDll_WSAGetLastError";
  if (id == 0x0000001C) return "NetDll_WSASetLastError";
  if (id == 0x0000001D) return "NetDll_WSACreateEvent";
  if (id == 0x0000001E) return "NetDll_WSACloseEvent";
  if (id == 0x0000001F) return "NetDll_WSASetEvent";
  if (id == 0x00000020) return "NetDll_WSAResetEvent";
  if (id == 0x00000021) return "NetDll_WSAWaitForMultipleEvents";
  if (id == 0x00000022) return "NetDll___WSAFDIsSet";
  if (id == 0x00000023) return "NetDll_WSAEventSelect";
  if (id == 0x00000033) return "NetDll_XNetStartup";
  if (id == 0x00000034) return "NetDll_XNetCleanup";
  if (id == 0x00000035) return "NetDll_XNetRandom";
  if (id == 0x00000036) return "NetDll_XNetCreateKey";
  if (id == 0x00000037) return "NetDll_XNetRegisterKey";
  if (id == 0x00000038) return "NetDll_XNetUnregisterKey";
  if (id == 0x00000039) return "NetDll_XNetXnAddrToInAddr";
  if (id == 0x0000003A) return "NetDll_XNetServerToInAddr";
  if (id == 0x0000003B) return "NetDll_XNetTsAddrToInAddr";
  if (id == 0x0000003C) return "NetDll_XNetInAddrToXnAddr";
  if (id == 0x0000003D) return "NetDll_XNetInAddrToServer";
  if (id == 0x0000003E) return "NetDll_XNetInAddrToString";
  if (id == 0x0000003F) return "NetDll_XNetUnregisterInAddr";
  if (id == 0x00000040) return "NetDll_XNetXnAddrToMachineId";
  if (id == 0x00000041) return "NetDll_XNetConnect";
  if (id == 0x00000042) return "NetDll_XNetGetConnectStatus";
  if (id == 0x00000043) return "NetDll_XNetDnsLookup";
  if (id == 0x00000044) return "NetDll_XNetDnsRelease";
  if (id == 0x00000045) return "NetDll_XNetQosListen";
  if (id == 0x00000046) return "NetDll_XNetQosLookup";
  if (id == 0x00000047) return "NetDll_XNetQosServiceLookup";
  if (id == 0x00000048) return "NetDll_XNetQosRelease";
  if (id == 0x00000049) return "NetDll_XNetGetTitleXnAddr";
  if (id == 0x0000004A) return "NetDll_XNetGetDebugXnAddr";
  if (id == 0x0000004B) return "NetDll_XNetGetEthernetLinkStatus";
  if (id == 0x0000004C) return "NetDll_XNetGetBroadcastVersionStatus";
  if (id == 0x0000004D) return "NetDll_XNetQosGetListenStats";
  if (id == 0x0000004E) return "NetDll_XNetGetOpt";
  if (id == 0x0000004F) return "NetDll_XNetSetOpt";
  if (id == 0x00000065) return "NetDll_XnpLoadConfigParams";
  if (id == 0x00000066) return "NetDll_XnpSaveConfigParams";
  if (id == 0x00000067) return "NetDll_XnpConfigUPnP";
  if (id == 0x00000068) return "NetDll_XnpConfig";
  if (id == 0x00000069) return "NetDll_XnpGetConfigStatus";
  if (id == 0x0000006A) return "NetDll_XnpLoadMachineAccount";
  if (id == 0x0000006B) return "NetDll_XnpSaveMachineAccount";
  if (id == 0x0000006C) return "NetDll_XnpCapture";
  if (id == 0x0000006D) return "NetDll_XnpEthernetInterceptSetCallbacks";
  if (id == 0x0000006E) return "NetDll_XnpEthernetInterceptXmit";
  if (id == 0x0000006F) return "NetDll_XnpEthernetInterceptRecv";
  if (id == 0x00000070) return "NetDll_XnpLogonGetStatus";
  if (id == 0x00000071) return "NetDll_XnpLogonGetQFlags";
  if (id == 0x00000072) return "NetDll_XnpLogonSetQFlags";
  if (id == 0x00000073) return "NetDll_XnpLogonSetQEvent";
  if (id == 0x00000074) return "NetDll_XnpLogonClearQEvent";
  if (id == 0x00000075) return "NetDll_XnpLogonGetQVals";
  if (id == 0x00000076) return "NetDll_XnpLogonSetQVals";
  if (id == 0x00000077) return "NetDll_XnpLogonSetPState";
  if (id == 0x00000078) return "NetDll_XnpGetVlanXboxName";
  if (id == 0x00000079) return "NetDll_XnpSetVlanXboxName";
  if (id == 0x0000007A) return "NetDll_XnpGetActiveSocketList";
  if (id == 0x0000007B) return "NetDll_XnpNoteSystemTime";
  if (id == 0x0000007C) return "NetDll_XnpUpdateInAddrServiceId";
  if (id == 0x00000097) return "NetDll_XmlDownloadStart";
  if (id == 0x00000098) return "NetDll_XmlDownloadContinue";
  if (id == 0x00000099) return "NetDll_XmlDownloadStop";
  if (id == 0x000000C7) return "?D3DDevice_GetRenderState_Wrap10@D3D@@YAKPAUD3DDevice@@@Z";
  if (id == 0x000000C9) return "NetDll_XHttpStartup";
  if (id == 0x000000CA) return "NetDll_XHttpShutdown";
  if (id == 0x000000CB) return "NetDll_XHttpOpen";
  if (id == 0x000000CC) return "NetDll_XHttpCloseHandle";
  if (id == 0x000000CD) return "NetDll_XHttpConnect";
  if (id == 0x000000CE) return "NetDll_XHttpSetStatusCallback";
  if (id == 0x000000CF) return "NetDll_XHttpOpenRequest";
  if (id == 0x000000D0) return "NetDll_XHttpOpenRequestUsingMemory";
  if (id == 0x000000D1) return "NetDll_XHttpSendRequest";
  if (id == 0x000000D2) return "NetDll_XHttpReceiveResponse";
  if (id == 0x000000D3) return "NetDll_XHttpQueryHeaders";
  if (id == 0x000000D4) return "NetDll_XHttpReadData";
  if (id == 0x000000D5) return "NetDll_XHttpWriteData";
  if (id == 0x000000D6) return "NetDll_XHttpQueryOption";
  if (id == 0x000000D7) return "NetDll_XHttpSetOption";
  if (id == 0x000000D8) return "NetDll_XHttpDoWork";
  if (id == 0x000000FB) return "NetDll_UpnpStartup";
  if (id == 0x000000FC) return "NetDll_UpnpCleanup";
  if (id == 0x000000FD) return "NetDll_UpnpSearchCreate";
  if (id == 0x000000FE) return "NetDll_UpnpSearchGetDevices";
  if (id == 0x000000FF) return "NetDll_UpnpDescribeCreate";
  if (id == 0x00000100) return "NetDll_UpnpDescribeGetResults";
  if (id == 0x00000101) return "NetDll_UpnpActionCreate";
  if (id == 0x00000102) return "NetDll_UpnpActionGetResults";
  if (id == 0x00000103) return "NetDll_UpnpEventCreate";
  if (id == 0x00000104) return "NetDll_UpnpEventGetCurrentState";
  if (id == 0x00000105) return "NetDll_UpnpEventUnsubscribe";
  if (id == 0x00000106) return "NetDll_UpnpDoWork";
  if (id == 0x00000107) return "NetDll_UpnpCloseHandle";
  if (id == 0x0000012D) return "XNetLogonGetLoggedOnUsers";
  if (id == 0x0000012E) return "XNetLogonGetNatType";
  if (id == 0x0000012F) return "XNetLogonTaskStart";
  if (id == 0x00000130) return "XNetLogonTaskClose";
  if (id == 0x00000131) return "XNetLogonTaskContinue";
  if (id == 0x00000132) return "XNetLogonGetServiceInfo";
  if (id == 0x00000133) return "XNetLogonGetUserPrivileges";
  if (id == 0x00000134) return "?XNetLogonSetConsoleCertificate@@YAHPBU_CONSOLE_CERTIFICATE@@@Z";
  if (id == 0x00000135) return "XNetLogonGetMachineID";
  if (id == 0x00000136) return "XNetLogonGetTitleID";
  if (id == 0x00000137) return "XNetLogonGetTitleVersion";
  if (id == 0x00000138) return "XNetLogonGetServiceNetworkID";
  if (id == 0x00000139) return "XNetLogonGetDnsString";
  if (id == 0x0000013A) return "XNetLogonSetTitleID";
  if (id == 0x00000190) return "XamInputGetCapabilities";
  if (id == 0x00000191) return "XamInputGetState";
  if (id == 0x00000192) return "XamInputSetState";
  if (id == 0x00000193) return "XamInputGetKeystroke";
  if (id == 0x00000194) return "XamInputEnableAutobind";
  if (id == 0x00000195) return "?XamInputRawState@@YAKKKHPAU_XINPUT_RAW@@@Z";
  if (id == 0x00000196) return "XamEnableSystemAppInput";
  if (id == 0x00000197) return "XamInputGetDeviceStats";
  if (id == 0x00000198) return "XamInputGetKeystrokeEx";
  if (id == 0x00000199) return "XamInputGetKeystrokeHud";
  if (id == 0x0000019A) return "XamInputSetLayoutKeyboard";
  if (id == 0x0000019B) return "XamInputToggleKeyLocks";
  if (id == 0x000001A4) return "XLaunchNewImage";
  if (id == 0x000001A5) return "XLaunchNewImageEx";
  if (id == 0x000001A6) return "XSetLaunchData";
  if (id == 0x000001A7) return "XGetLaunchDataSize";
  if (id == 0x000001A8) return "XGetLaunchData";
  if (id == 0x000001A9) return "XamTerminateTitle";
  if (id == 0x000001AA) return "XGetTrayState";
  if (id == 0x000001AB) return "XamGetGameInfo";
  if (id == 0x000001AC) return "XLaunchMedia";
  if (id == 0x000001AE) return "XamTaskCreateQueue";
  if (id == 0x000001AF) return "XamTaskSchedule";
  if (id == 0x000001B0) return "XamTaskReschedule";
  if (id == 0x000001B1) return "XamTaskCloseHandle";
  if (id == 0x000001B2) return "XamTaskCancel";
  if (id == 0x000001B3) return "XamTaskShouldExit";
  if (id == 0x000001B4) return "XamTaskWaitOnCompletion";
  if (id == 0x000001B5) return "XamTaskModify";
  if (id == 0x000001B6) return "XamTaskGetCurrentTask";
  if (id == 0x000001B7) return "XamTaskGetAttributes";
  if (id == 0x000001B8) return "XamExecutingOnBehalfOfTitle";
  if (id == 0x000001C2) return "XamApplySkin";
  if (id == 0x000001C3) return "XamGetRootObj";
  if (id == 0x000001C4) return "XamFormatMessage";
  if (id == 0x000001C5) return "XamBuildResourceLocator";
  if (id == 0x000001C6) return "XamBuildSharedSystemResourceLocator";
  if (id == 0x000001C7) return "XamShowMessageBox";
  if (id == 0x000001C8) return "XCustomGetBannerImage";
  if (id == 0x000001C9) return "XCustomSetBannerImage";
  if (id == 0x000001CA) return "XCustomSetAction";
  if (id == 0x000001CB) return "XCustomGetLastActionPress";
  if (id == 0x000001CC) return "XCustomGetActionSetting";
  if (id == 0x000001CD) return "XCustomBroadcastActionEvent";
  if (id == 0x000001CE) return "XamGetBkgndDefault";
  if (id == 0x000001CF) return "XamGetDefaultSystemImage";
  if (id == 0x000001D0) return "XamFormatTimeString";
  if (id == 0x000001D2) return "XamFormatDateString";
  if (id == 0x000001D3) return "?D3DDevice_GetRenderState_Wrap10@D3D@@YAKPAUD3DDevice@@@Z";
  if (id == 0x000001D4) return "XamEnableInactivityProcessing";
  if (id == 0x000001D5) return "XamSetInactivityTime";
  if (id == 0x000001D6) return "XamSetDashContext";
  if (id == 0x000001D7) return "XamGetDashContext";
  if (id == 0x000001D8) return "XamGetCurrentTitleId";
  if (id == 0x000001D9) return "XamGetWCNConfigFile";
  if (id == 0x000001EA) return "XamAlloc";
  if (id == 0x000001EB) return "XamAllocEx";
  if (id == 0x000001EC) return "XamFree";
  if (id == 0x000001ED) return "XamAllocSize";
  if (id == 0x000001F4) return "XMsgInProcessCall";
  if (id == 0x000001F5) return "XMsgCompleteIORequest";
  if (id == 0x000001F6) return "XMsgSystemProcessCall";
  if (id == 0x000001F7) return "XMsgStartIORequest";
  if (id == 0x000001F8) return "XMsgCancelIORequest";
  if (id == 0x000001F9) return "XMsgAcquireAsyncMessageFromOverlapped";
  if (id == 0x000001FA) return "XMsgReleaseAsyncMessageToOverlapped";
  if (id == 0x000001FB) return "XamGetOverlappedResult";
  if (id == 0x000001FC) return "XMsgStartIORequestEx";
  if (id == 0x00000208) return "XamUserGetDeviceContext";
  if (id == 0x00000209) return "XamUserLookupDevice";
  if (id == 0x0000020A) return "XamUserGetXUID";
  if (id == 0x0000020B) return "XamUserLogon";
  if (id == 0x0000020C) return "XamUserGetGamerTag";
  if (id == 0x0000020D) return "XamUserGetUserIndexMask";
  if (id == 0x0000020E) return "XamUserGetName";
  if (id == 0x00000210) return "XamUserGetSigninState";
  if (id == 0x00000211) return "XamUserGetIndexFromXUID";
  if (id == 0x00000212) return "XamUserCheckPrivilege";
  if (id == 0x00000213) return "XamUserAreUsersFriends";
  if (id == 0x00000214) return "XamSetUserPresetPresenceState";
  if (id == 0x00000215) return "XamGetUserPresetPresenceState";
  if (id == 0x00000216) return "XamUserGetUserFlagsFromXUID";
  if (id == 0x00000217) return "XamUserGetMembershipTierFromXUID";
  if (id == 0x00000218) return "XamUserGetOnlineCountryFromXUID";
  if (id == 0x00000219) return "XamUserReadProfileSettings";
  if (id == 0x0000021A) return "XamUserWriteProfileSettings";
  if (id == 0x0000021B) return "XamUserGetMembershipTier";
  if (id == 0x0000021C) return "XamUserGetUserFlags";
  if (id == 0x0000021D) return "XamUserGetRequestedUserIndexMask";
  if (id == 0x0000021E) return "XamUserIsGuest";
  if (id == 0x0000021F) return "XamUserProfileSync";
  if (id == 0x00000220) return "XamUserFlushLogonQueue";
  if (id == 0x00000221) return "XamUserIsOnlineEnabled";
  if (id == 0x00000230) return "XamProfileCreate";
  if (id == 0x00000231) return "XamProfileCreateEnumerator";
  if (id == 0x00000232) return "XamProfileEnumerate";
  if (id == 0x00000233) return "XamProfileDelete";
  if (id == 0x00000234) return "XamProfileGetCreationStatus";
  if (id == 0x00000235) return "XamProfileFindAccount";
  if (id == 0x00000236) return "XamProfileRenameAccount";
  if (id == 0x00000237) return "XamProfileOpen";
  if (id == 0x00000238) return "XamProfileClose";
  if (id == 0x00000239) return "XamProfileSaveAccountInfo";
  if (id == 0x0000023A) return "XamProfileLoadAccountInfo";
  if (id == 0x00000244) return "XamAppLoad";
  if (id == 0x00000245) return "XamAppUnloadSelf";
  if (id == 0x00000246) return "XamAppUnloadStack";
  if (id == 0x00000247) return "XamSendMessageToLoadedApps";
  if (id == 0x00000248) return "XamAppRequestLoad";
  if (id == 0x00000249) return "XamAppUnrequestLoad";
  if (id == 0x0000024A) return "XamNavigate";
  if (id == 0x0000024B) return "XamRegisterSysApp";
  if (id == 0x0000024C) return "XamUnregisterSysApp";
  if (id == 0x00000258) return "XamContentCreate";
  if (id == 0x00000259) return "XamContentDelete";
  if (id == 0x0000025A) return "XamContentClose";
  if (id == 0x0000025B) return "XamContentCreateEnumerator";
  if (id == 0x0000025C) return "XamContentCreateDeviceEnumerator";
  if (id == 0x0000025D) return "XamContentGetDeviceData";
  if (id == 0x0000025E) return "XamContentGetDeviceName";
  if (id == 0x0000025F) return "XamContentSetThumbnail";
  if (id == 0x00000260) return "XamCreateEnumeratorHandle";
  if (id == 0x00000261) return "XamGetPrivateEnumStructureFromHandle";
  if (id == 0x00000262) return "XamEnumerate";
  if (id == 0x00000263) return "XamContentGetThumbnail";
  if (id == 0x00000264) return "XamContentGetCreator";
  if (id == 0x00000265) return "XamContentLaunchImage";
  if (id == 0x0000026C) return "XamContentCopyInternal";
  if (id == 0x0000026D) return "XamContentMoveInternal";
  if (id == 0x0000026E) return "XamContentGetMetaDataInternal";
  if (id == 0x0000026F) return "XamContentCreateEnumeratorInternal";
  if (id == 0x00000270) return "XamContentAggregateCreateEnumerator";
  if (id == 0x00000271) return "XamContentDeleteInternal";
  if (id == 0x00000272) return "XamContentCreateInternal";
  if (id == 0x00000273) return "XamContentCreateAndMountPackage";
  if (id == 0x00000274) return "XamContentSetThumbnailInternal";
  if (id == 0x00000275) return "XamContentLaunchImageInternal";
  if (id == 0x00000276) return "XamContentOpenPackageFile";
  if (id == 0x00000277) return "XamContentMountPackage";
  if (id == 0x00000278) return "XamContentWritePackageHeader";
  if (id == 0x00000279) return "XamContentFlushPackage";
  if (id == 0x0000027A) return "XamContentDismountAndClosePackage";
  if (id == 0x0000027B) return "XamContentClosePackageFile";
  if (id == 0x00000280) return "XamGetExecutionId";
  if (id == 0x00000281) return "XamGetSPAName";
  if (id == 0x0000028A) return "XamNotifyCreateListener";
  if (id == 0x0000028B) return "XNotifyGetNext";
  if (id == 0x0000028C) return "XNotifyPositionUI";
  if (id == 0x0000028D) return "XNotifyDelayUI";
  if (id == 0x0000028E) return "XNotifyBroadcast";
  if (id == 0x0000028F) return "XNotifyRegisterArea";
  if (id == 0x00000290) return "XNotifyQueueUI";
  if (id == 0x00000291) return "XamNotifyCreateListenerInternal";
  if (id == 0x00000292) return "XNotifyUISetOptions";
  if (id == 0x00000293) return "XNotifyUIGetOptions";
  if (id == 0x0000029E) return "XamUpdateStart";
  if (id == 0x0000029F) return "XamUpdateGetProgress";
  if (id == 0x000002A0) return "XamUpdateGetExtenderInstance";
  if (id == 0x000002A1) return "XamUpdateFinish";
  if (id == 0x000002A2) return "XamUpdateAttachExtenderInstance";
  if (id == 0x000002B2) return "XamCacheStoreFile";
  if (id == 0x000002B3) return "XamCacheFetchFile";
  if (id == 0x000002B4) return "XamCacheOpenFile";
  if (id == 0x000002B5) return "XamCacheCloseFile";
  if (id == 0x000002B6) return "XamGetCachedTitleName";
  if (id == 0x000002B7) return "XamCacheReset";
  if (id == 0x000002BD) return "XamShowSigninUI";
  if (id == 0x000002BE) return "XamShowSigninUIp";
  if (id == 0x000002BF) return "XamShowFriendsUI";
  if (id == 0x000002C0) return "XamShowMessagesUI";
  if (id == 0x000002C1) return "XamShowKeyboardUI";
  if (id == 0x000002C2) return "XamShowQuickChatUI";
  if (id == 0x000002C3) return "XamShowVoiceMailUI";
  if (id == 0x000002C4) return "XamShowGamerCardUI";
  if (id == 0x000002C5) return "XamShowAchievementsUI";
  if (id == 0x000002C6) return "XamShowPlayerReviewUI";
  if (id == 0x000002C7) return "XamShowMarketplaceUI";
  if (id == 0x000002C8) return "XamShowPlayersUI";
  if (id == 0x000002C9) return "XamShowUpdaterUI";
  if (id == 0x000002CA) return "XamShowMessageBoxUI";
  if (id == 0x000002CB) return "XamShowDeviceSelectorUI";
  if (id == 0x000002CC) return "XamShowMessageComposeUI";
  if (id == 0x000002CD) return "XamShowGameInviteUI";
  if (id == 0x000002CE) return "XamShowFriendRequestUI";
  if (id == 0x000002CF) return "XamShowCreateProfileUI";
  if (id == 0x000002D0) return "XamShowGamesUI";
  if (id == 0x000002D1) return "XamShowLiveSignupUI";
  if (id == 0x000002D2) return "XamShowFriendsUIp";
  if (id == 0x000002D3) return "XamShowComplaintUI";
  if (id == 0x000002D4) return "XamShowReputationUI";
  if (id == 0x000002D5) return "XamShowGamerCardUIForXUID";
  if (id == 0x000002D6) return "XamShowForcedNameChangeUI";
  if (id == 0x000002D7) return "XamShowLiveUpsellUI";
  if (id == 0x000002D8) return "XamShowSigninUIEx";
  if (id == 0x000002EE) return "XamUserCreateAchievementEnumerator";
  if (id == 0x000002EF) return "XamReadTile";
  if (id == 0x000002F0) return "XamWriteGamerTile";
  if (id == 0x000002F1) return "XamWriteTile";
  if (id == 0x000002F2) return "?XamReadImage@@YAJW4XTILETYPE@@KK_KPAPAU_XUIBRUSH@@@Z";
  if (id == 0x000002F3) return "XamUserCreateTitlesPlayedEnumerator";
  if (id == 0x000002F4) return "XamDecompressPNGToTexture";
  if (id == 0x000002F5) return "XamReadTileToTexture";
  if (id == 0x000002F6) return "XamReadString";
  if (id == 0x000002F7) return "XamUserCreateStatsEnumerator";
  if (id == 0x00000302) return "XamUserAddRecentPlayer";
  if (id == 0x00000303) return "XamUserUpdateRecentPlayer";
  if (id == 0x00000304) return "XamUserCreatePlayerEnumerator";
  if (id == 0x00000305) return "XamParseGamerTileKey";
  if (id == 0x0000030C) return "XamVoiceCreate";
  if (id == 0x0000030D) return "XamVoiceSubmitPacket";
  if (id == 0x0000030E) return "XamVoiceClose";
  if (id == 0x00000320) return "XuiAnimRun";
  if (id == 0x00000321) return "XuiApplyLocale";
  if (id == 0x00000322) return "XuiBubbleMessage";
  if (id == 0x00000323) return "XuiControlIsBackButton";
  if (id == 0x00000324) return "XuiControlIsNavButton";
  if (id == 0x00000325) return "XuiCreateObject";
  if (id == 0x00000326) return "XuiDestroyObject";
  if (id == 0x00000327) return "XuiDynamicCast";
  if (id == 0x00000328) return "XuiElementAddChild";
  if (id == 0x00000329) return "XuiElementFindNamedFrame";
  if (id == 0x0000032A) return "XuiElementGetChildById";
  if (id == 0x0000032B) return "XuiElementGetFirstChild";
  if (id == 0x0000032C) return "XuiElementGetFocus";
  if (id == 0x0000032D) return "XuiElementGetFocusUser";
  if (id == 0x0000032E) return "XuiElementGetId";
  if (id == 0x0000032F) return "XuiElementGetLastChild";
  if (id == 0x00000330) return "XuiElementGetNext";
  if (id == 0x00000331) return "XuiElementGetParent";
  if (id == 0x00000332) return "XuiElementGetUserFocus";
  if (id == 0x00000333) return "XuiElementInitFocus";
  if (id == 0x00000334) return "XuiElementInitUserFocus";
  if (id == 0x00000335) return "XuiElementPlayTimeline";
  if (id == 0x00000336) return "XuiElementSetBounds";
  if (id == 0x00000337) return "XuiElementSetFocus";
  if (id == 0x00000338) return "XuiElementSetUserFocus";
  if (id == 0x00000339) return "XuiElementTreeGetFocus";
  if (id == 0x0000033A) return "XuiFindClass";
  if (id == 0x0000033B) return "XuiFreeStringTable";
  if (id == 0x0000033C) return "XuiGetBaseObject";
  if (id == 0x0000033D) return "XuiGetClass";
  if (id == 0x0000033E) return "XuiGetObjectClass";
  if (id == 0x0000033F) return "XuiGetOuter";
  if (id == 0x00000340) return "XuiInit";
  if (id == 0x00000341) return "XuiLoadFromBinary";
  if (id == 0x00000342) return "XuiLoadStringTableFromFile";
  if (id == 0x00000343) return "XuiVisualGetBasePath";
  if (id == 0x00000344) return "XuiLookupStringTable";
  if (id == 0x00000345) return "XuiNavButtonGetPressPath";
  if (id == 0x00000346) return "XuiObjectFromHandle";
  if (id == 0x00000347) return "XuiObjectGetProperty";
  if (id == 0x00000348) return "XuiObjectGetPropertyId";
  if (id == 0x00000349) return "XuiProcessInput";
  if (id == 0x0000034A) return "XuiRegisterClass";
  if (id == 0x0000034B) return "XuiRenderBegin";
  if (id == 0x0000034C) return "XuiRenderCreateDC";
  if (id == 0x0000034D) return "XuiRenderDCDeviceChanged";
  if (id == 0x0000034E) return "XuiRenderDestroyDC";
  if (id == 0x0000034F) return "XuiRenderEnd";
  if (id == 0x00000350) return "XuiRenderGetBackBufferSize";
  if (id == 0x00000351) return "XuiRenderInit";
  if (id == 0x00000352) return "XuiRenderInitShared";
  if (id == 0x00000353) return "XuiRenderPresent";
  if (id == 0x00000354) return "XuiRenderSetViewTransform";
  if (id == 0x00000355) return "XuiRenderUninit";
  if (id == 0x00000357) return "XuiSceneCreate";
  if (id == 0x00000358) return "XuiSceneNavigateBack";
  if (id == 0x00000359) return "XuiSceneNavigateFirst";
  if (id == 0x0000035A) return "XuiSceneNavigateForward";
  if (id == 0x0000035B) return "XuiScenePlayBackFromTransition";
  if (id == 0x0000035C) return "XuiScenePlayBackToTransition";
  if (id == 0x0000035D) return "XuiScenePlayFromTransition";
  if (id == 0x0000035E) return "XuiScenePlayToTransition";
  if (id == 0x0000035F) return "XuiSendMessage";
  if (id == 0x00000360) return "XuiSetLocale";
  if (id == 0x00000361) return "XuiUninit";
  if (id == 0x00000362) return "XuiUnregisterClass";
  if (id == 0x00000363) return "XuiTextElementSetText";
  if (id == 0x00000364) return "XuiSetTimer";
  if (id == 0x00000365) return "XuiTimersRun";
  if (id == 0x00000366) return "XuiTextElementGetText";
  if (id == 0x00000367) return "XuiVisualSetBasePath";
  if (id == 0x00000368) return "XuiHandleIsValid";
  if (id == 0x00000369) return "XuiAlloc";
  if (id == 0x0000036A) return "XuiFree";
  if (id == 0x0000036B) return "XuiDefault_True";
  if (id == 0x0000036C) return "XuiDefault_EmptyString";
  if (id == 0x0000036D) return "XuiDefault_IntegerZero";
  if (id == 0x0000036E) return "XuiCopyString";
  if (id == 0x0000036F) return "XuiRealloc";
  if (id == 0x00000370) return "XuiControlPlayOptionalVisual";
  if (id == 0x00000371) return "XuiKillTimer";
  if (id == 0x00000372) return "XuiElementEnableInput";
  if (id == 0x00000373) return "XuiElementInputEnabled";
  if (id == 0x00000374) return "XuiIsInstanceOf";
  if (id == 0x00000375) return "XuiResourceComposeLocator";
  if (id == 0x00000376) return "XuiResourceLocatorIsAbsolute";
  if (id == 0x00000377) return "XuiBroadcastMessage";
  if (id == 0x00000378) return "XuiElementDisallowRecursiveTimelineControl";
  if (id == 0x00000379) return "XUIElementPropVal_Construct";
  if (id == 0x0000037A) return "XUIElementPropVal_Destruct";
  if (id == 0x0000037B) return "XUIElementPropVal_SetString";
  if (id == 0x0000037C) return "XuiObjectSetProperty";
  if (id == 0x0000037D) return "XuiElementGetOpacity";
  if (id == 0x0000037E) return "XuiElementSetOpacity";
  if (id == 0x0000037F) return "XuiEditSetTextLimit";
  if (id == 0x00000380) return "XuiEditGetTextLimit";
  if (id == 0x00000381) return "XuiSliderSetValue";
  if (id == 0x00000382) return "XuiSliderGetValue";
  if (id == 0x00000383) return "XuiSliderSetRange";
  if (id == 0x00000384) return "XuiElementUnlink";
  if (id == 0x00000385) return "XuiElementInsertChild";
  if (id == 0x00000386) return "XuiSceneNavigateBackToFirst";
  if (id == 0x00000387) return "XuiProgressBarSetRange";
  if (id == 0x00000388) return "XuiProgressBarSetValue";
  if (id == 0x00000389) return "XuiProgressBarGetValue";
  if (id == 0x0000038A) return "XuiControlAttachVisual";
  if (id == 0x0000038B) return "XuiCreateTextureBrush";
  if (id == 0x0000038C) return "XuiDestroyBrush";
  if (id == 0x0000038D) return "XUIElementPropVal_SetColorFromUint";
  if (id == 0x0000038E) return "XuiFigureSetFill";
  if (id == 0x0000038F) return "XuiSliderGetRange";
  if (id == 0x00000390) return "XuiFigureSetTexture";
  if (id == 0x00000391) return "XuiControlGetItemAssociation";
  if (id == 0x00000392) return "XuiResourceLoadAll";
  if (id == 0x00000393) return "XuiImageElementSetImagePath";
  if (id == 0x00000394) return "XuiImageElementGetImagePath";
  if (id == 0x00000395) return "XuiControlGetVisual";
  if (id == 0x00000396) return "XuiControlGetNavigation";
  if (id == 0x00000397) return "XuiLookupStringTableByIndex";
  if (id == 0x00000398) return "XUIElementPropVal_SetBool";
  if (id == 0x00000399) return "XuiElementHasFocus";
  if (id == 0x0000039A) return "XUIElementPropVal_SetUint";
  if (id == 0x0000039B) return "XUIElementPropVal_Clear";
  if (id == 0x0000039C) return "XuiEditSetTextFormatInfo";
  if (id == 0x0000039D) return "XuiCreateSolidBrush";
  if (id == 0x0000039E) return "XuiSceneInterruptTransitions";
  if (id == 0x0000039F) return "XuiResourceOpen";
  if (id == 0x000003A0) return "XuiResourceRead";
  if (id == 0x000003A1) return "XuiResourceClose";
  if (id == 0x000003A2) return "XuiVisualCreateInstance";
  if (id == 0x000003A3) return "XuiElementGetTimeline";
  if (id == 0x000003A4) return "?GetCodecVersion@CCalMediaInfo@@UBAKXZ";
  if (id == 0x000003A5) return "XuiElementIsDescendant";
  if (id == 0x000003A6) return "XuiSetMessageFilter";
  if (id == 0x000003A7) return "XamContentGetDeviceState";
  if (id == 0x000003CA) return "XGetAudioFlags";
  if (id == 0x000003CB) return "XGetAVPack";
  if (id == 0x000003CC) return "XGetGameRegion";
  if (id == 0x000003CD) return "XGetLanguage";
  if (id == 0x000003CE) return "XGetParentalControlSetting";
  if (id == 0x000003CF) return "XGetVideoFlags";
  if (id == 0x000003D0) return "XGetVideoStandard";
  if (id == 0x000003D1) return "XGetVideoMode";
  if (id == 0x000003D2) return "XGetLocale";
  if (id == 0x000003D4) return "XamSetAutomation";
  if (id == 0x000003D5) return "XAutomationpBindController";
  if (id == 0x000003D6) return "XAutomationpUnbindController";
  if (id == 0x000003D7) return "XAutomationpInputXenonButton";
  if (id == 0x000003D8) return "XAutomationpInputPress";
  if (id == 0x000003D9) return "XAutomationpInputSetState";
  if (id == 0x000003DA) return "XamEnableOverdraw";
  if (id == 0x000003DB) return "g_XuiAutomation";
  if (id == 0x000003E8) return "RtlFindFirstFile";
  if (id == 0x000003E9) return "RtlFindNextFile";
  if (id == 0x000003EA) return "RtlGetModuleFileName";
  if (id == 0x000003EB) return "RtlOutputDebugString";
  if (id == 0x000003EC) return "RtlRemoveDirectory";
  if (id == 0x000003ED) return "RtlSleep";
  if (id == 0x000003EE) return "RtlGetLastError";
  if (id == 0x000003EF) return "RtlSetLastError";
  if (id == 0x000003F0) return "RtlSetLastNTError";
  if (id == 0x000003F7) return "RtlGetAttributesOnHeapAlloc";
  if (id == 0x000003F8) return "RtlSetAttributesOnHeapAlloc";
  if (id == 0x000003FA) return "RtlCreateHeap";
  if (id == 0x000003FB) return "RtlDestroyHeap";
  if (id == 0x000003FC) return "RtlAllocateHeap";
  if (id == 0x000003FD) return "RtlAllocateHeapSlowly";
  if (id == 0x000003FE) return "RtlReAllocateHeap";
  if (id == 0x000003FF) return "RtlFreeHeap";
  if (id == 0x00000400) return "RtlFreeHeapSlowly";
  if (id == 0x00000401) return "RtlSizeHeap";
  if (id == 0x00000402) return "RtlZeroHeap";
  if (id == 0x0000040E) return "OutputDebugStringA";
  if (id == 0x0000040F) return "DebugBreak";
  if (id == 0x00000410) return "GetCurrentThreadId";
  if (id == 0x00000414) return "CloseHandle";
  if (id == 0x00000415) return "GetTickCount";
  if (id == 0x00000416) return "GetLastError";
  if (id == 0x00000417) return "SetFilePointer";
  if (id == 0x00000418) return "SetFilePointerEx";
  if (id == 0x00000419) return "SetLastError";
  if (id == 0x0000041A) return "MultiByteToWideChar";
  if (id == 0x0000041B) return "WideCharToMultiByte";
  if (id == 0x0000041C) return "ReadFile";
  if (id == 0x0000041D) return "FlushFileBuffers";
  if (id == 0x0000041E) return "WriteFile";
  if (id == 0x0000041F) return "OutputDebugStringW";
  if (id == 0x00000420) return "SetEvent";
  if (id == 0x00000421) return "XapiFormatTimeOut";
  if (id == 0x00000422) return "CreateMutexA";
  if (id == 0x00000423) return "OpenMutexA";
  if (id == 0x00000424) return "ReleaseMutex";
  if (id == 0x00000425) return "WaitForSingleObject";
  if (id == 0x00000426) return "WaitForSingleObjectEx";
  if (id == 0x00000427) return "GetFileSize";
  if (id == 0x00000428) return "GetFileSizeEx";
  if (id == 0x00000429) return "XapiDirectoryInformationToFindData";
  if (id == 0x0000042A) return "XapiFormatObjectAttributes";
  if (id == 0x0000042B) return "ResetEvent";
  if (id == 0x0000042C) return "wsprintfA";
  if (id == 0x0000042D) return "wsprintfW";
  if (id == 0x0000042E) return "GetOverlappedResult";
  if (id == 0x0000042F) return "QueryPerformanceCounter";
  if (id == 0x00000430) return "QueryPerformanceFrequency";
  if (id == 0x00000431) return "LocalAlloc";
  if (id == 0x00000432) return "LocalFree";
  if (id == 0x00000433) return "RaiseException";
  if (id == 0x00000434) return "RtlUniform";
  if (id == 0x00000435) return "RtlRandom";
  if (id == 0x00000436) return "Sleep";
  if (id == 0x00000437) return "SleepEx";
  if (id == 0x00000438) return "XMemSet";
  if (id == 0x00000439) return "XRegisterThreadNotifyRoutine";
  if (id == 0x0000043A) return "XGetOverlappedExtendedError";
  if (id == 0x0000043B) return "XGetOverlappedResult";
  if (id == 0x0000043C) return "CreateThread";
  if (id == 0x0000043D) return "ResumeThread";
  if (id == 0x0000043E) return "ExitThread";
  if (id == 0x0000043F) return "GetTimeZoneInformation";
  if (id == 0x00000440) return "GetSystemTimeAsFileTime";
  if (id == 0x00000441) return "SystemTimeToFileTime";
  if (id == 0x00000442) return "FileTimeToSystemTime";
  if (id == 0x00000443) return "GetSystemTime";
  if (id == 0x00000444) return "GetLocalTime";
  if (id == 0x00000445) return "CreateDirectoryA";
  if (id == 0x00000446) return "CreateEventA";
  if (id == 0x00000447) return "CreateFileA";
  if (id == 0x00000448) return "DeleteFileA";
  if (id == 0x00000449) return "FindFirstFileA";
  if (id == 0x0000044A) return "FindNextFileA";
  if (id == 0x0000044B) return "GetFileAttributesA";
  if (id == 0x0000044D) return "GetFileAttributesExA";
  if (id == 0x0000044E) return "GetModuleHandleA";
  if (id == 0x0000044F) return "GetDiskFreeSpaceExA";
  if (id == 0x00000450) return "CopyFileA";
  if (id == 0x00000451) return "PIXAddEvent";
  if (id == 0x00000452) return "PIXBeginEvent";
  if (id == 0x00000453) return "PIXEndEvent";
  if (id == 0x00000454) return "PIXBeginCapture";
  if (id == 0x00000455) return "PIXEndCapture";
  if (id == 0x00000456) return "PIXAddCounter";
  if (id == 0x00000457) return "PIXWriteData";
  if (id == 0x00000458) return "SetWaitableTimer";
  if (id == 0x00000459) return "CancelWaitableTimer";
  if (id == 0x0000045A) return "CreateWaitableTimerA";
  if (id == 0x0000045B) return "DuplicateHandle";
  if (id == 0x0000045C) return "XapipCreateThread";
  if (id == 0x0000045D) return "lstrcpyA";
  if (id == 0x0000045E) return "lstrcpyW";
  if (id == 0x0000045F) return "lstrcpynA";
  if (id == 0x00000460) return "lstrcpynW";
  if (id == 0x00000461) return "lstrcatA";
  if (id == 0x00000462) return "lstrcatW";
  if (id == 0x00000463) return "lstrlenA";
  if (id == 0x00000464) return "lstrlenW";
  if (id == 0x00000465) return "IsBadReadPtr";
  if (id == 0x00000466) return "IsBadWritePtr";
  if (id == 0x000007D2) return "GetProcessHeap";
  if (id == 0x000007D3) return "UnhandledExceptionFilter";
  if (id == 0x000007D4) return "SetUnhandledExceptionFilter";

  return nullptr;
}

const char* xamNameGen_1838(int id)
{
  if (id == 0x00000001) return "NetDll_WSAStartup";
  if (id == 0x00000002) return "NetDll_WSACleanup";
  if (id == 0x00000003) return "NetDll_socket";
  if (id == 0x00000004) return "NetDll_closesocket";
  if (id == 0x00000005) return "NetDll_shutdown";
  if (id == 0x00000006) return "NetDll_ioctlsocket";
  if (id == 0x00000007) return "NetDll_setsockopt";
  if (id == 0x00000008) return "NetDll_getsockopt";
  if (id == 0x00000009) return "NetDll_getsockname";
  if (id == 0x0000000A) return "NetDll_getpeername";
  if (id == 0x0000000B) return "NetDll_bind";
  if (id == 0x0000000C) return "NetDll_connect";
  if (id == 0x0000000D) return "NetDll_listen";
  if (id == 0x0000000E) return "NetDll_accept";
  if (id == 0x0000000F) return "NetDll_select";
  if (id == 0x00000010) return "NetDll_WSAGetOverlappedResult";
  if (id == 0x00000011) return "NetDll_WSACancelOverlappedIO";
  if (id == 0x00000012) return "NetDll_recv";
  if (id == 0x00000013) return "NetDll_WSARecv";
  if (id == 0x00000014) return "NetDll_recvfrom";
  if (id == 0x00000015) return "NetDll_WSARecvFrom";
  if (id == 0x00000016) return "NetDll_send";
  if (id == 0x00000017) return "NetDll_WSASend";
  if (id == 0x00000018) return "NetDll_sendto";
  if (id == 0x00000019) return "NetDll_WSASendTo";
  if (id == 0x0000001A) return "NetDll_inet_addr";
  if (id == 0x0000001B) return "NetDll_WSAGetLastError";
  if (id == 0x0000001C) return "NetDll_WSASetLastError";
  if (id == 0x0000001D) return "NetDll_WSACreateEvent";
  if (id == 0x0000001E) return "NetDll_WSACloseEvent";
  if (id == 0x0000001F) return "NetDll_WSASetEvent";
  if (id == 0x00000020) return "NetDll_WSAResetEvent";
  if (id == 0x00000021) return "NetDll_WSAWaitForMultipleEvents";
  if (id == 0x00000022) return "NetDll___WSAFDIsSet";
  if (id == 0x00000023) return "NetDll_WSAEventSelect";
  if (id == 0x00000033) return "NetDll_XNetStartup";
  if (id == 0x00000034) return "NetDll_XNetCleanup";
  if (id == 0x00000035) return "NetDll_XNetRandom";
  if (id == 0x00000036) return "NetDll_XNetCreateKey";
  if (id == 0x00000037) return "NetDll_XNetRegisterKey";
  if (id == 0x00000038) return "NetDll_XNetUnregisterKey";
  if (id == 0x00000039) return "NetDll_XNetXnAddrToInAddr";
  if (id == 0x0000003A) return "NetDll_XNetServerToInAddr";
  if (id == 0x0000003B) return "NetDll_XNetTsAddrToInAddr";
  if (id == 0x0000003C) return "NetDll_XNetInAddrToXnAddr";
  if (id == 0x0000003D) return "NetDll_XNetInAddrToServer";
  if (id == 0x0000003E) return "NetDll_XNetInAddrToString";
  if (id == 0x0000003F) return "NetDll_XNetUnregisterInAddr";
  if (id == 0x00000040) return "NetDll_XNetXnAddrToMachineId";
  if (id == 0x00000041) return "NetDll_XNetConnect";
  if (id == 0x00000042) return "NetDll_XNetGetConnectStatus";
  if (id == 0x00000043) return "NetDll_XNetDnsLookup";
  if (id == 0x00000044) return "NetDll_XNetDnsRelease";
  if (id == 0x00000045) return "NetDll_XNetQosListen";
  if (id == 0x00000046) return "NetDll_XNetQosLookup";
  if (id == 0x00000047) return "NetDll_XNetQosServiceLookup";
  if (id == 0x00000048) return "NetDll_XNetQosRelease";
  if (id == 0x00000049) return "NetDll_XNetGetTitleXnAddr";
  if (id == 0x0000004A) return "NetDll_XNetGetDebugXnAddr";
  if (id == 0x0000004B) return "NetDll_XNetGetEthernetLinkStatus";
  if (id == 0x0000004C) return "NetDll_XNetGetBroadcastVersionStatus";
  if (id == 0x0000004D) return "NetDll_XNetQosGetListenStats";
  if (id == 0x0000004E) return "NetDll_XNetGetOpt";
  if (id == 0x0000004F) return "NetDll_XNetSetOpt";
  if (id == 0x00000065) return "NetDll_XnpLoadConfigParams";
  if (id == 0x00000066) return "NetDll_XnpSaveConfigParams";
  if (id == 0x00000067) return "NetDll_XnpConfigUPnP";
  if (id == 0x00000068) return "NetDll_XnpConfig";
  if (id == 0x00000069) return "NetDll_XnpGetConfigStatus";
  if (id == 0x0000006A) return "NetDll_XnpLoadMachineAccount";
  if (id == 0x0000006B) return "NetDll_XnpSaveMachineAccount";
  if (id == 0x0000006C) return "NetDll_XnpCapture";
  if (id == 0x0000006D) return "NetDll_XnpEthernetInterceptSetCallbacks";
  if (id == 0x0000006E) return "NetDll_XnpEthernetInterceptXmit";
  if (id == 0x0000006F) return "NetDll_XnpEthernetInterceptRecv";
  if (id == 0x00000070) return "NetDll_XnpLogonGetStatus";
  if (id == 0x00000071) return "NetDll_XnpLogonGetQFlags";
  if (id == 0x00000072) return "NetDll_XnpLogonSetQFlags";
  if (id == 0x00000073) return "NetDll_XnpLogonSetQEvent";
  if (id == 0x00000074) return "NetDll_XnpLogonClearQEvent";
  if (id == 0x00000075) return "NetDll_XnpLogonGetQVals";
  if (id == 0x00000076) return "NetDll_XnpLogonSetQVals";
  if (id == 0x00000077) return "NetDll_XnpLogonSetPState";
  if (id == 0x00000078) return "NetDll_XnpGetVlanXboxName";
  if (id == 0x00000079) return "NetDll_XnpSetVlanXboxName";
  if (id == 0x0000007A) return "NetDll_XnpGetActiveSocketList";
  if (id == 0x0000007B) return "NetDll_XnpNoteSystemTime";
  if (id == 0x0000007C) return "NetDll_XnpRegisterKeyForCallerType";
  if (id == 0x0000007D) return "NetDll_XnpUnregisterKeyForCallerType";
  if (id == 0x00000097) return "NetDll_XmlDownloadStart";
  if (id == 0x00000098) return "NetDll_XmlDownloadContinue";
  if (id == 0x00000099) return "NetDll_XmlDownloadStop";
  if (id == 0x000000C7) return "XnpGetXwppRuntimeFilter";
  if (id == 0x000000C9) return "NetDll_XHttpStartup";
  if (id == 0x000000CA) return "NetDll_XHttpShutdown";
  if (id == 0x000000CB) return "NetDll_XHttpOpen";
  if (id == 0x000000CC) return "NetDll_XHttpCloseHandle";
  if (id == 0x000000CD) return "NetDll_XHttpConnect";
  if (id == 0x000000CE) return "NetDll_XHttpSetStatusCallback";
  if (id == 0x000000CF) return "NetDll_XHttpOpenRequest";
  if (id == 0x000000D0) return "NetDll_XHttpOpenRequestUsingMemory";
  if (id == 0x000000D1) return "NetDll_XHttpSendRequest";
  if (id == 0x000000D2) return "NetDll_XHttpReceiveResponse";
  if (id == 0x000000D3) return "NetDll_XHttpQueryHeaders";
  if (id == 0x000000D4) return "NetDll_XHttpReadData";
  if (id == 0x000000D5) return "NetDll_XHttpWriteData";
  if (id == 0x000000D6) return "NetDll_XHttpQueryOption";
  if (id == 0x000000D7) return "NetDll_XHttpSetOption";
  if (id == 0x000000D8) return "NetDll_XHttpDoWork";
  if (id == 0x000000FB) return "NetDll_UpnpStartup";
  if (id == 0x000000FC) return "NetDll_UpnpCleanup";
  if (id == 0x000000FD) return "NetDll_UpnpSearchCreate";
  if (id == 0x000000FE) return "NetDll_UpnpSearchGetDevices";
  if (id == 0x000000FF) return "NetDll_UpnpDescribeCreate";
  if (id == 0x00000100) return "NetDll_UpnpDescribeGetResults";
  if (id == 0x00000101) return "NetDll_UpnpActionCreate";
  if (id == 0x00000102) return "NetDll_UpnpActionGetResults";
  if (id == 0x00000103) return "NetDll_UpnpEventCreate";
  if (id == 0x00000104) return "NetDll_UpnpEventGetCurrentState";
  if (id == 0x00000105) return "NetDll_UpnpEventUnsubscribe";
  if (id == 0x00000106) return "NetDll_UpnpDoWork";
  if (id == 0x00000107) return "NetDll_UpnpCloseHandle";
  if (id == 0x0000012D) return "XNetLogonGetLoggedOnUsers";
  if (id == 0x0000012E) return "XNetLogonGetNatType";
  if (id == 0x0000012F) return "XNetLogonTaskStart";
  if (id == 0x00000130) return "XNetLogonTaskClose";
  if (id == 0x00000131) return "XNetLogonTaskContinue";
  if (id == 0x00000132) return "XNetLogonGetServiceInfo";
  if (id == 0x00000133) return "XNetLogonGetUserPrivileges";
  if (id == 0x00000134) return "XNetLogonSetConsoleCertificate";
  if (id == 0x00000135) return "XNetLogonGetMachineID";
  if (id == 0x00000136) return "XNetLogonGetTitleID";
  if (id == 0x00000137) return "XNetLogonGetTitleVersion";
  if (id == 0x00000138) return "XNetLogonGetServiceNetworkID";
  if (id == 0x00000139) return "XNetLogonGetDnsString";
  if (id == 0x0000013A) return "XNetLogonSetTitleID";
  if (id == 0x0000013B) return "XNetLogonGetExtendedStatus";
  if (id == 0x0000013C) return "XNetLogonClearTicketCaches";
  if (id == 0x00000190) return "XamInputGetCapabilities";
  if (id == 0x00000191) return "XamInputGetState";
  if (id == 0x00000192) return "XamInputSetState";
  if (id == 0x00000193) return "XamInputGetKeystroke";
  if (id == 0x00000194) return "XamInputEnableAutobind";
  if (id == 0x00000195) return "?XamInputRawState@@YAKKKHPAU_XINPUT_RAW@@@Z";
  if (id == 0x00000196) return "XamEnableSystemAppInput";
  if (id == 0x00000197) return "XamInputGetDeviceStats";
  if (id == 0x00000198) return "XamInputGetKeystrokeEx";
  if (id == 0x00000199) return "XamInputGetKeystrokeHud";
  if (id == 0x0000019A) return "XamInputSetLayoutKeyboard";
  if (id == 0x0000019B) return "XamInputToggleKeyLocks";
  if (id == 0x000001A4) return "XamLaunchNewImage";
  if (id == 0x000001A5) return "XLaunchNewImageEx";
  if (id == 0x000001A6) return "XSetLaunchData";
  if (id == 0x000001A7) return "XGetLaunchDataSize";
  if (id == 0x000001A8) return "XGetLaunchData";
  if (id == 0x000001A9) return "XamTerminateTitle";
  if (id == 0x000001AA) return "XGetTrayState";
  if (id == 0x000001AB) return "?ProcessRemoteInput@XAMAuditionHost@@UAAJPBU_XINPUT_KEYSTROKE@@@Z";
  if (id == 0x000001AC) return "XLaunchMedia";
  if (id == 0x000001AE) return "XamTaskCreateQueue";
  if (id == 0x000001AF) return "XamTaskSchedule";
  if (id == 0x000001B0) return "XamTaskReschedule";
  if (id == 0x000001B1) return "XamTaskCloseHandle";
  if (id == 0x000001B2) return "XamTaskCancel";
  if (id == 0x000001B3) return "XamTaskShouldExit";
  if (id == 0x000001B4) return "XamTaskWaitOnCompletion";
  if (id == 0x000001B5) return "XamTaskModify";
  if (id == 0x000001B6) return "XamTaskGetCurrentTask";
  if (id == 0x000001B7) return "XamTaskGetAttributes";
  if (id == 0x000001B8) return "XamExecutingOnBehalfOfTitle";
  if (id == 0x000001C2) return "XamApplySkin";
  if (id == 0x000001C3) return "XamGetRootObj";
  if (id == 0x000001C4) return "XamFormatMessage";
  if (id == 0x000001C5) return "XamBuildResourceLocator";
  if (id == 0x000001C6) return "XamBuildSharedSystemResourceLocator";
  if (id == 0x000001C7) return "XamShowMessageBox";
  if (id == 0x000001C8) return "XCustomGetBannerImage";
  if (id == 0x000001C9) return "XamCustomSetBannerImage";
  if (id == 0x000001CA) return "XCustomSetAction";
  if (id == 0x000001CB) return "XCustomGetLastActionPress";
  if (id == 0x000001CC) return "XCustomGetActionSetting";
  if (id == 0x000001CD) return "XCustomBroadcastActionEvent";
  if (id == 0x000001CE) return "XamGetBkgndDefault";
  if (id == 0x000001CF) return "XamGetDefaultSystemImage";
  if (id == 0x000001D0) return "XamFormatTimeString";
  if (id == 0x000001D2) return "XamFormatDateString";
  if (id == 0x000001D3) return "XamDbgPrint";
  if (id == 0x000001D4) return "XamEnableInactivityProcessing";
  if (id == 0x000001D5) return "XamSetInactivityTime";
  if (id == 0x000001D6) return "XamSetDashContext";
  if (id == 0x000001D7) return "XamGetDashContext";
  if (id == 0x000001D8) return "XamGetCurrentTitleId";
  if (id == 0x000001D9) return "XamGetWCNConfigFile";
  if (id == 0x000001DA) return "XamIsCurrentTitleDash";
  if (id == 0x000001DB) return "XamResetInactivity";
  if (id == 0x000001DC) return "XamAreMixedAccountsSignedIn";
  if (id == 0x000001DD) return "XamBuildGamercardResourceLocator";
  if (id == 0x000001DE) return "XamSetInactivityTimeFromConfig";
  if (id == 0x000001DF) return "XamBuildDynamicResourceLocator";
  if (id == 0x000001E0) return "XamSetPowerMode";
  if (id == 0x000001E2) return "XamExecuteChallenge";
  if (id == 0x000001E3) return "XamIsSysUiInvokedByXenonButton";
  if (id == 0x000001E4) return "XamIsSysUiInvokedByTitle";
  if (id == 0x000001E5) return "XamUniSortCmpString";
  if (id == 0x000001EA) return "XamAlloc";
  if (id == 0x000001EB) return "XamAllocEx";
  if (id == 0x000001EC) return "XamFree";
  if (id == 0x000001ED) return "XamAllocSize";
  if (id == 0x000001F4) return "XMsgInProcessCall";
  if (id == 0x000001F5) return "XMsgCompleteIORequest";
  if (id == 0x000001F6) return "XMsgSystemProcessCall";
  if (id == 0x000001F7) return "XMsgStartIORequest";
  if (id == 0x000001F8) return "XMsgCancelIORequest";
  if (id == 0x000001F9) return "XMsgAcquireAsyncMessageFromOverlapped";
  if (id == 0x000001FA) return "XMsgReleaseAsyncMessageToOverlapped";
  if (id == 0x000001FB) return "XamGetOverlappedResult";
  if (id == 0x000001FC) return "XMsgStartIORequestEx";
  if (id == 0x00000208) return "XamUserGetDeviceContext";
  if (id == 0x00000209) return "XamUserLookupDevice";
  if (id == 0x0000020A) return "XamUserGetXUID";
  if (id == 0x0000020B) return "XamUserLogon";
  if (id == 0x0000020C) return "XamUserGetGamerTag";
  if (id == 0x0000020D) return "XamUserGetUserIndexMask";
  if (id == 0x0000020E) return "XamUserGetName";
  if (id == 0x00000210) return "XamUserGetSigninState";
  if (id == 0x00000211) return "XamUserGetIndexFromXUID";
  if (id == 0x00000212) return "XamUserCheckPrivilege";
  if (id == 0x00000213) return "XamUserAreUsersFriends";
  if (id == 0x00000214) return "XamSetUserPresetPresenceState";
  if (id == 0x00000215) return "XamGetUserPresetPresenceState";
  if (id == 0x00000216) return "XamUserGetUserFlagsFromXUID";
  if (id == 0x00000217) return "XamUserGetMembershipTierFromXUID";
  if (id == 0x00000218) return "XamUserGetOnlineCountryFromXUID";
  if (id == 0x00000219) return "XamUserReadProfileSettings";
  if (id == 0x0000021A) return "XamUserWriteProfileSettings";
  if (id == 0x0000021B) return "XamUserGetMembershipTier";
  if (id == 0x0000021C) return "XamUserGetUserFlags";
  if (id == 0x0000021D) return "XamUserGetRequestedUserIndexMask";
  if (id == 0x0000021E) return "XamUserIsGuest";
  if (id == 0x0000021F) return "XamUserProfileSync";
  if (id == 0x00000220) return "XamUserFlushLogonQueue";
  if (id == 0x00000221) return "XamUserIsOnlineEnabled";
  if (id == 0x00000230) return "XamProfileCreate";
  if (id == 0x00000231) return "XamProfileCreateEnumerator";
  if (id == 0x00000232) return "XamProfileEnumerate";
  if (id == 0x00000233) return "XamProfileDelete";
  if (id == 0x00000234) return "XamProfileGetCreationStatus";
  if (id == 0x00000235) return "XamProfileFindAccount";
  if (id == 0x00000236) return "XamProfileRenameAccount";
  if (id == 0x00000237) return "XamProfileOpen";
  if (id == 0x00000238) return "XamProfileClose";
  if (id == 0x00000239) return "XamProfileSaveAccountInfo";
  if (id == 0x0000023A) return "XamProfileLoadAccountInfo";
  if (id == 0x0000023B) return "XamProfileRecoverTitle";
  if (id == 0x00000244) return "XamAppLoad";
  if (id == 0x00000245) return "XamAppUnloadSelf";
  if (id == 0x00000246) return "XamAppUnloadStack";
  if (id == 0x00000247) return "XamSendMessageToLoadedApps";
  if (id == 0x00000248) return "XamAppRequestLoad";
  if (id == 0x00000249) return "XamAppUnrequestLoad";
  if (id == 0x0000024A) return "XamNavigate";
  if (id == 0x0000024B) return "XamRegisterSysApp";
  if (id == 0x0000024C) return "XamUnregisterSysApp";
  if (id == 0x00000258) return "XamContentCreate";
  if (id == 0x00000259) return "XamContentDelete";
  if (id == 0x0000025A) return "XamContentClose";
  if (id == 0x0000025B) return "XamContentCreateEnumerator";
  if (id == 0x0000025C) return "XamContentCreateDeviceEnumerator";
  if (id == 0x0000025D) return "XamContentGetDeviceData";
  if (id == 0x0000025E) return "XamContentGetDeviceName";
  if (id == 0x0000025F) return "XamContentSetThumbnail";
  if (id == 0x00000260) return "XamCreateEnumeratorHandle";
  if (id == 0x00000261) return "XamGetPrivateEnumStructureFromHandle";
  if (id == 0x00000262) return "XamEnumerate";
  if (id == 0x00000263) return "XamContentGetThumbnail";
  if (id == 0x00000264) return "XamContentGetCreator";
  if (id == 0x00000265) return "XamContentLaunchImage";
  if (id == 0x00000266) return "XamContentGetAttributes";
  if (id == 0x00000267) return "XamContentGetDeviceState";
  if (id == 0x00000268) return "XamContentGetLicenseMask";
  if (id == 0x00000269) return "XamContentFlush";
  if (id == 0x0000026C) return "XamContentCopyInternal";
  if (id == 0x0000026D) return "XamContentMoveInternal";
  if (id == 0x0000026E) return "XamContentGetMetaDataInternal";
  if (id == 0x0000026F) return "XamContentCreateEnumeratorInternal";
  if (id == 0x00000270) return "XamContentAggregateCreateEnumerator";
  if (id == 0x00000271) return "XamContentDeleteInternal";
  if (id == 0x00000272) return "XamContentCreateInternal";
  if (id == 0x00000273) return "XamContentCreateAndMountPackage";
  if (id == 0x00000274) return "XamContentSetThumbnailInternal";
  if (id == 0x00000275) return "XamContentLaunchImageInternal";
  if (id == 0x00000276) return "XamContentOpenPackageFile";
  if (id == 0x00000277) return "XamContentMountPackage";
  if (id == 0x00000278) return "XamContentWritePackageHeader";
  if (id == 0x00000279) return "XamContentFlushPackage";
  if (id == 0x0000027A) return "XamContentDismountAndClosePackage";
  if (id == 0x0000027B) return "XamContentClosePackageFile";
  if (id == 0x0000027C) return "XamContentResolve";
  if (id == 0x0000027D) return "XamContentResolveInternal";
  if (id == 0x0000027E) return "XamContentGetAttributesInternal";
  if (id == 0x00000280) return "XamGetExecutionId";
  if (id == 0x00000281) return "XamGetGameRatings";
  if (id == 0x00000282) return "XamGetSystemVersion";
  if (id == 0x0000028A) return "XamNotifyCreateListener";
  if (id == 0x0000028B) return "XNotifyGetNext";
  if (id == 0x0000028C) return "XNotifyPositionUI";
  if (id == 0x0000028D) return "XNotifyDelayUI";
  if (id == 0x0000028E) return "XNotifyBroadcast";
  if (id == 0x0000028F) return "XNotifyRegisterArea";
  if (id == 0x00000290) return "XNotifyQueueUI";
  if (id == 0x00000291) return "XamNotifyCreateListenerInternal";
  if (id == 0x00000292) return "XNotifyUISetOptions";
  if (id == 0x00000293) return "XNotifyUIGetOptions";
  if (id == 0x0000029E) return "XamUpdateStart";
  if (id == 0x0000029F) return "XamUpdateGetProgress";
  if (id == 0x000002A0) return "XamUpdateGetExtenderInstance";
  if (id == 0x000002A1) return "XamUpdateFinish";
  if (id == 0x000002A2) return "XamUpdateAttachExtenderInstance";
  if (id == 0x000002A3) return "XamUpdateAllocateExtenderBuffer";
  if (id == 0x000002A4) return "XamRestartAfterDeclinedUpdate";
  if (id == 0x000002A5) return "XamUIThreadDisableFontPatching";
  if (id == 0x000002B2) return "XamCacheStoreFile";
  if (id == 0x000002B3) return "XamCacheFetchFile";
  if (id == 0x000002B4) return "XamCacheOpenFile";
  if (id == 0x000002B5) return "XamCacheCloseFile";
  if (id == 0x000002B6) return "XamGetCachedTitleName";
  if (id == 0x000002B7) return "XamCacheReset";
  if (id == 0x000002B8) return "XamGetCachedGamerTag";
  if (id == 0x000002B9) return "XamGetCachedGamerTagW";
  if (id == 0x000002BC) return "XamShowSigninUI";
  if (id == 0x000002BD) return "XamShowSigninUIEx";
  if (id == 0x000002BE) return "XamShowSigninUIp";
  if (id == 0x000002BF) return "XamShowFriendsUI";
  if (id == 0x000002C0) return "XamShowMessagesUI";
  if (id == 0x000002C1) return "XamShowKeyboardUI";
  if (id == 0x000002C2) return "XamShowQuickChatUI";
  if (id == 0x000002C3) return "XamShowVoiceMailUI";
  if (id == 0x000002C4) return "XamShowGamerCardUI";
  if (id == 0x000002C5) return "XamShowAchievementsUI";
  if (id == 0x000002C6) return "XamShowPlayerReviewUI";
  if (id == 0x000002C7) return "XamShowMarketplaceUI";
  if (id == 0x000002C8) return "XamShowPlayersUI";
  if (id == 0x000002C9) return "XamShowUpdaterUI";
  if (id == 0x000002CA) return "XamShowMessageBoxUI";
  if (id == 0x000002CB) return "XamShowDeviceSelectorUI";
  if (id == 0x000002CC) return "XamShowMessageComposeUI";
  if (id == 0x000002CD) return "XamShowGameInviteUI";
  if (id == 0x000002CE) return "XamShowFriendRequestUI";
  if (id == 0x000002CF) return "XamShowCreateProfileUI";
  if (id == 0x000002D0) return "XamShowGamesUI";
  if (id == 0x000002D1) return "XamShowLiveSignupUI";
  if (id == 0x000002D2) return "XamShowFriendsUIp";
  if (id == 0x000002D3) return "XamShowComplaintUI";
  if (id == 0x000002D4) return "XamShowReputationUI";
  if (id == 0x000002D5) return "XamShowGamerCardUIForXUID";
  if (id == 0x000002D6) return "XamShowForcedNameChangeUI";
  if (id == 0x000002D7) return "XamShowLiveUpsellUI";
  if (id == 0x000002D8) return "XamShowPasscodeVerifyUI";
  if (id == 0x000002D9) return "XamShowDirtyDiscErrorUI";
  if (id == 0x000002DA) return "XamShowSignupCreditCardUI";
  if (id == 0x000002DB) return "XamShowPrivateChatInviteUI";
  if (id == 0x000002EE) return "XamUserCreateAchievementEnumerator";
  if (id == 0x000002EF) return "XamReadTile";
  if (id == 0x000002F0) return "XamWriteGamerTile";
  if (id == 0x000002F1) return "XamWriteTile";
  if (id == 0x000002F2) return "?XamReadImage@@YAJW4XTILETYPE@@KK_KPAPAU_XUIBRUSH@@@Z";
  if (id == 0x000002F3) return "XamUserCreateTitlesPlayedEnumerator";
  if (id == 0x000002F4) return "XamDecompressPNGToTexture";
  if (id == 0x000002F5) return "XamReadTileToTexture";
  if (id == 0x000002F6) return "XamReadString";
  if (id == 0x000002F7) return "XamUserCreateStatsEnumerator";
  if (id == 0x000002F8) return "XamPrepareGamerTiles";
  if (id == 0x00000302) return "XamUserAddRecentPlayer";
  if (id == 0x00000303) return "XamUserUpdateRecentPlayer";
  if (id == 0x00000304) return "XamUserCreatePlayerEnumerator";
  if (id == 0x00000305) return "XamParseGamerTileKey";
  if (id == 0x0000030C) return "XamVoiceCreate";
  if (id == 0x0000030D) return "XamVoiceHeadsetPresent";
  if (id == 0x0000030E) return "XamVoiceSubmitPacket";
  if (id == 0x0000030F) return "XamVoiceClose";
  if (id == 0x00000316) return "XamSessionCreateHandle";
  if (id == 0x00000317) return "XamSessionRefObjByHandle";
  if (id == 0x00000320) return "XuiAnimRun";
  if (id == 0x00000321) return "XuiApplyLocale";
  if (id == 0x00000322) return "XuiBubbleMessage";
  if (id == 0x00000323) return "XuiControlIsBackButton";
  if (id == 0x00000324) return "XuiControlIsNavButton";
  if (id == 0x00000325) return "XuiCreateObject";
  if (id == 0x00000326) return "XuiDestroyObject";
  if (id == 0x00000327) return "XuiDynamicCast";
  if (id == 0x00000328) return "XuiElementAddChild";
  if (id == 0x00000329) return "XuiElementFindNamedFrame";
  if (id == 0x0000032A) return "XuiElementGetChildById";
  if (id == 0x0000032B) return "XuiElementGetFirstChild";
  if (id == 0x0000032C) return "XuiElementGetFocus";
  if (id == 0x0000032D) return "XuiElementGetFocusUser";
  if (id == 0x0000032E) return "XuiElementGetId";
  if (id == 0x0000032F) return "XuiElementGetLastChild";
  if (id == 0x00000330) return "XuiElementGetNext";
  if (id == 0x00000331) return "XuiElementGetParent";
  if (id == 0x00000332) return "XuiElementGetUserFocus";
  if (id == 0x00000333) return "XuiElementInitFocus";
  if (id == 0x00000334) return "XuiElementInitUserFocus";
  if (id == 0x00000335) return "XuiElementPlayTimeline";
  if (id == 0x00000336) return "XuiElementSetBounds";
  if (id == 0x00000337) return "XuiElementSetFocus";
  if (id == 0x00000338) return "XuiElementSetUserFocus";
  if (id == 0x00000339) return "XuiElementTreeGetFocus";
  if (id == 0x0000033A) return "XuiFindClass";
  if (id == 0x0000033B) return "XuiFreeStringTable";
  if (id == 0x0000033C) return "XuiGetBaseObject";
  if (id == 0x0000033D) return "XuiGetClass";
  if (id == 0x0000033E) return "XuiGetObjectClass";
  if (id == 0x0000033F) return "XuiGetOuter";
  if (id == 0x00000340) return "XuiInit";
  if (id == 0x00000341) return "XuiLoadFromBinary";
  if (id == 0x00000342) return "XuiLoadStringTableFromFile";
  if (id == 0x00000343) return "XuiVisualGetBasePath";
  if (id == 0x00000344) return "XuiLookupStringTable";
  if (id == 0x00000345) return "XuiNavButtonGetPressPath";
  if (id == 0x00000346) return "XuiObjectFromHandle";
  if (id == 0x00000347) return "XuiObjectGetProperty";
  if (id == 0x00000348) return "XuiObjectGetPropertyId";
  if (id == 0x00000349) return "XuiProcessInput";
  if (id == 0x0000034A) return "XuiRegisterClass";
  if (id == 0x0000034B) return "XuiRenderBegin";
  if (id == 0x0000034C) return "XuiRenderCreateDC";
  if (id == 0x0000034D) return "XuiRenderDCDeviceChanged";
  if (id == 0x0000034E) return "XuiRenderDestroyDC";
  if (id == 0x0000034F) return "XuiRenderEnd";
  if (id == 0x00000350) return "XuiRenderGetBackBufferSize";
  if (id == 0x00000351) return "XuiRenderInit";
  if (id == 0x00000352) return "XuiRenderInitShared";
  if (id == 0x00000353) return "XuiRenderPresent";
  if (id == 0x00000354) return "XuiRenderSetViewTransform";
  if (id == 0x00000355) return "XuiRenderUninit";
  if (id == 0x00000357) return "XuiSceneCreate";
  if (id == 0x00000358) return "XuiSceneNavigateBack";
  if (id == 0x00000359) return "XuiSceneNavigateFirst";
  if (id == 0x0000035A) return "XuiSceneNavigateForward";
  if (id == 0x0000035B) return "XuiScenePlayBackFromTransition";
  if (id == 0x0000035C) return "XuiScenePlayBackToTransition";
  if (id == 0x0000035D) return "XuiScenePlayFromTransition";
  if (id == 0x0000035E) return "XuiScenePlayToTransition";
  if (id == 0x0000035F) return "XuiSendMessage";
  if (id == 0x00000360) return "XuiSetLocale";
  if (id == 0x00000361) return "XuiUninit";
  if (id == 0x00000362) return "XuiUnregisterClass";
  if (id == 0x00000363) return "XuiTextElementSetText";
  if (id == 0x00000364) return "XuiSetTimer";
  if (id == 0x00000365) return "XuiTimersRun";
  if (id == 0x00000366) return "XuiTextElementGetText";
  if (id == 0x00000367) return "XuiVisualSetBasePath";
  if (id == 0x00000368) return "XuiHandleIsValid";
  if (id == 0x00000369) return "XuiAlloc";
  if (id == 0x0000036A) return "XuiFree";
  if (id == 0x0000036B) return "XuiDefault_True";
  if (id == 0x0000036C) return "XuiDefault_EmptyString";
  if (id == 0x0000036D) return "XuiDefault_IntegerZero";
  if (id == 0x0000036E) return "XuiCopyString";
  if (id == 0x0000036F) return "XuiRealloc";
  if (id == 0x00000370) return "XuiControlPlayOptionalVisual";
  if (id == 0x00000371) return "XuiKillTimer";
  if (id == 0x00000372) return "XuiElementEnableInput";
  if (id == 0x00000373) return "XuiElementInputEnabled";
  if (id == 0x00000374) return "XuiIsInstanceOf";
  if (id == 0x00000375) return "XuiResourceComposeLocator";
  if (id == 0x00000376) return "XuiResourceLocatorIsAbsolute";
  if (id == 0x00000377) return "XuiBroadcastMessage";
  if (id == 0x00000378) return "XuiElementDisallowRecursiveTimelineControl";
  if (id == 0x00000379) return "XUIElementPropVal_Construct";
  if (id == 0x0000037A) return "XUIElementPropVal_Destruct";
  if (id == 0x0000037B) return "XUIElementPropVal_SetString";
  if (id == 0x0000037C) return "XuiObjectSetProperty";
  if (id == 0x0000037D) return "XuiElementGetOpacity";
  if (id == 0x0000037E) return "XuiElementSetOpacity";
  if (id == 0x0000037F) return "XuiEditSetTextLimit";
  if (id == 0x00000380) return "XuiEditGetTextLimit";
  if (id == 0x00000381) return "XuiSliderSetValue";
  if (id == 0x00000382) return "XuiSliderGetValue";
  if (id == 0x00000383) return "XuiSliderSetRange";
  if (id == 0x00000384) return "XuiElementUnlink";
  if (id == 0x00000385) return "XuiElementInsertChild";
  if (id == 0x00000386) return "XuiSceneNavigateBackToFirst";
  if (id == 0x00000387) return "XuiProgressBarSetRange";
  if (id == 0x00000388) return "XuiProgressBarSetValue";
  if (id == 0x00000389) return "XuiProgressBarGetValue";
  if (id == 0x0000038A) return "XuiControlAttachVisual";
  if (id == 0x0000038B) return "XuiCreateTextureBrush";
  if (id == 0x0000038C) return "XuiDestroyBrush";
  if (id == 0x0000038D) return "XUIElementPropVal_SetColorFromUint";
  if (id == 0x0000038E) return "XuiFigureSetFill";
  if (id == 0x0000038F) return "XuiSliderGetRange";
  if (id == 0x00000390) return "XuiFigureSetTexture";
  if (id == 0x00000391) return "XuiControlGetItemAssociation";
  if (id == 0x00000392) return "XuiResourceLoadAll";
  if (id == 0x00000393) return "XuiImageElementSetImagePath";
  if (id == 0x00000394) return "XuiImageElementGetImagePath";
  if (id == 0x00000395) return "XuiControlGetVisual";
  if (id == 0x00000396) return "XuiControlGetNavigation";
  if (id == 0x00000397) return "XuiLookupStringTableByIndex";
  if (id == 0x00000398) return "XUIElementPropVal_SetBool";
  if (id == 0x00000399) return "XuiElementHasFocus";
  if (id == 0x0000039A) return "XUIElementPropVal_SetUint";
  if (id == 0x0000039B) return "XUIElementPropVal_Clear";
  if (id == 0x0000039C) return "XuiEditSetTextFormatInfo";
  if (id == 0x0000039D) return "XuiCreateSolidBrush";
  if (id == 0x0000039E) return "XuiSceneInterruptTransitions";
  if (id == 0x0000039F) return "XuiResourceOpen";
  if (id == 0x000003A0) return "XuiResourceRead";
  if (id == 0x000003A1) return "XuiResourceClose";
  if (id == 0x000003A2) return "XuiVisualCreateInstance";
  if (id == 0x000003A3) return "XuiElementGetTimeline";
  if (id == 0x000003A4) return "?GetCodecVersion@CCalMediaInfo@@UBAKXZ";
  if (id == 0x000003A5) return "XuiElementIsDescendant";
  if (id == 0x000003A6) return "XuiSetMessageFilter";
  if (id == 0x000003CA) return "XGetAudioFlags";
  if (id == 0x000003CB) return "XGetAVPack";
  if (id == 0x000003CC) return "XGetGameRegion";
  if (id == 0x000003CD) return "XGetLanguage";
  if (id == 0x000003CE) return "XGetLocale";
  if (id == 0x000003CF) return "?XGetVideoFlags@@YAKXZ";
  if (id == 0x000003D0) return "XGetVideoStandard";
  if (id == 0x000003D1) return "XGetVideoMode";
  if (id == 0x000003D4) return "XamSetAutomation";
  if (id == 0x000003D5) return "XAutomationpBindController";
  if (id == 0x000003D6) return "XAutomationpUnbindController";
  if (id == 0x000003D7) return "XAutomationpInputXenonButton";
  if (id == 0x000003D8) return "XAutomationpInputPress";
  if (id == 0x000003D9) return "XAutomationpInputSetState";
  if (id == 0x000003DA) return "XamEnableOverdraw";
  if (id == 0x000003DB) return "g_XuiAutomation";
  if (id == 0x000003E4) return "GamerCardStartup";
  if (id == 0x000003E5) return "GamerCardCleanup";
  if (id == 0x000003E6) return "GamerCardRegisterControls";
  if (id == 0x000003E7) return "GamerCardUnregisterControls";
  if (id == 0x000003E8) return "RtlFindFirstFile";
  if (id == 0x000003E9) return "RtlFindNextFile";
  if (id == 0x000003EA) return "RtlGetModuleFileName";
  if (id == 0x000003EB) return "RtlOutputDebugString";
  if (id == 0x000003EC) return "RtlRemoveDirectory";
  if (id == 0x000003ED) return "RtlSleep";
  if (id == 0x000003EE) return "RtlGetLastError";
  if (id == 0x000003EF) return "RtlSetLastError";
  if (id == 0x000003F0) return "RtlSetLastNTError";
  if (id == 0x000003F1) return "RtlDebugPrint";
  if (id == 0x000003F2) return "RtlDebugError";
  if (id == 0x000003F3) return "XDebugWarning";
  if (id == 0x000003F4) return "RtlDebugTrace";
  if (id == 0x000003F5) return "RtlDebugEntry";
  if (id == 0x000003F6) return "RtlDebugExit";
  if (id == 0x000003F7) return "RtlGetAttributesOnHeapAlloc";
  if (id == 0x000003F8) return "RtlSetAttributesOnHeapAlloc";
  if (id == 0x000003FA) return "RtlCreateHeap";
  if (id == 0x000003FB) return "RtlDestroyHeap";
  if (id == 0x000003FC) return "RtlAllocateHeap";
  if (id == 0x000003FD) return "RtlAllocateHeapSlowly";
  if (id == 0x000003FE) return "RtlReAllocateHeap";
  if (id == 0x000003FF) return "RtlFreeHeap";
  if (id == 0x00000400) return "RtlFreeHeapSlowly";
  if (id == 0x00000401) return "RtlSizeHeap";
  if (id == 0x00000402) return "RtlZeroHeap";
  if (id == 0x00000403) return "RtlDebugWalkHeap";
  if (id == 0x00000404) return "RtlWalkHeap";
  if (id == 0x00000405) return "RtlLockHeap";
  if (id == 0x00000406) return "RtlUnlockHeap";
  if (id == 0x00000407) return "RtlValidateHeap";
  if (id == 0x00000408) return "RtlDebugCompactHeap";
  if (id == 0x00000409) return "RtlCompactHeap";
  if (id == 0x0000040E) return "OutputDebugStringA";
  if (id == 0x0000040F) return "DebugBreak";
  if (id == 0x00000410) return "GetCurrentThreadId";
  if (id == 0x00000411) return "XDebugError";
  if (id == 0x00000412) return "XDebugWarning";
  if (id == 0x00000413) return "RtlDebugSetLevel";
  if (id == 0x00000414) return "CloseHandle";
  if (id == 0x00000415) return "GetTickCount";
  if (id == 0x00000416) return "GetLastError";
  if (id == 0x00000417) return "SetFilePointer";
  if (id == 0x00000418) return "SetFilePointerEx";
  if (id == 0x00000419) return "SetLastError";
  if (id == 0x0000041A) return "MultiByteToWideChar";
  if (id == 0x0000041B) return "WideCharToMultiByte";
  if (id == 0x0000041C) return "ReadFile";
  if (id == 0x0000041D) return "FlushFileBuffers";
  if (id == 0x0000041E) return "WriteFile";
  if (id == 0x0000041F) return "OutputDebugStringW";
  if (id == 0x00000420) return "SetEvent";
  if (id == 0x00000421) return "XapiFormatTimeOut";
  if (id == 0x00000422) return "CreateMutexA";
  if (id == 0x00000423) return "OpenMutexA";
  if (id == 0x00000424) return "ReleaseMutex";
  if (id == 0x00000425) return "WaitForSingleObject";
  if (id == 0x00000426) return "WaitForSingleObjectEx";
  if (id == 0x00000427) return "GetFileSize";
  if (id == 0x00000428) return "GetFileSizeEx";
  if (id == 0x00000429) return "XapiDirectoryInformationToFindData";
  if (id == 0x0000042A) return "XapiFormatObjectAttributes";
  if (id == 0x0000042B) return "ResetEvent";
  if (id == 0x0000042C) return "wsprintfA";
  if (id == 0x0000042D) return "wsprintfW";
  if (id == 0x0000042E) return "GetOverlappedResult";
  if (id == 0x0000042F) return "QueryPerformanceCounter";
  if (id == 0x00000430) return "QueryPerformanceFrequency";
  if (id == 0x00000431) return "LocalAlloc";
  if (id == 0x00000432) return "LocalFree";
  if (id == 0x00000433) return "RaiseException";
  if (id == 0x00000434) return "RtlUniform";
  if (id == 0x00000435) return "RtlRandom";
  if (id == 0x00000436) return "Sleep";
  if (id == 0x00000437) return "SleepEx";
  if (id == 0x00000438) return "XMemSet";
  if (id == 0x00000439) return "XRegisterThreadNotifyRoutine";
  if (id == 0x0000043A) return "XGetOverlappedExtendedError";
  if (id == 0x0000043B) return "XGetOverlappedResult";
  if (id == 0x0000043C) return "CreateThread";
  if (id == 0x0000043D) return "ResumeThread";
  if (id == 0x0000043E) return "ExitThread";
  if (id == 0x0000043F) return "GetTimeZoneInformation";
  if (id == 0x00000440) return "GetSystemTimeAsFileTime";
  if (id == 0x00000441) return "SystemTimeToFileTime";
  if (id == 0x00000442) return "FileTimeToSystemTime";
  if (id == 0x00000443) return "GetSystemTime";
  if (id == 0x00000444) return "GetLocalTime";
  if (id == 0x00000445) return "CreateDirectoryA";
  if (id == 0x00000446) return "CreateEventA";
  if (id == 0x00000447) return "CreateFileA";
  if (id == 0x00000448) return "DeleteFileA";
  if (id == 0x00000449) return "FindFirstFileA";
  if (id == 0x0000044A) return "FindNextFileA";
  if (id == 0x0000044B) return "GetFileAttributesA";
  if (id == 0x0000044D) return "GetFileAttributesExA";
  if (id == 0x0000044E) return "GetModuleHandleA";
  if (id == 0x0000044F) return "GetDiskFreeSpaceExA";
  if (id == 0x00000450) return "CopyFileA";
  if (id == 0x00000451) return "PIXAddEvent";
  if (id == 0x00000452) return "PIXBeginEvent";
  if (id == 0x00000453) return "PIXEndEvent";
  if (id == 0x00000454) return "PIXBeginCapture";
  if (id == 0x00000455) return "PIXEndCapture";
  if (id == 0x00000456) return "PIXAddCounter";
  if (id == 0x00000457) return "PIXWriteData";
  if (id == 0x00000458) return "SetWaitableTimer";
  if (id == 0x00000459) return "CancelWaitableTimer";
  if (id == 0x0000045A) return "CreateWaitableTimerA";
  if (id == 0x0000045B) return "DuplicateHandle";
  if (id == 0x0000045C) return "XapipCreateThread";
  if (id == 0x0000045D) return "lstrcpyA";
  if (id == 0x0000045E) return "lstrcpyW";
  if (id == 0x0000045F) return "lstrcpynA";
  if (id == 0x00000460) return "lstrcpynW";
  if (id == 0x00000461) return "lstrcatA";
  if (id == 0x00000462) return "lstrcatW";
  if (id == 0x00000463) return "lstrlenA";
  if (id == 0x00000464) return "lstrlenW";
  if (id == 0x00000465) return "IsBadReadPtr";
  if (id == 0x00000466) return "IsBadWritePtr";
  if (id == 0x00000467) return "FileTimeToLocalFileTime";
  if (id == 0x000004B0) return "XMPRegisterCodec";
  if (id == 0x000007D2) return "GetProcessHeap";
  if (id == 0x000007D3) return "UnhandledExceptionFilter";
  if (id == 0x000007D4) return "SetUnhandledExceptionFilter";

  return nullptr;
}

const char* xamNameGen(int id, int version)
{
  if (version > 0) {
    if (version <= 1640) return xamNameGen_1640(id);
    if (version <= 1746) return xamNameGen_1746(id);
    if (version <= 1838) return xamNameGen_1838(id);
  }

  if (id == 0x00000001) return "NetDll_WSAStartup";
  if (id == 0x00000002) return "NetDll_WSACleanup";
  if (id == 0x00000003) return "NetDll_socket";
  if (id == 0x00000004) return "NetDll_closesocket";
  if (id == 0x00000005) return "NetDll_shutdown";
  if (id == 0x00000006) return "NetDll_ioctlsocket";
  if (id == 0x00000007) return "NetDll_setsockopt";
  if (id == 0x00000008) return "NetDll_getsockopt";
  if (id == 0x00000009) return "NetDll_getsockname";
  if (id == 0x0000000A) return "NetDll_getpeername";
  if (id == 0x0000000B) return "NetDll_bind";
  if (id == 0x0000000C) return "NetDll_connect";
  if (id == 0x0000000D) return "NetDll_listen";
  if (id == 0x0000000E) return "NetDll_accept";
  if (id == 0x0000000F) return "NetDll_select";
  if (id == 0x00000010) return "NetDll_WSAGetOverlappedResult";
  if (id == 0x00000011) return "NetDll_WSACancelOverlappedIO";
  if (id == 0x00000012) return "NetDll_recv";
  if (id == 0x00000013) return "NetDll_WSARecv";
  if (id == 0x00000014) return "NetDll_recvfrom";
  if (id == 0x00000015) return "NetDll_WSARecvFrom";
  if (id == 0x00000016) return "NetDll_send";
  if (id == 0x00000017) return "NetDll_WSASend";
  if (id == 0x00000018) return "NetDll_sendto";
  if (id == 0x00000019) return "NetDll_WSASendTo";
  if (id == 0x0000001A) return "NetDll_inet_addr";
  if (id == 0x0000001B) return "NetDll_WSAGetLastError";
  if (id == 0x0000001C) return "NetDll_WSASetLastError";
  if (id == 0x0000001D) return "NetDll_WSACreateEvent";
  if (id == 0x0000001E) return "NetDll_WSACloseEvent";
  if (id == 0x0000001F) return "NetDll_WSASetEvent";
  if (id == 0x00000020) return "NetDll_WSAResetEvent";
  if (id == 0x00000021) return "NetDll_WSAWaitForMultipleEvents";
  if (id == 0x00000022) return "NetDll___WSAFDIsSet";
  if (id == 0x00000023) return "NetDll_WSAEventSelect";
  if (id == 0x00000024) return "NetDll_WSAStartupEx";
  if (id == 0x00000033) return "NetDll_XNetStartup";
  if (id == 0x00000034) return "NetDll_XNetCleanup";
  if (id == 0x00000035) return "NetDll_XNetRandom";
  if (id == 0x00000036) return "NetDll_XNetCreateKey";
  if (id == 0x00000037) return "NetDll_XNetRegisterKey";
  if (id == 0x00000038) return "NetDll_XNetUnregisterKey";
  if (id == 0x00000039) return "NetDll_XNetXnAddrToInAddr";
  if (id == 0x0000003A) return "NetDll_XNetServerToInAddr";
  if (id == 0x0000003B) return "NetDll_XNetTsAddrToInAddr";
  if (id == 0x0000003C) return "NetDll_XNetInAddrToXnAddr";
  if (id == 0x0000003D) return "NetDll_XNetInAddrToServer";
  if (id == 0x0000003E) return "NetDll_XNetInAddrToString";
  if (id == 0x0000003F) return "NetDll_XNetUnregisterInAddr";
  if (id == 0x00000040) return "NetDll_XNetXnAddrToMachineId";
  if (id == 0x00000041) return "NetDll_XNetConnect";
  if (id == 0x00000042) return "NetDll_XNetGetConnectStatus";
  if (id == 0x00000043) return "NetDll_XNetDnsLookup";
  if (id == 0x00000044) return "NetDll_XNetDnsRelease";
  if (id == 0x00000045) return "NetDll_XNetQosListen";
  if (id == 0x00000046) return "NetDll_XNetQosLookup";
  if (id == 0x00000047) return "NetDll_XNetQosServiceLookup";
  if (id == 0x00000048) return "NetDll_XNetQosRelease";
  if (id == 0x00000049) return "NetDll_XNetGetTitleXnAddr";
  if (id == 0x0000004A) return "NetDll_XNetGetDebugXnAddr";
  if (id == 0x0000004B) return "NetDll_XNetGetEthernetLinkStatus";
  if (id == 0x0000004C) return "NetDll_XNetGetBroadcastVersionStatus";
  if (id == 0x0000004D) return "NetDll_XNetQosGetListenStats";
  if (id == 0x0000004E) return "NetDll_XNetGetOpt";
  if (id == 0x0000004F) return "NetDll_XNetSetOpt";
  if (id == 0x00000050) return "NetDll_XNetStartupEx";
  if (id == 0x00000051) return "NetDll_XNetReplaceKey";
  if (id == 0x00000052) return "NetDll_XNetGetXnAddrPlatform";
  if (id == 0x00000053) return "NetDll_XNetGetSystemLinkPort";
  if (id == 0x00000054) return "NetDll_XNetSetSystemLinkPort";
  if (id == 0x00000055) return "NetDll_XNetDnsReverseLookup";
  if (id == 0x00000056) return "NetDll_XNetDnsReverseRelease";
  if (id == 0x00000065) return "NetDll_XnpLoadConfigParams";
  if (id == 0x00000066) return "NetDll_XnpSaveConfigParams";
  if (id == 0x00000067) return "NetDll_XnpConfigUPnP";
  if (id == 0x00000068) return "NetDll_XnpConfig";
  if (id == 0x00000069) return "NetDll_XnpGetConfigStatus";
  if (id == 0x0000006A) return "NetDll_XnpLoadMachineAccount";
  if (id == 0x0000006B) return "NetDll_XnpSaveMachineAccount";
  if (id == 0x0000006C) return "NetDll_XnpCapture";
  if (id == 0x0000006D) return "NetDll_XnpEthernetInterceptSetCallbacks";
  if (id == 0x0000006E) return "NetDll_XnpEthernetInterceptXmit";
  if (id == 0x0000006F) return "NetDll_XnpEthernetInterceptRecv";
  if (id == 0x00000070) return "NetDll_XnpLogonGetStatus";
  if (id == 0x00000071) return "NetDll_XnpLogonGetQFlags";
  if (id == 0x00000072) return "NetDll_XnpLogonSetQFlags";
  if (id == 0x00000073) return "NetDll_XnpLogonSetQEvent";
  if (id == 0x00000074) return "NetDll_XnpLogonClearQEvent";
  if (id == 0x00000075) return "NetDll_XnpLogonGetQVals";
  if (id == 0x00000076) return "NetDll_XnpLogonSetQVals";
  if (id == 0x00000077) return "NetDll_XnpLogonSetPState";
  if (id == 0x00000078) return "NetDll_XnpGetVlanXboxName";
  if (id == 0x00000079) return "NetDll_XnpSetVlanXboxName";
  if (id == 0x0000007A) return "NetDll_XnpGetActiveSocketList";
  if (id == 0x0000007B) return "NetDll_XnpNoteSystemTime";
  if (id == 0x0000007C) return "NetDll_XnpRegisterKeyForCallerType";
  if (id == 0x0000007D) return "NetDll_XnpUnregisterKeyForCallerType";
  if (id == 0x0000007E) return "NetDll_XnpLogonGetChallenge";
  if (id == 0x0000007F) return "NetDll_XnpLogonClearChallenge";
  if (id == 0x00000080) return "NetDll_XnpLogonSetChallengeResponse";
  if (id == 0x00000081) return "NetDll_XnpGetSecAssocList";
  if (id == 0x00000082) return "NetDll_XnpGetKeyList";
  if (id == 0x00000083) return "NetDll_XnpGetQosLookupList";
  if (id == 0x00000084) return "NetDll_XnpPersistTitleState";
  if (id == 0x00000085) return "NetDll_XnpReplaceKeyForCallerType";
  if (id == 0x00000086) return "NetDll_XnpEthernetInterceptSetExtendedReceiveCallback";
  if (id == 0x00000087) return "NetDll_XnpQosHistoryLoad";
  if (id == 0x00000088) return "NetDll_XnpQosHistorySaveMeasurements";
  if (id == 0x00000089) return "NetDll_XnpQosHistoryGetEntries";
  if (id == 0x0000008A) return "NetDll_XnpQosHistoryGetAggregateMeasurement";
  if (id == 0x0000008B) return "NetDll_XnpToolSetCallbacks";
  if (id == 0x0000008C) return "NetDll_XnpToolIpProxyInject";
  if (id == 0x0000008D) return "NetDll_XnpUpdateConfigParams";
  if (id == 0x0000008E) return "NetDll_XnpEthernetInterceptXmitAsIp";
  if (id == 0x0000008F) return "NetDll_XnpConfigUPnPPortAndExternalAddr";
  if (id == 0x00000097) return "NetDll_XmlDownloadStart";
  if (id == 0x00000098) return "NetDll_XmlDownloadContinue";
  if (id == 0x00000099) return "NetDll_XmlDownloadStop";
  if (id == 0x0000009A) return "NetDll_XmlDownloadGetParseTime";
  if (id == 0x0000009B) return "NetDll_XmlDownloadGetReceivedDataSize";
  if (id == 0x000000C6) return "XnpGetXwppMemoryLogSnapshot";
  if (id == 0x000000C7) return "XnpGetXwppRuntimeFilter";
  if (id == 0x000000C9) return "NetDll_XHttpStartup";
  if (id == 0x000000CA) return "NetDll_XHttpShutdown";
  if (id == 0x000000CB) return "NetDll_XHttpOpen";
  if (id == 0x000000CC) return "NetDll_XHttpCloseHandle";
  if (id == 0x000000CD) return "NetDll_XHttpConnect";
  if (id == 0x000000CE) return "NetDll_XHttpSetStatusCallback";
  if (id == 0x000000CF) return "NetDll_XHttpOpenRequest";
  if (id == 0x000000D0) return "NetDll_XHttpOpenRequestUsingMemory";
  if (id == 0x000000D1) return "NetDll_XHttpSendRequest";
  if (id == 0x000000D2) return "NetDll_XHttpReceiveResponse";
  if (id == 0x000000D3) return "NetDll_XHttpQueryHeaders";
  if (id == 0x000000D4) return "NetDll_XHttpReadData";
  if (id == 0x000000D5) return "NetDll_XHttpWriteData";
  if (id == 0x000000D6) return "NetDll_XHttpQueryOption";
  if (id == 0x000000D7) return "NetDll_XHttpSetOption";
  if (id == 0x000000D8) return "NetDll_XHttpDoWork";
  if (id == 0x000000D9) return "NetDll_XHttpSetCredentials";
  if (id == 0x000000DA) return "NetDll_XHttpQueryAuthSchemes";
  if (id == 0x000000DB) return "NetDll_XHttpCrackUrlW";
  if (id == 0x000000DC) return "NetDll_XHttpCrackUrl";
  if (id == 0x000000DD) return "NetDll_XHttpCreateUrl";
  if (id == 0x000000DE) return "NetDll_XHttpCreateUrlW";
  if (id == 0x000000DF) return "NetDll_XHttpResetPerfCounters";
  if (id == 0x000000E0) return "NetDll_XHttpGetPerfCounters";
  if (id == 0x000000FB) return "NetDll_UpnpStartup";
  if (id == 0x000000FC) return "NetDll_UpnpCleanup";
  if (id == 0x000000FD) return "NetDll_UpnpSearchCreate";
  if (id == 0x000000FE) return "NetDll_UpnpSearchGetDevices";
  if (id == 0x000000FF) return "NetDll_UpnpDescribeCreate";
  if (id == 0x00000100) return "NetDll_UpnpDescribeGetResults";
  if (id == 0x00000101) return "NetDll_UpnpActionCalculateWorkBufferSize";
  if (id == 0x00000102) return "NetDll_UpnpActionCreate";
  if (id == 0x00000103) return "NetDll_UpnpActionGetResults";
  if (id == 0x00000104) return "NetDll_UpnpEventCreate";
  if (id == 0x00000105) return "NetDll_UpnpEventGetCurrentState";
  if (id == 0x00000106) return "NetDll_UpnpEventUnsubscribe";
  if (id == 0x00000107) return "NetDll_UpnpDoWork";
  if (id == 0x00000108) return "NetDll_UpnpCloseHandle";
  if (id == 0x0000012D) return "XNetLogonGetLoggedOnUsers";
  if (id == 0x0000012E) return "XNetLogonGetNatType";
  if (id == 0x0000012F) return "XNetLogonTaskStart";
  if (id == 0x00000130) return "XNetLogonTaskClose";
  if (id == 0x00000131) return "XNetLogonTaskContinue";
  if (id == 0x00000132) return "XNetLogonGetServiceInfo";
  if (id == 0x00000133) return "XNetLogonGetUserPrivileges";
  if (id == 0x00000134) return "XNetLogonSetConsoleCertificate";
  if (id == 0x00000135) return "XNetLogonGetMachineID";
  if (id == 0x00000136) return "XNetLogonGetTitleID";
  if (id == 0x00000137) return "XNetLogonGetTitleVersion";
  if (id == 0x00000138) return "XNetLogonGetServiceNetworkID";
  if (id == 0x00000139) return "XNetLogonGetDnsString";
  if (id == 0x0000013A) return "XNetLogonSetTitleID";
  if (id == 0x0000013B) return "XNetLogonGetExtendedStatus";
  if (id == 0x0000013C) return "XNetLogonClearTicketCaches";
  if (id == 0x0000013D) return "XNetLogonInitOverrideInfo";
  if (id == 0x0000013E) return "XNetLogonGetLastUPnPStatus";
  if (id == 0x0000013F) return "XNetLogonGetFlowToken";
  if (id == 0x00000140) return "XNetLogonGetTicketOpt";
  if (id == 0x00000141) return "XNetLogonSetTicketOpt";
  if (id == 0x00000142) return "XNetLogonGetState";
  if (id == 0x00000190) return "XamInputGetCapabilities";
  if (id == 0x00000191) return "XamInputGetState";
  if (id == 0x00000192) return "XamInputSetState";
  if (id == 0x00000193) return "XamInputGetKeystroke";
  if (id == 0x00000194) return "XamInputEnableAutobind";
  if (id == 0x00000195) return "XamInputRawState";
  if (id == 0x00000196) return "XamEnableSystemAppInput";
  if (id == 0x00000197) return "XamInputGetDeviceStats";
  if (id == 0x00000198) return "XamInputGetKeystrokeEx";
  if (id == 0x00000199) return "XamInputGetKeystrokeHud";
  if (id == 0x0000019A) return "XamInputSetLayoutKeyboard";
  if (id == 0x0000019B) return "XamInputToggleKeyLocks";
  if (id == 0x0000019C) return "XamInputResetLayoutKeyboard";
  if (id == 0x0000019D) return "XamInputGetKeystrokeHudEx";
  if (id == 0x0000019E) return "XamInputSetKeyboardTranslationHud";
  if (id == 0x0000019F) return "XamSetInactivityTime";
  if (id == 0x000001A0) return "XamEnableInactivityProcessing";
  if (id == 0x000001A1) return "XamResetInactivity";
  if (id == 0x000001A2) return "XamSetInactivityTimeFromConfig";
  if (id == 0x000001A3) return "XamLoaderGetMediaInfo";
  if (id == 0x000001A4) return "XamLoaderLaunchTitle";
  if (id == 0x000001A5) return "XamLoaderLaunchTitleEx";
  if (id == 0x000001A6) return "XamLoaderSetLaunchData";
  if (id == 0x000001A7) return "XamLoaderGetLaunchDataSize";
  if (id == 0x000001A8) return "XamLoaderGetLaunchData";
  if (id == 0x000001A9) return "XamLoaderTerminateTitle";
  if (id == 0x000001AA) return "XamLoaderGetDvdTrayState";
  if (id == 0x000001AB) return "XamLoaderGetGameInfo";
  if (id == 0x000001AC) return "XamLoaderLaunchTitleOnDvd";
  if (id == 0x000001AD) return "XamLoaderSetSpindleSpeed";
  if (id == 0x000001AE) return "XamTaskCreateQueue";
  if (id == 0x000001AF) return "XamTaskSchedule";
  if (id == 0x000001B0) return "XamTaskReschedule";
  if (id == 0x000001B1) return "XamTaskCloseHandle";
  if (id == 0x000001B2) return "XamTaskCancel";
  if (id == 0x000001B3) return "XamTaskShouldExit";
  if (id == 0x000001B4) return "XamTaskWaitOnCompletion";
  if (id == 0x000001B5) return "XamTaskModify";
  if (id == 0x000001B6) return "XamTaskGetCurrentTask";
  if (id == 0x000001B7) return "XamTaskGetAttributes";
  if (id == 0x000001B8) return "XamExecutingOnBehalfOfTitle";
  if (id == 0x000001B9) return "XamInputSendStayAliveRequest";
  if (id == 0x000001BA) return "XamInputGetUserVibrationLevel";
  if (id == 0x000001BB) return "XamIsSystemTitleId";
  if (id == 0x000001BC) return "XamLoaderIsTitleTerminatePending";
  if (id == 0x000001BD) return "XamInputSetTextMessengerIndicator";
  if (id == 0x000001BE) return "XamLoaderGetPriorTitleId";
  if (id == 0x000001BF) return "XamIsXbox1TitleId";
  if (id == 0x000001C0) return "XamInputSetKeyLocks";
  if (id == 0x000001C1) return "XamInputGetKeyLocks";
  if (id == 0x000001C2) return "XamTaskGetStatus";
  if (id == 0x000001C3) return "XamGetRootObj";
  if (id == 0x000001C4) return "XamDevAuthSetFault";
  if (id == 0x000001C5) return "XamGetDefaultSystemImage";
  if (id == 0x000001C6) return "XamGetWCNConfigFile";
  if (id == 0x000001C7) return "XamSetPowerMode";
  if (id == 0x000001C8) return "XamExecuteChallenge";
  if (id == 0x000001C9) return "XamGetDefaultImage";
  if (id == 0x000001CA) return "XamMuteSound";
  if (id == 0x000001CB) return "XamGetOnlineSchema";
  if (id == 0x000001CC) return "XamSetDashContext";
  if (id == 0x000001CD) return "XamGetDashContext";
  if (id == 0x000001CE) return "XamIsCurrentTitleDash";
  if (id == 0x000001CF) return "XamGetCurrentTitleId";
  if (id == 0x000001D0) return "XamSetCurrentTitleDash";
  if (id == 0x000001D1) return "XamAllocHeapFreeSpace";
  if (id == 0x000001D2) return "XamSetDashContextEx";
  if (id == 0x000001D3) return "XamGetDashContextEx";
  if (id == 0x000001D4) return "XamSetHudContext";
  if (id == 0x000001D5) return "XamGetHudContext";
  if (id == 0x000001D6) return "XCustomGetBannerImage";
  if (id == 0x000001D7) return "XamCustomSetBannerImage";
  if (id == 0x000001D8) return "XCustomSetAction";
  if (id == 0x000001D9) return "XCustomGetLastActionPress";
  if (id == 0x000001DA) return "XCustomSetDynamicActions";
  if (id == 0x000001DB) return "XCustomBroadcastActionEvent";
  if (id == 0x000001DC) return "XCustomGetLastActionPressEx";
  if (id == 0x000001DD) return "XCustomRegisterDynamicActions";
  if (id == 0x000001DE) return "XCustomUnregisterDynamicActions";
  if (id == 0x000001DF) return "XCustomGetCurrentGamercard";
  if (id == 0x000001E0) return "XamDbgPrint";
  if (id == 0x000001E1) return "XamDbgSetOutputLevel";
  if (id == 0x000001E2) return "XamDbgSetBreakLevel";
  if (id == 0x000001E3) return "XamLoaderGetMediaInfoEx";
  if (id == 0x000001E4) return "XamLoaderSetGameInfo";
  if (id == 0x000001E5) return "XamFormatMessage";
  if (id == 0x000001E6) return "XamUniSortCmpString";
  if (id == 0x000001E7) return "XamFormatTimeString";
  if (id == 0x000001E8) return "XamFormatDateString";
  if (id == 0x000001E9) return "XamGetLocaleDateFormat";
  if (id == 0x000001EA) return "XamAlloc";
  if (id == 0x000001EB) return "XamAllocEx";
  if (id == 0x000001EC) return "XamFree";
  if (id == 0x000001ED) return "XamAllocSize";
  if (id == 0x000001EE) return "XamAllocMountIPTVHeap";
  if (id == 0x000001EF) return "XamAllocUnmountIPTVHeap";
  if (id == 0x000001F0) return "XamAllocFreeIPTVHeap";
  if (id == 0x000001F1) return "XamDeviceRemap";
  if (id == 0x000001F2) return "XamLoaderGetClearCache";
  if (id == 0x000001F3) return "XamLoaderSetClearCache";
  if (id == 0x000001F4) return "XMsgInProcessCall";
  if (id == 0x000001F5) return "XMsgCompleteIORequest";
  if (id == 0x000001F6) return "XMsgSystemProcessCall";
  if (id == 0x000001F7) return "XMsgStartIORequest";
  if (id == 0x000001F8) return "XMsgCancelIORequest";
  if (id == 0x000001F9) return "XMsgAcquireAsyncMessageFromOverlapped";
  if (id == 0x000001FA) return "XMsgReleaseAsyncMessageToOverlapped";
  if (id == 0x000001FB) return "XamGetOverlappedResult";
  if (id == 0x000001FC) return "XMsgStartIORequestEx";
  if (id == 0x000001FD) return "XamAppAllocateInterappWorkspace";
  if (id == 0x000001FE) return "XamAppGetInterappWorkspace";
  if (id == 0x000001FF) return "XamAppFreeInterappWorkspace";
  if (id == 0x00000200) return "XamFeatureEnabled";
  if (id == 0x00000201) return "XamFeatureEnforceImageBudget";
  if (id == 0x00000202) return "XamFeatureSetMask";
  if (id == 0x00000203) return "XamFeatureEnableDisable";
  if (id == 0x00000204) return "XuiControlSetItemAssociation";
  if (id == 0x00000205) return "XamGetTitleGlobalStorageValue";
  if (id == 0x00000206) return "XamSetTitleGlobalStorageValue";
  if (id == 0x00000207) return "XamUserValidateAvatarManifest";
  if (id == 0x00000208) return "XamUserGetDeviceContext";
  if (id == 0x00000209) return "XamUserLookupDevice";
  if (id == 0x0000020A) return "XamUserGetXUID";
  if (id == 0x0000020B) return "XamUserLogon";
  if (id == 0x0000020C) return "XamUserGetGamerTag";
  if (id == 0x0000020D) return "XamUserGetUserIndexMask";
  if (id == 0x0000020E) return "XamUserGetName";
  if (id == 0x0000020F) return "XamLookupCommonStringByIndex";
  if (id == 0x00000210) return "XamUserGetSigninState";
  if (id == 0x00000211) return "XamUserGetIndexFromXUID";
  if (id == 0x00000212) return "XamUserCheckPrivilege";
  if (id == 0x00000213) return "XamUserAreUsersFriends";
  if (id == 0x00000214) return "XamSetUserPresetPresenceState";
  if (id == 0x00000215) return "XamGetUserPresetPresenceState";
  if (id == 0x00000216) return "XamUserGetUserFlagsFromXUID";
  if (id == 0x00000217) return "XamUserGetMembershipTierFromXUID";
  if (id == 0x00000218) return "XamUserGetOnlineCountryFromXUID";
  if (id == 0x00000219) return "XamUserReadProfileSettings";
  if (id == 0x0000021A) return "XamUserWriteProfileSettings";
  if (id == 0x0000021B) return "XamUserGetMembershipTier";
  if (id == 0x0000021C) return "XamUserGetUserFlags";
  if (id == 0x0000021D) return "XamUserGetRequestedUserIndexMask";
  if (id == 0x0000021E) return "XamUserIsGuest";
  if (id == 0x0000021F) return "XamUserProfileSync";
  if (id == 0x00000220) return "XamUserFlushLogonQueue";
  if (id == 0x00000221) return "XamUserIsOnlineEnabled";
  if (id == 0x00000222) return "XamUserGetCachedUserFlags";
  if (id == 0x00000223) return "XamAreMixedAccountsSignedIn";
  if (id == 0x00000224) return "XamUserLogonEx";
  if (id == 0x00000225) return "XamSetUserShowMessengerFriends";
  if (id == 0x00000226) return "XamGetUserShowMessengerFriends";
  if (id == 0x00000227) return "XamUserGetSigninInfo";
  if (id == 0x00000228) return "XamUserIsPartial";
  if (id == 0x00000229) return "XamUserGetOnlineLanguageFromXUID";
  if (id == 0x0000022A) return "XamUserReadProfileSettingsEx";
  if (id == 0x0000022B) return "XamSystemUpdaterLogon";
  if (id == 0x0000022C) return "XamUserGetUsersMissingAvatars";
  if (id == 0x0000022D) return "XamIsChildAccountSignedIn";
  if (id == 0x0000022E) return "XamUserPrefetchProfileSettings";
  if (id == 0x0000022F) return "XamUserInvalidateProfileSetting";
  if (id == 0x00000230) return "XamProfileCreate";
  if (id == 0x00000231) return "XamProfileCreateEnumerator";
  if (id == 0x00000232) return "XamProfileEnumerate";
  if (id == 0x00000233) return "XamProfileDelete";
  if (id == 0x00000234) return "XamProfileGetCreationStatus";
  if (id == 0x00000235) return "XamProfileFindAccount";
  if (id == 0x00000236) return "XamProfileRenameAccount";
  if (id == 0x00000237) return "XamProfileOpen";
  if (id == 0x00000238) return "XamProfileClose";
  if (id == 0x00000239) return "XamProfileSaveAccountInfo";
  if (id == 0x0000023A) return "XamProfileLoadAccountInfo";
  if (id == 0x0000023B) return "XamProfileRecoverTitle";
  if (id == 0x0000023C) return "XamProfileSaveWindowsLiveCredentials";
  if (id == 0x0000023D) return "XamProfileLoadWindowsLiveCredentials";
  if (id == 0x0000023E) return "XamProfileIsSaveWindowsLiveCredsEnabled";
  if (id == 0x0000023F) return "XamProfileSetSaveWindowsLiveCredsEnabled";
  if (id == 0x00000240) return "XamSetProfileReadTestHook";
  if (id == 0x00000241) return "XamProfileGetLastSync";
  if (id == 0x00000242) return "XamAccountRecoveryRecoverTitle";
  if (id == 0x00000243) return "XamProfileControlPec";
  if (id == 0x00000244) return "XamAppLoad";
  if (id == 0x00000245) return "XamAppUnloadSelf";
  if (id == 0x00000246) return "XamAppUnloadStack";
  if (id == 0x00000247) return "XamSendMessageToLoadedApps";
  if (id == 0x00000248) return "XamAppRequestLoad";
  if (id == 0x00000249) return "XamAppUnrequestLoad";
  if (id == 0x0000024A) return "XamNavigate";
  if (id == 0x0000024B) return "XamRegisterSysApp";
  if (id == 0x0000024C) return "XamUnregisterSysApp";
  if (id == 0x0000024D) return "XamAppReinitialize";
  if (id == 0x0000024E) return "XamCreateEnumeratorHandle";
  if (id == 0x0000024F) return "XamGetPrivateEnumStructureFromHandle";
  if (id == 0x00000250) return "XamEnumerate";
  if (id == 0x00000251) return "XamLoadSysApp";
  if (id == 0x00000252) return "XamUnloadSysApp";
  if (id == 0x00000253) return "XamReloadSysApp";
  if (id == 0x00000254) return "XamAppLoadPass2SysApps";
  if (id == 0x00000255) return "XamProfileGetLiveLegalLocale";
  if (id == 0x00000256) return "XamUserIsParentalControlled";
  if (id == 0x00000257) return "XamContentLaunchImageFromFileInternal";
  if (id == 0x00000258) return "XamContentCreate";
  if (id == 0x00000259) return "XamContentCreateEx";
  if (id == 0x0000025A) return "XamContentClose";
  if (id == 0x0000025B) return "XamContentDelete";
  if (id == 0x0000025C) return "XamContentCreateEnumerator";
  if (id == 0x0000025D) return "XamContentCreateDeviceEnumerator";
  if (id == 0x0000025E) return "XamContentGetDeviceData";
  if (id == 0x0000025F) return "XamContentGetDeviceName";
  if (id == 0x00000260) return "XamContentSetThumbnail";
  if (id == 0x00000261) return "XamContentGetThumbnail";
  if (id == 0x00000262) return "XamContentGetCreator";
  if (id == 0x00000263) return "XamContentLaunchImage";
  if (id == 0x00000264) return "XamContentGetAttributes";
  if (id == 0x00000265) return "XamContentGetDeviceState";
  if (id == 0x00000266) return "XamContentGetLicenseMask";
  if (id == 0x00000267) return "XamContentFlush";
  if (id == 0x00000268) return "XamContentResolve";
  if (id == 0x00000269) return "XamContentOpenFile";
  if (id == 0x0000026A) return "XamContentInstall";
  if (id == 0x0000026B) return "XamContentLockUnlockPackageHeaders";
  if (id == 0x0000026C) return "XamContentCopyInternal";
  if (id == 0x0000026D) return "XamContentMoveInternal";
  if (id == 0x0000026E) return "XamContentGetMetaDataInternal";
  if (id == 0x0000026F) return "XamContentCreateEnumeratorInternal";
  if (id == 0x00000270) return "XamContentDeleteInternal";
  if (id == 0x00000271) return "XamContentCreateInternal";
  if (id == 0x00000272) return "XamContentSetThumbnailInternal";
  if (id == 0x00000273) return "XamContentLaunchImageInternal";
  if (id == 0x00000274) return "XamContentWritePackageHeader";
  if (id == 0x00000275) return "XamContentDismountAndClosePackage";
  if (id == 0x00000276) return "XamContentResolveInternal";
  if (id == 0x00000277) return "XamContentGetAttributesInternal";
  if (id == 0x00000278) return "XamContentOpenFileInternal";
  if (id == 0x00000279) return "XamContentAggregateCreateEnumerator";
  if (id == 0x0000027A) return "XamContentCreateAndMountPackage";
  if (id == 0x0000027B) return "XamContentOpenPackageFile";
  if (id == 0x0000027C) return "XamContentMountPackage";
  if (id == 0x0000027D) return "XamContentFlushPackage";
  if (id == 0x0000027E) return "XamContentClosePackageFile";
  if (id == 0x0000027F) return "XamContentDuplicateFileHandle";
  if (id == 0x00000280) return "XamGetExecutionId";
  if (id == 0x00000281) return "XamGetGameRatings";
  if (id == 0x00000282) return "XamGetSystemVersion";
  if (id == 0x00000283) return "XamContentGetLocalizedString";
  if (id == 0x00000284) return "XamContentGetDefaultDevice";
  if (id == 0x00000285) return "XamContentInstallInternal";
  if (id == 0x00000286) return "XamContentSetMediaMetaDataInternal";
  if (id == 0x00000287) return "XamContentGetDeviceSerialNumber";
  if (id == 0x00000288) return "XamContentGetMountedPackageByRootName";
  if (id == 0x00000289) return "XamContentRegisterChangeCallback";
  if (id == 0x0000028A) return "XamNotifyCreateListener";
  if (id == 0x0000028B) return "XNotifyGetNext";
  if (id == 0x0000028C) return "XNotifyPositionUI";
  if (id == 0x0000028D) return "XNotifyDelayUI";
  if (id == 0x0000028E) return "XNotifyBroadcast";
  if (id == 0x0000028F) return "XNotifyRegisterArea";
  if (id == 0x00000290) return "XNotifyQueueUI";
  if (id == 0x00000291) return "XamNotifyCreateListenerInternal";
  if (id == 0x00000292) return "XNotifyUISetOptions";
  if (id == 0x00000293) return "XNotifyUIGetOptions";
  if (id == 0x00000294) return "XamContentLaunchImageInternalEx";
  if (id == 0x00000295) return "XamShutdown";
  if (id == 0x00000296) return "XamAllocDevkitHeapAvailable";
  if (id == 0x00000297) return "XamNotifyCreateListenerRangeInternal";
  if (id == 0x00000298) return "XNotifyQueueUIEx";
  if (id == 0x00000299) return "XamAppRequestLoadEx";
  if (id == 0x0000029A) return "XuiPNGTextureLoader";
  if (id == 0x0000029B) return "XuiRenderGetXuiDevice";
  if (id == 0x0000029C) return "XuiDefault_False";
  if (id == 0x0000029D) return "XamUserGetReportingInfo";
  if (id == 0x0000029E) return "XamUpdateStart";
  if (id == 0x0000029F) return "XamUpdateGetProgress";
  if (id == 0x000002A0) return "XamUpdateGetExtenderInstance";
  if (id == 0x000002A1) return "XamUpdateFinish";
  if (id == 0x000002A2) return "XamUpdateAttachExtenderInstance";
  if (id == 0x000002A3) return "XamUpdateAllocateExtenderBuffer";
  if (id == 0x000002A4) return "XamRestartTitleLoadAfterUpdate";
  if (id == 0x000002A5) return "XamUIThreadDisableFontPatching";
  if (id == 0x000002A6) return "XamUpdateGetBaseSystemVersion";
  if (id == 0x000002A7) return "XamUpdateGetCurrentSystemVersion";
  if (id == 0x000002A8) return "XamUIThreadEnableFontPatching";
  if (id == 0x000002A9) return "XamTerminateTitleForUpdate";
  if (id == 0x000002AA) return "XamSystemUpdateInstallLocal";
  if (id == 0x000002AB) return "XamUpdateChainPass3FromPass2";
  if (id == 0x000002AD) return "XamInputGetCapabilitiesEx";
  if (id == 0x000002AE) return "XamUserIsUnsafeProgrammingAllowed";
  if (id == 0x000002AF) return "XamDevAuthSetFaultEx";
  if (id == 0x000002B0) return "XamUpdateGetData";
  if (id == 0x000002B1) return "XamCacheIntegrityCheck";
  if (id == 0x000002B2) return "XamCacheStoreFile";
  if (id == 0x000002B3) return "XamCacheFetchFile";
  if (id == 0x000002B4) return "XamCacheOpenFile";
  if (id == 0x000002B5) return "XamCacheCloseFile";
  if (id == 0x000002B6) return "XamGetCachedTitleName";
  if (id == 0x000002B7) return "XamCacheReset";
  if (id == 0x000002B8) return "XamGetCachedGamerTag";
  if (id == 0x000002B9) return "XamGetCachedGamerTagW";
  if (id == 0x000002BA) return "XamCacheDeleteFile";
  if (id == 0x000002BB) return "XamCacheRenameFile";
  if (id == 0x000002BC) return "XamShowSigninUI";
  if (id == 0x000002BD) return "XamShowSigninUIEx";
  if (id == 0x000002BE) return "XamShowSigninUIp";
  if (id == 0x000002BF) return "XamShowFriendsUI";
  if (id == 0x000002C0) return "XamShowMessagesUI";
  if (id == 0x000002C1) return "XamShowKeyboardUI";
  if (id == 0x000002C2) return "XamShowQuickChatUI";
  if (id == 0x000002C3) return "XamShowVoiceMailUI";
  if (id == 0x000002C4) return "XamShowGamerCardUI";
  if (id == 0x000002C5) return "XamShowAchievementsUI";
  if (id == 0x000002C6) return "XamShowPlayerReviewUI";
  if (id == 0x000002C7) return "XamShowMarketplaceUI";
  if (id == 0x000002C8) return "XamShowPlayersUI";
  if (id == 0x000002C9) return "XamShowUpdaterUI";
  if (id == 0x000002CA) return "XamShowMessageBoxUI";
  if (id == 0x000002CB) return "XamShowDeviceSelectorUI";
  if (id == 0x000002CC) return "XamShowMessageComposeUI";
  if (id == 0x000002CD) return "XamShowGameInviteUI";
  if (id == 0x000002CE) return "XamShowFriendRequestUI";
  if (id == 0x000002CF) return "XamShowCreateProfileUI";
  if (id == 0x000002D0) return "XamShowGamesUI";
  if (id == 0x000002D1) return "XamShowLiveSignupUI";
  if (id == 0x000002D2) return "XamShowFriendsUIp";
  if (id == 0x000002D3) return "XamShowComplaintUI";
  if (id == 0x000002D4) return "XamShowReputationUI";
  if (id == 0x000002D5) return "XamShowGamerCardUIForXUID";
  if (id == 0x000002D6) return "XamShowForcedNameChangeUI";
  if (id == 0x000002D7) return "XamShowLiveUpsellUI";
  if (id == 0x000002D8) return "XamShowPasscodeVerifyUI";
  if (id == 0x000002D9) return "XamShowDirtyDiscErrorUI";
  if (id == 0x000002DA) return "XamShowSignupCreditCardUI";
  if (id == 0x000002DB) return "XamShowPrivateChatInviteUI";
  if (id == 0x000002DC) return "XamShowMessageBoxUIEx";
  if (id == 0x000002DD) return "XamShowRecentMessageUI";
  if (id == 0x000002DE) return "XamShowRecentMessageUIEx";
  if (id == 0x000002DF) return "XamShowMessagesUIEx";
  if (id == 0x000002E0) return "XamShowAchievementDetailsUI";
  if (id == 0x000002E1) return "XamShowPersonalizationUI";
  if (id == 0x000002E2) return "XamShowChangeGamerTileUI";
  if (id == 0x000002E3) return "XamShowVoiceSettingsUI";
  if (id == 0x000002E4) return "XamShowVideoChatInviteUI";
  if (id == 0x000002E5) return "XamShowCustomMessageComposeUI";
  if (id == 0x000002E6) return "XamShowCustomPlayerListUI";
  if (id == 0x000002E7) return "XamShowMarketplaceDownloadItemsUI";
  if (id == 0x000002E8) return "XamShowMarketplaceUIEx";
  if (id == 0x000002E9) return "XamShowMessageBox";
  if (id == 0x000002EA) return "XamIsSysUiInvokedByXenonButton";
  if (id == 0x000002EB) return "XamIsSysUiInvokedByTitle";
  if (id == 0x000002EC) return "XamIsUIActive";
  if (id == 0x000002ED) return "XamSysUiDisableAutoClose";
  if (id == 0x000002EE) return "XamUserCreateAchievementEnumerator";
  if (id == 0x000002EF) return "XamReadTile";
  if (id == 0x000002F0) return "XamWriteGamerTile";
  if (id == 0x000002F1) return "XamWriteTile";
  if (id == 0x000002F2) return "XamReadImage";
  if (id == 0x000002F3) return "XamUserCreateTitlesPlayedEnumerator";
  if (id == 0x000002F4) return "XamDecompressPNGToTexture";
  if (id == 0x000002F5) return "XamReadTileToTexture";
  if (id == 0x000002F6) return "XamReadString";
  if (id == 0x000002F7) return "XamUserCreateStatsEnumerator";
  if (id == 0x000002F8) return "XamPrepareGamerTiles";
  if (id == 0x000002F9) return "XamClearTitle";
  if (id == 0x000002FA) return "XamReadStrings";
  if (id == 0x000002FB) return "XamWriteGamerTileEx";
  if (id == 0x000002FC) return "XamReadTileEx";
  if (id == 0x000002FD) return "XamReadTileToTextureEx";
  if (id == 0x000002FE) return "XamShowMessengerUI";
  if (id == 0x000002FF) return "XamShowKeyboardUIMessenger";
  if (id == 0x00000300) return "XamShowLiveUpsellUIEx";
  if (id == 0x00000301) return "XamShowJoinSessionInProgressUI";
  if (id == 0x00000302) return "XamShowGraduateUserUI";
  if (id == 0x00000303) return "XamShowGamerCardUIForXUIDp";
  if (id == 0x00000304) return "XamShowGuideUI";
  if (id == 0x00000305) return "XamShowPartyUI";
  if (id == 0x00000306) return "XamShowPartyInviteUI";
  if (id == 0x00000307) return "XamUserAddRecentPlayer";
  if (id == 0x00000308) return "XamUserUpdateRecentPlayer";
  if (id == 0x00000309) return "XamUserCreatePlayerEnumerator";
  if (id == 0x0000030A) return "XamParseGamerTileKey";
  if (id == 0x0000030B) return "XamShowCommunitySessionsUI";
  if (id == 0x0000030C) return "XamVoiceCreate";
  if (id == 0x0000030D) return "XamVoiceHeadsetPresent";
  if (id == 0x0000030E) return "XamVoiceSubmitPacket";
  if (id == 0x0000030F) return "XamVoiceClose";
  if (id == 0x00000310) return "XamVoiceGetBatteryStatus";
  if (id == 0x00000311) return "XamVoiceDisableTestHook"; // this might be switched with EnableTestHook
  if (id == 0x00000312) return "XamVoiceEnableTestHook";
  if (id == 0x00000313) return "XamShowJoinSessionByIdInProgressUI";
  if (id == 0x00000314) return "XamShowPartyJoinInProgressUI";
  if (id == 0x00000315) return "XamBuildSharedSystemResourceLocator";
  if (id == 0x00000316) return "XamSessionCreateHandle";
  if (id == 0x00000317) return "XamSessionRefObjByHandle";
  if (id == 0x00000318) return "XamVoiceGetMicArrayStatus";
  if (id == 0x00000319) return "XamVoiceSetAudioCaptureRoutine";
  if (id == 0x0000031A) return "XamVoiceGetDirectionalData";
  if (id == 0x0000031B) return "XamBuildResourceLocator";
  if (id == 0x0000031C) return "XamBuildLegacySystemResourceLocator";
  if (id == 0x0000031D) return "XamBuildGamercardResourceLocator";
  if (id == 0x0000031E) return "XamBuildDynamicResourceLocator";
  if (id == 0x0000031F) return "XamBuildXamResourceLocator";
  if (id == 0x00000320) return "XuiAnimRun";
  if (id == 0x00000321) return "XuiApplyLocale";
  if (id == 0x00000322) return "XuiBubbleMessage";
  if (id == 0x00000323) return "XuiControlIsBackButton";
  if (id == 0x00000324) return "XuiControlIsNavButton";
  if (id == 0x00000325) return "XuiCreateObject";
  if (id == 0x00000326) return "XuiDestroyObject";
  if (id == 0x00000327) return "XuiDynamicCast";
  if (id == 0x00000328) return "XuiElementAddChild";
  if (id == 0x00000329) return "XuiElementFindNamedFrame";
  if (id == 0x0000032A) return "XuiElementGetChildById";
  if (id == 0x0000032B) return "XuiElementGetFirstChild";
  if (id == 0x0000032C) return "XuiElementGetFocus";
  if (id == 0x0000032D) return "XuiElementGetFocusUser";
  if (id == 0x0000032E) return "XuiElementGetId";
  if (id == 0x0000032F) return "XuiElementGetLastChild";
  if (id == 0x00000330) return "XuiElementGetNext";
  if (id == 0x00000331) return "XuiElementGetParent";
  if (id == 0x00000332) return "XuiElementGetUserFocus";
  if (id == 0x00000333) return "XuiElementInitFocus";
  if (id == 0x00000334) return "XuiElementInitUserFocus";
  if (id == 0x00000335) return "XuiElementPlayTimeline";
  if (id == 0x00000336) return "XuiElementSetBounds";
  if (id == 0x00000337) return "XuiElementSetFocus";
  if (id == 0x00000338) return "XuiElementSetUserFocus";
  if (id == 0x00000339) return "XuiElementTreeGetFocus";
  if (id == 0x0000033A) return "XuiFindClass";
  if (id == 0x0000033B) return "XuiFreeStringTable";
  if (id == 0x0000033C) return "XuiGetBaseObject";
  if (id == 0x0000033D) return "XuiGetClass";
  if (id == 0x0000033E) return "XuiGetObjectClass";
  if (id == 0x0000033F) return "XuiGetOuter";
  if (id == 0x00000340) return "XuiInit";
  if (id == 0x00000341) return "XuiLoadFromBinary";
  if (id == 0x00000342) return "XuiLoadStringTableFromFile";
  if (id == 0x00000343) return "XuiVisualGetBasePath";
  if (id == 0x00000344) return "XuiLookupStringTable";
  if (id == 0x00000345) return "XuiNavButtonGetPressPath";
  if (id == 0x00000346) return "XuiObjectFromHandle";
  if (id == 0x00000347) return "XuiObjectGetProperty";
  if (id == 0x00000348) return "XuiObjectGetPropertyId";
  if (id == 0x00000349) return "XuiProcessInput";
  if (id == 0x0000034A) return "XuiRegisterClass";
  if (id == 0x0000034B) return "XuiRenderBegin";
  if (id == 0x0000034C) return "XuiRenderCreateDC";
  if (id == 0x0000034D) return "XuiRenderDCDeviceChanged";
  if (id == 0x0000034E) return "XuiRenderDestroyDC";
  if (id == 0x0000034F) return "XuiRenderEnd";
  if (id == 0x00000350) return "XuiRenderGetBackBufferSize";
  if (id == 0x00000351) return "XuiRenderInit";
  if (id == 0x00000352) return "XuiRenderInitShared";
  if (id == 0x00000353) return "XuiRenderPresent";
  if (id == 0x00000354) return "XuiRenderSetViewTransform";
  if (id == 0x00000355) return "XuiRenderUninit";
  if (id == 0x00000356) return "XamShowNuiGuideUI";
  if (id == 0x00000357) return "XuiSceneCreate";
  if (id == 0x00000358) return "XuiSceneNavigateBack";
  if (id == 0x00000359) return "XuiSceneNavigateFirst";
  if (id == 0x0000035A) return "XuiSceneNavigateForward";
  if (id == 0x0000035B) return "XuiScenePlayBackFromTransition";
  if (id == 0x0000035C) return "XuiScenePlayBackToTransition";
  if (id == 0x0000035D) return "XuiScenePlayFromTransition";
  if (id == 0x0000035E) return "XuiScenePlayToTransition";
  if (id == 0x0000035F) return "XuiSendMessage";
  if (id == 0x00000360) return "XuiSetLocale";
  if (id == 0x00000361) return "XuiUninit";
  if (id == 0x00000362) return "XuiUnregisterClass";
  if (id == 0x00000363) return "XuiTextElementSetText";
  if (id == 0x00000364) return "XuiSetTimer";
  if (id == 0x00000365) return "XuiTimersRun";
  if (id == 0x00000366) return "XuiTextElementGetText";
  if (id == 0x00000367) return "XuiVisualSetBasePath";
  if (id == 0x00000368) return "XuiHandleIsValid";
  if (id == 0x00000369) return "XuiAlloc";
  if (id == 0x0000036A) return "XuiFree";
  if (id == 0x0000036B) return "XuiDefault_True";
  if (id == 0x0000036C) return "XuiDefault_EmptyString";
  if (id == 0x0000036D) return "XuiDefault_IntegerZero";
  if (id == 0x0000036E) return "XuiCopyString";
  if (id == 0x0000036F) return "XuiRealloc";
  if (id == 0x00000370) return "XuiControlPlayOptionalVisual";
  if (id == 0x00000371) return "XuiKillTimer";
  if (id == 0x00000372) return "XuiElementEnableInput";
  if (id == 0x00000373) return "XuiElementInputEnabled";
  if (id == 0x00000374) return "XuiIsInstanceOf";
  if (id == 0x00000375) return "XuiResourceComposeLocator";
  if (id == 0x00000376) return "XuiResourceLocatorIsAbsolute";
  if (id == 0x00000377) return "XuiBroadcastMessage";
  if (id == 0x00000378) return "XuiElementDisallowRecursiveTimelineControl";
  if (id == 0x00000379) return "XUIElementPropVal_Construct";
  if (id == 0x0000037A) return "XUIElementPropVal_Destruct";
  if (id == 0x0000037B) return "XUIElementPropVal_SetString";
  if (id == 0x0000037C) return "XuiObjectSetProperty";
  if (id == 0x0000037D) return "XuiElementGetOpacity";
  if (id == 0x0000037E) return "XuiElementSetOpacity";
  if (id == 0x0000037F) return "XuiEditSetTextLimit";
  if (id == 0x00000380) return "XuiEditGetTextLimit";
  if (id == 0x00000381) return "XuiSliderSetValue";
  if (id == 0x00000382) return "XuiSliderGetValue";
  if (id == 0x00000383) return "XuiSliderSetRange";
  if (id == 0x00000384) return "XuiElementUnlink";
  if (id == 0x00000385) return "XuiElementInsertChild";
  if (id == 0x00000386) return "XuiSceneNavigateBackToFirst";
  if (id == 0x00000387) return "XuiProgressBarSetRange";
  if (id == 0x00000388) return "XuiProgressBarSetValue";
  if (id == 0x00000389) return "XuiProgressBarGetValue";
  if (id == 0x0000038A) return "XuiControlAttachVisual";
  if (id == 0x0000038B) return "XuiCreateTextureBrush";
  if (id == 0x0000038C) return "XuiDestroyBrush";
  if (id == 0x0000038D) return "XUIElementPropVal_SetColorFromUint";
  if (id == 0x0000038E) return "XuiFigureSetFill";
  if (id == 0x0000038F) return "XuiSliderGetRange";
  if (id == 0x00000390) return "XuiFigureSetTexture";
  if (id == 0x00000391) return "XuiControlGetItemAssociation";
  if (id == 0x00000392) return "XuiResourceLoadAll";
  if (id == 0x00000393) return "XuiImageElementSetImagePath";
  if (id == 0x00000394) return "XuiImageElementGetImagePath";
  if (id == 0x00000395) return "XuiControlGetVisual";
  if (id == 0x00000396) return "XuiControlGetNavigation";
  if (id == 0x00000397) return "XuiLookupStringTableByIndex";
  if (id == 0x00000398) return "XUIElementPropVal_SetBool";
  if (id == 0x00000399) return "XuiElementHasFocus";
  if (id == 0x0000039A) return "XUIElementPropVal_SetUint";
  if (id == 0x0000039B) return "XUIElementPropVal_Clear";
  if (id == 0x0000039C) return "XuiEditSetTextFormatInfo";
  if (id == 0x0000039D) return "XuiCreateSolidBrush";
  if (id == 0x0000039E) return "XuiSceneInterruptTransitions";
  if (id == 0x0000039F) return "XuiResourceOpen";
  if (id == 0x000003A0) return "XuiResourceRead";
  if (id == 0x000003A1) return "XuiResourceClose";
  if (id == 0x000003A2) return "XuiVisualCreateInstance";
  if (id == 0x000003A3) return "XuiElementGetTimeline";
  if (id == 0x000003A4) return "GetCodecVersion";
  if (id == 0x000003A5) return "XuiElementIsDescendant";
  if (id == 0x000003A6) return "XuiSetMessageFilter";
  if (id == 0x000003A7) return "XuiAttachTextureBrush";
  if (id == 0x000003A8) return "XuiElementBeginRender";
  if (id == 0x000003A9) return "XuiElementEndRender";
  if (id == 0x000003AA) return "XuiDrawShape";
  if (id == 0x000003AB) return "XuiSelectBrushEx";
  if (id == 0x000003AC) return "XuiFigureGetShape";
  if (id == 0x000003AD) return "XuiFillRect";
  if (id == 0x000003AE) return "XuiVec2TransformCoord";
  if (id == 0x000003AF) return "XuiMatrixMultiply";
  if (id == 0x000003B0) return "XuiElementGetXForm";
  if (id == 0x000003B1) return "XuiElementSetPosition";
  if (id == 0x000003B2) return "XuiSelectBrush";
  if (id == 0x000003B3) return "XuiElementRenderChildren";
  if (id == 0x000003B4) return "XuiFreeUnusedTextures";
  if (id == 0x000003B5) return "XuiListEnableItemOverride";
  if (id == 0x000003B6) return "XuiListGetDefaultItemSize";
  if (id == 0x000003B7) return "XuiResourceSeek";
  if (id == 0x000003B8) return "XuiElementDiscardResources";
  if (id == 0x000003B9) return "XuiTabSceneGoto";
  if (id == 0x000003BA) return "XuiTabSceneGetCurrentTab";
  if (id == 0x000003BB) return "XamShowWhatsOnUI";
  if (id == 0x000003BC) return "XamShowEditProfileUI";
  if (id == 0x000003BD) return "XamShowStorePickerUI";
  if (id == 0x000003BE) return "XamShowTermsOfUseUI";
  if (id == 0x000003BF) return "XamShowJoinPartyUI";
  if (id == 0x000003C0) return "XamShowWordRegisterUI";
  if (id == 0x000003C1) return "XamOverrideHudOpenType";
  if (id == 0x000003C2) return "XamShowAchievementsUIEx";
  if (id == 0x000003C3) return "XamUserGetUserTenure";
  if (id == 0x000003C4) return "XamUserGetSubscriptionType";
  if (id == 0x000003C5) return "XamShowGameVoiceChannelUI";
  if (id == 0x000003C6) return "XamShowAvatarAwardsUI";
  if (id == 0x000003C7) return "XamShowAvatarAwardGamesUI";
  if (id == 0x000003C8) return "XamShowVideoRichPresenceUI";
  if (id == 0x000003C9) return "XamHudGetUserIndex";
  if (id == 0x000003CA) return "XGetAudioFlags";
  if (id == 0x000003CB) return "XGetAVPack";
  if (id == 0x000003CC) return "XGetGameRegion";
  if (id == 0x000003CD) return "XGetLanguage";
  if (id == 0x000003CE) return "XapipGetLocale";
  if (id == 0x000003CF) return "XGetVideoFlags";
  if (id == 0x000003D0) return "XGetVideoStandard";
  if (id == 0x000003D1) return "XGetVideoMode";
  if (id == 0x000003D2) return "XamGetLanguage";
  if (id == 0x000003D3) return "XUITimeline_Run";
  if (id == 0x000003D4) return "XamSetAutomation";
  if (id == 0x000003D5) return "XAutomationpBindController";
  if (id == 0x000003D6) return "XAutomationpUnbindController";
  if (id == 0x000003D7) return "XAutomationpInputXenonButton";
  if (id == 0x000003D8) return "XAutomationpInputPress";
  if (id == 0x000003D9) return "XAutomationpInputSetState";
  if (id == 0x000003DA) return "XamEnableOverdraw";
  if (id == 0x000003DB) return "g_XuiAutomation";
  if (id == 0x000003DC) return "XamVoiceGetMicArrayAudio";
  if (id == 0x000003DD) return "XampSystemInput";
  if (id == 0x000003DE) return "XamInputControl";
  if (id == 0x000003DF) return "XuiElementGetPosition";
  if (id == 0x000003E0) return "XamIsMessageBoxActive";
  if (id == 0x000003E1) return "XamIsBackgroundSceneInTransition";
  if (id == 0x000003E2) return "XuiElementTreeHasFocus";
  if (id == 0x000003E3) return "XuiFigureClose";
  if (id == 0x000003E4) return "GamerCardStartup";
  if (id == 0x000003E5) return "GamerCardCleanup";
  if (id == 0x000003E6) return "GamerCardRegisterControls";
  if (id == 0x000003E7) return "GamerCardUnregisterControls";
  if (id == 0x000003E8) return "RtlFindFirstFile";
  if (id == 0x000003E9) return "RtlFindNextFile";
  if (id == 0x000003EA) return "RtlGetModuleFileName";
  if (id == 0x000003EB) return "RtlOutputDebugString";
  if (id == 0x000003EC) return "RtlRemoveDirectory";
  if (id == 0x000003ED) return "RtlSleep";
  if (id == 0x000003EE) return "RtlGetLastError";
  if (id == 0x000003EF) return "RtlSetLastError";
  if (id == 0x000003F0) return "RtlSetLastNTError";
  if (id == 0x000003F1) return "RtlDebugPrint";
  if (id == 0x000003F2) return "RtlDebugError";
  if (id == 0x000003F3) return "XDebugWarning";
  if (id == 0x000003F4) return "RtlDebugTrace";
  if (id == 0x000003F5) return "RtlDebugEntry";
  if (id == 0x000003F6) return "RtlDebugExit";
  if (id == 0x000003F7) return "RtlGetAttributesOnHeapAlloc";
  if (id == 0x000003F8) return "RtlSetAttributesOnHeapAlloc";
  if (id == 0x000003F9) return "XuiFigureSetShape";
  if (id == 0x000003FA) return "RtlCreateHeap";
  if (id == 0x000003FB) return "RtlDestroyHeap";
  if (id == 0x000003FC) return "RtlAllocateHeap";
  if (id == 0x000003FD) return "RtlAllocateHeapSlowly";
  if (id == 0x000003FE) return "RtlReAllocateHeap";
  if (id == 0x000003FF) return "RtlFreeHeap";
  if (id == 0x00000400) return "RtlFreeHeapSlowly";
  if (id == 0x00000401) return "RtlSizeHeap";
  if (id == 0x00000402) return "RtlZeroHeap";
  if (id == 0x00000403) return "RtlDebugWalkHeap";
  if (id == 0x00000404) return "RtlWalkHeap";
  if (id == 0x00000405) return "RtlLockHeap";
  if (id == 0x00000406) return "RtlUnlockHeap";
  if (id == 0x00000407) return "RtlValidateHeap";
  if (id == 0x00000408) return "RtlDebugCompactHeap";
  if (id == 0x00000409) return "RtlCompactHeap";
  if (id == 0x0000040A) return "XamAppSetTestOption";
  if (id == 0x0000040B) return "XamAppReportError";
  if (id == 0x0000040C) return "XamIsNuiUIActive";
  if (id == 0x0000040D) return "XamVerifyPasscode";
  if (id == 0x0000040E) return "OutputDebugStringA";
  if (id == 0x0000040F) return "DebugBreak";
  if (id == 0x00000410) return "GetCurrentThreadId";
  if (id == 0x00000411) return "XDebugError";
  if (id == 0x00000412) return "XDebugWarning_0";
  if (id == 0x00000413) return "RtlDebugSetLevel";
  if (id == 0x00000414) return "CloseHandle";
  if (id == 0x00000415) return "GetTickCount";
  if (id == 0x00000416) return "GetLastError";
  if (id == 0x00000417) return "SetFilePointer";
  if (id == 0x00000418) return "SetFilePointerEx";
  if (id == 0x00000419) return "SetLastError";
  if (id == 0x0000041A) return "MultiByteToWideChar";
  if (id == 0x0000041B) return "WideCharToMultiByte";
  if (id == 0x0000041C) return "ReadFile";
  if (id == 0x0000041D) return "FlushFileBuffers";
  if (id == 0x0000041E) return "WriteFile";
  if (id == 0x0000041F) return "OutputDebugStringW";
  if (id == 0x00000420) return "SetEvent";
  if (id == 0x00000421) return "XapiFormatTimeOut";
  if (id == 0x00000422) return "CreateMutexA";
  if (id == 0x00000423) return "OpenMutexA";
  if (id == 0x00000424) return "ReleaseMutex";
  if (id == 0x00000425) return "WaitForSingleObject";
  if (id == 0x00000426) return "WaitForSingleObjectEx";
  if (id == 0x00000427) return "GetFileSize";
  if (id == 0x00000428) return "GetFileSizeEx";
  if (id == 0x00000429) return "XapiDirectoryInformationToFindData";
  if (id == 0x0000042A) return "XapiFormatObjectAttributes";
  if (id == 0x0000042B) return "ResetEvent";
  if (id == 0x0000042C) return "wsprintfA";
  if (id == 0x0000042D) return "wsprintfW";
  if (id == 0x0000042E) return "GetOverlappedResult";
  if (id == 0x0000042F) return "QueryPerformanceCounter";
  if (id == 0x00000430) return "QueryPerformanceFrequency";
  if (id == 0x00000431) return "LocalAlloc";
  if (id == 0x00000432) return "LocalFree";
  if (id == 0x00000433) return "RaiseException";
  if (id == 0x00000434) return "RtlUniform";
  if (id == 0x00000435) return "RtlRandom";
  if (id == 0x00000436) return "Sleep";
  if (id == 0x00000437) return "SleepEx";
  if (id == 0x00000438) return "XMemSet";
  if (id == 0x00000439) return "XRegisterThreadNotifyRoutine";
  if (id == 0x0000043A) return "XGetOverlappedExtendedError";
  if (id == 0x0000043B) return "XGetOverlappedResult";
  if (id == 0x0000043C) return "CreateThread";
  if (id == 0x0000043D) return "ResumeThread";
  if (id == 0x0000043E) return "ExitThread";
  if (id == 0x0000043F) return "GetTimeZoneInformation";
  if (id == 0x00000440) return "GetSystemTimeAsFileTime";
  if (id == 0x00000441) return "SystemTimeToFileTime";
  if (id == 0x00000442) return "FileTimeToSystemTime";
  if (id == 0x00000443) return "GetSystemTime";
  if (id == 0x00000444) return "GetLocalTime";
  if (id == 0x00000445) return "CreateDirectoryA";
  if (id == 0x00000446) return "CreateEventA";
  if (id == 0x00000447) return "CreateFileA";
  if (id == 0x00000448) return "DeleteFileA";
  if (id == 0x00000449) return "FindFirstFileA";
  if (id == 0x0000044A) return "FindNextFileA";
  if (id == 0x0000044B) return "GetFileAttributesA";
  if (id == 0x0000044C) return "XamLoaderGetCurrentTitleD3DVersion";
  if (id == 0x0000044D) return "GetFileAttributesExA";
  if (id == 0x0000044E) return "GetModuleHandleA";
  if (id == 0x0000044F) return "GetDiskFreeSpaceExA";
  if (id == 0x00000450) return "CopyFileA";
  if (id == 0x00000451) return "SetEndOfFile";
  if (id == 0x00000452) return "XamFamilyAddParentalExemptionToList";
  if (id == 0x00000453) return "XamFamilyIsParentalValidationRequired";
  if (id == 0x00000454) return "PIXBeginCapture";
  if (id == 0x00000455) return "PIXEndCapture";
  if (id == 0x00000456) return "PIXAddCounter";
  if (id == 0x00000457) return "PIXGetGPUSlot";
  if (id == 0x00000458) return "SetWaitableTimer";
  if (id == 0x00000459) return "CancelWaitableTimer";
  if (id == 0x0000045A) return "CreateWaitableTimerA";
  if (id == 0x0000045B) return "DuplicateHandle";
  if (id == 0x0000045C) return "XapipCreateThread";
  if (id == 0x0000045D) return "lstrcpyA";
  if (id == 0x0000045E) return "lstrcpyW";
  if (id == 0x0000045F) return "lstrcpynA";
  if (id == 0x00000460) return "lstrcpynW";
  if (id == 0x00000461) return "lstrcatA";
  if (id == 0x00000462) return "lstrcatW";
  if (id == 0x00000463) return "lstrlenA";
  if (id == 0x00000464) return "lstrlenW";
  if (id == 0x00000465) return "IsBadReadPtr";
  if (id == 0x00000466) return "IsBadWritePtr";
  if (id == 0x00000467) return "FileTimeToLocalFileTime";
  if (id == 0x00000468) return "XMemCpy";
  if (id == 0x00000469) return "XMemCpyStreaming";
  if (id == 0x0000046A) return "XamHudSetUserIndex";
  if (id == 0x0000046B) return "XamShowNuiTroubleshooterUI";
  if (id == 0x0000046C) return "XamTestShowNuiTroubleshooterUI";
  if (id == 0x0000046D) return "XamShowPasscodeVerifyUIEx";
  if (id == 0x0000046E) return "XamShowNuiAchievementsUI";
  if (id == 0x0000046F) return "XamShowNuiCommunitySessionsUI";
  if (id == 0x00000470) return "XamShowNuiDeviceSelectorUI";
  if (id == 0x00000471) return "XamShowNuiDirtyDiscErrorUI";
  if (id == 0x00000472) return "XamShowNuiFriendsUI";
  if (id == 0x00000473) return "XamShowNuiGameInviteUI";
  if (id == 0x00000474) return "XamShowNuiGamerCardUIForXUID";
  if (id == 0x00000475) return "XamShowNuiMarketplaceDownloadItemsUI";
  if (id == 0x00000476) return "XamShowNuiMarketplaceUI";
  if (id == 0x00000477) return "XamShowNuiMessageBoxUI";
  if (id == 0x00000478) return "XamShowNuiPartyUI";
  if (id == 0x00000479) return "XamShowNuiFriendRequestUI";
  if (id == 0x0000047A) return "XamShowNuiSigninUI";
  if (id == 0x0000047B) return "XamShowNuiControllerRequiredUI";
  if (id == 0x0000047C) return "XamShowNuiGamesUI";
  if (id == 0x0000047D) return "XamShowNuiHardwareRequiredUI";
  if (id == 0x0000047E) return "XamCacheStoreFileByString";
  if (id == 0x0000047F) return "XamCacheFetchFileByString";
  if (id == 0x00000480) return "XamCacheDeleteFileByString";
  if (id == 0x00000481) return "XamGetCachedTitleNameEx";
  if (id == 0x00000482) return "XamXlfsInitializeUploadQueue";
  if (id == 0x00000483) return "XamXlfsUninitializeUploadQueue";
  if (id == 0x00000484) return "XamXlfsMountUploadQueueInstance";
  if (id == 0x00000485) return "XamXlfsUnmountUploadQueueInstance";
  if (id == 0x00000486) return "XamVoiceRecordUserPrivileges";
  if (id == 0x00000487) return "XamXlfsInitializeUploadQueueWithTestHooks";
  if (id == 0x00000488) return "XamXlfsNotifyContentDeletion";
  if (id == 0x00000489) return "XMemAlloc";
  if (id == 0x0000048A) return "XMemFree";
  if (id == 0x0000048B) return "XMemSize";
  if (id == 0x0000048C) return "XamVoiceSetMicArrayIdleUsers";
  if (id == 0x0000048D) return "XamVoiceMuteMicArray";
  if (id == 0x0000048E) return "XamVoiceGetMicArrayUnderrunStatus";
  if (id == 0x0000048F) return "XuiSceneEnableTransitionDependency";
  if (id == 0x00000490) return "XamVoiceGetMicArrayAudioEx";
  if (id == 0x00000491) return "XamVoiceDisableMicArray";
  if (id == 0x00000492) return "XamUserGetDeviceId";
  if (id == 0x00000493) return "XamUpdateEtxLogUpdateTaskStart";
  if (id == 0x00000494) return "XamUpdateEtxLogUpdateTaskSuccess";
  if (id == 0x00000495) return "XamUpdateEtxLogUpdateTaskFailure";
  if (id == 0x00000496) return "XamEtxFlushLogs";
  if (id == 0x00000497) return "XamVoiceIsActiveProcess";
  if (id == 0x00000498) return "XamInactivityGetInactivityInterruptTime";
  if (id == 0x00000499) return "XamInactivitySetInactivityInterruptTime";
  if (id == 0x0000049A) return "XamInactivityGetLastActivityTime";
  if (id == 0x0000049B) return "XamInactivitySetDetectionTaskPeriod";
  if (id == 0x0000049C) return "XamInactivityEnablePowerDown";
  if (id == 0x0000049D) return "XamUpdateGetChainMarker";
  if (id == 0x0000049E) return "XGetVideoCapabilities";
  if (id == 0x0000049F) return "XMsgProcessRequest";
  if (id == 0x000004A0) return "XGetDisplaySize";
  if (id == 0x000004A1) return "XamInputNonControllerGetRaw";
  if (id == 0x000004A2) return "XamInputNonControllerSetRaw";
  if (id == 0x000004A3) return "XamVoiceSetMicArrayBeamAngle";
  if (id == 0x000004A4) return "XamUserGetAge";
  if (id == 0x000004A5) return "XamUserGetAgeGroup";
  if (id == 0x000004A6) return "XamVoiceGetMicArrayFilenameDesc";
  if (id == 0x000004A7) return "XamLoaderGetState";
  if (id == 0x000004A8) return "XamTaskQueryProperty";
  if (id == 0x000004A9) return "XamGetLocale";
  if (id == 0x000004AA) return "XamQueryTimeZoneInformation";
  if (id == 0x000004AB) return "XamSetTimeZoneInformation";
  if (id == 0x000004AC) return "XamLaunchURI";
  if (id == 0x000004AF) return "XamShowNuiMessagesUI";
  if (id == 0x000004B0) return "XMPRegisterCodec";
  if (id == 0x000004B1) return "XamNavigateBack";
  if (id == 0x000004B2) return "XamPushBackURI";
  if (id == 0x000004B3) return "XamUserOverrideDeviceBindings";
  if (id == 0x000004B4) return "XamUserOverrideBindingCallbacks";
  if (id == 0x000004B5) return "XamUserOverrideUserInfo";
  if (id == 0x000004B6) return "XamUserContentRestrictionGetFlags";
  if (id == 0x000004B7) return "XamUserContentRestrictionGetRating";
  if (id == 0x000004B8) return "XamUserContentRestrictionCheckAccess";
  if (id == 0x000004B9) return "XamShowFitnessBodyProfileUI";
  if (id == 0x000004BA) return "XamFitnessAddBodyProfileRecord";
  if (id == 0x000004BB) return "XamFamilyGetMembers";
  if (id == 0x000004BC) return "XampXAuthStartup";
  if (id == 0x000004BD) return "XampXAuthShutdown";
  if (id == 0x000004BE) return "XamGetToken";
  if (id == 0x000004BF) return "XamFreeToken";
  if (id == 0x000004C0) return "XamGetAppliesTo";
  if (id == 0x000004C1) return "XamFitnessClearBodyProfileRecords";
  if (id == 0x000004C2) return "XamFitnessGetCurrentBodyProfileRecord";
  if (id == 0x000004C3) return "XamFitnessGetAllBodyProfileRecords";
  if (id == 0x000004C4) return "XamFitnessGetAllTitleSummaries";
  if (id == 0x000004C5) return "XamFitnessGetOverallSummary";
  if (id == 0x000004C6) return "XamFitnessAddFitnessEvent";
  if (id == 0x000004C7) return "XamLrcGetInput";
  if (id == 0x000004C8) return "XamLrcGetInputWithSeek";
  if (id == 0x000004C9) return "XamLrcSetMediaState";
  if (id == 0x000004CA) return "XamPixSetDirtyCounters";
  if (id == 0x000004CB) return "XamFitnessCreateFitnessEventEnumerator";
  if (id == 0x000004CC) return "XamFitnessInitialize";
  if (id == 0x000004CD) return "XamRequestToken";
  if (id == 0x000004CE) return "XamResolveURI";
  if (id == 0x000004CF) return "XamContentGetOnlineCreator";
  if (id == 0x000004D0) return "XamShowBrandedKeyboardUI";
  if (id == 0x000004D1) return "XamBackgroundDownloadNetworkStorageEnable";
  if (id == 0x000004D2) return "XamBackgroundDownloadNetworkStorageIsEnabled";
  if (id == 0x000004D3) return "XamShowNuiJoinSessionInProgressUI";
  if (id == 0x000004D4) return "XamBase64Decode";
  if (id == 0x000004D5) return "XamCertDecode";
  if (id == 0x000004D6) return "XamCertDecodeRsaPublicKey";
  if (id == 0x000004D7) return "XamCertValidateStruct";
  if (id == 0x000004D8) return "XamFitnessConvertByteMetToFloatMet";
  if (id == 0x000004D9) return "XamXgiBlobTrackerSetMockInfo";
  if (id == 0x000004DA) return "XamFitnessMsgTimeToSystemTime";
  if (id == 0x000004DB) return "XamFitnessSystemTimeToMsgTime";
  if (id == 0x000004DC) return "XamShowFitnessWarnAboutPrivacyUI";
  if (id == 0x000004DD) return "XamShowFitnessWarnAboutTimeUI";
  if (id == 0x000004DE) return "XamFitnessUnInitialize";
  if (id == 0x000004DF) return "XamBackgroundDownloadNetworkStorageOnContentChange";
  if (id == 0x000004E0) return "XamLiveBaseConfigureInMemoryMockResponse";
  if (id == 0x000004E1) return "InjectConnectionServerNotification";
  if (id == 0x000004E2) return "XamFitnessConvertFloatMetToByteMet";
  if (id == 0x000004E3) return "XamGetGamerTileKeyFromGamertag";
  if (id == 0x000004E4) return "XamBackgroundDownloadNetworkStorageRegisterChangeCallback";
  if (id == 0x000004E5) return "XamFindOrCreateInternalPassportAccount";
  if (id == 0x000004E6) return "XOnlinepFriendsRequest";
  if (id == 0x000004E7) return "XOnlinepFriendsAcceptRequest";
  if (id == 0x000004E8) return "XOnlinepFriendsRejectRequest";
  if (id == 0x000004E9) return "XOnlinepFriendsRemove";
  if (id == 0x000004EA) return "XFriendsCreateEnumerator";
  if (id == 0x000004EB) return "XamBackgroundDownloadNetworkStorageIsRunning";
  if (id == 0x000004EC) return "XamCertGetSerialNumber";
  if (id == 0x000004ED) return "XamShowOptionsUI";
  if (id == 0x000004EE) return "XampXAuthGetTitleBuffer";
  if (id == 0x000004EF) return "XamGetSTSTokenCache";
  if (id == 0x000004F0) return "XamUserGetOnlineXUIDFromOfflineXUID";
  if (id == 0x000004F1) return "XamIsUserUsingMetricSystem";
  if (id == 0x000004F2) return "XamShowNuiVideoRichPresenceUI";
  if (id == 0x000004F3) return "XamAppAllocateInterappWorkspaceEx";
  if (id == 0x000004F4) return "XampKioskSetTestMock";
  if (id == 0x000004F5) return "XamNetworkStatusGetInformation";
  if (id == 0x000004F6) return "XamNetworkStatusAddAddress";
  if (id == 0x000004F7) return "XamUserReadUserPreference";
  if (id == 0x000004F8) return "XamUserWriteUserPreference";
  if (id == 0x000004F9) return "XamShowFitnessClearUI";
  if (id == 0x000004FA) return "XamFitnessClearAll";
  if (id == 0x000004FB) return "XamFitnessGetPrivacySettings";
  if (id == 0x000004FC) return "XamWaitForNSAL";
  if (id == 0x000004FD) return "XamMarkInternalAccountTrustedOnConsole";
  if (id == 0x000004FE) return "XamBackgroundDownloadNetworkStorageGetProgress";
  if (id == 0x000004FF) return "XamCopyFile";
  if (id == 0x00000500) return "XamMoveFile";
  if (id == 0x00000501) return "XamDeleteFile";
  if (id == 0x00000502) return "XamUserOverrideGlobalState";
  if (id == 0x00000503) return "XamGetAdaptersCollection";
  if (id == 0x00000504) return "XampKioskIsSimulationMode";
  if (id == 0x00000505) return "XamIsUIThread";
  if (id == 0x00000506) return "XamInputSendXenonButtonPress";
  if (id == 0x00000507) return "XamDebugGetURISchemeCount";
  if (id == 0x00000508) return "XamDebugGetURISchemeInfo";
  if (id == 0x00000509) return "XamGetOnlineCountryFromLocale";
  if (id == 0x0000050A) return "XTestOnlineIsConnectedToLive";
  if (id == 0x0000050B) return "XamGetConsoleFriendlyName";
  if (id == 0x0000050C) return "XamSetConsoleFriendlyName";
  if (id == 0x0000050D) return "XamGetCountry";
  if (id == 0x0000050E) return "XamPackageManagerGetFilePathW";
  if (id == 0x0000050F) return "XamGetCurrentDemand";
  if (id == 0x00000510) return "XamCompleteDemand";
  if (id == 0x00000511) return "XamDemand";
  if (id == 0x00000512) return "XamFormatSystemDateString";
  if (id == 0x00000513) return "XamDebugGetBackURI";
  if (id == 0x00000514) return "XamIsCurrentTitleIptv";
  if (id == 0x00000515) return "XamIsIptvEnabled";
  if (id == 0x00000516) return "XamIsDvrRecording";
  if (id == 0x00000517) return "XamIptvUninstall";
  if (id == 0x00000518) return "XamGetDvrStorage";
  if (id == 0x00000519) return "XamSetDvrStorage";
  if (id == 0x0000051A) return "XamIptvGetServiceName";
  if (id == 0x0000051B) return "XamNuiHudGetEngagedEnrollmentIndex";
  if (id == 0x0000051C) return "XamProfileSetCachedWindowsLiveEmail";
  if (id == 0x0000051D) return "XamProfileGetCachedWindowsLiveEmail";
  if (id == 0x0000051E) return "XamUserResetSubscriptionType";
  if (id == 0x0000051F) return "XamLrcSetTitlePort";
  if (id == 0x00000520) return "XamLrcVerifyClientId";
  if (id == 0x00000521) return "XamLrcEncryptDecryptTitleMessage";
  if (id == 0x00000522) return "XamFitnessGetSyncStatus";
  if (id == 0x00000523) return "XamFitnessInitializeForOneUser";
  if (id == 0x00000524) return "XamFitnessGetSuggestedPrivacySettings";
  if (id == 0x00000525) return "XampFitnessLetFireAndForgetsCatchUpInternal";
  if (id == 0x00000526) return "XamInputGetFailedConnectionOrBind";
  if (id == 0x00000527) return "XuiSceneIsInTransition";
  if (id == 0x00000528) return "XamIsOnPrivateNetwork";
  if (id == 0x00000529) return "XamInputSetMinMaxAuthDelay";
  if (id == 0x0000052A) return "XamInputNonControllerGetRawEx";
  if (id == 0x0000052B) return "XamInputNonControllerSetRawEx";
  if (id == 0x0000052C) return "XamMarketplaceAcquireFreeContent";
  if (id == 0x0000052D) return "XamGetClosedCaptioningState";
  if (id == 0x0000052E) return "XamGetClosedCaptioningSettings";
  if (id == 0x0000052F) return "XamSetClosedCaptioningState";
  if (id == 0x00000530) return "XamLoaderGetLogonTitle";
  if (id == 0x00000531) return "XamBeginDemand";
  if (id == 0x00000532) return "XamGetErrorStringFromWebService";
  if (id == 0x00000533) return "XamGetModernPresenceWorkspaceSize";
  if (id == 0x00000534) return "XamGetModernPresence";
  if (id == 0x00000535) return "XamGetSingleModernPresence";
  if (id == 0x00000536) return "XamGetModernPresenceImageUrl";
  if (id == 0x00000537) return "XGetSSLCertBypassEnabled";
  if (id == 0x00000538) return "XamIsNetworkCaptivePortal";
  if (id == 0x00000539) return "XamShowAndWaitForMessageBoxEx";
  if (id == 0x0000053B) return "XamGetCurrencyFormat";
  if (id == 0x0000053C) return "XamFormatCurrency";
  if (id == 0x0000053D) return "XamReportTLSConnect";
  if (id == 0x0000053E) return "XamGetXSTSTokenExpiryPeriodMS";
  if (id == 0x0000053F) return "XamGetUserBalance";
  if (id == 0x00000540) return "XamIsGuideDisabled";
  if (id == 0x00000541) return "XampCallXAccountTransitionStoredValuePointsToCurrency";
  if (id == 0x00000542) return "XampSetMockCallXAccountTransitionStoredValuePointsToCurrency";
  if (id == 0x00000543) return "XamShowCsvTransitionUI";
  if (id == 0x00000544) return "XamAskUserForCSVDrainagePermission";
  if (id == 0x00000545) return "XamIsCSVDrainageSupported";
  if (id == 0x0000056C) return "XamGetTLSConfig";
  if (id == 0x00000577) return "XamGetServiceEndpoint";
  if (id == 0x00000578) return "XamReminderGetItems";
  if (id == 0x00000579) return "XamReminderClearItems";
  if (id == 0x0000057A) return "XamReminderItemAdd";
  if (id == 0x0000057B) return "XamReminderItemRemove";
  if (id == 0x0000057C) return "XamReminderGetNextItem";
  if (id == 0x0000057D) return "XamReminderGetModifiedTime";
  if (id == 0x0000057E) return "XamReminderClearCache";
  if (id == 0x0000057F) return "XamLrcKeyboardGetInput";
  if (id == 0x00000580) return "XamLrcKeyboardGetRequiredBufferSize";
  if (id == 0x00000581) return "XamLrcKeyboardRegister";
  if (id == 0x00000582) return "XamLrcKeyboardUnregister";
  if (id == 0x00000583) return "XamLrcKeyboardUpdateText";
  if (id == 0x00000584) return "XamValidateCountry";
  if (id == 0x00000585) return "XamGetOnlineCountryString";
  if (id == 0x00000586) return "XamGetCountryString";
  if (id == 0x00000587) return "XamGetLanguageString";
  if (id == 0x00000588) return "XamGetLanguageLocaleString";
  if (id == 0x00000589) return "XamGetOnlineLanguageAndCountryString";
  if (id == 0x0000058A) return "XamGetLanguageLocaleFallbackString";
  if (id == 0x0000058B) return "XamGetOnlineLanguageAndCountry";
  if (id == 0x0000058C) return "XamGetLanguageTypeface";
  if (id == 0x0000058D) return "XamGetLanguageTypefacePatch";
  if (id == 0x0000058E) return "XamGetLocaleString";
  if (id == 0x0000058F) return "XamGetLocaleFromOnlineCountry";
  if (id == 0x00000590) return "XamOfflineTimerSetData";
  if (id == 0x00000591) return "XamOfflineTimerResume";
  if (id == 0x00000592) return "XamOfflineTimerSuspend";
  if (id == 0x00000593) return "XamOfflineTimerIsRunning";
  if (id == 0x00000594) return "XamOfflineTimerIsEnabled";
  if (id == 0x00000595) return "XamOfflineTimerGetTimeRemaining";
  if (id == 0x00000596) return "XamOfflineTimerGetContractData";
  if (id == 0x00000597) return "XamOfflineTimerInitialize";
  if (id == 0x00000598) return "XamOfflineTimerGetData";
  if (id == 0x00000599) return "XamPlayToRegister";
  if (id == 0x0000059A) return "XamPlayToReportPlaybackState";
  if (id == 0x0000059B) return "XamPlayToUnregister";
  if (id == 0x0000059C) return "XamShowTFAUI";
  if (id == 0x0000059D) return "OnReconnect";
  if (id == 0x0000059E) return "XamGetOnlineCountryFeatures";
  if (id == 0x0000059F) return "XamLogLocalizationEtx";
  if (id == 0x000005A0) return "XampXAuthIsLocalSocketAllowed";
  if (id == 0x000005A1) return "XamPlayToGetRequest";
  if (id == 0x000005A2) return "XamPlayToCancelGetRequest";
  if (id == 0x000005A3) return "XamPlayToCompleteRequest";
  if (id == 0x000005A4) return "XamFitnessGetTitleSummaries";
  if (id == 0x000005A5) return "XamFitnessGetTitleSummary";
  if (id == 0x000005A6) return "XamOfflineTimerShutdown";
  if (id == 0x000005A7) return "XamFitnessContainsFitnessData";
  if (id == 0x000005A8) return "XamGetLanguageFromOnlineLanguage";
  if (id == 0x000005A9) return "XamGetOnlineLanguageString";
  if (id == 0x000005AA) return "XamGetCountryFromOnlineCountry";
  if (id == 0x000005D7) return "XamGetLocaleEx";
  if (id == 0x000005D8) return "XamOfflineTimerForceQuery";
  if (id == 0x000005D9) return "XamShowCreateProfileUIEx";
  if (id == 0x000005DA) return "XTLGetLanguageV2";
  if (id == 0x000005DB) return "XTLGetLocaleV1";
  if (id == 0x000005DC) return "XamAvatarInitialize";
  if (id == 0x000005DD) return "XamAvatarShutdown";
  if (id == 0x000005DE) return "XamAvatarGetManifestLocalUser";
  if (id == 0x000005DF) return "XamAvatarGetManifestsByXuid";
  if (id == 0x000005E0) return "XamAvatarGetAssetsResultSize";
  if (id == 0x000005E1) return "XamAvatarGetAssets";
  if (id == 0x000005E2) return "XamAvatarGenerateMipMaps";
  if (id == 0x000005E3) return "XamAvatarSetCustomAsset";
  if (id == 0x000005E4) return "XamAvatarSetManifest";
  if (id == 0x000005E5) return "EnumerateMediaObjects";
  if (id == 0x000005E6) return "EnumerateMediaObjects_0";
  if (id == 0x000005E7) return "XamAvatarLoadAnimation";
  if (id == 0x000005E8) return "XamAvatarBeginEnumAssets";
  if (id == 0x000005E9) return "XamAvatarEndEnumAssets";
  if (id == 0x000005EA) return "XamAvatarEnumAssets";
  if (id == 0x000005EB) return "XamAvatarGetMetadataRandom";
  if (id == 0x000005EC) return "EnumerateMediaObjects_1";
  if (id == 0x000005ED) return "EnumerateMediaObjects_2";
  if (id == 0x000005EE) return "XamAvatarGetMetadataSignedOutProfileCount";
  if (id == 0x000005EF) return "XamAvatarGetMetadataSignedOutProfile";
  if (id == 0x000005F0) return "EnumerateMediaObjects_3";
  if (id == 0x000005F1) return "XamAvatarManifestGetBodyType";
  if (id == 0x000005F2) return "XamAvatarGetInstrumentation";
  if (id == 0x000005F3) return "XamAvatarGetAssetIcon";
  if (id == 0x000005F4) return "XamAvatarWearNow";
  if (id == 0x000005F5) return "XamAvatarGetAssetBinary";
  if (id == 0x000005F6) return "XamAvatarReinstallAwardedAsset";
  if (id == 0x000005F7) return "XamAvatarGetInstalledAssetPackageDescription";
  if (id == 0x000005F8) return "XamAvatarSetMocks";
  if (id == 0x000005F9) return "XamLrcKeyboardValidateTextChange";
  if (id == 0x000005FA) return "XamLrcKeyboardApplyTextChange";
  if (id == 0x000005FB) return "XamLrcLogSessionSummary";
  if (id == 0x000005FC) return "XamLrcLogError";
  if (id == 0x0000060E) return "XamContentMountInstalledGame";
  if (id == 0x0000060F) return "XamContentIsGameInstalledToHDD";
  if (id == 0x00000610) return "XamContentQueryLicenseInternal";
  if (id == 0x00000611) return "XamContentGetDeviceVolumePath";
  if (id == 0x00000612) return "XamContentDeviceCheckUpdates";
  if (id == 0x00000613) return "XamContentGetHeaderInternal";
  if (id == 0x00000614) return "XamNetworkStorageGetNetworkDevice";
  if (id == 0x00000615) return "XamNetworkStorageDeviceHasCacheFile";
  if (id == 0x00000616) return "XamNetworkStorageCreateCacheOnDevice";
  if (id == 0x00000617) return "XamNetworkStorageDeleteCacheOnDevice";
  if (id == 0x00000618) return "XamNetworkStorageGetStatus";
  if (id == 0x00000619) return "XamNetworkStorageIsSupportedContentType";
  if (id == 0x0000061A) return "XamNetworkStorageSetTestMock";
  if (id == 0x0000061B) return "XamNetworkStorageGetLastSyncTime";
  if (id == 0x0000061C) return "XamShowNetworkStorageSyncUI";
  if (id == 0x0000061D) return "XamUserIsLogonPreviewModeEnabled";
  if (id == 0x0000061E) return "XamUserLockLogonPreviewMode";
  if (id == 0x0000061F) return "XamUserUnlockLogonPreviewMode";
  if (id == 0x00000620) return "XamNetworkStorageIsUserInSync";
  if (id == 0x00000621) return "XamNetworkStorageSetUserInSync";
  if (id == 0x00000622) return "XamNetworkStorageOnSigninChanged";
  if (id == 0x00000623) return "XamNetworkStorageSignInTestMock";
  if (id == 0x00000624) return "XamShowFofUI";
  if (id == 0x00000625) return "CompareFileTime";
  if (id == 0x00000626) return "SetFileTime";
  if (id == 0x00000627) return "XamNetworkStorageGetTitleProperties";
  if (id == 0x00000628) return "XamNetworkStorageLockFile";
  if (id == 0x00000629) return "XamNetworkStorageUserHasPrivilege";
  if (id == 0x0000062A) return "XamNetworkStorageIsTitleExempt";
  if (id == 0x0000062B) return "XamContentExistsOnDeviceInternal";
  if (id == 0x0000062C) return "XamNetworkStorageGetBackingDevice";
  if (id == 0x0000062D) return "XamNetworkStorageIsEnabledInLiveHive";
  if (id == 0x0000062E) return "XamNetworkStorageIsCheckingSyncStates";
  if (id == 0x0000062F) return "XamNetworkStorageUserNeedsToSync";
  if (id == 0x00000630) return "XamNetworkStorageGetUserNetworkSyncTime";
  if (id == 0x00000631) return "XamNetworkStorageGetUserProperties";
  if (id == 0x00000632) return "XamNetworkStorageAppLauncherLaunchIfRunning";
  if (id == 0x00000633) return "XamNetworkStorageSetTitleProperties";
  if (id == 0x00000634) return "XamNetworkStorageGetUserLastError";
  if (id == 0x00000635) return "XamNetworkStorageCheckOutTitle";
  if (id == 0x00000636) return "XamNetworkStorageShouldHideFromTitle";
  if (id == 0x00000637) return "XamNetworkStorageOnUserSyncChange";
  if (id == 0x00000638) return "XamNetworkStorageHasUserEnabledStorage";
  if (id == 0x00000639) return "XamContentGetLocalizedDeviceData";
  if (id == 0x00000640) return "XamPackageManagerFindPackageContainingIndexedXEX";
  if (id == 0x00000641) return "XamPackageManagerReinitialize";
  if (id == 0x00000642) return "XamPackageManagerGetAuthoritativeManifestVersion";
  if (id == 0x00000643) return "XamGetCurrentSystemOnlineManifestRevision";
  if (id == 0x00000644) return "XamPackageManagerDeleteExtendedPartition";
  if (id == 0x00000645) return "XamPackageManagerHasExtendedPartition";
  if (id == 0x00000646) return "XamPackageManagerGetExperienceMode";
  if (id == 0x00000647) return "XamPackageManagerGetFeatureRequiresUpdateStrings";
  if (id == 0x00000648) return "XamPackageManagerGetFileSize";
  if (id == 0x00000649) return "XampDemandUpdateGetAttributes";
  if (id == 0x0000064A) return "XampDemandUpdateGetExtendedAttributes";
  if (id == 0x0000064B) return "XampDemandUpdateGetInstance";
  if (id == 0x0000064C) return "XampDemandUpdateSetRefreshTestFlags";
  if (id == 0x0000064D) return "XampDemandUpdateIsRefreshTestFlagSet";
  if (id == 0x0000064E) return "XampDemandUpdateGetManifestLocalPath";
  if (id == 0x0000064F) return "XampDemandUpdateRefreshManifest";
  if (id == 0x00000650) return "XdfInitialize";
  if (id == 0x00000651) return "XdfShutdown";
  if (id == 0x00000652) return "XdfGetExpectedDownloadSize";
  if (id == 0x00000653) return "XdfGetItem";
  if (id == 0x00000654) return "XdfCacheItem";
  if (id == 0x00000655) return "XdfLoadXexFromCache";
  if (id == 0x00000656) return "XdfLoadXex";
  if (id == 0x00000657) return "XdfCancelRequest";
  if (id == 0x00000658) return "XdfResumeDelayedItem";
  if (id == 0x00000659) return "XdfLaunchNewImageFromCache";
  if (id == 0x0000065A) return "XampDemandUpdateRefreshManifestDuringLogon";
  if (id == 0x0000065B) return "XampDemandUpdateCheckOnlineManifestChanged";
  if (id == 0x0000065C) return "XampDemandUpdateRunCacheCleaner";
  if (id == 0x00000685) return "XamUpdateGetTitleUpdateSizeThreshold";
  if (id == 0x00000686) return "XamXStudioRequest";
  if (id == 0x00000687) return "XamNotifyDelayUIInternal";
  if (id == 0x000006A4) return "XamShowAvatarMiniCreatorUI";
  if (id == 0x000006A5) return "XamShowGoldUpgradeUI";
  if (id == 0x000006A6) return "XamResumeUpdaterUI";
  if (id == 0x000006A7) return "XamShowDirectAcquireUI";
  if (id == 0x000006A8) return "XamShowPaymentOptionsUI";
  if (id == 0x000006A9) return "XamShowMultiplayerUpgradeUI";
  if (id == 0x00000708) return "XamGetLiveHiveValueA";
  if (id == 0x00000709) return "XamGetLiveHiveValueW";
  if (id == 0x0000070A) return "XamGetLiveHiveValueDuringLogonAttemptA";
  if (id == 0x0000070B) return "XamSetUserPresetWindowsLiveCreds";
  if (id == 0x0000070C) return "XamQueryLiveHiveA";
  if (id == 0x0000070D) return "XamQueryLiveHiveW";
  if (id == 0x0000070E) return "XamGetLiveHiveValueDuringLogonAttemptExA";
  if (id == 0x0000070F) return "XamGetUserPresetWindowsLiveCreds";
  if (id == 0x00000710) return "XamGetUserNeedTFA";
  if (id == 0x00000711) return "XamSetUserNeedTFA";
  if (id == 0x00000712) return "XamGetUserInMemoryWindowsLiveCreds";
  if (id == 0x0000076C) return "XamDownloadMarketplaceStoresList";
  if (id == 0x0000076D) return "XamGetStoreFront";
  if (id == 0x0000076E) return "XamSetStagingMode";
  if (id == 0x0000076F) return "XamGetStagingMode";
  if (id == 0x00000770) return "XamAppGetSessionId";
  if (id == 0x00000771) return "XamAccountRecoveryRecoverAllProfileData";
  if (id == 0x00000772) return "XamAccountRecoveryGetProgress";
  if (id == 0x000007D0) return "XamDoesOmniNeedConfiguration";
  if (id == 0x000007D1) return "XamFirstRunExperienceShouldRun";
  if (id == 0x000007D2) return "GetProcessHeap";
  if (id == 0x000007D3) return "UnhandledExceptionFilter";
  if (id == 0x000007D4) return "SetUnhandledExceptionFilter";
  if (id == 0x000007D5) return "XamIsOptionalMediaUpdateInstalled";
  if (id == 0x000007D6) return "XamShowOptionalMediaUpdateRequiredUI";
  if (id == 0x000007D7) return "XamShowOptionalMediaUpdateRequiredUIEx";
  if (id == 0x000007D8) return "XamShowFirstRunWelcomeUI";
  if (id == 0x000007D9) return "XamTaskCreateQueueEx";
  if (id == 0x000007DA) return "XamSetDashBackstackData";
  if (id == 0x000007DB) return "XamLaunchAvatarEditor";
  if (id == 0x000007DC) return "XamGetDashBackstackData";
  if (id == 0x000007DD) return "XamGetDashBackstackNodesCount";
  if (id == 0x000007DE) return "XamSetLastActiveUserData";
  if (id == 0x000007DF) return "XamGetLastActiveUserData";
  if (id == 0x000007E0) return "XamSetActiveDashAppInfo";
  if (id == 0x000007E1) return "XamGetActiveDashAppInfo";
  if (id == 0x000007E2) return "XamLoaderRegisterLaunchRequestCallback";
  if (id == 0x000007E3) return "XamLoadExtraAVCodecs2";
  if (id == 0x000007E4) return "XamUnloadExtraAVCodecs2";
  if (id == 0x00000802) return "XamUserCreateAvatarAssetEnumerator";
  if (id == 0x00000803) return "XamInitializeGameTileCache";
  if (id == 0x00000804) return "XamDestroyGameTileCache";
  if (id == 0x00000805) return "XamReadGameTileImage";
  if (id == 0x00000806) return "XamShouldThrottleAccountInfoCall";
  if (id == 0x00000807) return "XuiClassDerivesFrom";
  if (id == 0x00000808) return "XuiFreeVisuals";
  if (id == 0x00000809) return "XuiGetBaseClass";
  if (id == 0x0000080A) return "XuiLoadVisualFromBinary";
  if (id == 0x0000080B) return "XuiResourceGetBuffer";
  if (id == 0x0000080C) return "XuiResourceGetTotalSize";
  if (id == 0x0000080D) return "XuiElementGetUserData";
  if (id == 0x0000080E) return "XuiElementSetUserData";
  if (id == 0x0000080F) return "XuiTabSceneGetCount";
  if (id == 0x00000810) return "XuiSliderGetStep";
  if (id == 0x00000811) return "XuiSliderSetStep";
  if (id == 0x00000812) return "XuiProgressBarGetRange";
  if (id == 0x00000813) return "XuiElementSetHittable";
  if (id == 0x00000814) return "XuiElementPlayNamedFrames";
  if (id == 0x00000815) return "XuiElementGetPivot";
  if (id == 0x00000816) return "XuiElementGetPrev";
  if (id == 0x00000817) return "XuiElementGetScale";
  if (id == 0x00000818) return "XuiElementSetPivot";
  if (id == 0x00000819) return "XuiElementSetRotation";
  if (id == 0x0000081A) return "XuiElementSetScale";
  if (id == 0x0000081B) return "XuiControlWantsUnfocusedInput";
  if (id == 0x0000081C) return "XuiResourceOpenNoLoc";
  if (id == 0x0000081D) return "XuiResourceReleasePackage";
  if (id == 0x0000081E) return "XuiResourceGetPackageEntryInfo";
  if (id == 0x0000081F) return "XuiResourceGetPackageEntryCount";
  if (id == 0x00000820) return "XuiResourceOpenPackage";
  if (id == 0x00000821) return "XamCodeCoverageFileOpen";
  if (id == 0x00000822) return "XamCodeCoverageFileClose";
  if (id == 0x00000823) return "XamCodeCoverageFileLseek";
  if (id == 0x00000824) return "XamCodeCoverageFileRead";
  if (id == 0x00000825) return "XamCodeCoverageFileWrite";
  if (id == 0x00000826) return "?XamCodeCoverageFcntl@@YAHH@Z";
  if (id == 0x00000827) return "XampHeapGetInfo";
  if (id == 0x00000828) return "XampHeapGetCount";
  if (id == 0x00000829) return "XamShowPamUI";
  if (id == 0x0000082A) return "XuiElementLayoutTree";
  if (id == 0x0000082B) return "XamRegisterScreenSaverCallback";
  if (id == 0x0000082C) return "XUIElementPropVal_SetInt";
  if (id == 0x0000082D) return "XUIElementPropVal_SetFloat";
  if (id == 0x0000082E) return "XuiObjectGetPropertyDef";
  if (id == 0x0000082F) return "XuiRenderGetDevice";
  if (id == 0x00000830) return "XuiRenderRestoreState";
  if (id == 0x00000831) return "XuiElementGetFullXForm";
  if (id == 0x00000832) return "XuiRenderGetViewTransform";
  if (id == 0x00000833) return "XuiRenderGetColorSpace";
  if (id == 0x00000834) return "XamPngEncode";
  if (id == 0x00000835) return "XamPngDecode";
  if (id == 0x00000836) return "XamPngEncodeEx";
  if (id == 0x00000837) return "XuiTextElementMeasureText";
  if (id == 0x00000838) return "XamLoaderShouldConfirmReboot";
  if (id == 0x00000839) return "XamLoaderRebootToDash";
  if (id == 0x0000083A) return "XamNuiHudGetEngagedTrackingID";
  if (id == 0x0000083B) return "XamLoaderLaunchTitleForReason";
  if (id == 0x0000083C) return "XamNuiHudSetEngagedTrackingID";
  if (id == 0x0000083D) return "XuiBrushGetTexture";
  if (id == 0x0000083E) return "XamSetupTexture";
  if (id == 0x0000083F) return "XuiElementGetDescendantById";
  if (id == 0x00000840) return "XamLoaderIsKinectUIPreferredForLogonTitle";
  if (id == 0x00000841) return "XamSetupCameraPreviewStuff";
  if (id == 0x00000842) return "XamReleaseCameraPreviewStuff";
  if (id == 0x00000843) return "XamRenderCameraPreviewStuff";
  if (id == 0x00000848) return "XamAccountRecoveryGetSetTitleSyncTime";
  if (id == 0x00000849) return "XamReadBiometricData";
  if (id == 0x0000084A) return "XamWriteBiometricData";
  if (id == 0x0000084B) return "XamD3DResourceDescriptorCreate";
  if (id == 0x0000084C) return "XamD3DResourceDescriptorAddRef";
  if (id == 0x0000084D) return "XamD3DResourceDescriptorRelease";
  if (id == 0x0000084E) return "XamD3DResourceAddRef";
  if (id == 0x0000084F) return "XamD3DResourceSet";
  if (id == 0x00000850) return "XamD3DResourceIsBusy";
  if (id == 0x00000851) return "XamD3DResourceRelease";
  if (id == 0x00000852) return "ControlPackGetCursorPosition";
  if (id == 0x00000853) return "ControlPackShouldShowCursor";
  if (id == 0x00000858) return "XamFlushAgraTemperatureReport";
  if (id == 0x00000859) return "XamNatalDeviceAudioCalibrate";
  if (id == 0x0000085A) return "XamNuiIdentityGetEnrollmentInfo";
  if (id == 0x0000085B) return "XamNuiIdentityUnenroll";
  if (id == 0x0000085C) return "XamNuiIdentityGetColorTexture";
  if (id == 0x0000085D) return "XamReportKinectSettingsChangedEvent";
  if (id == 0x0000085E) return "XamNuiEnableChatMic";
  if (id == 0x0000085F) return "XamNuiIsChatMicEnabled";
  if (id == 0x00000860) return "XamNuiGetDepthCalibration";
  if (id == 0x00000861) return "XamNuiStoreDepthCalibration";
  if (id == 0x00000862) return "XamUserNuiIsBiometricEnabled";
  if (id == 0x00000863) return "XamUserNuiEnableBiometric";
  if (id == 0x00000864) return "XamNuiCameraSetFlags";
  if (id == 0x00000865) return "XamNuiCameraRememberFloor";
  if (id == 0x00000866) return "XamUserNuiGetUserIndexForBind";
  if (id == 0x00000867) return "XamUserNuiGetUserIndexForSignin";
  if (id == 0x00000868) return "XamUserNuiBind";
  if (id == 0x00000869) return "XamUserNuiGetUserIndex";
  if (id == 0x0000086A) return "XamUserNuiGetEnrollmentIndex";
  if (id == 0x0000086B) return "XamUserNuiUnbind";
  if (id == 0x0000086C) return "XamNuiIdentityGetQualityFlagsMessage";
  if (id == 0x0000086D) return "XamNuiCameraTiltSetCallback";
  if (id == 0x0000086E) return "XamNuiHudIsEnabled";
  if (id == 0x0000086F) return "XamNuiCameraGetTiltControllerType";
  if (id == 0x00000870) return "XamNuiCameraTiltGetStatus";
  if (id == 0x00000871) return "XamNuiIdentityGetQualityFlags";
  if (id == 0x00000872) return "XamNuiIdentityEnrollForSignIn";
  if (id == 0x00000873) return "XamNuiIdentityGetSessionId";
  if (id == 0x00000874) return "XamNuiIdentityIdentifyWithBiometric";
  if (id == 0x00000875) return "ControlPackGetHandleManager";
  if (id == 0x00000876) return "XamEnableNuiAutomation";
  if (id == 0x00000877) return "XamNuiGetSystemGestureControl";
  if (id == 0x00000878) return "XamGetPasscodeKeyFromVirtualKey";
  if (id == 0x00000879) return "XamEnableNatalPlayback";
  if (id == 0x0000087A) return "XamIsNuiAutomationEnabled";
  if (id == 0x0000087B) return "XamIsNatalPlaybackEnabled";
  if (id == 0x0000087C) return "XamNuiHudInterpretFrame";
  if (id == 0x0000087D) return "XamNuiHudEnableInputFilter";
  if (id == 0x0000087E) return "ControlpackNuiCursorSetTrackingId";
  if (id == 0x0000087F) return "XamNuiHudGetInitializeFlags";
  if (id == 0x00000880) return "XamNuiCameraElevationSetAngle";
  if (id == 0x00000881) return "XamNuiCameraElevationGetAngle";
  if (id == 0x00000882) return "XamNuiCameraElevationAutoTilt";
  if (id == 0x00000883) return "XamNuiCameraElevationStopMovement";
  if (id == 0x00000884) return "XamNuiCameraElevationSetCallback";
  if (id == 0x00000885) return "XamNuiGetDeviceStatus";
  if (id == 0x00000886) return "XamNuiNatalCameraUpdateStarting";
  if (id == 0x00000887) return "XamNuiNatalCameraUpdateComplete";
  if (id == 0x00000888) return "XamNuiHudGetVersions";
  if (id == 0x00000889) return "XamGetHUDElementByPath";
  if (id == 0x0000088A) return "XamGetHUDElementByAutoId";
  if (id == 0x0000088B) return "XuiElementGetScreenPositionCenter";
  if (id == 0x0000088C) return "XamNuiCameraElevationReverseAutoTilt";
  if (id == 0x0000088D) return "ControlPackSimpleCursorGetRayFromScreenPosition";
  if (id == 0x0000088E) return "ControlPackSideNavControlGetNuiHandle";
  if (id == 0x0000088F) return "XamFindHUDElementByXuiId";
  if (id == 0x00000890) return "XamNuiIsDeviceReady";
  if (id == 0x00000891) return "XamNuiSetForceDeviceOff";
  if (id == 0x00000892) return "XamNuiPlayerEngagementUpdate";
  if (id == 0x00000893) return "XamNuiSkeletonGetBestSkeletonIndex";
  if (id == 0x00000894) return "XamNuiSkeletonScoreUpdate";
  if (id == 0x00000895) return "XamNuiCameraTiltReportStatus";
  if (id == 0x00000896) return "XamNuiCameraAdjustTilt";
  if (id == 0x00000897) return "XamNuiIdentityAbort";
  if (id == 0x00000898) return "D3DDevice_CreateVertexShader";
  if (id == 0x00000899) return "D3DDevice_CreatePixelShader";
  if (id == 0x0000089A) return "D3DDevice_CreateTexture";
  if (id == 0x0000089B) return "D3DDevice_CreateVertexBuffer";
  if (id == 0x0000089C) return "D3DDevice_CreateIndexBuffer";
  if (id == 0x0000089D) return "D3DDevice_CreateVertexDeclaration";
  if (id == 0x0000089E) return "D3DVertexBuffer_Unlock";
  if (id == 0x0000089F) return "D3DVertexBuffer_Lock";
  if (id == 0x000008A0) return "D3DIndexBuffer_Unlock";
  if (id == 0x000008A1) return "D3DIndexBuffer_Lock";
  if (id == 0x000008A2) return "D3DTexture_UnlockRect";
  if (id == 0x000008A3) return "D3DTexture_LockRect";
  if (id == 0x000008A4) return "D3DDevice_Clear";
  if (id == 0x000008A5) return "D3DDevice_SetViewport";
  if (id == 0x000008A6) return "D3DDevice_GetViewport";
  if (id == 0x000008A7) return "D3DVertexShader_Release";
  if (id == 0x000008A8) return "D3DPixelShader_Release";
  if (id == 0x000008A9) return "D3DVertexDeclaration_Release";
  if (id == 0x000008AA) return "D3DResource_Release";
  if (id == 0x000008AB) return "D3DDevice_Release";
  if (id == 0x000008AC) return "D3DDevice_SetVertexShader";
  if (id == 0x000008AD) return "D3DDevice_SetPixelShader";
  if (id == 0x000008AE) return "D3DDevice_SetTexture";
  if (id == 0x000008AF) return "D3DDevice_SetVertexDeclaration";
  if (id == 0x000008B0) return "D3DDevice_SetIndices";
  if (id == 0x000008B1) return "D3DDevice_SetStreamSource";
  if (id == 0x000008B2) return "D3DDevice_DrawVertices";
  if (id == 0x000008B3) return "D3DDevice_DrawVerticesUP";
  if (id == 0x000008B4) return "D3DDevice_DrawIndexedVertices";
  if (id == 0x000008B5) return "D3DDevice_DrawIndexedVerticesUP";
  if (id == 0x000008B6) return "D3DDevice_SetVertexShaderConstantF_ParameterCheck";
  if (id == 0x000008B7) return "D3DDevice_SetPixelShaderConstantF_ParameterCheck";
  if (id == 0x000008B8) return "D3DDevice_SetSamplerState_ParameterCheck";
  if (id == 0x000008B9) return "D3DDevice_SetRenderState_ParameterCheck";
  if (id == 0x000008BA) return "D3DDevice_GetRenderState_ParameterCheck";
  if (id == 0x000008BB) return "D3DDevice_SetVertexShaderConstantFN";
  if (id == 0x000008BC) return "D3DDevice_SetPixelShaderConstantFN";
  if (id == 0x000008BD) return "D3DDevice_GetRenderState_ZEnable";
  if (id == 0x000008BE) return "D3DDevice_GetRenderState_CullMode";
  if (id == 0x000008BF) return "D3DDevice_GetRenderState_AlphaBlendEnable";
  if (id == 0x000008C0) return "D3DDevice_GetRenderState_SrcBlendAlpha";
  if (id == 0x000008C1) return "D3DDevice_GetRenderState_DestBlendAlpha";
  if (id == 0x000008C2) return "D3DDevice_GetRenderState_BlendOp";
  if (id == 0x000008C3) return "D3DDevice_GetRenderState_ViewportEnable";
  if (id == 0x000008C4) return "D3DDevice_SetRenderState_ZEnable";
  if (id == 0x000008C5) return "D3DDevice_SetRenderState_CullMode";
  if (id == 0x000008C6) return "D3DDevice_SetRenderState_AlphaBlendEnable";
  if (id == 0x000008C7) return "D3DDevice_SetRenderState_SrcBlendAlpha";
  if (id == 0x000008C8) return "D3DDevice_SetRenderState_DestBlendAlpha";
  if (id == 0x000008C9) return "D3DDevice_SetRenderState_BlendOp";
  if (id == 0x000008CA) return "D3DDevice_SetRenderState_ViewportEnable";
  if (id == 0x000008CB) return "D3DDevice_SetSamplerState_MagFilter";
  if (id == 0x000008CC) return "D3DDevice_SetSamplerState_MinFilter";
  if (id == 0x000008CD) return "D3DDevice_SetSamplerState_AddressU";
  if (id == 0x000008CE) return "D3DDevice_SetSamplerState_AddressV";
  if (id == 0x000008CF) return "XGSetTextureHeader";
  if (id == 0x000008D0) return "XGGetTextureDesc";
  if (id == 0x000008D1) return "XGOffsetResourceAddress";
  if (id == 0x000008D2) return "D3DResource_AddRef";
  if (id == 0x000008D3) return "D3DVertexShader_AddRef";
  if (id == 0x000008D4) return "D3DPixelShader_AddRef";
  if (id == 0x000008D5) return "D3DVertexDeclaration_AddRef";
  if (id == 0x000008D6) return "XGSetTextureHeaderEx";
  if (id == 0x000008D7) return "D3DDevice_GetRenderTarget";
  if (id == 0x000008D8) return "D3DDevice_SetRenderTarget";
  if (id == 0x000008D9) return "D3DDevice_GetDepthStencilSurface";
  if (id == 0x000008DA) return "D3DDevice_SetDepthStencilSurface";
  if (id == 0x000008DB) return "D3DDevice_Resolve";
  if (id == 0x000008DC) return "D3DDevice_SetPixelShaderConstantB";
  if (id == 0x000008DD) return "XamNuiGetDeviceSerialNumber";
  if (id == 0x000008DE) return "XamNuiGetLoadedDepthCalibration";
  if (id == 0x000008DF) return "XamNuiGetTrueColorInfo";
  if (id == 0x000008E0) return "XamNuiGetCameraIntrinsics";
  if (id == 0x000008E1) return "XamNuiGetFanRate";
  if (id == 0x000008E2) return "XamNuiGetSupportString";
  if (id == 0x000008E3) return "XamKinectGetHardwareType";
  if (id == 0x000008FC) return "XamXtwManagerGetVariableCount";
  if (id == 0x000008FD) return "XamXtwManagerGetId";
  if (id == 0x000008FE) return "XamXtwManagerGetValue";
  if (id == 0x000008FF) return "XamXtwManagerSetValue";
  if (id == 0x00000900) return "XamXtwManagerIncrement";
  if (id == 0x00000901) return "XamXtwManagerDecrement";
  if (id == 0x00000902) return "XamXtwManagerResetValue";
  if (id == 0x00000903) return "XamXtwManagerResetAll";
  if (id == 0x00000904) return "XamXtwManagerGetDataFilePath";
  if (id == 0x00000905) return "XamXtwManagerDeleteDataFile";
  if (id == 0x00000906) return "XamXtwManagerSave";
  if (id == 0x00000907) return "XamXtwManagerLoad";
  if (id == 0x00000908) return "XamGetXTweakManager";
  if (id == 0x000009BB) return "XamMediaVerificationCreate";
  if (id == 0x000009BC) return "XamMediaVerificationClose";
  if (id == 0x000009BD) return "XamMediaVerificationVerify";
  if (id == 0x000009BE) return "XamMediaVerificationFailedBlocks";
  if (id == 0x000009BF) return "XamMediaVerificationInject";
  if (id == 0x000009C0) return "XamShowBadDiscErrorUI";
  if (id == 0x000009C4) return "XamBackgroundDownloadSetMode";
  if (id == 0x000009C5) return "XamBackgroundDownloadIsEnabled";
  if (id == 0x000009C6) return "XamBackgroundDownloadGetActiveItem";
  if (id == 0x000009C7) return "XamBackgroundDownloadGetItems";
  if (id == 0x000009C8) return "XamBackgroundDownloadClearItems";
  if (id == 0x000009C9) return "XamBackgroundDownloadItemAdd";
  if (id == 0x000009CA) return "XamBackgroundDownloadItemRemove";
  if (id == 0x000009CB) return "XamBackgroundDownloadItemMakeFirst";
  if (id == 0x000009CC) return "XamBackgroundDownloadSetForegroundPriority";
  if (id == 0x000009CD) return "XamBackgroundDownloadGetForegroundPriority";
  if (id == 0x000009CE) return "XamBackgroundDownloadItemToContentData";
  if (id == 0x000009CF) return "XamBackgroundDownloadItemGetStatus";
  if (id == 0x000009D0) return "XamBackgroundDownloadHistoryGetItem";
  if (id == 0x000009D1) return "XamBackgroundDownloadItemGetHistoryStatus";
  if (id == 0x000009D2) return "XamBackgroundDownloadItemSetHistoryStatus";
  if (id == 0x000009D3) return "XamBackgroundDownloadItemGetStatusAsync";
  if (id == 0x000009D4) return "XamBackgroundDownloadItemGetStatusEx";
  if (id == 0x000009D5) return "XamBackgroundDownloadItemGetHistoryStatusEx";
  if (id == 0x000009D6) return "XamBackgroundDownloadBindItems";
  if (id == 0x000009D7) return "XamBackgroundDownloadSetPollingActive";
  if (id == 0x000009D8) return "XamBackgroundDownloadGetPollingActive";
  if (id == 0x000009D9) return "XamBackgroundDownloadGetMode";
  if (id == 0x000009DA) return "XamBackgroundDownloadGetUnexpectedChangeCount";
  if (id == 0x000009DB) return "XamBackgroundDownloadIsItemForThisConsole";
  if (id == 0x000009DC) return "XamBackgroundDownloadSelectDevice";
  if (id == 0x000009DD) return "XamBackgroundDownloadItemModify";
  if (id == 0x000009DE) return "XamBackgroundDownloadCacheLegacyMappingInfo";
  if (id == 0x000009DF) return "XamBackgroundDownloadGetLegacyMappingInfo";
  if (id == 0x000009E0) return "XamBackgroundDownloadGetLegacyId";
  if (id == 0x000009E1) return "XamBackgroundDownloadDoFail";
  if (id == 0x000009E2) return "XamDownloadSingleItem";
  if (id == 0x000009E3) return "XamDownloadInSingleItemMode";
  if (id == 0x00000A28) return "XamSwapDisc";
  if (id == 0x00000A29) return "XamSwapDiscPatchAddress";
  if (id == 0x00000A2A) return "XamSwapCancel";
  if (id == 0x00000A2B) return "XamContentSetAttributes";
  if (id == 0x00000A32) return "XamRamDriveCreate";
  if (id == 0x00000A33) return "XamRamDriveDestroy";
  if (id == 0x00000A5A) return "XamPlayTimerGetData";
  if (id == 0x00000A5B) return "XamPlayTimerSetData";
  if (id == 0x00000A5C) return "XamPlayTimerResume";
  if (id == 0x00000A5D) return "XamPlayTimerSuspend";
  if (id == 0x00000A5E) return "XamPlayTimerIsRunning";
  if (id == 0x00000A5F) return "XamPlayTimerIsEnabled";
  if (id == 0x00000A60) return "XamPlayTimerGetNextResetDate";
  if (id == 0x00000A61) return "XamPlayTimerFormatDurationString";
  if (id == 0x00000A62) return "XamPlayTimerGetTimeRemaining";
  if (id == 0x00000A63) return "XamPlayTimerUpdateTimeRemaining";
  if (id == 0x00000A64) return "XamPlayTimerForceNotification";
  if (id == 0x00000A65) return "XamPlayTimerRefreshResetDate";
  if (id == 0x00000A66) return "XuiResourceOpenAndVerifyNoLoc";
  if (id == 0x00000A6E) return "UpnpAVServerSearchInitialize";
  if (id == 0x00000A6F) return "UpnpAVServerSearchDestroy";
  if (id == 0x00000A70) return "UpnpAVServerSearchStart";
  if (id == 0x00000A71) return "Destroy";
  if (id == 0x00000A72) return "UpnpAVServerSearchDoWork";
  if (id == 0x00000A73) return "UpnpAVServerSearchGetNextServer";
  if (id == 0x00000A8C) return "XCustomBroadcastGamercardEvent";
  if (id == 0x00000A8D) return "XamCustomGetCurrentActions";
  if (id == 0x00000AA0) return "XamInstrumentationLogEvent";
  if (id == 0x00000AA1) return "XamRegisterSMCNotification";
  if (id == 0x00000AA8) return "XamIsScreenSaverActive";
  if (id == 0x00000AAA) return "XamInstrumentationLogEventEx";
  if (id == 0x00000AAB) return "XamInstrumentationGetSourceConfig";
  if (id == 0x00000AAC) return "XamInstrumentationDebugConfig";
  if (id == 0x00000ADC) return "CurlCreateCacheEntry";
  if (id == 0x00000ADD) return "CurlOpenCacheEntry";
  if (id == 0x00000ADE) return "CurlSetCacheEntryExpireTime";
  if (id == 0x00000ADF) return "CurlReadCacheEntryHeaders";
  if (id == 0x00000AE0) return "CurlReadCacheEntryContent";
  if (id == 0x00000AE1) return "CurlWriteCacheEntryContent";
  if (id == 0x00000AE2) return "CurlCloseCacheEntry";
  if (id == 0x00000AE3) return "CurlEnumerateCacheEntry";
  if (id == 0x00000AE5) return "CurlWipeBackingFiles";
  if (id == 0x00000AE7) return "CurlOpenTitleBackingFile";
  if (id == 0x00000AEA) return "XamUserIsPartialProfile";
  if (id == 0x00000AEB) return "XamLocateTitle";
  if (id == 0x00000AEC) return "XamProfileGetLocalTitleCount";
  if (id == 0x00000AED) return "XamContentRemoveCacheDevice";
  if (id == 0x00000AEE) return "XamContentAddCacheDevice";
  if (id == 0x00000AF0) return "XamSetSecurityViolationDetected";
  if (id == 0x00000AF1) return "XamIsSecurityViolationDetected";
  if (id == 0x00000AF2) return "XamIsAnySecurityViolationDetected";
  if (id == 0x00000AF3) return "XamGetSecurityViolationsDetected";
  if (id == 0x00000AF4) return "XamActivateCounterMeasure";
  if (id == 0x00000AF5) return "XamDeactivateCounterMeasure";
  if (id == 0x00000AF6) return "XamIsCounterMeasureActivated";
  if (id == 0x00000AF7) return "XamGetActiveCounterMeasures";
  if (id == 0x00000AF8) return "XamPmdIdentify";
  if (id == 0x00000AF9) return "XamPmdSendCommand";
  if (id == 0x00000AFA) return "XamPmdReadReport";
  if (id == 0x00000AFC) return "XamPartyCreate";
  if (id == 0x00000AFD) return "XamPartyLeave";
  if (id == 0x00000AFE) return "XamPartySendInviteDeprecated";
  if (id == 0x00000AFF) return "XamPartyGetUserList";
  if (id == 0x00000B00) return "XamPartySendGameInvites";
  if (id == 0x00000B01) return "XamPartyJoin";
  if (id == 0x00000B02) return "XamPartyKickUser";
  if (id == 0x00000B03) return "XamPartyAddLocalUsers";
  if (id == 0x00000B04) return "XamConvertEmoticons";
  if (id == 0x00000B05) return "XamGetLocaleTimeFormat";
  if (id == 0x00000B06) return "XamPartyRemoveLocalUsers";
  if (id == 0x00000B07) return "XamPartyGetUserListInternal";
  if (id == 0x00000B08) return "XamPartySetJoinable";
  if (id == 0x00000B09) return "XamPartyGetJoinable";
  if (id == 0x00000B0A) return "XamPartyGetInfo";
  if (id == 0x00000B0B) return "XamPartySetCustomData";
  if (id == 0x00000B0C) return "XamPartySetConnectivityGraph";
  if (id == 0x00000B0D) return "XamPartyGetRoutingTable";
  if (id == 0x00000B0E) return "XamPartyAutomationInprocCall";
  if (id == 0x00000B0F) return "XamPartyGetState";
  if (id == 0x00000B10) return "XamPartyGetBandwidth";
  if (id == 0x00000B11) return "XamPartyGetNetworkCounters";
  if (id == 0x00000B12) return "XamShowQuickLaunchUI";
  if (id == 0x00000B13) return "XamPartyIsCoordinator";
  if (id == 0x00000B14) return "XamPartyGetFormation";
  if (id == 0x00000B15) return "XamPartySendInvite";
  if (id == 0x00000B16) return "XamPartySetTestDelay";
  if (id == 0x00000B17) return "XamPartyOverrideNatType";
  if (id == 0x00000B18) return "XamPartyGetAccessLevel";
  if (id == 0x00000B19) return "XamPartySetTestFlags";
  if (id == 0x00000B1A) return "XamIsSystemExperienceTitleId";
  if (id == 0x00000B1B) return "XamPartyJoinEx";
  if (id == 0x00000B1C) return "XamPartyGetInfoEx";
  if (id == 0x00000B20) return "XamIsCurrentTitleDatacenterClient";
  if (id == 0x00000B22) return "XamTaskSetCancelSubTasks";
  if (id == 0x00000B23) return "XamTaskGetCompletionStatus";
  if (id == 0x00000B24) return "XamTaskCancelWaitAndCloseWaitTask";
  if (id == 0x00000B27) return "XamDataCenterLog";
  if (id == 0x00000B28) return "XamDataCenterGetDhcpOptionResponseHostnameAndPort";
  if (id == 0x00000B29) return "XamDataCenterLogEvent";
  if (id == 0x00000B2A) return "XamDataCenterShowForceSignInMessage";
  if (id == 0x00000B2C) return "XamWebInstrumentationCreateReport";
  if (id == 0x00000B2D) return "XamWebInstrumentationSetUserVar";
  if (id == 0x00000B2E) return "XamWebInstrumentationSetUserVarNoEscape";
  if (id == 0x00000B2F) return "XamWebInstrumentationGetURL";
  if (id == 0x00000B30) return "XamWebInstrumentationSendReport";
  if (id == 0x00000B31) return "XamWebInstrumentationDestroyReport";
  if (id == 0x00000B32) return "XamWebInstrumentationCreateSampledReport";
  if (id == 0x00000B33) return "XampSetSamplingRandomValue";
  if (id == 0x00000B34) return "XampWebInstrumentationSetProfileCounts";
  if (id == 0x00000B35) return "XamWebInstrumentationGetURLEx";
  if (id == 0x00000B36) return "XampSetOmnitureCallbackFunction";
  if (id == 0x00000B37) return "XamShowQuickChatUIp";
  if (id == 0x00000B38) return "XamShowSocialPostUI";
  if (id == 0x00000B39) return "XamShowBeaconsUI";
  if (id == 0x00000B3A) return "XamShowMarketplacePurchaseOrderUI";
  if (id == 0x00000B3B) return "XamShowMarketplaceGetOrderReceipts";
  if (id == 0x00000B3C) return "XamShowGenericOnlineAppUI";
  if (id == 0x00000B3D) return "XamUserAllowedToPostToSocialNetwork";
  if (id == 0x00000B3E) return "XamShowMarketplacePurchaseOrderUIEx";
  if (id == 0x00000B3F) return "DebugXamShowMessageBoxUI_Wait";
  if (id == 0x00000B43) return "XamSetCountry";
  if (id == 0x00000B44) return "XamIsCurrentTitleDatacenterDash";
  if (id == 0x00000B45) return "XamLoaderRebootToServerDash";
  if (id == 0x00000B46) return "XamIsDataCenterMode";
  if (id == 0x00000B48) return "XamUserGetXUIDForTFA";
  if (id == 0x00000B4A) return "XamVerifyXSignerSignature";
  
  return nullptr;
}

const char* xapiNameGen(int id)
{
  if (id == 0x00000001) return "XapiProcessHeap";
  if (id == 0x00000002) return "_locktable";
  if (id == 0x00000003) return "__tlsindexXapi";
  if (id == 0x00000004) return "XapiTermHeapNoop";
  if (id == 0x00000005) return "XapiDebugHeap";

  return nullptr;
}

const char* xbdmNameGen_1640(int id)
{
  if (id == 0x00000001) return "DmAllocatePool";
  if (id == 0x00000002) return "DmAllocatePoolWithTag";
  if (id == 0x00000003) return "DmCloseCounters";
  if (id == 0x00000004) return "DmCloseModuleSections";
  if (id == 0x00000005) return "DmCloseModuleSections";
  if (id == 0x00000006) return "DmCloseNotificationSession";
  if (id == 0x00000007) return "DmClosePerformanceCounter";
  if (id == 0x00000008) return "DmContinueThread";
  if (id == 0x00000009) return "DmFreePool";
  if (id == 0x0000000A) return "DmGetMemory";
  if (id == 0x0000000B) return "DmGetModuleLongName";
  if (id == 0x0000000C) return "DmGetProcAddress";
  if (id == 0x0000000D) return "DmGetThreadContext";
  if (id == 0x0000000F) return "DmGetThreadList";
  if (id == 0x00000010) return "DmGetXbeInfo";
  if (id == 0x00000011) return "DmGetXboxName";
  if (id == 0x00000013) return "DmGo";
  if (id == 0x00000014) return "DmHaltThread";
  if (id == 0x00000015) return "DmIsDebuggerPresent";
  if (id == 0x00000016) return "DmIsThreadStopped";
  if (id == 0x00000017) return "DmLoadExtension";
  if (id == 0x00000018) return "DmNotify";
  if (id == 0x00000019) return "DmOpenNotificationSession";
  if (id == 0x0000001A) return "DmOpenPerformanceCounter";
  if (id == 0x0000001B) return "DmQueryPerformanceCounterHandle";
  if (id == 0x0000001C) return "DmReboot";
  if (id == 0x0000001E) return "DmRegisterCommandProcessor";
  if (id == 0x00000020) return "DmRegisterNotificationProcessor";
  if (id == 0x00000021) return "DmRegisterPerformanceCounter";
  if (id == 0x00000022) return "DmRemoveBreakpoint";
  if (id == 0x00000023) return "DmResumeThread";
  if (id == 0x00000024) return "DmSendNotificationString";
  if (id == 0x00000025) return "DmSetBreakpoint";
  if (id == 0x00000026) return "DmSetDataBreakpoint";
  if (id == 0x00000027) return "DmSetInitialBreakpoint";
  if (id == 0x00000028) return "DmSetMemory";
  if (id == 0x00000029) return "DmSetThreadContext";
  if (id == 0x0000002A) return "DmSetTitle";
  if (id == 0x0000002B) return "DmSetXboxName";
  if (id == 0x0000002D) return "DmStop";
  if (id == 0x0000002E) return "DmStopOn";
  if (id == 0x00000030) return "DmSuspendThread";
  if (id == 0x00000031) return "DmThreadUserData";
  if (id == 0x00000032) return "DmUnloadExtension";
  if (id == 0x00000033) return "DmWalkLoadedModules";
  if (id == 0x00000034) return "DmWalkModuleSections";
  if (id == 0x00000035) return "DmWalkPerformanceCounters";
  if (id == 0x00000037) return "DmCloseCounters";
  if (id == 0x00000038) return "DmIsBreakpoint";
  if (id == 0x00000039) return "DmCloseCounters";
  if (id == 0x0000003A) return "DmSetUserAccess";
  if (id == 0x0000003B) return "DmGetUserAccess";
  if (id == 0x0000003C) return "DmWalkUserList";
  if (id == 0x0000003D) return "DmAddUser";
  if (id == 0x0000003E) return "DmEnableSecurity";
  if (id == 0x0000003F) return "DmIsSecurityEnabled";
  if (id == 0x00000040) return "DmRemoveUser";
  if (id == 0x00000041) return "__CAP_Start_Profiling";
  if (id == 0x00000042) return "__CAP_End_Profiling";
  if (id == 0x00000046) return "__CAP_Enter_Function";
  if (id == 0x00000047) return "__CAP_Exit_Function";
  if (id == 0x00000048) return "DmRegisterCommandProcessorEx";
  if (id == 0x00000049) return "DmStartProfiling";
  if (id == 0x0000004A) return "DmStopProfiling";
  if (id == 0x0000004B) return "DmQueryMemoryStatistics";
  if (id == 0x0000004C) return "DmEnableStackTrace";
  if (id == 0x0000004D) return "DmQueryAllocationTypeName";
  if (id == 0x0000004E) return "DmRegisterAllocationType";
  if (id == 0x0000004F) return "DmInsertAllocationEntry";
  if (id == 0x00000050) return "DmRemoveAllocationEntry";
  if (id == 0x00000051) return "DmSetTitleEx";
  if (id == 0x00000052) return "DmCaptureStackBackTrace";
  if (id == 0x00000053) return "DmCrashDump";
  if (id == 0x00000054) return "DmIsFastCAPEnabled";
  if (id == 0x00000055) return "DmGetFileAccessCount";
  if (id == 0x00000058) return "HrGetUtilityDriveInfo";
  if (id == 0x00000059) return "DmGetThreadInfoEx";
  if (id == 0x0000005A) return "DmSetProfilingOptions";
  if (id == 0x0000005B) return "DmQuerySystemSettings";
  if (id == 0x0000005C) return "DmSaveSystemSettings";
  if (id == 0x0000006A) return "DmpGetPgoModuleHandleForBaseAddress";
  if (id == 0x0000006B) return "DmpOnPgoModuleLoad";
  if (id == 0x0000006C) return "DmPgoStartDataCollection";
  if (id == 0x0000006D) return "DmPgoStopDataCollection";
  if (id == 0x0000006E) return "DmPgoSaveSnapshot";
  if (id == 0x0000006F) return "IrtClientAbort";
  if (id == 0x00000070) return "IrtPogoInit";
  if (id == 0x00000071) return "IrtSetStaticInfo";
  if (id == 0x00000072) return "IrtAutoSweepW";
  if (id == 0x00000073) return "IrtAutoSweepA";
  if (id == 0x00000075) return "DmGetDumpMode";
  if (id == 0x00000076) return "DmSetDumpMode";
  if (id == 0x00000077) return "DmGetDumpSettings";
  if (id == 0x00000078) return "DmSetDumpSettings";
  if (id == 0x00000079) return "DmGetEventDeferFlags";
  if (id == 0x0000007A) return "DmSetEventDeferFlags";
  if (id == 0x0000007B) return "DmWalkCommittedMemory";
  if (id == 0x0000007C) return "DmCloseCounters";
  if (id == 0x0000007D) return "DmRebootEx";
  if (id == 0x0000007E) return "?PEPLELookup@@YIPAUEPLE@@PAUPGCHDR@@PAUEPLH@@K@Z";
  if (id == 0x0000007F) return "?PVPLELookup@@YIPA_KPAUPGCHDR@@PAUVPLH@@_K@Z";
  if (id == 0x00000080) return "?PVPLETemplatedLookup@@YIPA_KPAUPGCHDR@@PAUVPLH@@_KPAUtagPOGOVALUETEMPLATE@@@Z";
  if (id == 0x00000081) return "?PVPLEFilteredLookup@@YIPA_KPAUPGCHDR@@PAUVPLH@@_K@Z";

  return nullptr;
}

const char* xbdmNameGen_1838(int id)
{
  if (id == 0x00000001) return "DmAllocatePool";
  if (id == 0x00000002) return "DmAllocatePoolWithTag";
  if (id == 0x00000003) return "DmCloseCounters";
  if (id == 0x00000004) return "DmCloseModuleSections";
  if (id == 0x00000005) return "DmCloseModuleSections";
  if (id == 0x00000006) return "DmCloseNotificationSession";
  if (id == 0x00000007) return "DmClosePerformanceCounter";
  if (id == 0x00000008) return "DmContinueThread";
  if (id == 0x00000009) return "DmFreePool";
  if (id == 0x0000000A) return "DmGetMemory";
  if (id == 0x0000000B) return "DmGetModuleLongName";
  if (id == 0x0000000C) return "DmGetProcAddress";
  if (id == 0x0000000D) return "DmGetThreadContext";
  if (id == 0x0000000F) return "DmGetThreadList";
  if (id == 0x00000010) return "DmGetXbeInfo";
  if (id == 0x00000011) return "DmGetXboxName";
  if (id == 0x00000013) return "DmGo";
  if (id == 0x00000014) return "DmHaltThread";
  if (id == 0x00000015) return "DmIsDebuggerPresent";
  if (id == 0x00000016) return "DmIsThreadStopped";
  if (id == 0x00000017) return "DmLoadExtension";
  if (id == 0x00000018) return "DmNotify";
  if (id == 0x00000019) return "DmOpenNotificationSession";
  if (id == 0x0000001A) return "DmOpenPerformanceCounter";
  if (id == 0x0000001B) return "DmQueryPerformanceCounterHandle";
  if (id == 0x0000001C) return "DmReboot";
  if (id == 0x0000001E) return "DmRegisterCommandProcessor";
  if (id == 0x00000020) return "DmRegisterNotificationProcessor";
  if (id == 0x00000021) return "DmRegisterPerformanceCounter";
  if (id == 0x00000022) return "DmRemoveBreakpoint";
  if (id == 0x00000023) return "DmResumeThread";
  if (id == 0x00000024) return "DmSendNotificationString";
  if (id == 0x00000025) return "DmSetBreakpoint";
  if (id == 0x00000026) return "DmSetDataBreakpoint";
  if (id == 0x00000027) return "DmSetInitialBreakpoint";
  if (id == 0x00000028) return "DmSetMemory";
  if (id == 0x00000029) return "DmSetThreadContext";
  if (id == 0x0000002A) return "DmSetTitle";
  if (id == 0x0000002B) return "DmSetXboxName";
  if (id == 0x0000002D) return "DmStop";
  if (id == 0x0000002E) return "DmStopOn";
  if (id == 0x00000030) return "DmSuspendThread";
  if (id == 0x00000031) return "DmThreadUserData";
  if (id == 0x00000032) return "DmUnloadExtension";
  if (id == 0x00000033) return "DmWalkLoadedModules";
  if (id == 0x00000034) return "DmWalkModuleSections";
  if (id == 0x00000035) return "DmWalkPerformanceCounters";
  if (id == 0x00000037) return "DmCloseCounters";
  if (id == 0x00000038) return "DmIsBreakpoint";
  if (id == 0x00000039) return "DmCloseCounters";
  if (id == 0x0000003A) return "DmSetUserAccess";
  if (id == 0x0000003B) return "DmGetUserAccess";
  if (id == 0x0000003C) return "DmWalkUserList";
  if (id == 0x0000003D) return "DmAddUser";
  if (id == 0x0000003E) return "DmEnableSecurity";
  if (id == 0x0000003F) return "DmIsSecurityEnabled";
  if (id == 0x00000040) return "DmRemoveUser";
  if (id == 0x00000041) return "__CAP_Start_Profiling";
  if (id == 0x00000042) return "__CAP_End_Profiling";
  if (id == 0x00000046) return "__CAP_Enter_Function";
  if (id == 0x00000047) return "__CAP_Exit_Function";
  if (id == 0x00000048) return "DmRegisterCommandProcessorEx";
  if (id == 0x00000049) return "DmStartProfiling";
  if (id == 0x0000004A) return "DmStopProfiling";
  if (id == 0x0000004B) return "DmQueryMemoryStatistics";
  if (id == 0x0000004C) return "DmEnableStackTrace";
  if (id == 0x0000004D) return "DmQueryAllocationTypeName";
  if (id == 0x0000004E) return "DmRegisterAllocationType";
  if (id == 0x0000004F) return "DmInsertAllocationEntry";
  if (id == 0x00000050) return "DmRemoveAllocationEntry";
  if (id == 0x00000051) return "DmSetTitleEx";
  if (id == 0x00000052) return "DmCaptureStackBackTrace";
  if (id == 0x00000053) return "DmCrashDump";
  if (id == 0x00000054) return "DmIsFastCAPEnabled";
  if (id == 0x00000055) return "DmGetFileAccessCount";
  if (id == 0x00000058) return "HrGetUtilityDriveInfo";
  if (id == 0x00000059) return "DmGetThreadInfoEx";
  if (id == 0x0000005A) return "DmSetProfilingOptions";
  if (id == 0x0000005B) return "DmQuerySystemSettings";
  if (id == 0x0000005C) return "DmSaveSystemSettings";
  if (id == 0x0000006A) return "DmpGetPgoModuleHandleForBaseAddress";
  if (id == 0x0000006B) return "DmpOnPgoModuleLoad";
  if (id == 0x0000006C) return "DmPgoStartDataCollection";
  if (id == 0x0000006D) return "DmPgoStopDataCollection";
  if (id == 0x0000006E) return "DmPgoSaveSnapshot";
  if (id == 0x0000006F) return "IrtClientAbort";
  if (id == 0x00000070) return "IrtPogoInit";
  if (id == 0x00000071) return "IrtSetStaticInfo";
  if (id == 0x00000072) return "IrtAutoSweepW";
  if (id == 0x00000073) return "IrtAutoSweepA";
  if (id == 0x00000075) return "DmGetDumpMode";
  if (id == 0x00000076) return "DmSetDumpMode";
  if (id == 0x00000077) return "DmGetDumpSettings";
  if (id == 0x00000078) return "DmSetDumpSettings";
  if (id == 0x00000079) return "DmGetEventDeferFlags";
  if (id == 0x0000007A) return "DmSetEventDeferFlags";
  if (id == 0x0000007B) return "DmWalkCommittedMemory";
  if (id == 0x0000007C) return "DmCloseCounters";
  if (id == 0x0000007D) return "DmRebootEx";
  if (id == 0x0000007E) return "?PEPLELookup@@YIPAUEPLE@@PAUPGCHDR@@PAUEPLH@@K@Z";
  if (id == 0x0000007F) return "?PVPLELookup@@YIPA_KPAUPGCHDR@@PAUVPLH@@_K@Z";
  if (id == 0x00000080) return "?PVPLETemplatedLookup@@YIPA_KPAUPGCHDR@@PAUVPLH@@_KPAUtagPOGOVALUETEMPLATE@@@Z";
  if (id == 0x00000081) return "?PVPLEFilteredLookup@@YIPA_KPAUPGCHDR@@PAUVPLH@@_K@Z";
  if (id == 0x00000082) return "DmMountFdfxVolume";

  return nullptr;
}

const char* xbdmNameGen(int id, int version)
{
  if (version > 0) {
    if (version <= 1640) return xbdmNameGen_1640(id);
    // 1746 & 1838 seem to be the same
    if (version <= 1838) return xbdmNameGen_1838(id);
  }

  if (id == 0x00000001) return "DmAllocatePool";
  if (id == 0x00000002) return "DmAllocatePoolWithTag";
  if (id == 0x00000003) return "DmCloseCounters";
  if (id == 0x00000004) return "DmCloseLoadedModules";
  if (id == 0x00000005) return "DmCloseModuleSections";
  if (id == 0x00000006) return "DmCloseNotificationSession";
  if (id == 0x00000007) return "DmClosePerformanceCounter";
  if (id == 0x00000008) return "DmContinueThread";
  if (id == 0x00000009) return "DmFreePool";
  if (id == 0x0000000A) return "DmGetMemory";
  if (id == 0x0000000B) return "DmGetModuleLongName";
  if (id == 0x0000000C) return "DmGetProcAddress";
  if (id == 0x0000000D) return "DmGetThreadContext";
  if (id == 0x0000000F) return "DmGetThreadList";
  if (id == 0x00000010) return "DmGetXbeInfo";
  if (id == 0x00000011) return "DmGetXboxName";
  if (id == 0x00000013) return "DmGo";
  if (id == 0x00000014) return "DmHaltThread";
  if (id == 0x00000015) return "DmIsDebuggerPresent";
  if (id == 0x00000016) return "DmIsThreadStopped";
  if (id == 0x00000017) return "DmLoadExtension";
  if (id == 0x00000018) return "DmNotify";
  if (id == 0x00000019) return "DmOpenNotificationSession";
  if (id == 0x0000001A) return "DmOpenPerformanceCounter";
  if (id == 0x0000001B) return "DmQueryPerformanceCounterHandle";
  if (id == 0x0000001C) return "DmReboot";
  if (id == 0x0000001E) return "DmRegisterCommandProcessor";
  if (id == 0x00000020) return "DmRegisterNotificationProcessor";
  if (id == 0x00000021) return "DmRegisterPerformanceCounter";
  if (id == 0x00000022) return "DmRemoveBreakpoint";
  if (id == 0x00000023) return "DmResumeThread";
  if (id == 0x00000024) return "DmSendNotificationString";
  if (id == 0x00000025) return "DmSetBreakpoint";
  if (id == 0x00000026) return "DmSetDataBreakpoint";
  if (id == 0x00000027) return "DmSetInitialBreakpoint";
  if (id == 0x00000028) return "DmSetMemory";
  if (id == 0x00000029) return "DmSetThreadContext";
  if (id == 0x0000002A) return "DmSetTitle";
  if (id == 0x0000002B) return "DmSetXboxName";
  if (id == 0x0000002D) return "DmStop";
  if (id == 0x0000002E) return "DmStopOn";
  if (id == 0x00000030) return "DmSuspendThread";
  if (id == 0x00000031) return "DmThreadUserData";
  if (id == 0x00000032) return "DmUnloadExtension";
  if (id == 0x00000033) return "DmWalkLoadedModules";
  if (id == 0x00000034) return "DmWalkModuleSections";
  if (id == 0x00000035) return "DmWalkPerformanceCounters";
  if (id == 0x00000037) return "DmCloseCounters_0";
  if (id == 0x00000038) return "DmIsBreakpoint";
  if (id == 0x00000039) return "DmCloseCounters_1";
  if (id == 0x0000003A) return "DmSetUserAccess";
  if (id == 0x0000003B) return "DmGetUserAccess";
  if (id == 0x0000003C) return "DmWalkUserList";
  if (id == 0x0000003D) return "DmAddUser";
  if (id == 0x0000003E) return "DmEnableSecurity";
  if (id == 0x0000003F) return "DmIsSecurityEnabled";
  if (id == 0x00000040) return "DmRemoveUser";
  if (id == 0x00000041) return "__CAP_Start_Profiling";
  if (id == 0x00000042) return "__CAP_End_Profiling";
  if (id == 0x00000046) return "__CAP_Enter_Function";
  if (id == 0x00000047) return "__CAP_Exit_Function";
  if (id == 0x00000048) return "DmRegisterCommandProcessorEx";
  if (id == 0x00000049) return "DmStartProfiling";
  if (id == 0x0000004A) return "DmStopProfiling";
  if (id == 0x0000004B) return "DmQueryMemoryStatistics";
  if (id == 0x0000004C) return "DmEnableStackTrace";
  if (id == 0x0000004D) return "DmQueryAllocationTypeName";
  if (id == 0x0000004E) return "DmRegisterAllocationType";
  if (id == 0x0000004F) return "DmInsertAllocationEntry";
  if (id == 0x00000050) return "DmRemoveAllocationEntry";
  if (id == 0x00000051) return "DmSetTitleEx";
  if (id == 0x00000052) return "DmCaptureStackBackTrace";
  if (id == 0x00000053) return "DmCrashDump";
  if (id == 0x00000054) return "DmIsFastCAPEnabled";
  if (id == 0x00000055) return "DmGetFileAccessCount";
  if (id == 0x00000058) return "DmGetUtilityDriveInfo";
  if (id == 0x00000059) return "DmGetThreadInfoEx";
  if (id == 0x0000005A) return "DmSetProfilingOptions";
  if (id == 0x0000005B) return "DmQuerySystemSettings";
  if (id == 0x0000005C) return "DmSaveSystemSettings";
  if (id == 0x0000006A) return "DmpGetPgoModuleHandleForBaseAddress";
  if (id == 0x0000006B) return "DmpOnPgoModuleLoad";
  if (id == 0x0000006C) return "DmPgoStartDataCollection";
  if (id == 0x0000006D) return "DmPgoStopDataCollection";
  if (id == 0x0000006E) return "DmPgoSaveSnapshot";
  if (id == 0x0000006F) return "IrtClientAbort";
  if (id == 0x00000070) return "IrtPogoInit";
  if (id == 0x00000071) return "IrtSetStaticInfo";
  if (id == 0x00000072) return "IrtAutoSweepW";
  if (id == 0x00000073) return "IrtAutoSweepA";
  if (id == 0x00000075) return "DmGetDumpMode";
  if (id == 0x00000076) return "DmSetDumpMode";
  if (id == 0x00000077) return "DmGetDumpSettings";
  if (id == 0x00000078) return "DmSetDumpSettings";
  if (id == 0x00000079) return "DmGetEventDeferFlags";
  if (id == 0x0000007A) return "DmSetEventDeferFlags";
  if (id == 0x0000007B) return "DmWalkCommittedMemory";
  if (id == 0x0000007C) return "DmCloseCounters_2";
  if (id == 0x0000007D) return "DmRebootEx";
  if (id == 0x00000082) return "DmMountFdfxVolume";
  if (id == 0x00000083) return "DmCapGetFileHeader";
  if (id == 0x00000084) return "DmCapFreeFileHeader";
  if (id == 0x00000085) return "DmTraceStartRecording";
  if (id == 0x00000086) return "DmTraceStartRecordingFunction";
  if (id == 0x00000087) return "DmTraceSetBufferSize";
  if (id == 0x00000088) return "DmTraceStopRecording";
  if (id == 0x00000089) return "DmTraceSaveBuffer";
  if (id == 0x0000008C) return "DmGetConsoleType";
  if (id == 0x0000008D) return "DmMapDevkitDrive";
  if (id == 0x0000008E) return "DmWalkLoadedModulesEx";
  if (id == 0x0000008F) return "DmGetXexHeaderField";
  if (id == 0x00000090) return "DmGetMouseChanges";
  if (id == 0x00000091) return "DmFindPdbSignature";
  if (id == 0x00000092) return "DmGetProfilingStatus";
  if (id == 0x00000093) return "DmOpticalDiscLogStart";
  if (id == 0x00000094) return "DmOpticalDiscLogStop";
  if (id == 0x00000095) return "DmStartSamplingProfiler";
  if (id == 0x00000096) return "DmStopSamplingProfiler";
  if (id == 0x00000097) return "DmGetSamplingProfilerInfo";
  if (id == 0x00000098) return "DmStartFileEventCapture";
  if (id == 0x00000099) return "DmStopFileEventCapture";
  if (id == 0x0000009A) return "DmSetFileEventMarker";
  if (id == 0x0000009B) return "DmMarkPseudoCreateBegin";
  if (id == 0x0000009C) return "DmMarkPseudoCreateEnd";
  if (id == 0x0000009D) return "DmMarkPseudoEventBegin";
  if (id == 0x0000009E) return "DmMarkPseudoEventEnd";
  if (id == 0x0000009F) return "DmMarkFileEventWorkerThreadBegin";
  if (id == 0x000000A0) return "DmMarkFileEventWorkerThreadEnd";
  if (id == 0x000000A1) return "DmGetSystemInfo";
  if (id == 0x000000A2) return "DmAbortProfiling";
  if (id == 0x000000A3) return "DmNetCaptureStart";
  if (id == 0x000000A4) return "DmNetCaptureStop";
  if (id == 0x000000A5) return "DmQueryTitleMemoryStatistics";
  if (id == 0x000000A6) return "DmAutomationGetInputProcess";
  if (id == 0x000000A7) return "DmAutomationBindController";
  if (id == 0x000000A8) return "DmAutomationUnbindController";
  if (id == 0x000000A9) return "DmAutomationConnectController";
  if (id == 0x000000AA) return "DmAutomationDisconnectController";
  if (id == 0x000000AB) return "DmAutomationSetGamepadState";
  if (id == 0x000000AC) return "DmAutomationQueueGamepadState";
  if (id == 0x000000AD) return "DmAutomationClearGamepadQueue";
  if (id == 0x000000AE) return "DmAutomationQueryGamepadQueue";
  if (id == 0x000000AF) return "DmAutomationGetUserDefaultProfile";
  if (id == 0x000000B0) return "DmAutomationSetUserDefaultProfile";
  if (id == 0x000000B1) return "DmTraceIsRecording";
  if (id == 0x000000B2) return "DmLoadDebuggerExtension";
  if (id == 0x000000B3) return "DmUnloadDebuggerExtension";
  if (id == 0x000000B4) return "DmCreateSystemThread";
  if (id == 0x000000B5) return "PEPLELookup";
  if (id == 0x000000B6) return "PEPLELookupCompact";
  if (id == 0x000000B7) return "PVPLELookup";
  if (id == 0x000000B8) return "PVPLELookupCompact";
  if (id == 0x000000B9) return "PVPLELookupCompactMDS";
  if (id == 0x000000BA) return "PVPLEFilteredLookup";
  if (id == 0x000000BB) return "PVPLEFilteredLookupCompact";
  if (id == 0x000000BC) return "PVPLEFilteredLookupCompactMDS";
  if (id == 0x000000BD) return "PVPLETemplatedLookup";
  if (id == 0x000000BE) return "PVPLETemplatedLookupCompact";
  if (id == 0x000000BF) return "PVPLETemplatedLookupCompactMDS";
  if (id == 0x000000C0) return "DmpPgoCounterOverflow";
  if (id == 0x000000C1) return "UpdateMDSProbeState";
  if (id == 0x000000C2) return "DmGetHttpRegistration";
  if (id == 0x000000C3) return "DmTraceSetIOThread";
  if (id == 0x000000C4) return "DmPMCInstallAndStart";
  if (id == 0x000000C5) return "DmPMCStopAndReport";
  if (id == 0x000000C6) return "DmPMCInstallSetup";
  if (id == 0x000000C7) return "DmPMCUnInstallSetup";
  if (id == 0x000000C8) return "DmPMCResetCounters";
  if (id == 0x000000C9) return "DmPMCSetTriggerProcessor";
  if (id == 0x000000CA) return "DmPMCStart";
  if (id == 0x000000CB) return "DmPMCStop";
  if (id == 0x000000CC) return "DmPMCGetCounter";
  if (id == 0x000000CD) return "DmPMCGetCounters";
  if (id == 0x000000CE) return "DmPMCGetCounterName";
  if (id == 0x000000CF) return "DmPMCDumpCounters";
  if (id == 0x000000D0) return "DmPMCDumpCountersVerbose";
  if (id == 0x000000D1) return "DmPMCGetCounterCostEstimate";
  if (id == 0x000000D2) return "DmPMCGetCounterSource";
  if (id == 0x000000D3) return "DmPMCComputeFrequency";
  if (id == 0x000000D4) return "DmGetAdditionalTitleMemorySetting";
  if (id == 0x000000D5) return "DmGetDebugMemorySize";
  if (id == 0x000000D6) return "DmGetConsoleDebugMemoryStatus";
  if (id == 0x000000D7) return "DmNetSimSetLinkStatusHidden";
  if (id == 0x000000D8) return "DmNetSimInsertQueue";
  if (id == 0x000000D9) return "DmNetSimRemoveQueue";
  if (id == 0x000000DA) return "DmNetSimRemoveAllQueues";
  if (id == 0x000000DB) return "DmNetSimModifyQueueSettings";
  if (id == 0x000000DC) return "DmGetConsoleFeatures";
  if (id == 0x000000DD) return "DmNetSimGetQueueStats";
  if (id == 0x000000DE) return "DmNetSimGetQueueSettings";
  if (id == 0x000000DF) return "DmNetSimGetNumQueues";
  if (id == 0x000000E0) return "DmNetSimInsertIpv4Redirect";
  if (id == 0x000000E1) return "DmNetSimRemoveIpv4Redirect";
  if (id == 0x000000E2) return "DmNetSimGetNumIpv4Redirects";
  if (id == 0x0000012C) return "XLFAllocate";
  if (id == 0x0000012D) return "XLFFree";
  if (id == 0x0000012E) return "XLFQueueAdd";
  if (id == 0x0000012F) return "XLFQueueAllocated";
  if (id == 0x00000130) return "XLFQueueCreate";
  if (id == 0x00000131) return "XLFQueueDestroy";
  if (id == 0x00000132) return "XLFQueueGetEntryCount";
  if (id == 0x00000133) return "XLFQueueIsEmpty";
  if (id == 0x00000134) return "XLFQueueRemove";
  if (id == 0x00000135) return "XLFQueueUnsafeDump";
  if (id == 0x00000136) return "XLFStackAllocated";
  if (id == 0x00000137) return "XLFStackCreate";
  if (id == 0x00000138) return "XLFStackDestroy";
  if (id == 0x00000139) return "XLFStackGetEntryCount";
  if (id == 0x0000013A) return "XLFStackIsEmpty";
  if (id == 0x0000013B) return "XLFStackPop";
  if (id == 0x0000013C) return "XLFStackPush";
  if (id == 0x0000013D) return "XLFStackUnsafeDump";
  if (id == 0x00000140) return "XLFPriorityQueueAdd";
  if (id == 0x00000141) return "XLFPriorityQueueAllocated";
  if (id == 0x00000142) return "XLFPriorityQueueCreate";
  if (id == 0x00000143) return "XLFPriorityQueueDestroy";
  if (id == 0x00000144) return "XLFPriorityQueueGetEntryCount";
  if (id == 0x00000145) return "XLFPriorityQueueIsEmpty";
  if (id == 0x00000146) return "XLFPriorityQueueRemoveFirst";
  if (id == 0x00000147) return "XLFPriorityQueueRemove";
  if (id == 0x00000148) return "XLFPriorityQueueUnsafeDump";
  if (id == 0x0000014A) return "XLFHashTableAdd";
  if (id == 0x0000014B) return "XLFHashTableAllocated";
  if (id == 0x0000014C) return "XLFHashTableCreate";
  if (id == 0x0000014D) return "XLFHashTableDestroy";
  if (id == 0x0000014E) return "XLFHashTableGetEntryCount";
  if (id == 0x0000014F) return "XLFHashTableIsEmpty";
  if (id == 0x00000150) return "XLFHashTableRemoveFirst";
  if (id == 0x00000151) return "XLFHashTableRemove";
  if (id == 0x00000152) return "XLFHashTableUnsafeDump";
  if (id == 0x00000154) return "XLFPoolAcquireLock";
  if (id == 0x00000155) return "XLFPoolAllocated";
  if (id == 0x00000156) return "XLFPoolCreate";
  if (id == 0x00000157) return "XLFPoolCreateLock";
  if (id == 0x00000158) return "XLFPoolDestroy";
  if (id == 0x00000159) return "XLFPoolDestroyLock";
  if (id == 0x0000015A) return "XLFPoolIncreaseEvents";
  if (id == 0x0000015B) return "XLFPoolIncreaseLocks";
  if (id == 0x0000015C) return "XLFPoolInitializeLock";
  if (id == 0x0000015D) return "XLFPoolNumberOfEvents";
  if (id == 0x0000015E) return "XLFPoolNumberOfLocks";
  if (id == 0x0000015F) return "XLFPoolReleaseLock";
  if (id == 0x00000163) return "XLFStartLog";
  if (id == 0x00000164) return "XLFStartUserLog";
  if (id == 0x00000165) return "XLFInitializeLog";
  if (id == 0x00000166) return "XLFInitializeUserLog";
  if (id == 0x00000168) return "XLFEndLog";
  if (id == 0x00000169) return "XLFLogPrint";
  if (id == 0x0000016A) return "XLFLogPrintV";
  if (id == 0x0000016B) return "XLFLogBuffer";
  if (id == 0x0000016C) return "XLFLogMessageStats";
  if (id == 0x00000172) return "XLockFreeGetErrorHandler";
  if (id == 0x00000173) return "XLockFreeSetErrorHandler";
  if (id == 0x00000174) return "DmExecuteThreadRPC";
  if (id == 0x00000175) return "DmGetDebuggerConnection";

  return nullptr;
}

const char* xboxkrnlNameGen_1640(int id)
{
  if (id == 0x00000001) return "XexpNtosXexHeader";
  if (id == 0x00000002) return "DbgBreakPoint";
  if (id == 0x00000003) return "DbgBreakPointWithStatus";
  if (id == 0x00000004) return "DbgPrint";
  if (id == 0x00000005) return "DbgPrompt";
  if (id == 0x00000006) return "DumpGetRawDumpInfo";
  if (id == 0x00000007) return "DumpWriteDump";
  if (id == 0x00000008) return "ExAcquireReadWriteLockExclusive";
  if (id == 0x00000009) return "ExAcquireReadWriteLockShared";
  if (id == 0x0000000A) return "ExAllocatePool";
  if (id == 0x0000000B) return "ExAllocatePoolWithTag";
  if (id == 0x0000000C) return "ExAllocatePoolTypeWithTag";
  if (id == 0x0000000D) return "ExCreateThread";
  if (id == 0x0000000E) return "ExEventObjectType";
  if (id == 0x0000000F) return "ExGetXConfigSetting";
  if (id == 0x00000010) return "ExFreePool";
  if (id == 0x00000011) return "ExInitializeReadWriteLock";
  if (id == 0x00000012) return "ExMutantObjectType";
  if (id == 0x00000013) return "ExQueryPoolBlockSize";
  if (id == 0x00000014) return "ExRegisterThreadNotification";
  if (id == 0x00000015) return "ExRegisterTitleTerminateNotification";
  if (id == 0x00000016) return "ExReleaseReadWriteLock";
  if (id == 0x00000017) return "ExSemaphoreObjectType";
  if (id == 0x00000018) return "ExSetXConfigSetting";
  if (id == 0x00000019) return "ExTerminateThread";
  if (id == 0x0000001A) return "ExTerminateTitleProcess";
  if (id == 0x0000001B) return "ExThreadObjectType";
  if (id == 0x0000001C) return "ExTimerObjectType";
  if (id == 0x0000001D) return "ExQueryNonVolatileSetting";
  if (id == 0x0000001E) return "ExSaveNonVolatileSetting";
  if (id == 0x0000001F) return "ExQueryConfigPartition";
  if (id == 0x00000020) return "ExSaveConfigPartition";
  if (id == 0x00000021) return "FscGetCacheElementCount";
  if (id == 0x00000022) return "FscSetCacheElementCount";
  if (id == 0x00000023) return "HalGetCurrentAVPack";
  if (id == 0x00000024) return "HalGpioControl";
  if (id == 0x00000025) return "HalOpenCloseODDTray";
  if (id == 0x00000026) return "HalReadWritePCISpace";
  if (id == 0x00000027) return "HalRegisterShutdownNotification";
  if (id == 0x00000028) return "HalRegisterSMCNotification";
  if (id == 0x00000029) return "HalReturnToFirmware";
  if (id == 0x0000002A) return "HalSendSMCMessage";
  if (id == 0x0000002B) return "HalSetAudioEnable";
  if (id == 0x0000002C) return "InterlockedFlushSList";
  if (id == 0x0000002D) return "InterlockedPopEntrySList";
  if (id == 0x0000002E) return "InterlockedPushEntrySList";
  if (id == 0x0000002F) return "IoAcquireDeviceObjectLock";
  if (id == 0x00000030) return "IoAllocateIrp";
  if (id == 0x00000031) return "IoBuildAsynchronousFsdRequest";
  if (id == 0x00000032) return "IoBuildDeviceIoControlRequest";
  if (id == 0x00000033) return "IoBuildSynchronousFsdRequest";
  if (id == 0x00000034) return "IoCallDriver";
  if (id == 0x00000035) return "IoCheckShareAccess";
  if (id == 0x00000036) return "IoCompleteRequest";
  if (id == 0x00000037) return "IoCompletionObjectType";
  if (id == 0x00000038) return "IoCreateDevice";
  if (id == 0x00000039) return "IoCreateFile";
  if (id == 0x0000003A) return "IoDeleteDevice";
  if (id == 0x0000003B) return "IoDeviceObjectType";
  if (id == 0x0000003C) return "IoDismountVolume";
  if (id == 0x0000003D) return "IoDismountVolumeByFileHandle";
  if (id == 0x0000003E) return "IoDismountVolumeByName";
  if (id == 0x0000003F) return "IoFileObjectType";
  if (id == 0x00000040) return "IoFreeIrp";
  if (id == 0x00000041) return "IoInitializeIrp";
  if (id == 0x00000042) return "IoInvalidDeviceRequest";
  if (id == 0x00000043) return "KiApcNormalRoutineNop";
  if (id == 0x00000044) return "IoQueueThreadIrp";
  if (id == 0x00000045) return "IoReleaseDeviceObjectLock";
  if (id == 0x00000046) return "IoRemoveShareAccess";
  if (id == 0x00000047) return "IoSetIoCompletion";
  if (id == 0x00000048) return "IoSetShareAccess";
  if (id == 0x00000049) return "IoStartNextPacket";
  if (id == 0x0000004A) return "IoStartNextPacketByKey";
  if (id == 0x0000004B) return "IoStartPacket";
  if (id == 0x0000004C) return "IoSynchronousDeviceIoControlRequest";
  if (id == 0x0000004D) return "IoSynchronousFsdRequest";
  if (id == 0x0000004E) return "KeAcquireSpinLockAtRaisedIrql";
  if (id == 0x0000004F) return "KeAlertResumeThread";
  if (id == 0x00000050) return "KeAlertThread";
  if (id == 0x00000051) return "KeBoostPriorityThread";
  if (id == 0x00000052) return "KeBugCheck";
  if (id == 0x00000053) return "KeBugCheckEx";
  if (id == 0x00000054) return "KeCancelTimer";
  if (id == 0x00000055) return "KeConnectInterrupt";
  if (id == 0x00000056) return "KeContextFromKframes";
  if (id == 0x00000057) return "KeContextToKframes";
  if (id == 0x00000058) return "KeCreateUserMode";
  if (id == 0x00000059) return "KeDebugMonitorData";
  if (id == 0x0000005A) return "KeDelayExecutionThread";
  if (id == 0x0000005B) return "KeDeleteUserMode";
  if (id == 0x0000005C) return "KeDisconnectInterrupt";
  if (id == 0x0000005D) return "KeEnableFpuExceptions";
  if (id == 0x0000005E) return "KeEnablePPUPerformanceMonitor";
  if (id == 0x0000005F) return "KeEnterCriticalRegion";
  if (id == 0x00000060) return "KeEnterUserMode";
  if (id == 0x00000061) return "KeFlushCacheRange";
  if (id == 0x00000062) return "KeFlushCurrentSingleTb";
  if (id == 0x00000063) return "KeFlushCurrentEntireTb";
  if (id == 0x00000064) return "KeFlushUserModeCurrentTb";
  if (id == 0x00000065) return "KeFlushUserModeTb";
  if (id == 0x00000066) return "KeGetCurrentProcessType";
  if (id == 0x00000067) return "KeGetPMWRegister";
  if (id == 0x00000068) return "KeGetPRVRegister";
  if (id == 0x00000069) return "KeGetSpecialPurposeRegister";
  if (id == 0x0000006A) return "KeInitializeApc";
  if (id == 0x0000006C) return "KeInitializeDeviceQueue";
  if (id == 0x0000006D) return "KeInitializeDpc";
  if (id == 0x0000006E) return "KeInitializeEvent";
  if (id == 0x0000006F) return "KeInitializeInterrupt";
  if (id == 0x00000070) return "KeInitializeMutant";
  if (id == 0x00000071) return "KeInitializeQueue";
  if (id == 0x00000072) return "KeInitializeSemaphore";
  if (id == 0x00000073) return "KeInitializeTimerEx";
  if (id == 0x00000074) return "KeInsertByKeyDeviceQueue";
  if (id == 0x00000075) return "KeInsertDeviceQueue";
  if (id == 0x00000076) return "KeInsertHeadQueue";
  if (id == 0x00000077) return "KeInsertQueue";
  if (id == 0x00000078) return "KeInsertQueueApc";
  if (id == 0x00000079) return "KeInsertQueueDpc";
  if (id == 0x0000007A) return "KeIpiGenericCall";
  if (id == 0x0000007B) return "KeLeaveCriticalRegion";
  if (id == 0x0000007C) return "KeLeaveUserMode";
  if (id == 0x0000007D) return "KePulseEvent";
  if (id == 0x0000007E) return "KeQueryBasePriorityThread";
  if (id == 0x0000007F) return "KeQueryInterruptTime";
  if (id == 0x00000080) return "KeQueryPerformanceFrequency";
  if (id == 0x00000081) return "KeQuerySystemTime";
  if (id == 0x00000082) return "KeRaiseIrqlToDpcLevel";
  if (id == 0x00000083) return "KeReleaseMutant";
  if (id == 0x00000084) return "KeReleaseSemaphore";
  if (id == 0x00000085) return "KeReleaseSpinLockFromRaisedIrql";
  if (id == 0x00000086) return "KeRemoveByKeyDeviceQueue";
  if (id == 0x00000087) return "KeRemoveDeviceQueue";
  if (id == 0x00000088) return "KeRemoveEntryDeviceQueue";
  if (id == 0x00000089) return "KeRemoveQueue";
  if (id == 0x0000008A) return "KeRemoveQueueDpc";
  if (id == 0x0000008B) return "KeResetEvent";
  if (id == 0x0000008C) return "KeRestoreFloatingPointState";
  if (id == 0x0000008D) return "KeRestoreVectorUnitState";
  if (id == 0x0000008E) return "KeResumeThread";
  if (id == 0x0000008F) return "KeRundownQueue";
  if (id == 0x00000090) return "KeSaveFloatingPointState";
  if (id == 0x00000091) return "KeSaveVectorUnitState";
  if (id == 0x00000092) return "KeSetAffinityThread";
  if (id == 0x00000093) return "KeSetBasePriorityThread";
  if (id == 0x00000094) return "KeSetCurrentProcessType";
  if (id == 0x00000095) return "KeSetCurrentStackPointers";
  if (id == 0x00000096) return "KeSetDisableBoostThread";
  if (id == 0x00000097) return "KeSetEvent";
  if (id == 0x00000098) return "KeSetEventBoostPriority";
  if (id == 0x00000099) return "KeSetPMWRegister";
  if (id == 0x0000009A) return "KeSetPRVRegister";
  if (id == 0x0000009B) return "KeSetPriorityClassThread";
  if (id == 0x0000009C) return "KeSetPriorityThread";
  if (id == 0x0000009D) return "KeSetSpecialPurposeRegister";
  if (id == 0x0000009E) return "KeSetTimer";
  if (id == 0x0000009F) return "KeSetTimerEx";
  if (id == 0x000000A0) return "KeStallExecutionProcessor";
  if (id == 0x000000A1) return "KeStartBackgroundScheduling";
  if (id == 0x000000A2) return "KeSuspendThread";
  if (id == 0x000000A3) return "KeSweepDcacheRange";
  if (id == 0x000000A4) return "KeSweepIcacheRange";
  if (id == 0x000000A5) return "KeTestAlertThread";
  if (id == 0x000000A6) return "KeTimeStampBundle";
  if (id == 0x000000A7) return "KeTryToAcquireSpinLockAtRaisedIrql";
  if (id == 0x000000A8) return "KeWaitForMultipleObjects";
  if (id == 0x000000A9) return "KeWaitForSingleObject";
  if (id == 0x000000AA) return "KfAcquireSpinLock";
  if (id == 0x000000AB) return "KfRaiseIrql";
  if (id == 0x000000AC) return "KfLowerIrql";
  if (id == 0x000000AD) return "KfReleaseSpinLock";
  if (id == 0x000000AE) return "KiBugCheckData";
  if (id == 0x000000AF) return "LDICreateDecompression";
  if (id == 0x000000B0) return "LDIDecompress";
  if (id == 0x000000B1) return "LDIDestroyDecompression";
  if (id == 0x000000B2) return "MmAllocatePhysicalMemory";
  if (id == 0x000000B3) return "MmAllocatePhysicalMemoryEx";
  if (id == 0x000000B4) return "MmCreateKernelStack";
  if (id == 0x000000B5) return "MmDeleteKernelStack";
  if (id == 0x000000B6) return "MmFreePhysicalMemory";
  if (id == 0x000000B7) return "MmGetPhysicalAddress";
  if (id == 0x000000B8) return "MmIsAddressValid";
  if (id == 0x000000B9) return "MmLockAndMapSegmentArray";
  if (id == 0x000000BA) return "MmLockUnlockBufferPages";
  if (id == 0x000000BB) return "MmMapIoSpace";
  if (id == 0x000000BC) return "MmPersistPhysicalMemoryAllocation";
  if (id == 0x000000BD) return "MmQueryAddressProtect";
  if (id == 0x000000BE) return "MmQueryAllocationSize";
  if (id == 0x000000BF) return "MmQueryStatistics";
  if (id == 0x000000C0) return "MmSetAddressProtect";
  if (id == 0x000000C1) return "MmSplitPhysicalMemoryAllocation";
  if (id == 0x000000C2) return "MmUnlockAndUnmapSegmentArray";
  if (id == 0x000000C3) return "MmUnmapIoSpace";
  if (id == 0x000000C4) return "Nls844UnicodeCaseTable";
  if (id == 0x000000C5) return "NtAllocateVirtualMemory";
  if (id == 0x000000C6) return "NtCancelTimer";
  if (id == 0x000000C7) return "NtClearEvent";
  if (id == 0x000000C8) return "NtClose";
  if (id == 0x000000C9) return "NtCreateDirectoryObject";
  if (id == 0x000000CA) return "NtCreateEvent";
  if (id == 0x000000CB) return "NtCreateFile";
  if (id == 0x000000CC) return "NtCreateIoCompletion";
  if (id == 0x000000CD) return "NtCreateMutant";
  if (id == 0x000000CE) return "NtCreateSemaphore";
  if (id == 0x000000CF) return "NtCreateSymbolicLinkObject";
  if (id == 0x000000D0) return "NtCreateTimer";
  if (id == 0x000000D1) return "NtDeleteFile";
  if (id == 0x000000D2) return "NtDeviceIoControlFile";
  if (id == 0x000000D3) return "NtDuplicateObject";
  if (id == 0x000000D4) return "NtFlushBuffersFile";
  if (id == 0x000000D5) return "NtFreeVirtualMemory";
  if (id == 0x000000D6) return "NtMakeTemporaryObject";
  if (id == 0x000000D7) return "NtOpenDirectoryObject";
  if (id == 0x000000D8) return "NtOpenFile";
  if (id == 0x000000D9) return "NtOpenSymbolicLinkObject";
  if (id == 0x000000DA) return "NtProtectVirtualMemory";
  if (id == 0x000000DB) return "NtPulseEvent";
  if (id == 0x000000DC) return "NtQueueApcThread";
  if (id == 0x000000DD) return "NtQueryDirectoryFile";
  if (id == 0x000000DE) return "NtQueryDirectoryObject";
  if (id == 0x000000DF) return "NtQueryEvent";
  if (id == 0x000000E0) return "NtQueryFullAttributesFile";
  if (id == 0x000000E1) return "NtQueryInformationFile";
  if (id == 0x000000E2) return "NtQueryIoCompletion";
  if (id == 0x000000E3) return "NtQueryMutant";
  if (id == 0x000000E4) return "NtQuerySemaphore";
  if (id == 0x000000E5) return "NtQuerySymbolicLinkObject";
  if (id == 0x000000E6) return "NtQueryTimer";
  if (id == 0x000000E7) return "NtQueryVirtualMemory";
  if (id == 0x000000E8) return "NtQueryVolumeInformationFile";
  if (id == 0x000000E9) return "NtReadFile";
  if (id == 0x000000EA) return "NtReadFileScatter";
  if (id == 0x000000EB) return "NtReleaseMutant";
  if (id == 0x000000EC) return "NtReleaseSemaphore";
  if (id == 0x000000ED) return "NtRemoveIoCompletion";
  if (id == 0x000000EE) return "NtResumeThread";
  if (id == 0x000000EF) return "NtSetEvent";
  if (id == 0x000000F0) return "NtSetInformationFile";
  if (id == 0x000000F1) return "NtSetIoCompletion";
  if (id == 0x000000F2) return "NtSetSystemTime";
  if (id == 0x000000F3) return "NtSetTimerEx";
  if (id == 0x000000F4) return "NtSignalAndWaitForSingleObjectEx";
  if (id == 0x000000F5) return "NtSuspendThread";
  if (id == 0x000000F6) return "NtWaitForSingleObjectEx";
  if (id == 0x000000F7) return "NtWaitForMultipleObjectsEx";
  if (id == 0x000000F8) return "NtWriteFile";
  if (id == 0x000000F9) return "NtWriteFileGather";
  if (id == 0x000000FA) return "NtYieldExecution";
  if (id == 0x000000FB) return "ObCreateObject";
  if (id == 0x000000FC) return "ObCreateSymbolicLink";
  if (id == 0x000000FD) return "ObDeleteSymbolicLink";
  if (id == 0x000000FE) return "ObDereferenceObject";
  if (id == 0x000000FF) return "ObDirectoryObjectType";
  if (id == 0x00000100) return "ObGetWaitableObject";
  if (id == 0x00000101) return "ObInsertObject";
  if (id == 0x00000102) return "ObIsTitleObject";
  if (id == 0x00000103) return "ObLookupAnyThreadByThreadId";
  if (id == 0x00000104) return "ObLookupThreadByThreadId";
  if (id == 0x00000105) return "ObMakeTemporaryObject";
  if (id == 0x00000106) return "ObOpenObjectByName";
  if (id == 0x00000107) return "ObOpenObjectByPointer";
  if (id == 0x00000108) return "ObReferenceObject";
  if (id == 0x00000109) return "ObReferenceObjectByHandle";
  if (id == 0x0000010A) return "ObReferenceObjectByName";
  if (id == 0x0000010B) return "ObSymbolicLinkObjectType";
  if (id == 0x0000010C) return "ObTranslateSymbolicLink";
  if (id == 0x0000010D) return "RtlAnsiStringToUnicodeString";
  if (id == 0x0000010E) return "RtlAppendStringToString";
  if (id == 0x0000010F) return "RtlAppendUnicodeStringToString";
  if (id == 0x00000110) return "RtlAppendUnicodeToString";
  if (id == 0x00000111) return "RtlAssert";
  if (id == 0x00000112) return "RtlCaptureContext";
  if (id == 0x00000113) return "RtlCompareMemory";
  if (id == 0x00000114) return "RtlCompareMemoryUlong";
  if (id == 0x00000115) return "RtlCompareString";
  if (id == 0x00000116) return "RtlCompareStringN";
  if (id == 0x00000117) return "RtlCompareUnicodeString";
  if (id == 0x00000118) return "RtlCompareUnicodeStringN";
  if (id == 0x00000119) return "RtlCopyString";
  if (id == 0x0000011A) return "RtlCopyUnicodeString";
  if (id == 0x0000011B) return "RtlCreateUnicodeString";
  if (id == 0x0000011C) return "RtlDowncaseUnicodeChar";
  if (id == 0x0000011D) return "RtlEnterCriticalSection";
  if (id == 0x0000011E) return "RtlFillMemoryUlong";
  if (id == 0x0000011F) return "RtlFreeAnsiString";
  if (id == 0x00000120) return "RtlFreeAnsiString";
  if (id == 0x00000121) return "RtlGetCallersAddress";
  if (id == 0x00000122) return "RtlGetStackLimits";
  if (id == 0x00000123) return "RtlImageXexHeaderField";
  if (id == 0x00000124) return "RtlInitAnsiString";
  if (id == 0x00000125) return "RtlInitUnicodeString";
  if (id == 0x00000126) return "RtlInitializeCriticalSection";
  if (id == 0x00000127) return "RtlInitializeCriticalSectionAndSpinCount";
  if (id == 0x00000128) return "RtlLeaveCriticalSection";
  if (id == 0x00000129) return "RtlLookupFunctionEntry";
  if (id == 0x0000012A) return "RtlLowerChar";
  if (id == 0x0000012B) return "RtlMultiByteToUnicodeN";
  if (id == 0x0000012C) return "RtlMultiByteToUnicodeSize";
  if (id == 0x0000012D) return "RtlNtStatusToDosError";
  if (id == 0x0000012E) return "RtlRaiseException";
  if (id == 0x0000012F) return "RtlRaiseStatus";
  if (id == 0x00000130) return "RtlRip";
  if (id == 0x00000131) return "_scprintf";
  if (id == 0x00000132) return "_snprintf";
  if (id == 0x00000133) return "sprintf";
  if (id == 0x00000134) return "_scwprintf";
  if (id == 0x00000135) return "_snwprintf";
  if (id == 0x00000136) return "_swprintf";
  if (id == 0x00000137) return "RtlTimeFieldsToTime";
  if (id == 0x00000138) return "RtlTimeToTimeFields";
  if (id == 0x00000139) return "RtlTryEnterCriticalSection";
  if (id == 0x0000013A) return "RtlUnicodeStringToAnsiString";
  if (id == 0x0000013B) return "RtlUnicodeToMultiByteN";
  if (id == 0x0000013C) return "RtlUnicodeToMultiByteSize";
  if (id == 0x0000013D) return "RtlUnwind";
  if (id == 0x0000013E) return "RtlUnwind2";
  if (id == 0x0000013F) return "RtlUpcaseUnicodeChar";
  if (id == 0x00000140) return "RtlUpperChar";
  if (id == 0x00000141) return "RtlVirtualUnwind";
  if (id == 0x00000142) return "_vscprintf";
  if (id == 0x00000143) return "_vsnprintf";
  if (id == 0x00000144) return "vsprintf";
  if (id == 0x00000145) return "_vscwprintf";
  if (id == 0x00000146) return "_vsnwprintf";
  if (id == 0x00000147) return "_vswprintf";
  if (id == 0x00000148) return "SfcWriteLogical";
  if (id == 0x00000149) return "TlsAlloc";
  if (id == 0x0000014A) return "TlsFree";
  if (id == 0x0000014B) return "TlsGetValue";
  if (id == 0x0000014C) return "TlsSetValue";
  if (id == 0x0000014D) return "XboxHardwareInfo";
  if (id == 0x0000014E) return "XboxKrnlVersion";
  if (id == 0x0000014F) return "XeCryptAesKey";
  if (id == 0x00000150) return "XeCryptAesEcb";
  if (id == 0x00000151) return "XeCryptAesCbc";
  if (id == 0x00000152) return "XeCryptBnDwLeDhEqualBase";
  if (id == 0x00000153) return "XeCryptBnDwLeDhInvalBase";
  if (id == 0x00000154) return "XeCryptBnDwLeDhModExp";
  if (id == 0x00000155) return "XeCryptBnDw_Copy";
  if (id == 0x00000156) return "XeCryptBnDw_SwapLeBe";
  if (id == 0x00000157) return "XeCryptBnDw_Zero";
  if (id == 0x00000158) return "XeCryptBnDwLePkcs1Format";
  if (id == 0x00000159) return "XeCryptBnDwLePkcs1Verify";
  if (id == 0x0000015A) return "XeCryptBnQwBeSigCreate";
  if (id == 0x0000015B) return "XeCryptBnQwBeSigFormat";
  if (id == 0x0000015C) return "XeCryptBnQwBeSigVerify";
  if (id == 0x0000015D) return "XeCryptBnQwNeEcSigVerify";
  if (id == 0x0000015E) return "XeCryptBnQwNeModExp";
  if (id == 0x0000015F) return "XeCryptBnQwNeModExpRoot";
  if (id == 0x00000160) return "XeCryptBnQwNeModInv";
  if (id == 0x00000161) return "XeCryptBnQwNeModMul";
  if (id == 0x00000162) return "XeCryptBnQwNeRsaKeyGen";
  if (id == 0x00000163) return "XeCryptBnQwNeRsaPrvCrypt";
  if (id == 0x00000164) return "XeCryptBnQwNeRsaPubCrypt";
  if (id == 0x00000165) return "XeCryptBnQw_Copy";
  if (id == 0x00000166) return "XeCryptBnQw_SwapDwQw";
  if (id == 0x00000167) return "XeCryptBnQw_SwapDwQwLeBe";
  if (id == 0x00000168) return "XeCryptBnQw_SwapLeBe";
  if (id == 0x00000169) return "XeCryptBnQw_Zero";
  if (id == 0x0000016A) return "XeCryptChainAndSumMac";
  if (id == 0x0000016B) return "XeCryptDesParity";
  if (id == 0x0000016C) return "XeCryptDesKey";
  if (id == 0x0000016D) return "XeCryptDesEcb";
  if (id == 0x0000016E) return "XeCryptDesCbc";
  if (id == 0x0000016F) return "XeCryptDes3Key";
  if (id == 0x00000170) return "XeCryptDes3Ecb";
  if (id == 0x00000171) return "XeCryptDes3Cbc";
  if (id == 0x00000172) return "XeCryptHmacMd5Init";
  if (id == 0x00000173) return "XeCryptHmacMd5Update";
  if (id == 0x00000174) return "XeCryptHmacMd5Final";
  if (id == 0x00000175) return "XeCryptHmacMd5";
  if (id == 0x00000176) return "XeCryptHmacShaInit";
  if (id == 0x00000177) return "XeCryptHmacShaUpdate";
  if (id == 0x00000178) return "XeCryptHmacShaFinal";
  if (id == 0x00000179) return "XeCryptHmacSha";
  if (id == 0x0000017A) return "XeCryptHmacShaVerify";
  if (id == 0x0000017B) return "XeCryptMd5Init";
  if (id == 0x0000017C) return "XeCryptMd5Update";
  if (id == 0x0000017D) return "XeCryptMd5Final";
  if (id == 0x0000017E) return "XeCryptMd5";
  if (id == 0x0000017F) return "XeCryptParveEcb";
  if (id == 0x00000180) return "XeCryptParveCbcMac";
  if (id == 0x00000181) return "XeCryptRandom";
  if (id == 0x00000182) return "XeCryptRc4Key";
  if (id == 0x00000183) return "XeCryptRc4Ecb";
  if (id == 0x00000184) return "XeCryptRc4";
  if (id == 0x00000185) return "XeCryptShaInit";
  if (id == 0x00000186) return "XeCryptShaUpdate";
  if (id == 0x00000187) return "XeCryptShaFinal";
  if (id == 0x00000188) return "XeCryptSha";
  if (id == 0x00000189) return "XexExecutableModuleHandle";
  if (id == 0x0000018A) return "XexGetModuleHandle";
  if (id == 0x0000018B) return "XexGetModuleSection";
  if (id == 0x0000018C) return "XexGetProcedureAddress";
  if (id == 0x0000018D) return "XexLoadExecutable";
  if (id == 0x0000018E) return "XexLoadImage";
  if (id == 0x0000018F) return "XexLoadImageHeaders";
  if (id == 0x00000190) return "XexPcToFileHeader";
  if (id == 0x00000191) return "XexRegisterLoader";
  if (id == 0x00000192) return "XexRegisterPatchDescriptor";
  if (id == 0x00000193) return "XexSendDeferredNotifications";
  if (id == 0x00000194) return "XexStartExecutable";
  if (id == 0x00000195) return "XexUnloadImage";
  if (id == 0x00000196) return "XexUnloadImageAndExitThread";
  if (id == 0x00000197) return "XexUnloadTitleModules";
  if (id == 0x00000198) return "__C_specific_handler";
  if (id == 0x00000199) return "DbgLoadImageSymbols";
  if (id == 0x0000019A) return "DbgUnLoadImageSymbols";
  if (id == 0x0000019B) return "RtlImageDirectoryEntryToData";
  if (id == 0x0000019C) return "RtlImageNtHeader";
  if (id == 0x0000019D) return "ExDebugMonitorService";
  if (id == 0x0000019E) return "MmDbgReadCheck";
  if (id == 0x0000019F) return "MmDbgReleaseAddress";
  if (id == 0x000001A0) return "MmDbgWriteCheck";
  if (id == 0x000001A1) return "ExLoadedCommandLine";
  if (id == 0x000001A2) return "ExLoadedImageName";

  return nullptr;
}

const char* xboxkrnlNameGen_1746(int id)
{
  if (id == 0x00000002) return "DbgBreakPoint";
  if (id == 0x00000003) return "DbgBreakPointWithStatus";
  if (id == 0x00000004) return "DbgPrint";
  if (id == 0x00000005) return "DbgPrompt";
  if (id == 0x00000006) return "DumpGetRawDumpInfo";
  if (id == 0x00000007) return "DumpWriteDump";
  if (id == 0x00000008) return "ExAcquireReadWriteLockExclusive";
  if (id == 0x00000009) return "ExAcquireReadWriteLockShared";
  if (id == 0x0000000A) return "ExAllocatePool";
  if (id == 0x0000000B) return "ExAllocatePoolWithTag";
  if (id == 0x0000000C) return "ExAllocatePoolTypeWithTag";
  if (id == 0x0000000D) return "ExCreateThread";
  if (id == 0x0000000E) return "ExEventObjectType";
  if (id == 0x0000000F) return "ExGetXConfigSetting";
  if (id == 0x00000010) return "ExFreePool";
  if (id == 0x00000011) return "ExInitializeReadWriteLock";
  if (id == 0x00000012) return "ExMutantObjectType";
  if (id == 0x00000013) return "ExQueryPoolBlockSize";
  if (id == 0x00000014) return "ExRegisterThreadNotification";
  if (id == 0x00000015) return "ExRegisterTitleTerminateNotification";
  if (id == 0x00000016) return "ExReleaseReadWriteLock";
  if (id == 0x00000017) return "ExSemaphoreObjectType";
  if (id == 0x00000018) return "ExSetXConfigSetting";
  if (id == 0x00000019) return "ExTerminateThread";
  if (id == 0x0000001A) return "ExTerminateTitleProcess";
  if (id == 0x0000001B) return "ExThreadObjectType";
  if (id == 0x0000001C) return "ExTimerObjectType";
  if (id == 0x0000001D) return "ExQueryNonVolatileSetting";
  if (id == 0x0000001E) return "ExSaveNonVolatileSetting";
  if (id == 0x0000001F) return "ExQueryConfigPartition";
  if (id == 0x00000020) return "ExSaveConfigPartition";
  if (id == 0x00000021) return "FscGetCacheElementCount";
  if (id == 0x00000022) return "FscSetCacheElementCount";
  if (id == 0x00000023) return "HalGetCurrentAVPack";
  if (id == 0x00000024) return "HalGpioControl";
  if (id == 0x00000025) return "HalOpenCloseODDTray";
  if (id == 0x00000026) return "HalReadWritePCISpace";
  if (id == 0x00000027) return "HalRegisterShutdownNotification";
  if (id == 0x00000028) return "HalRegisterSMCNotification";
  if (id == 0x00000029) return "HalReturnToFirmware";
  if (id == 0x0000002A) return "HalSendSMCMessage";
  if (id == 0x0000002B) return "HalSetAudioEnable";
  if (id == 0x0000002C) return "InterlockedFlushSList";
  if (id == 0x0000002D) return "InterlockedPopEntrySList";
  if (id == 0x0000002E) return "InterlockedPushEntrySList";
  if (id == 0x0000002F) return "IoAcquireDeviceObjectLock";
  if (id == 0x00000030) return "IoAllocateIrp";
  if (id == 0x00000031) return "IoBuildAsynchronousFsdRequest";
  if (id == 0x00000032) return "IoBuildDeviceIoControlRequest";
  if (id == 0x00000033) return "IoBuildSynchronousFsdRequest";
  if (id == 0x00000034) return "IoCallDriver";
  if (id == 0x00000035) return "IoCheckShareAccess";
  if (id == 0x00000036) return "IoCompleteRequest";
  if (id == 0x00000037) return "ExTimerObjectType";
  if (id == 0x00000038) return "IoCreateDevice";
  if (id == 0x00000039) return "IoCreateFile";
  if (id == 0x0000003A) return "IoDeleteDevice";
  if (id == 0x0000003B) return "IoDeviceObjectType";
  if (id == 0x0000003C) return "IoDismountVolume";
  if (id == 0x0000003D) return "IoDismountVolumeByFileHandle";
  if (id == 0x0000003E) return "IoDismountVolumeByName";
  if (id == 0x0000003F) return "IoFileObjectType";
  if (id == 0x00000040) return "IoFreeIrp";
  if (id == 0x00000041) return "IoInitializeIrp";
  if (id == 0x00000042) return "IoInvalidDeviceRequest";
  if (id == 0x00000043) return "KiApcNormalRoutineNop";
  if (id == 0x00000044) return "IoQueueThreadIrp";
  if (id == 0x00000045) return "IoReleaseDeviceObjectLock";
  if (id == 0x00000046) return "IoRemoveShareAccess";
  if (id == 0x00000047) return "IoSetIoCompletion";
  if (id == 0x00000048) return "IoSetShareAccess";
  if (id == 0x00000049) return "IoStartNextPacket";
  if (id == 0x0000004A) return "IoStartNextPacketByKey";
  if (id == 0x0000004B) return "IoStartPacket";
  if (id == 0x0000004C) return "IoSynchronousDeviceIoControlRequest";
  if (id == 0x0000004D) return "IoSynchronousFsdRequest";
  if (id == 0x0000004E) return "KeAccessFuses";
  if (id == 0x0000004F) return "KeAcquireSpinLockAtRaisedIrql";
  if (id == 0x00000050) return "KeAlertResumeThread";
  if (id == 0x00000051) return "KeAlertThread";
  if (id == 0x00000052) return "KeBoostPriorityThread";
  if (id == 0x00000053) return "KeBugCheck";
  if (id == 0x00000054) return "KeBugCheckEx";
  if (id == 0x00000055) return "KeCancelTimer";
  if (id == 0x00000056) return "KeConnectInterrupt";
  if (id == 0x00000057) return "KeContextFromKframes";
  if (id == 0x00000058) return "KeContextToKframes";
  if (id == 0x00000059) return "KeCreateUserMode";
  if (id == 0x0000005A) return "KeDebugMonitorData";
  if (id == 0x0000005B) return "KeDelayExecutionThread";
  if (id == 0x0000005C) return "KeDeleteUserMode";
  if (id == 0x0000005D) return "KeDisconnectInterrupt";
  if (id == 0x0000005E) return "KeEnableFpuExceptions";
  if (id == 0x0000005F) return "KeEnablePPUPerformanceMonitor";
  if (id == 0x00000060) return "KeEnterCriticalRegion";
  if (id == 0x00000061) return "KeEnterUserMode";
  if (id == 0x00000062) return "KeFlushCacheRange";
  if (id == 0x00000063) return "KeFlushEntireTb";
  if (id == 0x00000064) return "KeFlushCurrentEntireTb";
  if (id == 0x00000065) return "KeFlushUserModeCurrentTb";
  if (id == 0x00000066) return "KeFlushUserModeTb";
  if (id == 0x00000067) return "KeGetCurrentProcessType";
  if (id == 0x00000068) return "KeGetPMWRegister";
  if (id == 0x00000069) return "KeGetPRVRegister";
  if (id == 0x0000006A) return "KeGetSocRegister";
  if (id == 0x0000006C) return "KeGetSpecialPurposeRegister";
  if (id == 0x0000006D) return "KeInitializeApc";
  if (id == 0x0000006E) return "KeInitializeDeviceQueue";
  if (id == 0x0000006F) return "KeInitializeDpc";
  if (id == 0x00000070) return "KeInitializeEvent";
  if (id == 0x00000071) return "KeInitializeInterrupt";
  if (id == 0x00000072) return "KeInitializeMutant";
  if (id == 0x00000073) return "KeInitializeQueue";
  if (id == 0x00000074) return "KeInitializeSemaphore";
  if (id == 0x00000075) return "KeInitializeTimerEx";
  if (id == 0x00000076) return "KeInsertByKeyDeviceQueue";
  if (id == 0x00000077) return "KeInsertDeviceQueue";
  if (id == 0x00000078) return "KeInsertHeadQueue";
  if (id == 0x00000079) return "KeInsertQueue";
  if (id == 0x0000007A) return "KeInsertQueueApc";
  if (id == 0x0000007B) return "KeInsertQueueDpc";
  if (id == 0x0000007C) return "KeIpiGenericCall";
  if (id == 0x0000007D) return "KeLeaveCriticalRegion";
  if (id == 0x0000007E) return "KeLeaveUserMode";
  if (id == 0x0000007F) return "KePulseEvent";
  if (id == 0x00000080) return "KeQueryBasePriorityThread";
  if (id == 0x00000081) return "KeQueryInterruptTime";
  if (id == 0x00000082) return "KeQueryPerformanceFrequency";
  if (id == 0x00000083) return "KeQuerySystemTime";
  if (id == 0x00000084) return "KeRaiseIrqlToDpcLevel";
  if (id == 0x00000085) return "KeRegisterDriverNotification";
  if (id == 0x00000086) return "KeReleaseMutant";
  if (id == 0x00000087) return "KeReleaseSemaphore";
  if (id == 0x00000088) return "KeReleaseSpinLockFromRaisedIrql";
  if (id == 0x00000089) return "KeRemoveByKeyDeviceQueue";
  if (id == 0x0000008A) return "KeRemoveDeviceQueue";
  if (id == 0x0000008B) return "KeRemoveEntryDeviceQueue";
  if (id == 0x0000008C) return "KeRemoveQueue";
  if (id == 0x0000008D) return "KeRemoveQueueDpc";
  if (id == 0x0000008E) return "KeResetEvent";
  if (id == 0x0000008F) return "KeRestoreFloatingPointState";
  if (id == 0x00000090) return "KeRestoreVectorUnitState";
  if (id == 0x00000091) return "KeResumeThread";
  if (id == 0x00000092) return "KeRetireDpcList";
  if (id == 0x00000093) return "KeRundownQueue";
  if (id == 0x00000094) return "KeSaveFloatingPointState";
  if (id == 0x00000095) return "KeSaveVectorUnitState";
  if (id == 0x00000096) return "KeSetAffinityThread";
  if (id == 0x00000097) return "KeSetBasePriorityThread";
  if (id == 0x00000098) return "KeSetCurrentProcessType";
  if (id == 0x00000099) return "KeSetCurrentStackPointers";
  if (id == 0x0000009A) return "KeSetDisableBoostThread";
  if (id == 0x0000009B) return "KeSetEvent";
  if (id == 0x0000009C) return "KeSetEventBoostPriority";
  if (id == 0x0000009D) return "KeSetPMWRegister";
  if (id == 0x0000009E) return "KeSetPowerMode";
  if (id == 0x0000009F) return "KeSetPRVRegister";
  if (id == 0x000000A0) return "KeSetPriorityClassThread";
  if (id == 0x000000A1) return "KeSetPriorityThread";
  if (id == 0x000000A2) return "KeSetSocRegister";
  if (id == 0x000000A3) return "KeSetSpecialPurposeRegister";
  if (id == 0x000000A4) return "KeSetTimer";
  if (id == 0x000000A5) return "KeSetTimerEx";
  if (id == 0x000000A6) return "KeStallExecutionProcessor";
  if (id == 0x000000A8) return "KeSuspendThread";
  if (id == 0x000000A9) return "KeSweepDcacheRange";
  if (id == 0x000000AA) return "KeSweepIcacheRange";
  if (id == 0x000000AB) return "KeTestAlertThread";
  if (id == 0x000000AC) return "KeTimeStampBundle";
  if (id == 0x000000AD) return "KeTryToAcquireSpinLockAtRaisedIrql";
  if (id == 0x000000AE) return "KeWaitForMultipleObjects";
  if (id == 0x000000AF) return "KeWaitForSingleObject";
  if (id == 0x000000B0) return "KfAcquireSpinLock";
  if (id == 0x000000B1) return "KfRaiseIrql";
  if (id == 0x000000B2) return "KfLowerIrql";
  if (id == 0x000000B3) return "KfReleaseSpinLock";
  if (id == 0x000000B4) return "KiBugCheckData";
  if (id == 0x000000B5) return "LDICreateDecompression";
  if (id == 0x000000B6) return "LDIDecompress";
  if (id == 0x000000B7) return "LDIDestroyDecompression";
  if (id == 0x000000B8) return "MmAllocatePhysicalMemory";
  if (id == 0x000000B9) return "MmAllocatePhysicalMemoryEx";
  if (id == 0x000000BA) return "MmCreateKernelStack";
  if (id == 0x000000BB) return "MmDeleteKernelStack";
  if (id == 0x000000BC) return "MmFreePhysicalMemory";
  if (id == 0x000000BD) return "MmGetPhysicalAddress";
  if (id == 0x000000BE) return "MmIsAddressValid";
  if (id == 0x000000BF) return "MmLockAndMapSegmentArray";
  if (id == 0x000000C0) return "MmLockUnlockBufferPages";
  if (id == 0x000000C1) return "MmMapIoSpace";
  if (id == 0x000000C2) return "MmPersistPhysicalMemoryAllocation";
  if (id == 0x000000C3) return "MmQueryAddressProtect";
  if (id == 0x000000C4) return "MmQueryAllocationSize";
  if (id == 0x000000C5) return "MmQueryStatistics";
  if (id == 0x000000C6) return "MmSetAddressProtect";
  if (id == 0x000000C7) return "MmSplitPhysicalMemoryAllocation";
  if (id == 0x000000C8) return "MmUnlockAndUnmapSegmentArray";
  if (id == 0x000000C9) return "MmUnmapIoSpace";
  if (id == 0x000000CA) return "Nls844UnicodeCaseTable";
  if (id == 0x000000CB) return "NtAllocateVirtualMemory";
  if (id == 0x000000CC) return "NtCancelTimer";
  if (id == 0x000000CD) return "NtClearEvent";
  if (id == 0x000000CE) return "NtClose";
  if (id == 0x000000CF) return "NtCreateDirectoryObject";
  if (id == 0x000000D0) return "NtCreateEvent";
  if (id == 0x000000D1) return "NtCreateFile";
  if (id == 0x000000D2) return "NtCreateIoCompletion";
  if (id == 0x000000D3) return "NtCreateMutant";
  if (id == 0x000000D4) return "NtCreateSemaphore";
  if (id == 0x000000D5) return "NtCreateSymbolicLinkObject";
  if (id == 0x000000D6) return "NtCreateTimer";
  if (id == 0x000000D7) return "NtDeleteFile";
  if (id == 0x000000D8) return "NtDeviceIoControlFile";
  if (id == 0x000000D9) return "NtDuplicateObject";
  if (id == 0x000000DA) return "NtFlushBuffersFile";
  if (id == 0x000000DB) return "NtFreeVirtualMemory";
  if (id == 0x000000DC) return "NtMakeTemporaryObject";
  if (id == 0x000000DD) return "NtOpenDirectoryObject";
  if (id == 0x000000DE) return "NtOpenFile";
  if (id == 0x000000DF) return "NtOpenSymbolicLinkObject";
  if (id == 0x000000E0) return "NtProtectVirtualMemory";
  if (id == 0x000000E1) return "NtPulseEvent";
  if (id == 0x000000E2) return "NtQueueApcThread";
  if (id == 0x000000E3) return "NtQueryDirectoryFile";
  if (id == 0x000000E4) return "NtQueryDirectoryObject";
  if (id == 0x000000E5) return "NtQueryEvent";
  if (id == 0x000000E6) return "NtQueryFullAttributesFile";
  if (id == 0x000000E7) return "NtQueryInformationFile";
  if (id == 0x000000E8) return "NtQueryIoCompletion";
  if (id == 0x000000E9) return "NtQueryMutant";
  if (id == 0x000000EA) return "NtQuerySemaphore";
  if (id == 0x000000EB) return "NtQuerySymbolicLinkObject";
  if (id == 0x000000EC) return "NtQueryTimer";
  if (id == 0x000000ED) return "NtQueryVirtualMemory";
  if (id == 0x000000EE) return "NtQueryVolumeInformationFile";
  if (id == 0x000000EF) return "NtReadFile";
  if (id == 0x000000F0) return "NtReadFileScatter";
  if (id == 0x000000F1) return "NtReleaseMutant";
  if (id == 0x000000F2) return "NtReleaseSemaphore";
  if (id == 0x000000F3) return "NtRemoveIoCompletion";
  if (id == 0x000000F4) return "NtResumeThread";
  if (id == 0x000000F5) return "NtSetEvent";
  if (id == 0x000000F6) return "NtSetInformationFile";
  if (id == 0x000000F7) return "NtSetIoCompletion";
  if (id == 0x000000F8) return "NtSetSystemTime";
  if (id == 0x000000F9) return "NtSetTimerEx";
  if (id == 0x000000FA) return "NtSignalAndWaitForSingleObjectEx";
  if (id == 0x000000FB) return "NtSuspendThread";
  if (id == 0x000000FC) return "NtWaitForSingleObjectEx";
  if (id == 0x000000FD) return "NtWaitForMultipleObjectsEx";
  if (id == 0x000000FE) return "NtWriteFile";
  if (id == 0x000000FF) return "NtWriteFileGather";
  if (id == 0x00000100) return "NtYieldExecution";
  if (id == 0x00000101) return "ObCreateObject";
  if (id == 0x00000102) return "ObCreateSymbolicLink";
  if (id == 0x00000103) return "ObDeleteSymbolicLink";
  if (id == 0x00000104) return "ObDereferenceObject";
  if (id == 0x00000105) return "ObDirectoryObjectType";
  if (id == 0x00000106) return "ObGetWaitableObject";
  if (id == 0x00000107) return "ObInsertObject";
  if (id == 0x00000108) return "ObIsTitleObject";
  if (id == 0x00000109) return "ObLookupAnyThreadByThreadId";
  if (id == 0x0000010A) return "ObLookupThreadByThreadId";
  if (id == 0x0000010B) return "ObMakeTemporaryObject";
  if (id == 0x0000010C) return "ObOpenObjectByName";
  if (id == 0x0000010D) return "ObOpenObjectByPointer";
  if (id == 0x0000010E) return "ObReferenceObject";
  if (id == 0x0000010F) return "ObReferenceObjectByHandle";
  if (id == 0x00000110) return "ObReferenceObjectByName";
  if (id == 0x00000111) return "ObSymbolicLinkObjectType";
  if (id == 0x00000112) return "ObTranslateSymbolicLink";
  if (id == 0x00000113) return "RtlAnsiStringToUnicodeString";
  if (id == 0x00000114) return "RtlAppendStringToString";
  if (id == 0x00000115) return "RtlAppendUnicodeStringToString";
  if (id == 0x00000116) return "RtlAppendUnicodeToString";
  if (id == 0x00000117) return "RtlAssert";
  if (id == 0x00000118) return "RtlCaptureContext";
  if (id == 0x00000119) return "RtlCompareMemory";
  if (id == 0x0000011A) return "RtlCompareMemoryUlong";
  if (id == 0x0000011B) return "RtlCompareString";
  if (id == 0x0000011C) return "RtlCompareStringN";
  if (id == 0x0000011D) return "RtlCompareUnicodeString";
  if (id == 0x0000011E) return "RtlCompareUnicodeStringN";
  if (id == 0x0000011F) return "RtlCompareUtf8ToUnicode";
  if (id == 0x00000120) return "RtlCopyString";
  if (id == 0x00000121) return "RtlCopyUnicodeString";
  if (id == 0x00000122) return "RtlCreateUnicodeString";
  if (id == 0x00000123) return "RtlDowncaseUnicodeChar";
  if (id == 0x00000124) return "RtlEnterCriticalSection";
  if (id == 0x00000125) return "RtlFillMemoryUlong";
  if (id == 0x00000126) return "RtlFreeAnsiString";
  if (id == 0x00000127) return "RtlFreeAnsiString";
  if (id == 0x00000128) return "RtlGetCallersAddress";
  if (id == 0x00000129) return "RtlGetStackLimits";
  if (id == 0x0000012A) return "RtlImageXexHeaderField";
  if (id == 0x0000012B) return "RtlInitAnsiString";
  if (id == 0x0000012C) return "RtlInitUnicodeString";
  if (id == 0x0000012D) return "RtlInitializeCriticalSection";
  if (id == 0x0000012E) return "RtlInitializeCriticalSectionAndSpinCount";
  if (id == 0x0000012F) return "RtlLeaveCriticalSection";
  if (id == 0x00000130) return "RtlLookupFunctionEntry";
  if (id == 0x00000131) return "RtlLowerChar";
  if (id == 0x00000132) return "RtlMultiByteToUnicodeN";
  if (id == 0x00000133) return "RtlMultiByteToUnicodeSize";
  if (id == 0x00000134) return "RtlNtStatusToDosError";
  if (id == 0x00000135) return "RtlRaiseException";
  if (id == 0x00000136) return "RtlRaiseStatus";
  if (id == 0x00000137) return "RtlRip";
  if (id == 0x00000138) return "_scprintf";
  if (id == 0x00000139) return "_snprintf";
  if (id == 0x0000013A) return "sprintf";
  if (id == 0x0000013B) return "_scwprintf";
  if (id == 0x0000013C) return "_snwprintf";
  if (id == 0x0000013D) return "_swprintf";
  if (id == 0x0000013E) return "RtlTimeFieldsToTime";
  if (id == 0x0000013F) return "RtlTimeToTimeFields";
  if (id == 0x00000140) return "RtlTryEnterCriticalSection";
  if (id == 0x00000141) return "RtlUnicodeStringToAnsiString";
  if (id == 0x00000142) return "RtlUnicodeToMultiByteN";
  if (id == 0x00000143) return "RtlUnicodeToMultiByteSize";
  if (id == 0x00000144) return "RtlUnicodeToUtf8";
  if (id == 0x00000145) return "RtlUnicodeToUtf8Size";
  if (id == 0x00000146) return "RtlUnwind";
  if (id == 0x00000147) return "RtlUnwind2";
  if (id == 0x00000148) return "RtlUpcaseUnicodeChar";
  if (id == 0x00000149) return "RtlUpperChar";
  if (id == 0x0000014A) return "RtlVirtualUnwind";
  if (id == 0x0000014B) return "_vscprintf";
  if (id == 0x0000014C) return "_vsnprintf";
  if (id == 0x0000014D) return "vsprintf";
  if (id == 0x0000014E) return "_vscwprintf";
  if (id == 0x0000014F) return "_vsnwprintf";
  if (id == 0x00000150) return "_vswprintf";
  if (id == 0x00000151) return "SfcWriteLogical";
  if (id == 0x00000152) return "TlsAlloc";
  if (id == 0x00000153) return "TlsFree";
  if (id == 0x00000154) return "TlsGetValue";
  if (id == 0x00000155) return "TlsSetValue";
  if (id == 0x00000156) return "XboxHardwareInfo";
  if (id == 0x00000157) return "XboxKrnlVersion";
  if (id == 0x00000158) return "XeCryptAesKey";
  if (id == 0x00000159) return "XeCryptAesEcb";
  if (id == 0x0000015A) return "XeCryptAesCbc";
  if (id == 0x0000015B) return "XeCryptBnDwLeDhEqualBase";
  if (id == 0x0000015C) return "XeCryptBnDwLeDhInvalBase";
  if (id == 0x0000015D) return "XeCryptBnDwLeDhModExp";
  if (id == 0x0000015E) return "XeCryptBnDw_Copy";
  if (id == 0x0000015F) return "XeCryptBnDw_SwapLeBe";
  if (id == 0x00000160) return "XeCryptBnDw_Zero";
  if (id == 0x00000161) return "XeCryptBnDwLePkcs1Format";
  if (id == 0x00000162) return "XeCryptBnDwLePkcs1Verify";
  if (id == 0x00000163) return "XeCryptBnQwBeSigCreate";
  if (id == 0x00000164) return "XeCryptBnQwBeSigFormat";
  if (id == 0x00000165) return "XeCryptBnQwBeSigVerify";
  if (id == 0x00000167) return "XeCryptBnQwNeModExp";
  if (id == 0x00000168) return "XeCryptBnQwNeModExpRoot";
  if (id == 0x00000169) return "XeCryptBnQwNeModInv";
  if (id == 0x0000016A) return "XeCryptBnQwNeModMul";
  if (id == 0x0000016B) return "XeCryptBnQwNeRsaKeyGen";
  if (id == 0x0000016C) return "XeCryptBnQwNeRsaPrvCrypt";
  if (id == 0x0000016D) return "XeCryptBnQwNeRsaPubCrypt";
  if (id == 0x0000016E) return "XeCryptBnQw_Copy";
  if (id == 0x0000016F) return "XeCryptBnQw_SwapDwQw";
  if (id == 0x00000170) return "XeCryptBnQw_SwapDwQwLeBe";
  if (id == 0x00000171) return "XeCryptBnQw_SwapLeBe";
  if (id == 0x00000172) return "XeCryptBnQw_Zero";
  if (id == 0x00000173) return "XeCryptChainAndSumMac";
  if (id == 0x00000174) return "XeCryptDesParity";
  if (id == 0x00000175) return "XeCryptDesKey";
  if (id == 0x00000176) return "XeCryptDesEcb";
  if (id == 0x00000177) return "XeCryptDesCbc";
  if (id == 0x00000178) return "XeCryptDes3Key";
  if (id == 0x00000179) return "XeCryptDes3Ecb";
  if (id == 0x0000017A) return "XeCryptDes3Cbc";
  if (id == 0x0000017B) return "XeCryptHmacMd5Init";
  if (id == 0x0000017C) return "XeCryptHmacMd5Update";
  if (id == 0x0000017D) return "XeCryptHmacMd5Final";
  if (id == 0x0000017E) return "XeCryptHmacMd5";
  if (id == 0x0000017F) return "XeCryptHmacShaInit";
  if (id == 0x00000180) return "XeCryptHmacShaUpdate";
  if (id == 0x00000181) return "XeCryptHmacShaFinal";
  if (id == 0x00000182) return "XeCryptHmacSha";
  if (id == 0x00000183) return "XeCryptHmacShaVerify";
  if (id == 0x00000184) return "XeCryptMd5Init";
  if (id == 0x00000185) return "XeCryptMd5Update";
  if (id == 0x00000186) return "XeCryptMd5Final";
  if (id == 0x00000187) return "XeCryptMd5";
  if (id == 0x00000188) return "XeCryptParveEcb";
  if (id == 0x00000189) return "XeCryptParveCbcMac";
  if (id == 0x0000018A) return "XeCryptRandom";
  if (id == 0x0000018B) return "XeCryptRc4Key";
  if (id == 0x0000018C) return "XeCryptRc4Ecb";
  if (id == 0x0000018D) return "XeCryptRc4";
  if (id == 0x0000018E) return "XeCryptShaInit";
  if (id == 0x0000018F) return "XeCryptShaUpdate";
  if (id == 0x00000190) return "XeCryptShaFinal";
  if (id == 0x00000191) return "XeCryptSha";
  if (id == 0x00000192) return "XexExecutableModuleHandle";
  if (id == 0x00000193) return "XexCheckExecutablePrivilege";
  if (id == 0x00000194) return "XexGetModuleHandle";
  if (id == 0x00000195) return "XexGetModuleSection";
  if (id == 0x00000196) return "XexGetProcedureAddress";
  if (id == 0x00000197) return "XexLoadExecutable";
  if (id == 0x00000198) return "XexLoadImage";
  if (id == 0x00000199) return "XexLoadImageFromMemory";
  if (id == 0x0000019A) return "XexLoadImageHeaders";
  if (id == 0x0000019B) return "XexPcToFileHeader";
  if (id == 0x0000019C) return "XexRegisterLoader";
  if (id == 0x0000019D) return "XexRegisterPatchDescriptor";
  if (id == 0x0000019E) return "XexSendDeferredNotifications";
  if (id == 0x0000019F) return "XexStartExecutable";
  if (id == 0x000001A0) return "XexUnloadImage";
  if (id == 0x000001A1) return "XexUnloadImageAndExitThread";
  if (id == 0x000001A2) return "XexUnloadTitleModules";
  if (id == 0x000001A3) return "XexVerifyImageHeaders";
  if (id == 0x000001A4) return "__C_specific_handler";
  if (id == 0x000001A5) return "DbgLoadImageSymbols";
  if (id == 0x000001A6) return "DbgUnLoadImageSymbols";
  if (id == 0x000001A7) return "RtlImageDirectoryEntryToData";
  if (id == 0x000001A8) return "RtlImageNtHeader";
  if (id == 0x000001A9) return "ExDebugMonitorService";
  if (id == 0x000001AA) return "MmDbgReadCheck";
  if (id == 0x000001AB) return "MmDbgReleaseAddress";
  if (id == 0x000001AC) return "MmDbgWriteCheck";
  if (id == 0x000001AD) return "ExLoadedCommandLine";
  if (id == 0x000001AE) return "ExLoadedImageName";
  if (id == 0x000001AF) return "VdBlockUntilGUIIdle";
  if (id == 0x000001B0) return "VdCallGraphicsNotificationRoutines";
  if (id == 0x000001B1) return "VdDisplayFatalError";
  if (id == 0x000001B3) return "VdEnableClosedCaption";
  if (id == 0x000001B4) return "VdEnableDisablePowerSavingMode";
  if (id == 0x000001B5) return "VdEnableRingBufferRPtrWriteBack";
  if (id == 0x000001B6) return "VdGenerateGPUCSCCoefficients";
  if (id == 0x000001B7) return "VdGetClosedCaptionReadyStatus";
  if (id == 0x000001B8) return "VdGetCurrentDisplayGamma";
  if (id == 0x000001B9) return "VdGetCurrentDisplayInformation";
  if (id == 0x000001BA) return "VdGetDefaultMEInitCommand";
  if (id == 0x000001BB) return "VdGetDisplayModeOverride";
  if (id == 0x000001BC) return "VdGetGraphicsAsicID";
  if (id == 0x000001BD) return "VdGetSystemCommandBuffer";
  if (id == 0x000001BE) return "VdGlobalDevice";
  if (id == 0x000001BF) return "VdHSIOCalibrationLock";
  if (id == 0x000001C0) return "VdInitializeEngines";
  if (id == 0x000001C1) return "VdInitializeRingBuffer";
  if (id == 0x000001C2) return "VdInitializeScaler";
  if (id == 0x000001C3) return "VdInitializeScalerCommandBuffer";
  if (id == 0x000001C4) return "VdIsHSIOTrainingSucceeded";
  if (id == 0x000001C5) return "VdPersistDisplay";
  if (id == 0x000001C6) return "VdQuerySystemCommandBuffer";
  if (id == 0x000001C7) return "VdQueryVideoFlags";
  if (id == 0x000001C8) return "VdQueryVideoMode";
  if (id == 0x000001C9) return "VdReadDVERegisterUlong";
  if (id == 0x000001CA) return "VdReadWriteHSIOCalibrationFlag";
  if (id == 0x000001CB) return "VdRegisterGraphicsNotification";
  if (id == 0x000001CC) return "VdSendClosedCaptionData";
  if (id == 0x000001CD) return "VdSetCGMSOption";
  if (id == 0x000001CE) return "VdSetColorProfileAdjustment";
  if (id == 0x000001CF) return "VdSetDisplayMode";
  if (id == 0x000001D0) return "VdSetDisplayModeOverride";
  if (id == 0x000001D1) return "VdSetGraphicsInterruptCallback";
  if (id == 0x000001D2) return "VdSetMacrovisionOption";
  if (id == 0x000001D3) return "VdSetSystemCommandBuffer";
  if (id == 0x000001D4) return "VdSetSystemCommandBufferGpuIdentifierAddress";
  if (id == 0x000001D5) return "VdSetWSSData";
  if (id == 0x000001D6) return "VdSetWSSOption";
  if (id == 0x000001D7) return "VdShutdownEngines";
  if (id == 0x000001D8) return "VdTurnDisplayOff";
  if (id == 0x000001D9) return "VdTurnDisplayOn";
  if (id == 0x000001DA) return "VdWriteDVERegisterUlong";
  if (id == 0x000001DB) return "KiApcNormalRoutineNop";
  if (id == 0x000001DC) return "XVoicedSubmitPacket";
  if (id == 0x000001DD) return "XVoicedClose";
  if (id == 0x000001DE) return "XVoicedActivate";
  if (id == 0x000001DF) return "XInputdGetCapabilities";
  if (id == 0x000001E0) return "XInputdReadState";
  if (id == 0x000001E1) return "XInputdWriteState";
  if (id == 0x000001E2) return "XInputdNotify";
  if (id == 0x000001E3) return "XInputdRawState";
  if (id == 0x000001E4) return "HidGetCapabilities";
  if (id == 0x000001E5) return "HidReadKeys";
  if (id == 0x000001E6) return "XInputdGetDeviceStats";
  if (id == 0x000001E7) return "XInputdResetDevice";
  if (id == 0x000001E8) return "XInputdSetRingOfLight";
  if (id == 0x000001E9) return "XAudioRenderDriverInitialize";
  if (id == 0x000001EA) return "XAudioRegisterRenderDriverClient";
  if (id == 0x000001EB) return "XAudioUnregisterRenderDriverClient";
  if (id == 0x000001EC) return "XAudioSubmitRenderDriverFrame";
  if (id == 0x000001ED) return "XAudioRenderDriverLock";
  if (id == 0x000001EE) return "XAudioGetVoiceCategoryVolumeChangeMask";
  if (id == 0x000001EF) return "XAudioGetVoiceCategoryVolume";
  if (id == 0x000001F0) return "XAudioSetVoiceCategoryVolume";
  if (id == 0x000001F1) return "XAudioBeginDigitalBypassMode";
  if (id == 0x000001F2) return "XAudioEndDigitalBypassMode";
  if (id == 0x000001F3) return "XAudioSubmitDigitalPacket";
  if (id == 0x000001F4) return "XAudioQueryDriverPerformance";
  if (id == 0x000001F5) return "XAudioGetRenderDriverThread";
  if (id == 0x000001F6) return "NicSetUnicastAddress";
  if (id == 0x000001F7) return "NicAttach";
  if (id == 0x000001F8) return "NicDetach";
  if (id == 0x000001F9) return "NicXmit";
  if (id == 0x000001FA) return "NicUpdateMcastMembership";
  if (id == 0x000001FB) return "NicFlushXmitQueue";
  if (id == 0x000001FC) return "NicShutdown";
  if (id == 0x000001FD) return "NicGetLinkState";
  if (id == 0x000001FE) return "NicGetStats";
  if (id == 0x000001FF) return "NicGetOpt";
  if (id == 0x00000200) return "NicSetOpt";
  if (id == 0x00000201) return "DrvSetSysReqCallback";
  if (id == 0x00000202) return "DrvSetUserBindingCallback";
  if (id == 0x00000203) return "DrvSetContentStorageCallback";
  if (id == 0x00000204) return "DrvSetAutobind";
  if (id == 0x00000205) return "DrvGetContentStorageNotification";
  if (id == 0x00000206) return "MtpdBeginTransaction";
  if (id == 0x00000207) return "MtpdCancelTransaction";
  if (id == 0x00000208) return "MtpdEndTransaction";
  if (id == 0x00000209) return "MtpdGetCurrentDevices";
  if (id == 0x0000020A) return "MtpdReadData";
  if (id == 0x0000020B) return "MtpdReadEvent";
  if (id == 0x0000020C) return "MtpdResetDevice";
  if (id == 0x0000020D) return "MtpdSendData";
  if (id == 0x0000020E) return "MtpdVerifyProximity";
  if (id == 0x0000020F) return "XUsbcamSetCaptureMode";
  if (id == 0x00000210) return "XUsbcamGetConfig";
  if (id == 0x00000211) return "XUsbcamSetConfig";
  if (id == 0x00000212) return "XUsbcamGetState";
  if (id == 0x00000213) return "XUsbcamReadFrame";
  if (id == 0x00000214) return "XUsbcamSnapshot";
  if (id == 0x00000215) return "XUsbcamSetView";
  if (id == 0x00000216) return "XUsbcamGetView";
  if (id == 0x00000217) return "XUsbcamCreate";
  if (id == 0x00000218) return "XUsbcamDestroy";
  if (id == 0x00000219) return "XMACreateContext";
  if (id == 0x0000021A) return "XMAInitializeContext";
  if (id == 0x0000021B) return "XMAReleaseContext";
  if (id == 0x0000021C) return "XMAEnableContext";
  if (id == 0x0000021D) return "XMADisableContext";
  if (id == 0x0000021E) return "XMAGetOutputBufferWriteOffset";
  if (id == 0x0000021F) return "XMASetOutputBufferReadOffset";
  if (id == 0x00000220) return "XMAGetOutputBufferReadOffset";
  if (id == 0x00000221) return "XMASetOutputBufferValid";
  if (id == 0x00000222) return "XMAIsOutputBufferValid";
  if (id == 0x00000223) return "XMASetInputBuffer0Valid";
  if (id == 0x00000224) return "XMAIsInputBuffer0Valid";
  if (id == 0x00000225) return "XMASetInputBuffer1Valid";
  if (id == 0x00000226) return "XMAIsInputBuffer1Valid";
  if (id == 0x00000227) return "XMASetInputBuffer0";
  if (id == 0x00000228) return "XMASetInputBuffer1";
  if (id == 0x00000229) return "XMAGetPacketMetadata";
  if (id == 0x0000022A) return "XMABlockWhileInUse";
  if (id == 0x0000022B) return "XMASetLoopData";
  if (id == 0x0000022C) return "XMASetInputBufferReadOffset";
  if (id == 0x0000022D) return "XboxKrnlBaseVersion";
  if (id == 0x0000022E) return "XeKeysSaveKeyVault";
  if (id == 0x0000022F) return "XeKeysGetStatus";
  if (id == 0x00000230) return "XeKeysGeneratePrivateKey";
  if (id == 0x00000231) return "XeKeysGetKeyProperties";
  if (id == 0x00000232) return "XeKeysSetKey";
  if (id == 0x00000233) return "XeKeysGenerateRandomKey";
  if (id == 0x00000234) return "XeKeysGetKey";
  if (id == 0x00000235) return "XeKeysGetDigest";
  if (id == 0x00000236) return "XeKeysGetConsoleID";
  if (id == 0x00000237) return "XeKeysGetConsoleType";
  if (id == 0x00000238) return "XeKeysQwNeRsaPrvCrypt";
  if (id == 0x00000239) return "XeKeysHmacSha";
  if (id == 0x0000023A) return "XeKeysHmacMd5";
  if (id == 0x0000023B) return "XeKeysAesCbc";
  if (id == 0x0000023C) return "XeKeysDes2Cbc";
  if (id == 0x0000023D) return "XeKeysDesCbc";
  if (id == 0x0000023E) return "XeKeysObscureKey";
  if (id == 0x0000023F) return "XeKeysHmacShaUsingKey";
  if (id == 0x00000240) return "XeKeysHmacMd5UsingKey";
  if (id == 0x00000241) return "XeKeysAesCbcUsingKey";
  if (id == 0x00000242) return "XeKeysDes2CbcUsingKey";
  if (id == 0x00000243) return "XeKeysDesCbcUsingKey";
  if (id == 0x00000244) return "XeKeysObfuscate";
  if (id == 0x00000245) return "XeKeysUnObfuscate";
  if (id == 0x00000246) return "XeKeysConsolePrivateKeySign";
  if (id == 0x00000247) return "XeKeysConsoleSignatureVerification";
  if (id == 0x00000248) return "XeKeysSaveEncryptedBootLoader";
  if (id == 0x00000249) return "XAudioGetSpeakerConfig";
  if (id == 0x0000024A) return "XAudioSetSpeakerConfig";
  if (id == 0x0000024B) return "XeKeysInitialize";
  if (id == 0x0000024C) return "XeKeysGetFactoryChallenge";
  if (id == 0x0000024D) return "XeKeysSetFactoryResponse";
  if (id == 0x0000024E) return "XeKeysInitializeFuses";
  if (id == 0x0000024F) return "VdGlobalXamDevice";
  if (id == 0x00000250) return "KeQueryBackgroundProcessors";
  if (id == 0x00000251) return "KeSetBackgroundProcessors";
  if (id == 0x00000252) return "FdfxCreateDevice";
  if (id == 0x00000253) return "FdfxDeleteDevice";
  if (id == 0x00000254) return "VdEnableDisableClockGating";
  if (id == 0x00000255) return "FdfxGetRootDigest";
  if (id == 0x00000256) return "VdSetCscMatricesOverride";
  if (id == 0x00000257) return "XMAGetInputBufferReadOffset";
  if (id == 0x00000258) return "VdRegisterXamGraphicsNotification";
  if (id == 0x0000025A) return "XInputdSetRFPowerMode";
  if (id == 0x0000025B) return "XInputdSetRadioFrequency";

  return nullptr;
}

const char* xboxkrnlNameGen_1838(int id)
{
  if (id == 0x00000001) return "DbgBreakPoint";
  if (id == 0x00000002) return "DbgBreakPointWithStatus";
  if (id == 0x00000003) return "DbgPrint";
  if (id == 0x00000004) return "DbgPrompt";
  if (id == 0x00000005) return "DumpGetRawDumpInfo";
  if (id == 0x00000006) return "DumpWriteDump";
  if (id == 0x00000007) return "ExAcquireReadWriteLockExclusive";
  if (id == 0x00000008) return "ExAcquireReadWriteLockShared";
  if (id == 0x00000009) return "ExAllocatePool";
  if (id == 0x0000000A) return "ExAllocatePoolWithTag";
  if (id == 0x0000000B) return "ExAllocatePoolTypeWithTag";
  if (id == 0x0000000C) return "ExConsoleGameRegion";
  if (id == 0x0000000D) return "ExCreateThread";
  if (id == 0x0000000E) return "ExEventObjectType";
  if (id == 0x0000000F) return "ExFreePool";
  if (id == 0x00000010) return "ExGetXConfigSetting";
  if (id == 0x00000011) return "ExInitializeReadWriteLock";
  if (id == 0x00000012) return "ExMutantObjectType";
  if (id == 0x00000013) return "ExQueryPoolBlockSize";
  if (id == 0x00000014) return "ExRegisterThreadNotification";
  if (id == 0x00000015) return "ExRegisterTitleTerminateNotification";
  if (id == 0x00000016) return "ExReleaseReadWriteLock";
  if (id == 0x00000017) return "ExSemaphoreObjectType";
  if (id == 0x00000018) return "ExSetXConfigSetting";
  if (id == 0x00000019) return "ExTerminateThread";
  if (id == 0x0000001A) return "ExTerminateTitleProcess";
  if (id == 0x0000001B) return "ExThreadObjectType";
  if (id == 0x0000001C) return "ExTimerObjectType";
  if (id == 0x00000020) return "FscGetCacheElementCount";
  if (id == 0x00000021) return "FscSetCacheElementCount";
  if (id == 0x00000022) return "HalGetCurrentAVPack";
  if (id == 0x00000023) return "HalGpioControl";
  if (id == 0x00000024) return "HalOpenCloseODDTray";
  if (id == 0x00000025) return "HalReadWritePCISpace";
  if (id == 0x00000026) return "HalRegisterShutdownNotification";
  if (id == 0x00000027) return "HalRegisterSMCNotification";
  if (id == 0x00000028) return "HalReturnToFirmware";
  if (id == 0x00000029) return "HalSendSMCMessage";
  if (id == 0x0000002A) return "HalSetAudioEnable";
  if (id == 0x0000002B) return "InterlockedFlushSList";
  if (id == 0x0000002C) return "InterlockedPopEntrySList";
  if (id == 0x0000002D) return "InterlockedPushEntrySList";
  if (id == 0x0000002E) return "IoAcquireDeviceObjectLock";
  if (id == 0x0000002F) return "IoAllocateIrp";
  if (id == 0x00000030) return "IoBuildAsynchronousFsdRequest";
  if (id == 0x00000031) return "IoBuildDeviceIoControlRequest";
  if (id == 0x00000032) return "IoBuildSynchronousFsdRequest";
  if (id == 0x00000033) return "IoCallDriver";
  if (id == 0x00000034) return "IoCheckShareAccess";
  if (id == 0x00000035) return "IoCompleteRequest";
  if (id == 0x00000036) return "IoCompletionObjectType";
  if (id == 0x00000037) return "IoCreateDevice";
  if (id == 0x00000038) return "IoCreateFile";
  if (id == 0x00000039) return "IoDeleteDevice";
  if (id == 0x0000003A) return "IoDeviceObjectType";
  if (id == 0x0000003B) return "IoDismountVolume";
  if (id == 0x0000003C) return "IoDismountVolumeByFileHandle";
  if (id == 0x0000003D) return "IoDismountVolumeByName";
  if (id == 0x0000003E) return "IoFileObjectType";
  if (id == 0x0000003F) return "IoFreeIrp";
  if (id == 0x00000040) return "IoInitializeIrp";
  if (id == 0x00000041) return "IoInvalidDeviceRequest";
  if (id == 0x00000042) return "KiApcNormalRoutineNop";
  if (id == 0x00000043) return "IoQueueThreadIrp";
  if (id == 0x00000044) return "IoReleaseDeviceObjectLock";
  if (id == 0x00000045) return "IoRemoveShareAccess";
  if (id == 0x00000046) return "IoSetIoCompletion";
  if (id == 0x00000047) return "IoSetShareAccess";
  if (id == 0x00000048) return "IoStartNextPacket";
  if (id == 0x00000049) return "IoStartNextPacketByKey";
  if (id == 0x0000004A) return "IoStartPacket";
  if (id == 0x0000004B) return "IoSynchronousDeviceIoControlRequest";
  if (id == 0x0000004C) return "IoSynchronousFsdRequest";
  if (id == 0x0000004D) return "KeAcquireSpinLockAtRaisedIrql";
  if (id == 0x0000004E) return "KeAlertResumeThread";
  if (id == 0x0000004F) return "KeAlertThread";
  if (id == 0x00000050) return "KeBlowFuses";
  if (id == 0x00000051) return "KeBoostPriorityThread";
  if (id == 0x00000052) return "KeBugCheck";
  if (id == 0x00000053) return "KeBugCheckEx";
  if (id == 0x00000054) return "KeCancelTimer";
  if (id == 0x00000055) return "KeConnectInterrupt";
  if (id == 0x00000056) return "KeContextFromKframes";
  if (id == 0x00000057) return "KeContextToKframes";
  if (id == 0x00000058) return "KeCreateUserMode";
  if (id == 0x00000059) return "KeDebugMonitorData";
  if (id == 0x0000005A) return "KeDelayExecutionThread";
  if (id == 0x0000005B) return "KeDeleteUserMode";
  if (id == 0x0000005C) return "KeDisconnectInterrupt";
  if (id == 0x0000005D) return "KeEnableFpuExceptions";
  if (id == 0x0000005E) return "KeEnablePPUPerformanceMonitor";
  if (id == 0x0000005F) return "KeEnterCriticalRegion";
  if (id == 0x00000060) return "KeEnterUserMode";
  if (id == 0x00000061) return "KeFlushCacheRange";
  if (id == 0x00000062) return "KeFlushCurrentEntireTb";
  if (id == 0x00000063) return "KeFlushEntireTb";
  if (id == 0x00000064) return "KeFlushUserModeCurrentTb";
  if (id == 0x00000065) return "KeFlushUserModeTb";
  if (id == 0x00000066) return "KeGetCurrentProcessType";
  if (id == 0x00000067) return "KeGetPMWRegister";
  if (id == 0x00000068) return "KeGetPRVRegister";
  if (id == 0x00000069) return "KeGetSocRegister";
  if (id == 0x0000006A) return "KeGetSpecialPurposeRegister";
  if (id == 0x0000006B) return "KeLockL2";
  if (id == 0x0000006C) return "KeUnlockL2";
  if (id == 0x0000006D) return "KeInitializeApc";
  if (id == 0x0000006E) return "KeInitializeDeviceQueue";
  if (id == 0x0000006F) return "KeInitializeDpc";
  if (id == 0x00000070) return "KeInitializeEvent";
  if (id == 0x00000071) return "KeInitializeInterrupt";
  if (id == 0x00000072) return "KeInitializeMutant";
  if (id == 0x00000073) return "KeInitializeQueue";
  if (id == 0x00000074) return "KeInitializeSemaphore";
  if (id == 0x00000075) return "KeInitializeTimerEx";
  if (id == 0x00000076) return "KeInsertByKeyDeviceQueue";
  if (id == 0x00000077) return "KeInsertDeviceQueue";
  if (id == 0x00000078) return "KeInsertHeadQueue";
  if (id == 0x00000079) return "KeInsertQueue";
  if (id == 0x0000007A) return "KeInsertQueueApc";
  if (id == 0x0000007B) return "KeInsertQueueDpc";
  if (id == 0x0000007C) return "KeIpiGenericCall";
  if (id == 0x0000007D) return "KeLeaveCriticalRegion";
  if (id == 0x0000007E) return "KeLeaveUserMode";
  if (id == 0x0000007F) return "KePulseEvent";
  if (id == 0x00000080) return "KeQueryBackgroundProcessors";
  if (id == 0x00000081) return "KeQueryBasePriorityThread";
  if (id == 0x00000082) return "KeQueryInterruptTime";
  if (id == 0x00000083) return "KeQueryPerformanceFrequency";
  if (id == 0x00000084) return "KeQuerySystemTime";
  if (id == 0x00000085) return "KeRaiseIrqlToDpcLevel";
  if (id == 0x00000086) return "KeRegisterDriverNotification";
  if (id == 0x00000087) return "KeReleaseMutant";
  if (id == 0x00000088) return "KeReleaseSemaphore";
  if (id == 0x00000089) return "KeReleaseSpinLockFromRaisedIrql";
  if (id == 0x0000008A) return "KeRemoveByKeyDeviceQueue";
  if (id == 0x0000008B) return "KeRemoveDeviceQueue";
  if (id == 0x0000008C) return "KeRemoveEntryDeviceQueue";
  if (id == 0x0000008D) return "KeRemoveQueue";
  if (id == 0x0000008E) return "KeRemoveQueueDpc";
  if (id == 0x0000008F) return "KeResetEvent";
  if (id == 0x00000090) return "KeRestoreFloatingPointState";
  if (id == 0x00000091) return "KeRestoreVectorUnitState";
  if (id == 0x00000092) return "KeResumeThread";
  if (id == 0x00000093) return "KeRetireDpcList";
  if (id == 0x00000094) return "KeRundownQueue";
  if (id == 0x00000095) return "KeSaveFloatingPointState";
  if (id == 0x00000096) return "KeSaveVectorUnitState";
  if (id == 0x00000097) return "KeSetAffinityThread";
  if (id == 0x00000098) return "KeSetBackgroundProcessors";
  if (id == 0x00000099) return "KeSetBasePriorityThread";
  if (id == 0x0000009A) return "KeSetCurrentProcessType";
  if (id == 0x0000009B) return "KeSetCurrentStackPointers";
  if (id == 0x0000009C) return "KeSetDisableBoostThread";
  if (id == 0x0000009D) return "KeSetEvent";
  if (id == 0x0000009E) return "KeSetEventBoostPriority";
  if (id == 0x0000009F) return "KeSetPMWRegister";
  if (id == 0x000000A0) return "KeSetPowerMode";
  if (id == 0x000000A1) return "KeSetPRVRegister";
  if (id == 0x000000A2) return "KeSetPriorityClassThread";
  if (id == 0x000000A3) return "KeSetPriorityThread";
  if (id == 0x000000A4) return "KeSetSocRegister";
  if (id == 0x000000A5) return "KeSetSpecialPurposeRegister";
  if (id == 0x000000A6) return "KeSetTimer";
  if (id == 0x000000A7) return "KeSetTimerEx";
  if (id == 0x000000A8) return "KeStallExecutionProcessor";
  if (id == 0x000000A9) return "KeSuspendThread";
  if (id == 0x000000AA) return "KeSweepDcacheRange";
  if (id == 0x000000AB) return "KeSweepIcacheRange";
  if (id == 0x000000AC) return "KeTestAlertThread";
  if (id == 0x000000AD) return "KeTimeStampBundle";
  if (id == 0x000000AE) return "KeTryToAcquireSpinLockAtRaisedIrql";
  if (id == 0x000000AF) return "KeWaitForMultipleObjects";
  if (id == 0x000000B0) return "KeWaitForSingleObject";
  if (id == 0x000000B1) return "KfAcquireSpinLock";
  if (id == 0x000000B2) return "KfRaiseIrql";
  if (id == 0x000000B3) return "KfLowerIrql";
  if (id == 0x000000B4) return "KfReleaseSpinLock";
  if (id == 0x000000B5) return "KiBugCheckData";
  if (id == 0x000000B6) return "LDICreateDecompression";
  if (id == 0x000000B7) return "LDIDecompress";
  if (id == 0x000000B8) return "LDIDestroyDecompression";
  if (id == 0x000000B9) return "MmAllocatePhysicalMemory";
  if (id == 0x000000BA) return "MmAllocatePhysicalMemoryEx";
  if (id == 0x000000BB) return "MmCreateKernelStack";
  if (id == 0x000000BC) return "MmDeleteKernelStack";
  if (id == 0x000000BD) return "MmFreePhysicalMemory";
  if (id == 0x000000BE) return "MmGetPhysicalAddress";
  if (id == 0x000000BF) return "MmIsAddressValid";
  if (id == 0x000000C0) return "MmLockAndMapSegmentArray";
  if (id == 0x000000C1) return "MmLockUnlockBufferPages";
  if (id == 0x000000C2) return "MmMapIoSpace";
  if (id == 0x000000C3) return "MmPersistPhysicalMemoryAllocation";
  if (id == 0x000000C4) return "MmQueryAddressProtect";
  if (id == 0x000000C5) return "MmQueryAllocationSize";
  if (id == 0x000000C6) return "MmQueryStatistics";
  if (id == 0x000000C7) return "MmSetAddressProtect";
  if (id == 0x000000C8) return "MmSplitPhysicalMemoryAllocation";
  if (id == 0x000000C9) return "MmUnlockAndUnmapSegmentArray";
  if (id == 0x000000CA) return "MmUnmapIoSpace";
  if (id == 0x000000CB) return "Nls844UnicodeCaseTable";
  if (id == 0x000000CC) return "NtAllocateVirtualMemory";
  if (id == 0x000000CD) return "NtCancelTimer";
  if (id == 0x000000CE) return "NtClearEvent";
  if (id == 0x000000CF) return "NtClose";
  if (id == 0x000000D0) return "NtCreateDirectoryObject";
  if (id == 0x000000D1) return "NtCreateEvent";
  if (id == 0x000000D2) return "NtCreateFile";
  if (id == 0x000000D3) return "NtCreateIoCompletion";
  if (id == 0x000000D4) return "NtCreateMutant";
  if (id == 0x000000D5) return "NtCreateSemaphore";
  if (id == 0x000000D6) return "NtCreateSymbolicLinkObject";
  if (id == 0x000000D7) return "NtCreateTimer";
  if (id == 0x000000D8) return "NtDeleteFile";
  if (id == 0x000000D9) return "NtDeviceIoControlFile";
  if (id == 0x000000DA) return "NtDuplicateObject";
  if (id == 0x000000DB) return "NtFlushBuffersFile";
  if (id == 0x000000DC) return "NtFreeVirtualMemory";
  if (id == 0x000000DD) return "NtMakeTemporaryObject";
  if (id == 0x000000DE) return "NtOpenDirectoryObject";
  if (id == 0x000000DF) return "NtOpenFile";
  if (id == 0x000000E0) return "NtOpenSymbolicLinkObject";
  if (id == 0x000000E1) return "NtProtectVirtualMemory";
  if (id == 0x000000E2) return "NtPulseEvent";
  if (id == 0x000000E3) return "NtQueueApcThread";
  if (id == 0x000000E4) return "NtQueryDirectoryFile";
  if (id == 0x000000E5) return "NtQueryDirectoryObject";
  if (id == 0x000000E6) return "NtQueryEvent";
  if (id == 0x000000E7) return "NtQueryFullAttributesFile";
  if (id == 0x000000E8) return "NtQueryInformationFile";
  if (id == 0x000000E9) return "NtQueryIoCompletion";
  if (id == 0x000000EA) return "NtQueryMutant";
  if (id == 0x000000EB) return "NtQuerySemaphore";
  if (id == 0x000000EC) return "NtQuerySymbolicLinkObject";
  if (id == 0x000000ED) return "NtQueryTimer";
  if (id == 0x000000EE) return "NtQueryVirtualMemory";
  if (id == 0x000000EF) return "NtQueryVolumeInformationFile";
  if (id == 0x000000F0) return "NtReadFile";
  if (id == 0x000000F1) return "NtReadFileScatter";
  if (id == 0x000000F2) return "NtReleaseMutant";
  if (id == 0x000000F3) return "NtReleaseSemaphore";
  if (id == 0x000000F4) return "NtRemoveIoCompletion";
  if (id == 0x000000F5) return "NtResumeThread";
  if (id == 0x000000F6) return "NtSetEvent";
  if (id == 0x000000F7) return "NtSetInformationFile";
  if (id == 0x000000F8) return "NtSetIoCompletion";
  if (id == 0x000000F9) return "NtSetSystemTime";
  if (id == 0x000000FA) return "NtSetTimerEx";
  if (id == 0x000000FB) return "NtSignalAndWaitForSingleObjectEx";
  if (id == 0x000000FC) return "NtSuspendThread";
  if (id == 0x000000FD) return "NtWaitForSingleObjectEx";
  if (id == 0x000000FE) return "NtWaitForMultipleObjectsEx";
  if (id == 0x000000FF) return "NtWriteFile";
  if (id == 0x00000100) return "NtWriteFileGather";
  if (id == 0x00000101) return "NtYieldExecution";
  if (id == 0x00000102) return "ObCreateObject";
  if (id == 0x00000103) return "ObCreateSymbolicLink";
  if (id == 0x00000104) return "ObDeleteSymbolicLink";
  if (id == 0x00000105) return "ObDereferenceObject";
  if (id == 0x00000106) return "ObDirectoryObjectType";
  if (id == 0x00000107) return "ObGetWaitableObject";
  if (id == 0x00000108) return "ObInsertObject";
  if (id == 0x00000109) return "ObIsTitleObject";
  if (id == 0x0000010A) return "ObLookupAnyThreadByThreadId";
  if (id == 0x0000010B) return "ObLookupThreadByThreadId";
  if (id == 0x0000010C) return "ObMakeTemporaryObject";
  if (id == 0x0000010D) return "ObOpenObjectByName";
  if (id == 0x0000010E) return "ObOpenObjectByPointer";
  if (id == 0x0000010F) return "ObReferenceObject";
  if (id == 0x00000110) return "ObReferenceObjectByHandle";
  if (id == 0x00000111) return "ObReferenceObjectByName";
  if (id == 0x00000112) return "ObSymbolicLinkObjectType";
  if (id == 0x00000113) return "ObTranslateSymbolicLink";
  if (id == 0x00000114) return "RtlAnsiStringToUnicodeString";
  if (id == 0x00000115) return "RtlAppendStringToString";
  if (id == 0x00000116) return "RtlAppendUnicodeStringToString";
  if (id == 0x00000117) return "RtlAppendUnicodeToString";
  if (id == 0x00000118) return "RtlAssert";
  if (id == 0x00000119) return "RtlCaptureContext";
  if (id == 0x0000011A) return "RtlCompareMemory";
  if (id == 0x0000011B) return "RtlCompareMemoryUlong";
  if (id == 0x0000011C) return "RtlCompareString";
  if (id == 0x0000011D) return "RtlCompareStringN";
  if (id == 0x0000011E) return "RtlCompareUnicodeString";
  if (id == 0x0000011F) return "RtlCompareUnicodeStringN";
  if (id == 0x00000120) return "RtlCompareUtf8ToUnicode";
  if (id == 0x00000121) return "RtlCopyString";
  if (id == 0x00000122) return "RtlCopyUnicodeString";
  if (id == 0x00000123) return "RtlCreateUnicodeString";
  if (id == 0x00000124) return "RtlDowncaseUnicodeChar";
  if (id == 0x00000125) return "RtlEnterCriticalSection";
  if (id == 0x00000126) return "RtlFillMemoryUlong";
  if (id == 0x00000127) return "RtlFreeAnsiString";
  if (id == 0x00000128) return "RtlFreeAnsiString";
  if (id == 0x00000129) return "RtlGetCallersAddress";
  if (id == 0x0000012A) return "RtlGetStackLimits";
  if (id == 0x0000012B) return "RtlImageXexHeaderField";
  if (id == 0x0000012C) return "RtlInitAnsiString";
  if (id == 0x0000012D) return "RtlInitUnicodeString";
  if (id == 0x0000012E) return "RtlInitializeCriticalSection";
  if (id == 0x0000012F) return "RtlInitializeCriticalSectionAndSpinCount";
  if (id == 0x00000130) return "RtlLeaveCriticalSection";
  if (id == 0x00000131) return "RtlLookupFunctionEntry";
  if (id == 0x00000132) return "RtlLowerChar";
  if (id == 0x00000133) return "RtlMultiByteToUnicodeN";
  if (id == 0x00000134) return "RtlMultiByteToUnicodeSize";
  if (id == 0x00000135) return "RtlNtStatusToDosError";
  if (id == 0x00000136) return "RtlRaiseException";
  if (id == 0x00000137) return "RtlRaiseStatus";
  if (id == 0x00000138) return "RtlRip";
  if (id == 0x00000139) return "_scprintf";
  if (id == 0x0000013A) return "_snprintf";
  if (id == 0x0000013B) return "sprintf";
  if (id == 0x0000013C) return "_scwprintf";
  if (id == 0x0000013D) return "_snwprintf";
  if (id == 0x0000013E) return "_swprintf";
  if (id == 0x0000013F) return "RtlTimeFieldsToTime";
  if (id == 0x00000140) return "RtlTimeToTimeFields";
  if (id == 0x00000141) return "RtlTryEnterCriticalSection";
  if (id == 0x00000142) return "RtlUnicodeStringToAnsiString";
  if (id == 0x00000143) return "RtlUnicodeToMultiByteN";
  if (id == 0x00000144) return "RtlUnicodeToMultiByteSize";
  if (id == 0x00000145) return "RtlUnicodeToUtf8";
  if (id == 0x00000146) return "RtlUnicodeToUtf8Size";
  if (id == 0x00000147) return "RtlUnwind";
  if (id == 0x00000148) return "RtlUnwind2";
  if (id == 0x00000149) return "RtlUpcaseUnicodeChar";
  if (id == 0x0000014A) return "RtlUpperChar";
  if (id == 0x0000014B) return "RtlVirtualUnwind";
  if (id == 0x0000014C) return "_vscprintf";
  if (id == 0x0000014D) return "_vsnprintf";
  if (id == 0x0000014E) return "vsprintf";
  if (id == 0x0000014F) return "_vscwprintf";
  if (id == 0x00000150) return "_vsnwprintf";
  if (id == 0x00000151) return "_vswprintf";
  if (id == 0x00000152) return "KeTlsAlloc";
  if (id == 0x00000153) return "KeTlsFree";
  if (id == 0x00000154) return "KeTlsGetValue";
  if (id == 0x00000155) return "KeTlsSetValue";
  if (id == 0x00000156) return "XboxHardwareInfo";
  if (id == 0x00000157) return "XboxKrnlBaseVersion";
  if (id == 0x00000158) return "XboxKrnlVersion";
  if (id == 0x00000159) return "XeCryptAesKey";
  if (id == 0x0000015A) return "XeCryptAesEcb";
  if (id == 0x0000015B) return "XeCryptAesCbc";
  if (id == 0x0000015C) return "XeCryptBnDwLeDhEqualBase";
  if (id == 0x0000015D) return "XeCryptBnDwLeDhInvalBase";
  if (id == 0x0000015E) return "XeCryptBnDwLeDhModExp";
  if (id == 0x0000015F) return "XeCryptBnDw_Copy";
  if (id == 0x00000160) return "XeCryptBnDw_SwapLeBe";
  if (id == 0x00000161) return "XeCryptBnDw_Zero";
  if (id == 0x00000162) return "XeCryptBnDwLePkcs1Format";
  if (id == 0x00000163) return "XeCryptBnDwLePkcs1Verify";
  if (id == 0x00000164) return "XeCryptBnQwBeSigCreate";
  if (id == 0x00000165) return "XeCryptBnQwBeSigFormat";
  if (id == 0x00000166) return "XeCryptBnQwBeSigVerify";
  if (id == 0x00000167) return "XeCryptBnQwNeModExp";
  if (id == 0x00000168) return "XeCryptBnQwNeModExpRoot";
  if (id == 0x00000169) return "XeCryptBnQwNeModInv";
  if (id == 0x0000016A) return "XeCryptBnQwNeModMul";
  if (id == 0x0000016B) return "XeCryptBnQwNeRsaKeyGen";
  if (id == 0x0000016C) return "XeCryptBnQwNeRsaPrvCrypt";
  if (id == 0x0000016D) return "XeCryptBnQwNeRsaPubCrypt";
  if (id == 0x0000016E) return "XeCryptBnQw_Copy";
  if (id == 0x0000016F) return "XeCryptBnQw_SwapDwQw";
  if (id == 0x00000170) return "XeCryptBnQw_SwapDwQwLeBe";
  if (id == 0x00000171) return "XeCryptBnQw_SwapLeBe";
  if (id == 0x00000172) return "XeCryptBnQw_Zero";
  if (id == 0x00000173) return "XeCryptChainAndSumMac";
  if (id == 0x00000174) return "XeCryptDesParity";
  if (id == 0x00000175) return "XeCryptDesKey";
  if (id == 0x00000176) return "XeCryptDesEcb";
  if (id == 0x00000177) return "XeCryptDesCbc";
  if (id == 0x00000178) return "XeCryptDes3Key";
  if (id == 0x00000179) return "XeCryptDes3Ecb";
  if (id == 0x0000017A) return "XeCryptDes3Cbc";
  if (id == 0x0000017B) return "XeCryptHmacMd5Init";
  if (id == 0x0000017C) return "XeCryptHmacMd5Update";
  if (id == 0x0000017D) return "XeCryptHmacMd5Final";
  if (id == 0x0000017E) return "XeCryptHmacMd5";
  if (id == 0x0000017F) return "XeCryptHmacShaInit";
  if (id == 0x00000180) return "XeCryptHmacShaUpdate";
  if (id == 0x00000181) return "XeCryptHmacShaFinal";
  if (id == 0x00000182) return "XeCryptHmacSha";
  if (id == 0x00000183) return "XeCryptHmacShaVerify";
  if (id == 0x00000184) return "XeCryptMd5Init";
  if (id == 0x00000185) return "XeCryptMd5Update";
  if (id == 0x00000186) return "XeCryptMd5Final";
  if (id == 0x00000187) return "XeCryptMd5";
  if (id == 0x00000188) return "XeCryptParveEcb";
  if (id == 0x00000189) return "XeCryptParveCbcMac";
  if (id == 0x0000018A) return "XeCryptRandom";
  if (id == 0x0000018B) return "XeCryptRc4Key";
  if (id == 0x0000018C) return "XeCryptRc4Ecb";
  if (id == 0x0000018D) return "XeCryptRc4";
  if (id == 0x0000018E) return "XeCryptRotSumSha";
  if (id == 0x0000018F) return "XeCryptShaInit";
  if (id == 0x00000190) return "XeCryptShaUpdate";
  if (id == 0x00000191) return "XeCryptShaFinal";
  if (id == 0x00000192) return "XeCryptSha";
  if (id == 0x00000193) return "XexExecutableModuleHandle";
  if (id == 0x00000194) return "XexCheckExecutablePrivilege";
  if (id == 0x00000195) return "XexGetModuleHandle";
  if (id == 0x00000196) return "XexGetModuleSection";
  if (id == 0x00000197) return "XexGetProcedureAddress";
  if (id == 0x00000198) return "XexLoadExecutable";
  if (id == 0x00000199) return "XexLoadImage";
  if (id == 0x0000019A) return "XexLoadImageFromMemory";
  if (id == 0x0000019B) return "XexLoadImageHeaders";
  if (id == 0x0000019C) return "XexPcToFileHeader";
  if (id == 0x0000019D) return "XexRegisterLoader";
  if (id == 0x0000019E) return "XexRegisterPatchDescriptor";
  if (id == 0x0000019F) return "XexSendDeferredNotifications";
  if (id == 0x000001A0) return "XexStartExecutable";
  if (id == 0x000001A1) return "XexUnloadImage";
  if (id == 0x000001A2) return "XexUnloadImageAndExitThread";
  if (id == 0x000001A3) return "XexUnloadTitleModules";
  if (id == 0x000001A4) return "XexVerifyImageHeaders";
  if (id == 0x000001A5) return "__C_specific_handler";
  if (id == 0x000001A6) return "DbgLoadImageSymbols";
  if (id == 0x000001A7) return "DbgUnLoadImageSymbols";
  if (id == 0x000001A8) return "RtlImageDirectoryEntryToData";
  if (id == 0x000001A9) return "RtlImageNtHeader";
  if (id == 0x000001AA) return "ExDebugMonitorService";
  if (id == 0x000001AB) return "MmDbgReadCheck";
  if (id == 0x000001AC) return "MmDbgReleaseAddress";
  if (id == 0x000001AD) return "MmDbgWriteCheck";
  if (id == 0x000001AE) return "ExLoadedCommandLine";
  if (id == 0x000001AF) return "ExLoadedImageName";
  if (id == 0x000001B0) return "VdBlockUntilGUIIdle";
  if (id == 0x000001B1) return "VdCallGraphicsNotificationRoutines";
  if (id == 0x000001B2) return "VdDisplayFatalError";
  if (id == 0x000001B3) return "VdEnableClosedCaption";
  if (id == 0x000001B4) return "VdEnableDisableClockGating";
  if (id == 0x000001B5) return "VdEnableDisablePowerSavingMode";
  if (id == 0x000001B6) return "VdEnableRingBufferRPtrWriteBack";
  if (id == 0x000001B7) return "VdGenerateGPUCSCCoefficients";
  if (id == 0x000001B8) return "VdGetClosedCaptionReadyStatus";
  if (id == 0x000001B9) return "VdGetCurrentDisplayGamma";
  if (id == 0x000001BA) return "VdGetCurrentDisplayInformation";
  if (id == 0x000001BB) return "VdGetDisplayModeOverride";
  if (id == 0x000001BC) return "VdGetGraphicsAsicID";
  if (id == 0x000001BD) return "VdGetSystemCommandBuffer";
  if (id == 0x000001BE) return "VdGlobalDevice";
  if (id == 0x000001BF) return "VdGlobalXamDevice";
  if (id == 0x000001C0) return "VdGpuClockInMHz";
  if (id == 0x000001C1) return "VdHSIOCalibrationLock";
  if (id == 0x000001C2) return "VdInitializeEngines";
  if (id == 0x000001C3) return "VdInitializeRingBuffer";
  if (id == 0x000001C4) return "VdInitializeScaler";
  if (id == 0x000001C5) return "VdInitializeScalerCommandBuffer";
  if (id == 0x000001C6) return "VdIsHSIOTrainingSucceeded";
  if (id == 0x000001C7) return "VdPersistDisplay";
  if (id == 0x000001C8) return "VdQuerySystemCommandBuffer";
  if (id == 0x000001C9) return "VdQueryVideoFlags";
  if (id == 0x000001CA) return "VdQueryVideoMode";
  if (id == 0x000001CB) return "VdReadDVERegisterUlong";
  if (id == 0x000001CC) return "VdReadWriteHSIOCalibrationFlag";
  if (id == 0x000001CD) return "VdRegisterGraphicsNotification";
  if (id == 0x000001CE) return "VdRegisterXamGraphicsNotification";
  if (id == 0x000001CF) return "VdSendClosedCaptionData";
  if (id == 0x000001D0) return "VdSetCGMSOption";
  if (id == 0x000001D1) return "VdSetColorProfileAdjustment";
  if (id == 0x000001D2) return "VdSetCscMatricesOverride";
  if (id == 0x000001D3) return "VdSetDisplayMode";
  if (id == 0x000001D4) return "VdSetDisplayModeOverride";
  if (id == 0x000001D5) return "VdSetGraphicsInterruptCallback";
  if (id == 0x000001D6) return "VdSetHDCPOption";
  if (id == 0x000001D7) return "VdSetMacrovisionOption";
  if (id == 0x000001D8) return "VdSetSystemCommandBuffer";
  if (id == 0x000001D9) return "VdSetSystemCommandBufferGpuIdentifierAddress";
  if (id == 0x000001DA) return "VdSetWSSData";
  if (id == 0x000001DB) return "VdSetWSSOption";
  if (id == 0x000001DC) return "VdShutdownEngines";
  if (id == 0x000001DD) return "VdTurnDisplayOff";
  if (id == 0x000001DE) return "VdTurnDisplayOn";
  if (id == 0x000001DF) return "VdVerifyMEInitCommand";
  if (id == 0x000001E0) return "VdWriteDVERegisterUlong";
  if (id == 0x000001E1) return "XVoicedHeadsetPresent";
  if (id == 0x000001E2) return "XVoicedSubmitPacket";
  if (id == 0x000001E3) return "XVoicedClose";
  if (id == 0x000001E4) return "XVoicedActivate";
  if (id == 0x000001E5) return "XInputdGetCapabilities";
  if (id == 0x000001E6) return "XInputdReadState";
  if (id == 0x000001E7) return "XInputdWriteState";
  if (id == 0x000001E8) return "XInputdNotify";
  if (id == 0x000001E9) return "XInputdRawState";
  if (id == 0x000001EA) return "HidGetCapabilities";
  if (id == 0x000001EB) return "HidReadKeys";
  if (id == 0x000001EC) return "XInputdGetDeviceStats";
  if (id == 0x000001ED) return "XInputdResetDevice";
  if (id == 0x000001EE) return "XInputdSetRingOfLight";
  if (id == 0x000001EF) return "XInputdSetRFPowerMode";
  if (id == 0x000001F0) return "XInputdSetRadioFrequency";
  if (id == 0x000001F1) return "HidGetLastInputTime";
  if (id == 0x000001F2) return "XAudioRenderDriverInitialize";
  if (id == 0x000001F3) return "XAudioRegisterRenderDriverClient";
  if (id == 0x000001F4) return "XAudioUnregisterRenderDriverClient";
  if (id == 0x000001F5) return "XAudioSubmitRenderDriverFrame";
  if (id == 0x000001F6) return "XAudioRenderDriverLock";
  if (id == 0x000001F7) return "XAudioGetVoiceCategoryVolumeChangeMask";
  if (id == 0x000001F8) return "XAudioGetVoiceCategoryVolume";
  if (id == 0x000001F9) return "XAudioSetVoiceCategoryVolume";
  if (id == 0x000001FA) return "XAudioBeginDigitalBypassMode";
  if (id == 0x000001FB) return "XAudioEndDigitalBypassMode";
  if (id == 0x000001FC) return "XAudioSubmitDigitalPacket";
  if (id == 0x000001FD) return "XAudioQueryDriverPerformance";
  if (id == 0x000001FE) return "XAudioGetRenderDriverThread";
  if (id == 0x000001FF) return "XAudioGetSpeakerConfig";
  if (id == 0x00000200) return "XAudioSetSpeakerConfig";
  if (id == 0x00000201) return "NicSetUnicastAddress";
  if (id == 0x00000202) return "NicAttach";
  if (id == 0x00000203) return "NicDetach";
  if (id == 0x00000204) return "NicXmit";
  if (id == 0x00000205) return "NicUpdateMcastMembership";
  if (id == 0x00000206) return "NicFlushXmitQueue";
  if (id == 0x00000207) return "NicShutdown";
  if (id == 0x00000208) return "NicGetLinkState";
  if (id == 0x00000209) return "NicGetStats";
  if (id == 0x0000020A) return "NicGetOpt";
  if (id == 0x0000020B) return "NicSetOpt";
  if (id == 0x0000020C) return "DrvSetSysReqCallback";
  if (id == 0x0000020D) return "DrvSetUserBindingCallback";
  if (id == 0x0000020E) return "DrvSetContentStorageCallback";
  if (id == 0x0000020F) return "DrvSetAutobind";
  if (id == 0x00000210) return "DrvGetContentStorageNotification";
  if (id == 0x00000211) return "MtpdBeginTransaction";
  if (id == 0x00000212) return "MtpdCancelTransaction";
  if (id == 0x00000213) return "MtpdEndTransaction";
  if (id == 0x00000214) return "MtpdGetCurrentDevices";
  if (id == 0x00000215) return "MtpdReadData";
  if (id == 0x00000216) return "MtpdReadEvent";
  if (id == 0x00000217) return "MtpdResetDevice";
  if (id == 0x00000218) return "MtpdSendData";
  if (id == 0x00000219) return "MtpdVerifyProximity";
  if (id == 0x0000021A) return "XUsbcamSetCaptureMode";
  if (id == 0x0000021B) return "XUsbcamGetConfig";
  if (id == 0x0000021C) return "XUsbcamSetConfig";
  if (id == 0x0000021D) return "XUsbcamGetState";
  if (id == 0x0000021E) return "XUsbcamReadFrame";
  if (id == 0x0000021F) return "XUsbcamSnapshot";
  if (id == 0x00000220) return "XUsbcamSetView";
  if (id == 0x00000221) return "XUsbcamGetView";
  if (id == 0x00000222) return "XUsbcamCreate";
  if (id == 0x00000223) return "XUsbcamDestroy";
  if (id == 0x00000224) return "XMACreateContext";
  if (id == 0x00000225) return "XMAInitializeContext";
  if (id == 0x00000226) return "XMAReleaseContext";
  if (id == 0x00000227) return "XMAEnableContext";
  if (id == 0x00000228) return "XMADisableContext";
  if (id == 0x00000229) return "XMAGetOutputBufferWriteOffset";
  if (id == 0x0000022A) return "XMASetOutputBufferReadOffset";
  if (id == 0x0000022B) return "XMAGetOutputBufferReadOffset";
  if (id == 0x0000022C) return "XMASetOutputBufferValid";
  if (id == 0x0000022D) return "XMAIsOutputBufferValid";
  if (id == 0x0000022E) return "XMASetInputBuffer0Valid";
  if (id == 0x0000022F) return "XMAIsInputBuffer0Valid";
  if (id == 0x00000230) return "XMASetInputBuffer1Valid";
  if (id == 0x00000231) return "XMAIsInputBuffer1Valid";
  if (id == 0x00000232) return "XMASetInputBuffer0";
  if (id == 0x00000233) return "XMASetInputBuffer1";
  if (id == 0x00000234) return "XMAGetPacketMetadata";
  if (id == 0x00000235) return "XMABlockWhileInUse";
  if (id == 0x00000236) return "XMASetLoopData";
  if (id == 0x00000237) return "XMASetInputBufferReadOffset";
  if (id == 0x00000238) return "XMAGetInputBufferReadOffset";
  if (id == 0x0000023A) return "XeKeysGetFactoryChallenge";
  if (id == 0x0000023B) return "XeKeysSetFactoryResponse";
  if (id == 0x0000023C) return "XeKeysInitializeFuses";
  if (id == 0x0000023D) return "XeKeysSaveBootLoader";
  if (id == 0x0000023E) return "XeKeysSaveKeyVault";
  if (id == 0x0000023F) return "XeKeysGetStatus";
  if (id == 0x00000240) return "XeKeysGeneratePrivateKey";
  if (id == 0x00000241) return "XeKeysGetKeyProperties";
  if (id == 0x00000242) return "XeKeysSetKey";
  if (id == 0x00000243) return "XeKeysGenerateRandomKey";
  if (id == 0x00000244) return "XeKeysGetKey";
  if (id == 0x00000245) return "XeKeysGetDigest";
  if (id == 0x00000246) return "XeKeysGetConsoleID";
  if (id == 0x00000247) return "XeKeysGetConsoleType";
  if (id == 0x00000248) return "XeKeysQwNeRsaPrvCrypt";
  if (id == 0x00000249) return "XeKeysHmacSha";
  if (id == 0x0000024A) return "XeKeysHmacMd5";
  if (id == 0x0000024B) return "XeKeysAesCbc";
  if (id == 0x0000024C) return "XeKeysDes2Cbc";
  if (id == 0x0000024D) return "XeKeysDesCbc";
  if (id == 0x0000024E) return "XeKeysObscureKey";
  if (id == 0x0000024F) return "XeKeysHmacShaUsingKey";
  if (id == 0x00000250) return "XeKeysHmacMd5UsingKey";
  if (id == 0x00000251) return "XeKeysAesCbcUsingKey";
  if (id == 0x00000252) return "XeKeysDes2CbcUsingKey";
  if (id == 0x00000253) return "XeKeysDesCbcUsingKey";
  if (id == 0x00000254) return "XeKeysObfuscate";
  if (id == 0x00000255) return "XeKeysUnObfuscate";
  if (id == 0x00000256) return "XeKeysConsolePrivateKeySign";
  if (id == 0x00000257) return "XeKeysConsoleSignatureVerification";
  if (id == 0x00000258) return "XeKeysVerifyRSASignature";
  if (id == 0x00000259) return "StfsCreateDevice";
  if (id == 0x0000025A) return "StfsControlDevice";
  if (id == 0x0000025B) return "VdSwap";
  if (id == 0x0000025C) return "HalFsbInterruptCount";
  if (id == 0x0000025D) return "XeKeysSaveSystemUpdate";
  if (id == 0x0000025E) return "XeKeysLockSystemUpdate";
  if (id == 0x0000025F) return "XeKeysExecute";
  if (id == 0x00000260) return "XeKeysGetVersions";

  return nullptr;
}

const char* xboxkrnlNameGen(int id, int version)
{
  if (version > 0) {
    if (version <= 1640) return xboxkrnlNameGen_1640(id);
    if (version <= 1746) return xboxkrnlNameGen_1746(id);
    if (version <= 1838) return xboxkrnlNameGen_1838(id);
  }

  if (id == 0x00000001) return "DbgBreakPoint";
  if (id == 0x00000002) return "DbgBreakPointWithStatus";
  if (id == 0x00000003) return "DbgPrint";
  if (id == 0x00000004) return "DbgPrompt";
  if (id == 0x00000005) return "DumpGetRawDumpInfo";
  if (id == 0x00000006) return "DumpWriteDump";
  if (id == 0x00000007) return "ExAcquireReadWriteLockExclusive";
  if (id == 0x00000008) return "ExAcquireReadWriteLockShared";
  if (id == 0x00000009) return "ExAllocatePool";
  if (id == 0x0000000A) return "ExAllocatePoolWithTag";
  if (id == 0x0000000B) return "ExAllocatePoolTypeWithTag";
  if (id == 0x0000000C) return "ExConsoleGameRegion";
  if (id == 0x0000000D) return "ExCreateThread";
  if (id == 0x0000000E) return "ExEventObjectType";
  if (id == 0x0000000F) return "ExFreePool";
  if (id == 0x00000010) return "ExGetXConfigSetting";
  if (id == 0x00000011) return "ExInitializeReadWriteLock";
  if (id == 0x00000012) return "ExMutantObjectType";
  if (id == 0x00000013) return "ExQueryPoolBlockSize";
  if (id == 0x00000014) return "ExRegisterThreadNotification";
  if (id == 0x00000015) return "ExRegisterTitleTerminateNotification";
  if (id == 0x00000016) return "ExReleaseReadWriteLock";
  if (id == 0x00000017) return "ExSemaphoreObjectType";
  if (id == 0x00000018) return "ExSetXConfigSetting";
  if (id == 0x00000019) return "ExTerminateThread";
  if (id == 0x0000001A) return "ExTerminateTitleProcess";
  if (id == 0x0000001B) return "ExThreadObjectType";
  if (id == 0x0000001C) return "ExTimerObjectType";
  if (id == 0x0000001D) return "MmDoubleMapMemory";
  if (id == 0x0000001E) return "MmUnmapMemory";
  if (id == 0x0000001F) return "XeKeysGetConsoleCertificate";
  if (id == 0x00000020) return "FscGetCacheElementCount";
  if (id == 0x00000021) return "FscSetCacheElementCount";
  if (id == 0x00000022) return "HalGetCurrentAVPack";
  if (id == 0x00000023) return "HalGpioControl";
  if (id == 0x00000024) return "HalOpenCloseODDTray";
  if (id == 0x00000025) return "HalReadWritePCISpace";
  if (id == 0x00000026) return "HalRegisterPowerDownNotification";
  if (id == 0x00000027) return "HalRegisterSMCNotification";
  if (id == 0x00000028) return "HalReturnToFirmware";
  if (id == 0x00000029) return "HalSendSMCMessage";
  if (id == 0x0000002A) return "HalSetAudioEnable";
  if (id == 0x0000002B) return "InterlockedFlushSList";
  if (id == 0x0000002C) return "InterlockedPopEntrySList";
  if (id == 0x0000002D) return "InterlockedPushEntrySList";
  if (id == 0x0000002E) return "IoAcquireDeviceObjectLock";
  if (id == 0x0000002F) return "IoAllocateIrp";
  if (id == 0x00000030) return "IoBuildAsynchronousFsdRequest";
  if (id == 0x00000031) return "IoBuildDeviceIoControlRequest";
  if (id == 0x00000032) return "IoBuildSynchronousFsdRequest";
  if (id == 0x00000033) return "IoCallDriver";
  if (id == 0x00000034) return "IoCheckShareAccess";
  if (id == 0x00000035) return "IoCompleteRequest";
  if (id == 0x00000036) return "IoCompletionObjectType";
  if (id == 0x00000037) return "IoCreateDevice";
  if (id == 0x00000038) return "IoCreateFile";
  if (id == 0x00000039) return "IoDeleteDevice";
  if (id == 0x0000003A) return "IoDeviceObjectType";
  if (id == 0x0000003B) return "IoDismountVolume";
  if (id == 0x0000003C) return "IoDismountVolumeByFileHandle";
  if (id == 0x0000003D) return "IoDismountVolumeByName";
  if (id == 0x0000003E) return "IoFileObjectType";
  if (id == 0x0000003F) return "IoFreeIrp";
  if (id == 0x00000040) return "IoInitializeIrp";
  if (id == 0x00000041) return "IoInvalidDeviceRequest";
  if (id == 0x00000042) return "ExSetBetaFeaturesEnabled";
  if (id == 0x00000043) return "IoQueueThreadIrp";
  if (id == 0x00000044) return "IoReleaseDeviceObjectLock";
  if (id == 0x00000045) return "IoRemoveShareAccess";
  if (id == 0x00000046) return "IoSetIoCompletion";
  if (id == 0x00000047) return "IoSetShareAccess";
  if (id == 0x00000048) return "IoStartNextPacket";
  if (id == 0x00000049) return "IoStartNextPacketByKey";
  if (id == 0x0000004A) return "IoStartPacket";
  if (id == 0x0000004B) return "IoSynchronousDeviceIoControlRequest";
  if (id == 0x0000004C) return "IoSynchronousFsdRequest";
  if (id == 0x0000004D) return "KeAcquireSpinLockAtRaisedIrql";
  if (id == 0x0000004E) return "KeAlertResumeThread";
  if (id == 0x0000004F) return "KeAlertThread";
  if (id == 0x00000050) return "KeBlowFuses";
  if (id == 0x00000051) return "KeBoostPriorityThread";
  if (id == 0x00000052) return "KeBugCheck";
  if (id == 0x00000053) return "KeBugCheckEx";
  if (id == 0x00000054) return "KeCancelTimer";
  if (id == 0x00000055) return "KeConnectInterrupt";
  if (id == 0x00000056) return "KeContextFromKframes";
  if (id == 0x00000057) return "KeContextToKframes";
  if (id == 0x00000058) return "KeCreateUserMode";
  if (id == 0x00000059) return "KeDebugMonitorData";
  if (id == 0x0000005A) return "KeDelayExecutionThread";
  if (id == 0x0000005B) return "KeDeleteUserMode";
  if (id == 0x0000005C) return "KeDisconnectInterrupt";
  if (id == 0x0000005D) return "KeEnableFpuExceptions";
  if (id == 0x0000005E) return "KeEnablePPUPerformanceMonitor";
  if (id == 0x0000005F) return "KeEnterCriticalRegion";
  if (id == 0x00000060) return "KeEnterUserMode";
  if (id == 0x00000061) return "KeFlushCacheRange";
  if (id == 0x00000062) return "KeFlushCurrentEntireTb";
  if (id == 0x00000063) return "KeFlushEntireTb";
  if (id == 0x00000064) return "KeFlushUserModeCurrentTb";
  if (id == 0x00000065) return "KeFlushUserModeTb";
  if (id == 0x00000066) return "KeGetCurrentProcessType";
  if (id == 0x00000067) return "KeGetPMWRegister";
  if (id == 0x00000068) return "KeGetPRVRegister";
  if (id == 0x00000069) return "KeGetSocRegister";
  if (id == 0x0000006A) return "KeGetSpecialPurposeRegister";
  if (id == 0x0000006B) return "KeLockL2";
  if (id == 0x0000006C) return "KeUnlockL2";
  if (id == 0x0000006D) return "KeInitializeApc";
  if (id == 0x0000006E) return "KeInitializeDeviceQueue";
  if (id == 0x0000006F) return "KeInitializeDpc";
  if (id == 0x00000070) return "KeInitializeEvent";
  if (id == 0x00000071) return "KeInitializeInterrupt";
  if (id == 0x00000072) return "KeInitializeMutant";
  if (id == 0x00000073) return "KeInitializeQueue";
  if (id == 0x00000074) return "KeInitializeSemaphore";
  if (id == 0x00000075) return "KeInitializeTimerEx";
  if (id == 0x00000076) return "KeInsertByKeyDeviceQueue";
  if (id == 0x00000077) return "KeInsertDeviceQueue";
  if (id == 0x00000078) return "KeInsertHeadQueue";
  if (id == 0x00000079) return "KeInsertQueue";
  if (id == 0x0000007A) return "KeInsertQueueApc";
  if (id == 0x0000007B) return "KeInsertQueueDpc";
  if (id == 0x0000007C) return "KeIpiGenericCall";
  if (id == 0x0000007D) return "KeLeaveCriticalRegion";
  if (id == 0x0000007E) return "KeLeaveUserMode";
  if (id == 0x0000007F) return "KePulseEvent";
  if (id == 0x00000080) return "KeQueryBackgroundProcessors";
  if (id == 0x00000081) return "KeQueryBasePriorityThread";
  if (id == 0x00000082) return "KeQueryInterruptTime";
  if (id == 0x00000083) return "KeQueryPerformanceFrequency";
  if (id == 0x00000084) return "KeQuerySystemTime";
  if (id == 0x00000085) return "KeRaiseIrqlToDpcLevel";
  if (id == 0x00000086) return "KeRegisterDriverNotification";
  if (id == 0x00000087) return "KeReleaseMutant";
  if (id == 0x00000088) return "KeReleaseSemaphore";
  if (id == 0x00000089) return "KeReleaseSpinLockFromRaisedIrql";
  if (id == 0x0000008A) return "KeRemoveByKeyDeviceQueue";
  if (id == 0x0000008B) return "KeRemoveDeviceQueue";
  if (id == 0x0000008C) return "KeRemoveEntryDeviceQueue";
  if (id == 0x0000008D) return "KeRemoveQueue";
  if (id == 0x0000008E) return "KeRemoveQueueDpc";
  if (id == 0x0000008F) return "KeResetEvent";
  if (id == 0x00000090) return "KeRestoreFloatingPointState";
  if (id == 0x00000091) return "KeRestoreVectorUnitState";
  if (id == 0x00000092) return "KeResumeThread";
  if (id == 0x00000093) return "KeRetireDpcList";
  if (id == 0x00000094) return "KeRundownQueue";
  if (id == 0x00000095) return "KeSaveFloatingPointState";
  if (id == 0x00000096) return "KeSaveVectorUnitState";
  if (id == 0x00000097) return "KeSetAffinityThread";
  if (id == 0x00000098) return "KeSetBackgroundProcessors";
  if (id == 0x00000099) return "KeSetBasePriorityThread";
  if (id == 0x0000009A) return "KeSetCurrentProcessType";
  if (id == 0x0000009B) return "KeSetCurrentStackPointers";
  if (id == 0x0000009C) return "KeSetDisableBoostThread";
  if (id == 0x0000009D) return "KeSetEvent";
  if (id == 0x0000009E) return "KeSetEventBoostPriority";
  if (id == 0x0000009F) return "KeSetPMWRegister";
  if (id == 0x000000A0) return "KeSetPowerMode";
  if (id == 0x000000A1) return "KeSetPRVRegister";
  if (id == 0x000000A2) return "KeSetPriorityClassThread";
  if (id == 0x000000A3) return "KeSetPriorityThread";
  if (id == 0x000000A4) return "KeSetSocRegister";
  if (id == 0x000000A5) return "KeSetSpecialPurposeRegister";
  if (id == 0x000000A6) return "KeSetTimer";
  if (id == 0x000000A7) return "KeSetTimerEx";
  if (id == 0x000000A8) return "KeStallExecutionProcessor";
  if (id == 0x000000A9) return "KeSuspendThread";
  if (id == 0x000000AA) return "KeSweepDcacheRange";
  if (id == 0x000000AB) return "KeSweepIcacheRange";
  if (id == 0x000000AC) return "KeTestAlertThread";
  if (id == 0x000000AD) return "KeTimeStampBundle";
  if (id == 0x000000AE) return "KeTryToAcquireSpinLockAtRaisedIrql";
  if (id == 0x000000AF) return "KeWaitForMultipleObjects";
  if (id == 0x000000B0) return "KeWaitForSingleObject";
  if (id == 0x000000B1) return "KfAcquireSpinLock";
  if (id == 0x000000B2) return "KfRaiseIrql";
  if (id == 0x000000B3) return "KfLowerIrql";
  if (id == 0x000000B4) return "KfReleaseSpinLock";
  if (id == 0x000000B5) return "KiBugCheckData";
  if (id == 0x000000B6) return "LDICreateDecompression";
  if (id == 0x000000B7) return "LDIDecompress";
  if (id == 0x000000B8) return "LDIDestroyDecompression";
  if (id == 0x000000B9) return "MmAllocatePhysicalMemory";
  if (id == 0x000000BA) return "MmAllocatePhysicalMemoryEx";
  if (id == 0x000000BB) return "MmCreateKernelStack";
  if (id == 0x000000BC) return "MmDeleteKernelStack";
  if (id == 0x000000BD) return "MmFreePhysicalMemory";
  if (id == 0x000000BE) return "MmGetPhysicalAddress";
  if (id == 0x000000BF) return "MmIsAddressValid";
  if (id == 0x000000C0) return "MmLockAndMapSegmentArray";
  if (id == 0x000000C1) return "MmLockUnlockBufferPages";
  if (id == 0x000000C2) return "MmMapIoSpace";
  if (id == 0x000000C3) return "MmPersistPhysicalMemoryAllocation";
  if (id == 0x000000C4) return "MmQueryAddressProtect";
  if (id == 0x000000C5) return "MmQueryAllocationSize";
  if (id == 0x000000C6) return "MmQueryStatistics";
  if (id == 0x000000C7) return "MmSetAddressProtect";
  if (id == 0x000000C8) return "MmSplitPhysicalMemoryAllocation";
  if (id == 0x000000C9) return "MmUnlockAndUnmapSegmentArray";
  if (id == 0x000000CA) return "MmUnmapIoSpace";
  if (id == 0x000000CB) return "Nls844UnicodeCaseTable";
  if (id == 0x000000CC) return "NtAllocateVirtualMemory";
  if (id == 0x000000CD) return "NtCancelTimer";
  if (id == 0x000000CE) return "NtClearEvent";
  if (id == 0x000000CF) return "NtClose";
  if (id == 0x000000D0) return "NtCreateDirectoryObject";
  if (id == 0x000000D1) return "NtCreateEvent";
  if (id == 0x000000D2) return "NtCreateFile";
  if (id == 0x000000D3) return "NtCreateIoCompletion";
  if (id == 0x000000D4) return "NtCreateMutant";
  if (id == 0x000000D5) return "NtCreateSemaphore";
  if (id == 0x000000D6) return "NtCreateSymbolicLinkObject";
  if (id == 0x000000D7) return "NtCreateTimer";
  if (id == 0x000000D8) return "NtDeleteFile";
  if (id == 0x000000D9) return "NtDeviceIoControlFile";
  if (id == 0x000000DA) return "NtDuplicateObject";
  if (id == 0x000000DB) return "NtFlushBuffersFile";
  if (id == 0x000000DC) return "NtFreeVirtualMemory";
  if (id == 0x000000DD) return "NtMakeTemporaryObject";
  if (id == 0x000000DE) return "NtOpenDirectoryObject";
  if (id == 0x000000DF) return "NtOpenFile";
  if (id == 0x000000E0) return "NtOpenSymbolicLinkObject";
  if (id == 0x000000E1) return "NtProtectVirtualMemory";
  if (id == 0x000000E2) return "NtPulseEvent";
  if (id == 0x000000E3) return "NtQueueApcThread";
  if (id == 0x000000E4) return "NtQueryDirectoryFile";
  if (id == 0x000000E5) return "NtQueryDirectoryObject";
  if (id == 0x000000E6) return "NtQueryEvent";
  if (id == 0x000000E7) return "NtQueryFullAttributesFile";
  if (id == 0x000000E8) return "NtQueryInformationFile";
  if (id == 0x000000E9) return "NtQueryIoCompletion";
  if (id == 0x000000EA) return "NtQueryMutant";
  if (id == 0x000000EB) return "NtQuerySemaphore";
  if (id == 0x000000EC) return "NtQuerySymbolicLinkObject";
  if (id == 0x000000ED) return "NtQueryTimer";
  if (id == 0x000000EE) return "NtQueryVirtualMemory";
  if (id == 0x000000EF) return "NtQueryVolumeInformationFile";
  if (id == 0x000000F0) return "NtReadFile";
  if (id == 0x000000F1) return "NtReadFileScatter";
  if (id == 0x000000F2) return "NtReleaseMutant";
  if (id == 0x000000F3) return "NtReleaseSemaphore";
  if (id == 0x000000F4) return "NtRemoveIoCompletion";
  if (id == 0x000000F5) return "NtResumeThread";
  if (id == 0x000000F6) return "NtSetEvent";
  if (id == 0x000000F7) return "NtSetInformationFile";
  if (id == 0x000000F8) return "NtSetIoCompletion";
  if (id == 0x000000F9) return "NtSetSystemTime";
  if (id == 0x000000FA) return "NtSetTimerEx";
  if (id == 0x000000FB) return "NtSignalAndWaitForSingleObjectEx";
  if (id == 0x000000FC) return "NtSuspendThread";
  if (id == 0x000000FD) return "NtWaitForSingleObjectEx";
  if (id == 0x000000FE) return "NtWaitForMultipleObjectsEx";
  if (id == 0x000000FF) return "NtWriteFile";
  if (id == 0x00000100) return "NtWriteFileGather";
  if (id == 0x00000101) return "NtYieldExecution";
  if (id == 0x00000102) return "ObCreateObject";
  if (id == 0x00000103) return "ObCreateSymbolicLink";
  if (id == 0x00000104) return "ObDeleteSymbolicLink";
  if (id == 0x00000105) return "ObDereferenceObject";
  if (id == 0x00000106) return "ObDirectoryObjectType";
  if (id == 0x00000107) return "ObGetWaitableObject";
  if (id == 0x00000108) return "ObInsertObject";
  if (id == 0x00000109) return "ObIsTitleObject";
  if (id == 0x0000010A) return "ObLookupAnyThreadByThreadId";
  if (id == 0x0000010B) return "ObLookupThreadByThreadId";
  if (id == 0x0000010C) return "ObMakeTemporaryObject";
  if (id == 0x0000010D) return "ObOpenObjectByName";
  if (id == 0x0000010E) return "ObOpenObjectByPointer";
  if (id == 0x0000010F) return "ObReferenceObject";
  if (id == 0x00000110) return "ObReferenceObjectByHandle";
  if (id == 0x00000111) return "ObReferenceObjectByName";
  if (id == 0x00000112) return "ObSymbolicLinkObjectType";
  if (id == 0x00000113) return "ObTranslateSymbolicLink";
  if (id == 0x00000114) return "RtlAnsiStringToUnicodeString";
  if (id == 0x00000115) return "RtlAppendStringToString";
  if (id == 0x00000116) return "RtlAppendUnicodeStringToString";
  if (id == 0x00000117) return "RtlAppendUnicodeToString";
  if (id == 0x00000118) return "RtlAssert";
  if (id == 0x00000119) return "RtlCaptureContext";
  if (id == 0x0000011A) return "RtlCompareMemory";
  if (id == 0x0000011B) return "RtlCompareMemoryUlong";
  if (id == 0x0000011C) return "RtlCompareString";
  if (id == 0x0000011D) return "RtlCompareStringN";
  if (id == 0x0000011E) return "RtlCompareUnicodeString";
  if (id == 0x0000011F) return "RtlCompareUnicodeStringN";
  if (id == 0x00000120) return "RtlCompareUtf8ToUnicode";
  if (id == 0x00000121) return "RtlCopyString";
  if (id == 0x00000122) return "RtlCopyUnicodeString";
  if (id == 0x00000123) return "RtlCreateUnicodeString";
  if (id == 0x00000124) return "RtlDowncaseUnicodeChar";
  if (id == 0x00000125) return "RtlEnterCriticalSection";
  if (id == 0x00000126) return "RtlFillMemoryUlong";
  if (id == 0x00000127) return "RtlFreeAnsiString";
  if (id == 0x00000128) return "RtlFreeUnicodeString";
  if (id == 0x00000129) return "RtlGetCallersAddress";
  if (id == 0x0000012A) return "RtlGetStackLimits";
  if (id == 0x0000012B) return "RtlImageXexHeaderField";
  if (id == 0x0000012C) return "RtlInitAnsiString";
  if (id == 0x0000012D) return "RtlInitUnicodeString";
  if (id == 0x0000012E) return "RtlInitializeCriticalSection";
  if (id == 0x0000012F) return "RtlInitializeCriticalSectionAndSpinCount";
  if (id == 0x00000130) return "RtlLeaveCriticalSection";
  if (id == 0x00000131) return "RtlLookupFunctionEntry";
  if (id == 0x00000132) return "RtlLowerChar";
  if (id == 0x00000133) return "RtlMultiByteToUnicodeN";
  if (id == 0x00000134) return "RtlMultiByteToUnicodeSize";
  if (id == 0x00000135) return "RtlNtStatusToDosError";
  if (id == 0x00000136) return "RtlRaiseException";
  if (id == 0x00000137) return "RtlRaiseStatus";
  if (id == 0x00000138) return "RtlRip";
  if (id == 0x00000139) return "_scprintf";
  if (id == 0x0000013A) return "_snprintf";
  if (id == 0x0000013B) return "sprintf";
  if (id == 0x0000013C) return "_scwprintf";
  if (id == 0x0000013D) return "_snwprintf";
  if (id == 0x0000013E) return "swprintf";
  if (id == 0x0000013F) return "RtlTimeFieldsToTime";
  if (id == 0x00000140) return "RtlTimeToTimeFields";
  if (id == 0x00000141) return "RtlTryEnterCriticalSection";
  if (id == 0x00000142) return "RtlUnicodeStringToAnsiString";
  if (id == 0x00000143) return "RtlUnicodeToMultiByteN";
  if (id == 0x00000144) return "RtlUnicodeToMultiByteSize";
  if (id == 0x00000145) return "RtlUnicodeToUtf8";
  if (id == 0x00000146) return "RtlUnicodeToUtf8Size";
  if (id == 0x00000147) return "RtlUnwind";
  if (id == 0x00000148) return "RtlUnwind2";
  if (id == 0x00000149) return "RtlUpcaseUnicodeChar";
  if (id == 0x0000014A) return "RtlUpperChar";
  if (id == 0x0000014B) return "RtlVirtualUnwind";
  if (id == 0x0000014C) return "_vscprintf";
  if (id == 0x0000014D) return "_vsnprintf";
  if (id == 0x0000014E) return "vsprintf";
  if (id == 0x0000014F) return "_vscwprintf";
  if (id == 0x00000150) return "_vsnwprintf";
  if (id == 0x00000151) return "vswprintf";
  if (id == 0x00000152) return "KeTlsAlloc";
  if (id == 0x00000153) return "KeTlsFree";
  if (id == 0x00000154) return "KeTlsGetValue";
  if (id == 0x00000155) return "KeTlsSetValue";
  if (id == 0x00000156) return "XboxHardwareInfo";
  if (id == 0x00000157) return "XboxKrnlBaseVersion";
  if (id == 0x00000158) return "XboxKrnlVersion";
  if (id == 0x00000159) return "XeCryptAesKey";
  if (id == 0x0000015A) return "XeCryptAesEcb";
  if (id == 0x0000015B) return "XeCryptAesCbc";
  if (id == 0x0000015C) return "XeCryptBnDwLeDhEqualBase";
  if (id == 0x0000015D) return "XeCryptBnDwLeDhInvalBase";
  if (id == 0x0000015E) return "XeCryptBnDwLeDhModExp";
  if (id == 0x0000015F) return "XeCryptBnDw_Copy";
  if (id == 0x00000160) return "XeCryptBnDw_SwapLeBe";
  if (id == 0x00000161) return "XeCryptBnDw_Zero";
  if (id == 0x00000162) return "XeCryptBnDwLePkcs1Format";
  if (id == 0x00000163) return "XeCryptBnDwLePkcs1Verify";
  if (id == 0x00000164) return "XeCryptBnQwBeSigCreate";
  if (id == 0x00000165) return "XeCryptBnQwBeSigFormat";
  if (id == 0x00000166) return "XeCryptBnQwBeSigVerify";
  if (id == 0x00000167) return "XeCryptBnQwNeModExp";
  if (id == 0x00000168) return "XeCryptBnQwNeModExpRoot";
  if (id == 0x00000169) return "XeCryptBnQwNeModInv";
  if (id == 0x0000016A) return "XeCryptBnQwNeModMul";
  if (id == 0x0000016B) return "XeCryptBnQwNeRsaKeyGen";
  if (id == 0x0000016C) return "XeCryptBnQwNeRsaPrvCrypt";
  if (id == 0x0000016D) return "XeCryptBnQwNeRsaPubCrypt";
  if (id == 0x0000016E) return "XeCryptBnQw_Copy";
  if (id == 0x0000016F) return "XeCryptBnQw_SwapDwQw";
  if (id == 0x00000170) return "XeCryptBnQw_SwapDwQwLeBe";
  if (id == 0x00000171) return "XeCryptBnQw_SwapLeBe";
  if (id == 0x00000172) return "XeCryptBnQw_Zero";
  if (id == 0x00000173) return "XeCryptChainAndSumMac";
  if (id == 0x00000174) return "XeCryptDesParity";
  if (id == 0x00000175) return "XeCryptDesKey";
  if (id == 0x00000176) return "XeCryptDesEcb";
  if (id == 0x00000177) return "XeCryptDesCbc";
  if (id == 0x00000178) return "XeCryptDes3Key";
  if (id == 0x00000179) return "XeCryptDes3Ecb";
  if (id == 0x0000017A) return "XeCryptDes3Cbc";
  if (id == 0x0000017B) return "XeCryptHmacMd5Init";
  if (id == 0x0000017C) return "XeCryptHmacMd5Update";
  if (id == 0x0000017D) return "XeCryptHmacMd5Final";
  if (id == 0x0000017E) return "XeCryptHmacMd5";
  if (id == 0x0000017F) return "XeCryptHmacShaInit";
  if (id == 0x00000180) return "XeCryptHmacShaUpdate";
  if (id == 0x00000181) return "XeCryptHmacShaFinal";
  if (id == 0x00000182) return "XeCryptHmacSha";
  if (id == 0x00000183) return "XeCryptHmacShaVerify";
  if (id == 0x00000184) return "XeCryptMd5Init";
  if (id == 0x00000185) return "XeCryptMd5Update";
  if (id == 0x00000186) return "XeCryptMd5Final";
  if (id == 0x00000187) return "XeCryptMd5";
  if (id == 0x00000188) return "XeCryptParveEcb";
  if (id == 0x00000189) return "XeCryptParveCbcMac";
  if (id == 0x0000018A) return "XeCryptRandom";
  if (id == 0x0000018B) return "XeCryptRc4Key";
  if (id == 0x0000018C) return "XeCryptRc4Ecb";
  if (id == 0x0000018D) return "XeCryptRc4";
  if (id == 0x0000018E) return "XeCryptRotSumSha";
  if (id == 0x0000018F) return "XeCryptShaInit";
  if (id == 0x00000190) return "XeCryptShaUpdate";
  if (id == 0x00000191) return "XeCryptShaFinal";
  if (id == 0x00000192) return "XeCryptSha";
  if (id == 0x00000193) return "XexExecutableModuleHandle";
  if (id == 0x00000194) return "XexCheckExecutablePrivilege";
  if (id == 0x00000195) return "XexGetModuleHandle";
  if (id == 0x00000196) return "XexGetModuleSection";
  if (id == 0x00000197) return "XexGetProcedureAddress";
  if (id == 0x00000198) return "XexLoadExecutable";
  if (id == 0x00000199) return "XexLoadImage";
  if (id == 0x0000019A) return "XexLoadImageFromMemory";
  if (id == 0x0000019B) return "XexLoadImageHeaders";
  if (id == 0x0000019C) return "XexPcToFileHeader";
  if (id == 0x0000019D) return "KiApcNormalRoutineNop";
  if (id == 0x0000019E) return "XexRegisterPatchDescriptor";
  if (id == 0x0000019F) return "XexSendDeferredNotifications";
  if (id == 0x000001A0) return "XexStartExecutable";
  if (id == 0x000001A1) return "XexUnloadImage";
  if (id == 0x000001A2) return "XexUnloadImageAndExitThread";
  if (id == 0x000001A3) return "XexUnloadTitleModules";
  if (id == 0x000001A4) return "XexVerifyImageHeaders";
  if (id == 0x000001A5) return "__C_specific_handler";
  if (id == 0x000001A6) return "DbgLoadImageSymbols";
  if (id == 0x000001A7) return "DbgUnLoadImageSymbols";
  if (id == 0x000001A8) return "RtlImageDirectoryEntryToData";
  if (id == 0x000001A9) return "RtlImageNtHeader";
  if (id == 0x000001AA) return "ExDebugMonitorService";
  if (id == 0x000001AB) return "MmDbgReadCheck";
  if (id == 0x000001AC) return "MmDbgReleaseAddress";
  if (id == 0x000001AD) return "MmDbgWriteCheck";
  if (id == 0x000001AE) return "ExLoadedCommandLine";
  if (id == 0x000001AF) return "ExLoadedImageName";
  if (id == 0x000001B0) return "VdBlockUntilGUIIdle";
  if (id == 0x000001B1) return "VdCallGraphicsNotificationRoutines";
  if (id == 0x000001B2) return "VdDisplayFatalError";
  if (id == 0x000001B3) return "VdEnableClosedCaption";
  if (id == 0x000001B4) return "VdEnableDisableClockGating";
  if (id == 0x000001B5) return "VdEnableDisablePowerSavingMode";
  if (id == 0x000001B6) return "VdEnableRingBufferRPtrWriteBack";
  if (id == 0x000001B7) return "VdGenerateGPUCSCCoefficients";
  if (id == 0x000001B8) return "VdGetClosedCaptionReadyStatus";
  if (id == 0x000001B9) return "VdGetCurrentDisplayGamma";
  if (id == 0x000001BA) return "VdGetCurrentDisplayInformation";
  if (id == 0x000001BB) return "VdGetDisplayModeOverride";
  if (id == 0x000001BC) return "VdGetGraphicsAsicID";
  if (id == 0x000001BD) return "VdGetSystemCommandBuffer";
  if (id == 0x000001BE) return "VdGlobalDevice";
  if (id == 0x000001BF) return "VdGlobalXamDevice";
  if (id == 0x000001C0) return "VdGpuClockInMHz";
  if (id == 0x000001C1) return "VdHSIOCalibrationLock";
  if (id == 0x000001C2) return "VdInitializeEngines";
  if (id == 0x000001C3) return "VdInitializeRingBuffer";
  if (id == 0x000001C4) return "VdInitializeScaler";
  if (id == 0x000001C5) return "VdInitializeScalerCommandBuffer";
  if (id == 0x000001C6) return "VdIsHSIOTrainingSucceeded";
  if (id == 0x000001C7) return "VdPersistDisplay";
  if (id == 0x000001C8) return "VdQuerySystemCommandBuffer";
  if (id == 0x000001C9) return "VdQueryVideoFlags";
  if (id == 0x000001CA) return "VdQueryVideoMode";
  if (id == 0x000001CB) return "VdReadDVERegisterUlong";
  if (id == 0x000001CC) return "VdReadWriteHSIOCalibrationFlag";
  if (id == 0x000001CD) return "VdRegisterGraphicsNotification";
  if (id == 0x000001CE) return "VdRegisterXamGraphicsNotification";
  if (id == 0x000001CF) return "VdSendClosedCaptionData";
  if (id == 0x000001D0) return "VdSetCGMSOption";
  if (id == 0x000001D1) return "VdSetColorProfileAdjustment";
  if (id == 0x000001D2) return "VdSetCscMatricesOverride";
  if (id == 0x000001D3) return "VdSetDisplayMode";
  if (id == 0x000001D4) return "VdSetDisplayModeOverride";
  if (id == 0x000001D5) return "VdSetGraphicsInterruptCallback";
  if (id == 0x000001D6) return "VdSetHDCPOption";
  if (id == 0x000001D7) return "VdSetMacrovisionOption";
  if (id == 0x000001D8) return "VdSetSystemCommandBuffer";
  if (id == 0x000001D9) return "VdSetSystemCommandBufferGpuIdentifierAddress";
  if (id == 0x000001DA) return "VdSetWSSData";
  if (id == 0x000001DB) return "VdSetWSSOption";
  if (id == 0x000001DC) return "VdShutdownEngines";
  if (id == 0x000001DD) return "VdTurnDisplayOff";
  if (id == 0x000001DE) return "VdTurnDisplayOn";
  if (id == 0x000001DF) return "KiApcNormalRoutineNop_0";
  if (id == 0x000001E0) return "VdWriteDVERegisterUlong";
  if (id == 0x000001E1) return "XVoicedHeadsetPresent";
  if (id == 0x000001E2) return "XVoicedSubmitPacket";
  if (id == 0x000001E3) return "XVoicedClose";
  if (id == 0x000001E4) return "XVoicedActivate";
  if (id == 0x000001E5) return "XInputdGetCapabilities";
  if (id == 0x000001E6) return "XInputdReadState";
  if (id == 0x000001E7) return "XInputdWriteState";
  if (id == 0x000001E8) return "XInputdNotify";
  if (id == 0x000001E9) return "XInputdRawState";
  if (id == 0x000001EA) return "HidGetCapabilities";
  if (id == 0x000001EB) return "HidReadKeys";
  if (id == 0x000001EC) return "XInputdGetDeviceStats";
  if (id == 0x000001ED) return "XInputdResetDevice";
  if (id == 0x000001EE) return "XInputdSetRingOfLight";
  if (id == 0x000001EF) return "XInputdSetRFPowerMode";
  if (id == 0x000001F0) return "XInputdSetRadioFrequency";
  if (id == 0x000001F1) return "HidGetLastInputTime";
  if (id == 0x000001F2) return "XAudioRenderDriverInitialize";
  if (id == 0x000001F3) return "XAudioRegisterRenderDriverClient";
  if (id == 0x000001F4) return "XAudioUnregisterRenderDriverClient";
  if (id == 0x000001F5) return "XAudioSubmitRenderDriverFrame";
  if (id == 0x000001F6) return "XAudioRenderDriverLock";
  if (id == 0x000001F7) return "XAudioGetVoiceCategoryVolumeChangeMask";
  if (id == 0x000001F8) return "XAudioGetVoiceCategoryVolume";
  if (id == 0x000001F9) return "XAudioSetVoiceCategoryVolume";
  if (id == 0x000001FA) return "XAudioBeginDigitalBypassMode";
  if (id == 0x000001FB) return "XAudioEndDigitalBypassMode";
  if (id == 0x000001FC) return "XAudioSubmitDigitalPacket";
  if (id == 0x000001FD) return "XAudioQueryDriverPerformance";
  if (id == 0x000001FE) return "XAudioGetRenderDriverThread";
  if (id == 0x000001FF) return "XAudioGetSpeakerConfig";
  if (id == 0x00000200) return "XAudioSetSpeakerConfig";
  if (id == 0x00000201) return "NicSetUnicastAddress";
  if (id == 0x00000202) return "NicAttach";
  if (id == 0x00000203) return "NicDetach";
  if (id == 0x00000204) return "NicXmit";
  if (id == 0x00000205) return "NicUpdateMcastMembership";
  if (id == 0x00000206) return "NicFlushXmitQueue";
  if (id == 0x00000207) return "NicShutdown";
  if (id == 0x00000208) return "NicGetLinkState";
  if (id == 0x00000209) return "NicGetStats";
  if (id == 0x0000020A) return "NicGetOpt";
  if (id == 0x0000020B) return "NicSetOpt";
  if (id == 0x0000020C) return "DrvSetSysReqCallback";
  if (id == 0x0000020D) return "DrvSetUserBindingCallback";
  if (id == 0x0000020E) return "DrvSetContentStorageCallback";
  if (id == 0x0000020F) return "DrvSetAutobind";
  if (id == 0x00000210) return "DrvGetContentStorageNotification";
  if (id == 0x00000211) return "MtpdBeginTransaction";
  if (id == 0x00000212) return "MtpdCancelTransaction";
  if (id == 0x00000213) return "MtpdEndTransaction";
  if (id == 0x00000214) return "MtpdGetCurrentDevices";
  if (id == 0x00000215) return "MtpdReadData";
  if (id == 0x00000216) return "MtpdReadEvent";
  if (id == 0x00000217) return "MtpdResetDevice";
  if (id == 0x00000218) return "MtpdSendData";
  if (id == 0x00000219) return "MtpdVerifyProximity";
  if (id == 0x0000021A) return "XUsbcamSetCaptureMode";
  if (id == 0x0000021B) return "XUsbcamGetConfig";
  if (id == 0x0000021C) return "XUsbcamSetConfig";
  if (id == 0x0000021D) return "XUsbcamGetState";
  if (id == 0x0000021E) return "XUsbcamReadFrame";
  if (id == 0x0000021F) return "XUsbcamSnapshot";
  if (id == 0x00000220) return "XUsbcamSetView";
  if (id == 0x00000221) return "XUsbcamGetView";
  if (id == 0x00000222) return "XUsbcamCreate";
  if (id == 0x00000223) return "XUsbcamDestroy";
  if (id == 0x00000224) return "XMACreateContext";
  if (id == 0x00000225) return "XMAInitializeContext";
  if (id == 0x00000226) return "XMAReleaseContext";
  if (id == 0x00000227) return "XMAEnableContext";
  if (id == 0x00000228) return "XMADisableContext";
  if (id == 0x00000229) return "XMAGetOutputBufferWriteOffset";
  if (id == 0x0000022A) return "XMASetOutputBufferReadOffset";
  if (id == 0x0000022B) return "XMAGetOutputBufferReadOffset";
  if (id == 0x0000022C) return "XMASetOutputBufferValid";
  if (id == 0x0000022D) return "XMAIsOutputBufferValid";
  if (id == 0x0000022E) return "XMASetInputBuffer0Valid";
  if (id == 0x0000022F) return "XMAIsInputBuffer0Valid";
  if (id == 0x00000230) return "XMASetInputBuffer1Valid";
  if (id == 0x00000231) return "XMAIsInputBuffer1Valid";
  if (id == 0x00000232) return "XMASetInputBuffer0";
  if (id == 0x00000233) return "XMASetInputBuffer1";
  if (id == 0x00000234) return "XMAGetPacketMetadata";
  if (id == 0x00000235) return "XMABlockWhileInUse";
  if (id == 0x00000236) return "XMASetLoopData";
  if (id == 0x00000237) return "XMASetInputBufferReadOffset";
  if (id == 0x00000238) return "XMAGetInputBufferReadOffset";
  if (id == 0x00000239) return "ExIsBetaFeatureEnabled";
  if (id == 0x0000023A) return "XeKeysGetFactoryChallenge";
  if (id == 0x0000023B) return "XeKeysSetFactoryResponse";
  if (id == 0x0000023C) return "XeKeysInitializeFuses";
  if (id == 0x0000023D) return "XeKeysSaveBootLoader";
  if (id == 0x0000023E) return "XeKeysSaveKeyVault";
  if (id == 0x0000023F) return "XeKeysGetStatus";
  if (id == 0x00000240) return "XeKeysGeneratePrivateKey";
  if (id == 0x00000241) return "XeKeysGetKeyProperties";
  if (id == 0x00000242) return "XeKeysSetKey";
  if (id == 0x00000243) return "XeKeysGenerateRandomKey";
  if (id == 0x00000244) return "XeKeysGetKey";
  if (id == 0x00000245) return "XeKeysGetDigest";
  if (id == 0x00000246) return "XeKeysGetConsoleID";
  if (id == 0x00000247) return "XeKeysGetConsoleType";
  if (id == 0x00000248) return "XeKeysQwNeRsaPrvCrypt";
  if (id == 0x00000249) return "XeKeysHmacSha";
  if (id == 0x0000024A) return "XInputdPassThroughRFCommand";
  if (id == 0x0000024B) return "XeKeysAesCbc";
  if (id == 0x0000024C) return "XeKeysDes2Cbc";
  if (id == 0x0000024D) return "XeKeysDesCbc";
  if (id == 0x0000024E) return "XeKeysObscureKey";
  if (id == 0x0000024F) return "XeKeysHmacShaUsingKey";
  if (id == 0x00000250) return "XeKeysSaveBootLoaderEx";
  if (id == 0x00000251) return "XeKeysAesCbcUsingKey";
  if (id == 0x00000252) return "XeKeysDes2CbcUsingKey";
  if (id == 0x00000253) return "XeKeysDesCbcUsingKey";
  if (id == 0x00000254) return "XeKeysObfuscate";
  if (id == 0x00000255) return "XeKeysUnObfuscate";
  if (id == 0x00000256) return "XeKeysConsolePrivateKeySign";
  if (id == 0x00000257) return "XeKeysConsoleSignatureVerification";
  if (id == 0x00000258) return "XeKeysVerifyRSASignature";
  if (id == 0x00000259) return "StfsCreateDevice";
  if (id == 0x0000025A) return "StfsControlDevice";
  if (id == 0x0000025B) return "VdSwap";
  if (id == 0x0000025C) return "HalFsbInterruptCount";
  if (id == 0x0000025D) return "XeKeysSaveSystemUpdate";
  if (id == 0x0000025E) return "XeKeysLockSystemUpdate";
  if (id == 0x0000025F) return "XeKeysExecute";
  if (id == 0x00000260) return "XeKeysGetVersions";
  if (id == 0x00000261) return "XInputdPowerDownDevice";
  if (id == 0x00000262) return "AniBlockOnAnimation";
  if (id == 0x00000263) return "AniTerminateAnimation";
  if (id == 0x00000264) return "XUsbcamReset";
  if (id == 0x00000265) return "AniSetLogo";
  if (id == 0x00000266) return "KeCertMonitorData";
  if (id == 0x00000267) return "HalIsExecutingPowerDownDpc";
  if (id == 0x00000268) return "VdInitializeEDRAM";
  if (id == 0x00000269) return "VdRetrainEDRAM";
  if (id == 0x0000026A) return "VdRetrainEDRAMWorker";
  if (id == 0x0000026B) return "VdHSIOTrainCount";
  if (id == 0x0000026C) return "HalGetPowerUpCause";
  if (id == 0x0000026D) return "VdHSIOTrainingStatus";
  if (id == 0x0000026E) return "RgcBindInfo";
  if (id == 0x0000026F) return "VdReadEEDIDBlock";
  if (id == 0x00000270) return "VdEnumerateVideoModes";
  if (id == 0x00000271) return "VdEnableHDCP";
  if (id == 0x00000272) return "VdRegisterHDCPNotification";
  if (id == 0x00000273) return "HidReadMouseChanges";
  if (id == 0x00000274) return "DumpSetCollectionFacility";
  if (id == 0x00000275) return "XexTransformImageKey";
  if (id == 0x00000276) return "XAudioOverrideSpeakerConfig";
  if (id == 0x00000277) return "XInputdReadTextKeystroke";
  if (id == 0x00000278) return "DrvXenonButtonPressed";
  if (id == 0x00000279) return "DrvBindToUser";
  if (id == 0x0000027A) return "XexGetModuleImportVersions";
  if (id == 0x0000027B) return "RtlComputeCrc32";
  if (id == 0x0000027C) return "XeKeysSetRevocationList";
  if (id == 0x0000027D) return "HalRegisterPowerDownCallback";
  if (id == 0x0000027E) return "VdGetDisplayDiscoveryData";
  if (id == 0x0000027F) return "XInputdSendStayAliveRequest";
  if (id == 0x00000280) return "XVoicedSendVPort";
  if (id == 0x00000281) return "XVoicedGetBatteryStatus";
  if (id == 0x00000282) return "XInputdFFGetDeviceInfo";
  if (id == 0x00000283) return "XInputdFFSetEffect";
  if (id == 0x00000284) return "XInputdFFUpdateEffect";
  if (id == 0x00000285) return "XInputdFFEffectOperation";
  if (id == 0x00000286) return "XInputdFFDeviceControl";
  if (id == 0x00000287) return "XInputdFFSetDeviceGain";
  if (id == 0x00000288) return "XInputdFFCancelIo";
  if (id == 0x00000289) return "XInputdFFSetRumble";
  if (id == 0x0000028A) return "NtAllocateEncryptedMemory";
  if (id == 0x0000028B) return "NtFreeEncryptedMemory";
  if (id == 0x0000028C) return "XeKeysExSaveKeyVault";
  if (id == 0x0000028D) return "XeKeysExSetKey";
  if (id == 0x0000028E) return "XeKeysExGetKey";
  if (id == 0x0000028F) return "DrvSetDeviceConfigChangeCallback";
  if (id == 0x00000290) return "DrvDeviceConfigChange";
  if (id == 0x00000291) return "HalRegisterHdDvdRomNotification";
  if (id == 0x00000292) return "XeKeysSecurityInitialize";
  if (id == 0x00000293) return "XeKeysSecurityLoadSettings";
  if (id == 0x00000294) return "XeKeysSecuritySaveSettings";
  if (id == 0x00000295) return "XeKeysSecuritySetDetected";
  if (id == 0x00000296) return "XeKeysSecurityGetDetected";
  if (id == 0x00000297) return "XeKeysSecuritySetActivated";
  if (id == 0x00000298) return "XeKeysSecurityGetActivated";
  if (id == 0x00000299) return "XeKeysDvdAuthAP25InstallTable";
  if (id == 0x0000029A) return "XeKeysDvdAuthAP25GetTableVersion";
  if (id == 0x0000029B) return "XeKeysGetProtectedFlag";
  if (id == 0x0000029C) return "XeKeysSetProtectedFlag";
  if (id == 0x0000029D) return "KeEnablePFMInterrupt";
  if (id == 0x0000029E) return "KeDisablePFMInterrupt";
  if (id == 0x0000029F) return "KeSetProfilerISR";
  if (id == 0x000002A0) return "VdStartDisplayDiscovery";
  if (id == 0x000002A1) return "VdSetHDCPRevocationList";
  if (id == 0x000002A2) return "XeKeysGetUpdateSequence";
  if (id == 0x000002A3) return "XeKeysDvdAuthExActivate";
  if (id == 0x000002A4) return "KeGetImagePageTableEntry";
  if (id == 0x000002A5) return "HalRegisterBackgroundModeTransitionCallback";
  if (id == 0x000002A6) return "AniStartBootAnimation";
  if (id == 0x000002A7) return "HalClampUnclampOutputDACs";
  if (id == 0x000002A8) return "HalPowerDownToBackgroundMode";
  if (id == 0x000002A9) return "HalNotifyAddRemoveBackgroundTask";
  if (id == 0x000002AA) return "HalCallBackgroundModeNotificationRoutines";
  if (id == 0x000002AB) return "HalFsbResetCount";
  if (id == 0x000002AC) return "HalGetMemoryInformation";
  if (id == 0x000002AD) return "XInputdGetLastTextInputTime";
  if (id == 0x000002AE) return "VdEnableWMAProOverHDMI";
  if (id == 0x000002AF) return "XeKeysRevokeSaveSettings";
  if (id == 0x000002B0) return "XInputdSetTextMessengerIndicator";
  if (id == 0x000002B1) return "MicDeviceRequest";
  if (id == 0x000002B2) return "XeKeysGetMediaID";
  if (id == 0x000002B3) return "XeKeysLoadKeyVault";
  if (id == 0x000002B4) return "KeGetVidInfo";
  if (id == 0x000002B5) return "HalNotifyBackgroundModeTransitionComplete";
  if (id == 0x000002B6) return "IoAcquireCancelSpinLock";
  if (id == 0x000002B7) return "IoReleaseCancelSpinLock";
  if (id == 0x000002B8) return "NtCancelIoFile";
  if (id == 0x000002B9) return "NtCancelIoFileEx";
  if (id == 0x000002BA) return "HalFinalizePowerLossRecovery";
  if (id == 0x000002BB) return "HalSetPowerLossRecovery";
  if (id == 0x000002BC) return "ExReadModifyWriteXConfigSettingUlong";
  if (id == 0x000002BD) return "HalRegisterXamPowerDownCallback";
  if (id == 0x000002BE) return "ExCancelAlarm";
  if (id == 0x000002BF) return "ExInitializeAlarm";
  if (id == 0x000002C0) return "ExSetAlarm";
  if (id == 0x000002C1) return "XexActivationGetNonce";
  if (id == 0x000002C2) return "XexActivationSetLicense";
  if (id == 0x000002C3) return "IptvSetBoundaryKey";
  if (id == 0x000002C4) return "IptvSetSessionKey";
  if (id == 0x000002C5) return "IptvVerifyOmac1Signature";
  if (id == 0x000002C6) return "IptvGetAesCtrTransform";
  if (id == 0x000002C7) return "SataCdRomRecordReset";
  if (id == 0x000002C8) return "XInputdSetTextDeviceKeyLocks";
  if (id == 0x000002C9) return "XInputdGetTextDeviceKeyLocks";
  if (id == 0x000002CA) return "XexActivationVerifyOwnership";
  if (id == 0x000002CB) return "XexDisableVerboseDbgPrint";
  if (id == 0x000002CC) return "SvodCreateDevice";
  if (id == 0x000002CD) return "RtlCaptureStackBackTrace";
  if (id == 0x000002CE) return "XeKeysRevokeUpdateDynamic";
  if (id == 0x000002CF) return "XexImportTraceEnable";
  if (id == 0x000002D0) return "ExRegisterXConfigNotification";
  if (id == 0x000002D1) return "XeKeysSecuritySetStat";
  if (id == 0x000002D2) return "VdQueryRealVideoMode";
  if (id == 0x000002D3) return "XexSetExecutablePrivilege";
  if (id == 0x000002D4) return "XAudioSuspendRenderDriverClients";
  if (id == 0x000002D5) return "IptvGetSessionKeyHash";
  if (id == 0x000002D6) return "VdSetCGMSState";
  if (id == 0x000002D7) return "VdSetSCMSState";
  if (id == 0x000002D8) return "KeFlushMultipleTb";
  if (id == 0x000002D9) return "VdGetOption";
  if (id == 0x000002DA) return "VdSetOption";
  if (id == 0x000002DB) return "UsbdBootEnumerationDoneEvent";
  if (id == 0x000002DC) return "StfsDeviceErrorEvent";
  if (id == 0x000002DD) return "ExTryToAcquireReadWriteLockExclusive";
  if (id == 0x000002DE) return "ExTryToAcquireReadWriteLockShared";
  if (id == 0x000002DF) return "XexSetLastKdcTime";
  if (id == 0x000002E0) return "XInputdControl";
  if (id == 0x000002E1) return "RmcDeviceRequest";
  if (id == 0x000002E2) return "LDIResetDecompression";
  if (id == 0x000002E3) return "NicRegisterDevice";
  if (id == 0x000002E4) return "UsbdAddDeviceComplete";
  if (id == 0x000002E5) return "UsbdCancelAsyncTransfer";
  if (id == 0x000002E6) return "UsbdGetDeviceSpeed";
  if (id == 0x000002E7) return "UsbdGetDeviceTopology";
  if (id == 0x000002E8) return "UsbdGetEndpointDescriptor";
  if (id == 0x000002E9) return "UsbdIsDeviceAuthenticated";
  if (id == 0x000002EA) return "UsbdOpenDefaultEndpoint";
  if (id == 0x000002EB) return "UsbdOpenEndpoint";
  if (id == 0x000002EC) return "UsbdQueueAsyncTransfer";
  if (id == 0x000002ED) return "UsbdQueueCloseDefaultEndpoint";
  if (id == 0x000002EE) return "UsbdQueueCloseEndpoint";
  if (id == 0x000002EF) return "UsbdRemoveDeviceComplete";
  if (id == 0x000002F0) return "KeRemoveQueueApc";
  if (id == 0x000002F1) return "UsbdDriverLoadRequiredEvent";
  if (id == 0x000002F2) return "UsbdGetRequiredDrivers";
  if (id == 0x000002F3) return "UsbdRegisterDriverObject";
  if (id == 0x000002F4) return "UsbdUnregisterDriverObject";
  if (id == 0x000002F5) return "UsbdCallAndBlockOnDpcRoutine";
  if (id == 0x000002F6) return "UsbdResetDevice";
  if (id == 0x000002F7) return "UsbdGetDeviceDescriptor";
  if (id == 0x000002F8) return "NomnilGetExtension";
  if (id == 0x000002F9) return "NomnilStartCloseDevice";
  if (id == 0x000002FA) return "WifiBeginAuthentication";
  if (id == 0x000002FB) return "WifiCheckCounterMeasures";
  if (id == 0x000002FC) return "WifiChooseAuthenCipherSetFromBSSID";
  if (id == 0x000002FD) return "WifiCompleteAuthentication";
  if (id == 0x000002FE) return "WifiGetAssociationIE";
  if (id == 0x000002FF) return "WifiOnMICError";
  if (id == 0x00000300) return "WifiPrepareAuthenticationContext";
  if (id == 0x00000301) return "WifiRecvEAPOLPacket";
  if (id == 0x00000302) return "WifiDeduceNetworkType";
  if (id == 0x00000303) return "NicUnregisterDevice";
  if (id == 0x00000304) return "DumpXitThread";
  if (id == 0x00000305) return "XInputdSetWifiChannel";
  if (id == 0x00000306) return "NomnilSetLed";
  if (id == 0x00000307) return "WifiCalculateRegulatoryDomain";
  if (id == 0x00000308) return "WifiSelectAdHocChannel";
  if (id == 0x00000309) return "WifiChannelToFrequency";
  if (id == 0x0000030A) return "MmGetPoolPagesType";
  if (id == 0x0000030B) return "ExExpansionInstall";
  if (id == 0x0000030C) return "ExExpansionCall";
  if (id == 0x0000030D) return "PsCamDeviceRequest";
  if (id == 0x0000030E) return "McaDeviceRequest";
  if (id == 0x0000030F) return "DetroitDeviceRequest";
  if (id == 0x00000310) return "XeCryptSha256Init";
  if (id == 0x00000311) return "XeCryptSha256Update";
  if (id == 0x00000312) return "XeCryptSha256Final";
  if (id == 0x00000313) return "XeCryptSha256";
  if (id == 0x00000314) return "XeCryptSha384Init";
  if (id == 0x00000315) return "XeCryptSha384Update";
  if (id == 0x00000316) return "XInputdGetDevicePid";
  if (id == 0x00000317) return "HalGetNotedArgonErrors";
  if (id == 0x00000318) return "XeCryptSha384Final";
  if (id == 0x00000319) return "HalReadArgonEeprom";
  if (id == 0x0000031A) return "HalWriteArgonEeprom";
  if (id == 0x0000031B) return "XeKeysFcrtLoad";
  if (id == 0x0000031C) return "XeKeysFcrtSave";
  if (id == 0x0000031D) return "XeKeysFcrtSet";
  if (id == 0x0000031E) return "XeCryptSha384";
  if (id == 0x0000031F) return "XeCryptSha512Init";
  if (id == 0x00000320) return "XAudioRegisterRenderDriverMECClient";
  if (id == 0x00000321) return "XAudioUnregisterRenderDriverMECClient";
  if (id == 0x00000322) return "XAudioCaptureRenderDriverFrame";
  if (id == 0x00000323) return "XeCryptSha512Update";
  if (id == 0x00000324) return "XeCryptSha512Final";
  if (id == 0x00000325) return "XeCryptSha512";
  if (id == 0x00000326) return "XeCryptBnQwNeCompare";
  if (id == 0x00000327) return "XVoicedGetDirectionalData";
  if (id == 0x00000328) return "DrvSetMicArrayStartCallback";
  if (id == 0x00000329) return "DevAuthGetStatistics";
  if (id == 0x0000032A) return "NullCableRequest";
  if (id == 0x0000032B) return "XeKeysRevokeIsDeviceRevoked";
  if (id == 0x0000032C) return "DumpUpdateDumpSettings";
  if (id == 0x0000032D) return "EtxConsumerDisableEventType";
  if (id == 0x0000032E) return "EtxConsumerEnableEventType";
  if (id == 0x0000032F) return "EtxConsumerProcessLogs";
  if (id == 0x00000330) return "EtxConsumerRegister";
  if (id == 0x00000331) return "EtxConsumerUnregister";
  if (id == 0x00000332) return "EtxProducerLog";
  if (id == 0x00000333) return "EtxProducerLogV";
  if (id == 0x00000334) return "EtxProducerRegister";
  if (id == 0x00000335) return "EtxProducerUnregister";
  if (id == 0x00000336) return "EtxConsumerFlushBuffers";
  if (id == 0x00000337) return "EtxProducerLogXwpp";
  if (id == 0x00000338) return "EtxProducerLogXwppV";
  if (id == 0x00000339) return "UsbdEnableDisableRootHubPort";
  if (id == 0x0000033A) return "EtxBufferRegister";
  if (id == 0x0000033B) return "EtxBufferUnregister";
  if (id == 0x0000033C) return "DumpRegisterDedicatedDataBlock";
  if (id == 0x0000033D) return "XeKeysDvdAuthExSave";
  if (id == 0x0000033E) return "XeKeysDvdAuthExInstall";
  if (id == 0x0000033F) return "XexShimDisable";
  if (id == 0x00000340) return "XexShimEnable";
  if (id == 0x00000341) return "XexShimEntryDisable";
  if (id == 0x00000342) return "XexShimEntryEnable";
  if (id == 0x00000343) return "XexShimEntryRegister";
  if (id == 0x00000344) return "XexShimLock";
  if (id == 0x00000345) return "XboxKrnlVersion4Digit";
  if (id == 0x00000346) return "XeKeysObfuscateEx";
  if (id == 0x00000347) return "XeKeysUnObfuscateEx";
  if (id == 0x00000348) return "XexTitleHash";
  if (id == 0x00000349) return "XexTitleHashClose";
  if (id == 0x0000034A) return "XexTitleHashContinue";
  if (id == 0x0000034B) return "XexTitleHashOpen";
  if (id == 0x0000034C) return "XAudioGetRenderDriverTic";
  if (id == 0x0000034D) return "XAudioEnableDucker";
  if (id == 0x0000034E) return "XAudioSetDuckerLevel";
  if (id == 0x0000034F) return "XAudioIsDuckerEnabled";
  if (id == 0x00000350) return "XAudioGetDuckerLevel";
  if (id == 0x00000351) return "XAudioGetDuckerThreshold";
  if (id == 0x00000352) return "XAudioSetDuckerThreshold";
  if (id == 0x00000353) return "XAudioGetDuckerAttackTime";
  if (id == 0x00000354) return "XAudioSetDuckerAttackTime";
  if (id == 0x00000355) return "XAudioGetDuckerReleaseTime";
  if (id == 0x00000356) return "XAudioSetDuckerReleaseTime";
  if (id == 0x00000357) return "XAudioGetDuckerHoldTime";
  if (id == 0x00000358) return "XAudioSetDuckerHoldTime";
  if (id == 0x00000359) return "DevAuthShouldAlwaysEnforce";
  if (id == 0x0000035A) return "XAudioGetUnderrunCount";
  if (id == 0x0000035B) return "DrvSetAudioLatencyCallback";
  if (id == 0x0000035C) return "XVoicedIsActiveProcess";
  if (id == 0x0000035D) return "KeExecuteOnProtectedStack";
  if (id == 0x0000035E) return "XeKeysVerifyPIRSSignature";
  if (id == 0x0000035F) return "XeCryptAesCtr";
  if (id == 0x00000360) return "XeCryptAesCbcMac";
  if (id == 0x00000361) return "XeCryptAesDmMac";
  if (id == 0x00000362) return "EmaExecute";
  if (id == 0x00000363) return "XeKeysGetTruncatedSecondaryConsoleId";
  if (id == 0x00000364) return "ExFreeDebugPool";
  if (id == 0x00000365) return "VdQueryVideoCapabilities";
  if (id == 0x00000366) return "UsbdGetDeviceRootPortType";
  if (id == 0x00000367) return "VdGet3dVideoFormat";
  if (id == 0x00000368) return "VdGetWSS2Data";
  if (id == 0x00000369) return "VdSet3dVideoFormat";
  if (id == 0x0000036A) return "VdSetWSS2Data";
  if (id == 0x0000036B) return "XexReserveCodeBuffer";
  if (id == 0x0000036C) return "XexCommitCodeBuffer";
  if (id == 0x0000036D) return "RtlSetVectoredExceptionHandler";
  if (id == 0x0000036E) return "RtlClearVectoredExceptionHandler";
  if (id == 0x0000036F) return "XAudioSetProcessFrameCallback";
  if (id == 0x00000370) return "UsbdGetRootHubDeviceNode";
  if (id == 0x00000371) return "UsbdGetPortDeviceNode";
  if (id == 0x00000372) return "UsbdGetNatalHub";
  if (id == 0x00000373) return "UsbdGetNatalHardwareVersion";
  if (id == 0x00000374) return "UsbdNatalHubRegisterNotificationCallback";
  if (id == 0x00000375) return "KeCallAndBlockOnDpcRoutine";
  if (id == 0x00000376) return "KeCallAndWaitForDpcRoutine";
  if (id == 0x00000377) return "TidDeviceRequest";
  if (id == 0x00000378) return "DmPrintData";
  if (id == 0x00000379) return "VdSetStudioRGBMode";
  if (id == 0x0000037A) return "UsbdTitleDriverResetAllUnrecognizedPorts";
  if (id == 0x0000037B) return "UsbdTitleDriverSetUnrecognizedPort";
  if (id == 0x0000037C) return "UsbdResetEndpoint";
  if (id == 0x0000037D) return "UsbdSetTimer";
  if (id == 0x0000037E) return "UsbdCancelTimer";
  if (id == 0x0000037F) return "UsbdQueueIsochTransfer";
  if (id == 0x00000380) return "KeSetPageRelocationCallback";
  if (id == 0x00000381) return "XexRegisterUsermodeModule";
  if (id == 0x00000383) return "TitleDeviceAuthRequest";
  if (id == 0x00000384) return "KeRegisterSwapNotification";
  if (id == 0x00000385) return "XInputdGetFailedConnectionOrBind";
  if (id == 0x00000386) return "XInputdSetFailedConnectionOrBindCallback";
  if (id == 0x00000388) return "XInputdSetMinMaxAuthDelay";
  if (id == 0x00000389) return "VgcHandler_SetHandlers";
  if (id == 0x0000038A) return "VvcHandlerCancelTransfers";
  if (id == 0x0000038B) return "VvcHandlerRetrieveVoiceExtension";
  if (id == 0x0000038D) return "MmResetLowestAvailablePages";
  if (id == 0x00000394) return "VeSetHandlers";
  if (id == 0x00000395) return "HalConfigureVeDevice";
  if (id == 0x00000396) return "XeCryptSha224Init";
  if (id == 0x00000397) return "XeCryptAesCreateKeySchedule";
  if (id == 0x00000398) return "XeCryptAesEncryptOne";
  if (id == 0x00000399) return "XeCryptAesDecryptOne";
  if (id == 0x0000039A) return "XeCryptAesCbcEncrypt";
  if (id == 0x0000039B) return "XeCryptAesCbcDecrypt";
  if (id == 0x0000039C) return "XeCryptAesGcmInitialize";
  if (id == 0x0000039D) return "XeCryptAesGcmUpdate";
  if (id == 0x0000039E) return "XeCryptAesGcmFinalize";
  if (id == 0x0000039F) return "XeCryptEccGetCurveParameters";
  if (id == 0x000003A0) return "XeCryptEccEcdhGenerateKeypair";
  if (id == 0x000003A1) return "XeCryptEccEcdhExponentiate";
  if (id == 0x000003A2) return "XeCryptEccEcdsaGenerateSignature";
  if (id == 0x000003A3) return "XeCryptEccEcdsaVerifySignature";

  return nullptr;
}

const char* syscallNameGen(int id)
{
  if (id == 0x00000000) return "HvxGetVersions";
  if (id == 0x00000001) return "HvxStartupProcessors";
  if (id == 0x00000002) return "HvxQuiesceProcessor";
  if (id == 0x00000003) return "HvxFlushEntireTb";
  if (id == 0x00000004) return "HvxFlushSingleTb";
  if (id == 0x00000005) return "HvxRelocateAndFlush";
  if (id == 0x00000006) return "HvxGetSpecialPurposeRegister";
  if (id == 0x00000007) return "HvxSetSpecialPurposeRegister";
  if (id == 0x00000008) return "HvxGetSocRegister";
  if (id == 0x00000009) return "HvxSetSocRegister";
  if (id == 0x0000000A) return "HvxSetTimeBaseToZero";
  if (id == 0x0000000B) return "HvxZeroPage";
  if (id == 0x0000000C) return "HvxFlushDcacheRange";
  if (id == 0x0000000D) return "HvxPostOutput";
  if (id == 0x0000000E) return "HvxEnablePPUPerformanceMonitor";
  if (id == 0x0000000F) return "HvxGetImagePageTableEntry";
  if (id == 0x00000010) return "HvxSetImagePageTableEntry";
  if (id == 0x00000011) return "HvxCreateImageMapping";
  if (id == 0x00000012) return "HvxMapImagePage";
  if (id == 0x00000013) return "HvxCompleteImageMapping";
  if (id == 0x00000014) return "HvxLoadImageData";
  if (id == 0x00000015) return "HvxFinishImageDataLoad";
  if (id == 0x00000016) return "HvxStartResolveImports";
  if (id == 0x00000017) return "HvxResolveImports";
  if (id == 0x00000018) return "HvxFinishImageLoad";
  if (id == 0x00000019) return "HvxAbandonImageLoad";
  if (id == 0x0000001A) return "HvxUnmapImagePages";
  if (id == 0x0000001B) return "HvxUnmapImage";
  if (id == 0x0000001C) return "HvxUnmapImageRange";
  if (id == 0x0000001D) return "HvxCreateUserMode";
  if (id == 0x0000001E) return "HvxDeleteUserMode";
  if (id == 0x0000001F) return "HvxFlushUserModeTb";
  if (id == 0x00000020) return "HvxSetPowerMode";
  if (id == 0x00000021) return "HvxShadowBoot";
  if (id == 0x00000022) return "HvxBlowFuses";
  if (id == 0x00000023) return "HvxFsbInterrupt";
  if (id == 0x00000024) return "HvxLockL2";
  if (id == 0x00000025) return "HvxDvdAuthBuildNVPage";
  if (id == 0x00000026) return "HvxDvdAuthVerifyNVPage";
  if (id == 0x00000027) return "HvxDvdAuthRecordAuthenticationPage";
  if (id == 0x00000028) return "HvxDvdAuthRecordXControl";
  if (id == 0x00000029) return "HvxDvdAuthGetAuthPage";
  if (id == 0x0000002A) return "HvxDvdAuthVerifyAuthPage";
  if (id == 0x0000002B) return "HvxDvdAuthGetNextLBAIndex";
  if (id == 0x0000002C) return "HvxDvdAuthVerifyLBA";
  if (id == 0x0000002D) return "HvxDvdAuthClearDiscAuthInfo";
  if (id == 0x0000002E) return "HvxKeysInitialize";
  if (id == 0x0000002F) return "HvxKeysGetKeyProperties";
  if (id == 0x00000030) return "HvxKeysGetStatus";
  if (id == 0x00000031) return "HvxKeysGenerateRandomKey";
  if (id == 0x00000032) return "HvxKeysGetFactoryChallenge";
  if (id == 0x00000033) return "HvxKeysSetFactoryResponse";
  if (id == 0x00000034) return "HvxKeysSaveBootLoader";
  if (id == 0x00000035) return "HvxKeysSaveKeyVault";
  if (id == 0x00000036) return "HvxKeysSetKey";
  if (id == 0x00000037) return "HvxKeysGetKey";
  if (id == 0x00000038) return "HvxKeysGetDigest";
  if (id == 0x00000039) return "HvxKeysRsaPrvCrypt";
  if (id == 0x0000003A) return "HvxKeysHmacSha";
  if (id == 0x0000003B) return "HvxKeysAesCbc";
  if (id == 0x0000003C) return "HvxKeysDes2Cbc";
  if (id == 0x0000003D) return "HvxKeysDesCbc";
  if (id == 0x0000003E) return "HvxKeysObscureKey";
  if (id == 0x0000003F) return "HvxKeysSaveSystemUpdate";
  if (id == 0x00000040) return "HvxKeysExecute";
  if (id == 0x00000041) return "HvxDvdAuthTestMode";
  if (id == 0x00000042) return "HvxEnableTimebase";
  if (id == 0x00000043) return "HvxHdcpCalculateMi";
  if (id == 0x00000044) return "HvxHdcpCalculateAKsvSignature";
  if (id == 0x00000045) return "HvxHdcpCalculateBKsvSignature";
  if (id == 0x00000046) return "HvxSetRevocationList";
  if (id == 0x00000047) return "HvxEncryptedReserveAllocation";
  if (id == 0x00000048) return "HvxEncryptedReleaseAllocation";
  if (id == 0x00000049) return "HvxEncryptedEncryptAllocation";
  if (id == 0x0000004A) return "HvxEncryptedSweepAddressRange";
  if (id == 0x0000004B) return "HvxKeysExCreateKeyVault";
  if (id == 0x0000004C) return "HvxKeysExLoadKeyVault";
  if (id == 0x0000004D) return "HvxKeysExSaveKeyVault";
  if (id == 0x0000004E) return "HvxKeysExSetKey";
  if (id == 0x0000004F) return "HvxKeysExGetKey";
  if (id == 0x00000050) return "HvxGetUpdateSequence";
  if (id == 0x00000051) return "HvxSecurityInitialize";
  if (id == 0x00000052) return "HvxSecurityLoadSettings";
  if (id == 0x00000053) return "HvxSecuritySaveSettings";
  if (id == 0x00000054) return "HvxSecuritySetDetected";
  if (id == 0x00000055) return "HvxSecurityGetDetected";
  if (id == 0x00000056) return "HvxSecuritySetActivated";
  if (id == 0x00000057) return "HvxSecurityGetActivated";
  if (id == 0x00000058) return "HvxSecuritySetStat";
  if (id == 0x00000059) return "HvxGetProtectedFlags";
  if (id == 0x0000005A) return "HvxSetProtectedFlag";
  if (id == 0x0000005B) return "HvxDvdAuthGetAuthResults";
  if (id == 0x0000005C) return "HvxDvdAuthSetDriveAuthResult";
  if (id == 0x0000005D) return "HvxDvdAuthSetDiscAuthResult";
  if (id == 0x0000005E) return "HvxImageTransformImageKey";
  if (id == 0x0000005F) return "HvxImageXexHeader";
  if (id == 0x00000060) return "HvxRevokeLoad";
  if (id == 0x00000061) return "HvxRevokeSave";
  if (id == 0x00000062) return "HvxRevokeUpdate";
  if (id == 0x00000063) return "HvxDvdAuthGetMediaId";
  if (id == 0x00000064) return "HvxKeysLoadKeyVault";
  if (id == 0x00000065) return "HvxXexActivationGetNonce";
  if (id == 0x00000066) return "HvxXexActivationSetLicense";
  if (id == 0x00000067) return "HvxXexActivationVerifyOwnership";
  if (id == 0x00000068) return "HvxIptvSetBoundaryKey";
  if (id == 0x00000069) return "HvxIptvSetSessionKey";
  if (id == 0x0000006A) return "HvxIptvVerifyOmac1Signature";
  if (id == 0x0000006B) return "HvxIptvGetAesCtrTransform";
  if (id == 0x0000006C) return "HvxIptvGetSessionKeyHash";
  if (id == 0x0000006D) return "HvxImageDvdEmulationMode";
  if (id == 0x0000006E) return "HvxImageUserMode";
  if (id == 0x0000006F) return "HvxImageShim";
  if (id == 0x00000070) return "HvxExpansionInstall";
  if (id == 0x00000071) return "HvxExpansionCall";
  if (id == 0x00000072) return "HvxDvdAuthFwcr";
  if (id == 0x00000073) return "HvxDvdAuthFcrt";
  if (id == 0x00000074) return "HvxDvdAuthEx";
  if (id == 0x00000075) return "HvxTest";

  return nullptr;
}

// <= 1640 only
const char* driversNameGen(int id)
{
  if (id == 0x00000001) return "VdBlockUntilGUIIdle";
  if (id == 0x00000002) return "VdCallGraphicsNotificationRoutines";
  if (id == 0x00000003) return "VdEdramHeap";
  if (id == 0x00000004) return "VdSetColorProfileAdjustment";
  if (id == 0x00000005) return "VdEnableDisablePowerSavingMode";
  if (id == 0x00000006) return "VdEnableRingBufferRPtrWriteBack";
  if (id == 0x00000008) return "VdGetCurrentDisplayInformation";
  if (id == 0x00000009) return "VdGetDefaultGammaTable";
  if (id == 0x0000000A) return "VdGetDefaultMEInitCommand";
  if (id == 0x0000000B) return "VdGetGraphicsAsicID";
  if (id == 0x0000000C) return "VdGetSystemCommandBuffer";
  if (id == 0x0000000D) return "VdGlobalDevice";
  if (id == 0x0000000E) return "VdInitializeEngines";
  if (id == 0x0000000F) return "VdInitializeRingBuffer";
  if (id == 0x00000010) return "VdInitializeScaler";
  if (id == 0x00000011) return "VdInitializeScalerCommandBuffer";
  if (id == 0x00000012) return "VdIsHSIOTrainingSucceeded";
  if (id == 0x00000013) return "VdQuerySystemCommandBuffer";
  if (id == 0x00000014) return "VdRegisterGraphicsNotification";
  if (id == 0x00000015) return "VdSetDisplayMode";
  if (id == 0x00000016) return "VdGenerateGPUCSCCoefficients";
  if (id == 0x00000017) return "VdSetGraphicsInterruptCallback";
  if (id == 0x00000018) return "VdSetSystemCommandBuffer";
  if (id == 0x00000019) return "?VdSetSystemCommandBufferGpuIdentifierAddress@@YAXPAK@Z";
  if (id == 0x0000001A) return "VdShutdownEngines";
  if (id == 0x0000001B) return "VdTurnDisplayOff";
  if (id == 0x0000001C) return "VdTurnDisplayOn";
  if (id == 0x0000001D) return "XVoicedSubmitPacket";
  if (id == 0x0000001E) return "XVoicedClose";
  if (id == 0x0000001F) return "XVoicedActivate";
  if (id == 0x00000020) return "XInputdGetCapabilities";
  if (id == 0x00000021) return "XInputdReadState";
  if (id == 0x00000022) return "XInputdWriteState";
  if (id == 0x00000023) return "XInputdNotify";
  if (id == 0x00000024) return "XInputdRawState";
  if (id == 0x00000025) return "HidGetCapabilities";
  if (id == 0x00000026) return "HidReadKeys";
  if (id == 0x00000027) return "XAudioRenderDriverInitialize";
  if (id == 0x00000028) return "XAudioRegisterRenderDriverClient";
  if (id == 0x00000029) return "XAudioUnregisterRenderDriverClient";
  if (id == 0x0000002A) return "XAudioSubmitRenderDriverFrame";
  if (id == 0x0000002B) return "XAudioRenderDriverLock";
  if (id == 0x0000002C) return "XAudioGetVoiceCategoryVolumeChangeMask";
  if (id == 0x0000002D) return "XAudioGetVoiceCategoryVolume";
  if (id == 0x0000002E) return "XAudioSetVoiceCategoryVolume";
  if (id == 0x0000002F) return "XAudioBeginDolbyDigitalBypassMode";
  if (id == 0x00000030) return "XAudioEndDolbyDigitalBypassMode";
  if (id == 0x00000031) return "XAudioSubmitDolbyDigitalPacket";
  if (id == 0x00000032) return "NicSetUnicastAddress";
  if (id == 0x00000033) return "NicAttach";
  if (id == 0x00000034) return "NicDetach";
  if (id == 0x00000035) return "NicXmit";
  if (id == 0x00000036) return "NicUpdateMcastMembership";
  if (id == 0x00000037) return "NicFlushXmitQueue";
  if (id == 0x00000038) return "NicShutdown";
  if (id == 0x00000039) return "NicGetLinkState";
  if (id == 0x0000003A) return "NicGetStats";
  if (id == 0x0000003B) return "NicReadAlphaNicFactoryAddress";
  if (id == 0x0000003C) return "DrvSetSysReqCallback";
  if (id == 0x0000003D) return "DrvSetUserBindingCallback";
  if (id == 0x0000003E) return "DrvSetContentStorageCallback";
  if (id == 0x0000003F) return "DrvSetAutobind";
  if (id == 0x00000040) return "MtpdBeginTransaction";
  if (id == 0x00000041) return "MtpdCancelTransaction";
  if (id == 0x00000042) return "MtpdEndTransaction";
  if (id == 0x00000043) return "MtpdGetCurrentDevices";
  if (id == 0x00000044) return "MtpdReadData";
  if (id == 0x00000045) return "MtpdReadEvent";
  if (id == 0x00000046) return "MtpdResetDevice";
  if (id == 0x00000047) return "MtpdSendData";
  if (id == 0x00000048) return "XUsbcamSetCaptureMode";
  if (id == 0x00000049) return "XUsbcamGetConfig";
  if (id == 0x0000004A) return "XUsbcamGetHWConfig";
  if (id == 0x0000004B) return "XUsbcamSetConfig";
  if (id == 0x0000004C) return "XUsbcamGetState";
  if (id == 0x0000004D) return "XUsbcamReadFrame";
  if (id == 0x0000004E) return "XUsbcamSnapshot";
  if (id == 0x0000004F) return "XMACreateContext";
  if (id == 0x00000050) return "XMAInitializeContext";
  if (id == 0x00000051) return "XMAReleaseContext";
  if (id == 0x00000052) return "XMAEnableContext";
  if (id == 0x00000053) return "XMADisableContext";
  if (id == 0x00000054) return "XMAGetOutputBufferWriteOffset";
  if (id == 0x00000055) return "XMASetOutputBufferReadOffset";
  if (id == 0x00000056) return "XMAGetOutputBufferReadOffset";
  if (id == 0x00000057) return "XMASetOutputBufferValid";
  if (id == 0x00000058) return "XMAIsOutputBufferValid";
  if (id == 0x00000059) return "XMASetInputBuffer0Valid";
  if (id == 0x0000005A) return "XMAIsInputBuffer0Valid";
  if (id == 0x0000005B) return "XMASetInputBuffer1Valid";
  if (id == 0x0000005C) return "XMAIsInputBuffer1Valid";
  if (id == 0x0000005D) return "XMASetInputBuffer0";
  if (id == 0x0000005E) return "XMASetInputBuffer1";
  if (id == 0x0000005F) return "XMAGetPacketMetadata";
  if (id == 0x00000060) return "XMABlockWhileInUse";
  if (id == 0x00000061) return "XMASetLoopData";
  if (id == 0x00000062) return "XMASetInputBufferReadOffset";
  if (id == 0x00000063) return "VdSetDisplayModeOverride";
  if (id == 0x00000064) return "VdGetDisplayModeOverride";
  if (id == 0x00000065) return "XInputdGetDeviceStats";
  if (id == 0x00000066) return "?VdReadDVERegisterUlong@@YAKK@Z";
  if (id == 0x00000067) return "?VdWriteDVERegisterUlong@@YAXKK@Z";
  if (id == 0x00000068) return "VdEnableClosedCaption";
  if (id == 0x00000069) return "VdSendClosedCaptionData";
  if (id == 0x0000006A) return "VdGetClosedCaptionReadyStatus";
  if (id == 0x0000006B) return "VdSetCGMSOption";
  if (id == 0x0000006C) return "?VdSetWSSData@@YAXU_VD_WSS_DATA@@@Z";
  if (id == 0x0000006D) return "VdSetMacrovisionOption";
  if (id == 0x0000006E) return "XAudioQueryDriverPerformance";
  if (id == 0x0000006F) return "VdReadWriteHSIOCalibrationFlag";
  if (id == 0x00000070) return "VdHSIOCalibrationLock";
  if (id == 0x00000071) return "VdGetCurrentDisplayGamma";
  if (id == 0x00000072) return "NicGetOpt";
  if (id == 0x00000073) return "NicSetOpt";
  if (id == 0x00000074) return "XAudioGetRenderDriverThread";
  if (id == 0x00000075) return "VdSetWSSOption";
  if (id == 0x00000076) return "MtpdVerifyProximity";
  if (id == 0x00000077) return "?VdDisplayFatalError@@YAXK@Z";

  return nullptr;
}

// <= 1640 only
const char* xnetNameGen(int id)
{
  if (id == 0x00000001) return "NetDll_WSAStartup";
  if (id == 0x00000002) return "NetDll_WSACleanup";
  if (id == 0x00000003) return "NetDll_socket";
  if (id == 0x00000004) return "NetDll_closesocket";
  if (id == 0x00000005) return "NetDll_shutdown";
  if (id == 0x00000006) return "NetDll_ioctlsocket";
  if (id == 0x00000007) return "NetDll_setsockopt";
  if (id == 0x00000008) return "NetDll_getsockopt";
  if (id == 0x00000009) return "NetDll_getsockname";
  if (id == 0x0000000A) return "NetDll_getpeername";
  if (id == 0x0000000B) return "NetDll_bind";
  if (id == 0x0000000C) return "NetDll_connect";
  if (id == 0x0000000D) return "NetDll_listen";
  if (id == 0x0000000E) return "NetDll_accept";
  if (id == 0x0000000F) return "NetDll_select";
  if (id == 0x00000010) return "NetDll_WSAGetOverlappedResult";
  if (id == 0x00000011) return "NetDll_WSACancelOverlappedIO";
  if (id == 0x00000012) return "NetDll_recv";
  if (id == 0x00000013) return "NetDll_WSARecv";
  if (id == 0x00000014) return "NetDll_recvfrom";
  if (id == 0x00000015) return "NetDll_WSARecvFrom";
  if (id == 0x00000016) return "NetDll_send";
  if (id == 0x00000017) return "NetDll_WSASend";
  if (id == 0x00000018) return "NetDll_sendto";
  if (id == 0x00000019) return "NetDll_WSASendTo";
  if (id == 0x0000001A) return "NetDll_inet_addr";
  if (id == 0x0000001B) return "NetDll_WSAGetLastError";
  if (id == 0x0000001C) return "NetDll_WSASetLastError";
  if (id == 0x0000001D) return "NetDll_WSACreateEvent";
  if (id == 0x0000001E) return "NetDll_WSACloseEvent";
  if (id == 0x0000001F) return "NetDll_WSASetEvent";
  if (id == 0x00000020) return "NetDll_WSAResetEvent";
  if (id == 0x00000021) return "NetDll_WSAWaitForMultipleEvents";
  if (id == 0x00000022) return "NetDll___WSAFDIsSet";
  if (id == 0x00000023) return "NetDll_WSAEventSelect";
  if (id == 0x00000033) return "NetDll_XNetStartup";
  if (id == 0x00000034) return "NetDll_XNetCleanup";
  if (id == 0x00000035) return "NetDll_XNetRandom";
  if (id == 0x00000036) return "NetDll_XNetCreateKey";
  if (id == 0x00000037) return "NetDll_XNetRegisterKey";
  if (id == 0x00000038) return "NetDll_XNetUnregisterKey";
  if (id == 0x00000039) return "NetDll_XNetXnAddrToInAddr";
  if (id == 0x0000003A) return "NetDll_XNetServerToInAddr";
  if (id == 0x0000003B) return "NetDll_XNetTsAddrToInAddr";
  if (id == 0x0000003C) return "NetDll_XNetInAddrToXnAddr";
  if (id == 0x0000003D) return "NetDll_XNetInAddrToServer";
  if (id == 0x0000003E) return "NetDll_XNetInAddrToString";
  if (id == 0x0000003F) return "NetDll_XNetUnregisterInAddr";
  if (id == 0x00000040) return "NetDll_XNetXnAddrToMachineId";
  if (id == 0x00000041) return "NetDll_XNetConnect";
  if (id == 0x00000042) return "NetDll_XNetGetConnectStatus";
  if (id == 0x00000043) return "NetDll_XNetDnsLookup";
  if (id == 0x00000044) return "NetDll_XNetDnsRelease";
  if (id == 0x00000045) return "NetDll_XNetQosListen";
  if (id == 0x00000046) return "NetDll_XNetQosLookup";
  if (id == 0x00000047) return "NetDll_XNetQosServiceLookup";
  if (id == 0x00000048) return "NetDll_XNetQosRelease";
  if (id == 0x00000049) return "NetDll_XNetGetTitleXnAddr";
  if (id == 0x0000004A) return "NetDll_XNetGetDebugXnAddr";
  if (id == 0x0000004B) return "NetDll_XNetGetEthernetLinkStatus";
  if (id == 0x0000004C) return "NetDll_XNetGetBroadcastVersionStatus";
  if (id == 0x0000004D) return "NetDll_XNetQosGetListenStats";
  if (id == 0x0000004E) return "NetDll_XNetGetOpt";
  if (id == 0x0000004F) return "NetDll_XNetSetOpt";
  if (id == 0x00000065) return "NetDll_XnpLoadConfigParams";
  if (id == 0x00000066) return "NetDll_XnpSaveConfigParams";
  if (id == 0x00000067) return "NetDll_XnpConfigUPnP";
  if (id == 0x00000068) return "NetDll_XnpConfig";
  if (id == 0x00000069) return "NetDll_XnpGetConfigStatus";
  if (id == 0x0000006A) return "NetDll_XnpLoadMachineAccount";
  if (id == 0x0000006B) return "NetDll_XnpSaveMachineAccount";
  if (id == 0x0000006C) return "NetDll_XnpCapture";
  if (id == 0x0000006D) return "NetDll_XnpEthernetInterceptSetCallbacks";
  if (id == 0x0000006E) return "NetDll_XnpEthernetInterceptXmit";
  if (id == 0x0000006F) return "NetDll_XnpEthernetInterceptRecv";
  if (id == 0x00000070) return "NetDll_XnpLogonGetStatus";
  if (id == 0x00000071) return "NetDll_XnpLogonGetQFlags";
  if (id == 0x00000072) return "NetDll_XnpLogonSetQFlags";
  if (id == 0x00000073) return "NetDll_XnpLogonSetQEvent";
  if (id == 0x00000074) return "NetDll_XnpLogonClearQEvent";
  if (id == 0x00000075) return "NetDll_XnpLogonGetQVals";
  if (id == 0x00000076) return "NetDll_XnpLogonSetQVals";
  if (id == 0x00000077) return "NetDll_XnpLogonSetPState";
  if (id == 0x00000078) return "NetDll_XnpGetVlanXboxName";
  if (id == 0x00000079) return "NetDll_XnpSetVlanXboxName";
  if (id == 0x0000007A) return "NetDll_XnpGetActiveSocketList";
  if (id == 0x0000007B) return "NetDll_XnpNoteSystemTime";
  if (id == 0x00000097) return "NetDll_XmlDownloadStart";
  if (id == 0x00000098) return "NetDll_XmlDownloadContinue";
  if (id == 0x00000099) return "NetDll_XmlDownloadStop";
  if (id == 0x000000C9) return "NetDll_XHttpStartup";
  if (id == 0x000000CA) return "NetDll_XHttpShutdown";
  if (id == 0x000000CB) return "NetDll_XHttpOpen";
  if (id == 0x000000CC) return "NetDll_XHttpCloseHandle";
  if (id == 0x000000CD) return "NetDll_XHttpConnect";
  if (id == 0x000000CE) return "NetDll_XHttpSetStatusCallback";
  if (id == 0x000000CF) return "NetDll_XHttpOpenRequest";
  if (id == 0x000000D0) return "NetDll_XHttpOpenRequestUsingMemory";
  if (id == 0x000000D1) return "NetDll_XHttpSendRequest";
  if (id == 0x000000D2) return "NetDll_XHttpReceiveResponse";
  if (id == 0x000000D3) return "NetDll_XHttpQueryHeaders";
  if (id == 0x000000D4) return "NetDll_XHttpReadData";
  if (id == 0x000000D5) return "NetDll_XHttpWriteData";
  if (id == 0x000000D6) return "NetDll_XHttpQueryOption";
  if (id == 0x000000D7) return "NetDll_XHttpSetOption";
  if (id == 0x000000D8) return "NetDll_XHttpDoWork";
  if (id == 0x000000FB) return "NetDll_UpnpStartup";
  if (id == 0x000000FC) return "NetDll_UpnpCleanup";
  if (id == 0x000000FD) return "NetDll_UpnpSearchCreate";
  if (id == 0x000000FE) return "NetDll_UpnpSearchGetDevices";
  if (id == 0x000000FF) return "NetDll_UpnpDescribeCreate";
  if (id == 0x00000100) return "NetDll_UpnpDescribeGetResults";
  if (id == 0x00000101) return "NetDll_UpnpActionCreate";
  if (id == 0x00000102) return "NetDll_UpnpActionGetResults";
  if (id == 0x00000103) return "NetDll_UpnpEventCreate";
  if (id == 0x00000104) return "NetDll_UpnpEventGetCurrentState";
  if (id == 0x00000105) return "NetDll_UpnpEventUnsubscribe";
  if (id == 0x00000106) return "NetDll_UpnpDoWork";
  if (id == 0x00000107) return "NetDll_UpnpCloseHandle";
  if (id == 0x0000012D) return "XNetLogonGetLoggedOnUsers";
  if (id == 0x0000012E) return "XNetLogonGetNatType";
  if (id == 0x0000012F) return "XNetLogonTaskStart";
  if (id == 0x00000130) return "XNetLogonTaskClose";
  if (id == 0x00000131) return "XNetLogonTaskContinue";
  if (id == 0x00000132) return "XNetLogonGetServiceInfo";
  if (id == 0x00000133) return "XNetLogonGetUserPrivileges";
  if (id == 0x00000134) return "?XNetLogonSetConsoleCertificate@@YAHPBUCONSOLE_CERTIFICATE@@@Z";
  if (id == 0x00000135) return "XNetLogonGetMachineID";
  if (id == 0x00000136) return "XNetLogonGetTitleID";
  if (id == 0x00000137) return "XNetLogonGetTitleVersion";
  if (id == 0x00000138) return "XNetLogonGetServiceNetworkID";
  if (id == 0x00000139) return "XNetLogonGetDnsString";
  if (id == 0x0000013A) return "XNetLogonSetTitleID";

  return nullptr;
}

const char* xbox1krnlNameGen(int id)
{
  if (id == 1) return "AvGetSavedDataAddress";
  if (id == 2) return "AvSendTVEncoderOption";
  if (id == 3) return "AvSetDisplayMode";
  if (id == 4) return "AvSetSavedDataAddress";
  if (id == 5) return "DbgBreakPoint";
  if (id == 6) return "DbgBreakPointWithStatus";
  if (id == 7) return "DbgLoadImageSymbols";
  if (id == 8) return "DbgPrint";
  if (id == 9) return "HalReadSMCTrayState";
  if (id == 10) return "DbgPrompt";
  if (id == 11) return "DbgUnLoadImageSymbols";
  if (id == 12) return "ExAcquireReadWriteLockExclusive";
  if (id == 13) return "ExAcquireReadWriteLockShared";
  if (id == 14) return "ExAllocatePool";
  if (id == 15) return "ExAllocatePoolWithTag";
  if (id == 16) return "ExEventObjectType";
  if (id == 17) return "ExFreePool";
  if (id == 18) return "ExInitializeReadWriteLock";
  if (id == 19) return "ExInterlockedAddLargeInteger";
  if (id == 20) return "ExInterlockedAddLargeStatistic";
  if (id == 21) return "ExInterlockedCompareExchange64";
  if (id == 22) return "ExMutantObjectType";
  if (id == 23) return "ExQueryPoolBlockSize";
  if (id == 24) return "ExQueryNonVolatileSetting";
  if (id == 25) return "ExReadWriteRefurbInfo";
  if (id == 26) return "ExRaiseException";
  if (id == 27) return "ExRaiseStatus";
  if (id == 28) return "ExReleaseReadWriteLock";
  if (id == 29) return "ExSaveNonVolatileSetting";
  if (id == 30) return "ExSemaphoreObjectType";
  if (id == 31) return "ExTimerObjectType";
  if (id == 32) return "ExfInterlockedInsertHeadList";
  if (id == 33) return "ExfInterlockedInsertTailList";
  if (id == 34) return "ExfInterlockedRemoveHeadList";
  if (id == 35) return "FscGetCacheSize";
  if (id == 36) return "FscInvalidateIdleBlocks";
  if (id == 37) return "FscSetCacheSize";
  if (id == 38) return "HalClearSoftwareInterrupt";
  if (id == 39) return "HalDisableSystemInterrupt";
  if (id == 40) return "HalDiskCachePartitionCount";
  if (id == 41) return "HalDiskModelNumber";
  if (id == 42) return "HalDiskSerialNumber";
  if (id == 43) return "HalEnableSystemInterrupt";
  if (id == 44) return "HalGetInterruptVector";
  if (id == 45) return "HalReadSMBusValue";
  if (id == 46) return "HalReadWritePCISpace";
  if (id == 47) return "HalRegisterShutdownNotification";
  if (id == 48) return "HalRequestSoftwareInterrupt";
  if (id == 49) return "HalReturnToFirmware";
  if (id == 50) return "HalWriteSMBusValue";
  if (id == 51) return "InterlockedCompareExchange";
  if (id == 52) return "InterlockedDecrement";
  if (id == 53) return "InterlockedIncrement";
  if (id == 54) return "InterlockedExchange";
  if (id == 55) return "InterlockedExchangeAdd";
  if (id == 56) return "InterlockedFlushSList";
  if (id == 57) return "InterlockedPopEntrySList";
  if (id == 58) return "InterlockedPushEntrySList";
  if (id == 59) return "IoAllocateIrp";
  if (id == 60) return "IoBuildAsynchronousFsdRequest";
  if (id == 61) return "IoBuildDeviceIoControlRequest";
  if (id == 62) return "IoBuildSynchronousFsdRequest";
  if (id == 63) return "IoCheckShareAccess";
  if (id == 64) return "IoCompletionObjectType";
  if (id == 65) return "IoCreateDevice";
  if (id == 66) return "IoCreateFile";
  if (id == 67) return "IoCreateSymbolicLink";
  if (id == 68) return "IoDeleteDevice";
  if (id == 69) return "IoDeleteSymbolicLink";
  if (id == 70) return "IoDeviceObjectType";
  if (id == 71) return "IoFileObjectType";
  if (id == 72) return "IoFreeIrp";
  if (id == 73) return "IoInitializeIrp";
  if (id == 74) return "IoInvalidDeviceRequest";
  if (id == 75) return "IoQueryFileInformation";
  if (id == 76) return "IoQueryVolumeInformation";
  if (id == 77) return "IoQueueThreadIrp";
  if (id == 78) return "IoRemoveShareAccess";
  if (id == 79) return "IoSetIoCompletion";
  if (id == 80) return "IoSetShareAccess";
  if (id == 81) return "IoStartNextPacket";
  if (id == 82) return "IoStartNextPacketByKey";
  if (id == 83) return "IoStartPacket";
  if (id == 84) return "IoSynchronousDeviceIoControlRequest";
  if (id == 85) return "IoSynchronousFsdRequest";
  if (id == 86) return "IofCallDriver";
  if (id == 87) return "IofCompleteRequest";
  if (id == 88) return "KdDebuggerEnabled";
  if (id == 89) return "KdDebuggerNotPresent";
  if (id == 90) return "IoDismountVolume";
  if (id == 91) return "IoDismountVolumeByName";
  if (id == 92) return "KeAlertResumeThread";
  if (id == 93) return "KeAlertThread";
  if (id == 94) return "KeBoostPriorityThread";
  if (id == 95) return "KeBugCheck";
  if (id == 96) return "KeBugCheckEx";
  if (id == 97) return "KeCancelTimer";
  if (id == 98) return "KeConnectInterrupt";
  if (id == 99) return "KeDelayExecutionThread";
  if (id == 100) return "KeDisconnectInterrupt";
  if (id == 101) return "KeEnterCriticalRegion";
  if (id == 102) return "MmGlobalData";
  if (id == 103) return "KeGetCurrentIrql";
  if (id == 104) return "KeGetCurrentThread";
  if (id == 105) return "KeInitializeApc";
  if (id == 106) return "KeInitializeDeviceQueue";
  if (id == 107) return "KeInitializeDpc";
  if (id == 108) return "KeInitializeEvent";
  if (id == 109) return "KeInitializeInterrupt";
  if (id == 110) return "KeInitializeMutant";
  if (id == 111) return "KeInitializeQueue";
  if (id == 112) return "KeInitializeSemaphore";
  if (id == 113) return "KeInitializeTimerEx";
  if (id == 114) return "KeInsertByKeyDeviceQueue";
  if (id == 115) return "KeInsertDeviceQueue";
  if (id == 116) return "KeInsertHeadQueue";
  if (id == 117) return "KeInsertQueue";
  if (id == 118) return "KeInsertQueueApc";
  if (id == 119) return "KeInsertQueueDpc";
  if (id == 120) return "KeInterruptTime";
  if (id == 121) return "KeIsExecutingDpc";
  if (id == 122) return "KeLeaveCriticalRegion";
  if (id == 123) return "KePulseEvent";
  if (id == 124) return "KeQueryBasePriorityThread";
  if (id == 125) return "KeQueryInterruptTime";
  if (id == 126) return "KeQueryPerformanceCounter";
  if (id == 127) return "KeQueryPerformanceFrequency";
  if (id == 128) return "KeQuerySystemTime";
  if (id == 129) return "KeRaiseIrqlToDpcLevel";
  if (id == 130) return "KeRaiseIrqlToSynchLevel";
  if (id == 131) return "KeReleaseMutant";
  if (id == 132) return "KeReleaseSemaphore";
  if (id == 133) return "KeRemoveByKeyDeviceQueue";
  if (id == 134) return "KeRemoveDeviceQueue";
  if (id == 135) return "KeRemoveEntryDeviceQueue";
  if (id == 136) return "KeRemoveQueue";
  if (id == 137) return "KeRemoveQueueDpc";
  if (id == 138) return "KeResetEvent";
  if (id == 139) return "KeRestoreFloatingPointState";
  if (id == 140) return "KeResumeThread";
  if (id == 141) return "KeRundownQueue";
  if (id == 142) return "KeSaveFloatingPointState";
  if (id == 143) return "KeSetBasePriorityThread";
  if (id == 144) return "KeSetDisableBoostThread";
  if (id == 145) return "KeSetEvent";
  if (id == 146) return "KeSetEventBoostPriority";
  if (id == 147) return "KeSetPriorityProcess";
  if (id == 148) return "KeSetPriorityThread";
  if (id == 149) return "KeSetTimer";
  if (id == 150) return "KeSetTimerEx";
  if (id == 151) return "KeStallExecutionProcessor";
  if (id == 152) return "KeSuspendThread";
  if (id == 153) return "KeSynchronizeExecution";
  if (id == 154) return "KeSystemTime";
  if (id == 155) return "KeTestAlertThread";
  if (id == 156) return "KeTickCount";
  if (id == 157) return "KeTimeIncrement";
  if (id == 158) return "KeWaitForMultipleObjects";
  if (id == 159) return "KeWaitForSingleObject";
  if (id == 160) return "KfRaiseIrql";
  if (id == 161) return "KfLowerIrql";
  if (id == 162) return "KiBugCheckData";
  if (id == 163) return "KiUnlockDispatcherDatabase";
  if (id == 164) return "LaunchDataPage";
  if (id == 165) return "MmAllocateContiguousMemory";
  if (id == 166) return "MmAllocateContiguousMemoryEx";
  if (id == 167) return "MmAllocateSystemMemory";
  if (id == 168) return "MmClaimGpuInstanceMemory";
  if (id == 169) return "MmCreateKernelStack";
  if (id == 170) return "MmDeleteKernelStack";
  if (id == 171) return "MmFreeContiguousMemory";
  if (id == 172) return "MmFreeSystemMemory";
  if (id == 173) return "MmGetPhysicalAddress";
  if (id == 174) return "MmIsAddressValid";
  if (id == 175) return "MmLockUnlockBufferPages";
  if (id == 176) return "MmLockUnlockPhysicalPage";
  if (id == 177) return "MmMapIoSpace";
  if (id == 178) return "MmPersistContiguousMemory";
  if (id == 179) return "MmQueryAddressProtect";
  if (id == 180) return "MmQueryAllocationSize";
  if (id == 181) return "MmQueryStatistics";
  if (id == 182) return "MmSetAddressProtect";
  if (id == 183) return "MmUnmapIoSpace";
  if (id == 184) return "NtAllocateVirtualMemory";
  if (id == 185) return "NtCancelTimer";
  if (id == 186) return "NtClearEvent";
  if (id == 187) return "NtClose";
  if (id == 188) return "NtCreateDirectoryObject";
  if (id == 189) return "NtCreateEvent";
  if (id == 190) return "NtCreateFile";
  if (id == 191) return "NtCreateIoCompletion";
  if (id == 192) return "NtCreateMutant";
  if (id == 193) return "NtCreateSemaphore";
  if (id == 194) return "NtCreateTimer";
  if (id == 195) return "NtDeleteFile";
  if (id == 196) return "NtDeviceIoControlFile";
  if (id == 197) return "NtDuplicateObject";
  if (id == 198) return "NtFlushBuffersFile";
  if (id == 199) return "NtFreeVirtualMemory";
  if (id == 200) return "NtFsControlFile";
  if (id == 201) return "NtOpenDirectoryObject";
  if (id == 202) return "NtOpenFile";
  if (id == 203) return "NtOpenSymbolicLinkObject";
  if (id == 204) return "NtProtectVirtualMemory";
  if (id == 205) return "NtPulseEvent";
  if (id == 206) return "NtQueueApcThread";
  if (id == 207) return "NtQueryDirectoryFile";
  if (id == 208) return "NtQueryDirectoryObject";
  if (id == 209) return "NtQueryEvent";
  if (id == 210) return "NtQueryFullAttributesFile";
  if (id == 211) return "NtQueryInformationFile";
  if (id == 212) return "NtQueryIoCompletion";
  if (id == 213) return "NtQueryMutant";
  if (id == 214) return "NtQuerySemaphore";
  if (id == 215) return "NtQuerySymbolicLinkObject";
  if (id == 216) return "NtQueryTimer";
  if (id == 217) return "NtQueryVirtualMemory";
  if (id == 218) return "NtQueryVolumeInformationFile";
  if (id == 219) return "NtReadFile";
  if (id == 220) return "NtReadFileScatter";
  if (id == 221) return "NtReleaseMutant";
  if (id == 222) return "NtReleaseSemaphore";
  if (id == 223) return "NtRemoveIoCompletion";
  if (id == 224) return "NtResumeThread";
  if (id == 225) return "NtSetEvent";
  if (id == 226) return "NtSetInformationFile";
  if (id == 227) return "NtSetIoCompletion";
  if (id == 228) return "NtSetSystemTime";
  if (id == 229) return "NtSetTimerEx";
  if (id == 230) return "NtSignalAndWaitForSingleObjectEx";
  if (id == 231) return "NtSuspendThread";
  if (id == 232) return "NtUserIoApcDispatcher";
  if (id == 233) return "NtWaitForSingleObject";
  if (id == 234) return "NtWaitForSingleObjectEx";
  if (id == 235) return "NtWaitForMultipleObjectsEx";
  if (id == 236) return "NtWriteFile";
  if (id == 237) return "NtWriteFileGather";
  if (id == 238) return "NtYieldExecution";
  if (id == 239) return "ObCreateObject";
  if (id == 240) return "ObDirectoryObjectType";
  if (id == 241) return "ObInsertObject";
  if (id == 242) return "ObMakeTemporaryObject";
  if (id == 243) return "ObOpenObjectByName";
  if (id == 244) return "ObOpenObjectByPointer";
  if (id == 245) return "ObpObjectHandleTable";
  if (id == 246) return "ObReferenceObjectByHandle";
  if (id == 247) return "ObReferenceObjectByName";
  if (id == 248) return "ObReferenceObjectByPointer";
  if (id == 249) return "ObSymbolicLinkObjectType";
  if (id == 250) return "ObfDereferenceObject";
  if (id == 251) return "ObfReferenceObject";
  if (id == 252) return "PhyGetLinkState";
  if (id == 253) return "PhyInitialize";
  if (id == 254) return "PsCreateSystemThread";
  if (id == 255) return "PsCreateSystemThreadEx";
  if (id == 256) return "PsQueryStatistics";
  if (id == 257) return "PsSetCreateThreadNotifyRoutine";
  if (id == 258) return "PsTerminateSystemThread";
  if (id == 259) return "PsThreadObjectType";
  if (id == 260) return "RtlAnsiStringToUnicodeString";
  if (id == 261) return "RtlAppendStringToString";
  if (id == 262) return "RtlAppendUnicodeStringToString";
  if (id == 263) return "RtlAppendUnicodeToString";
  if (id == 264) return "RtlAssert";
  if (id == 265) return "RtlCaptureContext";
  if (id == 266) return "RtlCaptureStackBackTrace";
  if (id == 267) return "RtlCharToInteger";
  if (id == 268) return "RtlCompareMemory";
  if (id == 269) return "RtlCompareMemoryUlong";
  if (id == 270) return "RtlCompareString";
  if (id == 271) return "RtlCompareUnicodeString";
  if (id == 272) return "RtlCopyString";
  if (id == 273) return "RtlCopyUnicodeString";
  if (id == 274) return "RtlCreateUnicodeString";
  if (id == 275) return "RtlDowncaseUnicodeChar";
  if (id == 276) return "RtlDowncaseUnicodeString";
  if (id == 277) return "RtlEnterCriticalSection";
  if (id == 278) return "RtlEnterCriticalSectionAndRegion";
  if (id == 279) return "RtlEqualString";
  if (id == 280) return "RtlEqualUnicodeString";
  if (id == 281) return "RtlExtendedIntegerMultiply";
  if (id == 282) return "RtlExtendedLargeIntegerDivide";
  if (id == 283) return "RtlExtendedMagicDivide";
  if (id == 284) return "RtlFillMemory";
  if (id == 285) return "RtlFillMemoryUlong";
  if (id == 286) return "RtlFreeAnsiString";
  if (id == 287) return "RtlFreeUnicodeString";
  if (id == 288) return "RtlGetCallersAddress";
  if (id == 289) return "RtlInitAnsiString";
  if (id == 290) return "RtlInitUnicodeString";
  if (id == 291) return "RtlInitializeCriticalSection";
  if (id == 292) return "RtlIntegerToChar";
  if (id == 293) return "RtlIntegerToUnicodeString";
  if (id == 294) return "RtlLeaveCriticalSection";
  if (id == 295) return "RtlLeaveCriticalSectionAndRegion";
  if (id == 296) return "RtlLowerChar";
  if (id == 297) return "RtlMapGenericMask";
  if (id == 298) return "RtlMoveMemory";
  if (id == 299) return "RtlMultiByteToUnicodeN";
  if (id == 300) return "RtlMultiByteToUnicodeSize";
  if (id == 301) return "RtlNtStatusToDosError";
  if (id == 302) return "RtlRaiseException";
  if (id == 303) return "RtlRaiseStatus";
  if (id == 304) return "RtlTimeFieldsToTime";
  if (id == 305) return "RtlTimeToTimeFields";
  if (id == 306) return "RtlTryEnterCriticalSection";
  if (id == 307) return "RtlUlongByteSwap";
  if (id == 308) return "RtlUnicodeStringToAnsiString";
  if (id == 309) return "RtlUnicodeStringToInteger";
  if (id == 310) return "RtlUnicodeToMultiByteN";
  if (id == 311) return "RtlUnicodeToMultiByteSize";
  if (id == 312) return "RtlUnwind";
  if (id == 313) return "RtlUpcaseUnicodeChar";
  if (id == 314) return "RtlUpcaseUnicodeString";
  if (id == 315) return "RtlUpcaseUnicodeToMultiByteN";
  if (id == 316) return "RtlUpperChar";
  if (id == 317) return "RtlUpperString";
  if (id == 318) return "RtlUshortByteSwap";
  if (id == 319) return "RtlWalkFrameChain";
  if (id == 320) return "RtlZeroMemory";
  if (id == 321) return "XboxEEPROMKey";
  if (id == 322) return "XboxHardwareInfo";
  if (id == 323) return "XboxHDKey";
  if (id == 324) return "XboxKrnlVersion";
  if (id == 325) return "XboxSignatureKey";
  if (id == 326) return "XeImageFileName";
  if (id == 327) return "XeLoadSection";
  if (id == 328) return "XeUnloadSection";
  if (id == 329) return "READ_PORT_BUFFER_UCHAR";
  if (id == 330) return "READ_PORT_BUFFER_USHORT";
  if (id == 331) return "READ_PORT_BUFFER_ULONG";
  if (id == 332) return "WRITE_PORT_BUFFER_UCHAR";
  if (id == 333) return "WRITE_PORT_BUFFER_USHORT";
  if (id == 334) return "WRITE_PORT_BUFFER_ULONG";
  if (id == 335) return "XcSHAInit";
  if (id == 336) return "XcSHAUpdate";
  if (id == 337) return "XcSHAFinal";
  if (id == 338) return "XcRC4Key";
  if (id == 339) return "XcRC4Crypt";
  if (id == 340) return "XcHMAC";
  if (id == 341) return "XcPKEncPublic";
  if (id == 342) return "XcPKDecPrivate";
  if (id == 343) return "XcPKGetKeyLen";
  if (id == 344) return "XcVerifyPKCS1Signature";
  if (id == 345) return "XcModExp";
  if (id == 346) return "XcDESKeyParity";
  if (id == 347) return "XcKeyTable";
  if (id == 348) return "XcBlockCrypt";
  if (id == 349) return "XcBlockCryptCBC";
  if (id == 350) return "XcCryptService";
  if (id == 351) return "XcUpdateCrypto";
  if (id == 352) return "RtlRip";
  if (id == 353) return "XboxLANKey";
  if (id == 354) return "XboxAlternateSignatureKeys";
  if (id == 355) return "XePublicKeyData";
  if (id == 356) return "HalBootSMCVideoMode";
  if (id == 357) return "IdexChannelObject";
  if (id == 358) return "HalIsResetOrShutdownPending";
  if (id == 359) return "IoMarkIrpMustComplete";
  if (id == 360) return "HalInitiateShutdown";
  if (id == 361) return "RtlSnprintf";
  if (id == 362) return "RtlSprintf";
  if (id == 363) return "RtlVsnprintf";
  if (id == 364) return "RtlVsprintf";
  if (id == 365) return "HalEnableSecureTrayEject";
  if (id == 366) return "HalWriteSMCScratchRegister";
  if (id == 367) return "Undefined_0";
  if (id == 368) return "Undefined_1";
  if (id == 369) return "Undefined_2";
  if (id == 370) return "XProfpControl";
  if (id == 371) return "XProfpGetData";
  if (id == 372) return "IrtClientInitFast";
  if (id == 373) return "IrtSweep";
  if (id == 374) return "MmDbgAllocateMemory";
  if (id == 375) return "MmDbgFreeMemory";
  if (id == 376) return "MmDbgQueryAvailablePages";
  if (id == 377) return "MmDbgReleaseAddress";
  if (id == 378) return "MmDbgWriteCheck";

  return nullptr;
}

std::string DoNameGen(const std::string& libName, int id, int version)
{
  std::string lib = libName;
  auto pos = lib.find_first_of('.');
  if (pos != std::string::npos)
    lib = lib.substr(0, pos);
  pos = lib.find_last_of('\\');
  if (pos != std::string::npos && lib.length() > pos + 1)
    lib = lib.substr(pos + 1);
  pos = lib.find_last_of('/');
  if (pos != std::string::npos && lib.length() > pos + 1)
    lib = lib.substr(pos + 1);

  const char* name = 0;
  if (lib == "xbox1krnl")
    name = xbox1krnlNameGen(id);
  else if (lib == "connectx")
    name = connectxNameGen(id);
  else if (lib == "createprofile")
    name = createprofileNameGen(id);
  else if (lib == "vk")
    name = vkNameGen(id);
  else if (lib == "xam" || lib == "xamc" || lib == "xamd")
    name = xamNameGen(id, version);
  else if (lib == "xapi" || lib == "xapid")
    name = xapiNameGen(id);
  else if (lib == "xbdm")
    name = xbdmNameGen(id, version);
  else if (lib == "xboxkrnl")
    name = xboxkrnlNameGen(id, version);
  else if (lib == "syscall")
    name = syscallNameGen(id);
  else if (lib == "drivers" && version <= 1640)
    name = driversNameGen(id);
  else if (lib == "xnet" && version <= 1640)
    name = xnetNameGen(id);

  if (name)
    return std::string(name);

  std::stringstream ss;
  ss << lib << "_";
  ss << std::setfill('0') << std::setw(4) << std::hex << id;
  return ss.str();
}

```

`namegen_xtlid.cpp`:

```cpp
#include <string>
#include <sstream>
#include <iomanip>
#include <unordered_map>
#include <cstdint>

// Based on https://github.com/XboxDev/xtlid/blob/4c76295326efd4fa16c3298635909c9767c180f2/src/xtlid.xml

// Function mappings for D3DX8
std::unordered_map<uint32_t, std::string> functions_D3DX8 = {
  { 0x90001, "D3DXBoxBoundProbe" },
  { 0x90002, "D3DXCheckCubeTextureRequirements" },
  { 0x90003, "D3DXCheckTextureRequirements" },
  { 0x90004, "D3DXCheckVolumeTextureRequirements" },
  { 0x90005, "D3DXCleanMesh" },
  { 0x90006, "D3DXColorAdd" },
  { 0x90007, "D3DXColorAdjustContrast" },
  { 0x90008, "D3DXColorAdjustSaturation" },
  { 0x90009, "D3DXColorLerp" },
  { 0x9000a, "D3DXColorModulate" },
  { 0x9000b, "D3DXColorNegative" },
  { 0x9000c, "D3DXColorScale" },
  { 0x9000d, "D3DXColorSubtract" },
  { 0x9000e, "D3DXCompileEffect" },
  { 0x9000f, "D3DXCompileEffectFromFileA" },
  { 0x90010, "D3DXComputeBoundingBox" },
  { 0x90011, "D3DXComputeBoundingSphere" },
  { 0x90012, "D3DXComputeNormals" },
  { 0x90013, "D3DXCreateBox" },
  { 0x90014, "D3DXCreateBuffer" },
  { 0x90015, "D3DXCreateCubeTexture" },
  { 0x90016, "D3DXCreateCubeTextureFromFileA" },
  { 0x90017, "D3DXCreateCubeTextureFromFileExA" },
  { 0x90018, "D3DXCreateCubeTextureFromFileInMemory" },
  { 0x90019, "D3DXCreateCubeTextureFromFileInMemoryEx" },
  { 0x9001a, "D3DXCreateCylinder" },
  { 0x9001b, "D3DXCreateEffect" },
  { 0x9001c, "D3DXCreateMatrixStack" },
  { 0x9001d, "D3DXCreateMesh" },
  { 0x9001e, "D3DXCreateMeshFVF" },
  { 0x9001f, "D3DXCreatePMeshFromStream" },
  { 0x90020, "D3DXCreatePolygon" },
  { 0x90021, "D3DXCreateSkinMesh" },
  { 0x90022, "D3DXCreateSkinMeshFromMesh" },
  { 0x90023, "D3DXCreateSkinMeshFVF" },
  { 0x90024, "D3DXCreateSphere" },
  { 0x90025, "D3DXCreateSPMesh" },
  { 0x90026, "D3DXCreateTeapot" },
  { 0x90027, "D3DXCreateTexture" },
  { 0x90028, "D3DXCreateTextureFromFileA" },
  { 0x90029, "D3DXCreateTextureFromFileExA" },
  { 0x9002a, "D3DXCreateTextureFromFileInMemory" },
  { 0x9002b, "D3DXCreateTextureFromFileInMemoryEx" },
  { 0x9002c, "D3DXCreateTorus" },
  { 0x9002d, "D3DXCreateVolumeTexture" },
  { 0x9002e, "D3DXDeclaratorFromFVF" },
  { 0x9002f, "D3DXFilterCubeTexture" },
  { 0x90030, "D3DXFilterTexture" },
  { 0x90031, "D3DXFilterVolumeTexture" },
  { 0x90032, "D3DXFVFFromDeclarator" },
  { 0x90033, "D3DXGeneratePMesh" },
  { 0x90034, "D3DXGetDXT3DXT5" },
  { 0x90035, "D3DXIntersect" },
  { 0x90036, "D3DXLoadMeshFromX" },
  { 0x90037, "D3DXLoadMeshFromXof" },
  { 0x90038, "D3DXLoadSkinMeshFromXof" },
  { 0x90039, "D3DXLoadSurfaceFromFileA" },
  { 0x9003a, "D3DXLoadSurfaceFromFileInMemory" },
  { 0x9003b, "D3DXLoadSurfaceFromMemory" },
  { 0x9003c, "D3DXLoadSurfaceFromSurface" },
  { 0x9003d, "D3DXLoadVolumeFromMemory" },
  { 0x9003e, "D3DXLoadVolumeFromVolume" },
  { 0x9003f, "D3DXMatrixAffineTransformation" },
  { 0x90040, "D3DXMatrixfDeterminant" },
  { 0x90041, "D3DXMatrixIdentity" },
  { 0x90042, "D3DXMatrixInverse" },
  { 0x90043, "D3DXMatrixIsIdentity" },
  { 0x90044, "D3DXMatrixLookAtLH" },
  { 0x90045, "D3DXMatrixLookAtRH" },
  { 0x90046, "D3DXMatrixMultiply" },
  { 0x90047, "D3DXMatrixOrthoLH" },
  { 0x90048, "D3DXMatrixOrthoOffCenterLH" },
  { 0x90049, "D3DXMatrixOrthoOffCenterRH" },
  { 0x9004a, "D3DXMatrixOrthoRH" },
  { 0x9004b, "D3DXMatrixPerspectiveFovLH" },
  { 0x9004c, "D3DXMatrixPerspectiveFovRH" },
  { 0x9004d, "D3DXMatrixPerspectiveLH" },
  { 0x9004e, "D3DXMatrixPerspectiveOffCenterLH" },
  { 0x9004f, "D3DXMatrixPerspectiveOffCenterRH" },
  { 0x90050, "D3DXMatrixPerspectiveRH" },
  { 0x90051, "D3DXMatrixReflect" },
  { 0x90052, "D3DXMatrixRotationAxis" },
  { 0x90053, "D3DXMatrixRotationQuaternion" },
  { 0x90054, "D3DXMatrixRotationX" },
  { 0x90055, "D3DXMatrixRotationY" },
  { 0x90056, "D3DXMatrixRotationYawPitchRoll" },
  { 0x90057, "D3DXMatrixRotationZ" },
  { 0x90058, "D3DXMatrixScaling" },
  { 0x90059, "D3DXMatrixShadow" },
  { 0x9005a, "D3DXMatrixTransformation" },
  { 0x9005b, "D3DXMatrixTranslation" },
  { 0x9005c, "D3DXMatrixTranspose" },
  { 0x9005d, "D3DXPlaneDot" },
  { 0x9005e, "D3DXPlaneDotCoord" },
  { 0x9005f, "D3DXPlaneDotNormal" },
  { 0x90060, "D3DXPlaneFromPointNormal" },
  { 0x90061, "D3DXPlaneFromPoints" },
  { 0x90062, "D3DXPlaneIntersectLine" },
  { 0x90063, "D3DXPlaneNormalize" },
  { 0x90064, "D3DXPlaneTransform" },
  { 0x90065, "D3DXQuaternionBaryCentric" },
  { 0x90066, "D3DXQuaternionConjugate" },
  { 0x90067, "D3DXQuaternionDot" },
  { 0x90068, "D3DXQuaternionExp" },
  { 0x90069, "D3DXQuaternionIdentity" },
  { 0x9006a, "D3DXQuaternionInverse" },
  { 0x9006b, "D3DXQuaternionIsIdentity" },
  { 0x9006c, "D3DXQuaternionLength" },
  { 0x9006d, "D3DXQuaternionLengthSq" },
  { 0x9006e, "D3DXQuaternionLn" },
  { 0x9006f, "D3DXQuaternionMultiply" },
  { 0x90070, "D3DXQuaternionNormalize" },
  { 0x90071, "D3DXQuaternionRotationAxis" },
  { 0x90072, "D3DXQuaternionRotationMatrix" },
  { 0x90073, "D3DXQuaternionRotationYawPitchRoll" },
  { 0x90074, "D3DXQuaternionSlerp" },
  { 0x90075, "D3DXQuaternionSquad" },
  { 0x90076, "D3DXQuaternionToAxisAngle" },
  { 0x90077, "D3DXSaveMeshToX" },
  { 0x90078, "D3DXSetDXT3DXT5" },
  { 0x90079, "D3DXSimplifyMesh" },
  { 0x9007a, "D3DXSphereBoundProbe" },
  { 0x9007b, "D3DXTesselateMesh" },
  { 0x9007c, "D3DXValidMesh" },
  { 0x9007d, "D3DXVec2Add" },
  { 0x9007e, "D3DXVec2BaryCentric" },
  { 0x9007f, "D3DXVec2CatmullRom" },
  { 0x90080, "D3DXVec2CCW" },
  { 0x90081, "D3DXVec2Dot" },
  { 0x90082, "D3DXVec2Hermite" },
  { 0x90083, "D3DXVec2Length" },
  { 0x90084, "D3DXVec2LengthSq" },
  { 0x90085, "D3DXVec2Lerp" },
  { 0x90086, "D3DXVec2Maximize" },
  { 0x90087, "D3DXVec2Minimize" },
  { 0x90088, "D3DXVec2Normalize" },
  { 0x90089, "D3DXVec2Scale" },
  { 0x9008a, "D3DXVec2Subtract" },
  { 0x9008b, "D3DXVec2Transform" },
  { 0x9008c, "D3DXVec2TransformCoord" },
  { 0x9008d, "D3DXVec2TransformNormal" },
  { 0x9008e, "D3DXVec3Add" },
  { 0x9008f, "D3DXVec3BaryCentric" },
  { 0x90090, "D3DXVec3CatmullRom" },
  { 0x90091, "D3DXVec3Cross" },
  { 0x90092, "D3DXVec3Dot" },
  { 0x90093, "D3DXVec3Hermite" },
  { 0x90094, "D3DXVec3Length" },
  { 0x90095, "D3DXVec3LengthSq" },
  { 0x90096, "D3DXVec3Lerp" },
  { 0x90097, "D3DXVec3Maximize" },
  { 0x90098, "D3DXVec3Minimize" },
  { 0x90099, "D3DXVec3Normalize" },
  { 0x9009a, "D3DXVec3Project" },
  { 0x9009b, "D3DXVec3Scale" },
  { 0x9009c, "D3DXVec3Subtract" },
  { 0x9009d, "D3DXVec3Transform" },
  { 0x9009e, "D3DXVec3TransformCoord" },
  { 0x9009f, "D3DXVec3TransformNormal" },
  { 0x900a0, "D3DXVec3Unproject" },
  { 0x900a1, "D3DXVec4Add" },
  { 0x900a2, "D3DXVec4BaryCentric" },
  { 0x900a3, "D3DXVec4CatmullRom" },
  { 0x900a4, "D3DXVec4Cross" },
  { 0x900a5, "D3DXVec4Dot" },
  { 0x900a6, "D3DXVec4Hermite" },
  { 0x900a7, "D3DXVec4Length" },
  { 0x900a8, "D3DXVec4LengthSq" },
  { 0x900a9, "D3DXVec4Lerp" },
  { 0x900aa, "D3DXVec4Maximize" },
  { 0x900ab, "D3DXVec4Minimize" },
  { 0x900ac, "D3DXVec4Normalize" },
  { 0x900ad, "D3DXVec4Scale" },
  { 0x900ae, "D3DXVec4Subtract" },
  { 0x900af, "D3DXVec4Transform" },
  { 0x900b0, "D3DXWeldVertices" }
};

// Function mappings for DMUSIC
std::unordered_map<uint32_t, std::string> functions_DMUSIC = {
  { 0xa0001, "DirectMusicAlloc" },
  { 0xa0002, "DirectMusicCreateDefaultHeap" },
  { 0xa0003, "DirectMusicCreateDefaultPhysicalHeap" },
  { 0xa0004, "DirectMusicCreateFixedSizeHeap" },
  { 0xa0005, "DirectMusicCreateFixedSizePhysicalHeap" },
  { 0xa0006, "DirectMusicCreateInstance" },
  { 0xa0007, "DirectMusicDefaultFactory" },
  { 0xa0008, "DirectMusicDoWork" },
  { 0xa0009, "DirectMusicFree" },
  { 0xa000a, "DirectMusicInitialize" },
  { 0xa000b, "DirectMusicInitializeEx" },
  { 0xa000c, "DirectMusicInitializeFixedSizeHeaps" },
  { 0xa000d, "DirectMusicMemCheck" },
  { 0xa000e, "DirectMusicMemDump" },
  { 0xa000f, "DirectMusicPhysicalAlloc" },
  { 0xa0010, "DirectMusicPhysicalFree" },
  { 0xa0011, "DirectMusicSetDebugLevel" }
};

// Function mappings for DSOUND
std::unordered_map<uint32_t, std::string> functions_DSOUND = {
  { 0xb0001, "Ac97CreateMediaObject" },
  { 0xb0002, "DirectSoundCreate" },
  { 0xb0003, "DirectSoundCreateBuffer" },
  { 0xb0004, "DirectSoundCreateStream" },
  { 0xb0005, "DirectSoundDefaulMixBins_5Channel3D_PlusLFE" },
  { 0xb0006, "DirectSoundDefault3DBuffer" },
  { 0xb0007, "DirectSoundDefault3DListener" },
  { 0xb0008, "DirectSoundDefaultI3DL2Buffer" },
  { 0xb0009, "DirectSoundDefaultMixBins_3D" },
  { 0xb000a, "DirectSoundDefaultMixBins_4Channel" },
  { 0xb000b, "DirectSoundDefaultMixBins_5Channel3D" },
  { 0xb000c, "DirectSoundDefaultMixBins_6Channel" },
  { 0xb000d, "DirectSoundDefaultMixBins_Mono" },
  { 0xb000e, "DirectSoundDefaultMixBins_Stereo" },
  { 0xb000f, "DirectSoundDoWork" },
  { 0xb0010, "DirectSoundDumpMemoryUsage" },
  { 0xb0011, "DirectSoundGetSampleTime" },
  { 0xb0012, "DirectSoundI3DL2ListenerPreset_Alley" },
  { 0xb0013, "DirectSoundI3DL2ListenerPreset_Arena" },
  { 0xb0014, "DirectSoundI3DL2ListenerPreset_Auditorium" },
  { 0xb0015, "DirectSoundI3DL2ListenerPreset_Bathroom" },
  { 0xb0016, "DirectSoundI3DL2ListenerPreset_CarpetedHallway" },
  { 0xb0017, "DirectSoundI3DL2ListenerPreset_Cave" },
  { 0xb0018, "DirectSoundI3DL2ListenerPreset_City" },
  { 0xb0019, "DirectSoundI3DL2ListenerPreset_ConcertHall" },
  { 0xb001a, "DirectSoundI3DL2ListenerPreset_Default" },
  { 0xb001b, "DirectSoundI3DL2ListenerPreset_Default2" },
  { 0xb001c, "DirectSoundI3DL2ListenerPreset_Forest" },
  { 0xb001d, "DirectSoundI3DL2ListenerPreset_Generic" },
  { 0xb001e, "DirectSoundI3DL2ListenerPreset_Hallway" },
  { 0xb001f, "DirectSoundI3DL2ListenerPreset_Hangar" },
  { 0xb0020, "DirectSoundI3DL2ListenerPreset_LivingRoom" },
  { 0xb0021, "DirectSoundI3DL2ListenerPreset_Mountains" },
  { 0xb0022, "DirectSoundI3DL2ListenerPreset_NoReverb" },
  { 0xb0023, "DirectSoundI3DL2ListenerPreset_PaddedCell" },
  { 0xb0024, "DirectSoundI3DL2ListenerPreset_ParkingLot" },
  { 0xb0025, "DirectSoundI3DL2ListenerPreset_Plain" },
  { 0xb0026, "DirectSoundI3DL2ListenerPreset_Quarry" },
  { 0xb0027, "DirectSoundI3DL2ListenerPreset_Room" },
  { 0xb0028, "DirectSoundI3DL2ListenerPreset_SewerPipe" },
  { 0xb0029, "DirectSoundI3DL2ListenerPreset_StoneCorridor" },
  { 0xb002a, "DirectSoundI3DL2ListenerPreset_StoneRoom" },
  { 0xb002b, "DirectSoundI3DL2ListenerPreset_Underwater" },
  { 0xb002c, "DirectSoundOverrideSpeakerConfig" },
  { 0xb002d, "DirectSoundRequiredMixBins_3D" },
  { 0xb002e, "DirectSoundRequiredMixBins_5Channel3D" },
  { 0xb002f, "DirectSoundUseFullHRTF" },
  { 0xb0030, "DirectSoundUseFullHRTF4Channel" },
  { 0xb0031, "DirectSoundUseLightHRTF" },
  { 0xb0032, "DirectSoundUseLightHRTF4Channel" },
  { 0xb0033, "g_dwDirectSoundDebugBreakLevel" },
  { 0xb0034, "g_dwDirectSoundDebugLevel" },
  { 0xb0035, "g_pfnDirectSoundDebugCallback" },
  { 0xb0036, "IDirectSound_AddRef" },
  { 0xb0037, "IDirectSound_CommitDeferredSettings" },
  { 0xb0038, "IDirectSound_CommitEffectData" },
  { 0xb0039, "IDirectSound_Compact" },
  { 0xb003a, "IDirectSound_CreateSoundBuffer" },
  { 0xb003b, "IDirectSound_CreateSoundStream" },
  { 0xb003c, "IDirectSound_DownloadEffectsImage" },
  { 0xb003d, "IDirectSound_EnableHeadphones" },
  { 0xb003e, "IDirectSound_GetCaps" },
  { 0xb003f, "IDirectSound_GetEffectData" },
  { 0xb0040, "IDirectSound_GetOutputLevels" },
  { 0xb0041, "IDirectSound_GetSpeakerConfig" },
  { 0xb0042, "IDirectSound_GetTime" },
  { 0xb0043, "IDirectSound_QueryInterface" },
  { 0xb0044, "IDirectSound_QueryInterfaceC" },
  { 0xb0045, "IDirectSound_Release" },
  { 0xb0046, "IDirectSound_SetAllParameters" },
  { 0xb0047, "IDirectSound_SetCooperativeLevel" },
  { 0xb0048, "IDirectSound_SetDistanceFactor" },
  { 0xb0049, "IDirectSound_SetDopplerFactor" },
  { 0xb004a, "IDirectSound_SetEffectData" },
  { 0xb004b, "IDirectSound_SetI3DL2Listener" },
  { 0xb004c, "IDirectSound_SetMixBinHeadroom" },
  { 0xb004d, "IDirectSound_SetOrientation" },
  { 0xb004e, "IDirectSound_SetPosition" },
  { 0xb004f, "IDirectSound_SetRolloffFactor" },
  { 0xb0050, "IDirectSound_SetVelocity" },
  { 0xb0051, "IDirectSound_SynchPlayback" },
  { 0xb0052, "IDirectSoundBuffer_AddRef" },
  { 0xb0053, "IDirectSoundBuffer_GetCurrentPosition" },
  { 0xb0054, "IDirectSoundBuffer_GetStatus" },
  { 0xb0055, "IDirectSoundBuffer_GetVoiceProperties" },
  { 0xb0056, "IDirectSoundBuffer_Lock" },
  { 0xb0057, "IDirectSoundBuffer_Pause" },
  { 0xb0058, "IDirectSoundBuffer_PauseEx" },
  { 0xb0059, "IDirectSoundBuffer_Play" },
  { 0xb005a, "IDirectSoundBuffer_PlayEx" },
  { 0xb005b, "IDirectSoundBuffer_QueryInterface" },
  { 0xb005c, "IDirectSoundBuffer_QueryInterfaceC" },
  { 0xb005d, "IDirectSoundBuffer_Release" },
  { 0xb005e, "IDirectSoundBuffer_Restore" },
  { 0xb005f, "IDirectSoundBuffer_SetAllParameters" },
  { 0xb0060, "IDirectSoundBuffer_SetBufferData" },
  { 0xb0061, "IDirectSoundBuffer_SetConeAngles" },
  { 0xb0062, "IDirectSoundBuffer_SetConeOrientation" },
  { 0xb0063, "IDirectSoundBuffer_SetConeOutsideVolume" },
  { 0xb0064, "IDirectSoundBuffer_SetCurrentPosition" },
  { 0xb0065, "IDirectSoundBuffer_SetDistanceFactor" },
  { 0xb0066, "IDirectSoundBuffer_SetDopplerFactor" },
  { 0xb0067, "IDirectSoundBuffer_SetEG" },
  { 0xb0068, "IDirectSoundBuffer_SetFilter" },
  { 0xb0069, "IDirectSoundBuffer_SetFormat" },
  { 0xb006a, "IDirectSoundBuffer_SetFrequency" },
  { 0xb006b, "IDirectSoundBuffer_SetHeadroom" },
  { 0xb006c, "IDirectSoundBuffer_SetI3DL2Source" },
  { 0xb006d, "IDirectSoundBuffer_SetLFO" },
  { 0xb006e, "IDirectSoundBuffer_SetLoopRegion" },
  { 0xb006f, "IDirectSoundBuffer_SetMaxDistance" },
  { 0xb0070, "IDirectSoundBuffer_SetMinDistance" },
  { 0xb0071, "IDirectSoundBuffer_SetMixBins" },
  { 0xb0072, "IDirectSoundBuffer_SetMixBinVolumes" },
  { 0xb0073, "IDirectSoundBuffer_SetMode" },
  { 0xb0074, "IDirectSoundBuffer_SetNotificationPositions" },
  { 0xb0075, "IDirectSoundBuffer_SetOutputBuffer" },
  { 0xb0076, "IDirectSoundBuffer_SetPitch" },
  { 0xb0077, "IDirectSoundBuffer_SetPlayRegion" },
  { 0xb0078, "IDirectSoundBuffer_SetPosition" },
  { 0xb0079, "IDirectSoundBuffer_SetRolloffCurve" },
  { 0xb007a, "IDirectSoundBuffer_SetRolloffFactor" },
  { 0xb007b, "IDirectSoundBuffer_SetVelocity" },
  { 0xb007c, "IDirectSoundBuffer_SetVolume" },
  { 0xb007d, "IDirectSoundBuffer_Stop" },
  { 0xb007e, "IDirectSoundBuffer_StopEx" },
  { 0xb007f, "IDirectSoundBuffer_Unlock" },
  { 0xb0080, "IDirectSoundStream_FlushEx" },
  { 0xb0081, "IDirectSoundStream_GetVoiceProperties" },
  { 0xb0082, "IDirectSoundStream_Pause" },
  { 0xb0083, "IDirectSoundStream_PauseEx" },
  { 0xb0084, "IDirectSoundStream_QueryInterface" },
  { 0xb0085, "IDirectSoundStream_QueryInterfaceC" },
  { 0xb0086, "IDirectSoundStream_SetAllParameters" },
  { 0xb0087, "IDirectSoundStream_SetConeAngles" },
  { 0xb0088, "IDirectSoundStream_SetConeOrientation" },
  { 0xb0089, "IDirectSoundStream_SetConeOutsideVolume" },
  { 0xb008a, "IDirectSoundStream_SetDistanceFactor" },
  { 0xb008b, "IDirectSoundStream_SetDopplerFactor" },
  { 0xb008c, "IDirectSoundStream_SetEG" },
  { 0xb008d, "IDirectSoundStream_SetFilter" },
  { 0xb008e, "IDirectSoundStream_SetFormat" },
  { 0xb008f, "IDirectSoundStream_SetFrequency" },
  { 0xb0090, "IDirectSoundStream_SetHeadroom" },
  { 0xb0091, "IDirectSoundStream_SetI3DL2Source" },
  { 0xb0092, "IDirectSoundStream_SetLFO" },
  { 0xb0093, "IDirectSoundStream_SetMaxDistance" },
  { 0xb0094, "IDirectSoundStream_SetMinDistance" },
  { 0xb0095, "IDirectSoundStream_SetMixBins" },
  { 0xb0096, "IDirectSoundStream_SetMixBinVolumes" },
  { 0xb0097, "IDirectSoundStream_SetMode" },
  { 0xb0098, "IDirectSoundStream_SetOutputBuffer" },
  { 0xb0099, "IDirectSoundStream_SetPitch" },
  { 0xb009a, "IDirectSoundStream_SetPosition" },
  { 0xb009b, "IDirectSoundStream_SetRolloffCurve" },
  { 0xb009c, "IDirectSoundStream_SetRolloffFactor" },
  { 0xb009d, "IDirectSoundStream_SetVelocity" },
  { 0xb009e, "IDirectSoundStream_SetVolume" },
  { 0xb009f, "WmaCreateDecoder" },
  { 0xb00a0, "WmaCreateDecoderEx" },
  { 0xb00a1, "WmaCreateInMemoryDecoder" },
  { 0xb00a2, "WmaCreateInMemoryDecoderEx" },
  { 0xb00a3, "XAudioCalculatePitch" },
  { 0xb00a4, "XAudioCreateAdpcmFormat" },
  { 0xb00a5, "XAudioCreatePcmFormat" },
  { 0xb00a6, "XAudioDownloadEffectsImage" },
  { 0xb00a7, "XAudioSetEffectData" },
  { 0xb00a8, "XFileCreateMediaObject" },
  { 0xb00a9, "XFileCreateMediaObjectAsync" },
  { 0xb00aa, "XFileCreateMediaObjectEx" },
  { 0xb00ab, "XWaveFileCreateMediaObject" },
  { 0xb00ac, "XWaveFileCreateMediaObjectEx" },
  { 0xb00ad, "XWmaDecoderCreateMediaObject" }
};

// Function mappings for KEYBOARD
std::unordered_map<uint32_t, std::string> functions_KEYBOARD = {
  { 0x60001, "XDEVICE_TYPE_KEYBOARD_TABLE" },
  { 0x60002, "XInputGetKeyboardDeviceLanguage" },
  { 0x60003, "XInputGetKeyboardOptions" },
  { 0x60004, "XInputGetKeystroke" },
  { 0x60005, "XInputRegisterLanguages" },
  { 0x60006, "XInputSetKeyboardOptions" }
};

// Function mappings for XACT
std::unordered_map<uint32_t, std::string> functions_XACT = {
  { 0xc0001, "IXACTEngine_AddRef" },
  { 0xc0002, "IXACTEngine_CommitDeferredSettings" },
  { 0xc0003, "IXACTEngine_CreateSoundBank" },
  { 0xc0004, "IXACTEngine_CreateSoundSource" },
  { 0xc0005, "IXACTEngine_DownloadEffectsImage" },
  { 0xc0006, "IXACTEngine_EnableHeadphones" },
  { 0xc0007, "IXACTEngine_FlushNotification" },
  { 0xc0008, "IXACTEngine_GetNotification" },
  { 0xc0009, "IXACTEngine_GlobalPause" },
  { 0xc000a, "IXACTEngine_RegisterNotification" },
  { 0xc000b, "IXACTEngine_RegisterStreamedWaveBank" },
  { 0xc000c, "IXACTEngine_RegisterWaveBank" },
  { 0xc000d, "IXACTEngine_Release" },
  { 0xc000e, "IXACTEngine_SetI3dl2Listener" },
  { 0xc000f, "IXACTEngine_SetListenerOrientation" },
  { 0xc0010, "IXACTEngine_SetListenerPosition" },
  { 0xc0011, "IXACTEngine_SetListenerVelocity" },
  { 0xc0012, "IXACTEngine_SetMasterVolume" },
  { 0xc0013, "IXACTEngine_SetParameterControl" },
  { 0xc0014, "IXACTEngine_UnRegisterNotification" },
  { 0xc0015, "IXACTEngine_UnRegisterWaveBank" },
  { 0xc0016, "IXACTSoundBank_AddRef" },
  { 0xc0017, "IXACTSoundBank_CreateWmaPlayList" },
  { 0xc0018, "IXACTSoundBank_GetSoundCueIndexFromFriendlyName" },
  { 0xc0019, "IXACTSoundBank_GetSoundCueProperties" },
  { 0xc001a, "IXACTSoundBank_PauseSoundCue" },
  { 0xc001b, "IXACTSoundBank_Play" },
  { 0xc001c, "IXACTSoundBank_PlayEx" },
  { 0xc001d, "IXACTSoundBank_Prepare" },
  { 0xc001e, "IXACTSoundBank_PrepareEx" },
  { 0xc001f, "IXACTSoundBank_Release" },
  { 0xc0020, "IXACTSoundBank_SelectVariation" },
  { 0xc0021, "IXACTSoundBank_Stop" },
  { 0xc0022, "IXACTSoundSource_AddRef" },
  { 0xc0023, "IXACTSoundSource_GetProperties" },
  { 0xc0024, "IXACTSoundSource_GetStatus" },
  { 0xc0025, "IXACTSoundSource_Release" },
  { 0xc0026, "IXACTSoundSource_SetConeOrientation" },
  { 0xc0027, "IXACTSoundSource_SetFilter" },
  { 0xc0028, "IXACTSoundSource_SetI3DL2Source" },
  { 0xc0029, "IXACTSoundSource_SetMixBins" },
  { 0xc002a, "IXACTSoundSource_SetMixBinVolumes" },
  { 0xc002b, "IXACTSoundSource_SetMode" },
  { 0xc002c, "IXACTSoundSource_SetPitch" },
  { 0xc002d, "IXACTSoundSource_SetPosition" },
  { 0xc002e, "IXACTSoundSource_SetVelocity" },
  { 0xc002f, "IXACTSoundSource_StopSoundCues" },
  { 0xc0030, "IXACTWmaPlayList_Add" },
  { 0xc0031, "IXACTWmaPlayList_AddRef" },
  { 0xc0032, "IXACTWmaPlayList_GetCurrentSongInfo" },
  { 0xc0033, "IXACTWmaPlayList_GetCurrentSongInfoEx" },
  { 0xc0034, "IXACTWmaPlayList_GetProperties" },
  { 0xc0035, "IXACTWmaPlayList_Next" },
  { 0xc0036, "IXACTWmaPlayList_Previous" },
  { 0xc0037, "IXACTWmaPlayList_Release" },
  { 0xc0038, "IXACTWmaPlayList_Remove" },
  { 0xc0039, "IXACTWmaPlayList_SetCurrent" },
  { 0xc003a, "IXACTWmaPlayList_SetPlaybackBehavior" },
  { 0xc003b, "XACTEngineCreate" },
  { 0xc003c, "XACTEngineDoWork" },
  { 0xc003d, "XACTEngineSetFileIOCallbacks" }
};

// Function mappings for XAPILIB
std::unordered_map<uint32_t, std::string> functions_XAPILIB = {
  { 0x10001, "XLoadSection" },
  { 0x10002, "XFreeSection" },
  { 0x10003, "XGetSectionHandle" },
  { 0x10004, "XLoadSectionByHandle" },
  { 0x10005, "XFreeSectionByHandle" },
  { 0x10006, "XGetSectionSize" },
  { 0x10007, "XGetDisplayBlocks" },
  { 0x10008, "XCreateSaveGame" },
  { 0x10009, "XDeleteSaveGame" },
  { 0x1000a, "XFindFirstSaveGame" },
  { 0x1000b, "XFindNextSaveGame" },
  { 0x1000c, "XFindClose" },
  { 0x1000d, "XSetNickname" },
  { 0x1000e, "XFindFirstNickname" },
  { 0x1000f, "XFindNextNickname" },
  { 0x10010, "XFindFirstContent" },
  { 0x10011, "XFindNextContent" },
  { 0x10012, "XGetContentInstallLocation" },
  { 0x10013, "XGetContentInstallLocationFromIDs" },
  { 0x10014, "XInstallContentSignatures" },
  { 0x10015, "XCreateContentSimple" },
  { 0x10016, "XRemoveContent" },
  { 0x10017, "XLoadContentSignaturesWithFileName" },
  { 0x10018, "XLocateSignatureByNameEx" },
  { 0x10019, "XLocateNextSignature" },
  { 0x1001a, "XInstallContentSignaturesWithFileName" },
  { 0x1001b, "XInstallContentSignaturesEx" },
  { 0x1001c, "XLoadContentSignaturesEx" },
  { 0x1001d, "XLocateSignatureByIndex" },
  { 0x1001e, "XLocateSignatureByName" },
  { 0x1001f, "XCalculateContentSignature" },
  { 0x10020, "XCloseContentSignatures" },
  { 0x10021, "XComputeContentSignatureKey" },
  { 0x10022, "XFindFirstSoundtrack" },
  { 0x10023, "XFindNextSoundtrack" },
  { 0x10024, "XOpenSoundtrackSong" },
  { 0x10025, "XGetSoundtrackSongInfo" },
  { 0x10026, "XAddSoundtrack" },
  { 0x10027, "XAddSongToSoundtrack" },
  { 0x10028, "XGetLanguage" },
  { 0x10029, "XGetAVPack" },
  { 0x1002a, "XGetVideoStandard" },
  { 0x1002b, "XGetVideoFlags" },
  { 0x1002c, "XGetAudioFlags" },
  { 0x1002d, "XGetParentalControlSetting" },
  { 0x1002e, "XGetGameRegion" },
  { 0x1002f, "XSetValue" },
  { 0x10030, "XQueryValue" },
  { 0x10031, "XInitDevices" },
  { 0x10032, "XGetDevices" },
  { 0x10033, "XGetDeviceChanges" },
  { 0x10034, "XPeekDevices" },
  { 0x10035, "XGetDeviceEnumerationStatus" },
  { 0x10036, "XInputOpen" },
  { 0x10037, "XInputClose" },
  { 0x10038, "XInputGetState" },
  { 0x10039, "XInputPoll" },
  { 0x1003a, "XInputSetState" },
  { 0x1003b, "XInputGetCapabilities" },
  { 0x1003c, "XInputGetDeviceDescription" },
  { 0x1003d, "XInputSetLightgunCalibration" },
  { 0x1003e, "XMountMUA" },
  { 0x1003f, "XMountMURoot" },
  { 0x10040, "XUnmountMU" },
  { 0x10041, "XMUPortFromDriveLetter" },
  { 0x10042, "XMUSlotFromDriveLetter" },
  { 0x10043, "XMUNameFromDriveLetter" },
  { 0x10044, "XMUNameFromPortSlot" },
  { 0x10045, "XReadMUMetaData" },
  { 0x10046, "XMUWriteNameToDriveLetter" },
  { 0x10047, "XCleanMUFromRoot" },
  { 0x10048, "XCleanDrive" },
  { 0x10049, "XMountUtilityDrive" },
  { 0x1004a, "XFormatUtilityDrive" },
  { 0x1004b, "XMountAlternateTitle" },
  { 0x1004c, "XUnmountAlternateTitle" },
  { 0x1004d, "XGetDiskSectorSize" },
  { 0x1004e, "XGetDiskClusterSize" },
  { 0x1004f, "XDCSGetInformation" },
  { 0x10050, "XDCSDownloadCode" },
  { 0x10051, "XDCSDownloadCodeAsync" },
  { 0x10052, "XAutoPowerDownSet" },
  { 0x10053, "XAutoPowerDownGet" },
  { 0x10054, "XAutoPowerDownResetTimer" },
  { 0x10055, "XAutoPowerDownDebugSetTimeout" },
  { 0x10056, "XapiSetLocalTime" },
  { 0x10057, "XapipQueryTimeZoneInformation" },
  { 0x10058, "XapipSetTimeZoneInformation" },
  { 0x10059, "XapipUseDaylightSavingTime" },
  { 0x1005a, "XLaunchNewImageA" },
  { 0x1005b, "XGetLaunchInfo" },
  { 0x1005c, "XWriteTitleInfoAndReboot" },
  { 0x1005d, "XRegisterThreadNotifyRoutine" },
  { 0x1005e, "XSetProcessQuantumLength" },
  { 0x1005f, "XGetProcessQuantumLength" },
  { 0x10060, "XSetFileCacheSize" },
  { 0x10061, "XGetFileCacheSize" },
  { 0x10062, "XSaveFloatingPointStateForDpc" },
  { 0x10063, "XRestoreFloatingPointStateForDpc" },
  { 0x10064, "XPhysicalAlloc" },
  { 0x10065, "XPhysicalSize" },
  { 0x10066, "XPhysicalProtect" },
  { 0x10067, "XPhysicalFree" },
  { 0x10068, "XQueryMemoryProtect" },
  { 0x10069, "XMemAlloc" },
  { 0x1006a, "XMemFree" },
  { 0x1006b, "XMemSize" },
  { 0x1006c, "XSetAttributesOnHeapAlloc" },
  { 0x1006d, "XGetAttributesOnHeapAlloc" },
  { 0x1006e, "XDebugGetSystemVersion" },
  { 0x1006f, "XDebugGetXTLVersion" },
  { 0x10070, "XCalculateSignatureBegin" },
  { 0x10071, "XCalculateSignatureBeginEx" },
  { 0x10072, "XCalculateSignatureUpdate" },
  { 0x10073, "XCalculateSignatureEnd" },
  { 0x10074, "XAutoPowerDownTimeRemaining" },
  { 0x10075, "XapiFlashKernelImage" },
  { 0x10076, "XapiReplaceRootDirectoryFile" },
  { 0x10077, "XapiGetKernelExportAddress" },
  { 0x10078, "XMemAllocDefault" },
  { 0x10079, "XMemFreeDefault" },
  { 0x1007a, "XMemSizeDefault" },
  { 0x1007b, "XDEVICE_TYPE_DEBUG_MOUSE_TABLE" },
  { 0x1007c, "XDEVICE_TYPE_GAMEPAD_TABLE" },
  { 0x1007d, "XDEVICE_TYPE_IR_REMOTE_TABLE" },
  { 0x1007e, "XDEVICE_TYPE_MEMORY_UNIT_TABLE" },
  { 0x20001, "GetCurrentTime" },
  { 0x20002, "Yield" },
  { 0x20003, "MoveMemory" },
  { 0x20004, "CopyMemory" },
  { 0x20005, "FillMemory" },
  { 0x20006, "ZeroMemory" },
  { 0x2000f, "InterlockedIncrement" },
  { 0x20010, "InterlockedDecrement" },
  { 0x20011, "InterlockedExchange" },
  { 0x20012, "InterlockedExchangePointerTarget" },
  { 0x20013, "InterlockedExchangeAdd" },
  { 0x20014, "InterlockedCompareExchange" },
  { 0x20015, "InterlockedCompareExchangePointer" },
  { 0x20016, "FreeResource" },
  { 0x20017, "LockResource" },
  { 0x20018, "UnlockResourcehResData" },
  { 0x20019, "WinMain" },
  { 0x2001a, "FreeLibrary" },
  { 0x2001b, "FreeLibraryAndExitThread" },
  { 0x2001c, "DisableThreadLibraryCalls" },
  { 0x2001d, "GetProcAddress" },
  { 0x2001e, "GlobalAlloc" },
  { 0x2001f, "GlobalReAlloc" },
  { 0x20020, "GlobalFlags" },
  { 0x20021, "GlobalSize" },
  { 0x20022, "GlobalLock" },
  { 0x20023, "GlobalHandle" },
  { 0x20024, "GlobalUnlock" },
  { 0x20025, "GlobalFree" },
  { 0x20026, "GlobalCompact" },
  { 0x20027, "GlobalFix" },
  { 0x20028, "GlobalUnfix" },
  { 0x20029, "GlobalWire" },
  { 0x2002a, "GlobalUnWire" },
  { 0x2002b, "GlobalMemoryStatus" },
  { 0x2002c, "GlobalMemoryStatusEx" },
  { 0x2002d, "LocalAlloc" },
  { 0x2002e, "LocalReAlloc" },
  { 0x2002f, "LocalLock" },
  { 0x20030, "LocalHandle" },
  { 0x20031, "LocalUnlock" },
  { 0x20032, "LocalSize" },
  { 0x20033, "LocalFlags" },
  { 0x20034, "LocalFree" },
  { 0x20035, "LocalShrink" },
  { 0x20036, "LocalCompact" },
  { 0x20037, "VirtualAlloc" },
  { 0x20038, "VirtualFree" },
  { 0x20039, "VirtualProtect" },
  { 0x2003a, "VirtualQuery" },
  { 0x2003b, "VirtualAllocEx" },
  { 0x2003c, "VirtualFreeEx" },
  { 0x2003d, "VirtualProtectEx" },
  { 0x2003e, "VirtualQueryEx" },
  { 0x2003f, "HeapCreate" },
  { 0x20040, "HeapDestroy" },
  { 0x20041, "HeapCreateTagsW" },
  { 0x20042, "HeapQueryTagW" },
  { 0x20043, "HeapAlloc" },
  { 0x20044, "HeapReAlloc" },
  { 0x20045, "HeapSize" },
  { 0x20046, "HeapFree" },
  { 0x20047, "HeapValidate" },
  { 0x20048, "HeapCompact" },
  { 0x20049, "GetProcessHeapVOID" },
  { 0x2004a, "GetProcessHeaps" },
  { 0x2004b, "HeapLock" },
  { 0x2004c, "HeapUnlock" },
  { 0x2004d, "HeapSummary" },
  { 0x2004e, "HeapExtend" },
  { 0x2004f, "HeapUsage" },
  { 0x20050, "HeapWalk" },
  { 0x20051, "GetShortPathNameA" },
  { 0x20052, "GetShortPathNameW" },
  { 0x20053, "GetLongPathNameA" },
  { 0x20054, "GetLongPathNameW" },
  { 0x20055, "GetProcessTimes" },
  { 0x20056, "GetCurrentProcess" },
  { 0x20057, "GetCurrentProcessId" },
  { 0x20058, "ExitProcess" },
  { 0x20059, "TerminateProcess" },
  { 0x2005a, "GetExitCodeProcess" },
  { 0x2005b, "FatalExit" },
  { 0x2005c, "RaiseException" },
  { 0x2005d, "UnhandledExceptionFilter" },
  { 0x2005e, "SetUnhandledExceptionFilter" },
  { 0x2005f, "CreateFiber" },
  { 0x20060, "DeleteFiber" },
  { 0x20061, "ConvertThreadToFiber" },
  { 0x20062, "SwitchToFiber" },
  { 0x20063, "SwitchToThread" },
  { 0x20064, "CreateThread" },
  { 0x20065, "GetCurrentThread" },
  { 0x20066, "GetCurrentThreadId" },
  { 0x20067, "SetProcessPriorityBoost" },
  { 0x20068, "GetProcessPriorityBoost" },
  { 0x20069, "OpenThread" },
  { 0x2006a, "SetThreadPriority" },
  { 0x2006b, "SetThreadPriorityBoost" },
  { 0x2006c, "GetThreadPriorityBoost" },
  { 0x2006d, "GetThreadPriority" },
  { 0x2006e, "GetThreadTimes" },
  { 0x2006f, "ExitThread" },
  { 0x20070, "TerminateThread" },
  { 0x20071, "GetExitCodeThread" },
  { 0x20072, "GetLastError" },
  { 0x20073, "SetLastError" },
  { 0x20074, "HasOverlappedIoCompletedlpOverlapped" },
  { 0x20075, "GetOverlappedResult" },
  { 0x20076, "CreateIoCompletionPort" },
  { 0x20077, "GetQueuedCompletionStatus" },
  { 0x20078, "PostQueuedCompletionStatus" },
  { 0x20079, "SetErrorMode" },
  { 0x2007a, "GetThreadContext" },
  { 0x2007b, "SetThreadContext" },
  { 0x2007c, "SuspendThread" },
  { 0x2007d, "ResumeThread" },
  { 0x2007e, "QueueUserAPC" },
  { 0x2007f, "IsDebuggerPresent" },
  { 0x20080, "DebugBreak" },
  { 0x20081, "WaitForDebugEvent" },
  { 0x20082, "ContinueDebugEvent" },
  { 0x20083, "DebugActiveProcess" },
  { 0x20084, "InitializeCriticalSection" },
  { 0x20085, "EnterCriticalSection" },
  { 0x20086, "LeaveCriticalSection" },
  { 0x20087, "TryEnterCriticalSection" },
  { 0x20088, "DeleteCriticalSection" },
  { 0x20089, "SetEvent" },
  { 0x2008a, "ResetEvent" },
  { 0x2008b, "PulseEvent" },
  { 0x2008c, "ReleaseSemaphore" },
  { 0x2008d, "ReleaseMutex" },
  { 0x2008e, "WaitForSingleObject" },
  { 0x2008f, "WaitForMultipleObjects" },
  { 0x20090, "Sleep" },
  { 0x20091, "LoadResource" },
  { 0x20092, "SizeofResource" },
  { 0x20093, "GetLogicalDrives" },
  { 0x20094, "GetFileInformationByHandle" },
  { 0x20095, "GetFileType" },
  { 0x20096, "GetFileSize" },
  { 0x20097, "GetFileSizeEx" },
  { 0x20098, "WriteFile" },
  { 0x20099, "ReadFile" },
  { 0x2009a, "FlushFileBuffers" },
  { 0x2009b, "DeviceIoControl" },
  { 0x2009c, "SetEndOfFile" },
  { 0x2009d, "SetFilePointer" },
  { 0x2009e, "SetFilePointerEx" },
  { 0x2009f, "GetFileTime" },
  { 0x200a0, "SetFileTime" },
  { 0x200a1, "CloseHandle" },
  { 0x200a2, "DuplicateHandle" },
  { 0x200a3, "LoadModule" },
  { 0x200a4, "MulDiv" },
  { 0x200a5, "GetSystemTime" },
  { 0x200a6, "GetSystemTimeAsFileTime" },
  { 0x200a7, "SetSystemTime" },
  { 0x200a8, "GetLocalTime" },
  { 0x200a9, "SetLocalTime" },
  { 0x200aa, "GetSystemInfo" },
  { 0x200ab, "SystemTimeToTzSpecificLocalTime" },
  { 0x200ac, "GetTimeZoneInformation" },
  { 0x200ad, "SetTimeZoneInformation" },
  { 0x200ae, "SystemTimeToFileTime" },
  { 0x200af, "FileTimeToLocalFileTime" },
  { 0x200b0, "LocalFileTimeToFileTime" },
  { 0x200b1, "FileTimeToSystemTime" },
  { 0x200b2, "CompareFileTime" },
  { 0x200b3, "FileTimeToDosDateTime" },
  { 0x200b4, "DosDateTimeToFileTime" },
  { 0x200b5, "GetTickCount" },
  { 0x200b6, "SetSystemTimeAdjustment" },
  { 0x200b7, "GetSystemTimeAdjustment" },
  { 0x200b8, "FormatMessageA" },
  { 0x200b9, "FormatMessageW" },
  { 0x200ba, "lstrcmpA" },
  { 0x200bb, "lstrcmpW" },
  { 0x200bc, "lstrcmpiA" },
  { 0x200bd, "lstrcmpiW" },
  { 0x200be, "lstrcpynA" },
  { 0x200bf, "lstrcpynW" },
  { 0x200c0, "lstrcpyA" },
  { 0x200c1, "lstrcpyW" },
  { 0x200c2, "lstrcatA" },
  { 0x200c3, "lstrcatW" },
  { 0x200c4, "lstrlenA" },
  { 0x200c5, "lstrlenW" },
  { 0x200c6, "OpenFile" },
  { 0x200c7, "_lopen" },
  { 0x200c8, "_lcreat" },
  { 0x200c9, "_lread" },
  { 0x200ca, "_lwrite" },
  { 0x200cb, "_hread" },
  { 0x200cc, "_hwrite" },
  { 0x200cd, "_lclose" },
  { 0x200ce, "_llseek" },
  { 0x200cf, "IsTextUnicode" },
  { 0x200d0, "TlsAlloc" },
  { 0x200d1, "TlsGetValue" },
  { 0x200d2, "TlsSetValue" },
  { 0x200d3, "TlsFree" },
  { 0x200d4, "SleepEx" },
  { 0x200d5, "WaitForSingleObjectEx" },
  { 0x200d6, "WaitForMultipleObjectsEx" },
  { 0x200d7, "SignalObjectAndWait" },
  { 0x200d8, "ReadFileEx" },
  { 0x200d9, "WriteFileEx" },
  { 0x200da, "ReadFileScatter" },
  { 0x200db, "WriteFileGather" },
  { 0x200dc, "CreateMutex" },
  { 0x200dd, "OpenMutex" },
  { 0x200de, "CreateEvent" },
  { 0x200df, "OpenEvent" },
  { 0x200e0, "CreateSemaphore" },
  { 0x200e1, "OpenSemaphore" },
  { 0x200e2, "CreateWaitableTimer" },
  { 0x200e3, "OpenWaitableTimer" },
  { 0x200e4, "SetWaitableTimer" },
  { 0x200e5, "CancelWaitableTimer" },
  { 0x200e6, "GetLogicalDriveStringsA" },
  { 0x200e7, "GetLogicalDriveStringsW" },
  { 0x200e8, "LoadLibraryA" },
  { 0x200e9, "LoadLibraryW" },
  { 0x200ea, "LoadLibraryExA" },
  { 0x200eb, "LoadLibraryExW" },
  { 0x200ec, "GetModuleFileNameA" },
  { 0x200ed, "GetModuleFileNameW" },
  { 0x200ee, "GetModuleHandleA" },
  { 0x200ef, "GetModuleHandleW" },
  { 0x200f0, "OutputDebugStringA" },
  { 0x200f1, "OutputDebugStringW" },
  { 0x200f2, "FindResourceA" },
  { 0x200f3, "FindResourceW" },
  { 0x200f4, "FindResourceExA" },
  { 0x200f5, "FindResourceExW" },
  { 0x200f6, "EnumResourceTypesA" },
  { 0x200f7, "EnumResourceTypesW" },
  { 0x200f8, "EnumResourceNamesA" },
  { 0x200f9, "EnumResourceNamesW" },
  { 0x200fa, "EnumResourceLanguagesA" },
  { 0x200fb, "EnumResourceLanguagesW" },
  { 0x200fc, "GetProfileIntA" },
  { 0x200fd, "GetProfileIntW" },
  { 0x200fe, "GetProfileStringA" },
  { 0x200ff, "GetProfileStringW" },
  { 0x20100, "WriteProfileStringA" },
  { 0x20101, "WriteProfileStringW" },
  { 0x20102, "GetProfileSectionA" },
  { 0x20103, "GetProfileSectionW" },
  { 0x20104, "WriteProfileSectionA" },
  { 0x20105, "WriteProfileSectionW" },
  { 0x20106, "GetPrivateProfileIntA" },
  { 0x20107, "GetPrivateProfileIntW" },
  { 0x20108, "GetPrivateProfileStringA" },
  { 0x20109, "GetPrivateProfileStringW" },
  { 0x2010a, "WritePrivateProfileStringA" },
  { 0x2010b, "WritePrivateProfileStringW" },
  { 0x2010c, "GetPrivateProfileSectionA" },
  { 0x2010d, "GetPrivateProfileSectionW" },
  { 0x2010e, "WritePrivateProfileSectionA" },
  { 0x2010f, "WritePrivateProfileSectionW" },
  { 0x20110, "GetPrivateProfileSectionNamesA" },
  { 0x20111, "GetPrivateProfileSectionNamesW" },
  { 0x20112, "GetPrivateProfileStructA" },
  { 0x20113, "GetPrivateProfileStructW" },
  { 0x20114, "WritePrivateProfileStructA" },
  { 0x20115, "WritePrivateProfileStructW" },
  { 0x20116, "GetDriveTypeA" },
  { 0x20117, "GetDriveTypeW" },
  { 0x20118, "GetSystemDirectoryA" },
  { 0x20119, "GetSystemDirectoryW" },
  { 0x2011a, "GetTempPathA" },
  { 0x2011b, "GetTempPathW" },
  { 0x2011c, "GetTempFileNameA" },
  { 0x2011d, "GetTempFileNameW" },
  { 0x2011e, "SetCurrentDirectoryA" },
  { 0x2011f, "GetCurrentDirectoryW" },
  { 0x20120, "GetDiskFreeSpaceA" },
  { 0x20121, "GetDiskFreeSpaceW" },
  { 0x20122, "GetDiskFreeSpaceEx" },
  { 0x20123, "CreateDirectory" },
  { 0x20124, "CreateDirectoryExA" },
  { 0x20125, "CreateDirectoryExW" },
  { 0x20126, "RemoveDirectory" },
  { 0x20127, "GetFullPathNameA" },
  { 0x20128, "GetFullPathNameW" },
  { 0x20129, "CreateFile" },
  { 0x2012a, "SetFileAttributes" },
  { 0x2012b, "GetFileAttributes" },
  { 0x2012c, "GetFileAttributesEx" },
  { 0x2012d, "DeleteFile" },
  { 0x2012e, "FindFirstFile" },
  { 0x2012f, "FindNextFile" },
  { 0x20130, "SearchPathA" },
  { 0x20131, "SearchPathW" },
  { 0x20132, "CopyFile" },
  { 0x20133, "CopyFileEx" },
  { 0x20134, "MoveFile" },
  { 0x20135, "MoveFileEx" },
  { 0x20136, "MoveFileWithProgress" },
  { 0x20137, "SetVolumeLabelA" },
  { 0x20138, "SetVolumeLabelW" },
  { 0x20139, "SetFileApisToOEMVOID" },
  { 0x2013a, "SetFileApisToANSIVOID" },
  { 0x2013b, "AreFileApisANSIVOID" },
  { 0x2013c, "GetVolumeInformation" },
  { 0x2013d, "CancelIo" },
  { 0x2013e, "SetPriorityClass" },
  { 0x2013f, "GetPriorityClass" },
  { 0x20140, "IsBadReadPtr" },
  { 0x20141, "IsBadWritePtr" },
  { 0x20142, "IsBadHugeReadPtr" },
  { 0x20143, "IsBadHugeWritePtr" },
  { 0x20144, "IsBadCodePtr" },
  { 0x20145, "IsBadStringPtrA" },
  { 0x20146, "IsBadStringPtrW" },
  { 0x20147, "GetComputerNameA" },
  { 0x20148, "GetComputerNameW" },
  { 0x20149, "SetComputerNameA" },
  { 0x2014a, "SetComputerNameW" },
  { 0x2014b, "GetComputerNameExA" },
  { 0x2014c, "GetComputerNameExW" },
  { 0x2014d, "SetComputerNameExA" },
  { 0x2014e, "SetComputerNameExW" },
  { 0x2014f, "DnsHostnameToComputerNameA" },
  { 0x20150, "DnsHostnameToComputerNameW" },
  { 0x20151, "GetUserNameA" },
  { 0x20152, "GetUserNameW" },
  { 0x20153, "RegisterWaitForSingleObject" },
  { 0x20154, "RegisterWaitForSingleObjectEx" },
  { 0x20155, "UnregisterWait" },
  { 0x20156, "UnregisterWaitEx" },
  { 0x20157, "QueueUserWorkItem" },
  { 0x20158, "BindIoCompletionCallback" },
  { 0x20159, "CreateTimerQueue" },
  { 0x2015a, "CreateTimerQueueTimer" },
  { 0x2015b, "ChangeTimerQueueTimer" },
  { 0x2015c, "DeleteTimerQueueTimer" },
  { 0x2015d, "DeleteTimerQueueEx" },
  { 0x2015e, "SetTimerQueueTimer" },
  { 0x2015f, "CancelTimerQueueTimer" },
  { 0x20160, "DeleteTimerQueue" },
  { 0x20161, "QueryPerformanceCounter" },
  { 0x20162, "QueryPerformanceFrequency" },
  { 0x20163, "FindFirstVolumeA" },
  { 0x20164, "FindFirstVolumeW" },
  { 0x20165, "FindNextVolumeA" },
  { 0x20166, "FindNextVolumeW" },
  { 0x20167, "FindVolumeClose" },
  { 0x20168, "GetVolumePathNameA" },
  { 0x20169, "GetVolumePathNameW" },
  { 0x2016a, "GetDaylightFlagVOID" },
  { 0x2016b, "SetDaylightFlag" },
  { 0x2016c, "wvsprintfA" },
  { 0x2016d, "wvsprintfW" },
  { 0x2016e, "wsprintfA" },
  { 0x2016f, "wsprintfW" },
  { 0x20170, "MultiByteToWideChar" },
  { 0x20171, "WideCharToMultiByte" },
  { 0x20172, "CharUpperA" },
  { 0x20173, "CharUpperW" },
  { 0x20174, "CharLowerA" },
  { 0x20175, "CharLowerW" },
  { 0x20176, "SetRect" },
  { 0x20177, "SetRectEmpty" },
  { 0x20178, "CopyRect" },
  { 0x20179, "InflateRect" },
  { 0x2017a, "IntersectRect" },
  { 0x2017b, "UnionRect" },
  { 0x2017c, "SubtractRect" },
  { 0x2017d, "OffsetRect" },
  { 0x2017e, "IsRectEmpty" },
  { 0x2017f, "EqualRect" },
  { 0x20180, "PtInRect" }
};

// Function mappings for XGRAPHICS
std::unordered_map<uint32_t, std::string> functions_XGRAPHICS = {
  { 0xd0001, "XGAssembleShader" },
  { 0xd0002, "XGBuffer_AddRef" },
  { 0xd0003, "XGBuffer_GetBufferPointer" },
  { 0xd0004, "XGBuffer_GetBufferSize" },
  { 0xd0005, "XGBuffer_Release" },
  { 0xd0006, "XGBufferCreate" },
  { 0xd0007, "XGBytesPerPixelFromFormat" },
  { 0xd0008, "XGCompileDrawIndexedVertices" },
  { 0xd0009, "XGCompileShader" },
  { 0xd000a, "XGCompressRect" },
  { 0xd000b, "XGIsSwizzledFormat" },
  { 0xd000c, "XGSetCubeTextureHeader" },
  { 0xd000d, "XGSetFixupHeader" },
  { 0xd000e, "XGSetIndexBufferHeader" },
  { 0xd000f, "XGSetPaletteHeader" },
  { 0xd0010, "XGSetPushBufferHeader" },
  { 0xd0011, "XGSetSurfaceHeader" },
  { 0xd0012, "XGSetTextureHeader" },
  { 0xd0013, "XGSetVertexBufferHeader" },
  { 0xd0014, "XGSetVolumeTextureHeader" },
  { 0xd0015, "XGSpliceVertexShaders" },
  { 0xd0016, "XGSUCode_CompareVertexShaders" },
  { 0xd0017, "XGSUCode_GetVertexShaderLength" },
  { 0xd0018, "XGSUCode_GetVertexShaderType" },
  { 0xd0019, "XGSwizzleBox" },
  { 0xd001a, "XGSwizzleRect" },
  { 0xd001b, "XGUnswizzleBox" },
  { 0xd001c, "XGUnswizzleRect" },
  { 0xd001d, "XGWriteSurfaceOrTextureToXPR" },
  { 0xd001e, "XGWriteSurfaceToFile" }
};

// Function mappings for XKBD
std::unordered_map<uint32_t, std::string> functions_XKBD = {
  { 0x50001, "XDEVICE_TYPE_DEBUG_KEYBOARD_TABLE" },
  { 0x50002, "XInputDebugGetKeystroke" },
  { 0x50003, "XInputDebugInitKeyboardQueue" }
};

// Function mappings for XMV
std::unordered_map<uint32_t, std::string> functions_XMV = {
  { 0xe0001, "XMVDecoder_CloseDecoder" },
  { 0xe0002, "XMVDecoder_CreateDecoderForFile" },
  { 0xe0003, "XMVDecoder_CreateDecoderForPackets" },
  { 0xe0004, "XMVDecoder_DisableAudioStream" },
  { 0xe0005, "XMVDecoder_EnableAudioStream" },
  { 0xe0006, "XMVDecoder_GetAudioDescriptor" },
  { 0xe0007, "XMVDecoder_GetAudioStream" },
  { 0xe0008, "XMVDecoder_GetNextFrame" },
  { 0xe0009, "XMVDecoder_GetSynchronizationStream" },
  { 0xe000a, "XMVDecoder_GetTimeFromStart" },
  { 0xe000b, "XMVDecoder_GetVideoDescriptor" },
  { 0xe000c, "XMVDecoder_Play" },
  { 0xe000d, "XMVDecoder_Reset" },
  { 0xe000e, "XMVDecoder_SetSynchronizationStream" },
  { 0xe000f, "XMVDecoder_TerminateImmediately" },
  { 0xe0010, "XMVDecoder_TerminateLoop" },
  { 0xe0011, "XMVDecoder_TerminatePlayback" }
};

// Function mappings for XONLINES
std::unordered_map<uint32_t, std::string> functions_XONLINES = {
  { 0x30001, "XOnlineStartup" },
  { 0x30002, "XOnlineCleanup" },
  { 0x30003, "XOnlineTaskContinue" },
  { 0x30004, "XOnlineTaskClose" },
  { 0x30005, "XOnlineGetUsers" },
  { 0x30006, "XOnlineLogon" },
  { 0x30007, "XOnlineLogonTaskGetResults" },
  { 0x30008, "XOnlineChangeLogonUsers" },
  { 0x30009, "XOnlineChangeLogonUsersTaskGetResults" },
  { 0x3000a, "XOnlineGetLogonUsers" },
  { 0x3000b, "XOnlineGetServiceInfo" },
  { 0x3000c, "XOnlineSaveLogonState" },
  { 0x3000d, "XOnlineRetrieveLogonState" },
  { 0x3000e, "XOnlineDashUpdate" },
  { 0x3000f, "XOnlineTitleUpdate" },
  { 0x30010, "XOnlineTitleUpdateEx" },
  { 0x30011, "XOnlineOfferingPurchase" },
  { 0x30012, "XOnlineOfferingCancel" },
  { 0x30013, "XOnlineOfferingDetails" },
  { 0x30014, "XOnlineOfferingDetailsGetResults" },
  { 0x30015, "XOnlineOfferingDetailsMaxSize" },
  { 0x30016, "XOnlineOfferingPriceFormat" },
  { 0x30017, "XOnlineOfferingVerifyLicense" },
  { 0x30018, "XOnlineOfferingIsNewContentAvailable" },
  { 0x30019, "XOnlineOfferingEnumerate" },
  { 0x3001a, "XOnlineOfferingEnumerateGetResults" },
  { 0x3001b, "XOnlineOfferingEnumerateMaxSize" },
  { 0x3001c, "XOnlineContentInstall" },
  { 0x3001d, "XOnlineContentInstallFromDVD" },
  { 0x3001e, "XOnlineContentInstallGetProgress" },
  { 0x3001f, "XOnlineContentSetSecurityKey" },
  { 0x30020, "XOnlineMatchSessionCreate" },
  { 0x30021, "XOnlineMatchSessionUpdate" },
  { 0x30022, "XOnlineMatchSessionGetInfo" },
  { 0x30023, "XOnlineMatchSessionDelete" },
  { 0x30024, "XOnlineMatchSessionFindFromID" },
  { 0x30025, "XOnlineMatchSearch" },
  { 0x30026, "XOnlineMatchSearchGetResults" },
  { 0x30027, "XOnlineMatchSearchParse" },
  { 0x30028, "XOnlineMatchSearchResultsLen" },
  { 0x30029, "XOnlineTitleNameStartup" },
  { 0x3002a, "XOnlineTitleNameLookup" },
  { 0x3002b, "XOnlineTitleNameSetName" },
  { 0x3002c, "XOnlineTitleNameReset" },
  { 0x3002d, "XOnlineTitleIdIsSameTitle" },
  { 0x3002e, "XOnlineTitleIdIsSamePublisher" },
  { 0x3002f, "XOnlineNotificationSetState" },
  { 0x30030, "XOnlineNotificationSetUserData" },
  { 0x30031, "XOnlineGetNotification" },
  { 0x30032, "XOnlineFriendsStartup" },
  { 0x30033, "XOnlineFriendsEnumerate" },
  { 0x30034, "XOnlineFriendsEnumerateFinish" },
  { 0x30035, "XOnlineFriendsGetLatest" },
  { 0x30036, "XOnlineFriendsGetLatestByRange" },
  { 0x30037, "XOnlineFriendsGetLatestByFocus" },
  { 0x30038, "XOnlineFriendsGetTitleName" },
  { 0x30039, "XOnlineFriendsRemove" },
  { 0x3003a, "XOnlineFriendsRequest" },
  { 0x3003b, "XOnlineFriendsRequestByName" },
  { 0x3003c, "XOnlineFriendsGameInvite" },
  { 0x3003d, "XOnlineFriendsRevokeGameInvite" },
  { 0x3003e, "XOnlineFriendsAnswerRequest" },
  { 0x3003f, "XOnlineFriendsAnswerGameInvite" },
  { 0x30040, "XOnlineFriendsJoinGame" },
  { 0x30041, "XOnlineFriendsGetAcceptedGameInvite" },
  { 0x30042, "XOnlineMutelistGet" },
  { 0x30043, "XOnlineMutelistStartup" },
  { 0x30044, "XOnlineMutelistAdd" },
  { 0x30045, "XOnlineMutelistRemove" },
  { 0x30046, "XOnlineFeedbackSend" },
  { 0x30047, "XOnlineStringGet" },
  { 0x30048, "XOnlineMessageGet" },
  { 0x30049, "XOnlineEnumerateTitlesBegin" },
  { 0x3004a, "XOnlineEnumerateTitlesContinue" },
  { 0x3004b, "XOnlineEnumerateTitlesGetResults" },
  { 0x3004c, "XOnlineDownloadToMemory" },
  { 0x3004d, "XOnlineDownloadFile" },
  { 0x3004e, "XOnlineDownloadGetProgress" },
  { 0x3004f, "XOnlineDownloadGetResults" },
  { 0x30050, "XOnlineUploadFromMemory" },
  { 0x30051, "XOnlineUploadFile" },
  { 0x30052, "XOnlineUploadFileByHandle" },
  { 0x30053, "XOnlineUploadGetProgress" },
  { 0x30054, "XOnlineUploadGetResults" },
  { 0x30055, "XOnlineVerifyNickname" },
  { 0x30056, "XOnlineStatWrite" },
  { 0x30057, "XOnlineStatRead" },
  { 0x30058, "XOnlineStatReadGetResult" },
  { 0x30059, "XOnlineStatLeaderEnumerate" },
  { 0x3005a, "XOnlineStatLeaderEnumerateGetResults" },
  { 0x3005b, "XOnlineStatReset" },
  { 0x3005c, "_XOnlineLogonTaskGetStatus" },
  { 0x3005d, "_XOnlineGetLogonUserPrivateFlags" },
  { 0x3005e, "_XOnlineDontUseTicketCacheOnNextLogon" },
  { 0x3005f, "_XOnlineGetMachineID" },
  { 0x30060, "_XOnlineGetSerialNumber" },
  { 0x30061, "_XOnlineGetUsersFromHD" },
  { 0x30062, "_XOnlineGetUserFromMU" },
  { 0x30063, "_XOnlineAddUserToHD" },
  { 0x30064, "_XOnlineSetUserInMU" },
  { 0x30065, "_XOnlineRemoveUserFromHD" },
  { 0x30066, "_XOnlineIsUserCredentialPresent" },
  { 0x30067, "_XOnlineIsLoggedOn" },
  { 0x30068, "_XOnlineOverrideInfo" },
  { 0x30069, "_XOnlineCleanupAsyncIO" },
  { 0x3006a, "_XOnlineGetTitleId" },
  { 0x3006b, "_XOnlineGetTitleVersion" },
  { 0x3006c, "_XOnlineSetTitleId" },
  { 0x3006d, "_XOnlineSetTitleVersion" },
  { 0x3006e, "_XOnlineSetTitleGameRegion" },
  { 0x3006f, "_XOnlineReserveName" },
  { 0x30070, "_XOnlineGetReserveNameResults" },
  { 0x30071, "_XOnlineCreateOwnerAccount" },
  { 0x30072, "_XOnlineGetCreateOwnerAccountResults" },
  { 0x30073, "_XOnlineOfferingPurchaseInternal" },
  { 0x30074, "_XOnlineOfferingEnumerateInternal" },
  { 0x30075, "_XOnlineGetPaymentInfo" },
  { 0x30076, "_XOnlineGetPaymentInfoResults" },
  { 0x30077, "_XOnlineSetPaymentInfo" },
  { 0x30078, "_XOnlineSetUserSettings" },
  { 0x30079, "_XOnlineSetUserPIN" },
  { 0x3007a, "_XOnlineSetUserPINResults" },
  { 0x3007b, "_XOnlineVerifyBillingPIN" },
  { 0x3007c, "_XOnlineVerifyVoucher" },
  { 0x3007d, "_XOnlineRestoreAccount" },
  { 0x3007e, "_XOnlineRestoreAccountResults" },
  { 0x3007f, "_XOnlineChangeGamerTag" },
  { 0x30080, "_XOnlineChangeGamerTagResults" },
  { 0x30081, "_XOnlineSetUserAccountStatus" },
  { 0x30082, "_XOnlineClearSubscriptions" },
  { 0x30083, "_XOnlineAcceptTermsOfUse" },
  { 0x30084, "_XOnlineTroubleshootAccount" },
  { 0x30085, "_XOnlineTroubleshootAccountResults" },
  { 0x30086, "XOnlineCompetitionCreate" },
  { 0x30088, "XOnlineCompetitionCreateGetResults" },
  { 0x30089, "XOnlineStatWriteGetResult" },
  { 0x3008a, "XOnlineSignatureVerify" },
  { 0x3008b, "XOnlineSignatureVerifyGetResults" },
  { 0x3008c, "XOnlineStorageUpload" },
  { 0x3008d, "XOnlineStorageDownload" },
  { 0x3008e, "XOnlineStorageGetProgress" },
  { 0x3008f, "_XOnlineStorageResolveName" },
  { 0x30090, "_XOnlineStorageResolveNameResults" },
  { 0x30091, "_XOnlineStorageReportBrokenLink" },
  { 0x30092, "_XOnlineCreateRemoteFileReference" },
  { 0x30093, "_XOnlineDestroyRemoteFileReference" },
  { 0x30094, "_XOnlineStorageGetInstallLocation" },
  { 0x40001, "accept" },
  { 0x40002, "bind" },
  { 0x40003, "closesocket" },
  { 0x40004, "connect" },
  { 0x40005, "getpeername" },
  { 0x40006, "getsockname" },
  { 0x40007, "getsockopt" },
  { 0x40008, "htonl" },
  { 0x40009, "htons" },
  { 0x4000a, "inet_addr" },
  { 0x4000b, "ioctlsocket" },
  { 0x4000c, "listen" },
  { 0x4000d, "ntohl" },
  { 0x4000e, "ntohs" },
  { 0x4000f, "recv" },
  { 0x40010, "recvfrom" },
  { 0x40011, "select" },
  { 0x40012, "send" },
  { 0x40013, "sendto" },
  { 0x40014, "setsockopt" },
  { 0x40015, "shutdown" },
  { 0x40016, "socket" },
  { 0x40017, "__WSAFDIsSet" },
  { 0x40018, "WSAStartup" },
  { 0x40019, "WSACleanup" },
  { 0x4001a, "WSASetLastError" },
  { 0x4001b, "WSAGetLastError" },
  { 0x4001c, "WSACloseEvent" },
  { 0x4001d, "WSACreateEvent" },
  { 0x4001e, "WSAGetOverlappedResult" },
  { 0x4001f, "WSARecv" },
  { 0x40020, "WSARecvFrom" },
  { 0x40021, "WSAResetEvent" },
  { 0x40022, "WSASend" },
  { 0x40023, "WSASendTo" },
  { 0x40024, "WSASetEvent" },
  { 0x40025, "WSAWaitForMultipleEvents" },
  { 0x40026, "XNetStartup" },
  { 0x40027, "XNetCleanup" },
  { 0x40028, "XNetRandom" },
  { 0x40029, "XNetCreateKey" },
  { 0x4002a, "XNetRegisterKey" },
  { 0x4002b, "XNetUnregisterKey" },
  { 0x4002c, "XNetXnAddrToInAddr" },
  { 0x4002d, "XNetServerToInAddr" },
  { 0x4002e, "XNetInAddrToXnAddr" },
  { 0x4002f, "XNetInAddrToString" },
  { 0x40030, "XNetUnregisterInAddr" },
  { 0x40031, "XNetConnect" },
  { 0x40032, "XNetGetConnectStatus" },
  { 0x40033, "XNetDnsLookup" },
  { 0x40034, "XNetDnsRelease" },
  { 0x40035, "XNetQosListen" },
  { 0x40036, "XNetQosLookup" },
  { 0x40037, "XNetQosRelease" },
  { 0x40038, "XNetGetTitleXnAddr" },
  { 0x40039, "XNetGetDebugXnAddr" },
  { 0x4003a, "XNetGetEthernetLinkStatus" },
  { 0x4003b, "WSACancelOverlappedIO" },
  { 0x4003c, "XnInit" },
  { 0x4003d, "XnTerm" },
  { 0x4003e, "XNetOpenConfigVolume" },
  { 0x4003f, "XNetLoadConfigSector" },
  { 0x40040, "XNetSaveConfigSector" },
  { 0x40041, "XNetCloseConfigVolume" },
  { 0x40042, "XNetLoadConfigParams" },
  { 0x40043, "XNetSaveConfigParams" },
  { 0x40044, "XNetUpdateConfigParams" },
  { 0x40045, "XNetConfigUPnP" },
  { 0x40046, "XNetConfig" },
  { 0x40047, "XNetGetConfigStatus" },
  { 0x40048, "XNetCapture" }
};

// Function mappings for D3D
std::unordered_map<uint32_t, std::string> functions_D3D = {
  { 0x80001, "D3D__Device" },
  { 0x80002, "D3D__NullHardware" },
  { 0x80003, "D3D__pDevice" },
  { 0x80004, "D3D__SingleStepPusher" },
  { 0x80005, "D3D_AllocContiguousMemory" },
  { 0x80006, "D3D_CopyContiguousMemoryToVideo" },
  { 0x80007, "D3D_FreeContiguousMemory" },
  { 0x80008, "D3DBaseTexture_AddRef" },
  { 0x80009, "D3DBaseTexture_BlockUntilNotBusy" },
  { 0x8000a, "D3DBaseTexture_FreePrivateData" },
  { 0x8000b, "D3DBaseTexture_GetDevice" },
  { 0x8000c, "D3DBaseTexture_GetLevelCount" },
  { 0x8000d, "D3DBaseTexture_GetPrivateData" },
  { 0x8000e, "D3DBaseTexture_GetType" },
  { 0x8000f, "D3DBaseTexture_IsBusy" },
  { 0x80010, "D3DBaseTexture_MoveResourceMemory" },
  { 0x80011, "D3DBaseTexture_Register" },
  { 0x80012, "D3DBaseTexture_Release" },
  { 0x80013, "D3DBaseTexture_SetPrivateData" },
  { 0x80014, "D3DCubeTexture_AddRef" },
  { 0x80015, "D3DCubeTexture_BlockUntilNotBusy" },
  { 0x80016, "D3DCubeTexture_FreePrivateData" },
  { 0x80017, "D3DCubeTexture_GetCubeMapSurface2" },
  { 0x80018, "D3DCubeTexture_GetDevice" },
  { 0x80019, "D3DCubeTexture_GetLevelCount" },
  { 0x8001a, "D3DCubeTexture_GetLevelDesc" },
  { 0x8001b, "D3DCubeTexture_GetPrivateData" },
  { 0x8001c, "D3DCubeTexture_GetType" },
  { 0x8001d, "D3DCubeTexture_IsBusy" },
  { 0x8001e, "D3DCubeTexture_LockRect" },
  { 0x8001f, "D3DCubeTexture_MoveResourceMemory" },
  { 0x80020, "D3DCubeTexture_Register" },
  { 0x80021, "D3DCubeTexture_Release" },
  { 0x80022, "D3DCubeTexture_SetPrivateData" },
  { 0x80023, "D3DCubeTexture_UnlockRect" },
  { 0x80024, "D3DFixup_AddRef" },
  { 0x80025, "D3DFixup_BlockUntilNotBusy" },
  { 0x80026, "D3DFixup_FreePrivateData" },
  { 0x80027, "D3DFixup_GetDevice" },
  { 0x80028, "D3DFixup_GetPrivateData" },
  { 0x80029, "D3DFixup_GetSize" },
  { 0x8002a, "D3DFixup_GetSpace" },
  { 0x8002b, "D3DFixup_GetType" },
  { 0x8002c, "D3DFixup_IsBusy" },
  { 0x8002d, "D3DFixup_MoveResourceMemory" },
  { 0x8002e, "D3DFixup_Register" },
  { 0x8002f, "D3DFixup_Release" },
  { 0x80030, "D3DFixup_Reset" },
  { 0x80031, "D3DFixup_SetPrivateData" },
  { 0x80032, "D3DIndexBuffer_AddRef" },
  { 0x80033, "D3DIndexBuffer_BlockUntilNotBusy" },
  { 0x80034, "D3DIndexBuffer_FreePrivateData" },
  { 0x80035, "D3DIndexBuffer_GetDesc" },
  { 0x80036, "D3DIndexBuffer_GetDevice" },
  { 0x80037, "D3DIndexBuffer_GetPrivateData" },
  { 0x80038, "D3DIndexBuffer_GetType" },
  { 0x80039, "D3DIndexBuffer_IsBusy" },
  { 0x8003a, "D3DIndexBuffer_Lock" },
  { 0x8003b, "D3DIndexBuffer_MoveResourceMemory" },
  { 0x8003c, "D3DIndexBuffer_Register" },
  { 0x8003d, "D3DIndexBuffer_Release" },
  { 0x8003e, "D3DIndexBuffer_SetPrivateData" },
  { 0x8003f, "D3DIndexBuffer_Unlock" },
  { 0x80040, "D3DPalette_AddRef" },
  { 0x80041, "D3DPalette_BlockUntilNotBusy" },
  { 0x80042, "D3DPalette_FreePrivateData" },
  { 0x80043, "D3DPalette_GetDevice" },
  { 0x80044, "D3DPalette_GetPrivateData" },
  { 0x80045, "D3DPalette_GetSize" },
  { 0x80046, "D3DPalette_GetType" },
  { 0x80047, "D3DPalette_IsBusy" },
  { 0x80048, "D3DPalette_Lock2" },
  { 0x80049, "D3DPalette_MoveResourceMemory" },
  { 0x8004a, "D3DPalette_Register" },
  { 0x8004b, "D3DPalette_Release" },
  { 0x8004c, "D3DPalette_SetPrivateData" },
  { 0x8004d, "D3DPalette_Unlock" },
  { 0x8004e, "D3DPushBuffer_AddRef" },
  { 0x8004f, "D3DPushBuffer_BeginFixup" },
  { 0x80050, "D3DPushBuffer_BlockUntilNotBusy" },
  { 0x80051, "D3DPushBuffer_CopyRects" },
  { 0x80052, "D3DPushBuffer_EndFixup" },
  { 0x80053, "D3DPushBuffer_EndVisibilityTest" },
  { 0x80054, "D3DPushBuffer_FreePrivateData" },
  { 0x80055, "D3DPushBuffer_GetDevice" },
  { 0x80056, "D3DPushBuffer_GetPrivateData" },
  { 0x80057, "D3DPushBuffer_GetType" },
  { 0x80058, "D3DPushBuffer_IsBusy" },
  { 0x80059, "D3DPushBuffer_Jump" },
  { 0x8005a, "D3DPushBuffer_MoveResourceMemory" },
  { 0x8005b, "D3DPushBuffer_Register" },
  { 0x8005c, "D3DPushBuffer_Release" },
  { 0x8005d, "D3DPushBuffer_RunPushBuffer" },
  { 0x8005e, "D3DPushBuffer_SetModelView" },
  { 0x8005f, "D3DPushBuffer_SetPalette" },
  { 0x80060, "D3DPushBuffer_SetPrivateData" },
  { 0x80061, "D3DPushBuffer_SetRenderState" },
  { 0x80062, "D3DPushBuffer_SetRenderTarget" },
  { 0x80063, "D3DPushBuffer_SetTexture" },
  { 0x80064, "D3DPushBuffer_SetVertexBlendModelView" },
  { 0x80065, "D3DPushBuffer_SetVertexShaderConstant" },
  { 0x80066, "D3DPushBuffer_SetVertexShaderInput" },
  { 0x80067, "D3DPushBuffer_SetVertexShaderInputDirect" },
  { 0x80068, "D3DPushBuffer_Verify" },
  { 0x80069, "D3DResource_AddRef" },
  { 0x8006a, "D3DResource_BlockUntilNotBusy" },
  { 0x8006b, "D3DResource_FreePrivateData" },
  { 0x8006c, "D3DResource_GetDevice" },
  { 0x8006d, "D3DResource_GetPrivateData" },
  { 0x8006e, "D3DResource_GetType" },
  { 0x8006f, "D3DResource_IsBusy" },
  { 0x80070, "D3DResource_MoveResourceMemory" },
  { 0x80071, "D3DResource_Register" },
  { 0x80072, "D3DResource_Release" },
  { 0x80073, "D3DResource_SetPrivateData" },
  { 0x80074, "D3DSurface_AddRef" },
  { 0x80075, "D3DSurface_BlockUntilNotBusy" },
  { 0x80076, "D3DSurface_FreePrivateData" },
  { 0x80077, "D3DSurface_GetContainer2" },
  { 0x80078, "D3DSurface_GetDesc" },
  { 0x80079, "D3DSurface_GetDevice" },
  { 0x8007a, "D3DSurface_GetPrivateData" },
  { 0x8007b, "D3DSurface_GetType" },
  { 0x8007c, "D3DSurface_IsBusy" },
  { 0x8007d, "D3DSurface_LockRect" },
  { 0x8007e, "D3DSurface_MoveResourceMemory" },
  { 0x8007f, "D3DSurface_Register" },
  { 0x80080, "D3DSurface_Release" },
  { 0x80081, "D3DSurface_SetPrivateData" },
  { 0x80082, "D3DSurface_UnlockRect" },
  { 0x80083, "D3DTexture_AddRef" },
  { 0x80084, "D3DTexture_BlockUntilNotBusy" },
  { 0x80085, "D3DTexture_FreePrivateData" },
  { 0x80086, "D3DTexture_GetDevice" },
  { 0x80087, "D3DTexture_GetLevelCount" },
  { 0x80088, "D3DTexture_GetLevelDesc" },
  { 0x80089, "D3DTexture_GetPrivateData" },
  { 0x8008a, "D3DTexture_GetSurfaceLevel2" },
  { 0x8008b, "D3DTexture_GetType" },
  { 0x8008c, "D3DTexture_IsBusy" },
  { 0x8008d, "D3DTexture_LockRect" },
  { 0x8008e, "D3DTexture_MoveResourceMemory" },
  { 0x8008f, "D3DTexture_Register" },
  { 0x80090, "D3DTexture_Release" },
  { 0x80091, "D3DTexture_SetPrivateData" },
  { 0x80092, "D3DTexture_UnlockRect" },
  { 0x80093, "D3DVertexBuffer_AddRef" },
  { 0x80094, "D3DVertexBuffer_BlockUntilNotBusy" },
  { 0x80095, "D3DVertexBuffer_FreePrivateData" },
  { 0x80096, "D3DVertexBuffer_GetDesc" },
  { 0x80097, "D3DVertexBuffer_GetDevice" },
  { 0x80098, "D3DVertexBuffer_GetPrivateData" },
  { 0x80099, "D3DVertexBuffer_GetType" },
  { 0x8009a, "D3DVertexBuffer_IsBusy" },
  { 0x8009b, "D3DVertexBuffer_Lock2" },
  { 0x8009c, "D3DVertexBuffer_MoveResourceMemory" },
  { 0x8009d, "D3DVertexBuffer_Register" },
  { 0x8009e, "D3DVertexBuffer_Release" },
  { 0x8009f, "D3DVertexBuffer_SetPrivateData" },
  { 0x800a0, "D3DVertexBuffer_Unlock" },
  { 0x800a1, "D3DVolume_AddRef" },
  { 0x800a2, "D3DVolume_BlockUntilNotBusy" },
  { 0x800a3, "D3DVolume_FreePrivateData" },
  { 0x800a4, "D3DVolume_GetContainer2" },
  { 0x800a5, "D3DVolume_GetDesc" },
  { 0x800a6, "D3DVolume_GetDevice" },
  { 0x800a7, "D3DVolume_GetPrivateData" },
  { 0x800a8, "D3DVolume_GetType" },
  { 0x800a9, "D3DVolume_IsBusy" },
  { 0x800aa, "D3DVolume_LockBox" },
  { 0x800ab, "D3DVolume_MoveResourceMemory" },
  { 0x800ac, "D3DVolume_Register" },
  { 0x800ad, "D3DVolume_Release" },
  { 0x800ae, "D3DVolume_SetPrivateData" },
  { 0x800af, "D3DVolume_UnlockBox" },
  { 0x800b0, "D3DVolumeTexture_AddRef" },
  { 0x800b1, "D3DVolumeTexture_BlockUntilNotBusy" },
  { 0x800b2, "D3DVolumeTexture_FreePrivateData" },
  { 0x800b3, "D3DVolumeTexture_GetDevice" },
  { 0x800b4, "D3DVolumeTexture_GetLevelCount" },
  { 0x800b5, "D3DVolumeTexture_GetLevelDesc" },
  { 0x800b6, "D3DVolumeTexture_GetPrivateData" },
  { 0x800b7, "D3DVolumeTexture_GetType" },
  { 0x800b8, "D3DVolumeTexture_GetVolumeLevel2" },
  { 0x800b9, "D3DVolumeTexture_IsBusy" },
  { 0x800ba, "D3DVolumeTexture_LockBox" },
  { 0x800bb, "D3DVolumeTexture_MoveResourceMemory" },
  { 0x800bc, "D3DVolumeTexture_Register" },
  { 0x800bd, "D3DVolumeTexture_Release" },
  { 0x800be, "D3DVolumeTexture_SetPrivateData" },
  { 0x800bf, "D3DVolumeTexture_UnlockBox" },
  { 0x800c0, "Direct3D_AddRef" },
  { 0x800c1, "Direct3D_CheckDepthStencilMatch" },
  { 0x800c2, "Direct3D_CheckDeviceFormat" },
  { 0x800c3, "Direct3D_CheckDeviceMultiSampleType" },
  { 0x800c4, "Direct3D_CheckDeviceType" },
  { 0x800c5, "Direct3D_CreateDevice" },
  { 0x800c6, "Direct3D_EnumAdapterModes" },
  { 0x800c7, "Direct3D_GetAdapterCount" },
  { 0x800c8, "Direct3D_GetAdapterDisplayMode" },
  { 0x800c9, "Direct3D_GetAdapterIdentifier" },
  { 0x800ca, "Direct3D_GetAdapterModeCount" },
  { 0x800cb, "Direct3D_GetDeviceCaps" },
  { 0x800cc, "Direct3D_Release" },
  { 0x800cd, "Direct3D_SetPushBufferSize" },
  { 0x800ce, "IDirect3D8_AddRef" },
  { 0x800cf, "IDirect3D8_CheckDepthStencilMatch" },
  { 0x800d0, "IDirect3D8_CheckDeviceFormat" },
  { 0x800d1, "IDirect3D8_CheckDeviceMultiSampleType" },
  { 0x800d2, "IDirect3D8_CheckDeviceType" },
  { 0x800d3, "IDirect3D8_CreateDevice" },
  { 0x800d4, "IDirect3D8_EnumAdapterModes" },
  { 0x800d5, "IDirect3D8_GetAdapterCount" },
  { 0x800d6, "IDirect3D8_GetAdapterDisplayMode" },
  { 0x800d7, "IDirect3D8_GetAdapterIdentifier" },
  { 0x800d8, "IDirect3D8_GetAdapterModeCount" },
  { 0x800d9, "IDirect3D8_GetDeviceCaps" },
  { 0x800da, "IDirect3D8_Release" },
  { 0x800db, "IDirect3D8_SetPushBufferSize" },
  { 0x800dc, "IDirect3DBaseTexture8_AddRef" },
  { 0x800dd, "IDirect3DBaseTexture8_BlockUntilNotBusy" },
  { 0x800de, "IDirect3DBaseTexture8_FreePrivateData" },
  { 0x800df, "IDirect3DBaseTexture8_GetDevice" },
  { 0x800e0, "IDirect3DBaseTexture8_GetLevelCount" },
  { 0x800e1, "IDirect3DBaseTexture8_GetPrivateData" },
  { 0x800e2, "IDirect3DBaseTexture8_GetType" },
  { 0x800e3, "IDirect3DBaseTexture8_IsBusy" },
  { 0x800e4, "IDirect3DBaseTexture8_MoveResourceMemory" },
  { 0x800e5, "IDirect3DBaseTexture8_Register" },
  { 0x800e6, "IDirect3DBaseTexture8_Release" },
  { 0x800e7, "IDirect3DBaseTexture8_SetPrivateData" },
  { 0x800e8, "IDirect3DCubeTexture8_AddRef" },
  { 0x800e9, "IDirect3DCubeTexture8_BlockUntilNotBusy" },
  { 0x800ea, "IDirect3DCubeTexture8_FreePrivateData" },
  { 0x800eb, "IDirect3DCubeTexture8_GetCubeMapSurface" },
  { 0x800ec, "IDirect3DCubeTexture8_GetDevice" },
  { 0x800ed, "IDirect3DCubeTexture8_GetLevelCount" },
  { 0x800ee, "IDirect3DCubeTexture8_GetLevelDesc" },
  { 0x800ef, "IDirect3DCubeTexture8_GetPrivateData" },
  { 0x800f0, "IDirect3DCubeTexture8_GetType" },
  { 0x800f1, "IDirect3DCubeTexture8_IsBusy" },
  { 0x800f2, "IDirect3DCubeTexture8_LockRect" },
  { 0x800f3, "IDirect3DCubeTexture8_MoveResourceMemory" },
  { 0x800f4, "IDirect3DCubeTexture8_Register" },
  { 0x800f5, "IDirect3DCubeTexture8_Release" },
  { 0x800f6, "IDirect3DCubeTexture8_SetPrivateData" },
  { 0x800f7, "IDirect3DCubeTexture8_UnlockRect" },
  { 0x800f8, "IDirect3DFixup8_AddRef" },
  { 0x800f9, "IDirect3DFixup8_BlockUntilNotBusy" },
  { 0x800fa, "IDirect3DFixup8_FreePrivateData" },
  { 0x800fb, "IDirect3DFixup8_GetDevice" },
  { 0x800fc, "IDirect3DFixup8_GetPrivateData" },
  { 0x800fd, "IDirect3DFixup8_GetSize" },
  { 0x800fe, "IDirect3DFixup8_GetSpace" },
  { 0x800ff, "IDirect3DFixup8_GetType" },
  { 0x80100, "IDirect3DFixup8_IsBusy" },
  { 0x80101, "IDirect3DFixup8_MoveResourceMemory" },
  { 0x80102, "IDirect3DFixup8_Register" },
  { 0x80103, "IDirect3DFixup8_Release" },
  { 0x80104, "IDirect3DFixup8_Reset" },
  { 0x80105, "IDirect3DFixup8_SetPrivateData" },
  { 0x80106, "IDirect3DIndexBuffer8_AddRef" },
  { 0x80107, "IDirect3DIndexBuffer8_BlockUntilNotBusy" },
  { 0x80108, "IDirect3DIndexBuffer8_FreePrivateData" },
  { 0x80109, "IDirect3DIndexBuffer8_GetDesc" },
  { 0x8010a, "IDirect3DIndexBuffer8_GetDevice" },
  { 0x8010b, "IDirect3DIndexBuffer8_GetPrivateData" },
  { 0x8010c, "IDirect3DIndexBuffer8_GetType" },
  { 0x8010d, "IDirect3DIndexBuffer8_IsBusy" },
  { 0x8010e, "IDirect3DIndexBuffer8_Lock" },
  { 0x8010f, "IDirect3DIndexBuffer8_MoveResourceMemory" },
  { 0x80110, "IDirect3DIndexBuffer8_Register" },
  { 0x80111, "IDirect3DIndexBuffer8_Release" },
  { 0x80112, "IDirect3DIndexBuffer8_SetPrivateData" },
  { 0x80113, "IDirect3DIndexBuffer8_Unlock" },
  { 0x80114, "IDirect3DPalette8_AddRef" },
  { 0x80115, "IDirect3DPalette8_BlockUntilNotBusy" },
  { 0x80116, "IDirect3DPalette8_FreePrivateData" },
  { 0x80117, "IDirect3DPalette8_GetDevice" },
  { 0x80118, "IDirect3DPalette8_GetPrivateData" },
  { 0x80119, "IDirect3DPalette8_GetSize" },
  { 0x8011a, "IDirect3DPalette8_GetType" },
  { 0x8011b, "IDirect3DPalette8_IsBusy" },
  { 0x8011c, "IDirect3DPalette8_Lock" },
  { 0x8011d, "IDirect3DPalette8_MoveResourceMemory" },
  { 0x8011e, "IDirect3DPalette8_Register" },
  { 0x8011f, "IDirect3DPalette8_Release" },
  { 0x80120, "IDirect3DPalette8_SetPrivateData" },
  { 0x80121, "IDirect3DPalette8_Unlock" },
  { 0x80122, "IDirect3DPushBuffer8_AddRef" },
  { 0x80123, "IDirect3DPushBuffer8_BeginFixup" },
  { 0x80124, "IDirect3DPushBuffer8_BlockUntilNotBusy" },
  { 0x80125, "IDirect3DPushBuffer8_CopyRects" },
  { 0x80126, "IDirect3DPushBuffer8_EndFixup" },
  { 0x80127, "IDirect3DPushBuffer8_EndVisibilityTest" },
  { 0x80128, "IDirect3DPushBuffer8_FreePrivateData" },
  { 0x80129, "IDirect3DPushBuffer8_GetDevice" },
  { 0x8012a, "IDirect3DPushBuffer8_GetPrivateData" },
  { 0x8012b, "IDirect3DPushBuffer8_GetSize" },
  { 0x8012c, "IDirect3DPushBuffer8_GetType" },
  { 0x8012d, "IDirect3DPushBuffer8_IsBusy" },
  { 0x8012e, "IDirect3DPushBuffer8_Jump" },
  { 0x8012f, "IDirect3DPushBuffer8_MoveResourceMemory" },
  { 0x80130, "IDirect3DPushBuffer8_Register" },
  { 0x80131, "IDirect3DPushBuffer8_Release" },
  { 0x80132, "IDirect3DPushBuffer8_RunPushBuffer" },
  { 0x80133, "IDirect3DPushBuffer8_SetModelView" },
  { 0x80134, "IDirect3DPushBuffer8_SetPalette" },
  { 0x80135, "IDirect3DPushBuffer8_SetPrivateData" },
  { 0x80136, "IDirect3DPushBuffer8_SetRenderState" },
  { 0x80137, "IDirect3DPushBuffer8_SetRenderTarget" },
  { 0x80138, "IDirect3DPushBuffer8_SetTexture" },
  { 0x80139, "IDirect3DPushBuffer8_SetVertexBlendModelView" },
  { 0x8013a, "IDirect3DPushBuffer8_SetVertexShaderConstant" },
  { 0x8013b, "IDirect3DPushBuffer8_SetVertexShaderInput" },
  { 0x8013c, "IDirect3DPushBuffer8_SetVertexShaderInputDirect" },
  { 0x8013d, "IDirect3DPushBuffer8_Verify" },
  { 0x8013e, "IDirect3DResource8_AddRef" },
  { 0x8013f, "IDirect3DResource8_BlockUntilNotBusy" },
  { 0x80140, "IDirect3DResource8_FreePrivateData" },
  { 0x80141, "IDirect3DResource8_GetDevice" },
  { 0x80142, "IDirect3DResource8_GetPrivateData" },
  { 0x80143, "IDirect3DResource8_GetType" },
  { 0x80144, "IDirect3DResource8_IsBusy" },
  { 0x80145, "IDirect3DResource8_MoveResourceMemory" },
  { 0x80146, "IDirect3DResource8_Register" },
  { 0x80147, "IDirect3DResource8_Release" },
  { 0x80148, "IDirect3DResource8_SetPrivateData" },
  { 0x80149, "IDirect3DSurface8_AddRef" },
  { 0x8014a, "IDirect3DSurface8_BlockUntilNotBusy" },
  { 0x8014b, "IDirect3DSurface8_FreePrivateData" },
  { 0x8014c, "IDirect3DSurface8_GetContainer" },
  { 0x8014d, "IDirect3DSurface8_GetDesc" },
  { 0x8014e, "IDirect3DSurface8_GetDevice" },
  { 0x8014f, "IDirect3DSurface8_GetPrivateData" },
  { 0x80150, "IDirect3DSurface8_GetType" },
  { 0x80151, "IDirect3DSurface8_IsBusy" },
  { 0x80152, "IDirect3DSurface8_LockRect" },
  { 0x80153, "IDirect3DSurface8_MoveResourceMemory" },
  { 0x80154, "IDirect3DSurface8_Register" },
  { 0x80155, "IDirect3DSurface8_Release" },
  { 0x80156, "IDirect3DSurface8_SetPrivateData" },
  { 0x80157, "IDirect3DSurface8_UnlockRect" },
  { 0x80158, "IDirect3DTexture8_AddRef" },
  { 0x80159, "IDirect3DTexture8_BlockUntilNotBusy" },
  { 0x8015a, "IDirect3DTexture8_FreePrivateData" },
  { 0x8015b, "IDirect3DTexture8_GetDevice" },
  { 0x8015c, "IDirect3DTexture8_GetLevelCount" },
  { 0x8015d, "IDirect3DTexture8_GetLevelDesc" },
  { 0x8015e, "IDirect3DTexture8_GetPrivateData" },
  { 0x8015f, "IDirect3DTexture8_GetSurfaceLevel" },
  { 0x80160, "IDirect3DTexture8_GetType" },
  { 0x80161, "IDirect3DTexture8_IsBusy" },
  { 0x80162, "IDirect3DTexture8_LockRect" },
  { 0x80163, "IDirect3DTexture8_MoveResourceMemory" },
  { 0x80164, "IDirect3DTexture8_Register" },
  { 0x80165, "IDirect3DTexture8_Release" },
  { 0x80166, "IDirect3DTexture8_SetPrivateData" },
  { 0x80167, "IDirect3DTexture8_UnlockRect" },
  { 0x80168, "IDirect3DVertexBuffer8_AddRef" },
  { 0x80169, "IDirect3DVertexBuffer8_BlockUntilNotBusy" },
  { 0x8016a, "IDirect3DVertexBuffer8_FreePrivateData" },
  { 0x8016b, "IDirect3DVertexBuffer8_GetDesc" },
  { 0x8016c, "IDirect3DVertexBuffer8_GetDevice" },
  { 0x8016d, "IDirect3DVertexBuffer8_GetPrivateData" },
  { 0x8016e, "IDirect3DVertexBuffer8_GetType" },
  { 0x8016f, "IDirect3DVertexBuffer8_IsBusy" },
  { 0x80170, "IDirect3DVertexBuffer8_Lock" },
  { 0x80171, "IDirect3DVertexBuffer8_MoveResourceMemory" },
  { 0x80172, "IDirect3DVertexBuffer8_Register" },
  { 0x80173, "IDirect3DVertexBuffer8_Release" },
  { 0x80174, "IDirect3DVertexBuffer8_SetPrivateData" },
  { 0x80175, "IDirect3DVertexBuffer8_Unlock" },
  { 0x80176, "IDirect3DVolume8_AddRef" },
  { 0x80177, "IDirect3DVolume8_BlockUntilNotBusy" },
  { 0x80178, "IDirect3DVolume8_FreePrivateData" },
  { 0x80179, "IDirect3DVolume8_GetContainer" },
  { 0x8017a, "IDirect3DVolume8_GetDesc" },
  { 0x8017b, "IDirect3DVolume8_GetDevice" },
  { 0x8017c, "IDirect3DVolume8_GetPrivateData" },
  { 0x8017d, "IDirect3DVolume8_GetType" },
  { 0x8017e, "IDirect3DVolume8_IsBusy" },
  { 0x8017f, "IDirect3DVolume8_LockBox" },
  { 0x80180, "IDirect3DVolume8_MoveResourceMemory" },
  { 0x80181, "IDirect3DVolume8_Register" },
  { 0x80182, "IDirect3DVolume8_Release" },
  { 0x80183, "IDirect3DVolume8_SetPrivateData" },
  { 0x80184, "IDirect3DVolume8_UnlockBox" },
  { 0x80185, "IDirect3DVolumeTexture8_AddRef" },
  { 0x80186, "IDirect3DVolumeTexture8_BlockUntilNotBusy" },
  { 0x80187, "IDirect3DVolumeTexture8_FreePrivateData" },
  { 0x80188, "IDirect3DVolumeTexture8_GetDevice" },
  { 0x80189, "IDirect3DVolumeTexture8_GetLevelCount" },
  { 0x8018a, "IDirect3DVolumeTexture8_GetLevelDesc" },
  { 0x8018b, "IDirect3DVolumeTexture8_GetPrivateData" },
  { 0x8018c, "IDirect3DVolumeTexture8_GetType" },
  { 0x8018d, "IDirect3DVolumeTexture8_GetVolumeLevel" },
  { 0x8018e, "IDirect3DVolumeTexture8_IsBusy" },
  { 0x8018f, "IDirect3DVolumeTexture8_LockBox" },
  { 0x80191, "IDirect3DVolumeTexture8_MoveResourceMemory" },
  { 0x80192, "IDirect3DVolumeTexture8_Register" },
  { 0x80193, "IDirect3DVolumeTexture8_Release" },
  { 0x80194, "IDirect3DVolumeTexture8_SetPrivateData" },
  { 0x80195, "IDirect3DVolumeTexture8_UnlockBox" }
};

// Function mappings for XVOICE
std::unordered_map<uint32_t, std::string> functions_XVOICE = {
  { 0x70001, "XDEVICE_TYPE_HIGHFIDELITY_MICROPHONE_TABLE" },
  { 0x70002, "XDEVICE_TYPE_VOICE_HEADPHONE_TABLE" },
  { 0x70003, "XDEVICE_TYPE_VOICE_MICROPHONE_TABLE" },
  { 0x70004, "XVoiceCreateFourToFourFullDecoder" },
  { 0x70005, "XVoiceCreateFourToFourFullEncoder" },
  { 0x70006, "XVoiceCreateFourToFourRoundRobinEncoder" },
  { 0x70007, "XVoiceCreateFourToOneMixingDecoder" },
  { 0x70008, "XVoiceCreateMediaObject" },
  { 0x70009, "XVoiceCreateMediaObjectEx" },
  { 0x7000a, "XVoiceCreateOneToOneDecoder" },
  { 0x7000b, "XVoiceCreateOneToOneEncoder" },
  { 0x7000c, "XVoiceCreateTwoToOneMixingDecoder" },
  { 0x7000d, "XVoiceCreateTwoToTwoEncoder" },
  { 0x7000e, "XVoiceGetEncodedPacketEnergy" },
  { 0x7000f, "XVoiceQueueCreateMediaObject" },
  { 0x70010, "XVoiceSynchronizedQueueCreateMediaObject" }
};

using XTLIDMap = std::unordered_map<uint32_t, std::string>;

std::string DoXTLIDNameGen(uint32_t id) {
  // Extract lib_id from the upper 16 bits
  uint32_t lib_id = id >> 16;

  static const std::unordered_map<uint32_t, XTLIDMap&> generators = {
      {0x1, functions_XAPILIB},
      {0x2, functions_XAPILIB},
      {0x3, functions_XONLINES},
      {0x4, functions_XONLINES},
      {0x5, functions_XKBD},
      {0x6, functions_KEYBOARD},
      {0x7, functions_XVOICE},
      {0x8, functions_D3D},
      {0x9, functions_D3DX8},
      {0xA, functions_DMUSIC},
      {0xB, functions_DSOUND},
      {0xC, functions_XACT},
      {0xD, functions_XGRAPHICS},
      {0xE, functions_XMV},
  };

  // Lookup the library for the XTLID
  auto it = generators.find(lib_id);
  if (it != generators.end())
  {
    // Found library, now look for function inside it
    auto fn_it = it->second.find(id);
    if(fn_it != it->second.end())
      return fn_it->second;
  }

  // XTLID not found/invalid
  return "";
}
```

`xex1tool.cpp`:

```cpp
// xex1tool.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <iostream>
#include <cstdio>
#include <filesystem>
#include <cinttypes>

#include "3rdparty/cxxopts.hpp"
#include "3rdparty/date.hpp"

#include "formats/xex.hpp"
#include "formats/xex_headerids.hpp"

#include "formats/xdbf.hpp"

extern const char* key_names[4];
extern bool xex_log_verbose;

#ifndef _MSC_VER
inline int fopen_s(FILE** pFile, const char* filename, const char* mode)
{
  if (pFile == nullptr)
    return EINVAL;

  *pFile = fopen(filename, mode);
  if (*pFile == nullptr)
    return errno;

  return 0;
}
#endif

std::string time2str(uint32_t time)
{
  date::sys_seconds tp{ std::chrono::seconds{time} };
  return date::format("%a %b %d %I:%M:%S %Y", tp);
}

std::string titleid2str(uint32_t tid, bool id_only = false)
{
  char str[64];
  if (id_only || (((tid >> 24) & 0xFF) - 0x21 > 0x59) || (((tid >> 16) & 0xFF) - 0x21 > 0x59))
    snprintf(str, sizeof(str), "%08X", tid);
  else
    snprintf(str, sizeof(str), "%08X (%c%c-%d)", tid, ((tid >> 24) & 0xFF), ((tid >> 16) & 0xFF), (tid & 0xFFFF));

  return str;
}

bool LoadSpa(XEXFile& xex, xe::kernel::xam::xdbf::SpaFile& spa)
{
  uint32_t title_id = 0;
  auto* exec_info = xex.opt_header_ptr<xex_opt::XexExecutionId>(XEX_HEADER_EXECUTION_ID);
  if (exec_info)
    title_id = exec_info->TitleID;
  else
  {
    auto* exec_info25 = xex.opt_header_ptr<xex_opt::xex25::XexExecutionId>(XEX_HEADER_EXECUTION_ID_BETA);
    if (exec_info25)
      title_id = exec_info25->TitleID;
  }

  auto tid = titleid2str(title_id, true);

  auto& sects = xex.xex_sections();
  for (auto section : sects)
  {
    char name[9];
    std::copy_n(section.Name, 8, name);
    name[8] = '\0';

    if (std::string(name) != tid)
      continue;

    auto* data = xex.pe_data();
    data += xex.pe_rva_to_offset(section.VirtualAddress);
    auto size = std::min(section.SizeOfRawData, section.VirtualSize);

    return spa.Read(data, size);
  }

  return false;
}

std::string DoNameGen(const std::string& libName, int id, int version);

void PrintImports(XEXFile& xex) {
  printf("\nXEX Imports:\n");

  auto& tables = xex.import_tables();

  for (auto& lib : xex.imports()) {
    auto& libname = lib.first;

    int version = xex.min_kernel_version();

    if (tables.count(libname))
    {
      auto& table_header = tables.at(libname);

      printf("# %s v%d.%d.%d.%d\n# (min v%d.%d.%d.%d, %d imports)\n", libname.c_str(),
        table_header.Version.Major, table_header.Version.Minor, table_header.Version.Build, table_header.Version.QFE,
        table_header.VersionMin.Major, table_header.VersionMin.Minor, table_header.VersionMin.Build, table_header.VersionMin.QFE, int(lib.second.size()));

      version = table_header.Version.Build;
    }

    for (auto& imp : lib.second)
    {
      auto imp_name = DoNameGen(libname, imp.first, version);
      auto imp_addr = imp.second.ThunkAddr;

      printf("  %3d) %s\n", imp.first, imp_name.c_str());
    }
    printf("\n");
  }
}

void PrintInfo(XEXFile& xex, bool print_mem_pages)
{
  printf("\nXEX Info\n");

  auto& header = xex.header();
  const char* exe_type = nullptr;
  const char* exe_versions = nullptr;
  switch (header.Magic) {
  case MAGIC_XEX2:
    exe_type = "XEX2";
    exe_versions = ">=1861";
    break;
  case MAGIC_XEX1:
    exe_type = "XEX1";
    exe_versions = ">=1838";
    break;
  case MAGIC_XEX25:
    exe_type = "XEX25 ('XEX%')";
    exe_versions = ">=1746";
    break;
  case MAGIC_XEX2D:
    exe_type = "XEX2D ('XEX-')";
    exe_versions = ">=1640";
    break;
  case MAGIC_XEX3F:
    exe_type = "XEX3F ('XEX?')";
    exe_versions = ">=1434";
    break;
  case MAGIC_XEX0:
    exe_type = "XEX0";
    exe_versions = ">=1332";
    break;
  }

  if (!exe_type)
    return; // wtf

  printf("  %s %s (%s)\n", exe_type, xex.basefile_is_pe() ? "Executable" : "Image", exe_versions);

  // We only have pub keys / verify method for XEX2 atm
  // No point printing any misleading info...
  if (header.Magic == MAGIC_XEX2)
  {
    if (xex.valid_signature() && xex.sign_key_index() != -1)
      printf("  Valid RSA signature (signed with '%s' key)\n", xex.sign_key_name());
    else
      printf("  Invalid RSA signature!\n");

    if (!xex.valid_header_hash())
      printf("  Invalid header hash!\n");

    if (!xex.valid_imports_hash())
      printf("  Invalid import table hash!\n");
  }

  if (!xex.valid_image_hash())
    printf("  Invalid image hash!\n");

  bool encrypted = false;
  if (xex.data_descriptor())
  {
    auto* desc = xex.data_descriptor();
    encrypted = desc->Flags != 0;
    if (encrypted && xex.encryption_key_index() != -1)
      printf("  Encrypted using '%s' key\n", key_names[xex.encryption_key_index()]);
    else if (!encrypted)
      printf("  Not Encrypted\n");

    switch (desc->Format)
    {
    case xex_opt::XexDataFormat::None:
    case xex_opt::XexDataFormat::Raw:
      printf("  Not Compressed\n");
      break;
    case xex_opt::XexDataFormat::Compressed:
      printf("  Compressed\n");
      break;
    case xex_opt::XexDataFormat::DeltaCompressed:
      printf("  Delta Compressed\n");
      break;
    }
  }

  if (header.ModuleFlags.TitleProcess)
    printf("  Title Module\n");
  if (header.ModuleFlags.TitleImports)
    printf("  Title Exports\n");
  if (header.ModuleFlags.Debugger)
    printf("  System Debugger\n");
  if (header.ModuleFlags.Dll)
    printf("  DLL Module\n");
  if (header.ModuleFlags.PatchFull)
    printf("  Full Patch\n");
  if (header.ModuleFlags.PatchDelta)
    printf("  Delta Patch\n");
  if (header.ModuleFlags.UserMode)
    printf("  User Mode\n");

  auto& sec_info = xex.security_info();
  // Flags aren't correct for XEX2D afaik...
  if (header.Magic != MAGIC_XEX2D)
  {
    if (sec_info.ImageInfo.ImageFlags.Unknown1)
      printf("  Has Unknown1 flag\n");
    if (sec_info.ImageInfo.ImageFlags.ManufacturingUtility)
      printf("  Manufacturing Utility\n");
    if (sec_info.ImageInfo.ImageFlags.ManufacturingSupportTool)
      printf("  Manufacturing Support Tool\n");
    if (sec_info.ImageInfo.ImageFlags.Xgd2MediaOnly)
      printf("  XGD2 Media Only\n");
    if (sec_info.ImageInfo.ImageFlags.DataCenterRequired)
      printf("  DataCenter Required\n");
    if (sec_info.ImageInfo.ImageFlags.DataCenterAware)
      printf("  DataCenter Aware\n");
    if (sec_info.ImageInfo.ImageFlags.CardeaKey)
      printf("  Cardea Key\n");
    if (sec_info.ImageInfo.ImageFlags.XeikaKey)
      printf("  Xeika Key\n");
    if (sec_info.ImageInfo.ImageFlags.TitleUserMode)
      printf("  Title UserMode\n");
    if (sec_info.ImageInfo.ImageFlags.SystemUserMode)
      printf("  System UserMode\n");
    if (sec_info.ImageInfo.ImageFlags.Orange0)
      printf("  Orange0\n");
    if (sec_info.ImageInfo.ImageFlags.Orange1)
      printf("  Orange1\n");
    if (sec_info.ImageInfo.ImageFlags.Orange2)
      printf("  Orange2\n");
    if (sec_info.ImageInfo.ImageFlags.SignedKeyVaultRequired)
      printf("  Signed KeyVault Required\n");
    if (sec_info.ImageInfo.ImageFlags.IptvSignupApplication)
      printf("  Iptv Signup Application\n");
    if (sec_info.ImageInfo.ImageFlags.IptvTitleApplication)
      printf("  Iptv Title Application\n");
    if (sec_info.ImageInfo.ImageFlags.NccpKeys)
      printf("  NCCP Keys\n");
    if (sec_info.ImageInfo.ImageFlags.KeyVaultPrivilegesRequired)
      printf("  KeyVault Privileges Required\n");
    if (sec_info.ImageInfo.ImageFlags.OnlineActivationRequired)
      printf("  Online Activation Required\n");
    if (sec_info.ImageInfo.ImageFlags.PageSize4Kb)
      printf("  Page Size 4Kb\n");
    if (sec_info.ImageInfo.ImageFlags.NoGameRegion)
      printf("  No Game Region\n");
    if (sec_info.ImageInfo.ImageFlags.RevocationCheckOptional)
      printf("  Revocation Check Optional\n");
    if (sec_info.ImageInfo.ImageFlags.RevocationCheckRequired)
      printf("  Revocation Check Required\n");
  }

  auto mslogo = xex.has_header(XEX_HEADER_MSLOGO);
  if (mslogo)
    printf("  Xbox360 Logo Data Present\n");

  if (xex.has_header(XEX_HEADER_PE_IMPORTS))
    printf("  Imports By Name\n");

  if (xex.has_header(XEX_HEADER_PE_EXPORTS))
    printf("  Exports By Name\n");

  auto* callcap = xex.opt_header_ptr<xex_opt::XexCallcapImports>(XEX_HEADER_CALLCAP_IMPORTS);
  if (callcap)
    printf("  Has Call Cap Data   (%08X %08X)\n", (uint32_t)callcap->BeginFunctionThunkAddress, (uint32_t)callcap->EndFunctionThunkAddress);

  auto fastcap = xex.has_header(XEX_HEADER_FASTCAP_ENABLED);
  if (fastcap)
    printf("  Has Fast Cap Data   (%08X)\n", fastcap);

  auto addt_mem = xex.opt_header(XEX_HEADER_ADDITIONAL_TITLE_MEM);
  if (addt_mem)
    printf("  Requires %dMB Extra Debug Memory\n", addt_mem);

  printf("\nBasefile Info\n");
  auto& pe_name = xex.pe_module_name();
  if (pe_name.length())
    printf("  Original PE Name:   %s\n", pe_name.c_str());

  printf("  Base Address:       %08X\n", xex.base_address());
  printf("  Entry Point:        %08X\n", xex.entry_point());
  printf("  Image Size:         %8X\n", xex.image_size());
  auto page_size = xex.base_address() < 0x90000000 ? 64 * 1024 : 4 * 1024;
  printf("  Page Size:          %8X\n", page_size);
  auto* stats = xex.vital_stats();
  if (stats)
  {
    printf("  Checksum:           %08X\n", (uint32_t)stats->Checksum);

    // TODO: should this be the VA from inside PE headers?
    auto* exp_table = xex.opt_header_ptr<IMAGE_DATA_DIRECTORY>(XEX_HEADER_PE_EXPORTS);
    if (exp_table)
      printf("  Export Table:       %08X\n", exp_table->VirtualAddress);

    auto s = time2str(stats->Timestamp);
    printf("  Filetime:           %08X - %s\n", (uint32_t)stats->Timestamp, s.c_str());
  }
  auto size = xex.opt_header(XEX_HEADER_STACK_SIZE);
  if (size)
    printf("  Stack Size:         %8X\n", size);

  size = xex.opt_header(XEX_HEADER_XAPI_HEAP_SIZE);
  if (size)
    printf("  Heap Size:          %8X\n", size);

  auto* page_heap = xex.opt_header_ptr<xex_opt::XexPageHeapOptions>(XEX_HEADER_PAGE_HEAP_SIZE_FLAGS);
  if (page_heap)
  {
    printf("  Page Heap Size:     %8X\n", (uint32_t)page_heap->Size);
    printf("  Page Heap Flags:    %8X\n", (uint32_t)page_heap->Flags);
  }

  size = xex.opt_header(XEX_HEADER_WORKSPACE_SIZE);
  if (size)
    printf("  Workspace Size:     %8X\n", size);

  size = xex.opt_header(XEX_HEADER_FSCACHE_SIZE);
  if (size)
    printf("  Filesystem Cache Size:  %8X\n", size);

  // Write out region info (XEX1/XEX2 only)
  if (header.Magic == MAGIC_XEX1 || header.Magic == MAGIC_XEX2)
  {
    printf("\nRegions\n");
    if (sec_info.ImageInfo.ImageFlags.NoGameRegion || (sec_info.ImageInfo.GameRegion & xex::Region_All))
      printf("  All Regions\n");
    else
    {
      if (sec_info.ImageInfo.GameRegion & xex::Region_NorthAmerica)
        printf("  North America\n");
      if (sec_info.ImageInfo.GameRegion & xex::Region_Japan)
        printf("  Japan\n");
      if (sec_info.ImageInfo.GameRegion & xex::Region_China)
        printf("  China\n");
      if (sec_info.ImageInfo.GameRegion & xex::Region_RestOfAsia)
        printf("  Rest of Asia\n");
      if (sec_info.ImageInfo.GameRegion & xex::Region_AustraliaNewZealand)
        printf("  Australia & New Zealand\n");
      if (sec_info.ImageInfo.GameRegion & xex::Region_RestOfEurope)
        printf("  Rest of Europe\n");
      if (sec_info.ImageInfo.GameRegion & xex::Region_Europe)
        printf("  Europe\n");
      if (sec_info.ImageInfo.GameRegion & xex::Region_RestOfWorld)
        printf("  Rest of the World\n");
    }
  }

  if (header.Magic == MAGIC_XEX2 || header.Magic == MAGIC_XEX1 || header.Magic == MAGIC_XEX25)
  {
    printf("\nAllowed Media\n");
    auto media_int = *(uint32_t*)&sec_info.AllowedMediaTypes;
    if (sec_info.ImageInfo.ImageFlags.Xgd2MediaOnly)
    {
      if (sec_info.AllowedMediaTypes.DvdCd)
        printf("  DVD-XGD2 (Xbox360 Original Disc)\n");
      else
        printf("  Updated DVD-XGD2 (Updated version of Xbox360 Original Disc)\n");
    }
    else
    {
      if (!media_int || media_int == 0xFFFFFFFF)
        printf("  All Media Types\n");
      else {
        if (sec_info.AllowedMediaTypes.HardDisk)
          printf("  Hard Disk\n");
        if (sec_info.AllowedMediaTypes.DvdX2)
          printf("  DVD-X2 (Xbox OG Original Disc)\n");
        if (sec_info.AllowedMediaTypes.DvdCd)
          printf("  DVD / CD\n");
        if (sec_info.AllowedMediaTypes.Dvd5)
          printf("  DVD-5\n");
        if (sec_info.AllowedMediaTypes.Dvd9)
          printf("  DVD-9\n");
        if (sec_info.AllowedMediaTypes.SystemFlash)
          printf("  System Flash\n");
        if (sec_info.AllowedMediaTypes._Unknown40)
          printf("  _Unknown40\n");
        if (sec_info.AllowedMediaTypes.MemoryUnit)
          printf("  Memory Unit\n");
        if (sec_info.AllowedMediaTypes.MassStorageDevice)
          printf("  USB Mass Storage Device\n");
        if (sec_info.AllowedMediaTypes.SmbFilesystem)
          printf("  Networked SMB Share\n");
        if (sec_info.AllowedMediaTypes.DirectFromRam)
          printf("  Direct From RAM\n");
        if (sec_info.AllowedMediaTypes._Unknown800)
          printf("  _Unknown800\n");
        if (sec_info.AllowedMediaTypes.SecureVirtualOpticalDevice)
          printf("  Secure Virtual Optical Device (\"SVOD\")\n");
        if (sec_info.AllowedMediaTypes.WirelessNStorageDevice)
          printf("  WirelessN Storage Device\n");
        if (sec_info.AllowedMediaTypes.SystemExtendedPartition)
          printf("  System Extended Partition (\"SEP\")\n");
        if (sec_info.AllowedMediaTypes.SystemAuxiliaryPartition)
          printf("  System Auxiliary Partition (\"SAP\")\n");
        if (sec_info.AllowedMediaTypes.InsecurePackage)
          printf("  Insecure Package (\"CON\")\n");
        if (sec_info.AllowedMediaTypes.SaveGamePackage)
          printf("  Savegame Package (\"CON\")\n");
        if (sec_info.AllowedMediaTypes.LocallySignedPackage)
          printf("  Locally Signed Package (\"CON\")\n");
        if (sec_info.AllowedMediaTypes.LiveSignedPackage)
          printf("  Live Signed Package (\"LIVE\")\n");
        if (sec_info.AllowedMediaTypes.XboxPlatformPackage)
          printf("  Xbox Platform Package (\"PIRS\")\n");
      }
    }
  }


  auto privileges = xex.opt_header(XEX_HEADER_PRIVILEGES);
  auto privileges32 = xex.opt_header(XEX_HEADER_PRIVILEGES_32);
  if (privileges || privileges32)
  {
    printf("\nXEX Privileges\n");
    if (privileges)
    {
      auto* privs = (xex_opt::XexPrivileges*)&privileges;
      if (privs->NoForceReboot)
        printf("   0x0: No Force Reboot\n");
      if (privs->ForegroundTasks)
        printf("   0x1: Foreground Tasks\n");
      if (privs->NoOddMapping)
        printf("   0x2: No ODD Mapping\n");
      if (privs->HandleMceInput)
        printf("   0x3: Handles MCE Input\n");
      if (privs->RestrictHudFeatures)
        printf("   0x4: Restricted HUD Features\n");
      if (privs->HandleGamepadDisconnect)
        printf("   0x5: Handles Gamepad Disconnect\n");
      if (privs->InsecureSockets)
        printf("   0x6: Has Insecure Sockets\n");
      if (privs->Xbox1XspInterop)
        printf("   0x7: Xbox1 XSP Interoperability\n");
      if (privs->SetDashContext)
        printf("   0x8: Can Set Dash Context\n");
      if (privs->TitleUsesGameVoiceChannel)
        printf("   0x9: Uses Game Voice Channel\n");
      if (privs->TitlePal50Incompatible)
        printf("   0xA: PAL-50 Incompatible\n");
      if (privs->TitleInsecureUtilityDrive)
        printf("   0xB: Supports Insecure Utility Drive\n");
      if (privs->TitleXamHooks)
        printf("   0xC: Xam Hooks\n");
      if (privs->TitlePii)
        printf("   0xD: PII\n");
      if (privs->CrossplatformSystemLink)
        printf("   0xE: Crossplatform System Link\n");
      if (privs->MultidiscSwap)
        printf("   0xF: Multidisc Swap\n");
      if (privs->MultidiscInsecureMedia)
        printf("  0x10: Supports Insecure Multidisc Media\n");
      if (privs->Ap25Media)
        printf("  0x11: AP25 Media\n");
      if (privs->NoConfirmExit)
        printf("  0x12: No Confirm Exit\n");
      if (privs->AllowBackgroundDownload)
        printf("  0x13: Allows Background Downloads\n");
      if (privs->CreatePersistableRamdrive)
        printf("  0x14: Creates Persistable Ramdrive\n");
      if (privs->InheritPersistedRamdrive)
        printf("  0x15: Inherits Persisted Ramdrive\n");
      if (privs->AllowHudVibration)
        printf("  0x16: Allows HUD Vibration\n");
      if (privs->TitleBothUtilityPartitions)
        printf("  0x17: Can Use Both Utility Partitions\n");
      if (privs->HandleIPTVInput)
        printf("  0x18: Handles IPTV Input\n");
      if (privs->PreferBigButtonInput)
        printf("  0x19: Prefers Big Button Input\n");
      if (privs->AllowXsamReservation)
        printf("  0x1A: Allow Xsam Reservation\n");
      if (privs->MultidiscCrossTitle)
        printf("  0x1B: Multidisc Cross Title\n");
      if (privs->TitleInstallIncompatible)
        printf("  0x1C: Title Install Incompatible\n");
      if (privs->AllowAvatarGetMetadataByXUID)
        printf("  0x1D: Allow Avatar Get Metadata By XUID\n");
      if (privs->AllowControllerSwapping)
        printf("  0x1E: Allow Controller Swapping\n");
      if (privs->DashExtensibilityModule)
        printf("  0x1F: Dash Extensibility Module\n");
    }

    if (privileges32)
    {
      auto* privs = (xex_opt::XexPrivileges32*)&privileges32;
      if (privs->AllowNetworkReadCancel)
        printf("  0x20: Allow Network Read Cancel\n");
      if (privs->UninterruptableReads)
        printf("  0x21: Uninterruptable Reads\n");
      if (privs->RequireExperienceFull)
        printf("  0x22: Requires NXE\n");
      if (privs->GameVoiceRequiredUI)
        printf("  0x23: Game Voice Required UI\n");
      if (privs->TitleSetPresenceString)
        printf("  0x24: Sets Presence String\n");
      if (privs->NatalTiltControl)
        printf("  0x25: Natal Tilt Control\n");
      if (privs->TitleRequiresSkeletalTracking)
        printf("  0x26: Requires Skeletal Tracking\n");
      if (privs->TitleSupportsSkeletalTracking)
        printf("  0x27: Supports Skeletal Tracking\n");
      if (privs->UseLargeHDsFileCache)
        printf("  0x28: Uses Large HDs File Cache\n");
      if (privs->TitleSupportsDeepLink)
        printf("  0x29: Supports Deep Link\n");
      if (privs->TitleBodyProfile)
        printf("  0x2A: Supports Body Profile\n");
      if (privs->TitleWinUSB)
        printf("  0x2B: Supports WinUSB\n");
      if (privs->TitleSupportsDeepLinkRefresh)
        printf("  0x2C: Supports Deep Link Refresh\n");
      if (privs->LocalOnlySockets)
        printf("  0x2D: Local Only Sockets\n");
      if (privs->TitleContentAcquireAndDownload)
        printf("  0x2E: Title Content Acquire And Download\n");
      if (privs->AllowSystemForeground)
        printf("  0x2F: Allow System Foreground\n");
    }
  }

  if (header.Magic == MAGIC_XEX2 || header.Magic == MAGIC_XEX1)
  {
    printf("\nMedia ID\n  ");
    for (int i = 0; i < 0x10; i++)
      printf("%02X ", sec_info.ImageInfo.MediaID[i]);
    printf("\n");
  }

  auto* key = (const uint8_t*)xex.opt_header_ptr(XEX_HEADER_DISC_PROFILE_ID);
  if (key)
  {
    printf("\nDisc Profile ID\n  ");
    for (int i = 0; i < 0x10; i++)
      printf("%02X ", key[i]);
    printf("\n");
  }

  if (header.Magic != MAGIC_XEX3F && header.Magic != MAGIC_XEX0) // these two don't use crypto
  {
    key = encrypted ? xex.session_key() : sec_info.ImageInfo.ImageKey;
    if (encrypted)
      printf("\nEncryption Key (key decrypted using %s key)\n  ", key_names[xex.encryption_key_index()]);
    else
      printf("\nEncryption Key (raw value)\n  ");
    for (int i = 0; i < 0x10; i++)
      printf("%02X ", key[i]);
    printf("\n");
  }

  key = (uint8_t*)xex.opt_header_ptr(XEX_HEADER_LAN_KEY);
  if (key)
  {
    printf("\nLAN Key\n  ");
    for (int i = 0; i < 0x10; i++)
      printf("%02X ", key[i]);
    printf("\n");
  }

  key = (uint8_t*)xex.opt_header_ptr(XEX_PATCH_FILE_BASE_REFERENCE);
  if (key)
  {
    printf("\nPatch Base Reference\n  ");
    for (int i = 0; i < 0x14; i++)
      printf("%02X ", key[i]);
    printf("\n");
  }

  auto* time_range = xex.opt_header_ptr<xex_opt::XexSystemTimeRange>(XEX_HEADER_TIME_RANGE);
  if (!time_range)
  {
    time_range = xex.opt_header_ptr<xex_opt::XexSystemTimeRange>(XEX_HEADER_TIME_RANGE_ALT);
    if (time_range)
      printf("\n[+] Uses alt time range header!!!\n");
  }
  auto* kv_privs = xex.opt_header_ptr<xex_opt::XexKeyVaultPrivileges>(XEX_HEADER_KEY_VAULT_PRIVS);
  if (!kv_privs)
  {
    kv_privs = xex.opt_header_ptr<xex_opt::XexKeyVaultPrivileges>(XEX_HEADER_KEY_VAULT_PRIVS_ALT);
    if (kv_privs)
      printf("\n[+] Uses alt KV privs header!!!\n");
  }
  if (time_range || kv_privs)
  {
    printf("\nRestrictions for Use\n");
    // TODO: print these as strings!
    if (time_range)
    {
      printf("  Start Date:         %" PRIX64 "\n", (uint64_t)time_range->Start);
      printf("  End Date:           %" PRIX64 "\n", (uint64_t)time_range->End);
    }
    if (kv_privs)
    {
      printf("  KeyVault Mask:      %" PRIX64 "\n", (uint64_t)kv_privs->Mask);
      printf("  KeyVault Value:     %" PRIX64 "\n", (uint64_t)kv_privs->Match);
    }
    // TODO: consoleID table
  }

  auto* bound_path = xex.opt_header_ptr<xex_opt::XexStringHeader>(XEX_HEADER_BOUND_PATH);
  if (bound_path)
  {
    printf("\nBound Path\n");
    printf("  %.*s\n", (uint32_t)bound_path->Size, bound_path->Data);
  }

  key = (uint8_t*)xex.opt_header_ptr(XEX_HEADER_DEVICE_ID);
  if (key)
  {
    printf("\nBound Device ID\n  ");
    for (int i = 0; i < 0x14; i++)
      printf("%02X ", key[i]);
    printf("\n");
  }

  auto* tls_info = xex.opt_header_ptr<xex_opt::XexTlsData>(XEX_HEADER_TLS_DATA);
  if (tls_info)
  {
    printf("\nTLS Info\n");
    printf("  Number of Slots:    %d\n", (uint32_t)tls_info->TlsSlotCount);
    printf("  Data Size:          %08X\n", (uint32_t)tls_info->SizeOfTlsData);
    printf("  Raw Data Address:   %08X\n", (uint32_t)tls_info->AddressOfRawData);
    printf("  Raw Data Size:      %08X\n", (uint32_t)tls_info->SizeOfRawData);
  }

  if (header.Magic != MAGIC_XEX2D)
  {
    auto* exec_info = xex.opt_header_ptr<xex_opt::XexExecutionId>(XEX_HEADER_EXECUTION_ID);
    if (exec_info)
    {
      printf("\nExecution ID\n");
      printf("  Media ID:           %08X\n", (uint32_t)exec_info->MediaID);
      printf("  Title ID:           %s\n", titleid2str(exec_info->TitleID).c_str());
      printf("  Savegame ID:        %08X\n", (uint32_t)exec_info->SaveGameID);
      printf("  Version:            v%d.%d.%d.%d\n", exec_info->Version.Major, exec_info->Version.Minor, exec_info->Version.Build, exec_info->Version.QFE);
      printf("  Base Version:       v%d.%d.%d.%d\n", exec_info->BaseVersion.Major, exec_info->BaseVersion.Minor, exec_info->BaseVersion.Build, exec_info->BaseVersion.QFE);
      printf("  Platform:           %d\n", exec_info->Platform);
      printf("  Executable Type:    %d\n", exec_info->ExecutableType);
      printf("  Disc Number:        %d\n", exec_info->DiscNum);
      printf("  Number of Discs:    %d\n", exec_info->DiscsInSet);
    }
  }
  else
  {
    auto* exec_info = xex.opt_header_ptr<xex_opt::xex2d::XexExecutionId>(XEX_HEADER_EXECUTION_ID);
    if (exec_info)
    {
      printf("\nExecution ID (XEX2D)\n");
      printf("  Media ID:           %08X\n", (uint32_t)exec_info->MediaID);
      printf("  Title ID:           %s\n", titleid2str(exec_info->TitleID).c_str());
      printf("  Savegame ID:        %X\n", exec_info->SaveGameID);
      printf("  Version:            v%d.%d.%d.%d\n", exec_info->Version.Major, exec_info->Version.Minor, exec_info->Version.Build, exec_info->Version.QFE);
      printf("  UpdatedVersion:     %04X\n", (uint16_t)exec_info->UpdatedVersion);
      printf("  Region:             %04X\n", (uint16_t)exec_info->Region);
      printf("  Rating:             %08X\n", (uint32_t)exec_info->Rating);
      printf("  Platform:           %d\n", exec_info->Platform);
      printf("  Executable Type:    %d\n", exec_info->ExecutableType);
      printf("  Disc Number:        %d\n", exec_info->DiscNum);
    }
  }

  auto* exec_info25 = xex.opt_header_ptr<xex_opt::xex25::XexExecutionId>(XEX_HEADER_EXECUTION_ID_BETA);
  if (exec_info25)
  {
    printf("\nExecution ID (XEX25)\n");
    printf("  Media ID:           %08X\n", (uint32_t)exec_info25->MediaID);
    printf("  Title ID:           %s\n", titleid2str(exec_info25->TitleID).c_str());
    printf("  Savegame ID:        %08X\n", (uint32_t)exec_info25->SaveGameID);
    printf("  Version:            v%d.%d.%d.%d\n", exec_info25->Version.Major, exec_info25->Version.Minor, exec_info25->Version.Build, exec_info25->Version.QFE);
    printf("  Platform:           %d\n", (uint32_t)exec_info25->Platform);
    printf("  Executable Type:    %d\n", (uint32_t)exec_info25->ExecutableType);
    printf("  Disc Number:        %d\n", (uint32_t)exec_info25->DiscNum);
    printf("  Number of Discs:    %d\n", (uint32_t)exec_info25->DiscsInSet);
  }

  // TODO: read in as XEX3F/XEX0 depending on variant when XEX0 support is added!
  auto* exec_info3f = xex.opt_header_ptr<xex_opt::xex3f::XexExecutionId>(XEX_HEADER_EXECUTION_ID_BETA3F);
  if (exec_info3f)
  {
    if (header.Magic == MAGIC_XEX3F)
      printf("\nExecution ID (XEX3F)\n");
    else
      printf("\nExecution ID (XEX0)\n");
    printf("  Media ID:           %08X\n", (uint32_t)exec_info3f->MediaID);
    printf("  Title ID:           %s\n", titleid2str(exec_info3f->TitleID).c_str());
    printf("  Savegame ID:        %X\n", exec_info3f->SaveGameID);
    printf("  Version:            v%d.%d.%d.%d\n", exec_info3f->Version.Major, exec_info3f->Version.Minor, exec_info3f->Version.Build, exec_info3f->Version.QFE);
    printf("  UpdatedVersion:     %04X\n", (uint16_t)exec_info3f->UpdatedVersion);
    printf("  Region:             %04X\n", (uint16_t)exec_info3f->Region);
    printf("  Platform:           %d\n", exec_info3f->Platform);
    if (header.Magic == MAGIC_XEX3F)
      printf("  Executable Type:    %d\n", exec_info3f->ExecutableType);
    else
      printf("  Content Type:       %d\n", exec_info3f->ExecutableType);
    printf("  Disc Number:        %d\n", exec_info3f->DiscNum);
  }

  xe::kernel::xam::xdbf::SpaFile spa;
  if (LoadSpa(xex, spa)) {
    printf("\nSPA / XDBF Info\n");
    printf("  Title Name:         %s\n", spa.GetTitleName().c_str());
    xe::kernel::xam::xdbf::X_XDBF_XTHD_DATA title_data;
    if (spa.GetTitleData(&title_data))
    {
      printf("  Title Type:         %d\n", (uint32_t)title_data.title_type);
      printf("  XDBF Version:       v%d.%d.%d.%d\n", (uint32_t)title_data.title_version_major, (uint32_t)title_data.title_version_minor, (uint32_t)title_data.title_version_build, (uint32_t)title_data.title_version_revision);
    }
    printf("  Achievement Count:  %d\n", spa.GetAchievements(xe::kernel::xam::xdbf::XLanguage::kEnglish, nullptr));
  }

  auto* title_ids = xex.opt_header_ptr<uint32_t>(XEX_HEADER_ALTERNATE_TITLE_IDS);
  if (title_ids)
  {
    uint32_t size = xe::byte_swap(*title_ids);
    uint32_t count = (size - 4) / sizeof(uint32_t);
    if (count > 0)
    {
      printf("\nAlternate Title Ids\n");
      title_ids++;
      for (uint32_t i = 0; i < count; i++)
      {
        uint32_t tid = xe::byte_swap(*title_ids);
        title_ids++;
        printf("  %3d) %s\n", i, titleid2str(tid).c_str());
      }
    }
  }

  auto* patch_info_og = xex.opt_header_ptr<xex_opt::XexDeltaPatchDescriptor>(XEX_HEADER_DELTA_PATCH_DESCRIPTOR);
  if (patch_info_og) {
    xex_opt::XexDeltaPatchDescriptor patch_info = *patch_info_og;

    *(uint32_t*)&patch_info.SourceVersion = xe::byte_swap(*(uint32_t*)&patch_info.SourceVersion);
    *(uint32_t*)&patch_info.TargetVersion = xe::byte_swap(*(uint32_t*)&patch_info.TargetVersion);

    uint32_t media_id;
    media_id = xe::byte_swap(*(uint32_t*)(&xex.security_info().ImageInfo.MediaID[0xC]));

    printf("\nDelta Patch Descriptor\n");
    printf("  Media ID:               %08X\n", media_id);
    printf("  Source Version:         v%d.%d.%d.%d\n", patch_info.SourceVersion.Major, patch_info.SourceVersion.Minor, patch_info.SourceVersion.Build, patch_info.SourceVersion.QFE);
    printf("  Target Version:         v%d.%d.%d.%d\n", patch_info.TargetVersion.Major, patch_info.TargetVersion.Minor, patch_info.TargetVersion.Build, patch_info.TargetVersion.QFE);
  
    printf("  Headers source offset:  %X\n", uint32_t(patch_info.DeltaHeadersSourceOffset));
    printf("  Headers source size:    %X\n", uint32_t(patch_info.DeltaHeadersSourceSize));
    printf("  Headers target offset   %X\n", uint32_t(patch_info.DeltaHeadersTargetOffset));

    printf("  Image source offset:    %X\n", uint32_t(patch_info.DeltaImageSourceOffset));
    printf("  Image source size:      %X\n", uint32_t(patch_info.DeltaImageSourceSize));
    printf("  Image target offset:    %X\n", uint32_t(patch_info.DeltaImageTargetOffset));

    printf("  Target header size:     %X\n", uint32_t(patch_info.SizeOfTargetHeaders));

    printf("\n  Source Digest\n    ");
    for (int i = 0; i < 0x14; i++)
      printf("%02X ", patch_info.DigestSource[i]);
    printf("\n");

    printf("\n  Source Image Key\n    ");
    for (int i = 0; i < 0x10; i++)
      printf("%02X ", patch_info.ImageKeySource[i]);
    printf("\n");
  }

  // TODO: ratings!

  auto* libs = xex.opt_header_ptr<xex_opt::XexImageLibraryVersions>(XEX_HEADER_BUILD_VERSIONS);
  if (libs)
  {
    printf("\nStatic Libraries\n");
    auto count = libs->Size / sizeof(xex_opt::XexImageLibraryVersion);

    for (uint32_t i = 0; i < count; i++)
    {
      auto& lib = libs->Libraries[i];

      char details[256];
      snprintf(details, sizeof(details), "%3d) %-14.8s v%d.%d.%d.%d", i, lib.LibraryName, (uint16_t)lib.Version.Major, (uint16_t)lib.Version.Minor, (uint16_t)lib.Version.Build, (uint16_t)lib.Version.QFE);
    
      printf("  %-32s  (", details);

      if ((lib.Version.ApprovalType & xex::ApprovalType_Expired) == xex::ApprovalType_Expired)
        printf("Expired");
      else if (lib.Version.ApprovalType & xex::ApprovalType_PossiblyApproved)
        printf("Possibly Approved");
      else if (lib.Version.ApprovalType & xex::ApprovalType_Approved)
        printf("Approved");
      else
        printf("Unapproved");

      if (lib.Version.ApprovalType & xex::ApprovalType_Tool)
        printf(", Tool Version");
      if (lib.Version.ApprovalType & xex::ApprovalType_Executable)
        printf(", Executable Version");
      if (lib.Version.ApprovalType & xex::ApprovalType_Debug)
        printf(", Debug Build");
      printf(")\n");
    }
  }

  auto& import_tables = xex.import_tables();
  auto& imports = xex.imports();
  if (import_tables.size())
  {
    printf("\nImport Libraries\n");
    int i = 0;
    for (auto kvp : import_tables) {
      char details[256];
      snprintf(details, sizeof(details), "%3d) %-14s v%d.%d.%d.%d", i, kvp.first.c_str(), kvp.second.Version.Major, kvp.second.Version.Minor, kvp.second.Version.Build, kvp.second.Version.QFE);

      printf("  %-32s  (min v%d.%d.%d.%d, %d imports)\n", details, 
        kvp.second.VersionMin.Major, kvp.second.VersionMin.Minor, kvp.second.VersionMin.Build, kvp.second.VersionMin.QFE, (uint32_t)(imports.at(kvp.first).size()));

      i++;
    }
  }

  auto& sections = xex.xex_sections();
  if (sections.size())
  {
    printf("\nResources\n");
    int i = 0;
    for (auto section : sections) {
      auto start = section.VirtualAddress + xex.base_address();
      auto end = start + section.VirtualSize;
      printf("  %3d) %08X - %08X : %.8s\n", i, start, end, section.Name);
      i++;
    }
  }

  if (!print_mem_pages)
    return;

  auto& page_descriptors = xex.page_descriptors();
  if (page_descriptors.size())
  {
    printf("\nMemory Pages\n");
    int i = 0;
    uint32_t address = xex.base_address();
    for (auto page : page_descriptors)
    {
      auto size = page.Size * page_size;
      auto details = "Data";
      if (page.Info & xex::PageInfoFlag_NoWrite)
      {
        if (page.Info & xex::PageInfoFlag_NoExecute)
          details = "Header/Resource";
        else
          details = "Code";
      }

      printf("  %3d) %08X - %08X : %s\n", i, address, address + size, details);
      address += size;
      i++;
    }
  }
}

int main(int argc, char* argv[])
{
  cxxopts::Options options("xex1tool");
  options.add_options()
    ("l,listing", "Print executable info")
    ("m,listmem", "Print executable info & memory pages")
    ("i,imports", "Print import libraries & functions")
    ("b,basefile", "Dump basefile from XEX", cxxopts::value<std::string>())
    ("d,dumpres", "Dump all resources to a dir (can be '.')", cxxopts::value<std::string>())
    ("v,verbose", "Enables verbose XEXFile debug output")
    ("a,address", "Convert a virtual memory address to file offset, or vice-versa", cxxopts::value<uint32_t>())
    ("positional", "Positional parameters",
      cxxopts::value<std::vector<std::string>>())
    ;
  options.positional_help("input-filepath");
  options.parse_positional({ "positional" });

  printf("xex1tool  -  emoose\n");

  auto result = options.parse(argc, argv);

  if (!result.count("positional"))
  {
    printf("%s", options.help().c_str());
    return 0;
  }

  auto& positional = result["positional"].as<std::vector<std::string>>();

  if (!positional.size())
  {
    printf("%s", options.help().c_str());
    return 0;
  }

  auto& filepath = positional[0];

  xex_log_verbose = result["v"].as<bool>();

  printf("Reading and parsing input XEX file...\n");

  FILE* file;
  auto res = fopen_s(&file, filepath.c_str(), "rb");

  if (!file)
  {
    printf("Error opening XEX file %s\n", filepath.c_str());
    return 0;
  }

  XEXFile xex;

  bool loadresult = xex.load(file);

  if (!loadresult)
  {
    printf("Error %d while loading XEX file %s\n", xex.load_error(), filepath.c_str());
    return xex.load_error();
  }

  if (result.count("a"))
  {
    uint32_t rva = result["a"].as<uint32_t>();
    printf("\n");

    bool convert = true;
    auto* data_descriptor = xex.data_descriptor();
    if (!data_descriptor)
      convert = false;
    else
    {
      xex_opt::XexDataFormat comp_format = (xex_opt::XexDataFormat)(uint16_t)data_descriptor->Format;
      convert = comp_format == xex_opt::XexDataFormat::None || comp_format == xex_opt::XexDataFormat::Raw;
    }

    if (!convert)
      printf("XEX isn't uncompressed, unable to convert address with -a!\n");
    else
    {
      // TODO: fix these functions to work with older formats
      if (xex.header().Magic != MAGIC_XEX2)
        printf("XEX isn't XEX2, addresses might not be correct!\n");

      uint32_t result = 0;
      if (rva >= xex.base_address())
      {
        result = xex.xex_va_to_offset(rva);
        printf("Virtual Address -> File Offset\n");
        printf("Virtual Addr: 0x%X\n", rva);
        printf("File Offset:  0x%X\n", result);
      }
      else
      {
        result = xex.xex_offset_to_va(rva);
        printf("File Offset -> Virtual Address\n");
        printf("File Offset:  0x%X\n", rva);
        printf("Virtual Addr: 0x%X\n", result);
      }

      if (!result)
      {
        printf("\nThe given address was unable to be converted, either:\n");
        printf("- The given number is invalid\n");
        printf("- The address is out-of-bounds\n");
        printf("- The VA is part of a zero-compressed block in the file\n");
        printf("(even with uncompressed XEXs, blocks of zeroes are removed from the file to save some space)\n");
      }
    }

    printf("\n");
  }

  if (result.count("b"))
  {
    auto& basefile = result["b"].as<std::string>();
    FILE* output;
    auto res = fopen_s(&output, basefile.c_str(), "wb");
    if (res != 0 || !output) {
      printf("Error %d opening basefile %s for write\n", res, basefile.c_str());
    }
    else {
      fwrite(xex.pe_data(), 1, xex.pe_data_length(), output);
      fclose(output);
      printf("Successfully dumped basefile to %s\n", basefile.c_str());

      if (xex.basefile_is_pe())
      {
        printf("\nLoad basefile into IDA with the following details\n");
        printf("DO NOT load as a PE or EXE file as the format is not valid\n");
        printf("File Type:       Binary file\n");
        printf("Processor Type:  PowerPC: ppcbe\n");
        printf("Load Address:    0x%08X\n", xex.base_address());
        printf("Entry Point:     0x%08X\n", xex.entry_point());
      }
    }
  }

  if (result.count("d"))
  {
    auto& sections = xex.xex_sections();
    if (sections.size())
    {
      auto& dump_path_s = result["d"].as<std::string>();
      if (dump_path_s != ".")
        std::filesystem::create_directory(dump_path_s);
      std::filesystem::path dump_path = dump_path_s;

      std::vector<std::string> dumped_names;
      for (auto section : sections)
      {
        char sectname_safe[9];
        std::copy_n(section.Name, 8, sectname_safe);
        sectname_safe[8] = '\0';

        // Check if we've dumped the same filename before, try adding a number if we have
        std::string sectname = sectname_safe;
        int i = 0;
        while (std::find(dumped_names.begin(), dumped_names.end(), sectname) != dumped_names.end())
            sectname = std::string(sectname_safe) + "_" + std::to_string(++i);

        dumped_names.push_back(sectname);

        std::filesystem::path res_path = dump_path / sectname;
        FILE* file;
        if (auto res = fopen_s(&file, res_path.string().c_str(), "wb") != 0 || !file) {
          printf("Error %d opening file %s for writing\n", res, res_path.string().c_str());
        }
        else {

          auto addr = xex.pe_rva_to_offset(section.VirtualAddress);
          if (xex.header().Magic == MAGIC_XEX3F || xex.header().Magic == MAGIC_XEX0 || !addr)
            addr = section.PointerToRawData;

          auto* data = xex.pe_data() + addr;
          fwrite(data, 1, std::min(section.SizeOfRawData, section.VirtualSize), file);
          fclose(file);
          printf("Extracted resource %.8s to %s\n", section.Name, res_path.string().c_str());
        }
      }
    }
  }

  if (result["i"].as<bool>())
    PrintImports(xex);

  if (result["l"].as<bool>() || result["m"].as<bool>())
    PrintInfo(xex, result["m"].as<bool>());
}

```

`xex1tool.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{67F256A0-C7FB-448F-9B8F-362AE793C5B4}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>xex1tool</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <AdditionalIncludeDirectories>3rdparty/excrypt/src;3rdparty/mspack</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalLibraryDirectories>3rdparty/excrypt</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <AdditionalIncludeDirectories>3rdparty/excrypt/src;3rdparty/mspack</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalLibraryDirectories>3rdparty/excrypt</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="3rdparty\excrypt\src\excrypt_aes.c" />
    <ClCompile Include="3rdparty\excrypt\src\excrypt_bn.c" />
    <ClCompile Include="3rdparty\excrypt\src\excrypt_bn_mod.cpp" />
    <ClCompile Include="3rdparty\excrypt\src\excrypt_bn_sig.c" />
    <ClCompile Include="3rdparty\excrypt\src\excrypt_mem.cpp" />
    <ClCompile Include="3rdparty\excrypt\src\excrypt_rc4.c" />
    <ClCompile Include="3rdparty\excrypt\src\excrypt_rotsum.c" />
    <ClCompile Include="3rdparty\excrypt\src\excrypt_sha.c" />
    <ClCompile Include="3rdparty\excrypt\src\rijndael.c" />
    <ClCompile Include="3rdparty\lzx.cpp" />
    <ClCompile Include="3rdparty\mspack\lzxd.c" />
    <ClCompile Include="3rdparty\mspack\system.c">
      <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">_DEBUG;_CONSOLE;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">NDEBUG;_CONSOLE;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <ClCompile Include="formats\xdbf.cpp" />
    <ClCompile Include="formats\xex.cpp" />
    <ClCompile Include="namegen.cpp" />
    <ClCompile Include="xex1tool.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="3rdparty\byte_order.hpp" />
    <ClInclude Include="3rdparty\cxxopts.hpp" />
    <ClInclude Include="3rdparty\date.hpp" />
    <ClInclude Include="formats\pe_structs.hpp" />
    <ClInclude Include="formats\xdbf.hpp" />
    <ClInclude Include="formats\xdbf_structs.hpp" />
    <ClInclude Include="formats\xex.hpp" />
    <ClInclude Include="formats\xex_headerids.hpp" />
    <ClInclude Include="formats\xex_keys.hpp" />
    <ClInclude Include="formats\xex_optheaders.hpp" />
    <ClInclude Include="formats\xex_structs.hpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`xex1tool.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Header Files\formats">
      <UniqueIdentifier>{bcbb88ec-15d3-4ca7-b4ad-94813d536d60}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\excrypt">
      <UniqueIdentifier>{166b01ed-282b-4f1c-b5e9-26e8696318b4}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\formats">
      <UniqueIdentifier>{bf9da4ae-4f30-46ac-881f-014918c66db9}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\lzx">
      <UniqueIdentifier>{7071ccd0-cad0-4907-9d95-90600bd9d1f5}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="xex1tool.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="namegen.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="3rdparty\excrypt\src\excrypt_aes.c">
      <Filter>Source Files\excrypt</Filter>
    </ClCompile>
    <ClCompile Include="3rdparty\excrypt\src\excrypt_bn.c">
      <Filter>Source Files\excrypt</Filter>
    </ClCompile>
    <ClCompile Include="3rdparty\excrypt\src\excrypt_bn_mod.cpp">
      <Filter>Source Files\excrypt</Filter>
    </ClCompile>
    <ClCompile Include="3rdparty\excrypt\src\excrypt_bn_sig.c">
      <Filter>Source Files\excrypt</Filter>
    </ClCompile>
    <ClCompile Include="3rdparty\excrypt\src\excrypt_mem.cpp">
      <Filter>Source Files\excrypt</Filter>
    </ClCompile>
    <ClCompile Include="3rdparty\excrypt\src\excrypt_rc4.c">
      <Filter>Source Files\excrypt</Filter>
    </ClCompile>
    <ClCompile Include="3rdparty\excrypt\src\excrypt_rotsum.c">
      <Filter>Source Files\excrypt</Filter>
    </ClCompile>
    <ClCompile Include="3rdparty\excrypt\src\excrypt_sha.c">
      <Filter>Source Files\excrypt</Filter>
    </ClCompile>
    <ClCompile Include="formats\xex.cpp">
      <Filter>Source Files\formats</Filter>
    </ClCompile>
    <ClCompile Include="3rdparty\mspack\lzxd.c">
      <Filter>Source Files\lzx</Filter>
    </ClCompile>
    <ClCompile Include="3rdparty\mspack\system.c">
      <Filter>Source Files\lzx</Filter>
    </ClCompile>
    <ClCompile Include="3rdparty\excrypt\src\rijndael.c">
      <Filter>Source Files\excrypt</Filter>
    </ClCompile>
    <ClCompile Include="3rdparty\lzx.cpp">
      <Filter>Source Files\lzx</Filter>
    </ClCompile>
    <ClCompile Include="formats\xdbf.cpp">
      <Filter>Source Files\formats</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="3rdparty\byte_order.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="3rdparty\cxxopts.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="3rdparty\date.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="formats\pe_structs.hpp">
      <Filter>Header Files\formats</Filter>
    </ClInclude>
    <ClInclude Include="formats\xex.hpp">
      <Filter>Header Files\formats</Filter>
    </ClInclude>
    <ClInclude Include="formats\xex_headerids.hpp">
      <Filter>Header Files\formats</Filter>
    </ClInclude>
    <ClInclude Include="formats\xex_keys.hpp">
      <Filter>Header Files\formats</Filter>
    </ClInclude>
    <ClInclude Include="formats\xex_optheaders.hpp">
      <Filter>Header Files\formats</Filter>
    </ClInclude>
    <ClInclude Include="formats\xex_structs.hpp">
      <Filter>Header Files\formats</Filter>
    </ClInclude>
    <ClInclude Include="formats\xdbf.hpp">
      <Filter>Header Files\formats</Filter>
    </ClInclude>
    <ClInclude Include="formats\xdbf_structs.hpp">
      <Filter>Header Files\formats</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`xex1tool/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.10)

project(xex1tool)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED True)

# Enable AES NI intrinsic
set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -maes")
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -maes")

add_executable(xex1tool
  ../xex1tool.cpp
  ../namegen.cpp
  ../formats/xdbf.cpp
  ../formats/xex.cpp
  ../3rdparty/excrypt/src/excrypt_aes.c
  ../3rdparty/excrypt/src/rijndael.c
  ../3rdparty/excrypt/src/excrypt_bn.c
  ../3rdparty/excrypt/src/excrypt_bn_mod.cpp
  ../3rdparty/excrypt/src/excrypt_bn_sig.c
  ../3rdparty/excrypt/src/excrypt_mem.cpp
  ../3rdparty/excrypt/src/excrypt_rc4.c
  ../3rdparty/excrypt/src/excrypt_rotsum.c
  ../3rdparty/excrypt/src/excrypt_sha.c
  ../3rdparty/lzx.cpp
  ../3rdparty/mspack/lzxd.c
  ../3rdparty/mspack/system.c
)

target_include_directories(xex1tool PRIVATE ${PROJECT_SOURCE_DIR}/../3rdparty/excrypt/src)

```