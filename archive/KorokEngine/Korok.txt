Project Path: arc_KorokEngine_Korok_l6rb9p3v

Source Tree:

```txt
arc_KorokEngine_Korok_l6rb9p3v
├── LICENSE
├── README.md
├── anim
│   ├── anim.go
│   ├── frame
│   │   ├── anim.go
│   │   └── frame.go
│   ├── spine
│   │   ├── anim.go
│   │   ├── atlas.go
│   │   ├── attachment.go
│   │   ├── bone.go
│   │   ├── curve.go
│   │   ├── doc.md.go
│   │   ├── skeleton.go
│   │   ├── skin.go
│   │   ├── slot.go
│   │   └── spine.go
│   ├── ween
│   │   ├── anim.go
│   │   ├── animator.go
│   │   ├── tween_test.go
│   │   └── tweens.go
│   ├── ween_basic.go
│   ├── ween_sprite.go
│   └── ween_transform.go
├── asset
│   ├── R.go
│   ├── glsl100.go
│   ├── glsl330.go
│   ├── maudio.go
│   ├── mfont.go
│   ├── mpsconfig.go
│   ├── mshader.go
│   ├── mtexture.go
│   └── res
│       ├── res.go
│       ├── res_file.go
│       ├── res_local.go
│       └── res_webgl.go
├── audio
│   ├── audio.go
│   ├── decoder.go
│   ├── ogg
│   │   ├── decoder_opus.go
│   │   └── decoder_vorbis.go
│   ├── positional.go
│   ├── sine
│   │   ├── R.go
│   │   ├── bk_al.go
│   │   ├── bk_sl.go
│   │   ├── bk_webgl.go
│   │   ├── bk_windows.go
│   │   ├── decoder.go
│   │   ├── pool.go
│   │   └── sine.go
│   └── wav
│       └── decoder.go
├── dev.log
├── effect
│   ├── chan.go
│   ├── chan_test.go
│   ├── particle.go
│   ├── particle_test.go
│   ├── pool.go
│   ├── pool_test.go
│   ├── sim_explosion.go
│   ├── sim_fire.go
│   ├── sim_fountain.go
│   ├── sim_gravity.go
│   ├── sim_radius.go
│   ├── sim_snow.go
│   ├── simulate.go
│   └── simulate_test.go
├── engi
│   ├── array
│   │   ├── map.go
│   │   └── map_test.go
│   ├── comps.go
│   ├── entity.go
│   ├── entity_test.go
│   └── geom
│       ├── dimen.go
│       └── geom.go
├── event
│   └── m.md
├── game
│   ├── debug.go
│   ├── doc.go
│   ├── fps.go
│   ├── game.go
│   ├── prof.go
│   ├── scene.go
│   ├── script.go
│   ├── table_test.go
│   └── tag.go
├── gfx
│   ├── R.go
│   ├── batch.go
│   ├── batch_render.go
│   ├── bk
│   │   ├── R.go
│   │   ├── bk.go
│   │   ├── buffer.go
│   │   ├── queue.go
│   │   ├── renderc.go
│   │   ├── shader.go
│   │   ├── sortkey.go
│   │   ├── sortkey_test.go
│   │   ├── texture.go
│   │   ├── uniform.go
│   │   └── vertex.go
│   ├── camera.go
│   ├── data.go
│   ├── dbg
│   │   ├── dbg.go
│   │   ├── font.go
│   │   ├── glsl100.go
│   │   ├── glsl330.go
│   │   └── hud.go
│   ├── font
│   │   ├── bitmap.go
│   │   ├── config.go
│   │   ├── font.go
│   │   ├── glyph.go
│   │   ├── misc.go
│   │   ├── pow2.go
│   │   └── truetype.go
│   ├── gctx.go
│   ├── mesh.go
│   ├── mesh_render.go
│   ├── render_system.go
│   ├── shape.go
│   ├── sprite.go
│   ├── stack_alloc.go
│   ├── table_test.go
│   ├── text.go
│   ├── transform.go
│   ├── transform_test.go
│   └── visibility.go
├── gui
│   ├── auto
│   │   ├── gui.go
│   │   ├── gui_lib.go
│   │   └── layout.go
│   ├── drawing.go
│   ├── font.go
│   ├── gui.go
│   ├── gui_lib.go
│   ├── id.go
│   ├── render.go
│   └── style.go
├── hid
│   ├── config.go
│   ├── doc.go
│   ├── gl
│   │   ├── consts.go
│   │   ├── gl_gl2.go
│   │   ├── gl_gl3.go
│   │   ├── gl_mobile.go
│   │   └── gl_webgl.go
│   ├── hid_android.go
│   ├── hid_attr.go
│   ├── hid_darwin.go
│   ├── hid_ios.go
│   ├── hid_webgl.go
│   ├── input
│   │   ├── button.go
│   │   ├── button_test.go
│   │   ├── input.go
│   │   ├── joystick.go
│   │   ├── keys_android.go
│   │   ├── keys_glfw.go
│   │   ├── keys_ios.go
│   │   ├── keys_webgl.go
│   │   └── touch.go
│   ├── lifecycle.go
│   ├── window_glfw.go
│   ├── window_mob.go
│   └── window_webgl.go
├── korok.go
├── math
│   ├── doc.go
│   ├── ease
│   │   ├── back.go
│   │   ├── bounce.go
│   │   ├── circle.go
│   │   ├── cubic.go
│   │   ├── ease.go
│   │   ├── elastic.go
│   │   ├── expo.go
│   │   ├── quad.go
│   │   ├── quart.go
│   │   ├── quint.go
│   │   └── sine.go
│   ├── f32
│   │   ├── matrix.go
│   │   ├── project.go
│   │   ├── transform.go
│   │   └── vector.go
│   ├── f32.go
│   ├── geom.go
│   └── i32.go
└── webav
    ├── webaudio.go
    └── webgl.go

```

`LICENSE`:

```
Copyright (c) 2006-2017 http://korok.io

This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.

```

`README.md`:

```md
# Korok

**Korok** is a free lightweight, cross-platform, component-based 2D game engine written in Golang and released under the zlib license. Greatly
inspired by [bitsquid blog](http://bitsquid.blogspot.com/).

Homepage: [korok.io](http://korok.io)      Twitter: [ntop](https://twitter.com/ntoooop)

The latest release is beta-version which is not stable and will have breaking changes in the future.
About the state and progress of the project, see [Devlogs](https://github.com/KorokEngine/Korok/blob/master/dev.log)

## Getting Started

`go get korok.io/korok`

## Games

**FlappyBird**
<br>
![flappy bird](https://github.com/ntop001/flappybird/blob/master/images/flappybird.final.gif)
<br>
[GitHub](https://github.com/ntop001/flappybird)

**Shoot Stack**
<br>
<img src="https://github.com/KorokEngine/KorokEngine.github.io/blob/master/static/img/shoot_stack.jpeg" width="320">
<br>
<a href="https://itunes.apple.com/cn/app/shoot-stack/id1435699416?mt=8"><small><strong>AppStore</strong></small></a>
<a href="https://play.google.com/store/apps/details?id=io.korok.shootingblock"><small><strong>GooglePlay</strong></small></a>

**Unstable Tower**
<br>
<img src="https://github.com/KorokEngine/KorokEngine.github.io/blob/master/static/img/unstable_tower.jpeg" width="320">
<br>
<a href="https://play.google.com/store/apps/details?id=io.korok.unstabletower"><small><strong>GooglePlay</strong></small></a>

## [Demos Project](https://github.com/KorokEngine/beta-demo)

**Some ScreenShot**

> Input Control - Show how to use `InputSystem`

<img src="https://github.com/KorokEngine/beta-demo/blob/master/images/v1_input.gif" width="500">

> Sprite Animation - Show how to use sprite animation system

<img src="https://github.com/KorokEngine/beta-demo/blob/master/images/v1_sprite_anim.gif" width="500">

> Tween Animation - Show how to use tween animation system

<img src="https://github.com/KorokEngine/beta-demo/blob/master/images/v1_tween.gif" width="500">


> ParticleSystem - Show how to use `ParticleComp`

<img src="https://github.com/KorokEngine/beta-demo/blob/master/images/v1_snow.gif" width="500">


> Gui - Show how to use korok's imgui-api

<img src="https://github.com/KorokEngine/beta-demo/blob/master/images/v1_gui.jpeg" width="500">

## License

This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.

Note: To avoid fragmentation, it's not allowed to create and distribute korok-like libs.

```

`anim/anim.go`:

```go
package anim

import (
	"korok.io/korok/anim/frame"
	"korok.io/korok/anim/ween"
	"korok.io/korok/gfx"
)

type AnimationSystem struct {
	*frame.SpriteEngine
	*ween.TweenEngine

	// tables
	st *gfx.SpriteTable
	xf *gfx.TransformTable
}

func NewAnimationSystem() *AnimationSystem {
	return &AnimationSystem{
		SpriteEngine: frame.NewEngine(),
		TweenEngine: ween.NewEngine(),
	}
}

func (as *AnimationSystem) RequireTable(tables []interface{}) {
	as.SpriteEngine.RequireTable(tables)

	for _, t := range tables {
		switch table := t.(type) {
		case *gfx.SpriteTable:
			as.st = table
		case *gfx.TransformTable:
			as.xf = table
		}
	}
}

func (as *AnimationSystem) Update(dt float32) {
	as.SpriteEngine.Update(dt)
	as.TweenEngine.Update(dt)
}

// set shortcut
func SetDefaultAnimationSystem(as *AnimationSystem) {
	animationSystem = as
	spriteEngine = as.SpriteEngine
	tweenEngine = as.TweenEngine
}

// shortcut
var spriteEngine *frame.SpriteEngine
var tweenEngine *ween.TweenEngine
var animationSystem *AnimationSystem
```

`anim/frame/anim.go`:

```go
package frame

import (
	"korok.io/korok/gfx"
)

// implement sprite-animation system

// Frames data of Sprite Animation
type Animation struct {
	Name string
	Start, Len int
	Loop bool
}

// Sprite Animation System
type SpriteEngine struct {
	// raw frames
	frames []gfx.Tex2D
	// raw animation
	data []Animation
	// mapping from name to index
	names map[string]int

	// sprite and animate table
	st *gfx.SpriteTable
	at *FlipbookTable
}

func NewEngine() *SpriteEngine {
	return &SpriteEngine{ names:make(map[string]int) }
}

func (eng *SpriteEngine) RequireTable(tables []interface{}) {
	for _, t := range tables {
		switch table := t.(type) {
		case *gfx.SpriteTable:
			eng.st = table
		case *FlipbookTable:
			eng.at = table
		}
	}
}

// 创建新的动画数据
// 现在 subText 还是指针，稍后会全部用 id 来索引。
// 动画资源全部存储在一个大的buffer里面，在外部使用索引引用即可.
// 采用这种设计，删除动画将会变得麻烦..
// 或者说无法删除动画，只能全部删除或者完全重新加载...
// 如何动画以组的形式存在，那么便可以避免很多问题
//
func (eng *SpriteEngine) NewAnimation(name string, frames []gfx.Tex2D, loop bool) {
	// copy frames
	start, size := len(eng.frames), len(frames)
	eng.frames = append(eng.frames, frames...)
	// new animation
	eng.data = append(eng.data, Animation{name, start, size, loop})
	// keep mapping
	eng.names[name] = len(eng.data)-1
}

// 返回动画定义 - 好像并没有太大的意义
func (eng *SpriteEngine) Animation(name string) (anim *Animation, seq []gfx.Tex2D) {
	if ii, ok := eng.names[name]; ok {
		anim = &eng.data[ii]
		seq  = eng.frames[anim.Start:anim.Start+anim.Len]
	}
	return
}

func (eng *SpriteEngine) Update(dt float32) {
	var (
		at, st = eng.at, eng.st
		anims  = at.comps[:at.index]
	)

	// update animation state
	for i := range anims {
		if am := &anims[i]; am.running {
			var (
				id    = eng.names[am.define]
				data  = eng.data[id]
			)
			am.gfi = data.Start+int(am.frameIndex)
			if am.dt += dt; am.dt > am.rate {
				am.ii = am.ii + 1
				am.dt = 0
				frame := am.ii% data.Len

				// frame end
				if frame == 0 {
					if am.loop && am.typ == PingPong {
						am.reverse = !am.reverse
						am.ii += 1 // skip one frame, or it'll repeat last frame
						frame += 1
					}
					if !am.loop {
						am.running = false
						break
					}
				}

				if am.reverse {
					frame = data.Len-frame-1
				}
				// update frame index
				am.lastFrameIndex = am.frameIndex
				am.frameIndex = uint16(frame)
				am.gfi = data.Start+frame
			}

			// update sprite-component
			comp := st.Comp(am.Entity)
			frame := eng.frames[am.gfi]
			comp.SetSprite(frame)
		}
	}
}

```

`anim/frame/frame.go`:

```go
package frame

import (
	"korok.io/korok/engi"
	"korok.io/korok/gfx"
)

// Defines what this animation should do when it reaches the end.
type LoopType uint8
const (
	Restart LoopType = iota
	PingPong
	None
)

// Sprite Animation Component
type FlipbookComp struct {
	engi.Entity
	define                     string
	dt, rate                   float32
	ii                         int
	running                    bool
	loop                       bool
	frameIndex, lastFrameIndex uint16
	gfi                        int
	typ                        LoopType
	reverse                    bool
}

func (fb *FlipbookComp) Play(name string) {
	fb.define = name
	fb.running = true
	fb.reverse = false
	fb.frameIndex = 0
	fb.lastFrameIndex = 0
	fb.dt, fb.ii = 0, 0
}

func (fb *FlipbookComp) Resume() {
	fb.running = true
}

func (fb *FlipbookComp) Pause() {
	fb.running = false
}

func (fb *FlipbookComp) Stop() {
	fb.running = false
}

func (fb *FlipbookComp) Running() bool {
	return fb.running
}

func (fb *FlipbookComp) SetAnimation(name string) {
	fb.define = name
}

func (fb *FlipbookComp) Loop() (bool, LoopType) {
	return fb.loop, fb.typ
}

func (fb *FlipbookComp) SetLoop(v bool, typ LoopType) {
	fb.loop, fb.typ = v, typ
}

func (fb *FlipbookComp) Rate() float32 {
	return fb.rate
}

func (fb *FlipbookComp) SetRate(r float32) {
	fb.rate = r
}

func (fb *FlipbookComp) FrameIndex() (frame, lastFrame uint16) {
	return fb.frameIndex, fb.lastFrameIndex
}

// Sprite Animation Table
type FlipbookTable struct {
	comps []FlipbookComp
	_map   map[uint32]int
	index, cap int
}

func NewFlipbookTable(cap int) *FlipbookTable {
	return &FlipbookTable{
		cap:cap,
		_map:make(map[uint32]int),
	}
}

func (t *FlipbookTable) NewComp(entity engi.Entity) (am *FlipbookComp) {
	if size := len(t.comps); t.index >= size {
		t.comps = tableResize(t.comps, size + gfx.STEP)
	}
	ei := entity.Index()
	if v, ok := t._map[ei]; ok {
		am = &t.comps[v]
		return
	}
	am = &t.comps[t.index]
	am.Entity = entity
	t._map[ei] = t.index
	t.index ++
	return
}

func (t *FlipbookTable) Alive(entity engi.Entity) bool {
	ei := entity.Index()
	if v, ok := t._map[ei]; ok {
		return t.comps[v].Entity != 0
	}
	return false
}

func (t *FlipbookTable) Comp(entity engi.Entity) (sc *FlipbookComp) {
	ei := entity.Index()
	if v, ok := t._map[ei]; ok {
		sc = &t.comps[v]
	}
	return
}

func (t *FlipbookTable) Delete(entity engi.Entity) {
	ei := entity.Index()
	if v, ok := t._map[ei]; ok {
		if tail := t.index -1; v != tail && tail > 0 {
			t.comps[v] = t.comps[tail]
			// remap index
			tComp := &t.comps[tail]
			ei := tComp.Entity.Index()
			t._map[ei] = v
			tComp.Entity = 0
		} else {
			t.comps[tail].Entity = 0
		}

		t.index -= 1
		delete(t._map, ei)
	}
}

func (t *FlipbookTable) Size() (size, cap int) {
	return t.index, t.cap
}

func (t *FlipbookTable) Destroy() {
	t.comps = make([]FlipbookComp, 0)
	t._map = make(map[uint32]int)
	t.index = 0
}

func tableResize(slice []FlipbookComp, size int) []FlipbookComp {
	newSlice := make([]FlipbookComp, size)
	copy(newSlice, slice)
	return newSlice
}





```

`anim/spine/anim.go`:

```go
package spine

import (
	"math"
)

type Timeline interface {
	Apply(skeleton *Skeleton, time, alpha float32)
}

type RotateTimeline struct {
	boneIndex int
	frames    []float32
	curve     *Curve
}

func NewRotateTimeline(l int) *RotateTimeline {
	timeline := new(RotateTimeline)
	timeline.frames = make([]float32, l*2)
	timeline.curve = NewCurve(l)
	return timeline
}

func (t *RotateTimeline) Apply(skeleton *Skeleton, time, alpha float32) {
	frames := t.frames
	if time < frames[0] {
		return
	}

	bone := skeleton.Bones[t.boneIndex]
	if time >= frames[len(frames)-2] {
		amount := bone.Data.rotation + frames[len(frames)-1] - bone.Rotation
		for amount > 180 {
			amount -= 360
		}

		for amount < -180 {
			amount += 360
		}
		bone.Rotation += amount * alpha
		return
	}

	frameIndex := binarySearch(frames, time, 2)
	lastFrameValue := frames[frameIndex-1]
	frameTime := frames[frameIndex]
	percent := 1 - (time-frameTime)/(frames[frameIndex-2]-frameTime)
	percent = t.curve.CurvePercent(frameIndex/2-1, percent)
	amount := frames[frameIndex+1] - lastFrameValue
	for amount > 180 {
		amount -= 360
	}
	for amount < -180 {
		amount += 360
	}
	amount = bone.Data.rotation + (lastFrameValue + amount*percent) - bone.Rotation
	for amount > 180 {
		amount -= 360
	}

	for amount < -180 {
		amount += 360
	}
	bone.Rotation += amount * alpha
}

func binarySearch(values []float32, target float32, step int) int {
	low := 0
	high := int(math.Floor(float64(len(values)/step))) - 2
	if high == 0 {
		return step
	}
	current := high >> 1
	for {
		if values[(current+1)*step] <= target {
			low = current + 1
		} else {
			high = current
		}
		if low == high {
			return (low + 1) * step
		}
		current = (low + high) >> 1
	}
}

func (t *RotateTimeline) setFrame(index int, time, angle float32) {
	frameIndex := index * 2
	t.frames[frameIndex] = time
	t.frames[frameIndex+1] = angle
}

func (t *RotateTimeline) frameCount() int {
	return len(t.frames) / 2
}

type TranslateTimeline struct {
	boneIndex int
	frames    []float32
	curve     *Curve
}

func NewTranslateTimeline(l int) *TranslateTimeline {
	timeline := new(TranslateTimeline)
	timeline.frames = make([]float32, l*3)
	timeline.curve = NewCurve(l)
	return timeline
}

func (t *TranslateTimeline) frameCount() int {
	return len(t.frames) / 3
}

func (t *TranslateTimeline) setFrame(index int, time, x, y float32) {
	frameIndex := index * 3
	t.frames[frameIndex] = time
	t.frames[frameIndex+1] = x
	t.frames[frameIndex+2] = y
}

func (t *TranslateTimeline) Apply(skeleton *Skeleton, time, alpha float32) {
	frames := t.frames
	if time < frames[0] {
		return
	}

	bone := skeleton.Bones[t.boneIndex]

	if time >= frames[len(frames)-3] {
		bone.X += (bone.Data.x + frames[len(frames)-2] - bone.X) * alpha
		bone.Y += (bone.Data.y + frames[len(frames)-1] - bone.Y) * alpha
		return
	}

	frameIndex := binarySearch(frames, time, 3)
	lastFrameX := frames[frameIndex-2]
	lastFrameY := frames[frameIndex-1]
	frameTime := frames[frameIndex]
	percent := 1 - (time-frameTime)/(frames[frameIndex-3]-frameTime)
	percent = t.curve.CurvePercent(frameIndex/3-1, percent)

	bone.X += (bone.Data.x + lastFrameX + (frames[frameIndex+1]-lastFrameX)*percent - bone.X) * alpha
	bone.Y += (bone.Data.y + lastFrameY + (frames[frameIndex+2]-lastFrameY)*percent - bone.Y) * alpha
}

type ScaleTimeline struct {
	boneIndex int
	frames    []float32
	curve     *Curve
}

func NewScaleTimeline(l int) *ScaleTimeline {
	timeline := new(ScaleTimeline)
	timeline.frames = make([]float32, l*3)
	timeline.curve = NewCurve(l)
	return timeline
}

func (t *ScaleTimeline) frameCount() int {
	return len(t.frames) / 3
}

func (t *ScaleTimeline) setFrame(index int, time, x, y float32) {
	frameIndex := index * 3
	t.frames[frameIndex] = time
	t.frames[frameIndex+1] = x
	t.frames[frameIndex+2] = y
}

func (t *ScaleTimeline) Apply(skeleton *Skeleton, time, alpha float32) {
	frames := t.frames
	if time < frames[0] {
		return
	}

	bone := skeleton.Bones[t.boneIndex]

	if time >= frames[len(frames)-3] {
		bone.ScaleX += (bone.Data.scaleX - 1 + frames[len(frames)-2] - bone.ScaleX) * alpha
		bone.ScaleY += (bone.Data.scaleY - 1 + frames[len(frames)-1] - bone.ScaleY) * alpha
		return
	}

	frameIndex := binarySearch(frames, time, 3)
	lastFrameX := frames[frameIndex-2]
	lastFrameY := frames[frameIndex-1]
	frameTime := frames[frameIndex]
	percent := 1 - (time-frameTime)/(frames[frameIndex-3]-frameTime)
	percent = t.curve.CurvePercent(frameIndex/3-1, percent)

	bone.ScaleX += (bone.Data.scaleX - 1 + lastFrameX + (frames[frameIndex+1]-lastFrameX)*percent - bone.ScaleX) * alpha
	bone.ScaleY += (bone.Data.scaleY - 1 + lastFrameY + (frames[frameIndex+2]-lastFrameY)*percent - bone.ScaleY) * alpha
}

type ColorTimeline struct {
	slotIndex int
	frames    []float32
	curve     *Curve
}

func NewColorTimeline(l int) *ColorTimeline {
	return &ColorTimeline{
		frames: make([]float32, l*5),
		curve:  NewCurve(l),
	}
}

func (t *ColorTimeline) frameCount() int {
	return t.curve.frameCount()
}

func (t *ColorTimeline) setFrame(index int, time, r, g, b, a float32) {
	index *= 5
	frames := t.frames
	frames[index] = time
	frames[index+1] = r
	frames[index+2] = g
	frames[index+3] = b
	frames[index+4] = a
}

func (t *ColorTimeline) Apply(skeleton *Skeleton, time, alpha float32) {
	frames := t.frames
	if time < frames[0] {
		return // Time is before first frame.
	}

	slot := skeleton.Slots[t.slotIndex]

	if time >= frames[len(t.frames)-5] { // Time is after last frame.
		i := len(frames) - 1
		slot.R = frames[i-3]
		slot.G = frames[i-2]
		slot.B = frames[i-1]
		slot.A = frames[i]
		return
	}

	// Interpolate between the last frame and the current frame.
	frameIndex := binarySearch(frames, time, 5)
	lastFrameR := frames[frameIndex-4]
	lastFrameG := frames[frameIndex-3]
	lastFrameB := frames[frameIndex-2]
	lastFrameA := frames[frameIndex-1]
	frameTime := frames[frameIndex]
	percent := 1 - (time-frameTime)/(frames[frameIndex-5]-frameTime)
	percent = t.curve.CurvePercent(frameIndex/5-1, percent)

	r := lastFrameR + (frames[frameIndex+1]-lastFrameR)*percent
	g := lastFrameG + (frames[frameIndex+2]-lastFrameG)*percent
	b := lastFrameB + (frames[frameIndex+3]-lastFrameB)*percent
	a := lastFrameA + (frames[frameIndex+4]-lastFrameA)*percent
	if alpha < 1 {
		slot.R += (r - slot.R) * alpha
		slot.G += (g - slot.G) * alpha
		slot.B += (b - slot.B) * alpha
		slot.A += (a - slot.A) * alpha
	} else {
		slot.R = r
		slot.G = g
		slot.B = b
		slot.A = a
	}
}

type AttachmentTimeline struct {
	slotIndex       int
	frames          []float32
	attachmentNames []string
}

func NewAttachmentTimeline(l int) *AttachmentTimeline {
	return &AttachmentTimeline{
		frames:          make([]float32, l),
		attachmentNames: make([]string, l),
	}
}

func (t *AttachmentTimeline) frameCount() int {
	return len(t.frames)
}

func (t *AttachmentTimeline) setFrame(index int, time float32, attachmentName string) {
	t.frames[index] = time
	t.attachmentNames[index] = attachmentName
}

func (t *AttachmentTimeline) Apply(skeleton *Skeleton, time, alpha float32) {
	frames := t.frames
	if time < frames[0] {
		return // Time is before first frame.
	}

	var frameIndex int
	if time >= frames[len(frames)-1] { // Time is after last frame.
		frameIndex = len(frames) - 1
	} else {
		frameIndex = binarySearch(frames, time, 1) - 1
	}

	attachmentName := t.attachmentNames[frameIndex]
	var attachment Attachment
	if attachmentName != "" {
		attachment = skeleton.AttachmentBySlotIndex(t.slotIndex, attachmentName)
	}
	skeleton.Slots[t.slotIndex].Attachment = attachment
}

type Animation struct {
	name      string
	timelines []Timeline
	duration  float32
}

func NewAnimation(name string, timelines []Timeline, duration float32) *Animation {
	anim := new(Animation)
	anim.name = name
	anim.timelines = timelines
	anim.duration = duration
	return anim
}

func (a *Animation) Apply(skeleton *Skeleton, time float32, loop bool) {
	if loop && a.duration != 0 {
		time = float32(math.Mod(float64(time), float64(a.duration)))
	}

	for _, timeline := range a.timelines {
		timeline.Apply(skeleton, time, 1)
	}
}

func (a *Animation) Mix(skeleton *Skeleton, time float32, loop bool, alpha float32) {
	if loop && a.duration != 0 {
		time = float32(math.Mod(float64(time), float64(a.duration)))
	}
	for _, timeline := range a.timelines {
		timeline.Apply(skeleton, time, alpha)
	}
}

func (a *Animation) Duration() float32 {
	return a.duration
}

```

`anim/spine/atlas.go`:

```go
package spine

import (
	"bufio"
	"errors"
	"io"
	"strconv"
	"strings"
)

type Atlas struct {
	Pages   []*AtlasPage
	Regions []*AtlasRegion
	loader  TextureLoader
}

func NewAtlas(r io.Reader, loader TextureLoader) (*Atlas, error) {
	if loader == nil {
		return nil, errors.New("spine: texture loader cannot be nil")
	}
	var atlas Atlas
	atlas.loader = loader

	scanner := bufio.NewScanner(r)
	var page *AtlasPage
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if len(line) == 0 {
			page = nil
			continue
		}
		if page == nil {
			var tuple []string
			var terr error

			formatName, err := readValue("format", scanner)
			if err != nil {
				return nil, errors.New("spine: failed to parse format: " + err.Error())
			}
			format, err := formatFromName(formatName)
			if err != nil {
				return nil, errors.New("spine: failed to parse format: " + err.Error())
			}

			size, err := readTuple("size", scanner)
			if err != nil {
				return nil, errors.New("spine: failed to read size" + err.Error())
			}

			width,  _ := strconv.Atoi(size[0])
			height, _ := strconv.Atoi(size[1])

			tuple, terr = readTuple("filter", scanner)
			if terr != nil {
				return nil, errors.New("spine: failed to read page: " + err.Error())
			}

			minFilter, err := filterFromName(tuple[0])
			if err != nil {
				return nil, errors.New("spine: failed to parse min filter: " + err.Error())
			}
			magFilter, err := filterFromName(tuple[1])
			if err != nil {
				return nil, errors.New("spine: failed to parse mag filter: " + err.Error())
			}
			page = &AtlasPage{
				Name:      line,
				Format:    format,
				MinFilter: minFilter,
				MagFilter: magFilter,
				UWrap:     ClampToEdge,
				VWrap:     ClampToEdge,
				Width:	   width,
				Height:	   height,
			}

			direction, err := readValue("repeat", scanner)
			if err != nil {
				return nil, errors.New("spine: failed to parse direction: " + err.Error())
			}
			switch direction {
			case "x":
				page.UWrap = Repeat
			case "y":
				page.VWrap = Repeat
			case "xy":
				page.UWrap = Repeat
				page.VWrap = Repeat
			}

			if err := atlas.loader.Load(page); err != nil {
				return nil, errors.New("spine: failed to load texture: " + err.Error())
			}

			atlas.Pages = append(atlas.Pages, page)
		} else {
			var tuple []string
			var terr error
			rotateVal, err := readValue("rotate", scanner)
			if err != nil {
				return nil, errors.New("spine: failed to parse rotate: " + err.Error())
			}
			rotate, err := strconv.ParseBool(rotateVal)
			if err != nil {
				return nil, errors.New("spine: failed to parse rotate: " + err.Error())
			}
			tuple, terr = readTuple("xy", scanner)
			if terr != nil {
				return nil, errors.New("spine: failed to read x, y tuple: " + err.Error())
			}
			x, err := strconv.Atoi(tuple[0])
			if err != nil {
				return nil, errors.New("spine: failed to parse x: " + err.Error())
			}
			y, err := strconv.Atoi(tuple[1])
			if err != nil {
				return nil, errors.New("spine: failed to parse y: " + err.Error())
			}

			tuple, terr = readTuple("size", scanner)
			if terr != nil {
				return nil, errors.New("spine: failed to read width, height tuple: " + err.Error())
			}
			width, err := strconv.Atoi(tuple[0])
			if err != nil {
				return nil, errors.New("spine: failed to parse width: " + err.Error())
			}
			height, err := strconv.Atoi(tuple[1])
			if err != nil {
				return nil, errors.New("spine: failed to parse height: " + err.Error())
			}

			region := &AtlasRegion{
				Name:   line,
				Page:   page,
				Rotate: rotate,
				X:      x,
				Y:      y,
				U:      float32(x) / float32(page.Width),
				V:      float32(y) / float32(page.Height),
			}

			if region.Rotate {
				region.U2 = float32(x+height) / float32(page.Width)
				region.V2 = float32(y+width) / float32(page.Height)
			} else {
				region.U2 = float32(x+width) / float32(page.Width)
				region.V2 = float32(y+height) / float32(page.Height)
			}
			region.X, region.Y = x, y
			region.Width, region.Height = width, height
			if region.Width < 0 {
				region.Width = -region.Width
			}
			if region.Height < 0 {
				region.Height = -region.Height
			}

			tuple, terr = readTuple("", scanner)
			if terr != nil {
				return nil, errors.New("spine: failed to read tuple: " + err.Error())
			}
			if len(tuple) == 4 { // split is optional
				for idx, sval := range tuple {
					val, err := strconv.Atoi(sval)
					if err != nil {
						return nil, errors.New("spine: failed to read split: " + err.Error())
					}
					region.Splits[idx] = val
				}

				tuple, terr = readTuple("", scanner)
				if terr != nil {
					return nil, errors.New("spine: failed to read tuple: " + err.Error())
				}
				if len(tuple) == 4 { // pad is optional, but only present with splits
					for idx, sval := range tuple {
						val, err := strconv.Atoi(sval)
						if err != nil {
							return nil, errors.New("spine: failed to read split: " + err.Error())
						}
						region.Pads[idx] = val
					}

					tuple, terr = readTuple("orig", scanner)
					if terr != nil {
						return nil, errors.New("spine: failed to read tuple: " + err.Error())
					}
				}
			}

			origWidth, err := strconv.Atoi(tuple[0])
			if err != nil {
				return nil, errors.New("spine: failed to parse original width: " + err.Error())
			}
			origHeight, err := strconv.Atoi(tuple[1])
			if err != nil {
				return nil, errors.New("spine: failed to parse original height: " + err.Error())
			}

			region.OriginalWidth, region.OriginalHeight = origWidth, origHeight

			tuple, terr = readTuple("offset", scanner)
			if terr != nil {
				return nil, errors.New("spine: failed to read x offset, y offset tuple: " + err.Error())
			}
			offX, err := strconv.Atoi(tuple[0])
			if err != nil {
				return nil, errors.New("spine: failed to parse x offset: " + err.Error())
			}
			offY, err := strconv.Atoi(tuple[1])
			if err != nil {
				return nil, errors.New("spine: failed to parse y offset: " + err.Error())
			}
			region.OffsetX, region.OffsetY = float32(offX), float32(offY)

			regIdxVal, err := readValue("index", scanner)
			if err != nil {
				return nil, errors.New("spine: failed to parse region index: " + err.Error())
			}
			regIdx, err := strconv.Atoi(regIdxVal)
			if err != nil {
				return nil, errors.New("spine: failed to parse region index: " + err.Error())
			}
			region.Index = regIdx

			atlas.Regions = append(atlas.Regions, region)
		}
	}
	if scanner.Err() != nil {
		return nil, errors.New("spine: failed to read atlas file: " + scanner.Err().Error())
	}
	return &atlas, nil
}

func readValue(expectedKey string, s *bufio.Scanner) (string, error) {
	if err := nextLine(s); err != nil {
		return "", err
	}
	line := s.Text()
	keyVal := strings.SplitN(line, ":", 2)
	if len(keyVal) < 2 {
		return "", errors.New("spine: invalid key/value: " + line)
	}
	key := strings.TrimSpace(keyVal[0])
	if expectedKey != "" && expectedKey != key {
		return "", errors.New("spine: expected " + expectedKey + ", got " + key)
	}
	return strings.TrimSpace(keyVal[1]), nil
}

func nextLine(s *bufio.Scanner) error {
	if s.Scan() {
		return nil
	}
	if s.Err() != nil {
		return errors.New("spine: failed to read file: " + s.Err().Error())
	} else {
		return errors.New("spine: unexpected EOF encountered")
	}
}

/** Returns the number of tuple values read (2 or 4). */
func readTuple(expectedKey string, s *bufio.Scanner) ([]string, error) {
	val, err := readValue(expectedKey, s)
	if err != nil {
		return nil, err
	}
	tuple := strings.Split(val, ",")
	for idx, v := range tuple {
		tuple[idx] = strings.TrimSpace(v)
	}
	return tuple, nil
}

/** Returns the first region found with the specified name. This method uses string comparison to find the region, so the result
* should be cached rather than calling this method multiple times.
* @return The region, or null. */
func (a *Atlas) FindRegion(name string) *AtlasRegion {
	for _, region := range a.Regions {
		if region.Name == name {
			return region
		}
	}
	return nil
}

func (a *Atlas) Dispose() error {
	for _, page := range a.Pages {
		if err := a.loader.Unload(page); err != nil {
			return err
		}
	}
	return nil
}

func formatFromName(name string) (TextureFormat, error) {
	var f TextureFormat
	switch name {
	case "Alpha":
		f = Alpha
	case "Intensity":
		f = Intensity
	case "LuminanceAlpha":
		f = LuminanceAlpha
	case "RGB565":
		f = RGB565
	case "RGBA4444":
		f = RGBA4444
	case "RGB888":
		f = RGB888
	case "RGBA8888":
		f = RGBA8888
	default:
		return 0, errors.New("unknown texture format: " + name)
	}
	return f, nil
}

func filterFromName(name string) (TextureFilter, error) {
	var f TextureFilter
	switch name {
	case "Nearest":
		f = Nearest
	case "Linear":
		f = Linear
	case "MipMap":
		f = MipMap
	case "MipMapNearestNearest":
		f = MipMapNearestNearest
	case "MipMapLinearNearest":
		f = MipMapLinearNearest
	case "MipMapNearestLinear":
		f = MipMapNearestLinear
	case "MipMapLinearLinear":
		f = MipMapLinearLinear
	default:
		return 0, errors.New("unknown filter: " + name)
	}
	return f, nil
}

type TextureFormat int

const (
	Alpha TextureFormat = iota
	Intensity
	LuminanceAlpha
	RGB565
	RGBA4444
	RGB888
	RGBA8888
)

type TextureFilter int

const (
	Nearest TextureFilter = iota
	Linear
	MipMap
	MipMapNearestNearest
	MipMapLinearNearest
	MipMapNearestLinear
	MipMapLinearLinear
)

type TextureWrap int

const (
	MirroredRepeat TextureWrap = iota
	ClampToEdge
	Repeat
)

type AtlasPage struct {
	Name           string
	Format         TextureFormat
	MinFilter      TextureFilter
	MagFilter      TextureFilter
	UWrap          TextureWrap
	VWrap          TextureWrap
	RendererObject interface{}
	Width, Height  int
}

type AtlasRegion struct {
	Page                          *AtlasPage
	Name                          string
	X, Y, Width, Height           int
	U, V, U2, V2                  float32
	OffsetX, OffsetY              float32
	OriginalWidth, OriginalHeight int
	Index                         int
	Rotate                        bool
	Splits                        [4]int
	Pads                          [4]int
}

type TextureLoader interface {
	Load(page *AtlasPage) error
	Unload(page *AtlasPage) error
}

```

`anim/spine/attachment.go`:

```go
package spine

import (
	"math"
)

type Attachment interface {
	Name() string
}

type RegionAttachment struct {
	name     string
	X        float32
	Y        float32
	Rotation float32
	ScaleX   float32
	ScaleY   float32
	Width    float32
	Height   float32

	RendererObject       interface{}
	RegionOffsetX        float32
	RegionOffsetY        float32
	RegionWidth          float32
	RegionHeight         float32
	RegionOriginalWidth  float32
	RegionOriginalHeight float32

	Uvs    [8]float32
	offset [8]float32
}

func (a RegionAttachment) Name() string {
	return a.name
}

func NewRegionAttachment(name string) *RegionAttachment {
	return &RegionAttachment{
		name:   name,
		ScaleX: 1,
		ScaleY: 1,
	}
}

func (r *RegionAttachment) SetUVs(u float32, v float32, u2 float32, v2 float32, rotate bool) {
	uvs := &r.Uvs
	if rotate {
		uvs[2] = u
		uvs[3] = v2
		uvs[4] = u
		uvs[5] = v
		uvs[6] = u2
		uvs[7] = v
		uvs[0] = u2
		uvs[1] = v2
	} else {
		uvs[0] = u
		uvs[1] = v2
		uvs[2] = u
		uvs[3] = v
		uvs[4] = u2
		uvs[5] = v
		uvs[6] = u2
		uvs[7] = v2
	}
}

func (r *RegionAttachment) updateOffset() {
	width := r.Width
	height := r.Height
	scaleX := r.ScaleX
	scaleY := r.ScaleY
	regionScaleX := width / r.RegionOriginalWidth * scaleX
	regionScaleY := height / r.RegionOriginalHeight * scaleY
	localX := -width/2*scaleX + r.RegionOffsetX*regionScaleX
	localY := -height/2*scaleY + r.RegionOffsetY*regionScaleY
	localX2 := localX + r.RegionWidth*regionScaleX
	localY2 := localY + r.RegionHeight*regionScaleY
	rotation := r.Rotation
	rads := float64(rotation) * math.Pi / 180
	cos := float32(math.Cos(rads))
	sin := float32(math.Sin(rads))
	x := r.X
	y := r.Y
	localXCos := localX*cos + x
	localXSin := localX * sin
	localYCos := localY*cos + y
	localYSin := localY * sin
	localX2Cos := localX2*cos + x
	localX2Sin := localX2 * sin
	localY2Cos := localY2*cos + y
	localY2Sin := localY2 * sin
	r.offset[0] = localXCos - localYSin
	r.offset[1] = localYCos + localXSin
	r.offset[2] = localXCos - localY2Sin
	r.offset[3] = localY2Cos + localXSin
	r.offset[4] = localX2Cos - localY2Sin
	r.offset[5] = localY2Cos + localX2Sin
	r.offset[6] = localX2Cos - localYSin
	r.offset[7] = localYCos + localX2Sin
}

func (r *RegionAttachment) Update(slot *Slot) (verts [8]float32) {
	bone := slot.Bone

	s := slot.Skeleton()
	x := s.X + bone.WorldX
	y := s.Y + bone.WorldY
	m00 := bone.M00
	m01 := bone.M01
	m10 := bone.M10
	m11 := bone.M11

	verts[0] = r.offset[0]*m00 + r.offset[1]*m01 + x
	verts[1] = r.offset[0]*m10 + r.offset[1]*m11 + y
	verts[2] = r.offset[2]*m00 + r.offset[3]*m01 + x
	verts[3] = r.offset[2]*m10 + r.offset[3]*m11 + y
	verts[4] = r.offset[4]*m00 + r.offset[5]*m01 + x
	verts[5] = r.offset[4]*m10 + r.offset[5]*m11 + y
	verts[6] = r.offset[6]*m00 + r.offset[7]*m01 + x
	verts[7] = r.offset[6]*m10 + r.offset[7]*m11 + y

	return
}
```

`anim/spine/bone.go`:

```go
package spine

import (
	"math"
)

var BoneYDown = false

type BoneData struct {
	name     string
	parent   *BoneData
	Length   float32
	x        float32
	y        float32
	rotation float32
	scaleX   float32
	scaleY   float32
}

func NewBoneData(name string, parent *BoneData) *BoneData {
	boneData := new(BoneData)
	boneData.name = name
	boneData.parent = parent
	boneData.scaleX = 1
	boneData.scaleY = 1
	return boneData
}

type Bone struct {
	name          string
	Data          *BoneData
	parent        *Bone
	X             float32
	Y             float32
	Rotation      float32
	ScaleX        float32
	ScaleY        float32
	M00           float32
	M01           float32
	M10           float32
	M11           float32
	WorldX        float32
	WorldY        float32
	WorldRotation float32
	WorldScaleX   float32
	WorldScaleY   float32
}

func NewBone(boneData *BoneData, parent *Bone) *Bone {
	bone := new(Bone)
	bone.name = boneData.name
	bone.Data = boneData
	bone.parent = parent
	bone.ScaleX = 1
	bone.ScaleY = 1
	bone.WorldScaleX = 1
	bone.WorldScaleY = 1
	bone.SetToSetupPose()
	return bone
}

func (b *Bone) SetToSetupPose() {
	data := b.Data
	b.X = data.x
	b.Y = data.y
	b.Rotation = data.rotation
	b.ScaleX = data.scaleX
	b.ScaleY = data.scaleY
}

func (b *Bone) UpdateWorldTransform(flipX, flipY bool) {
	parent := b.parent
	if parent != nil {
		b.WorldX = b.X*parent.M00 + b.Y*parent.M01 + parent.WorldX
		b.WorldY = b.X*parent.M10 + b.Y*parent.M11 + parent.WorldY
		b.WorldScaleX = parent.WorldScaleX * b.ScaleX
		b.WorldScaleY = parent.WorldScaleY * b.ScaleY
		b.WorldRotation = parent.WorldRotation + b.Rotation
	} else {
		b.WorldX = b.X
		b.WorldY = b.Y
		b.WorldScaleX = b.ScaleX
		b.WorldScaleY = b.ScaleY
		b.WorldRotation = b.Rotation
	}
	radians := float64(b.WorldRotation) * math.Pi / 180.0
	cos := float32(math.Cos(radians))
	sin := float32(math.Sin(radians))
	b.M00 = cos * b.WorldScaleX
	b.M10 = sin * b.WorldScaleX
	b.M01 = -sin * b.WorldScaleY
	b.M11 = cos * b.WorldScaleY
	if flipX {
		b.M00 = -b.M00
		b.M01 = -b.M01
	}
	if flipY {
		b.M10 = -b.M10
		b.M11 = -b.M11
	}
	if BoneYDown {
		b.M10 = -b.M10
		b.M11 = -b.M11
	}
}

```

`anim/spine/curve.go`:

```go
package spine

type Curve struct {
	curves []float32
}

func NewCurve(frameCount int) *Curve {
	curve := new(Curve)
	curve.curves = make([]float32, (frameCount-1)*6)
	return curve
}

func (c *Curve) frameCount() int {
	return len(c.curves)/6 + 1
}

func (c *Curve) SetLinear(index int) {
	c.curves[index*6] = 0
}

func (c *Curve) SetStepped(index int) {
	c.curves[index*6] = -1
}

func (c *Curve) SetCurve(index int, cx1, cy1, cx2, cy2 float32) {
	subdiv_step := float32(1) / 10
	subdiv_step2 := subdiv_step * subdiv_step
	subdiv_step3 := subdiv_step2 * subdiv_step
	pre1 := 3 * subdiv_step
	pre2 := 3 * subdiv_step2
	pre4 := 6 * subdiv_step2
	pre5 := 6 * subdiv_step3
	tmp1x := -cx1*2 + cx2
	tmp1y := -cy1*2 + cy2
	tmp2x := (cx1-cx2)*3 + 1
	tmp2y := (cy1-cy2)*3 + 1
	i := index * 6
	curves := c.curves
	curves[i] = cx1*pre1 + tmp1x*pre2 + tmp2x*subdiv_step3
	curves[i+1] = cy1*pre1 + tmp1y*pre2 + tmp2y*subdiv_step3
	curves[i+2] = tmp1x*pre4 + tmp2x*pre5
	curves[i+3] = tmp1y*pre4 + tmp2y*pre5
	curves[i+4] = tmp2x * pre5
	curves[i+5] = tmp2y * pre5
}

func (c *Curve) CurvePercent(index int, percent float32) float32 {
	if percent < 0 {
		percent = 0
	} else if percent > 1 {
		percent = 1
	}

	curveIndex := index * 6
	curves := c.curves
	dfx := curves[curveIndex]
	if dfx == 0 {
		return percent
	}
	if dfx == -1 {
		return 0
	}

	dfy := curves[curveIndex+1]
	ddfx := curves[curveIndex+2]
	ddfy := curves[curveIndex+3]
	dddfx := curves[curveIndex+4]
	dddfy := curves[curveIndex+5]
	x := dfx
	y := dfy
	i := 8

	for {
		if x >= percent {
			lastX := x - dfx
			lastY := y - dfy
			return lastY + (y-lastY)*(percent-lastX)/(x-lastX)
		}
		if i == 0 {
			break
		}
		i -= 1
		dfx += ddfx
		dfy += ddfy
		ddfx += dddfx
		ddfy += dddfy
		x += dfx
		y += dfy
	}
	return y + (1-y)*(percent-x)/(1-x)
}

```

`anim/spine/doc.md.go`:

```go
package spine

// the first version fork form: https://github.com/ajhager/spine

```

`anim/spine/skeleton.go`:

```go
package spine

type SkeletonData struct {
	bones       []*BoneData
	slots       []*SlotData
	skins       []*Skin
	animations  []*Animation
	defaultSkin *Skin
}

func NewSkeletonData() *SkeletonData {
	data := new(SkeletonData)
	data.bones = make([]*BoneData, 0)
	data.slots = make([]*SlotData, 0)
	data.skins = make([]*Skin, 0)
	data.animations = make([]*Animation, 0)
	return data
}

func (s *SkeletonData) findBone(name string) (int, *BoneData) {
	for i, bone := range s.bones {
		if bone.name == name {
			return i, bone
		}
	}
	return -1, nil
}

func (s *SkeletonData) findSlot(name string) (int, *SlotData) {
	for i, slot := range s.slots {
		if slot.name == name {
			return i, slot
		}
	}
	return -1, nil
}

func (s *SkeletonData) findSkin(name string) (int, *Skin) {
	for i, skin := range s.skins {
		if skin.name == name {
			return i, skin
		}
	}
	return -1, nil
}

func (s *SkeletonData) findAnimation(name string) (int, *Animation) {
	for i, animation := range s.animations {
		if animation.name == name {
			return i, animation
		}
	}
	return -1, nil
}

type Skeleton struct {
	data         *SkeletonData
	Bones        []*Bone
	Slots        []*Slot
	DrawOrder    []*Slot
	skin         *Skin
	X, Y         float32
	r, g, b, a   float32
	time         float32
	FlipX, FlipY bool
	DebugBones   bool
	DebugSlots   bool
}

func NewSkeleton(skeletonData *SkeletonData) *Skeleton {
	skeleton := new(Skeleton)
	skeleton.data = skeletonData
	skeleton.r = 1
	skeleton.g = 1
	skeleton.b = 1
	skeleton.a = 1

	skeleton.Bones = make([]*Bone, 0)
	for _, boneData := range skeletonData.bones {
		var parent *Bone
		if boneData.parent != nil {
			i, _ := skeletonData.findBone(boneData.parent.name)
			parent = skeleton.Bones[i]
		}
		skeleton.Bones = append(skeleton.Bones, NewBone(boneData, parent))
	}

	skeleton.Slots = make([]*Slot, 0)
	skeleton.DrawOrder = make([]*Slot, 0)
	for _, slotData := range skeletonData.slots {
		i, _ := skeletonData.findBone(slotData.boneData.name)
		bone := skeleton.Bones[i]
		slot := NewSlot(slotData, skeleton, bone)
		skeleton.Slots = append(skeleton.Slots, slot)
		skeleton.DrawOrder = append(skeleton.DrawOrder, slot)
	}

	return skeleton
}

func (s *Skeleton) UpdateWorldTransform() {
	for _, bone := range s.Bones {
		bone.UpdateWorldTransform(s.FlipX, s.FlipY)
	}
}

func (s *Skeleton) SetToSetupPose() {
	s.setBonesToSetupPose()
	s.setSlotsToSetupPose()
}

func (s *Skeleton) setBonesToSetupPose() {
	for _, bone := range s.Bones {
		bone.SetToSetupPose()
	}
}

func (s *Skeleton) setSlotsToSetupPose() {
	for _, slot := range s.Slots {
		slot.SetToSetupPose()
	}
}

func (s *Skeleton) RootBone() *Bone {
	if len(s.Bones) != 0 {
		return s.Bones[0]
	}
	return nil
}

func (s *Skeleton) FindBone(name string) (int, *Bone) {
	for i, bone := range s.Bones {
		if bone.name == name {
			return i, bone
		}
	}
	return -1, nil
}

func (s *Skeleton) FindSlot(name string) (int, *Slot) {
	for i, slot := range s.Slots {
		if slot.data.name == name {
			return i, slot
		}
	}
	return -1, nil
}

func (s *Skeleton) SetSkinByName(name string) {
	_, skin := s.data.findSkin(name)
	if skin == nil {
		panic("Skin not found: " + name)
	}
	s.SetSkin(skin)
}

func (s *Skeleton) SetSkin(skin *Skin) {
	if s.skin != nil && skin != nil {
		skin.attachAll(s, s.skin)
	}
	s.skin = skin
}

func (s *Skeleton) AttachmentBySlotName(slot string, attachment string) Attachment {
	i, _ := s.data.findSlot(slot)
	return s.AttachmentBySlotIndex(i, attachment)
}

func (s *Skeleton) AttachmentBySlotIndex(index int, name string) Attachment {
	if s.skin != nil {
		attachment := s.skin.Attachment(index, name)
		if attachment != nil {
			return attachment
		}
	}
	if s.data.defaultSkin != nil {
		return s.data.defaultSkin.Attachment(index, name)
	}
	return nil
}

func (s *Skeleton) SetAttachment(slotName, attachmentName string) {
	for i, slot := range s.Slots {
		if slot.data.name == slotName {
			var attachment Attachment
			if attachmentName != "" {
				attachment = s.AttachmentBySlotIndex(i, attachmentName)
				if attachment == nil {
					panic("Attachment not found: " + attachmentName + ", for slot: " + slotName)
				}
			}
			slot.SetAttachment(attachment)
			return
		}
	}
	panic("slot not found: " + slotName)
}

func (s *Skeleton) FindAnimation(name string) *Animation {
	_, a := s.data.findAnimation(name)
	return a
}

func (s *Skeleton) Update(dt float32) {
	s.time += dt
}

```

`anim/spine/skin.go`:

```go
package spine

import (
	"fmt"
)

type skinData struct {
	Index      int
	Name       string
	Attachment Attachment
}

type Skin struct {
	name        string
	attachments map[string]*skinData
}

func NewSkin(name string) *Skin {
	skin := new(Skin)
	skin.name = name
	skin.attachments = make(map[string]*skinData)
	return skin
}

func (s *Skin) AddAttachment(slotIndex int, name string, attachment Attachment) {
	data := &skinData{slotIndex, name, attachment}
	s.attachments[fmt.Sprintf("%v:%v", slotIndex, name)] = data
}

func (s *Skin) Attachment(slotIndex int, name string) Attachment {
	values, ok := s.attachments[fmt.Sprintf("%v:%v", slotIndex, name)]
	if !ok {
		return nil
	}
	return values.Attachment
}

func (s *Skin) attachAll(skeleton *Skeleton, oldSkin *Skin) {
	for _, val := range oldSkin.attachments {
		slot := skeleton.Slots[val.Index]
		attachment := s.Attachment(val.Index, val.Name)
		if attachment != nil {
			slot.SetAttachment(attachment)
		}
	}
}

```

`anim/spine/slot.go`:

```go
package spine

type SlotData struct {
	name           string
	boneData       *BoneData
	r, g, b, a     float32
	attachmentName string
}

func NewSlotData(name string, boneData *BoneData) *SlotData {
	slotData := new(SlotData)
	slotData.name = name
	slotData.boneData = boneData
	slotData.r = 1
	slotData.g = 1
	slotData.b = 1
	slotData.a = 1
	return slotData
}

type Slot struct {
	data           *SlotData
	skeleton       *Skeleton
	Bone           *Bone
	R, G, B, A     float32
	attachmentTime float32
	Attachment     Attachment
}

func NewSlot(slotData *SlotData, skeleton *Skeleton, bone *Bone) *Slot {
	slot := new(Slot)
	slot.data = slotData
	slot.skeleton = skeleton
	slot.Bone = bone
	slot.R = 1
	slot.G = 1
	slot.B = 1
	slot.A = 1
	slot.SetToSetupPose()
	return slot
}

func (s *Slot) SetToSetupPose() {
	data := s.data
	s.R = data.r
	s.G = data.g
	s.B = data.b
	s.A = data.a

	for i, slotData := range s.skeleton.data.slots {
		if slotData == data {
			s.SetAttachment(s.skeleton.AttachmentBySlotIndex(i, data.attachmentName))
			return
		}
	}
}

func (s *Slot) SetAttachment(attachment Attachment) {
	s.Attachment = attachment
	s.attachmentTime = s.skeleton.time
}

func (s *Slot) SetAttachmentTime(time float32) {
	s.attachmentTime = s.skeleton.time - time
}

func (s *Slot) AttachmentTime() float32 {
	return s.skeleton.time - s.attachmentTime
}

func (s *Slot) Skeleton() *Skeleton {
	return s.skeleton
}

```

`anim/spine/spine.go`:

```go
package spine

import (
	"encoding/json"
	"errors"
	"io"
	"math"
	"strconv"
)

// 动画时间线
type fileAnim struct {
	Bones map[string]map[string][]map[string]interface{} `json:"bones"`
	Slots map[string]map[string][]map[string]interface{} `json:"slots"`
}

// 插槽 - 骨骼和蒙皮的关联映射
type fileSlot struct {
	Bone       string `json:"bone"`
	Name       string `json:"name"`
	Color      string `json:"color"`
	Attachment string `json:"attachment"`
}

// 骨骼姿势
type fileBone struct {
	Name   string `json:"name"`
	Parent string `json:"parent"`

	Length   interface{} `json:"length"`
	Rotation interface{} `json:"rotation"`
	X        interface{} `json:"x"`
	Y        interface{} `json:"y"`
	ScaleX   interface{} `json:"scaleX"`
	ScaleY   interface{} `json:"scaleY"`
}

// 插件
type fileAttachment struct {
	Name string `json:"name"`
	Type string `json:"type"`

	Rotation interface{} `json:"rotation"`
	X        interface{} `json:"x"`
	Y        interface{} `json:"y"`
	ScaleX   interface{} `json:"scaleX"`
	ScaleY   interface{} `json:"scaleY"`
	Width    interface{} `json:"width"`
	Height   interface{} `json:"height"`
}

type fileRoot struct {
	Bones      []fileBone                                      `json:"bones"`
	Slots      []fileSlot                                      `json:"slots"`
	Skins      map[string]map[string]map[string]fileAttachment `json:"skins"`
	Animations map[string]fileAnim                             `json:"animations"`
}

type AttachmentLoader interface {
	NewAttachment(skin *Skin, _type, name string) (Attachment, error)
}

type AtlasAttachmentLoader struct {
	*Atlas
}

func (a AtlasAttachmentLoader) NewAttachment(skin *Skin, _type, name string) (Attachment, error) {
	if _type != "region" && _type != "" {
		return nil, errors.New("spine: unknown attachment type: " + _type)
	}
	attachment := NewRegionAttachment(name)
	region := a.FindRegion(name)
	if region == nil {
		return nil, errors.New("spine: region not found in atlas: " + name + " (" + _type + ")")
	}
	attachment.RendererObject = region
	attachment.SetUVs(region.U, region.V, region.U2, region.V2, region.Rotate)
	attachment.RegionOffsetX = region.OffsetX
	attachment.RegionOffsetY = region.OffsetY
	attachment.RegionWidth = float32(region.Width)
	attachment.RegionHeight = float32(region.Height)
	attachment.RegionOriginalWidth = float32(region.OriginalWidth)
	attachment.RegionOriginalHeight = float32(region.OriginalHeight)
	return attachment, nil
}

func New(r io.Reader, scale float32, loader AttachmentLoader) (*SkeletonData, error) {
	var root fileRoot
	err := json.NewDecoder(r).Decode(&root)
	if err != nil {
		return nil, errors.New("failed to parse skeleton json: " + err.Error())
	}

	skeletonData := NewSkeletonData()

	// Bones
	for _, bone := range root.Bones {
		boneName := bone.Name
		var boneParent *BoneData
		if parentName := bone.Parent; parentName != "" {
			_, boneParent = skeletonData.findBone(parentName)
			if boneParent == nil {
				return nil, errors.New("Parent bone not found: " + parentName)
			}
		}

		boneData := NewBoneData(boneName, boneParent)

		if length, ok := bone.Length.(float64); ok {
			boneData.Length = float32(length) * scale
		}

		if x, ok := bone.X.(float64); ok {
			boneData.x = float32(x) * scale
		}

		if y, ok := bone.Y.(float64); ok {
			boneData.y = float32(y) * scale
		}

		if rotation, ok := bone.Rotation.(float64); ok {
			boneData.rotation = float32(rotation)
		}

		boneData.scaleX = 1
		if scaleX, ok := bone.ScaleX.(float64); ok {
			boneData.scaleX = float32(scaleX)
		}

		boneData.scaleY = 1
		if scaleY, ok := bone.ScaleY.(float64); ok {
			boneData.scaleY = float32(scaleY)
		}

		skeletonData.bones = append(skeletonData.bones, boneData)
	}

	// Slots
	for _, slot := range root.Slots {
		boneName := slot.Bone
		_, boneData := skeletonData.findBone(boneName)
		if boneData == nil {
			return nil, errors.New("spine: slot bone not found: " + boneName)
		}
		slotData := NewSlotData(slot.Name, boneData)

		if color := slot.Color; color != "" {
			c, err := toColor(color)
			if err != nil {
				return nil, errors.New("spine: failed to parse color: " + err.Error())
			}
			slotData.r = c[0]
			slotData.g = c[1]
			slotData.b = c[2]
			slotData.a = c[3]
		}

		slotData.attachmentName = slot.Attachment

		skeletonData.slots = append(skeletonData.slots, slotData)
	}

	// Skins
	for skinName, skinMap := range root.Skins {
		skin := NewSkin(skinName)
		for slotName, slotMap := range skinMap {
			slotIndex, _ := skeletonData.findSlot(slotName)
			for name, at := range slotMap {
				atName := name
				if at.Name != "" {
					atName = at.Name
				}

				attachment, err := loader.NewAttachment(skin, at.Type, atName)
				if err != nil {
					return nil, err
				}
				if regionAttach, ok := attachment.(*RegionAttachment); ok {
					readAttachment(regionAttach, at, scale)
				}
				skin.AddAttachment(slotIndex, name, attachment)
			}
		}
		skeletonData.skins = append(skeletonData.skins, skin)
		if skin.name == "default" {
			skeletonData.defaultSkin = skin
		}
	}

	// Animations
	for animName, fileAnim := range root.Animations {
		timelines := make([]Timeline, 0)
		duration := float32(0)
		for boneName, timelineMap := range fileAnim.Bones {
			boneIndex, _ := skeletonData.findBone(boneName)
			for timelineType, timelineData := range timelineMap {
				if timelineType == "rotate" {
					n := len(timelineData)
					timeline := NewRotateTimeline(n)
					timeline.boneIndex = boneIndex
					for i, valueMap := range timelineData {
						time := float32(valueMap["time"].(float64))
						angle := float32(valueMap["angle"].(float64))
						timeline.setFrame(i, time, angle)
						if curve, ok := valueMap["curve"]; ok {
							readCurve(timeline.curve, i, curve)
						}
					}
					duration = float32(math.Max(float64(duration), float64(timeline.frames[timeline.frameCount()*2-2])))

					timelines = append(timelines, timeline)
				} else if timelineType == "translate" {
					n := len(timelineData)
					timeline := NewTranslateTimeline(n)
					timeline.boneIndex = boneIndex
					for i, valueMap := range timelineData {
						x := float32(0)
						if xx, ok := valueMap["x"].(float64); ok {
							x = float32(xx) * scale
						}
						y := float32(0)
						if yy, ok := valueMap["y"].(float64); ok {
							y = float32(yy) * scale
						}
						time := float32(valueMap["time"].(float64))

						timeline.setFrame(i, time, x, y)
						if curve, ok := valueMap["curve"]; ok {
							readCurve(timeline.curve, i, curve)
						}
					}
					duration = float32(math.Max(float64(duration), float64(timeline.frames[timeline.frameCount()*3-3])))
					timelines = append(timelines, timeline)
				} else if timelineType == "scale" {
					n := len(timelineData)
					timeline := NewScaleTimeline(n)
					timeline.boneIndex = boneIndex
					for i, valueMap := range timelineData {
						x := float32(0)
						if xx, ok := valueMap["x"].(float64); ok {
							x = float32(xx)
						}
						y := float32(0)
						if yy, ok := valueMap["y"].(float64); ok {
							y = float32(yy)
						}
						time := float32(valueMap["time"].(float64))

						timeline.setFrame(i, time, x, y)
						if curve, ok := valueMap["curve"]; ok {
							readCurve(timeline.curve, i, curve)
						}
					}
					duration = float32(math.Max(float64(duration), float64(timeline.frames[timeline.frameCount()*3-3])))
					timelines = append(timelines, timeline)
				}
			}
		}
		for slotName, timelineMap := range fileAnim.Slots {
			slotIndex, _ := skeletonData.findSlot(slotName)

			for timelineName, values := range timelineMap {
				n := len(values)
				if timelineName == "color" {
					timeline := NewColorTimeline(n)
					timeline.slotIndex = slotIndex

					for frameIndex, valueMap := range values {
						time := float32(valueMap["time"].(float64))
						c, err := toColor(valueMap["color"].(string))
						if err != nil {
							return nil, errors.New("spine: failed to parse color: " + err.Error())
						}
						timeline.setFrame(frameIndex, time, c[0], c[1], c[2], c[3])
						readCurve(timeline.curve, frameIndex, valueMap)
					}
					duration = float32(math.Max(float64(duration), float64(timeline.frames[timeline.frameCount()*5-5])))
					timelines = append(timelines, timeline)
				} else if timelineName == "attachment" {
					timeline := NewAttachmentTimeline(n)
					timeline.slotIndex = slotIndex

					for frameIndex, valueMap := range values {
						time := float32(valueMap["time"].(float64))

						// TODO name can be nil!!
						if name, ok := valueMap["name"].(string); ok {
							timeline.setFrame(frameIndex, time, name)
						} else {
							timeline.setFrame(frameIndex, time, "")
						}
					}
					duration = float32(math.Max(float64(duration), float64(timeline.frames[timeline.frameCount()-1])))
					timelines = append(timelines, timeline)
				}
			}
		}
		anim := NewAnimation(animName, timelines, duration)
		skeletonData.animations = append(skeletonData.animations, anim)
	}

	return skeletonData, nil
}

func toColor(colorStr string) (c [4]float32, err error) {
	for i := 0; i < len(c); i++ {
		var b uint64
		if b, err = strconv.ParseUint(colorStr[i*2:(i+1)*2], 16, 8); err != nil {
			return
		}
		c[i] = float32(b) / 255.0
	}
	return
}

func readAttachment(attachment *RegionAttachment, at fileAttachment, scale float32) {
	if x, ok := at.X.(float64); ok {
		attachment.X = float32(x) * scale
	}

	if y, ok := at.Y.(float64); ok {
		attachment.Y = float32(y) * scale
	}

	if rotation, ok := at.Rotation.(float64); ok {
		attachment.Rotation = float32(rotation)
	}

	attachment.ScaleX = 1
	if scaleX, ok := at.ScaleX.(float64); ok {
		attachment.ScaleX = float32(scaleX)
	}

	attachment.ScaleY = 1
	if scaleY, ok := at.ScaleY.(float64); ok {
		attachment.ScaleY = float32(scaleY)
	}

	attachment.Width = 32
	if width, ok := at.Width.(float64); ok {
		attachment.Width = float32(width) * scale
	}

	attachment.Height = 32
	if height, ok := at.Height.(float64); ok {
		attachment.Height = float32(height) * scale
	}
	attachment.updateOffset()
}

func readCurve(curve *Curve, frameIndex int, data interface{}) {
	switch t := data.(type) {
	default:
	case string:
		if t == "stepped" {
			curve.SetStepped(frameIndex)
		}
	case []interface{}:
		a := float32(t[0].(float64))
		b := float32(t[1].(float64))
		c := float32(t[2].(float64))
		d := float32(t[3].(float64))
		curve.SetCurve(frameIndex, a, b, c, d)
	}
}
```

`anim/ween/anim.go`:

```go
package ween

import (
	"korok.io/korok/math/ease"
)

type UpdateCallback func(reverse bool, f float32)
type EndCallback func(reverse bool)

type Callback struct {
	UpdateCallback
	EndCallback
}

type Value struct {
	f float32
}

type AnimState uint8

const (
	Waiting AnimState = iota
	Running
	Stopped
	Dispose
)

// Defines what this animation should do when it reaches the end.
type LoopType uint8
const (
	Restart LoopType = iota
	PingPong
)

// Sets how many times the animation should be repeated.
const (
	RepeatOnce = 1
	RepeatInfinite = -1
)

// 维护动画的状态数据
// 底层动画系统，使用float作为单位 0-1
type Animation struct {
	index int
	clock, duration float32
	iteration, repeatCount int
	interpolator ease.Function
	LoopType
	state struct{
		AnimState
		dirty bool
	}
	reverse bool
	delay float32
}

func (anim *Animation) Reset() {
	anim.interpolator = ease.Linear
	anim.state.AnimState = Waiting
	anim.clock = 0
	anim.LoopType = Restart
	anim.repeatCount = 0
	anim.reverse = false
}

// 动画核心算法
func (anim *Animation) Animate(dt float32) (f float32) {
	anim.clock += dt
	fr := anim.clock / anim.duration
	if fr >= 1 {
		if anim.iteration < anim.repeatCount || anim.repeatCount == RepeatInfinite {
			// Time to repeat
			anim.iteration += int(fr)
			anim.clock = 0
			if anim.LoopType == PingPong {
				anim.reverse = !anim.reverse
			}
			for;fr >= 1; { fr = fr - 1 }
		} else {
			anim.state.AnimState = Stopped
			anim.state.dirty = true
			fr = 1
		}
	}
	if anim.state.AnimState == Stopped {
		f = 1
	} else {
		f = float32(anim.interpolator(float64(fr)))
	}
	if anim.reverse {
		f = 1 - f
	}
	return
}

type TweenEngine struct {
	anims []Animation
	values []Value
	callbacks []Callback

	time, scale float32
	active, cap int
	lookup map[int]int
	uniqueId int
}

func NewEngine() *TweenEngine {
	return &TweenEngine{
		scale:     1,
		anims:     make([]Animation, 32),
		values:    make([]Value, 32),
		callbacks: make([]Callback, 32),
		lookup:    make(map[int]int),
	}
}

func (eng *TweenEngine) New() (uid int) {
	uid = eng.uniqueId; eng.uniqueId++
	index := eng.active
	eng.active ++
	anim := &eng.anims[index];
	anim.Reset()
	anim.index = uid
	eng.values[index] = Value{}
	eng.callbacks[index] = Callback{}
	eng.lookup[uid] = index
	return
}

func (eng *TweenEngine) Delete(index int) {
	if v, ok := eng.lookup[index]; ok {
		eng.anims[v].state.AnimState = Dispose
	}
}

func (eng *TweenEngine) SetTimeScale(sk float32) {
	eng.scale = sk
}

// It's not easy to maintain the callback, one many add or delete animation
// while looping. Thanks to our delayed deleting strategy that delete operation
// only mark the animation 'Disposed' and will not change the size of the
// active animation. But add new animation will change the size, since new
// animation is always appended to the end. We can easily know the real size.
// Note: we need a BETTER callback policy.
func (eng *TweenEngine) Update(dt float32) {
	size := eng.active
	// 1. update
	for i := 0; i < size; i++ {
		if anim := &eng.anims[i]; anim.state.AnimState == Running {
			f := anim.Animate(dt)
			eng.values[i] = Value{f}
		}
	}

	// 2. callback
	for i := 0; i < eng.active; i++ {
		if anim := &eng.anims[i]; anim.state.AnimState == Stopped && anim.state.dirty {
			anim.state.dirty = false
			if cb := eng.callbacks[i].EndCallback; cb != nil {
				cb(anim.reverse)
			}
		} else if anim.state.AnimState == Running {
			if cb := eng.callbacks[i].UpdateCallback; cb != nil {
				cb(anim.reverse, eng.values[i].f)
			}
		}
	}
	// 3. delete dead
	var	i, j = 0, eng.active-1
	for i <= j {
		if anim := &eng.anims[i]; anim.state.AnimState == Dispose {
			eng.lookup[eng.anims[j].index] = i
			delete(eng.lookup, anim.index)
			eng.anims[i] = eng.anims[j]
			eng.values[i] = eng.values[j]
			eng.callbacks[i] = eng.callbacks[j]
			j--
		} else {
			i++
		}
	}
	eng.active = i

	//dbg.Move(10, 300)
	//dbg.DrawStrScaled(fmt.Sprintf("animation: %d", i), .6)
}

// Play an animation, produces values that range from 0.0 to 1.0,
// during a given duration.
func (eng *TweenEngine) Forward(index int) {
	if v, ok := eng.lookup[index]; ok {
		anim := &eng.anims[v]
		anim.clock = 0
		anim.state.AnimState = Running
		anim.state.dirty = true
		anim.iteration = 0
		anim.reverse = false

		eng.values[v] = Value{}
	}
}

// Play an animation in reverse. If the animation is already running,
// stop itself and play backwards from the point. If the animation is not
// running, then it will start from the end and play backwards.
func (eng *TweenEngine) Reverse(index int) {
	if v, ok := eng.lookup[index]; ok {
		if anim := &eng.anims[v]; anim.state.AnimState == Running {
			anim.clock = anim.duration - anim.clock
			anim.reverse = !anim.reverse
		} else {
			anim.reverse = !anim.reverse
			anim.clock = 0
			anim.state.AnimState = Running
			anim.state.dirty = true
			anim.iteration = 0
		}
	}
}

// Stops running this animation.
func (eng *TweenEngine) Stop(index int) {
	if v, ok := eng.lookup[index]; ok {
		eng.anims[v].state.AnimState = Stopped
		eng.anims[v].state.dirty = true
	}
}

// Duration is the length of time this animation should last.
func (eng *TweenEngine) SetDuration(index int, d float32) {
	if v, ok := eng.lookup[index]; ok {
		eng.anims[v].duration = d
	}
}

// Repeat the animation. If playback type is forward, restart the animation
// from start, if the playback type is backward or ping-pong,
func (eng *TweenEngine) SetRepeat(index int, count int, loop LoopType) {
	if v, ok := eng.lookup[index]; ok {
		eng.anims[v].repeatCount = count
		eng.anims[v].LoopType = loop
	}
}

func (eng *TweenEngine) SetFunction(index int, fn ease.Function) {
	if v, ok := eng.lookup[index]; ok {
		if fn != nil {
			eng.anims[v].interpolator = fn
		} else {
			eng.anims[v].interpolator = ease.Linear
		}
	}
}

func (eng *TweenEngine) SetUpdateCallback(index int, cb UpdateCallback) {
	if v, ok := eng.lookup[index]; ok {
		eng.callbacks[v].UpdateCallback = cb
	}
}

func (eng *TweenEngine) SetCompleteCallback(index int, cb EndCallback) {
	if v, ok := eng.lookup[index]; ok {
		eng.callbacks[v].EndCallback = cb
	}
}

func (eng *TweenEngine) Value(index int) (f float32) {
	if v, ok := eng.lookup[index]; ok {
		f = eng.values[v].f
	}
	return
}

func (eng *TweenEngine) Duration(index int) float32 {
	if v, ok := eng.lookup[index]; ok {
		return eng.anims[v].duration
	} else {
		return 0
	}
}


```

`anim/ween/animator.go`:

```go
package ween

import "korok.io/korok/math/ease"

type Animator struct {
	en *TweenEngine
	index int
}

func (eng *TweenEngine) NewAnimator() Animator {
	return Animator{eng, eng.New()}
}

func (am Animator) SetDuration(d float32) Animator{
	am.en.SetDuration(am.index, d)
	return am
}

func (am Animator) SetRepeat(count int, loop LoopType) Animator {
	am.en.SetRepeat(am.index, count, loop)
	return am
}

func (am Animator) SetFunction(function ease.Function) Animator {
	am.en.SetFunction(am.index, function)
	return am
}

func (am Animator) OnUpdate(cb UpdateCallback) Animator{
	am.en.SetUpdateCallback(am.index, cb)
	return am
}

func (am Animator) OnComplete(cb EndCallback) Animator{
	am.en.SetCompleteCallback(am.index, cb)
	return am
}

func (am Animator) Value() (f float32) {
	return am.en.Value(am.index)
}

func (am Animator) Valid() bool {
	if am.en == nil {
		return false
	}
	if _, ok := am.en.lookup[am.index]; !ok {
		return false
	}
	return true
}

func (am Animator) Forward() {
	am.en.Forward(am.index)
}

func (am Animator) Reverse() {
	am.en.Reverse(am.index)
}

func (am Animator) Stop() {
	am.en.Stop(am.index)
}

func (am Animator) Dispose() {
	am.en.Delete(am.index)
}



```

`anim/ween/tween_test.go`:

```go
package ween



```

`anim/ween/tweens.go`:

```go
package ween

import (
	"korok.io/korok/math/f32"
	"korok.io/korok/gfx"
	"log"
)

func U8Lerp(from, to uint8, f float32) uint8 {
	v1, v2 := float32(from), float32(to)
	return uint8(v1+(v2-v1)*f)
}

func U16Lerp(from, to uint16, f float32) uint16 {
	v1, v2 := float32(from), float32(to)
	return uint16(v1+(v2-v1)*f)
}

func IntLerp(from, to int, f float32) int {
	return from + int(float32(to-from)*f)
}

func F32Lerp(from, to float32, f float32) float32 {
	return from + (to-from)*f
}

func Vec2Lerp(from, to f32.Vec2, f float32) f32.Vec2 {
	v2 := f32.Vec2{
		F32Lerp(from[0], to[0], f),
		F32Lerp(from[1], to[1], f),
	}
	return v2
}

func ColorLerp(from, to gfx.Color, f float32) gfx.Color {
	c := gfx.Color{
		R: U8Lerp(from.R, to.R, f),
		G: U8Lerp(from.G, to.G, f),
		B: U8Lerp(from.B, to.B, f),
		A: U8Lerp(from.A, to.A, f),
	}
	return c
}

// A float32 linear interpolation between a beginning and ending value.
// It use the Animator as the input.
type F32Tween struct {
	am Animator
	from, to float32
}

// Animate sets the Animator that drives the Tween.
func (t *F32Tween) Animate(am Animator) Animator {
	t.am = am
	return am
}

// Animator returns the Animator driving the Tween.
func (t *F32Tween) Animator() Animator {
	if !t.am.Valid() {
		log.Println("animator is unavailable")
	}
	return t.am
}

// Range sets the beginning and ending value of the F32Tween.
func (t *F32Tween) Range(from, to float32) *F32Tween {
	t.from = from
	t.to = to
	return t
}

// Returns the interpolated value for the current value of the given Animator.
func (t *F32Tween) Value() float32 {
	return F32Lerp(t.from, t.to, t.am.Value())
}

// A f32.Vec2 linear interpolation between a beginning and ending value.
// It use the Animator as the input.
type Vec2Tween struct {
	am Animator
	from, to f32.Vec2
}

// Animate sets the Animator that drives the Tween.
func (t *Vec2Tween) Animate(am Animator) Animator {
	t.am = am
	return am
}

// Animator returns the Animator driving the Tween.
func (t *Vec2Tween) Animator() Animator {
	return t.am
}

// Range sets the beginning and ending value of the Vec2Tween.
func (t *Vec2Tween) Range(from, to f32.Vec2) *Vec2Tween {
	t.from, t.to = from, to
	return t
}

// Returns the interpolated value for the current value of the given Animator.
func (t *Vec2Tween) Value() f32.Vec2 {
	return Vec2Lerp(t.from, t.to, t.am.Value())
}

// A gfx.Color linear interpolation between a beginning and ending value.
// It use the Animator as the input.
type ColorTween struct {
	am Animator
	from, to gfx.Color
}

// Range sets the beginning and ending value of the ColorTween.
func (t *ColorTween) Range(from, to gfx.Color) *ColorTween {
	t.from, t.to = from, to
	return t
}

// Animate sets the Animator that drives the Tween.
func (t *ColorTween) Animate(animator Animator) Animator {
	t.am = animator
	return animator
}

// Animator returns the Animator driving the Tween.
func (t *ColorTween) Animator() Animator {
	return t.am
}

// Returns the interpolated value for the current value of the given Animator.
func (t *ColorTween) Value() gfx.Color {
	return ColorLerp(t.from, t.to, t.am.Value())
}



```

`anim/ween_basic.go`:

```go
package anim

import (
	"korok.io/korok/anim/ween"
	"korok.io/korok/math/f32"
	"korok.io/korok/gfx"
	"korok.io/korok/math/ease"
)

// A fire-and-forget pattern Animator.
type proxyAnimator struct {
	ween.Animator
	update ween.UpdateCallback
	complete ween.EndCallback
}

// Proxy the SetDuration method.
func (proxy *proxyAnimator) SetDuration(d float32) *proxyAnimator {
	proxy.Animator.SetDuration(d)
	return proxy
}

// Proxy the SetRepeat method.
func (proxy *proxyAnimator) SetRepeat(count int, loop ween.LoopType) *proxyAnimator {
	proxy.Animator.SetRepeat(count, loop)
	return proxy
}

// Proxy the SetFunction method.
func (proxy *proxyAnimator) SetFunction(function ease.Function) *proxyAnimator {
	proxy.Animator.SetFunction(function)
	return proxy
}

// Proxy the OnUpdate method. proxyAnimator uses the UpdateCallback to update values internally,
// the user UpdateCallback will be called after it.
func (proxy *proxyAnimator) OnUpdate(fn ween.UpdateCallback) *proxyAnimator{
	proxy.update = fn
	return proxy
}

// Proxy the OnComplete method. proxyAnimator uses the CompleteCallback to remove itself from
// the TweenEngine, the user CompleteCallback will be called after it.
func (proxy *proxyAnimator) OnComplete(fn ween.EndCallback) *proxyAnimator{
	proxy.complete = fn
	return proxy
}

// OfFloat returns a Animator that animates between float values.
func OfFloat(target *float32, from, to float32) *proxyAnimator {
	proxy := &proxyAnimator{ Animator: tweenEngine.NewAnimator()}
	proxy.Animator.OnUpdate(func (r bool, f float32) {
		*target = ween.F32Lerp(from, to, f)
		if fn := proxy.update; fn != nil {
			fn(r, f)
		}
	})
	proxy.Animator.OnComplete(func(reverse bool) {
		proxy.Dispose()
		if fn := proxy.complete; fn != nil {
			fn(reverse)
		}
	})
	return proxy
}

// OfVec2 returns a Animator that animates between f32.Vec2 values.
func OfVec2(target *f32.Vec2, from, to f32.Vec2) *proxyAnimator {
	proxy := &proxyAnimator{Animator:tweenEngine.NewAnimator()}
	proxy.Animator.OnUpdate(func(r bool, f float32) {
		*target = ween.Vec2Lerp(from, to, f)
		if fn := proxy.update; fn != nil {
			fn(r, f)
		}
	})
	proxy.Animator.OnComplete(func(reverse bool) {
		proxy.Dispose()
		if fn := proxy.complete; fn != nil {
			fn(reverse)
		}
	})
	return proxy
}

// OfColor returns a Animator that animates between gfx.Color values.
func OfColor(target *gfx.Color, from, to gfx.Color) *proxyAnimator {
	proxy := &proxyAnimator{Animator:tweenEngine.NewAnimator()}
	proxy.Animator.OnUpdate(func(r bool, f float32) {
		*target = ween.ColorLerp(from, to, f)
		if fn := proxy.update; fn != nil {
			fn(r, f)
		}
	})
	proxy.Animator.OnComplete(func(reverse bool) {
		proxy.Dispose()
		if fn := proxy.complete; fn != nil {
			fn(reverse)
		}
	})
	return proxy
}
```

`anim/ween_sprite.go`:

```go
package anim

import (
	"korok.io/korok/engi"
	"korok.io/korok/gfx"
	"korok.io/korok/anim/ween"
)

// Convenient methods that uses to animate the Sprite Component.

// Tint the Entity to given color.
func Tint(e engi.Entity, from, to gfx.Color) *proxyAnimator {
	proxy := &proxyAnimator{Animator:tweenEngine.NewAnimator()}
	proxy.Animator.OnUpdate(func(reverse bool, f float32) {
		if spr := animationSystem.st.Comp(e); spr != nil {
			c := ween.ColorLerp(from, to, f)
			spr.SetColor(c)
		}
		if fn := proxy.update; fn != nil {
			fn(reverse, f)
		}
	})
	proxy.Animator.OnComplete(func(reverse bool) {
		proxy.Dispose()
		if fn := proxy.complete; fn != nil {
			fn(reverse)
		}
	})
	return proxy
}
//
//func Alpha(e engi.Entity, from, to float32) *proxyAnimator {
//	proxy := &proxyAnimator{Animator:tweenEngine.NewAnimator()}
//	proxy.Animator.OnUpdate(func(reverse bool, f float32) {
//		if spr := animationSystem.st.Comp(e); spr != nil {
//			c := spr.Color()
//			a := ween.F32Lerp(from, to, f)
//			// TODO
//		}
//		if fn := proxy.update; fn != nil {
//			fn(reverse, f)
//		}
//	})
//	proxy.Animator.OnComplete(func(reverse bool) {
//		proxy.Dispose()
//		if fn := proxy.complete; fn != nil {
//			fn(reverse)
//		}
//	})
//	return proxy
//}
```

`anim/ween_transform.go`:

```go
package anim

import (
	"korok.io/korok/anim/ween"
	"korok.io/korok/engi"
	"korok.io/korok/math/f32"
)

// Convenient methods that uses to animate the Transform Component.

// Move the Entity to given value.
func Move(e engi.Entity, from, to f32.Vec2) *proxyAnimator {
	proxy := &proxyAnimator{Animator:tweenEngine.NewAnimator()}
	proxy.Animator.OnUpdate(func(r bool, f float32) {
		animationSystem.xf.Comp(e).SetPosition(ween.Vec2Lerp(from, to, f))
		if fn := proxy.update; fn != nil {
			fn(r, f)
		}
	})
	proxy.Animator.OnComplete(func(reverse bool) {
		proxy.Dispose()
		if fn := proxy.complete; fn != nil {
			fn(reverse)
		}
	})
	return proxy
}

// Move the 'x' to given value.
func MoveX(e engi.Entity, from, to float32) *proxyAnimator {
	proxy := &proxyAnimator{Animator:tweenEngine.NewAnimator()}
	proxy.Animator.OnUpdate(func(r bool, f float32) {
		xf := animationSystem.xf.Comp(e)
		x  := ween.F32Lerp(from, to, f)
		xf.SetPosition(f32.Vec2{x, xf.Position()[1]})
		if fn := proxy.update; fn != nil {
			fn(r, f)
		}
	})
	proxy.Animator.OnComplete(func(reverse bool) {
		proxy.Dispose()
		if fn := proxy.complete; fn != nil {
			fn(reverse)
		}
	})
	return proxy
}

// Move the 'y' to given value.
func MoveY(e engi.Entity, from, to float32) *proxyAnimator {
	proxy := &proxyAnimator{Animator:tweenEngine.NewAnimator()}
	proxy.Animator.OnUpdate(func(r bool, f float32) {
		xf := animationSystem.xf.Comp(e)
		y  := ween.F32Lerp(from, to, f)
		xf.SetPosition(f32.Vec2{xf.Position()[0], y})
		if fn := proxy.update; fn != nil {
			fn(r, f)
		}
	})
	proxy.Animator.OnComplete(func(reverse bool) {
		proxy.Dispose()
		if fn := proxy.complete; fn != nil {
			fn(reverse)
		}
	})
	return proxy
}

// Scale the Entity to the given value.
func Scale(e engi.Entity, from, to f32.Vec2) *proxyAnimator {
	proxy := &proxyAnimator{Animator:tweenEngine.NewAnimator()}
	proxy.Animator.OnUpdate(func(reverse bool, f float32) {
		animationSystem.xf.Comp(e).SetScale(ween.Vec2Lerp(from, to, f))
		if fn := proxy.update; fn != nil {
			fn(reverse, f)
		}
	})
	proxy.Animator.OnComplete(func(reverse bool) {
		proxy.Dispose()
		if fn := proxy.complete; fn != nil {
			fn(reverse)
		}
	})
	return proxy
}

// Scale the 'x' to the given value.
func ScaleX(e engi.Entity, from, to float32) *proxyAnimator {
	proxy := &proxyAnimator{Animator:tweenEngine.NewAnimator()}
	proxy.Animator.OnUpdate(func(reverse bool, f float32) {
		xf := animationSystem.xf.Comp(e)
		x  := ween.F32Lerp(from, to, f)
		xf.SetScale(f32.Vec2{x, xf.Scale()[1]})
		if fn := proxy.update; fn != nil {
			fn(reverse, f)
		}
	})
	proxy.Animator.OnComplete(func(reverse bool) {
		proxy.Dispose()
		if fn := proxy.complete; fn != nil {
			fn(reverse)
		}
	})
	return proxy
}

// Scale the 'x' to the given value.
func ScaleY(e engi.Entity, from, to float32) *proxyAnimator {
	proxy := &proxyAnimator{Animator:tweenEngine.NewAnimator()}
	proxy.Animator.OnUpdate(func(reverse bool, f float32) {
		xf := animationSystem.xf.Comp(e)
		y  := ween.F32Lerp(from, to, f)
		xf.SetScale(f32.Vec2{xf.Scale()[0], y})
		if fn := proxy.update; fn != nil {
			fn(reverse, f)
		}
	})
	proxy.Animator.OnComplete(func(reverse bool) {
		proxy.Dispose()
		if fn := proxy.complete; fn != nil {
			fn(reverse)
		}
	})
	return proxy
}

// Rotate the Entity to given value.
func Rotate(e engi.Entity, from, to float32) *proxyAnimator {
	proxy := &proxyAnimator{Animator:tweenEngine.NewAnimator()}
	proxy.Animator.OnUpdate(func(reverse bool, f float32) {
		animationSystem.xf.Comp(e).SetRotation(ween.F32Lerp(from, to, f))
		if fn := proxy.update; fn != nil {
			fn(reverse, f)
		}
	})
	proxy.Animator.OnComplete(func(reverse bool) {
		proxy.Dispose()
		if fn := proxy.complete; fn != nil {
			fn(reverse)
		}
	})
	return proxy
}



```

`asset/R.go`:

```go
package asset

type refCount struct {
	ref interface{} // 资源引用
	cnt int32       // 引用计数
}

type idCount struct {
	rid uint16 	// 资源ID
	cnt uint16  // 引用计数
}

/// 资源在各自相关的系统内管理，此处只提供工具方法
/// 和引用计数相关的操作



func Clear()  {
	// TODO
	//for _, v := range shaders {
	//	gl.DeleteProgram(v.Program)
	//}
	//
	//for _, v := range textures {
	//	gl.DeleteTextures(1, &v.Id)
	//}
}

var Shader *ShaderManager
var Texture *TextureManager
var Font *FontManager
var PSConfig *ParticleConfigManager
var Audio *AudioManager

func init() {
	Shader = &ShaderManager{}
	Audio = NewAudioManager()
	Texture = NewTextureManager()
	Font = NewFontManager()
	PSConfig = NewParticleConfigManager()
}
```

`asset/glsl100.go`:

```go
// +build android ios windows js

package asset

// shader for batch-system
var bVertex = `
#version 100

uniform mat4 proj;

attribute vec4 xyuv;
attribute vec4 rgba;

varying vec4 outColor;
varying vec2 outTexCoord;

void main() {
    outColor = rgba;
	outTexCoord = xyuv.zw;
    gl_Position = proj * vec4(xyuv.xy, 1, 1);
}
` + "\x00"

var bColor = `
#version 100

#ifdef GL_ES
precision mediump float;
#endif

uniform sampler2D tex;

varying vec2 outTexCoord;
varying vec4 outColor;

void main() {
    gl_FragColor = texture2D(tex, outTexCoord) * outColor;
}
` + "\x00"

// mesh shader

var vertex = `
#version 100

uniform mat4 proj;
uniform mat4 model;

attribute vec4 xyuv;
attribute vec4 rgba;

varying vec4 outColor;
varying vec2 outTexCoord;

void main() {
    outColor = rgba;
	outTexCoord = xyuv.zw;
    gl_Position = proj * model * vec4(xyuv.xy, 1, 1);
}
` + "\x00"

var color = `
#version 100

#ifdef GL_ES
precision mediump float;
#endif

uniform sampler2D tex;

varying vec2 outTexCoord;
varying vec4 outColor;

void main() {
    gl_FragColor = texture2D(tex, outTexCoord) * outColor;
}
` + "\x00"

```

`asset/glsl330.go`:

```go
// +build !android,!ios,!windows,!js

package asset

// shader for batch-system
var bVertex = `
#version 330

uniform mat4 proj;

in vec4 xyuv;
in vec4 rgba;

out vec4 outColor;
out vec2 outTexCoord;

void main() {
    outColor = rgba;
	outTexCoord = xyuv.zw;
    gl_Position = proj * vec4(xyuv.xy, 1, 1);
}
` + "\x00"

var bColor = `
#version 330

uniform sampler2D tex;

in vec2 outTexCoord;
in vec4 outColor;

out vec4 outputColor;
void main() {
    outputColor = texture(tex, outTexCoord) * outColor;
}
` + "\x00"

// mesh shader

var vertex = `
#version 330

uniform mat4 proj;
uniform mat4 model;

in vec4 xyuv;
in vec4 rgba;

out vec4 outColor;
out vec2 outTexCoord;

void main() {
    outColor = rgba;
	outTexCoord = xyuv.zw;

    gl_Position = proj * model * vec4(xyuv.xy, 1, 1);
}
` + "\x00"

var color = `
#version 330

uniform sampler2D tex;

in vec2 outTexCoord;
in vec4 outColor;

out vec4 outputColor;
void main() {
    outputColor = texture(tex, outTexCoord) * outColor;
}
` + "\x00"

```

`asset/maudio.go`:

```go
package asset

import (
	"korok.io/korok/audio/sine"
	"strings"
	"log"
)

type AudioManager struct {
	repo map[string]idCount
}

func NewAudioManager() *AudioManager {
	return &AudioManager{make(map[string]idCount)}
}

// Load loads a single Texture file.
func (am *AudioManager) Load(file string, stream bool) {
	if typ := audioType(file); typ == sine.None {
		log.Println("not implemented audio type:", file)
		return
	}
	var rid, cnt uint16
	if v, ok := am.repo[file]; ok {
		cnt = v.cnt
		rid = v.rid
	} else {
		id, _ := sine.R.LoadSound(file, audioType(file), sourceType(stream))
		rid = id
	}
	am.repo[file] = idCount{rid, cnt+1}
	log.Print("load file:", file)
}

// Unload delete raw Texture and any related SubTextures.
func (am *AudioManager) Unload(file string) {
	if v, ok := am.repo[file]; ok {
		if v.cnt > 1 {
			am.repo[file] = idCount{v.rid, v.cnt -1}
		} else {
			delete(am.repo, file)
			sine.R.UnloadSound(v.rid)
			log.Println("refCont == 0, delete resoruce!!")
		}
	}
}

func (am *AudioManager) Get(file string) (id uint16, ok bool){
	if v, ook := am.repo[file]; ook {
		id = v.rid
		ok = true
	}
	return
}

func audioType(name string) sine.FileType {
	switch true {
	case strings.HasSuffix(name, ".wav"):
		return sine.WAV
	case strings.HasSuffix(name, ".ogg"):
		return sine.VORB
	default:
		return sine.None
	}
}

func sourceType(stream bool) sine.SourceType {
	if stream {
		return sine.Stream
	} else {
		return sine.Static
	}
}



```

`asset/mfont.go`:

```go
package asset

import (
	"korok.io/korok/gfx/font"

	"fmt"
	"log"

	"korok.io/korok/asset/res"
)

type FontManager struct {
	repo map[string]refCount
}

func NewFontManager() *FontManager {
	return &FontManager{repo: make(map[string]refCount)}
}

func (fm *FontManager) LoadBitmap(name string, img, fc string) {
	var cnt int32 = 0
	var fnt interface{}

	if v, ok := fm.repo[name]; ok {
		cnt = v.cnt
		fnt = v.ref
	} else {
		ir, err := res.Open(img)
		if err != nil {
			fmt.Println(err)
			return
		}
		fcr, err := res.Open(fc)
		if err != nil {
			fmt.Println(err)
			return
		}

		f, err := font.LoadBitmap(ir, fcr, 1)
		if err != nil {
			fmt.Println(err)
			return
		}
		fnt = f
	}

	fm.repo[name] = refCount{fnt, cnt + 1}
	fmt.Println("load bitmap font sucess...", name)
}

func (fm *FontManager) LoadTrueType(name string, file string, lc font.TTFConfig) {
	var cnt int32 = 0
	var fnt interface{}

	if v, ok := fm.repo[name]; ok {
		cnt = v.cnt
		fnt = v.ref
	} else {
		fcr, err := res.Open(file)
		if err != nil {
			fmt.Println(err)
			return
		}

		f, err := font.LoadTrueType(fcr, lc)
		if err != nil {
			fmt.Println(err)
			return
		}
		fnt = f
	}

	fm.repo[name] = refCount{fnt, cnt + 1}
	fmt.Println("load true-type font sucess...", name)
}

func (fm *FontManager) Unload(name string) {
	if v, ok := fm.repo[name]; ok {
		if v.cnt > 1 {
			fm.repo[name] = refCount{v.ref, v.cnt - 1}
		} else {
			ref := fm.repo[name].ref
			delete(fm.repo, name)
			fnt := ref.(font.Disposer)
			fnt.Dispose()

			log.Println("dispose font:", name)
		}
	}
}

func (fm *FontManager) Get(name string) (fnt font.Font, ok bool) {
	if v, ok1 := fm.repo[name]; ok1 {
		fnt, ok = v.ref.(font.Font)
	}
	return
}

```

`asset/mpsconfig.go`:

```go
package asset

import (
	"korok.io/korok/asset/res"
	"korok.io/korok/effect"
	"korok.io/korok/math"
	"korok.io/korok/math/f32"

	"encoding/json"
	"io/ioutil"
	"log"
)

// 粒子系统配置文件管理
type ParticleConfigManager struct {
	repo map[string]refCount
}

func NewParticleConfigManager() *ParticleConfigManager {
	return &ParticleConfigManager{
		repo: make(map[string]refCount),
	}
}

func (pcm *ParticleConfigManager) Load(file string) {
	if rc, ok := pcm.repo[file]; ok {
		pcm.repo[file] = refCount{rc.ref, rc.cnt + 1}
	} else {
		ref, err := pcm.load(file)
		if err != nil {
			log.Println(err)
		} else {
			pcm.repo[file] = refCount{ref, 1}
		}
	}
}

func (pcm *ParticleConfigManager) Unload(file string) {
	if rc, ok := pcm.repo[file]; ok {
		if rc.cnt > 1 {
			pcm.repo[file] = refCount{rc.ref, rc.cnt - 1}
		} else {
			delete(pcm.repo, file)
		}
	}
}

func (pcm *ParticleConfigManager) Get(file string) (res interface{}, exist bool) {
	if rc, ok := pcm.repo[file]; ok {
		res = rc.ref
		exist = ok
	}
	return
}

func (pcm *ParticleConfigManager) load(file string) (ref interface{}, err error) {
	render, err := res.Open(file)
	defer render.Close()
	if err != nil {
		return
	}

	data, err := ioutil.ReadAll(render)
	if err != nil {
		return
	}

	cfg := &psConfig{}
	err = json.Unmarshal(data, cfg)
	if err != nil {
		return
	}

	var config *effect.Config
	if cfg.EmitterType == 0 {
		g := &effect.GravityConfig{}
		ref = g
		config = &g.Config
		g.Gravity = f32.Vec2{cfg.GravityX, cfg.GravityY}
		g.Speed = effect.Var{cfg.Speed, cfg.SpeedVar}

		ab, av := math.Radian(cfg.Angle), math.Radian(cfg.AngleVar)
		g.Angel = effect.Var{ab, av}

		g.RadialAcc = effect.Var{cfg.RadialAccel, cfg.RadialAccelVar}
		g.TangentialAcc = effect.Var{cfg.TangentialAccel, cfg.TangentialAccelVar}
		g.RotationIsDir = cfg.RotationIsDir
	} else {
		r := effect.RadiusConfig{}
		ref = r
		config = &r.Config
		r.Radius = effect.Range{
			Start: effect.Var{cfg.StartRadius, cfg.StartRadiusVar},
			End:   effect.Var{cfg.EndRadius, cfg.EndRadiusVar},
		}
		r.Angle = effect.Var{cfg.Angle, cfg.AngleVar}
		//r.AngleDelta = effect.Var{cfg.Angle}
	}

	// shared properties
	config.Max = cfg.MaxParticles
	config.Duration = cfg.Duration
	config.Life = effect.Var{cfg.LifeSpan, cfg.LifeSpanVar}
	config.X = effect.Var{cfg.SourcePositionX, cfg.SourcePositionVarX}
	config.Y = effect.Var{cfg.SourcePositionY, cfg.SourcePositionVarY}

	// size and spin
	config.Size = effect.Range{
		Start: effect.Var{cfg.StartSize, cfg.StartSizeVar},
		End:   effect.Var{cfg.EndSize, cfg.EndSizeVar},
	}
	config.Rot = effect.Range{
		Start: effect.Var{cfg.StartSpin, cfg.StartSpinVar},
		End:   effect.Var{cfg.EndSpin, cfg.EndSpinVar},
	}
	// color
	config.R = effect.Range{
		Start: effect.Var{cfg.StartColorRed, cfg.StartColorVarRed},
		End:   effect.Var{cfg.EndColorRed, cfg.EndColorVarRed},
	}
	config.G = effect.Range{
		Start: effect.Var{cfg.StartColorGreen, cfg.StartColorVarGreen},
		End:   effect.Var{cfg.EndColorGreen, cfg.EndColorVarGreen},
	}
	config.B = effect.Range{
		Start: effect.Var{cfg.StartColorBlue, cfg.StartColorVarBlue},
		End:   effect.Var{cfg.EndColorBlue, cfg.EndColorVarBlue},
	}
	config.A = effect.Range{
		Start: effect.Var{cfg.StartColorAlpha, cfg.StartColorVarAlpha},
		End:   effect.Var{cfg.EndColorAlpha, cfg.EndColorVarAlpha},
	}
	return
}

type psConfig struct {
	ConfigName string `json:"configName"`

	MaxParticles int     `json:"maxParticles"`
	Angle        float32 `json:"angle"`
	AngleVar     float32 `json:"angleVariance"`
	Duration     float32 `json:"duration"`

	// blend-func - not support, now

	// color
	StartColorRed   float32 `json:"startColorRed"`
	StartColorGreen float32 `json:"startColorGreen"`
	StartColorBlue  float32 `json:"startColorBlue"`
	StartColorAlpha float32 `json:"startColorAlpha"`

	StartColorVarRed   float32 `json:"startColorVarianceRed"`
	StartColorVarGreen float32 `json:"startColorVarianceGreen"`
	StartColorVarBlue  float32 `json:"startColorVarianceBlue"`
	StartColorVarAlpha float32 `json:"startColorVarianceAlpha"`

	EndColorRed   float32 `json:"finishColorRed"`
	EndColorGreen float32 `json:"finishColorGreen"`
	EndColorBlue  float32 `json:"finishColorBlue"`
	EndColorAlpha float32 `json:"finishColorAlpha"`

	EndColorVarRed   float32 `json:"finishColorVarianceRed"`
	EndColorVarGreen float32 `json:"finishColorVarianceGreen"`
	EndColorVarBlue  float32 `json:"finishColorVarianceBlue"`
	EndColorVarAlpha float32 `json:"finishColorVarianceAlpha"`

	// size
	StartSize    float32 `json:"startParticleSize"`
	StartSizeVar float32 `json:"startParticleSizeVariance"`
	EndSize      float32 `json:"finishParticleSize"`
	EndSizeVar   float32 `json:"finishParticleSizeVariance"`

	// Position
	SourcePositionX float32 `json:"sourcePositionx"`
	SourcePositionY float32 `json:"sourcePositiony"`

	SourcePositionVarX float32 `json:"sourcePositionVariancex"`
	SourcePositionVarY float32 `json:"sourcePositionVariancey"`

	// Spinning
	StartSpin    float32 `json:"rotationStart"`
	StartSpinVar float32 `json:"rotationStartVariance"`
	EndSpin      float32 `json:"rotationEnd"`
	EndSpinVar   float32 `json:"rotationEndVariance"`

	// life and emission rate
	LifeSpan    float32 `json:"particleLifespan"`
	LifeSpanVar float32 `json:"particleLifespanVariance"`

	// mode
	EmitterType int `json:"emitterType"`

	///////// ModeA

	// gravity
	GravityX float32 `json:"gravityx"`
	GravityY float32 `json:"gravityy"`

	// speed
	Speed    float32 `json:"speed"`
	SpeedVar float32 `json:"speedVariance"`

	// radial acceleration
	RadialAccel    float32 `json:"radialAcceleration"`
	RadialAccelVar float32 `json:"radialAccelVariance"`

	// tangential acceleration
	TangentialAccel    float32 `json:"tangentialAcceleration"`
	TangentialAccelVar float32 `json:"tangentialAccelVariance"`

	// rotation is dir
	RotationIsDir bool `json:"rotationIsDir"`

	////////// ModeB

	// radius
	StartRadius    float32 `json:"maxRadius"`
	StartRadiusVar float32 `json:"maxRadiusVariance"`

	EndRadius    float32 `json:"minRadius"`
	EndRadiusVar float32 `json:"minRadiusVariance"`

	// rotate
	RotatePerSecond    float32 `json:"rotatePerSecond"`
	RotatePerSecondVar float32 `json:"rotatePerSecondVariance"`
}

```

`asset/mshader.go`:

```go
package asset

type ShaderManager struct {
}

func (sm *ShaderManager) GetShaderStr(key string) (string, string) {
	switch key {
	case "dft", "mesh":
		return vertex, color
	case "batch":
		return bVertex, bColor
	}
	return "", ""
}


```

`asset/mtexture.go`:

```go
package asset

import (
	"korok.io/korok/asset/res"
	"korok.io/korok/gfx"
	"korok.io/korok/gfx/bk"

	"encoding/json"
	"errors"
	"fmt"
	"image"
	"io/ioutil"
	"log"
)

type TextureManager struct {
	repo  map[string]idCount
	names map[string]uint32
}

func NewTextureManager() *TextureManager {
	return &TextureManager{
		make(map[string]idCount),
		make(map[string]uint32),
	}
}

// Load loads a single Texture file.
func (tm *TextureManager) Load(file string) {
	var rid, cnt uint16
	if v, ok := tm.repo[file]; ok {
		cnt = v.cnt
		rid = v.rid
	} else {
		// create bk.Texture2D
		id, err := tm.loadTexture(file)
		if err != nil {
			log.Println(err)
		}
		rid = id
	}
	tm.repo[file] = idCount{rid, cnt + 1}
}

// Unload delete raw Texture and any related SubTextures.
func (tm *TextureManager) Unload(file string) {
	if v, ok := tm.repo[file]; ok {
		if v.cnt > 1 {
			tm.repo[file] = idCount{v.rid, v.cnt - 1}
		} else {
			delete(tm.repo, file)
			bk.R.Free(v.rid)
			// maybe it's a atlas, try to delete
			gfx.R.Delete(file)

			log.Println("refCont == 0, delete resoruce!!")
		}
	}
}

// LoadAtlas loads the atlas with a description file.
// The SubTexture can be found by SubTexture's name.
func (tm *TextureManager) LoadAtlas(file, desc string) {
	var rid, cnt uint16
	if v, ok := tm.repo[file]; ok {
		cnt = v.cnt
		rid = v.rid
	} else {
		id, data, err := tm.loadAtlas(file, desc)
		if err != nil {
			log.Println(err)
			return
		}
		size := len(data.Frames)

		// new atlas
		at := gfx.R.NewAtlas(id, size, file)

		// fill
		for _, f := range data.Frames {
			at.AddItem(float32(f.Frame.X), float32(f.Frame.Y), float32(f.Frame.W), float32(f.Frame.H), f.Filename, f.Rotated)
		}
		rid = id
	}
	tm.repo[file] = idCount{rid, cnt + 1}
}

// LoadAtlasIndexed loads the atlas with specified with/height/num.
func (tm *TextureManager) LoadAtlasIndexed(file string, width, height float32, row, col int) {
	var rid, cnt uint16
	if v, ok := tm.repo[file]; ok {
		cnt = v.cnt
		rid = v.rid
	} else {
		id, err := tm.loadTexture(file)
		if err != nil {
			log.Println(err)
		}
		size := row * col

		// new atlas
		at := gfx.R.NewAtlas(id, size, file)

		// fill
		for i := 0; i < row; i++ {
			for j := 0; j < col; j++ {
				at.AddItem(float32(j)*width, float32(i)*height, width, height, "", false)
			}
		}
	}
	tm.repo[file] = idCount{rid, cnt + 1}
}

// Get returns the low-level Texture.
func (tm *TextureManager) Get(file string) gfx.Tex2D {
	rid := tm.repo[file]
	return gfx.NewTex(rid.rid)
}

// Get returns the low-level Texture.
func (tm *TextureManager) GetRaw(file string) (uint16, *bk.Texture2D) {
	if v, ok := tm.repo[file]; ok {
		if ok, tex := bk.R.Texture(v.rid); ok {
			return v.rid, tex
		}
	}
	return bk.InvalidId, nil
}

// Atlas returns the Atlas.
func (tm *TextureManager) Atlas(file string) (at *gfx.Atlas, ok bool) {
	if _, ok1 := tm.repo[file]; ok1 {
		at = gfx.R.Atlas(file)
		ok = at != nil
	}
	return
}

func (tm *TextureManager) loadTexture(file string) (uint16, error) {
	log.Println("load file:" + file)
	// 1. load file
	imgFile, err := res.Open(file)
	if err != nil {
		return bk.InvalidId, fmt.Errorf("texture %q not found: %v", file, err)
	}
	// 2. decode image
	img, _, err := image.Decode(imgFile)
	if err != nil {
		return bk.InvalidId, err
	}
	// 3. create raw texture
	if id, _ := bk.R.AllocTexture(img); id != bk.InvalidId {
		return id, nil
	}
	return bk.InvalidId, errors.New("fail to load texture")
}

// 加载纹理图集
func (tm *TextureManager) loadAtlas(img, desc string) (id uint16, at *atlas, e error) {
	id, err := tm.loadTexture(img)
	if err != nil {
		e = err
		return
	}
	file, err := res.Open(desc)
	defer file.Close()

	if err != nil {
		e = err
		return
	}
	d, err := ioutil.ReadAll(file)
	if err != nil {
		e = err
		return
	}
	at = &atlas{}
	e = json.Unmarshal(d, at)
	return
}

// Field int `json:"myName"`
// The file format is TexturePacker's generic json-array format.
// TexturePacker: https://www.codeandweb.com/texturepacker
type atlas struct {
	Meta struct {
		App     string `json:"app"`
		Version string `json:"version"`
		Image   string `json:"image"`
		Format  string `json:"format"`
		Size    struct {
			W, H int
		} `json:"size"`
		Scale float32 `json:"scale,string"`
	} `json:"meta"`

	Frames []struct {
		Filename string                   `json:"filename"`
		Frame    struct{ X, Y, W, H int } `json:"frame"`
		Rotated  bool                     `json:"rotated"`
		Trimmed  bool                     `json:trimmed`
		Pivot    struct{ X, Y float32 }   `json:"pivot"`
	} `json:"frames"`
}

```

`asset/res/res.go`:

```go
package res

import (
	"io"
)

// File is an open asset.
type File interface {
	io.ReadCloser
	// io.Closer
}

type WFile interface {
	io.Writer
}

```

`asset/res/res_file.go`:

```go
// +build darwin linux windows

package res

import (
	"golang.org/x/mobile/asset"
)

// Open opens a named asset.
func Open(name string) (File, error) {
	return asset.Open(name)
}

```

`asset/res/res_local.go`:

```go
// +build android ios

package res

import (
	"golang.org/x/mobile/asset"
)

// Open opens a named asset.
//
// Errors are of type *os.PathError.
//
// This must not be called from init when used in android apps.
func Open(name string) (File, error) {
	return asset.Open(name)
}

```

`asset/res/res_webgl.go`:

```go
// +build js

package res

import (
	"bytes"
	"fmt"
	"net/http"
	"time"
)

// Open opens a named asset.
func Open(name string) (File, error) {

	client := http.Client{
		Timeout: time.Second * 10,
	}
	resp, err := client.Get(name)
	if err != nil {
		return nil, err
	}
	if resp.StatusCode != 200 {
		resp.Body.Close()
		return nil, fmt.Errorf("resp.StatusCode=%d", resp.StatusCode)
	}
	return resp.Body, nil
}

type wfile struct {
	name string
}

func (wf *wfile) Write(p []byte) (n int, err error) {
	client := http.Client{
		Timeout: time.Second * 10,
	}
	resp, err := client.Post(wf.name, "", bytes.NewReader(p))
	if err != nil {
		return 0, err
	}
	if resp.StatusCode != 200 {
		resp.Body.Close()
		return 0, fmt.Errorf("resp.StatusCode=%d", resp.StatusCode)
	}
	return len(p), nil
}

// Open opens a named asset.
func Create(name string) (WFile, error) {
	return &wfile{name: name}, nil
}

```

`audio/audio.go`:

```go
package audio

import (
	"korok.io/korok/audio/sine"
)

type MusicPlayer struct {
	*sine.StreamPlayer
}

type ChanId int

var (
	music *sine.StreamPlayer
	effects *sine.SoundPool
)

func Init() (err error) {
	sine.Init(DefaultDecoderFactory)
	music   = sine.NewStreamPlayer()
	effects = sine.NewSoundPool()
	return
}

func Destroy() {
	sine.Destroy()
}

func AdvanceFrame() {
	music.Tick()
	effects.Tick()
}

////////////////////// Music ////////////////////

func PlayMusic(id uint16) (sp MusicPlayer, ook bool){
	if sound, ok := sine.R.Sound(id); ok {
		if d, ok := sound.Data.(*sine.StreamData); ok {
			music.Play(d)
			sp, ook = MusicPlayer{music}, true
		}
	}
	return
}

func PauseMusic() {
	music.Pause()
}

func ResumeMusic() {
	music.Resume()
}

func StopMusic() {
	music.Stop()
}

func SetMusicVolume(v float32) {
	music.SetVolume(v)
}

func MusicVolume() float32 {
	return music.Volume()
}

////////////////////// Effect ////////////////////

func PlayEffect(id uint16, priority int) (cid ChanId){
	return ChanId(effects.Play(id, priority))
}

func PauseEffect(cid ChanId) {
	effects.PauseChan(int(cid))
}

func ResumeEffect(cid ChanId) {
	effects.ResumeChan(int(cid))
}

func StopEffect(cid ChanId) {
	effects.StopChan(int(cid))
}

func EffectChannelVolume(cid ChanId) (v float32, ok bool){
	return effects.GetChanVolume(int(cid))
}

func SetEffectChannelVolume(cid ChanId, v float32) {
	effects.SetChanVolume(int(cid), v)
}

// Overall volume setting.
func EffectVolume() float32 {
	return effects.Volume()
}

func SetEffectVolume(v float32) {
	effects.SetVolume(v)
}


// default Audio-File-Decoder
var DefaultDecoderFactory = &decoderFactory{}



```

`audio/decoder.go`:

```go
package audio

import (
	"korok.io/korok/audio/sine"
	"korok.io/korok/audio/wav"
	"korok.io/korok/audio/ogg"

	"fmt"
)

type decoderFactory struct {
}

func (df *decoderFactory) NewDecoder(name string, fileType sine.FileType) (sine.Decoder, error) {
	switch fileType {
	case sine.WAV:
		return NewWavDecoder(name)
	case sine.VORB:
		return NewVorbisDecoder(name)
	}

	return nil, fmt.Errorf("not support file type: %d", fileType)
}

func NewWavDecoder(name string) (sine.Decoder, error) {
	return wav.NewDecoder(name)
}

func NewVorbisDecoder(name string) (sine.Decoder, error) {
	return ogg.NewVorbisDecoder(name)
}

```

`audio/ogg/decoder_opus.go`:

```go
package ogg

// NOT IMPLEMENT YET.

```

`audio/ogg/decoder_vorbis.go`:

```go
package ogg

import (
	"github.com/jfreymuth/oggvorbis"
	"korok.io/korok/asset/res"

	"io"
	"log"
	"unsafe"
)

type Decoder struct {
	numChannels int32
	sampleRate  int32
	bitDepth    int32

	i16buffer []int16
	f32buffer []float32
	size      int

	name     string
	file     res.File
	reader   *oggvorbis.Reader
	reachEnd bool
}

func (d *Decoder) NumOfChan() int32 {
	return d.numChannels
}

func (d *Decoder) BitDepth() int32 {
	return d.bitDepth
}

func (d *Decoder) SampleRate() int32 {
	return d.sampleRate
}

func (d *Decoder) Buffer() []byte {
	return ((*[1 << 30]byte)(unsafe.Pointer(&d.i16buffer[0])))[:d.size*2]
}

func (d *Decoder) ReachEnd() bool {
	return d.reachEnd
}

func (*Decoder) FullDecode(file res.File) (data []byte, numChan, bitDepth, freq int32, err error) {
	floats, format, err := oggvorbis.ReadAll(file)
	if err != nil {
		return
	}
	defer file.Close()

	numChan = int32(format.Channels)
	bitDepth = 16
	freq = int32(format.SampleRate)

	i16s := make([]int16, len(floats))
	f216(floats, i16s)
	ptr := unsafe.Pointer(&i16s[0])
	data = ((*[1 << 30]byte)(ptr))[:len(floats)*2]
	return
}

func (d *Decoder) Decode() int {
	size, err := d.reader.Read(d.f32buffer)
	if err != nil && err != io.EOF {
		log.Println("vorbis decode err:", err)
		return 0
	}
	if io.EOF == err {
		d.reachEnd = true
	}
	f216(d.f32buffer, d.i16buffer)
	d.size = size
	return size
}

func (d *Decoder) head() error {
	if f := d.file; f != nil {
		f.Close()
	}
	f, err := res.Open(d.name)
	if err != nil {
		return err
	}
	r, err := oggvorbis.NewReader(f)
	if err != nil {
		return err
	}

	d.file = f
	d.reader = r
	d.numChannels = int32(r.Channels())
	d.sampleRate = int32(r.SampleRate())
	d.bitDepth = 16
	d.reachEnd = false
	return nil
}

func (d *Decoder) Rewind() {
	d.head()
}

func NewVorbisDecoder(name string) (d *Decoder, err error) {
	d = new(Decoder)
	d.name = name
	d.f32buffer = make([]float32, 16384)
	d.i16buffer = make([]int16, 16384)
	err = d.head()
	return
}

func f216(f32 []float32, i16 []int16) {
	for i, f := range f32 {
		i16[i] = int16(f * 32767)
	}
}

```

`audio/positional.go`:

```go
package audio

// TODO
// positional audio component/system

type SourceComp struct {
	// 音频资源
	Id uint16
	// 优先级
	P  uint16

	// 静音
	Mute bool

	// 循环
	Loop bool

	// 音量 [0, 1]
	Volume float32
}


```

`audio/sine/R.go`:

```go
package sine

import (
	"log"

	"korok.io/korok/asset/res"
)

type FileType uint8

const (
	None FileType = iota
	WAV
	VORB

	// NOT IMPLEMENT YET
	OPUS
	FLAC
)

type SourceType uint8

const (
	Static SourceType = iota
	Stream
)

type FormatEnum uint8

const (
	FormatNone FormatEnum = iota
	Mono8
	Mono16
	Stereo8
	Stereo16
)

// sound represent a audio segment
type Sound struct {
	Type     SourceType
	Priority uint16
	Data     interface{}
}

const MaxSoundPoolSize = 128 // 128=96+32
const MaxStaticData = 96
const MaxStreamData = 32

type AudioManger struct {
	// sound array
	soundPool [MaxSoundPoolSize]Sound

	// data pool
	staticData [MaxStaticData]StaticData
	streamData [MaxStreamData]StreamData

	indexPool   uint16
	indexStatic uint16
	indexStream uint16
	padding     uint16
}

func NewAudioManager() *AudioManger {
	return new(AudioManger)
}

/// 加载数据，得到 Sound 实例
/// 此时应该得出, 采样率，是否Stream等，
func (am *AudioManger) LoadSound(name string, ft FileType, sType SourceType) (id uint16, sound *Sound) {
	id, sound = am.indexPool, &am.soundPool[am.indexPool]
	am.indexPool++
	sound.Type = sType

	var d interface{}
	if sType == Static {
		_, d = am.LoadStatic(name, ft)
	} else {
		_, d = am.LoadStream(name, ft)
	}
	sound.Data = d
	return
}

func (am *AudioManger) LoadStatic(name string, ft FileType) (id uint16, sd *StaticData) {
	d, err := factory.NewDecoder(name, ft)
	if err != nil {
		log.Println(err)
		return
	}
	file, err := res.Open(name)
	if err != nil {
		log.Println(err)
		return
	}
	data, numChan, bitDepth, freq, err := d.FullDecode(file)
	if err != nil {
		log.Println("fail to full decode audio data")
		return
	}
	format := getFormat(numChan, bitDepth)
	if format == FormatNone {
		log.Println("invalid audio format")
		return
	}

	fc := formatCodes[format]
	fc = FormatMono16
	id, sd = am.allocStaticData(fc, data, freq)
	return
}

func (am *AudioManger) LoadStream(name string, ft FileType) (id uint16, data *StreamData) {
	return am.allocStreamData(name, ft)
}

func (am *AudioManger) allocStaticData(fmt uint32, bits []byte, freq int32) (id uint16, data *StaticData) {
	id, data = am.indexStatic, &am.staticData[am.indexStatic]
	am.indexStatic++
	data.Create(fmt, bits, freq)
	return
}

func (am *AudioManger) allocStreamData(name string, ft FileType) (id uint16, data *StreamData) {
	id, data = am.indexStream, &am.streamData[am.indexStream]
	am.indexStream++
	data.Create(name, ft)
	return
}

// TODO!
func (am *AudioManger) freeStatic(id uint16) {
	rear := am.indexStatic - 1
	if id < rear {

	}
}

func (am *AudioManger) UnloadSound(id uint16) {

}

func (am *AudioManger) Sound(id uint16) (sound *Sound, ok bool) {
	if id >= MaxSoundPoolSize {
		return nil, false
	}
	return &am.soundPool[id], true
}

func getFormat(channels, depth int32) FormatEnum {
	var format FormatEnum
	switch {
	case channels == 1 && depth == 8:
		format = Mono8
	case channels == 1 && depth == 16:
		format = Mono16
	case channels == 2 && depth == 8:
		format = Stereo8
	case channels == 2 && depth == 16:
		format = Stereo16
	default:
		format = FormatNone
	}
	return format
}

///////// static and global field
var formatCodes = []uint32{
	0, // none
	FormatMono8,
	FormatMono16,
	FormatStereo8,
	FormatStereo16,
}

```

`audio/sine/bk_al.go`:

```go
//+build !android,!js,!windows

package sine

/*
#cgo darwin   CFLAGS:  -DGOOS_darwin
#cgo linux    CFLAGS:  -DGOOS_linux
#cgo darwin   LDFLAGS: -framework OpenAL
#cgo linux    LDFLAGS: -lopenal


#ifdef GOOS_darwin
#include <stdlib.h>
#include <stdio.h>
#include <OpenAL/al.h>
#include <OpenAL/alc.h>
#endif

typedef struct SineEngine {
	ALCdevice *device;
	ALCcontext *context;
} SineEngine;

ALenum Sine_init(SineEngine *eng) {
	alGetError(); // clear error code
	eng->device = alcOpenDevice(0);
	eng->context = alcCreateContext(eng->device, 0);

	return alGetError();
}

void Sine_wake(SineEngine *eng) {
	alcMakeContextCurrent(eng->context);
	// alcProcessContext(engine.context);
}

void Sine_destroy(SineEngine *eng) {

}

typedef struct SineBufferPlayer {
	ALuint idSource;
} SineBufferPlayer;

ALenum SineBufferPlayer_init(SineBufferPlayer *p) {
	ALuint id;
	alGenSources(1, &id);
	p->idSource = id;
	return alGetError();
}

ALenum SineBufferPlayer_play(SineBufferPlayer *p, ALuint idBuffer) {
	ALuint source = p->idSource;
	alSourcei(source, AL_BUFFER, 0); // do need reset?
	alSourcei(source, AL_BUFFER, idBuffer);
	alSourcePlay(source);
	return alGetError();
}

ALenum SineBufferPlayer_pause(SineBufferPlayer *p) {
	alSourcePause(p->idSource);
	return alGetError();
}

ALenum SineBufferPlayer_stop(SineBufferPlayer *p) {
	alSourceStop(p->idSource);
	return alGetError();
}

// ignore error check for state-checking
ALenum SineBufferPlayer_state(SineBufferPlayer *p) {
 	ALenum state;
 	alGetSourcei(p->idSource, AL_SOURCE_STATE, &state);
 	return state;
}

ALfloat SineBufferPlayer_getVolume(SineBufferPlayer *p) {
	ALfloat v;
	alGetSourcef(p->idSource, AL_GAIN, &v);
	return v;
}

void SineBufferPlayer_setVolume(SineBufferPlayer *p, ALfloat v) {
	alSourcef(p->idSource, AL_GAIN, v);
}

typedef struct SineStreamPlayer {
	ALuint idSource;
	ALuint buffers[8]; //max buffer size
	ALuint numBuffers; //buffer in use
	ALuint freed;      //buffer active
} SineStreamPlayer;

ALenum SineStreamPlayer_init(SineStreamPlayer *p, ALuint numBuffers) {
	ALuint id;
	alGenSources(1, &id);
	p->idSource = id;
	alSourcei(id, AL_LOOPING, AL_FALSE); // stop looping

	p->numBuffers = numBuffers;
	p->freed = numBuffers;
	alGenBuffers(numBuffers, &(p->buffers[0]));

	return alGetError();
}

ALenum SineStreamPlayer_play(SineStreamPlayer *p) {
	alSourcePlay(p->idSource);
	return alGetError();
}


ALenum SineStreamPlayer_stop(SineStreamPlayer *p) {
	alSourceStop(p->idSource);
	return alGetError();
}


ALenum SineStreamPlayer_pause(SineStreamPlayer *p) {
	alSourcePause(p->idSource);
	return alGetError();
}

ALuint SineStreamPlayer_freeBuffer(SineStreamPlayer *p) {
	ALuint source = p->idSource;
	ALuint freed  = p->freed;

	ALint bp;
	alGetSourcei(p->idSource, AL_BUFFERS_PROCESSED, &bp);

	if (bp > 0 ){
		alSourceUnqueueBuffers(source, bp, &(p->buffers[freed]));
		freed += bp;
		p->freed = freed;
	}

	return freed;
}

void SineStreamPlayer_feed(SineStreamPlayer *p, void *data, ALsizei size, ALenum format, ALsizei freq) {
	ALuint source = p->idSource;
	ALuint freed  = p->freed;

	ALuint buffer = p->buffers[freed-1];
	alBufferData(buffer, format, data, size, freq);
	alSourceQueueBuffers(source, 1, &buffer);
	p->freed = freed-1;
}

ALenum SineStreamPlayer_state(SineStreamPlayer *p) {
 	ALenum state;
 	alGetSourcei(p->idSource, AL_SOURCE_STATE, &state);
 	return state;
}


ALfloat SineStreamPlayer_getVolume(SineStreamPlayer *p) {
	ALfloat v;
	alGetSourcef(p->idSource, AL_GAIN, &v);
	return v;
}

void SineStreamPlayer_setVolume(SineStreamPlayer *p, ALfloat v) {
	alSourcef(p->idSource, AL_GAIN, v);
}

// stream play!!

*/
import "C"
import (
	"log"
	"unsafe"
)

// StaticData is small audio sampler, which will be load into memory directly.
type StaticData struct {
	idBuffer C.ALuint
	fmt      uint32
	freq     int32
}

func (d *StaticData) Create(fmt uint32, bits []byte, freq int32) {
	d.fmt = fmt
	d.freq = freq

	C.alGenBuffers(1, &d.idBuffer)
	C.alBufferData(d.idBuffer, C.ALenum(fmt), unsafe.Pointer(&bits[0]), C.ALsizei(len(bits)), C.ALsizei(freq))
}

// StreamData will decode pcm-data at runtime. It's used to play big audio files(like .ogg).
type StreamData struct {
	decoder Decoder
}

func (d *StreamData) Create(file string, ft FileType) {
	decoder, err := factory.NewDecoder(file, ft)
	if err != nil {
		log.Println(err)
		return
	}
	d.decoder = decoder
}

func (d *StreamData) format() FormatEnum {
	return getFormat(d.decoder.NumOfChan(), d.decoder.BitDepth())
}

type Engine struct {
	engine C.SineEngine
}

func (eng *Engine) Initialize() {
	C.Sine_init(&eng.engine)
	C.Sine_wake(&eng.engine)
}

func (eng *Engine) Destroy() {
	C.Sine_destroy(&eng.engine)
}

// BufferPlayer can play audio loaded as StaticData.
type BufferPlayer struct {
	player        C.SineBufferPlayer
	playingBuffer C.ALuint
}

func (p *BufferPlayer) initialize(engine *Engine) {
	if ret := C.SineBufferPlayer_init(&p.player); ret != NoError {
		log.Println("buffer-player init err:", errString(ret))
	}
}

func (p *BufferPlayer) Play(data *StaticData) {
	if ret := C.SineBufferPlayer_play(&p.player, data.idBuffer); ret != NoError {
		log.Println("buffer-player play err:", errString(ret))
	}
}

func (p *BufferPlayer) Stop() {
	if ret := C.SineBufferPlayer_stop(&p.player); ret != NoError {
		log.Println("buffer-player stop err:", errString(ret))
	}
}

func (p *BufferPlayer) Pause() {
	if ret := C.SineBufferPlayer_pause(&p.player); ret != NoError {
		log.Println("buffer-player pause err:", errString(ret))
	}
}

func (p *BufferPlayer) Resume() {
	if ret := C.SineBufferPlayer_play(&p.player, p.playingBuffer); ret != NoError {
		log.Println("buffer-player resume err:", errString(ret))
	}
}

func (p *BufferPlayer) Volume() float32 {
	v := C.SineBufferPlayer_getVolume(&p.player)
	return float32(v)
}

func (p *BufferPlayer) SetVolume(v float32) {
	C.SineBufferPlayer_setVolume(&p.player, C.ALfloat(v))
}

func (p *BufferPlayer) SetLoop(loop int) {

}

func (p *BufferPlayer) State() uint32 {
	st := C.SineBufferPlayer_state(&p.player)
	return uint32(st)
}

// StreamPlayer can play audio loaded as StreamData.
type StreamPlayer struct {
	player C.SineStreamPlayer
	format uint32
	sampleRate int32
	decoder      Decoder
}

func (p *StreamPlayer) initialize(engine *Engine) {
	var (
		numBuffers = C.ALuint(4)
	)
	if ret := C.SineStreamPlayer_init(&p.player, numBuffers); ret != NoError {
		log.Println("stream-player init err:", errString(ret))
	}
}

func (p *StreamPlayer) Play(stream *StreamData) {
	d := stream.decoder
	p.decoder = d
	p.format = formatCodes[stream.format()]
	p.sampleRate = d.SampleRate()
	p.fill()
	// play
	if ret := C.SineStreamPlayer_play(&p.player); ret != NoError {
		log.Println("stream-player play err:", errString(ret))
	}
}

func (p *StreamPlayer) Stop() {
	if ret := C.SineStreamPlayer_stop(&p.player); ret != NoError {
		log.Println("stream-player stop err:", errString(ret))
	}
	if d := p.decoder; d != nil {
		d.Rewind()
	}
	p.decoder = nil
}

func (p *StreamPlayer) Pause() {
	if ret := C.SineStreamPlayer_pause(&p.player); ret != NoError {
		log.Println("stream-player pause err:", errString(ret))
	}
}

func (p *StreamPlayer) Resume() {
	if ret := C.SineStreamPlayer_play(&p.player); ret != NoError {
		log.Println("stream-player resume err:", errString(ret))
	}
}

func (p *StreamPlayer) State() uint32 {
	st := C.SineStreamPlayer_state(&p.player)
	return uint32(st)
}

func (p *StreamPlayer) Volume() float32 {
	v := C.SineStreamPlayer_getVolume(&p.player)
	return float32(v)
}

func (p *StreamPlayer) SetVolume(v float32) {
	C.SineStreamPlayer_setVolume(&p.player, C.ALfloat(v))
}

func (p *StreamPlayer) Tick() {
	p.fill()
}

func (p *StreamPlayer) fill() {
	d := p.decoder
	if d == nil || d.ReachEnd() {
		return // return if no more data
	}

	free := int(C.SineStreamPlayer_freeBuffer(&p.player))
	if free == 0 {
		return // return if no more free buffer
	}

	// feed the free buffer one by one.
	for ;free > 0 ; free-- {
		if n := d.Decode(); n == 0 {
			break
		}
		var (
			buffer = d.Buffer()
			size   = C.ALsizei(len(buffer))
			format = C.ALenum(p.format)
			freq   = C.ALsizei(p.sampleRate)
		)
		C.SineStreamPlayer_feed(&p.player, unsafe.Pointer(&buffer[0]), size, format, freq)
	}
}

func errString(code C.ALenum) string {
	switch code {
	case InvalidName:
		return "invalid name"
	case InvalidEnum:
		return "invalid enum"
	case InvalidValue:
		return "invalid value"
	case InvalidOperation:
		return "invalid operation"
	case OutOfMemory:
		return "out of memory"
	}
	return "unknown"
}

const (
	FormatMono8    = 0x1100
	FormatMono16   = 0x1101
	FormatStereo8  = 0x1102
	FormatStereo16 = 0x1103
)

// AL error
const (
	NoError          = C.AL_NO_ERROR
	InvalidName      = C.AL_INVALID_NAME
	InvalidEnum      = C.AL_INVALID_ENUM
	InvalidValue     = C.AL_INVALID_VALUE
	InvalidOperation = C.AL_INVALID_OPERATION
	OutOfMemory      = C.AL_OUT_OF_MEMORY
)

// AL state
const (
	Initial = 0x1011
	Playing = 0x1012
	Paused  = 0x1013
	Stopped = 0x1014
)
```

`audio/sine/bk_sl.go`:

```go
// +build android,!js

package sine

/*
 #cgo LDFLAGS: -landroid -lOpenSLES

 #include <SLES/OpenSLES.h>
 #include <SLES/OpenSLES_Android.h>

//////////////////// AudioEngine /////////////////////

typedef struct SineEngine {
	SLObjectItf object;
    SLEngineItf interface;
    SLObjectItf outputMixer;
} SineEngine;

SLresult Sine_init(SineEngine *engine) {
	// create engine & realize
	SLresult ret = slCreateEngine(&engine->object, 0, (void*)(0), 0, (void*)(0), (void*)(0));
	if (ret != SL_RESULT_SUCCESS) {
		return ret;
	}
	ret = (*engine->object)->Realize(engine->object, SL_BOOLEAN_FALSE);
	if (ret != SL_RESULT_SUCCESS) {
		return ret;
	}

	// get the engine interface, which is needed in order to create other objects
	ret = (*engine->object)->GetInterface(engine->object, SL_IID_ENGINE, &engine->interface);
	if (ret != SL_RESULT_SUCCESS) {
		return ret;
	}

	// create output mixer & realize
	ret = (*engine->interface)->CreateOutputMix(engine->interface, &engine->outputMixer, 0, 0, 0);
	if (ret != SL_RESULT_SUCCESS) {
		return ret;
	}
	ret = (*engine->outputMixer)->Realize(engine->outputMixer, SL_BOOLEAN_FALSE);
	if (ret != SL_RESULT_SUCCESS) {
		return ret;
	}
	return SL_RESULT_SUCCESS;
}

void Sine_close(SineEngine *engine) {

}

//////////////////// BufferPlayer /////////////////////

typedef struct SineBufferPlayer {
	// data
	SLDataSource audioSrc;
	SLDataSink   audioSink;

	// control
	SLVolumeItf volume;
	SLObjectItf playerObj;
	SLPlayItf   player;

	SLBufferQueueItf bufferQueue;
	SLboolean playing;
} SineBufferPlayer;

void SineBufferPlayer_callback(SLBufferQueueItf aSoundQueue, void* aContext) {
	((SineBufferPlayer*) aContext)->playing = SL_BOOLEAN_FALSE;
}

SLresult SineBufferPlayer_init(SineBufferPlayer *p, SineEngine *engine, SLuint32 numBuffers, SLuint32 numChannels) {
	SLDataLocator_AndroidSimpleBufferQueue locatorBufferQueue = {
		SL_DATALOCATOR_ANDROIDSIMPLEBUFFERQUEUE, numBuffers
	};
	SLDataFormat_PCM format = {
		SL_DATAFORMAT_PCM,
		numChannels,
		SL_SAMPLINGRATE_44_1,
		SL_PCMSAMPLEFORMAT_FIXED_16,
		SL_PCMSAMPLEFORMAT_FIXED_16,
		SL_SPEAKER_FRONT_LEFT|SL_SPEAKER_FRONT_RIGHT,
		SL_BYTEORDER_LITTLEENDIAN
	};

	p->audioSrc.pLocator = &locatorBufferQueue;
	p->audioSrc.pFormat  = &format;

	SLDataLocator_OutputMix outmix = {SL_DATALOCATOR_OUTPUTMIX, engine->outputMixer};
	p->audioSink.pLocator = &outmix;
	p->audioSink.pFormat  = (void*)(0);

	SLInterfaceID ids[2] = {SL_IID_ANDROIDSIMPLEBUFFERQUEUE, SL_IID_VOLUME};
	SLboolean req[2] = {SL_BOOLEAN_TRUE,SL_BOOLEAN_TRUE};

	SLresult ret;
	// create player & realize
	ret = (*engine->interface)->CreateAudioPlayer(engine->interface, &(p->playerObj), &(p->audioSrc), &(p->audioSink), 2, ids, req);
	if (ret != SL_RESULT_SUCCESS) {
		return ret;
	}
	ret = (*p->playerObj)->Realize(p->playerObj, SL_BOOLEAN_FALSE);
	if (ret != SL_RESULT_SUCCESS) {
		return ret;
	}

	// play interface
	ret = (*p->playerObj)->GetInterface(p->playerObj, SL_IID_PLAY, &(p->player));
	if (ret != SL_RESULT_SUCCESS) {
		return ret;
	}

	// create volume & realize
	ret = (*p->playerObj)->GetInterface(p->playerObj, SL_IID_VOLUME, &(p->volume));
	if (ret != SL_RESULT_SUCCESS) {
		return ret;
	}
	ret = (*p->playerObj)->GetInterface(p->playerObj, SL_IID_ANDROIDSIMPLEBUFFERQUEUE, &(p->bufferQueue));
	if (ret != SL_RESULT_SUCCESS) {
		return ret;
	}
	return SL_RESULT_SUCCESS;
}

void SineBufferPlayer_close(SineBufferPlayer *p) {
	(*p->playerObj)->Destroy(p->playerObj);
}

SLresult SineBufferPlayer_play(SineBufferPlayer *p, void* buffer, SLuint32 size) {
	// enqueue data
	SLresult ret;
	ret = (*p->bufferQueue)->Enqueue(p->bufferQueue, buffer, size);
	if (ret != SL_RESULT_SUCCESS) {
		return ret;
	}
	// play
	ret = (*p->player)->SetPlayState(p->player, SL_PLAYSTATE_PLAYING);
	if (ret != SL_RESULT_SUCCESS) {
		return ret;
	}
	p->playing = SL_BOOLEAN_TRUE;
	return SL_RESULT_SUCCESS;
}

SLresult SineBufferPlayer_stop(SineBufferPlayer *p) {
	return (*p->player)->SetPlayState(p->player, SL_PLAYSTATE_STOPPED);
}

SLresult SineBufferPlayer_pause(SineBufferPlayer *p) {
	return (*p->player)->SetPlayState(p->player, SL_PLAYSTATE_PAUSED);
}

SLresult SineBufferPlayer_resume(SineBufferPlayer *p) {
	return (*p->player)->SetPlayState(p->player, SL_PLAYSTATE_PLAYING);
}

SLresult SineBufferPlayer_queueCount(SineBufferPlayer *p, SLuint32 *count) {
	SLresult ret;
	SLBufferQueueState qState;
	ret = (*p->bufferQueue)->GetState(p->bufferQueue, &qState);
	*count = qState.count;
	return ret;
}

SLresult SineBufferPlayer_state(SineBufferPlayer *p, SLuint32 *state) {
	return (*p->player)->GetPlayState(p->player, state);
}

// unit: db
SLresult SineBufferPlayer_setVolume(SineBufferPlayer *p, SLmillibel v) {
	return (*p->volume)->SetVolumeLevel(p->volume, v);
}

SLresult SineBufferPlayer_getVolume(SineBufferPlayer *p, SLmillibel *v) {
	return (*p->volume)->GetVolumeLevel(p->volume, v);
}

//////////////////// StreamPlayer /////////////////////

typedef struct SineBuffer {
	void *data;
	SLuint32 size;
} SineBuffer;

typedef struct SineStreamPlayer {
	// data
	SLDataSource audioSrc;
	SLDataSink   audioSink;

	// control
	SLVolumeItf volume;
	SLObjectItf playerObj;
	SLPlayItf   player;

	// queue and buffer
	SLBufferQueueItf bufferQueue;
	SineBuffer buffers[8]; //max free buffers
	SLuint32 numBuffers;   //buffer in use
	SLuint32 freed;        //freed buffers
} SineStreamPlayer;

// just increase free buffer
void SineStreamPlayer_callback(SLBufferQueueItf aSoundQueue, void* aContext) {
	((SineStreamPlayer*) aContext)->freed += 1;
}

SLresult SineStreamPlayer_init(SineStreamPlayer *p, SineEngine *engine, SLuint32 numBuffers, SLuint32 numChannels) {
	SLDataLocator_AndroidSimpleBufferQueue locatorBufferQueue = {
		SL_DATALOCATOR_ANDROIDSIMPLEBUFFERQUEUE, numBuffers
	};
	SLDataFormat_PCM format = {
		SL_DATAFORMAT_PCM,
		numChannels,
		SL_SAMPLINGRATE_44_1,
		SL_PCMSAMPLEFORMAT_FIXED_16,
		SL_PCMSAMPLEFORMAT_FIXED_16,
		SL_SPEAKER_FRONT_LEFT|SL_SPEAKER_FRONT_RIGHT,
		SL_BYTEORDER_LITTLEENDIAN
	};

	p->audioSrc.pLocator = &locatorBufferQueue;
	p->audioSrc.pFormat  = &format;

	SLDataLocator_OutputMix outmix = {SL_DATALOCATOR_OUTPUTMIX, engine->outputMixer};
	p->audioSink.pLocator = &outmix;
	p->audioSink.pFormat  = (void*)(0);

	SLInterfaceID ids[2] = {SL_IID_ANDROIDSIMPLEBUFFERQUEUE, SL_IID_VOLUME};
	SLboolean req[2] = {SL_BOOLEAN_TRUE,SL_BOOLEAN_TRUE};

	SLresult ret;
	// create player & realize
	ret = (*engine->interface)->CreateAudioPlayer(engine->interface, &(p->playerObj), &(p->audioSrc), &(p->audioSink), 2, ids, req);
	if (ret != SL_RESULT_SUCCESS) {
		return ret;
	}
	ret = (*p->playerObj)->Realize(p->playerObj, SL_BOOLEAN_FALSE);
	if (ret != SL_RESULT_SUCCESS) {
		return ret;
	}

	// play interface
	ret = (*p->playerObj)->GetInterface(p->playerObj, SL_IID_PLAY, &(p->player));
	if (ret != SL_RESULT_SUCCESS) {
		return ret;
	}

	// create volume & realize
	ret = (*p->playerObj)->GetInterface(p->playerObj, SL_IID_VOLUME, &(p->volume));
	if (ret != SL_RESULT_SUCCESS) {
		return ret;
	}

	// setup buffer queue
	ret = (*p->playerObj)->GetInterface(p->playerObj, SL_IID_ANDROIDSIMPLEBUFFERQUEUE, &(p->bufferQueue));
	if (ret != SL_RESULT_SUCCESS) {
		return ret;
	}
	p->numBuffers = numBuffers;
	p->freed      = numBuffers;

	// register callback
	ret = (*p->bufferQueue)->RegisterCallback(p->bufferQueue, SineStreamPlayer_callback, p);
	if (ret != SL_RESULT_SUCCESS) {
		return ret;
	}
	return SL_RESULT_SUCCESS;
}

void SineStreamPlayer_feed(SineStreamPlayer *p, void* data, SLuint32 size) {
	SLuint32 freed = p->freed;
	if (freed <= 0) {
		return;
	}
	(*p->bufferQueue)->Enqueue(p->bufferQueue, data, size);
	p->freed = freed - 1;
}

void SineStreamPlayer_close(SineStreamPlayer *p) {
	(*p->playerObj)->Destroy(p->playerObj);
}

SLresult SineStreamPlayer_play(SineStreamPlayer *p) {
	return (*p->player)->SetPlayState(p->player, SL_PLAYSTATE_PLAYING);
}

SLresult SineStreamPlayer_stop(SineStreamPlayer *p) {
	return (*p->player)->SetPlayState(p->player, SL_PLAYSTATE_STOPPED);
}

SLresult SineStreamPlayer_pause(SineStreamPlayer *p) {
	return  (*p->player)->SetPlayState(p->player, SL_PLAYSTATE_PAUSED);
}

SLresult SineStreamPlayer_queueCount(SineStreamPlayer *p, SLuint32 *count) {
	SLresult ret;
	SLBufferQueueState qState;
	ret = (*p->bufferQueue)->GetState(p->bufferQueue, &qState);
	*count = qState.count;
	return ret;
}

SLresult SineStreamPlayer_state(SineStreamPlayer *p, SLuint32 *state) {
	return (*p->player)->GetPlayState(p->player, state);
}

// unit: db
SLresult SineStreamPlayer_setVolume(SineStreamPlayer *p, SLmillibel v) {
	return (*p->volume)->SetVolumeLevel(p->volume, v);
}

SLresult SineStreamPlayer_getVolume(SineStreamPlayer *p, SLmillibel *v) {
	return (*p->volume)->GetVolumeLevel(p->volume, v);
}

 */
import "C"
import (
	//"unsafe"
	//"log"
	"log"
	//"unsafe"
	//"unsafe"
	"unsafe"
	"math"
)

// StaticData is small audio sampler, which will be load into memory directly.
type StaticData struct {
	bits []byte
	fmt uint32
	freq int32
}

func (d *StaticData) Create(fmt uint32, bits []byte, freq int32) {
	d.fmt = fmt
	d.bits = bits
	d.freq = freq
}

// StreamData will decode pcm-data at runtime. It's used to play big audio files(like .ogg).
type StreamData struct {
	decoder Decoder
}

func (d *StreamData) Create(file string, ft FileType) {
	decoder, err := factory.NewDecoder(file, ft)
	if err != nil {
		log.Println(err)
		return
	}
	d.decoder = decoder
}

type Engine struct {
	engine C.SineEngine
}

func (eng *Engine) Initialize() {
	if ret := C.Sine_init(&eng.engine); ret != OK {
		log.Println("fail to initialize opensl")
	}
}

func (eng *Engine) Destroy() {
	C.Sine_close(&eng.engine)
}

// BufferPlayer can play audio loaded as StaticData.
type BufferPlayer struct {
	player C.SineBufferPlayer
	volume float32
	state int
}

func (p *BufferPlayer) initialize(engine *Engine) {
	var (
		numBuffers = C.SLuint32(2)
		numChannels = C.SLuint32(2)
	)
	if ret := C.SineBufferPlayer_init(&p.player, &engine.engine, numBuffers, numChannels); ret != OK {
		log.Println("buffer-player init err:", ret)
	}
}

func (p *BufferPlayer) destroy() {
	C.SineBufferPlayer_close(&p.player)
}

func (p *BufferPlayer) Play(d *StaticData) {
	p.state = Playing
	if ret := C.SineBufferPlayer_play(&p.player, unsafe.Pointer(&d.bits[0]), C.SLuint32(len(d.bits))); ret != OK {
		log.Println("buffer-player play err:", ret)
	}
}

func (p *BufferPlayer) Stop() {
	p.state = Stopped
	if ret := C.SineBufferPlayer_stop(&p.player); ret != OK {
		log.Println("buffer-player stop err:", ret)
	}
}

func (p *BufferPlayer) Pause() {
	p.state = Paused
	if ret := C.SineBufferPlayer_pause(&p.player); ret != OK {
		log.Println("buffer-player pause err:", ret)
	}
}

func (p *BufferPlayer) Resume() {
	p.state = Playing
	if ret := C.SineBufferPlayer_resume(&p.player); ret != OK {
		log.Println("buffer-player resume err:", ret)
	}
}

// OpenSL's state is different from OpenAL. In OpenAL, if buffer
// queue exhausted, OpenAL will issue a 'Stop' state. But in SL,
// buffer-queue has nothing to do with player state. It' still
// playing even though queue exhausted.


func (p *BufferPlayer) State() int {
	if st := p.state; st != Playing {
		return st
	}
	ct := C.SLuint32(0)
	if ret := C.SineBufferPlayer_queueCount(&p.player, &ct); ret != OK {
		log.Print("buffer state err:", ret)
		return Initial
	}
	if ct == 0 {
		return Stopped
	}
	return Playing
}

func (p *BufferPlayer) Volume() float32 {
	return p.volume
}

func (p *BufferPlayer) SetVolume(v float32) {
	p.volume = v
	f := math.Log10(float64(v)) * 2000
	if ret := C.SineBufferPlayer_setVolume(&p.player, C.SLmillibel(f)); ret != OK {
		log.Print("stream-player set volume err:", ret)
	}
}

func (p *BufferPlayer) SetLoop(n int) {

}

// StreamPlayer can play audio loaded as StreamData.
type StreamPlayer struct {
	player C.SineStreamPlayer
	decoder      Decoder
	volume float32
	state int
}

func (p *StreamPlayer) initialize(engine *Engine) {
	var (
		numBuffers = C.SLuint32(2)
		numChannels = C.SLuint32(2)
	)
	if ret := C.SineStreamPlayer_init(&p.player, &engine.engine, numBuffers, numChannels); ret != OK {
		log.Println("stream-player init err:", ret)
	}
	p.volume = 1
}

func (p *StreamPlayer) Play(d *StreamData) {
	p.decoder = d.decoder
	p.fill()
	p.state = Playing
	// play
	if ret := C.SineStreamPlayer_play(&p.player); ret != OK {
		log.Println("stream-player play err:", ret)
	}
}

func (p *StreamPlayer) Stop() {
	p.state = Stopped
	if ret := C.SineStreamPlayer_stop(&p.player); ret != OK {
		log.Println("stream-player stop err:", ret)
	}
	if d := p.decoder; d != nil {
		d.Rewind()
	}
	p.decoder = nil
}

func (p *StreamPlayer) Pause() {
	p.state = Paused
	if ret := C.SineStreamPlayer_pause(&p.player); ret != OK {
		log.Println("stream-player pause err:", ret)
	}
}

func (p *StreamPlayer) Resume() {
	p.state = Playing
	if ret := C.SineStreamPlayer_play(&p.player); ret != OK {
		log.Println("stream-player resume err:", ret)
	}
}

func (p *StreamPlayer) State() int {
	if st := p.state; st != Playing {
		return st
	}
	ct := C.SLuint32(0)
	if ret := C.SineStreamPlayer_queueCount(&p.player, &ct); ret != OK {
		log.Print("buffer state err:", ret)
		return Initial
	}
	if ct == 0 {
		return Stopped
	}
	return Playing
}

func (p *StreamPlayer) Volume() float32 {
	return p.volume
}

func (p *StreamPlayer) SetVolume(v float32) {
	var db C.SLmillibel
	if v > 0 {
		p.volume = v
		db = C.SLmillibel(math.Log10(float64(v))*2000)
	} else {
		p.volume = 0
		db = C.SL_MILLIBEL_MIN
	}
	if ret := C.SineStreamPlayer_setVolume(&p.player, db); ret != OK {
		log.Print("stream-player set volume err:", ret)
	}
}

func (p *StreamPlayer) Tick() {
	p.fill()
}

func (p *StreamPlayer) fill() {
	d := p.decoder
	if d == nil || d.ReachEnd() {
		return // return if no more data
	}

	free := int(p.player.freed)
	if free == 0 {
		return // return if no more free buffer
	}

	// feed the free buffer one by one.
	for ;free > 0 ; free-- {
		if n := d.Decode(); n == 0 {
			break
		}
		var (
			buffer = d.Buffer()
			size   = C.SLuint32(len(buffer))
		)
		C.SineStreamPlayer_feed(&p.player, unsafe.Pointer(&buffer[0]), size)
	}
}

const (
	FormatMono8    = 0x1100
	FormatMono16   = 0x1101
	FormatStereo8  = 0x1102
	FormatStereo16 = 0x1103
)

const (
	OK = C.SL_RESULT_SUCCESS
)

const (
	Initial = 0x0
	Playing = C.SL_PLAYSTATE_PLAYING
	Paused  = C.SL_PLAYSTATE_PAUSED
	Stopped = C.SL_PLAYSTATE_STOPPED
)



```

`audio/sine/bk_webgl.go`:

```go
// Copyright 2017 Hajime Hoshi
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// vanishs 修改于github.com/hajimehoshi/oto

//+build js

package sine

import (
	"log"
	"time"

	"syscall/js"

	"korok.io/korok/hid"
)

type driver struct {
	sampleRate      int
	channelNum      int
	bitDepthInBytes int
	nextPos         float64
	tmp             []byte
	bufferSize      int
	context         js.Value
	lastTime        float64
	lastAudioTime   float64
	ready           bool
	bytesPerSecond  int
}

const audioBufferSamples = 3200

func max(a, b int) int {
	if a < b {
		return b
	}
	return a
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

func newDriver(sampleRate, channelNum, bitDepthInBytes, bufferSize int) (*driver, error) {

	p := &driver{
		sampleRate:      sampleRate,
		channelNum:      channelNum,
		bitDepthInBytes: bitDepthInBytes,
		context:         hid.AudioCtx,
		bufferSize:      max(bufferSize, audioBufferSamples*channelNum*bitDepthInBytes),
		bytesPerSecond:  sampleRate * channelNum * bitDepthInBytes,
	}

	// setCallback := func(event string) {
	// 	var f js.Func
	// 	f = js.FuncOf(func(this js.Value, args []js.Value) interface{} {
	// 		if !p.ready {
	// 			p.context.Call("resume")
	// 			p.ready = true
	// 		}
	// 		js.Global().Get("document").Call("removeEventListener", event, f)
	// 		return nil
	// 	})
	// 	js.Global().Get("document").Call("addEventListener", event, f)

	// }

	// // Browsers require user interaction to start the audio.
	// // https://developers.google.com/web/updates/2017/09/autoplay-policy-changes#webaudio
	// setCallback("touchend")
	// setCallback("keyup")
	// setCallback("mouseup")
	return p, nil
}

func toLR(data []byte) ([]float32, []float32) {
	const max = 1 << 15

	l := make([]float32, len(data)/4)
	r := make([]float32, len(data)/4)
	for i := 0; i < len(data)/4; i++ {
		l[i] = float32(int16(data[4*i])|int16(data[4*i+1])<<8) / max
		r[i] = float32(int16(data[4*i+2])|int16(data[4*i+3])<<8) / max
	}
	return l, r
}

func nowInSeconds() float64 {
	return js.Global().Get("performance").Call("now").Float() / 1000.0
}

func (p *driver) TryWrite(data []byte) (int, error) {
	// if !p.ready {
	// 	return 0, nil
	// }

	n := min(len(data), max(0, p.bufferSize-len(p.tmp)))
	p.tmp = append(p.tmp, data[:n]...)

	c := p.context.Get("currentTime").Float()
	now := nowInSeconds()

	if p.lastTime != 0 && p.lastAudioTime != 0 && p.lastAudioTime >= c && p.lastTime != now {
		// Unfortunately, currentTime might not be precise enough on some devices
		// (e.g. Android Chrome). Adjust the audio time with OS clock.
		c = p.lastAudioTime + now - p.lastTime
	}

	p.lastAudioTime = c
	p.lastTime = now

	if p.nextPos < c {
		p.nextPos = c
	}

	// It's too early to enqueue a buffer.
	// Highly likely, there are two playing buffers now.
	if c+float64(p.bufferSize/p.bitDepthInBytes/p.channelNum)/float64(p.sampleRate) < p.nextPos {
		return n, nil
	}

	le := audioBufferSamples * p.bitDepthInBytes * p.channelNum
	if len(p.tmp) < le {
		return n, nil
	}

	buf := p.context.Call("createBuffer", p.channelNum, audioBufferSamples, p.sampleRate)
	l, r := toLR(p.tmp[:le])
	tl := js.TypedArrayOf(l)
	tr := js.TypedArrayOf(r)
	if buf.Get("copyToChannel") != js.Undefined() {
		buf.Call("copyToChannel", tl, 0, 0)
		buf.Call("copyToChannel", tr, 1, 0)
	} else {
		// copyToChannel is not defined on Safari 11
		buf.Call("getChannelData", 0).Call("set", tl)
		buf.Call("getChannelData", 1).Call("set", tr)
	}
	tl.Release()
	tr.Release()

	s := p.context.Call("createBufferSource")
	s.Set("buffer", buf)
	s.Call("connect", p.context.Get("destination"))
	s.Call("start", p.nextPos)
	p.nextPos += buf.Get("duration").Float()

	p.tmp = p.tmp[le:]
	return n, nil
}

func (p *driver) Close() error {
	return nil
}

///////////////////////////////

// StaticData is small audio sampler, which will be load into memory directly.
type StaticData struct {
	bits []byte
	fmt  uint32
	freq int32
}

func (d *StaticData) Create(fmt uint32, bits []byte, freq int32) {
	d.fmt = fmt
	d.bits = bits
	d.freq = freq
}

// StreamData will decode pcm-data at runtime. It's used to play big audio files(like .ogg).
type StreamData struct {
	decoder Decoder
}

func (d *StreamData) Create(file string, ft FileType) {
	decoder, err := factory.NewDecoder(file, ft)
	if err != nil {
		log.Println(err)
		return
	}
	d.decoder = decoder
}

type Engine struct {
	d *driver
}

func (eng *Engine) Initialize() {
	var err error
	eng.d, err = newDriver(44100, 2, 2, 4096)
	if err != nil {
		panic(err)
	}
}

func (eng *Engine) Destroy() {
	err := eng.d.Close()
	if err != nil {
		panic(err)
	}
}

// BufferPlayer can play audio loaded as StaticData.
type BufferPlayer struct {
	engine *Engine
	status uint32
}

func (p *BufferPlayer) initialize(engine *Engine) {
	p.engine = engine
	p.status = Stopped
}

func (p *BufferPlayer) Play(data *StaticData) {
	go func() {
		written := 0
		buf := data.bits
		for len(buf) > 0 {
			// if d.driver == nil {
			// 	return written, errClosed
			// }
			n, _ := engine.d.TryWrite(buf)
			written += n
			// if err != nil {
			// 	return written, err
			// }
			buf = buf[n:]
			// When not all buf is written, the underlying buffer is full.
			// Mitigate the busy loop by sleeping (#10).
			if len(buf) > 0 {
				t := time.Second * time.Duration(engine.d.bufferSize) / time.Duration(engine.d.bytesPerSecond) / 8
				time.Sleep(t)
			}
		}
	}()

	// engine.d.TryWrite(data.bits)
}

func (p *BufferPlayer) Stop() {

}

func (p *BufferPlayer) Pause() {

}

func (p *BufferPlayer) Resume() {

}

func (p *BufferPlayer) Volume() float32 {
	return 0
}

func (p *BufferPlayer) SetVolume(v float32) {
}

func (p *BufferPlayer) SetLoop(loop int) {

}

func (p *BufferPlayer) State() uint32 {
	return p.status
}

// StreamPlayer can play audio loaded as StreamData.
type StreamPlayer struct {
	engine  *Engine
	status  uint32
	feed    chan []byte
	decoder Decoder
}

func (p *StreamPlayer) initialize(engine *Engine) {
	p.engine = engine
	p.status = Stopped
	p.feed = make(chan []byte, 128)
}

func (p *StreamPlayer) Play(stream *StreamData) {
	p.decoder = stream.decoder
	p.fill()
	go func() {

		for {

			written := 0
			buf := <-p.feed
			for len(buf) > 0 {
				// if d.driver == nil {
				// 	return written, errClosed
				// }
				n, _ := engine.d.TryWrite(buf)
				written += n
				// if err != nil {
				// 	return written, err
				// }
				buf = buf[n:]
				// When not all buf is written, the underlying buffer is full.
				// Mitigate the busy loop by sleeping (#10).
				if len(buf) > 0 {
					t := time.Second * time.Duration(engine.d.bufferSize) / time.Duration(engine.d.bytesPerSecond) / 8
					time.Sleep(t)
				}
			}
		}

	}()
}

func (p *StreamPlayer) fill() {
	d := p.decoder
	if d == nil || d.ReachEnd() {
		return // return if no more data
	}

	// feed the free buffer one by one.
	for {
		if n := d.Decode(); n == 0 {
			break
		}
		// var (
		// 	buffer = d.Buffer()
		// 	size   = C.SLuint32(len(buffer))
		// )
		// C.SineStreamPlayer_feed(&p.player, unsafe.Pointer(&buffer[0]), size)

		p.feed <- d.Buffer()
	}
}

func (p *StreamPlayer) Stop() {

}

func (p *StreamPlayer) Pause() {
}

func (p *StreamPlayer) Resume() {

}

func (p *StreamPlayer) State() uint32 {
	return p.status
}

func (p *StreamPlayer) Volume() float32 {
	return 0
}

func (p *StreamPlayer) SetVolume(v float32) {
}

func (p *StreamPlayer) Tick() {
	p.fill()
}

const (
	FormatMono8    = 0x1100
	FormatMono16   = 0x1101
	FormatStereo8  = 0x1102
	FormatStereo16 = 0x1103
)

// AL error
const ()

// AL state
const (
	Initial = 0x1011
	Playing = 0x1012
	Paused  = 0x1013
	Stopped = 0x1014
)

```

`audio/sine/bk_windows.go`:

```go
// Copyright 2017 Hajime Hoshi
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// vanishs 修改于github.com/hajimehoshi/oto

//+build windows

package sine

import (
	"errors"
	"fmt"
	"log"
	"runtime"
	"time"
	"unsafe"

	"golang.org/x/sys/windows"
)

var (
	winmm = windows.NewLazySystemDLL("winmm")
)

var (
	procWaveOutOpen          = winmm.NewProc("waveOutOpen")
	procWaveOutClose         = winmm.NewProc("waveOutClose")
	procWaveOutPrepareHeader = winmm.NewProc("waveOutPrepareHeader")
	procWaveOutWrite         = winmm.NewProc("waveOutWrite")
)

type wavehdr struct {
	lpData          uintptr
	dwBufferLength  uint32
	dwBytesRecorded uint32
	dwUser          uintptr
	dwFlags         uint32
	dwLoops         uint32
	lpNext          uintptr
	reserved        uintptr
}

type waveformatex struct {
	wFormatTag      uint16
	nChannels       uint16
	nSamplesPerSec  uint32
	nAvgBytesPerSec uint32
	nBlockAlign     uint16
	wBitsPerSample  uint16
	cbSize          uint16
}

const (
	waveFormatPCM = 1
	whdrInqueue   = 16
)

type mmresult uint

const (
	mmsyserrNoerror       mmresult = 0
	mmsyserrError         mmresult = 1
	mmsyserrBaddeviceid   mmresult = 2
	mmsyserrAllocated     mmresult = 4
	mmsyserrInvalidhandle mmresult = 5
	mmsyserrNodriver      mmresult = 6
	mmsyserrNomem         mmresult = 7
	waveerrBadformat      mmresult = 32
	waveerrStillplaying   mmresult = 33
	waveerrUnprepared     mmresult = 34
	waveerrSync           mmresult = 35
)

func (m mmresult) String() string {
	switch m {
	case mmsyserrNoerror:
		return "MMSYSERR_NOERROR"
	case mmsyserrError:
		return "MMSYSERR_ERROR"
	case mmsyserrBaddeviceid:
		return "MMSYSERR_BADDEVICEID"
	case mmsyserrAllocated:
		return "MMSYSERR_ALLOCATED"
	case mmsyserrInvalidhandle:
		return "MMSYSERR_INVALIDHANDLE"
	case mmsyserrNodriver:
		return "MMSYSERR_NODRIVER"
	case mmsyserrNomem:
		return "MMSYSERR_NOMEM"
	case waveerrBadformat:
		return "WAVEERR_BADFORMAT"
	case waveerrStillplaying:
		return "WAVEERR_STILLPLAYING"
	case waveerrUnprepared:
		return "WAVEERR_UNPREPARED"
	case waveerrSync:
		return "WAVEERR_SYNC"
	}
	return fmt.Sprintf("MMRESULT (%d)", m)
}

type winmmError struct {
	fname    string
	errno    windows.Errno
	mmresult mmresult
}

func (e *winmmError) Error() string {
	if e.errno != 0 {
		return fmt.Sprintf("winmm error at %s: Errno: %d", e.fname, e.errno)
	}
	if e.mmresult != mmsyserrNoerror {
		return fmt.Sprintf("winmm error at %s: %s", e.fname, e.mmresult)
	}
	return fmt.Sprintf("winmm error at %s", e.fname)
}

func waveOutOpen(f *waveformatex) (uintptr, error) {
	const (
		waveMapper   = 0xffffffff
		callbackNull = 0
	)
	var w uintptr
	r, _, e := procWaveOutOpen.Call(uintptr(unsafe.Pointer(&w)), waveMapper, uintptr(unsafe.Pointer(f)),
		0, 0, callbackNull)
	runtime.KeepAlive(f)
	if e.(windows.Errno) != 0 {
		return 0, &winmmError{
			fname: "waveOutOpen",
			errno: e.(windows.Errno),
		}
	}
	if mmresult(r) != mmsyserrNoerror {
		return 0, &winmmError{
			fname:    "waveOutOpen",
			mmresult: mmresult(r),
		}
	}
	return w, nil
}

func waveOutClose(hwo uintptr) error {
	r, _, e := procWaveOutClose.Call(hwo)
	if e.(windows.Errno) != 0 {
		return &winmmError{
			fname: "waveOutClose",
			errno: e.(windows.Errno),
		}
	}
	// WAVERR_STILLPLAYING is ignored.
	if mmresult(r) != mmsyserrNoerror && mmresult(r) != waveerrStillplaying {
		return &winmmError{
			fname:    "waveOutClose",
			mmresult: mmresult(r),
		}
	}
	return nil
}

func waveOutPrepareHeader(hwo uintptr, pwh *wavehdr) error {
	r, _, e := procWaveOutPrepareHeader.Call(hwo, uintptr(unsafe.Pointer(pwh)), unsafe.Sizeof(wavehdr{}))
	runtime.KeepAlive(pwh)
	if e.(windows.Errno) != 0 {
		return &winmmError{
			fname: "waveOutPrepareHeader",
			errno: e.(windows.Errno),
		}
	}
	if mmresult(r) != mmsyserrNoerror {
		return &winmmError{
			fname:    "waveOutPrepareHeader",
			mmresult: mmresult(r),
		}
	}
	return nil
}

func waveOutWrite(hwo uintptr, pwh *wavehdr) error {
	r, _, e := procWaveOutWrite.Call(hwo, uintptr(unsafe.Pointer(pwh)), unsafe.Sizeof(wavehdr{}))
	runtime.KeepAlive(pwh)
	if e.(windows.Errno) != 0 {
		return &winmmError{
			fname: "waveOutWrite",
			errno: e.(windows.Errno),
		}
	}
	if mmresult(r) != mmsyserrNoerror {
		return &winmmError{
			fname:    "waveOutWrite",
			mmresult: mmresult(r),
		}
	}
	return nil
}

type header struct {
	buffer  []byte
	waveHdr *wavehdr
}

func newHeader(waveOut uintptr, bufferSize int) (*header, error) {
	h := &header{
		buffer: make([]byte, bufferSize),
	}
	h.waveHdr = &wavehdr{
		lpData:         uintptr(unsafe.Pointer(&h.buffer[0])),
		dwBufferLength: uint32(bufferSize),
	}
	if err := waveOutPrepareHeader(waveOut, h.waveHdr); err != nil {
		return nil, err
	}
	return h, nil
}

func (h *header) Write(waveOut uintptr, data []byte) error {
	if len(data) != len(h.buffer) {
		return errors.New("oto: len(data) must equal to len(h.buffer)")
	}
	copy(h.buffer, data)
	if err := waveOutWrite(waveOut, h.waveHdr); err != nil {
		return err
	}
	return nil
}

type driver struct {
	out            uintptr
	headers        []*header
	tmp            []byte
	bufferSize     int
	bytesPerSecond int
}

func newDriver(sampleRate, channelNum, bitDepthInBytes, bufferSizeInBytes int) (*driver, error) {
	numBlockAlign := channelNum * bitDepthInBytes
	f := &waveformatex{
		wFormatTag:      waveFormatPCM,
		nChannels:       uint16(channelNum),
		nSamplesPerSec:  uint32(sampleRate),
		nAvgBytesPerSec: uint32(sampleRate * numBlockAlign),
		wBitsPerSample:  uint16(bitDepthInBytes * 8),
		nBlockAlign:     uint16(numBlockAlign),
	}
	w, err := waveOutOpen(f)
	if err != nil {
		return nil, err
	}

	const numBufs = 2
	p := &driver{
		out:            w,
		headers:        make([]*header, numBufs),
		bufferSize:     bufferSizeInBytes,
		bytesPerSecond: sampleRate * channelNum * bitDepthInBytes,
	}
	runtime.SetFinalizer(p, (*driver).Close)
	for i := range p.headers {
		var err error
		p.headers[i], err = newHeader(w, p.bufferSize)
		if err != nil {
			return nil, err
		}
	}
	return p, nil
}

func (p *driver) TryWrite(data []byte) (int, error) {
	n := min(len(data), max(0, p.bufferSize-len(p.tmp)))
	p.tmp = append(p.tmp, data[:n]...)
	if len(p.tmp) < p.bufferSize {
		return n, nil
	}

	var headerToWrite *header
	for _, h := range p.headers {
		// TODO: Need to check WHDR_DONE?
		if h.waveHdr.dwFlags&whdrInqueue == 0 {
			headerToWrite = h
			break
		}
	}
	if headerToWrite == nil {
		return n, nil
	}

	if err := headerToWrite.Write(p.out, p.tmp); err != nil {
		// This error can happen when e.g. a new HDMI connection is detected (#51).
		const errorNotFound = 1168
		werr := err.(*winmmError)
		if werr.fname == "waveOutWrite" && werr.errno == errorNotFound {
			return 0, nil
		}
		return 0, err
	}

	p.tmp = nil
	return n, nil
}

func (p *driver) Close() error {
	runtime.SetFinalizer(p, nil)
	// TODO: Call waveOutUnprepareHeader here
	if err := waveOutClose(p.out); err != nil {
		return err
	}
	return nil
}

func max(a, b int) int {
	if a < b {
		return b
	}
	return a
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

///////////////////////////////

// StaticData is small audio sampler, which will be load into memory directly.
type StaticData struct {
	bits []byte
	fmt  uint32
	freq int32
}

func (d *StaticData) Create(fmt uint32, bits []byte, freq int32) {
	d.fmt = fmt
	d.bits = bits
	d.freq = freq
}

// StreamData will decode pcm-data at runtime. It's used to play big audio files(like .ogg).
type StreamData struct {
	decoder Decoder
}

func (d *StreamData) Create(file string, ft FileType) {
	decoder, err := factory.NewDecoder(file, ft)
	if err != nil {
		log.Println(err)
		return
	}
	d.decoder = decoder
}

type Engine struct {
	d *driver
}

func (eng *Engine) Initialize() {
	var err error
	eng.d, err = newDriver(44100, 2, 2, 4096)
	if err != nil {
		panic(err)
	}
}

func (eng *Engine) Destroy() {
	err := eng.d.Close()
	if err != nil {
		panic(err)
	}
}

// BufferPlayer can play audio loaded as StaticData.
type BufferPlayer struct {
	engine *Engine
	status uint32
}

func (p *BufferPlayer) initialize(engine *Engine) {
	p.engine = engine
	p.status = Stopped
}

func (p *BufferPlayer) Play(data *StaticData) {

	go func() {
		written := 0
		buf := data.bits
		for len(buf) > 0 {
			// if d.driver == nil {
			// 	return written, errClosed
			// }
			n, _ := engine.d.TryWrite(buf)
			written += n
			// if err != nil {
			// 	return written, err
			// }
			buf = buf[n:]
			// When not all buf is written, the underlying buffer is full.
			// Mitigate the busy loop by sleeping (#10).
			if len(buf) > 0 {
				t := time.Second * time.Duration(engine.d.bufferSize) / time.Duration(engine.d.bytesPerSecond) / 8
				time.Sleep(t)
			}
		}
	}()

	// engine.d.TryWrite(data.bits)
}

func (p *BufferPlayer) Stop() {

}

func (p *BufferPlayer) Pause() {

}

func (p *BufferPlayer) Resume() {

}

func (p *BufferPlayer) Volume() float32 {
	return 0
}

func (p *BufferPlayer) SetVolume(v float32) {
}

func (p *BufferPlayer) SetLoop(loop int) {

}

func (p *BufferPlayer) State() uint32 {
	return p.status
}

// StreamPlayer can play audio loaded as StreamData.
type StreamPlayer struct {
	engine  *Engine
	status  uint32
	feed    chan []byte
	decoder Decoder
}

func (p *StreamPlayer) initialize(engine *Engine) {
	p.engine = engine
	p.status = Stopped
	p.feed = make(chan []byte, 128)
}

func (p *StreamPlayer) Play(stream *StreamData) {
	p.decoder = stream.decoder
	p.fill()
	go func() {

		for {

			written := 0
			buf := <-p.feed
			for len(buf) > 0 {
				// if d.driver == nil {
				// 	return written, errClosed
				// }
				n, _ := engine.d.TryWrite(buf)
				written += n
				// if err != nil {
				// 	return written, err
				// }
				buf = buf[n:]
				// When not all buf is written, the underlying buffer is full.
				// Mitigate the busy loop by sleeping (#10).
				if len(buf) > 0 {
					t := time.Second * time.Duration(engine.d.bufferSize) / time.Duration(engine.d.bytesPerSecond) / 8
					time.Sleep(t)
				}
			}
		}

	}()
}

func (p *StreamPlayer) fill() {
	d := p.decoder
	if d == nil || d.ReachEnd() {
		return // return if no more data
	}

	// feed the free buffer one by one.
	for {
		if n := d.Decode(); n == 0 {
			break
		}
		// var (
		// 	buffer = d.Buffer()
		// 	size   = C.SLuint32(len(buffer))
		// )
		// C.SineStreamPlayer_feed(&p.player, unsafe.Pointer(&buffer[0]), size)

		p.feed <- d.Buffer()
	}
}

func (p *StreamPlayer) Stop() {

}

func (p *StreamPlayer) Pause() {
}

func (p *StreamPlayer) Resume() {

}

func (p *StreamPlayer) State() uint32 {
	return p.status
}

func (p *StreamPlayer) Volume() float32 {
	return 0
}

func (p *StreamPlayer) SetVolume(v float32) {
}

func (p *StreamPlayer) Tick() {
	p.fill()
}

const (
	FormatMono8    = 0x1100
	FormatMono16   = 0x1101
	FormatStereo8  = 0x1102
	FormatStereo16 = 0x1103
)

// AL error
const ()

// AL state
const (
	Initial = 0x1011
	Playing = 0x1012
	Paused  = 0x1013
	Stopped = 0x1014
)

```

`audio/sine/decoder.go`:

```go
package sine

import "korok.io/korok/asset/res"

// audio file decoder
type Decoder interface {
	// helper method for in-memory decode
	FullDecode(file res.File) (d []byte, numChan, bitDepth, freq int32, err error)

	// stream decode
	Decode() int
	NumOfChan() int32
	BitDepth() int32
	SampleRate() int32
	Buffer() []byte
	ReachEnd() bool
	Rewind()
}

// decoder factory, we use'll used it to
// create new decoder by file-type
type DecoderFactory interface {
	NewDecoder(name string, fileType FileType) (Decoder, error)
}

```

`audio/sine/pool.go`:

```go
package sine

import (
	"log"
	"sort"
)

const (
	MaxChannelSize = 8
)

// TODO
type SoundPollCallback func(id uint16)

type SoundChannel struct {
	BufferPlayer
	playing bool
	priority int
	channelId int
}

// manager priority and audio play
type SoundPool struct {
	R *AudioManger
	cb SoundPollCallback

	// state
	pause bool
	mute  bool
	volume float32

	nextChanId int
	channels []*SoundChannel  // quick ref
	_channels  []SoundChannel // real data
}

func (sp *SoundPool) initialize (am *AudioManger, engine *Engine, maxChannel int) *SoundPool {
	sp.R = am
	size := maxChannel
	if size == 0 {
		size = MaxChannelSize
	}
	sp.channels = make([]*SoundChannel, size)
	sp._channels = make([]SoundChannel, size)
	sp.volume = 1 // default value

	for i := range sp.channels {
		sp._channels[i].initialize(engine)
		sp.channels[i] = &sp._channels[i]
		sp.channels[i].priority = -1
	}
	return sp
}

func (sp *SoundPool) Destroy() {
	//al.CloseDevice()
}

func (sp *SoundPool) Mute(mute bool) {
	sp.mute = mute
}

func (sp *SoundPool) Pause(pause bool) {
	sp.pause = pause
}

// TODO: This method has little Latency. Burst effects will
// use up all the play-channel quickly.
func (sp *SoundPool) Tick() {
	for _, ch := range sp.channels {
		if ch.playing && ch.State() == Stopped {
			ch.playing = false
			ch.priority = -1
		}
	}
}

func (sp *SoundPool) Play(id uint16, priority int) (chanId int){
	sound, ok := sp.R.Sound(id)
	if !ok {
		log.Println("invalid sound id:", id)
		return
	}
	static, ok := sound.Data.(*StaticData)
	if !ok {
		return
	}

	// allocate a channel
	ch, ok := sp.allocChannel(priority)
	if !ok {
		log.Print("no channel available")
		return
	}

	// play sample with the channel
	sp.nextChanId ++; chanId = sp.nextChanId
	ch.channelId = chanId
	if ch.playing {
		ch.Stop()
	}
	ch.Play(static)
	return chanId
}

// channels ascend order
func (sp *SoundPool) allocChannel(p int) (sc *SoundChannel, ok bool) {
	// allocate a channel
	if c := sp.channels[0]; !c.playing || c.priority < p {
		sc = c; ok = true
		c.priority = p
		c.playing = true
	}

	// update priority
	if sc != nil {
		sort.SliceStable(sp.channels, func(i, j int) bool {
			return sp.channels[i].priority < sp.channels[j].priority
		})
	}
	return
}

func (sp *SoundPool) StopChan(chanId int) {
	if ch, ok := sp.findChannel(chanId); ok {
		ch.Stop()
	}
}

func (sp *SoundPool) PauseChan(chanId int) {
	if ch, ok := sp.findChannel(chanId); ok {
		ch.Pause()
	}
}

func (sp *SoundPool) ResumeChan(chanId int) {
	if ch, ok := sp.findChannel(chanId); ok {
		ch.Resume()
	}
}

// SetChanVolume sets volume for the specified channel. It
// may fail if can't find the channel.
func (sp *SoundPool) SetChanVolume(chanId int, v float32) {
	if ch, ok := sp.findChannel(chanId); ok {
		ch.SetVolume(v)
	}
}

// GetChanVolume gets volume from the specified channel. Return
// false if not found.
func (sp *SoundPool) GetChanVolume(chanId int) (float32, bool) {
	if ch, ok := sp.findChannel(chanId); ok {
		return ch.Volume(), true
	}
	return 0, false
}

// SetVolume set volume for all the channels in the pool.
func (sp *SoundPool) SetVolume(v float32) {
	for _, ch := range sp.channels {
		ch.SetVolume(v)
	}
	sp.volume = v
}

func (sp *SoundPool) Volume() float32 {
	return sp.volume
}

func (sp *SoundPool) SetLoop(chanId int, loop int) {
	if ch, ok := sp.findChannel(chanId); ok {
		ch.SetLoop(loop)
	}
}

func (sp *SoundPool) findChannel(chanId int) (sc *SoundChannel, ok bool) {
	for _, ch := range sp.channels {
		if ch.channelId == chanId {
			sc, ok = ch, true; break
		}
	}
	return
}

func (sp *SoundPool) SetCallback(cb SoundPollCallback) {
	sp.cb = cb
}

```

`audio/sine/sine.go`:

```go
package sine

/**
Sine is a low-level audio library. You can use it to play pcm-streams, pcm-buffer.
Compressed audio format like ogg/mp3 is not supported directly. You can implement
the DecoderFactory/Decoder interface to play those audio format.
*/
var (
	factory DecoderFactory
	engine *Engine
)

func Init(df DecoderFactory) {
	factory = df
	engine.Initialize()
}

func Destroy() {
	engine.Destroy()
}

func init() {
	R = NewAudioManager()
	engine = &Engine{};
}

// public field
var R *AudioManger

func NewBufferPlayer() (bp *BufferPlayer) {
	bp = &BufferPlayer{}; bp.initialize(engine)
	return
}

func NewStreamPlayer() (sp *StreamPlayer) {
	sp = &StreamPlayer{}; sp.initialize(engine)
	return
}

func NewSoundPool() *SoundPool {
	soundPool := &SoundPool{}; soundPool.initialize(R, engine, 8)
	return soundPool
}
```

`audio/wav/decoder.go`:

```go
package wav

import (
	"encoding/binary"
	"io"
	"io/ioutil"

	"korok.io/korok/asset/res"
)

const (
	// Data format codes

	// PCM
	wave_FORMAT_PCM = 0x0001

	// IEEE float
	wave_FORMAT_IEEE_FLOAT = 0x0003

	// 8-bit ITU-T G.711 A-law
	wave_FORMAT_ALAW = 0x0006

	// 8-bit ITU-T G.711 µ-law
	wave_FORMAT_MULAW = 0x0007

	// Determined by SubFormat
	wave_FORMAT_EXTENSIBLE = 0xFFFE
)

// header
type header struct {
	bChunkID  [4]byte // BUF
	ChunkSize uint32  // L
	bFormat   [4]byte // BUF

	bSubchunk1ID  [4]byte // BUF
	Subchunk1Size uint32  // L

	AudioFormat   uint16 // L
	NumChannels   uint16 // L
	SampleRate    uint32 // L
	ByteRate      uint32 // L
	BlockAlign    uint16 // L
	BitsPerSample uint16 // L

	bSubchunk2ID  [4]byte // BUF
	Subchunk2Size uint32  // L
	Data          []byte  // L
}

// Read returns raw wav data from an input reader
func decode(r io.Reader) (*header, error) {
	h := &header{}
	// header
	err := binary.Read(r, binary.BigEndian, &h.bChunkID)
	if err != nil {
		return nil, err
	}
	err = binary.Read(r, binary.LittleEndian, &h.ChunkSize)
	if err != nil {
		return nil, err
	}
	err = binary.Read(r, binary.BigEndian, &h.bFormat)
	if err != nil {
		return nil, err
	}

	err = binary.Read(r, binary.BigEndian, &h.bSubchunk1ID)
	if err != nil {
		return nil, err
	}
	err = binary.Read(r, binary.LittleEndian, &h.Subchunk1Size)
	if err != nil {
		return nil, err
	}
	err = binary.Read(r, binary.LittleEndian, &h.AudioFormat)
	if err != nil {
		return nil, err
	}
	err = binary.Read(r, binary.LittleEndian, &h.NumChannels)
	if err != nil {
		return nil, err
	}
	err = binary.Read(r, binary.LittleEndian, &h.SampleRate)
	if err != nil {
		return nil, err
	}
	err = binary.Read(r, binary.LittleEndian, &h.ByteRate)
	if err != nil {
		return nil, err
	}
	err = binary.Read(r, binary.LittleEndian, &h.BlockAlign)
	if err != nil {
		return nil, err
	}
	err = binary.Read(r, binary.LittleEndian, &h.BitsPerSample)
	if err != nil {
		return nil, err
	}

	err = binary.Read(r, binary.BigEndian, &h.bSubchunk2ID)
	if err != nil {
		return nil, err
	}
	err = binary.Read(r, binary.LittleEndian, &h.Subchunk2Size)
	if err != nil {
		return nil, err
	}
	return h, nil
}

/**
impl:
type Decoder interface {
	FullDecode() (d []byte, numChan, freq int32, err error)

	Decode() int
	NumOfChan() int
	BitDepth() int
	SampleRate() int32
	Static() []byte
	ReachEnd() bool
}
*/
type Decoder struct {
	numChannels int32
	sampleRate  int32
	bitDepth    int32

	buffer   []byte
	size     int32
	offset   int32
	reachEnd bool

	file res.File
	name string
}

// DON'T change decoder state! pure-virtual function
func (*Decoder) FullDecode(file res.File) (data []byte, numChan, bitDepth, freq int32, err error) {
	h, err := decode(file)
	defer file.Close()

	if err != nil {
		return
	}

	buf, err := ioutil.ReadAll(file)
	if err != nil {
		return
	}

	numChan = int32(h.NumChannels)
	freq = int32(h.SampleRate)
	bitDepth = int32(h.BitsPerSample)
	data = buf
	return
}

// streamed from disc
func (d *Decoder) Decode() (decoded int) {
	n, err := io.ReadFull(d.file, d.buffer)
	if err == io.EOF {
		d.reachEnd = true
	}
	return n
}

func (d *Decoder) head() error {
	if d.file != nil {
		d.file.Close()
	}

	file, err := res.Open(d.name)
	if err != nil {
		return err
	}
	d.file = file
	h, err := decode(file)
	if err != nil {
		return err
	}
	d.numChannels = int32(h.NumChannels)
	d.sampleRate = int32(h.SampleRate)
	d.bitDepth = int32(h.BitsPerSample)
	d.buffer = make([]byte, 16384)
	d.reachEnd = false
	return nil
}

func (d *Decoder) NumOfChan() int32 {
	return d.numChannels
}

func (d *Decoder) BitDepth() int32 {
	return d.bitDepth
}

func (d *Decoder) SampleRate() int32 {
	return d.sampleRate
}

func (d *Decoder) Buffer() []byte {
	return d.buffer
}

func (d *Decoder) ReachEnd() bool {
	return d.reachEnd
}

func (d *Decoder) Rewind() {
	d.head()
}

func (d *Decoder) Close() {
	d.file.Close()
}

func NewDecoder(name string) (d *Decoder, err error) {
	d = new(Decoder)
	d.name = name
	err = d.head()
	return
}

```

`dev.log`:

```log
# 关于 Korok

Korok 取自塞尔达传说里面的森林精灵，在我的最初计划里面这应该是一个面向组件的简单易扩展的2D游戏引擎，引擎的设计启发自：bitsquid.blogspot.com 。
在一般的游戏引擎中都会有游戏对象的概念，比如：Unity 的 GameObject，Cocos2D 的 Sprite，在 korok 里面，是没有这个概念的，它的本质是一个ECS系统，GameObject
是通过一个 id索引各种相关组件组成的，现在设计了几种组件：

1. RenderComp 渲染一个可渲染对象
2. Transform  负责坐标和场景图
3. Animator   动画控制器
3. SourceComp 负责音频

--七夕的第二天

操千曲而后晓声，观千剑而后识器。在之前的设计中，渲染引擎的基础架构设计的不够好，导致后面的系统集成变得艰难。在阅读了大量的开源游戏引擎的渲染系统代码之后，对基础图形API接口的设计
有了新的想法。这样的API符合的特征是：

1. 无状态渲染提交(stateless)
2. 基于排序渲染(sort-based)
3. 易于实现多线程(multi-thread)
4. 兼容新的图形API

这部分的底层API，实现在 `gfx/bk` 叫做 'bk-api'。目前版本的实现搭建了基本的API框架，排序，多线程等暂时都没有实现。但是架构在此，以后添加上这些并非难事。
从现在的观点看来，这种API设计是比较主流的底层图形API设计方式，Ogre3D/Paradox/BitSquid 等大型3D开源引擎都采用了这种设计，此处的设计借鉴了 bgfx 的实现，可以说
是一个简版的 bgfx，但是移除了 bgfx 里面大量的资源管理功能。


--国庆的第二天

基于 bk-API，分别实现了一个用于渲染简单网格的 MeshRender 和 一个用于批量精灵纹理渲染的 BatchRender。Korok 的 Batch 系统，底层维护了8个VBO，最多可以生成128个Batch分组。
Batch接口采用了一个半自动的方案：提供一个 batch-id 字段，如果用户把一组图元标记为相同的 batch-id，那么他们可能会被batch在一起。还有另外两种常见方案：

1. 使用 SpriteBatch 提供手动的 Batch 接口
2. 引擎检测材质，自动根据不同材质进行合并

第一种略显过时，第二种常常会造成困扰，比如我们认为应该batch的场景却没有batch。而korok中采用半自动的方案，可以在无法batch时做出相应的提示，并且尽量按照用户希望
的方式batch，或许能提供更好的开发体验。

--2017/10/06

音频系统暂时可以工作了，这部分api实现在 `audio/ap` 叫做 'ap-API'。这是一套非常底层的API具体负责：

1. 统一的资源管理
2. 播放优先级决策

音频格式(编解码)的支持在 `audio/xx` 目录下实现，这里有两个已经支持的音频格式:wav 和 ogg. wav 一般用来测试和播放占用内存较少的音效，ogg 用来播放背景音乐之类。
此处并不打算支持 mp3 格式，相较来说无论文件大小还是保真程度 ogg 都是优于 mp3 的，所以应该尽量用 ogg 格式来编码游戏音频。编解码模块和底层音频播放系统是完全分离的，
我们通过上层 API 来配置音频的编解码，相互之间通过接口依赖，这样方便以后添加更多音频格式支持。

音频管理（内存管理）和播放部分还有一些功能没有实现(TODO)。

--2017/10/14

在 `gfx/dbg/` 目录下实现了 debug 绘制功能，这这种功能通常用来显示一些debug信息，比如fps,GPU和GPU状态监控等。目前可以用来在屏幕上打印矩形和字符串，这是一个自包含的
模块，可以说是一个微型的渲染系统，它不依赖GUI，也不依赖于引擎的渲染系统（直接基于bk-API）实现。我们的API使用了 *ImmediateMode GUI* 设计，这种 API 接口简单，却能够
实现强大的功能，对于打印一些临时信息来说再好不过，下面是一个段示例：

```
func OnLoop() {
	// draw something...
	dbg.Move(50, 50)
	dbg.Color(0xFFFF0000)
	dbg.DrawRect(0, 0, 50, 50)

	dbg.Move(300, 50)
	dbg.DrawStr("fps:60000!!")

	// advance frame
	dbg.AdvanceFrame()
}
```
-- 2017/10/17

Korok的最终架构这几天确定了 - Comp/Table/System，我们的所有数据采用类似数据库表的概念来管理，所以对一个组件的增删改查类似于表的CRUD操作。我们的底层引擎也会使用同样的接口来操作数据
比如SpriteComp/MeshComp的各自存储在自己的表中。渲染引擎在渲染的时候也是读取当前的表查出所有可渲染对象然后再做绘制。此次没有功能上的更新，大多是运行时系统的重构，但是却
很重要，因为这次我们确定了整体架构和设计哲学，这会直接影响到以后的系统设计/开发。

-- 万圣节的第二天 🎃

可见性系统的设计还是很不完善，而且也没有太好的想法，暂时去掉这个功能，这样可以继续完善渲染系统。目前渲染系统的把Feature和Render分开了，Render是可以复用的基于
Shader的渲染工具，Feature是具体的渲染类型，比如SpriteComp/TextComp.. 它们都可以用BatchRender来渲染，只是使用上有细微的差别。由于 Golang 不支持泛型所以
只能采取间接层的方式--既Feature，来实现差异部分的功能。

-- 2017/12/04

当前已经可以使用 MeshComp 来渲染网格，用 SpriteComp 来渲染精灵图片，从接口API道底层渲染系统联调通过。中间写了一些临时代码，以后会去掉。批量渲染精灵的API如下:

```
    id, _ := assets.Texture.GetTexture("src/main/assets/ball.png")

	for i := 0; i < 50; i++ {
		face := korok.Entity.New()
		korok.Sprite.NewComp(face, assets.AsSubTexture(id))

		faceXF := korok.Transform.NewComp(face)

		x := float32(rand.Intn(480))
		y := float32(rand.Intn(320))
		faceXF.Position = mgl32.Vec2{x, y}
	}
```
今天是个值得庆祝的日子！😊

-- 2017/12/07

重新组织了包名和域名，现在可以使用 `go get korok.io/korok` 来下载引擎了(还没有启用HTTPS，需要加`-insecure`标记).

-- 2017/12/12

设计了粒子系统的初步版本，粒子系统通过 ParticleComp 提供，每个 ParticleComp 都可以设置一个仿真器 - Simulator, 它的实现决定了
具体的粒子效果。仿真部分采用 Pool + Channel + Simulator 组合实现，渲染部分参考 Xenko 的实现申请一个足够容纳所有粒子的VBO来渲染粒子
(注意：大部分引擎是每个系统对应一个VBO)，具体渲染使用的是 MeshRender，当前的代码仅仅验证了想法和一个可以工作的仿真器，接下来会优化接口。

-- 冬至

现在正在一步一步的实现GUI系统，现在的GUI系统主要参考了 dear-imgui 的设计，比如形状的绘制算法，文字渲染等。区别于 imgui 是
我们的设计是分层的：drawing/ui2d/window， drawing 模块负责最底层的UI元素渲染，并生成顶点数组，这样可以使用 gfx 模块的 api
把顶点渲染到屏幕，ui2d模块负责提供ui元素，比如:button/text/image 组件，window 模块在最上层用来实现窗口系统。当然这是一个比较
理想的设计（这个设计也受到了 [OurMachinery](http://ourmachinery.com/)的影响）。

-- 2018/01/05

这段时间主要尝试实现动画系统，并且实现GUI布局和动画，动画系统实现三个子模块：骨骼动画/帧动画/补间动画，这个系统实现的不是很满意，以后
可能会有大的改动。其次就是GUI，IM-GUI并不擅长布局和动画，尝试了诸多方案，比如类似flatui的2-pass方案等，最后采用的方案是在前一帧缓存
UI元素的大小，这样在下一帧的时候可以用这些缓存的数据计算布局。这样的实现使当前显示的UI实际上是上一帧的UI（延迟了一帧），如果30或者60FPS
的刷新率这是感觉不到的。目前这个系统已经可以工作，但是代码上还需要一些优化，接下来会发布beta版本，这个版本之后不会再做新功能的开发。

-- 2018/02/21(初六)

现在各个模块和API接口已经趋于稳定，在发布1.0版本（正式）之前还需要修复一些小bug。之后的版本需要更新的地方还有很多，比如异步资源/场景加载，
GUI的布局系统/ID系统优化等，估计会在1.1 ~ 2.0 之间的某个版本中实现。目前的实现已经具备一定的开发能力，有经验的开发者已经可以用来做一些
东西，但是对于初级用户来说还需要不断完善的API。

-- 2018/03/29


今天其实值得庆祝的，我们把引擎成功的移植到了Android/iOS, 构建一个移动应用仅仅使用 gomobile 命令即可（非常之快之简单）。而且还发现了一些
额外的好处，比如构建出的包大小非常小Android一个架构在5M左右，并且做了一些粗略的性能测试，主要就是在测试Batch系统的性能上限，在iPhone6上
批量10000个精灵还是可以保持60fps的，在红米5A上可以批量1000个精灵保持60fps，2000个精灵会降到30fps（红米5A价值600RMB配置为晓龙425/2G）
这个粗略的测试表明我们的系统是完全可以胜任绝大部分类型游戏的性能需求的，这点令人兴奋。另外我们引擎的潜力并没有完全释放，一是3D支持，二是多
线程支持，这得益于我们的架构设计非常容易的添加新的系统也非常容易的使之并行化。

-- 2018/04/13

好久没有写开发日志了，距离我们正式开始项目已经过去了1年多的时间。到现在为止我们的各个模块的架构设计基本固定不会再有太多的变化。最近这段时间
主要是忙着写博客文章(Marketing)和做 Demo - 一个仿 flappy-bird 的小游戏，同时通过这个 Demo 来发现引擎再实战中的问题。其中比较大的一次改
变是关于引擎的渲染架构部分，按照最早的设计我们各个渲染子系统是互相分离的，但是这样的话我们在处理 Batch 的时候不能把不同 z-order 但是可以
Batch 的元素batch到一起，这件事始终让我耿耿于怀（事实上即使不Batch, 到了bk-api还会产生一次排序，对性能其实影响微乎其微）。所以为了消除这
种心理上的不愉快我还是改变了渲染架构部分（现在实现更接近于 Destiny 的 RenderFeature 架构）。现在会经过两个阶段：Extract 和 Draw，在
Extract 阶段收集所有可见的元素生成一个可以排序的列表，按 z-Order 进行全局排序。然后是 Draw 阶段，此时会根据排序结果进行渲染，渲染还是通
过各个子系统做的，只是在上层(渲染系统)重新调度。现阶段存在的主要问题是重复代码太多，之前我们做系统的时候为了避免过早优化采用的策略是不做任何
抽象，现在随着代码和功能变多，已经到了一个不得不做优化的阶段，这个工作需要在接下来完成。

-- 2018/05/19

最近一个多月的时间主要用来写一个仿 Guppy 的小游戏，主要目的还是检测引擎的实用性，庆幸的是基本上没有遇到太多困难。有一些小的功能添加，比如相机
的一些API，大体上是完全可用的。在实现这个游戏的过程中，用到了物理引擎（Box2D），Box2D的设计思路和我们的ECS架构是很吻合的所以很快的就集成
了。另外把游戏打包 Android/iOS 平台的时候也异常顺利，直接用 gomobile 工具打包就 OK 了。在做文件存储的时候遇到一些困难，写了一些辅助方法，
比如查询当前平台的文件目录。目前来看如果只是做一些典型的小游戏是没有问题的，但是对于国内的情况来说，可能还要集成统计、广告的SDK，现阶段我们还
没有从引擎上直接支持，如果做这些工作，需要使用 gmobile-bind 模式比较容易。

-- 2018/07/12
```

`effect/chan.go`:

```go
package effect

import (
	"korok.io/korok/math/f32"
	"korok.io/korok/math"
)

// Compute Channel：
// Types：float32/Vec2/Vec4
// Methods: random/const/add/sub/mul/integrate
//
// Compute channel is an array of values that can be computed in a for-loop.
// It's data structure is cache-friendly.
type ChanType uint8
const (
	ChanF32 ChanType = iota
	ChanV2
	ChanV4
)

type Channel_f32 []float32

func (ch Channel_f32) SetConst(n int32, v float32) {
	for i := int32(0); i < n; i++ {
		ch[i] = v
	}
}

func (ch Channel_f32) SetRandom(n int32, v Var) {
	for i := int32(0); i < n; i++ {
		ch[i] = math.Random(v.Base, v.Base+v.Var)
	}
}

func (ch Channel_f32) Add(n int32, v float32) {
	for i := int32(0); i < n; i ++ {
		ch[i] += v
	}
}

func (ch Channel_f32) Sub(n int32, v float32) {
	for i := int32(0); i < n; i ++ {
		ch[i] -= v
	}
}

func (ch Channel_f32) Mul(n int32, v float32) {
	for i := int32(0); i < n; i++ {
		ch[i] *= v
	}
}

func (ch Channel_f32) Integrate(n int32, ch1 Channel_f32, dt float32) {
	for i := int32(0); i < n; i++ {
		ch[i] += ch1[i] * dt
	}
}

type Channel_v2 []f32.Vec2

func (ch Channel_v2) SetConst(n int32, x, y float32) {
	for i := int32(0); i < n; i++ {
		ch[i][0], ch[i][1] = x, y
	}
}

func (ch Channel_v2) SetRandom(n int32, xlow, xhigh float32, ylow, yhigh float32) {
	for i := int32(0); i < n; i++ {
		ch[i][0], ch[i][1] = xlow, ylow
	}
}

func (ch Channel_v2) Add(n int32, x, y float32) {
	for i := int32(0); i < n; i++ {
		ch[i][0] += x
		ch[i][1] += y
	}
}

func (ch Channel_v2) Integrate(n int32, ch1 Channel_v2, dt float32) {
	for i := int32(0); i < n; i++ {
		ch[i][0] += ch1[i][0] * dt
		ch[i][1] += ch1[i][1] * dt
	}
}

// ch = normal * m, normal = normal_vector(x, y), m = magnitude
func (ch Channel_v2) radialIntegrate(n int32, xy Channel_v2, m Channel_f32, dt float32) {
	for i := int32(0); i < n; i++ {
		normal := [2]float32{0, 0}
		p := xy[i]

		if p[0] != 0 || p[1] != 0 {
			normalize(p[0], p[1], &normal)
		}

		ch[i][0] += m[i] * normal[0] * dt
		ch[i][1] += m[i] * normal[1] * dt
	}
}

// ch = tangent * m, normal = normal_vector(y, x), m = magnitude
func (ch Channel_v2) tangentIntegrate(n int32, xy Channel_v2, m Channel_f32, dt float32) {
	for i := int32(0); i < n; i++ {
		tangent := [2]float32{0, 0}
		p := xy[i]

		if p[0] != 0 || p[1] != 0 {
			normalize(p[1], p[0], &tangent)
		}

		ch[i][0] += m[i] * tangent[0] * dt
		ch[i][1] += m[i] * tangent[1] * dt
	}
}

// maybe only Color will use it
type Channel_v4 []f32.Vec4

func (ch Channel_v4) SetConst(n int32, x, y, z, w float32) {
	for i := int32(0); i < n; i ++ {
		ch[i][0], ch[i][1], ch[i][2], ch[i][3] = x, y, z, w
	}
}

func (ch Channel_v4) SetRandom(n int32, x, y, z, v [4]Var) {
	for i := int32(0); i < n; i ++ {
		ch[i][0] = math.Random(v[0].Base, v[0].Base+v[0].Var)
		ch[i][1] = math.Random(v[1].Base, v[1].Base+v[1].Var)
		ch[i][2] = math.Random(v[2].Base, v[2].Base+v[2].Var)
		ch[i][3] = math.Random(v[3].Base, v[3].Base+v[3].Var)
	}
}

func (ch Channel_v4) Add(n int32, x, y, z, w float32) {
	for i := int32(0); i < n; i ++ {
		ch[i][0] += x
		ch[i][1] += y
		ch[i][2] += z
		ch[i][3] += w
	}
}

func (ch Channel_v4) Sub(n int32, x, y, z, w float32) {
	for i := int32(0); i < n; i ++ {
		ch[i][0] -= x
		ch[i][1] -= y
		ch[i][2] -= z
		ch[i][3] -= w
	}
}

func (ch Channel_v4) Integrate(n int32, d Channel_v4, dt float32) {
	for i := int32(0); i < n; i++ {
		ch[i][0] += d[i][0] * dt
		ch[i][1] += d[i][1] * dt
		ch[i][2] += d[i][2] * dt
		ch[i][3] += d[i][3] * dt
	}
}

func normalize(x, y float32, n *[2]float32)  {
	div := math.InvSqrt(x * x + y * y)
	n[0] = x * div
	n[1] = x * div
}

```

`effect/chan_test.go`:

```go
package effect

import (
	"testing"
	"korok.io/korok/math/f32"
)

func TestChannel_f32(t *testing.T) {
	p := Channel_f32(make([]float32, 1024))
	n  := 10

	p.Add(int32(n), 8)

	for i := 0; i < n; i++ {
		if p[i] != 8 {
			t.Error("err: chanf32.add")
		}
	}

	p.Sub(int32(n), 4)

	for i := 0; i < n; i++ {
		if p[i] != 4 {
			t.Error("err: chanf32.add")
		}
	}

	p.Mul(10, 2)
	for i := 0; i < n; i++ {
		if p[i] != 8 {
			t.Error("err: chanf32.Mul")
		}
	}

	v := Channel_f32(make([]float32, 1024))
	v.SetConst(int32(n), 1.0/60)

	p.Integrate(10, v, 2)

	// p' = p + v*dt
	pp := float32(8 + 1.0/60 * 2)
	for i := 0; i < n; i++ {
		if p[i] != pp {
			t.Error("err: chanf32.integrate")
		}
	}
}

func TestChannel_v2(t *testing.T) {
	p := Channel_v2(make([]f32.Vec2, 1024))
	n := 10

	p.SetConst(int32(n), 4, 8)
	for i := 0; i < n; i++ {
		if p[i][0] != 4 || p[i][1] != 8 {
			t.Error("err: chanv2.SetConst")
		}
	}

	p.Add(int32(n), 4, 8)
	for i := 0; i < n; i++ {
		if p[i][0] != 8 || p[i][1] != 16 {
			t.Error("err: chanv2.Add")
		}
	}

	v := Channel_v2(make([]f32.Vec2, 1024))
	v.SetConst(int32(n), 16, 32)
	p.Integrate(int32(n), v, 1.0/60)

	p1, p2 := float32(8 + 16 * 1.0/60), float32(16 + 32 * 1.0/60)
	for i := 0; i < n; i++ {
		if p[i][0] != p1 || p[i][1] != p2 {
			t.Error("err: chanv2.Integrate")
		}
	}

}

```

`effect/particle.go`:

```go
package effect

import (
	"korok.io/korok/math/f32"
	"korok.io/korok/engi"
	"korok.io/korok/gfx"
	"korok.io/korok/gfx/bk"
	"korok.io/korok/gfx/dbg"

	"unsafe"
	"log"
)

// Particle Component
type ParticleComp struct {
	init bool
	engi.Entity
	sim Simulator
	zOrder int16
	visible int16

	tex gfx.Tex2D
	size f32.Vec2
}

func (pc *ParticleComp) SetSimulator(sim Simulator) {
	pc.sim = sim
}

func (pc *ParticleComp) Simulator() Simulator {
	return pc.sim
}

func (pc *ParticleComp) SetTexture(tex gfx.Tex2D) {
	pc.tex = tex
}

func (pc *ParticleComp) Texture() gfx.Tex2D {
	return pc.tex
}

func (pc *ParticleComp) Play() {
	if ctr, ok := pc.sim.(Controller); ok {
		ctr.Play()
	}
}

func (pc *ParticleComp) Stop() {
	if ctr, ok := pc.sim.(Controller); ok {
		ctr.Stop()
	}
}

func (pc *ParticleComp) Prewarm(t float32) {
	if ctr, ok := pc.sim.(WarmupController); ok {
		ctr.Prewarm(t)
		log.Println("prewarm time, t:", t)
	}
}

func (pc *ParticleComp) SetZOrder(z int16) {
	pc.zOrder = z
}

func (pc *ParticleComp) Z() int16 {
	return pc.zOrder
}

func (pc *ParticleComp) Visible() bool {
	if pc.visible == 0 {
		return false
	}
	return true
}

func (pc *ParticleComp) SetVisible(v bool) {
	if v {
		pc.visible = 1
	} else {
		pc.visible = 0
	}
}

// The width and height of the particle system. We'll use it to
// make visibility test. The default value is {w:64, h:64}
func (pc *ParticleComp) SetSize(w, h float32) {
	pc.size[0], pc.size[1] = w, h
}

// component manager
type ParticleSystemTable struct {
	comps []ParticleComp
	_map   map[uint32]int
	index, cap int
}

func NewParticleSystemTable(cap int) *ParticleSystemTable {
	return &ParticleSystemTable{
		_map:make(map[uint32]int),
		cap:cap,
	}
}

func (et *ParticleSystemTable) NewComp(entity engi.Entity) (ec *ParticleComp) {
	if size := len(et.comps); et.index >= size {
		et.comps = effectCompResize(et.comps, size + 64)
	}
	ei := entity.Index()
	if v, ok := et._map[ei]; ok {
		return &et.comps[v]
	}
	ec = &et.comps[et.index]
	ec.Entity = entity
	ec.visible = 1
	ec.size = f32.Vec2{64, 64}
	et._map[ei] = et.index
	et.index ++
	return
}

func (et *ParticleSystemTable) Alive(entity engi.Entity) bool {
	if v, ok := et._map[entity.Index()]; ok {
		return et.comps[v].Entity != 0
	}
	return false
}

func (et *ParticleSystemTable) Comp(entity engi.Entity) (ec *ParticleComp) {
	if v, ok := et._map[entity.Index()]; ok {
		ec = &et.comps[v]
	}
	return
}

func (et *ParticleSystemTable) Delete(entity engi.Entity) {
	ei := entity.Index()
	if v, ok := et._map[ei]; ok {
		if tail := et.index -1; v != tail && tail > 0 {
			et.comps[v] = et.comps[tail]
			// remap index
			tComp := &et.comps[tail]
			ei := tComp.Entity.Index()
			et._map[ei] = v
			tComp.Entity = 0
		} else {
			et.comps[tail].Entity = 0
		}

		et.index -= 1
		delete(et._map, ei)
	}
}

func (et *ParticleSystemTable) Size() (size, cap int) {
	return et.index, et.cap
}

func effectCompResize(slice []ParticleComp, size int) []ParticleComp {
	newSlice := make([]ParticleComp, size)
	copy(newSlice, slice)
	return newSlice
}

type ParticleRenderFeature struct {
	*gfx.MeshRender
	id int
	BufferContext

	et *ParticleSystemTable
	xt *gfx.TransformTable

	stats struct{
		lives int
	}
}

// 此处初始化所有的依赖
func (f *ParticleRenderFeature) Register(rs *gfx.RenderSystem) {
	// init render
	for _, r := range rs.RenderList {
		switch mr := r.(type) {
		case *gfx.MeshRender:
			f.MeshRender = mr; break
		}
	}
	// init table
	for _, t := range rs.TableList {
		switch table := t.(type){
		case *ParticleSystemTable:
			f.et = table
		case *gfx.TransformTable:
			f.xt = table
		}
	}
	// add new feature
	f.id = rs.Accept(f)
}

func (f *ParticleRenderFeature) Extract(v *gfx.View) {
	var (
		camera = v.Camera
		xt     = f.xt
		fi = uint32(f.id) << 16
	)
	for i, pc := range f.et.comps[:f.et.index] {
		if xf := xt.Comp(pc.Entity); pc.visible != 0 && camera.InView(xf, pc.size, f32.Vec2{.5, .5}) {
			sid := gfx.PackSortId(pc.zOrder, 0)
			val := fi+uint32(i)
			v.RenderNodes = append(v.RenderNodes, gfx.SortObject{SortId:sid,Value:val})
		}
	}
}

func (f *ParticleRenderFeature) Draw(nodes gfx.RenderNodes) {
	var (
		requireVertexSize int
		requireIndexSize int
	)
	for _, node := range nodes {
		_, cap := f.et.comps[node.Value&0xFFFF].sim.Size()
		requireVertexSize += cap * 4
		if cap > requireIndexSize {
			requireIndexSize = cap * 6
		}
	}
	f.AllocBuffer(requireVertexSize, requireIndexSize)

	// setup mesh & matrix
	mesh := &gfx.Mesh{
		IndexId:f.BufferContext.indexId,
		VertexId:f.BufferContext.vertexId,
	}
	mat4 := &f32.Mat4{1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1}

	// fill vertex buffer
	var (
		offset int
	)
	for _, node := range nodes {
		z, _ := gfx.UnpackSortId(node.SortId)
		ps := f.et.comps[node.Value&0xFFFF]
		xf := f.xt.Comp(ps.Entity)

		live, _ := ps.sim.Size()
		vsz, isz := live*4, live*6
		buff := f.vertex[offset:offset+vsz]
		ps.sim.Visualize(buff, ps.tex)

		mesh.FirstVertex = uint16(offset);offset += vsz
		mesh.NumVertex = uint16(vsz)
		mesh.FirstIndex = 0
		mesh.NumIndex = uint16(isz)
		mesh.SetTexture(ps.tex.Tex())

		p := xf.Position()
		mat4.Set(0, 3, p[0])
		mat4.Set(1, 3, p[1])
		f.MeshRender.Draw(mesh, mat4, int32(z))

		f.stats.lives += live
	}

	// update buffer
	updateSize := uint32(requireVertexSize * 20)
	f.vb.Update(0, updateSize, unsafe.Pointer(&f.vertex[0]), false)
}

func (f *ParticleRenderFeature) Flush() {
	dbg.Hud("lives: %d", f.stats.lives)
	f.stats.lives = 0
}

// 目前所有的粒子都会使用一个VBO进行渲染 TODO
// 这么做同时可渲染的例子数量会受限于VBO的大小，需要一些经验数据支持
type BufferContext struct {
	vertexId uint16
	indexId uint16

	vertexSize int
	indexSize int

	// 目前我们使用 MeshRender 来渲染粒子
	// 所以必须支持如下的数据结构
	vertex []gfx.PosTexColorVertex

	vb *bk.VertexBuffer
}

func (ctx *BufferContext) AllocBuffer(vertexSize, indexSize int) {
	id, sz, vb := gfx.Context.TempVertexBuffer(vertexSize, 20)
	ctx.vertexId = id
	ctx.vb = vb
	if sz > ctx.vertexSize {
		ctx.vertexSize = sz
		ctx.vertex = make([]gfx.PosTexColorVertex, sz)
	}

	if indexSize > ctx.indexSize {
		ctx.indexId, ctx.indexSize = gfx.Context.SharedIndexBuffer()
	}
}

func (ctx *BufferContext) Release() {

}

```

`effect/particle_test.go`:

```go
package effect

import (
	"testing"
	"korok.io/korok/engi"
)

// Test CRUD operation for MeshTable
func TestMeshTable(t *testing.T) {
	em := &engi.EntityManager{}
	et := NewParticleSystemTable(1024)

	e1 := em.New()
	xf1 := et.NewComp(e1)

	if xf := et.Comp(e1); xf != xf1 {
		t.Error("fail to create Comp")
	}

	et.Delete(e1)
	if xf := et.Comp(e1); xf != nil {
		t.Error("fail to delete Comp")
	}

	if size, _ := et.Size(); size != 0 {
		t.Error("fail to reset Table state")
	}

	// create 10
	eList := make([]engi.Entity, 10)
	for i := 0; i < 10; i++ {
		e := em.New()
		et.NewComp(e)
		eList[i] = e
	}

	if size, _ := et.Size(); size != len(eList) {
		t.Error("fail to create 10 Comps")
	}

	// delete 5
	for i, e := range eList {
		if i % 2 == 0 {
			et.Delete(e)
		}
	}

	if size, _ := et.Size(); size != len(eList)/2 {
		t.Error("fail to delete Comps")
	}

	// test left
	for i, e := range eList {
		if i % 2 == 1 {
			if comp := et.Comp(e); comp == nil || comp.Entity != e {
				t.Error("fail to keep entity:", e)
			}
		} else {
			if et.Comp(e) != nil {
				t.Error("fail to delete Comps:", e)
			}
		}
	}


}

// step=64
func TestMeshTableResize(t *testing.T) {
	em := &engi.EntityManager{}
	et := NewParticleSystemTable(1024)

	list30 := make([]engi.Entity, 30)
	for i := 0; i < 30; i++ {
		e := em.New()
		et.NewComp(e)
		list30[i] = e
	}

	// will cause resize
	list100 := make([]engi.Entity, 100)
	for i := 0; i < 100; i++ {
		e := em.New()
		et.NewComp(e)
		list100[i] = e
	}

	if size, _ := et.Size(); size != (len(list30) + len(list100)) {
		t.Errorf("fail to create Comps: %d/%d", size, len(list30) + len(list100))
	}

	list := append(list100, list30...)
	for _, e := range list {
		if xf := et.Comp(e); xf == nil || xf.Entity != e {
			t.Error("comp is not create correctly")
		}
	}
}
```

`effect/pool.go`:

```go
package effect

import (
	"unsafe"
	"korok.io/korok/math/f32"
)

// A description of channel used in pool
type ChanFiled struct {
	Type ChanType
	Name string
}

type block struct {
	ChanFiled
	stride int
	data []byte
}

var (
	Life = ChanFiled{Type:ChanF32, Name:"Life"}
	Size = ChanFiled{Type:ChanF32, Name:"ParticleSize"}
	SizeDelta = ChanFiled{Type:ChanF32, Name:"ParticleSize-delta"}

	Color = ChanFiled{Type:ChanV4, Name:"Color"}
	ColorDelta = ChanFiled{Type:ChanV4, Name:"Color-delta"}

	Position = ChanFiled{Type:ChanV2, Name:"position"}
	PositionStart = ChanFiled{Type:ChanV2, Name:"position-start"}
	Velocity = ChanFiled{Type:ChanV2, Name:"velocity"}

	Speed = ChanFiled{Type:ChanF32, Name:"speed"}
	Direction = ChanFiled{Type:ChanV2, Name:"direction"}
	RadialAcc = ChanFiled{Type:ChanF32, Name:"radial-acc"}
	TangentialAcc = ChanFiled{Type:ChanF32, Name:"tangent-acc"}

	Rotation = ChanFiled{Type:ChanF32, Name:"rotation"}
	RotationDelta = ChanFiled{Type:ChanF32, Name:"rotation-delta"}

	Angle = ChanFiled{Type:ChanF32, Name:"angle"}
	AngleDelta = ChanFiled{Type:ChanF32, Name:"angle-delta"}
	Radius = ChanFiled{Type:ChanF32, Name:"radius"}
	RadiusDelta = ChanFiled{Type:ChanF32, Name:"radius-delta"}
)

// A Pool represent a particle-pool.
type Pool struct {
	blocks []block
	chans  map[ChanFiled]int
	Cap    int
}

// AddChan adds new fields to the pool.
func (p *Pool) AddChan(fields ...ChanFiled) {
	for _, f := range fields {
		p.blocks = append(p.blocks, block{ChanFiled:f})
	}
}

// Initialize the particle pool.
func (p *Pool) Initialize() {
	p.chans = make(map[ChanFiled]int)
	size := p.Size()
	pool := make([]byte, size)

	var (
		mem = uintptr(unsafe.Pointer(&pool[0]))
		offset uintptr
		cap = p.Cap
	)

	for i, b := range p.blocks {
		stride := sizeOf(b.Type)
		p.blocks[i].stride = stride
		p.blocks[i].data = (*[1<<16]byte)(unsafe.Pointer(mem + offset))[:cap*stride]
		offset += uintptr(cap * stride)
		p.chans[b.ChanFiled] = i
	}
}

func sizeOf(t ChanType) (size int) {
	switch t {
	case ChanF32:
		size = 4
	case ChanV2:
		size = 8
	case ChanV4:
		size = 16
	}
	return
}

// Size return the ParticleSize (in bytes) of the pool.
func (p *Pool) Size() (size int) {
	for _, f := range p.blocks {
		size += int(sizeOf(f.Type)) * p.Cap
	}
	return
}

// Field returns pointer of the filed in the pool.
func (p *Pool) Field(t ChanFiled) (array interface{}) {
	block := p.blocks[p.chans[t]]
	mem := unsafe.Pointer(&block.data[0])
	switch t.Type {
	case ChanF32:
		array = Channel_f32((*[1<<16]float32)(mem)[:p.Cap])
	case ChanV2:
		array = Channel_v2((*[1<<16]f32.Vec2)(mem)[:p.Cap])
	case ChanV4:
		array = Channel_v4((*[1<<16]f32.Vec4)(mem)[:p.Cap])
	}
	return
}

// Swap swap all the field defined in the pool.
func (p *Pool) Swap(dst, src int) {
	for _, b := range p.blocks {
		stride := 4 << uint(b.Type)
		i, j := dst * stride, src * stride
		copy(b.data[i:], b.data[j:j+stride])
	}
}

```

`effect/pool_test.go`:

```go
package effect

import (
	"testing"
	"unsafe"
)

func TestPool(t *testing.T) {
	p := &Pool{Cap: 1024}

	p.AddChan(Life, Position)
	p.Initialize()

	//   Life: Cap * sizeOf(float)
	// + Position: Cap * sizeOf(vec2)
	size := 1024 * 4 + 1024 * 8
	if p.Size() != size {
		t.Error("fail to compute ParticleSize")
	}

	life := p.Field(Life).(Channel_f32)
	pose := p.Field(Position).(Channel_v2)

	if life == nil || len(life) != 1024 {
		t.Error("fail to cast Life")
	}

	if pose == nil || len(pose) != 1024 {
		t.Error("fail to cast Position")
	}

	d := uintptr(unsafe.Pointer(&pose[0])) - uintptr(unsafe.Pointer(&life[0]))
	if int(d) != 1024 * 4 { // Cap * sizeOf(float)
		t.Error("fail to alloc Life and position")
	}
}

```

`effect/sim_explosion.go`:

```go
package effect

import (
	"korok.io/korok/math/f32"
	"korok.io/korok/gfx"
	"korok.io/korok/math"
)

// FireSimulator can simulate the fire effect.
type ExplosionSimulator struct {
	Pool

	RateController
	LifeController
	VisualController

	velocity Channel_v2
	deltaColor Channel_v4

	// Configuration.
	Config struct{
		Duration, Rate float32
		Life Var
		Size Var
		Color TwoColor
		Position [2]Var
		Angle Var
		Speed Var
		Additive bool
	}
}

func NewExplosionSimulator(cap int) *ExplosionSimulator {
	sim := ExplosionSimulator{Pool: Pool{Cap: cap}}
	sim.AddChan(Life, Size)
	sim.AddChan(Position, Velocity)
	sim.AddChan(Color)
	sim.AddChan(Rotation)
	sim.AddChan(ColorDelta)

	// config
	sim.Config.Duration = .1
	sim.Config.Rate = float32(cap)/sim.Config.Duration
	sim.Config.Life = Var{3, 1}
	sim.Config.Color = TwoColor{f32.Vec4{1, 1, 0, 1}, f32.Vec4{.973, .349, 0, 1}, true}
	sim.Config.Size = Var{15, 10}
	sim.Config.Angle = Var{0, 6.28}
	sim.Config.Speed = Var{100, 40}

	return &sim
}

func (f *ExplosionSimulator) Initialize() {
	f.Pool.Initialize()

	f.Life = f.Field(Life).(Channel_f32)
	f.ParticleSize = f.Field(Size).(Channel_f32)
	f.Position = f.Field(Position).(Channel_v2)
	f.velocity = f.Field(Velocity).(Channel_v2)
	f.Color = f.Field(Color).(Channel_v4)
	f.deltaColor = f.Field(ColorDelta).(Channel_v4)
	f.Rotation = f.Field(Rotation).(Channel_f32)

	f.RateController.Initialize(f.Config.Duration, f.Config.Rate)
}

func (f *ExplosionSimulator) Simulate(dt float32) {
	// spawn new particle
	if new := f.Rate(dt); new > 0 {
		f.newParticle(new)
	}

	n := int32(f.Live)

	// update old particle
	f.Life.Sub(n, dt)

	// position integrate: p' = p + v * t
	f.Position.Integrate(n, f.velocity, dt)

	// Color
	f.Color.Integrate(n, f.deltaColor, dt)

	// GC
	f.GC(&f.Pool)
}

func (f *ExplosionSimulator) Size() (live, cap int) {
	return int(f.Live), f.Cap
}

func (f *ExplosionSimulator) newParticle(new int) {
	if (f.Live + new) > f.Cap {
		return
	}

	start := f.Live
	f.Live += new

	for i := start; i < f.Live; i++ {
		f.Life[i] = f.Config.Life.Random()
		f.ParticleSize[i] = f.Config.Size.Random()
		startColor := f.Config.Color.Random()
		f.Color[i] = startColor
		invLife := 1/f.Life[i]
		f.deltaColor[i] = f32.Vec4{
			-startColor[0] * invLife,
			-startColor[1] * invLife,
			-startColor[2] * invLife,
			-startColor[3] * invLife,
		}

		px := f.Config.Position[0].Random()
		py := f.Config.Position[1].Random()
		f.Position[i] = f32.Vec2{px, py}

		a := f.Config.Angle.Random()
		s := f.Config.Speed.Random()
		f.velocity[i] = f32.Vec2{math.Cos(a)*s, math.Sin(a)*s}
		f.Rotation[i] = a
	}
}

func (f *ExplosionSimulator) Visualize(buf []gfx.PosTexColorVertex, tex gfx.Tex2D) {
	f.VisualController.Visualize(buf, tex, f.Live, f.Config.Additive)
}


```

`effect/sim_fire.go`:

```go
package effect

import (
	"korok.io/korok/math/f32"
	"korok.io/korok/gfx"
	"korok.io/korok/math"
)

// FireSimulator can simulate the fire effect.
type FireSimulator struct {
	Pool

	RateController
	LifeController
	VisualController

	velocity Channel_v2
	deltaColor Channel_v4

	// Configuration.
	Config struct{
		Duration, Rate float32
		Life Var
		Size Var
		Color f32.Vec4
		Position [2]Var
		Angle Var
		Speed Var
		Additive bool
	}
}

func NewFireSimulator(cap int) *FireSimulator {
	sim := FireSimulator{Pool: Pool{Cap: cap}}
	sim.AddChan(Life, Size)
	sim.AddChan(Position, Velocity)
	sim.AddChan(Color)
	sim.AddChan(Rotation)
	sim.AddChan(ColorDelta)

	// config
	sim.Config.Duration = math.MaxFloat32
	sim.Config.Rate = float32(cap)/3
	sim.Config.Life = Var{3, .25}
	sim.Config.Color = f32.Vec4{.76, .25, .12, 1}
	sim.Config.Size = Var{34, 10}
	sim.Config.Position[0] = Var{0, 20}
	sim.Config.Position[1] = Var{0, 20}
	sim.Config.Angle = Var{3.14/2, 0.314}
	sim.Config.Speed = Var{60, 20}
	sim.Config.Additive = true

	return &sim
}

func (f *FireSimulator) Initialize() {
	f.Pool.Initialize()

	f.Life = f.Field(Life).(Channel_f32)
	f.ParticleSize = f.Field(Size).(Channel_f32)
	f.Position = f.Field(Position).(Channel_v2)
	f.velocity = f.Field(Velocity).(Channel_v2)
	f.Color = f.Field(Color).(Channel_v4)
	f.deltaColor = f.Field(ColorDelta).(Channel_v4)
	f.Rotation = f.Field(Rotation).(Channel_f32)

	f.RateController.Initialize(f.Config.Duration, f.Config.Rate)
}

func (f *FireSimulator) Simulate(dt float32) {
	// spawn new particle
	if new := f.Rate(dt); new > 0 {
		f.newParticle(new)
	}

	n := int32(f.Live)

	// update old particle
	f.Life.Sub(n, dt)

	// position integrate: p' = p + v * t
	f.Position.Integrate(n, f.velocity, dt)

	// Color
	f.Color.Integrate(n, f.deltaColor, dt)

	// GC
	f.GC(&f.Pool)
}

func (f *FireSimulator) Size() (live, cap int) {
	return int(f.Live), f.Cap
}

func (f *FireSimulator) newParticle(new int) {
	if (f.Live + new) > f.Cap {
		return
	}

	start := f.Live
	f.Live += new

	for i := start; i < f.Live; i++ {
		f.Life[i] = f.Config.Life.Random()
		f.ParticleSize[i] = f.Config.Size.Random()
		f.Color[i] = f.Config.Color
		invLife := 1/f.Life[i]
		f.deltaColor[i] = f32.Vec4{
			-f.Config.Color[0] * invLife,
			-f.Config.Color[1] * invLife,
			-f.Config.Color[2] * invLife,
		}

		px := f.Config.Position[0].Random()
		py := f.Config.Position[1].Random()
		f.Position[i] = f32.Vec2{px, py}

		a := f.Config.Angle.Random()
		s := f.Config.Speed.Random()
		f.velocity[i] = f32.Vec2{math.Cos(a)*s, math.Sin(a)*s}
	}
}

func (f *FireSimulator) Visualize(buf []gfx.PosTexColorVertex, tex gfx.Tex2D) {
	f.VisualController.Visualize(buf, tex, f.Live, f.Config.Additive)
}


```

`effect/sim_fountain.go`:

```go
package effect

import (
	"korok.io/korok/math/f32"
	"korok.io/korok/gfx"
	"korok.io/korok/math"
)

// FireSimulator can simulate the fire effect.
type FountainSimulator struct {
	Pool

	RateController
	LifeController
	VisualController

	velocity Channel_v2
	deltaColor Channel_v4
	deltaRot Channel_f32

	// Configuration.
	Config struct{
		Duration, Rate float32
		Life Var
		Size Var
		Color TwoColor
		Fading bool
		Position [2]Var
		Angle Var
		Speed Var
		Gravity float32
		Rotation Var
		Additive bool
	}
}

func NewFountainSimulator(cap int) *FountainSimulator {
	sim := FountainSimulator{Pool: Pool{Cap: cap}}
	sim.AddChan(Life, Size)
	sim.AddChan(Position, Velocity)
	sim.AddChan(Color, ColorDelta)
	sim.AddChan(Rotation, RotationDelta)

	// config
	sim.Config.Duration = math.MaxFloat32
	sim.Config.Rate = float32(cap)/3
	sim.Config.Life = Var{3, .25}
	sim.Config.Color = TwoColor{f32.Vec4{1, 1, 1, 1}, f32.Vec4{1, 1, 1, 1}, false}
	sim.Config.Fading = false
	sim.Config.Size = Var{8, 2}
	sim.Config.Angle = Var{3.14/2, 3.14/3}
	sim.Config.Speed = Var{120, 20}
	sim.Config.Rotation = Var{0, 1}
	sim.Config.Gravity = -120

	return &sim
}

func (f *FountainSimulator) Initialize() {
	f.Pool.Initialize()

	f.Life = f.Field(Life).(Channel_f32)
	f.ParticleSize = f.Field(Size).(Channel_f32)
	f.Position = f.Field(Position).(Channel_v2)
	f.velocity = f.Field(Velocity).(Channel_v2)
	f.Color = f.Field(Color).(Channel_v4)
	f.deltaColor = f.Field(ColorDelta).(Channel_v4)
	f.Rotation = f.Field(Rotation).(Channel_f32)
	f.deltaRot = f.Field(RotationDelta).(Channel_f32)

	f.RateController.Initialize(f.Config.Duration, f.Config.Rate)
}

func (f *FountainSimulator) Simulate(dt float32) {
	// spawn new particle
	if new := f.Rate(dt); new > 0 {
		f.newParticle(new)
	}

	n := int32(f.Live)

	// update old particle
	f.Life.Sub(n, dt)

	// position integrate: p' = p + v * t
	f.Position.Integrate(n, f.velocity, dt)

	// v' = v + g * t
	f.velocity.Add(n, 0, f.Config.Gravity*dt)

	// spin
	f.Rotation.Integrate(n, f.deltaRot, dt)

	// Color
	f.Color.Integrate(n, f.deltaColor, dt)

	// GC
	f.GC(&f.Pool)
}

func (f *FountainSimulator) Size() (live, cap int) {
	return int(f.Live), f.Cap
}

func (f *FountainSimulator) newParticle(new int) {
	if (f.Live + new) > f.Cap {
		return
	}

	start := f.Live
	f.Live += new

	for i := start; i < f.Live; i++ {
		f.Life[i] = f.Config.Life.Random()
		f.ParticleSize[i] = f.Config.Size.Random()

		startColor := f.Config.Color.Random()
		f.Color[i] = startColor
		if f.Config.Fading {
			invLife := 1/f.Life[i]
			f.deltaColor[i] = f32.Vec4{
				-startColor[0] * invLife,
				-startColor[1] * invLife,
				-startColor[2] * invLife,
				-startColor[2] * invLife,
			}
		}

		px := f.Config.Position[0].Random()
		py := f.Config.Position[1].Random()
		f.Position[i] = f32.Vec2{px, py}

		a := f.Config.Angle.Random()
		s := f.Config.Speed.Random()
		f.velocity[i] = f32.Vec2{math.Cos(a)*s, math.Sin(a)*s}

		r := f.Config.Rotation.Random()
		f.deltaRot[i] = r
	}
}

func (f *FountainSimulator) Visualize(buf []gfx.PosTexColorVertex, tex gfx.Tex2D) {
	f.VisualController.Visualize(buf, tex, f.Live, f.Config.Additive)
}



```

`effect/sim_gravity.go`:

```go
package effect

import (
	"korok.io/korok/math"
	"korok.io/korok/math/f32"
	"korok.io/korok/gfx"
)

type Config struct {
	Max int

	Duration float32
	Rate float32 	// Number of particles per-second

	Life  Var
	X, Y  Var
	Size  Range
	Rot   Range

	R, G, B, A Range
	Additive bool
}

// GravityConfig used to configure the GravitySimulator.
type GravityConfig struct {
	Config

	// gravity
	Gravity f32.Vec2

	// speed and direction
	Speed Var
	Angel Var

	// Radial acceleration
	RadialAcc Var

	// tangent acceleration
	TangentialAcc Var

	RotationIsDir bool
}

// GravitySimulator works as the gravity mode of Cocos2D's particle-system.
type GravitySimulator struct {
	Pool

	RateController
	LifeController
	VisualController

	poseStart  Channel_v2
	colorDelta Channel_v4
	sizeDelta  Channel_f32
	rot        Channel_f32
	rotDelta   Channel_f32

	velocity      Channel_v2
	radialAcc     Channel_f32
	tangentialAcc Channel_f32

	//
	gravity f32.Vec2

	// config
	*GravityConfig
}

func NewGravitySimulator(cfg *GravityConfig) *GravitySimulator {
	g := &GravitySimulator{GravityConfig: cfg}; g.Cap = cfg.Max

	g.Pool.AddChan(Life)
	g.Pool.AddChan(Position, PositionStart)
	g.Pool.AddChan(Color, ColorDelta)
	g.Pool.AddChan(Size, SizeDelta)
	g.Pool.AddChan(Rotation, RotationDelta)

	g.Pool.AddChan(Velocity)
	g.Pool.AddChan(RadialAcc)
	g.Pool.AddChan(TangentialAcc)

	return g
}

// alloc a big block
func (g *GravitySimulator) Initialize() {
	g.Pool.Initialize()

	g.Life = g.Field(Life).(Channel_f32)
	g.Position = g.Field(Position).(Channel_v2)
	g.poseStart = g.Field(PositionStart).(Channel_v2)
	g.Color = g.Field(Color).(Channel_v4)
	g.colorDelta = g.Field(ColorDelta).(Channel_v4)
	g.ParticleSize = g.Field(Size).(Channel_f32)
	g.sizeDelta = g.Field(SizeDelta).(Channel_f32)
	g.Rotation = g.Field(Rotation).(Channel_f32)
	g.rotDelta = g.Field(RotationDelta).(Channel_f32)

	g.velocity = g.Field(Velocity).(Channel_v2)
	g.radialAcc = g.Field(RadialAcc).(Channel_f32)
	g.tangentialAcc = g.Field(TangentialAcc).(Channel_f32)

	// init const
	g.gravity = g.GravityConfig.Gravity

	// emit rate
	g.RateController.Initialize(g.GravityConfig.Duration, g.GravityConfig.Rate)
}

func (g *GravitySimulator) Simulate(dt float32) {
	if new := g.RateController.Rate(dt); new > 0 {
		g.newParticle(new)
	}

	n := int32(g.Live)

	g.Life.Sub(n, dt)

	// gravity model integrate
	g.velocity.radialIntegrate(n, g.Position, g.radialAcc, dt)
	g.velocity.tangentIntegrate(n, g.Position, g.tangentialAcc, dt)

	g.velocity.Add(n, g.gravity[0]*dt, g.gravity[1]*dt)

	// position
	g.Position.Integrate(n, g.velocity, dt)

	// Color
	g.Color.Integrate(n, g.colorDelta, dt)

	// ParticleSize
	g.ParticleSize.Integrate(n, g.sizeDelta, dt)

	// angle
	g.Rotation.Integrate(n, g.rotDelta, dt)

	// recycle dead
	g.GC(&g.Pool)
}

func (g *GravitySimulator) newParticle(new int) {
	if (g.Live + new) > g.Cap {
		return
	}
	start := g.Live
	g.Live += new

	cfg := g.GravityConfig
	for i := start; i < g.Live; i++ {
		g.Life[i] = math.Random(cfg.Life.Base, cfg.Life.Base+cfg.Life.Var)
		invLife := 1/g.Life[i]

		g.Position[i] = f32.Vec2{cfg.X.Random(), cfg.Y.Random()}
		// Color
		var red, _g, b, a  float32 = 0, 0, 0, 1
		var redd, gd, bd, ad float32

		if cfg.R.Used() {
			red, redd = cfg.R.RangeInit(invLife)
		}
		if cfg.G.Used() {
			_g, gd = cfg.G.RangeInit(invLife)
		}
		if cfg.B.Used() {
			b, bd = cfg.B.RangeInit(invLife)
		}
		if cfg.A.Used() {
			a, ad = cfg.A.RangeInit(invLife)
		}
		g.Color[i] = f32.Vec4{red, _g, b, a}
		g.colorDelta[i] = f32.Vec4{redd, gd, bd, ad}

		g.ParticleSize[i], g.sizeDelta[i] = cfg.Size.RangeInit(invLife)
		// rot
		g.Rotation[i], g.rotDelta[i] = cfg.Rot.RangeInit(invLife)

		// start position
		g.poseStart[i] = g.Position[i]

		// gravity
		g.radialAcc[i] = cfg.RadialAcc.Random()
		g.tangentialAcc[i] = cfg.TangentialAcc.Random()

		// velocity = speed * direction
		a, s := cfg.Angel.Random(), cfg.Speed.Random()
		g.velocity[i] = f32.Vec2{math.Cos(a)*s, math.Sin(a)*s}
	}
}

func (g *GravitySimulator) Visualize(buf []gfx.PosTexColorVertex, tex gfx.Tex2D) {
	g.VisualController.Visualize(buf, tex, g.Live, g.Additive)
}

func (r *GravitySimulator) Size() (live, cap int) {
	return r.Live, r.Cap
}

```

`effect/sim_radius.go`:

```go
package effect

import (
	"korok.io/korok/gfx"
	"korok.io/korok/math/f32"
	"korok.io/korok/math"

)

// RadiusConfig used to configure the RadiusSimulator.
type RadiusConfig struct {
	Config

	Radius Range
	Angle, AngleDelta    Var
}

// RadiusSimulator works as the radius mode of the Cocos2D's particle-system.
type RadiusSimulator struct {
	Pool

	LifeController
	RateController
	VisualController

	poseStart  Channel_v2
	colorDelta Channel_v4
	sizeDelta  Channel_f32
	rot        Channel_f32
	rotDelta   Channel_f32

	angle       Channel_f32
	angleDelta  Channel_f32
	radius      Channel_f32
	radiusDelta Channel_f32

	*RadiusConfig
}

func NewRadiusSimulator(cfg *RadiusConfig) *RadiusSimulator {
	r := &RadiusSimulator{Pool:Pool{Cap: cfg.Max}, RadiusConfig: cfg}
	r.Pool.AddChan(Life)
	r.Pool.AddChan(Position, PositionStart)
	r.Pool.AddChan(Color, ColorDelta)
	r.Pool.AddChan(Size, SizeDelta)
	r.Pool.AddChan(Rotation, RotationDelta)

	r.Pool.AddChan(Angle, AngleDelta)
	r.Pool.AddChan(Radius, RadiusDelta)

	return r
}

// prepare data
func (r *RadiusSimulator) Initialize() {
	r.Pool.Initialize()
	r.Life = r.Field(Life).(Channel_f32)
	r.Position = r.Field(Position).(Channel_v2)
	r.poseStart = r.Field(PositionStart).(Channel_v2)
	r.Color = r.Field(Color).(Channel_v4)
	r.colorDelta = r.Field(ColorDelta).(Channel_v4)
	r.ParticleSize = r.Field(Size).(Channel_f32)
	r.sizeDelta = r.Field(SizeDelta).(Channel_f32)
	r.Rotation = r.Field(Rotation).(Channel_f32)
	r.rotDelta = r.Field(RotationDelta).(Channel_f32)
	r.angle = r.Field(Angle).(Channel_f32)
	r.angleDelta = r.Field(AngleDelta).(Channel_f32)
	r.radius = r.Field(Radius).(Channel_f32)
	r.radiusDelta = r.Field(RadiusDelta).(Channel_f32)

	// init controller
	r.RateController.Initialize(r.Duration, r.RadiusConfig.Rate)
}

func (r *RadiusSimulator) Simulate(dt float32) {
	if new := r.RateController.Rate(dt); new > 0 {
		r.newParticle(new)
	}
	n := int32(r.Live)

	r.Life.Sub(n, dt)
	r.angle.Integrate(n, r.angleDelta, dt)
	r.radius.Integrate(n, r.radiusDelta, dt)

	// 极坐标转换
	for i := int32(0); i < n; i ++ {
		x := float32(math.Cos(r.angle[i])) * r.radius[i]
		y := float32(math.Sin(r.angle[i])) * r.radius[i]
		r.Position[i] = f32.Vec2{x, y}
	}
	r.Color.Integrate(n, r.colorDelta, dt)
	r.ParticleSize.Integrate(n, r.sizeDelta, dt)
	r.Rotation.Integrate(n, r.rotDelta, dt)
	// recycle dead particle
	r.GC(&r.Pool)
}

func (r *RadiusSimulator) newParticle(new int) {
	if (r.Live + new) > r.Cap {
		return
	}
	start := r.Live
	r.Live += new

	cfg := r.RadiusConfig

	for i := start; i < r.Live; i++ {
		r.Life[i] = cfg.Life.Random()
		invLife := 1/r.Life[i]
		r.Position[i] = f32.Vec2{cfg.X.Random(), cfg.Y.Random()}

		// Color
		var red, _g, b, a  float32 = 0, 0, 0, 1
		var redd, gd, bd, ad float32

		if cfg.R.Used() {
			red, redd = cfg.R.RangeInit(invLife)
		}
		if cfg.G.Used() {
			_g, gd = cfg.G.RangeInit(invLife)
		}
		if cfg.B.Used() {
			b, bd = cfg.B.RangeInit(invLife)
		}
		if cfg.A.Used() {
			a, ad = cfg.A.RangeInit(invLife)
		}
		r.Color[i] = f32.Vec4{red, _g, b, a}
		r.colorDelta[i] = f32.Vec4{redd, gd, bd, ad}


		r.ParticleSize[i] = cfg.Size.Start.Random()
		if cfg.Size.Start != cfg.Size.End {
			r.sizeDelta[i] = (cfg.Size.End.Random() - r.ParticleSize[i]) * invLife
		}
		// rot
		r.Rotation[i] = cfg.Rot.Start.Random()
		if cfg.Rot.Start != cfg.Rot.End {
			r.rotDelta[i] = (cfg.Rot.End.Random() - r.Rotation[i]) * invLife
		}
		// start position
		r.poseStart[i] = r.Position[i]

		// radius
		r.radius[i] = cfg.Radius.Start.Random()
		if cfg.Radius.Start != cfg.Radius.End {
			r.radiusDelta[i] = (cfg.Radius.End.Random() - r.Rotation[i]) * invLife
		}
		// angle
		r.angle[i] = cfg.Angle.Random()
		r.angleDelta[i] = cfg.AngleDelta.Random()
	}
}

func (r *RadiusSimulator) Visualize(buf []gfx.PosTexColorVertex, tex gfx.Tex2D) {
	r.VisualController.Visualize(buf, tex, int(r.Live), r.Additive)
}

func (r *RadiusSimulator) Size() (live, cap int) {
	return r.Live, r.Cap
}



```

`effect/sim_snow.go`:

```go
package effect

import (
	"korok.io/korok/math/f32"
	"korok.io/korok/gfx"
	"korok.io/korok/math"
)

// SnowSimulator can simulate snow effect.
type SnowSimulator struct {
	Pool

	RateController
	LifeController
	VisualController

	velocity Channel_v2
	deltaRot Channel_f32

	// Configuration.
	Config struct{
		Duration, Rate float32
		Life Var
		Size Var
		Color f32.Vec4
		Position [2]Var
		Velocity [2]Var
		Rotation Var
	}
}

func NewSnowSimulator(cap int, w, h float32) *SnowSimulator {
	sim := SnowSimulator{Pool: Pool{Cap: cap}}
	sim.AddChan(Life, Size)
	sim.AddChan(Position, Velocity)
	sim.AddChan(Color)
	sim.AddChan(Rotation)
	sim.AddChan(RotationDelta)

	// config
	sim.Config.Duration = math.MaxFloat32
	sim.Config.Rate = float32(cap)/10
	sim.Config.Life = Var{10, 4}
	sim.Config.Color = f32.Vec4{1, 1, 1, 1}
	sim.Config.Size = Var{6, 6}
	sim.Config.Position[0] = Var{0, w}
	sim.Config.Position[1] = Var{h/2, 0}
	sim.Config.Velocity[0] = Var{-10,  20}
	sim.Config.Velocity[1] = Var{-50, 20}
	sim.Config.Rotation    = Var{0, 3.14/180}

	return &sim
}

func (sim *SnowSimulator) Initialize() {
	sim.Pool.Initialize()

	sim.Life = sim.Field(Life).(Channel_f32)
	sim.ParticleSize = sim.Field(Size).(Channel_f32)
	sim.Position = sim.Field(Position).(Channel_v2)
	sim.velocity = sim.Field(Velocity).(Channel_v2)
	sim.Color = sim.Field(Color).(Channel_v4)
	sim.Rotation = sim.Field(Rotation).(Channel_f32)
	sim.deltaRot = sim.Field(RotationDelta).(Channel_f32)

	sim.RateController.Initialize(sim.Config.Duration, sim.Config.Rate)
}

func (sim *SnowSimulator) Simulate(dt float32) {
	if new := sim.Rate(dt); new > 0 {
		sim.NewParticle(new)
	}

	n := int32(sim.Live)

	// update old particle
	sim.Life.Sub(n, dt)

	// position integrate: p' = p + v * t
	sim.Position.Integrate(n, sim.velocity, dt)

	// rotation
	sim.Rotation.Integrate(n, sim.deltaRot, dt)

	// GC
	sim.GC(&sim.Pool)
}


func (sim *SnowSimulator) Size() (live, cap int) {
	return int(sim.Live), sim.Cap
}

func (sim *SnowSimulator) NewParticle(new int) {
	if (sim.Live + new) > sim.Cap {
		return
	}
	start := sim.Live
	sim.Live += new

	for i := start; i < sim.Live; i++ {
		sim.Life[i] = sim.Config.Life.Random()
		sim.Color[i] = sim.Config.Color
		sim.ParticleSize[i] = sim.Config.Size.Random()

		f := sim.ParticleSize[i]/(sim.Config.Size.Base+sim.Config.Size.Var)
		sim.Color[i][3] = f
		sim.Rotation[i] = sim.Config.Rotation.Random()

		px := sim.Config.Position[0].Random()
		py := sim.Config.Position[1].Random()
		sim.Position[i] = f32.Vec2{px, py}

		dx := sim.Config.Velocity[0].Random()
		dy := sim.Config.Velocity[1].Random()
		sim.velocity[i] = f32.Vec2{dx, dy}
	}
}

func (sim *SnowSimulator) Visualize(buf []gfx.PosTexColorVertex, tex gfx.Tex2D) {
	sim.VisualController.Visualize(buf, tex, int(sim.Live), false)
}
```

`effect/simulate.go`:

```go
package effect

import (
	"korok.io/korok/gfx"
	"korok.io/korok/math"
	"korok.io/korok/math/f32"
)

type TwoColor struct {
	One, Other f32.Vec4
	EnableGradient bool
}

func (tc TwoColor) Random() (c f32.Vec4) {
	if f := math.Random(0, 1); tc.EnableGradient {
		c[0] = tc.One[0] + (tc.Other[0]-tc.One[0])*f
		c[1] = tc.One[1] + (tc.Other[1]-tc.One[1])*f
		c[2] = tc.One[2] + (tc.Other[2]-tc.One[2])*f
		c[3] = tc.One[3] + (tc.Other[3]-tc.One[3])*f
	} else {
		if f >= .5 {
			c = tc.Other
		} else {
			c = tc.One
		}
	}
	return
}

// Var define a variable value between [Base-Var/2, Base+Var/2].
type Var struct {
	Base, Var float32
}

// Used returns whether the value is empty.
func (v Var) Used() bool {
	return v.Base != 0 || v.Var != 0
}

// Random returns a value between [Base-Var/2, Base+Var/2].
func (v Var) Random() float32{
	return math.Random(v.Base-v.Var/2 , v.Base+v.Var/2)
}

// Range define a range between [Start, End].
type Range struct {
	Start, End Var
}

// Used returns whether the value is empty.
func (r Range) Used() bool {
	return r.Start.Used() || r.End.Used()
}

// HasRange returns whether Start and End is the same.
func (r Range) HasRange() bool {
	return r.Start != r.End
}

func (r *Range) RangeInit(invLife float32) (start, d float32) {
	start = r.Start.Random()
	if r.Start != r.End {
		d = (r.End.Random() - start) * invLife
	}
	return
}

// Simulator define how a particle-system works.
type Simulator interface {
	// Initialize the particle simulator.
	Initialize()

	// Run the simulator with delta time.
	Simulate(dt float32)

	// Write the result to vertex-buffer.
	Visualize(buf []gfx.PosTexColorVertex, tex gfx.Tex2D)

	// Return the ParticleSize of the simulator.
	Size() (live, cap int)
}

// ParticleSystem lifecycle controller.
type Controller interface {
	Stop()
	Play()
}

// Prewarm particle system
type WarmupController interface {
	Prewarm(t float32)
	WarmTime() float32
}

// TODO:
// Emitter的概念可以提供一种可能：
// 在这里可以通过各种各样的Emitter实现，生成不同的初始粒子位置
// 这样可以实现更丰富的例子形状
// 之前要么认为粒子都是从一个点发射出来的，要么是全屏发射的，这只是hardcode了特殊情况
// 同时通过配置多个Emitter还可以实现交叉堆叠的形状
type Emitter interface {
}

// TODO:
// 基于上面的想法，还可以设计出 Updater 的概念，不同的 Updater 对粒子执行不同的
// 行走路径，这会极大的增加粒子弹性
type Updater interface {

}

// RateController is a helper struct to manage the EmitterRate.
type RateController struct {
	warmupTime float32

	// control emitter-rate
	accTime float32
	threshTime float32

	// lifetime
	lifeTime float32
	duration float32
	stop bool
}

// Initialize init RateController with duration and emitter-rate.
func (ctr *RateController) Initialize(du, rate float32) {
	ctr.duration = du
	if rate == 0 {
		ctr.threshTime = 1.0/60
	} else {
		ctr.threshTime = 1.0/rate
	}
}

// Rate returns new particles that should spawn.
func (ctr *RateController) Rate(dt float32) (n int) {
	ctr.lifeTime += dt
	if ctr.stop || ctr.lifeTime > ctr.duration {
		return
	}
	ctr.accTime += dt
	if ctr.accTime >= ctr.threshTime {
		acc := ctr.accTime
		for d := ctr.threshTime ; acc > d; {
			acc -= d; n++
		}
		ctr.accTime = acc
	}
	return
}

func (ctr *RateController) Stop() {
	ctr.stop = true
}

func (ctr *RateController) Play() {
	ctr.stop = false
	ctr.lifeTime = 0
}

func (ctr *RateController) Prewarm(t float32) {
	ctr.warmupTime = t
}

func (ctr *RateController) WarmTime() float32 {
	return ctr.warmupTime
}

// LifeController is a helper struct to manage the Life of particles.
type LifeController struct {
	// channel ref
	Life Channel_f32
	Live int
}

// GC removes dead particles from the Pool.
func (ctr *LifeController) GC(p *Pool) (dead int){
	i, j := int(0), int(ctr.Live-1)
	for i <= j {
		if ctr.Life[i] <= 0 {
			p.Swap(i, j);j--
		} else {
			i++
		}
	}
	dead = ctr.Live -i
	ctr.Live = i
	return
}

// VisualController is a helper struct to write simulation result to vertex-buffer.
type VisualController struct {
	Position     Channel_v2
	Color        Channel_v4
	ParticleSize Channel_f32
	Rotation     Channel_f32
}

// Visualize write the Live particles to vertex-buffer.
func (ctr *VisualController) Visualize(buf []gfx.PosTexColorVertex, tex gfx.Tex2D, live int, additive bool) {
	size := ctr.ParticleSize
	pose := ctr.Position
	rots := ctr.Rotation

	// compute vbo
	for i := 0; i < live; i ++ {
		vi := i << 2
		size := size[i]
		half := size/2

		var (
			r = math.Clamp(ctr.Color[i][0], 0, 1)
			g = math.Clamp(ctr.Color[i][1], 0, 1)
			b = math.Clamp(ctr.Color[i][2], 0, 1)
			a = math.Clamp(ctr.Color[i][3], 0, 1)
		)

		var c uint32
		if additive {
			c = uint32(b*255) << 16 + uint32(g*255) << 8 + uint32(r*255)
		} else {
			c = uint32(a*255) << 24 + uint32(b*255) << 16 + uint32(g*255) << 8 + uint32(r*255)
		}
		rg := tex.Region()

		// Transform matrix
		m := f32.Mat3{}; m.InitializeScale1(pose[i][0], pose[i][1], rots[i], half, half)

		// bottom-left
		buf[vi+0].X, buf[vi+0].Y = m.Transform(0, 0)
		buf[vi+0].U, buf[vi+0].V = rg.X1, rg.Y1
		buf[vi+0].RGBA = c

		// bottom-right
		buf[vi+1].X, buf[vi+1].Y = m.Transform(size, 0)
		buf[vi+1].U, buf[vi+1].V = rg.X2, rg.Y1
		buf[vi+1].RGBA = c

		// top-right
		buf[vi+2].X, buf[vi+2].Y = m.Transform(size, size)
		buf[vi+2].U, buf[vi+2].V = rg.X2, rg.Y2
		buf[vi+2].RGBA = c

		// top-left
		buf[vi+3].X, buf[vi+3].Y = m.Transform(0, size)
		buf[vi+3].U, buf[vi+3].V  = rg.X1, rg.Y2
		buf[vi+3].RGBA = c
	}
}


// ParticleSimulateSystem is the system that manage ParticleComp's simulation.
type ParticleSimulateSystem struct {
	pst *ParticleSystemTable
}

func NewSimulationSystem () *ParticleSimulateSystem {
	return &ParticleSimulateSystem{}
}

func (pss *ParticleSimulateSystem) RequireTable(tables []interface{}) {
	for _, t := range tables {
		switch table := t.(type) {
		case *ParticleSystemTable:
			pss.pst = table
		}
	}
}

// System 的生命周期中，应该安排一个 Initialize 的阶段
func (pss *ParticleSimulateSystem) Initialize() {}

func (pc *ParticleComp) initialize() {
	sim := pc.sim; sim.Initialize()
	if warmup, ok := sim.(WarmupController); ok && warmup.WarmTime() > 0 {
		pc.warmup(sim, warmup.WarmTime())
	}
}

func (*ParticleComp) warmup(sim Simulator, t float32) {
	for dt := float32(1)/30; t > 0; t -= dt {
		sim.Simulate(dt)
	}
}

// TODO:
// Need a better way to initialize each simulator
func (pss *ParticleSimulateSystem) Update(dt float32) {
	// initialize
	et := pss.pst
	for i, n := 0, et.index; i < n; i++ {
		if comp := et.comps[i]; !comp.init {
			et.comps[i].init = true
			comp.initialize()
		}
	}

	// simulate
	for i, n := 0, et.index; i < n; i++ {
		et.comps[i].sim.Simulate(dt)
	}
}

```

`effect/simulate_test.go`:

```go
package effect

import (
	"testing"
	"korok.io/korok/math/f32"
)

func TestFireSimulator(t *testing.T) {
	fire := NewFireSimulator(1024)
	fire.Initialize()

	for i := 0; i < 10; i++ {
		fire.Simulate(1.0/60)
	}


}

func TestRadiusSimulator(t *testing.T) {
	cfg := &RadiusConfig{
		Config:Config {
			Max:128,
			Duration:0,
			Life:Var{1.1, 0.4},
			Size:Range{Var{10 ,20}, Var{10, 20}},
			X:Var{0, 0}, Y:Var{0, 0},
		},
		Radius:Range{Var{50, 10}, Var{50, 10}},
		Angle:Var{0, 3.14},
	}
	radius := NewRadiusSimulator(cfg)
	radius.Initialize()

	radius.newParticle(2)

	t.Log("Life:", radius.Life[:2])
	t.Log("radius:", radius.radius[:2])
	t.Log("angle:", radius.angle[:2])

	for i := 0; i < 10; i++ {
		radius.Simulate(1.0/60)
	}
}

func TestGravitySimulator(t *testing.T) {
	cfg := &GravityConfig{
		Config:Config {
			Max:128,
			Duration:0,
			Life:Var{1.1, 0.4},
			Size:Range{Var{10 ,5}, Var{20, 5}},
			X:Var{0, 0}, Y:Var{0, 0},
			A: Range{Var{1, 0}, Var{0, 0}},
		},
		Velocity: [2]Var{{10, 0}, {10, 0}},
		Gravity:f32.Vec2{0, 90},
	}
	gravity := NewGravitySimulator(cfg)
	gravity.Initialize()

	gravity.newParticle(2)
	t.Log("Life:", gravity.Life[:2])
	t.Log("velocity:", gravity.velocity[:2])
	t.Log("Position:", gravity.Position[:2])
}

```

`engi/array/map.go`:

```go
package array

const STEP  = 64

type DenseIntMap struct {
	entries []int
}

func (m *DenseIntMap) Grow(size int) {
	slice := make([]int, size)
	copy(slice, m.entries)
	m.entries = slice
}

func (m *DenseIntMap) Compact() {

}

func (m *DenseIntMap) Put(k, v int) {
	if n := len(m.entries); k >= n {
		m.Grow(k + 64)
	}
	m.entries[k] = v
}

func (m *DenseIntMap) Get(k int) (v int, ok bool) {
	if n := len(m.entries); k < n {
		if vv := m.entries[k]; vv != 0 {
			v, ok = vv, true
		}
	}
	return
}

func (m *DenseIntMap) Del(k int) {
	if n := len(m.entries); k < n {
		m.entries[k] = 0
	}
}

func (m *DenseIntMap) Clear() {

}


type SparseIntMap struct {
	keys []int
	vals []int
	used int
}

func (m *SparseIntMap) Grow(size int) {
	newKeys := make([]int, size)
	newVals := make([]int, size)
	copy(newKeys, m.keys)
	copy(newVals, m.vals)
	m.keys = newKeys
	m.vals = newVals
}

func (m *SparseIntMap) Compact() {

}

func (m *SparseIntMap) Put(k, v int) {
	m.keys[m.used] = k
	m.vals[m.used] = v
	m.used ++
}

func (m *SparseIntMap) Get(k int) (v int) {
	v = 0
	return
}

func (m *SparseIntMap) Del(k int) {

}


```

`engi/array/map_test.go`:

```go
package array

import "testing"

func TestDenseMap(t *testing.T) {
	t.Log("Hello")
}
```

`engi/comps.go`:

```go
package engi

// Components
type Component interface {
}

// System
type System interface {
}

// Component Table
type CompTable interface {
}

```

`engi/entity.go`:

```go
package engi

/**
	定义ECS组件: Entity/Component/System

	Entity 仅仅是一个类型为 uint32 的 id， 高8位表示出生代，低24位表示索引。
	因为 Entity 可以被不断的销毁和重建，可以使用高8位来记录在同一个索引位创建的Entity，
	这样最多可以用24位来记录Entity的id，8位记录id复用情况，如此，同一个id在循环了256次
	之后才会出现Entity重复的情况。

	三个主要接口：
	1. Create() Entity
	2. Alive(Entity)
	3. Destroy(Entity)
	增删查
 */

const IndexBits = 24
const IndexMask = (1<< IndexBits)-1

const GenerationBits = 8
const GenerationMask = (1<< GenerationBits)-1

// An invalid entity
const Ghost = Entity(0xFFFFFFFF)

type ComponentType uint16

type Entity uint32

func (e Entity) Index() uint32 {
	return uint32(e) & IndexMask
}

func (e Entity) Gene() uint8 {
	return uint8(e >>IndexBits) & GenerationMask
}

// 要不要用一个数组来管理所有的 Entity-Id 索引？
// 好处是可以方便的跟踪游戏整个生命周期中产生的所有对象.
// 同时需要一个 FreeList 来记录所有的对象.
type EntityManager struct {
	generation []uint8
	freelist   []uint32
	id Entity
}

func NewEntityManager() *EntityManager {
	return &EntityManager{}
}

func (em *EntityManager) New() Entity {
	var ei uint32
	var eg uint8

	if size := len(em.freelist); size > 0 {
		ei, em.freelist = em.freelist[0], em.freelist[1:]
		eg = em.generation[ei]
	} else {
		ei = uint32(len(em.generation))
		em.generation = append(em.generation, 0)
	}
	return Entity((uint32(eg) << IndexBits) | ei)
}

func (em *EntityManager) Alive(e Entity) bool {
	return em.generation[e.Index()] == e.Gene()
}

func (em *EntityManager) Destroy(e Entity) {
	ei := e.Index()
	em.generation[ei] ++
	em.freelist = append(em.freelist, ei)
}

```

`engi/entity_test.go`:

```go
package engi

import (
	"testing"
)

func TestEntityCreate(t *testing.T) {
	em := NewEntityManager()
	e := em.New()

	if !em.Alive(e) {
		t.Error("fail to create entity")
	}

	em.Destroy(e)

	if em.Alive(e) {
		t.Error("fail to destroy entity")
	}

	e1 := em.New()
	if e.Index() != e1.Index() {
		t.Error("fail to reuse index")
	}

	if e1.Gene() != (e.Gene() + 1) {
		t.Error("fail to compute generation")
	}
}
```

`engi/geom/dimen.go`:

```go
package geom

```

`engi/geom/geom.go`:

```go
package geom

```

`game/debug.go`:

```go
package game

type DebugDrawComp struct {

}

```

`game/doc.go`:

```go
package game

/**
	游戏性 - GamePlay

	地图/场景/关卡/任务等游戏相关的概念
 */

```

`game/fps.go`:

```go
package game

import (
	"time"
)

type FPS struct {
	startTime time.Time
	preTime time.Time

	dt, scale float32
	realdt float32
	fps int32
	pause bool
}

func (fps *FPS) initialize() {
	fps.startTime = time.Now()
}

func (fps *FPS) SetScale(factor float32) {
	fps.scale = factor
}

func (fps *FPS) Step() float32 {
	now := time.Now()
	du := now.Sub(fps.preTime); fps.preTime = now
	dt := float32(du)/float32(time.Second)

	fps.dt = float32(dt)
	fps.fps = int32(1/dt)
	return fps.dt
}

func (fps *FPS) Smooth() float32 {
	now := time.Now()
	du := now.Sub(fps.preTime); fps.preTime = now

	var dt float32
	if du < 3*time.Second {
		dt = float32(du)/float32(time.Second)
	} else {
		dt = 1.0/60
	}

	predt := fps.dt
	sdt := predt * .8 + float32(dt*.2)
	fps.dt = sdt
	fps.fps = int32(1/sdt)
	fps.realdt = dt

	return fps.dt
}

func (fps *FPS) Pause() {
	fps.pause = true
}

func (fps *FPS) Resume() {
	fps.pause = false
}

```

`game/game.go`:

```go
package game

import (
	"korok.io/korok/engi"
	"korok.io/korok/gfx"
	"korok.io/korok/effect"
	"korok.io/korok/anim"
	"korok.io/korok/anim/frame"
	"korok.io/korok/asset"
	"korok.io/korok/hid/input"
	"korok.io/korok/gfx/dbg"
	"korok.io/korok/gui"
	"korok.io/korok/audio"

	"log"
	"reflect"
	"time"
)

const (
	MaxScriptSize = 1024

	MaxSpriteSize = 64 << 10
	MaxTransformSize = 64 << 10
	MaxTextSize = 64 << 10
	MaxMeshSize = 64 << 10

	MaxParticleSize = 1024
)


type Options struct {
	W, H int
}

type Table interface{}

type DB struct {
	EntityM *engi.EntityManager
	Tables  []interface{}
}

type appState struct {
	old struct{
		paused bool
		lostFocus bool
	}
	now struct{
		paused bool
		lostFocus bool
	}
	PauseCallback func(paused bool)
	FocusCallback func(focused bool)
}

//func (app appState) Paused() (paused bool, old bool){
//	paused = app.now.paused
//	old = app.old.paused
//	return
//}
//
//func (app appState) Focused() (focused bool, old bool) {
//	focused = !app.now.lostFocus
//	old = !app.old.lostFocus
//	return
//}

func (app *appState) setPaused(paused bool) {
	app.old.paused = app.now.paused
	app.now.paused = paused
}

func (app *appState) setFocused(focused bool) {
	app.old.lostFocus = app.now.lostFocus
	app.now.lostFocus = !focused
}

// 统一管理游戏各个子系统的创建和销毁的地方
var G *Game

type Game struct {
	Options; FPS; DB

	// scene manager
	SceneManager

	// system
	*gfx.RenderSystem
	*input.InputSystem
	*effect.ParticleSimulateSystem
	*ScriptSystem
	*anim.AnimationSystem

	// game state
	appState
}

func (g *Game) Camera() *gfx.Camera {
	return &g.RenderSystem.MainCamera
}

/// window callback
func (g *Game) OnCreate(w, h float32, ratio float32) {
	g.Create(w, h, ratio)
}

func (g *Game) OnLoop() {
	g.Update()
}

func (g *Game) OnDestroy() {
	g.Destroy()
}

func (g *Game) OnPause() {
	g.notifyPause()
}

func (g *Game) OnResume() {
	g.notifyResume()
}

func (g *Game) OnFocusChanged(focused bool) {
	g.appState.setFocused(focused)
	if fn := g.FocusCallback; fn != nil {
		fn(focused)
	}
	log.Println("window focuse changed !!", focused)
}

/// input callback
func (g *Game) OnKeyEvent(key int, pressed bool) {
	g.InputSystem.SetKeyEvent(key, pressed)
}

func (g *Game) OnPointEvent(key int, pressed bool, x, y float32) {
	g.InputSystem.SetPointerEvent(key, pressed, x, y)
}

func (g *Game) OnResize(w, h int32) {
	g.setGameSize(float32(w), float32(h))
}

func (g *Game) setGameSize(w, h float32) {
	// setup camera
	if rs := g.RenderSystem; rs != nil {
		rs.MainCamera.SetViewPort(w, h)
	}

	// gui real screen size
	gui.SetScreenSize(w, h)
}

// init subsystem
func (g *Game) Create(w, h float32, ratio float32) {
	g.FPS.initialize()
	gfx.Init(ratio)
	audio.Init()

	// render system
	rs := gfx.NewRenderSystem()
	g.RenderSystem = rs

	// init game window size
	g.setGameSize(w, h); g.MainCamera.MoveTo(w/2, h/2)

	// set table
	rs.RequireTable(g.DB.Tables)
	// set render
	var vertex, color string

	vertex, color = asset.Shader.GetShaderStr("batch")
	batchRender := gfx.NewBatchRender(vertex, color)
	rs.RegisterRender(gfx.RenderType(0), batchRender)

	vertex, color = asset.Shader.GetShaderStr("mesh")
	meshRender := gfx.NewMeshRender(vertex, color)
	rs.RegisterRender(gfx.RenderType(1), meshRender)

	// set feature
	srf := &gfx.SpriteRenderFeature{}
	srf.Register(rs)
	mrf := &gfx.MeshRenderFeature{}
	mrf.Register(rs)
	trf := &gfx.TextRenderFeature{}
	trf.Register(rs)

	// gui system
	ui := &gui.UIRenderFeature{}
	ui.Register(rs)

	/// init debug
	dbg.Init(g.Options.W, g.Options.H)

	/// input system
	g.InputSystem = input.NewInputSystem()

	/// particle-simulation system
	pss := effect.NewSimulationSystem()
	pss.RequireTable(g.DB.Tables)
	g.ParticleSimulateSystem = pss
	// set feature
	prf := &effect.ParticleRenderFeature{}
	prf.Register(rs)

	/// script system
	g.ScriptSystem = NewScriptSystem()
	g.ScriptSystem.RequireTable(g.DB.Tables)

	/// Tex2D animation system
	g.AnimationSystem = anim.NewAnimationSystem()
	g.AnimationSystem.RequireTable(g.DB.Tables)
	anim.SetDefaultAnimationSystem(g.AnimationSystem)

	// audio system

	/// setup scene manager
	g.SceneManager.Setup(g)

	log.Println("Load Feature:", len(rs.FeatureList))
	for i, v := range rs.FeatureList {
		log.Println(i, " feature - ", reflect.TypeOf(v))
	}
}

// destroy subsystem
func (g *Game) Destroy() {
	// clear scene stack
	g.SceneManager.Clear()

	// destroy other system
	g.RenderSystem.Destroy()

	// dbg system
	dbg.Destroy()

	// audio system
	audio.Destroy()
}

func (g *Game) notifyPause() {
	g.setPaused(true)
	if fn := g.PauseCallback; fn != nil {
		fn(true)
	}
	log.Println("game paused..")
}

func (g *Game) notifyResume() {
	g.setPaused(false)
	if fn := g.PauseCallback; fn != nil {
		fn(false)
	}
	log.Println("game resumed..")
}

func (g *Game) Init() {
	g.loadTables()
}

func (g *Game) loadTables() {
	g.DB.EntityM = engi.NewEntityManager()

	// init tables
	scriptTable := NewScriptTable(MaxScriptSize)
	tagTable := &TagTable{}

	g.DB.Tables = append(g.DB.Tables, scriptTable, tagTable)

	spriteTable := gfx.NewSpriteTable(MaxSpriteSize)
	meshTable := gfx.NewMeshTable(MaxMeshSize)
	xfTable := gfx.NewTransformTable(MaxTransformSize)
	textTable := gfx.NewTextTable(MaxTextSize)

	g.DB.Tables = append(g.DB.Tables, spriteTable, meshTable, xfTable, textTable)

	psTable := effect.NewParticleSystemTable(MaxParticleSize)
	g.DB.Tables = append(g.DB.Tables, psTable)

	spriteAnimTable := frame.NewFlipbookTable(MaxSpriteSize)
	g.DB.Tables = append(g.DB.Tables, spriteAnimTable)
}

func (g *Game) Input(dt float32) {

}

func (g *Game) Update() {
	// update
	dt := g.FPS.Smooth()

	// ease cpu usage TODO
	if g.now.paused || (g.now.lostFocus && dt < 0.016) {
		time.Sleep(time.Duration((0.016-dt)*1000)*time.Millisecond)
	}

	// update input-system
	g.InputSystem.AdvanceFrame()

	// update scene
	g.SceneManager.Update(dt)

	// update script
	g.ScriptSystem.Update(dt)

	g.InputSystem.Reset()

	//// simulation....

	// update sprite animation
	g.AnimationSystem.Update(dt)

	/// 动画更新，骨骼数据
	///g.AnimationSystem.Update(dt)

	// g.CollisionSystem.Update(dt)

	// 粒子系统更新
	g.ParticleSimulateSystem.Update(dt)

	// Render
	g.RenderSystem.Update(dt)

	// fps & profile
	g.DrawProfile()

	//bk.Dump()
	audio.AdvanceFrame()

	// flush drawCall
	num := gfx.Flush()

	// drawCall = all-drawCall - camera-drawCall
	dc := num - len(g.RenderSystem.RenderList)
	dbg.LogFPS(int(g.fps), dc)
}

func (g *Game) DrawProfile() {
	// Advance frame
	dbg.AdvanceFrame()
}

func (g *Game) Draw(dt float32) {
}

```

`game/prof.go`:

```go
package game



```

`game/scene.go`:

```go
package game

type LoaderState struct {
	progress int
	done bool
}

type AsyncHandler chan bool

// Loader
type Loader interface {
	Load()
}

type UnLoader interface {
	Unload()
}

// Scene has lifecycle callback.
// OnEnter is called when the scene is shown.
// Update is called each frame.
// OnExit is called when the scene is hided.
type Scene interface {
	OnEnter(g *Game)
	Update(dt float32)
	OnExit()
}

// SceneManager manages scenes.
type SceneManager struct {
	g *Game

	stack []Scene
	hScene Scene
}

// 设计合理的异步加载方案：TODO
func (*SceneManager) Load(sn Scene) {
	if loader, ok := sn.(Loader); ok {
		loader.Load()
	}
}

func (*SceneManager) UnLoad(sn Scene) {
	if loader, ok := sn.(UnLoader); ok {
		loader.Unload()
	}
}

func (sm *SceneManager) Setup(g *Game) {
	sm.g = g

	// special case for default scene.
	if h := sm.hScene; h != nil {
		if loader, ok := h.(Loader); ok {
			loader.Load()
		}
		h.OnEnter(g)
	}
}

func (sm *SceneManager) Update(dt float32) {
	if h := sm.hScene; h != nil {
		h.Update(dt)
	}
}

// SetDefault sets the default Scene before the Game start.
// It's designed for internal usage. You should not use it.
func (sm *SceneManager) SetDefault(sn Scene) {
	sm.hScene = sn
	sm.stack = append(sm.stack, sn)
}

func (sm *SceneManager) Push(sn Scene) {
	if h := sm.hScene; h != nil {
		h.OnExit()
	}

	sm.hScene = sn
	sm.stack = append(sm.stack, sn)

	// setup
	sn.OnEnter(sm.g)
}

func (sm *SceneManager) Pop() (sn Scene, ok bool) {
	if size := len(sm.stack); size > 0 {
		sn = sm.stack[size-1]
		ok = true
		sm.stack = sm.stack[:size-1]
		sn.OnExit()
		sm.UnLoad(sn)

		if next := size-2; next >= 0 {
			sn := sm.stack[next]
			sm.hScene = sn
			sn.OnEnter(sm.g)
		}
	}
	return
}

func (sm *SceneManager) Peek() (sn Scene, ok bool) {
	if size := len(sm.stack); size > 0 {
		sn = sm.stack[size-1]
		ok = true
	}
	return
}

func (sm *SceneManager) Clear() {
	for i := len(sm.stack)-1; i >= 0; i-- {
		sm.stack[i].OnExit()
	}
}


```

`game/script.go`:

```go
package game

import "korok.io/korok/engi"

/**
	游戏对象绑定脚本/行为
 */

type Script interface {
	Init()

	Update(dt float32)

	Destroy()
}

type ScriptComp struct {
	engi.Entity
	Script
}

func (sc *ScriptComp) SetScript(script Script) {
	sc.Script = script
}

type ScriptTable struct {
	comps []ScriptComp
	_map   map[uint32]int
	index, cap int
}

func NewScriptTable(cap int) *ScriptTable {
	return &ScriptTable{cap: cap, _map: make(map[uint32]int)}
}

func (st *ScriptTable) NewComp(entity engi.Entity, script Script) (sc *ScriptComp) {
	if size := len(st.comps); st.index >= size {
		st.comps = scriptResize(st.comps, size + 64)
	}
	ei := entity.Index()
	if v, ok := st._map[ei]; ok {
		return &st.comps[v]
	}
	sc = &st.comps[st.index]
	sc.Entity = entity
	sc.Script = script
	st._map[ei] = st.index
	st.index ++
	return
}

func (st *ScriptTable) Alive(entity engi.Entity) bool {
	if v, ok := st._map[entity.Index()]; ok {
		return st.comps[v].Entity == 0
	}
	return false
}

func (st *ScriptTable) Comp(entity engi.Entity) (sc *ScriptComp) {
	if v, ok := st._map[entity.Index()]; ok {
		sc = &st.comps[v]
	}
	return
}

func (st *ScriptTable) Delete(entity engi.Entity) {
	ei := entity.Index()
	if v, ok := st._map[ei]; ok {
		if tail := st.index -1; v != tail && tail > 0 {
			st.comps[v] = st.comps[tail]
			// remap index
			tComp := &st.comps[tail]
			ei := tComp.Entity.Index()
			st._map[ei] = v
			tComp.Entity = 0
		} else {
			st.comps[tail].Entity = 0
		}

		st.index -= 1
		delete(st._map, ei)
	}
}

func (st *ScriptTable) Size() (size, cap int) {
	return st.index, st.cap
}

func scriptResize(slice []ScriptComp, size int) []ScriptComp {
	newSlice := make([]ScriptComp, size)
	copy(newSlice, slice)
	return newSlice
}

type ScriptSystem struct {
	*ScriptTable
}

func NewScriptSystem() *ScriptSystem {
	return &ScriptSystem{}
}
func (ss *ScriptSystem) RequireTable(tables []interface{}) {
	for _, t := range tables {
		switch table := t.(type) {
		case *ScriptTable:
			ss.ScriptTable = table
		}
	}
}

func (ss *ScriptSystem) Update(dt float32) {
	N := ss.ScriptTable.index
	comps := ss.ScriptTable.comps
	for i := 0; i < N; i++ {
		if script := comps[i].Script; script != nil {
			script.Update(dt)
		}
	}
}




```

`game/table_test.go`:

```go
package game

import (
	"testing"
	"korok.io/korok/engi"
)

// Test CRUD operation for MeshTable
func TestScriptTable(t *testing.T) {
	em := &engi.EntityManager{}
	st := NewScriptTable(1024)

	e1 := em.New()
	xf1 := st.NewComp(e1, nil)

	if xf := st.Comp(e1); xf != xf1 {
		t.Error("fail to create Comp")
	}

	st.Delete(e1)
	if xf := st.Comp(e1); xf != nil {
		t.Error("fail to delete Comp")
	}

	if size, _ := st.Size(); size != 0 {
		t.Error("fail to reset Table state")
	}

	// create 10
	eList := make([]engi.Entity, 10)
	for i := 0; i < 10; i++ {
		e := em.New()
		st.NewComp(e, nil)
		eList[i] = e
	}

	if size, _ := st.Size(); size != len(eList) {
		t.Error("fail to create 10 Comps")
	}

	// delete 5
	for i, e := range eList {
		if i % 2 == 0 {
			st.Delete(e)
		}
	}

	if size, _ := st.Size(); size != len(eList)/2 {
		t.Error("fail to delete Comps")
	}

	// test left
	for i, e := range eList {
		if i % 2 == 1 {
			if comp := st.Comp(e); comp == nil || comp.Entity != e {
				t.Error("fail to keep entity:", e)
			}
		} else {
			if st.Comp(e) != nil {
				t.Error("fail to delete Comps:", e)
			}
		}
	}


}

// step=64
func TestScripTableResize(t *testing.T) {
	em := &engi.EntityManager{}
	st := NewScriptTable(1024)

	list30 := make([]engi.Entity, 30)
	for i := 0; i < 30; i++ {
		e := em.New()
		st.NewComp(e, nil)
		list30[i] = e
	}

	// will cause resize
	list100 := make([]engi.Entity, 100)
	for i := 0; i < 100; i++ {
		e := em.New()
		st.NewComp(e, nil)
		list100[i] = e
	}

	if size, _ := st.Size(); size != (len(list30) + len(list100)) {
		t.Errorf("fail to create Comps: %d/%d", size, len(list30) + len(list100))
	}

	list := append(list100, list30...)
	for _, e := range list {
		if xf := st.Comp(e); xf == nil || xf.Entity != e {
			t.Error("comp is not create correctly")
		}
	}
}



// Test CRUD operation for MeshTable
func TestTagTable(t *testing.T) {
	em := &engi.EntityManager{}
	st := NewTagTable(1024)

	e1 := em.New()
	xf1 := st.NewComp(e1)

	if xf := st.Comp(e1); xf != xf1 {
		t.Error("fail to create Comp")
	}

	st.Delete(e1)
	if xf := st.Comp(e1); xf != nil {
		t.Error("fail to delete Comp")
	}

	if size, _ := st.Size(); size != 0 {
		t.Error("fail to reset Table state")
	}

	// create 10
	eList := make([]engi.Entity, 10)
	for i := 0; i < 10; i++ {
		e := em.New()
		st.NewComp(e)
		eList[i] = e
	}

	if size, _ := st.Size(); size != len(eList) {
		t.Error("fail to create 10 Comps")
	}

	// delete 5
	for i, e := range eList {
		if i % 2 == 0 {
			st.Delete(e)
		}
	}

	if size, _ := st.Size(); size != len(eList)/2 {
		t.Error("fail to delete Comps")
	}

	// test left
	for i, e := range eList {
		if i % 2 == 1 {
			if comp := st.Comp(e); comp == nil || comp.Entity != e {
				t.Error("fail to keep entity:", e)
			}
		} else {
			if st.Comp(e) != nil {
				t.Error("fail to delete Comps:", e)
			}
		}
	}


}

// step=64
func TestTagTableResize(t *testing.T) {
	em := &engi.EntityManager{}
	st := NewScriptTable(1024)

	list30 := make([]engi.Entity, 30)
	for i := 0; i < 30; i++ {
		e := em.New()
		st.NewComp(e, nil)
		list30[i] = e
	}

	// will cause resize
	list100 := make([]engi.Entity, 100)
	for i := 0; i < 100; i++ {
		e := em.New()
		st.NewComp(e, nil)
		list100[i] = e
	}

	if size, _ := st.Size(); size != (len(list30) + len(list100)) {
		t.Errorf("fail to create Comps: %d/%d", size, len(list30) + len(list100))
	}

	list := append(list100, list30...)
	for _, e := range list {
		if xf := st.Comp(e); xf == nil || xf.Entity != e {
			t.Error("comp is not create correctly")
		}
	}
}

```

`game/tag.go`:

```go
package game

import "korok.io/korok/engi"

/**
标记并分类游戏对象, 在 Tag (Name) 的基础上再加一个 Label，作为二级分类，
在游戏中，很多时候是需要这样的二级分类的。比如: enemy {bullet, ship}

http://bitsquid.blogspot.se/2015/06/allocation-adventures-1-datacomponent.html
http://bitsquid.blogspot.com/2015/06/allocation-adventures-2-arrays-of-arrays.html

关于 string 比较的问题，还需要研究：https://stackoverflow.com/questions/20232976/how-does-go-do-string-comparison

关于 Tag 系统的设计，可以学下一下
 */
type TagComp struct {
	engi.Entity
	Name, Label string
}

// TODO 如何高效的存储和查找tag数据？
type TagTable struct {
	comps []TagComp
	_map   map[uint32]int
	index, cap int

	d map[string][]engi.Entity
}

func NewTagTable(cap int) *TagTable {
	return &TagTable{cap: cap, _map: make(map[uint32]int)}
}

func (tt *TagTable) NewComp(entity engi.Entity) (tc *TagComp) {
	if size := len(tt.comps); tt.index >= size {
		tt.comps = tagResize(tt.comps, size+64)
	}
	ei := entity.Index()
	if v, ok := tt._map[ei]; ok {
		return &tt.comps[v]
	}
	tc = &tt.comps[tt.index]
	tc.Entity = entity
	tt._map[entity.Index()] = tt.index
	tt.index ++
	return
}

func (tt *TagTable) Alive(entity engi.Entity) bool {
	if v, ok := tt._map[entity.Index()]; ok {
		return tt.comps[v].Entity == 0
	}
	return false
}

func (tt *TagTable) Comp(entity engi.Entity) (tc *TagComp) {
	if v, ok := tt._map[entity.Index()]; ok {
		tc = &tt.comps[v]
	}
	return
}

func (tt *TagTable) Delete(entity engi.Entity) (tc *TagComp) {
	ei := entity.Index()
	if v, ok := tt._map[ei]; ok {
		if tail := tt.index-1; v != tail && tail > 0 {
			tt.comps[v] = tt.comps[tail]
			// remap index
			tComp := &tt.comps[tail]
			ei := tComp.Entity.Index()
			tt._map[ei] = v
			tComp.Entity = 0
		} else {
			tt.comps[tail].Entity = 0
		}
		tt.index -= 1
		delete(tt._map, ei)
	}
	return nil
}

// 删除所有属于该标签的元素..
func (tt *TagTable) DeleteTag(entity engi.Entity) {

}

// 这个效率非常低，因为Group一次要对所有的Entity做一次线性的
// 查找..
func (tt *TagTable) Group(tag string) []engi.Entity {
	list := make([]engi.Entity, 0)
	for _, comp := range tt.comps {
		if comp.Name == tag {
			list = append(list, comp.Entity)
		}
	}
	return list
}

func (tt *TagTable) Size() (size, cap int) {
	return tt.index, tt.cap
}

func tagResize(slice []TagComp, size int) []TagComp {
	newSlice := make([]TagComp, size)
	copy(newSlice, slice)
	return newSlice
}


```

`gfx/R.go`:

```go
package gfx

import (
	"korok.io/korok/gfx/bk"
	"unsafe"
)

// Tex2D is a Texture or a SubTexture
type Tex2D interface {
	// return texture id
	Tex() uint16
	// uv
	Region() Region
	// size
	Size() Size
}

// Anchor type
type Anchor uint8
const(
	ANCHOR_CENTER Anchor = 0x00
	ANCHOR_LEFT          = 0x01
	ANCHOR_RIGHT         = 0x02
	ANCHOR_UP  			 = 0x04
	ANCHOR_DOWN          = 0x08
)

type Size struct {
	Width, Height float32
}

type Region struct {
	X1, Y1 float32
	X2, Y2 float32
	Rotated bool
}


type bkTex struct {
	id, padding uint16
}

func (tex bkTex) Tex() uint16 {
	return uint16(tex.id)
}

func (tex bkTex) Region() Region {
	return Region{0, 0, 1, 1, false}
}

func (tex bkTex) Size() (sz Size) {
	if ok, t := bk.R.Texture(uint16(tex.id)); ok {
		sz = Size{t.Width, t.Height}
	}
	return
}

func NewTex(id uint16) Tex2D {
	return bkTex{id:id}
}

// SubTexture = (atlas-id << 16) + SubTexture-id
type SubTex struct {
	id uint32
}

func (tex SubTex) Tex() uint16 {
	return R.texId(tex.id)
}

func (tex SubTex) Region() Region {
	return R.region(tex.id)
}

func (tex SubTex) Size() Size {
	return R.size(tex.id)
}

func (tex SubTex) Id() (atlas, index int) {
	atlas = int(tex.id >> 16)
	index = int(tex.id & 0xFFFF)
	return
}

// A small struct to describe a group of sub-texture
type Atlas struct {
	id, aid uint16

	w, h float32

	// compiled sub-texture coordinate
	regions []Region

	// size of sub-texture
	sizes []Size

	// name of this atlas
	names map[string]int

	// start index and size
	index, size uint16
}

func (at *Atlas) initialize(size int) {
	var (
		szRegion = size * int(sizeOfRegion)
		szSize   = size * int(sizeOfSize)
	)

	buffer := make([]byte, szRegion + szSize)
	at.regions = (*[1<<16]Region)(unsafe.Pointer(&buffer[0]))[:size]
	at.sizes = (*[1<<16]Size)(unsafe.Pointer(&buffer[szRegion]))[:size]
	at.names = make(map[string]int, size)
	at.index = 0
	at.size = uint16(size)
}

func (at *Atlas) release() {
	at.regions = nil
	at.sizes = nil
	at.names = nil
}

func (at *Atlas) AddItem(x, y, w, h float32, name string, rotated bool) {
	ii := at.index; at.index++

	at.sizes[ii] = Size{w, h}
	at.names[name] = int(ii)

	if rotated {
		at.regions[ii] = Region{
			X1: x/at.w, Y1: y/at.h,
			X2: (x+h)/at.w, Y2:(y+w)/at.h,
			Rotated:true,
		}
	} else {
		at.regions[ii] = Region{
			X1: x/at.w, Y1: y/at.h,
			X2: (x+w)/at.w, Y2:(y+h)/at.h,
		}
	}
}

func (at *Atlas) GetByName(name string) (tex SubTex, ok bool) {
	if v, ook := at.names[name]; ook {
		ok = true
		tex = SubTex{uint32(at.aid) << 16 + uint32(v)}
	}
	return
}

func (at *Atlas) GetByIndex(index int) (tex SubTex, ok bool) {
	if index < int(at.size) {
		ok = true
		tex = SubTex{uint32(at.aid) << 16 + uint32(index)}
	}
	return
}

func (at *Atlas) Region(ii int) Region {
	return at.regions[ii]
}

func (at *Atlas) Size(ii int) Size {
	return at.sizes[ii]
}

// Texture Resource Manager
type TexManager struct {
	atlases []Atlas
	frees []uint16

	// name to id
	names map[string]int

	// index and capacity
	index, cap uint16
}

// 纹理图集的管理是以纹理为单位.
func (tm *TexManager) NewAtlas(id uint16, size int, name string) (at *Atlas){
	if n := len(tm.frees); n > 0 {
		at = &tm.atlases[tm.frees[size-1]]
		tm.frees = tm.frees[:size-1]
	} else {
		ii := len(tm.atlases)
		tm.atlases = append(tm.atlases, Atlas{aid:uint16(ii)})
		at = &tm.atlases[ii]
		tm.names[name] = ii
	}

	at.initialize(size)
	at.id = id
	_, tex := bk.R.Texture(id)
	at.w, at.h = tex.Width, tex.Height

	return
}

func (tm *TexManager) Delete(name string) {
	if ii, ok := tm.names[name]; ok {
		tm.atlases[ii].release()
		tm.frees = append(tm.frees, uint16(ii))
		delete(tm.names, name)
	}
}

func (tm *TexManager) Atlas(name string) (at *Atlas) {
	if ii, ok := tm.names[name]; ok {
		at = &tm.atlases[ii]
	}
	return
}

// Region returns sub-texture's Region by id.
func (tm *TexManager) region(id uint32) (rg Region) {
	var (
		ai = id >> 16
		ii = id & 0xFFFF
	)
	at := tm.atlases[ai]
	rg = at.regions[ii]
	return
}

// Size returns sub-texture's Size by id.
func (tm *TexManager) size(id uint32) (sz Size) {
	var (
		ai = id >> 16
		ii = id & 0xFFFF
	)
	at := tm.atlases[ai]
	sz = at.sizes[ii]
	return
}

func (tm *TexManager) texId(id uint32) uint16 {
	return tm.atlases[id>>16].id
}

// TextureManager as a global variable.
var R *TexManager

// init
func init() {
	R = &TexManager{names:make(map[string]int, 0)}

	sizeOfRegion = unsafe.Sizeof(Region{})
	sizeOfSize = unsafe.Sizeof(Size{})
}

var sizeOfRegion uintptr
var sizeOfSize uintptr

```

`gfx/batch.go`:

```go
package gfx

/**
Batch 系统设计
对所有物体进行分类：静态和动态，静态物体使用稳定的batch系统，动态物体每次重新计算batch

静态：
使用稳定的batch面临的最大问题是，batch内存的物体的可见性问题。如果batch内的物体有的可见，
有的不可见（有可能是不再视野内，也有可能是主动隐藏）. 采用 unity 方案，只减少状态切换，不减少 drawcall 的做法，
实现比较简单（否则要面临修改VBO缓存的问题）。

动态：
动态Batch每次都需要重新构建，只要实现正确的合并算法即可。

暗示：在 sortkey 中提供一个字段 batch=0 (默认情况使用动态batch)，batch=1,2..N 的情况按batch值进行
分批处理。
优化：按照空间划分可以得到不同子空间的batch，可以在batch中再做一次筛选滤掉不可见的物体。

渲染：
静态系统，按照 batch-id 找到对应的batch数据，生成渲染命令
动态系统，直接合并数据并生成渲染命令

目前Batch实现只支持格式：pos_uv_color
 */
type Batch struct {
	TextureId uint16
	depth     int16

	VertexId  uint16
	IndexId   uint16

	firstVertex uint16
	numVertex   uint16

	firstIndex uint16
	numIndex   uint16
}

type BatchObject interface {
	Fill(vertex []PosTexColorVertex)
	Size() int
}

type SortObject struct {
	SortId uint32
	Value  uint32
}

```

`gfx/batch_render.go`:

```go
package gfx

import (
	"korok.io/korok/math/f32"
	"korok.io/korok/gfx/bk"

	"unsafe"
	"log"
)

// Batch Render:
// Use PosTexColorVertex struct with P4C4 format

/// A Tex2D Batch TypeRender
type BatchRender struct {
	stateFlags uint64
	rgba       uint32

	// shader program
	program uint16

	// uniform handle
	umhProjection uint16 // Projection
	umhSampler0   uint16 // Sampler0

	// batch context
	BatchContext
}

func NewBatchRender(vsh, fsh string) *BatchRender {
	br := new(BatchRender)

	// setup state
	br.stateFlags |= bk.ST_BLEND.ALPHA_PREMULTIPLIED

	// setup shader
	if shId, sh := bk.R.AllocShader(vsh, fsh); shId != bk.InvalidId {
		br.program = shId
		sh.Use()

		// setup attribute
		sh.AddAttributeBinding("xyuv\x00", 0, P4C4[0])
		sh.AddAttributeBinding("rgba\x00", 0, P4C4[1])

		s0 := int32(0)
		// setup uniform
		if id, _ := bk.R.AllocUniform(shId, "proj\x00", bk.UniformMat4, 1); id != bk.InvalidId {
			br.umhProjection = id
		}
		if id, _ := bk.R.AllocUniform(shId, "tex\x00", bk.UniformSampler, 1); id != bk.InvalidId {
			br.umhSampler0 = id
			bk.SetUniform(id, unsafe.Pointer(&s0))
		}
		//bk.Touch(0)
		bk.Submit(0, shId, 0)
	}
	// setup batch context
	br.BatchContext.init()
	return br
}

func (br *BatchRender) SetCamera(camera *Camera) {
	left, right, bottom, top := camera.P()
	p := f32.Ortho2D(left, right, bottom, top)

	// setup uniform
	bk.SetUniform(br.umhProjection, unsafe.Pointer(&p[0]))
	bk.Submit(0, br.program, 0)
}

// submit all batched group
func (br *BatchRender) submit(bList []Batch) {
	for i := range bList {
		b := &bList[i]

		// state
		bk.SetState(br.stateFlags, br.rgba)
		bk.SetTexture(0, br.umhSampler0, b.TextureId, 0)

		// set vertex
		bk.SetVertexBuffer(0, b.VertexId, uint32(b.firstVertex), uint32(b.numVertex) )
		bk.SetIndexBuffer(b.IndexId, uint32(b.firstIndex), uint32(b.numIndex))

		// submit draw-call
		bk.Submit(0, br.program, int32(b.depth))
	}
}

func (br *BatchRender) Begin(tex uint16, depth int16) {
	br.BatchContext.begin(tex, depth)
}

func (br *BatchRender) Draw(b BatchObject) {
	br.BatchContext.drawComp(b)
}

func (br *BatchRender) End() {
	br.BatchContext.end()
}

func (br *BatchRender) Flush() (num int) {
	bc := &br.BatchContext
	num = bc.batchUsed

	// flush unclosed vertex buffer
	if bc.vertexPos > 0 {
		bc.flushBuffer()
	}

	// submit
	br.submit(bc.BatchList[:bc.batchUsed])

	// reset batch state
	bc.reset()

	return
}

// 目前采用提前申请好大块空间的方式，会导致大量的内存浪费
// 之后可以把vbo管理起来，按需使用

// ~ 640k per-batch, 32k vertex, 8k quad
const MAX_BATCH_QUAD_SIZE   = uint32(8<<10)
const MAX_BATCH_VERTEX_SIZE = 4 * MAX_BATCH_QUAD_SIZE

// 管理一或多个Batch实例
// 最多可以生成 128 个 Batch 分组
// 最多可以使用 8 个 VBO 缓存
type BatchContext struct {
	vertex []PosTexColorVertex
	vertexPos uint32
	firstVertex uint32

	// state
	batchUsed int
	texId     uint16
	depth     int16

	// batch-list
	BatchList [128]Batch
}

func (bc *BatchContext)init() {
	// init shared vertex
	bc.vertex = make([]PosTexColorVertex, MAX_BATCH_VERTEX_SIZE)
	bc.batchUsed = 0
}

func (bc *BatchContext) begin(tex uint16, depth int16) {
	bc.texId = tex
	bc.depth = depth
	bc.firstVertex = bc.vertexPos
}

// 计算世界坐标并保存到 Batch 结构
//
//   3 ---- 2
//   | `    |
//   |   `  |
//   0------1

func (bc *BatchContext) drawComp(b BatchObject) {
	step := uint32(b.Size())

	if bc.vertexPos + step > MAX_BATCH_VERTEX_SIZE {
		bc.flushBuffer()
		bc.end()

		bc.vertexPos = 0
		bc.firstVertex = 0
	}

	buf := bc.vertex[bc.vertexPos:bc.vertexPos+step]
	bc.vertexPos = bc.vertexPos+step
	b.Fill(buf)
}

// commit a batch
func (bc *BatchContext) end() {
	if bc.batchUsed >= 128 {
		log.Printf("Batch List out of size:(%d, %d) ", 128, bc.batchUsed)
	}

	batch := &bc.BatchList[bc.batchUsed]
	batch.TextureId = bc.texId
	batch.depth = bc.depth

	batch.VertexId = bk.InvalidId
	batch.firstVertex = 0 //uint16(bc.firstVertex)
	batch.numVertex = uint16(bc.vertexPos-bc.firstVertex)
	batch.firstIndex = uint16(bc.firstVertex/4 * 6)
	batch.numIndex = uint16(batch.numVertex/4 * 6)

	bc.batchUsed += 1
}

// upload buffer
func (bc *BatchContext) reset() {
	bc.texId = 0
	bc.firstVertex = 0
	bc.vertexPos = 0
	bc.batchUsed = 0
}

// flushBuffer() will write and switch vertex-buffer
// we must submit batch with a end() method
func (bc *BatchContext) flushBuffer() {
	var (
		reqSize = int(bc.vertexPos)
		stride = 20
	)

	iid, _ := Context.SharedIndexBuffer()
	vid, _, vb := Context.TempVertexBuffer(reqSize, stride)

	// flush vertex-buffer
	vb.Update(0, bc.vertexPos * uint32(stride), unsafe.Pointer(&bc.vertex[0]), false)

	// backward rewrite vertex-buffer id
	for i := bc.batchUsed; i >= 0; i-- {
		if b := &bc.BatchList[i]; b.VertexId == bk.InvalidId {
			b.VertexId = vid
			b.IndexId  = iid
		}
	}
}


```

`gfx/bk/R.go`:

```go
package bk

import (
	"korok.io/korok/hid/gl"

	"log"
	"unsafe"
	"image"
)

/// 在 2D 引擎中，GPU 资源的使用时很有限的，
/// 大部分图元会在 Batch 环节得到优化，最终生成有限的渲染指令.
/// Id从1开始，0作为Invalid-Id比0xFFFF有很多天然的好处

const InvalidId uint16 = 0x0000
const UInt16Max uint16 = 0xFFFF

const (
	IdMask      uint16 = 0x0FFF
	IdTypeShift        = 12
)

type Memory struct {
	Data unsafe.Pointer
	Size uint32
}

// ID FORMAT
// 0x F   FFF
//    ^    ^
//    |    +---- id value
//    +--------- id type
const (
	IdTypeIndex   uint16 = iota
	IdTypeVertex
	IdTypeTexture
	IdTypeLayout
	IdTypeUniform
	IdTypeShader
)

const (
	MaxIndex   = 2 << 10
	MaxVertex  = 2 << 10
	MaxTexture = 1 << 10
	MaxUniform = 32 * 8
	MaxShader  = 32
)

type FreeList struct {
	slots []uint16
}

func (fl *FreeList) Pop() (slot uint16, ok bool) {
	if size := len(fl.slots); size > 0 {
		slot = fl.slots[size-1]
		ok = true
		fl.slots = fl.slots[:size-1]
	}
	return
}

func (fl *FreeList) Push(slot uint16) {
	fl.slots = append(fl.slots, slot)
}

type ResManager struct {
	indexBuffers  [MaxIndex]IndexBuffer
	vertexBuffers [MaxVertex]VertexBuffer
	textures      [MaxTexture]Texture2D

	uniforms [MaxUniform]Uniform
	shaders  [MaxShader]Shader

	ibIndex uint16
	vbIndex uint16
	ttIndex uint16
	vlIndex uint16
	umIndex uint16
	shIndex uint16

	// free list
	ibFrees FreeList
	vbFrees FreeList
	ttFrees FreeList
	umFrees FreeList
	shFrees FreeList
}

func NewResManager() *ResManager {
	return &ResManager{}
}

// skip first index - 0
func (rm *ResManager) Init() {
	if rm.ibIndex == 0 {
		rm.ibIndex ++
		rm.vbIndex ++
		rm.ttIndex ++
		rm.vlIndex ++
		rm.umIndex ++
		rm.shIndex ++
	}
}

func (rm *ResManager) Destroy() {

}

// AllocIndexBuffer alloc a new Index-Buffer, Return the resource handler.
func (rm *ResManager) AllocIndexBuffer(mem Memory) (id uint16, ib *IndexBuffer) {
	if index, ok := rm.ibFrees.Pop(); ok {
		id = index
		ib = &rm.indexBuffers[index]
	} else {
		id, ib = rm.ibIndex, &rm.indexBuffers[rm.ibIndex]
		rm.ibIndex++
	}
	id = id | (IdTypeIndex << IdTypeShift)

	if err := ib.Create(mem.Size, mem.Data, 0); err != nil {
		log.Println("fail to alloc index-buffer, ", err)
	} else {
		if gDebug&DebugResMan != 0 {
			log.Printf("alloc index-buffer: (%d, %d)", id&IdMask, ib.Id)
		}
	}
	return
}

// AllocVertexBuffer alloc a new Vertex-Buffer, Return the resource handler.
func (rm *ResManager) AllocVertexBuffer(mem Memory, stride uint16) (id uint16, vb *VertexBuffer) {
	if index, ok := rm.vbFrees.Pop(); ok {
		id = index
		vb = &rm.vertexBuffers[index]
	} else {
		id, vb = rm.vbIndex, &rm.vertexBuffers[rm.vbIndex]
		rm.vbIndex++
	}
	id = id | (IdTypeVertex << IdTypeShift)
	if err := vb.Create(mem.Size, mem.Data, stride, 0); err != nil {
		log.Println("fail to alloc vertex-buffer, ", err)
	} else {
		if  gDebug&DebugResMan != 0 {
			log.Printf("alloc vertex-buffer: (%d, %d)", id&IdMask, vb.Id)
		}
	}
	return
}

// AllocUniform get the uniform slot in a shader program, Return the resource handler.
func (rm *ResManager) AllocUniform(shId uint16, name string, xType UniformType, num uint32) (id uint16, um *Uniform) {
	if index, ok := rm.umFrees.Pop(); ok {
		id = index
		um = &rm.uniforms[index]
	} else {
		id, um = rm.umIndex, &rm.uniforms[rm.umIndex]
		rm.umIndex++
	}
	id = id | (IdTypeUniform << IdTypeShift)
	if ok, sh := rm.Shader(shId); ok {
		if um.create(sh.Program, name, xType, num) < 0 {
			log.Printf("fail to alloc uniform - %s, make sure shader %d in use", name, shId&IdMask)
		} else {
			if (gDebug & DebugResMan) != 0 {
				log.Printf("alloc uniform: (%d, %d) => %s", id&IdMask, um.Slot, name)
			}
		}
	}
	return
}

// AllocTexture upload image to GPU, Return the resource handler.
func (rm *ResManager) AllocTexture(img image.Image) (id uint16, tex *Texture2D) {
	if index, ok := rm.ttFrees.Pop(); ok {
		id = index
		tex = &rm.textures[index]
	} else {
		id, tex = rm.ttIndex, &rm.textures[rm.ttIndex]
		rm.ttIndex ++
	}
	id = id | (IdTypeTexture << IdTypeShift)
	if err := tex.Create(img); err != nil {
		log.Printf("fail to alloc texture, %s", err)
	} else {
		if (gDebug & DebugResMan) != 0 {
			log.Printf("alloc texture id: (%d, %d)", id&IdMask, tex.Id)
		}
	}
	return
}

// AllocShader compile and link the Shader source code, Return the resource handler.
func (rm *ResManager) AllocShader(vsh, fsh string) (id uint16, sh *Shader) {
	if index, ok := rm.shFrees.Pop(); ok {
		id = index
		sh = &rm.shaders[index]
	} else {
		id, sh = rm.shIndex, &rm.shaders[rm.shIndex]
		rm.shIndex++
	}
	id = id | (IdTypeShader << IdTypeShift)

	if err := sh.Create(vsh, fsh); err != nil {
		log.Println("fail to alloc shader, ", err)
	} else {
		if (gDebug & DebugResMan) != 0 {
			log.Printf("alloc shader id:(%d, %d) ", id&IdMask, sh.Program)
		}
	}
	return
}

// Free free all resource managed by R. Including index-buffer, vertex-buffer,
// texture, uniform and shader program.
func (rm *ResManager) Free(id uint16) {
	t := (id >> IdTypeShift) & 0x000F
	v := id & IdMask

	switch t {
	case IdTypeIndex:
		rm.indexBuffers[v].Destroy()
		rm.ibFrees.Push(v)
	case IdTypeVertex:
		rm.vertexBuffers[v].Destroy()
		rm.vbFrees.Push(v)
	case IdTypeTexture:
		rm.textures[v].Destroy()
		rm.ttFrees.Push(v)
	case IdTypeLayout:
		// todo
	case IdTypeUniform:
		rm.umFrees.Push(v)
	case IdTypeShader:
		rm.shaders[v].Destroy()
		rm.shFrees.Push(v)
	}
}

// IndexBuffer returns the low-level IndexBuffer struct.
func (rm *ResManager) IndexBuffer(id uint16) (ok bool, ib *IndexBuffer) {
	t, v := id>>IdTypeShift, id&IdMask
	if t != IdTypeIndex || v >= MaxIndex {
		return false, nil
	}
	return true, &rm.indexBuffers[v]
}

// VertexBuffer returns the low-level VertexBuffer struct.
func (rm *ResManager) VertexBuffer(id uint16) (ok bool, vb *VertexBuffer) {
	t, v := id>>IdTypeShift, id&IdMask
	if t != IdTypeVertex || v >= MaxVertex {
		return false, nil
	}
	return true, &rm.vertexBuffers[v]
}

// Texture returns the low-level Texture struct.
func (rm *ResManager) Texture(id uint16) (ok bool, tex *Texture2D) {
	t, v := id >>IdTypeShift, id&IdMask
	if t != IdTypeTexture || v >= MaxTexture {
		return false, nil
	}
	return true, &rm.textures[v]
}

// Uniform returns the low-level Uniform struct.
func (rm *ResManager) Uniform(id uint16) (ok bool, um *Uniform) {
	t, v := id>>IdTypeShift, id&IdMask
	if t != IdTypeUniform || v >= MaxUniform {
		return false, nil
	}
	return true, &rm.uniforms[v]
}

// Shader returns the low-level Shader struct.
func (rm *ResManager) Shader(id uint16) (ok bool, sh *Shader) {
	t, v := id>>IdTypeShift, id&IdMask
	if t != IdTypeShader || v >= MaxShader {
		if (gDebug & DebugResMan) != 0 {
			log.Printf("Invalid shader id:(%d, %d, %d)", id, t, v)
		}
		return false, nil
	}
	return true, &rm.shaders[v]
}

////// MAX SIZE
var MAX = struct {
}{}

////// STATE MASK AND VALUE DEFINES

var ST = struct {
	RGB_WRITE   uint64
	ALPHA_WRITE uint64
	DEPTH_WRITE uint64

	DEPTH_TEST_MASK  uint64
	DEPTH_TEST_SHIFT uint64

	BLEND_MASK  uint64
	BLEND_SHIFT uint64

	PT_MASK  uint64
	PT_SHIFT uint64
}{
	RGB_WRITE:   0x0000000000000001,
	ALPHA_WRITE: 0x0000000000000002,
	DEPTH_WRITE: 0x0000000000000004,

	DEPTH_TEST_MASK:  0x00000000000000F0,
	DEPTH_TEST_SHIFT: 4,

	BLEND_MASK:  0x0000000000000F00,
	BLEND_SHIFT: 8,

	PT_MASK:  0x000000000000F000,
	PT_SHIFT: 12,
}

// zero means no depth-test
var ST_DEPTH = struct {
	LESS     uint64
	LEQUAL   uint64
	EQUAL    uint64
	GEQUAL   uint64
	GREATER  uint64
	NOTEQUAL uint64
	NEVER    uint64
	ALWAYS   uint64
}{
	LESS:     0x0000000000000010,
	LEQUAL:   0x0000000000000020,
	EQUAL:    0x0000000000000030,
	GEQUAL:   0x0000000000000040,
	GREATER:  0x0000000000000050,
	NOTEQUAL: 0x0000000000000060,
	NEVER:    0x0000000000000070,
	ALWAYS:   0x0000000000000080,
}

var g_CmpFunc = []uint32{
	0, // ignored
	gl.LESS,
	gl.LEQUAL,
	gl.EQUAL,
	gl.GEQUAL,
	gl.GREATER,
	gl.NOTEQUAL,
	gl.NEVER,
	gl.ALWAYS,
}

// zero means no blend
var ST_BLEND = struct {
	DEFAULT                 uint64
	ISABLE                  uint64
	ALPHA_PREMULTIPLIED     uint64
	ALPHA_NON_PREMULTIPLIED uint64
	ADDITIVE                uint64
}{
	ISABLE:                  0x0000000000000100,
	ALPHA_PREMULTIPLIED:     0x0000000000000200,
	ALPHA_NON_PREMULTIPLIED: 0x0000000000000300,
	ADDITIVE:                0x0000000000000400,
}

var g_Blend = []struct {
	Src, Dst uint32
}{
	{0, 0},
	{gl.ONE, gl.ZERO},
	{gl.ONE, gl.ONE_MINUS_SRC_ALPHA},
	{gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA},
	{gl.SRC_ALPHA, gl.ONE},
}

var ST_PT = struct {
	TRIANGLES      uint64
	TRIANGLE_STRIP uint64
	LINES          uint64
	LINE_STRIP     uint64
	POINTS         uint64
}{
	TRIANGLES:      0x0000000000000000,
	TRIANGLE_STRIP: 0x0000000000001000,
	LINES:          0x0000000000002000,
	LINE_STRIP:     0x0000000000003000,
	POINTS:         0x0000000000004000,
}

var g_PrimInfo = []uint32{
	gl.TRIANGLES,
	gl.TRIANGLE_STRIP,
	gl.LINES,
	gl.LINE_STRIP,
	gl.POINTS,
}

/// STATE ENCODE FORMAT - bgfx
// 64bit:
//
//                                0-4 func ----------+            rgb-dst
//                                               +   |  a-dsr        |  rgb-src +--------- 1 - 8 depth-function
//                  independent|alpha_cover --+  |   |    |    a-src |    |     |     +--- depth_write | alpha_write | rgb_write
//                                            |  |   |    |     |    |    |     |     |
// 000000000 000 0000 0-000 0000-0000-00 00 + 00 00-0000 0000-0000-0000-0000  0000-0 000
//            |    |     |      |        |
//            |    |     |      |        +---- CULL_CCW | CW
//            |    |     |      +------------- Alpha Ref Value (255)
//            |    |     +-------------------- Primitive Type
//            |    +-------------------------- Point Size (16)
//            +------------------------------- Conservative Raster | LineAA | MSAA

```

`gfx/bk/bk.go`:

```go
// bk-api provide low-level graphics api.
package bk

import (
	"korok.io/korok/math/f32"
	"unsafe"
	"log"
)

// SetDebug set debug Flags, DebugResMan enable ResourceManager's log output and
// DebugQueue enable RenderQueue's log output.
func SetDebug(debug uint32) {
	gDebug = debug
}

// Init init the bk-api.
func Init() {
	R.Init()
	gRenderQ.Init()
}

// Reset resets RenderContext's internal state, such as frame-buffer size.
func Reset(width, height uint32, pixelRatio float32) {
	gRenderQ.Reset(uint16(width), uint16(height), pixelRatio)
}

// Destroy release any resource used by the bk-api.
func Destroy() {
	gRenderQ.Destroy()
	R.Destroy()
}

// SetState set render's states for drawCall primitive.
// State flags is defined  by ST_BLEND.
func SetState(state uint64, rgba uint32) {
	gRenderQ.SetState(state, rgba)
}

// SetIndexBuffer sets index buffer for drawCall primitive.
func SetIndexBuffer(id uint16, firstIndex, num uint32) {
	gRenderQ.SetIndexBuffer(id, uint16(firstIndex), uint16(num))
}

// SetVertexBuffer sets vertex buffer for drawCall primitive.
func SetVertexBuffer(stream uint8, id uint16, firstVertex, numVertex uint32) {
	gRenderQ.SetVertexBuffer(stream, id, uint16(firstVertex), uint16(numVertex))
}

// SetSprite sets texture stages for drawCall primitive.
func SetTexture(stage uint8, sampler uint16, handle uint16, flags uint32) {
	gRenderQ.SetTexture(stage, sampler, handle, flags)
}

// SetTransform sets Model matrix.
func SetTransform(mtx *f32.Mat4) {
	gRenderQ.SetTransform(mtx)
}

// SetUniform sets shader uniform parameter for drawCall primitive.
func SetUniform(id uint16, ptr unsafe.Pointer) {
	gRenderQ.SetUniform(id, ptr)
}

// SetStencil sets stencil test state.
func SetStencil(stencil uint32) {
	gRenderQ.SetStencil(stencil)
}

// SetScissor set scissor for drawCall primitive. Return a cached ScissorRect handler.
func SetScissor(x, y, width, height uint16) uint16 {
	return gRenderQ.SetScissor(x, y, width, height)
}

// SetScissorCached set scissor rect with a cached ScissorRect handler.
func SetScissorCached(id uint16) {
	gRenderQ.SetScissorCached(id)
}

// SetViewScissor view scissor. Draw primitive outsize view will be clipped. When
// x, y, with, height are set to 0, scissor will be disabled.
func SetViewScissor(id uint8, x, y, width, height uint16) {
	gRenderQ.SetViewScissor(id, x, y, width, height)
}

func SetViewPort(id uint8, x, y, width, height uint16) {
	gRenderQ.SetViewPort(id, x, y, width, height)
}

// Set view clear Flags. rgba is Color clear value(default = 0x000000ff), depth is Depth clear value
// (default = 1.0), stencil is Stencil clear value(default = 0).
func SetViewClear(id uint8, flags uint16, rgba uint32, depth float32, stencil uint8) {
	gRenderQ.SetViewClear(id, flags, rgba, depth, stencil)
}

// SetViewTransform sets view and projection matrices, all drawCall primitives in this
// view will use these matrices.
func SetViewTransform(id uint8, view, proj *f32.Mat4, flags uint8) {
	gRenderQ.SetViewTransform(id, view, proj, flags)
}

// Submit an empty primitive for rendering. Uniforms and drawCall state
// will be applied but no geometry will be submitted. These empty drawCall
// calls will sort before ordinary drawCall calls.
func Touch(id uint8) uint32 {
	return Submit(id, InvalidId, 0)
}

// Submit primitive for rendering. Default depth is zero.
// Returns Number of drawCall calls.
func Submit(id uint8, program uint16, depth int32) uint32 {
	return gRenderQ.Submit(id, program, depth)
}

// Reset DrawCall state
func ResetDrawCall() {
	gRenderQ.drawCall.reset()
}

// Execute final draw
func Flush() int {
	return gRenderQ.Flush()
}

func Dump() {
	size := gRenderQ.drawCallNum;
	drawCall := gRenderQ.drawCallList[:size]
	log.Println("drawCall:", drawCall)
}

// Global Resources Manager!
var R *ResManager

const (
	DebugResMan uint32 = 0x000000001
	DebugQueue  uint32 = 0x000000002
)

// -- private field
var gDebug uint32
var gRenderQ *RenderQueue

func init() {
	R = NewResManager()
	// after res-manager!
	gRenderQ = NewRenderQueue(R)
}

```

`gfx/bk/buffer.go`:

```go
package bk

import (
	"korok.io/korok/hid/gl"

	"log"
	"unsafe"
	"errors"
)

type IndexBuffer struct {
	Id    uint32
	size  uint32
	flags uint16
}

func (ib *IndexBuffer) Create(size uint32, data unsafe.Pointer, flags uint16) error{
	ib.size = size
	ib.flags = flags

	gl.GenBuffers(1, &ib.Id)

	if 0 == ib.Id {
		return errors.New("failed to generate buffer id")
	}

	gl.BindBuffer(gl.ELEMENT_ARRAY_BUFFER, ib.Id)
	if data == nil {
		gl.BufferData(gl.ELEMENT_ARRAY_BUFFER, int(size), nil, gl.DYNAMIC_DRAW)
	} else {
		gl.BufferData(gl.ELEMENT_ARRAY_BUFFER, int(size), data, gl.STATIC_DRAW)
	}
	gl.BindBuffer(gl.ELEMENT_ARRAY_BUFFER, 0)

	return nil
}

/// discard=false
func (ib *IndexBuffer) Update(offset uint32, size uint32, data unsafe.Pointer, discard bool) {
	if 0 == ib.Id {
		log.Println("updating invalid index buffer")
	}

	if discard {
		// orphan buffer
		ib.Destroy()
		ib.Create(ib.size, nil, ib.flags)
	}

	gl.BindBuffer(gl.ELEMENT_ARRAY_BUFFER, ib.Id)
	gl.BufferSubData(gl.ELEMENT_ARRAY_BUFFER, int(offset), int(size), data)
	gl.BindBuffer(gl.ELEMENT_ARRAY_BUFFER, 0)
}

func (ib *IndexBuffer) Destroy() {
	gl.BindBuffer(gl.ELEMENT_ARRAY_BUFFER, 0)
	gl.DeleteBuffers(1, &ib.Id)
}

type VertexBuffer struct {
	Id     uint32
	target uint32
	size   uint32
	layout uint16 // Stride | Offset
}

/// draw indirect >= es 3.0 or gl 4.0
func (vb *VertexBuffer) Create(size uint32, data unsafe.Pointer, layout uint16, flags uint16) error{
	vb.size = size
	vb.layout = layout
	vb.target = gl.ARRAY_BUFFER

	gl.GenBuffers(1, &vb.Id)
	if vb.Id == 0 {
		return errors.New("failed to generate buffer id")
	}
	gl.BindBuffer(vb.target, vb.Id)
	if data == nil {
		gl.BufferData(vb.target, int(size), data, gl.DYNAMIC_DRAW)
	} else {
		gl.BufferData(vb.target, int(size), data, gl.STATIC_DRAW)
	}
	gl.BindBuffer(vb.target, 0)
	return nil
}

/// discard = false
func (vb *VertexBuffer) Update(offset uint32, size uint32, data unsafe.Pointer, discard bool) {
	if vb.Id == 0 {
		log.Println("Updating invalid vertex buffer")
	}

	if discard {
		vb.Destroy()
		vb.Create(vb.size, nil, vb.layout, 0)
	}

	gl.BindBuffer(vb.target, vb.Id)
	gl.BufferSubData(vb.target, int(offset), int(size), data)
	gl.BindBuffer(vb.target, 0)
}

func (vb *VertexBuffer) Destroy() {
	gl.BindBuffer(gl.ARRAY_BUFFER, 0)
	gl.DeleteBuffers(1, &vb.Id)
}

```

`gfx/bk/queue.go`:

```go
package bk

import (
	"korok.io/korok/math/f32"
	"log"
	"unsafe"
	"sort"
)

type SortMode int

const (
	Sequential SortMode = iota
	Ascending
	Descending
)

type Rect struct {
	x, y uint16
	w, h uint16
}

func (r *Rect) clear() {
	r.x, r.y = 0, 0
	r.w, r.h = 0, 0
}

func (r *Rect) isZero() bool {
	u64 := (*uint64)(unsafe.Pointer(r))
	return *u64 == 0
}

type Stream struct {
	vertexBuffer uint16
	vertexFormat uint16 // Offset | Stride， not used now!!

	firstVertex uint16
	numVertex   uint16
}

type RenderDraw struct {
	indexBuffer   uint16
	vertexBuffers [2]Stream
	textures      [2]uint16

	// index params
	firstIndex, num uint16

	// uniform range
	uniformBegin uint16
	uniformEnd   uint16

	// stencil and scissor
	stencil uint32
	scissor uint16

	// required renderer state
	state uint64
}

func (rd *RenderDraw) reset() {
	rd.indexBuffer = 0
	rd.firstIndex, rd.num = 0, 0
	rd.scissor = 0
}

// ~ 8000 draw call
const MAX_QUEUE_SIZE = 8 << 10

type RenderQueue struct {
	SortMode
	// render list
	sortKey    [MAX_QUEUE_SIZE]uint64
	sortValues [MAX_QUEUE_SIZE]uint16

	drawCallList [MAX_QUEUE_SIZE]RenderDraw
	drawCallNum  uint16

	sk SortKey

	// per-drawCall state cache
	drawCall RenderDraw

	uniformBegin uint16
	uniformEnd   uint16

	// per-frame state
	viewports [4]Rect
	scissors  [4]Rect
	clears    [4]struct {
		index   [8]uint8
		rgba    uint32
		depth   float32
		stencil uint8
		flags   uint16
	}

	// per-frame data flow
	rm *ResManager
	ub *UniformBuffer

	// render context
	ctx *RenderContext
}

func NewRenderQueue(m *ResManager) *RenderQueue {
	ub := NewUniformBuffer()
	rc := NewRenderContext(m, ub)
	return &RenderQueue{
		ctx: rc,
		rm:  m,
		ub:  ub,
	}
}

func (rq *RenderQueue) Init() {
	rq.ctx.Init()
}

// reset frame-buffer size
func (rq *RenderQueue) Reset(w, h uint16, pr float32) {
	rq.ctx.wRect.w = w
	rq.ctx.wRect.h = h
	rq.ctx.pixelRatio = pr
}

func (rq *RenderQueue) Destroy() {
	//
}

func (rq *RenderQueue) SetState(state uint64, rgba uint32) {
	rq.drawCall.state = state
}

func (rq *RenderQueue) SetIndexBuffer(id uint16, firstIndex, num uint16) {
	rq.drawCall.indexBuffer = id & IdMask
	rq.drawCall.firstIndex = firstIndex
	rq.drawCall.num = num
}

func (rq *RenderQueue) SetVertexBuffer(stream uint8, id uint16, firstVertex, numVertex uint16) {
	if stream < 0 || stream >= 2 {
		log.Printf("Not support stream location: %d", stream)
		return
	}

	vbStream := &rq.drawCall.vertexBuffers[stream]
	vbStream.vertexBuffer = id & IdMask
	vbStream.vertexFormat = InvalidId
	vbStream.firstVertex = firstVertex
	vbStream.numVertex = numVertex
}

func (rq *RenderQueue) SetTexture(stage uint8, samplerId uint16, texId uint16, flags uint32) {
	if stage < 0 || stage >= 2 {
		log.Printf("Not suppor texture location: %d", stage)
		return
	}

	rq.drawCall.textures[stage] = texId & IdMask
}

// 复制简单数据的时候（比如：Sampler），采用赋值的方式可能更快 TODO
func (rq *RenderQueue) SetUniform(id uint16, ptr unsafe.Pointer) {
	if ok, um := rq.rm.Uniform(id); ok {
		opCode := Uniform_encode(um.Type, um.Slot, um.Size, um.Count)
		rq.ub.WriteUInt32(opCode)
		rq.ub.Copy(ptr, uint32(um.Size)*uint32(um.Count))
	}
}

// Transform 是 uniform 之一，2D 世界可以省略
func (rq *RenderQueue) SetTransform(mtx *f32.Mat4) {
	// TODO impl
}

func (rq *RenderQueue) SetStencil(stencil uint32) {
	rq.drawCall.stencil = stencil
}

func (rq *RenderQueue) SetScissor(x, y, width, height uint16) (id uint16) {
	id = rq.ctx.AddClipRect(x, y, width, height)
	rq.drawCall.scissor = id
	return id
}

func (rq *RenderQueue) SetScissorCached(id uint16) {
	rq.drawCall.scissor = id
}

/// View Related Setting
func (rq *RenderQueue) SetViewScissor(id uint8, x, y, with, height uint16) {
	if id < 0 || id >= 4 {
		log.Printf("Not support view id: %d", id)
		return
	}
	rq.scissors[id] = Rect{x, y, with, height}
}

func (rq *RenderQueue) SetViewPort(id uint8, x, y, width, height uint16) {
	if id < 0 || id >= 4 {
		log.Printf("Not support view id: %d", id)
		return
	}
	rq.viewports[id] = Rect{x, y, width, height}
}

func (rq *RenderQueue) SetViewClear(id uint8, flags uint16, rgba uint32, depth float32, stencil uint8) {
	if id < 0 || id >= 4 {
		log.Printf("Not support view id: %d", id)
		return
	}
	clear := &rq.clears[id]
	clear.flags = flags
	clear.rgba = rgba
	clear.depth = depth
	clear.stencil = stencil
}

func (rq *RenderQueue) SetViewTransform(id uint8, view, proj *f32.Mat4, flags uint8) {

}

// conversion: depth range [-int16, int16]
func (rq *RenderQueue) Submit(id uint8, program uint16, depth int32) uint32 {
	// uniform range
	rq.uniformEnd = uint16(rq.ub.GetPos())

	// encode sort-key
	sk := &rq.sk
	sk.Layer = uint16(id)
	sk.Order = uint16(depth+0xFFFF>>1)

	sk.Shader = program & IdMask // trip type
	sk.Blend = 0
	sk.Texture = rq.drawCall.textures[0]

	rq.sortKey[rq.drawCallNum] = rq.sk.Encode()
	rq.sortValues[rq.drawCallNum] = rq.drawCallNum

	// copy data
	rq.drawCall.uniformBegin = rq.uniformBegin
	rq.drawCall.uniformEnd = rq.uniformEnd

	rq.drawCallList[rq.drawCallNum] = rq.drawCall
	rq.drawCallNum++

	// reset state
	rq.drawCall.reset()
	rq.uniformBegin = uint16(rq.ub.GetPos())

	// return frame Num
	return 0
}

/// 执行最终的绘制
func (rq *RenderQueue) Flush() int {
	num := rq.drawCallNum

	var (
		sortKeys = rq.sortKey[:num]
		sortVals = rq.sortValues[:num]
		drawList = rq.drawCallList[:num]
	)

	// Sort by SortKey
	switch rq.SortMode {
	case Ascending:
		sort.Stable(ByKeyAscending{sortKeys, sortVals})
	case Descending:
		sort.Stable(ByKeyDescending{sortKeys, sortVals})
	}

	// Draw respect to sorted values
	rq.ctx.Draw(sortKeys, sortVals, drawList)

	// Clear counter
	rq.drawCallNum = 0
	rq.uniformBegin = 0
	rq.uniformEnd = 0
	rq.ub.Reset()
	rq.ctx.Reset()

	return int(num)
}

// For 2D games, batch-system will reduce draw-call obviously,
// A simple default sort method will be OK.

// sort draw-call based on SortKey
type ByKeyAscending struct {
	k []uint64
	v []uint16
}

func (a ByKeyAscending) Len() int           {
	return len(a.k)
}

func (a ByKeyAscending) Swap(i, j int)      {
	a.k[i], a.k[j] = a.k[j], a.k[i]
	a.v[i], a.v[j] = a.v[j], a.v[i]
}

func (a ByKeyAscending) Less(i, j int) bool {
	return a.k[i] < a.k[j]
}

type ByKeyDescending struct {
	k []uint64
	v []uint16
}

func (a ByKeyDescending) Len() int           {
	return len(a.k)
}

func (a ByKeyDescending) Swap(i, j int)      {
	a.k[i], a.k[j] = a.k[j], a.k[i]
	a.v[i], a.v[j] = a.v[j], a.v[i]
}

func (a ByKeyDescending) Less(i, j int) bool {
	return a.k[i] > a.k[j]
}




```

`gfx/bk/renderc.go`:

```go
package bk

import (
	"log"

	"korok.io/korok/hid/gl"
)

type RenderContext struct {
	// data
	R  *ResManager
	ub *UniformBuffer

	// draw state
	vao        uint32
	vaoSupport bool

	// window rect
	wRect Rect
	// pixel-ratio = windows-size/frame-buffer-size
	pixelRatio float32

	// clips rect, index-0 is a default zero-rect.
	clips []Rect

	backBufferFbo uint32
}

func NewRenderContext(r *ResManager, ub *UniformBuffer) *RenderContext {
	return &RenderContext{
		R:     r,
		ub:    ub,
		clips: make([]Rect, 1),
	}
}

func (ctx *RenderContext) Init() {
	ctx.vaoSupport = gl.NeedVao()
	if ctx.vaoSupport {
		gl.GenVertexArrays(1, &ctx.vao)
	}
}

func (ctx *RenderContext) Shutdown() {
	if ctx.vao != 0 {
		gl.BindVertexArray(0)
		gl.DeleteVertexArrays(1, &ctx.vao)
	}
}

// Reset OpenGL state, then each frame has same starting state.
func (ctx *RenderContext) Reset() {
	ctx.clips = ctx.clips[:1]
	gl.Disable(gl.SCISSOR_TEST)
}

func (ctx *RenderContext) AddClipRect(x, y, w, h uint16) uint16 {
	index := uint16(len(ctx.clips))
	ratio := ctx.pixelRatio
	ctx.clips = append(ctx.clips, Rect{
		uint16(float32(x) * ratio),
		uint16(float32(y) * ratio),
		uint16(float32(w) * ratio),
		uint16(float32(h) * ratio)})
	return index
}

func (ctx *RenderContext) Draw(sortKeys []uint64, sortValues []uint16, drawList []RenderDraw) {
	// if vao support
	if defaultVao := ctx.vao; 0 != defaultVao {
		gl.BindVertexArray(defaultVao)
	}

	// init per-draw state
	var (
		currentState = RenderDraw{}
		shaderId     = InvalidId
		key          = SortKey{}
		primIndex    = uint8(uint64(0) >> ST.PT_SHIFT)
		prim         = g_PrimInfo[primIndex]
		stateBits    = ST.DEPTH_WRITE | ST.DEPTH_TEST_MASK | ST.RGB_WRITE | ST.ALPHA_WRITE | ST.BLEND_MASK | ST.PT_MASK
	)

	// Let's Render!!
	for item := range sortKeys {
		encodedKey := sortKeys[item]
		itemId := sortValues[item]
		key.Decode(encodedKey)

		draw := drawList[itemId]

		// 1. 求取变化的状态位
		newFlags := draw.state
		changedFlags := currentState.state ^ draw.state
		currentState.state = newFlags

		newStencil := draw.stencil
		changedStencil := currentState.stencil ^ draw.stencil
		currentState.stencil = newStencil

		// 2. Scissor
		if scissor := draw.scissor; currentState.scissor != scissor {
			currentState.scissor = scissor
			clip := ctx.clips[scissor]

			if clip.isZero() {
				gl.Disable(gl.SCISSOR_TEST)
			} else {
				gl.Enable(gl.SCISSOR_TEST)
				gl.Scissor(int32(clip.x), int32(clip.y), int32(clip.w), int32(clip.h))
			}
		}

		// 3. stencil
		if changedStencil != 0 {
			if newStencil != 0 {
				if (gDebug & DebugQueue) != 0 {
					log.Println("Renderc disable stencil")
				}
				gl.Enable(gl.STENCIL_TEST)
			} else {
				gl.Disable(gl.STENCIL_TEST)
				if (gDebug & DebugQueue) != 0 {
					log.Println("Renderc enable stencil")
				}
			}
		}

		// 4. state binding
		if (stateBits & changedFlags) != 0 {
			ctx.bindState(changedFlags, newFlags)
			pt := newFlags & ST.PT_MASK
			primIndex = uint8(pt >> ST.PT_SHIFT)
			prim = g_PrimInfo[primIndex]
		}

		var programChanged bool
		//var bindAttribs bool
		//var constantsChanged bool

		// 5. Update program
		if key.Shader != shaderId {
			shaderId = key.Shader
			var id = ctx.R.shaders[shaderId].GLShader.Program
			gl.UseProgram(id)
			programChanged = true
			//constantsChanged = true
			//bindAttribs = true
			//log.Println("bind program")
		}

		// 6. uniform binding
		if draw.uniformBegin < draw.uniformEnd {
			ctx.bindUniform(uint32(draw.uniformBegin), uint32(draw.uniformEnd))
		}

		// 7. texture binding 如果纹理的采样类型变化，也要重新绑定！！
		for stage := 0; stage < 2; stage++ {
			bind := draw.textures[stage]
			current := currentState.textures[stage]
			if InvalidId != bind {
				if current != bind || programChanged {
					texture := ctx.R.textures[bind]
					texture.Bind(int32(stage))
				}
			}
			currentState.textures[stage] = bind
		}

		// 8. index & vertex binding TODO 优化 attribute 绑定
		shader := ctx.R.shaders[shaderId]
		shader.BindAttributes(ctx.R, draw.vertexBuffers[:])

		if ib := draw.indexBuffer; ib != InvalidId && ib != currentState.indexBuffer {
			gl.BindBuffer(gl.ELEMENT_ARRAY_BUFFER, ctx.R.indexBuffers[ib].Id)
			currentState.indexBuffer = ib
		}

		// 9. draw
		if draw.indexBuffer != InvalidId {
			offset := int(draw.firstIndex) * 2 // 2 = sizeOf(unsigned_short)
			gl.DrawElements(prim, int32(draw.num), gl.UNSIGNED_SHORT, offset)
		} else {
			gl.DrawArrays(prim, int32(draw.firstIndex), int32(draw.num))
		}
	}
}

func (ctx *RenderContext) updateResolution() {

}

func (ctx *RenderContext) bindUniform(begin, end uint32) {
	ctx.ub.Seek(begin)

	for ub := ctx.ub; ub.GetPos() < end; {
		opcode := ub.ReadUInt32()

		if opcode == uint32(UniformEnd) {
			break
		}

		var uType, loc, size, num uint8
		Uniform_decode(opcode, &uType, &loc, &size, &num)
		data := ub.ReadPointer(uint32(size) * uint32(num))

		switch UniformType(uType) {
		case UniformInt1:
			gl.Uniform1iv(int32(loc), int32(num), (*int32)(data))
		case UniformVec1:
			gl.Uniform1fv(int32(loc), int32(num), (*float32)(data))
		case UniformVec4:
			gl.Uniform4fv(int32(loc), int32(num), (*float32)(data))
		case UniformMat3:
			gl.UniformMatrix3fv(int32(loc), int32(num), false, (*float32)(data))
		case UniformMat4:
			gl.UniformMatrix4fv(int32(loc), int32(num), false, (*float32)(data))
		case UniformSampler:
			gl.Uniform1i(int32(loc), *(*int32)(data))
		}
	}
}

func (ctx *RenderContext) bindAttributes() {

}

func (ctx *RenderContext) bindState(changedFlags, newFlags uint64) {
	if changedFlags&ST.DEPTH_WRITE != 0 {
		gl.DepthMask(newFlags&ST.DEPTH_WRITE != 0)
		log.Printf("depth mask state: %v", ST.DEPTH_WRITE&newFlags != 0)
	}

	if changedFlags&(ST.ALPHA_WRITE|ST.RGB_WRITE) != 0 {
		alpha := (newFlags & ST.ALPHA_WRITE) != 0
		rgb := (newFlags & ST.RGB_WRITE) != 0
		gl.ColorMask(rgb, rgb, rgb, alpha)

		log.Printf("color mask state: (%t, %t)", rgb, alpha)
	}

	if changedFlags&ST.DEPTH_TEST_MASK != 0 {
		_func := (newFlags & ST.DEPTH_TEST_MASK) >> ST.DEPTH_TEST_SHIFT

		if _func != 0 {
			gl.Enable(gl.DEPTH_TEST)
			gl.DepthFunc(g_CmpFunc[_func])

			log.Printf("set depth-test func: %d", _func)
		} else {
			if newFlags&ST.DEPTH_WRITE != 0 {
				gl.Enable(gl.DEPTH_TEST)
				gl.DepthFunc(gl.ALWAYS)

				log.Println("set depth-test always")
			} else {
				gl.Disable(gl.DEPTH_TEST)

				log.Println("disable depth-test")
			}
		}
	}

	/// 所谓 blend independent 可以实现顺序无关的 alpha 混合
	/// http://www.openglsuperbible.com/2013/08/20/is-order-independent-transparency-really-necessary/
	if changedFlags&ST.BLEND_MASK != 0 {
		blend := uint16(newFlags&ST.BLEND_MASK) >> ST.BLEND_SHIFT
		if blend != 0 {
			gl.Enable(gl.BLEND)
			gl.BlendFunc(g_Blend[blend].Src, g_Blend[blend].Dst)
		} else {
			gl.Disable(gl.BLEND)
		}
	}
}

```

`gfx/bk/shader.go`:

```go
package bk

import (
	"korok.io/korok/hid/gl"
	"korok.io/korok/math/f32"

	"fmt"
	"log"
)

// 编译/配置着色器相关数据
// 可以在 Shader 中实现预定义的 Uniform
type Shader struct {
	GLShader

	// bind attribute
	AttrBinds [32]AttribBind
	numAttr   uint32

	// predefined uniform
	M, V, P Uniform

	// custom uniform
	customUniforms []uint16
}

// 如果 AttrBinds 指定了一个 Stream，但是 Stream 并没有提供相应的数据(stride < Offset)
// 此时应该 disable 当前 Attribute,
func (sh *Shader) BindAttributes(R *ResManager, streams []Stream) {
	var bindStream uint16 = UInt16Max
	var bindStride uint16
	for i := uint32(0); i < sh.numAttr; i++ {
		bind := sh.AttrBinds[i]
		stream := streams[bind.stream]

		if bind.stream != bindStream {
			buffer := R.vertexBuffers[stream.vertexBuffer&IdMask]
			gl.BindBuffer(gl.ARRAY_BUFFER, buffer.Id)
			bindStream = bind.stream
			bindStride = buffer.layout
		}

		slot := uint32(bind.slot)
		enable := bindStride != 0

		if enable {
			gl.EnableVertexAttribArray(slot)

			var (
				comp   = bind.comp
				num    = int32(comp.Num)
				xType  = g_AttrType[comp.Type]
				offset = int(comp.Offset)
				base   = int(stream.firstVertex)*int(bindStride)
			)

			var norm bool
			if (comp.Normalized & 0x01) != 0 {
				norm = true
			}
			if offset < int(bindStride) {
				gl.VertexAttribPointer(slot, num, xType, norm, int32(bindStride), base+offset)
			} else {
				gl.DisableVertexAttribArray(slot)
			}
		} else {
			gl.DisableVertexAttribArray(slot)
		}
	}
}

type AttribBind struct {
	slot   uint16 // slot location
	stream uint16 // stream index

	comp VertexComp // attribute component format
}

func (sh *Shader) AddAttributeBinding(attr string, stream uint32, comp VertexComp) {
	slot := gl.GetAttribLocation(sh.Program, attr)

	if slot < 0 {
		log.Printf("fail to bind attribute: %v, %s", comp, attr)
	} else {
		if (gDebug & DebugResMan) != 0 {
			log.Printf("bind attr: %d => %s", slot, attr)
		}
	}

	bind := &sh.AttrBinds[sh.numAttr]
	bind.slot = uint16(slot)
	bind.stream = uint16(stream)
	bind.comp = comp

	sh.numAttr++
}

func (sh *Shader) AddUniformBinding(uniform string) {

}

type GLShader struct {
	Program uint32
}

func (s *GLShader) Use() {
	gl.UseProgram(s.Program)
}

func (s *GLShader) Create(vsh, fsh string) error{
	if program, err := Compile(vsh, fsh); err == nil {
		s.Program = program
		//gl.BindFragDataLocation(program, 0, "gl_FragColor\x00")
		return nil
	} else {
		return err
	}
}

func (s *GLShader) Destroy() {

}

func (s *GLShader) SetFloat(name string, value float32) {
	location := gl.GetUniformLocation(s.Program, name)
	gl.Uniform1f(location, value)
}

func (s *GLShader) SetInteger(name string, value int32) {
	location := gl.GetUniformLocation(s.Program, name)
	gl.Uniform1i(location, value)
}

func (s *GLShader) SetMatrix4(name string, mat4 f32.Mat4) {
	location := gl.GetUniformLocation(s.Program, name)
	gl.UniformMatrix4fv(location, 1, false, &mat4[0])
}

func (s *GLShader) SetVector2f(name string, x, y float32) {
	location := gl.GetUniformLocation(s.Program, name)
	gl.Uniform2f(location, x, y)
}

func (s *GLShader) SetVector3f(name string, x, y, z float32) {
	location := gl.GetUniformLocation(s.Program, name)
	gl.Uniform3f(location, x, y, z)
}

func (s *GLShader) SetVector4f(name string, x, y, z, w float32) {
	location := gl.GetUniformLocation(s.Program, name)
	gl.Uniform4f(location, x, y, z, w)
}

func (s *GLShader) SetVec4fArray(name string, array []float32, count int32) {
	location := gl.GetUniformLocation(s.Program, name)
	gl.Uniform4fv(location, count, &array[0])
}

func (s *GLShader) GetAttrLocation(attr string) uint32 {
	return uint32(gl.GetAttribLocation(s.Program, attr))
}

func (s *GLShader) GetUniformLocation(uniform string) uint32 {
	return uint32(gl.GetUniformLocation(s.Program, uniform))
}

func GetErrors() string {
	return ""
}

func Compile(vertex, fragment string) (uint32, error) {
	// 1. 编译顶点着色器
	vertexShader, err := compileShader(vertex, gl.VERTEX_SHADER)
	if err != nil {
		return 0, err
	}

	// 2. 编译颜色着色器
	fragmentShader, err := compileShader(fragment, gl.FRAGMENT_SHADER)
	if err != nil {
		return 0, err
	}
	// 3. 链接程序
	program := gl.CreateProgram()
	gl.AttachShader(program, vertexShader)
	gl.AttachShader(program, fragmentShader)
	gl.LinkProgram(program)

	// 4. 如果有错误，读取日志
	ok, desp := getProgramStatus(program)
	if !ok {
		return 0, fmt.Errorf("failed to link program %v", desp)
	}

	// 5. 删除Shader占用的资源
	gl.DeleteShader(vertexShader)
	gl.DeleteShader(fragmentShader)

	return program, nil
}

// 编译着色器小程序, 类型： gl.VertexShader or gl.fragmentShader
// 如果错误，提取错误信息并返回
func compileShader(src string, shaderType uint32) (uint32, error) {
	shader := gl.CreateShader(shaderType)
	gl.ShaderSource(shader, src)
	gl.CompileShader(shader)

	ok, err := getShaderStatus(shader)
	if !ok {
		return 0, fmt.Errorf("failed to compile: %v, %v", err, src)
	}
	return shader, nil
}

func getShaderStatus(shader uint32) (bool, string) {
	var status int32
	gl.GetShaderiv(shader, gl.COMPILE_STATUS, &status)

	if status == gl.TRUE {
		return true, ""
	}
	log := gl.GetShaderInfoLog(shader)
	return false, log
}

func getProgramStatus(program uint32) (bool, string) {
	var status int32
	gl.GetProgramiv(program, gl.LINK_STATUS, &status)

	if status == gl.TRUE {
		return true, ""
	}

	log := gl.GetProgramInfoLog(program)
	return false, log
}

// 解析 attribute 和 uniform
//func (s *Shader) Setup() {
//	// 4. 解析 attribute
//	count := int32(0)
//	nameL := int32(0)
//	gl.GetProgramiv(s.Program, gl.ACTIVE_ATTRIBUTES, &count)
//	gl.GetProgramiv(s.Program, gl.ACTIVE_ATTRIBUTE_MAX_LENGTH, &nameL)
//
//	for i := int32(0); i < count; i++ {
//		var name string = strings.Repeat("\x00", int(nameL+1))
//		var attr VertexAttr
//		gl.GetActiveAttrib(s.Program, uint32(i), nameL, nil, &attr.Size, &attr.Type, gl.Str(name))
//
//		attr.slot = uint32(gl.GetAttribLocation(s.Program, gl.Str(name)))
//		s.AttributeMap[name] = attr
//	}
//
//	// 5. 解析 uniform
//	gl.GetProgramiv(s.Program, gl.ACTIVE_UNIFORMS, &count)
//	gl.GetProgramiv(s.Program, gl.ACTIVE_UNIFORM_MAX_LENGTH, &nameL)
//
//	for i := int32(0); i < count; i++ {
//		var name string = strings.Repeat("\x00", int(nameL+ 1))
//		var uniform Uniform
//		var xtype uint32
//
//		gl.GetActiveUniform(s.Program, uint32(i), nameL, nil, &uniform.Size, &xtype, gl.Str(name))
//		uniform.slot = uint32(gl.GetUniformLocation(s.Program, gl.Str(name)))
//		uniform.Type = UniformType(xtype)
//
//		s.UniformMap[name] = uniform
//	}
//}

```

`gfx/bk/sortkey.go`:

```go
package bk

// 应该尽可能的编码一些重要的状态切换信息

const (
	SK_LayerMask   uint32 = 0xF0000000
	SK_ShaderMask  uint32 = 0x0F000000
	SK_BlendMask   uint32 = 0x00F00000
	SK_TextureMask uint32 = 0x000FF000
)

// SortKey FORMAT
// 64bit:
// 0000 - 0000000000 -       00000 -  000 - 0000000000
//  ^        ^                  ^      ^       ^
//  |        |                  |      |       |
//  |      z-order()         shader(2^5)   |    texture(2^10)
// Layer(2^4)                        blend(2^3)
// 4 + 10 + 5 + 3 + 10
type SortKey struct {
	Layer   uint16
	Order   uint16
	Shader  uint16
	Blend   uint16
	Texture uint16
}

func (sk *SortKey) Encode() (key uint64) {
	return 0 |
		uint64(sk.Layer  )<<28 |
		uint64(sk.Order  )<<18 |
		uint64(sk.Shader )<<13 |
		uint64(sk.Blend  )<<10 |
		uint64(sk.Texture)
}

func (sk *SortKey) Decode(key uint64) {
	sk.Texture = uint16((key >> 00) & (1<<10 - 1))
	sk.Blend   = uint16((key >> 10) & (1<< 3 - 1))
	sk.Shader  = uint16((key >> 13) & (1<< 5 - 1))
	sk.Order   = uint16((key >> 18) & (1<<10 - 1))
	sk.Layer   = uint16((key >> 28) & (1<< 4 - 1))
}

func SkDecode(key uint64) (sk SortKey) {
	return
}

//
//func (sk *SortKey) SetTexture(t uint32) {
//	v := uint32(*sk)
//	v = (v & ^TextureMask) | (t << 12 & TextureMask)
//	*sk = SortKey(v)
//}

```

`gfx/bk/sortkey_test.go`:

```go
package bk

import (
	"testing"
)

func TestEncoder(t *testing.T) {
	sk := SortKey{
		Layer:1,
		Order:2,
		Shader:3,
		Blend:4,
		Texture:5,
	}

	key := sk.Encode()

	if key != 0x10087005 {
		t.Error("encoder err")
	}

	sk1 := &SortKey{}; sk1.Decode(key)


	if sk.Layer != sk1.Layer {
		t.Error("layer decoder error")
	}
	if sk.Order != sk1.Order {
		t.Error("order decoder error")
	}
	if sk.Shader != sk1.Shader {
		t.Error("shader decoder error")
	}
	if sk.Blend != sk1.Blend {
		t.Error("blend decoder error")
	}
	if sk.Texture != sk1.Texture {
		t.Error("texture decdoer error")
	}

}

```

`gfx/bk/texture.go`:

```go
package bk

import (
	"fmt"
	"image"
	"image/draw"
	_ "image/jpeg"
	_ "image/png"

	"korok.io/korok/hid/gl"
	"korok.io/korok/math/f32"
	"unsafe"
)

/**
处理纹理相关问题
*/

type Texture2D struct {
	Width, Height float32
	Id            uint32
}

func (t *Texture2D) Create(image image.Image) (error) {
	t.Width  = float32(image.Bounds().Dx())
	t.Height = float32(image.Bounds().Dy())

	if id, err := newTexture(image); err != nil {
		return err
	} else {
		t.Id = id
	}
	return nil
}

func (t *Texture2D) Update(img image.Image, xoff, yoff int32, w, h int32) (err error) {
	rgba := image.NewRGBA(img.Bounds())
	if rgba.Stride != rgba.Rect.Size().X*4 {
		err = fmt.Errorf("unsupported stride")
		return
	}
	draw.Draw(rgba, rgba.Bounds(), img, image.Point{0, 0}, draw.Src)

	gl.ActiveTexture(gl.TEXTURE0)
	gl.BindTexture(gl.TEXTURE_2D, t.Id);
	gl.TexSubImage2D(gl.TEXTURE_2D,
		0,
		xoff,
		yoff,
		w,
		h,
		gl.RGBA,
		gl.UNSIGNED_BYTE,
		unsafe.Pointer(&rgba.Pix[0]))
	return
}

func (t *Texture2D) Bind(stage int32) {
	gl.ActiveTexture(gl.TEXTURE0 + uint32(stage))
	gl.BindTexture(gl.TEXTURE_2D, t.Id)
}

func (t *Texture2D) Sub(x, y float32, w, h float32) *SubTex {
	subTex := &SubTex{Texture2D: t}
	subTex.Min = f32.Vec2{x, y}
	subTex.Max = f32.Vec2{x + w, y + h}
	return subTex
}

func (t *Texture2D) Destroy() {
	gl.DeleteTextures(1, &t.Id)
}

// TODO 提前转换图片格式
func newTexture(img image.Image) (uint32, error) {
	// 3. copy image
	rgba := image.NewRGBA(img.Bounds())
	if rgba.Stride != rgba.Rect.Size().X*4 {
		return 0, fmt.Errorf("unsupported stride")
	}
	draw.Draw(rgba, rgba.Bounds(), img, image.Point{0, 0}, draw.Src)
	// 4. upload texture
	var texture uint32
	// 4.1 apply space
	gl.GenTextures(1, &texture)
	gl.ActiveTexture(gl.TEXTURE0)
	gl.BindTexture(gl.TEXTURE_2D, texture)
	// 4.2 params
	// 大小插值
	gl.TexParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)
	gl.TexParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
	// 环绕方式
	gl.TexParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
	gl.TexParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)

	// 4.3 upload
	gl.TexImage2D(gl.TEXTURE_2D,
		0,
		gl.RGBA,
		int32(rgba.Rect.Dx()),
		int32(rgba.Rect.Dy()),
		0,
		gl.RGBA,
		gl.UNSIGNED_BYTE,
		unsafe.Pointer(&rgba.Pix[0]))
	return texture, nil
}

///// 还需要抽象 SubTexture 的概念出来
type SubTex struct {
	*Texture2D

	// location -
	Min, Max f32.Vec2
}

```

`gfx/bk/uniform.go`:

```go
package bk

import (
	"korok.io/korok/hid/gl"
	"unsafe"
)
const (
	UNIFORM_BUFFER_SIZE = 16 << 10
)

type UniformType uint8

/// 支持哪些类型呢?
/// https://github.com/bkaradzic/bgfx/issues/653
/// float 在 GPU 中表现为 vec4
const (
	UniformStart UniformType = iota
	UniformMat4 		// mat4 array
	UniformMat3 		// mat3 array
	UniformVec4 		// vec4 array
	UniformVec1 		// float array
	UniformInt1 		// int array

	UniformSampler 		// sampler

	UniformEnd
)

type Uniform struct {
	Name string // Uniform Name

	Slot  uint8 // slot in shader
	Size  uint8
	Type  UniformType
	Count uint8
}

func (um *Uniform) create(program uint32, name string, xType UniformType, num uint32) (slot int32) {
	slot = gl.GetUniformLocation(program, name)
	um.Slot = uint8(slot)
	um.Name = name
	um.Type = xType
	um.Count = uint8(num)
	um.Size = g_uniform_type2size[xType]
	return
}

type UniformBuffer struct {
	buffer [UNIFORM_BUFFER_SIZE]uint8

	size uint32
	pos  uint32
}

func NewUniformBuffer() *UniformBuffer {
	return &UniformBuffer{}
}

func (ub *UniformBuffer) GetPos() uint32 {
	return ub.pos
}

func (ub *UniformBuffer) Reset() {
	ub.pos = 0
}

func (ub *UniformBuffer) Seek(pos uint32) {
	ub.pos = pos
}

func (ub *UniformBuffer) IsEmpty() bool {
	return ub.pos == 0
}

func (ub *UniformBuffer) WriteUInt32(value uint32) {
	u32 := (*uint32)(unsafe.Pointer(&ub.buffer[ub.pos]))
	*u32 = value
	ub.pos += 4
}

func (ub *UniformBuffer) Copy(ptr unsafe.Pointer, size uint32) {
	data := (*[1024]uint8)(ptr)[:size]
	copy(ub.buffer[ub.pos:], data)
	ub.pos += size
}

func (ub *UniformBuffer) ReadUInt32() uint32 {
	u32 := (*uint32)(unsafe.Pointer(&ub.buffer[ub.pos]))
	ub.pos += 4
	return *u32
}

func (ub *UniformBuffer) ReadPointer(size uint32) unsafe.Pointer {
	ptr := &ub.buffer[ub.pos]
	ub.pos += size
	return unsafe.Pointer(ptr)
}

/// Uniform ENCODE FORMAT
// 	 0x FF FF FF FF
//	    ^  ^  ^  ^
//	    |  |  |  |
// type-+  |  |  +--- Num
// loc  ---+  +------ size

func Uniform_decode(code uint32, uType, loc, size, num *uint8) {
	*uType = uint8((code >> 24) & 0xFF)
	*loc = uint8((code >> 16) & 0xFF)
	*size = uint8((code >> 8) & 0xFF)
	*num = uint8((code >> 0) & 0xFF)
}

func Uniform_encode(uType UniformType, loc, size, num uint8) uint32 {
	return uint32(uType)<<24 |
		uint32(loc)<<16 |
		uint32(size)<<8 |
		uint32(num)<<0
}

var g_uniform_type2size = [UniformEnd]uint8{
	0,				// ignore
	16 * 4,			// mat4
	9  * 4,			// mat3
	4  * 4,			// vec4
	4,				// vec1(float32)
	4,				// int32
	4,				// sampler
}

```

`gfx/bk/vertex.go`:

```go
package bk

import "korok.io/korok/hid/gl"

/// Vertex attribute type enum
type AttrType uint8

const (
	AttrInt8   AttrType = iota // byte
	AttrUInt8                  // uint8, unsigned byte
	AttrInt16                  // int16
	AttrUInt16                 // uint16
	AttrFixed                  // fixed
	AttrFloat                  // float32

	AttrCount
)

// useful defines
// <x,y, u,v, color>
var P2T2C4 = []VertexComp{
	{2, AttrFloat, 0, 0},
	{2, AttrFloat, 8, 0},
	{4, AttrUInt8, 16, 1},
}

// <x,y, u,v>
var P2T2 = []VertexComp{
	{2, AttrFloat, 0, 0},
	{2, AttrFloat, 8, 0},
}

// <x,y, color>
var P2C4 = []VertexComp{
	{2, AttrFloat, 0, 0},
	{4, AttrUInt8, 8, 1},
}

type VertexComp struct {
	Num        uint8
	Type       AttrType
	Offset     uint8
	Normalized uint8
}

func (comp *VertexComp) encode() uint16 {
	return 0
}

var g_AttrType = []uint32{
	gl.BYTE,
	gl.UNSIGNED_BYTE,
	gl.SHORT,
	gl.UNSIGNED_SHORT,
	gl.FIXED,
	gl.FLOAT,
}

var g_AttrType2Size = []int32{
	1, 1,
	2, 2,
	0, // Fixed Size ?
	4,
}

```

`gfx/camera.go`:

```go
package gfx

import (
	"korok.io/korok/math/f32"
	"korok.io/korok/engi"
	"korok.io/korok/math"
)

type CameraMode uint8
const (
	Perspective CameraMode = iota
	Orthographic
)

//
type Camera struct {
	Eye f32.Vec3
	//
	bound struct{
		left, top, right, bottom float32
	}
	mat struct{
		x, y float32
		sx, sy float32
		rt float32
	}
	view struct{
		w, h float32
		ratio float32  // ratio=w/h
		scale, invScale f32.Vec2  // scale=view_width/screen_width
	}
	follow engi.Entity

	desire struct{
		w, h float32
	}
	screen struct{
		w, h float32
	}
}

func (c *Camera) initialize() {
	// bounding-box
	min, max := -math.MaxFloat32, math.MaxFloat32
	c.SetBound(min, max, max, min)

	// scale
	c.mat.sx, c.mat.sy = 1, 1
}

func (c *Camera) P() (left, right, bottom, top float32){
	hx := c.view.w*c.mat.sx/2
	hy := c.view.h*c.mat.sy/2
	left   = c.mat.x - hx
	right  = c.mat.x + hx
	bottom = c.mat.y - hy
	top    = c.mat.y + hy
	return
}

func (c *Camera) View() (x, y, w, h float32) {
	return c.mat.x, c.mat.y, c.view.w, c.view.h
}

func (c *Camera) Bounding() (left, top, right, bottom float32){
	return c.bound.left, c.bound.top, c.bound.right, c.bound.bottom
}

// Screen2Scene converts (x,y) in screen coordinate to (x1,y1) in game's world coordinate.
func (c *Camera) Screen2Scene(x, y float32) (x1, y1 float32) {
	x1 = c.mat.x - c.view.w/2 + x*c.view.scale[0]
	y1 = c.mat.y + c.view.h/2 - y*c.view.scale[1]
	return
}

// Scene2Screen converts (x,y) in game's world coordinate to screen coordinate.
func (c *Camera) Scene2Screen(x, y float32) (x1, y1 float32) {
	x1 =  (x + c.view.w/2 - c.mat.x)*c.view.invScale[0]
	y1 = -(y - c.view.h/2 - c.mat.y)*c.view.invScale[1]
	return
}

func (c *Camera) Flow(entity engi.Entity) {
	c.follow = entity
}

func (c *Camera) Position() (x,y float32) {
	return c.mat.x, c.mat.y
}

func (c *Camera) MoveTo(x, y float32) {
	c.mat.x, c.mat.y = x, y
	c.clamp()
}

func (c *Camera) MoveBy(dx, dy float32) {
	c.mat.x += dx
	c.mat.y += dy
	c.clamp()
}

func (c *Camera) Scale() (sx, sy float32) {
	return c.mat.sx, c.mat.sy
}

func (c *Camera) ScaleTo(sx, sy float32) {
	c.mat.sx, c.mat.sy = sx, sy
}

func (c *Camera) ScaleBy(dsx, dsy float32) {
	c.mat.sx += dsx
	c.mat.sy += dsy
}

func (c *Camera) Rotation() float32 {
	return c.mat.rt
}

func (c *Camera) RotateTo(rt float32) {
	c.mat.rt = rt
}

func (c *Camera) RotateBy(d float32) {
	c.mat.rt += d
}

func (c *Camera) SetBound(left, top, right, bottom float32) {
	c.bound.left = left
	c.bound.right = right
	c.bound.top = top
	c.bound.bottom = bottom
	c.clamp()
}

func (c *Camera) Screen() (w,h float32) {
	return c.screen.w, c.screen.h
}

// TODO:相机默认位置应该在屏幕中间
func (c *Camera) SetViewPort(w, h float32) {
	c.screen.w = w
	c.screen.h = h

	if c.desire.w != 0 || c.desire.h != 0 {
		c.SetDesiredViewport(c.desire.w, c.desire.h)
	} else {
		c.view.w = w
		c.view.h = h
		c.view.ratio = 1
		c.view.scale = f32.Vec2{1, 1}
		c.view.invScale = f32.Vec2{1, 1}
	}
	c.clamp()
}

func (c *Camera) SetDesiredViewport(w, h float32) {
	c.desire.w = w
	c.desire.h = h

	if w != 0 && h != 0 {
		c.view.w, c.view.h = w, h
		c.view.ratio = w/h
		c.view.scale = f32.Vec2{
			w/c.screen.w,
			h/c.screen.h,
		}
		c.view.invScale =  f32.Vec2 {
			c.screen.w/w,
			c.screen.h/h,
		}
	} else if w == 0 {
		ratio := c.screen.w/c.screen.h
		c.view.w = ratio * h
		c.view.h = h
		c.view.ratio = ratio
		scale, invScale := h/c.screen.h, c.screen.h/h
		c.view.scale = f32.Vec2{ scale, scale}
		c.view.invScale = f32.Vec2{invScale, invScale}
	} else if h == 0 {
		ratio := c.screen.w/c.screen.h
		c.view.w = w
		c.view.h = w/ratio
		c.view.ratio = ratio
		scale, invScale := w/c.screen.w, c.screen.w/w
		c.view.scale = f32.Vec2{ scale, scale}
		c.view.invScale = f32.Vec2{invScale, invScale}
	}

	c.clamp()
}

func (c *Camera) clamp() {
	// x
	if left := c.mat.x - c.view.w/2; left < c.bound.left {
		c.mat.x += c.bound.left - left
	} else if right := c.mat.x + c.view.w/2; right > c.bound.right {
		c.mat.x += c.bound.right - right
	}

	// y
	if bottom := c.mat.y - c.view.h/2; bottom < c.bound.bottom {
		c.mat.y += c.bound.bottom - bottom
	} else if top := c.mat.y + c.view.h/2; top > c.bound.top {
		c.mat.y += c.bound.top - top
	}
}

func (c *Camera) InView(xf *Transform, size, gravity f32.Vec2) bool {
	var (
		w = c.view.w * c.mat.sx
		h = c.view.h * c.mat.sy
	)
	if xf.world.Rotation == 0 { // happy path
		p := xf.world.Position
		size[0], size[1] = size[0]*xf.world.Scale[0], size[1]*xf.world.Scale[1]
		a := AABB{p[0]-size[0]*gravity[0], p[1]-size[1]*gravity[1], size[0], size[1]}
		b := AABB{c.mat.x-w/2, c.mat.y-h/2, w, h}
		return OverlapAB(&a, &b)
	} else {
		srt := xf.world
		m := mat3{}; m.Initialize(srt.Position[0], srt.Position[1], srt.Rotation, srt.Scale[0], srt.Scale[1])
		// center and extent
		cx, cy := -size[0]*gravity[0] + size[0]/2, -size[1]*gravity[1] + size[1]/2
		ex, ey := size[0]/2, size[1]/2

		// transform center
		cx, cy = m.TransformCoord(cx, cy)

		// transform extent
		for i, v := range m {
			if v < 0 {
				m[i] = -v
			}
		}
		ex, ey = m.TransformNormal(ex, ey)
		a := AABB{cx-ex, cy-ey, ex*2, ey*2}
		b := AABB{c.mat.x-w/2, c.mat.y-h/2, w, h}
		return OverlapAB(&a, &b)
	}
}

type mat3 [9]float32 // fast culling matrix, (0, 0) as the center of the local model

func (m *mat3) Initialize(x, y, angle, sx, sy float32) {
	c, s := math.Cos(angle), math.Sin(angle)

	m[0] = c * sx
	m[1] = s * sx
	m[3] =  - s * sy
	m[4] =  + c * sy
	m[6] = x
	m[7] = y

	m[2], m[5] = 0, 0
	m[8] = 1.0
}

func (m mat3) TransformCoord(x, y float32) (x1, y1 float32) {
	x1 = m[0]*x + m[3]*y + m[6]
	y1 = m[1]*x + m[4]*y + m[7]
	return
}

func (m mat3) TransformNormal(x, y float32) (x1, y1 float32) {
	x1 = m[0]*x + m[3]*y
	y1 = m[1]*x + m[4]*y
	return
}
```

`gfx/data.go`:

```go
package gfx

import (
	"korok.io/korok/gfx/bk"
	"unsafe"
	"image/color"
)

type Color color.RGBA

var (
	White  = Color{0xFF, 0xFF, 0xFF, 0xFF}
	Black  = Color{0,0,0,0xFF}
	LTGray = Color{0xCC,0xCC,0xCC, 0xFF}
	Gray   = Color{0x88, 0x88, 0x88, 0xFF}
	DKGray = Color{0x44, 0x44, 0x44, 0xFF}

	Red   = Color{0xFF,0,0, 0xFF}
	Green = Color{0,0xFF,0, 0xFF}
	Blue  = Color{0,0,0xFF, 0xFF}

	Cyan    = Color{0, 0xFF, 0xFF, 0xFF}
	Magenta = Color{0xFF, 00, 0xFF, 0xFF}
	Yellow  = Color{0xFF, 0xFF, 0x00, 0xFF}

	Transparent = Color{}
	Opaque      = Color{0xFF, 0xFF, 0xFF, 0xFF}
)

func (c Color) U32() uint32 {
	return *(*uint32)(unsafe.Pointer(&c))
}

// Color value should follow byte-order: 0xAABBGGRR
func U32Color(v uint32) Color {
	return *(*Color)(unsafe.Pointer(&v))
}

// PMAColor returns a pre-multiplied alpha Color.
func PMAColor(r, g, b, a uint8) Color {
	f := float32(a)/255
	return Color{
		R:uint8(float32(r)*f),
		G:uint8(float32(g)*f),
		B:uint8(float32(b)*f),
		A:a,
	}
}

func PMAColorf(r, g, b, a float32) Color{
	return Color{
		R:uint8(r*a*255),
		G:uint8(g*a*255),
		B:uint8(b*a*255),
		A:uint8(a*255),
	}
}

func (c Color) RGBA() (r, g, b, a uint32) {
	r = uint32(c.R)
	r |= r << 8
	g = uint32(c.G)
	g |= g << 8
	b = uint32(c.B)
	b |= b << 8
	a = uint32(c.A)
	a |= a << 8
	return
}

type CompRef struct {
	Type int32
	*Transform
	*SpriteComp
}

type AABB struct {
	x, y float32
	width, height float32
}

func OverlapAB(a, b *AABB) bool {
	if a.x < b.x+b.width && a.x+a.width>b.x && a.y < b.y+b.height && a.y+a.height > b.y {
		return true
	}
	return false
}

type zOrder struct {
	value int16
}

func (zo *zOrder) SetZOrder(z int16) {
	zo.value = z
}

func (zo *zOrder) Z() int16 {
	return zo.value
}

type batchId struct {
	value uint16
}

func (b *batchId) SetBatchId(id uint16) {
	b.value = id
}

func (b *batchId) BatchId() uint16 {
	return b.value
}

func PackSortId(z int16, b uint16) (sid uint32) {
	 sid = uint32(int32(z) + 0xFFFF>>1)
	 sid = (sid << 16) + uint32(b)
	 return
}

func UnpackSortId(sortId uint32) (z int16, b uint16) {
	b = uint16(sortId & 0xFFFF)
	z = int16(int32(sortId>>16)-0xFFFF>>1)
	return
}

// format <x,y,u,v rgba>
var P4C4 = []bk.VertexComp{
	{4, bk.AttrFloat, 0, 0},
	{4, bk.AttrUInt8, 16, 1},
}

// vertex struct
type PosTexColorVertex struct {
	X, Y, U, V float32
	RGBA       uint32
}

//
var PosTexColorVertexSize = unsafe.Sizeof(PosTexColorVertex{})
var UInt16Size = unsafe.Sizeof(uint16(0))






```

`gfx/dbg/dbg.go`:

```go
package dbg

import (
	"korok.io/korok/gfx/bk"
	"korok.io/korok/math/f32"

	"unsafe"
	"log"
	"fmt"
	"korok.io/korok/math"
)

type DebugEnum uint32

const (
	FPS DebugEnum = 1 << iota
	Stats
	Draw

	ALL = FPS|Stats|Draw
	None = DebugEnum(0)
)


var screen struct{
	w, h float32
}
// max value of z-order
const zOrder = int32(0xFFFF>>1)

// dbg - draw debug info
// provide self-contained, im-gui api
// can be used to show debug info, fps..
// dependents: bk-api

var p2t2c4 = []bk.VertexComp{
	{4, bk.AttrFloat, 0, 0},
	{4, bk.AttrUInt8, 16, 1},
}

type PosTexColorVertex struct {
	X, Y, U, V float32
	RGBA       uint32
}

func Init(w, h int) {
	if gRender == nil {
		gRender = NewDebugRender(vsh, fsh)
		gBuffer = &gRender.Buffer
		hud = &HudLog{}
	}
	screen.w = float32(w)
	screen.h = float32(h)

	log.Println("dbg init w,h", w, h)
}

func SetDebug(enum DebugEnum) {
	DEBUG = enum
}

func SetCamera(x,y, w,h float32) {
	gRender.SetViewPort(x, y, w, h)
}

func Destroy() {
}

func Color(argb uint32) {
	gBuffer.color = argb
}

// draw a rect
func DrawRect(x, y, w, h float32) {
	if (DEBUG & Draw) != 0 {
		gBuffer.Rect(x, y, w, h)
	}
}

func DrawBorder(x, y, w, h, thickness float32) {
	if (DEBUG & Draw) != 0 {
		gBuffer.Border(x, y, w, h, thickness)
	}
}

// draw a circle
func DrawCircle(x,y float32, r float32) {
	if (DEBUG & Draw) != 0 {
		gBuffer.Circle(x, y, r)
	}
}

func DrawLine(from, to f32.Vec2) {
	if (DEBUG & Draw) != 0 {
		gBuffer.Line(from, to)
	}
}

// draw string
func DrawStr(x,y float32, str string, args ...interface{}) {
	if (DEBUG & Draw) != 0 {
		gBuffer.String(x, y, fmt.Sprintf(str, args...), 1)
	}
}

func DrawStrScaled(x, y float32, scale float32, str string, args ...interface{}) {
	if (DEBUG & Draw) != 0 {
		gBuffer.String(x, y, fmt.Sprintf(str, args...), scale)
	}
}

func AdvanceFrame() {
	// draw hud
	hud.draw()
	hud.reset()

	// flush
	gBuffer.Update()
	gRender.Draw()
	gBuffer.Reset()
}


type DebugRender struct {
	stateFlags uint64
	rgba       uint32
	view struct{
		x, y, w, h float32
	}

	// shader program
	program uint16

	// uniform handle
	umhProjection uint16 // Projection
	umhSampler0   uint16 // Sampler0

	// buffer
	Buffer TextShapeBuffer
}

func NewDebugRender(vsh, fsh string) *DebugRender {
	dr := new(DebugRender)
	// blend func
	dr.stateFlags |= bk.ST_BLEND.ALPHA_PREMULTIPLIED

	// setup shader
	if id, sh := bk.R.AllocShader(vsh, fsh); id != bk.InvalidId {
		dr.program = id
		sh.Use()

		// setup attribute
		sh.AddAttributeBinding("xyuv\x00", 0, p2t2c4[0])
		sh.AddAttributeBinding("rgba\x00", 0, p2t2c4[1])

		s0 := int32(0)
		// setup uniform
		if pid, _ := bk.R.AllocUniform(id, "projection\x00", bk.UniformMat4, 1); pid != bk.InvalidId {
			dr.umhProjection = pid
		}
		if sid, _ := bk.R.AllocUniform(id, "tex\x00", bk.UniformSampler, 1); sid != bk.InvalidId {
			dr.umhSampler0 = sid
			bk.SetUniform(sid, unsafe.Pointer(&s0))
		}

		// submit render state
		//bk.Touch(0)
		bk.Submit(0, id, zOrder)
	}
	// setup buffer, we can draw 512 rect at most!!
	dr.Buffer.init(2048*4)
	return dr
}

func (dr *DebugRender) Destroy() {
	bk.R.Free(dr.program)
	bk.R.Free(dr.umhProjection)
	bk.R.Free(dr.umhSampler0)
}

func (dr *DebugRender) SetViewPort(x,y, w,h float32) {
	dr.view.x = x
	dr.view.y = y
	dr.view.w = w
	dr.view.h = h

	var (
		left   = x - dr.view.w/2
		right  = x + dr.view.w/2
		bottom = y - dr.view.h/2
		top    = y + dr.view.h/2
	)

	p := f32.Ortho2D(left, right, bottom, top)

	// setup uniform
	bk.SetUniform(dr.umhProjection, unsafe.Pointer(&p[0]))
	bk.Submit(0, dr.program, zOrder)
}

//func (dr *DebugRender) SetViewPort(x, y, w, h float32) {
//	dr.view.w, dr.view.h = w, h
//	p := f32.Ortho2D(0, w, 0, h)
//	bk.SetUniform(dr.umhProjection, unsafe.Pointer(&p[0]))
//	bk.Submit(0, dr.program, zOrder)
//}

func (dr *DebugRender) Draw() {
	bk.SetState(dr.stateFlags, dr.rgba)
	bk.SetTexture(0, dr.umhSampler0, uint16(dr.Buffer.fontTexId), 0)

	b := &dr.Buffer
	// set vertex
	bk.SetVertexBuffer(0, b.vertexId, 0, b.pos)
	bk.SetIndexBuffer(dr.Buffer.indexId, 0, b.pos * 6 >> 2)
	// submit
	bk.Submit(0, dr.program, zOrder)
}

// Rect:
//   3 ---- 2
//   | `    |
//   |   `  |
//   0------1
// Order:
// 3, 0, 1, 3, 1, 2
type TextShapeBuffer struct {
	// real data
	vertex []PosTexColorVertex
	index  []uint16

	// gpu res
	indexId, vertexId uint16
	ib *bk.IndexBuffer
	vb *bk.VertexBuffer
	fontTexId uint16

	// current painter color
	color uint32

	// current buffer position
	pos uint32
}

func (buff *TextShapeBuffer) init(maxVertex uint32) {
	iboSize := maxVertex * 6 / 4
	buff.index = make([]uint16, iboSize)
	iFormat := [6]uint16 {3, 0, 1, 3, 1, 2}
	for i := uint32(0); i < iboSize; i += 6 {
		copy(buff.index[i:], iFormat[:])
		iFormat[0] += 4
		iFormat[1] += 4
		iFormat[2] += 4
		iFormat[3] += 4
		iFormat[4] += 4
		iFormat[5] += 4
	}
	if id, ib := bk.R.AllocIndexBuffer(bk.Memory{unsafe.Pointer(&buff.index[0]), iboSize}); id != bk.InvalidId {
		buff.indexId = id
		buff.ib = ib
	}

	buff.vertex = make([]PosTexColorVertex, maxVertex)
	vboSize := maxVertex * 20
	if id, vb := bk.R.AllocVertexBuffer(bk.Memory{nil, vboSize}, 20); id != bk.InvalidId {
		buff.vertexId = id
		buff.vb = vb
	}

	// texture
	img, fmt, err := LoadFontImage()
	if err != nil {
		log.Println("fail to load font image.. fmt:", fmt)
	}
	if id, _ := bk.R.AllocTexture(img); id != bk.InvalidId {
		buff.fontTexId = id
	}
	buff.color = 0xFF000000
}

func (buff *TextShapeBuffer) String(x, y float32, chars string, scale float32) {
	w, h := font_width * scale, font_height * scale

	for i, N := 0, len(chars); i < N; i++ {
		b := buff.vertex[buff.pos: buff.pos+4]
		buff.pos += 4

		// vv := chars[0]
		var left, right, bottom, top float32 = GlyphRegion(chars[i])
		bottom, top = top, bottom

		b[0].X, b[0].Y = x, y
		b[0].U, b[0].V = left, bottom
		b[0].RGBA = buff.color

		b[1].X, b[1].Y = x + w, y
		b[1].U, b[1].V = right, bottom
		b[1].RGBA = buff.color

		b[2].X, b[2].Y = x + w, y + h
		b[2].U, b[2].V = right, top
		b[2].RGBA = buff.color

		b[3].X, b[3].Y = x, y + h
		b[3].U, b[3].V = left, top
		b[3].RGBA = buff.color

		// advance x,y
		x += w
	}
}


//
//  3-------2
//  |       |
//  |       |
//  0-------1
func (buff *TextShapeBuffer) Rect(x,y, w, h float32) {
	b := buff.vertex[buff.pos: buff.pos+4]
	buff.pos += 4

	b[0].X, b[0].Y = x, y
	b[0].U, b[0].V = 2, 0
	b[0].RGBA = buff.color

	b[1].X, b[1].Y = x + w, y
	b[1].U, b[1].V = 2, 0
	b[1].RGBA = buff.color

	b[2].X, b[2].Y = x + w, y + h
	b[2].U, b[2].V = 2, 0
	b[2].RGBA = buff.color

	b[3].X, b[3].Y = x, y + h
	b[3].U, b[3].V = 2, 0
	b[3].RGBA = buff.color
}

func (buff *TextShapeBuffer) Line(from, to f32.Vec2) {
	b := buff.vertex[buff.pos: buff.pos+4]
	buff.pos += 4

	diff := to.Sub(from)
	invLength := math.InvLength(diff[0], diff[1], 1.0)
	diff = diff.Mul(invLength)
	thickness := float32(1)

	dx := diff[1] * (thickness * 0.5)
	dy := diff[0] * (thickness * 0.5)

	b[0].X, b[0].Y = from[0]+dx, from[1]-dy
	b[0].U, b[0].V = 2, 0
	b[0].RGBA = buff.color

	b[1].X, b[1].Y = to[0]+dx, to[1]-dy
	b[1].U, b[1].V = 2, 0
	b[1].RGBA = buff.color

	b[2].X, b[2].Y = to[0]-dx, to[1]+dy
	b[2].U, b[2].V = 2, 0
	b[2].RGBA = buff.color

	b[3].X, b[3].Y = from[0]-dx, from[1]+dy
	b[3].U, b[3].V = 2, 0
	b[3].RGBA = buff.color
}

func (buff *TextShapeBuffer) Border(x, y, w, h, thick float32) {
	buff.Rect(x,y,w,thick)
	buff.Rect(x,y+h-thick,w,thick)
	buff.Rect(x, y, thick, h)
	buff.Rect(x+w-thick,y,thick,h)
}

func (buff *TextShapeBuffer) Circle(x, y float32, radius float32) {
	var (
		segments = 12
		path = [24]f32.Vec2{}
		angle = float32(3.14*2)
	)

	switch {
	case radius < 4:
		segments = 4
	case radius < 100:
		segments = int(radius/100 * 16) + 8
	default:
		segments = 24
	}

	for i := 0; i < segments; i++ {
		a := float32(i)/float32(segments) * angle
		x1 := x + math.Cos(a) * radius
		y1 := y + math.Sin(a) * radius
		path[i] = f32.Vec2{x1, y1}
	}
	for i := 0; i < segments; i++ {
		j := i+1
		if j == segments {
			j = 0
		}
		p1, p2 := path[i],path[j]
		buff.Line(p1, p2)
	}
}

func (buff *TextShapeBuffer) Update() {
	if DEBUG != None && buff.pos > 0 {
		buff.vb.Update(0, buff.pos * 20, unsafe.Pointer(&buff.vertex[0]), false)
	}
}

func (buff *TextShapeBuffer) Reset() {
	buff.pos = 0
}

func (buff *TextShapeBuffer) Destroy() {
	buff.vertex = nil
	buff.index = nil
	bk.R.Free(buff.vertexId)
	bk.R.Free(buff.indexId)
	bk.R.Free(buff.fontTexId)
}

//// static filed
var gRender *DebugRender
var gBuffer *TextShapeBuffer
var hud *HudLog
var DEBUG DebugEnum = FPS|Draw

```

`gfx/dbg/font.go`:

```go
package dbg

import (
	"image"
	_ "image/png"
	"log"
	"bytes"
)

//
type FontSystem interface {
	Glyph(r rune) (tex uint16, left, right, bottom, top float32)
}

var font_width float32 = 12
var font_height float32 = 32

var font_x float32 = 12.0 / 999
var font_y float32 = float32(32)/54

func GlyphRegion(char byte) (left, right, bottom, top float32) {
	i := char - '.'

	left   = float32(i) * font_x
	right  = left + font_x
	bottom = 0
	top    = font_y
	return
}

func LoadFontImage() (img image.Image, fmt string, err error) {
	img, fmt, err = image.Decode(bytes.NewReader(font_image))
	log.Println("font img bounds:", img.Bounds())
	return
}

// fixed size, bitmap font - png encoded!
// size: 12 * 32
var font_image = []byte{
0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d,
0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x03, 0xe7, 0x00, 0x00, 0x00, 0x36,
0x08, 0x06, 0x00, 0x00, 0x00, 0xa5, 0x74, 0xe8, 0xab, 0x00, 0x00, 0x00,
0x04, 0x67, 0x41, 0x4d, 0x41, 0x00, 0x00, 0xb1, 0x8f, 0x0b, 0xfc, 0x61,
0x05, 0x00, 0x00, 0x00, 0x01, 0x73, 0x52, 0x47, 0x42, 0x00, 0xae, 0xce,
0x1c, 0xe9, 0x00, 0x00, 0x00, 0x20, 0x63, 0x48, 0x52, 0x4d, 0x00, 0x00,
0x7a, 0x26, 0x00, 0x00, 0x80, 0x84, 0x00, 0x00, 0xfa, 0x00, 0x00, 0x00,
0x80, 0xe8, 0x00, 0x00, 0x75, 0x30, 0x00, 0x00, 0xea, 0x60, 0x00, 0x00,
0x3a, 0x98, 0x00, 0x00, 0x17, 0x70, 0x9c, 0xba, 0x51, 0x3c, 0x00, 0x00,
0x00, 0x06, 0x62, 0x4b, 0x47, 0x44, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,
0xa0, 0xbd, 0xa7, 0x93, 0x00, 0x00, 0x6c, 0xe9, 0x49, 0x44, 0x41, 0x54,
0x78, 0xda, 0xed, 0x9d, 0x77, 0x58, 0x54, 0x47, 0xf7, 0xc7, 0xbf, 0x77,
0x97, 0xa5, 0xf7, 0x22, 0x45, 0x6c, 0x80, 0x8a, 0x08, 0xd8, 0xc0, 0xae,
0x88, 0x0d, 0x4b, 0xec, 0x5d, 0xa3, 0x46, 0x63, 0x8d, 0xd8, 0x8d, 0xc6,
0x12, 0x7b, 0x8b, 0xdd, 0xa0, 0xb1, 0x61, 0x8f, 0x3d, 0xd8, 0x1b, 0x22,
0x8a, 0x0d, 0x0b, 0x45, 0x01, 0x15, 0xa5, 0x83, 0x54, 0xe9, 0xb0, 0xb0,
0x6c, 0xbb, 0xf3, 0xfb, 0xe3, 0xde, 0x95, 0x65, 0x5d, 0x9a, 0x9a, 0xbc,
0x6f, 0x7e, 0xef, 0xfd, 0x3c, 0xcf, 0x7d, 0x12, 0xd9, 0xb9, 0x73, 0xa7,
0x9c, 0x39, 0x33, 0x67, 0xca, 0x19, 0x80, 0x83, 0x83, 0x83, 0x83, 0x83,
0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83,
0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83,
0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83,
0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83,
0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83,
0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83,
0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83,
0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83,
0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83,
0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83,
0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83,
0x83, 0xe3, 0x1f, 0x85, 0xff, 0x9f, 0x4e, 0x00, 0x07, 0x07, 0x07, 0x07,
0x07, 0x07, 0x07, 0xc7, 0xff, 0x02, 0xfd, 0xfa, 0xf5, 0x1b, 0xe8, 0xe2,
0xe2, 0xd2, 0xa2, 0xa0, 0xa0, 0xa0, 0x40, 0x28, 0x14, 0x16, 0x7f, 0x8b,
0x38, 0xeb, 0xd4, 0xa9, 0x63, 0xd5, 0xb4, 0x69, 0xd3, 0x66, 0x22, 0x91,
0x48, 0x54, 0x56, 0x56, 0x56, 0xf6, 0x4f, 0xe6, 0xc7, 0xc8, 0xc8, 0xc8,
0xb8, 0x79, 0xf3, 0xe6, 0x2e, 0x72, 0xb9, 0x9c, 0x2e, 0x29, 0x29, 0x11,
0x7e, 0xab, 0x78, 0xf5, 0xf4, 0xf4, 0xf4, 0x9b, 0x37, 0x6f, 0xee, 0xe2,
0xec, 0xec, 0xdc, 0x42, 0x20, 0x10, 0x68, 0x16, 0x17, 0x17, 0x17, 0xc9,
0xe5, 0x72, 0xf9, 0x97, 0xc4, 0x65, 0x61, 0x61, 0x61, 0xe9, 0xe8, 0xe8,
0xe8, 0xf4, 0xa5, 0xe5, 0x43, 0x51, 0x14, 0xa5, 0xa7, 0xa7, 0xa7, 0x2f,
0x95, 0x4a, 0x25, 0xb5, 0x79, 0x4f, 0x5f, 0x5f, 0xdf, 0x40, 0x22, 0x91,
0xa8, 0x7d, 0xc7, 0xc5, 0xc5, 0xa5, 0x85, 0xb9, 0xb9, 0xb9, 0x45, 0x76,
0x76, 0xf6, 0xc7, 0xda, 0xe4, 0xc1, 0xda, 0xda, 0xba, 0xae, 0xb5, 0xb5,
0x75, 0x5d, 0x2b, 0x2b, 0x2b, 0x9b, 0xcc, 0xcc, 0xcc, 0xf4, 0x6f, 0x51,
0xd6, 0x1c, 0x1c, 0xff, 0x26, 0x1c, 0x1c, 0x1c, 0x9a, 0x9a, 0x98, 0x98,
0x98, 0xe5, 0xe7, 0xe7, 0xe7, 0xfe, 0xa7, 0xd3, 0xf2, 0x77, 0xa1, 0xf1,
0x77, 0x44, 0xda, 0xb5, 0x6b, 0xd7, 0xee, 0x84, 0x10, 0xf2, 0xe8, 0xd1,
0xa3, 0xfb, 0xea, 0x7e, 0x6f, 0xd6, 0xac, 0x99, 0x73, 0xa7, 0x4e, 0x9d,
0xba, 0xc8, 0x64, 0x32, 0xd9, 0xa3, 0x47, 0x8f, 0x1e, 0xc4, 0xc7, 0xc7,
0xc7, 0x54, 0x17, 0xa7, 0x89, 0x89, 0x89, 0x59, 0xdb, 0xb6, 0x6d, 0xdb,
0xbf, 0x79, 0xf3, 0x26, 0x2a, 0x35, 0x35, 0x35, 0xa5, 0xb2, 0x70, 0x3a,
0x3a, 0x3a, 0xba, 0xad, 0x5a, 0xb5, 0x72, 0x6b, 0xd9, 0xb2, 0x65, 0xab,
0xd2, 0xd2, 0xd2, 0xd2, 0x90, 0x90, 0x90, 0xe7, 0x6f, 0xde, 0xbc, 0x89,
0xac, 0x2c, 0x7c, 0xa3, 0x46, 0x8d, 0x1c, 0x5c, 0x5c, 0x5c, 0x5c, 0xed,
0xed, 0xed, 0x1d, 0xb2, 0xb3, 0xb3, 0x3f, 0x86, 0x86, 0x86, 0x86, 0xbc,
0x7b, 0xf7, 0xee, 0x4d, 0x8d, 0x0a, 0x4f, 0x43, 0x43, 0x30, 0x62, 0xc4,
0x88, 0x31, 0x12, 0x89, 0x44, 0xec, 0xe7, 0xe7, 0x77, 0x1e, 0x00, 0x51,
0xfe, 0xdd, 0xce, 0xce, 0xae, 0x71, 0xe3, 0xc6, 0x8d, 0x9b, 0xa8, 0x7b,
0x37, 0x24, 0x24, 0xe4, 0x79, 0x5e, 0x5e, 0x5e, 0x4e, 0x65, 0x71, 0x1b,
0x1a, 0x1a, 0x1a, 0xb5, 0x6c, 0xd9, 0xb2, 0x8d, 0xab, 0xab, 0x6b, 0x0b,
0x89, 0x44, 0x22, 0xb9, 0x7b, 0xf7, 0xee, 0x9d, 0x84, 0x84, 0x84, 0x58,
0xc5, 0xef, 0x4e, 0x4e, 0x4e, 0xce, 0xf5, 0xea, 0xd5, 0x6b, 0x50, 0x55,
0xfa, 0x92, 0x93, 0x93, 0x93, 0xd4, 0xe5, 0xa5, 0x5b, 0xb7, 0x6e, 0x3d,
0x5d, 0x5d, 0x5d, 0x5b, 0x00, 0xc0, 0xeb, 0xd7, 0xaf, 0xa3, 0xee, 0xdf,
0xbf, 0x1f, 0x40, 0x08, 0x21, 0xea, 0xe2, 0xe0, 0xf1, 0x78, 0xfc, 0x4e,
0x9d, 0x3a, 0x75, 0x75, 0x71, 0x71, 0x71, 0xcd, 0xc9, 0xc9, 0xc9, 0x79,
0xfa, 0xf4, 0xe9, 0x93, 0x0f, 0x1f, 0x3e, 0x24, 0xd5, 0xa4, 0x7c, 0xfe,
0x17, 0x70, 0x72, 0x72, 0x72, 0x6e, 0xde, 0xbc, 0xb9, 0xab, 0xad, 0xad,
0xad, 0x6d, 0x71, 0x71, 0x71, 0x71, 0x6c, 0x6c, 0x6c, 0xcc, 0xc3, 0x87,
0x0f, 0xef, 0x55, 0x56, 0x9e, 0x0a, 0x2c, 0x2c, 0x2c, 0x2c, 0xed, 0xed,
0xed, 0x1d, 0xa2, 0xa2, 0xa2, 0x22, 0xaa, 0x1b, 0xd0, 0xf0, 0x78, 0x3c,
0xfe, 0xb0, 0x61, 0xc3, 0x46, 0x12, 0x42, 0x88, 0x9f, 0x9f, 0xdf, 0x79,
0x42, 0x08, 0xad, 0x1a, 0xa6, 0x65, 0xcb, 0x96, 0x6d, 0x2c, 0x2d, 0x2d,
0xad, 0x14, 0xff, 0xa6, 0x69, 0x9a, 0xce, 0xcd, 0xcd, 0xcd, 0xc9, 0xcc,
0xcc, 0xcc, 0x48, 0x4f, 0x4f, 0x4f, 0xad, 0x2e, 0x1f, 0x26, 0x26, 0x26,
0x66, 0xae, 0xae, 0xae, 0x2d, 0x5d, 0x5c, 0x5c, 0x5c, 0x65, 0x32, 0x99,
0x2c, 0x35, 0x35, 0xf5, 0xc3, 0x83, 0x07, 0x0f, 0xee, 0x15, 0x17, 0x17,
0x17, 0xa9, 0xc6, 0x2f, 0x97, 0xcb, 0xe5, 0x09, 0x09, 0x09, 0xf1, 0x49,
0x49, 0x49, 0xf1, 0x34, 0x4d, 0xd3, 0x95, 0xc5, 0xd9, 0xb5, 0x6b, 0xd7,
0xee, 0x3a, 0x3a, 0x3a, 0x3a, 0x95, 0xfd, 0x1e, 0x11, 0x11, 0xf1, 0x52,
0x79, 0x70, 0xd1, 0xbc, 0x79, 0x73, 0x17, 0x5b, 0x5b, 0xdb, 0xfa, 0x95,
0x85, 0xff, 0xf0, 0xe1, 0x43, 0xf2, 0xdb, 0xb7, 0x6f, 0x5f, 0xab, 0xfe,
0x9d, 0xcf, 0xe7, 0xf3, 0x1d, 0x1d, 0x1d, 0x9b, 0xb7, 0x69, 0xd3, 0xc6,
0xdd, 0xd8, 0xd8, 0xd8, 0x38, 0x25, 0x25, 0x25, 0xf9, 0xfe, 0xfd, 0xfb,
0x81, 0x85, 0x85, 0x85, 0xf9, 0xaa, 0xe5, 0xf3, 0xe8, 0xd1, 0xa3, 0xa0,
0xd2, 0xd2, 0xd2, 0x12, 0xe5, 0xf7, 0x75, 0x75, 0x75, 0xf5, 0xba, 0x74,
0xe9, 0xd2, 0x2d, 0x2b, 0x2b, 0x2b, 0xf3, 0xd5, 0xab, 0x57, 0x61, 0x8a,
0xbf, 0xb7, 0x6f, 0xdf, 0xbe, 0x93, 0x91, 0x91, 0x91, 0xb1, 0xba, 0xb4,
0x14, 0x14, 0x14, 0xe4, 0x3f, 0x7f, 0xfe, 0x3c, 0xb8, 0xba, 0x72, 0x35,
0x35, 0x35, 0x35, 0x77, 0x77, 0x77, 0x6f, 0x97, 0x94, 0x94, 0x94, 0xf8,
0xfe, 0xfd, 0xfb, 0xb7, 0xca, 0xbf, 0x75, 0xef, 0xde, 0xbd, 0xb7, 0x4c,
0x26, 0x93, 0x3d, 0x7c, 0xf8, 0xf0, 0x9e, 0xea, 0x7b, 0xce, 0xce, 0xce,
0x2d, 0xea, 0xd6, 0xad, 0x6b, 0xfb, 0xf6, 0xed, 0xdb, 0xd7, 0x1f, 0x3e,
0x7c, 0x48, 0x06, 0x80, 0x36, 0x6d, 0xda, 0xb4, 0x35, 0x37, 0x37, 0xb7,
0x08, 0x0a, 0x0a, 0x0a, 0x14, 0x8b, 0xc5, 0x55, 0x0e, 0x30, 0x3d, 0x3c,
0x3c, 0x7a, 0x68, 0x6b, 0x6b, 0x6b, 0x27, 0x26, 0x26, 0x26, 0xc4, 0xc4,
0xc4, 0x44, 0x2b, 0xff, 0xa6, 0xd0, 0x1d, 0x65, 0x65, 0x65, 0x65, 0x0f,
0x1e, 0x3c, 0x08, 0x54, 0x2e, 0x9f, 0x98, 0x98, 0x98, 0xf7, 0x89, 0x89,
0x89, 0x71, 0xca, 0xe1, 0x79, 0x3c, 0x1e, 0xbf, 0x57, 0xaf, 0x5e, 0x7d,
0x32, 0x33, 0x33, 0x33, 0x22, 0x22, 0x22, 0xc2, 0x95, 0x7f, 0xd3, 0xd0,
0xd0, 0x10, 0xb8, 0xb8, 0xb8, 0xb4, 0x68, 0xd3, 0xa6, 0x8d, 0x3b, 0x8f,
0xc7, 0xe3, 0x3d, 0x7f, 0xfe, 0xfc, 0xe9, 0xeb, 0xd7, 0xaf, 0x23, 0x54,
0x07, 0xd1, 0x66, 0x66, 0x66, 0x16, 0x6e, 0x6e, 0x6e, 0x6d, 0x15, 0xff,
0xa6, 0x69, 0x9a, 0xce, 0xcc, 0xcc, 0xcc, 0x48, 0x4e, 0x4e, 0x4e, 0x2c,
0x2a, 0x2a, 0x2a, 0xac, 0x2c, 0x1f, 0x35, 0x8d, 0xdf, 0xc0, 0xc0, 0xc0,
0xb0, 0x63, 0xc7, 0x8e, 0x5d, 0x14, 0xff, 0x2e, 0x2b, 0x2b, 0x2b, 0x4b,
0x4b, 0x4b, 0x4b, 0xfd, 0xf0, 0xe1, 0x43, 0x72, 0x55, 0x65, 0xc5, 0xe3,
0xf1, 0xf8, 0x5d, 0xba, 0x74, 0xe9, 0xe6, 0xe0, 0xe0, 0xd0, 0x58, 0x57,
0x57, 0x57, 0x37, 0x32, 0x32, 0x32, 0x22, 0x22, 0x22, 0x22, 0xbc, 0xa0,
0xa0, 0x20, 0x5f, 0x39, 0x9c, 0x97, 0x97, 0x57, 0xff, 0xea, 0xea, 0x9a,
0xa6, 0x69, 0x3a, 0x20, 0x20, 0xe0, 0x16, 0x00, 0xb4, 0x6b, 0xd7, 0xae,
0xa3, 0xb1, 0xb1, 0xb1, 0x49, 0x40, 0x40, 0xc0, 0x6d, 0x9a, 0xa6, 0xe5,
0xaa, 0xdf, 0xec, 0xd7, 0xaf, 0xdf, 0x80, 0xfc, 0xfc, 0xfc, 0xfc, 0x27,
0x4f, 0x9e, 0x3c, 0x74, 0x76, 0x76, 0x76, 0xad, 0x5b, 0xb7, 0xae, 0x6d,
0x68, 0x68, 0xe8, 0x8b, 0xdc, 0xdc, 0xdc, 0x6c, 0x75, 0x71, 0x5b, 0x58,
0x58, 0x58, 0xb6, 0x6e, 0xdd, 0xda, 0x2d, 0x2d, 0x2d, 0x2d, 0xd5, 0xca,
0xca, 0xca, 0x3a, 0x37, 0x37, 0x37, 0xe7, 0xe5, 0xcb, 0x97, 0xa1, 0x55,
0xa5, 0xa7, 0x55, 0xab, 0x56, 0x6e, 0x66, 0x66, 0x66, 0xe6, 0x0f, 0x1f,
0x3e, 0xbc, 0xef, 0xe9, 0xe9, 0xd9, 0xb3, 0xa4, 0xa4, 0xa4, 0xe4, 0xf1,
0xe3, 0xc7, 0x41, 0xea, 0xc2, 0x76, 0xec, 0xd8, 0xb1, 0x8b, 0xbe, 0xbe,
0xbe, 0x41, 0x60, 0x60, 0xe0, 0x9d, 0xa6, 0x4d, 0x9b, 0x3a, 0xd6, 0xab,
0x57, 0xaf, 0x41, 0x54, 0x54, 0x54, 0x44, 0x65, 0xba, 0xc3, 0xc6, 0xc6,
0xc6, 0xd6, 0xc5, 0xc5, 0xa5, 0x45, 0x4a, 0x4a, 0x4a, 0x72, 0x74, 0x74,
0xf4, 0x9b, 0xf6, 0xed, 0xdb, 0x77, 0xac, 0xac, 0xad, 0x28, 0xa8, 0xac,
0xcd, 0xf4, 0xea, 0xd5, 0xab, 0x2f, 0x8f, 0xc7, 0xe3, 0x29, 0xff, 0xed,
0xc9, 0x93, 0x27, 0x0f, 0x55, 0x0d, 0xd7, 0xea, 0xc6, 0x15, 0xaa, 0xe8,
0xeb, 0xeb, 0x1b, 0x74, 0xea, 0xd4, 0xa9, 0x6b, 0x65, 0x75, 0x54, 0x05,
0xd4, 0x88, 0x11, 0x23, 0x46, 0xbf, 0x78, 0xf1, 0xe2, 0x79, 0x72, 0x72,
0x72, 0x42, 0x4d, 0xbe, 0x55, 0x0b, 0x34, 0x2d, 0x2c, 0x2c, 0x3a, 0x1e,
0x3b, 0x76, 0x6c, 0xc9, 0xb5, 0x6b, 0xd7, 0xee, 0x0d, 0x1c, 0x38, 0xb0,
0x37, 0x80, 0x2f, 0x32, 0x38, 0x95, 0xe0, 0x4d, 0x98, 0x30, 0xc1, 0x7b,
0xeb, 0xd6, 0xad, 0xcb, 0x87, 0x0e, 0x1d, 0x3a, 0xe9, 0xd2, 0xa5, 0x4b,
0x27, 0x00, 0xd0, 0x5f, 0x19, 0x67, 0x8d, 0xbf, 0xdd, 0xbd, 0x7b, 0xf7,
0x41, 0x17, 0x2f, 0x5e, 0x3c, 0xb6, 0x78, 0xf1, 0xe2, 0x8d, 0x5b, 0xb7,
0x6e, 0xfd, 0xf5, 0x1b, 0x7c, 0x9b, 0x1a, 0x37, 0x6e, 0xdc, 0x0f, 0x3e,
0x3e, 0x3e, 0x3b, 0x4d, 0x4c, 0x4c, 0x8c, 0x14, 0x7f, 0xbc, 0x77, 0xef,
0xde, 0xe3, 0x1e, 0x3d, 0x7a, 0x78, 0x7c, 0x41, 0xfc, 0xbc, 0xb1, 0x63,
0xc7, 0xce, 0xd8, 0xb5, 0x6b, 0xd7, 0xea, 0x51, 0xa3, 0x46, 0x4d, 0x3b,
0x7f, 0xfe, 0xfc, 0xe1, 0x5a, 0xc6, 0x41, 0x5d, 0xba, 0x74, 0xe9, 0x7a,
0xef, 0xde, 0xbd, 0xbb, 0xd7, 0xaf, 0x5f, 0xbf, 0x51, 0x4e, 0x4e, 0x4e,
0x66, 0x4d, 0xde, 0x39, 0x74, 0xe8, 0xd0, 0xd1, 0x89, 0x13, 0x27, 0x8e,
0x73, 0x76, 0x76, 0x6e, 0x11, 0x13, 0x13, 0xf3, 0x56, 0xe5, 0x77, 0x81,
0xbf, 0xbf, 0xff, 0xdd, 0x92, 0x92, 0x12, 0x51, 0xe3, 0xc6, 0x8d, 0xed,
0x00, 0xc8, 0xaa, 0xcb, 0xc3, 0xc8, 0x91, 0x23, 0xa7, 0xec, 0xd9, 0xb3,
0x67, 0xbd, 0xe2, 0x0f, 0x32, 0x99, 0x4c, 0x2e, 0x10, 0x08, 0x74, 0x00,
0x48, 0xbf, 0xb2, 0xbc, 0x39, 0x38, 0xfe, 0x2b, 0xe0, 0xf3, 0xf9, 0xfc,
0x86, 0x0d, 0x1b, 0xda, 0xeb, 0xe9, 0xe9, 0xe9, 0x46, 0x46, 0x46, 0xbe,
0xaa, 0x24, 0x98, 0xc6, 0xfe, 0xfd, 0xfb, 0x8f, 0x49, 0x24, 0x12, 0x59,
0xbf, 0x7e, 0xfd, 0x3c, 0x51, 0x49, 0xdb, 0x69, 0xd1, 0xa2, 0x45, 0x2b,
0xa1, 0x50, 0x58, 0x92, 0x94, 0x94, 0x14, 0xff, 0xa5, 0x93, 0x7a, 0xff,
0xaf, 0x70, 0x74, 0x74, 0x6c, 0x49, 0xd3, 0x34, 0xfd, 0xc7, 0x1f, 0x7f,
0x5c, 0x04, 0x20, 0x50, 0xf9, 0x99, 0xda, 0xbd, 0x7b, 0xf7, 0x3e, 0xa2,
0xc2, 0xea, 0xd5, 0xab, 0x37, 0x02, 0xa0, 0x2a, 0x8b, 0xb3, 0x65, 0xcb,
0x96, 0xee, 0xf1, 0xf1, 0xf1, 0x29, 0x84, 0x10, 0x32, 0x7d, 0xfa, 0xf4,
0xe5, 0x50, 0xbf, 0xe2, 0x4f, 0x0d, 0x1b, 0x36, 0x6c, 0x74, 0x46, 0x46,
0xc6, 0x47, 0xe5, 0xb8, 0x69, 0x9a, 0xa6, 0x0f, 0x1c, 0x38, 0x70, 0x94,
0xa2, 0xa8, 0x0a, 0x9d, 0xbf, 0x9d, 0x9d, 0x5d, 0xe3, 0x73, 0xe7, 0xce,
0x5d, 0x54, 0x4d, 0x0b, 0x4d, 0xd3, 0xf4, 0xe1, 0xc3, 0x87, 0x4f, 0xf2,
0x78, 0xbc, 0xea, 0x76, 0x15, 0x50, 0xab, 0x56, 0xad, 0xfa, 0x8d, 0x10,
0x42, 0x3e, 0x7e, 0xfc, 0x58, 0x08, 0x40, 0x4b, 0xe5, 0x77, 0xfe, 0xd6,
0xad, 0x5b, 0x0f, 0x93, 0x4a, 0xe8, 0xde, 0xbd, 0xfb, 0x70, 0x00, 0x3c,
0xd5, 0x48, 0xf9, 0x7c, 0xbe, 0xc6, 0xd6, 0xad, 0x5b, 0x77, 0xd1, 0x34,
0x4d, 0x2b, 0x87, 0xf7, 0xf6, 0xf6, 0x5e, 0xa7, 0x94, 0x6f, 0x8d, 0x83,
0x07, 0x0f, 0xfa, 0x91, 0x6a, 0xf0, 0xf1, 0xf1, 0x39, 0x0d, 0xa5, 0x09,
0x18, 0x53, 0x53, 0x53, 0x8b, 0xe0, 0xe0, 0xe0, 0x17, 0xaa, 0xe1, 0x9e,
0x3f, 0x7f, 0x1e, 0x66, 0x6e, 0x6e, 0x6e, 0xa9, 0x9a, 0x96, 0xba, 0x75,
0xeb, 0xd6, 0x7f, 0xf8, 0xf0, 0xe1, 0x53, 0xe5, 0xb0, 0x72, 0xb9, 0x5c,
0x3e, 0x7f, 0xfe, 0xfc, 0x5f, 0xaa, 0xaa, 0xaf, 0xff, 0x05, 0x9a, 0x36,
0x6d, 0xea, 0x14, 0x15, 0x15, 0x15, 0xad, 0xae, 0xdc, 0xa3, 0xa2, 0xa2,
0xde, 0xb9, 0xba, 0xba, 0xb6, 0x56, 0xf3, 0x1a, 0xf5, 0xe3, 0x8f, 0x3f,
0xce, 0x88, 0x8d, 0x8d, 0x4d, 0x50, 0x84, 0x95, 0xc9, 0x64, 0xb2, 0xfb,
0xf7, 0xef, 0x3f, 0xb2, 0xb1, 0xb1, 0xa9, 0x57, 0xd9, 0xb7, 0x3a, 0x77,
0xee, 0xdc, 0x5b, 0x11, 0xbe, 0x7d, 0xfb, 0xf6, 0x9e, 0x6a, 0x82, 0x08,
0x2e, 0x5e, 0xbc, 0x78, 0xbf, 0x32, 0x39, 0x88, 0x8c, 0x8c, 0x7c, 0x3b,
0x62, 0xc4, 0x88, 0xb1, 0x50, 0x53, 0x67, 0xda, 0xda, 0xda, 0xba, 0x3e,
0x3e, 0x3e, 0xfb, 0xd5, 0xbd, 0x57, 0x5a, 0x5a, 0x2a, 0xea, 0xd3, 0xa7,
0xcf, 0xc0, 0xca, 0xe2, 0x2f, 0x29, 0x29, 0x29, 0xbd, 0x79, 0xf3, 0xe6,
0x9d, 0x46, 0x8d, 0x1a, 0x39, 0xa8, 0x49, 0x93, 0x66, 0x52, 0x52, 0x52,
0x56, 0x55, 0xf2, 0x39, 0x6a, 0xd4, 0xa8, 0x9f, 0x50, 0xde, 0x06, 0x34,
0x0e, 0x1f, 0x3e, 0x7c, 0xa9, 0xaa, 0xf0, 0xfb, 0xf7, 0xef, 0xbf, 0x00,
0x95, 0x09, 0x45, 0x17, 0x17, 0x97, 0x56, 0x31, 0x31, 0x31, 0xf1, 0xea,
0xd2, 0xd6, 0xb5, 0x6b, 0xd7, 0x1e, 0xaa, 0xe5, 0xe3, 0xe0, 0xe0, 0xd0,
0x5a, 0xa5, 0x1c, 0x28, 0x07, 0x07, 0x87, 0xd6, 0x84, 0x10, 0x72, 0xf1,
0xe2, 0xc5, 0xfb, 0x28, 0xd7, 0x59, 0x82, 0x47, 0x8f, 0x1e, 0x45, 0xa8,
0x4b, 0x07, 0x4d, 0xd3, 0xf4, 0xdd, 0xbb, 0x77, 0x43, 0xf0, 0xb9, 0x7e,
0x53, 0x85, 0xe7, 0xe9, 0xe9, 0x39, 0x8c, 0x10, 0x42, 0x76, 0xee, 0xdc,
0x79, 0x42, 0x25, 0xed, 0x9a, 0x05, 0x05, 0x05, 0xc2, 0xc4, 0xc4, 0xc4,
0x4c, 0x00, 0x9a, 0xca, 0x2f, 0xb5, 0x68, 0xd1, 0xc2, 0xbd, 0xa4, 0xa4,
0x44, 0xf4, 0xfa, 0xf5, 0xeb, 0x64, 0x03, 0x03, 0x83, 0xa6, 0x6c, 0x19,
0x09, 0xfc, 0xfd, 0xfd, 0x9f, 0x11, 0x42, 0x88, 0xb5, 0xb5, 0x75, 0x63,
0x54, 0xdd, 0xfe, 0x34, 0x53, 0x53, 0x53, 0x73, 0x08, 0x21, 0xc4, 0xcf,
0xcf, 0x2f, 0x40, 0xe5, 0xbb, 0x1a, 0xfe, 0xfe, 0xfe, 0xc1, 0x84, 0x10,
0x92, 0x9a, 0x9a, 0x9a, 0xc3, 0x7e, 0xfb, 0x53, 0xf9, 0x3c, 0x79, 0xf2,
0xe4, 0xa5, 0x6a, 0x19, 0x6b, 0x6b, 0x6b, 0x9b, 0x10, 0x42, 0xc8, 0xb9,
0x73, 0xe7, 0xee, 0x28, 0xff, 0x66, 0x6d, 0x6d, 0x6d, 0x1b, 0x12, 0x12,
0xf2, 0x52, 0xb5, 0x7c, 0x1e, 0x3f, 0x7e, 0xfc, 0xdc, 0xd4, 0xd4, 0xd4,
0x42, 0xb9, 0x1c, 0xbc, 0xbc, 0xbc, 0xc6, 0x54, 0x56, 0xaf, 0x57, 0xae,
0x5c, 0xb9, 0xe9, 0xe4, 0xe4, 0xe4, 0xa2, 0x9a, 0x89, 0x5a, 0xc4, 0x4f,
0xb9, 0xba, 0xba, 0x76, 0x55, 0x17, 0xb7, 0x50, 0x28, 0x2c, 0xd9, 0xb1,
0x63, 0x87, 0x8f, 0xa1, 0xa1, 0xa1, 0xb1, 0x6a, 0xfc, 0x6d, 0xdb, 0xb6,
0xed, 0xf8, 0xf6, 0xed, 0xdb, 0x58, 0x75, 0xef, 0x25, 0x26, 0x26, 0x26,
0xdb, 0xdb, 0xdb, 0x2b, 0x26, 0x56, 0xb5, 0x48, 0x0d, 0x10, 0x8b, 0xc5,
0x52, 0x30, 0xfd, 0x80, 0x20, 0x38, 0x38, 0xf8, 0x35, 0x21, 0x84, 0xe8,
0xe8, 0xe8, 0x98, 0xaa, 0x69, 0x73, 0x26, 0x84, 0x10, 0x12, 0x1c, 0x1c,
0xfc, 0x06, 0x80, 0xce, 0xac, 0x59, 0xb3, 0x36, 0x10, 0x42, 0xc8, 0xf2,
0xe5, 0xcb, 0x7f, 0x83, 0x9a, 0x3e, 0x01, 0x00, 0x6f, 0xed, 0xda, 0xb5,
0xbb, 0x09, 0x21, 0x64, 0xd6, 0xac, 0x59, 0xbf, 0x25, 0x24, 0x24, 0x64,
0x3e, 0x7b, 0xf6, 0xec, 0x75, 0x35, 0xf2, 0x27, 0x78, 0xf8, 0xf0, 0xe1,
0xcb, 0xa4, 0xa4, 0xa4, 0x2c, 0x00, 0x26, 0x37, 0x6e, 0xdc, 0x78, 0x4e,
0xd3, 0x34, 0xdd, 0xb1, 0x63, 0xc7, 0xee, 0x6a, 0xca, 0xa1, 0x2b, 0x4d,
0xd3, 0xf4, 0xa9, 0x53, 0xa7, 0xee, 0x02, 0xd0, 0xeb, 0xde, 0xbd, 0xfb,
0x0f, 0x84, 0x10, 0x72, 0xed, 0xda, 0xb5, 0x7b, 0x50, 0xdf, 0xd7, 0xf2,
0xaf, 0x5f, 0xbf, 0x7e, 0x9f, 0x10, 0x42, 0x3a, 0x77, 0xee, 0x3c, 0x16,
0x80, 0x4e, 0x68, 0x68, 0xe8, 0xbb, 0xea, 0xca, 0x27, 0x38, 0x38, 0x58,
0x5d, 0x9a, 0xb5, 0xc4, 0x62, 0xb1, 0x54, 0x35, 0xac, 0x8b, 0x8b, 0x4b,
0x67, 0x15, 0x19, 0x17, 0x1c, 0x3c, 0x78, 0xf0, 0xaa, 0x5c, 0x2e, 0xa7,
0x1d, 0x1c, 0x1c, 0x9a, 0xa3, 0x7a, 0x28, 0x17, 0x17, 0x97, 0xce, 0xaa,
0xf1, 0x4a, 0x24, 0x12, 0x45, 0x1d, 0x55, 0x4a, 0x8b, 0x16, 0x2d, 0xda,
0xb3, 0xfa, 0x20, 0x00, 0xdf, 0x7e, 0x77, 0xa1, 0x16, 0x80, 0xb1, 0x2b,
0x56, 0xac, 0xc8, 0x22, 0x84, 0x90, 0xde, 0xbd, 0x7b, 0x0f, 0xff, 0x06,
0x71, 0xea, 0x2c, 0x5a, 0xb4, 0xe8, 0x32, 0x21, 0x84, 0x0c, 0x19, 0x32,
0x64, 0x0b, 0x54, 0xf4, 0xc9, 0xdf, 0x8c, 0xe6, 0x90, 0x21, 0x43, 0xb6,
0x10, 0x42, 0xc8, 0xcf, 0x3f, 0xff, 0x7c, 0x05, 0x80, 0xce, 0xd7, 0x46,
0x68, 0x61, 0x61, 0x51, 0x4f, 0x28, 0x14, 0x96, 0x65, 0x67, 0x67, 0x4b,
0xe7, 0xcf, 0x9f, 0x9f, 0xd7, 0xb6, 0x6d, 0xdb, 0xf4, 0xef, 0xbe, 0xfb,
0x2e, 0xb5, 0x7d, 0xfb, 0xf6, 0x97, 0x01, 0x18, 0x7e, 0x49, 0xf9, 0xcc,
0x9d, 0x3b, 0xf7, 0x02, 0x21, 0x84, 0x8c, 0x1c, 0x39, 0x72, 0x17, 0xaa,
0xa9, 0x7f, 0x35, 0x18, 0x9c, 0x3b, 0x77, 0x2e, 0x3e, 0x2f, 0x2f, 0x4f,
0x66, 0x64, 0x64, 0xd4, 0x02, 0x35, 0x1b, 0xfb, 0xe8, 0xfb, 0xf8, 0xf8,
0x84, 0x95, 0x96, 0x96, 0xca, 0xed, 0xed, 0xed, 0xbf, 0xc3, 0xe7, 0x72,
0x64, 0x9a, 0x9e, 0x9e, 0x2e, 0x8e, 0x8d, 0x8d, 0x2d, 0x05, 0x60, 0x52,
0x83, 0xf8, 0xb4, 0x29, 0x8a, 0x9a, 0x68, 0x62, 0x62, 0x12, 0xd9, 0xb8,
0x71, 0xe3, 0x94, 0xe8, 0xe8, 0x68, 0x99, 0x54, 0x2a, 0xa5, 0x01, 0x98,
0x7f, 0x6d, 0x79, 0x73, 0xd4, 0x8e, 0xb6, 0x6d, 0xdb, 0x76, 0x98, 0x33,
0x67, 0xce, 0x02, 0xfc, 0x8f, 0x8f, 0x81, 0xbf, 0x31, 0xd4, 0xd4, 0xa9,
0x53, 0x7f, 0x4a, 0x4b, 0x4b, 0xcb, 0x60, 0xfb, 0x8a, 0x08, 0x54, 0xde,
0xbf, 0x19, 0x05, 0x04, 0x04, 0xa4, 0xdf, 0xba, 0x75, 0xeb, 0x03, 0x2a,
0xd7, 0x07, 0x82, 0x67, 0xcf, 0x9e, 0x45, 0x11, 0x42, 0x48, 0x5a, 0x5a,
0x5a, 0xc6, 0xd4, 0xa9, 0x53, 0x7f, 0xc2, 0xff, 0x78, 0x7d, 0x69, 0xf8,
0xf8, 0xf8, 0xfc, 0x45, 0x08, 0x21, 0x8e, 0x8e, 0x8e, 0xfb, 0x00, 0xe8,
0x29, 0xfd, 0x46, 0x2d, 0x5a, 0xb4, 0x68, 0x15, 0x3b, 0xc8, 0x13, 0x36,
0x69, 0xd2, 0x24, 0xcd, 0xc9, 0xc9, 0x29, 0xed, 0xe2, 0xc5, 0x8b, 0x42,
0x42, 0x08, 0x99, 0x32, 0x65, 0xca, 0x5c, 0x7c, 0x5e, 0x78, 0xd4, 0xc4,
0x89, 0x13, 0xa7, 0x95, 0x96, 0x96, 0x96, 0xa5, 0xa5, 0xa5, 0x89, 0x09,
0x21, 0x64, 0xfa, 0xf4, 0xe9, 0x27, 0x01, 0x68, 0xab, 0x7e, 0xd8, 0xd2,
0xd2, 0xb2, 0x41, 0x76, 0x76, 0x76, 0x51, 0x58, 0x58, 0x58, 0xc9, 0x80,
0x01, 0x03, 0xb2, 0x2c, 0x2d, 0x2d, 0x53, 0xfa, 0xf5, 0xeb, 0x97, 0xfd,
0xfc, 0xf9, 0xf3, 0x32, 0x42, 0x08, 0xf9, 0xe9, 0xa7, 0x9f, 0x16, 0x2b,
0xc5, 0xcf, 0xef, 0xdb, 0xb7, 0xef, 0x74, 0xa1, 0x50, 0x28, 0xdd, 0xb8,
0x71, 0x63, 0xbe, 0xbb, 0xbb, 0x7b, 0xba, 0xb9, 0xb9, 0x79, 0xca, 0x90,
0x21, 0x43, 0x72, 0x42, 0x42, 0x42, 0xc4, 0x84, 0x10, 0xb2, 0x68, 0xd1,
0xa2, 0xd5, 0xa8, 0xa2, 0x32, 0x5b, 0xb5, 0x6a, 0xd5, 0x59, 0x22, 0x91,
0xc8, 0x52, 0x53, 0x53, 0x65, 0x1f, 0x3f, 0x7e, 0x94, 0x02, 0x50, 0x1d,
0x84, 0xe9, 0x1d, 0x3d, 0x7a, 0xf4, 0x15, 0x21, 0x84, 0x7c, 0xff, 0xfd,
0xf7, 0xb9, 0xa3, 0x46, 0x8d, 0xca, 0x51, 0x3c, 0xa3, 0x47, 0x8f, 0xfe,
0x50, 0xa7, 0x4e, 0x9d, 0x61, 0x50, 0x11, 0x3e, 0x3e, 0x9f, 0x2f, 0xf0,
0xf7, 0xf7, 0x0f, 0x22, 0x84, 0x90, 0x23, 0x47, 0x8e, 0x14, 0xb6, 0x6d,
0xdb, 0x36, 0x4d, 0x4f, 0x4f, 0x2f, 0xd1, 0xc2, 0xc2, 0xe2, 0x9d, 0xb9,
0xb9, 0xf9, 0x6c, 0xa5, 0x7c, 0xeb, 0xb9, 0xbb, 0xbb, 0x1f, 0x19, 0x35,
0x6a, 0x54, 0xc6, 0xc8, 0x91, 0x23, 0xb3, 0x95, 0x9f, 0x51, 0xa3, 0x46,
0xe5, 0xec, 0xdb, 0xb7, 0xaf, 0x84, 0xcd, 0xf3, 0x6d, 0xa5, 0x3a, 0xe0,
0x9d, 0x39, 0x73, 0xe6, 0x26, 0x21, 0x84, 0x6c, 0xd9, 0xb2, 0xa5, 0xd0,
0xce, 0xce, 0x2e, 0xcd, 0xde, 0xde, 0x3e, 0x6d, 0xdb, 0xb6, 0x6d, 0x45,
0x84, 0x10, 0x72, 0xf6, 0xec, 0xd9, 0x5b, 0xa8, 0xd8, 0x81, 0xf0, 0x6f,
0xdf, 0xbe, 0xfd, 0x44, 0x2a, 0x95, 0xd2, 0xf3, 0xe7, 0xcf, 0xcf, 0xb5,
0xb4, 0xb4, 0x4c, 0x71, 0x72, 0x72, 0x4a, 0xbd, 0x7a, 0xf5, 0xaa, 0x90,
0x10, 0x42, 0x7e, 0xf8, 0xe1, 0x87, 0xff, 0x65, 0x61, 0xe7, 0x0b, 0x04,
0x82, 0x96, 0x4f, 0x9e, 0x3c, 0xc9, 0xdf, 0xb0, 0x61, 0x43, 0x41, 0xb7,
0x6e, 0xdd, 0xb2, 0x1a, 0x35, 0x6a, 0x94, 0xe6, 0xe1, 0xe1, 0x91, 0xb5,
0x79, 0xf3, 0xe6, 0x42, 0xb9, 0x5c, 0x4e, 0x27, 0x25, 0x25, 0x65, 0x69,
0x6b, 0x6b, 0x1b, 0x28, 0xbd, 0x43, 0xad, 0x5b, 0xb7, 0x6e, 0x9b, 0x5c,
0x2e, 0xa7, 0x7f, 0xfb, 0xed, 0xb7, 0xa4, 0xae, 0x5d, 0xbb, 0xa6, 0xd8,
0xd8, 0xd8, 0x24, 0x0e, 0x1c, 0x38, 0x30, 0xe5, 0xd5, 0xab, 0x57, 0xf9,
0xa9, 0xa9, 0xa9, 0x59, 0x4d, 0x9a, 0x34, 0x51, 0x37, 0xe8, 0x14, 0xec,
0xda, 0xb5, 0xeb, 0x92, 0x58, 0x2c, 0xa6, 0x65, 0x32, 0x19, 0xd9, 0xb6,
0x6d, 0xdb, 0x05, 0x7c, 0xae, 0xb4, 0x0c, 0x2f, 0x5e, 0xbc, 0x98, 0x48,
0x08, 0x21, 0x93, 0x26, 0x4d, 0xca, 0xeb, 0xdd, 0xbb, 0x77, 0xa6, 0x97,
0x97, 0x57, 0xd6, 0xa8, 0x51, 0xa3, 0xb2, 0xb7, 0x6d, 0xdb, 0x56, 0x28,
0x12, 0x89, 0xe4, 0x52, 0xa9, 0x54, 0xd6, 0xa9, 0x53, 0xa7, 0x9e, 0xca,
0x2f, 0x99, 0x98, 0x98, 0x98, 0xbf, 0x7e, 0xfd, 0xfa, 0x3d, 0x21, 0x84,
0x84, 0x84, 0x84, 0x94, 0xfd, 0xf0, 0xc3, 0x0f, 0xb9, 0x2d, 0x5b, 0xb6,
0xcc, 0x18, 0x30, 0x60, 0x40, 0xf6, 0x8e, 0x1d, 0x3b, 0x8a, 0xef, 0xdd,
0xbb, 0x57, 0xac, 0xab, 0xab, 0xfb, 0x1d, 0x00, 0x33, 0xe5, 0xf8, 0xfb,
0xf7, 0xef, 0x9f, 0x35, 0x6f, 0xde, 0xbc, 0xbc, 0x33, 0x67, 0xce, 0x14,
0xd2, 0x34, 0x4d, 0x84, 0x42, 0x61, 0xe9, 0xc8, 0x91, 0x23, 0xc7, 0xa3,
0xa2, 0x3c, 0x98, 0x26, 0x25, 0x25, 0x95, 0x09, 0x85, 0x42, 0x7a, 0xe8,
0xd0, 0xa1, 0xd9, 0x6a, 0x9e, 0x14, 0x5b, 0x5b, 0xdb, 0x69, 0x28, 0x1f,
0x48, 0xea, 0x1f, 0x3e, 0x7c, 0xf8, 0x35, 0x3b, 0xc8, 0x2b, 0x54, 0x13,
0x3e, 0xbd, 0x55, 0xab, 0x56, 0x07, 0xa1, 0xa4, 0x53, 0x3c, 0x3c, 0x3c,
0x7a, 0x97, 0x94, 0x94, 0x94, 0x49, 0xa5, 0x52, 0x7a, 0xcd, 0x9a, 0x35,
0x05, 0x9d, 0x3b, 0x77, 0xce, 0x6c, 0xd5, 0xaa, 0x55, 0xe6, 0xb4, 0x69,
0xd3, 0xf2, 0xee, 0xdd, 0xbb, 0x57, 0xac, 0xad, 0xad, 0xdd, 0x13, 0x8c,
0x31, 0xf9, 0xa9, 0x7c, 0x1c, 0x1c, 0x1c, 0x06, 0x40, 0x45, 0xce, 0x1d,
0x1c, 0x1c, 0x06, 0xb0, 0x83, 0xf1, 0x44, 0x94, 0x2b, 0x7b, 0x43, 0x00,
0x87, 0xf9, 0x7c, 0xfe, 0x5b, 0x73, 0x73, 0xf3, 0xa4, 0xbc, 0xbc, 0x3c,
0xfa, 0xe3, 0xc7, 0x8f, 0x72, 0x73, 0x73, 0xf3, 0x24, 0x3e, 0x9f, 0xff,
0x06, 0xc0, 0x7e, 0x00, 0xca, 0xf5, 0xab, 0x0e, 0x81, 0xa7, 0xa7, 0xe7,
0x62, 0x42, 0x08, 0xd9, 0xb1, 0x63, 0xc7, 0x73, 0x54, 0xd4, 0x87, 0x66,
0x05, 0x05, 0x05, 0xb2, 0xc4, 0xc4, 0xc4, 0x32, 0x28, 0xe9, 0x0e, 0x33,
0x33, 0x33, 0xeb, 0x84, 0x84, 0x84, 0x8c, 0xdc, 0xdc, 0x5c, 0x99, 0xbd,
0xbd, 0xfd, 0x1d, 0x00, 0x75, 0xd9, 0x72, 0x35, 0xba, 0x7d, 0xfb, 0x76,
0x3a, 0x21, 0x84, 0x58, 0x5b, 0x5b, 0x77, 0x81, 0x7a, 0x23, 0xee, 0x53,
0xd9, 0xa7, 0xa5, 0xa5, 0x89, 0x0b, 0x0a, 0x0a, 0xe8, 0xe4, 0xe4, 0x64,
0x21, 0x2a, 0x76, 0x60, 0x46, 0x79, 0x79, 0x79, 0xe2, 0xc2, 0xc2, 0x42,
0x3a, 0x2d, 0x2d, 0x4d, 0xcc, 0x7e, 0xfb, 0x53, 0xf9, 0x10, 0x42, 0x48,
0xb7, 0x6e, 0xdd, 0x06, 0x29, 0xcb, 0xad, 0xb6, 0xb6, 0x76, 0x23, 0x56,
0x6f, 0xc7, 0x29, 0xf2, 0xac, 0xa5, 0xa5, 0xa5, 0x97, 0x98, 0x98, 0x98,
0x4e, 0x08, 0x21, 0x87, 0x0f, 0x1f, 0x16, 0x76, 0xea, 0xd4, 0x29, 0xcb,
0xdd, 0xdd, 0x3d, 0x73, 0xe7, 0xce, 0x9d, 0x85, 0x84, 0x10, 0xf2, 0xfa,
0xf5, 0xeb, 0x58, 0x0d, 0x0d, 0x0d, 0xc5, 0x20, 0x58, 0xd3, 0xcb, 0xcb,
0x6b, 0x25, 0xab, 0x67, 0x44, 0xbd, 0x7b, 0xf7, 0xce, 0xea, 0xd7, 0xaf,
0x5f, 0xd6, 0x94, 0x29, 0x53, 0x72, 0x6f, 0xdf, 0xbe, 0x5d, 0x4a, 0x08,
0x21, 0xc9, 0xc9, 0xc9, 0x59, 0x26, 0x26, 0x26, 0x9f, 0x26, 0x08, 0x6b,
0x19, 0xbf, 0x86, 0xab, 0xab, 0xeb, 0xf7, 0x84, 0x10, 0x12, 0x18, 0x18,
0x28, 0xe9, 0xdd, 0xbb, 0x77, 0xd6, 0x80, 0x01, 0x03, 0xb2, 0x66, 0xcd,
0x9a, 0x95, 0x1b, 0x1a, 0x1a, 0x2a, 0x62, 0xeb, 0xf6, 0xb6, 0x72, 0x99,
0x99, 0x98, 0x98, 0x58, 0x65, 0x66, 0x66, 0xe6, 0x49, 0x24, 0x12, 0x7a,
0xc3, 0x86, 0x0d, 0x85, 0x5e, 0x5e, 0x5e, 0xd9, 0xad, 0x5b, 0xb7, 0xce,
0x9c, 0x36, 0x6d, 0x5a, 0xde, 0xe1, 0xc3, 0x87, 0x85, 0x37, 0x6e, 0xdc,
0xc8, 0x01, 0xd0, 0x8c, 0x7d, 0xc7, 0x6c, 0xc8, 0x90, 0x21, 0x09, 0xca,
0xf2, 0x58, 0x54, 0x54, 0x44, 0xe7, 0xe7, 0xe7, 0x57, 0x90, 0xed, 0x41,
0x83, 0x06, 0xc5, 0xb2, 0xe5, 0x69, 0x1c, 0x1c, 0x1c, 0x9c, 0xc7, 0x1a,
0xe7, 0xf6, 0x2a, 0xed, 0xe2, 0x53, 0x79, 0x06, 0x07, 0x07, 0xe7, 0x01,
0xb0, 0xb2, 0xb2, 0xb2, 0x5a, 0x20, 0x97, 0xcb, 0x49, 0x68, 0x68, 0x68,
0x1a, 0x00, 0x5d, 0x35, 0xf5, 0xa9, 0x17, 0x15, 0x15, 0x95, 0x25, 0x97,
0xcb, 0x89, 0xa5, 0xa5, 0xe5, 0x9a, 0x80, 0x80, 0x80, 0xfc, 0x8f, 0x1f,
0x3f, 0x96, 0x01, 0x30, 0xae, 0x42, 0x06, 0x8c, 0xe2, 0xe3, 0xe3, 0x85,
0x41, 0x41, 0x41, 0xf9, 0x00, 0x1a, 0xd8, 0xd9, 0xd9, 0x9d, 0x11, 0x89,
0x44, 0x74, 0x78, 0x78, 0x78, 0x1c, 0x8f, 0xc7, 0xfb, 0xd4, 0x7f, 0xf2,
0x78, 0x3c, 0xad, 0x90, 0x90, 0x90, 0xf7, 0x85, 0x85, 0x85, 0x72, 0x4b,
0x4b, 0xcb, 0xfd, 0x60, 0x0c, 0x85, 0x9e, 0xb7, 0x6e, 0xdd, 0x12, 0x12,
0x42, 0x48, 0xdb, 0xb6, 0x6d, 0x7b, 0xaa, 0x46, 0xdc, 0xbe, 0x7d, 0xfb,
0xde, 0x84, 0x10, 0x72, 0xe9, 0xd2, 0xa5, 0x22, 0x00, 0xdd, 0x00, 0x98,
0xf7, 0xea, 0xd5, 0xeb, 0xc1, 0xc8, 0x91, 0x23, 0xb3, 0xd4, 0xf5, 0x47,
0x67, 0xcf, 0x9e, 0x15, 0x11, 0x42, 0xc8, 0xc6, 0x8d, 0x1b, 0xa3, 0x01,
0x18, 0xa9, 0x44, 0x67, 0x2e, 0x16, 0x8b, 0xe9, 0xb7, 0x6f, 0xdf, 0xca,
0x9c, 0x9d, 0x9d, 0xd3, 0x9c, 0x9d, 0x9d, 0x53, 0x9d, 0x9d, 0x9d, 0xa3,
0xb5, 0xb5, 0xb5, 0x3b, 0xa8, 0xb4, 0x53, 0x3d, 0x17, 0x17, 0x97, 0x43,
0x84, 0x10, 0xb2, 0x73, 0xe7, 0xce, 0x33, 0xa8, 0xde, 0x68, 0xe6, 0x6b,
0x6b, 0x6b, 0x77, 0x70, 0x76, 0x76, 0x8e, 0x66, 0xe3, 0x4c, 0x7b, 0xf3,
0xe6, 0x8d, 0x4c, 0x22, 0x91, 0x54, 0x67, 0xd0, 0x68, 0xfc, 0xf9, 0xe7,
0x9f, 0x01, 0x71, 0x71, 0x71, 0x12, 0x42, 0x08, 0x71, 0x73, 0x73, 0xeb,
0x8e, 0x6f, 0x0b, 0xc5, 0x96, 0xf1, 0x8a, 0xdd, 0xbb, 0x77, 0xe7, 0x5d,
0xbb, 0x76, 0x2d, 0x04, 0x5f, 0x6f, 0x4c, 0xeb, 0x2e, 0x5c, 0xb8, 0xf0,
0x3a, 0x21, 0x84, 0x0c, 0x1e, 0x3c, 0x78, 0x07, 0x6a, 0x6f, 0x7c, 0x7e,
0x0d, 0x5a, 0x83, 0x07, 0x0f, 0xde, 0xc1, 0xea, 0xed, 0x1b, 0x50, 0x2f,
0xbf, 0xb5, 0x81, 0xd7, 0xbb, 0x77, 0xef, 0xc9, 0x84, 0x10, 0x72, 0xe0,
0xc0, 0x81, 0x42, 0x00, 0x4b, 0x01, 0xf4, 0x01, 0x30, 0x14, 0x40, 0x27,
0x54, 0x3f, 0x21, 0xaa, 0x0e, 0x9d, 0xb9, 0x73, 0xe7, 0x5e, 0x62, 0x8d,
0xf3, 0x3d, 0x5f, 0x50, 0x3e, 0x06, 0x00, 0xf6, 0x68, 0x6a, 0x6a, 0x06,
0x03, 0xa8, 0x8f, 0x9a, 0x8d, 0x7b, 0xf4, 0x00, 0xac, 0xd7, 0xd2, 0xd2,
0x0a, 0x01, 0xe0, 0x8a, 0xcf, 0xe5, 0xd5, 0x2c, 0x3d, 0x3d, 0x5d, 0x1a,
0x13, 0x13, 0x23, 0xc2, 0xe7, 0x63, 0x47, 0x75, 0x50, 0x6c, 0x9c, 0xf6,
0x00, 0x3c, 0x43, 0x43, 0x43, 0x4b, 0xa4, 0x52, 0x29, 0x01, 0x60, 0x51,
0x83, 0x77, 0x39, 0xbe, 0x1d, 0x02, 0x1f, 0x1f, 0x9f, 0x0b, 0x81, 0x81,
0x81, 0x6f, 0xf1, 0x0d, 0x26, 0xa2, 0x38, 0x18, 0x3a, 0x76, 0xec, 0xd8,
0x93, 0x10, 0x42, 0x12, 0x12, 0x12, 0xca, 0x46, 0x8c, 0x18, 0x91, 0xee,
0xe4, 0xe4, 0x74, 0x05, 0x95, 0x1b, 0xde, 0xc6, 0x77, 0xef, 0xde, 0xcd,
0xba, 0x75, 0xeb, 0x56, 0x3a, 0x3e, 0xef, 0x4f, 0x14, 0x18, 0x35, 0x6b,
0xd6, 0xec, 0xea, 0x88, 0x11, 0x23, 0xd2, 0x13, 0x13, 0x13, 0xc5, 0xec,
0xc4, 0x74, 0x4f, 0xfc, 0xaf, 0x62, 0x68, 0x68, 0x68, 0x53, 0x5c, 0x5c,
0x2c, 0xb9, 0x73, 0xe7, 0x8e, 0x08, 0x40, 0x67, 0x54, 0x5c, 0x81, 0xd1,
0x8d, 0x8d, 0x8d, 0xcd, 0x4e, 0x4e, 0x4e, 0x96, 0x69, 0x69, 0x69, 0x9d,
0x04, 0xe0, 0x01, 0xc0, 0x53, 0x47, 0x47, 0xe7, 0x4c, 0x6a, 0x6a, 0xaa,
0x2c, 0x22, 0x22, 0x22, 0x15, 0x15, 0x8d, 0x6e, 0x6a, 0xc5, 0x8a, 0x15,
0x1b, 0x08, 0x21, 0xe4, 0xfa, 0xf5, 0xeb, 0xc5, 0x03, 0x06, 0x0c, 0xc8,
0x60, 0x8d, 0xf3, 0x33, 0xf8, 0xbc, 0x51, 0xf0, 0x00, 0x34, 0xb2, 0xb3,
0xb3, 0x0b, 0xd6, 0xd0, 0xd0, 0xf0, 0x07, 0x30, 0x0e, 0x40, 0x2b, 0x00,
0x63, 0xba, 0x74, 0xe9, 0x12, 0x46, 0x08, 0x21, 0x77, 0xef, 0xde, 0x7d,
0xa7, 0xf4, 0x9e, 0x00, 0x80, 0x97, 0xbe, 0xbe, 0xfe, 0x73, 0x00, 0x1b,
0x01, 0xf4, 0x02, 0xe0, 0x02, 0x60, 0xbc, 0x87, 0x87, 0xc7, 0x4b, 0x42,
0x08, 0x09, 0x0a, 0x0a, 0x8a, 0x43, 0x25, 0x8d, 0x4f, 0x53, 0x53, 0x53,
0x2f, 0x22, 0x22, 0x22, 0xe1, 0xce, 0x9d, 0x3b, 0x25, 0xd7, 0xaf, 0x5f,
0x17, 0x7d, 0xfc, 0xf8, 0x51, 0x86, 0xcf, 0x3b, 0x7c, 0x83, 0x6b, 0xd7,
0xae, 0x25, 0x0b, 0x85, 0x42, 0x1a, 0xc0, 0x5c, 0x00, 0x13, 0x95, 0x9e,
0x31, 0x00, 0x6c, 0x51, 0x71, 0x80, 0x4d, 0x8d, 0x18, 0x31, 0x62, 0x0a,
0x21, 0x84, 0xac, 0x59, 0xb3, 0x26, 0x1f, 0xc0, 0x01, 0x00, 0x5e, 0x00,
0xec, 0x00, 0x34, 0x06, 0x60, 0xad, 0x14, 0x5e, 0x00, 0xa0, 0x1d, 0x9b,
0xcf, 0x09, 0x2a, 0xcf, 0x94, 0x7b, 0xf7, 0xee, 0x65, 0x16, 0x15, 0x15,
0xd1, 0x06, 0x06, 0x06, 0x0b, 0x94, 0xf2, 0x60, 0x90, 0x97, 0x97, 0x57,
0x96, 0x91, 0x91, 0x21, 0xd7, 0xd0, 0xd0, 0xd8, 0x0e, 0xa0, 0x03, 0x80,
0x8e, 0x02, 0x81, 0x60, 0x47, 0x46, 0x46, 0x86, 0x3c, 0x2f, 0x2f, 0xaf,
0x0c, 0x4a, 0x8d, 0xc1, 0xcd, 0xcd, 0xad, 0x3b, 0x21, 0x84, 0x04, 0x04,
0x04, 0x88, 0x00, 0xfc, 0xc2, 0x96, 0xa7, 0x27, 0x9f, 0xcf, 0x3f, 0x93,
0x9b, 0x9b, 0x2b, 0x8f, 0x89, 0x89, 0xc9, 0xe2, 0xf1, 0x78, 0x5f, 0xdb,
0x11, 0x7f, 0x13, 0x0c, 0x0d, 0x0d, 0x8d, 0x97, 0x2e, 0x5d, 0xba, 0x72,
0xd6, 0xac, 0x59, 0xf3, 0xf0, 0x65, 0x13, 0x06, 0xd4, 0x9c, 0x39, 0x73,
0x16, 0x2c, 0x59, 0xb2, 0x64, 0x85, 0xbe, 0xbe, 0x7e, 0x4d, 0x66, 0xe6,
0x29, 0x30, 0x9d, 0xe2, 0x9f, 0x00, 0xd6, 0x03, 0x18, 0x08, 0xc0, 0x1d,
0xc0, 0x00, 0x00, 0x5b, 0xce, 0x9c, 0x39, 0x23, 0x22, 0x84, 0x90, 0x8e,
0x1d, 0x3b, 0x0e, 0x52, 0xa4, 0x67, 0xc0, 0x80, 0x01, 0xa3, 0x65, 0x32,
0x19, 0xfd, 0xfd, 0xf7, 0xdf, 0x7f, 0x00, 0xb0, 0x19, 0x40, 0x7f, 0xb6,
0x4c, 0xc7, 0x19, 0x1a, 0x1a, 0x06, 0x84, 0x87, 0x87, 0x17, 0x9f, 0x3b,
0x77, 0xee, 0x2e, 0x54, 0x56, 0x2d, 0x29, 0x8a, 0x32, 0x48, 0x49, 0x49,
0x29, 0x0a, 0x0a, 0x0a, 0x92, 0x3e, 0x7d, 0xfa, 0x54, 0x96, 0x94, 0x94,
0x54, 0x08, 0x40, 0x5f, 0x25, 0x3d, 0x46, 0x7e, 0x7e, 0x7e, 0x1f, 0x58,
0xe3, 0x73, 0x13, 0x98, 0x81, 0xcc, 0x50, 0x00, 0x93, 0x00, 0xec, 0xdc,
0xb7, 0x6f, 0x9f, 0x90, 0x10, 0x42, 0xb6, 0x6d, 0xdb, 0xf6, 0x17, 0xca,
0x07, 0x37, 0xbc, 0x9d, 0x3b, 0x77, 0x1e, 0x23, 0x84, 0x90, 0xd3, 0xa7,
0x4f, 0x8b, 0x34, 0x35, 0x35, 0x03, 0x01, 0xfc, 0x04, 0xa0, 0x07, 0x80,
0xd1, 0x00, 0xb6, 0x00, 0x38, 0x01, 0xc6, 0x38, 0x34, 0x56, 0x8a, 0x7f,
0x33, 0x18, 0xf9, 0x5d, 0x04, 0xe0, 0x44, 0x8f, 0x1e, 0x3d, 0x3e, 0x16,
0x14, 0x14, 0xc8, 0xf3, 0xf3, 0xf3, 0x4b, 0x2c, 0x2c, 0x2c, 0x94, 0x57,
0xff, 0xcd, 0x92, 0x92, 0x92, 0xc4, 0xf9, 0xf9, 0xf9, 0x72, 0x00, 0xd3,
0x01, 0x8c, 0x55, 0x79, 0x46, 0x00, 0x68, 0x84, 0xf2, 0x41, 0x8b, 0x81,
0xaf, 0xaf, 0x6f, 0x34, 0x21, 0x84, 0xb4, 0x6a, 0xd5, 0xea, 0x10, 0x80,
0xef, 0x55, 0xc2, 0x8f, 0x02, 0xe0, 0xa6, 0x54, 0x3e, 0x9a, 0x61, 0x61,
0x61, 0x71, 0x84, 0x10, 0xd2, 0xbf, 0x7f, 0xff, 0x2c, 0x00, 0x1b, 0xd8,
0x32, 0xed, 0x01, 0x60, 0x36, 0x80, 0xa3, 0x60, 0xda, 0x0c, 0xa5, 0x52,
0x3e, 0x83, 0xf1, 0xb9, 0x71, 0x3e, 0x98, 0x10, 0x42, 0xfc, 0xfc, 0xfc,
0x3e, 0xa0, 0x5c, 0xd9, 0x53, 0x60, 0x8c, 0x1f, 0x2b, 0x00, 0x6d, 0xb3,
0xb3, 0xb3, 0x65, 0x19, 0x19, 0x19, 0x32, 0xb6, 0x9e, 0xad, 0xd8, 0x70,
0xd5, 0xc9, 0x9a, 0xc0, 0xd3, 0xd3, 0x73, 0x29, 0x6b, 0x50, 0x84, 0xaa,
0xd4, 0x9b, 0x79, 0x41, 0x41, 0x81, 0x3c, 0x31, 0x31, 0x51, 0x0c, 0xc0,
0x0c, 0x00, 0xf8, 0x7c, 0xbe, 0xe6, 0xdd, 0xbb, 0x77, 0x9f, 0xc9, 0x64,
0x32, 0xba, 0x47, 0x8f, 0x1e, 0xf1, 0x00, 0x3a, 0x2a, 0xd5, 0x97, 0xd1,
0xed, 0xdb, 0xb7, 0xb3, 0x58, 0xe3, 0xdc, 0x03, 0x55, 0x1b, 0xe7, 0x66,
0x69, 0x69, 0x69, 0x92, 0x87, 0x0f, 0x1f, 0x4a, 0x08, 0x21, 0xc4, 0xca,
0xca, 0xca, 0x49, 0xf1, 0x43, 0xe3, 0xc6, 0x8d, 0xdb, 0x13, 0x42, 0xc8,
0xfd, 0xfb, 0xf7, 0x25, 0x69, 0x69, 0x69, 0x12, 0xf6, 0xdb, 0x46, 0x7e,
0x7e, 0x7e, 0x1f, 0x52, 0x52, 0x52, 0xe8, 0xac, 0xac, 0x2c, 0xf9, 0x9d,
0x3b, 0x77, 0x5e, 0xa1, 0xdc, 0x60, 0xa0, 0xb4, 0xb5, 0xb5, 0xed, 0x59,
0xc3, 0x3a, 0x09, 0x8c, 0x8e, 0xa0, 0x7e, 0xf8, 0xe1, 0x87, 0x05, 0xac,
0xc1, 0x5e, 0x06, 0xe0, 0x20, 0x2b, 0xfb, 0x7d, 0x95, 0xe5, 0x6d, 0xd4,
0xa8, 0x51, 0xd3, 0xd9, 0x32, 0xd2, 0xf4, 0xf2, 0xf2, 0x5a, 0x43, 0x08,
0x21, 0x9b, 0x37, 0x6f, 0x7e, 0xc7, 0xca, 0xd7, 0x70, 0xb6, 0x9e, 0x2e,
0x9e, 0x3c, 0x79, 0x52, 0x44, 0x08, 0x21, 0xf3, 0xe6, 0xcd, 0xdb, 0xc0,
0xe6, 0xab, 0xb6, 0xf1, 0x6b, 0xb8, 0xba, 0xba, 0x4e, 0x24, 0x84, 0x90,
0x3f, 0xff, 0xfc, 0x33, 0x83, 0x95, 0x97, 0xd1, 0x00, 0x16, 0x99, 0x9a,
0x9a, 0x3e, 0x2c, 0x2b, 0x2b, 0xa3, 0x09, 0x21, 0xa4, 0x69, 0xd3, 0xa6,
0xee, 0x0a, 0xd9, 0x1f, 0x38, 0x70, 0xe0, 0x34, 0x42, 0x08, 0x39, 0x76,
0xec, 0x58, 0x09, 0x80, 0xdf, 0xd8, 0xf4, 0xf4, 0x04, 0x30, 0x0b, 0xc0,
0x1f, 0xec, 0x37, 0x15, 0x2b, 0x5a, 0x5a, 0x6c, 0x7b, 0x52, 0xc8, 0xe2,
0xb4, 0xec, 0xec, 0x6c, 0x39, 0x2b, 0x0f, 0xd3, 0xd8, 0xbf, 0x8d, 0x01,
0x30, 0x98, 0x0d, 0x6b, 0x12, 0x1c, 0x1c, 0x5c, 0xc0, 0x1a, 0xe7, 0xaa,
0xbb, 0x1c, 0x3e, 0x95, 0x67, 0x70, 0x70, 0x70, 0x01, 0x5b, 0xfe, 0x2e,
0xf7, 0xef, 0xdf, 0x2f, 0x23, 0x84, 0x90, 0x06, 0x0d, 0x1a, 0xb4, 0x54,
0xad, 0xcc, 0xc6, 0x8d, 0x1b, 0xb7, 0x65, 0xeb, 0xac, 0x0c, 0x40, 0xe7,
0xfd, 0xfb, 0xf7, 0x27, 0x11, 0x42, 0x88, 0xbe, 0xbe, 0x7e, 0x55, 0xc7,
0x9a, 0x4c, 0x45, 0x22, 0x91, 0xfc, 0xd8, 0xb1, 0x63, 0x29, 0x60, 0xfa,
0xa6, 0x0e, 0xab, 0x57, 0xaf, 0xce, 0x25, 0x84, 0x90, 0x19, 0x33, 0x66,
0x2c, 0x61, 0xd3, 0x44, 0x4d, 0x9b, 0x36, 0xed, 0x67, 0x42, 0x08, 0x99,
0x3d, 0x7b, 0x76, 0x3a, 0x80, 0x16, 0x6c, 0xdb, 0x30, 0x73, 0x75, 0x75,
0xbd, 0x43, 0xd3, 0x34, 0xb9, 0x75, 0xeb, 0x96, 0xea, 0x0e, 0x11, 0xc1,
0xdd, 0xbb, 0x77, 0x5f, 0xca, 0x64, 0x32, 0xe2, 0xe8, 0xe8, 0x78, 0x0d,
0x8c, 0x61, 0xa1, 0x05, 0xa6, 0xaf, 0xfa, 0x1e, 0x2a, 0xfd, 0x51, 0xbd,
0x7a, 0xf5, 0x7e, 0x29, 0x28, 0x28, 0x90, 0xbe, 0x7a, 0xf5, 0x4a, 0xaa,
0xa9, 0xa9, 0xb9, 0x0e, 0x15, 0x27, 0xa8, 0x00, 0xc0, 0x42, 0x2c, 0x16,
0xd3, 0x21, 0x21, 0x21, 0x25, 0x60, 0x8c, 0xb0, 0x4e, 0x60, 0xfa, 0x36,
0x43, 0x95, 0x72, 0xd3, 0x00, 0xe0, 0x71, 0xef, 0xde, 0x3d, 0x51, 0x41,
0x41, 0x41, 0x99, 0xbe, 0xbe, 0xbe, 0x15, 0xaa, 0x86, 0x62, 0xe3, 0x68,
0xc7, 0xc6, 0xd9, 0x27, 0x24, 0x24, 0xa4, 0x84, 0x35, 0xce, 0x2b, 0x35,
0x68, 0xea, 0xd7, 0xaf, 0xef, 0x2c, 0x95, 0x4a, 0xe5, 0xfd, 0xfa, 0xf5,
0x4b, 0x0c, 0x08, 0x08, 0x10, 0xdd, 0xbe, 0x7d, 0xbb, 0x26, 0x3b, 0x64,
0x6a, 0x8b, 0xa2, 0xff, 0xd8, 0x00, 0x60, 0x3b, 0xaa, 0x9f, 0xe4, 0xab,
0x0e, 0x65, 0xe3, 0x7c, 0x3b, 0xfe, 0xdd, 0xc6, 0xb9, 0xe6, 0x0f, 0x3f,
0xfc, 0xb0, 0x9b, 0x10, 0x42, 0xa6, 0x4d, 0x9b, 0xf6, 0x90, 0x2d, 0x27,
0x01, 0x18, 0x7d, 0xf4, 0xa5, 0xc7, 0x30, 0xbf, 0xd6, 0x38, 0x57, 0xc8,
0x52, 0x1d, 0xd4, 0x7c, 0x27, 0x05, 0x05, 0x46, 0xdf, 0x5b, 0x42, 0xbd,
0xfc, 0xd4, 0xd6, 0x38, 0x57, 0x8e, 0xd7, 0x3c, 0x34, 0x34, 0xb4, 0x98,
0x33, 0xce, 0xff, 0x23, 0xe8, 0xbf, 0x7d, 0xfb, 0x36, 0xe7, 0xde, 0xbd,
0x7b, 0x99, 0xa8, 0xdc, 0x30, 0xe4, 0xa8, 0x1d, 0x82, 0xc5, 0x8b, 0x17,
0x1f, 0x62, 0x17, 0x69, 0x93, 0x01, 0xfc, 0x08, 0xa0, 0x0d, 0x2a, 0x6f,
0xef, 0x35, 0x31, 0xce, 0x35, 0xd8, 0x38, 0xa6, 0x4c, 0x9f, 0x3e, 0x3d,
0x85, 0x10, 0x42, 0x96, 0x2c, 0x59, 0xe2, 0x8b, 0x6f, 0xaf, 0xcb, 0xff,
0x15, 0xf0, 0xe6, 0xce, 0x9d, 0xbb, 0x9e, 0x10, 0x42, 0x06, 0x0c, 0x18,
0xf0, 0x04, 0x2a, 0x0a, 0xa7, 0x6d, 0xdb, 0xb6, 0x5e, 0x84, 0x10, 0xb2,
0x7f, 0xff, 0xfe, 0x8f, 0x60, 0x66, 0xff, 0x04, 0xec, 0xd3, 0xf8, 0xc0,
0x81, 0x03, 0xd9, 0x84, 0x10, 0xe2, 0xea, 0xea, 0xaa, 0x7c, 0x3e, 0x4c,
0xa7, 0x79, 0xf3, 0xe6, 0x1b, 0x36, 0x6e, 0xdc, 0x98, 0xcb, 0xe7, 0xf3,
0xcf, 0xf7, 0xeb, 0xd7, 0x6f, 0x7f, 0x15, 0xc6, 0x39, 0xc0, 0x28, 0x6f,
0x27, 0x30, 0x0a, 0x54, 0x0b, 0x8c, 0x12, 0xd5, 0x13, 0x08, 0x04, 0x43,
0xa5, 0x52, 0x29, 0x79, 0xf5, 0xea, 0x55, 0x01, 0x2a, 0x56, 0xa4, 0x36,
0x18, 0xc3, 0x43, 0x9f, 0x4d, 0x07, 0x0f, 0x80, 0xbe, 0x8e, 0x8e, 0xce,
0x28, 0x9a, 0xa6, 0xc9, 0x8b, 0x17, 0x2f, 0xf2, 0xa1, 0x7e, 0x65, 0x82,
0xda, 0xb8, 0x71, 0xe3, 0x1e, 0xa9, 0x54, 0x4a, 0xb7, 0x6a, 0xd5, 0xea,
0x71, 0x40, 0x40, 0x40, 0x2e, 0xbb, 0x72, 0xae, 0x6a, 0x9c, 0x1b, 0x3d,
0x7d, 0xfa, 0x34, 0x27, 0x36, 0x36, 0x56, 0xc2, 0x7e, 0x47, 0x4b, 0xe5,
0x51, 0x1d, 0x5c, 0x6b, 0x3d, 0x7d, 0xfa, 0x34, 0x2e, 0x37, 0x37, 0x57,
0xae, 0xaf, 0xaf, 0xbf, 0x99, 0xcd, 0x87, 0x00, 0x8c, 0x32, 0xe6, 0xe1,
0x73, 0x43, 0x40, 0x43, 0x4d, 0x9c, 0xda, 0x2e, 0x2e, 0x2e, 0xdd, 0x09,
0x21, 0x64, 0xcf, 0x9e, 0x3d, 0x79, 0x00, 0x1c, 0x94, 0xbe, 0x63, 0xf6,
0xee, 0xdd, 0xbb, 0xb2, 0xc4, 0xc4, 0x44, 0x09, 0x18, 0xa3, 0x48, 0x03,
0x80, 0x06, 0x8f, 0xc7, 0xb3, 0x4f, 0x4d, 0x4d, 0x95, 0xbe, 0x79, 0xf3,
0xa6, 0x0c, 0xac, 0x91, 0x00, 0x40, 0x63, 0xe2, 0xc4, 0x89, 0x9b, 0xd8,
0x1d, 0x04, 0xaf, 0xc1, 0x18, 0x23, 0x7c, 0x36, 0x3d, 0xf6, 0xc7, 0x8f,
0x1f, 0x2f, 0x20, 0x84, 0x90, 0x76, 0xed, 0xda, 0xf5, 0x55, 0x27, 0x08,
0x5a, 0x5a, 0x5a, 0x3a, 0x61, 0x61, 0x61, 0x11, 0xa1, 0xa1, 0xa1, 0xaf,
0x34, 0x35, 0x35, 0xb5, 0x51, 0x0d, 0x14, 0x45, 0xf1, 0x1e, 0x3d, 0x7a,
0x14, 0xfc, 0xfa, 0xf5, 0xeb, 0x77, 0x46, 0x46, 0x46, 0x35, 0xd9, 0xe2,
0x05, 0x00, 0x30, 0x36, 0x36, 0x36, 0x5d, 0xb5, 0x6a, 0xd5, 0x86, 0xbc,
0xbc, 0xbc, 0x82, 0xb2, 0xb2, 0x32, 0xe9, 0xb8, 0x71, 0xe3, 0xf6, 0x42,
0xcd, 0xae, 0x8a, 0x1a, 0xa0, 0x3d, 0x71, 0xe2, 0xc4, 0x03, 0x62, 0xb1,
0x58, 0x96, 0x9b, 0x9b, 0x9b, 0xff, 0xeb, 0xaf, 0xbf, 0xae, 0xab, 0x41,
0x3a, 0x78, 0x60, 0xe4, 0x49, 0x0f, 0x8c, 0xec, 0xf1, 0xd9, 0xff, 0x5a,
0x2d, 0x5e, 0xbc, 0x38, 0x9c, 0x10, 0x42, 0x3a, 0x74, 0xe8, 0xe0, 0xad,
0xa8, 0xa7, 0x87, 0x0f, 0x1f, 0x46, 0x5f, 0xb8, 0x70, 0xa1, 0x00, 0x8c,
0xa1, 0x6a, 0xd6, 0xba, 0x75, 0xeb, 0x8e, 0x63, 0xc6, 0x8c, 0xf9, 0xa1,
0x4d, 0x9b, 0x36, 0x5d, 0xb4, 0xb5, 0xb5, 0x5b, 0x0f, 0x1e, 0x3c, 0x38,
0x54, 0x2e, 0x97, 0xd3, 0x4d, 0x9a, 0x34, 0x71, 0x53, 0xfe, 0x48, 0x87,
0x0e, 0x1d, 0xfa, 0x13, 0x42, 0xc8, 0xca, 0x95, 0x2b, 0x93, 0x57, 0xaf,
0x5e, 0x9d, 0x4a, 0x08, 0x21, 0xee, 0xee, 0xee, 0xbd, 0x55, 0xd2, 0xa2,
0x6c, 0x7c, 0x0e, 0x07, 0xd3, 0x3e, 0x34, 0xd9, 0xb2, 0xb0, 0xec, 0xd9,
0xb3, 0xe7, 0x15, 0x42, 0x08, 0x39, 0x74, 0xe8, 0xd0, 0x2b, 0x36, 0xbd,
0xb0, 0xb7, 0xb7, 0x6f, 0x21, 0x91, 0x48, 0xe4, 0x05, 0x05, 0x05, 0xb4,
0xb1, 0xb1, 0xf1, 0x9f, 0xac, 0x4c, 0xe8, 0xb0, 0x75, 0xac, 0x05, 0xa6,
0x5d, 0x18, 0x2a, 0xf2, 0xa9, 0x26, 0x7e, 0x5d, 0x56, 0x5e, 0x46, 0x2c,
0x5b, 0xb6, 0x2c, 0x9b, 0x6d, 0xdb, 0xe7, 0x95, 0xe5, 0x4d, 0xc9, 0x38,
0xb7, 0x51, 0x23, 0xab, 0x9a, 0xa8, 0xd8, 0x06, 0x3e, 0x19, 0xe7, 0xad,
0x5b, 0xb7, 0x9e, 0xc9, 0xa6, 0x53, 0xf5, 0x9d, 0x4f, 0xca, 0x7a, 0xe0,
0xc0, 0x81, 0xe3, 0x09, 0x21, 0xc4, 0xdf, 0xdf, 0xbf, 0x0c, 0x8c, 0x51,
0x60, 0x8c, 0x72, 0x9d, 0xa2, 0xa3, 0x94, 0x76, 0xd5, 0xf2, 0x19, 0x8c,
0x9a, 0x19, 0xe7, 0xca, 0x58, 0xb0, 0xc6, 0xb9, 0x14, 0xb5, 0x1b, 0x0c,
0xd5, 0xc6, 0x38, 0xa7, 0x76, 0xec, 0xd8, 0x71, 0x90, 0x10, 0x42, 0xe6,
0xcc, 0x99, 0x93, 0x0d, 0xc6, 0x58, 0x54, 0xd6, 0x73, 0xb5, 0x36, 0xce,
0x0f, 0x1e, 0x3c, 0xf8, 0x91, 0xd5, 0xc7, 0xb3, 0xd8, 0xf0, 0xfc, 0xb1,
0x63, 0xc7, 0xae, 0x90, 0x4a, 0xa5, 0x64, 0xef, 0xde, 0xbd, 0x99, 0x2a,
0xc6, 0x79, 0x4a, 0x5a, 0x5a, 0x9a, 0x6c, 0xc9, 0x92, 0x25, 0xb9, 0xec,
0x8a, 0x69, 0x2f, 0x36, 0x2e, 0x75, 0xc6, 0xb9, 0xf6, 0xd3, 0xa7, 0x4f,
0xe3, 0x09, 0x21, 0xa4, 0x73, 0xe7, 0xce, 0xb7, 0xc0, 0x4c, 0x82, 0x68,
0xb2, 0x65, 0x6f, 0xe9, 0xe2, 0xe2, 0x72, 0x86, 0x10, 0x42, 0x1e, 0x3e,
0x7c, 0xf8, 0x5e, 0x51, 0xd7, 0x0a, 0xe3, 0x7c, 0xd3, 0xa6, 0x4d, 0xcf,
0xc0, 0x18, 0xbd, 0x9a, 0x6c, 0xfe, 0xea, 0xf6, 0xed, 0xdb, 0xf7, 0x0e,
0x21, 0x84, 0xf8, 0xfa, 0xfa, 0x3e, 0x65, 0xff, 0x56, 0xdb, 0xf8, 0x3f,
0x19, 0xe7, 0x27, 0x4f, 0x9e, 0x8c, 0x67, 0xf3, 0xa4, 0xc5, 0xca, 0x50,
0xcb, 0x33, 0x67, 0xce, 0x94, 0xb0, 0x5b, 0x7e, 0x7f, 0x56, 0xb4, 0xd3,
0x1f, 0x7e, 0xf8, 0x61, 0x0f, 0xdb, 0x61, 0x87, 0x82, 0x19, 0x40, 0x2b,
0xe2, 0xd7, 0x01, 0x63, 0x2c, 0x29, 0x1b, 0x87, 0x14, 0xfb, 0xbb, 0x42,
0x0e, 0x6d, 0x94, 0xe4, 0x41, 0x59, 0xb6, 0x15, 0x13, 0x1a, 0xb5, 0x31,
0xce, 0x4d, 0x00, 0x98, 0xfe, 0xf4, 0xd3, 0x4f, 0x51, 0xec, 0x04, 0xc5,
0x36, 0x55, 0xf9, 0x5c, 0xbc, 0x78, 0xf1, 0x1e, 0x76, 0x27, 0x54, 0x14,
0x80, 0xfa, 0x8b, 0x16, 0x2d, 0x7a, 0xc2, 0xf6, 0x97, 0x7d, 0x51, 0xc9,
0x04, 0x91, 0x99, 0x99, 0x59, 0x53, 0x42, 0x08, 0x59, 0xb5, 0x6a, 0x55,
0x28, 0x9b, 0x17, 0x03, 0x6d, 0x6d, 0xed, 0x75, 0xf1, 0xf1, 0xf1, 0xd2,
0xdc, 0xdc, 0xdc, 0x12, 0x33, 0x33, 0x33, 0x5b, 0x33, 0x33, 0x33, 0xdb,
0x9c, 0x9c, 0x1c, 0x61, 0x78, 0x78, 0xb8, 0x98, 0xcf, 0xe7, 0x2f, 0x44,
0xb9, 0xe1, 0x2c, 0x00, 0xd0, 0xfd, 0xe4, 0xc9, 0x93, 0x42, 0x76, 0x92,
0xf1, 0x93, 0x9e, 0xef, 0xd6, 0xad, 0xdb, 0x20, 0xb6, 0xad, 0x17, 0x01,
0xe8, 0x82, 0xf2, 0x36, 0xa9, 0xd0, 0x1b, 0x9f, 0x1e, 0x8a, 0xa2, 0xf4,
0x03, 0x03, 0x03, 0xc3, 0xc4, 0x62, 0x31, 0xed, 0xea, 0xea, 0xfa, 0x14,
0xea, 0x57, 0x1d, 0x2d, 0xc4, 0x62, 0x31, 0x1d, 0x1a, 0x1a, 0x5a, 0xc4,
0xb6, 0x2d, 0x0d, 0x36, 0xff, 0xea, 0xf2, 0x65, 0x36, 0x64, 0xc8, 0x90,
0xe7, 0x84, 0x10, 0x32, 0x6b, 0xd6, 0xac, 0x55, 0xd5, 0xb4, 0x01, 0x45,
0xbd, 0xf1, 0xd9, 0x38, 0x2d, 0x42, 0x43, 0x43, 0x8b, 0xaa, 0x31, 0xce,
0xf9, 0x3b, 0x76, 0xec, 0x38, 0xf5, 0xfe, 0xfd, 0xfb, 0x32, 0x00, 0xd3,
0x3b, 0x75, 0xea, 0xf4, 0x80, 0x10, 0x42, 0xba, 0x76, 0xed, 0xfa, 0x1d,
0xbe, 0x3d, 0x8a, 0x95, 0x50, 0x83, 0xca, 0xea, 0xd0, 0xde, 0xde, 0xbe,
0xc9, 0xda, 0xb5, 0x6b, 0x37, 0x05, 0x05, 0x05, 0x3d, 0x4e, 0x4c, 0x4c,
0x4c, 0x7e, 0xfb, 0xf6, 0x6d, 0xcc, 0xad, 0x5b, 0xb7, 0x02, 0x86, 0x0d,
0x1b, 0x36, 0x5a, 0xe5, 0x9d, 0x4f, 0xc6, 0x79, 0x9f, 0x3e, 0x7d, 0x36,
0x8d, 0x1d, 0x3b, 0xf6, 0xc7, 0xeb, 0xd7, 0xaf, 0xfb, 0xc7, 0xc7, 0xc7,
0x27, 0x5e, 0xbd, 0x7a, 0xf5, 0xd6, 0xa0, 0x41, 0x83, 0xaa, 0xda, 0x3a,
0x4f, 0x7d, 0xff, 0xfd, 0xf7, 0x93, 0x2e, 0x5c, 0xb8, 0x70, 0x39, 0x32,
0x32, 0xf2, 0xed, 0xdb, 0xb7, 0x6f, 0x63, 0x2e, 0x5c, 0xb8, 0x70, 0x79,
0xe5, 0xca, 0x95, 0xeb, 0x6c, 0x6d, 0x6d, 0x3f, 0x9b, 0xfc, 0x19, 0x30,
0x60, 0xc0, 0xd0, 0xab, 0x57, 0xaf, 0xde, 0x8a, 0x8f, 0x8f, 0x4f, 0xbc,
0x7e, 0xfd, 0xba, 0xff, 0xe8, 0xd1, 0xa3, 0x27, 0xf5, 0xeb, 0xd7, 0xef,
0xb7, 0xca, 0x8c, 0xf3, 0x7a, 0xf5, 0xea, 0x35, 0xdc, 0xbf, 0x7f, 0xff,
0xe1, 0x17, 0x2f, 0x5e, 0x84, 0xc7, 0xc4, 0xc4, 0xc4, 0x5f, 0xbc, 0x78,
0xf1, 0x6a, 0xaf, 0x5e, 0xbd, 0x3e, 0x1b, 0x37, 0x74, 0xec, 0xd8, 0xb1,
0xeb, 0xce, 0x9d, 0x3b, 0xf7, 0x9c, 0x3f, 0x7f, 0xfe, 0x4a, 0x74, 0x74,
0x74, 0x16, 0xbb, 0x3b, 0x26, 0xcb, 0xdf, 0xdf, 0x3f, 0xc8, 0xdf, 0xdf,
0x3f, 0xd0, 0xdf, 0xdf, 0x3f, 0xd0, 0xc1, 0xc1, 0xa1, 0xa9, 0xea, 0x7b,
0x83, 0x07, 0x0f, 0x1e, 0xe1, 0xef, 0xef, 0x1f, 0x18, 0x1f, 0x1f, 0x9f,
0x18, 0x15, 0x15, 0x15, 0x7d, 0xe7, 0xce, 0x9d, 0x7b, 0x8a, 0xf0, 0xb7,
0x6f, 0xdf, 0xbe, 0xcb, 0x96, 0xd3, 0x27, 0xe3, 0x7c, 0xd8, 0xb0, 0x61,
0xbf, 0x0f, 0x1a, 0x34, 0x68, 0x8c, 0x9f, 0x9f, 0xdf, 0x95, 0xf8, 0xf8,
0xf8, 0xc4, 0xe7, 0xcf, 0x9f, 0x87, 0x6d, 0xda, 0xb4, 0x69, 0x9b, 0xba,
0x49, 0x79, 0x0f, 0x0f, 0x8f, 0x1e, 0x8a, 0xb8, 0x14, 0x8f, 0x9e, 0x9e,
0x5e, 0x65, 0x13, 0x29, 0xd4, 0x8f, 0x3f, 0xfe, 0x38, 0x43, 0x35, 0xbc,
0xbf, 0xbf, 0x7f, 0x60, 0xd7, 0xae, 0x5d, 0xd5, 0xed, 0xbe, 0xa8, 0xcc,
0x38, 0xa7, 0x86, 0x0e, 0x1d, 0x3a, 0xca, 0xdf, 0xdf, 0x3f, 0x70, 0xcd,
0x9a, 0x35, 0x95, 0x1d, 0xf7, 0x34, 0xa9, 0xca, 0x38, 0x37, 0x35, 0x35,
0x35, 0xf7, 0xf7, 0xf7, 0x0f, 0x6c, 0xdc, 0xb8, 0x71, 0xb3, 0x75, 0xeb,
0xd6, 0x6d, 0x8e, 0x8a, 0x8a, 0x8a, 0xde, 0xbc, 0x79, 0xf3, 0x76, 0x30,
0x67, 0xef, 0x27, 0x86, 0x87, 0x87, 0x47, 0xde, 0xbf, 0x7f, 0xff, 0x51,
0x93, 0x26, 0x4d, 0x9a, 0x29, 0x97, 0xe3, 0xed, 0xdb, 0xb7, 0xef, 0xea,
0xe9, 0xe9, 0x19, 0x0e, 0x1a, 0x34, 0x68, 0x78, 0x4d, 0xca, 0x07, 0x00,
0xdc, 0xdd, 0xdd, 0x3b, 0x9c, 0x3c, 0x79, 0xf2, 0x6c, 0x44, 0x44, 0xc4,
0x9b, 0x88, 0x88, 0x88, 0x37, 0xc7, 0x8e, 0x1d, 0x3b, 0xe5, 0xec, 0xec,
0xdc, 0x42, 0xb5, 0x6c, 0x86, 0x0f, 0x1f, 0x3e, 0xe6, 0xf6, 0xed, 0xdb,
0x77, 0xb5, 0xb5, 0xb5, 0x75, 0x47, 0x8c, 0x18, 0x31, 0x56, 0x21, 0x43,
0xd5, 0xc9, 0xa7, 0x42, 0xde, 0xe2, 0xe2, 0xe2, 0x12, 0xae, 0x5c, 0xb9,
0x72, 0x73, 0xe8, 0xd0, 0xa1, 0xa3, 0xb4, 0xb5, 0xb5, 0x75, 0x6f, 0xdf,
0xbe, 0x7d, 0x77, 0xf8, 0xf0, 0xe1, 0x63, 0x94, 0xcb, 0x67, 0xe0, 0xc0,
0x81, 0xc3, 0x14, 0x75, 0xd4, 0xa0, 0x41, 0x03, 0xbb, 0x9d, 0x3b, 0x77,
0xee, 0x09, 0x09, 0x09, 0x79, 0x19, 0x11, 0x11, 0xf1, 0xe6, 0xc4, 0x89,
0x13, 0x67, 0xd4, 0xc9, 0x4f, 0xcf, 0x9e, 0x3d, 0xfb, 0x5c, 0xbc, 0x78,
0xf1, 0xea, 0x9b, 0x37, 0x6f, 0xde, 0xc7, 0xc6, 0xc6, 0x26, 0x9c, 0x3f,
0x7f, 0xfe, 0xd2, 0x92, 0x25, 0x4b, 0x56, 0x74, 0xec, 0xd8, 0xb1, 0x82,
0xaf, 0x8a, 0x4e, 0x9d, 0x3a, 0x79, 0xac, 0x5b, 0xb7, 0x6e, 0xf3, 0xd5,
0xab, 0x57, 0x03, 0x08, 0x21, 0x24, 0x37, 0x37, 0x57, 0x72, 0xfb, 0xf6,
0xed, 0x07, 0xca, 0xf5, 0xcc, 0xe7, 0xf3, 0x3f, 0x8d, 0x4f, 0x14, 0x72,
0xa9, 0xae, 0xee, 0xbb, 0x76, 0xed, 0xda, 0xdd, 0xdf, 0xdf, 0x3f, 0x70,
0xc8, 0x90, 0x21, 0x23, 0x01, 0x50, 0x06, 0x06, 0x06, 0x46, 0xb7, 0x6e,
0xdd, 0x0a, 0xd8, 0xb1, 0x63, 0x87, 0x4f, 0x25, 0xf5, 0x4d, 0xf9, 0xf8,
0xf8, 0xec, 0xbf, 0x7e, 0xfd, 0xba, 0xbf, 0x9e, 0x9e, 0x9e, 0xe1, 0x95,
0x2b, 0x57, 0x6e, 0xcc, 0x9b, 0x37, 0xef, 0x67, 0x45, 0x58, 0x0d, 0x0d,
0x0d, 0xc1, 0xf5, 0xeb, 0xd7, 0xfd, 0x15, 0xe5, 0xab, 0x78, 0x67, 0xe6,
0xcc, 0x99, 0x73, 0xae, 0x5c, 0xb9, 0x72, 0x83, 0xa2, 0x28, 0xfe, 0xec,
0xd9, 0xb3, 0x17, 0xf8, 0xfb, 0xfb, 0x07, 0x0e, 0x18, 0x30, 0x60, 0xa8,
0xba, 0x32, 0xf6, 0xf7, 0xf7, 0x0f, 0x9c, 0x3d, 0x7b, 0xf6, 0x02, 0x00,
0x94, 0xbe, 0xbe, 0xbe, 0xe1, 0xf5, 0xeb, 0xd7, 0xfd, 0x77, 0xed, 0xda,
0xb5, 0xb7, 0xba, 0xf4, 0xe8, 0xea, 0xea, 0x2a, 0xc6, 0x34, 0xd4, 0xe9,
0xd3, 0xa7, 0x2f, 0xa8, 0x93, 0x7f, 0x75, 0xe5, 0xa3, 0x82, 0xce, 0xaa,
0x55, 0xab, 0xee, 0x10, 0x42, 0x48, 0xef, 0xde, 0xbd, 0xf7, 0x81, 0x19,
0x83, 0x55, 0x35, 0x09, 0x56, 0x13, 0xe3, 0x1c, 0x6c, 0x1c, 0xc6, 0x5e,
0x5e, 0x5e, 0x87, 0xd8, 0xbe, 0xf0, 0x0e, 0xbe, 0x7e, 0xf2, 0xf0, 0xdf,
0x07, 0x45, 0x51, 0xba, 0xb1, 0xb1, 0xb1, 0xd9, 0x71, 0x71, 0x71, 0x52,
0x1e, 0x8f, 0x37, 0x1a, 0x15, 0x67, 0x27, 0x35, 0xc6, 0x8d, 0x1b, 0xb7,
0x81, 0x10, 0x42, 0x7e, 0xfc, 0xf1, 0xc7, 0x7b, 0xa8, 0x38, 0x53, 0x6c,
0x38, 0x65, 0xca, 0x94, 0x20, 0x76, 0x25, 0x64, 0x25, 0xca, 0x3b, 0x7b,
0x0d, 0x00, 0xad, 0x01, 0xfc, 0x0c, 0xa0, 0xe1, 0xa0, 0x41, 0x83, 0xb6,
0x54, 0x63, 0x9c, 0x03, 0x9f, 0x77, 0xd6, 0x54, 0xbb, 0x76, 0xed, 0x86,
0xb0, 0x83, 0x89, 0x34, 0x7c, 0x7e, 0xb6, 0x47, 0x55, 0xf0, 0x78, 0xe3,
0xc7, 0x8f, 0x5f, 0xcc, 0x6e, 0xc1, 0x8b, 0x87, 0x1a, 0xe3, 0xbc, 0x6d,
0xdb, 0xb6, 0xdd, 0x65, 0x32, 0x19, 0xbd, 0x66, 0xcd, 0x9a, 0x8f, 0x00,
0x86, 0x3e, 0x7e, 0xfc, 0x38, 0xaf, 0x12, 0xe3, 0xdc, 0x24, 0x2e, 0x2e,
0xae, 0xe4, 0xf1, 0xe3, 0xc7, 0x45, 0xa8, 0xc1, 0xcc, 0x68, 0xc3, 0x86,
0x0d, 0x5b, 0x12, 0x42, 0xc8, 0x91, 0x23, 0x47, 0xf2, 0xc0, 0xac, 0x94,
0x57, 0x37, 0xf0, 0x50, 0x87, 0x86, 0xaf, 0xaf, 0xef, 0x75, 0x42, 0x08,
0x69, 0xd6, 0xac, 0xd9, 0x71, 0x95, 0x72, 0x36, 0xdd, 0xbe, 0x7d, 0x7b,
0x1a, 0x21, 0x84, 0x0c, 0x1a, 0x34, 0xe8, 0x07, 0x36, 0xef, 0xd4, 0xe4,
0xc9, 0x93, 0x17, 0x12, 0x42, 0xc8, 0xfa, 0xf5, 0xeb, 0x93, 0x95, 0xca,
0x47, 0x7b, 0xd1, 0xa2, 0x45, 0xe7, 0x09, 0x21, 0x64, 0xe0, 0xc0, 0x81,
0xc7, 0x51, 0x51, 0xa0, 0x0d, 0xc7, 0x8e, 0x1d, 0x7b, 0x9f, 0xad, 0xaf,
0xb5, 0xf8, 0x7c, 0x76, 0x8b, 0x6a, 0xd6, 0xac, 0x59, 0x17, 0xc2, 0xd2,
0xb4, 0x69, 0xd3, 0x8e, 0xa8, 0x66, 0x85, 0xd1, 0xca, 0xca, 0xca, 0x51,
0x11, 0xbe, 0x7d, 0xfb, 0xf6, 0x83, 0xab, 0x0b, 0x6f, 0x6e, 0x6e, 0x5e,
0x67, 0xc3, 0x86, 0x0d, 0x5b, 0x0b, 0x0b, 0x0b, 0x8b, 0x85, 0x42, 0xa1,
0x78, 0xfb, 0xf6, 0xed, 0x59, 0xd6, 0xd6, 0xd6, 0xaf, 0xc1, 0xac, 0x5e,
0x69, 0x81, 0x59, 0x11, 0x9a, 0x15, 0x1c, 0x1c, 0xfc, 0xa2, 0xaa, 0x67,
0xf2, 0xe4, 0xc9, 0x8a, 0x95, 0x37, 0x2d, 0x00, 0xdf, 0xdb, 0xda, 0xda,
0xbe, 0xd9, 0xb5, 0x6b, 0x57, 0x56, 0x49, 0x49, 0x89, 0xa4, 0xa0, 0xa0,
0xa0, 0x68, 0xdd, 0xba, 0x75, 0xbf, 0x99, 0x9a, 0x9a, 0xd6, 0xea, 0x4c,
0x17, 0x45, 0x51, 0xfa, 0x8f, 0x1e, 0x3d, 0x4a, 0x16, 0x0a, 0x85, 0xb4,
0x86, 0x86, 0x46, 0x2f, 0x00, 0x82, 0x36, 0x6d, 0xda, 0x74, 0x27, 0x84,
0x10, 0x4f, 0x4f, 0xcf, 0x9b, 0x02, 0x81, 0xa0, 0xee, 0xa9, 0x53, 0xa7,
0x2e, 0x10, 0x42, 0x48, 0x76, 0x76, 0x76, 0x11, 0x21, 0x84, 0xa4, 0xa4,
0xa4, 0xa4, 0x53, 0x14, 0x35, 0x21, 0x3b, 0x3b, 0x5b, 0x36, 0x73, 0xe6,
0xcc, 0xdf, 0x50, 0xae, 0x98, 0x04, 0xdb, 0xb7, 0x6f, 0xf7, 0x23, 0x84,
0x90, 0x16, 0x2d, 0x5a, 0x1c, 0x71, 0x73, 0x73, 0x3b, 0x41, 0x08, 0x21,
0x5b, 0xb6, 0x6c, 0x39, 0x87, 0x8a, 0x33, 0x80, 0x55, 0x19, 0x9f, 0x5a,
0xbb, 0x77, 0xef, 0xbe, 0xc5, 0x2a, 0xbe, 0x8b, 0x60, 0x0c, 0x44, 0xfe,
0xf4, 0xe9, 0xd3, 0x37, 0x12, 0x42, 0xc8, 0x6f, 0xbf, 0xfd, 0x96, 0x0b,
0xa0, 0x39, 0xaa, 0x56, 0x86, 0x55, 0xc5, 0x6f, 0xa4, 0xaf, 0xaf, 0xbf,
0x56, 0x26, 0x93, 0x11, 0x95, 0x55, 0x7d, 0x65, 0xe3, 0xbc, 0x26, 0x65,
0xa8, 0x6c, 0x9c, 0x4f, 0x45, 0xd5, 0xab, 0x24, 0x9a, 0x3b, 0x76, 0xec,
0xb8, 0x4e, 0x08, 0x21, 0xa3, 0x47, 0x8f, 0x7e, 0x81, 0xea, 0x0d, 0xe6,
0xaf, 0x35, 0xce, 0xcd, 0x95, 0x8c, 0x31, 0x33, 0xd4, 0x9c, 0x1a, 0x1b,
0xe7, 0xdf, 0x7f, 0xff, 0xfd, 0x74, 0xd6, 0x40, 0x2d, 0x02, 0xb0, 0x10,
0x9f, 0x6f, 0xe9, 0xaa, 0xb5, 0x71, 0xbe, 0x7d, 0xfb, 0xf6, 0xf7, 0x09,
0x09, 0x09, 0xb2, 0xb5, 0x6b, 0xd7, 0xfe, 0x05, 0x76, 0xb2, 0x66, 0xe7,
0xce, 0x9d, 0x77, 0xc2, 0xc2, 0xc2, 0xc4, 0x3e, 0x3e, 0x3e, 0x31, 0xaa,
0xc6, 0x79, 0x51, 0x51, 0x91, 0xdc, 0xc0, 0xc0, 0xe0, 0xf7, 0xfc, 0xfc,
0x7c, 0xf9, 0x95, 0x2b, 0x57, 0x82, 0xc1, 0x4e, 0x0e, 0xaa, 0x31, 0xce,
0x8d, 0x0b, 0x0b, 0x0b, 0xa5, 0x85, 0x85, 0x85, 0x34, 0x80, 0xef, 0x50,
0x51, 0x16, 0x35, 0x00, 0x74, 0xcb, 0xca, 0xca, 0x92, 0x17, 0x17, 0x17,
0x4b, 0xc1, 0xe8, 0x50, 0xe5, 0x95, 0xf3, 0x60, 0x54, 0x5c, 0x3d, 0xd5,
0xea, 0xd3, 0xa7, 0xcf, 0x26, 0x42, 0x08, 0xf9, 0xfd, 0xf7, 0xdf, 0x23,
0xc0, 0xe8, 0xac, 0xda, 0xc6, 0xaf, 0xbc, 0x72, 0x1e, 0xa7, 0x52, 0x76,
0xc6, 0xf7, 0xef, 0xdf, 0xcf, 0x62, 0x75, 0xe2, 0x5c, 0x45, 0x39, 0xb4,
0x6c, 0xd9, 0x72, 0x15, 0x21, 0x84, 0xc4, 0xc4, 0xc4, 0xe4, 0xea, 0xe8,
0xe8, 0xd4, 0x76, 0xf5, 0xa9, 0x3a, 0x79, 0xa8, 0xad, 0x71, 0xae, 0x63,
0x65, 0x65, 0xf5, 0xab, 0x5c, 0x2e, 0x27, 0x0f, 0x1e, 0x3c, 0x88, 0x47,
0xc5, 0xfe, 0x4d, 0xf7, 0xe9, 0xd3, 0xa7, 0xc9, 0xec, 0x96, 0xf6, 0xe5,
0x60, 0x0c, 0xd4, 0xe3, 0xec, 0x2a, 0xe9, 0x52, 0x30, 0x13, 0xac, 0x1a,
0x21, 0x21, 0x21, 0x2f, 0x5f, 0xbd, 0x7a, 0xf5, 0x9a, 0x9d, 0x0c, 0xe5,
0xb9, 0xba, 0xba, 0x0e, 0x20, 0x84, 0x90, 0x09, 0x13, 0x26, 0x5c, 0x64,
0xcb, 0x9b, 0x02, 0xd0, 0xb0, 0x6f, 0xdf, 0xbe, 0x6f, 0x09, 0x21, 0x64,
0xdf, 0xbe, 0x7d, 0xe7, 0xf6, 0xef, 0xdf, 0x7f, 0x9e, 0xa6, 0x69, 0xd2,
0xb6, 0x6d, 0xdb, 0xa7, 0x60, 0x26, 0x19, 0x94, 0xd3, 0x69, 0xd2, 0xb0,
0x61, 0xc3, 0xb3, 0x62, 0xb1, 0x98, 0xbe, 0x7b, 0xf7, 0xee, 0x4b, 0xb6,
0x0e, 0x34, 0x1f, 0x3e, 0x7c, 0xf8, 0x56, 0x28, 0x14, 0xd2, 0xd6, 0xd6,
0xd6, 0x87, 0x51, 0xf5, 0xc0, 0x88, 0x9a, 0x3b, 0x77, 0xee, 0xaf, 0x84,
0x10, 0xb2, 0x78, 0xf1, 0xe2, 0x6c, 0x00, 0xdd, 0xa1, 0x7e, 0xd5, 0x42,
0xd9, 0x38, 0xaf, 0x6e, 0x42, 0x54, 0x8b, 0xc7, 0xe3, 0x8d, 0x4f, 0x4a,
0x4a, 0x92, 0xbe, 0x7d, 0xfb, 0x36, 0x93, 0xa2, 0xa8, 0xda, 0x0c, 0xb4,
0x4c, 0xaa, 0x33, 0xce, 0x8d, 0x8d, 0x8d, 0x6d, 0x8b, 0x8b, 0x8b, 0xc5,
0xb3, 0x67, 0xcf, 0x7e, 0x0f, 0xa0, 0x1e, 0x80, 0xef, 0x02, 0x02, 0x02,
0x84, 0x0f, 0x1f, 0x3e, 0x7c, 0x83, 0x7f, 0xf6, 0x1c, 0x37, 0x00, 0x68,
0x5c, 0xb9, 0x72, 0x25, 0x48, 0x2a, 0x95, 0xca, 0x83, 0x82, 0x82, 0xb2,
0x0f, 0x1d, 0x3a, 0x94, 0x19, 0x14, 0x14, 0x54, 0x20, 0x93, 0xc9, 0x68,
0x42, 0x08, 0x99, 0x39, 0x73, 0xa6, 0xf2, 0x99, 0xd7, 0x4f, 0xc6, 0xf9,
0xd5, 0xab, 0x57, 0x5f, 0xe5, 0xe5, 0xe5, 0x95, 0x5c, 0xb8, 0x70, 0x21,
0xe9, 0xc4, 0x89, 0x13, 0x99, 0x99, 0x99, 0x99, 0x22, 0x9a, 0xa6, 0x69,
0x6f, 0x6f, 0xef, 0x9f, 0xa1, 0xd2, 0xaf, 0x6a, 0x6b, 0x6b, 0xeb, 0x06,
0x04, 0x04, 0x3c, 0x20, 0x84, 0x90, 0xbc, 0xbc, 0x3c, 0xf1, 0xbd, 0x7b,
0xf7, 0xf2, 0xfc, 0xfd, 0xfd, 0x73, 0xf3, 0xf2, 0xf2, 0xc4, 0x22, 0x91,
0x48, 0x6a, 0x6c, 0x6c, 0xec, 0x82, 0x72, 0x3d, 0x43, 0xcd, 0x98, 0x31,
0x63, 0x1e, 0xeb, 0xc8, 0x51, 0x74, 0xe2, 0xc4, 0x89, 0x4c, 0x3f, 0x3f,
0xbf, 0xe4, 0xc2, 0xc2, 0xc2, 0xd2, 0xeb, 0xd7, 0xaf, 0x47, 0xa8, 0x33,
0xce, 0x3d, 0x3c, 0x3c, 0x7a, 0xe5, 0xe5, 0xe5, 0x15, 0xb2, 0xb2, 0x9e,
0x7f, 0xed, 0xda, 0xb5, 0x5c, 0xa9, 0x54, 0x4a, 0xd3, 0x34, 0x4d, 0xff,
0xf2, 0xcb, 0x2f, 0xab, 0x95, 0xd2, 0x23, 0xe8, 0xdf, 0xbf, 0xff, 0x02,
0x5f, 0x5f, 0xdf, 0x70, 0x5f, 0x5f, 0xdf, 0xf7, 0x0f, 0x1f, 0x3e, 0x2c,
0x26, 0x84, 0x90, 0xc7, 0x8f, 0x1f, 0x17, 0xfb, 0xfa, 0xfa, 0x26, 0xf8,
0xfa, 0xfa, 0xc6, 0xfb, 0xfa, 0xfa, 0xbe, 0xaf, 0x5f, 0xbf, 0x7e, 0x77,
0x94, 0xeb, 0x6e, 0x6a, 0xf6, 0xec, 0xd9, 0x8b, 0x09, 0x21, 0x24, 0x32,
0x32, 0x32, 0x7f, 0xe9, 0xd2, 0xa5, 0x09, 0x87, 0x0f, 0x1f, 0x4e, 0x2f,
0x2c, 0x2c, 0x94, 0x12, 0x42, 0xc8, 0xf1, 0xe3, 0xc7, 0x13, 0x17, 0x2c,
0x58, 0xf0, 0x04, 0x8c, 0x2e, 0xf8, 0x64, 0x9c, 0x5f, 0xb8, 0x70, 0x21,
0xac, 0xac, 0xac, 0x4c, 0x7a, 0xe3, 0xc6, 0x8d, 0x0f, 0xa7, 0x4e, 0x9d,
0xca, 0x52, 0x84, 0xbf, 0x7b, 0xf7, 0x6e, 0x30, 0x2a, 0xea, 0x54, 0x41,
0xf3, 0xe6, 0xcd, 0x27, 0x6c, 0xdd, 0xba, 0x35, 0xf2, 0xe8, 0xd1, 0xa3,
0x09, 0x99, 0x99, 0x99, 0x65, 0x84, 0x10, 0x62, 0x64, 0x64, 0x54, 0x99,
0xbf, 0x0f, 0xad, 0x1e, 0x3d, 0x7a, 0xac, 0xdb, 0xb4, 0x69, 0x53, 0xa4,
0x8f, 0x8f, 0x4f, 0xcc, 0xf1, 0xe3, 0xc7, 0x13, 0x5f, 0xbd, 0x7a, 0x95,
0xcf, 0xae, 0xd6, 0xaf, 0xc6, 0xe7, 0xb2, 0xaf, 0xce, 0x38, 0xa7, 0x86,
0x0f, 0x1f, 0x3e, 0x5e, 0x2a, 0x95, 0xca, 0x1e, 0x3c, 0x78, 0x90, 0xa9,
0xaf, 0xaf, 0x3f, 0x1f, 0xea, 0xc7, 0xba, 0x55, 0x19, 0xe7, 0x94, 0xb5,
0xb5, 0x75, 0x1b, 0x42, 0x08, 0xb9, 0x71, 0xe3, 0xc6, 0xb3, 0x98, 0x98,
0x98, 0x9c, 0xd8, 0xd8, 0xd8, 0x12, 0x42, 0x08, 0x59, 0xb7, 0x6e, 0xdd,
0xee, 0xb8, 0xb8, 0xb8, 0xac, 0x4b, 0x97, 0x2e, 0x65, 0x10, 0x42, 0x48,
0x40, 0x40, 0xc0, 0x0b, 0x30, 0xfa, 0x54, 0x73, 0xee, 0xdc, 0xb9, 0x87,
0xd8, 0x09, 0xfc, 0x0b, 0x65, 0x65, 0x65, 0x92, 0x1a, 0x94, 0x0f, 0x35,
0x7d, 0xfa, 0xf4, 0xb9, 0x12, 0x89, 0x44, 0x9a, 0x96, 0x96, 0x56, 0x72,
0xea, 0xd4, 0xa9, 0x8c, 0x33, 0x67, 0xce, 0x64, 0x64, 0x64, 0x64, 0x94,
0x94, 0x96, 0x96, 0x96, 0x8d, 0x1a, 0x35, 0x6a, 0x82, 0x52, 0x39, 0x69,
0x2d, 0x5a, 0xb4, 0xe8, 0x18, 0x3b, 0xbe, 0xf5, 0xcb, 0xcd, 0xcd, 0x2d,
0x3e, 0x77, 0xee, 0x5c, 0x62, 0x35, 0xf2, 0xa9, 0x4e, 0xde, 0x92, 0x0a,
0x0a, 0x0a, 0x4a, 0x0e, 0x1f, 0x3e, 0xfc, 0x17, 0x2b, 0x6f, 0xc7, 0x51,
0x6e, 0x67, 0x68, 0xce, 0x9a, 0x35, 0x6b, 0x1f, 0x21, 0x84, 0xf4, 0xe8,
0xd1, 0x63, 0x6c, 0x5c, 0x5c, 0x5c, 0x6a, 0x5a, 0x5a, 0x5a, 0x71, 0x50,
0x50, 0x50, 0x6e, 0x7c, 0x7c, 0xbc, 0x48, 0x2a, 0x95, 0xca, 0x4d, 0x4c,
0x4c, 0xdc, 0x95, 0xe5, 0x67, 0xec, 0xd8, 0xb1, 0x93, 0x09, 0x21, 0xe4,
0xc3, 0x87, 0x0f, 0x25, 0x7e, 0x7e, 0x7e, 0x1f, 0x4f, 0x9e, 0x3c, 0x99,
0x15, 0x17, 0x17, 0x57, 0x44, 0x08, 0x21, 0xbb, 0x76, 0xed, 0x3a, 0xaf,
0x54, 0x67, 0x82, 0xa9, 0x53, 0xa7, 0x6e, 0xf6, 0xf5, 0xf5, 0x0d, 0x39,
0x76, 0xec, 0x58, 0x02, 0x21, 0x84, 0xa4, 0xa7, 0xa7, 0xcb, 0x0e, 0x1f,
0x3e, 0x9c, 0xc8, 0xca, 0x66, 0xbc, 0xaf, 0xaf, 0xef, 0x3b, 0x3e, 0x9f,
0xaf, 0xe8, 0x0b, 0x3e, 0x95, 0xa7, 0x9a, 0xba, 0x17, 0x8c, 0x1c, 0x39,
0x72, 0x35, 0x3b, 0x11, 0xeb, 0xcb, 0xa6, 0xdf, 0x32, 0x20, 0x20, 0x20,
0x55, 0x26, 0x93, 0xd1, 0xac, 0x3f, 0x99, 0x0a, 0xd4, 0xaf, 0x5f, 0xdf,
0x89, 0xa6, 0x69, 0x72, 0xf3, 0xe6, 0xcd, 0x14, 0x00, 0xf6, 0x2f, 0x5e,
0xbc, 0xc8, 0x7a, 0xf4, 0xe8, 0x91, 0x62, 0x67, 0x2f, 0xe5, 0xe6, 0xe6,
0xd6, 0x4b, 0x31, 0x7e, 0xee, 0xd4, 0xa9, 0xd3, 0x00, 0xb6, 0x1c, 0x75,
0x02, 0x02, 0x02, 0xde, 0xbe, 0x78, 0xf1, 0x22, 0x13, 0x40, 0x1d, 0x53,
0x53, 0xd3, 0xe9, 0x29, 0x29, 0x29, 0xc2, 0x9c, 0x9c, 0x9c, 0x22, 0x1b,
0x1b, 0x1b, 0x3b, 0x45, 0xdc, 0x36, 0x36, 0x36, 0x76, 0xb9, 0xb9, 0xb9,
0xc5, 0xc9, 0xc9, 0xc9, 0x42, 0x53, 0x53, 0xd3, 0xe9, 0x6c, 0x9c, 0x75,
0x2e, 0x5f, 0xbe, 0x9c, 0x48, 0xd3, 0x34, 0xb1, 0xb3, 0xb3, 0x73, 0xad,
0x2c, 0x3d, 0x37, 0x6e, 0xdc, 0x48, 0x66, 0xe5, 0x8f, 0x02, 0x60, 0xb0,
0x7d, 0xfb, 0xf6, 0x10, 0xa5, 0xf2, 0x88, 0xf7, 0xf5, 0xf5, 0x8d, 0x3f,
0x7c, 0xf8, 0x70, 0x42, 0x59, 0x59, 0x99, 0xbc, 0xac, 0xac, 0x4c, 0xc6,
0xe7, 0xf3, 0x2b, 0x1b, 0x07, 0xea, 0xad, 0x5e, 0xbd, 0xfa, 0x3e, 0x3b,
0x46, 0x5d, 0x83, 0xea, 0x75, 0x6d, 0x4d, 0x8d, 0x73, 0x00, 0xd0, 0xec,
0xd3, 0xa7, 0xcf, 0x7a, 0x42, 0x08, 0x59, 0xbd, 0x7a, 0xf5, 0x7d, 0x7c,
0xbe, 0x73, 0xeb, 0xff, 0x3d, 0x54, 0xff, 0xfe, 0xfd, 0xbf, 0x67, 0x05,
0x2e, 0x11, 0xe5, 0xdb, 0x49, 0x15, 0x68, 0x2d, 0x58, 0xb0, 0xe0, 0x0c,
0x21, 0x84, 0x0c, 0x1d, 0x3a, 0xf4, 0x20, 0x2a, 0x2a, 0x1c, 0x9d, 0x61,
0xc3, 0x86, 0x1d, 0x62, 0x57, 0x8c, 0x4e, 0x42, 0xc5, 0xa8, 0x07, 0xa3,
0xec, 0xb5, 0x07, 0x0f, 0x1e, 0xbc, 0xad, 0x06, 0xc6, 0xb9, 0x2a, 0x82,
0xb5, 0x6b, 0xd7, 0x9e, 0x62, 0x0d, 0xc9, 0xdb, 0x50, 0xb3, 0x7d, 0xcc,
0xd8, 0xd8, 0xd8, 0xa4, 0x41, 0x83, 0x06, 0x76, 0xa3, 0x46, 0x8d, 0xfa,
0xfe, 0xf4, 0xe9, 0xd3, 0x7e, 0x85, 0x85, 0x85, 0xa2, 0x83, 0x07, 0x0f,
0x16, 0xeb, 0xeb, 0xeb, 0x6f, 0x84, 0x4a, 0x45, 0x6a, 0x6b, 0x6b, 0x1b,
0x46, 0x47, 0x47, 0xa7, 0x84, 0x87, 0x87, 0x8b, 0x04, 0x02, 0xc1, 0x1a,
0x00, 0x0d, 0x42, 0x42, 0x42, 0x0a, 0x2a, 0x31, 0xce, 0x4d, 0x0b, 0x0b,
0x0b, 0x65, 0x09, 0x09, 0x09, 0xa5, 0x7f, 0xfe, 0xf9, 0xe7, 0xc5, 0x3b,
0x77, 0xee, 0xdc, 0xfb, 0xf3, 0xcf, 0x3f, 0xcf, 0x2d, 0x5a, 0xb4, 0x68,
0xa9, 0x9a, 0x59, 0x48, 0x7e, 0x97, 0x2e, 0x5d, 0x26, 0x11, 0x42, 0xc8,
0xf2, 0xe5, 0xcb, 0xc3, 0x86, 0x0d, 0x1b, 0x36, 0xe9, 0xd6, 0xad, 0x5b,
0x01, 0x29, 0x29, 0x29, 0xa9, 0x41, 0x41, 0x41, 0x8f, 0xa7, 0x4c, 0x99,
0x32, 0x13, 0xa8, 0x7e, 0xbb, 0xb6, 0xb9, 0xb9, 0x79, 0x23, 0x91, 0x48,
0x24, 0x63, 0xb7, 0xa2, 0xab, 0x1e, 0x2b, 0xd0, 0x33, 0x30, 0x30, 0xd8,
0x11, 0x14, 0x14, 0x54, 0x26, 0x91, 0x48, 0x64, 0xbb, 0x76, 0xed, 0xda,
0x7f, 0xe4, 0xc8, 0x91, 0xd3, 0x84, 0x10, 0x72, 0xec, 0xd8, 0xb1, 0x62,
0x6d, 0x6d, 0x6d, 0xe5, 0x2d, 0x87, 0x3a, 0x43, 0x87, 0x0e, 0x3d, 0x4a,
0x08, 0x21, 0x7b, 0xf7, 0xee, 0xbd, 0xab, 0x52, 0x27, 0xda, 0xab, 0x56,
0xad, 0xba, 0x4e, 0x08, 0x21, 0x8b, 0x16, 0x2d, 0x3a, 0x03, 0x35, 0x8e,
0xf0, 0x00, 0xb4, 0xde, 0xb8, 0x71, 0x63, 0xc1, 0x86, 0x0d, 0x1b, 0x0a,
0x00, 0xb4, 0x44, 0xd5, 0x86, 0x1f, 0x0f, 0x40, 0xe3, 0x15, 0x2b, 0x56,
0xe4, 0xed, 0xd8, 0xb1, 0xa3, 0x48, 0x20, 0x10, 0x74, 0x43, 0x25, 0x86,
0x99, 0xa5, 0xa5, 0xa5, 0xcd, 0xd6, 0xad, 0x5b, 0x77, 0x0b, 0x85, 0xc2,
0xd2, 0xfc, 0xfc, 0x7c, 0xd1, 0xba, 0x75, 0xeb, 0x32, 0xcc, 0xcc, 0xcc,
0x5e, 0x83, 0xd9, 0x96, 0xda, 0x82, 0x95, 0x15, 0x0a, 0x80, 0xf6, 0x98,
0x31, 0x63, 0xf6, 0xfe, 0xf5, 0xd7, 0x5f, 0xa9, 0x7e, 0x7e, 0x7e, 0x19,
0xea, 0x9e, 0xbf, 0xfe, 0xfa, 0x2b, 0x75, 0xe4, 0xc8, 0x91, 0xbb, 0xd9,
0xf4, 0x53, 0xec, 0xbb, 0xad, 0x00, 0x6c, 0x31, 0x37, 0x37, 0x7f, 0xb3,
0x7e, 0xfd, 0xfa, 0xcc, 0x82, 0x82, 0x82, 0xb2, 0xe2, 0xe2, 0xe2, 0x92,
0xcd, 0x9b, 0x37, 0xef, 0xa8, 0x53, 0xa7, 0x4e, 0x75, 0xdb, 0x28, 0xa1,
0xa9, 0xa9, 0xa9, 0x7d, 0xf8, 0xf0, 0xe1, 0xb3, 0xec, 0x2c, 0xdd, 0x47,
0x30, 0x3b, 0x26, 0x04, 0x3f, 0xfe, 0xf8, 0xe3, 0x96, 0xe2, 0xe2, 0x62,
0x39, 0x80, 0x41, 0xd3, 0xa7, 0x4f, 0x5f, 0x4a, 0xd3, 0x34, 0xe9, 0xde,
0xbd, 0x7b, 0x32, 0x80, 0x97, 0x97, 0x2f, 0x5f, 0x2e, 0x7d, 0xfb, 0xf6,
0x6d, 0x09, 0x00, 0xe7, 0x67, 0xcf, 0x9e, 0x09, 0x37, 0x6d, 0xda, 0xe4,
0x8f, 0xf2, 0xd5, 0x7f, 0xfd, 0xa4, 0xa4, 0xa4, 0xc2, 0xe4, 0xe4, 0x64,
0x19, 0x80, 0x9e, 0x14, 0x45, 0x79, 0x7d, 0xf8, 0xf0, 0x41, 0x96, 0x90,
0x90, 0x50, 0x80, 0x8a, 0x86, 0xde, 0x27, 0xe3, 0x73, 0xc4, 0x88, 0x11,
0xcb, 0x3a, 0x74, 0xe8, 0xe0, 0xd1, 0xa1, 0x43, 0x87, 0x2e, 0x7d, 0xfa,
0xf4, 0xf9, 0x6e, 0xf9, 0xf2, 0xe5, 0x1b, 0xf3, 0xf2, 0xf2, 0xca, 0x8e,
0x1e, 0x3d, 0x5a, 0x4c, 0x51, 0xd4, 0x10, 0xb0, 0xc6, 0xc9, 0xd6, 0xad,
0x5b, 0x03, 0x08, 0x21, 0xe4, 0xfb, 0xef, 0xbf, 0xbf, 0x81, 0xea, 0xb7,
0x55, 0x56, 0x65, 0xdc, 0xf2, 0x00, 0x34, 0x49, 0x49, 0x49, 0x91, 0xc9,
0xe5, 0x72, 0xa2, 0xa5, 0xa5, 0x65, 0xcd, 0xfe, 0xdd, 0x2c, 0x29, 0x29,
0x49, 0x5c, 0x5c, 0x5c, 0x2c, 0xef, 0xd1, 0xa3, 0xc7, 0x88, 0x1e, 0x3d,
0x7a, 0x78, 0x29, 0x3f, 0xdd, 0xba, 0x75, 0x53, 0x3d, 0xff, 0x53, 0x1b,
0xe3, 0x5c, 0xff, 0xd2, 0xa5, 0x4b, 0x31, 0x84, 0x10, 0xe2, 0xe6, 0xe6,
0xb6, 0x0e, 0xd5, 0xef, 0x96, 0xf8, 0x94, 0xfe, 0x09, 0x13, 0x26, 0xac,
0xe9, 0xd1, 0xa3, 0x47, 0x3f, 0xa5, 0xb4, 0xf4, 0x1b, 0x3f, 0x7e, 0xfc,
0x9a, 0xff, 0xa4, 0x71, 0xee, 0xec, 0xec, 0xdc, 0x4b, 0x24, 0x12, 0x49,
0x9e, 0x3c, 0x79, 0x22, 0x12, 0x08, 0x04, 0x7f, 0x80, 0xd1, 0x25, 0xaa,
0xed, 0xbd, 0xd6, 0xc6, 0xb9, 0x8f, 0x8f, 0xcf, 0x9b, 0xd3, 0xa7, 0x4f,
0xe7, 0xdd, 0xba, 0x75, 0x2b, 0x16, 0x4c, 0xdb, 0xd6, 0x7f, 0xf2, 0xe4,
0x49, 0xda, 0x9e, 0x3d, 0x7b, 0xd2, 0xf6, 0xed, 0xdb, 0xf7, 0x4e, 0xd5,
0x38, 0x67, 0x0d, 0x97, 0x0e, 0x6b, 0xd7, 0xae, 0xcd, 0xa4, 0x69, 0xfa,
0x93, 0x53, 0x2e, 0x55, 0xe3, 0x5c, 0x4f, 0x4f, 0xaf, 0x01, 0x21, 0x84,
0xbc, 0x7f, 0xff, 0x5e, 0x02, 0x46, 0xd7, 0xab, 0x62, 0x19, 0x15, 0x15,
0x55, 0x46, 0x08, 0x21, 0x86, 0x86, 0x86, 0x76, 0xa8, 0xc6, 0x38, 0xf7,
0xf1, 0xf1, 0xb9, 0x4d, 0x08, 0x21, 0x93, 0x27, 0x4f, 0xf6, 0x07, 0xa0,
0xff, 0x05, 0xf1, 0x57, 0x6a, 0x9c, 0x37, 0x6e, 0xdc, 0xd8, 0x9d, 0xa6,
0x69, 0x12, 0x1f, 0x1f, 0x2f, 0x03, 0xb3, 0xc5, 0x59, 0xb1, 0x92, 0xda,
0xe5, 0xd4, 0xa9, 0x53, 0xa5, 0xac, 0x81, 0x9e, 0x3c, 0x79, 0xf2, 0xe4,
0x19, 0xba, 0xba, 0xba, 0x35, 0xed, 0xb8, 0xbf, 0xb5, 0x71, 0xce, 0x03,
0xbb, 0xb5, 0x5d, 0x2e, 0x97, 0xd3, 0x75, 0xea, 0xd4, 0xf9, 0x34, 0x40,
0xb3, 0xb1, 0xb1, 0x71, 0xa2, 0x69, 0x9a, 0xdc, 0xbb, 0x77, 0x4f, 0x04,
0xc0, 0x19, 0x80, 0x8e, 0x8b, 0x8b, 0xcb, 0x62, 0x42, 0x08, 0x59, 0xb0,
0x60, 0xc1, 0x49, 0x00, 0x5a, 0x6d, 0xdb, 0xb6, 0xf5, 0x92, 0xc9, 0x64,
0xb4, 0x58, 0x2c, 0x96, 0xb3, 0x8e, 0x46, 0x05, 0x7d, 0xfb, 0xf6, 0x5d,
0xc4, 0xae, 0xfa, 0x6e, 0x41, 0x79, 0xfb, 0xd0, 0x02, 0x30, 0xea, 0xe2,
0xc5, 0x8b, 0xa5, 0x72, 0xb9, 0x9c, 0x96, 0xcb, 0xe5, 0x34, 0x7b, 0xae,
0xb7, 0x2f, 0x3e, 0x37, 0x1e, 0xf8, 0x00, 0xda, 0xee, 0xdc, 0xb9, 0x33,
0x9f, 0x8d, 0x67, 0x80, 0x97, 0x97, 0xd7, 0x48, 0x42, 0x08, 0x59, 0xb3,
0x66, 0x4d, 0x36, 0xaa, 0xd1, 0xeb, 0x8e, 0x8e, 0x8e, 0xad, 0x4b, 0x4b,
0x4b, 0x25, 0x8f, 0x1f, 0x3f, 0x2e, 0xa3, 0x28, 0x6a, 0x19, 0x2a, 0xd7,
0x31, 0xb5, 0x31, 0xce, 0x29, 0x00, 0x36, 0x8b, 0x17, 0x2f, 0x4e, 0x66,
0x07, 0x72, 0xa3, 0x6a, 0x58, 0x5f, 0x40, 0xf5, 0xc6, 0x39, 0x6f, 0xe9,
0xd2, 0xa5, 0xdb, 0x0b, 0x0b, 0x0b, 0x65, 0x06, 0x06, 0x06, 0x8b, 0xc1,
0xee, 0x0c, 0xea, 0xd4, 0xa9, 0xd3, 0x5d, 0x76, 0x45, 0xba, 0x36, 0xdf,
0xfa, 0x16, 0x18, 0xd4, 0xaf, 0x5f, 0xff, 0x58, 0x9d, 0x3a, 0x75, 0xde,
0x01, 0xb8, 0x0a, 0xe6, 0x98, 0xdb, 0x75, 0x77, 0x77, 0xf7, 0x4c, 0x42,
0x08, 0x79, 0xfb, 0xf6, 0x6d, 0x26, 0xca, 0xc7, 0x41, 0x9f, 0x8c, 0xf3,
0xbc, 0xbc, 0x3c, 0x49, 0xc3, 0x86, 0x0d, 0x5f, 0x01, 0x38, 0x0e, 0xe0,
0xa8, 0xb5, 0xb5, 0xf5, 0x9b, 0x0f, 0x1f, 0x3e, 0xc8, 0x0a, 0x0b, 0x0b,
0x45, 0xc6, 0xc6, 0xc6, 0xca, 0x6d, 0x89, 0x5a, 0xb5, 0x6a, 0xd5, 0x0e,
0x42, 0x08, 0x39, 0x73, 0xe6, 0x4c, 0x89, 0xbe, 0xbe, 0xfe, 0x5b, 0x00,
0xd7, 0x00, 0x5c, 0x06, 0x10, 0x69, 0x6d, 0x6d, 0x1d, 0x0e, 0xa0, 0x01,
0x5b, 0xe6, 0x30, 0x34, 0x34, 0xb4, 0xcc, 0xcf, 0xcf, 0x2f, 0x4d, 0x4d,
0x4d, 0x95, 0xd9, 0xd8, 0xd8, 0xbc, 0x01, 0x73, 0x6c, 0xe8, 0x64, 0xd3,
0xa6, 0x4d, 0x5f, 0x17, 0x15, 0x15, 0x49, 0x55, 0x8d, 0x73, 0x81, 0x40,
0xa0, 0x17, 0x1b, 0x1b, 0x9b, 0x9e, 0x9f, 0x9f, 0x2f, 0xb3, 0xb7, 0xb7,
0x4f, 0x05, 0xe0, 0x0f, 0xc0, 0xcf, 0xc2, 0xc2, 0x22, 0x29, 0x3a, 0x3a,
0x5a, 0x22, 0x91, 0x48, 0x64, 0xcd, 0x9a, 0x35, 0x53, 0xec, 0x12, 0xd3,
0x04, 0x73, 0xa4, 0x64, 0x33, 0x80, 0x3d, 0x93, 0x26, 0x4d, 0x8a, 0x26,
0x84, 0x90, 0x29, 0x53, 0xa6, 0xbc, 0x03, 0x73, 0xc4, 0xe4, 0x77, 0xf6,
0x37, 0x7b, 0x94, 0xeb, 0x3d, 0x9d, 0x82, 0x82, 0x02, 0x51, 0x41, 0x41,
0x81, 0x5c, 0x20, 0x10, 0xdc, 0x03, 0xb0, 0x1a, 0xc0, 0xfe, 0x29, 0x53,
0xa6, 0x7c, 0x64, 0xc7, 0x7b, 0x0f, 0x00, 0xcc, 0x64, 0xcb, 0xe8, 0x93,
0x71, 0x2e, 0x95, 0x4a, 0xe9, 0x4e, 0x9d, 0x3a, 0xc5, 0x03, 0x38, 0x07,
0xe0, 0x84, 0x8e, 0x8e, 0xce, 0xbb, 0x37, 0x6f, 0xde, 0xc8, 0x08, 0xa9,
0xb0, 0x5b, 0x08, 0x60, 0x64, 0xdb, 0x05, 0xc0, 0xaf, 0x00, 0x0e, 0xdc,
0xbc, 0x79, 0xb3, 0x84, 0x35, 0xce, 0x5d, 0xa1, 0x7e, 0x2c, 0x26, 0x00,
0xe3, 0x7f, 0x61, 0x39, 0x80, 0xad, 0x00, 0x0e, 0xcc, 0x9d, 0x3b, 0x37,
0x91, 0x35, 0xd0, 0x7e, 0xc7, 0xe7, 0xe3, 0x24, 0x55, 0xe3, 0x9c, 0x1a,
0x31, 0x62, 0xc4, 0x04, 0xa9, 0x54, 0x2a, 0xbb, 0x73, 0xe7, 0x8e, 0x50,
0x57, 0x57, 0xf7, 0x2f, 0x30, 0xbb, 0xd9, 0xd4, 0xe9, 0xf9, 0xaa, 0x8c,
0x73, 0x9e, 0xb5, 0xb5, 0x75, 0x57, 0x76, 0xd2, 0xa2, 0x48, 0x47, 0x47,
0xe7, 0xa1, 0xa1, 0xa1, 0xe1, 0x4b, 0x85, 0x7f, 0xe1, 0x16, 0x2d, 0x5a,
0x3c, 0x03, 0xe0, 0x77, 0xfc, 0xf8, 0xf1, 0x52, 0x99, 0x4c, 0x46, 0xf3,
0xf9, 0x7c, 0x53, 0xb6, 0x7c, 0x2e, 0x2a, 0xca, 0xa7, 0x73, 0xe7, 0xce,
0xb1, 0xd5, 0x95, 0x4f, 0xfd, 0xfa, 0xf5, 0x1d, 0x4b, 0x4b, 0x4b, 0x25,
0x61, 0x61, 0x61, 0x65, 0x26, 0x26, 0x26, 0xaf, 0x00, 0x1c, 0x03, 0x70,
0xdc, 0xc2, 0xc2, 0x22, 0x22, 0x22, 0x22, 0x42, 0x54, 0x50, 0x50, 0x50,
0xaa, 0x74, 0xcc, 0x4d, 0x67, 0xd1, 0xa2, 0x45, 0xd7, 0x14, 0x93, 0x40,
0xf5, 0xea, 0xd5, 0x0b, 0x63, 0xc3, 0x57, 0x2a, 0x9f, 0x55, 0xc8, 0x5b,
0x44, 0x51, 0x51, 0x91, 0x84, 0x95, 0xb7, 0xeb, 0x28, 0x9f, 0x0c, 0xd2,
0x99, 0x35, 0x6b, 0xd6, 0x79, 0x42, 0x08, 0x29, 0x2e, 0x2e, 0x2e, 0x5b,
0xb8, 0x70, 0x61, 0x0c, 0x8f, 0xc7, 0x7b, 0x0e, 0xe0, 0x06, 0x80, 0x17,
0x06, 0x06, 0x06, 0x2f, 0xd9, 0xf2, 0x54, 0xd4, 0x9d, 0xf6, 0xa3, 0x47,
0x8f, 0x62, 0x4a, 0x4a, 0x4a, 0x68, 0x2b, 0x2b, 0xab, 0x48, 0x00, 0xa7,
0xd8, 0x6f, 0x3c, 0xb6, 0xb4, 0xb4, 0x8c, 0x31, 0x35, 0x35, 0xdd, 0x80,
0xf2, 0x7e, 0x4a, 0x0b, 0xc0, 0x48, 0x00, 0x5b, 0xb4, 0xb5, 0xb5, 0x8f,
0xb1, 0x93, 0x15, 0x22, 0xb6, 0x4d, 0xfe, 0xce, 0x3e, 0x1b, 0x51, 0x3e,
0x76, 0xf8, 0x54, 0x9e, 0x6a, 0xea, 0x5e, 0x6b, 0xe4, 0xc8, 0x91, 0xbf,
0xb3, 0xb6, 0xd2, 0x25, 0x56, 0x3e, 0x8d, 0xc7, 0x8d, 0x1b, 0xf7, 0x8c,
0x1d, 0x53, 0x6f, 0x57, 0xa9, 0x73, 0xfe, 0xb2, 0x65, 0xcb, 0xf6, 0xb0,
0x71, 0x3d, 0x06, 0xd0, 0xf0, 0x8f, 0x3f, 0xfe, 0x48, 0x2a, 0x28, 0x28,
0x90, 0x80, 0x9d, 0x98, 0x9e, 0x33, 0x67, 0xce, 0xef, 0x51, 0x51, 0x51,
0xd2, 0xd4, 0xd4, 0x54, 0xd9, 0xc2, 0x85, 0x0b, 0x0f, 0xb0, 0xb2, 0x68,
0x94, 0x9d, 0x9d, 0x5d, 0xb6, 0x67, 0xcf, 0x9e, 0x44, 0x56, 0xbe, 0x9a,
0x74, 0xee, 0xdc, 0x39, 0x42, 0x26, 0x93, 0xd1, 0xfe, 0xfe, 0xfe, 0x4f,
0x29, 0x8a, 0xd2, 0xa0, 0x28, 0x4a, 0xe3, 0xce, 0x9d, 0x3b, 0xcf, 0x64,
0x32, 0x19, 0xdd, 0xb1, 0x63, 0xc7, 0x57, 0x28, 0x5f, 0x14, 0x34, 0xea,
0xd3, 0xa7, 0xcf, 0x5d, 0x42, 0x08, 0xd9, 0xb8, 0x71, 0xe3, 0x51, 0xa8,
0x2c, 0x66, 0x28, 0xd2, 0x33, 0x7c, 0xf8, 0xf0, 0x47, 0x4a, 0x79, 0xd6,
0x03, 0xb0, 0x0c, 0xc0, 0x6e, 0xa5, 0x32, 0xf1, 0x59, 0xba, 0x74, 0xe9,
0x4b, 0xb6, 0x6f, 0x4f, 0x45, 0xe5, 0x8b, 0x28, 0x7a, 0xab, 0x57, 0xaf,
0x0e, 0x62, 0x75, 0xfa, 0x6a, 0x7c, 0x7b, 0xe3, 0x7c, 0x2d, 0x6b, 0x9c,
0x07, 0xa1, 0x0a, 0xe3, 0xdc, 0xd8, 0xd8, 0xd8, 0xd4, 0xcb, 0xcb, 0xab,
0xbf, 0x9b, 0x9b, 0x5b, 0x3b, 0x75, 0xab, 0xfc, 0x96, 0x96, 0x96, 0xd6,
0xf8, 0x17, 0xa2, 0xe9, 0xef, 0xef, 0x1f, 0x21, 0x14, 0x0a, 0x69, 0x23,
0x23, 0xa3, 0x15, 0xf8, 0x7c, 0xeb, 0x80, 0xee, 0xe6, 0xcd, 0x9b, 0xef,
0xb1, 0xb3, 0x5a, 0x1b, 0xa0, 0x22, 0xac, 0x3d, 0x7a, 0xf4, 0xd8, 0x40,
0x08, 0x21, 0xeb, 0xd7, 0xaf, 0x0f, 0x80, 0x7a, 0xc3, 0x5b, 0x4b, 0x61,
0x9c, 0x4f, 0x9b, 0x36, 0xed, 0x34, 0x6a, 0x68, 0x9c, 0x3b, 0x3b, 0x3b,
0xb7, 0x17, 0x89, 0x44, 0xd2, 0x67, 0xcf, 0x9e, 0x89, 0x29, 0x8a, 0x1a,
0x8f, 0xcf, 0x15, 0x24, 0x6f, 0xcb, 0x96, 0x2d, 0x7b, 0x15, 0xb3, 0x4e,
0x22, 0x91, 0x48, 0x36, 0x73, 0xe6, 0xcc, 0x0f, 0x3a, 0x3a, 0x3a, 0x7b,
0xc1, 0x6c, 0xc1, 0xab, 0x30, 0x53, 0xb8, 0x6d, 0xdb, 0xb6, 0x83, 0x62,
0xb1, 0x58, 0xee, 0xe2, 0xe2, 0xf2, 0x08, 0xcc, 0xcc, 0xba, 0x69, 0x58,
0x58, 0x58, 0x51, 0x25, 0xc6, 0xb9, 0xf9, 0xc3, 0x87, 0x0f, 0x4b, 0x72,
0x73, 0x73, 0x65, 0xaf, 0x5e, 0xbd, 0xca, 0x7b, 0xfe, 0xfc, 0x79, 0x6e,
0x6e, 0x6e, 0x6e, 0x19, 0x3b, 0xeb, 0x96, 0xe5, 0xec, 0xec, 0xdc, 0x52,
0x29, 0xac, 0x60, 0xf4, 0xe8, 0xd1, 0x9b, 0x08, 0x21, 0xe4, 0xfa, 0xf5,
0xeb, 0xf1, 0x52, 0xa9, 0x54, 0xee, 0xef, 0xef, 0x9f, 0xbe, 0x7f, 0xff,
0xfe, 0x8c, 0x82, 0x82, 0x02, 0x09, 0x21, 0x84, 0xec, 0xd8, 0xb1, 0xe3,
0x0f, 0x54, 0x6d, 0xa0, 0xf3, 0x96, 0x2d, 0x5b, 0xb6, 0x8b, 0x5d, 0x51,
0x79, 0x86, 0xcf, 0x57, 0xeb, 0x79, 0x00, 0xec, 0xcd, 0xcc, 0xcc, 0x6e,
0xe4, 0xe7, 0xe7, 0xcb, 0x15, 0x79, 0x0e, 0x0e, 0x0e, 0x2e, 0xe3, 0xf1,
0x78, 0xfb, 0xc0, 0x9c, 0x81, 0xff, 0x34, 0xd3, 0x69, 0x66, 0x66, 0xf6,
0x63, 0x5e, 0x5e, 0x9e, 0x3c, 0x3d, 0x3d, 0xbd, 0xc4, 0xd3, 0xd3, 0x73,
0x20, 0x45, 0x51, 0x3c, 0x7d, 0x7d, 0x7d, 0x83, 0xa9, 0x53, 0xa7, 0xce,
0x13, 0x89, 0x44, 0x52, 0x42, 0x08, 0xf1, 0xf6, 0xf6, 0xbe, 0x58, 0x49,
0x5d, 0x18, 0x81, 0xe9, 0xa4, 0x96, 0xa1, 0x66, 0xde, 0x55, 0xf5, 0xc1,
0x9c, 0x61, 0x5e, 0x05, 0x76, 0x8b, 0xaf, 0xca, 0xef, 0xd4, 0xd8, 0xb1,
0x63, 0x7f, 0x28, 0x2d, 0x2d, 0x2d, 0xcb, 0xce, 0xce, 0x2e, 0x59, 0xb2,
0x64, 0x49, 0xba, 0x81, 0x81, 0xc1, 0x2b, 0x30, 0x1d, 0xb2, 0x13, 0x98,
0x81, 0x5f, 0x85, 0xd5, 0x62, 0x30, 0x67, 0x44, 0x0f, 0x82, 0x19, 0xa4,
0xa8, 0x7b, 0x0e, 0xa2, 0xfc, 0x8c, 0xa8, 0x02, 0x3e, 0x1b, 0x97, 0x33,
0x80, 0xb5, 0x86, 0x86, 0x86, 0xaf, 0x96, 0x2d, 0x5b, 0x96, 0x9e, 0x9b,
0x9b, 0x5b, 0x5a, 0x52, 0x52, 0x22, 0x1a, 0x39, 0x72, 0xe4, 0xf7, 0x95,
0xd5, 0x81, 0x9e, 0x9e, 0x9e, 0x41, 0x60, 0x60, 0xe0, 0x13, 0x9a, 0xa6,
0xc9, 0xaf, 0xbf, 0xfe, 0x9a, 0x07, 0x60, 0x25, 0x18, 0x45, 0xa0, 0xbd,
0x66, 0xcd, 0x9a, 0x6b, 0xd1, 0xd1, 0xd1, 0x65, 0x00, 0x1a, 0x85, 0x86,
0x86, 0xa6, 0xb0, 0x47, 0x1d, 0x46, 0x02, 0x68, 0x12, 0x18, 0x18, 0xf8,
0xf1, 0xf9, 0xf3, 0xe7, 0x45, 0x00, 0xec, 0xfd, 0xfc, 0xfc, 0x32, 0xce,
0x9c, 0x39, 0xf3, 0x9a, 0x7d, 0x0f, 0xee, 0xee, 0xee, 0xbd, 0xd9, 0x15,
0xc5, 0x2c, 0x30, 0xc7, 0x1c, 0x2c, 0x7d, 0x7c, 0x7c, 0x3e, 0x12, 0x42,
0x48, 0x9b, 0x36, 0x6d, 0x94, 0x07, 0x12, 0x9f, 0x8c, 0x4f, 0x55, 0x24,
0x12, 0x89, 0xdc, 0xdb, 0xdb, 0xfb, 0x83, 0xb6, 0xb6, 0xf6, 0x7e, 0xa5,
0xb2, 0xfd, 0x64, 0xdc, 0x76, 0xec, 0xd8, 0x71, 0x13, 0x6a, 0x61, 0xdc,
0xaa, 0x31, 0xce, 0x01, 0xc0, 0xfc, 0xd1, 0xa3, 0x47, 0x42, 0x42, 0x08,
0x71, 0x74, 0x74, 0xec, 0xc6, 0x7e, 0xc3, 0x2c, 0x29, 0x29, 0x49, 0x4c,
0x2a, 0xa1, 0xa4, 0xa4, 0xa4, 0x0c, 0x15, 0x95, 0xf0, 0x27, 0xe3, 0xfc,
0xfa, 0xf5, 0xeb, 0x2f, 0x4e, 0x9e, 0x3c, 0x79, 0xee, 0xe4, 0xc9, 0x93,
0x67, 0x95, 0x1f, 0xa5, 0x6d, 0x69, 0x46, 0x2f, 0x5f, 0xbe, 0xcc, 0x23,
0x84, 0x10, 0x2b, 0x2b, 0xab, 0x61, 0x60, 0x0d, 0xf9, 0xce, 0x9d, 0x3b,
0x77, 0xdb, 0xb2, 0x65, 0xcb, 0x4e, 0xc5, 0x33, 0x61, 0xc2, 0x84, 0xc9,
0x50, 0x39, 0x73, 0x5e, 0x15, 0xff, 0x09, 0xe3, 0x3c, 0x23, 0x23, 0x43,
0x1a, 0x15, 0x15, 0x95, 0x42, 0x08, 0x21, 0xcf, 0x9f, 0x3f, 0x2f, 0xe4,
0xf3, 0xf9, 0xaa, 0x0e, 0xc4, 0x3e, 0xd5, 0xc1, 0x97, 0x18, 0xe7, 0x73,
0xe6, 0xcc, 0x09, 0xcd, 0xc9, 0xc9, 0x29, 0x03, 0x60, 0xa4, 0xa1, 0xa1,
0x61, 0x21, 0x12, 0x89, 0xe4, 0xdf, 0x7f, 0xff, 0x7d, 0xa0, 0x1a, 0xe3,
0xfc, 0x03, 0x21, 0x84, 0x00, 0x68, 0x64, 0x66, 0x66, 0xb6, 0x45, 0x28,
0x14, 0xd2, 0xa7, 0x4f, 0x9f, 0xbe, 0x0b, 0x40, 0xa0, 0x62, 0x9c, 0x1b,
0x39, 0x38, 0x38, 0x78, 0xb0, 0xba, 0xa3, 0x18, 0xea, 0x77, 0x05, 0x99,
0xde, 0xbf, 0x7f, 0xbf, 0x90, 0x10, 0x42, 0x9a, 0x35, 0x6b, 0xd6, 0x0b,
0x80, 0x96, 0xc2, 0x38, 0xdf, 0xb3, 0x67, 0x4f, 0x98, 0xb5, 0xb5, 0x75,
0x63, 0x3b, 0x3b, 0xbb, 0xc6, 0x5d, 0xba, 0x74, 0xf1, 0xdc, 0xbb, 0x77,
0xef, 0x51, 0x9a, 0xa6, 0x49, 0x64, 0x64, 0xa4, 0x54, 0x53, 0x53, 0x73,
0x06, 0x00, 0x9d, 0x2f, 0x88, 0x5f, 0xa0, 0x30, 0xce, 0x43, 0x42, 0x42,
0x72, 0xe6, 0xcf, 0x9f, 0xbf, 0x72, 0xe9, 0xd2, 0xa5, 0x2b, 0x0f, 0x1c,
0x38, 0x70, 0x34, 0x3f, 0x3f, 0xbf, 0x38, 0x25, 0x25, 0x45, 0xe6, 0xe1,
0xe1, 0x11, 0x85, 0x8a, 0x3a, 0xda, 0x84, 0xcf, 0xe7, 0x1f, 0x5a, 0xbf,
0x7e, 0xbd, 0xb0, 0xa4, 0xa4, 0x44, 0x4e, 0x08, 0x21, 0xf9, 0xf9, 0xf9,
0x85, 0xdb, 0xb6, 0x6d, 0xdb, 0xdd, 0xa0, 0x41, 0x03, 0x3b, 0x54, 0xcd,
0xb7, 0x36, 0xce, 0x01, 0xa5, 0xad, 0xed, 0x53, 0xa6, 0x4c, 0x59, 0xc9,
0xd6, 0x2f, 0x6f, 0xe6, 0xcc, 0x99, 0xeb, 0x09, 0x21, 0x64, 0xe6, 0xcc,
0x99, 0x91, 0x6c, 0x58, 0x0d, 0x3d, 0x3d, 0xbd, 0x1e, 0xac, 0x5e, 0x78,
0x0c, 0xc0, 0x70, 0xc5, 0x8a, 0x15, 0x47, 0xc2, 0xc2, 0xc2, 0x24, 0x4f,
0x9e, 0x3c, 0x11, 0xff, 0xf6, 0xdb, 0x6f, 0x7f, 0x01, 0xd0, 0x9f, 0x3a,
0x75, 0xea, 0x1f, 0x84, 0x10, 0x52, 0xaf, 0x5e, 0xbd, 0x09, 0xa8, 0x68,
0x78, 0x9b, 0xb9, 0xbb, 0xbb, 0xdf, 0x52, 0xc8, 0x7c, 0xd3, 0xa6, 0x4d,
0x4f, 0xa2, 0x72, 0xc7, 0x72, 0x86, 0x66, 0x66, 0x66, 0x7b, 0x0a, 0x0b,
0x0b, 0xe5, 0x41, 0x41, 0x41, 0xaf, 0x5f, 0xbc, 0x78, 0x11, 0x9f, 0x95,
0x95, 0x25, 0x33, 0x30, 0x30, 0xd8, 0x84, 0x2a, 0x26, 0xf4, 0x34, 0x34,
0x34, 0xb4, 0x43, 0x42, 0x42, 0xde, 0x15, 0x17, 0x17, 0xcb, 0x1b, 0x35,
0x6a, 0x14, 0x80, 0xcf, 0x27, 0xeb, 0x95, 0xa9, 0x8d, 0x71, 0x0e, 0x00,
0xba, 0xa6, 0xa6, 0xa6, 0x6b, 0x4a, 0x4b, 0x4b, 0xe9, 0xeb, 0xd7, 0xaf,
0x87, 0xa2, 0xe6, 0x2b, 0xda, 0x55, 0x1a, 0xe7, 0x5a, 0x5a, 0x5a, 0xa6,
0xe9, 0xe9, 0xe9, 0x45, 0x3b, 0x77, 0xee, 0xcc, 0x42, 0xf9, 0x71, 0x30,
0x01, 0x80, 0xfe, 0x01, 0x01, 0x01, 0xc2, 0x90, 0x90, 0x90, 0x78, 0x8a,
0xa2, 0xfe, 0xc9, 0xb3, 0xdc, 0x7c, 0x30, 0x83, 0xe5, 0xc6, 0x60, 0x9d,
0x36, 0x82, 0x91, 0xdf, 0x01, 0xef, 0xde, 0xbd, 0x93, 0x49, 0x24, 0x12,
0x9a, 0xc7, 0xe3, 0x29, 0xe4, 0xf9, 0x93, 0x71, 0xbe, 0x77, 0xef, 0xde,
0x3c, 0x30, 0x13, 0xf3, 0x26, 0x60, 0xea, 0xb5, 0xed, 0xb2, 0x65, 0xcb,
0xd2, 0x59, 0xb9, 0x5a, 0xc6, 0xe6, 0x0b, 0x1a, 0x1a, 0x1a, 0x46, 0xa5,
0xa5, 0xa5, 0x92, 0x8f, 0x1f, 0x3f, 0xca, 0xf5, 0xf5, 0xf5, 0x4f, 0x02,
0x70, 0x54, 0x7a, 0xc7, 0x82, 0x2d, 0x83, 0x4f, 0xfe, 0x49, 0x26, 0x4f,
0x9e, 0xfc, 0x0b, 0x21, 0x84, 0xac, 0x5c, 0xb9, 0x32, 0x03, 0xcc, 0x24,
0x97, 0x31, 0x9b, 0xae, 0x6e, 0x07, 0x0f, 0x1e, 0x2c, 0x50, 0x31, 0xce,
0xa9, 0xb1, 0x63, 0xc7, 0xce, 0x52, 0x4a, 0x8f, 0x07, 0x98, 0x76, 0x62,
0x02, 0xc0, 0x6d, 0xe3, 0xc6, 0x8d, 0x69, 0x84, 0x10, 0xb2, 0x62, 0xc5,
0x8a, 0x03, 0x50, 0xf2, 0x21, 0x02, 0x46, 0xa6, 0x2c, 0x26, 0x4d, 0x9a,
0x74, 0x8a, 0x4d, 0xef, 0x39, 0x36, 0x2d, 0x06, 0x60, 0x77, 0x7c, 0x29,
0x0a, 0xa7, 0x6e, 0xdd, 0xba, 0xae, 0xac, 0xce, 0x2e, 0x06, 0xd0, 0x14,
0x4c, 0x9f, 0x69, 0x61, 0x6b, 0x6b, 0xbb, 0x8a, 0x10, 0x42, 0x8e, 0x1d,
0x3b, 0xf6, 0x8c, 0x4d, 0x63, 0x85, 0x6d, 0xed, 0xa7, 0x4e, 0x9d, 0x12,
0x82, 0xe9, 0xf7, 0xcd, 0xc1, 0xe8, 0x7a, 0xa7, 0x0d, 0x1b, 0x36, 0xa4,
0x12, 0x42, 0xc8, 0x84, 0x09, 0x13, 0x36, 0x41, 0xe5, 0x66, 0x0b, 0x36,
0x5e, 0xdb, 0x9b, 0x37, 0x6f, 0x66, 0xb1, 0xc6, 0x79, 0x55, 0xde, 0xda,
0x35, 0xd9, 0xf0, 0xfa, 0x00, 0xea, 0xcc, 0x9d, 0x3b, 0xf7, 0x3a, 0x6b,
0x54, 0xa9, 0x3b, 0xe7, 0x6e, 0x96, 0x9e, 0x9e, 0x2e, 0x8d, 0x88, 0x88,
0x28, 0x01, 0x60, 0x36, 0x72, 0xe4, 0xc8, 0x89, 0x52, 0xa9, 0x54, 0x76,
0xed, 0xda, 0xb5, 0x62, 0x4d, 0x4d, 0xcd, 0x0b, 0x60, 0x26, 0x22, 0x2a,
0x9b, 0xfc, 0xaa, 0xce, 0x38, 0xf7, 0x20, 0x84, 0x90, 0x3f, 0xfe, 0xf8,
0x23, 0x1d, 0x8c, 0x53, 0xcb, 0x56, 0x09, 0x09, 0x09, 0xb2, 0xac, 0xac,
0x2c, 0x39, 0x18, 0xff, 0x4a, 0x0d, 0x7e, 0xfd, 0xf5, 0xd7, 0x97, 0x84,
0x10, 0x62, 0x61, 0x61, 0xd1, 0x1c, 0x80, 0x6e, 0x2d, 0xcb, 0x87, 0xbf,
0x6d, 0xdb, 0xb6, 0x13, 0x84, 0x10, 0x32, 0x60, 0xc0, 0x80, 0x97, 0x60,
0x1c, 0xde, 0x19, 0xb3, 0x4f, 0xab, 0xa1, 0x43, 0x87, 0x46, 0x11, 0x42,
0xc8, 0xba, 0x75, 0xeb, 0xf6, 0xb3, 0xf2, 0xf6, 0x49, 0x3e, 0x77, 0xed,
0xda, 0x95, 0x03, 0xc6, 0xdf, 0x51, 0x55, 0xf2, 0x59, 0xa5, 0xbc, 0x1d,
0x38, 0x70, 0x20, 0x5f, 0x45, 0xde, 0x00, 0xc6, 0x38, 0xbf, 0x40, 0x08,
0x21, 0x37, 0x6e, 0xdc, 0x10, 0x82, 0x19, 0x4f, 0xda, 0xb2, 0xdf, 0x31,
0x63, 0xff, 0x5f, 0xb9, 0x6e, 0x8d, 0xce, 0x9e, 0x3d, 0xfb, 0x81, 0xa6,
0x69, 0xe2, 0xe6, 0xe6, 0xf6, 0x23, 0x1b, 0x4e, 0xd1, 0xc6, 0x1a, 0x83,
0xd9, 0x49, 0xf4, 0x69, 0xd7, 0x08, 0x98, 0x31, 0x92, 0x81, 0xb6, 0xb6,
0x76, 0x0b, 0xd6, 0x38, 0xcf, 0x61, 0xe3, 0x34, 0x50, 0x92, 0x4f, 0x85,
0x5c, 0x54, 0xe5, 0xe3, 0x40, 0x6b, 0xe4, 0xc8, 0x91, 0x7b, 0x58, 0xe3,
0xfc, 0x32, 0xd8, 0x63, 0x5c, 0x3a, 0x3a, 0x3a, 0x33, 0x0a, 0x0a, 0x0a,
0xe4, 0x91, 0x91, 0x91, 0x19, 0xa8, 0x68, 0x3f, 0xe9, 0x46, 0x47, 0x47,
0x67, 0xe7, 0xe5, 0xe5, 0xc9, 0x35, 0x35, 0x35, 0x27, 0x03, 0x30, 0x9f,
0x3c, 0x79, 0x72, 0x00, 0x21, 0x84, 0x34, 0x68, 0xd0, 0xa0, 0x35, 0x00,
0x9d, 0xb3, 0x67, 0xcf, 0x86, 0x9f, 0x38, 0x71, 0x22, 0xf7, 0xe2, 0xc5,
0x8b, 0x45, 0x17, 0x2e, 0x5c, 0x88, 0x00, 0xa0, 0xab, 0x68, 0x1f, 0x93,
0x26, 0x4d, 0xba, 0xc3, 0xa6, 0x4f, 0x0b, 0xc0, 0xc0, 0x5f, 0x7f, 0xfd,
0x35, 0x8f, 0x10, 0x42, 0xe6, 0xcf, 0x9f, 0xbf, 0x72, 0xe1, 0xc2, 0x85,
0x6b, 0x08, 0x21, 0x64, 0xe9, 0xd2, 0xa5, 0xb9, 0x60, 0x7c, 0xba, 0x7c,
0xda, 0x85, 0x00, 0x60, 0x78, 0x5c, 0x5c, 0x9c, 0x34, 0x23, 0x23, 0x43,
0x28, 0x10, 0x08, 0x4c, 0x54, 0xd3, 0x93, 0x9d, 0x9d, 0x2d, 0xd7, 0xd4,
0xd4, 0x9c, 0xa4, 0xf4, 0x8e, 0xf2, 0x31, 0x1d, 0x03, 0x00, 0x86, 0xbd,
0x7b, 0xf7, 0x1e, 0x2b, 0x97, 0xcb, 0xe9, 0x3f, 0xfe, 0xf8, 0xa3, 0x08,
0x8c, 0x3f, 0xa3, 0xca, 0xec, 0x36, 0xbd, 0x5b, 0xb7, 0x6e, 0xc5, 0xcb,
0xe5, 0x72, 0x62, 0x6d, 0x6d, 0xad, 0xda, 0x5f, 0xa9, 0xa3, 0x56, 0xc6,
0xb9, 0x8d, 0x8d, 0xcd, 0x0f, 0x72, 0xb9, 0x9c, 0xdc, 0xba, 0x75, 0x2b,
0x9e, 0xa2, 0x28, 0x7d, 0x75, 0x81, 0xba, 0x75, 0xeb, 0xd6, 0x2b, 0x2f,
0x2f, 0xaf, 0x40, 0xd1, 0x2f, 0x16, 0x14, 0x14, 0x14, 0x5e, 0xb9, 0x72,
0xe5, 0xe6, 0x4f, 0x3f, 0xfd, 0x34, 0xd7, 0xcb, 0xcb, 0xeb, 0xbb, 0x13,
0x27, 0x4e, 0x9c, 0x59, 0xb5, 0x6a, 0xd5, 0x36, 0x7c, 0xd9, 0x8e, 0xe6,
0x2f, 0xe2, 0x9b, 0xdc, 0x73, 0xee, 0xe8, 0xe8, 0xd8, 0xaa, 0x57, 0xaf,
0x5e, 0xae, 0xfb, 0xf7, 0xef, 0xcf, 0x2f, 0x2c, 0x2c, 0x3c, 0x0f, 0x40,
0xf5, 0x5e, 0x59, 0x4a, 0x2c, 0x16, 0x6b, 0x00, 0x80, 0x40, 0x20, 0x90,
0xa1, 0xe2, 0x7d, 0xe0, 0x84, 0xfd, 0x1b, 0xa4, 0x52, 0xa9, 0xe2, 0xec,
0xf7, 0x57, 0x63, 0x61, 0x61, 0x61, 0x73, 0xf9, 0xf2, 0x65, 0x3f, 0x91,
0x48, 0xc4, 0x9b, 0x30, 0x61, 0xc2, 0x63, 0x42, 0xc8, 0x1d, 0x00, 0x12,
0x95, 0x60, 0xda, 0x67, 0xce, 0x9c, 0x91, 0x45, 0x44, 0x44, 0xa4, 0x9b,
0x99, 0x99, 0xe9, 0x35, 0x6d, 0xda, 0x94, 0xb7, 0x61, 0xc3, 0x06, 0xf3,
0x5f, 0x7f, 0xfd, 0x75, 0xc4, 0xf8, 0xf1, 0xe3, 0x6f, 0x04, 0x06, 0x06,
0x7e, 0xba, 0x4f, 0xbd, 0x73, 0xe7, 0xce, 0x5e, 0xf3, 0xe7, 0xcf, 0x9f,
0xf2, 0xeb, 0xaf, 0xbf, 0x66, 0x47, 0x45, 0x45, 0xad, 0x04, 0x90, 0x89,
0xcf, 0x1d, 0x73, 0x29, 0x23, 0xed, 0xda, 0xb5, 0xeb, 0x75, 0x30, 0xc6,
0xe3, 0x47, 0x00, 0x72, 0x0d, 0x0d, 0x0d, 0x9b, 0x39, 0x73, 0xe6, 0xd8,
0x6e, 0xdf, 0xbe, 0xbd, 0xce, 0xa9, 0x53, 0xa7, 0xfc, 0x5a, 0xb6, 0x6c,
0xd9, 0x8c, 0x10, 0x22, 0x01, 0xc0, 0xab, 0x5b, 0xb7, 0x6e, 0x43, 0x00,
0x70, 0x72, 0x72, 0xb2, 0x71, 0x70, 0x70, 0x88, 0x4d, 0x4e, 0x4e, 0x7e,
0x0d, 0x20, 0x77, 0xc1, 0x82, 0x05, 0x5d, 0x83, 0x83, 0x83, 0xed, 0xe7,
0xcc, 0x99, 0x33, 0x63, 0xdf, 0xbe, 0x7d, 0x87, 0x62, 0x63, 0x63, 0x5f,
0xaa, 0xfb, 0x98, 0x40, 0x20, 0x30, 0xfc, 0xe9, 0xa7, 0x9f, 0x26, 0xa5,
0xa4, 0xa4, 0xc8, 0xaf, 0x5e, 0xbd, 0xba, 0x17, 0x40, 0x89, 0x4a, 0x10,
0xda, 0xc1, 0xc1, 0x41, 0xfb, 0xe2, 0xc5, 0x8b, 0xcd, 0x34, 0x35, 0x35,
0x29, 0x6f, 0x6f, 0x6f, 0x61, 0x8b, 0x16, 0x2d, 0x34, 0x7e, 0xfc, 0xf1,
0x47, 0xed, 0xbb, 0x77, 0xef, 0xb6, 0x1e, 0x33, 0x66, 0x0c, 0xb2, 0xb2,
0xb2, 0x14, 0xf5, 0x22, 0xcd, 0xcd, 0xcd, 0x7d, 0xf4, 0xd3, 0x4f, 0x3f,
0xa5, 0x1e, 0x3d, 0x7a, 0xb4, 0xde, 0xbd, 0x7b, 0xf7, 0xae, 0x24, 0x26,
0x26, 0xa6, 0xd4, 0xa9, 0x53, 0xc7, 0xa2, 0xa4, 0xa4, 0x44, 0xb6, 0x67,
0xcf, 0x1e, 0xe1, 0xa2, 0x45, 0x8b, 0x8c, 0x53, 0x53, 0x53, 0xf3, 0x2a,
0xc9, 0x7b, 0x11, 0x80, 0x9d, 0xec, 0xff, 0x8b, 0x6a, 0x50, 0x5d, 0x25,
0x60, 0x66, 0xc8, 0x29, 0x00, 0xa5, 0x2a, 0xf2, 0x01, 0x30, 0xd7, 0x4e,
0x35, 0x2d, 0x28, 0x28, 0xe0, 0x9b, 0x9a, 0x9a, 0x6a, 0x36, 0x68, 0xd0,
0x20, 0xda, 0xcc, 0xcc, 0xec, 0x97, 0xe2, 0xe2, 0xe2, 0x67, 0x6c, 0x78,
0xd5, 0x3b, 0x4b, 0x25, 0x60, 0x66, 0x4c, 0xef, 0x56, 0xf3, 0x5d, 0xb1,
0x8a, 0x4c, 0xc8, 0x01, 0x14, 0x03, 0x78, 0x0b, 0x60, 0x8b, 0x85, 0x85,
0xc5, 0x93, 0x86, 0x0d, 0x1b, 0x6e, 0xd6, 0xd7, 0xd7, 0xb7, 0xca, 0xc9,
0xc9, 0x91, 0x17, 0x16, 0x16, 0x36, 0x05, 0xa3, 0x38, 0x2a, 0xc8, 0x11,
0x9f, 0xcf, 0x17, 0xdc, 0xbe, 0x7d, 0xfb, 0x9e, 0x9b, 0x9b, 0x5b, 0xab,
0x11, 0x23, 0x46, 0x64, 0xf8, 0xf9, 0xf9, 0xed, 0x63, 0xf3, 0x53, 0x0a,
0x40, 0xb7, 0x7e, 0xfd, 0xfa, 0x75, 0xd3, 0xd3, 0xd3, 0x4b, 0x01, 0xf0,
0x9a, 0x34, 0x69, 0x62, 0x7d, 0xeb, 0xd6, 0xad, 0x42, 0x00, 0x0f, 0x00,
0x88, 0xcd, 0xcc, 0xcc, 0x34, 0xb3, 0xb3, 0xb3, 0x25, 0x00, 0x64, 0x52,
0xa9, 0xb4, 0x8c, 0xa6, 0x69, 0x85, 0xbf, 0x04, 0xc1, 0x88, 0x11, 0x23,
0x7e, 0x04, 0x00, 0x7f, 0x7f, 0xff, 0xa7, 0xec, 0x75, 0xe1, 0xe4, 0xf6,
0xed, 0xdb, 0x4f, 0xbd, 0xbd, 0xbd, 0x07, 0x8e, 0x18, 0x31, 0x62, 0x72,
0x58, 0x58, 0xd8, 0x7d, 0xa8, 0xdc, 0xf1, 0x38, 0x6d, 0xda, 0xb4, 0xc2,
0xf4, 0xf4, 0x74, 0x31, 0x00, 0x34, 0x6a, 0xd4, 0x48, 0xb3, 0x47, 0x8f,
0x1e, 0x9a, 0x1b, 0x37, 0x6e, 0xac, 0xb3, 0x60, 0xc1, 0x82, 0xef, 0x86,
0x0c, 0x19, 0x72, 0x38, 0x22, 0x22, 0x22, 0x17, 0x00, 0x4f, 0x24, 0x12,
0x69, 0x02, 0x80, 0xb6, 0xb6, 0x76, 0x21, 0xbe, 0xfe, 0x9e, 0x5d, 0xb9,
0x81, 0x81, 0x01, 0x01, 0x80, 0xbc, 0xbc, 0xbc, 0x0a, 0x6d, 0xb8, 0xa4,
0xa4, 0x04, 0xe3, 0xc7, 0x8f, 0xcf, 0x55, 0xae, 0x53, 0x42, 0x08, 0xa1,
0x69, 0x3a, 0x17, 0x4c, 0xfb, 0xf9, 0x4c, 0x86, 0x7a, 0xf6, 0xec, 0xd9,
0x86, 0xa6, 0xe9, 0xd6, 0xaa, 0x72, 0xb0, 0x67, 0xcf, 0x9e, 0xcb, 0x71,
0x71, 0x71, 0x71, 0x00, 0x78, 0x65, 0x65, 0x65, 0x7c, 0x00, 0xd0, 0xd4,
0xd4, 0x2c, 0x62, 0xeb, 0x5f, 0xd0, 0xa6, 0x4d, 0x9b, 0x21, 0x3f, 0xff,
0xfc, 0xf3, 0x1c, 0x45, 0xf8, 0x4b, 0x97, 0x2e, 0x85, 0x9c, 0x38, 0x71,
0xe2, 0xb4, 0x72, 0x1c, 0x73, 0xe7, 0xce, 0x2d, 0xca, 0xc8, 0xc8, 0xa8,
0x50, 0x7f, 0xd6, 0xd6, 0xd6, 0x9a, 0xbb, 0x77, 0xef, 0xfe, 0x92, 0x2b,
0x7a, 0xbe, 0x1a, 0x2b, 0x2b, 0x2b, 0x8d, 0xb8, 0xb8, 0x38, 0x13, 0x5f,
0x5f, 0x5f, 0xf1, 0x94, 0x29, 0x53, 0x0c, 0xe7, 0xcd, 0x9b, 0x37, 0x71,
0xfb, 0xf6, 0xed, 0xab, 0xbe, 0x51, 0xf4, 0xf4, 0xf3, 0xe7, 0xcf, 0x43,
0xcc, 0xcc, 0xcc, 0xda, 0xd8, 0xd9, 0xd9, 0x35, 0x31, 0x32, 0x32, 0x32,
0xd5, 0xd6, 0xd6, 0xe6, 0x3d, 0x7d, 0xfa, 0xf4, 0x49, 0xe7, 0xce, 0x9d,
0x2b, 0x3b, 0xe7, 0x57, 0x9a, 0x9b, 0x9b, 0x7b, 0x6c, 0xff, 0xfe, 0xfd,
0x93, 0xe7, 0xcd, 0x9b, 0xd7, 0x7d, 0xe5, 0xca, 0x95, 0xae, 0xa9, 0xa9,
0xa9, 0x05, 0x4a, 0xbf, 0xf3, 0xca, 0xca, 0xca, 0x74, 0xd8, 0xb2, 0x27,
0xf8, 0xbc, 0xad, 0x02, 0x00, 0xad, 0xa9, 0xa9, 0x49, 0x03, 0x40, 0x59,
0x59, 0x99, 0x2e, 0x94, 0xe4, 0x61, 0xd6, 0xac, 0x59, 0xad, 0x67, 0xcd,
0x9a, 0x15, 0xa3, 0x1c, 0xf8, 0xca, 0x95, 0x2b, 0xa2, 0xf9, 0xf3, 0xe7,
0x87, 0x4b, 0x24, 0x92, 0xeb, 0x00, 0xa4, 0xb5, 0x89, 0x5f, 0x2e, 0x97,
0x2b, 0xfb, 0x16, 0x80, 0x9b, 0x9b, 0x9b, 0x99, 0x9b, 0x9b, 0xdb, 0x1a,
0xc5, 0xbf, 0x5f, 0xbe, 0x7c, 0x59, 0xe6, 0xe9, 0xe9, 0xf9, 0xb2, 0xb0,
0xb0, 0x70, 0x2d, 0x18, 0xbd, 0xa4, 0xa0, 0x40, 0x2e, 0x97, 0xaf, 0x5c,
0xb1, 0x62, 0x45, 0xfa, 0x8e, 0x1d, 0x3b, 0xc6, 0x4d, 0x9b, 0x36, 0xcd,
0x62, 0xea, 0xd4, 0xa9, 0x3a, 0x0b, 0x17, 0x2e, 0x9c, 0x33, 0x6b, 0xd6,
0xac, 0x19, 0xde, 0xde, 0xde, 0xf3, 0x0f, 0x1f, 0x3e, 0xbc, 0xaf, 0x92,
0xef, 0xff, 0x1d, 0x88, 0x2e, 0x5e, 0xbc, 0x78, 0xde, 0xc7, 0xc7, 0xc7,
0x79, 0xc8, 0x90, 0x21, 0x23, 0x7c, 0x7d, 0x7d, 0xb7, 0x00, 0xa0, 0x86,
0x0c, 0x19, 0x32, 0x4c, 0x2e, 0x97, 0xe3, 0xe2, 0xc5, 0x8b, 0x67, 0xc1,
0xf4, 0xab, 0xf2, 0x92, 0x92, 0x92, 0xf8, 0x8c, 0x8c, 0x0c, 0xb9, 0x8d,
0x8d, 0x8d, 0x25, 0x00, 0x9d, 0x5e, 0xbd, 0x7a, 0x75, 0x0b, 0x0e, 0x0e,
0xce, 0x29, 0x2d, 0x2d, 0x95, 0x79, 0x79, 0x79, 0x75, 0x5e, 0xb2, 0x64,
0x89, 0xb6, 0xad, 0xad, 0x6d, 0x03, 0x89, 0x44, 0x42, 0xd2, 0xd2, 0xd2,
0x22, 0x51, 0xb1, 0x7d, 0x17, 0x7b, 0x7b, 0x7b, 0x6b, 0x4b, 0xa5, 0x52,
0x08, 0x04, 0x02, 0x2c, 0x5a, 0xb4, 0xc8, 0x6c, 0xea, 0xd4, 0xa9, 0x25,
0x95, 0xa4, 0x49, 0x98, 0x9b, 0x9b, 0xbb, 0xef, 0xb7, 0xdf, 0x7e, 0x1b,
0xbe, 0x61, 0xc3, 0x86, 0xe6, 0x00, 0xe0, 0xed, 0xed, 0xfd, 0xa1, 0xb8,
0xb8, 0xf8, 0x08, 0x3e, 0xef, 0x5f, 0x14, 0x50, 0x2b, 0x56, 0xac, 0xd8,
0xe8, 0xe6, 0xe6, 0xd6, 0x74, 0xda, 0xb4, 0x69, 0x19, 0x89, 0x89, 0x89,
0x2b, 0x01, 0x64, 0x7f, 0xc3, 0x72, 0x2c, 0xcb, 0xcb, 0xcb, 0x3b, 0x7b,
0xf2, 0xe4, 0xc9, 0x39, 0x53, 0xa7, 0x4e, 0x6d, 0xe3, 0xe0, 0xe0, 0xe0,
0x12, 0x17, 0x17, 0x17, 0xf6, 0x95, 0x71, 0x52, 0xe3, 0xc7, 0x8f, 0x9f,
0x6a, 0x69, 0x69, 0x69, 0xe0, 0xe3, 0xe3, 0x73, 0x06, 0x40, 0x16, 0x18,
0x9d, 0x42, 0x03, 0x78, 0xb6, 0x66, 0xcd, 0x9a, 0xe7, 0x8f, 0x1e, 0x3d,
0xea, 0x3e, 0x74, 0xe8, 0xd0, 0x71, 0x7e, 0x7e, 0x7e, 0x47, 0xbf, 0x61,
0x5e, 0xaa, 0x42, 0x0e, 0x20, 0x9e, 0xa2, 0x28, 0xca, 0xc9, 0xc9, 0xa9,
0x79, 0xc3, 0x86, 0x0d, 0x1b, 0xd5, 0xad, 0x5b, 0xd7, 0x56, 0x57, 0x57,
0xb7, 0x0e, 0x00, 0xa9, 0x40, 0x20, 0xd0, 0xe6, 0xf1, 0x78, 0x9a, 0x34,
0x5d, 0xb1, 0xeb, 0x7b, 0xf3, 0xe6, 0x4d, 0x14, 0x80, 0x28, 0x00, 0x85,
0xec, 0x9f, 0xde, 0xbe, 0x7c, 0xf9, 0xf2, 0x1e, 0x80, 0x71, 0xf6, 0xf6,
0xf6, 0x9d, 0xc1, 0x0c, 0xbc, 0xcb, 0x1a, 0x35, 0x6a, 0xd4, 0x5c, 0x47,
0x47, 0x47, 0x70, 0xfd, 0xfa, 0xf5, 0x22, 0xa1, 0x50, 0xb8, 0x01, 0x40,
0x2c, 0x2a, 0xca, 0x49, 0x2e, 0xca, 0xfb, 0x55, 0x4d, 0x07, 0x07, 0x87,
0x2e, 0x00, 0x10, 0x1a, 0x1a, 0x7a, 0x1f, 0x4c, 0xff, 0xa8, 0xb8, 0x83,
0xfe, 0x55, 0x64, 0x64, 0xe4, 0x6b, 0x30, 0x4e, 0xf7, 0x14, 0x68, 0xba,
0xb8, 0xb8, 0xf4, 0x01, 0x00, 0x1d, 0x1d, 0x9d, 0x8f, 0x4b, 0x96, 0x2c,
0xe9, 0x05, 0xc6, 0x3f, 0x01, 0x00, 0x68, 0xd9, 0xd8, 0xd8, 0x14, 0x00,
0xb0, 0x71, 0x74, 0x74, 0x6c, 0xcb, 0xa6, 0x47, 0x06, 0xa6, 0x4f, 0x95,
0x80, 0xb9, 0xb3, 0x5b, 0x0a, 0x00, 0x14, 0x45, 0x49, 0xd9, 0xef, 0xa8,
0x8e, 0x27, 0x79, 0x1f, 0x3f, 0x7e, 0xa4, 0x8b, 0x8b, 0x8b, 0x89, 0x93,
0x93, 0x13, 0x61, 0xeb, 0xab, 0x04, 0x40, 0x99, 0xb3, 0xb3, 0x73, 0x3e,
0x00, 0x14, 0x16, 0x16, 0xea, 0xb2, 0xf9, 0xa9, 0x50, 0x57, 0xa1, 0xa1,
0xa1, 0xd1, 0x00, 0x1e, 0xa2, 0xbc, 0xdf, 0x91, 0xbf, 0x7a, 0xf5, 0x2a,
0x04, 0x40, 0x5d, 0x53, 0x53, 0xd3, 0x86, 0x60, 0xc6, 0xc4, 0x8a, 0x3e,
0x55, 0xc6, 0x3e, 0x1a, 0x35, 0xac, 0x73, 0x45, 0x1e, 0x14, 0xf5, 0x57,
0xdd, 0xfd, 0xe3, 0xa4, 0xb0, 0xb0, 0x50, 0xfa, 0xdd, 0x77, 0xdf, 0x0d,
0x3c, 0x7d, 0xfa, 0xb4, 0xef, 0xe5, 0xcb, 0x97, 0x4b, 0xc6, 0x8c, 0x19,
0x73, 0x4d, 0x2a, 0x95, 0x2e, 0x07, 0x90, 0x82, 0xaf, 0xbc, 0x2f, 0x3e,
0x2f, 0x2f, 0x2f, 0x03, 0x40, 0x1a, 0x00, 0xcd, 0xcc, 0xcc, 0xcc, 0x32,
0x43, 0x43, 0x43, 0x0d, 0x00, 0x91, 0x00, 0x84, 0x22, 0x91, 0x28, 0x1b,
0x00, 0x74, 0x75, 0x75, 0x2d, 0x00, 0x24, 0xd5, 0xb2, 0x7c, 0xf8, 0x4e,
0x4e, 0x4e, 0x9d, 0x00, 0x20, 0x38, 0x38, 0x78, 0x1f, 0x80, 0x18, 0xa5,
0x3a, 0x7a, 0x17, 0x1c, 0x1c, 0x7c, 0x08, 0xc0, 0x6e, 0x17, 0x17, 0x17,
0x0f, 0xa8, 0x4c, 0xfc, 0x47, 0x47, 0x47, 0x47, 0x00, 0x78, 0x83, 0x72,
0x5d, 0xac, 0x4e, 0x3e, 0x51, 0x95, 0xbc, 0x45, 0x45, 0x45, 0xbd, 0x41,
0x45, 0x79, 0xab, 0xc0, 0xfd, 0xfb, 0xf7, 0x13, 0x01, 0x9c, 0x04, 0x33,
0xee, 0x56, 0xd4, 0x1b, 0xa5, 0x52, 0x87, 0x64, 0xdf, 0xbe, 0x7d, 0x91,
0x83, 0x07, 0x0f, 0xae, 0xfb, 0xe4, 0xc9, 0x93, 0xfd, 0x67, 0xcf, 0x9e,
0xed, 0x79, 0xe8, 0xd0, 0xa1, 0x03, 0x8f, 0x1f, 0x3f, 0x7e, 0xc0, 0xe6,
0x5d, 0xb9, 0xef, 0x21, 0x6c, 0xfe, 0xc4, 0x00, 0x84, 0x4a, 0x7f, 0x13,
0x2a, 0xa5, 0xeb, 0x6b, 0x10, 0x8b, 0x44, 0xa2, 0xdb, 0xe7, 0xce, 0x9d,
0x2b, 0x9c, 0x36, 0x6d, 0x9a, 0x55, 0xcb, 0x96, 0x2d, 0xdb, 0xbd, 0x7a,
0xf5, 0xea, 0x3e, 0x00, 0xb4, 0x6d, 0xdb, 0xb6, 0x8b, 0xa3, 0xa3, 0xa3,
0xf9, 0x9e, 0x3d, 0x7b, 0xf2, 0x24, 0x12, 0xc9, 0x5d, 0x00, 0x25, 0xa1,
0xa1, 0xa1, 0x4f, 0x01, 0xf4, 0x6c, 0xd1, 0xa2, 0x45, 0x97, 0xe4, 0xe4,
0xe4, 0xc4, 0x4e, 0x9d, 0x3a, 0x35, 0xd9, 0xbe, 0x7d, 0xfb, 0x3b, 0x5d,
0x5d, 0x5d, 0x9d, 0x19, 0x33, 0x66, 0xd8, 0x03, 0xd0, 0x6a, 0xd9, 0xb2,
0x65, 0x17, 0x00, 0x08, 0x09, 0x09, 0x09, 0x06, 0x23, 0x87, 0x62, 0x00,
0x0f, 0xd6, 0xaf, 0x5f, 0xbf, 0xab, 0x5b, 0xb7, 0x6e, 0x4b, 0x37, 0x6d,
0xda, 0xf4, 0x2b, 0x45, 0x51, 0xd4, 0xdd, 0xbb, 0x77, 0x45, 0x9b, 0x37,
0x6f, 0xde, 0x09, 0x76, 0x3c, 0xca, 0xa6, 0x47, 0x0a, 0xe0, 0xf1, 0xfe,
0xfd, 0xfb, 0xd3, 0xb6, 0x6e, 0xdd, 0xda, 0x60, 0xe0, 0xc0, 0x81, 0x23,
0xfc, 0xfc, 0xfc, 0x0e, 0x01, 0x20, 0x8a, 0xf4, 0xec, 0xda, 0xb5, 0x2b,
0x87, 0x4d, 0x8f, 0x42, 0xde, 0x09, 0x94, 0xfa, 0x84, 0x86, 0x0d, 0x1b,
0x3a, 0x9e, 0x39, 0x73, 0xe6, 0xc0, 0xb3, 0x67, 0xcf, 0xca, 0xe6, 0xce,
0x9d, 0x7b, 0x0c, 0xcc, 0x4e, 0x8c, 0x0a, 0xed, 0xd8, 0xcb, 0xcb, 0xab,
0x7f, 0xb3, 0x66, 0xcd, 0x9a, 0x0f, 0x1a, 0x34, 0x68, 0x70, 0xd7, 0xae,
0x5d, 0x1b, 0x1d, 0x38, 0x70, 0xa0, 0x28, 0x23, 0x23, 0x23, 0x0c, 0x5f,
0x3f, 0x1e, 0x55, 0x46, 0x96, 0x9e, 0x9e, 0x1e, 0x72, 0xf0, 0xe0, 0xc1,
0xa2, 0xe9, 0xd3, 0xa7, 0xdb, 0xdd, 0xbf, 0x7f, 0x3f, 0xe0, 0xf2, 0xe5,
0xcb, 0x97, 0xde, 0xbd, 0x7b, 0xf7, 0xf6, 0xf6, 0xed, 0xdb, 0xd7, 0xd9,
0x30, 0x02, 0x4f, 0x4f, 0xcf, 0x89, 0xfb, 0xf6, 0xed, 0x13, 0x9e, 0x3e,
0x7d, 0xba, 0xb8, 0x49, 0x93, 0x26, 0x02, 0x2f, 0x2f, 0x2f, 0x41, 0xf7,
0xee, 0xdd, 0x3b, 0x0f, 0x1c, 0x38, 0xb0, 0x2f, 0x00, 0x24, 0x26, 0x26,
0x16, 0x6d, 0xdf, 0xbe, 0x7d, 0x2f, 0x98, 0xc9, 0x88, 0x9a, 0xd8, 0x34,
0x5f, 0xcd, 0xb7, 0x30, 0xce, 0x35, 0xbc, 0xbd, 0xbd, 0x17, 0x53, 0x14,
0x05, 0x1f, 0x1f, 0x9f, 0x1b, 0x00, 0x32, 0xa0, 0x46, 0xa9, 0x64, 0x66,
0x66, 0x16, 0x01, 0x80, 0xb1, 0xb1, 0xb1, 0xba, 0xad, 0xe5, 0x06, 0x00,
0x90, 0x95, 0x95, 0x55, 0x8c, 0x6f, 0xd0, 0xf1, 0xe9, 0xe8, 0xe8, 0xe8,
0x5f, 0xbd, 0x7a, 0xf5, 0x56, 0xbd, 0x7a, 0xf5, 0xac, 0x7b, 0xf7, 0xee,
0x9d, 0x10, 0x13, 0x13, 0xb3, 0x02, 0x4c, 0x67, 0xa3, 0x1a, 0xb7, 0xe4,
0xe5, 0xcb, 0x97, 0x27, 0x5f, 0xbe, 0x7c, 0x19, 0x0e, 0x66, 0x76, 0xcd,
0x6e, 0xd3, 0xa6, 0x4d, 0x5d, 0x43, 0x43, 0x43, 0x1d, 0xcf, 0x9e, 0x3d,
0x7b, 0xa6, 0x51, 0xa3, 0x46, 0x76, 0x42, 0xa1, 0x30, 0x57, 0x57, 0x57,
0xd7, 0xf8, 0xe8, 0xd1, 0xa3, 0x47, 0x42, 0x42, 0x42, 0xca, 0x36, 0x6f,
0xde, 0xec, 0x03, 0x20, 0x14, 0xd5, 0x2b, 0xde, 0x22, 0x30, 0x9e, 0x7c,
0x35, 0x14, 0xe5, 0x21, 0x93, 0xc9, 0x0c, 0x76, 0xec, 0xd8, 0x31, 0xf6,
0xbb, 0xef, 0xbe, 0x5b, 0xe3, 0xe9, 0xe9, 0x69, 0xd7, 0xa8, 0x51, 0x23,
0x97, 0x84, 0x84, 0x84, 0x30, 0x00, 0x3c, 0xb1, 0x58, 0xac, 0x05, 0x00,
0x9b, 0x37, 0x6f, 0xce, 0x48, 0x4e, 0x4e, 0x9e, 0x0c, 0xe0, 0x1d, 0x00,
0x59, 0x69, 0x69, 0xa9, 0xed, 0xa5, 0x4b, 0x97, 0x6e, 0xb6, 0x68, 0xd1,
0xa2, 0x41, 0xbb, 0x76, 0xed, 0xbe, 0x8b, 0x8d, 0x8d, 0x55, 0x1d, 0x6c,
0x01, 0xcc, 0x59, 0xa5, 0x71, 0x75, 0xeb, 0xd6, 0x35, 0x5c, 0xb6, 0x6c,
0x59, 0x2a, 0x4d, 0xd3, 0x81, 0x50, 0x31, 0x20, 0x29, 0x8a, 0x12, 0x04,
0x06, 0x06, 0x06, 0xea, 0xe8, 0xe8, 0x98, 0xb8, 0xb9, 0xb9, 0x25, 0x45,
0x47, 0x47, 0x1f, 0x01, 0x50, 0xef, 0xe4, 0xc9, 0x93, 0xdf, 0xdd, 0xb8,
0x71, 0xa3, 0x75, 0x40, 0x40, 0xc0, 0x3d, 0x57, 0x57, 0xd7, 0x66, 0x6c,
0xdc, 0x34, 0x80, 0x0f, 0x67, 0xcf, 0x9e, 0x5d, 0xfd, 0xf2, 0xe5, 0xcb,
0x95, 0x43, 0x87, 0x0e, 0x35, 0xb6, 0xb3, 0xb3, 0xd3, 0x79, 0xf3, 0xe6,
0x4d, 0xe1, 0xa5, 0x4b, 0x97, 0xb2, 0xa6, 0x4d, 0x9b, 0xc6, 0x03, 0x60,
0x9c, 0x9e, 0x9e, 0x9e, 0x04, 0xf5, 0x1d, 0x08, 0x01, 0x63, 0x98, 0xd6,
0x94, 0xea, 0xc2, 0x93, 0x9b, 0x37, 0x6f, 0x3e, 0xb6, 0xb3, 0xb3, 0xeb,
0x3d, 0x65, 0xca, 0x94, 0x46, 0x3f, 0xff, 0xfc, 0x73, 0xd3, 0xa9, 0x53,
0xa7, 0xde, 0x3e, 0x73, 0xe6, 0xcc, 0x5f, 0x9b, 0x36, 0x6d, 0x5a, 0x1f,
0x1d, 0x1d, 0xfd, 0x5a, 0xf5, 0x85, 0xe9, 0xd3, 0xa7, 0x4f, 0x9d, 0x34,
0x69, 0xd2, 0x44, 0x54, 0x3e, 0xcb, 0x4d, 0x0e, 0x1d, 0x3a, 0x74, 0xf8,
0xf0, 0xe1, 0xc3, 0x07, 0x54, 0x7f, 0x68, 0xde, 0xbc, 0xb9, 0xf3, 0xd2,
0xa5, 0x4b, 0x57, 0x8c, 0x1e, 0x3d, 0x7a, 0x58, 0x6a, 0x6a, 0x6a, 0xe9,
0xbc, 0x79, 0xf3, 0x0a, 0x8f, 0x1c, 0x39, 0x12, 0x27, 0x16, 0x8b, 0x83,
0xd5, 0xc4, 0x43, 0xb5, 0x6c, 0xd9, 0xd2, 0xa3, 0x73, 0xe7, 0xce, 0x6e,
0x0b, 0x16, 0x2c, 0xf8, 0xe8, 0xe7, 0xe7, 0xb7, 0x0c, 0xcc, 0xd6, 0xc0,
0x42, 0x36, 0x5f, 0x3c, 0x4d, 0x4d, 0x4d, 0x3d, 0x9a, 0xa6, 0xa5, 0x00,
0x28, 0x91, 0x48, 0x84, 0xc2, 0xc2, 0xc2, 0x7c, 0x00, 0x22, 0x3e, 0x9f,
0xaf, 0xd5, 0xb4, 0x69, 0x53, 0x03, 0xf6, 0x2e, 0x62, 0x62, 0x64, 0x64,
0xa4, 0x11, 0x13, 0x13, 0xa3, 0x50, 0xf6, 0x5a, 0xc3, 0x86, 0x0d, 0xeb,
0x0d, 0x00, 0xd7, 0xaf, 0x5f, 0x1f, 0x04, 0x40, 0xf9, 0x7a, 0x2b, 0x0c,
0x1f, 0x3e, 0xdc, 0xeb, 0x97, 0x5f, 0x7e, 0xd1, 0x82, 0x8a, 0x71, 0x7e,
0xff, 0xfe, 0xfd, 0x83, 0x4a, 0x83, 0xd5, 0xba, 0x7b, 0xf6, 0xec, 0x71,
0x1f, 0x3f, 0x7e, 0x7c, 0x97, 0x13, 0x27, 0x4e, 0xd4, 0x3d, 0x72, 0xe4,
0xc8, 0xa9, 0x36, 0x6d, 0xda, 0x34, 0x07, 0x80, 0xe4, 0xe4, 0xe4, 0x22,
0x00, 0xa8, 0x5f, 0xbf, 0x7e, 0x55, 0xab, 0x5a, 0x35, 0x85, 0xb2, 0xb3,
0xb3, 0xd3, 0x29, 0x2a, 0x2a, 0x22, 0x1f, 0x3f, 0x7e, 0x4c, 0x81, 0x52,
0x3b, 0x93, 0x4a, 0xa5, 0xf4, 0xa5, 0x4b, 0x97, 0x96, 0xa1, 0x62, 0x27,
0x46, 0xc0, 0x28, 0x38, 0xb5, 0x03, 0xfc, 0x8e, 0x1d, 0x3b, 0xe6, 0x84,
0x87, 0x87, 0x17, 0xa1, 0x62, 0x7b, 0x2d, 0x02, 0xf0, 0x81, 0x4d, 0x2b,
0x49, 0x49, 0x49, 0x29, 0x6d, 0xdf, 0xbe, 0xbd, 0xa1, 0x95, 0x95, 0x95,
0x65, 0x4a, 0x4a, 0x0a, 0x05, 0x80, 0xbf, 0x6f, 0xdf, 0xbe, 0xe8, 0x63,
0xc7, 0x8e, 0xc5, 0xd4, 0xab, 0x57, 0xcf, 0x24, 0x2a, 0x2a, 0xca, 0x82,
0x10, 0xa2, 0x70, 0xf4, 0xf5, 0x89, 0x9b, 0x37, 0x6f, 0x1e, 0x8d, 0x8b,
0x8b, 0x7b, 0x89, 0x72, 0xb9, 0xe5, 0x39, 0x38, 0x38, 0xb4, 0xda, 0xbd,
0x7b, 0xf7, 0xdc, 0xaf, 0x2c, 0x83, 0x2f, 0x22, 0x2b, 0x2b, 0x8b, 0x74,
0xef, 0xde, 0xfd, 0xa9, 0x86, 0x86, 0x46, 0x4e, 0xf7, 0xee, 0xdd, 0x47,
0xae, 0x5b, 0xb7, 0xee, 0x97, 0x2b, 0x57, 0xae, 0xfc, 0x15, 0x17, 0x17,
0x17, 0xf9, 0xb5, 0x71, 0x13, 0x42, 0xe8, 0xf0, 0xf0, 0xf0, 0x40, 0x89,
0x44, 0x32, 0xdd, 0xdd, 0xdd, 0xbd, 0xb7, 0xb1, 0xb1, 0xb1, 0x59, 0x76,
0x76, 0xb6, 0x3c, 0x3e, 0x3e, 0xfe, 0x1e, 0x98, 0x9d, 0x25, 0xea, 0xa0,
0x01, 0x7c, 0xd8, 0xbe, 0x7d, 0xfb, 0x39, 0x6f, 0x6f, 0xef, 0x99, 0x4b,
0x96, 0x2c, 0x59, 0x35, 0x63, 0xc6, 0x8c, 0x79, 0x00, 0xc0, 0xe3, 0xf1,
0x00, 0x80, 0x64, 0x66, 0x66, 0x66, 0x10, 0x42, 0x60, 0x66, 0x66, 0x56,
0xd9, 0x0c, 0x37, 0x65, 0x6e, 0x6e, 0xae, 0x49, 0x08, 0x41, 0x5a, 0x5a,
0x5a, 0x9a, 0xf2, 0x0f, 0xf7, 0xee, 0xdd, 0x93, 0x5d, 0xbb, 0x76, 0xad,
0x58, 0x22, 0x91, 0x90, 0xe4, 0xe4, 0x64, 0xd9, 0xfb, 0xf7, 0xef, 0xa5,
0x71, 0x71, 0x71, 0xf7, 0xc1, 0x6c, 0x87, 0xcb, 0x04, 0x40, 0xd7, 0x34,
0x7e, 0x00, 0xc8, 0xcb, 0xcb, 0x2b, 0x54, 0xfe, 0xe1, 0xe2, 0xc5, 0x8b,
0x32, 0x6f, 0x6f, 0xef, 0x8f, 0x7c, 0x3e, 0x1f, 0x41, 0x41, 0x41, 0x56,
0xcd, 0x9a, 0x35, 0xd3, 0x34, 0x33, 0x33, 0x5b, 0x5d, 0x58, 0x58, 0xa8,
0x3c, 0x90, 0x00, 0x18, 0xd9, 0xca, 0x04, 0xb0, 0x35, 0x2f, 0x2f, 0xef,
0xec, 0xe6, 0xcd, 0x9b, 0x07, 0x6f, 0xde, 0xbc, 0x79, 0xd0, 0xa8, 0x51,
0xa3, 0x9a, 0xec, 0xdf, 0xbf, 0xdf, 0xe8, 0xd0, 0xa1, 0x43, 0x7b, 0x5e,
0xbd, 0x7a, 0x15, 0x15, 0x16, 0x16, 0xf6, 0xe8, 0x5b, 0xd7, 0x39, 0x45,
0x51, 0xea, 0xda, 0x9b, 0x38, 0x33, 0x33, 0xf3, 0xf2, 0xa3, 0x47, 0x8f,
0x96, 0xf5, 0xec, 0xd9, 0xd3, 0xc9, 0xc0, 0xc0, 0xc0, 0x9c, 0xcf, 0xe7,
0x6b, 0x74, 0xeb, 0xd6, 0xad, 0xc9, 0x83, 0x07, 0x0f, 0xca, 0xb2, 0xb2,
0xb2, 0xae, 0x82, 0x19, 0x3c, 0x11, 0x00, 0xc2, 0xf8, 0xf8, 0x78, 0x91,
0xad, 0xad, 0xad, 0xb1, 0x81, 0x81, 0x81, 0x59, 0x87, 0x0e, 0x1d, 0x1a,
0xec, 0xdd, 0xbb, 0xf7, 0xae, 0x50, 0x28, 0x2c, 0x5d, 0xbc, 0x78, 0xf1,
0x60, 0x2b, 0x2b, 0xab, 0x06, 0x75, 0xeb, 0xd6, 0xb5, 0x4e, 0x49, 0x49,
0x91, 0xd1, 0x34, 0x9d, 0x09, 0x25, 0x1d, 0xdd, 0xb1, 0x63, 0x47, 0xcf,
0xf1, 0xe3, 0xc7, 0x77, 0xdb, 0xb2, 0x65, 0x8b, 0xc8, 0xce, 0xce, 0x4e,
0x63, 0xf2, 0xe4, 0xc9, 0x7d, 0x0e, 0x1e, 0x3c, 0xd8, 0x25, 0x24, 0x24,
0xe4, 0x5e, 0x25, 0xb2, 0x90, 0xbc, 0x6b, 0xd7, 0xae, 0x03, 0xcb, 0x97,
0x2f, 0xff, 0x55, 0x2a, 0x95, 0xe2, 0xc0, 0x81, 0x03, 0xbb, 0xc1, 0x0c,
0xf8, 0xd5, 0x1a, 0x0e, 0xee, 0xee, 0xee, 0x1e, 0xcb, 0x97, 0x2f, 0x9f,
0x7b, 0xf3, 0xe6, 0x4d, 0xd1, 0xa1, 0x43, 0x87, 0x36, 0x82, 0x31, 0x06,
0x64, 0xf8, 0x76, 0xd0, 0x00, 0xd2, 0xf6, 0xec, 0xd9, 0x73, 0x7b, 0xda,
0xb4, 0x69, 0xa3, 0xbd, 0xbd, 0xbd, 0x7f, 0x9e, 0x37, 0x6f, 0xde, 0x38,
0x7c, 0xdd, 0x80, 0x4e, 0xcb, 0xda, 0xda, 0xba, 0xfd, 0x9a, 0x35, 0x6b,
0x3e, 0x26, 0x24, 0x24, 0x1c, 0x46, 0xc5, 0xbe, 0xa8, 0xe8, 0xf1, 0xe3,
0xc7, 0x3b, 0x36, 0x6e, 0xdc, 0xe8, 0xda, 0xb4, 0x69, 0xd3, 0x5e, 0x60,
0xb6, 0xbf, 0x8a, 0xbf, 0xec, 0x33, 0xb5, 0x82, 0x1a, 0x35, 0x6a, 0xd4,
0xd8, 0xf5, 0xeb, 0xd7, 0xaf, 0x75, 0x70, 0x70, 0x68, 0x54, 0x5a, 0x5a,
0x2a, 0x4e, 0x4d, 0x4d, 0x2d, 0x28, 0x28, 0x28, 0x90, 0x58, 0x59, 0x59,
0x09, 0x00, 0x80, 0xa2, 0xa8, 0xcf, 0xc6, 0x6f, 0xb9, 0xb9, 0xb9, 0x89,
0xa8, 0x28, 0xe7, 0x92, 0xec, 0xec, 0xec, 0x28, 0x00, 0xb0, 0xb1, 0xb1,
0xb1, 0x05, 0x33, 0xf1, 0xcb, 0xb7, 0xb3, 0xb3, 0x6b, 0x03, 0x00, 0x29,
0x29, 0x29, 0xe9, 0x60, 0xc6, 0x6c, 0xaa, 0xe5, 0xa7, 0x5c, 0xbf, 0xfc,
0xba, 0x75, 0xeb, 0xd6, 0x03, 0x80, 0xec, 0xec, 0xec, 0x48, 0x95, 0xfc,
0x8b, 0x3f, 0x7e, 0xfc, 0x18, 0x8f, 0x8a, 0xc6, 0x92, 0x46, 0xa3, 0x46,
0x8d, 0xec, 0x00, 0x60, 0xfc, 0xf8, 0xf1, 0x4d, 0xc0, 0x5c, 0x87, 0x56,
0x21, 0x6f, 0x32, 0x99, 0x0c, 0x7a, 0x7a, 0x7a, 0x26, 0xf8, 0xb2, 0x31,
0x28, 0x2d, 0x95, 0x4a, 0x73, 0x2f, 0x5e, 0xbc, 0x58, 0x34, 0x71, 0xe2,
0x44, 0xa3, 0xf5, 0xeb, 0xd7, 0xaf, 0x39, 0x7b, 0xf6, 0xec, 0x91, 0x86,
0x0d, 0x1b, 0x36, 0x5e, 0xbe, 0x7c, 0xb9, 0xb7, 0x4c, 0x26, 0xc3, 0x9f,
0x7f, 0xfe, 0xf9, 0x12, 0x6a, 0xc6, 0x92, 0x99, 0x99, 0x99, 0xca, 0x86,
0x24, 0x00, 0x48, 0x29, 0x8a, 0xca, 0x60, 0xff, 0x5f, 0x1b, 0xff, 0xf0,
0xf5, 0xb0, 0x75, 0xeb, 0xd6, 0xd5, 0x3a, 0x77, 0xee, 0xdc, 0x7e, 0x3e,
0x9f, 0xcf, 0x33, 0x32, 0x32, 0x12, 0x11, 0x42, 0x7e, 0xc5, 0x37, 0x30,
0xcc, 0x01, 0xa0, 0xac, 0xac, 0xac, 0x18, 0x4c, 0xbd, 0xca, 0x09, 0x21,
0x52, 0x91, 0x48, 0x44, 0xc0, 0x8c, 0x5b, 0x09, 0x3b, 0xf1, 0x01, 0x94,
0x1f, 0xeb, 0xab, 0x4d, 0xf9, 0x68, 0x34, 0x68, 0xd0, 0xc0, 0x42, 0x26,
0x93, 0x21, 0x37, 0x37, 0xf7, 0x21, 0x2a, 0xca, 0x9b, 0xf8, 0xe3, 0xc7,
0x8f, 0x41, 0x84, 0x10, 0x34, 0x6a, 0xd4, 0xc8, 0x0a, 0xcc, 0x62, 0xc6,
0xa7, 0xb1, 0x72, 0x4e, 0x4e, 0x4e, 0x12, 0x2a, 0x8e, 0x9d, 0xd5, 0xc9,
0x27, 0x6a, 0x29, 0x6f, 0x15, 0x48, 0x4f, 0x4f, 0x57, 0x18, 0xf3, 0x15,
0x8c, 0x71, 0xd5, 0xe2, 0x79, 0xf0, 0xe0, 0xc1, 0x1f, 0xee, 0xee, 0xee,
0xcd, 0x57, 0xad, 0x5a, 0x65, 0x3e, 0x6e, 0xdc, 0xb8, 0x51, 0x13, 0x26,
0x4c, 0x18, 0xfd, 0xea, 0xd5, 0xab, 0xd7, 0xab, 0x57, 0xaf, 0x5e, 0x73,
0xe5, 0xca, 0x95, 0xbf, 0xbe, 0x45, 0xfd, 0xd6, 0x10, 0x02, 0x20, 0xf7,
0xe8, 0xd1, 0xa3, 0x81, 0xd3, 0xa6, 0x4d, 0x1b, 0x3e, 0x71, 0xe2, 0xc4,
0x9f, 0x5e, 0xbd, 0x7a, 0xf5, 0x08, 0x00, 0x35, 0x61, 0xc2, 0x84, 0x9f,
0x00, 0xe0, 0xe8, 0xd1, 0xa3, 0xfe, 0x00, 0xf2, 0x01, 0x48, 0xdf, 0xbe,
0x7d, 0x1b, 0x28, 0x12, 0x89, 0x56, 0xb8, 0xb8, 0xb8, 0xb4, 0x8f, 0x88,
0x88, 0x78, 0x66, 0x6b, 0x6b, 0xab, 0x17, 0x12, 0x12, 0x12, 0xae, 0xad,
0xad, 0xad, 0xb3, 0x61, 0xc3, 0x06, 0x27, 0x5b, 0x5b, 0x5b, 0xfb, 0x96,
0x2d, 0x5b, 0x76, 0x2a, 0x2d, 0x2d, 0x25, 0xd1, 0xd1, 0xd1, 0x81, 0x28,
0xd7, 0xbf, 0x45, 0x84, 0x90, 0x43, 0x8b, 0x17, 0x2f, 0xf6, 0x0c, 0x0d,
0x0d, 0xed, 0x06, 0x00, 0xac, 0x73, 0xd1, 0xc3, 0xf8, 0x7c, 0x7c, 0x56,
0x74, 0xf4, 0xe8, 0xd1, 0xe3, 0xeb, 0xd7, 0xaf, 0xff, 0x75, 0xfa, 0xf4,
0xe9, 0xb3, 0xfd, 0xfc, 0xfc, 0x8e, 0x03, 0xa0, 0x95, 0xd2, 0x73, 0x93,
0x4d, 0xcf, 0x67, 0x6d, 0x4c, 0x47, 0x47, 0xc7, 0xe0, 0xe2, 0xc5, 0x8b,
0x57, 0x24, 0x12, 0x89, 0xd6, 0x88, 0x11, 0x23, 0xee, 0x4b, 0xa5, 0xd2,
0x6d, 0x28, 0x9f, 0xf0, 0x50, 0xa0, 0xb9, 0x71, 0xe3, 0xc6, 0x5d, 0xad,
0x5b, 0xb7, 0x76, 0x00, 0x00, 0x6f, 0x6f, 0xef, 0xdc, 0xbd, 0x7b, 0xf7,
0x1e, 0x07, 0x33, 0xc6, 0xfb, 0x6a, 0xd9, 0x57, 0x82, 0x06, 0xf0, 0x61,
0xe6, 0xcc, 0x99, 0x87, 0xa3, 0xa2, 0xa2, 0x26, 0xee, 0xdd, 0xbb, 0xb7,
0xbd, 0x87, 0x87, 0x47, 0xfb, 0x97, 0x2f, 0x5f, 0xc6, 0xdf, 0xbe, 0x7d,
0x5b, 0xb1, 0x60, 0xab, 0xb1, 0x75, 0xeb, 0xd6, 0x30, 0xa1, 0x50, 0x18,
0x0d, 0xe0, 0xd9, 0x9b, 0x37, 0x6f, 0xac, 0x2e, 0x5d, 0xba, 0xd4, 0x0e,
0x40, 0x4b, 0x5b, 0x5b, 0xdb, 0x06, 0xc6, 0xc6, 0xc6, 0xd4, 0xdb, 0xb7,
0x6f, 0x63, 0x69, 0x9a, 0xbe, 0x81, 0xea, 0xed, 0xbe, 0x6f, 0xc6, 0x57,
0x1b, 0xe7, 0x46, 0x46, 0x46, 0x96, 0x13, 0x27, 0x4e, 0x1c, 0x10, 0x10,
0x10, 0x50, 0x16, 0x1d, 0x1d, 0x7d, 0x00, 0xea, 0x67, 0x15, 0xe8, 0xac,
0xac, 0xac, 0x4c, 0x00, 0xa8, 0x53, 0xa7, 0x4e, 0x1d, 0xa8, 0x6c, 0xf3,
0xb3, 0xb4, 0xb4, 0xb4, 0x04, 0x00, 0x36, 0xcc, 0x57, 0x19, 0xe7, 0x1a,
0x1a, 0x1a, 0x9a, 0x17, 0x2e, 0x5c, 0xb8, 0xda, 0xae, 0x5d, 0x3b, 0xd7,
0xef, 0xbf, 0xff, 0x3e, 0xe3, 0xc1, 0x83, 0x07, 0x8b, 0x00, 0x84, 0x43,
0xfd, 0x00, 0x41, 0x06, 0xe0, 0x15, 0x98, 0x99, 0x66, 0x1e, 0x00, 0xcd,
0xd4, 0xd4, 0xd4, 0x66, 0xd7, 0xae, 0x5d, 0xbb, 0x31, 0x65, 0xca, 0x14,
0x53, 0x57, 0x57, 0x57, 0x8f, 0xe0, 0xe0, 0xe0, 0x2b, 0xa3, 0x47, 0x8f,
0x9e, 0xea, 0xe0, 0xe0, 0x60, 0xad, 0xab, 0xab, 0x2b, 0x89, 0x88, 0x88,
0x98, 0x48, 0x08, 0x19, 0x0b, 0x00, 0x14, 0x45, 0xf1, 0x1d, 0x1c, 0x1c,
0xf4, 0x04, 0x02, 0x01, 0x2f, 0x2a, 0x2a, 0xea, 0x09, 0x4d, 0xd3, 0xb2,
0x16, 0x2d, 0x5a, 0x38, 0xa3, 0x7c, 0xd6, 0xad, 0x50, 0xe5, 0x7b, 0x05,
0x00, 0x8e, 0x45, 0x46, 0x46, 0x4e, 0xf7, 0xf4, 0xf4, 0x6c, 0xd8, 0xb0,
0x61, 0xc3, 0x36, 0x09, 0x09, 0x09, 0xaf, 0x00, 0x20, 0x25, 0x25, 0x25,
0x07, 0x00, 0x04, 0x02, 0xc1, 0x2b, 0xb0, 0xb3, 0x9b, 0xec, 0x3b, 0x29,
0x61, 0x61, 0x61, 0x4f, 0x01, 0x34, 0xb0, 0xb6, 0xb6, 0x76, 0x66, 0xeb,
0x4c, 0xb5, 0x23, 0xd5, 0x9a, 0x3b, 0x77, 0xee, 0x02, 0xb1, 0x58, 0x4c,
0x0e, 0x1d, 0x3a, 0x74, 0x82, 0xfd, 0x4e, 0x85, 0x72, 0x74, 0x73, 0x73,
0xf3, 0xac, 0x5f, 0xbf, 0xbe, 0xe5, 0xae, 0x5d, 0xbb, 0x72, 0xa2, 0xa3,
0xa3, 0xa7, 0x00, 0x08, 0x01, 0x20, 0x78, 0xf4, 0xe8, 0xd1, 0xed, 0xe3,
0xc7, 0x8f, 0x1f, 0xf6, 0xf6, 0xf6, 0x6e, 0xdc, 0xba, 0x75, 0x6b, 0x8f,
0xf0, 0xf0, 0x70, 0xc5, 0x20, 0xad, 0x0c, 0xc0, 0xf9, 0xf7, 0xef, 0xdf,
0xbf, 0xdd, 0xb4, 0x69, 0x53, 0x37, 0x30, 0x1e, 0xdb, 0x93, 0x00, 0x84,
0x3a, 0x39, 0x39, 0x1d, 0x93, 0xc9, 0x64, 0x88, 0x8f, 0x8f, 0x7f, 0x8d,
0x6f, 0x3b, 0xcb, 0x55, 0x19, 0x12, 0x00, 0x77, 0xcb, 0xca, 0xca, 0x5e,
0xef, 0xd9, 0xb3, 0x67, 0xf0, 0xc1, 0x83, 0x07, 0x47, 0x4c, 0x9c, 0x38,
0xd1, 0x6e, 0xe9, 0xd2, 0xa5, 0x7d, 0xdf, 0xbc, 0x79, 0x33, 0xf2, 0xd2,
0xa5, 0x4b, 0xd7, 0x37, 0x6e, 0xdc, 0xb8, 0x21, 0x2c, 0x2c, 0xec, 0xb9,
0xa2, 0x3c, 0x8a, 0x8b, 0x8b, 0x9d, 0xd2, 0xd3, 0xd3, 0x95, 0xb7, 0x26,
0xa9, 0x42, 0x0b, 0x85, 0x42, 0x27, 0x30, 0xc6, 0x9b, 0x18, 0x60, 0x3c,
0x8f, 0x2e, 0x5b, 0xb6, 0x6c, 0xf9, 0xa0, 0x41, 0x83, 0xfa, 0x25, 0x26,
0x26, 0x16, 0xcf, 0x98, 0x31, 0x23, 0xeb, 0xf8, 0xf1, 0xe3, 0x09, 0x52,
0xa9, 0xf4, 0x1c, 0x80, 0x2b, 0x60, 0x66, 0xe8, 0x55, 0x77, 0x5f, 0xf0,
0x5b, 0xb7, 0x6e, 0xed, 0x55, 0x5a, 0x5a, 0x4a, 0xee, 0xdc, 0xb9, 0x73,
0x1a, 0x15, 0x0d, 0x73, 0x00, 0xa0, 0x12, 0x13, 0x13, 0x85, 0x6e, 0x6e,
0x6e, 0xd6, 0x00, 0x48, 0x50, 0x50, 0x50, 0x71, 0xf3, 0xe6, 0xcd, 0x0d,
0x00, 0xc0, 0xd9, 0xd9, 0xb9, 0x85, 0xb6, 0xb6, 0x36, 0xcf, 0xdc, 0xdc,
0x5c, 0x00, 0x00, 0x8e, 0x8e, 0x8e, 0x26, 0xa7, 0x4e, 0x9d, 0x7a, 0x05,
0x80, 0x6e, 0xdd, 0xba, 0x75, 0x7b, 0x3b, 0x3b, 0x3b, 0xe3, 0xf0, 0xf0,
0x70, 0x3a, 0x38, 0x38, 0xb8, 0x8c, 0x10, 0x42, 0xb3, 0x32, 0xc7, 0xeb,
0xd8, 0xb1, 0xa3, 0x76, 0xeb, 0xd6, 0xad, 0x4d, 0x5a, 0xb5, 0x6a, 0xd5,
0x8e, 0x9d, 0x75, 0x56, 0xe6, 0x05, 0x98, 0x5d, 0x03, 0x34, 0x9b, 0xf7,
0x93, 0xe7, 0xcf, 0x9f, 0x1f, 0xb5, 0x7b, 0xf7, 0xee, 0xdf, 0x5b, 0xb7,
0x6e, 0xdd, 0x58, 0x4f, 0x4f, 0xaf, 0x4e, 0x49, 0x49, 0x49, 0x41, 0x62,
0x62, 0x62, 0x2a, 0x00, 0x17, 0x37, 0x37, 0x37, 0xd7, 0x63, 0xc7, 0x8e,
0x7d, 0xd5, 0x6e, 0x95, 0x56, 0xad, 0x5a, 0xb5, 0x36, 0x30, 0x30, 0xe0,
0x87, 0x85, 0x85, 0x89, 0xc1, 0x28, 0x61, 0x55, 0xe5, 0x7a, 0x1d, 0xcc,
0xe4, 0x98, 0x32, 0x44, 0x4d, 0x59, 0x2a, 0xd8, 0x0c, 0xe0, 0x0c, 0x2a,
0xca, 0x16, 0x0d, 0xa6, 0x03, 0x91, 0x01, 0xa0, 0x93, 0x93, 0x93, 0xf3,
0x00, 0x58, 0x39, 0x3a, 0x3a, 0x3a, 0xbf, 0x78, 0xf1, 0x82, 0x07, 0x40,
0x2c, 0x91, 0x48, 0xce, 0x48, 0x24, 0x92, 0x3b, 0xc6, 0xc6, 0xc6, 0x1e,
0x00, 0x8e, 0x40, 0xfd, 0x2d, 0x07, 0x4f, 0xd8, 0xf2, 0x51, 0xc4, 0xcd,
0x07, 0x33, 0x18, 0xff, 0x5b, 0x8c, 0x73, 0x3e, 0x9f, 0xcf, 0x07, 0x00,
0x99, 0x4c, 0xa6, 0x56, 0xaf, 0x89, 0x44, 0x22, 0x99, 0x54, 0x2a, 0x9d,
0x2d, 0x95, 0x4a, 0xe9, 0x69, 0xd3, 0xa6, 0xb9, 0xde, 0xbd, 0x7b, 0xb7,
0xb9, 0xaf, 0xaf, 0xef, 0x31, 0x4f, 0x4f, 0xcf, 0x76, 0x84, 0x90, 0xaf,
0xea, 0x08, 0x28, 0x8a, 0xa2, 0xa5, 0x52, 0xe9, 0x9b, 0xf0, 0xf0, 0xf0,
0x32, 0x77, 0x77, 0x77, 0x0f, 0x63, 0x63, 0x63, 0x83, 0x67, 0xcf, 0x9e,
0x15, 0x83, 0x19, 0xfc, 0x55, 0xa5, 0x67, 0x4b, 0x33, 0x32, 0x32, 0x0e,
0x1d, 0x39, 0x72, 0x64, 0xec, 0x94, 0x29, 0x53, 0xfa, 0xaf, 0x5d, 0xbb,
0x76, 0x87, 0x4c, 0xf6, 0x49, 0x7d, 0x12, 0x99, 0x4c, 0x96, 0x9d, 0x9d,
0x9d, 0x4d, 0x5b, 0x5b, 0x5b, 0x6b, 0xe9, 0xea, 0xea, 0xea, 0x95, 0x96,
0x96, 0xe6, 0x2b, 0xbf, 0x2c, 0x10, 0x08, 0x34, 0x6d, 0x6c, 0x6c, 0xb4,
0x72, 0x72, 0x72, 0x68, 0x89, 0x44, 0x52, 0xc1, 0x38, 0x0c, 0x09, 0x09,
0x49, 0xdb, 0xb5, 0x6b, 0xd7, 0x01, 0x30, 0xfa, 0x2d, 0x03, 0x8c, 0x4e,
0x89, 0x07, 0x33, 0xf9, 0x22, 0x67, 0xcb, 0xaa, 0x46, 0xf1, 0xe7, 0xe7,
0xe7, 0xd3, 0x79, 0x79, 0x79, 0xa9, 0xca, 0xf1, 0x8b, 0x44, 0xa2, 0x8c,
0x8c, 0x8c, 0x8c, 0xe1, 0x00, 0x04, 0x0b, 0x17, 0x2e, 0x3c, 0x72, 0xf9,
0xf2, 0xe5, 0x26, 0x3e, 0x3e, 0x3e, 0xcb, 0xfb, 0xf7, 0xef, 0xef, 0xaf,
0x26, 0x9f, 0x8a, 0xd5, 0x8f, 0xf7, 0x60, 0x26, 0x07, 0x8e, 0x9d, 0x3b,
0x77, 0xae, 0x7f, 0xb3, 0x66, 0xcd, 0xb6, 0xac, 0x5a, 0xb5, 0xca, 0x64,
0xd0, 0xa0, 0x41, 0x53, 0x59, 0xdd, 0x5b, 0x5b, 0xe3, 0x92, 0xe4, 0xe6,
0xe6, 0x4a, 0x01, 0xc0, 0xdc, 0xdc, 0xdc, 0xec, 0xc3, 0x87, 0x0f, 0x71,
0xca, 0x3f, 0x5a, 0x58, 0x58, 0x98, 0x03, 0x40, 0x5e, 0x5e, 0x9e, 0x54,
0xa9, 0x1e, 0x68, 0x00, 0x69, 0xe7, 0xcf, 0x9f, 0x8f, 0xf3, 0xf0, 0xf0,
0x70, 0xf6, 0xf4, 0xf4, 0xec, 0xaf, 0xa9, 0xa9, 0xa9, 0x25, 0x10, 0x08,
0x78, 0x17, 0x2e, 0x5c, 0x88, 0x41, 0x45, 0x83, 0x58, 0x16, 0x1b, 0x1b,
0x9b, 0xdf, 0xb3, 0x67, 0x4f, 0x8b, 0xce, 0x9d, 0x3b, 0xf7, 0xd0, 0xd0,
0xd0, 0xe0, 0x05, 0x06, 0x06, 0xde, 0x28, 0x2d, 0x2d, 0x2d, 0x2a, 0x2b,
0x2b, 0x1b, 0xd4, 0xab, 0x57, 0xaf, 0x81, 0xf5, 0xea, 0xd5, 0x33, 0x4f,
0x4a, 0x4a, 0x2a, 0x81, 0x52, 0x1b, 0xe3, 0xf1, 0x78, 0xda, 0x3e, 0x3e,
0x3e, 0x7b, 0xb3, 0xb2, 0xb2, 0xe4, 0x1b, 0x36, 0x6c, 0x38, 0x51, 0xa7,
0x4e, 0x9d, 0xfa, 0x83, 0x06, 0x0d, 0xea, 0xe3, 0xe3, 0xe3, 0xf3, 0x47,
0x87, 0x0e, 0x1d, 0x5c, 0xd9, 0x5d, 0x5c, 0x9f, 0xc9, 0x42, 0x69, 0x69,
0xe9, 0xc9, 0xd2, 0xd2, 0xd2, 0x15, 0x32, 0x99, 0x8c, 0xc8, 0x64, 0xb2,
0xbf, 0x50, 0xc9, 0xca, 0x81, 0x8e, 0x8e, 0x8e, 0xd1, 0x89, 0x13, 0x27,
0x4e, 0x14, 0x16, 0x16, 0x92, 0xc9, 0x93, 0x27, 0xdf, 0x06, 0x70, 0x1e,
0xb5, 0x9b, 0xa4, 0xad, 0x29, 0xa5, 0x51, 0x51, 0x51, 0xfb, 0xef, 0xdf,
0xbf, 0x3f, 0x78, 0xd2, 0xa4, 0x49, 0x43, 0x56, 0xac, 0x58, 0x61, 0x21,
0x14, 0x0a, 0x33, 0xbf, 0x22, 0x3e, 0x6a, 0xdd, 0xba, 0x75, 0xfe, 0x00,
0x1e, 0x03, 0x88, 0x46, 0x45, 0xbd, 0x23, 0x05, 0xf0, 0x78, 0xf9, 0xf2,
0xe5, 0xdb, 0xc1, 0xe8, 0xb0, 0x7f, 0x64, 0x5b, 0xa3, 0xa7, 0xa7, 0x67,
0xdf, 0xd3, 0xa7, 0x4f, 0x9f, 0x88, 0x8e, 0x8e, 0x16, 0xb5, 0x6f, 0xdf,
0xfe, 0xc3, 0xf3, 0xe7, 0xcf, 0xf3, 0xd9, 0xef, 0x8b, 0xef, 0xdd, 0xbb,
0x67, 0xe9, 0xe9, 0xe9, 0xc9, 0x67, 0x8f, 0xa1, 0x54, 0xc0, 0xc8, 0xc8,
0x08, 0xa8, 0xa8, 0x7f, 0x89, 0x91, 0x91, 0x91, 0x1c, 0x00, 0x72, 0x72,
0x72, 0x08, 0x9b, 0x7e, 0x7e, 0x4e, 0x4e, 0x8e, 0x06, 0x00, 0x98, 0x9a,
0x9a, 0xca, 0x51, 0x7d, 0x1f, 0xce, 0xcb, 0xcb, 0x63, 0x16, 0x52, 0x0d,
0x0c, 0x0c, 0x54, 0x77, 0x3e, 0xd2, 0xda, 0xda, 0xda, 0xaa, 0x93, 0x15,
0xfc, 0xec, 0xec, 0x6c, 0x0a, 0x00, 0x3a, 0x77, 0xee, 0x9c, 0xc3, 0x1e,
0xdb, 0x52, 0x7e, 0x47, 0x03, 0x8c, 0x5e, 0xf6, 0xc7, 0x97, 0x8f, 0xf7,
0x84, 0x53, 0xa6, 0x4c, 0x39, 0xa3, 0xa3, 0xa3, 0x33, 0x71, 0xf9, 0xf2,
0xe5, 0x73, 0x96, 0x2f, 0x5f, 0x3e, 0x07, 0x00, 0x62, 0x63, 0x63, 0x4b,
0x87, 0x0e, 0x1d, 0x9a, 0x1e, 0x12, 0x12, 0x72, 0x02, 0x6a, 0x26, 0x51,
0xe4, 0x72, 0x79, 0x21, 0x3e, 0xef, 0x9f, 0x14, 0xff, 0xfe, 0x47, 0x0d,
0x73, 0x00, 0x94, 0xad, 0xad, 0xad, 0xd6, 0xaa, 0x55, 0xab, 0x0a, 0x8c,
0x8d, 0x8d, 0xe9, 0x25, 0x4b, 0x96, 0xd4, 0xf9, 0xfd, 0xf7, 0xdf, 0x57,
0xff, 0xf4, 0xd3, 0x4f, 0x13, 0xbf, 0x45, 0xe4, 0x72, 0xb9, 0x5c, 0xa1,
0x5f, 0x94, 0x75, 0x8c, 0x6a, 0x79, 0x53, 0x2a, 0xef, 0xd4, 0xa4, 0x7c,
0x78, 0x59, 0x59, 0x59, 0xb4, 0x93, 0x93, 0x13, 0x0c, 0x0c, 0x0c, 0xa4,
0xc5, 0xc5, 0xc5, 0xca, 0xe1, 0x69, 0x23, 0x23, 0x23, 0x09, 0x45, 0x51,
0x8a, 0x9d, 0x98, 0x15, 0xda, 0x8b, 0x99, 0x99, 0x19, 0x85, 0xea, 0xe5,
0x13, 0xb5, 0x94, 0x37, 0x55, 0xd4, 0xe5, 0x41, 0x15, 0x09, 0x80, 0x7b,
0x51, 0x51, 0x51, 0x13, 0x87, 0x0f, 0x1f, 0x3e, 0xa9, 0x7e, 0xfd, 0xfa,
0x9e, 0xd3, 0xa7, 0x4f, 0x37, 0x9e, 0x39, 0x73, 0x66, 0xd3, 0xcb, 0x97,
0x2f, 0x5f, 0x98, 0x32, 0x65, 0xca, 0xec, 0xc3, 0x87, 0x0f, 0xef, 0xc5,
0xdf, 0xb0, 0x4b, 0xc6, 0xc4, 0xc4, 0x44, 0xdd, 0xb9, 0xe7, 0xb2, 0x67,
0xcf, 0x9e, 0x1d, 0x8a, 0x8e, 0x8e, 0x1e, 0x34, 0x7a, 0xf4, 0xe8, 0x7e,
0x8b, 0x16, 0x2d, 0xd2, 0xe3, 0xf1, 0x78, 0xfc, 0xd1, 0xa3, 0x47, 0xf7,
0x8e, 0x8c, 0x8c, 0x94, 0x86, 0x87, 0x87, 0x1f, 0x06, 0xbb, 0x73, 0x4a,
0x26, 0x93, 0xc5, 0xbe, 0x7c, 0xf9, 0xb2, 0xac, 0x69, 0xd3, 0xa6, 0xcd,
0xdc, 0xdd, 0xdd, 0x7b, 0x49, 0x24, 0x12, 0x12, 0x16, 0x16, 0xe6, 0xaf,
0xa9, 0xa9, 0xa9, 0x43, 0xd3, 0xf4, 0xf7, 0x6d, 0xda, 0xb4, 0xe9, 0xee,
0xec, 0xec, 0xec, 0xfc, 0xf2, 0xe5, 0x4b, 0x91, 0x5c, 0x2e, 0x8f, 0x43,
0x79, 0xff, 0x45, 0x78, 0x3c, 0x5e, 0xc1, 0xd6, 0xad, 0x5b, 0xcd, 0x25,
0x12, 0x09, 0x28, 0x8a, 0xc2, 0xd6, 0xad, 0x5b, 0x2d, 0xbc, 0xbc, 0xbc,
0xf2, 0xd4, 0xe8, 0x92, 0xb2, 0xdc, 0xdc, 0xdc, 0xb3, 0xe7, 0xce, 0x9d,
0x9b, 0x37, 0x7e, 0xfc, 0x78, 0x67, 0x3b, 0x3b, 0xbb, 0xe6, 0x29, 0x29,
0x29, 0x89, 0xa3, 0x47, 0x8f, 0xee, 0x1d, 0x16, 0x16, 0x26, 0x89, 0x8c,
0x8c, 0x3c, 0x82, 0xcf, 0x77, 0xb4, 0x00, 0x00, 0xef, 0xc0, 0x81, 0x03,
0xc7, 0x9d, 0x9d, 0x9d, 0x1b, 0x7b, 0x7a, 0x7a, 0x46, 0xa7, 0xa7, 0xa7,
0x2f, 0x05, 0x90, 0xae, 0xa6, 0x1c, 0x75, 0x26, 0x4d, 0x9a, 0x14, 0xdf,
0xa8, 0x51, 0x23, 0xa3, 0xa1, 0x43, 0x87, 0xea, 0xef, 0xd9, 0xb3, 0xc7,
0xac, 0x57, 0xaf, 0x5e, 0xae, 0x83, 0x07, 0x0f, 0x16, 0xe2, 0xdb, 0x23,
0xbc, 0x72, 0xe5, 0x8a, 0xeb, 0xc0, 0x81, 0x03, 0x4d, 0x4f, 0x9c, 0x38,
0x21, 0xba, 0x78, 0xf1, 0xa2, 0x30, 0x21, 0x21, 0x41, 0xe1, 0x78, 0x55,
0x02, 0x40, 0x2c, 0x14, 0x0a, 0x8f, 0xa3, 0x7c, 0x27, 0x2d, 0x0f, 0x8c,
0x9f, 0x0f, 0xad, 0xd4, 0xd4, 0x54, 0xab, 0xd4, 0xd4, 0x54, 0x5d, 0x00,
0xc9, 0x60, 0xc6, 0xb6, 0xdf, 0x72, 0xa2, 0xb9, 0x4a, 0xbe, 0xb6, 0xa3,
0xe1, 0x4d, 0x9a, 0x34, 0xe9, 0x27, 0x7d, 0x7d, 0x7d, 0xc1, 0xee, 0xdd,
0xbb, 0xc3, 0xc1, 0x6c, 0x3f, 0x51, 0x97, 0x78, 0xfa, 0xe9, 0xd3, 0xa7,
0x21, 0x72, 0xb9, 0x1c, 0x1e, 0x1e, 0x1e, 0xae, 0x2a, 0xdf, 0xe5, 0x7b,
0x78, 0x78, 0xb4, 0xa0, 0x69, 0x1a, 0xa1, 0xa1, 0xa1, 0xca, 0x2b, 0x5a,
0xb5, 0x86, 0xa2, 0x28, 0xde, 0x91, 0x23, 0x47, 0x4e, 0xf7, 0xef, 0xdf,
0xdf, 0xd3, 0xdb, 0xdb, 0x3b, 0xe7, 0xf4, 0xe9, 0xd3, 0x2b, 0xc1, 0x6c,
0x6d, 0xae, 0x6a, 0x1b, 0x82, 0x0c, 0x4c, 0xa5, 0x88, 0xc0, 0x34, 0xea,
0x68, 0x81, 0x40, 0x90, 0x0b, 0x00, 0x65, 0x65, 0x65, 0x16, 0x60, 0x1c,
0x8f, 0xd4, 0x0b, 0x09, 0x09, 0x91, 0xa6, 0xa7, 0xa7, 0xa3, 0xac, 0xac,
0xcc, 0x4a, 0x2c, 0x16, 0xdb, 0x8a, 0xc5, 0x62, 0xdb, 0xb2, 0xb2, 0x32,
0x1b, 0x9a, 0xa6, 0x29, 0x42, 0x08, 0xca, 0xca, 0xca, 0x6c, 0x24, 0x12,
0x89, 0x0d, 0xaa, 0x3e, 0x03, 0x41, 0x00, 0x94, 0x58, 0x59, 0x59, 0x49,
0x01, 0x20, 0x3e, 0x3e, 0xbe, 0x8c, 0x2d, 0x0b, 0xf9, 0xfb, 0xf7, 0xef,
0xdf, 0x02, 0xc0, 0x80, 0x01, 0x03, 0x9a, 0x43, 0x65, 0x70, 0xd0, 0xa5,
0x4b, 0x17, 0x03, 0x00, 0x48, 0x4a, 0x4a, 0x12, 0xab, 0xab, 0xb3, 0x76,
0xed, 0xda, 0x79, 0xb4, 0x6b, 0xd7, 0xce, 0xee, 0xdc, 0xb9, 0x73, 0xc2,
0x9c, 0x9c, 0x9c, 0xd3, 0xf8, 0xbc, 0xd1, 0x68, 0xb4, 0x6d, 0xdb, 0xb6,
0x3f, 0x00, 0x84, 0x85, 0x85, 0x85, 0x01, 0x08, 0x03, 0x63, 0xe8, 0xe4,
0x01, 0x08, 0x0a, 0x0d, 0x0d, 0x0d, 0x07, 0x80, 0xf6, 0xed, 0xdb, 0x0f,
0x40, 0xf9, 0x84, 0x8d, 0x62, 0x9b, 0x4a, 0x18, 0x00, 0x1f, 0x30, 0x8e,
0x51, 0x0e, 0x36, 0x68, 0xd0, 0xa0, 0xf4, 0xbb, 0xef, 0xbe, 0xb3, 0xbf,
0x70, 0xe1, 0x82, 0x30, 0x37, 0x37, 0xf7, 0xcd, 0xd7, 0xd4, 0x57, 0x2d,
0x11, 0x83, 0x31, 0x2a, 0x0e, 0x49, 0x24, 0x92, 0xb1, 0x87, 0x0e, 0x1d,
0xda, 0xd0, 0xb8, 0x71, 0xe3, 0x88, 0xc9, 0x93, 0x27, 0x67, 0xb9, 0xb8,
0xb8, 0x78, 0x84, 0x86, 0x86, 0x3e, 0x9b, 0x35, 0x6b, 0x96, 0xc2, 0x83,
0x2d, 0x39, 0x7d, 0xfa, 0x74, 0xe0, 0xd0, 0xa1, 0x43, 0x6f, 0x0e, 0x1d,
0x3a, 0x34, 0xa0, 0x92, 0xe7, 0xe6, 0xb9, 0x73, 0xe7, 0xee, 0x2b, 0x44,
0x67, 0xee, 0xdc, 0xb9, 0x8b, 0x5f, 0xbc, 0x78, 0x11, 0xdc, 0xac, 0x59,
0xb3, 0xce, 0x13, 0x27, 0x4e, 0xcc, 0x6c, 0xd2, 0xa4, 0xc9, 0x2b, 0x5f,
0x5f, 0xdf, 0x75, 0x52, 0xa9, 0x74, 0x0c, 0x00, 0x5f, 0x30, 0x33, 0x7a,
0xea, 0x3a, 0x05, 0xfe, 0xa1, 0x43, 0x87, 0x22, 0xf4, 0xf4, 0xf4, 0x9e,
0xbf, 0x79, 0xf3, 0xe6, 0x3c, 0x98, 0xc1, 0xbe, 0xb2, 0x22, 0x92, 0x27,
0x27, 0x27, 0xa7, 0xd7, 0xab, 0x57, 0x4f, 0x8f, 0xcf, 0xe7, 0x23, 0x30,
0x30, 0x30, 0xba, 0x63, 0xc7, 0x8e, 0x96, 0x27, 0x4f, 0x9e, 0x3c, 0x7e,
0xed, 0xda, 0xb5, 0x33, 0x5b, 0xb6, 0x6c, 0x29, 0x72, 0x72, 0x72, 0x32,
0xf2, 0xf5, 0xf5, 0xdd, 0x65, 0x6c, 0x6c, 0xac, 0x75, 0xf3, 0xe6, 0xcd,
0x9b, 0x00, 0x30, 0x7c, 0xf8, 0xf0, 0x49, 0x00, 0xb0, 0x66, 0xcd, 0x9a,
0x98, 0xd9, 0xb3, 0x67, 0x1f, 0x9d, 0x33, 0x67, 0xce, 0xe1, 0x39, 0x73,
0xe6, 0x1c, 0x9e, 0x3d, 0x7b, 0xf6, 0xd1, 0x35, 0x6b, 0xd6, 0xc4, 0xb0,
0x61, 0x26, 0xe3, 0xf3, 0x09, 0x36, 0xc5, 0x16, 0x41, 0x85, 0x4c, 0xe7,
0x98, 0x99, 0x99, 0x85, 0x1a, 0x1a, 0x1a, 0x52, 0x62, 0xb1, 0x98, 0x88,
0xc5, 0x62, 0x01, 0x00, 0xfa, 0xda, 0xb5, 0x6b, 0x41, 0x22, 0x91, 0x88,
0x4c, 0x9a, 0x34, 0xa9, 0x73, 0x9d, 0x3a, 0x75, 0xea, 0x7e, 0x45, 0xbd,
0x08, 0xb6, 0x6c, 0xd9, 0xf2, 0x1b, 0x00, 0xec, 0xda, 0xb5, 0x2b, 0x16,
0xea, 0x67, 0x16, 0x15, 0xe9, 0x51, 0x7e, 0x24, 0x55, 0xc4, 0x29, 0x04,
0x90, 0x03, 0x66, 0x3b, 0xac, 0xe2, 0xc9, 0x55, 0x7a, 0x47, 0x7e, 0xf9,
0xf2, 0xe5, 0x50, 0x00, 0xf8, 0xe1, 0x87, 0x1f, 0x86, 0x80, 0x31, 0xb0,
0x15, 0x93, 0x61, 0x29, 0x60, 0x56, 0x44, 0x2b, 0x43, 0xb1, 0xc5, 0x4b,
0xf9, 0xf9, 0xbb, 0x66, 0x43, 0xa9, 0x26, 0x4d, 0x9a, 0xd4, 0x03, 0x80,
0x98, 0x98, 0x98, 0xca, 0xb6, 0xf6, 0x12, 0x36, 0xaf, 0x29, 0x81, 0x81,
0x81, 0x2b, 0x8f, 0x1c, 0x39, 0x52, 0xe2, 0xe1, 0xe1, 0xd1, 0x6a, 0xc6,
0x8c, 0x19, 0xf3, 0xf1, 0x6d, 0x06, 0x8b, 0xc2, 0x67, 0xcf, 0x9e, 0x65,
0xb8, 0xbb, 0xbb, 0x3b, 0xb5, 0x6d, 0xdb, 0xb6, 0xe9, 0xd3, 0xa7, 0x4f,
0x55, 0x57, 0xd6, 0xd4, 0x21, 0x07, 0x90, 0xb0, 0x75, 0xeb, 0xd6, 0xcb,
0x14, 0x45, 0x51, 0x3f, 0xff, 0xfc, 0xf3, 0xfc, 0x92, 0x92, 0x12, 0x45,
0x3b, 0x27, 0x00, 0xc4, 0x41, 0x41, 0x41, 0xc5, 0x5a, 0x5a, 0x5a, 0xd4,
0x77, 0xdf, 0x7d, 0x37, 0x58, 0x25, 0x9d, 0x54, 0x8f, 0x1e, 0x3d, 0x7a,
0xeb, 0xeb, 0xeb, 0xf3, 0x6f, 0xdd, 0xba, 0x55, 0x04, 0x46, 0x17, 0x29,
0xe7, 0x3b, 0x0b, 0xc0, 0x21, 0x30, 0x6d, 0xea, 0x2a, 0x80, 0x97, 0x60,
0x66, 0xe0, 0x95, 0x75, 0x5e, 0x8d, 0xe2, 0xbf, 0x7b, 0xf7, 0x6e, 0x09,
0x4d, 0xd3, 0x15, 0x66, 0xe4, 0xd9, 0x09, 0x8d, 0x18, 0x00, 0xe1, 0x57,
0xae, 0x5c, 0x59, 0x1b, 0x10, 0x10, 0x20, 0xee, 0xd7, 0xaf, 0x5f, 0x87,
0xc1, 0x83, 0x07, 0x8f, 0xad, 0x22, 0xbf, 0x34, 0x18, 0x23, 0x32, 0x13,
0x80, 0x5f, 0x40, 0x40, 0xc0, 0x55, 0x00, 0xd0, 0xd1, 0xd1, 0xb1, 0xc3,
0x97, 0x79, 0xe9, 0x26, 0x89, 0x89, 0x89, 0x05, 0x00, 0xd0, 0xac, 0x59,
0xb3, 0x96, 0xa8, 0xa8, 0xb3, 0x79, 0xce, 0xce, 0xce, 0x6e, 0x00, 0x10,
0x1f, 0x1f, 0x5f, 0xa0, 0x52, 0x36, 0xa2, 0x4b, 0x97, 0x2e, 0x9d, 0xa7,
0x69, 0x1a, 0x3d, 0x7b, 0xf6, 0x1c, 0xd6, 0xab, 0x57, 0xaf, 0x61, 0x72,
0xb9, 0x1c, 0x7e, 0x7e, 0x7e, 0x8a, 0x2d, 0xed, 0x9f, 0xea, 0x27, 0x21,
0x21, 0x21, 0xd3, 0xd2, 0xd2, 0x52, 0xab, 0x63, 0xc7, 0x8e, 0x5e, 0x2f,
0x5f, 0xbe, 0x2c, 0xcb, 0xcd, 0xcd, 0xbd, 0x2b, 0x12, 0x89, 0x1e, 0xde,
0xbf, 0x7f, 0x5f, 0xd8, 0xa3, 0x47, 0x8f, 0xbe, 0x36, 0x36, 0x36, 0xc6,
0x89, 0x89, 0x89, 0xf9, 0x50, 0x1a, 0x58, 0x4f, 0x9b, 0x36, 0x6d, 0x6e,
0xeb, 0xd6, 0xad, 0xed, 0x97, 0x2d, 0x5b, 0xf6, 0xa1, 0xb8, 0xb8, 0x78,
0x77, 0x7c, 0x7c, 0xfc, 0x7a, 0x1f, 0x1f, 0x9f, 0xc2, 0x76, 0xed, 0xda,
0x35, 0x9d, 0x3c, 0x79, 0xb2, 0x37, 0xd4, 0xcb, 0x1b, 0x8d, 0xf2, 0xc9,
0x5e, 0x45, 0x9f, 0xa0, 0x4e, 0x8e, 0x79, 0x9b, 0x37, 0x6f, 0xde, 0xe5,
0xe8, 0xe8, 0x58, 0x6f, 0xc6, 0x8c, 0x19, 0x1f, 0xb2, 0xb2, 0xb2, 0xd6,
0x42, 0xfd, 0x6e, 0xb5, 0x6f, 0x81, 0x0c, 0xc0, 0x6b, 0x1f, 0x1f, 0x9f,
0x48, 0x43, 0x43, 0x43, 0xcd, 0x89, 0x13, 0x27, 0x4e, 0xc7, 0xd7, 0x8d,
0x65, 0xca, 0x00, 0x9c, 0x00, 0xb0, 0x0f, 0xe5, 0x93, 0xe2, 0xca, 0x14,
0x81, 0x71, 0x70, 0xf4, 0x27, 0xd4, 0x0f, 0x48, 0xbf, 0x35, 0x9a, 0x43,
0x86, 0x0c, 0x99, 0xc1, 0xe3, 0xf1, 0xa8, 0x05, 0x0b, 0x16, 0xc4, 0x3f,
0x7f, 0xfe, 0x7c, 0x26, 0x98, 0x7b, 0xe4, 0x87, 0x03, 0x98, 0xd9, 0xa0,
0x41, 0x03, 0x39, 0xa0, 0x7e, 0x07, 0x46, 0xc3, 0x86, 0x0d, 0xad, 0x55,
0xca, 0x82, 0x6a, 0xdc, 0xb8, 0xb1, 0x3d, 0x00, 0xa4, 0xa4, 0xa4, 0x28,
0xea, 0x83, 0x8e, 0x8d, 0x8d, 0x7d, 0x0f, 0x00, 0xad, 0x5b, 0xb7, 0xae,
0xc9, 0xce, 0x29, 0x92, 0x94, 0x94, 0x94, 0x03, 0x00, 0x0e, 0x0e, 0x0e,
0x8d, 0x54, 0xc2, 0x53, 0xec, 0x0a, 0xa9, 0x32, 0xf4, 0xbb, 0x77, 0xef,
0x32, 0x01, 0xa0, 0x55, 0xab, 0x56, 0x57, 0x01, 0x74, 0x05, 0xd0, 0x51,
0xe9, 0x69, 0x0b, 0xc0, 0x0d, 0xcc, 0x4d, 0x3c, 0x5f, 0x3a, 0x18, 0x2f,
0x69, 0xd8, 0xb0, 0xe1, 0xd9, 0xce, 0x9d, 0x3b, 0x53, 0x2b, 0x57, 0xae,
0x2c, 0x72, 0x70, 0x70, 0x48, 0x31, 0x32, 0x32, 0x8a, 0x6f, 0xd2, 0xa4,
0xc9, 0x8b, 0x6b, 0xd7, 0xae, 0x2d, 0x04, 0xf0, 0x0c, 0xea, 0xf5, 0xba,
0x3a, 0x03, 0xf5, 0x3f, 0x46, 0x4a, 0x4a, 0x0a, 0xbd, 0x79, 0xf3, 0xe6,
0x3f, 0x96, 0x2e, 0x5d, 0xba, 0xdf, 0xcf, 0xcf, 0xaf, 0x74, 0xe6, 0xcc,
0x99, 0xe3, 0xbd, 0xbd, 0xbd, 0x17, 0xe3, 0xdb, 0xe8, 0xfe, 0x2f, 0xc9,
0x67, 0x4d, 0xca, 0x87, 0xc4, 0xc4, 0xc4, 0x14, 0x00, 0x80, 0x93, 0x93,
0x93, 0xea, 0x19, 0x7c, 0x1e, 0xfb, 0x37, 0xc4, 0xc6, 0xc6, 0x16, 0xa8,
0xc6, 0xd5, 0xb0, 0x61, 0xc3, 0xba, 0xa8, 0x5e, 0x3e, 0x6b, 0x2b, 0x6f,
0xea, 0xf2, 0x50, 0x13, 0x44, 0x60, 0x26, 0xeb, 0xe7, 0xa5, 0xa4, 0xa4,
0x0c, 0x5d, 0xbe, 0x7c, 0xb9, 0x8f, 0x8b, 0x8b, 0x4b, 0x62, 0x69, 0x69,
0x29, 0xf9, 0xe9, 0xa7, 0x9f, 0x16, 0xe3, 0x73, 0x3f, 0x01, 0xe5, 0x99,
0xe4, 0xf1, 0xaa, 0xac, 0x1f, 0x91, 0x48, 0x24, 0x05, 0x00, 0x1b, 0x1b,
0x1b, 0x55, 0x3f, 0x1a, 0x3c, 0xb6, 0x0c, 0x54, 0x91, 0x02, 0x78, 0x79,
0xec, 0xd8, 0xb1, 0x54, 0x2b, 0x2b, 0x2b, 0xdd, 0x1e, 0x3d, 0x7a, 0xf4,
0xf7, 0xf4, 0xf4, 0xec, 0x63, 0x66, 0x66, 0xa6, 0x7d, 0xec, 0xd8, 0xb1,
0x14, 0x30, 0x0b, 0x76, 0x8a, 0xc9, 0x16, 0x51, 0x58, 0x58, 0x58, 0x66,
0xe3, 0xc6, 0x8d, 0x6d, 0x5a, 0xb6, 0x6c, 0xd9, 0x29, 0x3c, 0x3c, 0xbc,
0xac, 0xac, 0xac, 0x2c, 0xac, 0xa8, 0xa8, 0xe8, 0x59, 0x74, 0x74, 0xb4,
0xb8, 0x65, 0xcb, 0x96, 0x9d, 0x9a, 0x35, 0x6b, 0x66, 0x1b, 0x12, 0x12,
0x92, 0x89, 0x8a, 0xfa, 0x8a, 0x5a, 0xbe, 0x7c, 0xf9, 0x1a, 0x4f, 0x4f,
0x4f, 0xe7, 0x65, 0xcb, 0x96, 0x95, 0xac, 0x58, 0xb1, 0xa2, 0xa4, 0x57,
0xaf, 0x5e, 0x2d, 0x16, 0x2f, 0x5e, 0xfc, 0x2b, 0x3e, 0x97, 0x37, 0x1a,
0x40, 0xfa, 0xbe, 0x7d, 0xfb, 0xee, 0x53, 0x14, 0x85, 0xf1, 0xe3, 0xc7,
0xcf, 0xf0, 0xf0, 0xf0, 0xe8, 0x63, 0x66, 0x66, 0xa6, 0x7d, 0xe4, 0xc8,
0x91, 0x04, 0x30, 0x47, 0x13, 0x54, 0x6d, 0x3d, 0xca, 0xdb, 0xdb, 0x7b,
0xf1, 0xf8, 0xf1, 0xe3, 0x87, 0xcc, 0x9b, 0x37, 0x2f, 0xeb, 0xc9, 0x93,
0x27, 0xbf, 0xa0, 0x72, 0x9b, 0xb0, 0x34, 0x32, 0x32, 0xf2, 0xd7, 0x2b,
0x57, 0xae, 0xcc, 0x9f, 0x38, 0x71, 0xe2, 0xe9, 0xf3, 0xe7, 0xcf, 0x97,
0x0c, 0x1a, 0x34, 0xa8, 0x67, 0xc3, 0x86, 0x0d, 0x9d, 0x6b, 0x58, 0x77,
0x35, 0xc6, 0xce, 0xce, 0xce, 0x75, 0xe0, 0xc0, 0x81, 0x3d, 0x2e, 0x5c,
0xb8, 0x50, 0x32, 0x71, 0xe2, 0xc4, 0xd3, 0x57, 0xae, 0x5c, 0x99, 0x1f,
0x15, 0x15, 0xf5, 0x2b, 0xca, 0x27, 0x8e, 0x69, 0x30, 0x63, 0x90, 0x12,
0x94, 0x8f, 0x0f, 0x8b, 0xc1, 0x8c, 0xcb, 0xde, 0x82, 0xb1, 0x81, 0xb2,
0xf0, 0x0f, 0xae, 0x9a, 0x57, 0x8a, 0x8d, 0x8d, 0x4d, 0xbd, 0x07, 0x0f,
0x1e, 0x3c, 0x79, 0xf0, 0xe0, 0xc1, 0x13, 0x1b, 0x1b, 0x9b, 0x7a, 0x95,
0x85, 0xe3, 0xf1, 0x78, 0xfa, 0x55, 0x5c, 0x9f, 0x56, 0x21, 0x28, 0x00,
0xe7, 0x9b, 0x37, 0x6f, 0x96, 0x16, 0x17, 0x17, 0x4b, 0xed, 0xec, 0xec,
0x5a, 0x29, 0x7e, 0x68, 0xdc, 0xb8, 0x71, 0x1b, 0xa1, 0x50, 0x28, 0x0d,
0x08, 0x08, 0x28, 0x05, 0xe3, 0x58, 0x42, 0x9d, 0x13, 0x8c, 0x9a, 0x38,
0x84, 0xa3, 0x76, 0xee, 0xdc, 0x79, 0x90, 0x10, 0x42, 0x7e, 0xf9, 0xe5,
0x97, 0x5c, 0x00, 0xf3, 0xc0, 0x18, 0xca, 0x6a, 0x1b, 0x91, 0xa9, 0xa9,
0xa9, 0x5a, 0xc7, 0x4e, 0x36, 0x36, 0x36, 0x8e, 0x39, 0x39, 0x39, 0x65,
0x42, 0xa1, 0x90, 0xd6, 0xd4, 0xd4, 0xf4, 0x04, 0xe3, 0x9c, 0x61, 0x30,
0xca, 0xcf, 0x30, 0x07, 0x28, 0x3d, 0xf7, 0x43, 0x43, 0x43, 0x65, 0x1f,
0x3f, 0x7e, 0xa4, 0x01, 0x04, 0x01, 0xb8, 0x00, 0xd6, 0xb9, 0x8e, 0x91,
0x91, 0x91, 0xb1, 0x62, 0xd5, 0x4c, 0x99, 0x86, 0x0d, 0x1b, 0xb6, 0x10,
0x0a, 0x85, 0xd2, 0xc4, 0xc4, 0x44, 0x29, 0xca, 0x3d, 0xde, 0xf2, 0x01,
0xb8, 0xdf, 0xb9, 0x73, 0x47, 0x24, 0x16, 0x8b, 0xe5, 0xf5, 0xea, 0xd5,
0xfb, 0x24, 0xa0, 0x14, 0x45, 0x19, 0x44, 0x45, 0x45, 0x7d, 0x94, 0x4a,
0xa5, 0xa4, 0x61, 0xc3, 0x86, 0xf3, 0xd4, 0x94, 0xb1, 0xe0, 0xf4, 0xe9,
0xd3, 0xf7, 0x09, 0x21, 0xc4, 0xcd, 0xcd, 0xed, 0x12, 0xd4, 0x4f, 0x0e,
0x68, 0xf7, 0xe8, 0xd1, 0x63, 0x17, 0x21, 0x84, 0x5c, 0xb9, 0x72, 0x25,
0x52, 0xa5, 0xfc, 0x74, 0x82, 0x82, 0x82, 0xe2, 0x08, 0x21, 0xa4, 0x4b,
0x97, 0x2e, 0x5b, 0x51, 0x85, 0x73, 0x30, 0x7d, 0x7d, 0x7d, 0xe3, 0xeb,
0xd7, 0xaf, 0x3f, 0x66, 0x1d, 0x92, 0x5d, 0x45, 0x15, 0x13, 0x11, 0x9e,
0x9e, 0x9e, 0xbd, 0xd4, 0x78, 0xe4, 0x56, 0x8b, 0x86, 0x86, 0x86, 0x60,
0xd8, 0xb0, 0x61, 0xa3, 0x86, 0x0c, 0x19, 0x32, 0x82, 0xa2, 0xa8, 0x9a,
0x0c, 0xb2, 0x28, 0x36, 0x0f, 0x75, 0x01, 0x4c, 0xe3, 0xf3, 0xf9, 0x41,
0x63, 0xc7, 0x8e, 0x4d, 0x19, 0x37, 0x6e, 0xdc, 0x21, 0x94, 0x6f, 0xbd,
0xd2, 0x02, 0xe3, 0xe0, 0xc3, 0xa8, 0x92, 0xc7, 0x10, 0xe5, 0x5b, 0xba,
0xb4, 0x27, 0x4c, 0x98, 0x70, 0x64, 0xd4, 0xa8, 0x51, 0x29, 0x3c, 0x1e,
0xef, 0x1e, 0x80, 0xa9, 0x60, 0x1c, 0x82, 0xe8, 0xa0, 0xfa, 0x4e, 0x92,
0xaa, 0x5b, 0xb7, 0x6e, 0xe3, 0xd1, 0xa3, 0x47, 0xcf, 0x30, 0x34, 0x34,
0x54, 0x77, 0x55, 0x84, 0xb6, 0xab, 0xab, 0xeb, 0x3a, 0x42, 0x08, 0x19,
0x35, 0x6a, 0xd4, 0x5c, 0x1e, 0x8f, 0x37, 0x73, 0xfd, 0xfa, 0xf5, 0xf9,
0x4f, 0x9e, 0x3c, 0xf9, 0xb8, 0x7a, 0xf5, 0xea, 0x64, 0x8a, 0xa2, 0xfe,
0x98, 0x36, 0x6d, 0xda, 0x87, 0xc0, 0xc0, 0xc0, 0xf4, 0xde, 0xbd, 0x7b,
0x47, 0x03, 0x68, 0x02, 0xc0, 0x20, 0x26, 0x26, 0x26, 0xb7, 0xb8, 0xb8,
0x98, 0xd6, 0xd2, 0xd2, 0xfa, 0x01, 0x8c, 0x23, 0x14, 0x7d, 0xf6, 0x31,
0xd5, 0xd2, 0xd2, 0xfa, 0x41, 0x28, 0x14, 0xd2, 0x31, 0x31, 0x31, 0xb9,
0x60, 0x9c, 0x70, 0x54, 0xea, 0xb0, 0x8d, 0xcf, 0xe7, 0x6b, 0x6e, 0xdc,
0xb8, 0xf1, 0x30, 0x21, 0x84, 0x3c, 0x7a, 0xf4, 0xa8, 0x0c, 0xe5, 0x77,
0xd6, 0x3b, 0x6f, 0xd9, 0xb2, 0x25, 0x9f, 0x10, 0x42, 0x82, 0x82, 0x82,
0x42, 0x2d, 0x2d, 0x2d, 0xab, 0x32, 0xd0, 0xd5, 0xc6, 0x5f, 0xa7, 0x4e,
0x1d, 0xeb, 0x73, 0xe7, 0xce, 0x5d, 0x65, 0x9d, 0x5b, 0x49, 0x28, 0x8a,
0x9a, 0xaa, 0x24, 0x3f, 0x7f, 0xe7, 0x55, 0x6a, 0x02, 0x00, 0x5e, 0x8f,
0x1e, 0x3d, 0x12, 0x13, 0x42, 0xc8, 0xf4, 0xe9, 0xd3, 0x95, 0xaf, 0x61,
0xe1, 0x37, 0x68, 0xd0, 0xa0, 0x8f, 0x8a, 0x83, 0xb7, 0xff, 0xc8, 0x55,
0x6a, 0x56, 0x56, 0x56, 0x76, 0x09, 0x09, 0x09, 0xb9, 0x32, 0x99, 0x8c,
0x34, 0x6b, 0xd6, 0x6c, 0x35, 0x2a, 0xb6, 0x2d, 0xd5, 0x7b, 0xce, 0x01,
0xc0, 0xd4, 0xc4, 0xc4, 0xe4, 0x70, 0x46, 0x46, 0x86, 0xac, 0xa8, 0xa8,
0xa8, 0xac, 0x7e, 0xfd, 0xfa, 0x8e, 0xca, 0x75, 0xf0, 0x05, 0x0e, 0xe1,
0x5e, 0x02, 0xb0, 0x1a, 0x33, 0x66, 0xcc, 0x95, 0xd2, 0xd2, 0x52, 0xb9,
0x4c, 0x26, 0xa3, 0x3d, 0x3c, 0x3c, 0xf6, 0x03, 0xb0, 0xdc, 0xbf, 0x7f,
0x7f, 0x54, 0x25, 0x0e, 0xe1, 0x14, 0x0e, 0x86, 0xf8, 0x00, 0xda, 0x1e,
0x3f, 0x7e, 0xbc, 0xb0, 0xb4, 0xb4, 0x54, 0x56, 0x52, 0x52, 0x42, 0x9f,
0x3f, 0x7f, 0x3e, 0x09, 0x4c, 0xbb, 0x31, 0xec, 0xdc, 0xb9, 0xf3, 0x4d,
0x42, 0x08, 0x89, 0x8c, 0x8c, 0xfc, 0x60, 0x62, 0x62, 0xf2, 0xc9, 0x8b,
0xa9, 0xae, 0xae, 0xae, 0x49, 0x70, 0x70, 0xf0, 0x7b, 0x42, 0x08, 0x69,
0xd9, 0xb2, 0xa5, 0x1f, 0x18, 0xe7, 0x30, 0x55, 0x79, 0x6b, 0x57, 0x47,
0x8d, 0xe2, 0xef, 0xd5, 0xab, 0xd7, 0x1d, 0x36, 0x3d, 0x95, 0x79, 0x6b,
0xb7, 0x68, 0xde, 0xbc, 0xf9, 0x1d, 0xa9, 0x54, 0x4a, 0x92, 0x92, 0x92,
0xb2, 0x75, 0x75, 0x75, 0x3f, 0x39, 0x97, 0x33, 0x33, 0x33, 0xab, 0x4c,
0x26, 0x35, 0x7d, 0x7c, 0x7c, 0x6e, 0xb0, 0xed, 0xf5, 0x52, 0x25, 0x69,
0xad, 0x4e, 0x1e, 0xf4, 0x87, 0x0f, 0x1f, 0x7e, 0x8d, 0x75, 0x1c, 0x14,
0x25, 0x10, 0x08, 0x3e, 0xf9, 0x26, 0x11, 0x08, 0x04, 0xfa, 0xf7, 0xef,
0xdf, 0x7f, 0x43, 0x08, 0x21, 0xfd, 0xfb, 0xf7, 0x57, 0x5c, 0x6d, 0xa8,
0x80, 0x07, 0xc0, 0x35, 0x28, 0x28, 0x48, 0xf4, 0xfa, 0xf5, 0xeb, 0xfc,
0xc4, 0xc4, 0x44, 0x61, 0x60, 0x60, 0x60, 0x29, 0x98, 0xab, 0x0e, 0x95,
0xeb, 0x5b, 0x77, 0xf4, 0xe8, 0xd1, 0xe7, 0x08, 0x21, 0xe4, 0xc5, 0x8b,
0x17, 0x59, 0x9b, 0x37, 0x6f, 0x8e, 0x03, 0xa3, 0x23, 0x8c, 0xbd, 0xbd,
0xbd, 0x43, 0x62, 0x63, 0x63, 0x8b, 0xf2, 0xf2, 0xf2, 0x64, 0xcb, 0x96,
0x2d, 0x0b, 0x66, 0xcb, 0x1f, 0x66, 0x66, 0x66, 0xb6, 0xb9, 0xb9, 0xb9,
0x25, 0x21, 0x21, 0x21, 0x65, 0x60, 0xbc, 0x58, 0xeb, 0x02, 0x30, 0x34,
0x31, 0x31, 0xd9, 0x9d, 0x9b, 0x9b, 0x2b, 0xff, 0xf8, 0xf1, 0x63, 0xb1,
0x8a, 0x37, 0xef, 0xda, 0xe4, 0x17, 0x3d, 0x7a, 0xf4, 0x18, 0x4c, 0xd3,
0x34, 0x39, 0x79, 0xf2, 0xa4, 0x10, 0xc0, 0x44, 0xd4, 0xfc, 0x46, 0x95,
0xda, 0x3a, 0x84, 0x53, 0x50, 0xdb, 0x6b, 0xd5, 0xaa, 0xbd, 0x4a, 0xed,
0xbf, 0x08, 0xfd, 0x03, 0x07, 0x0e, 0xbc, 0x62, 0x65, 0x70, 0x0f, 0x94,
0x64, 0xb0, 0x6f, 0xdf, 0xbe, 0x63, 0x15, 0x4e, 0x8b, 0x04, 0x02, 0x41,
0x7d, 0xf6, 0xcf, 0x9f, 0x1c, 0x6e, 0x25, 0x25, 0x25, 0x15, 0x6a, 0x69,
0x69, 0x7d, 0xaa, 0x23, 0x3e, 0x9f, 0xaf, 0xff, 0xe2, 0xc5, 0x8b, 0x64,
0x99, 0x4c, 0x46, 0xec, 0xed, 0xed, 0xd7, 0xa1, 0xbc, 0x4f, 0xb3, 0xbb,
0x7a, 0xf5, 0x6a, 0x29, 0x21, 0x84, 0x4c, 0x9c, 0x38, 0x71, 0x0e, 0xaa,
0xee, 0xe7, 0x74, 0x1a, 0x37, 0x6e, 0xbc, 0x41, 0x2e, 0x97, 0x93, 0x67,
0xcf, 0x9e, 0x25, 0xf1, 0xf9, 0x7c, 0x7d, 0xa5, 0xf8, 0x0d, 0xa3, 0xa3,
0xa3, 0x73, 0x54, 0x1c, 0x74, 0xe9, 0x58, 0x59, 0x59, 0x2d, 0x2d, 0x28,
0x28, 0x90, 0x27, 0x24, 0x24, 0xe4, 0xaa, 0x93, 0x2b, 0x3e, 0x9f, 0xcf,
0xe7, 0xb1, 0xe7, 0x64, 0x54, 0xd0, 0x9e, 0x34, 0x69, 0xd2, 0x31, 0x42,
0x08, 0x99, 0x3a, 0x75, 0xea, 0x9f, 0xa8, 0x7c, 0x3c, 0xc2, 0x5f, 0xbb,
0x76, 0xad, 0x2f, 0x21, 0x84, 0xd8, 0xda, 0xda, 0xee, 0x02, 0xd0, 0x1e,
0x80, 0x1d, 0x98, 0x76, 0xa0, 0x3a, 0x46, 0xaa, 0xad, 0x83, 0x2e, 0x55,
0x8c, 0x6e, 0xde, 0xbc, 0x99, 0x59, 0x03, 0x87, 0x70, 0x35, 0xfd, 0x26,
0x50, 0xee, 0xad, 0xbd, 0x0c, 0x8c, 0x63, 0x31, 0x6b, 0x5d, 0x5d, 0xdd,
0x93, 0x21, 0x21, 0x21, 0x62, 0x99, 0x4c, 0x26, 0xf7, 0xf2, 0xf2, 0x1a,
0x52, 0x45, 0xdc, 0x35, 0x72, 0x08, 0xb7, 0x74, 0xe9, 0x52, 0xc5, 0xbd,
0xce, 0xc6, 0x4f, 0x9e, 0x3c, 0xc9, 0x0f, 0x09, 0x09, 0x29, 0x04, 0xd3,
0xc6, 0x74, 0x7f, 0xfe, 0xf9, 0xe7, 0x1b, 0xac, 0x53, 0xb1, 0x3e, 0x00,
0xf4, 0x6b, 0x59, 0x3e, 0xfa, 0x6d, 0xda, 0xb4, 0x39, 0x45, 0xd3, 0x34,
0x39, 0x77, 0xee, 0xdc, 0x43, 0x28, 0x39, 0xf0, 0xa2, 0x28, 0x4a, 0xd3,
0xcf, 0xcf, 0xef, 0x09, 0x4d, 0xd3, 0xc4, 0xdd, 0xdd, 0xfd, 0x14, 0x18,
0xfd, 0x56, 0x5b, 0xf9, 0xac, 0xad, 0xbc, 0x01, 0x4a, 0x0e, 0xe1, 0xc6,
0x8e, 0x1d, 0xbb, 0x1f, 0x55, 0x18, 0xd6, 0xca, 0x32, 0xa8, 0xfc, 0x4f,
0x30, 0x0e, 0xdf, 0x3c, 0x52, 0x53, 0x53, 0x65, 0xac, 0x1f, 0x20, 0x75,
0x57, 0x2f, 0xd7, 0xcd, 0xcf, 0xcf, 0x97, 0xe7, 0xe7, 0xe7, 0x4b, 0x34,
0x35, 0x35, 0x2d, 0x2b, 0x89, 0xfa, 0xd3, 0x78, 0x3b, 0x30, 0x30, 0x30,
0x4e, 0x29, 0x8d, 0xd0, 0xd1, 0xd1, 0xb1, 0xf8, 0xf0, 0xe1, 0x43, 0x71,
0x25, 0xf2, 0xa6, 0x6b, 0x6d, 0x6d, 0xbd, 0x41, 0x26, 0x93, 0x91, 0x43,
0x87, 0x0e, 0x05, 0x1e, 0x3c, 0x78, 0xf0, 0xae, 0x44, 0x22, 0xa1, 0xeb,
0xd4, 0xa9, 0xb3, 0x1a, 0x15, 0x9d, 0xc4, 0xe9, 0x8f, 0x1f, 0x3f, 0xfe,
0x46, 0x4e, 0x4e, 0x8e, 0xe4, 0xc6, 0x8d, 0x1b, 0x89, 0xdb, 0xb6, 0x6d,
0x8b, 0x63, 0xd3, 0x6a, 0x76, 0xe8, 0xd0, 0xa1, 0xd4, 0xcb, 0x97, 0x2f,
0xc7, 0x09, 0x85, 0x42, 0xd9, 0xd8, 0xb1, 0x63, 0xaf, 0x42, 0xa9, 0x7f,
0xe9, 0xd2, 0xa5, 0x4b, 0x1f, 0x99, 0x4c, 0x26, 0x0f, 0x08, 0x08, 0x10,
0x51, 0x14, 0xb5, 0x9a, 0xc7, 0xe3, 0xad, 0x0b, 0x0c, 0x0c, 0x14, 0x49,
0xa5, 0x52, 0x79, 0xfb, 0xf6, 0xed, 0x7b, 0xa8, 0xc9, 0x87, 0x00, 0x80,
0x57, 0x78, 0x78, 0xb8, 0xf8, 0xf5, 0xeb, 0xd7, 0x1f, 0x77, 0xef, 0xde,
0x7d, 0x4b, 0x24, 0x12, 0xd1, 0x26, 0x26, 0x26, 0xbf, 0x40, 0x4d, 0x3b,
0xe9, 0xd4, 0xa9, 0x53, 0x2f, 0x89, 0x44, 0x22, 0x3b, 0x72, 0xe4, 0x48,
0x21, 0x98, 0x9d, 0x88, 0xd5, 0xdd, 0x02, 0xa4, 0xc1, 0xd6, 0x93, 0xcd,
0xea, 0xd5, 0xab, 0xa3, 0x08, 0x21, 0xa4, 0x77, 0xef, 0xde, 0x33, 0x51,
0xf5, 0xed, 0x4e, 0x40, 0xed, 0x1c, 0xc2, 0xf1, 0xfb, 0xf4, 0xe9, 0x33,
0x8b, 0x10, 0x42, 0x56, 0xaf, 0x5e, 0x1d, 0x05, 0x66, 0x5c, 0xaf, 0x85,
0x6f, 0xe4, 0x6f, 0xed, 0xef, 0x44, 0x5d, 0x02, 0x79, 0xfd, 0xfa, 0xf5,
0x9b, 0xd8, 0xb5, 0x6b, 0xd7, 0x8e, 0x00, 0xd0, 0xaf, 0x5f, 0xbf, 0x89,
0xbe, 0xbe, 0xbe, 0x1b, 0xf1, 0xf9, 0x6c, 0x14, 0xd5, 0xb7, 0x6f, 0xdf,
0xc1, 0x0e, 0x0e, 0x0e, 0xe6, 0xf3, 0xe7, 0xcf, 0x4f, 0xa2, 0x69, 0xfa,
0x01, 0x2a, 0x5f, 0x91, 0xa1, 0x01, 0xa4, 0xad, 0x5f, 0xbf, 0x3e, 0x38,
0x20, 0x20, 0xc0, 0xd3, 0xdf, 0xdf, 0xff, 0xea, 0xfe, 0xfd, 0xfb, 0xf7,
0xf1, 0xf9, 0x7c, 0xfe, 0xf4, 0xe9, 0xd3, 0x67, 0xf2, 0xf9, 0x7c, 0xfe,
0x86, 0x0d, 0x1b, 0x82, 0xc1, 0xac, 0x4e, 0x7e, 0xc9, 0x36, 0x69, 0x6a,
0xec, 0xd8, 0xb1, 0x53, 0xe7, 0xcd, 0x9b, 0x37, 0xb5, 0xa0, 0xa0, 0x80,
0x6e, 0xda, 0xb4, 0x69, 0xda, 0xd1, 0xa3, 0x47, 0x3b, 0x81, 0x99, 0x9d,
0xfd, 0xc4, 0xe9, 0xd3, 0xa7, 0x4f, 0x05, 0x04, 0x04, 0xdc, 0x02, 0xc0,
0x3b, 0x75, 0xea, 0xd4, 0x5f, 0x06, 0x06, 0x06, 0x3a, 0xb7, 0x6f, 0xdf,
0xbe, 0x93, 0x94, 0x94, 0x94, 0x48, 0xd3, 0x34, 0xdd, 0xac, 0x59, 0x33,
0xa7, 0x69, 0xd3, 0xa6, 0x4d, 0x35, 0x33, 0x33, 0xd3, 0xfa, 0xe1, 0x87,
0x1f, 0xd2, 0x25, 0x12, 0x49, 0x0c, 0x98, 0xd9, 0xb5, 0x5b, 0x60, 0x8c,
0x6f, 0x55, 0xa5, 0x6c, 0x0c, 0x66, 0x46, 0x4b, 0x07, 0xc0, 0x8f, 0x60,
0x56, 0x0a, 0x0a, 0x01, 0xf0, 0xba, 0x77, 0xef, 0x3e, 0x60, 0xe7, 0xce,
0x9d, 0x1b, 0xce, 0x9e, 0x3d, 0xfb, 0x57, 0x62, 0x62, 0x62, 0x42, 0x69,
0x69, 0x69, 0xa9, 0xa3, 0xa3, 0xa3, 0xd3, 0x8c, 0x19, 0x33, 0xa6, 0xea,
0xea, 0xea, 0x6a, 0x4c, 0x99, 0x32, 0xe5, 0x0d, 0x98, 0xad, 0x8a, 0x8a,
0xfc, 0xc6, 0xff, 0xfa, 0xeb, 0xaf, 0x4f, 0xef, 0xdd, 0xbb, 0xd7, 0xed,
0xc9, 0x93, 0x27, 0x81, 0xbb, 0x76, 0xed, 0xda, 0x95, 0x9b, 0x9b, 0x9b,
0x33, 0x66, 0xcc, 0x98, 0xef, 0x9d, 0x9d, 0x9d, 0x2d, 0x76, 0xee, 0xdc,
0x59, 0x98, 0x94, 0x94, 0x14, 0x04, 0x95, 0x59, 0xa8, 0xba, 0x75, 0xeb,
0x3a, 0x8c, 0x18, 0x31, 0xa2, 0xeb, 0x8b, 0x17, 0x2f, 0x24, 0xa1, 0xa1,
0xa1, 0x0a, 0x27, 0x64, 0xaa, 0xc8, 0x1f, 0x3c, 0x78, 0x70, 0xff, 0xd9,
0xb3, 0x67, 0x33, 0xfb, 0xf7, 0xef, 0xef, 0x7c, 0xed, 0xda, 0xb5, 0xab,
0x37, 0x6f, 0xde, 0xbc, 0xa6, 0xa3, 0xa3, 0xa3, 0x33, 0x78, 0xf0, 0xe0,
0xa1, 0x5d, 0xba, 0x74, 0xb1, 0xbf, 0x71, 0xe3, 0x46, 0xd9, 0xe3, 0xc7,
0x8f, 0x03, 0x95, 0xcb, 0xbf, 0x75, 0xeb, 0xd6, 0xee, 0xcd, 0x9b, 0x37,
0x77, 0x2e, 0x29, 0x29, 0x29, 0x75, 0x76, 0x76, 0x76, 0x19, 0x37, 0x6e,
0xdc, 0x38, 0x7b, 0x7b, 0xfb, 0x06, 0x8b, 0x16, 0x2d, 0xca, 0x0b, 0x0b,
0x0b, 0xfb, 0xbd, 0x92, 0x6f, 0xa1, 0x5e, 0xbd, 0x7a, 0x0e, 0xf7, 0xee,
0xdd, 0xbb, 0xa3, 0xf8, 0xff, 0xd4, 0xd4, 0xd4, 0xf8, 0xaa, 0xea, 0xae,
0x79, 0xf3, 0xe6, 0xee, 0x7f, 0xfd, 0xf5, 0xd7, 0xd9, 0xc4, 0xc4, 0xc4,
0xac, 0x4b, 0x97, 0x2e, 0x5d, 0x43, 0xf5, 0xab, 0x13, 0x8a, 0x33, 0xcb,
0xe9, 0x00, 0x4e, 0xc8, 0xe5, 0xf2, 0xeb, 0xa7, 0x4f, 0x9f, 0xf6, 0x40,
0xb9, 0x33, 0x39, 0x82, 0xf2, 0x55, 0xd1, 0x9a, 0x40, 0x4e, 0x9c, 0x38,
0x71, 0x0d, 0xc0, 0x1d, 0x30, 0x8e, 0x31, 0xf2, 0x51, 0x7e, 0xbe, 0xb3,
0x3a, 0x78, 0x07, 0x0f, 0x1e, 0xf4, 0xed, 0xd7, 0xaf, 0x5f, 0xd7, 0x75,
0xeb, 0xd6, 0x35, 0x5d, 0xb9, 0x72, 0xe5, 0x42, 0x54, 0x6c, 0x2b, 0xb2,
0xc8, 0xc8, 0x48, 0xff, 0x6b, 0xd7, 0xae, 0xcd, 0x5f, 0xba, 0x74, 0xe9,
0xc2, 0x8b, 0x17, 0x2f, 0x76, 0x59, 0xb1, 0x62, 0x85, 0x39, 0x18, 0x8f,
0xf0, 0xaf, 0x00, 0x9c, 0x3a, 0x78, 0xf0, 0x60, 0xc4, 0xc1, 0x83, 0x07,
0xdb, 0x82, 0xb9, 0xca, 0x26, 0xc5, 0xd5, 0xd5, 0xb5, 0x5d, 0xe3, 0xc6,
0x8d, 0x4d, 0xcf, 0x9d, 0x3b, 0x57, 0x2c, 0x16, 0x8b, 0xef, 0xa3, 0xe2,
0xd9, 0x1e, 0x4a, 0x2c, 0x16, 0xdf, 0xbf, 0x75, 0xeb, 0x56, 0xc9, 0xf0,
0xe1, 0xc3, 0x4d, 0x5b, 0xb4, 0x68, 0xe1, 0x1e, 0x11, 0x11, 0xf1, 0xc9,
0x49, 0xe0, 0x92, 0x25, 0x4b, 0x7e, 0x2c, 0x28, 0x28, 0xf0, 0x04, 0x40,
0xea, 0xd6, 0xad, 0x5b, 0xd7, 0xcb, 0xcb, 0xab, 0xa7, 0xa9, 0xa9, 0xa9,
0xb1, 0x48, 0x24, 0x22, 0x33, 0x67, 0xce, 0x0c, 0x66, 0xcb, 0x56, 0x0e,
0x20, 0x79, 0xe3, 0xc6, 0x8d, 0xc7, 0xda, 0xb4, 0x69, 0x33, 0xab, 0x7b,
0xf7, 0xee, 0x6d, 0x22, 0x23, 0x23, 0x23, 0xfd, 0xfd, 0xfd, 0xef, 0x44,
0x45, 0x45, 0x45, 0x99, 0x98, 0x98, 0x98, 0x38, 0x3b, 0x3b, 0x3b, 0x3b,
0x3a, 0x3a, 0x36, 0x6e, 0xd2, 0xa4, 0x49, 0x85, 0x7b, 0x37, 0x57, 0xac,
0x58, 0x31, 0x1d, 0xc0, 0x48, 0x47, 0x47, 0xc7, 0x26, 0xce, 0xce, 0xce,
0x4e, 0x7a, 0x7a, 0x7a, 0x3a, 0x37, 0x6f, 0xde, 0x14, 0x4f, 0x9b, 0x36,
0xed, 0x21, 0x21, 0x44, 0x71, 0x2e, 0xf6, 0x13, 0xba, 0xba, 0xba, 0xd4,
0xc1, 0x83, 0x07, 0x7d, 0xd4, 0xd5, 0xe9, 0xc1, 0x83, 0x07, 0x0f, 0x84,
0x86, 0x86, 0x3e, 0xab, 0x61, 0x1d, 0x29, 0x23, 0x05, 0x10, 0x36, 0x7b,
0xf6, 0xec, 0xa7, 0xb7, 0x6f, 0xdf, 0xee, 0xb2, 0x7f, 0xff, 0xfe, 0x2d,
0x83, 0x06, 0x0d, 0xf2, 0x7a, 0xf2, 0xe4, 0xc9, 0x13, 0x00, 0x94, 0xab,
0xab, 0x6b, 0xa7, 0x2f, 0x88, 0xf3, 0x33, 0x5c, 0x5d, 0x5d, 0x5b, 0xd9,
0xda, 0xda, 0xd6, 0x33, 0x31, 0x31, 0xa9, 0xaf, 0xad, 0xad, 0x4d, 0xd1,
0x34, 0x4d, 0x8d, 0x1b, 0x37, 0x6e, 0x4c, 0x5e, 0x5e, 0x5e, 0x72, 0x6a,
0x6a, 0xea, 0x87, 0xa8, 0xa8, 0xa8, 0x57, 0x8a, 0x3a, 0x39, 0x72, 0xe4,
0xc8, 0x89, 0x26, 0x4d, 0x9a, 0x34, 0x0e, 0x0b, 0x0b, 0x0b, 0xcf, 0xcc,
0xcc, 0xcc, 0xea, 0xd3, 0xa7, 0x4f, 0xef, 0x4e, 0x9d, 0x3a, 0xb5, 0xe7,
0xf3, 0xf9, 0xbc, 0x35, 0x6b, 0xd6, 0x14, 0x44, 0x47, 0x47, 0xdf, 0x46,
0xf5, 0x5b, 0xa2, 0x0a, 0xf2, 0xf3, 0xf3, 0xb7, 0xcd, 0x9e, 0x3d, 0xbb,
0xdb, 0x85, 0x0b, 0x17, 0xec, 0x0e, 0x1c, 0x38, 0x70, 0xa4, 0x6f, 0xdf,
0xbe, 0x5d, 0xa0, 0xa2, 0x13, 0x77, 0xee, 0xdc, 0xb9, 0x9c, 0x75, 0xe8,
0x53, 0x41, 0x3e, 0x77, 0xef, 0xde, 0xbd, 0xf3, 0xd5, 0xab, 0x57, 0xaa,
0xce, 0xb1, 0x64, 0xcf, 0x9e, 0x3d, 0x7b, 0xa8, 0xa3, 0xa3, 0x33, 0x50,
0x2e, 0x97, 0x23, 0x34, 0x34, 0xf4, 0x0e, 0x6a, 0x36, 0x03, 0x2c, 0x07,
0x10, 0xb3, 0x79, 0xf3, 0xe6, 0xdb, 0xe3, 0xc7, 0x8f, 0x1f, 0xa9, 0xb2,
0x48, 0x27, 0x7a, 0xfc, 0xf8, 0xf1, 0xde, 0xb3, 0x67, 0xcf, 0x76, 0x1b,
0x3d, 0x7a, 0xb4, 0xed, 0xb3, 0x67, 0xcf, 0x9e, 0xfa, 0xf9, 0xf9, 0xfd,
0x25, 0x97, 0xcb, 0xe5, 0x83, 0x06, 0x0d, 0x1a, 0xec, 0xe2, 0xe2, 0xd2,
0x64, 0xcf, 0x9e, 0x3d, 0xc5, 0xaf, 0x5e, 0xbd, 0xda, 0x0b, 0xa6, 0x9d,
0xd6, 0x76, 0x55, 0xb3, 0xda, 0xf8, 0x4f, 0x9c, 0x38, 0x51, 0x1a, 0x10,
0x10, 0xf0, 0x07, 0xaa, 0xd6, 0x15, 0xf9, 0x6f, 0xde, 0xbc, 0xd9, 0xb0,
0x6f, 0xdf, 0xbe, 0xf6, 0xb3, 0x67, 0xcf, 0x36, 0x5f, 0xb1, 0x62, 0xc5,
0xfa, 0x65, 0xcb, 0x96, 0x79, 0x03, 0xc0, 0xb6, 0x6d, 0xdb, 0xf6, 0x7a,
0x78, 0x78, 0xb4, 0xbb, 0x73, 0xe7, 0x4e, 0x60, 0x72, 0x72, 0x72, 0x72,
0x5e, 0x5e, 0x5e, 0x9e, 0xb9, 0xb9, 0xb9, 0x85, 0x97, 0x97, 0x57, 0x9f,
0x2e, 0x5d, 0xba, 0xb4, 0xbd, 0x77, 0xef, 0x9e, 0xd8, 0xcf, 0xcf, 0xef,
0x52, 0x0d, 0xea, 0x4c, 0x1d, 0x52, 0x3f, 0x3f, 0xbf, 0x33, 0x2f, 0x5e,
0xbc, 0xf0, 0xea, 0xd1, 0xa3, 0x87, 0xf3, 0xb3, 0x67, 0xcf, 0x9e, 0x5d,
0xb9, 0x72, 0xe5, 0xb2, 0x5c, 0x2e, 0x97, 0x0f, 0x19, 0x32, 0x64, 0x68,
0x9b, 0x36, 0x6d, 0x9c, 0x02, 0x02, 0x02, 0xc4, 0x37, 0x6e, 0xdc, 0x38,
0x8d, 0x8a, 0x7d, 0x26, 0x0d, 0x20, 0xf5, 0xc2, 0x85, 0x0b, 0xb1, 0x7b,
0xf6, 0xec, 0x71, 0x01, 0x80, 0xcd, 0x9b, 0x37, 0xbf, 0x02, 0xa3, 0xe7,
0x94, 0x75, 0x8a, 0x3c, 0x3e, 0x3e, 0x3e, 0x1a, 0x00, 0xda, 0xb4, 0x69,
0x53, 0x87, 0x1d, 0x84, 0x8b, 0x01, 0xd0, 0x37, 0x6f, 0xde, 0xbc, 0xf1,
0xfb, 0xef, 0xbf, 0xbb, 0x51, 0x14, 0x85, 0xc4, 0xc4, 0xc4, 0x14, 0xb6,
0x1e, 0x79, 0xeb, 0xd7, 0xaf, 0xdf, 0x6e, 0x6a, 0x6a, 0xaa, 0x3b, 0x70,
0xe0, 0xc0, 0x67, 0x00, 0x2e, 0xb1, 0xf5, 0x42, 0xe5, 0xe7, 0xe7, 0xef,
0x5f, 0xb3, 0x66, 0xcd, 0x88, 0xdd, 0xbb, 0x77, 0x5b, 0xaf, 0x5b, 0xb7,
0x6e, 0xeb, 0xec, 0xd9, 0xb3, 0x27, 0xa0, 0xf6, 0xbb, 0xa1, 0x34, 0x8f,
0x1c, 0x39, 0x72, 0x88, 0xa2, 0x28, 0xe8, 0xeb, 0xeb, 0xe7, 0x1f, 0x3d,
0x7a, 0xf4, 0x3b, 0x30, 0x5e, 0xa1, 0x2b, 0x20, 0x93, 0xc9, 0x64, 0x53,
0xa7, 0x4e, 0x9d, 0x84, 0x6f, 0xb3, 0x72, 0x29, 0xa1, 0x69, 0x3a, 0x70,
0xef, 0xde, 0xbd, 0xe9, 0x5b, 0xb6, 0x6c, 0xa9, 0xdf, 0xbb, 0x77, 0xef,
0x81, 0xfe, 0xfe, 0xfe, 0xe7, 0xbe, 0x51, 0xdc, 0xff, 0x71, 0xfc, 0xfd,
0xfd, 0x3f, 0x4c, 0x9b, 0x36, 0xad, 0xc5, 0xda, 0xb5, 0x6b, 0x87, 0x5b,
0x58, 0x58, 0x24, 0x0b, 0x85, 0xc2, 0xc2, 0xd1, 0xa3, 0x47, 0x8f, 0xee,
0xd4, 0xa9, 0x53, 0x87, 0xd7, 0xaf, 0x5f, 0xcb, 0x9d, 0x9d, 0x9d, 0xd5,
0x0e, 0x60, 0x65, 0x32, 0x99, 0xd6, 0xa3, 0x47, 0x8f, 0x82, 0x7c, 0x7d,
0x7d, 0x0f, 0x94, 0x94, 0x94, 0x94, 0x4c, 0x98, 0x30, 0x61, 0x92, 0xbb,
0xbb, 0x7b, 0xfd, 0xa3, 0x47, 0x8f, 0x0a, 0xe3, 0xe3, 0xe3, 0xaf, 0x80,
0x91, 0x37, 0x02, 0x20, 0x77, 0xee, 0xdc, 0xb9, 0x77, 0x3c, 0x3c, 0x3c,
0x06, 0x1e, 0x3b, 0x76, 0x6c, 0xf7, 0x77, 0xdf, 0x7d, 0xd7, 0x33, 0x38,
0x38, 0xf8, 0x09, 0x45, 0x51, 0x68, 0xc5, 0xd0, 0x72, 0xe4, 0xc8, 0x91,
0x23, 0xde, 0xbe, 0x7d, 0x1b, 0x05, 0x40, 0x12, 0x1b, 0x1b, 0x7b, 0xe5,
0xe4, 0xc9, 0x93, 0x73, 0x27, 0x4e, 0x9c, 0xd8, 0xe0, 0xe6, 0xcd, 0x9b,
0x37, 0x4f, 0x9e, 0x3c, 0x79, 0x4c, 0x4b, 0x4b, 0x4b, 0x73, 0xe2, 0xc4,
0x89, 0x93, 0xd5, 0x4c, 0x8c, 0x88, 0x33, 0x33, 0x33, 0xaf, 0x2e, 0x58,
0xb0, 0x60, 0x96, 0xaf, 0xaf, 0x6f, 0xdd, 0x37, 0x6f, 0xde, 0x44, 0x1c,
0x3d, 0x7a, 0xf4, 0xd8, 0x87, 0x0f, 0x1f, 0x52, 0x1c, 0x1d, 0x1d, 0x1d,
0xdd, 0xdd, 0xdd, 0xdd, 0x5a, 0xb5, 0x6a, 0xe5, 0xda, 0xac, 0x59, 0x33,
0xe7, 0x94, 0x94, 0x94, 0x84, 0x2f, 0x2c, 0x22, 0xad, 0xd0, 0xd0, 0x50,
0x01, 0x21, 0x04, 0xd1, 0xd1, 0xd1, 0xd3, 0x62, 0x62, 0x62, 0x3c, 0x25,
0x12, 0x89, 0x44, 0x2c, 0x16, 0x8b, 0x93, 0x93, 0x93, 0x53, 0x8e, 0x1f,
0x3f, 0x7e, 0x4c, 0x31, 0x06, 0xf9, 0x12, 0xf8, 0x7c, 0xbe, 0x46, 0x87,
0x0e, 0x1d, 0x3a, 0x1b, 0x1a, 0x1a, 0x1a, 0x1a, 0x19, 0x19, 0x59, 0xdb,
0xda, 0xda, 0xea, 0x00, 0xc0, 0x98, 0x31, 0x63, 0x86, 0x64, 0x66, 0x66,
0x36, 0x29, 0x2a, 0x2a, 0x2a, 0x7c, 0xff, 0xfe, 0x7d, 0x74, 0x5a, 0x5a,
0xda, 0x87, 0xaf, 0xac, 0x6a, 0x85, 0xbf, 0x9d, 0x82, 0xd2, 0xd2, 0xd2,
0xd5, 0x03, 0x07, 0x0e, 0xb4, 0x79, 0xf1, 0xe2, 0x45, 0xd7, 0x73, 0xe7,
0xce, 0xfd, 0xd9, 0xa1, 0x43, 0x87, 0x4e, 0xd1, 0xd1, 0xd1, 0xaf, 0x00,
0x40, 0x5b, 0x5b, 0x5b, 0xc7, 0xdd, 0xdd, 0xbd, 0xbd, 0x11, 0x83, 0x8d,
0xb9, 0xb9, 0xb9, 0x80, 0xc7, 0xe3, 0x61, 0xfc, 0xf8, 0xf1, 0x63, 0x8b,
0x8a, 0x8a, 0xd2, 0x0a, 0x0b, 0x0b, 0x0b, 0xa2, 0xa3, 0xa3, 0xdf, 0x64,
0x65, 0x65, 0x65, 0x7d, 0x65, 0x7a, 0x6a, 0x82, 0x38, 0x2c, 0x2c, 0xec,
0xf0, 0xde, 0xbd, 0x7b, 0xbf, 0xf3, 0xf6, 0xf6, 0xee, 0xa2, 0xab, 0xab,
0x7b, 0xd3, 0xcf, 0xcf, 0xef, 0x02, 0x00, 0x8c, 0x18, 0x31, 0x62, 0x54,
0xbf, 0x7e, 0xfd, 0x3a, 0x1e, 0x38, 0x70, 0xa0, 0x38, 0x24, 0x24, 0xe4,
0x28, 0x18, 0xbd, 0xf4, 0xc9, 0x78, 0xe7, 0xf1, 0x78, 0xda, 0x35, 0x90,
0x4f, 0x54, 0x25, 0x6f, 0x3c, 0x1e, 0xef, 0xab, 0xef, 0xaa, 0xd6, 0xd0,
0xd0, 0xd0, 0x4c, 0x4d, 0x4d, 0x4d, 0xf5, 0xf3, 0xf3, 0xbb, 0x1c, 0x1e,
0x1e, 0x1e, 0x9e, 0x99, 0x99, 0x99, 0xe9, 0xe0, 0xe0, 0xd0, 0xb8, 0x6f,
0xdf, 0xbe, 0x03, 0xeb, 0xd6, 0xad, 0xcb, 0xdf, 0xb3, 0x67, 0x4f, 0x3e,
0x3e, 0xef, 0xb7, 0x08, 0x00, 0x71, 0x40, 0x40, 0x40, 0xc9, 0x88, 0x11,
0x23, 0x0c, 0x4e, 0x9d, 0x3a, 0x75, 0xfc, 0xdc, 0xb9, 0x73, 0xc7, 0x79,
0x3c, 0x1e, 0xcf, 0xc4, 0xc4, 0xc4, 0xe4, 0xc0, 0x81, 0x03, 0x8a, 0x6d,
0xf0, 0xf2, 0x27, 0x4f, 0x9e, 0x3c, 0x4c, 0x4c, 0x4c, 0xf4, 0xee, 0xd6,
0xad, 0x9b, 0xdd, 0xb5, 0x6b, 0xd7, 0xae, 0x9e, 0x3f, 0x7f, 0xfe, 0xb4,
0xa1, 0xa1, 0xa1, 0xd1, 0xcc, 0x99, 0x33, 0x7f, 0x2a, 0x2e, 0x2e, 0xae,
0xcc, 0x30, 0x14, 0x67, 0x64, 0x64, 0x9c, 0xbb, 0x75, 0xeb, 0xd6, 0xbc,
0x5e, 0xbd, 0x7a, 0xb5, 0xe3, 0xf3, 0xf9, 0xd4, 0xcd, 0x9b, 0x37, 0x4b,
0x3f, 0x7e, 0xfc, 0xf8, 0x17, 0x2a, 0xf6, 0x73, 0xb2, 0xd0, 0xd0, 0xd0,
0xa7, 0x66, 0x66, 0x66, 0xfd, 0xba, 0x74, 0xe9, 0x62, 0x7b, 0xf8, 0xf0,
0xe1, 0xab, 0x60, 0xfa, 0x74, 0xea, 0xe9, 0xd3, 0xa7, 0xef, 0x76, 0xed,
0xda, 0xe5, 0xa1, 0xa7, 0xa7, 0xc7, 0x0f, 0x0d, 0x0d, 0x0d, 0x06, 0xdb,
0x7f, 0x99, 0x9a, 0x9a, 0x5a, 0x9d, 0x3a, 0x75, 0xea, 0xcf, 0x82, 0x82,
0x02, 0x32, 0x71, 0xe2, 0xc4, 0x40, 0x42, 0xc8, 0x01, 0x42, 0x08, 0x35,
0x61, 0xc2, 0x84, 0xd6, 0x51, 0x51, 0x51, 0x7d, 0x4e, 0x9f, 0x3e, 0x7d,
0xaa, 0x55, 0xab, 0x56, 0x2e, 0x85, 0x85, 0x85, 0xd9, 0x4a, 0xdf, 0x91,
0x02, 0x08, 0xdf, 0xb7, 0x6f, 0x5f, 0xdc, 0x81, 0x03, 0x07, 0x9c, 0x2c,
0x2c, 0x2c, 0xba, 0x5d, 0xba, 0x74, 0xa9, 0x38, 0x3f, 0x3f, 0xff, 0x12,
0x54, 0xc6, 0x79, 0xe6, 0xe6, 0xe6, 0x36, 0xe7, 0xcf, 0x9f, 0x3f, 0x27,
0x12, 0x89, 0xa8, 0xa0, 0xa0, 0xa0, 0x97, 0x23, 0x47, 0x8e, 0x14, 0x03,
0x18, 0xa8, 0x1c, 0xe6, 0xce, 0x9d, 0x3b, 0xb7, 0x0a, 0x0a, 0x0a, 0x94,
0x1d, 0x00, 0x2b, 0x1c, 0x2e, 0x16, 0xa2, 0xdc, 0x01, 0xa1, 0x05, 0x18,
0xe3, 0xfc, 0x5b, 0x1d, 0x97, 0xe5, 0x83, 0xb9, 0xe9, 0x08, 0xec, 0x37,
0x0a, 0xf1, 0xcf, 0xf8, 0x0c, 0xf9, 0x5b, 0xd0, 0xee, 0xd0, 0xa1, 0xc3,
0x3a, 0x9a, 0xa6, 0x09, 0x4d, 0xd3, 0xa4, 0x43, 0x87, 0x0e, 0x95, 0xdd,
0x23, 0xac, 0xe9, 0xef, 0xef, 0x1f, 0x51, 0x5c, 0x5c, 0x5c, 0xd9, 0xf5,
0x69, 0xaa, 0x08, 0x00, 0xf4, 0xf1, 0xf4, 0xf4, 0x4c, 0x8a, 0x8e, 0x8e,
0x2e, 0x55, 0xcc, 0xfe, 0xbe, 0x7b, 0xf7, 0x4e, 0xd4, 0xb3, 0x67, 0xcf,
0x14, 0x30, 0xae, 0xfc, 0x2b, 0xdb, 0x42, 0x58, 0xdd, 0xca, 0xb9, 0xd6,
0xa2, 0x45, 0x8b, 0x4e, 0x93, 0x6a, 0x98, 0x37, 0x6f, 0xde, 0x1f, 0xec,
0x37, 0x0c, 0xa7, 0x4e, 0x9d, 0x1a, 0xf4, 0xfe, 0xfd, 0xfb, 0x62, 0xe5,
0xdf, 0xe5, 0x72, 0x39, 0xfd, 0xfc, 0xf9, 0xf3, 0x92, 0x7e, 0xfd, 0xfa,
0x65, 0x01, 0x98, 0x8e, 0xea, 0x67, 0xff, 0x4d, 0x2a, 0xb9, 0x4a, 0x4d,
0xb3, 0x69, 0xd3, 0xa6, 0x33, 0x02, 0x02, 0x02, 0x72, 0x15, 0xf7, 0x4b,
0x12, 0x42, 0x88, 0x54, 0x2a, 0x95, 0x3f, 0x7a, 0xf4, 0xa8, 0xa4, 0x5d,
0xbb, 0x76, 0xa9, 0x60, 0x1c, 0x32, 0x29, 0xe7, 0x57, 0x00, 0xc0, 0xab,
0x75, 0xeb, 0xd6, 0xf1, 0x11, 0x11, 0x11, 0xa5, 0x34, 0xfb, 0x62, 0x51,
0x51, 0x91, 0x74, 0xc5, 0x8a, 0x15, 0x05, 0x7c, 0x3e, 0xff, 0x37, 0x7c,
0x7e, 0x2d, 0x19, 0x7f, 0xc3, 0x86, 0x0d, 0xbe, 0x84, 0x10, 0x32, 0x7e,
0xfc, 0xf8, 0x48, 0x54, 0xbe, 0x42, 0x49, 0x01, 0xb0, 0xb4, 0xb4, 0xb4,
0xf4, 0x3f, 0x74, 0xe8, 0x90, 0x50, 0x22, 0x91, 0x7c, 0xba, 0x4a, 0xad,
0xa4, 0xa4, 0x44, 0xb6, 0x75, 0xeb, 0xd6, 0x62, 0x03, 0x03, 0x83, 0x73,
0xa8, 0xb8, 0x2a, 0xa2, 0x31, 0x6b, 0xd6, 0xac, 0xcd, 0x8a, 0x70, 0xc5,
0xc5, 0xc5, 0xe2, 0x87, 0x0f, 0x1f, 0x16, 0xf6, 0xec, 0xd9, 0x33, 0x15,
0xcc, 0x76, 0xb4, 0xca, 0x66, 0xc5, 0x78, 0xe6, 0xe6, 0xe6, 0x1d, 0x65,
0x32, 0x19, 0x91, 0x4a, 0xa5, 0xb4, 0xa9, 0xa9, 0x69, 0x7b, 0x54, 0x3d,
0x38, 0xd7, 0x98, 0x3c, 0x79, 0xf2, 0x26, 0x42, 0x08, 0xd9, 0xb6, 0x6d,
0x5b, 0x0a, 0x6a, 0xb7, 0x7a, 0xa2, 0x9c, 0x3f, 0x2d, 0xa8, 0x38, 0x37,
0xf9, 0x87, 0xde, 0x37, 0x3c, 0x7b, 0xf6, 0x6c, 0xa2, 0x9a, 0x99, 0x5c,
0x65, 0x4c, 0x5b, 0xb6, 0x6c, 0x79, 0x5d, 0x2c, 0x16, 0xcb, 0x83, 0x82,
0x82, 0x9e, 0x9b, 0x9b, 0x9b, 0x37, 0x02, 0x33, 0xb1, 0xa3, 0x0b, 0x80,
0xa7, 0xa5, 0xa5, 0x65, 0xdc, 0xa6, 0x4d, 0x1b, 0x4f, 0xf6, 0xfb, 0x82,
0xb5, 0x6b, 0xd7, 0x1e, 0x67, 0x67, 0xb1, 0x1f, 0x40, 0xfd, 0xcc, 0xa0,
0xd1, 0xd8, 0xb1, 0x63, 0x1f, 0xb3, 0xd7, 0x95, 0x9c, 0x00, 0x60, 0xa6,
0xee, 0xaa, 0x30, 0x89, 0x44, 0x22, 0x7f, 0xf7, 0xee, 0x9d, 0xf8, 0xd8,
0xb1, 0x63, 0xa2, 0x06, 0x0d, 0x1a, 0xc4, 0x81, 0xb9, 0xd2, 0x46, 0xd1,
0x31, 0xf0, 0x00, 0x38, 0xf0, 0x78, 0xbc, 0xbf, 0x96, 0x2e, 0x5d, 0x5a,
0xf4, 0xe6, 0xcd, 0x9b, 0x32, 0x99, 0x4c, 0x46, 0x2b, 0xda, 0x41, 0x5c,
0x5c, 0x5c, 0xf1, 0xc5, 0x8b, 0x17, 0xd3, 0xd9, 0x74, 0x56, 0xb8, 0x8a,
0x4c, 0x28, 0x14, 0x4a, 0xc3, 0xc2, 0xc2, 0x0a, 0x4f, 0x9d, 0x3a, 0x55,
0x34, 0x7a, 0xf4, 0xe8, 0x5c, 0x30, 0xe7, 0xc3, 0x5b, 0xa2, 0xe2, 0x8c,
0x67, 0x95, 0x57, 0xa9, 0xb1, 0xab, 0x42, 0xcb, 0x95, 0xd2, 0x53, 0x9b,
0x95, 0x73, 0x80, 0x69, 0x2f, 0x9e, 0xf5, 0xea, 0xd5, 0x8b, 0xba, 0x75,
0xeb, 0x56, 0x59, 0x71, 0x71, 0xb1, 0x54, 0x91, 0xf6, 0x98, 0x98, 0x98,
0xa2, 0xbf, 0xfe, 0xfa, 0xab, 0x6c, 0xdc, 0xb8, 0x71, 0x0f, 0xc1, 0xee,
0x9e, 0xf8, 0x82, 0x95, 0x73, 0x41, 0x58, 0x58, 0x58, 0x74, 0x65, 0x69,
0x7f, 0xf2, 0xe4, 0x49, 0xa4, 0x52, 0x1a, 0xf5, 0x97, 0x2d, 0x5b, 0x16,
0x54, 0x52, 0x52, 0x22, 0x53, 0x0e, 0x13, 0x13, 0x13, 0x23, 0x1d, 0x33,
0x66, 0x4c, 0x2e, 0x98, 0x2b, 0x02, 0x55, 0xdb, 0xae, 0xba, 0x95, 0x73,
0x80, 0xd1, 0x39, 0x13, 0x2f, 0x5e, 0xbc, 0xa8, 0x58, 0xd5, 0x52, 0x6c,
0x37, 0xfe, 0xb4, 0x72, 0x5e, 0x19, 0x03, 0x06, 0x0c, 0x98, 0xcf, 0xa6,
0x49, 0x79, 0xe5, 0xdc, 0x08, 0x40, 0xeb, 0xac, 0xac, 0x2c, 0x79, 0x78,
0x78, 0xb8, 0x04, 0xcc, 0x5d, 0xaf, 0x86, 0x35, 0x58, 0x39, 0x07, 0x1b,
0x57, 0x67, 0x3f, 0x3f, 0x3f, 0x11, 0x21, 0x84, 0x28, 0xad, 0x9c, 0x03,
0x80, 0x29, 0x45, 0x51, 0x87, 0x56, 0xaf, 0x5e, 0x5d, 0x9c, 0x92, 0x92,
0xf2, 0xa9, 0x9e, 0x13, 0x12, 0x12, 0x44, 0x0b, 0x17, 0x2e, 0x2c, 0x00,
0xb0, 0x4d, 0xa9, 0x2c, 0x6b, 0xbb, 0x72, 0x5e, 0x69, 0xfc, 0x84, 0x10,
0x72, 0xf1, 0xe2, 0xc5, 0x32, 0x8a, 0xa2, 0xf6, 0xa1, 0xfc, 0x9a, 0xb5,
0x4a, 0xef, 0x39, 0x07, 0x60, 0x64, 0x6c, 0x6c, 0xbc, 0x37, 0x27, 0x27,
0x47, 0x2e, 0x16, 0x8b, 0x65, 0x8e, 0x8e, 0x8e, 0x6e, 0x00, 0xf4, 0x27,
0x4d, 0x9a, 0x74, 0xe3, 0xdd, 0xbb, 0x77, 0x25, 0xaa, 0x65, 0xf8, 0xf1,
0xe3, 0x47, 0xf1, 0xaa, 0x55, 0xab, 0x0a, 0x0c, 0x0c, 0x0c, 0x2e, 0x83,
0xd9, 0x65, 0xa2, 0x4e, 0x1f, 0x54, 0xb7, 0x92, 0x4c, 0x01, 0xa8, 0x63,
0x60, 0x60, 0x70, 0xdb, 0xd7, 0xd7, 0xb7, 0x54, 0x59, 0x2e, 0x0a, 0x0b,
0x0b, 0xa5, 0x5b, 0xb7, 0x6e, 0x15, 0x6a, 0x6b, 0x6b, 0xff, 0x05, 0xf5,
0xfa, 0x5a, 0xc7, 0xda, 0xda, 0xfa, 0x57, 0xb9, 0x5c, 0x4e, 0x64, 0x32,
0x19, 0xb1, 0xb0, 0xb0, 0x58, 0x82, 0xcf, 0xfb, 0x21, 0x0d, 0x13, 0x13,
0x93, 0x81, 0x84, 0x10, 0x52, 0x5a, 0x5a, 0x4a, 0x6b, 0x69, 0x69, 0x29,
0xfa, 0x12, 0x3e, 0x00, 0xb7, 0xe8, 0xe8, 0x68, 0x29, 0x21, 0x84, 0xb4,
0x6f, 0xdf, 0x7e, 0x2d, 0x00, 0xed, 0xd6, 0xad, 0x5b, 0x7b, 0xc8, 0xe5,
0x72, 0x9a, 0xbd, 0x26, 0xe9, 0x3b, 0x54, 0xec, 0x77, 0xf4, 0x04, 0x02,
0xc1, 0xe2, 0xf7, 0xef, 0xdf, 0x4b, 0x65, 0x32, 0x19, 0xed, 0xea, 0xea,
0xda, 0xf1, 0x0b, 0xf2, 0x6b, 0x5a, 0x5d, 0xdf, 0x4b, 0x08, 0x21, 0x62,
0xb1, 0x58, 0x86, 0xcf, 0xfb, 0x8d, 0x2f, 0x5d, 0x39, 0x07, 0x6a, 0x77,
0xad, 0xda, 0xbf, 0x69, 0xe5, 0x5c, 0x0b, 0xc0, 0xe8, 0x95, 0x2b, 0x57,
0x16, 0x96, 0x95, 0x95, 0x7d, 0x1a, 0x40, 0xc4, 0xc6, 0xc6, 0x16, 0x77,
0xec, 0xd8, 0x31, 0x76, 0xd2, 0xa4, 0x49, 0x1f, 0x08, 0xf9, 0x7c, 0xe5,
0xbc, 0xb8, 0xb8, 0x98, 0x36, 0x30, 0x30, 0x78, 0x75, 0xec, 0xd8, 0xb1,
0x14, 0x91, 0x48, 0x24, 0x51, 0xf4, 0xef, 0x3e, 0x3e, 0x3e, 0x42, 0x0d,
0x0d, 0x8d, 0x3f, 0x50, 0xb1, 0x2f, 0xe1, 0x03, 0x68, 0x5b, 0xb7, 0x6e,
0xdd, 0xe8, 0x0b, 0x17, 0x2e, 0x94, 0x0a, 0x85, 0x42, 0xa9, 0xe2, 0x3b,
0x19, 0x19, 0x19, 0xa5, 0xfe, 0xfe, 0xfe, 0x1f, 0xeb, 0xd6, 0xad, 0xdb,
0x0b, 0xe5, 0xba, 0xd2, 0x58, 0x43, 0x43, 0x63, 0xff, 0x9e, 0x3d, 0x7b,
0x84, 0xa5, 0xa5, 0xa5, 0x32, 0x36, 0x6e, 0xf1, 0xc1, 0x83, 0x07, 0x13,
0x2c, 0x2c, 0x2c, 0x5e, 0xaa, 0xe9, 0xff, 0x74, 0x01, 0xcc, 0xe8, 0xd2,
0xa5, 0x4b, 0x7a, 0x58, 0x58, 0x58, 0x89, 0xa2, 0x6f, 0x11, 0x8b, 0xc5,
0xb2, 0x90, 0x90, 0x90, 0x82, 0x7d, 0xfb, 0xf6, 0x65, 0x1a, 0x1a, 0x1a,
0xba, 0xe1, 0xf3, 0xb1, 0x41, 0x8d, 0x56, 0xce, 0x79, 0x3c, 0x9e, 0xce,
0x84, 0x09, 0x13, 0xf6, 0xe5, 0xe6, 0xe6, 0xd2, 0x79, 0x79, 0x79, 0xf2,
0xa8, 0xa8, 0x28, 0x61, 0x64, 0x64, 0x64, 0x71, 0x7c, 0x7c, 0xfc, 0xa7,
0x6f, 0x8d, 0x1e, 0x3d, 0xfa, 0x07, 0xa8, 0x5c, 0xa5, 0x56, 0xd3, 0x95,
0x73, 0x33, 0x33, 0xb3, 0xba, 0xd5, 0xc9, 0xf3, 0xaa, 0x55, 0xab, 0x76,
0xa1, 0xf2, 0x55, 0xbe, 0x9a, 0xae, 0x9c, 0x2b, 0xee, 0x39, 0x07, 0x18,
0x7d, 0xdb, 0xaa, 0x45, 0x8b, 0x16, 0x91, 0x42, 0xa1, 0x50, 0x1e, 0x17,
0x17, 0x97, 0x66, 0x66, 0x66, 0x66, 0x0d, 0x80, 0x6a, 0xd6, 0xac, 0x99,
0x7b, 0x75, 0xe9, 0x99, 0x35, 0x6b, 0xd6, 0x0a, 0x00, 0x1a, 0xff, 0xc0,
0xca, 0x39, 0xc0, 0x8c, 0x0b, 0xb6, 0x79, 0x7b, 0x7b, 0xe7, 0x64, 0x66,
0x66, 0x8a, 0x14, 0x69, 0xc8, 0xcc, 0xcc, 0x14, 0xcd, 0x99, 0x33, 0x27,
0x97, 0xa2, 0xa8, 0x5d, 0x28, 0xbf, 0xa2, 0xf1, 0xd3, 0xca, 0xf9, 0xc0,
0x81, 0x03, 0x3f, 0x1c, 0x3b, 0x76, 0xec, 0x43, 0x0d, 0xe4, 0xb3, 0x52,
0x79, 0xeb, 0xdf, 0xbf, 0x7f, 0xbc, 0x1a, 0x79, 0xab, 0xd5, 0xca, 0x39,
0x8f, 0xc7, 0xab, 0x73, 0xf9, 0xf2, 0xe5, 0x8f, 0x22, 0x91, 0xa8, 0x42,
0x9f, 0x9d, 0x9f, 0x9f, 0x2f, 0xd9, 0xb0, 0x61, 0x43, 0x91, 0x86, 0x86,
0xc6, 0x76, 0xa8, 0xbf, 0x8d, 0xc9, 0xd0, 0xca, 0xca, 0xea, 0xcc, 0xed,
0xdb, 0xb7, 0x2b, 0xf4, 0x49, 0x19, 0x19, 0x19, 0x85, 0x4a, 0x65, 0x43,
0x01, 0xb0, 0x6d, 0xd1, 0xa2, 0xc5, 0xcb, 0xd0, 0xd0, 0xd0, 0x4f, 0xed,
0xaa, 0xb8, 0xb8, 0xb8, 0x6c, 0xcf, 0x9e, 0x3d, 0xc9, 0xd6, 0xd6, 0xd6,
0xaf, 0xd4, 0x94, 0xa7, 0x02, 0x93, 0x61, 0xc3, 0x86, 0x3d, 0x56, 0xbc,
0x33, 0x68, 0xd0, 0xa0, 0x20, 0x7c, 0x7e, 0xd5, 0xa5, 0x06, 0x8f, 0xc7,
0xeb, 0x24, 0x14, 0x0a, 0x69, 0x42, 0x08, 0xb1, 0xb6, 0xb6, 0x9e, 0xc9,
0xe6, 0x57, 0xbb, 0x79, 0xf3, 0xe6, 0xab, 0x09, 0x21, 0xa4, 0xa0, 0xa0,
0x80, 0xa6, 0x28, 0xaa, 0x1d, 0x2b, 0x9f, 0xbc, 0x2b, 0x57, 0xae, 0xdc,
0x23, 0x84, 0x90, 0x21, 0x43, 0x86, 0x24, 0x02, 0x68, 0x8d, 0xf2, 0x1d,
0xbb, 0x6e, 0x23, 0x46, 0x8c, 0x48, 0x62, 0xfb, 0xf7, 0x5b, 0x6a, 0xda,
0xa3, 0x8e, 0x9e, 0x9e, 0xde, 0xbc, 0x82, 0x82, 0x02, 0x9a, 0x10, 0x42,
0x7a, 0xf4, 0xe8, 0x71, 0x13, 0x9f, 0x8f, 0x49, 0x79, 0xed, 0xdb, 0xb7,
0x1f, 0x5e, 0x9d, 0x7c, 0xb6, 0x6a, 0xd5, 0xaa, 0x07, 0xd4, 0xf7, 0xa7,
0xff, 0x15, 0xf7, 0x9c, 0xff, 0x1b, 0x10, 0x00, 0xe8, 0xde, 0xa0, 0x41,
0x83, 0xa4, 0xfa, 0xf5, 0xeb, 0x27, 0x01, 0xe8, 0x0e, 0xf5, 0xf7, 0xce,
0x19, 0x00, 0xd8, 0x0f, 0xe0, 0x39, 0xca, 0x2f, 0xaf, 0xaf, 0x0e, 0x5d,
0x30, 0x5e, 0xa7, 0x03, 0x2d, 0x2c, 0x2c, 0x92, 0xcd, 0xcd, 0xcd, 0x93,
0x01, 0xdc, 0x03, 0x30, 0xa4, 0x9a, 0x42, 0xd3, 0x64, 0xc3, 0xbc, 0x02,
0x30, 0x09, 0x9f, 0x2b, 0x6c, 0x1d, 0x30, 0xf7, 0xe8, 0x25, 0x82, 0x39,
0x37, 0x98, 0xa2, 0xe6, 0x89, 0x06, 0xb3, 0x5d, 0x59, 0x9b, 0x7d, 0x7e,
0x04, 0x70, 0xdf, 0xc0, 0xc0, 0x20, 0xc9, 0xde, 0xde, 0xfe, 0x83, 0x9d,
0x9d, 0xdd, 0x07, 0x81, 0x40, 0x10, 0x07, 0xe0, 0x26, 0x80, 0x11, 0x60,
0x06, 0x78, 0xd5, 0x19, 0x6a, 0xc6, 0x00, 0x2e, 0x82, 0xb9, 0x7a, 0x42,
0xf9, 0x3e, 0x5e, 0x3e, 0x80, 0x16, 0x00, 0xce, 0x6a, 0x69, 0x69, 0xc5,
0x37, 0x6a, 0xd4, 0x28, 0xd5, 0xde, 0xde, 0xfe, 0x83, 0x40, 0x20, 0x88,
0x05, 0xe3, 0x30, 0xac, 0x0f, 0xd4, 0x1b, 0x71, 0x3a, 0x00, 0x7a, 0x02,
0xf0, 0x37, 0x34, 0x34, 0x4c, 0x68, 0xd8, 0xb0, 0xa1, 0xe2, 0xac, 0xc9,
0x72, 0x30, 0xb3, 0x3f, 0x94, 0x9a, 0xf0, 0x0b, 0x00, 0xbc, 0x06, 0x30,
0x19, 0x55, 0xdf, 0x57, 0xcd, 0x07, 0x73, 0xad, 0x9b, 0x0f, 0x9f, 0xcf,
0x7f, 0xdf, 0xb0, 0x61, 0xc3, 0xd4, 0xfa, 0xf5, 0xeb, 0xa7, 0x52, 0x14,
0xf5, 0x16, 0xc0, 0x26, 0x30, 0x83, 0x76, 0xe5, 0x3a, 0xd4, 0xe6, 0xf3,
0xf9, 0x3f, 0xda, 0xda, 0xda, 0xbe, 0xb7, 0xb3, 0xb3, 0x4b, 0x01, 0xe3,
0x34, 0xef, 0x12, 0x5b, 0x0f, 0x95, 0x1e, 0x17, 0x60, 0xe3, 0xb0, 0xb7,
0xb5, 0xb5, 0x8d, 0xb5, 0xb1, 0xb1, 0x89, 0x05, 0xb3, 0xd5, 0xac, 0xaa,
0x72, 0xd4, 0xde, 0xbb, 0x77, 0x6f, 0x10, 0x21, 0x84, 0xb4, 0x6c, 0xd9,
0xf2, 0x18, 0xaa, 0xbe, 0x9e, 0xee, 0xbf, 0x11, 0x03, 0x81, 0x40, 0xb0,
0xaf, 0x65, 0xcb, 0x96, 0x1f, 0xc0, 0x6c, 0xe5, 0x51, 0x37, 0xa1, 0x23,
0x00, 0xe0, 0xd9, 0xae, 0x5d, 0xbb, 0xb8, 0xe4, 0xe4, 0xe4, 0x92, 0x92,
0x92, 0x12, 0xd1, 0x93, 0x27, 0x4f, 0x9e, 0x1f, 0x3e, 0x7c, 0xf8, 0x44,
0x70, 0x70, 0xf0, 0x8b, 0xb2, 0xb2, 0x32, 0x71, 0x76, 0x76, 0x76, 0x3e,
0x1b, 0x4e, 0x51, 0xa7, 0x51, 0x00, 0xc6, 0x41, 0x7d, 0x27, 0xa3, 0x05,
0x60, 0x02, 0x1b, 0x66, 0x01, 0x00, 0x4b, 0x30, 0x6d, 0xf1, 0x03, 0x18,
0x59, 0x4f, 0x62, 0x9f, 0x38, 0x00, 0xc1, 0x60, 0xae, 0x75, 0x73, 0x57,
0x13, 0x17, 0x1f, 0xcc, 0x1d, 0xc4, 0xbf, 0x00, 0x78, 0xa0, 0xa5, 0xa5,
0x95, 0xd8, 0xb8, 0x71, 0xe3, 0x34, 0x6d, 0x6d, 0xed, 0x04, 0x30, 0x67,
0xb1, 0xf6, 0x83, 0x69, 0x07, 0x06, 0x2a, 0xf1, 0x47, 0x83, 0x39, 0xd6,
0x71, 0x08, 0xc0, 0x78, 0x94, 0xcf, 0x76, 0x2a, 0x63, 0x02, 0xe0, 0x3e,
0x98, 0x55, 0xbf, 0x14, 0x30, 0x0e, 0x35, 0x94, 0x9f, 0x37, 0x00, 0x86,
0xa1, 0x5c, 0x11, 0xeb, 0x03, 0xd8, 0x0a, 0x46, 0xde, 0x3b, 0xa2, 0x66,
0xdb, 0x8e, 0xb4, 0xc0, 0xec, 0x8e, 0x39, 0x43, 0x51, 0x54, 0xb4, 0xbd,
0xbd, 0x7d, 0x9a, 0xae, 0xae, 0x6e, 0x3c, 0x80, 0x47, 0x60, 0xee, 0xb2,
0x1f, 0x03, 0xf6, 0x7e, 0x52, 0x36, 0xfd, 0x51, 0x60, 0xda, 0xa5, 0xea,
0x76, 0xb6, 0x16, 0xec, 0x6f, 0xfb, 0x51, 0x6e, 0x3c, 0x18, 0x81, 0x39,
0x63, 0x1a, 0x0d, 0xc6, 0x61, 0x59, 0x26, 0x18, 0x07, 0x66, 0xf1, 0x60,
0xce, 0x21, 0x1d, 0x45, 0xb9, 0x11, 0xa8, 0x0b, 0x60, 0xa1, 0x40, 0x20,
0x78, 0x6b, 0x6b, 0x6b, 0x9b, 0xd6, 0xac, 0x59, 0xb3, 0x0c, 0x3d, 0x3d,
0xbd, 0x54, 0x30, 0x0e, 0xa6, 0x26, 0xb1, 0x65, 0xa1, 0xda, 0x06, 0x4c,
0xc1, 0x9c, 0x8b, 0x0c, 0x44, 0x45, 0xa3, 0x84, 0x02, 0x63, 0xb4, 0x1d,
0x65, 0xcb, 0x62, 0x04, 0xca, 0x8f, 0x68, 0x1c, 0x07, 0x90, 0xaa, 0x54,
0x0f, 0xca, 0xcf, 0x6b, 0x94, 0x1b, 0x5e, 0x26, 0x60, 0x76, 0x81, 0xac,
0x05, 0xa3, 0x57, 0xcd, 0xd9, 0xb4, 0x5c, 0x63, 0x7f, 0xd3, 0x07, 0xb0,
0x81, 0x0d, 0x63, 0xa2, 0x54, 0x3e, 0xaf, 0xf0, 0xb9, 0xf1, 0x65, 0x02,
0xe0, 0x30, 0x9b, 0xef, 0xbd, 0x4a, 0xe5, 0x43, 0xb1, 0x72, 0xb7, 0x12,
0xc0, 0x0b, 0x4b, 0x4b, 0xcb, 0x0f, 0x96, 0x96, 0x96, 0x29, 0xac, 0xbc,
0x2d, 0x62, 0xbf, 0xa9, 0xc8, 0xb3, 0x00, 0x40, 0x3f, 0x94, 0xeb, 0xb2,
0xea, 0x26, 0x72, 0xd5, 0xc6, 0xef, 0xee, 0xee, 0xfe, 0xb1, 0xa0, 0xa0,
0x80, 0xce, 0xce, 0xce, 0x16, 0xd7, 0xa9, 0x53, 0xa7, 0x95, 0x52, 0xfc,
0x7c, 0x30, 0x77, 0xe1, 0x46, 0x81, 0x71, 0xec, 0xa6, 0x6c, 0x00, 0xf2,
0xc0, 0xdc, 0xe1, 0xfc, 0x02, 0x8c, 0x13, 0x4c, 0x57, 0xb6, 0x4c, 0x26,
0x02, 0x08, 0x32, 0x30, 0x30, 0x48, 0x69, 0xd8, 0xb0, 0x61, 0x9a, 0x93,
0x93, 0x53, 0x9a, 0x91, 0x91, 0x51, 0x32, 0x98, 0xf3, 0x65, 0x2b, 0xc1,
0xe8, 0xad, 0xca, 0x06, 0xde, 0xa6, 0x60, 0xda, 0x87, 0xaa, 0xde, 0x87,
0xca, 0x77, 0x1d, 0xc0, 0xf8, 0xeb, 0x78, 0xd7, 0xa0, 0x41, 0x83, 0x34,
0x6b, 0x6b, 0xeb, 0x0f, 0x6c, 0x3d, 0x6d, 0x02, 0x50, 0x1f, 0xea, 0xfb,
0x4c, 0x1e, 0x98, 0x5d, 0x35, 0xd1, 0xac, 0x9c, 0x35, 0x53, 0x13, 0x8e,
0x02, 0x73, 0x0f, 0x72, 0x34, 0x80, 0x08, 0x30, 0xdb, 0x62, 0x15, 0x65,
0x61, 0x06, 0xa6, 0x6d, 0xbe, 0x03, 0xe0, 0x09, 0x46, 0xfe, 0xdd, 0xd9,
0xbc, 0xef, 0x87, 0xfa, 0xad, 0x9a, 0xb6, 0x60, 0xe4, 0x30, 0x0c, 0xe5,
0x03, 0xb7, 0xda, 0xe4, 0xd7, 0x8c, 0xcd, 0x57, 0x16, 0xd4, 0xcb, 0xa6,
0xa2, 0xfd, 0xbf, 0x50, 0xf3, 0xfe, 0xd7, 0x18, 0xe7, 0x8a, 0xba, 0x0d,
0x41, 0x45, 0xd9, 0x54, 0xc7, 0xbf, 0xc9, 0x38, 0xa7, 0xc0, 0x8c, 0x2d,
0x7e, 0x15, 0x08, 0x04, 0x31, 0x8d, 0x1b, 0x37, 0x4e, 0x33, 0x30, 0x30,
0x48, 0x00, 0x53, 0x47, 0x43, 0x01, 0xcc, 0x62, 0xf3, 0xac, 0xd8, 0x56,
0xab, 0xc3, 0xfe, 0x2d, 0x18, 0xcc, 0xf6, 0xee, 0xdd, 0x1a, 0x1a, 0x1a,
0x51, 0xf6, 0xf6, 0xf6, 0x1f, 0x34, 0x34, 0x34, 0xa2, 0xc1, 0xe8, 0x55,
0x1b, 0x7c, 0xae, 0x83, 0x34, 0x01, 0xb4, 0x02, 0xa3, 0x6b, 0xde, 0x36,
0x68, 0xd0, 0x20, 0x95, 0x6d, 0xc3, 0x61, 0x60, 0xce, 0xe0, 0x2b, 0xee,
0x7b, 0x57, 0xa4, 0xa9, 0x2e, 0x80, 0x6d, 0x1a, 0x1a, 0x1a, 0xd1, 0x6c,
0xdc, 0x11, 0x00, 0xb6, 0x83, 0x39, 0x53, 0xfe, 0x12, 0xc0, 0x6c, 0x54,
0x34, 0x50, 0x0c, 0xc0, 0x2c, 0xba, 0xdc, 0xd2, 0xd4, 0xd4, 0x8c, 0x6b,
0xd2, 0xa4, 0x49, 0xaa, 0x40, 0x20, 0x88, 0x01, 0xe3, 0x08, 0x6e, 0x0b,
0xd4, 0x4f, 0x7e, 0x29, 0xfa, 0xb6, 0x48, 0xa8, 0x1f, 0xeb, 0x01, 0x00,
0xf5, 0xdb, 0x6f, 0xbf, 0xfd, 0x4e, 0x08, 0x21, 0xfd, 0xfb, 0xf7, 0x4f,
0xe1, 0xf3, 0xf9, 0xef, 0xc1, 0xe8, 0xfc, 0x07, 0x00, 0x5e, 0x38, 0x3b,
0x3b, 0x67, 0xd0, 0x34, 0x4d, 0x02, 0x03, 0x03, 0xdf, 0xb2, 0xf1, 0x69,
0x03, 0x98, 0x81, 0x8a, 0xfa, 0x54, 0xf9, 0x7b, 0x23, 0xd8, 0xdf, 0x66,
0xa2, 0x7c, 0xdb, 0x7f, 0x43, 0x30, 0x63, 0xdb, 0x58, 0x30, 0xba, 0x2f,
0x0d, 0x4c, 0x1f, 0x90, 0xc0, 0xfe, 0x2d, 0x02, 0x80, 0x37, 0x2a, 0x5f,
0xc0, 0xa9, 0xce, 0x38, 0x37, 0x05, 0xb3, 0x1b, 0xd3, 0x1f, 0x15, 0xe5,
0x5e, 0x0b, 0xcc, 0x18, 0x30, 0x1c, 0xcc, 0x78, 0xab, 0x1e, 0x98, 0xbe,
0xb0, 0x05, 0x98, 0xf6, 0xa3, 0x48, 0x4f, 0x3a, 0x9b, 0x9e, 0x78, 0xf6,
0x6f, 0x2f, 0xd9, 0x72, 0xd3, 0x05, 0x73, 0xef, 0x7b, 0x38, 0x80, 0xf9,
0x6c, 0xfa, 0x8c, 0xc0, 0x4c, 0xa0, 0x9f, 0x67, 0xe5, 0x4a, 0x87, 0xad,
0xab, 0x70, 0x30, 0x47, 0x66, 0xf4, 0x6a, 0x59, 0x3e, 0x8a, 0xfa, 0x35,
0x03, 0x33, 0xe6, 0x79, 0x6e, 0x63, 0x63, 0x93, 0x64, 0x69, 0x69, 0x99,
0xc4, 0xa6, 0x71, 0x3e, 0x98, 0x36, 0xa6, 0xa8, 0xdb, 0x4f, 0xc6, 0xf9,
0x90, 0x21, 0x43, 0x0e, 0x01, 0xd8, 0x57, 0x03, 0xf9, 0xac, 0x4c, 0xde,
0x76, 0x0f, 0x19, 0x32, 0xe4, 0x80, 0x1a, 0xe3, 0x5c, 0x1b, 0xcc, 0xf8,
0x3e, 0x12, 0x40, 0x55, 0x47, 0x6c, 0x15, 0x18, 0x03, 0x38, 0x2c, 0x10,
0x08, 0xa2, 0xad, 0xad, 0xad, 0x93, 0x9d, 0x9c, 0x9c, 0x52, 0xad, 0xac,
0xac, 0x52, 0x28, 0x8a, 0x7a, 0x05, 0xa6, 0xdf, 0xac, 0xcc, 0x17, 0x03,
0x1f, 0x8c, 0x7e, 0x3e, 0x6b, 0x64, 0x64, 0x94, 0xdc, 0xac, 0x59, 0xb3,
0x54, 0x13, 0x13, 0x93, 0x04, 0x30, 0x3a, 0x57, 0xb9, 0x1e, 0x05, 0x60,
0xf4, 0xef, 0x6d, 0x63, 0x63, 0xe3, 0x0f, 0xf6, 0xf6, 0xf6, 0x1f, 0x28,
0x8a, 0x0a, 0x07, 0x23, 0xf7, 0xdd, 0xd8, 0xb2, 0x57, 0x2e, 0x4f, 0xe5,
0xf2, 0x1e, 0xc3, 0xd6, 0x69, 0x2c, 0x80, 0x91, 0x95, 0xe4, 0xc5, 0x92,
0xad, 0xf3, 0x68, 0x94, 0x1f, 0x7b, 0xd2, 0x00, 0xd3, 0xfe, 0xdf, 0x81,
0xb9, 0x51, 0x4a, 0xb1, 0x62, 0xac, 0x0f, 0xe6, 0x6a, 0xe3, 0xd7, 0x00,
0xbe, 0x57, 0xf9, 0xa6, 0x2e, 0x98, 0xbe, 0xf0, 0x35, 0x9b, 0x36, 0xd5,
0xf1, 0x37, 0xc5, 0xe3, 0xf1, 0x1a, 0xa7, 0xa4, 0xa4, 0x48, 0x93, 0x92,
0x92, 0xe4, 0x14, 0x45, 0x0d, 0xc1, 0xe7, 0xc6, 0xb3, 0x06, 0x80, 0xce,
0xec, 0x77, 0x15, 0x63, 0xa4, 0x38, 0x95, 0x27, 0x0c, 0x4c, 0x3f, 0xa4,
0xae, 0x4f, 0xd5, 0x5b, 0xb0, 0x60, 0xc1, 0x6d, 0x42, 0x08, 0x99, 0x3f,
0x7f, 0xfe, 0x51, 0x7c, 0x63, 0xe3, 0x7c, 0xe1, 0xc2, 0x85, 0xc7, 0x09,
0x21, 0x64, 0xe1, 0xc2, 0x85, 0xfe, 0xf8, 0x17, 0x19, 0xe7, 0x95, 0x19,
0x4d, 0xda, 0x60, 0x14, 0x33, 0xc0, 0x14, 0x6c, 0x59, 0x25, 0xef, 0x1a,
0x82, 0x29, 0xec, 0xda, 0xdc, 0x95, 0xac, 0x09, 0x46, 0x69, 0x9b, 0x82,
0xd9, 0x02, 0x92, 0x0f, 0xe6, 0xf0, 0x7d, 0x75, 0x4e, 0x8a, 0xb4, 0xc0,
0x08, 0x4e, 0x29, 0x3e, 0x77, 0x32, 0xa4, 0x38, 0x83, 0xac, 0x5b, 0x45,
0x9e, 0x14, 0xdb, 0x87, 0x14, 0xce, 0xe1, 0xb4, 0x51, 0xae, 0xb8, 0x4c,
0xc0, 0x6c, 0xe5, 0xcb, 0x66, 0xc3, 0x94, 0xa2, 0x66, 0x5b, 0x1f, 0x28,
0xf6, 0x7d, 0x1e, 0x18, 0xa7, 0x39, 0xca, 0xdb, 0x01, 0x35, 0xd8, 0xf4,
0x2a, 0xf2, 0xca, 0x03, 0x73, 0xef, 0x62, 0x09, 0xca, 0x1d, 0x0f, 0xa8,
0x43, 0xc0, 0xbe, 0x63, 0x0c, 0x46, 0x90, 0xb2, 0xc0, 0x38, 0x4d, 0x11,
0x41, 0xbd, 0xa7, 0x4d, 0x5d, 0x36, 0x2f, 0x25, 0xa8, 0x7e, 0x2b, 0x36,
0x9f, 0x0d, 0xaf, 0x0f, 0x46, 0x79, 0x2a, 0xf2, 0x5c, 0x82, 0xcf, 0xef,
0x0b, 0x57, 0x74, 0xae, 0xf5, 0xd8, 0x34, 0x65, 0xb0, 0xf1, 0x97, 0xd6,
0xa0, 0xae, 0x04, 0x60, 0xe4, 0x87, 0x80, 0x69, 0xa8, 0x55, 0x6d, 0xa3,
0xd5, 0x7f, 0xf6, 0xec, 0x59, 0x2c, 0x00, 0xd3, 0xf6, 0xed, 0xdb, 0x7b,
0x81, 0x31, 0x22, 0xfe, 0x31, 0x8f, 0x88, 0xdf, 0x00, 0x1e, 0x98, 0x4e,
0xaa, 0x21, 0x18, 0xaf, 0xcf, 0x95, 0x5d, 0x07, 0xa8, 0x03, 0xa0, 0x9b,
0xa9, 0xa9, 0xe9, 0xca, 0xc1, 0x83, 0x07, 0xdb, 0xb6, 0x6e, 0xdd, 0x5a,
0xe6, 0xe8, 0xe8, 0x28, 0xc8, 0xcd, 0xcd, 0xe5, 0x45, 0x45, 0x45, 0x69,
0x9c, 0x3a, 0x75, 0x2a, 0x26, 0x31, 0x31, 0x71, 0x00, 0x18, 0x39, 0xaa,
0xae, 0x4e, 0x15, 0x2b, 0xfd, 0x7a, 0x60, 0xda, 0x82, 0x08, 0x4c, 0x9d,
0xaa, 0x53, 0xe2, 0x8a, 0xfb, 0x56, 0x4b, 0xa1, 0xbe, 0x8d, 0x2a, 0xda,
0x8e, 0x36, 0xca, 0x0d, 0xb9, 0x5c, 0x94, 0xcb, 0xa8, 0xe2, 0x8a, 0x0d,
0x03, 0xa5, 0xf8, 0x09, 0x1b, 0x97, 0x1c, 0xe5, 0xce, 0xdd, 0x54, 0xd3,
0xc8, 0x03, 0xd3, 0x36, 0x2a, 0x33, 0xb2, 0x15, 0x9e, 0xb2, 0x15, 0xf9,
0xa3, 0xd8, 0x3c, 0x68, 0x82, 0x71, 0xc0, 0x54, 0x53, 0xe7, 0x1b, 0x7c,
0xf6, 0x3d, 0x1d, 0x30, 0x1d, 0x96, 0xb2, 0x63, 0x0f, 0x85, 0x23, 0x3a,
0x45, 0xfa, 0x05, 0x60, 0x74, 0x95, 0xaa, 0x7c, 0x69, 0xb0, 0x69, 0x55,
0xe4, 0x57, 0x91, 0x1e, 0x23, 0xa8, 0x9f, 0x98, 0x04, 0x1b, 0xb6, 0x50,
0x29, 0xac, 0x2e, 0x1b, 0xde, 0x8c, 0x2d, 0xcb, 0x6c, 0x36, 0x1f, 0x0a,
0x5d, 0xa2, 0xae, 0x7c, 0x8c, 0x51, 0xee, 0xc8, 0x4e, 0x5d, 0xdb, 0xd3,
0x54, 0x2a, 0x23, 0x80, 0xd1, 0xb7, 0x95, 0x75, 0x5c, 0x84, 0x4d, 0xbb,
0xc2, 0x69, 0xa4, 0x22, 0x3f, 0x25, 0x28, 0x1f, 0xec, 0xd3, 0x28, 0xbf,
0x41, 0x42, 0x4f, 0xa9, 0x3c, 0x88, 0x52, 0xf9, 0xe4, 0x57, 0x91, 0x16,
0x09, 0x2a, 0xca, 0xb7, 0x22, 0xdf, 0x3a, 0x28, 0x37, 0xea, 0x73, 0x51,
0xae, 0x67, 0x95, 0xf3, 0xac, 0xd0, 0xdf, 0x65, 0x28, 0x3f, 0x7e, 0x52,
0x1d, 0xca, 0xf1, 0x5b, 0x00, 0x70, 0xf0, 0xf6, 0xf6, 0xf6, 0xf5, 0xf1,
0xf1, 0xa9, 0xf3, 0xe0, 0xc1, 0x83, 0xb0, 0x41, 0x83, 0x06, 0x79, 0x15,
0x16, 0x16, 0x2a, 0x6e, 0x01, 0x10, 0xb0, 0xe5, 0x23, 0xc1, 0xe7, 0x4e,
0x19, 0xf9, 0x28, 0x9f, 0x50, 0x54, 0xf4, 0x55, 0x5a, 0x6c, 0xdc, 0x0a,
0xbf, 0x14, 0x5a, 0x28, 0x3f, 0x96, 0x24, 0x62, 0x9f, 0xca, 0xb6, 0x77,
0x2b, 0xea, 0x0e, 0xf8, 0x5c, 0xef, 0xab, 0x86, 0xd3, 0x63, 0xbf, 0x53,
0x07, 0x8c, 0xdc, 0xe5, 0xa0, 0xbc, 0x8f, 0xa9, 0xac, 0x0c, 0xf8, 0x60,
0xfa, 0x24, 0xc2, 0xc6, 0x2f, 0xaf, 0x26, 0x4c, 0x05, 0xc7, 0x6f, 0x6c,
0xda, 0xf8, 0x28, 0x6f, 0x47, 0x1a, 0x55, 0x94, 0x8d, 0x22, 0x9d, 0x8a,
0x7e, 0x4c, 0x5d, 0xdb, 0xab, 0x2e, 0xbf, 0x3c, 0x36, 0x2d, 0xd5, 0x4d,
0xd0, 0x2b, 0x1c, 0xef, 0x28, 0xbf, 0x6f, 0x21, 0x16, 0x8b, 0xb3, 0x52,
0x52, 0x52, 0xca, 0x16, 0x2c, 0x58, 0x30, 0x9d, 0x4d, 0x1f, 0x82, 0x82,
0x82, 0x02, 0x8b, 0x8b, 0x8b, 0x8b, 0x50, 0x3d, 0x8a, 0xba, 0x95, 0x41,
0x45, 0xf7, 0x1a, 0x18, 0x18, 0x18, 0x76, 0xeb, 0xd6, 0x4d, 0x71, 0x96,
0x52, 0x7f, 0xc7, 0x8e, 0x1d, 0x07, 0x1a, 0x34, 0x68, 0xa0, 0xcd, 0x9e,
0x15, 0xcd, 0xae, 0x41, 0xdc, 0x9f, 0xa1, 0xad, 0xad, 0xad, 0xe3, 0xec,
0xec, 0xec, 0x5a, 0x9b, 0x77, 0xa2, 0xa2, 0xa2, 0x22, 0xc4, 0x62, 0x71,
0x6d, 0x1d, 0xc9, 0x29, 0x64, 0xdf, 0x18, 0x8c, 0xec, 0x14, 0x80, 0x91,
0x4d, 0x21, 0x9b, 0x67, 0x1d, 0x94, 0xd7, 0x85, 0xb2, 0x0e, 0x2f, 0x62,
0xff, 0xdf, 0x00, 0x4c, 0x9b, 0xf9, 0xc8, 0x96, 0x4b, 0x65, 0x8e, 0xfc,
0xf8, 0x60, 0x64, 0x54, 0xd1, 0xc6, 0x64, 0x28, 0x77, 0xbe, 0x29, 0x44,
0x45, 0xd9, 0xa3, 0xd8, 0xb0, 0x06, 0x6c, 0x9a, 0x3e, 0xa2, 0x7c, 0x6c,
0x62, 0x84, 0xf2, 0x76, 0x53, 0xe1, 0xca, 0x24, 0xf6, 0x1d, 0x45, 0xdf,
0xa2, 0x18, 0x63, 0x29, 0xfa, 0xa4, 0xcf, 0x8e, 0x4b, 0xb2, 0xf9, 0xd0,
0x85, 0xfa, 0xb1, 0x1e, 0x00, 0xe8, 0x25, 0x27, 0x27, 0xa7, 0xe7, 0xe4,
0xe4, 0x68, 0xb6, 0x69, 0xd3, 0xe6, 0x47, 0x30, 0x46, 0xb9, 0x62, 0x5c,
0xa7, 0x01, 0xa0, 0x55, 0x46, 0x46, 0xc6, 0xcd, 0xc4, 0xc4, 0xc4, 0x82,
0x8e, 0x1d, 0x3b, 0xda, 0xb1, 0x65, 0xa2, 0x88, 0x53, 0xb5, 0x4f, 0x55,
0xee, 0x4b, 0x95, 0xd3, 0xaf, 0x68, 0x5f, 0x55, 0x8d, 0x27, 0x45, 0xa8,
0xbc, 0x1d, 0xeb, 0xec, 0xd8, 0xb1, 0xe3, 0xf6, 0xfc, 0xf9, 0xf3, 0xbb,
0x7a, 0x79, 0x79, 0x6d, 0xb9, 0x73, 0xe7, 0xce, 0x4a, 0x54, 0x1c, 0x53,
0x2a, 0xda, 0x1c, 0xf0, 0xf9, 0xed, 0x3a, 0x0a, 0x5d, 0x46, 0xa3, 0xfc,
0x16, 0x0b, 0x01, 0xaa, 0x5e, 0x14, 0x51, 0x38, 0x6b, 0x54, 0x38, 0x19,
0x36, 0x56, 0xca, 0x0f, 0x50, 0xbe, 0xd8, 0xa4, 0xd0, 0xff, 0x3a, 0xec,
0xa3, 0xd0, 0x87, 0xb5, 0x2d, 0x1f, 0xe5, 0xba, 0xd2, 0x63, 0x65, 0x47,
0xe1, 0xdc, 0x54, 0x91, 0x0e, 0x45, 0x38, 0xdd, 0x85, 0x0b, 0x17, 0x9e,
0xdf, 0xb6, 0x6d, 0x5b, 0xff, 0x21, 0x43, 0x86, 0xec, 0xbc, 0x7c, 0xf9,
0xf2, 0x46, 0x56, 0x2e, 0xaa, 0x93, 0x4f, 0x75, 0xf2, 0x26, 0x19, 0x3c,
0x78, 0xf0, 0xf2, 0x4b, 0x97, 0x2e, 0xcd, 0x5f, 0xbc, 0x78, 0xf1, 0xcd,
0xad, 0x5b, 0xb7, 0x8e, 0x60, 0xeb, 0x80, 0xaa, 0x22, 0x0f, 0xea, 0x50,
0xf4, 0x6b, 0x7a, 0x28, 0xf7, 0xe9, 0xa3, 0x70, 0x02, 0xa6, 0x18, 0x0f,
0x57, 0xa5, 0x9f, 0x15, 0xe3, 0x7a, 0x53, 0xb6, 0xfe, 0xf2, 0xf1, 0xb9,
0x6e, 0x13, 0xb0, 0xf1, 0x2a, 0xe2, 0x57, 0x8c, 0xe5, 0xc5, 0x6c, 0x7d,
0xa8, 0x6b, 0x2f, 0x8a, 0xf2, 0x56, 0x18, 0xc9, 0x8a, 0x3e, 0x5d, 0x15,
0x85, 0xce, 0xa5, 0x50, 0xd1, 0xa1, 0xaa, 0x42, 0x4e, 0x14, 0x8e, 0x3c,
0x15, 0xfa, 0x41, 0xd1, 0x87, 0x2b, 0x6c, 0x2d, 0x75, 0xf5, 0xab, 0x3c,
0xfe, 0xf9, 0x94, 0x9e, 0x81, 0x03, 0x07, 0xfe, 0x70, 0xe5, 0xca, 0x95,
0x23, 0x2b, 0x56, 0xac, 0x48, 0xdd, 0xb0, 0x61, 0x83, 0x3b, 0x9b, 0x0f,
0xd5, 0xb2, 0xd1, 0x44, 0xd5, 0x0b, 0x9a, 0x8a, 0x71, 0x8e, 0xba, 0x71,
0x9d, 0x4e, 0x8b, 0x16, 0x2d, 0xd6, 0x84, 0x86, 0x86, 0xfe, 0x9c, 0x9f,
0x9f, 0x5f, 0xb2, 0x6d, 0xdb, 0xb6, 0x6d, 0xa1, 0xa1, 0xa1, 0xc1, 0x55,
0x1c, 0x4b, 0x31, 0xbe, 0x7b, 0xf7, 0xee, 0x7b, 0xa9, 0x54, 0x2a, 0xef,
0xdb, 0xb7, 0x6f, 0x33, 0x7c, 0x7e, 0x2b, 0x16, 0x00, 0xa0, 0x7b, 0xf7,
0xee, 0xbd, 0xdb, 0xb4, 0x69, 0xd3, 0x61, 0xf1, 0xe2, 0xc5, 0x8b, 0x8d,
0x8d, 0x8d, 0x75, 0xdd, 0xdc, 0xdc, 0xb6, 0x45, 0x44, 0x44, 0xac, 0xc4,
0x3f, 0x74, 0x4f, 0xf9, 0xdf, 0x09, 0x0f, 0x7f, 0xef, 0xb5, 0x21, 0xea,
0xae, 0x39, 0xfa, 0x4f, 0x40, 0xa1, 0x7c, 0x8b, 0xc7, 0xdf, 0x91, 0x9e,
0x2f, 0x8d, 0x9f, 0xc2, 0xdf, 0x5f, 0xfe, 0x35, 0x89, 0x9f, 0x87, 0xea,
0x1d, 0x34, 0x7c, 0x4d, 0xfc, 0xc6, 0xbf, 0xfd, 0xf6, 0x5b, 0x4c, 0xcf,
0x9e, 0x3d, 0x83, 0x51, 0x0b, 0x67, 0x5b, 0xff, 0x65, 0x28, 0xea, 0xb8,
0x3a, 0xb4, 0xc0, 0x38, 0x7c, 0x9b, 0x02, 0x66, 0xdb, 0xef, 0x19, 0x30,
0x5e, 0xab, 0x97, 0x82, 0x59, 0xb1, 0xfa, 0x4f, 0x3b, 0xa9, 0x50, 0xe4,
0xe3, 0xbf, 0xa1, 0x5d, 0x7e, 0x09, 0xff, 0xe9, 0xb4, 0x2b, 0xda, 0xec,
0x7f, 0x3a, 0x1d, 0xff, 0x09, 0xfe, 0x89, 0xfe, 0xc2, 0x80, 0xcf, 0xe7,
0x2f, 0xfc, 0xeb, 0xaf, 0xbf, 0x44, 0x84, 0x10, 0x12, 0x19, 0x19, 0xf9,
0x5e, 0x20, 0x10, 0x68, 0x7f, 0x65, 0xbc, 0x7f, 0xb7, 0xfe, 0xff, 0xa7,
0xca, 0xe7, 0xdf, 0x8a, 0x85, 0x58, 0x2c, 0xa6, 0x55, 0xb7, 0x40, 0xba,
0xb8, 0xb8, 0x74, 0xc1, 0xd7, 0xd5, 0x07, 0xe5, 0xe2, 0xe2, 0xd2, 0x45,
0x35, 0xde, 0xaf, 0x5c, 0x39, 0xa7, 0x9a, 0x36, 0x6d, 0xda, 0xa6, 0xba,
0xed, 0x9b, 0xaa, 0xd8, 0xdb, 0xdb, 0xbb, 0x7e, 0x45, 0x5e, 0xbe, 0x54,
0x27, 0xd7, 0xb4, 0x4f, 0x52, 0xa6, 0x36, 0x32, 0x5a, 0xdb, 0xb8, 0xbf,
0x65, 0xdf, 0x62, 0xfa, 0xfe, 0xfd, 0x7b, 0x51, 0x69, 0x69, 0xa9, 0xdc,
0xda, 0xda, 0xba, 0xa5, 0x4a, 0x9c, 0xd4, 0xc4, 0x89, 0x13, 0xe7, 0x13,
0x42, 0xc8, 0x6f, 0xbf, 0xfd, 0x16, 0x8f, 0xcf, 0xb7, 0x04, 0xff, 0x2d,
0xa8, 0x7a, 0xce, 0xb7, 0xb6, 0xb6, 0x6e, 0x92, 0x9b, 0x9b, 0x2b, 0x92,
0x4a, 0xa5, 0xc4, 0xd2, 0xd2, 0x72, 0x3c, 0xbe, 0xec, 0xd6, 0x87, 0x7f,
0x13, 0x55, 0xc9, 0xce, 0xa7, 0x95, 0xf3, 0xc1, 0x83, 0x07, 0xef, 0x40,
0xf9, 0xf1, 0xc1, 0xda, 0xc8, 0x90, 0x22, 0xac, 0xd6, 0xe0, 0xc1, 0x83,
0x77, 0xa8, 0x59, 0x39, 0xff, 0xda, 0xb4, 0xf3, 0x51, 0x7b, 0xfd, 0x5c,
0x53, 0x99, 0xfe, 0x92, 0xb6, 0xf8, 0x5f, 0x81, 0x91, 0x91, 0x51, 0x9d,
0xa4, 0xa4, 0xa4, 0x9c, 0xa2, 0xa2, 0x22, 0xda, 0xc4, 0xc4, 0x64, 0x03,
0xbe, 0x4d, 0x79, 0xab, 0xa2, 0x01, 0xa0, 0x73, 0xff, 0xfe, 0xfd, 0xd3,
0x43, 0x43, 0x43, 0x45, 0x84, 0x10, 0x12, 0x1c, 0x1c, 0xfc, 0x16, 0x95,
0xb7, 0x99, 0x9a, 0xac, 0x9c, 0x6b, 0x3e, 0x7d, 0xfa, 0x34, 0x9a, 0x10,
0x42, 0x42, 0x42, 0x42, 0x44, 0xfd, 0xfb, 0xf7, 0x4f, 0x07, 0xb3, 0xba,
0xff, 0x9f, 0x1e, 0x63, 0xd7, 0xaa, 0x50, 0x2a, 0xe3, 0xef, 0xbe, 0x22,
0xeb, 0x9f, 0xba, 0x82, 0xab, 0x3a, 0x14, 0xab, 0x80, 0xff, 0x6d, 0xf1,
0x2b, 0xdf, 0x4f, 0xf9, 0x77, 0x50, 0xd3, 0xf2, 0xff, 0xd2, 0x7a, 0xaa,
0xe9, 0x7b, 0xd2, 0x25, 0x4b, 0x96, 0x1c, 0x04, 0xb3, 0xad, 0xa6, 0xb8,
0x86, 0xef, 0xfc, 0xb7, 0x51, 0xd3, 0x3a, 0x16, 0x83, 0xd9, 0x89, 0x92,
0x02, 0xa6, 0xed, 0x29, 0xae, 0x00, 0x53, 0x5c, 0xe7, 0xf7, 0x4f, 0xdc,
0x19, 0xff, 0x2d, 0xf2, 0xf1, 0xdf, 0xca, 0x7f, 0x3a, 0xed, 0x7f, 0x77,
0x9b, 0xfd, 0x6f, 0xe6, 0x9f, 0xe8, 0x2f, 0x84, 0x72, 0xb9, 0xfc, 0xcf,
0x51, 0xa3, 0x46, 0x39, 0xef, 0xdf, 0xbf, 0x7f, 0x64, 0x44, 0x44, 0x44,
0x99, 0x54, 0x2a, 0x55, 0xec, 0x1e, 0xf9, 0x52, 0xfe, 0x29, 0x99, 0xff,
0x6f, 0xe9, 0xef, 0xfe, 0xdb, 0xa0, 0x5b, 0xb4, 0x68, 0x11, 0x0f, 0xc6,
0xc7, 0x80, 0x88, 0x10, 0x42, 0x28, 0x8a, 0x12, 0x26, 0x24, 0x24, 0xc8,
0xc0, 0x5e, 0x33, 0xfa, 0x85, 0xf1, 0xf2, 0x62, 0x62, 0x62, 0x64, 0x4e,
0x4e, 0x4e, 0xef, 0x08, 0x21, 0xfa, 0x14, 0x45, 0x51, 0x84, 0x10, 0x1d,
0x42, 0x88, 0xea, 0xea, 0x56, 0xad, 0xe2, 0x4c, 0x4c, 0x4c, 0x44, 0xb3,
0x66, 0xcd, 0xde, 0xe0, 0x73, 0x1f, 0x12, 0x95, 0x51, 0x94, 0x92, 0x92,
0x42, 0x81, 0xbd, 0xe2, 0xf3, 0x0b, 0xbe, 0xf9, 0x35, 0xe3, 0x87, 0xda,
0xbe, 0x57, 0x9b, 0x72, 0xa9, 0x6d, 0xdc, 0xdf, 0xb2, 0x9d, 0x91, 0x35,
0x6b, 0xd6, 0x24, 0xfd, 0xf9, 0xe7, 0x9f, 0x8e, 0x6f, 0xde, 0xbc, 0x79,
0xf8, 0xe2, 0xc5, 0x8b, 0x90, 0x98, 0x98, 0x98, 0x58, 0x13, 0x13, 0x13,
0x63, 0x37, 0x37, 0x37, 0x37, 0x47, 0x47, 0x47, 0xfb, 0xe0, 0xe0, 0x60,
0xf1, 0x9a, 0x35, 0x6b, 0x2e, 0xe0, 0x9f, 0xb9, 0xfe, 0x88, 0x3a, 0x7f,
0xfe, 0xfc, 0xa5, 0xb6, 0x6d, 0xdb, 0xb6, 0x49, 0x48, 0x48, 0x48, 0xd2,
0xd6, 0xd6, 0xd6, 0x6e, 0xdb, 0xb6, 0x6d, 0x6b, 0x1e, 0x8f, 0xc7, 0x5b,
0xbe, 0x7c, 0x79, 0x7e, 0x56, 0x56, 0x56, 0x28, 0xfe, 0x5d, 0xbb, 0x01,
0xbf, 0x84, 0xda, 0xb6, 0xa9, 0xda, 0xca, 0xc3, 0xdf, 0xa9, 0xa3, 0xbf,
0x54, 0x1f, 0xd4, 0x34, 0x0f, 0xff, 0xaa, 0x71, 0x95, 0x86, 0x86, 0x86,
0xe6, 0xad, 0x5b, 0xb7, 0xfc, 0x01, 0xa0, 0x63, 0xc7, 0x8e, 0xed, 0x75,
0x75, 0x75, 0xb5, 0x27, 0x4c, 0x98, 0x90, 0x96, 0x9f, 0x9f, 0x7f, 0x12,
0x7f, 0xcf, 0x55, 0x92, 0x32, 0x00, 0xe1, 0x37, 0x6e, 0xdc, 0x98, 0x77,
0xe3, 0xc6, 0x8d, 0x49, 0x9a, 0x9a, 0x9a, 0x76, 0xa6, 0xa6, 0xa6, 0x6f,
0xc0, 0xec, 0x84, 0xa8, 0x6e, 0x97, 0x6e, 0x65, 0xe8, 0x0c, 0x19, 0x32,
0xe4, 0x4d, 0x5e, 0x5e, 0x1e, 0x4f, 0x22, 0x91, 0x24, 0x80, 0x39, 0xba,
0x13, 0x8e, 0x7f, 0x51, 0x3b, 0xfc, 0xd7, 0xcc, 0x22, 0x70, 0xfc, 0xbf,
0xa5, 0x14, 0xcc, 0x99, 0x68, 0xc5, 0xfd, 0xdc, 0xff, 0xdf, 0xa1, 0xf1,
0xcf, 0xdc, 0x95, 0xcb, 0xc1, 0xf1, 0xff, 0x0d, 0x02, 0x20, 0x5b, 0x2e,
0x97, 0xaf, 0x98, 0x3a, 0x75, 0x6a, 0x16, 0x98, 0xf3, 0x9f, 0xa5, 0x5f,
0x19, 0x27, 0xc7, 0x7f, 0x96, 0xc2, 0x77, 0xef, 0xde, 0x8d, 0x42, 0xc5,
0xe3, 0x23, 0x72, 0x30, 0x47, 0x84, 0xbe, 0x66, 0x42, 0x83, 0x16, 0x8b,
0xc5, 0xaf, 0xa3, 0xa3, 0xa3, 0xc7, 0xa3, 0xe2, 0xaa, 0x95, 0xe2, 0x38,
0xca, 0x17, 0xc5, 0x29, 0x91, 0x48, 0xde, 0xbd, 0x7b, 0xf7, 0x6e, 0x22,
0x6a, 0x3e, 0x76, 0x92, 0x81, 0x99, 0x90, 0xfd, 0x5f, 0x9d, 0xb4, 0xfb,
0x3b, 0x10, 0x9d, 0x3e, 0x7d, 0x7a, 0xcb, 0xdb, 0xb7, 0x6f, 0xd7, 0xfd,
0xf8, 0xe3, 0x8f, 0xda, 0x0e, 0x0e, 0x0e, 0x4e, 0xee, 0xee, 0xee, 0xcd,
0xb2, 0xb2, 0xb2, 0x24, 0xf7, 0xef, 0xdf, 0x17, 0xcc, 0x9d, 0x3b, 0x37,
0xe3, 0xce, 0x9d, 0x3b, 0xcf, 0xc1, 0xf8, 0x58, 0xf8, 0x27, 0xb6, 0xb0,
0xea, 0x5f, 0xb8, 0x70, 0x41, 0x23, 0x3f, 0x3f, 0x5f, 0xa3, 0x61, 0xc3,
0x86, 0x4d, 0x29, 0x8a, 0xd2, 0x38, 0x7e, 0xfc, 0x78, 0xe9, 0xf1, 0xe3,
0xc7, 0x45, 0x0f, 0x1e, 0x3c, 0xd8, 0x05, 0xc6, 0x0f, 0xc3, 0xff, 0xf4,
0xe4, 0x5c, 0x76, 0x76, 0x76, 0x71, 0x78, 0x78, 0xb8, 0xa4, 0xb0, 0xb0,
0xf0, 0x4b, 0xef, 0xb5, 0xff, 0x44, 0x61, 0x61, 0xa1, 0x30, 0x3c, 0x3c,
0x5c, 0x92, 0x95, 0x95, 0xf5, 0x6f, 0x5d, 0xcc, 0xf9, 0xaf, 0x86, 0x10,
0x62, 0x28, 0x14, 0x0a, 0xed, 0xea, 0xd4, 0xa9, 0xa3, 0x7f, 0xfd, 0xfa,
0x75, 0xa9, 0xaf, 0xaf, 0x6f, 0x61, 0x40, 0x40, 0xc0, 0x1a, 0x30, 0x7e,
0x43, 0xfe, 0x2e, 0x39, 0x2e, 0x05, 0x70, 0x05, 0x40, 0x80, 0x44, 0x22,
0xd1, 0xcd, 0xcc, 0xcc, 0xd4, 0x04, 0x73, 0xbc, 0x40, 0x6d, 0x12, 0x63,
0x63, 0x63, 0x8b, 0x65, 0x32, 0x59, 0x55, 0x13, 0x1e, 0xc2, 0xcc, 0xcc,
0xcc, 0x9f, 0xc1, 0xd8, 0x14, 0xb5, 0x39, 0xaa, 0xfc, 0x5f, 0xc3, 0xff,
0xda, 0xd6, 0x4b, 0x0e, 0x0e, 0x0e, 0x0e, 0x8e, 0x7f, 0x37, 0x8a, 0xb3,
0x88, 0x72, 0xa8, 0x3f, 0x93, 0xca, 0xf1, 0xef, 0x42, 0xdd, 0x96, 0x4f,
0x1a, 0x5f, 0x5f, 0xaf, 0x95, 0x1d, 0x0d, 0xfb, 0x9a, 0x55, 0xac, 0x2f,
0x39, 0x6e, 0xf6, 0x2d, 0xf2, 0xc2, 0x51, 0x8e, 0xe2, 0x3c, 0xbe, 0x3b,
0x18, 0x47, 0x93, 0xb6, 0xec, 0xbf, 0x0b, 0xc1, 0x9c, 0x69, 0x7f, 0x0c,
0xc6, 0x81, 0x61, 0x2e, 0xfe, 0x19, 0xa3, 0x58, 0x0b, 0xcc, 0xb5, 0x51,
0x9d, 0xc1, 0x38, 0xb9, 0x13, 0x80, 0x71, 0xd8, 0x76, 0x8b, 0x4d, 0x4b,
0x11, 0xfe, 0xb7, 0xeb, 0x5f, 0x0b, 0x8c, 0x23, 0xc3, 0x61, 0x00, 0xf6,
0x81, 0x71, 0x2c, 0xf9, 0xa5, 0x3b, 0x1a, 0x04, 0x60, 0x1c, 0x10, 0xce,
0x04, 0xe0, 0x07, 0xc6, 0x21, 0xf3, 0xbf, 0xca, 0xe8, 0xfa, 0x17, 0x60,
0x0c, 0x60, 0x23, 0x18, 0x87, 0x7c, 0x39, 0x60, 0x1c, 0xc9, 0x06, 0x42,
0xbd, 0xbf, 0x92, 0xbf, 0x03, 0xc5, 0x4e, 0xa3, 0xca, 0xda, 0xae, 0x3e,
0x98, 0x1b, 0xa3, 0x68, 0x30, 0xc7, 0x43, 0x2b, 0x33, 0xe2, 0x79, 0xf8,
0x17, 0xef, 0x66, 0xe4, 0x8c, 0x73, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e,
0x0e, 0x0e, 0x8e, 0x7f, 0x13, 0x1a, 0x60, 0xb6, 0xbe, 0x2a, 0xce, 0xfd,
0x2a, 0xb6, 0x0f, 0x4b, 0xf0, 0xcf, 0xee, 0xc2, 0xa3, 0xc0, 0x9c, 0x8f,
0xd5, 0x44, 0xb9, 0x2f, 0x25, 0xc5, 0xc4, 0xe1, 0x3f, 0xb1, 0xad, 0xfe,
0xbf, 0x1d, 0xe5, 0xab, 0x6a, 0x45, 0xf8, 0xfa, 0xba, 0xd1, 0x04, 0xe3,
0xcc, 0x4e, 0x8c, 0xea, 0x1d, 0xbf, 0x71, 0xd4, 0x1e, 0x85, 0x03, 0x39,
0x1e, 0xca, 0x77, 0x7a, 0xfe, 0x37, 0xed, 0x6a, 0x55, 0x4c, 0xce, 0x2b,
0x9c, 0x7c, 0x73, 0xf5, 0xcf, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1,
0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1,
0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1,
0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1,
0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1,
0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1,
0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1,
0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1,
0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1,
0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1,
0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1,
0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1,
0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1,
0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1,
0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1,
0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1,
0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1,
0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1,
0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1,
0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1,
0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1,
0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1,
0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1,
0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1,
0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1,
0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1,
0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1,
0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1,
0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xf1, 0xaf, 0xe1, 0xff,
0x00, 0xae, 0xcb, 0x68, 0x01, 0xdb, 0x49, 0x15, 0x4b, 0x00, 0x00, 0x00,
0x25, 0x74, 0x45, 0x58, 0x74, 0x64, 0x61, 0x74, 0x65, 0x3a, 0x63, 0x72,
0x65, 0x61, 0x74, 0x65, 0x00, 0x32, 0x30, 0x31, 0x34, 0x2d, 0x31, 0x32,
0x2d, 0x32, 0x37, 0x54, 0x31, 0x39, 0x3a, 0x34, 0x38, 0x3a, 0x35, 0x33,
0x2b, 0x30, 0x38, 0x3a, 0x30, 0x30, 0x1b, 0xe6, 0x7d, 0x34, 0x00, 0x00,
0x00, 0x25, 0x74, 0x45, 0x58, 0x74, 0x64, 0x61, 0x74, 0x65, 0x3a, 0x6d,
0x6f, 0x64, 0x69, 0x66, 0x79, 0x00, 0x32, 0x30, 0x31, 0x34, 0x2d, 0x31,
0x32, 0x2d, 0x32, 0x37, 0x54, 0x31, 0x39, 0x3a, 0x34, 0x37, 0x3a, 0x35,
0x32, 0x2b, 0x30, 0x38, 0x3a, 0x30, 0x30, 0x3d, 0xc7, 0x95, 0xb1, 0x00,
0x00, 0x00, 0x00, 0x49, 0x45, 0x4e, 0x44, 0xae, 0x42, 0x60, 0x82,
}
```

`gfx/dbg/glsl100.go`:

```go
// +build android ios windows js

package dbg

var vsh = `
#version 100

uniform mat4 projection;

attribute vec4 xyuv;
attribute vec4 rgba;

varying vec4 outColor;
varying vec2 outTexCoord;

void main() {
    outColor = rgba;
	outTexCoord = xyuv.zw;
    gl_Position = projection * vec4(xyuv.xy, 1, 1);
}
` + "\x00"

var fsh = `
#version 100

#ifdef GL_ES
	precision mediump float;
#endif

uniform sampler2D tex;

varying vec4 outColor;
varying vec2 outTexCoord;

void main() {
	if (outTexCoord.x == 2.0) {
		gl_FragColor = outColor;
	} else {
		gl_FragColor = outColor * texture2D(tex, outTexCoord);
	}
}
` + "\x00"

```

`gfx/dbg/glsl330.go`:

```go
// +build !android,!ios,!windows,!js

package dbg

var vsh = `
#version 330

uniform mat4 projection;

in vec4 xyuv;
in vec4 rgba;

out vec4 outColor;
out vec2 outTexCoord;

void main() {
    outColor = rgba;
	outTexCoord = xyuv.zw;

    gl_Position = projection * vec4(xyuv.xy, 1, 1);
}
` + "\x00"

var fsh = `
#version 330

uniform sampler2D tex;

in vec2 outTexCoord;
in vec4 outColor;

out vec4 outputColor;
void main() {
	if (outTexCoord.x == 2.0) {
		outputColor = outColor;
	} else {
	    outputColor = outColor * texture(tex, outTexCoord);
	}
}
` + "\x00"

```

`gfx/dbg/hud.go`:

```go
package dbg

import (
	"fmt"
)

func LogFPS(fps, drawCall int) {
	hud.fps = fps
	hud.drawCall = drawCall
	if DEBUG != None {
		hud.drawCall = drawCall-1
	}
}

func Hud(format string, args... interface{}) {
	hud.verbs = append(hud.verbs, fmt.Sprintf(format, args...))
}

func HudFunc(fn func() string) {
	hud.verbs = append(hud.verbs, fn())
}

// Game internal state.
type HudLog struct {
	verbs []string
	drawCall, fps int
}

func (hud *HudLog) draw() {
	var (
		x = gRender.view.x - gRender.view.w/2
		y = gRender.view.y - gRender.view.h/2
	)

	// draw fps & draw call
	if (DEBUG & FPS) != 0 {
		drawFps(x, y, hud.fps)
		drawDrawCall(x, y, hud.drawCall)
	}

	// draw string
	if (DEBUG & Stats) != 0 {
		d := float32(0)
		x += 10
		y += gRender.view.h - 20
		for _, str := range hud.verbs {
			gBuffer.String(x, y-d, str, .6)
			d += 10
		}
	}
}

func (hud *HudLog) reset() {
	hud.verbs = hud.verbs[:0]
}

func drawFps(x, y float32, fps int) {
	Color(0xFF000000)
	gBuffer.Rect(x+5, y+5, 50, 6)

	// format: RGBA
	Color(0xFF00FF00)

	w := float32(fps)/60 * 50
	gBuffer.Rect(x+5, y+5, w, 5)

	// format: RGBA
	Color(0xFF000000)

	gBuffer.String(x+5, y+10, fmt.Sprintf("%d fps", fps), .6)
}

func drawDrawCall(x,y float32, dc int) {
	gBuffer.String(x+5, y+25, fmt.Sprintf("DrawCall: %d", hud.drawCall), .6)
}
```

`gfx/font/bitmap.go`:

```go
package font

import (
	"io"

	"encoding/json"
	"image"
	_ "image/jpeg"
	_ "image/png"
	"io/ioutil"
)

// LoadBitmap loads a bitmap (raster) fontAtlas from the given
// sprite sheet and config files. It is optionally scaled by
// the given scale factor.
//
// A scale factor of 1 retains the original size. A factor of 2 doubles the
// fontAtlas size, etc. A scale factor of 0 is not valid and will default to 1.
//
// Supported image formats are 32-bit RGBA as PNG, JPEG.
func LoadBitmap(img, config io.Reader, scale int) (Font, error) {
	f := &fontAtlas{glyphs: make(map[rune]Glyph)}

	// load texture
	pix, _, err := image.Decode(img)
	if err != nil {
		return nil, err
	}
	err = f.loadTex(toRGBA(pix, scale))
	if err != nil {
		return nil, err
	}
	// load glyph data
	fc := &fontConfig{}
	data, err := ioutil.ReadAll(config)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(data, fc)
	if err != nil {
		return nil, err
	}
	var gh, gw int
	// add glyphs
	for _, g := range fc.Glyphs {
		f.addGlyphs(g.Id, Glyph{
			Rune: g.Id,
			X:    float32(g.X), Y: float32(g.Y),
			Width:   float32(g.Width),
			Height:  float32(g.Height),
			XOffset: float32(g.XOffset),
			YOffset: float32(g.YOffset),
			Advance: g.Advance,
		})
		if g.Width > gw {
			gw = g.Width
		}
		if g.Height > gh {
			gh = g.Height
		}
	}
	f.gWidth = float32(gw)
	f.gHeight = float32(gh)
	// log.Println("dump:", f)
	return f, nil
}

type fontConfig struct {
	Dir Direction `json:"direction"`

	// Lower rune boundary
	Low rune `json:"rune_low"`

	// Upper rune boundary.
	High rune `json:"rune_high"`

	// Glyphs holds a set of glyph descriptors, defining the location,
	// size and advance of each glyph in the sprite sheet.
	Glyphs []struct {
		Id      rune `json:"id,string"`
		X       int  `json:"x,string"`
		Y       int  `json:"y,string"`
		Width   int  `json:"width,string"`
		Height  int  `json:"height,string"`
		XOffset int  `json:"xoffset,string"`
		YOffset int  `json:"yoffset,string"`
		Advance int  `json:"advance,string"`
	} `json:"glyphs"`
}

```

`gfx/font/config.go`:

```go
package font

type Directional interface {
	Direction() Direction
}

type TTFConfig interface {
	FontSize() int
	Runes() []rune
}

// TTF config based on range
type rangeTTFConfig struct {
	Low, High uint32
	Size int
}

func (fc rangeTTFConfig) FontSize() int {
	return fc.Size
}

func (fc rangeTTFConfig) Runes() (runes []rune) {
	if fc.Low == fc.High && fc.Low == 0{
		fc.Low = 32
		fc.High = 127
	}
	runes = make([]rune, fc.High-fc.Low+1)
	for i,j := fc.Low, fc.High; i <= j; i++ {
		runes[i-fc.Low] = rune(i)
	}
	return
}

func (rangeTTFConfig) Direction() Direction {
	return LeftToRight
}

// TTF config based on runes collection
type ttfConfig struct {
	size int
	runes []rune
}

func (ttf ttfConfig) FontSize() int {
	return ttf.size
}

func (ttf ttfConfig) Runes() []rune {
	return ttf.runes
}

func (ttfConfig) Direction() Direction {
	return LeftToRight
}

func NewTTFConfig(size int, runes []rune) TTFConfig {
	return ttfConfig{size:size, runes:runes}
}

func ASCII(size int) TTFConfig {
	return rangeTTFConfig{Size:size, Low:32, High:127}
}











```

`gfx/font/font.go`:

```go
package font

import (
	"korok.io/korok/math/f32"
	"korok.io/korok/gfx/bk"

	"image"
	"image/color"

	"unicode/utf8"
)

// Direction represents the direction in which strings should be rendered.
type Direction uint8

// Known directions.
const (
	LeftToRight Direction = iota // E.g.: Latin
	RightToLeft                  // E.g.: Arabic
	TopToBottom                  // E.g.: Old-Chinese
)

// Font provides all the information needed to render a Rune.
//
// Tex2D returns the low-level bk-texture.
// Glyph returns the matrix of rune.
// Bounds returns the largest width and height for any of the glyphs
// in the fontAtlas.
// SizeOf measure the text and returns the width and height.
type Font interface {
	Tex2D() (uint16, *bk.Texture2D)
	Glyph(rune rune) (g Glyph, ok bool)
	Bounds() (gw, gh float32)
	Frame(rune rune) (x1, y1, x2, y2 float32)
}

type Disposer interface {
	Dispose()
}

// A fontAtlas allows rendering ofg text to an OpenGL context
type fontAtlas struct {
	id uint16

	texWidth float32
	texHeight float32

	gWidth  float32 // Largest glyph width.
	gHeight float32 // Largest glyph height.

	glyphs map[rune]Glyph
	w, h uint16

	regions []float32

	// fallback
}

func (f *fontAtlas) Tex2D() (id uint16, tex *bk.Texture2D) {
	id = f.id
	if ok, t := bk.R.Texture(id); ok {
		tex = t
	}
	return
}

// implement fontAtlas-system
func (f *fontAtlas) Glyph(rune rune) (g Glyph, ok bool) {
	g, ok = f.glyphs[rune]
	return
}

func (f *fontAtlas) Bounds() (float32, float32) {
	return f.gWidth, f.gHeight
}

func (f *fontAtlas) Frame(r rune) (u1, v1, u2, v2 float32) {
	g := f.glyphs[r]
	u1, v1 = float32(g.X)/ f.texWidth, float32(g.Y)/ f.texHeight
	u2, v2 = float32(g.X+g.Width)/ f.texWidth, float32(g.Y+g.Height)/ f.texHeight
	return
}

// Release release fontAtlas resources.
func (f *fontAtlas) Dispose() {
	bk.R.Free(f.id)
}

func (f *fontAtlas) addGlyphs(r rune, g Glyph) {
	f.glyphs[r] = g
}

func (f *fontAtlas) loadTex(img *image.RGBA) error {
	// Resize image to power-of-two.
	img = Pow2Image(img).(*image.RGBA)
	ib := img.Bounds()

	// add a white pixel at (0, 0)
	img.Set(0,0, color.White)

	f.texWidth = float32(ib.Dx())
	f.texHeight = float32(ib.Dy())

	if id, _ := bk.R.AllocTexture(img); id != bk.InvalidId {
		f.id = id
	}
	return checkGLError()
}

func Wrap(font Font, text string, wrap, fontSize float32) (n int, lines string) {
	size := len(text)
	line := make([]byte, 0, size)
	buff := make([]byte, 0, size*2)
	_, gh := font.Bounds()
	scale := fontSize/gh

	for i, w := 0, 0; i < size;{
		var lineSize float32
		var lastSpace = -1

		for j := 0 ; i < size; i, j = i+w, j+w {
			r, width := utf8.DecodeRuneInString(text[i:])
			w = width

			if r == '\n' {
				i, j = i+w, j+w
				goto NEW_LINE
			}

			line = append(line, text[i:i+w]...)
			if g, ok :=  font.Glyph(r); ok {
				lineSize += float32(g.Advance) * scale
			} else {
				// todo fallback ?
			}
			if r == ' ' || r == '\t' {
				lastSpace = j
			}

			if lineSize > wrap {
				i, j = i+w, j+w
				break
			}
		}

		// reach the end
		if lineSize < wrap {
			buff = append(buff, line...)
			n += 1
			break
		}

		if len(line) == 0 {

		}

		// if has space, break! or remove last char to fit line-width
		if lastSpace > 0 {
			i -= len(line) - lastSpace

			//log.Println("trim last space i:", i, "lastSpace:", lastSpace, "lineSize:", len(line))
			line = line[:lastSpace]
		} else {
			i -= w
			line = line[:len(line)-w]
		}

	NEW_LINE:
		line = append(line, '\n')
		buff = append(buff, line...)
		line = line[:0]
		n += 1
	}
	return n, string(buff)
}

func CalculateTextSize(text string, font Font, fontSize float32) f32.Vec2 {
	_, gh := font.Bounds()
	scale := fontSize/gh
	size := f32.Vec2{0, fontSize}

	for i, w := 0, 0; i < len(text); i += w {
		r, width := utf8.DecodeRuneInString(text[i:])
		w = width
		g, _ := font.Glyph(r)
		if r >= 32 {
			size[0] += float32(g.Advance) * scale
		}
	}
	return size
}
```

`gfx/font/glyph.go`:

```go
package font

type Point struct {
	X, Y float32
}

// A Glyph describes metrics for a single Font glyph.
// These indicate which area of a given image contains the
// glyph data and how the glyph should be spaced in a rendered string.
//
// Advance determines the distance to the next glyph.
// This is used to properly align non-monospaced fonts.
type Glyph struct {
	Rune rune

	X      float32
	Y      float32
	Width  float32
	Height float32

	XOffset float32
	YOffset float32

	Advance int
}

```

`gfx/font/misc.go`:

```go
package font

import (
	"korok.io/korok/hid/gl"

	"image"
	"fmt"
)

// toRGBA translate the given image to RGBA format if necessary.
// Optionally scales it by the given amount
func toRGBA(src image.Image, scale int) *image.RGBA {
	if scale < 1 {
		scale = 1
	}

	dst, ok := src.(*image.RGBA)
	if ok && scale == 1 {
		return dst
	}

	// Scale image to match new size
	ib := src.Bounds()
	rect := image.Rect(0, 0, ib.Dx()*scale, ib.Dy()*scale)

	if !ok {
		// Image is not RGBA, so we create it
		dst = image.NewRGBA(rect)
	}

	for sy := 0; sy < ib.Dy(); sy++ {
		for sx := 0; sx < ib.Dx(); sx++ {
			dx := sx * scale
			dy := sy * scale
			pixel := src.At(sx, sy)

			for scy := 0; scy < scale; scy++ {
				for scx := 0; scx < scale; scx++ {
					dst.Set(dx+scx, dy+scy, pixel)
				}
 			}
		}
	}
	return dst
}

// checkGLError returns an opengl error if one exists
func checkGLError() error {
	errno := gl.GetError()
	if errno == gl.NO_ERROR {
		return nil
	}

	return fmt.Errorf("GL error: %d", errno)
}


```

`gfx/font/pow2.go`:

```go
package font

import (
	"korok.io/korok/math"
	"image"
	"fmt"
	"image/color"
)

// Pow2Image returns the given image, scaled to the smallest power-of-two
// dimensions larger or equal to the input dimensions.
// It preserves the image format and contents.
//
// This is useful if an image is to be used as an OpenGL Texture.
// These often require image data to have power-of-two dimensions.
func Pow2Image(src image.Image) image.Image {
	sb := src.Bounds()
	w, h := uint32(sb.Dx()), uint32(sb.Dy())

	if math.IsPow2(w) && math.IsPow2(h) {
		return src // Nothing to do.
	}

	rect := image.Rect(0, 0, int(math.Pow2(w)), int(math.Pow2(h)))

	switch src := src.(type) {
	case *image.Alpha:
		return copyImg(src, image.NewAlpha(rect))
	case *image.Alpha16:
		return copyImg(src, image.NewAlpha16(rect))
	case *image.Gray:
		return copyImg(src, image.NewGray(rect))
	case *image.Gray16:
		return copyImg(src, image.NewGray16(rect))
	case *image.NRGBA:
		return copyImg(src, image.NewNRGBA(rect))
	case *image.NRGBA64:
		return copyImg(src, image.NewNRGBA64(rect))
	case *image.Paletted:
		return copyImg(src, image.NewPaletted(rect, src.Palette))
	case *image.RGBA:
		return copyImg(src, image.NewRGBA(rect))
	case *image.RGBA64:
		return copyImg(src, image.NewRGBA64(rect))
	}

	panic(fmt.Sprintf("Unsupported image format: %T", src))
}

//
type copyable interface {
	image.Image
	Set(x, y int, clr color.Color)
}

func copyImg(src, dst copyable) image.Image {
	var x, y int
	sb := src.Bounds()

	for y = 0; y < sb.Dy(); y++ {
		for x = 0; x < sb.Dx(); x++ {
			dst.Set(x, y, src.At(x, y))
		}
	}
	return dst
}



```

`gfx/font/truetype.go`:

```go
package font

import (
	"github.com/golang/freetype/truetype"
	"golang.org/x/image/math/fixed"

	"image"
	"image/draw"
	"image/png"
	"io"
	"io/ioutil"
	"log"
	"os"
)

// http://www.freetype.org/freetype2/docs/tutorial/step2.html

// LoadTrueType loads a truetype fontAtlas from the given stream and
// applies the given fontAtlas scale in points.
//
// The low and high values determine the lower and upper rune limits
// we should load for this Font. For standard ASCII this would be:32, 127.
func LoadTrueType(r io.Reader, lc TTFConfig) (*fontAtlas, error) {
	data, err := ioutil.ReadAll(r)
	if err != nil {
		return nil, err
	}

	// Read the TrueType Font
	ttf, err := truetype.Parse(data)
	if err != nil {
		return nil, err
	}

	// Create an image(512*512) to store all requested glyphs.
	iw, ih := 1024, 1024
	_, fg := image.Black, image.White
	rect := image.Rect(0, 0, iw, ih)
	img := image.NewRGBA(rect)
	padding := fixed.I(2)

	// Use a FreeType context to do the drawing.
	face := truetype.NewFace(ttf, &truetype.Options{
		Size: float64(lc.FontSize()),
		DPI:  72,
	})

	// new font-atlas
	f := &fontAtlas{glyphs: make(map[rune]Glyph)}

	// Iterate over all relevant glyphs in the truetype fontAtlas and
	// draw them all to the image buffer.
	var (
		gb = ttf.Bounds(fixed.I(lc.FontSize()))
		gw = gb.Max.X - gb.Min.X
		gh = gb.Max.Y - gb.Min.Y
		hh = face.Metrics().Ascent + face.Metrics().Descent
		ah = face.Metrics().Ascent
	)

	width := fixed.I(iw)
	dot := fixed.Point26_6{X: padding, Y: padding}
	adjust := padding / 2

	//for ch := low; ch <= high; ch++ {
	for _, ch := range lc.Runes() {
		bb, advance, ok := face.GlyphBounds(ch)
		if !ok {
			continue
		}
		gw := bb.Max.X - bb.Min.X
		gh := bb.Max.Y - bb.Min.Y

		// draw to canvas
		if x := dot.X + gw; x > width {
			dot.X = padding
			dot.Y += hh + padding
		}

		d := dot
		d.Y -= bb.Min.Y
		d.X -= bb.Min.X
		dr, mask, mp, _, ok := face.Glyph(d, ch)
		if !ok {
			continue
		}
		draw.DrawMask(img, dr, fg, image.Point{}, mask, mp, draw.Over)

		// record glyph region
		g := Glyph{
			Rune:    ch,
			Advance: int(advance.Floor()),
			X:       fixed2f32(dot.X - adjust),
			Y:       fixed2f32(dot.Y - adjust),
			Width:   fixed2f32(gw + padding),
			Height:  fixed2f32(gh + padding),

			XOffset: fixed2f32(bb.Min.X),
			YOffset: fixed2f32(ah + bb.Min.Y - padding),
		}

		// add padding
		dot.X += gw + padding

		// add to glyph-array
		f.addGlyphs(ch, g)
	}

	// set bounds
	f.gWidth = fixed2f32(gw)
	f.gHeight = fixed2f32(gh)

	// load image
	err = f.loadTex(img)
	if err != nil {
		return nil, err
	}
	// save baked fontAtlas-image
	//savePng(img)
	return f, nil
}

func fixed2f32(fixed fixed.Int26_6) float32 {
	return float32(fixed) / (1 << 6)
}

// debug only.
func savePng(img image.Image) {
	f, err := os.Create("ttf.png")
	if err != nil {
		log.Println(err)
		return
	}
	defer f.Close()
	err = png.Encode(f, img)
	if err != nil {
		log.Println(err)
	}
}

```

`gfx/gctx.go`:

```go
package gfx

import (
	"korok.io/korok/gfx/bk"
	"unsafe"
	"sort"
)

// graphics context
// a wrapper for bk-api

const SharedIndexBufferSize uint16 = 0xFFFF

func Init(pixelRatio float32) {
	bk.Init()
	bk.Reset(480, 320, pixelRatio)

	// Enable debug text
	bk.SetDebug(bk.DebugResMan |bk.DebugQueue)
}

func Flush() (num int) {
	num = bk.Flush()
	Context.Step()
	return
}

func Destroy() {
	bk.Destroy()
	Context.Destroy()
}

// 目前各个 RenderFeature 都是自己管理 VBO/IBO，但是对于一些系统，比如
// Batch/ParticleSystem(2D中的大部分元素)，都是可以复用VBO的，顶点数据
// 需要每帧动态生成，如此可以把这些需要动态申请的Buffer在此管理起来，对应的
// CPU 数据可以在 StackAllocator 上申请，一帧之后就自动释放。
type tempBuffer struct {
	vb *bk.VertexBuffer
	size int
	stride int
	id uint16
	use uint16
}

type context struct {
	Stack StackAllocator
	temps []tempBuffer

	shared struct{
		id uint16
		padding uint16
		index []uint16
		size int
	}
}

// 一帧之后自动释放
func (ctx *context) TempVertexBuffer(reqSize, stride int) (id uint16, size int, vb *bk.VertexBuffer){
	var (
		buffer tempBuffer
		found bool
	)
	for i, tb := range ctx.temps {
		if tb.use == 0 && tb.stride == stride && tb.size >= reqSize {
			ctx.temps[i].use = 1
			buffer = tb;found = true; break
		}
	}
	if !found {
		buffer = ctx.newVertexBuffer(reqSize, stride)
		ctx.temps = append(ctx.temps, buffer)
	}
	id, size, vb = buffer.id, buffer.size, buffer.vb
	return
}

func (ctx *context) newVertexBuffer(vertexSize,stride int) tempBuffer {
	{
		vertexSize--
		vertexSize |= vertexSize >> 1
		vertexSize |= vertexSize >> 2
		vertexSize |= vertexSize >> 3
		vertexSize |= vertexSize >> 8
		vertexSize |= vertexSize >> 16
		vertexSize++
	}
	tb := tempBuffer{size:vertexSize, stride: stride, use:1}
	if id, vb := bk.R.AllocVertexBuffer(bk.Memory{nil,uint32(vertexSize* stride)}, uint16(stride)); id != bk.InvalidId {
		tb.id = id
		tb.vb = vb
	}
	return tb
}

func (ctx *context) release() {
	for i := range ctx.temps {
		ctx.temps[i].use = 0
	}
	sort.Slice(ctx.temps, func(i, j int) bool {
		return ctx.temps[i].size < ctx.temps[j].size
	})
}

func (ctx *context) Step() {
	ctx.release()
	ctx.Stack.release()
}

func (ctx *context) Destroy() {
	// destroy any release!
}

// 64kb, format={3, 0, 1, 3, 1, 2}
func (ctx *context) SharedIndexBuffer () (id uint16, size int) {
	if ctx.shared.index == nil {
		ctx.initIndexBuffer()
	}
	return ctx.shared.id, ctx.shared.size
}

func (ctx *context) initIndexBuffer () {
	indexSize := int(SharedIndexBufferSize)
	ctx.shared.index = make([]uint16, indexSize)
	size := int(indexSize)
	iFormat := [6]uint16 {3, 0, 1, 3, 1, 2}
	for i := 0; i < size; i += 6 {
		copy(ctx.shared.index[i:], iFormat[:])
		iFormat[0] += 4
		iFormat[1] += 4
		iFormat[2] += 4
		iFormat[3] += 4
		iFormat[4] += 4
		iFormat[5] += 4
	}
	if id, _ := bk.R.AllocIndexBuffer(bk.Memory{unsafe.Pointer(&ctx.shared.index[0]), uint32(size) * 2}); id != bk.InvalidId {
		ctx.shared.id = id
		ctx.shared.size = size
	}
}

// global shared
var Context *context

// Stack capacity ~ 100K
func init() {
	Context = &context{}; Context.Stack.initialize(100*1024)
}
```

`gfx/mesh.go`:

```go
package gfx

import (
	"korok.io/korok/math/f32"
	"korok.io/korok/gfx/bk"
	"korok.io/korok/engi"

	"unsafe"
	"korok.io/korok/math"
)

/// MeshComp and MeshTable

type Mesh struct {
	// vertex data <x,y,u,v>
	vertex []PosTexColorVertex
	index  []uint16

	// res handle
	textureId uint16
	padding   uint16

	IndexId   uint16
	VertexId  uint16

	FirstVertex uint16
	NumVertex   uint16

	FirstIndex uint16
	NumIndex   uint16
}

type MeshComp struct {
	engi.Entity
	Mesh
	zOrder
	size f32.Vec2
	visible bool
}

func (m *MeshComp) Size() (w, h float32) {
	return m.size[0], m.size[1]
}

func (m *MeshComp) SetSize(width, height float32) {
	m.size[0], m.size[1] = width, height
}

func (m *MeshComp) SetVisible(v bool) {
	m.visible = v
}

func (m *Mesh) Setup() {
	mem_v := bk.Memory{unsafe.Pointer(&m.vertex[0]), uint32(len(m.vertex)) * 20 }
	if id, _:= bk.R.AllocVertexBuffer(mem_v, 20); id != bk.InvalidId {
		m.VertexId = id
	}

	mem_i := bk.Memory{unsafe.Pointer(&m.index[0]), uint32(len(m.index)) * 2}
	if id, _:= bk.R.AllocIndexBuffer(mem_i); id != bk.InvalidId {
		m.IndexId = id
	}

	m.FirstVertex = 0
	m.NumVertex = uint16(len(m.vertex))
	m.FirstIndex = 0
	m.NumIndex = uint16(len(m.index))
}

func (m*Mesh) SetTexture(id uint16) {
	m.textureId = id
}

func (m*Mesh) SetVertex(v []PosTexColorVertex) {
	m.vertex = v
}

func (m*Mesh) SetIndex(v []uint16) {
	m.index = v
}


func (m *Mesh) Update() {
	if ok, ib := bk.R.IndexBuffer(m.IndexId); ok {
		ib.Update(0, uint32(len(m.index)) * uint32(UInt16Size), unsafe.Pointer(&m.index[0]), false)
	}

	if ok, vb := bk.R.VertexBuffer(m.VertexId); ok {
		vb.Update(0, uint32(len(m.vertex)) * uint32(PosTexColorVertexSize), unsafe.Pointer(&m.vertex[0]), false)
	}
}

func (m*Mesh) Delete() {
	if ok, ib := bk.R.IndexBuffer(m.IndexId); ok {
		ib.Destroy()
	}
	if ok, vb := bk.R.VertexBuffer(m.VertexId); ok {
		vb.Destroy()
	}
	if ok, tex := bk.R.Texture(m.textureId); ok {
		tex.Destroy()
	}
}

// Configure VAO/VBO TODO
// 如果每个Sprite都创建一个VBO还是挺浪费的，
// 但是如果不创建新的VBO，那么怎么处理纹理坐标呢？
// 2D 场景中会出现大量模型和纹理相同的物体，仅仅
// 位置不同，比如满屏的子弹
// 或许可以通过工厂来构建mesh，这样自动把重复的mesh丢弃
// mesh 数量最终 <= 精灵的数量
var vertices = []float32{
	// Pos      // Tex
	0.0, 1.0, 0.0, 1.0,
	1.0, 0.0, 1.0, 0.0,
	0.0, 0.0, 0.0, 0.0,

	0.0, 1.0, 0.0, 1.0,
	1.0, 1.0, 1.0, 1.0,
	1.0, 0.0, 1.0, 0.0,
}


type MeshTable struct {
	comps []MeshComp
	_map  map[uint32]int
	index, cap int
}

func NewMeshTable(cap int) *MeshTable {
	return &MeshTable{cap:cap, _map:make(map[uint32]int)}
}

func (mt *MeshTable) NewComp(entity engi.Entity) (mc *MeshComp) {
	if size := len(mt.comps); mt.index >= size {
		mt.comps = meshResize(mt.comps, size + STEP)
	}
	ei := entity.Index()
	if v, ok := mt._map[ei]; ok {
		return &mt.comps[v]
	}

	mc = &mt.comps[mt.index]
	mc.Entity = entity
	mc.size = f32.Vec2{64, 64}
	mc.visible = true
	mt._map[ei] = mt.index
	mt.index ++
	return
}

func (mt *MeshTable) Alive(entity engi.Entity) bool {
	if v, ok := mt._map[entity.Index()]; ok {
		return mt.comps[v].Entity == 0
	}
	return false
}

func (mt *MeshTable) Comp(entity engi.Entity) (mc *MeshComp) {
	if v, ok := mt._map[entity.Index()]; ok {
		mc = &mt.comps[v]
	}
	return
}

func (mt *MeshTable) Delete(entity engi.Entity) {
	ei := entity.Index()
	if v, ok := mt._map[ei]; ok {
		if tail := mt.index -1; v != tail && tail > 0 {
			mt.comps[v] = mt.comps[tail]
			// remap index
			tComp := mt.comps[tail]
			ei := tComp.Entity.Index()
			mt._map[ei] = v
			mt.comps[tail] = MeshComp{}
		} else {
			mt.comps[tail] = MeshComp{}
		}

		mt.index -= 1
		delete(mt._map, ei)
	}
}

func (mt *MeshTable) Destroy() {
	mt.comps = make([]MeshComp, 0)
	mt._map = make(map[uint32]int)
	mt.index = 0
}

func (mt *MeshTable) Size() (size, cap int) {
	return mt.index, mt.cap
}

func meshResize(slice []MeshComp, size int) []MeshComp {
	newSlice := make([]MeshComp, size)
	copy(newSlice, slice)
	return newSlice
}

/////
type MeshRenderFeature struct {
	Stack *StackAllocator
	id int

	R *MeshRender
	mt *MeshTable
	xt *TransformTable
}

// 此处初始化所有的依赖
func (f *MeshRenderFeature) Register(rs *RenderSystem) {
	// init render
	for _, r := range rs.RenderList {
		switch br := r.(type) {
		case *MeshRender:
			f.R = br; break
		}
	}
	// init table
	for _, t := range rs.TableList {
		switch table := t.(type){
		case *MeshTable:
			f.mt = table
		case *TransformTable:
			f.xt = table
		}
	}
	// add new feature
	f.id = rs.Accept(f)
}

func (f *MeshRenderFeature) Extract(v *View) {
	var (
		camera = v.Camera
		xt     = f.xt
		fi = uint32(f.id) << 16
	)
	for i, m := range f.mt.comps[:f.mt.index] {
		if xf := xt.Comp(m.Entity); m.visible && camera.InView(xf,m.size,f32.Vec2{.5, .5}) {
			sid := PackSortId(m.zOrder.value, 0)
			val := fi + uint32(i)
			v.RenderNodes = append(v.RenderNodes, SortObject{sid, val})
		}
	}
}

func (f *MeshRenderFeature) Draw(nodes RenderNodes) {
	xt, mt := f.xt, f.mt
	mr := f.R
	mat4 := f32.Ident4()

	for _, b := range nodes {
		mesh := &mt.comps[b.Value&0xFFFF]
		entity := mesh.Entity
		xf  := xt.Comp(entity)
		srt := xf.world

		// construct matrix from scale/rotation/translate
		c, s := math.Cos(srt.Rotation), math.Sin(srt.Rotation)

		mat4[0] = c*srt.Scale[0]
		mat4[1] = s*srt.Scale[0]
		mat4[4] = -s*srt.Scale[1]
		mat4[5] = c*srt.Scale[1]
		mat4[8] = srt.Position[0]
		mat4[9] = srt.Position[1]

		mat4[10] = 1
		mat4[15] = 1

		mr.Draw(&mesh.Mesh, &mat4, int32(mesh.zOrder.value))
	}
}

func (f *MeshRenderFeature) Flush() {

}

```

`gfx/mesh_render.go`:

```go
package gfx

import (
	"korok.io/korok/math/f32"
	"korok.io/korok/gfx/bk"

	"unsafe"
)

/// Simple Mesh TypeRender
/// For simple mesh, not 3D model

type MeshRender struct {
	stateFlags uint64
	rgba       uint32

	// shader program
	program uint16

	// uniform handle
	umhProjection uint16 // Projection
	umhModel      uint16 // Model
	umhSampler0   uint16 // Sampler0
}

func NewMeshRender(vsh, fsh string) *MeshRender {
	mr := new(MeshRender)
	// blend func
	mr.stateFlags |= bk.ST_BLEND.ALPHA_PREMULTIPLIED

	// setup shader
	if id, sh := bk.R.AllocShader(vsh, fsh); id != bk.InvalidId {
		mr.program = id
		sh.Use()

		// setup attribute
		sh.AddAttributeBinding("xyuv\x00", 0, P4C4[0])
		sh.AddAttributeBinding("rgba\x00", 0, P4C4[1])

		s0 := int32(0)
		// setup uniform
		if pid, _ := bk.R.AllocUniform(id, "proj\x00", bk.UniformMat4, 1); pid != bk.InvalidId {
			mr.umhProjection = pid
		}

		if mid, _ := bk.R.AllocUniform(id, "model\x00", bk.UniformMat4, 1); mid != bk.InvalidId {
			mr.umhModel = mid
		}

		if sid,_ := bk.R.AllocUniform(id, "tex\x00", bk.UniformSampler, 1); sid != bk.InvalidId {
			mr.umhSampler0 = sid
			bk.SetUniform(sid, unsafe.Pointer(&s0))
		}

		// submit render state
		// bk.Touch(0)
		bk.Submit(0, id, 0)
	}
	return mr
}

func (mr *MeshRender) SetCamera(camera *Camera) {
	left, right, bottom, top := camera.P()
	p := f32.Ortho2D(left, right, bottom, top)

	// setup uniform
	bk.SetUniform(mr.umhProjection, unsafe.Pointer(&p[0]))
	bk.Submit(0, mr.program, 0)
}

type RenderMesh struct {
	*Mesh
	Matrix []float32
}

// extract render object
func (mr *MeshRender) Extract(visibleObjects []uint32) {

}

// draw
func (mr *MeshRender) Draw(m *Mesh, mat4 *f32.Mat4, depth int32) {
	// state
	bk.SetState(mr.stateFlags, mr.rgba)
	bk.SetTexture(0, mr.umhSampler0, m.textureId, 0)

	// set uniform - mvp
	bk.SetUniform(mr.umhModel, unsafe.Pointer(&mat4[0]))

	// set vertex
	bk.SetVertexBuffer(0, m.VertexId, uint32(m.FirstVertex), uint32(m.NumVertex))
	bk.SetIndexBuffer(m.IndexId, uint32(m.FirstIndex), uint32(m.NumIndex))
	//
	bk.Submit(0, mr.program, depth)
}

```

`gfx/render_system.go`:

```go
package gfx

import (
	"korok.io/korok/math/f32"
	"korok.io/korok/engi"
	"sort"
	"korok.io/korok/gfx/dbg"
)

type RenderType int32

type Render interface {
	SetCamera(camera *Camera)
}

// 适合于渲染系统访问的表达方式.
// 其实不必这么麻烦，我们在 RenderFeature里面涉及一个 Extract 步骤，构建一个渲染列表，然后再绘制即可.
// 这个列表需要动态构建
//type renderObject struct {
//
//}

// Shared properties by most render object.
type RenderObject struct {
	engi.Entity
	Size f32.Vec2
	Center f32.Vec2
	ZOrder int16
	BatchId uint16
}

type RenderNodes []SortObject

func (nodes RenderNodes) Len() int           { return len(nodes) }
func (nodes RenderNodes) Swap(i, j int)      { nodes[i], nodes[j] = nodes[j], nodes[i] }
func (nodes RenderNodes) Less(i, j int) bool { return nodes[i].SortId < nodes[j].SortId }

type View struct {
	*Camera
	RenderNodes
}

// 传入参数是经过可见性系统筛选后的 Entity，这是一个很小的数组，可以
// 直接传给各个 RenderFeature 来做可见性判断.
type RenderFeature interface {
	Extract(v *View)
	Draw(nodes RenderNodes)
	Flush()
}

// 所有的Table和Render都在此管理
// 其它的 RenderFeature 在此提取依赖
// 这样的话， RenderSystem 就沦为一个管理 RenderFeature 和 Table 的地方
// 它们之间也会存在各种组合...
type RenderSystem struct {
	MainCamera Camera
	View

	// shortcut for TransformTable
	xfs *TransformTable

	// visibility test
	V VisibilitySystem

	// render-data
	TableList []interface{}

	// render
	RenderList []Render

	// feature knows how to use render-data and render
	FeatureList []RenderFeature
}

func (th *RenderSystem) RequireTable(tables []interface{}) {
	th.TableList = tables
	for _, table := range tables {
		if t, ok := table.(*TransformTable); ok {
			th.xfs = t; break
		}
	}
}

func (th *RenderSystem) Accept(rf RenderFeature) (index int){
	index = len(th.FeatureList)
	th.FeatureList = append(th.FeatureList, rf)
	return
}

// register type-render
func (th *RenderSystem) RegisterRender(t RenderType, render Render) {
	th.RenderList = append(th.RenderList, render)
}

func (th *RenderSystem) Update(dt float32) {
	// update camera
	if c := &th.MainCamera; c.follow != engi.Ghost {
		xf := th.xfs.Comp(c.follow)
		p  := xf.Position()
		dx := (p[0]-c.mat.x)*.1
		dy := (p[1]-c.mat.y)*.1
		c.MoveBy(dx, dy)
	}

	// main camera
	for _, r := range th.RenderList {
		r.SetCamera(&th.MainCamera)
	}
	if dbg.DEBUG != dbg.None {
		dbg.SetCamera(th.MainCamera.View())
	}

	// build view
	v := th.View

	// extract
	for _, f := range th.FeatureList {
		f.Extract(&v)
	}

	// sort
	var (
		nodes, n = v.RenderNodes, len(v.RenderNodes)
	)
	//sort.Slice(nodes, func(i, j int) bool {
	//	return nodes[i].SortId < nodes[j].SortId
	//})
	sort.Stable(nodes)

	// draw
	for i, j := 0, 0; i < n; i = j {
		fi := nodes[i].Value >>16
		j = i+1
		for j < n && nodes[j].Value>>16 == fi {
			j++
		}
		f := th.FeatureList[fi]
		f.Draw(v.RenderNodes[i:j])
	}

	// flush, release any resource
	for _, f := range  th.FeatureList {
		f.Flush()
	}


	// view reset
	th.View.RenderNodes = th.View.RenderNodes[:0]
}

func (th *RenderSystem) Destroy() {

}

func NewRenderSystem() (rs *RenderSystem) {
	rs = &RenderSystem{MainCamera:Camera{follow:engi.Ghost}}
	rs.View.Camera = &rs.MainCamera
	rs.View.RenderNodes = make([]SortObject, 0)
	rs.MainCamera.initialize()
	return
}

```

`gfx/shape.go`:

```go
package gfx

type ShapeRender struct {

}

func (sr *ShapeRender) DrawRect() {

}

func (sr *ShapeRender) DrawCircle() {

}

func (sr *ShapeRender) DrawLine() {

}

func (sr *ShapeRender) DrawTriangle() {

}

func (sr *ShapeRender) DrawPolygon() {

}

```

`gfx/sprite.go`:

```go
package gfx

import (
	"korok.io/korok/math/f32"
	"korok.io/korok/engi"
)

// Sprite is Tex2D
type Sprite Tex2D

// SpriteComp & SpriteTable
// Usually, sprite can be rendered with a BatchRenderer
type SpriteComp struct {
	engi.Entity
	Sprite
	zOrder
	batchId

	color uint32
	flipX uint16
	flipY uint16

	width float32
	height float32
	gravity struct{
		x, y float32
	}
	visible bool
}

func (sc *SpriteComp) SetSprite(spt Sprite) {
	sc.Sprite = spt
	sc.batchId.value = spt.Tex()

	// optional size
	if sc.width == 0 || sc.height == 0 {
		size := spt.Size()
		sc.width = size.Width
		sc.height = size.Height
	}
}

func (sc *SpriteComp) SetSize(w, h float32) {
	sc.width, sc.height = w, h
}

func (sc *SpriteComp) Size() (w, h float32) {
	w, h = sc.width, sc.height
	return
}

func (sc *SpriteComp) SetGravity(x, y float32) {
	sc.gravity.x = x
	sc.gravity.y = y
}

func (sc *SpriteComp) Gravity() (x, y float32) {
	return sc.gravity.x, sc.gravity.y
}

func (sc *SpriteComp) SetVisible(v bool) {
	sc.visible = v
}

func (sc *SpriteComp) Visible() bool {
	return sc.visible
}

func (sc *SpriteComp) Color() Color {
	return U32Color(sc.color)
}

func (sc *SpriteComp) SetColor(c Color) {
	sc.color = c.U32()
}

func (sc *SpriteComp) Flip(flipX, flipY bool) {
	if flipX {
		sc.flipX = 1
	} else {
		sc.flipX = 0
	}
	if flipY {
		sc.flipY = 1
	} else {
		sc.flipY = 0
	}
}

type SpriteTable struct {
	comps []SpriteComp
	_map   map[uint32]int
	index, cap int
}

func NewSpriteTable(cap int) *SpriteTable {
	return &SpriteTable{
		cap:cap,
		_map:make(map[uint32]int),
	}
}

func (st *SpriteTable) NewComp(entity engi.Entity) (sc *SpriteComp) {
	if size := len(st.comps); st.index >= size {
		st.comps = spriteResize(st.comps, size + STEP)
	}
	ei := entity.Index()
	if v, ok := st._map[ei]; ok {
		sc = &st.comps[v]
		return
	}
	sc = &st.comps[st.index]
	sc.Entity = entity
	sc.gravity.x, sc.gravity.y = .5, .5
	sc.color = 0xFFFFFFFF
	sc.visible = true
	st._map[ei] = st.index
	st.index ++
	return
}

// New SpriteComp with parameter
func (st *SpriteTable) NewCompX(entity engi.Entity, spt Tex2D) (sc *SpriteComp) {
	sc = st.NewComp(entity)
	sc.SetSprite(spt)
	return
}

func (st *SpriteTable) Alive(entity engi.Entity) bool {
	ei := entity.Index()
	if v, ok := st._map[ei]; ok {
		return st.comps[v].Entity != 0
	}
	return false
}

func (st *SpriteTable) Comp(entity engi.Entity) (sc *SpriteComp) {
	ei := entity.Index()
	if v, ok := st._map[ei]; ok {
		sc = &st.comps[v]
	}
	return
}

func (st *SpriteTable) Delete(entity engi.Entity) {
	ei := entity.Index()
	if v, ok := st._map[ei]; ok {
		if tail := st.index -1; v != tail && tail > 0 {
			st.comps[v] = st.comps[tail]
			// remap index
			tComp := st.comps[tail]
			ei := tComp.Entity.Index()
			st._map[ei] = v
			st.comps[tail] = SpriteComp{}
		} else {
			st.comps[tail] = SpriteComp{}
		}

		st.index -= 1
		delete(st._map, ei)
	}
}

func (st *SpriteTable) Size() (size, cap int) {
	return st.index, st.cap
}

func (st *SpriteTable) Destroy() {
	st.comps = make([]SpriteComp, 0)
	st._map = make(map[uint32]int)
	st.index = 0
}

func spriteResize(slice []SpriteComp, size int) []SpriteComp {
	newSlice := make([]SpriteComp, size)
	copy(newSlice, slice)
	return newSlice
}

/////
type SpriteRenderFeature struct {
	Stack *StackAllocator
	id int

	R *BatchRender
	st *SpriteTable
	xt *TransformTable
}

func (f *SpriteRenderFeature) SetRender(render *BatchRender) {
	f.R = render
}

func (f *SpriteRenderFeature) SetTable(st *SpriteTable, xt *TransformTable) {
	f.st, f.xt = st, xt
}

// 此处初始化所有的依赖
func (f *SpriteRenderFeature) Register(rs *RenderSystem) {
	// init render
	for _, r := range rs.RenderList {
		switch br := r.(type) {
		case *BatchRender:
			f.R = br; break
		}
	}
	// init table
	for _, t := range rs.TableList {
		switch table := t.(type){
		case *SpriteTable:
			f.st = table
		case *TransformTable:
			f.xt = table
		}
	}
	// add new feature, use the index as id
	f.id = rs.Accept(f)
}

func (f *SpriteRenderFeature) Extract(v *View) {
	var (
		camera = v.Camera
		xt     = f.xt
		fi = uint32(f.id) << 16
	)
	for i, spr := range f.st.comps[:f.st.index] {
		xf := xt.Comp(spr.Entity)
		sz := f32.Vec2{spr.width, spr.height}
		g  := f32.Vec2{spr.gravity.x, spr.gravity.y}

		if spr.visible && camera.InView(xf,sz , g) {
			sid := PackSortId(spr.zOrder.value, spr.batchId.value)
			val := fi + uint32(i)
			v.RenderNodes = append(v.RenderNodes, SortObject{sid, val})
		}
	}
}

func (f *SpriteRenderFeature) Draw(nodes RenderNodes) {
	var (
		st, xt = f.st, f.xt
		sortId = uint32(0xFFFFFFFF)
		begin = false
		render = f.R
	)

	// batch draw!
	var spriteBatchObject = spriteBatchObject{}
	for _, b := range nodes {
		ii := b.Value & 0xFFFF
		if sid := b.SortId & 0xFFFF; sortId != sid {
			if begin {
				render.End()
			}
			sortId = sid
			begin = true
			tex2d := st.comps[ii].Sprite.Tex()
			depth, _ := UnpackSortId(b.SortId)
			render.Begin(tex2d, depth)
		}
		spriteBatchObject.SpriteComp = &st.comps[ii]
		spriteBatchObject.Transform = xt.Comp(st.comps[ii].Entity)
		render.Draw(spriteBatchObject)
	}
	if begin {
		render.End()
	}
	render.Flush()
}

func (f *SpriteRenderFeature) Flush() {

}


type spriteBatchObject struct {
	*SpriteComp
	*Transform
}

// batch system winding order
//
//		3----------2
//		| . 	   |
//      |   .	   |
//		|     .    |
// 		|		.  |
// 		0----------1
// 1 * 1 quad for each char
// order: 3 0 1 3 1 2
//
// Transform Method:
//
// |
// |
// |
func (sbo spriteBatchObject) Fill(buf []PosTexColorVertex) {
	var (
		srt = sbo.Transform.world
		p = srt.Position
		c = sbo.SpriteComp
		w = sbo.width
		h = sbo.height
	)
	// Texture
	rg := c.Sprite.Region()
	if rg.Rotated {
		if c.flipX == 1 {
			rg.Y1, rg.Y2 = rg.Y2, rg.Y1
		}
		if c.flipY == 1 {
			rg.X1, rg.X2 = rg.X2, rg.X1
		}
		buf[1].U, buf[1].V = rg.X1, rg.Y2
		buf[2].U, buf[2].V = rg.X2, rg.Y2
		buf[3].U, buf[3].V = rg.X2, rg.Y1
		buf[0].U, buf[0].V = rg.X1, rg.Y1
	} else {
		if c.flipY == 1 {
			rg.Y1, rg.Y2 = rg.Y2, rg.Y1
		}
		if c.flipX == 1 {
			rg.X1, rg.X2 = rg.X2, rg.X1
		}
		buf[0].U, buf[0].V = rg.X1, rg.Y2
		buf[1].U, buf[1].V = rg.X2, rg.Y2
		buf[2].U, buf[2].V = rg.X2, rg.Y1
		buf[3].U, buf[3].V = rg.X1, rg.Y1
	}

	// Color
	buf[0].RGBA = c.color
	buf[1].RGBA = c.color
	buf[2].RGBA = c.color
	buf[3].RGBA = c.color

	// Center of model
	ox := w * c.gravity.x
	oy := h * c.gravity.y

	// Transform matrix
	m := f32.Mat3{}; m.Initialize(p[0], p[1], srt.Rotation, srt.Scale[0], srt.Scale[1], ox, oy, 0,0)

	// Let's go!
	buf[0].X, buf[0].Y = m.Transform(0, 0)
	buf[1].X, buf[1].Y = m.Transform(w, 0)
	buf[2].X, buf[2].Y = m.Transform(w, h)
	buf[3].X, buf[3].Y = m.Transform(0, h)

}

func (sbo spriteBatchObject) Size() int {
	return 4
}



```

`gfx/stack_alloc.go`:

```go
package gfx

import "unsafe"

// // This is a stack allocator used for fast per step allocations.
type StackAllocator struct {
	// bottom of the stack
	data uintptr

	// current position and capacity
	alloc, cap int32

	// keep a reference
	ref unsafe.Pointer
}

func (stack *StackAllocator) initialize(max int) {
	mem := make([]byte, max)
	stack.ref = unsafe.Pointer(&mem[0])
	stack.data = uintptr(stack.ref)
}

// Alloc alloc memory on the stack.
func (stack *StackAllocator) Alloc(size int32) (ptr unsafe.Pointer) {
	if req := stack.alloc + size; req < stack.cap {
		ptr = unsafe.Pointer(stack.data + uintptr(stack.alloc))
		stack.alloc += size
	} else {
		tmp := make([]byte, size)
		ptr = unsafe.Pointer(&tmp[0])
	}
	return
}

// Free frees memory on the stack, it should pair with Alloc.
func (stack *StackAllocator) Free(size int32) {
	stack.alloc -= size
	if stack.alloc < 0 {
		stack.alloc = 0
	}
	return
}

// release will empty the stack each frame.
func (stack *StackAllocator) release() {
	stack.alloc = 0
}



```

`gfx/table_test.go`:

```go
package gfx

import (
	"testing"
	"korok.io/korok/engi"
)

// Test CRUD operation for SpriteTable
func TestSpriteTable(t *testing.T) {
	em := &engi.EntityManager{}
	st := NewSpriteTable(1024)

	e1 := em.New()
	xf1 := st.NewComp(e1)

	if xf := st.Comp(e1); xf != xf1 {
		t.Error("fail to create Comp")
	}

	st.Delete(e1)
	if xf := st.Comp(e1); xf != nil {
		t.Error("fail to delete Comp")
	}

	if size, _ := st.Size(); size != 0 {
		t.Error("fail to reset Table state")
	}

	// create 10
	eList := make([]engi.Entity, 10)
	for i := 0; i < 10; i++ {
		e := em.New()
		st.NewComp(e)
		eList[i] = e
	}

	if size, _ := st.Size(); size != len(eList) {
		t.Error("fail to create 10 Comps")
	}

	// delete 5
	for i, e := range eList {
		if i % 2 == 0 {
			st.Delete(e)
		}
	}

	if size, _ := st.Size(); size != len(eList)/2 {
		t.Error("fail to delete Comps")
	}

	// test left
	for i, e := range eList {
		if i % 2 == 1 {
			if comp := st.Comp(e); comp == nil || comp.Entity != e {
				t.Error("fail to keep entity:", e)
			}
		} else {
			if st.Comp(e) != nil {
				t.Error("fail to delete Comps:", e)
			}
		}
	}
}

func TestSpriteTableResize(t *testing.T) {
	em := &engi.EntityManager{}
	st := NewSpriteTable(1024)

	list30 := make([]engi.Entity, 30)
	for i := 0; i < 30; i++ {
		e := em.New()
		st.NewComp(e)
		list30[i] = e
	}

	// will cause resize
	list100 := make([]engi.Entity, 100)
	for i := 0; i < 100; i++ {
		e := em.New()
		st.NewComp(e)
		list100[i] = e
	}

	if size, _ := st.Size(); size != (len(list30) + len(list100)) {
		t.Errorf("fail to create Comps: %d/%d", size, len(list30) + len(list100))
	}

	list := append(list100, list30...)
	for _, e := range list {
		if xf := st.Comp(e); xf == nil || xf.Entity != e {
			t.Error("comp is not create correctly")
		}
	}
}

// Test CRUD operation for TextTable
func TestTextTable(t *testing.T) {
	em := &engi.EntityManager{}
	tt := NewTextTable(1024)

	e1 := em.New()
	xf1 := tt.NewComp(e1)

	if xf := tt.Comp(e1); xf != xf1 {
		t.Error("fail to create Comp")
	}

	tt.Delete(e1)
	if xf := tt.Comp(e1); xf != nil {
		t.Error("fail to delete Comp")
	}

	if size, _ := tt.Size(); size != 0 {
		t.Error("fail to reset Table state")
	}

	// create 10
	eList := make([]engi.Entity, 10)
	for i := 0; i < 10; i++ {
		e := em.New()
		tt.NewComp(e)
		eList[i] = e
	}

	if size, _ := tt.Size(); size != len(eList) {
		t.Error("fail to create 10 Comps")
	}

	// delete 5
	for i, e := range eList {
		if i % 2 == 0 {
			tt.Delete(e)
		}
	}

	if size, _ := tt.Size(); size != len(eList)/2 {
		t.Error("fail to delete Comps")
	}

	// test left
	for i, e := range eList {
		if i % 2 == 1 {
			if comp := tt.Comp(e); comp == nil || comp.Entity != e {
				t.Error("fail to keep entity:", e)
			}
		} else {
			if tt.Comp(e) != nil {
				t.Error("fail to delete Comps:", e)
			}
		}
	}


}

// step=64
func TestTextTableResize(t *testing.T) {
	em := &engi.EntityManager{}
	tt := NewTextTable(1024)

	list30 := make([]engi.Entity, 30)
	for i := 0; i < 30; i++ {
		e := em.New()
		tt.NewComp(e)
		list30[i] = e
	}

	// will cause resize
	list100 := make([]engi.Entity, 100)
	for i := 0; i < 100; i++ {
		e := em.New()
		tt.NewComp(e)
		list100[i] = e
	}

	if size, _ := tt.Size(); size != (len(list30) + len(list100)) {
		t.Errorf("fail to create Comps: %d/%d", size, len(list30) + len(list100))
	}

	list := append(list100, list30...)
	for _, e := range list {
		if xf := tt.Comp(e); xf == nil || xf.Entity != e {
			t.Error("comp is not create correctly")
		}
	}
}

// Test CRUD operation for MeshTable
func TestMeshTable(t *testing.T) {
	em := &engi.EntityManager{}
	mt := NewMeshTable(1024)

	e1 := em.New()
	xf1 := mt.NewComp(e1)

	if xf := mt.Comp(e1); xf != xf1 {
		t.Error("fail to create Comp")
	}

	mt.Delete(e1)
	if xf := mt.Comp(e1); xf != nil {
		t.Error("fail to delete Comp")
	}

	if size, _ := mt.Size(); size != 0 {
		t.Error("fail to reset Table state")
	}

	// create 10
	eList := make([]engi.Entity, 10)
	for i := 0; i < 10; i++ {
		e := em.New()
		mt.NewComp(e)
		eList[i] = e
	}

	if size, _ := mt.Size(); size != len(eList) {
		t.Error("fail to create 10 Comps")
	}

	// delete 5
	for i, e := range eList {
		if i % 2 == 0 {
			mt.Delete(e)
		}
	}

	if size, _ := mt.Size(); size != len(eList)/2 {
		t.Error("fail to delete Comps")
	}

	// test left
	for i, e := range eList {
		if i % 2 == 1 {
			if comp := mt.Comp(e); comp == nil || comp.Entity != e {
				t.Error("fail to keep entity:", e)
			}
		} else {
			if mt.Comp(e) != nil {
				t.Error("fail to delete Comps:", e)
			}
		}
	}


}

// step=64
func TestMeshTableResize(t *testing.T) {
	em := &engi.EntityManager{}
	mt := NewMeshTable(1024)

	list30 := make([]engi.Entity, 30)
	for i := 0; i < 30; i++ {
		e := em.New()
		mt.NewComp(e)
		list30[i] = e
	}

	// will cause resize
	list100 := make([]engi.Entity, 100)
	for i := 0; i < 100; i++ {
		e := em.New()
		mt.NewComp(e)
		list100[i] = e
	}

	if size, _ := mt.Size(); size != (len(list30) + len(list100)) {
		t.Errorf("fail to create Comps: %d/%d", size, len(list30) + len(list100))
	}

	list := append(list100, list30...)
	for _, e := range list {
		if xf := mt.Comp(e); xf == nil || xf.Entity != e {
			t.Error("comp is not create correctly")
		}
	}
}



```

`gfx/text.go`:

```go
package gfx

import (
	"korok.io/korok/engi"
	"korok.io/korok/gfx/font"
	"korok.io/korok/math/f32"
)

// 文字应该采用 BatchRender 绘制
// 如果使用 BatchRender 那么此处生成模型即可

type TextQuad struct {
	// local shit
	xOffset, yOffset float32

	// size
	w, h float32

	// texture
	region Region
}

// TextSprite
type TextComp struct {
	engi.Entity
	font font.Font
	zOrder
	batchId

	size float32
	color uint32

	width float32
	height float32
	gravity struct{
		x, y float32
	}
	visible bool

	// TextModel
	text  string
	vertex []TextQuad
	runeCount int32
}

func (tc *TextComp)  Color() Color {
	return U32Color(tc.color)
}

func (tc *TextComp) SetColor(color Color) {
	tc.color = color.U32()
}

func (tc *TextComp) Text() string {
	return tc.text
}

func (tc *TextComp) SetText(text string) {
	tc.text = text
	// init ebo, vbo
	tc.runeCount  = int32(len(text))

	// fill data
	tc.fillData()
}

func (tc *TextComp) Gravity() (x, y float32) {
	return tc.gravity.x, tc.gravity.y
}

func (tc *TextComp) SetGravity(x, y float32) {
	tc.gravity.x = x
	tc.gravity.y = y
}

func (tc *TextComp) Visible() bool {
	return tc.visible
}

func (tc *TextComp) SetVisible(v bool) {
	tc.visible = v
}

func (tc *TextComp) FontSize() float32 {
	return tc.size
}

func (tc *TextComp) SetFontSize(sz float32) {
	tc.size = sz
}

func (tc *TextComp) Size() (w, h float32) {
	return tc.width, tc.height
}

// generate text-vertex with the string
//
//		+----------+
//		| . 	   |
//      |   .	   |
//		|     .    |
// 		|		.  |
// 		+----------+
// 1 * 1 quad for each char
func (tc *TextComp) fillData() {
	chars := make([]TextQuad, len(tc.text))
	tc.vertex = chars
	_, gh := tc.font.Bounds()

	var (
		size = struct { w, h float32}{}
		scale = tc.size/gh
		xOffset float32
		yOffset float32
	)

	if tc.size == 0 {
		scale = 1.0
	} else {
		gh = tc.size
	}
	yOffset = gh

	for i, r := range tc.text {
		if glyph, ok := tc.font.Glyph(r); ok {
			advance := float32(glyph.Advance) * scale
			vw := glyph.Width * scale
			vh := glyph.Height * scale
			ox := glyph.XOffset * scale
			oy := glyph.YOffset * scale

			u1, v1, u2, v2 := tc.font.Frame(r)
			char := &chars[i]

			char.xOffset = xOffset + ox
			char.yOffset = yOffset - (oy+vh)
			char.w, char.h = vw, vh
			char.region.X1, char.region.Y1 = u1, v1
			char.region.X2, char.region.Y2 = u2, v2

			// left to right shift only!
			xOffset += advance
			yOffset += 0
		}
	}
	size.w = xOffset + chars[len(chars)-1].w
	tc.width = size.w
	tc.height = gh
}

func (tc *TextComp) Font() font.Font {
	return tc.font
}

// should have default font!!
func (tc *TextComp) SetFont(fnt font.Font) {
	tc.font = fnt
	if fnt != nil && tc.batchId.value != 0 {
		tex, _ := fnt.Tex2D()
		tc.batchId.value = tex
	}
}

// TextTable
type TextTable struct {
	comps []TextComp
	_map   map[uint32]int
	index, cap int

}

func NewTextTable(cap int) *TextTable {
	return &TextTable{cap: cap,_map: make(map[uint32]int)}
}

func (tt *TextTable) NewComp(entity engi.Entity) (tc *TextComp) {
	if size := len(tt.comps); tt.index >= size {
		tt.comps = textResize(tt.comps, size + STEP)
	}
	ei := entity.Index()
	if v, ok := tt._map[ei]; ok {
		return &tt.comps[v]
	}

	tc = &tt.comps[tt.index]
	tc.Entity = entity
	tc.color = 0xFFFFFFFF
	tc.gravity.x = .5
	tc.gravity.y = .5
	tc.visible = true
	tt._map[ei] = tt.index;
	tt.index ++
	return
}

func (tt *TextTable) Alive(entity engi.Entity) bool {
	if v, ok := tt._map[entity.Index()]; ok {
		return tt.comps[v].Entity == 0
	}
	return false
}

func (tt *TextTable) Comp(entity engi.Entity) (tc *TextComp) {
	if v, ok := tt._map[entity.Index()]; ok {
		tc = &tt.comps[v]
	}
	return
}

func (tt *TextTable) Delete(entity engi.Entity) (tc *TextComp) {
	ei := entity.Index()
	if v, ok := tt._map[ei]; ok {
		if tail := tt.index -1; v != tail && tail > 0 {
			tt.comps[v] = tt.comps[tail]
			// remap index
			tComp := tt.comps[tail]
			ei := tComp.Entity.Index()
			tt._map[ei] = v
			tt.comps[tail] = TextComp{}
		} else {
			tt.comps[tail] = TextComp{}
		}

		tt.index -= 1
		delete(tt._map, ei)
	}
	return
}

// Destroy Table
func (tt *TextTable) Destroy() {
	tt.comps = make([]TextComp, 0)
	tt._map = make(map[uint32]int)
	tt.index = 0
}

func (tt *TextTable) Size() (size, cap int) {
	return tt.index, tt.cap
}

func textResize(slice []TextComp, size int) []TextComp {
	newSlice := make([]TextComp, size)
	copy(newSlice, slice)
	return newSlice
}


type TextRenderFeature struct {
	Stack *StackAllocator
	R *BatchRender
	id int

	tt *TextTable
	xt *TransformTable
}

// 此处初始化所有的依赖
func (f *TextRenderFeature) Register(rs *RenderSystem) {
	// init render
	for _, r := range rs.RenderList {
		switch br := r.(type) {
		case *BatchRender:
			f.R = br; break
		}
	}

	// init table
	for _, t := range rs.TableList {
		switch table := t.(type){
		case *TextTable:
			f.tt = table
		case *TransformTable:
			f.xt = table
		}
	}
	f.id = rs.Accept(f)
}

func (f *TextRenderFeature) Extract(v *View) {
	var (
		camera = v.Camera
		xt     = f.xt
		fi     = uint32(f.id)<<16
	)

	for i, spr := range f.tt.comps[:f.tt.index] {
		xf := xt.Comp(spr.Entity)
		sz := f32.Vec2{spr.width, spr.height}
		g  := f32.Vec2{spr.gravity.x, spr.gravity.y}

		if spr.visible && camera.InView(xf, sz, g) {
			sid := PackSortId(spr.zOrder.value, spr.batchId.value)
			val := fi + uint32(i)
			v.RenderNodes = append(v.RenderNodes, SortObject{sid, val})
		}
	}
}

func (f *TextRenderFeature) Draw(nodes RenderNodes) {
	var (
		tt, xt = f.tt, f.xt
		sortId  = uint32(0xFFFFFFFF)
		begin = false
		render = f.R
	)

	// batch draw!
	var textBatchObject = textBatchObject{}
	for _, b := range nodes {
		ii := b.Value & 0xFFFF
		if sid := b.SortId & 0xFFFF; sortId != sid {
			if begin {
				render.End()
			}
			sortId = sid
			begin = true
			tex2d, _ := tt.comps[ii].font.Tex2D()
			depth, _ := UnpackSortId(b.SortId)
			render.Begin(tex2d, depth)
		}
		textBatchObject.TextComp = &tt.comps[ii]
		textBatchObject.Transform = xt.Comp(tt.comps[ii].Entity)
		render.Draw(textBatchObject)
	}
	if begin {
		render.End()
	}
	render.Flush()
}

func (f *TextRenderFeature) Flush() {

}

type textBatchObject struct {
	*TextComp
	*Transform
}

// batch system winding order
//
//		3----------2
//		| . 	   |
//      |   .	   |
//		|     .    |
// 		|		.  |
// 		0----------1
// 1 * 1 quad for each char
// order: 3 0 1 3 1 2
func (tbo textBatchObject) Fill(buf []PosTexColorVertex) {
	srt :=  &tbo.Transform.world
	p := tbo.Transform.world.Position
	t := tbo.TextComp

	// Center of model
	ox := t.width * t.gravity.x
	oy := t.height * t.gravity.y

	// Transform matrix
	m := f32.Mat3{}; m.Initialize(p[0], p[1], srt.Rotation, srt.Scale[0], srt.Scale[1], ox, oy, 0,0)


	for i, char := range tbo.vertex {
		vi := i * 4

		// index (0, 0) <x,y,u,v>
		v := &buf[vi+0]
		v.X, v.Y = m.Transform(char.xOffset, char.yOffset)
		v.U, v.V = char.region.X1, char.region.Y2
		v.RGBA = t.color

		// index (1,0) <x,y,u,v>
		v = &buf[vi+1]
		v.X, v.Y = m.Transform(char.xOffset + char.w, char.yOffset)
		v.U, v.V = char.region.X2, char.region.Y2
		v.RGBA = t.color

		// index(1,1) <x,y,u,v>
		v = &buf[vi+2]
		v.X, v.Y = m.Transform(char.xOffset + char.w, char.yOffset + char.h)
		v.U, v.V = char.region.X2, char.region.Y1
		v.RGBA = t.color

		// index(0, 1) <x,y,u,v>
		v = &buf[vi+3]
		v.X, v.Y = m.Transform(char.xOffset, char.yOffset + char.h)
		v.U, v.V = char.region.X1, char.region.Y1
		v.RGBA = t.color
	}
}

func (tbo textBatchObject) Size() int {
	return 4 * len(tbo.vertex)
}



```

`gfx/transform.go`:

```go
package gfx

import (
	"korok.io/korok/math/f32"
	"korok.io/korok/engi"
)

/**
默认情况下，每一个游戏对象都会有个 Transform 组件
为了保证内存紧凑，删除操作采用尾部复制的方式，但是
这样会导致组件的索引变动，通过  _map[]int 来维护
索引变化，这样便可以一直使用 EntityId 来访问组件。

Entity的销毁可以在每帧结束的时候扫描各个系统实现，
这样的效率会更高些。

节点系统会自然的包含组织(父子)关系，此处通过 Transform 组件
来实现类似的效果。
*/

const STEP = 64
const none = 0

type SRT struct {
	Scale f32.Vec2
	Rotation float32
	Position f32.Vec2
}

// 还可以做更细的拆分，把 Matrix 全部放到一个数组里面
// position, position, position .... position
// rotation, rotation, rotation .... rotation
// 把这两个数组申请为一块，然后分两个小组使用
type Transform struct {
	engi.Entity

	// world location
	world SRT
	// relative location to parent
	local SRT

	// graph-link
	parent     uint16
	firstChild uint16
	preSibling uint16
	nxtSibling uint16

	// pointer will cause gc check
	t *TransformTable
}

func (xf *Transform) Position() f32.Vec2 {
	return xf.local.Position
}

func (xf *Transform) Scale() f32.Vec2 {
	return xf.local.Scale
}

func (xf *Transform) Rotation() float32 {
	return xf.local.Rotation
}

func (xf *Transform) Local() SRT {
	return xf.local
}

func (xf *Transform) World() SRT {
	return xf.world
}

// Set local position relative to parent
func (xf *Transform) SetPosition(position f32.Vec2) {
	xf.local.Position = position
	// compute world position
	if xf.parent == none {
		xf.setPosition(nil, position)
	} else {
		xf.setPosition(&xf.t.comps[xf.parent].world, position)
	}
}

func (xf *Transform) MoveBy(dx, dy float32) {
	p := xf.local.Position
	p[0], p[1] = p[0]+dx, p[1]+dy
	xf.SetPosition(p)
}

// update world location: world = parent.world + self.local
func (xf *Transform) setPosition(parent *SRT, local f32.Vec2) {
	p := f32.Vec2{0, 0}
	if parent != nil {
		p = parent.Position
	}
	xf.world.Position[0] = p[0] + local[0]
	xf.world.Position[1] = p[1] + local[1]
	// all child
	for comps, child := xf.t.comps, xf.firstChild; child != none; {
		node := &comps[child]
		child = node.nxtSibling
		node.setPosition(&xf.world, node.local.Position)
	}
}

// apply scale to child
func (xf *Transform) SetScale(scale f32.Vec2) {
	xf.local.Scale = scale
	// compute world scale
	if xf.parent == none {
		xf.setScale(nil, scale)
	} else {
		xf.setScale(&xf.t.comps[xf.parent].world, scale)
	}
}

func (xf *Transform) ScaleBy(dx, dy float32) {
	sk := xf.local.Scale
	sk[0], sk[1] = sk[0]+dx, sk[1]+dy
	xf.SetScale(sk)
}

func (xf *Transform) setScale(parent *SRT, scale f32.Vec2) {
	s := f32.Vec2{1, 1}
	if parent != nil {
		s = parent.Scale
	}
	xf.world.Scale[0] = s[0] * scale[0]
	xf.world.Scale[1] = s[1] * scale[1]

	// all child
	for comps, child := xf.t.comps, xf.firstChild; child != none; {
		node := comps[child]
		child = node.nxtSibling
		node.setPosition(&xf.world, node.local.Position)
	}
}

// apply
func (xf *Transform) SetRotation(rotation float32) {
	xf.local.Rotation = rotation
	// compute world rotation
	if xf.parent == none {
		xf.setRotation(nil, rotation)
	} else {
		xf.setRotation(&xf.t.comps[xf.parent].world, rotation)
	}
}

func (xf *Transform) RotateBy(d float32) {
	r := xf.local.Rotation
	r += d
	xf.SetRotation(r)
}

func (xf *Transform) setRotation(parent *SRT, rotation float32) {
	r := float32(0)
	if parent != nil {
		r = parent.Rotation
	}
	xf.world.Rotation = r + rotation

	// all child
	for comps, child := xf.t.comps, xf.firstChild; child != none; {
		node := comps[child]
		child = node.nxtSibling
		node.setRotation(&xf.world, node.local.Rotation)
	}
}

func (xf *Transform) LinkChildren(list... *Transform) {
	for _, c := range list {
		xf.LinkChild(c)
	}
}

func (xf *Transform) LinkChild(c *Transform) {
	mp, comps := xf.t._map, xf.t.comps
	pi, ci := mp[xf.Entity.Index()], mp[c.Entity.Index()]

	if xf.firstChild == none {
		xf.firstChild = uint16(ci)
		c.parent = uint16(pi)
	} else {
		var prev uint16
		for next := xf.firstChild; next != none; {
			prev = next
			next = comps[next].nxtSibling
		}
		comps[prev].nxtSibling = uint16(ci)
		c.preSibling = prev
		c.parent = uint16(pi)
	}
}

func (xf *Transform) RemoveChild(c *Transform) {
	mp, comps := xf.t._map, xf.t.comps
	pi, ci := uint16(mp[xf.Entity.Index()]), uint16(mp[c.Entity.Index()])

	if c.parent != pi {
		return
	}

	if xf.firstChild == ci {
		xf.firstChild = c.nxtSibling
	} else {
		comps[c.preSibling].nxtSibling = c.nxtSibling
	}
	if nxt := c.nxtSibling; nxt != none {
		comps[nxt].preSibling = c.preSibling
	}
	c.parent, c.preSibling, c.nxtSibling = none, none, none
}

func (xf *Transform) FirstChild() (c *Transform) {
	if first := xf.firstChild; first != none {
		c = &xf.t.comps[first]
	}
	return
}

func (xf *Transform) Parent() (p *Transform) {
	if x := xf.parent; x != none {
		p = &xf.t.comps[x]
	}
	return
}

func (xf *Transform) Sibling() (prev, next *Transform) {
	if x := xf.preSibling; x != none {
		prev = &xf.t.comps[x]
	}
	if x := xf.nxtSibling; x != none {
		next = &xf.t.comps[x]
	}
	return
}

func (xf *Transform) reset() {
	if p := xf.parent; p != none {
		xf.t.comps[p].RemoveChild(xf)
	}
	*xf = Transform{}
}

type TransformTable struct {
 	comps []Transform
	_map  map[uint32]int
	index, cap int
}

func NewTransformTable(cap int) *TransformTable {
	return &TransformTable{
		cap:cap,
		_map:make(map[uint32]int),
		index:1, // skip first
	}
}

// Create a new TransformComp for the entity,
// Return the old one, if it already exist .
func (tt *TransformTable) NewComp(entity engi.Entity) (xf *Transform) {
	if size := len(tt.comps); tt.index >= size {
		tt.comps = transformResize(tt.comps, size + STEP)
	}
	ei := entity.Index()
	if v, ok := tt._map[ei]; ok {
		xf = &tt.comps[v]
		return
	}

	xf = &tt.comps[tt.index]
	xf.Entity = entity
	xf.local.Scale = f32.Vec2{1, 1}
	xf.world.Scale = f32.Vec2{1, 1}
	xf.t = tt
	tt._map[ei] = tt.index
	tt.index += 1
	return
}

// Return the TransformComp or nil
func (tt *TransformTable) Comp(entity engi.Entity) (xf *Transform) {
	ei := entity.Index()
	if v, ok := tt._map[ei]; ok {
		xf = &tt.comps[v]
	}
	return
}

func (tt *TransformTable) Alive(entity engi.Entity) bool {
	ei := entity.Index()
	if v, ok := tt._map[ei]; ok {
		return tt.comps[v].Entity != 0
	}
	return false
}

// Swap erase the TransformComp if exist
// Delete will unlink the parent-child relation
func (tt *TransformTable) Delete(entity engi.Entity) {
	ei := entity.Index()
	if v, ok := tt._map[ei]; ok {
		if tail := tt.index -1; v != tail && tail > 0 {
			tt.comps[v] = tt.comps[tail]
			tt.relink(uint16(tail), uint16(v))

			// remap index
			tComp := &tt.comps[tail]
			ei := tComp.Entity.Index()
			tt._map[ei] = v
			tt.comps[tail].reset()
		} else {
			tt.comps[tail].reset()
		}
		tt.index -= 1
		delete(tt._map, ei)
	}
}

func (tt *TransformTable) relink(old, new uint16) {
	xf := &tt.comps[old]
	// relink parent
	if p := xf.parent; p != none {
		if pxf := &tt.comps[p]; pxf.firstChild == old {
			pxf.firstChild = new
		} else {
			prev := &tt.comps[xf.preSibling]
			prev.nxtSibling = new
		}
	}
	// relink children
	if child := xf.firstChild; child != none {
		node := &tt.comps[child]
		node.parent = new
	}
}


func (tt *TransformTable) Destroy() {
	tt.comps = make([]Transform, 0)
	tt._map = make(map[uint32]int)
	tt.index = 1
}

func (tt *TransformTable) Size() (size, cap int) {
	return tt.index-1, tt.cap
}

func transformResize(slice []Transform, size int) []Transform {
	newSlice := make([]Transform, size)
	copy(newSlice, slice)
	return newSlice
}

func intResize(slice []int, size int) []int {
	newSlice := make([]int, size)
	copy(newSlice, slice)
	return newSlice
}

```

`gfx/transform_test.go`:

```go
package gfx

import (
	"testing"
	"korok.io/korok/engi"
	"korok.io/korok/math/f32"
)

func TestTransform(t *testing.T) {
	em := engi.NewEntityManager()
	tt := NewTransformTable(1024)

	e := em.New()
	xf := tt.NewComp(e)

	c1, c2 := em.New(), em.New()
	xf1, xf2 := tt.NewComp(c1), tt.NewComp(c2)

	xf.SetPosition(f32.Vec2{100, 100})

	if xy := xf.Local().Position; xy[0] != 100 || xy[1] != 100 {
		t.Error("xf local position is not set correctly")
	}

	if xy := xf.World().Position; xy[0] != 100 || xy[1] != 100 {
		t.Error("xf world is not set correctly")
	}

	// link c1 and c2 to parent e
	xf.LinkChild(xf1)
	xf.LinkChild(xf2)

	xf1.SetPosition(f32.Vec2{50, 50})
	xf2.SetPosition(f32.Vec2{-50, -50})

	if xy := xf1.World().Position; xy[0] != 150 || xy[1] != 150 {
		t.Error("child1 postion:", xy, "expected:", f32.Vec2{150, 150})
	}

	if xy := xf2.World().Position; xy[0] != 50 || xy[1] != 50 {
		t.Error("child2 postion:", xy, "expected:", f32.Vec2{50, 50})
	}

	xf.SetPosition(f32.Vec2{200, 200})

	if xy := xf.World().Position; xy[0] != 200 || xy[1] != 200 {
		t.Error("xf world is not set correctly")
	}

	xf1, xf2 = tt.Comp(c1), tt.Comp(c2)
	if xy := xf1.World().Position; xy[0] != 250 || xy[1] != 250 {
		t.Error("child1 postion err:", xy, "expected:", f32.Vec2{250, 250})
	}

	if xy := xf2.World().Position; xy[0] != 150 || xy[1] != 150 {
		t.Error("child2 postion err:", xy, "expected:", f32.Vec2{150, 150})
	}
}


// Test CRUD operation for TransformTable
func TestTransformTable(t *testing.T) {
	em := &engi.EntityManager{}
	tt := NewTransformTable(1024)

	e1 := em.New()
	xf1 := tt.NewComp(e1)

	if xf := tt.Comp(e1); xf != xf1 {
		t.Error("fail to create Comp")
	}

	tt.Delete(e1)
	if xf := tt.Comp(e1); xf != nil {
		t.Error("fail to delete Comp")
	}

	if size, _ := tt.Size(); size != 0 {
		t.Error("fail to reset Table state")
	}

	// create 10
	eList := make([]engi.Entity, 10)
	for i := 0; i < 10; i++ {
		e := em.New()
		tt.NewComp(e)
		eList[i] = e
	}

	if size, _ := tt.Size(); size != len(eList) {
		t.Error("fail to create 10 Comps")
	}

	// delete 5
	for i, e := range eList {
		if i % 2 == 0 {
			tt.Delete(e)
		}
	}

	if size, _ := tt.Size(); size != len(eList)/2 {
		t.Error("fail to delete Comps")
	}

	// test left
	for i, e := range eList {
		if i % 2 == 1 {
			if comp := tt.Comp(e); comp == nil || comp.Entity != e {
				t.Error("fail to keep entity:", e)
			}
		} else {
			if tt.Comp(e) != nil {
				t.Error("fail to delete Comps:", e)
			}
		}
	}
}

// step=64
func TestTransformTableResize(t *testing.T) {
	em := &engi.EntityManager{}
	tt := NewTransformTable(1024)

	list30 := make([]engi.Entity, 30)
	for i := 0; i < 30; i++ {
		e := em.New()
		tt.NewComp(e)
		list30[i] = e
	}

	// will cause resize
	list100 := make([]engi.Entity, 100)
	for i := 0; i < 100; i++ {
		e := em.New()
		tt.NewComp(e)
		list100[i] = e
	}

	if size, _ := tt.Size(); size != (len(list30) + len(list100)) {
		t.Errorf("fail to create Comps: %d/%d", size, len(list30) + len(list100))
	}

	list := append(list100, list30...)
	for _, e := range list {
		if xf := tt.Comp(e); xf == nil || xf.Entity != e {
			t.Error("comp is not create correctly")
		}
	}
}

// test node-link
func TestParentChildLink(t *testing.T) {
	em := engi.NewEntityManager()
	tt := NewTransformTable(1024)

	car := em.New()
	xf := tt.NewComp(car)

	wheel1, wheel2, wheel3, wheel4 := em.New(), em.New(), em.New(), em.New()
	xf1 := tt.NewComp(wheel1)
	xf2 := tt.NewComp(wheel2)
	xf3 := tt.NewComp(wheel3)
	xf4 := tt.NewComp(wheel4)

	xf.LinkChildren(xf1, xf2, xf3, xf4)

	wheels := []*Transform{xf1, xf2, xf3, xf4}
	for _, xf := range wheels {
		if xf.Parent().Entity != car {
			t.Error("fail to link child to parent")
		}
	}

	if xf.FirstChild().Entity != wheel1 {
		t.Error("fail to link wheel1")
	}

	for i := 0; i < 3; i++ {
		if _, nxt := wheels[i].Sibling(); nxt.Entity != wheels[i+1].Entity {
			t.Error("fail to link next sibling wheels")
		}
	}

	for i := 3; i >= 1; i-- {
		if pre, _ := wheels[i].Sibling(); pre.Entity != wheels[i-1].Entity {
			t.Error("fail to link prev sibling wheels")
		}
	}
	// remove first wheel
	xf.RemoveChild(xf1)
	if xf1.Parent() != nil {
		t.Error("fail to remove wheel1, wheel ref parent")
	}
	if xf.FirstChild().Entity == wheel1 {
		t.Error("fail to remove wheel1, car ref wheel")
	}

	if xf.FirstChild().Entity != wheel2 {
		t.Error("fail to keep wheel2")
	}

	// remove second wheel
	xf.RemoveChild(xf3)
	if xf.FirstChild().Entity != wheel2 {
		t.Error("fail to keep wheel2")
	}
	if pre, nxt := xf2.Sibling(); pre != nil && nxt.Entity != wheel4 {
		t.Error("fail to keep wheel4")
	}

	// re-construct wheels
	xf.LinkChildren(xf1, xf3)
	wheels = []*Transform{xf2, xf4, xf1, xf3}

	for i := 0; i < 3; i++ {
		if _, nxt := wheels[i].Sibling(); nxt.Entity != wheels[i+1].Entity {
			t.Error("fail to link next sibling wheels")
		}
	}

	// try to delete something. danger!
	tt.Delete(wheel1)
	tt.Delete(wheel3)

	// delete will cause ref change
	xf1, xf2, xf3, xf4 = tt.Comp(wheel1), tt.Comp(wheel2), tt.Comp(wheel3), tt.Comp(wheel4)

	if xf1 != nil {
		t.Error("fail to delete wheel1")
	}
	if xf3 != nil {
		t.Error("fail to delete wheel3")
	}

	if xf.FirstChild().Entity != wheel2 {
		t.Error("fail to keep wheel2")
	}
	if pre, nxt := xf.FirstChild().Sibling(); pre != nil || nxt != xf4 {
		t.Error("fail to keep wheel2 and wheel4")
	}
}
```

`gfx/visibility.go`:

```go
package gfx

import (
	"korok.io/korok/math/f32"
	"korok.io/korok/engi"
)

/// 可见性系统，以一个组件的形式呈现
type BoundingBox struct {
	Min f32.Vec2
	Max f32.Vec2
}

/// 每个Entity只有一个可见性对象，如果它包含多个 RenderComp，那么求出一个最大面积
/// 作为该对象的可见面积
type BoundingComp struct {
	BoundingBox
}

func (bc *BoundingComp) SetBounding(bb *BoundingBox) {
	bc.BoundingBox = *bb
}

// 合并两个矩形
func (bc *BoundingComp) Add(bb *BoundingBox) {

}

// 减去一个矩形的贡献
func (bc *BoundingComp) Sub(bb *BoundingBox) {

}

type BoundingTable struct {
	_comp []BoundingComp
	_index uint32
	_map [1024]uint32
}

func (bt *BoundingTable) NewComp(entity engi.Entity) (bc *BoundingComp) {
	bc = &bt._comp[bt._index]
	bt._map[entity] = bt._index
	bt._index ++
	return
}

func (bt *BoundingTable) Comp(entity engi.Entity) (bc *BoundingComp) {
	bc = &bt._comp[bt._map[entity]]
	return
}


type VisibilitySystem interface {
	UpdateBounding(id int32, bb BoundingBox)
	UpdateTransform()
	Collect(camera *Camera) []engi.Entity
}

// 对于静态的对象，可以使用一些空间算法做到快速的筛选
// 对于动态的对象，最好的做法还是跑一遍 O(N) 的循环，
// 这样可以避免因维护算法带来的开销

type visibilitySystem struct {
}

// 返回相机可见的对象集合
func (*visibilitySystem) Collect(camera *Camera) []engi.Entity{
	return nil
}

// 在此注册一个 静态的游戏对象
func (*visibilitySystem) RegisterStatic(entity engi.Entity, bb BoundingBox) int32{
	return 0
}

// 注册一个 动态的游戏对象
func (*visibilitySystem) RegisterDynamic(entity engi.Entity, bb BoundingBox) int32 {
	return 0
}

// 更新游戏对象的 AABB
func (*visibilitySystem) UpdateBounding(id int32, bb BoundingBox) {

}





```

`gui/auto/gui.go`:

```go
package auto

import (
	"korok.io/korok/gfx"
	"korok.io/korok/gui"
)

//	Awesome GUI System
//
type LayoutType int

const (
	Vertical   LayoutType = iota
	Horizontal
	OverLay
)

type ViewType int

const (
	Normal ViewType = iota
	Popup
)

// Options: margin
func Margin(top, left, right, bottom float32) *Options {
	opt := &gLayoutMan.Options
	opt.Margin(top, left, right, bottom)
	return opt
}

// Options: gravity
func Gravity(x, y float32) *Options {
	opt := &gLayoutMan.Options
	opt.Gravity(x, y)
	return opt
}

// Options: Size
func Size(w, h float32) *Options {
	opt := &gLayoutMan.Options
	opt.Size(w, h)
	return opt
}

// Widgets: Text
func Text(id gui.ID, text string, style *gui.TextStyle, p *Options) {
	if style == nil {
		style = &gContext.Theme.Text
	}
	gLayoutMan.Text(id, text, style, p)
	return
}

func TextSizeColored(id gui.ID, text string, color gfx.Color, size float32, opt *Options) {
	sty := gContext.Theme.Text
	sty.Color = color
	sty.Size = size
	gLayoutMan.Text(id, text, &sty, opt)
}

// Widgets: InputEditor
func InputText(hint string, style *gui.InputStyle, p *Options) {

}

// Widget: Image
func Image(id gui.ID, tex gfx.Tex2D, style *gui.ImageStyle, p *Options) {
	if style == nil {
		style = &gContext.Theme.Image
	}
	gLayoutMan.Image(id, tex, style, p)
}

// Widget: Button
func Button(id gui.ID, text string, style *gui.ButtonStyle, p *Options) (event gui.EventType) {
	if style == nil {
		style = &gContext.Theme.Button
	}
	return gLayoutMan.Button(id, text, style, p)
}

func ImageButton(id gui.ID, normal, pressed gfx.Tex2D, style *gui.ImageButtonStyle, p *Options) gui.EventType{
	if style == nil {
		style = &gContext.Theme.ImageButton
	}
	return gLayoutMan.ImageButton(id, normal, pressed, style, p)
}

func CheckBox(text string, style *gui.CheckBoxStyle) bool {
	return false
}

// Widget: ProgressBar, Slider
func ProgressBar(fraction float32, style *gui.ProgressBarStyle, p *Options) {

}

func Slider(id gui.ID, value *float32, style *gui.SliderStyle, p *Options) (v gui.EventType){
	if style == nil {
		style = &gContext.Theme.Slider
	}
	return gLayoutMan.Slider(id, value, style, p)
}

// Widget: ListView TODO
func ListView() {

}

// Layout & Group

// Define a view group
func Define(name string, ) {
	gLayoutMan.DefineLayout(name, Normal)
}

func DefineType(name string, xt ViewType) {
	gLayoutMan.DefineLayout(name, xt)
}

func Clear(names ...string) {
	gLayoutMan.Clear(names...)
}

func Layout(id gui.ID, gui func(g *Group), w, h float32, xt LayoutType) {
	gLayoutMan.BeginLayout(id, nil, xt)
	if w != 0 || h != 0 {
		gLayoutMan.current.SetSize(w, h)
	}
	gui(gLayoutMan.current.hGroup)
	gLayoutMan.EndLayout()
}

func LayoutX(id gui.ID, gui func(g *Group), opt *Options, xt LayoutType) {
	gLayoutMan.BeginLayout(id, opt, xt)
	if opt != nil {
		if w, h := opt.W, opt.H; w != 0 || h != 0 {
			gLayoutMan.current.SetSize(w, h)
		}
		gLayoutMan.current.SetGravity(opt.gravity.X, opt.gravity.Y)

	}
	gui(gLayoutMan.current.hGroup)
	gLayoutMan.EndLayout()
}


var gLayoutMan *LayoutMan
var gContext *gui.Context

func init() {
	gContext = gui.DefaultContext()
	gLayoutMan = &LayoutMan{Context: gContext}; gLayoutMan.initialize()
}

```

`gui/auto/gui_lib.go`:

```go
package auto

import (
	"korok.io/korok/math/f32"
	"korok.io/korok/gfx"
	g "korok.io/korok/gui"
)

type LayoutMan struct {
	*g.Context
	Options
	fallback layout

	layouts map[string]*layout
	depth int
	current *layout

	// sqNum should be same for  layout and drawing
	sqNum int
}

func (lm *LayoutMan) initialize() {
	lm.fallback.Initialize(gContext.Theme)
	lm.current = &lm.fallback
	lm.layouts = make(map[string]*layout)
}

func (lm *LayoutMan) Text(id g.ID, text string, style *g.TextStyle, opt *Options)  *Element {
	var (
		elem, ready = lm.BeginElement(id, opt)
		size f32.Vec2
		font = style.Font
	)
	if font == nil {
		font = lm.Context.Theme.Font
	}

	// draw text 最好返回最新的大小..
	if ready {
		size = lm.Context.DrawText(&elem.Rect, text, style)
	} else {
		size = lm.Context.CalcTextSize(text, 0, font, style.Size)
	}

	elem.Rect.W = size[0]
	elem.Rect.H = size[1]

	lm.EndElement(elem)
	return nil
}

// Widgets: InputEditor
func (lm *LayoutMan) InputText(hint string, lyt layout, style *g.InputStyle) {

}

// Widget: Image
func (lm *LayoutMan) Image(id g.ID, tex gfx.Tex2D, style *g.ImageStyle, opt *Options) {
	var (
		elem, ready = lm.BeginElement(id, opt)
	)

	if ready {
		lm.Context.DrawImage(&elem.Rect, tex, style)
	} else {
		if opt != nil {
			elem.W = opt.W
			elem.H = opt.H
		}
	}

	lm.EndElement(elem)
}

// Widget: Button
func (lm *LayoutMan) Button(id g.ID, text string, style *g.ButtonStyle, opt *Options) (event g.EventType) {
	var (
		elem, ready = lm.BeginElement(id, opt)
	)

	if ready {
		lm.Context.Button(id, &elem.Rect, text, style)
	} else {
		font := style.Font
		if font == nil {
			font = lm.Context.Theme.Font
		}
		size := style.TextStyle.Size
		textSize := lm.CalcTextSize(text, 0, font, size)
		extW := style.Padding.Left+style.Padding.Right
		extH := style.Padding.Top+style.Padding.Bottom
		elem.W, elem.H = textSize[0]+extW, textSize[1]+extH
	}
	lm.EndElement(elem)
	return
}


func (lm *LayoutMan) renderTextClipped(text string, bb *g.Rect, style *g.TextStyle) {
	x, y := g.Gui2Game(bb.X, bb.Y)
	font := lm.Theme.Text.Font
	if bb.W == 0 {
		lm.DrawList.AddText(f32.Vec2{x, y}, text, font, 12, 0xFF000000, 0)
	} else {
		lm.DrawList.AddText(f32.Vec2{x, y}, text, font, 12, 0xFF000000, bb.W)
	}
}

func (lm *LayoutMan) ImageButton(id g.ID, normal, pressed gfx.Tex2D, style *g.ImageButtonStyle, opt *Options) ( event g.EventType) {
	var (
		elem, ready = lm.BeginElement(id, opt)
		bb = &elem.Rect
	)
	if ready {
		event = lm.ClickEvent(id, bb)
		var tex gfx.Tex2D
		if event & g.EventDown != 0 {
			tex = pressed
		} else {
			tex = normal
		}
		lm.DrawImage(bb, tex, &style.ImageStyle)
	} else {
		if opt != nil {
			elem.W = opt.W
			elem.H = opt.H
		}
	}
	lm.EndElement(elem)
	return
}

// Slider 需要设定一些自定义的属性，目前没有想好如何实现，先把逻辑实现了
// 用两种颜色来绘制
func (lm *LayoutMan) Slider(id g.ID, value *float32, style *g.SliderStyle, opt *Options) (e g.EventType){
	var (
		elem, ready = lm.BeginElement(id, opt)
		bb = &elem.Rect
	)

	if ready {
		// 说明滑动了，那么应该使用最新的值，而不是传入的值
		if v, event := lm.Context.CheckSlider(id, bb); event & g.EventDragging != 0 {
			*value = v
			e = event
		}

		lm.DrawRect(bb, style.Bar, 5)
		lm.DrawCircle(bb.X+bb.W*(*value), bb.Y+bb.H/2, 10, style.Knob)
	} else {
		// 设置默认的宽高
		if elem.W == 0 {
			elem.W = 120
		}
		if elem.H == 0 {
			elem.H = 10
		}
	}

	lm.EndElement(elem)
	return
}

func (lm *LayoutMan) DefineLayout(name string, xt ViewType) {
	if l, ok := lm.layouts[name]; ok {
		lm.current = l
	} else {
		l := &layout{}; l.Initialize(gContext.Theme)
		lm.layouts[name] = l
		lm.current = l
	}
}

func (lm *LayoutMan) Clear(names ...string) {
	if size := len(names); size > 0 {
		for i := 0; i < size; i++ {
			delete(lm.layouts, names[i])
		}
	} else {
		lm.layouts = make(map[string]*layout)
	}
}

// 计算单个UI元素
// 如果有大小则记录出偏移和Margin
// 否则只返回元素
func (lm *LayoutMan) BeginElement(id g.ID, opt *Options) (elem *Element, ok bool){
	return lm.current.BeginElement(id, opt)
}

// 结束绘制, 每绘制完一个元素都要偏移一下光标
func (lm *LayoutMan) EndElement(elem *Element) {
	lm.current.EndElement(elem)
}

func (lm *LayoutMan) BeginLayout(id g.ID, opt *Options, xtype LayoutType) {
	lm.depth ++
	if elem, ok := lm.current.BeginLayout(id, opt, xtype); ok {
		// debug-draw
		if g.DebugDraw {
			lm.DrawDebugBorder(elem.X, elem.Y, elem.W, elem.H, 0xFF00FF00)
		}
	}
}

func (lm *LayoutMan) EndLayout() {
	lm.depth --
	lm.current.EndLayout()
	if d := lm.depth; d == 0 {
		lm.current = &lm.fallback
	}
}

```

`gui/auto/layout.go`:

```go
package auto

import (
	"korok.io/korok/math"
	"korok.io/korok/gui"

	"log"
)

// GUI coordinate system
// (0, 0)
//  +-------------------------+ (w, 0)
//  |  (x,y)                  |
//  |   +------> W            |
//  |   |                     |
//  |   |                     |
//  | H V                     |
//  +-------------------------+
//(0, h)                       (w, h)
// Options is our layout-system

// 当 W = 0, H = 0 的时候，按 WrapContent 的方式绘制
type Element struct{
	id gui.ID
	// 相对偏移 和 大小
	gui.Rect
	// margin
	margin
}

type margin struct {
	Top, Left, Bottom, Right float32
}

type gravity struct {
	X, Y float32
}

type DirtyFlag uint32

const (
	FlagSize DirtyFlag = 1 << iota
	FlagMargin
	FlagGravity
)

// Shadow of current ui-element
type Options struct {
	gui.Rect
	margin
	gravity
	Flag    DirtyFlag // dirty flag
}

// set flag
func (p *Options) Margin(top, left, right, bottom float32) *Options {
	p.Flag |= FlagMargin
	p.margin = margin{top, left, bottom, right}
	return p
}

func (p *Options) Size(w, h float32) *Options {
	p.Flag |= FlagSize
	p.Rect.W = w
	p.Rect.H = h
	return p
}

func (p *Options) Gravity(x, y float32) *Options {
	p.Flag |= FlagGravity
	p.gravity.X = x
	p.gravity.Y = y
	return p
}

type layout struct {
	Cursor struct{X, Y float32}
	
	// ui bound 是一直存储的，记录一些持久化的数据
	uiElements           []Element // element uiElements

	// group 是 fifo 的结构,记录动态的数据
	groupStack           []Group // groupStack uiElements

	// header of group stack
	hGroup *Group

	// default ui-element spacing
	spacing float32
}

func (lyt *layout) Initialize(style *gui.Theme) {
	// init size, todo resize 会导致指针错误
	lyt.uiElements = make([]Element, 0, 32)
	lyt.groupStack = make([]Group, 0, 8)
	lyt.spacing = style.Spacing

	// Create a default layout
	bb := lyt.NewElement(0)
	ii := len(lyt.groupStack)
	lyt.groupStack = append(lyt.groupStack, Group{LayoutType: OverLay, Element: bb})
	lyt.hGroup = &lyt.groupStack[ii]
}

func (lyt *layout) SetDefaultLayoutSize(w, h float32) {
	if dft, ok := lyt.Element(0); ok {
		dft.W, dft.H = w, h
	}
}

// 创建新的Layout
func (lyt *layout) NewElement(id gui.ID) *Element {
	ii := len(lyt.uiElements)
	lyt.uiElements = append(lyt.uiElements, Element{id:id})
	return &lyt.uiElements[ii]
}

// 找出前一帧保存的大小
func (lyt *layout) Element(id gui.ID) (bb *Element, ok bool) {
	if size := len(lyt.uiElements); size > int(id) {
		if bb = &lyt.uiElements[id]; bb.id == id {
			ok = true; return
		}
	}
	// Linear Search
	for i := range lyt.uiElements {
		if bb = &lyt.uiElements[i]; bb.id == id {
			ok = true; break
		}
	}
	return
}

func (lyt *layout) Dump()  {
	log.Println("dump elemnts:", lyt.uiElements)
	log.Println("dump group:", lyt.groupStack)
}

func (lyt *layout) Reset() {
	lyt.uiElements = lyt.uiElements[:0]
}

// Options Operation
func (lyt *layout) Move(x, y float32) *layout {
	lyt.Cursor.X, lyt.Cursor.Y = x, y
	return lyt
}

func (lyt *layout) BoundOf(id gui.ID) (bb Element, ok bool) {
	if size := len(lyt.uiElements); size > int(id) {
		if bb = lyt.uiElements[id]; bb.id == id {
			ok = true
		}
	}
	// 否则进行线性查找, 找出UI边界
	return
}

func (lyt *layout) Offset(dx, dy float32) *layout {
	lyt.Cursor.X += dx
	lyt.Cursor.Y += dy
	return lyt
}

func (lyt *layout) SetGravity(x, y float32) *layout {
	lyt.hGroup.Gravity.X = math.Clamp(x, 0, 1)
	lyt.hGroup.Gravity.Y = math.Clamp(y, 0, 1)
	return lyt
}

func (lyt *layout) SetSize(w, h float32) *layout {
	lyt.hGroup.SetSize(w, h)
	return lyt
}

func (lyt *layout) SetPadding(top, left, right, bottom float32) *layout {
	lyt.hGroup.Padding = gui.Padding{left, right, top, bottom}
	return lyt
}

func (lyt *layout) BeginLayout(id gui.ID, opt *Options, xtype LayoutType) (elem *Element, ok bool) {
	// layout element
	spacing := lyt.spacing; lyt.spacing = 0
	elem, ok = lyt.BeginElement(id, opt)
	lyt.spacing = spacing

	// do layout
	ii := len(lyt.groupStack)

	// group-stack has a default parent
	// so it's safe to index
	parent := &lyt.groupStack[ii-1]
	lyt.groupStack = append(lyt.groupStack, Group{LayoutType:xtype, Element: elem})
	lyt.hGroup = &lyt.groupStack[ii]

	// stash Options state
	parent.Cursor.X = lyt.Cursor.X
	parent.Cursor.Y = lyt.Cursor.Y

	// reset Options
	lyt.Cursor.X, lyt.Cursor.Y = 0, 0
	return
}

// PopLayout, resume parent's state
func (lyt *layout) EndLayout() {
	// 1. Set size with external spacing
	v := lyt.hGroup
	if v.fixedWidth > 0 {
		v.W = v.fixedWidth
	} else {
		v.W = v.Size.W + lyt.spacing
	}
	if v.fixedHeight > 0 {
		v.H = v.fixedHeight
	} else {
		v.H = v.Size.H + lyt.spacing
	}

	// 2. return to parent
	if size := len(lyt.groupStack); size > 1 {
		lyt.groupStack = lyt.groupStack[:size-1]
		lyt.hGroup = &lyt.groupStack[size-2]
	}

	g := lyt.hGroup
	lyt.Cursor.X, lyt.Cursor.Y = g.Cursor.X, g.Cursor.Y

	// 3. end layout
	elem := &Element{Rect:gui.Rect{0, 0, v.W, v.H}}
	spacing := lyt.spacing; lyt.spacing = 0
	lyt.EndElement(elem)
	lyt.spacing = spacing

}

func (lyt *layout) BeginElement(id gui.ID, opt *Options) (elem *Element, ok bool){
	if elem, ok = lyt.Element(id); !ok {
		elem = lyt.NewElement(id)
	} else {
		// 计算偏移
		elem.X = lyt.Cursor.X + lyt.spacing
		elem.Y = lyt.Cursor.Y + lyt.spacing

		// gravity
		var (
			group = lyt.hGroup
			gravity = group.Gravity
			extra = struct {W, H float32} {lyt.spacing*2, lyt.spacing*2}
		)

		// Each element's property
		if opt != nil && opt.Flag != 0 {
			// 计算 margin 和 偏移
			if opt.Flag & FlagMargin != 0 {
				elem.margin = opt.margin
				elem.X += elem.Left
				elem.Y += elem.Top

				extra.W += elem.Left + elem.Right
				extra.H += elem.Top + elem.Bottom
			}

			// 计算大小
			if opt.Flag & FlagSize != 0 {
				if opt.W > 0 {
					elem.Rect.W = opt.W
				}
				if opt.H > 0 {
					elem.Rect.H = opt.H
				}
			}

			// Overlap group's gravity
			if opt.Flag & FlagGravity != 0 {
				gravity = opt.gravity
			}

			// Clear flag
			opt.Flag = 0
		}

		switch group.LayoutType {
		case Horizontal:
			elem.Y += (group.H - elem.H - extra.H) * gravity.Y
		case Vertical:
			elem.X += (group.W - elem.W - extra.W) * gravity.X
		case OverLay:
			elem.Y += (group.H - elem.H - extra.H) * gravity.Y
			elem.X += (group.W - elem.W - extra.W) * gravity.X
		}

		elem.X += lyt.hGroup.X
		elem.Y += lyt.hGroup.Y
	}
	return
}

func (lyt *layout) EndElement(elem *Element) {
	if  elem == nil {
		log.Println("====> err nil")
	}
	lyt.Advance(elem)
	lyt.Extend(elem)
}

// 重新计算父容器的大小
// size + margin = BoundingBox
func (lyt *layout) Extend(elem *Element) {
	var (
		g  = lyt.hGroup
		dx = elem.W + elem.Left + elem.Right + lyt.spacing //+ lyt.spacing
		dy = elem.H + elem.Top + elem.Bottom + lyt.spacing //+ lyt.spacing
	)

	switch g.LayoutType {
	case Horizontal:
		// 水平加之，高度取最大
		g.Size.W += dx
		g.Size.H = math.Max(g.Size.H, dy)
	case Vertical:
		// 高度加之，水平取最大
		g.Size.W = math.Max(g.Size.W, dx)
		g.Size.H += dy
	case OverLay:
		// 重叠, 取高或者宽的最大值
		g.Size.W = math.Max(g.Size.W, dx)
		g.Size.H = math.Max(g.Size.H, dy)
	}
}

// 重新计算父容器的光标位置
func (lyt *layout) Advance(elem *Element) {
	var (
		g, c  = lyt.hGroup, &lyt.Cursor
		dx = elem.W + elem.Left + elem.Right + lyt.spacing// + lyt.spacing
		dy = elem.H + elem.Top + elem.Bottom + lyt.spacing// + lyt.spacing
	)

	switch g.LayoutType {
	case Horizontal:
		// 水平步进，前进一个控件宽度
		c.X += dx
	case Vertical:
		// 垂直步进，前进一个控件高度
		c.Y += dy
	case OverLay:
		// 保持原来的位置不变..
	}
}

// Q. 当前 Group 的 X，Y, W, H 应该和 Group 的Cursor区分开来

type Flag uint32

type Group struct {
	LayoutType; Flag
	*Element
	// 仅用来缓存...
	Cursor struct{X, Y float32}
	Offset struct{X, Y float32}
	gui.Padding

	// 当前帧布局的计算变量
	Size struct{W, H float32}
	Gravity struct{X, Y float32}

	// true if group has a predefined size
	fixedWidth float32
	fixedHeight float32
}

func (g *Group) SetGravity(x, y float32) {
	g.Gravity.X = math.Clamp(x, 0, 1)
	g.Gravity.Y = math.Clamp(y, 0, 1)
}

func (g *Group) SetPadding(top, left, right, bottom float32) {
	g.Padding = gui.Padding{left, right, top, bottom}
}

func (g *Group) SetSize(w, h float32) {
	g.fixedWidth = w
	g.fixedHeight = h
}
```

`gui/drawing.go`:

```go
package gui

import (
	"korok.io/korok/math/f32"
	"korok.io/korok/math"
	"korok.io/korok/gfx/bk"
	"korok.io/korok/gfx/font"
)

type DrawListFlags uint32
const (
	FlagAntiAliasedLine DrawListFlags = iota
	FlagAntiAliasedFill
)
// Rounding corner:
// A: 0x0000 0001 top-left
// B: 0x0000 0002 top-right
// C: 0x0000 0004 down-right
// D: 0x0000 0008 down-left
type FlagCorner uint32

const (
	FlagCornerNone        FlagCorner = 0x0000
	FlagCornerTopLeft                = 0x0001
	FlagCornerTopRight               = 0x0002
	FlagCornerBottomRight            = 0x0004
	FlagCornerBottomLeft             = 0x0008
	FlagCornerAll                    = 0x000F
)

type Align uint32

const (
	AlignCenter Align = iota
	AlignLeft		  = 1 << iota
	AlignRight		  = 1 << iota
	AlignTop 		  = 1 << iota
	AlignBottom		  = 1 << iota
)

const (
	DefaultZOrder = int16(0xFFFF>>1-100)
)

// DrawList provide method to write primitives to buffer
type DrawCmd struct {
	FirstIndex uint16
	ElemCount uint16
	ClipRect f32.Vec4
	TextureId uint16
	zOrder int16
}

type DrawIdx uint16

type DrawVert struct {
	xy f32.Vec2
	uv  f32.Vec2
	color uint32
}

type DrawList struct {
	CmdBuffer []DrawCmd
	IdxBuffer []DrawIdx
	VtxBuffer []DrawVert

	cmdIndex, idxIndex, vtxIndex int
	cmdCap, idxCap, vtxCap int

	// Data *DrawListSharedData
	OwnerName string // 窗口名
	VtxCurrentIdx int // VtxBuffer.Size

	// 指向当前正在使用的 cmdbuffer 的位置
	VtxWriter []DrawVert
	IdxWriter []DrawIdx

	ClipRectStack[]f32.Vec4
	TextureIdStack []uint16

	// path
	path [64]f32.Vec2
	pathUsed int


	FullScreen f32.Vec4
	TexUVWhitePixel f32.Vec2
	CircleVtx12 [12]f32.Vec2
	Font font.Font
	FontSize float32

	Flags DrawListFlags
	ZOrder int16
}

func NewDrawList() *DrawList {
	dl := &DrawList{}
	dl.Initialize()
	return dl
}

func (dl *DrawList) Initialize() {
	dl.CmdBuffer = make([]DrawCmd, 1024)
	dl.IdxBuffer = make([]DrawIdx, 2024)
	dl.VtxBuffer = make([]DrawVert, 2024)

	// TODO
	dl.TexUVWhitePixel = f32.Vec2{0, 0}

	// TODO bake circle vertex!!
	for i := 0; i < 12; i++ {
		sin := math.Sin((6.28/12)*float32(i))
		cos := math.Cos((6.28/12)*float32(i))
		dl.CircleVtx12[i] = f32.Vec2{cos, sin}
	}
	dl.ZOrder = DefaultZOrder
	dl.cmdIndex = 1 // skip first one
}

func (dl *DrawList) Empty() bool {
	return dl.vtxIndex == 0 || dl.idxIndex == 0
}

func (dl *DrawList) Size() (idx, vdx int) {
	idx = dl.idxIndex
	vdx = dl.vtxIndex
	return
}

// TODO
func (dl *DrawList) Clear() {
	dl.cmdIndex = 1
	dl.idxIndex = 0
	dl.vtxIndex = 0
}

func (dl *DrawList) PathClear() {
	dl.pathUsed = 0
}

func (dl *DrawList) PathLineTo(pos f32.Vec2) {
	if n := len(dl.path); dl.pathUsed < n-1 {
		dl.path[dl.pathUsed] = pos
		dl.pathUsed += 1
	}
}

func (dl *DrawList) PathLineToMergeDuplicate(pos f32.Vec2) {
	//if (_Path.Size == 0 || memcmp(&_Path[_Path.Size-1], &pos, 8) != 0)
	//	_Path.push_back(pos);
}

func (dl *DrawList) PathFillConvex(col uint32) {
	dl.AddConvexPolyFilled(dl.path[:dl.pathUsed], col);
	dl.pathUsed = 0
}

// default: thickness=1.0
func (dl *DrawList) PathStroke(color uint32, thickness float32, closed bool)  {
	dl.AddPolyLine(dl.path[:dl.pathUsed], color, thickness, closed)
	dl.PathClear()
}


func (dl *DrawList) CurrentClipRect() (clip f32.Vec4) {
	if n := len(dl.ClipRectStack); n > 0 {
		clip = dl.ClipRectStack[n-1]
	} else {
		clip = dl.FullScreen
	}
	return
}

func (dl *DrawList) CurrentTextureId() (id uint16) {
	if n := len(dl.TextureIdStack); n > 0 {
		id = dl.TextureIdStack[n-1]
	}
	return
}

// will result in new draw-call
func (dl *DrawList) UpdateClipRect() {
	//clip := dl.CurrentClipRect()
}

func (dl *DrawList) UpdateTextureId() {

}

// Clip 相关的操作
func (dl *DrawList) PushClipRect(min, max f32.Vec2, intersectCurrentClip bool) {
	cr := f32.Vec4{min[0], min[1], max[0], max[1]}
	if intersectCurrentClip && len(dl.ClipRectStack) > 0{
		current := dl.ClipRectStack[len(dl.ClipRectStack)-1]
		if cr[0] < current[0] {
			cr[0] = current[0]
		}
		if cr[1] < current[1] {
			cr[1] = current[1]
		}
		if cr[2] > current[2] {
			cr[2] = current[2]
		}
		if cr[3] > current[3] {
			cr[3] = current[3]
		}
		cr[2] = math.Max(cr[0], cr[2])
		cr[3] = math.Max(cr[1], cr[3])

		dl.ClipRectStack = append(dl.ClipRectStack, cr)
		dl.UpdateClipRect()
	}
}

func (dl *DrawList) PushClipRectFullScreen() {
	min := f32.Vec2{dl.FullScreen[0], dl.FullScreen[1]}
	max := f32.Vec2{dl.FullScreen[2], dl.FullScreen[3]}
	dl.PushClipRect(min, max, false)
}

func (dl *DrawList) PopClipRect() {
	if n := len(dl.ClipRectStack); n > 0 {
		dl.ClipRectStack = dl.ClipRectStack[:n-1]
	}
}

func (dl *DrawList) GetClipRectMin() f32.Vec2 {
	return f32.Vec2{0, 0 }
}

func (dl *DrawList) GetClipRectMax() f32.Vec2 {
	return f32.Vec2{0, 0 }
}

func (dl *DrawList) PushTextureId(texId uint16) {
	dl.TextureIdStack = append(dl.TextureIdStack, texId)
}

func (dl *DrawList) PopTextureId() {
	if n := len(dl.TextureIdStack); n > 0 {
		dl.TextureIdStack = dl.TextureIdStack[:n-1]
	}
}

// primitive operation, auto scale by 1024
func (dl *DrawList) PrimReserve(idxCount, vtxCount int) {
	if sz, require := len(dl.VtxBuffer), dl.vtxIndex+vtxCount; require >= sz {
		vtxBuffer := make([]DrawVert, sz+1024)
		copy(vtxBuffer, dl.VtxBuffer)
		dl.VtxBuffer = vtxBuffer
	}
	if sz, require := len(dl.IdxBuffer), dl.idxIndex+idxCount; require >= sz {
		idxBuffer := make([]DrawIdx, sz+1024)
		copy(idxBuffer, dl.IdxBuffer)
		dl.IdxBuffer = idxBuffer
	}
	dl.VtxWriter = dl.VtxBuffer[dl.vtxIndex:dl.vtxIndex+vtxCount]
	dl.IdxWriter = dl.IdxBuffer[dl.idxIndex:dl.idxIndex+idxCount]
}

func (dl *DrawList) PrimRect(min, max f32.Vec2, color uint32) {
	uv := dl.TexUVWhitePixel
	a, b, c, d := min, f32.Vec2{max[0], min[1]}, max, f32.Vec2{min[0], max[1]}
	dl.VtxWriter[0] = DrawVert{a, uv, color}
	dl.VtxWriter[1] = DrawVert{b, uv, color}
	dl.VtxWriter[2] = DrawVert{c, uv, color}
	dl.VtxWriter[3] = DrawVert{d, uv, color}

	dl.IdxWriter[0] = DrawIdx(dl.vtxIndex+0)
	dl.IdxWriter[1] = DrawIdx(dl.vtxIndex+1)
	dl.IdxWriter[2] = DrawIdx(dl.vtxIndex+2)

	dl.IdxWriter[3] = DrawIdx(dl.vtxIndex+0)
	dl.IdxWriter[4] = DrawIdx(dl.vtxIndex+2)
	dl.IdxWriter[5] = DrawIdx(dl.vtxIndex+3)

	dl.vtxIndex += 4
	dl.idxIndex += 6
}

func (dl *DrawList) PrimRectUV(a, c f32.Vec2, uva, uvc f32.Vec2, color uint32) {
	b, d := f32.Vec2{c[0], a[1]}, f32.Vec2{a[0], c[1]}
	uvb, uvd := f32.Vec2{uvc[0], uva[1]}, f32.Vec2{uva[0], uvc[1]}

	dl.VtxWriter[0] = DrawVert{a, uva, color}
	dl.VtxWriter[1] = DrawVert{b, uvb, color}
	dl.VtxWriter[2] = DrawVert{c, uvc, color}
	dl.VtxWriter[3] = DrawVert{d, uvd, color}

	ii := dl.vtxIndex
	dl.IdxWriter[0] = DrawIdx(ii+0)
	dl.IdxWriter[1] = DrawIdx(ii+1)
	dl.IdxWriter[2] = DrawIdx(ii+2)
	dl.IdxWriter[3] = DrawIdx(ii+0)
	dl.IdxWriter[4] = DrawIdx(ii+2)
	dl.IdxWriter[5] = DrawIdx(ii+3)

	dl.idxIndex += 6
	dl.vtxIndex += 4
}

func (dl *DrawList) PrimQuadUV(a, b, c, d f32.Vec2, uva, uvb,uvc, uvd f32.Vec2, color uint32) {
	// vertex
	dl.VtxWriter[0] = DrawVert{a, uva, color}
	dl.VtxWriter[1] = DrawVert{b, uvb, color}
	dl.VtxWriter[2] = DrawVert{c, uvc, color}
	dl.VtxWriter[3] = DrawVert{d, uvd, color}

	ii := dl.vtxIndex
	dl.IdxWriter[0] = DrawIdx(ii+0)
	dl.IdxWriter[1] = DrawIdx(ii+1)
	dl.IdxWriter[2] = DrawIdx(ii+2)
	dl.IdxWriter[3] = DrawIdx(ii+0)
	dl.IdxWriter[4] = DrawIdx(ii+2)
	dl.IdxWriter[5] = DrawIdx(ii+3)

	dl.vtxIndex += 4
	dl.idxIndex += 6
}

// 此处生成最终的顶点数据和索引数据
// 当前并不支持抗锯齿！！简单的用顶点生成线段
func (dl *DrawList) AddPolyLine(points []f32.Vec2, color uint32, thickness float32, closed bool) {
	pointsCount := len(points)
	if pointsCount < 2 {
		return
	}
	uv := dl.TexUVWhitePixel
	count := pointsCount
	if !closed {
		count = pointsCount - 1
	}
	// Non Anti-aliased Stroke
	idxCount := count * 6
	vtxCount := count * 4
	dl.PrimReserve(idxCount, vtxCount)

	for i1 := 0; i1 < count; i1 ++{
		i2 := i1 + 1
		if i2 == pointsCount {
			i2 = 0
		}
		p1, p2 := points[i1], points[i2]

		diff := p2.Sub(p1)

		invLength := math.InvLength(diff[0], diff[1], 1.0)
		diff = diff.Mul(invLength)
		dx := diff[0] * (thickness * 0.5)
		dy := diff[1] * (thickness * 0.5)

		vi := i1*4
		dl.VtxWriter[vi+0] = DrawVert{f32.Vec2{p1[0]+dy, p1[1]-dx}, uv, color}
		dl.VtxWriter[vi+1] = DrawVert{f32.Vec2{p2[0]+dy, p2[1]-dx}, uv, color}
		dl.VtxWriter[vi+2] = DrawVert{f32.Vec2{p2[0]-dy, p2[1]+dx}, uv, color}
		dl.VtxWriter[vi+3] = DrawVert{f32.Vec2{p1[0]-dy, p1[1]+dx}, uv, color}

		ii := i1*6
		dl.IdxWriter[ii+0] = DrawIdx(dl.vtxIndex+0)
		dl.IdxWriter[ii+1] = DrawIdx(dl.vtxIndex+1)
		dl.IdxWriter[ii+2] = DrawIdx(dl.vtxIndex+2)
		dl.IdxWriter[ii+3] = DrawIdx(dl.vtxIndex+0)
		dl.IdxWriter[ii+4] = DrawIdx(dl.vtxIndex+2)
		dl.IdxWriter[ii+5] = DrawIdx(dl.vtxIndex+3)

		dl.vtxIndex += 4
		dl.idxIndex += 6
	}
	dl.AddCommand(idxCount)
}

// Non Anti-aliased Fill
func (dl *DrawList) AddConvexPolyFilled(points []f32.Vec2, color uint32) {
	uv := dl.TexUVWhitePixel
	pointCount := len(points)

	idxCount := (pointCount-2)*3
	vtxCount := pointCount
	dl.PrimReserve(idxCount, vtxCount)

	for i := 0; i < vtxCount; i++ {
		dl.VtxWriter[i] = DrawVert{points[i], uv, color}
	}
	for i, ii := 2, 0; i < pointCount; i, ii = i+1, ii+3 {
		dl.IdxWriter[ii+0] = DrawIdx(dl.vtxIndex+0)
		dl.IdxWriter[ii+1] = DrawIdx(dl.vtxIndex+i-1)
		dl.IdxWriter[ii+2] = DrawIdx(dl.vtxIndex+i)
	}

	dl.vtxIndex += vtxCount
	dl.idxIndex += idxCount
	dl.AddCommand(idxCount)
}

// 此处圆角的算法：
// 使用一个12边形近似圆形，采用中心放射算法，计算出
// 各个角度的sin/cos, 然后通过公式，得到圆圆形顶点
// f(x) = centre.x + cos()*radius
// f(y) = centre.y + sin()*radius
// 以上, 可以提前算好 sin/cos 加速整个过程
func (dl *DrawList) PathArcToFast(centre f32.Vec2, radius float32, min12, max12 int) {
	if radius == 0 || min12 > max12 {
		dl.path[dl.pathUsed] = centre; dl.pathUsed ++
		return
	}
	for a := min12; a <= max12; a++ {
		x := centre[0] + dl.CircleVtx12[a%12][0] * radius
		y := centre[1] + dl.CircleVtx12[a%12][1] * radius
		dl.path[dl.pathUsed] = f32.Vec2{x, y}
		dl.pathUsed ++
	}
}

func (dl *DrawList) PathArcTo(centre f32.Vec2, radius float32, min, max float32, segments int) {
	if radius == 0 {
		dl.path[dl.pathUsed] = centre; dl.pathUsed++
		return
	}
	for i := 0; i <= segments; i++ {
		a := min + (float32(i)/float32(segments)) * (max-min)
		x := centre[0] + math.Cos(a) * radius
		y := centre[1] + math.Sin(a) * radius
		dl.path[dl.pathUsed] = f32.Vec2{x, y}
		dl.pathUsed ++
	}

}

func (dl *DrawList) PathBezierCurveTo(p2, p3, p4 f32.Vec2, segments int) {

}

func (dl *DrawList) PathRect(a, b f32.Vec2, rounding float32, corners FlagCorner) {
	if rounding <= 0 || corners == FlagCornerNone {
		dl.PathLineTo(a)
		dl.PathLineTo(f32.Vec2{b[0], a[1]})
		dl.PathLineTo(b)
		dl.PathLineTo(f32.Vec2{a[0], b[1]})
	} else {
		var bl, br, tr, tl float32
		if (corners & FlagCornerBottomLeft) != 0 {
			bl = rounding
		}
		if (corners & FlagCornerBottomRight) != 0 {
			br = rounding
		}
		if (corners & FlagCornerTopRight) != 0 {
			tr = rounding
		}
		if (corners & FlagCornerTopLeft) != 0 {
			tl = rounding
		}
		dl.PathArcToFast(f32.Vec2{a[0]+bl, a[1]+bl}, bl, 6, 9) // bottom-left
		dl.PathArcToFast(f32.Vec2{b[0]-br, a[1]+br}, br, 9, 12)// bottom-right
		dl.PathArcToFast(f32.Vec2{b[0]-tr, b[1]-tr}, tr, 0, 3) // top-right
		dl.PathArcToFast(f32.Vec2{a[0]+tl, b[1]-tl}, tl, 3, 6) // top-left
	}
}

func (dl *DrawList) AddLine(a, b f32.Vec2, color uint32, thickness float32) {
	dl.PathLineTo(a.Add(f32.Vec2{.5, .5}))
	dl.PathLineTo(b.Add(f32.Vec2{.5, .5}))
	dl.PathStroke(color, thickness, false)
}

// 所有非填充图形看来都是使用路径实现的
func (dl *DrawList) AddRect(a, b f32.Vec2, color uint32, rounding float32, roundFlags FlagCorner, thickness float32) {
	//dl.PathRect(a.Add(mgl32.Vec2{5, .5}), b.Sub(mgl32.Vec2{.5, .5}), rounding, roundFlags)
	// TODO
	dl.PathRect(a, b, rounding, roundFlags)
	dl.PathStroke(color, thickness, true)
}

func (dl *DrawList) AddRectFilled(min, max f32.Vec2, color uint32, rounding float32, corner FlagCorner) {
	if rounding > 0 && corner != FlagCornerNone {
		dl.PathRect(min, max, rounding, corner)
		dl.PathFillConvex(color)
	} else {
		dl.PrimReserve(6, 4)
		dl.PrimRect(min, max, color)
		dl.AddCommand(6)
	}
}

func (dl *DrawList) AddRectFilledMultiColor() {

}

func (dl *DrawList) AddQuad(a, b, c, d f32.Vec2, color uint32, thickness float32) {
	dl.PathLineTo(a)
	dl.PathLineTo(b)
	dl.PathLineTo(c)
	dl.PathLineTo(d)
	dl.PathStroke(color, thickness, true)
}

func (dl *DrawList) AddQuadFilled(a, b, c, d f32.Vec2, color uint32) {
	dl.PathLineTo(a)
	dl.PathLineTo(b)
	dl.PathLineTo(c)
	dl.PathLineTo(d)
	dl.PathFillConvex(color)
}

func (dl *DrawList) AddTriangle(a, b, c f32.Vec2, color uint32, thickness float32) {
	dl.PathLineTo(a)
	dl.PathLineTo(b)
	dl.PathLineTo(c)
	dl.PathStroke(color, thickness, true)
}

func (dl *DrawList) AddTriangleFilled(a, b, c f32.Vec2, color uint32) {
	dl.PathLineTo(a)
	dl.PathLineTo(b)
	dl.PathLineTo(c)
	dl.PathFillConvex(color)
}

func (dl *DrawList) AddCircle(centre f32.Vec2, radius float32, color uint32, segments int, thickness float32) {
	max := math.Pi * 2 * float32(segments-1)/float32(segments)
	dl.PathArcTo(centre, radius, 0.0, max, segments)
	dl.PathStroke(color, thickness, true)
}

func (dl *DrawList) AddCircleFilled(centre f32.Vec2, radius float32, color uint32, segments int) {
	max := math.Pi * 2 * float32(segments-1)/float32(segments)
	dl.PathArcTo(centre, radius,0.0, max, segments)
	dl.PathFillConvex(color)
}

func (dl *DrawList) AddBezierCurve(pos0 f32.Vec2, cp0, cp1 f32.Vec2, pos1 f32.Vec2,
	color uint32, thickness float32, segments int) {
	dl.PathLineTo(pos0)
	dl.PathBezierCurveTo(cp0, cp1, pos1, segments)
	dl.PathStroke(color, thickness, false)
}

func (dl *DrawList) AddImage(texId uint16, a, b f32.Vec2, uva, uvb f32.Vec2, color uint32) {
	if n := len(dl.TextureIdStack); n == 0 || texId != dl.TextureIdStack[n-1]  {
		dl.PushTextureId(texId)
		defer dl.PopTextureId()
	}

	dl.PrimReserve(6, 4)
	dl.PrimRectUV(a, b, uva, uvb, color)
	dl.AddCommand(6)
}

func (dl *DrawList) AddImageQuad(texId uint16, a, b, c, d f32.Vec2, uva, uvb, uvc, uvd f32.Vec2, color uint32) {
	if n := len(dl.TextureIdStack); n == 0 || texId != dl.TextureIdStack[n-1] {
		dl.PushTextureId(texId)
		defer dl.PopTextureId()
	}
	dl.PrimReserve(6, 4)
	dl.PrimQuadUV(a, b, c, d, uva, uvb, uvc, uvd, color)
	dl.AddCommand(6)
}

func (dl *DrawList) AddImageRound(texId uint16, a, b f32.Vec2, uva, uvb f32.Vec2, color uint32, rounding float32, corners FlagCorner) {
	if rounding <= 0 || (corners & FlagCornerAll) == 0 {
		dl.AddImage(texId, a, b, uva, uvb, color)
		return
	}
	if n := len(dl.TextureIdStack); n == 0 || texId != dl.TextureIdStack[n-1] {
		dl.PushTextureId(texId)
		defer dl.PopTextureId()
	}

	dl.PathRect(a, b, rounding, corners)
	dl.PathFillConvex(color)

	// map uv to vertex - linear scale
	xySize, uvSize := b.Sub(a), uvb.Sub(uva)
	var scale f32.Vec2
	if xySize[0] != 0 {
		scale[0] = uvSize[0]/xySize[0]
	}
	if xySize[1] != 0 {
		scale[1] = uvSize[1]/xySize[1]
	}

	// clamp??
	for i  := range dl.VtxWriter {
		vertex := &dl.VtxWriter[i]
		dx := (vertex.xy[0] - a[0]) * scale[0]
		dy := (vertex.xy[1] - a[1]) * scale[1]
		vertex.uv = f32.Vec2{uva[0]+dx, uva[1]+dy}
	}
}

// NinePatch Algorithm
//  12   13   14   15
//       x1   x2     max
//  +----+----+----+
//  |    |    |    |
//  |    |    |p1  |
//  +----+----+----+ y2
//  |    |    |    |
//  |    |p0  |    |
//  +----+----+----+ y1
//  |    |    |    |
//  |    |    |    |
//  +----+----+----+
//min
//  0    1    2    3
//patch = {x1, x2, y1, y2} % TextureSize
func (dl *DrawList) AddImageNinePatch(texId uint16, min, max f32.Vec2, uva, uvb f32.Vec2, patch f32.Vec4, color uint32) {
	if n := len(dl.TextureIdStack); n == 0 || texId != dl.TextureIdStack[n-1]  {
		dl.PushTextureId(texId)
		defer dl.PopTextureId()
	}

	_, tex := bk.R.Texture(texId)
	texSize := f32.Vec2{tex.Width, tex.Height}

	idxCount, vtxCount := 9 * 6, 16
	dl.PrimReserve(idxCount, vtxCount)

	x1, x2, y1, y2 := min[0]+patch[0]*texSize[0], max[0]-patch[1]*texSize[0], min[1]+patch[2]*texSize[1], max[1]-patch[3]*texSize[1]
	uvw, uvh := uvb[0]-uva[0], uvb[1]-uva[1]
	u1, u2, v1, v2 := uva[0]+patch[0]*uvw, uvb[0]-patch[1]*uvw, uva[1]+patch[2]*uvh, uvb[1]-patch[3]*uvh

	if x2 < x1 {
		x1 = (min[0] + max[0])/2; x2 = x1
	}
	if y2 < y1 {
		y1 = (min[1] + max[1])/2; y2 = y1
	}

	vtxWriter := dl.VtxWriter
	idxWriter := dl.IdxWriter

	// fill vertex
	vtxWriter[0] = DrawVert{min, uva, color}
	vtxWriter[1] = DrawVert{f32.Vec2{x1, min[1]}, f32.Vec2{u1, uva[1]}, color}
	vtxWriter[2] = DrawVert{f32.Vec2{x2, min[1]}, f32.Vec2{u2, uva[1]}, color}
	vtxWriter[3] = DrawVert{f32.Vec2{max[0], min[1]}, f32.Vec2{uvb[0], uva[1]}, color}

	vtxWriter[4] = DrawVert{f32.Vec2{min[0], y1}, f32.Vec2{uva[0], v1}, color}
	vtxWriter[5] = DrawVert{f32.Vec2{x1, y1}, f32.Vec2{u1, v1}, color}
	vtxWriter[6] = DrawVert{f32.Vec2{x2, y1}, f32.Vec2{u2, v1}, color}
	vtxWriter[7] = DrawVert{f32.Vec2{max[0], y1}, f32.Vec2{uvb[0], v1}, color}

	vtxWriter[8] = DrawVert{f32.Vec2{min[0], y2}, f32.Vec2{uva[0], v2}, color}
	vtxWriter[9] = DrawVert{f32.Vec2{x1, y2}, f32.Vec2{u1, v2}, color}
	vtxWriter[10] = DrawVert{f32.Vec2{x2, y2}, f32.Vec2{u2, v2}, color}
	vtxWriter[11] = DrawVert{f32.Vec2{max[0], y2}, f32.Vec2{uvb[0], v2}, color}

	vtxWriter[12] = DrawVert{f32.Vec2{min[0], max[1]}, f32.Vec2{uva[0], uvb[1]}, color}
	vtxWriter[13] = DrawVert{f32.Vec2{x1, max[1]}, f32.Vec2{u1, uvb[1]}, color}
	vtxWriter[14] = DrawVert{f32.Vec2{x2, max[1]}, f32.Vec2{u2, uvb[1]}, color}
	vtxWriter[15] = DrawVert{max, uvb, color}

	// fill index
	ii := uint16(dl.vtxIndex)
	for i, v := range ninePatchIndex {
		idxWriter[i] = DrawIdx(ii+v)
	}
	dl.idxIndex += idxCount
	dl.vtxIndex += vtxCount

	dl.AddCommand(idxCount)
}

var ninePatchIndex = [54]uint16 {
	0, 1, 5,  0, 5,  4,   1, 2,  6,  1, 6,  5,   2,  3, 7,  2,  7,  6,
	4, 5, 9,  4, 9,  8,   5, 6,  10, 5, 10, 9,   6,  7, 11, 6,  11, 10,
	8, 9, 13, 8, 13, 12,  9, 10, 14, 9, 14, 13,  10, 11,15, 10, 15, 14,
}

func (dl *DrawList) AddText(pos f32.Vec2, text string, font font.Font, fontSize float32, color uint32, wrapWidth float32) (size f32.Vec2){
	if text == "" {
		return
	}
	if font == nil {
		font = dl.Font
	}
	if fontSize == 0 {
		fontSize = dl.FontSize
	}

	fr := &FontRender{
		DrawList:dl,
		fontSize:fontSize,
		font:font,
		color:color,
	}

	if wrapWidth > 0 {
		size = fr.RenderWrapped(pos, text, wrapWidth)
	} else {
		size = fr.RenderText(pos, text)
	}
	return
}

// 每次绘制都会产生一个 Command （可能会造成内存浪费! 1k cmd = 1000 * 6 * 4 = 24k）
// 为了减少内存可以一边添加一边尝试向前合并
func (dl *DrawList) AddCommand(elemCount int) {
	var (
		clip  = dl.CurrentClipRect()
		tex   = dl.CurrentTextureId()
		order = dl.ZOrder
		index = dl.cmdIndex
	)
	if prev := &dl.CmdBuffer[index-1]; prev.ClipRect == clip && prev.TextureId == tex && prev.zOrder == order{
		prev.ElemCount += uint16(elemCount)
	} else {
		fi := prev.FirstIndex+prev.ElemCount
		dl.CmdBuffer[index] = DrawCmd{fi,uint16(elemCount),clip,tex, order}
		dl.cmdIndex += 1
	}
}

func (dl *DrawList) Commands() []DrawCmd {
	return dl.CmdBuffer[1:dl.cmdIndex]
}




```

`gui/font.go`:

```go
package gui

import (
	"unicode/utf8"
	"korok.io/korok/math"
	"korok.io/korok/math/f32"
	"korok.io/korok/gfx/font"
)

// 工具结构，负责把字符串转化为顶点..
// 拥有所有需要的条件属性
type FontRender struct {
	*DrawList
	fontSize float32
	font font.Font
	color uint32
	lineSpace float32
}

// 当前的实现中，不考虑裁切优化，全部绘制所有字符
func (fr *FontRender) RenderText(pos f32.Vec2, text string) (size f32.Vec2){
	dx, dy := pos[0], pos[1]
	maxWidth := float32(0)

	idxCount := len(text) * 6
	vtxCount := len(text) * 4
	fr.DrawList.PrimReserve(idxCount, vtxCount)

	vtxWriter := fr.DrawList.VtxWriter
	idxWriter := fr.DrawList.IdxWriter

	color := fr.color
	_, gh := fr.font.Bounds()
	scale := fr.fontSize/gh
	lineHeight := fr.fontSize

	lineSpace := fr.lineSpace
	if lineSpace == 0 {
		lineSpace = 0.4 * lineHeight
	}

	bufferUsed := 0

	for i, w := 0, 0; i < len(text); i += w {
		r, width := utf8.DecodeRuneInString(text[i:])
		w = width

		if r == '\n' {
			if dx > maxWidth {
				maxWidth = dx
			}

			dy -= lineHeight + lineSpace
			dx = pos[0]
			continue
		}

		g, _ := fr.font.Glyph(r)

		// Add kerning todo
		// dx += getKerning(preglyph, g)
		x1, y1 := dx, dy - (g.Height+g.YOffset) * scale
		x2, y2 := x1 + g.Width * scale, dy - (g.YOffset) * scale
		u1,v1, u2, v2 := fr.font.Frame(r)

		vi := bufferUsed * 4
		vtxWriter[vi+0] = DrawVert{f32.Vec2{x1, y1}, f32.Vec2{u1, v2}, color}
		vtxWriter[vi+1] = DrawVert{f32.Vec2{x2, y1}, f32.Vec2{u2, v2}, color}
		vtxWriter[vi+2] = DrawVert{f32.Vec2{x2, y2}, f32.Vec2{u2, v1}, color}
		vtxWriter[vi+3] = DrawVert{f32.Vec2{x1, y2}, f32.Vec2{u1, v1}, color}

		ii, offset := bufferUsed * 6, fr.DrawList.vtxIndex
		idxWriter[ii+0] = DrawIdx(offset+0)
		idxWriter[ii+1] = DrawIdx(offset+1)
		idxWriter[ii+2] = DrawIdx(offset+2)
		idxWriter[ii+3] = DrawIdx(offset+0)
		idxWriter[ii+4] = DrawIdx(offset+2)
		idxWriter[ii+5] = DrawIdx(offset+3)

		fr.DrawList.idxIndex += 6
		fr.DrawList.vtxIndex += 4

		dx += float32(g.Advance) * scale
		bufferUsed ++
		// character space & line spacing todo
		// 处理 < 32 的控制符号!!
	}

	if dx > maxWidth {
		maxWidth = dx
	}
	size[0] = maxWidth - pos[0]
	size[1] = pos[1]-dy+fr.fontSize

	fr.DrawList.AddCommand(bufferUsed*6)
	return
}

func (fr *FontRender) RenderWrapped(pos f32.Vec2, text string, wrapWidth float32) (size f32.Vec2){
	wrap  := math.Max(wrapWidth, 0)
	// wrap text
	_, lines := font.Wrap(fr.font, text, wrap, fr.fontSize)
	//log.Println(lines)

	size = fr.RenderText(pos, lines)
	return
}










```

`gui/gui.go`:

```go
package gui

import (
	"korok.io/korok/gfx"
	"korok.io/korok/gfx/font"
)

//	Awesome GUI System

// Widgets: Text
func Text(id ID, bb Rect, text string, style *TextStyle) {
	if style == nil {
		style = &gContext.Theme.Text
	}
	gContext.Text(id, &bb, text, style)
	return
}

func TextSizeColored(id ID, bb Rect, text string, color gfx.Color, size float32) {
	sty := gContext.Theme.Text
	sty.Color = color
	sty.Size = size
	gContext.Text(id, &bb,text, &sty)
}

// Widgets: InputEditor
func InputText(id ID, bb Rect, hint string, style *InputStyle) {
	gContext.InputText(id, &bb, hint, style)
}

// Widget: Image
func Image(id ID, bb Rect, tex gfx.Tex2D, style *ImageStyle) {
	gContext.Image(id, &bb, tex, style)
}

// Widget: Button
func Button(id ID, bb Rect, text string, style *ButtonStyle) (event EventType) {
	return gContext.Button(id, &bb, text, style)
}

func ImageButton(id ID, bb Rect, normal, pressed gfx.Tex2D, style *ImageButtonStyle) EventType{
	return gContext.ImageButton(id, normal, pressed, &bb, style)
}

func CheckBox(id ID, bb Rect, text string, style *CheckBoxStyle) bool {
	return false
}

// Widget: ProgressBar, Slider
func ProgressBar(id ID, bb Rect, fraction float32, style *ProgressBarStyle) {

}

func Slider(id ID, bb Rect, value *float32, style *SliderStyle) (v EventType){
	return gContext.Slider(id, &bb, value, style)
}

// Widget: ColorRect
func ColorRect(bb Rect, fill gfx.Color, rounding float32) {
	gContext.DrawRect(&bb, fill, rounding)
}

// Widget: ListView TODO
func ListView() {

}

// Offset move the ui coordinate's origin by (dx, dy)
func Offset(dx, dy float32) {
	gContext.Cursor.X += dx
	gContext.Cursor.Y += dy
}

// Move sets the ui coordinate's origin to (x, y)
func Move(x, y float32) {
	gContext.Cursor.X = x
	gContext.Cursor.Y = y
}

// Theme:
func UseTheme(style *Theme) {
	gContext.UseTheme(style)
}

func SetFont(font font.Font) {
	gContext.Theme.Font = font
	texFont, _ := font.Tex2D()
	gContext.DrawList.PushTextureId(texFont)
}

// Set Z-Order for
func SetZOrder(z int16) (old int16){
	old = gContext.ZOrder
	gContext.DrawList.ZOrder = z
	return
}

// for internal usage, DO NOT call.
func SetScreenSize(w, h float32) {
	screen.SetRealSize(w, h)
}

// ScreenSize return the physical width&height of the screen.
func ScreenSize() (w, h float32) {
	return screen.rlWidth, screen.rlHeight
}

func VirtualSize() (w, h float32) {
	return screen.vtWidth, screen.vtHeight
}

func HintAndScale() (hintx, hinty, skx, sky float32) {
	return screen.hintX, screen.hintY, screen.scaleX, screen.scaleY
}

// SetVirtualResolution set the virtual resolution.
func SetVirtualResolution(w, h float32) {
	screen.SetVirtualSize(w, h)
}

func DefaultContext() *Context {
	return gContext
}

var DebugDraw = false

var ThemeLight *Theme
var ThemeDark  *Theme

////////// implementation
// 应该设计一种状态管理机制，用这套机制来维护状态
// 比如：PopupWindow/Animation/Toast/
// 这些控件的典型特点是状态是变化的，而且不方便用代码维护
// 如果用一个专门的系统，问题可以减轻很多

var gContext *Context


func init() {
	// default theme
	ThemeLight = newLightTheme()
	ThemeDark  = newDarkTheme()

	// default context
	gContext = NewContext(ThemeLight)
}

```

`gui/gui_lib.go`:

```go
package gui

import (
	"korok.io/korok/math/f32"
	"korok.io/korok/gfx"
	"korok.io/korok/hid/input"
	"korok.io/korok/gfx/font"
)

type EventType uint8

const (
	EventWentDown  EventType = 1 << iota
	EventWentUp
	EventDown
	EventStartDrag
	EventEndDrag
	EventDragging
)

const EventNone = EventType(0)

func (et EventType) JustPressed() bool {
	return (et & EventWentDown) != 0
}

func (et EventType) JustReleased() bool {
	return (et & EventWentUp) != 0
}

func (et EventType) Down() bool {
	return (et & EventDown) != 0
}

func (et EventType) StartDrag() bool {
	return (et & EventStartDrag) != 0
}

func (et EventType) EndDrag() bool {
	return (et & EventEndDrag) != 0
}

func (et EventType) Dragging() bool {
	return (et & EventDragging) != 0
}

// UI绘制边界
type Rect struct {
	X, Y float32
	W, H float32
}

func (r *Rect) Offset(dx, dy float32) *Rect{
	r.X, r.Y = r.X+dx, r.Y+dy
	return r
}

func (r *Rect) Scale(skx, sky float32) *Rect{
	r.X, r.Y = r.X*skx, r.Y*sky
	r.W, r.H = r.W*skx, r.H*sky
	return r
}

func (r *Rect) InRange(p f32.Vec2) bool{
	if r.X < p[0] && p[0] < (r.X + r.W) && r.Y < p[1] && p[1] < (r.Y + r.H) {
		return true
	}
	return false
}

type Cursor struct {
	X, Y float32
}

// 一个Context维护UI层逻辑:
// 1. 一个 DrawList，负责生成顶点
// 2. 共享的 Theme，指针引用，多个 Context 之间可以共享
// 3. State 维护，负责维护当前的 UI 状态，比如动画，按钮，列表...
// 窗口在 Context 之上维护，默认的Context可以随意的绘制
// 在窗口内绘制的UI会受到窗口的管理.
type Context struct {
	DrawList
	*Theme
	Cursor

	// ui global state
	state struct{
		hot, active ID
		mouseX, mouseY, mouseDown int

		// drag state
		draggingPointer ID
		draggingStart f32.Vec2

		isLastEventPointerType bool
		pointerCapture ID
	}

	// sqNum should be same for  layout and drawing
	sqNum int
}

func NewContext(style *Theme) *Context {
	c := &Context{
		Theme: style,
	}
	c.state.draggingPointer = -1
	c.state.isLastEventPointerType = false
	c.state.pointerCapture = -1
	c.DrawList.Initialize()
	return c
}

func (ctx *Context) Text(id ID, bb *Rect, text string, style *TextStyle) {
	if bb.W != 0 {
		ctx.DrawText(bb, text, style)
	} else {
		var font = style.Font
		if font == nil {
			font = ctx.Theme.Font
		}
		sz := ctx.CalcTextSize(text, 0, font, style.Size)
		bb.W = sz[0]
		bb.H = sz[1]
		ctx.DrawText(bb, text, style)
	}
	return
}

// Widgets: InputEditor
func (ctx *Context) InputText(id ID, bb *Rect, hint string, style *InputStyle) {

}

// Widget: Image
func (ctx *Context) Image(id ID, bb *Rect, tex gfx.Tex2D, style *ImageStyle) {
	ctx.DrawImage(bb, tex, style)
}

// Widget: Button
func (ctx *Context) Button(id ID, bb *Rect, text string, style *ButtonStyle) (event EventType) {
	var (
		round = ctx.Theme.Button.Rounding
		offset f32.Vec2
		font font.Font
	)
	if style == nil {
		style = &ctx.Theme.Button
	}
	if style.Font != nil {
		font = style.Font
	} else {
		font = ctx.Theme.Font
	}

	if bb.W == 0 {
		textSize := ctx.CalcTextSize(text, 0, font, style.Size)
		extW := style.Padding.Left+style.Padding.Right
		extH := style.Padding.Top+style.Padding.Bottom
		bb.W = textSize[0] + extW
		bb.H = textSize[1] + extH
	} else {
		// if button has size, gravity will effect text's position
		var font = style.Font
		if font == nil {
			font = ctx.Theme.Font
		}
		textSize := ctx.CalcTextSize(text, 0, font, style.Size)
		g := style.Gravity
		offset[0] = (bb.W-textSize[0]-style.Padding.Left-style.Padding.Right) * g[0]
		offset[1] = (bb.H-textSize[1]-style.Padding.Top-style.Padding.Bottom) * g[1]
	}

	// Check Event
	event = ctx.ClickEvent(id, bb)

	// Render Frame
	if bg := style.Background; bg.Normal != (gfx.Color{}) {
		ctx.ColorBackground(event, bb, bg.Normal, bg.Pressed, round)
	} else {
		ctx.ColorBackground(event, bb, ThemeLight.Normal, ThemeLight.Pressed, round)
	}

	// Render Text
	bb.X +=  offset[0] + style.Padding.Left
	bb.Y +=  offset[1] + style.Padding.Top

	ctx.DrawText(bb, text, &style.TextStyle)
	return
}

func (ctx *Context) ImageBackground(eventType EventType) {

}

func (ctx *Context) ImageButton(id ID, normal, pressed gfx.Tex2D, bb *Rect, style *ImageButtonStyle) ( event EventType) {
	if style == nil {
		style = &ctx.Theme.ImageButton
	}
	event = ctx.ClickEvent(id, bb)
	var tex gfx.Tex2D
	if event & EventDown != 0 {
		tex = pressed
	} else {
		tex = normal
	}
	ctx.DrawImage(bb, tex, &style.ImageStyle)
	return
}

func (ctx *Context) Slider(id ID, bb *Rect, value *float32, style *SliderStyle) (e EventType){
	if style == nil {
		style = &ctx.Theme.Slider
	}
	// 说明滑动了，那么应该使用最新的值，而不是传入的值
	if v, event := ctx.CheckSlider(id, bb); event & EventDragging != 0 {
		*value = v
		e = event
	}

	ctx.DrawRect(bb, style.Bar, 5)
	ctx.DrawCircle(bb.X+bb.W*(*value), bb.Y+bb.H/2, 10, style.Knob)
	return
}

// Scroll 效果的关键是使用裁切限制滚动区域，然后
// 通过计算拖拽，来得到争取的偏移
func (ctx *Context) StartScroll(size, offset f32.Vec2) {

}

func (ctx *Context) EndScroll() {

}

func (ctx *Context) CheckSlider(id ID, bound *Rect) (v float32, e EventType) {
	event := ctx.DraggingEvent(id, bound)
	if (event & EventStartDrag) != 0 {
		ctx.state.pointerCapture = id
	}
	if (event & EventEndDrag) != 0 {
		ctx.state.pointerCapture = -1
	}
	// Update the knob position & default = Horizontal
	if (event & (EventDragging|EventWentDown)) != 0{
		p1 := (input.PointerPosition(0).MousePos[0])/screen.scaleX
		p0 := bound.X + ctx.Cursor.X
		v = (p1 - p0)/bound.W
		if v > 1 { v = 1 }
		if v < 0 { v = 0 }
	}
	e = event
	return
}

func (ctx *Context) ClickEvent(id ID, rect *Rect) EventType {
	var (
		event = EventNone
		c = ctx.Cursor
	)
	bb := Rect{(c.X+rect.X)*screen.scaleX, (c.Y+rect.Y)*screen.scaleY, rect.W*screen.scaleX,rect.H*screen.scaleY}
	if p  := input.PointerPosition(0); bb.InRange(p.MousePos) {
		btn := input.PointerButton(0)
		if btn.JustPressed() {
			ctx.state.active = id
			event = EventWentDown
		}
		if btn.JustReleased() && ctx.state.active == id {
			event = EventWentUp
			ctx.state.active = -1
		} else if btn.Down() && ctx.state.active == id {
			event |= EventDown
		}
	}
	return event
}

func (ctx *Context) DraggingEvent(id ID, bound *Rect) EventType {
	var (
		event = EventNone
		c = ctx.Cursor
	)

	bb := Rect{(c.X+bound.X)*screen.scaleX, (c.Y+bound.Y)*screen.scaleY, bound.W*screen.scaleX, bound.H*screen.scaleY}
	p  := input.PointerPosition(0)

	if bb.InRange(p.MousePos) || ctx.state.pointerCapture == id {
		// in-dragging, The pointer is in drag operation
		if btn := input.PointerButton(0); ctx.state.draggingPointer == id && !btn.JustPressed() {
			if btn.JustReleased() {
				event = EventEndDrag
				ctx.state.draggingPointer = -1
				ctx.state.draggingStart = f32.Vec2{}
				event |= EventWentUp
			} else if btn.Down() {
				event = EventDragging
			} else {
				ctx.state.draggingPointer = -1
			}
		} else {
			// Keep the click position, then use it to check a drag event
			if btn.JustPressed() {
				ctx.state.draggingStart = p.MousePos
			}
			// If the next movement out of thresh-hold, then it's a drag event
			if btn.Down() && bb.InRange(ctx.state.draggingStart) {
				var (
					startPosition  = ctx.state.draggingStart
					dragThreshHold = float32(8)
				)

				bb := Rect{startPosition[0]-dragThreshHold,
					startPosition[1]-dragThreshHold,
					dragThreshHold,
					dragThreshHold}

				// Start drag event
				if !bb.InRange(p.MousePos) {
					event |= EventStartDrag
					ctx.state.draggingStart = p.MousePos
					ctx.state.draggingPointer = id
				}
			}
		}

	}
	return event
}

func (ctx *Context) DrawQuad(vertex [4]f32.Vec2, fill gfx.Color) {
	var (
		cx, cy = ctx.Cursor.X, ctx.Cursor.Y
	)
	for i := 0; i < 4; i++ {
		vertex[i][0], vertex[i][1] = Gui2Game(vertex[i][0]+cx, vertex[i][1]+cy)
	}
	ctx.AddQuadFilled(vertex[0], vertex[1], vertex[2], vertex[3], fill.U32())
}

func (ctx *Context) DrawGradient(bb Rect, c0, c1 gfx.Color, vertical bool) {
	var (
		x = bb.X+ctx.Cursor.X
		y = bb.Y+ctx.Cursor.Y
	)
	x, y = Gui2Game(x, y)

	min := f32.Vec2{x * screen.scaleX, (y-bb.H) * screen.scaleY}
	max := f32.Vec2{(x+bb.W) * screen.scaleX, y * screen.scaleY}

	dl := &ctx.DrawList
	dl.PrimReserve(6, 4)
	uv := dl.TexUVWhitePixel
	a, b, c, d := min, f32.Vec2{max[0], min[1]}, max, f32.Vec2{min[0], max[1]}
	if vertical {
		top, down := c0.U32(), c1.U32()
		dl.VtxWriter[0] = DrawVert{a, uv, down}
		dl.VtxWriter[1] = DrawVert{b, uv, down}
		dl.VtxWriter[2] = DrawVert{c, uv, top}
		dl.VtxWriter[3] = DrawVert{d, uv, top}
	} else {
		left, right := c0.U32(), c1.U32()
		dl.VtxWriter[0] = DrawVert{a, uv, left}
		dl.VtxWriter[1] = DrawVert{b, uv, right}
		dl.VtxWriter[2] = DrawVert{c, uv, right}
		dl.VtxWriter[3] = DrawVert{d, uv, left}
	}

	dl.IdxWriter[0] = DrawIdx(dl.vtxIndex+0)
	dl.IdxWriter[1] = DrawIdx(dl.vtxIndex+1)
	dl.IdxWriter[2] = DrawIdx(dl.vtxIndex+2)

	dl.IdxWriter[3] = DrawIdx(dl.vtxIndex+0)
	dl.IdxWriter[4] = DrawIdx(dl.vtxIndex+2)
	dl.IdxWriter[5] = DrawIdx(dl.vtxIndex+3)

	dl.vtxIndex += 4
	dl.idxIndex += 6
	dl.AddCommand(6)
}

func (ctx *Context) DrawRect(bb *Rect, fill gfx.Color, round float32) {
	var (
		x = bb.X+ctx.Cursor.X
		y = bb.Y+ctx.Cursor.Y
	)
	x, y = Gui2Game(x, y)
	min := f32.Vec2{x * screen.scaleX, (y-bb.H) * screen.scaleY}
	max := f32.Vec2{(x+bb.W) * screen.scaleX, y * screen.scaleY}
	ctx.DrawList.AddRectFilled(min, max, fill.U32(), round * screen.scaleX, FlagCornerAll)
}

func (ctx *Context) DrawBorder(bb *Rect, color uint32, round, thick float32) {
	var (
		x = bb.X+ctx.Cursor.X
		y = bb.Y+ctx.Cursor.Y
	)
	x, y = Gui2Game(x, y)
	min := f32.Vec2{x * screen.scaleX, (y-bb.H) * screen.scaleY}
	max := f32.Vec2{(x+bb.W) * screen.scaleX, y * screen.scaleY}
	ctx.DrawList.AddRect(min, max, color, round * screen.scaleX, FlagCornerAll, thick)
}

func (ctx *Context) DrawDebugBorder(x, y, w, h float32, color uint32) {
	x, y = Gui2Game(x + ctx.Cursor.X, y + ctx.Cursor.Y)
	min := f32.Vec2{x * screen.scaleX, (y-h) * screen.scaleY}
	max := f32.Vec2{(x+w) * screen.scaleX, y * screen.scaleY}
	ctx.DrawList.AddRect(min, max, color, 0, FlagCornerNone, 1)
}

// default segment = 12 TODO, circle scale factor
func (ctx *Context) DrawCircle(x, y, radius float32, fill gfx.Color) {
	x, y = Gui2Game(x+ctx.Cursor.X, y+ctx.Cursor.Y)
	x = x * screen.scaleX
	y = y * screen.scaleY
	ctx.DrawList.AddCircleFilled(f32.Vec2{x, y}, radius * screen.scaleX, fill.U32(), 12)
}

// segment default=12
func (ctx *Context) DrawCircleNoneFill(x, y, radius float32, strokeColor gfx.Color, segment int, thickness float32) {
	x, y = Gui2Game(x+ctx.Cursor.X, y+ctx.Cursor.Y)
	x = x * screen.scaleX
	y = y * screen.scaleY
	ctx.DrawList.AddCircle(f32.Vec2{x, y}, radius * screen.scaleX, strokeColor.U32(), segment, thickness)
}

func (ctx *Context) DrawImage(bound *Rect, tex gfx.Tex2D, style *ImageStyle) {
	min := f32.Vec2{bound.X+ctx.Cursor.X, bound.Y+ctx.Cursor.Y}
	if bound.W == 0 {
		sz := tex.Size()
		bound.W = sz.Width
		bound.H = sz.Height
	}
	max := min.Add(f32.Vec2{bound.W, bound.H})
	var color uint32
	if style != nil {
		color = style.Tint.U32()
	} else {
		color = ctx.Theme.Image.Tint.U32()
	}
	min[0], min[1] = Gui2Game(min[0], min[1])
	max[0], max[1] = Gui2Game(max[0], max[1])

	// scale
	min[0], min[1] = min[0] * screen.scaleX, min[1] * screen.scaleY
	max[0], max[1] = max[0] * screen.scaleX, max[1] * screen.scaleY

	rg := tex.Region()
	if rg.Rotated {
		ctx.DrawList.AddImageQuad(tex.Tex(),
			min, f32.Vec2{max[0], min[1]},  max, f32.Vec2{min[0], max[1]}, // xy
			f32.Vec2{rg.X2, rg.Y1}, f32.Vec2{rg.X2, rg.Y2}, f32.Vec2{rg.X1, rg.Y2}, f32.Vec2{rg.X1, rg.Y1},// uv
			color)
	} else {
		ctx.DrawList.AddImage(tex.Tex(), min, max, f32.Vec2{rg.X1, rg.Y1}, f32.Vec2{rg.X2, rg.Y2}, color)
	}
}

// 绘制元素, bb 存储相对于父容器的相对坐标..
func (ctx *Context) DrawText(bb *Rect, text string, style *TextStyle) (size f32.Vec2) {
	x, y := Gui2Game(bb.X+ctx.Cursor.X, bb.Y+ctx.Cursor.Y)
	var (
		font = style.Font
		fontSize = style.Size * screen.scaleX // TODO 字体缩放不能这么简单的考虑
		color = style.Color.U32()
		wrapWidth = (bb.W + 10) * screen.scaleX
		pos = f32.Vec2{x * screen.scaleX, y * screen.scaleY}
	)
	if font == nil {
		font = ctx.Theme.Font
	}
	size = ctx.DrawList.AddText(pos, text, font, fontSize, color, wrapWidth)
	return
}

func (ctx *Context) CalcTextSize(text string, wrapWidth float32, fnt font.Font, fontSize float32) f32.Vec2 {
	return font.CalculateTextSize(text, fnt, fontSize)
}

// 偷师 flat-ui 中的设计，把空间的前景和背景分离，背景单独根据事件来变化..
// 在 Android 中，Widget的前景和背景都可以根据控件状态发生变化
// 但是在大部分UI中，比如 Text/Image 只会改变背景的状态
// 偷懒的自定义UI，不做任何状态的改变... 所以说呢, 我们也采用偷懒的做法呗。。
func (ctx *Context) ColorBackground(event EventType, bb *Rect, normal, pressed gfx.Color, round float32) {
	if (event & EventDown) != 0 {
		ctx.DrawRect(bb, pressed, round)
	} else {
		ctx.DrawRect(bb, normal, round)
	}
}

// Clip:
func (ctx *Context) PushClipRect(minClip, maxClip f32.Vec2, intersectCurrent bool) {

}

// Theme:
func (ctx *Context) UseTheme(style *Theme) {
	ctx.Theme = style
}

func Gui2Game(x, y float32) (x1, y1 float32) {
	return x, screen.hintY - y
}

func Game2Gui(x, y float32) (x1, y1 float32) {
	return x, screen.hintY - y
}

type screenSize struct{
	rlWidth, rlHeight float32
	vtWidth, vtHeight float32
	// hint
	hintX, scaleX float32
	hintY, scaleY float32
}

func (sc *screenSize) SetRealSize(w, h float32) {
	sc.rlWidth, sc.rlHeight = w, h
	sc.updateHint()
}

func (sc *screenSize) SetVirtualSize(w, h float32) {
	sc.vtWidth, sc.vtHeight = w, h
	sc.updateHint()
}

func (sc *screenSize) updateHint() {
	if screen.rlWidth == 0 || screen.rlHeight == 0 {
		return
	}
	// update hint
	w := screen.vtWidth
	h := screen.vtHeight
	if w == 0 && h == 0 {
		screen.hintX = screen.rlWidth
		screen.hintY = screen.rlHeight
		screen.scaleX = 1
		screen.scaleY = 1
	} else if w == 0 {
		f := screen.rlHeight/h
		screen.scaleY = f
		screen.scaleX = f
		screen.hintY = h
		screen.hintX = screen.rlWidth/f
	} else if h == 0 {
		f := screen.rlWidth/w
		screen.scaleY = f
		screen.scaleX = f
		screen.hintX = w
		screen.hintY = screen.rlHeight/f
	} else {
		screen.scaleX = screen.rlWidth/w
		screen.scaleY = screen.rlHeight/h
		screen.hintX = w
		screen.hintY = h
	}
}

var screen screenSize
```

`gui/id.go`:

```go
package gui

// 每个控件都需要手动传入一个 Id
type ID int

// 返回一个 Id
func GenID(name string) ID {
	return 0
}

type IdMap map[string]ID

```

`gui/render.go`:

```go
package gui

import (
	"korok.io/korok/gfx"
	"korok.io/korok/gfx/bk"
	"korok.io/korok/math/f32"

	"unsafe"
	"korok.io/korok/gfx/dbg"
)

type UIRenderFeature struct {
	id int
	*gfx.MeshRender
	*DrawList
	*gfx.Camera

	Buffer struct{
		firstDraw bool
		iid, vid uint16
		isz, vsz int
		vertex *bk.VertexBuffer
		index *bk.IndexBuffer
	}
}

func (f *UIRenderFeature) SetDrawList(dl *DrawList) {
	f.DrawList = dl
}

func (f *UIRenderFeature) Register(rs *gfx.RenderSystem) {
	f.Camera = &rs.MainCamera
	// init render
	for _, r := range rs.RenderList {
		switch render := r.(type) {
		case *gfx.MeshRender:
			f.MeshRender = render; break
		}
	}
	// add new feature, use the index as id
	f.id = rs.Accept(f)
	f.DrawList = &gContext.DrawList
	f.Buffer.vid = bk.InvalidId
	f.Buffer.iid = bk.InvalidId
}

func (f *UIRenderFeature) Extract(v *gfx.View) {
	if dl := f.DrawList; !dl.Empty() {
		fi := uint32(f.id)<<16
		for i, cmd := range dl.Commands() {
			sid := gfx.PackSortId(cmd.zOrder, 0)
			val := fi + uint32(i)
			v.RenderNodes = append(v.RenderNodes, gfx.SortObject{SortId:sid, Value:val})
		}
	}
}

// TODO rotation..
func (f *UIRenderFeature) Draw(nodes gfx.RenderNodes) {
	var (
		sw, _ = f.Camera.Screen()
		x, y, w, h = f.Camera.View()
		sx, sy = f.Camera.Scale()
	)
	dx := x - w*sx/2
	dy := y - h*sy/2
	sk := w*sx/sw

	// setup buffer
	isz, vsz := f.DrawList.Size()
	if f.Buffer.firstDraw {
		f.Buffer.firstDraw = false
		f.allocBuffer(isz, vsz)
		f.Buffer.vertex.Update(0, uint32(vsz*20), unsafe.Pointer(&f.DrawList.VtxBuffer[0]),false)
		f.Buffer.index.Update(0, uint32(isz*2), unsafe.Pointer(&f.DrawList.IdxBuffer[0]), false)
	}

	mesh := &gfx.Mesh{
		IndexId:f.Buffer.iid,
		VertexId:f.Buffer.vid,
	}
	mat4 := &f32.Mat4{sk, 0, 0, 0, 0, sk, 0, 0, dx, dy, 1, 0, 0, 0, 0, 1}
	commands := f.DrawList.Commands()
	for _, node := range nodes {
		index := node.Value&0xFFFF
		cmd := commands[index]

		mesh.FirstVertex = 0
		mesh.NumVertex = uint16(vsz)
		mesh.FirstIndex = cmd.FirstIndex
		mesh.NumIndex = cmd.ElemCount
		mesh.SetTexture(cmd.TextureId)

		f.MeshRender.Draw(mesh, mat4, int32(cmd.zOrder))
	}
}

func (f *UIRenderFeature) Flush() {
	isz, vsz := f.DrawList.Size()
	dbg.Hud("gui DrawList: %d, %d", isz, vsz)
	f.DrawList.Clear()
	f.Buffer.firstDraw = true
}

func (f *UIRenderFeature) allocBuffer(isz, vsz int) {
	if isz > f.Buffer.isz {
		if iid := f.Buffer.iid; iid != bk.InvalidId {
			bk.R.Free(iid)
		}
		{
			isz--
			isz |= isz >> 1
			isz |= isz >> 2
			isz |= isz >> 3
			isz |= isz >> 8
			isz |= isz >> 16
			isz++
		}
		id, ib := bk.R.AllocIndexBuffer(bk.Memory{nil, uint32(isz)*2})
		f.Buffer.iid = id
		f.Buffer.isz = isz
		f.Buffer.index = ib
	}

	vid, _, vb := gfx.Context.TempVertexBuffer(vsz, 20)
	f.Buffer.vid = vid
	f.Buffer.vertex = vb
}


```

`gui/style.go`:

```go
package gui

import (
	"korok.io/korok/gfx"
	"korok.io/korok/gfx/font"
	"korok.io/korok/math/f32"
)

type Visibility uint8

const (
	Visible Visibility = iota
	InVisible
	Gone
)

type Theme struct {
	Text        TextStyle
	Button      ButtonStyle
	Image       ImageStyle
	ImageButton ImageButtonStyle
	Slider      SliderStyle

	// global config..
	Normal  gfx.Color
	Pressed gfx.Color
	// item 之间的空隙
	Spacing float32

	// default font
	font.Font
}

type Padding struct {
	Left, Right, Top, Bottom float32
}

type TextStyle struct {
	Font      font.Font
	Color     gfx.Color
	Size      float32
	Lines     int
	LineSpace float32
}

func (text *TextStyle) SetFont(f font.Font) *TextStyle {
	text.Font = f
	return text
}

func (text *TextStyle) SetColor(color gfx.Color) *TextStyle {
	text.Color = color
	return text
}

func (text *TextStyle) SetSize(size float32) *TextStyle {
	text.Size = size
	return text
}

type InputStyle struct {
	Visibility
	Color, HintColor uint32
	Size             float32
}

type ButtonStyle struct {
	TextStyle
	Padding
	Background struct {
		Normal  gfx.Color
		Pressed gfx.Color
	}
	Gravity  f32.Vec2
	Rounding float32
}

type ImageButtonStyle struct {
	ImageStyle
	Padding
}

type ImageStyle struct {
	Tint gfx.Color
}

type CheckBoxStyle struct {
}

type ProgressBarStyle struct {
}

type SliderStyle struct {
	Bar, Knob gfx.Color
}

//// 这样
func newLightTheme() *Theme {
	return &Theme{
		Text:TextStyle{
			Color:gfx.Black,
			Size:12,
			LineSpace:6,
		},
		Button:ButtonStyle{
			TextStyle:TextStyle{Color:gfx.Black, Size:12},
			Padding:Padding{10, 10, 10, 10},
			Gravity:f32.Vec2{.5, .5},
			Rounding:5,
		},
		Image: ImageStyle{gfx.White},
		ImageButton: ImageButtonStyle{
			ImageStyle: ImageStyle{Tint: gfx.White},
			Padding:    Padding{0, 0, 0, 0},
		},
		Slider: SliderStyle{
			gfx.LTGray, gfx.Gray,
		},
		Normal:  gfx.LTGray,
		Pressed: gfx.Gray,
		Spacing: 4,
	}
}

func newDarkTheme() *Theme {
	return &Theme{}
}

```

`hid/config.go`:

```go
package hid

import "korok.io/korok/math/f32"

type WindowOptions struct{
	Title string
	Width int
	Height int
	Clear f32.Vec4
	FullScreen bool
	NoVsync    bool
	NoTitleBar bool
	Resizable  bool
}

```

`hid/doc.go`:

```go
package hid

/**
	HID = Human interface device

	此处处理用户输入，窗口等问题
 */

```

`hid/gl/consts.go`:

```go
// Copyright 2014 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package gl

/*
Partially generated from the Khronos OpenGL API specification in XML
format, which is covered by the license:

	Copyright (c) 2013-2014 The Khronos Group Inc.

	Permission is hereby granted, free of charge, to any person obtaining a
	copy of this software and/or associated documentation files (the
	"Materials"), to deal in the Materials without restriction, including
	without limitation the rights to use, copy, modify, merge, publish,
	distribute, sublicense, and/or sell copies of the Materials, and to
	permit persons to whom the Materials are furnished to do so, subject to
	the following conditions:

	The above copyright notice and this permission notice shall be included
	in all copies or substantial portions of the Materials.

	THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
	CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
	TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
	MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.

*/

const (
	POINTS                                       = 0x0000
	LINES                                        = 0x0001
	LINE_LOOP                                    = 0x0002
	LINE_STRIP                                   = 0x0003
	TRIANGLES                                    = 0x0004
	TRIANGLE_STRIP                               = 0x0005
	TRIANGLE_FAN                                 = 0x0006
	SRC_COLOR                                    = 0x0300
	ONE_MINUS_SRC_COLOR                          = 0x0301
	SRC_ALPHA                                    = 0x0302
	ONE_MINUS_SRC_ALPHA                          = 0x0303
	DST_ALPHA                                    = 0x0304
	ONE_MINUS_DST_ALPHA                          = 0x0305
	DST_COLOR                                    = 0x0306
	ONE_MINUS_DST_COLOR                          = 0x0307
	SRC_ALPHA_SATURATE                           = 0x0308
	FUNC_ADD                                     = 0x8006
	BLEND_EQUATION                               = 0x8009
	BLEND_EQUATION_RGB                           = 0x8009
	BLEND_EQUATION_ALPHA                         = 0x883D
	FUNC_SUBTRACT                                = 0x800A
	FUNC_REVERSE_SUBTRACT                        = 0x800B
	BLEND_DST_RGB                                = 0x80C8
	BLEND_SRC_RGB                                = 0x80C9
	BLEND_DST_ALPHA                              = 0x80CA
	BLEND_SRC_ALPHA                              = 0x80CB
	CONSTANT_COLOR                               = 0x8001
	ONE_MINUS_CONSTANT_COLOR                     = 0x8002
	CONSTANT_ALPHA                               = 0x8003
	ONE_MINUS_CONSTANT_ALPHA                     = 0x8004
	BLEND_COLOR                                  = 0x8005
	ARRAY_BUFFER                                 = 0x8892
	ELEMENT_ARRAY_BUFFER                         = 0x8893
	ARRAY_BUFFER_BINDING                         = 0x8894
	ELEMENT_ARRAY_BUFFER_BINDING                 = 0x8895
	STREAM_DRAW                                  = 0x88E0
	STATIC_DRAW                                  = 0x88E4
	DYNAMIC_DRAW                                 = 0x88E8
	BUFFER_SIZE                                  = 0x8764
	BUFFER_USAGE                                 = 0x8765
	CURRENT_VERTEX_ATTRIB                        = 0x8626
	FRONT                                        = 0x0404
	BACK                                         = 0x0405
	FRONT_AND_BACK                               = 0x0408
	TEXTURE_2D                                   = 0x0DE1
	CULL_FACE                                    = 0x0B44
	BLEND                                        = 0x0BE2
	DITHER                                       = 0x0BD0
	STENCIL_TEST                                 = 0x0B90
	DEPTH_TEST                                   = 0x0B71
	SCISSOR_TEST                                 = 0x0C11
	POLYGON_OFFSET_FILL                          = 0x8037
	SAMPLE_ALPHA_TO_COVERAGE                     = 0x809E
	SAMPLE_COVERAGE                              = 0x80A0
	INVALID_ENUM                                 = 0x0500
	INVALID_VALUE                                = 0x0501
	INVALID_OPERATION                            = 0x0502
	OUT_OF_MEMORY                                = 0x0505
	CW                                           = 0x0900
	CCW                                          = 0x0901
	LINE_WIDTH                                   = 0x0B21
	ALIASED_POINT_SIZE_RANGE                     = 0x846D
	ALIASED_LINE_WIDTH_RANGE                     = 0x846E
	CULL_FACE_MODE                               = 0x0B45
	FRONT_FACE                                   = 0x0B46
	DEPTH_RANGE                                  = 0x0B70
	DEPTH_WRITEMASK                              = 0x0B72
	DEPTH_CLEAR_VALUE                            = 0x0B73
	DEPTH_FUNC                                   = 0x0B74
	STENCIL_CLEAR_VALUE                          = 0x0B91
	STENCIL_FUNC                                 = 0x0B92
	STENCIL_FAIL                                 = 0x0B94
	STENCIL_PASS_DEPTH_FAIL                      = 0x0B95
	STENCIL_PASS_DEPTH_PASS                      = 0x0B96
	STENCIL_REF                                  = 0x0B97
	STENCIL_VALUE_MASK                           = 0x0B93
	STENCIL_WRITEMASK                            = 0x0B98
	STENCIL_BACK_FUNC                            = 0x8800
	STENCIL_BACK_FAIL                            = 0x8801
	STENCIL_BACK_PASS_DEPTH_FAIL                 = 0x8802
	STENCIL_BACK_PASS_DEPTH_PASS                 = 0x8803
	STENCIL_BACK_REF                             = 0x8CA3
	STENCIL_BACK_VALUE_MASK                      = 0x8CA4
	STENCIL_BACK_WRITEMASK                       = 0x8CA5
	VIEWPORT                                     = 0x0BA2
	SCISSOR_BOX                                  = 0x0C10
	COLOR_CLEAR_VALUE                            = 0x0C22
	COLOR_WRITEMASK                              = 0x0C23
	UNPACK_ALIGNMENT                             = 0x0CF5
	PACK_ALIGNMENT                               = 0x0D05
	MAX_TEXTURE_SIZE                             = 0x0D33
	MAX_VIEWPORT_DIMS                            = 0x0D3A
	SUBPIXEL_BITS                                = 0x0D50
	RED_BITS                                     = 0x0D52
	GREEN_BITS                                   = 0x0D53
	BLUE_BITS                                    = 0x0D54
	ALPHA_BITS                                   = 0x0D55
	DEPTH_BITS                                   = 0x0D56
	STENCIL_BITS                                 = 0x0D57
	POLYGON_OFFSET_UNITS                         = 0x2A00
	POLYGON_OFFSET_FACTOR                        = 0x8038
	TEXTURE_BINDING_2D                           = 0x8069
	SAMPLE_BUFFERS                               = 0x80A8
	SAMPLES                                      = 0x80A9
	SAMPLE_COVERAGE_VALUE                        = 0x80AA
	SAMPLE_COVERAGE_INVERT                       = 0x80AB
	NUM_COMPRESSED_TEXTURE_FORMATS               = 0x86A2
	COMPRESSED_TEXTURE_FORMATS                   = 0x86A3
	DONT_CARE                                    = 0x1100
	FASTEST                                      = 0x1101
	NICEST                                       = 0x1102
	GENERATE_MIPMAP_HINT                         = 0x8192
	BYTE                                         = 0x1400
	UNSIGNED_BYTE                                = 0x1401
	SHORT                                        = 0x1402
	UNSIGNED_SHORT                               = 0x1403
	INT                                          = 0x1404
	UNSIGNED_INT                                 = 0x1405
	FLOAT                                        = 0x1406
	FIXED                                        = 0x140C
	DEPTH_COMPONENT                              = 0x1902
	ALPHA                                        = 0x1906
	RGB                                          = 0x1907
	RGBA                                         = 0x1908
	LUMINANCE                                    = 0x1909
	LUMINANCE_ALPHA                              = 0x190A
	UNSIGNED_SHORT_4_4_4_4                       = 0x8033
	UNSIGNED_SHORT_5_5_5_1                       = 0x8034
	UNSIGNED_SHORT_5_6_5                         = 0x8363
	MAX_VERTEX_ATTRIBS                           = 0x8869
	MAX_VERTEX_UNIFORM_VECTORS                   = 0x8DFB
	MAX_VARYING_VECTORS                          = 0x8DFC
	MAX_COMBINED_TEXTURE_IMAGE_UNITS             = 0x8B4D
	MAX_VERTEX_TEXTURE_IMAGE_UNITS               = 0x8B4C
	MAX_TEXTURE_IMAGE_UNITS                      = 0x8872
	MAX_FRAGMENT_UNIFORM_VECTORS                 = 0x8DFD
	SHADER_TYPE                                  = 0x8B4F
	DELETE_STATUS                                = 0x8B80
	LINK_STATUS                                  = 0x8B82
	VALIDATE_STATUS                              = 0x8B83
	ATTACHED_SHADERS                             = 0x8B85
	ACTIVE_UNIFORMS                              = 0x8B86
	ACTIVE_UNIFORM_MAX_LENGTH                    = 0x8B87
	ACTIVE_ATTRIBUTES                            = 0x8B89
	ACTIVE_ATTRIBUTE_MAX_LENGTH                  = 0x8B8A
	SHADING_LANGUAGE_VERSION                     = 0x8B8C
	CURRENT_PROGRAM                              = 0x8B8D
	NEVER                                        = 0x0200
	LESS                                         = 0x0201
	EQUAL                                        = 0x0202
	LEQUAL                                       = 0x0203
	GREATER                                      = 0x0204
	NOTEQUAL                                     = 0x0205
	GEQUAL                                       = 0x0206
	ALWAYS                                       = 0x0207
	KEEP                                         = 0x1E00
	REPLACE                                      = 0x1E01
	INCR                                         = 0x1E02
	DECR                                         = 0x1E03
	INVERT                                       = 0x150A
	INCR_WRAP                                    = 0x8507
	DECR_WRAP                                    = 0x8508
	VENDOR                                       = 0x1F00
	RENDERER                                     = 0x1F01
	VERSION                                      = 0x1F02
	EXTENSIONS                                   = 0x1F03
	NEAREST                                      = 0x2600
	LINEAR                                       = 0x2601
	NEAREST_MIPMAP_NEAREST                       = 0x2700
	LINEAR_MIPMAP_NEAREST                        = 0x2701
	NEAREST_MIPMAP_LINEAR                        = 0x2702
	LINEAR_MIPMAP_LINEAR                         = 0x2703
	TEXTURE_MAG_FILTER                           = 0x2800
	TEXTURE_MIN_FILTER                           = 0x2801
	TEXTURE_WRAP_S                               = 0x2802
	TEXTURE_WRAP_T                               = 0x2803
	TEXTURE                                      = 0x1702
	TEXTURE_CUBE_MAP                             = 0x8513
	TEXTURE_BINDING_CUBE_MAP                     = 0x8514
	TEXTURE_CUBE_MAP_POSITIVE_X                  = 0x8515
	TEXTURE_CUBE_MAP_NEGATIVE_X                  = 0x8516
	TEXTURE_CUBE_MAP_POSITIVE_Y                  = 0x8517
	TEXTURE_CUBE_MAP_NEGATIVE_Y                  = 0x8518
	TEXTURE_CUBE_MAP_POSITIVE_Z                  = 0x8519
	TEXTURE_CUBE_MAP_NEGATIVE_Z                  = 0x851A
	MAX_CUBE_MAP_TEXTURE_SIZE                    = 0x851C
	TEXTURE0                                     = 0x84C0
	TEXTURE1                                     = 0x84C1
	TEXTURE2                                     = 0x84C2
	TEXTURE3                                     = 0x84C3
	TEXTURE4                                     = 0x84C4
	TEXTURE5                                     = 0x84C5
	TEXTURE6                                     = 0x84C6
	TEXTURE7                                     = 0x84C7
	TEXTURE8                                     = 0x84C8
	TEXTURE9                                     = 0x84C9
	TEXTURE10                                    = 0x84CA
	TEXTURE11                                    = 0x84CB
	TEXTURE12                                    = 0x84CC
	TEXTURE13                                    = 0x84CD
	TEXTURE14                                    = 0x84CE
	TEXTURE15                                    = 0x84CF
	TEXTURE16                                    = 0x84D0
	TEXTURE17                                    = 0x84D1
	TEXTURE18                                    = 0x84D2
	TEXTURE19                                    = 0x84D3
	TEXTURE20                                    = 0x84D4
	TEXTURE21                                    = 0x84D5
	TEXTURE22                                    = 0x84D6
	TEXTURE23                                    = 0x84D7
	TEXTURE24                                    = 0x84D8
	TEXTURE25                                    = 0x84D9
	TEXTURE26                                    = 0x84DA
	TEXTURE27                                    = 0x84DB
	TEXTURE28                                    = 0x84DC
	TEXTURE29                                    = 0x84DD
	TEXTURE30                                    = 0x84DE
	TEXTURE31                                    = 0x84DF
	ACTIVE_TEXTURE                               = 0x84E0
	REPEAT                                       = 0x2901
	CLAMP_TO_EDGE                                = 0x812F
	MIRRORED_REPEAT                              = 0x8370
	VERTEX_ATTRIB_ARRAY_ENABLED                  = 0x8622
	VERTEX_ATTRIB_ARRAY_SIZE                     = 0x8623
	VERTEX_ATTRIB_ARRAY_STRIDE                   = 0x8624
	VERTEX_ATTRIB_ARRAY_TYPE                     = 0x8625
	VERTEX_ATTRIB_ARRAY_NORMALIZED               = 0x886A
	VERTEX_ATTRIB_ARRAY_POINTER                  = 0x8645
	VERTEX_ATTRIB_ARRAY_BUFFER_BINDING           = 0x889F
	IMPLEMENTATION_COLOR_READ_TYPE               = 0x8B9A
	IMPLEMENTATION_COLOR_READ_FORMAT             = 0x8B9B
	COMPILE_STATUS                               = 0x8B81
	INFO_LOG_LENGTH                              = 0x8B84
	SHADER_SOURCE_LENGTH                         = 0x8B88
	SHADER_COMPILER                              = 0x8DFA
	SHADER_BINARY_FORMATS                        = 0x8DF8
	NUM_SHADER_BINARY_FORMATS                    = 0x8DF9
	LOW_FLOAT                                    = 0x8DF0
	MEDIUM_FLOAT                                 = 0x8DF1
	HIGH_FLOAT                                   = 0x8DF2
	LOW_INT                                      = 0x8DF3
	MEDIUM_INT                                   = 0x8DF4
	HIGH_INT                                     = 0x8DF5
	FRAMEBUFFER                                  = 0x8D40
	RENDERBUFFER                                 = 0x8D41
	RGBA4                                        = 0x8056
	RGB5_A1                                      = 0x8057
	RGB565                                       = 0x8D62
	DEPTH_COMPONENT16                            = 0x81A5
	STENCIL_INDEX8                               = 0x8D48
	RENDERBUFFER_WIDTH                           = 0x8D42
	RENDERBUFFER_HEIGHT                          = 0x8D43
	RENDERBUFFER_INTERNAL_FORMAT                 = 0x8D44
	RENDERBUFFER_RED_SIZE                        = 0x8D50
	RENDERBUFFER_GREEN_SIZE                      = 0x8D51
	RENDERBUFFER_BLUE_SIZE                       = 0x8D52
	RENDERBUFFER_ALPHA_SIZE                      = 0x8D53
	RENDERBUFFER_DEPTH_SIZE                      = 0x8D54
	RENDERBUFFER_STENCIL_SIZE                    = 0x8D55
	FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE           = 0x8CD0
	FRAMEBUFFER_ATTACHMENT_OBJECT_NAME           = 0x8CD1
	FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL         = 0x8CD2
	FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 0x8CD3
	COLOR_ATTACHMENT0                            = 0x8CE0
	DEPTH_ATTACHMENT                             = 0x8D00
	STENCIL_ATTACHMENT                           = 0x8D20
	FRAMEBUFFER_COMPLETE                         = 0x8CD5
	FRAMEBUFFER_INCOMPLETE_ATTACHMENT            = 0x8CD6
	FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT    = 0x8CD7
	FRAMEBUFFER_INCOMPLETE_DIMENSIONS            = 0x8CD9
	FRAMEBUFFER_UNSUPPORTED                      = 0x8CDD
	FRAMEBUFFER_BINDING                          = 0x8CA6
	RENDERBUFFER_BINDING                         = 0x8CA7
	MAX_RENDERBUFFER_SIZE                        = 0x84E8
	INVALID_FRAMEBUFFER_OPERATION                = 0x0506
)

const (
	DEPTH_BUFFER_BIT   = 0x00000100
	STENCIL_BUFFER_BIT = 0x00000400
	COLOR_BUFFER_BIT   = 0x00004000
)

const (
	FLOAT_VEC2   = 0x8B50
	FLOAT_VEC3   = 0x8B51
	FLOAT_VEC4   = 0x8B52
	INT_VEC2     = 0x8B53
	INT_VEC3     = 0x8B54
	INT_VEC4     = 0x8B55
	BOOL         = 0x8B56
	BOOL_VEC2    = 0x8B57
	BOOL_VEC3    = 0x8B58
	BOOL_VEC4    = 0x8B59
	FLOAT_MAT2   = 0x8B5A
	FLOAT_MAT3   = 0x8B5B
	FLOAT_MAT4   = 0x8B5C
	SAMPLER_2D   = 0x8B5E
	SAMPLER_CUBE = 0x8B60
)

const (
	FRAGMENT_SHADER = 0x8B30
	VERTEX_SHADER   = 0x8B31
)

const (
	FALSE    = 0
	TRUE     = 1
	ZERO     = 0
	ONE      = 1
	NO_ERROR = 0
	NONE     = 0
)

// GL ES 3.0 constants.
const (
	ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH          = 0x8A35
	ACTIVE_UNIFORM_BLOCKS                         = 0x8A36
	ALREADY_SIGNALED                              = 0x911A
	ANY_SAMPLES_PASSED                            = 0x8C2F
	ANY_SAMPLES_PASSED_CONSERVATIVE               = 0x8D6A
	BLUE                                          = 0x1905
	BUFFER_ACCESS_FLAGS                           = 0x911F
	BUFFER_MAP_LENGTH                             = 0x9120
	BUFFER_MAP_OFFSET                             = 0x9121
	BUFFER_MAPPED                                 = 0x88BC
	BUFFER_MAP_POINTER                            = 0x88BD
	COLOR                                         = 0x1800
	COLOR_ATTACHMENT10                            = 0x8CEA
	COLOR_ATTACHMENT1                             = 0x8CE1
	COLOR_ATTACHMENT11                            = 0x8CEB
	COLOR_ATTACHMENT12                            = 0x8CEC
	COLOR_ATTACHMENT13                            = 0x8CED
	COLOR_ATTACHMENT14                            = 0x8CEE
	COLOR_ATTACHMENT15                            = 0x8CEF
	COLOR_ATTACHMENT2                             = 0x8CE2
	COLOR_ATTACHMENT3                             = 0x8CE3
	COLOR_ATTACHMENT4                             = 0x8CE4
	COLOR_ATTACHMENT5                             = 0x8CE5
	COLOR_ATTACHMENT6                             = 0x8CE6
	COLOR_ATTACHMENT7                             = 0x8CE7
	COLOR_ATTACHMENT8                             = 0x8CE8
	COLOR_ATTACHMENT9                             = 0x8CE9
	COMPARE_REF_TO_TEXTURE                        = 0x884E
	COMPRESSED_R11_EAC                            = 0x9270
	COMPRESSED_RG11_EAC                           = 0x9272
	COMPRESSED_RGB8_ETC2                          = 0x9274
	COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2      = 0x9276
	COMPRESSED_RGBA8_ETC2_EAC                     = 0x9278
	COMPRESSED_SIGNED_R11_EAC                     = 0x9271
	COMPRESSED_SIGNED_RG11_EAC                    = 0x9273
	COMPRESSED_SRGB8_ALPHA8_ETC2_EAC              = 0x9279
	COMPRESSED_SRGB8_ETC2                         = 0x9275
	COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2     = 0x9277
	CONDITION_SATISFIED                           = 0x911C
	COPY_READ_BUFFER                              = 0x8F36
	COPY_READ_BUFFER_BINDING                      = 0x8F36
	COPY_WRITE_BUFFER                             = 0x8F37
	COPY_WRITE_BUFFER_BINDING                     = 0x8F37
	CURRENT_QUERY                                 = 0x8865
	DEPTH                                         = 0x1801
	DEPTH24_STENCIL8                              = 0x88F0
	DEPTH32F_STENCIL8                             = 0x8CAD
	DEPTH_COMPONENT24                             = 0x81A6
	DEPTH_COMPONENT32F                            = 0x8CAC
	DEPTH_STENCIL                                 = 0x84F9
	DEPTH_STENCIL_ATTACHMENT                      = 0x821A
	DRAW_BUFFER0                                  = 0x8825
	DRAW_BUFFER10                                 = 0x882F
	DRAW_BUFFER1                                  = 0x8826
	DRAW_BUFFER11                                 = 0x8830
	DRAW_BUFFER12                                 = 0x8831
	DRAW_BUFFER13                                 = 0x8832
	DRAW_BUFFER14                                 = 0x8833
	DRAW_BUFFER15                                 = 0x8834
	DRAW_BUFFER2                                  = 0x8827
	DRAW_BUFFER3                                  = 0x8828
	DRAW_BUFFER4                                  = 0x8829
	DRAW_BUFFER5                                  = 0x882A
	DRAW_BUFFER6                                  = 0x882B
	DRAW_BUFFER7                                  = 0x882C
	DRAW_BUFFER8                                  = 0x882D
	DRAW_BUFFER9                                  = 0x882E
	DRAW_FRAMEBUFFER                              = 0x8CA9
	DRAW_FRAMEBUFFER_BINDING                      = 0x8CA6
	DYNAMIC_COPY                                  = 0x88EA
	DYNAMIC_READ                                  = 0x88E9
	FLOAT_32_UNSIGNED_INT_24_8_REV                = 0x8DAD
	FLOAT_MAT2x3                                  = 0x8B65
	FLOAT_MAT2x4                                  = 0x8B66
	FLOAT_MAT3x2                                  = 0x8B67
	FLOAT_MAT3x4                                  = 0x8B68
	FLOAT_MAT4x2                                  = 0x8B69
	FLOAT_MAT4x3                                  = 0x8B6A
	FRAGMENT_SHADER_DERIVATIVE_HINT               = 0x8B8B
	FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE             = 0x8215
	FRAMEBUFFER_ATTACHMENT_BLUE_SIZE              = 0x8214
	FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING         = 0x8210
	FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE         = 0x8211
	FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE             = 0x8216
	FRAMEBUFFER_ATTACHMENT_GREEN_SIZE             = 0x8213
	FRAMEBUFFER_ATTACHMENT_RED_SIZE               = 0x8212
	FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE           = 0x8217
	FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER          = 0x8CD4
	FRAMEBUFFER_DEFAULT                           = 0x8218
	FRAMEBUFFER_INCOMPLETE_MULTISAMPLE            = 0x8D56
	FRAMEBUFFER_UNDEFINED                         = 0x8219
	GREEN                                         = 0x1904
	HALF_FLOAT                                    = 0x140B
	INT_2_10_10_10_REV                            = 0x8D9F
	INTERLEAVED_ATTRIBS                           = 0x8C8C
	INT_SAMPLER_2D                                = 0x8DCA
	INT_SAMPLER_2D_ARRAY                          = 0x8DCF
	INT_SAMPLER_3D                                = 0x8DCB
	INT_SAMPLER_CUBE                              = 0x8DCC
	INVALID_INDEX                                 = 0xFFFFFFFF
	MAJOR_VERSION                                 = 0x821B
	MAP_FLUSH_EXPLICIT_BIT                        = 0x0010
	MAP_INVALIDATE_BUFFER_BIT                     = 0x0008
	MAP_INVALIDATE_RANGE_BIT                      = 0x0004
	MAP_READ_BIT                                  = 0x0001
	MAP_UNSYNCHRONIZED_BIT                        = 0x0020
	MAP_WRITE_BIT                                 = 0x0002
	MAX                                           = 0x8008
	MAX_3D_TEXTURE_SIZE                           = 0x8073
	MAX_ARRAY_TEXTURE_LAYERS                      = 0x88FF
	MAX_COLOR_ATTACHMENTS                         = 0x8CDF
	MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS      = 0x8A33
	MAX_COMBINED_UNIFORM_BLOCKS                   = 0x8A2E
	MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS        = 0x8A31
	MAX_DRAW_BUFFERS                              = 0x8824
	MAX_ELEMENT_INDEX                             = 0x8D6B
	MAX_ELEMENTS_INDICES                          = 0x80E9
	MAX_ELEMENTS_VERTICES                         = 0x80E8
	MAX_FRAGMENT_INPUT_COMPONENTS                 = 0x9125
	MAX_FRAGMENT_UNIFORM_BLOCKS                   = 0x8A2D
	MAX_FRAGMENT_UNIFORM_COMPONENTS               = 0x8B49
	MAX_PROGRAM_TEXEL_OFFSET                      = 0x8905
	MAX_SAMPLES                                   = 0x8D57
	MAX_SERVER_WAIT_TIMEOUT                       = 0x9111
	MAX_TEXTURE_LOD_BIAS                          = 0x84FD
	MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS = 0x8C8A
	MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS       = 0x8C8B
	MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS    = 0x8C80
	MAX_UNIFORM_BLOCK_SIZE                        = 0x8A30
	MAX_UNIFORM_BUFFER_BINDINGS                   = 0x8A2F
	MAX_VARYING_COMPONENTS                        = 0x8B4B
	MAX_VERTEX_OUTPUT_COMPONENTS                  = 0x9122
	MAX_VERTEX_UNIFORM_BLOCKS                     = 0x8A2B
	MAX_VERTEX_UNIFORM_COMPONENTS                 = 0x8B4A
	MIN                                           = 0x8007
	MINOR_VERSION                                 = 0x821C
	MIN_PROGRAM_TEXEL_OFFSET                      = 0x8904
	NUM_EXTENSIONS                                = 0x821D
	NUM_PROGRAM_BINARY_FORMATS                    = 0x87FE
	NUM_SAMPLE_COUNTS                             = 0x9380
	OBJECT_TYPE                                   = 0x9112
	PACK_ROW_LENGTH                               = 0x0D02
	PACK_SKIP_PIXELS                              = 0x0D04
	PACK_SKIP_ROWS                                = 0x0D03
	PIXEL_PACK_BUFFER                             = 0x88EB
	PIXEL_PACK_BUFFER_BINDING                     = 0x88ED
	PIXEL_UNPACK_BUFFER                           = 0x88EC
	PIXEL_UNPACK_BUFFER_BINDING                   = 0x88EF
	PRIMITIVE_RESTART_FIXED_INDEX                 = 0x8D69
	PROGRAM_BINARY_FORMATS                        = 0x87FF
	PROGRAM_BINARY_LENGTH                         = 0x8741
	PROGRAM_BINARY_RETRIEVABLE_HINT               = 0x8257
	QUERY_RESULT                                  = 0x8866
	QUERY_RESULT_AVAILABLE                        = 0x8867
	R11F_G11F_B10F                                = 0x8C3A
	R16F                                          = 0x822D
	R16I                                          = 0x8233
	R16UI                                         = 0x8234
	R32F                                          = 0x822E
	R32I                                          = 0x8235
	R32UI                                         = 0x8236
	R8                                            = 0x8229
	R8I                                           = 0x8231
	R8_SNORM                                      = 0x8F94
	R8UI                                          = 0x8232
	RASTERIZER_DISCARD                            = 0x8C89
	READ_BUFFER                                   = 0x0C02
	READ_FRAMEBUFFER                              = 0x8CA8
	READ_FRAMEBUFFER_BINDING                      = 0x8CAA
	RED                                           = 0x1903
	RED_INTEGER                                   = 0x8D94
	RENDERBUFFER_SAMPLES                          = 0x8CAB
	RG                                            = 0x8227
	RG16F                                         = 0x822F
	RG16I                                         = 0x8239
	RG16UI                                        = 0x823A
	RG32F                                         = 0x8230
	RG32I                                         = 0x823B
	RG32UI                                        = 0x823C
	RG8                                           = 0x822B
	RG8I                                          = 0x8237
	RG8_SNORM                                     = 0x8F95
	RG8UI                                         = 0x8238
	RGB10_A2                                      = 0x8059
	RGB10_A2UI                                    = 0x906F
	RGB16F                                        = 0x881B
	RGB16I                                        = 0x8D89
	RGB16UI                                       = 0x8D77
	RGB32F                                        = 0x8815
	RGB32I                                        = 0x8D83
	RGB32UI                                       = 0x8D71
	RGB8                                          = 0x8051
	RGB8I                                         = 0x8D8F
	RGB8_SNORM                                    = 0x8F96
	RGB8UI                                        = 0x8D7D
	RGB9_E5                                       = 0x8C3D
	RGBA16F                                       = 0x881A
	RGBA16I                                       = 0x8D88
	RGBA16UI                                      = 0x8D76
	RGBA32F                                       = 0x8814
	RGBA32I                                       = 0x8D82
	RGBA32UI                                      = 0x8D70
	RGBA8                                         = 0x8058
	RGBA8I                                        = 0x8D8E
	RGBA8_SNORM                                   = 0x8F97
	RGBA8UI                                       = 0x8D7C
	RGBA_INTEGER                                  = 0x8D99
	RGB_INTEGER                                   = 0x8D98
	RG_INTEGER                                    = 0x8228
	SAMPLER_2D_ARRAY                              = 0x8DC1
	SAMPLER_2D_ARRAY_SHADOW                       = 0x8DC4
	SAMPLER_2D_SHADOW                             = 0x8B62
	SAMPLER_3D                                    = 0x8B5F
	SAMPLER_BINDING                               = 0x8919
	SAMPLER_CUBE_SHADOW                           = 0x8DC5
	SEPARATE_ATTRIBS                              = 0x8C8D
	SIGNALED                                      = 0x9119
	SIGNED_NORMALIZED                             = 0x8F9C
	SRGB                                          = 0x8C40
	SRGB8                                         = 0x8C41
	SRGB8_ALPHA8                                  = 0x8C43
	STATIC_COPY                                   = 0x88E6
	STATIC_READ                                   = 0x88E5
	STENCIL                                       = 0x1802
	STREAM_COPY                                   = 0x88E2
	STREAM_READ                                   = 0x88E1
	SYNC_CONDITION                                = 0x9113
	SYNC_FENCE                                    = 0x9116
	SYNC_FLAGS                                    = 0x9115
	SYNC_FLUSH_COMMANDS_BIT                       = 0x00000001
	SYNC_GPU_COMMANDS_COMPLETE                    = 0x9117
	SYNC_STATUS                                   = 0x9114
	TEXTURE_2D_ARRAY                              = 0x8C1A
	TEXTURE_3D                                    = 0x806F
	TEXTURE_BASE_LEVEL                            = 0x813C
	TEXTURE_BINDING_2D_ARRAY                      = 0x8C1D
	TEXTURE_BINDING_3D                            = 0x806A
	TEXTURE_COMPARE_FUNC                          = 0x884D
	TEXTURE_COMPARE_MODE                          = 0x884C
	TEXTURE_IMMUTABLE_FORMAT                      = 0x912F
	TEXTURE_IMMUTABLE_LEVELS                      = 0x82DF
	TEXTURE_MAX_LEVEL                             = 0x813D
	TEXTURE_MAX_LOD                               = 0x813B
	TEXTURE_MIN_LOD                               = 0x813A
	TEXTURE_SWIZZLE_A                             = 0x8E45
	TEXTURE_SWIZZLE_B                             = 0x8E44
	TEXTURE_SWIZZLE_G                             = 0x8E43
	TEXTURE_SWIZZLE_R                             = 0x8E42
	TEXTURE_WRAP_R                                = 0x8072
	TIMEOUT_EXPIRED                               = 0x911B
	TIMEOUT_IGNORED                               = 0xFFFFFFFFFFFFFFFF
	TRANSFORM_FEEDBACK                            = 0x8E22
	TRANSFORM_FEEDBACK_ACTIVE                     = 0x8E24
	TRANSFORM_FEEDBACK_BINDING                    = 0x8E25
	TRANSFORM_FEEDBACK_BUFFER                     = 0x8C8E
	TRANSFORM_FEEDBACK_BUFFER_BINDING             = 0x8C8F
	TRANSFORM_FEEDBACK_BUFFER_MODE                = 0x8C7F
	TRANSFORM_FEEDBACK_BUFFER_SIZE                = 0x8C85
	TRANSFORM_FEEDBACK_BUFFER_START               = 0x8C84
	TRANSFORM_FEEDBACK_PAUSED                     = 0x8E23
	TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN         = 0x8C88
	TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH         = 0x8C76
	TRANSFORM_FEEDBACK_VARYINGS                   = 0x8C83
	UNIFORM_ARRAY_STRIDE                          = 0x8A3C
	UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES          = 0x8A43
	UNIFORM_BLOCK_ACTIVE_UNIFORMS                 = 0x8A42
	UNIFORM_BLOCK_BINDING                         = 0x8A3F
	UNIFORM_BLOCK_DATA_SIZE                       = 0x8A40
	UNIFORM_BLOCK_INDEX                           = 0x8A3A
	UNIFORM_BLOCK_NAME_LENGTH                     = 0x8A41
	UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER   = 0x8A46
	UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER     = 0x8A44
	UNIFORM_BUFFER                                = 0x8A11
	UNIFORM_BUFFER_BINDING                        = 0x8A28
	UNIFORM_BUFFER_OFFSET_ALIGNMENT               = 0x8A34
	UNIFORM_BUFFER_SIZE                           = 0x8A2A
	UNIFORM_BUFFER_START                          = 0x8A29
	UNIFORM_IS_ROW_MAJOR                          = 0x8A3E
	UNIFORM_MATRIX_STRIDE                         = 0x8A3D
	UNIFORM_NAME_LENGTH                           = 0x8A39
	UNIFORM_OFFSET                                = 0x8A3B
	UNIFORM_SIZE                                  = 0x8A38
	UNIFORM_TYPE                                  = 0x8A37
	UNPACK_IMAGE_HEIGHT                           = 0x806E
	UNPACK_ROW_LENGTH                             = 0x0CF2
	UNPACK_SKIP_IMAGES                            = 0x806D
	UNPACK_SKIP_PIXELS                            = 0x0CF4
	UNPACK_SKIP_ROWS                              = 0x0CF3
	UNSIGNALED                                    = 0x9118
	UNSIGNED_INT_10F_11F_11F_REV                  = 0x8C3B
	UNSIGNED_INT_2_10_10_10_REV                   = 0x8368
	UNSIGNED_INT_24_8                             = 0x84FA
	UNSIGNED_INT_5_9_9_9_REV                      = 0x8C3E
	UNSIGNED_INT_SAMPLER_2D                       = 0x8DD2
	UNSIGNED_INT_SAMPLER_2D_ARRAY                 = 0x8DD7
	UNSIGNED_INT_SAMPLER_3D                       = 0x8DD3
	UNSIGNED_INT_SAMPLER_CUBE                     = 0x8DD4
	UNSIGNED_INT_VEC2                             = 0x8DC6
	UNSIGNED_INT_VEC3                             = 0x8DC7
	UNSIGNED_INT_VEC4                             = 0x8DC8
	UNSIGNED_NORMALIZED                           = 0x8C17
	VERTEX_ARRAY_BINDING                          = 0x85B5
	VERTEX_ATTRIB_ARRAY_DIVISOR                   = 0x88FE
	VERTEX_ATTRIB_ARRAY_INTEGER                   = 0x88FD
	WAIT_FAILED                                   = 0x911D
)

```

`hid/gl/gl_gl2.go`:

```go
// +build !android,!ios,!js,!windows,!darwin

package gl

import (
	"unsafe"

	"github.com/go-gl/gl/v2.1/gl"
)

func Init() error {
	return gl.Init()
}

func NeedVao() bool {
	return false
}

func GetError() uint32 {
	return gl.GetError()
}

func Viewport(x, y, width, height int32) {
	gl.Viewport(x, y, width, height)
}

func ClearColor(r, g, b, a float32) {
	gl.ClearColor(r, g, b, a)
}

func Clear(flags uint32) {
	gl.Clear(flags)
}

func Disable(flag uint32) {
	gl.Disable(flag)
}

func Enable(flag uint32) {
	gl.Enable(flag)
}

func Scissor(x, y, w, h int32) {
	gl.Scissor(x, y, w, h)
}

func DepthMask(flag bool) {
	gl.DepthMask(flag)
}

func ColorMask(r, g, b, a bool) {
	gl.ColorMask(r, g, b, a)
}

func BlendFunc(src, dst uint32) {
	gl.BlendFunc(src, dst)
}

func DepthFunc(fn uint32) {
	gl.DepthFunc(fn)
}

// vao

func GenVertexArrays(n int32, arrays *uint32) {
	gl.GenVertexArrays(n, arrays)
}

func BindVertexArray(array uint32) {
	gl.BindVertexArray(array)
}

func DeleteVertexArrays(n int32, array *uint32) {
	gl.DeleteVertexArrays(n, array)
}

// program & shader

func CreateProgram() uint32 {
	return gl.CreateProgram()
}

func AttachShader(program, shader uint32) {
	gl.AttachShader(program, shader)
}

func LinkProgram(program uint32) {
	gl.LinkProgram(program)
}

func UseProgram(id uint32) {
	gl.UseProgram(id)
}

func GetProgramiv(program uint32, pname uint32, params *int32) {
	gl.GetProgramiv(program, pname, params)
}

// TODO 原来的实现中 buf = loglength + 1 的，需要测试这种情况...
func GetProgramInfoLog(program uint32) string {
	var logLength int32
	GetProgramiv(program, INFO_LOG_LENGTH, &logLength)

	if logLength == 0 {
		return ""
	}
	buf := make([]uint8, logLength)
	gl.GetProgramInfoLog(program, logLength, nil, &buf[0])
	return string(buf)
}

func CreateShader(xtype uint32) uint32 {
	return gl.CreateShader(xtype)
}

func ShaderSource(shader uint32, src string) {
	cstr, free := gl.Strs(src)
	gl.ShaderSource(shader, 1, cstr, nil)
	free()
}

func CompileShader(shader uint32) {
	gl.CompileShader(shader)
}

func GetShaderiv(shader uint32, pname uint32, params *int32) {
	gl.GetShaderiv(shader, pname, params)
}

func GetShaderInfoLog(shader uint32) string {
	var logLength int32
	gl.GetShaderiv(shader, gl.INFO_LOG_LENGTH, &logLength)
	buf := make([]uint8, logLength)
	gl.GetShaderInfoLog(shader, logLength, nil, &buf[0])
	return string(buf)
}

func DeleteShader(shader uint32) {
	gl.DeleteShader(shader)
}

// buffers & draw

func GenBuffers(n int32, buffers *uint32) {
	gl.GenBuffers(n, buffers)
}

func BufferData(target uint32, size int, data unsafe.Pointer, usage uint32) {
	gl.BufferData(target, size, data, usage)
}

func BufferSubData(target uint32, offset, size int, data unsafe.Pointer) {
	gl.BufferSubData(target, offset, size, data)
}

func BindBuffer(target uint32, buffer uint32) {
	gl.BindBuffer(target, buffer)
}

func DeleteBuffers(n int32, buffers *uint32) {
	gl.DeleteBuffers(n, buffers)
}

func DrawElements(mode uint32, count int32, typ uint32, offset int) {
	gl.DrawElements(mode, count, typ, gl.PtrOffset(offset))
}

func DrawArrays(mode uint32, first, count int32) {
	gl.DrawArrays(mode, first, count)
}

// uniform

func GetUniformLocation(program uint32, name string) int32 {
	return gl.GetUniformLocation(program, gl.Str(name))
}

func Uniform1i(loc, v int32) {
	gl.Uniform1i(loc, v)
}

func Uniform1iv(loc, num int32, v *int32) {
	gl.Uniform1iv(loc, num, v)
}

func Uniform1f(location int32, v0 float32) {
	gl.Uniform1f(location, v0)
}

func Uniform2f(location int32, v0, v1 float32) {
	gl.Uniform2f(location, v0, v1)
}

func Uniform3f(location int32, v0, v1, v2 float32) {
	gl.Uniform3f(location, v0, v1, v2)
}

func Uniform4f(location int32, v0, v1, v2, v3 float32) {
	gl.Uniform4f(location, v0, v1, v2, v3)
}

func Uniform1fv(loc, num int32, v *float32) {
	gl.Uniform1fv(loc, num, v)
}

func Uniform4fv(loc, num int32, v *float32) {
	gl.Uniform4fv(loc, num, v)
}

func UniformMatrix3fv(loc, num int32, t bool, v *float32) {
	gl.UniformMatrix3fv(loc, num, t, v)
}

func UniformMatrix4fv(loc, num int32, t bool, v *float32) {
	gl.UniformMatrix4fv(loc, num, t, v)
}

// attribute

func EnableVertexAttribArray(index uint32) {
	gl.EnableVertexAttribArray(index)
}

func VertexAttribPointer(index uint32, size int32, xtype uint32, normalized bool, stride int32, offset int) {
	gl.VertexAttribPointer(index, size, xtype, normalized, stride, gl.PtrOffset(offset))
}

func DisableVertexAttribArray(index uint32) {
	gl.DisableVertexAttribArray(index)
}

func GetAttribLocation(program uint32, name string) int32 {
	return gl.GetAttribLocation(program, gl.Str(name))
}

// texture

func ActiveTexture(texture uint32) {
	gl.ActiveTexture(texture)
}

func BindTexture(target uint32, texture uint32) {
	gl.BindTexture(target, texture)
}

func TexSubImage2D(target uint32, level int32, xOffset, yOffset, width, height int32, format, xtype uint32, pixels unsafe.Pointer) {
	gl.TexSubImage2D(target, level, xOffset, yOffset, width, height, format, xtype, pixels)
}

func TexImage2D(target uint32, level int32, internalFormat int32, width, height, border int32, format, xtype uint32, pixels unsafe.Pointer) {
	gl.TexImage2D(target, level, internalFormat, width, height, border, format, xtype, pixels)
}

func DeleteTextures(n int32, textures *uint32) {
	gl.DeleteTextures(n, textures)
}

func GenTextures(n int32, textures *uint32) {
	gl.GenTextures(n, textures)
}

func TexParameteri(texture uint32, pname uint32, params int32) {
	gl.TexParameteri(texture, pname, params)
}

```

`hid/gl/gl_gl3.go`:

```go
// +build darwin windows
// +build !android,!ios,!js

package gl

import (
	"unsafe"

	"github.com/go-gl/gl/v3.2-core/gl"
)

func Init() error {
	return gl.Init()
}

func NeedVao() bool {
	return true
}

func GetError() uint32 {
	return gl.GetError()
}

func Viewport(x, y, width, height int32) {
	gl.Viewport(x, y, width, height)
}

func ClearColor(r, g, b, a float32) {
	gl.ClearColor(r, g, b, a)
}

func Clear(flags uint32) {
	gl.Clear(flags)
}

func Disable(flag uint32) {
	gl.Disable(flag)
}

func Enable(flag uint32) {
	gl.Enable(flag)
}

func Scissor(x, y, w, h int32) {
	gl.Scissor(x, y, w, h)
}

func DepthMask(flag bool) {
	gl.DepthMask(flag)
}

func ColorMask(r, g, b, a bool) {
	gl.ColorMask(r, g, b, a)
}

func BlendFunc(src, dst uint32) {
	gl.BlendFunc(src, dst)
}

func DepthFunc(fn uint32) {
	gl.DepthFunc(fn)
}

// vao

func GenVertexArrays(n int32, arrays *uint32) {
	gl.GenVertexArrays(n, arrays)
}

func BindVertexArray(array uint32) {
	gl.BindVertexArray(array)
}

func DeleteVertexArrays(n int32, array *uint32) {
	gl.DeleteVertexArrays(n, array)
}

// program & shader

func CreateProgram() uint32 {
	return gl.CreateProgram()
}

func AttachShader(program, shader uint32) {
	gl.AttachShader(program, shader)
}

func LinkProgram(program uint32) {
	gl.LinkProgram(program)
}

func UseProgram(id uint32) {
	gl.UseProgram(id)
}

func GetProgramiv(program uint32, pname uint32, params *int32) {
	gl.GetProgramiv(program, pname, params)
}

// TODO 原来的实现中 buf = loglength + 1 的，需要测试这种情况...
func GetProgramInfoLog(program uint32) string {
	var logLength int32
	GetProgramiv(program, INFO_LOG_LENGTH, &logLength)

	if logLength == 0 {
		return ""
	}
	buf := make([]uint8, logLength)
	gl.GetProgramInfoLog(program, logLength, nil, &buf[0])
	return string(buf)
}

func CreateShader(xtype uint32) uint32 {
	return gl.CreateShader(xtype)
}

func ShaderSource(shader uint32, src string) {
	cstr, free := gl.Strs(src)
	gl.ShaderSource(shader, 1, cstr, nil)
	free()
}

func CompileShader(shader uint32) {
	gl.CompileShader(shader)
}

func GetShaderiv(shader uint32, pname uint32, params *int32) {
	gl.GetShaderiv(shader, pname, params)
}

func GetShaderInfoLog(shader uint32) string {
	var logLength int32
	gl.GetShaderiv(shader, gl.INFO_LOG_LENGTH, &logLength)
	buf := make([]uint8, logLength)
	gl.GetShaderInfoLog(shader, logLength, nil, &buf[0])
	return string(buf)
}

func DeleteShader(shader uint32) {
	gl.DeleteShader(shader)
}

// buffers & draw

func GenBuffers(n int32, buffers *uint32) {
	gl.GenBuffers(n, buffers)
}

func BufferData(target uint32, size int, data unsafe.Pointer, usage uint32) {
	gl.BufferData(target, size, data, usage)
}

func BufferSubData(target uint32, offset, size int, data unsafe.Pointer) {
	gl.BufferSubData(target, offset, size, data)
}

func BindBuffer(target uint32, buffer uint32) {
	gl.BindBuffer(target, buffer)
}

func DeleteBuffers(n int32, buffers *uint32) {
	gl.DeleteBuffers(n, buffers)
}

func DrawElements(mode uint32, count int32, typ uint32, offset int) {
	gl.DrawElements(mode, count, typ, gl.PtrOffset(offset))
}

func DrawArrays(mode uint32, first, count int32) {
	gl.DrawArrays(mode, first, count)
}

// uniform

func GetUniformLocation(program uint32, name string) int32 {
	return gl.GetUniformLocation(program, gl.Str(name))
}

func Uniform1i(loc, v int32) {
	gl.Uniform1i(loc, v)
}

func Uniform1iv(loc, num int32, v *int32) {
	gl.Uniform1iv(loc, num, v)
}

func Uniform1f(location int32, v0 float32) {
	gl.Uniform1f(location, v0)
}

func Uniform2f(location int32, v0, v1 float32) {
	gl.Uniform2f(location, v0, v1)
}

func Uniform3f(location int32, v0, v1, v2 float32) {
	gl.Uniform3f(location, v0, v1, v2)
}

func Uniform4f(location int32, v0, v1, v2, v3 float32) {
	gl.Uniform4f(location, v0, v1, v2, v3)
}

func Uniform1fv(loc, num int32, v *float32) {
	gl.Uniform1fv(loc, num, v)
}

func Uniform4fv(loc, num int32, v *float32) {
	gl.Uniform4fv(loc, num, v)
}

func UniformMatrix3fv(loc, num int32, t bool, v *float32) {
	gl.UniformMatrix3fv(loc, num, t, v)
}

func UniformMatrix4fv(loc, num int32, t bool, v *float32) {
	gl.UniformMatrix4fv(loc, num, t, v)
}

// attribute

func EnableVertexAttribArray(index uint32) {
	gl.EnableVertexAttribArray(index)
}

func VertexAttribPointer(index uint32, size int32, xtype uint32, normalized bool, stride int32, offset int) {
	gl.VertexAttribPointer(index, size, xtype, normalized, stride, gl.PtrOffset(offset))
}

func DisableVertexAttribArray(index uint32) {
	gl.DisableVertexAttribArray(index)
}

func GetAttribLocation(program uint32, name string) int32 {
	return gl.GetAttribLocation(program, gl.Str(name))
}

func BindFragDataLocation(program uint32, color uint32, name string) {
	gl.BindFragDataLocation(program, color, gl.Str(name))
}

// texture

func ActiveTexture(texture uint32) {
	gl.ActiveTexture(texture)
}

func BindTexture(target uint32, texture uint32) {
	gl.BindTexture(target, texture)
}

func TexSubImage2D(target uint32, level int32, xOffset, yOffset, width, height int32, format, xtype uint32, pixels unsafe.Pointer) {
	gl.TexSubImage2D(target, level, xOffset, yOffset, width, height, format, xtype, pixels)
}

func TexImage2D(target uint32, level int32, internalFormat int32, width, height, border int32, format, xtype uint32, pixels unsafe.Pointer) {
	gl.TexImage2D(target, level, internalFormat, width, height, border, format, xtype, pixels)
}

func DeleteTextures(n int32, textures *uint32) {
	gl.DeleteTextures(n, textures)
}

func GenTextures(n int32, textures *uint32) {
	gl.GenTextures(n, textures)
}

func TexParameteri(texture uint32, pname uint32, params int32) {
	gl.TexParameteri(texture, pname, params)
}

```

`hid/gl/gl_mobile.go`:

```go
// +build !js
// +build android ios

package gl

import (
	"unsafe"

	"golang.org/x/mobile/gl"

	//"log"
	"runtime"
)

var glc gl.Context

func NeedVao() bool {
	return false
}

func InitContext(drawContext interface{}) {
	glc = drawContext.(gl.Context)
}

func Release() {
	glc = nil
	runtime.GC()
}

func GetError() uint32 {
	return uint32(glc.GetError())
}

func Viewport(x, y, width, height int32) {
	glc.Viewport(int(x), int(y), int(width), int(height))
}

func ClearColor(r, g, b, a float32) {
	glc.ClearColor(r, g, b, a)
}

func Clear(flags uint32) {
	glc.Clear(gl.Enum(flags))
}

func Disable(flag uint32) {
	glc.Disable(gl.Enum(flag))
}

func Enable(flag uint32) {
	glc.Enable(gl.Enum(flag))
}

func Scissor(x, y, w, h int32) {
	glc.Scissor(x, y, w, h)
}

func DepthMask(flag bool) {
	glc.DepthMask(flag)
}

func ColorMask(r, g, b, a bool) {
	glc.ColorMask(r, g, b, a)
}

func BlendFunc(src, dst uint32) {
	glc.BlendFunc(gl.Enum(src), gl.Enum(dst))
}

func DepthFunc(fn uint32) {
	glc.DepthFunc(gl.Enum(fn))
}

// vao

func GenVertexArrays(n int32, arrays *uint32) {
	va := glc.CreateVertexArray()
	*arrays = va.Value
}

func BindVertexArray(array uint32) {
	glc.BindVertexArray(gl.VertexArray{array})
}

func DeleteVertexArrays(n int32, array *uint32) {
	glc.DeleteVertexArray(gl.VertexArray{*array})
}

// program & shader

func CreateProgram() uint32 {
	return glc.CreateProgram().Value
}

func AttachShader(program, shader uint32) {
	glc.AttachShader(gl.Program{true, program}, gl.Shader{shader})
}

func LinkProgram(program uint32) {
	glc.LinkProgram(gl.Program{true, program})
}

func UseProgram(id uint32) {
	glc.UseProgram(gl.Program{true, id})
}

func GetProgramiv(program uint32, pname uint32, params *int32) {
	v := glc.GetProgrami(gl.Program{true, program}, gl.Enum(pname))
	*params = int32(v)
}

func GetProgramInfoLog(program uint32) string {
	return glc.GetProgramInfoLog(gl.Program{true, program})
}

func CreateShader(xtype uint32) uint32 {
	return glc.CreateShader(gl.Enum(xtype)).Value
}

func ShaderSource(shader uint32, src string) {
	glc.ShaderSource(gl.Shader{shader}, src)
}

func CompileShader(shader uint32) {
	glc.CompileShader(gl.Shader{shader})
}

func GetShaderiv(shader uint32, pname uint32, params *int32) {
	v := glc.GetShaderi(gl.Shader{shader}, gl.Enum(pname))
	*params = int32(v)
}

func GetShaderInfoLog(shader uint32) string {
	return glc.GetShaderInfoLog(gl.Shader{shader})
}

func DeleteShader(shader uint32) {
	glc.DeleteShader(gl.Shader{shader})
}

// buffers & draw

func GenBuffers(n int32, buffers *uint32) {
	buffer := glc.CreateBuffer()
	*buffers = buffer.Value
}

func BufferData(target uint32, size int, data unsafe.Pointer, usage uint32) {
	if data == nil {
		glc.BufferInit(gl.Enum(target), size, gl.Enum(usage))
	} else {
		d := ((*[1 << 24]byte)(data))[:size]
		glc.BufferData(gl.Enum(target), d, gl.Enum(usage))
		//log.Println("update buffer:", target, " data:", (*[20]float32)(data))
	}
}

func BufferSubData(target uint32, offset, size int, data unsafe.Pointer) {
	glc.BufferSubData(gl.Enum(target), offset, ((*[1 << 24]byte)(data))[:size])
}

func BindBuffer(target uint32, buffer uint32) {
	glc.BindBuffer(gl.Enum(target), gl.Buffer{buffer})
}

func DeleteBuffers(n int32, buffers *uint32) {
	glc.DeleteBuffer(gl.Buffer{*buffers})
}

func DrawElements(mode uint32, count int32, typ uint32, offset int) {
	glc.DrawElements(gl.Enum(mode), int(count), gl.Enum(typ), offset)
}

func DrawArrays(mode uint32, first, count int32) {
	glc.DrawArrays(gl.Enum(mode), int(first), int(count))
}

// uniform

func GetUniformLocation(program uint32, name string) int32 {
	u := glc.GetUniformLocation(gl.Program{true, program}, name)
	return u.Value
}

func Uniform1i(loc, v int32) {
	glc.Uniform1i(gl.Uniform{loc}, int(v))
}

func Uniform1iv(loc, num int32, v *int32) {
	glc.Uniform1iv(gl.Uniform{loc}, ((*[1 << 24]int32)(unsafe.Pointer(v)))[:num])
}

func Uniform1f(location int32, v0 float32) {
	glc.Uniform1f(gl.Uniform{location}, v0)
}

func Uniform2f(location int32, v0, v1 float32) {
	glc.Uniform2f(gl.Uniform{location}, v0, v1)
}

func Uniform3f(location int32, v0, v1, v2 float32) {
	glc.Uniform3f(gl.Uniform{location}, v0, v1, v2)
}

func Uniform4f(location int32, v0, v1, v2, v3 float32) {
	glc.Uniform4f(gl.Uniform{location}, v0, v1, v2, v3)
}

func Uniform1fv(loc, num int32, v *float32) {
	glc.Uniform1fv(gl.Uniform{loc}, ((*[1 << 24]float32)(unsafe.Pointer(v)))[:num])
}

func Uniform4fv(loc, num int32, v *float32) {
	glc.Uniform4fv(gl.Uniform{loc}, ((*[1 << 24]float32)(unsafe.Pointer(v)))[:num*4])
}

func UniformMatrix3fv(loc, num int32, t bool, v *float32) {
	glc.UniformMatrix3fv(gl.Uniform{loc}, ((*[1 << 24]float32)(unsafe.Pointer(v)))[:num*9])
}

func UniformMatrix4fv(loc, num int32, t bool, v *float32) {
	glc.UniformMatrix4fv(gl.Uniform{loc}, ((*[1 << 24]float32)(unsafe.Pointer(v)))[:num*16])
}

// attribute

func EnableVertexAttribArray(index uint32) {
	glc.EnableVertexAttribArray(gl.Attrib{uint(index)})
}

func VertexAttribPointer(index uint32, size int32, xtype uint32, normalized bool, stride int32, offset int) {
	glc.VertexAttribPointer(gl.Attrib{uint(index)}, int(size), gl.Enum(xtype), normalized, int(stride), offset)
}

func DisableVertexAttribArray(index uint32) {
	glc.DisableVertexAttribArray(gl.Attrib{uint(index)})
}

func GetAttribLocation(program uint32, name string) uint32 {
	return uint32(glc.GetAttribLocation(gl.Program{true, program}, name).Value)
}

// texture

func ActiveTexture(texture uint32) {
	glc.ActiveTexture(gl.Enum(texture))
}

func BindTexture(target uint32, texture uint32) {
	glc.BindTexture(gl.Enum(target), gl.Texture{texture})
}

func TexSubImage2D(target uint32, level int32, xOffset, yOffset, width, height int32, format, xtype uint32, pixels unsafe.Pointer) {
	glc.TexSubImage2D(gl.Enum(target), int(level), int(xOffset), int(xOffset), int(width), int(height), gl.Enum(format), gl.Enum(xtype), ((*[1 << 24]byte)(pixels))[:])
}

func TexImage2D(target uint32, level int32, internalFormat int32, width, height, border int32, format, xtype uint32, pixels unsafe.Pointer) {
	glc.TexImage2D(gl.Enum(target), int(level), int(width), int(height), gl.Enum(format), gl.Enum(xtype), ((*[1 << 24]byte)(pixels))[:])
}

func DeleteTextures(n int32, textures *uint32) {
	glc.DeleteTexture(gl.Texture{*textures})
}

func GenTextures(n int32, textures *uint32) {
	tex := glc.CreateTexture()
	*textures = tex.Value
}

func TexParameteri(texture uint32, pname uint32, params int32) {
	glc.TexParameteri(gl.Enum(texture), gl.Enum(pname), int(params))
}

```

`hid/gl/gl_webgl.go`:

```go
// +build js

package gl

import (
	"unsafe"

	"syscall/js"

	"korok.io/korok/webav"
)

var (
	gl            *webav.Context
	programMap    = make(map[uint32]js.Value)
	programCount  uint32
	shaderMap     = make(map[uint32]js.Value)
	shaderCount   uint32
	bufferMap     = make(map[uint32]js.Value)
	bufferCount   uint32
	locationMap   = make(map[int32]js.Value)
	locationCount int32
	textureMap    = make(map[uint32]js.Value)
	textureCount  uint32
)

type Slice struct {
	Addr uintptr
	Len  int
	Cap  int
}

func cstr2str(x string) string {
	return x[0 : len(x)-1]
}

func bytes2uint8s(x []byte) []uint8 {
	s := make([]uint8, len(x))
	for i, v := range x {
		s[i] = uint8(v)
	}
	return s
}

func Init(canvas js.Value) error {
	attrs := webav.DefaultAttributes()
	attrs.Alpha = false

	var err error
	gl, err = webav.NewContext(canvas, attrs)

	return err
}

func NeedVao() bool {
	// webgl 2.0才支持
	return false
}

func GetError() uint32 {
	return uint32(gl.GetError())
}

func Viewport(x, y, width, height int32) {
	gl.Viewport(int(x), int(y), int(width), int(height))
}

func ClearColor(r, g, b, a float32) {
	gl.ClearColor(r, g, b, a)
}

func Clear(flags uint32) {
	gl.Clear(int(flags))
}

func Disable(flag uint32) {
	gl.Disable(int(flag))
}

func Enable(flag uint32) {
	gl.Enable(int(flag))
}

func Scissor(x, y, w, h int32) {
	gl.Scissor(int(x), int(y), int(w), int(h))
}

func DepthMask(flag bool) {
	gl.DepthMask(flag)
}

func ColorMask(r, g, b, a bool) {
	gl.ColorMask(r, g, b, a)
}

func BlendFunc(src, dst uint32) {
	gl.BlendFunc(int(src), int(dst))
}

func DepthFunc(fn uint32) {
	gl.DepthFunc(int(fn))
}

// vao webgl 2.0才支持

func GenVertexArrays(n int32, arrays *uint32) {
}

func BindVertexArray(array uint32) {
}

func DeleteVertexArrays(n int32, array *uint32) {
}

// program & shader

func CreateProgram() uint32 {
	x := gl.CreateProgram()
	if x == js.Null() {
		return 0
	}
	programCount++
	programMap[programCount] = x
	return programCount
}

func AttachShader(program, shader uint32) {
	gl.AttachShader(programMap[program], shaderMap[shader])
}

func LinkProgram(program uint32) {
	gl.LinkProgram(programMap[program])
}

func UseProgram(id uint32) {
	gl.UseProgram(programMap[id])
}

// TODO 目前只支持bool的获取
func GetProgramiv(program uint32, pname uint32, params *int32) {
	*params = 0
	if gl.GetProgramParameterb(programMap[program], int(pname)) {
		*params = 1
	}
}

// TODO 原来的实现中 buf = loglength + 1 的，需要测试这种情况...
func GetProgramInfoLog(program uint32) string {
	// var logLength int32
	// GetProgramiv(program, INFO_LOG_LENGTH, &logLength)

	// if logLength == 0 {
	// 	return ""
	// }

	return gl.GetProgramInfoLog(programMap[program])
}

func CreateShader(xtype uint32) uint32 {
	x := gl.CreateShader(int(xtype))
	if x == js.Null() {
		return 0
	}
	shaderCount++
	shaderMap[shaderCount] = x
	return shaderCount
}

func ShaderSource(shader uint32, src string) {
	// cstr, free := gl.Strs(src)
	cstr := cstr2str(src)
	gl.ShaderSource(shaderMap[shader], cstr)
	// free()
}

func CompileShader(shader uint32) {
	gl.CompileShader(shaderMap[shader])
}

// TODO 目前只支持bool的获取
func GetShaderiv(shader uint32, pname uint32, params *int32) {
	*params = 0
	if gl.GetShaderParameter(shaderMap[shader], int(pname)).Bool() {
		*params = 1
	}
}

func GetShaderInfoLog(shader uint32) string {
	// var logLength int32
	// GetShaderiv(shader, uint32(gl.INFO_LOG_LENGTH), &logLength)
	// if logLength == 0 {
	// 	return ""
	// }
	return gl.GetShaderInfoLog(shaderMap[shader])
}

func DeleteShader(shader uint32) {
	gl.DeleteShader(shaderMap[shader])
	delete(shaderMap, shader)
}

// buffers & draw

func GenBuffers(n int32, buffers *uint32) {
	x := gl.CreateBuffer()
	if x == js.Null() {
		*buffers = 0
		return
	}
	bufferCount++
	bufferMap[bufferCount] = x
	*buffers = bufferCount
}

func BufferData(target uint32, size int, data unsafe.Pointer, usage uint32) {
	if nil == data {
		gl.BufferData(int(target), size, int(usage))
		return
	}
	sl := &Slice{Addr: uintptr(data), Len: size, Cap: size}
	b := *(*[]uint8)(unsafe.Pointer(sl))

	ta := js.TypedArrayOf(b)
	gl.BufferData(int(target), ta, int(usage))
	ta.Release()
}

func BufferSubData(target uint32, offset, size int, data unsafe.Pointer) {
	sl := &Slice{Addr: uintptr(data), Len: size, Cap: size}
	b := *(*[]uint8)(unsafe.Pointer(sl))

	ta := js.TypedArrayOf(b)
	gl.BufferSubData(int(target), int(offset), ta)
	ta.Release()
}

func BindBuffer(target uint32, buffer uint32) {
	gl.BindBuffer(int(target), bufferMap[buffer])
}

func DeleteBuffers(n int32, buffers *uint32) {
	gl.DeleteBuffer(bufferMap[*buffers])
	delete(bufferMap, *buffers)
}

func DrawElements(mode uint32, count int32, typ uint32, offset int) {
	gl.DrawElements(int(mode), int(count), int(typ), int(offset))
}

func DrawArrays(mode uint32, first, count int32) {
	gl.DrawArrays(int(mode), int(first), int(count))
}

// uniform

func GetUniformLocation(program uint32, name string) int32 {
	x := gl.GetUniformLocation(programMap[program], cstr2str(name))
	if x == js.Null() {
		return 0
	}
	locationCount++
	locationMap[locationCount] = x
	return locationCount
}

func Uniform1i(loc, v int32) {
	gl.Uniform1i(locationMap[loc], int(v))
}

func Uniform1iv(loc, num int32, v *int32) {
	sl := &Slice{Addr: uintptr(unsafe.Pointer(v)), Len: int(num), Cap: int(num)}
	b := *(*[]int32)(unsafe.Pointer(sl))

	ta := js.TypedArrayOf(b)
	gl.Uniform1iv(locationMap[loc], ta)
	ta.Release()
}

func Uniform1f(location int32, v0 float32) {
	gl.Uniform1f(locationMap[location], v0)
}

func Uniform2f(location int32, v0, v1 float32) {
	gl.Uniform2f(locationMap[location], v0, v1)
}

func Uniform3f(location int32, v0, v1, v2 float32) {
	gl.Uniform3f(locationMap[location], v0, v1, v2)
}

func Uniform4f(location int32, v0, v1, v2, v3 float32) {
	gl.Uniform4f(locationMap[location], v0, v1, v2, v3)
}

func Uniform1fv(loc, num int32, v *float32) {
	sl := &Slice{Addr: uintptr(unsafe.Pointer(v)), Len: int(num), Cap: int(num)}
	b := *(*[]float32)(unsafe.Pointer(sl))

	ta := js.TypedArrayOf(b)
	gl.Uniform1fv(locationMap[loc], ta)
	ta.Release()
}

func Uniform4fv(loc, num int32, v *float32) {
	sl := &Slice{Addr: uintptr(unsafe.Pointer(v)), Len: int(num * 4), Cap: int(num * 4)}
	b := *(*[]float32)(unsafe.Pointer(sl))

	ta := js.TypedArrayOf(b)
	gl.Uniform4fv(locationMap[loc], ta)
	ta.Release()
}

func UniformMatrix3fv(loc, num int32, t bool, v *float32) {
	sl := &Slice{Addr: uintptr(unsafe.Pointer(v)), Len: int(num * 9), Cap: int(num * 9)}
	b := *(*[]float32)(unsafe.Pointer(sl))

	ta := js.TypedArrayOf(b)
	gl.UniformMatrix3fv(locationMap[loc], t, ta)
	ta.Release()
}

func UniformMatrix4fv(loc, num int32, t bool, v *float32) {
	sl := &Slice{Addr: uintptr(unsafe.Pointer(v)), Len: int(num * 16), Cap: int(num * 16)}
	b := *(*[]float32)(unsafe.Pointer(sl))

	ta := js.TypedArrayOf(b)
	gl.UniformMatrix4fv(locationMap[loc], t, ta)
	ta.Release()
}

// attribute

func EnableVertexAttribArray(index uint32) {
	gl.EnableVertexAttribArray(int(index))
}

func VertexAttribPointer(index uint32, size int32, xtype uint32, normalized bool, stride int32, offset int) {
	gl.VertexAttribPointer(int(index), int(size), int(xtype), normalized, int(stride), offset)
}

func DisableVertexAttribArray(index uint32) {
	gl.DisableVertexAttribArray(int(index))
}

func GetAttribLocation(program uint32, name string) int32 {
	return int32(gl.GetAttribLocation(programMap[program], cstr2str(name)))
}

// texture

func ActiveTexture(texture uint32) {
	gl.ActiveTexture(int(texture))
}

func BindTexture(target uint32, texture uint32) {
	gl.BindTexture(int(target), textureMap[texture])
}

// 目前支持Type:UNSIGNED_BYTE, Format:RGBA,RGB,LUMINANCE_ALPHA,LUMINANCE,ALPHA
func TexSubImage2D(target uint32, level int32, xOffset, yOffset, width, height int32, format, xtype uint32, pixels unsafe.Pointer) {
	var sizePerpix int32
	switch format {
	case RGBA:
		sizePerpix = 4
	case RGB:
		sizePerpix = 3
	case LUMINANCE_ALPHA:
		sizePerpix = 2
	case LUMINANCE:
		sizePerpix = 1
	case ALPHA:
		sizePerpix = 1
	}
	sl := &Slice{Addr: uintptr(pixels), Len: int(sizePerpix * width * height), Cap: int(sizePerpix * width * height)}
	b := *(*[]uint8)(unsafe.Pointer(sl))

	ta := js.TypedArrayOf(b)
	gl.TexSubImage2D(int(target), int(level), int(xOffset), int(yOffset), int(format), int(xtype), ta)
	ta.Release()
}

func TexImage2D(target uint32, level int32, internalFormat int32, width, height, border int32, format, xtype uint32, pixels unsafe.Pointer) {
	// b := ((*[1 << 24]byte)(pixels))[:]
	// bytes2uint8s(b)
	var sizePerpix int32
	switch format {
	case RGBA:
		sizePerpix = 4
	case RGB:
		sizePerpix = 3
	case LUMINANCE_ALPHA:
		sizePerpix = 2
	case LUMINANCE:
		sizePerpix = 1
	case ALPHA:
		sizePerpix = 1
	}
	sl := &Slice{Addr: uintptr(pixels), Len: int(sizePerpix * width * height), Cap: int(sizePerpix * width * height)}
	b := *(*[]uint8)(unsafe.Pointer(sl))

	ta := js.TypedArrayOf(b)
	gl.TexImage2D(int(target), int(level), int(internalFormat), int(width), int(height), int(border), int(format), int(xtype), ta)
	ta.Release()
}

func DeleteTextures(n int32, textures *uint32) {
	gl.DeleteTexture(textureMap[*textures])
	delete(textureMap, *textures)
}

func GenTextures(n int32, textures *uint32) {
	x := gl.CreateTexture()
	if x == js.Null() {
		*textures = 0
		return
	}
	textureCount++
	textureMap[textureCount] = x
	*textures = textureCount
}

func TexParameteri(texture uint32, pname uint32, params int32) {
	gl.TexParameteri(int(texture), int(pname), int(params))
}

```

`hid/hid_android.go`:

```go
// +build android

package hid

/*
#cgo LDFLAGS: -landroid

#include <jni.h>
#include <stdlib.h>
#include <string.h>

// Equivalent to:
// String lan = Locale.getDefault().getLanguage();
char* kk_getLanguage(uintptr_t java_vm, uintptr_t jni_env, jobject ctx) {
	JavaVM* vm = (JavaVM*)java_vm;
	JNIEnv* env = (JNIEnv*)jni_env;

	jclass locale_clazz = (*env)->FindClass(env, "java/util/Locale");
	jmethodID getdft_id = (*env)->GetStaticMethodID(env, locale_clazz, "getDefault", "()Ljava/util/Locale;");
	jobject locale = (*env)->CallStaticObjectMethod(env, locale_clazz, getdft_id);

	jmethodID getlang_id = (*env)->GetMethodID(env, locale_clazz, "getLanguage", "()Ljava/lang/String;");
	jobject lang = (*env)->CallObjectMethod(env, locale, getlang_id);
	const char* str = (*env)->GetStringUTFChars(env, (jstring) lang, NULL);
	char * retString = strdup(str);
	(*env)->ReleaseStringUTFChars(env, (jstring)lang, str);
	return retString;
}

// Equivalent to:
// Activity.Finish()
void kk_finish(uintptr_t java_vm, uintptr_t jni_env, jobject ctx) {
	JavaVM* vm = (JavaVM*)java_vm;
	JNIEnv* env = (JNIEnv*)jni_env;
	jclass clazz = (*env)->GetObjectClass(env, ctx);
	jmethodID finish_id = (*env)->GetMethodID(env, clazz, "finish", "()V");
	(*env)->CallVoidMethod(env, ctx, finish_id);
}
 */
import "C"
import (
	"golang.org/x/mobile/app"
	"os"
	"unsafe"

)

func FileDir() string {
	return deviceAttr.File(func() string {
		return os.Getenv("TMPDIR")
	})
}

func Language() string {
	return deviceAttr.Lang(func() string {
		var ret string
		app.RunOnJVM(func(vm, jniEnv, ctx uintptr) error {
			cstring := C.kk_getLanguage(C.uintptr_t(vm), C.uintptr_t(jniEnv), C.jobject(ctx))
			ret = C.GoString(cstring)
			C.free(unsafe.Pointer(cstring))
			return nil
		})
		return ret
	})
}

func Quit() {
	app.RunOnJVM(func(vm, jniEnv, ctx uintptr) error {
		C.kk_finish(C.uintptr_t(vm), C.uintptr_t(jniEnv), C.jobject(ctx))
		return nil
	})
}
```

`hid/hid_attr.go`:

```go
package hid

type AttrTable struct {
	file string
	lang string
}

func (at *AttrTable) File(init func() string) string {
	if at.file == "" {
		at.file = init()
	}
	return at.file
}

func (at *AttrTable) Lang(init func() string) string {
	if at.lang == "" {
		at.lang = init()
	}
	return at.lang
}

var deviceAttr AttrTable

```

`hid/hid_darwin.go`:

```go
// +build darwin,!ios

package hid

/*
#cgo CFLAGS: -x objective-c
#cgo LDFLAGS: -framework Cocoa
#import <Cocoa/Cocoa.h>

#include <stdlib.h>
#include <string.h>

char* kk_getLanguage() {
	// get the current language and country config
	NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
    NSArray *languages = [defaults objectForKey:@"AppleLanguages"];
    NSString *currentLanguage = [languages objectAtIndex:0];

    // get the current language code.(such as English is "en", Chinese is "zh" and so on)
    NSDictionary* temp = [NSLocale componentsFromLocaleIdentifier:currentLanguage];
    NSString * languageCode = [temp objectForKey:NSLocaleLanguageCode];

    //get uft8 string and copy it
	const char* str = [languageCode UTF8String];
	char * retString = strdup(str);
	return retString;
}

*/
import "C"
import (
	"os"
	"unsafe"
)

func FileDir() string {
	return deviceAttr.File(func() string {
		return os.Getenv("HOME") + "/Library/Application Support"
	})
}

func Language() string {
	return deviceAttr.Lang(func() string {
		var ret string
		cstring := C.kk_getLanguage()
		ret = C.GoString(cstring)
		C.free(unsafe.Pointer(cstring))
		return ret
	})
}

```

`hid/hid_ios.go`:

```go
// +build ios

package hid

/*
#cgo CFLAGS: -x objective-c
#cgo LDFLAGS: -framework Foundation -framework UIKit
#import <UIKit/UIKit.h>

#include <stdlib.h>
#include <string.h>

char* kk_getLanguage() {
	// get the current language and country config
	NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
    NSArray *languages = [defaults objectForKey:@"AppleLanguages"];
    NSString *currentLanguage = [languages objectAtIndex:0];

    // get the current language code.(such as English is "en", Chinese is "zh" and so on)
    NSDictionary* temp = [NSLocale componentsFromLocaleIdentifier:currentLanguage];
    NSString * languageCode = [temp objectForKey:NSLocaleLanguageCode];

    //get uft8 string and copy it
	const char* str = [languageCode UTF8String];
	char * retString = strdup(str);
	return retString;
}

char* kk_getFileDir() {
	NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
    NSString *documentsDirectory = [paths objectAtIndex:0];

    // get utf8 string and copy it
    const char* str = [documentsDirectory UTF8String];
    char* retString = strdup(str);
    return retString;
}
 */
import "C"
import (
	"unsafe"
)

func FileDir() string {
	return deviceAttr.File(func() string {
		var ret string
		cstring := C.kk_getFileDir()
		ret = C.GoString(cstring)
		C.free(unsafe.Pointer(cstring))
		return ret
	})
}

func Language() string {
	return deviceAttr.Lang(func() string {
		var ret string
		cstring := C.kk_getLanguage()
		ret = C.GoString(cstring)
		C.free(unsafe.Pointer(cstring))
		return ret
	})
}

func Quit() {
	// TODO
}
```

`hid/hid_webgl.go`:

```go
// +build js

package hid

func FileDir() string {
	return ""
}

func Language() string {
	return ""
}

func Quit() {
}
```

`hid/input/button.go`:

```go
package input


// JustPressed/JustReleased 表示按键事件
// IsDown 表示按键状态
//
// 0x0001 记录当前状态
// 0x0002 记录pressed状态
// 0x0004 记录release状态
type button struct {
	id uint16
	state uint16
}
var btnId uint16 = 0
var buttonCache = make([]button, 64)
func NewButton() (btn *button) {
	btn = &buttonCache[btnId]
	btnId ++
	return
}

func (btn button) JustPressed() bool {
	return (btn.state & 0x02) == 2
}

func (btn button) JustReleased() bool {
	return (btn.state & 0x04) == 4
}

func (btn button) Down() bool {
	return (btn.state & 0x01) == 1
}

func (btn *button) Update(down bool){
	d := (btn.state & 0x01) == 1
	btn.state &= 0x04|0x02
	if down {
		btn.state |= 0x01
	}
	if d && !down {
		btn.state |= 0x04
	} else if !d && down {
		btn.state |= 0x02
	}
}

func (btn *button) Reset() {
	btn.state = btn.state & 0x01
}

```

`hid/input/button_test.go`:

```go
package input

import "testing"

func TestButton(t *testing.T) {
	btn := button{}
	btn.Update(true)

	if !btn.JustPressed() {
		t.Error("button not pressed")
	}
	if !btn.Down() {
		t.Error("button not down")
	}
	btn.Reset()

	btn.Update(true)
	if btn.JustPressed() {
		t.Error("button should not be pressed")
	}
	if !btn.Down() {
		t.Error("button not down")
	}
	btn.Reset()

	btn.Update(false)
	if !btn.JustReleased() {
		t.Error("button not released")
	}
	if btn.JustPressed() {
		t.Error("button should not be pressed")
	}
	if btn.Down() {
		t.Error("button should not be down")
	}
	btn.Reset()
}

func TestButton_Update2(t *testing.T) {
	btn := button{}
	btn.Update(true)
	btn.Update(true)

	if !btn.JustPressed() {
		t.Error("button not pressed")
	}
	if !btn.Down() {
		t.Error("button not down")
	}
	btn.Reset()

	btn.Update(false)
	btn.Update(false)

	if !btn.JustReleased() {
		t.Error("button not released")
	}
	if btn.Down() {
		t.Errorf("button should not be down")
	}
	btn.Reset()

	btn.Update(true)
	btn.Update(false)

	if !btn.JustPressed() {
		t.Error("button not pressed")
	}
	if !btn.JustReleased() {
		t.Error("button not released")
	}
	btn.Reset()
}
```

`hid/input/input.go`:

```go
package input

import (
	"sync"
	"korok.io/korok/math/f32"
)

// 记录一帧之内的按键，一帧时间做多支持同时按6个按键
type SparseMap struct {
	keys [6]Key
	stat [6]bool
	used int
}

func (m *SparseMap) Put(k Key, st bool) {
	m.keys[m.used] = k
	m.stat[m.used] = st
	m.used ++
}

func (m *SparseMap) Clear() {
	m.used = 0
}

func (m *SparseMap) Get(k Key) (st, ok bool) {
	for i := 0; i < m.used; i++ {
		if m.keys[i] == k {
			st, ok = m.stat[i], true
			break
		}
	}
	return
}

type InputSystem struct {
	buttons map[string]*button
	axes	map[string]*VAxis

	// 记录每帧的按键状态
	// 无论是用数组还是哈希，这里的实现总之要达到快速
	// 查询一个按键的状态的效果
	dirty SparseMap
	mutex   sync.RWMutex

	// 按照button排序，这样同一个Button的绑定按键是
	// 是连续的。
	binds []KeyBind

	// 触摸/鼠标, 最多支持10个手指头同时触摸
	// 通常情况下，active < 1
	active int
	pointerButton [10]button
	pointers [10]PointerInput
}

func NewInputSystem() *InputSystem {
	in := &InputSystem{
		buttons:make(map[string]*button),
		axes:make(map[string]*VAxis),
	}
	Input = in
	return in
}

/// 查询虚拟按键的状态
func (in *InputSystem) Button(name string) *button {
	return in.buttons[name]
}

func (in *InputSystem) AnyKeyChanged() bool {
	if in.dirty.used > 0 {
		return true
	}
	return false
}

/// 将物理按键映射到虚拟按键
func (in *InputSystem) RegisterButton(name string, keys ...Key) {
	btn := NewButton()
	in.buttons[name] = btn
	for _, k := range keys {
		in.binds = append(in.binds, KeyBind{k, btn})
	}
	// sort binds!!
}

// 更新 Button 状态....
// TODO 此处的输入状态，更新有bug！！
func (in *InputSystem) AdvanceFrame() {
	if n, dirty := len(in.binds), in.dirty.used; n > 0 && dirty > 0 {
		var st, ok bool
		var pr *button

		for _, bd := range in.binds {
			if s, o := in.dirty.Get(bd.key); o {
				st = st || s
				ok = ok || o
			}

			if pr != bd.btn {
				if ok {
					bd.btn.Update(st)
				}
				st, ok = false, false
			}

			pr = bd.btn
		}
	}
}

func (in *InputSystem) Reset() {
	// clear dirty map!!
	in.mutex.Lock()
	in.dirty.Clear()
	in.mutex.Unlock()
	// reset button state
	for _, v := range in.buttons {
		v.Reset()
	}
	for i := 0; i <= in.active; i++ {
		in.pointerButton[i].Reset()
	}
}

// 更新 key 的状态
func (in *InputSystem) SetKeyEvent(key int, pressed bool) {
	in.mutex.Lock()
	in.dirty.Put(Key(key), pressed)
	in.mutex.Unlock()
}

// 更新 Mouse/Touch 状态
func (in *InputSystem) SetPointerEvent(key int, pressed bool, x, y float32) {
	if key != -1000 {
		in.mutex.Lock()
		in.pointerButton[key].Update(pressed)
		in.pointers[key].MousePos = f32.Vec2{x, y}
		if key > in.active {
			in.active = key
		}
		in.mutex.Unlock()
	} else {
		// 如果是鼠标总是记录在 0 的位置
		// 如果是手指... 这就尴尬了..需要特殊处理
		in.pointers[0].MousePos = f32.Vec2{x, y}
	}
}

type Key int

type KeyBind struct {
	key Key
	btn *button
}

// short API
func Button(name string) button {
	return *Input.Button(name)
}

func AnyKeyChanged() bool {
	return Input.AnyKeyChanged()
}

func RegisterButton(name string, keys...Key) {
	Input.RegisterButton(name, keys...)
}

func PointerButton(pb KeyPoint) button {
	return Input.pointerButton[pb]
}

func PointerPosition(pb KeyPoint) PointerInput {
	return Input.pointers[pb]
}

// Touch event
func Touch(fi FingerId) (btn button, pos, delta f32.Vec2) {
	btn = Input.pointerButton[fi]
	p := Input.pointers[fi]
	pos, delta = p.MousePos, p.MouseDelta
	return
}

// Mouse event
func Mouse(key int) (btn *button, pos, delta f32.Vec2) {
	btn = &Input.pointerButton[key]
	p := Input.pointers[key]
	pos, delta = p.MousePos, p.MouseDelta
	return
}

var Input *InputSystem

// mouse or finger button
type KeyPoint int
const (
	KeyPoint1 KeyPoint = iota
	KeyPoint2
	KeyPoint3
	KeyPoint4
	KeyPoint5
	KeyPoint6
	KeyPoint7
	KeyPoint8
	KeyPoint9
	KeyPointX
)


```

`hid/input/joystick.go`:

```go
package input

/// 虚拟遥感
type VAxis struct {

}

```

`hid/input/keys_android.go`:

```go
// +build android

package input

const (
	Back = Key(4)
	Menu = Key(82)

	// Home key. This key is handled by the framework and is never delivered to applications.
	Home = Key(3)
)

```

`hid/input/keys_glfw.go`:

```go
// +build !android,!ios,!js

package input

import "github.com/go-gl/glfw/v3.2/glfw"

const (
	Grave        = Key(glfw.KeyGraveAccent)
	Dash         = Key(glfw.KeyMinus)
	Apostrophe   = Key(glfw.KeyApostrophe)
	Semicolon    = Key(glfw.KeySemicolon)
	Equals       = Key(glfw.KeyEqual)
	Comma        = Key(glfw.KeyComma)
	Period       = Key(glfw.KeyPeriod)
	Slash        = Key(glfw.KeySlash)
	Backslash    = Key(glfw.KeyBackslash)
	Backspace    = Key(glfw.KeyBackspace)
	Tab          = Key(glfw.KeyTab)
	CapsLock     = Key(glfw.KeyCapsLock)
	Space        = Key(glfw.KeySpace)
	Enter        = Key(glfw.KeyEnter)
	Escape       = Key(glfw.KeyEscape)
	Insert       = Key(glfw.KeyInsert)
	PrintScreen  = Key(glfw.KeyPrintScreen)
	Delete       = Key(glfw.KeyDelete)
	PageUp       = Key(glfw.KeyPageUp)
	PageDown     = Key(glfw.KeyPageDown)
	Home         = Key(glfw.KeyHome)
	End          = Key(glfw.KeyEnd)
	Pause        = Key(glfw.KeyPause)
	ScrollLock   = Key(glfw.KeyScrollLock)
	ArrowLeft    = Key(glfw.KeyLeft)
	ArrowRight   = Key(glfw.KeyRight)
	ArrowDown    = Key(glfw.KeyDown)
	ArrowUp      = Key(glfw.KeyUp)
	LeftBracket  = Key(glfw.KeyLeftBracket)
	LeftShift    = Key(glfw.KeyLeftShift)
	LeftControl  = Key(glfw.KeyLeftControl)
	LeftSuper    = Key(glfw.KeyLeftSuper)
	LeftAlt      = Key(glfw.KeyLeftAlt)
	RightBracket = Key(glfw.KeyRightBracket)
	RightShift   = Key(glfw.KeyRightShift)
	RightControl = Key(glfw.KeyRightControl)
	RightSuper   = Key(glfw.KeyRightSuper)
	RightAlt     = Key(glfw.KeyRightAlt)
	Zero         = Key(glfw.Key0)
	One          = Key(glfw.Key1)
	Two          = Key(glfw.Key2)
	Three        = Key(glfw.Key3)
	Four         = Key(glfw.Key4)
	Five         = Key(glfw.Key5)
	Six          = Key(glfw.Key6)
	Seven        = Key(glfw.Key7)
	Eight        = Key(glfw.Key8)
	Nine         = Key(glfw.Key9)
	F1           = Key(glfw.KeyF1)
	F2           = Key(glfw.KeyF2)
	F3           = Key(glfw.KeyF3)
	F4           = Key(glfw.KeyF4)
	F5           = Key(glfw.KeyF5)
	F6           = Key(glfw.KeyF6)
	F7           = Key(glfw.KeyF7)
	F8           = Key(glfw.KeyF8)
	F9           = Key(glfw.KeyF9)
	F10          = Key(glfw.KeyF10)
	F11          = Key(glfw.KeyF11)
	F12          = Key(glfw.KeyF12)
	A            = Key(glfw.KeyA)
	B            = Key(glfw.KeyB)
	C            = Key(glfw.KeyC)
	D            = Key(glfw.KeyD)
	E            = Key(glfw.KeyE)
	F            = Key(glfw.KeyF)
	G            = Key(glfw.KeyG)
	H            = Key(glfw.KeyH)
	I            = Key(glfw.KeyI)
	J            = Key(glfw.KeyJ)
	K            = Key(glfw.KeyK)
	L            = Key(glfw.KeyL)
	M            = Key(glfw.KeyM)
	N            = Key(glfw.KeyN)
	O            = Key(glfw.KeyO)
	P            = Key(glfw.KeyP)
	Q            = Key(glfw.KeyQ)
	R            = Key(glfw.KeyR)
	S            = Key(glfw.KeyS)
	T            = Key(glfw.KeyT)
	U            = Key(glfw.KeyU)
	V            = Key(glfw.KeyV)
	W            = Key(glfw.KeyW)
	X            = Key(glfw.KeyX)
	Y            = Key(glfw.KeyY)
	Z            = Key(glfw.KeyZ)
	NumLock      = Key(glfw.KeyNumLock)
	NumMultiply  = Key(glfw.KeyKPMultiply)
	NumDivide    = Key(glfw.KeyKPDivide)
	NumAdd       = Key(glfw.KeyKPAdd)
	NumSubtract  = Key(glfw.KeyKPSubtract)
	NumZero      = Key(glfw.KeyKP0)
	NumOne       = Key(glfw.KeyKP1)
	NumTwo       = Key(glfw.KeyKP2)
	NumThree     = Key(glfw.KeyKP3)
	NumFour      = Key(glfw.KeyKP4)
	NumFive      = Key(glfw.KeyKP5)
	NumSix       = Key(glfw.KeyKP6)
	NumSeven     = Key(glfw.KeyKP7)
	NumEight     = Key(glfw.KeyKP8)
	NumNine      = Key(glfw.KeyKP9)
	NumDecimal   = Key(glfw.KeyKPDecimal)
	NumEnter     = Key(glfw.KeyKPEnter)
)

```

`hid/input/keys_ios.go`:

```go
// +build ios

package input

// dummy TODO
const (
	Back = Key(4)
	Menu = Key(82)

	// Home key. This key is handled by the framework and is never delivered to applications.
	Home = Key(3)
)

```

`hid/input/keys_webgl.go`:

```go
// +build js

package input

// dummy TODO
const (
	Back = Key(4)
	Menu = Key(82)

	// Home key. This key is handled by the framework and is never delivered to applications.
	Home = Key(3)
)

```

`hid/input/touch.go`:

```go
package input

import "korok.io/korok/math/f32"

type FingerId int

//// Touch & Mouse input go here
type PointerInput struct {
	// The mouse pointer always has a pointer-id of 0
	Id FingerId

	// The position and moved amount of pointer
	MousePos, MouseDelta f32.Vec2

	used bool
}



```

`hid/lifecycle.go`:

```go
package hid

// 窗口生命周期
type WindowCallback interface {
	// 窗口创建
	OnCreate(w, h float32, pixelRatio float32)

	// Resize...
	OnResize(w, h int32)

	// 窗口循环
	OnLoop()

	// 窗口销毁
	OnDestroy()

	// 窗口切回？
	OnResume()

	// 窗口切入后台
	OnPause()

	// 窗口焦点变化
	OnFocusChanged(focused bool)
}

// 输入系统
type InputCallback interface {
	OnKeyEvent(key int, pressed bool)
	OnPointEvent(key int, pressed bool, x, y float32)
}

```

`hid/window_glfw.go`:

```go
//+build !android,!ios,!js

package hid

import (
	"github.com/go-gl/glfw/v3.2/glfw"
	"korok.io/korok/hid/gl"

	"fmt"
	"log"
	"runtime"
)

var windowCallback WindowCallback
var inputCallback InputCallback
var Keys [1024]int

func init() {
	runtime.LockOSThread()
}

func RegisterWindowCallback(callback WindowCallback) {
	windowCallback = callback
}

func RegisterInputCallback(callback InputCallback) {
	inputCallback = callback
}

func CreateWindow(option *WindowOptions) {
	fmt.Println(glfw.GetVersionString())

	// 初始化 glfw
	err := glfw.Init()
	defer glfw.Terminate()

	if err != nil {
		log.Fatal(err)
	}

	// 设置API版本兼容, 最低支持：3.2
	glfw.WindowHint(glfw.ContextVersionMajor, 3)
	glfw.WindowHint(glfw.ContextVersionMinor, 2)
	glfw.WindowHint(glfw.OpenGLProfile, glfw.OpenGLCoreProfile)
	glfw.WindowHint(glfw.OpenGLForwardCompatible, glfw.True)

	// window resizable hint
	if option.Resizable {
		glfw.WindowHint(glfw.Resizable, glfw.True)
	} else {
		glfw.WindowHint(glfw.Resizable, glfw.False)
	}
	// hide title-bar
	if option.NoTitleBar {
		glfw.WindowHint(glfw.Decorated, glfw.False)
	} else {
		glfw.WindowHint(glfw.Decorated, glfw.True)
	}

	monitor := glfw.GetPrimaryMonitor()
	mode := &glfw.VidMode{
		Width:       1,
		Height:      1,
		RedBits:     8,
		GreenBits:   8,
		BlueBits:    8,
		RefreshRate: 60,
	}
	if monitor != nil {
		mode = monitor.GetVideoMode()
	}

	// if full-screen ignore width and height
	if option.FullScreen {
		option.Width = mode.Width
		option.Height = mode.Height
	} else {
		monitor = nil
	}

	// 创建窗口
	window, err := glfw.CreateWindow(option.Width, option.Height, option.Title, monitor, nil)
	if err != nil {
		fmt.Println("fail window:", err)
		return
	}
	defer window.Destroy()

	if !option.FullScreen && mode.Width != 1 {
		window.SetPos((mode.Width-option.Width)/2, (mode.Height-option.Height)/2)
	}

	// make the window's context current
	window.MakeContextCurrent()

	if option.NoVsync {
		glfw.SwapInterval(0)
	} else {
		glfw.SwapInterval(1)
	}

	window.SetFramebufferSizeCallback(func(w *glfw.Window, width int, height int) {
		gl.Viewport(0, 0, int32(width), int32(height))
	})

	// Handle input callback
	window.SetKeyCallback(func(w *glfw.Window, key glfw.Key, scancode int, action glfw.Action, mods glfw.ModifierKey) {
		if key == glfw.KeyEscape && action == glfw.Press {
			w.SetShouldClose(true)
		}

		//if key >= 0 && key < 1024 {
		//	if action == glfw.Press {
		//		Keys[key] = gl.TRUE
		//	} else if action == glfw.Release {
		//		Keys[key] = gl.FALSE
		//	}
		//}
		if inputCallback != nil {
			if action == glfw.Press {
				inputCallback.OnKeyEvent(int(key), true)
			} else if action == glfw.Release {
				inputCallback.OnKeyEvent(int(key), false)
			}
		}
	})

	window.SetMouseButtonCallback(func(w *glfw.Window, button glfw.MouseButton, action glfw.Action, mod glfw.ModifierKey) {
		if inputCallback != nil {
			x, y := w.GetCursorPos()
			pb := int(button)
			if action == glfw.Press {
				inputCallback.OnPointEvent(pb, true, float32(x), float32(y))
			} else {
				inputCallback.OnPointEvent(pb, false, float32(x), float32(y))
			}
		}
	})

	window.SetIconifyCallback(func(w *glfw.Window, iconified bool) {
		if iconified {
			windowCallback.OnPause()
		} else {
			windowCallback.OnResume()
		}
	})
	window.SetFocusCallback(func(w *glfw.Window, focused bool) {
		windowCallback.OnFocusChanged(focused)
	})

	window.SetSizeCallback(func(w *glfw.Window, width int, height int) {
		windowCallback.OnResize(int32(width), int32(height))
		// 此处应该判断是否全屏 TODO
	})

	// init openGL
	// golang 版本必须调用此init方法来加载本地OpenGL指针，C原声不需要
	// 见go-gl文档:https://github.com/go-gl/gl
	if err := gl.Init(); err != nil {
		fmt.Print(err)
		return
	}

	// 读取本机的 OpenGL 版本
	//version := gl.GoStr(gl.GetString(gl.VERSION))
	//fmt.Println("OpenGL version", version)

	// viewport size
	w, h := window.GetFramebufferSize()
	gl.Viewport(0, 0, int32(w), int32(h))

	// DEBUG
	// ========== Engine Start
	windowCallback.OnCreate(float32(option.Width), float32(option.Height), float32(w)/float32(option.Width))
	windowCallback.OnResize(int32(option.Width), int32(option.Height))

	// ========== Engine End
	// 全局配置
	//gl.Enable(gl.DEPTH_TEST)
	//gl.DepthFunc(gl.LESS)
	if option.Clear[3] == 0 {
		gl.ClearColor(1.0, 1.0, 1.0, 1.0)
	} else {
		gl.ClearColor(option.Clear[0], option.Clear[1], option.Clear[2], option.Clear[3])
	}

	// 如果窗口没有关闭，那么应该持续当前的循环
	// main loop...
	for !window.ShouldClose() {
		gl.Clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)

		windowCallback.OnLoop()

		// swap buffer
		window.SwapBuffers()

		// poll event
		glfw.PollEvents()

		// cursor should be update every frame!!
		if inputCallback != nil {
			x, y := window.GetCursorPos()
			inputCallback.OnPointEvent(-1000, false, float32(x), float32(y))
		}
	}
	windowCallback.OnDestroy()
}

```

`hid/window_mob.go`:

```go
// +build android ios

package hid

import (
	"golang.org/x/mobile/app"
	"golang.org/x/mobile/event/key"
	"golang.org/x/mobile/event/lifecycle"
	"golang.org/x/mobile/event/paint"
	"golang.org/x/mobile/event/size"
	"golang.org/x/mobile/event/touch"
	"korok.io/korok/hid/gl"

	"os"
	"sync"
)

var options *WindowOptions

var (
	once     sync.Once
	widthPx  int
	heightPx int
)

var (
	windowCallback WindowCallback
	inputCallback  InputCallback
	Keys           [1024]int
)

func RegisterWindowCallback(callback WindowCallback) {
	windowCallback = callback
}

func RegisterInputCallback(callback InputCallback) {
	inputCallback = callback
}

// Mobile always full-screen.
func CreateWindow(opt *WindowOptions) {
	options = opt
	app.Main(func(a app.App) {
		var (
			glctx interface{}
			sz    size.Event
		)
		for e := range a.Events() {
			switch e := a.Filter(e).(type) {
			case lifecycle.Event:
				switch e.Crosses(lifecycle.StageAlive) {
				case lifecycle.CrossOn:
					onCreate()
				case lifecycle.CrossOff:
					onDestroy()
				}
				switch e.Crosses(lifecycle.StageVisible) {
				case lifecycle.CrossOn:
					glctx = e.DrawContext
					onStart(e)
					a.Send(paint.Event{})
				case lifecycle.CrossOff:
					onStop()
					glctx = nil
				}
			case size.Event:
				sz = e
				onResize(e)
			case paint.Event:
				if glctx == nil || e.External {
					// As we are actively painting as fast as
					// we can (usually 60 FPS), skip any paint
					// events sent by the system.
					continue
				}
				onPaint(e, sz)
				a.Publish()
				// Drive the animation by preparing to paint the next frame
				// after this one is shown.
				a.Send(paint.Event{})
			case touch.Event:
				onTouch(e)
			case key.Event:
				onKey(e)
			}
		}
	})
}

func onCreate() {
	widthPx = app.DisplayMetrics.WidthPx
	heightPx = app.DisplayMetrics.HeightPx
}

func onStart(e lifecycle.Event) {
	if e.DrawContext == nil {
		return
	}
	gl.InitContext(e.DrawContext)
	bg := options.Clear
	if bg[3] == 0 {
		gl.ClearColor(1, 1, 1, 1)
	} else {
		gl.ClearColor(bg[0], bg[1], bg[2], bg[3])
	}
	once.Do(func() {
		windowCallback.OnCreate(float32(widthPx), float32(heightPx), 1)
	})
	windowCallback.OnResume()
}

func onStop() {
	windowCallback.OnPause()
	gl.Release()
}

func onDestroy() {
	windowCallback.OnDestroy()
	os.Exit(0)
}

func onResize(e size.Event) {
	widthPx, heightPx = e.WidthPx, e.HeightPx
	iw, ih := int32(e.WidthPx), int32(e.HeightPx)
	windowCallback.OnResize(iw, ih)
}

func onPaint(e paint.Event, sz size.Event) {
	gl.Clear(gl.COLOR_BUFFER_BIT)
	windowCallback.OnLoop()
}

func onTouch(e touch.Event) {
	var pressed bool
	switch e.Type {
	case touch.TypeBegin:
		pressed = true
	case touch.TypeMove:
		pressed = true
	case touch.TypeEnd:
		pressed = false
	}
	inputCallback.OnPointEvent(0, pressed, e.X, e.Y)
}

func onKey(e key.Event) {
	inputCallback.OnKeyEvent(int(e.Code), e.Direction == key.DirPress)
}

```

`hid/window_webgl.go`:

```go
// +build js

package hid

import (
	"log"
	// "os"
	"runtime"
	"runtime/pprof"
	"syscall/js"

	"korok.io/korok/asset/res"
	"korok.io/korok/hid/gl"

	"strconv"
	"time"
)

var windowCallback WindowCallback
var inputCallback InputCallback
var Keys [1024]int
var AudioCtx js.Value
var AudioCheck bool

func init() {
	runtime.LockOSThread()
}

func RegisterWindowCallback(callback WindowCallback) {
	windowCallback = callback
}

func RegisterInputCallback(callback InputCallback) {
	inputCallback = callback
}

func consume(event js.Value) {
	event.Call("stopPropagation")
	event.Call("preventDefault")
}

func sn() {
	x := time.Now().Format("2006-01-02-15-04-05")
	println("-------------", x)
	f, err := res.Create(x)
	if err != nil {
		log.Fatal("xxxxxxxxxxxx: ", err)
	}

	pprof.Lookup("allocs").WriteTo(f, 0)
	// pprof.Lookup("heap").WriteTo(f, 2)
	// if err := pprof.WriteHeapProfile(f); err != nil {
	// 	log.Fatal("could not write memory profile: ", err)
	// }

}

func CreateWindow(option *WindowOptions) {
	document := js.Global().Get("document")
	document.Set("title", option.Title)

	canvas := document.Call("createElement", "canvas")

	ww := js.Global().Get("innerWidth").Int()
	hh := js.Global().Get("innerHeight").Int()

	r := float32(ww) / float32(option.Width)
	wh := float32(option.Width) / float32(option.Height)
	h := int(float32(ww) / wh)
	var w int
	if hh >= h {
		w = ww
	} else {
		r = float32(hh) / float32(option.Height)
		hw := float32(option.Height) / float32(option.Width)
		w = int(float32(hh) / hw)
		h = hh
	}

	canvas.Set("width", strconv.Itoa(w))
	canvas.Set("height", strconv.Itoa(h))
	document.Get("body").Call("appendChild", canvas)
	err := gl.Init(canvas)
	if err != nil {
		js.Global().Call("alert", "Error: "+err.Error())
		return
	}

	ac := js.Global().Get("AudioContext")
	if ac == js.Undefined() {
		ac = js.Global().Get("webkitAudioContext")
	}
	if ac == js.Undefined() {
		println("audio couldn't be initialized")
	}

	AudioCtx = ac.New()

	mousedown := js.FuncOf(func(this js.Value, arg []js.Value) interface{} {
		if !AudioCheck {
			AudioCheck = true
			AudioCtx.Call("resume")
		}
		consume(arg[0])
		// go sn()
		rect := canvas.Call("getBoundingClientRect")
		x := arg[0].Get("clientX").Int() - rect.Get("left").Int()
		y := arg[0].Get("clientY").Int() - rect.Get("top").Int()
		button := arg[0].Get("button").Int()
		inputCallback.OnPointEvent(button, true, float32(x)/r, float32(y)/r)

		return nil
	})
	mouseup := js.FuncOf(func(this js.Value, arg []js.Value) interface{} {
		if !AudioCheck {
			AudioCheck = true
			AudioCtx.Call("resume")
		}
		consume(arg[0])
		rect := canvas.Call("getBoundingClientRect")
		x := arg[0].Get("clientX").Int() - rect.Get("left").Int()
		y := arg[0].Get("clientY").Int() - rect.Get("top").Int()
		button := arg[0].Get("button").Int()
		inputCallback.OnPointEvent(button, false, float32(x)/r, float32(y)/r)

		return nil
	})
	keydown := js.FuncOf(func(this js.Value, arg []js.Value) interface{} {
		if !AudioCheck {
			AudioCheck = true
			AudioCtx.Call("resume")
		}
		consume(arg[0])
		// TODO 这里需要处理特殊按键
		button := arg[0].Get("key").String()
		inputCallback.OnKeyEvent(int(button[0]), true)

		return nil
	})
	keyup := js.FuncOf(func(this js.Value, arg []js.Value) interface{} {
		if !AudioCheck {
			AudioCheck = true
			AudioCtx.Call("resume")
		}
		consume(arg[0])
		// TODO 这里需要处理特殊按键
		button := arg[0].Get("key").String()
		inputCallback.OnKeyEvent(int(button[0]), false)

		return nil
	})

	// ========== Engine Start
	windowCallback.OnCreate(float32(option.Width), float32(option.Height), r)
	windowCallback.OnResize(int32(option.Width), int32(option.Height))

	// resize := js.FuncOf(func(this js.Value, arg []js.Value) interface{} {
	// 	consume(arg[0])

	// 	w = js.Global().Get("innerWidth").Int()

	// 	wh = float32(option.Width) / float32(option.Height)
	// 	h = int(float32(w) / wh)

	// 	canvas.Set("width", strconv.Itoa(w))
	// 	canvas.Set("height", strconv.Itoa(h))

	// 	windowCallback.OnResize(int32(option.Width), int32(option.Height))

	// 	return nil
	// })

	canvas.Call("addEventListener", "mousedown", mousedown, true)
	canvas.Call("addEventListener", "mouseup", mouseup, true)
	document.Call("addEventListener", "keydown", keydown, true)
	document.Call("addEventListener", "keyup", keyup, true)

	// js.Global().Call("addEventListener", "resize", resize, true)

	// st := time.Second / 60
	// ticker := time.NewTicker(st)
	// for _ = range ticker.C {
	// 	gl.Clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)
	// 	windowCallback.OnLoop()
	// 	// window.SwapBuffers()
	// }

	var renderFrame js.Func
	renderFrame = js.FuncOf(func(this js.Value, args []js.Value) interface{} {

		go func() {
			// runtime.GC()
			gl.Clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)
			windowCallback.OnLoop()
			// window.SwapBuffers()
			js.Global().Call("requestAnimationFrame", renderFrame)
		}()

		return nil
	})
	js.Global().Call("requestAnimationFrame", renderFrame)
	done := make(chan struct{}, 0)
	<-done

	renderFrame.Release()
	mousedown.Release()
	mouseup.Release()
	keydown.Release()
	keyup.Release()

	// resize.Release()

	windowCallback.OnDestroy()
}

```

`korok.go`:

```go
package korok

import (
	"log"
	"reflect"

	"korok.io/korok/gfx"
	"korok.io/korok/engi"
	"korok.io/korok/game"
	"korok.io/korok/hid"
	"korok.io/korok/effect"
	"korok.io/korok/hid/input"
	"korok.io/korok/anim/frame"
)

const VERSION_CODE  = 2
const VERSION_NAME  = "0.2"

type Options hid.WindowOptions

func Run(options *Options, sc game.Scene)  {
	log.Println("Game Start! " + options.Title)

	g := &game.Game{}
	g.Init()

	G = g
	Entity = g.DB.EntityM
	SceneMan = &g.SceneManager
	SceneMan.SetDefault(sc)

	// init table shortcut
	for _, table := range g.DB.Tables {
		switch t := table.(type) {
		case *gfx.SpriteTable:
			Sprite = t
		case *gfx.MeshTable:
			Mesh = t
		case *gfx.TransformTable:
			Transform = t
		case *gfx.TextTable:
			Text = t
		case *effect.ParticleSystemTable:
			ParticleSystem = t
		case *game.TagTable:
			Tag = t
		case *game.ScriptTable:
			Script = t
		case *frame.FlipbookTable:
			Flipbook = t
		}
	}

	log.Printf("Load table: %v", len(g.DB.Tables))
	for i, v := range g.DB.Tables {
		log.Println(i, "table - ", reflect.TypeOf(v))
	}

	hid.RegisterWindowCallback(g)
	hid.RegisterInputCallback(g)
	hid.CreateWindow((*hid.WindowOptions)(options))
}

var G *game.Game
var SceneMan *game.SceneManager

// entity-api
var Entity *engi.EntityManager

var Script *game.ScriptTable
var Tag    *game.TagTable

// shortcut component-api for rendering system
var Sprite 	   *gfx.SpriteTable
var Mesh       *gfx.MeshTable
var Transform  *gfx.TransformTable
var Text       *gfx.TextTable

// animation system
var Flipbook *frame.FlipbookTable

// particle system
var ParticleSystem *effect.ParticleSystemTable

// input system
var Input *input.InputSystem

```

`math/doc.go`:

```go
package math

/**
	二维/三维数学相关基本类型定义预操作

	geometry.go 几何数学
	other...go  代数，矩阵
 */
```

`math/ease/back.go`:

```go
package ease

func InBack(t float64) float64 {
	s := 1.70158
	return t * t * ((s+1)*t - s)
}

func OutBack(t float64) float64 {
	s := 1.70158
	t -= 1
	return t*t*((s+1)*t+s) + 1
}

func InOutBack(t float64) float64 {
	s := 1.70158
	t *= 2
	if t < 1 {
		s *= 1.525
		return 0.5 * (t * t * ((s+1)*t - s))
	} else {
		t -= 2
		s *= 1.525
		return 0.5 * (t*t*((s+1)*t+s) + 2)
	}
}



```

`math/ease/bounce.go`:

```go
package ease


func InBounce(t float64) float64 {
	return 1 - OutBounce(1-t)
}

func OutBounce(t float64) float64 {
	if t < 4/11.0 {
		return (121 * t * t) / 16.0
	} else if t < 8/11.0 {
		return (363 / 40.0 * t * t) - (99 / 10.0 * t) + 17/5.0
	} else if t < 9/10.0 {
		return (4356 / 361.0 * t * t) - (35442 / 1805.0 * t) + 16061/1805.0
	} else {
		return (54 / 5.0 * t * t) - (513 / 25.0 * t) + 268/25.0
	}
}

func InOutBounce(t float64) float64 {
	if t < 0.5 {
		return InBounce(2*t) * 0.5
	} else {
		return OutBounce(2*t-1)*0.5 + 0.5
	}
}

```

`math/ease/circle.go`:

```go
package ease

import "math"

func InCirc(t float64) float64 {
	return -1 * (math.Sqrt(1-t*t) - 1)
}

func OutCirc(t float64) float64 {
	t -= 1
	return math.Sqrt(1 - (t * t))
}

func InOutCirc(t float64) float64 {
	t *= 2
	if t < 1 {
		return -0.5 * (math.Sqrt(1-t*t) - 1)
	} else {
		t = t - 2
		return 0.5 * (math.Sqrt(1-t*t) + 1)
	}
}

```

`math/ease/cubic.go`:

```go
package ease


func InCubic(t float64) float64 {
	return t * t * t
}

func OutCubic(t float64) float64 {
	t -= 1
	return t*t*t + 1
}

func InOutCubic(t float64) float64 {
	t *= 2
	if t < 1 {
		return 0.5 * t * t * t
	} else {
		t -= 2
		return 0.5 * (t*t*t + 2)
	}
}

```

`math/ease/ease.go`:

```go
package ease


type Function func(float64) float64

func Linear(t float64) float64 {
	return t
}

func InSquare(t float64) float64 {
	if t < 1 {
		return 0
	} else {
		return 1
	}
}

func OutSquare(t float64) float64 {
	if t > 0 {
		return 1
	} else {
		return 0
	}
}

func InOutSquare(t float64) float64 {
	if t < 0.5 {
		return 0
	} else {
		return 1
	}
}

```

`math/ease/elastic.go`:

```go
package ease

import "math"

func InElastic(t float64) float64 {
	return InElasticFunction(0.5)(t)
}

func OutElastic(t float64) float64 {
	return OutElasticFunction(0.5)(t)
}

func InOutElastic(t float64) float64 {
	return InOutElasticFunction(0.5)(t)
}

func InElasticFunction(period float64) Function {
	p := period
	return func(t float64) float64 {
		t -= 1
		return -1 * (math.Pow(2, 10*t) * math.Sin((t-p/4)*(2*math.Pi)/p))
	}
}

func OutElasticFunction(period float64) Function {
	p := period
	return func(t float64) float64 {
		return math.Pow(2, -10*t)*math.Sin((t-p/4)*(2*math.Pi/p)) + 1
	}
}

func InOutElasticFunction(period float64) Function {
	p := period
	return func(t float64) float64 {
		t *= 2
		if t < 1 {
			t -= 1
			return -0.5 * (math.Pow(2, 10*t) * math.Sin((t-p/4)*2*math.Pi/p))
		} else {
			t -= 1
			return math.Pow(2, -10*t)*math.Sin((t-p/4)*2*math.Pi/p)*0.5 + 1
		}
	}
}

```

`math/ease/expo.go`:

```go
package ease

import "math"

func InExpo(t float64) float64 {
	if t == 0 {
		return 0
	} else {
		return math.Pow(2, 10*(t-1))
	}
}

func OutExpo(t float64) float64 {
	if t == 1 {
		return 1
	} else {
		return 1 - math.Pow(2, -10*t)
	}
}

func InOutExpo(t float64) float64 {
	if t == 0 {
		return 0
	} else if t == 1 {
		return 1
	} else {
		if t < 0.5 {
			return 0.5 * math.Pow(2, (20*t)-10)
		} else {
			return 1 - 0.5*math.Pow(2, (-20*t)+10)
		}
	}
}


```

`math/ease/quad.go`:

```go
package ease


func InQuad(t float64) float64 {
	return t * t
}

func OutQuad(t float64) float64 {
	return -t * (t - 2)
}

func InOutQuad(t float64) float64 {
	if t < 0.5 {
		return 2 * t * t
	} else {
		t = 2*t - 1
		return -0.5 * (t*(t-2) - 1)
	}
}

```

`math/ease/quart.go`:

```go
package ease


func InQuart(t float64) float64 {
	return t * t * t * t
}

func OutQuart(t float64) float64 {
	t -= 1
	return -(t*t*t*t - 1)
}

func InOutQuart(t float64) float64 {
	t *= 2
	if t < 1 {
		return 0.5 * t * t * t * t
	} else {
		t -= 2
		return -0.5 * (t*t*t*t - 2)
	}
}

```

`math/ease/quint.go`:

```go
package ease

func InQuint(t float64) float64 {
	return t * t * t * t * t
}

func OutQuint(t float64) float64 {
	t -= 1
	return t*t*t*t*t + 1
}

func InOutQuint(t float64) float64 {
	t *= 2
	if t < 1 {
		return 0.5 * t * t * t * t * t
	} else {
		t -= 2
		return 0.5 * (t*t*t*t*t + 2)
	}
}

```

`math/ease/sine.go`:

```go
package ease

import "math"

func InSine(t float64) float64 {
	return -1*math.Cos(t*math.Pi/2) + 1
}

func OutSine(t float64) float64 {
	return math.Sin(t * math.Pi / 2)
}

func InOutSine(t float64) float64 {
	return -0.5 * (math.Cos(math.Pi*t) - 1)
}


```

`math/f32.go`:

```go
package math

import (
	"unsafe"
	"math/rand"
	"math"
	"korok.io/korok/math/f32"
)

const MaxFloat32 float32 = 3.40282346638528859811704183484516925440e+38
const Pi = math.Pi

/// This is A approximate yet fast inverse square-root.
func InvSqrt(x float32) float32 {
	xhalf := float32(0.5) * x
	i := *(*int32)(unsafe.Pointer(&x))
	i = int32(0x5f3759df) - int32(i>>1)
	x = *(*float32)(unsafe.Pointer(&i))
	x = x * (1.5 - (xhalf * x * x))
	return x
}

func InvLength(x, y , fail float32) float32 {
	return 1/float32(math.Sqrt(float64(x*x + y*y)))
}


/// a faster way ?
func Random(low, high float32) float32 {
	return low + (high - low) * rand.Float32()
}

func ABS(a float32) float32 {
	if a < 0 {
		return -a
	}
	return a
}

func Max(a, b float32) float32 {
	if a < b {
		return b
	}
	return a
}

func Min(a, b float32) float32 {
	if a < b {
		return a
	}
	return b
}

func Clamp(v, left, right float32) float32{
	if v > right {
		return right
	}
	if v < left {
		return left
	}
	return v
}

func Sin(r float32) float32 {
	return float32(math.Sin(float64(r)))
}

func Cos(r float32) float32 {
	return float32(math.Cos(float64(r)))
}

func Atan2(y, x float32) float32 {
	return float32(math.Atan2(float64(y), float64(x)))
}

func Floor(v float32) float32 {
	return float32(math.Floor(float64(v)))
}

func Ceil(v float32) float32 {
	return float32(math.Ceil(float64(v)))
}

// Radian converts degree to radian.
func Radian(d float32) float32 {
	return d * Pi / 180
}

// Degree converts radian to degree.
func Degree(r float32) float32 {
	return r * 180 / Pi
}


func AngleTo(v1, v2 f32.Vec2) (dot float32) {
	l1 := InvLength(v1[0], v1[1], 1)
	l2 := InvLength(v2[0], v2[1], 1)

	x1, y1 := v1[0]*l1, v1[1]*l1
	x2, y2 := v2[0]*l2, v2[1]*l2
	dot = x1 * x2 + y1 * y2
	return
}

func Direction(v1, v2 f32.Vec2) float32 {
	return v1[0]*v2[1] - v1[1]*v2[0]
}

func Angle(v f32.Vec2) float32 {
	return float32(math.Atan2(float64(v[1]), float64(v[0])))
}

func Vector(a float32) f32.Vec2 {
	return f32.Vec2{Cos(a), Sin(a)}
}
```

`math/f32/matrix.go`:

```go
package f32

import (
	"golang.org/x/image/math/f32"
	"math"
)

type Mat3 f32.Mat3
type Mat4 f32.Mat4

// SetCol sets a Column within the Matrix, so it mutates the calling matrix.
func (m *Mat3) SetCol(col int, v Vec3) {
	m[col*3+0], m[col*3+1], m[col*3+2] = v[0], v[1], v[2]
}

// SetRow sets a Row within the Matrix, so it mutates the calling matrix.
func (m *Mat3) SetRow(row int, v Vec3) {
	m[row+0], m[row+3], m[row+6] = v[0], v[1], v[2]
}

// Diag returns main diagonal (meaning all elements such that row==col).
func (m Mat3) Diag() Vec3 {
	return Vec3{m[0], m[4], m[8]}
}

// Transform transforms (x, y) to (x1, y).
//
// matrix multiplication carried out on paper:
// |1    x| |c -s  | |sx     | | 1 ky  | |1   -ox|
// |  1  y| |s  c  | |   sy  | |kx  1  | |  1 -oy|
// |     1| |     1| |      1| |      1| |     1 |
//   move    rotate    scale     skew      origin
func (m Mat3) Transform(x, y float32) (x1, y1 float32) {
	x1 = m[0]*x + m[3]*y + m[6]
	y1 = m[1]*x + m[4]*y + m[7]
	return
}

// Initialize defines a 3-D Matrix.
//            | x |
//            | y |
//            | 1 |
// | e0 e3 e6 |
// | e1 e4 e7 |
// | e2 e5 e8 |
func (m *Mat3) Initialize(x, y, angle, sx, sy, ox, oy, kx, ky float32) {
	c, s := cos(angle), sin(angle)

	m[0] = c * sx - ky * s * sy // = a
	m[1] = s * sx + ky * c * sy // = b
	m[3] = kx * c * sx - s * sy // = c
	m[4] = kx * s * sx + c * sy // = d
	m[6] = x - ox * m[0] - oy * m[3]
	m[7] = y - ox * m[1] - oy * m[4]

	m[2], m[5] = 0, 0
	m[8] = 1.0
}

func (m *Mat3) InitializeScale1(x, y, angle, ox, oy float32) {
	c, s := cos(angle), sin(angle)

	m[0] = c // = a
	m[1] = s // = b
	m[3] = - s // = c
	m[4] = + c // = d
	m[6] = x - ox * m[0] - oy * m[3]
	m[7] = y - ox * m[1] - oy * m[4]

	m[2], m[5] = 0, 0
	m[8] = 1.0
}

func sin(r float32) float32 {
	return float32(math.Sin(float64(r)))
}

func cos(r float32) float32 {
	return float32(math.Cos(float64(r)))
}

// Ident3 returns the 3x3 identity matrix.
func Ident3() Mat3 {
	return Mat3{1, 0, 0, 0, 1, 0, 0, 0, 1}
}

// SetCol sets a Column within the Matrix.
func (m *Mat4) SetCol(col int, v Vec4) {
	m[col*4+0], m[col*4+1], m[col*4+2], m[col*4+3] = v[0], v[1], v[2], v[3]
}

// SetRow sets a Row within the Matrix.
func (m *Mat4) SetRow(row int, v Vec4) {
	m[row+0], m[row+4], m[row+8], m[row+12] = v[0], v[1], v[2], v[3]
}

// Diag returns main diagonal (meaning all elements such that row==col).
func (m Mat4) Diag() Vec4 {
	return Vec4{m[0], m[5], m[10], m[15]}
}

// Ident4 returns the 4x4 identity matrix.
func Ident4() Mat4 {
	return Mat4{1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1}
}

// At returns the matrix element at the given row and column.
func (m Mat4) At(row, col int) float32 {
	return m[col*4+row]
}

// Set sets the corresponding matrix element at the given row and column.
func (m *Mat4) Set(row, col int, value float32) {
	m[col*4+row] = value
}

```

`math/f32/project.go`:

```go
package f32

import (
	"math"
)

func Ortho(left, right, bottom, top, near, far float32) Mat4 {
	rml, tmb, fmn := (right - left), (top - bottom), (far - near)

	return Mat4{float32(2. / rml), 0, 0, 0, 0, float32(2. / tmb), 0, 0, 0, 0, float32(-2. / fmn), 0, float32(-(right + left) / rml), float32(-(top + bottom) / tmb), float32(-(far + near) / fmn), 1}
}

// Equivalent to Ortho with the near and far planes being -1 and 1, respectively
func Ortho2D(left, right, bottom, top float32) Mat4 {
	return Ortho(left, right, bottom, top, -1, 1)
}

func Perspective(fovy, aspect, near, far float32) Mat4 {
	// fovy = (fovy * math.Pi) / 180.0 // convert from degrees to radians
	nmf, f := near-far, float32(1./math.Tan(float64(fovy)/2.0))

	return Mat4{float32(f / aspect), 0, 0, 0, 0, float32(f), 0, 0, 0, 0, float32((near + far) / nmf), -1, 0, 0, float32((2. * far * near) / nmf), 0}
}

func Frustum(left, right, bottom, top, near, far float32) Mat4 {
	rml, tmb, fmn := (right - left), (top - bottom), (far - near)
	A, B, C, D := (right+left)/rml, (top+bottom)/tmb, -(far+near)/fmn, -(2*far*near)/fmn

	return Mat4{float32((2. * near) / rml), 0, 0, 0, 0, float32((2. * near) / tmb), 0, 0, float32(A), float32(B), float32(C), -1, 0, 0, float32(D), 0}
}

```

`math/f32/transform.go`:

```go
// Copyright 2014 The go-gl Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package f32

import "math"

// Rotate3DY returns a 3x3 (non-homogeneous) Matrix that rotates by angle about the Y-axis
//
// Where c is cos(angle) and s is sin(angle)
//    [c 0 s]
//    [0 1 0]
//    [s 0 c ]
func Rotate3DY(angle float32) Mat3 {
	//angle = (angle * math.Pi) / 180.0
	sin, cos := float32(math.Sin(float64(angle))), float32(math.Cos(float64(angle)))

	return Mat3{cos, 0, -sin, 0, 1, 0, sin, 0, cos}
}

// Rotate3DZ returns a 3x3 (non-homogeneous) Matrix that rotates by angle about the Z-axis
//
// Where c is cos(angle) and s is sin(angle)
//    [c -s 0]
//    [s c 0]
//    [0 0 1 ]
func Rotate3DZ(angle float32) Mat3 {
	//angle = (angle * math.Pi) / 180.0
	sin, cos := float32(math.Sin(float64(angle))), float32(math.Cos(float64(angle)))

	return Mat3{cos, sin, 0, -sin, cos, 0, 0, 0, 1}
}

// Translate2D returns a homogeneous (3x3 for 2D-space) Translation matrix that moves a point by Tx units in the x-direction and Ty units in the y-direction
//
//    [[1, 0, Tx]]
//    [[0, 1, Ty]]
//    [[0, 0, 1 ]]
func Translate2D(Tx, Ty float32) Mat3 {
	return Mat3{1, 0, 0, 0, 1, 0, float32(Tx), float32(Ty), 1}
}

// Translate3D returns a homogeneous (4x4 for 3D-space) Translation matrix that moves a point by Tx units in the x-direction, Ty units in the y-direction,
// and Tz units in the z-direction
//
//    [[1, 0, 0, Tx]]
//    [[0, 1, 0, Ty]]
//    [[0, 0, 1, Tz]]
//    [[0, 0, 0, 1 ]]
func Translate3D(Tx, Ty, Tz float32) Mat4 {
	return Mat4{1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, float32(Tx), float32(Ty), float32(Tz), 1}
}

```

`math/f32/vector.go`:

```go
package f32

import (
	"golang.org/x/image/math/f32"
	"math"
)

type Vec2 f32.Vec2
type Vec3 f32.Vec3
type Vec4 f32.Vec4


func (v1 Vec2) Add(v2 Vec2) Vec2 {
	return Vec2{v1[0] + v2[0], v1[1] + v2[1]}
}

func (v1 Vec2) Sub(v2 Vec2) Vec2 {
	return Vec2{v1[0] - v2[0], v1[1] - v2[1]}
}

func (v1 Vec2) Mul(c float32) Vec2 {
	return Vec2{v1[0] * c, v1[1] * c}
}

func (v1 Vec2) Len() float32 {
	return float32(math.Sqrt(float64(v1[0]*v1[0]+v1[1]*v1[1])))
}

func (v1 Vec2) IsZero() bool {
	return v1[0]==0 && v1[1]==0
}

func (v1 Vec2) Norm() Vec2 {
	d := float32(math.Sqrt(float64(v1[0]*v1[0]+v1[1]*v1[1])))
	return Vec2{v1[0]/d, v1[1]/d}
}

func (v1 Vec2) Dot(v2 Vec2) float32 {
	return v1[0]*v2[0] + v1[1]*v2[1]
}

func (v1 Vec2) Cross(v2 Vec2) float32 {
	return v1[0]*v2[1] - v1[1]*v2[0]
}

func (v1 Vec3) Add(v2 Vec3) Vec3 {
	return Vec3{v1[0] + v2[0], v1[1] + v2[1], v1[2] + v2[2]}
}

func (v1 Vec3) Sub(v2 Vec3) Vec3 {
	return Vec3{v1[0] - v2[0], v1[1] - v2[1], v1[2] - v2[2]}
}

func (v1 Vec3) Mul(c float32) Vec3 {
	return Vec3{v1[0] * c, v1[1] * c, v1[2] * c}
}


```

`math/geom.go`:

```go
package math

// 点
type Point struct {
	X, Y float32
}

// 大小
type Size struct {
	Width, Height float32
}

// 矩形
type Rect struct {
	Min, Max Point
}

func (rect *Rect) Dx() float32{
	return rect.Max.X - rect.Min.X
}

func (rect *Rect) Dy() float32 {
	return rect.Max.Y - rect.Min.Y
}

func (rect *Rect) Center() Point {
	return Point{(rect.Max.X - rect.Min.X) / 2, (rect.Max.Y - rect.Min.X) / 2}
}








```

`math/i32.go`:

```go
package math

// types for int/int32/int16...

func U32Clamp(v, low, high uint32) uint32 {
	if v < low {
		return low
	}
	if v > high {
		return high
	}
	return v
}

func U32Min(a, b uint32) uint32 {
	if a < b {
		return a
	}
	return b
}

func U32Max(a, b uint32) uint32 {
	if a < b {
		return b
	}
	return a
}

func U16Clamp(v, low, high uint16) uint16 {
	if v < low {
		return low
	}
	if v > high {
		return high
	}
	return v
}

func U16Min(a, b uint16) uint16 {
	if a < b {
		return a
	}
	return b
}

func U16Max(a, b uint16) uint16 {
	if a < b {
		return b
	}
	return a
}

// Pow2 returns the first power-of-two value >= to n.
// This can be used to create suitable Texture dimensions.
func Pow2(x uint32) uint32 {
	x--
	x |= x >> 1
	x |= x >> 2
	x |= x >> 4
	x |= x >> 8
	x |= x >> 16
	return x + 1
}

// IsPow2 returns true if the given value if a power-of-two.
func IsPow2(x uint32) bool {
	return (x & (x-1)) == 0
}

```

`webav/webaudio.go`:

```go
// +build js

// Copyright 2014 Joseph Hager. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package webav

import (
	"errors"

	"syscall/js"
)

type AudioContextAttributes struct {
	// LatencyHint: 这个参数表示了重放的类型, 参数是播放效果和资源消耗的一种权衡。
	// 可接受的值有 "balanced", "interactive" 和"playback"，
	// 默认值为 "interactive"。意思是 "平衡音频输出延迟和资源消耗", "提供最小的音频输出延迟最好没有干扰"和 "对比音频输出延迟，优先重放不被中断"。
	// 我们也可以用一个双精度的值来定义一个秒级的延迟数值做到更精确的控制。
	LatencyHint string
}

func ms2mi(x map[string]string) map[string]interface{} {
	y := make(map[string]interface{})
	for k, v := range x {
		y[k] = v
	}
	return y
}

// AudioDefaultAttributes 返回默认属性
func AudioDefaultAttributes() *AudioContextAttributes {
	return &AudioContextAttributes{"interactive"}
}

type AudioContext struct {
	js.Value
}

// AudioNewContext 获取音频对象
func AudioNewContext(ca *AudioContextAttributes) (*AudioContext, error) {

	if ca == nil {
		ca = AudioDefaultAttributes()
	}
	attrs := map[string]string{
		"latencyHint": ca.LatencyHint,
	}

	audioContext := js.Global().Get("AudioContext")
	if audioContext == js.Undefined() || audioContext == js.Null() {
		audioContext = js.Global().Get("webkitAudioContext")
	}
	if audioContext == js.Undefined() || audioContext == js.Null() {
		return nil, errors.New("Your browser doesn't appear to support Web Audio API.")
	}

	ac := audioContext.New(ms2mi(attrs))
	if ac == js.Null() {
		return nil, errors.New("Creating a Web Audio API context has failed.")
	}
	ctx := new(AudioContext)
	ctx.Value = ac
	return ctx, nil
}

func (c *AudioContext) Close() {
	c.Call("close")
}

func (c *AudioContext) CreateBuffer(numOfChannels, length, sampleRate int) js.Value {
	return c.Call("createBuffer", numOfChannels, length, sampleRate)
}

type AudioBufferSource struct {
	js.Value
}

func (c *AudioContext) CreateBufferSource() *AudioBufferSource {
	jsv := c.Call("createBufferSource")
	abs := new(AudioBufferSource)
	abs.Value = jsv
	return abs
}

func (c *AudioBufferSource) Start() js.Value {
	return c.Call("start")
}

func (c *AudioBufferSource) Stop() js.Value {
	return c.Call("stop")
}

```

`webav/webgl.go`:

```go
// +build js

// Copyright 2014 Joseph Hager. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package webav

import (
	"errors"

	"syscall/js"
)

type ContextAttributes struct {
	// If Alpha is true, the drawing buffer has an alpha channel for
	// the purposes of performing OpenGL destination alpha operations
	// and compositing with the page.
	Alpha bool

	// If Depth is true, the drawing buffer has a depth buffer of at least 16 bits.
	Depth bool

	// If Stencil is true, the drawing buffer has a stencil buffer of at least 8 bits.
	Stencil bool

	// If Antialias is true and the implementation supports antialiasing
	// the drawing buffer will perform antialiasing using its choice of
	// technique (multisample/supersample) and quality.
	Antialias bool

	// If PremultipliedAlpha is true the page compositor will assume the
	// drawing buffer contains colors with premultiplied alpha.
	// This flag is ignored if the alpha flag is false.
	PremultipliedAlpha bool

	// If the value is true the buffers will not be cleared and will preserve
	// their values until cleared or overwritten by the author.
	PreserveDrawingBuffer bool
}

func mb2mi(x map[string]bool) map[string]interface{} {
	y := make(map[string]interface{})
	for k, v := range x {
		y[k] = v
	}
	return y
}

// Returns a copy of the default WebGL context attributes.
func DefaultAttributes() *ContextAttributes {
	return &ContextAttributes{true, true, false, true, true, false}
}

type Context struct {
	js.Value
	ARRAY_BUFFER                                 int `js:"ARRAY_BUFFER"`
	ARRAY_BUFFER_BINDING                         int `js:"ARRAY_BUFFER_BINDING"`
	ATTACHED_SHADERS                             int `js:"ATTACHED_SHADERS"`
	BACK                                         int `js:"BACK"`
	BLEND                                        int `js:"BLEND"`
	BLEND_COLOR                                  int `js:"BLEND_COLOR"`
	BLEND_DST_ALPHA                              int `js:"BLEND_DST_ALPHA"`
	BLEND_DST_RGB                                int `js:"BLEND_DST_RGB"`
	BLEND_EQUATION                               int `js:"BLEND_EQUATION"`
	BLEND_EQUATION_ALPHA                         int `js:"BLEND_EQUATION_ALPHA"`
	BLEND_EQUATION_RGB                           int `js:"BLEND_EQUATION_RGB"`
	BLEND_SRC_ALPHA                              int `js:"BLEND_SRC_ALPHA"`
	BLEND_SRC_RGB                                int `js:"BLEND_SRC_RGB"`
	BLUE_BITS                                    int `js:"BLUE_BITS"`
	BOOL                                         int `js:"BOOL"`
	BOOL_VEC2                                    int `js:"BOOL_VEC2"`
	BOOL_VEC3                                    int `js:"BOOL_VEC3"`
	BOOL_VEC4                                    int `js:"BOOL_VEC4"`
	BROWSER_DEFAULT_WEBGL                        int `js:"BROWSER_DEFAULT_WEBGL"`
	BUFFER_SIZE                                  int `js:"BUFFER_SIZE"`
	BUFFER_USAGE                                 int `js:"BUFFER_USAGE"`
	BYTE                                         int `js:"BYTE"`
	CCW                                          int `js:"CCW"`
	CLAMP_TO_EDGE                                int `js:"CLAMP_TO_EDGE"`
	COLOR_ATTACHMENT0                            int `js:"COLOR_ATTACHMENT0"`
	COLOR_BUFFER_BIT                             int `js:"COLOR_BUFFER_BIT"`
	COLOR_CLEAR_VALUE                            int `js:"COLOR_CLEAR_VALUE"`
	COLOR_WRITEMASK                              int `js:"COLOR_WRITEMASK"`
	COMPILE_STATUS                               int `js:"COMPILE_STATUS"`
	COMPRESSED_TEXTURE_FORMATS                   int `js:"COMPRESSED_TEXTURE_FORMATS"`
	CONSTANT_ALPHA                               int `js:"CONSTANT_ALPHA"`
	CONSTANT_COLOR                               int `js:"CONSTANT_COLOR"`
	CONTEXT_LOST_WEBGL                           int `js:"CONTEXT_LOST_WEBGL"`
	CULL_FACE                                    int `js:"CULL_FACE"`
	CULL_FACE_MODE                               int `js:"CULL_FACE_MODE"`
	CURRENT_PROGRAM                              int `js:"CURRENT_PROGRAM"`
	CURRENT_VERTEX_ATTRIB                        int `js:"CURRENT_VERTEX_ATTRIB"`
	CW                                           int `js:"CW"`
	DECR                                         int `js:"DECR"`
	DECR_WRAP                                    int `js:"DECR_WRAP"`
	DELETE_STATUS                                int `js:"DELETE_STATUS"`
	DEPTH_ATTACHMENT                             int `js:"DEPTH_ATTACHMENT"`
	DEPTH_BITS                                   int `js:"DEPTH_BITS"`
	DEPTH_BUFFER_BIT                             int `js:"DEPTH_BUFFER_BIT"`
	DEPTH_CLEAR_VALUE                            int `js:"DEPTH_CLEAR_VALUE"`
	DEPTH_COMPONENT                              int `js:"DEPTH_COMPONENT"`
	DEPTH_COMPONENT16                            int `js:"DEPTH_COMPONENT16"`
	DEPTH_FUNC                                   int `js:"DEPTH_FUNC"`
	DEPTH_RANGE                                  int `js:"DEPTH_RANGE"`
	DEPTH_STENCIL                                int `js:"DEPTH_STENCIL"`
	DEPTH_STENCIL_ATTACHMENT                     int `js:"DEPTH_STENCIL_ATTACHMENT"`
	DEPTH_TEST                                   int `js:"DEPTH_TEST"`
	DEPTH_WRITEMASK                              int `js:"DEPTH_WRITEMASK"`
	DITHER                                       int `js:"DITHER"`
	DONT_CARE                                    int `js:"DONT_CARE"`
	DST_ALPHA                                    int `js:"DST_ALPHA"`
	DST_COLOR                                    int `js:"DST_COLOR"`
	DYNAMIC_DRAW                                 int `js:"DYNAMIC_DRAW"`
	ELEMENT_ARRAY_BUFFER                         int `js:"ELEMENT_ARRAY_BUFFER"`
	ELEMENT_ARRAY_BUFFER_BINDING                 int `js:"ELEMENT_ARRAY_BUFFER_BINDING"`
	EQUAL                                        int `js:"EQUAL"`
	FASTEST                                      int `js:"FASTEST"`
	FLOAT                                        int `js:"FLOAT"`
	FLOAT_MAT2                                   int `js:"FLOAT_MAT2"`
	FLOAT_MAT3                                   int `js:"FLOAT_MAT3"`
	FLOAT_MAT4                                   int `js:"FLOAT_MAT4"`
	FLOAT_VEC2                                   int `js:"FLOAT_VEC2"`
	FLOAT_VEC3                                   int `js:"FLOAT_VEC3"`
	FLOAT_VEC4                                   int `js:"FLOAT_VEC4"`
	FRAGMENT_SHADER                              int `js:"FRAGMENT_SHADER"`
	FRAMEBUFFER                                  int `js:"FRAMEBUFFER"`
	FRAMEBUFFER_ATTACHMENT_OBJECT_NAME           int `js:"FRAMEBUFFER_ATTACHMENT_OBJECT_NAME"`
	FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE           int `js:"FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE"`
	FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE int `js:"FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE"`
	FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL         int `js:"FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL"`
	FRAMEBUFFER_BINDING                          int `js:"FRAMEBUFFER_BINDING"`
	FRAMEBUFFER_COMPLETE                         int `js:"FRAMEBUFFER_COMPLETE"`
	FRAMEBUFFER_INCOMPLETE_ATTACHMENT            int `js:"FRAMEBUFFER_INCOMPLETE_ATTACHMENT"`
	FRAMEBUFFER_INCOMPLETE_DIMENSIONS            int `js:"FRAMEBUFFER_INCOMPLETE_DIMENSIONS"`
	FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT    int `js:"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT"`
	FRAMEBUFFER_UNSUPPORTED                      int `js:"FRAMEBUFFER_UNSUPPORTED"`
	FRONT                                        int `js:"FRONT"`
	FRONT_AND_BACK                               int `js:"FRONT_AND_BACK"`
	FRONT_FACE                                   int `js:"FRONT_FACE"`
	FUNC_ADD                                     int `js:"FUNC_ADD"`
	FUNC_REVERSE_SUBTRACT                        int `js:"FUNC_REVERSE_SUBTRACT"`
	FUNC_SUBTRACT                                int `js:"FUNC_SUBTRACT"`
	GENERATE_MIPMAP_HINT                         int `js:"GENERATE_MIPMAP_HINT"`
	GEQUAL                                       int `js:"GEQUAL"`
	GREATER                                      int `js:"GREATER"`
	GREEN_BITS                                   int `js:"GREEN_BITS"`
	HIGH_FLOAT                                   int `js:"HIGH_FLOAT"`
	HIGH_INT                                     int `js:"HIGH_INT"`
	INCR                                         int `js:"INCR"`
	INCR_WRAP                                    int `js:"INCR_WRAP"`
	INFO_LOG_LENGTH                              int `js:"INFO_LOG_LENGTH"`
	INT                                          int `js:"INT"`
	INT_VEC2                                     int `js:"INT_VEC2"`
	INT_VEC3                                     int `js:"INT_VEC3"`
	INT_VEC4                                     int `js:"INT_VEC4"`
	INVALID_ENUM                                 int `js:"INVALID_ENUM"`
	INVALID_FRAMEBUFFER_OPERATION                int `js:"INVALID_FRAMEBUFFER_OPERATION"`
	INVALID_OPERATION                            int `js:"INVALID_OPERATION"`
	INVALID_VALUE                                int `js:"INVALID_VALUE"`
	INVERT                                       int `js:"INVERT"`
	KEEP                                         int `js:"KEEP"`
	LEQUAL                                       int `js:"LEQUAL"`
	LESS                                         int `js:"LESS"`
	LINEAR                                       int `js:"LINEAR"`
	LINEAR_MIPMAP_LINEAR                         int `js:"LINEAR_MIPMAP_LINEAR"`
	LINEAR_MIPMAP_NEAREST                        int `js:"LINEAR_MIPMAP_NEAREST"`
	LINES                                        int `js:"LINES"`
	LINE_LOOP                                    int `js:"LINE_LOOP"`
	LINE_STRIP                                   int `js:"LINE_STRIP"`
	LINE_WIDTH                                   int `js:"LINE_WIDTH"`
	LINK_STATUS                                  int `js:"LINK_STATUS"`
	LOW_FLOAT                                    int `js:"LOW_FLOAT"`
	LOW_INT                                      int `js:"LOW_INT"`
	LUMINANCE                                    int `js:"LUMINANCE"`
	LUMINANCE_ALPHA                              int `js:"LUMINANCE_ALPHA"`
	MAX_COMBINED_TEXTURE_IMAGE_UNITS             int `js:"MAX_COMBINED_TEXTURE_IMAGE_UNITS"`
	MAX_CUBE_MAP_TEXTURE_SIZE                    int `js:"MAX_CUBE_MAP_TEXTURE_SIZE"`
	MAX_FRAGMENT_UNIFORM_VECTORS                 int `js:"MAX_FRAGMENT_UNIFORM_VECTORS"`
	MAX_RENDERBUFFER_SIZE                        int `js:"MAX_RENDERBUFFER_SIZE"`
	MAX_TEXTURE_IMAGE_UNITS                      int `js:"MAX_TEXTURE_IMAGE_UNITS"`
	MAX_TEXTURE_SIZE                             int `js:"MAX_TEXTURE_SIZE"`
	MAX_VARYING_VECTORS                          int `js:"MAX_VARYING_VECTORS"`
	MAX_VERTEX_ATTRIBS                           int `js:"MAX_VERTEX_ATTRIBS"`
	MAX_VERTEX_TEXTURE_IMAGE_UNITS               int `js:"MAX_VERTEX_TEXTURE_IMAGE_UNITS"`
	MAX_VERTEX_UNIFORM_VECTORS                   int `js:"MAX_VERTEX_UNIFORM_VECTORS"`
	MAX_VIEWPORT_DIMS                            int `js:"MAX_VIEWPORT_DIMS"`
	MEDIUM_FLOAT                                 int `js:"MEDIUM_FLOAT"`
	MEDIUM_INT                                   int `js:"MEDIUM_INT"`
	MIRRORED_REPEAT                              int `js:"MIRRORED_REPEAT"`
	NEAREST                                      int `js:"NEAREST"`
	NEAREST_MIPMAP_LINEAR                        int `js:"NEAREST_MIPMAP_LINEAR"`
	NEAREST_MIPMAP_NEAREST                       int `js:"NEAREST_MIPMAP_NEAREST"`
	NEVER                                        int `js:"NEVER"`
	NICEST                                       int `js:"NICEST"`
	NONE                                         int `js:"NONE"`
	NOTEQUAL                                     int `js:"NOTEQUAL"`
	NO_ERROR                                     int `js:"NO_ERROR"`
	NUM_COMPRESSED_TEXTURE_FORMATS               int `js:"NUM_COMPRESSED_TEXTURE_FORMATS"`
	ONE                                          int `js:"ONE"`
	ONE_MINUS_CONSTANT_ALPHA                     int `js:"ONE_MINUS_CONSTANT_ALPHA"`
	ONE_MINUS_CONSTANT_COLOR                     int `js:"ONE_MINUS_CONSTANT_COLOR"`
	ONE_MINUS_DST_ALPHA                          int `js:"ONE_MINUS_DST_ALPHA"`
	ONE_MINUS_DST_COLOR                          int `js:"ONE_MINUS_DST_COLOR"`
	ONE_MINUS_SRC_ALPHA                          int `js:"ONE_MINUS_SRC_ALPHA"`
	ONE_MINUS_SRC_COLOR                          int `js:"ONE_MINUS_SRC_COLOR"`
	OUT_OF_MEMORY                                int `js:"OUT_OF_MEMORY"`
	PACK_ALIGNMENT                               int `js:"PACK_ALIGNMENT"`
	POINTS                                       int `js:"POINTS"`
	POLYGON_OFFSET_FACTOR                        int `js:"POLYGON_OFFSET_FACTOR"`
	POLYGON_OFFSET_FILL                          int `js:"POLYGON_OFFSET_FILL"`
	POLYGON_OFFSET_UNITS                         int `js:"POLYGON_OFFSET_UNITS"`
	RED_BITS                                     int `js:"RED_BITS"`
	RENDERBUFFER                                 int `js:"RENDERBUFFER"`
	RENDERBUFFER_ALPHA_SIZE                      int `js:"RENDERBUFFER_ALPHA_SIZE"`
	RENDERBUFFER_BINDING                         int `js:"RENDERBUFFER_BINDING"`
	RENDERBUFFER_BLUE_SIZE                       int `js:"RENDERBUFFER_BLUE_SIZE"`
	RENDERBUFFER_DEPTH_SIZE                      int `js:"RENDERBUFFER_DEPTH_SIZE"`
	RENDERBUFFER_GREEN_SIZE                      int `js:"RENDERBUFFER_GREEN_SIZE"`
	RENDERBUFFER_HEIGHT                          int `js:"RENDERBUFFER_HEIGHT"`
	RENDERBUFFER_INTERNAL_FORMAT                 int `js:"RENDERBUFFER_INTERNAL_FORMAT"`
	RENDERBUFFER_RED_SIZE                        int `js:"RENDERBUFFER_RED_SIZE"`
	RENDERBUFFER_STENCIL_SIZE                    int `js:"RENDERBUFFER_STENCIL_SIZE"`
	RENDERBUFFER_WIDTH                           int `js:"RENDERBUFFER_WIDTH"`
	RENDERER                                     int `js:"RENDERER"`
	REPEAT                                       int `js:"REPEAT"`
	REPLACE                                      int `js:"REPLACE"`
	RGB                                          int `js:"RGB"`
	RGB5_A1                                      int `js:"RGB5_A1"`
	RGB565                                       int `js:"RGB565"`
	RGBA                                         int `js:"RGBA"`
	RGBA4                                        int `js:"RGBA4"`
	SAMPLER_2D                                   int `js:"SAMPLER_2D"`
	SAMPLER_CUBE                                 int `js:"SAMPLER_CUBE"`
	SAMPLES                                      int `js:"SAMPLES"`
	SAMPLE_ALPHA_TO_COVERAGE                     int `js:"SAMPLE_ALPHA_TO_COVERAGE"`
	SAMPLE_BUFFERS                               int `js:"SAMPLE_BUFFERS"`
	SAMPLE_COVERAGE                              int `js:"SAMPLE_COVERAGE"`
	SAMPLE_COVERAGE_INVERT                       int `js:"SAMPLE_COVERAGE_INVERT"`
	SAMPLE_COVERAGE_VALUE                        int `js:"SAMPLE_COVERAGE_VALUE"`
	SCISSOR_BOX                                  int `js:"SCISSOR_BOX"`
	SCISSOR_TEST                                 int `js:"SCISSOR_TEST"`
	SHADER_COMPILER                              int `js:"SHADER_COMPILER"`
	SHADER_SOURCE_LENGTH                         int `js:"SHADER_SOURCE_LENGTH"`
	SHADER_TYPE                                  int `js:"SHADER_TYPE"`
	SHADING_LANGUAGE_VERSION                     int `js:"SHADING_LANGUAGE_VERSION"`
	SHORT                                        int `js:"SHORT"`
	SRC_ALPHA                                    int `js:"SRC_ALPHA"`
	SRC_ALPHA_SATURATE                           int `js:"SRC_ALPHA_SATURATE"`
	SRC_COLOR                                    int `js:"SRC_COLOR"`
	STATIC_DRAW                                  int `js:"STATIC_DRAW"`
	STENCIL_ATTACHMENT                           int `js:"STENCIL_ATTACHMENT"`
	STENCIL_BACK_FAIL                            int `js:"STENCIL_BACK_FAIL"`
	STENCIL_BACK_FUNC                            int `js:"STENCIL_BACK_FUNC"`
	STENCIL_BACK_PASS_DEPTH_FAIL                 int `js:"STENCIL_BACK_PASS_DEPTH_FAIL"`
	STENCIL_BACK_PASS_DEPTH_PASS                 int `js:"STENCIL_BACK_PASS_DEPTH_PASS"`
	STENCIL_BACK_REF                             int `js:"STENCIL_BACK_REF"`
	STENCIL_BACK_VALUE_MASK                      int `js:"STENCIL_BACK_VALUE_MASK"`
	STENCIL_BACK_WRITEMASK                       int `js:"STENCIL_BACK_WRITEMASK"`
	STENCIL_BITS                                 int `js:"STENCIL_BITS"`
	STENCIL_BUFFER_BIT                           int `js:"STENCIL_BUFFER_BIT"`
	STENCIL_CLEAR_VALUE                          int `js:"STENCIL_CLEAR_VALUE"`
	STENCIL_FAIL                                 int `js:"STENCIL_FAIL"`
	STENCIL_FUNC                                 int `js:"STENCIL_FUNC"`
	STENCIL_INDEX                                int `js:"STENCIL_INDEX"`
	STENCIL_INDEX8                               int `js:"STENCIL_INDEX8"`
	STENCIL_PASS_DEPTH_FAIL                      int `js:"STENCIL_PASS_DEPTH_FAIL"`
	STENCIL_PASS_DEPTH_PASS                      int `js:"STENCIL_PASS_DEPTH_PASS"`
	STENCIL_REF                                  int `js:"STENCIL_REF"`
	STENCIL_TEST                                 int `js:"STENCIL_TEST"`
	STENCIL_VALUE_MASK                           int `js:"STENCIL_VALUE_MASK"`
	STENCIL_WRITEMASK                            int `js:"STENCIL_WRITEMASK"`
	STREAM_DRAW                                  int `js:"STREAM_DRAW"`
	SUBPIXEL_BITS                                int `js:"SUBPIXEL_BITS"`
	TEXTURE                                      int `js:"TEXTURE"`
	TEXTURE0                                     int `js:"TEXTURE0"`
	TEXTURE1                                     int `js:"TEXTURE1"`
	TEXTURE2                                     int `js:"TEXTURE2"`
	TEXTURE3                                     int `js:"TEXTURE3"`
	TEXTURE4                                     int `js:"TEXTURE4"`
	TEXTURE5                                     int `js:"TEXTURE5"`
	TEXTURE6                                     int `js:"TEXTURE6"`
	TEXTURE7                                     int `js:"TEXTURE7"`
	TEXTURE8                                     int `js:"TEXTURE8"`
	TEXTURE9                                     int `js:"TEXTURE9"`
	TEXTURE10                                    int `js:"TEXTURE10"`
	TEXTURE11                                    int `js:"TEXTURE11"`
	TEXTURE12                                    int `js:"TEXTURE12"`
	TEXTURE13                                    int `js:"TEXTURE13"`
	TEXTURE14                                    int `js:"TEXTURE14"`
	TEXTURE15                                    int `js:"TEXTURE15"`
	TEXTURE16                                    int `js:"TEXTURE16"`
	TEXTURE17                                    int `js:"TEXTURE17"`
	TEXTURE18                                    int `js:"TEXTURE18"`
	TEXTURE19                                    int `js:"TEXTURE19"`
	TEXTURE20                                    int `js:"TEXTURE20"`
	TEXTURE21                                    int `js:"TEXTURE21"`
	TEXTURE22                                    int `js:"TEXTURE22"`
	TEXTURE23                                    int `js:"TEXTURE23"`
	TEXTURE24                                    int `js:"TEXTURE24"`
	TEXTURE25                                    int `js:"TEXTURE25"`
	TEXTURE26                                    int `js:"TEXTURE26"`
	TEXTURE27                                    int `js:"TEXTURE27"`
	TEXTURE28                                    int `js:"TEXTURE28"`
	TEXTURE29                                    int `js:"TEXTURE29"`
	TEXTURE30                                    int `js:"TEXTURE30"`
	TEXTURE31                                    int `js:"TEXTURE31"`
	TEXTURE_2D                                   int `js:"TEXTURE_2D"`
	TEXTURE_BINDING_2D                           int `js:"TEXTURE_BINDING_2D"`
	TEXTURE_BINDING_CUBE_MAP                     int `js:"TEXTURE_BINDING_CUBE_MAP"`
	TEXTURE_CUBE_MAP                             int `js:"TEXTURE_CUBE_MAP"`
	TEXTURE_CUBE_MAP_NEGATIVE_X                  int `js:"TEXTURE_CUBE_MAP_NEGATIVE_X"`
	TEXTURE_CUBE_MAP_NEGATIVE_Y                  int `js:"TEXTURE_CUBE_MAP_NEGATIVE_Y"`
	TEXTURE_CUBE_MAP_NEGATIVE_Z                  int `js:"TEXTURE_CUBE_MAP_NEGATIVE_Z"`
	TEXTURE_CUBE_MAP_POSITIVE_X                  int `js:"TEXTURE_CUBE_MAP_POSITIVE_X"`
	TEXTURE_CUBE_MAP_POSITIVE_Y                  int `js:"TEXTURE_CUBE_MAP_POSITIVE_Y"`
	TEXTURE_CUBE_MAP_POSITIVE_Z                  int `js:"TEXTURE_CUBE_MAP_POSITIVE_Z"`
	TEXTURE_MAG_FILTER                           int `js:"TEXTURE_MAG_FILTER"`
	TEXTURE_MIN_FILTER                           int `js:"TEXTURE_MIN_FILTER"`
	TEXTURE_WRAP_S                               int `js:"TEXTURE_WRAP_S"`
	TEXTURE_WRAP_T                               int `js:"TEXTURE_WRAP_T"`
	TRIANGLES                                    int `js:"TRIANGLES"`
	TRIANGLE_FAN                                 int `js:"TRIANGLE_FAN"`
	TRIANGLE_STRIP                               int `js:"TRIANGLE_STRIP"`
	UNPACK_ALIGNMENT                             int `js:"UNPACK_ALIGNMENT"`
	UNPACK_COLORSPACE_CONVERSION_WEBGL           int `js:"UNPACK_COLORSPACE_CONVERSION_WEBGL"`
	UNPACK_FLIP_Y_WEBGL                          int `js:"UNPACK_FLIP_Y_WEBGL"`
	UNPACK_PREMULTIPLY_ALPHA_WEBGL               int `js:"UNPACK_PREMULTIPLY_ALPHA_WEBGL"`
	UNSIGNED_BYTE                                int `js:"UNSIGNED_BYTE"`
	UNSIGNED_INT                                 int `js:"UNSIGNED_INT"`
	UNSIGNED_SHORT                               int `js:"UNSIGNED_SHORT"`
	UNSIGNED_SHORT_4_4_4_4                       int `js:"UNSIGNED_SHORT_4_4_4_4"`
	UNSIGNED_SHORT_5_5_5_1                       int `js:"UNSIGNED_SHORT_5_5_5_1"`
	UNSIGNED_SHORT_5_6_5                         int `js:"UNSIGNED_SHORT_5_6_5"`
	VALIDATE_STATUS                              int `js:"VALIDATE_STATUS"`
	VENDOR                                       int `js:"VENDOR"`
	VERSION                                      int `js:"VERSION"`
	VERTEX_ATTRIB_ARRAY_BUFFER_BINDING           int `js:"VERTEX_ATTRIB_ARRAY_BUFFER_BINDING"`
	VERTEX_ATTRIB_ARRAY_ENABLED                  int `js:"VERTEX_ATTRIB_ARRAY_ENABLED"`
	VERTEX_ATTRIB_ARRAY_NORMALIZED               int `js:"VERTEX_ATTRIB_ARRAY_NORMALIZED"`
	VERTEX_ATTRIB_ARRAY_POINTER                  int `js:"VERTEX_ATTRIB_ARRAY_POINTER"`
	VERTEX_ATTRIB_ARRAY_SIZE                     int `js:"VERTEX_ATTRIB_ARRAY_SIZE"`
	VERTEX_ATTRIB_ARRAY_STRIDE                   int `js:"VERTEX_ATTRIB_ARRAY_STRIDE"`
	VERTEX_ATTRIB_ARRAY_TYPE                     int `js:"VERTEX_ATTRIB_ARRAY_TYPE"`
	VERTEX_SHADER                                int `js:"VERTEX_SHADER"`
	VIEWPORT                                     int `js:"VIEWPORT"`
	ZERO                                         int `js:"ZERO"`
}

// NewContext takes an HTML5 canvas object and optional context attributes.
// If an error is returned it means you won't have access to WebGL
// functionality.
func NewContext(canvas js.Value, ca *ContextAttributes) (*Context, error) {
	if js.Global().Get("WebGLRenderingContext") == js.Undefined() {
		return nil, errors.New("Your browser doesn't appear to support webgl.")
	}

	if ca == nil {
		ca = DefaultAttributes()
	}

	attrs := map[string]bool{
		"alpha":                 ca.Alpha,
		"depth":                 ca.Depth,
		"stencil":               ca.Stencil,
		"antialias":             ca.Antialias,
		"premultipliedAlpha":    ca.PremultipliedAlpha,
		"preserveDrawingBuffer": ca.PreserveDrawingBuffer,
	}
	gl := canvas.Call("getContext", "webgl", mb2mi(attrs))
	if gl == js.Null() {
		gl = canvas.Call("getContext", "experimental-webgl", mb2mi(attrs))
		if gl == js.Null() {
			return nil, errors.New("Creating a webgl context has failed.")
		}
	}
	ctx := new(Context)
	ctx.Value = gl
	return ctx, nil
}

// Returns the context attributes active on the context. These values might
// be different than what was requested on context creation if the
// browser's implementation doesn't support a feature.
func (c *Context) GetContextAttributes() ContextAttributes {
	ca := c.Call("getContextAttributes")
	return ContextAttributes{
		ca.Get("alpha").Bool(),
		ca.Get("depth").Bool(),
		ca.Get("stencil").Bool(),
		ca.Get("antialias").Bool(),
		ca.Get("premultipliedAlpha").Bool(),
		ca.Get("preservedDrawingBuffer").Bool(),
	}
}

// Specifies the active texture unit.
func (c *Context) ActiveTexture(texture int) {
	c.Call("activeTexture", texture)
}

// Attaches a WebGLShader object to a WebGLProgram object.
func (c *Context) AttachShader(program js.Value, shader js.Value) {
	c.Call("attachShader", program, shader)
}

// Binds a generic vertex index to a user-defined attribute variable.
func (c *Context) BindAttribLocation(program js.Value, index int, name string) {
	c.Call("bindAttribLocation", program, index, name)
}

// Associates a buffer with a buffer target.
func (c *Context) BindBuffer(target int, buffer js.Value) {
	c.Call("bindBuffer", target, buffer)
}

// Associates a WebGLFramebuffer object with the FRAMEBUFFER bind target.
func (c *Context) BindFramebuffer(target int, framebuffer js.Value) {
	c.Call("bindFramebuffer", target, framebuffer)
}

// Binds a WebGLRenderbuffer object to be used for rendering.
func (c *Context) BindRenderbuffer(target int, renderbuffer js.Value) {
	c.Call("bindRenderbuffer", target, renderbuffer)
}

// Binds a named texture object to a target.
func (c *Context) BindTexture(target int, texture js.Value) {
	c.Call("bindTexture", target, texture)
}

// The GL_BLEND_COLOR may be used to calculate the source and destination blending factors.
func (c *Context) BlendColor(r, g, b, a float64) {
	c.Call("blendColor", r, g, b, a)
}

// Sets the equation used to blend RGB and Alpha values of an incoming source
// fragment with a destination values as stored in the fragment's frame buffer.
func (c *Context) BlendEquation(mode int) {
	c.Call("blendEquation", mode)
}

// Controls the blending of an incoming source fragment's R, G, B, and A values
// with a destination R, G, B, and A values as stored in the fragment's WebGLFramebuffer.
func (c *Context) BlendEquationSeparate(modeRGB, modeAlpha int) {
	c.Call("blendEquationSeparate", modeRGB, modeAlpha)
}

// Sets the blending factors used to combine source and destination pixels.
func (c *Context) BlendFunc(sfactor, dfactor int) {
	c.Call("blendFunc", sfactor, dfactor)
}

// Sets the weighting factors that are used by blendEquationSeparate.
func (c *Context) BlendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha int) {
	c.Call("blendFuncSeparate", srcRGB, dstRGB, srcAlpha, dstAlpha)
}

// Creates a buffer in memory and initializes it with array data.
// If no array is provided, the contents of the buffer is initialized to 0.
func (c *Context) BufferData(target int, data interface{}, usage int) {
	c.Call("bufferData", target, data, usage)
}

// Used to modify or update some or all of a data store for a bound buffer object.
func (c *Context) BufferSubData(target int, offset int, data interface{}) {
	c.Call("bufferSubData", target, offset, data)
}

// Returns whether the currently bound WebGLFramebuffer is complete.
// If not complete, returns the reason why.
func (c *Context) CheckFramebufferStatus(target int) int {
	return c.Call("checkFramebufferStatus", target).Int()
}

// Sets all pixels in a specific buffer to the same value.
func (c *Context) Clear(flags int) {
	c.Call("clear", flags)
}

// Specifies color values to use by the clear method to clear the color buffer.
func (c *Context) ClearColor(r, g, b, a float32) {
	c.Call("clearColor", r, g, b, a)
}

// Clears the depth buffer to a specific value.
func (c *Context) ClearDepth(depth float64) {
	c.Call("clearDepth", depth)
}

func (c *Context) ClearStencil(s int) {
	c.Call("clearStencil", s)
}

// Lets you set whether individual colors can be written when
// drawing or rendering to a framebuffer.
func (c *Context) ColorMask(r, g, b, a bool) {
	c.Call("colorMask", r, g, b, a)
}

// Compiles the GLSL shader source into binary data used by the WebGLProgram object.
func (c *Context) CompileShader(shader js.Value) {
	c.Call("compileShader", shader)
}

// Copies a rectangle of pixels from the current WebGLFramebuffer into a texture image.
func (c *Context) CopyTexImage2D(target, level, internal, x, y, w, h, border int) {
	c.Call("copyTexImage2D", target, level, internal, x, y, w, h, border)
}

// Replaces a portion of an existing 2D texture image with data from the current framebuffer.
func (c *Context) CopyTexSubImage2D(target, level, xoffset, yoffset, x, y, w, h int) {
	c.Call("copyTexSubImage2D", target, level, xoffset, yoffset, x, y, w, h)
}

// Creates and initializes a WebGLBuffer.
func (c *Context) CreateBuffer() js.Value {
	return c.Call("createBuffer")
}

// Returns a WebGLFramebuffer object.
func (c *Context) CreateFramebuffer() js.Value {
	return c.Call("createFramebuffer")
}

// Creates an empty WebGLProgram object to which vector and fragment
// WebGLShader objects can be bound.
func (c *Context) CreateProgram() js.Value {
	return c.Call("createProgram")
}

// Creates and returns a WebGLRenderbuffer object.
func (c *Context) CreateRenderbuffer() js.Value {
	return c.Call("createRenderbuffer")
}

// Returns an empty vertex or fragment shader object based on the type specified.
func (c *Context) CreateShader(typ int) js.Value {
	return c.Call("createShader", typ)
}

// Used to generate a WebGLTexture object to which images can be bound.
func (c *Context) CreateTexture() js.Value {
	return c.Call("createTexture")
}

// Sets whether or not front, back, or both facing facets are able to be culled.
func (c *Context) CullFace(mode int) {
	c.Call("cullFace", mode)
}

// Delete a specific buffer.
func (c *Context) DeleteBuffer(buffer js.Value) {
	c.Call("deleteBuffer", buffer)
}

// Deletes a specific WebGLFramebuffer object. If you delete the
// currently bound framebuffer, the default framebuffer will be bound.
// Deleting a framebuffer detaches all of its attachments.
func (c *Context) DeleteFramebuffer(framebuffer js.Value) {
	c.Call("deleteFramebuffer", framebuffer)
}

// Flags a specific WebGLProgram object for deletion if currently active.
// It will be deleted when it is no longer being used.
// Any shader objects associated with the program will be detached.
// They will be deleted if they were already flagged for deletion.
func (c *Context) DeleteProgram(program js.Value) {
	c.Call("deleteProgram", program)
}

// Deletes the specified renderbuffer object. If the renderbuffer is
// currently bound, it will become unbound. If the renderbuffer is
// attached to the currently bound framebuffer, it is detached.
func (c *Context) DeleteRenderbuffer(renderbuffer js.Value) {
	c.Call("deleteRenderbuffer", renderbuffer)
}

// Deletes a specific shader object.
func (c *Context) DeleteShader(shader js.Value) {
	c.Call("deleteShader", shader)
}

// Deletes a specific texture object.
func (c *Context) DeleteTexture(texture js.Value) {
	c.Call("deleteTexture", texture)
}

// Sets a function to use to compare incoming pixel depth to the
// current depth buffer value.
func (c *Context) DepthFunc(fun int) {
	c.Call("depthFunc", fun)
}

// Sets whether or not you can write to the depth buffer.
func (c *Context) DepthMask(flag bool) {
	c.Call("depthMask", flag)
}

// Sets the depth range for normalized coordinates to canvas or viewport depth coordinates.
func (c *Context) DepthRange(zNear, zFar float64) {
	c.Call("depthRange", zNear, zFar)
}

// Detach a shader object from a program object.
func (c *Context) DetachShader(program, shader js.Value) {
	c.Call("detachShader", program, shader)
}

// Turns off specific WebGL capabilities for this context.
func (c *Context) Disable(cap int) {
	c.Call("disable", cap)
}

// Turns off a vertex attribute array at a specific index position.
func (c *Context) DisableVertexAttribArray(index int) {
	c.Call("disableVertexAttribArray", index)
}

// Render geometric primitives from bound and enabled vertex data.
func (c *Context) DrawArrays(mode, first, count int) {
	c.Call("drawArrays", mode, first, count)
}

// Renders geometric primitives indexed by element array data.
func (c *Context) DrawElements(mode, count, typ, offset int) {
	c.Call("drawElements", mode, count, typ, offset)
}

// Turns on specific WebGL capabilities for this context.
func (c *Context) Enable(cap int) {
	c.Call("enable", cap)
}

// Turns on a vertex attribute at a specific index position in
// a vertex attribute array.
func (c *Context) EnableVertexAttribArray(index int) {
	c.Call("enableVertexAttribArray", index)
}

func (c *Context) Finish() {
	c.Call("finish")
}

func (c *Context) Flush() {
	c.Call("flush")
}

// Attaches a WebGLRenderbuffer object as a logical buffer to the
// currently bound WebGLFramebuffer object.
func (c *Context) FrameBufferRenderBuffer(target, attachment, renderbufferTarget int, renderbuffer js.Value) {
	c.Call("framebufferRenderBuffer", target, attachment, renderbufferTarget, renderbuffer)
}

// Attaches a texture to a WebGLFramebuffer object.
func (c *Context) FramebufferTexture2D(target, attachment, textarget int, texture js.Value, level int) {
	c.Call("framebufferTexture2D", target, attachment, textarget, texture, level)
}

// Sets whether or not polygons are considered front-facing based
// on their winding direction.
func (c *Context) FrontFace(mode int) {
	c.Call("frontFace", mode)
}

// Creates a set of textures for a WebGLTexture object with image
// dimensions from the original size of the image down to a 1x1 image.
func (c *Context) GenerateMipmap(target int) {
	c.Call("generateMipmap", target)
}

// Returns an WebGLActiveInfo object containing the size, type, and name
// of a vertex attribute at a specific index position in a program object.
func (c *Context) GetActiveAttrib(program js.Value, index int) js.Value {
	return c.Call("getActiveAttrib", program, index)
}

// Returns an WebGLActiveInfo object containing the size, type, and name
// of a uniform attribute at a specific index position in a program object.
func (c *Context) GetActiveUniform(program js.Value, index int) js.Value {
	return c.Call("getActiveUniform", program, index)
}

// Returns a slice of WebGLShaders bound to a WebGLProgram.
func (c *Context) GetAttachedShaders(program js.Value) []js.Value {
	objs := c.Call("getAttachedShaders", program)
	shaders := make([]js.Value, objs.Length())
	for i := 0; i < objs.Length(); i++ {
		shaders[i] = objs.Index(i)
	}
	return shaders
}

// Returns an index to the location in a program of a named attribute variable.
func (c *Context) GetAttribLocation(program js.Value, name string) int {
	return c.Call("getAttribLocation", program, name).Int()
}

// TODO: Create type specific variations.
// Returns the type of a parameter for a given buffer.
func (c *Context) GetBufferParameter(target, pname int) js.Value {
	return c.Call("getBufferParameter", target, pname)
}

// TODO: Create type specific variations.
// Returns the natural type value for a constant parameter.
func (c *Context) GetParameter(pname int) js.Value {
	return c.Call("getParameter", pname)
}

// Returns a value for the WebGL error flag and clears the flag.
func (c *Context) GetError() int {
	return c.Call("getError").Int()
}

// TODO: Create type specific variations.
// Enables a passed extension, otherwise returns null.
func (c *Context) GetExtension(name string) js.Value {
	return c.Call("getExtension", name)
}

// TODO: Create type specific variations.
// Gets a parameter value for a given target and attachment.
func (c *Context) GetFramebufferAttachmentParameter(target, attachment, pname int) js.Value {
	return c.Call("getFramebufferAttachmentParameter", target, attachment, pname)
}

// Returns the value of the program parameter that corresponds to a supplied pname
// which is interpreted as an int.
func (c *Context) GetProgramParameteri(program js.Value, pname int) int {
	return c.Call("getProgramParameter", program, pname).Int()
}

// Returns the value of the program parameter that corresponds to a supplied pname
// which is interpreted as a bool.
func (c *Context) GetProgramParameterb(program js.Value, pname int) bool {
	return c.Call("getProgramParameter", program, pname).Bool()
}

// Returns information about the last error that occurred during
// the failed linking or validation of a WebGL program object.
func (c *Context) GetProgramInfoLog(program js.Value) string {
	return c.Call("getProgramInfoLog", program).String()
}

// TODO: Create type specific variations.
// Returns a renderbuffer parameter from the currently bound WebGLRenderbuffer object.
func (c *Context) GetRenderbufferParameter(target, pname int) js.Value {
	return c.Call("getRenderbufferParameter", target, pname)
}

// TODO: Create type specific variations.
// Returns the value of the parameter associated with pname for a shader object.
func (c *Context) GetShaderParameter(shader js.Value, pname int) js.Value {
	return c.Call("getShaderParameter", shader, pname)
}

// Returns the value of the parameter associated with pname for a shader object.
func (c *Context) GetShaderParameterb(shader js.Value, pname int) bool {
	return c.Call("getShaderParameter", shader, pname).Bool()
}

// Returns errors which occur when compiling a shader.
func (c *Context) GetShaderInfoLog(shader js.Value) string {
	return c.Call("getShaderInfoLog", shader).String()
}

// Returns source code string associated with a shader object.
func (c *Context) GetShaderSource(shader js.Value) string {
	return c.Call("getShaderSource", shader).String()
}

// Returns a slice of supported extension strings.
func (c *Context) GetSupportedExtensions() []string {
	ext := c.Call("getSupportedExtensions")
	extensions := make([]string, ext.Length())
	for i := 0; i < ext.Length(); i++ {
		extensions[i] = ext.Index(i).String()
	}
	return extensions
}

// TODO: Create type specific variations.
// Returns the value for a parameter on an active texture unit.
func (c *Context) GetTexParameter(target, pname int) js.Value {
	return c.Call("getTexParameter", target, pname)
}

// TODO: Create type specific variations.
// Gets the uniform value for a specific location in a program.
func (c *Context) GetUniform(program, location js.Value) js.Value {
	return c.Call("getUniform", program, location)
}

// Returns a WebGLUniformLocation object for the location
// of a uniform variable within a WebGLProgram object.
func (c *Context) GetUniformLocation(program js.Value, name string) js.Value {
	return c.Call("getUniformLocation", program, name)
}

// TODO: Create type specific variations.
// Returns data for a particular characteristic of a vertex
// attribute at an index in a vertex attribute array.
func (c *Context) GetVertexAttrib(index, pname int) js.Value {
	return c.Call("getVertexAttrib", index, pname)
}

// Returns the address of a specified vertex attribute.
func (c *Context) GetVertexAttribOffset(index, pname int) int {
	return c.Call("getVertexAttribOffset", index, pname).Int()
}

// public function hint(target:GLenum, mode:GLenum) : Void;

// Returns true if buffer is valid, false otherwise.
func (c *Context) IsBuffer(buffer js.Value) bool {
	return c.Call("isBuffer", buffer).Bool()
}

// Returns whether the WebGL context has been lost.
func (c *Context) IsContextLost() bool {
	return c.Call("isContextLost").Bool()
}

// Returns true if buffer is valid, false otherwise.
func (c *Context) IsFramebuffer(framebuffer js.Value) bool {
	return c.Call("isFramebuffer", framebuffer).Bool()
}

// Returns true if program object is valid, false otherwise.
func (c *Context) IsProgram(program js.Value) bool {
	return c.Call("isProgram", program).Bool()
}

// Returns true if buffer is valid, false otherwise.
func (c *Context) IsRenderbuffer(renderbuffer js.Value) bool {
	return c.Call("isRenderbuffer", renderbuffer).Bool()
}

// Returns true if shader is valid, false otherwise.
func (c *Context) IsShader(shader js.Value) bool {
	return c.Call("isShader", shader).Bool()
}

// Returns true if texture is valid, false otherwise.
func (c *Context) IsTexture(texture js.Value) bool {
	return c.Call("isTexture", texture).Bool()
}

// Returns whether or not a WebGL capability is enabled for this context.
func (c *Context) IsEnabled(capability int) bool {
	return c.Call("isEnabled", capability).Bool()
}

// Sets the width of lines in WebGL.
func (c *Context) LineWidth(width float64) {
	c.Call("lineWidth", width)
}

// Links an attached vertex shader and an attached fragment shader
// to a program so it can be used by the graphics processing unit (GPU).
func (c *Context) LinkProgram(program js.Value) {
	c.Call("linkProgram", program)
}

// Sets pixel storage modes for readPixels and unpacking of textures
// with texImage2D and texSubImage2D.
func (c *Context) PixelStorei(pname, param int) {
	c.Call("pixelStorei", pname, param)
}

// Sets the implementation-specific units and scale factor
// used to calculate fragment depth values.
func (c *Context) PolygonOffset(factor, units float64) {
	c.Call("polygonOffset", factor, units)
}

// TODO: Figure out if pixels should be a slice.
// Reads pixel data into an ArrayBufferView object from a
// rectangular area in the color buffer of the active frame buffer.
func (c *Context) ReadPixels(x, y, width, height, format, typ int, pixels js.Value) {
	c.Call("readPixels", x, y, width, height, format, typ, pixels)
}

// Creates or replaces the data store for the currently bound WebGLRenderbuffer object.
func (c *Context) RenderbufferStorage(target, internalFormat, width, height int) {
	c.Call("renderbufferStorage", target, internalFormat, width, height)
}

//func (c *Context) SampleCoverage(value float64, invert bool) {
//	c.Call("sampleCoverage", value, invert)
//}

// Sets the dimensions of the scissor box.
func (c *Context) Scissor(x, y, width, height int) {
	c.Call("scissor", x, y, width, height)
}

// Sets and replaces shader source code in a shader object.
func (c *Context) ShaderSource(shader js.Value, source string) {
	c.Call("shaderSource", shader, source)
}

// public function stencilFunc(func:GLenum, ref:GLint, mask:GLuint) : Void;
// public function stencilFuncSeparate(face:GLenum, func:GLenum, ref:GLint, mask:GLuint) : Void;
// public function stencilMask(mask:GLuint) : Void;
// public function stencilMaskSeparate(face:GLenum, mask:GLuint) : Void;
// public function stencilOp(fail:GLenum, zfail:GLenum, zpass:GLenum) : Void;
// public function stencilOpSeparate(face:GLenum, fail:GLenum, zfail:GLenum, zpass:GLenum) : Void;

// Loads the supplied pixel data into a texture.
func (c *Context) TexImage2D(target, level, internalFormat, width, height, border, format, kind int, image interface{}) {
	c.Call("texImage2D", target, level, internalFormat, width, height, border, format, kind, image)
}

// Sets texture parameters for the current texture unit.
func (c *Context) TexParameteri(target int, pname int, param int) {
	c.Call("texParameteri", target, pname, param)
}

// Replaces a portion of an existing 2D texture image with all of another image.
func (c *Context) TexSubImage2D(target, level, xoffset, yoffset, format, typ int, image interface{}) {
	c.Call("texSubImage2D", target, level, xoffset, yoffset, format, typ, image)
}

// Assigns a floating point value to a uniform variable for the current program object.
func (c *Context) Uniform1f(location js.Value, x float32) {
	c.Call("uniform1f", location, x)
}

// Assigns a integer value to a uniform variable for the current program object.
func (c *Context) Uniform1i(location js.Value, x int) {
	c.Call("uniform1i", location, x)
}

// Assigns 2 floating point values to a uniform variable for the current program object.
func (c *Context) Uniform2f(location js.Value, x, y float32) {
	c.Call("uniform2f", location, x, y)
}

// Assigns 2 integer values to a uniform variable for the current program object.
func (c *Context) Uniform2i(location js.Value, x, y int) {
	c.Call("uniform2i", location, x, y)
}

// Assigns 3 floating point values to a uniform variable for the current program object.
func (c *Context) Uniform3f(location js.Value, x, y, z float32) {
	c.Call("uniform3f", location, x, y, z)
}

// Assigns 3 integer values to a uniform variable for the current program object.
func (c *Context) Uniform3i(location js.Value, x, y, z int) {
	c.Call("uniform3i", location, x, y, z)
}

// Assigns 4 floating point values to a uniform variable for the current program object.
func (c *Context) Uniform4f(location js.Value, x, y, z, w float32) {
	c.Call("uniform4f", location, x, y, z, w)
}

// Assigns 4 integer values to a uniform variable for the current program object.
func (c *Context) Uniform4i(location js.Value, x, y, z, w int) {
	c.Call("uniform4i", location, x, y, z, w)
}

// Assigns a floating point value to a uniform variable for the current program object.
func (c *Context) Uniform1fv(location js.Value, src js.TypedArray) {
	c.Call("uniform1fv", location, src)
}

// Assigns a integer value to a uniform variable for the current program object.
func (c *Context) Uniform1iv(location js.Value, src js.TypedArray) {
	c.Call("uniform1iv", location, src)
}

// Assigns 2 floating point values to a uniform variable for the current program object.
func (c *Context) Uniform2fv(location js.Value, src js.TypedArray) {
	c.Call("uniform2fv", location, src)
}

// Assigns 2 integer values to a uniform variable for the current program object.
func (c *Context) Uniform2iv(location js.Value, src js.TypedArray) {
	c.Call("uniform2iv", location, src)
}

// Assigns 3 floating point values to a uniform variable for the current program object.
func (c *Context) Uniform3fv(location js.Value, src js.TypedArray) {
	c.Call("uniform3fv", location, src)
}

// Assigns 3 integer values to a uniform variable for the current program object.
func (c *Context) Uniform3iv(location js.Value, src js.TypedArray) {
	c.Call("uniform3iv", location, src)
}

// Assigns 4 floating point values to a uniform variable for the current program object.
func (c *Context) Uniform4fv(location js.Value, src js.TypedArray) {
	c.Call("uniform4fv", location, src)
}

// Assigns 4 integer values to a uniform variable for the current program object.
func (c *Context) Uniform4iv(location js.Value, src js.TypedArray) {
	c.Call("uniform4iv", location, src)
}

// Sets values for a 2x2 floating point vector matrix into a
// uniform location as a matrix or a matrix array.
func (c *Context) UniformMatrix2fv(location js.Value, transpose bool, value js.TypedArray) {
	c.Call("uniformMatrix2fv", location, transpose, value)
}

// Sets values for a 3x3 floating point vector matrix into a
// uniform location as a matrix or a matrix array.
func (c *Context) UniformMatrix3fv(location js.Value, transpose bool, value js.TypedArray) {
	c.Call("uniformMatrix3fv", location, transpose, value)
}

// Sets values for a 4x4 floating point vector matrix into a
// uniform location as a matrix or a matrix array.
func (c *Context) UniformMatrix4fv(location js.Value, transpose bool, value js.TypedArray) {
	c.Call("uniformMatrix4fv", location, transpose, value)
}

// Set the program object to use for rendering.
func (c *Context) UseProgram(program js.Value) {
	c.Call("useProgram", program)
}

// Returns whether a given program can run in the current WebGL state.
func (c *Context) ValidateProgram(program js.Value) {
	c.Call("validateProgram", program)
}

func (c *Context) VertexAttribPointer(index, size, typ int, normal bool, stride int, offset int) {
	c.Call("vertexAttribPointer", index, size, typ, normal, stride, offset)
}

// public function vertexAttrib1f(indx:GLuint, x:GLfloat) : Void;
// public function vertexAttrib2f(indx:GLuint, x:GLfloat, y:GLfloat) : Void;
// public function vertexAttrib3f(indx:GLuint, x:GLfloat, y:GLfloat, z:GLfloat) : Void;
// public function vertexAttrib4f(indx:GLuint, x:GLfloat, y:GLfloat, z:GLfloat, w:GLfloat) : Void;
// public function vertexAttrib1fv(indx:GLuint, values:ArrayAccess<Float>) : Void;
// public function vertexAttrib2fv(indx:GLuint, values:ArrayAccess<Float>) : Void;
// public function vertexAttrib3fv(indx:GLuint, values:ArrayAccess<Float>) : Void;
// public function vertexAttrib4fv(indx:GLuint, values:ArrayAccess<Float>) : Void;

// Represents a rectangular viewable area that contains
// the rendering results of the drawing buffer.
func (c *Context) Viewport(x, y, width, height int) {
	c.Call("viewport", x, y, width, height)
}

```