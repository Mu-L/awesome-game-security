Project Path: arc_bit-paper_sakura_i5ch0uzi

Source Tree:

```txt
arc_bit-paper_sakura_i5ch0uzi
├── LICENSE
├── README.md
├── detours
├── halflife
│   ├── GameUI
│   │   ├── IGameConsole.h
│   │   ├── IGameUI.h
│   │   ├── IRunGameEngine.h
│   │   └── IVGuiModuleLoader.h
│   ├── common
│   │   ├── BEAMDEF.H
│   │   ├── CONST.H
│   │   ├── CRC.H
│   │   ├── CVARDEF.H
│   │   ├── DEMO_API.H
│   │   ├── DLIGHT.H
│   │   ├── EXEFUNCS.H
│   │   ├── HLTV.H
│   │   ├── MATHLIB.H
│   │   ├── NETADR.H
│   │   ├── NET_API.H
│   │   ├── NOWIN.H
│   │   ├── PMTRACE.H
│   │   ├── QFONT.H
│   │   ├── R_EFX.H
│   │   ├── Sequence.h
│   │   ├── USERCMD.H
│   │   ├── cl_entity.h
│   │   ├── com_model.h
│   │   ├── com_model_backup.h
│   │   ├── con_nprint.h
│   │   ├── director_cmds.h
│   │   ├── dll_state.h
│   │   ├── engine_launcher_api.h
│   │   ├── entity_state.h
│   │   ├── entity_types.h
│   │   ├── enums.h
│   │   ├── event_api.h
│   │   ├── event_args.h
│   │   ├── event_flags.h
│   │   ├── in_buttons.h
│   │   ├── interface.cpp
│   │   ├── interface.h
│   │   ├── itrackeruser.h
│   │   ├── ivoicetweak.h
│   │   ├── particledef.h
│   │   ├── qlimits.h
│   │   ├── ref_params.h
│   │   ├── screenfade.h
│   │   ├── studio_event.h
│   │   ├── triangleapi.h
│   │   └── weaponinfo.h
│   ├── engine
│   │   ├── ANORMS.H
│   │   ├── APIProxy.h
│   │   ├── BEAMDEF.H
│   │   ├── CDLL_DLL.H
│   │   ├── CDLL_INT2.H
│   │   ├── CL_DLL.H
│   │   ├── CONST.H
│   │   ├── CRC.H
│   │   ├── CUSTOM.H
│   │   ├── CVARDEF.H
│   │   ├── DLIGHT.H
│   │   ├── EDICT.H
│   │   ├── EIFACE.H
│   │   ├── KEYDEFS.H
│   │   ├── PMTRACE.H
│   │   ├── PM_DEFS.H
│   │   ├── PM_INFO.H
│   │   ├── PROGDEFS.H
│   │   ├── PROGS.H
│   │   ├── R_EFX.H
│   │   ├── SHAKE.H
│   │   ├── STUDIO.H
│   │   ├── USERCMD.H
│   │   ├── WRECT.H
│   │   ├── bspfile.h
│   │   ├── cdll_engine_dll.h
│   │   ├── cdll_int.h
│   │   ├── cl_entity.h
│   │   ├── client.h
│   │   ├── common.h
│   │   ├── consistency.h
│   │   ├── customentity.h
│   │   ├── delta_packet.h
│   │   ├── entity_state.h
│   │   ├── entity_types.h
│   │   ├── event.h
│   │   ├── event_args.h
│   │   ├── event_flags.h
│   │   ├── in_buttons.h
│   │   ├── model.h
│   │   ├── modelgen.h
│   │   ├── net.h
│   │   ├── particledef.h
│   │   ├── pm_materials.h
│   │   ├── pm_movevars.h
│   │   ├── r_studioint.h
│   │   ├── sound.h
│   │   ├── spritegn.h
│   │   ├── studio_event.h
│   │   ├── triangleapi.h
│   │   ├── util_vector.h
│   │   └── weaponinfo.h
│   ├── misc
│   │   ├── UTILS.H
│   │   ├── archtypes.h
│   │   ├── netadr.h
│   │   ├── netchan.h
│   │   ├── r_studioint.h
│   │   ├── sprites.cpp
│   │   ├── sprites.h
│   │   └── steamtypes.h
│   ├── parsemsg.cpp
│   ├── parsemsg.h
│   ├── vgui
│   │   ├── VGUI.h
│   │   ├── VGUI_ActionSignal.h
│   │   ├── VGUI_App.h
│   │   ├── VGUI_Bitmap.h
│   │   ├── VGUI_BitmapTGA.h
│   │   ├── VGUI_Border.h
│   │   ├── VGUI_BorderLayout.h
│   │   ├── VGUI_BorderPair.h
│   │   ├── VGUI_BuildGroup.h
│   │   ├── VGUI_Button.h
│   │   ├── VGUI_ButtonController.h
│   │   ├── VGUI_ButtonGroup.h
│   │   ├── VGUI_ChangeSignal.h
│   │   ├── VGUI_CheckButton.h
│   │   ├── VGUI_Color.h
│   │   ├── VGUI_ComboKey.h
│   │   ├── VGUI_ConfigWizard.h
│   │   ├── VGUI_Cursor.h
│   │   ├── VGUI_Dar.h
│   │   ├── VGUI_DataInputStream.h
│   │   ├── VGUI_Desktop.h
│   │   ├── VGUI_DesktopIcon.h
│   │   ├── VGUI_EditPanel.h
│   │   ├── VGUI_EtchedBorder.h
│   │   ├── VGUI_FileInputStream.h
│   │   ├── VGUI_FlowLayout.h
│   │   ├── VGUI_FocusChangeSignal.h
│   │   ├── VGUI_FocusNavGroup.h
│   │   ├── VGUI_Font.h
│   │   ├── VGUI_Frame.h
│   │   ├── VGUI_FrameSignal.h
│   │   ├── VGUI_GridLayout.h
│   │   ├── VGUI_HeaderPanel.h
│   │   ├── VGUI_Image.h
│   │   ├── VGUI_ImagePanel.h
│   │   ├── VGUI_InputSignal.h
│   │   ├── VGUI_InputStream.h
│   │   ├── VGUI_IntChangeSignal.h
│   │   ├── VGUI_IntLabel.h
│   │   ├── VGUI_KeyCode.h
│   │   ├── VGUI_Label.h
│   │   ├── VGUI_Layout.h
│   │   ├── VGUI_LayoutInfo.h
│   │   ├── VGUI_LineBorder.h
│   │   ├── VGUI_ListPanel.h
│   │   ├── VGUI_LoweredBorder.h
│   │   ├── VGUI_Menu.h
│   │   ├── VGUI_MenuItem.h
│   │   ├── VGUI_MenuSeparator.h
│   │   ├── VGUI_MessageBox.h
│   │   ├── VGUI_MiniApp.h
│   │   ├── VGUI_MouseCode.h
│   │   ├── VGUI_Panel.h
│   │   ├── VGUI_Point.h
│   │   ├── VGUI_PopupMenu.h
│   │   ├── VGUI_ProgressBar.h
│   │   ├── VGUI_RadioButton.h
│   │   ├── VGUI_RaisedBorder.h
│   │   ├── VGUI_RepaintSignal.h
│   │   ├── VGUI_Scheme.h
│   │   ├── VGUI_ScrollBar.h
│   │   ├── VGUI_ScrollPanel.h
│   │   ├── VGUI_Slider.h
│   │   ├── VGUI_StackLayout.h
│   │   ├── VGUI_String.h
│   │   ├── VGUI_Surface.h
│   │   ├── VGUI_SurfaceBase.h
│   │   ├── VGUI_SurfaceGL.h
│   │   ├── VGUI_TabPanel.h
│   │   ├── VGUI_TablePanel.h
│   │   ├── VGUI_TaskBar.h
│   │   ├── VGUI_TextEntry.h
│   │   ├── VGUI_TextGrid.h
│   │   ├── VGUI_TextImage.h
│   │   ├── VGUI_TextPanel.h
│   │   ├── VGUI_TickSignal.h
│   │   ├── VGUI_ToggleButton.h
│   │   ├── VGUI_TreeFolder.h
│   │   └── VGUI_WizardPanel.h
│   └── vgui2
│       ├── IEngineVGui.h
│       ├── IHTML.h
│       ├── IPanel.h
│       └── ISurface.h
├── imgui
├── lua
├── luabridge
├── sakura
│   ├── libs
│   │   ├── bass
│   │   │   ├── bass.h
│   │   │   ├── dll.cpp
│   │   │   ├── dll.h
│   │   │   └── dll_image.cpp
│   │   ├── image
│   │   │   ├── image_DXT.cpp
│   │   │   ├── image_DXT.h
│   │   │   ├── image_helper.cpp
│   │   │   ├── image_helper.h
│   │   │   ├── imstb_rectpack.h
│   │   │   ├── imstb_textedit.h
│   │   │   ├── imstb_truetype.h
│   │   │   ├── khrplatform.h
│   │   │   ├── soil.cpp
│   │   │   ├── soil.h
│   │   │   ├── stb_image_aug.cpp
│   │   │   ├── stb_image_aug.h
│   │   │   ├── stbi_DDS_aug.h
│   │   │   └── stbi_DDS_aug_c.h
│   │   ├── lua54.lib
│   │   ├── opengl
│   │   │   ├── gl.h
│   │   │   ├── gl3w.cpp
│   │   │   ├── gl3w.h
│   │   │   ├── glcorearb.h
│   │   │   └── glu.h
│   │   └── xor
│   │       └── xorstr.h
│   ├── loader
│   │   ├── icon.ico
│   │   ├── injector.cpp
│   │   ├── injector.h
│   │   ├── loader.aps
│   │   ├── loader.rc
│   │   ├── loader.user
│   │   ├── loader.vcxproj
│   │   ├── loader.vcxproj.filters
│   │   ├── loader.vcxproj.user
│   │   ├── main.cpp
│   │   ├── menu.cpp
│   │   ├── menu.h
│   │   └── resource.h
│   ├── sakura.vcxproj
│   ├── sakura.vcxproj.filters
│   ├── sakura.vcxproj.user
│   └── source
│       ├── client.cpp
│       ├── client.h
│       ├── config
│       │   ├── cvar.cpp
│       │   └── cvar.hpp
│       ├── features
│       │   ├── aimbot.cpp
│       │   ├── aimbot.h
│       │   ├── hns
│       │   │   ├── bhop.cpp
│       │   │   ├── bhop.h
│       │   │   ├── fastrun.cpp
│       │   │   ├── fastrun.h
│       │   │   ├── groundstrafe.cpp
│       │   │   ├── groundstrafe.h
│       │   │   ├── jumpbug.cpp
│       │   │   ├── jumpbug.h
│       │   │   ├── strafe.cpp
│       │   │   └── strafe.h
│       │   ├── legit
│       │   │   ├── knife.cpp
│       │   │   ├── knife.h
│       │   │   ├── laim.cpp
│       │   │   ├── laim.h
│       │   │   ├── trigger.cpp
│       │   │   └── trigger.h
│       │   ├── lua
│       │   │   ├── luabind.cpp
│       │   │   └── luabind.h
│       │   ├── misc
│       │   │   ├── afk.cpp
│       │   │   ├── afk.h
│       │   │   ├── chatspammer.cpp
│       │   │   ├── chatspammer.h
│       │   │   ├── fakelatency.cpp
│       │   │   ├── fakelatency.h
│       │   │   ├── idhook.cpp
│       │   │   ├── idhook.h
│       │   │   ├── namestealer.cpp
│       │   │   ├── namestealer.h
│       │   │   ├── skipframes.cpp
│       │   │   ├── skipframes.h
│       │   │   ├── snapshot.cpp
│       │   │   ├── snapshot.h
│       │   │   ├── steamid.cpp
│       │   │   └── steamid.h
│       │   ├── rage
│       │   │   ├── antiaim.cpp
│       │   │   ├── antiaim.h
│       │   │   ├── autoroute.cpp
│       │   │   ├── autoroute.h
│       │   │   ├── fakelag.cpp
│       │   │   ├── fakelag.h
│       │   │   ├── norecoil.cpp
│       │   │   ├── norecoil.h
│       │   │   ├── nospread.cpp
│       │   │   ├── nospread.h
│       │   │   ├── raim.cpp
│       │   │   └── raim.h
│       │   ├── sound
│       │   │   ├── killsound.cpp
│       │   │   ├── killsound.h
│       │   │   ├── sound.cpp
│       │   │   ├── sound.h
│       │   │   ├── soundesp.cpp
│       │   │   └── soundesp.h
│       │   └── visuals
│       │       ├── chams
│       │       │   ├── chams.cpp
│       │       │   ├── chams.h
│       │       │   ├── studiomodelrender.cpp
│       │       │   └── studiomodelrender.h
│       │       ├── esp
│       │       │   ├── esp.cpp
│       │       │   ├── esp.h
│       │       │   ├── hitboxes.cpp
│       │       │   ├── hitboxes.h
│       │       │   ├── radar.cpp
│       │       │   ├── radar.h
│       │       │   ├── snaplines.cpp
│       │       │   └── snaplines.h
│       │       ├── light
│       │       │   ├── light.cpp
│       │       │   ├── light.h
│       │       │   ├── studio.cpp
│       │       │   └── studio.h
│       │       ├── local
│       │       │   ├── crosshair.cpp
│       │       │   ├── crosshair.h
│       │       │   ├── fov.cpp
│       │       │   ├── fov.h
│       │       │   ├── removals
│       │       │   │   ├── fade.cpp
│       │       │   │   ├── fade.h
│       │       │   │   ├── hands.cpp
│       │       │   │   ├── hands.h
│       │       │   │   ├── scope.cpp
│       │       │   │   └── scope.h
│       │       │   ├── skins
│       │       │   │   ├── skins.cpp
│       │       │   │   ├── skins.h
│       │       │   │   ├── viewmodel.cpp
│       │       │   │   └── viewmodel.h
│       │       │   ├── thirdperson.cpp
│       │       │   ├── thirdperson.h
│       │       │   ├── tracegrenade.cpp
│       │       │   ├── tracegrenade.h
│       │       │   └── world
│       │       │       ├── bullettrace.cpp
│       │       │       ├── bullettrace.h
│       │       │       ├── deathmark.cpp
│       │       │       ├── deathmark.h
│       │       │       ├── fog.cpp
│       │       │       ├── fog.h
│       │       │       ├── lightmap.cpp
│       │       │       ├── lightmap.h
│       │       │       ├── sky.cpp
│       │       │       └── sky.h
│       │       ├── menu
│       │       │   ├── menu.cpp
│       │       │   ├── menu.h
│       │       │   ├── menu_widgets.cpp
│       │       │   ├── menu_widgets.h
│       │       │   └── tabs
│       │       │       ├── menu_colors_tab.cpp
│       │       │       ├── menu_colors_tab.h
│       │       │       ├── menu_legit_tab.cpp
│       │       │       ├── menu_legit_tab.h
│       │       │       ├── menu_misc_tab.cpp
│       │       │       ├── menu_misc_tab.h
│       │       │       ├── menu_rage_tab.cpp
│       │       │       ├── menu_rage_tab.h
│       │       │       ├── menu_visuals_tab.cpp
│       │       │       └── menu_visuals_tab.h
│       │       └── toasts
│       │           ├── toasts.cpp
│       │           └── toasts.h
│       ├── fonts
│       │   ├── font.h
│       │   ├── icons.h
│       │   └── weapons.h
│       ├── gui
│       │   ├── gui.cpp
│       │   ├── gui.h
│       │   ├── guiwindow.cpp
│       │   ├── guiwindow.h
│       │   ├── guiwindowpop.cpp
│       │   └── guiwindowpop.h
│       ├── helpers
│       │   ├── anim.cpp
│       │   ├── anim.h
│       │   ├── color.cpp
│       │   ├── color.h
│       │   ├── log.cpp
│       │   ├── log.h
│       │   ├── stringfinder.cpp
│       │   ├── stringfinder.h
│       │   ├── strings.cpp
│       │   ├── strings.h
│       │   ├── textures.cpp
│       │   ├── textures.h
│       │   ├── trace.cpp
│       │   ├── trace.h
│       │   ├── weapons.cpp
│       │   └── weapons.h
│       ├── main.cpp
│       ├── offsets
│       │   ├── offset.cpp
│       │   └── offset.h
│       ├── opengl.cpp
│       ├── opengl.h
│       ├── other
│       │   └── smth
│       │       ├── defs.h
│       │       ├── gl3winit.cpp
│       │       ├── gl3winit.h
│       │       ├── interface.cpp
│       │       ├── interface.h
│       │       └── keydefs.h
│       ├── player.cpp
│       ├── player.h
│       ├── sakura_precompiled.cpp
│       ├── usermsg.cpp
│       ├── usermsg.h
│       └── vectors
│           ├── QAngle.cpp
│           ├── QAngle.h
│           ├── Vector.cpp
│           └── Vector.h
├── sakura.sln
└── xorgen-2023

```

`LICENSE`:

```
MIT License

Copyright (c) 2023 rbl-dot

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
<h1 align="center">
  <br>
  <a href="https://github.com/rbl-dot/sakura"><img src="https://i.imgur.com/WFsf63R.png" alt="Sakura" width="200"></a>
  <br>
  Sakura
  <br>
</h1>

<div align="center">
  <img src="https://img.shields.io/badge/License-MIT-green">
  <img src="https://img.shields.io/badge/Language-C%2B%2B-red">
</div>

<h4 align="center">Sakura is a free and public cheat for Counter-Strike 1.6 written in <b>C++</b>.</h4>

<p align="center">
  <a href="#key-features">Key Features</a> •
  <a href="#how-to-use">How To Use</a> •
  <a href="#known-bugs">Known bugs</a> •
  <a href="#to-do">To do</a> •
  <a href="#credits">Credits</a> •
  <a href="#support">Support</a> •
  <a href="#license">License</a>
</p>

![screenshot](https://i.imgur.com/1pD62e6.png)

## Key Features

* Modern and User-Friendly Interface: Sakura features a sleek and intuitive menu interface that is easy to navigate. It provides a seamless user experience and makes it easy to access all the features.
* Customizable Colors: With Sakura, you can customize the menu colors to your liking. This means you can personalize the interface and make it match your own preferences.
* Powerful LUA Scripting: Sakura is built on top of the powerful LUA scripting language, which allows for complex and dynamic interactions. This means you can create custom scripts that automate tasks, enhance functionality, and improve performance. If you need help with scripting, check out our [documentation](https://sakura-9.gitbook.io/sakura/).
* Bypasses: Sakura includes several bypasses that allow you to bypass various anti-cheat systems. These bypasses are constantly updated to ensure that they work with the latest versions of anti-cheat software.

## How To Use

To run this cheat, you'll need [Git](https://git-scm.com) or downloaded source code and installed [Visual Studio](https://visualstudio.microsoft.com/) on your computer and basic knowledge how to compile it. Also for the loader you'll need DirectX SDK from [here](https://www.microsoft.com/en-us/download/details.aspx?id=6812).

It's compilable in Visual Studio 2022 and 2019.

```bash
$ git clone --recurse-submodules https://github.com/rbl-dot/sakura.git
```

## Known bugs

* Fov for Perfect Silent doesn't work.
* CreateBeamPoint is not working from Lua script.
* First snapshot is double taken while using anti screenshot function.

## To-do

* Improve Lua functions.
* Add Save/Load functions for Lua.
* Improve UI customization.
* Fix bugs.

## Credits

- [BloodSharp](https://github.com/BloodSharp)
- [Imgui](https://github.com/ocornut/imgui)
- [Lua](https://www.lua.org/)
- [LuaBridge](https://github.com/vinniefalco/LuaBridge)
- [Detours](https://github.com/microsoft/Detours)

## Support

We welcome contributions to Sakura from anyone, whether you're an experienced developer or just getting started. Here are some ways you can help:

* Make Pull Requests: If you have made changes to the code that you would like to share, consider making a pull request.
* Report Issues: If you encounter any issues or bugs while using Sakura, please report them on our [GitHub repository](https://github.com/rbl-dot/sakura/issues).

## License

Sakura is licensed under the MIT License. See [LICENSE](https://github.com/rbl-dot/sakura/blob/main/LICENSE) for more information.

```

`halflife/GameUI/IGameConsole.h`:

```h
#ifndef IGAMECONSOLE_H
#define IGAMECONSOLE_H
#ifdef _WIN32
#pragma once
#endif

class IGameConsole : public IBaseInterface
{
public:
	virtual void Activate(void) = 0;
	virtual void Initialize(void) = 0;
	virtual void Hide(void) = 0;
	virtual void Clear(void) = 0;
	virtual bool IsConsoleVisible(void) = 0;
	virtual void Printf(const char *format, ...) = 0;
	virtual void DPrintf(const char *format, ...) = 0;
	virtual void SetParent(int parent) = 0;
};

extern IGameConsole* g_pConsole;

#define GAMECONSOLE_INTERFACE_VERSION "GameConsole003"
#endif
```

`halflife/GameUI/IGameUI.h`:

```h
#ifndef IGAMEUI_H
#define IGAMEUI_H

#ifdef _WIN32
#pragma once
#endif

class IGameUI : public IBaseInterface
{
public:
	virtual void Initialize(CreateInterfaceFn *factories, int count) = 0;
	virtual void Start(struct cl_enginefuncs_s *engineFuncs, int interfaceVersion, void *system) = 0;
	virtual void Shutdown(void) = 0;
	virtual int ActivateGameUI(void) = 0;
	virtual int ActivateDemoUI(void) = 0;
	virtual int HasExclusiveInput(void) = 0;
	virtual void RunFrame(void) = 0;
	virtual void ConnectToServer(const char *game, int IP, int port) = 0;
	virtual void DisconnectFromServer(void) = 0;
	virtual void HideGameUI(void) = 0;
	virtual bool IsGameUIActive(void) = 0;
	virtual void LoadingStarted(const char *resourceType, const char *resourceName) = 0;
	virtual void LoadingFinished(const char *resourceType, const char *resourceName) = 0;
	virtual void StartProgressBar(const char *progressType, int progressSteps) = 0;
	virtual int ContinueProgressBar(int progressPoint, float progressFraction) = 0;
	virtual void StopProgressBar(bool bError, const char *failureReason, const char *extendedReason = NULL) = 0;
	virtual int SetProgressBarStatusText(const char *statusText) = 0;
	virtual void SetSecondaryProgressBar(float progress) = 0;
	virtual void SetSecondaryProgressBarText(const char *statusText) = 0;
};

extern IGameUI* g_pGameUI;

#define GAMEUI_INTERFACE_VERSION "GameUI007"
#endif
```

`halflife/GameUI/IRunGameEngine.h`:

```h
#ifndef IRUNGAMEENGINE_H
#define IRUNGAMEENGINE_H
#ifdef _WIN32
#pragma once
#endif

//-----------------------------------------------------------------------------
// Purpose: Interface to running the game engine
//-----------------------------------------------------------------------------
class IRunGameEngine : public IBaseInterface
{
public:
	// Returns true if the engine is running, false otherwise.
	virtual bool IsRunning() = 0;

	// Adds text to the engine command buffer. Only works if IsRunning()
	// returns true on success, false on failure
	virtual bool AddTextCommand( const char *text ) = 0;

	// runs the engine with the specified command line parameters.  Only works if !IsRunning()
	// returns true on success, false on failure
	virtual bool RunEngine( const char *gameDir , const char *commandLineParams ) = 0;

	// returns true if the player is currently connected to a game server
	virtual bool IsInGame() = 0;

	// gets information about the server the engine is currently connected to
	// returns true on success, false on failure
	virtual bool GetGameInfo( char *infoBuffer , int bufferSize ) = 0;

	// tells the engine our userID
	virtual void SetTrackerUserID( int trackerID , const char *trackerName ) = 0;

	// this next section could probably moved to another interface
	// iterates users
	// returns the number of user
	virtual int GetPlayerCount() = 0;

	// returns a playerID for a player
	// playerIndex is in the range [0, GetPlayerCount)
	virtual unsigned int GetPlayerFriendsID( int playerIndex ) = 0;

	// gets the in-game name of another user, returns NULL if that user doesn't exists
	virtual const char *GetPlayerName( int friendsID ) = 0;

	// gets the friends name of a player
	virtual const char *GetPlayerFriendsName( int friendsID ) = 0;

	// returns the engine build number and mod version string for server versioning
	virtual unsigned int GetEngineBuildNumber() = 0;
	virtual const char *GetProductVersionString() = 0;
	virtual unsigned int GetPlayerUserID( int friendsID ) = 0;
};

extern IRunGameEngine* g_pIRunGameEngine;

#define RUNGAMEENGINE_INTERFACE_VERSION "RunGameEngine006"
#endif
```

`halflife/GameUI/IVGuiModuleLoader.h`:

```h
//========= Copyright ?1996-2005, Valve Corporation, All rights reserved. ============//
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================//

#ifndef IVGUIMODULELOADER_H
#define IVGUIMODULELOADER_H
#ifdef _WIN32
#pragma once
#endif

//-----------------------------------------------------------------------------
// Purpose: interface to accessing all loaded modules
//-----------------------------------------------------------------------------
class IVGuiModuleLoader : public IBaseInterface
{
public:
	virtual int GetModuleCount() = 0;
	virtual const char *GetModuleLabel(int moduleIndex) = 0;
	virtual CreateInterfaceFn GetModuleFactory(int moduleIndex) = 0;
	virtual bool ActivateModule(int moduleIndex) = 0;
	virtual bool ActivateModule(const char *moduleName) = 0;
	virtual void SetPlatformToRestart() = 0;
};

extern IVGuiModuleLoader* g_pIVGuiModuleLoader;

#define VGUIMODULELOADER_INTERFACE_VERSION "VGuiModuleLoader003"
#endif
```

`halflife/common/BEAMDEF.H`:

```H
/***
*
*	Copyright (c) 1999, 2000, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined ( BEAMDEFH )
#define BEAMDEFH
#ifdef _WIN32
#pragma once
#endif

#define FBEAM_STARTENTITY		0x00000001
#define FBEAM_ENDENTITY			0x00000002
#define FBEAM_FADEIN			0x00000004
#define FBEAM_FADEOUT			0x00000008
#define FBEAM_SINENOISE			0x00000010
#define FBEAM_SOLID				0x00000020
#define FBEAM_SHADEIN			0x00000040
#define FBEAM_SHADEOUT			0x00000080
#define FBEAM_STARTVISIBLE		0x10000000		// Has this client actually seen this beam's start entity yet?
#define FBEAM_ENDVISIBLE		0x20000000		// Has this client actually seen this beam's end entity yet?
#define FBEAM_ISACTIVE			0x40000000
#define FBEAM_FOREVER			0x80000000

typedef struct beam_s BEAM;
struct beam_s
{
	BEAM		*next;
	int			type;
	int			flags;
	vec3_t		source;
	vec3_t		target;
	vec3_t		delta;
	float		t;		// 0 .. 1 over lifetime of beam
	float		freq;
	float		die;
	float		width;
	float		amplitude;
	float		r, g, b;
	float		brightness;
	float		speed;
	float		frameRate;
	float		frame;
	int			segments;
	int			startEntity;
	int			endEntity;
	int			modelIndex;
	int			frameCount;
	struct model_s		*pFollowModel;
	struct particle_s	*particles;
};

#endif

```

`halflife/common/CONST.H`:

```H
/***
*
*	Copyright (c) 1999, 2000, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef CONST_H
#define CONST_H
//
// Constants shared by the engine and dlls
// This header file included by engine files and DLL files.
// Most came from server.h

// edict->flags
#define	FL_FLY					(1<<0)	// Changes the SV_Movestep() behavior to not need to be on ground
#define	FL_SWIM					(1<<1)	// Changes the SV_Movestep() behavior to not need to be on ground (but stay in water)
#define	FL_CONVEYOR				(1<<2)
#define	FL_CLIENT				(1<<3)
#define	FL_INWATER				(1<<4)
#define	FL_MONSTER				(1<<5)
#define	FL_GODMODE				(1<<6)
#define	FL_NOTARGET				(1<<7)
#define	FL_SKIPLOCALHOST		(1<<8)	// Don't send entity to local host, it's predicting this entity itself
#define	FL_ONGROUND				(1<<9)	// At rest / on the ground
#define	FL_PARTIALGROUND		(1<<10)	// not all corners are valid
#define	FL_WATERJUMP			(1<<11)	// player jumping out of water
#define FL_FROZEN				(1<<12) // Player is frozen for 3rd person camera
#define FL_FAKECLIENT			(1<<13)	// JAC: fake client, simulated server side; don't send network messages to them
#define FL_DUCKING				(1<<14)	// Player flag -- Player is fully crouched
#define FL_FLOAT				(1<<15)	// Apply floating force to this entity when in water
#define FL_GRAPHED				(1<<16) // worldgraph has this ent listed as something that blocks a connection

// UNDONE: Do we need these?
#define FL_IMMUNE_WATER			(1<<17)
#define	FL_IMMUNE_SLIME			(1<<18)
#define FL_IMMUNE_LAVA			(1<<19)

#define FL_PROXY				(1<<20)	// This is a spectator proxy
#define FL_ALWAYSTHINK			(1<<21)	// Brush model flag -- call think every frame regardless of nextthink - ltime (for constantly changing velocity/path)
#define FL_BASEVELOCITY			(1<<22)	// Base velocity has been applied this frame (used to convert base velocity into momentum)
#define FL_MONSTERCLIP			(1<<23)	// Only collide in with monsters who have FL_MONSTERCLIP set
#define FL_ONTRAIN				(1<<24) // Player is _controlling_ a train, so movement commands should be ignored on client during prediction.
#define FL_WORLDBRUSH			(1<<25)	// Not moveable/removeable brush entity (really part of the world, but represented as an entity for transparency or something)
#define FL_SPECTATOR            (1<<26) // This client is a spectator, don't run touch functions, etc.
#define FL_CUSTOMENTITY			(1<<29)	// This is a custom entity
#define FL_KILLME				(1<<30)	// This entity is marked for death -- This allows the engine to kill ents at the appropriate time
#define FL_DORMANT				(1<<31)	// Entity is dormant, no updates to client


// Goes into globalvars_t.trace_flags
#define FTRACE_SIMPLEBOX		(1<<0)	// Traceline with a simple box


// walkmove modes
#define	WALKMOVE_NORMAL		0 // normal walkmove
#define WALKMOVE_WORLDONLY	1 // doesn't hit ANY entities, no matter what the solid type
#define WALKMOVE_CHECKONLY	2 // move, but don't touch triggers

// edict->movetype values
#define	MOVETYPE_NONE			0		// never moves
//#define	MOVETYPE_ANGLENOCLIP	1
//#define	MOVETYPE_ANGLECLIP		2
#define	MOVETYPE_WALK			3		// Player only - moving on the ground
#define	MOVETYPE_STEP			4		// gravity, special edge handling -- monsters use this
#define	MOVETYPE_FLY			5		// No gravity, but still collides with stuff
#define	MOVETYPE_TOSS			6		// gravity/collisions
#define	MOVETYPE_PUSH			7		// no clip to world, push and crush
#define	MOVETYPE_NOCLIP			8		// No gravity, no collisions, still do velocity/avelocity
#define	MOVETYPE_FLYMISSILE		9		// extra size to monsters
#define	MOVETYPE_BOUNCE			10		// Just like Toss, but reflect velocity when contacting surfaces
#define MOVETYPE_BOUNCEMISSILE	11		// bounce w/o gravity
#define MOVETYPE_FOLLOW			12		// track movement of aiment
#define	MOVETYPE_PUSHSTEP		13		// BSP model that needs physics/world collisions (uses nearest hull for world collision)

// edict->solid values
// NOTE: Some movetypes will cause collisions independent of SOLID_NOT/SOLID_TRIGGER when the entity moves
// SOLID only effects OTHER entities colliding with this one when they move - UGH!
#define	SOLID_NOT				0		// no interaction with other objects
#define	SOLID_TRIGGER			1		// touch on edge, but not blocking
#define	SOLID_BBOX				2		// touch on edge, block
#define	SOLID_SLIDEBOX			3		// touch on edge, but not an onground
#define	SOLID_BSP				4		// bsp clip, touch on edge, block

// edict->deadflag values
#define	DEAD_NO					0 // alive
#define	DEAD_DYING				1 // playing death animation or still falling off of a ledge waiting to hit ground
#define	DEAD_DEAD				2 // dead. lying still.
#define DEAD_RESPAWNABLE		3
#define DEAD_DISCARDBODY		4

#define	DAMAGE_NO				0
#define	DAMAGE_YES				1
#define	DAMAGE_AIM				2

// entity effects
#define	EF_BRIGHTFIELD			1	// swirling cloud of particles
#define	EF_MUZZLEFLASH 			2	// single frame ELIGHT on entity attachment 0
#define	EF_BRIGHTLIGHT 			4	// DLIGHT centered at entity origin
#define	EF_DIMLIGHT 			8	// player flashlight
#define EF_INVLIGHT				16	// get lighting from ceiling
#define EF_NOINTERP				32	// don't interpolate the next frame
#define EF_LIGHT				64	// rocket flare glow sprite
#define EF_NODRAW				128	// don't draw entity

// entity flags
#define EFLAG_SLERP				1	// do studio interpolation of this entity
		
//
// temp entity events
//
#define	TE_BEAMPOINTS		0		// beam effect between two points
// coord coord coord (start position) 
// coord coord coord (end position) 
// short (sprite index) 
// byte (starting frame) 
// byte (frame rate in 0.1's) 
// byte (life in 0.1's) 
// byte (line width in 0.1's) 
// byte (noise amplitude in 0.01's) 
// byte,byte,byte (color)
// byte (brightness)
// byte (scroll speed in 0.1's)

#define	TE_BEAMENTPOINT		1		// beam effect between point and entity
// short (start entity) 
// coord coord coord (end position) 
// short (sprite index) 
// byte (starting frame) 
// byte (frame rate in 0.1's) 
// byte (life in 0.1's) 
// byte (line width in 0.1's) 
// byte (noise amplitude in 0.01's) 
// byte,byte,byte (color)
// byte (brightness)
// byte (scroll speed in 0.1's)

#define	TE_GUNSHOT			2		// particle effect plus ricochet sound
// coord coord coord (position) 

#define	TE_EXPLOSION		3		// additive sprite, 2 dynamic lights, flickering particles, explosion sound, move vertically 8 pps
// coord coord coord (position) 
// short (sprite index)
// byte (scale in 0.1's)
// byte (framerate)
// byte (flags)
//
// The Explosion effect has some flags to control performance/aesthetic features:
#define TE_EXPLFLAG_NONE		0	// all flags clear makes default Half-Life explosion
#define TE_EXPLFLAG_NOADDITIVE	1	// sprite will be drawn opaque (ensure that the sprite you send is a non-additive sprite)
#define TE_EXPLFLAG_NODLIGHTS	2	// do not render dynamic lights
#define TE_EXPLFLAG_NOSOUND		4	// do not play client explosion sound
#define TE_EXPLFLAG_NOPARTICLES	8	// do not draw particles


#define	TE_TAREXPLOSION		4		// Quake1 "tarbaby" explosion with sound
// coord coord coord (position) 

#define	TE_SMOKE			5		// alphablend sprite, move vertically 30 pps
// coord coord coord (position) 
// short (sprite index)
// byte (scale in 0.1's)
// byte (framerate)

#define	TE_TRACER			6		// tracer effect from point to point
// coord, coord, coord (start) 
// coord, coord, coord (end)

#define	TE_LIGHTNING		7		// TE_BEAMPOINTS with simplified parameters
// coord, coord, coord (start) 
// coord, coord, coord (end) 
// byte (life in 0.1's) 
// byte (width in 0.1's) 
// byte (amplitude in 0.01's)
// short (sprite model index)

#define	TE_BEAMENTS			8		
// short (start entity) 
// short (end entity) 
// short (sprite index) 
// byte (starting frame) 
// byte (frame rate in 0.1's) 
// byte (life in 0.1's) 
// byte (line width in 0.1's) 
// byte (noise amplitude in 0.01's) 
// byte,byte,byte (color)
// byte (brightness)
// byte (scroll speed in 0.1's)

#define	TE_SPARKS			9		// 8 random tracers with gravity, ricochet sprite
// coord coord coord (position) 

#define	TE_LAVASPLASH		10		// Quake1 lava splash
// coord coord coord (position) 

#define	TE_TELEPORT			11		// Quake1 teleport splash
// coord coord coord (position) 

#define TE_EXPLOSION2		12		// Quake1 colormaped (base palette) particle explosion with sound
// coord coord coord (position) 
// byte (starting color)
// byte (num colors)

#define TE_BSPDECAL			13		// Decal from the .BSP file 
// coord, coord, coord (x,y,z), decal position (center of texture in world)
// short (texture index of precached decal texture name)
// short (entity index)
// [optional - only included if previous short is non-zero (not the world)] short (index of model of above entity)

#define TE_IMPLOSION		14		// tracers moving toward a point
// coord, coord, coord (position)
// byte (radius)
// byte (count)
// byte (life in 0.1's) 

#define TE_SPRITETRAIL		15		// line of moving glow sprites with gravity, fadeout, and collisions
// coord, coord, coord (start) 
// coord, coord, coord (end) 
// short (sprite index)
// byte (count)
// byte (life in 0.1's) 
// byte (scale in 0.1's) 
// byte (velocity along vector in 10's)
// byte (randomness of velocity in 10's)

#define TE_BEAM				16		// obsolete

#define TE_SPRITE			17		// additive sprite, plays 1 cycle
// coord, coord, coord (position) 
// short (sprite index) 
// byte (scale in 0.1's) 
// byte (brightness)

#define TE_BEAMSPRITE		18		// A beam with a sprite at the end
// coord, coord, coord (start position) 
// coord, coord, coord (end position) 
// short (beam sprite index) 
// short (end sprite index) 

#define TE_BEAMTORUS		19		// screen aligned beam ring, expands to max radius over lifetime
// coord coord coord (center position) 
// coord coord coord (axis and radius) 
// short (sprite index) 
// byte (starting frame) 
// byte (frame rate in 0.1's) 
// byte (life in 0.1's) 
// byte (line width in 0.1's) 
// byte (noise amplitude in 0.01's) 
// byte,byte,byte (color)
// byte (brightness)
// byte (scroll speed in 0.1's)

#define TE_BEAMDISK			20		// disk that expands to max radius over lifetime
// coord coord coord (center position) 
// coord coord coord (axis and radius) 
// short (sprite index) 
// byte (starting frame) 
// byte (frame rate in 0.1's) 
// byte (life in 0.1's) 
// byte (line width in 0.1's) 
// byte (noise amplitude in 0.01's) 
// byte,byte,byte (color)
// byte (brightness)
// byte (scroll speed in 0.1's)

#define TE_BEAMCYLINDER		21		// cylinder that expands to max radius over lifetime
// coord coord coord (center position) 
// coord coord coord (axis and radius) 
// short (sprite index) 
// byte (starting frame) 
// byte (frame rate in 0.1's) 
// byte (life in 0.1's) 
// byte (line width in 0.1's) 
// byte (noise amplitude in 0.01's) 
// byte,byte,byte (color)
// byte (brightness)
// byte (scroll speed in 0.1's)

#define TE_BEAMFOLLOW		22		// create a line of decaying beam segments until entity stops moving
// short (entity:attachment to follow)
// short (sprite index)
// byte (life in 0.1's) 
// byte (line width in 0.1's) 
// byte,byte,byte (color)
// byte (brightness)

#define TE_GLOWSPRITE		23		
// coord, coord, coord (pos) short (model index) byte (scale / 10)

#define TE_BEAMRING			24		// connect a beam ring to two entities
// short (start entity) 
// short (end entity) 
// short (sprite index) 
// byte (starting frame) 
// byte (frame rate in 0.1's) 
// byte (life in 0.1's) 
// byte (line width in 0.1's) 
// byte (noise amplitude in 0.01's) 
// byte,byte,byte (color)
// byte (brightness)
// byte (scroll speed in 0.1's)

#define TE_STREAK_SPLASH	25		// oriented shower of tracers
// coord coord coord (start position) 
// coord coord coord (direction vector) 
// byte (color)
// short (count)
// short (base speed)
// short (ramdon velocity)

#define TE_BEAMHOSE			26		// obsolete

#define TE_DLIGHT			27		// dynamic light, effect world, minor entity effect
// coord, coord, coord (pos) 
// byte (radius in 10's) 
// byte byte byte (color)
// byte (brightness)
// byte (life in 10's)
// byte (decay rate in 10's)

#define TE_ELIGHT			28		// point entity light, no world effect
// short (entity:attachment to follow)
// coord coord coord (initial position) 
// coord (radius)
// byte byte byte (color)
// byte (life in 0.1's)
// coord (decay rate)

#define TE_TEXTMESSAGE		29
// short 1.2.13 x (-1 = center)
// short 1.2.13 y (-1 = center)
// byte Effect 0 = fade in/fade out
			// 1 is flickery credits
			// 2 is write out (training room)

// 4 bytes r,g,b,a color1	(text color)
// 4 bytes r,g,b,a color2	(effect color)
// ushort 8.8 fadein time
// ushort 8.8  fadeout time
// ushort 8.8 hold time
// optional ushort 8.8 fxtime	(time the highlight lags behing the leading text in effect 2)
// string text message		(512 chars max sz string)
#define TE_LINE				30
// coord, coord, coord		startpos
// coord, coord, coord		endpos
// short life in 0.1 s
// 3 bytes r, g, b

#define TE_BOX				31
// coord, coord, coord		boxmins
// coord, coord, coord		boxmaxs
// short life in 0.1 s
// 3 bytes r, g, b

#define TE_KILLBEAM			99		// kill all beams attached to entity
// short (entity)

#define TE_LARGEFUNNEL		100
// coord coord coord (funnel position)
// short (sprite index) 
// short (flags) 

#define	TE_BLOODSTREAM		101		// particle spray
// coord coord coord (start position)
// coord coord coord (spray vector)
// byte (color)
// byte (speed)

#define	TE_SHOWLINE			102		// line of particles every 5 units, dies in 30 seconds
// coord coord coord (start position)
// coord coord coord (end position)

#define TE_BLOOD			103		// particle spray
// coord coord coord (start position)
// coord coord coord (spray vector)
// byte (color)
// byte (speed)

#define TE_DECAL			104		// Decal applied to a brush entity (not the world)
// coord, coord, coord (x,y,z), decal position (center of texture in world)
// byte (texture index of precached decal texture name)
// short (entity index)

#define TE_FIZZ				105		// create alpha sprites inside of entity, float upwards
// short (entity)
// short (sprite index)
// byte (density)

#define TE_MODEL			106		// create a moving model that bounces and makes a sound when it hits
// coord, coord, coord (position) 
// coord, coord, coord (velocity)
// angle (initial yaw)
// short (model index)
// byte (bounce sound type)
// byte (life in 0.1's)

#define TE_EXPLODEMODEL		107		// spherical shower of models, picks from set
// coord, coord, coord (origin)
// coord (velocity)
// short (model index)
// short (count)
// byte (life in 0.1's)

#define TE_BREAKMODEL		108		// box of models or sprites
// coord, coord, coord (position)
// coord, coord, coord (size)
// coord, coord, coord (velocity)
// byte (random velocity in 10's)
// short (sprite or model index)
// byte (count)
// byte (life in 0.1 secs)
// byte (flags)

#define TE_GUNSHOTDECAL		109		// decal and ricochet sound
// coord, coord, coord (position)
// short (entity index???)
// byte (decal???)

#define TE_SPRITE_SPRAY		110		// spay of alpha sprites
// coord, coord, coord (position)
// coord, coord, coord (velocity)
// short (sprite index)
// byte (count)
// byte (speed)
// byte (noise)

#define TE_ARMOR_RICOCHET	111		// quick spark sprite, client ricochet sound. 
// coord, coord, coord (position)
// byte (scale in 0.1's)

#define TE_PLAYERDECAL		112		// ???
// byte (playerindex)
// coord, coord, coord (position)
// short (entity???)
// byte (decal number???)
// [optional] short (model index???)

#define TE_BUBBLES			113		// create alpha sprites inside of box, float upwards
// coord, coord, coord (min start position)
// coord, coord, coord (max start position)
// coord (float height)
// short (model index)
// byte (count)
// coord (speed)

#define TE_BUBBLETRAIL		114		// create alpha sprites along a line, float upwards
// coord, coord, coord (min start position)
// coord, coord, coord (max start position)
// coord (float height)
// short (model index)
// byte (count)
// coord (speed)

#define TE_BLOODSPRITE		115		// spray of opaque sprite1's that fall, single sprite2 for 1..2 secs (this is a high-priority tent)
// coord, coord, coord (position)
// short (sprite1 index)
// short (sprite2 index)
// byte (color)
// byte (scale)

#define TE_WORLDDECAL		116		// Decal applied to the world brush
// coord, coord, coord (x,y,z), decal position (center of texture in world)
// byte (texture index of precached decal texture name)

#define TE_WORLDDECALHIGH	117		// Decal (with texture index > 256) applied to world brush
// coord, coord, coord (x,y,z), decal position (center of texture in world)
// byte (texture index of precached decal texture name - 256)

#define TE_DECALHIGH		118		// Same as TE_DECAL, but the texture index was greater than 256
// coord, coord, coord (x,y,z), decal position (center of texture in world)
// byte (texture index of precached decal texture name - 256)
// short (entity index)

#define TE_PROJECTILE		119		// Makes a projectile (like a nail) (this is a high-priority tent)
// coord, coord, coord (position)
// coord, coord, coord (velocity)
// short (modelindex)
// byte (life)
// byte (owner)  projectile won't collide with owner (if owner == 0, projectile will hit any client).

#define TE_SPRAY			120		// Throws a shower of sprites or models
// coord, coord, coord (position)
// coord, coord, coord (direction)
// short (modelindex)
// byte (count)
// byte (speed)
// byte (noise)
// byte (rendermode)

#define TE_PLAYERSPRITES	121		// sprites emit from a player's bounding box (ONLY use for players!)
// byte (playernum)
// short (sprite modelindex)
// byte (count)
// byte (variance) (0 = no variance in size) (10 = 10% variance in size)

#define TE_PARTICLEBURST	122		// very similar to lavasplash.
// coord (origin)
// short (radius)
// byte (particle color)
// byte (duration * 10) (will be randomized a bit)

#define TE_FIREFIELD			123		// makes a field of fire.
// coord (origin)
// short (radius) (fire is made in a square around origin. -radius, -radius to radius, radius)
// short (modelindex)
// byte (count)
// byte (flags)
// byte (duration (in seconds) * 10) (will be randomized a bit)
//
// to keep network traffic low, this message has associated flags that fit into a byte:
#define TEFIRE_FLAG_ALLFLOAT	1 // all sprites will drift upwards as they animate
#define TEFIRE_FLAG_SOMEFLOAT	2 // some of the sprites will drift upwards. (50% chance)
#define TEFIRE_FLAG_LOOP		4 // if set, sprite plays at 15 fps, otherwise plays at whatever rate stretches the animation over the sprite's duration.
#define TEFIRE_FLAG_ALPHA		8 // if set, sprite is rendered alpha blended at 50% else, opaque
#define TEFIRE_FLAG_PLANAR		16 // if set, all fire sprites have same initial Z instead of randomly filling a cube. 

#define TE_PLAYERATTACHMENT			124 // attaches a TENT to a player (this is a high-priority tent)
// byte (entity index of player)
// coord (vertical offset) ( attachment origin.z = player origin.z + vertical offset )
// short (model index)
// short (life * 10 );

#define TE_KILLPLAYERATTACHMENTS	125 // will expire all TENTS attached to a player.
// byte (entity index of player)

#define TE_MULTIGUNSHOT				126 // much more compact shotgun message
// This message is used to make a client approximate a 'spray' of gunfire.
// Any weapon that fires more than one bullet per frame and fires in a bit of a spread is
// a good candidate for MULTIGUNSHOT use. (shotguns)
//
// NOTE: This effect makes the client do traces for each bullet, these client traces ignore
//		 entities that have studio models.Traces are 4096 long.
//
// coord (origin)
// coord (origin)
// coord (origin)
// coord (direction)
// coord (direction)
// coord (direction)
// coord (x noise * 100)
// coord (y noise * 100)
// byte (count)
// byte (bullethole decal texture index)

#define TE_USERTRACER				127 // larger message than the standard tracer, but allows some customization.
// coord (origin)
// coord (origin)
// coord (origin)
// coord (velocity)
// coord (velocity)
// coord (velocity)
// byte ( life * 10 )
// byte ( color ) this is an index into an array of color vectors in the engine. (0 - )
// byte ( length * 10 )



#define	MSG_BROADCAST		0		// unreliable to all
#define	MSG_ONE				1		// reliable to one (msg_entity)
#define	MSG_ALL				2		// reliable to all
#define	MSG_INIT			3		// write to the init string
#define MSG_PVS				4		// Ents in PVS of org
#define MSG_PAS				5		// Ents in PAS of org
#define MSG_PVS_R			6		// Reliable to PVS
#define MSG_PAS_R			7		// Reliable to PAS
#define MSG_ONE_UNRELIABLE	8		// Send to one client, but don't put in reliable stream, put in unreliable datagram ( could be dropped )
#define	MSG_SPEC			9		// Sends to all spectator proxies

// contents of a spot in the world
#define	CONTENTS_EMPTY		-1
#define	CONTENTS_SOLID		-2
#define	CONTENTS_WATER		-3
#define	CONTENTS_SLIME		-4
#define	CONTENTS_LAVA		-5
#define	CONTENTS_SKY		-6
/* These additional contents constants are defined in bspfile.h
#define	CONTENTS_ORIGIN		-7		// removed at csg time
#define	CONTENTS_CLIP		-8		// changed to contents_solid
#define	CONTENTS_CURRENT_0		-9
#define	CONTENTS_CURRENT_90		-10
#define	CONTENTS_CURRENT_180	-11
#define	CONTENTS_CURRENT_270	-12
#define	CONTENTS_CURRENT_UP		-13
#define	CONTENTS_CURRENT_DOWN	-14

#define CONTENTS_TRANSLUCENT	-15
*/
#define	CONTENTS_LADDER		-16

#define CONTENT_EMPTY	-1
#define CONTENT_SOLID	-2
#define	CONTENT_WATER	-3
#define CONTENT_SLIME	-4
#define CONTENT_LAVA	-5
#define CONTENT_SKY		-6

// channels
#define CHAN_AUTO			0
#define CHAN_WEAPON			1
#define	CHAN_VOICE			2
#define CHAN_ITEM			3
#define	CHAN_BODY			4
#define CHAN_STREAM			5			// allocate stream channel from the static or dynamic area
#define CHAN_STATIC			6			// allocate channel from the static area 
#define CHAN_NETWORKVOICE_BASE	7		// voice data coming across the network
#define CHAN_NETWORKVOICE_END	500		// network voice data reserves slots (CHAN_NETWORKVOICE_BASE through CHAN_NETWORKVOICE_END).

// attenuation values
#define ATTN_NONE		0
#define	ATTN_NORM		(float)0.8
#define ATTN_IDLE		(float)2
#define ATTN_STATIC		(float)1.25 

// pitch values
#define	PITCH_NORM		100			// non-pitch shifted
#define PITCH_LOW		95			// other values are possible - 0-255, where 255 is very high
#define PITCH_HIGH		120

// volume values
#define VOL_NORM		1.0

// plats
#define	PLAT_LOW_TRIGGER	1

// Trains
#define	SF_TRAIN_WAIT_RETRIGGER	1
#define SF_TRAIN_PASSABLE		8		// Train is not solid -- used to make water trains

// buttons
#ifndef IN_BUTTONS_H
#include "in_buttons.h"
#endif

// Break Model Defines

#define BREAK_TYPEMASK	0x4F
#define BREAK_GLASS		0x01
#define BREAK_METAL		0x02
#define BREAK_FLESH		0x04
#define BREAK_WOOD		0x08

#define BREAK_SMOKE		0x10
#define BREAK_TRANS		0x20
#define BREAK_CONCRETE	0x40
#define BREAK_2			0x80

// Colliding temp entity sounds

#define BOUNCE_GLASS	BREAK_GLASS
#define	BOUNCE_METAL	BREAK_METAL
#define BOUNCE_FLESH	BREAK_FLESH
#define BOUNCE_WOOD		BREAK_WOOD
#define BOUNCE_SHRAP	0x10
#define BOUNCE_SHELL	0x20
#define	BOUNCE_CONCRETE BREAK_CONCRETE
#define BOUNCE_SHOTSHELL 0x80

// Temp entity bounce sound types
#define TE_BOUNCE_NULL		0
#define TE_BOUNCE_SHELL		1
#define TE_BOUNCE_SHOTSHELL	2

// Rendering constants
enum 
{	
	kRenderNormal,			// src
	kRenderTransColor,		// c*a+dest*(1-a)
	kRenderTransTexture,	// src*a+dest*(1-a)
	kRenderGlow,			// src*a+dest -- No Z buffer checks
	kRenderTransAlpha,		// src*srca+dest*(1-srca)
	kRenderTransAdd,		// src*a+dest
};

enum 
{	
	kRenderFxNone = 0, 
	kRenderFxPulseSlow, 
	kRenderFxPulseFast, 
	kRenderFxPulseSlowWide, 
	kRenderFxPulseFastWide, 
	kRenderFxFadeSlow, 
	kRenderFxFadeFast, 
	kRenderFxSolidSlow, 
	kRenderFxSolidFast, 	   
	kRenderFxStrobeSlow, 
	kRenderFxStrobeFast, 
	kRenderFxStrobeFaster, 
	kRenderFxFlickerSlow, 
	kRenderFxFlickerFast,
	kRenderFxNoDissipation,
	kRenderFxDistort,			// Distort/scale/translate flicker
	kRenderFxHologram,			// kRenderFxDistort + distance fade
	kRenderFxDeadPlayer,		// kRenderAmt is the player index
	kRenderFxExplode,			// Scale up really big!
	kRenderFxGlowShell,			// Glowing Shell
	kRenderFxClampMinScale,		// Keep this sprite from getting very small (SPRITES only!)
};


typedef int	func_t;
typedef int	string_t;

typedef unsigned char 		byte;
typedef unsigned short 		word;
#define _DEF_BYTE_

#undef true
#undef false

#ifndef __cplusplus
typedef enum {false, true}	qboolean;
#else 
typedef int qboolean;
#endif

typedef struct
{
	byte r, g, b;
} color24;

typedef struct
{
	unsigned r, g, b, a;
} colorVec;

#ifdef _WIN32
#pragma pack(push,2)
#endif

typedef struct
{
	unsigned short r, g, b, a;
} PackedColorVec;

#ifdef _WIN32
#pragma pack(pop)
#endif
typedef struct link_s
{
	struct link_s	*prev, *next;
} link_t;

typedef struct edict_s edict_t;

typedef struct
{
	vec3_t	normal;
	float	dist;
} plane_t;

typedef struct
{
	qboolean	allsolid;	// if true, plane is not valid
	qboolean	startsolid;	// if true, the initial point was in a solid area
	qboolean	inopen, inwater;
	float	fraction;		// time completed, 1.0 = didn't hit anything
	vec3_t	endpos;			// final position
	plane_t	plane;			// surface normal at impact
	edict_t	*ent;			// entity the surface is on
	int		hitgroup;		// 0 == generic, non zero is specific body part
} trace_t;

#endif


```

`halflife/common/CRC.H`:

```H
/***
*
*	Copyright (c) 1999, 2000, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
/* crc.h */
#ifndef CRC_H
#define CRC_H
#ifdef _WIN32
#pragma once
#endif

// MD5 Hash
typedef struct
{
	unsigned int buf[4];
    unsigned int bits[2];
    unsigned char in[64];
} MD5Context_t;


typedef unsigned long CRC32_t;
void CRC32_Init(CRC32_t *pulCRC);
CRC32_t CRC32_Final(CRC32_t pulCRC);
void CRC32_ProcessBuffer(CRC32_t *pulCRC, void *p, int len);
void CRC32_ProcessByte(CRC32_t *pulCRC, unsigned char ch);
int CRC_File(CRC32_t *crcvalue, char *pszFileName);

unsigned char COM_BlockSequenceCRCByte (unsigned char *base, int length, int sequence);

void MD5Init(MD5Context_t *context);
void MD5Update(MD5Context_t *context, unsigned char const *buf,
               unsigned int len);
void MD5Final(unsigned char digest[16], MD5Context_t *context);
void Transform(unsigned int buf[4], unsigned int const in[16]);

int MD5_Hash_File(unsigned char digest[16], char *pszFileName, int bUsefopen, int bSeed, unsigned int seed[4]);
char *MD5_Print(unsigned char hash[16]);
int MD5_Hash_CachedFile(unsigned char digest[16], unsigned char *pCache, int nFileSize, int bSeed, unsigned int seed[4]);

int CRC_MapFile(CRC32_t *crcvalue, char *pszFileName);

#endif

```

`halflife/common/CVARDEF.H`:

```H
/***
*
*	Copyright (c) 1999, 2000, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef CVARDEF_H
#define CVARDEF_H

#define	FCVAR_ARCHIVE		(1<<0)	// set to cause it to be saved to vars.rc
#define	FCVAR_USERINFO		(1<<1)	// changes the client's info string
#define	FCVAR_SERVER		(1<<2)	// notifies players when changed
#define FCVAR_EXTDLL		(1<<3)	// defined by external DLL
#define FCVAR_CLIENTDLL     (1<<4)  // defined by the client dll
#define FCVAR_PROTECTED     (1<<5)  // It's a server cvar, but we don't send the data since it's a password, etc.  Sends 1 if it's not bland/zero, 0 otherwise as value
#define FCVAR_SPONLY        (1<<6)  // This cvar cannot be changed by clients connected to a multiplayer server.
#define FCVAR_PRINTABLEONLY (1<<7)  // This cvar's string cannot contain unprintable characters ( e.g., used for player name etc ).
#define FCVAR_UNLOGGED		(1<<8)  // If this is a FCVAR_SERVER, don't log changes to the log file / console if we are creating a log

typedef struct cvar_s
{
	char	*name;
	char	*string;
	int		flags;
	float	value;
	struct cvar_s *next;
} cvar_t;
#endif

```

`halflife/common/DEMO_API.H`:

```H
/***
*
*	Copyright (c) 1999, 2000, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined ( DEMO_APIH )
#define DEMO_APIH
#ifdef _WIN32
#pragma once
#endif

typedef struct demo_api_s
{
	int		( *IsRecording )	( void );
	int		( *IsPlayingback )	( void );
	int		( *IsTimeDemo )		( void );
	void	( *WriteBuffer )	( int size, unsigned char *buffer );
} demo_api_t;

extern demo_api_t demoapi;

#endif

```

`halflife/common/DLIGHT.H`:

```H
/***
*
*	Copyright (c) 1999, 2000, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined ( DLIGHTH )
#define DLIGHTH
#ifdef _WIN32
#pragma once
#endif

typedef struct
{
	vec3_t	origin;
	float	radius;
	color24	color;
	float	die;				// stop lighting after this time
	float	decay;				// drop this each second
	float	minlight;			// don't add when contributing less
	int		key;
	qboolean	dark;			// subtracts light instead of adding
} dlight_t;

#endif

```

`halflife/common/EXEFUNCS.H`:

```H
// exefuncs.h
#ifndef EXEFUNCS_H
#define EXEFUNCS_H

// Engine hands this to DLLs for functionality callbacks
typedef struct exefuncs_s
{
	int			fMMX;
	int			iCPUMhz;
	void		(*unused1)(void);
	void		(*unused2)(void);
	void		(*unused3)(void);
	void		(*unused4)(void);
	void		(*VID_ForceLockState)(int lk);
	int			(*VID_ForceUnlockedAndReturnState)(void);
	void		(*unused5)(void);
	void		(*unused6)(void);
	void		(*unused7)(void);
	void		(*unused8)(void);
	void		(*unused9)(void);
	void		(*unused10)(void);
	void		(*unused11)(void);
	void		(*unused12)(void);
	void		(*unused13)(void);
	void		(*unused14)(void);
	void		(*unused15)(void);
	void        (*ErrorMessage)(int nLevel, const char *pszErrorMessage);
	void		(*unused16)(void);
	void        (*Sys_Printf)(char *fmt, ...);
	void		(*unused17)(void);
	void		(*unused18)(void);
	void		(*unused19)(void);
	void		(*unused20)(void);
	void		(*unused21)(void);
	void		(*unused22)(void);
	void		(*unused23)(void);
	void		(*unused24)(void);
	void		(*unused25)(void);
} exefuncs_t;

#endif

```

`halflife/common/HLTV.H`:

```H
// hltv.h
// all shared consts between server, clients and proxy

#define TYPE_CLIENT				0	// client is a normal HL client (default)
#define TYPE_PROXY				1	// client is another proxy
#define TYPE_DIRECTOR			2	// client is a director
#define TYPE_COMMENTATOR		3	// client is a commentator


#define HLTV_ACTIVE				0	// tells client that he's an spectator and will get director command
#define HLTV_STATUS				1	// send status infos about proxy 
#define HLTV_CAMERA				2	// set the actual director camera position
#define HLTV_EVENT				3	// informs the dircetor about ann important game event


#define DRC_FLAG_PRIO_MASK		0x0F	//	priorities between 0 and 15 (15 most important)
#define DRC_FLAG_SIDE			(1<<4)	
#define DRC_FLAG_DRAMATIC		(1<<5)



// commands of the director API function CallDirectorProc(...)

#define DRCAPI_NOP					0	// no operation
#define DRCAPI_ACTIVE				1	// de/acivates director mode in engine
#define DRCAPI_STATUS				2   // request proxy information
#define DRCAPI_SETCAM				3	// set camera n to given position and angle
#define DRCAPI_GETCAM				4	// request camera n position and angle
#define DRCAPI_DIRTIME				5	// set director time
#define DRCAPI_DIRSCALE				6	// set time scale
#define DRCAPI_SETVIEWMODE			7	// overview or 4 cameras 
#define DRCAPI_SETOVERVIEWPARAMS	8	// sets parameter for overview mode
#define DRCAPI_SETFOCUS				9	// set the camera which has the input focus
#define DRCAPI_GETTARGETS			10	// queries engine for player list
#define DRCAPI_SETVIEWPOINTS		11	// gives engine all waypoints



```

`halflife/common/MATHLIB.H`:

```H
/***
*
*	Copyright (c) 1999, 2000, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
// mathlib.h

typedef float vec_t;
typedef vec_t vec3_t[3];
typedef vec_t vec4_t[4];	// x,y,z,w
typedef vec_t vec5_t[5];

typedef short vec_s_t;
typedef vec_s_t vec3s_t[3];
typedef vec_s_t vec4s_t[4];	// x,y,z,w
typedef vec_s_t vec5s_t[5];

typedef	int	fixed4_t;
typedef	int	fixed8_t;
typedef	int	fixed16_t;

#ifndef FX_PI
#define FX_PI 3.141592
#endif

struct mplane_s;

extern vec3_t vec3_origin;
extern	int nanmask;

#define	IS_NAN(x) (((*(int *)&x)&nanmask)==nanmask)

#ifndef VECTOR_H
#define DotProduct(x,y) ((x)[0]*(y)[0]+(x)[1]*(y)[1]+(x)[2]*(y)[2])
#endif

#define VectorSubtract(a,b,c) {(c)[0]=(a)[0]-(b)[0];(c)[1]=(a)[1]-(b)[1];(c)[2]=(a)[2]-(b)[2];}
#define VectorAdd(a,b,c) {(c)[0]=(a)[0]+(b)[0];(c)[1]=(a)[1]+(b)[1];(c)[2]=(a)[2]+(b)[2];}
#define VectorCopy(a,b) {(b)[0]=(a)[0];(b)[1]=(a)[1];(b)[2]=(a)[2];}
#define VectorClear(a) {(a)[0]=0.0;(a)[1]=0.0;(a)[2]=0.0;}

void VectorMA (const vec3_t veca, float scale, const vec3_t vecb, vec3_t vecc);

vec_t _DotProduct (vec3_t v1, vec3_t v2);
void _VectorSubtract (vec3_t veca, vec3_t vecb, vec3_t out);
void _VectorAdd (vec3_t veca, vec3_t vecb, vec3_t out);
void _VectorCopy (vec3_t in, vec3_t out);

int VectorCompare (const vec3_t v1, const vec3_t v2);
float Length (const vec3_t v);
void CrossProduct (const vec3_t v1, const vec3_t v2, vec3_t cross);
float VectorNormalize (vec3_t v);		// returns vector length
void VectorInverse (vec3_t v);
void VectorScale (const vec3_t in, vec_t scale, vec3_t out);
int Q_log2(int val);

void R_ConcatRotations (float in1[3][3], float in2[3][3], float out[3][3]);
void R_ConcatTransforms (float in1[3][4], float in2[3][4], float out[3][4]);

// Here are some "manual" INLINE routines for doing floating point to integer conversions
extern short new_cw, old_cw;

typedef union DLONG {
	int		i[2];
	double	d;
	float	f;
	} DLONG;

extern DLONG	dlong;

#ifdef _WIN32
void __inline set_fpu_cw(void)
{
_asm	
	{		wait
			fnstcw	old_cw
			wait
			mov		ax, word ptr old_cw
			or		ah, 0xc
			mov		word ptr new_cw,ax
			fldcw	new_cw
	}
}

int __inline quick_ftol(float f)
{
	_asm {
		// Assumes that we are already in chop mode, and only need a 32-bit int
		fld		DWORD PTR f
		fistp	DWORD PTR dlong
	}
	return dlong.i[0];
}

void __inline restore_fpu_cw(void)
{
	_asm	fldcw	old_cw
}
#else
#define set_fpu_cw() /* */
#define quick_ftol(f) ftol(f)
#define restore_fpu_cw() /* */
#endif

void FloorDivMod (double numer, double denom, int *quotient,
		int *rem);
fixed16_t Invert24To16(fixed16_t val);
int GreatestCommonDivisor (int i1, int i2);

void AngleVectors (const vec3_t angles, vec3_t forward, vec3_t right, vec3_t up);
void AngleVectorsTranspose (const vec3_t angles, vec3_t forward, vec3_t right, vec3_t up);
#define AngleIVectors	AngleVectorsTranspose

void AngleMatrix (const vec3_t angles, float (*matrix)[4] );
void AngleIMatrix (const vec3_t angles, float (*matrix)[4] );
void VectorTransform (const vec3_t in1, float in2[3][4], vec3_t out);

void VectorMatrix( vec3_t forward, vec3_t right, vec3_t up);
void VectorAngles( const vec3_t forward, vec3_t angles );

int BoxOnPlaneSide (vec3_t emins, vec3_t emaxs, struct mplane_s *plane);
float	anglemod(float a);



#define BOX_ON_PLANE_SIDE(emins, emaxs, p)	\
	(((p)->type < 3)?						\
	(										\
		((p)->dist <= (emins)[(p)->type])?	\
			1								\
		:									\
		(									\
			((p)->dist >= (emaxs)[(p)->type])?\
				2							\
			:								\
				3							\
		)									\
	)										\
	:										\
		BoxOnPlaneSide( (emins), (emaxs), (p)))

```

`halflife/common/NETADR.H`:

```H
/***
*
*	Copyright (c) 1999, 2000, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
// netadr.h
#ifndef NETADR_H
#define NETADR_H
#ifdef _WIN32
#pragma once
#endif

typedef enum
{
	NA_UNUSED,
	NA_LOOPBACK,
	NA_BROADCAST,
	NA_IP,
	NA_IPX,
	NA_BROADCAST_IPX,
} netadrtype_t;

typedef struct netadr_s
{
	netadrtype_t	type;
	unsigned char	ip[4];
	unsigned char	ipx[10];
	unsigned short	port;
} netadr_t;

#endif // NETADR_H

```

`halflife/common/NET_API.H`:

```H
#if !defined( NET_APIH )
#define NET_APIH
#ifdef _WIN32
#pragma once
#endif

#if !defined ( NETADRH )
#include "netadr.h"
#endif

#define NETAPI_REQUEST_SERVERLIST	( 0 )  // Doesn't need a remote address
#define NETAPI_REQUEST_PING			( 1 )
#define NETAPI_REQUEST_RULES		( 2 )
#define NETAPI_REQUEST_PLAYERS		( 3 )
#define NETAPI_REQUEST_DETAILS		( 4 )

// Set this flag for things like broadcast requests, etc. where the engine should not
//  kill the request hook after receiving the first response
#define FNETAPI_MULTIPLE_RESPONSE ( 1<<0 )

typedef void ( *net_api_response_func_t ) ( struct net_response_s *response );

#define NET_SUCCESS						( 0 )
#define NET_ERROR_TIMEOUT				( 1<<0 )
#define NET_ERROR_PROTO_UNSUPPORTED		( 1<<1 )
#define NET_ERROR_UNDEFINED				( 1<<2 )

typedef struct net_adrlist_s
{
	struct net_adrlist_s	*next;
	netadr_t				remote_address;
} net_adrlist_t;

typedef struct net_response_s
{
	// NET_SUCCESS or an error code
	int			error;

	// Context ID
	int			context;
	// Type
	int			type;

	// Server that is responding to the request
	netadr_t	remote_address;

	// Response RTT ping time
	double		ping;
	// Key/Value pair string ( separated by backlash \ characters )
	// WARNING:  You must copy this buffer in the callback function, because it is freed
	//  by the engine right after the call!!!!
	// ALSO:  For NETAPI_REQUEST_SERVERLIST requests, this will be a pointer to a linked list of net_adrlist_t's
	void		*response;
} net_response_t;

typedef struct net_status_s
{
		// Connected to remote server?  1 == yes, 0 otherwise
	int			connected; 
	// Client's IP address
	netadr_t	local_address;
	// Address of remote server
	netadr_t	remote_address;
	// Packet Loss ( as a percentage )
	int			packet_loss;
	// Latency, in seconds ( multiply by 1000.0 to get milliseconds )
	double		latency;
	// Connection time, in seconds
	double		connection_time;
	// Rate setting ( for incoming data )
	double		rate;
} net_status_t;

typedef struct net_api_s
{
	// APIs
	void		( *InitNetworking )( void );
	void		( *Status ) ( struct net_status_s *status );
	void		( *SendRequest) ( int context, int request, int flags, double timeout, struct netadr_s *remote_address, net_api_response_func_t response );
	void		( *CancelRequest ) ( int context );
	void		( *CancelAllRequests ) ( void );
	char		*( *AdrToString ) ( struct netadr_s *a );
	int			( *CompareAdr ) ( struct netadr_s *a, struct netadr_s *b );
	int			( *StringToAdr ) ( char *s, struct netadr_s *a );
	const char *( *ValueForKey ) ( const char *s, const char *key );
	void		( *RemoveKey ) ( char *s, const char *key );
	void		( *SetValueForKey ) (char *s, const char *key, const char *value, int maxsize );
} net_api_t;

extern net_api_t netapi;

#endif // NET_APIH
```

`halflife/common/NOWIN.H`:

```H

#ifndef INC_NOWIN_H
#define INC_NOWIN_H
#ifndef _WIN32

#include <unistd.h>

#endif //!_WIN32
#endif //INC_NOWIN_H
```

`halflife/common/PMTRACE.H`:

```H
/***
*
*	Copyright (c) 1999, 2000, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined( PMTRACEH )
#define PMTRACEH
#ifdef _WIN32
#pragma once
#endif

typedef struct
{
	vec3_t	normal;
	float	dist;
} pmplane_t;

typedef struct pmtrace_s pmtrace_t;

struct pmtrace_s
{
	qboolean	allsolid;	      // if true, plane is not valid
	qboolean	startsolid;	      // if true, the initial point was in a solid area
	qboolean	inopen, inwater;  // End point is in empty space or in water
	float		fraction;		  // time completed, 1.0 = didn't hit anything
	vec3_t		endpos;			  // final position
	pmplane_t	plane;		      // surface normal at impact
	int			ent;			  // entity at impact
	vec3_t      deltavelocity;    // Change in player's velocity caused by impact.  
								  // Only run on server.
	int         hitgroup;
};

#endif

```

`halflife/common/QFONT.H`:

```H
/***
*
*	Copyright (c) 1999, 2000, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined( QFONTH )
#define QFONTH
#ifdef _WIN32
#pragma once
#endif

// Font stuff

#define NUM_GLYPHS 256

typedef struct
{
	short startoffset;
	short charwidth;
} charinfo;

typedef struct qfont_s
{
	int 		width, height;
	int			rowcount;
	int			rowheight;
	charinfo	fontinfo[ NUM_GLYPHS ];
	byte 		data[4];
} qfont_t;

#endif // qfont.h

```

`halflife/common/R_EFX.H`:

```H
/***
*
*	Copyright (c) 1999, 2000, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined ( R_EFXH )
#define R_EFXH
#ifdef _WIN32
#pragma once
#endif

// particle_t
#if !defined( PARTICLEDEFH )  
#include "particledef.h"
#endif

// BEAM
#if !defined( BEAMDEFH )
#include "beamdef.h"
#endif

// dlight_t
#if !defined ( DLIGHTH )
#include "dlight.h"
#endif

// cl_entity_t
#if !defined( CL_ENTITYH )
#include "cl_entity.h"
#endif

/*
// FOR REFERENCE, These are the built-in tracer colors.  Note, color 4 is the one
//  that uses the tracerred/tracergreen/tracerblue and traceralpha cvar settings
color24 gTracerColors[] =
{
	{ 255, 255, 255 },		// White
	{ 255, 0, 0 },			// Red
	{ 0, 255, 0 },			// Green
	{ 0, 0, 255 },			// Blue
	{ 0, 0, 0 },			// Tracer default, filled in from cvars, etc.
	{ 255, 167, 17 },		// Yellow-orange sparks
	{ 255, 130, 90 },		// Yellowish streaks (garg)
	{ 55, 60, 144 },		// Blue egon streak
	{ 255, 130, 90 },		// More Yellowish streaks (garg)
	{ 255, 140, 90 },		// More Yellowish streaks (garg)
	{ 200, 130, 90 },		// More red streaks (garg)
	{ 255, 120, 70 },		// Darker red streaks (garg)
};
*/

// Temporary entity array
#define TENTPRIORITY_LOW	0
#define TENTPRIORITY_HIGH	1

// TEMPENTITY flags
#define	FTENT_NONE				0x00000000
#define	FTENT_SINEWAVE			0x00000001
#define	FTENT_GRAVITY			0x00000002
#define FTENT_ROTATE			0x00000004
#define	FTENT_SLOWGRAVITY		0x00000008
#define FTENT_SMOKETRAIL		0x00000010
#define FTENT_COLLIDEWORLD		0x00000020
#define FTENT_FLICKER			0x00000040
#define FTENT_FADEOUT			0x00000080
#define FTENT_SPRANIMATE		0x00000100
#define FTENT_HITSOUND			0x00000200
#define FTENT_SPIRAL			0x00000400
#define FTENT_SPRCYCLE			0x00000800
#define FTENT_COLLIDEALL		0x00001000 // will collide with world and slideboxes
#define FTENT_PERSIST			0x00002000 // tent is not removed when unable to draw 
#define FTENT_COLLIDEKILL		0x00004000 // tent is removed upon collision with anything
#define FTENT_PLYRATTACHMENT	0x00008000 // tent is attached to a player (owner)
#define FTENT_SPRANIMATELOOP	0x00010000 // animating sprite doesn't die when last frame is displayed
#define FTENT_SPARKSHOWER		0x00020000
#define FTENT_NOMODEL			0x00040000 // Doesn't have a model, never try to draw ( it just triggers other things )
#define FTENT_CLIENTCUSTOM		0x00080000 // Must specify callback.  Callback function is responsible for killing tempent and updating fields ( unless other flags specify how to do things )

typedef struct tempent_s	TEMPENTITY;
typedef struct tempent_s
{
	int			flags;
	float		die;
	float		frameMax;
	float		x;
	float		y;
	float		z;
	float		fadeSpeed;
	float		bounceFactor;
	int			hitSound;
	void		( *hitcallback )	( struct tempent_s *ent, struct pmtrace_s *ptr );
	void		( *callback )		( struct tempent_s *ent, float frametime, float currenttime );
	TEMPENTITY	*next;
	int			priority;
	short		clientIndex;	// if attached, this is the index of the client to stick to
								// if COLLIDEALL, this is the index of the client to ignore
								// TENTS with FTENT_PLYRATTACHMENT MUST set the clientindex! 

	vec3_t		tentOffset;		// if attached, client origin + tentOffset = tent origin.
	cl_entity_t	entity;

	// baseline.origin		- velocity
	// baseline.renderamt	- starting fadeout intensity
	// baseline.angles		- angle velocity
} TEMPENTITY;

typedef struct efx_api_s efx_api_t;

struct efx_api_s
{
	particle_t  *( *R_AllocParticle )			( void ( *callback ) ( struct particle_s *particle, float frametime ) );
	void		( *R_BlobExplosion )			( float * org );
	void		( *R_Blood )					( float * org, float * dir, int pcolor, int speed );
	void		( *R_BloodSprite )				( float * org, int colorindex, int modelIndex, int modelIndex2, float size );
	void		( *R_BloodStream )				( float * org, float * dir, int pcolor, int speed );
	void		( *R_BreakModel )				( float *pos, float *size, float *dir, float random, float life, int count, int modelIndex, char flags );
	void		( *R_Bubbles )					( float * mins, float * maxs, float height, int modelIndex, int count, float speed );
	void		( *R_BubbleTrail )				( float * start, float * end, float height, int modelIndex, int count, float speed );
	void		( *R_BulletImpactParticles )	( float * pos );
	void		( *R_EntityParticles )			( struct cl_entity_s *ent );
	void		( *R_Explosion )				( float *pos, int model, float scale, float framerate, int flags );
	void		( *R_FizzEffect )				( struct cl_entity_s *pent, int modelIndex, int density );
	void		( *R_FireField ) 				( float * org, int radius, int modelIndex, int count, int flags, float life );
	void		( *R_FlickerParticles )			( float * org );
	void		( *R_FunnelSprite )				( float *org, int modelIndex, int reverse );
	void		( *R_Implosion )				( float * end, float radius, int count, float life );
	void		( *R_LargeFunnel )				( float * org, int reverse );
	void		( *R_LavaSplash )				( float * org );
	void		( *R_MultiGunshot )				( float * org, float * dir, float * noise, int count, int decalCount, int *decalIndices );
	void		( *R_MuzzleFlash )				( float *pos1, int type );
	void		( *R_ParticleBox )				( float *mins, float *maxs, unsigned char r, unsigned char g, unsigned char b, float life );
	void		( *R_ParticleBurst )			( float * pos, int size, int color, float life );
	void		( *R_ParticleExplosion )		( float * org );
	void		( *R_ParticleExplosion2 )		( float * org, int colorStart, int colorLength );
	void		( *R_ParticleLine )				( float * start, float *end, unsigned char r, unsigned char g, unsigned char b, float life );
	void		( *R_PlayerSprites )			( int client, int modelIndex, int count, int size );
	void		( *R_Projectile )				( float * origin, float * velocity, int modelIndex, int life, int owner, void (*hitcallback)( struct tempent_s *ent, struct pmtrace_s *ptr ) );
	void		( *R_RicochetSound )			( float * pos );
	void		( *R_RicochetSprite )			( float *pos, struct model_s *pmodel, float duration, float scale );
	void		( *R_RocketFlare )				( float *pos );
	void		( *R_RocketTrail )				( float * start, float * end, int type );
	void		( *R_RunParticleEffect )		( float * org, float * dir, int color, int count );
	void		( *R_ShowLine )					( float * start, float * end );
	void		( *R_SparkEffect )				( float *pos, int count, int velocityMin, int velocityMax );
	void		( *R_SparkShower )				( float *pos );
	void		( *R_SparkStreaks )				( float * pos, int count, int velocityMin, int velocityMax );
	void		( *R_Spray )					( float * pos, float * dir, int modelIndex, int count, int speed, int spread, int rendermode );
	void		( *R_Sprite_Explode )			( TEMPENTITY *pTemp, float scale, int flags );
	void		( *R_Sprite_Smoke )				( TEMPENTITY *pTemp, float scale );
	void		( *R_Sprite_Spray )				( float * pos, float * dir, int modelIndex, int count, int speed, int iRand );
	void		( *R_Sprite_Trail )				( int type, float * start, float * end, int modelIndex, int count, float life, float size, float amplitude, int renderamt, float speed );
	void		( *R_Sprite_WallPuff )			( TEMPENTITY *pTemp, float scale );
	void		( *R_StreakSplash )				( float * pos, float * dir, int color, int count, float speed, int velocityMin, int velocityMax );
	void		( *R_TracerEffect )				( float * start, float * end );
	void		( *R_UserTracerParticle )		( float * org, float * vel, float life, int colorIndex, float length, unsigned char deathcontext, void ( *deathfunc)( struct particle_s *particle ) );
	particle_t *( *R_TracerParticles )			( float * org, float * vel, float life );
	void		( *R_TeleportSplash )			( float * org );
	void		( *R_TempSphereModel )			( float *pos, float speed, float life, int count, int modelIndex );
	TEMPENTITY	*( *R_TempModel )				( float *pos, float *dir, float *angles, float life, int modelIndex, int soundtype );
	TEMPENTITY	*( *R_DefaultSprite )			( float *pos, int spriteIndex, float framerate );
	TEMPENTITY	*( *R_TempSprite )				( float *pos, float *dir, float scale, int modelIndex, int rendermode, int renderfx, float a, float life, int flags );
	int			( *Draw_DecalIndex )			( int id );
	int			( *Draw_DecalIndexFromName )	( char *name );
	void		( *R_DecalShoot )				( int textureIndex, int entity, int modelIndex, float * position, int flags );
	void		( *R_AttachTentToPlayer )		( int client, int modelIndex, float zoffset, float life );
	void		( *R_KillAttachedTents )		( int client );
	BEAM		*( *R_BeamCirclePoints )		( int type, float * start, float * end, int modelIndex, float life, float width, float amplitude, float brightness, float speed, int startFrame, float framerate, float r, float g, float b );
	BEAM		*( *R_BeamEntPoint )			( int startEnt, float * end, int modelIndex, float life, float width, float amplitude, float brightness, float speed, int startFrame, float framerate, float r, float g, float b );
	BEAM		*( *R_BeamEnts )				( int startEnt, int endEnt, int modelIndex, float life, float width, float amplitude, float brightness, float speed, int startFrame, float framerate, float r, float g, float b );
	BEAM		*( *R_BeamFollow )				( int startEnt, int modelIndex, float life, float width, float r, float g, float b, float brightness );
	void		( *R_BeamKill )					( int deadEntity );
	BEAM		*( *R_BeamLightning )			( float * start, float * end, int modelIndex, float life, float width, float amplitude, float brightness, float speed );
	BEAM		*( *R_BeamPoints )				( float * start, float * end, int modelIndex, float life, float width, float amplitude, float brightness, float speed, int startFrame, float framerate, float r, float g, float b );
	BEAM		*( *R_BeamRing )				( int startEnt, int endEnt, int modelIndex, float life, float width, float amplitude, float brightness, float speed, int startFrame, float framerate, float r, float g, float b );
	dlight_t	*( *CL_AllocDlight )			( int key );
	dlight_t	*( *CL_AllocElight )			( int key );
	TEMPENTITY	*( *CL_TempEntAlloc )			( float * org, struct model_s *model );
	TEMPENTITY	*( *CL_TempEntAllocNoModel )	( float * org );
	TEMPENTITY	*( *CL_TempEntAllocHigh )		( float * org, struct model_s *model );
	TEMPENTITY	*( *CL_TentEntAllocCustom )		( float *origin, struct model_s *model, int high, void ( *callback ) ( struct tempent_s *ent, float frametime, float currenttime ) );
	void		( *R_GetPackedColor )			( short *packed, short color );
	short		( *R_LookupColor )				( unsigned char r, unsigned char g, unsigned char b );
	void		( *R_DecalRemoveAll )			( int textureIndex ); //textureIndex points to the decal index in the array, not the actual texture index.
};

extern efx_api_t efx;

#endif

```

`halflife/common/Sequence.h`:

```h
//---------------------------------------------------------------------------
// 
//		S c r i p t e d   S e q u e n c e s
// 
//---------------------------------------------------------------------------
#ifndef _INCLUDE_SEQUENCE_H_
#define _INCLUDE_SEQUENCE_H_


#ifndef _DEF_BYTE_
typedef unsigned char byte;
#endif

//---------------------------------------------------------------------------
// client_textmessage_t
//---------------------------------------------------------------------------
typedef struct client_textmessage_s
{
	int		effect;
	byte	r1, g1, b1, a1;		// 2 colors for effects
	byte	r2, g2, b2, a2;
	float	x;
	float	y;
	float	fadein;
	float	fadeout;
	float	holdtime;
	float	fxtime;
	const char *pName;
	const char *pMessage;
} client_textmessage_t;


//--------------------------------------------------------------------------
// sequenceDefaultBits_e
//	
// Enumerated list of possible modifiers for a command.  This enumeration
// is used in a bitarray controlling what modifiers are specified for a command.
//---------------------------------------------------------------------------
enum sequenceModifierBits
{
	SEQUENCE_MODIFIER_EFFECT_BIT		= (1 << 1),
	SEQUENCE_MODIFIER_POSITION_BIT		= (1 << 2),
	SEQUENCE_MODIFIER_COLOR_BIT			= (1 << 3),
	SEQUENCE_MODIFIER_COLOR2_BIT		= (1 << 4),
	SEQUENCE_MODIFIER_FADEIN_BIT		= (1 << 5),
	SEQUENCE_MODIFIER_FADEOUT_BIT		= (1 << 6),
	SEQUENCE_MODIFIER_HOLDTIME_BIT		= (1 << 7),
	SEQUENCE_MODIFIER_FXTIME_BIT		= (1 << 8),
	SEQUENCE_MODIFIER_SPEAKER_BIT		= (1 << 9),
	SEQUENCE_MODIFIER_LISTENER_BIT		= (1 << 10),
	SEQUENCE_MODIFIER_TEXTCHANNEL_BIT	= (1 << 11),
};
typedef enum sequenceModifierBits sequenceModifierBits_e ;


//---------------------------------------------------------------------------
// sequenceCommandEnum_e
// 
// Enumerated sequence command types.
//---------------------------------------------------------------------------
enum sequenceCommandEnum_
{
	SEQUENCE_COMMAND_ERROR = -1,
	SEQUENCE_COMMAND_PAUSE = 0,
	SEQUENCE_COMMAND_FIRETARGETS,
	SEQUENCE_COMMAND_KILLTARGETS,
	SEQUENCE_COMMAND_TEXT,
	SEQUENCE_COMMAND_SOUND,
	SEQUENCE_COMMAND_GOSUB,
	SEQUENCE_COMMAND_SENTENCE,
	SEQUENCE_COMMAND_REPEAT,
	SEQUENCE_COMMAND_SETDEFAULTS,
	SEQUENCE_COMMAND_MODIFIER,
	SEQUENCE_COMMAND_POSTMODIFIER,
	SEQUENCE_COMMAND_NOOP,

	SEQUENCE_MODIFIER_EFFECT,
	SEQUENCE_MODIFIER_POSITION,
	SEQUENCE_MODIFIER_COLOR,
	SEQUENCE_MODIFIER_COLOR2,
	SEQUENCE_MODIFIER_FADEIN,
	SEQUENCE_MODIFIER_FADEOUT,
	SEQUENCE_MODIFIER_HOLDTIME,
	SEQUENCE_MODIFIER_FXTIME,
	SEQUENCE_MODIFIER_SPEAKER,
	SEQUENCE_MODIFIER_LISTENER,
	SEQUENCE_MODIFIER_TEXTCHANNEL,
};
typedef enum sequenceCommandEnum_ sequenceCommandEnum_e;


//---------------------------------------------------------------------------
// sequenceCommandType_e
// 
// Typeerated sequence command types.
//---------------------------------------------------------------------------
enum sequenceCommandType_
{
	SEQUENCE_TYPE_COMMAND,
	SEQUENCE_TYPE_MODIFIER,
};
typedef enum sequenceCommandType_ sequenceCommandType_e;


//---------------------------------------------------------------------------
// sequenceCommandMapping_s
// 
// A mapping of a command enumerated-value to its name.
//---------------------------------------------------------------------------
typedef struct sequenceCommandMapping_ sequenceCommandMapping_s;
struct sequenceCommandMapping_
{
	sequenceCommandEnum_e	commandEnum;
	const char*				commandName;
	sequenceCommandType_e	commandType;
};


//---------------------------------------------------------------------------
// sequenceCommandLine_s
// 
// Structure representing a single command (usually 1 line) from a
//	.SEQ file entry.
//---------------------------------------------------------------------------
typedef struct sequenceCommandLine_ sequenceCommandLine_s;
struct sequenceCommandLine_
{
	int						commandType;		// Specifies the type of command
	client_textmessage_t	clientMessage;		// Text HUD message struct
	char*					speakerName;		// Targetname of speaking entity
	char*					listenerName;		// Targetname of entity being spoken to
	char*					soundFileName;		// Name of sound file to play
	char*					sentenceName;		// Name of sentences.txt to play
	char*					fireTargetNames;	// List of targetnames to fire
	char*					killTargetNames;	// List of targetnames to remove
	float					delay;				// Seconds 'till next command
	int						repeatCount;		// If nonzero, reset execution pointer to top of block (N times, -1 = infinite)
	int						textChannel;		// Display channel on which text message is sent
	int						modifierBitField;	// Bit field to specify what clientmessage fields are valid
	sequenceCommandLine_s*	nextCommandLine;	// Next command (linked list)
};


//---------------------------------------------------------------------------
// sequenceEntry_s
// 
// Structure representing a single command (usually 1 line) from a
//	.SEQ file entry.
//---------------------------------------------------------------------------
typedef struct sequenceEntry_ sequenceEntry_s;
struct sequenceEntry_
{
	char*					fileName;		// Name of sequence file without .SEQ extension
	char*					entryName;		// Name of entry label in file
	sequenceCommandLine_s*	firstCommand;	// Linked list of commands in entry
	sequenceEntry_s*		nextEntry;		// Next loaded entry
	qboolean				isGlobal;		// Is entry retained over level transitions?
};



//---------------------------------------------------------------------------
// sentenceEntry_s
// Structure representing a single sentence of a group from a .SEQ
// file entry.  Sentences are identical to entries in sentences.txt, but
// can be unique per level and are loaded/unloaded with the level.
//---------------------------------------------------------------------------
typedef struct sentenceEntry_ sentenceEntry_s;
struct sentenceEntry_
{
	char*					data;			// sentence data (ie "We have hostiles" )
	sentenceEntry_s*		nextEntry;		// Next loaded entry
	qboolean				isGlobal;		// Is entry retained over level transitions?
	unsigned int			index;			// this entry's position in the file.
};

//--------------------------------------------------------------------------
// sentenceGroupEntry_s
// Structure representing a group of sentences found in a .SEQ file.
// A sentence group is defined by all sentences with the same name, ignoring
// the number at the end of the sentence name.  Groups enable a sentence
// to be picked at random across a group.
//--------------------------------------------------------------------------
typedef struct sentenceGroupEntry_ sentenceGroupEntry_s;
struct sentenceGroupEntry_
{
	char*					groupName;		// name of the group (ie CT_ALERT )
	unsigned int			numSentences;	// number of sentences in group
	sentenceEntry_s*		firstSentence;	// head of linked list of sentences in group
	sentenceGroupEntry_s*	nextEntry;		// next loaded group
};

//---------------------------------------------------------------------------
// Function declarations
//---------------------------------------------------------------------------
sequenceEntry_s* SequenceGet( const char* fileName, const char* entryName );
void Sequence_ParseFile( const char* fileName, qboolean isGlobal );
void Sequence_OnLevelLoad( const char* mapName );
sentenceEntry_s* SequencePickSentence( const char *groupName, int pickMethod, int *picked );

#endif // _INCLUDE_SEQUENCE_H_

```

`halflife/common/USERCMD.H`:

```H
/***
*
*	Copyright (c) 1999, 2000, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef USERCMD_H
#define USERCMD_H
#ifdef _WIN32
#pragma once
#endif

typedef struct usercmd_s
{
	short	lerp_msec;      // Interpolation time on client
	byte	msec;           // Duration in ms of command
	vec3_t	viewangles;     // Command view angles.

// intended velocities
	float	forwardmove;    // Forward velocity.
	float	sidemove;       // Sideways velocity.
	float	upmove;         // Upward velocity.
	byte	lightlevel;     // Light level at spot where we are standing.
	unsigned short  buttons;  // Attack buttons
	byte    impulse;          // Impulse command issued.
	byte	weaponselect;	// Current weapon id

// Experimental player impact stuff.
	int		impact_index;
	vec3_t	impact_position;
} usercmd_t;

#endif // USERCMD_H

```

`halflife/common/cl_entity.h`:

```h
/***
*
*	Copyright (c) 1999, 2000, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
// cl_entity.h
#if !defined( CL_ENTITYH )
#define CL_ENTITYH
#ifdef _WIN32
#pragma once
#endif

typedef struct efrag_s
{
	struct mleaf_s		*leaf;
	struct efrag_s		*leafnext;
	struct cl_entity_s	*entity;
	struct efrag_s		*entnext;
} efrag_t;

typedef struct
{
	byte					mouthopen;		// 0 = mouth closed, 255 = mouth agape
	byte					sndcount;		// counter for running average
	int						sndavg;			// running average
} mouth_t;

typedef struct
{
	float					prevanimtime;  
	float					sequencetime;
	byte					prevseqblending[2];
	vec3_t					prevorigin;
	vec3_t					prevangles;

	int						prevsequence;
	float					prevframe;

	byte					prevcontroller[4];
	byte					prevblending[2];
} latchedvars_t;

typedef struct
{
	// Time stamp for this movement
	float					animtime;

	vec3_t					origin;
	vec3_t					angles;
} position_history_t;

typedef struct cl_entity_s cl_entity_t;

#define HISTORY_MAX		64  // Must be power of 2
#define HISTORY_MASK	( HISTORY_MAX - 1 )


#if !defined( ENTITY_STATEH )
#include "entity_state.h"
#endif

#if !defined( PROGS_H )
#include "progs.h"
#endif

struct cl_entity_s
{
	int						index;      // Index into cl_entities ( should match actual slot, but not necessarily )

	qboolean				player;     // True if this entity is a "player"
	
	entity_state_t			baseline;   // The original state from which to delta during an uncompressed message
	entity_state_t			prevstate;  // The state information from the penultimate message received from the server
	entity_state_t			curstate;   // The state information from the last message received from server

	int						current_position;  // Last received history update index
	position_history_t		ph[ HISTORY_MAX ];   // History of position and angle updates for this player

	mouth_t					mouth;			// For synchronizing mouth movements.

	latchedvars_t			latched;		// Variables used by studio model rendering routines

	// Information based on interplocation, extrapolation, prediction, or just copied from last msg received.
	//
	float					lastmove;

	// Actual render position and angles
	vec3_t					origin;
	vec3_t					angles;

	// Attachment points
	vec3_t					attachment[4];

	// Other entity local information
	int						trivial_accept;

	struct model_s			*model;			// cl.model_precache[ curstate.modelindes ];  all visible entities have a model
	struct efrag_s			*efrag;			// linked list of efrags
	struct mnode_s			*topnode;		// for bmodels, first world node that splits bmodel, or NULL if not split

	float					syncbase;		// for client-side animations -- used by obsolete alias animation system, remove?
	int						visframe;		// last frame this entity was found in an active leaf
	colorVec				cvFloorColor;
};

#endif // !CL_ENTITYH

```

`halflife/common/com_model.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

// com_model.h
#if !defined( COM_MODEL_H )
#define COM_MODEL_H
#if defined( _WIN32 )
#pragma once
#endif

#define STUDIO_RENDER 1
#define STUDIO_EVENTS 2

#define MAX_CLIENTS			32
#define	MAX_EDICTS			900

#define MAX_MODEL_NAME		64
#define MAX_MAP_HULLS		4
#define	MIPLEVELS			4
#define	NUM_AMBIENTS		4		// automatic ambient sounds
#define	MAXLIGHTMAPS		4
#define	PLANE_ANYZ			5

#define ALIAS_Z_CLIP_PLANE	5

// flags in finalvert_t.flags
#define ALIAS_LEFT_CLIP				0x0001
#define ALIAS_TOP_CLIP				0x0002
#define ALIAS_RIGHT_CLIP			0x0004
#define ALIAS_BOTTOM_CLIP			0x0008
#define ALIAS_Z_CLIP				0x0010
#define ALIAS_ONSEAM				0x0020
#define ALIAS_XY_CLIP_MASK			0x000F

#define	ZISCALE	((float)0x8000)

#define CACHE_SIZE	32		// used to align key data structures

typedef enum
{
	mod_brush, 
	mod_sprite, 
	mod_alias, 
	mod_studio
} modtype_t;

// must match definition in modelgen.h
#ifndef SYNCTYPE_T
#define SYNCTYPE_T

typedef enum
{
	ST_SYNC=0,
	ST_RAND
} synctype_t;

#endif

typedef struct
{
	float		mins[3], maxs[3];
	float		origin[3];
	int			headnode[MAX_MAP_HULLS];
	int			visleafs;		// not including the solid leaf 0
	int			firstface, numfaces;
} dmodel_t;

// plane_t structure
typedef struct mplane_s
{
	vec3_t	normal;			// surface normal
	float	dist;			// closest appoach to origin
	byte	type;			// for texture axis selection and fast side tests
	byte	signbits;		// signx + signy<<1 + signz<<1
	byte	pad[2];
} mplane_t;

typedef struct
{
	vec3_t		position;
} mvertex_t;

typedef struct
{
	unsigned short	v[2];
	unsigned int	cachededgeoffset;
} medge_t;

typedef struct texture_s
{
	char		name[16];
	unsigned	width, height;
	int			gl_texturenum;
	void*		texturechain;
	int			anim_total;				// total tenths in sequence ( 0 = no)
	int			anim_min, anim_max;		// time for this frame min <=time< max
	struct texture_s *anim_next;		// in the animation sequence
	struct texture_s *alternate_anims;	// bmodels in frame 1 use these
	unsigned	offsets[MIPLEVELS];		// four mip maps stored
	byte* pPal;
} texture_t;

typedef struct
{
	float		vecs[2][4];		// [s/t] unit vectors in world space. 
								// [i][3] is the s/t offset relative to the origin.
								// s or t = dot(3Dpoint,vecs[i])+vecs[i][3]
	float		mipadjust;		// ?? mipmap limits for very small surfaces
	texture_t	*texture;
	int			flags;			// sky or slime, no lightmap or 256 subdivision
} mtexinfo_t;

typedef struct mnode_s
{
// common with leaf
	int			contents;		// 0, to differentiate from leafs
	int			visframe;		// node needs to be traversed if current
	
	float		minmaxs[6];		// for bounding box culling

	struct mnode_s	*parent;

// node specific
	mplane_t	*plane;
	struct mnode_s	*children[2];	

	unsigned short		firstsurface;
	unsigned short		numsurfaces;
} mnode_t;

typedef struct msurface_s	msurface_t;
typedef struct decal_s		decal_t;

// JAY: Compress this as much as possible
struct decal_s
{
	decal_t		*pnext;			// linked list for each surface
	msurface_t	*psurface;		// Surface id for persistence / unlinking
	short		dx;				// Offsets into surface texture (in texture coordinates, so we don't need floats)
	short		dy;
	short		texture;		// Decal texture
	byte		scale;			// Pixel scale
	byte		flags;			// Decal flags

	short		entityIndex;	// Entity this is attached to
};

typedef struct mleaf_s
{
// common with node
	int			contents;		// wil be a negative contents number
	int			visframe;		// node needs to be traversed if current

	short		minmaxs[6];		// for bounding box culling

	struct mnode_s	*parent;

// leaf specific
	byte		*compressed_vis;
	struct efrag_s	*efrags;

	msurface_t	**firstmarksurface;
	int			nummarksurfaces;
	int			key;			// BSP sequence number for leaf's contents
	byte		ambient_sound_level[NUM_AMBIENTS];
} mleaf_t;

struct msurface_s
{
	int			visframe;		// should be drawn when node is crossed

	int			dlightframe;	// last frame the surface was checked by an animated light
	int			dlightbits;		// dynamically generated. Indicates if the surface illumination 
								// is modified by an animated light.

	mplane_t	*plane;			// pointer to shared plane			
	int			flags;			// see SURF_ #defines

	int			firstedge;	// look up in model->surfedges[], negative numbers
	int			numedges;	// are backwards edges
	
// surface generation data
	struct surfcache_s	*cachespots[MIPLEVELS];

	short		texturemins[2]; // smallest s/t position on the surface.
	short		extents[2];		// ?? s/t texture size, 1..256 for all non-sky surfaces

	mtexinfo_t	*texinfo;		
	
// lighting info
	byte		styles[MAXLIGHTMAPS]; // index into d_lightstylevalue[] for animated lights 
									  // no one surface can be effected by more than 4 
									  // animated lights.
	color24		*samples;
	
	decal_t		*pdecals;
};

typedef struct
{
	int			planenum;
	short		children[2];	// negative numbers are contents
} dclipnode_t;

typedef struct hull_s
{
	dclipnode_t	*clipnodes;
	mplane_t	*planes;
	int			firstclipnode;
	int			lastclipnode;
	vec3_t		clip_mins;
	vec3_t		clip_maxs;
} hull_t;

#if !defined( CACHE_USER ) && !defined( QUAKEDEF_H )
#define CACHE_USER
typedef struct cache_user_s
{
	void	*data;
} cache_user_t;
#endif

typedef struct model_s
{
	char		name[ MAX_MODEL_NAME ];
	qboolean	needload;		// bmodels and sprites don't cache normally

	modtype_t	type;
	int			numframes;
	synctype_t	synctype;
	
	int			flags;

//
// volume occupied by the model
//		
	vec3_t		mins, maxs;
	float		radius;

//
// brush model
//
	int			firstmodelsurface, nummodelsurfaces;

	int			numsubmodels;
	dmodel_t	*submodels;

	int			numplanes;
	mplane_t	*planes;

	int			numleafs;		// number of visible leafs, not counting 0
	struct mleaf_s		*leafs;

	int			numvertexes;
	mvertex_t	*vertexes;

	int			numedges;
	medge_t		*edges;

	int			numnodes;
	mnode_t		*nodes;

	int			numtexinfo;
	mtexinfo_t	*texinfo;

	int			numsurfaces;
	msurface_t	*surfaces;

	int			numsurfedges;
	int			*surfedges;

	int			numclipnodes;
	dclipnode_t	*clipnodes;

	int			nummarksurfaces;
	msurface_t	**marksurfaces;

	hull_t		hulls[MAX_MAP_HULLS];

	int			numtextures;
	texture_t	**textures;

	byte		*visdata;

	color24		*lightdata;

	char		*entities;

//
// additional model data
//
	cache_user_t	cache;		// only access through Mod_Extradata

} model_t;

typedef vec_t vec4_t[4];

typedef struct alight_s
{
	int			ambientlight;	// clip at 128
	int			shadelight;		// clip at 192 - ambientlight
	vec3_t		color;
	float		*plightvec;
} alight_t;

typedef struct auxvert_s
{
	float	fv[3];		// viewspace x, y
} auxvert_t;

#include "../engine/custom.h"

#define	MAX_INFO_STRING			256
#define	MAX_SCOREBOARDNAME		32
typedef struct player_info_s
{
	// User id on server
	int		userid;

	// User info string
	char	userinfo[ MAX_INFO_STRING ];

	// Name
	char	name[ MAX_SCOREBOARDNAME ];

	// Spectator or not, unused
	int		spectator;

	int		ping;
	int		packet_loss;

	// skin information
	char	model[MAX_QPATH];
	int		topcolor;
	int		bottomcolor;

	// last frame rendered
	int		renderframe;	

	// Gait frame estimation
	int		gaitsequence;
	float	gaitframe;
	float	gaityaw;
	vec3_t	prevgaitorigin;

	customization_t customdata;
} player_info_t;

#endif // #define COM_MODEL_H

```

`halflife/common/com_model_backup.h`:

```h
// com_model.h
#if !defined( COM_MODEL_H )
#define COM_MODEL_H
#if defined( _WIN32 )
#pragma once
#endif

#define STUDIO_RENDER 1
#define STUDIO_EVENTS 2

#define MAX_CLIENTS			32
#define	MAX_EDICTS			900

#define MAX_MODEL_NAME		64
#define MAX_MAP_HULLS		4
#define	MIPLEVELS			4
#define	NUM_AMBIENTS		4		// automatic ambient sounds
#define	MAXLIGHTMAPS		4
#define	PLANE_ANYZ			5

#define ALIAS_Z_CLIP_PLANE	5

// flags in finalvert_t.flags
#define ALIAS_LEFT_CLIP				0x0001
#define ALIAS_TOP_CLIP				0x0002
#define ALIAS_RIGHT_CLIP			0x0004
#define ALIAS_BOTTOM_CLIP			0x0008
#define ALIAS_Z_CLIP				0x0010
#define ALIAS_ONSEAM				0x0020
#define ALIAS_XY_CLIP_MASK			0x000F

#define	ZISCALE	((float)0x8000)

#define CACHE_SIZE	32		// used to align key data structures

typedef enum
{
	mod_brush, 
	mod_sprite, 
	mod_alias, 
	mod_studio
} modtype_t;

// must match definition in modelgen.h
#ifndef SYNCTYPE_T
#define SYNCTYPE_T

typedef enum
{
	ST_SYNC=0,
	ST_RAND
} synctype_t;

#endif

typedef struct
{
	float		mins[3], maxs[3];
	float		origin[3];
	int			headnode[MAX_MAP_HULLS];
	int			visleafs;		// not including the solid leaf 0
	int			firstface, numfaces;
} dmodel_t;

// plane_t structure
typedef struct mplane_s
{
	vec3_t	normal;			// surface normal
	float	dist;			// closest appoach to origin
	byte	type;			// for texture axis selection and fast side tests
	byte	signbits;		// signx + signy<<1 + signz<<1
	byte	pad[2];
} mplane_t;

typedef struct
{
	vec3_t		position;
} mvertex_t;

typedef struct
{
	unsigned short	v[2];
	unsigned int	cachededgeoffset;
} medge_t;
/*
typedef struct texture_s
{
	char		name[16];
	unsigned	width, height;
	int			anim_total;				// total tenths in sequence ( 0 = no)
	int			anim_min, anim_max;		// time for this frame min <=time< max
	struct texture_s *anim_next;		// in the animation sequence
	struct texture_s *alternate_anims;	// bmodels in frame 1 use these
	unsigned	offsets[MIPLEVELS];		// four mip maps stored
	unsigned	paloffset;
} texture_t;
*/
typedef struct texture_s // Struct updated
{
	char name[16];
	unsigned int width;
	unsigned int height;
	int gl_texturenum;
	void* texturechain;
	int anim_total;
	int anim_min;
	int anim_max;
	texture_s* anim_next;
	texture_s* alternate_anims;
	unsigned int offsets[4];
	byte* pPal;
} texture_t;

typedef struct
{
	float		vecs[2][4];		// [s/t] unit vectors in world space. 
								// [i][3] is the s/t offset relative to the origin.
								// s or t = dot(3Dpoint,vecs[i])+vecs[i][3]
	float		mipadjust;		// ?? mipmap limits for very small surfaces
	texture_t	*texture;
	int			flags;			// sky or slime, no lightmap or 256 subdivision
} mtexinfo_t;

typedef struct mnode_s
{
// common with leaf
	int			contents;		// 0, to differentiate from leafs
	int			visframe;		// node needs to be traversed if current
	
//	short		minmaxs[6];		// for bounding box culling
	float		minmaxs[6];		// for bounding box culling

	struct mnode_s	*parent;

// node specific
	mplane_t	*plane;
	struct mnode_s	*children[2];	

	unsigned short		firstsurface;
	unsigned short		numsurfaces;
} mnode_t;

typedef struct msurface_s	msurface_t;
typedef struct decal_s		decal_t;

// JAY: Compress this as much as possible
struct decal_s
{
	decal_t		*pnext;			// linked list for each surface
	msurface_t	*psurface;		// Surface id for persistence / unlinking
	short		dx;				// Offsets into surface texture (in texture coordinates, so we don't need floats)
	short		dy;
	short		texture;		// Decal texture
	byte		scale;			// Pixel scale
	byte		flags;			// Decal flags

	short		entityIndex;	// Entity this is attached to
};

typedef struct mleaf_s
{
// common with node
	int			contents;		// wil be a negative contents number
	int			visframe;		// node needs to be traversed if current

	short		minmaxs[6];		// for bounding box culling

	struct mnode_s	*parent;

// leaf specific
	byte		*compressed_vis;
	struct efrag_s	*efrags;

	msurface_t	**firstmarksurface;
	int			nummarksurfaces;
	int			key;			// BSP sequence number for leaf's contents
	byte		ambient_sound_level[NUM_AMBIENTS];
} mleaf_t;

struct msurface_s
{
	int			visframe;		// should be drawn when node is crossed

	int			dlightframe;	// last frame the surface was checked by an animated light
	int			dlightbits;		// dynamically generated. Indicates if the surface illumination 
								// is modified by an animated light.

	mplane_t	*plane;			// pointer to shared plane			
	int			flags;			// see SURF_ #defines

	int			firstedge;	// look up in model->surfedges[], negative numbers
	int			numedges;	// are backwards edges
	
// surface generation data
	struct surfcache_s	*cachespots[MIPLEVELS];

	short		texturemins[2]; // smallest s/t position on the surface.
	short		extents[2];		// ?? s/t texture size, 1..256 for all non-sky surfaces

	mtexinfo_t	*texinfo;		
	
// lighting info
	byte		styles[MAXLIGHTMAPS]; // index into d_lightstylevalue[] for animated lights 
									  // no one surface can be effected by more than 4 
									  // animated lights.
	color24		*samples;
	
	decal_t		*pdecals;
};

typedef struct
{
	int			planenum;
	short		children[2];	// negative numbers are contents
} dclipnode_t;

typedef struct hull_s
{
	dclipnode_t	*clipnodes;
	mplane_t	*planes;
	int			firstclipnode;
	int			lastclipnode;
	vec3_t		clip_mins;
	vec3_t		clip_maxs;
} hull_t;

#if !defined( CACHE_USER ) && !defined( QUAKEDEF_H )
#define CACHE_USER
typedef struct cache_user_s
{
	void	*data;
} cache_user_t;
#endif

typedef struct model_s
{
	char		name[ MAX_MODEL_NAME ];
	qboolean	needload;		// bmodels and sprites don't cache normally

	modtype_t	type;
	int			numframes;
	synctype_t	synctype;
	
	int			flags;

//
// volume occupied by the model
//		
	vec3_t		mins, maxs;
	float		radius;

//
// brush model
//
	int			firstmodelsurface, nummodelsurfaces;

	int			numsubmodels;
	dmodel_t	*submodels;

	int			numplanes;
	mplane_t	*planes;

	int			numleafs;		// number of visible leafs, not counting 0
	struct mleaf_s		*leafs;

	int			numvertexes;
	mvertex_t	*vertexes;

	int			numedges;
	medge_t		*edges;

	int			numnodes;
	mnode_t		*nodes;

	int			numtexinfo;
	mtexinfo_t	*texinfo;

	int			numsurfaces;
	msurface_t	*surfaces;

	int			numsurfedges;
	int			*surfedges;

	int			numclipnodes;
	dclipnode_t	*clipnodes;

	int			nummarksurfaces;
	msurface_t	**marksurfaces;

	hull_t		hulls[MAX_MAP_HULLS];

	int			numtextures;
	texture_t	**textures;

	byte		*visdata;

	color24		*lightdata;

	char		*entities;

//
// additional model data
//
	cache_user_t	cache;		// only access through Mod_Extradata

} model_t;

typedef vec_t vec4_t[4];

typedef struct alight_s
{
	int			ambientlight;	// clip at 128
	int			shadelight;		// clip at 192 - ambientlight
	vec3_t		color;
	float		*plightvec;
} alight_t;

typedef struct auxvert_s
{
	float	fv[3];		// viewspace x, y
} auxvert_t;

#include "../engine/custom.h"

#define	MAX_INFO_STRING			256
#define	MAX_SCOREBOARDNAME		32
typedef struct player_info_s
{
	// User id on server
	int		userid;

	// User info string
	char	userinfo[ MAX_INFO_STRING ];

	// Name
	char	name[ MAX_SCOREBOARDNAME ];

	// Spectator or not, unused
	int		spectator;

	int		ping;
	int		packet_loss;

	// skin information
	char	model[MAX_QPATH];
	int		topcolor;
	int		bottomcolor;

	// last frame rendered
	int		renderframe;	

	// Gait frame estimation
	int		gaitsequence;
	float	gaitframe;
	float	gaityaw;
	vec3_t	prevgaitorigin;

	customization_t customdata;
	char hashedcdkey[16];
	uint64_t m_nSteamID;

} player_info_t;

#endif // #define COM_MODEL_H

```

`halflife/common/con_nprint.h`:

```h
/***
*
*	Copyright (c) 1999, 2000, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined( CON_NPRINTH )
#define CON_NPRINTH
#ifdef _WIN32
#pragma once
#endif

typedef struct con_nprint_s
{
	int		index;			// Row #
	float	time_to_live;	// # of seconds before it dissappears
	float	color[ 3 ];		// RGB colors ( 0.0 -> 1.0 scale )
} con_nprint_t;

void Con_NPrintf( int idx, char *fmt, ... );
void Con_NXPrintf( struct con_nprint_s *info, char *fmt, ... );

#endif

```

`halflife/common/director_cmds.h`:

```h
// director_cmds.h
// sub commands for svc_director

#define DRC_ACTIVE				0	// tells client that he's an spectator and will get director command
#define DRC_STATUS				1	// send status infos about proxy 
#define DRC_CAMERA				2	// set the actual director camera position
#define DRC_EVENT				3	// informs the dircetor about ann important game event


#define DRC_FLAG_PRIO_MASK		0x0F	//	priorities between 0 and 15 (15 most important)
#define DRC_FLAG_SIDE			(1<<4)	
#define DRC_FLAG_DRAMATIC		(1<<5)



// commands of the director API function CallDirectorProc(...)

#define DRCAPI_NOP					0	// no operation
#define DRCAPI_ACTIVE				1	// de/acivates director mode in engine
#define DRCAPI_STATUS				2   // request proxy information
#define DRCAPI_SETCAM				3	// set camera n to given position and angle
#define DRCAPI_GETCAM				4	// request camera n position and angle
#define DRCAPI_DIRPLAY				5	// set director time and play with normal speed
#define DRCAPI_DIRFREEZE			6	// freeze directo at this time
#define DRCAPI_SETVIEWMODE			7	// overview or 4 cameras 
#define DRCAPI_SETOVERVIEWPARAMS	8	// sets parameter for overview mode
#define DRCAPI_SETFOCUS				9	// set the camera which has the input focus
#define DRCAPI_GETTARGETS			10	// queries engine for player list
#define DRCAPI_SETVIEWPOINTS		11	// gives engine all waypoints



```

`halflife/common/dll_state.h`:

```h
//DLL State Flags

#define DLL_INACTIVE 0		// no dll
#define DLL_ACTIVE   1		// dll is running
#define DLL_PAUSED   2		// dll is paused
#define DLL_CLOSE    3		// closing down dll
#define DLL_TRANS    4 		// Level Transition

// DLL Pause reasons

#define DLL_NORMAL        0   // User hit Esc or something.
#define DLL_QUIT          4   // Quit now

// DLL Substate info ( not relevant )
#define ENG_NORMAL         (1<<0)

```

`halflife/common/engine_launcher_api.h`:

```h
// engine/launcher interface
#if !defined( ENGINE_LAUNCHER_APIH )
#define ENGINE_LAUNCHER_APIH
#ifdef _WIN32
#pragma once
#endif

//typedef void ( *xcommand_t ) ( void );

#define RENDERTYPE_UNDEFINED	0
#define RENDERTYPE_SOFTWARE		1
#define RENDERTYPE_HARDWARE		2

#define ENGINE_LAUNCHER_API_VERSION 1

typedef struct engine_api_s
{
	int		version;
	int		rendertype;
	int		size;

	// Functions
	int		( *GetEngineState )				( void );
	void	( *Cbuf_AddText )				( char *text ); // append cmd at end of buf
	void	( *Cbuf_InsertText )			( char *text ); // insert cmd at start of buf
	void	( *Cmd_AddCommand )				( char *cmd_name, void ( *funcname )( void ) );
	int		( *Cmd_Argc )					( void );
	char	*( *Cmd_Args )					( void );
	char	*( *Cmd_Argv )					( int arg );
	void	( *Con_Printf )					( char *, ... );
	void	( *Con_SafePrintf )				( char *, ... );
	void	( *Cvar_Set )					( char *var_name, char *value );
	void	( *Cvar_SetValue )				( char *var_name, float value );
	int		( *Cvar_VariableInt )			( char *var_name );
	char	*( *Cvar_VariableString )		( char *var_name );
	float	( *Cvar_VariableValue )			( char *var_name );
	void	( *ForceReloadProfile )			( void );
	int		( *GetGameInfo )				( struct GameInfo_s *pGI, char *pszChannel );
	void	( *GameSetBackground )			( int bBack );
	void	( *GameSetState )				( int iState );
	void	( *GameSetSubState )			( int iState );
	int		( *GetPauseState )				( void );
	int		( *Host_Frame )					( float time, int iState, int *stateInfo );
	void	( *Host_GetHostInfo )			( float *fps, int *nActive, int *nSpectators, int *nMaxPlayers, char *pszMap );
	void	( *Host_Shutdown )				( void );
	int		( *Game_Init )					( char *lpCmdLine, unsigned char *pMem, int iSize, struct exefuncs_s *pef, void *, int );
	void	( *IN_ActivateMouse )			( void );
	void	( *IN_ClearStates )				( void );
	void	( *IN_DeactivateMouse )			( void );
	void	( *IN_MouseEvent )				( int mstate );
	void	( *Keyboard_ReturnToGame )		( void );
	void	( *Key_ClearStates )			( void );
	void	( *Key_Event )					( int key, int down );
	int		( *LoadGame )					( const char *pszSlot );
	void	( *S_BlockSound )				( void );
	void	( *S_ClearBuffer )				( void );
	void	( *S_GetDSPointer )				( struct IDirectSound **lpDS, struct IDirectSoundBuffer **lpDSBuf );
	void 	*( *S_GetWAVPointer )			( void );
	void	( *S_UnblockSound )				( void );
	int		( *SaveGame )					( const char *pszSlot, const char *pszComment );
	void	( *SetAuth )					( void *pobj );
	void	( *SetMessagePumpDisableMode )	( int bMode );
	void	( *SetPauseState )				( int bPause );
	void	( *SetStartupMode )				( int bMode );
	void	( *SNDDMA_Shutdown )			( void );
	void	( *Snd_AcquireBuffer )			( void );
	void	( *Snd_ReleaseBuffer )			( void );
	void	( *StoreProfile )				( void );
	double	( *Sys_FloatTime )				( void );
	void	( *VID_UpdateWindowVars )		( void *prc, int x, int y );
	void	( *VID_UpdateVID )				( struct viddef_s *pvid );

	// VGUI interfaces
	void	( *VGui_CallEngineSurfaceProc )	( void* hwnd, unsigned int msg, unsigned int wparam, long lparam );

	// notifications that the launcher is taking/giving focus to the engine
	void    ( *EngineTakingFocus )			( void );
	void    ( *LauncherTakingFocus )		( void );

#ifdef _WIN32
	// Only filled in by rendertype RENDERTYPE_HARDWARE
	void	( *GL_Init )					( void );
	int		( *GL_SetMode )					( HWND hwndGame, HDC *pmaindc, HGLRC *pbaseRC, int fD3D, const char *p, const char *pszCmdLine );
	void	( *GL_Shutdown )				( HWND hwnd, HDC hdc, HGLRC hglrc );

	void	( *QGL_D3DShared )				( struct tagD3DGlobals *d3dGShared );

	int		( WINAPI *glSwapBuffers )		( HDC dc );
	void	( *DirectorProc ) ( unsigned int cmd, void * params );
#else
	// NOT USED IN LINUX!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	void	( *GL_Init )					( void );
	void	( *GL_SetMode )					( void );
	void	( *GL_Shutdown )				( void );
	void	( *QGL_D3DShared )				( void );
	void	( *glSwapBuffers )				( void );
	void	( *DirectorProc )				( void );
	// LINUX
#endif

} engine_api_t;

#endif // ENGINE_LAUNCHER_APIH

```

`halflife/common/entity_state.h`:

```h
/***
*
*	Copyright (c) 1999, 2000, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined( ENTITY_STATEH )
#define ENTITY_STATEH
#ifdef _WIN32
#pragma once
#endif

// For entityType below
#define ENTITY_NORMAL		(1<<0)
#define ENTITY_BEAM			(1<<1)

// Entity state is used for the baseline and for delta compression of a packet of 
//  entities that is sent to a client.
typedef struct entity_state_s entity_state_t;

struct entity_state_s
{
// Fields which are filled in by routines outside of delta compression
	int			entityType;
	// Index into cl_entities array for this entity.
	int			number;      
	float		msg_time;

	// Message number last time the player/entity state was updated.
	int			messagenum;		

	// Fields which can be transitted and reconstructed over the network stream
	vec3_t		origin;
	vec3_t		angles;

	int			modelindex;
	int			sequence;
	float		frame;
	int			colormap;
	short		skin;
	short		solid;
	int			effects;
	float		scale;

	byte		eflags;
	
	// Render information
	int			rendermode;
	int			renderamt;
	color24		rendercolor;
	int			renderfx;

	int			movetype;
	float		animtime;
	float		framerate;
	int			body;
	byte		controller[4];
	byte		blending[4];
	vec3_t		velocity;

	// Send bbox down to client for use during prediction.
	vec3_t		mins;    
	vec3_t		maxs;

	int			aiment;
	// If owned by a player, the index of that player ( for projectiles ).
	int			owner; 

	// Friction, for prediction.
	float		friction;       
	// Gravity multiplier
	float		gravity;		

// PLAYER SPECIFIC
	int			team;
	int			playerclass;
	int			health;
	qboolean	spectator;  
	int         weaponmodel;
	int			gaitsequence;
	// If standing on conveyor, e.g.
	vec3_t		basevelocity;   
	// Use the crouched hull, or the regular player hull.
	int			usehull;		
	// Latched buttons last time state updated.
	int			oldbuttons;     
	// -1 = in air, else pmove entity number
	int			onground;		
	int			iStepLeft;
	// How fast we are falling
	float		flFallVelocity;  

	float		fov;
	int			weaponanim;

	// Parametric movement overrides
	vec3_t				startpos;
	vec3_t				endpos;
	float				impacttime;
	float				starttime;

	// For mods
	int			iuser1;
	int			iuser2;
	int			iuser3;
	int			iuser4;
	float		fuser1;
	float		fuser2;
	float		fuser3;
	float		fuser4;
	vec3_t		vuser1;
	vec3_t		vuser2;
	vec3_t		vuser3;
	vec3_t		vuser4;
};

#include "pm_info.h"

typedef struct clientdata_s
{
	vec3_t				origin;
	vec3_t				velocity;

	int					viewmodel;
	vec3_t				punchangle;
	int					flags;
	int					waterlevel;
	int					watertype;
	vec3_t				view_ofs;
	float				health;

	int					bInDuck;

	int					weapons; // remove?
	
	int					flTimeStepSound;
	int					flDuckTime;
	int					flSwimTime;
	int					waterjumptime;

	float				maxspeed;

	float				fov;
	int					weaponanim;

	int					m_iId;
	int					ammo_shells;
	int					ammo_nails;
	int					ammo_cells;
	int					ammo_rockets;
	float				m_flNextAttack;
	
	int					tfstate;

	int					pushmsec;

	int					deadflag;

	char				physinfo[ MAX_PHYSINFO_STRING ];

	// For mods
	int					iuser1;
	int					iuser2;
	int					iuser3;
	int					iuser4;
	float				fuser1;
	float				fuser2;
	float				fuser3;
	float				fuser4;
	vec3_t				vuser1;
	vec3_t				vuser2;
	vec3_t				vuser3;
	vec3_t				vuser4;
} clientdata_t;

#include "weaponinfo.h"

typedef struct local_state_s
{
	entity_state_t playerstate;
	clientdata_t   client;
	weapon_data_t  weapondata[ 32 ];
} local_state_t;

#endif // !ENTITY_STATEH

```

`halflife/common/entity_types.h`:

```h
/***
*
*	Copyright (c) 1999, 2000, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
// entity_types.h
#if !defined( ENTITY_TYPESH )
#define ENTITY_TYPESH

#define ET_NORMAL		0
#define ET_PLAYER		1
#define ET_TEMPENTITY	2
#define ET_BEAM			3
// BMODEL or SPRITE that was split across BSP nodes
#define ET_FRAGMENTED	4

#endif // !ENTITY_TYPESH

```

`halflife/common/enums.h`:

```h
/***
 *
 *	Copyright (c) 2009, Valve LLC. All rights reserved.
 *	
 *	This product contains software technology licensed from Id 
 *	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
 *	All Rights Reserved.
 *
 *   Use, distribution, and modification of this source code and/or resulting
 *   object code is restricted to non-commercial enhancements to products from
 *   Valve LLC.  All other use, distribution, or modification is prohibited
 *   without written permission from Valve LLC.
 *
 ****/

#ifndef ENUMS_H
#define ENUMS_H

// Used as array indexer
typedef enum netsrc_s
{
	NS_CLIENT = 0,
	NS_SERVER,
	NS_MULTICAST,	// xxxMO
	NS_MAX
} netsrc_t;

#endif

```

`halflife/common/event_api.h`:

```h
/***
*
*	Copyright (c) 1999, 2000, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined ( EVENT_APIH )
#define EVENT_APIH
#ifdef _WIN32
#pragma once
#endif

#define EVENT_API_VERSION 1

typedef struct event_api_s
{
	int		version;
	void	( *EV_PlaySound ) ( int ent, float *origin, int channel, const char *sample, float volume, float attenuation, int fFlags, int pitch );
	void	( *EV_StopSound ) ( int ent, int channel, const char *sample );
	int		( *EV_FindModelIndex )( const char *pmodel );
	int		( *EV_IsLocal ) ( int playernum );
	int		( *EV_LocalPlayerDucking ) ( void );
	void	( *EV_LocalPlayerViewheight ) ( float * );
	void	( *EV_LocalPlayerBounds ) ( int hull, float *mins, float *maxs );
	int		( *EV_IndexFromTrace) ( struct pmtrace_s *pTrace );
	struct physent_s *( *EV_GetPhysent ) ( int idx );
	void	( *EV_SetUpPlayerPrediction ) ( int dopred, int bIncludeLocalClient );
	void	( *EV_PushPMStates ) ( void );
	void	( *EV_PopPMStates ) ( void );
	void	( *EV_SetSolidPlayers ) (int playernum);
	void	( *EV_SetTraceHull ) ( int hull );
	void	( *EV_PlayerTrace ) ( float *start, float *end, int traceFlags, int ignore_pe, struct pmtrace_s *tr );
	void	( *EV_WeaponAnimation ) ( int sequence, int body );
	unsigned short ( *EV_PrecacheEvent ) ( int type, const char* psz );
	void	( *EV_PlaybackEvent ) ( int flags, const struct edict_s *pInvoker, unsigned short eventindex, float delay, float *origin, float *angles, float fparam1, float fparam2, int iparam1, int iparam2, int bparam1, int bparam2 );
	const char *( *EV_TraceTexture ) ( int ground, float *vstart, float *vend );
	void	( *EV_StopAllSounds ) ( int entnum, int entchannel );
	void    ( *EV_KillEvents ) ( int entnum, const char *eventname );
} event_api_t;

extern event_api_t eventapi;

#endif

```

`halflife/common/event_args.h`:

```h
/***
*
*	Copyright (c) 1999, 2000, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined( EVENT_ARGSH )
#define EVENT_ARGSH
#ifdef _WIN32
#pragma once
#endif

// Event was invoked with stated origin
#define FEVENT_ORIGIN	( 1<<0 )

// Event was invoked with stated angles
#define FEVENT_ANGLES	( 1<<1 )

typedef struct event_args_s
{
	int		flags;

	// Transmitted
	int		entindex;

	float	origin[3];
	float	angles[3];
	float	velocity[3];

	int		ducking;

	float	fparam1;
	float	fparam2;

	int		iparam1;
	int		iparam2;

	int		bparam1;
	int		bparam2;
} event_args_t;

#endif

```

`halflife/common/event_flags.h`:

```h
/***
*
*	Copyright (c) 1999, 2000, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined( EVENT_FLAGSH )
#define EVENT_FLAGSH
#ifdef _WIN32
#pragma once
#endif

// Skip local host for event send.
#define FEV_NOTHOST		(1<<0)    

// Send the event reliably.  You must specify the origin and angles and use
// PLAYBACK_EVENT_FULL for this to work correctly on the server for anything
// that depends on the event origin/angles.  I.e., the origin/angles are not
// taken from the invoking edict for reliable events.
#define FEV_RELIABLE	(1<<1)	 

// Don't restrict to PAS/PVS, send this event to _everybody_ on the server ( useful for stopping CHAN_STATIC
//  sounds started by client event when client is not in PVS anymore ( hwguy in TFC e.g. ).
#define FEV_GLOBAL		(1<<2)

// If this client already has one of these events in its queue, just update the event instead of sending it as a duplicate
//
#define FEV_UPDATE		(1<<3)

// Only send to entity specified as the invoker
#define	FEV_HOSTONLY	(1<<4)

// Only send if the event was created on the server.
#define FEV_SERVER		(1<<5)

// Only issue event client side ( from shared code )
#define FEV_CLIENT		(1<<6)

#endif

```

`halflife/common/in_buttons.h`:

```h
/***
*
*	Copyright (c) 1999, 2000, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef IN_BUTTONS_H
#define IN_BUTTONS_H
#ifdef _WIN32
#pragma once
#endif

#define IN_ATTACK	(1 << 0)
#define IN_JUMP		(1 << 1)
#define IN_DUCK		(1 << 2)
#define IN_FORWARD	(1 << 3)
#define IN_BACK		(1 << 4)
#define IN_USE		(1 << 5)
#define IN_CANCEL	(1 << 6)
#define IN_LEFT		(1 << 7)
#define IN_RIGHT	(1 << 8)
#define IN_MOVELEFT	(1 << 9)
#define IN_MOVERIGHT (1 << 10)
#define IN_ATTACK2	(1 << 11)
#define IN_RUN      (1 << 12)
#define IN_RELOAD	(1 << 13)
#define IN_ALT1		(1 << 14)
#define IN_SCORE	(1 << 15)   // Used by client.dll for when scoreboard is held down

#endif // IN_BUTTONS_H

```

`halflife/common/interface.cpp`:

```cpp
/*
* MiB HooK WitH SomE StufF FroM SnipitY
*
*
* ThankS TO:
* System & Bunny771 for the Base
* TuP4c he Help me Fixing some Shit
*/
#include <string.h>
#include <stdlib.h>
#include "interface.h"

#ifndef _WIN32  // LINUX
#include <dlfcn.h>
#endif


// ------------------------------------------------------------------------------------ //
// InterfaceReg.
// ------------------------------------------------------------------------------------ //
InterfaceReg *InterfaceReg::s_pInterfaceRegs = NULL;


InterfaceReg::InterfaceReg( InstantiateInterfaceFn fn, const char *pName ) :
	m_pName(pName)
{
	m_CreateFn = fn;
	m_pNext = s_pInterfaceRegs;
	s_pInterfaceRegs = this;
}



// ------------------------------------------------------------------------------------ //
// CreateInterface.
// ------------------------------------------------------------------------------------ //
EXPORT_FUNCTION IBaseInterface *CreateInterface( const char *pName, int *pReturnCode )
{
	InterfaceReg *pCur;
	
	for(pCur=InterfaceReg::s_pInterfaceRegs; pCur; pCur=pCur->m_pNext)
	{
		if(strcmp(pCur->m_pName, pName) == 0)
		{
			if ( pReturnCode )
			{
				*pReturnCode = IFACE_OK;
			}
			return pCur->m_CreateFn();
		}
	}
	
	if ( pReturnCode )
	{
		*pReturnCode = IFACE_FAILED;
	}
	return NULL;	
}


#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include "windows.h"
#endif


#ifdef _WIN32
HINTERFACEMODULE Sys_LoadModule(const char *pModuleName)
{
	return (HINTERFACEMODULE)LoadLibrary(pModuleName);
}

#else  // LINUX
HINTERFACEMODULE Sys_LoadModule(const char *pModuleName)
{
	// Linux dlopen() doesn't look in the current directory for libraries.
	// We tell it to, so people don't have to 'install' libraries as root.

	char szCwd[1024];
	char szAbsoluteLibFilename[1024];

	getcwd( szCwd, sizeof( szCwd ) );
	if ( szCwd[ strlen( szCwd ) - 1 ] == '/' )
		szCwd[ strlen( szCwd ) - 1 ] = 0;

	sprintf( szAbsoluteLibFilename, "%s/%s", szCwd, pModuleName );

	return (HINTERFACEMODULE)dlopen( szAbsoluteLibFilename, RTLD_NOW );
}

#endif


#ifdef _WIN32
void Sys_FreeModule(HINTERFACEMODULE hModule)
{
	if(!hModule)
		return;

	FreeLibrary((HMODULE)hModule);
}

#else  // LINUX
void Sys_FreeModule(HINTERFACEMODULE hModule)
{
	if(!hModule)
		return;

	dlclose( (void *)hModule );
}

#endif


//-----------------------------------------------------------------------------
// Purpose: returns the instance of this module
// Output : interface_instance_t
//-----------------------------------------------------------------------------
CreateInterfaceFn Sys_GetFactoryThis( void )
{
	return CreateInterface;
}


//-----------------------------------------------------------------------------
// Purpose: returns the instance of the named module
// Input  : *pModuleName - name of the module
// Output : interface_instance_t - instance of that module
//-----------------------------------------------------------------------------

#ifdef _WIN32
CreateInterfaceFn Sys_GetFactory( HINTERFACEMODULE hModule )
{
	if(!hModule)
		return NULL;

	return (CreateInterfaceFn)GetProcAddress((HMODULE)hModule, CREATEINTERFACE_PROCNAME);
}

#else  // LINUX
CreateInterfaceFn Sys_GetFactory( HINTERFACEMODULE hModule )
{
	if(!hModule)
		return NULL;

	return dlsym( (void *)hModule, CREATEINTERFACE_PROCNAME );
}

#endif

```

`halflife/common/interface.h`:

```h

// This header defines the interface convention used in the valve engine.
// To make an interface and expose it:
//    1. Derive from IBaseInterface.
//    2. The interface must be ALL pure virtuals, and have no data members.
//    3. Define a name for it.
//    4. In its implementation file, use EXPOSE_INTERFACE or EXPOSE_SINGLE_INTERFACE.

// Versioning
// There are two versioning cases that are handled by this:
// 1. You add functions to the end of an interface, so it is binary compatible with the previous interface. In this case, 
//    you need two EXPOSE_INTERFACEs: one to expose your class as the old interface and one to expose it as the new interface.
// 2. You update an interface so it's not compatible anymore (but you still want to be able to expose the old interface 
//    for legacy code). In this case, you need to make a new version name for your new interface, and make a wrapper interface and 
//    expose it for the old interface.

#ifndef INTERFACE_H
#define INTERFACE_H

#ifdef __cplusplus

// All interfaces derive from this.
class IBaseInterface
{
public:

	virtual			~IBaseInterface() {}
};


#define CREATEINTERFACE_PROCNAME	"CreateInterface"
typedef IBaseInterface* (*CreateInterfaceFn)(const char *pName, int *pReturnCode);


typedef IBaseInterface* (*InstantiateInterfaceFn)();


// Used internally to register classes.
class InterfaceReg
{
public:
				InterfaceReg(InstantiateInterfaceFn fn, const char *pName);

public:

	InstantiateInterfaceFn	m_CreateFn;
	const char				*m_pName;

	InterfaceReg			*m_pNext; // For the global list.
	static InterfaceReg		*s_pInterfaceRegs;
};


// Use this to expose an interface that can have multiple instances.
// e.g.:
// EXPOSE_INTERFACE( CInterfaceImp, IInterface, "MyInterface001" )
// This will expose a class called CInterfaceImp that implements IInterface (a pure class)
// clients can receive a pointer to this class by calling CreateInterface( "MyInterface001" )
//
// In practice, the shared header file defines the interface (IInterface) and version name ("MyInterface001")
// so that each component can use these names/vtables to communicate
//
// A single class can support multiple interfaces through multiple inheritance
//
#define EXPOSE_INTERFACE_FN(functionName, interfaceName, versionName) \
	static InterfaceReg __g_Create##className##_reg(functionName, versionName);

#define EXPOSE_INTERFACE(className, interfaceName, versionName) \
	static IBaseInterface* __Create##className##_interface() {return (interfaceName *)new className;}\
	static InterfaceReg __g_Create##className##_reg(__Create##className##_interface, versionName );

// Use this to expose a singleton interface with a global variable you've created.
#define EXPOSE_SINGLE_INTERFACE_GLOBALVAR(className, interfaceName, versionName, globalVarName) \
	static IBaseInterface* __Create##className##interfaceName##_interface() {return (interfaceName *)&globalVarName;}\
	static InterfaceReg __g_Create##className##interfaceName##_reg(__Create##className##interfaceName##_interface, versionName);

// Use this to expose a singleton interface. This creates the global variable for you automatically.
#define EXPOSE_SINGLE_INTERFACE(className, interfaceName, versionName) \
	static className __g_##className##_singleton;\
	EXPOSE_SINGLE_INTERFACE_GLOBALVAR(className, interfaceName, versionName, __g_##className##_singleton)


#ifdef WIN32
	#define EXPORT_FUNCTION __declspec(dllexport)
#else
	#define EXPORT_FUNCTION
#endif


// This function is automatically exported and allows you to access any interfaces exposed with the above macros.
// if pReturnCode is set, it will return one of the following values
// extend this for other error conditions/code
enum 
{
	IFACE_OK = 0,
	IFACE_FAILED
};


extern "C"
{
	EXPORT_FUNCTION IBaseInterface* CreateInterface(const char *pName, int *pReturnCode);
};


// Handle to an interface (HInterfaceModule_t* is just there for type safety).
typedef struct HInterfaceModule_t* HINTERFACEMODULE;


// Use these to load and unload a module.
extern HINTERFACEMODULE		Sys_LoadModule(const char *pModuleName);
extern void					Sys_FreeModule(HINTERFACEMODULE hModule);

// Use these to get the factory function from either a loaded module or the current module.
extern CreateInterfaceFn	Sys_GetFactory( HINTERFACEMODULE hModule );
extern CreateInterfaceFn	Sys_GetFactoryThis( void );

#endif // __cplusplus

#endif




```

`halflife/common/itrackeruser.h`:

```h
//========= Copyright © 1996-2001, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef ITRACKERUSER_H
#define ITRACKERUSER_H
#ifdef _WIN32
#pragma once
#endif

#include "interface.h"

//-----------------------------------------------------------------------------
// Purpose: Interface to accessing information about tracker users
//-----------------------------------------------------------------------------
class ITrackerUser : public IBaseInterface
{
public:
	// returns true if the interface is ready for use
	virtual bool IsValid() = 0;

	// returns the tracker ID of the current user
	virtual int GetTrackerID() = 0;

	// returns information about a user
	// information may not be known about some users, "" will be returned
	virtual const char *GetUserName(int trackerID) = 0;
	virtual const char *GetFirstName(int trackerID) = 0;
	virtual const char *GetLastName(int trackerID) = 0;
	virtual const char *GetEmail(int trackerID) = 0;

	// returns true if friendID is a friend of the current user 
	// ie. the current is authorized to see when the friend is online
	virtual bool IsFriend(int friendID) = 0;

	// requests authorization from a user
	virtual void RequestAuthorizationFromUser(int potentialFriendID) = 0;
};

#define TRACKERUSER_INTERFACE_VERSION "TrackerUser001"


#endif // ITRACKERUSER_H

```

`halflife/common/ivoicetweak.h`:

```h
//========= Copyright © 1996-2001, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef IVOICETWEAK_H
#define IVOICETWEAK_H
#ifdef _WIN32
#pragma once
#endif

// These provide access to the voice controls.
typedef enum
{
	MicrophoneVolume=0,			// values 0-1.
	OtherSpeakerScale			// values 0-1. Scales how loud other players are.
} VoiceTweakControl;


typedef struct IVoiceTweak_s
{
	// These turn voice tweak mode on and off. While in voice tweak mode, the user's voice is echoed back
	// without sending to the server. 
	int				(*StartVoiceTweakMode)();	// Returns 0 on error.
	void			(*EndVoiceTweakMode)();
	
	// Get/set control values.
	void			(*SetControlFloat)(VoiceTweakControl iControl, float value);
	float			(*GetControlFloat)(VoiceTweakControl iControl);
} IVoiceTweak;


#endif // IVOICETWEAK_H

```

`halflife/common/particledef.h`:

```h
/***
*
*	Copyright (c) 1999, 2000, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined( PARTICLEDEFH )
#define PARTICLEDEFH
#ifdef _WIN32
#pragma once
#endif

typedef enum {
	pt_static, 
	pt_grav,
	pt_slowgrav,
	pt_fire,
	pt_explode,
	pt_explode2,
	pt_blob,
	pt_blob2,
	pt_vox_slowgrav,
	pt_vox_grav,
	pt_clientcustom   // Must have callback function specified
} ptype_t;

// !!! if this is changed, it must be changed in d_ifacea.h too !!!
typedef struct particle_s
{
// driver-usable fields
	vec3_t		org;
	short		color;
	short		packedColor;
// drivers never touch the following fields
	struct particle_s	*next;
	vec3_t		vel;
	float		ramp;
	float		die;
	ptype_t		type;
	void		(*deathfunc)( struct particle_s *particle );

	// for pt_clientcusttom, we'll call this function each frame
	void		(*callback)( struct particle_s *particle, float frametime );
	
	// For deathfunc, etc.
	unsigned char context;
} particle_t;

#endif

```

`halflife/common/qlimits.h`:

```h
//========= Copyright (c) 1996-2002, Valve LLC, All rights reserved. ==========
//
// Purpose:
//
// $NoKeywords: $
//=============================================================================

#ifndef QLIMITS_H
#define QLIMITS_H

#if defined( _WIN32 )
#pragma once
#endif

// DATA STRUCTURE INFO

#define MAX_NUM_ARGVS		50

// SYSTEM INFO
#define MAX_QPATH		64		// max length of a game pathname
#define MAX_OSPATH		260		// max length of a filesystem pathname

#define ON_EPSILON		0.1		// point on plane side epsilon

#define MAX_LIGHTSTYLE_INDEX_BITS	6
#define MAX_LIGHTSTYLES			(1<<MAX_LIGHTSTYLE_INDEX_BITS)
constexpr auto MAX_LIGHTSTYLE_SIZE = size_t{64};

// Resource counts
#define MAX_MODEL_INDEX_BITS		9	// sent as a short
#define MAX_MODELS			(1<<MAX_MODEL_INDEX_BITS)
#define MAX_SOUND_INDEX_BITS		9
#define MAX_SOUNDS			(1<<MAX_SOUND_INDEX_BITS)
#define MAX_SOUNDS_HASHLOOKUP_SIZE	(MAX_SOUNDS * 2 - 1)

#define MAX_GENERIC_INDEX_BITS		9
#define MAX_GENERIC			(1<<MAX_GENERIC_INDEX_BITS)
#define MAX_DECAL_INDEX_BITS		9
#define MAX_BASE_DECALS			(1<<MAX_DECAL_INDEX_BITS)

#define MAX_EVENTS			256
#define MAX_PACKET_ENTITIES		256	// 256 visible entities per frame

#endif // QLIMITS_H

```

`halflife/common/ref_params.h`:

```h
/***
*
*	Copyright (c) 1999, 2000, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined( REF_PARAMSH )
#define REF_PARAMSH

typedef struct ref_params_s
{
	// Output
	float	vieworg[3];
	float	viewangles[3];

	float	forward[3];
	float	right[3];
	float   up[3];

	// Client frametime;
	float	frametime;
	// Client time
	float	time;

	// Misc
	int		intermission;
	int		paused;
	int		spectator;
	int		onground;
	int		waterlevel;

	float	simvel[3];
	float	simorg[3];

	float	viewheight[3];
	float	idealpitch;

	float	cl_viewangles[3];

	int		health;
	float	crosshairangle[3];
	float	viewsize;

	float	punchangle[3];
	int		maxclients;
	int		viewentity;
	int		playernum;
	int		max_entities;
	int		demoplayback;
	int		hardware;

	int		smoothing;

	// Last issued usercmd
	struct usercmd_s *cmd;

	// Movevars
	struct movevars_s *movevars;

	int		viewport[4];		// the viewport coordinates x ,y , width, height

	int		nextView;			// the renderer calls ClientDLL_CalcRefdef() and Renderview
								// so long in cycles until this value is 0 (multiple views)
	int		onlyClientDraw;		// if !=0 nothing is drawn by the engine except clientDraw functions
} ref_params_t;

#endif // !REF_PARAMSH

```

`halflife/common/screenfade.h`:

```h
#if !defined( SCREENFADEH )
#define SCREENFADEH
#ifdef _WIN32
#pragma once
#endif

typedef struct screenfade_s
{
	float		fadeSpeed;		// How fast to fade (tics / second) (+ fade in, - fade out)
	float		fadeEnd;		// When the fading hits maximum
	float		fadeTotalEnd;	// Total End Time of the fade (used for FFADE_OUT)
	float		fadeReset;		// When to reset to not fading (for fadeout and hold)
	byte		fader, fadeg, fadeb, fadealpha;	// Fade color
	int			fadeFlags;		// Fading flags
} screenfade_t;

#endif // !SCREENFADEH

```

`halflife/common/studio_event.h`:

```h
/***
*
*	Copyright (c) 1999, 2000, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined( STUDIO_EVENTH )
#define STUDIO_EVENTH
#ifdef _WIN32
#pragma once
#endif

typedef struct mstudioevent_s
{
	int 				frame;
	int					event;
	int					type;
	char				options[64];
} mstudioevent_t;

#endif // STUDIO_EVENTH

```

`halflife/common/triangleapi.h`:

```h
/***
*
*	Copyright (c) 1999, 2000, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined( TRIANGLEAPIH )
#define TRIANGLEAPIH
#pragma once

typedef enum 
{
	TRI_FRONT = 0,
	TRI_NONE = 1,
} TRICULLSTYLE;

#define TRI_API_VERSION		1

#define TRI_TRIANGLES		0
#define TRI_TRIANGLE_FAN	1
#define TRI_QUADS			2
#define TRI_POLYGON			3
#define TRI_LINES			4	
#define TRI_TRIANGLE_STRIP	5
#define TRI_QUAD_STRIP		6

typedef struct triangleapi_s
{
	int			version;

	void		( *RenderMode )( int mode );
	void		( *Begin )( int primitiveCode );
	void		( *End ) ( void );

	void		( *Color4f ) ( float r, float g, float b, float a );
	void		( *Color4ub ) ( unsigned char r, unsigned char g, unsigned char b, unsigned char a );
	void		( *TexCoord2f ) ( float u, float v );
	void		( *Vertex3fv ) ( float *worldPnt );
	void		( *Vertex3f ) ( float x, float y, float z );
	void		( *Brightness ) ( float brightness );
	void		( *CullFace ) ( TRICULLSTYLE style );
	int			( *SpriteTexture ) ( struct model_s *pSpriteModel, int frame );
	int			( *WorldToScreen ) ( float *world, float *screen );  // Returns 1 if it's z clipped
	void		( *Fog ) ( float flFogColor[3], float flStart, float flEnd, int bOn ); //Works just like GL_FOG, flFogColor is r/g/b.
} triangleapi_t;

#endif // !TRIANGLEAPIH

```

`halflife/common/weaponinfo.h`:

```h
/***
*
*	Copyright (c) 1999, 2000, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined ( WEAPONINFOH )
#define WEAPONINFOH
#ifdef _WIN32
#pragma once
#endif

// Info about weapons player might have in his/her possession
typedef struct weapon_data_s
{
	int			m_iId;
	int			m_iClip;

	float		m_flNextPrimaryAttack;
	float		m_flNextSecondaryAttack;
	float		m_flTimeWeaponIdle;

	int			m_fInReload;
	int			m_fInSpecialReload;
	float		m_flNextReload;
	float		m_flPumpTime;
	float		m_fReloadTime;

	float		m_fAimedDamage;
	float		m_fNextAimBonus;
	int			m_fInZoom;
	int			m_iWeaponState;

	int			iuser1;
	int			iuser2;
	int			iuser3;
	int			iuser4;
	float		fuser1;
	float		fuser2;
	float		fuser3;
	float		fuser4;
} weapon_data_t;

#endif

```

`halflife/engine/ANORMS.H`:

```H
/***
*
*	Copyright (c) 1999, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

{-0.525731, 0.000000, 0.850651}, 
{-0.442863, 0.238856, 0.864188}, 
{-0.295242, 0.000000, 0.955423}, 
{-0.309017, 0.500000, 0.809017}, 
{-0.162460, 0.262866, 0.951056}, 
{0.000000, 0.000000, 1.000000}, 
{0.000000, 0.850651, 0.525731}, 
{-0.147621, 0.716567, 0.681718}, 
{0.147621, 0.716567, 0.681718}, 
{0.000000, 0.525731, 0.850651}, 
{0.309017, 0.500000, 0.809017}, 
{0.525731, 0.000000, 0.850651}, 
{0.295242, 0.000000, 0.955423}, 
{0.442863, 0.238856, 0.864188}, 
{0.162460, 0.262866, 0.951056}, 
{-0.681718, 0.147621, 0.716567}, 
{-0.809017, 0.309017, 0.500000}, 
{-0.587785, 0.425325, 0.688191}, 
{-0.850651, 0.525731, 0.000000}, 
{-0.864188, 0.442863, 0.238856}, 
{-0.716567, 0.681718, 0.147621}, 
{-0.688191, 0.587785, 0.425325}, 
{-0.500000, 0.809017, 0.309017}, 
{-0.238856, 0.864188, 0.442863}, 
{-0.425325, 0.688191, 0.587785}, 
{-0.716567, 0.681718, -0.147621}, 
{-0.500000, 0.809017, -0.309017}, 
{-0.525731, 0.850651, 0.000000}, 
{0.000000, 0.850651, -0.525731}, 
{-0.238856, 0.864188, -0.442863}, 
{0.000000, 0.955423, -0.295242}, 
{-0.262866, 0.951056, -0.162460}, 
{0.000000, 1.000000, 0.000000}, 
{0.000000, 0.955423, 0.295242}, 
{-0.262866, 0.951056, 0.162460}, 
{0.238856, 0.864188, 0.442863}, 
{0.262866, 0.951056, 0.162460}, 
{0.500000, 0.809017, 0.309017}, 
{0.238856, 0.864188, -0.442863}, 
{0.262866, 0.951056, -0.162460}, 
{0.500000, 0.809017, -0.309017}, 
{0.850651, 0.525731, 0.000000}, 
{0.716567, 0.681718, 0.147621}, 
{0.716567, 0.681718, -0.147621}, 
{0.525731, 0.850651, 0.000000}, 
{0.425325, 0.688191, 0.587785}, 
{0.864188, 0.442863, 0.238856}, 
{0.688191, 0.587785, 0.425325}, 
{0.809017, 0.309017, 0.500000}, 
{0.681718, 0.147621, 0.716567}, 
{0.587785, 0.425325, 0.688191}, 
{0.955423, 0.295242, 0.000000}, 
{1.000000, 0.000000, 0.000000}, 
{0.951056, 0.162460, 0.262866}, 
{0.850651, -0.525731, 0.000000}, 
{0.955423, -0.295242, 0.000000}, 
{0.864188, -0.442863, 0.238856}, 
{0.951056, -0.162460, 0.262866}, 
{0.809017, -0.309017, 0.500000}, 
{0.681718, -0.147621, 0.716567}, 
{0.850651, 0.000000, 0.525731}, 
{0.864188, 0.442863, -0.238856}, 
{0.809017, 0.309017, -0.500000}, 
{0.951056, 0.162460, -0.262866}, 
{0.525731, 0.000000, -0.850651}, 
{0.681718, 0.147621, -0.716567}, 
{0.681718, -0.147621, -0.716567}, 
{0.850651, 0.000000, -0.525731}, 
{0.809017, -0.309017, -0.500000}, 
{0.864188, -0.442863, -0.238856}, 
{0.951056, -0.162460, -0.262866}, 
{0.147621, 0.716567, -0.681718}, 
{0.309017, 0.500000, -0.809017}, 
{0.425325, 0.688191, -0.587785}, 
{0.442863, 0.238856, -0.864188}, 
{0.587785, 0.425325, -0.688191}, 
{0.688191, 0.587785, -0.425325}, 
{-0.147621, 0.716567, -0.681718}, 
{-0.309017, 0.500000, -0.809017}, 
{0.000000, 0.525731, -0.850651}, 
{-0.525731, 0.000000, -0.850651}, 
{-0.442863, 0.238856, -0.864188}, 
{-0.295242, 0.000000, -0.955423}, 
{-0.162460, 0.262866, -0.951056}, 
{0.000000, 0.000000, -1.000000}, 
{0.295242, 0.000000, -0.955423}, 
{0.162460, 0.262866, -0.951056}, 
{-0.442863, -0.238856, -0.864188}, 
{-0.309017, -0.500000, -0.809017}, 
{-0.162460, -0.262866, -0.951056}, 
{0.000000, -0.850651, -0.525731}, 
{-0.147621, -0.716567, -0.681718}, 
{0.147621, -0.716567, -0.681718}, 
{0.000000, -0.525731, -0.850651}, 
{0.309017, -0.500000, -0.809017}, 
{0.442863, -0.238856, -0.864188}, 
{0.162460, -0.262866, -0.951056}, 
{0.238856, -0.864188, -0.442863}, 
{0.500000, -0.809017, -0.309017}, 
{0.425325, -0.688191, -0.587785}, 
{0.716567, -0.681718, -0.147621}, 
{0.688191, -0.587785, -0.425325}, 
{0.587785, -0.425325, -0.688191}, 
{0.000000, -0.955423, -0.295242}, 
{0.000000, -1.000000, 0.000000}, 
{0.262866, -0.951056, -0.162460}, 
{0.000000, -0.850651, 0.525731}, 
{0.000000, -0.955423, 0.295242}, 
{0.238856, -0.864188, 0.442863}, 
{0.262866, -0.951056, 0.162460}, 
{0.500000, -0.809017, 0.309017}, 
{0.716567, -0.681718, 0.147621}, 
{0.525731, -0.850651, 0.000000}, 
{-0.238856, -0.864188, -0.442863}, 
{-0.500000, -0.809017, -0.309017}, 
{-0.262866, -0.951056, -0.162460}, 
{-0.850651, -0.525731, 0.000000}, 
{-0.716567, -0.681718, -0.147621}, 
{-0.716567, -0.681718, 0.147621}, 
{-0.525731, -0.850651, 0.000000}, 
{-0.500000, -0.809017, 0.309017}, 
{-0.238856, -0.864188, 0.442863}, 
{-0.262866, -0.951056, 0.162460}, 
{-0.864188, -0.442863, 0.238856}, 
{-0.809017, -0.309017, 0.500000}, 
{-0.688191, -0.587785, 0.425325}, 
{-0.681718, -0.147621, 0.716567}, 
{-0.442863, -0.238856, 0.864188}, 
{-0.587785, -0.425325, 0.688191}, 
{-0.309017, -0.500000, 0.809017}, 
{-0.147621, -0.716567, 0.681718}, 
{-0.425325, -0.688191, 0.587785}, 
{-0.162460, -0.262866, 0.951056}, 
{0.442863, -0.238856, 0.864188}, 
{0.162460, -0.262866, 0.951056}, 
{0.309017, -0.500000, 0.809017}, 
{0.147621, -0.716567, 0.681718}, 
{0.000000, -0.525731, 0.850651}, 
{0.425325, -0.688191, 0.587785}, 
{0.587785, -0.425325, 0.688191}, 
{0.688191, -0.587785, 0.425325}, 
{-0.955423, 0.295242, 0.000000}, 
{-0.951056, 0.162460, 0.262866}, 
{-1.000000, 0.000000, 0.000000}, 
{-0.850651, 0.000000, 0.525731}, 
{-0.955423, -0.295242, 0.000000}, 
{-0.951056, -0.162460, 0.262866}, 
{-0.864188, 0.442863, -0.238856}, 
{-0.951056, 0.162460, -0.262866}, 
{-0.809017, 0.309017, -0.500000}, 
{-0.864188, -0.442863, -0.238856}, 
{-0.951056, -0.162460, -0.262866}, 
{-0.809017, -0.309017, -0.500000}, 
{-0.681718, 0.147621, -0.716567}, 
{-0.681718, -0.147621, -0.716567}, 
{-0.850651, 0.000000, -0.525731}, 
{-0.688191, 0.587785, -0.425325}, 
{-0.587785, 0.425325, -0.688191}, 
{-0.425325, 0.688191, -0.587785}, 
{-0.425325, -0.688191, -0.587785}, 
{-0.587785, -0.425325, -0.688191}, 
{-0.688191, -0.587785, -0.425325}, 

```

`halflife/engine/APIProxy.h`:

```h
#ifndef __APIPROXY__
#define __APIPROXY__

#include "../MISC/archtypes.h"     // DAL
#include "../MISC/netadr.h"
#include "../COMMON//Sequence.h"

#ifndef _WIN32
#include "enums.h"
#endif

#define	MAX_ALIAS_NAME	32

typedef struct cmdalias_s
{
	struct cmdalias_s	*next;
	char	name[MAX_ALIAS_NAME];
	char	*value;
} cmdalias_t;

// ********************************************************
// Functions exported by the client .dll
// ********************************************************

// Function type declarations for client exports
typedef int (*INITIALIZE_FUNC)	( struct cl_enginefuncs_s*, int );
typedef void (*HUD_INIT_FUNC)		( void );
typedef int (*HUD_VIDINIT_FUNC)	( void );
typedef int (*HUD_REDRAW_FUNC)	( float, int );
typedef int (*HUD_UPDATECLIENTDATA_FUNC) ( struct client_data_s*, float );
typedef void (*HUD_RESET_FUNC)    ( void );
typedef void (*HUD_CLIENTMOVE_FUNC)( struct playermove_s *ppmove, qboolean server );
typedef void (*HUD_CLIENTMOVEINIT_FUNC)( struct playermove_s *ppmove );
typedef char (*HUD_TEXTURETYPE_FUNC)( char *name );
typedef void (*HUD_IN_ACTIVATEMOUSE_FUNC) ( void );
typedef void (*HUD_IN_DEACTIVATEMOUSE_FUNC)		( void );
typedef void (*HUD_IN_MOUSEEVENT_FUNC)		( int mstate );
typedef void (*HUD_IN_CLEARSTATES_FUNC)		( void );
typedef void (*HUD_IN_ACCUMULATE_FUNC ) ( void );
typedef void (*HUD_CL_CREATEMOVE_FUNC)		( float frametime, struct usercmd_s *cmd, int active );
typedef int (*HUD_CL_ISTHIRDPERSON_FUNC) ( void );
typedef void (*HUD_CL_GETCAMERAOFFSETS_FUNC )( float *ofs );
typedef struct kbutton_s * (*HUD_KB_FIND_FUNC) ( const char *name );
typedef void ( *HUD_CAMTHINK_FUNC )( void );
typedef void ( *HUD_CALCREF_FUNC ) ( struct ref_params_s *pparams );
typedef int	 ( *HUD_ADDENTITY_FUNC ) ( int type, struct cl_entity_s *ent, const char *modelname );
typedef void ( *HUD_CREATEENTITIES_FUNC ) ( void );
typedef void ( *HUD_DRAWNORMALTRIS_FUNC ) ( void );
typedef void ( *HUD_DRAWTRANSTRIS_FUNC ) ( void );
typedef void ( *HUD_STUDIOEVENT_FUNC ) ( const struct mstudioevent_s *event, const struct cl_entity_s *entity );
typedef void ( *HUD_POSTRUNCMD_FUNC ) ( struct local_state_s *from, struct local_state_s *to, struct usercmd_s *cmd, int runfuncs, double time, unsigned int random_seed );
typedef void ( *HUD_SHUTDOWN_FUNC ) ( void );
typedef void ( *HUD_TXFERLOCALOVERRIDES_FUNC )( struct entity_state_s *state, const struct clientdata_s *client );
typedef void ( *HUD_PROCESSPLAYERSTATE_FUNC )( struct entity_state_s *dst, const struct entity_state_s *src );
typedef void ( *HUD_TXFERPREDICTIONDATA_FUNC ) ( struct entity_state_s *ps, const struct entity_state_s *pps, struct clientdata_s *pcd, const struct clientdata_s *ppcd, struct weapon_data_s *wd, const struct weapon_data_s *pwd );
typedef void ( *HUD_DEMOREAD_FUNC ) ( int size, unsigned char *buffer );
typedef int ( *HUD_CONNECTIONLESS_FUNC )( const struct netadr_s *net_from, const char *args, char *response_buffer, int *response_buffer_size );
typedef	int	( *HUD_GETHULLBOUNDS_FUNC ) ( int hullnumber, float *mins, float *maxs );
typedef void (*HUD_FRAME_FUNC)		( double );
typedef int (*HUD_KEY_EVENT_FUNC ) ( int eventcode, int keynum, const char *pszCurrentBinding );
typedef void (*HUD_TEMPENTUPDATE_FUNC) ( double frametime, double client_time, double cl_gravity, struct tempent_s **ppTempEntFree, struct tempent_s **ppTempEntActive, 	int ( *Callback_AddVisibleEntity )( struct cl_entity_s *pEntity ),	void ( *Callback_TempEntPlaySound )( struct tempent_s *pTemp, float damp ) );
typedef struct cl_entity_s *(*HUD_GETUSERENTITY_FUNC ) ( int index );
typedef void (*HUD_VOICESTATUS_FUNC)(int entindex, qboolean bTalking);
typedef void (*HUD_DIRECTORMESSAGE_FUNC)( int iSize, void *pbuf );
typedef int ( *HUD_STUDIO_INTERFACE_FUNC )( int version, struct r_studio_interface_s **ppinterface, struct engine_studio_api_s *pstudio );
typedef void (*HUD_CHATINPUTPOSITION_FUNC)( int *x, int *y );
typedef int (*HUD_GETPLAYERTEAM)(int iplayer);
typedef void *(*CLIENTFACTORY)(); // this should be CreateInterfaceFn but that means including interface.h
									// which is a C++ file and some of the client files a C only... 
									// so we return a void * which we then do a typecast on later.


// Pointers to the exported client functions themselves
typedef struct
{
	INITIALIZE_FUNC						pInitFunc;
	HUD_INIT_FUNC						pHudInitFunc;
	HUD_VIDINIT_FUNC					pHudVidInitFunc;
	HUD_REDRAW_FUNC						pHudRedrawFunc;
	HUD_UPDATECLIENTDATA_FUNC			pHudUpdateClientDataFunc;
	HUD_RESET_FUNC						pHudResetFunc;
	HUD_CLIENTMOVE_FUNC					pClientMove;
	HUD_CLIENTMOVEINIT_FUNC				pClientMoveInit;
	HUD_TEXTURETYPE_FUNC				pClientTextureType;
	HUD_IN_ACTIVATEMOUSE_FUNC			pIN_ActivateMouse;
	HUD_IN_DEACTIVATEMOUSE_FUNC			pIN_DeactivateMouse;
	HUD_IN_MOUSEEVENT_FUNC				pIN_MouseEvent;
	HUD_IN_CLEARSTATES_FUNC				pIN_ClearStates;
	HUD_IN_ACCUMULATE_FUNC				pIN_Accumulate;
	HUD_CL_CREATEMOVE_FUNC				pCL_CreateMove;
	HUD_CL_ISTHIRDPERSON_FUNC			pCL_IsThirdPerson;
	HUD_CL_GETCAMERAOFFSETS_FUNC		pCL_GetCameraOffsets;
	HUD_KB_FIND_FUNC					pFindKey;
	HUD_CAMTHINK_FUNC					pCamThink;
	HUD_CALCREF_FUNC					pCalcRefdef;
	HUD_ADDENTITY_FUNC					pAddEntity;
	HUD_CREATEENTITIES_FUNC				pCreateEntities;
	HUD_DRAWNORMALTRIS_FUNC				pDrawNormalTriangles;
	HUD_DRAWTRANSTRIS_FUNC				pDrawTransparentTriangles;
	HUD_STUDIOEVENT_FUNC				pStudioEvent;
	HUD_POSTRUNCMD_FUNC					pPostRunCmd;
	HUD_SHUTDOWN_FUNC					pShutdown;
	HUD_TXFERLOCALOVERRIDES_FUNC		pTxferLocalOverrides;
	HUD_PROCESSPLAYERSTATE_FUNC			pProcessPlayerState;
	HUD_TXFERPREDICTIONDATA_FUNC		pTxferPredictionData;
	HUD_DEMOREAD_FUNC					pReadDemoBuffer;
	HUD_CONNECTIONLESS_FUNC				pConnectionlessPacket;
	HUD_GETHULLBOUNDS_FUNC				pGetHullBounds;
	HUD_FRAME_FUNC						pHudFrame;
	HUD_KEY_EVENT_FUNC					pKeyEvent;
	HUD_TEMPENTUPDATE_FUNC				pTempEntUpdate;
	HUD_GETUSERENTITY_FUNC				pGetUserEntity;
	HUD_VOICESTATUS_FUNC				pVoiceStatus;		// Possibly null on old client dlls.
	HUD_DIRECTORMESSAGE_FUNC			pDirectorMessage;	// Possibly null on old client dlls.
	HUD_STUDIO_INTERFACE_FUNC			pStudioInterface;	// Not used by all clients
	HUD_CHATINPUTPOSITION_FUNC			pChatInputPosition;	// Not used by all clients
	HUD_GETPLAYERTEAM					pGetPlayerTeam; // Not used by all clients
	CLIENTFACTORY						pClientFactory;
} cldll_func_t;

// Function type declarations for client destination functions
typedef void (*DST_INITIALIZE_FUNC)	( struct cl_enginefuncs_s**, int *);
typedef void (*DST_HUD_INIT_FUNC)		( void );
typedef void (*DST_HUD_VIDINIT_FUNC)	( void );
typedef void (*DST_HUD_REDRAW_FUNC)	( float*, int* );
typedef void (*DST_HUD_UPDATECLIENTDATA_FUNC) ( struct client_data_s**, float* );
typedef void (*DST_HUD_RESET_FUNC)    ( void );
typedef void (*DST_HUD_CLIENTMOVE_FUNC)( struct playermove_s **, qboolean * );
typedef void (*DST_HUD_CLIENTMOVEINIT_FUNC)( struct playermove_s ** );
typedef void (*DST_HUD_TEXTURETYPE_FUNC)( char ** );
typedef void (*DST_HUD_IN_ACTIVATEMOUSE_FUNC) ( void );
typedef void (*DST_HUD_IN_DEACTIVATEMOUSE_FUNC)		( void );
typedef void (*DST_HUD_IN_MOUSEEVENT_FUNC)		( int * );
typedef void (*DST_HUD_IN_CLEARSTATES_FUNC)		( void );
typedef void (*DST_HUD_IN_ACCUMULATE_FUNC ) ( void );
typedef void (*DST_HUD_CL_CREATEMOVE_FUNC)		( float *, struct usercmd_s **, int * );
typedef void (*DST_HUD_CL_ISTHIRDPERSON_FUNC) ( void );
typedef void (*DST_HUD_CL_GETCAMERAOFFSETS_FUNC )( float ** );
typedef void (*DST_HUD_KB_FIND_FUNC) ( const char ** );
typedef void (*DST_HUD_CAMTHINK_FUNC )( void );
typedef void (*DST_HUD_CALCREF_FUNC ) ( struct ref_params_s ** );
typedef void (*DST_HUD_ADDENTITY_FUNC ) ( int *, struct cl_entity_s **, const char ** );
typedef void (*DST_HUD_CREATEENTITIES_FUNC ) ( void );
typedef void (*DST_HUD_DRAWNORMALTRIS_FUNC ) ( void );
typedef void (*DST_HUD_DRAWTRANSTRIS_FUNC ) ( void );
typedef void (*DST_HUD_STUDIOEVENT_FUNC ) ( const struct mstudioevent_s **, const struct cl_entity_s ** );
typedef void (*DST_HUD_POSTRUNCMD_FUNC ) ( struct local_state_s **, struct local_state_s **, struct usercmd_s **, int *, double *, unsigned int * );
typedef void (*DST_HUD_SHUTDOWN_FUNC ) ( void );
typedef void (*DST_HUD_TXFERLOCALOVERRIDES_FUNC )( struct entity_state_s **, const struct clientdata_s ** );
typedef void (*DST_HUD_PROCESSPLAYERSTATE_FUNC )( struct entity_state_s **, const struct entity_state_s ** );
typedef void (*DST_HUD_TXFERPREDICTIONDATA_FUNC ) ( struct entity_state_s **, const struct entity_state_s **, struct clientdata_s **, const struct clientdata_s **, struct weapon_data_s **, const struct weapon_data_s ** );
typedef void (*DST_HUD_DEMOREAD_FUNC ) ( int *, unsigned char ** );
typedef void (*DST_HUD_CONNECTIONLESS_FUNC )( const struct netadr_s **, const char **, char **, int ** );
typedef void (*DST_HUD_GETHULLBOUNDS_FUNC ) ( int *, float **, float ** );
typedef void (*DST_HUD_FRAME_FUNC)		( double * );
typedef void (*DST_HUD_KEY_EVENT_FUNC ) ( int *, int *, const char ** );
typedef void (*DST_HUD_TEMPENTUPDATE_FUNC) ( double *, double *, double *, struct tempent_s ***, struct tempent_s ***, int ( **Callback_AddVisibleEntity )( struct cl_entity_s *pEntity ),	void ( **Callback_TempEntPlaySound )( struct tempent_s *pTemp, float damp ) );
typedef void (*DST_HUD_GETUSERENTITY_FUNC ) ( int * );
typedef void (*DST_HUD_VOICESTATUS_FUNC)(int *, qboolean *);
typedef void (*DST_HUD_DIRECTORMESSAGE_FUNC)( int *, void ** );
typedef void (*DST_HUD_STUDIO_INTERFACE_FUNC ) ( int *, struct r_studio_interface_s ***, struct engine_studio_api_s ** );
typedef void (*DST_HUD_CHATINPUTPOSITION_FUNC)( int **, int ** );
typedef void (*DST_HUD_GETPLAYERTEAM)(int);

// Pointers to the client destination functions
typedef struct
{
	DST_INITIALIZE_FUNC						pInitFunc;
	DST_HUD_INIT_FUNC						pHudInitFunc;
	DST_HUD_VIDINIT_FUNC					pHudVidInitFunc;
	DST_HUD_REDRAW_FUNC						pHudRedrawFunc;
	DST_HUD_UPDATECLIENTDATA_FUNC			pHudUpdateClientDataFunc;
	DST_HUD_RESET_FUNC						pHudResetFunc;
	DST_HUD_CLIENTMOVE_FUNC					pClientMove;
	DST_HUD_CLIENTMOVEINIT_FUNC				pClientMoveInit;
	DST_HUD_TEXTURETYPE_FUNC				pClientTextureType;
	DST_HUD_IN_ACTIVATEMOUSE_FUNC			pIN_ActivateMouse;
	DST_HUD_IN_DEACTIVATEMOUSE_FUNC			pIN_DeactivateMouse;
	DST_HUD_IN_MOUSEEVENT_FUNC				pIN_MouseEvent;
	DST_HUD_IN_CLEARSTATES_FUNC				pIN_ClearStates;
	DST_HUD_IN_ACCUMULATE_FUNC				pIN_Accumulate;
	DST_HUD_CL_CREATEMOVE_FUNC				pCL_CreateMove;
	DST_HUD_CL_ISTHIRDPERSON_FUNC			pCL_IsThirdPerson;
	DST_HUD_CL_GETCAMERAOFFSETS_FUNC		pCL_GetCameraOffsets;
	DST_HUD_KB_FIND_FUNC					pFindKey;
	DST_HUD_CAMTHINK_FUNC					pCamThink;
	DST_HUD_CALCREF_FUNC					pCalcRefdef;
	DST_HUD_ADDENTITY_FUNC					pAddEntity;
	DST_HUD_CREATEENTITIES_FUNC				pCreateEntities;
	DST_HUD_DRAWNORMALTRIS_FUNC				pDrawNormalTriangles;
	DST_HUD_DRAWTRANSTRIS_FUNC				pDrawTransparentTriangles;
	DST_HUD_STUDIOEVENT_FUNC				pStudioEvent;
	DST_HUD_POSTRUNCMD_FUNC					pPostRunCmd;
	DST_HUD_SHUTDOWN_FUNC					pShutdown;
	DST_HUD_TXFERLOCALOVERRIDES_FUNC		pTxferLocalOverrides;
	DST_HUD_PROCESSPLAYERSTATE_FUNC			pProcessPlayerState;
	DST_HUD_TXFERPREDICTIONDATA_FUNC		pTxferPredictionData;
	DST_HUD_DEMOREAD_FUNC					pReadDemoBuffer;
	DST_HUD_CONNECTIONLESS_FUNC				pConnectionlessPacket;
	DST_HUD_GETHULLBOUNDS_FUNC				pGetHullBounds;
	DST_HUD_FRAME_FUNC						pHudFrame;
	DST_HUD_KEY_EVENT_FUNC					pKeyEvent;
	DST_HUD_TEMPENTUPDATE_FUNC				pTempEntUpdate;
	DST_HUD_GETUSERENTITY_FUNC				pGetUserEntity;
	DST_HUD_VOICESTATUS_FUNC				pVoiceStatus;	// Possibly null on old client dlls.
	DST_HUD_DIRECTORMESSAGE_FUNC			pDirectorMessage;	// Possibly null on old client dlls.
	DST_HUD_STUDIO_INTERFACE_FUNC			pStudioInterface;  // Not used by all clients
	DST_HUD_CHATINPUTPOSITION_FUNC			pChatInputPosition;  // Not used by all clients
	DST_HUD_GETPLAYERTEAM					pGetPlayerTeam; // Not used by all clients
} cldll_func_dst_t;




// ********************************************************
// Functions exported by the engine
// ********************************************************

// Function type declarations for engine exports
typedef HSPRITE						(*pfnEngSrc_pfnSPR_Load_t )			( const char *szPicName );
typedef int							(*pfnEngSrc_pfnSPR_Frames_t )			( HSPRITE hPic );
typedef int							(*pfnEngSrc_pfnSPR_Height_t )			( HSPRITE hPic, int frame );
typedef int							(*pfnEngSrc_pfnSPR_Width_t )			( HSPRITE hPic, int frame );
typedef void						(*pfnEngSrc_pfnSPR_Set_t )				( HSPRITE hPic, int r, int g, int b );
typedef void						(*pfnEngSrc_pfnSPR_Draw_t )			( int frame, int x, int y, const struct rect_s *prc );
typedef void						(*pfnEngSrc_pfnSPR_DrawHoles_t )		( int frame, int x, int y, const struct rect_s *prc );
typedef void						(*pfnEngSrc_pfnSPR_DrawAdditive_t )	( int frame, int x, int y, const struct rect_s *prc );
typedef void						(*pfnEngSrc_pfnSPR_EnableScissor_t )	( int x, int y, int width, int height );
typedef void						(*pfnEngSrc_pfnSPR_DisableScissor_t )	( void );
typedef struct client_sprite_s	*	(*pfnEngSrc_pfnSPR_GetList_t )			( char *psz, int *piCount );
typedef void						(*pfnEngSrc_pfnFillRGBA_t )			( int x, int y, int width, int height, int r, int g, int b, int a );
typedef int							(*pfnEngSrc_pfnGetScreenInfo_t ) 		( struct SCREENINFO_s *pscrinfo );
typedef void						(*pfnEngSrc_pfnSetCrosshair_t )		( HSPRITE hspr, wrect_t rc, int r, int g, int b );
typedef struct cvar_s *				(*pfnEngSrc_pfnRegisterVariable_t )	( char *szName, char *szValue, int flags );
typedef float						(*pfnEngSrc_pfnGetCvarFloat_t )		( char *szName );
typedef char*						(*pfnEngSrc_pfnGetCvarString_t )		( char *szName );
typedef int							(*pfnEngSrc_pfnAddCommand_t )			( char *cmd_name, void (*pfnEngSrc_function)(void) );
typedef int							(*pfnEngSrc_pfnHookUserMsg_t )			( char *szMsgName, pfnUserMsgHook pfn );
typedef int							(*pfnEngSrc_pfnServerCmd_t )			( char *szCmdString );
typedef int							(*pfnEngSrc_pfnClientCmd_t )			( char *szCmdString );
typedef void						(*pfnEngSrc_pfnPrimeMusicStream_t )	( char *szFilename, int looping );
typedef void						(*pfnEngSrc_pfnGetPlayerInfo_t )		( int ent_num, struct hud_player_info_s *pinfo );
typedef void						(*pfnEngSrc_pfnPlaySoundByName_t )		( char *szSound, float volume );
typedef void						(*pfnEngSrc_pfnPlaySoundByNameAtPitch_t )	( char *szSound, float volume, int pitch );
typedef void						(*pfnEngSrc_pfnPlaySoundVoiceByName_t )		( char *szSound, float volume, int pitch );
typedef void						(*pfnEngSrc_pfnPlaySoundByIndex_t )	( int iSound, float volume );
typedef void						(*pfnEngSrc_pfnAngleVectors_t )		( const float * vecAngles, float * forward, float * right, float * up );
typedef struct client_textmessage_s*(*pfnEngSrc_pfnTextMessageGet_t )		( const char *pName );
typedef int							(*pfnEngSrc_pfnDrawCharacter_t )		( int x, int y, int number, int r, int g, int b );
typedef int							(*pfnEngSrc_pfnDrawConsoleString_t )	( int x, int y, char *string );
typedef void						(*pfnEngSrc_pfnDrawSetTextColor_t )	( float r, float g, float b );
typedef void						(*pfnEngSrc_pfnDrawConsoleStringLen_t )(  const char *string, int *length, int *height );
typedef void						(*pfnEngSrc_pfnConsolePrint_t )		( const char *string );
typedef void						(*pfnEngSrc_pfnCenterPrint_t )			( const char *string );
typedef int							(*pfnEngSrc_GetWindowCenterX_t )		( void );
typedef int							(*pfnEngSrc_GetWindowCenterY_t )		( void );
typedef void						(*pfnEngSrc_GetViewAngles_t )			( float * );
typedef void						(*pfnEngSrc_SetViewAngles_t )			( float * );
typedef int							(*pfnEngSrc_GetMaxClients_t )			( void );
typedef void						(*pfnEngSrc_Cvar_SetValue_t )			( char *cvar, float value );
typedef int       					(*pfnEngSrc_Cmd_Argc_t)					(void);	
typedef char *						(*pfnEngSrc_Cmd_Argv_t )				( int arg );
typedef void						(*pfnEngSrc_Con_Printf_t )				( char *fmt, ... );
typedef void						(*pfnEngSrc_Con_DPrintf_t )			( char *fmt, ... );
typedef void						(*pfnEngSrc_Con_NPrintf_t )			( int pos, char *fmt, ... );
typedef void						(*pfnEngSrc_Con_NXPrintf_t )			( struct con_nprint_s *info, char *fmt, ... );
typedef const char *				(*pfnEngSrc_PhysInfo_ValueForKey_t )	( const char *key );
typedef const char *				(*pfnEngSrc_ServerInfo_ValueForKey_t )( const char *key );
typedef float						(*pfnEngSrc_GetClientMaxspeed_t )		( void );
typedef int							(*pfnEngSrc_CheckParm_t )				( char *parm, char **ppnext );
typedef void						(*pfnEngSrc_Key_Event_t )				( int key, int down );
typedef void						(*pfnEngSrc_GetMousePosition_t )		( int *mx, int *my );
typedef int							(*pfnEngSrc_IsNoClipping_t )			( void );
typedef struct cl_entity_s *		(*pfnEngSrc_GetLocalPlayer_t )		( void );
typedef struct cl_entity_s *		(*pfnEngSrc_GetViewModel_t )			( void );
typedef struct cl_entity_s *		(*pfnEngSrc_GetEntityByIndex_t )		( int idx );
typedef float						(*pfnEngSrc_GetClientTime_t )			( void );
typedef void						(*pfnEngSrc_V_CalcShake_t )			( void );
typedef void						(*pfnEngSrc_V_ApplyShake_t )			( float *origin, float *angles, float factor );
typedef int							(*pfnEngSrc_PM_PointContents_t )		( float *point, int *truecontents );
typedef int							(*pfnEngSrc_PM_WaterEntity_t )			( float *p );
typedef struct pmtrace_s *			(*pfnEngSrc_PM_TraceLine_t )			( float *start, float *end, int flags, int usehull, int ignore_pe );
typedef struct model_s *			(*pfnEngSrc_CL_LoadModel_t )			( const char *modelname, int *index );
typedef int							(*pfnEngSrc_CL_CreateVisibleEntity_t )	( int type, struct cl_entity_s *ent );
typedef const struct model_s *		(*pfnEngSrc_GetSpritePointer_t )		( HSPRITE hSprite );
typedef void						(*pfnEngSrc_pfnPlaySoundByNameAtLocation_t )	( char *szSound, float volume, float *origin );
typedef unsigned short				(*pfnEngSrc_pfnPrecacheEvent_t )		( int type, const char* psz );
typedef void						(*pfnEngSrc_pfnPlaybackEvent_t )		( int flags, const struct edict_s *pInvoker, unsigned short eventindex, float delay, float *origin, float *angles, float fparam1, float fparam2, int iparam1, int iparam2, int bparam1, int bparam2 );
typedef void						(*pfnEngSrc_pfnWeaponAnim_t )			( int iAnim, int body );
typedef float						(*pfnEngSrc_pfnRandomFloat_t )			( float flLow, float flHigh );
typedef int32						(*pfnEngSrc_pfnRandomLong_t )			( int32 lLow, int32 lHigh );
typedef void						(*pfnEngSrc_pfnHookEvent_t )			( char *name, void ( *pfnEvent )( struct event_args_s *args ) );
typedef int							(*pfnEngSrc_Con_IsVisible_t)			();
typedef const char *				(*pfnEngSrc_pfnGetGameDirectory_t )	( void );
typedef struct cvar_s *				(*pfnEngSrc_pfnGetCvarPointer_t )		( const char *szName );
typedef const char *				(*pfnEngSrc_Key_LookupBinding_t )		( const char *pBinding );
typedef const char *				(*pfnEngSrc_pfnGetLevelName_t )		( void );
typedef void						(*pfnEngSrc_pfnGetScreenFade_t )		( struct screenfade_s *fade );
typedef void						(*pfnEngSrc_pfnSetScreenFade_t )		( struct screenfade_s *fade );
typedef void *						(*pfnEngSrc_VGui_GetPanel_t )         ( );
typedef void                        (*pfnEngSrc_VGui_ViewportPaintBackground_t ) (int extents[4]);
typedef byte*						(*pfnEngSrc_COM_LoadFile_t )				( char *path, int usehunk, int *pLength );
typedef char*						(*pfnEngSrc_COM_ParseFile_t )			( char *data, char *token );
typedef void						(*pfnEngSrc_COM_FreeFile_t)				( void *buffer );
typedef struct triangleapi_s *		pTriAPI;
typedef struct efx_api_s *			pEfxAPI;
typedef struct event_api_s *		pEventAPI;
typedef struct demo_api_s *			pDemoAPI;
typedef struct net_api_s *			pNetAPI;
typedef struct IVoiceTweak_s *		pVoiceTweak;
typedef int							(*pfnEngSrc_IsSpectateOnly_t ) ( void );
typedef struct model_s *			(*pfnEngSrc_LoadMapSprite_t )			( const char *filename );
typedef void						(*pfnEngSrc_COM_AddAppDirectoryToSearchPath_t ) ( const char *pszBaseDir, const char *appName );
typedef int							(*pfnEngSrc_COM_ExpandFilename_t)				 ( const char *fileName, char *nameOutBuffer, int nameOutBufferSize );
typedef const char *				(*pfnEngSrc_PlayerInfo_ValueForKey_t )( int playerNum, const char *key );
typedef void						(*pfnEngSrc_PlayerInfo_SetValueForKey_t )( const char *key, const char *value );
typedef qboolean					(*pfnEngSrc_GetPlayerUniqueID_t)(int iPlayer, char playerID[16]);
typedef int							(*pfnEngSrc_GetTrackerIDForPlayer_t)(int playerSlot);
typedef int							(*pfnEngSrc_GetPlayerForTrackerID_t)(int trackerID);
typedef int							(*pfnEngSrc_pfnServerCmdUnreliable_t )( char *szCmdString );
typedef void						(*pfnEngSrc_GetMousePos_t )(struct tagPOINT *ppt);
typedef void						(*pfnEngSrc_SetMousePos_t )(int x, int y);
typedef void						(*pfnEngSrc_SetMouseEnable_t)(qboolean fEnable);
typedef struct cvar_s *				(*pfnEngSrc_GetFirstCVarPtr_t)();
typedef unsigned int				(*pfnEngSrc_GetFirstCmdFunctionHandle_t)();
typedef unsigned int				(*pfnEngSrc_GetNextCmdFunctionHandle_t)(unsigned int cmdhandle);
typedef const char *				(*pfnEngSrc_GetCmdFunctionName_t)(unsigned int cmdhandle);
typedef float						(*pfnEngSrc_GetClientOldTime_t)();
typedef float						(*pfnEngSrc_GetServerGravityValue_t)();
typedef struct model_s	*			(*pfnEngSrc_GetModelByIndex_t)( int index );
typedef void						(*pfnEngSrc_pfnSetFilterMode_t )( int mode );
typedef void						(*pfnEngSrc_pfnSetFilterColor_t )( float r, float g, float b );
typedef void						(*pfnEngSrc_pfnSetFilterBrightness_t )( float brightness );
typedef sequenceEntry_s*			(*pfnEngSrc_pfnSequenceGet_t )( const char *fileName, const char* entryName );
typedef void						(*pfnEngSrc_pfnSPR_DrawGeneric_t )( int frame, int x, int y, const struct rect_s *prc, int src, int dest, int w, int h );
typedef sentenceEntry_s*			(*pfnEngSrc_pfnSequencePickSentence_t )( const char *sentenceName, int pickMethod, int* entryPicked );
// draw a complete string
typedef int							(*pfnEngSrc_pfnDrawString_t )		( int x, int y, const char *str, int r, int g, int b );
typedef int							(*pfnEngSrc_pfnDrawStringReverse_t )		( int x, int y, const char *str, int r, int g, int b );
typedef const char *				(*pfnEngSrc_LocalPlayerInfo_ValueForKey_t )( const char *key );
typedef int							(*pfnEngSrc_pfnVGUI2DrawCharacter_t )		( int x, int y, int ch, unsigned int font );
typedef int							(*pfnEngSrc_pfnVGUI2DrawCharacterAdd_t )	( int x, int y, int ch, int r, int g, int b, unsigned int font);
typedef unsigned int		(*pfnEngSrc_COM_GetApproxWavePlayLength ) ( const char * filename);
typedef void *						(*pfnEngSrc_pfnGetCareerUI_t)();
typedef void						(*pfnEngSrc_Cvar_Set_t )			( char *cvar, char *value );
typedef int							(*pfnEngSrc_pfnIsPlayingCareerMatch_t)();
typedef double						(*pfnEngSrc_GetAbsoluteTime_t) ( void );
typedef void						(*pfnEngSrc_pfnProcessTutorMessageDecayBuffer_t)(int *buffer, int bufferLength);
typedef void						(*pfnEngSrc_pfnConstructTutorMessageDecayBuffer_t)(int *buffer, int bufferLength);
typedef void						(*pfnEngSrc_pfnResetTutorMessageDecayData_t)();
typedef void						(*pfnEngSrc_pfnFillRGBABlend_t )			( int x, int y, int width, int height, int r, int g, int b, int a );
typedef int						(*pfnEngSrc_pfnGetAppID_t)			( void );
typedef cmdalias_t*				(*pfnEngSrc_pfnGetAliases_t)		( void );
typedef void					(*pfnEngSrc_pfnVguiWrap2_GetMouseDelta_t) ( int *x, int *y );

// Pointers to the exported engine functions themselves
typedef struct cl_enginefuncs_s
{
	pfnEngSrc_pfnSPR_Load_t					pfnSPR_Load;
	pfnEngSrc_pfnSPR_Frames_t				pfnSPR_Frames;
	pfnEngSrc_pfnSPR_Height_t				pfnSPR_Height;
	pfnEngSrc_pfnSPR_Width_t				pfnSPR_Width;
	pfnEngSrc_pfnSPR_Set_t					pfnSPR_Set;
	pfnEngSrc_pfnSPR_Draw_t					pfnSPR_Draw;
	pfnEngSrc_pfnSPR_DrawHoles_t			pfnSPR_DrawHoles;
	pfnEngSrc_pfnSPR_DrawAdditive_t			pfnSPR_DrawAdditive;
	pfnEngSrc_pfnSPR_EnableScissor_t		pfnSPR_EnableScissor;
	pfnEngSrc_pfnSPR_DisableScissor_t		pfnSPR_DisableScissor;
	pfnEngSrc_pfnSPR_GetList_t				pfnSPR_GetList;
	pfnEngSrc_pfnFillRGBA_t					pfnFillRGBA;
	pfnEngSrc_pfnGetScreenInfo_t			pfnGetScreenInfo;
	pfnEngSrc_pfnSetCrosshair_t				pfnSetCrosshair;
	pfnEngSrc_pfnRegisterVariable_t			pfnRegisterVariable;
	pfnEngSrc_pfnGetCvarFloat_t				pfnGetCvarFloat;
	pfnEngSrc_pfnGetCvarString_t			pfnGetCvarString;
	pfnEngSrc_pfnAddCommand_t				pfnAddCommand;
	pfnEngSrc_pfnHookUserMsg_t				pfnHookUserMsg;
	pfnEngSrc_pfnServerCmd_t				pfnServerCmd;
	pfnEngSrc_pfnClientCmd_t				pfnClientCmd;
	pfnEngSrc_pfnGetPlayerInfo_t			pfnGetPlayerInfo;
	pfnEngSrc_pfnPlaySoundByName_t			pfnPlaySoundByName;
	pfnEngSrc_pfnPlaySoundByIndex_t			pfnPlaySoundByIndex;
	pfnEngSrc_pfnAngleVectors_t				pfnAngleVectors;
	pfnEngSrc_pfnTextMessageGet_t			pfnTextMessageGet;
	pfnEngSrc_pfnDrawCharacter_t			pfnDrawCharacter;
	pfnEngSrc_pfnDrawConsoleString_t		pfnDrawConsoleString;
	pfnEngSrc_pfnDrawSetTextColor_t			pfnDrawSetTextColor;
	pfnEngSrc_pfnDrawConsoleStringLen_t		pfnDrawConsoleStringLen;
	pfnEngSrc_pfnConsolePrint_t				pfnConsolePrint;
	pfnEngSrc_pfnCenterPrint_t				pfnCenterPrint;
	pfnEngSrc_GetWindowCenterX_t			GetWindowCenterX;
	pfnEngSrc_GetWindowCenterY_t			GetWindowCenterY;
	pfnEngSrc_GetViewAngles_t				GetViewAngles;
	pfnEngSrc_SetViewAngles_t				SetViewAngles;
	pfnEngSrc_GetMaxClients_t				GetMaxClients;
	pfnEngSrc_Cvar_SetValue_t				Cvar_SetValue;
	pfnEngSrc_Cmd_Argc_t					Cmd_Argc;
	pfnEngSrc_Cmd_Argv_t					Cmd_Argv;
	pfnEngSrc_Con_Printf_t					Con_Printf;
	pfnEngSrc_Con_DPrintf_t					Con_DPrintf;
	pfnEngSrc_Con_NPrintf_t					Con_NPrintf;
	pfnEngSrc_Con_NXPrintf_t				Con_NXPrintf;
	pfnEngSrc_PhysInfo_ValueForKey_t		PhysInfo_ValueForKey;
	pfnEngSrc_ServerInfo_ValueForKey_t		ServerInfo_ValueForKey;
	pfnEngSrc_GetClientMaxspeed_t			GetClientMaxspeed;
	pfnEngSrc_CheckParm_t					CheckParm;
	pfnEngSrc_Key_Event_t					Key_Event;
	pfnEngSrc_GetMousePosition_t			GetMousePosition;
	pfnEngSrc_IsNoClipping_t				IsNoClipping;
	pfnEngSrc_GetLocalPlayer_t				GetLocalPlayer;
	pfnEngSrc_GetViewModel_t				GetViewModel;
	pfnEngSrc_GetEntityByIndex_t			GetEntityByIndex;
	pfnEngSrc_GetClientTime_t				GetClientTime;
	pfnEngSrc_V_CalcShake_t					V_CalcShake;
	pfnEngSrc_V_ApplyShake_t				V_ApplyShake;
	pfnEngSrc_PM_PointContents_t			PM_PointContents;
	pfnEngSrc_PM_WaterEntity_t				PM_WaterEntity;
	pfnEngSrc_PM_TraceLine_t				PM_TraceLine;
	pfnEngSrc_CL_LoadModel_t				CL_LoadModel;
	pfnEngSrc_CL_CreateVisibleEntity_t		CL_CreateVisibleEntity;
	pfnEngSrc_GetSpritePointer_t			GetSpritePointer;
	pfnEngSrc_pfnPlaySoundByNameAtLocation_t	pfnPlaySoundByNameAtLocation;
	pfnEngSrc_pfnPrecacheEvent_t			pfnPrecacheEvent;
	pfnEngSrc_pfnPlaybackEvent_t			pfnPlaybackEvent;
	pfnEngSrc_pfnWeaponAnim_t				pfnWeaponAnim;
	pfnEngSrc_pfnRandomFloat_t				pfnRandomFloat;
	pfnEngSrc_pfnRandomLong_t				pfnRandomLong;
	pfnEngSrc_pfnHookEvent_t				pfnHookEvent;
	pfnEngSrc_Con_IsVisible_t				Con_IsVisible;
	pfnEngSrc_pfnGetGameDirectory_t			pfnGetGameDirectory;
	pfnEngSrc_pfnGetCvarPointer_t			pfnGetCvarPointer;
	pfnEngSrc_Key_LookupBinding_t			Key_LookupBinding;
	pfnEngSrc_pfnGetLevelName_t				pfnGetLevelName;
	pfnEngSrc_pfnGetScreenFade_t			pfnGetScreenFade;
	pfnEngSrc_pfnSetScreenFade_t			pfnSetScreenFade;
	pfnEngSrc_VGui_GetPanel_t				VGui_GetPanel;
	pfnEngSrc_VGui_ViewportPaintBackground_t	VGui_ViewportPaintBackground;
	pfnEngSrc_COM_LoadFile_t				COM_LoadFile;
	pfnEngSrc_COM_ParseFile_t				COM_ParseFile;
	pfnEngSrc_COM_FreeFile_t				COM_FreeFile;
	struct triangleapi_s		*pTriAPI;
	struct efx_api_s			*pEfxAPI;
	struct event_api_s			*pEventAPI;
	struct demo_api_s			*pDemoAPI;
	struct net_api_s			*pNetAPI;
	struct IVoiceTweak_s		*pVoiceTweak;
	pfnEngSrc_IsSpectateOnly_t				IsSpectateOnly;
	pfnEngSrc_LoadMapSprite_t				LoadMapSprite;
	pfnEngSrc_COM_AddAppDirectoryToSearchPath_t		COM_AddAppDirectoryToSearchPath;
	pfnEngSrc_COM_ExpandFilename_t			COM_ExpandFilename;
	pfnEngSrc_PlayerInfo_ValueForKey_t		PlayerInfo_ValueForKey;
	pfnEngSrc_PlayerInfo_SetValueForKey_t	PlayerInfo_SetValueForKey;
	pfnEngSrc_GetPlayerUniqueID_t			GetPlayerUniqueID;
	pfnEngSrc_GetTrackerIDForPlayer_t		GetTrackerIDForPlayer;
	pfnEngSrc_GetPlayerForTrackerID_t		GetPlayerForTrackerID;
	pfnEngSrc_pfnServerCmdUnreliable_t		pfnServerCmdUnreliable;
	pfnEngSrc_GetMousePos_t					pfnGetMousePos;
	pfnEngSrc_SetMousePos_t					pfnSetMousePos;
	pfnEngSrc_SetMouseEnable_t				pfnSetMouseEnable;
	pfnEngSrc_GetFirstCVarPtr_t				GetFirstCvarPtr;
	pfnEngSrc_GetFirstCmdFunctionHandle_t	GetFirstCmdFunctionHandle;
	pfnEngSrc_GetNextCmdFunctionHandle_t	GetNextCmdFunctionHandle;
	pfnEngSrc_GetCmdFunctionName_t			GetCmdFunctionName;
	pfnEngSrc_GetClientOldTime_t			hudGetClientOldTime;
	pfnEngSrc_GetServerGravityValue_t		hudGetServerGravityValue;
	pfnEngSrc_GetModelByIndex_t				hudGetModelByIndex;
	pfnEngSrc_pfnSetFilterMode_t			pfnSetFilterMode;
	pfnEngSrc_pfnSetFilterColor_t			pfnSetFilterColor;
	pfnEngSrc_pfnSetFilterBrightness_t		pfnSetFilterBrightness;
	pfnEngSrc_pfnSequenceGet_t				pfnSequenceGet;
	pfnEngSrc_pfnSPR_DrawGeneric_t			pfnSPR_DrawGeneric;
	pfnEngSrc_pfnSequencePickSentence_t		pfnSequencePickSentence;
	pfnEngSrc_pfnDrawString_t				pfnDrawString;
	pfnEngSrc_pfnDrawStringReverse_t				pfnDrawStringReverse;
	pfnEngSrc_LocalPlayerInfo_ValueForKey_t		LocalPlayerInfo_ValueForKey;
	pfnEngSrc_pfnVGUI2DrawCharacter_t		pfnVGUI2DrawCharacter;
	pfnEngSrc_pfnVGUI2DrawCharacterAdd_t	pfnVGUI2DrawCharacterAdd;
	pfnEngSrc_COM_GetApproxWavePlayLength	COM_GetApproxWavePlayLength;
	pfnEngSrc_pfnGetCareerUI_t				pfnGetCareerUI;
	pfnEngSrc_Cvar_Set_t					Cvar_Set;
	pfnEngSrc_pfnIsPlayingCareerMatch_t		pfnIsCareerMatch;
	pfnEngSrc_pfnPlaySoundVoiceByName_t	pfnPlaySoundVoiceByName;
	pfnEngSrc_pfnPrimeMusicStream_t		pfnPrimeMusicStream;
	pfnEngSrc_GetAbsoluteTime_t				GetAbsoluteTime;
	pfnEngSrc_pfnProcessTutorMessageDecayBuffer_t		pfnProcessTutorMessageDecayBuffer;
	pfnEngSrc_pfnConstructTutorMessageDecayBuffer_t		pfnConstructTutorMessageDecayBuffer;
	pfnEngSrc_pfnResetTutorMessageDecayData_t		pfnResetTutorMessageDecayData;
	pfnEngSrc_pfnPlaySoundByNameAtPitch_t	pfnPlaySoundByNameAtPitch;
	pfnEngSrc_pfnFillRGBABlend_t					pfnFillRGBABlend;
	pfnEngSrc_pfnGetAppID_t					pfnGetAppID;
	pfnEngSrc_pfnGetAliases_t				pfnGetAliasList;
	pfnEngSrc_pfnVguiWrap2_GetMouseDelta_t pfnVguiWrap2_GetMouseDelta;
} cl_enginefunc_t;

// Function type declarations for engine destination functions
typedef void	(*pfnEngDst_pfnSPR_Load_t )				( const char ** );
typedef void	(*pfnEngDst_pfnSPR_Frames_t )			( HSPRITE * );
typedef void	(*pfnEngDst_pfnSPR_Height_t )			( HSPRITE *, int * );
typedef void	(*pfnEngDst_pfnSPR_Width_t )			( HSPRITE *, int * );
typedef void	(*pfnEngDst_pfnSPR_Set_t )				( HSPRITE *, int *, int *, int * );
typedef void	(*pfnEngDst_pfnSPR_Draw_t )				( int *, int *, int *, const struct rect_s ** );
typedef void	(*pfnEngDst_pfnSPR_DrawHoles_t )		( int *, int *, int *, const struct rect_s ** );
typedef void	(*pfnEngDst_pfnSPR_DrawAdditive_t )		( int *, int *, int *, const struct rect_s ** );
typedef void	(*pfnEngDst_pfnSPR_EnableScissor_t )	( int *, int *, int *, int * );
typedef void	(*pfnEngDst_pfnSPR_DisableScissor_t )	( void );
typedef void	(*pfnEngDst_pfnSPR_GetList_t )			( char **, int ** );
typedef void	(*pfnEngDst_pfnFillRGBA_t )				( int *, int *, int *, int *, int *, int *, int *, int * );
typedef void	(*pfnEngDst_pfnGetScreenInfo_t ) 		( struct SCREENINFO_s ** );
typedef void	(*pfnEngDst_pfnSetCrosshair_t )			( HSPRITE *, struct rect_s *, int *, int *, int * );
typedef void	(*pfnEngDst_pfnRegisterVariable_t )		( char **, char **, int * );
typedef void	(*pfnEngDst_pfnGetCvarFloat_t )			( char ** );
typedef void	(*pfnEngDst_pfnGetCvarString_t )		( char ** );
typedef void	(*pfnEngDst_pfnAddCommand_t )			( char **, void (**pfnEngDst_function)(void) );
typedef void	(*pfnEngDst_pfnHookUserMsg_t )			( char **, pfnUserMsgHook * );
typedef void	(*pfnEngDst_pfnServerCmd_t )			( char ** );
typedef void	(*pfnEngDst_pfnClientCmd_t )			( char ** );
typedef void	(*pfnEngDst_pfnPrimeMusicStream_t )	( char **, int *);
typedef void	(*pfnEngDst_pfnGetPlayerInfo_t )		( int *, struct hud_player_info_s ** );
typedef void	(*pfnEngDst_pfnPlaySoundByName_t )		( char **, float * );
typedef void	(*pfnEngDst_pfnPlaySoundByNameAtPitch_t )	( char **, float *, int * );
typedef void	(*pfnEngDst_pfnPlaySoundVoiceByName_t )	(char **, float * );
typedef void	(*pfnEngDst_pfnPlaySoundByIndex_t )		( int *, float * );
typedef void	(*pfnEngDst_pfnAngleVectors_t )			( const float * *, float * *, float * *, float * * );
typedef void	(*pfnEngDst_pfnTextMessageGet_t )		( const char ** );
typedef void	(*pfnEngDst_pfnDrawCharacter_t )		( int *, int *, int *, int *, int *, int * );
typedef void	(*pfnEngDst_pfnDrawConsoleString_t )	( int *, int *, char ** );
typedef void	(*pfnEngDst_pfnDrawSetTextColor_t )		( float *, float *, float * );
typedef void	(*pfnEngDst_pfnDrawConsoleStringLen_t )	(  const char **, int **, int ** );
typedef void	(*pfnEngDst_pfnConsolePrint_t )			( const char ** );
typedef void	(*pfnEngDst_pfnCenterPrint_t )			( const char ** );
typedef void	(*pfnEngDst_GetWindowCenterX_t )		( void );
typedef void	(*pfnEngDst_GetWindowCenterY_t )		( void );
typedef void	(*pfnEngDst_GetViewAngles_t )			( float ** );
typedef void	(*pfnEngDst_SetViewAngles_t )			( float ** );
typedef void	(*pfnEngDst_GetMaxClients_t )			( void );
typedef void	(*pfnEngDst_Cvar_SetValue_t )			( char **, float * );
typedef void    (*pfnEngDst_Cmd_Argc_t)					(void);	
typedef void	(*pfnEngDst_Cmd_Argv_t )				( int * );
typedef void	(*pfnEngDst_Con_Printf_t )				( char **);
typedef void	(*pfnEngDst_Con_DPrintf_t )				( char **);
typedef void	(*pfnEngDst_Con_NPrintf_t )				( int *, char ** );
typedef void	(*pfnEngDst_Con_NXPrintf_t )			( struct con_nprint_s **, char **);
typedef void	(*pfnEngDst_PhysInfo_ValueForKey_t )	( const char ** );
typedef void	(*pfnEngDst_ServerInfo_ValueForKey_t )	( const char ** );
typedef void	(*pfnEngDst_GetClientMaxspeed_t )		( void );
typedef void	(*pfnEngDst_CheckParm_t )				( char **, char *** );
typedef void	(*pfnEngDst_Key_Event_t )				( int *, int * );
typedef void	(*pfnEngDst_GetMousePosition_t )		( int **, int ** );
typedef void	(*pfnEngDst_IsNoClipping_t )			( void );
typedef void	(*pfnEngDst_GetLocalPlayer_t )			( void );
typedef void	(*pfnEngDst_GetViewModel_t )			( void );
typedef void	(*pfnEngDst_GetEntityByIndex_t )		( int * );
typedef void	(*pfnEngDst_GetClientTime_t )			( void );
typedef void	(*pfnEngDst_V_CalcShake_t )				( void );
typedef void	(*pfnEngDst_V_ApplyShake_t )			( float **, float **, float * );
typedef void	(*pfnEngDst_PM_PointContents_t )		( float **, int ** );
typedef void	(*pfnEngDst_PM_WaterEntity_t )			( float ** );
typedef void	(*pfnEngDst_PM_TraceLine_t )			( float **, float **, int *, int *, int * );
typedef void	(*pfnEngDst_CL_LoadModel_t )			( const char **, int ** );
typedef void	(*pfnEngDst_CL_CreateVisibleEntity_t )	( int *, struct cl_entity_s ** );
typedef void	(*pfnEngDst_GetSpritePointer_t )		( HSPRITE * );
typedef void	(*pfnEngDst_pfnPlaySoundByNameAtLocation_t )	( char **, float *, float ** );
typedef void	(*pfnEngDst_pfnPrecacheEvent_t )		( int *, const char* * );
typedef void	(*pfnEngDst_pfnPlaybackEvent_t )		( int *, const struct edict_s **, unsigned short *, float *, float **, float **, float *, float *, int *, int *, int *, int * );
typedef void	(*pfnEngDst_pfnWeaponAnim_t )			( int *, int * );
typedef void	(*pfnEngDst_pfnRandomFloat_t )			( float *, float * );
typedef void	(*pfnEngDst_pfnRandomLong_t )			( int32 *, int32 * );
typedef void	(*pfnEngDst_pfnHookEvent_t )			( char **, void ( **pfnEvent )( struct event_args_s *args ) );
typedef void	(*pfnEngDst_Con_IsVisible_t)			();
typedef void	(*pfnEngDst_pfnGetGameDirectory_t )		( void );
typedef void	(*pfnEngDst_pfnGetCvarPointer_t )		( const char ** );
typedef void	(*pfnEngDst_Key_LookupBinding_t )		( const char ** );
typedef void	(*pfnEngDst_pfnGetLevelName_t )			( void );
typedef void	(*pfnEngDst_pfnGetScreenFade_t )		( struct screenfade_s ** );
typedef void	(*pfnEngDst_pfnSetScreenFade_t )		( struct screenfade_s ** );
typedef void	(*pfnEngDst_VGui_GetPanel_t )			( );
typedef void	(*pfnEngDst_VGui_ViewportPaintBackground_t ) (int **);
typedef void	(*pfnEngDst_COM_LoadFile_t )			( char **, int *, int ** );
typedef void	(*pfnEngDst_COM_ParseFile_t )			( char **, char ** );
typedef void	(*pfnEngDst_COM_FreeFile_t)				( void ** );
typedef void	(*pfnEngDst_IsSpectateOnly_t )			( void );
typedef void	(*pfnEngDst_LoadMapSprite_t )			( const char ** );
typedef void	(*pfnEngDst_COM_AddAppDirectoryToSearchPath_t ) ( const char **, const char ** );
typedef void	(*pfnEngDst_COM_ExpandFilename_t)		( const char **, char **, int * );
typedef void	(*pfnEngDst_PlayerInfo_ValueForKey_t )	( int *, const char ** );
typedef void	(*pfnEngDst_PlayerInfo_SetValueForKey_t )( const char **, const char ** );
typedef void	(*pfnEngDst_GetPlayerUniqueID_t)		(int *, char **);
typedef void	(*pfnEngDst_GetTrackerIDForPlayer_t)	(int *);
typedef void	(*pfnEngDst_GetPlayerForTrackerID_t)	(int *);
typedef void	(*pfnEngDst_pfnServerCmdUnreliable_t )	( char ** );
typedef void	(*pfnEngDst_GetMousePos_t )				(struct tagPOINT **);
typedef void	(*pfnEngDst_SetMousePos_t )				(int *, int *);
typedef void	(*pfnEngDst_SetMouseEnable_t )			(qboolean *);
typedef void	(*pfnEngDst_pfnSetFilterMode_t)			( int * );
typedef void	(*pfnEngDst_pfnSetFilterColor_t)		( float *, float *, float * );
typedef void	(*pfnEngDst_pfnSetFilterBrightness_t)	( float * );
typedef void	(*pfnEngDst_pfnSequenceGet_t )			( const char**, const char** );
typedef void	(*pfnEngDst_pfnSPR_DrawGeneric_t )		( int *, int *, int *, const struct rect_s **, int *, int *, int *, int * );
typedef void	(*pfnEngDst_pfnSequencePickSentence_t )	( const char**, int *, int ** );
typedef void	(*pfnEngDst_pfnDrawString_t )			( int *, int *, const char *, int *, int *, int * );
typedef void	(*pfnEngDst_pfnDrawStringReverse_t )			( int *, int *, const char *, int *, int *, int * );
typedef void	(*pfnEngDst_LocalPlayerInfo_ValueForKey_t )( const char **);
typedef void	(*pfnEngDst_pfnVGUI2DrawCharacter_t )		( int *, int *, int *, unsigned int * );
typedef void	(*pfnEngDst_pfnVGUI2DrawCharacterAdd_t )	( int *, int *, int *, int *, int *, int *, unsigned int *);
typedef void	(*pfnEngDst_pfnProcessTutorMessageDecayBuffer_t )(int **, int *);
typedef void	(*pfnEngDst_pfnConstructTutorMessageDecayBuffer_t )(int **, int *);
typedef void	(*pfnEngDst_pfnResetTutorMessageDecayData_t)();
typedef void	(*pfnEngDst_pfnFillRGBABlend_t )				( int *, int *, int *, int *, int *, int *, int *, int * );
typedef void	(*pfnEngDst_pfnGetAppID_t )				( void );
typedef void	(*pfnEngDst_pfnGetAliases_t )				( void );
typedef void	(*pfnEngDst_pfnVguiWrap2_GetMouseDelta_t) ( int *x, int *y );




// Pointers to the engine destination functions
typedef struct
{
	pfnEngDst_pfnSPR_Load_t					pfnSPR_Load;
	pfnEngDst_pfnSPR_Frames_t				pfnSPR_Frames;
	pfnEngDst_pfnSPR_Height_t				pfnSPR_Height;
	pfnEngDst_pfnSPR_Width_t				pfnSPR_Width;
	pfnEngDst_pfnSPR_Set_t					pfnSPR_Set;
	pfnEngDst_pfnSPR_Draw_t					pfnSPR_Draw;
	pfnEngDst_pfnSPR_DrawHoles_t			pfnSPR_DrawHoles;
	pfnEngDst_pfnSPR_DrawAdditive_t			pfnSPR_DrawAdditive;
	pfnEngDst_pfnSPR_EnableScissor_t		pfnSPR_EnableScissor;
	pfnEngDst_pfnSPR_DisableScissor_t		pfnSPR_DisableScissor;
	pfnEngDst_pfnSPR_GetList_t				pfnSPR_GetList;
	pfnEngDst_pfnFillRGBA_t					pfnFillRGBA;
	pfnEngDst_pfnGetScreenInfo_t			pfnGetScreenInfo;
	pfnEngDst_pfnSetCrosshair_t				pfnSetCrosshair;
	pfnEngDst_pfnRegisterVariable_t			pfnRegisterVariable;
	pfnEngDst_pfnGetCvarFloat_t				pfnGetCvarFloat;
	pfnEngDst_pfnGetCvarString_t			pfnGetCvarString;
	pfnEngDst_pfnAddCommand_t				pfnAddCommand;
	pfnEngDst_pfnHookUserMsg_t				pfnHookUserMsg;
	pfnEngDst_pfnServerCmd_t				pfnServerCmd;
	pfnEngDst_pfnClientCmd_t				pfnClientCmd;
	pfnEngDst_pfnGetPlayerInfo_t			pfnGetPlayerInfo;
	pfnEngDst_pfnPlaySoundByName_t			pfnPlaySoundByName;
	pfnEngDst_pfnPlaySoundByIndex_t			pfnPlaySoundByIndex;
	pfnEngDst_pfnAngleVectors_t				pfnAngleVectors;
	pfnEngDst_pfnTextMessageGet_t			pfnTextMessageGet;
	pfnEngDst_pfnDrawCharacter_t			pfnDrawCharacter;
	pfnEngDst_pfnDrawConsoleString_t		pfnDrawConsoleString;
	pfnEngDst_pfnDrawSetTextColor_t			pfnDrawSetTextColor;
	pfnEngDst_pfnDrawConsoleStringLen_t		pfnDrawConsoleStringLen;
	pfnEngDst_pfnConsolePrint_t				pfnConsolePrint;
	pfnEngDst_pfnCenterPrint_t				pfnCenterPrint;
	pfnEngDst_GetWindowCenterX_t			GetWindowCenterX;
	pfnEngDst_GetWindowCenterY_t			GetWindowCenterY;
	pfnEngDst_GetViewAngles_t				GetViewAngles;
	pfnEngDst_SetViewAngles_t				SetViewAngles;
	pfnEngDst_GetMaxClients_t				GetMaxClients;
	pfnEngDst_Cvar_SetValue_t				Cvar_SetValue;
	pfnEngDst_Cmd_Argc_t					Cmd_Argc;
	pfnEngDst_Cmd_Argv_t					Cmd_Argv;
	pfnEngDst_Con_Printf_t					Con_Printf;
	pfnEngDst_Con_DPrintf_t					Con_DPrintf;
	pfnEngDst_Con_NPrintf_t					Con_NPrintf;
	pfnEngDst_Con_NXPrintf_t				Con_NXPrintf;
	pfnEngDst_PhysInfo_ValueForKey_t		PhysInfo_ValueForKey;
	pfnEngDst_ServerInfo_ValueForKey_t		ServerInfo_ValueForKey;
	pfnEngDst_GetClientMaxspeed_t			GetClientMaxspeed;
	pfnEngDst_CheckParm_t					CheckParm;
	pfnEngDst_Key_Event_t					Key_Event;
	pfnEngDst_GetMousePosition_t			GetMousePosition;
	pfnEngDst_IsNoClipping_t				IsNoClipping;
	pfnEngDst_GetLocalPlayer_t				GetLocalPlayer;
	pfnEngDst_GetViewModel_t				GetViewModel;
	pfnEngDst_GetEntityByIndex_t			GetEntityByIndex;
	pfnEngDst_GetClientTime_t				GetClientTime;
	pfnEngDst_V_CalcShake_t					V_CalcShake;
	pfnEngDst_V_ApplyShake_t				V_ApplyShake;
	pfnEngDst_PM_PointContents_t			PM_PointContents;
	pfnEngDst_PM_WaterEntity_t				PM_WaterEntity;
	pfnEngDst_PM_TraceLine_t				PM_TraceLine;
	pfnEngDst_CL_LoadModel_t				CL_LoadModel;
	pfnEngDst_CL_CreateVisibleEntity_t		CL_CreateVisibleEntity;
	pfnEngDst_GetSpritePointer_t			GetSpritePointer;
	pfnEngDst_pfnPlaySoundByNameAtLocation_t	pfnPlaySoundByNameAtLocation;
	pfnEngDst_pfnPrecacheEvent_t			pfnPrecacheEvent;
	pfnEngDst_pfnPlaybackEvent_t			pfnPlaybackEvent;
	pfnEngDst_pfnWeaponAnim_t				pfnWeaponAnim;
	pfnEngDst_pfnRandomFloat_t				pfnRandomFloat;
	pfnEngDst_pfnRandomLong_t				pfnRandomLong;
	pfnEngDst_pfnHookEvent_t				pfnHookEvent;
	pfnEngDst_Con_IsVisible_t				Con_IsVisible;
	pfnEngDst_pfnGetGameDirectory_t			pfnGetGameDirectory;
	pfnEngDst_pfnGetCvarPointer_t			pfnGetCvarPointer;
	pfnEngDst_Key_LookupBinding_t			Key_LookupBinding;
	pfnEngDst_pfnGetLevelName_t				pfnGetLevelName;
	pfnEngDst_pfnGetScreenFade_t			pfnGetScreenFade;
	pfnEngDst_pfnSetScreenFade_t			pfnSetScreenFade;
	pfnEngDst_VGui_GetPanel_t				VGui_GetPanel;
	pfnEngDst_VGui_ViewportPaintBackground_t	VGui_ViewportPaintBackground;
	pfnEngDst_COM_LoadFile_t				COM_LoadFile;
	pfnEngDst_COM_ParseFile_t				COM_ParseFile;
	pfnEngDst_COM_FreeFile_t				COM_FreeFile;
	struct triangleapi_s		*pTriAPI;
	struct efx_api_s			*pEfxAPI;
	struct event_api_s			*pEventAPI;
	struct demo_api_s			*pDemoAPI;
	struct net_api_s			*pNetAPI;
	struct IVoiceTweak_s		*pVoiceTweak;
	pfnEngDst_IsSpectateOnly_t				IsSpectateOnly;
	pfnEngDst_LoadMapSprite_t				LoadMapSprite;
	pfnEngDst_COM_AddAppDirectoryToSearchPath_t		COM_AddAppDirectoryToSearchPath;
	pfnEngDst_COM_ExpandFilename_t			COM_ExpandFilename;
	pfnEngDst_PlayerInfo_ValueForKey_t		PlayerInfo_ValueForKey;
	pfnEngDst_PlayerInfo_SetValueForKey_t	PlayerInfo_SetValueForKey;
	pfnEngDst_GetPlayerUniqueID_t			GetPlayerUniqueID;
	pfnEngDst_GetTrackerIDForPlayer_t		GetTrackerIDForPlayer;
	pfnEngDst_GetPlayerForTrackerID_t		GetPlayerForTrackerID;
	pfnEngDst_pfnServerCmdUnreliable_t		pfnServerCmdUnreliable;
	pfnEngDst_GetMousePos_t					pfnGetMousePos;
	pfnEngDst_SetMousePos_t					pfnSetMousePos;
	pfnEngDst_SetMouseEnable_t				pfnSetMouseEnable;
	pfnEngDst_pfnSetFilterMode_t			pfnSetFilterMode ;
	pfnEngDst_pfnSetFilterColor_t			pfnSetFilterColor ;
	pfnEngDst_pfnSetFilterBrightness_t		pfnSetFilterBrightness ;
	pfnEngDst_pfnSequenceGet_t				pfnSequenceGet;
	pfnEngDst_pfnSPR_DrawGeneric_t			pfnSPR_DrawGeneric;
	pfnEngDst_pfnSequencePickSentence_t		pfnSequencePickSentence;
	pfnEngDst_pfnDrawString_t				pfnDrawString;
	pfnEngDst_pfnDrawString_t				pfnDrawStringReverse;
	pfnEngDst_LocalPlayerInfo_ValueForKey_t	LocalPlayerInfo_ValueForKey;
	pfnEngDst_pfnVGUI2DrawCharacter_t		pfnVGUI2DrawCharacter;
	pfnEngDst_pfnVGUI2DrawCharacterAdd_t	pfnVGUI2DrawCharacterAdd;
	pfnEngDst_pfnPlaySoundVoiceByName_t	pfnPlaySoundVoiceByName;
	pfnEngDst_pfnPrimeMusicStream_t			pfnPrimeMusicStream;
	pfnEngDst_pfnProcessTutorMessageDecayBuffer_t		pfnProcessTutorMessageDecayBuffer;
	pfnEngDst_pfnConstructTutorMessageDecayBuffer_t		pfnConstructTutorMessageDecayBuffer;
	pfnEngDst_pfnResetTutorMessageDecayData_t		pfnResetTutorMessageDecayData;
	pfnEngDst_pfnPlaySoundByNameAtPitch_t	pfnPlaySoundByNameAtPitch;
	pfnEngDst_pfnFillRGBABlend_t					pfnFillRGBABlend;
	pfnEngDst_pfnGetAppID_t							pfnGetAppID;
	pfnEngDst_pfnGetAliases_t				pfnGetAliasList;
	pfnEngDst_pfnVguiWrap2_GetMouseDelta_t	pfnVguiWrap2_GetMouseDelta;
} cl_enginefunc_dst_t;


// ********************************************************
// Functions exposed by the engine to the module
// ********************************************************

// Functions for ModuleS
typedef void (*PFN_KICKPLAYER)(int nPlayerSlot, int nReason);

typedef struct modshelpers_s
{
	PFN_KICKPLAYER m_pfnKickPlayer;

	// reserved for future expansion
	int m_nVoid1;
	int m_nVoid2;
	int m_nVoid3;
	int m_nVoid4;
	int m_nVoid5;
	int m_nVoid6;
	int m_nVoid7;
	int m_nVoid8;
	int m_nVoid9;
} modshelpers_t;

// Functions for moduleC
typedef struct modchelpers_s
{
	// reserved for future expansion
	int m_nVoid0;
	int m_nVoid1;
	int m_nVoid2;
	int m_nVoid3;
	int m_nVoid4;
	int m_nVoid5;
	int m_nVoid6;
	int m_nVoid7;
	int m_nVoid8;
	int m_nVoid9;
} modchelpers_t;


// ********************************************************
// Information about the engine
// ********************************************************
typedef struct engdata_s
{
	cl_enginefunc_t	*pcl_enginefuncs;		// functions exported by the engine
	cl_enginefunc_dst_t *pg_engdstAddrs;	// destination handlers for engine exports
	cldll_func_t *pcl_funcs;				// client exports
	cldll_func_dst_t *pg_cldstAddrs;		// client export destination handlers
	struct modfuncs_s *pg_modfuncs;			// engine's pointer to module functions
	struct cmd_function_s **pcmd_functions;	// list of all registered commands
	void *pkeybindings;						// all key bindings (not really a void *, but easier this way)
	void (*pfnConPrintf)(char *, ...);		// dump to console
	struct cvar_s **pcvar_vars;				// pointer to head of cvar list
	struct glwstate_t *pglwstate;			// OpenGl information
	void *(*pfnSZ_GetSpace)(struct sizebuf_s *, int); // pointer to SZ_GetSpace
	struct modfuncs_s *pmodfuncs;			// &g_modfuncs
	void *pfnGetProcAddress;				// &GetProcAddress
	void *pfnGetModuleHandle;				// &GetModuleHandle
	struct server_static_s *psvs;			// &svs
	struct client_static_s *pcls;			// &cls
	void (*pfnSV_DropClient)(struct client_s *, qboolean, char *, ...);	// pointer to SV_DropClient
	void (*pfnNetchan_Transmit)(struct netchan_s *, int, byte *);		// pointer to Netchan_Transmit
	void (*pfnNET_SendPacket)(enum netsrc_s sock, int length, void *data, netadr_t to); // &NET_SendPacket
	struct cvar_s *(*pfnCvarFindVar)(const char *pchName);				// pointer to Cvar_FindVar
	int *phinstOpenGlEarly;					// &g_hinstOpenGlEarly

	// Reserved for future expansion
	void *pVoid0;							// reserved for future expan
	void *pVoid1;							// reserved for future expan
	void *pVoid2;							// reserved for future expan
	void *pVoid3;							// reserved for future expan
	void *pVoid4;							// reserved for future expan
	void *pVoid5;							// reserved for future expan
	void *pVoid6;							// reserved for future expan
	void *pVoid7;							// reserved for future expan
	void *pVoid8;							// reserved for future expan
	void *pVoid9;							// reserved for future expan
} engdata_t;


// ********************************************************
// Functions exposed by the security module
// ********************************************************
typedef void (*PFN_LOADMOD)(char *pchModule);
typedef void (*PFN_CLOSEMOD)(void);
typedef int (*PFN_NCALL)(int ijump, int cnArg, ...);

typedef void (*PFN_GETCLDSTADDRS)(cldll_func_dst_t *pcldstAddrs);
typedef void (*PFN_GETENGDSTADDRS)(cl_enginefunc_dst_t *pengdstAddrs);
typedef void (*PFN_MODULELOADED)(void);

typedef void (*PFN_PROCESSOUTGOINGNET)(struct netchan_s *pchan, struct sizebuf_s *psizebuf);
typedef qboolean (*PFN_PROCESSINCOMINGNET)(struct netchan_s *pchan, struct sizebuf_s *psizebuf);

typedef void (*PFN_TEXTURELOAD)(char *pszName, int dxWidth, int dyHeight, char *pbData);
typedef void (*PFN_MODELLOAD)(struct model_s *pmodel, void *pvBuf);

typedef void (*PFN_FRAMEBEGIN)(void);
typedef void (*PFN_FRAMERENDER1)(void);
typedef void (*PFN_FRAMERENDER2)(void);

typedef void (*PFN_SETMODSHELPERS)(modshelpers_t *pmodshelpers);
typedef void (*PFN_SETMODCHELPERS)(modchelpers_t *pmodchelpers);
typedef void (*PFN_SETENGDATA)(engdata_t *pengdata);

typedef void (*PFN_CONNECTCLIENT)(int iPlayer);
typedef void (*PFN_RECORDIP)(unsigned int pnIP);
typedef void (*PFN_PLAYERSTATUS)(unsigned char *pbData, int cbData);

typedef void (*PFN_SETENGINEVERSION)(int nVersion);

// typedef class CMachine *(*PFN_PCMACHINE)(void);
typedef int (*PFN_PCMACHINE)(void);
typedef void (*PFN_SETIP)(int ijump);
typedef void (*PFN_EXECUTE)(void);

typedef struct modfuncs_s
{
	// Functions for the pcode interpreter
	PFN_LOADMOD m_pfnLoadMod;
	PFN_CLOSEMOD m_pfnCloseMod;
	PFN_NCALL m_pfnNCall;

	// API destination functions
	PFN_GETCLDSTADDRS m_pfnGetClDstAddrs;
	PFN_GETENGDSTADDRS m_pfnGetEngDstAddrs;

	// Miscellaneous functions
	PFN_MODULELOADED m_pfnModuleLoaded;     // Called right after the module is loaded

	// Functions for processing network traffic
	PFN_PROCESSOUTGOINGNET m_pfnProcessOutgoingNet;   // Every outgoing packet gets run through this
	PFN_PROCESSINCOMINGNET m_pfnProcessIncomingNet;   // Every incoming packet gets run through this

	// Resource functions
	PFN_TEXTURELOAD m_pfnTextureLoad;     // Called as each texture is loaded
	PFN_MODELLOAD m_pfnModelLoad;         // Called as each model is loaded

	// Functions called every frame
	PFN_FRAMEBEGIN m_pfnFrameBegin;       // Called at the beginning of each frame cycle
	PFN_FRAMERENDER1 m_pfnFrameRender1;   // Called at the beginning of the render loop
	PFN_FRAMERENDER2 m_pfnFrameRender2;   // Called at the end of the render loop

	// Module helper transfer
	PFN_SETMODSHELPERS m_pfnSetModSHelpers;
	PFN_SETMODCHELPERS m_pfnSetModCHelpers;
	PFN_SETENGDATA m_pfnSetEngData;

	// Which version of the module is this?
	int m_nVersion;

	// Miscellaneous game stuff
	PFN_CONNECTCLIENT m_pfnConnectClient;	// Called whenever a new client connects
	PFN_RECORDIP m_pfnRecordIP;				// Secure master has reported a new IP for us
	PFN_PLAYERSTATUS m_pfnPlayerStatus;		// Called whenever we receive a PlayerStatus packet

	// Recent additions
	PFN_SETENGINEVERSION m_pfnSetEngineVersion;	// 1 = patched engine

	// reserved for future expansion
	int m_nVoid2;
	int m_nVoid3;
	int m_nVoid4;
	int m_nVoid5;
	int m_nVoid6;
	int m_nVoid7;
	int m_nVoid8;
	int m_nVoid9;
} modfuncs_t;


#define k_nEngineVersion15Base		0
#define k_nEngineVersion15Patch		1
#define k_nEngineVersion16Base		2
#define k_nEngineVersion16Validated	3		// 1.6 engine with built-in validation


typedef struct validator_s
{
	int m_nRandomizer;			// Random number to be XOR'd into all subsequent fields
	int m_nSignature1;			// First signature that identifies this structure
	int m_nSignature2;			// Second signature
	int m_pbCode;				// Beginning of the code block
	int m_cbCode;				// Size of the code block
	int m_nChecksum;			// Checksum of the code block
	int m_nSpecial;				// For engine, 1 if hw.dll, 0 if sw.dll.  For client, pclfuncs checksum
	int m_nCompensator;			// Keeps the checksum correct
} validator_t;


#define k_nChecksumCompensator 0x36a8f09c	// Don't change this value: it's hardcorded in cdll_int.cpp, 

#define k_nModuleVersionCur 0x43210004


#endif // __APIPROXY__

```

`halflife/engine/BEAMDEF.H`:

```H
/***
*
*	Copyright (c) 1999, 2000, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined ( BEAMDEFH )
#define BEAMDEFH
#pragma once

#define FBEAM_STARTENTITY		0x00000001
#define FBEAM_ENDENTITY			0x00000002
#define FBEAM_FADEIN			0x00000004
#define FBEAM_FADEOUT			0x00000008
#define FBEAM_SINENOISE			0x00000010
#define FBEAM_SOLID				0x00000020
#define FBEAM_SHADEIN			0x00000040
#define FBEAM_SHADEOUT			0x00000080
#define FBEAM_STARTVISIBLE		0x10000000		// Has this client actually seen this beam's start entity yet?
#define FBEAM_ENDVISIBLE		0x20000000		// Has this client actually seen this beam's end entity yet?
#define FBEAM_ISACTIVE			0x40000000
#define FBEAM_FOREVER			0x80000000

typedef struct beam_s BEAM;
struct beam_s
{
	BEAM		*next;
	int			type;
	int			flags;
	vec3_t		source;
	vec3_t		target;
	vec3_t		delta;
	float		t;		// 0 .. 1 over lifetime of beam
	float		freq;
	float		die;
	float		width;
	float		amplitude;
	float		r, g, b;
	float		brightness;
	float		speed;
	float		frameRate;
	float		frame;
	int			segments;
	int			startEntity;
	int			endEntity;
	int			modelIndex;
	int			frameCount;
	struct model_s		*pFollowModel;
	struct particle_s	*particles;
};

#endif
```

`halflife/engine/CDLL_DLL.H`:

```H
/***
*
*	Copyright (c) 1999, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
//  cdll_dll.h

// this file is included by both the game-dll and the client-dll,

#ifndef CDLL_DLL_H
#define CDLL_DLL_H

#define MAX_WEAPONS		32		// ???

#define MAX_WEAPON_SLOTS		5	// hud item selection slots
#define MAX_ITEM_TYPES			6	// hud item selection slots

#define MAX_ITEMS				5	// hard coded item types

#define	HIDEHUD_WEAPONS		( 1<<0 )
#define	HIDEHUD_FLASHLIGHT	( 1<<1 )
#define	HIDEHUD_ALL			( 1<<2 )
#define 	HIDEHUD_HEALTH		( 1<<3 )

#define	MAX_AMMO_TYPES	32		// ???
#define MAX_AMMO_SLOTS  32		// not really slots

#define HUD_PRINTNOTIFY		1
#define HUD_PRINTCONSOLE	2
#define HUD_PRINTTALK		3
#define HUD_PRINTCENTER		4


#define WEAPON_SUIT			31

#endif
```

`halflife/engine/CDLL_INT2.H`:

```H
/***
*
*	Copyright (c) 1999, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
//  cdll_int.h
//
// 4-23-98  
// JOHN:  client dll interface declarations
//

#ifndef CDLL_INT_H
#define CDLL_INT_H

#ifdef __cplusplus
extern "C" {
#endif

#include "const.h"

// this file is included by both the engine and the client-dll,
// so make sure engine declarations aren't done twice

//typedef int HSPRITE;	// handle to a graphic

#define SCRINFO_SCREENFLASH 1
#define SCRINFO_STRETCHED	2

typedef struct
{
	int		iSize;
	int		iWidth;
	int		iHeight;
	int		iFlags;
	int		iCharHeight;
	short	charWidths[256];
} SCREENINFO;


typedef struct client_data_s
{
	// fields that cannot be modified  (ie. have no effect if changed)
	vec3_t origin;

	// fields that can be changed by the cldll
	vec3_t viewangles;
	int		iWeaponBits;
	float	fov;	// field of view
} client_data_t;

typedef struct client_sprite_s
{
	char szName[64];
	char szSprite[64];
	int hspr;
	int iRes;
	wrect_t rc;
} client_sprite_t;

typedef struct
{
	int		effect;
	byte	r1, g1, b1, a1;		// 2 colors for effects
	byte	r2, g2, b2, a2;
	float	x;
	float	y;
	float	fadein;
	float	fadeout;
	float	holdtime;
	float	fxtime;
	const char *pName;
	const char *pMessage;
} client_textmessage_t;

typedef struct
{
	char *name;
	short ping;
	byte thisplayer;  // TRUE if this is the calling player

  // stuff that's unused at the moment,  but should be done
	byte spectator;
	byte packetloss;

	char *model;
	short topcolor;
	short bottomcolor;

} hud_player_info_t;


// this is by no means complete,  or even accurate
typedef struct cl_enginefuncs_s
{
	// sprite handlers
	int						( *pfnSPR_Load )			( const char *szPicName );
	int							( *pfnSPR_Frames )			( int hPic );
	int							( *pfnSPR_Height )			( int hPic, int frame );
	int							( *pfnSPR_Width )			( int hPic, int frame );
	void						( *pfnSPR_Set )				( int hPic, int r, int g, int b );
	void						( *pfnSPR_Draw )			( int frame, int x, int y, const wrect_t *prc );
	void						( *pfnSPR_DrawHoles )		( int frame, int x, int y, const wrect_t *prc );
	void						( *pfnSPR_DrawAdditive )	( int frame, int x, int y, const wrect_t *prc );
	void						( *pfnSPR_EnableScissor )	( int x, int y, int width, int height );
	void						( *pfnSPR_DisableScissor )	( void );
	client_sprite_t				*( *pfnSPR_GetList )			( char *psz, int *piCount );

	// screen handlers
	void						( *pfnFillRGBA )			( int x, int y, int width, int height, int r, int g, int b, int a );
	int							( *pfnGetScreenInfo ) 		( SCREENINFO *pscrinfo );
	void						( *pfnSetCrosshair )		( int hspr, wrect_t rc, int r, int g, int b );

	// cvar handlers
	struct cvar_s				*( *pfnRegisterVariable )	( char *szName, char *szValue, int flags );
	float						( *pfnGetCvarFloat )		( char *szName );
	char*						( *pfnGetCvarString )		( char *szName );

	// command handlers
	int							( *pfnAddCommand )			( char *cmd_name, void (*function)(void) );
	int							( *pfnHookUserMsg )			( char *szMsgName, pfnUserMsgHook pfn );
	int							( *pfnServerCmd )			( char *szCmdString );
	int							( *pfnClientCmd )			( char *szCmdString );

	void						( *pfnGetPlayerInfo )		( int ent_num, hud_player_info_t *pinfo );

	// sound handlers
	void						( *pfnPlaySoundByName )		( char *szSound, float volume );
	void						( *pfnPlaySoundByIndex )	( int iSound, float volume );

	// vector helpers
	void						( *pfnAngleVectors )		( const float * vecAngles, float * forward, float * right, float * up );

	// text message system
	client_textmessage_t		*( *pfnTextMessageGet )		( const char *pName );
	int							( *pfnDrawCharacter )		( int x, int y, int number, int r, int g, int b );
	int							( *pfnDrawConsoleString )	( int x, int y, char *string );
	void						( *pfnDrawSetTextColor )	( float r, float g, float b );
	void						( *pfnDrawConsoleStringLen )(  const char *string, int *length, int *height );

	void						( *pfnConsolePrint )		( const char *string );
	void						( *pfnCenterPrint )			( const char *string );


// Added for user input processing
	int							( *GetWindowCenterX )		( void );
	int							( *GetWindowCenterY )		( void );
	void						( *GetViewAngles )			( float * );
	void						( *SetViewAngles )			( float * );
	int							( *GetMaxClients )			( void );
	void						( *Cvar_SetValue )			( char *cvar, float value );

	int       					(*Cmd_Argc)					(void);	
	char						*( *Cmd_Argv )				( int arg );
	void						( *Con_Printf )				( char *fmt, ... );
	void						( *Con_DPrintf )			( char *fmt, ... );
	void						( *Con_NPrintf )			( int pos, char *fmt, ... );
	void						( *Con_NXPrintf )			( struct con_nprint_s *info, char *fmt, ... );

	const char					*( *PhysInfo_ValueForKey )	( const char *key );
	const char					*( *ServerInfo_ValueForKey )( const char *key );
	float						( *GetClientMaxspeed )		( void );
	int							( *CheckParm )				( char *parm, char **ppnext );
	void						( *Key_Event )				( int key, int down );
	void						( *GetMousePosition )		( int *mx, int *my );
	int							( *IsNoClipping )			( void );

	struct cl_entity_s			*( *GetLocalPlayer )		( void );
	struct cl_entity_s			*( *GetViewModel )			( void );
	struct cl_entity_s			*( *GetEntityByIndex )		( int idx );

	float						( *GetClientTime )			( void );
	void						( *V_CalcShake )			( void );
	void						( *V_ApplyShake )			( float *origin, float *angles, float factor );

	int							( *PM_PointContents )		( float *point, int *truecontents );
	int							( *PM_WaterEntity )			( float *p );
	struct pmtrace_s			*( *PM_TraceLine )			( float *start, float *end, int flags, int usehull, int ignore_pe );

	struct model_s				*( *CL_LoadModel )			( const char *modelname, int *index );
	int							( *CL_CreateVisibleEntity )	( int type, struct cl_entity_s *ent );

	const struct model_s *		( *GetSpritePointer )		( int hSprite );
	void						( *pfnPlaySoundByNameAtLocation )	( char *szSound, float volume, float *origin );

	unsigned short				( *pfnPrecacheEvent )		( int type, const char* psz );
	void						( *pfnPlaybackEvent )		( int flags, const struct edict_s *pInvoker, unsigned short eventindex, float delay, float *origin, float *angles, float fparam1, float fparam2, int iparam1, int iparam2, int bparam1, int bparam2 );
	void						( *pfnWeaponAnim )			( int iAnim, int body );
	float						( *pfnRandomFloat )			( float flLow, float flHigh );
	long						( *pfnRandomLong )			( long lLow, long lHigh );
	void						( *pfnHookEvent )			( char *name, void ( *pfnEvent )( struct event_args_s *args ) );
	int							(*Con_IsVisible)			();
	const char					*( *pfnGetGameDirectory )	( void );
	struct cvar_s				*( *pfnGetCvarPointer )		( const char *szName );
	const char					*( *Key_LookupBinding )		( const char *pBinding );
	const char					*( *pfnGetLevelName )		( void );
	void						( *pfnGetScreenFade )		( struct screenfade_s *fade );
	void						( *pfnSetScreenFade )		( struct screenfade_s *fade );
	void                        *( *VGui_GetPanel )         ( );
	void                         ( *VGui_ViewportPaintBackground ) (int extents[4]);

	byte*						(*COM_LoadFile)				( char *path, int usehunk, int *pLength );
	char*						(*COM_ParseFile)			( char *data, char *token );
	void						(*COM_FreeFile)				( void *buffer );
		
	struct triangleapi_s		*pTriAPI;
	struct efx_api_s			*pEfxAPI;
	struct event_api_s			*pEventAPI;
	struct demo_api_s			*pDemoAPI;
	struct net_api_s			*pNetAPI;
	struct IVoiceTweak_s		*pVoiceTweak;

	// returns 1 if the client is a spectator only (connected to a proxy), 0 otherwise or 2 if in dev_overview mode
	int							( *IsSpectateOnly ) ( void );
	struct model_s				*( *LoadMapSprite )			( const char *filename );

	// file search functions
	void						( *COM_AddAppDirectoryToSearchPath ) ( const char *pszBaseDir, const char *appName );
	int							( *COM_ExpandFilename)				 ( const char *fileName, char *nameOutBuffer, int nameOutBufferSize );

	// User info
	// playerNum is in the range (1, MaxClients)
	// returns NULL if player doesn't exit
	// returns "" if no value is set
	const char					*( *PlayerInfo_ValueForKey )( int playerNum, const char *key );
	void						( *PlayerInfo_SetValueForKey )( const char *key, const char *value );

	// Gets a unique ID for the specified player. This is the same even if you see the player on a different server.
	// iPlayer is an entity index, so client 0 would use iPlayer=1.
	// Returns false if there is no player on the server in the specified slot.
	qboolean					(*GetPlayerUniqueID)(int iPlayer, char playerID[16]);

	// TrackerID access
	int							(*GetTrackerIDForPlayer)(int playerSlot);
	int							(*GetPlayerForTrackerID)(int trackerID);

	// Same as pfnServerCmd, but the message goes in the unreliable stream so it can't clog the net stream
	// (but it might not get there).
	int							( *pfnServerCmdUnreliable )( char *szCmdString );
	struct cmd_s* ( *pfnGetCmdList )( void );
} cl_enginefunc_t;

#ifndef IN_BUTTONS_H
#include "in_buttons.h"
#endif

#define CLDLL_INTERFACE_VERSION		7

extern void ClientDLL_Init( void ); // from cdll_int.c
extern void ClientDLL_Shutdown( void );
extern void ClientDLL_HudInit( void );
extern void ClientDLL_HudVidInit( void );
extern void	ClientDLL_UpdateClientData( void );
extern void ClientDLL_Frame( double time );
extern void ClientDLL_HudRedraw( int intermission );
extern void ClientDLL_MoveClient( struct playermove_s *ppmove );
extern void ClientDLL_ClientMoveInit( struct playermove_s *ppmove );
extern char ClientDLL_ClientTextureType( char *name );

extern void ClientDLL_CreateMove( float frametime, struct usercmd_s *cmd, int active );
extern void ClientDLL_ActivateMouse( void );
extern void ClientDLL_DeactivateMouse( void );
extern void ClientDLL_MouseEvent( int mstate );
extern void ClientDLL_ClearStates( void );
extern int ClientDLL_IsThirdPerson( void );
extern void ClientDLL_GetCameraOffsets( float *ofs );
extern int ClientDLL_GraphKeyDown( void );
extern struct kbutton_s *ClientDLL_FindKey( const char *name );
extern void ClientDLL_CAM_Think( void );
extern void ClientDLL_IN_Accumulate( void );
extern void ClientDLL_CalcRefdef( struct ref_params_s *pparams );
extern int ClientDLL_AddEntity( int type, struct cl_entity_s *ent );
extern void ClientDLL_CreateEntities( void );

extern void ClientDLL_DrawNormalTriangles( void );
extern void ClientDLL_DrawTransparentTriangles( void );
extern void ClientDLL_StudioEvent( const struct mstudioevent_s *event, const struct cl_entity_s *entity );
extern void ClientDLL_PostRunCmd( struct local_state_s *from, struct local_state_s *to, struct usercmd_s *cmd, int runfuncs, double time, unsigned int random_seed );
extern void ClientDLL_TxferLocalOverrides( struct entity_state_s *state, const struct clientdata_s *client );
extern void ClientDLL_ProcessPlayerState( struct entity_state_s *dst, const struct entity_state_s *src );
extern void ClientDLL_TxferPredictionData ( struct entity_state_s *ps, const struct entity_state_s *pps, struct clientdata_s *pcd, const struct clientdata_s *ppcd, struct weapon_data_s *wd, const struct weapon_data_s *pwd );
extern void ClientDLL_ReadDemoBuffer( int size, unsigned char *buffer );
extern int ClientDLL_ConnectionlessPacket( const struct netadr_s *net_from, const char *args, char *response_buffer, int *response_buffer_size );
extern int ClientDLL_GetHullBounds( int hullnumber, float *mins, float *maxs );

extern void ClientDLL_VGui_ConsolePrint(const char* text);

extern int ClientDLL_Key_Event( int down, int keynum, const char *pszCurrentBinding );
extern void ClientDLL_TempEntUpdate( double ft, double ct, double grav, struct tempent_s **ppFreeTE, struct tempent_s **ppActiveTE, int ( *addTEntity )( struct cl_entity_s *pEntity ), void ( *playTESound )( struct tempent_s *pTemp, float damp ) );
extern struct cl_entity_s *ClientDLL_GetUserEntity( int index );
extern void ClientDLL_VoiceStatus(int entindex, qboolean bTalking);
extern void ClientDLL_DirectorEvent(unsigned char command, unsigned int firstObject, unsigned int secondObject, unsigned int flags);


#ifdef __cplusplus
}
#endif

#endif // CDLL_INT_H

```

`halflife/engine/CL_DLL.H`:

```H
/***
*
*	Copyright (c) 1999, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
//  cl_dll.h
//

// 4-23-98  JOHN

//
//  This DLL is linked by the client when they first initialize.
// This DLL is responsible for the following tasks:
//		- Loading the HUD graphics upon initialization
//		- Drawing the HUD graphics every frame
//		- Handling the custum HUD-update packets
//
typedef unsigned char byte;
typedef unsigned short word;
typedef float vec_t;
typedef int (*pfnUserMsgHook)(const char *pszName, int iSize, void *pbuf);



```

`halflife/engine/CONST.H`:

```H
/***
*
*	Copyright (c) 1999, 2000, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef CONST_H
#define CONST_H
//
// Constants shared by the engine and dlls
// This header file included by engine files and DLL files.
// Most came from server.h

// edict->flags
#define	FL_FLY					(1<<0)	// Changes the SV_Movestep() behavior to not need to be on ground
#define	FL_SWIM					(1<<1)	// Changes the SV_Movestep() behavior to not need to be on ground (but stay in water)
#define	FL_CONVEYOR				(1<<2)
#define	FL_CLIENT				(1<<3)
#define	FL_INWATER				(1<<4)
#define	FL_MONSTER				(1<<5)
#define	FL_GODMODE				(1<<6)
#define	FL_NOTARGET				(1<<7)
#define	FL_SKIPLOCALHOST		(1<<8)	// Don't send entity to local host, it's predicting this entity itself
#define	FL_ONGROUND				(1<<9)	// At rest / on the ground
#define	FL_PARTIALGROUND		(1<<10)	// not all corners are valid
#define	FL_WATERJUMP			(1<<11)	// player jumping out of water
#define FL_FROZEN				(1<<12) // Player is frozen for 3rd person camera
#define FL_FAKECLIENT			(1<<13)	// JAC: fake client, simulated server side; don't send network messages to them
#define FL_DUCKING				(1<<14)	// Player flag -- Player is fully crouched
#define FL_FLOAT				(1<<15)	// Apply floating force to this entity when in water
#define FL_GRAPHED				(1<<16) // worldgraph has this ent listed as something that blocks a connection

// UNDONE: Do we need these?
#define FL_IMMUNE_WATER			(1<<17)
#define	FL_IMMUNE_SLIME			(1<<18)
#define FL_IMMUNE_LAVA			(1<<19)

#define FL_PROXY				(1<<20)	// This is a spectator proxy
#define FL_ALWAYSTHINK			(1<<21)	// Brush model flag -- call think every frame regardless of nextthink - ltime (for constantly changing velocity/path)
#define FL_BASEVELOCITY			(1<<22)	// Base velocity has been applied this frame (used to convert base velocity into momentum)
#define FL_MONSTERCLIP			(1<<23)	// Only collide in with monsters who have FL_MONSTERCLIP set
#define FL_ONTRAIN				(1<<24) // Player is _controlling_ a train, so movement commands should be ignored on client during prediction.
#define FL_WORLDBRUSH			(1<<25)	// Not moveable/removeable brush entity (really part of the world, but represented as an entity for transparency or something)
#define FL_SPECTATOR            (1<<26) // This client is a spectator, don't run touch functions, etc.
#define FL_CUSTOMENTITY			(1<<29)	// This is a custom entity
#define FL_KILLME				(1<<30)	// This entity is marked for death -- This allows the engine to kill ents at the appropriate time
#define FL_DORMANT				(1<<31)	// Entity is dormant, no updates to client


// Goes into globalvars_t.trace_flags
#define FTRACE_SIMPLEBOX		(1<<0)	// Traceline with a simple box


// walkmove modes
#define	WALKMOVE_NORMAL		0 // normal walkmove
#define WALKMOVE_WORLDONLY	1 // doesn't hit ANY entities, no matter what the solid type
#define WALKMOVE_CHECKONLY	2 // move, but don't touch triggers

// edict->movetype values
#define	MOVETYPE_NONE			0		// never moves
//#define	MOVETYPE_ANGLENOCLIP	1
//#define	MOVETYPE_ANGLECLIP		2
#define	MOVETYPE_WALK			3		// Player only - moving on the ground
#define	MOVETYPE_STEP			4		// gravity, special edge handling -- monsters use this
#define	MOVETYPE_FLY			5		// No gravity, but still collides with stuff
#define	MOVETYPE_TOSS			6		// gravity/collisions
#define	MOVETYPE_PUSH			7		// no clip to world, push and crush
#define	MOVETYPE_NOCLIP			8		// No gravity, no collisions, still do velocity/avelocity
#define	MOVETYPE_FLYMISSILE		9		// extra size to monsters
#define	MOVETYPE_BOUNCE			10		// Just like Toss, but reflect velocity when contacting surfaces
#define MOVETYPE_BOUNCEMISSILE	11		// bounce w/o gravity
#define MOVETYPE_FOLLOW			12		// track movement of aiment
#define	MOVETYPE_PUSHSTEP		13		// BSP model that needs physics/world collisions (uses nearest hull for world collision)

// edict->solid values
// NOTE: Some movetypes will cause collisions independent of SOLID_NOT/SOLID_TRIGGER when the entity moves
// SOLID only effects OTHER entities colliding with this one when they move - UGH!
#define	SOLID_NOT				0		// no interaction with other objects
#define	SOLID_TRIGGER			1		// touch on edge, but not blocking
#define	SOLID_BBOX				2		// touch on edge, block
#define	SOLID_SLIDEBOX			3		// touch on edge, but not an onground
#define	SOLID_BSP				4		// bsp clip, touch on edge, block

// edict->deadflag values
#define	DEAD_NO					0 // alive
#define	DEAD_DYING				1 // playing death animation or still falling off of a ledge waiting to hit ground
#define	DEAD_DEAD				2 // dead. lying still.
#define DEAD_RESPAWNABLE		3
#define DEAD_DISCARDBODY		4

#define	DAMAGE_NO				0
#define	DAMAGE_YES				1
#define	DAMAGE_AIM				2

// entity effects
#define	EF_BRIGHTFIELD			1	// swirling cloud of particles
#define	EF_MUZZLEFLASH 			2	// single frame ELIGHT on entity attachment 0
#define	EF_BRIGHTLIGHT 			4	// DLIGHT centered at entity origin
#define	EF_DIMLIGHT 			8	// player flashlight
#define EF_INVLIGHT				16	// get lighting from ceiling
#define EF_NOINTERP				32	// don't interpolate the next frame
#define EF_LIGHT				64	// rocket flare glow sprite
#define EF_NODRAW				128	// don't draw entity

// entity flags
#define EFLAG_SLERP				1	// do studio interpolation of this entity
		
//
// temp entity events
//
#define	TE_BEAMPOINTS		0		// beam effect between two points
// coord coord coord (start position) 
// coord coord coord (end position) 
// short (sprite index) 
// byte (starting frame) 
// byte (frame rate in 0.1's) 
// byte (life in 0.1's) 
// byte (line width in 0.1's) 
// byte (noise amplitude in 0.01's) 
// byte,byte,byte (color)
// byte (brightness)
// byte (scroll speed in 0.1's)

#define	TE_BEAMENTPOINT		1		// beam effect between point and entity
// short (start entity) 
// coord coord coord (end position) 
// short (sprite index) 
// byte (starting frame) 
// byte (frame rate in 0.1's) 
// byte (life in 0.1's) 
// byte (line width in 0.1's) 
// byte (noise amplitude in 0.01's) 
// byte,byte,byte (color)
// byte (brightness)
// byte (scroll speed in 0.1's)

#define	TE_GUNSHOT			2		// particle effect plus ricochet sound
// coord coord coord (position) 

#define	TE_EXPLOSION		3		// additive sprite, 2 dynamic lights, flickering particles, explosion sound, move vertically 8 pps
// coord coord coord (position) 
// short (sprite index)
// byte (scale in 0.1's)
// byte (framerate)
// byte (flags)
//
// The Explosion effect has some flags to control performance/aesthetic features:
#define TE_EXPLFLAG_NONE		0	// all flags clear makes default Half-Life explosion
#define TE_EXPLFLAG_NOADDITIVE	1	// sprite will be drawn opaque (ensure that the sprite you send is a non-additive sprite)
#define TE_EXPLFLAG_NODLIGHTS	2	// do not render dynamic lights
#define TE_EXPLFLAG_NOSOUND		4	// do not play client explosion sound
#define TE_EXPLFLAG_NOPARTICLES	8	// do not draw particles


#define	TE_TAREXPLOSION		4		// Quake1 "tarbaby" explosion with sound
// coord coord coord (position) 

#define	TE_SMOKE			5		// alphablend sprite, move vertically 30 pps
// coord coord coord (position) 
// short (sprite index)
// byte (scale in 0.1's)
// byte (framerate)

#define	TE_TRACER			6		// tracer effect from point to point
// coord, coord, coord (start) 
// coord, coord, coord (end)

#define	TE_LIGHTNING		7		// TE_BEAMPOINTS with simplified parameters
// coord, coord, coord (start) 
// coord, coord, coord (end) 
// byte (life in 0.1's) 
// byte (width in 0.1's) 
// byte (amplitude in 0.01's)
// short (sprite model index)

#define	TE_BEAMENTS			8		
// short (start entity) 
// short (end entity) 
// short (sprite index) 
// byte (starting frame) 
// byte (frame rate in 0.1's) 
// byte (life in 0.1's) 
// byte (line width in 0.1's) 
// byte (noise amplitude in 0.01's) 
// byte,byte,byte (color)
// byte (brightness)
// byte (scroll speed in 0.1's)

#define	TE_SPARKS			9		// 8 random tracers with gravity, ricochet sprite
// coord coord coord (position) 

#define	TE_LAVASPLASH		10		// Quake1 lava splash
// coord coord coord (position) 

#define	TE_TELEPORT			11		// Quake1 teleport splash
// coord coord coord (position) 

#define TE_EXPLOSION2		12		// Quake1 colormaped (base palette) particle explosion with sound
// coord coord coord (position) 
// byte (starting color)
// byte (num colors)

#define TE_BSPDECAL			13		// Decal from the .BSP file 
// coord, coord, coord (x,y,z), decal position (center of texture in world)
// short (texture index of precached decal texture name)
// short (entity index)
// [optional - only included if previous short is non-zero (not the world)] short (index of model of above entity)

#define TE_IMPLOSION		14		// tracers moving toward a point
// coord, coord, coord (position)
// byte (radius)
// byte (count)
// byte (life in 0.1's) 

#define TE_SPRITETRAIL		15		// line of moving glow sprites with gravity, fadeout, and collisions
// coord, coord, coord (start) 
// coord, coord, coord (end) 
// short (sprite index)
// byte (count)
// byte (life in 0.1's) 
// byte (scale in 0.1's) 
// byte (velocity along vector in 10's)
// byte (randomness of velocity in 10's)

#define TE_BEAM				16		// obsolete

#define TE_SPRITE			17		// additive sprite, plays 1 cycle
// coord, coord, coord (position) 
// short (sprite index) 
// byte (scale in 0.1's) 
// byte (brightness)

#define TE_BEAMSPRITE		18		// A beam with a sprite at the end
// coord, coord, coord (start position) 
// coord, coord, coord (end position) 
// short (beam sprite index) 
// short (end sprite index) 

#define TE_BEAMTORUS		19		// screen aligned beam ring, expands to max radius over lifetime
// coord coord coord (center position) 
// coord coord coord (axis and radius) 
// short (sprite index) 
// byte (starting frame) 
// byte (frame rate in 0.1's) 
// byte (life in 0.1's) 
// byte (line width in 0.1's) 
// byte (noise amplitude in 0.01's) 
// byte,byte,byte (color)
// byte (brightness)
// byte (scroll speed in 0.1's)

#define TE_BEAMDISK			20		// disk that expands to max radius over lifetime
// coord coord coord (center position) 
// coord coord coord (axis and radius) 
// short (sprite index) 
// byte (starting frame) 
// byte (frame rate in 0.1's) 
// byte (life in 0.1's) 
// byte (line width in 0.1's) 
// byte (noise amplitude in 0.01's) 
// byte,byte,byte (color)
// byte (brightness)
// byte (scroll speed in 0.1's)

#define TE_BEAMCYLINDER		21		// cylinder that expands to max radius over lifetime
// coord coord coord (center position) 
// coord coord coord (axis and radius) 
// short (sprite index) 
// byte (starting frame) 
// byte (frame rate in 0.1's) 
// byte (life in 0.1's) 
// byte (line width in 0.1's) 
// byte (noise amplitude in 0.01's) 
// byte,byte,byte (color)
// byte (brightness)
// byte (scroll speed in 0.1's)

#define TE_BEAMFOLLOW		22		// create a line of decaying beam segments until entity stops moving
// short (entity:attachment to follow)
// short (sprite index)
// byte (life in 0.1's) 
// byte (line width in 0.1's) 
// byte,byte,byte (color)
// byte (brightness)

#define TE_GLOWSPRITE		23		
// coord, coord, coord (pos) short (model index) byte (scale / 10)

#define TE_BEAMRING			24		// connect a beam ring to two entities
// short (start entity) 
// short (end entity) 
// short (sprite index) 
// byte (starting frame) 
// byte (frame rate in 0.1's) 
// byte (life in 0.1's) 
// byte (line width in 0.1's) 
// byte (noise amplitude in 0.01's) 
// byte,byte,byte (color)
// byte (brightness)
// byte (scroll speed in 0.1's)

#define TE_STREAK_SPLASH	25		// oriented shower of tracers
// coord coord coord (start position) 
// coord coord coord (direction vector) 
// byte (color)
// short (count)
// short (base speed)
// short (ramdon velocity)

#define TE_BEAMHOSE			26		// obsolete

#define TE_DLIGHT			27		// dynamic light, effect world, minor entity effect
// coord, coord, coord (pos) 
// byte (radius in 10's) 
// byte byte byte (color)
// byte (brightness)
// byte (life in 10's)
// byte (decay rate in 10's)

#define TE_ELIGHT			28		// point entity light, no world effect
// short (entity:attachment to follow)
// coord coord coord (initial position) 
// coord (radius)
// byte byte byte (color)
// byte (life in 0.1's)
// coord (decay rate)

#define TE_TEXTMESSAGE		29
// short 1.2.13 x (-1 = center)
// short 1.2.13 y (-1 = center)
// byte Effect 0 = fade in/fade out
			// 1 is flickery credits
			// 2 is write out (training room)

// 4 bytes r,g,b,a color1	(text color)
// 4 bytes r,g,b,a color2	(effect color)
// ushort 8.8 fadein time
// ushort 8.8  fadeout time
// ushort 8.8 hold time
// optional ushort 8.8 fxtime	(time the highlight lags behing the leading text in effect 2)
// string text message		(512 chars max sz string)
#define TE_LINE				30
// coord, coord, coord		startpos
// coord, coord, coord		endpos
// short life in 0.1 s
// 3 bytes r, g, b

#define TE_BOX				31
// coord, coord, coord		boxmins
// coord, coord, coord		boxmaxs
// short life in 0.1 s
// 3 bytes r, g, b

#define TE_KILLBEAM			99		// kill all beams attached to entity
// short (entity)

#define TE_LARGEFUNNEL		100
// coord coord coord (funnel position)
// short (sprite index) 
// short (flags) 

#define	TE_BLOODSTREAM		101		// particle spray
// coord coord coord (start position)
// coord coord coord (spray vector)
// byte (color)
// byte (speed)

#define	TE_SHOWLINE			102		// line of particles every 5 units, dies in 30 seconds
// coord coord coord (start position)
// coord coord coord (end position)

#define TE_BLOOD			103		// particle spray
// coord coord coord (start position)
// coord coord coord (spray vector)
// byte (color)
// byte (speed)

#define TE_DECAL			104		// Decal applied to a brush entity (not the world)
// coord, coord, coord (x,y,z), decal position (center of texture in world)
// byte (texture index of precached decal texture name)
// short (entity index)

#define TE_FIZZ				105		// create alpha sprites inside of entity, float upwards
// short (entity)
// short (sprite index)
// byte (density)

#define TE_MODEL			106		// create a moving model that bounces and makes a sound when it hits
// coord, coord, coord (position) 
// coord, coord, coord (velocity)
// angle (initial yaw)
// short (model index)
// byte (bounce sound type)
// byte (life in 0.1's)

#define TE_EXPLODEMODEL		107		// spherical shower of models, picks from set
// coord, coord, coord (origin)
// coord (velocity)
// short (model index)
// short (count)
// byte (life in 0.1's)

#define TE_BREAKMODEL		108		// box of models or sprites
// coord, coord, coord (position)
// coord, coord, coord (size)
// coord, coord, coord (velocity)
// byte (random velocity in 10's)
// short (sprite or model index)
// byte (count)
// byte (life in 0.1 secs)
// byte (flags)

#define TE_GUNSHOTDECAL		109		// decal and ricochet sound
// coord, coord, coord (position)
// short (entity index???)
// byte (decal???)

#define TE_SPRITE_SPRAY		110		// spay of alpha sprites
// coord, coord, coord (position)
// coord, coord, coord (velocity)
// short (sprite index)
// byte (count)
// byte (speed)
// byte (noise)

#define TE_ARMOR_RICOCHET	111		// quick spark sprite, client ricochet sound. 
// coord, coord, coord (position)
// byte (scale in 0.1's)

#define TE_PLAYERDECAL		112		// ???
// byte (playerindex)
// coord, coord, coord (position)
// short (entity???)
// byte (decal number???)
// [optional] short (model index???)

#define TE_BUBBLES			113		// create alpha sprites inside of box, float upwards
// coord, coord, coord (min start position)
// coord, coord, coord (max start position)
// coord (float height)
// short (model index)
// byte (count)
// coord (speed)

#define TE_BUBBLETRAIL		114		// create alpha sprites along a line, float upwards
// coord, coord, coord (min start position)
// coord, coord, coord (max start position)
// coord (float height)
// short (model index)
// byte (count)
// coord (speed)

#define TE_BLOODSPRITE		115		// spray of opaque sprite1's that fall, single sprite2 for 1..2 secs (this is a high-priority tent)
// coord, coord, coord (position)
// short (sprite1 index)
// short (sprite2 index)
// byte (color)
// byte (scale)

#define TE_WORLDDECAL		116		// Decal applied to the world brush
// coord, coord, coord (x,y,z), decal position (center of texture in world)
// byte (texture index of precached decal texture name)

#define TE_WORLDDECALHIGH	117		// Decal (with texture index > 256) applied to world brush
// coord, coord, coord (x,y,z), decal position (center of texture in world)
// byte (texture index of precached decal texture name - 256)

#define TE_DECALHIGH		118		// Same as TE_DECAL, but the texture index was greater than 256
// coord, coord, coord (x,y,z), decal position (center of texture in world)
// byte (texture index of precached decal texture name - 256)
// short (entity index)

#define TE_PROJECTILE		119		// Makes a projectile (like a nail) (this is a high-priority tent)
// coord, coord, coord (position)
// coord, coord, coord (velocity)
// short (modelindex)
// byte (life)
// byte (owner)  projectile won't collide with owner (if owner == 0, projectile will hit any client).

#define TE_SPRAY			120		// Throws a shower of sprites or models
// coord, coord, coord (position)
// coord, coord, coord (direction)
// short (modelindex)
// byte (count)
// byte (speed)
// byte (noise)
// byte (rendermode)

#define TE_PLAYERSPRITES	121		// sprites emit from a player's bounding box (ONLY use for players!)
// byte (playernum)
// short (sprite modelindex)
// byte (count)
// byte (variance) (0 = no variance in size) (10 = 10% variance in size)

#define TE_PARTICLEBURST	122		// very similar to lavasplash.
// coord (origin)
// short (radius)
// byte (particle color)
// byte (duration * 10) (will be randomized a bit)

#define TE_FIREFIELD			123		// makes a field of fire.
// coord (origin)
// short (radius) (fire is made in a square around origin. -radius, -radius to radius, radius)
// short (modelindex)
// byte (count)
// byte (flags)
// byte (duration (in seconds) * 10) (will be randomized a bit)
//
// to keep network traffic low, this message has associated flags that fit into a byte:
#define TEFIRE_FLAG_ALLFLOAT	1 // all sprites will drift upwards as they animate
#define TEFIRE_FLAG_SOMEFLOAT	2 // some of the sprites will drift upwards. (50% chance)
#define TEFIRE_FLAG_LOOP		4 // if set, sprite plays at 15 fps, otherwise plays at whatever rate stretches the animation over the sprite's duration.
#define TEFIRE_FLAG_ALPHA		8 // if set, sprite is rendered alpha blended at 50% else, opaque
#define TEFIRE_FLAG_PLANAR		16 // if set, all fire sprites have same initial Z instead of randomly filling a cube. 

#define TE_PLAYERATTACHMENT			124 // attaches a TENT to a player (this is a high-priority tent)
// byte (entity index of player)
// coord (vertical offset) ( attachment origin.z = player origin.z + vertical offset )
// short (model index)
// short (life * 10 );

#define TE_KILLPLAYERATTACHMENTS	125 // will expire all TENTS attached to a player.
// byte (entity index of player)

#define TE_MULTIGUNSHOT				126 // much more compact shotgun message
// This message is used to make a client approximate a 'spray' of gunfire.
// Any weapon that fires more than one bullet per frame and fires in a bit of a spread is
// a good candidate for MULTIGUNSHOT use. (shotguns)
//
// NOTE: This effect makes the client do traces for each bullet, these client traces ignore
//		 entities that have studio models.Traces are 4096 long.
//
// coord (origin)
// coord (origin)
// coord (origin)
// coord (direction)
// coord (direction)
// coord (direction)
// coord (x noise * 100)
// coord (y noise * 100)
// byte (count)
// byte (bullethole decal texture index)

#define TE_USERTRACER				127 // larger message than the standard tracer, but allows some customization.
// coord (origin)
// coord (origin)
// coord (origin)
// coord (velocity)
// coord (velocity)
// coord (velocity)
// byte ( life * 10 )
// byte ( color ) this is an index into an array of color vectors in the engine. (0 - )
// byte ( length * 10 )



#define	MSG_BROADCAST		0		// unreliable to all
#define	MSG_ONE				1		// reliable to one (msg_entity)
#define	MSG_ALL				2		// reliable to all
#define	MSG_INIT			3		// write to the init string
#define MSG_PVS				4		// Ents in PVS of org
#define MSG_PAS				5		// Ents in PAS of org
#define MSG_PVS_R			6		// Reliable to PVS
#define MSG_PAS_R			7		// Reliable to PAS
#define MSG_ONE_UNRELIABLE	8		// Send to one client, but don't put in reliable stream, put in unreliable datagram ( could be dropped )
#define	MSG_SPEC			9		// Sends to all spectator proxies

// contents of a spot in the world
#define	CONTENTS_EMPTY		-1
#define	CONTENTS_SOLID		-2
#define	CONTENTS_WATER		-3
#define	CONTENTS_SLIME		-4
#define	CONTENTS_LAVA		-5
#define	CONTENTS_SKY		-6
/* These additional contents constants are defined in bspfile.h
#define	CONTENTS_ORIGIN		-7		// removed at csg time
#define	CONTENTS_CLIP		-8		// changed to contents_solid
#define	CONTENTS_CURRENT_0		-9
#define	CONTENTS_CURRENT_90		-10
#define	CONTENTS_CURRENT_180	-11
#define	CONTENTS_CURRENT_270	-12
#define	CONTENTS_CURRENT_UP		-13
#define	CONTENTS_CURRENT_DOWN	-14

#define CONTENTS_TRANSLUCENT	-15
*/
#define	CONTENTS_LADDER		-16

#define CONTENT_EMPTY	-1
#define CONTENT_SOLID	-2
#define	CONTENT_WATER	-3
#define CONTENT_SLIME	-4
#define CONTENT_LAVA	-5
#define CONTENT_SKY		-6

// channels
#define CHAN_AUTO			0
#define CHAN_WEAPON			1
#define	CHAN_VOICE			2
#define CHAN_ITEM			3
#define	CHAN_BODY			4
#define CHAN_STREAM			5			// allocate stream channel from the static or dynamic area
#define CHAN_STATIC			6			// allocate channel from the static area 
#define CHAN_NETWORKVOICE_BASE	7		// voice data coming across the network
#define CHAN_NETWORKVOICE_END	500		// network voice data reserves slots (CHAN_NETWORKVOICE_BASE through CHAN_NETWORKVOICE_END).

// attenuation values
#define ATTN_NONE		0
#define	ATTN_NORM		(float)0.8
#define ATTN_IDLE		(float)2
#define ATTN_STATIC		(float)1.25 

// pitch values
#define	PITCH_NORM		100			// non-pitch shifted
#define PITCH_LOW		95			// other values are possible - 0-255, where 255 is very high
#define PITCH_HIGH		120

// volume values
#define VOL_NORM		1.0

// plats
#define	PLAT_LOW_TRIGGER	1

// Trains
#define	SF_TRAIN_WAIT_RETRIGGER	1
#define SF_TRAIN_PASSABLE		8		// Train is not solid -- used to make water trains

// buttons
#ifndef IN_BUTTONS_H
#include "in_buttons.h"
#endif

// Break Model Defines

#define BREAK_TYPEMASK	0x4F
#define BREAK_GLASS		0x01
#define BREAK_METAL		0x02
#define BREAK_FLESH		0x04
#define BREAK_WOOD		0x08

#define BREAK_SMOKE		0x10
#define BREAK_TRANS		0x20
#define BREAK_CONCRETE	0x40
#define BREAK_2			0x80

// Colliding temp entity sounds

#define BOUNCE_GLASS	BREAK_GLASS
#define	BOUNCE_METAL	BREAK_METAL
#define BOUNCE_FLESH	BREAK_FLESH
#define BOUNCE_WOOD		BREAK_WOOD
#define BOUNCE_SHRAP	0x10
#define BOUNCE_SHELL	0x20
#define	BOUNCE_CONCRETE BREAK_CONCRETE
#define BOUNCE_SHOTSHELL 0x80

// Temp entity bounce sound types
#define TE_BOUNCE_NULL		0
#define TE_BOUNCE_SHELL		1
#define TE_BOUNCE_SHOTSHELL	2

// Rendering constants
enum 
{	
	kRenderNormal,			// src
	kRenderTransColor,		// c*a+dest*(1-a)
	kRenderTransTexture,	// src*a+dest*(1-a)
	kRenderGlow,			// src*a+dest -- No Z buffer checks
	kRenderTransAlpha,		// src*srca+dest*(1-srca)
	kRenderTransAdd,		// src*a+dest
};

enum 
{	
	kRenderFxNone = 0, 
	kRenderFxPulseSlow, 
	kRenderFxPulseFast, 
	kRenderFxPulseSlowWide, 
	kRenderFxPulseFastWide, 
	kRenderFxFadeSlow, 
	kRenderFxFadeFast, 
	kRenderFxSolidSlow, 
	kRenderFxSolidFast, 	   
	kRenderFxStrobeSlow, 
	kRenderFxStrobeFast, 
	kRenderFxStrobeFaster, 
	kRenderFxFlickerSlow, 
	kRenderFxFlickerFast,
	kRenderFxNoDissipation,
	kRenderFxDistort,			// Distort/scale/translate flicker
	kRenderFxHologram,			// kRenderFxDistort + distance fade
	kRenderFxDeadPlayer,		// kRenderAmt is the player index
	kRenderFxExplode,			// Scale up really big!
	kRenderFxGlowShell,			// Glowing Shell
	kRenderFxClampMinScale,		// Keep this sprite from getting very small (SPRITES only!)
};


typedef int	func_t;
typedef int	string_t;

typedef unsigned char 		byte;
typedef unsigned short 		word;
#define _DEF_BYTE_

#undef true
#undef false

#ifndef __cplusplus
typedef enum {false, true}	qboolean;
#else 
typedef int qboolean;
#endif

typedef struct
{
	byte r, g, b;
} color24;

typedef struct
{
	unsigned r, g, b, a;
} colorVec;

#ifdef _WIN32
#pragma pack(push,2)
#endif

typedef struct
{
	unsigned short r, g, b, a;
} PackedColorVec;

#ifdef _WIN32
#pragma pack(pop)
#endif
typedef struct link_s
{
	struct link_s	*prev, *next;
} link_t;

typedef struct edict_s edict_t;

typedef struct
{
	vec3_t	normal;
	float	dist;
} plane_t;

typedef struct
{
	qboolean	allsolid;	// if true, plane is not valid
	qboolean	startsolid;	// if true, the initial point was in a solid area
	qboolean	inopen, inwater;
	float	fraction;		// time completed, 1.0 = didn't hit anything
	vec3_t	endpos;			// final position
	plane_t	plane;			// surface normal at impact
	edict_t	*ent;			// entity the surface is on
	int		hitgroup;		// 0 == generic, non zero is specific body part
} trace_t;

#endif


```

`halflife/engine/CRC.H`:

```H
/***
*
*	Copyright (c) 1999, 2000, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
/* crc.h */
#ifndef CRC_H
#define CRC_H
#ifdef _WIN32
#pragma once
#endif

// MD5 Hash
typedef struct
{
	unsigned int buf[4];
    unsigned int bits[2];
    unsigned char in[64];
} MD5Context_t;


typedef unsigned long CRC32_t;
void CRC32_Init(CRC32_t *pulCRC);
CRC32_t CRC32_Final(CRC32_t pulCRC);
void CRC32_ProcessBuffer(CRC32_t *pulCRC, void *p, int len);
void CRC32_ProcessByte(CRC32_t *pulCRC, unsigned char ch);
int CRC_File(CRC32_t *crcvalue, char *pszFileName);
unsigned char COM_BlockSequenceCRCByte(unsigned char *base, int length, int sequence);

void MD5Init(MD5Context_t *context);
void MD5Update(MD5Context_t *context, unsigned char const *buf,
               unsigned int len);
void MD5Final(unsigned char digest[16], MD5Context_t *context);
void Transform(unsigned int buf[4], unsigned int const in[16]);

int MD5_Hash_File(unsigned char digest[16], char *pszFileName, int bUsefopen, int bSeed, unsigned int seed[4]);
char *MD5_Print(unsigned char hash[16]);
int MD5_Hash_CachedFile(unsigned char digest[16], unsigned char *pCache, int nFileSize, int bSeed, unsigned int seed[4]);

int CRC_MapFile(CRC32_t *crcvalue, char *pszFileName);

#endif

```

`halflife/engine/CUSTOM.H`:

```H
/***
*
*	Copyright (c) 1999, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
// Customization.h

#ifndef CUSTOM_H
#define CUSTOM_H
#ifdef _WIN32
#pragma once
#endif

#include "const.h"

#define MAX_QPATH 64    // Must match value in quakedefs.h

/////////////////
// Customization
// passed to pfnPlayerCustomization
// For automatic downloading.
typedef enum
{
	t_sound = 0,
	t_skin,
	t_model,
	t_decal,
	t_generic,
	t_eventscript
} resourcetype_t;

// Fake type for world
#define t_world 6

typedef struct
{
	int				size;
} _resourceinfo_t;

typedef struct resourceinfo_s
{
	_resourceinfo_t info[ 7 ];
} resourceinfo_t;

#define RES_FATALIFMISSING (1<<0)   // Disconnect if we can't get this file.
#define RES_WASMISSING     (1<<1)   // Do we have the file locally, did we get it ok?
#define RES_CUSTOM         (1<<2)   // Is this resource one that corresponds to another player's customization
								    //  or is it a server startup resource.
#define RES_REQUESTED	   (1<<3)	// Already requested a download of this one
#define RES_PRECACHED	   (1<<4)	// Already precached

#include "crc.h"

typedef struct resource_s
{
	char              szFileName[MAX_QPATH]; // File name to download/precache.
	resourcetype_t    type;                // t_sound, t_skin, t_model, t_decal.
	int               nIndex;              // For t_decals
	int               nDownloadSize;       // Size in Bytes if this must be downloaded.
	unsigned char     ucFlags;

// For handling client to client resource propagation
	unsigned char     rgucMD5_hash[16];    // To determine if we already have it.
	unsigned char     playernum;           // Which player index this resource is associated with, if it's a custom resource.

	unsigned char	  rguc_reserved[ 32 ]; // For future expansion
	struct resource_s *pNext;              // Next in chain.
	struct resource_s *pPrev;
} resource_t;

typedef struct customization_s
{
	qboolean bInUse;     // Is this customization in use;
	resource_t resource; // The resource_t for this customization
	qboolean bTranslated; // Has the raw data been translated into a useable format?  
						   //  (e.g., raw decal .wad make into texture_t *)
	int        nUserData1; // Customization specific data
	int        nUserData2; // Customization specific data
	void *pInfo;          // Buffer that holds the data structure that references the data (e.g., the cachewad_t)
	void *pBuffer;       // Buffer that holds the data for the customization (the raw .wad data)
	struct customization_s *pNext; // Next in chain
} customization_t;

#define FCUST_FROMHPAK		( 1<<0 )
#define FCUST_WIPEDATA		( 1<<1 )
#define FCUST_IGNOREINIT	( 1<<2 )

void		COM_ClearCustomizationList( struct customization_s *pHead, qboolean bCleanDecals);
qboolean	COM_CreateCustomization( struct customization_s *pListHead, struct resource_s *pResource, int playernumber, int flags, 
				struct customization_s **pCustomization, int *nLumps ); 
int			COM_SizeofResourceList ( struct resource_s *pList, struct resourceinfo_s *ri );

#endif // CUSTOM_H

```

`halflife/engine/CVARDEF.H`:

```H
/***
*
*	Copyright (c) 1999, 2000, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef CVARDEF_H
#define CVARDEF_H

#define	FCVAR_ARCHIVE		(1<<0)	// set to cause it to be saved to vars.rc
#define	FCVAR_USERINFO		(1<<1)	// changes the client's info string
#define	FCVAR_SERVER		(1<<2)	// notifies players when changed
#define FCVAR_EXTDLL		(1<<3)	// defined by external DLL
#define FCVAR_CLIENTDLL     (1<<4)  // defined by the client dll
#define FCVAR_PROTECTED     (1<<5)  // It's a server cvar, but we don't send the data since it's a password, etc.  Sends 1 if it's not bland/zero, 0 otherwise as value
#define FCVAR_SPONLY        (1<<6)  // This cvar cannot be changed by clients connected to a multiplayer server.
#define FCVAR_PRINTABLEONLY (1<<7)  // This cvar's string cannot contain unprintable characters ( e.g., used for player name etc ).
#define FCVAR_UNLOGGED		(1<<8)  // If this is a FCVAR_SERVER, don't log changes to the log file / console if we are creating a log

typedef struct cvar_s
{
	char	*name;
	char	*string;
	int		flags;
	float	value;
	struct cvar_s *next;
} cvar_t;
#endif
```

`halflife/engine/DLIGHT.H`:

```H
/***
*
*	Copyright (c) 1999, 2000, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined ( DLIGHTH )
#define DLIGHTH
#ifdef _WIN32
#pragma once
#endif

typedef struct
{
	vec3_t	origin;
	float	radius;
	color24	color;
	float	die;				// stop lighting after this time
	float	decay;				// drop this each second
	float	minlight;			// don't add when contributing less
	int		key;
	qboolean	dark;			// subtracts light instead of adding
} dlight_t;

#endif
```

`halflife/engine/EDICT.H`:

```H
#if !defined EDICT_H
#define EDICT_H
#ifdef _WIN32
#pragma once
#endif
#define	MAX_ENT_LEAFS	48

#include "progdefs.h"

struct edict_s
{
	qboolean	free;
	int			serialnumber;
	link_t		area;				// linked to a division node or leaf
	
	int			headnode;			// -1 to use normal leaf check
	int			num_leafs;
	short		leafnums[MAX_ENT_LEAFS];

	float		freetime;			// sv.time when the object was freed

	void*		pvPrivateData;		// Alloced and freed by engine, used by DLLs

	entvars_t	v;					// C exported fields from progs

	// other fields from progs come immediately after
};

#endif

```

`halflife/engine/EIFACE.H`:

```H
/***
*
*	Copyright (c) 1999, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef EIFACE_H
#define EIFACE_H

#ifdef HLDEMO_BUILD
#define INTERFACE_VERSION       001
#else  // !HLDEMO_BUILD, i.e., regular version of HL
#define INTERFACE_VERSION		140
#endif // !HLDEMO_BUILD

#include <stdio.h>
#include "custom.h"
#include "cvardef.h"
//
// Defines entity interface between engine and DLLs.
// This header file included by engine files and DLL files.
//
// Before including this header, DLLs must:
//		include progdefs.h
// This is conveniently done for them in extdll.h
//

#ifdef _WIN32
#define DLLEXPORT __stdcall
#else
#define DLLEXPORT /* */
#endif

typedef enum
	{
	at_notice,
	at_console,		// same as at_notice, but forces a ConPrintf, not a message box
	at_aiconsole,	// same as at_console, but only shown if developer level is 2!
	at_warning,
	at_error,
	at_logged		// Server print to console ( only in multiplayer games ).
	} ALERT_TYPE;

// 4-22-98  JOHN: added for use in pfnClientPrintf
typedef enum
	{
	print_console,
	print_center,
	print_chat,
	} PRINT_TYPE;

// For integrity checking of content on clients
typedef enum
{
	force_exactfile,			// File on client must exactly match server's file
	force_model_samebounds,		// For model files only, the geometry must fit in the same bbox
	force_model_specifybounds,	// For model files only, the geometry must fit in the specified bbox
} FORCE_TYPE;

// Returned by TraceLine
typedef struct
	{
	int		fAllSolid;			// if true, plane is not valid
	int		fStartSolid;		// if true, the initial point was in a solid area
	int		fInOpen;
	int		fInWater;
	float	flFraction;			// time completed, 1.0 = didn't hit anything
	vec3_t	vecEndPos;			// final position
	float	flPlaneDist;
	vec3_t	vecPlaneNormal;		// surface normal at impact
	edict_t	*pHit;				// entity the surface is on
	int		iHitgroup;			// 0 == generic, non zero is specific body part
	} TraceResult;

// CD audio status
typedef struct 
{
	int	fPlaying;// is sound playing right now?
	int	fWasPlaying;// if not, CD is paused if WasPlaying is true.
	int	fInitialized;
	int	fEnabled;
	int	fPlayLooping;
	float	cdvolume;
	//BYTE 	remap[100];
	int	fCDRom;
	int	fPlayTrack;
} CDStatus;

#include "../common/crc.h"

// Engine hands this to DLLs for functionality callbacks
typedef struct enginefuncs_s
{
	int			(*pfnPrecacheModel)			(char* s);
	int			(*pfnPrecacheSound)			(char* s);
	void		(*pfnSetModel)				(edict_t *e, const char *m);
	int			(*pfnModelIndex)			(const char *m);
	int			(*pfnModelFrames)			(int modelIndex);
	void		(*pfnSetSize)				(edict_t *e, const float *rgflMin, const float *rgflMax);
	void		(*pfnChangeLevel)			(char* s1, char* s2);
	void		(*pfnGetSpawnParms)			(edict_t *ent);
	void		(*pfnSaveSpawnParms)		(edict_t *ent);
	float		(*pfnVecToYaw)				(const float *rgflVector);
	void		(*pfnVecToAngles)			(const float *rgflVectorIn, float *rgflVectorOut);
	void		(*pfnMoveToOrigin)			(edict_t *ent, const float *pflGoal, float dist, int iMoveType);
	void		(*pfnChangeYaw)				(edict_t* ent);
	void		(*pfnChangePitch)			(edict_t* ent);
	edict_t*	(*pfnFindEntityByString)	(edict_t *pEdictStartSearchAfter, const char *pszField, const char *pszValue);
	int			(*pfnGetEntityIllum)		(edict_t* pEnt);
	edict_t*	(*pfnFindEntityInSphere)	(edict_t *pEdictStartSearchAfter, const float *org, float rad);
	edict_t*	(*pfnFindClientInPVS)		(edict_t *pEdict);
	edict_t* (*pfnEntitiesInPVS)			(edict_t *pplayer);
	void		(*pfnMakeVectors)			(const float *rgflVector);
	void		(*pfnAngleVectors)			(const float *rgflVector, float *forward, float *right, float *up);
	edict_t*	(*pfnCreateEntity)			(void);
	void		(*pfnRemoveEntity)			(edict_t* e);
	edict_t*	(*pfnCreateNamedEntity)		(int className);
	void		(*pfnMakeStatic)			(edict_t *ent);
	int			(*pfnEntIsOnFloor)			(edict_t *e);
	int			(*pfnDropToFloor)			(edict_t* e);
	int			(*pfnWalkMove)				(edict_t *ent, float yaw, float dist, int iMode);
	void		(*pfnSetOrigin)				(edict_t *e, const float *rgflOrigin);
	void		(*pfnEmitSound)				(edict_t *entity, int channel, const char *sample, /*int*/float volume, float attenuation, int fFlags, int pitch);
	void		(*pfnEmitAmbientSound)		(edict_t *entity, float *pos, const char *samp, float vol, float attenuation, int fFlags, int pitch);
	void		(*pfnTraceLine)				(const float *v1, const float *v2, int fNoMonsters, edict_t *pentToSkip, TraceResult *ptr);
	void		(*pfnTraceToss)				(edict_t* pent, edict_t* pentToIgnore, TraceResult *ptr);
	int			(*pfnTraceMonsterHull)		(edict_t *pEdict, const float *v1, const float *v2, int fNoMonsters, edict_t *pentToSkip, TraceResult *ptr);
	void		(*pfnTraceHull)				(const float *v1, const float *v2, int fNoMonsters, int hullNumber, edict_t *pentToSkip, TraceResult *ptr);
	void		(*pfnTraceModel)			(const float *v1, const float *v2, int hullNumber, edict_t *pent, TraceResult *ptr);
	const char *(*pfnTraceTexture)			(edict_t *pTextureEntity, const float *v1, const float *v2 );
	void		(*pfnTraceSphere)			(const float *v1, const float *v2, int fNoMonsters, float radius, edict_t *pentToSkip, TraceResult *ptr);
	void		(*pfnGetAimVector)			(edict_t* ent, float speed, float *rgflReturn);
	void		(*pfnServerCommand)			(char* str);
	void		(*pfnServerExecute)			(void);
	void		(*pfnClientCommand)			(edict_t* pEdict, char* szFmt, ...);
	void		(*pfnParticleEffect)		(const float *org, const float *dir, float color, float count);
	void		(*pfnLightStyle)			(int style, char* val);
	int			(*pfnDecalIndex)			(const char *name);
	int			(*pfnPointContents)			(const float *rgflVector);
	void		(*pfnMessageBegin)			(int msg_dest, int msg_type, const float *pOrigin, edict_t *ed);
	void		(*pfnMessageEnd)			(void);
	void		(*pfnWriteByte)				(int iValue);
	void		(*pfnWriteChar)				(int iValue);
	void		(*pfnWriteShort)			(int iValue);
	void		(*pfnWriteLong)				(int iValue);
	void		(*pfnWriteAngle)			(float flValue);
	void		(*pfnWriteCoord)			(float flValue);
	void		(*pfnWriteString)			(const char *sz);
	void		(*pfnWriteEntity)			(int iValue);
	void		(*pfnCVarRegister)			(cvar_t *pCvar);
	float		(*pfnCVarGetFloat)			(const char *szVarName);
	const char*	(*pfnCVarGetString)			(const char *szVarName);
	void		(*pfnCVarSetFloat)			(const char *szVarName, float flValue);
	void		(*pfnCVarSetString)			(const char *szVarName, const char *szValue);
	void		(*pfnAlertMessage)			(ALERT_TYPE atype, char *szFmt, ...);
	void		(*pfnEngineFprintf)			(FILE *pfile, char *szFmt, ...);
	void*		(*pfnPvAllocEntPrivateData)	(edict_t *pEdict, long cb);
	void*		(*pfnPvEntPrivateData)		(edict_t *pEdict);
	void		(*pfnFreeEntPrivateData)	(edict_t *pEdict);
	const char*	(*pfnSzFromIndex)			(int iString);
	int			(*pfnAllocString)			(const char *szValue);
	struct entvars_s*	(*pfnGetVarsOfEnt)			(edict_t *pEdict);
	edict_t*	(*pfnPEntityOfEntOffset)	(int iEntOffset);
	int			(*pfnEntOffsetOfPEntity)	(const edict_t *pEdict);
	int			(*pfnIndexOfEdict)			(const edict_t *pEdict);
	edict_t*	(*pfnPEntityOfEntIndex)		(int iEntIndex);
	edict_t*	(*pfnFindEntityByVars)		(struct entvars_s* pvars);
	void*		(*pfnGetModelPtr)			(edict_t* pEdict);
	int			(*pfnRegUserMsg)			(const char *pszName, int iSize);
	void		(*pfnAnimationAutomove)		(const edict_t* pEdict, float flTime);
	void		(*pfnGetBonePosition)		(const edict_t* pEdict, int iBone, float *rgflOrigin, float *rgflAngles );
	unsigned long (*pfnFunctionFromName)	( const char *pName );
	const char *(*pfnNameForFunction)		( unsigned long function );
	void		(*pfnClientPrintf)			( edict_t* pEdict, PRINT_TYPE ptype, const char *szMsg ); // JOHN: engine callbacks so game DLL can print messages to individual clients
	void		(*pfnServerPrint)			( const char *szMsg );
	const char *(*pfnCmd_Args)				( void );		// these 3 added 
	const char *(*pfnCmd_Argv)				( int argc );	// so game DLL can easily 
	int			(*pfnCmd_Argc)				( void );		// access client 'cmd' strings
	void		(*pfnGetAttachment)			(const edict_t *pEdict, int iAttachment, float *rgflOrigin, float *rgflAngles );
	void		(*pfnCRC32_Init)			(CRC32_t *pulCRC);
	void        (*pfnCRC32_ProcessBuffer)   (CRC32_t *pulCRC, void *p, int len);
	void		(*pfnCRC32_ProcessByte)     (CRC32_t *pulCRC, unsigned char ch);
	CRC32_t		(*pfnCRC32_Final)			(CRC32_t pulCRC);
	long		(*pfnRandomLong)			(long  lLow,  long  lHigh);
	float		(*pfnRandomFloat)			(float flLow, float flHigh);
	void		(*pfnSetView)				(const edict_t *pClient, const edict_t *pViewent );
	float		(*pfnTime)					( void );
	void		(*pfnCrosshairAngle)		(const edict_t *pClient, float pitch, float yaw);
	byte *      (*pfnLoadFileForMe)         (char *filename, int *pLength);
	void        (*pfnFreeFile)              (void *buffer);
	void        (*pfnEndSection)            (const char *pszSectionName); // trigger_endsection
	int 		(*pfnCompareFileTime)       (char *filename1, char *filename2, int *iCompare);
	void        (*pfnGetGameDir)            (char *szGetGameDir);
	void		(*pfnCvar_RegisterVariable) (cvar_t *variable);
	void        (*pfnFadeClientVolume)      (const edict_t *pEdict, int fadePercent, int fadeOutSeconds, int holdTime, int fadeInSeconds);
	void        (*pfnSetClientMaxspeed)     (const edict_t *pEdict, float fNewMaxspeed);
	edict_t *	(*pfnCreateFakeClient)		(const char *netname);	// returns NULL if fake client can't be created
	void		(*pfnRunPlayerMove)			(edict_t *fakeclient, const float *viewangles, float forwardmove, float sidemove, float upmove, unsigned short buttons, byte impulse, byte msec );
	int			(*pfnNumberOfEntities)		(void);
	char*		(*pfnGetInfoKeyBuffer)		(edict_t *e);	// passing in NULL gets the serverinfo
	char*		(*pfnInfoKeyValue)			(char *infobuffer, char *key);
	void		(*pfnSetKeyValue)			(char *infobuffer, char *key, char *value);
	void		(*pfnSetClientKeyValue)		(int clientIndex, char *infobuffer, char *key, char *value);
	int			(*pfnIsMapValid)			(char *filename);
	void		(*pfnStaticDecal)			( const float *origin, int decalIndex, int entityIndex, int modelIndex );
	int			(*pfnPrecacheGeneric)		(char* s);
	int			(*pfnGetPlayerUserId)		(edict_t *e ); // returns the server assigned userid for this player.  useful for logging frags, etc.  returns -1 if the edict couldn't be found in the list of clients
	void		(*pfnBuildSoundMsg)			(edict_t *entity, int channel, const char *sample, /*int*/float volume, float attenuation, int fFlags, int pitch, int msg_dest, int msg_type, const float *pOrigin, edict_t *ed);
	int			(*pfnIsDedicatedServer)		(void);// is this a dedicated server?
	cvar_t		*(*pfnCVarGetPointer)		(const char *szVarName);
	unsigned int (*pfnGetPlayerWONId)		(edict_t *e); // returns the server assigned WONid for this player.  useful for logging frags, etc.  returns -1 if the edict couldn't be found in the list of clients

	// YWB 8/1/99 TFF Physics additions
	void		(*pfnInfo_RemoveKey)		( char *s, const char *key );
	const char *(*pfnGetPhysicsKeyValue)	( const edict_t *pClient, const char *key );
	void		(*pfnSetPhysicsKeyValue)	( const edict_t *pClient, const char *key, const char *value );
	const char *(*pfnGetPhysicsInfoString)	( const edict_t *pClient );
	unsigned short (*pfnPrecacheEvent)		( int type, const char*psz );
	void		(*pfnPlaybackEvent)			( int flags, const edict_t *pInvoker, unsigned short eventindex, float delay, float *origin, float *angles, float fparam1, float fparam2, int iparam1, int iparam2, int bparam1, int bparam2 );

	unsigned char *(*pfnSetFatPVS)			( float *org );
	unsigned char *(*pfnSetFatPAS)			( float *org );

	int			(*pfnCheckVisibility )		( const edict_t *entity, unsigned char *pset );

	void		(*pfnDeltaSetField)			( struct delta_s *pFields, const char *fieldname );
	void		(*pfnDeltaUnsetField)		( struct delta_s *pFields, const char *fieldname );
	void		(*pfnDeltaAddEncoder)		( char *name, void (*conditionalencode)( struct delta_s *pFields, const unsigned char *from, const unsigned char *to ) );
	int			(*pfnGetCurrentPlayer)		( void );
	int			(*pfnCanSkipPlayer)			( const edict_t *player );
	int			(*pfnDeltaFindField)		( struct delta_s *pFields, const char *fieldname );
	void		(*pfnDeltaSetFieldByIndex)	( struct delta_s *pFields, int fieldNumber );
	void		(*pfnDeltaUnsetFieldByIndex)( struct delta_s *pFields, int fieldNumber );

	void		(*pfnSetGroupMask)			( int mask, int op );

	int			(*pfnCreateInstancedBaseline) ( int classname, struct entity_state_s *baseline );
	void		(*pfnCvar_DirectSet)		( struct cvar_s *var, char *value );

	// Forces the client and server to be running with the same version of the specified file
	//  ( e.g., a player model ).
	// Calling this has no effect in single player
	void		(*pfnForceUnmodified)		( FORCE_TYPE type, float *mins, float *maxs, const char *filename );

	void		(*pfnGetPlayerStats)		( const edict_t *pClient, int *ping, int *packet_loss );

	void		(*pfnAddServerCommand)		( char *cmd_name, void (*function) (void) );

	// For voice communications, set which clients hear eachother.
	// NOTE: these functions take player entity indices (starting at 1).
	qboolean	(*pfnVoice_GetClientListening)(int iReceiver, int iSender);
	qboolean	(*pfnVoice_SetClientListening)(int iReceiver, int iSender, qboolean bListen);
} enginefuncs_t;
// ONLY ADD NEW FUNCTIONS TO THE END OF THIS STRUCT.  INTERFACE VERSION IS FROZEN AT 138

// Passed to pfnKeyValue
typedef struct KeyValueData_s
{
	char	*szClassName;	// in: entity classname
	char	*szKeyName;		// in: name of key
	char	*szValue;		// in: value of key
	long	fHandled;		// out: DLL sets to true if key-value pair was understood
} KeyValueData;


typedef struct
{
	char		mapName[ 32 ];
	char		landmarkName[ 32 ];
	edict_t	*pentLandmark;
	vec3_t		vecLandmarkOrigin;
} LEVELLIST;
#define MAX_LEVEL_CONNECTIONS	16		// These are encoded in the lower 16bits of ENTITYTABLE->flags

typedef struct 
{
	int			id;				// Ordinal ID of this entity (used for entity <--> pointer conversions)
	edict_t	*pent;			// Pointer to the in-game entity

	int			location;		// Offset from the base data of this entity
	int			size;			// Byte size of this entity's data
	int			flags;			// This could be a short -- bit mask of transitions that this entity is in the PVS of
	string_t	classname;		// entity class name

} ENTITYTABLE;

#define FENTTABLE_PLAYER		0x80000000
#define FENTTABLE_REMOVED		0x40000000
#define FENTTABLE_MOVEABLE		0x20000000
#define FENTTABLE_GLOBAL		0x10000000

typedef struct saverestore_s SAVERESTOREDATA;

#ifdef _WIN32
typedef 
#endif
struct saverestore_s
{
	char		*pBaseData;		// Start of all entity save data
	char		*pCurrentData;	// Current buffer pointer for sequential access
	int			size;			// Current data size
	int			bufferSize;		// Total space for data
	int			tokenSize;		// Size of the linear list of tokens
	int			tokenCount;		// Number of elements in the pTokens table
	char		**pTokens;		// Hash table of entity strings (sparse)
	int			currentIndex;	// Holds a global entity table ID
	int			tableCount;		// Number of elements in the entity table
	int			connectionCount;// Number of elements in the levelList[]
	ENTITYTABLE	*pTable;		// Array of ENTITYTABLE elements (1 for each entity)
	LEVELLIST	levelList[ MAX_LEVEL_CONNECTIONS ];		// List of connections from this level

	// smooth transition
	int			fUseLandmark;
	char		szLandmarkName[20];// landmark we'll spawn near in next level
	vec3_t		vecLandmarkOffset;// for landmark transitions
	float		time;
	char		szCurrentMapName[32];	// To check global entities

} 
#ifdef _WIN32
SAVERESTOREDATA 
#endif
;

typedef enum _fieldtypes
{
	FIELD_FLOAT = 0,		// Any floating point value
	FIELD_STRING,			// A string ID (return from ALLOC_STRING)
	FIELD_ENTITY,			// An entity offset (EOFFSET)
	FIELD_CLASSPTR,			// CBaseEntity *
	FIELD_EHANDLE,			// Entity handle
	FIELD_EVARS,			// EVARS *
	FIELD_EDICT,			// edict_t *, or edict_t *  (same thing)
	FIELD_VECTOR,			// Any vector
	FIELD_POSITION_VECTOR,	// A world coordinate (these are fixed up across level transitions automagically)
	FIELD_POINTER,			// Arbitrary data pointer... to be removed, use an array of FIELD_CHARACTER
	FIELD_INTEGER,			// Any integer or enum
	FIELD_FUNCTION,			// A class function pointer (Think, Use, etc)
	FIELD_BOOLEAN,			// boolean, implemented as an int, I may use this as a hint for compression
	FIELD_SHORT,			// 2 byte integer
	FIELD_CHARACTER,		// a byte
	FIELD_TIME,				// a floating point time (these are fixed up automatically too!)
	FIELD_MODELNAME,		// Engine string that is a model name (needs precache)
	FIELD_SOUNDNAME,		// Engine string that is a sound name (needs precache)

	FIELD_TYPECOUNT,		// MUST BE LAST
} FIELDTYPE;

#ifndef offsetof
#define offsetof(s,m)	(size_t)&(((s *)0)->m)
#endif

#define _FIELD(type,name,fieldtype,count,flags)		{ fieldtype, #name, offsetof(type, name), count, flags }
#define DEFINE_FIELD(type,name,fieldtype)			_FIELD(type, name, fieldtype, 1, 0)
#define DEFINE_ARRAY(type,name,fieldtype,count)		_FIELD(type, name, fieldtype, count, 0)
#define DEFINE_ENTITY_FIELD(name,fieldtype)			_FIELD(entvars_t, name, fieldtype, 1, 0 )
#define DEFINE_ENTITY_GLOBAL_FIELD(name,fieldtype)	_FIELD(entvars_t, name, fieldtype, 1, FTYPEDESC_GLOBAL )
#define DEFINE_GLOBAL_FIELD(type,name,fieldtype)	_FIELD(type, name, fieldtype, 1, FTYPEDESC_GLOBAL )


#define FTYPEDESC_GLOBAL			0x0001		// This field is masked for global entity save/restore

typedef struct 
{
	FIELDTYPE		fieldType;
	char			*fieldName;
	int				fieldOffset;
	short			fieldSize;
	short			flags;
} TYPEDESCRIPTION;

#define ARRAYSIZE(p)		(sizeof(p)/sizeof(p[0]))

typedef struct 
{
	// Initialize/shutdown the game (one-time call after loading of game .dll )
	void			(*pfnGameInit)			( void );				
	int				(*pfnSpawn)				( edict_t *pent );
	void			(*pfnThink)				( edict_t *pent );
	void			(*pfnUse)				( edict_t *pentUsed, edict_t *pentOther );
	void			(*pfnTouch)				( edict_t *pentTouched, edict_t *pentOther );
	void			(*pfnBlocked)			( edict_t *pentBlocked, edict_t *pentOther );
	void			(*pfnKeyValue)			( edict_t *pentKeyvalue, KeyValueData *pkvd );
	void			(*pfnSave)				( edict_t *pent, SAVERESTOREDATA *pSaveData );
	int 			(*pfnRestore)			( edict_t *pent, SAVERESTOREDATA *pSaveData, int globalEntity );
	void			(*pfnSetAbsBox)			( edict_t *pent );

	void			(*pfnSaveWriteFields)	( SAVERESTOREDATA *, const char *, void *, TYPEDESCRIPTION *, int );
	void			(*pfnSaveReadFields)	( SAVERESTOREDATA *, const char *, void *, TYPEDESCRIPTION *, int );

	void			(*pfnSaveGlobalState)		( SAVERESTOREDATA * );
	void			(*pfnRestoreGlobalState)	( SAVERESTOREDATA * );
	void			(*pfnResetGlobalState)		( void );

	qboolean		(*pfnClientConnect)		( edict_t *pEntity, const char *pszName, const char *pszAddress, char szRejectReason[ 128 ] );
	
	void			(*pfnClientDisconnect)	( edict_t *pEntity );
	void			(*pfnClientKill)		( edict_t *pEntity );
	void			(*pfnClientPutInServer)	( edict_t *pEntity );
	void			(*pfnClientCommand)		( edict_t *pEntity );
	void			(*pfnClientUserInfoChanged)( edict_t *pEntity, char *infobuffer );

	void			(*pfnServerActivate)	( edict_t *pEdictList, int edictCount, int clientMax );
	void			(*pfnServerDeactivate)	( void );

	void			(*pfnPlayerPreThink)	( edict_t *pEntity );
	void			(*pfnPlayerPostThink)	( edict_t *pEntity );

	void			(*pfnStartFrame)		( void );
	void			(*pfnParmsNewLevel)		( void );
	void			(*pfnParmsChangeLevel)	( void );

	 // Returns string describing current .dll.  E.g., TeamFotrress 2, Half-Life
	const char     *(*pfnGetGameDescription)( void );     

	// Notify dll about a player customization.
	void            (*pfnPlayerCustomization) ( edict_t *pEntity, customization_t *pCustom );  

	// Spectator funcs
	void			(*pfnSpectatorConnect)		( edict_t *pEntity );
	void			(*pfnSpectatorDisconnect)	( edict_t *pEntity );
	void			(*pfnSpectatorThink)		( edict_t *pEntity );

	// Notify game .dll that engine is going to shut down.  Allows mod authors to set a breakpoint.
	void			(*pfnSys_Error)			( const char *error_string );

	void			(*pfnPM_Move) ( struct playermove_s *ppmove, qboolean server );
	void			(*pfnPM_Init) ( struct playermove_s *ppmove );
	char			(*pfnPM_FindTextureType)( char *name );
	void			(*pfnSetupVisibility)( struct edict_s *pViewEntity, struct edict_s *pClient, unsigned char **pvs, unsigned char **pas );
	void			(*pfnUpdateClientData) ( const struct edict_s *ent, int sendweapons, struct clientdata_s *cd );
	int				(*pfnAddToFullPack)( struct entity_state_s *state, int e, edict_t *ent, edict_t *host, int hostflags, int player, unsigned char *pSet );
	void			(*pfnCreateBaseline) ( int player, int eindex, struct entity_state_s *baseline, struct edict_s *entity, int playermodelindex, vec3_t player_mins, vec3_t player_maxs );
	void			(*pfnRegisterEncoders)	( void );
	int				(*pfnGetWeaponData)		( struct edict_s *player, struct weapon_data_s *info );

	void			(*pfnCmdStart)			( const edict_t *player, const struct usercmd_s *cmd, unsigned int random_seed );
	void			(*pfnCmdEnd)			( const edict_t *player );

	// Return 1 if the packet is valid.  Set response_buffer_size if you want to send a response packet.  Incoming, it holds the max
	//  size of the response_buffer, so you must zero it out if you choose not to respond.
	int				(*pfnConnectionlessPacket )	( const struct netadr_s *net_from, const char *args, char *response_buffer, int *response_buffer_size );

	// Enumerates player hulls.  Returns 0 if the hull number doesn't exist, 1 otherwise
	int				(*pfnGetHullBounds)	( int hullnumber, float *mins, float *maxs );

	// Create baselines for certain "unplaced" items.
	void			(*pfnCreateInstancedBaselines) ( void );

	// One of the pfnForceUnmodified files failed the consistency check for the specified player
	// Return 0 to allow the client to continue, 1 to force immediate disconnection ( with an optional disconnect message of up to 256 characters )
	int				(*pfnInconsistentFile)( const struct edict_s *player, const char *filename, char *disconnect_message );

	// The game .dll should return 1 if lag compensation should be allowed ( could also just set
	//  the sv_unlag cvar.
	// Most games right now should return 0, until client-side weapon prediction code is written
	//  and tested for them.
	int				(*pfnAllowLagCompensation)( void );
} DLL_FUNCTIONS;

extern DLL_FUNCTIONS		gEntityInterface;

// Current version.
#define NEW_DLL_FUNCTIONS_VERSION	1

typedef struct
{
	// Called right before the object's memory is freed. 
	// Calls its destructor.
	void			(*pfnOnFreeEntPrivateData)(edict_t *pEnt);
	void			(*pfnGameShutdown)(void);
	int				(*pfnShouldCollide)( edict_t *pentTouched, edict_t *pentOther );
} NEW_DLL_FUNCTIONS;
typedef int	(*NEW_DLL_FUNCTIONS_FN)( NEW_DLL_FUNCTIONS *pFunctionTable, int *interfaceVersion );

// Pointers will be null if the game DLL doesn't support this API.
extern NEW_DLL_FUNCTIONS	gNewDLLFunctions;

typedef int	(*APIFUNCTION)( DLL_FUNCTIONS *pFunctionTable, int interfaceVersion );
typedef int	(*APIFUNCTION2)( DLL_FUNCTIONS *pFunctionTable, int *interfaceVersion );

#endif EIFACE_H

```

`halflife/engine/KEYDEFS.H`:

```H
// keydefs.h
#ifndef KEYDEFS_H
#define KEYDEFS_H
#ifdef _WIN32
#pragma once
#endif

//
// these are the key numbers that should be passed to Key_Event
//
#define	K_TAB			9
#define	K_ENTER			13
#define	K_ESCAPE		27
#define	K_SPACE			32

// normal keys should be passed as lowercased ascii

#define	K_BACKSPACE		127
#define	K_UPARROW		128
#define	K_DOWNARROW		129
#define	K_LEFTARROW		130
#define	K_RIGHTARROW	131

#define	K_ALT			132
#define	K_CTRL			133
#define	K_SHIFT			134
#define	K_F1			135
#define	K_F2			136
#define	K_F3			137
#define	K_F4			138
#define	K_F5			139
#define	K_F6			140
#define	K_F7			141
#define	K_F8			142
#define	K_F9			143
#define	K_F10			144
#define	K_F11			145
#define	K_F12			146
#define	K_INS			147
#define	K_DEL			148
#define	K_PGDN			149
#define	K_PGUP			150
#define	K_HOME			151
#define	K_END			152

#define K_KP_HOME		160
#define K_KP_UPARROW	161
#define K_KP_PGUP		162
#define	K_KP_LEFTARROW	163
#define K_KP_5			164
#define K_KP_RIGHTARROW	165
#define K_KP_END		166
#define K_KP_DOWNARROW	167
#define K_KP_PGDN		168
#define	K_KP_ENTER		169
#define K_KP_INS   		170
#define	K_KP_DEL		171
#define K_KP_SLASH		172
#define K_KP_MINUS		173
#define K_KP_PLUS		174
#define K_CAPSLOCK		175


//
// joystick buttons
//
#define	K_JOY1			203
#define	K_JOY2			204
#define	K_JOY3			205
#define	K_JOY4			206

//
// aux keys are for multi-buttoned joysticks to generate so they can use
// the normal binding process
//
#define	K_AUX1			207
#define	K_AUX2			208
#define	K_AUX3			209
#define	K_AUX4			210
#define	K_AUX5			211
#define	K_AUX6			212
#define	K_AUX7			213
#define	K_AUX8			214
#define	K_AUX9			215
#define	K_AUX10			216
#define	K_AUX11			217
#define	K_AUX12			218
#define	K_AUX13			219
#define	K_AUX14			220
#define	K_AUX15			221
#define	K_AUX16			222
#define	K_AUX17			223
#define	K_AUX18			224
#define	K_AUX19			225
#define	K_AUX20			226
#define	K_AUX21			227
#define	K_AUX22			228
#define	K_AUX23			229
#define	K_AUX24			230
#define	K_AUX25			231
#define	K_AUX26			232
#define	K_AUX27			233
#define	K_AUX28			234
#define	K_AUX29			235
#define	K_AUX30			236
#define	K_AUX31			237
#define	K_AUX32			238
#define K_MWHEELDOWN	239
#define K_MWHEELUP		240

#define K_PAUSE			255

//
// mouse buttons generate virtual keys
//
#define	K_MOUSE1		241
#define	K_MOUSE2		242
#define	K_MOUSE3		243
#define K_MOUSE4		244
#define K_MOUSE5		245

#endif // KEYDEFS_H

```

`halflife/engine/PMTRACE.H`:

```H
/***
*
*	Copyright (c) 1999, 2000 Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined( PMTRACEH )
#define PMTRACEH
#ifdef _WIN32
#pragma once
#endif

typedef struct
{
	vec3_t	normal;
	float	dist;
} pmplane_t;

typedef struct pmtrace_s pmtrace_t;

struct pmtrace_s
{
	qboolean	allsolid;	      // if true, plane is not valid
	qboolean	startsolid;	      // if true, the initial point was in a solid area
	qboolean	inopen, inwater;  // End point is in empty space or in water
	float		fraction;		  // time completed, 1.0 = didn't hit anything
	vec3_t		endpos;			  // final position
	pmplane_t	plane;		      // surface normal at impact
	int			ent;			  // entity at impact
	vec3_t      deltavelocity;    // Change in player's velocity caused by impact.  
								  // Only run on server.
	int         hitgroup;
};

#endif
```

`halflife/engine/PM_DEFS.H`:

```H
/***
*
*	Copyright (c) 1999, 2000, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
// pm_defs.h
#if !defined( PM_DEFSH )
#define PM_DEFSH
#pragma once

#define	MAX_PHYSENTS 600 		  // Must have room for all entities in the world.
#define MAX_MOVEENTS 64
#define	MAX_CLIP_PLANES	5

#define PM_NORMAL			0x00000000
#define PM_STUDIO_IGNORE	0x00000001		// Skip studio models
#define PM_STUDIO_BOX		0x00000002		// Use boxes for non-complex studio models (even in traceline)
#define PM_GLASS_IGNORE		0x00000004		// Ignore entities with non-normal rendermode
#define PM_WORLD_ONLY		0x00000008		// Only trace against the world

// Values for flags parameter of PM_TraceLine
#define PM_TRACELINE_ANYVISIBLE		0
#define PM_TRACELINE_PHYSENTSONLY	1

#include "pm_info.h"

// PM_PlayerTrace results.
//#include "engine/pmtrace.h"

#if !defined ( USERCMD_H )
#include "usercmd.h"
#endif

// physent_t
typedef struct physent_s
{
	char			name[32];             // Name of model, or "player" or "world".
	int				player;
	vec3_t			origin;               // Model's origin in world coordinates.
	struct model_s	*model;		          // only for bsp models
	struct model_s	*studiomodel;         // SOLID_BBOX, but studio clip intersections.
	vec3_t			mins, maxs;	          // only for non-bsp models
	int				info;		          // For client or server to use to identify (index into edicts or cl_entities)
	vec3_t			angles;               // rotated entities need this info for hull testing to work.

	int				solid;				  // Triggers and func_door type WATER brushes are SOLID_NOT
	int				skin;                 // BSP Contents for such things like fun_door water brushes.
	int				rendermode;			  // So we can ignore glass
	
	// Complex collision detection.
	float			frame;
	int				sequence;
	byte			controller[4];
	byte			blending[2];

	int				movetype;
	int				takedamage;
	int				blooddecal;
	int				team;
	int				classnumber;

	// For mods
	int				iuser1;
	int				iuser2;
	int				iuser3;
	int				iuser4;
	float			fuser1;
	float			fuser2;
	float			fuser3;
	float			fuser4;
	vec3_t			vuser1;
	vec3_t			vuser2;
	vec3_t			vuser3;
	vec3_t			vuser4;
} physent_t;

typedef struct playermove_s playermove_t;

struct playermove_s
{
	int				player_index;  // So we don't try to run the PM_CheckStuck nudging too quickly.
	qboolean		server;        // For debugging, are we running physics code on server side?

	qboolean		multiplayer;   // 1 == multiplayer server
	float			time;          // realtime on host, for reckoning duck timing
	float			frametime;	   // Duration of this frame

	vec3_t			forward, right, up; // Vectors for angles
	// player state
	vec3_t			origin;        // Movement origin.
	vec3_t			angles;        // Movement view angles.
	vec3_t			oldangles;     // Angles before movement view angles were looked at.
	vec3_t			velocity;      // Current movement direction.
	vec3_t			movedir;       // For waterjumping, a forced forward velocity so we can fly over lip of ledge.
	vec3_t			basevelocity;  // Velocity of the conveyor we are standing, e.g.
	
	// For ducking/dead
	vec3_t			view_ofs;      // Our eye position.
	float			flDuckTime;    // Time we started duck
	qboolean		bInDuck;       // In process of ducking or ducked already?
	
	// For walking/falling
	int				flTimeStepSound;  // Next time we can play a step sound
	int				iStepLeft;

	float			flFallVelocity;
	vec3_t			punchangle;

	float			flSwimTime;

	float			flNextPrimaryAttack;

	int				effects;		// MUZZLE FLASH, e.g.

	int				flags;         // FL_ONGROUND, FL_DUCKING, etc.
	int				usehull;       // 0 = regular player hull, 1 = ducked player hull, 2 = point hull
	float			gravity;       // Our current gravity and friction.
	float			friction;
	int				oldbuttons;    // Buttons last usercmd
	float			waterjumptime; // Amount of time left in jumping out of water cycle.
	qboolean		dead;          // Are we a dead player?
	int				deadflag;
	int				spectator;     // Should we use spectator physics model?
	int				movetype;      // Our movement type, NOCLIP, WALK, FLY

	int				onground;
	int				waterlevel;
	int				watertype;
	int				oldwaterlevel;

	char			sztexturename[256];
	char			chtexturetype;

	float			maxspeed;
	float			clientmaxspeed; // Player specific maxspeed

	// For mods
	int				iuser1;
	int				iuser2;
	int				iuser3;
	int				iuser4;
	float			fuser1;
	float			fuser2;
	float			fuser3;
	float			fuser4;
	vec3_t			vuser1;
	vec3_t			vuser2;
	vec3_t			vuser3;
	vec3_t			vuser4;
	// world state
	// Number of entities to clip against.
	int				numphysent;    
	physent_t		physents[MAX_PHYSENTS];
	// Number of momvement entities (ladders)
	int				nummoveent;
	// just a list of ladders
	physent_t		moveents[MAX_MOVEENTS];	

	// All things being rendered, for tracing against things you don't actually collide with
	int				numvisent;
	physent_t		visents[ MAX_PHYSENTS ];

	// input to run through physics.
	usercmd_t		cmd;

	// Trace results for objects we collided with.
	int				numtouch;
	pmtrace_t		touchindex[MAX_PHYSENTS];

	char			physinfo[ MAX_PHYSINFO_STRING ]; // Physics info string

	struct movevars_s *movevars;
	vec3_t player_mins[ 4 ];
	vec3_t player_maxs[ 4 ];
	
	// Common functions
	const char		*(*PM_Info_ValueForKey) ( const char *s, const char *key );
	void			(*PM_Particle)( vec3_t origin, int color, float life, int zpos, int zvel);
	int				(*PM_TestPlayerPosition) (vec3_t pos, pmtrace_t *ptrace );
	void			(*Con_NPrintf)( int idx, char *fmt, ... );
	void			(*Con_DPrintf)( char *fmt, ... );
	void			(*Con_Printf)( char *fmt, ... );
	double			(*Sys_FloatTime)( void );
	void			(*PM_StuckTouch)( int hitent, pmtrace_t *ptraceresult );
	int				(*PM_PointContents) (vec3_t p, int *truecontents /*filled in if this is non-null*/ );
	int				(*PM_TruePointContents) (vec3_t p);
	int				(*PM_HullPointContents) ( struct hull_s *hull, int num, vec3_t p);   
	pmtrace_t		(*PM_PlayerTrace) (vec3_t start, vec3_t end, int traceFlags, int ignore_pe );
	struct pmtrace_s *(*PM_TraceLine)( float *start, float *end, int flags, int usehull, int ignore_pe );
	long			(*RandomLong)( long lLow, long lHigh );
	float			(*RandomFloat)( float flLow, float flHigh );
	int				(*PM_GetModelType)( struct model_s *mod );
	void			(*PM_GetModelBounds)( struct model_s *mod, vec3_t mins, vec3_t maxs );
	void			*(*PM_HullForBsp)( physent_t *pe, vec3_t offset );
	float			(*PM_TraceModel)( physent_t *pEnt, vec3_t start, vec3_t end, trace_t *trace );
	int				(*COM_FileSize)(char *filename);
	byte			*(*COM_LoadFile) (char *path, int usehunk, int *pLength);
	void			(*COM_FreeFile) ( void *buffer );
	char			*(*memfgets)( byte *pMemFile, int fileSize, int *pFilePos, char *pBuffer, int bufferSize );

	// Functions
	// Run functions for this frame?
	qboolean		runfuncs;      
	void			(*PM_PlaySound) ( int channel, const char *sample, float volume, float attenuation, int fFlags, int pitch );
	const char		*(*PM_TraceTexture) ( int ground, vec3_t vstart, vec3_t vend );
	void			(*PM_PlaybackEventFull) ( int flags, int clientindex, unsigned short eventindex, float delay, float *origin, float *angles, float fparam1, float fparam2, int iparam1, int iparam2, int bparam1, int bparam2 );
};

#endif

```

`halflife/engine/PM_INFO.H`:

```H
/***
*
*	Copyright (c) 1999, 2000, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
// Physics info string definition
#if !defined( PM_INFOH )
#define PM_INFOH
#pragma once

#define MAX_PHYSINFO_STRING 256

#endif // PM_INFOH
```

`halflife/engine/PROGDEFS.H`:

```H
/***
*
*	Copyright (c) 1999, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef PROGDEFS_H
#define PROGDEFS_H
#ifdef _WIN32
#pragma once
#endif

typedef struct
{	
	float		time;
	float		frametime;
	float		force_retouch;
	string_t	mapname;
	string_t	startspot;
	float		deathmatch;
	float		coop;
	float		teamplay;
	float		serverflags;
	float		found_secrets;
	vec3_t		v_forward;
	vec3_t		v_up;
	vec3_t		v_right;
	float		trace_allsolid;
	float		trace_startsolid;
	float		trace_fraction;
	vec3_t		trace_endpos;
	vec3_t		trace_plane_normal;
	float		trace_plane_dist;
	edict_t		*trace_ent;
	float		trace_inopen;
	float		trace_inwater;
	int			trace_hitgroup;
	int			trace_flags;
	int			msg_entity;
	int			cdAudioTrack;
	int			maxClients;
	int			maxEntities;
	const char	*pStringBase;

	void		*pSaveData;
	vec3_t		vecLandmarkOffset;
} globalvars_t;


typedef struct entvars_s
{
	string_t	classname;
	string_t	globalname;

	vec3_t		origin;
	vec3_t		oldorigin;
	vec3_t		velocity;
	vec3_t		basevelocity;
	vec3_t      clbasevelocity;  // Base velocity that was passed in to server physics so 
							     //  client can predict conveyors correctly.  Server zeroes it, so we need to store here, too.
	vec3_t		movedir;

	vec3_t		angles;			// Model angles
	vec3_t		avelocity;		// angle velocity (degrees per second)
	vec3_t		punchangle;		// auto-decaying view angle adjustment
	vec3_t		v_angle;		// Viewing angle (player only)

	// For parametric entities
	vec3_t		endpos;
	vec3_t		startpos;
	float		impacttime;
	float		starttime;

	int			fixangle;		// 0:nothing, 1:force view angles, 2:add avelocity
	float		idealpitch;
	float		pitch_speed;
	float		ideal_yaw;
	float		yaw_speed;

	int			modelindex;
	string_t	model;

	int			viewmodel;		// player's viewmodel
	int			weaponmodel;	// what other players see
	
	vec3_t		absmin;		// BB max translated to world coord
	vec3_t		absmax;		// BB max translated to world coord
	vec3_t		mins;		// local BB min
	vec3_t		maxs;		// local BB max
	vec3_t		size;		// maxs - mins

	float		ltime;
	float		nextthink;

	int			movetype;
	int			solid;

	int			skin;			
	int			body;			// sub-model selection for studiomodels
	int 		effects;
	
	float		gravity;		// % of "normal" gravity
	float		friction;		// inverse elasticity of MOVETYPE_BOUNCE
	
	int			light_level;

	int			sequence;		// animation sequence
	int			gaitsequence;	// movement animation sequence for player (0 for none)
	float		frame;			// % playback position in animation sequences (0..255)
	float		animtime;		// world time when frame was set
	float		framerate;		// animation playback rate (-8x to 8x)
	byte		controller[4];	// bone controller setting (0..255)
	byte		blending[2];	// blending amount between sub-sequences (0..255)

	float		scale;			// sprite rendering scale (0..255)

	int			rendermode;
	float		renderamt;
	vec3_t		rendercolor;
	int			renderfx;

	float		health;
	float		frags;
	int			weapons;  // bit mask for available weapons
	float		takedamage;

	int			deadflag;
	vec3_t		view_ofs;	// eye position

	int			button;
	int			impulse;

	edict_t		*chain;			// Entity pointer when linked into a linked list
	edict_t		*dmg_inflictor;
	edict_t		*enemy;
	edict_t		*aiment;		// entity pointer when MOVETYPE_FOLLOW
	edict_t		*owner;
	edict_t		*groundentity;

	int			spawnflags;
	int			flags;
	
	int			colormap;		// lowbyte topcolor, highbyte bottomcolor
	int			team;

	float		max_health;
	float		teleport_time;
	float		armortype;
	float		armorvalue;
	int			waterlevel;
	int			watertype;
	
	string_t	target;
	string_t	targetname;
	string_t	netname;
	string_t	message;

	float		dmg_take;
	float		dmg_save;
	float		dmg;
	float		dmgtime;
	
	string_t	noise;
	string_t	noise1;
	string_t	noise2;
	string_t	noise3;
	
	float		speed;
	float		air_finished;
	float		pain_finished;
	float		radsuit_finished;
	
	edict_t		*pContainingEntity;

	int			playerclass;
	float		maxspeed;

	float		fov;
	int			weaponanim;

	int			pushmsec;

	int			bInDuck;
	int			flTimeStepSound;
	int			flSwimTime;
	int			flDuckTime;
	int			iStepLeft;
	float		flFallVelocity;

	int			gamestate;

	int			oldbuttons;

	int			groupinfo;

	// For mods
	int			iuser1;
	int			iuser2;
	int			iuser3;
	int			iuser4;
	float		fuser1;
	float		fuser2;
	float		fuser3;
	float		fuser4;
	vec3_t		vuser1;
	vec3_t		vuser2;
	vec3_t		vuser3;
	vec3_t		vuser4;
	edict_t		*euser1;
	edict_t		*euser2;
	edict_t		*euser3;
	edict_t		*euser4;
} entvars_t;


#endif // PROGDEFS_H
```

`halflife/engine/PROGS.H`:

```H
/***
*
*	Copyright (c) 1999, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef PROGS_H
#define PROGS_H

#include "progdefs.h"

// 16 simultaneous events, max
#define MAX_EVENT_QUEUE 64

#define DEFAULT_EVENT_RESENDS 1

#include "event_flags.h"

typedef struct event_info_s event_info_t;

#include "event_args.h"

struct event_info_s
{
	unsigned short index;			  // 0 implies not in use

	short packet_index;      // Use data from state info for entity in delta_packet .  -1 implies separate info based on event
	                         // parameter signature
	short entity_index;      // The edict this event is associated with

	float fire_time;        // if non-zero, the time when the event should be fired ( fixed up on the client )
	
	event_args_t args;

// CLIENT ONLY	
	int	  flags;			// Reliable or not, etc.

};

typedef struct event_state_s event_state_t;

struct event_state_s
{
	struct event_info_s ei[ MAX_EVENT_QUEUE ];
};

#if !defined( ENTITY_STATEH )
#include "entity_state.h"
#endif

#if !defined( EDICT_H )
#include "edict.h"
#endif

#define	STRUCT_FROM_LINK(l,t,m) ((t *)((byte *)l - (int)&(((t *)0)->m)))
#define	EDICT_FROM_AREA(l) STRUCT_FROM_LINK(l,edict_t,area)

//============================================================================

extern	char			*pr_strings;
extern	globalvars_t	gGlobalVariables;

//============================================================================

edict_t		*ED_Alloc (void);
void		ED_Free (edict_t *ed);
void		ED_LoadFromFile (char *data);

edict_t		*EDICT_NUM(int n);
int			NUM_FOR_EDICT(const edict_t *e);

#define PROG_TO_EDICT(e) ((edict_t *)((byte *)sv.edicts + e))

#endif // PROGS_H
```

`halflife/engine/R_EFX.H`:

```H
/***
*
*	Copyright (c) 1999, 2000, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined ( R_EFXH )
#define R_EFXH
#pragma once

// particle_t
#if !defined( PARTICLEDEFH )  
#include "particledef.h"
#endif

// BEAM
#if !defined( BEAMDEFH )
#include "beamdef.h"
#endif

// dlight_t
#if !defined ( DLIGHTH )
#include "dlight.h"
#endif

// cl_entity_t
#if !defined( CL_ENTITYH )
#include "cl_entity.h"
#endif

/*
// FOR REFERENCE, These are the built-in tracer colors.  Note, color 4 is the one
//  that uses the tracerred/tracergreen/tracerblue and traceralpha cvar settings
color24 gTracerColors[] =
{
	{ 255, 255, 255 },		// White
	{ 255, 0, 0 },			// Red
	{ 0, 255, 0 },			// Green
	{ 0, 0, 255 },			// Blue
	{ 0, 0, 0 },			// Tracer default, filled in from cvars, etc.
	{ 255, 167, 17 },		// Yellow-orange sparks
	{ 255, 130, 90 },		// Yellowish streaks (garg)
	{ 55, 60, 144 },		// Blue egon streak
	{ 255, 130, 90 },		// More Yellowish streaks (garg)
	{ 255, 140, 90 },		// More Yellowish streaks (garg)
	{ 200, 130, 90 },		// More red streaks (garg)
	{ 255, 120, 70 },		// Darker red streaks (garg)
};
*/

// Temporary entity array
#define TENTPRIORITY_LOW	0
#define TENTPRIORITY_HIGH	1

// TEMPENTITY flags
#define	FTENT_NONE				0x00000000
#define	FTENT_SINEWAVE			0x00000001
#define	FTENT_GRAVITY			0x00000002
#define FTENT_ROTATE			0x00000004
#define	FTENT_SLOWGRAVITY		0x00000008
#define FTENT_SMOKETRAIL		0x00000010
#define FTENT_COLLIDEWORLD		0x00000020
#define FTENT_FLICKER			0x00000040
#define FTENT_FADEOUT			0x00000080
#define FTENT_SPRANIMATE		0x00000100
#define FTENT_HITSOUND			0x00000200
#define FTENT_SPIRAL			0x00000400
#define FTENT_SPRCYCLE			0x00000800
#define FTENT_COLLIDEALL		0x00001000 // will collide with world and slideboxes
#define FTENT_PERSIST			0x00002000 // tent is not removed when unable to draw 
#define FTENT_COLLIDEKILL		0x00004000 // tent is removed upon collision with anything
#define FTENT_PLYRATTACHMENT	0x00008000 // tent is attached to a player (owner)
#define FTENT_SPRANIMATELOOP	0x00010000 // animating sprite doesn't die when last frame is displayed
#define FTENT_SPARKSHOWER		0x00020000
#define FTENT_NOMODEL			0x00040000 // Doesn't have a model, never try to draw ( it just triggers other things )
#define FTENT_CLIENTCUSTOM		0x00080000 // Must specify callback.  Callback function is responsible for killing tempent and updating fields ( unless other flags specify how to do things )

typedef struct tempent_s	TEMPENTITY;
typedef struct tempent_s
{
	int			flags;
	float		die;
	float		frameMax;
	float		x;
	float		y;
	float		z;
	float		fadeSpeed;
	float		bounceFactor;
	int			hitSound;
	void		( *hitcallback )	( struct tempent_s *ent, struct pmtrace_s *ptr );
	void		( *callback )		( struct tempent_s *ent, float frametime, float currenttime );
	TEMPENTITY	*next;
	int			priority;
	short		clientIndex;	// if attached, this is the index of the client to stick to
								// if COLLIDEALL, this is the index of the client to ignore
								// TENTS with FTENT_PLYRATTACHMENT MUST set the clientindex! 

	vec3_t		tentOffset;		// if attached, client origin + tentOffset = tent origin.
	cl_entity_t	entity;

	// baseline.origin		- velocity
	// baseline.renderamt	- starting fadeout intensity
	// baseline.angles		- angle velocity
} TEMPENTITY;

typedef struct efx_api_s efx_api_t;

struct efx_api_s
{
	particle_t  *( *R_AllocParticle )			( void ( *callback ) ( struct particle_s *particle, float frametime ) );
	void		( *R_BlobExplosion )			( float * org );
	void		( *R_Blood )					( float * org, float * dir, int pcolor, int speed );
	void		( *R_BloodSprite )				( float * org, int colorindex, int modelIndex, int modelIndex2, float size );
	void		( *R_BloodStream )				( float * org, float * dir, int pcolor, int speed );
	void		( *R_BreakModel )				( float *pos, float *size, float *dir, float random, float life, int count, int modelIndex, char flags );
	void		( *R_Bubbles )					( float * mins, float * maxs, float height, int modelIndex, int count, float speed );
	void		( *R_BubbleTrail )				( float * start, float * end, float height, int modelIndex, int count, float speed );
	void		( *R_BulletImpactParticles )	( float * pos );
	void		( *R_EntityParticles )			( struct cl_entity_s *ent );
	void		( *R_Explosion )				( float *pos, int model, float scale, float framerate, int flags );
	void		( *R_FizzEffect )				( struct cl_entity_s *pent, int modelIndex, int density );
	void		( *R_FireField ) 				( float * org, int radius, int modelIndex, int count, int flags, float life );
	void		( *R_FlickerParticles )			( float * org );
	void		( *R_FunnelSprite )				( float *org, int modelIndex, int reverse );
	void		( *R_Implosion )				( float * end, float radius, int count, float life );
	void		( *R_LargeFunnel )				( float * org, int reverse );
	void		( *R_LavaSplash )				( float * org );
	void		( *R_MultiGunshot )				( float * org, float * dir, float * noise, int count, int decalCount, int *decalIndices );
	void		( *R_MuzzleFlash )				( float *pos1, int type );
	void		( *R_ParticleBox )				( float *mins, float *maxs, unsigned char r, unsigned char g, unsigned char b, float life );
	void		( *R_ParticleBurst )			( float * pos, int size, int color, float life );
	void		( *R_ParticleExplosion )		( float * org );
	void		( *R_ParticleExplosion2 )		( float * org, int colorStart, int colorLength );
	void		( *R_ParticleLine )				( float * start, float *end, unsigned char r, unsigned char g, unsigned char b, float life );
	void		( *R_PlayerSprites )			( int client, int modelIndex, int count, int size );
	void		( *R_Projectile )				( float * origin, float * velocity, int modelIndex, int life, int owner, void (*hitcallback)( struct tempent_s *ent, struct pmtrace_s *ptr ) );
	void		( *R_RicochetSound )			( float * pos );
	void		( *R_RicochetSprite )			( float *pos, struct model_s *pmodel, float duration, float scale );
	void		( *R_RocketFlare )				( float *pos );
	void		( *R_RocketTrail )				( float * start, float * end, int type );
	void		( *R_RunParticleEffect )		( float * org, float * dir, int color, int count );
	void		( *R_ShowLine )					( float * start, float * end );
	void		( *R_SparkEffect )				( float *pos, int count, int velocityMin, int velocityMax );
	void		( *R_SparkShower )				( float *pos );
	void		( *R_SparkStreaks )				( float * pos, int count, int velocityMin, int velocityMax );
	void		( *R_Spray )					( float * pos, float * dir, int modelIndex, int count, int speed, int spread, int rendermode );
	void		( *R_Sprite_Explode )			( TEMPENTITY *pTemp, float scale, int flags );
	void		( *R_Sprite_Smoke )				( TEMPENTITY *pTemp, float scale );
	void		( *R_Sprite_Spray )				( float * pos, float * dir, int modelIndex, int count, int speed, int iRand );
	void		( *R_Sprite_Trail )				( int type, float * start, float * end, int modelIndex, int count, float life, float size, float amplitude, int renderamt, float speed );
	void		( *R_Sprite_WallPuff )			( TEMPENTITY *pTemp, float scale );
	void		( *R_StreakSplash )				( float * pos, float * dir, int color, int count, float speed, int velocityMin, int velocityMax );
	void		( *R_TracerEffect )				( float * start, float * end );
	void		( *R_UserTracerParticle )		( float * org, float * vel, float life, int colorIndex, float length, unsigned char deathcontext, void ( *deathfunc)( struct particle_s *particle ) );
	particle_t *( *R_TracerParticles )			( float * org, float * vel, float life );
	void		( *R_TeleportSplash )			( float * org );
	void		( *R_TempSphereModel )			( float *pos, float speed, float life, int count, int modelIndex );
	TEMPENTITY	*( *R_TempModel )				( float *pos, float *dir, float *angles, float life, int modelIndex, int soundtype );
	TEMPENTITY	*( *R_DefaultSprite )			( float *pos, int spriteIndex, float framerate );
	TEMPENTITY	*( *R_TempSprite )				( float *pos, float *dir, float scale, int modelIndex, int rendermode, int renderfx, float a, float life, int flags );
	int			( *Draw_DecalIndex )			( int id );
	int			( *Draw_DecalIndexFromName )	( char *name );
	void		( *R_DecalShoot )				( int textureIndex, int entity, int modelIndex, float * position, int flags );
	void		( *R_AttachTentToPlayer )		( int client, int modelIndex, float zoffset, float life );
	void		( *R_KillAttachedTents )		( int client );
	BEAM		*( *R_BeamCirclePoints )		( int type, float * start, float * end, int modelIndex, float life, float width, float amplitude, float brightness, float speed, int startFrame, float framerate, float r, float g, float b );
	BEAM		*( *R_BeamEntPoint )			( int startEnt, float * end, int modelIndex, float life, float width, float amplitude, float brightness, float speed, int startFrame, float framerate, float r, float g, float b );
	BEAM		*( *R_BeamEnts )				( int startEnt, int endEnt, int modelIndex, float life, float width, float amplitude, float brightness, float speed, int startFrame, float framerate, float r, float g, float b );
	BEAM		*( *R_BeamFollow )				( int startEnt, int modelIndex, float life, float width, float r, float g, float b, float brightness );
	void		( *R_BeamKill )					( int deadEntity );
	BEAM		*( *R_BeamLightning )			( float * start, float * end, int modelIndex, float life, float width, float amplitude, float brightness, float speed );
	BEAM		*( *R_BeamPoints )				( float * start, float * end, int modelIndex, float life, float width, float amplitude, float brightness, float speed, int startFrame, float framerate, float r, float g, float b );
	BEAM		*( *R_BeamRing )				( int startEnt, int endEnt, int modelIndex, float life, float width, float amplitude, float brightness, float speed, int startFrame, float framerate, float r, float g, float b );
	dlight_t	*( *CL_AllocDlight )			( int key );
	dlight_t	*( *CL_AllocElight )			( int key );
	TEMPENTITY	*( *CL_TempEntAlloc )			( float * org, struct model_s *model );
	TEMPENTITY	*( *CL_TempEntAllocNoModel )	( float * org );
	TEMPENTITY	*( *CL_TempEntAllocHigh )		( float * org, struct model_s *model );
	TEMPENTITY	*( *CL_TentEntAllocCustom )		( float *origin, struct model_s *model, int high, void ( *callback ) ( struct tempent_s *ent, float frametime, float currenttime ) );
	void		( *R_GetPackedColor )			( short *packed, short color );
	short		( *R_LookupColor )				( unsigned char r, unsigned char g, unsigned char b );
};

extern efx_api_t efx;

#endif
```

`halflife/engine/SHAKE.H`:

```H
/***
*
*	Copyright (c) 1999, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef SHAKE_H
#define SHAKE_H

// Screen / View effects

// screen shake
extern int gmsgShake;

// This structure is sent over the net to describe a screen shake event
typedef struct
{
	unsigned short	amplitude;		// FIXED 4.12 amount of shake
	unsigned short 	duration;		// FIXED 4.12 seconds duration
	unsigned short	frequency;		// FIXED 8.8 noise frequency (low frequency is a jerk,high frequency is a rumble)
} ScreenShake;

extern void V_ApplyShake( float *origin, float *angles, float factor );
extern void V_CalcShake( void );
extern int V_ScreenShake( const char *pszName, int iSize, void *pbuf );
extern int V_ScreenFade( const char *pszName, int iSize, void *pbuf );


// Fade in/out
extern int gmsgFade;

#define FFADE_IN			0x0000		// Just here so we don't pass 0 into the function
#define FFADE_OUT			0x0001		// Fade out (not in)
#define FFADE_MODULATE		0x0002		// Modulate (don't blend)
#define FFADE_STAYOUT		0x0004		// ignores the duration, stays faded out until new ScreenFade message received

// This structure is sent over the net to describe a screen fade event
typedef struct
{
	unsigned short 	duration;		// FIXED 4.12 seconds duration
	unsigned short 	holdTime;		// FIXED 4.12 seconds duration until reset (fade & hold)
	short			fadeFlags;		// flags
	byte			r, g, b, a;		// fade to color ( max alpha )
} ScreenFade;

#endif		// SHAKE_H


```

`halflife/engine/STUDIO.H`:

```H
/***
*
*	Copyright (c) 1999, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/




#ifndef _STUDIO_H_
#define _STUDIO_H_

/*
==============================================================================

STUDIO MODELS

Studio models are position independent, so the cache manager can move them.
==============================================================================
*/


#define MAXSTUDIOTRIANGLES	20000	// TODO: tune this
#define MAXSTUDIOVERTS		2048	// TODO: tune this
#define MAXSTUDIOSEQUENCES	256		// total animation sequences
#define MAXSTUDIOSKINS		100		// total textures
#define MAXSTUDIOSRCBONES	512		// bones allowed at source movement
#define MAXSTUDIOBONES		128		// total bones actually used
#define MAXSTUDIOMODELS		32		// sub-models per model
#define MAXSTUDIOBODYPARTS	32
#define MAXSTUDIOGROUPS		16
#define MAXSTUDIOANIMATIONS	512		// per sequence
#define MAXSTUDIOMESHES		256
#define MAXSTUDIOEVENTS		1024
#define MAXSTUDIOPIVOTS		256
#define MAXSTUDIOCONTROLLERS 8

typedef struct 
{
	int					id;
	int					version;

	char				name[64];
	int					length;

	vec3_t				eyeposition;	// ideal eye position
	vec3_t				min;			// ideal movement hull size
	vec3_t				max;			

	vec3_t				bbmin;			// clipping bounding box
	vec3_t				bbmax;		

	int					flags;

	int					numbones;			// bones
	int					boneindex;

	int					numbonecontrollers;		// bone controllers
	int					bonecontrollerindex;

	int					numhitboxes;			// complex bounding boxes
	int					hitboxindex;			
	
	int					numseq;				// animation sequences
	int					seqindex;

	int					numseqgroups;		// demand loaded sequences
	int					seqgroupindex;

	int					numtextures;		// raw textures
	int					textureindex;
	int					texturedataindex;

	int					numskinref;			// replaceable textures
	int					numskinfamilies;
	int					skinindex;

	int					numbodyparts;		
	int					bodypartindex;

	int					numattachments;		// queryable attachable points
	int					attachmentindex;

	int					soundtable;
	int					soundindex;
	int					soundgroups;
	int					soundgroupindex;

	int					numtransitions;		// animation node to animation node transition graph
	int					transitionindex;
} studiohdr_t;

// header for demand loaded sequence group data
typedef struct 
{
	int					id;
	int					version;

	char				name[64];
	int					length;
} studioseqhdr_t;

// bones
typedef struct 
{
	char				name[32];	// bone name for symbolic links
	int		 			parent;		// parent bone
	int					flags;		// ??
	int					bonecontroller[6];	// bone controller index, -1 == none
	float				value[6];	// default DoF values
	float				scale[6];   // scale for delta DoF values
} mstudiobone_t;


// bone controllers
typedef struct 
{
	int					bone;	// -1 == 0
	int					type;	// X, Y, Z, XR, YR, ZR, M
	float				start;
	float				end;
	int					rest;	// byte index value at rest
	int					index;	// 0-3 user set controller, 4 mouth
} mstudiobonecontroller_t;

// intersection boxes
typedef struct
{
	int					bone;
	int					group;			// intersection group
	vec3_t				bbmin;		// bounding box
	vec3_t				bbmax;		
} mstudiobbox_t;

#if !defined( CACHE_USER ) && !defined( QUAKEDEF_H )
#define CACHE_USER
typedef struct cache_user_s
{
	void *data;
} cache_user_t;
#endif

// demand loaded sequence groups
typedef struct
{
	char				label[32];	// textual name
	char				name[64];	// file name
	cache_user_t		cache;		// cache index pointer
	int					data;		// hack for group 0
} mstudioseqgroup_t;

// sequence descriptions
typedef struct
{
	char				label[32];	// sequence label

	float				fps;		// frames per second	
	int					flags;		// looping/non-looping flags

	int					activity;
	int					actweight;

	int					numevents;
	int					eventindex;

	int					numframes;	// number of frames per sequence

	int					numpivots;	// number of foot pivots
	int					pivotindex;

	int					motiontype;	
	int					motionbone;
	vec3_t				linearmovement;
	int					automoveposindex;
	int					automoveangleindex;

	vec3_t				bbmin;		// per sequence bounding box
	vec3_t				bbmax;		

	int					numblends;
	int					animindex;		// mstudioanim_t pointer relative to start of sequence group data
										// [blend][bone][X, Y, Z, XR, YR, ZR]

	int					blendtype[2];	// X, Y, Z, XR, YR, ZR
	float				blendstart[2];	// starting value
	float				blendend[2];	// ending value
	int					blendparent;

	int					seqgroup;		// sequence group for demand loading

	int					entrynode;		// transition node at entry
	int					exitnode;		// transition node at exit
	int					nodeflags;		// transition rules
	
	int					nextseq;		// auto advancing sequences
} mstudioseqdesc_t;

// events
#include "studio_event.h"
/*
typedef struct 
{
	int 				frame;
	int					event;
	int					type;
	char				options[64];
} mstudioevent_t;
*/

// pivots
typedef struct 
{
	vec3_t				org;	// pivot point
	int					start;
	int					end;
} mstudiopivot_t;

// attachment
typedef struct 
{
	char				name[32];
	int					type;
	int					bone;
	vec3_t				org;	// attachment point
	vec3_t				vectors[3];
} mstudioattachment_t;

typedef struct
{
	unsigned short	offset[6];
} mstudioanim_t;

// animation frames
typedef union 
{
	struct {
		byte	valid;
		byte	total;
	} num;
	short		value;
} mstudioanimvalue_t;



// body part index
typedef struct
{
	char				name[64];
	int					nummodels;
	int					base;
	int					modelindex; // index into models array
} mstudiobodyparts_t;



// skin info
typedef struct
{
	char					name[64];
	int						flags;
	int						width;
	int						height;
	int						index;
} mstudiotexture_t;


// skin families
// short	index[skinfamilies][skinref]

// studio models
typedef struct
{
	char				name[64];

	int					type;

	float				boundingradius;

	int					nummesh;
	int					meshindex;

	int					numverts;		// number of unique vertices
	int					vertinfoindex;	// vertex bone info
	int					vertindex;		// vertex vec3_t
	int					numnorms;		// number of unique surface normals
	int					norminfoindex;	// normal bone info
	int					normindex;		// normal vec3_t

	int					numgroups;		// deformation groups
	int					groupindex;
} mstudiomodel_t;


// vec3_t	boundingbox[model][bone][2];	// complex intersection info


// meshes
typedef struct 
{
	int					numtris;
	int					triindex;
	int					skinref;
	int					numnorms;		// per mesh normals
	int					normindex;		// normal vec3_t
} mstudiomesh_t;

// triangles
#if 0
typedef struct 
{
	short				vertindex;		// index into vertex array
	short				normindex;		// index into normal array
	short				s,t;			// s,t position on skin
} mstudiotrivert_t;
#endif

// lighting options
#define STUDIO_NF_FLATSHADE		0x0001
#define STUDIO_NF_CHROME		0x0002
#define STUDIO_NF_FULLBRIGHT	0x0004

// motion flags
#define STUDIO_X		0x0001
#define STUDIO_Y		0x0002	
#define STUDIO_Z		0x0004
#define STUDIO_XR		0x0008
#define STUDIO_YR		0x0010
#define STUDIO_ZR		0x0020
#define STUDIO_LX		0x0040
#define STUDIO_LY		0x0080
#define STUDIO_LZ		0x0100
#define STUDIO_AX		0x0200
#define STUDIO_AY		0x0400
#define STUDIO_AZ		0x0800
#define STUDIO_AXR		0x1000
#define STUDIO_AYR		0x2000
#define STUDIO_AZR		0x4000
#define STUDIO_TYPES	0x7FFF
#define STUDIO_RLOOP	0x8000	// controller that wraps shortest distance

// sequence flags
#define STUDIO_LOOPING	0x0001

// bone flags
#define STUDIO_HAS_NORMALS	0x0001
#define STUDIO_HAS_VERTICES 0x0002
#define STUDIO_HAS_BBOX		0x0004
#define STUDIO_HAS_CHROME	0x0008	// if any of the textures have chrome on them

#define RAD_TO_STUDIO		(32768.0/M_PI)
#define STUDIO_TO_RAD		(M_PI/32768.0)

#endif

```

`halflife/engine/USERCMD.H`:

```H
/***
*
*	Copyright (c) 1999, 2000 Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef USERCMD_H
#define USERCMD_H
#ifdef _WIN32
#pragma once
#endif

typedef struct usercmd_s
{
	short	lerp_msec;      // Interpolation time on client
	byte	msec;           // Duration in ms of command
	vec3_t	viewangles;     // Command view angles.

// intended velocities
	float	forwardmove;    // Forward velocity.
	float	sidemove;       // Sideways velocity.
	float	upmove;         // Upward velocity.
	byte	lightlevel;     // Light level at spot where we are standing.
	unsigned short  buttons;  // Attack buttons
	byte    impulse;          // Impulse command issued.
	byte	weaponselect;	// Current weapon id

// Experimental player impact stuff.
	int		impact_index;
	vec3_t	impact_position;
} usercmd_t;

#endif // USERCMD_H
```

`halflife/engine/WRECT.H`:

```H
#if !defined( WRECTH )
#define WRECTH

typedef struct rect_s
{
	int				left, right, top, bottom;
} wrect_t;

#endif
```

`halflife/engine/bspfile.h`:

```h
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#pragma once

// header
#define Q1BSP_VERSION		29		// quake1 regular version (beta is 28)
#define HLBSP_VERSION		30		// half-life regular version

#define MAX_MAP_HULLS		4

#define CONTENTS_ORIGIN		-7		// removed at csg time
#define CONTENTS_CLIP		-8		// changed to contents_solid
#define CONTENTS_CURRENT_0	-9
#define CONTENTS_CURRENT_90	-10
#define CONTENTS_CURRENT_180	-11
#define CONTENTS_CURRENT_270	-12
#define CONTENTS_CURRENT_UP	-13
#define CONTENTS_CURRENT_DOWN	-14

#define CONTENTS_TRANSLUCENT	-15

#define	LUMP_ENTITIES		0
#define	LUMP_PLANES		1
#define	LUMP_TEXTURES		2
#define	LUMP_VERTEXES		3
#define	LUMP_VISIBILITY		4
#define	LUMP_NODES		5
#define	LUMP_TEXINFO		6
#define	LUMP_FACES		7
#define	LUMP_LIGHTING		8
#define	LUMP_CLIPNODES		9
#define	LUMP_LEAFS		10
#define	LUMP_MARKSURFACES	11
#define	LUMP_EDGES		12
#define	LUMP_SURFEDGES		13
#define	LUMP_MODELS		14

#define	HEADER_LUMPS		15

typedef struct lump_s
{
	int				fileofs;
	int				filelen;
} lump_t;

/*typedef struct dmodel_s
{
	float			mins[3], maxs[3];
	float			origin[3];
	int				headnode[MAX_MAP_HULLS];
	int				visleafs;		// not including the solid leaf 0
	int				firstface, numfaces;
} dmodel_t;*/

typedef struct dheader_s
{
	int				version;
	lump_t			lumps[15];
} dheader_t;

typedef struct dmiptexlump_s
{
	int				_nummiptex;
	int				dataofs[4];
} dmiptexlump_t;

typedef struct miptex_s
{
	char			name[16];
	unsigned		width;
	unsigned		height;
	unsigned		offsets[4];
} miptex_t;

typedef struct dvertex_s
{
	float			point[3];
} dvertex_t;

typedef struct dplane_s
{
	float			normal[3];
	float			dist;
	int				type;
} dplane_t;

typedef struct dnode_s
{
	int				planenum;
	short			children[2];
	short			mins[3];
	short			maxs[3];
	unsigned short	firstface;
	unsigned short	numfaces;
} dnode_t;

/*typedef struct dclipnode_s
{
	int				planenum;
	short			children[2];	// negative numbers are contents
} dclipnode_t;*/

typedef struct texinfo_s
{
	float			vecs[2][4];
	int				_miptex;
	int				flags;
} texinfo_t;

typedef struct dedge_s
{
	unsigned short	v[2];
} dedge_t;

typedef struct dface_s
{
	short			planenum;
	short			side;
	int				firstedge;
	short			numedges;
	short			texinfo;
	byte			styles[4];
	int				lightofs;
} dface_t;

typedef struct dleaf_s
{
	int				contents;
	int				visofs;
	short			mins[3];
	short			maxs[3];
	unsigned short	firstmarksurface;
	unsigned short	nummarksurfaces;
	byte			ambient_level[4];
} dleaf_t;

```

`halflife/engine/cdll_engine_dll.h`:

```h
/***
*
*	Copyright (c) 1999, 2000 Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
//  cdll_dll.h

// this file is included by both the game-dll and the client-dll,

#ifndef CDLL_DLL_H
#define CDLL_DLL_H

#define MAX_WEAPONS		32		// ???

#define MAX_WEAPON_SLOTS		5	// hud item selection slots
#define MAX_ITEM_TYPES			6	// hud item selection slots

#define MAX_ITEMS				5	// hard coded item types

#define	HIDEHUD_WEAPONS		( 1<<0 )
#define	HIDEHUD_FLASHLIGHT	( 1<<1 )
#define	HIDEHUD_ALL			( 1<<2 )
#define 	HIDEHUD_HEALTH		( 1<<3 )

#define	MAX_AMMO_TYPES	32		// ???
#define MAX_AMMO_SLOTS  32		// not really slots

#define HUD_PRINTNOTIFY		1
#define HUD_PRINTCONSOLE	2
#define HUD_PRINTTALK		3
#define HUD_PRINTCENTER		4


#define WEAPON_SUIT			31

#endif
```

`halflife/engine/cdll_int.h`:

```h
/***
*
*	Copyright (c) 1999, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
//  cdll_int.h
//
// 4-23-98  
// JOHN:  client dll interface declarations
//

#ifndef CDLL_INT_H
#define CDLL_INT_H

#ifdef __cplusplus
extern "C" {
#endif

#include "const.h"
#include "../misc/steamtypes.h"
#include "../common/ref_params.h"
#include "r_efx.h"
#include "studio_event.h"

// this file is included by both the engine and the client-dll,
// so make sure engine declarations aren't done twice

//typedef int HSPRITE;	// handle to a graphic

#define SCRINFO_SCREENFLASH 1
#define SCRINFO_STRETCHED	2

typedef struct SCREENINFO_s
{
	int		iSize;
	int		iWidth;
	int		iHeight;
	int		iFlags;
	int		iCharHeight;
	short	charWidths[256];
} SCREENINFO;


typedef struct client_data_s
{
	// fields that cannot be modified  (ie. have no effect if changed)
	vec3_t origin;

	// fields that can be changed by the cldll
	vec3_t viewangles;
	int		iWeaponBits;
//	int		iAccessoryBits;
	float	fov;	// field of view
} client_data_t;

typedef struct client_sprite_s
{
	char szName[64];
	char szSprite[64];
	int hspr;
	int iRes;
	wrect_t rc;
} client_sprite_t;



typedef struct hud_player_info_s
{
	char *name;
	short ping;
	byte thisplayer;  // TRUE if this is the calling player

	byte spectator;
	byte packetloss;

	char *model;
	short topcolor;
	short bottomcolor;

	uint64 m_nSteamID;
} hud_player_info_t;



typedef struct module_s
{
	unsigned char				ucMD5Hash[16];	// hash over code
	qboolean					fLoaded;		// true if successfully loaded
} module_t;



	
		

#ifndef IN_BUTTONS_H
#include "in_buttons.h"
#endif

#define CLDLL_INTERFACE_VERSION		7

extern void LoadSecurityModuleFromDisk(char * pszDllName);
extern void LoadSecurityModuleFromMemory( unsigned char * pCode, int nSize );
extern void CloseSecurityModule();


extern void ClientDLL_Init( void ); // from cdll_int.c
extern void ClientDLL_Shutdown( void );
extern void ClientDLL_HudInit( void );
extern void ClientDLL_HudVidInit( void );
extern void	ClientDLL_UpdateClientData( void );
extern void ClientDLL_Frame( double time );
extern void ClientDLL_HudRedraw( int intermission );
extern void ClientDLL_MoveClient( struct playermove_s *ppmove );
extern void ClientDLL_ClientMoveInit( struct playermove_s *ppmove );
extern char ClientDLL_ClientTextureType( char *name );

extern void ClientDLL_CreateMove( float frametime, struct usercmd_s *cmd, int active );
extern void ClientDLL_ActivateMouse( void );
extern void ClientDLL_DeactivateMouse( void );
extern void ClientDLL_MouseEvent( int mstate );
extern void ClientDLL_ClearStates( void );
extern int ClientDLL_IsThirdPerson( void );
extern void ClientDLL_GetCameraOffsets( float *ofs );
extern int ClientDLL_GraphKeyDown( void );
extern struct kbutton_s *ClientDLL_FindKey( const char *name );
extern void ClientDLL_CAM_Think( void );
extern void ClientDLL_IN_Accumulate( void );
extern void ClientDLL_CalcRefdef( struct ref_params_s *pparams );
extern int ClientDLL_AddEntity( int type, struct cl_entity_s *ent );
extern void ClientDLL_CreateEntities( void );

extern void ClientDLL_DrawNormalTriangles( void );
extern void ClientDLL_DrawTransparentTriangles( void );
extern void ClientDLL_StudioEvent( const struct mstudioevent_s *event, const struct cl_entity_s *entity );
extern void ClientDLL_PostRunCmd( struct local_state_s *from, struct local_state_s *to, struct usercmd_s *cmd, int runfuncs, double time, unsigned int random_seed );
extern void ClientDLL_TxferLocalOverrides( struct entity_state_s *state, const struct clientdata_s *client );
extern void ClientDLL_ProcessPlayerState( struct entity_state_s *dst, const struct entity_state_s *src );
extern void ClientDLL_TxferPredictionData ( struct entity_state_s *ps, const struct entity_state_s *pps, struct clientdata_s *pcd, const struct clientdata_s *ppcd, struct weapon_data_s *wd, const struct weapon_data_s *pwd );
extern void ClientDLL_ReadDemoBuffer( int size, unsigned char *buffer );
extern int ClientDLL_ConnectionlessPacket( const struct netadr_s *net_from, const char *args, char *response_buffer, int *response_buffer_size );
extern int ClientDLL_GetHullBounds( int hullnumber, float *mins, float *maxs );

extern void ClientDLL_VGui_ConsolePrint(const char* text);

extern int ClientDLL_Key_Event( int down, int keynum, const char *pszCurrentBinding );
extern void ClientDLL_TempEntUpdate( double ft, double ct, double grav, struct tempent_s **ppFreeTE, struct tempent_s **ppActiveTE, int ( *addTEntity )( struct cl_entity_s *pEntity ), void ( *playTESound )( struct tempent_s *pTemp, float damp ) );
extern struct cl_entity_s *ClientDLL_GetUserEntity( int index );
extern void ClientDLL_VoiceStatus(int entindex, qboolean bTalking);
extern void ClientDLL_DirectorMessage( int iSize, void *pbuf );
extern void ClientDLL_ChatInputPosition( int *x, int *y );

//#include "server.h" // server_static_t define for apiproxy
#include "APIProxy.h"

extern cldll_func_t	cl_funcs;
extern cl_enginefunc_t cl_engsrcProxies;
extern cl_enginefunc_dst_t g_engdstAddrs;

// Module exports
extern modfuncs_t g_modfuncs;
extern module_t	g_module;

// Macros for exported engine funcs
#define RecEngSPR_Load(a)					(g_engdstAddrs.pfnSPR_Load(&a))
#define RecEngSPR_Frames(a)					(g_engdstAddrs.pfnSPR_Frames(&a))
#define RecEngSPR_Height(a, b)				(g_engdstAddrs.pfnSPR_Height(&a, &b))
#define RecEngSPR_Width(a, b)				(g_engdstAddrs.pfnSPR_Width(&a, &b))
#define RecEngSPR_Set(a, b, c, d)			(g_engdstAddrs.pfnSPR_Set(&a, &b, &c, &d))
#define RecEngSPR_Draw(a, b, c, d)			(g_engdstAddrs.pfnSPR_Draw(&a, &b, &c, &d))
#define RecEngSPR_DrawHoles(a, b, c, d)		(g_engdstAddrs.pfnSPR_DrawHoles(&a, &b, &c, &d))
#define RecEngSPR_DrawAdditive(a, b, c, d)	(g_engdstAddrs.pfnSPR_DrawAdditive(&a, &b, &c, &d))
#define RecEngSPR_EnableScissor(a, b, c, d)	(g_engdstAddrs.pfnSPR_EnableScissor(&a, &b, &c, &d))
#define RecEngSPR_DisableScissor()			(g_engdstAddrs.pfnSPR_DisableScissor())
#define RecEngSPR_GetList(a, b)				(g_engdstAddrs.pfnSPR_GetList(&a, &b))
#define RecEngDraw_FillRGBA(a, b, c, d, e, f, g, h)		(g_engdstAddrs.pfnFillRGBA(&a, &b, &c, &d, &e, &f, &g, &h))
#define RecEnghudGetScreenInfo(a)			(g_engdstAddrs.pfnGetScreenInfo(&a))
#define RecEngSetCrosshair(a, b, c, d, e)	(g_engdstAddrs.pfnSetCrosshair(&a, &b, &c, &d, &e))
#define RecEnghudRegisterVariable(a, b, c)	(g_engdstAddrs.pfnRegisterVariable(&a, &b, &c))
#define RecEnghudGetCvarFloat(a)			(g_engdstAddrs.pfnGetCvarFloat(&a))
#define RecEnghudGetCvarString(a)			(g_engdstAddrs.pfnGetCvarString(&a))
#define RecEnghudAddCommand(a, b)			(g_engdstAddrs.pfnAddCommand(&a, &b))
#define RecEnghudHookUserMsg(a, b)			(g_engdstAddrs.pfnHookUserMsg(&a, &b))
#define RecEnghudServerCmd(a)				(g_engdstAddrs.pfnServerCmd(&a))
#define RecEnghudClientCmd(a)				(g_engdstAddrs.pfnClientCmd(&a))
#define RecEngPrimeMusicStream(a, b)	(g_engdstAddrs.pfnPrimeMusicStream(&a, &b))
#define RecEnghudGetPlayerInfo(a, b)		(g_engdstAddrs.pfnGetPlayerInfo(&a, &b))
#define RecEnghudPlaySoundByName(a, b)		(g_engdstAddrs.pfnPlaySoundByName(&a, &b))
#define RecEnghudPlaySoundByNameAtPitch(a, b, c)	(g_engdstAddrs.pfnPlaySoundByNameAtPitch(&a, &b, &c))
#define RecEnghudPlaySoundVoiceByName(a, b)	(g_engdstAddrs.pfnPlaySoundVoiceByName(&a, &b))
#define RecEnghudPlaySoundByIndex(a, b)		(g_engdstAddrs.pfnPlaySoundByIndex(&a, &b))
#define RecEngAngleVectors(a, b, c, d)		(g_engdstAddrs.pfnAngleVectors(&a, &b, &c, &d))
#define RecEngTextMessageGet(a)				(g_engdstAddrs.pfnTextMessageGet(&a))
#define RecEngTextMessageDrawCharacter(a, b, c, d, e, f)	(g_engdstAddrs.pfnDrawCharacter(&a, &b, &c, &d, &e, &f))
#define RecEngDrawConsoleString(a, b, c)	(g_engdstAddrs.pfnDrawConsoleString(&a, &b, &c))
#define RecEngDrawSetTextColor(a, b, c)		(g_engdstAddrs.pfnDrawSetTextColor(&a, &b, &c))
#define RecEnghudDrawConsoleStringLen(a, b, c)	(g_engdstAddrs.pfnDrawConsoleStringLen(&a, &b, &c))
#define RecEnghudConsolePrint(a)			(g_engdstAddrs.pfnConsolePrint(&a))
#define RecEnghudCenterPrint(a)				(g_engdstAddrs.pfnCenterPrint(&a))
#define RecEnghudCenterX()					(g_engdstAddrs.GetWindowCenterX())
#define RecEnghudCenterY()					(g_engdstAddrs.GetWindowCenterY())
#define RecEnghudGetViewAngles(a)			(g_engdstAddrs.GetViewAngles(&a))
#define RecEnghudSetViewAngles(a)			(g_engdstAddrs.SetViewAngles(&a))
#define RecEnghudGetMaxClients()			(g_engdstAddrs.GetMaxClients())
#define RecEngCvar_SetValue(a, b)			(g_engdstAddrs.Cvar_SetValue(&a, &b))
#define RecEngCmd_Argc()					(g_engdstAddrs.Cmd_Argc())
#define RecEngCmd_Argv(a)					(g_engdstAddrs.Cmd_Argv(&a))
#define RecEngCon_Printf(a)					(g_engdstAddrs.Con_Printf(&a))
#define RecEngCon_DPrintf(a)				(g_engdstAddrs.Con_DPrintf(&a))
#define RecEngCon_NPrintf(a, b)				(g_engdstAddrs.Con_NPrintf(&a, &b))
#define RecEngCon_NXPrintf(a, b)			(g_engdstAddrs.Con_NXPrintf(&a, &b))
#define RecEnghudPhysInfo_ValueForKey(a)	(g_engdstAddrs.PhysInfo_ValueForKey(&a))
#define RecEnghudServerInfo_ValueForKey(a)	(g_engdstAddrs.ServerInfo_ValueForKey(&a))
#define RecEnghudGetClientMaxspeed()		(g_engdstAddrs.GetClientMaxspeed())
#define RecEnghudCheckParm(a, b)			(g_engdstAddrs.CheckParm(&a, &b))
#define RecEngKey_Event(a, b)				(g_engdstAddrs.Key_Event(&a, &b))
#define RecEnghudGetMousePosition(a, b)		(g_engdstAddrs.GetMousePosition(&a, &b))
#define RecEnghudIsNoClipping()				(g_engdstAddrs.IsNoClipping())
#define RecEnghudGetLocalPlayer()			(g_engdstAddrs.GetLocalPlayer())
#define RecEnghudGetViewModel()				(g_engdstAddrs.GetViewModel())
#define RecEnghudGetEntityByIndex(a)		(g_engdstAddrs.GetEntityByIndex(&a))
#define RecEnghudGetClientTime()			(g_engdstAddrs.GetClientTime())
#define RecEngV_CalcShake()					(g_engdstAddrs.V_CalcShake())
#define RecEngV_ApplyShake(a, b, c)			(g_engdstAddrs.V_ApplyShake(&a, &b, &c))
#define RecEngPM_PointContents(a, b)		(g_engdstAddrs.PM_PointContents(&a, &b))
#define RecEngPM_WaterEntity(a)				(g_engdstAddrs.PM_WaterEntity(&a))
#define RecEngPM_TraceLine(a, b, c, d, e)	(g_engdstAddrs.PM_TraceLine(&a, &b, &c, &d, &e))
#define RecEngCL_LoadModel(a, b)			(g_engdstAddrs.CL_LoadModel(&a, &b))
#define RecEngCL_CreateVisibleEntity(a, b)	(g_engdstAddrs.CL_CreateVisibleEntity(&a, &b))
#define RecEnghudGetSpritePointer(a)		(g_engdstAddrs.GetSpritePointer(&a))
#define RecEnghudPlaySoundByNameAtLocation(a, b, c)		(g_engdstAddrs.pfnPlaySoundByNameAtLocation(&a, &b, &c))
#define RecEnghudPrecacheEvent(a, b)		(g_engdstAddrs.pfnPrecacheEvent(&a, &b))
#define RecEnghudPlaybackEvent(a, b, c, d, e, f, g, h, i, j, k, l)	(g_engdstAddrs.pfnPlaybackEvent(&a, &b, &c, &d, &e, &f, &g, &h, &i, &j, &k, &l))
#define RecEnghudWeaponAnim(a, b)			(g_engdstAddrs.pfnWeaponAnim(&a, &b))
#define RecEngRandomFloat(a, b)				(g_engdstAddrs.pfnRandomFloat(&a, &b))
#define RecEngRandomLong(a, b)				(g_engdstAddrs.pfnRandomLong(&a, &b))
#define RecEngCL_HookEvent(a, b)			(g_engdstAddrs.pfnHookEvent(&a, &b))
#define RecEngCon_IsVisible()				(g_engdstAddrs.Con_IsVisible())
#define RecEnghudGetGameDir()				(g_engdstAddrs.pfnGetGameDirectory())
#define RecEngCvar_FindVar(a)				(g_engdstAddrs.pfnGetCvarPointer(&a))
#define RecEngKey_NameForBinding(a)			(g_engdstAddrs.Key_LookupBinding(&a))
#define RecEnghudGetLevelName()				(g_engdstAddrs.pfnGetLevelName())
#define RecEnghudGetScreenFade(a)			(g_engdstAddrs.pfnGetScreenFade(&a))
#define RecEnghudSetScreenFade(a)			(g_engdstAddrs.pfnSetScreenFade(&a))
#define RecEngVGuiWrap_GetPanel()			(g_engdstAddrs.VGui_GetPanel())
#define RecEngVGui_ViewportPaintBackground(a)	(g_engdstAddrs.VGui_ViewportPaintBackground(&a))
#define RecEngCOM_LoadFile(a, b, c)			(g_engdstAddrs.COM_LoadFile(&a, &b, &c))
#define RecEngCOM_ParseFile(a, b)			(g_engdstAddrs.COM_ParseFile(&a, &b))
#define RecEngCOM_FreeFile(a)				(g_engdstAddrs.COM_FreeFile(&a))
#define RecEngCL_IsSpectateOnly()			(g_engdstAddrs.IsSpectateOnly())
#define RecEngR_LoadMapSprite(a)			(g_engdstAddrs.LoadMapSprite(&a))
#define RecEngCOM_AddAppDirectoryToSearchPath(a, b)		(g_engdstAddrs.COM_AddAppDirectoryToSearchPath(&a, &b))
#define RecEngClientDLL_ExpandFileName(a, b, c)		(g_engdstAddrs.COM_ExpandFilename(&a, &b, &c))
#define RecEngPlayerInfo_ValueForKey(a, b)	(g_engdstAddrs.PlayerInfo_ValueForKey(&a, &b))
#define RecEngPlayerInfo_SetValueForKey(a, b)		(g_engdstAddrs.PlayerInfo_SetValueForKey(&a, &b))
#define RecEngGetPlayerUniqueID(a, b)		(g_engdstAddrs.GetPlayerUniqueID(&a, &b))
#define RecEngGetTrackerIDForPlayer(a)		(g_engdstAddrs.GetTrackerIDForPlayer(&a))
#define RecEngGetPlayerForTrackerID(a)		(g_engdstAddrs.GetPlayerForTrackerID(&a))
#define RecEnghudServerCmdUnreliable(a)		(g_engdstAddrs.pfnServerCmdUnreliable(&a))
#define RecEngGetMousePos(a)				(g_engdstAddrs.pfnGetMousePos(&a))
#define RecEngSetMousePos(a, b)				(g_engdstAddrs.pfnSetMousePos(&a, &b))
#define RecEngSetMouseEnable(a)				(g_engdstAddrs.pfnSetMouseEnable(&a))
#define RecEngSetFilterMode(a)				(g_engdstAddrs.pfnSetFilterMode(&a))
#define RecEngSetFilterColor(a,b,c)			(g_engdstAddrs.pfnSetFilterColor(&a,&b,&c))
#define RecEngSetFilterBrightness(a)		(g_engdstAddrs.pfnSetFilterBrightness(&a))
#define RecEngSequenceGet(a,b)				(g_engdstAddrs.pfnSequenceGet(&a,&b))
#define RecEngSPR_DrawGeneric(a,b,c,d,e,f,g,h)	(g_engdstAddrs.pfnSPR_DrawGeneric(&a, &b, &c, &d, &e, &f, &g, &h))
#define RecEngSequencePickSentence(a,b,c)	(g_engdstAddrs.pfnSequencePickSentence(&a, &b, &c))
#define RecEngLocalPlayerInfo_ValueForKey(a)	(g_engdstAddrs.LocalPlayerInfo_ValueForKey(&a))
#define RecEngProcessTutorMessageDecayBuffer(a, b)		(g_engdstAddrs.pfnProcessTutorMessageDecayBuffer(&a, &b))
#define RecEngConstructTutorMessageDecayBuffer(a, b)	(g_engdstAddrs.pfnConstructTutorMessageDecayBuffer(&a, &b))
#define RecEngResetTutorMessageDecayBuffer()		(g_engdstAddrs.pfnResetTutorMessageDecayBuffer())
#define RecEngDraw_FillRGBABlend(a, b, c, d, e, f, g, h)		(g_engdstAddrs.pfnFillRGBABlend(&a, &b, &c, &d, &e, &f, &g, &h))

// Dummy destination function for use when there's no security module
extern void NullDst(void);

// Use this to init an engdst structure to point to NullDst
#define k_engdstNull \
{ \
	(pfnEngDst_pfnSPR_Load_t)						NullDst, \
	(pfnEngDst_pfnSPR_Frames_t)						NullDst, \
	(pfnEngDst_pfnSPR_Height_t)						NullDst, \
	(pfnEngDst_pfnSPR_Width_t)						NullDst, \
	(pfnEngDst_pfnSPR_Set_t)						NullDst, \
	(pfnEngDst_pfnSPR_Draw_t)						NullDst, \
	(pfnEngDst_pfnSPR_DrawHoles_t)					NullDst, \
	(pfnEngDst_pfnSPR_DrawAdditive_t)				NullDst, \
	(pfnEngDst_pfnSPR_EnableScissor_t)				NullDst, \
	(pfnEngDst_pfnSPR_DisableScissor_t)				NullDst, \
	(pfnEngDst_pfnSPR_GetList_t)					NullDst, \
	(pfnEngDst_pfnFillRGBA_t)						NullDst, \
	(pfnEngDst_pfnGetScreenInfo_t)					NullDst, \
	(pfnEngDst_pfnSetCrosshair_t)					NullDst, \
	(pfnEngDst_pfnRegisterVariable_t)				NullDst, \
	(pfnEngDst_pfnGetCvarFloat_t)					NullDst, \
	(pfnEngDst_pfnGetCvarString_t)					NullDst, \
	(pfnEngDst_pfnAddCommand_t)						NullDst, \
	(pfnEngDst_pfnHookUserMsg_t)					NullDst, \
	(pfnEngDst_pfnServerCmd_t)						NullDst, \
	(pfnEngDst_pfnClientCmd_t)						NullDst, \
	(pfnEngDst_pfnGetPlayerInfo_t)					NullDst, \
	(pfnEngDst_pfnPlaySoundByName_t)				NullDst, \
	(pfnEngDst_pfnPlaySoundByIndex_t)				NullDst, \
	(pfnEngDst_pfnAngleVectors_t)					NullDst, \
	(pfnEngDst_pfnTextMessageGet_t)					NullDst, \
	(pfnEngDst_pfnDrawCharacter_t)					NullDst, \
	(pfnEngDst_pfnDrawConsoleString_t)				NullDst, \
	(pfnEngDst_pfnDrawSetTextColor_t)				NullDst, \
	(pfnEngDst_pfnDrawConsoleStringLen_t)			NullDst, \
	(pfnEngDst_pfnConsolePrint_t)					NullDst, \
	(pfnEngDst_pfnCenterPrint_t)					NullDst, \
	(pfnEngDst_GetWindowCenterX_t)					NullDst, \
	(pfnEngDst_GetWindowCenterY_t)					NullDst, \
	(pfnEngDst_GetViewAngles_t)						NullDst, \
	(pfnEngDst_SetViewAngles_t)						NullDst, \
	(pfnEngDst_GetMaxClients_t)						NullDst, \
	(pfnEngDst_Cvar_SetValue_t)						NullDst, \
	(pfnEngDst_Cmd_Argc_t)							NullDst, \
	(pfnEngDst_Cmd_Argv_t)							NullDst, \
	(pfnEngDst_Con_Printf_t)						NullDst, \
	(pfnEngDst_Con_DPrintf_t)						NullDst, \
	(pfnEngDst_Con_NPrintf_t)						NullDst, \
	(pfnEngDst_Con_NXPrintf_t)						NullDst, \
	(pfnEngDst_PhysInfo_ValueForKey_t)				NullDst, \
	(pfnEngDst_ServerInfo_ValueForKey_t)			NullDst, \
	(pfnEngDst_GetClientMaxspeed_t)					NullDst, \
	(pfnEngDst_CheckParm_t)							NullDst, \
	(pfnEngDst_Key_Event_t)							NullDst, \
	(pfnEngDst_GetMousePosition_t)					NullDst, \
	(pfnEngDst_IsNoClipping_t)						NullDst, \
	(pfnEngDst_GetLocalPlayer_t)					NullDst, \
	(pfnEngDst_GetViewModel_t)						NullDst, \
	(pfnEngDst_GetEntityByIndex_t)					NullDst, \
	(pfnEngDst_GetClientTime_t)						NullDst, \
	(pfnEngDst_V_CalcShake_t)						NullDst, \
	(pfnEngDst_V_ApplyShake_t)						NullDst, \
	(pfnEngDst_PM_PointContents_t)					NullDst, \
	(pfnEngDst_PM_WaterEntity_t)					NullDst, \
	(pfnEngDst_PM_TraceLine_t)						NullDst, \
	(pfnEngDst_CL_LoadModel_t)						NullDst, \
	(pfnEngDst_CL_CreateVisibleEntity_t)			NullDst, \
	(pfnEngDst_GetSpritePointer_t)					NullDst, \
	(pfnEngDst_pfnPlaySoundByNameAtLocation_t)		NullDst, \
	(pfnEngDst_pfnPrecacheEvent_t)					NullDst, \
	(pfnEngDst_pfnPlaybackEvent_t)					NullDst, \
	(pfnEngDst_pfnWeaponAnim_t)						NullDst, \
	(pfnEngDst_pfnRandomFloat_t)					NullDst, \
	(pfnEngDst_pfnRandomLong_t)						NullDst, \
	(pfnEngDst_pfnHookEvent_t)						NullDst, \
	(pfnEngDst_Con_IsVisible_t)						NullDst, \
	(pfnEngDst_pfnGetGameDirectory_t)				NullDst, \
	(pfnEngDst_pfnGetCvarPointer_t)					NullDst, \
	(pfnEngDst_Key_LookupBinding_t)					NullDst, \
	(pfnEngDst_pfnGetLevelName_t)					NullDst, \
	(pfnEngDst_pfnGetScreenFade_t)					NullDst, \
	(pfnEngDst_pfnSetScreenFade_t)					NullDst, \
	(pfnEngDst_VGui_GetPanel_t)						NullDst, \
	(pfnEngDst_VGui_ViewportPaintBackground_t)		NullDst, \
	(pfnEngDst_COM_LoadFile_t)						NullDst, \
	(pfnEngDst_COM_ParseFile_t)						NullDst, \
	(pfnEngDst_COM_FreeFile_t)						NullDst, \
	NULL, \
	NULL, \
	NULL, \
	NULL, \
	NULL, \
	NULL, \
	(pfnEngDst_IsSpectateOnly_t)					NullDst, \
	(pfnEngDst_LoadMapSprite_t)						NullDst, \
	(pfnEngDst_COM_AddAppDirectoryToSearchPath_t)	NullDst, \
	(pfnEngDst_COM_ExpandFilename_t)				NullDst, \
	(pfnEngDst_PlayerInfo_ValueForKey_t)			NullDst, \
	(pfnEngDst_PlayerInfo_SetValueForKey_t)			NullDst, \
	(pfnEngDst_GetPlayerUniqueID_t)					NullDst, \
	(pfnEngDst_GetTrackerIDForPlayer_t)				NullDst, \
	(pfnEngDst_GetPlayerForTrackerID_t)				NullDst, \
	(pfnEngDst_pfnServerCmdUnreliable_t)			NullDst, \
	(pfnEngDst_GetMousePos_t)						NullDst, \
	(pfnEngDst_SetMousePos_t)						NullDst, \
	(pfnEngDst_SetMouseEnable_t)					NullDst, \
	(pfnEngDst_pfnSetFilterMode_t)					NullDst, \
	(pfnEngDst_pfnSetFilterColor_t)					NullDst, \
	(pfnEngDst_pfnSetFilterBrightness_t)			NullDst, \
	(pfnEngDst_pfnSequenceGet_t)					NullDst, \
	(pfnEngDst_pfnSPR_DrawGeneric_t)				NullDst, \
	(pfnEngDst_pfnSequencePickSentence_t)			NullDst, \
	(pfnEngDst_pfnDrawString_t)						NullDst, \
	(pfnEngDst_pfnDrawStringReverse_t)				NullDst, \
	(pfnEngDst_LocalPlayerInfo_ValueForKey_t)		NullDst, \
	(pfnEngDst_pfnVGUI2DrawCharacter_t)			NullDst, \
	(pfnEngDst_pfnVGUI2DrawCharacterAdd_t)	NullDst, \
	(pfnEngDst_pfnPlaySoundVoiceByName_t)		NullDst, \
	(pfnEngDst_pfnPrimeMusicStream_t)				NullDst, \
	(pfnEngDst_pfnProcessTutorMessageDecayBuffer_t)	NullDst, \
	(pfnEngDst_pfnConstructTutorMessageDecayBuffer_t)	NullDst, \
	(pfnEngDst_pfnResetTutorMessageDecayData_t) NullDst, \
	(pfnEngDst_pfnPlaySoundByNameAtPitch_t)			NullDst, \
	(pfnEngDst_pfnFillRGBABlend_t)						NullDst, \
	(pfnEngDst_pfnGetAppID_t)						NullDst, \
	(pfnEngDst_pfnGetAliases_t)						NullDst, \
	(pfnEngDst_pfnVguiWrap2_GetMouseDelta_t)		NullDst, \
};

// Use this to init a cldll_func_dst structure to point to NullDst
#define k_cldstNull \
{ \
	(DST_INITIALIZE_FUNC)				NullDst, \
	(DST_HUD_INIT_FUNC)					NullDst, \
	(DST_HUD_VIDINIT_FUNC)				NullDst, \
	(DST_HUD_REDRAW_FUNC)				NullDst, \
	(DST_HUD_UPDATECLIENTDATA_FUNC)		NullDst, \
	(DST_HUD_RESET_FUNC)				NullDst, \
	(DST_HUD_CLIENTMOVE_FUNC)			NullDst, \
	(DST_HUD_CLIENTMOVEINIT_FUNC)		NullDst, \
	(DST_HUD_TEXTURETYPE_FUNC)			NullDst, \
	(DST_HUD_IN_ACTIVATEMOUSE_FUNC)		NullDst, \
	(DST_HUD_IN_DEACTIVATEMOUSE_FUNC)	NullDst, \
	(DST_HUD_IN_MOUSEEVENT_FUNC)		NullDst, \
	(DST_HUD_IN_CLEARSTATES_FUNC)		NullDst, \
	(DST_HUD_IN_ACCUMULATE_FUNC)		NullDst, \
	(DST_HUD_CL_CREATEMOVE_FUNC)		NullDst, \
	(DST_HUD_CL_ISTHIRDPERSON_FUNC)		NullDst, \
	(DST_HUD_CL_GETCAMERAOFFSETS_FUNC)	NullDst, \
	(DST_HUD_KB_FIND_FUNC)				NullDst, \
	(DST_HUD_CAMTHINK_FUNC)				NullDst, \
	(DST_HUD_CALCREF_FUNC)				NullDst, \
	(DST_HUD_ADDENTITY_FUNC)			NullDst, \
	(DST_HUD_CREATEENTITIES_FUNC)		NullDst, \
	(DST_HUD_DRAWNORMALTRIS_FUNC)		NullDst, \
	(DST_HUD_DRAWTRANSTRIS_FUNC)		NullDst, \
	(DST_HUD_STUDIOEVENT_FUNC)			NullDst, \
	(DST_HUD_POSTRUNCMD_FUNC)			NullDst, \
	(DST_HUD_SHUTDOWN_FUNC)				NullDst, \
	(DST_HUD_TXFERLOCALOVERRIDES_FUNC)	NullDst, \
	(DST_HUD_PROCESSPLAYERSTATE_FUNC)	NullDst, \
	(DST_HUD_TXFERPREDICTIONDATA_FUNC)	NullDst, \
	(DST_HUD_DEMOREAD_FUNC)				NullDst, \
	(DST_HUD_CONNECTIONLESS_FUNC)		NullDst, \
	(DST_HUD_GETHULLBOUNDS_FUNC)		NullDst, \
	(DST_HUD_FRAME_FUNC)				NullDst, \
	(DST_HUD_KEY_EVENT_FUNC)			NullDst, \
	(DST_HUD_TEMPENTUPDATE_FUNC)		NullDst, \
	(DST_HUD_GETUSERENTITY_FUNC)		NullDst, \
	(DST_HUD_VOICESTATUS_FUNC)			NullDst, \
	(DST_HUD_DIRECTORMESSAGE_FUNC)		NullDst, \
	(DST_HUD_STUDIO_INTERFACE_FUNC)		NullDst, \
	(DST_HUD_CHATINPUTPOSITION_FUNC)	NullDst, \
	(DST_HUD_GETPLAYERTEAM)				NullDst, \
}

#ifdef __cplusplus
}
#endif

#endif // CDLL_INT_H
	
```

`halflife/engine/cl_entity.h`:

```h
/***
*
*	Copyright (c) 1999, 2000, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
// cl_entity.h
#if !defined( CL_ENTITYH )
#define CL_ENTITYH
#ifdef _WIN32
#pragma once
#endif

typedef struct efrag_s
{
	struct mleaf_s		*leaf;
	struct efrag_s		*leafnext;
	struct cl_entity_s	*entity;
	struct efrag_s		*entnext;
} efrag_t;

typedef struct
{
	byte					mouthopen;		// 0 = mouth closed, 255 = mouth agape
	byte					sndcount;		// counter for running average
	int						sndavg;			// running average
} mouth_t;

typedef struct
{
	float					prevanimtime;  
	float					sequencetime;
	byte					prevseqblending[2];
	vec3_t					prevorigin;
	vec3_t					prevangles;

	int						prevsequence;
	float					prevframe;

	byte					prevcontroller[4];
	byte					prevblending[2];
} latchedvars_t;

typedef struct
{
	// Time stamp for this movement
	float					animtime;

	vec3_t					origin;
	vec3_t					angles;
} position_history_t;

typedef struct cl_entity_s cl_entity_t;

#define HISTORY_MAX		64  // Must be power of 2
#define HISTORY_MASK	( HISTORY_MAX - 1 )


#if !defined( ENTITY_STATEH )
#include "entity_state.h"
#endif

#if !defined( PROGS_H )
#include "progs.h"
#endif

struct cl_entity_s
{
	int						index;      // Index into cl_entities ( should match actual slot, but not necessarily )

	qboolean				player;     // True if this entity is a "player"
	
	entity_state_t			baseline;   // The original state from which to delta during an uncompressed message
	entity_state_t			prevstate;  // The state information from the penultimate message received from the server
	entity_state_t			curstate;   // The state information from the last message received from server

	int						current_position;  // Last received history update index
	position_history_t		ph[ HISTORY_MAX ];   // History of position and angle updates for this player

	mouth_t					mouth;			// For synchronizing mouth movements.

	latchedvars_t			latched;		// Variables used by studio model rendering routines

	// Information based on interplocation, extrapolation, prediction, or just copied from last msg received.
	//
	float					lastmove;

	// Actual render position and angles
	vec3_t					origin;
	vec3_t					angles;

	// Attachment points
	vec3_t					attachment[4];

	// Other entity local information
	int						trivial_accept;

	struct model_s			*model;			// cl.model_precache[ curstate.modelindes ];  all visible entities have a model
	struct efrag_s			*efrag;			// linked list of efrags
	struct mnode_s			*topnode;		// for bmodels, first world node that splits bmodel, or NULL if not split

	float					syncbase;		// for client-side animations -- used by obsolete alias animation system, remove?
	int						visframe;		// last frame this entity was found in an active leaf
	colorVec				cvFloorColor;
};

#endif // !CL_ENTITYH
```

`halflife/engine/client.h`:

```h
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/

#pragma once

//#include "maintypes.h"
#include "common.h"
#include "custom.h"
#include "../common/cl_entity.h"
#include "consistency.h"
#include "delta_packet.h"
//#include "dlight.h"
#include "../common/entity_state.h"
#include "event.h"
//#include "info.h"
#include "net.h"
//#include "keys.h"
#include "sound.h"
#include "../common/screenfade.h"
#include "../common/usercmd.h"
#include "model.h"
//#include "kbutton.h"

const int MAX_DEMOS = 32;

typedef enum cactive_e
{
	ca_dedicated,
	ca_disconnected,
	ca_connecting,
	ca_connected,
	ca_uninitialized,
	ca_active,
} cactive_t;

typedef struct runcmd_s
{
	usercmd_t cmd;
	float senttime;
	float receivedtime;
	float frame_lerp;
	qboolean processedfuncs;
	qboolean heldback;
	int sendsize;
} runcmd_t;

typedef struct frame_s
{
	double receivedtime;
	double latency;
	qboolean invalid;
	qboolean choked;
	entity_state_t playerstate[32];
	double time;
	clientdata_t clientdata;
	weapon_data_t weapondata[64];
	packet_entities_t packet_entities;
	uint16 clientbytes;
	uint16 playerinfobytes;
	uint16 packetentitybytes;
	uint16 tentitybytes;
	uint16 soundbytes;
	uint16 eventbytes;
	uint16 usrbytes;
	uint16 voicebytes;
	uint16 msgbytes;
} frame_t;

/*typedef struct player_info_s
{
	int userid;
	char userinfo[MAX_INFO_STRING];
	char name[MAX_SCOREBOARDNAME];
	int spectator;
	int ping;
	int packet_loss;
	char model[MAX_QPATH];
	int topcolor;
	int bottomcolor;
	int renderframe;
	int gaitsequence;
	float gaitframe;
	float gaityaw;
	Vector prevgaitorigin;
	customization_t customdata;
	char hashedcdkey[16];
	uint64 m_nSteamID;
} player_info_t;*/

typedef struct soundfade_s
{
	int nStartPercent;
	int nClientSoundFadePercent;
	double soundFadeStartTime;
	int soundFadeOutTime;
	int soundFadeHoldTime;
	int soundFadeInTime;
} soundfade_t;

typedef FILE * FileHandle_t;

typedef struct client_static_s
{
	cactive_t state;
	netchan_t netchan;
	sizebuf_t datagram;
	byte datagram_buf[MAX_DATAGRAM];
	double connect_time;
	int connect_retry;
	int challenge;
	byte authprotocol;
	int userid;
	char trueaddress[32];
	float slist_time;
	int signon;
	char servername[MAX_PATH];
	char mapstring[64];
	char spawnparms[2048];
	char userinfo[256];
	float nextcmdtime;
	int lastoutgoingcommand;
	int demonum;
	char demos[MAX_DEMOS][16];
	qboolean demorecording;
	qboolean demoplayback;
	qboolean timedemo;
	float demostarttime;
	int demostartframe;
	int forcetrack;
	FileHandle_t demofile;
	FileHandle_t demoheader;
	qboolean demowaiting;
	qboolean demoappending;
	char demofilename[MAX_PATH];
	int demoframecount;
	int td_lastframe;
	int td_startframe;
	float td_starttime;
	incomingtransfer_t dl;
	float packet_loss;
	double packet_loss_recalc_time;
	int playerbits;
	soundfade_t soundfade;
	char physinfo[MAX_PHYSINFO_STRING];
	unsigned char md5_clientdll[16];
	netadr_t game_stream;
	netadr_t connect_stream;
	qboolean passive;
	qboolean spectator;
	qboolean director;
	qboolean fSecureClient;
	qboolean isVAC2Secure;
	uint64_t GameServerSteamID;
	int build_num;
} client_static_t;

typedef struct client_state_s
{
	int max_edicts;
	resource_t resourcesonhand;
	resource_t resourcesneeded;
	resource_t resourcelist[1280];
	int num_resources;
	qboolean need_force_consistency_response;
	char serverinfo[512];
	int servercount;
	int validsequence;
	int parsecount;
	int parsecountmod;
	int stats[32];
	int weapons;
	usercmd_t cmd;
	Vector viewangles;
	Vector punchangle;
	Vector crosshairangle;
	Vector simorg;
	Vector simvel;
	Vector simangles;
	Vector predicted_origins[64];
	Vector prediction_error;
	float idealpitch;
	Vector viewheight;
	screenfade_t sf;
	qboolean paused;
	int onground;
	int moving;
	int waterlevel;
	int usehull;
	float maxspeed;
	int pushmsec;
	int light_level;
	int intermission;
	double mtime[2];
	double time;
	double oldtime;
	frame_t frames[64];
	runcmd_t commands[64];
	local_state_t predicted_frames[64];
	int delta_sequence;
	int playernum;
	event_t event_precache[256];
	model_t *model_precache[(1 << 9)];
	int model_precache_count;
	sfx_s *sound_precache[(1 << 9)];
	consistency_t consistency_list[MAX_CONSISTENCY_LIST];
	int num_consistency;
	int highentity;
	char levelname[40];
	int maxclients;
	int gametype;
	int viewentity;
	model_t *worldmodel;
	efrag_t *free_efrags;
	int num_entities;
	int num_statics;
	cl_entity_t viewent;
	int cdtrack;
	int looptrack;
	CRC32_t serverCRC;
	unsigned char clientdllmd5[16];
	float weaponstarttime;
	int weaponsequence;
	int fPrecaching;
	dlight_t *pLight;
	player_info_t players[32];
	entity_state_t instanced_baseline[64];
	int instanced_baseline_number;
	CRC32_t mapCRC;
	event_state_t events;
	char downloadUrl[128];
} client_state_t;

typedef enum CareerStateType_e
{
	CAREER_NONE = 0,
	CAREER_LOADING = 1,
	CAREER_PLAYING = 2,
} CareerStateType;

/*extern keydest_t key_dest;
extern client_static_t *cls;
extern client_state_t *cl;

extern playermove_t g_clmove;
extern qboolean cl_inmovie;

extern cvar_t cl_name;
extern cvar_t rate_;
extern cvar_t console;

void CL_RecordHUDCommand(const char *cmdname);
void R_DecalRemoveAll(int textureIndex);
void CL_CheckForResend();
qboolean CL_CheckFile(sizebuf_t *msg, char *filename);
void CL_ClearClientState();
void CL_Connect_f();
void CL_DecayLights();
void CL_Disconnect();
void CL_Disconnect_f();
void CL_EmitEntities();
void CL_InitClosest();
void CL_Init();
void CL_Particle(vec_t *origin, int color, float life, int zpos, int zvel);
void CL_PredictMove(qboolean repredicting);
void CL_PrintLogos();
void CL_ReadPackets();
qboolean CL_RequestMissingResources();
void CL_Move();
void CL_SendConnectPacket();
void CL_StopPlayback();
void CL_UpdateSoundFade();
void CL_AdjustClock();
void CL_Save(const char *name);
void CL_HudMessage(const char *pMessage);

int Key_CountBindings();
void Key_WriteBindings(FileHandle_t f);
extern "C" void ClientDLL_UpdateClientData();
extern "C" void ClientDLL_HudVidInit();
void Chase_Init();
void Key_Init();
extern "C" void ClientDLL_Init();
void Con_Shutdown();
int DispatchDirectUserMsg(const char *pszName, int iSize, void *pBuf);
void CL_ShutDownUsrMessages();
void CL_ShutDownClientStatic();
extern "C" void ClientDLL_MoveClient(struct playermove_s *ppmove);
void CL_Shutdown();
extern "C" void ClientDLL_Frame(double time);
extern "C" void ClientDLL_CAM_Think();
void CL_InitEventSystem();
void CL_CheckClientState();
void CL_RedoPrediction();
void CL_SetLastUpdate();
void Con_NPrintf(int idx, const char *fmt, ...);
void CL_WriteMessageHistory(int starting_count, int cmd);
void CL_MoveSpectatorCamera();
void CL_AddVoiceToDatagram(qboolean bFinal);
void CL_VoiceIdle();
void PollDInputDevices();
void CL_KeepConnectionActive();
void CL_UpdateModuleC();
void ConstructTutorMessageDecayBuffer(int *buffer, int bufferLength);
void ProcessTutorMessageDecayBuffer(int *buffer, int bufferLength);
int GetTimesTutorMessageShown(int id);
void RegisterTutorMessageShown(int mid);
void ResetTutorMessageDecayData();
void SetCareerAudioState(int state);

int EXT_FUNC VGuiWrap2_IsInCareerMatch();
int EXT_FUNC VGuiWrap2_GetLocalizedStringLength(const char *label);
void VGuiWrap2_LoadingStarted(const char *resourceType, const char *resourceName);
void *VguiWrap2_GetCareerUI();
void VguiWrap2_GetMouseDelta(int *x, int *y);
int EXT_FUNC VGuiWrap2_GetLocalizedStringLength(const char *label);
int EXT_FUNC VGuiWrap2_IsInCareerMatch();
int VGuiWrap2_IsConsoleVisible();
int VGuiWrap2_Key_Event(int down, int keynum, const char *pszCurrentBinding);
int VGuiWrap2_GameUIKeyPressed();
int VGuiWrap2_IsGameUIVisible();
int VGuiWrap2_CallEngineSurfaceAppHandler(void *event, void *userData);
int VGuiWrap2_UseVGUI1();
void *VGuiWrap2_GetPanel();
void VGuiWrap2_NotifyOfServerConnect(const char *game, int IP, int port);
void VGuiWrap2_LoadingFinished(const char *resourceType, const char *resourceName);
void VGuiWrap2_LoadingStarted(const char *resourceType, const char *resourceName);
void VGuiWrap2_ConDPrintf(const char *msg);
void VGuiWrap2_Startup();
void VGuiWrap2_ConPrintf(const char *msg);
void VGuiWrap2_ClearConsole();
void VGuiWrap2_HideConsole();
void VGuiWrap2_ShowDemoPlayer();
void VGuiWrap2_ShowConsole();
void VGuiWrap2_HideGameUI();
void VGuiWrap2_NotifyOfServerDisconnect();
void VGuiWrap2_Paint();
void VGuiWrap2_SetVisible(int state);
void VGuiWrap2_GetMouse();
void VGuiWrap2_ReleaseMouse();
void VGuiWrap2_Shutdown();*/

```

`halflife/engine/common.h`:

```h
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/

#pragma once

#include "../common/const.h"
#include "../common/qlimits.h"
#include "bspfile.h"
//#include "FileSystem.h"
//#include "quakedef.h"
#include "../common/usercmd.h"
//#include "info.h"
#include "../common/com_model.h"

#define COM_TOKEN_LEN	1024

// Don't allow overflow
#define SIZEBUF_CHECK_OVERFLOW	0
#define SIZEBUF_ALLOW_OVERFLOW	BIT(0)
#define SIZEBUF_OVERFLOWED		BIT(1)

#define MAX_NUM_ARGVS			50
#define NUM_SAFE_ARGVS			7

#define COM_COPY_CHUNK_SIZE		1024
#define COM_MAX_CMD_LINE		256

typedef struct sizebuf_s
{
	const char *buffername;
	uint16 flags;
	byte *data;
	int maxsize;
	int cursize;
} sizebuf_t;

typedef struct downloadtime_s
{
	qboolean bUsed;
	float fTime;
	int nBytesRemaining;
} downloadtime_t;

typedef struct incomingtransfer_s
{
	qboolean doneregistering;
	int percent;
	qboolean downloadrequested;
	downloadtime_t rgStats[8];
	int nCurStat;
	int nTotalSize;
	int nTotalToTransfer;
	int nRemainingToTransfer;
	float fLastStatusUpdate;
	qboolean custom;
} incomingtransfer_t;

/*extern char serverinfo[MAX_INFO_STRING];

extern char gpszVersionString[32];
extern char gpszProductString[32];

typedef struct bf_read_s bf_read_t;
typedef struct bf_write_s bf_write_t;

extern bf_read_t bfread;
extern bf_write_t bfwrite;

extern int msg_badread;
extern int msg_readcount;

extern qboolean bigendien;

extern short(*BigShort)(short l);
extern short(*LittleShort)(short l);
extern int(*BigLong)(int l);
extern int(*LittleLong)(int l);
extern float(*BigFloat)(float l);
extern float(*LittleFloat)(float l);

extern int com_argc;
extern char **com_argv;

extern char com_token[COM_TOKEN_LEN];

extern qboolean com_ignorecolons;
extern qboolean s_com_token_unget;
extern char com_clientfallback[MAX_PATH];
extern char com_gamedir[MAX_PATH];
extern char com_cmdline[COM_MAX_CMD_LINE];

extern cache_user_t *loadcache;
extern unsigned char *loadbuf;
extern int loadsize;

int build_number(void);
char *Info_Serverinfo(void);

unsigned char COM_Nibble(char c);
void COM_HexConvert(const char *pszInput, int nInputLength, unsigned char *pOutput);
NOXREF char *COM_BinPrintf(unsigned char *buf, int nLen);
void COM_ExplainDisconnection(qboolean bPrint, char *fmt, ...);
NOXREF void COM_ExtendedExplainDisconnection(qboolean bPrint, char *fmt, ...);

int LongSwap(int l);
short ShortSwap(short l);
short ShortNoSwap(short l);
int LongNoSwap(int l);
float FloatSwap(float f);
float FloatNoSwap(float f);

void MSG_WriteChar(sizebuf_t *sb, int c);
void MSG_WriteByte(sizebuf_t *sb, int c);
void MSG_WriteShort(sizebuf_t *sb, int c);
void MSG_WriteWord(sizebuf_t *sb, int c);
void MSG_WriteLong(sizebuf_t *sb, int c);
void MSG_WriteFloat(sizebuf_t *sb, float f);
void MSG_WriteString(sizebuf_t *sb, const char *s);
void MSG_WriteBuf(sizebuf_t *sb, int iSize, void *buf);
void MSG_WriteAngle(sizebuf_t *sb, float f);
void MSG_WriteHiresAngle(sizebuf_t *sb, float f);
void MSG_WriteUsercmd(sizebuf_t *buf, usercmd_t *to, usercmd_t *from);
void COM_BitOpsInit(void);
void MSG_WriteOneBit(int nValue);
void MSG_StartBitWriting(sizebuf_t *buf);
NOXREF qboolean MSG_IsBitWriting(void);
void MSG_EndBitWriting(sizebuf_t *buf);
void MSG_WriteBits(uint32 data, int numbits);
void MSG_WriteSBits(int data, int numbits);
void MSG_WriteBitString(const char *p);
void MSG_WriteBitData(void *src, int length);
void MSG_WriteBitAngle(float fAngle, int numbits);
float MSG_ReadBitAngle(int numbits);
int MSG_CurrentBit(void);
NOXREF qboolean MSG_IsBitReading(void);
void MSG_StartBitReading(sizebuf_t *buf);
void MSG_EndBitReading(sizebuf_t *buf);
int MSG_ReadOneBit(void);
uint32 MSG_ReadBits(int numbits);
NOXREF uint32 MSG_PeekBits(int numbits);
int MSG_ReadSBits(int numbits);
NOXREF char *MSG_ReadBitString(void);
int MSG_ReadBitData(void *dest, int length);
NOXREF float MSG_ReadBitCoord(void);
void MSG_WriteBitCoord(const float f);
NOXREF void MSG_ReadBitVec3Coord(vec3_t fa);
void MSG_WriteBitVec3Coord(const vec3_t fa);
NOXREF float MSG_ReadCoord(void);
void MSG_WriteCoord(sizebuf_t *sb, const float f);
NOXREF void MSG_ReadVec3Coord(sizebuf_t *sb, vec3_t fa);
NOXREF void MSG_WriteVec3Coord(sizebuf_t *sb, const vec3_t fa);
void MSG_BeginReading(void);
int MSG_ReadChar(void);
int MSG_ReadByte(void);
int MSG_ReadShort(void);
NOXREF int MSG_ReadWord(void);
int MSG_ReadLong(void);
NOXREF float MSG_ReadFloat(void);
int MSG_ReadBuf(int iSize, void *pbuf);
char *MSG_ReadString(void);
char *MSG_ReadStringLine(void);
NOXREF float MSG_ReadAngle(void);
NOXREF float MSG_ReadHiresAngle(void);
void MSG_ReadUsercmd(usercmd_t *to, usercmd_t *from);

void SZ_Alloc(const char *name, sizebuf_t *buf, int startsize);
void SZ_Clear(sizebuf_t *buf);
void *SZ_GetSpace(sizebuf_t *buf, int length);
void SZ_Write(sizebuf_t *buf, const void *data, int length);
void SZ_Print(sizebuf_t *buf, const char *data);

NOXREF char *COM_SkipPath(char *pathname);
void COM_StripExtension(char *in, char *out);
char *COM_FileExtension(char *in);
void COM_FileBase(const char *in, char *out);
void COM_DefaultExtension(char *path, char *extension);
void COM_UngetToken(void);
char *COM_Parse(char *data);
char *COM_ParseLine(char *data);
int COM_TokenWaiting(char *buffer);
int COM_CheckParm(const char *parm);
void COM_InitArgv(int argc, char *argv[]);
void COM_Init(char *basedir);
char *va(char *format, ...);
char *vstr(vec_t *v);
NOXREF int memsearch(unsigned char *start, int count, int search);
NOXREF void COM_WriteFile(char *filename, void *data, int len);
void COM_FixSlashes(char *pname);
void COM_CreatePath(char *path);
NOXREF void COM_CopyFile(char *netpath, char *cachepath);
NOXREF int COM_ExpandFilename(char *filename);
int COM_FileSize(const char *filename);
unsigned char *COM_LoadFile(const char *path, int usehunk, int *pLength);
void COM_FreeFile(void *buffer);
void COM_CopyFileChunk(FileHandle_t dst, FileHandle_t src, int nSize);
NOXREF unsigned char *COM_LoadFileLimit(char *path, int pos, int cbmax, int *pcbread, FileHandle_t *phFile);
unsigned char *COM_LoadHunkFile(char *path);
unsigned char *COM_LoadTempFile(char *path, int *pLength);
void COM_LoadCacheFile(char *path, struct cache_user_s *cu);
NOXREF unsigned char *COM_LoadStackFile(char *path, void *buffer, int bufsize, int *length);
void COM_Shutdown(void);
NOXREF void COM_AddAppDirectory(char *pszBaseDir, const char *appName);
void COM_AddDefaultDir(char *pszDir);
void COM_StripTrailingSlash(char *ppath);
void COM_ParseDirectoryFromCmd(const char *pCmdName, char *pDirName, const char *pDefault);
qboolean COM_SetupDirectories(void);
void COM_CheckPrintMap(dheader_t *header, const char *mapname, qboolean bShowOutdated);
void COM_ListMaps(char *pszSubString);
void COM_Log(char *pszFile, char *fmt, ...);
unsigned char *COM_LoadFileForMe(const char *filename, int *pLength);
int COM_CompareFileTime(char *filename1, char *filename2, int *iCompare);
void COM_GetGameDir(char *szGameDir);
int COM_EntsForPlayerSlots(int nPlayers);
void COM_NormalizeAngles(vec_t *angles);
void COM_Munge(unsigned char *data, int len, int seq);
void COM_UnMunge(unsigned char *data, int len, int seq);
void COM_Munge2(unsigned char *data, int len, int seq);
void COM_UnMunge2(unsigned char *data, int len, int seq);
void COM_Munge3(unsigned char *data, int len, int seq);
NOXREF void COM_UnMunge3(unsigned char *data, int len, int seq);
unsigned int COM_GetApproxWavePlayLength(const char *filepath);*/

```

`halflife/engine/consistency.h`:

```h
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/

#pragma once

const int MAX_CONSISTENCY_LIST = 512;

typedef struct consistency_s
{
	char *filename;
	int issound;
	int orig_index;
	int value;
	int check_type;
	float mins[3];
	float maxs[3];
} consistency_t;

```

`halflife/engine/customentity.h`:

```h
/***
*
*	Copyright (c) 1999, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef CUSTOMENTITY_H
#define CUSTOMENTITY_H

// Custom Entities

// Start/End Entity is encoded as 12 bits of entity index, and 4 bits of attachment (4:12)
#define BEAMENT_ENTITY(x)		((x)&0xFFF)
#define BEAMENT_ATTACHMENT(x)	(((x)>>12)&0xF)

// Beam types, encoded as a byte
enum 
{
	BEAM_POINTS = 0,
	BEAM_ENTPOINT,
	BEAM_ENTS,
	BEAM_HOSE,
};

#define BEAM_FSINE		0x10
#define BEAM_FSOLID		0x20
#define BEAM_FSHADEIN	0x40
#define BEAM_FSHADEOUT	0x80

#endif	//CUSTOMENTITY_H

```

`halflife/engine/delta_packet.h`:

```h
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/

#pragma once

#include "../common/entity_state.h"

typedef struct packet_entities_s
{
	int num_entities;
	unsigned char flags[32];
	entity_state_t *entities;
} packet_entities_t;

```

`halflife/engine/entity_state.h`:

```h
/***
*
*	Copyright (c) 1999, 2000, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined( ENTITY_STATEH )
#define ENTITY_STATEH
#ifdef _WIN32
#pragma once
#endif

// For entityType below
#define ENTITY_NORMAL		(1<<0)
#define ENTITY_BEAM			(1<<1)

// Entity state is used for the baseline and for delta compression of a packet of 
//  entities that is sent to a client.
typedef struct entity_state_s entity_state_t;

struct entity_state_s
{
// Fields which are filled in by routines outside of delta compression
	int			entityType;
	// Index into cl_entities array for this entity.
	int			number;      
	float		msg_time;

	// Message number last time the player/entity state was updated.
	int			messagenum;		

	// Fields which can be transitted and reconstructed over the network stream
	vec3_t		origin;
	vec3_t		angles;

	int			modelindex;
	int			sequence;
	float		frame;
	int			colormap;
	short		skin;
	short		solid;
	int			effects;
	float		scale;

	byte		eflags;
	
	// Render information
	int			rendermode;
	int			renderamt;
	color24		rendercolor;
	int			renderfx;

	int			movetype;
	float		animtime;
	float		framerate;
	int			body;
	byte		controller[4];
	byte		blending[4];
	vec3_t		velocity;

	// Send bbox down to client for use during prediction.
	vec3_t		mins;    
	vec3_t		maxs;

	int			aiment;
	// If owned by a player, the index of that player ( for projectiles ).
	int			owner; 

	// Friction, for prediction.
	float		friction;       
	// Gravity multiplier
	float		gravity;		

// PLAYER SPECIFIC
	int			team;
	int			playerclass;
	int			health;
	qboolean	spectator;  
	int         weaponmodel;
	int			gaitsequence;
	// If standing on conveyor, e.g.
	vec3_t		basevelocity;   
	// Use the crouched hull, or the regular player hull.
	int			usehull;		
	// Latched buttons last time state updated.
	int			oldbuttons;     
	// -1 = in air, else pmove entity number
	int			onground;		
	int			iStepLeft;
	// How fast we are falling
	float		flFallVelocity;  

	float		fov;
	int			weaponanim;

	// Parametric movement overrides
	vec3_t				startpos;
	vec3_t				endpos;
	float				impacttime;
	float				starttime;

	// For mods
	int			iuser1;
	int			iuser2;
	int			iuser3;
	int			iuser4;
	float		fuser1;
	float		fuser2;
	float		fuser3;
	float		fuser4;
	vec3_t		vuser1;
	vec3_t		vuser2;
	vec3_t		vuser3;
	vec3_t		vuser4;
};

#include "pm_info.h"

typedef struct clientdata_s
{
	vec3_t				origin;
	vec3_t				velocity;

	int					viewmodel;
	vec3_t				punchangle;
	int					flags;
	int					waterlevel;
	int					watertype;
	vec3_t				view_ofs;
	float				health;

	int					bInDuck;

	int					weapons; // remove?
	
	int					flTimeStepSound;
	int					flDuckTime;
	int					flSwimTime;
	int					waterjumptime;

	float				maxspeed;

	float				fov;
	int					weaponanim;

	int					m_iId;
	int					ammo_shells;
	int					ammo_nails;
	int					ammo_cells;
	int					ammo_rockets;
	float				m_flNextAttack;
	
	int					tfstate;

	int					pushmsec;

	int					deadflag;

	char				physinfo[ MAX_PHYSINFO_STRING ];

	// For mods
	int					iuser1;
	int					iuser2;
	int					iuser3;
	int					iuser4;
	float				fuser1;
	float				fuser2;
	float				fuser3;
	float				fuser4;
	vec3_t				vuser1;
	vec3_t				vuser2;
	vec3_t				vuser3;
	vec3_t				vuser4;
} clientdata_t;

#include "weaponinfo.h"

typedef struct local_state_s
{
	entity_state_t playerstate;
	clientdata_t   client;
	weapon_data_t  weapondata[ 32 ];
} local_state_t;

#endif // !ENTITY_STATEH
```

`halflife/engine/entity_types.h`:

```h
/***
*
*	Copyright (c) 1999, 2000, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
// entity_types.h
#if !defined( ENTITY_TYPESH )
#define ENTITY_TYPESH

#define ET_NORMAL		0
#define ET_PLAYER		1
#define ET_TEMPENTITY	2
#define ET_BEAM			3
// BMODEL or SPRITE that was split across BSP nodes
#define ET_FRAGMENTED	4

#endif // !ENTITY_TYPESH
```

`halflife/engine/event.h`:

```h
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/

#pragma once

typedef struct event_s
{
	unsigned short index;
	const char *filename;
	int filesize;
	const char *pszScript;
} event_t;

```

`halflife/engine/event_args.h`:

```h
/***
*
*	Copyright (c) 1999, 2000, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined( EVENT_ARGSH )
#define EVENT_ARGSH
#ifdef _WIN32
#pragma once
#endif

// Event was invoked with stated origin
#define FEVENT_ORIGIN	( 1<<0 )

// Event was invoked with stated angles
#define FEVENT_ANGLES	( 1<<1 )

typedef struct event_args_s
{
	int		flags;

	// Transmitted
	int		entindex;

	float	origin[3];
	float	angles[3];
	float	velocity[3];

	int		ducking;

	float	fparam1;
	float	fparam2;

	int		iparam1;
	int		iparam2;

	int		bparam1;
	int		bparam2;
} event_args_t;

#endif

```

`halflife/engine/event_flags.h`:

```h
/***
*
*	Copyright (c) 1999, 2000, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined( EVENT_FLAGSH )
#define EVENT_FLAGSH
#ifdef _WIN32
#pragma once
#endif

// Skip local host for event send.
#define FEV_NOTHOST		(1<<0)    

// Send the event reliably.  You must specify the origin and angles and use
// PLAYBACK_EVENT_FULL for this to work correctly on the server for anything
// that depends on the event origin/angles.  I.e., the origin/angles are not
// taken from the invoking edict for reliable events.
#define FEV_RELIABLE	(1<<1)	 

// Don't restrict to PAS/PVS, send this event to _everybody_ on the server ( useful for stopping CHAN_STATIC
//  sounds started by client event when client is not in PVS anymore ( hwguy in TFC e.g. ).
#define FEV_GLOBAL		(1<<2)

// If this client already has one of these events in its queue, just update the event instead of sending it as a duplicate
//
#define FEV_UPDATE		(1<<3)

// Only send to entity specified as the invoker
#define	FEV_HOSTONLY	(1<<4)

// Only send if the event was created on the server.
#define FEV_SERVER		(1<<5)

// Only issue event client side ( from shared code )
#define FEV_CLIENT		(1<<6)

#endif
```

`halflife/engine/in_buttons.h`:

```h
/***
*
*	Copyright (c) 1999, 2000, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef IN_BUTTONS_H
#define IN_BUTTONS_H
#ifdef _WIN32
#pragma once
#endif

#define IN_ATTACK	(1 << 0)
#define IN_JUMP		(1 << 1)
#define IN_DUCK		(1 << 2)
#define IN_FORWARD	(1 << 3)
#define IN_BACK		(1 << 4)
#define IN_USE		(1 << 5)
#define IN_CANCEL	(1 << 6)
#define IN_LEFT		(1 << 7)
#define IN_RIGHT	(1 << 8)
#define IN_MOVELEFT	(1 << 9)
#define IN_MOVERIGHT (1 << 10)
#define IN_ATTACK2	(1 << 11)
#define IN_RUN      (1 << 12)
#define IN_RELOAD	(1 << 13)
#define IN_ALT1		(1 << 14)
#define IN_SCORE	(1 << 15)   // Used by client.dll for when scoreboard is held down

#endif // IN_BUTTONS_H
```

`halflife/engine/model.h`:

```h
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#pragma once

#include "../common/const.h"
#include "modelgen.h"
#include "spritegn.h"
#include "bspfile.h"
#include "../common/crc.h"
#include "../common/com_model.h"
//#include "commonmacros.h"

// header
#define ALIAS_MODEL_VERSION	0x006
#define IDPOLYHEADER		MAKEID('I', 'D', 'P', 'O') // little-endian "IDPO"

#define MAX_LBM_HEIGHT		480
#define MAX_ALIAS_MODEL_VERTS	2000

#define SURF_PLANEBACK		2
#define SURF_DRAWSKY		4
#define SURF_DRAWSPRITE		8
#define SURF_DRAWTURB		0x10
#define SURF_DRAWTILED		0x20
#define SURF_DRAWBACKGROUND	0x40

#define MAX_MODEL_NAME		64
#define MIPLEVELS			4
#define NUM_AMBIENTS		4		// automatic ambient sounds
#define MAXLIGHTMAPS		4
#define MAX_KNOWN_MODELS	1024

/*typedef struct mvertex_s
{
	Vector			position;
} mvertex_t;*/

/*typedef struct mplane_s
{
	Vector			normal;			// surface normal
	float			dist;			// closest appoach to origin
	byte			type;			// for texture axis selection and fast side tests
	byte			signbits;		// signx + signy<<1 + signz<<1
	byte			pad[2];
} mplane_t;*/

/*typedef struct texture_s
{
	char			name[16];
	unsigned		width, height;

#ifndef SWDS
	int			gl_texturenum;
	struct msurface_s *	texturechain;
#endif

	int				anim_total;			// total tenths in sequence ( 0 = no)
	int				anim_min, anim_max;	// time for this frame min <=time< max
	struct texture_s *anim_next;		// in the animation sequence
	struct texture_s *alternate_anims;	// bmodels in frame 1 use these
	unsigned		offsets[MIPLEVELS];	// four mip maps stored

#ifdef SWDS
	unsigned		paloffset;
#else
	byte *pPal;
#endif

} texture_t;*/

/*typedef struct medge_s
{
	unsigned short	v[2];
	unsigned int	cachededgeoffset;
} medge_t;*/

/*typedef struct mtexinfo_s
{
	float			vecs[2][4];		// [s/t] unit vectors in world space.
									// [i][3] is the s/t offset relative to the origin.
									// s or t = dot(3Dpoint,vecs[i])+vecs[i][3]
	float			mipadjust;		// ?? mipmap limits for very small surfaces
	texture_t		*texture;
	int				flags;			// sky or slime, no lightmap or 256 subdivision
} mtexinfo_t;*/
#define	TEX_SPECIAL		1		// sky or slime, no lightmap or 256 subdivision

typedef struct msurface_s msurface_t;
typedef struct decal_s decal_t;

// JAY: Compress this as much as possible
/*struct decal_s
{
	decal_t			*pnext;			// linked list for each surface
	msurface_t		*psurface;		// Surface id for persistence / unlinking
	short			dx;				// Offsets into surface texture (in texture coordinates, so we don't need floats)
	short			dy;
	short			texture;		// Decal texture
	byte			scale;			// Pixel scale
	byte			flags;			// Decal flags

	short			entityIndex;	// Entity this is attached to
};*/

/*struct msurface_s
{
	int				visframe;		// should be drawn when node is crossed

	int				dlightframe;	// last frame the surface was checked by an animated light
	int				dlightbits;		// dynamically generated. Indicates if the surface illumination
									// is modified by an animated light.

	mplane_t		*plane;			// pointer to shared plane
	int				flags;			// see SURF_ #defines

	int				firstedge;	// look up in model->surfedges[], negative numbers
	int				numedges;	// are backwards edges

	// surface generation data
	struct surfcache_s *cachespots[MIPLEVELS];

	short			texturemins[2]; // smallest s/t position on the surface.
	short			extents[2];		// ?? s/t texture size, 1..256 for all non-sky surfaces

	mtexinfo_t		*texinfo;

	// lighting info
	byte			styles[MAXLIGHTMAPS];	// index into d_lightstylevalue[] for animated lights
											// no one surface can be effected by more than 4
											// animated lights.
	color24			*samples;

	decal_t			*pdecals;
};*/

/*typedef struct mnode_s
{
	// common with leaf
	int				contents;		// 0, to differentiate from leafs
	int				visframe;		// node needs to be traversed if current

	short			minmaxs[6];		// for bounding box culling

	struct mnode_s	*parent;

	// node specific
	mplane_t		*plane;
	struct mnode_s	*children[2];

	unsigned short	firstsurface;
	unsigned short	numsurfaces;
} mnode_t;*/

/*typedef struct mleaf_s
{
	// common with node
	int				contents;		// wil be a negative contents number
	int				visframe;		// node needs to be traversed if current

	short			minmaxs[6];		// for bounding box culling

	struct mnode_s	*parent;

	// leaf specific
	byte			*compressed_vis;
	struct efrag_s	*efrags;

	msurface_t		**firstmarksurface;
	int				nummarksurfaces;
	int				key;			// BSP sequence number for leaf's contents
	byte			ambient_sound_level[NUM_AMBIENTS];
} mleaf_t;*/

/*typedef struct hull_s
{
	dclipnode_t		*clipnodes;
	mplane_t		*planes;
	int				firstclipnode;
	int				lastclipnode;
	Vector			clip_mins, clip_maxs;
} hull_t;*/

typedef struct mspriteframe_t
{
	int				width;
	int				height;
	void			*pcachespot;
	float			up, down, left, right;
	byte			pixels[4];
} mspriteframe_s;

typedef struct mspritegroup_s
{
	int				numframes;
	float			*intervals;
	mspriteframe_t	*frames[1];
} mspritegroup_t;

typedef struct mspriteframedesc_s
{
	spriteframetype_t type;
	mspriteframe_t	*frameptr;
} mspriteframedesc_t;

typedef struct msprite_s
{
	short int		type;
	short int		texFormat;
	int				maxwidth, maxheight;
	int				numframes;
	int				paloffset;
	float			beamlength;
	void			*cachespot;
	mspriteframedesc_t frames[1];
} msprite_t;

typedef struct maliasframedesc_s
{
	aliasframetype_t type;
	trivertx_t		bboxmin, bboxmax;
	int				frame;
	char			name[16];
} maliasframedesc_t;

typedef struct maliasskindesc_s
{
	aliasskintype_t type;
	void			*pcachespot;
	int				skin;
} maliasskindesc_t;

typedef struct maliasgroupframedesc_s
{
	trivertx_t		bboxmin, bboxmax;
	int				frame;
} maliasgroupframedesc_t;

typedef struct maliasgroup_s
{
	int				numframes;
	int				intervals;
	maliasgroupframedesc_t frames[1];
} maliasgroup_t;

typedef struct maliasskingroup_s
{
	int				numskins;
	int				intervals;
	maliasskindesc_t skindescs[1];
} maliasskingroup_t;

typedef struct mtriangle_s
{
	int				facesfront;
	int				vertindex[3];
} mtriangle_t;

typedef struct aliashdr_s
{
	int				model;
	int				stverts;
	int				skindesc;
	int				triangles;
	int				palette;
	maliasframedesc_t frames[1];
} aliashdr_t;

/*typedef enum modtype_e
{
	mod_bad = -1,
	mod_brush,
	mod_sprite,
	mod_alias,
	mod_studio,
} modtype_t;*/

/*typedef struct model_s
{
	char			name[MAX_MODEL_NAME];

	int		needload;		// bmodels and sprites don't cache normally

	modtype_t		type;
	int				numframes;
	synctype_t		synctype;

	int				flags;

	//
	// volume occupied by the model
	//
	Vector			mins, maxs;
	float			radius;

	//
	// brush model
	//
	int				firstmodelsurface, nummodelsurfaces;

	int				numsubmodels;
	dmodel_t		*submodels;

	int				numplanes;
	mplane_t		*planes;

	int				numleafs;		// number of visible leafs, not counting 0
	struct mleaf_s	*leafs;

	int				numvertexes;
	mvertex_t		*vertexes;

	int				numedges;
	medge_t			*edges;

	int				numnodes;
	mnode_t			*nodes;

	int				numtexinfo;
	mtexinfo_t		*texinfo;

	int				numsurfaces;
	msurface_t		*surfaces;

	int				numsurfedges;
	int				*surfedges;

	int				numclipnodes;
	dclipnode_t		*clipnodes;

	int				nummarksurfaces;
	msurface_t		**marksurfaces;

	hull_t			hulls[MAX_MAP_HULLS];

	int				numtextures;
	texture_t		**textures;

	byte			*visdata;

	color24			*lightdata;

	char			*entities;

	//
	// additional model data
	//
	cache_user_t	cache;			// only access through Mod_Extradata
} model_t;*/

typedef struct cachepic_s
{
	char			name[64];
	cache_user_t	cache;
} cachepic_t;

typedef struct cachewad_s cachewad_t;

typedef void(*PFNCACHE)(cachewad_t *, unsigned char *);

typedef struct cachewad_s
{
	char			*name;
	cachepic_t		*cache;
	int				cacheCount;
	int				cacheMax;
	struct lumpinfo_s *lumps;
	int				lumpCount;
	int				cacheExtra;
	PFNCACHE		pfnCacheBuild;
	int				numpaths;
	char			**basedirs;
	int				*lumppathindices;
#ifndef SWDS
	int				tempWad;
#endif // SWDS
} cachewad_t;

typedef struct mod_known_info_s
{
	qboolean		shouldCRC;
	qboolean		firstCRCDone;
	CRC32_t			initialCRC;
} mod_known_info_t;


```

`halflife/engine/modelgen.h`:

```h
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/

#ifndef MODELGEN_H
#define MODELGEN_H
#ifdef _WIN32
#pragma once
#endif

/*typedef enum synctype_e
{
	ST_SYNC = 0,
	ST_RAND = 1,
} synctype_t;*/

typedef enum aliasframetype_s
{
	ALIAS_SINGLE = 0,
	ALIAS_GROUP = 1,
} aliasframetype_t;

typedef enum aliasskintype_s
{
	ALIAS_SKIN_SINGLE = 0,
	ALIAS_SKIN_GROUP = 1,
} aliasskintype_t;

typedef struct mdl_s
{
	int				ident;
	int				version;
	Vector			scale;
	Vector			scale_origin;
	float			boundingradius;
	Vector			eyeposition;
	int				numskins;
	int				skinwidth;
	int				skinheight;
	int				numverts;
	int				numtris;
	int				numframes;
	synctype_t		synctype;
	int				flags;
	float			size;
} mdl_t;

typedef struct stvert_s
{
	int				onseam;
	int				s;
	int				t;
} stvert_t;

typedef struct dtriangle_s
{
	int				facesfront;
	int				vertindex[3];
} dtriangle_t;

typedef struct trivertx_s
{
	byte			v[3];
	byte			lightnormalindex;
} trivertx_t;

typedef struct daliasframe_s
{
	trivertx_t		bboxmin, bboxmax;
	char			name[16];
} daliasframe_t;

typedef struct daliasgroup_s
{
	int				numframes;
	trivertx_t		bboxmin, bboxmax;
} daliasgroup_t;

typedef struct daliasskingroup_s
{
	int				numskins;
} daliasskingroup_t;

typedef struct daliasinterval_s
{
	float			interval;
} daliasinterval_t;

typedef struct daliasskininterval_s
{
	float			interval;
} daliasskininterval_t;

typedef struct daliasframetype_s
{
	aliasframetype_t type;
} daliasframetype_t;

typedef struct daliasskintype_s
{
	aliasskintype_t type;
} daliasskintype_t;

#endif // MODELGEN_H

```

`halflife/engine/net.h`:

```h
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/

#pragma once

//#include "maintypes.h"
#include "../common/enums.h"
#include "../common/netadr.h"

const int PROTOCOL_VERSION		= 48;

// MAX_CHALLENGES is made large to prevent a denial
//  of service attack that could cycle all of them
//  out before legitimate users connected
#ifdef REHLDS_OPT_PEDANTIC
const int MAX_CHALLENGES		= 64;
#else
const int MAX_CHALLENGES		= 1024;
#endif // REHLDS_OPT_PEDANTIC

// Client connection is initiated by requesting a challenge value
//  the server sends this value back
const char S2C_CHALLENGE		= 'A';	// + challenge value

// Send a userid, client remote address, is this server secure and engine build number
const char S2C_CONNECTION       = 'B';

// HLMaster rejected a server's connection because the server needs to be updated
const char M2S_REQUESTRESTART	= 'O';

// Response details about each player on the server
const char S2A_PLAYERS			= 'D';

// Number of rules + string key and string value pairs
const char S2A_RULES			= 'E';

// info request
const char S2A_INFO				= 'C'; // deprecated goldsrc response

const char S2A_INFO_DETAILED	= 'm'; // New Query protocol, returns dedicated or not, + other performance info.

// send a log event as key value
const char S2A_LOGSTRING		= 'R';

// Send a log string
const char S2A_LOGKEY			= 'S';

// Basic information about the server
const char A2S_INFO				= 'T';

// Details about each player on the server
const char A2S_PLAYER			= 'U';

// The rules the server is using
const char A2S_RULES			= 'V';

// Another user is requesting a challenge value from this machine
const char A2A_GETCHALLENGE		= 'W';	// Request challenge # from another machine

// Generic Ping Request
const char A2A_PING				= 'i';	// respond with an A2A_ACK

// Generic Ack
const char A2A_ACK				= 'j';	// general acknowledgement without info

// Print to client console
const char A2A_PRINT			= 'l'; // print a message on client

// Challenge response from master
const char M2A_CHALLENGE		= 's';	// + challenge value

// 0 == regular, 1 == file stream
enum
{
	FRAG_NORMAL_STREAM = 0,
	FRAG_FILE_STREAM,

	MAX_STREAMS
};

// Flow control bytes per second limits
const float MAX_RATE		= 100000.0f;
const float MIN_RATE		= 1000.0f;

// Default data rate
const float DEFAULT_RATE	= 9999.0f;

// NETWORKING INFO

// Max size of udp packet payload
const int MAX_UDP_PACKET	= 4010; // 9 bytes SPLITHEADER + 4000 payload?

// Max length of a reliable message
const int MAX_MSGLEN		= 3990; // 10 reserved for fragheader?

// Max length of unreliable message
const int MAX_DATAGRAM		= 4000;

// This is the packet payload without any header bytes (which are attached for actual sending)
const int NET_MAX_PAYLOAD	= 65536;

// This is the payload plus any header info (excluding UDP header)

// Packet header is:
//  4 bytes of outgoing seq
//  4 bytes of incoming seq
//  and for each stream
// {
//  byte (on/off)
//  int (fragment id)
//  short (startpos)
//  short (length)
// }
#define HEADER_BYTES (8 + MAX_STREAMS * 9)

// Pad this to next higher 16 byte boundary
// This is the largest packet that can come in/out over the wire, before processing the header
//  bytes will be stripped by the networking channel layer
//#define NET_MAX_MESSAGE PAD_NUMBER( ( MAX_MSGLEN + HEADER_BYTES ), 16 )
// This is currently used value in the engine. TODO: define above gives 4016, check it why.
const int NET_MAX_MESSAGE = 4037;

enum svc_commands_e : uint32_t
{
	svc_bad,
	svc_nop,
	svc_disconnect,
	svc_event,
	svc_version,
	svc_setview,
	svc_sound,
	svc_time,
	svc_print,
	svc_stufftext,
	svc_setangle,
	svc_serverinfo,
	svc_lightstyle,
	svc_updateuserinfo,
	svc_deltadescription,
	svc_clientdata,
	svc_stopsound,
	svc_pings,
	svc_particle,
	svc_damage,
	svc_spawnstatic,
	svc_event_reliable,
	svc_spawnbaseline,
	svc_temp_entity,
	svc_setpause,
	svc_signonnum,
	svc_centerprint,
	svc_killedmonster,
	svc_foundsecret,
	svc_spawnstaticsound,
	svc_intermission,
	svc_finale,
	svc_cdtrack,
	svc_restore,
	svc_cutscene,
	svc_weaponanim,
	svc_decalname,
	svc_roomtype,
	svc_addangle,
	svc_newusermsg,
	svc_packetentities,
	svc_deltapacketentities,
	svc_choke,
	svc_resourcelist,
	svc_newmovevars,
	svc_resourcerequest,
	svc_customization,
	svc_crosshairangle,
	svc_soundfade,
	svc_filetxferfailed,
	svc_hltv,
	svc_director,
	svc_voiceinit,
	svc_voicedata,
	svc_sendextrainfo,
	svc_timescale,
	svc_resourcelocation,
	svc_sendcvarvalue,
	svc_sendcvarvalue2,
	svc_startofusermessages = svc_sendcvarvalue2,
	svc_endoflist = 255,
};

typedef void(*pfnEngineMessage)();

struct svc_func_t
{
	svc_commands_e opcode;
	char *pszName;
	pfnEngineMessage pfnParse;
};

typedef enum clc_commands_e
{
	clc_bad,
	clc_nop,
	clc_move,
	clc_stringcmd,
	clc_delta,
	clc_resourcelist,
	clc_tmove,
	clc_fileconsistency,
	clc_voicedata,
	clc_hltv,
	clc_cvarvalue,
	clc_cvarvalue2,
	clc_endoflist = 255,
} clc_commands_t;

enum
{
	FLOW_OUTGOING = 0,
	FLOW_INCOMING,

	MAX_FLOWS
};

// Message data
typedef struct flowstats_s
{
	// Size of message sent/received
	int size;
	// Time that message was sent/received
	double time;
} flowstats_t;

const int MAX_LATENT = 32;

typedef struct flow_s
{
	// Data for last MAX_LATENT messages
	flowstats_t stats[MAX_LATENT];
	// Current message position
	int current;
	// Time when we should recompute k/sec data
	double nextcompute;
	// Average data
	float kbytespersec;
	float avgkbytespersec;
} flow_t;

const int FRAGMENT_C2S_MIN_SIZE = 16;
const int FRAGMENT_S2C_MIN_SIZE = 256;
const int FRAGMENT_S2C_MAX_SIZE = 1024;

const int CLIENT_FRAGMENT_SIZE_ONCONNECT = 128;
const int CUSTOMIZATION_MAX_SIZE = 20480;

#ifndef REHLDS_FIXES
// Size of fragmentation buffer internal buffers
const int FRAGMENT_MAX_SIZE = 1400;

const int MAX_FRAGMENTS = 25000;
#else
const int FRAGMENT_MAX_SIZE = 1024;

// Client sends normal fragments only while connecting
#define MAX_NORMAL_FRAGMENTS (NET_MAX_PAYLOAD / CLIENT_FRAGMENT_SIZE_ONCONNECT)

// While client is connecting it sending fragments with minimal size, also it transfers sprays with minimal fragments...
// But with sv_delayed_spray_upload it sends with cl_dlmax fragment size
#define MAX_FILE_FRAGMENTS (CUSTOMIZATION_MAX_SIZE / FRAGMENT_C2S_MIN_SIZE)
#endif

const int UDP_HEADER_SIZE = 28;
const int MAX_RELIABLE_PAYLOAD = 1200;

#define MAKE_FRAGID(id,count)	((( id & 0xffff) << 16) | (count & 0xffff))
#define FRAG_GETID(fragid)		((fragid >> 16) & 0xffff)
#define FRAG_GETCOUNT(fragid)	(fragid & 0xffff)

// Generic fragment structure
typedef struct fragbuf_s
{
	// Next buffer in chain
	fragbuf_s *next;
	// Id of this buffer
	int bufferid;
	// Message buffer where raw data is stored
	sizebuf_t frag_message;
	// The actual data sits here
	byte frag_message_buf[FRAGMENT_MAX_SIZE];
	// Is this a file buffer?
	qboolean isfile;
	// Is this file buffer from memory ( custom decal, etc. ).
	qboolean isbuffer;
	qboolean iscompressed;
	// Name of the file to save out on remote host
	char filename[MAX_PATH];
	// Offset in file from which to read data
	int foffset;
	// Size of data to read at that offset
	int size;
} fragbuf_t;

// Waiting list of fragbuf chains
typedef struct fragbufwaiting_s
{
	// Next chain in waiting list
	fragbufwaiting_s *next;
	// Number of buffers in this chain
	int fragbufcount;
	// The actual buffers
	fragbuf_t *fragbufs;
} fragbufwaiting_t;

// Network Connection Channel
typedef struct netchan_s
{
	// NS_SERVER or NS_CLIENT, depending on channel.
	netsrc_t sock;

	// Address this channel is talking to.
	netadr_t remote_address;

	int player_slot;
	// For timeouts.  Time last message was received.
	float last_received;
	// Time when channel was connected.
	float connect_time;

	// Bandwidth choke
	// Bytes per second
	double rate;
	// If realtime > cleartime, free to send next packet
	double cleartime;

	// Sequencing variables
	//
	// Increasing count of sequence numbers
	int incoming_sequence;
	// # of last outgoing message that has been ack'd.
	int incoming_acknowledged;
	// Toggles T/F as reliable messages are received.
	int incoming_reliable_acknowledged;
	// single bit, maintained local
	int incoming_reliable_sequence;
	// Message we are sending to remote
	int outgoing_sequence;
	// Whether the message contains reliable payload, single bit
	int reliable_sequence;
	// Outgoing sequence number of last send that had reliable data
	int last_reliable_sequence;

	void *connection_status;
	int (*pfnNetchan_Blocksize)(void *);

	// Staging and holding areas
	sizebuf_t message;
	byte message_buf[MAX_MSGLEN];

	// Reliable message buffer. We keep adding to it until reliable is acknowledged. Then we clear it.
	int reliable_length;
	byte reliable_buf[MAX_MSGLEN];

	// Waiting list of buffered fragments to go onto queue. Multiple outgoing buffers can be queued in succession.
	fragbufwaiting_t *waitlist[MAX_STREAMS];

	// Is reliable waiting buf a fragment?
	int reliable_fragment[MAX_STREAMS];
	// Buffer id for each waiting fragment
	unsigned int reliable_fragid[MAX_STREAMS];

	// The current fragment being set
	fragbuf_t *fragbufs[MAX_STREAMS];
	// The total number of fragments in this stream
	int fragbufcount[MAX_STREAMS];

	// Position in outgoing buffer where frag data starts
	short int frag_startpos[MAX_STREAMS];
	// Length of frag data in the buffer
	short int frag_length[MAX_STREAMS];

	// Incoming fragments are stored here
	fragbuf_t *incomingbufs[MAX_STREAMS];
	// Set to true when incoming data is ready
	qboolean incomingready[MAX_STREAMS];

	// Only referenced by the FRAG_FILE_STREAM component
	// Name of file being downloaded
	char incomingfilename[MAX_PATH];

	void *tempbuffer;
	int tempbuffersize;

	// Incoming and outgoing flow metrics
	flow_t flow[MAX_FLOWS];
} netchan_t;

#ifdef REHLDS_FIXES
#define Con_NetPrintf Con_DPrintf
#else // REHLDS_FIXES
#define Con_NetPrintf Con_Printf
#endif // REHLDS_FIXES

```

`halflife/engine/particledef.h`:

```h
/***
*
*	Copyright (c) 1999, 2000, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined( PARTICLEDEFH )
#define PARTICLEDEFH
#ifdef _WIN32
#pragma once
#endif

typedef enum {
	pt_static, 
	pt_grav,
	pt_slowgrav,
	pt_fire,
	pt_explode,
	pt_explode2,
	pt_blob,
	pt_blob2,
	pt_vox_slowgrav,
	pt_vox_grav,
	pt_clientcustom   // Must have callback function specified
} ptype_t;

// !!! if this is changed, it must be changed in d_ifacea.h too !!!
typedef struct particle_s
{
// driver-usable fields
	vec3_t		org;
	short		color;
	short		packedColor;
// drivers never touch the following fields
	struct particle_s	*next;
	vec3_t		vel;
	float		ramp;
	float		die;
	ptype_t		type;
	void		(*deathfunc)( struct particle_s *particle );

	// for pt_clientcusttom, we'll call this function each frame
	void		(*callback)( struct particle_s *particle, float frametime );
	
	// For deathfunc, etc.
	unsigned char context;
} particle_t;

#endif
```

`halflife/engine/pm_materials.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined( PM_MATERIALSH )
#define PM_MATERIALSH
#pragma once

#define CBTEXTURENAMEMAX	13			// only load first n chars of name

#define CHAR_TEX_CONCRETE	'C'			// texture types
#define CHAR_TEX_METAL		'M'
#define CHAR_TEX_DIRT		'D'
#define CHAR_TEX_VENT		'V'
#define CHAR_TEX_GRATE		'G'
#define CHAR_TEX_TILE		'T'
#define CHAR_TEX_SLOSH		'S'
#define CHAR_TEX_WOOD		'W'
#define CHAR_TEX_COMPUTER	'P'
#define CHAR_TEX_GLASS		'Y'
#define CHAR_TEX_FLESH		'F'

#endif // !PM_MATERIALSH

```

`halflife/engine/pm_movevars.h`:

```h
//========= Copyright ?1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

// pm_movevars.h
#if !defined( PM_MOVEVARSH )
#define PM_MOVEVARSH

// movevars_t                  // Physics variables.
typedef struct movevars_s movevars_t;

struct movevars_s
{
	float	gravity;           // Gravity for map
	float	stopspeed;         // Deceleration when not moving
	float	maxspeed;          // Max allowed speed
	float	spectatormaxspeed;
	float	accelerate;        // Acceleration factor
	float	airaccelerate;     // Same for when in open air
	float	wateraccelerate;   // Same for when in water
	float	friction;          
	float   edgefriction;	   // Extra friction near dropofs 
	float	waterfriction;     // Less in water
	float	entgravity;        // 1.0
	float   bounce;            // Wall bounce value. 1.0
	float   stepsize;          // sv_stepsize;
	float   maxvelocity;       // maximum server velocity.
	float	zmax;			   // Max z-buffer range (for GL)
	float	waveHeight;		   // Water wave height (for GL)
	qboolean footsteps;        // Play footstep sounds
	char	skyName[32];	   // Name of the sky map
	float	rollangle;
	float	rollspeed;
	float	skycolor_r;			// Sky color
	float	skycolor_g;			// 
	float	skycolor_b;			//
	float	skyvec_x;			// Sky vector
	float	skyvec_y;			// 
	float	skyvec_z;			// 
};

extern movevars_t movevars;

#endif

```

`halflife/engine/r_studioint.h`:

```h
#if !defined( R_STUDIOINT_H )
#define R_STUDIOINT_H
#if defined( _WIN32 )
#pragma once
#endif

#define STUDIO_INTERFACE_VERSION 1

typedef struct engine_studio_api_s
{
	// Allocate number*size bytes and zero it
	void			*( *Mem_Calloc )				( int number, size_t size );
	// Check to see if pointer is in the cache
	void			*( *Cache_Check )				( struct cache_user_s *c );
	// Load file into cache ( can be swapped out on demand )
	void			( *LoadCacheFile )				( char *path, struct cache_user_s *cu );
	// Retrieve model pointer for the named model
	struct model_s	*( *Mod_ForName )				( const char *name, int crash_if_missing );
	// Retrieve pointer to studio model data block from a model
	void			*( *Mod_Extradata )				( struct model_s *mod );
	// Retrieve indexed model from client side model precache list
	struct model_s	*( *GetModelByIndex )			( int index );
	// Get entity that is set for rendering
	struct cl_entity_s * ( *GetCurrentEntity )		( void );
	// Get referenced player_info_t
	struct player_info_s *( *PlayerInfo )			( int index );
	// Get most recently received player state data from network system
	struct entity_state_s *( *GetPlayerState )		( int index );
	// Get viewentity
	struct cl_entity_s * ( *GetViewEntity )			( void );
	// Get current frame count, and last two timestampes on client
	void			( *GetTimes )					( int *framecount, double *current, double *old );
	// Get a pointer to a cvar by name
	struct cvar_s	*( *GetCvar )					( const char *name );
	// Get current render origin and view vectors ( up, right and vpn )
	void			( *GetViewInfo )				( float *origin, float *upv, float *rightv, float *vpnv );
	// Get sprite model used for applying chrome effect
	struct model_s	*( *GetChromeSprite )			( void );
	// Get model counters so we can incement instrumentation
	void			( *GetModelCounters )			( int **s, int **a );
	// Get software scaling coefficients
	void			( *GetAliasScale )				( float *x, float *y );

	// Get bone, light, alias, and rotation matrices
	float			****( *StudioGetBoneTransform ) ( void );
	float			****( *StudioGetLightTransform )( void );
	float			***( *StudioGetAliasTransform ) ( void );
	float			***( *StudioGetRotationMatrix ) ( void );

	// Set up body part, and get submodel pointers
	void			( *StudioSetupModel )			( int bodypart, void **ppbodypart, void **ppsubmodel );
	// Check if entity's bbox is in the view frustum
	int				( *StudioCheckBBox )			( void );
	// Apply lighting effects to model
	void			( *StudioDynamicLight )			( struct cl_entity_s *ent, struct alight_s *plight );
	void			( *StudioEntityLight )			( struct alight_s *plight );
	void			( *StudioSetupLighting )		( struct alight_s *plighting );

	// Draw mesh vertices
	void			( *StudioDrawPoints )			( void );

	// Draw hulls around bones
	void			( *StudioDrawHulls )			( void );
	// Draw bbox around studio models
	void			( *StudioDrawAbsBBox )			( void );
	// Draws bones
	void			( *StudioDrawBones )			( void );
	// Loads in appropriate texture for model
	void			( *StudioSetupSkin )			( void *ptexturehdr, int index );
	// Sets up for remapped colors
	void			( *StudioSetRemapColors )		( int top, int bottom );
	// Set's player model and returns model pointer
	struct model_s	*( *SetupPlayerModel )			( int index );
	// Fires any events embedded in animation
	void			( *StudioClientEvents )			( void );
	// Retrieve/set forced render effects flags
	int				( *GetForceFaceFlags )			( void );
	void			( *SetForceFaceFlags )			( int flags );
	// Tell engine the value of the studio model header
	void			( *StudioSetHeader )			( void *header );
	// Tell engine which model_t * is being renderered
	void			( *SetRenderModel )				( struct model_s *model );

	// Final state setup and restore for rendering
	void			( *SetupRenderer )				( int rendermode );
	void			( *RestoreRenderer )			( void );

	// Set render origin for applying chrome effect
	void			( *SetChromeOrigin )			( void );

	// True if using D3D/OpenGL
	int				( *IsHardware )					( void );
	
	// Only called by hardware interface
	void			( *GL_StudioDrawShadow )		( void );
	void			( *GL_SetRenderMode )			( int mode );
} engine_studio_api_t;

typedef struct r_studio_interface_s
{
	int				version;
	int				( *StudioDrawModel	)			( int flags );
	int				( *StudioDrawPlayer	)			( int flags, struct entity_state_s *pplayer );
} r_studio_interface_t;

extern r_studio_interface_t *pStudioAPI;

#endif // R_STUDIOINT_H
```

`halflife/engine/sound.h`:

```h
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/

#pragma once

//#include "quakedef.h"

#define BIT(n) (1<<(n))

#define DEFAULT_SOUND_PACKET_VOLUME			255
#define DEFAULT_SOUND_PACKET_ATTENUATION	1.0f
#define DEFAULT_SOUND_PACKET_PITCH			100

// Sound flags
#define SND_FL_VOLUME			BIT(0)	// send volume
#define SND_FL_ATTENUATION		BIT(1)	// send attenuation
#define SND_FL_LARGE_INDEX		BIT(2)	// send sound number as short instead of byte
#define SND_FL_PITCH			BIT(3)	// send pitch
#define SND_FL_SENTENCE			BIT(4)	// set if sound num is actually a sentence num
#define SND_FL_STOP				BIT(5)	// stop the sound
#define SND_FL_CHANGE_VOL		BIT(6)	// change sound vol
#define SND_FL_CHANGE_PITCH		BIT(7)	// change sound pitch
#define SND_FL_SPAWNING			BIT(8)	// we're spawning, used in some cases for ambients (not sent across network)

// max number of sentences in game. NOTE: this must match CVOXFILESENTENCEMAX in dlls\util.h!!!
const int CVOXFILESENTENCEMAX = 1536;

typedef struct sfx_s
{
	char name[64];
	cache_user_t cache;
	int servercount;
} sfx_t;

/*void S_Init();
void S_AmbientOff();
void S_AmbientOn();
void S_Shutdown();
void S_TouchSound(char *sample);
void S_ClearBuffer();
void S_StartStaticSound(int entnum, int entchannel, sfx_t *sfx, vec_t *origin, float vol, float attenuation, int flags, int pitch);
void S_StartDynamicSound(int entnum, int entchannel, sfx_t *sfx, vec_t *origin, float fvol, float attenuation, int flags, int pitch);
void S_StopSound(int entnum, int entchannel);
sfx_t *S_PrecacheSound(char *sample);
void S_ClearPrecache();
void S_Update(vec_t * origin, vec_t * v_forward, vec_t * v_right, vec_t * v_up);
void S_StopAllSounds(qboolean clear);
void S_BeginPrecaching();
void S_EndPrecaching();
void S_ExtraUpdate();
void S_LocalSound(char * s);
void S_BlockSound();
void S_PrintStats();
qboolean Voice_RecordStart(const char  * pUncompressedFile, const char  * pDecompressedFile, const char  * pMicInputFile);
qboolean Voice_IsRecording();
void Voice_RegisterCvars();
void Voice_Deinit();
void Voice_Idle(float frametime);
qboolean Voice_RecordStop();*/

```

`halflife/engine/spritegn.h`:

```h
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/

#ifndef SPRITEGN_H
#define SPRITEGN_H
#ifdef _WIN32
#pragma once
#endif

#include "modelgen.h"
//#include "../commonmacros.h"

#define SPRITE_VERSION		2				// Half-Life sprites
#define IDSPRITEHEADER		MAKEID('I', 'D', 'S', 'P')	// little-endian "IDSP"

typedef enum spriteframetype_e
{
	SPR_SINGLE = 0,
	SPR_GROUP,
	SPR_ANGLED
} spriteframetype_t;

typedef struct dsprite_s
{
	int				ident;
	int				version;
	int				type;
	int				texFormat;
	float			boundingradius;
	int				width;
	int				height;
	int				numframes;
	float			beamlength;
	synctype_t		synctype;
} dsprite_t;

typedef struct dspriteframe_s
{
	int				origin[2];
	int				width;
	int				height;
} dspriteframe_t;

typedef struct dspritegroup_s
{
	int				numframes;
} dspritegroup_t;

typedef struct dspriteinterval_s
{
	float			interval;
} dspriteinterval_t;

typedef struct dspriteframetype_s
{
	spriteframetype_t type;
} dspriteframetype_t;

#endif // SPRITEGN_H

```

`halflife/engine/studio_event.h`:

```h
/***
*
*	Copyright (c) 1999, 2000, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined( STUDIO_EVENTH )
#define STUDIO_EVENTH
#pragma once

typedef struct mstudioevent_s
{
	int 				frame;
	int					event;
	int					type;
	char				options[64];
} mstudioevent_t;

#endif // STUDIO_EVENTH
```

`halflife/engine/triangleapi.h`:

```h
/***
*
*	Copyright (c) 1999, 2000, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined( TRIANGLEAPIH )
#define TRIANGLEAPIH
#pragma once

typedef enum 
{
	TRI_FRONT = 0,
	TRI_NONE = 1,
} TRICULLSTYLE;

#define TRI_API_VERSION		1

#define TRI_TRIANGLES		0
#define TRI_TRIANGLE_FAN	1
#define TRI_QUADS			2
#define TRI_POLYGON			3
#define TRI_LINES			4	
#define TRI_TRIANGLE_STRIP	5
#define TRI_QUAD_STRIP		6

typedef struct triangleapi_s
{
	int			version;

	void		(*RenderMode)(int mode);
	void		(*Begin)(int primitiveCode);
	void		(*End) (void);

	void		(*Color4f) (float r, float g, float b, float a);
	void		(*Color4ub) (unsigned char r, unsigned char g, unsigned char b, unsigned char a);
	void		(*TexCoord2f) (float u, float v);
	void		(*Vertex3fv) (float* worldPnt);
	void		(*Vertex3f) (float x, float y, float z);
	void		(*Brightness) (float brightness);
	void		(*CullFace) (TRICULLSTYLE style);
	int			(*SpriteTexture) (struct model_s* pSpriteModel, int frame);
	int			(*WorldToScreen) (float* world, float* screen);  // Returns 1 if it's z clipped
	void		(*Fog) (float flFogColor[3], float flStart, float flEnd, int bOn); // Works just like GL_FOG, flFogColor is r/g/b.
	void		(*ScreenToWorld) (float* screen, float* world);
	void		(*GetMatrix) (const int pname, float* matrix);
	int			(*BoxInPVS) (float* mins, float* maxs);
	void		(*LightAtPoint) (float* pos, float* value);
	void		(*Color4fRendermode) (float r, float g, float b, float a, int rendermode);
	void		(*FogParams) (float flDensity, int iFogSkybox); // Used with Fog()...sets fog density and whether the fog should be applied to the skybox

} triangleapi_t;

#endif // !TRIANGLEAPIH
```

`halflife/engine/util_vector.h`:

```h
#if !defined FILE_UTIL_VECTOR_H
#define FILE_UTIL_VECTOR_H

// Misc C-runtime library headers
#include "STDIO.H"
#include "STDLIB.H"
#include "MATH.H"

// Header file containing definition of globalvars_t and entvars_t
typedef int	func_t;					//
typedef int	string_t;				// from engine's pr_comp.h;
typedef float vec_t;				// needed before including progdefs.h

//=========================================================
// 2DVector - used for many pathfinding and many other 
// operations that are treated as planar rather than 3d.
//=========================================================


#endif

```

`halflife/engine/weaponinfo.h`:

```h
/***
*
*	Copyright (c) 1999, 2000, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined ( WEAPONINFOH )
#define WEAPONINFOH
#ifdef _WIN32
#pragma once
#endif

// Info about weapons player might have in his/her possession
typedef struct weapon_data_s
{
	int			m_iId;
	int			m_iClip;

	float		m_flNextPrimaryAttack;
	float		m_flNextSecondaryAttack;
	float		m_flTimeWeaponIdle;

	int			m_fInReload;
	int			m_fInSpecialReload;
	float		m_flNextReload;
	float		m_flPumpTime;
	float		m_fReloadTime;

	float		m_fAimedDamage;
	float		m_fNextAimBonus;
	int			m_fInZoom;
	int			m_iWeaponState;

	int			iuser1;
	int			iuser2;
	int			iuser3;
	int			iuser4;
	float		fuser1;
	float		fuser2;
	float		fuser3;
	float		fuser4;
} weapon_data_t;

#endif
```

`halflife/misc/UTILS.H`:

```H

#ifndef  UTILS_H
#define  UTILS_H

template <class T> T inline MakePtr(void* Base,DWORD Offset=0)
{
	return reinterpret_cast<T>(reinterpret_cast<DWORD>(Base) + Offset);
}

void Protect(void* addr,int size)
{
	static DWORD realsize;
	static DWORD old;
	if (size!=-1)
	{
    realsize = size;
	VirtualProtect(addr,realsize,PAGE_EXECUTE_READWRITE,&old);
	}
	else 
	{   
		DWORD dummy;
		VirtualProtect(addr,realsize,old,&dummy);
	}
}

template <class T> void inline RandomOverwrite(T addr)
{
   BYTE* startaddr = reinterpret_cast<BYTE*>(addr);
   BYTE* endaddr = reinterpret_cast<BYTE*>(addr) + sizeof(T);
   Protect(startaddr,sizeof(T));
   for (;startaddr<endaddr;startaddr++)
	   *startaddr = rand();
   Protect(startaddr,-1);
}

bool __fastcall ScanPattern_FF15calladr(BYTE* start, DWORD calladr,int array_size,BYTE **pos )
{
	array_size-=6;
	while(array_size)
	{
 		if( start[0]==0xFF && 
			start[1]==0x15 &&
			*(DWORD*)(start+2)==calladr ) { *pos = start; return true; }

		array_size--;
		start++;
	}
	return false;
}

bool __fastcall ScanPattern_fixstackandret(BYTE* start,BYTE stacklen,int array_size,BYTE **pos)
{
	if (stacklen)
	{
	array_size-=6;
	while(array_size)
	{
 		if( start[0]==0x83 && 
			start[1]==0xC4 &&
			start[2]==stacklen &&
			start[3]==0xC3  ) { *pos = start; return true; }
		array_size--;
		start++;
	}
	}
	else
	{
		array_size-=1;
		while(array_size)
	    {
 		if( start[0]==0xC3 ) { *pos = start; return true; }
		array_size--;
		start++;
	    }
	}
	return false;
}

bool __fastcall ScanPattern_8B2Dcalladr(BYTE* start, DWORD calladr,int array_size,BYTE **pos )
{
	array_size-=6;
	while(array_size)
	{
 		if( start[0]==0x8B && 
			start[1]==0x2D &&
			*(DWORD*)(start+2)==calladr ) { *pos = start; return true; }

		array_size--;
		start++;
	}
	return false;
}

bool __fastcall ScanPattern_8B35calladr(BYTE* start, DWORD calladr,int array_size,BYTE **pos )
{
	array_size-=6;
	while(array_size)
	{
 		if( start[0]==0x8B && 
			start[1]==0x35 &&
			*(DWORD*)(start+2)==calladr ) { *pos = start; return true; }

		array_size--;
		start++;
	}
	return false;
}

#endif

```

`halflife/misc/archtypes.h`:

```h
//
// Word size dependent definitions
// DAL 1/03
//
#ifndef ARCHTYPES_H
#define ARCHTYPES_H

#include "steamtypes.h"

#ifndef _WIN32
#define MAX_PATH PATH_MAX
#include <sys/stat.h>
#include <sys/types.h>
#include <limits.h>
#include <stddef.h>
#define _S_IREAD S_IREAD
#define _S_IWRITE S_IWRITE
typedef long unsigned int ulong;
#endif

#endif // ARCHTYPES_H

```

`halflife/misc/netadr.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
// netadr.h
#ifndef NETADR_H
#define NETADR_H
#ifdef _WIN32
#pragma once
#endif

typedef enum
{
	NA_UNUSED,
	NA_LOOPBACK,
	NA_BROADCAST,
	NA_IP,
	NA_IPX,
	NA_BROADCAST_IPX,
} netadrtype_t;

typedef struct netadr_s
{
	netadrtype_t	type;
	unsigned char	ip[4];
	unsigned char	ipx[10];
	unsigned short	port;
} netadr_t;

#endif // NETADR_H

```

`halflife/misc/netchan.h`:

```h
/*
netchan.h - net channel abstraction layer
Copyright (C) 2007 Uncle Mike
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
*/

#ifndef NET_MSG_H
#define NET_MSG_H

#define CS_SIZE	64	// size of one config string

typedef struct sizebuf_s 
{
    qboolean		bOverflow;	// overflow reading or writing
    const char	*pDebugName;	// buffer name (pointer to const name)

    byte		*pData;
    int		iCurBit;
    int		nDataBits;
} sizebuf_t;

typedef enum {
    NS_CLIENT,
    NS_SERVER,
    NS_MULTICAST
} netsrc_t;

/*
==========================================================
ELEMENTS COMMUNICATED ACROSS THE NET
==========================================================
*/

// 0 == regular, 1 == file stream
#define MAX_STREAMS			2    

// flow control bytes per second limits
#define MAX_RATE			20000				
#define MIN_RATE			1000

// default data rate
#define DEFAULT_RATE		(9999.0f)

// NETWORKING INFO

// This is the packet payload without any header bytes (which are attached for actual sending)
#define NET_MAX_PAYLOAD		80000

// This is the payload plus any header info (excluding UDP header)

// Packet header is:
//  4 bytes of outgoing seq
//  4 bytes of incoming seq
//  and for each stream
// {
//  byte (on/off)
//  int (fragment id)
//  short (startpos)
//  short (length)
// }
#define HEADER_BYTES		( 8 + MAX_STREAMS * 9 )

// Pad this to next higher 16 byte boundary
// This is the largest packet that can come in/out over the wire, before processing the header
//  bytes will be stripped by the networking channel layer
#define NET_MAX_MESSAGE		PAD_NUMBER(( NET_MAX_PAYLOAD + HEADER_BYTES ), 16 )

#define PORT_MASTER			27010
#define PORT_CLIENT			27005
#define PORT_SERVER			27015
#define MULTIPLAYER_BACKUP		128	// how many data slots to use when in multiplayer (must be power of 2)
#define SINGLEPLAYER_BACKUP		16	// same for single player  

/*
==============================================================
NET
==============================================================
*/
#define MAX_FLOWS			2

#define FLOW_OUTGOING		0
#define FLOW_INCOMING		1
#define MAX_LATENT			32

// size of fragmentation buffer internal buffers
#define FRAGMENT_SIZE 		1400

#define FRAG_NORMAL_STREAM		0
#define FRAG_FILE_STREAM		1

#define NET_EXT_HUFF		(1U<<0)
#define NET_EXT_SPLIT		(1U<<1)
#define NET_EXT_SPLITHUFF	(1U<<2)

// message data
typedef struct {
    int		size;		// size of message sent/received
    double		time;		// time that message was sent/received
} flowstats_t;

typedef struct {
    flowstats_t	stats[MAX_LATENT];	// data for last MAX_LATENT messages
    int		current;		// current message position
    double		nextcompute; 	// time when we should recompute k/sec data
    float		kbytespersec;	// average data
    float		avgkbytespersec;
    int		totalbytes;
} flow_t;

// generic fragment structure
typedef struct fragbuf_s {
    struct fragbuf_s	*next;		// next buffer in chain
    int		bufferid;		// id of this buffer
    sizebuf_t		frag_message;	// message buffer where raw data is stored
    byte		frag_message_buf[FRAGMENT_SIZE];	// the actual data sits here
    qboolean		isfile;		// is this a file buffer?
    qboolean		isbuffer;		// is this file buffer from memory ( custom decal, etc. ).
    char		filename[CS_SIZE];	// name of the file to save out on remote host
    int		foffset;		// offset in file from which to read data  
    int		size;		// size of data to read at that offset
} fragbuf_t;

// Waiting list of fragbuf chains
typedef struct fragbufwaiting_s {
    struct fragbufwaiting_s	*next;	// next chain in waiting list
    int		fragbufcount;	// number of buffers in this chain
    fragbuf_t		*fragbufs;	// the actual buffers
} fragbufwaiting_t;


#define NETSPLIT_BACKUP 8
#define NETSPLIT_BACKUP_MASK (NETSPLIT_BACKUP - 1)
#define NETSPLIT_HEADER_SIZE 18

typedef struct netsplit_chain_packet_s {
    // bool vector
    unsigned int recieved_v[8];
    // serial number
    unsigned int id;
    byte data[NET_MAX_PAYLOAD];
    byte received;
    byte count;
} netsplit_chain_packet_t;

// raw packet format
typedef struct netsplit_packet_s {
    unsigned int signature; // 0xFFFFFFFE
    unsigned int length;
    unsigned int part;
    unsigned int id;
    // max 256 parts
    byte count;
    byte index;
    byte data[NET_MAX_PAYLOAD - NETSPLIT_HEADER_SIZE];
} netsplit_packet_t;


typedef struct netsplit_s {
    netsplit_chain_packet_t packets[NETSPLIT_BACKUP];
    unsigned long long total_received;
    unsigned long long total_received_uncompressed;
} netsplit_t;

// Network Connection Channel
typedef struct netchan_s {
    netsrc_t		sock;		// NS_SERVER or NS_CLIENT, depending on channel.
    netadr_t		remote_address;	// address this channel is talking to.  
    int		qport;		// qport value to write when transmitting

    qboolean		compress;		// enable huffman compression

    double		last_received;	// for timeouts
    double		last_sent;	// for retransmits		

    double		rate;		// bandwidth choke. bytes per second
    double		cleartime;	// if realtime > cleartime, free to send next packet
    double		connect_time;	// Usage: host.realtime - netchan.connect_time

    int		drop_count;	// dropped packets, cleared each level
    int		good_count;	// cleared each level

                        // Sequencing variables
    int		incoming_sequence;		// increasing count of sequence numbers               
    int		incoming_acknowledged;	// # of last outgoing message that has been ack'd.          
    int		incoming_reliable_acknowledged;	// toggles T/F as reliable messages are received.	
    int		incoming_reliable_sequence;	// single bit, maintained local	    
    int		outgoing_sequence;		// message we are sending to remote              
    int		reliable_sequence;		// whether the message contains reliable payload, single bit
    int		last_reliable_sequence; // outgoing sequence number of last send that had reliable data

                                    // staging and holding areas
    sizebuf_t		message;
    byte		message_buf[NET_MAX_PAYLOAD];

    // reliable message buffer.
    // we keep adding to it until reliable is acknowledged.  Then we clear it.
    int		reliable_length;
    byte		reliable_buf[NET_MAX_PAYLOAD];	// unacked reliable message

                                                // Waiting list of buffered fragments to go onto queue.
                                                // Multiple outgoing buffers can be queued in succession
    fragbufwaiting_t	*waitlist[MAX_STREAMS];

    int		reliable_fragment[MAX_STREAMS];	// is reliable waiting buf a fragment?          
    uint		reliable_fragid[MAX_STREAMS];		// buffer id for each waiting fragment

    fragbuf_t		*fragbufs[MAX_STREAMS];	// the current fragment being set
    int		fragbufcount[MAX_STREAMS];	// the total number of fragments in this stream

    short		frag_startpos[MAX_STREAMS];	// position in outgoing buffer where frag data starts
    short		frag_length[MAX_STREAMS];	// length of frag data in the buffer

    fragbuf_t		*incomingbufs[MAX_STREAMS];	// incoming fragments are stored here
    qboolean		incomingready[MAX_STREAMS];	// set to true when incoming data is ready

                                                // Only referenced by the FRAG_FILE_STREAM component
    char		incomingfilename[CS_SIZE];	// Name of file being downloaded

                                            // incoming and outgoing flow metrics
    flow_t		flow[MAX_FLOWS];

    // added for net_speeds
    size_t		total_sended;
    size_t		total_sended_uncompressed;

    size_t		total_received;
    size_t		total_received_uncompressed;
    qboolean	split;
    qboolean	splitcompress;
    unsigned int	maxpacket;
    unsigned int	splitid;
    netsplit_t netsplit;
} netchan_t;

extern netadr_t		net_from;
extern netadr_t		net_local;
extern sizebuf_t		net_message;
extern byte		net_message_buffer[NET_MAX_PAYLOAD];
extern int		net_drop;
extern byte 	*net_mempool;

void Netchan_Init(void);
void Netchan_Shutdown(void);
void Netchan_Setup(netsrc_t sock, netchan_t *chan, netadr_t adr, int qport);
qboolean Netchan_CopyNormalFragments(netchan_t *chan, sizebuf_t *msg);
qboolean Netchan_CopyFileFragments(netchan_t *chan, sizebuf_t *msg);
void Netchan_CreateFragments(qboolean server, netchan_t *chan, sizebuf_t *msg);
int Netchan_CreateFileFragments(qboolean server, netchan_t *chan, const char *filename);
void Netchan_Transmit(netchan_t *chan, int lengthInBytes, byte *data);
void Netchan_TransmitBits(netchan_t *chan, int lengthInBits, byte *data);
void Netchan_OutOfBand(int net_socket, netadr_t adr, int length, byte *data);
void Netchan_OutOfBandPrint(int net_socket, netadr_t adr, char *format, ...);
qboolean Netchan_Process(netchan_t *chan, sizebuf_t *msg);
void Netchan_UpdateProgress(netchan_t *chan);
qboolean Netchan_IncomingReady(netchan_t *chan);
qboolean Netchan_CanPacket(netchan_t *chan);
void Netchan_FragSend(netchan_t *chan);
void Netchan_Clear(netchan_t *chan);

// packet splitting
qboolean NetSplit_GetLong(netsplit_t *ns, netadr_t *from, byte *data, size_t *length, qboolean decompress);

// huffman compression
void Huff_Init(void);
void Huff_CompressPacket(sizebuf_t *msg, int offset);
void Huff_DecompressPacket(sizebuf_t *msg, int offset);
void Huff_CompressData(byte *data, size_t *length);
void Huff_DecompressData(byte *data, size_t *length);

#endif//NET_MSG_H
```

`halflife/misc/r_studioint.h`:

```h
#if !defined( R_STUDIOINT_H )
#define R_STUDIOINT_H
#if defined( _WIN32 )
#pragma once
#endif

#define STUDIO_INTERFACE_VERSION 1

typedef struct engine_studio_api_s
{
	// Allocate number*size bytes and zero it
	void			*( *Mem_Calloc )				( int number, size_t size );
	// Check to see if pointer is in the cache
	void			*( *Cache_Check )				( struct cache_user_s *c );
	// Load file into cache ( can be swapped out on demand )
	void			( *LoadCacheFile )				( char *path, struct cache_user_s *cu );
	// Retrieve model pointer for the named model
	struct model_s	*( *Mod_ForName )				( const char *name, int crash_if_missing );
	// Retrieve pointer to studio model data block from a model
	void			*( *Mod_Extradata )				( struct model_s *mod );
	// Retrieve indexed model from client side model precache list
	struct model_s	*( *GetModelByIndex )			( int index );
	// Get entity that is set for rendering
	struct cl_entity_s * ( *GetCurrentEntity )		( void );
	// Get referenced player_info_t
	struct player_info_s *( *PlayerInfo )			( int index );
	// Get most recently received player state data from network system
	struct entity_state_s *( *GetPlayerState )		( int index );
	// Get viewentity
	struct cl_entity_s * ( *GetViewEntity )			( void );
	// Get current frame count, and last two timestampes on client
	void			( *GetTimes )					( int *framecount, double *current, double *old );
	// Get a pointer to a cvar by name
	struct cvar_s	*( *GetCvar )					( const char *name );
	// Get current render origin and view vectors ( up, right and vpn )
	void			( *GetViewInfo )				( float *origin, float *upv, float *rightv, float *vpnv );
	// Get sprite model used for applying chrome effect
	struct model_s	*( *GetChromeSprite )			( void );
	// Get model counters so we can incement instrumentation
	void			( *GetModelCounters )			( int **s, int **a );
	// Get software scaling coefficients
	void			( *GetAliasScale )				( float *x, float *y );

	// Get bone, light, alias, and rotation matrices
	float			****( *StudioGetBoneTransform ) ( void );
	float			****( *StudioGetLightTransform )( void );
	float			***( *StudioGetAliasTransform ) ( void );
	float			***( *StudioGetRotationMatrix ) ( void );

	// Set up body part, and get submodel pointers
	void			( *StudioSetupModel )			( int bodypart, void **ppbodypart, void **ppsubmodel );
	// Check if entity's bbox is in the view frustum
	int				( *StudioCheckBBox )			( void );
	// Apply lighting effects to model
	void			( *StudioDynamicLight )			( struct cl_entity_s *ent, struct alight_s *plight );
	void			( *StudioEntityLight )			( struct alight_s *plight );
	void			( *StudioSetupLighting )		( struct alight_s *plighting );

	// Draw mesh vertices
	void			( *StudioDrawPoints )			( void );

	// Draw hulls around bones
	void			( *StudioDrawHulls )			( void );
	// Draw bbox around studio models
	void			( *StudioDrawAbsBBox )			( void );
	// Draws bones
	void			( *StudioDrawBones )			( void );
	// Loads in appropriate texture for model
	void			( *StudioSetupSkin )			( void *ptexturehdr, int index );
	// Sets up for remapped colors
	void			( *StudioSetRemapColors )		( int top, int bottom );
	// Set's player model and returns model pointer
	struct model_s	*( *SetupPlayerModel )			( int index );
	// Fires any events embedded in animation
	void			( *StudioClientEvents )			( void );
	// Retrieve/set forced render effects flags
	int				( *GetForceFaceFlags )			( void );
	void			( *SetForceFaceFlags )			( int flags );
	// Tell engine the value of the studio model header
	void			( *StudioSetHeader )			( void *header );
	// Tell engine which model_t * is being renderered
	void			( *SetRenderModel )				( struct model_s *model );

	// Final state setup and restore for rendering
	void			( *SetupRenderer )				( int rendermode );
	void			( *RestoreRenderer )			( void );

	// Set render origin for applying chrome effect
	void			( *SetChromeOrigin )			( void );

	// True if using D3D/OpenGL
	int				( *IsHardware )					( void );
	
	// Only called by hardware interface
	void			( *GL_StudioDrawShadow )		( void );
	void			( *GL_SetRenderMode )			( int mode );
} engine_studio_api_t;

typedef struct r_studio_interface_s
{
	int				version;
	int				( *StudioDrawModel	)			( int flags );
	int				( *StudioDrawPlayer	)			( int flags, struct entity_state_s *pplayer );
} r_studio_interface_t;

extern r_studio_interface_t *pStudioAPI;

#endif // R_STUDIOINT_H
```

`halflife/misc/sprites.cpp`:

```cpp
#include <windows.h>

#define MAX_SPRITES		500

static char * sprites[MAX_SPRITES];


void add_sprite (int id, const char * sprite)
{
	if ( id >= 0 && id < MAX_SPRITES )
		sprites[id] = _strdup(sprite);
}


const char * sprite_lookup (int id)
{
	if ( id >= 0 && id < MAX_SPRITES && sprites[id] )
		return sprites[id];
	else
		return "unknown";
}


```

`halflife/misc/sprites.h`:

```h
/*  
 * Half-Life client-side generic hook engine.
 * Copyright (c) Vasily Pupkin (clientbot@narod.ru) 2000-2001
 * Copyright (c) Tim Yunaev (tim@lviv.gu.net) 2000-2001
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 * NOTE:
 * GNU license doesn't cover Engine directory.
 * Content of Engine directory is copyrighted (c) 1999, 2000, by Valve LLC
 * and it is licensed under Valve's proprietary license (see original HL SDK).
 *
 * $Id: sprites.h,v 1.2 2001/07/16 11:23:11 vasily Exp $
 */

#ifndef SPRITES_H
#define SPRITES_H


void			add_sprite (int id, const char * sprite);
const char * 	sprite_lookup (int id);


#endif

```

`halflife/parsemsg.cpp`:

```cpp
typedef unsigned char byte;
#define true 1
static byte *gpBuf;
static int giSize;
static int giRead;
static int giBadRead;

void BEGIN_READ( void *buf, int size )
{
	giRead = 0;
	giBadRead = 0;
	giSize = size;
	gpBuf = (byte*)buf;
}

int READ_CHAR( void )
{
	int     c;
	if (giRead + 1 > giSize)
	{
		giBadRead = true;
		return -1;
	}
	c = (signed char)gpBuf[giRead];
	giRead++;
	return c;
}

int READ_BYTE( void )
{
	int     c;
	if (giRead+1 > giSize)
	{
		giBadRead = true;
		return -1;
	}	
	c = (unsigned char)gpBuf[giRead];
	giRead++;
	return c;
}

int READ_SHORT( void )
{
	int     c;
	if (giRead+2 > giSize)
	{
		giBadRead = true;
		return -1;
	}
	c = (short)( gpBuf[giRead] + ( gpBuf[giRead+1] << 8 ) );
	giRead += 2;
	return c;
}

int READ_WORD( void )
{
	return READ_SHORT();
}

int READ_LONG( void )
{
	int     c;
	if (giRead+4 > giSize)
	{
		giBadRead = true;
		return -1;
	}	
 	c = gpBuf[giRead] + (gpBuf[giRead + 1] << 8) + (gpBuf[giRead + 2] << 16) + (gpBuf[giRead + 3] << 24);
	giRead += 4;
	return c;
}

float READ_FLOAT( void )
{
	union
	{
		byte    b[4];
		float   f;
		int     l;
	} dat;
	dat.b[0] = gpBuf[giRead];
	dat.b[1] = gpBuf[giRead+1];
	dat.b[2] = gpBuf[giRead+2];
	dat.b[3] = gpBuf[giRead+3];
	giRead += 4;
	return dat.f;   
}

char* READ_STRING( void )
{
	static char     string[2048];
	int             l,c;
	string[0] = 0;
	l = 0;
	do
	{
		if ( giRead+1 > giSize )
			break;
		c = READ_CHAR();
		if (c == -1 || c == 0)
			break;
		string[l] = c;
		l++;
	} while (l < sizeof(string)-1);
	string[l] = 0;
	return string;
}

float READ_COORD( void )
{
	return (float)(READ_SHORT() * (1.0/8));
}

float READ_ANGLE( void )
{
	return (float)(READ_CHAR() * (360.0/256));
}

float READ_HIRESANGLE( void )
{
	return (float)(READ_SHORT() * (360.0/65536));
}



```

`halflife/parsemsg.h`:

```h
#ifndef _PARSEMSG_
#define _PARSEMSG_

#define ASSERT( x )
void BEGIN_READ( void *buf, int size );
int READ_CHAR( void );
int READ_BYTE( void );
int READ_SHORT( void );
int READ_WORD( void );
int READ_LONG( void );
float READ_FLOAT( void );
char* READ_STRING( void );
float READ_COORD( void );
float READ_ANGLE( void );
float READ_HIRESANGLE( void );

#endif

```

`halflife/vgui/VGUI.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_H
#define VGUI_H

//If you are going to add stuff to the vgui core...
//
//Keep it simple.
//
//Never put code in a header.
//
//The name of the class is the name of the the file
//
//Each class gets its own .cpp file for its definition and a .h for its header. Helper
//classes can be used but only within the .cpp and not referenceable from anywhere else.
//
//Don't add unneeded files. Keep the API clean.
//
//No platform specific code in vgui\lib-src\vgui dir. Code in vgui\lib-src\vgui should 
//only include from vgui\include or standard C includes. ie, if I see windows.h included
//anywhere but vgui\lib-src\win32 I will hunt you down and kill you. Don't give me any crap
//that mfc is platform inspecific.
//
//Always use <> and not "" for includes
//
//Use minimum dependencies in headers. Don't include another header if you can get away
//with forward declaring (which is usually the case)
//
//No macros in headers. They are tools of satan. This also means no use of DEFINEs, use enum
//
//Minimize global functions
//
//No global variables.
//
//Panel is getting pretty plump, try and avoid adding junk to it if you can

//TODO: Look and Feel support
//		add Panel::setPaintProxy, if _paintProxy exists, it calls _paintProxy->paint 
//		instead of Panel::paint. Components should implement their painting in a seperate
//      plugin class. Perhaps to encourage this, Panel::paint should just go away completely
//      The other option is to have Panel have the interface Paintable
//      class Paintable
//      {
//      public:
//			virtual void paint()=0;
//      };
//      Then a component can implement its paint in the class itself and then call 
//		setPaintProxy(this). If this is the case _paintProxy->paint should always be called
//      and never Panel::paint from within paintTraverse
//TODO: Figure out the 'Valve' Look and Feel and implement that instead of a the Java one
//TODO: Determine ownership policy for Borders, Layouts, etc..
//TODO: tooltips support
//TODO: ComboKey (hot key support)
//TODO: add Background.cpp, remove paintBackground from all components
//		Panel implements setBackground, Panel::paintBackground calls _background->paintBackground
//		similiar to the way Border works. 
//TODO: Builtin components should never overide paintBackground, only paint
//TODO: All protected members should be converted to private
//TODO: All member variables should be moved to the top of the class prototype
//TODO: All private methods should be prepended with private
//TODO: Use of word internal in method names is not consistent and confusing
//TODO: Cleanup so bullshit publics are properly named, maybe even figure out
//      a naming convention for them
//TODO: Breakup InputSignal into logical pieces
//TODO: Button is in a state of disarray, it should have ButtonModel support
//TODO: get rid of all the stupid strdup laziness, convert to vgui_strdup
//TODO: actually figure out policy on String and implement it consistently
//TODO: implement createLayoutInfo for other Layouts than need it
//TODO: BorderLayout should have option for a null LayoutInfo defaulting to center
//TODO: SurfaceBase should go away, put it in Surface
//TODO: ActionSignals and other Signals should just set a flag when they fire.
//		then App can come along later and fire all the signals
//TODO: Change all method naming to starting with a capital letter.

#ifdef _WIN32
#define VGUIAPI //__declspec( dllexport )
#else
# define VGUIAPI  __attribute__ ((visibility("default")))
#include "sys/types.h" // size_t define
#endif

#define null 0L

typedef unsigned char  uchar;
typedef unsigned short ushort;
typedef unsigned int   uint;
typedef unsigned long  ulong;

namespace vgui
{

VGUIAPI void  vgui_setMalloc(void *(*malloc)(size_t size) );
VGUIAPI void  vgui_setFree(void (*free)(void* memblock));
VGUIAPI void  vgui_strcpy(char* dst,int dstLen,const char* src);
VGUIAPI char* vgui_strdup(const char* src);
VGUIAPI int   vgui_printf(const char* format,...);
VGUIAPI int   vgui_dprintf(const char* format,...);
VGUIAPI int   vgui_dprintf2(const char* format,...);

}

#endif


```

`halflife/vgui/VGUI_ActionSignal.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_ACTIONSIGNAL_H
#define VGUI_ACTIONSIGNAL_H

#include "VGUI.h"

/*

TODO: maybe try something like this..

class VGUIAPI ActionSignal
{
};

class VGUIAPI ActionSignalSimple : public ActionSignal
{
public:
	virtual void actionPerformed(Panel* panel)=0;
};

class VGUIAPI ActionSignalInt : public ActionSignal
{
public:
	virtual void actionPerformed(int value,Panel* panel)=0;
};


DefaultButtonModel would implement:

virtual void addActionSignal(ActionSignal* s)
{
	if(s!=null)
	{
		_actionSignalDar.putElement(s);
	}
}

virtual void fireActionSignal()
{
	for(int i=0;i<_actionSignalDar.getCount();i++)
	{
		ActionSignal* signal=_actionSignalDar[i];
		
		ActionSignalSimple* ss=dynamic_cast<ActionSignalSimple*>(signal);
		if(ss!=null)
		{
			ss->actionPerformed(this);
		}
	
		ActionSignalCommand* si=dynamic_cast<ActionSignalInt*>(signal);
		if(si!=null)
		{
			si->actionPerformed(_intValue,this);
		}
	}
}


*/

#include "VGUI.h"

namespace vgui
{

class Panel;

class VGUIAPI ActionSignal
{
public:
	virtual void actionPerformed(Panel* panel)=0;
};

}

#endif



```

`halflife/vgui/VGUI_App.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_APP_H
#define VGUI_APP_H

#include "VGUI.h"
#include "VGUI_MouseCode.h"
#include "VGUI_KeyCode.h"
#include "VGUI_Dar.h"
#include "VGUI_Cursor.h"

namespace vgui
{

class Panel;
class TickSignal;
class Scheme;
class TickSignal;
class SurfaceBase;

class VGUIAPI App
{
public:
	App();
	App(bool externalMain);
public:
	static App* getInstance();
	//TODO: the public and public bullshit are all messed up, need to organize
	//TODO: actually all of the access needs to be properly thought out while you are at it
public:
	virtual void    start();
	virtual void    stop();
	virtual void    externalTick();
	virtual bool    wasMousePressed(MouseCode code,Panel* panel);
	virtual bool    wasMouseDoublePressed(MouseCode code,Panel* panel);
	virtual bool    isMouseDown(MouseCode code,Panel* panel);
	virtual bool    wasMouseReleased(MouseCode code,Panel* panel);
	virtual bool    wasKeyPressed(KeyCode code,Panel* panel);
	virtual bool    isKeyDown(KeyCode code,Panel* panel);
	virtual bool    wasKeyTyped(KeyCode code,Panel* panel);
	virtual bool    wasKeyReleased(KeyCode code,Panel* panel);
	virtual void    addTickSignal(TickSignal* s);
	virtual void    setCursorPos(int x,int y);
	virtual void    getCursorPos(int& x,int& y);
	virtual void    setMouseCapture(Panel* panel);
	virtual void    setMouseArena(int x0,int y0,int x1,int y1,bool enabled);
	virtual void    setMouseArena(Panel* panel);
	virtual void    requestFocus(Panel* panel); 
	virtual Panel*  getFocus();
	virtual void    repaintAll();
	virtual void    setScheme(Scheme* scheme);
	virtual Scheme* getScheme();
	virtual void    enableBuildMode();
	virtual long    getTimeMillis();
	virtual char    getKeyCodeChar(KeyCode code,bool shifted);
	virtual void    getKeyCodeText(KeyCode code,char* buf,int buflen);
	virtual int     getClipboardTextCount();
	virtual void    setClipboardText(const char* text,int textLen);
	virtual int     getClipboardText(int offset,char* buf,int bufLen);
	virtual void    reset();
	virtual void    internalSetMouseArena(int x0,int y0,int x1,int y1,bool enabled);
	virtual bool    setRegistryString(const char* key,const char* value);
	virtual bool    getRegistryString(const char* key,char* value,int valueLen);
	virtual bool    setRegistryInteger(const char* key,int value);
	virtual bool    getRegistryInteger(const char* key,int& value);
	virtual void    setCursorOveride(Cursor* cursor);
	virtual Cursor* getCursorOveride();
	virtual void    setMinimumTickMillisInterval(int interval);
public: //bullshit public stuff
	virtual void main(int argc,char* argv[])=0;
	virtual void run(); 
	virtual void internalCursorMoved(int x,int y,SurfaceBase* surfaceBase); //expects input in surface space
	virtual void internalMousePressed(MouseCode code,SurfaceBase* surfaceBase);
	virtual void internalMouseDoublePressed(MouseCode code,SurfaceBase* surfaceBase);
	virtual void internalMouseReleased(MouseCode code,SurfaceBase* surfaceBase);
	virtual void internalMouseWheeled(int delta,SurfaceBase* surfaceBase);
	virtual void internalKeyPressed(KeyCode code,SurfaceBase* surfaceBase);
	virtual void internalKeyTyped(KeyCode code,SurfaceBase* surfaceBase);
	virtual void internalKeyReleased(KeyCode code,SurfaceBase* surfaceBase);
private:
	virtual void init();
	virtual void updateMouseFocus(int x,int y,SurfaceBase* surfaceBase);
	virtual void setMouseFocus(Panel* newMouseFocus);
protected: 
	virtual void surfaceBaseCreated(SurfaceBase* surfaceBase);
	virtual void surfaceBaseDeleted(SurfaceBase* surfaceBase);
	virtual void platTick();
	virtual void internalTick();
protected:
	static App* _instance;
protected:
	bool              _running;
	bool              _externalMain;
	Dar<SurfaceBase*> _surfaceBaseDar;
	Panel*            _keyFocus;
	Panel*            _oldMouseFocus;
	Panel*            _mouseFocus;
	Panel*            _mouseCapture;
	Panel*            _wantedKeyFocus;
	bool              _mousePressed[MOUSE_LAST];
	bool              _mouseDoublePressed[MOUSE_LAST];
	bool              _mouseDown[MOUSE_LAST];
	bool              _mouseReleased[MOUSE_LAST];
	bool              _keyPressed[KEY_LAST];
	bool              _keyTyped[KEY_LAST];
	bool              _keyDown[KEY_LAST];
	bool              _keyReleased[KEY_LAST];
	Dar<TickSignal*>  _tickSignalDar;
	Scheme*           _scheme;
	bool              _buildMode;
	bool              _wantedBuildMode;
	Panel*            _mouseArenaPanel;
	Cursor*           _cursor[Cursor::dc_last];
	Cursor*           _cursorOveride;
private:
	long              _nextTickMillis;
	long              _minimumTickMillisInterval;
	friend class SurfaceBase;
};
}

#endif




```

`halflife/vgui/VGUI_Bitmap.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_BITMAP_H
#define VGUI_BITMAP_H

#include "VGUI.h"
#include "VGUI_Image.h"

namespace vgui
{

class Panel;

class VGUIAPI Bitmap : public Image
{
private:
	int         _id;
	bool        _uploaded;
public:
	Bitmap();
protected:
	virtual void setSize(int wide,int tall);
	virtual void setRGBA(int x,int y,uchar r,uchar g,uchar b,uchar a);
public:
	virtual void paint(Panel* panel);
protected:
	uchar* _rgba;
};

}

#endif
```

`halflife/vgui/VGUI_BitmapTGA.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_BITMAPTGA_H
#define VGUI_BITMAPTGA_H

#include "VGUI_Bitmap.h"

namespace vgui
{

class Panel;
class InputStream;

class VGUIAPI BitmapTGA : public Bitmap
{
public:
	BitmapTGA(InputStream* is,bool invertAlpha);
private:
	virtual bool loadTGA(InputStream* is,bool invertAlpha);
};

}

#endif
```

`halflife/vgui/VGUI_Border.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_BORDER_H
#define VGUI_BORDER_H

#include "VGUI.h"
#include "VGUI_Image.h"

//TODO: all borders should be titled

namespace vgui
{

class Panel;

class VGUIAPI Border : public Image
{
public:
	Border();
	Border(int left,int top,int right,int bottom);
public:
	virtual void setInset(int left,int top,int right,int bottom);
	virtual void getInset(int& left,int& top,int& right,int& bottom);
protected:
	virtual void drawFilledRect(int x0,int y0,int x1,int y1);
	virtual void drawOutlinedRect(int x0,int y0,int x1,int y1);
	virtual void drawSetTextPos(int x,int y);
	virtual void drawPrintText(int x,int y,const char* str,int strlen);
	virtual void drawPrintChar(int x,int y,char ch);
protected:
	int _inset[4];
private:
	Panel* _panel;
friend class Panel;
friend class BorderPair;
};

}

#endif
```

`halflife/vgui/VGUI_BorderLayout.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_BORDERLAYOUT_H
#define VGUI_BORDERLAYOUT_H

#include "VGUI.h"
#include "VGUI_Layout.h"

namespace vgui
{

class LayoutInfo;

class VGUIAPI BorderLayout : public Layout
{
public:
	enum Alignment
	{
		a_center=0,
		a_north,
		a_south,
		a_east,
		a_west,
	};
private:
	int _inset;
public:
	BorderLayout(int inset);
public:
	virtual void        performLayout(Panel* panel);
	virtual LayoutInfo* createLayoutInfo(Alignment alignment);
};

}

#endif






```

`halflife/vgui/VGUI_BorderPair.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_BORDERPAIR_H
#define VGUI_BORDERPAIR_H

#include "VGUI.h"
#include "VGUI_Border.h"

namespace vgui
{

class Panel;

class VGUIAPI BorderPair : public Border
{
public:
	BorderPair(Border* border0,Border* border1);
public:
	virtual void doPaint(Panel* panel);
protected:
	virtual void paint(Panel* panel);
protected:
	Border* _border[2];
};

}

#endif
```

`halflife/vgui/VGUI_BuildGroup.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_BUILDGROUP_H
#define VGUI_BUILDGROUP_H

#include "VGUI.h"
#include "VGUI_Dar.h"
#include "VGUI_MouseCode.h"
#include "VGUI_KeyCode.h"

namespace vgui
{

enum KeyCode;
enum MouseCode;
class Panel;
class Cursor;
class ChangeSignal;

class VGUIAPI BuildGroup
{
private:	
	bool      _enabled;
	int       _snapX;
	int       _snapY;
	Cursor*   _cursor_sizenwse;
	Cursor*   _cursor_sizenesw;
	Cursor*   _cursor_sizewe;
	Cursor*   _cursor_sizens;
	Cursor*   _cursor_sizeall;
	bool      _dragging;
	MouseCode _dragMouseCode;
	int       _dragStartPanelPos[2];
	int       _dragStartCursorPos[2];
	Panel*    _currentPanel;
	Dar<ChangeSignal*> _currentPanelChangeSignalDar;
	Dar<Panel*> _panelDar;
	Dar<char*>  _panelNameDar;
public:
	BuildGroup();
public:
	virtual void   setEnabled(bool state);
	virtual bool   isEnabled();
	virtual void   addCurrentPanelChangeSignal(ChangeSignal* s);
	virtual Panel* getCurrentPanel();
	virtual void   copyPropertiesToClipboard();
private:
	virtual void applySnap(Panel* panel);
	virtual void fireCurrentPanelChangeSignal();
protected:
	friend class Panel;
	virtual void    panelAdded(Panel* panel,const char* panelName);
	virtual void    cursorMoved(int x,int y,Panel* panel);
	virtual void    mousePressed(MouseCode code,Panel* panel);
	virtual void    mouseReleased(MouseCode code,Panel* panel);
	virtual void    mouseDoublePressed(MouseCode code,Panel* panel);
	virtual void    keyTyped(KeyCode code,Panel* panel);
	virtual Cursor* getCursor(Panel* panel);
};

}

#endif
```

`halflife/vgui/VGUI_Button.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_BUTTON_H
#define VGUI_BUTTON_H

#include "VGUI.h"
#include "VGUI_Label.h"
#include "VGUI_Dar.h"

namespace vgui
{

enum MouseCode;
class ButtonController;
class ButtonGroup;
class ActionSignal;

//TODO: Button should be derived from an AbstractButton
class VGUIAPI Button : public Label
{
public:
	Button(const char* text,int x,int y,int wide,int tall);
	Button(const char* text,int x,int y);
private:
	void init();
public:
	virtual void setSelected(bool state);
	virtual void setSelectedDirect(bool state);
	virtual void setArmed(bool state);
	virtual bool isSelected();
	virtual void doClick();
	virtual void addActionSignal(ActionSignal* s);
	virtual void setButtonGroup(ButtonGroup* buttonGroup);
	virtual bool isArmed();
	virtual void setButtonBorderEnabled(bool state);
	virtual void setMouseClickEnabled(MouseCode code,bool state);
	virtual bool isMouseClickEnabled(MouseCode code);
	virtual void fireActionSignal();
	virtual Panel* createPropertyPanel();
protected:
	virtual void setButtonController(ButtonController* _buttonController);
	virtual void paintBackground();
protected:
	char*              _text;
	bool               _armed;
	bool               _selected;
	bool               _buttonBorderEnabled;
	Dar<ActionSignal*> _actionSignalDar;
	int                _mouseClickMask;
	ButtonGroup*       _buttonGroup;
	ButtonController*  _buttonController;
};

}

#endif
```

`halflife/vgui/VGUI_ButtonController.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_BUTTONCONTROLLER_H
#define VGUI_BUTTONCONTROLLER_H

#include "VGUI.h"

namespace vgui
{

class Button;

class VGUIAPI ButtonController
{
public:	
	virtual void addSignals(Button* button)=0;
	virtual void removeSignals(Button* button)=0;
};

}

#endif

```

`halflife/vgui/VGUI_ButtonGroup.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_BUTTONGROUP_H
#define VGUI_BUTTONGROUP_H

#include "VGUI.h"
#include "VGUI_Dar.h"

namespace vgui
{

class Button;

class VGUIAPI ButtonGroup
{
public:
	virtual void addButton(Button* button);
	virtual void setSelected(Button* button);
protected:
	Dar<Button*> _buttonDar;
};

}

#endif
```

`halflife/vgui/VGUI_ChangeSignal.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_CHANGESIGNAL_H
#define VGUI_CHANGESIGNAL_H

#include "VGUI.h"

namespace vgui
{

class Panel;

class VGUIAPI ChangeSignal
{
public:
	virtual void valueChanged(Panel* panel)=0;
};

}

#endif
```

`halflife/vgui/VGUI_CheckButton.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_CHECKBUTTON_H
#define VGUI_CHECKBUTTON_H

#include "VGUI.h"
#include "VGUI_ToggleButton.h"

namespace vgui
{

class VGUIAPI CheckButton : public ToggleButton
{
public:
	CheckButton(const char* text,int x,int y,int wide,int tall);
	CheckButton(const char* text,int x,int y);
protected:
	virtual void paintBackground();
};

}

#endif
```

`halflife/vgui/VGUI_Color.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_COLOR_H
#define VGUI_COLOR_H

#include "VGUI.h"
#include "VGUI_Scheme.h"

//TODO: rename getColor(r,g,b,a) to getRGBA(r,g,b,a)
//TODO: rename setColor(r,g,b,a) to setRGBA(r,g,b,a)
//TODO: rename getColor(sc) to getSchemeColor(sc)
//TODO: rename setColor(sc) to setSchemeColor(sc)

namespace vgui
{

class VGUIAPI Color
{
private:
	uchar               _color[4];
	Scheme::SchemeColor _schemeColor;
public:
	Color();
	Color(int r,int g,int b,int a);
	Color(Scheme::SchemeColor sc);
private:
	virtual void init();
public:
	virtual void setColor(int r,int g,int b,int a);
	virtual void setColor(Scheme::SchemeColor sc);
	virtual void getColor(int& r,int& g,int& b,int& a);
	virtual void getColor(Scheme::SchemeColor& sc);
	virtual int  operator[](int index);
};

}


#endif

```

`halflife/vgui/VGUI_ComboKey.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_COMBOKEY_H
#define VGUI_COMBOKEY_H

#include "VGUI.h"

namespace vgui
{

enum KeyCode;

class ComboKey
{
public:
	ComboKey(KeyCode code,KeyCode modifier);
public:
	bool isTwoCombo(KeyCode code,KeyCode modifier);
protected:
	bool check(KeyCode code);
protected:
	KeyCode _keyCode[2];
friend class Panel;
};

}


#endif
```

`halflife/vgui/VGUI_ConfigWizard.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_CONFIGWIZARD_H
#define VGUI_CONFIGWIZARD_H

#include "VGUI.h"
#include "VGUI_Panel.h"

namespace vgui
{

class TreeFolder;
class Panel;
class Button;

class VGUIAPI ConfigWizard : public Panel
{
public:
	ConfigWizard(int x,int y,int wide,int tall);
public:
	virtual void        setSize(int wide,int tall);
	virtual Panel*      getClient();
	virtual TreeFolder* getFolder();
protected:
	TreeFolder* _treeFolder;
	Panel*      _client;
	Button*     _okButton;
	Button*     _cancelButton;
	Button*     _applyButton;
	Button*     _helpButton;
};

}

#endif
```

`halflife/vgui/VGUI_Cursor.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_CURSOR_H
#define VGUI_CURSOR_H

#include "VGUI.h"

namespace vgui
{

class Bitmap;

class VGUIAPI Cursor
{
public:
	enum DefaultCursor
	{
		dc_user,
		dc_none,
		dc_arrow,
		dc_ibeam,
		dc_hourglass,
		dc_crosshair,
		dc_up,
		dc_sizenwse,
		dc_sizenesw,
		dc_sizewe,
		dc_sizens,
		dc_sizeall,
		dc_no,
		dc_hand,
		dc_last,
	};
private:
	int           _hotspot[2];
	Bitmap*       _bitmap;
	DefaultCursor _dc;
public:
	Cursor(DefaultCursor dc);
	Cursor(Bitmap* bitmap,int hotspotX,int hotspotY);
public:
	virtual void getHotspot(int& x,int& y);
private:
	virtual void privateInit(Bitmap* bitmap,int hotspotX,int hotspotY);
public:
	virtual Bitmap*       getBitmap();
	virtual DefaultCursor getDefaultCursor();
};

}

#endif
```

`halflife/vgui/VGUI_Dar.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_DAR_H
#define VGUI_DAR_H

#include "stdlib.h"
#include "string.h"
#include "VGUI.h"



namespace vgui
{

//Simple lightweight dynamic array implementation
template<class ELEMTYPE> class VGUIAPI Dar
{
public:
	Dar()
	{
		_count=0;
		_capacity=0;
		_data=null;
		ensureCapacity(4);
	}
	Dar(int initialCapacity)
	{
		_count=0;
		_capacity=0;
		_data=null;
		ensureCapacity(initialCapacity);
	}
public:
	void ensureCapacity(int wantedCapacity)
	{
		if(wantedCapacity<=_capacity){return;}

		//double capacity until it is >= wantedCapacity
		//this could be done with math, but iterative is just so much more fun
		int newCapacity=_capacity;
		if(newCapacity==0){newCapacity=1;}
		while(newCapacity<wantedCapacity){newCapacity*=2;}

		//allocate and zero newData
		ELEMTYPE* newData=new ELEMTYPE[newCapacity]; 
		if(newData==null){exit(0);return;}
		memset(newData,0,sizeof(ELEMTYPE)*newCapacity);
		_capacity=newCapacity;
   
		//copy data into newData
		for(int i=0;i<_count;i++){newData[i]=_data[i];}

		delete[] _data;
		_data=newData;
	}
	void setCount(int count)
	{
		if((count<0)||(count>_capacity))
		{
			return;
		}
		_count=count;
	}
	int getCount()
	{
		return _count;
	}
	void addElement(ELEMTYPE elem)
	{
		ensureCapacity(_count+1);
		_data[_count]=elem;
		_count++;
	}
	bool hasElement(ELEMTYPE elem)
	{
		for(int i=0;i<_count;i++)
		{
			if(_data[i]==elem)
			{
				return true;
			}
		}
	return false;
	}
	void putElement(ELEMTYPE elem)
	{
		if(hasElement(elem))
		{
			return;
		}
		addElement(elem);
	}
	void insertElementAt(ELEMTYPE elem,int index)
	{
		if((index<0)||(index>_count))
		{
			return;
		}
		if((index==_count)||(_count==0))
		{
			addElement(elem);
		}
		else
		{
			addElement(elem); //just to make sure it is big enough
			for(int i=_count-1;i>index;i--)
			{
				_data[i]=_data[i-1];
			}
			_data[index]=elem;
		}
	}
	void setElementAt(ELEMTYPE elem,int index)
	{
		if((index<0)||(index>=_count))
		{
			return;
		}
		_data[index]=elem;
	}
	void removeElementAt(int index)
	{
		if((index<0)||(index>=_count))
		{
			return;
		}
   
		//slide everything to the right of index, left one.
		for(int i=index;i<(_count-1);i++)
		{
			_data[i]=_data[i+1];
		}
		_count--;
	} 
	void removeElement(ELEMTYPE elem)
	{
		for(int i=0;i<_count;i++)
		{
			if(_data[i]==elem)
			{
				removeElementAt(i);
				break;
			}
		}
	}
	void removeAll()
	{
		_count=0;
	}
	ELEMTYPE operator[](int index)
	{
		if((index<0)||(index>=_count))
		{
			return null;
		}
		return _data[index];
	}
protected:
	int       _count;
	int       _capacity;
	ELEMTYPE* _data;
};

#ifdef _WIN32
//forward referencing all the template types used so they get exported
template class VGUIAPI Dar<char>;
template class VGUIAPI Dar<char*>;
template class VGUIAPI Dar<int>;
template class VGUIAPI Dar<class Button*>;
template class VGUIAPI Dar<class SurfaceBase*>;
template class VGUIAPI Dar<class InputSignal*>;
template class VGUIAPI Dar<class FocusChangeSignal*>;
template class VGUIAPI Dar<class FrameSignal*>;
template class VGUIAPI Dar<class ActionSignal*>;
template class VGUIAPI Dar<class IntChangeSignal*>;
template class VGUIAPI Dar<class TickSignal*>;
template class VGUIAPI Dar<class Dar<char>*>;
template class VGUIAPI Dar<class Frame*>;
template class VGUIAPI Dar<class DesktopIcon*>;
template class VGUIAPI Dar<class ChangeSignal*>;
template class VGUIAPI Dar<class Panel*>;
template class VGUIAPI Dar<class Label*>;
template class VGUIAPI Dar<class RepaintSignal*>;
#endif

}


#endif
```

`halflife/vgui/VGUI_DataInputStream.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_DATAINPUTSTREAM_H
#define VGUI_DATAINPUTSTREAM_H

#include "VGUI.h"
#include "VGUI_InputStream.h"

namespace vgui
{

class VGUIAPI DataInputStream : virtual public InputStream
{
private:
	InputStream* _is;
public:
	DataInputStream(InputStream* is);
public:
	virtual void  seekStart(bool& success);
	virtual void  seekRelative(int count,bool& success);
	virtual void  seekEnd(bool& success);
	virtual int   getAvailable(bool& success);
	//virtual uchar readUChar(bool& success);
	virtual void  readUChar(uchar* buf,int count,bool& success);
	virtual void  close(bool& success);
	virtual void  close();
public:
	virtual bool   readBool(bool& success);
	virtual char   readChar(bool& success);
	virtual uchar  readUChar(bool& success);
	virtual short  readShort(bool& success);
	virtual ushort readUShort(bool& success);
	virtual int    readInt(bool& success);
	virtual uint   readUInt(bool& success);
	virtual long   readLong(bool& success);
	virtual ulong  readULong(bool& success);
	virtual float  readFloat(bool& success);
	virtual double readDouble(bool& success);
	virtual void   readLine(char* buf,int bufLen,bool& success);
};

}

#endif
```

`halflife/vgui/VGUI_Desktop.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_DESKTOP_H
#define VGUI_DESKTOP_H

#include "VGUI.h"
#include "VGUI_Dar.h"
#include "VGUI_Panel.h"

namespace vgui
{

class DesktopIcon;
class TaskBar;

class VGUIAPI Desktop : public Panel
{
public:
	Desktop(int x,int y,int wide,int tall);
public:
	virtual void    setSize(int wide,int tall);
	virtual void    iconActivated(DesktopIcon* icon);
	virtual void    addIcon(DesktopIcon* icon);
	virtual void    arrangeIcons();
	virtual Panel*  getBackground();
	virtual Panel*  getForeground();
protected:
	Panel*            _background;
	Panel*            _foreground;
	TaskBar*          _taskBar;
	Dar<DesktopIcon*> _desktopIconDar;
	int           	  _cascade[2];
};

}

#endif
```

`halflife/vgui/VGUI_DesktopIcon.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_DESKTOPICON_H
#define VGUI_DESKTOPICON_H

#include "VGUI.h"
#include "VGUI_Panel.h"

namespace vgui
{

class MiniApp;
class Image;
class Desktop;

class VGUIAPI DesktopIcon : public Panel
{
public:
	DesktopIcon(MiniApp* miniApp,Image* image);
public:
	virtual void doActivate();
	virtual void setImage(Image* image);
public: //bullshit public
	virtual void     setDesktop(Desktop* desktop);
	virtual MiniApp* getMiniApp();
protected:
	virtual void paintBackground();
protected:
	Desktop* _desktop;
	MiniApp* _miniApp;
	Image*   _image;
};

}

#endif
```

`halflife/vgui/VGUI_EditPanel.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_EDITPANEL_H
#define VGUI_EDITPANEL_H

#include "VGUI.h"
#include "VGUI_Panel.h"
#include "VGUI_Dar.h"

namespace vgui
{

class Font;

class VGUIAPI EditPanel : public Panel
{
public:
	EditPanel(int x,int y,int wide,int tall);
public:
	virtual void doCursorUp();
	virtual void doCursorDown();
	virtual void doCursorLeft();
	virtual void doCursorRight();
	virtual void doCursorToStartOfLine();
	virtual void doCursorToEndOfLine();
	virtual void doCursorInsertChar(char ch);
	virtual void doCursorBackspace();
	virtual void doCursorNewLine();
	virtual void doCursorDelete();
	virtual void doCursorPrintf(char* format,...);
	virtual int  getLineCount();
	virtual int  getVisibleLineCount();
	virtual void setCursorBlink(bool state);
	virtual void setFont(Font* font);
	virtual void getText(int lineIndex, int offset,char* buf,int bufLen);

public: //bullshit public
	void getCursorBlink(bool& blink,int& nextBlinkTime);
protected:
	virtual void       paintBackground();
	virtual void       paint();
	virtual void       addLine();
	virtual Dar<char>* getLine(int lineIndex);
	virtual void       setChar(Dar<char>* lineDar,int x,char ch,char fill);
	virtual void       setChar(Dar<char>* lineDar,int x,char ch);
	virtual void       shiftLineLeft(Dar<char>* lineDar,int x,int count);
	virtual void       shiftLineRight(Dar<char>* lineDar,int x,int count);
private:
	virtual int        spatialCharOffsetBetweenTwoLines(Dar<char>* srcDar,Dar<char>* dstDar,int x);
protected:
	Dar<Dar<char>*> _lineDarDar;
	int             _cursor[2];
	bool            _cursorBlink;
	int             _cursorNextBlinkTime;
	Font*           _font;
};

}

#endif
```

`halflife/vgui/VGUI_EtchedBorder.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_ETCHEDBORDER_H
#define VGUI_ETCHEDBORDER_H

#include "VGUI.h"
#include "VGUI_Border.h"

namespace vgui
{

class Panel;

class VGUIAPI EtchedBorder : public Border
{
public:
	EtchedBorder();
protected:
	virtual void paint(Panel* panel);
};

}

#endif
```

`halflife/vgui/VGUI_FileInputStream.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_FILEINPUTSTREAM_H
#define VGUI_FILEINPUTSTREAM_H

//TODO : figure out how to get stdio out of here, I think std namespace is broken for FILE for forward declaring does not work in vc6

#include "stdio.h" 
#include "VGUI_InputStream.h"

namespace vgui
{

class VGUIAPI FileInputStream : public InputStream
{
private:
	FILE* _fp;
public:
	FileInputStream(const char* fileName,bool textMode);
public:
	virtual void  seekStart(bool& success);
	virtual void  seekRelative(int count,bool& success);
	virtual void  seekEnd(bool& success);
	virtual int   getAvailable(bool& success);
	virtual uchar readUChar(bool& success);
	virtual void  readUChar(uchar* buf,int count,bool& success);
	virtual void  close(bool& success);
	virtual void  close();
};

}

#endif

```

`halflife/vgui/VGUI_FlowLayout.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_FLOWLAYOUT_H
#define VGUI_FLOWLAYOUT_H

#include "VGUI.h"
#include "VGUI_Layout.h"

namespace vgui
{

class VGUIAPI FlowLayout : public Layout
{
private:
	int _hgap;
public:
	FlowLayout(int hgap);
public:
	virtual void performLayout(Panel* panel);
};

}

#endif
```

`halflife/vgui/VGUI_FocusChangeSignal.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_FOCUSCHANGESIGNAL_H
#define VGUI_FOCUSCHANGESIGNAL_H

#include "VGUI.h"

namespace vgui
{

class Panel;

class VGUIAPI FocusChangeSignal
{
public:
	virtual void focusChanged(bool lost,Panel* panel)=0;
};

}

#endif
```

`halflife/vgui/VGUI_FocusNavGroup.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_FOCUSNAVGROUP_H
#define VGUI_FOCUSNAVGROUP_H

#include "VGUI.h"
#include "VGUI_Dar.h"

namespace vgui
{

class Panel;

class VGUIAPI FocusNavGroup
{
public:
	FocusNavGroup();
protected:
	virtual void addPanel(Panel* panel);
	virtual void requestFocusPrev();
	virtual void requestFocusNext();
	virtual void setCurrentPanel(Panel* panel);
protected:
	Dar<Panel*> _panelDar;
	int         _currentIndex;
friend class Panel;
};
}

#endif
```

`halflife/vgui/VGUI_Font.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_FONT_H
#define VGUI_FONT_H

#include "VGUI.h"

namespace vgui
{

class BaseFontPlat;

//TODO: cursors and fonts should work like gl binds
class VGUIAPI Font
 {
 public:
  Font(const char* name,int tall,int wide,float rotation,int weight,bool italic,bool underline,bool strikeout,bool symbol);
  // If pFileData is non-NULL, then it will try to load the 32-bit (RLE) TGA file. If that fails,
  // it will create the font using the specified parameters.
  // pUniqueName should be set if pFileData and fileDataLen are set so it can determine if a font is already loaded.
  Font(const char* name,void *pFileData,int fileDataLen, int tall,int wide,float rotation,int weight,bool italic,bool underline,bool strikeout,bool symbol);
 private:
  virtual void init(const char* name,void *pFileData,int fileDataLen, int tall,int wide,float rotation,int weight,bool italic,bool underline,bool strikeout,bool symbol);
 public:
  BaseFontPlat* getPlat();
  virtual void getCharRGBA(int ch,int rgbaX,int rgbaY,int rgbaWide,int rgbaTall,uchar* rgba);
  virtual void getCharABCwide(int ch,int& a,int& b,int& c);
  virtual void getTextSize(const char* text,int& wide,int& tall);
  virtual int  getTall();
#ifndef _WIN32
  virtual int getWide();
#endif
  virtual int  getId();
 protected:
  char*			_name;
  BaseFontPlat*	_plat;
  int			_id;
 friend class Surface;
 };


void Font_Reset();

}

#endif
```

`halflife/vgui/VGUI_Frame.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_FRAME_H
#define VGUI_FRAME_H

#include "VGUI.h"
#include "VGUI_Panel.h"
#include "VGUI_Dar.h"

namespace vgui
{

class Button;
class FrameSignal;

class VGUIAPI Frame : public Panel
 {
 public:
  Frame(int x,int y,int wide,int tall);
 public:
  virtual void   setSize(int wide,int tall);
  virtual void   setInternal(bool state);
  virtual void   paintBackground();
  virtual bool   isInternal();
  virtual Panel* getClient();
  virtual void   setTitle(const char* title);
  virtual void   getTitle(char* buf,int bufLen);
  virtual void	 setMoveable(bool state);
  virtual void   setSizeable(bool state);
  virtual bool   isMoveable();
  virtual bool   isSizeable();
  virtual void   addFrameSignal(FrameSignal* s);
  virtual void   setVisible(bool state);
  virtual void   setMenuButtonVisible(bool state);
  virtual void   setTrayButtonVisible(bool state);
  virtual void   setMinimizeButtonVisible(bool state);
  virtual void   setMaximizeButtonVisible(bool state);
  virtual void   setCloseButtonVisible(bool state);
 public: //bullshit public
  virtual void fireClosingSignal();
  virtual void fireMinimizingSignal();
 protected:
  char*             _title;
  bool              _internal;
  bool              _sizeable;
  bool              _moveable;
  Panel*            _topGrip;
  Panel*            _bottomGrip;
  Panel*            _leftGrip;
  Panel*            _rightGrip;
  Panel*            _topLeftGrip;
  Panel*            _topRightGrip;
  Panel*            _bottomLeftGrip;
  Panel*            _bottomRightGrip;
  Panel*            _captionGrip;
  Panel*            _client;
  Button*           _trayButton;
  Button*           _minimizeButton;
  Button*           _maximizeButton;
  Button*           _closeButton;
  Button*           _menuButton;
  Dar<FrameSignal*> _frameSignalDar;
  Frame*            _resizeable;
 };

}

#endif

```

`halflife/vgui/VGUI_FrameSignal.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_FRAMESIGNAL_H
#define VGUI_FRAMESIGNAL_H

#include "VGUI.h"

namespace vgui
{

class Frame;

class VGUIAPI FrameSignal
{
public:
	virtual void closing(Frame* frame)=0;
	virtual void minimizing(Frame* frame,bool toTray)=0;
};

}

#endif
```

`halflife/vgui/VGUI_GridLayout.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_GRIDLAYOUT_H
#define VGUI_GRIDLAYOUT_H

#include "VGUI.h"
#include "VGUI_Layout.h"

namespace vgui
{

/*
class VGUIAPI GridLayout : public Layout
{
public:
	GridLayout(int rows,int cols,int hgap,int vgap);
protected:
	int _rows;
	int _cols;
};
*/

}

#endif
```

`halflife/vgui/VGUI_HeaderPanel.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_HEADERPANEL_H
#define VGUI_HEADERPANEL_H

#include "VGUI.h"
#include "VGUI_Panel.h"
#include "VGUI_Dar.h"
#include "VGUI_Cursor.h"

namespace vgui
{

enum MouseCode;
class ChangeSignal;

class VGUIAPI HeaderPanel : public Panel
{

private:

	Dar<Panel*>        _sliderPanelDar;
	Dar<Panel*>        _sectionPanelDar;
	Dar<ChangeSignal*> _changeSignalDar;
	Panel*             _sectionLayer;
	int                _sliderWide;
	bool               _dragging;
	int                _dragSliderIndex;
	int                _dragSliderStartPos;
	int                _dragSliderStartX;

public:

	HeaderPanel(int x,int y,int wide,int tall);

protected:

	virtual void performLayout();

public:

	virtual void addSectionPanel(Panel* panel);
	virtual void setSliderPos(int sliderIndex,int pos);
	virtual int  getSectionCount();
	virtual void getSectionExtents(int sectionIndex,int& x0,int& x1);
	virtual void addChangeSignal(ChangeSignal* s);

public: //bullshit public

	virtual void fireChangeSignal();
	virtual void privateCursorMoved(int x,int y,Panel* panel);
	virtual void privateMousePressed(MouseCode code,Panel* panel);
	virtual void privateMouseReleased(MouseCode code,Panel* panel);

};

}

#endif


```

`halflife/vgui/VGUI_Image.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_IMAGE_H
#define VGUI_IMAGE_H

#include "VGUI.h"
#include "VGUI_Scheme.h"
#include "VGUI_Color.h"

//TODO:: needs concept of insets

namespace vgui
{

class Panel;

class VGUIAPI Image
{
friend class Panel;
private:
	int                 _pos[2];
	int                 _size[2];
	Panel*              _panel;
	Color               _color;
public:
	Image();
public:
	virtual void setPos(int x,int y);
	virtual void getPos(int& x,int& y);
	virtual void getSize(int& wide,int& tall);
	virtual void setColor(Color color);
	virtual void getColor(Color& color);
protected:
	virtual void setSize(int wide,int tall);
	virtual void drawSetColor(Scheme::SchemeColor sc);
	virtual void drawSetColor(int r,int g,int b,int a);
	virtual void drawFilledRect(int x0,int y0,int x1,int y1);
	virtual void drawOutlinedRect(int x0,int y0,int x1,int y1);
	virtual void drawSetTextFont(Scheme::SchemeFont sf);
	virtual void drawSetTextFont(Font* font);
	virtual void drawSetTextColor(Scheme::SchemeColor sc);
	virtual void drawSetTextColor(int r,int g,int b,int a);
	virtual void drawSetTextPos(int x,int y);
	virtual void drawPrintText(const char* str,int strlen);
	virtual void drawPrintText(int x,int y,const char* str,int strlen);
	virtual void drawPrintChar(char ch);
	virtual void drawPrintChar(int x,int y,char ch);
	virtual void drawSetTextureRGBA(int id,const char* rgba,int wide,int tall);
	virtual void drawSetTexture(int id);
	virtual void drawTexturedRect(int x0,int y0,int x1,int y1);
	virtual void paint(Panel* panel);
public:
	virtual void doPaint(Panel* panel);
};
}

#endif
```

`halflife/vgui/VGUI_ImagePanel.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_IMAGEPANEL_H
#define VGUI_IMAGEPANEL_H

#include "VGUI.h"
#include "VGUI_Panel.h"

namespace vgui
{

class Image;

class VGUIAPI ImagePanel : public Panel
{
public:
	inline ImagePanel()
	{
		_image=null;
	}

	ImagePanel(Image* image);
public:
	virtual void setImage(Image* image);
protected:
	virtual void paintBackground();
protected:
	Image* _image;
};

}

#endif
```

`halflife/vgui/VGUI_InputSignal.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_INPUTSIGNAL_H
#define VGUI_INPUTSIGNAL_H

#include "VGUI.h"

namespace vgui
{

enum MouseCode;
enum KeyCode;
class Panel;

//these are lumped into one for simplicity sake right now
class VGUIAPI InputSignal
{
public:
	virtual void cursorMoved(int x,int y,Panel* panel)=0;
	virtual void cursorEntered(Panel* panel)=0;
	virtual void cursorExited(Panel* panel)=0;
	virtual void mousePressed(MouseCode code,Panel* panel)=0;
	virtual void mouseDoublePressed(MouseCode code,Panel* panel)=0;
	virtual void mouseReleased(MouseCode code,Panel* panel)=0;
	virtual void mouseWheeled(int delta,Panel* panel)=0;
	virtual void keyPressed(KeyCode code,Panel* panel)=0;
	virtual void keyTyped(KeyCode code,Panel* panel)=0;
	virtual void keyReleased(KeyCode code,Panel* panel)=0;
	virtual void keyFocusTicked(Panel* panel)=0;
};

}

#endif
```

`halflife/vgui/VGUI_InputStream.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_FILE_H
#define VGUI_FILE_H

#include "VGUI.h"

namespace vgui
{

class VGUIAPI InputStream
{
public:
	virtual void  seekStart(bool& success)=0;
	virtual void  seekRelative(int count,bool& success)=0;
	virtual void  seekEnd(bool& success)=0;
	virtual int   getAvailable(bool& success)=0;
	virtual uchar readUChar(bool& success)=0;
	virtual void  readUChar(uchar* buf,int count,bool& success)=0;
	virtual void  close(bool& success)=0;
};

}

#endif
```

`halflife/vgui/VGUI_IntChangeSignal.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_INTCHANGESIGNAL_H
#define VGUI_INTCHANGESIGNAL_H

#include "VGUI.h"

namespace vgui
{

class Panel;

class VGUIAPI IntChangeSignal
{
public:
	virtual void intChanged(int value,Panel* panel)=0;
};

}

#endif
```

`halflife/vgui/VGUI_IntLabel.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_INTLABEL_H
#define VGUI_INTLABEL_H

#include "VGUI.h"
#include "VGUI_Label.h"
#include "VGUI_IntChangeSignal.h"

namespace vgui
{

class Panel;

class VGUIAPI IntLabel : public Label , public IntChangeSignal
{
public:
	IntLabel(int value,int x,int y,int wide,int tall);
public:
	virtual void setValue(int value);
	virtual void intChanged(int value,Panel* panel);
protected:
	virtual void paintBackground();
protected:
	int _value;
};

}

#endif

```

`halflife/vgui/VGUI_KeyCode.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_KEYCODE_H
#define VGUI_KEYCODE_H

#include "VGUI.h"

namespace vgui
{
enum VGUIAPI KeyCode
{
	KEY_0=0,
	KEY_1,
	KEY_2,
	KEY_3,
	KEY_4,
	KEY_5,
	KEY_6,
	KEY_7,
	KEY_8,
	KEY_9,
	KEY_A,
	KEY_B,
	KEY_C,
	KEY_D,
	KEY_E,
	KEY_F,
	KEY_G,
	KEY_H,
	KEY_I,
	KEY_J,
	KEY_K,
	KEY_L,
	KEY_M,
	KEY_N,
	KEY_O,
	KEY_P,
	KEY_Q,
	KEY_R,
	KEY_S,
	KEY_T,
	KEY_U,
	KEY_V,
	KEY_W,
	KEY_X,
	KEY_Y,
	KEY_Z,
	KEY_PAD_0,
	KEY_PAD_1,
	KEY_PAD_2,
	KEY_PAD_3,
	KEY_PAD_4,
	KEY_PAD_5,
	KEY_PAD_6,
	KEY_PAD_7,
	KEY_PAD_8,
	KEY_PAD_9,
	KEY_PAD_DIVIDE,
	KEY_PAD_MULTIPLY,
	KEY_PAD_MINUS,
	KEY_PAD_PLUS,
	KEY_PAD_ENTER,
	KEY_PAD_DECIMAL,
	KEY_LBRACKET,
	KEY_RBRACKET,
	KEY_SEMICOLON,
	KEY_APOSTROPHE,
	KEY_BACKQUOTE,
	KEY_COMMA,
	KEY_PERIOD,
	KEY_SLASH,
	KEY_BACKSLASH,
	KEY_MINUS,
	KEY_EQUAL,
	KEY_ENTER,
	KEY_SPACE,
	KEY_BACKSPACE,
	KEY_TAB,
	KEY_CAPSLOCK,
	KEY_NUMLOCK,
	KEY_ESCAPE,
	KEY_SCROLLLOCK,
	KEY_INSERT,
	KEY_DELETE,
	KEY_HOME,
	KEY_END,
	KEY_PAGEUP,
	KEY_PAGEDOWN,
	KEY_BREAK,
	KEY_LSHIFT,
	KEY_RSHIFT,
	KEY_LALT,
	KEY_RALT,
	KEY_LCONTROL,
	KEY_RCONTROL,
	KEY_LWIN,
	KEY_RWIN,
	KEY_APP,
	KEY_UP,
	KEY_LEFT,
	KEY_DOWN,
	KEY_RIGHT,
	KEY_F1,
	KEY_F2,
	KEY_F3,
	KEY_F4,
	KEY_F5,
	KEY_F6,
	KEY_F7,
	KEY_F8,
	KEY_F9,
	KEY_F10,
	KEY_F11,
	KEY_F12,
	KEY_LAST,
};
}


#endif


```

`halflife/vgui/VGUI_Label.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_LABEL_H
#define VGUI_LABEL_H

#include "VGUI.h"
#include "VGUI_Panel.h"
#include "VGUI_Scheme.h"
#include "VGUI_Image.h"

//TODO: this should use a TextImage for the text

namespace vgui
{

class Panel;
class TextImage;

class VGUIAPI Label : public Panel
{
public:
	enum Alignment
	{
		a_northwest=0,
		a_north,
		a_northeast,
		a_west,
		a_center,
		a_east,
		a_southwest,
		a_south,
		a_southeast,
	};
public:	
	Label(int textBufferLen,const char* text,int x,int y,int wide,int tall);
	Label(const char* text,int x,int y,int wide,int tall);
	Label(const char* text,int x,int y);
	Label(const char* text);
	
	inline Label() : Panel(0,0,10,10)
	{
		init(1,"",true);
	}
private:
	void init(int textBufferLen,const char* text,bool textFitted);
public:
	virtual void setImage(Image* image);
	virtual void setText(int textBufferLen,const char* text);
	virtual void setText(const char* format,...);
	virtual void setFont(Scheme::SchemeFont schemeFont);
	virtual void setFont(Font* font);
	virtual void getTextSize(int& wide,int& tall);
	virtual void getContentSize(int& wide,int& tall);
	virtual void setTextAlignment(Alignment alignment);
	virtual void setContentAlignment(Alignment alignment);
	virtual Panel* createPropertyPanel();
	virtual void setFgColor(int r,int g,int b,int a);
	virtual void setFgColor(vgui::Scheme::SchemeColor sc);
	virtual void setContentFitted(bool state);
protected:
	virtual void computeAlignment(int& tx0,int& ty0,int& tx1,int& ty1,int& ix0,int& iy0,int& ix1,int& iy1,int& minX,int& minY,int& maxX,int& maxY);
	virtual void paint();
	virtual void recomputeMinimumSize();
protected:
	bool       _textEnabled;
	bool       _imageEnabled;
	bool       _contentFitted;
	Alignment  _textAlignment;
	Alignment  _contentAlignment;
	TextImage* _textImage;
	Image*     _image;
};

}

#endif
```

`halflife/vgui/VGUI_Layout.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_LAYOUT_H
#define VGUI_LAYOUT_H

#include "VGUI.h"

namespace vgui
{

class Panel;

class VGUIAPI Layout
{
//private:
//	Panel* _panel;
public:
	Layout();
public:
	//virtual void setPanel(Panel* panel); //called by Panel::setLayout
	virtual void performLayout(Panel* panel);
};

}

#endif
```

`halflife/vgui/VGUI_LayoutInfo.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_LAYOUTINFO_H
#define VGUI_LAYOUTINFO_H

namespace vgui
{

class VGUIAPI LayoutInfo
{
	virtual LayoutInfo* getThis()=0;
};

}

#endif
```

`halflife/vgui/VGUI_LineBorder.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_LINEBORDER_H
#define VGUI_LINEBORDER_H

#include "VGUI.h"
#include "VGUI_Border.h"
#include "VGUI_Color.h"

namespace vgui
{

class Panel;

class VGUIAPI LineBorder : public Border
{
private:
	Color _color;
public:
	LineBorder();
	LineBorder(int thickness);
	LineBorder(Color color);
	LineBorder(int thickness,Color color);

	inline void setLineColor(int r, int g, int b, int a) {_color = Color(r,g,b,a);}
private:
	virtual void init(int thickness,Color color);
protected:
	virtual void paint(Panel* panel);
};

}

#endif
```

`halflife/vgui/VGUI_ListPanel.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_LISTPANEL_H
#define VGUI_LISTPANEL_H

#include "VGUI.h"
#include "VGUI_Panel.h"

namespace vgui
{

class ScrollBar;

//TODO: make a ScrollPanel and use a constrained one for _vpanel in ListPanel
class VGUIAPI ListPanel : public Panel
{
public:
	ListPanel(int x,int y,int wide,int tall);
public:
	virtual void setSize(int wide,int tall);
	virtual void addString(const char* str);
	virtual void addItem(Panel* panel);
	virtual void setPixelScroll(int value);
	virtual void translatePixelScroll(int delta);
protected:
	virtual void performLayout();
	virtual void paintBackground();
protected: 
	Panel*     _vpanel;
	ScrollBar* _scroll;
};

}

#endif
```

`halflife/vgui/VGUI_LoweredBorder.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_LOWEREDBORDER_H
#define VGUI_LOWEREDBORDER_H

#include "VGUI.h"
#include "VGUI_Border.h"

namespace vgui
{

class Panel;

class VGUIAPI LoweredBorder : public Border
{
public:
	LoweredBorder();
protected:
	virtual void paint(Panel* panel);
};

}

#endif
```

`halflife/vgui/VGUI_Menu.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_MENU_H
#define VGUI_MENU_H

#include "VGUI.h"
#include "VGUI_Panel.h"

namespace vgui
{

class Panel;

class VGUIAPI Menu : public Panel
{
public:
	Menu(int x,int y,int wide,int tall);
	Menu(int wide,int tall);
public:
	virtual void addMenuItem(Panel* panel);
};

}

#endif
```

`halflife/vgui/VGUI_MenuItem.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_MENUITEM_H
#define VGUI_MENUITEM_H

#include "VGUI.h"
#include "VGUI_Button.h"

namespace vgui
{

class Menu;

class VGUIAPI MenuItem : public Button
{
public:
	MenuItem(const char* text);
	MenuItem(const char* text,Menu* subMenu);
protected:
	Menu* _subMenu;
};

}

#endif
```

`halflife/vgui/VGUI_MenuSeparator.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_MENUSEPARATOR_H
#define VGUI_MENUSEPARATOR_H

#include "VGUI.h"
#include "VGUI_Label.h"

namespace vgui
{

class VGUIAPI MenuSeparator : public Label
{
public:
	MenuSeparator(const char* text);
protected:
	virtual void paintBackground();
};

}

#endif
```

`halflife/vgui/VGUI_MessageBox.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_MESSAGEBOX_H
#define VGUI_MESSAGEBOX_H

#include "VGUI.h"
#include "VGUI_Frame.h"
#include "VGUI_Dar.h"


namespace vgui
{

class Label;
class Button;
class ActionSignal;

class VGUIAPI MessageBox : public Frame
{

private:
	
	Label*             _messageLabel;
	Button*            _okButton;
	Dar<ActionSignal*> _actionSignalDar;

public:

	MessageBox(const char* title,const char* text,int x,int y);

protected:
	
	virtual void performLayout();

public:
	
	virtual void addActionSignal(ActionSignal* s);
	virtual void fireActionSignal();

};

}





#endif
```

`halflife/vgui/VGUI_MiniApp.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_MINIAPP_H
#define VGUI_MINIAPP_H

#include "VGUI.h"

namespace vgui
{

class Frame;

class VGUIAPI MiniApp
{
public:
	MiniApp();
public:
	virtual void   getName(char* buf,int bufLen);
	virtual Frame* createInstance()=0;
protected:
	virtual void setName(const char* name);
protected:
	char* _name;
};

}

#endif
```

`halflife/vgui/VGUI_MouseCode.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_MOUSECODE_H
#define VGUI_MOUSECODE_H

#include "VGUI.h"

namespace vgui
{
enum VGUIAPI MouseCode
{
	MOUSE_LEFT=0,
	MOUSE_RIGHT,
	MOUSE_MIDDLE,
	MOUSE_LAST,
};
}

#endif
```

`halflife/vgui/VGUI_Panel.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_PANEL_H
#define VGUI_PANEL_H


/*

TODO:

Maybe have the border know who they are added to.
A border can only be added to 1 thing, and will be
removed from the other. That way they can actually
be memory managed. Also do Layout's this way too.

TODO:
	outlinedRect should have a thickness arg

*/

					 
#include "VGUI.h"
#include "VGUI_Dar.h"
#include "VGUI_Scheme.h"
#include "VGUI_Color.h"
#include "VGUI_Cursor.h"
#include "VGUI_MouseCode.h"
#include "VGUI_KeyCode.h"
#include "VGUI_RepaintSignal.h"

namespace vgui
{

enum  KeyCode;
enum  MouseCode;
class SurfaceBase;
class FocusChangeSignal;
class InputSignal;
class Cursor;
class Layout;
class FocusNavGroup;
class Border;
class Font;
class BuildGroup;
class App;
class LayoutInfo;

class VGUIAPI Panel
{
public:
	Panel();
	Panel(int x,int y,int wide,int tall); 
private:
	void init(int x,int y,int wide,int tall);
public:
	virtual void   setPos(int x,int y);
	virtual void   getPos(int& x,int& y);
	virtual void   setSize(int wide,int tall);
	virtual void   getSize(int& wide,int& tall);
	virtual void   setBounds(int x,int y,int wide,int tall);
	virtual void   getBounds(int& x,int& y,int& wide,int& tall);
	virtual int    getWide();
	virtual int    getTall();
	virtual Panel* getParent();
	virtual void   setVisible(bool state);
	virtual bool   isVisible();
	virtual bool   isVisibleUp();
	virtual void   repaint();
	virtual void   repaintAll();
	virtual void   getAbsExtents(int& x0,int& y0,int& x1,int& y1);
	virtual void   getClipRect(int& x0,int& y0,int& x1,int& y1);
	virtual void   setParent(Panel* newParent);
	virtual void   addChild(Panel* child);
	virtual void   insertChildAt(Panel* child,int index);
	virtual void   removeChild(Panel* child);
	virtual bool   wasMousePressed(MouseCode code);
	virtual bool   wasMouseDoublePressed(MouseCode code);
	virtual bool   isMouseDown(MouseCode code);
	virtual bool   wasMouseReleased(MouseCode code);
	virtual bool   wasKeyPressed(KeyCode code);
	virtual bool   isKeyDown(KeyCode code);
	virtual bool   wasKeyTyped(KeyCode code);
	virtual bool   wasKeyReleased(KeyCode code);
	virtual void   addInputSignal(InputSignal* s);
	virtual void   removeInputSignal(InputSignal* s);
	virtual void   addRepaintSignal(RepaintSignal* s);
	virtual void   removeRepaintSignal(RepaintSignal* s);
	virtual bool   isWithin(int x,int y); //in screen space
	virtual Panel* isWithinTraverse(int x,int y);
	virtual void   localToScreen(int& x,int& y);
	virtual void   screenToLocal(int& x,int& y);
	virtual void   setCursor(Cursor* cursor);
	virtual void   setCursor(Scheme::SchemeCursor scu);
	virtual Cursor* getCursor();
	virtual void   setMinimumSize(int wide,int tall);
	virtual void   getMinimumSize(int& wide,int& tall);
	virtual void   requestFocus();
	virtual bool   hasFocus();
	virtual int    getChildCount();
	virtual Panel* getChild(int index);
	virtual void   setLayout(Layout* layout);
	virtual void   invalidateLayout(bool layoutNow);
	virtual void   setFocusNavGroup(FocusNavGroup* focusNavGroup);
	virtual void   requestFocusPrev();
	virtual void   requestFocusNext();
	virtual void   addFocusChangeSignal(FocusChangeSignal* s);
	virtual bool   isAutoFocusNavEnabled();
	virtual void   setAutoFocusNavEnabled(bool state);
	virtual void   setBorder(Border* border);
	virtual void   setPaintBorderEnabled(bool state);
	virtual void   setPaintBackgroundEnabled(bool state);
	virtual void   setPaintEnabled(bool state);
	virtual void   getInset(int& left,int& top,int& right,int& bottom);
	virtual void   getPaintSize(int& wide,int& tall);
	virtual void   setPreferredSize(int wide,int tall);
	virtual void   getPreferredSize(int& wide,int& tall);
	virtual SurfaceBase* getSurfaceBase();
	virtual bool   isEnabled();
	virtual void   setEnabled(bool state);
	virtual void   setBuildGroup(BuildGroup* buildGroup,const char* panelPersistanceName);
	virtual bool   isBuildGroupEnabled();
	virtual void   removeAllChildren();
	virtual void   repaintParent();
	virtual Panel* createPropertyPanel();
	virtual void   getPersistanceText(char* buf,int bufLen);
	virtual void   applyPersistanceText(const char* buf);
	virtual void   setFgColor(Scheme::SchemeColor sc);
	virtual void   setBgColor(Scheme::SchemeColor sc);
	virtual void   setFgColor(int r,int g,int b,int a);
	virtual void   setBgColor(int r,int g,int b,int a);
	virtual void   getFgColor(int& r,int& g,int& b,int& a);
	virtual void   getBgColor(int& r,int& g,int& b,int& a);
	virtual void   setBgColor(Color color);
	virtual void   setFgColor(Color color);
	virtual void   getBgColor(Color& color);
	virtual void   getFgColor(Color& color);
	virtual void   setAsMouseCapture(bool state);
	virtual void   setAsMouseArena(bool state);
	virtual App*   getApp();
	virtual void   getVirtualSize(int& wide,int& tall);
	virtual void   setLayoutInfo(LayoutInfo* layoutInfo);
	virtual LayoutInfo* getLayoutInfo();
	virtual bool   isCursorNone();
public: //bullshit public
	virtual void solveTraverse();
	virtual void paintTraverse();
	virtual void setSurfaceBaseTraverse(SurfaceBase* surfaceBase);
protected:
	virtual void performLayout();
	virtual void internalPerformLayout();
	virtual void drawSetColor(Scheme::SchemeColor sc);
	virtual void drawSetColor(int r,int g,int b,int a);
	virtual void drawFilledRect(int x0,int y0,int x1,int y1);
	virtual void drawOutlinedRect(int x0,int y0,int x1,int y1);
	virtual void drawSetTextFont(Scheme::SchemeFont sf);
	virtual void drawSetTextFont(Font* font);
	virtual void drawSetTextColor(Scheme::SchemeColor sc);
	virtual void drawSetTextColor(int r,int g,int b,int a);
	virtual void drawSetTextPos(int x,int y);
	virtual void drawPrintText(const char* str,int strlen);
	virtual void drawPrintText(int x,int y,const char* str,int strlen);
	virtual void drawPrintChar(char ch);
	virtual void drawPrintChar(int x,int y,char ch);
	virtual void drawSetTextureRGBA(int id,const char* rgba,int wide,int tall);
	virtual void drawSetTexture(int id);
	virtual void drawTexturedRect(int x0,int y0,int x1,int y1);
	virtual void solve();
	virtual void paintTraverse(bool repaint);
	virtual void paintBackground();
	virtual void paint();
	virtual void paintBuildOverlay();
	virtual void internalCursorMoved(int x,int y);
	virtual void internalCursorEntered();
	virtual void internalCursorExited();
	virtual void internalMousePressed(MouseCode code);
	virtual void internalMouseDoublePressed(MouseCode code);
	virtual void internalMouseReleased(MouseCode code);
	virtual void internalMouseWheeled(int delta);
	virtual void internalKeyPressed(KeyCode code);
	virtual void internalKeyTyped(KeyCode code);
	virtual void internalKeyReleased(KeyCode code);
	virtual void internalKeyFocusTicked();
	virtual void internalFocusChanged(bool lost);
	virtual void internalSetCursor();
protected:
	int               _pos[2];
	int               _size[2];
	int               _loc[2];
	int               _minimumSize[2];
	int               _preferredSize[2];
	Dar<Panel*>       _childDar;
	Panel*            _parent;
	SurfaceBase*      _surfaceBase;
	Dar<InputSignal*> _inputSignalDar;
	Dar<RepaintSignal*> _repaintSignalDar;
	int               _clipRect[4];
	Cursor*           _cursor;
	Scheme::SchemeCursor _schemeCursor;
	bool              _visible;
	Layout*           _layout;
	bool              _needsLayout;
	FocusNavGroup*    _focusNavGroup;
	Dar<FocusChangeSignal*> _focusChangeSignalDar;
	bool              _autoFocusNavEnabled;
	Border*           _border;
private:
	bool                _needsRepaint;
	bool                _enabled;
	BuildGroup*         _buildGroup;
	Color               _fgColor;
	Color               _bgColor;
	LayoutInfo*         _layoutInfo;
	bool                _paintBorderEnabled;
	bool                _paintBackgroundEnabled;
	bool                _paintEnabled;
friend class Panel;
friend class App;
friend class SurfaceBase;
friend class Image;
};
}

#endif

```

`halflife/vgui/VGUI_Point.h`:

```h
//========= Copyright © 1996-2001, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_Point_H
#define VGUI_Point_H
#ifdef _WIN32
#pragma once
#endif

#include "VGUI.h"

namespace vgui
{

//-----------------------------------------------------------------------------
// Purpose: Basic handler for a Points in 2 dimensions
//			This class is fully inline
//-----------------------------------------------------------------------------
class Point
{
public:
	// constructors
	Point()
	{
		SetPoint(0, 0);
	}
	Point(int x,int y)
	{
		SetPoint(x,y);
	}

	void SetPoint(int x1, int y1)
	{
		x=x1;
		y=y1;	
	}

	void GetPoint(int& x1,int& y1) const
	{
		x1 = x;
		y1 = y;
	
	}

	bool operator == (Point &rhs) const
	{
		return ( x == rhs.x && y==rhs.y);
	}

private:
	int x,y;
};

}

#endif // VGUI_Point_H



//## <b>class Point</b>
//## Point is a class to handle Points in VGUI.

//## // The default Point is (0,0,0,0)
//## Point()
//##
//## // A Point may be created with x,yvalues.
//## Point(int x,int y)
//##
//## // Set the x,y components of the Point.
//## void SetPoint(int x1, int y1)
//##
//## // Get the position of the Point
//## void GetPoint(int& x1,int& y1) const
//##
//## // Point classes can be set equal to each other.
//## bool operator == (Point &rhs) const
//##
//##
//## <hr>
//##
//##
//## <method>Point()
//## Description: Default constructor. The default Point is (0,0,0,0)
//##	
//##
//## <method>Point(int x,int y)
//## Description:
//##	A Point may be created with a x,y position.
//## Arguments:
//##	x - x position (horizontal axis) (0-65535)
//##	y - y position (vertical axis) (0-65535)
//## 
//## 
//## <method>void SetPoint(int x1, int x1)
//## Description:
//##	Set the position of the Point.
//## Arguments:
//##	x - x position (horizontal axis) (0-65535)
//##	y - y position (vertical axis) (0-65535)
//## 
//## 
//## <method>void GetPoint(int& x1,int& y1) const
//## Description:
//##	Get the x,y components of a Point
//## Arguments:
//##	x - x position (horizontal axis) (0-65535)
//##	y - y position (vertical axis) (0-65535)	
//##  
//## <method>bool operator == (Point &rhs) const
//## Description:
//##	Point classes can be set equal to each other.
//##
//##

```

`halflife/vgui/VGUI_PopupMenu.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_POPUPMENU_H
#define VGUI_POPUPMENU_H

#include "VGUI.h"
#include "VGUI_Menu.h"

namespace vgui
{

class Panel;

class VGUIAPI PopupMenu : public Menu
{
public:
	PopupMenu(int x,int y,int wide,int tall);
	PopupMenu(int wide,int tall);
public:
	virtual void showModal(Panel* panel);
};

}

#endif
```

`halflife/vgui/VGUI_ProgressBar.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_PROGRESSBAR_H
#define VGUI_PROGRESSBAR_H

#include "VGUI.h"
#include "VGUI_Panel.h"

namespace vgui
{

class VGUIAPI ProgressBar : public Panel
{
private:
	int   _segmentCount;
	float _progress;
public:
	ProgressBar(int segmentCount);
protected:
	virtual void paintBackground();
public:
	virtual void setProgress(float progress);
	virtual int  getSegmentCount();
};

}

#endif
```

`halflife/vgui/VGUI_RadioButton.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_RADIOBUTTON_H
#define VGUI_RADIOBUTTON_H

#include "VGUI.h"
#include "VGUI_ToggleButton.h"

namespace vgui
{

class VGUIAPI RadioButton : public ToggleButton
{
public:
	RadioButton(const char* text,int x,int y,int wide,int tall);
	RadioButton(const char* text,int x,int y);
protected:
	virtual void paintBackground();
};

}

#endif


```

`halflife/vgui/VGUI_RaisedBorder.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_RAISEDBORDER_H
#define VGUI_RAISEDBORDER_H

#include "VGUI.h"
#include "VGUI_Border.h"

namespace vgui
{

class Panel;

class VGUIAPI RaisedBorder : public Border
{
public:
	RaisedBorder();
protected:
	virtual void paint(Panel* panel);
};

}

#endif
```

`halflife/vgui/VGUI_RepaintSignal.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_REPAINTSIGNAL_H
#define VGUI_REPAINTSIGNAL_H



namespace vgui
{
class Panel;
	
class RepaintSignal
{
public:
	virtual void panelRepainted(Panel* panel)=0;
};

}


#endif
```

`halflife/vgui/VGUI_Scheme.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_SCHEME_H
#define VGUI_SCHEME_H

#include "VGUI.h"


namespace vgui
{

class Font;
class Cursor;

class VGUIAPI Scheme
{
public:
	enum SchemeColor
	{
		sc_user=0,
		sc_black,
		sc_white,
		sc_primary1,
		sc_primary2,
		sc_primary3,
		sc_secondary1,
		sc_secondary2,
		sc_secondary3,
		sc_last,
	};
	enum SchemeFont
	{
		sf_user=0,
		sf_primary1,
		sf_primary2,
		sf_primary3,
		sf_secondary1,
		sf_last,
	};
	enum SchemeCursor
	{
		scu_user=0,
		scu_none,
		scu_arrow,
		scu_ibeam,
		scu_hourglass,
		scu_crosshair,
		scu_up,
		scu_sizenwse,
		scu_sizenesw,
		scu_sizewe,
		scu_sizens,
		scu_sizeall,
		scu_no,
		scu_hand,
		scu_last,
	};
public:
	Scheme();
public:
	virtual void    setColor(SchemeColor sc,int r,int g,int b,int a);
	virtual void    getColor(SchemeColor sc,int& r,int& g,int& b,int& a);
	virtual void    setFont(SchemeFont sf,Font* font);
	virtual Font*   getFont(SchemeFont sf);
	virtual void    setCursor(SchemeCursor sc,Cursor* cursor);
	virtual Cursor* getCursor(SchemeCursor sc);
protected:
	int     _color[sc_last][4];
    Font*   _font[sf_last];
	Cursor* _cursor[scu_last];
    friend class Panel;
    friend class Canvas;
};

}

#endif
```

`halflife/vgui/VGUI_ScrollBar.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_SCROLLBAR_H
#define VGUI_SCROLLBAR_H

#include "VGUI.h"
#include "VGUI_Panel.h"
#include "VGUI_Dar.h"

namespace vgui
{

class IntChangeSignal;
class Button;
class Slider;

class VGUIAPI ScrollBar : public Panel
{
public:
	ScrollBar(int x,int y,int wide,int tall,bool vertical);
public:
	virtual void    setValue(int value);
	virtual int     getValue();
	virtual void    addIntChangeSignal(IntChangeSignal* s); 
	virtual void    setRange(int min,int max);
	virtual void    setRangeWindow(int rangeWindow);
	virtual void    setRangeWindowEnabled(bool state);
	virtual void    setSize(int wide,int tall);
	virtual bool    isVertical();
	virtual bool    hasFullRange();
	virtual void    setButton(Button* button,int index);
	virtual Button* getButton(int index);
	virtual void    setSlider(Slider* slider);
	virtual Slider* getSlider();
	virtual void 	doButtonPressed(int buttonIndex);
	virtual void    setButtonPressedScrollValue(int value);
	virtual void    validate();
public: //bullshit public 
	virtual void fireIntChangeSignal();
protected:
	virtual void performLayout();
protected:
	Button* _button[2];
	Slider* _slider;
	Dar<IntChangeSignal*> _intChangeSignalDar;
	int     _buttonPressedScrollValue;
};

}

#endif
```

`halflife/vgui/VGUI_ScrollPanel.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_SCROLLPANEL_H
#define VGUI_SCROLLPANEL_H

#include "VGUI.h"
#include "VGUI_Panel.h"

//NOTE: You need to call validate anytime you change a scrollbar

namespace vgui
{

class ScrollBar;

class VGUIAPI ScrollPanel : public Panel
{
private:
	Panel*     _clientClip;
	Panel*     _client;
	ScrollBar* _horizontalScrollBar;
	ScrollBar* _verticalScrollBar;
	bool       _autoVisible[2];
public:
	ScrollPanel(int x,int y,int wide,int tall);
protected:
	virtual void setSize(int wide,int tall);
public:
	virtual void   setScrollBarVisible(bool horizontal,bool vertical);
	virtual void   setScrollBarAutoVisible(bool horizontal,bool vertical);
	virtual Panel* getClient();
	virtual Panel* getClientClip();
	virtual void   setScrollValue(int horizontal,int vertical);
	virtual void   getScrollValue(int& horizontal,int& vertical);
	virtual void   recomputeClientSize();
	virtual ScrollBar* getHorizontalScrollBar();
	virtual ScrollBar* getVerticalScrollBar();
	virtual void       validate();
public: //bullshit public
	virtual void recomputeScroll();
};

}






#endif

```

`halflife/vgui/VGUI_Slider.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_SLIDER_H
#define VGUI_SLIDER_H

#include "VGUI.h"
#include "VGUI_Panel.h"
#include "VGUI_Dar.h"

namespace vgui
{

enum MouseCode;
class IntChangeSignal;

class VGUIAPI Slider : public Panel
{
private:
	bool                  _vertical;
	bool                  _dragging;
	int                   _nobPos[2];
	int                   _nobDragStartPos[2];
	int                   _dragStartPos[2];
	Dar<IntChangeSignal*> _intChangeSignalDar;
	int                   _range[2];
	int                   _value;
	int                   _rangeWindow;
	bool                  _rangeWindowEnabled;
	int                   _buttonOffset;
public:
	Slider(int x,int y,int wide,int tall,bool vertical);
public:
	virtual void setValue(int value);
	virtual int  getValue();
	virtual bool isVertical();
	virtual void addIntChangeSignal(IntChangeSignal* s);
    virtual void setRange(int min,int max);
	virtual void getRange(int& min,int& max);
	virtual void setRangeWindow(int rangeWindow);
	virtual void setRangeWindowEnabled(bool state);
	virtual void setSize(int wide,int tall);
	virtual void getNobPos(int& min, int& max);
	virtual bool hasFullRange();
	virtual void setButtonOffset(int buttonOffset);
private:
	virtual void recomputeNobPosFromValue();
	virtual void recomputeValueFromNobPos();
public: //bullshit public
	virtual void privateCursorMoved(int x,int y,Panel* panel);
	virtual void privateMousePressed(MouseCode code,Panel* panel);
	virtual void privateMouseReleased(MouseCode code,Panel* panel);
protected:
    virtual void fireIntChangeSignal();
	virtual void paintBackground();
};

}

#endif






```

`halflife/vgui/VGUI_StackLayout.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_STACKLAYOUT_H
#define VGUI_STACKLAYOUT_H

#include "VGUI.h"
#include "VGUI_Layout.h"

namespace vgui
{

class VGUIAPI StackLayout : public Layout
{
private:
	int  _vgap;
	bool _fitWide;
public:
	StackLayout(int vgap,bool fitWide);
public:
	virtual void performLayout(Panel* panel);
};

}

#endif
```

`halflife/vgui/VGUI_String.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_STRING_H
#define VGUI_STRING_H

#include "VGUI.h"


namespace vgui
{

class VGUIAPI String
{

friend class String;

private:

	char* _text;

public:

	String();
	String(const char* text);
	String(const String& src);

public:
	
	~String();

private:

	int getCount(const char* text);

public:

	int    getCount();
	String operator+(String text);
	String operator+(const char* text);
	bool   operator==(String text);
	bool   operator==(const char* text);
	char   operator[](int index);
	const char* getChars();

public:
	
	static void test();

};


}


#endif


```

`halflife/vgui/VGUI_Surface.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_SURFACE_H
#define VGUI_SURFACE_H

#include "VGUI.h"
#include "VGUI_SurfaceBase.h"
#include "VGUI_Dar.h"

namespace vgui
{

class Panel;
class Cursor;

class VGUIAPI Surface : public SurfaceBase
{
public:
	Surface(Panel* embeddedPanel);
public:
	virtual void setTitle(const char* title);
	virtual bool setFullscreenMode(int wide,int tall,int bpp);
	virtual void setWindowedMode();
	virtual void setAsTopMost(bool state);
	virtual int  getModeInfoCount();
	virtual void createPopup(Panel* embeddedPanel);
	virtual bool hasFocus();
	virtual bool isWithin(int x,int y);
	virtual void GetMousePos( int &x, int &y );
protected:
	virtual int  createNewTextureID(void);
	virtual void drawSetColor(int r,int g,int b,int a);
	virtual void drawFilledRect(int x0,int y0,int x1,int y1);
	virtual void drawOutlinedRect(int x0,int y0,int x1,int y1);
	virtual void drawSetTextFont(Font* font);
	virtual void drawSetTextColor(int r,int g,int b,int a);
	virtual void drawSetTextPos(int x,int y);
	virtual void drawPrintText(const char* text,int textLen);
	virtual void drawSetTextureRGBA(int id,const char* rgba,int wide,int tall);
	virtual void drawSetTexture(int id);
	virtual void drawTexturedRect(int x0,int y0,int x1,int y1);
	virtual void invalidate(Panel *panel);
	virtual bool createPlat();
	virtual bool recreateContext();
	virtual void enableMouseCapture(bool state);
	virtual void setCursor(Cursor* cursor);
	virtual void swapBuffers();
	virtual void pushMakeCurrent(Panel* panel,bool useInsets);
	virtual void popMakeCurrent(Panel* panel);
	virtual void applyChanges();
protected:
	class SurfacePlat* _plat;
	bool               _needsSwap;
	Panel*             _embeddedPanel;
	Dar<char*>         _modeInfoDar;
	friend class App;
	friend class Panel;
};

}

#endif


```

`halflife/vgui/VGUI_SurfaceBase.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_SURFACEBASE_H
#define VGUI_SURFACEBASE_H

#include "VGUI.h"
#include "VGUI_Dar.h"

namespace vgui
{

class Panel;
class Cursor;
class Font;
class App;
class ImagePanel;

class VGUIAPI SurfaceBase
{
public:
	SurfaceBase(Panel* embeddedPanel);
protected:
	~SurfaceBase();
public:
	virtual Panel* getPanel();
	virtual void   requestSwap();
	virtual void   resetModeInfo();
	virtual int    getModeInfoCount();
	virtual bool   getModeInfo(int mode,int& wide,int& tall,int& bpp);
	virtual App*   getApp();
	virtual void   setEmulatedCursorVisible(bool state);
	virtual void   setEmulatedCursorPos(int x,int y);
public:
	virtual void setTitle(const char* title)=0;
	virtual bool setFullscreenMode(int wide,int tall,int bpp)=0;
	virtual void setWindowedMode()=0;
	virtual void setAsTopMost(bool state)=0;
	virtual void createPopup(Panel* embeddedPanel)=0;
	virtual bool hasFocus()=0;
	virtual bool isWithin(int x,int y)=0;
	virtual int  createNewTextureID(void)=0;
	virtual void GetMousePos( int &x, int &y ) = 0;
protected:
	virtual void addModeInfo(int wide,int tall,int bpp);
protected:
	virtual void drawSetColor(int r,int g,int b,int a)=0;
	virtual void drawFilledRect(int x0,int y0,int x1,int y1)=0;
	virtual void drawOutlinedRect(int x0,int y0,int x1,int y1)=0;
	virtual void drawSetTextFont(Font* font)=0;
	virtual void drawSetTextColor(int r,int g,int b,int a)=0;
	virtual void drawSetTextPos(int x,int y)=0;
	virtual void drawPrintText(const char* text,int textLen)=0;
	virtual void drawSetTextureRGBA(int id,const char* rgba,int wide,int tall)=0;
	virtual void drawSetTexture(int id)=0;
	virtual void drawTexturedRect(int x0,int y0,int x1,int y1)=0;
	virtual void invalidate(Panel *panel)=0;
	virtual void enableMouseCapture(bool state)=0;
	virtual void setCursor(Cursor* cursor)=0;
	virtual void swapBuffers()=0;
	virtual void pushMakeCurrent(Panel* panel,bool useInsets)=0;
	virtual void popMakeCurrent(Panel* panel)=0;
	virtual void applyChanges()=0;
protected:
	bool       _needsSwap;
	App*       _app;
	Panel*     _embeddedPanel;
	Dar<char*> _modeInfoDar;
	ImagePanel* _emulatedCursor;
	Cursor*     _currentCursor;
friend class App;
friend class Panel;
};

}

#endif


```

`halflife/vgui/VGUI_SurfaceGL.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_SURFACEGL_H
#define VGUI_SURFACEGL_H

//macros borrowed from GLUT to get rid of win32 dependent junk in gl headers
#ifdef _WIN32
# ifndef APIENTRY
#  define VGUI_APIENTRY_DEFINED
#  if (_MSC_VER >= 800) || defined(_STDCALL_SUPPORTED)
#   define APIENTRY    __stdcall
#  else
#   define APIENTRY
#  endif
# endif
# ifndef CALLBACK
#  define VGUI_CALLBACK_DEFINED
#  if (defined(_M_MRX000) || defined(_M_IX86) || defined(_M_ALPHA) || defined(_M_PPC)) && !defined(MIDL_PASS)
#   define CALLBACK __stdcall
#  else
#   define CALLBACK
#  endif
# endif
# ifndef WINGDIAPI
#  define VGUI_WINGDIAPI_DEFINED
#  define WINGDIAPI __declspec(dllimport)
# endif
# ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#  define _WCHAR_T_DEFINED
# endif
# pragma comment(lib,"opengl32.lib")
#endif

#include "GL/gl.h"
#include "GL/glu.h"

#ifdef VGUI_APIENTRY_DEFINED
# undef VGUI_APIENTRY_DEFINED
# undef APIENTRY
#endif

#ifdef VGUI_CALLBACK_DEFINED
# undef VGUI_CALLBACK_DEFINED
# undef CALLBACK
#endif

#ifdef VGUI_WINGDIAPI_DEFINED
# undef VGUI_WINGDIAPI_DEFINED
# undef WINGDIAPI
#endif



#include "VGUI.h"
#include "VGUI_Surface.h"
#include "VGUI_Panel.h"

namespace vgui
{

class VGUIAPI SurfaceGL : public Surface
{
public:
	SurfaceGL(Panel* embeddedPanel);
public:
	virtual void createPopup(Panel* embeddedPanel);
protected:
	virtual bool recreateContext();
	virtual void pushMakeCurrent(Panel* panel,bool useInsets);
	virtual void popMakeCurrent(Panel* panel);
	virtual void makeCurrent();
	virtual void swapBuffers();
	virtual void setColor(int r,int g,int b);
	virtual void filledRect(int x0,int y0,int x1,int y1);
	virtual void outlinedRect(int x0,int y0,int x1,int y1);
	virtual void setTextFont(Font* font);
	virtual void setTextColor(int r,int g,int b);
	virtual void setDrawPos(int x,int y);
	virtual void printText(const char* str,int strlen);
	virtual void setTextureRGBA(int id,const char* rgba,int wide,int tall);
	virtual void setTexture(int id);
	virtual void texturedRect(int x0,int y0,int x1,int y1);
protected:
	int   _drawPos[2];
	uchar _drawColor[3];
	uchar _drawTextColor[3];
};

}

#endif


```

`halflife/vgui/VGUI_TabPanel.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_TABPANEL_H
#define VGUI_TABPANEL_H

#include "VGUI.h"
#include "VGUI_Panel.h"

namespace vgui
{

class ButtonGroup;

class VGUIAPI TabPanel : public Panel
{
public:
	enum TabPlacement
	{
		tp_top=0,
		tp_bottom,
		tp_left,
		tp_right,
	};
public:
	TabPanel(int x,int y,int wide,int tall);
public:
	virtual Panel* addTab(const char* text);
	virtual void   setSelectedTab(Panel* tab);
	virtual void   setSize(int wide,int tall);
protected:
	virtual void recomputeLayoutTop();
	virtual void recomputeLayout();
protected:
	TabPlacement _tabPlacement;
	Panel*       _tabArea;
	Panel*       _clientArea;
	Panel*       _selectedTab;
	Panel*       _selectedPanel;
	ButtonGroup* _buttonGroup;
};

}

#endif
```

`halflife/vgui/VGUI_TablePanel.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_TABLEPANEL_H
#define VGUI_TABLEPANEL_H

#include "VGUI.h"
#include "VGUI_Panel.h"
#include "VGUI_Dar.h"

namespace vgui
{

class HeaderPanel;

class VGUIAPI TablePanel : public Panel
{
friend class FooVGuiTablePanelHandler;
private:
	vgui::Dar<int> _columnDar;
	bool           _gridVisible[2];
	int            _gridWide;
	int            _gridTall;
	int            _selectedCell[2];
	int            _mouseOverCell[2];
	int            _editableCell[2];
	Panel*         _fakeInputPanel;
	bool           _columnSelectionEnabled;
	bool           _rowSelectionEnabled;
	bool           _cellSelectionEnabled;
	Panel*         _editableCellPanel;
	int            _virtualSize[2];
	bool           _cellEditingEnabled;
public:
	TablePanel(int x,int y,int wide,int tall,int columnCount);
public:
	virtual void   setCellEditingEnabled(bool state);
	virtual void   setColumnCount(int columnCount);
	virtual void   setGridVisible(bool horizontal,bool vertical);
	virtual void   setGridSize(int gridWide,int gridTall);
	virtual int    getColumnCount();
	virtual void   setColumnExtents(int column,int x0,int x1);
	virtual void   setSelectedCell(int column,int row);
	virtual void   getSelectedCell(int& column,int& row);
	virtual void   setHeaderPanel(HeaderPanel* header);
	virtual void   setColumnSelectionEnabled(bool state);
	virtual void   setRowSelectionEnabled(bool state);
	virtual void   setCellSectionEnabled(bool state);
	virtual void   setEditableCell(int column,int row);
	virtual void   stopCellEditing();
	virtual void   getVirtualSize(int& wide,int& tall);
	virtual int    getRowCount()=0;
	virtual int    getCellTall(int row)=0;
	virtual Panel* getCellRenderer(int column,int row,bool columnSelected,bool rowSelected,bool cellSelected)=0;
	virtual Panel* startCellEditing(int column,int row)=0;
protected:
	virtual void   paint();
	virtual Panel* isWithinTraverse(int x,int y);
private:
	virtual void privateMousePressed(MouseCode code,Panel* panel);
	virtual void privateMouseDoublePressed(MouseCode code,Panel* panel);
	virtual void privateKeyTyped(KeyCode code,Panel* panel);
};

}

#endif
```

`halflife/vgui/VGUI_TaskBar.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_TASKBAR_H
#define VGUI_TASKBAR_H

#include "VGUI.h"
#include "VGUI_Panel.h"
#include "VGUI_Dar.h"

namespace vgui
{

class Frame;
class Button;

class VGUIAPI TaskBar : public Panel
{
public:
	TaskBar(int x,int y,int wide,int tall);
public:
	virtual void addFrame(Frame* frame);
protected:
	virtual void performLayout();
protected:
	Dar<Frame*>  _frameDar;
	Dar<Button*> _taskButtonDar;
	Panel*       _tray;
};

}

#endif
```

`halflife/vgui/VGUI_TextEntry.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_TEXTENTRY_H
#define VGUI_TEXTENTRY_H

#include "VGUI.h"
#include "VGUI_Panel.h"
#include "VGUI_InputSignal.h"

namespace vgui
{

enum MouseCode;
enum KeyCode;
class ActionSignal;

class VGUIAPI TextEntry : public Panel , public InputSignal
{
public:
	TextEntry(const char* text,int x,int y,int wide,int tall);
public:
	virtual void setText(const char* text,int textLen);
	virtual void getText(int offset,char* buf,int bufLen);
	virtual void resetCursorBlink();
	virtual void doGotoLeft();
	virtual void doGotoRight();
	virtual void doGotoFirstOfLine();
	virtual void doGotoEndOfLine();
	virtual void doInsertChar(char ch);
	virtual void doBackspace();
	virtual void doDelete();
	virtual void doSelectNone();
	virtual void doCopySelected();
	virtual void doPaste();
	virtual void doPasteSelected();
	virtual void doDeleteSelected();
	virtual void addActionSignal(ActionSignal* s);
	virtual void setFont(Font* font);
	virtual void setTextHidden(bool bHideText);
protected:
	virtual void paintBackground();
	virtual void setCharAt(char ch,int index);
protected:
	virtual void fireActionSignal();
	virtual bool getSelectedRange(int& cx0,int& cx1);
	virtual bool getSelectedPixelRange(int& cx0,int& cx1);
	virtual int  cursorToPixelSpace(int cursorPos);
	virtual void selectCheck();
protected: //InputSignal
	virtual void cursorMoved(int x,int y,Panel* panel);
	virtual void cursorEntered(Panel* panel);
	virtual void cursorExited(Panel* panel);
	virtual void mousePressed(MouseCode code,Panel* panel);
	virtual void mouseDoublePressed(MouseCode code,Panel* panel);
	virtual void mouseReleased(MouseCode code,Panel* panel);
	virtual void mouseWheeled(int delta,Panel* panel);
	virtual void keyPressed(KeyCode code,Panel* panel);
	virtual void keyTyped(KeyCode code,Panel* panel);
	virtual void keyReleased(KeyCode code,Panel* panel); 
	virtual void keyFocusTicked(Panel* panel);
protected:
	Dar<char>          _lineDar;
	int                _cursorPos;
	bool               _cursorBlink;
	bool               _hideText;
	long               _cursorNextBlinkTime;
	int                _cursorBlinkRate;
	int                _select[2];
	Dar<ActionSignal*> _actionSignalDar;
	Font*              _font;
};

}

#endif
```

`halflife/vgui/VGUI_TextGrid.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_TEXTGRID_H
#define VGUI_TEXTGRID_H

#include "stdarg.h"
#include "VGUI.h"
#include "VGUI_Panel.h"

namespace vgui
{

class VGUIAPI TextGrid : public Panel
{
public:	
	TextGrid(int gridWide,int gridTall,int x,int y,int wide,int tall);
public:
	virtual void setGridSize(int wide,int tall);
	virtual void newLine();
	virtual void setXY(int x,int y);
	//virtual void setBgColor(int r,int g,int b);
	//virtual void setFgColor(int r,int g,int b);
	virtual int  vprintf(const char* format,va_list argList);
	virtual int  printf(const char* format,...);
protected:
	virtual void paintBackground();
protected:
	int   _xy[2];
	int   _bgColor[3];
	int   _fgColor[3];
	char* _grid; //[_gridSize[0]*_gridSize[1]*7] ch,br,bg,bb,fr,fg,fb
	int	  _gridSize[2];
};

}

#endif
```

`halflife/vgui/VGUI_TextImage.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_TEXTIMAGE_H
#define VGUI_TEXTIMAGE_H

#include "VGUI.h"
#include "VGUI_Image.h"
#include "VGUI_Scheme.h"


//TODO: need to add wrapping flag instead of being arbitrary about when wrapping and auto-resizing actually happens
//		This is probably why you are having problems if you had text in a constructor and then changed the font

namespace vgui
{

class Panel;
class Font;
class App;

class VGUIAPI TextImage : public Image
{
private:
	char*                     _text;
	int                       _textBufferLen;
	vgui::Scheme::SchemeFont  _schemeFont;
	vgui::Font*               _font;
	int                       _textColor[4];
	vgui::Scheme::SchemeColor _textSchemeColor;
public:	
	TextImage(int textBufferLen,const char* text);
	TextImage(const char* text);
private:
	virtual void  init(int textBufferLen,const char* text);
public:
	virtual void  getTextSize(int& wide,int& tall);
	virtual void  getTextSizeWrapped(int& wide,int& tall);
	virtual Font* getFont();
	virtual void  setText(int textBufferLen,const char* text);
	virtual void  setText(const char* text);
	virtual void  setFont(vgui::Scheme::SchemeFont schemeFont);
	virtual void  setFont(vgui::Font* font);
	virtual void  setSize(int wide,int tall);
protected:
	virtual void paint(Panel* panel);
};

}

#endif




```

`halflife/vgui/VGUI_TextPanel.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_TEXTPANEL_H
#define VGUI_TEXTPANEL_H

#include "VGUI.h"
#include "VGUI_Panel.h"
#include "VGUI_Scheme.h"

//NOTE : If you are having trouble with this class, your problem is probably in TextImage

namespace vgui
{

class TextImage;
class Font;

class VGUIAPI TextPanel : public Panel
{
private:
	TextImage* _textImage;
public:
	TextPanel(const char* text,int x,int y,int wide,int tall);
public:
	virtual void setText(const char* text);
	virtual void setFont(vgui::Scheme::SchemeFont schemeFont);
	virtual void setFont(vgui::Font* font);
	virtual void setSize(int wide,int tall);
	virtual void setFgColor(int r,int g,int b,int a);
	virtual void setFgColor(Scheme::SchemeColor sc);
	virtual TextImage* getTextImage();
protected:
	virtual void paint();
};

}

#endif




```

`halflife/vgui/VGUI_TickSignal.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_TICKSIGNAL_H
#define VGUI_TICKSIGNAL_H

#include "VGUI.h"

namespace vgui
{
class VGUIAPI TickSignal
 {
 public:
  virtual void ticked()=0;
 };
}

#endif
```

`halflife/vgui/VGUI_ToggleButton.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_TOGGLEBUTTON_H
#define VGUI_TOGGLEBUTTON_H

#include "VGUI.h"
#include "VGUI_Button.h"

namespace vgui
{

class VGUIAPI ToggleButton : public Button
{
public:
	ToggleButton(const char* text,int x,int y,int wide,int tall);
	ToggleButton(const char* text,int x,int y);
};

}

#endif
```

`halflife/vgui/VGUI_TreeFolder.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_TREEFOLDER_H
#define VGUI_TREEFOLDER_H

#include "VGUI.h"
#include "VGUI_Panel.h"

namespace vgui
{

class VGUIAPI TreeFolder : public Panel
{
public:
	TreeFolder(const char* name);
	TreeFolder(const char* name,int x,int y);
protected:
	virtual void init(const char* name);
public:
	virtual void setOpenedTraverse(bool state);
	virtual void setOpened(bool state);
	virtual bool isOpened();
protected:
	virtual void paintBackground();
protected:
	bool _opened;
};

}

#endif
```

`halflife/vgui/VGUI_WizardPanel.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VGUI_WIZARDPANEL_H
#define VGUI_WIZARDPANEL_H

#include "VGUI_Panel.h"
#include "VGUI_Dar.h"
#include "VGUI_Button.h"

namespace vgui
{

class ActionSignal;

class VGUIAPI WizardPanel : public Panel
{

public:

	class VGUIAPI WizardPage : public Panel
	{
	
	friend class WizardPanel;
	
	private:

		WizardPage* _backWizardPage;
		WizardPage* _nextWizardPage;
		bool        _backButtonEnabled;
		bool        _nextButtonEnabled;
		bool        _finishedButtonEnabled;
		bool        _cancelButtonEnabled;
		bool        _backButtonVisible;
		bool        _nextButtonVisible;
		bool        _finishedButtonVisible;
		bool        _cancelButtonVisible;
		char*       _backButtonText;
		char*       _nextButtonText;
		char*       _finishedButtonText;
		char*       _cancelButtonText;
		Dar<ActionSignal*> _switchingToBackPageSignalDar;
		Dar<ActionSignal*> _switchingToNextPageSignalDar;
		char*       _title;
		Panel*      _wantedFocus;

	private:
		
		virtual void fireSwitchingToBackPageSignals();
		virtual void fireSwitchingToNextPageSignals();
		virtual void init();

	public:

		WizardPage();
		WizardPage(int wide,int tall);

	public:

		virtual void        setBackWizardPage(WizardPage* backWizardPage);
		virtual void        setNextWizardPage(WizardPage* nextWizardPage);
		virtual WizardPage* getBackWizardPage();
		virtual WizardPage* getNextWizardPage();

		virtual bool        isBackButtonEnabled();
		virtual bool        isNextButtonEnabled();
		virtual bool        isFinishedButtonEnabled();
		virtual bool        isCancelButtonEnabled();
		virtual void        setBackButtonEnabled(bool state);
		virtual void        setNextButtonEnabled(bool state);
		virtual void        setFinishedButtonEnabled(bool state);
		virtual void        setCancelButtonEnabled(bool state);

		virtual bool        isBackButtonVisible();
		virtual bool        isNextButtonVisible();
		virtual bool        isFinishedButtonVisible();
		virtual bool        isCancelButtonVisible();
		virtual void        setBackButtonVisible(bool state);
		virtual void        setNextButtonVisible(bool state);
		virtual void        setFinishedButtonVisible(bool state);
		virtual void        setCancelButtonVisible(bool state);

		virtual void        getBackButtonText(char* text,int textLen);
		virtual void        getNextButtonText(char* text,int textLen);
		virtual void        getFinishedButtonText(char* text,int textLen);
		virtual void        getCancelButtonText(char* text,int textLen);
        virtual void        setBackButtonText(const char* text);
		virtual void        setNextButtonText(const char* text);
		virtual void        setFinishedButtonText(const char* text);
		virtual void        setCancelButtonText(const char* text);

		virtual void		setWantedFocus(Panel* panel);
		virtual Panel*		getWantedFocus();

		virtual void        addSwitchingToBackPageSignal(ActionSignal* s);
		virtual void        addSwitchingToNextPageSignal(ActionSignal* s);

		virtual void        setTitle(const char* title);
		virtual void        getTitle(char* buf,int bufLen);

	};

private:

	Button*     _backButton;
	Button*     _nextButton;
	Button*     _finishedButton;
	Button*     _cancelButton;
	WizardPage* _currentWizardPage;
	Dar<ActionSignal*> _pageChangedActionSignalDar;

private:

	virtual void fireFinishedActionSignal();
	virtual void fireCancelledActionSignal();
	virtual void firePageChangedActionSignal();

protected:

	virtual void performLayout();

public:

	WizardPanel(int x,int y,int wide,int tall);

public:

	virtual void setCurrentWizardPage(WizardPage* currentWizardPage);
	virtual void addFinishedActionSignal(ActionSignal* s);
	virtual void addCancelledActionSignal(ActionSignal* s);
	virtual void addPageChangedActionSignal(ActionSignal* s);
	virtual void doBack();
	virtual void doNext();
	virtual void getCurrentWizardPageTitle(char* buf,int bufLen);
	virtual WizardPage* getCurrentWizardPage();

};

}


#endif


```

`halflife/vgui2/IEngineVGui.h`:

```h
#ifndef IENGINEVGUI_H
#define IENGINEVGUI_H
#ifdef _WIN32
#pragma once
#endif

namespace vgui
{
	enum VGUIPANEL
	{
		PANEL_ROOT = 0 ,
		PANEL_CLIENTDLL ,
		PANEL_GAMEUIDLL
	};

	class IEngineVGui : public IBaseInterface
	{
	public:
		virtual vgui::IPanel* GetPanel( VGUIPANEL type ) = 0;
	};
}

extern vgui::IEngineVGui* g_pIEngineVGui;

#define VENGINE_VGUI_VERSION "VEngineVGui001"
#endif
```

`halflife/vgui2/IHTML.h`:

```h
#ifndef IHTML_H
#define IHTML_H
#ifdef _WIN32
#pragma once
#endif

#include "ISurface.h"

namespace vgui
{
	class IHTML
	{
	public:
		enum MOUSE_STATE { UP , DOWN , MOVE };

	public:
		virtual void OpenURL( const char *url ) = 0;
		virtual bool StopLoading( void ) = 0;
		virtual bool Refresh( void ) = 0;
		virtual bool Show( bool shown ) = 0;
		virtual char *GetOpenedPage( void ) = 0;
		virtual void OnSize( int x , int y , int w , int h ) = 0;
		virtual void GetHTMLSize( int &wide , int &tall ) = 0;
		virtual void Clear( void ) = 0;
		virtual void AddText( const char *text ) = 0;
		virtual void OnMouse( MouseCode code , MOUSE_STATE s , int x , int y ) = 0;
		virtual void OnChar( wchar_t unichar ) = 0;
		virtual void OnKeyDown( KeyCode code ) = 0;
		virtual IImage *GetBitmap( void ) = 0;
		virtual void SetVisible( bool state ) = 0;
	};

	class IHTMLEvents
	{
	public:
		virtual bool OnStartURL( const char *url , const char *target , bool first ) = 0;
		virtual void OnFinishURL( const char *url ) = 0;
		virtual void OnProgressURL( long current , long maximum ) = 0;
		virtual void OnSetStatusText( const char *text ) = 0;
		virtual void OnUpdate( void ) = 0;
		virtual void OnLink( void ) = 0;
		virtual void OffLink( void ) = 0;
	};
}

#endif
```

`halflife/vgui2/IPanel.h`:

```h
#ifndef IPANEL_H
#define IPANEL_H
#ifdef _WIN32
#pragma once
#endif

#ifdef SendMessage
#undef GetClassName
#endif
#ifdef SendMessage
#undef SendMessage
#endif

class KeyValues;

namespace vgui
{
	class SurfacePlat;
	class IClientPanel;
	
	class IPanel : public IBaseInterface
	{
	public:
		virtual void Init( IPanel* vguiPanel , IClientPanel *panel ) = 0;
		virtual void SetPos( IPanel* vguiPanel , int x , int y ) = 0;
		virtual void GetPos( IPanel* vguiPanel , int &x , int &y ) = 0;
		virtual void SetSize( IPanel* vguiPanel , int wide , int tall ) = 0;
		virtual void GetSize( IPanel* vguiPanel , int &wide , int &tall ) = 0;
		virtual void SetMinimumSize( IPanel* vguiPanel , int wide , int tall ) = 0;
		virtual void GetMinimumSize( IPanel* vguiPanel , int &wide , int &tall ) = 0;
		virtual void SetZPos( IPanel* vguiPanel , int z ) = 0;
		virtual int GetZPos( IPanel* vguiPanel ) = 0;
		virtual void GetAbsPos( IPanel* vguiPanel , int &x , int &y ) = 0;
		virtual void GetClipRect( IPanel* vguiPanel , int &x0 , int &y0 , int &x1 , int &y1 ) = 0;
		virtual void SetInset( IPanel* vguiPanel , int left , int top , int right , int bottom ) = 0;
		virtual void GetInset( IPanel* vguiPanel , int &left , int &top , int &right , int &bottom ) = 0;
		virtual void SetVisible( IPanel* vguiPanel , bool state ) = 0;
		virtual bool IsVisible( IPanel* vguiPanel ) = 0;
		virtual void SetParent( IPanel* vguiPanel , IPanel* newParent ) = 0;
		virtual int GetChildCount( IPanel* vguiPanel ) = 0;
		virtual IPanel* GetChild( IPanel* vguiPanel , int index ) = 0;
		virtual IPanel* GetParent( IPanel* vguiPanel ) = 0;
		virtual void MoveToFront( IPanel* vguiPanel ) = 0;
		virtual void MoveToBack( IPanel* vguiPanel ) = 0;
		virtual bool HasParent( IPanel* vguiPanel , IPanel* potentialParent ) = 0;
		virtual bool IsPopup( IPanel* vguiPanel ) = 0;
		virtual void SetPopup( IPanel* vguiPanel , bool state ) = 0;
		virtual bool Render_GetPopupVisible( IPanel* vguiPanel ) = 0;
		virtual void Render_SetPopupVisible( IPanel* vguiPanel , bool state ) = 0;
		virtual vgui::Scheme GetScheme( IPanel* vguiPanel ) = 0;
		virtual bool IsProportional( IPanel* vguiPanel ) = 0;
		virtual bool IsAutoDeleteSet( IPanel* vguiPanel ) = 0;
		virtual void DeletePanel( IPanel* vguiPanel ) = 0;
		virtual void SetKeyBoardInputEnabled( IPanel* vguiPanel , bool state ) = 0;
		virtual void SetMouseInputEnabled( IPanel* vguiPanel , bool state ) = 0;
		virtual bool IsKeyBoardInputEnabled( IPanel* vguiPanel ) = 0;
		virtual bool IsMouseInputEnabled( IPanel* vguiPanel ) = 0;
		virtual void Solve( IPanel* vguiPanel ) = 0;
		virtual const char *GetName( IPanel* vguiPanel ) = 0;
		virtual const char *GetClassName( IPanel* vguiPanel ) = 0;
		virtual void SendMessage( IPanel* vguiPanel , KeyValues *params , IPanel* ifromPanel ) = 0;
		virtual void Think( IPanel* vguiPanel ) = 0;
		virtual void PerformApplySchemeSettings( IPanel* vguiPanel ) = 0;
		virtual void PaintTraverse( IPanel* vguiPanel , bool forceRepaint , bool allowForce = true ) = 0;
		virtual void Repaint( IPanel* vguiPanel ) = 0;
		virtual IPanel* IsWithinTraverse( IPanel* vguiPanel , int x , int y , bool traversePopups ) = 0;
		virtual void OnChildAdded( IPanel* vguiPanel , IPanel* child ) = 0;
		virtual void OnSizeChanged( IPanel* vguiPanel , int newWide , int newTall ) = 0;
		virtual void InternalFocusChanged( IPanel* vguiPanel , bool lost ) = 0;
		virtual bool RequestInfo( IPanel* vguiPanel , KeyValues *outputData ) = 0;
		virtual void RequestFocus( IPanel* vguiPanel , int direction = 0 ) = 0;
		virtual bool RequestFocusPrev( IPanel* vguiPanel , IPanel* existingPanel ) = 0;
		virtual bool RequestFocusNext( IPanel* vguiPanel , IPanel* existingPanel ) = 0;
		virtual IPanel* GetCurrentKeyFocus( IPanel* vguiPanel ) = 0;
		virtual int GetTabPosition( IPanel* vguiPanel ) = 0;
		virtual SurfacePlat *Plat( IPanel* vguiPanel ) = 0;
		virtual void SetPlat( IPanel* vguiPanel , SurfacePlat *Plat ) = 0;
		virtual IPanel *GetPanel( IPanel* vguiPanel , const char *destinationModule ) = 0;
		virtual bool IsEnabled( IPanel* vguiPanel ) = 0;
		virtual void SetEnabled( IPanel* vguiPanel , bool state ) = 0;
		virtual void *Client( IPanel* vguiPanel ) = 0;
		virtual const char *GetModuleName( IPanel* vguiPanel ) = 0;
	};
}

extern vgui::IPanel* g_pIPanel;

#define VGUI_PANEL_INTERFACE_VERSION "VGUI_Panel007"
#endif
```

`halflife/vgui2/ISurface.h`:

```h
#ifndef ISURFACE_H
#define ISURFACE_H
#ifdef _WIN32
#pragma once
#endif

#ifdef CreateFont
#undef CreateFont
#endif

#ifdef PlaySound
#undef PlaySound
#endif

#include "IPanel.h"
#include "IHTML.h"

class Color;

template< typename Function > Function call_func( PVOID Base , DWORD Index )
{
	PDWORD* VTablePointer = (PDWORD*)Base;
	PDWORD VTableFunctionBase = *VTablePointer;
	DWORD dwAddress = VTableFunctionBase[Index];
	return (Function)( dwAddress );
}

namespace vgui
{
	class IImage;
	class Image;
	class Point;
	class IHTML;
	class IHTMLEvents;

	typedef unsigned long HCursor;
	typedef unsigned long HTexture;
	typedef unsigned long HFont;

	class ISurface : public IBaseInterface
	{
	public:
		enum EFontFlags
		{
			FONTFLAG_NONE ,
			FONTFLAG_ITALIC = 0x001 ,
			FONTFLAG_UNDERLINE = 0x002 ,
			FONTFLAG_STRIKEOUT = 0x004 ,
			FONTFLAG_SYMBOL = 0x008 ,
			FONTFLAG_ANTIALIAS = 0x010 ,
			FONTFLAG_GAUSSIANBLUR = 0x020 ,
			FONTFLAG_ROTARY = 0x040 ,
			FONTFLAG_DROPSHADOW = 0x080 ,
			FONTFLAG_ADDITIVE = 0x100 ,
			FONTFLAG_OUTLINE = 0x200 ,
		};

		enum SurfaceFeature_e
		{
			ANTIALIASED_FONTS = 1 ,
			DROPSHADOW_FONTS = 2 ,
			ESCAPE_KEY = 3 ,
			OPENING_NEW_HTML_WINDOWS = 4 ,
			FRAME_MINIMIZE_MAXIMIZE = 5 ,
			DIRECT_HWND_RENDER = 6 ,
		};

	public:
		virtual void Shutdown( void ) = 0;
		virtual void RunFrame( void ) = 0;
		virtual IPanel* GetEmbeddedPanel( void ) = 0;
		virtual void SetEmbeddedPanel( IPanel* pPanel ) = 0;
		virtual void PushMakeCurrent( IPanel* panel , bool useInsets ) = 0;
		virtual void PopMakeCurrent( IPanel* panel ) = 0;
		virtual void DrawSetColor( int r , int g , int b , int a ) = 0;
		virtual void DrawSetColor( Color col ) = 0;
		virtual void DrawFilledRect( int x0 , int y0 , int x1 , int y1 ) = 0;
		virtual void DrawOutlinedRect( int x0 , int y0 , int x1 , int y1 ) = 0;
		virtual void DrawLine( int x0 , int y0 , int x1 , int y1 ) = 0;
		virtual void DrawPolyLine( int *px , int *py , int numPoints ) = 0;
		virtual void DrawSetTextFont( HFont font ) = 0;
		virtual void DrawSetTextColor( int r , int g , int b , int a ) = 0;
		virtual void DrawSetTextColor( Color col ) = 0;
		virtual void DrawSetTextPos( int x , int y ) = 0;
		virtual void DrawGetTextPos( int &x , int &y ) = 0;
		virtual void DrawPrintText( const wchar_t *text , int textLen ) = 0;
		virtual void DrawUnicodeChar( wchar_t wch ) = 0;
		virtual void DrawUnicodeCharAdd( wchar_t wch ) = 0;
		virtual void DrawFlushText( void ) = 0;
		virtual IHTML* CreateHTMLWindow( IHTMLEvents *events , IPanel* context ) = 0;
		virtual void PaintHTMLWindow( IHTML *htmlwin ) = 0;
		virtual void DeleteHTMLWindow( IHTML *htmlwin ) = 0;
		virtual void DrawSetTextureFile( int id , const char *filename , int hardwareFilter , bool forceReload ) = 0;
		virtual void DrawSetTextureRGBA( int id , const unsigned char *rgba , int wide , int tall , int hardwareFilter , bool forceReload ) = 0;
		virtual void DrawSetTexture( int id ) = 0;
		virtual void DrawGetTextureSize( int id , int &wide , int &tall ) = 0;
		virtual void DrawTexturedRect( int x0 , int y0 , int x1 , int y1 ) = 0;
		virtual bool IsTextureIDValid( int id ) = 0;
		virtual int CreateNewTextureID( bool procedural = false ) = 0;
		virtual void GetScreenSize( int &wide , int &tall ) = 0;
		virtual void SetAsTopMost( IPanel* panel , bool state ) = 0;
		virtual void BringToFront( IPanel* panel ) = 0;
		virtual void SetForegroundWindow( IPanel* panel ) = 0;
		virtual void SetPanelVisible( IPanel* panel , bool state ) = 0;
		virtual void SetMinimized( IPanel* panel , bool state ) = 0;
		virtual bool IsMinimized( IPanel* panel ) = 0;
		virtual void FlashWindow( IPanel* panel , bool state ) = 0;
		virtual void SetTitle( IPanel* panel , const wchar_t *title ) = 0;
		virtual void SetAsToolBar( IPanel* panel , bool state ) = 0;
		virtual void CreatePopup( IPanel* panel , bool minimised , bool showTaskbarIcon = true , bool disabled = false , bool mouseInput = true , bool kbInput = true ) = 0;
		virtual void SwapBuffers( IPanel* panel ) = 0;
		virtual void Invalidate( IPanel* panel ) = 0;
		virtual void SetCursor( HCursor cursor ) = 0;
		virtual bool IsCursorVisible( void ) = 0;
		virtual void ApplyChanges( void ) = 0;
		virtual bool IsWithin( int x , int y ) = 0;
		virtual bool HasFocus( void ) = 0;
		virtual bool SupportsFeature( SurfaceFeature_e feature ) = 0;
		virtual void RestrictPaintToSinglePanel( IPanel* panel ) = 0;
		virtual void SetModalPanel( IPanel* panel ) = 0;
		virtual IPanel* GetModalPanel( void ) = 0;
		virtual void UnlockCursor( void ) = 0;
		virtual void LockCursor( void ) = 0;
		virtual void SetTranslateExtendedKeys( bool state ) = 0;
		virtual IPanel* GetTopmostPopup( void ) = 0;
		virtual void SetTopLevelFocus( IPanel* panel ) = 0;
		virtual HFont CreateFont( void ) = 0;
		virtual bool AddGlyphSetToFont( HFont font , const char *windowsFontName , int tall , int weight , int blur , int scanlines , int flags , int lowRange , int highRange ) = 0;
		virtual bool AddCustomFontFile( const char *fontFileName ) = 0;
		virtual int GetFontTall( HFont font ) = 0;
		virtual void GetCharABCwide( HFont font , int ch , int &a , int &b , int &c ) = 0;
		virtual int GetCharacterWidth( HFont font , int ch ) = 0;
		virtual void GetTextSize( HFont font , const wchar_t *text , int &wide , int &tall ) = 0;
		virtual IPanel* GetNotifyPanel( void ) = 0;
		virtual void SetNotifyIcon( IPanel* context , HTexture icon , IPanel* panelToReceiveMessages , const char *text ) = 0;
		virtual void PlaySound( const char *fileName ) = 0;
		virtual int GetPopupCount( void ) = 0;
		virtual IPanel* GetPopup( int index ) = 0;
		virtual bool ShouldPaintChildPanel( IPanel* childPanel ) = 0;
		virtual bool RecreateContext( IPanel* panel ) = 0;
		virtual void AddPanel( IPanel* panel ) = 0;
		virtual void ReleasePanel( IPanel* panel ) = 0;
		virtual void MovePopupToFront( IPanel* panel ) = 0;
		virtual void MovePopupToBack( IPanel* panel ) = 0;
		virtual void SolveTraverse( IPanel* panel , bool forceApplySchemeSettings = false ) = 0;
		virtual void PaintTraverse( IPanel* panel ) = 0;
		virtual void EnableMouseCapture( IPanel* panel , bool state ) = 0;
		virtual void GetWorkspaceBounds( int &x , int &y , int &wide , int &tall ) = 0;
		virtual void GetAbsoluteWindowBounds( int &x , int &y , int &wide , int &tall ) = 0;
		virtual void GetProportionalBase( int &width , int &height ) = 0;
		virtual void CalculateMouseVisible( void ) = 0;
		virtual bool NeedKBInput( void ) = 0;
		virtual bool HasCursorPosFunctions( void ) = 0;
		virtual void SurfaceGetCursorPos( int &x , int &y ) = 0;
		virtual void SurfaceSetCursorPos( int x , int y ) = 0;
		virtual void DrawTexturedPolygon( int *p , int n ) = 0;
		virtual int GetFontAscent( HFont font , wchar_t wch ) = 0;
		virtual void SetAllowHTMLJavaScript( bool state ) = 0;
	};
}

extern vgui::ISurface* g_pISurface;

#define VGUI_SURFACE_INTERFACE_VERSION "VGUI_Surface026"
#endif
```

`sakura.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.29001.49
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "sakura", "sakura\sakura.vcxproj", "{24F343A3-4BE5-4300-A129-3CBD7B511F65}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "sakura loader", "sakura\loader\loader.vcxproj", "{675311A9-B1B8-4314-9B85-8F7B9892329B}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{24F343A3-4BE5-4300-A129-3CBD7B511F65}.Debug|x64.ActiveCfg = Debug|Win32
		{24F343A3-4BE5-4300-A129-3CBD7B511F65}.Debug|x86.ActiveCfg = Debug|Win32
		{24F343A3-4BE5-4300-A129-3CBD7B511F65}.Debug|x86.Build.0 = Debug|Win32
		{24F343A3-4BE5-4300-A129-3CBD7B511F65}.Release|x64.ActiveCfg = Release|Win32
		{24F343A3-4BE5-4300-A129-3CBD7B511F65}.Release|x86.ActiveCfg = Release|Win32
		{24F343A3-4BE5-4300-A129-3CBD7B511F65}.Release|x86.Build.0 = Release|Win32
		{675311A9-B1B8-4314-9B85-8F7B9892329B}.Debug|x64.ActiveCfg = Debug|Win32
		{675311A9-B1B8-4314-9B85-8F7B9892329B}.Debug|x86.ActiveCfg = Debug|Win32
		{675311A9-B1B8-4314-9B85-8F7B9892329B}.Debug|x86.Build.0 = Debug|Win32
		{675311A9-B1B8-4314-9B85-8F7B9892329B}.Release|x64.ActiveCfg = Release|Win32
		{675311A9-B1B8-4314-9B85-8F7B9892329B}.Release|x86.ActiveCfg = Release|Win32
		{675311A9-B1B8-4314-9B85-8F7B9892329B}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {20612924-FA19-4E3C-8FDE-85AFDAC61CBD}
	EndGlobalSection
EndGlobal

```

`sakura/libs/bass/bass.h`:

```h
/*
	BASS 2.4 C/C++ header file
	Copyright (c) 1999-2016 Un4seen Developments Ltd.

	See the BASS.CHM file for more detailed documentation
*/

#ifndef BASS_H
#define BASS_H

#ifdef _WIN32

#include "dll.h"

#include <wtypes.h>
typedef unsigned __int64 QWORD;
#else
#include <stdint.h>
#define WINAPI
#define CALLBACK
typedef uint8_t BYTE;
typedef uint16_t WORD;
typedef uint32_t DWORD;
typedef uint64_t QWORD;
#ifndef __OBJC__
typedef int BOOL;
#endif
#ifndef TRUE
#define TRUE 1
#define FALSE 0
#endif
#define LOBYTE(a) (BYTE)(a)
#define HIBYTE(a) (BYTE)((a)>>8)
#define LOWORD(a) (WORD)(a)
#define HIWORD(a) (WORD)((a)>>16)
#define MAKEWORD(a,b) (WORD)(((a)&0xff)|((b)<<8))
#define MAKELONG(a,b) (DWORD)(((a)&0xffff)|((b)<<16))
#endif

#ifdef __cplusplus
extern "C" {
#endif

#define BASSVERSION			0x204	// API version
#define BASSVERSIONTEXT		"2.4"

#ifndef BASSDEF
#define BASSDEF(f) WINAPI f
#else
#define NOBASSOVERLOADS
#endif

	typedef DWORD HMUSIC;		// MOD music handle
	typedef DWORD HSAMPLE;		// sample handle
	typedef DWORD HCHANNEL;		// playing sample's channel handle
	typedef DWORD HSTREAM;		// sample stream handle
	typedef DWORD HRECORD;		// recording handle
	typedef DWORD HSYNC;		// synchronizer handle
	typedef DWORD HDSP;			// DSP handle
	typedef DWORD HFX;			// DX8 effect handle
	typedef DWORD HPLUGIN;		// Plugin handle

	// Error codes returned by BASS_ErrorGetCode
#define BASS_OK				0	// all is OK
#define BASS_ERROR_MEM		1	// memory error
#define BASS_ERROR_FILEOPEN	2	// can't open the file
#define BASS_ERROR_DRIVER	3	// can't find a free/valid driver
#define BASS_ERROR_BUFLOST	4	// the sample buffer was lost
#define BASS_ERROR_HANDLE	5	// invalid handle
#define BASS_ERROR_FORMAT	6	// unsupported sample format
#define BASS_ERROR_POSITION	7	// invalid position
#define BASS_ERROR_INIT		8	// BASS_Init has not been successfully called
#define BASS_ERROR_START	9	// BASS_Start has not been successfully called
#define BASS_ERROR_SSL		10	// SSL/HTTPS support isn't available
#define BASS_ERROR_ALREADY	14	// already initialized/paused/whatever
#define BASS_ERROR_NOCHAN	18	// can't get a free channel
#define BASS_ERROR_ILLTYPE	19	// an illegal type was specified
#define BASS_ERROR_ILLPARAM	20	// an illegal parameter was specified
#define BASS_ERROR_NO3D		21	// no 3D support
#define BASS_ERROR_NOEAX	22	// no EAX support
#define BASS_ERROR_DEVICE	23	// illegal device number
#define BASS_ERROR_NOPLAY	24	// not playing
#define BASS_ERROR_FREQ		25	// illegal sample rate
#define BASS_ERROR_NOTFILE	27	// the stream is not a file stream
#define BASS_ERROR_NOHW		29	// no hardware voices available
#define BASS_ERROR_EMPTY	31	// the MOD music has no sequence data
#define BASS_ERROR_NONET	32	// no internet connection could be opened
#define BASS_ERROR_CREATE	33	// couldn't create the file
#define BASS_ERROR_NOFX		34	// effects are not available
#define BASS_ERROR_NOTAVAIL	37	// requested data is not available
#define BASS_ERROR_DECODE	38	// the channel is/isn't a "decoding channel"
#define BASS_ERROR_DX		39	// a sufficient DirectX version is not installed
#define BASS_ERROR_TIMEOUT	40	// connection timedout
#define BASS_ERROR_FILEFORM	41	// unsupported file format
#define BASS_ERROR_SPEAKER	42	// unavailable speaker
#define BASS_ERROR_VERSION	43	// invalid BASS version (used by add-ons)
#define BASS_ERROR_CODEC	44	// codec is not available/supported
#define BASS_ERROR_ENDED	45	// the channel/file has ended
#define BASS_ERROR_BUSY		46	// the device is busy
#define BASS_ERROR_UNKNOWN	-1	// some other mystery problem

// BASS_SetConfig options
#define BASS_CONFIG_BUFFER			0
#define BASS_CONFIG_UPDATEPERIOD	1
#define BASS_CONFIG_GVOL_SAMPLE		4
#define BASS_CONFIG_GVOL_STREAM		5
#define BASS_CONFIG_GVOL_MUSIC		6
#define BASS_CONFIG_CURVE_VOL		7
#define BASS_CONFIG_CURVE_PAN		8
#define BASS_CONFIG_FLOATDSP		9
#define BASS_CONFIG_3DALGORITHM		10
#define BASS_CONFIG_NET_TIMEOUT		11
#define BASS_CONFIG_NET_BUFFER		12
#define BASS_CONFIG_PAUSE_NOPLAY	13
#define BASS_CONFIG_NET_PREBUF		15
#define BASS_CONFIG_NET_PASSIVE		18
#define BASS_CONFIG_REC_BUFFER		19
#define BASS_CONFIG_NET_PLAYLIST	21
#define BASS_CONFIG_MUSIC_VIRTUAL	22
#define BASS_CONFIG_VERIFY			23
#define BASS_CONFIG_UPDATETHREADS	24
#define BASS_CONFIG_DEV_BUFFER		27
#define BASS_CONFIG_VISTA_TRUEPOS	30
#define BASS_CONFIG_IOS_MIXAUDIO	34
#define BASS_CONFIG_DEV_DEFAULT		36
#define BASS_CONFIG_NET_READTIMEOUT	37
#define BASS_CONFIG_VISTA_SPEAKERS	38
#define BASS_CONFIG_IOS_SPEAKER		39
#define BASS_CONFIG_MF_DISABLE		40
#define BASS_CONFIG_HANDLES			41
#define BASS_CONFIG_UNICODE			42
#define BASS_CONFIG_SRC				43
#define BASS_CONFIG_SRC_SAMPLE		44
#define BASS_CONFIG_ASYNCFILE_BUFFER 45
#define BASS_CONFIG_OGG_PRESCAN		47
#define BASS_CONFIG_MF_VIDEO		48
#define BASS_CONFIG_AIRPLAY			49
#define BASS_CONFIG_DEV_NONSTOP		50
#define BASS_CONFIG_IOS_NOCATEGORY	51
#define BASS_CONFIG_VERIFY_NET		52
#define BASS_CONFIG_DEV_PERIOD		53
#define BASS_CONFIG_FLOAT			54
#define BASS_CONFIG_NET_SEEK		56

// BASS_SetConfigPtr options
#define BASS_CONFIG_NET_AGENT		16
#define BASS_CONFIG_NET_PROXY		17
#define BASS_CONFIG_IOS_NOTIFY		46

// BASS_Init flags
#define BASS_DEVICE_8BITS		1		// 8 bit
#define BASS_DEVICE_MONO		2		// mono
#define BASS_DEVICE_3D			4		// enable 3D functionality
#define BASS_DEVICE_16BITS		8		// limit output to 16 bit
#define BASS_DEVICE_LATENCY		0x100	// calculate device latency (BASS_INFO struct)
#define BASS_DEVICE_CPSPEAKERS	0x400	// detect speakers via Windows control panel
#define BASS_DEVICE_SPEAKERS	0x800	// force enabling of speaker assignment
#define BASS_DEVICE_NOSPEAKER	0x1000	// ignore speaker arrangement
#define BASS_DEVICE_DMIX		0x2000	// use ALSA "dmix" plugin
#define BASS_DEVICE_FREQ		0x4000	// set device sample rate
#define BASS_DEVICE_STEREO		0x8000	// limit output to stereo

// DirectSound interfaces (for use with BASS_GetDSoundObject)
#define BASS_OBJECT_DS		1	// IDirectSound
#define BASS_OBJECT_DS3DL	2	// IDirectSound3DListener

// Device info structure
	typedef struct {
#if defined(_WIN32_WCE) || (WINAPI_FAMILY && WINAPI_FAMILY!=WINAPI_FAMILY_DESKTOP_APP)
		const wchar_t *name;	// description
		const wchar_t *driver;	// driver
#else
		const char *name;	// description
		const char *driver;	// driver
#endif
		DWORD flags;
	} BASS_DEVICEINFO;

	// BASS_DEVICEINFO flags
#define BASS_DEVICE_ENABLED		1
#define BASS_DEVICE_DEFAULT		2
#define BASS_DEVICE_INIT		4

#define BASS_DEVICE_TYPE_MASK			0xff000000
#define BASS_DEVICE_TYPE_NETWORK		0x01000000
#define BASS_DEVICE_TYPE_SPEAKERS		0x02000000
#define BASS_DEVICE_TYPE_LINE			0x03000000
#define BASS_DEVICE_TYPE_HEADPHONES		0x04000000
#define BASS_DEVICE_TYPE_MICROPHONE		0x05000000
#define BASS_DEVICE_TYPE_HEADSET		0x06000000
#define BASS_DEVICE_TYPE_HANDSET		0x07000000
#define BASS_DEVICE_TYPE_DIGITAL		0x08000000
#define BASS_DEVICE_TYPE_SPDIF			0x09000000
#define BASS_DEVICE_TYPE_HDMI			0x0a000000
#define BASS_DEVICE_TYPE_DISPLAYPORT	0x40000000

// BASS_GetDeviceInfo flags
#define BASS_DEVICES_AIRPLAY	0x1000000

	typedef struct {
		DWORD flags;	// device capabilities (DSCAPS_xxx flags)
		DWORD hwsize;	// size of total device hardware memory
		DWORD hwfree;	// size of free device hardware memory
		DWORD freesam;	// number of free sample slots in the hardware
		DWORD free3d;	// number of free 3D sample slots in the hardware
		DWORD minrate;	// min sample rate supported by the hardware
		DWORD maxrate;	// max sample rate supported by the hardware
		BOOL eax;		// device supports EAX? (always FALSE if BASS_DEVICE_3D was not used)
		DWORD minbuf;	// recommended minimum buffer length in ms (requires BASS_DEVICE_LATENCY)
		DWORD dsver;	// DirectSound version
		DWORD latency;	// delay (in ms) before start of playback (requires BASS_DEVICE_LATENCY)
		DWORD initflags; // BASS_Init "flags" parameter
		DWORD speakers; // number of speakers available
		DWORD freq;		// current output rate
	} BASS_INFO;

	// BASS_INFO flags (from DSOUND.H)
#define DSCAPS_CONTINUOUSRATE	0x00000010	// supports all sample rates between min/maxrate
#define DSCAPS_EMULDRIVER		0x00000020	// device does NOT have hardware DirectSound support
#define DSCAPS_CERTIFIED		0x00000040	// device driver has been certified by Microsoft
#define DSCAPS_SECONDARYMONO	0x00000100	// mono
#define DSCAPS_SECONDARYSTEREO	0x00000200	// stereo
#define DSCAPS_SECONDARY8BIT	0x00000400	// 8 bit
#define DSCAPS_SECONDARY16BIT	0x00000800	// 16 bit

// Recording device info structure
	typedef struct {
		DWORD flags;	// device capabilities (DSCCAPS_xxx flags)
		DWORD formats;	// supported standard formats (WAVE_FORMAT_xxx flags)
		DWORD inputs;	// number of inputs
		BOOL singlein;	// TRUE = only 1 input can be set at a time
		DWORD freq;		// current input rate
	} BASS_RECORDINFO;

	// BASS_RECORDINFO flags (from DSOUND.H)
#define DSCCAPS_EMULDRIVER		DSCAPS_EMULDRIVER	// device does NOT have hardware DirectSound recording support
#define DSCCAPS_CERTIFIED		DSCAPS_CERTIFIED	// device driver has been certified by Microsoft

// defines for formats field of BASS_RECORDINFO (from MMSYSTEM.H)
#ifndef WAVE_FORMAT_1M08
#define WAVE_FORMAT_1M08       0x00000001       /* 11.025 kHz, Mono,   8-bit  */
#define WAVE_FORMAT_1S08       0x00000002       /* 11.025 kHz, Stereo, 8-bit  */
#define WAVE_FORMAT_1M16       0x00000004       /* 11.025 kHz, Mono,   16-bit */
#define WAVE_FORMAT_1S16       0x00000008       /* 11.025 kHz, Stereo, 16-bit */
#define WAVE_FORMAT_2M08       0x00000010       /* 22.05  kHz, Mono,   8-bit  */
#define WAVE_FORMAT_2S08       0x00000020       /* 22.05  kHz, Stereo, 8-bit  */
#define WAVE_FORMAT_2M16       0x00000040       /* 22.05  kHz, Mono,   16-bit */
#define WAVE_FORMAT_2S16       0x00000080       /* 22.05  kHz, Stereo, 16-bit */
#define WAVE_FORMAT_4M08       0x00000100       /* 44.1   kHz, Mono,   8-bit  */
#define WAVE_FORMAT_4S08       0x00000200       /* 44.1   kHz, Stereo, 8-bit  */
#define WAVE_FORMAT_4M16       0x00000400       /* 44.1   kHz, Mono,   16-bit */
#define WAVE_FORMAT_4S16       0x00000800       /* 44.1   kHz, Stereo, 16-bit */
#endif

// Sample info structure
	typedef struct {
		DWORD freq;		// default playback rate
		float volume;	// default volume (0-1)
		float pan;		// default pan (-1=left, 0=middle, 1=right)
		DWORD flags;	// BASS_SAMPLE_xxx flags
		DWORD length;	// length (in bytes)
		DWORD max;		// maximum simultaneous playbacks
		DWORD origres;	// original resolution bits
		DWORD chans;	// number of channels
		DWORD mingap;	// minimum gap (ms) between creating channels
		DWORD mode3d;	// BASS_3DMODE_xxx mode
		float mindist;	// minimum distance
		float maxdist;	// maximum distance
		DWORD iangle;	// angle of inside projection cone
		DWORD oangle;	// angle of outside projection cone
		float outvol;	// delta-volume outside the projection cone
		DWORD vam;		// voice allocation/management flags (BASS_VAM_xxx)
		DWORD priority;	// priority (0=lowest, 0xffffffff=highest)
	} BASS_SAMPLE;

#define BASS_SAMPLE_8BITS		1	// 8 bit
#define BASS_SAMPLE_FLOAT		256	// 32 bit floating-point
#define BASS_SAMPLE_MONO		2	// mono
#define BASS_SAMPLE_LOOP		4	// looped
#define BASS_SAMPLE_3D			8	// 3D functionality
#define BASS_SAMPLE_SOFTWARE	16	// not using hardware mixing
#define BASS_SAMPLE_MUTEMAX		32	// mute at max distance (3D only)
#define BASS_SAMPLE_VAM			64	// DX7 voice allocation & management
#define BASS_SAMPLE_FX			128	// old implementation of DX8 effects
#define BASS_SAMPLE_OVER_VOL	0x10000	// override lowest volume
#define BASS_SAMPLE_OVER_POS	0x20000	// override longest playing
#define BASS_SAMPLE_OVER_DIST	0x30000 // override furthest from listener (3D only)

#define BASS_STREAM_PRESCAN		0x20000 // enable pin-point seeking/length (MP3/MP2/MP1)
#define BASS_MP3_SETPOS			BASS_STREAM_PRESCAN
#define BASS_STREAM_AUTOFREE	0x40000	// automatically free the stream when it stop/ends
#define BASS_STREAM_RESTRATE	0x80000	// restrict the download rate of internet file streams
#define BASS_STREAM_BLOCK		0x100000 // download/play internet file stream in small blocks
#define BASS_STREAM_DECODE		0x200000 // don't play the stream, only decode (BASS_ChannelGetData)
#define BASS_STREAM_STATUS		0x800000 // give server status info (HTTP/ICY tags) in DOWNLOADPROC

#define BASS_MUSIC_FLOAT		BASS_SAMPLE_FLOAT
#define BASS_MUSIC_MONO			BASS_SAMPLE_MONO
#define BASS_MUSIC_LOOP			BASS_SAMPLE_LOOP
#define BASS_MUSIC_3D			BASS_SAMPLE_3D
#define BASS_MUSIC_FX			BASS_SAMPLE_FX
#define BASS_MUSIC_AUTOFREE		BASS_STREAM_AUTOFREE
#define BASS_MUSIC_DECODE		BASS_STREAM_DECODE
#define BASS_MUSIC_PRESCAN		BASS_STREAM_PRESCAN	// calculate playback length
#define BASS_MUSIC_CALCLEN		BASS_MUSIC_PRESCAN
#define BASS_MUSIC_RAMP			0x200	// normal ramping
#define BASS_MUSIC_RAMPS		0x400	// sensitive ramping
#define BASS_MUSIC_SURROUND		0x800	// surround sound
#define BASS_MUSIC_SURROUND2	0x1000	// surround sound (mode 2)
#define BASS_MUSIC_FT2PAN		0x2000	// apply FastTracker 2 panning to XM files
#define BASS_MUSIC_FT2MOD		0x2000	// play .MOD as FastTracker 2 does
#define BASS_MUSIC_PT1MOD		0x4000	// play .MOD as ProTracker 1 does
#define BASS_MUSIC_NONINTER		0x10000	// non-interpolated sample mixing
#define BASS_MUSIC_SINCINTER	0x800000 // sinc interpolated sample mixing
#define BASS_MUSIC_POSRESET		0x8000	// stop all notes when moving position
#define BASS_MUSIC_POSRESETEX	0x400000 // stop all notes and reset bmp/etc when moving position
#define BASS_MUSIC_STOPBACK		0x80000	// stop the music on a backwards jump effect
#define BASS_MUSIC_NOSAMPLE		0x100000 // don't load the samples

	// Speaker assignment flags
#define BASS_SPEAKER_FRONT	0x1000000	// front speakers
#define BASS_SPEAKER_REAR	0x2000000	// rear/side speakers
#define BASS_SPEAKER_CENLFE	0x3000000	// center & LFE speakers (5.1)
#define BASS_SPEAKER_REAR2	0x4000000	// rear center speakers (7.1)
#define BASS_SPEAKER_N(n)	((n)<<24)	// n'th pair of speakers (max 15)
#define BASS_SPEAKER_LEFT	0x10000000	// modifier: left
#define BASS_SPEAKER_RIGHT	0x20000000	// modifier: right
#define BASS_SPEAKER_FRONTLEFT	BASS_SPEAKER_FRONT|BASS_SPEAKER_LEFT
#define BASS_SPEAKER_FRONTRIGHT	BASS_SPEAKER_FRONT|BASS_SPEAKER_RIGHT
#define BASS_SPEAKER_REARLEFT	BASS_SPEAKER_REAR|BASS_SPEAKER_LEFT
#define BASS_SPEAKER_REARRIGHT	BASS_SPEAKER_REAR|BASS_SPEAKER_RIGHT
#define BASS_SPEAKER_CENTER		BASS_SPEAKER_CENLFE|BASS_SPEAKER_LEFT
#define BASS_SPEAKER_LFE		BASS_SPEAKER_CENLFE|BASS_SPEAKER_RIGHT
#define BASS_SPEAKER_REAR2LEFT	BASS_SPEAKER_REAR2|BASS_SPEAKER_LEFT
#define BASS_SPEAKER_REAR2RIGHT	BASS_SPEAKER_REAR2|BASS_SPEAKER_RIGHT

#define BASS_ASYNCFILE			0x40000000
#define BASS_UNICODE			0x80000000

#define BASS_RECORD_PAUSE		0x8000	// start recording paused
#define BASS_RECORD_ECHOCANCEL	0x2000
#define BASS_RECORD_AGC			0x4000

// DX7 voice allocation & management flags
#define BASS_VAM_HARDWARE		1
#define BASS_VAM_SOFTWARE		2
#define BASS_VAM_TERM_TIME		4
#define BASS_VAM_TERM_DIST		8
#define BASS_VAM_TERM_PRIO		16

// Channel info structure
	typedef struct {
		DWORD freq;		// default playback rate
		DWORD chans;	// channels
		DWORD flags;	// BASS_SAMPLE/STREAM/MUSIC/SPEAKER flags
		DWORD ctype;	// type of channel
		DWORD origres;	// original resolution
		HPLUGIN plugin;	// plugin
		HSAMPLE sample; // sample
		const char *filename; // filename
	} BASS_CHANNELINFO;

	// BASS_CHANNELINFO types
#define BASS_CTYPE_SAMPLE		1
#define BASS_CTYPE_RECORD		2
#define BASS_CTYPE_STREAM		0x10000
#define BASS_CTYPE_STREAM_OGG	0x10002
#define BASS_CTYPE_STREAM_MP1	0x10003
#define BASS_CTYPE_STREAM_MP2	0x10004
#define BASS_CTYPE_STREAM_MP3	0x10005
#define BASS_CTYPE_STREAM_AIFF	0x10006
#define BASS_CTYPE_STREAM_CA	0x10007
#define BASS_CTYPE_STREAM_MF	0x10008
#define BASS_CTYPE_STREAM_WAV	0x40000 // WAVE flag, LOWORD=codec
#define BASS_CTYPE_STREAM_WAV_PCM	0x50001
#define BASS_CTYPE_STREAM_WAV_FLOAT	0x50003
#define BASS_CTYPE_MUSIC_MOD	0x20000
#define BASS_CTYPE_MUSIC_MTM	0x20001
#define BASS_CTYPE_MUSIC_S3M	0x20002
#define BASS_CTYPE_MUSIC_XM		0x20003
#define BASS_CTYPE_MUSIC_IT		0x20004
#define BASS_CTYPE_MUSIC_MO3	0x00100 // MO3 flag

	typedef struct {
		DWORD ctype;		// channel type
#if defined(_WIN32_WCE) || (WINAPI_FAMILY && WINAPI_FAMILY!=WINAPI_FAMILY_DESKTOP_APP)
		const wchar_t *name;	// format description
		const wchar_t *exts;	// file extension filter (*.ext1;*.ext2;etc...)
#else
		const char *name;	// format description
		const char *exts;	// file extension filter (*.ext1;*.ext2;etc...)
#endif
	} BASS_PLUGINFORM;

	typedef struct {
		DWORD version;					// version (same form as BASS_GetVersion)
		DWORD formatc;					// number of formats
		const BASS_PLUGINFORM *formats;	// the array of formats
	} BASS_PLUGININFO;

	// 3D vector (for 3D positions/velocities/orientations)
	typedef struct BASS_3DVECTOR {
#ifdef __cplusplus
		BASS_3DVECTOR() {};
		BASS_3DVECTOR(float _x, float _y, float _z) : x(_x), y(_y), z(_z) {};
#endif
		float x;	// +=right, -=left
		float y;	// +=up, -=down
		float z;	// +=front, -=behind
	} BASS_3DVECTOR;

	// 3D channel modes
#define BASS_3DMODE_NORMAL		0	// normal 3D processing
#define BASS_3DMODE_RELATIVE	1	// position is relative to the listener
#define BASS_3DMODE_OFF			2	// no 3D processing

// software 3D mixing algorithms (used with BASS_CONFIG_3DALGORITHM)
#define BASS_3DALG_DEFAULT	0
#define BASS_3DALG_OFF		1
#define BASS_3DALG_FULL		2
#define BASS_3DALG_LIGHT	3

// EAX environments, use with BASS_SetEAXParameters
	enum
	{
		EAX_ENVIRONMENT_GENERIC,
		EAX_ENVIRONMENT_PADDEDCELL,
		EAX_ENVIRONMENT_ROOM,
		EAX_ENVIRONMENT_BATHROOM,
		EAX_ENVIRONMENT_LIVINGROOM,
		EAX_ENVIRONMENT_STONEROOM,
		EAX_ENVIRONMENT_AUDITORIUM,
		EAX_ENVIRONMENT_CONCERTHALL,
		EAX_ENVIRONMENT_CAVE,
		EAX_ENVIRONMENT_ARENA,
		EAX_ENVIRONMENT_HANGAR,
		EAX_ENVIRONMENT_CARPETEDHALLWAY,
		EAX_ENVIRONMENT_HALLWAY,
		EAX_ENVIRONMENT_STONECORRIDOR,
		EAX_ENVIRONMENT_ALLEY,
		EAX_ENVIRONMENT_FOREST,
		EAX_ENVIRONMENT_CITY,
		EAX_ENVIRONMENT_MOUNTAINS,
		EAX_ENVIRONMENT_QUARRY,
		EAX_ENVIRONMENT_PLAIN,
		EAX_ENVIRONMENT_PARKINGLOT,
		EAX_ENVIRONMENT_SEWERPIPE,
		EAX_ENVIRONMENT_UNDERWATER,
		EAX_ENVIRONMENT_DRUGGED,
		EAX_ENVIRONMENT_DIZZY,
		EAX_ENVIRONMENT_PSYCHOTIC,

		EAX_ENVIRONMENT_COUNT			// total number of environments
	};

	// EAX presets, usage: BASS_SetEAXParameters(EAX_PRESET_xxx)
#define EAX_PRESET_GENERIC         EAX_ENVIRONMENT_GENERIC,0.5F,1.493F,0.5F
#define EAX_PRESET_PADDEDCELL      EAX_ENVIRONMENT_PADDEDCELL,0.25F,0.1F,0.0F
#define EAX_PRESET_ROOM            EAX_ENVIRONMENT_ROOM,0.417F,0.4F,0.666F
#define EAX_PRESET_BATHROOM        EAX_ENVIRONMENT_BATHROOM,0.653F,1.499F,0.166F
#define EAX_PRESET_LIVINGROOM      EAX_ENVIRONMENT_LIVINGROOM,0.208F,0.478F,0.0F
#define EAX_PRESET_STONEROOM       EAX_ENVIRONMENT_STONEROOM,0.5F,2.309F,0.888F
#define EAX_PRESET_AUDITORIUM      EAX_ENVIRONMENT_AUDITORIUM,0.403F,4.279F,0.5F
#define EAX_PRESET_CONCERTHALL     EAX_ENVIRONMENT_CONCERTHALL,0.5F,3.961F,0.5F
#define EAX_PRESET_CAVE            EAX_ENVIRONMENT_CAVE,0.5F,2.886F,1.304F
#define EAX_PRESET_ARENA           EAX_ENVIRONMENT_ARENA,0.361F,7.284F,0.332F
#define EAX_PRESET_HANGAR          EAX_ENVIRONMENT_HANGAR,0.5F,10.0F,0.3F
#define EAX_PRESET_CARPETEDHALLWAY EAX_ENVIRONMENT_CARPETEDHALLWAY,0.153F,0.259F,2.0F
#define EAX_PRESET_HALLWAY         EAX_ENVIRONMENT_HALLWAY,0.361F,1.493F,0.0F
#define EAX_PRESET_STONECORRIDOR   EAX_ENVIRONMENT_STONECORRIDOR,0.444F,2.697F,0.638F
#define EAX_PRESET_ALLEY           EAX_ENVIRONMENT_ALLEY,0.25F,1.752F,0.776F
#define EAX_PRESET_FOREST          EAX_ENVIRONMENT_FOREST,0.111F,3.145F,0.472F
#define EAX_PRESET_CITY            EAX_ENVIRONMENT_CITY,0.111F,2.767F,0.224F
#define EAX_PRESET_MOUNTAINS       EAX_ENVIRONMENT_MOUNTAINS,0.194F,7.841F,0.472F
#define EAX_PRESET_QUARRY          EAX_ENVIRONMENT_QUARRY,1.0F,1.499F,0.5F
#define EAX_PRESET_PLAIN           EAX_ENVIRONMENT_PLAIN,0.097F,2.767F,0.224F
#define EAX_PRESET_PARKINGLOT      EAX_ENVIRONMENT_PARKINGLOT,0.208F,1.652F,1.5F
#define EAX_PRESET_SEWERPIPE       EAX_ENVIRONMENT_SEWERPIPE,0.652F,2.886F,0.25F
#define EAX_PRESET_UNDERWATER      EAX_ENVIRONMENT_UNDERWATER,1.0F,1.499F,0.0F
#define EAX_PRESET_DRUGGED         EAX_ENVIRONMENT_DRUGGED,0.875F,8.392F,1.388F
#define EAX_PRESET_DIZZY           EAX_ENVIRONMENT_DIZZY,0.139F,17.234F,0.666F
#define EAX_PRESET_PSYCHOTIC       EAX_ENVIRONMENT_PSYCHOTIC,0.486F,7.563F,0.806F

	typedef DWORD(CALLBACK STREAMPROC)(HSTREAM handle, void *buffer, DWORD length, void *user);
	/* User stream callback function. NOTE: A stream function should obviously be as quick
	as possible, other streams (and MOD musics) can't be mixed until it's finished.
	handle : The stream that needs writing
	buffer : Buffer to write the samples in
	length : Number of bytes to write
	user   : The 'user' parameter value given when calling BASS_StreamCreate
	RETURN : Number of bytes written. Set the BASS_STREAMPROC_END flag to end
			 the stream. */

#define BASS_STREAMPROC_END		0x80000000	// end of user stream flag

			 // special STREAMPROCs
#define STREAMPROC_DUMMY		(STREAMPROC*)0		// "dummy" stream
#define STREAMPROC_PUSH			(STREAMPROC*)-1		// push stream

// BASS_StreamCreateFileUser file systems
#define STREAMFILE_NOBUFFER		0
#define STREAMFILE_BUFFER		1
#define STREAMFILE_BUFFERPUSH	2

// User file stream callback functions
	typedef void (CALLBACK FILECLOSEPROC)(void *user);
	typedef QWORD(CALLBACK FILELENPROC)(void *user);
	typedef DWORD(CALLBACK FILEREADPROC)(void *buffer, DWORD length, void *user);
	typedef BOOL(CALLBACK FILESEEKPROC)(QWORD offset, void *user);

	typedef struct {
		FILECLOSEPROC *close;
		FILELENPROC *length;
		FILEREADPROC *read;
		FILESEEKPROC *seek;
	} BASS_FILEPROCS;

	// BASS_StreamPutFileData options
#define BASS_FILEDATA_END		0	// end & close the file

// BASS_StreamGetFilePosition modes
#define BASS_FILEPOS_CURRENT	0
#define BASS_FILEPOS_DECODE		BASS_FILEPOS_CURRENT
#define BASS_FILEPOS_DOWNLOAD	1
#define BASS_FILEPOS_END		2
#define BASS_FILEPOS_START		3
#define BASS_FILEPOS_CONNECTED	4
#define BASS_FILEPOS_BUFFER		5
#define BASS_FILEPOS_SOCKET		6
#define BASS_FILEPOS_ASYNCBUF	7
#define BASS_FILEPOS_SIZE		8

	typedef void (CALLBACK DOWNLOADPROC)(const void *buffer, DWORD length, void *user);
	/* Internet stream download callback function.
	buffer : Buffer containing the downloaded data... NULL=end of download
	length : Number of bytes in the buffer
	user   : The 'user' parameter value given when calling BASS_StreamCreateURL */

	// BASS_ChannelSetSync types
#define BASS_SYNC_POS			0
#define BASS_SYNC_END			2
#define BASS_SYNC_META			4
#define BASS_SYNC_SLIDE			5
#define BASS_SYNC_STALL			6
#define BASS_SYNC_DOWNLOAD		7
#define BASS_SYNC_FREE			8
#define BASS_SYNC_SETPOS		11
#define BASS_SYNC_MUSICPOS		10
#define BASS_SYNC_MUSICINST		1
#define BASS_SYNC_MUSICFX		3
#define BASS_SYNC_OGG_CHANGE	12
#define BASS_SYNC_MIXTIME		0x40000000	// flag: sync at mixtime, else at playtime
#define BASS_SYNC_ONETIME		0x80000000	// flag: sync only once, else continuously

	typedef void (CALLBACK SYNCPROC)(HSYNC handle, DWORD channel, DWORD data, void *user);
	/* Sync callback function. NOTE: a sync callback function should be very
	quick as other syncs can't be processed until it has finished. If the sync
	is a "mixtime" sync, then other streams and MOD musics can't be mixed until
	it's finished either.
	handle : The sync that has occured
	channel: Channel that the sync occured in
	data   : Additional data associated with the sync's occurance
	user   : The 'user' parameter given when calling BASS_ChannelSetSync */

	typedef void (CALLBACK DSPPROC)(HDSP handle, DWORD channel, void *buffer, DWORD length, void *user);
	/* DSP callback function. NOTE: A DSP function should obviously be as quick as
	possible... other DSP functions, streams and MOD musics can not be processed
	until it's finished.
	handle : The DSP handle
	channel: Channel that the DSP is being applied to
	buffer : Buffer to apply the DSP to
	length : Number of bytes in the buffer
	user   : The 'user' parameter given when calling BASS_ChannelSetDSP */

	typedef BOOL(CALLBACK RECORDPROC)(HRECORD handle, const void *buffer, DWORD length, void *user);
	/* Recording callback function.
	handle : The recording handle
	buffer : Buffer containing the recorded sample data
	length : Number of bytes
	user   : The 'user' parameter value given when calling BASS_RecordStart
	RETURN : TRUE = continue recording, FALSE = stop */

	// BASS_ChannelIsActive return values
#define BASS_ACTIVE_STOPPED	0
#define BASS_ACTIVE_PLAYING	1
#define BASS_ACTIVE_STALLED	2
#define BASS_ACTIVE_PAUSED	3

// Channel attributes
#define BASS_ATTRIB_FREQ			1
#define BASS_ATTRIB_VOL				2
#define BASS_ATTRIB_PAN				3
#define BASS_ATTRIB_EAXMIX			4
#define BASS_ATTRIB_NOBUFFER		5
#define BASS_ATTRIB_VBR				6
#define BASS_ATTRIB_CPU				7
#define BASS_ATTRIB_SRC				8
#define BASS_ATTRIB_NET_RESUME		9
#define BASS_ATTRIB_SCANINFO		10
#define BASS_ATTRIB_NORAMP			11
#define BASS_ATTRIB_BITRATE			12
#define BASS_ATTRIB_MUSIC_AMPLIFY	0x100
#define BASS_ATTRIB_MUSIC_PANSEP	0x101
#define BASS_ATTRIB_MUSIC_PSCALER	0x102
#define BASS_ATTRIB_MUSIC_BPM		0x103
#define BASS_ATTRIB_MUSIC_SPEED		0x104
#define BASS_ATTRIB_MUSIC_VOL_GLOBAL 0x105
#define BASS_ATTRIB_MUSIC_ACTIVE	0x106
#define BASS_ATTRIB_MUSIC_VOL_CHAN	0x200 // + channel #
#define BASS_ATTRIB_MUSIC_VOL_INST	0x300 // + instrument #

// BASS_ChannelGetData flags
#define BASS_DATA_AVAILABLE	0			// query how much data is buffered
#define BASS_DATA_FIXED		0x20000000	// flag: return 8.24 fixed-point data
#define BASS_DATA_FLOAT		0x40000000	// flag: return floating-point sample data
#define BASS_DATA_FFT256	0x80000000	// 256 sample FFT
#define BASS_DATA_FFT512	0x80000001	// 512 FFT
#define BASS_DATA_FFT1024	0x80000002	// 1024 FFT
#define BASS_DATA_FFT2048	0x80000003	// 2048 FFT
#define BASS_DATA_FFT4096	0x80000004	// 4096 FFT
#define BASS_DATA_FFT8192	0x80000005	// 8192 FFT
#define BASS_DATA_FFT16384	0x80000006	// 16384 FFT
#define BASS_DATA_FFT32768	0x80000007	// 32768 FFT
#define BASS_DATA_FFT_INDIVIDUAL 0x10	// FFT flag: FFT for each channel, else all combined
#define BASS_DATA_FFT_NOWINDOW	0x20	// FFT flag: no Hanning window
#define BASS_DATA_FFT_REMOVEDC	0x40	// FFT flag: pre-remove DC bias
#define BASS_DATA_FFT_COMPLEX	0x80	// FFT flag: return complex data

// BASS_ChannelGetLevelEx flags
#define BASS_LEVEL_MONO		1
#define BASS_LEVEL_STEREO	2
#define BASS_LEVEL_RMS		4

// BASS_ChannelGetTags types : what's returned
#define BASS_TAG_ID3		0	// ID3v1 tags : TAG_ID3 structure
#define BASS_TAG_ID3V2		1	// ID3v2 tags : variable length block
#define BASS_TAG_OGG		2	// OGG comments : series of null-terminated UTF-8 strings
#define BASS_TAG_HTTP		3	// HTTP headers : series of null-terminated ANSI strings
#define BASS_TAG_ICY		4	// ICY headers : series of null-terminated ANSI strings
#define BASS_TAG_META		5	// ICY metadata : ANSI string
#define BASS_TAG_APE		6	// APE tags : series of null-terminated UTF-8 strings
#define BASS_TAG_MP4 		7	// MP4/iTunes metadata : series of null-terminated UTF-8 strings
#define BASS_TAG_WMA		8	// WMA tags : series of null-terminated UTF-8 strings
#define BASS_TAG_VENDOR		9	// OGG encoder : UTF-8 string
#define BASS_TAG_LYRICS3	10	// Lyric3v2 tag : ASCII string
#define BASS_TAG_CA_CODEC	11	// CoreAudio codec info : TAG_CA_CODEC structure
#define BASS_TAG_MF			13	// Media Foundation tags : series of null-terminated UTF-8 strings
#define BASS_TAG_WAVEFORMAT	14	// WAVE format : WAVEFORMATEEX structure
#define BASS_TAG_RIFF_INFO	0x100 // RIFF "INFO" tags : series of null-terminated ANSI strings
#define BASS_TAG_RIFF_BEXT	0x101 // RIFF/BWF "bext" tags : TAG_BEXT structure
#define BASS_TAG_RIFF_CART	0x102 // RIFF/BWF "cart" tags : TAG_CART structure
#define BASS_TAG_RIFF_DISP	0x103 // RIFF "DISP" text tag : ANSI string
#define BASS_TAG_APE_BINARY	0x1000	// + index #, binary APE tag : TAG_APE_BINARY structure
#define BASS_TAG_MUSIC_NAME		0x10000	// MOD music name : ANSI string
#define BASS_TAG_MUSIC_MESSAGE	0x10001	// MOD message : ANSI string
#define BASS_TAG_MUSIC_ORDERS	0x10002	// MOD order list : BYTE array of pattern numbers
#define BASS_TAG_MUSIC_AUTH		0x10003	// MOD author : UTF-8 string
#define BASS_TAG_MUSIC_INST		0x10100	// + instrument #, MOD instrument name : ANSI string
#define BASS_TAG_MUSIC_SAMPLE	0x10300	// + sample #, MOD sample name : ANSI string

// ID3v1 tag structure
	typedef struct {
		char id[3];
		char title[30];
		char artist[30];
		char album[30];
		char year[4];
		char comment[30];
		BYTE genre;
	} TAG_ID3;

	// Binary APE tag structure
	typedef struct {
		const char *key;
		const void *data;
		DWORD length;
	} TAG_APE_BINARY;

	// BWF "bext" tag structure
#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable:4200)
#endif
#pragma pack(push,1)
	typedef struct {
		char Description[256];			// description
		char Originator[32];			// name of the originator
		char OriginatorReference[32];	// reference of the originator
		char OriginationDate[10];		// date of creation (yyyy-mm-dd)
		char OriginationTime[8];		// time of creation (hh-mm-ss)
		QWORD TimeReference;			// first sample count since midnight (little-endian)
		WORD Version;					// BWF version (little-endian)
		BYTE UMID[64];					// SMPTE UMID
		BYTE Reserved[190];
#if defined(__GNUC__) && __GNUC__<3
		char CodingHistory[0];			// history
#elif 1 // change to 0 if compiler fails the following line
		char CodingHistory[];			// history
#else
		char CodingHistory[1];			// history
#endif
	} TAG_BEXT;
#pragma pack(pop)

	// BWF "cart" tag structures
	typedef struct
	{
		DWORD dwUsage;					// FOURCC timer usage ID
		DWORD dwValue;					// timer value in samples from head
	} TAG_CART_TIMER;

	typedef struct
	{
		char Version[4];				// version of the data structure
		char Title[64];					// title of cart audio sequence
		char Artist[64];				// artist or creator name
		char CutID[64];					// cut number identification
		char ClientID[64];				// client identification
		char Category[64];				// category ID, PSA, NEWS, etc
		char Classification[64];		// classification or auxiliary key
		char OutCue[64];				// out cue text
		char StartDate[10];				// yyyy-mm-dd
		char StartTime[8];				// hh:mm:ss
		char EndDate[10];				// yyyy-mm-dd
		char EndTime[8];				// hh:mm:ss
		char ProducerAppID[64];			// name of vendor or application
		char ProducerAppVersion[64];	// version of producer application
		char UserDef[64];				// user defined text
		DWORD dwLevelReference;			// sample value for 0 dB reference
		TAG_CART_TIMER PostTimer[8];	// 8 time markers after head
		char Reserved[276];
		char URL[1024];					// uniform resource locator
#if defined(__GNUC__) && __GNUC__<3
		char TagText[0];				// free form text for scripts or tags
#elif 1 // change to 0 if compiler fails the following line
		char TagText[];					// free form text for scripts or tags
#else
		char TagText[1];				// free form text for scripts or tags
#endif
	} TAG_CART;
#ifdef _MSC_VER
#pragma warning(pop)
#endif

	// CoreAudio codec info structure
	typedef struct {
		DWORD ftype;					// file format
		DWORD atype;					// audio format
		const char *name;				// description
	} TAG_CA_CODEC;

#ifndef _WAVEFORMATEX_
#define _WAVEFORMATEX_
#pragma pack(push,1)
	typedef struct tWAVEFORMATEX
	{
		WORD wFormatTag;
		WORD nChannels;
		DWORD nSamplesPerSec;
		DWORD nAvgBytesPerSec;
		WORD nBlockAlign;
		WORD wBitsPerSample;
		WORD cbSize;
	} WAVEFORMATEX, *PWAVEFORMATEX, *LPWAVEFORMATEX;
	typedef const WAVEFORMATEX *LPCWAVEFORMATEX;
#pragma pack(pop)
#endif

	// BASS_ChannelGetLength/GetPosition/SetPosition modes
#define BASS_POS_BYTE			0		// byte position
#define BASS_POS_MUSIC_ORDER	1		// order.row position, MAKELONG(order,row)
#define BASS_POS_OGG			3		// OGG bitstream number
#define BASS_POS_INEXACT		0x8000000 // flag: allow seeking to inexact position
#define BASS_POS_DECODE			0x10000000 // flag: get the decoding (not playing) position
#define BASS_POS_DECODETO		0x20000000 // flag: decode to the position instead of seeking
#define BASS_POS_SCAN			0x40000000 // flag: scan to the position

// BASS_RecordSetInput flags
#define BASS_INPUT_OFF		0x10000
#define BASS_INPUT_ON		0x20000

#define BASS_INPUT_TYPE_MASK		0xff000000
#define BASS_INPUT_TYPE_UNDEF		0x00000000
#define BASS_INPUT_TYPE_DIGITAL		0x01000000
#define BASS_INPUT_TYPE_LINE		0x02000000
#define BASS_INPUT_TYPE_MIC			0x03000000
#define BASS_INPUT_TYPE_SYNTH		0x04000000
#define BASS_INPUT_TYPE_CD			0x05000000
#define BASS_INPUT_TYPE_PHONE		0x06000000
#define BASS_INPUT_TYPE_SPEAKER		0x07000000
#define BASS_INPUT_TYPE_WAVE		0x08000000
#define BASS_INPUT_TYPE_AUX			0x09000000
#define BASS_INPUT_TYPE_ANALOG		0x0a000000

// DX8 effect types, use with BASS_ChannelSetFX
	enum
	{
		BASS_FX_DX8_CHORUS,
		BASS_FX_DX8_COMPRESSOR,
		BASS_FX_DX8_DISTORTION,
		BASS_FX_DX8_ECHO,
		BASS_FX_DX8_FLANGER,
		BASS_FX_DX8_GARGLE,
		BASS_FX_DX8_I3DL2REVERB,
		BASS_FX_DX8_PARAMEQ,
		BASS_FX_DX8_REVERB
	};

	typedef struct {
		float       fWetDryMix;
		float       fDepth;
		float       fFeedback;
		float       fFrequency;
		DWORD       lWaveform;	// 0=triangle, 1=sine
		float       fDelay;
		DWORD       lPhase;		// BASS_DX8_PHASE_xxx
	} BASS_DX8_CHORUS;

	typedef struct {
		float   fGain;
		float   fAttack;
		float   fRelease;
		float   fThreshold;
		float   fRatio;
		float   fPredelay;
	} BASS_DX8_COMPRESSOR;

	typedef struct {
		float   fGain;
		float   fEdge;
		float   fPostEQCenterFrequency;
		float   fPostEQBandwidth;
		float   fPreLowpassCutoff;
	} BASS_DX8_DISTORTION;

	typedef struct {
		float   fWetDryMix;
		float   fFeedback;
		float   fLeftDelay;
		float   fRightDelay;
		BOOL    lPanDelay;
	} BASS_DX8_ECHO;

	typedef struct {
		float       fWetDryMix;
		float       fDepth;
		float       fFeedback;
		float       fFrequency;
		DWORD       lWaveform;	// 0=triangle, 1=sine
		float       fDelay;
		DWORD       lPhase;		// BASS_DX8_PHASE_xxx
	} BASS_DX8_FLANGER;

	typedef struct {
		DWORD       dwRateHz;               // Rate of modulation in hz
		DWORD       dwWaveShape;            // 0=triangle, 1=square
	} BASS_DX8_GARGLE;

	typedef struct {
		int     lRoom;                  // [-10000, 0]      default: -1000 mB
		int     lRoomHF;                // [-10000, 0]      default: 0 mB
		float   flRoomRolloffFactor;    // [0.0, 10.0]      default: 0.0
		float   flDecayTime;            // [0.1, 20.0]      default: 1.49s
		float   flDecayHFRatio;         // [0.1, 2.0]       default: 0.83
		int     lReflections;           // [-10000, 1000]   default: -2602 mB
		float   flReflectionsDelay;     // [0.0, 0.3]       default: 0.007 s
		int     lReverb;                // [-10000, 2000]   default: 200 mB
		float   flReverbDelay;          // [0.0, 0.1]       default: 0.011 s
		float   flDiffusion;            // [0.0, 100.0]     default: 100.0 %
		float   flDensity;              // [0.0, 100.0]     default: 100.0 %
		float   flHFReference;          // [20.0, 20000.0]  default: 5000.0 Hz
	} BASS_DX8_I3DL2REVERB;

	typedef struct {
		float   fCenter;
		float   fBandwidth;
		float   fGain;
	} BASS_DX8_PARAMEQ;

	typedef struct {
		float   fInGain;                // [-96.0,0.0]            default: 0.0 dB
		float   fReverbMix;             // [-96.0,0.0]            default: 0.0 db
		float   fReverbTime;            // [0.001,3000.0]         default: 1000.0 ms
		float   fHighFreqRTRatio;       // [0.001,0.999]          default: 0.001
	} BASS_DX8_REVERB;

#define BASS_DX8_PHASE_NEG_180        0
#define BASS_DX8_PHASE_NEG_90         1
#define BASS_DX8_PHASE_ZERO           2
#define BASS_DX8_PHASE_90             3
#define BASS_DX8_PHASE_180            4

	typedef void (CALLBACK IOSNOTIFYPROC)(DWORD status);
	/* iOS notification callback function.
	status : The notification (BASS_IOSNOTIFY_xxx) */

#define BASS_IOSNOTIFY_INTERRUPT		1	// interruption started
#define BASS_IOSNOTIFY_INTERRUPT_END	2	// interruption ended

	inline BOOL BASS_SetConfig(DWORD option, DWORD value)
	{
		return reinterpret_cast<BOOL(__stdcall*)(DWORD, DWORD)>(BASS::bass_lib.GetProcAddressFromMemory(BASS::bass_lib_handle, ("BASS_SetConfig")))(option, value);
	}

	inline DWORD BASS_GetConfig(DWORD option)
	{
		return reinterpret_cast<DWORD(__stdcall*)(DWORD)>(BASS::bass_lib.GetProcAddressFromMemory(BASS::bass_lib_handle, ("BASS_GetConfig")))(option);
	}

	BOOL BASSDEF(BASS_SetConfigPtr)(DWORD option, const void *value);
	void *BASSDEF(BASS_GetConfigPtr)(DWORD option);
	inline DWORD BASS_GetVersion()
	{
		return reinterpret_cast<DWORD(__stdcall*)()>(BASS::bass_lib.GetProcAddressFromMemory(BASS::bass_lib_handle, ("BASS_GetVersion")))();
	}

	inline int BASS_ErrorGetCode()
	{
		return reinterpret_cast<int(__stdcall*)()>(BASS::bass_lib.GetProcAddressFromMemory(BASS::bass_lib_handle, ("BASS_ErrorGetCode")))();
	}
	//int BASSDEF(BASS_ErrorGetCode)();
	BOOL BASSDEF(BASS_GetDeviceInfo)(DWORD device, BASS_DEVICEINFO *info);
#if defined(_WIN32) && !defined(_WIN32_WCE) && !(WINAPI_FAMILY && WINAPI_FAMILY!=WINAPI_FAMILY_DESKTOP_APP)
	inline BOOL BASS_Init(int device, DWORD freq, DWORD flags, HWND win, const GUID *dsguid)
	{
		return reinterpret_cast<BOOL(__stdcall*)(int device, DWORD freq, DWORD flags, HWND win, const GUID *dsguid)>(BASS::bass_lib.GetProcAddressFromMemory(BASS::bass_lib_handle, ("BASS_Init")))(device, freq, flags, win, dsguid);
	}

#else
	BOOL BASSDEF(BASS_Init)(int device, DWORD freq, DWORD flags, void *win, void *dsguid);
#endif
	BOOL BASSDEF(BASS_SetDevice)(DWORD device);
	DWORD BASSDEF(BASS_GetDevice)();
	inline BOOL BASS_Free()
	{
		return reinterpret_cast<BOOL(__stdcall*)()>(BASS::bass_lib.GetProcAddressFromMemory(BASS::bass_lib_handle, ("BASS_Free")))();
	}
#if defined(_WIN32) && !defined(_WIN32_WCE) && !(WINAPI_FAMILY && WINAPI_FAMILY!=WINAPI_FAMILY_DESKTOP_APP)
	void *BASSDEF(BASS_GetDSoundObject)(DWORD object);
#endif
	BOOL BASSDEF(BASS_GetInfo)(BASS_INFO *info);
	BOOL BASSDEF(BASS_Update)(DWORD length);
	float BASSDEF(BASS_GetCPU)();
	inline BOOL BASS_Start()
	{
		return reinterpret_cast<BOOL(__stdcall*)()>(BASS::bass_lib.GetProcAddressFromMemory(BASS::bass_lib_handle, ("BASS_Start")))();
	}
	inline BOOL BASS_Stop()
	{
		return reinterpret_cast<BOOL(__stdcall*)()>(BASS::bass_lib.GetProcAddressFromMemory(BASS::bass_lib_handle, ("BASS_Stop")))();
	}
	inline BOOL BASS_Pause()
	{
		return reinterpret_cast<BOOL(__stdcall*)()>(BASS::bass_lib.GetProcAddressFromMemory(BASS::bass_lib_handle, ("BASS_Pause")))();
	}
	inline BOOL BASS_SetVolume(float volume)
	{
		return reinterpret_cast<BOOL(__stdcall*)(float volume)>(BASS::bass_lib.GetProcAddressFromMemory(BASS::bass_lib_handle, ("BASS_SetVolume")))(volume);
	}
	inline float BASS_GetVolume()
	{
		return reinterpret_cast<float(__stdcall*)()>(BASS::bass_lib.GetProcAddressFromMemory(BASS::bass_lib_handle, ("BASS_GetVolume")))();
	}

	HPLUGIN BASSDEF(BASS_PluginLoad)(const char *file, DWORD flags);
	BOOL BASSDEF(BASS_PluginFree)(HPLUGIN handle);
	const BASS_PLUGININFO *BASSDEF(BASS_PluginGetInfo)(HPLUGIN handle);

	BOOL BASSDEF(BASS_Set3DFactors)(float distf, float rollf, float doppf);
	BOOL BASSDEF(BASS_Get3DFactors)(float *distf, float *rollf, float *doppf);
	BOOL BASSDEF(BASS_Set3DPosition)(const BASS_3DVECTOR *pos, const BASS_3DVECTOR *vel, const BASS_3DVECTOR *front, const BASS_3DVECTOR *top);
	BOOL BASSDEF(BASS_Get3DPosition)(BASS_3DVECTOR *pos, BASS_3DVECTOR *vel, BASS_3DVECTOR *front, BASS_3DVECTOR *top);
	void BASSDEF(BASS_Apply3D)();
#if defined(_WIN32) && !defined(_WIN32_WCE) && !(WINAPI_FAMILY && WINAPI_FAMILY!=WINAPI_FAMILY_DESKTOP_APP)
	BOOL BASSDEF(BASS_SetEAXParameters)(int env, float vol, float decay, float damp);
	BOOL BASSDEF(BASS_GetEAXParameters)(DWORD *env, float *vol, float *decay, float *damp);
#endif

	HMUSIC BASSDEF(BASS_MusicLoad)(BOOL mem, const void *file, QWORD offset, DWORD length, DWORD flags, DWORD freq);
	BOOL BASSDEF(BASS_MusicFree)(HMUSIC handle);

	inline HSAMPLE BASS_SampleLoad(BOOL mem, const void* file, QWORD offset, DWORD length, DWORD max, DWORD flags)
	{
		return reinterpret_cast<HSAMPLE(__stdcall*)(BOOL mem, const void* file, QWORD offset, DWORD length, DWORD max, DWORD flags)>(BASS::bass_lib.GetProcAddressFromMemory(BASS::bass_lib_handle, ("BASS_SampleLoad")))(mem, file, offset, length, max, flags);
	}

	inline BOOL BASS_SampleGetInfo(HSAMPLE handle, BASS_SAMPLE* info)
	{
		return reinterpret_cast<BOOL(__stdcall*)(HSAMPLE handle, BASS_SAMPLE * info)>(BASS::bass_lib.GetProcAddressFromMemory(BASS::bass_lib_handle, ("BASS_SampleGetInfo")))(handle, info);
	}

	inline BOOL BASS_SampleSetInfo(HSAMPLE handle, const BASS_SAMPLE* info)
	{
		return reinterpret_cast<BOOL(__stdcall*)(HSAMPLE handle, const BASS_SAMPLE * info)>(BASS::bass_lib.GetProcAddressFromMemory(BASS::bass_lib_handle, ("BASS_SampleSetInfo")))(handle, info);
	}

	inline HCHANNEL BASS_SampleGetChannel(HSAMPLE handle, BOOL onlynew)
	{
		return reinterpret_cast<HCHANNEL(__stdcall*)(HSAMPLE handle, BOOL onlynew)>(BASS::bass_lib.GetProcAddressFromMemory(BASS::bass_lib_handle, ("BASS_SampleGetChannel")))(handle, onlynew);
	}

	inline BOOL BASS_SampleFree(HSAMPLE handle)
	{
		return reinterpret_cast<BOOL(__stdcall*)(HSAMPLE handle)>(BASS::bass_lib.GetProcAddressFromMemory(BASS::bass_lib_handle, ("BASS_SampleFree")))(handle);
	}

	//HSAMPLE BASSDEF(BASS_SampleLoad)(BOOL mem, const void *file, QWORD offset, DWORD length, DWORD max, DWORD flags);
	HSAMPLE BASSDEF(BASS_SampleCreate)(DWORD length, DWORD freq, DWORD chans, DWORD max, DWORD flags);
	//BOOL BASSDEF(BASS_SampleFree)(HSAMPLE handle);
	BOOL BASSDEF(BASS_SampleSetData)(HSAMPLE handle, const void *buffer);
	BOOL BASSDEF(BASS_SampleGetData)(HSAMPLE handle, void *buffer);
	//BOOL BASSDEF(BASS_SampleGetInfo)(HSAMPLE handle, BASS_SAMPLE *info);
	//BOOL BASSDEF(BASS_SampleSetInfo)(HSAMPLE handle, const BASS_SAMPLE *info);
	//HCHANNEL BASSDEF(BASS_SampleGetChannel)(HSAMPLE handle, BOOL onlynew);
	DWORD BASSDEF(BASS_SampleGetChannels)(HSAMPLE handle, HCHANNEL *channels);
	BOOL BASSDEF(BASS_SampleStop)(HSAMPLE handle);

	HSTREAM BASSDEF(BASS_StreamCreate)(DWORD freq, DWORD chans, DWORD flags, STREAMPROC *proc, void *user);
	inline HSTREAM BASS_StreamCreateFile(BOOL mem, const void *file, QWORD offset, QWORD length, DWORD flags)
	{
		return reinterpret_cast<HSTREAM(__stdcall*)(BOOL mem, const void *file, QWORD offset, QWORD length, DWORD flags)>(BASS::bass_lib.GetProcAddressFromMemory(BASS::bass_lib_handle, ("BASS_StreamCreateFile")))(mem, file, offset, length, flags);
	}

	inline HSTREAM BASS_StreamCreateURL(const char *url, DWORD offset, DWORD flags, DOWNLOADPROC *proc, void *user)
	{
		return reinterpret_cast<HSTREAM(__stdcall*)(const char *url, DWORD offset, DWORD flags, DOWNLOADPROC *proc, void *user)>(BASS::bass_lib.GetProcAddressFromMemory(BASS::bass_lib_handle, ("BASS_StreamCreateURL")))(url, offset, flags, proc, user);
	}

	HSTREAM BASSDEF(BASS_StreamCreateFileUser)(DWORD system, DWORD flags, const BASS_FILEPROCS *proc, void *user);
	inline BOOL BASS_StreamFree(HSTREAM handle)
	{
		return reinterpret_cast<BOOL(__stdcall*)(HSTREAM handle)>(BASS::bass_lib.GetProcAddressFromMemory(BASS::bass_lib_handle, ("BASS_StreamFree")))(handle);
	}

	inline QWORD BASS_StreamGetFilePosition(HSTREAM handle, DWORD mode)
	{
		return reinterpret_cast<QWORD(__stdcall*)(HSTREAM handle, DWORD mode)>(BASS::bass_lib.GetProcAddressFromMemory(BASS::bass_lib_handle, ("BASS_StreamGetFilePosition")))(handle, mode);
	}

	DWORD BASSDEF(BASS_StreamPutData)(HSTREAM handle, const void *buffer, DWORD length);
	DWORD BASSDEF(BASS_StreamPutFileData)(HSTREAM handle, const void *buffer, DWORD length);

	BOOL BASSDEF(BASS_RecordGetDeviceInfo)(DWORD device, BASS_DEVICEINFO *info);
	BOOL BASSDEF(BASS_RecordInit)(int device);
	BOOL BASSDEF(BASS_RecordSetDevice)(DWORD device);
	DWORD BASSDEF(BASS_RecordGetDevice)();
	BOOL BASSDEF(BASS_RecordFree)();
	BOOL BASSDEF(BASS_RecordGetInfo)(BASS_RECORDINFO *info);
	const char *BASSDEF(BASS_RecordGetInputName)(int input);
	BOOL BASSDEF(BASS_RecordSetInput)(int input, DWORD flags, float volume);
	DWORD BASSDEF(BASS_RecordGetInput)(int input, float *volume);
	HRECORD BASSDEF(BASS_RecordStart)(DWORD freq, DWORD chans, DWORD flags, RECORDPROC *proc, void *user);

	double BASSDEF(BASS_ChannelBytes2Seconds)(DWORD handle, QWORD pos);
	QWORD BASSDEF(BASS_ChannelSeconds2Bytes)(DWORD handle, double pos);
	DWORD BASSDEF(BASS_ChannelGetDevice)(DWORD handle);
	BOOL BASSDEF(BASS_ChannelSetDevice)(DWORD handle, DWORD device);
	DWORD BASSDEF(BASS_ChannelIsActive)(DWORD handle);
	BOOL BASSDEF(BASS_ChannelGetInfo)(DWORD handle, BASS_CHANNELINFO *info);
	inline const char * BASS_ChannelGetTags(DWORD handle, DWORD tags)
	{
		return reinterpret_cast<const char *(__stdcall*)(DWORD handle, DWORD tags)>(BASS::bass_lib.GetProcAddressFromMemory(BASS::bass_lib_handle, ("BASS_ChannelGetTags")))(handle, tags);
	}

	DWORD BASSDEF(BASS_ChannelFlags)(DWORD handle, DWORD flags, DWORD mask);
	BOOL BASSDEF(BASS_ChannelUpdate)(DWORD handle, DWORD length);
	BOOL BASSDEF(BASS_ChannelLock)(DWORD handle, BOOL lock);
	inline BOOL BASS_ChannelPlay(DWORD handle, BOOL restart)
	{
		return reinterpret_cast<BOOL(__stdcall*)(DWORD handle, BOOL restart)>(BASS::bass_lib.GetProcAddressFromMemory(BASS::bass_lib_handle, ("BASS_ChannelPlay")))(handle, restart);
	}
	inline BOOL BASS_ChannelStop(DWORD handle)
	{
		return reinterpret_cast<BOOL(__stdcall*)(DWORD handle)>(BASS::bass_lib.GetProcAddressFromMemory(BASS::bass_lib_handle, ("BASS_ChannelStop")))(handle);
	}
	BOOL BASSDEF(BASS_ChannelPause)(DWORD handle);
	inline BOOL BASS_ChannelSetAttribute(DWORD handle, DWORD attrib, float value)
	{
		return reinterpret_cast<BOOL(__stdcall*)(DWORD handle, DWORD attrib, float value)>(BASS::bass_lib.GetProcAddressFromMemory(BASS::bass_lib_handle, ("BASS_ChannelSetAttribute")))(handle, attrib, value);
	}
	BOOL BASSDEF(BASS_ChannelGetAttribute)(DWORD handle, DWORD attrib, float *value);
	BOOL BASSDEF(BASS_ChannelSlideAttribute)(DWORD handle, DWORD attrib, float value, DWORD time);
	BOOL BASSDEF(BASS_ChannelIsSliding)(DWORD handle, DWORD attrib);
	BOOL BASSDEF(BASS_ChannelSetAttributeEx)(DWORD handle, DWORD attrib, void *value, DWORD size);
	DWORD BASSDEF(BASS_ChannelGetAttributeEx)(DWORD handle, DWORD attrib, void *value, DWORD size);
	BOOL BASSDEF(BASS_ChannelSet3DAttributes)(DWORD handle, int mode, float min, float max, int iangle, int oangle, float outvol);
	BOOL BASSDEF(BASS_ChannelGet3DAttributes)(DWORD handle, DWORD *mode, float *min, float *max, DWORD *iangle, DWORD *oangle, float *outvol);
	BOOL BASSDEF(BASS_ChannelSet3DPosition)(DWORD handle, const BASS_3DVECTOR *pos, const BASS_3DVECTOR *orient, const BASS_3DVECTOR *vel);
	BOOL BASSDEF(BASS_ChannelGet3DPosition)(DWORD handle, BASS_3DVECTOR *pos, BASS_3DVECTOR *orient, BASS_3DVECTOR *vel);
	QWORD BASSDEF(BASS_ChannelGetLength)(DWORD handle, DWORD mode);
	BOOL BASSDEF(BASS_ChannelSetPosition)(DWORD handle, QWORD pos, DWORD mode);
	QWORD BASSDEF(BASS_ChannelGetPosition)(DWORD handle, DWORD mode);
	DWORD BASSDEF(BASS_ChannelGetLevel)(DWORD handle);
	BOOL BASSDEF(BASS_ChannelGetLevelEx)(DWORD handle, float *levels, float length, DWORD flags);
	DWORD BASSDEF(BASS_ChannelGetData)(DWORD handle, void *buffer, DWORD length);
	inline HSYNC BASS_ChannelSetSync(DWORD handle, DWORD type, QWORD param, SYNCPROC *proc, void *user)
	{
		return reinterpret_cast<HSYNC(__stdcall*)(DWORD handle, DWORD type, QWORD param, SYNCPROC *proc, void *user)>(BASS::bass_lib.GetProcAddressFromMemory(BASS::bass_lib_handle, ("BASS_ChannelSetSync")))(handle, type, param, proc, user);
	}
	BOOL BASSDEF(BASS_ChannelRemoveSync)(DWORD handle, HSYNC sync);
	HDSP BASSDEF(BASS_ChannelSetDSP)(DWORD handle, DSPPROC *proc, void *user, int priority);
	BOOL BASSDEF(BASS_ChannelRemoveDSP)(DWORD handle, HDSP dsp);
	BOOL BASSDEF(BASS_ChannelSetLink)(DWORD handle, DWORD chan);
	BOOL BASSDEF(BASS_ChannelRemoveLink)(DWORD handle, DWORD chan);
	HFX BASSDEF(BASS_ChannelSetFX)(DWORD handle, DWORD type, int priority);
	BOOL BASSDEF(BASS_ChannelRemoveFX)(DWORD handle, HFX fx);

	BOOL BASSDEF(BASS_FXSetParameters)(HFX handle, const void *params);
	BOOL BASSDEF(BASS_FXGetParameters)(HFX handle, void *params);
	BOOL BASSDEF(BASS_FXReset)(HFX handle);
	BOOL BASSDEF(BASS_FXSetPriority)(HFX handle, int priority);

#ifdef __cplusplus
}

#if defined(_WIN32) && !defined(NOBASSOVERLOADS)
static inline HPLUGIN BASS_PluginLoad(const WCHAR *file, DWORD flags)
{
	return BASS_PluginLoad((const char*) file, flags | BASS_UNICODE);
}

static inline HMUSIC BASS_MusicLoad(BOOL mem, const WCHAR *file, QWORD offset, DWORD length, DWORD flags, DWORD freq)
{
	return BASS_MusicLoad(mem, (const void*) file, offset, length, flags | BASS_UNICODE, freq);
}

//static inline HSAMPLE BASS_SampleLoad(BOOL mem, const WCHAR *file, QWORD offset, DWORD length, DWORD max, DWORD flags)
//{
//	return BASS_SampleLoad(mem, (const void*) file, offset, length, max, flags | BASS_UNICODE);
//}
/*
static inline HSTREAM BASS_StreamCreateFile(BOOL mem, const WCHAR *file, QWORD offset, QWORD length, DWORD flags)
{
	return BASS_StreamCreateFile(mem, (const void*)file, offset, length, flags|BASS_UNICODE);
}
*/
static inline HSTREAM BASS_StreamCreateURL(const WCHAR *url, DWORD offset, DWORD flags, DOWNLOADPROC *proc, void *user)
{
	return BASS_StreamCreateURL((const char*) url, offset, flags | BASS_UNICODE, proc, user);
}

static inline BOOL BASS_SetConfigPtr(DWORD option, const WCHAR *value)
{
	return BASS_SetConfigPtr(option | BASS_UNICODE, (const void*) value);
}
#endif
#endif

#endif

```

`sakura/libs/bass/dll.cpp`:

```cpp
//#define _CRT_SECURE_NO_WARNINGS

#include <windows.h>
#include <winnt.h>
#include <stddef.h>
#include <stdint.h>
#include <tchar.h>
#include <iostream>
#include <fstream>

#ifdef DEBUG_OUTPUT
#include <stdio.h>
#endif

#if _MSC_VER
// Disable warning about data -> function pointer conversion
#pragma warning(disable:4055)
#endif

#define IMAGE_SIZEOF_BASE_RELOCATION (sizeof(IMAGE_BASE_RELOCATION))

#include "dll.h"

#define GET_HEADER_DICTIONARY(module, idx)  &(module)->headers->OptionalHeader.DataDirectory[idx]
#define ALIGN_DOWN(address, alignment)      (LPVOID)((uintptr_t)(address) & ~((alignment) - 1))
#define ALIGN_VALUE_UP(value, alignment)    (((value) + (alignment) - 1) & ~((alignment) - 1))

BOOL
CWin32PE::CheckSize(size_t size, size_t expected) {
	if (size < expected) {
		SetLastError(ERROR_INVALID_DATA);
		return FALSE;
	}

	return TRUE;
}

BOOL CWin32PE::CopySections(const unsigned char *data, size_t size, PIMAGE_NT_HEADERS old_headers, PMEMORYMODULE module)
{
	int i, section_size;
	unsigned char *codeBase = module->codeBase;
	unsigned char *dest;
	PIMAGE_SECTION_HEADER section = IMAGE_FIRST_SECTION(module->headers);
	for (i = 0; i < module->headers->FileHeader.NumberOfSections; i++, section++) {
		if (section->SizeOfRawData == 0) {
			// section doesn't contain data in the dll itself, but may define
			// uninitialized data
			section_size = old_headers->OptionalHeader.SectionAlignment;
			if (section_size > 0) {
				dest = (unsigned char *) VirtualAlloc(codeBase + section->VirtualAddress,
													  section_size,
													  MEM_COMMIT,
													  PAGE_READWRITE);
				if (dest == NULL) {
					return FALSE;
				}

				// Always use position from file to support alignments smaller
				// than page size.
				dest = codeBase + section->VirtualAddress;
				section->Misc.PhysicalAddress = (DWORD) (uintptr_t) dest;
				memset(dest, 0, section_size);
			}

			// section is empty
			continue;
		}

		if (!CheckSize(size, section->PointerToRawData + section->SizeOfRawData)) {
			return FALSE;
		}

		// commit memory block and copy data from dll
		dest = (unsigned char *) VirtualAlloc(codeBase + section->VirtualAddress,
											  section->SizeOfRawData,
											  MEM_COMMIT,
											  PAGE_READWRITE);
		if (dest == NULL) {
			return FALSE;
		}

		// Always use position from file to support alignments smaller
		// than page size.
		dest = codeBase + section->VirtualAddress;
		memcpy(dest, data + section->PointerToRawData, section->SizeOfRawData);
		section->Misc.PhysicalAddress = (DWORD) (uintptr_t) dest;
	}

	return TRUE;
}

// Protection flags for memory pages (Executable, Readable, Writeable)
static int ProtectionFlags[2][2][2] = {
	{
		// not executable
		{ PAGE_NOACCESS, PAGE_WRITECOPY },
{ PAGE_READONLY, PAGE_READWRITE },
	},{
		// executable
		{ PAGE_EXECUTE, PAGE_EXECUTE_WRITECOPY },
{ PAGE_EXECUTE_READ, PAGE_EXECUTE_READWRITE },
	},
};

DWORD
CWin32PE::GetRealSectionSize(PMEMORYMODULE module, PIMAGE_SECTION_HEADER section) {
	DWORD size = section->SizeOfRawData;
	if (size == 0) {
		if (section->Characteristics & IMAGE_SCN_CNT_INITIALIZED_DATA) {
			size = module->headers->OptionalHeader.SizeOfInitializedData;
		}
		else if (section->Characteristics & IMAGE_SCN_CNT_UNINITIALIZED_DATA) {
			size = module->headers->OptionalHeader.SizeOfUninitializedData;
		}
	}
	return size;
}

BOOL
CWin32PE::FinalizeSection(PMEMORYMODULE module, PSECTIONFINALIZEDATA sectionData) {
	DWORD protect, oldProtect;
	BOOL executable;
	BOOL readable;
	BOOL writeable;

	if (sectionData->size == 0) {
		return TRUE;
	}

	if (sectionData->characteristics & IMAGE_SCN_MEM_DISCARDABLE) {
		// section is not needed any more and can safely be freed
		if (sectionData->address == sectionData->alignedAddress &&
			(sectionData->last ||
			 module->headers->OptionalHeader.SectionAlignment == module->pageSize ||
			 (sectionData->size % module->pageSize) == 0)
			) {
			// Only allowed to decommit whole pages
			VirtualFree(sectionData->address, sectionData->size, MEM_DECOMMIT);
		}
		return TRUE;
	}

	// determine protection flags based on characteristics
	executable = (sectionData->characteristics & IMAGE_SCN_MEM_EXECUTE) != 0;
	readable = (sectionData->characteristics & IMAGE_SCN_MEM_READ) != 0;
	writeable = (sectionData->characteristics & IMAGE_SCN_MEM_WRITE) != 0;
	protect = ProtectionFlags[executable][readable][writeable];
	if (sectionData->characteristics & IMAGE_SCN_MEM_NOT_CACHED) {
		protect |= PAGE_NOCACHE;
	}

	// change memory access flags
	if (VirtualProtect(sectionData->address, sectionData->size, protect, &oldProtect) == 0) {
#ifdef DEBUG_OUTPUT
		OutputLastError("Error protecting memory page")
#endif
			return FALSE;
	}

	return TRUE;
}

BOOL
CWin32PE::FinalizeSections(PMEMORYMODULE module)
{
	int i;
	PIMAGE_SECTION_HEADER section = IMAGE_FIRST_SECTION(module->headers);
#ifdef _WIN64
	uintptr_t imageOffset = (module->headers->OptionalHeader.ImageBase & 0xffffffff00000000);
#else
#define imageOffset 0
#endif
	SECTIONFINALIZEDATA sectionData;
	sectionData.address = (LPVOID) ((uintptr_t) section->Misc.PhysicalAddress | imageOffset);
	sectionData.alignedAddress = ALIGN_DOWN(sectionData.address, module->pageSize);
	sectionData.size = GetRealSectionSize(module, section);
	sectionData.characteristics = section->Characteristics;
	sectionData.last = FALSE;
	section++;

	// loop through all sections and change access flags
	for (i = 1; i < module->headers->FileHeader.NumberOfSections; i++, section++) {
		LPVOID sectionAddress = (LPVOID) ((uintptr_t) section->Misc.PhysicalAddress | imageOffset);
		LPVOID alignedAddress = ALIGN_DOWN(sectionAddress, module->pageSize);
		DWORD sectionSize = GetRealSectionSize(module, section);
		// Combine access flags of all sections that share a page
		// TODO(fancycode): We currently share flags of a trailing large section
		//   with the page of a first small section. This should be optimized.
		if (sectionData.alignedAddress == alignedAddress || (uintptr_t) sectionData.address + sectionData.size > (uintptr_t) alignedAddress) {
			// Section shares page with previous
			if ((section->Characteristics & IMAGE_SCN_MEM_DISCARDABLE) == 0 || (sectionData.characteristics & IMAGE_SCN_MEM_DISCARDABLE) == 0) {
				sectionData.characteristics = (sectionData.characteristics | section->Characteristics) & ~IMAGE_SCN_MEM_DISCARDABLE;
			}
			else {
				sectionData.characteristics |= section->Characteristics;
			}
			sectionData.size = (((uintptr_t) sectionAddress) + sectionSize) - (uintptr_t) sectionData.address;
			continue;
		}

		if (!FinalizeSection(module, &sectionData)) {
			return FALSE;
		}
		sectionData.address = sectionAddress;
		sectionData.alignedAddress = alignedAddress;
		sectionData.size = sectionSize;
		sectionData.characteristics = section->Characteristics;
	}
	sectionData.last = TRUE;
	if (!FinalizeSection(module, &sectionData)) {
		return FALSE;
	}
#ifndef _WIN64
#undef imageOffset
#endif
	return TRUE;
}

BOOL
CWin32PE::ExecuteTLS(PMEMORYMODULE module)
{
	unsigned char *codeBase = module->codeBase;
	PIMAGE_TLS_DIRECTORY tls;
	PIMAGE_TLS_CALLBACK* callback;

	PIMAGE_DATA_DIRECTORY directory = GET_HEADER_DICTIONARY(module, IMAGE_DIRECTORY_ENTRY_TLS);
	if (directory->VirtualAddress == 0) {
		return TRUE;
	}

	tls = (PIMAGE_TLS_DIRECTORY) (codeBase + directory->VirtualAddress);
	callback = (PIMAGE_TLS_CALLBACK *) tls->AddressOfCallBacks;
	if (callback) {
		while (*callback) {
			(*callback)((LPVOID) codeBase, DLL_PROCESS_ATTACH, NULL);
			callback++;
		}
	}
	return TRUE;
}

BOOL
CWin32PE::PerformBaseRelocation(PMEMORYMODULE module, ptrdiff_t delta)
{
	unsigned char *codeBase = module->codeBase;
	PIMAGE_BASE_RELOCATION relocation;

	PIMAGE_DATA_DIRECTORY directory = GET_HEADER_DICTIONARY(module, IMAGE_DIRECTORY_ENTRY_BASERELOC);
	if (directory->Size == 0) {
		return (delta == 0);
	}

	relocation = (PIMAGE_BASE_RELOCATION) (codeBase + directory->VirtualAddress);
	for (; relocation->VirtualAddress > 0;) {
		DWORD i;
		unsigned char *dest = codeBase + relocation->VirtualAddress;
		unsigned short *relInfo = (unsigned short *) ((unsigned char *) relocation + IMAGE_SIZEOF_BASE_RELOCATION);
		for (i = 0; i < ((relocation->SizeOfBlock - IMAGE_SIZEOF_BASE_RELOCATION) / 2); i++, relInfo++) {
			DWORD *patchAddrHL;
#ifdef _WIN64
			ULONGLONG *patchAddr64;
#endif
			int type, offset;

			// the upper 4 bits define the type of relocation
			type = *relInfo >> 12;
			// the lower 12 bits define the offset
			offset = *relInfo & 0xfff;

			switch (type)
			{
			case IMAGE_REL_BASED_ABSOLUTE:
				// skip relocation
				break;

			case IMAGE_REL_BASED_HIGHLOW:
				// change complete 32 bit address
				patchAddrHL = (DWORD *) (dest + offset);
				*patchAddrHL += (DWORD) delta;
				break;

#ifdef _WIN64
			case IMAGE_REL_BASED_DIR64:
				patchAddr64 = (ULONGLONG *) (dest + offset);
				*patchAddr64 += (ULONGLONG) delta;
				break;
#endif

			default:
				//printf("Unknown relocation: %d\n", type);
				break;
			}
		}

		// advance to next relocation block
		relocation = (PIMAGE_BASE_RELOCATION) (((char *) relocation) + relocation->SizeOfBlock);
	}
	return TRUE;
}

BOOL
CWin32PE::BuildImportTable(PMEMORYMODULE module)
{
	unsigned char *codeBase = module->codeBase;
	PIMAGE_IMPORT_DESCRIPTOR importDesc;
	BOOL result = TRUE;

	PIMAGE_DATA_DIRECTORY directory = GET_HEADER_DICTIONARY(module, IMAGE_DIRECTORY_ENTRY_IMPORT);
	if (directory->Size == 0) {
		return TRUE;
	}

	importDesc = (PIMAGE_IMPORT_DESCRIPTOR) (codeBase + directory->VirtualAddress);
	for (; !IsBadReadPtr(importDesc, sizeof(IMAGE_IMPORT_DESCRIPTOR)) && importDesc->Name; importDesc++) {
		uintptr_t *thunkRef;
		FARPROC *funcRef;
		HCUSTOMMODULE *tmp;
		HCUSTOMMODULE handle = module->loadLibrary((LPCSTR) (codeBase + importDesc->Name), module->userdata);
		if (handle == NULL) {
			SetLastError(ERROR_MOD_NOT_FOUND);
			result = FALSE;
			break;
		}

		tmp = (HCUSTOMMODULE *) realloc(module->modules, (module->numModules + 1)*(sizeof(HCUSTOMMODULE)));
		if (tmp == NULL) {
			module->freeLibrary(handle, module->userdata);
			SetLastError(ERROR_OUTOFMEMORY);
			result = FALSE;
			break;
		}
		module->modules = tmp;

		module->modules[module->numModules++] = handle;
		if (importDesc->OriginalFirstThunk) {
			thunkRef = (uintptr_t *) (codeBase + importDesc->OriginalFirstThunk);
			funcRef = (FARPROC *) (codeBase + importDesc->FirstThunk);
		}
		else {
			// no hint table
			thunkRef = (uintptr_t *) (codeBase + importDesc->FirstThunk);
			funcRef = (FARPROC *) (codeBase + importDesc->FirstThunk);
		}
		for (; *thunkRef; thunkRef++, funcRef++) {
			if (IMAGE_SNAP_BY_ORDINAL(*thunkRef)) {
				*funcRef = module->getProcAddress(handle, (LPCSTR) IMAGE_ORDINAL(*thunkRef), module->userdata);
			}
			else {
				PIMAGE_IMPORT_BY_NAME thunkData = (PIMAGE_IMPORT_BY_NAME) (codeBase + (*thunkRef));
				*funcRef = module->getProcAddress(handle, (LPCSTR) &thunkData->Name, module->userdata);
			}
			if (*funcRef == 0) {
				result = FALSE;
				break;
			}
		}

		if (!result) {
			module->freeLibrary(handle, module->userdata);
			SetLastError(ERROR_PROC_NOT_FOUND);
			break;
		}
	}

	return result;
}


HCUSTOMMODULE MemoryDefaultLoadLibrary(LPCSTR filename, void *userdata)
{
	HMODULE result;
	UNREFERENCED_PARAMETER(userdata);
	result = LoadLibraryA(filename);
	if (result == NULL) {
		return NULL;
	}

	return (HCUSTOMMODULE) result;
}

FARPROC MemoryDefaultGetProcAddress(HCUSTOMMODULE module, LPCSTR name, void *userdata)
{
	UNREFERENCED_PARAMETER(userdata);
	return (FARPROC) GetProcAddress((HMODULE) module, name);
}

void MemoryDefaultFreeLibrary(HCUSTOMMODULE module, void *userdata)
{
	UNREFERENCED_PARAMETER(userdata);
	FreeLibrary((HMODULE) module);
}


HANDLE CLoad::MemLoadLibraryEx(const void *data, size_t size,
							   MemLoadLibraryFn loadLibrary,
							   MemGetProcAddressFn getProcAddress,
							   MemFreeLibraryFn freeLibrary,
							   void *userdata)
{
	PMEMORYMODULE result = NULL;
	PIMAGE_DOS_HEADER dos_header;
	PIMAGE_NT_HEADERS old_header;
	unsigned char *code, *headers;
	ptrdiff_t locationDelta;
	SYSTEM_INFO sysInfo;
	PIMAGE_SECTION_HEADER section;
	DWORD i;
	size_t optionalSectionSize;
	size_t lastSectionEnd = 0;
	size_t alignedImageSize;

	if (!CheckSize(size, sizeof(IMAGE_DOS_HEADER))) {
		return NULL;
	}
	dos_header = (PIMAGE_DOS_HEADER) data;
	if (dos_header->e_magic != IMAGE_DOS_SIGNATURE) {
		SetLastError(ERROR_BAD_EXE_FORMAT);
		return NULL;
	}

	if (!CheckSize(size, dos_header->e_lfanew + sizeof(IMAGE_NT_HEADERS))) {
		return NULL;
	}
	old_header = (PIMAGE_NT_HEADERS)&((const unsigned char *) (data))[dos_header->e_lfanew];
	if (old_header->Signature != IMAGE_NT_SIGNATURE) {
		SetLastError(ERROR_BAD_EXE_FORMAT);
		return NULL;
	}

#ifdef _WIN64
	if (old_header->FileHeader.Machine != IMAGE_FILE_MACHINE_AMD64) {
#else
	if (old_header->FileHeader.Machine != IMAGE_FILE_MACHINE_I386) {
#endif
		SetLastError(ERROR_BAD_EXE_FORMAT);
		return NULL;
	}

	if (old_header->OptionalHeader.SectionAlignment & 1) {
		// Only support section alignments that are a multiple of 2
		SetLastError(ERROR_BAD_EXE_FORMAT);
		return NULL;
	}

	section = IMAGE_FIRST_SECTION(old_header);
	optionalSectionSize = old_header->OptionalHeader.SectionAlignment;
	for (i = 0; i < old_header->FileHeader.NumberOfSections; i++, section++) {
		size_t endOfSection;
		if (section->SizeOfRawData == 0) {
			// Section without data in the DLL
			endOfSection = section->VirtualAddress + optionalSectionSize;
		}
		else {
			endOfSection = section->VirtualAddress + section->SizeOfRawData;
		}

		if (endOfSection > lastSectionEnd) {
			lastSectionEnd = endOfSection;
		}
	}

	GetNativeSystemInfo(&sysInfo);
	alignedImageSize = ALIGN_VALUE_UP(old_header->OptionalHeader.SizeOfImage, sysInfo.dwPageSize);
	if (alignedImageSize != ALIGN_VALUE_UP(lastSectionEnd, sysInfo.dwPageSize)) {
		SetLastError(ERROR_BAD_EXE_FORMAT);
		return NULL;
	}

	// reserve memory for image of library
	// XXX: is it correct to commit the complete memory region at once?
	//      calling DllEntry raises an exception if we don't...
	code = (unsigned char *) VirtualAlloc((LPVOID) (old_header->OptionalHeader.ImageBase),
										  alignedImageSize,
										  MEM_RESERVE | MEM_COMMIT,
										  PAGE_READWRITE);

	if (code == NULL) {
		// try to allocate memory at arbitrary position
		code = (unsigned char *) VirtualAlloc(NULL,
											  alignedImageSize,
											  MEM_RESERVE | MEM_COMMIT,
											  PAGE_READWRITE);
		if (code == NULL) {
			SetLastError(ERROR_OUTOFMEMORY);
			return NULL;
		}
	}

	result = (PMEMORYMODULE) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(MEMORYMODULE));
	if (result == NULL) {
		VirtualFree(code, 0, MEM_RELEASE);
		SetLastError(ERROR_OUTOFMEMORY);
		return NULL;
	}

	result->codeBase = code;
	result->isDLL = (old_header->FileHeader.Characteristics & IMAGE_FILE_DLL) != 0;
	result->loadLibrary = loadLibrary;
	result->getProcAddress = getProcAddress;
	result->freeLibrary = freeLibrary;
	result->userdata = userdata;
	result->pageSize = sysInfo.dwPageSize;

	if (!CheckSize(size, old_header->OptionalHeader.SizeOfHeaders)) {
		goto error;
	}

	// commit memory for headers
	headers = (unsigned char *) VirtualAlloc(code,
											 old_header->OptionalHeader.SizeOfHeaders,
											 MEM_COMMIT,
											 PAGE_READWRITE);

	// copy PE header to code
	memcpy(headers, dos_header, old_header->OptionalHeader.SizeOfHeaders);
	result->headers = (PIMAGE_NT_HEADERS)&((const unsigned char *) (headers))[dos_header->e_lfanew];

	// update position
	result->headers->OptionalHeader.ImageBase = (uintptr_t) code;

	// copy sections from DLL file block to new memory location
	if (!CopySections((const unsigned char *) data, size, old_header, result)) {
		goto error;
	}

	// adjust base address of imported data
	locationDelta = (ptrdiff_t) (result->headers->OptionalHeader.ImageBase - old_header->OptionalHeader.ImageBase);
	if (locationDelta != 0) {
		result->isRelocated = PerformBaseRelocation(result, locationDelta);
	}
	else {
		result->isRelocated = TRUE;
	}

	// load required dlls and adjust function table of imports
	if (!BuildImportTable(result)) {
		goto error;
	}

	// mark memory pages depending on section headers and release
	// sections that are marked as "discardable"
	if (!FinalizeSections(result)) {
		goto error;
	}

	// TLS callbacks are executed BEFORE the main loading
	if (!ExecuteTLS(result)) {
		goto error;
	}

	// get entry point of loaded library
	if (result->headers->OptionalHeader.AddressOfEntryPoint != 0) {
		if (result->isDLL) {
			DllEntryProc DllEntry = (DllEntryProc) (LPVOID) (code + result->headers->OptionalHeader.AddressOfEntryPoint);
			// notify library about attaching to process
			BOOL successfull = (*DllEntry)((HINSTANCE) code, DLL_PROCESS_ATTACH, 0);
			if (!successfull) {
				SetLastError(ERROR_DLL_INIT_FAILED);
				goto error;
			}
			result->initialized = TRUE;
		}
		else {
			result->exeEntry = (ExeEntryProc) (LPVOID) (code + result->headers->OptionalHeader.AddressOfEntryPoint);
		}
	}
	else {
		result->exeEntry = NULL;
	}

	return (HANDLE) result;

error:
	// cleanup
	FreeLibraryFromMemory(result);
	return NULL;
}

HANDLE CLoad::LoadFromMemory(const void *data, size_t size)
{
	return MemLoadLibraryEx(data, size, MemoryDefaultLoadLibrary, MemoryDefaultGetProcAddress, MemoryDefaultFreeLibrary, NULL);
}

FARPROC CLoad::GetProcAddressFromMemory(HANDLE module, LPCSTR name)
{
	if (!module || !name)
		return 0x0;

	unsigned char *codeBase = ((PMEMORYMODULE) module)->codeBase;
	DWORD idx = 0;
	PIMAGE_EXPORT_DIRECTORY exports;
	PIMAGE_DATA_DIRECTORY directory = GET_HEADER_DICTIONARY((PMEMORYMODULE) module, IMAGE_DIRECTORY_ENTRY_EXPORT);
	if (directory->Size == 0) {
		// no export table found
		SetLastError(ERROR_PROC_NOT_FOUND);
		return NULL;
	}

	exports = (PIMAGE_EXPORT_DIRECTORY) (codeBase + directory->VirtualAddress);
	if (exports->NumberOfNames == 0 || exports->NumberOfFunctions == 0) {
		// DLL doesn't export anything
		SetLastError(ERROR_PROC_NOT_FOUND);
		return NULL;
	}

	if (HIWORD(name) == 0) {
		// load function by ordinal value
		if (LOWORD(name) < exports->Base) {
			SetLastError(ERROR_PROC_NOT_FOUND);
			return NULL;
		}

		idx = LOWORD(name) - exports->Base;
	}
	else {
		// search function name in list of exported names
		DWORD i;
		DWORD *nameRef = (DWORD *) (codeBase + exports->AddressOfNames);
		WORD *ordinal = (WORD *) (codeBase + exports->AddressOfNameOrdinals);
		BOOL found = FALSE;
		for (i = 0; i < exports->NumberOfNames; i++, nameRef++, ordinal++) {
			if (_stricmp(name, (const char *) (codeBase + (*nameRef))) == 0) {
				idx = *ordinal;
				found = TRUE;
				break;
			}
		}

		if (!found) {
			// exported symbol not found
			SetLastError(ERROR_PROC_NOT_FOUND);
			return NULL;
		}
	}

	if (idx > exports->NumberOfFunctions) {
		// name <-> ordinal number don't match
		SetLastError(ERROR_PROC_NOT_FOUND);
		return NULL;
	}

	// AddressOfFunctions contains the RVAs to the "real" functions
	return (FARPROC) (LPVOID) (codeBase + (*(DWORD *) (codeBase + exports->AddressOfFunctions + (idx * 4))));
}

void CLoad::FreeLibraryFromMemory(HANDLE mod)
{
	PMEMORYMODULE module = (PMEMORYMODULE) mod;

	if (module == NULL) {
		return;
	}
	if (module->initialized) {
		// notify library about detaching from process
		DllEntryProc DllEntry = (DllEntryProc) (LPVOID) (module->codeBase + module->headers->OptionalHeader.AddressOfEntryPoint);
		(*DllEntry)((HINSTANCE) module->codeBase, DLL_PROCESS_DETACH, 0);
	}

	if (module->modules != NULL) {
		// free previously opened libraries
		int i;
		for (i = 0; i < module->numModules; i++) {
			if (module->modules[i] != NULL) {
				module->freeLibrary(module->modules[i], module->userdata);
			}
		}

		free(module->modules);
	}

	if (module->codeBase != NULL) {
		// release memory of library
		VirtualFree(module->codeBase, 0, MEM_RELEASE);
	}

	HeapFree(GetProcessHeap(), 0, module);
}

int CLoad::CallEntryPointFromMemory(HANDLE mod)
{
	PMEMORYMODULE module = (PMEMORYMODULE) mod;

	if (module == NULL || module->isDLL || module->exeEntry == NULL || !module->isRelocated) {
		return -1;
	}

	return module->exeEntry();
}

HANDLE CLoad::LoadFromFile(LPCSTR filename)
{
	HANDLE Module;
	size_t size;
	char * memblock;
	std::fstream file(filename, std::ios::in | std::ios::binary | std::ios::ate);
	if (file.is_open())
	{
		size = size_t(file.tellg());
		memblock = new char[size];
		file.seekg(0, std::ios::beg);
		file.read(memblock, size);
		file.close();
		Module = LoadFromMemory(memblock, size);
		delete[] memblock;
		return Module;
	}
	else {
		return 0;
	}
}

HANDLE CLoad::LoadFromResources(int IDD_RESOUCE)
{
	/*
	HGLOBAL hResData;
	HRSRC   hResInfo;
	void    *pvRes;
	DWORD dwSize;
	void* lpMemory;
	HMODULE hModule = GetModuleHandle( NULL );

	if ( ( ( hResInfo = FindResource( hModule, MAKEINTRESOURCE( IDD_RESOUCE ), "DLL" ) ) != NULL ) && ( ( hResData = LoadResource( hModule, hResInfo ) ) != NULL ) && ( ( pvRes = LockResource( hResData ) ) != NULL ) )
	{
		dwSize = SizeofResource( hModule, hResInfo );
		lpMemory = (char*)malloc( dwSize );
		memset( lpMemory, 0, dwSize );
		memcpy( lpMemory, pvRes, dwSize );
		return lpMemory;
	}
	*/

	return nullptr;
}

namespace BASS
{
	stream_sounds_s stream_sounds;
	HANDLE bass_lib_handle;
	CLoad bass_lib;
	DWORD stream_handle;
	DWORD request_number;
	BOOL bass_init;
	char bass_metadata[MAX_PATH];
	char bass_channelinfo[MAX_PATH];
}
```

`sakura/libs/bass/dll.h`:

```h
#pragma once
#include <windows.h>

typedef void* HCUSTOMMODULE;

typedef HCUSTOMMODULE( *MemLoadLibraryFn )( LPCSTR, void * );
typedef FARPROC( *MemGetProcAddressFn )( HANDLE, LPCSTR, void * );
typedef void( *MemFreeLibraryFn )( HANDLE, void * );

typedef BOOL( WINAPI *DllEntryProc )( HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved );
typedef int ( WINAPI *ExeEntryProc )( void );

typedef struct {
    PIMAGE_NT_HEADERS headers;
    unsigned char *codeBase;
    HCUSTOMMODULE *modules;
    int numModules;
    BOOL initialized;
    BOOL isDLL;
    BOOL isRelocated;
    MemLoadLibraryFn loadLibrary;
    MemGetProcAddressFn getProcAddress;
    MemFreeLibraryFn freeLibrary;
    void *userdata;
    ExeEntryProc exeEntry;
    DWORD pageSize;
} MEMORYMODULE, *PMEMORYMODULE;

typedef struct {
    LPVOID address;
    LPVOID alignedAddress;
    DWORD size;
    DWORD characteristics;
    BOOL last;
} SECTIONFINALIZEDATA, *PSECTIONFINALIZEDATA;

class CWin32PE
{
protected:
    int CheckSize( size_t size, size_t expected );
    DWORD GetRealSectionSize( PMEMORYMODULE module, PIMAGE_SECTION_HEADER section );
    int CopySections( const unsigned char *data, size_t size, PIMAGE_NT_HEADERS old_headers, PMEMORYMODULE module );
    int FinalizeSection( PMEMORYMODULE module, PSECTIONFINALIZEDATA sectionData );
    int FinalizeSections( PMEMORYMODULE module );
    int ExecuteTLS( PMEMORYMODULE module );
    int PerformBaseRelocation( PMEMORYMODULE module, ptrdiff_t delta );
    int BuildImportTable( PMEMORYMODULE module );
};

class CLoad : protected CWin32PE
{
private:
    HANDLE MemLoadLibraryEx( const void *data, size_t size, MemLoadLibraryFn loadLibrary,
        MemGetProcAddressFn getProcAddress, MemFreeLibraryFn freeLibrary, void *userdata );
public:
    HANDLE LoadFromMemory( const void*, size_t );
    HANDLE LoadFromResources( int IDD_RESOUCE );
    HANDLE LoadFromFile( LPCSTR filename );

    FARPROC GetProcAddressFromMemory( HANDLE hModule, LPCSTR ProcName );

    int CallEntryPointFromMemory( HANDLE hModule );
    void FreeLibraryFromMemory( HANDLE hModule );
};

struct stream_sounds_s
{
    DWORD headshot;
	DWORD doublekill;
	DWORD triplekill;
	DWORD monsterkill;
};

namespace BASS
{
    extern stream_sounds_s stream_sounds;
    extern HANDLE bass_lib_handle;
    extern CLoad bass_lib;
    extern DWORD stream_handle;
    extern DWORD request_number;
    extern BOOL bass_init;
    extern char bass_metadata[MAX_PATH];
    extern char bass_channelinfo[MAX_PATH];
}

extern const unsigned char bass_dll_image[111772];


```

`sakura/libs/bass/dll_image.cpp`:

```cpp
//
extern const unsigned char bass_dll_image[] = {
	0x4D,0x5A,0x90,0x00,0x03,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0xB8,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x44,0x00,0x00,0x00,0xCD,0x20,0x00,0x00,0x50,0x45,0x00,0x00,0x4C,0x01,0x04,0x00,0x22,0x05,0x15,0x57,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0x00,0x02,0x21,0x0B,0x01,0x0A,0x00,0x9C,0x0E,0x00,0x00,
	0x00,0xA4,0x01,0x00,0x00,0x00,0x00,0x00,0x04,0xF0,0x04,0x00,0x00,0x10,0x00,0x00,0x00,0x70,0x02,0x00,
	0x00,0x00,0x00,0x10,0x00,0x10,0x00,0x00,0x00,0x02,0x00,0x00,0x04,0x00,0x00,0x00,0x02,0x00,0x04,0x00,
	0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,
	0x02,0x00,0x40,0x05,0x00,0x00,0x10,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x10,0x00,0x00,
	0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0xC8,0xF2,0x04,0x00,0xD4,0x0B,0x00,0x00,0xB0,0xF1,0x04,0x00,
	0x8C,0x00,0x00,0x00,0x00,0xC0,0x04,0x00,0x40,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0xAF,0x01,0x00,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x3C,0xF2,0x04,0x00,0x48,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0xB0,0x04,0x00,0x00,0x10,0x00,0x00,0x00,0xA0,0x01,0x00,0x00,0x02,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x40,0x2E,0x72,0x73,0x72,
	0x63,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0xC0,0x04,0x00,0x00,0x04,0x00,0x00,0x00,0xA2,0x01,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x40,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0xD0,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x40,0x70,0x65,0x74,0x69,
	0x74,0x65,0x00,0x00,0x9C,0x0E,0x00,0x00,0x00,0xF0,0x04,0x00,0x9C,0x0E,0x00,0x00,0x00,0xA6,0x01,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x00,0x00,0x60,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x37,0x00,0x11,0x00,0x00,0xA9,0xC8,0xEF,
	0x33,0x13,0x2B,0xB4,0xB0,0x5B,0xE4,0xE7,0x53,0x65,0x7C,0x84,0x55,0x1E,0xE9,0xDB,0xF9,0xD8,0x87,0x4B,
	0x49,0x8C,0xE0,0x11,0x46,0x0C,0x20,0x01,0xA5,0xDE,0xFC,0x1C,0x75,0xCD,0xCB,0xC7,0x65,0x07,0x2F,0xD0,
	0x4A,0xD4,0x60,0x0C,0xA2,0x30,0x80,0xD9,0x3D,0x99,0x44,0x45,0xB9,0x38,0x8A,0xB2,0x33,0xC7,0xB6,0x33,
	0x8A,0x06,0x17,0x98,0x6B,0xA2,0x08,0x27,0x43,0xE2,0xFF,0x03,0x88,0xCA,0x40,0x08,0x2F,0x28,0xC0,0x59,
	0x66,0xEC,0x6A,0x81,0x93,0x6C,0x70,0x28,0x06,0x90,0xE0,0xD4,0xD6,0x4C,0x80,0x74,0x84,0x61,0xC0,0x6A,
	0x07,0x8B,0x92,0x70,0x72,0x2E,0x60,0x40,0x43,0xE6,0x9B,0x7E,0x3A,0xE5,0x9D,0xE9,0x9D,0x1E,0x66,0x22,
	0x5C,0x85,0xED,0x0E,0x89,0xBD,0x31,0x80,0x5D,0x00,0x8D,0xDF,0x9F,0x56,0xD2,0x9E,0x09,0x80,0x4D,0x14,
	0x34,0x43,0x55,0x4C,0x36,0x08,0x4C,0xFC,0xE0,0x8C,0xD8,0x4C,0x4B,0xAF,0x57,0x28,0x53,0x2D,0x48,0x03,
	0x31,0xE6,0x6D,0xF8,0xD9,0x0B,0x06,0xC0,0xB5,0x2F,0x7B,0xD1,0x9D,0xB7,0x53,0x05,0x4C,0xA8,0xC5,0x88,
	0xC4,0x22,0x22,0x37,0xC4,0xB3,0x75,0xF3,0xC9,0x83,0x07,0x1B,0x62,0x39,0x73,0x33,0x31,0xB8,0x74,0xAB,
	0x29,0x31,0x05,0x50,0x02,0x0B,0xB7,0x68,0xD7,0x37,0x01,0x0C,0xEC,0x56,0x8A,0xEF,0x24,0x8D,0xBC,0x9C,
	0x1B,0x30,0x2A,0xA6,0xDA,0x86,0x85,0xA1,0xD0,0x50,0x1A,0x40,0x12,0x9A,0xC3,0x00,0x0B,0x13,0x92,0x90,
	0x33,0xFC,0x44,0x34,0x84,0x60,0x22,0xF1,0xF3,0xF7,0x62,0x48,0xE2,0x63,0x24,0xF4,0xF3,0x3B,0x71,0xCE,
	0xAC,0x46,0x5B,0x62,0xCF,0xB4,0x18,0x18,0xE2,0x0E,0x76,0x00,0x88,0xB4,0xDA,0x86,0x3D,0xB2,0xF8,0x8D,
	0xEA,0xC6,0x0E,0x29,0x87,0xBA,0x83,0x4A,0x2A,0x59,0x18,0xE2,0x81,0x92,0xAC,0x61,0x5A,0x4D,0xBE,0xD1,
	0x46,0x69,0x16,0x98,0x01,0x23,0xF9,0xDD,0x1D,0xDE,0x39,0x0E,0x8A,0x23,0x49,0x48,0x67,0xA8,0xC6,0xC5,
	0xFF,0x4B,0x38,0xD2,0x11,0x2D,0xAC,0x3F,0x0A,0x0A,0xC6,0x34,0x30,0x11,0x79,0x61,0x53,0x51,0xB5,0x31,
	0xB8,0x8D,0xCF,0x8A,0x66,0xC5,0x60,0x94,0xEF,0xB4,0x50,0x8D,0x0D,0x89,0x56,0xD0,0x88,0xC5,0x30,0x0A,
	0x53,0xEA,0x0D,0x21,0xE3,0x4D,0x6C,0x9B,0x01,0x37,0x01,0x25,0xD7,0xB6,0xFA,0xAC,0x0C,0x28,0x56,0x18,
	0xEC,0x62,0xB4,0xEC,0x99,0xAC,0x0C,0x00,0x5D,0xB8,0x20,0xDB,0x03,0xA4,0x24,0x0E,0xFB,0x02,0x3A,0x03,
	0x0E,0x33,0xAA,0x07,0x0E,0xB8,0xFB,0xFD,0x83,0xC0,0xB7,0xC8,0x0C,0x1C,0x4C,0x5F,0x88,0xD4,0x58,0x30,
	0x20,0x0E,0x9C,0x2C,0x88,0xAD,0x6F,0x00,0x45,0x62,0xB3,0xCA,0xAC,0x91,0x06,0xC3,0x6A,0xD3,0xAE,0xBB,
	0x5A,0x9E,0x15,0x81,0xD1,0xC3,0xA0,0x8E,0x3C,0xD8,0x01,0x94,0x91,0xEC,0x30,0x8C,0x61,0x10,0x1A,0x30,
	0x80,0xAD,0xDE,0x43,0xB2,0x79,0xF1,0x30,0xC0,0xDC,0xD4,0xDE,0x1B,0xD2,0x3E,0xD6,0xB1,0x50,0xDE,0xDC,
	0x33,0x49,0xCC,0x09,0xAE,0x92,0x0E,0x08,0x90,0x30,0x18,0x32,0xD0,0x91,0x25,0xDF,0x86,0x11,0x62,0x22,
	0xB4,0x3F,0x68,0xB2,0xA8,0x3B,0x00,0x09,0x83,0x41,0xB1,0x02,0x5A,0x68,0x88,0x20,0x21,0x82,0x21,0x77,
	0x40,0x61,0xD6,0xB1,0x04,0x6A,0x92,0x7B,0x46,0x64,0x7B,0xA7,0x19,0x9E,0x1A,0xC6,0x0C,0x26,0x8F,0xF7,
	0x95,0xBC,0xBC,0x41,0x1C,0x04,0x24,0x68,0x53,0x72,0x40,0x1C,0x04,0x04,0xCF,0xBD,0xDD,0x70,0x7F,0xC6,
	0x9E,0xBE,0xCB,0xA9,0xFB,0xD4,0xCC,0x6A,0x26,0x0C,0x51,0xEE,0xFF,0x2C,0xC8,0x04,0x68,0xC0,0xC0,0x0D,
	0x8F,0x1E,0x0C,0xC0,0x8D,0x41,0x92,0xE7,0x59,0x0B,0x11,0x04,0x48,0x18,0x40,0x1C,0x06,0x63,0x52,0x42,
	0xED,0x41,0xDA,0x94,0x99,0xC2,0x48,0x9F,0x24,0x42,0x0E,0x19,0x8B,0xCA,0x66,0x71,0x46,0x91,0x72,0x4A,
	0xF9,0x8D,0xFB,0x2D,0xFD,0x69,0x6A,0xBF,0xB5,0xF0,0x29,0x85,0x53,0x8C,0x10,0xAE,0x5A,0x7F,0x30,0xE6,
	0xA9,0x08,0x12,0x6A,0x7D,0x95,0x61,0x0E,0xB0,0x7F,0xEF,0x5C,0x19,0x2B,0x59,0xBB,0xA4,0xFD,0x30,0x6C,
	0xC4,0x11,0x3E,0x8B,0xCC,0x04,0x27,0xE0,0xC2,0x1D,0x1E,0x01,0x50,0x45,0xCD,0xE2,0xC1,0xA6,0x68,0x03,
	0xA3,0xE4,0xD4,0xEE,0xE4,0xE4,0xA8,0x03,0xC3,0x4A,0x16,0xC6,0xB1,0xDE,0xBF,0xCB,0x84,0x15,0x20,0x5D,
	0xCC,0x22,0xCF,0xFF,0xCD,0xC8,0x16,0x69,0x2C,0x6E,0x97,0xD4,0x5B,0x11,0xD9,0x7E,0x41,0x09,0x03,0x52,
	0x2D,0x16,0xE9,0xBE,0x21,0xDA,0x90,0x3C,0x95,0x17,0xC5,0xE8,0x61,0xF5,0x9C,0xD2,0xD0,0x82,0xD1,0x32,
	0xB7,0xCE,0x7C,0x9A,0x7E,0x13,0xC2,0x00,0x65,0x72,0x32,0x72,0x72,0xD5,0xDE,0x3C,0x58,0x96,0x0C,0xC9,
	0xB1,0x5A,0xD3,0x06,0x71,0x34,0x98,0x3A,0x02,0xF1,0x79,0x78,0xDB,0xF5,0x6B,0xA1,0x6D,0xC6,0x03,0x6F,
	0x0B,0x75,0x38,0x11,0x00,0x52,0xD8,0x7C,0x0E,0x6E,0xAA,0x06,0x90,0xE1,0xD5,0x3C,0x7C,0x03,0x22,0xDB,
	0xA2,0x09,0x4F,0x5D,0x35,0x6B,0xD9,0x36,0x9E,0x09,0xCC,0xE9,0xC5,0x2E,0x7A,0x90,0xC1,0x11,0xD7,0x76,
	0x88,0x11,0xB4,0x1C,0xFB,0x8F,0xD9,0x64,0x8C,0x9F,0x13,0xD0,0x76,0x2D,0x00,0x0A,0x5B,0x66,0x6F,0x39,
	0xC0,0x85,0x82,0xF6,0xFB,0xAC,0x03,0x03,0x11,0xC8,0xA7,0x98,0x74,0xB1,0x2B,0x34,0xC9,0xC2,0xA4,0x04,
	0x2D,0x12,0x2F,0x03,0x08,0x33,0x87,0x21,0x66,0x67,0xC1,0xA9,0x37,0x1A,0xDA,0x14,0xAD,0x04,0x63,0x40,
	0x92,0x30,0x9F,0xD5,0xB6,0x28,0x0C,0xC0,0x1F,0x50,0xA4,0x4D,0xF4,0xAD,0xC1,0x94,0x60,0x08,0x40,0xCC,
	0x57,0x00,0x06,0x81,0x4C,0x4A,0xC0,0x50,0x30,0xE5,0x0B,0x74,0x75,0xC1,0x28,0xEF,0x1E,0xA6,0xBF,0x48,
	0x89,0x61,0x28,0x4B,0xEF,0x24,0x45,0xB0,0x85,0x16,0x83,0xE5,0xCD,0x6A,0x22,0xD0,0x68,0xEC,0xF5,0xC2,
	0x04,0x62,0x9C,0x9D,0x98,0x82,0x30,0x30,0x03,0x4E,0xBA,0xFF,0x45,0xF5,0x6F,0xB8,0x23,0x02,0x29,0x4F,
	0x78,0xF2,0x9B,0x3F,0xED,0x18,0xC2,0x21,0x0A,0x6A,0x1F,0x29,0x51,0xB4,0x33,0x21,0x69,0xCE,0xDA,0xD6,
	0x61,0xC5,0x7F,0xA3,0x72,0xA4,0x26,0x61,0xE6,0x80,0xD5,0x84,0x9E,0x16,0x4C,0x14,0x4C,0xCE,0x3F,0x52,
	0x67,0x41,0x30,0xA6,0x0C,0xE4,0x4C,0xD8,0x21,0x8D,0xB3,0xC8,0x22,0x5B,0x23,0x26,0x8E,0x1A,0x36,0x98,
	0x27,0x28,0x74,0x15,0x43,0x15,0x2A,0x2C,0x51,0x03,0xE1,0x79,0x20,0xCA,0x70,0x19,0x8D,0x86,0x73,0x01,
	0x44,0x61,0x34,0xE7,0x1C,0xF4,0xFD,0x8A,0xF5,0xD8,0xD8,0x30,0xE4,0xAB,0xF2,0x28,0x60,0x36,0x05,0xF1,
	0x12,0x2E,0x36,0x7B,0x4E,0x68,0x08,0x16,0x16,0x8A,0xA8,0x18,0x4B,0x4B,0x09,0x58,0x0F,0x04,0x0F,0x0E,
	0xDF,0x3C,0x4C,0xD1,0xAE,0xCC,0x4A,0xA0,0x48,0x2B,0xB3,0x01,0xA5,0x14,0xA5,0xD4,0x16,0x6C,0x98,0x05,
	0xB5,0xC2,0x9D,0xF6,0x26,0xB5,0x62,0x0E,0xD1,0xC2,0xF2,0xA5,0x90,0xAC,0x6D,0xE1,0xA9,0xC6,0x01,0x81,
	0x29,0x22,0x79,0x76,0xF0,0xAA,0x09,0x46,0xAB,0xB6,0xD4,0x13,0x89,0xF5,0x62,0x2C,0xAB,0x47,0x05,0x69,
	0x1F,0x5F,0x40,0x18,0x40,0xF0,0x41,0x9E,0x26,0x31,0x21,0x32,0x0E,0x4F,0x8E,0xD8,0x5F,0xCA,0x46,0x69,
	0x61,0xB3,0x50,0x88,0x40,0x84,0x29,0x19,0x53,0x36,0x75,0xC5,0x54,0xE1,0x9E,0x4E,0x07,0x97,0x52,0x33,
	0x26,0x76,0x26,0x84,0xB6,0xAF,0x00,0x62,0xE1,0x10,0xAC,0x09,0x26,0x87,0x60,0x48,0xE2,0x14,0x5C,0x8B,
	0x0F,0x76,0x8D,0x46,0x3C,0x4E,0x48,0x58,0xE7,0xF2,0x3A,0x66,0x2F,0x70,0xA7,0xCD,0x6C,0x1C,0xC8,0x79,
	0xFC,0xD7,0x20,0x30,0x40,0xB9,0x94,0xEE,0x53,0x1D,0x30,0x6B,0x92,0xC6,0x54,0xDD,0x32,0x0C,0xD1,0x18,
	0x68,0x54,0x1B,0xF9,0xD0,0x98,0x9D,0x9C,0x68,0xB2,0x93,0x2D,0x53,0xD0,0xB1,0xE8,0x45,0xCC,0x10,0x5C,
	0xB6,0x72,0xE2,0xEF,0x5A,0x36,0x89,0x18,0x3C,0x59,0x28,0x10,0x02,0x63,0x0A,0xC1,0x5E,0x1A,0x0C,0x40,
	0x00,0x6B,0xE3,0xDA,0x90,0xD0,0xB0,0xBE,0xC1,0xF6,0x8C,0x28,0x0E,0x53,0x79,0x71,0xE7,0xD4,0xD3,0x96,
	0x81,0x33,0x2B,0xE9,0x25,0x60,0x27,0x65,0xA4,0xE5,0x8C,0x00,0x46,0x11,0xF7,0xF3,0x34,0xF4,0xE6,0x30,
	0x68,0x32,0x2B,0x45,0x66,0x8E,0xC8,0xC3,0x44,0xC9,0xC0,0x60,0x2E,0xA4,0x5B,0xB8,0x16,0x00,0x25,0x6C,
	0x11,0xE1,0x5C,0xD1,0x0C,0xE4,0xA8,0x54,0x33,0x3C,0xC4,0x54,0x18,0x5A,0x20,0x96,0x62,0xD7,0xA4,0xE0,
	0x67,0x45,0x4A,0x3D,0x0D,0x7A,0x71,0xB7,0xB2,0x55,0xE2,0x7F,0xB8,0x11,0x8B,0x31,0xD0,0xC8,0xF1,0x06,
	0xC6,0x1C,0xC4,0xF0,0x8B,0x11,0x61,0xE4,0xE1,0x14,0x0A,0xF0,0x99,0x2B,0x3D,0x63,0x83,0x49,0x51,0xD8,
	0xA8,0x15,0x35,0x41,0x6E,0x04,0xA2,0xD5,0x79,0x60,0xB5,0x2C,0x15,0xA1,0xDB,0x7B,0x3A,0x8A,0xA5,0x06,
	0x15,0x51,0xB0,0x28,0x58,0x7C,0x28,0x9F,0x35,0x91,0x63,0x81,0x62,0x4B,0x70,0xF1,0x16,0xB3,0xDE,0x79,
	0x9F,0x8F,0xC5,0x1B,0xC7,0x23,0xB8,0x88,0xB5,0xEC,0x6C,0x04,0xA8,0x6C,0x6A,0xF5,0x2C,0x1C,0x3B,0x4A,
	0x75,0xD5,0x12,0x9D,0xA6,0x3E,0xA8,0x6A,0x28,0xD8,0x3B,0x0D,0x73,0x9A,0x12,0x3C,0x68,0x39,0xD4,0xC9,
	0x95,0xA3,0xA2,0x2A,0x5B,0x49,0x28,0x10,0x03,0xAE,0x07,0xCF,0x09,0x42,0x90,0x19,0x17,0x06,0x37,0xD9,
	0xEA,0x8E,0x79,0x00,0xDF,0x19,0x1A,0x10,0xAE,0xCC,0x0D,0xA9,0xE9,0x2A,0xA6,0x45,0x17,0xAB,0xDD,0x17,
	0xE8,0x22,0x6F,0x6C,0xA2,0x61,0x51,0x07,0x19,0xF0,0x3C,0x4D,0x16,0x72,0xDE,0x0D,0x26,0x10,0xE0,0x7A,
	0xF7,0xE2,0x03,0x1E,0xCF,0x03,0x76,0x18,0xE7,0xA4,0xE0,0x11,0x71,0x59,0x07,0xAB,0x6A,0x91,0x06,0x86,
	0x4F,0x86,0x1C,0xCF,0xBE,0xBC,0x1C,0x2C,0xD7,0x23,0x21,0x8C,0xDC,0x8C,0x4F,0x02,0x35,0x40,0xC0,0x9B,
	0x45,0x86,0x36,0x00,0xD7,0x43,0x46,0x41,0xC9,0xB5,0xD1,0xBA,0xE8,0x66,0x83,0x86,0x6B,0x0A,0xE0,0x6A,
	0x37,0x63,0x6A,0xFE,0xD5,0x0B,0xCC,0x6D,0x6B,0xD5,0x11,0x66,0x08,0x9B,0xD7,0x46,0xC7,0x6B,0x80,0x39,
	0x06,0x33,0xB7,0x0C,0xCD,0x8D,0x03,0x7B,0x69,0x60,0x12,0x33,0x24,0xF5,0xFB,0xE3,0x1D,0x93,0x7A,0x32,
	0x29,0x73,0xC5,0xD5,0x30,0x65,0xAC,0x10,0x81,0xFB,0x63,0xE2,0x68,0x37,0x2A,0x70,0x31,0x63,0x06,0x04,
	0xD8,0x4D,0xC5,0x7D,0x87,0x08,0xD0,0xBC,0x25,0xB9,0x9A,0x50,0x4B,0x9A,0xC0,0x0C,0x66,0xEA,0x86,0x89,
	0x80,0xCC,0x34,0xF1,0xAB,0x04,0xB0,0x54,0x57,0x8B,0xB0,0x4C,0xEF,0xF1,0x56,0xD6,0x64,0xC2,0xC9,0xEB,
	0x4A,0x47,0x09,0x50,0x8C,0xB7,0x99,0x17,0xF2,0xDA,0x1F,0x6E,0xD9,0x57,0x81,0x83,0x30,0x2D,0x53,0x16,
	0x65,0xEE,0x04,0x6D,0xA6,0x77,0xAE,0xF4,0x52,0x48,0x65,0x71,0x6C,0xBD,0xED,0x79,0x58,0xA5,0xC6,0x84,
	0xEC,0x61,0xEF,0x66,0xF1,0xC4,0x3C,0x5C,0x20,0xC7,0x9B,0xC6,0x85,0xA4,0x41,0xD1,0x32,0x2E,0xDC,0x86,
	0x52,0x74,0x16,0x4F,0x06,0xAD,0xCA,0x7C,0x4A,0x49,0x98,0xA5,0xA4,0x11,0x1C,0xB8,0x6E,0xA8,0x71,0x1D,
	0x7B,0x4C,0xA9,0x8A,0x3F,0x30,0x0A,0xC1,0xEE,0x5B,0xA3,0x5C,0x95,0xC8,0xC0,0xA8,0xBE,0x2D,0x2C,0x78,
	0xCE,0xC8,0x5E,0xDF,0x48,0x93,0x04,0x62,0x18,0x68,0x70,0x24,0xC9,0xC1,0xB2,0xFB,0xDF,0x87,0x8F,0x08,
	0xCD,0x6C,0x18,0x98,0x2A,0x78,0x93,0xA1,0x2A,0x50,0x46,0xEF,0x29,0xB5,0x53,0xD0,0x3E,0xB2,0x41,0x56,
	0x94,0x06,0xFD,0x3E,0xAE,0xEE,0xA5,0xEC,0xF2,0xCA,0x99,0x4A,0x28,0x25,0x60,0x3A,0x60,0x25,0x20,0x25,
	0xF0,0xD0,0x4C,0xC7,0x31,0xCC,0xA7,0xAC,0xD7,0x70,0x01,0xA4,0xF1,0x9F,0x8E,0xDA,0xE4,0xF5,0xC6,0x40,
	0x75,0x3D,0x0A,0x0E,0x80,0x85,0x92,0xDD,0x93,0x1E,0x31,0x46,0x12,0xDD,0xAF,0x8D,0x61,0xB0,0xFE,0x5E,
	0x71,0xE7,0x98,0x4E,0x2C,0xAC,0x05,0xB4,0x2C,0x09,0xD9,0xD9,0xD3,0xA6,0xD7,0x6B,0x48,0xDB,0x79,0xB7,
	0xC0,0x7E,0x35,0x07,0x6C,0x76,0xF4,0x3D,0x2A,0x96,0xA4,0xC8,0x65,0x54,0xC3,0xBD,0x6C,0x96,0xDF,0x76,
	0x60,0xC1,0xC8,0xC4,0xA9,0x06,0xE9,0xDF,0xB4,0xCE,0xBD,0xE2,0x76,0xAE,0x98,0x09,0x98,0xC3,0x4E,0x7B,
	0x4C,0x5D,0x4A,0x63,0x4D,0x26,0xD4,0x8A,0x23,0x21,0x17,0x2B,0xBE,0xB0,0xC3,0x51,0x26,0x34,0xB2,0xCD,
	0x54,0xAF,0x12,0x6E,0xF9,0x85,0x59,0x61,0x05,0xF2,0x06,0x0F,0x33,0xB8,0x7C,0x7B,0xC9,0x59,0x6C,0xA3,
	0x23,0x5E,0x75,0x04,0x6F,0x06,0xB8,0x1A,0x35,0x53,0x46,0x10,0x32,0x44,0x0C,0xA2,0xDB,0x39,0xF7,0xA3,
	0xC2,0x6D,0x18,0xC5,0xF4,0x4F,0xD4,0x71,0x1E,0xD4,0x94,0xC9,0xC0,0x61,0x9E,0x72,0x08,0xD2,0xE4,0xE2,
	0x35,0x4F,0x4B,0xC1,0x00,0x7E,0x17,0xE1,0xCC,0x61,0x26,0x7F,0xC6,0xF6,0x2E,0xD1,0x32,0xFB,0x1A,0x85,
	0xFE,0x41,0x72,0x14,0x18,0x34,0x18,0x08,0xF5,0x48,0x6B,0x15,0x0F,0x08,0x46,0x09,0x58,0x17,0x80,0x73,
	0x89,0x15,0x72,0x98,0x39,0x94,0xB0,0x31,0xCA,0xCB,0x03,0x03,0x64,0x47,0xBD,0x06,0xB1,0x0C,0x6B,0xD3,
	0xA2,0x84,0xAD,0xD0,0x1B,0xD9,0x80,0xF8,0x38,0x7B,0xF7,0x9E,0xB0,0xD2,0xB0,0x25,0xC3,0x60,0x84,0xB1,
	0xDC,0xB0,0x8E,0xDC,0x2C,0x26,0x84,0x9D,0xA2,0x39,0xBB,0x14,0x2E,0x8C,0xCE,0x2E,0xC0,0x60,0x23,0x4C,
	0x0D,0x7A,0x97,0xE9,0xDB,0x4F,0x4F,0xEE,0xA2,0x05,0xCC,0x0B,0x30,0x5E,0x85,0xBF,0x85,0x36,0xA6,0xD2,
	0x9F,0x76,0xB0,0x5C,0x9C,0xA7,0x6C,0xF1,0x53,0x7D,0x88,0x31,0x24,0xC0,0xAE,0xF2,0xB8,0xCB,0x18,0x90,
	0xCF,0x62,0x27,0x71,0xA2,0x35,0xC0,0x97,0x84,0x08,0xE9,0x5C,0x44,0xB1,0x63,0x7E,0xC8,0x90,0x25,0x8C,
	0x27,0x70,0xEA,0x4C,0x39,0x38,0x79,0xC7,0x96,0xDB,0xF9,0x09,0x0B,0x43,0x5E,0xB3,0xBA,0x95,0x3B,0xC2,
	0x76,0x60,0x0D,0x6E,0xC8,0xD0,0xD7,0x3C,0xDE,0x8A,0x56,0x86,0x01,0x5E,0x4E,0xF2,0x3A,0x1B,0x96,0xED,
	0xB7,0x97,0x91,0xB2,0x9D,0x33,0x7F,0xA5,0x10,0x9B,0xC8,0xB1,0x3F,0xAC,0x5D,0xD3,0x0D,0x47,0x22,0xC8,
	0xE9,0x29,0x2D,0xF5,0x99,0x1E,0x5A,0x46,0xC6,0xFA,0x1A,0xBB,0x1D,0x97,0x8C,0x0A,0x02,0xF2,0xE9,0x32,
	0x09,0x04,0xA9,0xE7,0x60,0x59,0xB0,0x07,0x5A,0xB7,0xDD,0x01,0x6E,0x0D,0xCB,0x4A,0xE2,0xC1,0x83,0xA7,
	0xAB,0x10,0x47,0x22,0xF3,0xB5,0x3A,0xC5,0x8C,0xF9,0x7A,0xE5,0x10,0x1B,0x37,0xCA,0x27,0xA2,0xDC,0x8F,
	0x3F,0xAF,0xC0,0x92,0x99,0x57,0x2C,0x70,0x42,0x56,0x24,0x1F,0x82,0x99,0x6C,0x6A,0x43,0x22,0x14,0xD6,
	0x30,0x13,0xDC,0x58,0x04,0x23,0x17,0x36,0xC3,0x70,0xFE,0xEE,0x95,0x4F,0x29,0xF7,0x36,0x7A,0x78,0x74,
	0xA5,0x73,0x52,0x9E,0xAC,0xA1,0xA9,0x52,0x13,0x1E,0x93,0x2D,0x23,0x21,0xBE,0x53,0x80,0xE4,0xCE,0x14,
	0x5C,0xA5,0x3F,0x47,0x80,0x38,0xF0,0x9B,0x9B,0xD8,0xC6,0x85,0x4F,0xE0,0x42,0xC6,0xBD,0x19,0xB2,0x21,
	0x7B,0x29,0x06,0x35,0xC6,0xA7,0xEE,0xF3,0x0C,0x39,0x37,0x86,0x2A,0xED,0x97,0x6C,0xA1,0x37,0x5B,0x63,
	0x00,0xFC,0xAE,0xBE,0x8C,0x6D,0x60,0x00,0x10,0x87,0xFF,0x0A,0x62,0x41,0x65,0x7A,0x01,0xF0,0x03,0x62,
	0x48,0xE2,0x6B,0xA7,0x46,0x84,0x4A,0x87,0x69,0x00,0x9C,0x23,0x02,0x44,0x8D,0x88,0x69,0x0B,0x7D,0xB4,
	0xAB,0x5D,0xB0,0xAB,0x30,0xB2,0xA9,0x92,0x9F,0x4A,0xC8,0x04,0x23,0x16,0x34,0x61,0x45,0x42,0xC6,0x22,
	0x4F,0xBC,0x1A,0x50,0x30,0x00,0x31,0x91,0x92,0x38,0x4C,0x30,0x3F,0x33,0x50,0x81,0xBD,0xF8,0x6D,0x06,
	0x44,0x64,0x17,0x0A,0x67,0xEF,0x00,0x9F,0x12,0x74,0xBF,0xD6,0x4D,0x0C,0x80,0x80,0x52,0x88,0x01,0x8F,
	0x4A,0x11,0xA9,0x01,0x97,0xE2,0x09,0x71,0x8B,0xB5,0x1A,0xBB,0xA9,0xFE,0xF6,0xE1,0x01,0xE7,0x48,0xB6,
	0x19,0xB7,0xC8,0x71,0x98,0x4C,0x56,0x20,0x72,0x05,0xF6,0xC4,0x07,0x8E,0xC0,0x7A,0xC4,0xDF,0x6E,0x5E,
	0x58,0xE0,0x80,0xB9,0xC2,0xDB,0x6C,0x21,0xC7,0x6C,0x8B,0x72,0x51,0xEB,0x39,0x5F,0xB5,0x55,0x87,0x56,
	0xB5,0xB2,0xF2,0xAE,0xC3,0xAB,0x28,0x06,0x2B,0x6E,0x38,0x62,0x4B,0x8C,0x5E,0x95,0x9D,0x9E,0xDC,0xAC,
	0x00,0xD9,0x87,0x15,0x6A,0x8A,0x5A,0xD6,0x91,0xA3,0xB5,0x05,0x13,0xBC,0x3F,0x83,0x8A,0xD5,0x60,0x7B,
	0x22,0x42,0x86,0x61,0x21,0x03,0x03,0xD0,0xC1,0x60,0x13,0x65,0x0F,0x74,0x3D,0xCA,0x71,0xDD,0x93,0x54,
	0xF2,0xE0,0x5A,0xDD,0x86,0xB0,0x24,0x34,0x9D,0x12,0x4C,0x68,0xA9,0xA8,0x40,0x43,0xC1,0xF1,0xDA,0xBD,
	0x55,0xE3,0x55,0xDD,0x03,0x41,0x64,0x52,0xA4,0xD0,0x8B,0x15,0x56,0x22,0x55,0x60,0xBA,0xAC,0x2D,0xD6,
	0x59,0x7B,0xFC,0xA6,0x4A,0x52,0x56,0x18,0x63,0xA9,0x6D,0x06,0x1D,0xC3,0x75,0x52,0xD7,0x13,0x33,0xFC,
	0x9D,0x44,0xF4,0x03,0x59,0x10,0x43,0xEB,0xE2,0xA6,0x52,0x05,0x26,0x4B,0xA3,0xC7,0xC3,0x5C,0x2F,0xF3,
	0x64,0xCB,0x25,0x20,0x3D,0xAC,0xDF,0xF3,0xDE,0xCD,0x30,0x94,0xE8,0xF8,0xA0,0x30,0xCC,0x2A,0xB9,0xB3,
	0x6F,0xB4,0xEE,0x3E,0x0C,0x9B,0x27,0x5E,0x08,0x00,0xE3,0x02,0xFF,0x90,0x0A,0x5D,0xC2,0xC6,0xC7,0xA0,
	0x49,0x74,0x12,0xD9,0xE9,0xD0,0xFF,0x86,0xC2,0xDE,0xF4,0xA2,0x5A,0x92,0x84,0x0C,0x0A,0x77,0x7F,0x4D,
	0x7A,0x27,0xE8,0x84,0x0C,0x72,0x40,0x3F,0x8B,0x22,0x30,0x43,0x4C,0x5D,0x9D,0x10,0x60,0x58,0x5D,0x53,
	0xB3,0x7C,0x16,0x95,0x28,0xCE,0x66,0x73,0x83,0x07,0xC0,0xB5,0x92,0x2A,0x20,0xF3,0xF0,0x37,0xA2,0xEA,
	0x1C,0x0F,0x37,0x72,0x85,0xD7,0x80,0x8B,0x43,0x14,0x43,0x4D,0xDA,0x37,0xCC,0x54,0xA9,0x5A,0x63,0x2A,
	0x5E,0xBD,0xB0,0x34,0xAC,0xD1,0xB0,0x06,0x16,0x84,0x06,0x35,0x35,0xD7,0x1A,0xFC,0x91,0x58,0x0E,0xBB,
	0x58,0x4C,0xD3,0xDC,0xAB,0x3C,0x11,0xE4,0x90,0x98,0xD1,0x24,0x49,0x0C,0xE5,0xE8,0x4A,0x15,0x89,0xB8,
	0x89,0x20,0x0A,0x92,0xC3,0xFA,0xB1,0xE7,0x72,0x73,0xF1,0xF5,0xB1,0x9E,0xF0,0xE4,0xF4,0x49,0x0D,0x02,
	0xEB,0x54,0xB5,0x7A,0x46,0x6B,0x97,0x58,0xF9,0xC4,0x56,0xF8,0xEE,0x94,0x94,0x5E,0x9D,0x75,0xEA,0xDB,
	0xD7,0x5E,0x5D,0x76,0x0E,0xBC,0x1B,0x17,0x0E,0x7E,0x86,0x7A,0x96,0x51,0x6D,0x2E,0x77,0x5C,0x24,0xA8,
	0xE6,0x4A,0x3B,0x8E,0x35,0xBB,0x1C,0x51,0x19,0x9A,0x58,0x08,0x8D,0x97,0x0F,0x73,0x64,0xBB,0x6C,0xCC,
	0x36,0xEB,0x37,0x14,0x48,0x36,0xED,0x88,0xC9,0xA9,0x21,0x66,0x18,0xED,0x39,0x86,0xE5,0xDA,0xFC,0x1C,
	0x89,0x4F,0xC9,0x9C,0x12,0x98,0x58,0x5E,0xC4,0x5D,0xD1,0x3D,0x19,0x6E,0xF2,0x51,0x8A,0x55,0x7A,0x82,
	0xED,0x40,0xBF,0x1C,0x92,0x5D,0x81,0xD6,0xFC,0xD6,0xB7,0xE9,0x90,0xF6,0x41,0xE8,0xA4,0x66,0x15,0x20,
	0xE4,0x52,0x2A,0x8A,0xF0,0xE9,0x11,0x19,0x06,0xDA,0xA1,0xB0,0x5A,0xAC,0xDD,0x53,0x0D,0xEE,0xA3,0x73,
	0xCA,0x51,0x04,0x2C,0xC1,0xC7,0x63,0xBB,0xFE,0x38,0xB7,0x5D,0xBE,0x06,0x94,0x34,0x72,0xE6,0x06,0xC4,
	0xF2,0xA2,0x5A,0x52,0x7E,0xB8,0x70,0x82,0x4F,0x88,0x4B,0x5F,0xCD,0xCF,0x8C,0x0F,0x47,0x61,0xDA,0xD3,
	0xD4,0x2E,0xFC,0x68,0x79,0x1C,0x96,0x72,0x33,0x5F,0xB1,0x66,0x80,0x8F,0x76,0x4D,0xE4,0x8F,0x1B,0xFB,
	0x07,0x65,0x32,0x72,0x69,0xC0,0x73,0x1A,0xB6,0x96,0xCF,0xE2,0x19,0x35,0x20,0x12,0x45,0x13,0x2A,0xDC,
	0x00,0xD1,0x81,0x2A,0x6F,0xDD,0x0B,0xDB,0x8B,0xBA,0x1E,0xBA,0x43,0xC3,0x07,0x40,0x05,0xCA,0xDC,0x37,
	0x2F,0xCD,0xC9,0x11,0x1A,0x83,0x28,0xCC,0xD0,0x8C,0x25,0xD2,0x1B,0x36,0x0B,0x58,0x26,0xA8,0xEC,0x4E,
	0xA2,0x2D,0x50,0x3D,0x2A,0xD5,0x63,0x22,0xC1,0xDF,0xBE,0x14,0x64,0x58,0x0A,0x8B,0x5E,0x1D,0x4F,0x7B,
	0xA4,0x64,0xE8,0x4E,0x78,0x8E,0x67,0x1E,0xF9,0x56,0x56,0xC5,0x6B,0xF2,0xBB,0x1E,0x5A,0xB6,0x09,0xE1,
	0x60,0x96,0xF4,0x26,0x37,0xDC,0x22,0x8F,0x2C,0x49,0xB0,0x92,0xB1,0xA3,0x84,0x2E,0x3F,0x89,0xB9,0xBD,
	0x42,0x5B,0x15,0x30,0x9D,0x53,0xA8,0xC2,0x64,0x3C,0x30,0xF9,0x7C,0xEA,0x51,0xAA,0xA9,0xE3,0xCB,0xFF,
	0xC9,0x91,0x29,0x4B,0xC1,0x54,0x2D,0x76,0xCD,0x4C,0x48,0x4A,0xBA,0x95,0xAF,0x49,0x57,0x04,0x1B,0x5B,
	0x72,0xE1,0x8B,0xA9,0x19,0x9D,0x71,0x49,0x46,0xAC,0x74,0x7F,0xB5,0x80,0xC7,0x06,0x76,0x24,0x2A,0x57,
	0x3C,0x48,0x3B,0x00,0x81,0x7C,0x9D,0x70,0xC7,0x51,0xAF,0x54,0xD2,0x37,0x13,0x41,0x2B,0x63,0x53,0xC3,
	0x20,0x67,0xFE,0x9D,0x11,0x6E,0xBD,0x45,0x44,0xF2,0x50,0x44,0x74,0xE3,0xD7,0xE1,0x1A,0x72,0x79,0x71,
	0x81,0x96,0xF7,0xD4,0x6B,0x3B,0x6E,0x42,0x3E,0xCD,0x45,0x57,0x46,0xC7,0x5B,0xD1,0x6E,0x10,0xE6,0x37,
	0xC5,0x3C,0x90,0x5F,0x64,0x4F,0xAC,0xCC,0xA2,0xDC,0x63,0x42,0xA2,0x28,0xCE,0x35,0xB1,0xA0,0x3F,0xFB,
	0xEC,0xB5,0xCD,0x89,0x27,0x9E,0xCA,0xF3,0x9E,0x20,0x66,0x9E,0x20,0x95,0x40,0x8B,0xD9,0xAE,0xE0,0xB7,
	0xA2,0x03,0x44,0xFE,0xC6,0xB1,0xCA,0x41,0x35,0x9C,0x43,0x45,0xA4,0xF5,0x84,0x38,0xA2,0xA0,0xED,0x43,
	0xDD,0xFB,0x18,0x66,0xA0,0x11,0xF5,0xAA,0xFB,0xA4,0xAD,0xD6,0x89,0x95,0x76,0xC4,0x1E,0xA3,0x37,0x25,
	0xC1,0x05,0xCE,0x44,0xC0,0x0D,0x12,0x93,0x16,0x7D,0x0E,0xD5,0xDB,0xA9,0xA1,0x7A,0xC1,0x90,0x67,0xF3,
	0x1A,0x4B,0x1C,0x5B,0xE8,0xDA,0xA4,0x1C,0xE9,0xB1,0xE9,0x0A,0x86,0x9A,0x62,0x2D,0x4C,0x89,0x1E,0xBD,
	0x6A,0x02,0xD3,0x1A,0x54,0x71,0x40,0x06,0x56,0x33,0x0D,0x4F,0x11,0x3A,0x77,0xB2,0xD4,0xB3,0x0A,0xD5,
	0x51,0x17,0x4B,0x27,0xA5,0x2A,0xD5,0x12,0xD7,0x25,0xB7,0xB5,0xD5,0xD8,0x68,0x76,0x05,0x67,0x67,0x4E,
	0xCD,0x2C,0x86,0x04,0x01,0x4C,0xB4,0xDC,0x19,0x3D,0x18,0x4A,0xFF,0x15,0xF8,0x33,0x6A,0x08,0xB1,0x2A,
	0x33,0xDD,0x8A,0x6B,0xAD,0x46,0x87,0x65,0x4D,0xED,0x2E,0x0C,0x40,0x82,0xF9,0xF8,0x8F,0xFE,0x74,0x16,
	0x4A,0x7D,0x04,0x37,0x62,0x97,0x53,0xCD,0x96,0x93,0x67,0x9B,0xAA,0x1B,0x2B,0xF5,0xB2,0xEE,0xE3,0x02,
	0x8A,0xA0,0xD4,0xF4,0xB1,0xC8,0x2C,0x77,0xBF,0x08,0xC5,0x4C,0xA1,0x5F,0x83,0x0C,0xC7,0x42,0x0E,0x40,
	0x55,0xBF,0xE4,0x52,0xBF,0x0B,0x8E,0x13,0xB1,0x5E,0x4D,0xF7,0xB0,0x15,0x19,0xF5,0x6B,0xFE,0xC6,0xF7,
	0xA8,0x01,0x92,0xE8,0x08,0x7A,0xC0,0x67,0x38,0xC0,0xA2,0xA0,0x4A,0xE6,0xCB,0x84,0x93,0xB4,0xF0,0xC0,
	0x00,0xCB,0x8D,0x2A,0x07,0xB7,0xE4,0x6A,0x5C,0x82,0x41,0x0A,0x79,0xC2,0x34,0x71,0xF3,0x73,0xBD,0x54,
	0xAF,0xDD,0x6A,0x11,0x54,0xE5,0xC2,0x1A,0x8A,0x75,0x1B,0x1A,0x37,0x6D,0xD0,0x14,0x8C,0x88,0xA8,0xAD,
	0x01,0x1B,0xB3,0x87,0x6E,0xFD,0x91,0x99,0xE2,0xCE,0x59,0xAC,0x53,0x8A,0x97,0x5C,0x1D,0xDA,0x88,0x11,
	0x75,0x62,0x8C,0xA3,0x5C,0xCC,0x86,0x2E,0x8E,0xC0,0x36,0xD6,0x13,0x6F,0x0D,0x69,0xF0,0x48,0xE4,0x6A,
	0xB4,0x62,0x5A,0x71,0x00,0xD3,0xFA,0x08,0x8C,0xED,0x02,0x87,0x0F,0x97,0x8E,0xA1,0x92,0x8D,0xE5,0xB7,
	0xD8,0xAF,0x1F,0xBA,0x00,0x90,0xEC,0xAE,0x7D,0x2D,0xCF,0x2D,0x87,0x17,0x8E,0x86,0xB4,0xFC,0xAC,0x0A,
	0x9A,0x36,0x87,0xDB,0xDC,0x3A,0x2F,0xE1,0x15,0x63,0x60,0x90,0x9E,0xE8,0xA5,0xDB,0xBB,0xE9,0x2A,0xEB,
	0xAD,0x10,0x8E,0x0F,0x90,0x4E,0x0B,0x97,0x80,0xD5,0xE0,0x70,0x71,0xB5,0x30,0x42,0x50,0xBB,0x97,0x04,
	0xC8,0x40,0x85,0xA5,0xA6,0x2D,0x80,0x04,0xB7,0x69,0xF7,0x97,0x5A,0x1C,0x46,0x5C,0x6C,0x5C,0xDD,0xC2,
	0x2E,0xB5,0x8E,0x9A,0xBA,0x8A,0xA7,0xBA,0x48,0x85,0x2C,0x30,0x8C,0xB8,0x31,0x70,0x82,0x38,0xC8,0x82,
	0x60,0x53,0x22,0x7B,0x0E,0xC9,0x03,0x48,0x04,0xF8,0xB6,0xAF,0x59,0x75,0xD0,0x3C,0xBD,0x03,0x42,0x6D,
	0x60,0xB6,0x6E,0x85,0x60,0xB5,0x28,0x49,0x11,0xC2,0x04,0x87,0x24,0x45,0x81,0x47,0xDF,0xC8,0x18,0x41,
	0xE7,0xC4,0x09,0x63,0x09,0x64,0x16,0x02,0x08,0x3F,0x4D,0x59,0x46,0xBC,0xD6,0x99,0xE5,0xC0,0x6A,0xE1,
	0x3D,0x69,0x12,0x29,0x30,0xC9,0x06,0x98,0xF6,0x52,0xD5,0x80,0x1D,0xA3,0x0B,0xB4,0x3A,0xA8,0x42,0x25,
	0x74,0xB2,0xDC,0xB7,0xC8,0xC7,0x09,0xDA,0x52,0xD9,0x2B,0x83,0xDA,0x09,0x49,0x47,0xCE,0x15,0xD2,0x76,
	0x15,0x07,0xDA,0xCA,0xB4,0x46,0x95,0x10,0x15,0x85,0x76,0x24,0xA9,0x02,0xA7,0x64,0x81,0x72,0x15,0x9E,
	0xC9,0x63,0xE5,0x09,0x6E,0x76,0xB1,0x7B,0x1E,0x6B,0x03,0x0B,0x1E,0x5D,0xF7,0x3C,0x84,0x82,0x27,0x89,
	0xE4,0x19,0xE3,0x18,0x2B,0xDE,0xDB,0xBD,0xA0,0x53,0xC4,0x62,0xB0,0x49,0xD0,0x4B,0x30,0x54,0xE5,0x88,
	0xA2,0xB7,0x57,0xDB,0xAF,0xC4,0xC6,0xA9,0xA6,0xBB,0x5B,0x7C,0x13,0x2E,0x92,0x32,0xF0,0xAA,0x33,0x34,
	0x84,0x59,0x03,0x66,0x04,0xAA,0x30,0x41,0x65,0x94,0x30,0x03,0x1B,0x9C,0xB6,0x66,0x18,0x7E,0x7E,0xA9,
	0x70,0x41,0x0C,0x27,0x63,0x02,0x5E,0xD3,0x42,0x85,0x76,0x75,0x06,0xAC,0x08,0x5F,0x06,0x32,0xE1,0x3B,
	0x74,0xB1,0xA6,0x6C,0x2D,0xD5,0xBF,0x86,0x61,0x05,0x2B,0xB2,0xD2,0x58,0xBC,0xF9,0xF8,0x34,0x33,0x19,
	0x33,0xC7,0x85,0xD2,0x78,0xD3,0x28,0x87,0xCA,0x4F,0x48,0x27,0x9C,0x71,0x17,0xA0,0xF7,0xB3,0x73,0xF3,
	0xE7,0xB5,0x2B,0x2A,0x0E,0x38,0x87,0x45,0xAB,0xAB,0xCD,0xF5,0x87,0xB0,0x93,0xCE,0xE4,0x09,0x5B,0x04,
	0xA8,0x17,0xF8,0x8F,0xC1,0x6A,0x17,0x9A,0xE0,0xA8,0xBF,0xFB,0x8C,0xB8,0x2B,0x0E,0x08,0x65,0x04,0xF6,
	0x62,0x40,0xA5,0x9A,0x09,0x45,0x39,0x61,0xF7,0x6E,0x5B,0x89,0x92,0x52,0x3A,0x41,0xEF,0x5B,0x86,0xCF,
	0xA1,0xAF,0x27,0xD7,0x85,0x93,0xB2,0x37,0xB2,0x48,0x56,0x11,0x56,0x5E,0xFF,0x89,0x86,0x2F,0xBA,0x9B,
	0xF3,0xAF,0xB4,0xB1,0x4E,0x88,0x47,0xC3,0x68,0xD0,0x40,0x13,0xFA,0xB3,0x7F,0x34,0x0C,0xF1,0x7B,0x3D,
	0x8C,0xCE,0xA3,0x51,0xAE,0xA0,0x64,0x2A,0x18,0x04,0xE0,0x52,0xEE,0xF9,0x62,0xF3,0xFC,0xB9,0x17,0x47,
	0x89,0x54,0x89,0x61,0x00,0x3D,0xE1,0xE4,0x91,0xC1,0x67,0x12,0x99,0x51,0x02,0x33,0x59,0x70,0x6C,0x44,
	0xB5,0x70,0x16,0x02,0x12,0x3D,0x11,0x78,0xF1,0xDE,0xF2,0x7B,0xF3,0x87,0xF6,0xB3,0x8E,0x53,0xA0,0x62,
	0xA4,0x58,0xDD,0x54,0x47,0xE2,0xF1,0x92,0x18,0x3A,0x86,0x56,0xD6,0x0F,0x48,0x61,0x05,0xD5,0x77,0x52,
	0x58,0xA8,0xDB,0x32,0xAB,0x41,0x4D,0x3D,0x8B,0xE9,0xC0,0xDA,0x6C,0x5A,0x99,0x09,0x90,0xCE,0xA6,0x6A,
	0xD0,0x5C,0xE1,0x4C,0xBC,0x00,0x74,0x50,0x63,0xE8,0x24,0xBB,0xE1,0xBD,0x50,0x43,0xCE,0x74,0xB5,0x83,
	0x9D,0x76,0xBC,0x5B,0xC8,0xF1,0x03,0xA5,0xE5,0x2D,0xC3,0x89,0x2E,0xCA,0x8C,0x53,0xB8,0xC2,0x10,0xC3,
	0xB8,0x09,0xD5,0x96,0x7C,0xD7,0x78,0xDE,0x4D,0x13,0xF2,0x40,0x68,0x1C,0x27,0x9F,0x07,0x67,0xF8,0x04,
	0xAA,0x9C,0x7D,0xD9,0x2D,0x28,0x1D,0x4D,0xB5,0x83,0x73,0x1E,0x4D,0xD4,0xAF,0x5B,0x40,0xDB,0x8D,0x04,
	0x6C,0x61,0xC8,0x92,0x4A,0xCB,0x87,0x45,0x3D,0xCB,0x67,0xF7,0x2D,0x2E,0x61,0x3A,0x4A,0xC0,0x98,0xF4,
	0xD1,0x20,0xB9,0x52,0xDE,0xC3,0x91,0x4D,0x36,0xCE,0x27,0xEA,0x2D,0x1D,0x51,0x7B,0x1C,0x49,0x84,0x0E,
	0xE4,0x85,0x56,0xFE,0x48,0x4B,0xD1,0x23,0x6D,0xBB,0x78,0x0F,0x7F,0x20,0xF1,0x6A,0x02,0xFB,0xB8,0x93,
	0xD5,0xD8,0x2E,0xE8,0x20,0x21,0xA6,0x91,0x21,0xE0,0x7B,0xBA,0x68,0x28,0xED,0xFD,0xFE,0x1E,0x1F,0x43,
	0x9A,0x2D,0x97,0x5F,0x08,0x16,0xA8,0x9C,0xD6,0xE5,0xA0,0x8A,0x36,0xB0,0x9E,0xE6,0xC8,0x90,0xA0,0x8A,
	0x5C,0xAA,0x89,0x03,0xC0,0x20,0x54,0xA2,0x2D,0x65,0x53,0x40,0x9D,0xC3,0x8D,0x4C,0xA0,0xCF,0x8A,0xCA,
	0x15,0x42,0xE6,0xA6,0xC7,0x75,0xB7,0xB4,0x29,0xEF,0x18,0xBD,0x1C,0xF5,0x8B,0xB9,0x09,0xD7,0x87,0x55,
	0xA5,0xDA,0xD1,0xDC,0x85,0x81,0x3F,0xB6,0x16,0xB8,0x17,0x2B,0x85,0x4A,0x59,0x99,0x46,0x6E,0x27,0x85,
	0x2E,0xC5,0x62,0x76,0x3C,0x50,0xA3,0xC8,0xBB,0x66,0x00,0x43,0x37,0x7A,0xBA,0x3A,0x13,0xE2,0x56,0xE4,
	0xCC,0x1B,0xB9,0x1E,0xB3,0x95,0x79,0xBF,0x4B,0xE1,0x22,0x6B,0x22,0x07,0x60,0xBD,0x28,0x28,0xC1,0x16,
	0x4C,0xC8,0xA4,0x60,0x31,0xA6,0xCD,0x01,0x1B,0x02,0xE9,0x1C,0xDE,0x53,0x0C,0xC4,0xE7,0x8D,0x87,0x1F,
	0xDA,0x65,0x07,0x89,0x7C,0x4A,0x5D,0x8F,0xA1,0x0E,0x57,0xDC,0x27,0xDB,0x0B,0x7E,0xDB,0x42,0x1C,0x17,
	0x61,0x03,0x33,0x01,0xF9,0x6B,0x29,0x46,0x18,0xE5,0xFB,0x13,0x28,0x56,0x9D,0xAA,0x19,0xCB,0x07,0x20,
	0x13,0xC4,0xD2,0xB9,0x42,0x62,0x04,0x43,0xD7,0x88,0x5E,0x80,0xD0,0xC9,0xD9,0x65,0xDB,0x73,0xAF,0xF5,
	0xC3,0x09,0xEF,0xE8,0xD6,0xC6,0x1D,0x47,0xB2,0xAF,0xB5,0xA5,0xEA,0x54,0x9B,0x82,0x72,0xCF,0x9F,0x96,
	0xEE,0xB7,0xBB,0xE6,0xD5,0xFC,0x12,0x05,0x90,0xB5,0x51,0x8B,0xB9,0x5E,0x61,0x55,0x4D,0x3F,0x5F,0x7B,
	0xCA,0x7D,0x2F,0xA8,0xF7,0xB8,0x04,0x03,0x86,0x8B,0xE1,0x8F,0xD6,0xA5,0x0B,0xDC,0xA7,0x86,0xF6,0xD7,
	0x5A,0x0B,0x97,0xFF,0xF4,0x55,0xF1,0xBD,0x9E,0xD4,0x14,0x54,0xBE,0x5B,0x4E,0x02,0x96,0x54,0x53,0x12,
	0xDA,0xD5,0x35,0x85,0x32,0xD3,0x4B,0x19,0xCE,0xCA,0xE2,0x92,0x4C,0x19,0x39,0xAE,0x14,0xA1,0x7E,0x2A,
	0x32,0x65,0x6E,0xEC,0x1D,0x65,0x1F,0x23,0x1C,0x97,0x65,0x50,0xCE,0xEE,0x11,0x17,0xCB,0xC3,0x08,0xEF,
	0x5A,0x3A,0x77,0x50,0xA9,0x3D,0xE5,0x29,0x90,0x41,0xB5,0x8B,0x06,0x16,0xE3,0x81,0xBA,0xD3,0x71,0xCA,
	0x1C,0x1A,0xF9,0xC1,0xA0,0x4C,0xFB,0x51,0xDA,0xEE,0x56,0x99,0xD1,0x0A,0xA3,0x46,0xEF,0xD8,0x08,0xC8,
	0x4D,0x25,0xED,0xEC,0x90,0xD1,0x01,0xAF,0x7E,0x55,0x96,0x8F,0x9B,0x98,0x50,0x72,0x67,0x84,0xB1,0xB8,
	0x12,0xD1,0x91,0xA9,0xE7,0x9A,0x3D,0x17,0x98,0x2A,0xC0,0x80,0xE5,0x16,0x65,0x1B,0xA5,0xE2,0xEC,0xD6,
	0x24,0x34,0x6A,0x97,0x83,0x05,0xB8,0x6E,0xC0,0x91,0x7F,0x60,0xFA,0x02,0xC0,0x9F,0xA8,0x09,0x76,0x0A,
	0x6E,0x44,0x6B,0x20,0x67,0x93,0xBD,0xFE,0xAB,0xFC,0x24,0x75,0x49,0x24,0x08,0x03,0x31,0x72,0x70,0xED,
	0xAC,0x6E,0xE8,0xAC,0x6B,0x18,0x90,0x1F,0xA7,0x13,0x81,0x89,0x64,0x7B,0x96,0xDD,0x84,0xA3,0x78,0xEB,
	0x45,0xAA,0x38,0x56,0x9A,0xBA,0x7D,0x34,0x95,0x63,0x08,0x51,0x64,0x76,0xB1,0x63,0x73,0x84,0xCC,0x45,
	0x42,0x38,0xD0,0x08,0x0D,0x10,0x86,0xE8,0xA6,0xFC,0x76,0xAA,0x92,0xE5,0x5E,0x72,0x4E,0xE2,0xB4,0xF2,
	0xA7,0x6F,0x15,0x74,0xB8,0x1C,0xBD,0xBB,0xF8,0x85,0xFC,0x83,0x41,0xAF,0x86,0x9B,0x14,0xD6,0x05,0x1F,
	0xDF,0xC9,0x4E,0x0C,0xBA,0x06,0x89,0x1D,0x10,0xE0,0xA2,0x4A,0x04,0x9F,0x53,0xF0,0x37,0x45,0x16,0x15,
	0x16,0x93,0x7C,0xA3,0x0E,0xD5,0xBD,0x23,0xE9,0x94,0x73,0x04,0x64,0x00,0xF7,0x86,0xB5,0x0C,0x40,0x0C,
	0x1A,0x17,0x96,0xD9,0x12,0x62,0xAC,0x3E,0x2C,0x61,0x86,0x95,0x70,0x5F,0x94,0xB6,0x01,0x5A,0x4A,0x57,
	0xDC,0xB1,0x66,0x26,0xA5,0x52,0x61,0x5D,0xFC,0xB4,0x34,0x51,0xAC,0x5E,0xD9,0xD1,0x66,0xE1,0x07,0xCE,
	0x73,0xBA,0x04,0x7D,0x19,0x85,0xDA,0xDA,0x60,0x57,0x97,0x70,0xFA,0x22,0xDD,0x63,0xBF,0x23,0xA3,0x87,
	0xD0,0x35,0xA8,0x5C,0x49,0x25,0x5C,0x15,0xB6,0x06,0x32,0xC0,0xBF,0xD6,0x2C,0xB2,0x84,0x37,0x65,0xF0,
	0xA5,0x0C,0x5F,0xF0,0x3F,0x71,0x77,0x9E,0x38,0xAA,0xE0,0x68,0xDE,0x11,0x18,0x4B,0xC9,0x49,0x1D,0xC6,
	0xE0,0x9A,0xD2,0x74,0x3C,0xBB,0x1F,0xBE,0x0B,0x0C,0x51,0x41,0x35,0x36,0xEE,0xDD,0x8D,0xCB,0xE5,0x48,
	0x9A,0x2C,0x98,0x3A,0x82,0x78,0xE8,0xC8,0x82,0xA2,0x6B,0x4A,0xDD,0x2D,0x92,0xD8,0xA0,0x8F,0xBF,0x02,
	0x91,0x15,0x28,0x47,0xB3,0x16,0x8F,0x1C,0xEB,0x8B,0x16,0xBA,0x5D,0xE4,0xC2,0xD9,0x36,0x1F,0x4A,0x4D,
	0xA7,0xDC,0xC8,0x01,0xB7,0x24,0x6A,0xA4,0xB9,0x5A,0xA0,0xA2,0x16,0xDB,0xB8,0x55,0x68,0x2D,0xD2,0x66,
	0x7F,0x02,0x93,0x79,0x27,0xEE,0x46,0x11,0xF6,0xEE,0xDB,0xB4,0x7D,0x6D,0x40,0x43,0x68,0xF6,0x0A,0x2E,
	0x4C,0xBD,0x5A,0x15,0xE3,0x1A,0x64,0xCC,0x25,0x46,0xD5,0x0E,0x3D,0x03,0xE2,0x25,0x6C,0xEC,0x87,0x62,
	0xB9,0xE5,0x31,0x18,0x97,0x0C,0x23,0x0C,0xC6,0xF9,0xF9,0xF5,0xE8,0xD5,0x8D,0x89,0xF8,0xBA,0xDB,0x85,
	0xB2,0xBC,0x5B,0xAD,0x2A,0x9A,0x9A,0xF0,0x2D,0xAB,0x29,0x5A,0x96,0x60,0xAC,0xD8,0xF3,0xE9,0xDE,0x34,
	0x4E,0x5D,0x65,0xF5,0x79,0x7F,0xB2,0xB0,0xA8,0x39,0xB3,0xC3,0xC0,0x9F,0xC8,0x0A,0x78,0x30,0x41,0xBC,
	0x0B,0xC2,0xAE,0x5A,0x1B,0x69,0xC4,0xDF,0xBE,0x83,0x81,0x14,0xDA,0x82,0x00,0x1E,0xD4,0xBB,0xA8,0x0A,
	0xB4,0xBC,0xCE,0x0C,0x0D,0xAF,0xFE,0xCD,0xFE,0xBB,0xDE,0xAF,0xE7,0x8C,0x6C,0x70,0xF5,0x80,0x39,0xF5,
	0x7B,0xC3,0xC6,0x41,0x91,0x77,0xEF,0x18,0x48,0xA9,0xCE,0x0F,0xCC,0x53,0xD5,0x1A,0x74,0x51,0xAD,0x11,
	0x0D,0xE4,0xC7,0xF9,0xF9,0xA7,0x46,0x7C,0x22,0xE5,0xAC,0x7B,0xD9,0xE6,0x17,0x8A,0x88,0xE5,0x41,0x7B,
	0xAA,0x32,0x6F,0xD7,0x22,0x9A,0xA8,0x4A,0x08,0x0F,0x9A,0x7F,0x5B,0x18,0x03,0xCC,0x5C,0xFE,0x41,0x8E,
	0xB8,0xE9,0x60,0x49,0x48,0x18,0x4E,0x18,0xE4,0x18,0xFD,0x68,0x57,0xE5,0x00,0x3D,0xD0,0x9A,0xF0,0xFC,
	0x89,0x61,0x64,0xDA,0x50,0x9E,0x7C,0xAD,0xF0,0xFB,0x8B,0x60,0xCB,0x10,0xF1,0x60,0xB4,0xC6,0x4A,0x2D,
	0xEE,0x0D,0x11,0xCA,0xB9,0x61,0xC8,0x88,0x45,0xD8,0xB4,0x38,0x19,0xFA,0x54,0x3E,0x5C,0xA9,0xC5,0x51,
	0x06,0x05,0x47,0xC9,0x88,0x5B,0x7E,0x7E,0x5E,0x60,0x57,0x9F,0x5A,0xA4,0x3D,0xB5,0xFE,0xD0,0x98,0xA5,
	0xAA,0xA1,0x90,0x6E,0x9F,0xB7,0x61,0xB0,0x09,0x8D,0x1D,0xA6,0xD2,0x22,0x94,0x10,0xF2,0x26,0x18,0x13,
	0xFC,0x21,0xB2,0xAD,0x29,0x48,0x75,0x6C,0x90,0x8C,0x88,0x66,0x7F,0x2F,0xC5,0x15,0x8D,0xBD,0xE7,0xA0,
	0x9C,0x62,0x15,0xE4,0x14,0x5A,0x4B,0x1E,0x5C,0xDA,0x09,0xC6,0xA0,0x60,0xFA,0x72,0xEA,0xA5,0x42,0x26,
	0x26,0x55,0x7B,0x2B,0x20,0x74,0xD5,0x3D,0x87,0x94,0x92,0x35,0x72,0x9C,0x0E,0x4D,0xDB,0x69,0xD0,0xEF,
	0x97,0xDE,0xCF,0x93,0x2A,0x56,0x9F,0x00,0xEF,0xCF,0xA2,0xDA,0xC4,0xE7,0xFA,0xA1,0x9A,0xCE,0xBF,0xFF,
	0x6F,0x0D,0xC5,0xB0,0x09,0x16,0x07,0x26,0xA0,0x88,0x96,0xC6,0xE7,0x25,0x85,0xF3,0xB6,0x20,0xA6,0xC4,
	0xDB,0xA7,0xAD,0x91,0x0E,0xA0,0x38,0x8F,0x8B,0x64,0x85,0x85,0x28,0x3D,0xA6,0xEA,0xCD,0x92,0x92,0x58,
	0x14,0x86,0xAB,0x32,0x82,0xAC,0xA4,0x4A,0x8D,0xCA,0x84,0x74,0x30,0x69,0x92,0xBF,0x29,0x67,0x57,0x3E,
	0x45,0x8C,0x30,0xF4,0x81,0xEB,0x1F,0xCD,0x58,0xBA,0x54,0x29,0xB1,0xE3,0xD4,0xAC,0xCA,0x08,0xFA,0xC6,
	0xE0,0x0E,0x37,0xA0,0x26,0xEB,0x55,0x21,0x2D,0x58,0xCA,0x14,0x7F,0x27,0xCB,0x2F,0x58,0x06,0xD4,0xEC,
	0x85,0x24,0x24,0x5F,0xBD,0xE5,0xB8,0x62,0xEA,0xF1,0xD4,0x60,0x33,0x7F,0x2F,0xA9,0xA4,0x30,0xE5,0x50,
	0xE9,0xE7,0x21,0x54,0xD0,0x97,0x9A,0x57,0xFE,0x19,0x44,0x03,0xE0,0x4D,0x4A,0xD8,0x91,0x48,0x15,0x33,
	0x27,0xE5,0x1F,0xCC,0x9F,0x79,0x21,0x09,0x67,0x6A,0x71,0x20,0xD0,0x98,0x08,0x76,0xA1,0xEF,0xA7,0x75,
	0x56,0xD2,0x1E,0x80,0x72,0x18,0x5A,0xD2,0xEC,0xDB,0x74,0x9D,0xC4,0xC1,0xD1,0xD2,0x14,0x86,0xAC,0x52,
	0xD0,0x42,0x18,0x1E,0x21,0xF5,0xE0,0xE7,0x03,0x11,0x5C,0x42,0x85,0xB7,0x81,0xBD,0xC4,0xB0,0xF8,0x2B,
	0xB1,0xB3,0x1E,0xA7,0x13,0x8D,0x9E,0x59,0x66,0x2C,0x6A,0x94,0x50,0x67,0xA1,0x27,0xF5,0x5F,0x47,0x8D,
	0x65,0x71,0x00,0xA5,0x40,0x38,0x39,0x53,0x41,0x73,0x15,0x73,0xCE,0x9E,0x33,0xA8,0x5D,0x8B,0x7F,0x54,
	0x30,0xA5,0x6E,0x74,0xF2,0x0A,0x11,0x42,0xCF,0x41,0x96,0x24,0xDA,0xE3,0x31,0xAC,0xBE,0x2D,0x5B,0xDA,
	0xA9,0x0D,0xD0,0x7A,0xD0,0x13,0x06,0xAC,0xD5,0xE3,0x97,0x16,0x15,0xDA,0xD9,0x58,0x57,0xC1,0x03,0x49,
	0x03,0x83,0x44,0x29,0xC7,0xB9,0xFA,0x8A,0x43,0x64,0x92,0x26,0xFF,0x77,0xFC,0x70,0x62,0xB1,0x61,0x59,
	0x76,0x7A,0x15,0x49,0xB7,0x45,0xAD,0x35,0x44,0x61,0xB7,0x57,0x88,0x5E,0x94,0xB1,0x77,0xAA,0xC0,0x52,
	0x1D,0xB3,0x93,0x25,0x16,0xAD,0xB2,0x60,0x80,0x01,0xAA,0xC0,0x1E,0xCB,0xA8,0x24,0x49,0x92,0x94,0x91,
	0x8A,0xEB,0xB0,0x8D,0x16,0x88,0x49,0x92,0x8E,0xAF,0xA8,0x35,0xD6,0x82,0x19,0x4C,0xEC,0x3D,0x92,0x24,
	0x04,0x32,0x33,0xC9,0x32,0x11,0x3E,0x20,0x49,0x3F,0x28,0x21,0x2B,0xF8,0xB4,0x2A,0xB3,0x03,0xAE,0xD7,
	0x42,0xB0,0x39,0x3A,0xFE,0xA9,0x09,0x75,0xC7,0x4B,0x26,0x5D,0xC4,0xB6,0x7A,0x1F,0x78,0xCA,0x1C,0x4A,
	0x0C,0xAA,0x5B,0x3F,0x45,0x6B,0x18,0x35,0xF8,0xD7,0x91,0x82,0x45,0x93,0xAE,0x0B,0xC5,0x62,0xCE,0x3D,
	0x26,0xCD,0x66,0x45,0xA0,0xA4,0xE5,0x54,0x18,0xFC,0xFF,0x73,0x23,0x12,0xCC,0xB1,0xD6,0x18,0x16,0x12,
	0xAC,0xA7,0xEA,0x9E,0x91,0xCA,0x99,0xBF,0x50,0x07,0x9E,0x22,0x00,0x80,0x5A,0x93,0x1A,0x4F,0x0D,0x9F,
	0x6B,0x1D,0xAD,0xC0,0x87,0x64,0x55,0xD9,0xCB,0x76,0x40,0x59,0xD3,0xBC,0xED,0x3D,0x7F,0x0B,0x8A,0xEB,
	0x2C,0x5D,0xA4,0x09,0x12,0x07,0xAB,0xE6,0x85,0xF3,0x6A,0xAF,0x54,0x58,0xF2,0x14,0x24,0xE7,0xB2,0x1C,
	0xD8,0x90,0x13,0x64,0x90,0x68,0xB2,0x6B,0x06,0x84,0xB2,0xE5,0x78,0x3B,0x7D,0xE5,0x61,0x81,0x7E,0x14,
	0x28,0x71,0x1C,0x10,0xD0,0x89,0x1C,0x71,0xDF,0x48,0x15,0x47,0xF8,0x58,0xE6,0x53,0x53,0x1A,0xD0,0x87,
	0x2F,0x4D,0xFF,0x44,0x05,0x44,0xC3,0x70,0x03,0xFD,0x0E,0xBF,0x71,0xC2,0x46,0xB4,0xF5,0xB7,0x9B,0x3A,
	0xF0,0x6F,0xDE,0x22,0xED,0x2A,0x6A,0x4F,0x18,0x39,0x7B,0x74,0xAC,0xA8,0x56,0xB8,0x52,0xAE,0x6E,0x5E,
	0x81,0x02,0x24,0x5A,0x66,0x03,0x9A,0x90,0x5F,0xC1,0x3F,0x95,0x0F,0x71,0x63,0x20,0x03,0x96,0x7D,0xB4,
	0xA8,0xA9,0xA4,0xBA,0xA8,0xE0,0xEA,0xAA,0xD3,0x86,0xCA,0xB8,0xCC,0x92,0xE5,0x25,0xEE,0xE8,0xDF,0x1E,
	0x3E,0xDE,0x14,0x24,0x61,0xC0,0xD4,0xDC,0x14,0x56,0x1C,0xD2,0x59,0xC9,0x31,0xBC,0x94,0x7A,0x11,0x06,
	0xC9,0x46,0xCB,0x46,0xC9,0x8F,0xCE,0xBF,0x2C,0x8F,0xB7,0x3D,0x0C,0x86,0x8C,0xE1,0x46,0xF0,0xF3,0xA4,
	0xA2,0xBD,0x70,0x19,0x43,0xE3,0x16,0x2A,0x22,0xE8,0x9B,0x61,0xF1,0x98,0x66,0xE8,0x6D,0x9A,0x09,0x1A,
	0x8C,0x1F,0x36,0x8D,0x03,0x03,0x5B,0x62,0xA3,0x3A,0x80,0xBC,0x64,0x51,0xC7,0xFD,0xFD,0xFB,0xFF,0x61,
	0x50,0x9C,0x81,0x99,0x6C,0x94,0x3B,0x10,0x58,0x02,0xDC,0x35,0xA0,0x5D,0x59,0xBD,0x74,0xF0,0xEB,0x18,
	0xD8,0x34,0x4D,0xB8,0x9C,0x7B,0x01,0x65,0x60,0x35,0x96,0x7A,0xAC,0x9E,0x16,0x81,0x31,0x7F,0x74,0x86,
	0xF2,0x56,0xE2,0x00,0xEE,0x5E,0x8A,0xC5,0x22,0x97,0x14,0x29,0x78,0xA2,0x8E,0xAD,0x25,0x82,0x94,0xCC,
	0x1B,0x93,0x13,0x8B,0xF5,0x48,0x76,0xCA,0xC4,0xC0,0x69,0xE6,0x93,0x78,0xCC,0xF7,0x22,0xE4,0x5B,0x2C,
	0x54,0xBF,0x5A,0x20,0x97,0x0D,0x90,0xDC,0x50,0xA5,0xF6,0xBA,0x88,0xC1,0x12,0xC6,0xFD,0x55,0xCC,0xB2,
	0xCB,0xB3,0x83,0xD4,0x8B,0xFC,0x81,0xC6,0xA3,0x66,0x8C,0x98,0x9D,0xA3,0x25,0xA1,0x72,0xB3,0xB2,0x9A,
	0x2E,0xA8,0x75,0x01,0x88,0x3C,0xD9,0x79,0x0C,0x08,0x9D,0x8B,0x5D,0x00,0x0A,0x50,0x74,0xAF,0x09,0x59,
	0xF1,0x71,0x29,0x58,0xDA,0x64,0x48,0x5D,0x7E,0x8D,0x47,0x43,0x14,0xD7,0xC3,0x3C,0xB9,0x0C,0x14,0x30,
	0x16,0xB8,0x70,0xE5,0x3B,0x45,0x63,0x59,0xB9,0xA2,0x08,0x64,0x93,0x85,0x14,0x57,0x80,0x6B,0x1B,0x74,
	0x14,0x21,0x53,0x23,0xAF,0x96,0x83,0x14,0x15,0xC9,0x02,0x05,0x20,0xB8,0x1A,0x1C,0x91,0xBA,0xD4,0x61,
	0x45,0x01,0xD5,0x85,0xE9,0x6F,0x64,0x3C,0x78,0x4A,0x56,0x2D,0x99,0xCB,0x93,0x5B,0xD6,0x86,0xEF,0x20,
	0x02,0x93,0x32,0xF7,0x43,0x65,0x5A,0xD9,0x28,0x82,0x32,0xFB,0x1F,0x33,0x5D,0x7F,0xF6,0xA9,0x23,0xA8,
	0xE7,0xC0,0x08,0x64,0x0A,0xB7,0xA3,0x7E,0xDD,0x2E,0xE2,0xBF,0xDC,0xEB,0xF0,0x92,0x34,0x54,0x4E,0x77,
	0x9D,0xCC,0x76,0x03,0x04,0x70,0x15,0xFB,0x9B,0x6D,0x05,0x4D,0x99,0xDC,0x58,0x04,0x03,0x64,0x03,0x69,
	0x7F,0xA3,0x69,0x83,0x93,0x71,0xBE,0xB8,0xA5,0x3A,0x0A,0xD4,0xCA,0x55,0xCD,0x3B,0x46,0x1E,0xC9,0x27,
	0x0B,0xC6,0xFD,0x5F,0x58,0x48,0x13,0x3D,0x34,0x10,0xB4,0xAE,0x10,0xAE,0x42,0x26,0x7C,0x4A,0x91,0x45,
	0x46,0x4A,0x8F,0x82,0x54,0x0B,0x8C,0x14,0x00,0x20,0x15,0xD5,0x37,0xEE,0x31,0xFE,0xC7,0x10,0x90,0x7E,
	0xAA,0xAC,0x9B,0xF0,0x24,0x56,0xA2,0x42,0x19,0x33,0x89,0x2B,0x0A,0xDA,0x68,0xC4,0x39,0x34,0xF2,0x1F,
	0x87,0x30,0x2C,0x06,0xBA,0xD3,0x08,0xBD,0xC7,0x90,0x30,0x73,0x18,0x3B,0xF9,0x7F,0xC8,0xA6,0x7D,0x51,
	0x67,0xCD,0x36,0x61,0x00,0xAB,0x7D,0xB8,0x9C,0x0A,0x0F,0x24,0xC9,0x9E,0xCD,0x20,0x0F,0x18,0x69,0x17,
	0x64,0xCC,0xC5,0x06,0x82,0xC2,0xF4,0xD0,0x0D,0xEC,0xFC,0xAD,0x0B,0x7E,0x0B,0x30,0x53,0xDE,0x5A,0x8B,
	0xD7,0x9C,0xAD,0x13,0x07,0x23,0xB5,0x65,0xED,0x77,0xD5,0x36,0x58,0x25,0x2A,0x7A,0xB2,0x9A,0x8E,0x4D,
	0xD7,0x3B,0xA8,0xF2,0xB8,0x22,0x69,0xD4,0x28,0xA7,0x4F,0x0C,0x1E,0x52,0x55,0x24,0x55,0x20,0x27,0xDA,
	0x0D,0x27,0xA3,0x53,0x5C,0x7C,0xA1,0x1B,0xD3,0xBA,0x22,0x65,0x5B,0x30,0x6D,0x15,0x20,0xED,0x21,0xAD,
	0x32,0x9C,0x52,0xA6,0xD1,0x75,0x60,0x6D,0x2F,0x9C,0x1E,0xBD,0xC0,0x8B,0x3C,0xD5,0x44,0xD5,0x16,0x2C,
	0x14,0xF4,0x4C,0x76,0xDC,0x3A,0x71,0xF0,0xC6,0xD6,0xE7,0x01,0xC2,0xD8,0x40,0xE4,0xF0,0x94,0xE5,0x8F,
	0x4C,0x36,0x56,0x02,0x96,0x8D,0xDE,0xD4,0x65,0x44,0x70,0x31,0xDA,0x91,0x08,0x57,0x90,0x18,0x92,0xC8,
	0x89,0x31,0xE1,0x82,0x51,0x11,0x6D,0x6B,0xED,0xBE,0x92,0xBB,0x07,0x2D,0xEE,0x2E,0xEA,0x8B,0x99,0xEC,
	0xDE,0x88,0xA3,0x52,0xA3,0x19,0x00,0x16,0xC7,0x2A,0x6B,0x88,0xDD,0xA0,0x8B,0xE6,0x76,0xB7,0x90,0x17,
	0x93,0xF9,0xA6,0x97,0x66,0x8C,0x98,0x16,0x3D,0x8A,0x54,0x02,0xBD,0xB5,0xF1,0xC4,0xEF,0xB3,0x3F,0x98,
	0xCE,0xBC,0x26,0xEA,0xE3,0x2D,0x01,0xA7,0x3B,0x4B,0xE9,0xF4,0x06,0x16,0xD2,0xF0,0xBB,0x12,0x58,0xBC,
	0x3C,0x75,0x09,0x0E,0xDE,0x6A,0x70,0xF6,0x21,0x10,0xB1,0x07,0x08,0x7B,0xA5,0xFC,0x27,0xFB,0x7D,0x5D,
	0x38,0x1E,0xF4,0x51,0x28,0x82,0xB7,0xE1,0x58,0x56,0x6A,0xBA,0xF4,0xA1,0x46,0x18,0x05,0x50,0x0B,0x56,
	0x7E,0x76,0x6D,0x0A,0x52,0xC5,0x4B,0x59,0xAD,0xD2,0xAD,0x6A,0x08,0xCF,0x1A,0x83,0xBD,0x35,0x19,0xF0,
	0x7A,0x0A,0xEE,0x11,0x7B,0x68,0xB1,0x04,0xAB,0x49,0x7C,0xB2,0x18,0xC2,0xF5,0xE3,0xD8,0x66,0x07,0xDC,
	0x7D,0x16,0xF9,0x2D,0x2D,0x1A,0xB9,0x4E,0xB2,0xE3,0x9E,0xF7,0x19,0xC1,0xD0,0x26,0xEE,0x2A,0xD1,0x0A,
	0x8C,0x2B,0x19,0x91,0xEE,0xE9,0x04,0xA2,0x16,0xE7,0x82,0x6F,0xF6,0xA6,0x52,0x2E,0x4A,0xAE,0x82,0x5B,
	0x2C,0xD2,0x8B,0xAE,0x87,0xF8,0xCC,0x6D,0x71,0xC5,0x0D,0xDE,0x32,0x8B,0xCC,0x26,0x9F,0xCC,0x80,0x5F,
	0x64,0x07,0x72,0xB1,0x41,0xA1,0x24,0x03,0xED,0x65,0x57,0x98,0x2A,0x00,0x1A,0xAF,0xF2,0x89,0x0B,0x65,
	0x15,0xF9,0x69,0x16,0xE6,0x77,0x5C,0x82,0x01,0x90,0xA9,0x6B,0x2D,0xE3,0xB7,0x1B,0x8C,0xE9,0xA6,0x0B,
	0xE1,0x72,0x7F,0xE4,0xA3,0xB0,0xA9,0x02,0xD2,0x7D,0xBC,0x48,0x05,0x0D,0x43,0xF0,0xB5,0xDE,0x54,0xF9,
	0xB5,0x50,0x2E,0x2A,0x82,0xC3,0xBE,0x06,0x12,0x90,0x1C,0x19,0x3C,0x6A,0x43,0x76,0xFD,0x2D,0x88,0x67,
	0x17,0x50,0x8D,0xF3,0xC6,0x3A,0xA8,0x81,0x64,0x45,0xC2,0xA1,0x60,0x71,0xDB,0x2E,0xE8,0x97,0xE0,0xAE,
	0x4F,0x16,0x92,0xF7,0x5A,0x8C,0xDC,0x09,0xED,0x29,0xFD,0x18,0xF6,0xA4,0xE1,0xF7,0xBE,0x86,0x00,0x3A,
	0x1D,0xED,0xE8,0x43,0x97,0x5C,0x31,0x18,0xC8,0x30,0x57,0x86,0xBA,0x3F,0x88,0x4D,0x62,0x01,0x62,0x75,
	0xAF,0x95,0x6C,0xD1,0xAE,0x8E,0x93,0xB4,0x31,0xC3,0x56,0x30,0xF7,0x52,0xD2,0xB8,0x66,0x54,0xDA,0xBA,
	0xD0,0x8C,0x85,0xE8,0xA0,0x48,0x92,0x47,0xD5,0x8F,0x42,0x0B,0x99,0x49,0x49,0xC3,0x0A,0x70,0x51,0x30,
	0x1A,0x79,0x37,0x7B,0x9A,0x77,0xC9,0xB4,0x97,0x68,0x71,0x2D,0x3E,0x5C,0x52,0x5F,0x56,0xA1,0x2F,0x59,
	0x72,0x2F,0x54,0x15,0xB9,0x6E,0x13,0x10,0x91,0x75,0x33,0xA6,0x52,0x12,0x33,0xAF,0x93,0xF2,0x46,0x55,
	0x03,0xA5,0xAD,0xE7,0x5A,0x70,0xC5,0x14,0x7C,0x62,0x6B,0x29,0x67,0x6C,0x10,0x95,0xC1,0xC6,0xE0,0x85,
	0x6B,0x6F,0x11,0x5F,0xF9,0x47,0x23,0x94,0xB2,0xFB,0xF9,0x9A,0x8B,0x68,0xD4,0xAB,0x16,0xD4,0x0F,0x34,
	0x3F,0x0E,0xC5,0x36,0x85,0x1F,0x95,0xBD,0x2A,0x0B,0xB5,0x7E,0x29,0x79,0x95,0x56,0x00,0xAF,0xC7,0xFE,
	0x41,0xA1,0xD4,0x29,0x81,0x59,0x21,0x80,0xA1,0x82,0x76,0x31,0xC3,0x34,0xC1,0x32,0x65,0x69,0xE8,0x0A,
	0x87,0xF6,0xC6,0x24,0x2E,0x2F,0xBC,0xD8,0x84,0xA4,0xCA,0xDF,0x0A,0xAE,0xE3,0x81,0x03,0x74,0x64,0x05,
	0xAF,0x28,0x9E,0x27,0xFC,0xFE,0xAC,0x54,0xE7,0x80,0x10,0x50,0x92,0xC3,0x2D,0xD9,0x03,0xCB,0xDD,0x29,
	0xDA,0x89,0x80,0xE1,0x0A,0xC1,0x00,0x39,0x30,0xF6,0x31,0xF8,0x7A,0xAA,0x2C,0x67,0x1E,0x93,0x8C,0x63,
	0xED,0x2C,0xBC,0x72,0xC3,0x40,0x28,0x6E,0xD6,0x16,0x4D,0xD9,0x40,0x94,0x1A,0x79,0x20,0x5A,0xA0,0x6A,
	0x23,0x48,0x28,0xE4,0x83,0xBF,0x6B,0x95,0x07,0x40,0x1F,0x03,0xA5,0x48,0x35,0x4F,0x31,0x0F,0x40,0x35,
	0x5A,0x28,0xC5,0x84,0x6A,0x85,0x56,0xF1,0xF3,0x37,0x38,0x07,0x0A,0x8E,0xE8,0xE9,0xBB,0x55,0x7B,0xEE,
	0x20,0xCD,0x61,0x91,0xFA,0xA9,0x8D,0x79,0x2C,0x12,0x6D,0x78,0xAF,0xE9,0xE9,0x02,0x22,0x6C,0xBD,0xA2,
	0x73,0x9D,0x30,0x3F,0x39,0xAB,0x94,0x9E,0xFD,0x14,0xF1,0x70,0x51,0xD6,0x9F,0x55,0x63,0x8F,0x5A,0x47,
	0x2B,0x0B,0x1A,0xDA,0xAF,0x96,0xA0,0xA6,0x51,0xE4,0x02,0xBD,0x98,0xAE,0xFE,0x6E,0xFC,0xA0,0xB5,0xEB,
	0xF3,0x3D,0x9C,0xE7,0xF0,0x28,0x02,0xFA,0x9D,0x2F,0x35,0xBA,0x25,0x28,0x52,0x8C,0x87,0x93,0x30,0x84,
	0xD3,0x17,0x00,0x48,0xA8,0xB8,0x07,0x80,0x81,0xDA,0x28,0xCD,0xBA,0x31,0x42,0x82,0xF5,0x25,0x2A,0xBA,
	0x88,0xBC,0x94,0x23,0xEC,0xC4,0x96,0xD5,0x8B,0xAA,0xD4,0xC7,0x34,0x13,0x56,0xC6,0x14,0x99,0x54,0xA2,
	0xC7,0x6F,0x62,0xE0,0xC7,0xCD,0xA0,0xF5,0xCC,0xF2,0x4A,0xAF,0xAB,0xE4,0xB2,0x15,0x7C,0x52,0xAF,0x3A,
	0x03,0x17,0x30,0x00,0x2D,0x2C,0x10,0x5C,0xFD,0x1F,0x7B,0x18,0x5C,0x32,0x5D,0x25,0x96,0xF9,0x39,0x32,
	0x25,0x6F,0x12,0x68,0x2D,0x1D,0xF1,0x45,0x72,0x2E,0x12,0x6E,0x1D,0x46,0x11,0x06,0x30,0x1A,0x57,0x19,
	0x33,0x72,0x48,0x71,0x3A,0x22,0x30,0x52,0x7E,0xB8,0xD7,0xAF,0xAF,0xA4,0xC7,0x6A,0x91,0xDB,0xDB,0x5F,
	0xC1,0x70,0x27,0x10,0x14,0xCE,0x94,0x01,0x8C,0x72,0x98,0x29,0xCB,0x1E,0x47,0xDC,0x7F,0x9F,0x3C,0xD2,
	0xCB,0x8F,0xDE,0x17,0xCF,0x58,0xFC,0x03,0xD0,0x96,0xD8,0x86,0xC8,0xE8,0xDB,0x7E,0xAD,0x0C,0xDB,0x9E,
	0x3D,0xB6,0x26,0x5B,0x2B,0x30,0x6B,0x8E,0x4E,0x59,0xD5,0x18,0xC2,0x8E,0xF9,0x25,0x2D,0x83,0x9F,0x4C,
	0x5B,0x75,0x54,0x8A,0xAC,0xC5,0xE5,0x21,0x9C,0xC1,0xA0,0x77,0xDB,0x8D,0x75,0xA4,0x65,0x01,0x6A,0xD6,
	0x2B,0xAB,0x69,0x88,0x1C,0xEE,0x30,0x73,0x13,0xD0,0x0A,0xAC,0x68,0x50,0x72,0xF6,0x67,0x61,0x16,0xD5,
	0x25,0x0F,0x2E,0x61,0xA3,0x80,0x64,0xDC,0x06,0x5B,0x7D,0x04,0x4C,0x30,0x63,0x8A,0x2D,0x2A,0x2C,0xBD,
	0xB3,0x94,0xB8,0x7E,0x61,0x89,0x21,0x93,0x1C,0xDF,0x5E,0x97,0x67,0x75,0x63,0x35,0xFC,0x02,0x34,0x95,
	0x4C,0x53,0x0D,0xF3,0xF5,0xC7,0x80,0x8A,0x1D,0x9F,0xCC,0x17,0x14,0x08,0x0D,0x51,0xF5,0x1F,0xA1,0x5D,
	0xA1,0xC3,0x67,0xC4,0x1F,0x20,0x23,0x17,0xA5,0x23,0xDD,0xA8,0x67,0x3A,0x2B,0x49,0x1E,0x06,0x85,0x64,
	0x24,0xC8,0x8C,0x30,0x4A,0xFF,0xC0,0x04,0xE1,0xB5,0x30,0xEB,0xEA,0x8E,0xE6,0x3F,0x8A,0x9A,0x96,0x4A,
	0x05,0x90,0xBC,0x4E,0xEB,0xDC,0xD0,0x96,0x09,0x46,0x2C,0x83,0xDA,0x6A,0x9F,0xDD,0xAD,0x4B,0x77,0xCF,
	0x7D,0x92,0x44,0xC6,0x8A,0xE5,0x7F,0xD8,0xBE,0xBF,0x76,0x34,0x35,0xD5,0xAB,0x6F,0x29,0x05,0xED,0x79,
	0x2D,0xC2,0xA4,0xB0,0x08,0x84,0x47,0xBC,0xD6,0xE6,0x03,0x75,0x54,0x05,0x45,0x3A,0xC5,0x7E,0x7B,0x31,
	0x19,0xA7,0x0D,0x58,0x87,0x7E,0x1E,0x0E,0xF0,0x2C,0x44,0x40,0x93,0xA9,0x96,0x86,0xC1,0x78,0x27,0x68,
	0x4E,0x4C,0xBE,0x96,0xCC,0xAC,0x7D,0xE0,0x51,0xBD,0x49,0xB1,0xC8,0xC3,0x1F,0xC4,0xCB,0xF5,0xFD,0xE0,
	0x15,0x38,0x23,0x9D,0x18,0xB0,0xF4,0x5C,0x01,0xBF,0x30,0x58,0x71,0xC5,0x9B,0xF4,0x84,0xCB,0x37,0x7B,
	0x57,0x00,0x61,0xA5,0x16,0x6E,0x7F,0x4F,0x8C,0x8E,0x10,0xB9,0x16,0xAD,0xCA,0xBA,0xA1,0x18,0xC4,0x5D,
	0x31,0xB1,0xAA,0x14,0xBE,0x1A,0xC3,0x1B,0x25,0xAF,0x6F,0x39,0x02,0x0C,0x06,0xE8,0x4A,0xE4,0xEC,0x35,
	0xB9,0x18,0x1C,0x17,0x7D,0x22,0x08,0x32,0x4C,0xBC,0xFE,0xBB,0x18,0x9C,0x3B,0x77,0x00,0x11,0x04,0x48,
	0xCA,0xFA,0xF8,0x29,0x1D,0xFF,0x60,0xCA,0x2D,0x96,0x04,0x8C,0xED,0xDF,0xB9,0x2C,0x79,0xED,0x83,0x82,
	0xED,0x63,0x85,0xDE,0x41,0x3A,0x78,0xF0,0x23,0xF2,0xDF,0x60,0xE8,0x12,0x57,0x87,0x8A,0x64,0x3F,0x07,
	0x33,0x83,0x11,0xD1,0xF7,0xC7,0xD1,0x90,0xDA,0xA2,0x76,0x75,0xE2,0xA1,0x9A,0x21,0x66,0x52,0x5F,0x56,
	0x3C,0x0C,0x05,0x71,0xB8,0x6E,0x9B,0x1E,0x83,0x4B,0x9E,0xEC,0x91,0x54,0x1D,0xD6,0xA2,0xFD,0x6E,0x74,
	0xCB,0xD3,0x95,0xEE,0xAE,0x15,0xB5,0xCA,0xFB,0xAE,0x78,0xA0,0xA8,0xDA,0xCB,0x1D,0x15,0x19,0x19,0xC1,
	0x94,0xCC,0x55,0xFC,0x33,0xC7,0xFD,0x50,0xAE,0xC8,0x6B,0xBD,0xE0,0x55,0x04,0x95,0x23,0xA8,0xC1,0x3A,
	0x91,0x01,0x93,0xDB,0x4C,0xCF,0x42,0x61,0x80,0xDD,0x61,0xB9,0x02,0xA4,0xED,0x6D,0x28,0x34,0xCF,0x9A,
	0x86,0xBF,0xDD,0xF6,0x0F,0xDB,0xD0,0x40,0x55,0x34,0x17,0x7C,0xB2,0x72,0x55,0x52,0x32,0xD3,0x95,0x6D,
	0x7F,0xFD,0x13,0x51,0x17,0xAC,0x84,0x6C,0xF3,0xFB,0x87,0xFC,0xFC,0x19,0x8B,0x48,0x74,0xCD,0xCC,0x5F,
	0x99,0x62,0x5C,0x65,0xB0,0xA2,0x21,0x8C,0x2C,0xBC,0xFD,0x6B,0x5B,0xFD,0xBA,0x90,0x80,0x83,0x2A,0x57,
	0xFE,0x5D,0xD9,0x64,0x3B,0xAD,0xA0,0x58,0x22,0xDF,0x38,0x5E,0x1E,0xDC,0x8A,0xB6,0x2A,0x0F,0xA0,0xE1,
	0x77,0x18,0x33,0x98,0xFC,0x78,0xA0,0x02,0x98,0x86,0xE8,0x93,0xF2,0xB6,0x18,0x6A,0x43,0x60,0x9D,0x01,
	0xD2,0xEB,0xD5,0x4F,0x96,0xCF,0xBA,0x4D,0xD0,0x20,0x11,0x25,0x23,0x9A,0x8A,0x98,0xC5,0xC0,0x6B,0x54,
	0xDA,0x9C,0x31,0xCB,0x4A,0x3B,0x76,0x88,0x66,0x36,0xD1,0xF2,0x35,0x83,0x99,0x24,0x43,0x0B,0xC1,0x8B,
	0xBA,0x94,0x66,0x6D,0x90,0x8B,0x5F,0xF2,0x9D,0x26,0x98,0x0C,0x5F,0x4A,0x58,0x01,0x77,0x8E,0xF8,0xB3,
	0x30,0x77,0x77,0x49,0xAF,0x07,0xD3,0x10,0x07,0x66,0x53,0x47,0x1F,0x1A,0xA5,0x79,0xB7,0x9C,0x77,0x24,
	0x7E,0xC1,0x74,0x9B,0x73,0x70,0x44,0x33,0x5C,0x60,0xE6,0xAB,0x62,0x81,0x9B,0xF1,0x4C,0x4E,0x37,0x2C,
	0xFE,0x16,0x41,0xAB,0x72,0x81,0x2E,0x4D,0xA6,0x24,0x5F,0xC1,0x4D,0x7C,0xEA,0x14,0x13,0x76,0x13,0xCF,
	0xAE,0x01,0x25,0x16,0x65,0xCB,0x0D,0x87,0x3E,0xA0,0x75,0x74,0xBA,0xE1,0xD8,0x0F,0x06,0xC1,0x86,0x3B,
	0x01,0x4D,0x07,0x19,0xB9,0x2C,0x29,0xE9,0x33,0xE0,0xD9,0x10,0xAE,0x39,0xA9,0xB3,0x7A,0x22,0x46,0xF4,
	0x6D,0xF0,0xE1,0x73,0x54,0xF3,0x91,0x90,0xE4,0xE2,0x95,0xBB,0x4E,0xDB,0xA1,0xF8,0x48,0xC8,0x09,0x94,
	0xE6,0xB1,0xD4,0xB3,0xD3,0xB5,0x8D,0x84,0x31,0xBC,0xF1,0xA7,0x21,0x2B,0x00,0xC4,0x8D,0xD8,0x99,0x0A,
	0x68,0x41,0xCF,0x66,0x9F,0xE9,0x94,0xBA,0x1C,0xB9,0xAC,0x0E,0x7A,0x57,0xFF,0x01,0x41,0x8C,0x26,0x9F,
	0x0A,0x77,0x32,0x1F,0x41,0x6F,0x03,0x79,0x73,0xBA,0x01,0x84,0x7C,0x5E,0x02,0x3D,0x5D,0x4C,0x0A,0x39,
	0x79,0xC9,0x9D,0x19,0xA6,0xAA,0xF5,0xFC,0x49,0x04,0x3E,0x92,0x63,0xF0,0xE7,0x02,0xC4,0x50,0xDE,0x56,
	0x34,0x5C,0x45,0x88,0x25,0x65,0x6A,0x74,0xBA,0xDC,0xB0,0x02,0x59,0xB1,0x75,0x7B,0x4D,0xEB,0xB6,0x18,
	0x3C,0x14,0x65,0x12,0xCD,0x75,0x64,0xD4,0x4E,0xBA,0xD2,0x9C,0x35,0x5F,0x29,0xBA,0xE5,0x49,0x33,0x49,
	0x9F,0xB1,0x36,0x7C,0x94,0xD8,0x63,0x04,0xAB,0x03,0xCE,0xF2,0x89,0x33,0x10,0xE7,0x9A,0x3C,0x65,0xCE,
	0x0A,0x03,0xA6,0xE6,0x63,0xA0,0xFD,0xEB,0x29,0xDE,0x99,0xFB,0x4C,0x34,0x8E,0x1E,0xC2,0x38,0x61,0x01,
	0x99,0x5E,0x56,0xCB,0x9F,0x72,0xB1,0x88,0xC7,0x0E,0x79,0xA1,0xDF,0x2E,0x99,0x83,0xC0,0x9F,0x52,0x2F,
	0x87,0x74,0xF2,0x4B,0x72,0x4B,0x35,0x5B,0xA2,0x06,0xC9,0x61,0x2B,0x33,0x66,0x90,0x52,0x10,0x7A,0x3E,
	0xD3,0x2C,0x09,0x7C,0x07,0xFD,0x34,0x63,0x57,0xD2,0xB4,0x02,0x3B,0x12,0x55,0xA1,0x42,0xFF,0xA3,0x53,
	0x4C,0x7C,0x1B,0x2C,0x2D,0x00,0x07,0x63,0xC4,0x85,0x97,0x9D,0x5B,0x00,0x22,0xAD,0x91,0x5C,0x27,0xFE,
	0xD8,0x80,0xFA,0xD5,0x10,0xC3,0x2A,0xC0,0x56,0x6C,0x23,0x40,0x0C,0x7A,0xF0,0x33,0x1A,0xEC,0xD9,0x94,
	0x0C,0xB4,0x70,0x39,0xB1,0xDD,0x64,0xCC,0x32,0x2C,0x59,0xFF,0x22,0x87,0x4D,0x6E,0x7A,0x40,0x90,0xFB,
	0xEC,0xA6,0xCA,0xA0,0xC4,0x9F,0x5B,0x90,0x04,0x8E,0xFE,0x4A,0x80,0xED,0x10,0x32,0xB7,0x8A,0xF3,0x2E,
	0x03,0x80,0xAF,0x02,0xD7,0x86,0x1F,0x52,0xE7,0xC4,0x24,0x45,0x34,0xFE,0xF5,0xFD,0x2C,0x82,0xDB,0x1F,
	0x5C,0x1C,0x54,0x3F,0xDA,0xDD,0xE7,0xAA,0x9D,0xB2,0x7F,0xDD,0x37,0x02,0x65,0xE0,0x2D,0x91,0x30,0xBF,
	0x30,0xEC,0x32,0xF7,0x2B,0x49,0x22,0x5F,0x01,0x9B,0x10,0x19,0x66,0x50,0xB9,0x6A,0x58,0xA4,0x0A,0x8C,
	0x12,0x05,0x12,0x73,0x68,0x01,0x1C,0x10,0xE9,0x59,0x17,0x3F,0xAE,0x5A,0x8E,0xEA,0x59,0x7B,0xFC,0x05,
	0x1F,0xFF,0xAA,0xBD,0x83,0xC5,0x6D,0x01,0x7C,0x05,0x5E,0x59,0x6C,0x58,0x85,0x41,0xA0,0x7E,0xFF,0xC8,
	0xE5,0xB3,0x2B,0xB6,0xC5,0xE1,0x2F,0xF8,0xC2,0xED,0x93,0xF6,0x1D,0xCC,0x4A,0x7C,0x62,0x9E,0x80,0x22,
	0x81,0x0C,0xD3,0x50,0xEC,0x22,0xDC,0x26,0xC7,0x11,0xE2,0xC5,0x4E,0xB6,0x81,0x1D,0x5F,0x78,0x45,0x76,
	0xC6,0xAF,0xB1,0xD6,0xBF,0x2D,0xF3,0x41,0x58,0x5C,0xED,0xD9,0x5E,0x99,0x69,0x6B,0xE0,0xD5,0xDF,0xF6,
	0x2A,0x0C,0x4A,0xD8,0xB9,0xA6,0x9F,0x1C,0x9F,0xD5,0x9C,0x51,0x9F,0x40,0xE7,0x62,0x14,0xA6,0xDC,0x4C,
	0x8E,0x89,0x0A,0x08,0x03,0xC9,0x9C,0x81,0x0C,0x70,0x32,0x51,0x0D,0x55,0xFC,0x2C,0xC1,0x84,0x11,0x63,
	0xE6,0xEA,0x20,0x83,0x78,0x48,0xF0,0xB2,0x44,0xAD,0x21,0x2F,0x88,0xB3,0xA5,0xA2,0x2B,0xF4,0xB9,0x03,
	0xFF,0x2A,0x63,0x3A,0x40,0x3C,0xCB,0x8B,0x25,0x43,0x7F,0x9B,0x10,0x20,0x8A,0x05,0x7D,0x92,0x93,0xA1,
	0x0B,0x5B,0x90,0xC1,0x48,0x0A,0xB5,0x98,0x46,0xC1,0x84,0x85,0x0B,0x8B,0x57,0x61,0x33,0x2E,0x08,0x48,
	0xEB,0x55,0x3F,0xD0,0xFC,0x9E,0xB9,0x5B,0x46,0xB6,0xBE,0x13,0x96,0x97,0xCE,0xDD,0x96,0x2A,0x37,0x75,
	0xFC,0x5B,0xBB,0xBD,0xA1,0x94,0x18,0x05,0xF2,0xF1,0x07,0x4C,0x61,0x85,0x86,0x69,0x4C,0x03,0x34,0xFE,
	0x4B,0xC8,0xD4,0xE9,0xE4,0x54,0x3C,0x4E,0xD7,0x05,0xA8,0xFE,0x5C,0x30,0xC5,0x4A,0xD3,0x20,0x80,0xA8,
	0xF1,0x92,0x2F,0xF2,0xAA,0xD0,0x8E,0xBC,0x9A,0x1F,0x97,0xAE,0x41,0x89,0x57,0xD5,0xED,0x93,0x8C,0x57,
	0x11,0x66,0x1F,0x66,0xC4,0xD8,0x6D,0x51,0xDE,0x11,0x8B,0x2F,0x17,0x8F,0xDE,0xF4,0x89,0x58,0x29,0x68,
	0x34,0xBC,0x89,0x29,0xDB,0x55,0x17,0x89,0xEE,0x1D,0xB3,0x6C,0x72,0x30,0xBD,0xD5,0x91,0x89,0x8D,0x6B,
	0x38,0xEC,0x4A,0x96,0xEF,0x08,0x7E,0x8D,0xD3,0x55,0x3B,0xD5,0xFC,0x85,0xAA,0xFF,0x00,0xAA,0x59,0x18,
	0xFE,0x32,0x79,0x9E,0xEB,0x89,0xE8,0xE7,0x8C,0xE3,0xEB,0x8D,0x87,0x81,0x0C,0x0C,0x11,0x55,0xA9,0x2C,
	0xA5,0x98,0xC0,0x78,0x0A,0x2D,0xCD,0x45,0x80,0xC4,0x40,0x92,0x27,0xA0,0x8A,0x8F,0x72,0x74,0x07,0xFC,
	0xB4,0xD1,0x3F,0xB9,0x8C,0x80,0x69,0x86,0x94,0x56,0xD0,0x6D,0xE2,0xAA,0x6B,0x6D,0x55,0x18,0x3B,0xEB,
	0x5A,0x9E,0x15,0xFB,0x89,0x94,0xEB,0x7E,0xE0,0x2D,0x86,0xC0,0xAD,0xB7,0x6E,0xA9,0x7B,0x81,0x2D,0x05,
	0x11,0xEB,0x05,0x48,0x43,0x7B,0xF5,0x11,0x55,0x7E,0xDB,0xF4,0x64,0x25,0x54,0xAE,0x9F,0x33,0x3D,0x54,
	0xCD,0x01,0x68,0xA4,0x6F,0xA4,0xE9,0xBB,0x14,0x46,0x75,0x13,0x99,0x42,0xC4,0x65,0xCE,0x07,0x26,0x73,
	0xCF,0x6E,0x83,0x54,0x55,0x61,0x88,0x44,0x3B,0x4A,0x14,0x11,0x63,0x19,0x02,0xA8,0xE0,0xAD,0xDF,0x18,
	0xC8,0x3B,0x1C,0x95,0x74,0x85,0xE8,0x28,0x42,0x3D,0x8D,0x56,0x55,0x12,0x87,0x0B,0xF7,0x53,0xF3,0xA7,
	0x0D,0x74,0x01,0xB4,0xAD,0x2A,0xD4,0x26,0x27,0x61,0x31,0xD8,0x3C,0x79,0xE6,0xA9,0x0D,0x6C,0x1F,0x6A,
	0xDA,0x3F,0x1F,0xC3,0x44,0xED,0x51,0x1B,0x44,0x8B,0xEF,0x75,0x26,0xE7,0xEA,0xBE,0xC3,0x0E,0x19,0x61,
	0xC0,0xAC,0xD5,0x60,0x61,0x2D,0x03,0x19,0xEF,0xC0,0x14,0x6D,0x0D,0x79,0x27,0x84,0x75,0x2C,0xFA,0x22,
	0xE6,0x87,0x35,0x6D,0x96,0xD1,0x76,0xC2,0x55,0x40,0x87,0x47,0xEB,0xFC,0xBD,0x90,0xD6,0x28,0x11,0xFA,
	0x35,0x47,0x60,0x47,0x7F,0xAF,0xD3,0xA5,0x0B,0x71,0xBA,0xD0,0xA8,0x54,0xA4,0x60,0xAA,0x7D,0xE7,0x98,
	0x14,0xB0,0x6E,0x4D,0xFC,0x3C,0x28,0x1F,0x9D,0x1D,0x16,0xC4,0x75,0xCE,0x98,0xDE,0xA3,0x98,0x55,0xF7,
	0xCC,0xA9,0x46,0xE1,0xA3,0x01,0x13,0x6A,0x78,0x62,0x5E,0xAB,0xD9,0xD0,0x88,0x16,0x10,0x9A,0xAA,0x72,
	0x5D,0x81,0xB6,0x04,0x29,0xCD,0x74,0x2E,0x60,0x32,0xAA,0x46,0xA1,0x97,0x5A,0xAA,0x03,0xE2,0xA3,0x60,
	0x0B,0x45,0x30,0x42,0xB0,0x87,0x03,0x11,0xB9,0x56,0x40,0x34,0x3E,0x7D,0x33,0xF9,0x8C,0xAF,0x29,0x0A,
	0x3F,0xF0,0x08,0x58,0x0C,0x22,0x24,0xDE,0xE9,0x4F,0xBB,0x66,0x9C,0xB5,0xEE,0x25,0x8D,0x44,0x05,0xCB,
	0x8A,0xC5,0x29,0x7F,0x83,0x45,0xE5,0xD7,0x53,0x3A,0x40,0xF2,0x87,0x22,0x0E,0x9A,0xAD,0xF4,0x8F,0x22,
	0x12,0xB3,0x90,0x4D,0x3A,0xC6,0xFB,0xD0,0x7D,0x2A,0xA3,0xA4,0xF9,0xFA,0x95,0xF0,0x42,0xED,0x77,0x61,
	0x53,0x71,0x58,0x8C,0xCB,0xA1,0xD0,0xF7,0x3A,0x32,0x58,0x19,0x15,0xD9,0x1D,0x21,0xD5,0xB5,0x2A,0x58,
	0xD3,0xFD,0x64,0xDD,0x9B,0x45,0xEC,0xDD,0x15,0xD2,0x18,0x19,0xA1,0x86,0xBB,0xD6,0x53,0x3B,0x28,0x97,
	0x2B,0xDF,0x6C,0xEC,0x2F,0xB8,0x0B,0x74,0x8B,0xF0,0xE7,0x25,0x5F,0x8E,0xDD,0x81,0xB8,0xA4,0x17,0xEB,
	0x2A,0x4C,0x3D,0x75,0xBF,0x28,0x63,0x6E,0x5D,0x12,0x5B,0x4D,0x97,0x29,0x7E,0x0D,0x9F,0x38,0xC3,0x79,
	0x22,0x05,0x5F,0x50,0xB5,0xBE,0x42,0x8D,0xAF,0xE2,0xC6,0xA0,0xAA,0x2D,0xB6,0xAA,0x21,0xFE,0xC7,0xA0,
	0x77,0x11,0x55,0x57,0x76,0x1D,0x01,0xAD,0x9A,0xE1,0x38,0xC3,0xA9,0x7F,0x6F,0x17,0x0F,0xCD,0x2A,0x02,
	0xD4,0x21,0x09,0xEF,0x18,0x8A,0xC2,0x06,0x6E,0xF7,0x4B,0xD0,0xBA,0x96,0xF9,0x63,0x5D,0x3D,0xAE,0x48,
	0xC1,0x01,0x21,0x64,0xA6,0xAD,0xDF,0xA7,0x06,0xC4,0xDC,0xF2,0x94,0x60,0xD4,0x69,0xE9,0xFB,0x95,0x17,
	0x92,0xA2,0xEB,0x52,0x0E,0xE4,0x69,0x38,0x42,0x11,0x52,0x30,0xC1,0xFE,0x1A,0x3D,0xEB,0x89,0xCE,0x7A,
	0xD4,0x9A,0xFD,0x7E,0xBB,0xFA,0xB5,0x39,0xE5,0x50,0xB0,0x97,0x13,0xE0,0x95,0x6E,0x89,0x7C,0x27,0xF0,
	0x0A,0xF1,0x96,0x35,0x8B,0x0C,0x6B,0x87,0x95,0x53,0xFD,0x32,0x97,0x9D,0x0B,0xDE,0xF9,0x4A,0x64,0xA5,
	0x5D,0x5E,0xDB,0xC4,0x86,0xCF,0x8D,0x12,0x6A,0xF4,0x67,0x46,0x55,0x0E,0x60,0xD8,0x00,0x60,0xEE,0xED,
	0x5B,0xED,0x04,0x9B,0x9A,0x0D,0x6D,0x71,0x55,0xE4,0x67,0x9D,0x5F,0xD2,0x00,0x4F,0xEB,0x34,0xC6,0x03,
	0xE0,0xBB,0xED,0xB9,0x34,0xEE,0x90,0xBE,0x57,0x7F,0x7D,0x35,0x13,0x70,0x7E,0x45,0x2E,0x58,0x26,0x30,
	0xF1,0xB8,0x68,0x6D,0x43,0x5C,0x6B,0x15,0xE1,0x07,0x08,0x93,0x31,0x55,0x94,0xD1,0x24,0xED,0xD1,0x48,
	0x05,0xBA,0x20,0x1A,0x12,0x16,0xDC,0x42,0x40,0x82,0x92,0x29,0x88,0x32,0xD6,0x71,0xC7,0x28,0xC4,0x02,
	0x75,0x1F,0x15,0x17,0x8C,0x34,0x66,0x80,0xF8,0x83,0xDD,0x70,0x78,0x47,0x96,0x9B,0xD7,0x9E,0xB1,0x33,
	0x90,0xD1,0x4B,0xB4,0xEE,0xE2,0x89,0x58,0xD5,0xDD,0x61,0xD5,0x70,0x3E,0x81,0x25,0xD2,0xA8,0x8E,0xD7,
	0x1C,0xF7,0x08,0xD3,0x52,0xB3,0x4B,0x9B,0xD0,0x13,0x36,0xF3,0xC6,0xE0,0x78,0x2F,0x6C,0xF2,0x50,0xA5,
	0xA8,0x68,0xF0,0x95,0x87,0x48,0xE9,0x92,0xD7,0xA1,0x81,0x80,0x78,0xC5,0x15,0x65,0xF6,0x72,0x1E,0xB9,
	0x0B,0x28,0x90,0x22,0x8C,0x5D,0xF5,0x91,0x0A,0x68,0x8F,0x8D,0xC2,0x90,0xAC,0x28,0x19,0x85,0x4F,0xB9,
	0xB5,0x00,0x1B,0xD8,0xE4,0xAD,0x8B,0x68,0x27,0xA0,0xD2,0x77,0x5F,0x02,0x4C,0x3D,0x9B,0xE1,0xA6,0xA3,
	0x53,0x73,0xB3,0x6B,0xB1,0x0C,0x65,0xC0,0xAE,0x9C,0xAC,0x48,0x5D,0x07,0x85,0xA3,0xB6,0x53,0x35,0x06,
	0x1A,0x4C,0xC2,0xBA,0x06,0x60,0x57,0x5E,0x56,0x0B,0xB7,0x5A,0x15,0xDA,0xFE,0x61,0x86,0x49,0x0B,0x33,
	0x14,0x40,0x29,0x91,0x9D,0x46,0x31,0xF0,0x7A,0x16,0xDB,0x64,0x53,0xF2,0x40,0x0A,0xD9,0xD7,0x0C,0x47,
	0xC4,0x7B,0x31,0x87,0x84,0xDA,0x1C,0x59,0x93,0xA6,0xEA,0xFE,0xCF,0x39,0xB6,0x53,0x27,0xDC,0xC3,0x69,
	0x00,0x3A,0xEE,0x9E,0xCF,0x09,0xB1,0x9C,0xB5,0x33,0x88,0x3A,0x06,0xCB,0xDF,0xA0,0x64,0xA0,0x72,0xF4,
	0x61,0x51,0x95,0xEB,0x2A,0x26,0x13,0x3F,0x08,0xEA,0x77,0x15,0xFB,0xF0,0xB1,0xE7,0xB8,0x94,0xBD,0x19,
	0x54,0x6E,0xEA,0xB6,0xF1,0x9B,0xF4,0xDB,0x19,0xA9,0x4B,0xFA,0xD8,0x4D,0xBF,0x95,0xAF,0xF8,0x64,0x09,
	0x57,0x2F,0xE2,0x26,0x16,0x4E,0x94,0x43,0x0B,0xB6,0x6B,0x08,0x7B,0xD6,0x95,0x6E,0xD6,0xC2,0xC2,0xEA,
	0xDD,0xA2,0xAD,0xB4,0x77,0x88,0x07,0xC2,0xCA,0x7D,0x4A,0x79,0x21,0x03,0xB9,0x6F,0x95,0x97,0xD0,0xD0,
	0x95,0x41,0x29,0x32,0x4F,0xCD,0x19,0x2E,0xF3,0xC0,0x27,0x0B,0x95,0x7F,0xEB,0x5B,0xF3,0xD5,0xCB,0x07,
	0xB7,0x87,0xE0,0xCA,0x3E,0xAC,0x1E,0x68,0x91,0x29,0x17,0x85,0x56,0xFD,0xD1,0x9C,0x3C,0x99,0x0B,0xB7,
	0x31,0x26,0xEE,0xAC,0x9B,0x75,0xB0,0x7A,0x64,0xD7,0xD3,0xCA,0x8D,0x28,0x01,0xDB,0x33,0x5A,0x96,0x49,
	0x6A,0x0F,0xAA,0xF4,0xDF,0x4C,0x04,0x03,0x11,0x08,0xC6,0x44,0x1D,0x82,0xBD,0x0B,0x14,0xEC,0x18,0xDF,
	0x80,0x15,0x79,0x8B,0x92,0xE0,0x71,0xA6,0x0E,0xDB,0xA0,0x34,0x00,0xA9,0x8C,0xED,0x6B,0x34,0x6A,0xCF,
	0x99,0x8B,0x01,0xAB,0xF8,0xD1,0xA7,0x64,0x25,0x58,0xFF,0xDC,0x98,0xC0,0x2C,0x0A,0xF6,0x53,0xAA,0x70,
	0x34,0xA3,0x25,0x78,0xEC,0x05,0x39,0xEA,0x60,0x0F,0xA9,0x34,0x27,0xBC,0x7E,0x8D,0xCC,0x70,0xD1,0x80,
	0x20,0x07,0x80,0x62,0x1C,0x48,0xF3,0x6D,0x9D,0x8A,0x78,0xCA,0xC5,0x5D,0x7A,0x68,0x0E,0xB6,0xFC,0xA9,
	0xF6,0x5C,0x34,0x51,0x38,0x6A,0x4D,0x03,0x57,0x71,0xD3,0xF1,0x07,0x91,0x23,0x08,0x64,0x53,0x45,0x99,
	0x5C,0xC4,0x0B,0xAE,0x31,0x32,0xD5,0xEA,0x79,0x59,0x14,0x07,0x2C,0x4B,0x03,0x40,0xE8,0x71,0x4E,0x4A,
	0x0D,0xCE,0x7B,0xAE,0x1B,0x81,0x95,0xA1,0x98,0x51,0xB7,0xB9,0xEF,0x25,0xC1,0x6C,0xD6,0x48,0xD8,0x09,
	0xE7,0xA8,0x77,0x14,0x32,0xC6,0x1C,0x25,0x6B,0xBA,0x0A,0xA6,0xB9,0xB2,0x9C,0xAC,0x86,0x31,0x91,0xAC,
	0xA1,0x42,0xAF,0x92,0xDF,0xAA,0x92,0x6C,0x5C,0x74,0xBA,0xA9,0xFA,0x97,0xD2,0xA6,0xDA,0x1A,0xAF,0xD3,
	0x22,0x5E,0xB4,0xFD,0x45,0xE1,0x22,0xCC,0xDA,0xA7,0xD0,0xBA,0x8C,0x5E,0x10,0x47,0x08,0x83,0xD7,0xD7,
	0x48,0xE1,0x01,0x06,0x76,0xED,0x31,0x67,0x61,0x35,0xE5,0x8F,0x1B,0x14,0x55,0x6B,0xC5,0x2E,0x9A,0x9B,
	0x1E,0xD9,0x40,0x41,0x6E,0x64,0x8F,0x2F,0x56,0x9E,0xD7,0x0B,0xCD,0x8D,0x0E,0xA8,0x0B,0xF5,0x74,0x97,
	0x23,0xF5,0x32,0x45,0x6A,0xC7,0x9E,0x84,0x2F,0x65,0xB6,0x52,0xC6,0x3C,0xD4,0xE3,0x51,0x91,0x3F,0xAB,
	0x08,0x5C,0x37,0x65,0x38,0x7A,0xEA,0xC1,0x2E,0x37,0x2A,0x51,0x35,0x7B,0xDC,0x3B,0x4C,0x77,0x96,0x8A,
	0xB2,0x6E,0x2B,0x4D,0x00,0x61,0x89,0xF9,0x32,0x67,0x7F,0xE6,0x74,0x72,0xDA,0xB2,0x4E,0x59,0xFA,0x2C,
	0x4E,0x79,0x97,0x28,0xF7,0xAB,0x00,0xB9,0xBD,0x10,0x09,0x07,0x2E,0x2F,0xEF,0x2B,0xB5,0x95,0xF4,0xAF,
	0xCC,0xAC,0xDD,0xE6,0x21,0x46,0xEB,0xED,0x1F,0xA2,0xD9,0xE9,0x6D,0x30,0xF0,0x8C,0xA9,0x8C,0x92,0x9C,
	0xD7,0x3B,0x97,0xB3,0x98,0xAB,0xF9,0xF1,0xA9,0xE9,0x95,0xD2,0x21,0xC7,0x89,0x85,0x75,0x5E,0xE4,0x78,
	0x99,0x69,0xB2,0x6A,0xF2,0xDF,0x07,0xDC,0x96,0x4B,0x3C,0x06,0xD9,0x58,0xEF,0x9A,0xEC,0x5D,0xE0,0x55,
	0xFE,0xF3,0xB4,0xAC,0xCB,0xD8,0x89,0xE7,0xAD,0x63,0xA1,0x45,0x86,0xD3,0x0C,0xDD,0x1E,0x73,0x19,0xD9,
	0x3A,0x64,0x0D,0x99,0x6A,0x41,0x42,0xCC,0xE6,0x1D,0xF3,0x17,0xD3,0x2C,0xBB,0x6B,0xA2,0x10,0x95,0x2D,
	0xDF,0xB3,0xB7,0x37,0x2D,0xE4,0x4C,0x5B,0x68,0x0E,0x6B,0x4A,0x8C,0x56,0xE2,0x42,0xB5,0x3B,0x8A,0x8E,
	0x78,0x66,0x14,0x7F,0x5A,0x30,0x7A,0x25,0x03,0xA9,0x29,0x41,0x70,0xA6,0x83,0x24,0x47,0x62,0x1D,0x7A,
	0xD1,0x75,0xBD,0xAF,0xB5,0xB9,0xB9,0x35,0x19,0x3C,0x41,0xC8,0x43,0xB5,0x5C,0x59,0x14,0x45,0x42,0x67,
	0x2B,0x35,0xB6,0x94,0x6A,0x62,0xD1,0x3E,0xD2,0x5B,0xE9,0xCA,0x93,0xBB,0xB3,0xD0,0xCE,0x42,0x64,0xC5,
	0xF8,0x41,0x72,0x5B,0x9E,0xB3,0x35,0x2C,0x18,0xE3,0x25,0xCD,0x2E,0xE1,0x4F,0x0F,0x1B,0x7E,0x01,0xBA,
	0xD2,0x89,0x03,0x7C,0xBC,0x7E,0x68,0xE0,0x08,0xE3,0xCD,0x58,0x32,0xB2,0x56,0xB5,0xE5,0x51,0xA0,0xA7,
	0x4C,0xA6,0x58,0xD3,0x37,0x6D,0x77,0x21,0xFA,0xDA,0x94,0x02,0x73,0x7D,0x38,0x7C,0x39,0x3A,0x91,0x70,
	0x18,0x06,0x2F,0xC9,0x3F,0x17,0xAA,0x4B,0x72,0x19,0x47,0x43,0xFB,0x5C,0x99,0x53,0x43,0x6B,0xFD,0x9E,
	0x4B,0x32,0x45,0x29,0x74,0xB0,0x1A,0x1C,0xC1,0x37,0x71,0xCB,0xAE,0x10,0x2C,0x6F,0xBD,0xAB,0xDC,0xC9,
	0x61,0x68,0x85,0xEB,0xB8,0x43,0x64,0x30,0x49,0x46,0x27,0xEB,0x44,0x6A,0x72,0xAB,0x91,0xC2,0x72,0xC4,
	0x18,0xA3,0x03,0x58,0x5C,0x2F,0xF2,0xEA,0x0C,0x0D,0x80,0xE7,0x7E,0x85,0xD8,0x92,0x1C,0x77,0x80,0x40,
	0xB5,0xF4,0xAD,0x30,0xC1,0x19,0xF3,0x34,0x0D,0x2D,0x59,0x69,0x5E,0xEB,0x78,0xAA,0xC2,0xA4,0xB4,0xAC,
	0x8F,0x77,0x00,0x21,0x3B,0xFF,0x94,0xCA,0x8F,0xCB,0x98,0xD2,0x96,0x0F,0x73,0xEC,0xAB,0x9B,0x9A,0x67,
	0x1E,0x19,0xCD,0x95,0x9D,0x0A,0x3E,0xCE,0xD4,0x2D,0xE0,0xDF,0x17,0x9F,0xC0,0x8F,0x81,0x94,0x89,0x47,
	0x15,0xE1,0x16,0x82,0x16,0x67,0x77,0x8A,0x42,0x20,0x5A,0x44,0xF5,0xAE,0xB9,0x7B,0xEE,0x22,0x92,0xC3,
	0xB0,0xA3,0x09,0xB0,0x30,0x3B,0xED,0x7D,0x2A,0x3E,0xAA,0xDF,0x81,0xD0,0xEC,0xAE,0x6E,0xAE,0xA4,0x9A,
	0x61,0xD6,0x6E,0x52,0x94,0x6F,0x01,0x44,0x52,0x3A,0x48,0x66,0x51,0x1F,0x31,0x55,0xDB,0x37,0x54,0x1E,
	0x98,0xDF,0xBD,0xE1,0x49,0xC9,0x3E,0xBC,0x18,0x5B,0xE2,0x71,0x3D,0x75,0x21,0x72,0xA7,0xDB,0x8E,0x07,
	0x30,0x61,0x5E,0xF2,0xE4,0x3E,0x9C,0x84,0xD9,0xD4,0x20,0xEA,0x9F,0x6E,0x1A,0xEC,0xE5,0x2E,0x27,0xC6,
	0xE5,0xFB,0x03,0xF1,0xD8,0x74,0xAD,0x72,0x89,0xD6,0x61,0xB1,0xAC,0xBE,0x41,0x54,0xB1,0xD1,0xA1,0x9D,
	0x75,0x18,0x3A,0x29,0x18,0x21,0x42,0xC3,0x88,0x6E,0x5F,0xF9,0x3F,0x6A,0x34,0x50,0x0A,0x46,0x18,0xEB,
	0x74,0x00,0x37,0x64,0x4D,0x41,0x34,0x68,0x1F,0xA4,0x47,0xF9,0x98,0xE9,0xEE,0x58,0x0F,0xDB,0x56,0x16,
	0x01,0x84,0xF0,0x9D,0x1F,0xAE,0x42,0x98,0x55,0xAA,0x41,0x64,0x7B,0x23,0x23,0x83,0x90,0x04,0x8F,0x55,
	0x40,0x3B,0x01,0x07,0x44,0x12,0x59,0xD5,0x64,0x77,0x0B,0x23,0xFE,0x0A,0xF3,0x17,0xA0,0x2E,0x71,0xF5,
	0xCA,0xC2,0xD0,0x4D,0xA6,0x9F,0xD0,0x5D,0xF1,0xC2,0x5A,0xFA,0xD4,0x7C,0x69,0x6E,0x95,0xB6,0x7F,0x01,
	0x55,0xC2,0x44,0xE2,0xC7,0x04,0x68,0x05,0xC1,0xED,0x01,0x95,0x9C,0xA8,0x21,0x24,0x1D,0x56,0x95,0xCE,
	0x02,0x83,0x03,0x83,0x32,0x27,0x20,0xD1,0xDE,0x68,0x3D,0x30,0x86,0x18,0xA6,0x7F,0xB8,0xBF,0x36,0xD3,
	0x34,0x91,0x1C,0x0F,0xB6,0xE1,0xF2,0xFC,0xCA,0xDF,0x34,0x4D,0xF6,0xA1,0x14,0x7D,0x58,0x91,0xCC,0x20,
	0x94,0x7F,0x22,0xD1,0xBD,0xFE,0x8A,0xE7,0x8D,0x2D,0x7B,0xB8,0xBB,0xD6,0x62,0xB7,0xF5,0xED,0x94,0x17,
	0x68,0x0F,0x8E,0x5F,0xAC,0x40,0x91,0xDB,0xBF,0x99,0x10,0xEB,0xD6,0x02,0xD6,0x79,0x1B,0xCD,0x8A,0x93,
	0x5C,0x6C,0x8B,0x05,0x68,0xB0,0x6A,0xBD,0x41,0x39,0x89,0x83,0x45,0x64,0x74,0x26,0x95,0x10,0x41,0x06,
	0x6C,0x13,0x64,0x02,0x08,0x3F,0xC3,0x1E,0x0C,0x80,0x80,0x08,0x46,0x45,0x69,0xD7,0x44,0x07,0x3B,0xA1,
	0x28,0x62,0x1A,0x77,0x5C,0x28,0xC1,0x4A,0xB2,0xC8,0x7D,0x7C,0x1A,0x22,0x48,0x8A,0x64,0x75,0x44,0x17,
	0x6D,0x52,0xBA,0x3F,0x2D,0x4C,0x76,0xA4,0x28,0x02,0x23,0xFD,0x89,0xDA,0xFD,0xEB,0xF1,0x28,0x60,0x8E,
	0x89,0xE0,0xCC,0x6D,0x99,0xF1,0x69,0x93,0xB8,0x28,0xD5,0x82,0x72,0xFD,0x69,0xA1,0xB2,0x0A,0x9C,0x95,
	0x37,0x91,0x14,0x45,0x60,0xC4,0x94,0xCC,0xE3,0xE1,0x52,0x3A,0x7B,0xC4,0xC2,0xAE,0x94,0x1D,0x01,0xF1,
	0x88,0xA4,0xB4,0xCE,0xAE,0x04,0xA8,0x83,0xDD,0xCD,0xB1,0xF2,0xB5,0xA1,0xFA,0x1A,0xDE,0x05,0xFD,0x24,
	0xB1,0x2E,0xE3,0xEB,0x7C,0x5F,0xAC,0x8E,0x91,0xCF,0xE2,0x6F,0x41,0x06,0x10,0xEF,0xA3,0x19,0xA7,0x03,
	0x7B,0xD2,0x0F,0x90,0xB3,0x6F,0xFC,0x4B,0x84,0x0C,0x32,0xA8,0xCE,0x4E,0x3A,0x9B,0xE9,0x55,0xDD,0x7B,
	0x4D,0x44,0x95,0x1B,0x1F,0xF8,0x98,0x11,0x5D,0x9B,0xB3,0x18,0x8D,0x44,0xBA,0x5A,0x57,0x27,0x6B,0x86,
	0x11,0xB3,0x5E,0x2D,0x03,0x23,0x33,0x96,0x0E,0x34,0x0A,0xC8,0x20,0x83,0x88,0x76,0x62,0x7E,0x20,0x83,
	0x0C,0x32,0x7A,0x46,0x2E,0x5C,0x16,0x32,0xC8,0x6A,0x66,0x66,0xA6,0x5A,0x52,0x92,0xD7,0x28,0xF0,0x20,
	0x77,0xD4,0x98,0x10,0xDA,0x2A,0xA1,0x65,0x26,0x42,0xA8,0x12,0x03,0xE8,0xD8,0x95,0x8D,0x92,0x33,0xB4,
	0x5D,0x52,0x40,0x0C,0x02,0x1D,0xBA,0x8F,0x48,0x63,0x18,0x90,0x36,0xB3,0xB7,0x30,0x0B,0x72,0x48,0x5A,
	0xC1,0xF0,0x28,0xE1,0x70,0x4C,0x30,0xB8,0xDE,0xED,0xAA,0x82,0xDC,0x6E,0xB4,0xDC,0xDE,0xC2,0xBB,0xA0,
	0x8A,0x27,0xE3,0x6B,0x67,0x41,0xAB,0x79,0x1B,0xA1,0xF9,0x01,0xC9,0x8F,0x6F,0x32,0x63,0xE6,0x38,0xE5,
	0x1D,0xBA,0x2A,0xE4,0xEA,0x19,0xF6,0x95,0xC1,0x63,0xBC,0x3D,0x71,0x85,0x4B,0xD8,0xBA,0xEF,0xDB,0xB0,
	0xA6,0x6A,0x1E,0x54,0x6F,0x95,0x56,0x1F,0x47,0xF1,0x32,0x54,0x1D,0x00,0x40,0x0F,0xA4,0x3E,0x81,0xDF,
	0x39,0x36,0xFA,0x79,0xB9,0xC3,0x3C,0x4B,0xDB,0xB6,0xF4,0x39,0x6C,0x31,0x45,0xF0,0xF1,0x21,0x52,0xB7,
	0xF8,0xEB,0x39,0xF5,0xFC,0x4D,0x48,0xB3,0xAB,0x91,0xED,0x78,0x7F,0xCB,0x0D,0x8E,0xB4,0xC7,0x32,0x71,
	0xD4,0x02,0x20,0x60,0xCD,0xBA,0x45,0x4D,0x53,0x4D,0xC2,0xAC,0xB4,0xBA,0xBD,0x04,0x91,0x82,0xF9,0xBF,
	0x82,0xB4,0xC7,0xC4,0x50,0x99,0x33,0xA7,0x64,0x99,0x33,0xA3,0xC2,0x60,0x66,0xC3,0x1C,0x6D,0x01,0x43,
	0x91,0x05,0xAE,0xB3,0xBF,0xB5,0x8B,0x61,0xE1,0x3B,0xFA,0xE6,0xB3,0x73,0xED,0x25,0x25,0x60,0x14,0xC8,
	0x4C,0x55,0x46,0x47,0xB9,0x32,0xA8,0xE0,0xCC,0x88,0x9E,0x58,0x33,0x77,0x59,0x79,0x58,0xF1,0x6E,0x97,
	0x08,0x0C,0x44,0x80,0x40,0x04,0xB1,0x79,0xCA,0xC0,0x07,0x3B,0xC4,0x64,0x74,0x3B,0x95,0xBC,0x1E,0xB7,
	0x99,0x30,0x91,0xC5,0x76,0x07,0x43,0x3D,0xB7,0x55,0x61,0x1F,0xAC,0x7A,0x4F,0xF6,0xD8,0x25,0xF7,0x30,
	0x94,0x63,0x4F,0x22,0xB6,0xB5,0xA6,0x3E,0x50,0x82,0x5A,0x21,0x7A,0xDF,0x17,0xA9,0x95,0xED,0x77,0x31,
	0xBD,0xC0,0x6C,0xBE,0x77,0x6A,0xF3,0x02,0x5E,0xB7,0x5C,0x07,0x22,0xF2,0x35,0xF6,0x6B,0x2F,0xD5,0x2C,
	0x77,0x12,0x59,0x82,0x2C,0xF5,0xD4,0xFB,0x94,0xCB,0x28,0x75,0x80,0x98,0x43,0x0B,0xAF,0x01,0x44,0x30,
	0x18,0x04,0x6C,0xE8,0xB0,0x63,0x67,0x71,0x65,0x2F,0xD8,0xCA,0xB1,0x4F,0xEF,0x70,0x0C,0x76,0xAF,0x21,
	0x6C,0xA5,0xE2,0x69,0x99,0xD9,0xB0,0x73,0x55,0x26,0x7E,0x69,0x18,0x15,0xB8,0x58,0xDE,0xA7,0xAD,0xCE,
	0xC4,0x40,0xC2,0x9E,0xF4,0xAF,0x7D,0x99,0x77,0xBB,0x79,0x18,0x35,0xF8,0xDE,0x6E,0x9B,0x2F,0x49,0x43,
	0x66,0xAF,0x46,0xBE,0x4A,0x66,0x3A,0x86,0x43,0xF1,0xEC,0x82,0x8D,0x37,0xA6,0xE4,0xE9,0x30,0xB7,0x7E,
	0x20,0x0A,0xCE,0x34,0xCA,0xBE,0x39,0xF0,0xDD,0x01,0xFC,0xC4,0x22,0x0B,0x0C,0x70,0x77,0x0A,0x4F,0x70,
	0x5B,0xA6,0x9E,0x6B,0x16,0x1A,0x78,0x8A,0x64,0x4D,0xAA,0xE7,0x5D,0xA5,0xE7,0x5F,0x6F,0x19,0x40,0x3A,
	0x6D,0xAB,0x4B,0x91,0x8D,0xB7,0x0E,0xAB,0xC0,0x32,0x4C,0x94,0xA7,0x6D,0x96,0x9A,0x18,0x06,0xCF,0x0C,
	0x46,0xF8,0xCA,0x9A,0xB0,0x00,0xC1,0xC9,0xFB,0x3D,0x34,0x34,0x60,0x60,0x66,0x2E,0x7D,0x79,0x3A,0x45,
	0xDE,0x89,0x52,0xCA,0x06,0xC1,0xAC,0x24,0x21,0x93,0x55,0x0A,0x6B,0x48,0x01,0x48,0xC5,0x3F,0xD2,0x9F,
	0x6D,0x17,0x0E,0x86,0x19,0x32,0x68,0x04,0x20,0x52,0xDE,0x38,0x69,0x6C,0x6D,0x77,0x74,0xDE,0xC3,0x88,
	0x60,0x35,0x98,0x12,0x8D,0xE2,0x90,0x56,0x36,0x17,0x69,0xE2,0x86,0x98,0xAA,0x02,0x98,0x06,0xC5,0x12,
	0x16,0xC9,0xC4,0x94,0x14,0xF6,0xFD,0xD5,0x60,0x00,0xAD,0xD9,0xE5,0x1C,0xD7,0xC2,0x14,0x39,0x15,0xB1,
	0xB8,0x87,0x04,0xA9,0xD6,0x68,0x32,0x40,0xC1,0xC6,0xA2,0x96,0xC1,0x1B,0x48,0x07,0x87,0xB2,0x1B,0x94,
	0x65,0x05,0x4B,0x44,0xA0,0x62,0xDD,0xBF,0xA7,0x82,0xA5,0x7D,0x24,0xA7,0xE5,0xF0,0x1F,0x50,0x54,0x83,
	0x2B,0x63,0x16,0xF6,0x53,0xB2,0x3A,0x55,0x20,0x6D,0x06,0x18,0x06,0xFC,0x58,0x39,0x3A,0x95,0x56,0xBC,
	0x5C,0xC7,0xF4,0x13,0x9D,0x95,0x52,0xBD,0x98,0x78,0x62,0xA6,0x0C,0xA1,0x16,0x43,0xA9,0x8F,0x66,0xC6,
	0x12,0xB0,0x5E,0xB3,0xBC,0x65,0x6F,0x31,0x46,0xCA,0x63,0xC2,0x06,0xDD,0xB1,0xDA,0xD9,0x48,0x0A,0x0C,
	0x41,0xFB,0x26,0x21,0x75,0xC7,0xD2,0x00,0x1A,0x46,0xB7,0x47,0x11,0x01,0x43,0x27,0x50,0x5C,0xE9,0x53,
	0x43,0xC1,0x1F,0x2D,0xC4,0x5B,0xC5,0x81,0xB7,0x82,0x81,0xAE,0x3F,0x4D,0x49,0xAC,0xAA,0xB3,0xB5,0x2E,
	0x5F,0x1B,0xF0,0xDF,0x13,0x85,0xA5,0x6E,0x97,0x32,0x23,0x1E,0x8E,0x89,0xE6,0x14,0xD1,0x8D,0x9D,0x21,
	0x9D,0x9D,0x9E,0x3F,0x5B,0xB1,0x11,0x41,0xB2,0xAB,0xA2,0xA8,0x39,0x4A,0x21,0xC3,0xA9,0x55,0x49,0x71,
	0x6F,0x3C,0x0C,0x55,0xC9,0x77,0x69,0xAD,0x9B,0xDB,0x42,0xCE,0x36,0x46,0x5E,0x6E,0xCB,0x76,0x9D,0x1D,
	0xCC,0x8A,0x71,0x58,0x87,0x1B,0x55,0xCF,0x85,0xB1,0x79,0xF9,0xD7,0x6F,0x06,0x83,0x14,0x0A,0x76,0x46,
	0x39,0x9B,0xD8,0x54,0xD6,0xFC,0x28,0x4C,0x9D,0x3D,0xE7,0xAF,0xB4,0xDC,0x53,0x32,0x65,0xFF,0x7D,0x58,
	0x71,0x4B,0x33,0x0A,0xA3,0x2D,0x53,0x50,0x8B,0x48,0x73,0x05,0x86,0x1A,0xBC,0xA5,0x45,0x40,0x46,0x96,
	0x86,0x81,0xFB,0x2A,0xB0,0x48,0x3D,0x7E,0xD5,0x06,0xDA,0xCC,0x41,0x9B,0x11,0x6F,0x56,0x50,0xC7,0x46,
	0x78,0x52,0x1B,0x7F,0x45,0x04,0xB1,0x49,0x8C,0x0D,0x41,0x42,0xD8,0x82,0xB6,0x7F,0x29,0x82,0x88,0x0A,
	0xA5,0x5C,0x10,0x3D,0x64,0x3F,0x4F,0x85,0x83,0x9D,0x90,0x2D,0x36,0x48,0x8A,0xC6,0x8B,0x49,0x0C,0xB3,
	0xCB,0x6A,0x89,0x0C,0xBB,0x08,0x8A,0x01,0x06,0x8E,0x94,0x54,0x7B,0x80,0xDF,0xDA,0xC8,0x30,0x31,0x91,
	0x94,0xC2,0xEC,0xC7,0xDE,0x1F,0x16,0xF1,0x10,0xAA,0xA2,0xC1,0x09,0x39,0x16,0x1E,0x52,0xDC,0xDE,0xFA,
	0x85,0xEC,0x64,0x30,0x58,0x49,0x80,0xF2,0x33,0xA9,0x3F,0xDA,0xA2,0x8A,0x6D,0xEB,0x5E,0xA0,0xC6,0xA8,
	0xD8,0x96,0x1A,0x46,0x33,0x2E,0xCA,0x08,0x93,0x2B,0x42,0x62,0xED,0x8F,0x3C,0x0C,0x74,0xE8,0xDF,0x93,
	0xA4,0x01,0x36,0xEA,0xC5,0xF6,0xA6,0xFB,0x2C,0xC5,0x03,0x8A,0x29,0xC7,0x08,0xE8,0x98,0x12,0x2C,0xA7,
	0x27,0xE2,0x66,0x45,0x60,0x61,0x38,0x2C,0x5A,0x30,0xC8,0xE6,0x36,0x73,0xCD,0x1D,0x16,0x86,0xE6,0x99,
	0x54,0x90,0x6C,0x13,0xF0,0x77,0x54,0x7F,0xF3,0x3E,0xF0,0x6C,0x52,0x93,0x34,0x46,0x2C,0xC2,0xEE,0xE4,
	0xA0,0x48,0x55,0x4D,0xE3,0x48,0x0B,0xFB,0x8C,0xEC,0x28,0xC4,0x49,0x75,0x24,0x0B,0xA2,0x0D,0xF4,0x3C,
	0xBB,0x3B,0x71,0xB2,0xAB,0x20,0xA8,0x5B,0x8A,0x6E,0x17,0x43,0xC0,0x99,0x4A,0xC5,0xDF,0x5A,0xE9,0x5F,
	0x89,0x81,0xC9,0x48,0x90,0x82,0x85,0xBB,0x4A,0x7F,0xDB,0x37,0xF8,0x1E,0x16,0x3D,0xBC,0xF8,0x55,0x13,
	0x65,0xBF,0x1A,0xB6,0xDB,0x86,0x95,0x6C,0xBF,0x38,0x42,0xFB,0x7C,0x92,0x20,0x96,0x7D,0x2B,0xF9,0xDF,
	0x89,0x2A,0xAB,0x80,0xD8,0x80,0xBA,0xC0,0x4D,0xBD,0x2D,0xCE,0x8B,0x8C,0x6E,0x2A,0x5B,0xD5,0xB5,0x45,
	0xFA,0x2D,0x1A,0xF8,0x92,0x72,0xAA,0x37,0x31,0x13,0x8E,0x0E,0xDA,0xAB,0x15,0xCF,0x94,0x6A,0xE7,0x54,
	0x6B,0xC6,0xE2,0x4E,0xE9,0xC4,0x30,0xA2,0x8A,0x0F,0x37,0x62,0xC3,0x28,0x50,0x68,0xC0,0xB8,0x41,0x76,
	0x23,0xD4,0x0C,0x6D,0x47,0xF1,0x54,0x11,0xAD,0x68,0x16,0x34,0x45,0x3F,0x43,0xBE,0xBB,0x11,0x75,0xDA,
	0x0A,0xFD,0xD9,0x2C,0x5A,0xF3,0xE3,0x8C,0x2D,0xF7,0x1A,0xCE,0x79,0x5C,0x0A,0xAB,0xFB,0x9D,0xF7,0xF4,
	0x61,0x5F,0xA6,0xCB,0x0E,0x46,0xB1,0x49,0xC9,0x71,0xC9,0xE8,0xB3,0xC2,0x40,0x2E,0xD8,0x05,0x12,0x17,
	0x81,0x46,0x4E,0x26,0x63,0xB6,0x82,0x96,0xB8,0x41,0x1F,0x05,0xC9,0xD7,0xC3,0xD1,0x62,0x70,0x18,0x06,
	0xEC,0xFB,0x61,0x28,0x8A,0x3D,0x20,0xFB,0xBE,0x28,0x84,0xC1,0xFD,0x93,0x26,0xC2,0xB6,0x30,0x98,0x8E,
	0xA0,0x41,0x46,0x96,0x7C,0xF2,0xCD,0xCD,0xAA,0x18,0x18,0xB5,0xC4,0x34,0x58,0xEA,0xE0,0xBB,0xC2,0xF2,
	0x5A,0x4D,0x7B,0x14,0xD3,0xB1,0xE6,0x53,0xB1,0x78,0xD8,0x46,0xAB,0x5F,0x18,0xE5,0x12,0xB5,0x85,0xA6,
	0x5C,0x7E,0x9C,0x73,0xA8,0x1C,0x28,0x2C,0x29,0x48,0x86,0x12,0x66,0x70,0xB0,0xF4,0x1A,0x30,0x64,0xEB,
	0xFE,0xB8,0x68,0x78,0x35,0x58,0x46,0x3B,0x3A,0x2B,0x05,0xEE,0x7D,0xC3,0x16,0x3D,0x65,0x24,0x1C,0x5A,
	0xB7,0xAA,0x69,0x93,0x52,0xDE,0x7B,0xB7,0x2C,0x88,0xD3,0x54,0xBA,0xD9,0x1D,0x59,0x9A,0x7E,0xB9,0x24,
	0xE6,0x18,0x53,0x79,0x35,0xB4,0xFD,0xDC,0x6D,0x7D,0xB8,0x53,0x99,0xF3,0x16,0x8C,0xEE,0xDB,0x75,0x95,
	0x40,0x55,0x78,0x43,0xEB,0x54,0x07,0x86,0x0F,0x3E,0xD3,0x75,0x6B,0xB5,0x0A,0x71,0x21,0x19,0x59,0xD7,
	0xA9,0x64,0x25,0x68,0x09,0xC0,0xF3,0xFA,0xEE,0x44,0xC7,0x7F,0x5E,0x0F,0x0E,0x3A,0x84,0xFA,0xB2,0xB6,
	0x1B,0xE6,0xE1,0x17,0x09,0x3C,0x1F,0x07,0x0C,0x90,0xB2,0xE8,0x8C,0xCA,0x37,0x5D,0xAD,0x4C,0x19,0x5C,
	0x48,0xDD,0x55,0x2F,0x58,0xA4,0xD2,0x58,0x0B,0x48,0x8F,0x2B,0xB0,0xAA,0x9A,0xD8,0x14,0x93,0xA9,0x7A,
	0x38,0x9E,0xAD,0xBC,0x44,0x04,0xE8,0x2A,0xD3,0x82,0x33,0x52,0xDE,0xEB,0x6A,0xF7,0x8E,0xA8,0xAA,0xE0,
	0x14,0xF1,0x40,0x6A,0xF1,0x57,0x82,0x0C,0x61,0x17,0x14,0x3C,0x21,0x0F,0xED,0x79,0xCE,0x7A,0xE9,0x41,
	0x2B,0x72,0x2A,0xDC,0x66,0x30,0x5A,0xBC,0xB6,0xF5,0xA7,0x82,0xB4,0x2F,0x91,0x12,0xE8,0x5A,0xEA,0xA9,
	0xBA,0x84,0xDB,0x2F,0x4A,0x59,0x84,0xD9,0x9C,0x4C,0x5A,0x56,0x12,0x91,0xA1,0xDD,0x77,0x37,0xAD,0x24,
	0xC1,0xF2,0x5A,0xD4,0x43,0x47,0x6C,0x24,0xD6,0x25,0xDC,0xEE,0xC0,0x79,0x11,0xC1,0xA9,0xE7,0xCB,0x59,
	0x95,0xA7,0x90,0x56,0xB7,0x10,0x2A,0x14,0xD8,0x6C,0x82,0xA6,0xE1,0x57,0x18,0xF9,0x58,0x65,0xA4,0xD7,
	0xAD,0x1B,0x08,0xFC,0x26,0xF2,0x90,0x0A,0x9D,0xAB,0x22,0x63,0x63,0xD2,0xE0,0x62,0xBB,0x7D,0x1A,0x63,
	0x61,0xA8,0x6C,0x56,0x22,0x7E,0x34,0xD4,0x95,0xC0,0x1B,0x8F,0x95,0xBF,0xBC,0x6B,0xEC,0x85,0x81,0x03,
	0x08,0xC4,0x1F,0x37,0x76,0x24,0x3E,0x6D,0x31,0xC7,0x7F,0xAB,0x55,0x60,0xA8,0xB7,0x38,0x56,0x7C,0x13,
	0xE0,0xA2,0xB1,0x82,0xBA,0x6E,0x3E,0xF5,0xB5,0xB3,0x07,0x40,0x1A,0xA3,0x82,0x12,0x9B,0xA9,0xAA,0xED,
	0xA8,0xE6,0x7D,0x05,0xBA,0xAC,0x18,0xE9,0x12,0xBE,0x53,0xB7,0x92,0xE1,0xC4,0x8A,0xB6,0x20,0xEC,0xA9,
	0xDC,0x28,0x99,0x23,0x64,0xB0,0x1E,0x1E,0xC4,0x65,0x9F,0xE3,0xDA,0xA3,0xF3,0x82,0x2D,0x5D,0xF9,0x7E,
	0x20,0x52,0x9D,0x09,0xE9,0x3B,0x7C,0x67,0xFC,0x14,0x7B,0xDC,0x2C,0x76,0x4A,0x49,0xD8,0x7F,0xB2,0xF1,
	0xD5,0x6C,0xAC,0xBA,0xC6,0x5D,0x9B,0xF9,0x58,0xB7,0xD1,0xAE,0xD6,0xA8,0xA4,0xB1,0xAA,0xF6,0x8C,0x55,
	0xF1,0x4E,0xB7,0x81,0x44,0x76,0xC1,0x66,0x93,0x88,0x63,0x27,0x64,0xC5,0x11,0x84,0x7E,0x29,0xA6,0xB2,
	0xB5,0xFC,0xED,0xA7,0xAE,0x8F,0xA4,0xF1,0x6F,0x5B,0xD0,0xF1,0x49,0xD1,0x05,0xF9,0x1A,0x99,0x3A,0xE1,
	0x40,0x5D,0x3C,0x57,0x82,0x87,0xDF,0x35,0xB9,0x8A,0x30,0x09,0x27,0x3E,0x8E,0x10,0xD0,0xD0,0xF8,0xB9,
	0x03,0x8A,0xB6,0xF5,0x0E,0x79,0x09,0x63,0x0A,0x5F,0xF5,0x86,0xDD,0xAC,0x45,0xF5,0x52,0xB0,0xA0,0x2A,
	0x1B,0xDC,0x35,0x7C,0x54,0x55,0x66,0x0C,0xC9,0x21,0x86,0xA3,0xDF,0x6E,0x8C,0x00,0x6F,0x9D,0x58,0xE1,
	0xB1,0x0A,0x50,0x8C,0xFD,0x04,0xEF,0x3E,0x51,0xB3,0xF6,0x09,0x16,0x8A,0x23,0x9C,0x2E,0x33,0x78,0x41,
	0xAE,0x2C,0x90,0x69,0xBA,0x7B,0x5E,0x81,0xC1,0x66,0x57,0x70,0x2C,0x0E,0xFD,0xCC,0xEC,0x65,0x17,0x25,
	0x86,0x0C,0x27,0x4A,0x2F,0x6C,0x58,0xB9,0x9F,0xF2,0x7C,0xB3,0xA3,0x1E,0xF4,0xCB,0xF2,0x06,0xB6,0x5D,
	0x51,0x7B,0xA8,0x14,0x77,0x2E,0xBB,0xF2,0xAF,0x5E,0xA1,0x1A,0x5C,0x63,0x98,0xD1,0x63,0x29,0x17,0x18,
	0xB3,0x8B,0xF8,0x7E,0x08,0x9D,0x83,0x25,0x20,0x79,0x7C,0x61,0xE6,0x95,0x26,0x46,0x21,0x2F,0xC0,0x71,
	0x45,0xCE,0x9D,0xD5,0xE1,0x93,0x7A,0x15,0x0C,0x83,0x52,0x97,0xAF,0x48,0x95,0xCA,0x42,0x54,0x1D,0x86,
	0xF5,0xDD,0x7C,0xA5,0xA4,0xF0,0xAF,0x45,0xED,0x26,0x4C,0x3D,0x6E,0xE7,0x8A,0x9D,0x3C,0xF3,0xA5,0x90,
	0x4E,0xD0,0x5D,0x3B,0x70,0x5C,0xEF,0x0B,0x0C,0x50,0x3E,0x13,0x03,0x83,0x23,0x27,0x67,0x83,0xEB,0xAB,
	0xB9,0x44,0x50,0xAE,0xF2,0xFE,0xC4,0x1A,0x56,0x85,0x77,0x7E,0x2F,0x6C,0x54,0x61,0xEC,0x3E,0x84,0xA0,
	0xC0,0xDD,0x8D,0xDB,0xD8,0xE8,0x77,0xA3,0x9F,0xC3,0x97,0x4B,0xF5,0x52,0x4A,0x5D,0xAA,0x8A,0x75,0x70,
	0x62,0x25,0x74,0xAA,0x0D,0x47,0xF6,0x6D,0x22,0xC4,0xDC,0x51,0x97,0x59,0x56,0x29,0x85,0xEE,0xB1,0xC6,
	0xBC,0x4A,0x73,0x4B,0xDB,0x4E,0x34,0x0F,0x46,0xED,0xE8,0xE1,0x56,0x3D,0x87,0x01,0xF8,0xBF,0xD4,0x2E,
	0x35,0xAC,0xB2,0xE5,0xEB,0xBE,0xEC,0xFF,0xB8,0x76,0x0F,0xDF,0x32,0xFB,0xC8,0x10,0x4E,0x72,0x30,0xE1,
	0x4A,0x22,0x3C,0x42,0x12,0x3B,0x5E,0x18,0x34,0x7C,0x0F,0x6D,0x12,0x51,0x7F,0x05,0x39,0xAC,0xF6,0xAF,
	0xFF,0x73,0x88,0x31,0x99,0x3A,0xBD,0xA5,0xAD,0xA5,0xE3,0xF2,0xDC,0x57,0xE2,0x3F,0x4A,0x51,0xC7,0x25,
	0x5A,0xDD,0x9B,0xB5,0x50,0x6A,0x77,0x00,0x2B,0xDF,0xA6,0x94,0x38,0xD4,0xED,0x93,0xCA,0xC5,0xF5,0xF9,
	0x1E,0x56,0x06,0x9D,0x52,0xAF,0x03,0x61,0xA8,0xCF,0x98,0x80,0xBD,0xFC,0x07,0x2A,0xC6,0xCE,0xFC,0x8C,
	0xE2,0xBF,0xD7,0xBA,0xF6,0xA0,0xA5,0x23,0xD5,0xBB,0xA3,0x5F,0x6B,0xA0,0x9E,0xC6,0xAB,0x92,0x2B,0xE3,
	0xDE,0x97,0xA8,0xDF,0x45,0x56,0x80,0xF0,0x4E,0x7B,0xCE,0xC0,0x1B,0x55,0xF4,0x88,0x89,0xCB,0xD2,0xCA,
	0x64,0x2E,0x8C,0x71,0xD1,0x38,0x2E,0x52,0x3F,0x37,0xA8,0x06,0xA8,0x62,0xC0,0xFE,0xB6,0x96,0x4C,0xDE,
	0x25,0x6D,0xD9,0x28,0x7A,0x93,0x7E,0x47,0x97,0x4D,0x3B,0x75,0x9B,0x4D,0xCA,0x86,0xB7,0x14,0x6A,0x5B,
	0x49,0xD5,0x65,0x69,0x5D,0x78,0xEC,0x8C,0xAD,0x0C,0x15,0xEF,0x92,0x94,0x41,0x29,0x32,0xED,0x48,0x1B,
	0x26,0xE4,0x2A,0x35,0x60,0x01,0xCF,0x0D,0x37,0x0A,0xA8,0x54,0x15,0x06,0x4B,0x1D,0xC8,0xFB,0xB2,0x24,
	0x9F,0x46,0x41,0xA9,0x16,0xDB,0x51,0x8D,0xC0,0x09,0xEA,0xBF,0x61,0xD5,0x55,0x09,0xAF,0x12,0xB2,0x43,
	0x0C,0xB9,0xFC,0x5F,0xE7,0xCE,0xF5,0x42,0x97,0xEC,0xD5,0xD9,0x37,0xD8,0x7D,0xF8,0xAF,0x2A,0x8B,0x34,
	0xCC,0x82,0x71,0x55,0xDF,0xEA,0xC8,0xBF,0x40,0x97,0xC2,0xDF,0xF4,0xAF,0x80,0xA9,0x54,0x0E,0x7C,0x4F,
	0x99,0x92,0x12,0x29,0x1C,0xB0,0xE4,0xE8,0x6F,0x64,0xA7,0x64,0x22,0xCC,0xC1,0x87,0x67,0xAB,0x8F,0x4F,
	0x50,0xE7,0x12,0xC8,0xB7,0xF6,0xAA,0x7E,0xF1,0x5C,0x14,0x2D,0x05,0x41,0x09,0x7B,0x70,0x07,0x7A,0xDE,
	0x82,0xAF,0x30,0x30,0x34,0x25,0x7C,0xAE,0x48,0x2C,0x5D,0xC2,0xA9,0x4B,0x3D,0xA7,0x4F,0x70,0xDD,0xE2,
	0xEA,0x8B,0x9D,0xC5,0x58,0x2B,0xAA,0x55,0x56,0x65,0xC4,0x64,0xA0,0x08,0x87,0x3F,0xAC,0xF3,0x2F,0xDF,
	0x57,0xD4,0xC5,0xF5,0x60,0x03,0x54,0x57,0x5B,0xED,0x4A,0x18,0xD4,0x3C,0x5A,0x30,0xF8,0xA9,0x40,0x2E,
	0xDA,0x40,0x06,0xA2,0xF3,0xAF,0x8E,0xCA,0xF3,0x35,0x7B,0x46,0x37,0x26,0x0D,0xCB,0x79,0xDC,0x6D,0xA6,
	0x4B,0x9F,0x03,0xB3,0x45,0xCD,0x3A,0x7D,0xC3,0x50,0x4E,0xFD,0xD2,0x1C,0x1F,0x30,0xA9,0xE9,0xD7,0xB9,
	0xD0,0x49,0xC7,0xC9,0x2C,0xD0,0x37,0x47,0x5C,0x0C,0x43,0x76,0x2D,0xE6,0x09,0xE1,0xCE,0xB8,0xBB,0x60,
	0x44,0xAC,0xF4,0x88,0x12,0xB4,0xAB,0xDC,0x47,0x14,0xAF,0xE2,0xA9,0x4D,0x85,0x12,0x94,0x6D,0xCA,0xE6,
	0xD4,0xF4,0x00,0x0D,0x8D,0x9D,0x06,0xE2,0xF6,0xDB,0x55,0xC9,0x94,0xCC,0xE1,0x3D,0xB0,0xE0,0xAC,0x52,
	0x49,0x4D,0x55,0xA0,0x62,0x19,0x0D,0x5D,0x15,0xA9,0x07,0x7B,0x0B,0x8B,0x5E,0x0C,0x46,0xD5,0xD0,0xAB,
	0x30,0xD6,0xCA,0x51,0xC8,0xA8,0x6B,0xBA,0x7C,0xA4,0x18,0x75,0x5A,0x6D,0xD8,0xC3,0x06,0x51,0x1F,0x37,
	0x4C,0x61,0x12,0x05,0x22,0xBC,0x70,0x0F,0x4A,0xC1,0xBB,0xEE,0xF2,0xF1,0x19,0x4A,0x6E,0xE1,0x67,0xCE,
	0x5F,0x99,0x59,0xEE,0x83,0x41,0xBF,0xA7,0xE0,0x17,0xE5,0x11,0xC6,0x2E,0x24,0xE1,0x09,0xC2,0x84,0x18,
	0x7A,0xC3,0xCC,0xF3,0xDE,0x41,0x55,0x4B,0xF6,0x18,0x9B,0x87,0x55,0x96,0x26,0x2B,0xFC,0x39,0x22,0x16,
	0x78,0x58,0xCC,0x8E,0x34,0xA6,0xAA,0xB0,0x3E,0xD9,0xB8,0x12,0xB8,0x7D,0xDA,0x47,0xA2,0x23,0xC3,0x55,
	0xEE,0x1A,0xDD,0xBD,0xAC,0x31,0x62,0x58,0xBE,0xDC,0x8D,0xC9,0xC0,0x33,0x3E,0xB5,0x0C,0xDA,0xA6,0x0B,
	0x3C,0x4E,0x83,0x75,0xE6,0xCD,0xFC,0x48,0x03,0x03,0x25,0xDE,0x76,0xCF,0x95,0xA2,0x18,0x66,0x53,0x80,
	0xAD,0x4A,0x82,0x11,0x7B,0xBA,0xD0,0x8A,0x98,0x0A,0x4A,0x4E,0xA8,0xF9,0xEF,0xA7,0xBF,0x12,0x39,0x43,
	0x10,0x73,0x6B,0x52,0x50,0xD7,0x72,0xA8,0x8D,0xAA,0x5E,0x7F,0x6A,0x15,0xC6,0x1C,0xAB,0x23,0x7E,0x73,
	0x7E,0x36,0xBB,0x0A,0xEE,0xBE,0x55,0xEF,0xAC,0x35,0xD3,0x08,0xF5,0xB1,0x46,0xF6,0x82,0x80,0x02,0x2A,
	0xBC,0xCA,0x6D,0x60,0x86,0x68,0xBD,0x8B,0xF7,0x2A,0xC2,0x2D,0x03,0x77,0x85,0x4F,0x26,0x4F,0x41,0x7D,
	0x37,0xE5,0x92,0xB1,0xED,0xAC,0xF8,0x11,0xF2,0xCD,0x8A,0x8A,0x93,0x8B,0x79,0xCD,0x05,0x8B,0x44,0xE3,
	0x74,0xFD,0xAA,0xE5,0x06,0x5B,0x1D,0x35,0x9A,0xC1,0x23,0x81,0x0A,0x73,0xD6,0x80,0xEA,0x7C,0xFF,0xDF,
	0x10,0xCB,0xBD,0x97,0x2B,0x24,0x35,0x94,0x8A,0x11,0x6D,0xF9,0x5F,0xCB,0xC9,0xE8,0x3E,0x48,0x13,0x44,
	0x0B,0xDA,0x3D,0xC5,0x3B,0x94,0xF6,0xFB,0x1D,0xDA,0x38,0xE3,0x85,0xA1,0x75,0x30,0x5F,0xB4,0x0C,0x20,
	0x0B,0x0D,0x68,0xE3,0x59,0x2E,0x50,0x18,0x6B,0x58,0xE2,0x4C,0xBC,0xBA,0xD0,0xFF,0x24,0x5F,0x15,0xC4,
	0x90,0xE1,0x61,0xC4,0xBE,0x16,0xED,0xC1,0x0F,0x54,0x8E,0xAD,0x68,0x37,0x09,0xAE,0x50,0x3C,0x87,0xA9,
	0x0D,0xD7,0xF0,0xEB,0x1D,0x5D,0x42,0x7A,0x26,0x19,0x0A,0x0E,0xC4,0x9D,0x83,0x9C,0xCE,0xFD,0xD7,0x03,
	0x78,0xD5,0xEA,0x36,0xCE,0xDD,0x05,0xBE,0x62,0x6C,0xCC,0x6A,0xA5,0x5E,0x29,0xCF,0xB8,0xFE,0x8D,0xD2,
	0xFB,0xF7,0x18,0x52,0xF4,0xC6,0x25,0xA0,0xE1,0x97,0x16,0xAD,0x8D,0x18,0x97,0xAE,0xEB,0x90,0xB5,0xCA,
	0x40,0xF4,0xA4,0xB5,0xC2,0xF9,0xDE,0x93,0x83,0xF0,0xC0,0xCC,0xE5,0x02,0x92,0xD1,0xD7,0x9B,0xCB,0xAA,
	0xDF,0xC9,0xA2,0xBD,0x85,0x41,0xAE,0xBE,0xFC,0xA9,0xA4,0xBA,0x8E,0xF4,0x96,0x52,0xD0,0x50,0x90,0x5F,
	0xBE,0x9F,0x85,0x53,0x47,0x39,0x51,0x3A,0xBE,0x05,0x44,0xD0,0x45,0xCB,0x09,0x87,0xE4,0x57,0x19,0x37,
	0xFF,0x85,0x08,0x7A,0xDF,0xFA,0xA2,0xD7,0x41,0x80,0xAE,0xE5,0x44,0xF8,0x24,0x16,0x67,0x43,0xC0,0x65,
	0x62,0x25,0xA7,0x9D,0x57,0x75,0x19,0x96,0x52,0x86,0xBD,0xD5,0x32,0x29,0x99,0x1E,0x6E,0x90,0x06,0xB7,
	0x1F,0x57,0xB6,0xF6,0x36,0x71,0x6B,0xB7,0x06,0xBD,0x05,0xB4,0x08,0x1E,0x03,0x80,0xDF,0xAB,0x94,0x38,
	0xE4,0xB6,0xB8,0x69,0x6A,0x43,0xE4,0x11,0x04,0xE4,0xF0,0xBC,0xA4,0xE9,0x70,0xC4,0x24,0x2E,0x21,0x26,
	0xEF,0xDB,0xF2,0x23,0x8E,0x16,0x20,0x7C,0xF5,0x89,0x0D,0xB4,0xC3,0xCA,0xD1,0xA7,0x61,0x5E,0x17,0xCE,
	0xD8,0xD8,0x80,0xAE,0x13,0x4A,0x90,0x13,0x20,0xE3,0x7B,0x53,0xA2,0x74,0x3E,0x32,0x2C,0x3C,0x0C,0x66,
	0x24,0x08,0xC3,0xE9,0x38,0x2D,0x26,0x6E,0xEE,0x8A,0x4B,0x5D,0x1F,0xA2,0xF7,0x98,0x84,0x09,0x4A,0x86,
	0x0C,0x07,0x72,0xA0,0xAA,0x30,0xF3,0xBB,0x3F,0x04,0xD6,0x8E,0x45,0x88,0xFC,0xA0,0x25,0x2F,0x86,0x01,
	0xAE,0xD1,0x05,0x57,0xD6,0x36,0xC2,0x9A,0x6A,0x15,0x5A,0x81,0x65,0x61,0x50,0x06,0x56,0x90,0x30,0x9E,
	0x05,0xEE,0x82,0x13,0x04,0x7D,0xBC,0xE4,0xAB,0x53,0x09,0x3A,0xB6,0x4E,0xC9,0xC9,0xF9,0xB4,0x05,0x8E,
	0x8C,0xBB,0x47,0xD4,0xF6,0x47,0x76,0xB9,0xBC,0x60,0xBB,0xC3,0x2B,0xC2,0x20,0xC5,0x92,0xA4,0x00,0x40,
	0xA5,0x96,0x55,0xAE,0x94,0xD3,0xA7,0xCC,0x99,0x16,0xE6,0xA0,0xCC,0xAF,0x6E,0x52,0x75,0xB1,0xFD,0x47,
	0xEA,0xE2,0xD5,0xF1,0x0A,0xC1,0x9C,0xA8,0x47,0x68,0xAE,0x02,0x8B,0x83,0xB2,0xB3,0xB5,0xA7,0x5E,0x61,
	0xFE,0x59,0xCC,0x23,0x7C,0x95,0xF0,0xAE,0xF2,0x97,0x85,0x92,0xBB,0x85,0xB0,0x45,0x45,0xCF,0x5E,0x87,
	0xF7,0x89,0x05,0x2A,0x54,0x34,0x28,0xF4,0x7F,0xB3,0xAF,0x03,0xEA,0x5E,0xAC,0x75,0x67,0x6C,0x19,0x6A,
	0xB3,0x20,0x7A,0xEE,0x6A,0x6F,0x80,0x61,0xAA,0x32,0x78,0x55,0x66,0x0F,0xA4,0x7A,0xBA,0x8E,0x60,0xCB,
	0xCA,0x9F,0x20,0x38,0x13,0x76,0x34,0xE8,0x4A,0xAA,0xF3,0x6A,0x11,0x10,0xA4,0x04,0x3C,0x45,0xE9,0x23,
	0x2E,0x1B,0x30,0x8E,0xBA,0x8A,0xCD,0x56,0x77,0xB7,0x18,0x75,0x25,0xF1,0xBD,0x63,0x57,0x21,0x3D,0xDF,
	0xB5,0xF7,0x2A,0x40,0x27,0x5D,0x38,0xB8,0xE5,0xCE,0x04,0x6F,0xDF,0x7B,0xB2,0xE3,0x05,0x43,0x47,0x14,
	0x6B,0x78,0xB7,0xBA,0xF0,0x9F,0xA2,0xB2,0xAA,0xE5,0xCF,0xCF,0xB4,0x9C,0x59,0x15,0x52,0xCC,0x55,0x93,
	0xD8,0x98,0xF0,0xB8,0x73,0xC4,0xCD,0x56,0xF6,0xC5,0x55,0x5D,0xE3,0xB4,0x4F,0x9F,0xD0,0x2B,0xE7,0x5F,
	0x88,0xCB,0xAE,0x3A,0x68,0xC0,0xDA,0xA2,0xBA,0xE9,0xF2,0xC2,0xE7,0x4E,0xAA,0xB3,0xF8,0xE7,0xDE,0x35,
	0x04,0xFB,0x59,0xB4,0xAB,0xAB,0x02,0xD5,0x75,0xDA,0x4E,0x35,0x16,0x00,0x82,0x2B,0x8A,0xF4,0xF5,0xD7,
	0x7F,0x08,0x03,0xF6,0x28,0x24,0x8A,0xEF,0x32,0x86,0x3B,0xF7,0xE1,0x5F,0x63,0xDB,0xD5,0x06,0xF9,0x72,
	0x4C,0x1F,0xB8,0x10,0x64,0xEE,0xA0,0x0F,0xDF,0x8B,0xB9,0x6E,0x0A,0xDA,0x61,0x11,0xC1,0x34,0x34,0x0F,
	0x74,0x9B,0x60,0x5A,0x5D,0x48,0x7D,0x56,0x09,0xDD,0x16,0xF9,0x8E,0x4D,0x06,0x97,0xCA,0x49,0x41,0x8A,
	0xC9,0x2A,0x17,0xE9,0x9C,0x39,0x72,0x42,0x75,0x51,0x22,0xB2,0xD3,0x95,0x1E,0x60,0x07,0x4F,0x32,0x42,
	0x45,0xB1,0x05,0x03,0x5D,0xD2,0xD5,0x37,0x5F,0xFD,0xDF,0xFF,0xDD,0xAF,0x06,0x34,0x16,0x1C,0x09,0x49,
	0x84,0x9C,0xFA,0x3C,0x1B,0xFA,0x73,0x4E,0x87,0x2F,0x6E,0xF7,0xDE,0x2F,0x65,0x17,0x75,0x2F,0x5C,0x55,
	0x63,0x0A,0xAC,0x03,0x8A,0x34,0xCC,0xC1,0x0C,0x93,0x07,0x95,0xEE,0xA1,0xAC,0x13,0xCA,0xF1,0x99,0xFA,
	0x9C,0xAC,0xC6,0x1D,0x00,0xFF,0xB1,0xD6,0xB5,0xD5,0xA4,0x9B,0xE6,0x8E,0xEF,0x93,0x8C,0x1E,0xE2,0x1D,
	0x59,0x18,0x5E,0x1E,0xC3,0xBD,0xFD,0x6E,0xA6,0x16,0xEF,0xA4,0x00,0xD8,0xF1,0x8D,0x40,0xAC,0x2F,0x2D,
	0x77,0xE5,0x0B,0x83,0xF0,0x30,0x73,0x9D,0x7F,0x72,0xE6,0x04,0xBF,0x93,0x03,0x6F,0x35,0xAC,0x6E,0xBC,
	0x5F,0xD6,0xE4,0xD7,0x12,0x14,0xB7,0x85,0xB4,0x0D,0x28,0x6C,0x59,0x95,0x4C,0xE2,0xB0,0xAB,0xDA,0x15,
	0x0B,0x63,0x83,0x58,0x2F,0x08,0x12,0xE0,0xB3,0x80,0x6E,0xBD,0x45,0x20,0x61,0x5C,0x46,0x67,0xF9,0x91,
	0x18,0xA9,0xB6,0xF0,0xC8,0xD9,0x2D,0x48,0x2B,0x2C,0xD9,0xB3,0xAB,0x37,0x66,0xED,0x1B,0x74,0xC0,0x52,
	0xC8,0x81,0x46,0x77,0xBD,0x82,0x0E,0xBF,0x84,0x7F,0xD6,0x64,0xE5,0xC7,0xF0,0xE4,0x07,0x35,0x38,0x7E,
	0xFE,0x5F,0x56,0xDA,0x32,0x99,0x0B,0x51,0x6A,0x81,0xA3,0x00,0x40,0xF9,0x10,0x08,0x19,0x0F,0x1D,0x05,
	0x1A,0x38,0x18,0x01,0x67,0x4F,0x64,0x24,0xC1,0xD4,0x30,0x8C,0xE4,0x6F,0x0E,0xFA,0xBB,0x0B,0x00,0x78,
	0xDF,0xC8,0x28,0x52,0x89,0xD4,0x73,0x7B,0x7D,0x2D,0xD6,0x5E,0x7A,0xE5,0x63,0x49,0x48,0x45,0x39,0x36,
	0xB1,0x76,0x24,0x60,0xB5,0x78,0x6F,0x54,0x90,0xBF,0xA2,0x4D,0xEA,0x5A,0xC7,0x07,0x64,0x42,0x4F,0x98,
	0x03,0xA2,0xAC,0xBD,0xEA,0xA7,0xA9,0x01,0xAE,0x9B,0xE2,0x31,0x86,0x5F,0xEC,0x4F,0xC1,0x79,0xB1,0xAE,
	0xE1,0xBC,0x56,0x0C,0xEA,0x95,0xD3,0xA1,0x02,0xD3,0x1C,0xD8,0xA6,0x2D,0x1D,0x3A,0x0A,0x1F,0x68,0xCB,
	0xB1,0x52,0x16,0x91,0x43,0xF3,0xD1,0x15,0xF0,0xCD,0x32,0xCA,0xBE,0xE6,0x63,0xC5,0x40,0x02,0x19,0xD1,
	0xF8,0xDF,0x3F,0xEF,0xAE,0x12,0xEA,0x41,0x36,0x1F,0x42,0x06,0x26,0x1E,0x67,0x19,0xE8,0xCF,0x50,0xEC,
	0x3D,0x5D,0x10,0x9D,0xC8,0xC6,0xDD,0xED,0x10,0x95,0x65,0x10,0xD3,0x7D,0xF3,0xDF,0x9A,0x85,0x83,0x01,
	0xF1,0x80,0x2C,0x10,0x7B,0x61,0xD7,0xF4,0x0D,0xCB,0xE2,0x30,0x85,0x35,0xB0,0xE8,0xA1,0xA2,0x7B,0xE2,
	0x22,0x2C,0x9C,0x67,0x9C,0x16,0x8C,0xAB,0x4D,0x0A,0xE4,0xBE,0x92,0xE2,0x87,0x50,0x2D,0x07,0x12,0x3A,
	0x01,0xBB,0x4F,0x1B,0x2F,0x7F,0x5D,0xB4,0x62,0x5B,0xC9,0xC4,0x61,0x2A,0x3F,0x32,0xB7,0xAB,0x05,0x63,
	0x05,0xF5,0xDF,0xEC,0xB6,0xBA,0xDF,0x30,0x90,0xFF,0x05,0x79,0x8B,0xDF,0x5E,0x41,0xED,0x2C,0x30,0x0A,
	0x76,0x10,0x69,0x9F,0xF6,0x80,0xEC,0x68,0x03,0xA9,0x02,0x4A,0x06,0x7C,0x85,0x82,0xA6,0x71,0xD5,0xBA,
	0xA6,0xD8,0x3F,0x79,0x13,0x8F,0x51,0xAD,0x67,0xFF,0xF7,0xFE,0x24,0x62,0x1B,0xB8,0xB7,0xE7,0x83,0x60,
	0x82,0xB0,0x02,0x7D,0x5D,0x7F,0x2A,0x58,0xDC,0x3B,0xCE,0x01,0x40,0x14,0xED,0x6C,0x6E,0x4D,0x97,0xAD,
	0x0E,0x05,0xC9,0x88,0x68,0xC2,0xB0,0x3A,0xF6,0x29,0x80,0xDB,0xAD,0xA3,0x91,0x8A,0x83,0x38,0x34,0xE5,
	0xA5,0xC6,0x1A,0x68,0xCC,0x6C,0x5B,0x70,0x77,0xFD,0xD5,0x6B,0x2E,0x24,0x60,0xF2,0xE7,0xDD,0x26,0x6B,
	0x6F,0x51,0x45,0xBB,0x60,0x9A,0xE0,0x2D,0x52,0x31,0xCB,0x8C,0x29,0xB6,0x52,0xD8,0xF1,0xD1,0xFB,0x55,
	0x1D,0x98,0xE2,0xD7,0x1C,0x60,0xCB,0xB2,0x95,0x52,0x70,0xDA,0x44,0x1C,0xBC,0x00,0xFD,0x8B,0x32,0x03,
	0x51,0x06,0xA0,0xF8,0x85,0xFD,0x20,0xBE,0xAD,0xD6,0x05,0x07,0xF6,0x95,0xD1,0x54,0x66,0x52,0x46,0xBD,
	0x56,0xFF,0x89,0x3D,0x5B,0x84,0x9E,0x42,0xF0,0x59,0xD8,0x57,0x65,0x40,0x05,0xE0,0x1B,0x09,0xC2,0x0E,
	0x66,0x40,0x30,0x82,0xD8,0x2F,0x6D,0x79,0x2E,0x52,0x97,0x4B,0x71,0x57,0x3C,0x6C,0x8A,0xB1,0x9B,0x7E,
	0xBE,0x10,0x37,0x62,0x4D,0x4C,0x1C,0x0F,0x93,0x63,0x24,0x88,0xDF,0xCE,0x29,0x88,0xB2,0x33,0x86,0x43,
	0xB6,0xD6,0x14,0x56,0xA1,0xA1,0x89,0x6A,0x06,0x64,0x8D,0x2D,0x06,0x77,0x5D,0xE1,0x22,0xB7,0x80,0xA4,
	0x45,0x42,0x46,0x9B,0xBE,0x4E,0x98,0x2D,0x63,0xEA,0x92,0x8C,0x8C,0xF6,0x17,0x77,0xD2,0x91,0x85,0x84,
	0xAD,0x73,0x9D,0x98,0x70,0x33,0x07,0xCB,0xA4,0x45,0xF8,0xE5,0xE5,0x39,0x51,0x13,0xEB,0x01,0x3E,0xBB,
	0xD3,0xDA,0x88,0xFF,0x82,0x4C,0x43,0x8E,0xCD,0xE2,0xC2,0x61,0x0A,0xA8,0xD1,0x9D,0x2B,0x36,0xBE,0x3D,
	0xD3,0x75,0x7B,0x55,0xE2,0x35,0x4C,0x4C,0xC1,0x82,0x59,0xB1,0xDD,0x57,0xF4,0x34,0x12,0x8C,0x0B,0x0C,
	0xA5,0x18,0xD1,0x9F,0x1A,0xCE,0x09,0x3D,0xED,0x3B,0xDD,0x94,0x67,0xEC,0x49,0xE0,0x72,0x44,0x6F,0xBF,
	0x2B,0x31,0x78,0x7F,0x0C,0x96,0x6C,0x5D,0xBF,0xE9,0x18,0xE5,0x51,0xBE,0xDC,0x4D,0x60,0x0A,0xE2,0xA4,
	0x9E,0xEA,0x80,0xFD,0x84,0x61,0xBC,0x1F,0xAE,0xCA,0xDB,0x86,0x03,0x70,0x6A,0xC1,0x5A,0xB2,0xCE,0xE8,
	0xA1,0xA0,0x3A,0x03,0x9F,0x80,0x0E,0x9D,0xF8,0xBA,0x44,0x38,0x61,0x9F,0x74,0x18,0xF6,0xB8,0x2A,0x2C,
	0xAD,0x31,0xCD,0xC6,0x72,0x74,0x13,0x22,0xAE,0x92,0xBD,0x16,0x41,0x96,0x8D,0x54,0xA7,0x82,0x78,0x88,
	0x25,0x36,0x48,0xCF,0xAF,0x8A,0x54,0x8D,0x1D,0x5D,0xC3,0xC2,0xB0,0x0D,0x38,0x10,0x61,0x30,0x46,0x25,
	0xC9,0x83,0x99,0x6C,0xD9,0x10,0x79,0x42,0x42,0x06,0x41,0xD3,0x8F,0x3D,0xA0,0xC1,0xCA,0xE4,0xD9,0x27,
	0xC8,0x20,0x21,0x83,0xE7,0x61,0xED,0x0C,0x12,0x42,0x48,0x7B,0xC1,0xBF,0x97,0x15,0xED,0xFE,0x01,0x83,
	0x84,0x0F,0xFB,0x2D,0x7A,0x27,0x40,0xA3,0x44,0xA4,0x45,0x44,0xD9,0x9C,0x4D,0xB6,0xE4,0xE0,0xD3,0x17,
	0x56,0xD2,0x2D,0x0C,0xA7,0x6E,0x0E,0x73,0x1B,0x8B,0x7F,0xA4,0x74,0x2B,0x0D,0x14,0xC3,0x43,0xEA,0x60,
	0xFF,0xB4,0x93,0x8C,0x98,0x8A,0x2D,0x76,0x88,0x47,0xC9,0xD4,0x1D,0x48,0x06,0x24,0x63,0x47,0x61,0x39,
	0xB1,0x72,0x00,0x90,0x12,0x7A,0x67,0x00,0x92,0x53,0xFE,0xF1,0x84,0xFC,0x0C,0x71,0x11,0x91,0x9A,0xE3,
	0xFD,0x0B,0xAC,0x8E,0x22,0x8F,0x0D,0x2C,0x83,0x19,0xD8,0xA6,0x85,0x7B,0x88,0x42,0x60,0x66,0x37,0xE4,
	0xC3,0x88,0x75,0xEE,0x41,0x1E,0x05,0x1E,0x07,0x12,0x14,0x41,0x30,0x44,0x0E,0x3E,0xBC,0x80,0x33,0x88,
	0x85,0x52,0x40,0x3D,0xE1,0xDD,0xF3,0xC8,0xC5,0x44,0xCE,0x87,0x4B,0xF1,0x9C,0x0A,0x50,0xE9,0xE2,0x09,
	0x86,0xFA,0x2C,0xC8,0x28,0x5E,0x29,0x8B,0x1B,0x2F,0x58,0x30,0x80,0x3A,0xD9,0x9B,0x5E,0xE3,0x64,0x17,
	0x9F,0x72,0x38,0x97,0xB8,0xA7,0xD9,0xA8,0x2A,0x30,0x86,0xBF,0x92,0x6D,0xF8,0x9D,0x4B,0x5B,0x85,0x15,
	0x5E,0xA3,0x18,0x40,0x5E,0xB6,0xBD,0xAA,0x80,0x79,0x9F,0xB5,0xE5,0x87,0x65,0x82,0xCD,0x60,0x3D,0x69,
	0x55,0x5E,0x4C,0x14,0x81,0x42,0xA5,0xBC,0x42,0x31,0xB4,0xE0,0xD7,0x9A,0xC9,0xBF,0xB6,0x01,0x71,0x18,
	0xB2,0x49,0x85,0xA8,0x48,0x39,0xFF,0xD4,0x38,0xB8,0xDC,0x3A,0x9C,0x1B,0x95,0x90,0x39,0x88,0x12,0xB0,
	0x0A,0xD3,0xCF,0xA5,0x1B,0xA3,0x89,0x37,0x63,0x22,0x51,0x24,0x7E,0x35,0x2A,0x78,0xEC,0x89,0x68,0x03,
	0x20,0xCA,0x6D,0x11,0xBC,0x5D,0x3B,0xF2,0xD8,0xBA,0x63,0x11,0xED,0x64,0x2B,0xC1,0x08,0xD4,0xCB,0x17,
	0x05,0x71,0x1D,0x98,0x28,0x92,0x50,0x03,0x82,0xFB,0xF9,0xF7,0x0C,0xF5,0xA5,0x69,0x4B,0x8E,0x0D,0xE2,
	0x99,0x68,0xD4,0xC0,0xC0,0x68,0xEA,0x8A,0x60,0x14,0xE9,0x01,0x29,0xDC,0xDD,0x95,0xCC,0x50,0xDE,0xD5,
	0x72,0x61,0x24,0xAC,0x2E,0xFB,0xCE,0xC3,0xA4,0x0A,0x0C,0xCD,0xC9,0xCF,0xDF,0x32,0xB8,0x04,0x20,0x2A,
	0xC7,0x99,0x51,0xB2,0x60,0xE5,0xF2,0x21,0xB6,0x0A,0x4F,0x80,0xBE,0x41,0x47,0x74,0xB5,0xA4,0xA5,0xA3,
	0x1B,0xE0,0x86,0x23,0x2A,0x77,0x6D,0x20,0x19,0xAA,0xDB,0xD1,0xCD,0xDE,0x18,0x8A,0xA0,0x2B,0xF3,0x94,
	0x4D,0x85,0x26,0x52,0x15,0xBE,0x46,0x2F,0x88,0x31,0xF6,0xD1,0x3F,0x79,0x3F,0x33,0x7D,0x01,0x8C,0x74,
	0x2B,0x28,0x07,0x72,0xB1,0x8F,0x6C,0x57,0xA4,0x96,0x1C,0x90,0x63,0xDC,0xA7,0x60,0xEA,0x52,0x9C,0x90,
	0xA3,0x68,0x25,0x59,0xEE,0x45,0x61,0x95,0x9C,0x49,0x6C,0x2F,0x35,0x3A,0xB1,0xE8,0x5E,0x9E,0xBF,0x11,
	0x5A,0xF5,0x7A,0xC2,0x90,0x17,0x05,0xB6,0x7B,0xC6,0xBB,0xD7,0xF4,0x13,0xD9,0x3F,0x8D,0xD8,0x0A,0x23,
	0x2C,0xEA,0x2F,0x8B,0x7C,0x95,0x6A,0xDC,0x40,0x8B,0x5E,0x73,0x23,0xC5,0x91,0xDF,0x05,0x10,0xAB,0x26,
	0xDC,0x88,0x74,0x01,0x08,0x59,0x2E,0x44,0xEF,0x57,0xE9,0x3C,0x94,0xF5,0xA4,0xEE,0x8A,0x88,0xC8,0x85,
	0xF4,0x09,0xF0,0x0B,0x22,0xBB,0x00,0xE1,0xC7,0x11,0xD1,0xAE,0x97,0x2C,0xFC,0x9A,0xEE,0x01,0x40,0xFD,
	0x5E,0xBF,0x6B,0x52,0xDE,0xE9,0x64,0x45,0x55,0x87,0x68,0x40,0x25,0xE8,0xB4,0xD1,0x07,0x53,0x83,0x69,
	0xB0,0xB3,0xC0,0x86,0xEA,0x57,0x29,0xCA,0x84,0xBB,0x50,0x8B,0xB1,0x69,0x5E,0x15,0x40,0x4E,0x6E,0x68,
	0x89,0xF9,0xA2,0xD3,0xED,0x26,0x2E,0x9B,0x03,0x83,0xAC,0xFE,0xF3,0xF3,0x2F,0x27,0x26,0x7B,0x53,0xE6,
	0xCC,0x12,0x77,0x79,0xC8,0x90,0xD7,0x9C,0x36,0xA1,0x41,0x4C,0xEF,0xE2,0xA0,0x5D,0xFE,0x12,0x67,0x6F,
	0xD7,0x62,0xBC,0xC8,0x05,0x4A,0x09,0x6E,0xC2,0x08,0xD8,0x26,0x39,0xE4,0xE6,0xC2,0x86,0xF0,0x7D,0x46,
	0x70,0x55,0x52,0xD5,0xD5,0x37,0xE7,0x68,0x92,0xFE,0x87,0xAB,0x5C,0x47,0xC9,0x2F,0x4A,0x80,0xAF,0xE2,
	0x1A,0x56,0xB5,0x80,0xEF,0x34,0xCF,0x97,0x44,0x72,0xCC,0x08,0x18,0x81,0x79,0x15,0xCB,0x4E,0x2B,0x07,
	0xE4,0xA3,0x82,0x87,0x0C,0x39,0x28,0x90,0xA1,0x34,0xCC,0xF6,0x3E,0x18,0xA6,0xAE,0x94,0xDA,0xCE,0x49,
	0x6D,0x43,0x46,0x32,0x47,0x93,0x75,0x8C,0x23,0xB1,0xEE,0xF5,0x58,0xAA,0x0C,0x50,0x01,0x3F,0x49,0x12,
	0x7C,0x37,0x38,0xBC,0x69,0x85,0xBE,0xC5,0x3D,0x8D,0x22,0x54,0x90,0x21,0x19,0x66,0xB6,0x27,0x7F,0xF1,
	0x6C,0x22,0x17,0x10,0x37,0x50,0x14,0x0A,0x38,0xF4,0x73,0x15,0xA2,0x8A,0xDB,0xE5,0x33,0xB9,0x71,0xBD,
	0x16,0x65,0xD3,0x9E,0x3A,0x64,0x8B,0x6F,0x36,0xFB,0xF3,0x2D,0xF0,0xEB,0x82,0x04,0xEC,0xC8,0x42,0xC8,
	0xDF,0xB0,0x8C,0x19,0xFC,0x26,0xC3,0x75,0xA5,0xF4,0xAE,0xE9,0xCE,0xDB,0x66,0x64,0xBB,0xF9,0x68,0x57,
	0x61,0x6D,0x75,0x81,0x52,0xEC,0xC7,0x28,0xDD,0xCB,0x28,0x18,0xBB,0x60,0x14,0x41,0xEC,0xF3,0x70,0xAB,
	0xAA,0x8B,0x8A,0x7C,0xB9,0xD7,0x60,0x75,0x05,0xC8,0x5D,0xD9,0x91,0xD8,0x62,0x21,0xDB,0x55,0x63,0xD9,
	0x5A,0x11,0x14,0xA0,0xA1,0x11,0x43,0x98,0x5C,0x76,0x65,0x7B,0x6F,0x7F,0x85,0x59,0x89,0xB7,0x85,0xE5,
	0x20,0xEC,0x39,0xF3,0x17,0x11,0x21,0x62,0xFC,0x00,0xF9,0x12,0x92,0x5D,0x15,0x22,0x37,0x97,0x62,0xF1,
	0xDB,0xFB,0x07,0xE5,0xFD,0x47,0x75,0x65,0x1C,0xD9,0x60,0x00,0xA4,0x82,0xC4,0xD3,0x23,0xC5,0x7A,0x72,
	0x1E,0xB5,0x1F,0xE7,0x86,0x10,0xE8,0x93,0x38,0x04,0x75,0xC5,0x94,0xFB,0xE6,0xB2,0x31,0x9A,0x87,0xEB,
	0x57,0x4C,0x43,0x28,0x61,0x67,0xD2,0xF7,0x56,0xCD,0x66,0x46,0xCF,0xB8,0x4A,0x94,0x6B,0xED,0x4D,0xF8,
	0x5C,0x24,0x35,0x02,0x92,0xBA,0x21,0x95,0xB3,0x86,0x60,0xCD,0xE3,0x9E,0x84,0x32,0xD8,0x97,0x2F,0xD6,
	0xBB,0xC0,0xB7,0x2B,0x47,0xDF,0x77,0xD4,0xA4,0x75,0x60,0x24,0x53,0x67,0xF8,0x04,0x4C,0xE6,0x90,0xF4,
	0x09,0xCD,0xC1,0x55,0x4E,0x49,0xDA,0x6B,0x77,0x69,0x3A,0x63,0x0F,0xB4,0xB0,0x5A,0xAA,0x58,0xFA,0xE0,
	0x98,0x18,0x67,0xA9,0x42,0xE7,0xE3,0xE0,0xF6,0x21,0x9F,0x2F,0x44,0x67,0x35,0x3E,0xF2,0x37,0x43,0xFE,
	0xF2,0x90,0x89,0x78,0xBA,0x0A,0x51,0x51,0x38,0xD4,0x6C,0x29,0xD7,0x8E,0xEC,0x55,0xEE,0x28,0x47,0xE1,
	0x49,0xD6,0x02,0x97,0xC4,0xE3,0x3B,0x81,0x75,0xD8,0x54,0x1D,0x26,0x13,0xC3,0x2E,0xC3,0x40,0x48,0x43,
	0x3C,0x51,0xB4,0x70,0xBE,0xB0,0x26,0x68,0x06,0x14,0x21,0xC5,0xE5,0x0D,0xA8,0x80,0xA9,0x3F,0x40,0xE7,
	0x44,0xA5,0x5D,0xE0,0x34,0x5E,0x0C,0xD0,0x51,0x09,0x5B,0x5F,0xAD,0x2B,0x80,0x7D,0xA3,0xA9,0x06,0xEB,
	0x4B,0x94,0x3E,0x0F,0x7E,0xDE,0x3E,0x98,0x34,0x4E,0x21,0x49,0x2E,0x25,0x00,0xEA,0x36,0xBD,0x98,0xE6,
	0xDA,0xB4,0x5A,0x2E,0x16,0x44,0x16,0x83,0xB6,0x7C,0x2E,0xE7,0x8E,0xE8,0x7E,0xDE,0x2D,0xD7,0x8E,0x54,
	0x1C,0x4B,0x81,0x78,0x5D,0xEB,0xEE,0x69,0x26,0xA9,0xD4,0x62,0x60,0xE5,0xBF,0xF4,0x69,0x9D,0x5E,0x4E,
	0xBD,0xB2,0xBD,0x82,0x4A,0x85,0x05,0xED,0x85,0x92,0x97,0xC4,0x8C,0x19,0x15,0x78,0x57,0x1B,0x3C,0x43,
	0x57,0x18,0x84,0x44,0x0E,0xA9,0xF5,0x6D,0xFB,0x87,0x2D,0xB4,0x5A,0x72,0xE4,0x72,0xB0,0xC7,0x96,0x94,
	0x11,0x69,0x0E,0x09,0x5B,0x7C,0x1E,0x7D,0xB1,0x6B,0x73,0xAE,0xB6,0x07,0xA0,0x63,0x24,0x73,0xD9,0x9E,
	0x83,0xA9,0xB1,0x0D,0x54,0xC0,0xDE,0x20,0xE8,0x1A,0xA6,0xBC,0x41,0x45,0xC9,0xCD,0xD0,0x23,0xBF,0xF3,
	0x1C,0x18,0x43,0x28,0x17,0x5C,0x15,0x6D,0x22,0x90,0x34,0x8B,0x01,0xEE,0x79,0x79,0x06,0xE7,0x78,0xE1,
	0x55,0xFB,0xEB,0x2D,0x38,0x44,0x9B,0xCE,0x48,0x1B,0x19,0x98,0x18,0xBA,0x82,0xC0,0xC1,0x17,0xE1,0x3E,
	0xA4,0xA4,0x7F,0xBB,0x0E,0x7C,0x45,0xD7,0x11,0x77,0x11,0x55,0x74,0xFF,0xE9,0xE6,0x9E,0x82,0x81,0xF5,
	0x2D,0xF7,0x03,0xF3,0x76,0x8D,0xB4,0x5A,0xE8,0x21,0x5D,0x87,0xAD,0x15,0x8A,0x8A,0x22,0x76,0x07,0x16,
	0x1E,0x18,0xB6,0x6A,0x30,0x00,0xC1,0x3C,0x57,0xB9,0x64,0xDB,0xFA,0x61,0xB4,0xB0,0xB2,0x10,0x15,0x62,
	0x55,0x56,0x73,0x26,0x27,0xBD,0x6D,0x4E,0x75,0xFE,0x52,0x31,0x38,0xCE,0x25,0x94,0xB8,0xDB,0x7A,0x1A,
	0x5E,0x43,0x60,0x0C,0x2A,0xD4,0xB4,0x4A,0xCA,0xF1,0xAA,0x51,0x06,0x67,0xFC,0x43,0x2D,0x48,0x5A,0x1A,
	0x26,0x07,0xE7,0x61,0x38,0x1C,0x52,0xB2,0x50,0x0B,0xD5,0x0C,0x22,0x93,0xD1,0x61,0x28,0xA3,0xDC,0xA0,
	0x20,0x47,0xB1,0xC2,0x00,0xEC,0x30,0x5B,0x03,0xDA,0x2B,0xD1,0xEA,0xA0,0xC2,0xC4,0x50,0xA0,0x29,0x84,
	0x58,0x9F,0x06,0xB5,0x28,0xDF,0xE4,0x0D,0x22,0x8C,0x7B,0x96,0xEC,0x3D,0x66,0x75,0x18,0xA0,0x4C,0x6A,
	0x1E,0x2B,0x98,0x54,0x93,0xC5,0xA8,0x3D,0x3A,0x0D,0xB6,0xCF,0x59,0x4A,0x92,0xDE,0x47,0x8A,0x94,0xEA,
	0x10,0x73,0x1D,0xF1,0xBB,0x68,0x41,0x7C,0xBB,0xF2,0x1A,0x1C,0xA6,0x7F,0xE0,0xC0,0x5E,0xFA,0xA0,0x2C,
	0x18,0x83,0xA3,0x0C,0x03,0x8B,0xA4,0x72,0xE5,0x96,0xE8,0x28,0x27,0x3C,0xAD,0xE1,0x85,0xAE,0x71,0x63,
	0xFA,0x90,0x32,0x0A,0x26,0x53,0xEB,0x8A,0x8F,0x12,0x24,0x26,0x49,0x51,0x23,0x03,0xAE,0x3B,0x24,0x49,
	0x21,0x58,0x2C,0xD1,0x4E,0x47,0xFA,0xC4,0x11,0x90,0xC4,0xCF,0xDD,0x19,0x00,0x20,0x49,0x5E,0x4F,0xE6,
	0xE8,0x35,0x46,0x43,0xF3,0x90,0x4A,0x4E,0xCC,0xD4,0xA5,0x19,0xA8,0x87,0xAE,0x26,0x98,0x61,0x78,0xFB,
	0x3A,0x04,0x13,0x4B,0xB4,0xC5,0x31,0x66,0x3C,0xA0,0x16,0x6C,0x2C,0x93,0x10,0x33,0x9D,0xE1,0xC8,0x3C,
	0x2E,0x27,0x99,0x50,0x42,0x06,0x24,0x49,0x39,0x48,0x0B,0x35,0x27,0x38,0x64,0x73,0x8E,0x4F,0xCA,0xCC,
	0x4C,0x42,0x56,0x23,0xD5,0x71,0xD0,0x76,0x6D,0x87,0x05,0xBA,0x5D,0x27,0xE1,0x18,0x68,0xC2,0xD9,0xC8,
	0x66,0xF0,0xC8,0x95,0x57,0x22,0x70,0xFE,0x8E,0xD0,0x82,0x6E,0x4A,0xC2,0x18,0x9D,0x7D,0x90,0xDB,0x9C,
	0x61,0x88,0x08,0x03,0xC0,0xB1,0x11,0x31,0x2C,0x01,0x05,0x9B,0x2C,0x15,0xBD,0xF8,0xDD,0xB5,0x12,0xFA,
	0xA6,0x2C,0x9C,0x9E,0x88,0x08,0xD4,0x82,0x81,0xC3,0xA4,0x24,0x24,0x24,0x24,0x9E,0xD8,0xDA,0xC4,0xC0,
	0x05,0x06,0x24,0xCE,0x38,0x56,0x5C,0x9F,0xE9,0x87,0x98,0x96,0xAF,0x8C,0x0A,0x54,0xF0,0x4A,0x17,0x98,
	0xA0,0x81,0x11,0x19,0xCC,0x1A,0x0F,0x88,0x95,0x19,0x90,0x1B,0x69,0x26,0xCC,0x68,0x18,0x98,0x83,0xB4,
	0x20,0xC4,0x69,0x18,0x7D,0x78,0xD0,0xA6,0x64,0xD8,0xE8,0x7F,0x86,0x9D,0xCF,0x39,0x70,0xC7,0xC4,0x81,
	0x81,0x27,0x4B,0x86,0x21,0x80,0x4A,0x50,0x16,0x0C,0x30,0xDD,0x33,0x03,0x22,0x08,0x48,0x37,0x3F,0x29,
	0x0B,0x81,0x08,0x03,0x46,0x05,0x97,0x15,0x40,0x04,0x09,0x01,0x31,0x23,0x06,0xA8,0x31,0x41,0x42,0xCF,
	0xD9,0x08,0x88,0x20,0x21,0xF1,0xD7,0xE0,0xE3,0x13,0x90,0x1A,0x0C,0x10,0x13,0xD1,0x85,0x38,0xD4,0x83,
	0x49,0x17,0x0B,0x83,0x61,0x7C,0x02,0x02,0xB2,0xC3,0xB6,0xEF,0x6E,0x0C,0xF3,0xE0,0x29,0x63,0x43,0x58,
	0x61,0xB0,0x65,0x3B,0xC1,0x79,0xF0,0x14,0xDD,0x4E,0x43,0x6E,0x75,0x64,0x95,0xE3,0x06,0xA8,0x39,0x9F,
	0x4F,0x37,0x2D,0x6D,0x23,0x58,0x16,0x6E,0xFF,0x40,0xB2,0x60,0xC2,0x52,0x56,0xB6,0x10,0x10,0x41,0x46,
	0x48,0x72,0x89,0x30,0x21,0xB1,0x16,0x28,0x88,0x20,0x21,0x20,0x2D,0x0C,0x0E,0x1A,0xCB,0x44,0x8D,0x29,
	0xF9,0xBC,0x9B,0x21,0x20,0x42,0x59,0x18,0xA7,0xBC,0xB5,0x33,0xF2,0xE1,0x43,0x8D,0x20,0xA1,0x7C,0x40,
	0xC8,0x04,0x95,0x9B,0x97,0xBA,0xCD,0xE1,0xA6,0x52,0x18,0x91,0xB0,0x49,0x95,0xE2,0xE8,0xEE,0x61,0x86,
	0xC2,0x9A,0x4F,0x8B,0x89,0x35,0xD2,0xEA,0x24,0x0B,0x86,0x54,0x0A,0x80,0x80,0xA1,0x64,0xA3,0x70,0xC4,
	0xC0,0x81,0x0B,0xD4,0x78,0x4C,0xF7,0xA6,0xAC,0x3E,0xBB,0x0E,0x60,0xFD,0x34,0x4C,0x33,0x2A,0x9F,0xFB,
	0x5D,0x61,0x3B,0xD4,0xE8,0x83,0xB2,0x23,0x45,0x1B,0x36,0x8B,0xBA,0x9C,0x77,0x23,0xB1,0x4C,0x45,0xEF,
	0x2B,0xAB,0x6F,0xBA,0x23,0x1A,0xBF,0xAB,0x98,0x64,0x3D,0x58,0xCC,0x51,0x14,0x46,0x31,0x93,0x90,0xC1,
	0xAB,0x64,0x4D,0x77,0x22,0xA4,0xD4,0x20,0xAB,0x02,0xB4,0x93,0x23,0xD4,0xAB,0x47,0x0E,0xEB,0x29,0x1A,
	0xC2,0x88,0x85,0x6B,0x9A,0x56,0x5C,0x17,0xCC,0x52,0x24,0x75,0x60,0xF8,0x06,0x03,0xC8,0x90,0xF4,0x83,
	0x49,0x0A,0x0F,0xEE,0xEB,0x01,0x49,0x40,0x12,0xE2,0xE7,0xF6,0xF3,0xFA,0x12,0x90,0x04,0x24,0xFF,0xFE,
	0xFB,0xF2,0x24,0x01,0x49,0x40,0xF7,0xE6,0xE3,0xEA,0xEF,0x40,0x12,0x90,0x04,0x8E,0x8B,0x82,0x87,0xA8,
	0x24,0x01,0x49,0x96,0x93,0x9A,0x9F,0xE5,0x3E,0x80,0x90,0x43,0xC0,0x40,0x10,0xE7,0x45,0x97,0x28,0x49,
	0x7E,0xFB,0x03,0xF4,0x50,0x6F,0x90,0x0F,0x7A,0x73,0xF4,0x0C,0x68,0x15,0x26,0x0E,0xB8,0x42,0x6C,0xA0,
	0x9C,0x68,0x00,0xB8,0xA4,0x6D,0xD7,0x4C,0x09,0xB5,0x7C,0x1A,0x8D,0x1E,0xA3,0x36,0xFD,0x90,0x8F,0x45,
	0x1B,0x93,0x36,0xCF,0xC6,0xA0,0x8D,0xCD,0x32,0x67,0x63,0x9C,0x62,0xF6,0x66,0x10,0x64,0x05,0x45,0xDE,
	0x5C,0xDE,0xF6,0x05,0x34,0xCA,0xCF,0x00,0x44,0x80,0x80,0xC3,0x17,0xDA,0x4B,0x9E,0x1C,0x1A,0xFC,0x03,
	0xDB,0x67,0xF7,0x0C,0x80,0x88,0x0E,0xEA,0x10,0x14,0x32,0x92,0x80,0x0C,0x92,0x28,0x3C,0x22,0x20,0x0C,
	0x92,0x80,0x0C,0x24,0x52,0x58,0x6C,0x80,0x0C,0x92,0x80,0x42,0x70,0x74,0x72,0x92,0x80,0x0C,0x92,0x48,
	0x5C,0x62,0x40,0x69,0x8A,0x26,0x0B,0x29,0xA2,0xA5,0x88,0xD5,0x82,0x82,0x20,0x9D,0x7E,0x64,0x91,0xEA,
	0x3D,0xF0,0x04,0x33,0xB5,0xDF,0x36,0xA2,0xD9,0xBA,0x00,0xE5,0xE0,0xB0,0x23,0xEC,0x9B,0x18,0x37,0x21,
	0x8D,0xD8,0xE3,0xA8,0x69,0xDE,0x5C,0x2C,0x42,0x04,0xF5,0x3E,0xFD,0x8B,0x54,0xA3,0x54,0xEE,0xDD,0xD3,
	0x0C,0x0A,0xAA,0xAE,0x76,0x3F,0x78,0x88,0x19,0xB3,0xF5,0xF8,0x55,0xD9,0xAB,0x80,0x55,0x6E,0xC3,0xC9,
	0x98,0x47,0xD9,0xF6,0x5D,0xCB,0x66,0xC3,0xF3,0xEA,0x1C,0xC2,0x43,0x82,0x0D,0x78,0x1B,0x1F,0x20,0x96,
	0x0C,0x8A,0x20,0x70,0x0A,0x25,0x5B,0x8A,0xDA,0xFF,0x3A,0xED,0xDD,0xAC,0x17,0x16,0xA5,0x6A,0xDC,0x62,
	0x53,0x65,0xC8,0x20,0x22,0xCE,0x51,0x5D,0x20,0x83,0x0C,0x32,0x59,0x55,0xA1,0x83,0x0C,0x32,0xC8,0xAD,
	0x89,0x85,0x0C,0x32,0xC8,0x20,0xB1,0xBD,0xB9,0xB5,0x25,0x18,0x21,0x83,0xC1,0x30,0xFD,0x6A,0xB1,0x16,
	0x61,0xD3,0x37,0x1A,0xA0,0x5E,0x28,0x2B,0xD4,0xCC,0x70,0x25,0x4B,0xDB,0xD2,0x02,0x5E,0xFA,0xD0,0xB2,
	0x80,0x11,0x65,0x01,0xA4,0xA5,0xCB,0x58,0x8D,0x2E,0x57,0x8E,0xC1,0xB1,0x73,0x3B,0x2B,0x20,0xDA,0xFB,
	0xB1,0x87,0x05,0x7B,0x1B,0x0F,0x30,0x1F,0x3F,0x40,0xC4,0xD8,0x89,0x21,0x0C,0x5D,0x3A,0x20,0x99,0xC3,
	0x4A,0x81,0x19,0x75,0xE7,0xFC,0x22,0x34,0x21,0x48,0x3D,0xD6,0x15,0x61,0x06,0x24,0x18,0x11,0x5F,0x61,
	0xB1,0x0B,0x88,0x06,0x3D,0x89,0xF1,0x9F,0xFA,0xF1,0xC9,0x2B,0xE1,0xBA,0xA7,0x99,0x60,0x98,0xE9,0x7E,
	0xEF,0x7A,0xE4,0x71,0x8A,0x21,0x3F,0xB1,0x51,0xB4,0x03,0x48,0x9C,0xE0,0x58,0x90,0x85,0xF4,0xCE,0xC1,
	0x73,0x0C,0xC4,0x72,0x32,0x48,0x3E,0xCB,0x0C,0x27,0x54,0x61,0x95,0xA4,0x1D,0x14,0xC5,0xA1,0xC1,0xC4,
	0xEA,0x21,0x6A,0x70,0x18,0xE0,0xFA,0x89,0x17,0xFE,0x1C,0x6C,0x27,0xB9,0xD4,0xC7,0xB4,0xD2,0x87,0xF1,
	0x69,0x46,0xAC,0xFE,0x6B,0x14,0x78,0xBD,0xB2,0xF8,0x22,0xFF,0x72,0x3A,0x77,0x51,0x98,0xC4,0x04,0x6E,
	0x52,0x30,0xFE,0x5C,0x3F,0x5B,0x5E,0x1A,0x7E,0x17,0xB1,0x61,0x6F,0xB9,0xCB,0xC0,0x53,0x20,0x48,0x6D,
	0x2B,0x46,0x59,0xEB,0xAF,0x71,0xCD,0x26,0xC8,0xD2,0x2A,0x2F,0xBD,0x38,0x22,0xBC,0x20,0x6E,0xCE,0x44,
	0xC1,0x38,0x67,0xBD,0x6A,0x02,0x89,0x34,0x12,0x36,0xE6,0x0C,0x78,0x00,0x0A,0x72,0x14,0xCC,0x28,0xD9,
	0x41,0x27,0x57,0x27,0xDA,0xB1,0x23,0xEC,0x3F,0x8C,0x38,0x73,0x2E,0x94,0xA2,0xED,0x72,0xDF,0x3C,0x8C,
	0xCD,0xF0,0xBB,0x22,0x61,0x9F,0xFC,0x56,0xD1,0x40,0x61,0xFA,0xBE,0xBE,0xA1,0x8D,0x3B,0x0B,0xB1,0x99,
	0x4D,0x5F,0xD1,0xE9,0x28,0x6F,0x98,0x58,0xA2,0x90,0x88,0xD6,0x75,0x75,0x8E,0x4C,0x78,0x7C,0xDD,0xD3,
	0xA8,0xCA,0x84,0x5C,0xC4,0x08,0xDA,0x6B,0xA8,0x2A,0x1B,0x7E,0x63,0x18,0x4E,0x9D,0x0B,0x99,0x32,0xF5,
	0xB5,0x9A,0x46,0x49,0x40,0x17,0x81,0xE9,0xF8,0x37,0x99,0xAA,0x54,0xCB,0x15,0xE3,0x9C,0x1A,0x24,0x8F,
	0x74,0xE2,0x3F,0x6B,0x10,0x41,0xD7,0x9A,0xEC,0x2F,0x5F,0xD3,0xCB,0x67,0x3E,0x27,0xB4,0x5C,0x15,0x25,
	0xEE,0x39,0x52,0x5D,0xD6,0x6D,0xBF,0x71,0xF3,0x57,0x70,0xF2,0xAC,0x0F,0xB3,0xAA,0x7A,0x89,0x7A,0x4D,
	0xC0,0x54,0x00,0x4F,0xF9,0x6F,0x98,0x99,0x62,0x14,0x15,0x9D,0x66,0x40,0xC1,0x5C,0x65,0x64,0xA9,0x6D,
	0x79,0x41,0x33,0x72,0xB7,0x9E,0xBE,0x02,0x18,0x73,0x1B,0x0A,0xB2,0x0D,0xBC,0x73,0xB6,0x55,0x9E,0x80,
	0x85,0x6E,0x00,0x49,0xF7,0x4B,0xB6,0x73,0x10,0xE6,0x91,0x0A,0xB6,0xAA,0x12,0x5C,0x97,0xF6,0x4C,0x24,
	0x8E,0xCB,0xD2,0xED,0xA6,0x22,0x2B,0x4A,0xEC,0x1B,0xD4,0xE6,0x77,0x04,0xB7,0xDF,0x46,0xBE,0x8D,0x24,
	0x7C,0x1D,0xCE,0xBB,0xFF,0xC0,0xA4,0x07,0xE8,0x97,0xD2,0x3B,0x64,0x08,0xBA,0xCE,0x43,0x2D,0xA1,0x33,
	0xAA,0xCE,0x9F,0x39,0xDE,0x76,0x82,0x1D,0xC6,0x45,0x9A,0xBD,0xD7,0x51,0x90,0x21,0x03,0x9C,0x3E,0x7E,
	0x05,0xC1,0x00,0x95,0x61,0xAD,0x57,0xCA,0x71,0xE0,0x21,0x4E,0x16,0x78,0x5F,0x61,0x8C,0x53,0xAB,0x89,
	0xC9,0xF5,0x02,0x56,0x2C,0x07,0x5C,0x25,0x26,0x15,0x45,0x06,0x33,0xED,0x8A,0xBB,0x4B,0xC9,0x2A,0x60,
	0x47,0x7D,0x8D,0x59,0xE4,0x34,0x24,0x45,0x5F,0xD1,0x19,0x3C,0x49,0x64,0x90,0xC7,0xAE,0x34,0xF6,0x0B,
	0x42,0x2D,0x45,0xA7,0x30,0xCA,0x2B,0x0A,0x74,0x42,0x21,0x7F,0x05,0x61,0xD5,0xF5,0xDD,0x6F,0x8A,0x7B,
	0x83,0x11,0x43,0x85,0xD4,0xFF,0x34,0x2F,0xE5,0x37,0x35,0xAE,0xEB,0x2F,0x52,0xE8,0x5A,0x43,0x6A,0xC1,
	0x8D,0xF8,0x01,0xC1,0xB1,0xD1,0x49,0xF8,0xC1,0x2E,0xFF,0xD3,0x1D,0xE8,0xB4,0x01,0x9F,0x97,0x7E,0x1C,
	0x8F,0xE1,0xE6,0x83,0x18,0xEC,0x9E,0x83,0x5A,0x23,0x49,0xD9,0xD3,0xC5,0xCF,0x1B,0xF0,0xCB,0x19,0x45,
	0x39,0x0B,0x94,0x3E,0x3E,0x1B,0xD3,0xC1,0x6F,0xC2,0xCD,0xC6,0x23,0x59,0xDD,0xEB,0x3D,0xF8,0x01,0xA8,
	0x15,0x4B,0x8A,0x59,0xB3,0x2A,0x27,0xD5,0x8E,0xC5,0xA5,0xD2,0x88,0x7D,0xB1,0x22,0x48,0xE3,0x38,0xAC,
	0xDC,0x60,0x61,0x39,0x70,0x5D,0xC8,0x88,0x68,0x77,0x31,0xC5,0x84,0xDD,0x44,0xC1,0x4D,0x92,0x50,0x7F,
	0x9E,0x9F,0x4A,0xA2,0xA4,0xB6,0x60,0x08,0xE1,0xD1,0x28,0x2C,0x00,0x9E,0x03,0x91,0x65,0x66,0x11,0x9B,
	0xA3,0x87,0x64,0x12,0x73,0x15,0x0C,0x1C,0xA7,0x1C,0x47,0x14,0x1F,0xD7,0xB9,0x74,0xA9,0x44,0xB5,0xB7,
	0xE1,0x1A,0x4C,0x6C,0x45,0x19,0x8B,0x96,0x1C,0xF9,0xBF,0x6C,0xFE,0xCE,0xDB,0xAE,0xA3,0x14,0x63,0x13,
	0xE5,0x8A,0xFA,0xAD,0xBA,0x39,0x94,0x90,0x8B,0x3D,0x59,0x43,0xB9,0x25,0x18,0x46,0xB1,0x2B,0x09,0x72,
	0xB8,0xB1,0x7E,0x11,0x7E,0x1A,0x25,0x8D,0xD5,0x2B,0x84,0xBB,0x44,0xB1,0x71,0xD1,0x8C,0xF4,0xEC,0x2A,
	0x6E,0xA0,0xC2,0x9B,0x9C,0xAF,0x37,0x60,0x3D,0x6B,0x63,0x48,0x9D,0x31,0x68,0x62,0x5F,0xF4,0x04,0xAD,
	0x08,0x8D,0xAA,0x45,0x98,0x18,0x80,0xCE,0xF7,0x33,0xE6,0x01,0x60,0x11,0x01,0xDC,0x0A,0xAA,0xE4,0xB5,
	0x2B,0xEE,0x51,0xCC,0x8A,0x8E,0xCC,0xF4,0xCD,0xA4,0x2A,0x14,0x69,0xC2,0x89,0x84,0x6C,0xB8,0x2A,0x80,
	0x8D,0xCC,0x65,0x18,0x33,0xEA,0x83,0xF5,0x24,0x2C,0x50,0x97,0x14,0xEE,0xB5,0xB0,0xD1,0xBA,0x25,0xD0,
	0x05,0x56,0x7B,0xCF,0xCF,0xEE,0x08,0x88,0xCA,0x5B,0x93,0x3B,0x7D,0x35,0x5E,0x72,0xB5,0x54,0x2B,0xF3,
	0x83,0x49,0xC1,0xDD,0x57,0x71,0xC6,0xA7,0x60,0x50,0x3C,0xE5,0x29,0xE4,0x63,0x5D,0x67,0xF9,0x8B,0xBD,
	0xAA,0x2C,0xDD,0x31,0xD3,0xF7,0xBF,0xA1,0xBD,0x5A,0xFE,0x46,0xC7,0x2D,0x26,0x06,0x63,0x52,0x3C,0x9C,
	0x73,0x5D,0x31,0x85,0x0A,0xB1,0x32,0x2A,0x2C,0xEA,0x94,0xDD,0x12,0x45,0x56,0xB8,0x33,0x23,0x69,0x36,
	0xE5,0xB4,0x24,0x24,0x24,0xE2,0x6D,0x46,0xBA,0xD3,0x80,0x4B,0x1C,0x01,0x1D,0x18,0x00,0x67,0xD1,0x8A,
	0xE3,0x02,0x82,0x7E,0x95,0x08,0xB9,0x3F,0x89,0x98,0xFA,0x57,0x01,0x1C,0x25,0xF3,0x3A,0x7A,0x38,0xFB,
	0xCE,0x91,0xA7,0x60,0xAA,0xCE,0x7D,0xFD,0xF0,0x26,0x5F,0x0F,0xCE,0xCA,0xE2,0xEE,0x40,0x85,0x2C,0xD8,
	0xF0,0xC5,0x22,0x33,0x2B,0x04,0xA2,0x99,0x56,0x2D,0x15,0x40,0x05,0x14,0xA9,0x01,0x44,0x2E,0xC4,0xBE,
	0x81,0x4B,0x3D,0xC9,0xB0,0xD6,0x8F,0x0B,0x3C,0x7C,0x32,0x00,0x92,0x0A,0x53,0x39,0xE3,0xBD,0x27,0xF3,
	0xD4,0x64,0xE3,0x9A,0xC5,0x4B,0xD7,0x0E,0xAA,0x89,0x3A,0x24,0xED,0x94,0xB9,0x8D,0x1D,0xD3,0xD0,0xB3,
	0x8D,0x86,0x18,0x41,0x80,0x93,0x13,0xA6,0x28,0x83,0x0F,0x36,0x71,0xB2,0x53,0xBD,0x65,0x63,0xBC,0x8A,
	0xC8,0x1C,0xEF,0x22,0x61,0x9F,0x28,0x5F,0x65,0x34,0xB2,0x48,0x88,0x8B,0x74,0x2A,0x06,0xE2,0xF3,0xB2,
	0xF1,0x25,0x20,0x43,0x71,0x94,0xBA,0x6A,0xB8,0x12,0x4A,0x82,0x7E,0x27,0x81,0xCB,0xA6,0x53,0x11,0x8A,
	0xF1,0x82,0xE2,0x01,0xAD,0x8D,0x6F,0x26,0x4E,0x28,0x02,0x6C,0x15,0x11,0x54,0xE7,0xF7,0x23,0x49,0x92,
	0x44,0x12,0x9C,0xD9,0x1B,0xC9,0xFE,0x55,0xF6,0x57,0x1D,0x7F,0x40,0x7C,0x87,0x90,0x58,0xB1,0x82,0x03,
	0xCA,0x78,0x81,0xF0,0x55,0xC6,0x9A,0x1A,0xB3,0x14,0x40,0x85,0x42,0xBD,0xE8,0x3C,0x56,0x55,0xF8,0x0A,
	0xAC,0x87,0x0E,0xB1,0x86,0xA7,0x6B,0x9D,0xB5,0xB7,0xD6,0x0F,0xAD,0x52,0x96,0x38,0x8D,0x15,0x92,0x21,
	0x54,0x62,0xB1,0xCF,0x58,0x95,0x0D,0xA9,0x13,0x07,0x03,0x27,0x05,0xDA,0x85,0xB8,0x94,0x23,0x3F,0xB4,
	0xB1,0xD8,0x0B,0x13,0xB5,0x7D,0x16,0x18,0x42,0xB6,0x4E,0x05,0xE6,0xDE,0xE9,0x32,0x61,0x16,0x39,0x6E,
	0x6B,0x54,0x1C,0x1E,0x3A,0x3D,0x6B,0xA2,0x98,0x21,0x2A,0x32,0x7C,0xAF,0xC9,0x26,0xD3,0xE1,0xAE,0xDE,
	0x2D,0x61,0xC5,0xFD,0x3D,0x30,0x20,0x51,0xCF,0x05,0x32,0xBF,0xEC,0x61,0x8B,0xAC,0x66,0x34,0x1D,0xEC,
	0xD2,0x99,0xD2,0x40,0x60,0x76,0xC7,0xB5,0xF3,0x51,0x98,0xF4,0xBC,0xBC,0xC7,0x20,0x0A,0x3B,0x8D,0x94,
	0x52,0x68,0x4E,0x22,0x6D,0x3F,0xA6,0xB3,0x1D,0x57,0xEB,0x16,0xDC,0x7A,0xFC,0x2F,0xA3,0xC3,0x47,0x42,
	0x3B,0x1B,0x45,0x30,0x7F,0x4E,0x8A,0xD7,0xB1,0xC8,0xB9,0xC3,0x8C,0x48,0x7D,0x1B,0xA1,0x60,0xBE,0xE4,
	0x95,0x6B,0xD5,0x93,0x00,0xE4,0xAE,0x92,0x6E,0x84,0x68,0x60,0x44,0xBA,0x14,0xA9,0x83,0x76,0xBE,0x03,
	0x48,0x33,0xAA,0x9F,0x3B,0x45,0xA9,0x6B,0xD7,0xD1,0x5D,0xC0,0x22,0x82,0x20,0x12,0x63,0xD8,0x66,0x14,
	0xB2,0x31,0xD8,0x1F,0xF0,0x3D,0x1D,0xB1,0x0E,0x4C,0xAC,0x15,0x7F,0x0D,0x58,0xF1,0xAB,0xF6,0xC5,0x72,
	0xAF,0x0A,0x67,0x7A,0xF2,0x61,0xD8,0xF7,0x0A,0x23,0xAB,0xC9,0xB8,0xC8,0x91,0x65,0x66,0x11,0x3A,0x22,
	0xE6,0xAA,0xDC,0x6F,0xDB,0x20,0xE3,0x2E,0x19,0x05,0x2A,0xEF,0xCC,0x14,0x50,0xCA,0xD8,0xF0,0x0E,0x82,
	0xF3,0x31,0xD6,0x74,0xF6,0x44,0x8D,0x22,0x91,0xAB,0xC4,0x27,0xD4,0xF3,0x89,0x39,0x81,0xBA,0x18,0xAA,
	0x4D,0xA9,0xD4,0x8D,0xF8,0xC3,0x31,0x0A,0x04,0x32,0xF1,0xEC,0x5C,0x79,0x51,0x7E,0x2F,0x5C,0x3D,0x94,
	0xE3,0x95,0x4E,0x80,0xD2,0xCA,0xF2,0x5D,0xD2,0xD9,0x84,0xEA,0xDC,0x97,0x35,0xE9,0x92,0xF4,0x32,0x08,
	0x93,0x6F,0xB4,0xF3,0x71,0xF4,0x98,0x89,0x6A,0x49,0x50,0x80,0x18,0x40,0xFA,0x5C,0xE7,0x36,0xA0,0xD6,
	0xE3,0xEB,0x96,0x1D,0xFF,0xFB,0xA4,0x11,0x42,0x94,0xDE,0x43,0x6E,0x11,0xFC,0x78,0xFF,0x20,0x27,0x5B,
	0xEF,0x8A,0xC1,0x50,0x90,0x62,0x86,0x5D,0x38,0x06,0x1C,0xBB,0xFD,0x3D,0x32,0xA9,0x14,0xEF,0x09,0x9D,
	0x34,0x12,0x81,0xBF,0x24,0xA2,0x12,0xCC,0xA3,0x32,0x8E,0x1E,0xC3,0xC2,0x94,0x15,0x28,0x09,0x3A,0x35,
	0x4A,0x55,0xAD,0xCB,0x9D,0x1C,0x24,0x57,0xBF,0xDB,0x9A,0xDB,0x52,0x79,0xE7,0x25,0x29,0xC8,0xD4,0xA4,
	0x77,0x5D,0x68,0x69,0xBB,0x20,0xA7,0x94,0x92,0x6E,0x6F,0x4C,0xAB,0x1C,0x3D,0xE3,0x12,0x94,0x8A,0x15,
	0xD0,0x87,0xCB,0xC8,0x42,0xD8,0xF4,0xF6,0xB7,0x7F,0x13,0x3F,0x7C,0xB5,0x28,0x2B,0x82,0x19,0xEA,0xC8,
	0xAF,0x1E,0x53,0x06,0xF6,0x91,0x73,0xBC,0x41,0xC9,0xC7,0x19,0xE1,0xA6,0xDB,0xD7,0x61,0x21,0xA4,0x2F,
	0x4E,0x21,0x42,0x5C,0x9C,0x4D,0x92,0x4F,0x78,0xD4,0x3D,0x60,0xE7,0xC7,0xD6,0x85,0x1F,0x2D,0x8A,0x02,
	0xB1,0x9F,0x09,0xC7,0x75,0x83,0x39,0x73,0x3F,0x53,0xAB,0x91,0x20,0x69,0x2A,0xCD,0x0C,0x4A,0x03,0xC9,
	0x58,0x31,0xB5,0x64,0x17,0x15,0x17,0x9F,0x7C,0xF0,0x1E,0xAD,0xD2,0xA5,0x49,0x0E,0x0D,0xB4,0x9B,0xC1,
	0x08,0xD9,0xFB,0xCD,0x71,0xCF,0x03,0x57,0x48,0x91,0x3B,0x95,0x7A,0x07,0xB3,0x3E,0x4C,0x76,0xCE,0x96,
	0x66,0x8B,0x7A,0xB0,0x05,0x66,0x01,0xA3,0x2C,0x02,0x39,0xEF,0x19,0x31,0x00,0xDD,0x51,0x28,0x59,0x9F,
	0xD5,0x2B,0xE4,0x09,0xD9,0x7F,0xD3,0x2F,0x6C,0x67,0xFE,0xF0,0xD0,0x32,0x75,0xCE,0x53,0xC0,0x7C,0xCD,
	0x8F,0x4D,0xA0,0x9D,0x59,0xF5,0xF3,0x55,0xD4,0x6D,0x67,0x37,0xF9,0xE9,0xF6,0x05,0xC5,0x33,0x53,0x05,
	0xA6,0x7E,0x36,0x23,0x3E,0x4D,0x2B,0x0A,0x96,0xB5,0x2A,0xD5,0x2C,0x5A,0xEF,0x8C,0x40,0xE8,0x54,0x54,
	0x8D,0xC8,0x00,0xFD,0xD8,0x15,0xC3,0x74,0xBF,0xF6,0x66,0x33,0xC2,0x43,0x15,0x40,0x77,0xA0,0x8E,0xC3,
	0xA5,0x60,0x5D,0x7A,0xCF,0x63,0x38,0x5B,0x56,0x26,0x95,0x62,0xBC,0x86,0xA6,0x1C,0x5D,0xDC,0xDE,0x02,
	0xDF,0xA5,0x1E,0x8E,0x55,0xAD,0xA7,0xED,0x52,0x0A,0x66,0x97,0xEE,0x35,0x92,0x24,0x55,0x60,0xD9,0x3B,
	0xDE,0x49,0x0A,0x40,0x24,0x49,0xA7,0x47,0xA8,0x5A,0xA9,0x33,0x42,0xA8,0xD4,0x79,0x40,0xBF,0xE4,0x55,
	0x25,0x38,0x47,0xA6,0xA8,0x2B,0x1D,0x52,0x4D,0x9C,0xC0,0xE5,0x9B,0x88,0x76,0x9E,0xDA,0x40,0x80,0x8B,
	0x90,0x33,0xDF,0x89,0x14,0x60,0xA2,0x71,0x3C,0x8E,0xE5,0xDA,0x00,0xBD,0xF8,0x7C,0x47,0xBE,0x04,0x60,
	0xFB,0xCB,0x79,0x65,0x01,0x00,0xC4,0x60,0xE4,0x79,0x63,0xE0,0x1B,0x6D,0xE0,0x33,0x62,0x49,0x24,0x58,
	0xA4,0x1D,0x97,0xEC,0x97,0x34,0x18,0x17,0x2E,0x81,0xB0,0x0A,0xBF,0x51,0x80,0xB0,0xCF,0xBF,0x30,0x7A,
	0xCC,0xD1,0x15,0xEC,0xA5,0xC6,0x8E,0x82,0xB6,0x6E,0x89,0x64,0x8E,0x32,0x74,0x1C,0x16,0x41,0x93,0x51,
	0x10,0x42,0x72,0xD8,0x4F,0x67,0x20,0x23,0x8C,0xDA,0xD5,0x3C,0x53,0x83,0xF8,0xED,0x20,0x3A,0xBE,0x28,
	0x1D,0xBA,0x28,0x00,0xA8,0xEF,0x33,0x79,0xF5,0x1D,0xF1,0x71,0xB6,0x77,0xF7,0x90,0x77,0x1D,0xD4,0x20,
	0x0F,0x05,0x38,0xBB,0xD0,0x12,0xBF,0x70,0x38,0x89,0x1E,0x2D,0x43,0xAE,0xC2,0xDE,0x0D,0xDA,0x1F,0x67,
	0x7F,0x50,0x68,0x62,0x7A,0x7A,0x60,0x1F,0x9A,0xCC,0x28,0x38,0x7D,0x6D,0x92,0x2A,0xED,0x79,0x53,0x25,
	0x94,0x68,0x5A,0x6F,0x93,0x42,0xFF,0xA1,0x4A,0xB3,0x2A,0x14,0x76,0x39,0xAB,0x93,0x4A,0x1C,0x52,0xE3,
	0x71,0x44,0xD1,0x3E,0xD0,0x9A,0x54,0x61,0x6C,0xC4,0x19,0x61,0x60,0x83,0x77,0x34,0x98,0x86,0x35,0x60,
	0xF8,0x88,0x03,0x78,0x86,0x47,0x0E,0x21,0x8C,0xCE,0x7E,0x2C,0x74,0xFA,0x7E,0x01,0x7A,0x32,0x00,0x04,
	0xFB,0x86,0xE4,0xF6,0x46,0x3E,0x2F,0xB1,0x3B,0xFD,0x3F,0x37,0xE2,0x6F,0x35,0x77,0x68,0x38,0x68,0x7E,
	0xA5,0xD4,0xE3,0x44,0x2F,0xC3,0x36,0xF4,0xDA,0x32,0x8C,0xF0,0x39,0xA3,0xF4,0x51,0x0A,0x75,0x08,0xD6,
	0x9F,0x1F,0x4C,0x06,0x7F,0x25,0x2C,0x86,0x36,0x62,0x5C,0xD5,0x73,0x7A,0x73,0xD3,0x0F,0xD5,0x9C,0x42,
	0xBC,0x29,0x63,0xED,0x62,0xA2,0xEB,0x53,0x68,0x86,0xBA,0x47,0xF9,0xC3,0x4C,0xD2,0x86,0x57,0x71,0x78,
	0xD6,0xCB,0x39,0xDD,0x18,0x6C,0x92,0xA4,0x11,0xAC,0xB8,0x41,0x42,0x49,0x92,0x24,0x49,0x43,0x4C,0x45,
	0x5E,0x5F,0x24,0x49,0x92,0x24,0x58,0x49,0x52,0x73,0x74,0x75,0x92,0x24,0x49,0x92,0x7E,0x77,0x78,0x69,
	0x6A,0x49,0x92,0x24,0x49,0x63,0x64,0x5D,0x1E,0x27,0x24,0x49,0x92,0x24,0x20,0x29,0x2A,0x3B,0x34,0x3D,
	0x92,0x24,0x49,0x92,0x36,0x37,0x30,0x11,0x0A,0x49,0x92,0x24,0x49,0x1B,0x1C,0x1D,0x06,0x0F,0x8B,0x30,
	0x04,0x5D,0x02,0xDB,0x5C,0xF0,0xBB,0x0D,0x8B,0x26,0x01,0xA2,0xFE,0x90,0x8B,0x66,0x3A,0xD4,0x10,0xE4,
	0x99,0x90,0xCE,0xF0,0xFA,0x85,0x84,0xB3,0x90,0xCC,0xD3,0x88,0x0C,0xE4,0x99,0xB2,0x32,0x93,0x8C,0xE0,
	0xEE,0x5E,0x43,0x99,0xBA,0x9A,0x06,0x6C,0x58,0x8F,0x0A,0xB3,0xC6,0xE9,0x40,0x52,0xB9,0x39,0x02,0xFF,
	0xB0,0xC0,0x05,0x18,0x52,0x49,0x72,0x6F,0x50,0x41,0x95,0xDA,0xAC,0x0A,0x5F,0x43,0x5B,0x41,0xDD,0xCF,
	0xD1,0xDB,0xF0,0xEB,0x14,0x7C,0x25,0x36,0x81,0x8B,0x1E,0xAE,0xC3,0xDA,0xF1,0xAA,0xAF,0x25,0x43,0x93,
	0x71,0x02,0xE2,0xC3,0x69,0x52,0x75,0x04,0x28,0x09,0x73,0x87,0xBF,0x27,0x05,0x83,0xBA,0x11,0x24,0x07,
	0xC0,0x88,0x08,0x12,0x09,0x10,0xD9,0xE0,0xFA,0x44,0xA6,0x03,0x27,0x60,0xD4,0x46,0xA2,0x95,0x43,0x70,
	0x97,0x09,0x43,0x25,0x16,0x56,0x4D,0xCF,0xD7,0xC6,0x59,0xE1,0x14,0x2C,0xF2,0xB0,0xA0,0xCE,0x40,0x45,
	0x82,0x47,0xB4,0x31,0x63,0xAC,0xCF,0x54,0x95,0xA3,0xE4,0xCE,0x22,0xA8,0xB2,0xC7,0x13,0x09,0x78,0x19,
	0x1B,0x9D,0x98,0x24,0xB5,0x60,0x25,0x26,0x23,0x08,0xA6,0x64,0x4B,0x21,0x65,0xA5,0x57,0x9A,0xED,0xF0,
	0x52,0x3B,0xE2,0x5D,0x5C,0x0C,0xA4,0x6D,0x04,0x56,0xAC,0x09,0x7C,0x0C,0x8C,0xC2,0x6C,0x69,0x22,0x7F,
	0xE1,0x38,0xC7,0x20,0xD3,0x24,0x25,0x32,0x34,0x60,0x8A,0x99,0x62,0xC9,0xB5,0xA1,0x26,0x85,0xC6,0xD3,
	0x47,0x29,0x48,0xA7,0xAD,0x51,0x34,0x69,0x50,0x1E,0x43,0x88,0x9B,0xC0,0xD0,0x64,0x97,0x91,0xC6,0x3C,
	0xA2,0xE8,0xA9,0x99,0xA7,0xA4,0xEA,0xF0,0x20,0xFE,0xFB,0x16,0x15,0xF9,0xC0,0x53,0x75,0xE4,0x28,0x65,
	0x3D,0x0B,0x85,0x07,0xFF,0xAC,0x09,0x03,0xD7,0x2B,0x8A,0x0D,0x8C,0xF5,0xCD,0xF0,0xCC,0xD0,0xC9,0xCE,
	0xEC,0xD8,0xCD,0xEB,0x12,0x2C,0x55,0x9B,0x23,0x31,0x03,0x0C,0xFE,0x90,0x93,0xCD,0x26,0xA7,0x8C,0x7C,
	0x18,0x2E,0xB3,0x33,0x3E,0xCD,0xE0,0x9A,0xF8,0xA2,0x1A,0xB9,0x35,0xFF,0x66,0x60,0x06,0x19,0x5C,0xDF,
	0x26,0x26,0x95,0x62,0x90,0xF5,0x7A,0x87,0xD4,0x58,0xB7,0x45,0xB2,0x35,0x06,0x1E,0x4B,0x27,0xBE,0xC7,
	0x96,0x66,0x6F,0xCC,0x40,0xD2,0xB9,0x4E,0xEB,0x76,0xC7,0xD4,0x33,0xB0,0xD4,0x9C,0x46,0xAC,0x82,0xC9,
	0x86,0x55,0xD8,0x01,0x14,0x67,0x1B,0x85,0x96,0x82,0x49,0x11,0x48,0x72,0xA6,0x9D,0x09,0x26,0x91,0x81,
	0x6F,0x99,0x30,0xDC,0x5A,0x04,0x49,0x9E,0xAC,0xC5,0x68,0x5F,0x1A,0x06,0xA9,0x2C,0xDC,0x07,0x42,0x97,
	0x59,0x96,0x7F,0x52,0x63,0x08,0xAF,0xC0,0xA5,0x5E,0xA0,0x3E,0x79,0x27,0xF1,0xCD,0xAC,0x8B,0xC1,0x2A,
	0x65,0xBA,0x4C,0x13,0x94,0x73,0x5E,0x39,0xC3,0xD3,0xA4,0x81,0xA4,0x1E,0x32,0x93,0xD7,0x58,0x14,0xE6,
	0xAF,0x78,0x4B,0x91,0x24,0x49,0x2B,0x64,0xE1,0x5E,0x1D,0x4D,0x95,0xD8,0x77,0xEC,0xEF,0x0F,0xDE,0x82,
	0x32,0xA8,0xCF,0x8D,0x4D,0x16,0x59,0xC8,0xD9,0x19,0x49,0x12,0x90,0x54,0x7D,0xA6,0xE1,0xAA,0xDF,0xFB,
	0xB0,0x52,0x24,0x6C,0x20,0xB1,0x25,0xE6,0x96,0xA2,0x49,0x8A,0x22,0xA8,0x9D,0x65,0x64,0x86,0x94,0x8D,
	0x23,0x20,0x27,0xE7,0x32,0x26,0x49,0x12,0x90,0xE3,0xA6,0xCF,0x84,0x21,0xA4,0x4D,0x58,0xF8,0x52,0xD2,
	0xE4,0x89,0xC3,0x96,0x7C,0x2D,0x38,0x76,0xAF,0x48,0xEB,0x3A,0x64,0x46,0x01,0x49,0x57,0xBB,0xDB,0x14,
	0x57,0x40,0x40,0x92,0x24,0x38,0x4D,0xEA,0x45,0x4F,0x04,0x01,0x4D,0x40,0x4E,0x73,0x74,0xA9,0x4E,0xF6,
	0x1A,0x96,0xD8,0xAE,0x4A,0xB3,0x96,0x4A,0xD2,0x38,0x12,0x73,0x68,0x16,0x8A,0x29,0x4F,0x95,0x12,0x34,
	0x49,0x40,0xD3,0x15,0x14,0x28,0x35,0x0E,0xCD,0x98,0x76,0xD4,0x40,0xB9,0x5F,0x78,0x92,0x41,0x7A,0xCA,
	0xA3,0xCA,0xC6,0xEE,0xB3,0x26,0xEF,0x24,0x49,0x48,0x02,0xEA,0xDF,0xE5,0xEA,0x53,0x0C,0x3A,0xCD,0x84,
	0x71,0x40,0x80,0x80,0x24,0x49,0x92,0xF1,0xBE,0x0B,0xB0,0xAB,0xA0,0x49,0x02,0x9A,0xAB,0xE6,0xE3,0x97,
	0x92,0x0C,0x92,0x24,0x5E,0x57,0x18,0xC8,0xC1,0x38,0x82,0x1E,0x2E,0x9E,0x45,0xB1,0x24,0x0C,0x46,0xA4,
	0x79,0xA3,0x67,0x32,0xBB,0x6B,0x92,0x7A,0x37,0xF0,0x32,0xE1,0xAF,0x90,0x64,0x35,0xBA,0x60,0x3E,0x1B,
	0x87,0x35,0x4A,0x33,0xB0,0x4C,0x81,0x96,0x28,0x83,0xDA,0x0C,0x9F,0xE4,0xC6,0x13,0x65,0x28,0xCE,0x66,
	0x75,0xF3,0x4A,0x5D,0x85,0xF8,0x03,0x4B,0xCC,0x85,0xDE,0x28,0x30,0x21,0x49,0xD4,0x1F,0x0C,0xB8,0x79,
	0x1D,0x70,0xC0,0xAB,0x64,0x6D,0xB0,0xE2,0x16,0xB8,0x06,0x3D,0x11,0xB4,0x86,0x2D,0x9F,0x71,0xE2,0x51,
	0x9B,0xF1,0xC1,0x9C,0xE6,0xC3,0xC9,0x7C,0xD5,0x84,0xBD,0x0A,0x96,0xA9,0x76,0x47,0x48,0x77,0xB0,0x30,
	0x59,0xF4,0xB7,0x11,0xFE,0xA2,0x82,0x83,0x51,0x00,0xB6,0xAD,0x66,0xE3,0xC7,0xE0,0xB3,0xD4,0x5E,0x34,
	0x5F,0x40,0x34,0x15,0xA5,0x43,0x4F,0xF4,0x74,0x74,0xE6,0x4F,0xBE,0x43,0x11,0x01,0xB7,0x02,0x7C,0xB9,
	0x39,0x62,0xB5,0x19,0x1E,0xA5,0xAE,0xED,0x9C,0x82,0x36,0x9F,0x90,0x84,0xA6,0xC1,0x97,0x97,0xB3,0xDE,
	0x59,0x46,0xE2,0xD4,0x58,0x49,0x7E,0x15,0xCC,0x5B,0x47,0x9B,0xB5,0x8C,0x59,0x6A,0x1A,0x53,0x1A,0xE2,
	0x20,0x18,0x25,0x5C,0xB8,0xA8,0x55,0xE1,0xFD,0xF2,0x5A,0x78,0x4E,0x74,0xD7,0x9A,0xA0,0x27,0x11,0x74,
	0x12,0x2D,0xFF,0xCC,0x90,0xAC,0x42,0x04,0xD9,0x10,0x7D,0x28,0xD1,0x9D,0x11,0x2C,0x0B,0x5B,0xD9,0x22,
	0x7C,0x28,0x21,0x63,0x7D,0xF7,0x01,0x45,0x41,0x89,0xD6,0x28,0x44,0x18,0x74,0x22,0x2A,0x71,0x14,0x55,
	0x9B,0xBD,0x0A,0x1F,0x23,0xFB,0x84,0x0F,0x82,0xF0,0x37,0xB4,0xF2,0x25,0x98,0x88,0xA1,0xA2,0x33,0xAC,
	0x50,0xFC,0xEE,0xCB,0x71,0xA1,0x84,0xE4,0x51,0x1A,0x7C,0xF4,0x4C,0x50,0x23,0x3E,0x86,0xC3,0x3E,0x2C,
	0x34,0x94,0xB9,0x30,0x5C,0x60,0xA1,0xB2,0x45,0x73,0xFB,0xEC,0x51,0x49,0x92,0x12,0xE5,0x9E,0xA7,0xB9,
	0x3E,0x5A,0x09,0xC0,0xA0,0x91,0xA8,0xBA,0xD7,0xA2,0x87,0x08,0x22,0x88,0xA7,0x94,0x71,0xDC,0x20,0x86,
	0xEC,0x11,0x2C,0xDA,0xA9,0xA8,0x2E,0xE8,0x69,0x94,0x10,0x0B,0x18,0xB2,0x2B,0x78,0xE2,0x9F,0xD4,0x44,
	0xF4,0x50,0xDC,0x9C,0xE6,0x67,0x2E,0x24,0x3E,0x95,0xA3,0x98,0x32,0xAB,0xB3,0x8B,0x4A,0x34,0x79,0x70,
	0x0D,0x5F,0x36,0x34,0xFE,0xC7,0x39,0x4F,0x84,0xF5,0x63,0xFB,0xFF,0x8C,0x8F,0xF2,0x5C,0x99,0x64,0x58,
	0x04,0x76,0xB8,0x62,0x6F,0x3F,0x3E,0x7B,0x2C,0x70,0x3B,0x32,0x35,0x35,0x6E,0x8C,0xBC,0x7E,0x11,0xD1,
	0x2F,0xD3,0x0D,0xDD,0x36,0x12,0x32,0x9F,0xDF,0x62,0xEB,0xD2,0x5F,0x40,0xD0,0x5E,0x31,0x5B,0xFA,0x66,
	0xCF,0x8C,0xE1,0x3A,0x9D,0x19,0x80,0xC0,0xE7,0x77,0xA5,0x60,0x97,0xAC,0xE2,0x10,0xD5,0xF5,0x5F,0xCD,
	0x38,0xE1,0xE0,0x86,0xF8,0x11,0xF1,0xEA,0x47,0x18,0x99,0x2C,0xD4,0x29,0x65,0x23,0x8C,0x51,0x44,0x07,
	0x86,0x8F,0x1D,0x40,0x70,0xF0,0x61,0xCD,0xBC,0x86,0xF8,0x30,0xC4,0x24,0x63,0xE9,0x43,0x80,0xFE,0x57,
	0xEB,0x3F,0xB9,0x60,0xF7,0x65,0xD9,0x8B,0xB2,0x64,0x28,0x81,0x2A,0x2C,0x99,0xAB,0x31,0xEC,0xA0,0xDE,
	0x15,0x01,0x54,0xAE,0x11,0x77,0xF7,0x43,0x2F,0xF3,0x3D,0x27,0x05,0x0C,0xE6,0x6A,0x5F,0xA0,0xB1,0x0E,
	0x8A,0x31,0xBD,0x6D,0x68,0xBA,0x78,0x3C,0x78,0x58,0x07,0x5E,0x13,0xDB,0xA5,0x48,0x0D,0xF5,0x42,0xE9,
	0x81,0x6F,0x12,0xA2,0x90,0xAC,0x83,0x8C,0x8D,0xA5,0xD6,0xD1,0xC8,0xD0,0xE2,0xF5,0xAC,0x7A,0x7B,0xA4,
	0x02,0xDB,0x70,0x6C,0xD1,0xE8,0x3A,0x24,0x04,0xF4,0x51,0xC5,0x54,0x95,0x62,0xA2,0x45,0x3E,0x06,0x7E,
	0x06,0x21,0xB3,0x86,0x8D,0xA2,0x98,0x63,0x2A,0x89,0x99,0x67,0xB5,0x98,0xD2,0x35,0xA2,0x12,0xBC,0x4A,
	0x56,0xEC,0x4E,0x35,0x11,0x57,0x06,0x02,0x4A,0x94,0x68,0xAB,0x4B,0x52,0x53,0x4A,0xDA,0xA8,0x74,0xCB,
	0xE0,0xCE,0x28,0x83,0x83,0x51,0x15,0x32,0x8D,0x7C,0x58,0x41,0xCC,0x4F,0xA6,0xA1,0x5B,0x54,0x34,0x1C,
	0x83,0x3F,0xEF,0x69,0x8F,0x08,0x44,0x18,0xE9,0xAD,0x4B,0xF2,0x11,0x44,0xB0,0x18,0x60,0x90,0x0D,0x8A,
	0x09,0x09,0x09,0x83,0x8D,0xBB,0x24,0x4C,0x0D,0xAE,0x28,0x08,0x22,0x5A,0x0C,0xBE,0xBE,0x33,0x24,0x82,
	0x84,0x84,0xB1,0xD3,0xBC,0xBD,0x82,0x0C,0x12,0x92,0x5E,0xC4,0xD4,0x89,0x20,0x21,0x21,0x69,0xE7,0xE1,
	0x8A,0x20,0x83,0x84,0x24,0x93,0x6C,0x0A,0x0A,0x22,0x48,0x48,0x88,0x87,0x1D,0x2F,0x48,0xC8,0x20,0x21,
	0x49,0x41,0xBA,0x38,0x38,0x08,0x12,0x12,0x22,0xD5,0x4B,0x45,0x3E,0x1F,0x57,0x48,0x92,0x3F,0xC0,0x0A,
	0x05,0x2E,0x16,0x5A,0x95,0x48,0x48,0x62,0x6C,0x97,0x85,0x21,0x49,0x22,0x48,0x87,0x28,0x21,0x6A,0x22,
	0x88,0xF8,0x32,0x90,0x60,0x45,0x3F,0x08,0x12,0x12,0x53,0xAD,0x1E,0xF2,0x06,0x92,0x20,0x45,0x68,0x44,
	0x71,0x02,0x92,0x20,0x01,0xEB,0xC7,0xC3,0x71,0x76,0x57,0xBD,0x37,0x09,0x2B,0x4A,0x01,0x43,0xB3,0x3C,
	0x04,0x86,0xB2,0x0F,0xBC,0x53,0x33,0x2C,0x2E,0x3D,0x25,0x3A,0x4C,0x6E,0x01,0x0F,0x63,0x1F,0x0D,0xFF,
	0xDE,0x14,0xF5,0x3A,0x09,0xAA,0x2B,0xE8,0x2B,0xD8,0x65,0x15,0xF1,0x2B,0xFC,0xA0,0xA0,0x84,0x81,0x33,
	0x0D,0x3F,0xE3,0x20,0x68,0x3A,0x14,0x7E,0xE8,0x37,0x76,0xE1,0xC2,0x00,0x2B,0x30,0xEC,0x36,0x17,0xD3,
	0x12,0x14,0x41,0xBA,0x8E,0x64,0xD3,0x97,0x22,0xC3,0x05,0xC6,0xCD,0x88,0xC5,0x80,0x4C,0xCA,0x57,0x51,
	0xE8,0x92,0x83,0xC4,0x9B,0x25,0xE9,0xCB,0xDD,0x43,0xB0,0xAF,0x9F,0x10,0xEC,0x90,0xB1,0xA5,0x61,0x30,
	0xB1,0x7B,0x6A,0x15,0x6C,0xF3,0x76,0x01,0x9B,0x45,0x2F,0xE9,0x6F,0x40,0x06,0x4A,0xD7,0x6D,0x14,0x0D,
	0x70,0xC8,0x1F,0x8F,0x2D,0xD0,0x6F,0x75,0x71,0x55,0x28,0xAE,0x4A,0x31,0x20,0x11,0x97,0x46,0xF8,0x2B,
	0x2B,0x0B,0xEC,0xF9,0xD2,0xB6,0x34,0x66,0x24,0xB3,0x11,0x24,0x98,0x98,0xDF,0x7E,0x52,0x04,0x8C,0xEE,
	0x0C,0xD4,0x88,0x84,0x48,0x0C,0x14,0x89,0x75,0xA3,0x04,0xD2,0x16,0xAB,0xF8,0x4A,0x01,0x02,0x91,0x56,
	0x05,0x1E,0xC1,0xC8,0x3E,0x62,0x3F,0xF5,0x5D,0x61,0x7F,0x07,0x38,0xF8,0xF1,0x76,0xBD,0x3E,0x84,0xBD,
	0x4E,0xBA,0xA4,0xF6,0xDC,0x1A,0xE5,0x0E,0x5E,0x4D,0x6F,0x4F,0x35,0x81,0x34,0x2B,0x88,0x37,0xA7,0x7B,
	0x79,0xA0,0x36,0xAF,0xE2,0xEE,0xF5,0x8E,0xB6,0x4B,0x27,0xB4,0x2A,0x08,0x96,0xC4,0x60,0x8B,0x68,0x9C,
	0x80,0x48,0x42,0x52,0x86,0xDF,0xB1,0x56,0xA9,0xBC,0xC8,0x08,0x13,0x92,0xCD,0xB7,0xBE,0x61,0x80,0xE0,
	0x09,0xCA,0xCD,0x11,0x3C,0x01,0x19,0xCF,0xD0,0x1D,0x85,0xF3,0x17,0x50,0x81,0x6D,0x6A,0x91,0x91,0x6A,
	0x59,0x76,0xA9,0x3F,0x97,0xCF,0x54,0xFE,0x03,0x12,0x86,0x46,0x33,0x61,0xEB,0x1D,0x90,0x23,0x5D,0xD2,
	0xE7,0xCC,0x08,0xC1,0x54,0x67,0x01,0x7D,0xF0,0xED,0xB4,0xCA,0x90,0xE9,0xC8,0xAB,0x61,0x00,0x10,0x9A,
	0xFA,0x72,0xA5,0x28,0x60,0xE3,0xC0,0xFE,0xEB,0x55,0x33,0xF6,0x78,0x87,0x12,0x97,0xFF,0x35,0x53,0x41,
	0xD2,0x41,0x75,0x30,0xD1,0x05,0x1D,0xC7,0x47,0x18,0xEC,0xF4,0x4A,0xA5,0x08,0x3C,0x70,0x75,0xF2,0x77,
	0xCF,0x61,0x12,0xC1,0xD4,0x1F,0x24,0xEE,0xDF,0x5E,0xFF,0x70,0xEF,0xA8,0xD6,0x7A,0x63,0x1D,0x92,0x96,
	0x93,0x88,0x5F,0x00,0x10,0x53,0xE6,0xA6,0xAB,0xD5,0xF6,0xFF,0x89,0xFD,0xA5,0x66,0xAB,0x2A,0x24,0x74,
	0xB9,0x3F,0x4C,0xB9,0x06,0x03,0x11,0x03,0x3A,0x8A,0xBA,0xF8,0x07,0x8D,0xA3,0x89,0x83,0x84,0xD5,0x41,
	0x40,0xA4,0x6A,0xA9,0xAA,0xB4,0xB4,0xE3,0x51,0x45,0x18,0x0D,0x74,0x63,0x1A,0x22,0x26,0x4B,0xD0,0x28,
	0x69,0xFB,0xDD,0x72,0xDD,0xDC,0x33,0x28,0x42,0xFE,0x7F,0x2A,0x2E,0x7B,0x48,0xBA,0xB8,0xD0,0xA5,0xDD,
	0xAF,0xFD,0x85,0x3C,0xFB,0xAB,0x7E,0x27,0x09,0x7F,0x7D,0x44,0x60,0x40,0x5C,0x21,0x2C,0x9D,0x11,0xCB,
	0x19,0xED,0xDA,0xE4,0x27,0xFB,0x22,0xD2,0x17,0x4B,0xF5,0x81,0xE9,0x08,0x92,0x7F,0x65,0x5C,0x81,0x8D,
	0xFB,0x3F,0xA9,0xF1,0x7C,0x12,0xBD,0x62,0xA1,0x38,0x4C,0xF5,0x62,0xDD,0xA0,0x20,0x85,0xB6,0x97,0x55,
	0x6E,0xC0,0x31,0x00,0x75,0x46,0xE4,0x64,0x99,0xC2,0xEC,0xAC,0xAD,0xA7,0xC2,0x73,0x7C,0xD8,0x10,0x02,
	0xA4,0xA8,0x0C,0xCF,0xB0,0xF0,0xB7,0x39,0x87,0x34,0x5A,0x0A,0x53,0x31,0x95,0x86,0x96,0x1A,0xC7,0xF8,
	0xAF,0x18,0xA8,0x8B,0x42,0xB2,0x28,0x5F,0xDE,0xAC,0x58,0x26,0x34,0xEE,0x50,0xE0,0xE1,0x74,0xC9,0x04,
	0xDC,0x13,0x71,0x2F,0x16,0xC2,0xAE,0xD6,0x2D,0xFB,0x85,0x6C,0xF6,0x60,0xC0,0x6C,0xF3,0x0C,0x7F,0x35,
	0xFA,0xB1,0xF1,0x5F,0xD7,0xA6,0x21,0x51,0x80,0x0C,0x66,0xA6,0x19,0x15,0x75,0x16,0x2A,0x44,0x98,0xE0,
	0xB0,0x04,0x5D,0xC3,0xC1,0x48,0x52,0xB0,0xA7,0x5F,0xB9,0x63,0x30,0x98,0x33,0x73,0xA0,0xC8,0xE8,0xAA,
	0x5F,0x87,0xF1,0xC9,0x9D,0x40,0xA4,0xAC,0xE4,0x0E,0x0C,0x48,0x36,0x5F,0xA8,0x0F,0x50,0xD0,0x24,0xC1,
	0xFC,0x59,0xF2,0x5B,0x12,0x55,0xAE,0xA4,0x4B,0xF5,0xC1,0x33,0x0E,0x8C,0x5A,0x7C,0x27,0xA9,0x8B,0x94,
	0x42,0xC8,0xD0,0xA8,0xD3,0x10,0x0B,0x83,0xCE,0xD3,0x61,0x9E,0x1C,0xDF,0x01,0xD0,0x0E,0xF0,0x40,0x5D,
	0x59,0xA2,0x57,0x80,0x76,0x8D,0xEC,0x97,0x76,0x3B,0x15,0x0C,0x22,0x02,0xCA,0x12,0xE3,0xF4,0x38,0x5E,
	0x62,0xAD,0x37,0xE0,0xA8,0xC1,0x92,0x28,0x5D,0x67,0xDC,0xE4,0x7D,0x3F,0xED,0x2F,0x7F,0xF3,0x6E,0xBD,
	0x4C,0x95,0x4F,0xE6,0xFD,0x38,0xD9,0x1F,0xEE,0xFC,0x15,0x1C,0x30,0x8A,0x60,0xA0,0xF4,0x9D,0xF5,0x8B,
	0x60,0x2C,0x50,0x35,0xA8,0x60,0xB7,0x36,0xEC,0x1E,0x0E,0x1B,0x39,0xEA,0x8E,0x1D,0xD2,0xB0,0x10,0x8F,
	0xAB,0xAD,0x89,0xAE,0x7D,0x84,0x6B,0xB0,0x5F,0x5E,0xE2,0x22,0x3C,0x8B,0x48,0x38,0x42,0x7B,0x3B,0x06,
	0x46,0xF3,0x7F,0x61,0xC9,0xF0,0xF7,0x77,0xFC,0x0A,0xDF,0x9A,0x58,0x34,0x30,0x53,0xA9,0x17,0x4B,0xB9,
	0x30,0x4B,0x26,0x0B,0xA4,0x36,0x3C,0x1F,0x8B,0x2F,0x7E,0x1F,0x42,0x0A,0xFA,0xCB,0x33,0x75,0x12,0x4D,
	0x2D,0x37,0xF4,0xB2,0x41,0x61,0x6F,0x6B,0x9D,0xE3,0xB3,0x68,0x13,0xE4,0xB4,0x10,0x87,0x03,0x55,0xFB,
	0x7F,0xA7,0xA8,0x2F,0xB5,0xD8,0x31,0xFD,0x1A,0xD9,0xD3,0x45,0x41,0x95,0x4B,0x4D,0x18,0x3E,0xA8,0xF6,
	0x1D,0xC8,0x08,0x22,0x44,0x5C,0xD8,0xF2,0x85,0xB1,0x8F,0x32,0x29,0x26,0x1A,0xAF,0x47,0x46,0xEE,0xA9,
	0xB5,0x35,0x7F,0x35,0xA9,0xFF,0xE2,0x0D,0x1C,0x90,0xDF,0x45,0x60,0xF4,0x61,0x87,0x41,0x60,0xE0,0xEF,
	0xB2,0xC1,0x05,0xFA,0x8F,0xAA,0x2F,0x09,0xB8,0x4E,0xFF,0x3E,0x2E,0x77,0x23,0x7B,0x99,0xA7,0xE1,0x51,
	0xE9,0x0B,0x17,0xC7,0x15,0x5D,0x13,0x17,0x07,0x11,0xBF,0xEF,0x40,0x5E,0x1B,0x03,0x64,0x28,0x42,0x68,
	0x73,0x75,0x70,0xC5,0xF6,0xF1,0xC7,0x2B,0x99,0xC7,0x3A,0x9F,0xA6,0xB7,0xE0,0xD8,0x1C,0xB5,0x77,0x21,
	0xDC,0xE0,0xF0,0x04,0x0E,0x99,0x9E,0x45,0x46,0x9E,0x11,0x8D,0xEA,0x13,0xB4,0x04,0xB4,0x7E,0x14,0x91,
	0x0E,0x28,0xE0,0x65,0x9B,0xB4,0x55,0x91,0xAC,0x75,0xB9,0xFA,0x87,0x1A,0xF2,0xAF,0xA0,0x4F,0x2F,0xE9,
	0xEB,0xAD,0xB0,0x28,0xF8,0x2E,0x56,0x35,0x0C,0x30,0x76,0x37,0xBE,0x97,0x01,0x82,0x27,0x21,0x35,0x7F,
	0x55,0x79,0xAA,0xEC,0x1F,0x86,0x41,0xE0,0xC1,0x88,0x4D,0xCD,0x73,0x9C,0x26,0xD6,0x26,0x0F,0x1F,0x80,
	0x1F,0x8B,0x4D,0xD4,0xD9,0x3C,0x36,0x77,0x4B,0xDF,0xB0,0x55,0x39,0x9D,0xEB,0xF1,0x59,0x7A,0xDC,0xF0,
	0x82,0xE7,0xC5,0xFE,0x8F,0x8E,0xF8,0xD2,0xCD,0xFA,0x6E,0x64,0xEB,0x8B,0x18,0xED,0x9F,0xFD,0x04,0x63,
	0x91,0x77,0xC3,0x72,0xB4,0x81,0x49,0xB6,0x48,0x90,0x52,0x9B,0x5C,0x7F,0x14,0x64,0x51,0x4A,0x4A,0x02,
	0x99,0x57,0x3D,0x1D,0x77,0xA9,0x73,0x19,0x10,0xA4,0xFF,0x11,0x46,0x50,0x38,0x38,0xA3,0xF7,0xB9,0xFA,
	0x58,0xFE,0x05,0x70,0x66,0xB8,0x63,0x17,0xCA,0xFF,0x28,0xFC,0x1A,0xA3,0x3B,0x44,0x63,0xE5,0x62,0x70,
	0x7E,0xF2,0x57,0x16,0xB6,0x87,0xA7,0x5F,0x3D,0x79,0x7A,0xE7,0x0C,0x4B,0x30,0xB4,0x45,0x41,0x4D,0x0A,
	0xF0,0x83,0x3D,0x49,0xD5,0xF4,0x85,0x07,0x27,0x26,0xFA,0x8B,0x51,0xDD,0xC0,0xDD,0x42,0x66,0x8C,0xF4,
	0xE2,0x2A,0x6A,0xAE,0x97,0xAF,0xAA,0x6E,0xFE,0xA5,0x39,0x5E,0xF5,0x1E,0x69,0x05,0x19,0xC0,0x53,0x37,
	0xA0,0xBB,0xA3,0x46,0x9B,0xC3,0x45,0x59,0xBE,0x58,0xDD,0x9E,0x3C,0x81,0xD3,0x07,0x5D,0xC9,0xC8,0xBF,
	0x0A,0x71,0xBE,0x4A,0x54,0x81,0x5D,0xF7,0x60,0xFA,0xB5,0x6E,0x82,0x80,0xF3,0xC5,0x0F,0x83,0x43,0x1B,
	0x55,0x9F,0xFD,0xAD,0xC2,0x57,0x04,0x04,0xFF,0x93,0xD4,0x56,0xE6,0xF1,0x93,0x25,0xEE,0x1F,0x99,0x3F,
	0xA6,0x33,0x9B,0xA3,0x6D,0x06,0xC5,0x2B,0x82,0x37,0xA4,0xE2,0xE8,0x5F,0xD5,0x93,0x64,0x47,0xCC,0x72,
	0xAE,0x6E,0x8B,0xAB,0xFA,0x47,0xFD,0xC3,0xAC,0x16,0xB1,0xB8,0xC8,0xFF,0x8A,0xD2,0x69,0x52,0x5F,0xE3,
	0x7C,0xF5,0xAB,0x02,0xE3,0xE9,0x2B,0xA6,0xF5,0x2C,0x5A,0x57,0x91,0xDF,0xBA,0x25,0x62,0xD1,0x49,0x65,
	0x45,0xF7,0x92,0xE9,0x5F,0x05,0xAC,0x2F,0x3D,0x13,0x8B,0x27,0xA5,0xF5,0x41,0x89,0x59,0xBF,0x62,0xC4,
	0xAE,0xAF,0x70,0xEC,0x97,0xD2,0x96,0x04,0xB3,0xA6,0x95,0xCF,0x90,0x0A,0xC2,0x6E,0x67,0x77,0xA8,0x6E,
	0x80,0x5C,0xA4,0xEB,0x26,0xFF,0xD9,0x6B,0x03,0xD6,0x8A,0x5F,0xF0,0xAC,0x05,0x96,0x98,0x8C,0xC8,0x28,
	0xFC,0x4A,0x73,0x17,0x38,0xE3,0x41,0xC6,0x44,0xC1,0x80,0x88,0x4C,0xD1,0x5D,0x45,0xFB,0x59,0x2A,0xB2,
	0xF5,0x75,0xFE,0x58,0x15,0xE2,0x77,0x7D,0xA4,0x62,0x29,0x98,0x73,0x97,0xBA,0x33,0x90,0x61,0xD0,0x8C,
	0xAC,0x78,0xE8,0xF1,0x8D,0xFB,0xF2,0x35,0x29,0xA4,0x5C,0x4B,0xC9,0x4D,0xF6,0xF8,0xCF,0xE4,0x62,0x53,
	0x61,0xC2,0x5D,0x67,0x56,0xF7,0x27,0x01,0xEF,0xA1,0xF2,0xA6,0x8E,0x37,0xAD,0x66,0x6B,0xD2,0x53,0x6D,
	0xE9,0x3B,0x22,0xEC,0xEB,0x59,0xF0,0xDB,0x1E,0x50,0x97,0x02,0x7E,0x72,0x1A,0x81,0x1D,0x8C,0x30,0x40,
	0x93,0x78,0xC5,0xB8,0xF8,0x79,0x03,0xDB,0xFA,0xCA,0x93,0xFE,0x4B,0xAB,0xCD,0x02,0x95,0x45,0xB8,0x2B,
	0x0C,0xB0,0xF6,0xCD,0xBB,0x29,0x51,0x1D,0xCB,0xE0,0x87,0xB3,0xFF,0x81,0x92,0xA9,0x2F,0x71,0x07,0x8D,
	0x7C,0xE2,0xDF,0x00,0xA7,0x3A,0x9A,0x3B,0xD3,0x27,0xB9,0x1A,0x2D,0x70,0xC0,0xBE,0x9D,0xDB,0x6C,0xDD,
	0xBC,0x4F,0x12,0x32,0x9E,0x25,0x2C,0xDF,0xE2,0xD0,0x3C,0x69,0x0A,0xD2,0xB2,0xDE,0x3F,0xD7,0xB9,0xF3,
	0xD7,0xA2,0x70,0x4D,0xE1,0x5A,0xB9,0xAA,0x70,0xE9,0x82,0xB1,0x5D,0x96,0xC2,0xEC,0xA8,0xFB,0x4D,0xCD,
	0xB4,0x39,0x79,0xB4,0xE5,0x0A,0xE3,0x42,0x19,0x3C,0x53,0xBF,0x46,0x13,0x1F,0x49,0x34,0xE3,0x9B,0x1C,
	0xE5,0x2C,0xB0,0xAE,0x5D,0x88,0x72,0xAA,0x93,0xB9,0xC4,0xEA,0x69,0x9A,0x8F,0x01,0x02,0xBF,0x91,0xFE,
	0xFD,0x38,0x02,0x4E,0xEF,0xD3,0xDA,0x07,0x08,0xA3,0x0D,0x4B,0x0D,0x91,0x27,0x19,0x0E,0xD2,0xA4,0x4D,
	0x70,0x12,0x9F,0x97,0xF2,0x72,0xBF,0xAD,0xDC,0x33,0x8D,0xBA,0xCA,0xA6,0xDF,0x29,0xC6,0xE6,0x5F,0xAC,
	0x0E,0x6C,0xB7,0xB5,0x21,0xCD,0xCF,0xE6,0xA5,0x28,0xFE,0x09,0x18,0x60,0xF0,0x24,0x5F,0x27,0x85,0x1B,
	0xF4,0xE5,0x37,0xEC,0x6F,0xAF,0x5B,0x8A,0xE6,0x3F,0x0A,0xED,0x52,0x08,0x64,0x70,0xF2,0xA9,0xC4,0x69,
	0x57,0xF5,0x1E,0xC3,0xE0,0xDB,0x3C,0xAF,0x0E,0x05,0xD4,0xB5,0xE1,0xA7,0x4D,0x7F,0x09,0xA6,0xA2,0x79,
	0xF1,0x95,0xFA,0xEB,0x0A,0x71,0xE4,0x66,0x68,0xE6,0x15,0x1B,0x37,0x9C,0xB1,0x75,0xF8,0x46,0x35,0x70,
	0x50,0x47,0x75,0x44,0xDA,0x4C,0xF4,0xAF,0xE1,0xE8,0x03,0xED,0x2E,0x5E,0x78,0x28,0x8F,0x29,0x56,0x1F,
	0xCB,0xC9,0xBD,0xBD,0x2A,0x7F,0x51,0xE2,0x7B,0x13,0x1F,0x9D,0x99,0x2D,0xA5,0xD4,0xB2,0x85,0xAE,0x30,
	0xDE,0xE7,0xFF,0x98,0x77,0xDF,0x7B,0x31,0x91,0x11,0x88,0x97,0x05,0x49,0x7B,0x89,0xCA,0xEC,0xEE,0x46,
	0xF7,0x73,0xF5,0x7B,0x29,0xAD,0x57,0xCB,0x88,0x42,0xA5,0x66,0x09,0xBD,0x75,0x06,0x03,0x5F,0x93,0x3B,
	0xB7,0xD7,0xFE,0x59,0xD5,0x57,0xE7,0x16,0xF5,0x11,0x91,0xEB,0xE2,0xB7,0x3C,0x43,0x48,0x8C,0x16,0xAE,
	0x70,0x40,0xD3,0xB7,0xC1,0x2C,0x7A,0x09,0x51,0xC1,0xB2,0xE7,0x37,0x60,0x30,0xF6,0x17,0x32,0x90,0x27,
	0xE8,0x2A,0x0B,0x99,0x59,0x6B,0x63,0xDF,0x7D,0x62,0x89,0xB1,0x54,0x29,0x3F,0xC7,0x45,0x35,0xB0,0x02,
	0x12,0xC1,0x83,0x69,0xFF,0xCE,0x70,0x70,0x83,0x0A,0x9E,0x87,0xA7,0xE5,0x21,0xBB,0xAF,0x34,0x02,0xFB,
	0x17,0x6E,0x5B,0xD5,0x4C,0x50,0xD0,0xF2,0x98,0x71,0x3B,0xDE,0x32,0x86,0x2D,0x30,0x23,0xBD,0xF7,0x98,
	0x1E,0x02,0x99,0x9B,0x41,0xDB,0xDF,0x39,0xBD,0xC1,0x38,0x60,0x09,0x83,0x8F,0x2F,0xDC,0xC9,0x48,0x69,
	0xEB,0x92,0x18,0x71,0x82,0x99,0x11,0xA0,0xA6,0x70,0x4B,0x3D,0x4D,0xEC,0x16,0x52,0xE2,0xAE,0x01,0xE0,
	0x2C,0x65,0x8B,0x89,0xFA,0x92,0xB1,0x80,0xB3,0x01,0x51,0xA2,0x85,0x83,0xF3,0x28,0x7D,0xF3,0x33,0xBF,
	0xD2,0x16,0x1E,0x51,0x86,0xBF,0x92,0xDE,0x24,0x67,0x73,0x3E,0x01,0xBB,0x67,0xB0,0x52,0xF8,0x6F,0xEB,
	0x43,0xAB,0xE9,0xDF,0x80,0x2C,0xFA,0x46,0x05,0x0B,0x5F,0xED,0x38,0xD5,0xA1,0x93,0x31,0x60,0x37,0x00,
	0x40,0x1D,0xFD,0x64,0x18,0x99,0x3F,0x95,0xD3,0x28,0x06,0xD0,0x48,0x2E,0x5D,0x36,0x7C,0xBB,0x0F,0xA6,
	0x7D,0xCC,0x95,0xEC,0x4B,0x65,0xB2,0x68,0x6C,0xA6,0xCA,0xF8,0x62,0xE4,0x0F,0xBC,0xBE,0xA2,0x6A,0x54,
	0xCE,0xFC,0x33,0xA1,0x8A,0x15,0xC6,0xC9,0x39,0xD9,0xEE,0xAC,0xE3,0x92,0x2A,0xB5,0x74,0x5F,0x51,0x75,
	0x86,0xAB,0xC9,0xD0,0x0D,0x26,0x9B,0x88,0x27,0x8B,0x19,0xC3,0x9C,0xB0,0x2D,0xC7,0xEA,0x2B,0x6E,0xF9,
	0x8B,0x08,0xC6,0x51,0x38,0x1F,0xB1,0x17,0xEF,0x28,0xC1,0x5D,0xD9,0x69,0x0B,0x55,0xDF,0x6F,0xA5,0xEF,
	0x8D,0xD2,0x6A,0x65,0xE4,0x95,0x25,0x24,0xA6,0x5A,0xFB,0x9F,0x1C,0x92,0xF4,0xE9,0xB9,0x9F,0x5C,0x66,
	0xBB,0xA7,0xFC,0x53,0x2C,0x4D,0x7A,0x15,0x51,0x24,0x0A,0x21,0x11,0xAD,0x2B,0x90,0x6A,0x9B,0x55,0xE3,
	0x84,0x87,0x06,0x6D,0x3E,0x73,0x0A,0x0D,0x35,0x58,0x54,0x02,0x8A,0x1C,0xB0,0xE2,0x91,0x2D,0xB0,0xE7,
	0x8C,0xCE,0xA8,0xA5,0x23,0x3D,0xBC,0xB5,0x6B,0xF1,0x89,0x2F,0x6F,0x0C,0x59,0x48,0x2D,0x7E,0xA4,0x59,
	0xE5,0xD8,0x0A,0x45,0x55,0xC5,0xA4,0x7F,0x23,0xC9,0xCE,0x3F,0xEB,0x61,0x32,0x98,0x22,0x50,0x48,0x01,
	0x28,0x62,0xA1,0x0B,0x47,0x65,0x75,0xED,0x0A,0x0C,0xD2,0x49,0x13,0xB8,0xD0,0x94,0x41,0x08,0x16,0x19,
	0xC9,0x8E,0x12,0x79,0xCD,0x24,0xCE,0x20,0x23,0xFB,0x43,0xDB,0xE6,0x40,0xB0,0xCD,0x4F,0xBB,0x4F,0xB4,
	0x0B,0x0A,0xF3,0x2A,0xFD,0x9F,0x5B,0xB1,0xEB,0x11,0x38,0x01,0xC8,0xDD,0xCA,0x8A,0x53,0x15,0x86,0x66,
	0x10,0x57,0x71,0x7C,0x8F,0x87,0xC3,0x62,0xA7,0x51,0x86,0x1A,0x72,0xAD,0x9F,0xBB,0x6B,0x30,0x78,0xF1,
	0x24,0x02,0x00,0x7B,0xCE,0xC4,0x00,0xD2,0x63,0xA3,0xE0,0x23,0x1F,0x56,0x67,0x5E,0x13,0x1A,0x9D,0x95,
	0x14,0x8B,0x21,0x63,0x52,0xB6,0xBA,0xC8,0x60,0x9E,0xB6,0x9B,0xA0,0x1A,0xD8,0xE3,0x17,0xD3,0x23,0xA5,
	0xD8,0xE4,0x5B,0x54,0x41,0x0E,0x01,0xBD,0x24,0x19,0xEA,0x64,0xBD,0xEF,0x2D,0xCC,0x26,0x87,0xCD,0x88,
	0x73,0xA1,0x2A,0x50,0xAE,0x49,0x30,0x53,0xFF,0xC6,0xA5,0x42,0x44,0xBF,0x81,0x6A,0x67,0x3A,0xC4,0x10,
	0x43,0x42,0x82,0xDE,0xD0,0xC8,0x00,0x14,0x00,0x19,0x84,0x3E,0x42,0xB7,0xC6,0x37,0x3C,0xFB,0xF0,0x0C,
	0x89,0x23,0x4B,0x63,0x31,0x5D,0xF9,0x2F,0x28,0x21,0x50,0x57,0xF9,0x15,0x4D,0x31,0x05,0x07,0x00,0x19,
	0x75,0x80,0x6B,0x05,0x0B,0x13,0x53,0xC8,0xE6,0xE0,0xEA,0x05,0x4D,0xF2,0x9B,0x01,0x70,0x32,0xDD,0x62,
	0x7F,0xE7,0xEC,0x7E,0x33,0x17,0x1E,0x18,0x4D,0xBD,0xAD,0x54,0x01,0x8E,0x6E,0x5A,0x0B,0xA1,0x9E,0x6B,
	0x2A,0xB0,0x3B,0xA0,0x69,0xF8,0x61,0x1E,0x46,0xE5,0xD2,0x49,0x6A,0xB0,0x45,0x19,0x06,0x4A,0x7E,0x13,
	0x72,0xF5,0x70,0x1F,0xC5,0x1E,0x4A,0xC1,0x51,0xB8,0x67,0x55,0x6D,0x52,0xB7,0x82,0x95,0x6C,0x57,0x95,
	0x28,0xC7,0x2A,0x31,0x71,0x57,0x3B,0xFA,0xD1,0x5B,0xE5,0xF6,0xFE,0xE4,0x24,0xC3,0x27,0xB8,0x17,0x6C,
	0x9F,0x05,0x60,0x95,0x25,0x13,0xD4,0xAF,0xF6,0xBB,0xA2,0x65,0x22,0xD0,0x03,0xF1,0x52,0x4E,0x1F,0x87,
	0xC2,0x04,0x23,0xEC,0xAF,0x5C,0x1E,0x61,0xBD,0xB8,0xD2,0x83,0x48,0xC5,0x62,0xA7,0x77,0x05,0x76,0xFA,
	0x1D,0x91,0x40,0x2C,0x36,0x12,0xF7,0x5F,0x65,0x9C,0x8E,0x73,0x29,0x7F,0x1A,0x95,0x84,0x9C,0x49,0xA5,
	0x92,0x81,0x85,0x30,0x8D,0x4D,0x83,0xBB,0xCA,0xDA,0x60,0x01,0x5D,0xB6,0xB6,0x6D,0x56,0xB4,0xEF,0xE2,
	0xE0,0x27,0xD2,0xA3,0xEF,0xB6,0x78,0x19,0x64,0xBC,0xA5,0x81,0x0C,0x4C,0x15,0x43,0x10,0x1A,0xD7,0x16,
	0xDB,0xF2,0xE7,0xF9,0x85,0xEE,0xAA,0xA7,0xF4,0x96,0x32,0xCE,0x7D,0x35,0x93,0xCC,0x06,0xF6,0xFB,0x70,
	0xF8,0x5C,0x0B,0x0E,0xB8,0x69,0x18,0x45,0xA0,0x27,0x4A,0x5C,0x10,0x40,0xEB,0x6C,0x59,0x64,0x11,0x22,
	0x82,0xF5,0x0F,0x5A,0x5A,0x2D,0x40,0x36,0x28,0xA2,0x25,0xB8,0x07,0x51,0xE6,0x20,0x50,0xC5,0xFC,0xAB,
	0x81,0xBE,0x72,0x1B,0xB2,0x59,0xB4,0xB7,0x28,0x19,0x32,0x3B,0xBF,0x43,0xDF,0xE3,0x32,0x73,0x26,0x74,
	0x73,0xF5,0x0B,0x31,0xC6,0x8A,0x9A,0x28,0x9A,0x3D,0xCC,0x41,0xD3,0x99,0xFA,0xE9,0x2A,0x34,0x79,0x26,
	0xAB,0xD1,0x69,0x9C,0xFD,0x3C,0x2A,0xDE,0x52,0x80,0x10,0x8F,0xCA,0x81,0x6C,0x54,0xE1,0xE9,0xAC,0xB0,
	0xCF,0x85,0xD0,0x00,0x8F,0x51,0x5E,0x15,0x42,0x7E,0x65,0xE4,0x80,0xAC,0x8B,0x53,0x16,0xA0,0xCD,0xBA,
	0x42,0xBC,0x87,0x79,0x6F,0xCA,0x08,0x7F,0xA2,0xB6,0x8B,0x8D,0x66,0x32,0x3F,0xD4,0xC0,0x25,0x0B,0xF9,
	0xBD,0x60,0xE9,0x28,0xD2,0xC0,0xF8,0xF6,0x2F,0xC0,0x64,0x44,0xD3,0x8D,0x63,0x17,0x74,0x08,0x52,0x4C,
	0x1F,0xA9,0x85,0x20,0xE8,0x8C,0xDC,0xA3,0x93,0xC1,0x02,0xF5,0x2E,0x1C,0x75,0x11,0xD5,0xB0,0x33,0xB8,
	0x08,0x05,0x12,0x2A,0x56,0x83,0x6A,0x6A,0x43,0x5B,0x1A,0x7C,0xD7,0x57,0x15,0x98,0xA4,0xE2,0x65,0x51,
	0x50,0xEF,0xDE,0x33,0x18,0x85,0x8E,0x5E,0x49,0x37,0x1D,0xAA,0x2E,0xC7,0x81,0xB1,0x37,0x18,0x82,0xC1,
	0x7B,0xC6,0x37,0x17,0x28,0xF3,0x36,0x72,0x82,0xD5,0xFF,0x02,0x4B,0x58,0xCE,0x96,0x11,0x68,0xFD,0xBB,
	0x35,0x21,0xF7,0xDA,0x1F,0x6F,0x0D,0xBA,0x94,0xD0,0x51,0x80,0x6C,0xE3,0xE8,0x99,0xFB,0x10,0xA6,0x18,
	0xAB,0x39,0x96,0xFA,0xEE,0xC3,0x49,0x0B,0xD3,0xCC,0x41,0xD4,0x28,0xA8,0x91,0x77,0xF5,0xE2,0xA0,0x94,
	0x67,0xCC,0xB8,0xCF,0x88,0xFE,0xA3,0x26,0xBF,0x9B,0xCE,0x58,0x14,0x08,0xB7,0xBF,0xC8,0xA3,0x30,0x29,
	0x0A,0xA5,0x00,0x81,0x45,0x0B,0xB1,0x14,0x7E,0xD7,0xCD,0xFD,0x2C,0xB9,0xC0,0x00,0x0C,0x07,0x4F,0x38,
	0x32,0xAA,0xFD,0x82,0xA1,0x84,0xA3,0x85,0x09,0xBC,0x8B,0x87,0xF3,0xB4,0x7B,0xDF,0x63,0xA8,0x53,0xF7,
	0xEB,0xD3,0x05,0x69,0xB5,0x71,0x28,0x3F,0x0B,0x03,0xB2,0x59,0xB5,0x8A,0x61,0xA0,0x73,0x89,0x7C,0x4F,
	0x63,0x81,0x07,0x38,0xB5,0xA6,0x70,0x4D,0x7C,0xD5,0xBE,0xA6,0x95,0x78,0x6D,0x00,0x17,0x3B,0x80,0x3E,
	0xFC,0xAC,0x0F,0x5B,0x28,0xF5,0x05,0xE2,0x45,0x37,0x42,0x27,0x54,0x77,0x15,0xFE,0x7E,0x6D,0x54,0x2C,
	0xE9,0x84,0xA6,0x43,0xFD,0x0B,0xA4,0x17,0xB5,0x6B,0x8D,0xD6,0x2E,0x06,0x11,0x76,0x81,0x8F,0x89,0x71,
	0xF7,0x02,0x21,0x8F,0xEA,0x35,0x85,0xD5,0x65,0x67,0x79,0x7A,0xB0,0xDB,0x68,0x9E,0x0D,0xB7,0x75,0xA9,
	0x2D,0xE3,0x4A,0x18,0xD1,0xCD,0x77,0xC9,0xF3,0x8C,0x16,0x84,0xED,0x9B,0x10,0x0D,0x00,0xDA,0xFB,0xCA,
	0xEB,0x13,0x16,0x21,0x5D,0xC5,0xBF,0xC3,0x53,0x94,0x3E,0xDF,0x9B,0x59,0x96,0x64,0x75,0x11,0x15,0xE9,
	0xAD,0xC5,0x82,0xC4,0x18,0xE3,0x98,0x62,0x8E,0x00,0x8B,0xC9,0x0C,0xAA,0x78,0x88,0x60,0x27,0xAC,0x3A,
	0x42,0x0D,0x5F,0xFF,0xC1,0x44,0xF2,0xD3,0xD0,0xF3,0xE3,0x27,0x4C,0xA0,0x43,0xC4,0x96,0xDF,0x60,0xF7,
	0x3C,0xFE,0xCA,0xFB,0xD6,0x20,0x00,0xFD,0x79,0x7C,0x33,0x2A,0x8B,0x84,0x63,0x62,0x43,0xA7,0x50,0x63,
	0xD2,0xEE,0xA3,0x53,0xE2,0x2F,0xE2,0xB3,0x67,0xC9,0x55,0x84,0xE4,0x75,0x05,0xE3,0x38,0xBF,0x92,0xE0,
	0x03,0x61,0x09,0x89,0x14,0x45,0x11,0x04,0xE5,0xEB,0x96,0xF2,0x04,0xEB,0x85,0x7B,0x73,0x16,0x8C,0x6D,
	0xF1,0xEE,0x76,0x27,0x87,0xEB,0xE6,0x68,0xF3,0xD3,0xD4,0xF3,0x43,0xE3,0xF4,0xF4,0x24,0x8F,0xA0,0x7D,
	0x18,0xF2,0xAE,0x1E,0xC3,0x2F,0x42,0x0A,0xE1,0xAB,0x0B,0x04,0xEE,0x70,0x24,0x66,0x40,0x47,0x7C,0xE0,
	0x97,0xD8,0x03,0x0D,0x81,0xE9,0xF7,0x9D,0x7C,0xDE,0x3C,0x3B,0x29,0xEE,0xA8,0x19,0xF8,0xEA,0xD0,0xB2,
	0x12,0x5C,0x55,0x58,0x81,0x96,0x6A,0xD0,0xAA,0x96,0x2E,0xC9,0xE9,0x2C,0x51,0xCB,0xAC,0xA3,0x55,0x18,
	0x31,0xDC,0x60,0xAD,0x6B,0x97,0xED,0x70,0xCE,0x52,0xED,0xD4,0xC4,0x95,0x06,0xAA,0x4A,0xF1,0xAB,0xD2,
	0xA0,0x6D,0xA2,0xC2,0xF8,0x3A,0x4A,0xCC,0x96,0x7D,0x3C,0xBA,0x04,0xED,0x1E,0x4B,0x7C,0x3F,0xF9,0xAA,
	0xB7,0xEC,0x91,0x81,0x1C,0x79,0x8E,0x35,0x2D,0x07,0x84,0x81,0x04,0xFA,0x08,0x0F,0x15,0x46,0x52,0xC5,
	0x1F,0x60,0xB4,0xA8,0x7C,0x66,0xF9,0x1B,0x18,0x5F,0x0A,0x37,0x8C,0x70,0xF1,0x5F,0x33,0x60,0x26,0xED,
	0x9C,0x12,0xD6,0x95,0x08,0xEE,0xC9,0x5C,0x6F,0x3A,0xDB,0x57,0x5C,0xE2,0x62,0xB9,0x62,0x65,0xB9,0x29,
	0x3B,0x66,0x56,0xBD,0xA2,0xF5,0x1E,0x26,0x01,0xD7,0x0B,0xA1,0x9F,0xC3,0x46,0xDF,0x05,0x48,0xEB,0x53,
	0x51,0x17,0xB5,0xF2,0x8A,0xCE,0x46,0x2C,0x90,0x5F,0x42,0xFA,0x92,0x1C,0x7A,0x0E,0x40,0x6C,0xF6,0xB1,
	0x9C,0x9D,0xD6,0xDF,0xE2,0xCC,0x90,0x86,0xA6,0x82,0xE8,0x96,0xE3,0x92,0xAA,0x8F,0xD1,0x3F,0xEA,0xB9,
	0xFF,0x79,0x88,0x70,0x2A,0x70,0xCA,0xB6,0xC5,0x9B,0x02,0xC0,0x8D,0x12,0xA0,0xAB,0x21,0x82,0x89,0xE9,
	0x7F,0x2A,0x95,0xE3,0xC3,0x50,0x0F,0x52,0x9F,0x58,0x4A,0xD5,0xC5,0xEC,0x23,0x00,0x48,0xEF,0x5F,0xB4,
	0x36,0x3E,0x81,0xD1,0x81,0x01,0xD1,0x6C,0xB1,0x41,0x3C,0x34,0xC1,0xBE,0x26,0xFF,0xB7,0x57,0xAE,0x10,
	0x15,0xF8,0x5A,0x23,0xFC,0x47,0x1C,0xF6,0x7F,0xE0,0xA9,0x1B,0xEB,0x43,0x40,0x1A,0x17,0x1F,0xCA,0x85,
	0x90,0xA8,0xAF,0xFF,0x65,0x00,0x94,0xEF,0xB4,0x7C,0xE1,0xA1,0x5E,0x0F,0xB3,0x55,0x31,0xA2,0xF0,0xE0,
	0x0A,0xC2,0xBE,0x2C,0x8A,0xF5,0x0E,0x79,0xA8,0x70,0xED,0xAC,0xE8,0xE4,0xE7,0xF4,0x70,0x0C,0xA6,0x71,
	0xE5,0x68,0x06,0x00,0xA6,0xD0,0x9F,0x36,0xE3,0x59,0x51,0x5E,0x4F,0xC1,0x67,0x49,0x5A,0x22,0x85,0xCD,
	0xE1,0x81,0x91,0xA4,0xA5,0x7B,0x97,0xB4,0x65,0xAB,0x2E,0x1B,0x93,0x3E,0xBE,0x6F,0x3F,0x46,0x2E,0x01,
	0xBD,0xC2,0x41,0xD3,0x14,0xA6,0x69,0x23,0x7D,0x99,0xDA,0x1F,0xA8,0xC2,0x94,0x13,0xCE,0x9C,0xCC,0xCF,
	0x68,0xE8,0x68,0x25,0xE5,0xA0,0x06,0x47,0xD5,0xD3,0x25,0xC9,0x72,0x96,0x61,0xA2,0xD1,0x44,0x8E,0x0B,
	0x50,0xE3,0xCB,0x39,0x54,0x92,0x78,0xB4,0x52,0x74,0x6C,0x8F,0xCD,0x36,0x3F,0xC5,0x9F,0x29,0xEC,0x30,
	0xEC,0xE0,0x8A,0x4E,0xD1,0x47,0x95,0xB9,0x41,0xEE,0x8B,0xAE,0xAC,0x3B,0x3F,0xFE,0x68,0x50,0x5F,0xB6,
	0x12,0x3A,0xDB,0x67,0x93,0xD5,0xD9,0xEE,0xA5,0x73,0x13,0xEE,0x1A,0x35,0xAB,0x8C,0xE8,0x75,0x9C,0x12,
	0x8E,0xF3,0x5B,0xE7,0x23,0xD5,0x41,0xC2,0xCB,0x8F,0x80,0x1B,0x56,0x09,0x07,0x3B,0x3D,0x32,0x91,0x7A,
	0xF6,0x76,0xBF,0xDD,0xB5,0x09,0x56,0x4F,0x2D,0x8B,0x47,0xF9,0xD9,0xD5,0x31,0xED,0x10,0x71,0x60,0x1A,
	0xC4,0xD8,0x6C,0xE6,0x88,0xB3,0x5A,0xB3,0xB1,0xBA,0xE7,0xD4,0x3C,0x0D,0xB3,0xE9,0xCE,0xD9,0xFE,0x44,
	0xD7,0xA4,0xD5,0x9D,0x11,0x7C,0xFD,0x58,0x85,0x05,0xE5,0x57,0x57,0xEE,0x9D,0xAF,0xD3,0x8B,0xED,0x75,
	0xB8,0xBB,0x73,0xB2,0x53,0x68,0x21,0x97,0x62,0x46,0x98,0xB0,0x79,0xE4,0xEC,0x2A,0xE4,0x6B,0xE2,0x21,
	0x63,0xB5,0x79,0x1D,0x00,0xB2,0xD6,0x2E,0x4B,0x53,0xED,0x66,0x69,0xF7,0xC9,0x8D,0x0B,0xBE,0x4C,0x60,
	0xA9,0x7D,0x59,0x64,0xE9,0x11,0x88,0xE8,0x08,0x01,0x38,0xA5,0xF5,0x61,0xE3,0xA5,0x28,0xC5,0xFE,0xC6,
	0x4B,0x85,0x86,0x4A,0xFB,0x06,0xAB,0xCB,0xDC,0xAE,0xA1,0x47,0x8C,0x66,0x3C,0x3A,0x0A,0xAB,0x49,0x16,
	0xC8,0xDC,0x1B,0x5F,0x3C,0x56,0xF8,0xBA,0x16,0x6E,0xDB,0xE1,0x74,0xE8,0x07,0x77,0xC9,0x89,0xD4,0x36,
	0xDD,0x16,0xA1,0x50,0xEE,0x74,0x44,0xCF,0xA5,0x7E,0xAB,0xAC,0x65,0x32,0x5B,0x05,0x36,0xE2,0x8D,0xD0,
	0xC6,0x68,0xBF,0x20,0x6D,0xF6,0x7C,0x52,0x82,0x06,0xE1,0x12,0x1A,0x55,0x57,0xD2,0x54,0x5D,0x31,0x03,
	0x54,0xBF,0x8E,0x65,0x4B,0xE1,0x51,0x3D,0x56,0xC0,0xB9,0x41,0x93,0x6F,0x35,0xCB,0xF7,0x00,0x70,0x5B,
	0x1D,0x54,0xB5,0xD0,0x07,0xAA,0x25,0x9C,0xED,0xC6,0xD6,0x80,0x7E,0x0D,0xC7,0xCC,0xEB,0xC6,0xDD,0x83,
	0x15,0xDF,0x8D,0xAE,0x4D,0xB4,0xF7,0x54,0x0F,0xBA,0x4B,0x6F,0xCA,0xF5,0x96,0x14,0x61,0x38,0x2B,0xD5,
	0x97,0x64,0x4B,0xA7,0x7A,0xC5,0x23,0x06,0x6B,0x41,0x23,0x69,0x4B,0xD6,0x2B,0xA7,0x09,0x13,0x89,0x7F,
	0x44,0xDC,0x9F,0x1E,0x64,0xA5,0x41,0x9D,0x88,0x1D,0xD4,0x10,0x48,0xD7,0xFE,0x15,0xA6,0x7F,0x2B,0x5F,
	0xEC,0xB4,0x9B,0xD1,0xCE,0x56,0x3C,0x34,0xC8,0x72,0x0F,0x51,0x32,0xB9,0x63,0x47,0xE0,0x25,0x6A,0xC0,
	0xD1,0x23,0x72,0x6B,0xB8,0x11,0x07,0x57,0x5E,0x7C,0x62,0xD5,0xCB,0xFF,0x00,0x7C,0xA0,0xDF,0x56,0xA3,
	0x5F,0x26,0xF7,0x6E,0xDB,0x75,0x75,0xCE,0x4E,0xC7,0x88,0xBA,0xEE,0x6B,0xD7,0x84,0xBC,0x4A,0x20,0x57,
	0x65,0xBE,0xD9,0x7D,0xAA,0xCA,0xD5,0xEE,0x17,0x8C,0x05,0x0E,0xCE,0xFF,0x2C,0x71,0xA2,0xD0,0x0E,0xED,
	0xA0,0x05,0xCF,0xAE,0x70,0x86,0xFE,0x57,0xF9,0xEE,0x22,0x82,0x2B,0xF8,0x80,0xDE,0x1D,0x63,0x9C,0x39,
	0xE4,0xC7,0xC2,0xDB,0x9D,0x86,0x56,0x87,0xFA,0x6A,0x88,0x4D,0x19,0x98,0xD8,0xC4,0x5D,0xBC,0xBA,0xFD,
	0x3B,0xB6,0xE5,0x4A,0x32,0xF4,0xF0,0x89,0xB8,0x94,0x82,0xE3,0x7B,0xAF,0xDB,0xE1,0x7E,0xA9,0x02,0xEB,
	0xD9,0x9A,0x49,0x24,0x49,0x92,0x24,0x9C,0x47,0x9E,0x69,0x98,0x6F,0x34,0xD5,0xAF,0xA0,0x54,0xE7,0x23,
	0x1A,0x9A,0x78,0x20,0x61,0x69,0x79,0x6F,0x9C,0x0B,0x57,0x8A,0x18,0x70,0x3D,0x9B,0x2D,0x6E,0x4C,0x4B,
	0x9A,0x31,0x9D,0x39,0x60,0x59,0x89,0xAD,0xBF,0x96,0xB9,0xDA,0x6F,0x5D,0x25,0x76,0x2C,0xDC,0x86,0x59,
	0x20,0xEB,0x5F,0x86,0xA6,0x2C,0xF3,0x90,0xA9,0xCA,0x04,0x36,0x40,0x45,0x3A,0xE7,0xD0,0xAC,0x1B,0x29,
	0xE0,0x6D,0x95,0x29,0x78,0x03,0x2F,0x86,0x52,0x93,0xA7,0x67,0xEA,0x8B,0x2A,0xB9,0xFF,0x81,0x0F,0x68,
	0x2C,0x2A,0x1B,0xB8,0xA0,0xB4,0x69,0x7A,0x98,0x74,0xA5,0xD4,0x9E,0xAF,0x3A,0x6E,0xE7,0xEB,0xFF,0x9F,
	0xC3,0x11,0x51,0x17,0xEC,0x29,0x07,0xC2,0xF2,0x5A,0x5C,0xCC,0x54,0x37,0x2C,0xAE,0x56,0x41,0xC1,0x8D,
	0xA3,0x87,0x0B,0xF1,0xBF,0x28,0xCC,0x34,0x46,0x13,0x3D,0x03,0x47,0x3E,0x87,0x7A,0xEB,0x1C,0xC1,0x1E,
	0xE3,0x08,0x68,0xAA,0x2C,0x57,0x5A,0xC3,0x0D,0xCB,0x5A,0xDC,0x7C,0x9F,0xAE,0xFD,0x2D,0xD8,0xC3,0x22,
	0x76,0x98,0xEA,0x98,0x10,0xEC,0x72,0x19,0x2A,0x9D,0xD9,0xFC,0xA0,0x67,0x8A,0xAA,0xAD,0x6E,0xB6,0x00,
	0x60,0x9B,0x42,0x0C,0xD4,0x33,0x71,0x6E,0x75,0x83,0x8D,0x8A,0xEA,0x58,0xFD,0xFE,0x68,0x66,0x56,0x06,
	0xE1,0xD3,0x74,0x1D,0x83,0xD4,0x03,0xA9,0x4C,0x4E,0x9D,0xF9,0x45,0xCC,0x69,0x73,0x57,0x9C,0xB5,0x4D,
	0x4B,0xC3,0x8A,0x2E,0xCD,0xB9,0x18,0xF0,0xC7,0x01,0x5A,0xBA,0xF3,0xC8,0x56,0xCA,0xE1,0xBE,0x4E,0x45,
	0x96,0x64,0xB2,0xCB,0x7E,0x46,0x7C,0xB3,0x74,0xA8,0x34,0x63,0x07,0xF5,0x82,0x9B,0x1B,0x8D,0xC0,0x70,
	0xD1,0x5F,0xDA,0x15,0x4E,0x83,0xDE,0x91,0x48,0xAB,0x26,0x1D,0x8E,0x81,0xF7,0xE6,0x44,0xDB,0xEB,0x77,
	0x0F,0xA1,0x01,0xD9,0x75,0x8D,0x8C,0x3C,0xAF,0x83,0x8D,0x09,0x3B,0xE2,0x3A,0xDB,0x11,0xDD,0xC0,0x2D,
	0x85,0x79,0xAD,0x70,0xE1,0x94,0x3D,0xB7,0x32,0x8B,0x15,0x4D,0xA8,0x02,0x87,0x46,0x6B,0x49,0x8A,0xCA,
	0xA2,0xF1,0xBF,0x60,0xAB,0x2A,0x60,0x9D,0x8C,0x76,0x36,0xE7,0xC9,0xF0,0xBE,0xDC,0x2D,0xDB,0x85,0xF1,
	0x3B,0x66,0x2D,0x87,0x66,0x45,0xCB,0xAB,0x02,0x18,0x89,0x77,0x68,0xA5,0x49,0x52,0x02,0x96,0x72,0x6B,
	0x6C,0x13,0x75,0x90,0x27,0x6D,0xF8,0x92,0x1C,0x0D,0x03,0x7C,0x7D,0x2F,0x4C,0x36,0x5E,0xD0,0x13,0x09,
	0x09,0x55,0x60,0x19,0x07,0x1D,0x3E,0x09,0x09,0x09,0x63,0x59,0x57,0x77,0x4C,0x88,0x4E,0x78,0x03,0x1A,
	0x72,0x01,0x4F,0xCD,0x8E,0xFB,0x4A,0x74,0x3B,0xFE,0x21,0xAC,0xEF,0x7B,0x14,0x82,0xE4,0x14,0xF6,0x1F,
	0x83,0x3A,0x7E,0x13,0x4A,0x84,0x86,0xC8,0x44,0x71,0xA8,0x6C,0x73,0x64,0xC2,0x7A,0xF7,0x54,0x5F,0xD6,
	0x08,0xD9,0x49,0x19,0x60,0xB5,0x1F,0x40,0x01,0xAA,0x06,0xB7,0x60,0x70,0xA7,0x36,0x07,0x34,0x3B,0x61,
	0x8A,0xF7,0x24,0xEE,0x66,0x52,0x60,0x96,0x26,0xF2,0x3F,0xB2,0xF7,0xCE,0xDC,0xC2,0x5F,0x4A,0x3E,0x7F,
	0x82,0x08,0x4C,0x05,0x3C,0xAD,0x43,0x91,0x6E,0xF2,0x58,0xF2,0x37,0x8E,0x98,0xF1,0x5A,0x75,0x05,0x83,
	0x89,0xBC,0x60,0x59,0x9F,0xEE,0xA0,0xE5,0xEF,0xC5,0xAF,0x9A,0x12,0xAA,0x1E,0x0E,0x44,0x52,0x05,0xA6,
	0xF5,0x87,0x64,0x8D,0xFB,0x8E,0x82,0x81,0x64,0x03,0x82,0xB8,0xF6,0x47,0xF6,0xC4,0x0F,0x6D,0x2A,0x4D,
	0x2A,0x14,0x2E,0x12,0x2E,0x4A,0x2E,0x2F,0x7B,0x3D,0xDA,0xB2,0xA8,0xA8,0xB7,0x24,0x64,0x0D,0xDA,0xA0,
	0x2B,0x5D,0x59,0x27,0x5A,0x5C,0x62,0xD6,0x28,0x15,0xA4,0xD7,0x55,0x61,0x64,0x9F,0x2F,0x36,0xB7,0x69,
	0x7E,0x95,0xAA,0x4A,0x2E,0x48,0x87,0x7E,0x0A,0xE7,0xDD,0x31,0x41,0x7A,0x6D,0xAF,0x75,0x45,0x28,0xAB,
	0x98,0x63,0xB4,0xE9,0x12,0x8E,0x16,0xFE,0x50,0x7F,0x59,0xF1,0x5D,0x93,0xFE,0xE0,0xD2,0x3B,0x0C,0xD5,
	0x18,0xA0,0x9B,0x77,0x95,0xDC,0x63,0xEF,0xE9,0xDA,0xB4,0x1E,0xF9,0xEF,0x78,0x54,0x54,0x2A,0xD9,0x0E,
	0x9A,0xE1,0x0F,0xAB,0xAB,0x53,0x0F,0xBE,0x51,0x6A,0xE7,0x46,0xF8,0x98,0xD0,0x53,0xB5,0x6D,0x9D,0xAE,
	0xEB,0xA0,0x25,0x4A,0xD7,0x87,0xC8,0xC4,0xC5,0x0B,0x88,0xFA,0xA5,0xC3,0xF8,0xDC,0x38,0xBE,0x39,0x8B,
	0x61,0x94,0x6B,0xBC,0xE3,0x0F,0x42,0x2B,0x45,0xFF,0x45,0x3B,0x0F,0x27,0x5A,0x82,0xDC,0x4E,0x74,0x57,
	0x28,0x00,0x3A,0x30,0x61,0x1A,0xA9,0x9A,0xB0,0x09,0x79,0x3F,0x11,0x50,0x97,0x2A,0x69,0x03,0xF6,0x8A,
	0xC3,0xCE,0xF6,0x6E,0xAC,0x4F,0x0C,0x06,0x93,0x90,0x51,0xFA,0x86,0x70,0x8B,0x15,0xE0,0xB0,0xE6,0x51,
	0x3A,0x95,0x25,0x16,0x06,0x5F,0xE9,0x07,0x96,0x8D,0x82,0xEB,0xAD,0x8F,0xB3,0x95,0xE5,0x62,0x40,0xAD,
	0xDD,0x01,0xD9,0x8F,0x51,0x83,0x0F,0x5A,0x9C,0xA8,0x91,0x6A,0x36,0xAB,0x36,0x01,0xF7,0xE6,0x13,0x1A,
	0x51,0x93,0x46,0xBE,0x08,0xE8,0x37,0xD7,0x81,0x49,0x11,0x56,0x53,0x8B,0x8E,0xAC,0x5A,0x10,0x1C,0xB6,
	0x61,0x55,0x09,0x9D,0x5E,0x56,0x3B,0x81,0x3A,0x48,0x11,0x8B,0xC8,0x3A,0x41,0x59,0x47,0x2C,0x15,0xCE,
	0xFE,0x71,0x15,0xF2,0x89,0xCC,0x64,0xA3,0xA4,0xB1,0xC5,0x75,0x47,0x10,0x49,0xF1,0xB1,0x2A,0x8A,0x93,
	0x0B,0xD4,0x5E,0x15,0x04,0x0E,0x2F,0xB4,0x2F,0xD0,0x4B,0xEA,0x1D,0xB4,0x6A,0xBE,0xAA,0x02,0x20,0xF8,
	0x50,0xD7,0xDB,0x2D,0x58,0x3E,0x4E,0x30,0x2D,0x9D,0x9A,0x79,0xC9,0xF1,0xDD,0x36,0xD2,0x62,0x53,0x55,
	0xEF,0xDF,0x95,0x8D,0x6F,0x7E,0x8C,0x7D,0x91,0xAD,0xA5,0xA4,0x05,0x30,0x04,0x64,0x50,0x54,0xEA,0xD1,
	0x54,0x99,0xE0,0x97,0xA6,0xE9,0xFC,0x55,0x00,0x22,0x91,0xD8,0xD5,0x7D,0x48,0xDC,0xD9,0x79,0x48,0xCF,
	0x53,0x55,0x31,0x01,0xC2,0x66,0xFD,0xAE,0x95,0xA1,0xAB,0x76,0xF8,0x6B,0xAA,0xFE,0x73,0x78,0x70,0x81,
	0x1C,0xCB,0x88,0xDC,0x0E,0xAD,0x0B,0xC0,0xD0,0xD9,0x15,0x0C,0x17,0x99,0x56,0x65,0x89,0x55,0x54,0x86,
	0x24,0x8D,0x30,0xB8,0x4F,0x07,0x3C,0x77,0x9D,0x7B,0x04,0x6A,0xCA,0xC0,0xB3,0xD2,0x14,0x7C,0x20,0xC5,
	0x70,0x29,0x5E,0x05,0xD4,0xD7,0x2A,0x92,0x8E,0x81,0x2F,0x27,0x01,0x8C,0x6F,0x78,0xCE,0xF8,0xB0,0x56,
	0xBA,0xA7,0xD1,0x6F,0x3A,0xB2,0x94,0x79,0xF3,0xF2,0xBB,0x40,0x7E,0x06,0x04,0xFF,0xDE,0x00,0xB8,0xD9,
	0x1E,0x26,0xB0,0x08,0x23,0x7D,0x38,0x16,0x8B,0x7B,0xBF,0x8A,0x80,0xF4,0x2C,0x29,0x5E,0xDD,0x96,0xAD,
	0x25,0x86,0xF2,0x56,0xAE,0xF0,0x6A,0xDC,0x40,0x21,0xED,0x6F,0x2B,0xC1,0x15,0xE7,0x62,0xCF,0x6A,0x3A,
	0xDC,0x8C,0xEB,0xA6,0xA0,0x30,0xCB,0x06,0x0F,0xAA,0xB2,0x1A,0x43,0x80,0xFB,0x77,0xC2,0x10,0x92,0x17,
	0xC5,0x15,0x64,0x60,0xE3,0xB0,0xE7,0xBA,0x7B,0x2D,0x39,0x4D,0x48,0xC7,0x77,0x1E,0x01,0xA7,0xFC,0xA8,
	0xD2,0x89,0xE3,0xD1,0x99,0x28,0x52,0xD2,0x75,0x01,0xEE,0x52,0x00,0x54,0xA6,0x8B,0x7E,0xC7,0x2B,0x61,
	0xFF,0x04,0x0C,0x71,0xE1,0x80,0x89,0xB4,0x2E,0xB9,0x04,0x0E,0x73,0x4B,0x69,0x07,0xD3,0xD2,0xF8,0x7A,
	0x97,0x3A,0x53,0x5C,0xCE,0xC3,0xBA,0xE1,0xC0,0xD0,0x21,0x59,0x86,0x87,0xA5,0x27,0x4D,0xAA,0x82,0xBF,
	0x74,0x58,0x0D,0xE6,0xA8,0xF8,0xB8,0x5A,0xAE,0xC8,0x2D,0x97,0x16,0x1B,0x57,0x6A,0x8C,0x53,0xFD,0x6C,
	0x0D,0xA1,0x11,0xCC,0x1D,0x2C,0x50,0x7F,0xA2,0xD8,0xD4,0x9F,0x57,0x54,0xE8,0xC4,0xBB,0x07,0xFD,0x76,
	0x20,0x21,0x49,0xB0,0xEB,0xF0,0x1D,0xDF,0x79,0x7D,0x1E,0x47,0xB4,0x8C,0xF0,0x57,0xD6,0x45,0x9D,0x0A,
	0x7D,0x2F,0x08,0x09,0x76,0xF1,0xAD,0xF6,0xEE,0x4A,0x77,0xFE,0xBD,0x3A,0x56,0x0B,0x31,0x6F,0x6C,0x90,
	0xD5,0x0B,0x6D,0x79,0x66,0x4E,0xAD,0x62,0x5E,0x7F,0x17,0xED,0xBD,0xE4,0x5D,0x13,0x4E,0x95,0x5C,0x3C,
	0xBF,0xD3,0x95,0x72,0x8B,0xC0,0x10,0x31,0xA5,0xB8,0x40,0x83,0x07,0x64,0x8B,0x75,0x25,0x0A,0x13,0xB3,
	0xAC,0xF1,0x4C,0xE3,0x5E,0x11,0x9E,0x00,0x6E,0xDB,0x02,0x71,0x41,0xA1,0x73,0xA6,0xEF,0xFD,0x0B,0x3A,
	0xB0,0x55,0xB4,0xEF,0xA1,0xB3,0x60,0xCA,0xB1,0x92,0x4C,0x7E,0x0F,0x4C,0x6E,0xDF,0x0A,0x5E,0x57,0xB8,
	0x74,0x98,0x3C,0x70,0x5E,0x4E,0x52,0x7A,0x91,0x02,0x84,0x40,0x55,0x24,0x00,0xF0,0x22,0xF1,0xC0,0xEF,
	0x1E,0xF5,0x85,0x7D,0x02,0xCB,0xD1,0xD5,0x34,0x2D,0xD3,0x6E,0x59,0x3D,0xD3,0xAF,0x51,0xF4,0xC1,0x15,
	0x7A,0xA2,0x08,0xD3,0x6C,0x05,0xFE,0xA5,0x25,0xEE,0x76,0x06,0xC3,0x7D,0x85,0x2E,0x48,0x74,0xF4,0xC2,
	0x2A,0xE6,0x26,0xA7,0x47,0x66,0xFE,0xC9,0xF3,0x7D,0x9B,0x2F,0xE7,0x56,0x82,0x0A,0x3C,0x8A,0xA1,0x7B,
	0x17,0x47,0x7A,0x13,0xAA,0xC0,0xC4,0xCA,0x5B,0x12,0xFF,0xB5,0x6B,0x3D,0x6B,0x46,0x38,0x05,0xD0,0x73,
	0x59,0x44,0x98,0x2B,0x06,0xAB,0xE9,0x75,0xB0,0x82,0xED,0x12,0x66,0x47,0x00,0x4B,0x54,0xFC,0x04,0xB8,
	0x0F,0x30,0x27,0x7A,0xBF,0xD2,0xE8,0x2B,0xDE,0x85,0xB2,0x3C,0xA8,0x92,0xB1,0x56,0xBA,0x47,0x94,0xE2,
	0x65,0x93,0x5F,0xA7,0xBA,0x40,0x74,0x76,0xC5,0x77,0xF3,0x74,0xE0,0x9C,0x0B,0x82,0x39,0x1D,0x15,0x7A,
	0x2E,0x36,0x89,0xF1,0x2F,0xCA,0x10,0x29,0x86,0xCA,0xB3,0x4F,0x20,0x9B,0xE3,0x1E,0x76,0x0A,0x0B,0xED,
	0x55,0xD9,0x7C,0xAF,0x76,0xBF,0xA3,0x95,0xAA,0x50,0x0E,0x2F,0x2C,0x6A,0xEE,0xA6,0x11,0x8A,0x41,0x5C,
	0x69,0x8B,0x57,0xCB,0xE6,0xB9,0x28,0x06,0xAC,0xF6,0x22,0x2D,0x10,0x30,0x43,0x2E,0xA5,0x72,0x38,0xAC,
	0x28,0xB0,0x57,0xCB,0x38,0x7C,0x5D,0x87,0x93,0x3B,0xAF,0x2E,0xA8,0xCD,0xF1,0x95,0xEE,0x4E,0x18,0x5A,
	0x20,0x01,0xBB,0xFA,0x38,0x4E,0xFB,0x80,0xC8,0x2C,0x0A,0x0A,0x53,0x29,0x74,0xCA,0x65,0xD3,0x1E,0x51,
	0x75,0x5D,0x5D,0x45,0xEE,0xDD,0xFE,0xB4,0x4A,0xAE,0x25,0x6C,0x0E,0x86,0x30,0x56,0xD7,0x4B,0x2C,0x8A,
	0x97,0xB2,0xD9,0xCC,0xBB,0x0F,0x24,0x69,0xF7,0xB5,0x03,0xC8,0x7B,0x82,0x2F,0xD5,0x79,0x49,0xB2,0x29,
	0x84,0x55,0x49,0x9B,0x78,0xF6,0x97,0x89,0xCF,0x00,0xDA,0xAA,0x50,0xF2,0x2B,0xD9,0x70,0xD1,0x8C,0x9C,
	0x67,0xED,0x85,0xC4,0x60,0xBB,0xAC,0xE4,0x9A,0xB5,0x06,0x33,0xC2,0x1E,0x7D,0xEF,0x53,0xFE,0xC6,0x33,
	0xC3,0xBC,0xD1,0x43,0x18,0x4E,0x5D,0xF5,0x0C,0x52,0x8C,0xE6,0xEC,0x29,0x8B,0x08,0xB0,0x75,0x0C,0x68,
	0x7E,0xCE,0x63,0x5E,0x54,0x23,0x43,0x4E,0xBB,0x30,0x88,0x5A,0x7F,0x5A,0x3F,0x7B,0x21,0x17,0x16,0x15,
	0x28,0x55,0xE7,0xA5,0xB3,0x43,0x36,0x12,0xAB,0xD0,0x9B,0x91,0x95,0x66,0x34,0x95,0x9D,0x13,0xF7,0x81,
	0x5A,0x12,0x20,0x54,0x4B,0x30,0x5A,0xED,0xE5,0xD6,0x96,0xDF,0x41,0x7F,0x2E,0x25,0x70,0xC0,0x69,0x30,
	0x06,0x98,0x1C,0x26,0x27,0xF4,0x00,0xEC,0x8C,0x36,0xD4,0x2D,0xC5,0x68,0xC7,0x54,0x91,0x99,0x06,0x5C,
	0x72,0x95,0x66,0x14,0x53,0x22,0xFB,0xB7,0x43,0x51,0xC8,0xDB,0xDE,0xD0,0x93,0x2D,0x01,0x02,0x61,0x5B,
	0xA8,0x99,0x9B,0x2B,0xF6,0x84,0x3E,0x0A,0x7E,0x21,0x5E,0x04,0xC2,0xA4,0x4E,0x2F,0xCE,0xAD,0xBD,0xD5,
	0x6F,0xD1,0xEF,0xD5,0xD8,0x52,0xB5,0xAD,0xD8,0xA3,0x40,0xE4,0x85,0x8C,0xC2,0xFC,0xF4,0xB4,0xC8,0x82,
	0xF5,0x36,0xE0,0x55,0xCA,0xE4,0x88,0x3A,0x4A,0xE3,0x45,0x8F,0xCC,0xCD,0x93,0xCF,0x61,0xAB,0x92,0x1C,
	0xA7,0x05,0x85,0x52,0xD0,0x8E,0x7C,0xA3,0xB5,0x90,0x17,0xD0,0x70,0xEA,0x7E,0xE3,0xB7,0xFF,0x91,0xBA,
	0x52,0x35,0x01,0x42,0x30,0xC8,0xDB,0xBF,0x87,0x0F,0x49,0xB9,0x43,0xF7,0x8D,0x2E,0x2C,0xBF,0xFD,0xB2,
	0xC8,0x47,0x11,0x0A,0x7B,0x78,0xBA,0xE7,0x65,0x1F,0xE7,0xC3,0xA3,0x66,0x58,0x2E,0x36,0x8C,0xF5,0xA6,
	0x36,0xD4,0x48,0xBD,0xD6,0x3F,0x6D,0xE3,0xAE,0x1A,0x11,0x90,0x70,0x5F,0x3E,0xC0,0xDE,0xDC,0x15,0x2B,
	0x58,0x65,0xA7,0x18,0x0A,0x74,0x76,0x62,0xC2,0x60,0x6B,0xBB,0x83,0xDA,0x46,0x3B,0x70,0x17,0x22,0x87,
	0x41,0xA8,0x26,0xB1,0xAA,0xA6,0xE8,0x2E,0xBD,0xC3,0x52,0x97,0x5A,0xEB,0x30,0x15,0x02,0x5D,0x26,0xDE,
	0x55,0x40,0xB8,0x7F,0x32,0x7C,0x8F,0xAA,0xB0,0x1D,0x33,0x26,0x3F,0x7F,0x2A,0x96,0x25,0x0A,0x77,0xE4,
	0x38,0xAA,0xB0,0xC8,0x4B,0x7F,0x30,0xE1,0xAC,0xA7,0x75,0xB2,0x25,0xC6,0x1B,0x09,0xDC,0x6C,0xDB,0xBF,
	0x30,0xEE,0xD7,0xC1,0xCA,0xC1,0x65,0xAF,0x1B,0x29,0x82,0x88,0x3C,0xE3,0x17,0x6B,0xF1,0xB4,0x36,0x9B,
	0xEA,0x7D,0x17,0x84,0xBF,0x97,0x34,0xA5,0xDF,0xE3,0x0C,0x2D,0x26,0x14,0x15,0xD7,0x08,0x30,0x4C,0x36,
	0x24,0xAA,0xAA,0x66,0xB3,0x04,0x3A,0xAD,0xA7,0x8C,0xA9,0x21,0xC7,0x9E,0xE5,0xF1,0xAF,0x8B,0x24,0xF5,
	0x4B,0x92,0x96,0x64,0x3C,0x15,0x06,0x6F,0xA6,0x21,0x08,0x7F,0x18,0xB8,0x95,0xBF,0x58,0xA3,0x13,0xD4,
	0x43,0x88,0x02,0x9C,0x36,0x3D,0xB8,0x24,0xB6,0x6D,0x65,0x59,0xD8,0x7B,0x66,0xAF,0x35,0x1F,0x68,0x59,
	0x58,0x43,0x5D,0xAC,0xF4,0x72,0x1D,0x2D,0x1E,0x2A,0x2F,0x62,0xC2,0xFA,0x19,0x70,0x56,0x7A,0x36,0x68,
	0x8D,0xE4,0x5A,0x5F,0x25,0x33,0x8E,0x95,0xFA,0x6A,0x1D,0x56,0x45,0xE7,0x63,0xFB,0x46,0xF3,0x18,0xAA,
	0x71,0xA4,0x1D,0x3D,0xF6,0x12,0xDB,0xD1,0x62,0xCE,0x10,0x5B,0x92,0x02,0x50,0xA9,0xF1,0xFC,0xFC,0x17,
	0xD2,0x9A,0x3B,0x16,0x33,0x9D,0xD3,0x11,0x60,0x82,0x00,0x84,0xB0,0xE0,0xF4,0xA9,0x7A,0x4A,0x0B,0x4D,
	0xA2,0x79,0x6D,0x5F,0xC8,0x2D,0xAA,0x31,0x75,0x15,0xC5,0xDC,0x13,0x15,0x08,0x23,0x33,0x9A,0xB8,0x12,
	0x2D,0x53,0x68,0x79,0xB6,0x6A,0x7B,0xFC,0x07,0x97,0xFF,0x51,0xA5,0x42,0xAA,0x52,0x66,0x45,0x57,0x3C,
	0x4E,0xDE,0xAB,0x6A,0xC4,0xC7,0xA4,0x82,0xAE,0x2B,0x6F,0x65,0x20,0x9E,0x11,0xFD,0x6C,0x09,0x1F,0x9D,
	0xB4,0x9F,0x04,0x69,0xAC,0xD0,0x64,0xAA,0xCB,0xD1,0x1C,0x5B,0x34,0x0B,0x9F,0xFC,0x30,0x4C,0x0B,0xED,
	0xE3,0x2F,0x9F,0x56,0x16,0x81,0xFB,0x2D,0x6F,0x51,0xC4,0xF2,0xA1,0xF7,0xE4,0xBA,0xFD,0x73,0xF4,0x0F,
	0x5D,0x8B,0xE2,0x1B,0x59,0x57,0x19,0x8F,0xB8,0x56,0xDE,0x55,0xCF,0x0A,0xF4,0x0C,0x9D,0x45,0xA2,0xE4,
	0x5B,0x84,0x6B,0xD1,0xEE,0xFD,0xC9,0x95,0x5B,0x77,0x48,0xD5,0x4B,0x4F,0xCA,0x29,0x13,0x3F,0x04,0x41,
	0x70,0x4E,0xA0,0xD4,0xE8,0x3B,0x17,0x18,0x29,0x41,0x89,0x5A,0x0E,0x11,0xB9,0x76,0xCA,0xDD,0x82,0x68,
	0x6F,0x5E,0x01,0x2A,0x0F,0x90,0xD5,0x97,0x92,0x78,0x75,0xD2,0x77,0x63,0xDC,0x3C,0x64,0xBD,0x9F,0x2A,
	0xA3,0xBC,0x37,0x9F,0xF0,0xB7,0x40,0x21,0x61,0x80,0x09,0x76,0xED,0x90,0x6D,0x15,0x7A,0x24,0x25,0xB1,
	0xB0,0x5E,0x0F,0x8F,0xB3,0xC0,0x3A,0xE6,0x53,0x48,0x25,0x9A,0x67,0x9D,0xF1,0xD1,0xB4,0xF5,0x08,0x09,
	0x2B,0xEC,0xFE,0x02,0x77,0x0A,0x56,0x80,0xC8,0xE7,0xCF,0xB9,0x3F,0x00,0x0A,0x34,0xA4,0xA8,0x6D,0x04,
	0x86,0xA7,0x70,0xD7,0x33,0x04,0x8C,0x81,0x00,0xF8,0x0A,0xD9,0x1C,0xED,0x69,0xCF,0x46,0xF2,0x7F,0x50,
	0x12,0x72,0x6B,0x78,0x49,0x36,0x8B,0xB6,0x50,0x1A,0xC7,0x7E,0x0F,0x4D,0x26,0x9D,0xA5,0x2A,0xAF,0x04,
	0x31,0x4A,0x65,0x2D,0x3F,0x28,0x64,0xE1,0xA4,0xCB,0x88,0x36,0x12,0xAB,0xAB,0x7D,0xF0,0x05,0x59,0x15,
	0x82,0x6F,0xF5,0xC3,0xB2,0x04,0x98,0xA0,0x92,0x2F,0x99,0x3E,0x4D,0x30,0xBB,0xD7,0x0F,0xDA,0x92,0x76,
	0xFE,0x57,0x45,0x26,0x94,0xA2,0x58,0x2E,0x14,0xC5,0x39,0x68,0xA1,0x7C,0x8E,0xF5,0x29,0x16,0xAE,0x6B,
	0x47,0xFC,0xC8,0x20,0x27,0xD8,0x47,0xE2,0x8A,0xB8,0xEC,0xED,0x8F,0xAB,0xBC,0x1C,0x79,0xFD,0x18,0xC4,
	0x4F,0xB6,0x31,0xDE,0xD2,0xB2,0x2A,0x8D,0xEF,0xDE,0x17,0xDF,0xD3,0x72,0xB5,0x07,0xFB,0xA3,0xC6,0xF7,
	0x5E,0x5F,0x22,0x09,0xC8,0xC1,0x77,0x7F,0xBF,0x25,0x0A,0xC4,0xDE,0xA6,0x63,0xC1,0x27,0x0B,0x7A,0x8F,
	0xD6,0xFA,0xED,0x47,0x39,0xC7,0x56,0x20,0xC1,0x4C,0x2B,0x0C,0x9D,0x78,0xBA,0x8B,0x83,0x58,0xF3,0xB4,
	0xBF,0x47,0xEC,0x51,0x71,0x78,0x33,0x29,0x61,0x52,0x64,0xD3,0x0E,0xFA,0xA5,0x1E,0x57,0xCC,0x84,0x98,
	0x09,0x5C,0x02,0x17,0xD0,0x21,0x48,0xB9,0x60,0xB3,0x6A,0x22,0x47,0x90,0x19,0xF2,0x4A,0x27,0xEB,0x40,
	0xF6,0x53,0x82,0x84,0x88,0x3F,0x20,0xD0,0x88,0x16,0x8B,0x22,0x58,0x79,0x69,0xE9,0xD4,0x55,0xEF,0x66,
	0x4E,0xCA,0xEB,0x13,0x7D,0x77,0x81,0xD2,0x28,0x44,0xFD,0x86,0x00,0x82,0xA5,0xCF,0xBF,0xF1,0xBF,0xA7,
	0xE6,0xEF,0xD4,0xFE,0x8F,0xD1,0xAE,0x60,0x8C,0x43,0x4F,0x51,0x65,0xE0,0x9C,0xED,0x55,0x9A,0x7D,0x66,
	0x34,0x47,0x43,0x79,0x44,0x96,0xBF,0x86,0x97,0x3B,0x9E,0xF8,0x5F,0xDB,0x07,0xD1,0xAE,0x3B,0x12,0x19,
	0x55,0xA8,0xB0,0xCB,0x01,0xF2,0x9B,0xA3,0x82,0xA5,0xAB,0x79,0xC5,0xC6,0xE5,0xBE,0xAD,0x6A,0xE0,0xB6,
	0x85,0x02,0x26,0xB3,0xA8,0x4B,0x97,0x62,0xE4,0xD6,0xF9,0x17,0x97,0x4A,0x91,0xAA,0x99,0x56,0xB3,0x81,
	0x53,0xB1,0x10,0x52,0xFF,0xDF,0xB9,0x62,0xEF,0x5A,0xBB,0xE8,0xC8,0x11,0x38,0xE9,0xB7,0x05,0x11,0x6E,
	0xD4,0x1F,0x05,0xA3,0x1E,0x77,0xB2,0x1D,0x9F,0x62,0x49,0x82,0x17,0x18,0x3B,0x0D,0x29,0x04,0x2B,0x28,
	0xA6,0x1A,0x41,0x33,0x07,0xE8,0xF3,0x34,0xBB,0xE4,0xA8,0x1F,0xBD,0x43,0xBD,0x58,0x8A,0x94,0x6C,0xBF,
	0x3D,0x05,0xF7,0x6F,0x32,0x95,0x3B,0xF5,0x9E,0x58,0xF4,0x97,0x5A,0x4A,0x9A,0xD0,0x78,0x1F,0xA2,0xFF,
	0xA9,0x98,0x2A,0x93,0x1A,0x0D,0xD7,0xAE,0x9B,0x3F,0x44,0x64,0xBD,0xCA,0x67,0x5D,0x1C,0xAC,0x91,0x35,
	0xE4,0xAB,0x5F,0x2D,0x60,0xFD,0xAF,0xE2,0xB8,0x8E,0xEA,0xF1,0x08,0x3B,0xE9,0x93,0x37,0x55,0x8F,0xB6,
	0xB0,0xE5,0xDB,0xA1,0x9E,0x1D,0x96,0xCF,0xD5,0xB8,0x08,0x50,0xFB,0x8F,0xC1,0x84,0x19,0xA6,0x14,0x61,
	0x01,0x82,0x18,0x44,0xDE,0x51,0x1B,0x33,0x28,0xF2,0x0A,0x41,0x40,0xF1,0x5E,0x1B,0x05,0x90,0x4B,0xD7,
	0x5C,0xB2,0x80,0x82,0x83,0x93,0xA5,0x45,0xC6,0x82,0x6D,0xC0,0x1E,0x50,0xD8,0x13,0x26,0xF4,0x96,0xCF,
	0x66,0xEA,0xC3,0xAB,0x39,0x26,0x5C,0xD5,0x13,0xFD,0x9A,0x4A,0xCE,0x13,0x73,0x12,0x05,0x2B,0x7D,0x2B,
	0x9A,0xB8,0x3E,0x14,0xB9,0x49,0xB4,0x3D,0x82,0xD5,0x9B,0x27,0x51,0xC1,0x4E,0x57,0x47,0x0B,0xAC,0x83,
	0xA4,0x95,0x24,0xEB,0x6E,0x1E,0x3B,0xE6,0xB2,0xBD,0x25,0xF3,0x8C,0x25,0xCB,0x7A,0x5A,0x17,0x91,0x4F,
	0x1B,0x2A,0x2D,0xDD,0xC8,0x0A,0x00,0xFE,0xE8,0xCD,0x0B,0x92,0x4D,0xF6,0x00,0x9F,0x19,0xFA,0x5E,0x41,
	0xA1,0x33,0x04,0x40,0x43,0xD1,0x2E,0xAA,0x45,0xEF,0x12,0x7F,0x64,0x5F,0xE5,0x80,0x90,0xCD,0xCC,0x6B,
	0xA7,0xE1,0x29,0x99,0x30,0x07,0xC3,0x4A,0x55,0xA0,0x22,0xB9,0x33,0x6C,0xD8,0x75,0x53,0x23,0x89,0x57,
	0xFB,0xA1,0xA7,0x63,0xEC,0x76,0xFA,0x27,0x03,0xC0,0x9F,0x18,0x5D,0x6B,0xFB,0xBD,0x3C,0x52,0xAB,0x89,
	0x50,0xFD,0x86,0xA4,0x90,0x88,0xF4,0xBB,0xC3,0x72,0x39,0xAA,0x53,0x55,0x4E,0x4B,0x7E,0xC1,0xD6,0xA5,
	0xC2,0x41,0xD5,0xA0,0x2B,0x98,0xB6,0xFE,0x61,0xAE,0x57,0xB1,0x93,0x7F,0xE5,0x1C,0xB1,0x91,0x60,0xAA,
	0x2A,0xDE,0xCD,0x3A,0xAB,0x34,0x1B,0x87,0xE8,0xA1,0xA1,0x76,0x95,0x46,0x4A,0x57,0x44,0x0C,0x15,0x66,
	0xE0,0x69,0x14,0x17,0xC4,0x41,0x66,0x20,0x20,0x28,0x1B,0x22,0x9F,0x95,0xBE,0x2B,0x05,0x35,0xD4,0xDD,
	0x35,0x4A,0x27,0xCB,0x13,0xCB,0x9A,0xAC,0x62,0x87,0xF9,0xF1,0xCA,0x52,0x21,0x0E,0xA8,0xAE,0x45,0x40,
	0x42,0x9B,0xA5,0xEF,0xA1,0x4E,0x82,0x58,0xDA,0xBA,0x4E,0xEE,0xFE,0xBB,0x44,0xCF,0x4D,0xBC,0x11,0x92,
	0x25,0xE5,0x52,0xDD,0xBC,0x47,0x54,0x1E,0x74,0x1E,0xCC,0xE5,0x6A,0x24,0xD4,0x5C,0x33,0xF2,0x3F,0x3A,
	0x0A,0x75,0x3F,0x7C,0xAA,0x20,0x5F,0x7E,0xC5,0x11,0x2E,0x86,0x13,0xA1,0x90,0x97,0xA9,0x0A,0xD6,0x34,
	0xC2,0x3C,0x24,0x51,0x4D,0x93,0xD7,0x65,0x25,0x6D,0xB1,0x10,0x0F,0x04,0xC5,0x4F,0x0C,0x00,0x46,0x33,
	0x48,0x68,0xCD,0xDD,0x21,0x75,0x26,0xCE,0x04,0x2B,0xE8,0x97,0x61,0x83,0x30,0x6E,0x13,0x49,0x97,0x78,
	0xF5,0x58,0x3C,0xA8,0x87,0x53,0x4B,0x5D,0x45,0x13,0x05,0x53,0x63,0xB2,0x77,0x45,0xB5,0xFE,0xBA,0x0B,
	0x04,0x66,0xF4,0x34,0x24,0x1D,0x86,0x07,0x46,0x57,0xE1,0xD8,0xD1,0x94,0xAB,0x3B,0xFA,0xE8,0xAF,0xCA,
	0xE3,0x2A,0x02,0x45,0x47,0x1E,0xBC,0x91,0xCD,0x45,0xEF,0xCD,0x3B,0xF5,0x13,0xEC,0xE1,0x18,0x15,0x3C,
	0x3B,0xA9,0xEE,0x10,0x10,0x41,0x2E,0xA2,0xAB,0x92,0x91,0x34,0x71,0xAE,0x79,0xDF,0xAE,0x22,0x39,0xDD,
	0xCE,0x9F,0x06,0x2F,0x05,0xD0,0xE9,0x81,0xC8,0xD6,0xE8,0x85,0x46,0x0C,0x09,0x4E,0xE7,0x88,0x30,0x30,
	0x1D,0x7D,0x0D,0x63,0x3F,0x4D,0x3E,0x8D,0x58,0x5F,0x8B,0xEE,0x2E,0xA7,0xCF,0x85,0xFC,0xE0,0xAE,0xDA,
	0xB5,0xBC,0xA7,0xDC,0x9F,0x49,0x7A,0xF5,0xB1,0x4C,0x4A,0x84,0x72,0x5A,0x07,0x52,0x52,0x09,0xA7,0xB7,
	0x30,0x9F,0x8B,0x21,0x64,0x2B,0x62,0x64,0xDB,0x65,0x16,0x53,0x17,0xCC,0x0A,0xFE,0xDA,0x5F,0x1A,0xED,
	0x36,0x86,0x6E,0xA8,0x49,0x18,0x82,0x9C,0xC2,0x00,0x14,0x31,0xDC,0x4C,0x66,0xFB,0xD0,0xBA,0xBB,0x50,
	0x3D,0xCF,0x71,0x74,0xFF,0xE5,0x52,0xF2,0x2F,0x0B,0xA4,0xE4,0x78,0x4C,0x3A,0xCD,0x80,0x15,0xBA,0x86,
	0x89,0xA4,0x9A,0x12,0x4E,0x41,0xE0,0xAE,0x1F,0xF1,0x87,0x79,0xC6,0xA4,0xE1,0xD3,0x04,0xE9,0x58,0xFA,
	0x0B,0x24,0xCD,0xBE,0x78,0x95,0x7C,0xD3,0xA4,0xDE,0x74,0xFC,0xA2,0xD8,0x52,0x2C,0xF2,0x9E,0xD5,0x4A,
	0x5F,0x56,0x7A,0x5A,0xB8,0xE2,0xF2,0x61,0x95,0xCD,0xC9,0x32,0xED,0x3F,0x06,0x16,0x15,0x7B,0x7E,0xF3,
	0xED,0xBB,0x72,0xA9,0x6A,0x97,0x9B,0x32,0x21,0x21,0x5F,0x4A,0xF2,0x15,0x61,0x91,0xFD,0x20,0xBC,0x25,
	0x1C,0xEA,0xD0,0xA6,0x4E,0x32,0x91,0x7B,0x9D,0xF1,0x33,0x4C,0xD2,0xE7,0xCA,0x1A,0xEE,0x47,0x35,0x92,
	0xFC,0xF6,0x45,0x90,0xDA,0x70,0xEF,0xD2,0x22,0x91,0xEC,0x2B,0xBB,0x28,0x6F,0xA9,0xCE,0x16,0x9A,0xFE,
	0x4C,0xF1,0x9B,0x9C,0xB8,0x66,0x76,0x23,0x70,0x8C,0x7E,0xE2,0x46,0xA0,0xCC,0x8D,0xAE,0x6E,0x51,0x2D,
	0xE8,0xA6,0x63,0x72,0xB5,0x7C,0x74,0xA6,0x63,0x07,0xED,0xAA,0x4B,0xB6,0x9C,0x51,0x98,0x9D,0xEC,0x59,
	0x8F,0xD4,0xE3,0xF1,0xEB,0x80,0xC4,0x6C,0xDD,0x9D,0x2B,0xA5,0x1F,0xE0,0xC8,0x5B,0xFD,0x39,0xFE,0xD0,
	0x83,0x5A,0xE6,0x16,0x22,0x6A,0x90,0x8A,0x4E,0x47,0x3C,0xA0,0x3B,0x45,0xA2,0x3A,0xA8,0x47,0xE0,0x4C,
	0x6F,0x39,0xAE,0x92,0x49,0xD1,0x0D,0xC1,0x90,0x2A,0x25,0x41,0x77,0x1F,0xBA,0x09,0xD1,0x65,0x21,0x5F,
	0xF6,0x83,0xF1,0xDB,0x10,0xA2,0x2E,0x1A,0xDE,0x2E,0x91,0xDE,0xEB,0x07,0x45,0x2D,0xE1,0x67,0xAC,0xBA,
	0x1B,0x01,0x2F,0x85,0xA9,0xEF,0x94,0xD6,0xC9,0xBD,0x33,0x54,0xFC,0xED,0xA9,0x4C,0x8C,0x72,0xE8,0x36,
	0xA1,0xB3,0x89,0x57,0x41,0x0C,0x33,0x6E,0x29,0x79,0xD5,0xDB,0xDB,0x36,0x57,0xBD,0xEA,0x36,0x31,0x10,
	0x63,0x38,0x41,0xF3,0x9D,0x37,0x55,0x71,0x17,0x85,0xEA,0x57,0xFB,0xD2,0xEF,0x15,0x65,0x6B,0xE5,0x57,
	0xF6,0xF2,0x94,0xFA,0x3F,0x95,0xF0,0xCF,0x78,0xC5,0xE8,0xFF,0xA5,0xE9,0xA2,0xFA,0xDC,0x34,0xE5,0xD6,
	0xAB,0xEE,0xAF,0x38,0xAC,0x7F,0xD4,0x96,0xD5,0xB2,0xAC,0x5D,0x44,0xEE,0x95,0xBC,0x11,0xFF,0x13,0xA8,
	0x15,0x45,0x48,0x7D,0xBC,0xB3,0xC8,0x8C,0xA4,0x37,0x0F,0x7B,0x4C,0xA7,0xEC,0x15,0x02,0x73,0x23,0xE9,
	0x94,0x9D,0x76,0xCE,0x9E,0xB7,0xCC,0xBD,0x26,0x58,0xAC,0xC5,0x8E,0x0A,0x44,0xE0,0x5E,0x2C,0xD7,0x6E,
	0xE8,0xAB,0x80,0xAD,0x0F,0xF9,0x97,0x9D,0xA5,0x49,0xE8,0xB7,0x64,0x15,0x05,0x63,0x0A,0x19,0x5A,0xD3,
	0x88,0x55,0x2A,0x62,0xEE,0xDF,0x8B,0x40,0x88,0x67,0xEE,0xCA,0xD1,0x12,0xA6,0x6B,0x0D,0x07,0x12,0xEA,
	0x74,0x45,0xE6,0x55,0x3C,0x0F,0x5E,0xF7,0x7A,0xD3,0x4C,0x7C,0x44,0xB2,0x06,0x99,0x25,0xD2,0x6E,0x2C,
	0x92,0x97,0xB0,0x2B,0xAA,0x13,0x66,0x17,0x4B,0xEC,0x82,0x49,0x06,0x14,0xBE,0xD1,0x8B,0x15,0x19,0xAF,
	0x93,0x03,0x89,0x6F,0x75,0x28,0x26,0x83,0x39,0xBA,0x2A,0xAF,0xE9,0x6A,0xA8,0x3B,0x1D,0xC8,0x02,0x30,
	0x5B,0x4B,0x7F,0x9A,0x0D,0x02,0xD6,0x21,0x5E,0xF9,0x90,0x00,0x61,0x60,0x72,0x88,0xBF,0x70,0xA8,0xC6,
	0x3D,0xCF,0xAF,0x54,0xFC,0x75,0x3B,0x8E,0xD9,0x90,0x16,0x23,0xE8,0xA9,0x9F,0x2A,0x50,0x66,0x3D,0xB7,
	0x2F,0x51,0x14,0x81,0x46,0xBE,0xA2,0xA7,0x99,0x12,0xC6,0x42,0xA4,0x36,0xA0,0x5A,0x3B,0x16,0x11,0x25,
	0xE3,0x14,0xB7,0x8B,0xD8,0x2A,0x10,0x18,0xAE,0x86,0x13,0xF5,0x29,0xC1,0x42,0xA0,0x91,0x6D,0xD6,0x8D,
	0xAB,0xDB,0x80,0x23,0x30,0xEE,0x50,0xF7,0x6F,0x49,0x89,0x20,0x6C,0xCC,0xA0,0x84,0xE7,0x21,0x2B,0x08,
	0x0D,0xD9,0xBF,0x81,0xBA,0x55,0xEB,0x98,0x75,0x8C,0x2B,0xC6,0xD4,0x9B,0x2B,0xA3,0xA3,0xAB,0x57,0x59,
	0x52,0x17,0xD6,0x10,0xA1,0x9E,0x73,0x72,0x52,0x5B,0xFC,0x9D,0xB8,0x1A,0xFA,0xF3,0x51,0x09,0x2C,0x3F,
	0x8D,0x95,0x4F,0x0A,0x51,0x0E,0x6D,0x12,0x92,0xCD,0x6B,0x09,0xB1,0xD4,0x7B,0xBF,0xD5,0x0D,0xF4,0xA7,
	0xAA,0x3C,0x5E,0x45,0x70,0xAC,0x1E,0x5F,0x17,0xE0,0x95,0x9F,0xDD,0xCB,0xBF,0x33,0xEE,0x17,0xA9,0x3B,
	0x08,0x42,0x05,0x72,0xCC,0xE9,0xEA,0x86,0xBB,0xD4,0x60,0x78,0xE2,0x07,0xB5,0xAD,0xAB,0x94,0x0E,0x81,
	0x97,0x52,0xBD,0x6A,0x68,0xE6,0xF2,0x9A,0x82,0xDF,0x30,0x56,0x1D,0x61,0x72,0xC9,0xE5,0xA3,0xED,0xFF,
	0xED,0x20,0xD4,0x33,0x42,0x02,0xBF,0x14,0x6F,0xFE,0xF9,0xC7,0x75,0x8A,0xAC,0x2D,0x64,0x45,0x7D,0xD9,
	0x4E,0xDB,0x1C,0x54,0xA9,0xAF,0x8E,0x27,0xA1,0x2F,0x72,0xDA,0x03,0x64,0x77,0x85,0xB4,0x54,0x07,0x0A,
	0xBF,0x13,0x27,0xB1,0x43,0x82,0x88,0x49,0x6B,0x15,0x2A,0xAD,0x8E,0x5C,0x12,0x9E,0x00,0xE3,0x79,0xB4,
	0xA6,0x28,0x1F,0xEA,0x0A,0xB8,0xCE,0x59,0x9C,0x19,0x63,0xDD,0x2A,0xE1,0x7A,0x59,0x1D,0x5D,0x44,0x95,
	0x1A,0xAE,0xDD,0xCC,0x77,0x86,0xF7,0xB1,0xFA,0x75,0x25,0xF3,0x18,0xF3,0xDB,0x31,0x38,0x07,0xF3,0xEE,
	0x3A,0x8B,0x30,0xC1,0x61,0xAB,0xFA,0x66,0x55,0x43,0x5B,0xD8,0x1F,0xF2,0xCA,0xEA,0x36,0x99,0xB3,0xFA,
	0x03,0x57,0x3D,0x89,0x0E,0xF6,0xAD,0x9D,0xD9,0x66,0xD3,0xBA,0xD5,0x65,0xD5,0xAF,0x09,0x4D,0x9C,0x1B,
	0x82,0xB5,0xCF,0xEB,0xA3,0x6F,0xC2,0xC6,0xA4,0x5D,0xB1,0x2A,0x77,0x49,0x12,0x1F,0xB2,0xB8,0xAD,0x3B,
	0x91,0xE0,0xCE,0x69,0x78,0xDE,0xF4,0x55,0x94,0x2B,0x0B,0x68,0x99,0xA2,0xF1,0xF5,0x58,0xFD,0x6C,0xD9,
	0xF4,0x20,0x4F,0x26,0x26,0xEF,0x64,0x20,0xBC,0x7F,0x06,0x26,0x3D,0x7B,0x57,0x2E,0x49,0x04,0x30,0x8C,
	0x59,0x9E,0x48,0x5B,0xC9,0x03,0x62,0x2D,0x45,0x98,0x19,0x43,0x13,0xC1,0xB9,0xC6,0x62,0xE3,0x47,0x71,
	0x32,0xFC,0xB8,0xFD,0x46,0x9C,0x73,0xEF,0x84,0x6F,0x86,0xD9,0x0D,0xAE,0xF0,0x5F,0xFB,0xA2,0x90,0x35,
	0xC3,0x9D,0x3A,0x31,0x77,0x37,0x5A,0x29,0x0B,0x95,0xB8,0xC7,0xED,0x92,0x45,0x54,0x72,0x01,0x74,0xEE,
	0xD9,0x32,0xAB,0x0B,0x2A,0xBD,0x15,0x58,0x35,0x75,0x31,0xDA,0xEC,0x8E,0xE1,0xEA,0x2A,0x52,0xD7,0x55,
	0x83,0x35,0xB0,0xE1,0x3A,0x70,0x25,0xD6,0x78,0xA4,0x1C,0xDE,0x44,0x8C,0x11,0x14,0x34,0xC4,0x14,0x6A,
	0xAE,0xED,0x7E,0x67,0xEE,0xAA,0x9F,0x52,0x50,0x62,0x16,0xD8,0xA6,0x29,0xD8,0x49,0x75,0x00,0xAE,0xB6,
	0xFE,0x8D,0xD6,0x5A,0x9D,0x91,0xB6,0xAF,0x70,0xF3,0x95,0xEB,0xDC,0x90,0x23,0xA7,0xEA,0xB8,0x07,0x24,
	0x62,0x20,0x97,0x63,0xBE,0x28,0x42,0xD1,0x90,0x52,0x97,0x2A,0xC6,0xB8,0x1E,0x58,0x59,0xD6,0x88,0x30,
	0x0D,0x18,0x44,0xBC,0x89,0x7A,0x8D,0x43,0xD7,0x4E,0x22,0xA3,0x0C,0x22,0x78,0xC8,0xF8,0xED,0xF8,0xF7,
	0x03,0xFE,0x87,0x17,0x0C,0xDE,0xF1,0xE2,0xC8,0x2C,0xF8,0xE6,0x60,0x9D,0x58,0x8B,0xD7,0xC1,0x2B,0x2B,
	0xC0,0x74,0xDF,0xCB,0xD3,0x0A,0x30,0xF5,0xD9,0xF6,0xD3,0xEB,0x16,0x71,0xC4,0xBF,0xA8,0x82,0xEA,0x6B,
	0x8B,0x7A,0x15,0x06,0x75,0xA1,0x54,0xEB,0x17,0x2C,0x04,0x2A,0x6D,0xD4,0x69,0x46,0x13,0x5A,0x8F,0xB3,
	0x46,0xEE,0xD9,0xAA,0xF8,0xD3,0x44,0xB2,0x1C,0x28,0x75,0xF1,0xE3,0x18,0xA9,0xB7,0x48,0x4E,0x3C,0x09,
	0x18,0x60,0x02,0x5A,0x76,0xBE,0x15,0x1C,0x99,0x18,0x1E,0x9E,0xAF,0x24,0x60,0x45,0x9B,0x7F,0xA0,0x62,
	0xD5,0x5E,0xB9,0x8C,0xF4,0xAB,0x9A,0xDA,0x1B,0x2C,0x6B,0x5E,0xB7,0x82,0xC4,0xCE,0x0B,0x5D,0xD1,0xA4,
	0x90,0xFA,0x30,0x55,0xD5,0x81,0xBA,0xAB,0x46,0xC5,0x2A,0x2C,0x17,0xE9,0x15,0x26,0x86,0x06,0xCB,0xFD,
	0x9B,0xE5,0x45,0x9A,0xE9,0x03,0x78,0xF2,0x5A,0x90,0xB1,0x4E,0x46,0x96,0xD7,0xD1,0x22,0xE8,0x1F,0xAF,
	0x29,0xFB,0xB0,0xF9,0x02,0x29,0x71,0x39,0x15,0x25,0x56,0x14,0x6D,0x45,0x11,0x98,0x59,0x1C,0x29,0x2C,
	0x46,0xCB,0x79,0x19,0x34,0x4B,0x0F,0x8E,0x80,0xF0,0x82,0x13,0xDF,0x2B,0x47,0x7F,0x1C,0x91,0x57,0x56,
	0x56,0xEC,0x8E,0xC3,0xF0,0x4A,0x6A,0x8D,0xEA,0x93,0x8D,0x2C,0xE5,0xCA,0xDD,0x78,0xE5,0x06,0x1D,0x09,
	0xD1,0x51,0x91,0x80,0xDD,0x85,0xC9,0xEC,0x22,0xEC,0x45,0x76,0x83,0x4C,0x86,0x56,0xCB,0x95,0x86,0xC3,
	0x77,0xD9,0xD6,0xFA,0xBE,0x01,0xA9,0x80,0x1F,0x2A,0xF7,0xB9,0x9C,0x5C,0xF8,0x6E,0x7C,0x57,0x70,0x45,
	0x5D,0xB4,0xA9,0xA4,0x01,0x55,0xE4,0x41,0x55,0x41,0x92,0xBA,0xA6,0xFD,0xC1,0xC2,0x4A,0x96,0x56,0x4C,
	0x12,0x8C,0xE8,0x3E,0xF8,0x6A,0x58,0x73,0x30,0x38,0xB0,0x08,0x02,0xB9,0x06,0xCC,0x44,0x8A,0x89,0x18,
	0xAD,0xB2,0xEA,0x92,0x13,0xF5,0xC6,0x87,0x6E,0xAF,0x72,0x05,0xA3,0xB6,0x12,0x7C,0x3B,0xE3,0x9A,0xB3,
	0x3D,0x0A,0x67,0xC0,0x2C,0x36,0x5B,0x6F,0x6D,0x61,0xAE,0x4A,0xD4,0x64,0xCC,0x39,0xBA,0x4E,0xE8,0x23,
	0x33,0x57,0xE1,0x12,0x57,0x6C,0x0D,0x06,0xF1,0x66,0x48,0xB2,0xC5,0xB7,0x3C,0xEE,0x7E,0x46,0x14,0x8D,
	0x27,0xD6,0x6E,0x67,0xFC,0x97,0xD7,0xA5,0xB8,0xDB,0xCC,0xC3,0x82,0xBF,0x44,0x17,0xCA,0x7C,0xA0,0xB2,
	0x53,0x80,0x04,0x14,0x78,0xC7,0xFF,0x2D,0xA2,0x25,0x44,0x17,0x88,0xC4,0x6D,0xF6,0x21,0xFB,0x20,0xA9,
	0x54,0x33,0xBF,0x4F,0x8D,0x73,0x6F,0xE1,0x94,0xBA,0xBA,0x4C,0xB8,0x1A,0x22,0xED,0xD4,0x9C,0x76,0xC3,
	0x09,0x4F,0x3F,0xAE,0xD2,0xB4,0xA9,0x93,0x9C,0x77,0x78,0xE2,0x57,0x39,0xF3,0x70,0x30,0x45,0x75,0x79,
	0x4E,0x09,0xE0,0x0A,0xE1,0x97,0x43,0x2E,0x19,0x76,0xE5,0x23,0xDE,0xDE,0x20,0x83,0xD0,0xD3,0xC1,0x8A,
	0xA1,0xE5,0x82,0xAC,0x61,0x80,0xC1,0xD4,0x7B,0x21,0x90,0xC8,0x91,0x17,0x1F,0x6F,0x3F,0xF0,0xFC,0x6E,
	0x34,0x75,0xD2,0x8F,0x78,0x00,0x6B,0xD6,0xAE,0xB2,0xA8,0xC5,0xF4,0xE1,0x98,0xA2,0x6E,0x90,0x81,0x32,
	0x12,0x5B,0x3D,0xBC,0x4C,0x14,0x71,0x5F,0x0C,0x59,0xB7,0x9D,0x2E,0xD8,0x4B,0xE2,0x7C,0xE5,0xFF,0xE9,
	0x71,0x2E,0x8D,0x18,0xDC,0xE0,0xE1,0xA4,0xA0,0x86,0x0A,0x54,0x58,0x3A,0xD1,0x25,0x1C,0xA8,0xAC,0xF7,
	0xAE,0xEF,0xF3,0x9E,0x71,0xF9,0x0B,0xEE,0x33,0xC1,0x29,0x04,0x55,0xF1,0xDF,0xDC,0x53,0xE3,0xF1,0x60,
	0xED,0xBB,0xE7,0x32,0xB4,0xA6,0xE1,0x4E,0x55,0x48,0xD5,0x45,0xA5,0xCC,0x0C,0x88,0xC6,0xD3,0x49,0xD4,
	0x0A,0x8E,0xCD,0xC1,0x8F,0x18,0xBC,0x0F,0x8C,0xFA,0x75,0x3A,0x9C,0x0F,0xF7,0x91,0x89,0xD9,0xE0,0x3B,
	0xA9,0xFE,0xB6,0x16,0x53,0x08,0xFD,0x38,0x6B,0x12,0x71,0x62,0xDE,0xEA,0x67,0x77,0xBD,0x7B,0x66,0xA6,
	0xD8,0x80,0xF3,0x58,0x4A,0x9E,0xC5,0x32,0xBA,0x25,0xBC,0xC6,0x76,0x3F,0x89,0x7A,0x90,0x1F,0xF5,0x81,
	0xBC,0x6E,0xFC,0x24,0x7E,0x85,0xED,0x08,0x8A,0xD3,0x87,0x55,0xEE,0x72,0x28,0x98,0xC8,0xF5,0xED,0x2C,
	0xAD,0xD2,0xA8,0xB9,0xBE,0xA9,0xCC,0x3D,0xB6,0x4D,0xE1,0x6F,0x43,0x51,0xD4,0x16,0x39,0xEB,0x27,0x93,
	0xBB,0x5F,0xC7,0x19,0xB2,0x3D,0xAE,0x73,0xAA,0xCC,0xAE,0xC9,0x61,0x7E,0xE9,0x18,0xEF,0xF3,0x9D,0xB3,
	0x2B,0x93,0x5B,0x6F,0xEA,0xAF,0x37,0x2D,0xAB,0x3A,0x37,0x9C,0x1C,0xB0,0x51,0xD0,0xED,0x56,0xB3,0x1B,
	0xC1,0x6D,0xCD,0x94,0xE2,0xE4,0x4F,0x44,0x3C,0x5F,0xD3,0xDE,0x55,0x84,0xE2,0x38,0xB1,0x88,0x4C,0xFE,
	0x80,0x59,0xC3,0xB8,0x6C,0x93,0x98,0x38,0x5D,0x25,0x70,0xD4,0x70,0xB7,0xA8,0x2F,0x00,0x4F,0x9A,0x06,
	0x0C,0xAA,0xFA,0x5B,0x7F,0x18,0xF8,0x4F,0xB6,0x41,0x7A,0xF1,0x43,0x1E,0x71,0x2C,0xEE,0xDC,0x72,0x20,
	0x08,0x24,0xA6,0x9D,0xEA,0x29,0x56,0x54,0x38,0x49,0xEA,0x2F,0x8F,0xC2,0x6B,0x2E,0xF8,0x61,0x6A,0x6E,
	0xDD,0x58,0x3F,0x71,0xF9,0xC0,0x4E,0x4B,0x6F,0x11,0x1A,0x77,0x42,0x2F,0x69,0xED,0x7B,0x8D,0x52,0x1C,
	0x3B,0x9F,0x76,0x9F,0xA6,0x42,0x9D,0x0A,0xC1,0x8E,0x1D,0xF2,0xCA,0xA1,0x6B,0x65,0xF8,0x26,0x1A,0x7B,
	0xC5,0x8F,0x16,0xC5,0x3B,0x18,0x75,0x9B,0xE6,0x1B,0xAB,0x2D,0xE5,0xEB,0x89,0xCB,0xCA,0xE9,0xE9,0x58,
	0x22,0x85,0xB5,0xF4,0x3F,0xB3,0xCA,0xEF,0xAA,0x9F,0xC1,0x03,0x5D,0xF2,0x2E,0xC8,0xD4,0xE3,0x49,0xA7,
	0x27,0x2C,0xF5,0x6E,0x41,0x55,0xDD,0x1C,0x03,0xA2,0x5E,0xE8,0xBB,0x1E,0x0E,0x1F,0xDC,0x1C,0x43,0xDF,
	0x09,0x3B,0x1D,0x2E,0xE3,0x93,0x88,0x4D,0xB7,0x09,0x4B,0xE0,0xCE,0x90,0x6F,0x8B,0x06,0xC4,0x10,0x51,
	0x1A,0xAC,0xFD,0xB7,0x3E,0x86,0x27,0xD0,0xF4,0x15,0x3F,0x45,0x68,0x39,0x0D,0x62,0x9F,0x07,0xCC,0xA0,
	0xFB,0xB3,0x12,0xFB,0x4B,0x07,0x56,0x2D,0x0A,0x21,0x35,0x15,0x82,0x6E,0x3D,0x96,0x46,0x6E,0x52,0x31,
	0x15,0xFE,0xE4,0x1D,0x4C,0x95,0xB4,0x12,0x17,0x2F,0x18,0x80,0x71,0x70,0xFE,0xFF,0xC3,0x34,0x96,0xC7,
	0x16,0x84,0xF9,0x6C,0xDE,0x7D,0x4D,0xC5,0x78,0x75,0x52,0x4D,0xDA,0xB2,0x28,0xD4,0x9D,0x8C,0x62,0xD5,
	0x97,0x51,0xC9,0x08,0xC4,0x1E,0xB3,0x4D,0x47,0x4F,0x88,0x95,0x42,0x7D,0x1D,0xFC,0x89,0xCE,0xF4,0x61,
	0x82,0x73,0xCB,0x60,0x0E,0x48,0x57,0x53,0x18,0x23,0x28,0xFB,0x7D,0xF5,0x0C,0x10,0xE1,0x2D,0x18,0x9A,
	0xE5,0x01,0x1B,0x36,0x18,0x5A,0x06,0x31,0xFE,0xDB,0x19,0x19,0xAC,0x9C,0xFF,0x3F,0x19,0x50,0x04,0x6E,
	0xFF,0x6E,0x52,0x6D,0x62,0x52,0x77,0xC4,0x3B,0xB9,0x9F,0x65,0xAE,0xAE,0xC2,0x3D,0x16,0xEC,0x74,0xE8,
	0xEC,0xC8,0x56,0x32,0xBF,0xAC,0x20,0x1B,0xBD,0x12,0x02,0x5F,0x08,0x59,0xC4,0x40,0xA3,0x19,0x83,0xD3,
	0xD0,0x54,0xB0,0x20,0x49,0xB9,0xC6,0xD2,0xB2,0x10,0x49,0x09,0x18,0x7B,0x46,0x1C,0x30,0x24,0x5C,0x06,
	0xE0,0xA1,0xA0,0xFA,0x7A,0x6A,0x29,0x40,0xB2,0x60,0x62,0xF6,0x3E,0x43,0x4B,0x10,0x10,0x41,0x06,0x89,
	0x0E,0xDC,0x6F,0x79,0x41,0x08,0x6A,0xD4,0x4A,0x0D,0x10,0x2D,0x46,0xB9,0x0D,0x47,0x61,0xF3,0x06,0x60,
	0x29,0x60,0x26,0x45,0xD1,0xE7,0x2F,0x9F,0x2F,0xBB,0x54,0xA7,0x67,0x2C,0xD4,0x5F,0x96,0xF7,0x06,0xEE,
	0x61,0x12,0xB0,0xE3,0xB0,0x83,0x24,0xE4,0x0E,0x74,0xCB,0xB9,0x88,0xBC,0xCC,0xB9,0xFE,0x6A,0xB2,0xDE,
	0xC4,0x80,0x30,0x2A,0xA2,0xAF,0xDE,0x97,0xAB,0xAE,0x05,0x6A,0x4E,0x15,0x73,0x89,0x35,0x29,0x5F,0x7B,
	0x7E,0xB0,0x42,0x24,0x96,0xF5,0x9D,0xF5,0x80,0xED,0x8A,0x58,0x04,0x9E,0x7C,0xAA,0x3B,0xD1,0xF2,0xAD,
	0x88,0xAA,0x21,0xEC,0x92,0xBB,0xFB,0x36,0x7D,0x31,0xE8,0x72,0x7C,0xB7,0xEA,0x5A,0xCC,0x02,0x17,0xBA,
	0x84,0x5F,0x6F,0x80,0x41,0x75,0xBF,0xA6,0x0D,0xFF,0x17,0x4F,0x0F,0x54,0x55,0xF4,0x1E,0xC1,0x9E,0x18,
	0x0D,0xD0,0x0F,0xC7,0x92,0xA0,0x20,0x5B,0x75,0x91,0x87,0x7B,0x0E,0xE5,0xC4,0x37,0xEB,0x5D,0x1F,0x03,
	0x5B,0x87,0x55,0x6F,0xDD,0x02,0xAF,0x3C,0xD3,0x85,0x31,0x6D,0xDE,0xD6,0x33,0x0C,0x92,0xE5,0x11,0xC5,
	0x2F,0xDF,0x29,0x79,0x71,0x18,0x55,0x88,0x2F,0x9C,0xED,0xA6,0x97,0x4B,0x75,0x13,0xA2,0x8A,0xB2,0xC5,
	0xDC,0x32,0x6B,0x49,0x55,0x74,0x1E,0xDC,0x2C,0x17,0xA0,0x45,0x52,0x9F,0xD4,0xFB,0x27,0x41,0x13,0x92,
	0x7B,0xE5,0x01,0xCC,0x82,0x0D,0xB8,0x3D,0x0F,0x6D,0xF8,0x1B,0x4E,0x54,0x81,0xB9,0x38,0x96,0x46,0x61,
	0xE4,0x8E,0x71,0x20,0x58,0x18,0x60,0xCC,0xFF,0x59,0x60,0xC6,0xFD,0x47,0x39,0x79,0x82,0x43,0x7C,0x87,
	0xCC,0x00,0xC8,0x23,0xA6,0x08,0xE8,0x16,0x57,0x82,0xA3,0xAB,0x7D,0xB6,0x9E,0xFE,0x12,0xF2,0xC0,0xF4,
	0x4D,0x4D,0x99,0x75,0x18,0xA8,0x29,0xB3,0x7D,0xD7,0xD6,0xCF,0x2F,0x61,0xBB,0x2A,0x43,0x12,0x35,0x1E,
	0xBE,0xC3,0xD2,0xC1,0x61,0x50,0x2C,0xFA,0x3A,0xC0,0xAE,0xE6,0xFD,0xF8,0xDD,0x6F,0x40,0xEE,0xD8,0xF8,
	0xCC,0x55,0x3C,0x88,0xA2,0x92,0xA9,0x39,0xC8,0x9E,0x92,0xAF,0x75,0x01,0x8E,0x94,0xEA,0x0D,0x72,0xC1,
	0x1C,0xC6,0xC6,0x0D,0x3B,0xD6,0xAB,0xE8,0x90,0x84,0x28,0x5E,0xE3,0x99,0x12,0xFC,0x60,0x15,0xC8,0xA0,
	0x6F,0xB8,0x2F,0x71,0x97,0xB0,0xF3,0x92,0xF1,0x47,0x7F,0xB6,0xAC,0xE1,0x11,0x87,0xBA,0xD3,0xD4,0x56,
	0x48,0x8C,0x5A,0xDF,0x91,0x07,0x09,0xEB,0x7D,0xDC,0x5D,0x2E,0xBA,0xB2,0xDD,0x6E,0x60,0x57,0x38,0xFF,
	0xBA,0xD5,0x43,0x8F,0x1C,0xE8,0x2E,0x94,0x40,0xE5,0x5F,0xC7,0x41,0x93,0xBC,0xD2,0xDB,0xE9,0xF3,0x97,
	0xF1,0x53,0x7D,0xD7,0xB5,0xAB,0xF2,0xF9,0xC1,0x03,0x74,0x18,0x0E,0x72,0xA5,0x2D,0xFC,0x69,0x32,0xEC,
	0xAA,0x61,0x58,0x07,0x73,0x70,0x60,0x80,0xA0,0x55,0x91,0x62,0x3E,0x18,0xFD,0x30,0x03,0xB7,0x9D,0x86,
	0x47,0x68,0xC0,0x86,0x78,0xF3,0x63,0x6B,0xA2,0xBF,0x2D,0x2D,0x7B,0x25,0x64,0xAA,0xBF,0xB8,0x96,0x67,
	0x31,0x25,0xF3,0x2D,0xD7,0x4C,0x55,0x1D,0xBE,0x14,0xA4,0x1E,0x15,0xF4,0x74,0x50,0xC1,0xFB,0x70,0x27,
	0x9F,0xDD,0x43,0xF3,0x6B,0xF1,0x2F,0x98,0xB0,0x7B,0xF8,0xBB,0xB7,0xCD,0xB5,0x68,0x5C,0xFF,0xE7,0xAB,
	0xA7,0xA2,0xC6,0x6F,0x8D,0x82,0x41,0xA3,0x54,0xE6,0x0A,0x92,0x58,0xD4,0x51,0x9D,0xAC,0xAF,0x4F,0x54,
	0x17,0x93,0xF5,0x6B,0xE0,0x81,0x1A,0x06,0x30,0x7B,0xE7,0x3C,0x97,0x44,0xB1,0x66,0xB2,0x9F,0xD4,0x6A,
	0xCB,0x98,0xD5,0xCE,0x5F,0x7C,0x99,0xA1,0x88,0x4D,0xC1,0x44,0xBD,0xDB,0xEE,0x4B,0x74,0xC6,0x0F,0x40,
	0xCE,0x58,0x4A,0xBE,0x0A,0x6B,0x2D,0x7A,0xFF,0x1E,0xB1,0xF5,0x4D,0xB7,0x03,0x18,0x4B,0xF4,0xB2,0x63,
	0xD2,0x7C,0x39,0x72,0x0D,0x41,0x2D,0x6A,0xB0,0xEB,0x3A,0x01,0x48,0x99,0x98,0xAF,0x3C,0x4E,0xF6,0x14,
	0xC4,0x3D,0x62,0xF9,0xD5,0x01,0xBC,0xC8,0x14,0x2A,0x3D,0x4A,0x19,0xD4,0x0C,0x9E,0x5B,0x1E,0x5D,0x78,
	0xE5,0x82,0xF4,0x42,0xF4,0x44,0x4B,0x17,0xD3,0x48,0x4E,0x4C,0x80,0x62,0xF4,0x26,0xEE,0x3C,0x3F,0x1D,
	0xD7,0x33,0x3F,0xB7,0x34,0xF9,0xF5,0x86,0x97,0xA0,0x35,0xAB,0x27,0x52,0xAB,0x16,0x21,0xFA,0xD3,0xA0,
	0xFF,0x6A,0x85,0xAE,0x95,0x25,0xCB,0xE5,0x2E,0x9F,0x14,0xC8,0x8A,0xC9,0x7A,0xCD,0x5B,0x88,0xC2,0xB0,
	0x28,0xAD,0x73,0x07,0x5C,0xA6,0x9E,0x8E,0x42,0xFC,0x3B,0x61,0x58,0x90,0x85,0x63,0x4B,0x01,0xA9,0xBD,
	0x6F,0x25,0xB7,0x9F,0x93,0xB9,0x96,0xBF,0x02,0x87,0xE3,0x6A,0xB8,0xAA,0xE7,0x18,0xCF,0x34,0xDE,0xC3,
	0xCE,0x6A,0xDB,0x9F,0x35,0xCD,0xDF,0xD0,0x81,0xA0,0x16,0xDC,0xC7,0xBC,0xD2,0x30,0x3A,0x4F,0x67,0x3C,
	0xED,0xBB,0x35,0xAE,0x5A,0xED,0x82,0x70,0x65,0x9B,0x84,0xDC,0xEC,0x25,0x84,0x9B,0x33,0x4E,0x79,0x45,
	0xA3,0x5D,0x4B,0xB0,0x43,0x3A,0x60,0x26,0xCD,0x51,0xBB,0xB9,0x07,0x7F,0x74,0xA9,0x84,0x8A,0xA4,0xF1,
	0xFB,0x9C,0x96,0xD5,0x76,0xCB,0xE4,0x48,0x6A,0x0F,0xCE,0xD2,0xBD,0x42,0x6D,0xDD,0xF5,0xDF,0x6B,0xA3,
	0x3B,0x50,0x00,0xFD,0x9C,0xA3,0x86,0x45,0xEA,0x19,0x7A,0xB3,0xBE,0x88,0x57,0x3A,0x06,0x63,0x97,0xEE,
	0x93,0xD6,0x5F,0x04,0x03,0xD4,0xCC,0x29,0x61,0xAE,0xFA,0x5A,0xDC,0xB8,0x99,0x2D,0x66,0x6A,0x16,0x81,
	0x00,0x2B,0x2C,0xFB,0x02,0x20,0x8B,0xFA,0xF2,0xA6,0x30,0x4E,0x9E,0x87,0x62,0xF5,0xC1,0xEF,0x77,0x41,
	0x5D,0x6B,0x59,0x20,0x3E,0x39,0x10,0x0C,0xF0,0x4E,0xA3,0x86,0xEE,0x8B,0x9D,0x70,0xF0,0xD5,0x46,0x98,
	0xA5,0x7B,0xD0,0xD9,0x3E,0xA7,0x19,0x74,0xCC,0x35,0xE3,0xAA,0x53,0xEF,0x1B,0xB5,0x4A,0x92,0xB7,0x4A,
	0x10,0x12,0xF1,0x32,0x0F,0x82,0xB0,0x37,0x4E,0x61,0x1B,0xF8,0x78,0x75,0x88,0x98,0x9E,0xAE,0x16,0xB6,
	0xAB,0x1C,0x74,0xE7,0x42,0x52,0xCF,0x1A,0x98,0xC7,0xE9,0xFB,0xBD,0xF1,0x73,0x48,0x30,0x08,0x19,0x26,
	0x01,0x4B,0xE8,0xBF,0x0E,0x38,0x14,0x83,0x31,0x04,0x05,0x13,0x93,0x82,0x31,0x2C,0x66,0x23,0xDB,0x2D,
	0xA3,0xCE,0x69,0x72,0x8E,0x71,0x61,0x9F,0x8C,0x7C,0xFF,0x73,0x76,0x20,0x3E,0xB7,0x27,0x96,0x95,0x99,
	0x78,0x7F,0xA9,0xF0,0x7D,0x25,0xC1,0x9A,0xF5,0x82,0xE8,0x72,0xFF,0x2C,0x7F,0xCD,0x3A,0x0A,0xD1,0x3B,
	0xC0,0x64,0xA8,0x03,0xC6,0x87,0xA2,0x4B,0xCC,0x05,0x5E,0xC8,0xF7,0x25,0x80,0x6D,0xD9,0xA1,0x2B,0xFC,
	0xC6,0x4E,0xB5,0x70,0x51,0x68,0xB0,0x02,0xA3,0x42,0xD8,0x8B,0x94,0xAF,0x4C,0x05,0xD0,0xF2,0x5F,0xD2,
	0xD7,0x56,0xF2,0x5F,0x21,0x3B,0xD0,0xC5,0x44,0x91,0xF9,0xAE,0x03,0x55,0x2A,0xC8,0x39,0x4B,0x31,0xF7,
	0x35,0xC4,0xAA,0x78,0x6B,0x48,0x2C,0x6D,0x88,0x47,0x19,0xF2,0x90,0xA2,0x73,0x85,0x35,0x4C,0xA5,0xAB,
	0x76,0x60,0xD3,0xB5,0x9D,0x23,0x5D,0x7D,0x5A,0x15,0x9A,0xAE,0xE2,0xDC,0xE5,0xC0,0xEC,0x60,0x6C,0xE7,
	0x1A,0x44,0x33,0x28,0x54,0x83,0xCE,0x3C,0x86,0x0B,0x65,0x50,0xBC,0x5F,0x02,0xC2,0x30,0x8C,0xB0,0xDB,
	0x60,0x8D,0x2A,0xCE,0x89,0xAC,0x31,0x44,0x66,0x03,0xA6,0x9A,0xE6,0xC6,0x71,0x36,0x5C,0xD0,0xB1,0x4E,
	0x29,0xE8,0xC4,0x68,0xAD,0xE5,0x3A,0x28,0x1D,0x5C,0xE9,0xC6,0xB8,0x76,0xE3,0xA7,0x63,0x9C,0x2D,0x24,
	0x4C,0xBF,0x18,0x42,0x47,0xD0,0x90,0x91,0x14,0x40,0x2E,0x46,0x97,0x87,0xDF,0x0B,0x41,0x3A,0x83,0x8E,
	0x8A,0xF1,0xCB,0x1D,0x7B,0x26,0x49,0x17,0x23,0x5E,0x25,0x2F,0xD4,0xAB,0xA3,0x65,0xA0,0x22,0xD7,0x09,
	0x18,0x89,0x5D,0x80,0x5E,0xDF,0xAA,0x1F,0x44,0x7C,0x00,0x00,0xFD,0x02,0x55,0x85,0xF3,0xE5,0x2C,0x62,
	0x30,0x98,0xF2,0x8A,0x63,0x10,0x93,0x60,0x1E,0x04,0x57,0x07,0x24,0x38,0x10,0x04,0x91,0x07,0x4B,0x5A,
	0x1C,0xBD,0x65,0x80,0xDF,0x05,0xDC,0x44,0xED,0x12,0xED,0x0E,0x45,0x49,0x6F,0xE7,0xFE,0x00,0x8F,0xB9,
	0x10,0xB9,0x32,0x34,0xB0,0xB7,0x1F,0x20,0x35,0xF8,0x2A,0xB6,0xA9,0x31,0xCA,0x5E,0x99,0x52,0x10,0xE4,
	0x17,0xE7,0x8C,0xC9,0xAE,0x1D,0x54,0xE4,0x48,0xF7,0xE9,0x5E,0xD9,0x67,0x52,0xE5,0x72,0xA2,0x33,0x8F,
	0xDB,0xF5,0x97,0xAE,0x2D,0xCE,0xAB,0xB5,0xAE,0x7E,0x8C,0x5D,0x93,0x8D,0x49,0xC9,0xF8,0x61,0xD5,0x3D,
	0x65,0x02,0x2E,0xE9,0x30,0x80,0x24,0x64,0x24,0xD4,0x63,0x56,0x0B,0xC7,0xD7,0xA1,0x1C,0xEA,0x73,0x61,
	0xCC,0x8D,0xC3,0x4F,0xCA,0x6E,0x82,0x93,0xB1,0xFC,0x7A,0x07,0x70,0x9C,0x7D,0xBD,0x09,0xA7,0x3A,0x0E,
	0xB2,0xBD,0x3B,0xBD,0x39,0xD1,0x91,0x83,0xA8,0xA1,0x29,0x55,0x45,0xAA,0x5E,0xDA,0x23,0x55,0xFF,0x74,
	0x7E,0x69,0x69,0xE9,0x31,0xEF,0x18,0x92,0xC4,0xED,0x15,0x4B,0x77,0xD5,0xB5,0x5B,0x45,0xF5,0x9C,0x26,
	0xE9,0xDC,0x0A,0xC3,0x85,0xE3,0x48,0x4D,0x55,0x83,0xEC,0xBB,0xFA,0x58,0x84,0x8D,0x3F,0x11,0x59,0xD6,
	0x12,0xA4,0xF1,0x9F,0x3D,0x53,0xD1,0x63,0xD2,0x98,0x35,0x8E,0x14,0xF5,0x06,0x62,0xC8,0x10,0xB7,0xC3,
	0x05,0x45,0x3D,0x2C,0xBE,0xF7,0xD4,0x80,0xB5,0xE4,0x43,0xF3,0xD4,0x83,0x6C,0x94,0x39,0x67,0xAA,0xB1,
	0x9D,0xDF,0xAF,0x9B,0x17,0x96,0x99,0x1A,0x15,0x40,0xD9,0x02,0x23,0xC3,0xFF,0xD8,0x08,0x38,0x1B,0x7B,
	0xD0,0x6A,0xC3,0xF6,0x71,0xF3,0x6F,0xCE,0x57,0x28,0x8E,0x03,0x74,0xE7,0x5D,0xA4,0x47,0xBB,0x6A,0xBE,
	0x33,0xB9,0x50,0x2D,0x59,0x53,0x34,0xB0,0x89,0xC4,0x5F,0xA2,0x8D,0x25,0x54,0x2B,0xEA,0x5A,0xB0,0x77,
	0xEB,0x0D,0xC6,0x60,0xA6,0x59,0x0B,0x8C,0x00,0xB9,0x54,0x3C,0x44,0x63,0x85,0x1B,0x30,0xDE,0x24,0x35,
	0xFB,0x75,0x36,0xB4,0x7C,0xE8,0xA5,0x71,0x22,0x7D,0xC3,0x2F,0x50,0x81,0x27,0x25,0x9E,0xAC,0xA5,0x6B,
	0x3B,0xF4,0x80,0x31,0x96,0x7C,0x46,0x05,0x29,0x34,0x10,0x07,0x2B,0x45,0x6F,0xA3,0xA1,0xF1,0xA5,0x3A,
	0x7B,0x38,0xCA,0xF2,0x9A,0xA5,0x66,0x2F,0x54,0x7E,0xB8,0xBF,0x9A,0x5B,0x21,0x39,0x36,0x0B,0x1E,0x4B,
	0xDD,0xDA,0x28,0x89,0x17,0x13,0x4B,0xFC,0x9D,0xE9,0xA1,0xC0,0x2E,0xEE,0xEB,0x49,0xEF,0x90,0xF2,0xC8,
	0x3C,0xBF,0x5A,0x2F,0x62,0x3B,0xBC,0x7B,0x25,0x5A,0xE0,0xEF,0xB5,0xBF,0xDC,0xB1,0xD2,0xC2,0xB1,0x9E,
	0x2E,0xD1,0x02,0xC2,0x9D,0x17,0x0B,0xB9,0x7A,0x06,0x73,0xE0,0x7C,0x21,0x36,0xFA,0x8E,0x43,0x4A,0x57,
	0x0E,0xB3,0xFA,0xE6,0x2C,0xD6,0x87,0x33,0x50,0xE1,0x21,0x45,0x69,0xAB,0x02,0x9E,0x35,0x1B,0x7A,0x19,
	0x46,0x30,0x5B,0x34,0xE8,0xA9,0xEA,0x50,0x46,0xB7,0xC1,0xF1,0x97,0x77,0x14,0xD2,0x58,0x7D,0x55,0xDC,
	0xAE,0x2D,0x33,0x50,0xC0,0xD5,0x58,0x32,0x11,0x07,0x46,0x57,0xF3,0xDA,0x18,0x75,0x02,0xB2,0x03,0x15,
	0x40,0xC7,0x7D,0x40,0x64,0xEA,0xFC,0xEF,0x21,0x1F,0xDC,0x24,0x55,0xE0,0xD8,0xD2,0xFB,0xB0,0x2D,0x49,
	0x92,0xD8,0xC1,0xE6,0x0B,0xC1,0x1D,0xFB,0xF9,0xE6,0x61,0x55,0x88,0xF3,0xCE,0x07,0xFF,0x85,0x07,0xC0,
	0xD6,0xDD,0xBD,0x2E,0xC2,0x31,0x5A,0xE6,0xBF,0x18,0x0E,0x26,0xA2,0xD5,0x1A,0xA0,0xF6,0xDD,0x49,0xAC,
	0x23,0x75,0x9D,0xB8,0xC3,0x51,0xAD,0x14,0xB0,0xF2,0xC0,0x40,0xB0,0xB2,0xFA,0x17,0x06,0xCE,0xD5,0xC9,
	0x69,0xA5,0x6B,0x89,0x98,0x8F,0x71,0x2E,0x55,0xC8,0x02,0xDE,0x37,0x85,0xBF,0x17,0x97,0xEC,0xEA,0x01,
	0xE0,0x5E,0x89,0xAE,0x8F,0xA3,0xB0,0x2E,0x54,0xEE,0x84,0x8F,0xA2,0xAC,0x82,0x28,0x5F,0x74,0x4A,0x5D,
	0x7D,0x62,0xCA,0x93,0x7F,0x95,0xAF,0x28,0xBE,0x06,0xF3,0x17,0xE0,0x16,0x24,0x7F,0x41,0x71,0x21,0xA1,
	0x37,0x1C,0x6C,0x5B,0x61,0x55,0x3D,0xD7,0x44,0x2D,0x20,0xBA,0x92,0x50,0xE6,0xFD,0x85,0x5F,0x1F,0xC8,
	0xEC,0x46,0xEF,0x42,0xA6,0x83,0xAB,0x62,0x58,0x37,0xB0,0xDD,0x85,0x50,0x41,0x76,0xAB,0x5F,0xEA,0x2D,
	0x2D,0x0D,0x8B,0x63,0xC8,0x64,0xB3,0x36,0xE9,0x55,0x2A,0xDF,0x0E,0xE1,0x5B,0xC3,0x11,0xF0,0xC2,0x57,
	0x0E,0x6B,0x80,0xD0,0xC3,0x74,0xD8,0xD6,0xCA,0xBB,0xF4,0x65,0x44,0xB9,0xC7,0x43,0xF5,0xD1,0x0E,0x07,
	0x33,0x06,0xC8,0x28,0xBD,0xBE,0x09,0x62,0x4C,0x6D,0xBE,0xF0,0xA5,0x8A,0x5F,0x5D,0x6D,0x6F,0x2C,0x20,
	0x57,0xA9,0x76,0xC0,0x60,0x60,0x31,0x3A,0xA1,0xAE,0x47,0xBC,0x78,0xE8,0x7E,0x15,0xE2,0xCD,0x07,0xC3,
	0x77,0xB1,0x4E,0xFA,0x58,0x5F,0xA1,0xD7,0x0E,0x77,0x0A,0x37,0x51,0xBF,0xE8,0x03,0xA4,0xFA,0x20,0x98,
	0xB8,0x82,0xB4,0xC8,0x01,0xD9,0xB5,0x93,0xB1,0x41,0xB7,0x2A,0x84,0xD5,0xEC,0xA3,0x3D,0x70,0x1F,0x16,
	0x72,0x80,0xF6,0xC4,0x87,0x6A,0x41,0x15,0x47,0x64,0x95,0xC9,0x9F,0x7B,0xB6,0x1F,0x2F,0xF7,0xAF,0x1E,
	0x1F,0x7C,0xCF,0x5D,0x65,0xB3,0x09,0xB8,0x3B,0xD8,0x3E,0xFD,0x44,0x2B,0x2E,0x0B,0xF8,0x2B,0x0E,0x39,
	0x38,0x41,0x0B,0x9E,0xD1,0x4C,0xDE,0x15,0x59,0xDB,0xD1,0xEF,0xF8,0xAB,0x3A,0x0C,0x01,0x6F,0x5F,0x25,
	0x67,0x60,0x04,0x14,0x86,0xC5,0x23,0x3D,0xFA,0x05,0x6E,0xC3,0x91,0xEB,0xFF,0xDB,0x57,0x52,0xE5,0xFA,
	0x86,0x33,0xF5,0xAE,0xE8,0x6B,0x03,0x56,0x38,0x62,0x44,0x31,0x17,0x14,0x88,0xD3,0xD8,0xE2,0xCD,0x7C,
	0xDE,0x0A,0x49,0x4C,0x33,0xC9,0xDA,0x9D,0xD5,0x94,0x91,0x03,0xBB,0xC7,0xDD,0x04,0x57,0xE1,0xC8,0x8D,
	0xBF,0x14,0x64,0x2C,0x87,0x32,0xBB,0x69,0xD7,0x69,0x97,0x6C,0x08,0x95,0xAB,0xC0,0x18,0x66,0xE5,0xA8,
	0xA9,0x61,0xC3,0x7A,0x52,0x50,0x02,0x26,0x01,0x45,0x5D,0x30,0x35,0x59,0xCF,0x14,0x71,0x6F,0x22,0x51,
	0x25,0x59,0xDD,0x87,0x6F,0xCD,0xCB,0xE6,0xA4,0x65,0x08,0x7F,0x04,0x17,0xE1,0x77,0xB6,0x5F,0x09,0x38,
	0x85,0x08,0x5F,0x9B,0xED,0x19,0x62,0x61,0x1C,0x0B,0x24,0xF1,0xDD,0x89,0x11,0x36,0xE3,0x46,0x7A,0xC1,
	0x65,0x7A,0x19,0x16,0x82,0x8B,0xF0,0x24,0xFE,0x85,0xF0,0x53,0x75,0x99,0x9C,0xFE,0xDC,0xBF,0xFE,0xC0,
	0x42,0xEE,0x8A,0x3C,0xB1,0x24,0x84,0x8A,0x94,0x24,0x49,0xDB,0x58,0x95,0x92,0x9B,0xCC,0x3E,0x06,0x24,
	0x9D,0xE4,0x97,0xA6,0x14,0xB9,0xE7,0x3E,0xA4,0xAE,0xF7,0xEE,0x56,0xB4,0xB7,0x96,0x40,0xD1,0x7E,0xB5,
	0xCF,0xF0,0xEE,0xC9,0xE5,0x1F,0xDF,0x28,0xA0,0x46,0x27,0x01,0xC1,0x90,0x43,0x6B,0x8F,0xBA,0x74,0x57,
	0x5A,0x63,0xE6,0x78,0x24,0xF8,0xF8,0xCD,0x73,0xF7,0xE6,0xE8,0x7B,0x0E,0x26,0xB4,0x81,0xA4,0x8F,0x17,
	0x54,0x50,0x8A,0x16,0x2A,0x0A,0xF6,0xC6,0x42,0xC0,0x28,0x5B,0x2C,0x36,0x66,0xF4,0x35,0x0A,0x34,0x16,
	0x85,0x73,0xB0,0x24,0xCC,0x31,0xD2,0x0E,0x7F,0x64,0x5F,0xFB,0x95,0xBE,0x72,0xC0,0xFD,0x07,0x73,0x82,
	0xD2,0x0E,0xE3,0xB1,0xA6,0xF4,0x35,0x29,0x94,0xA0,0x4C,0x78,0x91,0x53,0x5A,0x78,0x0A,0x0B,0xD4,0x48,
	0x82,0xEA,0xC2,0x45,0x53,0x65,0x82,0x92,0xA0,0x59,0x5E,0xA0,0xB0,0x1C,0x62,0x97,0xA6,0x21,0x38,0xA3,
	0x24,0xA4,0xBD,0xB7,0xB1,0x24,0xA6,0x24,0xB5,0x8A,0x17,0x2E,0x3B,0xCA,0x24,0x1B,0xC1,0x37,0xEA,0x99,
	0x09,0x09,0x92,0x29,0xC9,0xCB,0x88,0xF6,0xE0,0x71,0xEC,0x3B,0xFF,0xBD,0x67,0xDF,0xE9,0xE2,0xE4,0xBA,
	0x93,0xAE,0x4F,0x97,0x57,0x56,0x17,0x28,0x7C,0x56,0x04,0x2A,0x96,0xB5,0xCA,0x8D,0x58,0x2D,0x98,0x24,
	0x91,0xC1,0xE1,0x65,0x13,0x8C,0x3B,0xB0,0xDF,0x72,0x2B,0x06,0x6B,0xAC,0xBA,0x19,0x7A,0x32,0x50,0xB7,
	0x1F,0xF5,0x37,0x30,0xA2,0x8B,0x27,0x6C,0xAE,0xC7,0x9A,0xB4,0x5A,0xBB,0x52,0xB9,0xF0,0xA6,0xFF,0xF8,
	0x3A,0xA0,0x69,0x8F,0xCD,0x73,0xB6,0x21,0x62,0xE3,0x53,0xE6,0x53,0x35,0xDC,0xA9,0x72,0x20,0x6E,0xD2,
	0xFB,0x4E,0x33,0x5B,0x22,0x5D,0x75,0x79,0x59,0x1E,0x52,0x8E,0xDD,0xC6,0xF8,0xB7,0x8C,0xB0,0x07,0xD5,
	0x65,0xB9,0x62,0x60,0xF6,0x9C,0xB6,0x85,0xEC,0xBC,0x04,0x83,0x75,0xE3,0x1C,0x04,0x79,0xB0,0x9C,0xB4,
	0xAB,0xB1,0x1B,0xA7,0xA8,0xFA,0x29,0x95,0xDA,0x76,0xC1,0x93,0xDC,0xDD,0xD9,0xD6,0x02,0xF8,0x8A,0x26,
	0x84,0x34,0x96,0x80,0xDE,0xC3,0xC1,0x72,0x71,0x0E,0x54,0x99,0x89,0xF8,0xDE,0xE9,0x5F,0xE1,0xBE,0x7B,
	0x60,0x40,0xC7,0xB5,0xA8,0x39,0x09,0xE8,0x1C,0x8C,0x9F,0x74,0xD8,0x7C,0x1C,0x15,0xCD,0x63,0x86,0x3F,
	0x41,0x49,0xDD,0x67,0x64,0x63,0x21,0x38,0x08,0x9F,0x51,0x3D,0x01,0x7D,0x56,0x4D,0x02,0x06,0xB6,0x31,
	0x46,0x45,0xE3,0xB7,0x7E,0xDE,0xB5,0xF8,0x8F,0x7F,0x4C,0x9B,0x18,0x77,0x69,0x96,0x3C,0x58,0x1F,0x73,
	0x9F,0xF8,0x15,0xE7,0xAB,0x53,0x03,0xA3,0xFB,0x77,0xB8,0xCB,0x32,0xC6,0xFE,0xD1,0xD1,0xBE,0xBD,0x01,
	0xC8,0x0C,0xE9,0xBE,0xB8,0xAE,0x41,0x9F,0x5A,0x70,0xD0,0x38,0x68,0x0D,0xF6,0x54,0xE7,0x9E,0x2C,0x05,
	0x30,0x8A,0x0F,0x26,0x1B,0xFE,0xF3,0x39,0x13,0x96,0x1B,0x0E,0xCF,0x41,0x8B,0xB0,0xF5,0x20,0x8B,0x1C,
	0xAC,0x13,0x4B,0x87,0x07,0xF7,0xA0,0x45,0x58,0x7A,0x90,0x45,0x8E,0x8A,0x0D,0xE6,0xC2,0x83,0x8D,0xF5,
	0xA0,0x92,0x1C,0x2C,0x15,0x14,0xC5,0x53,0xB5,0x41,0x39,0x78,0xF6,0x07,0x6B,0xBF,0x00,0xE4,0xFF,0xF7,
	0x51,0xFC,0xF0,0x0C,0xB6,0x12,0x9A,0x81,0x3F,0xE6,0x6E,0x54,0x32,0x55,0x14,0x45,0xE6,0x0A,0x5C,0xBA,
	0x42,0xBC,0x6B,0x08,0x91,0x56,0x69,0xAD,0xEA,0xBB,0xD1,0xC7,0x2A,0x58,0xBC,0xCA,0xF6,0x9F,0xA3,0xB5,
	0x63,0xBB,0xAE,0xCF,0x12,0xEB,0xC8,0x86,0xD1,0x09,0x2E,0xD8,0x38,0xEF,0x1F,0xAA,0x51,0xEE,0xEB,0x71,
	0xC9,0x26,0xBE,0xBC,0xBC,0x14,0x38,0x05,0x8A,0x8C,0x4B,0xED,0xEA,0x67,0x02,0x66,0x20,0xE5,0x54,0xA9,
	0x71,0xE5,0xD2,0x41,0x58,0x27,0x8C,0xC9,0x8A,0x86,0x65,0x18,0xC8,0x2E,0xD4,0xDF,0x42,0x57,0x5E,0x76,
	0xC1,0xA0,0x0C,0x68,0xD2,0xF2,0xFC,0x25,0x4E,0xAE,0xE5,0x94,0xE1,0xB9,0xA7,0x85,0x77,0x05,0xAA,0x76,
	0x9F,0xEF,0x55,0xBB,0x10,0x84,0x4A,0x1D,0xCC,0x9B,0x9F,0x2F,0x52,0xE7,0xCF,0xFB,0x00,0xFE,0xE1,0x9D,
	0x3B,0x5C,0x7A,0xA4,0xFE,0x15,0x31,0xA9,0xF4,0xAC,0xEA,0xC2,0xAE,0x10,0x81,0xEE,0xB8,0x28,0x8D,0xBF,
	0x5F,0x38,0xDF,0xAE,0xEA,0xD3,0x3E,0xAA,0x48,0xCC,0xAA,0x75,0x29,0xB4,0x6E,0x27,0xC2,0xAB,0x2E,0xC7,
	0xAF,0x1F,0xCF,0x72,0x5E,0x91,0x01,0x00,0xAE,0x10,0x9E,0x26,0xA2,0xC9,0x0B,0xB5,0x80,0x30,0xB0,0xD2,
	0x0F,0x8B,0xED,0x7D,0xF2,0x8F,0xC4,0xBE,0x1F,0xEA,0xA5,0x35,0x78,0x3F,0xE9,0xB2,0x6F,0x2D,0xAA,0xB0,
	0xCE,0x63,0xE1,0xE4,0xAB,0x2B,0x81,0xEE,0x6A,0xA5,0xA5,0x27,0x27,0x1B,0x99,0xDA,0xDC,0x0D,0x9F,0xB3,
	0x97,0x0D,0xF3,0xD0,0x61,0xCC,0x62,0x90,0xC5,0x32,0xBB,0x12,0xA0,0xBB,0x3D,0xE4,0xEE,0xE6,0xA0,0xE6,
	0x66,0x9D,0x19,0xB4,0xAC,0x3E,0xC5,0x4B,0x4C,0x7D,0x9A,0x35,0xEF,0x6A,0xC5,0x4A,0x52,0xD6,0x10,0x90,
	0x80,0x39,0x72,0x71,0x21,0xC8,0x0C,0x74,0xFF,0x05,0x7E,0x67,0x3A,0x96,0x13,0x41,0xC6,0x98,0xA9,0xA2,
	0xBD,0x3A,0x94,0x6D,0x08,0x35,0xBA,0x76,0xBB,0xD1,0xE8,0x02,0xAF,0x91,0x88,0x1A,0x99,0x9B,0xFB,0xEA,
	0x64,0x50,0x35,0x3A,0x8E,0x77,0x3A,0xBB,0x57,0x45,0xC4,0x64,0x20,0xC6,0xCC,0xE7,0x2C,0x15,0xA3,0xE1,
	0x03,0x0E,0x42,0x97,0x52,0x72,0xA3,0x03,0x1D,0x9E,0x5D,0x0A,0xE1,0x07,0x9F,0xE4,0x83,0xA8,0x6B,0x39,
	0xEE,0x12,0xCF,0x14,0xF4,0x31,0x2B,0x07,0x8D,0xD1,0x61,0xB6,0x53,0xBA,0x12,0x5E,0x3B,0xA8,0x37,0x37,
	0xBC,0x7B,0x20,0xFE,0x42,0x82,0x0F,0x02,0x0F,0x5E,0x84,0x9E,0xC7,0xBE,0x88,0xB9,0x86,0xF7,0x85,0x4A,
	0xF8,0x49,0xEF,0xC3,0x0A,0x51,0x42,0xB8,0x9A,0x9C,0xC1,0x10,0x16,0x93,0xA5,0x53,0xEF,0x37,0x9B,0xC5,
	0xF0,0xAA,0x63,0x71,0x67,0xE6,0x70,0x04,0x98,0x55,0x47,0x61,0x6B,0xEC,0xFD,0xE0,0x30,0x32,0x69,0x15,
	0xB6,0x84,0xC4,0x8E,0x19,0x64,0x67,0x43,0x9D,0xAD,0x66,0x97,0x56,0x70,0xFD,0xBE,0xD0,0x30,0x8F,0x72,
	0x57,0x00,0x60,0xEE,0x72,0xCB,0xFE,0xBF,0x8E,0xCE,0xF2,0x95,0x30,0xAB,0x1B,0xA8,0x2A,0x30,0xF4,0x7C,
	0x4D,0x5A,0x5E,0xF1,0xF3,0xF5,0xBF,0x67,0x00,0xC1,0xCB,0xBC,0x58,0x45,0x4C,0x41,0x17,0xC8,0xC2,0x33,
	0xA1,0x83,0x43,0xC8,0xB8,0xC8,0xE5,0x9E,0x48,0xF4,0x3F,0xCB,0x6D,0x19,0xE3,0x22,0x74,0x84,0x55,0x83,
	0x09,0x79,0x9A,0x37,0x26,0x11,0xDB,0x66,0xCC,0x00,0x39,0xCB,0x67,0x52,0x05,0x3E,0x0F,0x24,0x3F,0xAD,
	0x71,0x8A,0x0D,0x22,0xA0,0xAE,0xF5,0xEE,0x20,0x20,0x78,0x30,0x79,0x21,0x67,0x32,0xD6,0x20,0x62,0x4A,
	0xD6,0x72,0xAB,0xF8,0x50,0x30,0x79,0xA0,0x5C,0x32,0x62,0x62,0x61,0x64,0xC0,0x88,0xB2,0xD8,0x66,0x74,
	0x09,0x09,0x61,0x83,0x89,0x9F,0xD9,0x86,0x11,0x03,0x1E,0xCE,0xE4,0x54,0x8C,0xBA,0x87,0x75,0xB1,0x0E,
	0x05,0x23,0x67,0x5D,0x79,0xF4,0x7D,0xC3,0x64,0x63,0xDE,0x30,0x9D,0x88,0xCA,0xC2,0xBF,0x3F,0x2A,0xA1,
	0x13,0x35,0xE1,0x66,0xC2,0x70,0xFC,0x56,0x56,0xAD,0x4D,0x19,0x22,0x72,0xC3,0xA7,0x57,0xD3,0x54,0xB2,
	0x1C,0x32,0x41,0x05,0xE3,0x8F,0xEF,0x48,0xE4,0x95,0x60,0x01,0x7B,0x11,0xF6,0xE3,0x88,0xC8,0x02,0xFF,
	0x74,0xC3,0x26,0x65,0x92,0x2D,0xB4,0x9D,0x9A,0xBE,0xB3,0xE9,0xA3,0x27,0x78,0x93,0xD4,0x13,0xB4,0xEA,
	0x68,0xB6,0xD0,0xAB,0xA3,0x07,0x31,0x7D,0xBE,0xE1,0x1B,0xAF,0x08,0x27,0x7D,0xFE,0x23,0xBA,0x97,0xEF,
	0x12,0xF2,0x74,0xDF,0xFE,0x26,0xA0,0x80,0xBA,0xAC,0x18,0x3E,0x89,0x7A,0xA1,0xBA,0xCD,0xF9,0x48,0x56,
	0x5D,0x17,0x14,0x4E,0x90,0xEC,0xE5,0xD6,0x96,0xD3,0xDF,0xD1,0x16,0xD6,0xBA,0xCA,0xE0,0xFA,0x02,0x50,
	0xD6,0xDF,0x97,0xDB,0x61,0xB6,0xFF,0x4B,0xC2,0xCF,0x03,0x15,0x7A,0x95,0xF1,0xD2,0x13,0x90,0xF5,0x2F,
	0xFD,0xCE,0x1D,0x32,0x20,0x20,0x3B,0x62,0x32,0x34,0x6C,0xAF,0x6E,0xA3,0xDB,0xD4,0x95,0x60,0xE2,0x37,
	0x87,0x5C,0xFD,0x4F,0x1A,0x37,0x47,0x0D,0xA2,0x6B,0xBE,0x6A,0x63,0xFE,0x72,0x3C,0x0C,0x24,0x8C,0xC6,
	0xB7,0x36,0x9F,0x56,0x8C,0x3C,0xA2,0x1C,0x14,0x1C,0x7F,0x40,0x36,0x96,0x24,0x70,0x38,0xF2,0x68,0xC7,
	0x41,0x72,0x89,0x61,0xE2,0xC3,0x6A,0x2B,0xBE,0xA8,0x1C,0xA0,0x75,0xD6,0xDE,0x35,0x6A,0xCB,0x00,0xF7,
	0x47,0x78,0x49,0x1C,0x49,0x89,0xF3,0xF2,0xC9,0xC1,0xD7,0x4E,0xB1,0x7E,0x82,0xC0,0x75,0xF8,0x9A,0xDA,
	0xD7,0xA1,0xB9,0x48,0xBF,0xF5,0x07,0x9E,0xF4,0x62,0x10,0x90,0x01,0x27,0x1F,0x86,0x72,0x31,0xB1,0x9A,
	0x84,0xA4,0x85,0xF6,0x0C,0x60,0xCB,0x85,0xFD,0x4D,0xF8,0xEB,0x8A,0x6C,0xF5,0x2A,0x30,0xFA,0xF3,0xF1,
	0xB8,0x0B,0xB0,0x85,0x7B,0xEC,0xEA,0xE4,0x9B,0x55,0x9F,0x9D,0xF1,0x5D,0x03,0x6D,0xCD,0xC6,0xEE,0x9D,
	0x51,0x0D,0x96,0x95,0xED,0x84,0x0A,0x95,0xFF,0x2A,0x84,0xFE,0xDF,0x1B,0xBD,0x66,0xF5,0xF0,0x73,0xC3,
	0xCC,0xA1,0xF4,0x86,0xF2,0x73,0xF0,0x5B,0x98,0x26,0xA3,0x0A,0x75,0xEA,0xE2,0xDE,0x5B,0x2F,0xBA,0x5F,
	0xC1,0x76,0x4E,0x3E,0x94,0x7F,0xCE,0xE6,0x47,0x84,0x42,0xC5,0xA9,0x02,0x9B,0xC3,0xB3,0x3C,0x58,0xB1,
	0xF2,0x7E,0x44,0x4F,0x72,0x7E,0x2F,0x56,0xFB,0x72,0x89,0x2F,0x28,0x9F,0x7A,0x3D,0xB4,0x41,0xF0,0x3B,
	0xC6,0xA6,0x9B,0x30,0x16,0x57,0xF1,0x7C,0x38,0x20,0xAC,0x0C,0x9B,0xC1,0x3E,0xCF,0x02,0x9A,0xA4,0x7E,
	0xCA,0x1A,0xE4,0x5D,0x75,0xA0,0xAA,0x3A,0xA2,0xF6,0xEB,0x8F,0xD9,0x78,0xA3,0xBE,0x1E,0xB8,0xA3,0x26,
	0xB1,0x9F,0x79,0x82,0xEE,0xD7,0x49,0x2A,0xCA,0x47,0x95,0xC7,0x5E,0x85,0xCE,0x1E,0xFD,0x0E,0x09,0xDC,
	0xAC,0xE1,0x15,0x69,0xB2,0x2C,0xEC,0x8A,0x46,0xFC,0x4F,0xC0,0x64,0x23,0xC7,0x53,0xB8,0x8E,0xA3,0x3F,
	0xC2,0xD1,0xA1,0x07,0x49,0x59,0x0B,0xC1,0xB4,0x8C,0x74,0x57,0xFD,0x7C,0x66,0x98,0x55,0x55,0xDC,0x57,
	0x01,0xA1,0x57,0x95,0x75,0xFA,0xAB,0xFC,0xCC,0x75,0x60,0xE6,0x1A,0xF9,0xFD,0x49,0x5F,0x0B,0xE5,0x3F,
	0xAA,0x9F,0x48,0x1B,0xD6,0x2E,0x14,0x01,0x61,0x67,0xA0,0xDD,0xEB,0x43,0x5A,0x58,0xC6,0xCF,0x7E,0x55,
	0x38,0x8F,0x20,0x82,0x64,0xF2,0x3D,0xCD,0x6C,0xC8,0x87,0xFC,0xA2,0x30,0xEC,0x0B,0xEE,0x56,0x95,0x60,
	0x09,0x5C,0xBA,0x40,0xDA,0xFA,0xAB,0x03,0xA3,0xB0,0x82,0xB3,0xD8,0xB4,0xEB,0xFA,0x45,0xA3,0xF1,0x5D,
	0xFC,0xA8,0xD3,0x4B,0x7A,0xE7,0x2A,0xBA,0xF0,0x9B,0x4E,0xA8,0x03,0xFB,0xCB,0x32,0xA5,0x25,0x20,0x5D,
	0x55,0xE7,0xE2,0x4A,0xA2,0xD4,0x2E,0x36,0x78,0x4F,0xDE,0xE6,0xED,0x9E,0x79,0xD9,0x79,0x95,0x01,0x0F,
	0x6B,0xD6,0xD0,0x99,0xD7,0xA8,0xCD,0x6C,0x87,0x08,0x02,0x12,0x8D,0xBB,0xC4,0x6E,0xD5,0x62,0x25,0x66,
	0x59,0x76,0xED,0xCF,0x52,0x6F,0x5D,0x47,0x0D,0x1A,0x64,0x2B,0x15,0x6B,0xEF,0x0A,0x64,0x47,0x21,0x37,
	0x08,0x75,0x35,0xA6,0xB6,0xD6,0x81,0xF2,0x2A,0x3B,0x43,0x80,0xD8,0x1C,0x9F,0x2D,0xFD,0x4E,0xAA,0xCB,
	0x76,0x2B,0xD7,0x52,0xD5,0x24,0xD1,0x76,0x0D,0xB5,0x08,0x4B,0x1A,0x58,0x08,0xE1,0xB5,0xCA,0xFE,0xA0,
	0x6B,0x1E,0x09,0xD9,0xFE,0xCF,0xFE,0x34,0x48,0x36,0x01,0xA4,0x04,0x4C,0xFA,0xD0,0xD9,0xC2,0xDB,0x46,
	0xF6,0x27,0x89,0xA7,0xAC,0xAD,0xCB,0xB2,0x5D,0x57,0xB4,0xF5,0x7E,0x5B,0x87,0x2D,0xDE,0x73,0xE2,0x50,
	0xC4,0x5E,0x83,0xB9,0xDE,0x1A,0x01,0x6F,0x56,0x3D,0xB8,0xF0,0xAA,0x42,0x73,0xBD,0x24,0xE9,0xAC,0x32,
	0x8E,0xF5,0xDE,0x90,0x45,0xA0,0xAB,0xEF,0xD7,0xBB,0x9B,0x33,0x0F,0x81,0x53,0x25,0x72,0xEB,0x93,0x9A,
	0xAB,0x22,0x25,0x22,0xE4,0x5D,0x60,0x4C,0x2B,0xAA,0xCA,0x9C,0xB2,0xCD,0x85,0xF6,0xF2,0x9D,0x19,0xDC,
	0x67,0xEF,0x8B,0xFA,0x95,0x7B,0x66,0x32,0x7D,0x30,0xDA,0x7F,0xA9,0x5B,0x3B,0x3E,0x91,0x2F,0x06,0x99,
	0x4E,0xBD,0xAC,0x2D,0x49,0x9A,0x72,0xA4,0xD6,0x67,0x99,0x5C,0xB1,0xCE,0x06,0x00,0xDF,0x8A,0x5A,0x62,
	0x1D,0x6F,0x23,0x50,0x6F,0x1E,0x6E,0x25,0x5F,0xAA,0x54,0xAB,0x8B,0x0F,0x61,0x78,0x0A,0xEB,0x4C,0x56,
	0x6F,0xC1,0x36,0x77,0xF5,0x58,0x04,0x01,0x56,0xE6,0x58,0xAA,0xCD,0xBA,0xB7,0x95,0x56,0x84,0xAC,0x32,
	0xA3,0x2D,0x17,0x44,0x69,0x43,0xCA,0xE0,0x9A,0x67,0x33,0xE8,0x61,0xA5,0xB5,0x26,0x79,0x02,0xF4,0xDD,
	0x31,0xEF,0x59,0xC0,0x9F,0xA3,0x03,0xF2,0x41,0x56,0x1B,0x1C,0xAF,0x51,0x27,0x26,0xDA,0xF7,0x7D,0xA7,
	0xDA,0xE8,0xF5,0x6A,0xA7,0x50,0xC9,0x2B,0xFB,0x95,0x80,0x89,0xC7,0x69,0x4A,0xD2,0xCD,0x5F,0xF9,0xCB,
	0xB6,0xEE,0x72,0x78,0xDB,0xA0,0xDF,0x86,0x47,0x73,0xD7,0xBA,0xE7,0xA5,0x7E,0x4D,0xC9,0x1E,0xC7,0xE7,
	0xAB,0x1F,0xAC,0x31,0xAB,0x9A,0xA0,0x33,0xA8,0xBB,0x6A,0x13,0x59,0xCB,0x3C,0x62,0x9B,0x4D,0x19,0xC4,
	0xF4,0x5D,0x38,0xDC,0x3F,0x33,0x7C,0xB1,0x20,0x89,0xF0,0xA6,0xB1,0xE0,0x70,0x46,0x0B,0x3B,0xEE,0xC1,
	0xF3,0xB3,0x06,0x38,0xD8,0x63,0x43,0xAF,0xEB,0x62,0x46,0x71,0xC2,0xB4,0x79,0x20,0x21,0x86,0x4C,0x2D,
	0x79,0x57,0x51,0x0B,0x56,0xB2,0xD9,0x32,0x5A,0xCE,0xE9,0x7B,0x88,0x9C,0x7D,0x3D,0xF8,0xC9,0x42,0xA9,
	0xBC,0x64,0xA4,0x30,0x5A,0x31,0x68,0x61,0x08,0x96,0x6E,0xAC,0xFD,0xAD,0xB0,0xEE,0xE8,0x0A,0xC9,0x61,
	0xF6,0x5B,0x21,0x8B,0x2F,0xBF,0x66,0x65,0xC5,0x55,0x64,0x86,0xF7,0x05,0x4C,0xA5,0xF7,0x2B,0xB8,0x09,
	0xF3,0x37,0x37,0x93,0xB7,0xDB,0x0C,0x83,0xEB,0x3D,0x5A,0xD8,0xC7,0x7C,0x00,0x5C,0x30,0x34,0x38,0xAC,
	0x18,0x89,0xFE,0x0C,0xD8,0x0E,0xCA,0xD6,0xF0,0x2C,0x3F,0x7A,0xB1,0x86,0xEB,0x30,0x01,0x49,0x45,0xB8,
	0xB6,0x43,0x46,0x61,0x5F,0xF9,0x23,0x24,0x52,0x2C,0x0B,0xFF,0x57,0x59,0xFF,0x80,0xA4,0x30,0xA9,0x66,
	0x61,0x6E,0x31,0x2C,0x60,0x03,0x84,0x76,0x85,0x26,0xA6,0xBA,0xB7,0x9A,0xC1,0xDA,0x66,0xFE,0xBA,0xD4,
	0x86,0xBE,0x03,0x53,0x53,0xA6,0xFB,0x21,0xE2,0x8F,0x08,0xC3,0x19,0x56,0x41,0x87,0x43,0x94,0xDF,0xEA,
	0x55,0xDA,0xC0,0x01,0xDA,0xB1,0x5E,0x96,0x5F,0xA0,0x5C,0xFF,0x7F,0x6C,0xF0,0xE6,0xDC,0x78,0x6B,0x6A,
	0xCA,0x34,0x9E,0x40,0x47,0x08,0x8C,0xC5,0x4C,0x11,0x0B,0xCA,0x40,0xEE,0x76,0x83,0x19,0xB0,0x6F,0x21,
	0x75,0x81,0x95,0x29,0x1F,0x37,0x92,0x55,0x9A,0x3C,0xE6,0xFE,0xFF,0x27,0xE9,0x86,0xBA,0x86,0xF3,0x08,
	0xE2,0x67,0xF8,0x2A,0x00,0x2E,0xED,0x00,0xEF,0xF4,0x55,0xD3,0x0C,0x75,0xA9,0xA9,0xEA,0x53,0x04,0x3E,
	0x9C,0xBA,0x20,0x89,0xF1,0xCE,0xF2,0x54,0xDD,0xB0,0xDC,0x0E,0x77,0x24,0xA7,0xFF,0xD5,0x68,0x34,0xF5,
	0x2B,0x27,0x9D,0xA2,0xE2,0xD8,0xAC,0xEA,0x8A,0x29,0xCC,0x8F,0x84,0x40,0x1D,0xE5,0x7E,0x81,0xCB,0x6C,
	0xF2,0xA6,0x79,0x35,0x8A,0xF7,0x1D,0x52,0xAC,0xEE,0xAF,0xD6,0x82,0xDC,0x8E,0x6E,0x39,0xD5,0x97,0xBE,
	0x4B,0xFA,0xB6,0x37,0x7B,0xA5,0x4F,0x5D,0x59,0xAC,0xD4,0xED,0xD5,0xB6,0xC6,0x76,0x55,0xA7,0x14,0xE0,
	0x91,0x06,0x69,0x60,0x79,0xEC,0xCE,0x60,0x1C,0x72,0xF3,0x5A,0xDB,0xD5,0x08,0x7D,0xA1,0x88,0xC0,0xBE,
	0x65,0xA6,0x36,0x46,0xCB,0x6D,0x77,0xE1,0x52,0xE8,0x79,0x79,0x9B,0x07,0xFF,0x8E,0x31,0x85,0x43,0xA6,
	0x67,0xC0,0x43,0xC8,0x2D,0xB9,0x44,0xC3,0xC0,0x31,0x81,0x64,0x24,0xAB,0x47,0xE2,0x7D,0x91,0x66,0x2C,
	0x44,0x2A,0x35,0x76,0x38,0x04,0x2B,0x60,0xAA,0x71,0xE8,0xCD,0xB5,0xC8,0x3B,0x40,0x3A,0xA7,0x66,0x7F,
	0x3A,0x67,0x03,0x19,0x97,0x85,0xCD,0x2C,0x5C,0x07,0x1D,0x5B,0x66,0xA3,0xB8,0x12,0xD7,0xBD,0x2B,0x8E,
	0x58,0x7F,0xA8,0x85,0x5F,0xB6,0x0A,0xC0,0xB0,0xF0,0xAD,0xD3,0x9A,0xEC,0x66,0x15,0x85,0xC5,0x4F,0xF1,
	0xA3,0xC1,0xD0,0x80,0xD5,0xD2,0x9D,0xDD,0x39,0x6E,0x8D,0xAE,0xF8,0xE0,0x0B,0xC8,0xA2,0x8E,0x79,0x99,
	0xD1,0xCA,0x1E,0x8E,0x9B,0xDA,0xCA,0xE9,0x9B,0x2D,0xC0,0x34,0x92,0x44,0x13,0x67,0x5A,0x57,0x86,0x02,
	0x9F,0xCB,0x13,0xC2,0x71,0x0C,0xBA,0x0B,0xC5,0x21,0x3E,0x8B,0x0E,0x54,0x4C,0xA6,0x30,0x1A,0x30,0x24,
	0x48,0x83,0x05,0x56,0x11,0x7A,0x14,0x6E,0xDA,0x3B,0x4A,0xB8,0x11,0x76,0x05,0xF8,0x4C,0x28,0x14,0x56,
	0x5A,0x71,0xE3,0x1A,0xEC,0x01,0xC2,0xDA,0x1C,0xFB,0xE8,0x47,0x80,0xC2,0x43,0x84,0x8B,0x32,0xFD,0xDB,
	0xA8,0x4B,0x9D,0xCB,0xA6,0x7D,0xFF,0xBA,0xFA,0x76,0x3B,0x01,0x7E,0xB9,0x5C,0x61,0x26,0x26,0x4D,0x17,
	0x67,0x2A,0xF8,0xB1,0x27,0x75,0x53,0x16,0x46,0xCD,0x95,0xEE,0x25,0x75,0x97,0x15,0x5F,0x01,0xDB,0xE2,
	0x9F,0x8F,0xD2,0x47,0xD4,0x83,0xEE,0xC8,0x45,0x73,0x16,0xE6,0x3F,0x5D,0x83,0x09,0x07,0xAA,0x4A,0x1A,
	0x16,0xB1,0x66,0xAD,0xA8,0xF8,0xCD,0xA1,0x52,0x9C,0x2B,0xEB,0x41,0x3E,0x54,0xCA,0xDA,0x09,0xEC,0x86,
	0x0C,0x70,0xEC,0x35,0xD5,0x0E,0xCD,0x83,0xDA,0x06,0xDE,0xF7,0x36,0x64,0x55,0x44,0xF3,0xCA,0xA1,0xCB,
	0x4B,0x7D,0x59,0xB4,0xBB,0x20,0x5E,0xB9,0x23,0xAC,0xEF,0xCA,0x57,0xA1,0xC0,0x57,0x34,0xFE,0x07,0x32,
	0xD7,0xD7,0x39,0x61,0xDF,0x75,0xDA,0xDB,0x4F,0x72,0xC5,0x63,0x98,0x61,0xA6,0x8E,0xFF,0x3E,0x16,0x0E,
	0xE7,0x31,0x17,0xA6,0x58,0x2B,0x90,0x05,0x4C,0x12,0x0E,0xBF,0x92,0x9B,0xCC,0x43,0x2A,0x29,0xB3,0xAA,
	0x13,0x7A,0x6B,0x76,0x98,0x00,0x10,0x77,0xBB,0xA3,0xD5,0x13,0x7D,0x38,0x4A,0x3F,0x53,0xB2,0x4D,0x21,
	0x5F,0x01,0xF5,0xAB,0x49,0xC2,0xFB,0x5B,0x52,0xDD,0x88,0xD5,0xDE,0x58,0x3C,0xA8,0x97,0x85,0x6D,0x38,
	0xBF,0x10,0x20,0x3E,0xC4,0x3B,0x1F,0x4D,0x11,0x50,0x24,0x02,0xE0,0x17,0x20,0x05,0xF7,0x6D,0xDC,0x06,
	0xC4,0xD5,0x7A,0x16,0x14,0x80,0x22,0x59,0x31,0xBA,0xE1,0xF2,0x01,0xCF,0x1C,0xE2,0x82,0x84,0xD3,0x78,
	0xA2,0xC2,0xBD,0xFC,0x9D,0xEE,0xB4,0xD5,0x96,0x88,0xD5,0x71,0x8F,0x2B,0x1E,0xF5,0xEA,0xD5,0xF5,0x98,
	0xCA,0x50,0x2F,0x0F,0x7A,0x1F,0x10,0x8D,0xFA,0x48,0x5F,0xFC,0x57,0x1D,0x95,0x83,0x91,0xA7,0xEB,0x2A,
	0xAC,0xF4,0xF6,0x62,0x49,0x6F,0x62,0x68,0xC7,0x13,0xA3,0x92,0xDF,0x85,0x02,0x03,0x69,0x31,0x0D,0x6A,
	0x36,0xF5,0x6B,0x99,0xFE,0x87,0x74,0xF5,0x46,0xBB,0xBA,0x95,0x68,0xA3,0x98,0x8F,0x08,0xCA,0x9F,0x40,
	0xDD,0x9B,0x12,0x5A,0xDC,0x61,0xC3,0x58,0x2F,0x5D,0xC8,0x71,0x1F,0x73,0x15,0x05,0x39,0x0A,0xE6,0x15,
	0x0E,0xD6,0x4C,0x72,0x1F,0xF7,0x10,0x46,0x11,0x06,0x9F,0x57,0x13,0x09,0x3B,0x5F,0xC6,0x8E,0xFA,0xDA,
	0xE2,0x16,0xC1,0xAA,0xC0,0x28,0xC3,0xC0,0xBC,0x99,0xB8,0xD4,0xEC,0x1F,0x40,0x99,0x33,0xAC,0x35,0x4E,
	0xF4,0xCF,0xAB,0xBB,0x2C,0x31,0x62,0x51,0x5D,0x56,0xD8,0xAB,0x04,0xB1,0x55,0x45,0xA5,0x41,0x54,0x2E,
	0xEE,0x94,0x77,0x01,0x2A,0xEA,0x1D,0xCC,0xED,0x6B,0xBF,0x6D,0x32,0xC1,0xD7,0x0B,0x2A,0x26,0x3C,0x4A,
	0xA3,0xB8,0x68,0x7F,0x0F,0x8C,0x43,0x0E,0xA1,0xE8,0xEE,0x6F,0xE1,0x89,0xC7,0xBD,0xAF,0x41,0xA6,0xDB,
	0xAF,0x06,0x61,0xC6,0x60,0x48,0xEF,0xBD,0x11,0x5F,0x3B,0x1D,0xA0,0x6A,0x09,0x89,0xAF,0x06,0x47,0x14,
	0xC8,0x5E,0xB2,0xFF,0x94,0x89,0x29,0xD3,0x53,0xA1,0xA4,0x32,0x44,0x97,0x60,0x61,0x15,0x00,0xDE,0x92,
	0x5B,0xB0,0x84,0x47,0x01,0xE2,0x9F,0xF2,0xD4,0x77,0x97,0xE8,0x58,0x04,0x1B,0x01,0x52,0x98,0xD2,0xBA,
	0x15,0xF2,0xA6,0x5C,0x29,0x2F,0x4A,0xF7,0xD4,0x15,0x2D,0xDA,0xF3,0x1F,0x0D,0xFC,0x82,0x6A,0x3A,0x44,
	0xA6,0xC9,0x80,0xC4,0xDB,0x6B,0x65,0x4A,0xB6,0xAA,0x7C,0x68,0x36,0x8B,0x69,0xC2,0x97,0x30,0x5B,0xA7,
	0xE3,0xD6,0xB5,0x63,0xF4,0xD9,0x70,0x52,0x7F,0xF8,0x1B,0xC9,0xFC,0xC1,0x73,0x1D,0xCA,0x65,0xD5,0x21,
	0xB9,0x85,0x01,0xFE,0xB8,0x6E,0xFC,0x11,0x9B,0x7F,0x89,0xDD,0xEF,0x6D,0xEB,0x83,0x5F,0xD2,0xBB,0x65,
	0x78,0xB5,0x47,0x23,0x47,0x47,0x5D,0xC9,0x53,0xC8,0x8E,0xD9,0x0B,0x53,0xD0,0x1D,0x47,0xC7,0x2F,0x54,
	0xDA,0x09,0x53,0x84,0xD8,0x53,0xFE,0x4D,0xA4,0xE0,0x2B,0xF4,0xFA,0x39,0x67,0xE3,0xC6,0x09,0x8F,0x6B,
	0xB5,0x0D,0xBA,0x15,0xFF,0x8C,0x20,0x87,0xC8,0x96,0xEC,0xB7,0x13,0x0A,0x9C,0xB9,0xD0,0x34,0xA4,0x0B,
	0x24,0xCA,0x85,0x98,0xD5,0xC1,0x79,0x44,0x0D,0xD9,0x10,0xA2,0xA0,0x88,0x07,0x71,0x43,0x1C,0xC6,0x75,
	0x44,0x0D,0xD9,0x90,0x5F,0x41,0x29,0x82,0xF8,0x2D,0x1B,0x8A,0xB8,0xF0,0x32,0xD3,0x26,0x0E,0xBF,0xC4,
	0x6B,0x5F,0x0B,0x8F,0x8A,0xFB,0x02,0x5F,0xFF,0xF5,0xBE,0x53,0x68,0xB1,0x09,0x92,0x0D,0xC7,0xDD,0x0B,
	0x66,0xA2,0x7D,0xD0,0xC9,0x60,0x30,0x14,0x84,0xC0,0xB3,0x90,0x16,0xD5,0xA0,0xBF,0xED,0xA7,0x21,0xAA,
	0xAD,0x28,0x02,0x03,0xEA,0x9E,0xF6,0xA1,0xD9,0x8E,0xA8,0xB6,0x6A,0x99,0x66,0x8F,0xEA,0x11,0xC5,0x9E,
	0x3D,0x8E,0x8E,0xEF,0x6A,0x28,0x59,0x1F,0x77,0xD0,0x72,0xD0,0x7B,0x42,0x1F,0x0E,0x09,0x33,0x38,0x38,
	0x15,0x23,0x9F,0x01,0x7C,0x48,0xC0,0x91,0x5F,0x96,0xA6,0xF6,0xF1,0x88,0x7D,0x0C,0xC5,0x02,0xA2,0x94,
	0xE1,0xEF,0x24,0xC4,0xFD,0x25,0xE7,0x85,0x24,0x98,0x14,0x49,0x43,0xDB,0x4B,0x2C,0xE2,0xED,0xFA,0x7A,
	0xEF,0x8B,0x8C,0xF0,0x1A,0x42,0xD7,0x01,0x41,0x4D,0x5E,0x98,0x61,0xE7,0x7A,0xF0,0xAE,0x3B,0x70,0x03,
	0x25,0x6C,0x2F,0x7C,0x0C,0xED,0xB8,0x2F,0xBF,0x82,0xC4,0xBC,0x02,0x5B,0xA4,0x06,0xE6,0x9B,0xAD,0x61,
	0x10,0x32,0x03,0xD0,0xA0,0xEF,0x92,0xDD,0xB4,0x3B,0xE5,0x30,0xE8,0x49,0x5B,0x1D,0x21,0xF7,0x88,0x15,
	0x5E,0xCB,0x22,0xAE,0x86,0xA5,0x24,0x8C,0xD8,0xFA,0x89,0xAD,0xE2,0xD8,0x6D,0x94,0xF4,0x01,0xD8,0x22,
	0xC2,0x54,0x0C,0xA8,0x6B,0x28,0x5B,0xDD,0xF4,0x9D,0x22,0xBD,0x72,0x21,0x7B,0xAF,0x51,0x1C,0xA1,0x55,
	0x6E,0xA0,0xAF,0x94,0x62,0xB4,0x23,0xFA,0xC8,0xC4,0xF9,0x6D,0xEA,0x43,0xC3,0xC6,0xF5,0xBC,0xBB,0x99,
	0x60,0x2D,0x53,0x1C,0xA0,0x64,0x7A,0x71,0xB1,0x45,0xD8,0x73,0xAC,0x68,0x72,0x15,0x42,0x70,0x2D,0x13,
	0x8B,0xED,0xC2,0x5F,0x05,0xA2,0xFE,0x1E,0x1C,0xDD,0xA2,0xA8,0xDB,0x57,0xA9,0x83,0x1E,0x03,0x05,0x43,
	0x9E,0x9A,0x8C,0xFC,0xEE,0xAD,0x34,0x0F,0x6A,0x07,0x2C,0x23,0xBB,0x7D,0xAA,0xA6,0xEE,0x52,0x06,0x52,
	0xF8,0xDB,0x37,0x0E,0xA0,0x66,0xF7,0xC6,0xEC,0xC4,0xD0,0x80,0xBF,0x4A,0xA6,0xE9,0xBE,0x2A,0x09,0xDE,
	0x34,0x09,0x4F,0xDF,0x46,0xF2,0xAB,0x09,0x9A,0xD8,0x60,0xB4,0x48,0x83,0x4E,0x2A,0x2F,0x0E,0x71,0xB8,
	0x94,0x3A,0x31,0x6B,0x64,0xE9,0x86,0xB2,0x88,0xAF,0xB2,0x74,0xA7,0xAE,0xAA,0xA2,0xDC,0x6B,0x0E,0x06,
	0x8A,0xA2,0xC7,0x73,0xCB,0x16,0x8F,0xBF,0xC2,0x55,0x55,0x9B,0xDD,0x3E,0xE7,0xF2,0x95,0xAE,0x3A,0xD7,
	0x58,0x48,0x1E,0x23,0x7A,0xED,0x01,0xD5,0x37,0xEC,0xAF,0xFF,0xC2,0x68,0xD6,0x06,0xB5,0xFB,0x28,0x3A,
	0x7D,0x3F,0x75,0x15,0x03,0xC4,0xC4,0xCF,0xE3,0x05,0x44,0xEC,0x27,0x20,0xEB,0xE2,0x16,0xE9,0xDD,0xB0,
	0x92,0x1B,0x2E,0x2F,0xFA,0xC8,0xFD,0x31,0xA0,0x61,0x2A,0x1A,0x65,0x81,0x9A,0x6D,0xBE,0xF0,0x2C,0x6F,
	0xFE,0x79,0x01,0x2C,0x7D,0x19,0xB0,0x91,0x6B,0x57,0xFD,0xE5,0xC0,0x8C,0x44,0x19,0x4C,0xD8,0x4B,0xC8,
	0xC3,0x6B,0xE6,0xEF,0xC1,0xE4,0xB1,0x14,0xD0,0x64,0xF3,0xE9,0x24,0x71,0xED,0x2D,0xF4,0x2C,0x49,0xBD,
	0x8A,0x78,0xA2,0xE5,0x4A,0xCB,0xF2,0x18,0xAA,0x34,0x60,0x60,0x00,0xE5,0x93,0x97,0xB4,0xF3,0x5F,0x82,
	0x82,0xA8,0x3A,0xE3,0x52,0x0C,0x69,0x96,0xC3,0xF8,0xD0,0x6A,0x4F,0x47,0x43,0x38,0x83,0xED,0xEE,0x8C,
	0x88,0x8D,0x50,0x5F,0x43,0x4F,0x65,0x10,0x16,0x4E,0x7D,0x43,0x7A,0x0C,0x35,0xE3,0x29,0xBD,0x4E,0x4D,
	0xEB,0xD6,0x34,0x60,0x63,0x35,0x3F,0xFE,0x0D,0xF6,0xAB,0x2E,0x53,0xBE,0x4C,0xB9,0x18,0x50,0x4D,0x94,
	0x05,0x12,0x56,0x6A,0x48,0xD6,0x30,0x1A,0xD1,0x32,0x52,0xF5,0x7E,0xDD,0x25,0x0B,0xCB,0x32,0x05,0xBC,
	0x30,0xDB,0x7A,0x91,0xF5,0xB9,0x55,0x14,0x6E,0xA6,0x84,0x2A,0x18,0x77,0x2B,0x33,0x80,0x02,0x8C,0x16,
	0xDB,0x5E,0xE8,0x18,0x8F,0xB9,0x76,0x4B,0x4D,0x91,0x22,0x43,0x3F,0x4A,0x41,0xBF,0x8B,0x37,0x43,0x04,
	0x2E,0x5F,0x39,0xC2,0x06,0x22,0x1A,0x64,0xB2,0xF3,0x5F,0x9D,0x9A,0x84,0xB0,0x2A,0xF8,0xAB,0x03,0x76,
	0xD3,0xAE,0x4A,0xB6,0xDC,0x26,0x07,0x0F,0xEB,0xF2,0x23,0x06,0x1A,0xF7,0x72,0xB4,0x13,0x85,0xA8,0x66,
	0x75,0xB6,0x97,0xD1,0x7E,0xCD,0x3F,0xE9,0xBA,0x41,0x79,0xC1,0x0F,0xCA,0x7C,0x5F,0x8C,0xF2,0xBC,0xBB,
	0xDD,0x32,0x04,0xC9,0xCF,0x8B,0xBA,0xED,0x75,0xC0,0x37,0x81,0xC1,0x50,0xEE,0xEB,0x7A,0x0D,0x7C,0x8C,
	0x27,0x77,0xFD,0xB9,0xC0,0xCA,0x38,0x27,0x92,0xD6,0x77,0x08,0x4B,0xE1,0x25,0xC2,0x51,0x75,0x85,0xF8,
	0x57,0x54,0x63,0xF6,0x4A,0x51,0x36,0xE4,0xBF,0xB6,0x7F,0x5B,0x72,0xB0,0xAF,0x43,0x7C,0xFC,0xEE,0x00,
	0x75,0xE2,0x1E,0x65,0x7C,0x29,0x31,0x2F,0x3E,0x59,0xFE,0x57,0x85,0x28,0xAA,0x14,0xCB,0x03,0x1A,0xD2,
	0x1F,0x20,0x28,0x82,0x8D,0x02,0xB6,0xD4,0xBE,0xD7,0x41,0xC8,0x90,0x6A,0xD1,0x5B,0x8A,0x2C,0x12,0xE0,
	0xA1,0xE7,0x7C,0x50,0xF8,0x63,0x8F,0x6C,0xA9,0xF9,0x17,0x1F,0xEC,0x28,0xD8,0x4C,0x57,0x76,0x77,0x46,
	0xCD,0xD6,0x48,0xA4,0xF0,0xE8,0x9D,0x74,0xDE,0xA0,0xF0,0x93,0xE9,0x7A,0x0F,0x3E,0xDE,0x7A,0x0B,0x87,
	0xB9,0xC0,0xB6,0x68,0xEA,0x31,0x5D,0xF2,0x2E,0xC4,0x95,0x3E,0xEC,0xBB,0xB7,0x72,0x1E,0x37,0xEC,0xA9,
	0x9A,0xDC,0x0D,0xB8,0x8A,0xAD,0xD4,0xE2,0xC9,0x19,0x15,0xF2,0x4D,0x3D,0x4B,0xBF,0x42,0x89,0x40,0x47,
	0x58,0x20,0x0D,0x90,0xFF,0x85,0x02,0x18,0x8E,0x9B,0xD5,0xC8,0xEE,0x07,0x05,0x10,0x0E,0xCD,0x53,0x86,
	0xBE,0xFC,0xEE,0xF0,0x20,0x7A,0x9A,0xDF,0xBF,0x6C,0x27,0x31,0xE0,0xB9,0xD9,0xBF,0xFA,0xC0,0x7D,0x0D,
	0x2D,0x6B,0xC4,0x9F,0xC2,0xB2,0xBB,0x83,0x58,0xED,0xAF,0x09,0x18,0xDB,0x1A,0x54,0x45,0xCD,0xD5,0x54,
	0x07,0x8D,0x57,0xF9,0xEB,0x73,0xC1,0xC4,0x27,0x12,0x7F,0x3B,0x72,0x30,0x62,0x72,0xB3,0x2B,0x25,0xEC,
	0xA0,0x08,0xD9,0x5B,0xAA,0x68,0x05,0xC8,0xD1,0x58,0x48,0x2B,0xEE,0x03,0x80,0xF4,0xF6,0x3F,0x16,0x97,
	0x48,0x16,0x91,0xD9,0x31,0x63,0xCB,0x4E,0xFA,0x91,0xD4,0x8E,0x45,0x3B,0x45,0x80,0x34,0x15,0xD8,0x25,
	0x45,0x35,0x01,0xF3,0x54,0x51,0x87,0x25,0x78,0x8B,0xE0,0xAF,0x1D,0x19,0xB0,0x5C,0x38,0x5B,0x3D,0xD2,
	0x30,0x78,0xCE,0x9E,0xDF,0xFD,0x93,0x18,0x65,0xBA,0xE7,0xBF,0xD5,0x07,0xAF,0x7A,0xBD,0x76,0xC1,0xC9,
	0x35,0x20,0xAF,0x0A,0x0E,0x14,0x94,0xEE,0xEE,0x34,0xC1,0x4B,0x25,0x60,0x4D,0x26,0x9E,0x30,0x1B,0xB4,
	0xD0,0xB7,0x97,0x01,0x70,0xE3,0x97,0xA3,0xE6,0x1A,0x35,0x1A,0x47,0x44,0x9F,0x80,0x63,0xD9,0xD0,0xD5,
	0x81,0x4B,0x6B,0xD2,0x8A,0x9F,0xB2,0xBA,0xAF,0xC5,0x9C,0x56,0xBA,0x21,0x43,0x6E,0x52,0x9F,0x5C,0x77,
	0x5D,0x8A,0x77,0x17,0x4C,0x81,0x32,0xD4,0x86,0xD8,0x1D,0x88,0x76,0xA6,0xFB,0x75,0x46,0x5F,0x08,0x14,
	0x70,0xF9,0xAF,0xEE,0x0B,0x53,0x3D,0xA9,0x3A,0x9B,0xB5,0xBE,0x7E,0x57,0x44,0x69,0xD2,0x5F,0xB3,0xC1,
	0xBF,0x23,0x4C,0x23,0xA7,0x51,0x4E,0xB7,0xD0,0x0D,0x8D,0x9E,0x13,0xEB,0x25,0x6A,0x29,0xDC,0x79,0x5B,
	0xA4,0x7D,0x51,0x68,0xFD,0xE5,0xED,0xC7,0x2A,0x08,0xF8,0x45,0xD5,0x1C,0xB0,0xD5,0xA8,0xFD,0xFD,0xF4,
	0x1D,0x63,0x9A,0xF5,0xF5,0xE1,0x6C,0xED,0x79,0xD7,0xDA,0x21,0x9A,0x81,0xC4,0xCD,0x47,0x65,0x9D,0xEB,
	0xAE,0xA6,0x54,0xEA,0x77,0x3A,0x0B,0x4B,0x82,0x76,0xA7,0x21,0xF2,0xA5,0xC8,0x87,0xEF,0xD0,0x99,0xD6,
	0x2A,0xCE,0x2E,0x12,0xD2,0x94,0xB2,0xE0,0x2E,0xCA,0xF0,0xBB,0x89,0x47,0x91,0xEE,0x15,0x72,0xED,0xAC,
	0x79,0x3B,0xF4,0x92,0x94,0xF0,0xA7,0x5F,0x8B,0x09,0x61,0x53,0x64,0xBB,0x86,0x7C,0x61,0x03,0xA7,0x00,
	0x1A,0xA3,0x42,0xE3,0x19,0xE4,0x91,0x82,0x7F,0xA1,0x78,0x2B,0x43,0xFF,0x4A,0xE7,0x7D,0x75,0x76,0xFA,
	0x8E,0x48,0x0D,0x2C,0x13,0x96,0x8E,0xEA,0xAB,0x1E,0xDD,0x30,0x57,0x3B,0x08,0x70,0x32,0xFD,0x65,0x84,
	0x42,0xAF,0x3D,0x07,0x68,0xFA,0x53,0x6A,0x16,0x3E,0x3E,0x27,0xBE,0xDB,0x82,0xC6,0x43,0xF0,0x2A,0xA0,
	0xCA,0x79,0x1F,0xCC,0xD8,0xCF,0x60,0x47,0x4D,0xBD,0x41,0x41,0xC6,0x19,0xF5,0xB9,0xEB,0xA1,0x2D,0x37,
	0x8A,0xA4,0xE9,0x8D,0xF1,0x81,0x54,0x54,0x83,0xA1,0x5C,0x83,0x60,0xC7,0x10,0xA5,0x99,0xB4,0xF8,0xF8,
	0x26,0x8A,0x78,0x62,0x0E,0x03,0xCA,0xD4,0x43,0x81,0x8E,0x80,0x94,0x23,0x04,0x2D,0xDC,0xE4,0xA5,0x1A,
	0x7B,0x14,0x15,0x24,0xBE,0x44,0x76,0x81,0x72,0x09,0xBC,0x3C,0x51,0xF0,0x2A,0xDA,0xB2,0xA2,0x5A,0x6D,
	0x2B,0xAF,0xB9,0xD7,0x9A,0x7B,0x2B,0x1E,0x36,0x2D,0xF7,0x57,0x7C,0xFE,0xA9,0xA2,0x66,0x2D,0x58,0x9A,
	0xDE,0x92,0x05,0xBA,0x87,0x42,0x40,0xEF,0xCA,0xF9,0x4D,0xC1,0x04,0x6C,0x2B,0xDC,0x00,0xB5,0x66,0x41,
	0x9B,0x66,0xA0,0xB7,0x4D,0xC1,0x00,0x53,0x15,0x6B,0x70,0x91,0x94,0x60,0xCC,0xCB,0x9D,0xE8,0x78,0x7F,
	0x00,0x1A,0x54,0x94,0xBE,0x5D,0x1D,0x00,0x84,0x13,0xC5,0x69,0xCA,0x72,0x0B,0xE3,0xA5,0x4C,0xE7,0x4A,
	0x90,0x64,0x11,0x6F,0xA5,0xA0,0x27,0x6A,0x83,0xC5,0xF1,0xC7,0x0C,0x56,0x7D,0xE9,0x4D,0x0C,0xDF,0x66,
	0x44,0xDD,0x81,0x1C,0xFE,0x6D,0xE4,0x3A,0x77,0xC2,0xAC,0x45,0x67,0x65,0xEA,0x3C,0xBC,0xED,0xA7,0x45,
	0x63,0x92,0x63,0x66,0x3A,0x88,0x71,0xEA,0x9E,0x29,0x18,0xB2,0xE0,0xB4,0x71,0xFB,0xC6,0x2B,0x04,0xD4,
	0x1B,0x7B,0x10,0x48,0xDD,0x90,0x35,0xAB,0xAA,0xED,0xBA,0x28,0x51,0x3C,0x84,0x89,0xC7,0x23,0xD1,0x4C,
	0xFC,0x0D,0x13,0x59,0x38,0x62,0x6D,0x0E,0xF2,0x6F,0x1F,0xB7,0x72,0x18,0x2E,0x59,0xEE,0x9B,0xAA,0x15,
	0x12,0x7A,0x0E,0xE4,0xD4,0x34,0xC7,0x28,0x01,0x39,0xBA,0xFE,0x59,0x13,0x84,0x43,0x3E,0xCB,0x1B,0x9D,
	0x55,0x53,0xA8,0x59,0x5F,0xE2,0x7E,0x0F,0xA7,0x62,0x7A,0x71,0xB7,0x9F,0x5F,0x3D,0xE3,0xFA,0xD3,0x5D,
	0x60,0xBC,0xA5,0xF5,0x5A,0xE6,0xC9,0x45,0x49,0xD7,0x27,0xA5,0xC0,0xED,0x82,0x09,0xD5,0x7C,0xDB,0x45,
	0x09,0x9B,0x82,0xBD,0xD0,0x63,0x64,0x39,0xDD,0x41,0x14,0x42,0xC2,0xA1,0xFD,0xCD,0x64,0x11,0x83,0x4B,
	0x56,0x7D,0x68,0x6D,0x28,0x0C,0x94,0xFD,0xC3,0xD7,0x73,0x06,0x48,0x04,0x9D,0x17,0xBA,0x21,0xCC,0xB5,
	0xC6,0xB8,0x12,0x91,0x30,0xD3,0xD5,0x52,0xD7,0x21,0xFC,0x90,0xB1,0xA0,0x50,0xC1,0xB0,0x39,0x05,0xDC,
	0xA9,0xC5,0x76,0x9D,0x12,0x31,0x3D,0xD9,0x12,0x9C,0xDD,0xDD,0xC3,0xD5,0xDF,0x48,0xBB,0xA8,0xD0,0xD5,
	0xBE,0x0F,0xFC,0xAD,0x43,0x0E,0x1D,0x2E,0x9D,0x20,0x98,0xD5,0x5B,0xBB,0xD8,0xA7,0xB2,0x09,0x1D,0x5D,
	0xD8,0xE5,0x54,0xA6,0xB1,0x06,0xE2,0xDA,0x39,0x06,0x3B,0x9F,0x01,0x70,0x5F,0x6F,0x76,0xD9,0x95,0x36,
	0xB8,0x08,0x23,0xAC,0xB7,0xEB,0xEB,0x85,0x8F,0x01,0xFF,0x5C,0x1E,0x62,0x98,0xF5,0x05,0x7E,0x30,0x04,
	0x54,0x51,0x9F,0xE1,0xA6,0xC4,0xA1,0x95,0x78,0xC6,0xB1,0x46,0xF7,0xBD,0x51,0x67,0x76,0x4A,0xB9,0xDC,
	0x6C,0x34,0xC2,0x97,0x40,0x0A,0xAE,0xDC,0x01,0x12,0x13,0x92,0x62,0xB6,0x1A,0x07,0x3C,0xF6,0xB7,0x88,
	0x93,0x03,0xAD,0xD7,0x57,0x89,0x67,0xDB,0x82,0x42,0xA2,0x95,0x3A,0xC8,0x71,0x5D,0x71,0xBA,0xE9,0x68,
	0x53,0x1F,0x73,0x62,0x89,0x50,0x38,0xE1,0xE1,0xB3,0x9F,0xE2,0x45,0x4D,0xDA,0x22,0x69,0x44,0xC6,0xA5,
	0x64,0x26,0xC4,0x83,0xD1,0x2C,0x1C,0x2A,0x15,0xF5,0x0B,0x8A,0x84,0x6D,0x1A,0x55,0xAB,0xA7,0x57,0x27,
	0x82,0xA6,0x33,0xA3,0xEB,0x84,0x54,0xA4,0x8B,0xBF,0x05,0x54,0xB1,0xE2,0x35,0x61,0x55,0x87,0x0E,0x5D,
	0xC1,0xC3,0xCD,0x8D,0xCA,0x82,0x8F,0xB3,0x46,0x2F,0xF6,0x7A,0x5E,0xB9,0x81,0x4A,0xF0,0x97,0x56,0xC0,
	0x82,0xC1,0x83,0xC3,0xB7,0x85,0x87,0x55,0xAF,0xC1,0x1F,0x24,0xFD,0x2E,0xE4,0x78,0xD5,0xD3,0x42,0x77,
	0x15,0xD3,0x64,0xB0,0xB8,0xB8,0x44,0x19,0xDB,0xFA,0xDA,0x8E,0x7E,0x4F,0xC8,0x53,0x38,0x19,0x7C,0xBC,
	0x98,0x56,0xA2,0x8C,0x54,0x0B,0x16,0x03,0x01,0x24,0x21,0xF3,0x90,0xD9,0xE9,0xB0,0x7F,0x38,0x03,0x5A,
	0xB0,0x98,0xF8,0x00,0xB6,0xF1,0x95,0xBE,0xA6,0xA8,0x52,0x42,0x41,0x4A,0x2A,0x7A,0xF5,0x49,0x20,0x6D,
	0x6C,0x94,0x80,0x37,0x31,0x2C,0x2A,0x26,0x7A,0x1D,0x94,0x5F,0x17,0x32,0x0D,0x31,0xBE,0xEA,0x7D,0x2A,
	0x07,0x80,0xBB,0xD9,0x5F,0x19,0x1D,0x74,0x60,0x34,0x61,0x61,0x75,0x92,0xB1,0xFF,0xEC,0x05,0xB4,0x7A,
	0x4D,0x7E,0x9C,0x61,0xB5,0xEF,0xE8,0x4F,0x6F,0xC9,0xAC,0x92,0x7C,0x7F,0xEE,0x5B,0xBC,0x95,0xFA,0xDC,
	0xC6,0xF1,0xA4,0xD3,0x94,0x21,0x22,0xF7,0xFB,0x8A,0xF8,0xA9,0xC2,0x70,0xC0,0x2B,0x6B,0x95,0xDE,0xAC,
	0xF7,0x69,0x44,0x97,0x9A,0x31,0x62,0x94,0xC1,0x28,0x00,0x71,0x07,0x53,0x7D,0x52,0x93,0x5C,0x07,0x66,
	0x1E,0x28,0x57,0x1F,0x41,0x01,0x75,0x58,0x1E,0xEF,0x57,0xE5,0x89,0xAB,0x5C,0x60,0x96,0x59,0x89,0xCE,
	0xCB,0x45,0x1F,0xEA,0x0E,0x89,0x63,0xB9,0x96,0xD7,0xD6,0xC0,0x2A,0x02,0x43,0xB3,0xED,0x2A,0x81,0x75,
	0x40,0xBF,0xEB,0x50,0x51,0xFD,0x71,0xE2,0x9C,0xD6,0xA9,0x81,0xA5,0x00,0x22,0x30,0x20,0x0A,0xAE,0xD2,
	0x23,0x55,0x1B,0x20,0x59,0x33,0xA8,0x76,0x90,0xDC,0x92,0x58,0xAC,0x02,0x12,0xE2,0x47,0x9B,0xE5,0x91,
	0x0B,0x97,0x5D,0xB7,0xBB,0x82,0xF0,0x6E,0xE3,0x86,0x5F,0x01,0xAA,0x88,0xC0,0xDA,0x0D,0x00,0x78,0x0F,
	0x65,0x64,0x7B,0xA6,0xF5,0xFF,0x04,0x9C,0x84,0xC7,0xF8,0x56,0x3F,0x4A,0xF4,0x9A,0xC3,0x06,0x7F,0xAC,
	0xFE,0x9E,0x02,0x55,0x55,0x5A,0x8E,0x7F,0xB6,0x1A,0xBF,0x90,0xAD,0x98,0xBA,0x0C,0x5C,0x7F,0xA6,0xFF,
	0x7C,0xA4,0x8D,0xFE,0x74,0x62,0x1A,0x27,0x4C,0x29,0x94,0x4C,0x58,0x3F,0x16,0x9D,0x8E,0xB9,0x4A,0xB6,
	0x20,0x2F,0x17,0xCB,0x4F,0x32,0xFE,0x25,0x02,0xAF,0x67,0x78,0xA8,0x86,0xBA,0x97,0x92,0x23,0x43,0x85,
	0x64,0xB9,0xEB,0x57,0x6D,0x8B,0xA6,0x15,0xBC,0xCD,0x5D,0x8B,0xC9,0x09,0x4E,0x8A,0x21,0xFF,0x99,0x73,
	0xCB,0xFE,0x3B,0x79,0xC9,0xBA,0x33,0xE0,0xB6,0x08,0xCE,0xF9,0x0D,0x69,0x7A,0xEE,0xC5,0x87,0x69,0xBE,
	0xAC,0x57,0x69,0xC4,0xC8,0x52,0x5A,0x44,0x7E,0x9F,0xAD,0x6F,0x92,0x5C,0xD3,0x3D,0x0D,0x11,0xA6,0x48,
	0xB3,0xD6,0x50,0x3A,0x38,0x46,0x86,0xCF,0xCF,0xB9,0x11,0xBF,0xDC,0x22,0x3C,0xB1,0x10,0x1F,0xC8,0x23,
	0x20,0x4B,0x17,0x6D,0x0E,0x51,0xC9,0xA2,0xC4,0x5B,0xEA,0x98,0x94,0xEB,0x70,0x5D,0x97,0x41,0xB9,0x5B,
	0x48,0x0A,0x80,0x65,0xAD,0x6A,0x29,0x69,0x9B,0xE4,0x70,0x8E,0xA5,0x1C,0x3B,0xD1,0x1A,0xEA,0x72,0xF3,
	0xC4,0xDB,0x19,0x32,0xF2,0xB9,0xD0,0x90,0x2F,0x5B,0x5B,0x41,0xA8,0x57,0x05,0x7C,0xE5,0xAC,0x5C,0xB9,
	0x86,0x48,0xB7,0x28,0xFE,0xBE,0x9A,0x80,0x58,0x3C,0x7E,0x8B,0x49,0x68,0x40,0x94,0xBC,0x30,0x40,0x17,
	0x0A,0x03,0x05,0x54,0xCA,0x77,0x89,0x44,0x95,0x86,0x2A,0xC2,0xC6,0x93,0x4D,0x27,0x60,0xD5,0xE5,0xE4,
	0x65,0x9A,0x0C,0x59,0x9B,0xE6,0x20,0x86,0xC1,0x49,0x15,0x15,0x5B,0x19,0x79,0x3B,0x50,0x15,0x09,0xA6,
	0xAC,0x75,0x94,0xA6,0x60,0xEA,0xAA,0xEC,0x2D,0xC6,0x51,0xD6,0x13,0x05,0x88,0xA8,0x2F,0xA0,0x49,0xCC,
	0x0A,0x26,0x11,0x6B,0x05,0x0D,0x03,0x26,0xB3,0x2A,0x02,0xBA,0x0F,0x02,0x48,0x81,0x7A,0xC2,0xBE,0x53,
	0xD6,0xA8,0x18,0x8A,0xF7,0x7B,0xF9,0xC4,0xB4,0xB5,0x24,0x55,0x87,0x92,0xC9,0xBC,0xF0,0x13,0x06,0xE7,
	0x54,0xE8,0x5E,0x7F,0x28,0xF1,0x17,0x41,0x9F,0x1C,0xB7,0x80,0x97,0xA1,0x16,0x4D,0x31,0xB8,0xD9,0x9B,
	0xE8,0xB0,0x38,0x08,0xEE,0x78,0x48,0xEA,0x6B,0xCB,0xCB,0x77,0xBF,0x85,0xB3,0x04,0x5A,0x77,0xAA,0x1F,
	0x19,0xB0,0x1D,0x80,0xB6,0xFD,0xCD,0x9B,0x0A,0x45,0x30,0x2D,0x49,0xFC,0x4D,0xB1,0x2B,0x1C,0x57,0x71,
	0x00,0x78,0xFF,0x62,0x7B,0xB8,0x66,0xF6,0xBE,0x28,0xDF,0x9D,0xA8,0xB3,0x54,0x61,0x25,0xA3,0x56,0xD1,
	0x53,0x1F,0x55,0x07,0x77,0x8F,0xCE,0x66,0xD5,0x0F,0x56,0xAC,0xAA,0x1C,0xA8,0x4E,0x2E,0x00,0x80,0x90,
	0x16,0x6B,0xBF,0x43,0x3E,0x79,0x45,0x22,0xBB,0x01,0x35,0xBE,0x4C,0x30,0xBA,0x39,0x68,0x5D,0x4C,0x37,
	0xEF,0xDF,0x75,0xA7,0xC7,0x75,0xA3,0x00,0x55,0xB8,0x56,0x91,0x57,0x2B,0x1C,0x6D,0xCD,0x48,0x0E,0x20,
	0x8A,0xD3,0x2E,0x54,0x01,0x90,0xCE,0x86,0x1E,0x9C,0x96,0x77,0x53,0xE8,0x14,0xE0,0xD5,0x11,0x00,0x41,
	0x7F,0x87,0x03,0x65,0xDA,0x34,0x0D,0xB8,0xD1,0xB8,0xF2,0x67,0x42,0xC3,0xFB,0xC4,0xD7,0x3F,0x08,0x8D,
	0x25,0xEF,0xA3,0xFE,0xD9,0xC0,0x68,0xD4,0x8D,0x8F,0xD6,0xB6,0xAC,0x12,0x98,0x0C,0x16,0x6D,0xAA,0x53,
	0x51,0x17,0x18,0xBD,0xF9,0x84,0x87,0xF5,0xDA,0xA8,0xC0,0x30,0xBF,0x3C,0xD2,0xDA,0x27,0xF5,0x83,0x0C,
	0x16,0x0E,0xF3,0x66,0x00,0x0B,0x2E,0x62,0xA8,0x95,0x1C,0x4A,0x18,0x1D,0x69,0x6F,0xA4,0x96,0xB8,0xCD,
	0x62,0xC0,0xB0,0xA4,0xF1,0x5A,0xD4,0x51,0xD2,0x74,0x1D,0x00,0x4A,0xF6,0xAA,0x50,0xAA,0x33,0x2F,0xF2,
	0x9B,0x01,0x41,0xF9,0x3F,0x5D,0x00,0x40,0x56,0x97,0xEE,0x8B,0x64,0x69,0x96,0x53,0xB0,0x13,0x43,0xE4,
	0x9A,0x92,0x12,0x41,0xB6,0x0D,0x89,0xF0,0xD7,0x91,0xD7,0x21,0x64,0x47,0x0C,0xA2,0x23,0xA7,0xF5,0x09,
	0x24,0x5B,0x8F,0xA9,0xC0,0xF4,0x5A,0xC1,0xAD,0x60,0x5A,0x11,0x06,0x84,0xF7,0xED,0xD2,0xBA,0xF0,0x3E,
	0xD3,0xB1,0x50,0x63,0x69,0x5A,0xCE,0x7C,0x40,0xAC,0xFA,0x11,0x83,0xB4,0xFA,0xBF,0x1E,0xD5,0xC0,0xA3,
	0x4A,0x4F,0x23,0x74,0x6F,0x0F,0x02,0xF4,0x3F,0x2F,0xF6,0xF7,0x61,0x0D,0x7E,0x94,0x12,0x37,0x2B,0xBC,
	0x7A,0x32,0xB4,0x03,0xFD,0x83,0x88,0x05,0x86,0xF6,0x7F,0x9D,0xFA,0x15,0x3F,0x94,0xFE,0xD1,0x84,0x67,
	0xD7,0xAE,0xD2,0xD1,0xDB,0x07,0x68,0xF6,0xA2,0xDC,0x93,0x9C,0xA4,0x21,0x24,0x49,0x18,0xFE,0xA4,0x47,
	0xBA,0xF5,0x3B,0x68,0xF7,0x15,0x61,0xC2,0x48,0x16,0x26,0xF7,0xF6,0xB5,0x2F,0x80,0x7B,0x81,0x51,0x94,
	0x16,0xA1,0x8A,0xDA,0xAC,0x61,0xA2,0xC8,0xBE,0x5B,0x81,0x0B,0x47,0x04,0x8B,0x6E,0x9B,0xC4,0xFB,0xA5,
	0xFE,0x52,0xE9,0x8E,0x55,0x49,0x5B,0x75,0xCB,0x67,0x7F,0xC5,0xCF,0x91,0xD7,0xB5,0xC1,0xCC,0x9B,0xC2,
	0xFD,0x54,0x97,0x0B,0x33,0xD3,0xC4,0xDD,0x7A,0x34,0xAC,0xAA,0x86,0xF1,0x6D,0xA8,0xFE,0x56,0xE0,0x52,
	0x3F,0x3D,0x2C,0x43,0x1F,0x08,0xDB,0x2F,0xA5,0x7D,0x11,0x6A,0x54,0x3D,0xDE,0x52,0x46,0xDF,0xD4,0x95,
	0x61,0x0B,0x93,0x84,0x01,0x51,0x4E,0xB7,0xC8,0x3C,0x01,0x2A,0x7F,0x65,0x27,0x6D,0x9F,0xF5,0x74,0xB9,
	0xFB,0xDF,0xDA,0xFD,0x89,0x93,0xBF,0xD1,0x67,0x34,0xA6,0x12,0xE4,0x4B,0x69,0x4D,0xEA,0x42,0x22,0x41,
	0xC6,0x96,0xB3,0x20,0x34,0x8C,0x70,0xAD,0xDB,0x60,0xDA,0x57,0xC5,0x55,0x0E,0xD2,0xA8,0xC5,0xB0,0x5D,
	0xE6,0xAB,0xAB,0x00,0x31,0x0C,0xCA,0xC6,0x72,0x7C,0xE5,0xD6,0x15,0x1F,0xAE,0xCB,0xEE,0x91,0xF7,0x61,
	0x86,0xB8,0x28,0x89,0x9A,0x80,0x55,0x83,0xE8,0x03,0x51,0xF0,0x47,0x9D,0xD3,0xDD,0x9C,0xA7,0x23,0x90,
	0x4E,0x0C,0xFC,0xDE,0xF7,0x1C,0xA0,0x62,0xFF,0x87,0x15,0x9B,0x98,0xBE,0x28,0x9A,0xFF,0x39,0x5B,0x22,
	0x6E,0xDF,0xD7,0xB1,0x57,0x38,0x8B,0x4A,0xA9,0x42,0x2B,0x28,0x6D,0x55,0x11,0x74,0xF1,0x38,0xB5,0xFA,
	0xF7,0xF4,0x7D,0x15,0x78,0x4B,0xC2,0xB5,0x0E,0xBF,0xB6,0x8E,0xC5,0xF5,0x2F,0x5E,0x03,0xEB,0xE0,0xBA,
	0x62,0xA6,0xD8,0x30,0xF5,0xF7,0x8D,0x24,0xE0,0x86,0xEB,0x5A,0x34,0x7F,0x1F,0x30,0x64,0x64,0xBB,0x24,
	0x6C,0x2D,0x86,0x9C,0x15,0x27,0xAD,0x4A,0x90,0xFD,0xA2,0x6A,0x55,0x7C,0xE7,0x0B,0x63,0xB9,0xC1,0x18,
	0xCF,0x0D,0x32,0xA4,0x2B,0x7F,0x67,0x34,0x47,0xD4,0x3E,0x43,0x63,0x44,0xB1,0xB6,0xDD,0xDA,0x6C,0xDE,
	0x7D,0x00,0x74,0x9F,0x23,0x53,0x56,0x42,0x5D,0x6D,0x64,0xD1,0x50,0x1C,0x34,0xEF,0x6F,0xC8,0x0C,0xB5,
	0xF0,0xDF,0x3C,0x0E,0x70,0x16,0xAF,0xD3,0x0C,0xE9,0x74,0x37,0xAE,0x6A,0xD8,0x41,0x03,0xF1,0xFD,0x72,
	0x58,0xCA,0xAE,0xC3,0x91,0xB8,0xF8,0x00,0xA3,0x57,0x9A,0x30,0x0F,0xDC,0x63,0xAA,0xCC,0xAB,0xA6,0xF8,
	0xDF,0xD6,0x5E,0x51,0xD4,0xD8,0x57,0x36,0x4C,0xAF,0x42,0x4C,0x2E,0xB2,0x8C,0x15,0xBA,0x4E,0x95,0x47,
	0x03,0xBC,0xC3,0xA0,0x46,0x19,0xB9,0xE9,0x52,0xB3,0xF4,0x32,0xC1,0xE0,0x08,0xF2,0xFD,0xAA,0x84,0x52,
	0xCB,0x35,0x39,0xAE,0x48,0x8B,0xB6,0xC9,0x3B,0x56,0xE7,0xEF,0x12,0x90,0xB2,0x72,0x00,0x88,0x01,0x47,
	0xD6,0x0A,0xD7,0x84,0xD7,0x09,0x9B,0xC0,0x04,0xA4,0xCA,0xA1,0xC0,0x47,0xB1,0x53,0xC9,0xF0,0x74,0x78,
	0x70,0x97,0x55,0x6A,0x12,0x66,0x59,0xB3,0x79,0x7D,0xE1,0x66,0x2C,0x4E,0xD0,0xE9,0xBF,0x11,0x1A,0x19,
	0x66,0x2A,0x5B,0x79,0x28,0xAA,0x61,0x68,0x6C,0x7C,0xF9,0xE4,0xFC,0xDF,0x3E,0xDF,0x97,0xEC,0x4D,0x56,
	0x21,0x06,0xD7,0x28,0x37,0xDD,0x1F,0x29,0xB8,0xBA,0xA1,0xC7,0x59,0x5F,0x41,0x79,0x11,0x22,0xF8,0xFA,
	0x89,0xE6,0x98,0x66,0xF5,0x64,0xE0,0xC5,0x90,0x5C,0x88,0x04,0x05,0xDD,0xE6,0x31,0xB1,0xD0,0xFA,0x5D,
	0x70,0xE2,0xBB,0xBC,0x64,0xC5,0x81,0xF9,0x15,0xEE,0x7D,0x24,0xA4,0xE4,0x03,0x3C,0xCB,0xEB,0x7D,0x35,
	0x7A,0xAE,0x43,0x9F,0x88,0x8E,0xD1,0x4B,0xA1,0x76,0xD4,0x10,0x9A,0x01,0x5F,0x71,0x8B,0x82,0x02,0xB9,
	0x2C,0xEA,0xA6,0x62,0x00,0x4D,0x4E,0x74,0xCF,0xB5,0x80,0xB6,0x83,0x2B,0xB4,0x94,0x75,0x6E,0xF7,0xBD,
	0x54,0xF5,0x9D,0x0C,0xFC,0x0D,0xF7,0x38,0xBD,0xDC,0xEF,0x07,0x55,0x51,0x08,0x01,0xC6,0x82,0x05,0xDC,
	0x57,0x50,0xD5,0x95,0x0C,0x0F,0x4F,0x2B,0xD8,0xAA,0x5E,0x72,0xFA,0x6E,0x96,0xEE,0x74,0xB3,0xFE,0x57,
	0x3F,0x48,0x75,0x64,0xB8,0x12,0x18,0x96,0x04,0x27,0x24,0x69,0x60,0x92,0x5E,0x4A,0x53,0x47,0xEB,0x24,
	0x4D,0xD2,0x48,0x54,0x41,0x59,0xCC,0x25,0x2B,0xC2,0x1E,0x37,0x2F,0x93,0xA6,0x0C,0x13,0x3D,0x18,0x40,
	0x25,0x18,0x9F,0x55,0x08,0xC9,0xB9,0xFB,0x24,0x45,0xAA,0x07,0xDB,0x54,0x07,0x00,0xAB,0x77,0x10,0x88,
	0x7F,0x4F,0xF1,0xA4,0x6A,0xBB,0x73,0x4D,0x6A,0x27,0xEA,0x8E,0xC2,0x4C,0x2E,0xB4,0xE3,0xDF,0x81,0x64,
	0x95,0x9F,0xEF,0xE9,0x12,0xF4,0x3F,0x63,0xA4,0xFF,0x11,0x2E,0x94,0x9F,0x27,0x8A,0x67,0xB5,0x30,0x34,
	0x83,0x0E,0x39,0xB6,0x7D,0x75,0x60,0x1E,0x38,0xC8,0x80,0x66,0x73,0x81,0x5A,0xF4,0x4B,0x0D,0x99,0x47,
	0xF0,0x16,0xAE,0xC1,0x20,0xBE,0x4F,0x30,0x58,0xE5,0x2A,0xE8,0xDB,0x30,0x07,0xE3,0x2F,0xE8,0xC8,0xA8,
	0xDC,0xBF,0x03,0x8D,0x39,0x59,0x77,0x01,0xC3,0x39,0x45,0x0E,0x64,0x07,0xA4,0xB7,0xB6,0x2B,0x37,0x8C,
	0xA9,0xDF,0x91,0xA4,0x5D,0x32,0x5C,0x64,0xB4,0x1F,0xBA,0x8D,0x94,0x94,0xE8,0x61,0x2B,0x5D,0xC2,0x88,
	0x22,0x4C,0x6B,0x53,0x11,0x1B,0x69,0x72,0x1F,0x2F,0x5E,0x8D,0x9A,0x2D,0x49,0x45,0x36,0x89,0xDC,0x36,
	0xC1,0x97,0xD1,0x87,0x25,0xAC,0x6A,0xCB,0x4A,0x33,0x11,0x66,0x08,0x10,0x6B,0x26,0x4D,0x1C,0x16,0xDD,
	0x93,0x50,0xAB,0xC5,0x83,0x79,0x54,0x12,0x8F,0x04,0x75,0x76,0xDF,0x6B,0x6B,0xDE,0x29,0x2D,0x38,0x5D,
	0xBB,0x42,0x42,0x42,0x42,0xD2,0x2A,0xC1,0x1D,0x89,0x8E,0x4E,0x42,0xFC,0x10,0x45,0xEA,0x06,0xE3,0x02,
	0xF7,0x4C,0x7A,0x88,0x20,0xA1,0x68,0x77,0x97,0x7D,0x9E,0x92,0xC1,0xED,0x5A,0x18,0xF0,0x4E,0x5E,0x28,
	0x88,0x8A,0x80,0x84,0xCC,0xB7,0xAE,0x33,0xBB,0x12,0x12,0x06,0x13,0xC5,0x4F,0x3C,0x59,0x53,0x26,0x06,
	0x43,0xEC,0x30,0x16,0xF3,0x35,0x99,0x28,0x90,0x18,0x31,0x82,0xB2,0x29,0x69,0x09,0xE5,0x67,0x20,0x18,
	0x79,0x17,0x89,0x09,0x09,0x83,0x76,0x6E,0x40,0x00,0x09,0x89,0x0B,0x75,0x9E,0xA7,0x1F,0xBA,0x06,0xE2,
	0x27,0xA2,0x7C,0x3F,0x02,0x4C,0xF0,0xEB,0x90,0x98,0x6F,0xF1,0x13,0x72,0x1B,0x2B,0x59,0xCA,0xFD,0xE9,
	0xCE,0x3F,0xAA,0x8A,0x1E,0xA3,0xC2,0x31,0x0D,0x88,0x8D,0x5A,0x0C,0xA2,0x68,0xEA,0x8E,0xCA,0xA2,0x4C,
	0xA8,0xC4,0x94,0x2E,0x0B,0x46,0x15,0x16,0x94,0xFA,0x5D,0x51,0x30,0x28,0x32,0x30,0x91,0xAC,0xCD,0xCE,
	0xCA,0xC0,0xCC,0xB2,0xC7,0xB3,0x4E,0xD5,0xA4,0x28,0x02,0xBD,0xA8,0x49,0x15,0x98,0x26,0xA6,0xA3,0xB4,
	0xF5,0x3D,0xAD,0x24,0xB9,0x81,0x01,0x01,0x71,0xBF,0x14,0xD5,0x8A,0x13,0xD4,0xA5,0x24,0x49,0x92,0x54,
	0x81,0xAE,0x88,0xB3,0x93,0xBB,0x4B,0xFA,0x98,0xB8,0x99,0xA4,0x0A,0xAC,0x05,0x66,0x3E,0x68,0x2F,0x76,
	0x49,0x92,0x3C,0x52,0x20,0x56,0xBB,0x4B,0x2B,0x4D,0xEF,0x23,0x48,0xDB,0x62,0x7F,0x4D,0x84,0xFE,0xB0,
	0x68,0x48,0x63,0x54,0x32,0x55,0x29,0xD6,0x6D,0xC3,0x8E,0x2C,0x97,0x5A,0x7C,0x34,0x7D,0x38,0x60,0x07,
	0xE2,0xEA,0x74,0x45,0x80,0x15,0xB6,0xCE,0xFE,0x5F,0x31,0xFB,0x27,0x60,0x7A,0xC5,0xF7,0x75,0x81,0x5F,
	0xF5,0xB3,0x28,0xD8,0xD8,0x5C,0xC5,0x14,0xA7,0x69,0x13,0x5B,0x52,0x1B,0x75,0xB1,0xB8,0x20,0x8B,0x95,
	0xAA,0xDF,0x74,0x94,0xB1,0xA2,0x05,0x0D,0x17,0xEE,0x80,0x25,0x6E,0x88,0xD7,0x3B,0x33,0x18,0xFA,0xEC,
	0x1D,0x88,0xC0,0xFD,0x20,0x34,0x00,0xE6,0x1A,0xED,0x75,0x29,0xF8,0x6B,0x5A,0xBA,0x50,0x78,0x23,0x96,
	0xE2,0x59,0xFC,0x0E,0x28,0x82,0x23,0x27,0xC9,0x3D,0xD3,0xED,0xBD,0x33,0x08,0x96,0x11,0xA1,0x2E,0x92,
	0xE4,0xDE,0x68,0xDA,0xAD,0x48,0xAD,0xF6,0xB2,0x1F,0x3F,0x25,0xE0,0xED,0x40,0xAD,0x8F,0x34,0x40,0x70,
	0x7F,0xDA,0x64,0xD8,0x20,0xB8,0x17,0x46,0xFD,0x5B,0x6D,0xB7,0x44,0x30,0x00,0xC8,0x6A,0x81,0xFC,0x43,
	0xFF,0x00,0x98,0x36,0x33,0x3D,0x31,0x03,0x67,0x3D,0x81,0x81,0x31,0x06,0x3C,0x20,0x3B,0x1B,0x63,0x68,
	0x6A,0xD4,0x8D,0x63,0x07,0xED,0x75,0xC1,0x76,0x9D,0x6B,0x06,0x1D,0x43,0xE2,0xBA,0xBA,0xE7,0xA5,0x66,
	0xC5,0x6F,0x24,0x9A,0xEE,0x72,0xFD,0xB0,0x4A,0x73,0xB3,0xF6,0x89,0x5F,0x33,0xF6,0xC0,0x30,0xED,0x09,
	0xC7,0xF5,0x54,0x02,0xEA,0xFF,0x36,0x99,0xBD,0x87,0x5D,0xDF,0xBC,0x44,0xBB,0x5D,0xC8,0x29,0x03,0xF7,
	0x06,0x72,0x12,0x56,0x6A,0xF4,0xAF,0x87,0x57,0xD5,0xBA,0xD0,0x94,0xFF,0x71,0x10,0x1E,0xD8,0x30,0xF0,
	0xCD,0xF2,0xBB,0x8D,0xE5,0xBE,0x11,0xDB,0xFD,0xA1,0x18,0x3F,0xE9,0xE2,0x71,0x17,0xD8,0x2A,0x9A,0xBA,
	0xD6,0xD4,0xB4,0x16,0xBE,0xC6,0xA3,0x95,0x5F,0x1C,0xDA,0x4D,0xEC,0xD6,0x90,0x9A,0x7A,0x9C,0x43,0xFB,
	0x92,0xF6,0x11,0xD1,0xA8,0x4B,0x6E,0x24,0x45,0x29,0x8B,0xD7,0xBB,0x6C,0xE6,0x51,0x86,0x21,0xEC,0x94,
	0x69,0x56,0x1B,0x16,0x8E,0x1B,0x8C,0x55,0x5D,0xC9,0xBF,0x22,0x35,0xBB,0x95,0xF8,0x56,0xEE,0x09,0xA3,
	0x0E,0x78,0xB8,0xFE,0x87,0x6F,0x20,0x5F,0x5E,0x01,0x64,0xDB,0xF8,0xEE,0x98,0x1A,0xA9,0x72,0xDB,0x05,
	0x51,0xBC,0xEE,0x54,0x6B,0xD6,0x26,0xE3,0x17,0xA1,0x55,0x50,0x90,0xF3,0xF1,0xFF,0x5D,0xD5,0x16,0x6D,
	0xCF,0xD5,0xD7,0x0C,0x64,0xAE,0x5D,0x77,0x7F,0x75,0x4F,0x45,0xF7,0x63,0x0E,0x59,0x51,0x27,0x2B,0xD7,
	0xDB,0x19,0xD2,0x56,0x34,0x85,0x75,0xAF,0x85,0x11,0x76,0x15,0x49,0xE5,0x53,0x3C,0x69,0x00,0xCA,0x5B,
	0xB3,0x59,0x5D,0x58,0x4A,0x73,0x17,0x8F,0x0D,0xC8,0x62,0x82,0xC5,0x58,0x88,0xF3,0x03,0xDF,0x59,0x0F,
	0x91,0xCB,0xF7,0x84,0xE8,0xA8,0x69,0xAB,0x42,0x1A,0x1D,0x02,0xBC,0x44,0xE7,0x7F,0xC1,0x10,0x91,0xAC,
	0xB7,0x6B,0xA5,0xFA,0x43,0x31,0x06,0xDE,0xE4,0xF6,0x91,0x85,0xDC,0x24,0x97,0xD6,0xED,0xDA,0xA8,0xC2,
	0x4D,0xA9,0xE6,0x9C,0x02,0x10,0x87,0x2E,0xE3,0xFE,0x83,0x94,0x94,0xF7,0xCB,0x9D,0xEB,0xC6,0x27,0x55,
	0xA9,0xBF,0xE8,0x8A,0x04,0xC9,0xAE,0xEB,0xB9,0xFE,0x76,0x45,0x75,0x68,0xC9,0xE8,0xDB,0xEF,0xA4,0x9F,
	0xE4,0x20,0xCB,0xDD,0xF7,0x14,0xEE,0x4F,0xFB,0x44,0xAA,0xA8,0x14,0xCC,0xB4,0xB1,0xC2,0x05,0x1B,0x77,
	0xFC,0x22,0x27,0xA7,0x18,0xAC,0x0A,0x2A,0x9E,0xAB,0xDA,0xE8,0x55,0x85,0xD0,0xDE,0x5F,0x70,0x97,0x21,
	0x0F,0x6F,0x25,0x98,0xBB,0x40,0x95,0x7C,0xC6,0x56,0x70,0x09,0x16,0x01,0x85,0x7F,0x2D,0xBB,0x0E,0x00,
	0x5C,0xEF,0x03,0xCC,0x45,0x24,0xBF,0xE4,0xB8,0x3B,0xB0,0xD6,0x24,0x59,0x2F,0xA3,0xD3,0x21,0x37,0xAA,
	0x1C,0xF5,0x57,0xD5,0x1B,0x53,0xDF,0x4D,0x19,0x8C,0xE9,0x60,0x36,0x7A,0x03,0x9E,0xAC,0x42,0xE5,0x77,
	0x31,0x0A,0x06,0xBC,0x79,0x7C,0x3C,0x53,0x36,0x05,0x0E,0x38,0xB6,0xBC,0xB5,0xAA,0x84,0xD5,0x7E,0xEA,
	0xFB,0xCE,0xD9,0x16,0xD2,0x66,0xB2,0xB5,0x62,0xE0,0xDB,0xDA,0x57,0xEA,0x73,0x7D,0xDB,0x92,0x96,0x02,
	0x5A,0x22,0xDF,0xB7,0xCE,0xDF,0x25,0x47,0x40,0xEE,0x02,0xEE,0x16,0x31,0xF9,0x28,0xE6,0x4C,0x96,0x16,
	0x8D,0x49,0xAF,0x46,0x60,0x94,0xAA,0xD0,0xDC,0x9D,0xA4,0xC8,0x57,0xC3,0xB5,0x06,0x8C,0x65,0x5B,0x3A,
	0xA3,0x18,0x89,0xC6,0xDF,0xF2,0x77,0x0C,0x35,0x88,0x30,0xBD,0x1A,0x97,0xA9,0xC3,0xB2,0x2A,0x58,0xD0,
	0x51,0x50,0x29,0xDA,0x6D,0xF9,0xD7,0xCF,0x55,0x48,0xCA,0xEF,0x0F,0x89,0x21,0xA3,0xE9,0xEF,0xAF,0xD2,
	0x37,0x6E,0xF7,0x81,0x38,0xC7,0x35,0xC2,0xD9,0x57,0xBC,0x36,0x30,0xBA,0x88,0x41,0xB5,0xA5,0xA0,0x6F,
	0xA3,0xFF,0x55,0x5A,0xD4,0xDA,0xB1,0x00,0x72,0x3E,0x1D,0x42,0x6C,0x06,0xAC,0x1D,0x27,0x7B,0xE9,0x1F,
	0x25,0x58,0x5D,0xDE,0x42,0xFA,0x15,0x6D,0x2C,0x16,0xDD,0x53,0xC4,0x22,0xB1,0x37,0xFE,0xF2,0xC4,0x84,
	0x11,0x0C,0x49,0xF5,0xA0,0x02,0xAA,0x3A,0x11,0xD2,0xE8,0xED,0x53,0xDA,0xB5,0x6F,0xF8,0x0E,0x03,0x93,
	0xF1,0xCE,0xF1,0x51,0xD3,0xDE,0x1F,0xAE,0x30,0x9C,0x3C,0x5A,0x81,0x30,0x47,0xC5,0xFE,0x57,0xA3,0x00,
	0x1B,0x24,0x67,0x40,0xE1,0xCB,0x40,0x03,0x3B,0x48,0xFA,0x45,0xB2,0xCD,0xC7,0x47,0x94,0xE9,0xDD,0x3D,
	0xA5,0x28,0x32,0x01,0x50,0x27,0xDD,0x1B,0xBD,0x0C,0x3E,0x18,0x68,0x48,0xC5,0xFD,0x5D,0x7C,0x9F,0x30,
	0x19,0x0C,0xF4,0x7F,0xC7,0xC2,0x54,0x30,0xE6,0x99,0x60,0x6B,0xCD,0x8B,0x80,0x26,0xE3,0x92,0x47,0x6B,
	0xBB,0xD4,0xB0,0x68,0x03,0x4D,0xA9,0xD6,0x45,0x40,0x62,0x18,0x6E,0x8E,0xE1,0x45,0x40,0xE9,0x33,0x30,
	0xA6,0x82,0x4F,0x70,0x69,0x08,0x04,0xF5,0x40,0xA8,0x4A,0x2B,0xDD,0x7C,0xC7,0x87,0x59,0x99,0x82,0x30,
	0xBF,0xE5,0x39,0xE2,0x2B,0x51,0x1E,0x9A,0xB0,0x1B,0x3D,0x5A,0x1C,0x57,0x75,0x60,0x40,0x62,0xCA,0x0F,
	0x6A,0x34,0x56,0x6F,0x38,0x14,0x06,0x5A,0xB5,0x14,0x03,0xFA,0x0B,0x7B,0x39,0xBD,0x11,0x12,0x03,0x83,
	0xCA,0x01,0x71,0xB4,0x1D,0xE5,0x2A,0x31,0x00,0x08,0xE1,0x1E,0x88,0x42,0xE4,0x1A,0x88,0x5E,0xF2,0x06,
	0x98,0xF4,0x01,0x93,0x96,0x31,0x9C,0x8A,0x86,0xE1,0xAA,0xAE,0x2C,0x29,0xEB,0xE9,0xD1,0xFE,0x2A,0x15,
	0xFA,0xDF,0x08,0x03,0x20,0x69,0x98,0xC4,0x4A,0xB0,0xF9,0x8E,0x8B,0x92,0xF1,0xB0,0x92,0x20,0x25,0x02,
	0x23,0xCF,0xC8,0xF2,0xB8,0xCF,0x09,0xB6,0x0C,0xEB,0x00,0x10,0x15,0x4A,0x59,0xB0,0x41,0x9E,0x19,0x88,
	0x4D,0x88,0x15,0x8D,0x49,0x88,0x2A,0x15,0xE2,0x52,0x28,0x57,0x5E,0x98,0x67,0x9D,0x0B,0x15,0x9D,0xE5,
	0x60,0x79,0x19,0x11,0x51,0x98,0x88,0x38,0x06,0x38,0x14,0x9E,0x78,0xCC,0x4F,0x90,0x78,0xC8,0x6B,0xC3,
	0xD4,0x04,0x06,0x43,0x30,0x8C,0x23,0x6C,0x44,0x6F,0x96,0x25,0x66,0xA5,0x3E,0xE5,0xBA,0x9D,0x23,0x81,
	0x05,0xC5,0xC9,0x01,0x13,0x18,0x47,0x6C,0x00,0xA6,0x69,0x9A,0xA6,0x13,0x20,0x33,0x40,0xBD,0xBE,0x80,
	0x82,0x6F,0x9A,0xA7,0x8E,0x2A,0xE4,0xF4,0x74,0xB0,0x36,0x75,0xF3,0xEE,0xD7,0x64,0xEB,0xF9,0x34,0xFB,
	0xDA,0x02,0x77,0xB5,0x68,0x49,0xA8,0x1B,0xE8,0x3B,0xA9,0x40,0x0E,0x4D,0xED,0xA2,0x98,0xF7,0x1C,0x07,
	0x72,0xDE,0xF7,0xD4,0xC8,0x1E,0x6A,0xF5,0xDE,0xC9,0xF7,0x6A,0x03,0xDF,0x1C,0x79,0xE5,0x12,0x5D,0xC5,
	0xE0,0x87,0x3D,0x25,0x7A,0x9B,0x8F,0x8B,0x50,0x39,0x25,0xDC,0x96,0x98,0x98,0xB6,0x30,0x76,0x36,0xBD,
	0x4C,0x2E,0x1E,0xA8,0xF4,0xED,0xAE,0x8A,0x27,0x94,0x06,0xF1,0xA0,0x1A,0xA1,0x7D,0x60,0x73,0xEA,0x60,
	0xFD,0xA3,0xD3,0xA2,0xE4,0xE7,0xB4,0x17,0xB5,0x48,0x6C,0x43,0x7D,0x93,0x17,0x65,0x83,0x8C,0x5F,0xC5,
	0xF0,0xC1,0xD5,0x0C,0x2E,0x57,0x4F,0xC5,0x47,0x19,0xEB,0xDE,0x3C,0x31,0xAD,0x75,0x55,0xB7,0x6A,0xA2,
	0x20,0xBA,0x6E,0x0D,0xAC,0x61,0x37,0xBB,0x19,0xA9,0x28,0xD7,0xE4,0xE9,0x43,0x82,0x2C,0x2A,0x23,0xDB,
	0xC5,0xC7,0x26,0xEF,0xBB,0x0C,0x7D,0xA2,0x58,0xAA,0x4E,0x4C,0x1A,0xAB,0xDC,0xA9,0xC0,0x46,0xD6,0x52,
	0xE3,0x32,0x0A,0x97,0x59,0x59,0x9F,0x50,0x6A,0x4A,0x4F,0x74,0x00,0xAC,0xF5,0xA0,0xF1,0x5B,0x01,0xA0,
	0xFD,0x01,0x6E,0x3F,0xCF,0xCA,0x29,0xAE,0x1E,0x50,0xB6,0x15,0xA0,0x40,0xF8,0x83,0x0B,0xD6,0xEF,0x71,
	0xE9,0x6F,0xEB,0x7B,0xE3,0xC8,0xC9,0x91,0xEE,0x71,0xEF,0xF3,0x52,0x57,0x70,0x0D,0xFE,0xEC,0xE4,0x2A,
	0xEF,0x10,0x49,0xE1,0x21,0xCD,0xD6,0x37,0xAB,0x4E,0x29,0xD5,0xD5,0x97,0x3E,0xFF,0x36,0xA9,0x5E,0x26,
	0x47,0xF8,0x74,0xCB,0x76,0x9D,0x1F,0x9C,0x9F,0xF1,0xCE,0x05,0xC5,0x3A,0xAB,0xA0,0x50,0xCE,0xF5,0x83,
	0x4C,0x6A,0x7C,0x25,0x7E,0x9B,0xEB,0xEC,0x00,0xAE,0x7A,0xD5,0xEB,0xAB,0x50,0x2C,0x2E,0x98,0x34,0x73,
	0xB5,0x30,0xF0,0x2F,0x31,0xAA,0x65,0x17,0xBE,0x84,0x88,0xEB,0x84,0xE5,0x6C,0xDF,0x17,0xFC,0x19,0x4A,
	0x5A,0xF7,0xF9,0x80,0x20,0xB8,0xE1,0xAA,0x79,0x74,0x1F,0x80,0x34,0x43,0x0B,0x8B,0x2B,0x4A,0x88,0x81,
	0x62,0x5B,0xAE,0x1D,0x58,0x06,0xC3,0xC4,0x6B,0x22,0x93,0xFA,0x89,0x45,0xC4,0x28,0xFE,0x53,0x1E,0x8E,
	0x48,0xD0,0x0A,0x2E,0x9F,0x47,0xB3,0xAA,0x13,0x90,0x03,0x4E,0xAB,0x97,0x5E,0x72,0x96,0x48,0x02,0x51,
	0xDE,0xA1,0x61,0x14,0xD7,0x46,0xA9,0xBE,0x0A,0x83,0x0B,0x7C,0x07,0x0B,0x15,0x88,0x96,0x95,0x28,0xF8,
	0x47,0xB0,0xBC,0xFC,0xAE,0x7F,0xEB,0xB4,0x97,0x67,0x8D,0x6D,0xAF,0x66,0xAD,0xE3,0xCA,0xA6,0x98,0x2C,
	0x2A,0xAB,0xD4,0x23,0x03,0x30,0xBB,0xA0,0xD6,0x1E,0x41,0x71,0x77,0xE2,0xBF,0xC7,0xE9,0x60,0x13,0xE9,
	0xC8,0x56,0x09,0x02,0xD7,0x56,0xAA,0x89,0x80,0xB1,0xEC,0x9A,0xDC,0xAD,0xDE,0xBB,0x16,0x08,0x7B,0x2A,
	0x36,0xC3,0xDC,0x50,0x10,0x90,0x25,0x8D,0x98,0x57,0xFE,0x81,0x02,0x9D,0x48,0x63,0x57,0x96,0x47,0xC1,
	0x44,0xE3,0x1A,0xF9,0x2E,0x30,0x71,0xB4,0x7C,0x30,0xC5,0x13,0xF0,0xB2,0x4D,0xB7,0xE9,0x51,0x6D,0xA9,
	0xAB,0xEC,0x41,0x16,0x38,0xD9,0x32,0xE5,0xE1,0x7C,0x3A,0x22,0x44,0xD9,0x7F,0xC2,0x84,0xD7,0x16,0xA4,
	0x35,0xBD,0x3E,0x27,0x5D,0x83,0x3A,0x13,0x77,0xFF,0x23,0xFB,0xD0,0x81,0x2A,0x30,0x2D,0x4E,0xA8,0xC2,
	0xA8,0x6E,0xF4,0x3E,0x80,0x0A,0xD2,0x0A,0x7E,0x53,0x23,0xB6,0xFB,0x52,0x15,0x41,0x0D,0xB7,0x64,0x85,
	0xFD,0x19,0x71,0x20,0xA9,0x94,0xCE,0xC0,0x20,0xFB,0xC5,0x0C,0x23,0x9E,0x86,0xA1,0x8A,0xA6,0x3D,0xBB,
	0xFB,0x8C,0x9F,0xE9,0x62,0x40,0xB7,0x10,0x05,0x27,0xB7,0xF4,0x74,0x9C,0x5C,0x05,0x56,0xAD,0xC5,0x7E,
	0x44,0x49,0xD7,0xDB,0x96,0xCA,0xF5,0xE9,0x83,0xBB,0xC6,0xDC,0xDB,0xBF,0x2B,0x40,0xF5,0x50,0x35,0x70,
	0xC7,0x66,0xB8,0xC6,0x97,0x2C,0x1F,0x4B,0x55,0xFC,0xFA,0x8A,0x38,0x1B,0x0C,0x57,0x99,0x51,0xFD,0xE1,
	0x06,0x98,0x59,0x64,0x89,0xC3,0xB8,0x4D,0x57,0x9B,0x9F,0x92,0xD4,0xA9,0xF2,0xA4,0x26,0xD7,0xC5,0x5A,
	0xE6,0x32,0x77,0xFD,0x35,0xE5,0xAF,0xAA,0xDA,0x02,0xE9,0x11,0xA6,0x73,0x7F,0x11,0x5C,0x91,0xB8,0xC1,
	0x9C,0x75,0xA4,0x57,0x96,0x0F,0x06,0x87,0x5F,0x22,0x6A,0x1F,0xD5,0xFA,0x0E,0x28,0xA9,0xE1,0xBD,0xCB,
	0x62,0x96,0x2F,0xBC,0xB1,0x6C,0x9A,0x61,0xA9,0xC1,0x7D,0x82,0xD8,0x2C,0x5A,0xB1,0x4B,0x28,0xF8,0xAA,
	0xF2,0xB7,0x0A,0x3A,0x20,0xE6,0x39,0x1C,0xB3,0x3C,0x8E,0xFA,0x94,0xFF,0xBB,0xE1,0x03,0x00,0xEC,0xF7,
	0x2F,0xCC,0x20,0x66,0x0C,0xC2,0x83,0x45,0x06,0x61,0xCE,0xEA,0x2E,0x56,0x2D,0x77,0x4D,0xD5,0xAD,0x55,
	0x07,0x50,0x52,0x2E,0xAF,0xB3,0xDA,0x46,0x8F,0xFE,0x99,0xC6,0xAC,0x64,0x9A,0x97,0x9D,0xBE,0xCB,0x9C,
	0xB3,0xB6,0x3F,0xC6,0xBF,0xAB,0x9C,0xB4,0xBA,0x52,0x2F,0xB1,0xE9,0xC6,0x67,0x44,0x2A,0x54,0xD1,0x72,
	0x26,0x19,0xE6,0x70,0xBF,0xC6,0xAA,0x98,0x86,0xB2,0x88,0x1B,0x19,0x5E,0xFC,0x3E,0x49,0x3F,0x87,0x3C,
	0x29,0x0D,0x83,0xD7,0x09,0x79,0x73,0xDA,0xF4,0x63,0x26,0x21,0x13,0x8C,0xFF,0x3E,0x8F,0x63,0x97,0x74,
	0xCD,0x10,0x9A,0x84,0x9F,0x49,0xA8,0x20,0x5F,0x6A,0x06,0x29,0x2B,0xDE,0x8A,0xB0,0xBA,0x6C,0x09,0xBE,
	0x5A,0xC9,0xE8,0xC8,0xCF,0x39,0x2A,0xDB,0x19,0x13,0x20,0x79,0x2B,0xAE,0xE4,0xAC,0x6B,0xC4,0x40,0xEA,
	0x39,0x45,0x95,0xE0,0x49,0x0A,0x08,0x71,0x99,0xD0,0x24,0x34,0x05,0x65,0x1E,0x6A,0x6F,0xCC,0x90,0x4C,
	0xED,0x19,0xA0,0x89,0x20,0xD0,0x8C,0xFF,0x68,0x0D,0x12,0x92,0xC1,0x6E,0xC3,0x01,0x21,0x82,0x84,0x08,
	0xD7,0x11,0xA3,0xB4,0x63,0xF7,0x27,0x6D,0x39,0xA6,0xF2,0xC8,0x24,0xA1,0xAD,0x8E,0x99,0x19,0x10,0x06,
	0x99,0xEC,0x04,0xFF,0x76,0xB7,0x46,0xE3,0xA0,0x3C,0x52,0x6C,0xD7,0x2F,0x14,0x42,0x3E,0x13,0xB7,0x5E,
	0x08,0x0F,0x4F,0x01,0x52,0xBE,0x08,0x86,0x55,0x07,0xF4,0x34,0x00,0xF6,0x6F,0xAB,0x9E,0x6D,0x95,0x12,
	0x8A,0x50,0xA7,0xD0,0x3A,0xCA,0x00,0x57,0x1D,0xB5,0x6A,0xCB,0x54,0xBB,0xD8,0xEB,0xCA,0x2C,0x2A,0xB8,
	0x12,0x9E,0xBF,0xE5,0xF5,0xB4,0x39,0x35,0x9E,0x40,0x03,0x77,0xE8,0x12,0x9D,0xFD,0xE4,0x2E,0xE7,0x60,
	0xAB,0xEC,0xE8,0xBF,0xC2,0xF5,0x57,0x55,0x59,0xE1,0x58,0x06,0x76,0x05,0x10,0x93,0xF3,0x42,0x0D,0x22,
	0x75,0x0A,0x7E,0xB5,0xDD,0xF9,0xE0,0x88,0xD7,0x29,0x8C,0xE2,0xC7,0x4E,0xF5,0x17,0xFD,0x49,0x09,0x58,
	0x06,0xFE,0xFF,0xC5,0x53,0xA4,0x84,0xDC,0xCE,0x1C,0xB5,0xFD,0x9F,0xD7,0xCA,0xA9,0x5E,0xD6,0x87,0x04,
	0x1C,0x06,0xB3,0xE3,0x46,0xBB,0xC8,0x53,0xE4,0x03,0xD3,0xB9,0x70,0x64,0x65,0x7F,0x39,0xCF,0xB5,0xEB,
	0x8B,0x45,0x59,0xA9,0x93,0x13,0xB0,0x23,0x01,0x64,0xEA,0x5A,0x80,0x3B,0x12,0x5B,0x91,0x00,0x73,0xAA,
	0x26,0xB7,0xE0,0xB7,0x27,0x36,0x02,0x4E,0x0D,0xF3,0xB0,0x65,0x59,0x8C,0x62,0x81,0x9C,0x50,0x1B,0x08,
	0x6A,0xDB,0x1B,0x30,0x9B,0x33,0xD3,0xF3,0xD9,0x57,0xA6,0x72,0x28,0x0E,0xB8,0x72,0xAE,0x96,0x8A,0x47,
	0xAC,0x92,0x1C,0x06,0xFF,0x0F,0xC2,0x0A,0x65,0x71,0x11,0xD4,0xF8,0x17,0x7D,0xF3,0xE6,0x0F,0x84,0x25,
	0x82,0x8F,0x05,0xC5,0xC8,0x2C,0x6F,0x28,0x57,0x1F,0x9E,0x1B,0x7D,0x22,0x9F,0xCF,0xDA,0x2B,0xB1,0x97,
	0x0C,0x77,0xAD,0x02,0x43,0x5F,0xD6,0xED,0xD1,0xF5,0xFB,0xB0,0xFB,0x4B,0x0D,0xA6,0xA3,0xD5,0x97,0x1F,
	0xEC,0xBE,0x28,0xC5,0xE4,0xE7,0x80,0x94,0x03,0x28,0x32,0x16,0x55,0x2A,0x9C,0xFF,0x84,0xE1,0x30,0x70,
	0xC1,0xE0,0x6E,0x96,0x89,0x90,0xB6,0xB8,0x60,0x27,0x78,0x3B,0xC8,0x2B,0x9A,0x0E,0x74,0xF5,0xF1,0x8C,
	0x82,0xC7,0xB5,0x6E,0x03,0x09,0xE8,0x05,0x9E,0xA5,0x2B,0x5E,0xBB,0x62,0x6C,0x0C,0x13,0xA1,0x00,0xA4,
	0xD5,0xB7,0xDD,0xE1,0x9B,0xD3,0x15,0x16,0xA1,0xDD,0xA9,0xC5,0xAC,0xC8,0x79,0xB1,0xD1,0x5B,0x1D,0xD6,
	0xC5,0xDA,0x98,0x4C,0x29,0x32,0xBB,0x91,0x60,0x7A,0xB7,0x48,0x48,0xC2,0x0D,0x5F,0x2D,0x25,0x22,0x1D,
	0x98,0xAE,0xC1,0xB2,0x31,0x42,0x9A,0x9C,0x40,0x14,0x9E,0x0E,0x28,0x9B,0xDA,0xB9,0x58,0x3D,0x9C,0xEC,
	0x32,0x65,0x62,0x5E,0x59,0x4E,0x8D,0x73,0xB4,0x56,0x05,0x15,0x77,0x29,0x42,0x3A,0x45,0x7C,0x6F,0x48,
	0x43,0xE7,0xB3,0xF1,0xF2,0xF9,0xDB,0x95,0xD1,0xFB,0x4A,0x98,0x9C,0x15,0xA2,0x5B,0xA5,0xD6,0x39,0xB2,
	0xAB,0xF7,0x7C,0x05,0x32,0x60,0xD7,0x52,0xE9,0x84,0xD1,0x46,0x01,0x12,0xE5,0x52,0xFC,0x16,0x81,0x0D,
	0xED,0x5D,0x8E,0x81,0xD4,0x5B,0x74,0x8E,0x58,0x0B,0xEE,0x51,0x89,0x41,0xB3,0xC4,0x77,0x81,0xB3,0x7F,
	0xB3,0xDC,0xC1,0xFB,0x15,0x64,0xEC,0xAC,0x9C,0xD1,0x69,0xBA,0x0A,0x19,0x5A,0xD3,0xBA,0x1F,0xEB,0x2C,
	0x63,0x16,0xA1,0x2B,0xC5,0x59,0x20,0xD7,0x30,0xDB,0xEA,0xDE,0x6F,0xF3,0x5B,0x59,0x30,0x69,0xCF,0x14,
	0x88,0xB4,0xD1,0x85,0xF9,0x06,0x8E,0xB6,0xBB,0xB6,0xD3,0x44,0x70,0xB6,0xBA,0xFE,0x2E,0x94,0x0D,0xE9,
	0x86,0x68,0xED,0x71,0xF6,0x29,0xAF,0x86,0xF0,0xDD,0xD5,0xCE,0x86,0x37,0xC2,0x00,0x80,0x50,0x58,0x04,
	0x85,0x06,0xDB,0x88,0x09,0x69,0x97,0x46,0x6F,0x80,0x89,0x48,0x09,0x42,0x30,0x1B,0x0C,0xCE,0x7E,0xF4,
	0x35,0x76,0x75,0x36,0xBD,0x02,0x93,0x70,0xF0,0xC6,0x4F,0x1B,0x2A,0x68,0xAD,0x72,0xB8,0xBB,0x69,0xCB,
	0xD4,0x85,0x96,0x12,0xA2,0x29,0x70,0x95,0xDC,0xAD,0xAA,0xFF,0x37,0xEB,0x4E,0xE4,0x57,0xFC,0xAA,0x1A,
	0xD6,0x27,0xF1,0xAB,0x0A,0x94,0x3A,0xC8,0x98,0x03,0xF1,0x70,0xCB,0xF4,0xBB,0x34,0xE9,0x28,0x2D,0x84,
	0xAF,0x16,0x2D,0xEA,0x6D,0xE1,0x6B,0x88,0x71,0x65,0xF8,0x37,0x19,0xAE,0xB9,0xDD,0x2E,0xA9,0x47,0xA8,
	0x57,0xD5,0xF6,0xB9,0xC2,0xA5,0xE0,0x3F,0xDB,0xD7,0x95,0x5B,0xAD,0x9D,0x51,0xFF,0x59,0xF0,0x6F,0x31,
	0xB8,0xCA,0xEF,0x01,0x1A,0x5D,0x5B,0xB5,0x32,0x38,0xD0,0x45,0xEA,0x82,0xB8,0x7A,0xDC,0x97,0xD6,0xDB,
	0x6E,0xA2,0xDF,0x0D,0xEC,0xC1,0x1F,0xF8,0x24,0x03,0xE9,0xBD,0x67,0xA2,0xA2,0x36,0xC4,0x31,0xAA,0x03,
	0xE7,0x6F,0x1B,0xAA,0xD5,0xFF,0xF3,0x28,0x84,0x8B,0x5B,0x89,0xD4,0x25,0x78,0xF4,0x97,0x51,0xAD,0x53,
	0x95,0x98,0x85,0x4C,0xE2,0x9C,0xF5,0x9D,0x8A,0xD3,0xB4,0x4C,0x30,0xBF,0xFD,0x5C,0x48,0x8E,0x64,0x47,
	0x04,0x53,0xB0,0x44,0x46,0x02,0xF8,0xFE,0xA7,0xF8,0x38,0x98,0x92,0xAB,0x18,0x7D,0xE4,0x9A,0x1A,0x2B,
	0xF0,0xD1,0xAA,0xE6,0x71,0x91,0xE0,0x9F,0x6E,0x73,0x06,0x14,0xFF,0x01,0x75,0x17,0x72,0x2E,0xD6,0xAF,
	0x80,0x3E,0x47,0x83,0x1D,0x97,0x48,0x6C,0x8E,0x76,0x01,0x4F,0x6B,0xCD,0x9A,0x6F,0x7E,0x54,0x54,0x7D,
	0x55,0xE8,0x38,0xAA,0x55,0xFB,0xBA,0x0A,0x05,0xFA,0x96,0xD1,0xBD,0xE9,0x90,0xAF,0xE9,0xCB,0x25,0x68,
	0x81,0xFA,0x83,0xDC,0xE7,0xDD,0xFE,0xB8,0xFC,0x57,0x14,0x95,0x77,0xFC,0xD6,0x80,0x24,0x6C,0x47,0x31,
	0xE8,0xCC,0xB9,0x03,0x8E,0x13,0xDF,0x4A,0x26,0x06,0x31,0x10,0xE4,0x60,0xAB,0x11,0xD7,0x87,0x6B,0xB9,
	0xD6,0x5F,0xE7,0x43,0x6F,0xBA,0x74,0x7C,0x86,0xDE,0x77,0xE0,0x33,0x03,0xC1,0xEB,0x84,0xDA,0xB1,0xD8,
	0xBA,0xCC,0xFE,0x97,0xCF,0xBE,0x93,0x2F,0x34,0x69,0x4A,0xCE,0xB5,0xFA,0x97,0xA0,0xED,0x4B,0xF5,0x6D,
	0xD8,0x0C,0x4A,0x1C,0x5C,0x3D,0x61,0xB5,0x2A,0x3A,0x81,0x8B,0x2E,0x42,0x50,0x6B,0xC0,0x19,0xE1,0x92,
	0x7B,0xF3,0x08,0xCF,0x5D,0x6F,0xD3,0xB2,0xAF,0xA4,0x64,0x8E,0x35,0xF2,0xA7,0xEE,0xCC,0xF2,0x0B,0x37,
	0xE1,0xFC,0x3B,0x0E,0x82,0x3C,0x62,0x8D,0x2F,0x6A,0x71,0x04,0xA1,0x2A,0xB8,0xE5,0xD9,0x02,0xB1,0x86,
	0x76,0x3E,0x17,0xD0,0x53,0xE4,0x5D,0x43,0xA4,0xAE,0xBA,0x96,0x56,0xA7,0x2C,0xFB,0x69,0xCF,0xEC,0xBE,
	0xD6,0xFD,0x6F,0x9A,0x5A,0xEF,0xD7,0xD9,0xB0,0xFE,0xA7,0xF1,0x22,0x79,0x7E,0x56,0x16,0x7A,0x25,0x31,
	0x48,0xAB,0x1A,0x30,0x40,0x3E,0x11,0x93,0x5E,0x13,0xBE,0x1A,0x60,0xE1,0x1F,0xCC,0x3E,0x3E,0x65,0x1B,
	0x1F,0x31,0x61,0xD6,0x5B,0x0D,0x95,0xD9,0xA8,0x3D,0x22,0x30,0xA6,0x18,0xF6,0x1D,0x85,0x85,0x9B,0xE0,
	0xF7,0x44,0xE7,0x8B,0xE0,0xD4,0x5E,0x45,0xE4,0x03,0x97,0x71,0x25,0x45,0x33,0x39,0x5C,0x63,0xAE,0xA0,
	0xF4,0x66,0x06,0x49,0x8D,0xFE,0xEE,0xC3,0xA0,0x3C,0x67,0xB4,0x9A,0x86,0xF3,0x42,0x65,0x91,0x40,0x2E,
	0xB2,0xAA,0x28,0xE3,0x8E,0xA9,0xC6,0xA0,0xD8,0xE4,0xB4,0x8C,0x68,0xAE,0xAA,0x27,0x6B,0x98,0x0F,0x16,
	0x59,0x8C,0x9E,0x94,0x1F,0x9A,0xF0,0x62,0x10,0xE9,0x8A,0xF2,0xA4,0x6E,0x51,0x8D,0xFC,0x8B,0xA7,0x05,
	0x45,0x90,0xD1,0x5D,0xDA,0xF7,0x7A,0x05,0x28,0x78,0xF6,0x17,0x29,0x60,0xCE,0x00,0xC2,0xDC,0x72,0x25,
	0xE8,0xCF,0x8A,0x6A,0xDF,0x18,0x12,0x41,0x92,0x67,0x01,0x30,0x13,0x92,0xA2,0x31,0x0D,0xAF,0xAC,0x55,
	0x96,0x80,0x4E,0x07,0xA0,0xAA,0xA7,0x3F,0x19,0x6B,0x17,0xA7,0xE7,0xEA,0x4F,0x85,0x60,0x0C,0xC7,0x53,
	0x86,0x4C,0xB1,0xF1,0xD3,0x22,0x45,0xEF,0xE6,0xC0,0xC8,0x0B,0x25,0x76,0xFE,0xF2,0x10,0x7F,0xFB,0x3E,
	0x74,0x4C,0x55,0x71,0xAA,0xEC,0xC4,0xF4,0x7F,0x48,0x8E,0x87,0xA6,0x70,0x0A,0x18,0x51,0x58,0xB5,0x97,
	0x8D,0x1B,0x18,0x2D,0xCE,0xDD,0xB1,0xA2,0xCA,0xB2,0x12,0xEE,0x85,0x5D,0x63,0x9A,0xAA,0xD6,0xD6,0x9D,
	0x2C,0x8A,0xEC,0xA2,0x3E,0xFA,0xDA,0xAA,0xAA,0xA3,0xFA,0x20,0xCA,0xB1,0x8A,0xC9,0xA9,0xE6,0xD0,0xAA,
	0x8C,0x15,0xB4,0xA8,0x62,0xD5,0xB0,0xFF,0xCF,0xE4,0x77,0x04,0xB9,0x68,0x99,0x91,0x68,0x05,0xD9,0xDB,
	0x0C,0x7E,0x02,0xA9,0x7B,0xDC,0xD7,0xDE,0xE0,0xFE,0xB4,0x73,0x2E,0x44,0xDA,0xBF,0x82,0x63,0x07,0x97,
	0x8F,0xE9,0xEA,0x73,0x00,0x6C,0x7C,0x55,0xCB,0xDA,0xE7,0x51,0x2C,0x9F,0x4A,0x7C,0xD4,0x19,0x52,0x2E,
	0x4F,0xAF,0x8A,0x50,0x6F,0xD6,0xEF,0xF9,0x1E,0xDC,0x5D,0x10,0x07,0x43,0x54,0xD8,0x5F,0xE5,0x8D,0x3A,
	0x6F,0x5D,0x3B,0x2B,0x29,0xD7,0x2C,0x60,0x55,0x91,0x7F,0xD9,0x6D,0x85,0x2F,0xD2,0x33,0xEC,0xC8,0xA7,
	0xE8,0xD5,0x6A,0x1E,0xA9,0x2F,0x5F,0x55,0x04,0x25,0x67,0x74,0xD2,0xAB,0xDF,0x25,0xAB,0x4D,0x6B,0x9D,
	0xBF,0x1F,0xEA,0xB2,0x79,0x9A,0xB4,0x34,0xBC,0xC0,0x28,0x6E,0xD0,0x78,0xE1,0x85,0xCB,0x6E,0x17,0x25,
	0x18,0xC8,0xC4,0xEF,0x2F,0xE8,0xE4,0x0D,0xC2,0x61,0xC4,0xEA,0x45,0xE7,0xC2,0xDC,0x2A,0x19,0xE0,0xD4,
	0x08,0xE7,0x3D,0x98,0xB3,0x5E,0xC6,0x47,0x2E,0xC2,0xCA,0x30,0x27,0xC6,0xD8,0x70,0xC6,0x54,0x04,0xD2,
	0xA2,0x47,0xFA,0xB2,0xB3,0xF3,0xCC,0x79,0xFA,0xFC,0xF4,0xFF,0x00,0x1B,0xAB,0xA8,0x4B,0xB6,0x0C,0x7D,
	0x37,0xBB,0x10,0x29,0xC6,0x72,0x89,0xB9,0xBB,0xCC,0xA0,0xAB,0x47,0xA2,0xBE,0xC5,0xDD,0x50,0x49,0x77,
	0xE5,0x7E,0xE3,0xA9,0x4F,0xFB,0x71,0x2E,0x30,0x07,0x1B,0x32,0xE4,0x9F,0x42,0xFD,0x2E,0x02,0xBF,0x89,
	0x38,0x4F,0xE0,0xD2,0xB3,0x16,0x22,0x28,0x1E,0x17,0x48,0x13,0xE2,0x43,0x0A,0x69,0xCE,0x00,0xD8,0x27,
	0xAB,0xC7,0x34,0x79,0x60,0x3A,0x22,0x39,0x2B,0x7A,0x7C,0x15,0xC7,0x39,0xA1,0x95,0x17,0xCB,0x83,0xAF,
	0x06,0x00,0x17,0x9F,0x2B,0x00,0x12,0x72,0xD1,0x06,0xAC,0xBC,0xE3,0xC9,0xF9,0x4B,0xEB,0xE4,0x45,0x1D,
	0x82,0x06,0x4F,0x71,0xE5,0xD2,0x4C,0x2E,0x98,0xE5,0xEC,0xF1,0x25,0x60,0xE4,0xD5,0xBC,0xBE,0xCE,0xCC,
	0xC4,0x3F,0xF3,0x71,0x69,0xC8,0x72,0x9A,0x82,0x8D,0x12,0x39,0xE2,0x3F,0x9E,0xDE,0x06,0x53,0xD4,0xDA,
	0xFA,0xE2,0xD2,0x37,0xB0,0x5E,0xD6,0xA5,0xCF,0x88,0xE9,0xCC,0xEA,0x8E,0xBE,0x41,0xCF,0x81,0xC4,0x14,
	0xDB,0x74,0x0B,0xFB,0x69,0x8F,0x40,0x97,0x40,0x3B,0x8E,0xA4,0xE0,0xEF,0x94,0xEF,0x86,0x3A,0xF1,0x21,
	0x73,0x75,0xA0,0x5A,0xC4,0x60,0xAA,0x2F,0x57,0x60,0x48,0xB0,0x12,0xA6,0x4C,0x3A,0x09,0x2F,0x8B,0x80,
	0x9F,0x6E,0xAD,0xBE,0x2E,0x7C,0x6C,0xB5,0xD6,0x2C,0x55,0x9A,0xF4,0x8E,0xB6,0x76,0x11,0x49,0x16,0x38,
	0x02,0x80,0x36,0x70,0x5D,0x04,0xA3,0xC4,0x09,0x55,0x63,0x70,0xDE,0x79,0x73,0xD7,0xFD,0xDA,0x65,0x3B,
	0xF3,0x54,0xC9,0xB8,0x95,0x61,0x22,0x6C,0xB3,0xC6,0xAE,0xDB,0xC7,0x2B,0x23,0xEC,0x95,0x0A,0xF7,0x6C,
	0x7E,0x04,0x26,0xA5,0x60,0xE4,0x1E,0xD5,0x2D,0xE3,0x43,0x16,0xF9,0xC8,0xC9,0x41,0x10,0x41,0x6B,0x3F,
	0xC9,0x7D,0x67,0xD1,0xE7,0x63,0xF5,0x33,0xB9,0x56,0x4D,0x81,0x55,0x6D,0xC1,0x8A,0x69,0x66,0x6A,0x81,
	0x30,0x93,0xC3,0xC4,0x55,0x8F,0x1C,0x9D,0x9A,0x91,0xDF,0x64,0xFE,0x9F,0xA9,0xBA,0xE5,0xDE,0x06,0x19,
	0x52,0x41,0xCB,0xC1,0x3E,0x0F,0x3A,0x26,0xEB,0xA8,0x1F,0xEA,0xCC,0x7B,0x04,0xEE,0x56,0xA6,0x8E,0xD3,
	0xA4,0x4D,0xDB,0x17,0x74,0xE8,0x89,0x8B,0x85,0x71,0x51,0x4F,0x66,0xA9,0x85,0xBE,0x02,0x89,0x86,0x5B,
	0x02,0xDE,0x76,0x0E,0x81,0x85,0x74,0x11,0x83,0x82,0xF7,0x39,0x81,0x8B,0x08,0x86,0x7C,0x7C,0x6F,0xF9,
	0x30,0x4C,0x4D,0x01,0x5E,0x2D,0x68,0x91,0xB3,0x43,0xA9,0x63,0xDB,0x56,0xB3,0x77,0xE5,0x1A,0x57,0x43,
	0x72,0x75,0xD8,0x2C,0xC5,0xF0,0x78,0x0C,0xEC,0xA8,0x3C,0xA9,0xB4,0x00,0xE3,0x6A,0xEE,0xAE,0x31,0xCA,
	0x32,0xCF,0x1A,0xF5,0x54,0xE9,0x51,0xA7,0x8C,0xC1,0xCB,0x09,0x86,0xFD,0x30,0xD4,0x2E,0x01,0x34,0x12,
	0x17,0x68,0x77,0x2C,0xAB,0xB8,0xD0,0x9B,0x45,0xB4,0x1B,0x19,0x62,0x75,0x81,0x0C,0xAB,0x16,0xAA,0x48,
	0xB2,0xF6,0x0F,0x70,0x93,0xF6,0xEF,0xA2,0x0D,0x9A,0x4F,0x85,0xFA,0x0B,0x8E,0xCB,0x69,0x22,0x6B,0x7C,
	0xD1,0x19,0xC2,0xDB,0x88,0xBB,0x2A,0xC3,0x38,0x47,0x33,0x90,0xFE,0x71,0x28,0x8C,0xFF,0x1B,0xBE,0xC2,
	0x8B,0x02,0x2E,0xCE,0x40,0xE0,0x14,0x64,0x18,0xE1,0x86,0x9E,0x53,0xE2,0x05,0x50,0x7E,0x71,0xEB,0xF2,
	0x55,0x88,0xFC,0xBD,0xEF,0x51,0x44,0xD5,0x3A,0xB8,0x5D,0x69,0xB7,0xD7,0x04,0xE2,0x99,0x32,0xAD,0x93,
	0xE7,0x3B,0x5C,0x16,0x5E,0xD7,0x69,0x97,0x83,0xA2,0xC3,0xC0,0x44,0x00,0x9A,0x7F,0x00,0x39,0xFB,0x9D,
	0x5D,0xB2,0x77,0x4A,0x7C,0xFD,0x13,0x56,0xF4,0xAE,0x93,0x87,0x15,0xF7,0x36,0xE9,0x00,0x6A,0x22,0x5B,
	0x51,0xA8,0x59,0x11,0x7E,0x23,0x48,0x74,0x40,0x08,0xFF,0x53,0x41,0x11,0x9A,0x74,0x92,0xA1,0x05,0xA7,
	0x5F,0x0D,0x8C,0x33,0x89,0xAE,0x00,0xCC,0x82,0x6F,0xB1,0x56,0x2E,0x0A,0x80,0x40,0xF3,0x3A,0x78,0xAB,
	0x66,0x1E,0x68,0xCE,0xED,0xC2,0x0A,0x26,0xE6,0x0E,0xE8,0x0F,0x50,0xC2,0x1A,0x3F,0xFC,0x74,0x07,0x97,
	0x00,0x40,0x2A,0x98,0x09,0xC4,0x0A,0x0C,0xF5,0x04,0x35,0x62,0xEF,0xEA,0x10,0x1A,0x89,0xB3,0xB1,0xAB,
	0x39,0x66,0xC4,0x0A,0x60,0x27,0xB8,0xEA,0xCD,0x6A,0xA2,0xBE,0xC7,0xC8,0x36,0x58,0x9B,0x30,0xE1,0xBC,
	0x34,0x30,0xE4,0xC3,0x0B,0x98,0x51,0x7F,0xC2,0x77,0x0A,0x8B,0xB9,0x00,0xBC,0xB0,0xD1,0xAC,0x4B,0x72,
	0x2F,0xBE,0x77,0xE8,0x2B,0xBD,0x21,0x4F,0x51,0x1E,0x73,0xF8,0x27,0x72,0x23,0x56,0x72,0xC1,0xA0,0x52,
	0x3F,0xA8,0x67,0xE8,0xD8,0x06,0x48,0x71,0x59,0xCC,0x5E,0x90,0x28,0x19,0xEF,0x98,0x10,0x87,0x4D,0x30,
	0x18,0x00,0x00,0x00,0xF9,0x44,0x80,0x2C,0xD8,0x41,0x8C,0x58,0xD4,0x6D,0x88,0xD2,0xD0,0x4A,0xB4,0x68,
	0xEC,0x7A,0xB0,0x68,0xE8,0x5F,0xBC,0xF2,0xE4,0x00,0x00,0x7C,0x19,0x7F,0xB8,0x78,0x70,0x6B,0x38,0x4D,
	0xF9,0x48,0xAD,0xDD,0xF5,0x6F,0xA9,0x5F,0xF1,0x18,0xB6,0x76,0xAB,0xF4,0x4D,0x67,0x44,0x51,0x28,0x1A,
	0x38,0x85,0x3B,0x13,0x89,0x46,0x76,0x76,0x28,0x98,0x07,0xDD,0xE2,0x51,0x31,0x2F,0x51,0x36,0x26,0xB2,
	0x64,0x55,0x60,0x1C,0x65,0x7B,0x5F,0x00,0x6A,0x31,0x73,0x7D,0x11,0x35,0xC9,0x74,0x11,0xFF,0xC4,0xFC,
	0xAB,0x81,0x45,0xB3,0x59,0x87,0x4F,0x00,0xA2,0xE3,0xBB,0xAA,0xD2,0x84,0x9F,0xED,0xC6,0xA8,0x59,0xD7,
	0x8A,0x22,0x13,0x0C,0x0D,0xF7,0xD8,0x90,0xB6,0xEC,0xD3,0x55,0xB1,0xA3,0x28,0xA4,0xD8,0xE1,0x24,0x4C,
	0x2C,0xF8,0xE3,0x0D,0x0A,0xB2,0xEC,0xB7,0xE4,0xFF,0x09,0xB2,0x02,0x1B,0x11,0x71,0xB9,0x1D,0x72,0xB4,
	0xED,0x88,0x01,0xBE,0x88,0x66,0xC1,0xBC,0xB4,0x9A,0xD9,0xAE,0x0C,0xD0,0x45,0x03,0x3F,0xA2,0xD0,0x81,
	0x58,0xA4,0xBB,0x2B,0xDB,0xF1,0xBE,0x22,0x09,0x98,0xC1,0xE4,0x4D,0xF8,0x5B,0xD2,0xF2,0x55,0x4E,0x6C,
	0xC0,0x1C,0x30,0x04,0xB3,0x73,0x59,0x58,0x57,0x9A,0xA6,0x69,0x9A,0x24,0x15,0x30,0x08,0x00,0x69,0x9A,
	0xA6,0x69,0x08,0x30,0x28,0x20,0x31,0xA6,0x69,0x9A,0xA6,0x39,0xB9,0xB1,0xB9,0xA1,0xB9,0x9A,0xA6,0x69,
	0x9A,0xB1,0xB9,0x8E,0xAE,0xAE,0xE0,0x47,0xA6,0x69,0xAE,0xD1,0xC9,0x80,0xA4,0xAB,0x0A,0x82,0x3E,0x4C,
	0x49,0x53,0x4F,0xD4,0x81,0x01,0xE6,0x0D,0xFB,0xF8,0x8C,0xF4,0x76,0xFD,0xF5,0xF3,0x40,0x12,0x90,0x04,
	0xE8,0xED,0xE6,0xE9,0x05,0x96,0x3D,0x15,0xFC,0x51,0x8B,0xD4,0x92,0x24,0x49,0x52,0xD6,0xD3,0xCF,0xCE,
	0xC4,0xB6,0x42,0xFD,0x49,0xC1,0xC0,0x21,0x07,0x8A,0xB0,0x3E,0x6B,0xCC,0x91,0x3B,0xE5,0x1D,0x18,0x00,
	0x10,0x73,0xB7,0xE7,0xC9,0x25,0xD4,0xAD,0xCD,0x23,0xD3,0x56,0xC1,0xA9,0x1B,0x9D,0x04,0x57,0x35,0x50,
	0x9B,0xE6,0x91,0x3C,0x7E,0xA5,0x9A,0x63,0x09,0xAB,0x77,0x6E,0x70,0x15,0xD7,0x4A,0x0C,0xE2,0x87,0xD2,
	0xB5,0xCA,0x72,0x29,0x5F,0xB7,0xF1,0x5D,0xC0,0x83,0x45,0xAA,0xAA,0xC6,0xB9,0x12,0x61,0xEE,0x44,0x87,
	0xC5,0x72,0x21,0xA5,0x68,0x78,0xBA,0xCA,0xA1,0x02,0x74,0x55,0x41,0x58,0x1D,0x9B,0x58,0x9D,0x5C,0x03,
	0x0F,0x6C,0x3E,0x5D,0x5D,0x4C,0x8D,0x80,0x24,0x54,0x1C,0x4F,0x20,0x69,0x05,0x5F,0x40,0xF1,0xA8,0xF6,
	0x19,0x63,0x4D,0x5D,0xB5,0x70,0x6A,0xD5,0x0F,0x16,0x97,0x0B,0x5B,0x92,0x9C,0x5A,0x3C,0x00,0x56,0x8F,
	0x5D,0x55,0xFD,0xA6,0x8B,0x90,0x0B,0xFF,0xE0,0x9A,0x08,0x7A,0xC1,0x8E,0xE1,0xC4,0xD9,0x1D,0xFC,0x3F,
	0x92,0x2D,0xA6,0x2E,0x38,0x98,0xA0,0xB6,0x8B,0x2A,0xC2,0x73,0xDE,0xCB,0xD6,0x23,0x47,0x46,0x9A,0xB3,
	0xE3,0x51,0x99,0xEA,0xC2,0x09,0xE2,0xC3,0xBA,0x0D,0xE8,0x02,0x0B,0xB6,0xDE,0xA7,0xB1,0x61,0x97,0x2A,
	0xCA,0xD0,0xBB,0x84,0x18,0x15,0xCD,0x3F,0x5F,0xCF,0x07,0x95,0x5B,0x6A,0x84,0x76,0x0C,0x66,0x1A,0xA0,
	0xDA,0x84,0x7B,0xB8,0x58,0xFD,0x88,0x36,0x40,0xB5,0x06,0x94,0x34,0x2F,0x71,0x37,0x55,0xE6,0x28,0x74,
	0x95,0xF2,0x10,0xF7,0xA1,0x93,0x6A,0xF4,0xFA,0xF1,0x71,0x2B,0x84,0x78,0x2D,0xBF,0x85,0x58,0x3D,0x5B,
	0xFB,0x88,0x3C,0x9C,0x32,0xF7,0x7D,0x38,0xB1,0x3E,0xB2,0xB7,0xBA,0xBC,0x13,0xC2,0xF8,0x7F,0x26,0xAB,
	0x27,0x5E,0xA9,0xCE,0x6D,0xCB,0x65,0x57,0x91,0xFB,0x97,0x3B,0x95,0xCB,0x60,0x1E,0x13,0x62,0xB9,0xC7,
	0x59,0xED,0xC2,0x8A,0xBF,0xFE,0x7D,0x5C,0x19,0xCC,0x22,0x4E,0x74,0xDE,0xF5,0x3E,0xC4,0xB0,0x65,0x8F,
	0x03,0xB2,0x0F,0x80,0xC4,0xB8,0x60,0x00,0xDE,0xD9,0x89,0xD6,0xA2,0xDA,0x56,0x90,0xD8,0x3F,0x57,0x7B,
	0xE7,0x02,0xE3,0xA9,0x5A,0x39,0x06,0x44,0x4F,0xDE,0x60,0x60,0x54,0xB3,0x4F,0x50,0x3D,0xC6,0x2C,0xBF,
	0xBC,0x46,0xA2,0xA0,0x14,0x0C,0xB3,0xA2,0xCB,0x82,0x51,0x0A,0x22,0x01,0x9E,0xC5,0x46,0xFF,0x2B,0x73,
	0x1F,0x39,0xB8,0xF1,0x72,0xF0,0xB9,0xFB,0xC9,0x77,0x5E,0xA6,0x23,0x30,0x6B,0xB8,0x3D,0x95,0x1B,0x3A,
	0xE8,0x01,0x09,0xFA,0x64,0xE2,0x2D,0x64,0x2F,0xDE,0xB6,0xC1,0x16,0xBA,0x94,0xD6,0x5D,0xDC,0x1F,0x62,
	0x1D,0xB9,0x80,0x23,0x1C,0xB2,0x2E,0x3C,0x42,0x81,0xC2,0x75,0x6C,0xE4,0x0E,0xCB,0x3F,0xD4,0x2D,0xD8,
	0xB2,0xB9,0x0D,0x51,0x3A,0x56,0x0F,0x2A,0x8C,0xFD,0xB9,0xBC,0x6A,0xB0,0x84,0x44,0x21,0x67,0x5A,0x98,
	0xA4,0x40,0x14,0x67,0x2A,0x00,0x46,0x7A,0x69,0x17,0x9B,0xFF,0x22,0x7E,0xD4,0x07,0x78,0x05,0xFB,0x57,
	0x0D,0xC6,0xE7,0x29,0x3B,0xD2,0xA1,0xEA,0x76,0x20,0x60,0x18,0x29,0xAA,0x59,0x88,0x01,0x89,0x7F,0x50,
	0x96,0x61,0x09,0xAE,0xDE,0x5E,0xE7,0x66,0x47,0x9D,0xD6,0x31,0xD8,0x89,0xF5,0x9B,0xFF,0x53,0x99,0x19,
	0xC2,0x65,0x72,0x99,0xFE,0xB5,0xC2,0xBE,0x4E,0x50,0xF0,0x82,0x1C,0xAD,0x5D,0x15,0x29,0x91,0xBA,0xDD,
	0x38,0x3C,0x32,0x44,0xF3,0xE5,0x1D,0xC6,0x90,0xC5,0x00,0x3F,0x86,0x83,0x41,0x27,0xEB,0x67,0xFE,0x1F,
	0x5C,0x24,0x42,0xDF,0xEB,0x70,0x47,0x40,0x7E,0x22,0x83,0x58,0xDA,0x68,0x6B,0xC0,0x68,0xAF,0x14,0x58,
	0xDC,0x1B,0x0E,0x89,0x5D,0x10,0x6E,0x49,0x32,0x15,0xAE,0x03,0xD3,0x9B,0x10,0xC1,0x2D,0x1A,0x58,0x1E,
	0xFA,0x27,0x5E,0xAD,0xC1,0xC1,0x5C,0x55,0x70,0xE1,0x2C,0x5F,0x57,0x56,0x69,0xC9,0x24,0xFB,0x1B,0x48,
	0x5E,0xAC,0xA3,0xA2,0xE2,0x17,0x2F,0x55,0x3C,0xA1,0x8B,0xCB,0x81,0x80,0x0B,0xA2,0xBF,0x68,0x18,0x1C,
	0xA7,0xD7,0xA4,0x85,0xE5,0xB3,0x45,0xE9,0x68,0xD3,0x14,0x93,0xA7,0x1D,0xA9,0xF8,0x4D,0xE7,0xDD,0xF8,
	0xDE,0x34,0x31,0x24,0x83,0xD9,0xD6,0xCA,0x13,0x09,0xC2,0x33,0x80,0xD6,0x47,0x55,0x49,0x21,0xD8,0x04,
	0xAC,0x5D,0x93,0x24,0x24,0x09,0xA2,0x41,0xB4,0x49,0x79,0xE9,0xDD,0xBA,0x12,0x6C,0x3B,0x36,0xAA,0x2E,
	0xB4,0xCE,0x0C,0x16,0xA9,0x6F,0xFB,0x94,0x93,0xC5,0xF3,0xD6,0x82,0xD1,0xDC,0x9A,0x2F,0x7C,0x11,0x99,
	0x3D,0xBA,0x25,0x89,0x01,0x71,0x8D,0x6F,0x09,0x95,0xFB,0xE5,0x98,0x84,0x3B,0x28,0x92,0x03,0x4A,0x4F,
	0x4A,0x91,0x58,0x95,0x65,0x54,0x4A,0x4F,0xD5,0x63,0x5E,0x8E,0xDF,0x55,0xA6,0xA5,0x06,0xF4,0xD5,0x72,
	0x5D,0x0C,0xE5,0xBA,0x90,0xC6,0xC1,0x00,0x43,0xA3,0x55,0x22,0x48,0x32,0x1E,0x79,0x21,0x01,0xA2,0x22,
	0x70,0xA2,0x20,0x2A,0x88,0x1E,0xD7,0xCC,0x12,0xE2,0x82,0x18,0xC3,0xDA,0xD9,0xA4,0x88,0x82,0x1C,0xAA,
	0x0D,0xA7,0xEE,0x40,0x92,0x09,0x9E,0xB0,0xE0,0x24,0x11,0x24,0x45,0x29,0x8F,0xD2,0x80,0xDC,0x8F,0x11,
	0x24,0x11,0x93,0xD6,0x64,0x37,0x77,0x9A,0x94,0x7E,0x2D,0xFF,0x43,0x84,0xBD,0x77,0xED,0x20,0x42,0x41,
	0x18,0x66,0x7F,0x96,0xE0,0x0E,0x59,0x17,0xA3,0xF8,0xD7,0xCE,0xF2,0x1F,0xB0,0x28,0x2A,0xF9,0x31,0x58,
	0xEA,0x9A,0x85,0xAC,0x19,0xBD,0x3C,0x52,0x89,0x3F,0x61,0xAE,0x25,0x3E,0xD5,0xC8,0xFF,0x48,0x28,0x1E,
	0x63,0x55,0xC0,0xF1,0xD7,0x4D,0x35,0x84,0x61,0xE0,0x96,0x90,0xE8,0xC4,0xAB,0x0A,0x30,0x88,0xCF,0x03,
	0x12,0x49,0x64,0x07,0x22,0x78,0x2E,0x72,0xBD,0xFB,0xE4,0xA9,0xEB,0x64,0xD5,0x0D,0x95,0x33,0x13,0xF5,
	0x50,0x76,0x77,0x0E,0x7E,0xED,0xBB,0xC0,0x2A,0xA3,0x3D,0x5D,0xA7,0xE7,0xB1,0x1A,0x5D,0x8D,0x99,0xD1,
	0xD5,0xEC,0x87,0x2D,0x97,0xDD,0xAB,0x56,0xE3,0xBE,0x86,0x3A,0xCA,0x2E,0xA3,0x5D,0x7D,0x96,0xD8,0x57,
	0xC4,0xB3,0xF9,0x30,0xF0,0xC9,0xA8,0x95,0x7C,0xD7,0x44,0xBC,0xA0,0x03,0x37,0x96,0x7A,0x21,0x5C,0x0C,
	0xF3,0xAE,0x9C,0x43,0xC1,0x75,0xB0,0x3A,0xCC,0x79,0x45,0x18,0xBA,0x4A,0xB2,0x97,0x4B,0xBC,0xF1,0x55,
	0x63,0xE7,0xE5,0xDE,0x57,0xAD,0x47,0xD2,0xE9,0x53,0x57,0x5E,0x2C,0x69,0x5A,0x5F,0x37,0xBE,0x60,0xA0,
	0xA0,0x25,0x51,0x75,0xB1,0x7F,0x0B,0x5E,0x92,0x24,0x55,0x7A,0x0C,0x63,0x15,0x01,0xAF,0x43,0xF3,0x11,
	0xA6,0x5A,0x19,0xAF,0x2F,0x48,0xA5,0xD7,0x59,0x49,0xAB,0x72,0x93,0x25,0x6D,0xF5,0x4B,0x68,0xFF,0x59,
	0xE8,0x42,0x59,0x5D,0xB5,0xDE,0x2F,0x89,0xC6,0xF2,0x71,0xB2,0xD6,0x0E,0x70,0x4A,0xEA,0xC7,0xA2,0xD4,
	0x05,0xCE,0xDD,0x00,0xA2,0xA4,0x68,0x60,0x11,0xE7,0x6D,0xC9,0xDB,0xC6,0x52,0x05,0x26,0xB5,0xE5,0xC6,
	0xFB,0x49,0x92,0x24,0x49,0xD4,0xF1,0xDA,0x83,0x84,0xF9,0xFA,0x01,0x37,0x25,0xF2,0xF3,0x8C,0x65,0x60,
	0x06,0x80,0xBC,0x0C,0xD6,0x19,0x55,0x86,0xBC,0x4D,0x6B,0xA1,0xEE,0x20,0x60,0x6A,0xF9,0x22,0x54,0xEA,
	0xF2,0xAB,0xF4,0x2E,0xC8,0x7E,0xE9,0xEE,0xEE,0x02,0xFE,0x32,0xA8,0xE4,0xCD,0x87,0xBE,0x68,0x55,0x85,
	0x0C,0x71,0x19,0xA7,0xA9,0xA6,0x9B,0x75,0x60,0x21,0xAD,0xBA,0x92,0x18,0x1C,0xED,0x67,0x71,0x5A,0x2E,
	0x91,0x9B,0x26,0xDA,0x15,0x5E,0x40,0x85,0x6B,0xB5,0x3C,0x47,0xD8,0x55,0xA5,0x46,0x13,0x20,0x76,0xC2,
	0x45,0x83,0x38,0x16,0x20,0x3D,0xEA,0x35,0x03,0x3D,0x35,0x63,0x07,0x16,0x57,0xBF,0xD6,0x82,0x75,0x70,
	0x0D,0x6F,0x98,0xD0,0x25,0x11,0x8A,0xDA,0xE1,0x05,0x3D,0x0D,0x09,0x4C,0x27,0x63,0x99,0x75,0xBF,0xC0,
	0xBA,0x8F,0xA6,0x00,0x7D,0xE2,0xC2,0xFD,0xB5,0x59,0xD2,0x95,0x81,0x67,0xE5,0x0D,0x3F,0xCC,0x06,0xFB,
	0x38,0xEA,0x1F,0x66,0x25,0xF7,0x43,0x67,0x6D,0xD5,0x59,0x38,0x46,0x2B,0xA0,0xF1,0x9B,0xCC,0xFF,0xCB,
	0x16,0xF1,0x9D,0x56,0x24,0x9C,0xAA,0x9A,0xB6,0xAF,0x95,0x07,0x33,0x7C,0x6B,0x90,0x01,0x68,0x6F,0x64,
	0x5C,0x0F,0xBF,0xBC,0x2B,0x43,0x7C,0x7A,0xDF,0x01,0xFF,0x1A,0xF6,0xA8,0x48,0xFA,0x59,0x06,0x41,0xFE,
	0x99,0x0B,0xC8,0x12,0x57,0x66,0xBB,0x5A,0xFD,0xE2,0xDE,0x78,0xA0,0x64,0xE7,0x24,0x14,0x20,0x61,0x0A,
	0x11,0xCA,0xBD,0x57,0xE4,0xA8,0xCD,0x16,0xA2,0x63,0x1A,0x55,0x15,0x79,0x58,0x59,0xAA,0x0C,0x9A,0xD4,
	0xC0,0x42,0x86,0xAD,0x2F,0xE1,0xB4,0x65,0xC4,0x8C,0xD1,0xD0,0x01,0x53,0x34,0x30,0x54,0x95,0x2F,0xF9,
	0xE4,0x5F,0xAC,0x60,0x62,0x8D,0xD0,0xBB,0x38,0xAC,0x6A,0xF8,0xF0,0x47,0xAF,0x66,0x0B,0x97,0xE2,0x20,
	0x56,0x13,0xF2,0x31,0x29,0xF2,0x50,0xD5,0xD8,0xC5,0xC7,0xFE,0xE4,0x39,0x45,0x8B,0x85,0x48,0xDD,0x49,
	0x8C,0x8C,0x18,0xB5,0xF1,0xB3,0xD9,0x0B,0xA2,0x20,0x9F,0xA7,0x50,0x44,0x41,0x27,0xBB,0x76,0x5D,0xE2,
	0xC0,0xC2,0xB0,0x77,0xF7,0x9F,0x1C,0x39,0x68,0x23,0x6B,0x41,0x46,0x9E,0xBE,0xEC,0x5B,0x6D,0x5C,0x75,
	0x53,0xCC,0xAC,0xFB,0x34,0x42,0xB2,0x64,0x45,0x47,0xC9,0xCE,0xAC,0x66,0x0A,0x90,0xB4,0x31,0x92,0x21,
	0x24,0x86,0x2D,0xC8,0x16,0x88,0x27,0xC3,0x00,0x68,0x20,0x88,0x5F,0x3F,0xCC,0xC8,0x99,0x4B,0x05,0x0C,
	0x69,0xFE,0x8B,0xB9,0x2D,0x4B,0x75,0x12,0x7F,0x4E,0xCD,0xE4,0x81,0x45,0xAE,0xCA,0x59,0x29,0x45,0xF9,
	0xDD,0xDB,0xAC,0x34,0xD7,0x28,0x25,0x24,0xD7,0xF8,0xBB,0x15,0x7A,0x16,0xE4,0x95,0x28,0xE7,0x9A,0xD7,
	0x3F,0x50,0xFA,0x8A,0xE4,0xDE,0x8C,0xBD,0x77,0xE9,0xF4,0x3B,0xAC,0x09,0x6E,0xB1,0xD3,0x5B,0xA8,0xB9,
	0x5C,0xA2,0xAE,0x67,0x57,0x09,0x33,0xB8,0x13,0x05,0x61,0x08,0x38,0xAD,0xDA,0x7B,0xD4,0xE7,0x85,0xC5,
	0x46,0xAA,0xEB,0xF4,0xE6,0xC5,0x7D,0x12,0xDF,0x8B,0x58,0x6A,0x17,0x54,0x0D,0x23,0xBA,0x2C,0x53,0x05,
	0x6A,0x31,0x4B,0x22,0xFA,0xAC,0x46,0x4C,0x59,0x33,0x38,0x41,0x18,0xB1,0x32,0x76,0x9D,0xCD,0x33,0xC5,
	0x5E,0xE8,0x06,0xC4,0x8E,0x8D,0xEA,0xEF,0x55,0xD1,0x63,0x2D,0x33,0x9D,0xA0,0x18,0x10,0xA4,0x3B,0x09,
	0xD3,0x42,0x3C,0x4F,0x6D,0x52,0x2C,0x08,0x35,0x2F,0xF3,0x89,0xBD,0x93,0xE1,0x17,0x7B,0x09,0x99,0x80,
	0x84,0x75,0x0B,0x70,0xE7,0x9C,0xE9,0x31,0x79,0xFD,0x67,0x6E,0x5A,0x7C,0x91,0x1C,0x94,0x7D,0xA5,0xEF,
	0x66,0xB8,0x9A,0x4C,0xD9,0x08,0xFF,0x11,0xA9,0xB0,0x20,0x30,0xE8,0xAB,0x6D,0x50,0x7D,0x0E,0x7E,0x45,
	0x52,0xEA,0xC4,0x8E,0xC2,0x93,0x04,0x44,0x49,0x47,0x08,0x30,0xFE,0xC8,0xB4,0x4C,0x7E,0x93,0x54,0x61,
	0xDA,0xAB,0xE5,0xC4,0x9A,0xB8,0xAC,0x19,0x10,0xB1,0x28,0xF4,0x87,0x09,0x26,0xC8,0x91,0xB6,0x8C,0xB1,
	0x0A,0x60,0xDC,0x71,0xD7,0x5A,0xDB,0x21,0x74,0x04,0x15,0x07,0x65,0x9B,0x00,0xED,0x62,0x99,0x45,0xCB,
	0x7F,0x11,0x45,0x0C,0x3B,0x40,0x65,0xC9,0x1D,0x70,0x17,0xB0,0x15,0x22,0xC5,0xD7,0x8D,0xF0,0x1B,0xBB,
	0x81,0x47,0xD7,0xF8,0xC0,0x55,0xEA,0x49,0x42,0x12,0xFB,0x47,0xC9,0xEB,0xF5,0xA8,0x0A,0x04,0xC4,0x50,
	0xF1,0xE8,0x27,0x41,0xEF,0x89,0x2F,0xBA,0x6E,0xF1,0xF5,0xBF,0xD7,0x59,0xD4,0x1C,0xAC,0xFB,0xC2,0xC0,
	0x40,0xB2,0xC8,0x20,0xD9,0xE2,0x89,0x83,0x10,0x65,0x0B,0x25,0x81,0x5F,0xBB,0x14,0x01,0x79,0xF1,0x86,
	0x52,0x0F,0xBF,0xB2,0xB7,0x4F,0x4E,0xE2,0xFB,0x70,0x86,0xAB,0x41,0x35,0xB6,0x11,0xD6,0xAE,0x19,0xA0,
	0x8C,0xAE,0x1E,0x94,0x7B,0xD0,0xB7,0xB0,0x9C,0xA8,0x96,0x6F,0x05,0x47,0x6C,0x97,0x86,0x24,0xA6,0x82,
	0x22,0x6E,0x57,0x25,0x83,0x26,0x0C,0x96,0xAF,0x72,0x3D,0xDC,0xB6,0x9C,0x8B,0xC0,0x35,0x43,0x70,0x72,
	0xDF,0x99,0x78,0x50,0xE5,0x0A,0xB2,0xB1,0xCE,0x5D,0xBB,0x05,0x4E,0x5F,0xC4,0x77,0xB8,0x29,0xBA,0x74,
	0xE0,0x2E,0xB1,0xB6,0xD5,0xA5,0x50,0x25,0x33,0x65,0x7A,0x75,0x17,0x55,0xB3,0x20,0x4E,0x6E,0x29,0xD5,
	0xF1,0x1A,0xDF,0x4C,0xF2,0xE7,0x32,0x4A,0x07,0x4A,0xED,0x29,0x45,0x4A,0x53,0xA5,0x1F,0x76,0xB4,0x4B,
	0x55,0x83,0xFF,0xBB,0x1F,0x87,0x78,0xDE,0xF5,0xF3,0xDD,0x19,0xBE,0x9E,0x76,0x84,0x8B,0xAE,0xC0,0xB5,
	0x13,0x13,0x76,0x57,0xA4,0x89,0x1B,0xC0,0xCA,0x1F,0x6C,0xF2,0x2A,0x55,0x2D,0xD7,0x9D,0x5C,0xF9,0xB4,
	0xF0,0xA6,0xBF,0x90,0xBB,0xD1,0x3D,0x93,0xED,0xE3,0xF4,0x64,0x02,0x7D,0x92,0xDB,0x9B,0xD3,0x1E,0x75,
	0xBC,0xF4,0x5C,0x98,0x94,0xB9,0xD8,0xD5,0x2D,0xC3,0x45,0xF4,0x37,0x7F,0x84,0xDC,0x0E,0x91,0x06,0x10,
	0x85,0xA5,0xB3,0x8E,0xA1,0x8C,0x75,0x5A,0x9B,0x40,0x5B,0x77,0x8B,0xC2,0x43,0x9C,0xC8,0x6B,0x8F,0x93,
	0x44,0x41,0x30,0xCC,0xB5,0x9B,0x67,0xA8,0xD0,0x0E,0xC2,0x29,0xE7,0xD6,0xB4,0xC7,0x6F,0x27,0xB8,0x31,
	0xD8,0x09,0x07,0xD5,0xD5,0xA6,0x35,0x39,0xCC,0x5E,0x12,0xFD,0x21,0x78,0x51,0xC1,0xBF,0x2B,0x8D,0xD4,
	0x48,0xEC,0x09,0xD6,0x1C,0x7B,0x92,0x8C,0x50,0x55,0x48,0x0C,0x2A,0xE6,0x5E,0x57,0x89,0x1D,0x9A,0x22,
	0x7F,0x83,0xBD,0x24,0x6C,0xCF,0xE1,0x96,0xAB,0x7E,0xF1,0xD9,0x42,0xD4,0x87,0x13,0xA4,0x66,0x03,0x53,
	0xD6,0xFF,0x6D,0x5A,0x19,0x45,0xD9,0xCD,0xD7,0x1A,0x42,0xE5,0x50,0xAD,0xAD,0x56,0x4D,0xC4,0x37,0x26,
	0xAA,0x6B,0x21,0x13,0x9C,0x06,0x2F,0x3C,0x89,0x12,0x75,0xD5,0x8A,0x5B,0xA7,0x24,0x38,0xC3,0x55,0xBF,
	0xAD,0xB8,0xBA,0x50,0xB5,0x02,0x3B,0xA5,0x60,0x6B,0x0A,0xD3,0x63,0x2E,0x87,0x1B,0xE9,0xD6,0x62,0xB8,
	0xA0,0x38,0x1C,0x0E,0xFF,0x00,0x6E,0x65,0x74,0x95,0x1B,0xAC,0x20,0xF8,0x14,0x69,0xF7,0x82,0x2B,0xAD,
	0xD6,0xDB,0x41,0xFD,0xC5,0x52,0x6F,0xAD,0x4E,0x5C,0x85,0x84,0x42,0x22,0x77,0xAE,0x8E,0x2D,0x3A,0x78,
	0x08,0x6C,0x40,0x58,0x0E,0xF4,0x0B,0x9D,0xB6,0xDB,0x07,0x0E,0x4D,0x24,0x40,0x56,0x91,0xF9,0xE1,0xD6,
	0xEA,0x12,0xE5,0xB1,0x1A,0xE4,0x6F,0x23,0xFF,0x74,0xD4,0x3F,0x30,0xC7,0xA5,0x55,0x38,0xD0,0x5D,0x93,
	0xCB,0xBD,0x4A,0x30,0x78,0xA1,0x18,0xCD,0x9A,0x39,0xC7,0x81,0xD0,0xB3,0x23,0x15,0x7D,0x2C,0xD6,0xCC,
	0x4A,0x28,0x33,0xED,0x93,0x6A,0xA3,0x99,0x55,0xE0,0xA7,0x9E,0x30,0x00,0xBF,0xC2,0x86,0xE8,0xAA,0x5E,
	0xEA,0x99,0x6E,0x17,0x00,0xC4,0x62,0x21,0xA7,0x27,0x5F,0x5B,0xD7,0xB3,0x76,0xEB,0xA6,0xEC,0x2E,0x90,
	0xE8,0xB0,0x48,0xD6,0x94,0x54,0x94,0x50,0x55,0xB7,0x5D,0x61,0xD9,0x81,0x4C,0x3C,0x0B,0x99,0x63,0xB5,
	0x67,0x65,0x67,0x60,0xA0,0x0D,0x6D,0x52,0x2D,0x1A,0x67,0xAC,0xF8,0x50,0x8D,0xC4,0x2F,0x8C,0xFE,0x4A,
	0x25,0x3C,0x9C,0xB2,0x03,0x47,0x32,0x62,0x0E,0xAA,0x2C,0x54,0x85,0x08,0x35,0x81,0x57,0x11,0x27,0x3F,
	0x4A,0xA5,0x6D,0xAB,0x51,0xC8,0xE0,0xC4,0xA9,0x5B,0x8A,0x72,0xAC,0xC6,0xA7,0x74,0x5D,0xA5,0x0A,0x69,
	0x85,0x3D,0xC4,0x9A,0x2D,0x5D,0x4B,0xC6,0xAF,0x85,0x17,0x49,0x95,0xDC,0xFE,0xE3,0x9D,0x3F,0xA2,0xDC,
	0x3A,0x0A,0x0F,0x5C,0x95,0x71,0x77,0xF3,0xED,0x45,0xF1,0x15,0xBD,0x84,0x5D,0x8F,0xBC,0x7F,0xFA,0x0B,
	0xA3,0xD8,0x87,0x99,0x0C,0xFD,0x6A,0x9A,0xDB,0xBF,0xF7,0x81,0xFF,0x4F,0x89,0xC6,0xEA,0x0F,0x5A,0x2D,
	0x75,0xB8,0xEB,0x50,0xAD,0x79,0x87,0xB1,0xC9,0x93,0x31,0xAB,0xBA,0xF1,0x2A,0xA5,0x9C,0x41,0x91,0x37,
	0x29,0x8A,0xC1,0xA0,0xA8,0xD1,0xE8,0x13,0xB2,0xC2,0x7A,0xBA,0x20,0x1D,0x47,0x7F,0x96,0x19,0x9E,0x19,
	0xB9,0xFD,0x73,0xF3,0x2D,0x23,0x11,0x5A,0x59,0x55,0x66,0x80,0x89,0x56,0x57,0x47,0x75,0x26,0x86,0x52,
	0x32,0xC1,0x26,0x22,0xF2,0x37,0x78,0x53,0x46,0x7F,0x7D,0x31,0x28,0xBF,0x85,0x49,0x2C,0x94,0xC4,0x42,
	0x41,0xC2,0x7C,0xA1,0x33,0x9B,0xBC,0xCD,0xFA,0x40,0xDA,0xBE,0x24,0x4D,0x17,0x44,0xDF,0x8A,0x75,0x9D,
	0x16,0xAC,0x58,0x9E,0x46,0xAC,0xDA,0xB8,0x9D,0x21,0x45,0x05,0x13,0xC2,0x1D,0xF0,0x50,0x5F,0x58,0x0C,
	0xF4,0x8D,0x8E,0x0E,0x1A,0xD0,0x1F,0x10,0x71,0x6E,0xCA,0x45,0x4F,0xC6,0x02,0x94,0xB1,0x4F,0x33,0x56,
	0x04,0xC0,0xF7,0x11,0xAE,0x4B,0xF7,0x2E,0x77,0x29,0x01,0xCF,0x4E,0x1A,0x7F,0x35,0x5A,0x2A,0x07,0xFD,
	0xDC,0xED,0x8E,0x54,0xBE,0xA7,0xD3,0x75,0x79,0x51,0xBF,0xDE,0xC3,0x9F,0x8A,0x56,0x82,0x64,0xA8,0x0A,
	0x28,0xF8,0xDB,0x53,0x31,0xC9,0xBE,0xA3,0xAC,0x77,0x87,0x8B,0x45,0x89,0x39,0xB4,0x97,0x49,0x49,0xFA,
	0x4B,0xE1,0x76,0xA6,0x22,0xAB,0x88,0xB3,0xFF,0xEF,0x02,0x00,0x26,0xE9,0x93,0x61,0xBD,0x53,0xE2,0xA0,
	0x52,0x4A,0x66,0x36,0x5E,0x2C,0x22,0x82,0x63,0xAA,0x6E,0xF6,0x30,0xA9,0x6C,0x2C,0xC7,0xFC,0xD3,0x1F,
	0x06,0x80,0x8B,0x9C,0xBE,0x45,0xF0,0x9B,0xAA,0x42,0x94,0xAB,0x08,0x17,0x3C,0x72,0xB6,0x1C,0x38,0xF6,
	0xA2,0x91,0xDA,0x56,0xAF,0xC8,0xC6,0xE6,0xE3,0x30,0xED,0xC1,0xBB,0x2E,0x62,0xA8,0xD7,0x21,0x0B,0x70,
	0x94,0x10,0x09,0x38,0x4B,0xD3,0x53,0x32,0xA7,0x10,0x07,0x6E,0xB7,0xF5,0x81,0xB4,0xA6,0x17,0x7D,0x85,
	0xAE,0x37,0xC3,0x8E,0xB7,0xFD,0x45,0x2F,0xA2,0x6F,0xAF,0xDB,0xA6,0x1C,0x6B,0x25,0xF4,0xAA,0x04,0x1C,
	0xD6,0xFB,0x9C,0x61,0x63,0x35,0x08,0x81,0x1E,0x69,0x07,0x98,0x3E,0xAB,0xDD,0x20,0x76,0x55,0x9B,0x1A,
	0xE4,0xAA,0xC1,0xD1,0x42,0x8A,0x57,0x61,0xF0,0x22,0x26,0x8D,0x71,0x2A,0x7F,0x4C,0x5D,0x87,0x15,0xF9,
	0xBF,0x6C,0x1C,0x80,0xE8,0x54,0x61,0x57,0x95,0xD1,0xD9,0x53,0x13,0xA0,0xDA,0x7B,0x70,0x57,0xC1,0xA9,
	0xB9,0xCE,0xC8,0x03,0x98,0x81,0x3D,0x3A,0x50,0x95,0x62,0x9C,0x88,0xE1,0x8A,0x35,0x76,0xB2,0x23,0x8D,
	0x82,0x1B,0x80,0x5E,0x54,0xDD,0x81,0xA5,0xA5,0xF1,0x51,0x74,0x4C,0x1F,0xD6,0x6F,0x56,0x06,0x1B,0x44,
	0x1F,0xC5,0x39,0xD1,0x05,0xEB,0xC1,0x51,0x60,0x26,0x17,0xC6,0x14,0xC4,0x34,0x38,0x88,0xA7,0x15,0xFD,
	0xCF,0xEF,0xA9,0x8B,0x45,0x57,0x50,0x27,0xE3,0x5E,0x8E,0x81,0xF6,0x47,0xD9,0x69,0xDB,0xE4,0x9E,0x48,
	0xD0,0xAB,0xC5,0xDE,0x06,0x33,0xF6,0xB6,0x47,0x12,0x6E,0xCA,0x8D,0x6A,0x57,0xDB,0x63,0xEC,0x74,0x57,
	0x9A,0x1E,0x11,0x9A,0x32,0x2D,0x67,0x17,0x7E,0xEA,0x77,0x00,0x08,0x48,0xEB,0x6D,0xAB,0x53,0x27,0x39,
	0x1F,0x4D,0xFA,0x32,0xC6,0x42,0x8D,0x72,0x27,0x96,0xF5,0x62,0x2C,0xA9,0xA0,0x30,0x71,0xCD,0x98,0x19,
	0xE8,0xCC,0xF0,0x2C,0x9D,0x86,0x90,0x66,0xDF,0xB4,0x22,0xE9,0xDF,0x95,0xB1,0x20,0xA4,0x26,0xCB,0x4A,
	0xDF,0x94,0xF4,0x5C,0xDE,0x67,0x36,0x31,0x03,0x0A,0x94,0x08,0x7A,0x51,0xCD,0x40,0x07,0x1E,0x4A,0x2C,
	0x7E,0xFC,0x83,0x1D,0xA5,0x6D,0xCE,0x4A,0xA7,0x91,0x5A,0x52,0x1C,0xFE,0x19,0x56,0x5D,0xAE,0x55,0xD7,
	0x45,0xFF,0x40,0x96,0x71,0x87,0x0D,0x93,0x39,0xF8,0xB3,0x0E,0x20,0x77,0x00,0x5D,0xA2,0x19,0x73,0x49,
	0x99,0x37,0x5C,0x9D,0x85,0x2A,0x5B,0xC8,0x6A,0x63,0x83,0xA4,0x10,0x65,0x36,0x58,0x10,0x6C,0xC4,0xBD,
	0x72,0xE5,0xCC,0xF8,0x16,0x6D,0x60,0x90,0x69,0x2E,0xDB,0x05,0xFB,0x0B,0x98,0x91,0xB4,0x20,0xD7,0x14,
	0xD1,0x90,0x69,0x0F,0x5A,0xB0,0x64,0x7D,0xDA,0x12,0x67,0x2A,0xAB,0xAE,0x83,0x9F,0x6C,0x69,0xD9,0x7C,
	0x7F,0x35,0x70,0x0E,0xCD,0xB1,0xEC,0x85,0x47,0x1D,0x16,0xA8,0xC3,0x3E,0xD5,0x67,0xD4,0xC6,0xD5,0x24,
	0xC8,0xEB,0x41,0xFB,0xAD,0xAF,0xD4,0xA5,0xB1,0x34,0x49,0x0B,0x32,0x72,0x07,0xB5,0xC4,0xAC,0x45,0x9A,
	0x69,0x7F,0x5F,0xB4,0x5F,0x6B,0xB6,0x07,0xA3,0x15,0x43,0xD1,0x7E,0x4B,0x73,0x49,0xB4,0xD2,0xFA,0x50,
	0x24,0xA9,0xBC,0x5A,0x8A,0xD7,0x3D,0xCA,0x6A,0xEE,0xA2,0x52,0xEC,0xC9,0x89,0x86,0x0E,0xC9,0x42,0xC1,
	0x1D,0x69,0xB5,0x16,0xAE,0xE1,0xB8,0x0F,0x72,0x2A,0xE5,0x98,0x57,0xD9,0x73,0x0D,0x5C,0xF2,0x78,0x06,
	0xB0,0x62,0xC0,0x65,0x33,0x1D,0x65,0x0A,0x1A,0x59,0x51,0x28,0xB4,0x53,0x89,0xAD,0x42,0xB0,0x01,0x47,
	0x14,0xCA,0xF1,0x4B,0x3C,0x56,0x26,0x92,0x15,0x45,0xFD,0x43,0xC2,0x59,0x3F,0x7F,0x7B,0x45,0x5A,0xD8,
	0x4C,0xC7,0x36,0x26,0x6A,0x4D,0x74,0x2A,0x4C,0x38,0x03,0x7F,0xE1,0xFC,0xEB,0x40,0x6C,0xE8,0x94,0x5B,
	0xED,0xC4,0xCA,0x25,0xEA,0x87,0x4D,0xB8,0xBF,0x40,0x16,0x08,0x09,0x56,0x0B,0x9B,0x4B,0xD0,0xC3,0xF5,
	0xFE,0xF3,0x3D,0x0E,0xF8,0x7E,0xA7,0x05,0x31,0xE9,0x19,0xAB,0xCC,0x0E,0xFB,0x8F,0x90,0xE2,0x97,0xC1,
	0xF4,0x23,0x24,0x43,0xF6,0x25,0x88,0x84,0x56,0xD4,0x38,0x0A,0xC1,0x92,0xC5,0xD3,0x88,0xCF,0x05,0x1D,
	0xD1,0x8A,0x4A,0x0A,0xC5,0x25,0x9A,0x4D,0xDC,0x7D,0x2E,0x2B,0xAD,0x80,0x77,0xF1,0x6C,0x0F,0x35,0xCB,
	0x4A,0x95,0x62,0xBA,0xDB,0x51,0xD5,0x75,0xEA,0xAB,0x76,0xF9,0xAA,0x29,0x61,0x86,0x52,0x55,0x03,0x22,
	0xA7,0xA8,0x25,0xD8,0xD0,0x20,0xC7,0xBF,0x6F,0x7D,0x62,0xA0,0x73,0x2F,0x4A,0x6E,0xFB,0x2C,0x70,0xF8,
	0x24,0x51,0x52,0xCD,0x9E,0xD7,0x51,0x0A,0x06,0xDA,0x16,0x7F,0x62,0x19,0x7A,0x71,0xA7,0x6D,0x2F,0x40,
	0x54,0x27,0x5C,0xBE,0x72,0xFB,0xEC,0x2F,0x3B,0xA5,0x93,0x92,0x30,0x41,0x0D,0x41,0x4D,0x52,0x18,0x62,
	0x3B,0x47,0xAB,0x27,0x3A,0x27,0xA3,0x30,0xEA,0x0B,0x66,0x06,0xEB,0x64,0xEA,0xC8,0x0C,0x69,0x27,0x64,
	0x5D,0x48,0x26,0x8A,0xCA,0x9C,0xE1,0xBC,0x6B,0xC7,0xDF,0xAA,0x6A,0x4E,0xA8,0xAF,0x2F,0x0D,0xED,0xFF,
	0x11,0xD8,0xAA,0x4A,0xAF,0x03,0x73,0x46,0x15,0xE8,0x81,0xEB,0x2E,0x0D,0xBA,0xD5,0xF0,0x82,0x7A,0x9E,
	0xAF,0x7F,0x7E,0x5D,0xE2,0x26,0xDB,0x15,0x90,0xB2,0x7E,0x4C,0x19,0x2A,0xA5,0x98,0x61,0xD1,0xF7,0x23,
	0xA2,0xC3,0x0C,0x35,0x3A,0x35,0xDB,0x7A,0x7F,0x2A,0x88,0xCE,0x7F,0xAD,0x16,0x5B,0x3F,0xCD,0xAE,0x79,
	0x94,0xF4,0xB9,0xAF,0x50,0x0A,0x6A,0x03,0x8D,0xE3,0xF7,0xC4,0x12,0xE4,0xAA,0x78,0xD0,0x40,0x9D,0x61,
	0xE4,0xC5,0x5E,0xB6,0x64,0x8A,0xC4,0xFD,0xC5,0x9D,0x2C,0x10,0xAD,0xCF,0x7E,0x14,0x2F,0xEE,0x8F,0x14,
	0xA6,0x77,0xAE,0x8F,0x09,0x1A,0x59,0x89,0x2F,0x41,0x59,0x1D,0x02,0x50,0xAA,0x72,0xCA,0xFA,0xA0,0x1A,
	0xB2,0x6A,0xF8,0x0E,0x43,0xA1,0xAD,0x1C,0x62,0x85,0xDB,0xA1,0x44,0x66,0xEC,0x50,0xBA,0x11,0xDF,0xC6,
	0x3D,0x59,0x14,0xA1,0x59,0x50,0x94,0x5C,0x99,0x61,0xBB,0x38,0x2D,0x47,0x61,0x2C,0x40,0x08,0x16,0xA1,
	0xD8,0xE7,0x1E,0xEC,0x6D,0x34,0x2A,0xEB,0x72,0x2B,0x13,0xD0,0x7F,0x2C,0x1C,0x2C,0x87,0x66,0xB1,0xED,
	0x12,0xFA,0x2F,0x13,0xFD,0xB7,0xAF,0xD6,0xDA,0xB2,0xB0,0xAB,0x86,0xF2,0x91,0xC9,0x43,0xD3,0x7F,0x0D,
	0xD5,0x88,0x75,0xAF,0xE3,0xBC,0xAE,0x78,0xC1,0xF3,0xB3,0xE4,0x30,0x65,0x08,0x30,0xEB,0x45,0xD2,0x55,
	0x9C,0x3D,0x02,0x5A,0xCC,0x71,0x17,0x5E,0x07,0xE4,0x5E,0x1F,0x74,0xFF,0x0E,0x5F,0x7F,0x77,0x48,0x66,
	0x54,0x26,0x31,0x3C,0xCC,0x5D,0xF5,0xD2,0xE5,0x56,0xFF,0x6A,0x8D,0xB7,0xFB,0xD2,0xB5,0x7C,0x0E,0xF1,
	0x74,0x5F,0xB8,0xEF,0x4E,0x16,0xAE,0x38,0x78,0x98,0x22,0x96,0x0C,0xBB,0xDC,0x15,0x29,0x4C,0x74,0x18,
	0x9E,0x23,0xB5,0xE4,0x58,0xE7,0xEA,0x0E,0xC6,0xC0,0xF0,0xBB,0x38,0x2A,0xD1,0x72,0x25,0x68,0x3A,0x7F,
	0x7A,0xF6,0x01,0x4B,0x94,0x8B,0x34,0x30,0xE6,0x21,0xC8,0xA7,0xB9,0x60,0xC8,0x47,0xCB,0xE0,0x1D,0x36,
	0x93,0x19,0x7F,0x2D,0x76,0xF8,0x0E,0x5C,0xA0,0xAA,0x04,0x6F,0x89,0x3E,0xAA,0xBF,0x5D,0x95,0x0F,0x21,
	0xD0,0x1E,0x6C,0xEB,0x14,0x3D,0x17,0xED,0x9A,0xC1,0xCB,0x76,0x59,0xC8,0xDB,0xD4,0xE9,0xED,0x1E,0xEF,
	0xB2,0xC0,0x2A,0x93,0x90,0xCA,0x72,0x1F,0xD6,0xD0,0x99,0x27,0xC5,0x1B,0x7F,0x7D,0x83,0x32,0xE2,0xC4,
	0x77,0x13,0xB2,0x0B,0x58,0xDA,0xF7,0x4C,0x2D,0x9D,0x4A,0x2B,0xD4,0x2C,0x7D,0x9F,0xB1,0xD9,0x4D,0xCF,
	0xFE,0x5F,0xC3,0x34,0xC4,0xDD,0x14,0x21,0xF0,0x7C,0x74,0x57,0xE5,0x07,0x9A,0x7C,0xF8,0x35,0x57,0xA8,
	0x05,0x4F,0xCD,0x1D,0x0C,0xC8,0xE2,0x68,0x2C,0x61,0xAF,0xE1,0xC6,0x3B,0x32,0x63,0x7A,0x37,0x9D,0xCC,
	0xB8,0x72,0x55,0x17,0x5D,0x79,0x9B,0xC7,0xCE,0x7C,0xF9,0x02,0xBC,0xE5,0x1D,0xC8,0x10,0xC7,0xB3,0xB1,
	0x2A,0xB7,0xD5,0xF2,0xB9,0x9B,0x6C,0xF8,0x5D,0xA4,0x60,0x26,0xA7,0xA5,0x32,0x2D,0x18,0xF2,0xA1,0x6F,
	0x62,0xBD,0xFA,0x3D,0xB0,0x0B,0xC6,0x45,0x54,0x92,0x62,0x49,0xA4,0x38,0xEC,0x67,0x1F,0x34,0xC1,0x78,
	0x1A,0x31,0x20,0xE2,0xFA,0x87,0xFE,0x07,0x69,0xEF,0x32,0x42,0xFA,0xBD,0x6B,0x24,0x66,0x42,0xAA,0x6A,
	0xB6,0x04,0xFC,0xF9,0xE5,0x9F,0x45,0x00,0xDE,0x1F,0x8E,0x0E,0xCB,0xE3,0xAA,0xF9,0x90,0x57,0x14,0x5F,
	0xD1,0x93,0x8E,0xEB,0xDF,0xDE,0x2A,0xA6,0xD1,0x9D,0x48,0x69,0xE1,0xE0,0xA3,0x02,0x49,0x6A,0xC1,0x4F,
	0x02,0xE3,0x73,0xB8,0x55,0xA6,0x3D,0x8A,0x31,0x7C,0xAE,0x00,0xEA,0xED,0xE2,0xA1,0x2B,0xDE,0x92,0x38,
	0x07,0x3E,0xBB,0xC7,0x31,0xBB,0x30,0xAE,0x4C,0x13,0x2F,0xA9,0xE8,0x1D,0x6C,0x1D,0xDF,0x62,0x70,0x55,
	0xA2,0xD9,0x0F,0x15,0x54,0x82,0x09,0xC1,0x4A,0x2B,0xBE,0xF2,0x92,0xA5,0xFF,0x7A,0x85,0x85,0xC1,0xB2,
	0x76,0x54,0x58,0x08,0x96,0x5F,0xAC,0x08,0x26,0x09,0x59,0x9F,0x45,0x82,0xE4,0x73,0xD8,0xF1,0xDD,0xFA,
	0x40,0x44,0x1C,0xD9,0xF5,0xB2,0xCA,0xF6,0xD8,0x31,0xB1,0x32,0xA8,0x02,0x3A,0xC2,0xA6,0x9E,0x63,0x92,
	0x52,0x75,0x4B,0x8A,0xA1,0x1A,0x0C,0x56,0x56,0xF6,0x10,0x01,0x0C,0x6B,0xE0,0x37,0x0F,0x4C,0xAB,0xAE,
	0xC2,0x16,0x4D,0x68,0x43,0xFD,0x16,0x3A,0x7C,0xA8,0x49,0x55,0x81,0x18,0xDC,0x63,0x18,0x5C,0x36,0x72,
	0x50,0xD8,0xEE,0x63,0x51,0x93,0x75,0xDD,0xEE,0x87,0x7A,0xCA,0x20,0xA9,0xC4,0x2D,0x5A,0xC5,0x26,0x66,
	0x1E,0x93,0x69,0xB0,0xCC,0xEA,0xC2,0xFE,0x70,0xC4,0xDC,0x81,0x7A,0xB0,0x68,0xBC,0xB5,0x48,0x00,0x11,
	0x94,0x81,0x45,0x2A,0x63,0x24,0x9B,0x29,0xDF,0x4D,0x17,0x9E,0xAD,0xA2,0xBA,0x4C,0x6B,0x31,0x99,0x20,
	0x92,0xD3,0x9A,0x28,0x70,0x3E,0xB5,0x08,0xF9,0xCC,0xE4,0x76,0x87,0x80,0x06,0x4C,0xF4,0x02,0x2C,0x02,
	0x4F,0x40,0x92,0x7B,0xAB,0x9F,0xA9,0xFF,0xC6,0xC6,0x04,0x48,0xA8,0xCC,0xC2,0xC5,0xC0,0x2C,0x60,0xD5,
	0x2D,0x5B,0x0F,0x93,0x66,0x81,0xB2,0x31,0x1A,0x4D,0xCF,0xD5,0x3F,0x41,0x85,0x49,0xB3,0x12,0x28,0x9E,
	0x66,0x2C,0xED,0xCE,0xD1,0x1D,0x94,0x31,0xA9,0xA7,0x4D,0x5F,0x44,0xFB,0x15,0x00,0x94,0x8F,0xC0,0x70,
	0x77,0x8B,0x44,0x84,0x27,0x08,0x55,0xF3,0x44,0xD2,0x49,0x9B,0x6B,0xE1,0x32,0x11,0xA1,0x05,0xC4,0xE0,
	0x3E,0x2C,0x16,0xEE,0xE9,0x7F,0x8C,0xBF,0x26,0xA3,0xB0,0x29,0x69,0xB2,0xCC,0x9A,0xEC,0x7E,0xC6,0x7F,
	0x68,0xB9,0xEF,0x4B,0x8A,0x0C,0xCD,0x43,0xB8,0x0E,0x81,0xD6,0x21,0x56,0xF7,0x0A,0x29,0xCA,0x11,0x8E,
	0x94,0x24,0xC7,0x7E,0xB9,0xBF,0x8A,0x2C,0x96,0x2B,0x02,0x7C,0x57,0x09,0x7D,0xD9,0x54,0x6D,0x18,0x59,
	0x72,0x15,0x5D,0x62,0x9D,0x1F,0x1B,0x24,0xB1,0xBD,0xEF,0x7A,0x34,0xE2,0xD5,0x2D,0x09,0xC5,0xDF,0x93,
	0x76,0x77,0xC0,0xA9,0x2D,0xBE,0xF1,0x6B,0xFE,0xE5,0xD3,0x74,0x25,0xE1,0xFC,0x36,0xC1,0x8A,0x86,0xA9,
	0x8F,0x6F,0x8B,0x71,0xD6,0xCF,0xF1,0x9A,0x01,0x09,0x46,0x0F,0x5B,0xDC,0xD5,0xC5,0x07,0x60,0xF2,0x8C,
	0x69,0x6A,0xF0,0xC6,0x8A,0x4B,0x54,0x98,0xCB,0x0B,0x09,0xCC,0xFB,0x60,0x92,0x73,0x01,0xB9,0x7C,0x25,
	0x29,0x2E,0xA0,0x10,0x45,0x2D,0x37,0xA7,0x5B,0x28,0x6A,0x08,0xA6,0x48,0xAE,0x17,0xE4,0x7B,0xD5,0x66,
	0x86,0x93,0x93,0xD4,0x5A,0x83,0x76,0x14,0xCE,0x7E,0x46,0x5A,0x8D,0xA1,0x83,0xA7,0xBF,0x57,0xEF,0x09,
	0x33,0xC8,0xC2,0xD7,0xD6,0xB5,0xD3,0x71,0x11,0x05,0x06,0x26,0x2E,0x60,0xBB,0x6B,0x85,0x03,0x4B,0xC2,
	0xFA,0x98,0x38,0x58,0x75,0x22,0xB1,0xF0,0x28,0x14,0xDE,0x09,0xF5,0x64,0x4B,0x41,0x80,0x72,0xFE,0x23,
	0x24,0x38,0xDE,0xFB,0xDF,0x6C,0xFC,0x2F,0x2A,0x82,0xEB,0xC4,0x6D,0x5B,0x52,0x51,0x5A,0xF0,0x8A,0x61,
	0x2E,0xA6,0x98,0x2D,0x3D,0x59,0x8B,0x1B,0x12,0x9C,0xB5,0xB5,0x51,0x1B,0x87,0x1B,0xEE,0xDA,0x1A,0x81,
	0x2F,0xA6,0x18,0xC3,0x84,0x44,0x56,0x7C,0xD7,0x19,0xEB,0x56,0xE4,0x25,0x89,0x55,0x21,0x26,0x4D,0xF5,
	0x19,0xB7,0xFB,0x8B,0x60,0x5F,0x39,0xF5,0x58,0x91,0x1B,0xB8,0x11,0xFE,0xA5,0xB2,0x18,0xD1,0x97,0x00,
	0x75,0xA1,0x9B,0x7D,0x7C,0x55,0xF3,0xD9,0x5C,0xF6,0x31,0x85,0x82,0xA3,0x47,0x02,0x92,0xF4,0x7A,0x7C,
	0x45,0x52,0x77,0xE7,0xCD,0x6E,0xA2,0x2C,0xAD,0x98,0xEF,0xEE,0xBA,0xB6,0xF2,0x07,0x2B,0xED,0x43,0x26,
	0x16,0x72,0xDD,0xED,0xF2,0xB4,0x29,0x1C,0x25,0x5A,0x45,0x6E,0xFB,0x6D,0xE8,0x1E,0x7E,0x1F,0x3B,0x37,
	0x5A,0x8C,0xAA,0x1C,0xB0,0x94,0x35,0x05,0xF2,0xF6,0xC4,0x4B,0x4E,0xF6,0x70,0xB1,0xDD,0x36,0xEF,0x63,
	0x66,0xC4,0xE8,0xFB,0x5A,0x5C,0x9B,0xBA,0xA3,0x98,0x56,0x6D,0x8B,0x5B,0x0C,0xC8,0xD0,0x58,0x04,0x5A,
	0x09,0x4E,0x0F,0x86,0xBD,0x27,0xEB,0x31,0x38,0x2A,0xE5,0xC4,0xE8,0x92,0xA2,0x3E,0x06,0x15,0x02,0xD8,
	0xF5,0xB0,0x3F,0x7C,0xA1,0x8B,0x5D,0xD4,0x13,0x2A,0x79,0xEC,0x2B,0x34,0x5F,0x50,0x07,0xC4,0xE8,0xCD,
	0xB5,0xC5,0x10,0x64,0x4C,0xC1,0x96,0x9A,0x28,0xCE,0x24,0x07,0x17,0x11,0x76,0xF6,0xFF,0x03,0x2B,0xD6,
	0xEF,0x96,0x55,0x94,0x80,0xA1,0x4F,0x32,0x03,0x50,0x62,0x04,0x74,0xD4,0x42,0x5E,0xBC,0x5D,0x07,0x34,
	0x71,0x4E,0xA5,0x88,0x4A,0x45,0xE0,0x7D,0x17,0xE0,0x66,0x7B,0x96,0x53,0x71,0x53,0xA0,0xBE,0x46,0x4C,
	0x8E,0xC8,0x8D,0x94,0x3D,0xFC,0x5D,0x64,0x4A,0xB8,0x2E,0xEB,0x56,0x75,0xC7,0x19,0x81,0xB2,0xAE,0xCF,
	0xF8,0xC9,0x34,0x77,0xE3,0xDF,0x72,0xCC,0x7D,0xD1,0xD0,0x00,0xAD,0x59,0x74,0x41,0xDC,0xB3,0xFD,0x62,
	0x88,0x40,0x95,0x29,0xD3,0x34,0x6E,0x83,0x89,0xE8,0x33,0xE0,0xEF,0x7A,0xCE,0x61,0xE0,0x90,0x24,0xE4,
	0xF9,0xC7,0x4B,0x0F,0x82,0x20,0x30,0x33,0x2B,0xC5,0xC3,0xE8,0x08,0x5C,0x75,0x75,0xEF,0x34,0x5C,0x85,
	0x39,0x92,0x30,0xEB,0x9A,0x29,0xF8,0x8C,0xCA,0x09,0x5A,0x06,0x0D,0x14,0x34,0xD6,0xCB,0xCD,0x06,0xA2,
	0xA2,0x29,0xDF,0xD3,0xBA,0x15,0x1C,0x73,0x4C,0x54,0x77,0xD7,0xB8,0x42,0x67,0xBA,0x38,0x57,0x8A,0x3C,
	0xAC,0xD2,0xD3,0x03,0x0E,0x74,0xC3,0x04,0xB5,0x9B,0xCC,0x02,0x0B,0x83,0x87,0xB4,0xE4,0xE2,0xBA,0x5A,
	0xF5,0x3C,0x65,0xDA,0x50,0x16,0xE4,0xF4,0x1D,0x87,0x01,0x03,0xD6,0x50,0x8C,0xB3,0x2B,0x3D,0x15,0x28,
	0x10,0x86,0x5C,0x87,0x28,0x64,0x23,0x34,0x6E,0xCA,0x1A,0x06,0x11,0x8A,0x3C,0x64,0xA4,0x50,0x1B,0x4C,
	0xD4,0x37,0x72,0xF9,0x55,0x14,0x16,0x32,0x53,0x2E,0x5C,0x5A,0xEC,0xA8,0x0C,0x1C,0xAA,0x1F,0x06,0x93,
	0x18,0x00,0x46,0xDF,0x18,0xC8,0xEE,0xCA,0x96,0xF4,0xFA,0x0C,0x8C,0xFC,0x72,0x43,0x42,0xAC,0x0E,0x0C,
	0x83,0xEB,0x93,0x2E,0x05,0x70,0xED,0x6D,0xCA,0x0A,0x7A,0x65,0x49,0x51,0x49,0x7E,0x28,0x10,0x64,0x8C,
	0xE7,0x1C,0x01,0x6A,0xD8,0x1A,0x50,0x55,0xD8,0x27,0x94,0xF3,0x70,0xA8,0xEB,0xFB,0xA8,0xC7,0x3D,0xB7,
	0x8D,0xB7,0x00,0x69,0xC8,0x96,0xAB,0xF7,0xC8,0xCC,0xD3,0x1C,0x27,0xD1,0x47,0xF4,0x4A,0x46,0x14,0x90,
	0xA5,0xA9,0x68,0x4E,0x8B,0x67,0x57,0xEB,0x73,0xDC,0xDF,0x09,0x22,0x5A,0x7E,0x67,0xB9,0x52,0xAC,0x16,
	0x16,0x24,0x9A,0x4C,0xF6,0x2E,0x57,0x2B,0xA2,0xA9,0x25,0xA5,0x80,0x10,0x60,0xE5,0x56,0x75,0x58,0x88,
	0x74,0x46,0x4A,0xE5,0x41,0x21,0x47,0x11,0x04,0x54,0x54,0x63,0xA2,0x13,0x38,0x00,0x16,0xFF,0x6F,0x57,
	0x45,0x50,0xFD,0x1D,0x71,0x11,0xCA,0x17,0x3E,0xBB,0xA9,0x7A,0xE7,0xE2,0x84,0xA1,0xC4,0xA8,0x69,0x2B,
	0xFA,0x4B,0xC6,0x3A,0x26,0xC3,0x9F,0x46,0x34,0x93,0xBA,0x01,0x82,0x12,0x89,0x7D,0x41,0xBB,0x14,0x32,
	0xDC,0x11,0x85,0xAD,0x93,0x21,0xCC,0xEA,0x76,0x59,0x82,0x29,0x7C,0x11,0x80,0x64,0x22,0xA6,0xE0,0xC1,
	0x29,0x7C,0xF1,0x2F,0xDC,0x0C,0xDA,0x20,0x0F,0x99,0x50,0xB2,0x4E,0x5F,0xE9,0xAE,0x72,0x6C,0x5D,0x66,
	0xD0,0xAF,0xB4,0xD6,0x57,0x1F,0x5A,0x8E,0x3B,0xA0,0x6F,0x81,0xD6,0xFE,0xA7,0x66,0x3B,0x0B,0xC9,0xCA,
	0xB3,0x5C,0xE5,0xB2,0x0C,0x0B,0xE7,0x98,0x67,0x7D,0x43,0x30,0x50,0xF4,0x71,0xCA,0xB8,0x13,0xBA,0x07,
	0x68,0x02,0xD1,0xD9,0x1B,0x45,0x77,0x45,0x7D,0x01,0x44,0x14,0x88,0x29,0x49,0xE5,0x82,0x4E,0xD6,0xCD,
	0x41,0x7A,0x70,0x86,0xD6,0xB7,0x64,0xD3,0xA8,0xB8,0xB9,0xAE,0x37,0x4A,0x7B,0x1A,0xAE,0x2A,0x58,0xB5,
	0xAF,0xE7,0xD8,0xC7,0x35,0x61,0x7E,0x33,0x2C,0xF1,0xFE,0x02,0xE7,0xC8,0xBF,0x7F,0x6C,0x2C,0xA0,0x77,
	0x45,0x2C,0x32,0x76,0x7B,0x19,0x1A,0xEE,0x17,0x6B,0xE8,0x6F,0x1A,0x2F,0x7B,0xC2,0x9B,0x31,0x9F,0x29,
	0xCF,0x4D,0x87,0xE1,0xBF,0x69,0xD3,0xAD,0xF6,0x11,0x16,0x03,0xE7,0xF8,0x9A,0xA0,0x97,0xFD,0x60,0xAC,
	0xE9,0x17,0x9D,0xDA,0x6D,0xB5,0xD0,0xA2,0xD0,0x31,0xDB,0x1D,0x7D,0x87,0x59,0xD5,0x5E,0x42,0x7F,0x55,
	0xE5,0xAE,0x16,0xA9,0x11,0xA3,0xE9,0xBE,0x55,0xAA,0xB4,0x9B,0x01,0x6B,0x3C,0xF2,0xEF,0x47,0x0A,0xD9,
	0xAC,0x0C,0x92,0x26,0x23,0xC5,0x5C,0x7A,0x84,0xF1,0x44,0x56,0x68,0x90,0x34,0xED,0x8B,0x53,0x41,0xD8,
	0xCD,0x14,0x35,0x40,0xCD,0x9D,0x79,0x20,0xDF,0xCC,0x8B,0xF0,0x80,0x37,0xFB,0x4A,0x90,0xC6,0x66,0x06,
	0x32,0x70,0x97,0x5C,0x14,0x0F,0xB1,0x5F,0x04,0x5A,0x84,0x53,0x30,0x07,0xD9,0xAE,0xA6,0x46,0x32,0x2A,
	0x1D,0x18,0x86,0x80,0xB6,0x3E,0xB5,0x59,0x27,0xEE,0x02,0xBF,0xBD,0xFD,0xA8,0x55,0x32,0x7B,0x0E,0x0C,
	0x90,0x9A,0x94,0x94,0x19,0x95,0xAE,0xA9,0x66,0x0F,0x9B,0x15,0x6C,0x5A,0x12,0x76,0x95,0x8B,0xA0,0x49,
	0xD5,0x5F,0x8A,0x43,0xA5,0x93,0x5B,0x48,0x7B,0x73,0xE4,0x68,0x60,0x98,0x4A,0x42,0xA6,0xD4,0x6B,0x97,
	0x9B,0xEF,0xB7,0xAE,0x20,0x1D,0x66,0x5B,0x67,0x78,0x7D,0xC7,0x4A,0x5A,0x42,0x28,0x18,0xD9,0xC8,0x9A,
	0x58,0xB6,0xEB,0xBC,0xD7,0x43,0xA6,0xC1,0x90,0x08,0x13,0xEA,0x06,0xE7,0x7B,0xF7,0x70,0x7B,0x06,0x04,
	0xC8,0xA5,0x6F,0x53,0xA8,0xED,0x27,0xF6,0x7F,0xA1,0x51,0xA2,0x9E,0xA8,0xDD,0xB9,0xCF,0xA3,0x58,0xDF,
	0xC1,0x75,0x7B,0x9D,0x98,0xD8,0x34,0x48,0x08,0x05,0x18,0x03,0x1C,0xF7,0x05,0x56,0xF2,0x3D,0x87,0x95,
	0x17,0xCA,0x0D,0xF2,0x50,0xD7,0xE3,0x9E,0x10,0x5D,0x14,0x66,0x95,0x8E,0x1F,0x45,0xA1,0x4A,0xD0,0x57,
	0xEB,0xE5,0xF7,0x9D,0x37,0x7C,0xE1,0xD1,0xF5,0x67,0x11,0x26,0xCC,0x31,0x2B,0xAD,0x15,0x50,0x1F,0xAC,
	0x22,0x22,0xC8,0x71,0xB4,0xFE,0x5A,0xF7,0xB9,0x7B,0xBA,0x50,0x8F,0x99,0xC9,0xCD,0x13,0x5A,0x3F,0x55,
	0x17,0xE7,0x3D,0xFB,0xAA,0x6D,0x03,0xE9,0x75,0x8A,0xFC,0xF7,0xBB,0x75,0x8D,0x11,0xC7,0x2A,0x2C,0x8E,
	0xEA,0x57,0x11,0xEC,0xA8,0x66,0x8F,0x81,0x4B,0xA0,0x3A,0xBA,0x61,0x42,0xC1,0x9A,0x54,0x28,0x89,0xA8,
	0x0F,0x3D,0x24,0xAB,0x30,0x55,0x91,0xE2,0x85,0x11,0xF7,0x61,0xBE,0x0C,0xD2,0x77,0xC3,0x77,0x5B,0xA7,
	0xDD,0xFF,0xC7,0x90,0x12,0x7C,0xEC,0x6C,0xA6,0x98,0x2A,0xA3,0xEB,0x42,0x58,0x25,0x3E,0x20,0xC2,0x54,
	0x5E,0x1D,0xC1,0xA8,0x8B,0xDC,0x5D,0xFE,0xFF,0x0F,0x25,0x4C,0xBA,0x53,0x1A,0x40,0xC1,0x7C,0x7E,0xBF,
	0xC6,0x03,0x83,0x31,0xCB,0x4F,0xFF,0x67,0x1B,0x4F,0x92,0xA9,0x10,0x1D,0x72,0xEC,0xEC,0xBA,0x57,0x80,
	0xD6,0xDF,0x23,0x74,0xFD,0xF6,0xE3,0x10,0x5A,0xB3,0x7F,0x9B,0xDD,0x55,0xE6,0xAF,0x21,0xA0,0x9C,0x2C,
	0x31,0x39,0x8A,0xA2,0xAF,0xDB,0x19,0xA4,0xC1,0xE0,0xC0,0xA1,0x09,0x5A,0x34,0x07,0xC4,0x0E,0xBD,0x19,
	0x28,0x4D,0x9A,0x12,0x87,0xE9,0xF1,0x05,0xC8,0xE8,0x0D,0x8A,0x1C,0xA2,0x41,0xC9,0x06,0xC1,0xE2,0x2B,
	0xE1,0xD3,0x6F,0x90,0x04,0xC3,0x0D,0x98,0xCB,0x09,0xE9,0xA5,0xC7,0x51,0x5F,0x81,0xE1,0xC0,0x0D,0x25,
	0x3E,0x8A,0x65,0x4D,0x57,0x27,0x66,0xAD,0x58,0xBA,0xBC,0x07,0xBC,0x75,0xE9,0x2D,0xE2,0xFB,0xB9,0xC2,
	0x48,0x90,0x14,0xD1,0xE6,0x9D,0xBD,0xEF,0xCE,0xC5,0xEF,0x08,0x05,0xB1,0x56,0x73,0x94,0x25,0x8F,0xFD,
	0x8F,0x46,0x23,0x77,0x79,0xC9,0x1B,0xCA,0x1E,0xFD,0x27,0x4A,0xD1,0xFF,0x16,0xB8,0xDD,0x1F,0xE9,0xFA,
	0x94,0xA9,0x55,0xC5,0xBF,0x90,0xC6,0xC0,0xFA,0x12,0x3A,0xA7,0x55,0x55,0xBE,0xE0,0x13,0xAF,0x4D,0x74,
	0xB5,0xC2,0x3D,0xF9,0x5B,0x64,0xA7,0x10,0x56,0x5D,0x7A,0xB0,0x3F,0xB5,0x29,0xB2,0x28,0x65,0xAB,0xB5,
	0x59,0xE9,0x8B,0x2F,0x36,0x43,0xAE,0x4A,0xB1,0xBA,0xBC,0x3B,0xF8,0xEB,0x82,0x12,0x2C,0xE4,0xC2,0x50,
	0x34,0x96,0x4F,0x19,0xB6,0xBC,0x33,0x8C,0x4D,0x30,0x75,0x73,0x95,0x43,0x10,0x98,0x08,0x22,0xF4,0x82,
	0x8B,0x02,0x8C,0xB3,0x01,0x8C,0xE2,0xBF,0xAB,0xE9,0xC3,0x39,0x83,0xCE,0x03,0xB3,0x14,0xC1,0x8A,0x55,
	0xDE,0x9A,0xF4,0x7A,0xFD,0x9E,0x21,0x71,0x8A,0x55,0x05,0xD3,0x5B,0x3F,0x55,0x88,0x8A,0x55,0x27,0x51,
	0x31,0x71,0xC6,0xBC,0x62,0xC6,0x82,0x2F,0xCA,0xC6,0x3D,0xD3,0x9A,0xC1,0xF1,0xCA,0xBE,0x50,0xFE,0x97,
	0x50,0xB7,0x61,0x9A,0x9B,0x56,0xF8,0xD8,0xB9,0xF0,0x71,0xCE,0x91,0xE2,0xD6,0x66,0xBE,0xC2,0x9F,0x4A,
	0x29,0xC6,0x94,0xC7,0x81,0x1E,0xD0,0x88,0xC1,0x1A,0x90,0x9B,0x99,0x7C,0xCA,0xC4,0x86,0xF2,0x68,0x6B,
	0xD1,0x44,0xF2,0xBA,0xF1,0xF0,0x5F,0x45,0xBD,0x78,0x7A,0x41,0x2C,0x12,0x2A,0x0D,0x3C,0x3A,0xB4,0xE5,
	0x2A,0x15,0x10,0xE7,0x1E,0x0D,0x84,0x88,0x5F,0x1F,0x6F,0x14,0x40,0x26,0x30,0x22,0x66,0x5E,0xC7,0x81,
	0xC5,0x35,0x68,0xB6,0xF3,0xAB,0x70,0x34,0xE6,0xB9,0x92,0xA0,0xD2,0x70,0x84,0x28,0xB2,0x99,0x83,0x39,
	0x98,0x28,0x8C,0xD4,0x76,0xFF,0x58,0x3D,0xC2,0xBE,0xB0,0x1B,0x28,0x17,0xD0,0x20,0x0C,0x4F,0x8C,0xE3,
	0x6E,0x1A,0x4B,0x7E,0x56,0x15,0x6A,0x12,0x0D,0xEB,0x90,0xBA,0x05,0x13,0x8C,0x22,0x6C,0x06,0xF5,0x88,
	0xF0,0x15,0x83,0x15,0xB1,0xFE,0xE4,0xA3,0x8E,0xAD,0xF5,0x97,0x07,0x7E,0x8F,0x9A,0x7B,0x14,0x04,0xCC,
	0x20,0x5D,0xD0,0x7D,0xD5,0x1C,0x58,0x53,0xC6,0x8F,0x0C,0x65,0x4F,0x67,0x42,0x75,0x00,0x84,0xB7,0xD7,
	0xE5,0x7F,0x37,0xB8,0xA8,0x58,0xC8,0x1F,0x30,0xFE,0x85,0x6E,0x80,0xBD,0x22,0xFC,0x57,0x27,0xC3,0x5A,
	0xAC,0xF6,0xB9,0x6F,0x0E,0x48,0x31,0xC3,0x9B,0xEE,0x9C,0xE0,0xB7,0xF5,0xD8,0xEC,0x22,0xD2,0x86,0x77,
	0x55,0x3D,0x78,0xE8,0x18,0xC5,0x1C,0x94,0x09,0x6D,0xDC,0x8F,0xD0,0x77,0xDA,0xF3,0xAA,0x09,0x29,0xC1,
	0x9F,0x52,0x17,0x6F,0x87,0x25,0x72,0x57,0x01,0xED,0x21,0xB7,0x5E,0xBB,0x5D,0x7F,0xFB,0xA5,0xD7,0x94,
	0x52,0xFF,0xAD,0xC6,0x48,0x59,0x57,0x12,0x68,0x56,0x93,0xF5,0x84,0x31,0x3D,0x02,0xBD,0x12,0x96,0x4B,
	0xBF,0xA0,0x5B,0xF7,0xAB,0xCD,0x0C,0xCF,0x26,0x9B,0x76,0x3C,0x03,0xF5,0xD7,0x0C,0x05,0x99,0x3C,0x19,
	0x5C,0xF2,0x0B,0xE1,0x10,0x22,0x61,0xA6,0xA4,0xCE,0x73,0xD6,0xE5,0xB8,0xBD,0xFB,0x86,0xBC,0x0D,0x63,
	0x11,0x35,0xD2,0x74,0x7C,0xF2,0x01,0x18,0x77,0x24,0xA9,0x9A,0xBA,0xBF,0x66,0x1C,0x6D,0x18,0xBC,0x60,
	0x94,0xBB,0x20,0x9F,0xD9,0xC7,0xAA,0xB1,0xEA,0x7F,0x20,0x6E,0xEB,0xC8,0xF8,0x59,0x84,0x14,0xF6,0x37,
	0xBE,0xE8,0xF3,0x33,0xB4,0x6D,0x61,0xC9,0xFD,0x92,0xC1,0xEC,0x14,0xDB,0xF8,0xC3,0xF6,0xB9,0xF6,0x43,
	0x23,0xF4,0x9E,0x8A,0x5A,0x81,0x2A,0xA2,0x22,0xAC,0x0E,0xF3,0xE2,0x1D,0x7D,0xC2,0x88,0x4E,0xE8,0xD9,
	0x89,0x51,0x84,0x42,0x70,0xC7,0x22,0x4C,0x32,0x63,0x9E,0x60,0xEB,0xC3,0x56,0x67,0xA2,0x86,0x8C,0x3F,
	0x9A,0xF9,0x42,0x4F,0x69,0x81,0xA5,0x68,0x6C,0x0E,0xAA,0xD2,0xE7,0x9B,0x65,0x4F,0x47,0xAE,0x81,0x59,
	0xB6,0x56,0x2C,0xA5,0x05,0x21,0xBA,0x12,0xA9,0x41,0x83,0x58,0xDC,0x4B,0xA2,0x90,0x6A,0x89,0xC4,0x46,
	0xB1,0xC7,0xBD,0x31,0x6E,0x2D,0x2A,0x01,0x9B,0x04,0x27,0xD2,0x6D,0x38,0xBE,0x0C,0x36,0xE6,0xCA,0x15,
	0x70,0xFF,0x5A,0x06,0x5E,0xCF,0x0F,0x53,0xD0,0x34,0x88,0x22,0x52,0x8C,0xE4,0x1E,0x87,0xE0,0x52,0xB2,
	0x7E,0x06,0xBB,0x86,0x41,0x1A,0x1C,0xED,0x69,0xA6,0x27,0xA5,0xC1,0x52,0x08,0x36,0x32,0xCA,0xE2,0x42,
	0xDF,0x59,0x69,0xB2,0x20,0x4C,0xEC,0x3D,0x32,0x3B,0x87,0x25,0xBB,0x8C,0x31,0xE7,0x0B,0x52,0xA6,0x7B,
	0x57,0xA4,0x05,0xD0,0xB0,0x2A,0xBD,0x45,0x79,0xA7,0x74,0x15,0xE8,0x2A,0x29,0x9F,0x10,0x88,0x95,0x69,
	0xAF,0xE6,0x83,0xAA,0x53,0x06,0x8D,0x01,0x35,0xFA,0x83,0x87,0x06,0xDF,0x92,0xAA,0x83,0xDB,0xAD,0x87,
	0x1A,0x49,0x59,0x44,0xE6,0x32,0x7A,0xEF,0x8C,0x73,0x30,0x7A,0x50,0x7A,0x24,0x27,0x1D,0xC1,0x80,0x66,
	0x05,0x88,0x40,0x25,0x16,0x11,0xD8,0x8B,0xD0,0xAC,0x4C,0x1A,0x38,0x46,0x01,0x20,0x37,0x7D,0x7F,0x02,
	0x08,0x36,0x2B,0xC5,0x92,0x47,0x5B,0x07,0xE4,0x70,0x4C,0xC6,0x76,0x61,0x33,0x38,0xA7,0xA0,0xA5,0xC9,
	0xB0,0xEB,0x28,0x5F,0x03,0xB8,0xF8,0x13,0x16,0xBD,0xDA,0x0B,0x48,0xE0,0xA4,0x0D,0x8B,0x6B,0x5D,0xC2,
	0xEB,0xDA,0xED,0xD7,0x04,0xBD,0x47,0x4E,0x52,0x7D,0xE9,0x70,0x0D,0xA6,0x5B,0xEE,0x97,0x4D,0xB0,0x3A,
	0x12,0x91,0xE1,0x5F,0x7A,0x58,0x32,0x76,0xDC,0x51,0xD5,0xB4,0x61,0x24,0x2E,0xD6,0xA6,0xF6,0x66,0x4B,
	0x90,0x41,0x98,0xC0,0xAD,0xB6,0x28,0xCF,0xD2,0x75,0xED,0x2B,0x64,0x84,0x7C,0xC0,0xB2,0x32,0xD9,0x5D,
	0x2C,0x0D,0x7B,0x65,0xF5,0x03,0xEF,0x58,0xA2,0x13,0xEA,0xBC,0xED,0x6A,0xE9,0xAA,0x02,0x12,0x3F,0xA8,
	0xEF,0xFB,0x19,0x26,0xC9,0xA1,0x3E,0x5D,0x35,0xC2,0xFD,0xC8,0x82,0x4B,0x94,0x80,0xAD,0x08,0x45,0xF5,
	0x13,0x33,0xBF,0x91,0x40,0x1A,0xD0,0xDD,0x5F,0xA1,0x48,0xEE,0x39,0xEF,0x15,0x40,0x24,0xD1,0x61,0x05,
	0x19,0xB5,0x40,0x9D,0x61,0x80,0xB3,0x97,0x40,0xEA,0xA2,0x40,0x17,0xB2,0x8C,0x41,0xF9,0xB8,0xC4,0xB6,
	0xDA,0x1A,0xF6,0x7E,0x83,0xA3,0xA0,0x1E,0x0C,0xB0,0xE4,0x60,0x43,0x74,0x7E,0xFA,0x15,0x89,0x13,0xEA,
	0x63,0x91,0x9A,0x55,0x99,0x62,0xF7,0xFA,0x83,0x42,0xA1,0x5D,0x55,0x41,0xDB,0x4D,0x18,0x58,0xDD,0x13,
	0xB6,0xCB,0xAF,0x27,0x00,0xC2,0x53,0xC8,0x6F,0x55,0x2F,0x95,0x60,0x01,0x7A,0xE8,0x20,0xD8,0x0F,0x91,
	0x03,0x41,0xFD,0x85,0x54,0x5C,0x53,0x3F,0x57,0xAD,0xE4,0xDC,0xF1,0x41,0x4E,0x74,0xD5,0x90,0x43,0x0B,
	0x4E,0x81,0xFA,0xC0,0x93,0x90,0xD0,0x45,0x72,0x5A,0x4C,0x22,0x74,0xAA,0x56,0x1C,0x5F,0x99,0x84,0x22,
	0x25,0x13,0x60,0x66,0x04,0x0A,0xF5,0x78,0x36,0xD3,0xD3,0xCE,0xD2,0xA7,0xAB,0x05,0x3B,0xA4,0xC5,0x51,
	0x3A,0x0F,0x0F,0x77,0xFB,0xD0,0xAB,0x22,0xCC,0x22,0x72,0xB2,0xEF,0x0F,0xE4,0x27,0xCE,0xDC,0x7B,0x57,
	0x87,0x9A,0x28,0xD7,0x05,0xFD,0xDF,0x05,0x5A,0x62,0x99,0x1D,0x0C,0xE6,0xEB,0x9D,0x7F,0xCB,0xF8,0x29,
	0x77,0x65,0x87,0x33,0x5D,0xDD,0xE5,0xDD,0x84,0xAB,0x9F,0xA3,0xBD,0x1E,0x3F,0xEA,0xD8,0xFC,0x5D,0x81,
	0xFF,0x6D,0x79,0xD4,0x64,0x2C,0x1A,0x37,0x3B,0x58,0x21,0x04,0x50,0x49,0xC6,0x62,0xAE,0xB4,0x86,0x30,
	0xD0,0x50,0x8C,0x07,0x0F,0xB1,0x69,0x83,0x07,0x89,0x64,0x4D,0x5F,0x30,0xF2,0x73,0xB9,0x77,0x66,0x76,
	0xEA,0x8A,0x4D,0xD7,0x24,0x4F,0xF4,0x11,0x1E,0x32,0x8E,0xD1,0x83,0x45,0xB4,0x0C,0x91,0xE2,0xDA,0x22,
	0x07,0x2F,0xF8,0xE2,0xAA,0xDB,0x99,0xF9,0xB8,0xED,0x66,0xD0,0x36,0x75,0x4E,0x90,0xB9,0x32,0x82,0x8D,
	0x34,0xB2,0xA4,0xB5,0xBA,0x38,0x18,0xE1,0x1E,0x6D,0x9C,0x78,0x2E,0xA6,0x43,0xA9,0xE7,0xFF,0x36,0x80,
	0xDD,0xB0,0x3C,0x5C,0x1C,0x43,0x03,0x2D,0xBC,0xB6,0xDB,0x75,0xF9,0x8D,0x05,0x53,0x10,0x0B,0x34,0x97,
	0x04,0x49,0x19,0xBA,0x2A,0xD2,0x83,0x37,0xE1,0x61,0xA5,0xC0,0x51,0x99,0x57,0x54,0x11,0x6D,0xAC,0xA5,
	0x17,0xDC,0x17,0x06,0x89,0x0B,0x18,0x3E,0x82,0xA5,0xB8,0x19,0xC9,0xF2,0xC5,0x15,0x72,0x02,0xE8,0xDD,
	0xDE,0x69,0x60,0x5B,0xA2,0xA6,0x73,0xBA,0x9A,0x5D,0xA2,0x8E,0x8F,0xBF,0x26,0x58,0x31,0xE8,0x5F,0x16,
	0xAE,0xC5,0x00,0x42,0x30,0x96,0xA5,0xCB,0x90,0x81,0x89,0x77,0x39,0x4D,0xAA,0xC0,0x92,0x65,0x3E,0xA5,
	0x4E,0x3F,0xEA,0x3A,0x49,0x80,0x60,0xE0,0x79,0xB5,0xCD,0x78,0x69,0x1E,0xD6,0x17,0x02,0x67,0x2A,0x09,
	0xE0,0x51,0x4E,0x52,0x0E,0x06,0xED,0x39,0xE3,0x4E,0x80,0xAC,0xE7,0x9F,0x7C,0x57,0x9B,0x09,0x0D,0x88,
	0x73,0x4A,0x5F,0x11,0xDF,0x8E,0xBB,0xA3,0xFB,0xEF,0x5A,0x48,0xC5,0x2E,0xDC,0xED,0xD4,0x8F,0x0D,0xFD,
	0x96,0x1B,0x94,0xA9,0x31,0xD2,0x38,0xA9,0x1D,0x56,0x95,0xBB,0x85,0x58,0x72,0x71,0x5C,0x95,0xC5,0x2A,
	0x51,0x72,0x8B,0x15,0x71,0x50,0x12,0x16,0x3D,0xDC,0x35,0x64,0x3C,0x31,0xD3,0xF4,0x06,0x92,0x2B,0xD4,
	0xC0,0x47,0x36,0x54,0xC3,0xB9,0x3A,0xC6,0x30,0x34,0x8E,0xD9,0xB0,0x53,0x32,0x7F,0x85,0xA8,0x98,0x33,
	0x89,0x04,0x8E,0x4A,0x99,0x31,0x22,0x9E,0x12,0xE4,0xE0,0x02,0x66,0x4E,0x28,0x0F,0x7A,0x8F,0x48,0xC0,
	0x24,0x20,0x43,0x09,0x15,0x07,0xED,0x15,0xBA,0xB6,0x22,0xAF,0xAF,0x56,0xFE,0x7E,0x51,0x10,0xA3,0x22,
	0x2B,0x9A,0x87,0x9B,0xDA,0xA6,0xDE,0xFF,0x29,0xA6,0x12,0x39,0x7D,0x58,0xC0,0xCC,0x96,0x98,0xE4,0x84,
	0xE1,0xD5,0xE5,0x2F,0xC9,0x5A,0x15,0xCE,0x99,0x26,0xDA,0x90,0x43,0x4E,0x65,0x00,0xCA,0x78,0x39,0x1F,
	0x1A,0x83,0xDD,0x34,0x73,0xA7,0xB1,0xD6,0xEB,0x29,0x43,0xEB,0x64,0xEE,0x41,0xE9,0x40,0x80,0xEB,0xCA,
	0xCB,0xD4,0xE9,0xD1,0x35,0x92,0xDD,0xBA,0x84,0x4C,0xF0,0x0D,0xDE,0x8C,0xA0,0x98,0x1A,0xA5,0xFF,0x0A,
	0xCC,0xD5,0x87,0x85,0xC0,0xDD,0x6E,0xAB,0xF6,0x74,0xD1,0x38,0xFE,0xF8,0x61,0xD3,0x7F,0xB8,0x1D,0x94,
	0x6F,0xFC,0x92,0x23,0x59,0x3E,0xC4,0x30,0x13,0x76,0x57,0x6B,0xBC,0x4B,0x6B,0xC2,0xFA,0x81,0xB5,0xC3,
	0xC2,0x18,0x7D,0xB7,0xB3,0x5C,0xA8,0x3B,0x10,0x00,0x32,0xCD,0xCE,0x52,0x53,0xD9,0xBA,0x2E,0xB9,0xF2,
	0x54,0x0E,0xF0,0xBB,0xAB,0xD8,0x65,0xAB,0x85,0xF9,0x8F,0xE8,0xAB,0x5E,0xAB,0x9F,0xD0,0xA9,0x83,0x1F,
	0xB9,0xD4,0xD5,0xFB,0x15,0xB2,0x41,0x12,0xD2,0x3B,0xAA,0x1B,0x8E,0xB4,0x83,0xF6,0xCF,0xDF,0xBA,0x83,
	0x8A,0x41,0x11,0x8A,0x9B,0xD9,0x4A,0xB4,0xA9,0x7A,0x98,0xAE,0xAD,0xAB,0x69,0xDC,0x00,0x21,0x3B,0x10,
	0xFF,0xC6,0x4E,0x63,0x16,0xD5,0x97,0x06,0x6C,0xB5,0x0F,0xAC,0xAF,0xB5,0xEB,0x01,0xC5,0xE8,0x97,0xDB,
	0x0D,0x15,0x69,0xB4,0xEF,0xC6,0xD9,0xE2,0x52,0x74,0x14,0xB2,0x88,0x73,0x7E,0xDC,0x15,0x11,0xBF,0xD7,
	0x2E,0x07,0x90,0x1F,0x5D,0x75,0xB4,0x8E,0x28,0xDF,0x94,0x1C,0x05,0x0A,0xDC,0x9F,0x0F,0x6B,0x4E,0x6C,
	0xF1,0xD8,0x7F,0xF2,0x36,0x30,0xDF,0x2A,0x75,0xEB,0xC3,0xC1,0x3E,0x68,0x6A,0x76,0x68,0x31,0x17,0x20,
	0x2C,0x23,0x50,0xB4,0xA9,0x55,0x2A,0xFF,0x68,0x80,0x7C,0xFA,0x9A,0xB9,0x7D,0x26,0xB1,0xE2,0x9B,0xB9,
	0x82,0x80,0x28,0x88,0x76,0x21,0x28,0xF3,0x24,0x51,0x10,0x10,0x5E,0x09,0x36,0xEE,0x30,0x2B,0x61,0x17,
	0x31,0xE6,0x4B,0x14,0xFB,0x2A,0x17,0xC0,0xFC,0x64,0x17,0x80,0x29,0xD9,0xCD,0x51,0x55,0x92,0xBC,0xD3,
	0x57,0x8B,0xF0,0xAF,0x95,0xFF,0x17,0xE4,0x00,0xF2,0x49,0xB6,0xBA,0x0B,0x5A,0x54,0x28,0x77,0xCA,0x71,
	0xF0,0x52,0x06,0xB4,0x1B,0xDF,0x54,0x66,0xF6,0x46,0xEA,0x0A,0x1E,0x21,0xAC,0x2E,0xDD,0x5D,0x0C,0xA4,
	0xF9,0x8D,0xC6,0x16,0xCA,0x55,0x13,0xF6,0xE4,0xF5,0xBE,0x79,0xAA,0x9C,0x55,0x64,0x0F,0x70,0x80,0x5E,
	0xE5,0x48,0x3B,0xE5,0xC1,0xEB,0x80,0x02,0x23,0xF8,0x0D,0x16,0x22,0x28,0x72,0xE9,0xE4,0x9B,0x12,0xA7,
	0x45,0x15,0x88,0x24,0x95,0x14,0x72,0xCA,0x55,0x90,0x26,0x33,0x73,0x3F,0x51,0x3C,0x00,0x64,0xE8,0x37,
	0x4B,0x76,0xB7,0x40,0x32,0x3A,0xC1,0xB4,0xC9,0x42,0x01,0x80,0x37,0x0A,0x4D,0x0E,0x86,0x09,0x42,0x50,
	0xAF,0x7B,0x2C,0x7B,0x09,0x62,0x28,0x2E,0x70,0x54,0xA6,0x75,0x73,0xCC,0x35,0x4F,0x92,0x10,0x6D,0x0E,
	0xD7,0x6D,0x95,0x16,0xE1,0x22,0x57,0x73,0x58,0x4D,0x24,0xF7,0x99,0x10,0x79,0x1F,0x1E,0x2D,0x96,0xC6,
	0xF0,0x74,0x7B,0x44,0x84,0x1F,0x56,0x13,0x21,0xA6,0x71,0xF7,0x94,0xF9,0x10,0xAD,0xEA,0x39,0x11,0xD0,
	0xDF,0x21,0x9A,0x7B,0xDE,0xFD,0xEF,0x1C,0x68,0x31,0x17,0xB9,0x26,0xBA,0x29,0x9C,0xFC,0x7A,0xE6,0xCA,
	0xD2,0x57,0x2E,0x77,0xFF,0x16,0x2B,0xAC,0x44,0xDD,0x02,0x50,0x4E,0xCC,0xD9,0xD2,0x9D,0x82,0x85,0x8C,
	0xBA,0x81,0x98,0x38,0x7D,0x07,0xA9,0xFE,0x44,0x61,0x2A,0x43,0x68,0x7B,0x2B,0xCE,0x0C,0xB5,0x52,0xBA,
	0x8C,0x37,0xE9,0xCE,0x8A,0xF5,0xB5,0x50,0x19,0xBA,0xFA,0x56,0x18,0x24,0xC1,0xDF,0x7D,0xB4,0xFA,0x76,
	0xD9,0xB5,0x31,0x88,0x7B,0x2F,0x7A,0x70,0x65,0x33,0x80,0x80,0x92,0x63,0x50,0x0A,0x9A,0x39,0x55,0x70,
	0x80,0xE3,0x12,0xC4,0x2D,0xF0,0x92,0x1F,0x4B,0x2A,0xE2,0x10,0x7F,0x87,0x8D,0x66,0x39,0x56,0xE1,0xBB,
	0x08,0xF5,0x4E,0x0B,0xD5,0xEC,0x61,0x0D,0xCA,0xB2,0xD8,0xDC,0x02,0xE5,0x00,0x5F,0x2F,0x0B,0x15,0x8D,
	0xA2,0x8E,0x74,0x53,0x1A,0xFB,0x77,0x89,0x7D,0xB7,0xB3,0x4E,0x44,0x18,0x3C,0x1C,0x57,0x82,0x60,0x45,
	0xF0,0xA5,0xFB,0x71,0x03,0xB0,0x09,0x67,0xCB,0xC0,0x89,0x7D,0xAE,0x9B,0x84,0x4C,0xB6,0x00,0xAA,0x94,
	0xBA,0x15,0x63,0x6A,0xA0,0x6A,0x68,0x54,0x22,0xFA,0xFE,0x57,0x5E,0x79,0x31,0x94,0xDD,0x6D,0x60,0xE2,
	0x33,0x65,0xAF,0x52,0x05,0x3B,0xB2,0xB2,0xF6,0xF9,0x77,0x0F,0x73,0xA7,0xCF,0x26,0x9A,0xEE,0xC7,0x47,
	0x8D,0x34,0x50,0x3B,0xDA,0xCF,0xF2,0xCC,0x9A,0x6D,0x7B,0xDC,0x5C,0xC8,0xB4,0xD5,0x67,0x14,0x42,0x93,
	0xD1,0x7B,0x45,0x72,0xBC,0x3C,0xC7,0xBE,0x75,0x45,0x7B,0x28,0x00,0xC4,0x40,0x07,0x10,0x18,0xF7,0x46,
	0xEB,0xFF,0x89,0xE8,0x70,0xAC,0x72,0x65,0x9B,0x1D,0x53,0x73,0x06,0xA9,0xF2,0x93,0xF7,0xF9,0x0A,0x9C,
	0xAB,0x22,0x65,0xA8,0xF4,0x53,0x8B,0x81,0x78,0xE8,0xAD,0xF4,0xEF,0xDB,0xA0,0xCC,0xEA,0xC5,0xD3,0xB3,
	0xBB,0xD4,0x36,0xBA,0xE8,0x7A,0x73,0xFE,0x27,0x8C,0xB6,0xEE,0x56,0xCE,0x11,0xE6,0x38,0xCB,0xED,0x89,
	0xE7,0xCC,0x55,0xA3,0xE4,0xFE,0xAE,0xC2,0x9A,0x92,0x26,0x49,0x52,0x02,0x78,0x65,0x66,0x6F,0x23,0x38,
	0x54,0x5F,0xFC,0xD2,0x01,0x4F,0xAB,0xE9,0x33,0x6B,0x71,0x2A,0x90,0xBD,0x85,0x1A,0xE6,0x32,0x1B,0x51,
	0xA2,0xA4,0x2E,0xAF,0xE8,0x65,0x8A,0x67,0xA4,0xB2,0x14,0x19,0x96,0xC3,0xC8,0x1B,0xDB,0x09,0xCE,0x1A,
	0x24,0x53,0xB8,0x33,0x06,0x31,0xDE,0x70,0x74,0x32,0x79,0x05,0x00,0xC1,0x44,0xA6,0xF9,0x79,0x78,0x60,
	0x5C,0x47,0xA5,0xCC,0x91,0x42,0x4B,0x7E,0x68,0x69,0x6A,0xB3,0x89,0x42,0xBB,0xA8,0x4B,0x6E,0x0E,0x68,
	0x97,0x5B,0x5C,0x78,0xA4,0x5B,0x9A,0x5F,0x93,0xDC,0x88,0x30,0xB9,0x8F,0x54,0x1A,0xB8,0xB3,0x94,0x9A,
	0x05,0x24,0xF3,0x08,0xB0,0xC4,0xA8,0x5C,0xD5,0x9C,0x38,0x5C,0xDD,0x1D,0x87,0x3B,0x6A,0x0C,0xE4,0x2A,
	0x80,0x84,0xB9,0x42,0xAD,0xEF,0xF2,0xC3,0x44,0x65,0x81,0xF9,0x43,0x81,0xE6,0xA4,0xCB,0xE2,0xB7,0x6F,
	0xD9,0x5D,0x00,0xC4,0x77,0x02,0xE1,0x82,0x29,0xF9,0x91,0x70,0xE3,0x9C,0xE3,0x10,0xE8,0x53,0xD9,0x17,
	0x12,0x69,0xAD,0x2D,0x19,0xF3,0xC3,0x51,0x98,0x28,0x5E,0x61,0x65,0x91,0x90,0xFA,0x5D,0x00,0x65,0xE4,
	0xB0,0x03,0x69,0x64,0x96,0xBC,0xFF,0x9F,0xA3,0x83,0x74,0x2E,0x42,0x41,0xF0,0x58,0xD6,0x47,0x50,0x14,
	0x82,0x7B,0xBB,0xC1,0xAC,0x2B,0x2D,0x38,0x18,0xB0,0x45,0xD5,0xA6,0x53,0x4D,0x55,0x73,0x26,0x34,0x09,
	0x24,0x4F,0xDD,0x09,0x2B,0x15,0x18,0x5C,0xCE,0xE8,0x07,0x56,0x82,0x62,0x02,0x7A,0x21,0x64,0x1C,0x04,
	0x0C,0x90,0x5B,0x82,0x02,0x16,0xF0,0xE5,0x59,0x48,0x1A,0x7C,0xD4,0x79,0x33,0xFA,0x08,0x8C,0xBA,0x28,
	0xF0,0x94,0x99,0x15,0x3C,0x93,0xA2,0xC4,0xEB,0xFC,0x25,0x79,0xE6,0x05,0xCF,0x4D,0x2E,0xAC,0x2B,0x57,
	0x65,0xE1,0x9F,0xA0,0xEF,0xE8,0x85,0xAF,0x04,0x60,0x28,0x75,0x17,0x96,0x4B,0x6B,0x44,0x5A,0x4C,0x7C,
	0x2A,0x74,0x6B,0xC8,0xE0,0x7D,0x04,0x65,0x8A,0x32,0x08,0x8B,0x76,0xDD,0x8F,0x88,0xBC,0x74,0x55,0x3D,
	0x06,0x81,0xF6,0xB4,0x43,0x43,0xEB,0x6A,0xF0,0xF3,0xF6,0x66,0x99,0x6F,0x02,0xC9,0xF5,0xA3,0x4B,0x40,
	0xD3,0x24,0xF7,0x40,0x43,0x3B,0x36,0x38,0xAA,0x47,0xAF,0xBF,0x6F,0x27,0xC9,0x7E,0xC1,0x2E,0x05,0xB3,
	0x25,0x1E,0x4B,0x73,0x47,0x35,0x46,0x6E,0x6F,0x84,0x8A,0x13,0xAB,0x90,0x32,0x8A,0x24,0x54,0x74,0xB8,
	0xC0,0x58,0x79,0x18,0x44,0xB9,0x74,0xFC,0x97,0xF9,0xF7,0x25,0xA5,0xC2,0x02,0xE9,0xCC,0xF1,0x59,0xFF,
	0x19,0x23,0x16,0xA8,0xA8,0x68,0x11,0x91,0x96,0xC5,0xC7,0x42,0x2C,0x48,0xF4,0x5A,0xC2,0x44,0x5F,0x20,
	0xBF,0xA3,0x6F,0xE8,0x9A,0xEB,0xC4,0x77,0x00,0x15,0xAF,0x4B,0xB9,0x97,0xF9,0x35,0xB1,0xE8,0xF8,0x7D,
	0xAD,0x33,0xE1,0xE9,0x1A,0x22,0x68,0xC1,0x91,0x18,0xE6,0xC7,0x75,0x1E,0x9A,0x03,0x97,0xEB,0x25,0x3E,
	0x4A,0x1A,0x96,0x65,0xF4,0xE9,0x76,0x54,0x48,0x5C,0xCD,0xB4,0x1A,0xAD,0x1A,0x73,0xB3,0xB2,0x02,0xF5,
	0xA0,0x88,0x5C,0xA9,0x8D,0xA0,0x69,0x7D,0x5A,0x06,0x95,0x16,0x82,0xC3,0x19,0x3D,0x73,0x37,0x5A,0xAE,
	0xD2,0xA8,0x1D,0xCD,0x6A,0xA5,0x3A,0x3B,0x60,0xC3,0xA9,0xF2,0x3D,0x4B,0x0A,0xF0,0x45,0x2C,0x70,0x8E,
	0xAB,0x9A,0x4B,0x6B,0x62,0x96,0x54,0x15,0x70,0xA9,0xD8,0xFD,0x4A,0x0D,0x55,0x6E,0xC9,0xC1,0xB9,0xDE,
	0x86,0xDB,0x6D,0x15,0x4E,0xA8,0xF4,0xF8,0xA5,0xC4,0x98,0x89,0x7C,0x47,0x7D,0x3F,0xB6,0x4B,0xA8,0x49,
	0xC3,0x9B,0x4E,0xC3,0x3B,0xAA,0x2A,0xDA,0x8C,0x33,0x41,0x98,0x3B,0xAF,0x7C,0x53,0x4C,0xFA,0x39,0x19,
	0x12,0x04,0x77,0x4D,0xF7,0x28,0x85,0x86,0xB5,0xAF,0xC8,0xE7,0x29,0xDD,0xDD,0x3A,0x55,0x29,0xD4,0x48,
	0xD0,0xB4,0x18,0xAF,0x2B,0x98,0x5D,0x73,0x57,0x95,0x59,0xBC,0x4A,0x12,0x8D,0x59,0xCD,0x06,0x95,0x90,
	0x37,0x27,0x09,0x6F,0x65,0x07,0x77,0xC6,0x88,0x91,0x13,0x90,0x85,0x65,0x82,0x72,0x21,0xC4,0x30,0xD7,
	0xA5,0xC4,0xA3,0xA9,0xC6,0xE6,0x39,0x6E,0x66,0x6A,0xD0,0x63,0x49,0x84,0xEA,0x82,0x7F,0x39,0x6B,0xAD,
	0xC3,0x4C,0x97,0x03,0x17,0x2B,0x6D,0x1D,0x44,0xED,0x02,0x4A,0x55,0x01,0x97,0x02,0x31,0xB0,0xB9,0x74,
	0x09,0xA7,0xCB,0x4E,0x87,0xBB,0x6C,0x3B,0x06,0xC9,0x38,0xB8,0xB3,0x0B,0xBE,0x9F,0xB7,0xB6,0xCE,0x48,
	0xB2,0x2E,0x91,0xDA,0xC9,0xDF,0x43,0xA8,0x78,0xA6,0xBB,0xD4,0x8E,0x45,0x2A,0xC1,0xF0,0xBD,0xD4,0x5D,
	0xED,0xC5,0x04,0x6A,0x57,0x10,0xBA,0xB8,0x52,0xB7,0xDD,0x94,0x82,0x12,0x26,0x37,0xC6,0x36,0x43,0x91,
	0x69,0x6F,0xFF,0x6D,0xA0,0x5C,0x85,0xDC,0x05,0x0E,0x1E,0x96,0xAD,0xB0,0x10,0xB7,0xD8,0xBA,0x9A,0x8B,
	0xD4,0xE9,0xBA,0x94,0x92,0xA0,0xCA,0xA3,0xC9,0x09,0x72,0x62,0x42,0xC3,0xEA,0x9B,0x51,0xF2,0x1C,0x31,
	0x35,0x76,0x74,0x39,0x2A,0xA6,0x28,0x4A,0xF3,0x81,0xC2,0x88,0x02,0x5E,0x39,0x53,0x7D,0x43,0x30,0x1B,
	0xA6,0x86,0x6D,0x40,0xB6,0x07,0xDF,0x15,0xDB,0x3F,0x40,0xA7,0x1F,0xF3,0x75,0x10,0x60,0xDB,0x31,0x18,
	0x4E,0x09,0x76,0x4A,0xE2,0xAB,0xCA,0x93,0xFC,0x8A,0x8D,0x73,0xBE,0xCA,0xE2,0x6D,0xC3,0x7D,0x45,0x6C,
	0xA0,0x81,0x94,0xE3,0x94,0x46,0x47,0xA8,0x17,0x52,0x79,0x50,0x61,0x54,0xF5,0x9D,0x14,0x49,0xFF,0x50,
	0x8D,0x4C,0x89,0xD4,0x68,0xB1,0x9C,0xF3,0x4E,0xE1,0xD7,0xA3,0xF6,0xCA,0x29,0xE4,0xB2,0xE3,0xE0,0x8D,
	0x19,0xD6,0x7A,0xD6,0xCA,0xAE,0x86,0xA4,0x38,0x9D,0x4A,0x4A,0x5A,0x61,0x8E,0x8E,0x5E,0x6C,0x4A,0x10,
	0xD8,0x65,0xFD,0xB1,0xEF,0x88,0xA6,0xBB,0xB0,0x4C,0x7A,0xFE,0xFA,0x50,0x7A,0x92,0x55,0xAA,0x06,0x6F,
	0x65,0x89,0x0C,0xF5,0x82,0x79,0xA8,0x28,0x9E,0x84,0x4F,0xFB,0x0D,0xC1,0xD8,0x6C,0x59,0x2E,0x8B,0x57,
	0xD1,0xAC,0x9C,0x65,0x4D,0xC1,0x33,0x15,0x55,0x99,0xF2,0x0E,0x28,0xC3,0x0B,0x80,0xC6,0xF2,0x8F,0xDA,
	0x0F,0xB8,0xF9,0xCA,0xAA,0x41,0xD5,0xA6,0x75,0xE5,0x73,0x91,0xFB,0x17,0x4D,0xEE,0xA5,0x30,0xBE,0xB5,
	0xEE,0xDF,0x30,0xF1,0xEE,0x14,0x26,0xF8,0x22,0xA5,0xE7,0x25,0x22,0xCA,0xE2,0x5D,0x99,0xD3,0x33,0x72,
	0xB4,0x24,0xA9,0xD9,0xED,0x25,0x50,0xF4,0xEA,0x56,0x23,0xD6,0x60,0xCA,0x03,0x3A,0x75,0x64,0xBC,0xED,
	0xB4,0x16,0x83,0x90,0xA9,0x4B,0x76,0x55,0x90,0x9E,0xA7,0xE0,0x6C,0x0D,0xA8,0x45,0x6B,0x96,0x95,0x96,
	0xF8,0x40,0x0C,0x4F,0x5B,0xF6,0x41,0x6A,0xFE,0x73,0x10,0x4C,0x71,0xD0,0x17,0xB2,0xDC,0xA6,0xCD,0x17,
	0x11,0x18,0x50,0x23,0x11,0x51,0x2A,0x6B,0x81,0x11,0x82,0x25,0x37,0x4A,0x30,0x69,0xBA,0x2A,0x7D,0x1A,
	0x45,0xDA,0x55,0x52,0xB6,0x15,0x93,0xA1,0xF7,0x6E,0x67,0xD7,0x7F,0x5A,0x35,0x76,0x63,0x30,0xF2,0xB6,
	0x71,0xB8,0x75,0x10,0x18,0xC1,0x1F,0xA5,0x6F,0xD9,0xC1,0x40,0x86,0xD1,0xF1,0xC1,0x21,0xF1,0x35,0x0D,
	0x8D,0xB9,0xEA,0xE1,0xFF,0x93,0xE7,0x9E,0xF3,0x82,0xDA,0x07,0x43,0x7F,0x15,0xD9,0xE9,0x42,0xA0,0x92,
	0x63,0x15,0xFB,0x60,0xF8,0xF2,0xFB,0x07,0x5B,0xEF,0xD0,0x57,0x5C,0xA4,0x7A,0x81,0xBA,0x43,0x9D,0xD5,
	0x80,0x3B,0x8D,0x80,0x43,0xC7,0x80,0xD2,0xB9,0x98,0xEC,0xCF,0xA6,0x5E,0xA1,0x39,0xA2,0x31,0x4A,0xAC,
	0xAA,0xDD,0x22,0x30,0xDC,0xA6,0xB6,0x27,0x8A,0x57,0x32,0xF4,0xD6,0xDD,0xEE,0x20,0x16,0x1E,0xEC,0xE9,
	0x7C,0x12,0x59,0x66,0x5E,0xB5,0x68,0xE0,0x07,0xB9,0x83,0x96,0x07,0x00,0x5D,0xE6,0x86,0x6F,0x9B,0x28,
	0x0B,0x86,0xB0,0x41,0x31,0x0E,0x09,0x3A,0xE0,0xE8,0x05,0x34,0x2A,0x10,0x43,0x94,0x62,0x39,0xE1,0x07,
	0x18,0x5F,0x7D,0x19,0x04,0xF1,0x09,0xD1,0xD3,0x29,0x87,0x67,0x07,0x00,0x7D,0xD3,0x6D,0x5E,0x25,0x6E,
	0xC4,0x0A,0x4D,0x77,0x0A,0x3A,0x4D,0x38,0x55,0x6D,0xCF,0x5B,0x6B,0xD0,0x9B,0xEF,0xAA,0x1B,0xA5,0x16,
	0xA6,0x39,0x93,0xCB,0x57,0xF4,0xDA,0xCA,0xEE,0x6A,0x52,0xAE,0x03,0x5C,0x61,0xFC,0x17,0x81,0xF3,0x45,
	0x6D,0x65,0x05,0x4B,0x50,0x33,0x92,0x71,0x72,0x21,0x3E,0xDE,0x33,0x8E,0x75,0x6D,0xE8,0x74,0x95,0xE7,
	0xFC,0x65,0x7B,0x96,0x42,0x6F,0x6B,0xF2,0x61,0xEC,0x6B,0xA0,0xBC,0xEB,0x02,0x66,0x4C,0x79,0x6D,0x95,
	0x6A,0x31,0x5C,0xC3,0x24,0x06,0x8F,0x65,0x00,0xFB,0x3E,0x46,0x55,0xC3,0x14,0xE6,0x0E,0xF1,0x77,0xBE,
	0xC7,0x49,0x27,0x4D,0x6D,0xF8,0x03,0xA0,0xB7,0x00,0xBC,0x74,0x15,0x3F,0xA1,0x27,0xA5,0xD9,0x8D,0x0B,
	0x1C,0x06,0xC1,0x51,0xB4,0xFA,0x9A,0x93,0x88,0x85,0xA9,0x1A,0x4D,0x96,0xD0,0x9E,0xD6,0x2F,0xD0,0xBB,
	0x97,0x10,0x54,0xD3,0x8F,0xDA,0x2B,0xE7,0x1A,0x01,0x03,0x20,0x01,0x7B,0x2F,0x02,0x25,0x35,0x39,0x04,
	0x11,0xA5,0x24,0x29,0x01,0x50,0x58,0x7D,0x5C,0xC1,0x1F,0x52,0x60,0x17,0x75,0xEA,0x9A,0xBA,0x48,0x41,
	0xFE,0x8D,0x5E,0x8A,0x1C,0x90,0x6F,0xB0,0xCF,0x45,0x49,0x58,0x2A,0xB2,0x8B,0xCB,0xCD,0x12,0x14,0xB0,
	0xE1,0xD5,0x42,0x87,0x03,0xF4,0xCA,0x43,0x20,0x7C,0xFB,0xE6,0xC4,0x27,0x7A,0xC9,0x76,0xCA,0xBE,0x21,
	0x7F,0x08,0x31,0xD3,0x2A,0x00,0x50,0xE5,0x00,0xB3,0x32,0x71,0x01,0x87,0x4D,0x2D,0x74,0x4D,0x23,0x71,
	0x2E,0x31,0x75,0x73,0xF9,0x79,0x0F,0xE2,0xF0,0x31,0x19,0xB0,0x7B,0x7A,0x32,0xC8,0x20,0x5D,0x4D,0xCC,
	0x9A,0x12,0x32,0xD7,0xE8,0x1E,0x21,0x9C,0x0E,0xED,0xB0,0x15,0x4B,0x61,0xCF,0x1F,0x72,0x25,0x56,0x87,
	0xAE,0x30,0x98,0x38,0x16,0x59,0xA5,0x7D,0xA4,0x02,0xAB,0x7C,0xEF,0xAE,0xE5,0xDE,0xCA,0xD8,0x15,0x03,
	0xE3,0x27,0x0B,0x7B,0x3A,0xED,0x23,0x54,0x02,0x26,0x02,0x5C,0x17,0x3E,0x67,0x32,0x91,0xB1,0x06,0x6C,
	0x53,0x32,0xA6,0x58,0x53,0x3E,0x03,0xFA,0x2E,0xC6,0x99,0x2A,0xAB,0x03,0x0A,0x6C,0xE4,0x00,0xD0,0xE9,
	0x3A,0x50,0xE0,0x62,0xA0,0xC9,0x1F,0xBA,0x5F,0xC2,0xF8,0x40,0x93,0x73,0xD6,0x2E,0x1B,0x50,0x83,0x98,
	0x47,0xF9,0x86,0xBB,0xC7,0x60,0x02,0xCA,0x5B,0x50,0x7B,0x57,0x89,0x0B,0x5E,0x2E,0x20,0xDF,0x0C,0xE7,
	0xD0,0xB5,0xD6,0x3F,0x0C,0x09,0x97,0x0B,0xE8,0xC1,0x3C,0x19,0x42,0x9F,0x5C,0x10,0x43,0x5C,0x10,0x57,
	0x2C,0xC7,0x57,0x72,0x28,0x91,0x70,0x84,0xC0,0x23,0xC2,0x56,0x0E,0x6C,0x29,0x6C,0x29,0xBE,0xDE,0xEB,
	0xF8,0xDF,0xD0,0xFF,0x76,0x7E,0x5D,0x4D,0x5B,0x37,0x4F,0xFD,0x55,0xBE,0x73,0xBC,0x39,0x06,0xC6,0x11,
	0x17,0x35,0x2E,0xBE,0xDB,0x20,0x2F,0x75,0x41,0xC9,0x5F,0x5D,0xC2,0xBE,0x55,0x45,0xD4,0xB9,0xCB,0x0F,
	0x80,0x49,0x8F,0xC0,0xD5,0xF0,0x63,0xFF,0x43,0xFB,0x66,0x14,0x61,0x3D,0xFC,0xCC,0x4A,0xC1,0x85,0x18,
	0xD0,0xD4,0x06,0xDE,0x99,0xE6,0x23,0xA6,0xCC,0xD4,0xEB,0x2E,0x0E,0x16,0xCB,0xF4,0x43,0xBD,0x00,0xCE,
	0xE2,0x33,0x28,0x0B,0x03,0x8B,0x9D,0x23,0xD4,0x45,0x3F,0xCC,0xBC,0x90,0x0C,0x49,0x0A,0xB7,0x38,0xE3,
	0xE5,0xC9,0xC3,0xE2,0xB2,0xD3,0xD2,0xA4,0x19,0x61,0xD3,0xBC,0x5C,0x77,0xEC,0x9C,0x22,0x0D,0x77,0xC7,
	0x1E,0x17,0x68,0x5E,0x50,0x9F,0xDE,0x28,0x02,0xFF,0x32,0x4B,0x36,0x5E,0x05,0x32,0xB3,0xC8,0x21,0x48,
	0x74,0xA1,0x5C,0xA4,0x28,0xB2,0xA0,0x79,0x7C,0x76,0xAB,0x5F,0xC3,0x58,0x17,0x83,0x5C,0x6F,0x5B,0x0B,
	0xF2,0xD0,0xC5,0x0D,0x9E,0xC2,0x19,0xE3,0xE4,0x2E,0x70,0x58,0x8D,0x45,0xC1,0x81,0xA4,0x21,0x9C,0x84,
	0x01,0x86,0x6C,0xB9,0x7A,0x17,0x0E,0xC6,0x83,0x7D,0x7C,0x89,0x01,0xCA,0x8B,0x29,0x3E,0xB0,0x2E,0x60,
	0xBE,0x79,0x34,0x8F,0x0F,0x41,0x77,0x92,0x0B,0x07,0x16,0x22,0x50,0x65,0xDA,0xE0,0x41,0x63,0x40,0x0D,
	0x07,0xA8,0x9B,0x4A,0xC8,0x5E,0xFD,0xBB,0xCA,0x83,0xCC,0x84,0x6B,0x31,0x57,0x8D,0xB0,0xD8,0x50,0x42,
	0xBA,0x83,0x9A,0x2E,0xCD,0xA0,0x81,0xA3,0x97,0x4D,0x10,0x10,0xB0,0x69,0x1C,0x0F,0xC4,0xFD,0x82,0xAD,
	0x56,0x05,0x0D,0x0A,0xC4,0x03,0x19,0x86,0xA9,0x9C,0x4A,0x9C,0x22,0x6C,0xFC,0x3F,0x3A,0x42,0x48,0x87,
	0x76,0xCD,0x66,0x57,0xDD,0x6E,0x24,0x83,0x87,0x05,0x16,0x2A,0xAE,0x22,0x4C,0x38,0x4E,0x45,0x39,0x58,
	0x80,0x1B,0x23,0x39,0x85,0xA6,0x63,0x06,0x02,0x64,0x9D,0xAB,0x58,0x38,0x58,0x37,0x02,0xE0,0x65,0x63,
	0x37,0x98,0xDB,0xFB,0x83,0x21,0x61,0xF9,0x02,0x62,0x19,0x5E,0xE3,0x4E,0xAD,0x98,0x29,0x84,0xAD,0x4A,
	0x09,0xF2,0x29,0x55,0x67,0x24,0x28,0x80,0xC2,0x81,0xB8,0xDE,0x8A,0x0A,0x5A,0x24,0xA0,0xEF,0x09,0x21,
	0x6F,0x39,0x6F,0xCA,0xCA,0x2C,0x8B,0x73,0x33,0x30,0x86,0xA2,0x20,0x7E,0x96,0x9F,0x68,0xBD,0x94,0x40,
	0x26,0x0F,0xBE,0x1D,0xEE,0xE2,0xBD,0x27,0x8F,0x11,0x82,0xAD,0x8C,0x86,0xC4,0xF8,0x4E,0xF1,0x9D,0x48,
	0xFA,0x09,0xCA,0xB1,0xAB,0xD2,0xC4,0xD4,0x70,0xD8,0x20,0x8F,0x23,0xE0,0x5B,0x2B,0xAD,0x1F,0x8C,0x12,
	0x49,0x3D,0xD0,0xC9,0xAA,0xD6,0xB5,0x0C,0x2F,0xEB,0x28,0x2A,0x14,0x15,0x61,0xA2,0xF2,0x3C,0x1B,0x05,
	0xE6,0x3D,0x22,0x30,0x2E,0x06,0xA7,0x53,0x0D,0x05,0x92,0x6C,0x21,0x2A,0x0C,0xEA,0x81,0xFA,0xA0,0x29,
	0x0C,0x5B,0xAA,0x6B,0x36,0xC2,0xAF,0x5A,0xC0,0xAE,0x3E,0x67,0x95,0x8B,0x19,0x7B,0x7D,0xBA,0x43,0x8F,
	0x55,0x15,0xE6,0xBC,0xE7,0x54,0xDA,0xEE,0x9A,0x43,0x8D,0xF4,0xB7,0xFA,0x41,0x77,0xEC,0x3E,0xB9,0x5A,
	0xFA,0x90,0x31,0x36,0x3D,0x97,0x11,0xDD,0x2E,0x55,0x16,0x85,0x5E,0x2C,0x89,0x2D,0xAB,0x64,0xB7,0x07,
	0x8F,0xCD,0x11,0xC4,0xDA,0x39,0x04,0x9A,0xE6,0xBE,0x86,0xC9,0x02,0xD6,0x80,0xF3,0x51,0x18,0x64,0xC3,
	0x51,0x59,0xCB,0xDC,0x31,0x41,0x3A,0xC1,0x60,0xD8,0xF4,0xB5,0xFD,0x44,0x65,0x5F,0x84,0x1C,0x02,0x6A,
	0x10,0xED,0x5B,0x31,0xCA,0x86,0x92,0xF7,0x07,0xBB,0xCA,0x08,0x16,0x8E,0xFB,0x27,0xA1,0x01,0xAF,0x10,
	0x92,0x86,0xF3,0x71,0x7B,0x89,0xBA,0x36,0xD4,0x95,0x76,0x81,0x04,0x57,0x20,0x42,0x88,0x7A,0x9E,0x41,
	0xDD,0x2A,0xF3,0xFA,0x7A,0x87,0x24,0x95,0xEC,0xD0,0xEA,0x40,0xBF,0x1D,0x41,0x11,0xB0,0xA6,0xF0,0xA6,
	0xD7,0xD8,0x82,0x41,0x45,0x54,0x6C,0x50,0x6D,0x26,0x5E,0x03,0x07,0x3D,0x4B,0x7A,0x0F,0x1B,0xC4,0x43,
	0xCA,0x7C,0x0D,0x86,0xF4,0x08,0x39,0x6F,0x54,0x89,0x78,0x46,0x35,0x06,0x3B,0x8B,0x34,0x31,0xF3,0x1D,
	0x50,0x11,0x8E,0x88,0x17,0x79,0x5A,0xBE,0x06,0x11,0x70,0xE5,0x4B,0x50,0x78,0x55,0xCB,0x85,0x77,0xB6,
	0xD5,0xA4,0x28,0x17,0x6C,0x36,0x45,0x62,0x45,0x0A,0x11,0x66,0x66,0x1D,0x8E,0xE9,0x0B,0x05,0xE8,0x66,
	0x40,0xC1,0x48,0x93,0xFA,0xFC,0x1A,0x3D,0x7C,0x04,0xF2,0x6C,0xB8,0x2F,0xBE,0xA6,0x29,0x1D,0x11,0xF9,
	0x93,0xC7,0xAE,0xA6,0x68,0x67,0x86,0x34,0xEC,0xEF,0xD1,0xD4,0xDF,0x5E,0x01,0xEE,0x02,0x0B,0x51,0x41,
	0xE1,0x2E,0x53,0xDB,0x2D,0xE2,0x2B,0xD8,0x5F,0xE8,0xE0,0xA9,0xA9,0x03,0xA2,0x3B,0xF9,0xE2,0x4A,0x37,
	0xBB,0x26,0x42,0xC5,0xA2,0x54,0x5D,0x91,0xF9,0xC6,0x76,0x47,0xF6,0xA1,0xCA,0xFD,0x0C,0x98,0x64,0x2C,
	0xFF,0x62,0x9A,0x26,0x1B,0xE2,0xE4,0xE2,0x04,0xE9,0xCC,0xCE,0xBF,0xA6,0x69,0xC7,0xD2,0xA2,0x9A,0xD0,
	0x57,0x26,0x2F,0xA1,0xB6,0xBE,0x45,0x7C,0x2B,0x1D,0xEC,0x1F,0x23,0xBA,0xDE,0xAB,0xC7,0x7D,0xB7,0x78,
	0x56,0x58,0xE2,0xAB,0x02,0x43,0xE8,0x02,0x35,0x18,0x58,0x62,0x58,0xA0,0x51,0x59,0x13,0xE0,0x79,0x40,
	0x11,0x4F,0x32,0x61,0x5C,0xC8,0x6D,0x82,0xC3,0x19,0x7F,0x8B,0x2E,0xC4,0x35,0xC2,0x7F,0x07,0x1A,0xDC,
	0x27,0xD5,0xF6,0x66,0xF5,0x95,0xEB,0xF8,0x78,0x12,0xA1,0xFA,0xBC,0x08,0xC8,0xDE,0x17,0xCD,0xDD,0x86,
	0x31,0xEC,0xC7,0x57,0xC0,0x93,0x4D,0x63,0xA9,0xCA,0x12,0x25,0xFD,0x2B,0xB1,0xE3,0x64,0x33,0x1D,0xFB,
	0x1C,0xCA,0x33,0xA9,0x2D,0xDA,0xC7,0x05,0xF2,0x1A,0x8D,0x81,0xB5,0x80,0x82,0xE3,0x31,0x2F,0xEA,0xF2,
	0x5C,0x8E,0x3F,0x3D,0x6A,0x90,0x99,0xDC,0xF5,0x67,0xC2,0xAA,0xF0,0xEB,0xD2,0xCF,0x7F,0x61,0xAA,0x2C,
	0x13,0x6E,0xBD,0x6F,0xAA,0x82,0xA8,0x24,0xEF,0x9A,0x81,0x58,0xEB,0xDE,0xF3,0x98,0x77,0x93,0xB5,0x03,
	0x70,0xBE,0xAF,0x50,0x80,0x32,0x03,0x17,0x3F,0x8B,0xC1,0x25,0x05,0x7C,0x62,0x2F,0xFF,0xB7,0x85,0x2E,
	0x6F,0xDB,0x65,0xC0,0xDD,0xD7,0x77,0x2A,0x9B,0xCB,0xBF,0xDA,0x85,0xA4,0x7B,0x6D,0xCA,0xF3,0xBB,0xD5,
	0xF6,0x52,0x67,0x21,0xF2,0x5B,0x80,0x5F,0xFA,0x08,0x7F,0x5B,0x15,0x57,0xA2,0x74,0x19,0x21,0x61,0x23,
	0xE3,0xA0,0x32,0x93,0x64,0xBD,0xA5,0xFA,0x90,0x3A,0xD6,0x55,0x9A,0x09,0xFB,0x2F,0x2B,0x16,0xBA,0xCC,
	0xDC,0x4B,0x9D,0x7B,0x68,0xEA,0x10,0xB4,0x24,0xA3,0x64,0x81,0x8A,0x45,0x64,0x5A,0x50,0x0E,0x8C,0x18,
	0x05,0x40,0xEC,0x47,0x32,0x58,0xFA,0x78,0xAC,0x82,0xFC,0xA1,0x0C,0xE0,0xEB,0x5F,0x1F,0x9A,0x71,0x35,
	0x31,0x3B,0x99,0x5E,0xD9,0x35,0xFE,0xB8,0x81,0xBC,0xA3,0x52,0xE6,0xF8,0x55,0x41,0x81,0xD7,0x9A,0xC0,
	0xCC,0xEE,0x99,0x7B,0xC8,0x70,0xC0,0xBB,0x29,0x1A,0x09,0x46,0xA9,0xC9,0x86,0x05,0x03,0xEE,0x0C,0xA8,
	0x26,0xB1,0xE0,0x74,0x27,0x59,0x33,0x91,0xF4,0x17,0x78,0x12,0x46,0x1D,0xB2,0xFC,0x82,0x48,0x11,0xC3,
	0xDA,0x6D,0x67,0x3D,0x2E,0xC7,0x79,0x15,0xEE,0x70,0x88,0x52,0xEE,0xDC,0xA7,0x88,0x48,0x72,0xC1,0x36,
	0xA6,0xFD,0xB7,0x20,0x39,0x32,0x26,0xF6,0x1C,0xC7,0x58,0xD9,0x68,0x36,0xC3,0x20,0x63,0x56,0x98,0x25,
	0x1B,0x35,0x6D,0xCE,0x62,0xB1,0x68,0x58,0x0D,0x52,0x7C,0xF8,0x1D,0x26,0x18,0x76,0xA2,0x5C,0xA9,0xCC,
	0xD5,0x05,0x67,0x13,0x62,0x5F,0x91,0x9E,0x45,0xC7,0x84,0xAA,0xE9,0xC9,0x4B,0x0E,0x72,0xCE,0x58,0x90,
	0xC5,0xDE,0x11,0x7A,0x90,0xC5,0xBA,0xA5,0x92,0xE4,0xD1,0x1F,0xB3,0x7D,0xDA,0x1C,0x4C,0xCD,0x31,0x99,
	0x73,0x03,0xC3,0x59,0xCE,0x2B,0xC0,0x75,0x40,0x8E,0xBB,0xA8,0x18,0xE3,0x48,0x63,0x65,0x57,0x88,0xC1,
	0xDC,0x27,0x9A,0xE7,0xEA,0xC8,0xEF,0x4E,0x8F,0x7D,0x36,0x0F,0x8B,0x15,0x40,0x14,0x02,0xE2,0x86,0xAF,
	0x33,0xD5,0xFE,0x6C,0xCE,0x95,0xBE,0xC2,0x6F,0xC1,0x14,0xBE,0xA0,0x18,0x60,0xA4,0xD7,0xCB,0x2A,0x97,
	0x39,0x92,0xF1,0x8B,0xBC,0xBC,0x03,0xAF,0x1B,0x8A,0x6F,0x33,0x2D,0xE3,0xBB,0x1A,0x6F,0x04,0x9E,0xE2,
	0xB0,0x04,0xA1,0x19,0xD0,0x73,0x35,0x6D,0xD5,0x73,0x6D,0xE0,0x70,0x7B,0xB8,0x7F,0xFB,0xCC,0xF0,0x80,
	0x10,0x99,0xFA,0x92,0x08,0x4D,0x23,0x5B,0x0C,0xC6,0xD9,0x57,0x7C,0xC2,0x3F,0x0A,0xC1,0x72,0x67,0x21,
	0x15,0x92,0x8D,0x54,0x09,0x4C,0x20,0x83,0x3C,0x18,0xE8,0x32,0x31,0xF5,0x41,0x15,0x01,0x18,0x8F,0xAB,
	0x13,0x70,0x7A,0x89,0xAD,0x26,0x61,0x11,0xCD,0x8C,0x83,0x21,0x6F,0x64,0xC8,0xB7,0xFC,0xCD,0x1C,0xBA,
	0xD2,0x16,0x2C,0xA4,0x07,0x50,0xFB,0xF9,0x4A,0xA5,0x7D,0x4A,0x3B,0xE8,0x16,0xEE,0x15,0x7A,0x86,0xA6,
	0x6F,0x0F,0xF4,0xB5,0x83,0x94,0xDE,0xA8,0xEE,0x3E,0x9B,0xFC,0xF0,0x36,0x3A,0xB0,0xD0,0x8A,0x7F,0x69,
	0xF4,0x34,0x6F,0x69,0x3A,0xB2,0x01,0x44,0x11,0x61,0x73,0xC9,0xC4,0x48,0x66,0x05,0xB4,0x71,0xC7,0x69,
	0x16,0xC9,0xEA,0x52,0x40,0x5B,0xC6,0x86,0xED,0x03,0x51,0x9E,0xFF,0xA8,0xF2,0xFF,0x01,0x53,0x91,0xD0,
	0x50,0x3B,0x7D,0x1E,0x3B,0x67,0xFB,0xF8,0x9A,0x42,0x99,0xD7,0x29,0x3E,0x11,0x55,0x1E,0x9E,0xEB,0x0D,
	0x3B,0x41,0x0E,0xD1,0x9C,0x0E,0x07,0x2A,0x30,0x26,0xEA,0x24,0x90,0x7D,0x8C,0x16,0xFE,0x4C,0x2E,0xE7,
	0x3B,0x43,0x58,0x1E,0xDE,0xB6,0x96,0x8D,0xAA,0x9D,0x75,0x21,0x60,0x0D,0x58,0x46,0xFF,0x1B,0xA1,0xC1,
	0xAB,0xAD,0x64,0x90,0x65,0xBC,0xD6,0x69,0x82,0x0E,0x9B,0x52,0x90,0x5B,0x62,0xBE,0x15,0xAD,0xB1,0xC6,
	0xC8,0x3A,0xFD,0xD2,0x6E,0x0C,0x15,0xC0,0xA9,0x3B,0x7E,0x76,0x74,0x0E,0xC3,0x1F,0xF0,0x75,0x71,0x4A,
	0x5A,0x2C,0x15,0xDD,0xBE,0xA0,0x18,0xE3,0x07,0xBC,0x8A,0xD7,0xD7,0xE5,0xC2,0xDC,0x67,0x40,0x57,0xA1,
	0x96,0xD6,0x29,0x34,0x02,0x14,0x8E,0x30,0x23,0x25,0x86,0xC8,0xA8,0x36,0xA7,0x9E,0x13,0x08,0x1E,0x60,
	0x49,0x88,0x9B,0x19,0xCE,0xC0,0xBE,0x6E,0x0F,0xA1,0x61,0xB1,0x93,0x98,0x1E,0x6E,0x2C,0x8F,0x11,0xEA,
	0x31,0xEF,0xA1,0x48,0xFD,0x5A,0xE6,0xB1,0x07,0x63,0x50,0x18,0x7A,0x17,0x08,0xA1,0xC4,0x01,0x73,0x19,
	0x4A,0x94,0x26,0xAC,0x75,0x4E,0x63,0xE8,0x12,0xE6,0x6A,0xAB,0x55,0xA6,0xF1,0x85,0x08,0x84,0x19,0x1C,
	0xD0,0xA7,0xBE,0x99,0x73,0x68,0xAE,0x52,0xA5,0xF2,0x7F,0xCA,0x2B,0x94,0x40,0x16,0x4E,0x8E,0xF5,0x34,
	0x06,0x55,0xDC,0x9D,0xAA,0x4D,0xC5,0x5E,0xAB,0xF4,0x15,0x12,0xE8,0x8E,0x4F,0x3B,0xB0,0x39,0xCD,0xF1,
	0x2D,0x7D,0x58,0x1D,0x86,0x0C,0xDF,0x20,0x6A,0xB8,0x70,0xD8,0xEA,0x12,0x10,0x27,0x9E,0x2D,0xEB,0xF7,
	0x4A,0xB5,0x04,0xAA,0x7A,0xAC,0x53,0x6F,0xBD,0xAE,0x80,0xEE,0x55,0xD8,0x35,0x2F,0xBB,0x90,0x77,0x5C,
	0x4A,0x1E,0x6B,0x0E,0x5A,0x37,0x6A,0xD1,0x33,0xE8,0x7B,0x47,0x59,0x07,0x38,0xA3,0xB4,0xD5,0xA3,0x28,
	0x48,0xC2,0xBB,0x8A,0x88,0x20,0x4B,0xAC,0x0A,0xDC,0xE0,0x58,0x25,0x80,0xA7,0xAF,0x3F,0x02,0x6D,0x94,
	0x03,0xCB,0x21,0x6C,0x08,0x9E,0xEB,0xCF,0x0D,0xCD,0x5E,0x45,0x01,0x5B,0x5F,0xA3,0x58,0x49,0xEA,0x51,
	0xCC,0x28,0x54,0x2B,0xB5,0xF4,0xAC,0xF8,0x9F,0x95,0xF5,0x17,0xC2,0xE6,0xF8,0x59,0xEA,0x6E,0x62,0x8E,
	0x42,0x30,0x53,0x3A,0xFE,0x29,0xC8,0xC2,0x10,0x21,0x09,0x5A,0x6C,0x07,0xE9,0x04,0x58,0x17,0x22,0x38,
	0x16,0x07,0x96,0x54,0xBE,0x4C,0xC9,0xC7,0x2B,0x10,0x0A,0x07,0x06,0x38,0x0B,0x08,0xD7,0x2B,0x5C,0x21,
	0x17,0x5B,0x5F,0xD8,0xA8,0x3E,0xE6,0x78,0x5F,0xF1,0x08,0xFC,0xFD,0xCD,0xEF,0xDA,0x74,0x04,0x37,0xC5,
	0xC1,0xA2,0x01,0xD0,0xEF,0x49,0xBC,0x82,0x89,0x60,0x5D,0x15,0x7A,0x37,0xC5,0x11,0xCA,0x94,0xEB,0x3B,
	0x1D,0x56,0x83,0x75,0xCA,0x7E,0x16,0xDE,0x89,0xB1,0xAC,0xCE,0xC3,0xD0,0x4B,0xBB,0x46,0x52,0x61,0xA6,
	0xFD,0x67,0x68,0x30,0xC0,0xDD,0x6E,0xBA,0x32,0x6B,0x28,0x48,0x37,0xA2,0x46,0xA7,0xE6,0xFD,0x96,0x56,
	0xE9,0x8B,0x76,0x91,0x1A,0x02,0x19,0xEF,0xD5,0x63,0xA3,0xB3,0x1D,0xA2,0x2E,0x1A,0x81,0x17,0x56,0xBD,
	0x2B,0x63,0xDB,0xB9,0xED,0x9D,0x8D,0xAF,0xD3,0xB9,0x8C,0xD1,0xDD,0x79,0x0E,0x03,0xC2,0xE9,0xCB,0x3D,
	0x5C,0x7E,0x27,0x74,0xFE,0x43,0xC1,0x8E,0x90,0x77,0xA4,0xEF,0x57,0xA5,0x16,0xFF,0xB1,0xED,0x74,0xEA,
	0x37,0x47,0xA8,0x45,0xFE,0x6E,0x29,0x73,0x8A,0x3B,0x04,0x5A,0x91,0xC4,0x56,0x49,0x55,0xFA,0x05,0x5D,
	0x8D,0xB0,0xBE,0xA9,0x2D,0x6E,0x14,0x00,0x20,0x83,0x7A,0xB0,0xD5,0xF8,0x7A,0x6F,0x45,0xD4,0x24,0xF5,
	0xE9,0x72,0xE0,0xEB,0x24,0xC5,0x10,0x48,0x44,0x7D,0x33,0x0C,0x1A,0x53,0x52,0x54,0x46,0xD4,0x5B,0x3D,
	0x8E,0x55,0x44,0x02,0xFC,0x3C,0xC2,0xEC,0x96,0x12,0x96,0x12,0x78,0x3B,0x91,0x30,0x44,0x2D,0x23,0x50,
	0xF6,0x23,0x55,0x05,0xE2,0x91,0xA9,0x74,0x27,0xFA,0xBE,0x69,0x5F,0x70,0xE6,0x14,0x32,0xA4,0x66,0x8B,
	0x3D,0x82,0x84,0x90,0x7F,0x05,0x01,0x77,0xA0,0xE1,0xC6,0xBC,0x96,0xE7,0x32,0x34,0xAF,0x08,0xED,0x5A,
	0x03,0xC6,0xB8,0xC2,0x56,0xEB,0xE4,0x14,0x6C,0xB9,0x0E,0xAF,0x28,0x44,0x0A,0x51,0x71,0x8A,0xAE,0x5E,
	0xC2,0x4B,0x8C,0xAA,0x64,0x64,0x2E,0xC2,0xA3,0x88,0x0B,0x3E,0x31,0xBE,0x62,0x63,0x83,0x2D,0x7E,0xF5,
	0xCD,0x67,0xCE,0x4E,0x4A,0x67,0x7B,0x62,0xEC,0x43,0x71,0x5D,0x49,0xC2,0xF7,0xB0,0x37,0x33,0x57,0xE5,
	0x84,0x1A,0xFF,0x2B,0x65,0xDE,0xD6,0x70,0x8A,0x2F,0x18,0x99,0x81,0xA2,0x4A,0x56,0x8C,0xF3,0x2A,0xF5,
	0xFC,0x00,0xE6,0xC7,0x0D,0x86,0x6B,0xA6,0x5C,0xD3,0x26,0xA0,0xE6,0xE5,0x8B,0x91,0x02,0xB9,0x33,0xE2,
	0xE2,0x90,0x90,0xF2,0x57,0x62,0xF1,0x02,0x7D,0x78,0x66,0xF6,0xB2,0xDE,0xD8,0xEB,0x32,0xA1,0x6D,0x8A,
	0xA2,0xF4,0xB4,0x32,0x68,0xA6,0x2A,0xF0,0x1A,0x38,0x88,0x98,0x60,0x2E,0x33,0x96,0x94,0xD7,0x9F,0x05,
	0x7D,0x23,0x3C,0x67,0x30,0xE8,0x8A,0xE4,0x97,0x47,0x6C,0xFC,0xC5,0xB9,0x73,0xB6,0x0A,0xFB,0x66,0xBA,
	0xED,0x71,0x54,0xCE,0xFE,0x57,0x12,0x17,0x3D,0x06,0x8D,0x40,0x4A,0xE1,0xA5,0x16,0x6F,0xC9,0xAA,0x8A,
	0xE2,0xA5,0xE3,0xB8,0x11,0x65,0xC0,0x05,0x26,0x41,0x4D,0x13,0xC9,0x01,0x9C,0x2F,0x0B,0xB2,0xF9,0x91,
	0xA6,0x69,0x22,0x44,0x12,0x7B,0x41,0xED,0x49,0xE3,0x83,0x88,0x03,0x23,0x51,0x00,0x2C,0x0E,0x18,0xC9,
	0x20,0x72,0x8B,0x76,0x11,0x8C,0x3B,0x26,0x4D,0xC7,0x94,0x8B,0x85,0x69,0xA7,0xC5,0x25,0x0F,0x39,0x26,
	0x12,0xC9,0x01,0xCE,0x96,0xE0,0x94,0xE7,0xB7,0x46,0x76,0x6C,0x9A,0x41,0x77,0xB8,0x0D,0x22,0x4D,0x93,
	0x03,0x12,0x26,0x43,0xC9,0xB2,0x34,0x4D,0xD3,0x44,0xCE,0xA7,0xDF,0x26,0x33,0xF8,0x44,0x9A,0x26,0xD2,
	0x06,0xD7,0x8A,0xBF,0xC1,0xEC,0xA9,0xF0,0x6D,0xF8,0x89,0xE4,0x66,0xC9,0xF3,0xF5,0xCB,0x49,0xE4,0x96,
	0xDD,0x0A,0x2B,0x48,0xCE,0xF3,0x9D,0x52,0xA3,0x5E,0xDB,0x5B,0xEB,0x41,0x06,0xA3,0xC1,0x59,0xDF,0x69,
	0x9A,0xBB,0x8D,0x1E,0xD3,0x53,0x80,0x82,0xA4,0x05,0xF5,0x74,0xF7,0xBE,0x03,0x63,0x85,0x75,0x97,0xFD,
	0x43,0x6B,0x99,0x4F,0xC8,0xEF,0xB0,0xD2,0xBF,0x9E,0x97,0x71,0x1B,0xE2,0x77,0xA5,0x51,0xE1,0x24,0xEF,
	0xA8,0x77,0xC4,0xC3,0x03,0x03,0x78,0x43,0x34,0x4C,0x41,0xB0,0xD4,0x9E,0xD2,0xAF,0x2C,0x69,0xCC,0x04,
	0x83,0x25,0x63,0x1A,0xBE,0xDC,0xD4,0x1F,0x99,0x7F,0xDD,0x59,0x17,0xA3,0xF9,0x99,0xAD,0x80,0x9B,0xFC,
	0xB9,0xA7,0x78,0xAD,0x9D,0x79,0xB0,0x9A,0x5F,0xCF,0xAC,0x3E,0x68,0x37,0x11,0x55,0x50,0xB0,0xA3,0x97,
	0xD9,0xA6,0x90,0xA4,0x88,0x05,0x89,0x9F,0xA7,0x65,0x86,0x89,0x42,0x32,0x6A,0x55,0xB5,0xF2,0xC0,0xCA,
	0xF0,0x00,0x3A,0xFC,0x4A,0xFD,0xC7,0xF2,0x32,0x59,0xBA,0x64,0xBF,0xBA,0x88,0xB0,0xDC,0x6A,0x0C,0x81,
	0x54,0x45,0x25,0x89,0x21,0x1A,0x1F,0x0E,0x61,0x11,0x76,0xD1,0x3C,0x6E,0x51,0xFF,0x2A,0x18,0x21,0xE9,
	0x7D,0x78,0x8B,0x14,0x33,0xAA,0x78,0x38,0x24,0xFA,0x50,0x5F,0x8C,0x09,0xEA,0xE5,0xEB,0x5F,0x69,0xD1,
	0xEB,0x2F,0x52,0x33,0xCD,0x52,0x5C,0x96,0x55,0xE1,0x43,0x38,0x5B,0x38,0x90,0x83,0x30,0x90,0xF4,0x0C,
	0x00,0x6B,0x4F,0xED,0xAB,0x50,0x91,0x6A,0x84,0x48,0x0C,0xF5,0x4C,0x82,0x9E,0x03,0xD5,0x80,0xD7,0x03,
	0xA8,0x45,0x63,0x02,0x7E,0x10,0x70,0x93,0x8E,0xE9,0x81,0x04,0xF9,0x0C,0x47,0x7F,0xCF,0x7E,0x1A,0x42,
	0xDF,0x2A,0xCA,0xC3,0xFD,0xB6,0x5D,0xE7,0x07,0x46,0xF1,0x5C,0x60,0x49,0x4E,0x7D,0x05,0x14,0x88,0x54,
	0xD2,0x3C,0xFD,0xDF,0x13,0x08,0xBE,0x3A,0xB7,0xD4,0xD6,0x6A,0x96,0x54,0xFD,0x09,0x52,0xD5,0x2C,0x72,
	0x2D,0xDE,0xC3,0x3D,0x10,0xEE,0x2F,0xCD,0x14,0x63,0xE3,0xA6,0xE6,0x0E,0x1F,0x65,0x0D,0xB4,0x97,0x19,
	0xF9,0xC3,0x0A,0xB3,0x3F,0x9A,0xEB,0xF2,0x92,0xD7,0xE7,0x8F,0x79,0x55,0xCF,0xCF,0x1F,0xA0,0x08,0x6B,
	0xE4,0x25,0xF1,0x99,0x76,0x1B,0xBE,0xDA,0x9F,0x3A,0x72,0x25,0x09,0x58,0x8E,0xAC,0x75,0x65,0x5B,0x36,
	0x43,0xED,0xDE,0x95,0x45,0x01,0x8A,0x79,0x4B,0x55,0xEF,0xCC,0x3D,0x41,0xA9,0x00,0x06,0x13,0x75,0xB5,
	0xDD,0x1F,0xBD,0xB3,0x97,0xFE,0xD6,0xD7,0xD5,0xEE,0xAF,0xA9,0xE1,0xDF,0xA9,0x42,0x61,0x6F,0xD2,0x82,
	0xA5,0x0F,0x9D,0x0B,0x2E,0xD5,0x98,0x73,0xE9,0x7B,0x0D,0x2C,0x31,0xA7,0x18,0x49,0x33,0x96,0x70,0x26,
	0xF7,0x25,0x56,0xFB,0x9A,0xB9,0xFC,0x27,0xFF,0x76,0xF3,0x04,0x78,0x66,0xFD,0x85,0xF5,0x48,0x6F,0x5B,
	0xA2,0x4C,0xE4,0xBB,0xFE,0xDB,0xC7,0x35,0xB6,0x68,0xBB,0x2A,0x00,0x0C,0x0F,0xE6,0xEA,0x4C,0x06,0x13,
	0xF6,0x87,0x4A,0xB4,0x0C,0x33,0x06,0x3C,0x44,0x8C,0xE0,0x5A,0x82,0x3D,0x18,0x98,0x47,0x61,0x41,0x79,
	0x72,0x93,0x48,0x06,0x4B,0x3B,0x0D,0x0C,0xA6,0xCB,0x53,0x17,0x48,0xAF,0x9C,0x0A,0x2A,0x43,0x3C,0x67,
	0xE5,0x5F,0xEE,0x28,0x01,0x45,0x21,0xAF,0xAB,0x64,0x1C,0x7E,0x96,0xE1,0xD3,0xAA,0x72,0xC5,0x1A,0x46,
	0x16,0x32,0x2D,0xCE,0xB6,0x50,0x58,0xCC,0xAD,0xC7,0xBF,0xCD,0x28,0x1D,0x03,0x16,0x8E,0xD5,0x38,0x1B,
	0x47,0xC9,0x52,0xB1,0x33,0x85,0xBB,0xCC,0xCA,0x55,0x4B,0xA9,0x13,0x7B,0x76,0x40,0x5B,0x14,0xFE,0xE8,
	0x27,0x01,0x82,0x39,0x03,0x7E,0xFB,0x11,0xE3,0x1E,0x1F,0x76,0xAE,0x97,0x63,0x0B,0x98,0x5E,0xAA,0xEB,
	0xB3,0xC8,0x22,0x08,0xE9,0x82,0x2A,0x83,0xFE,0x0D,0xA1,0x0C,0x20,0xAD,0x40,0x00,0x45,0x24,0xCF,0x41,
	0x46,0xC3,0x49,0x54,0x0D,0x87,0xD6,0xBC,0x85,0x31,0xE3,0xBC,0xFD,0xED,0xC0,0x50,0xCB,0xB2,0xF8,0x3B,
	0x4A,0x69,0x96,0xBC,0xE6,0xD3,0xAC,0x5A,0x16,0xA9,0x2E,0xBF,0xA0,0xAC,0x50,0xD8,0xCC,0xEC,0x14,0x82,
	0x0A,0x35,0x07,0xE1,0x9A,0xAC,0x55,0x2B,0x30,0x80,0x03,0x83,0x29,0x1A,0x8C,0x35,0x23,0x30,0x6E,0xE0,
	0xC5,0x35,0xA5,0xD1,0x52,0x36,0x88,0x68,0x6C,0x30,0xA0,0xEB,0xD5,0x60,0xAD,0x46,0x59,0x77,0xC0,0xBE,
	0xCC,0x06,0x5D,0x84,0x71,0x63,0xB6,0xC3,0xD6,0x26,0x74,0xB7,0x7A,0x37,0xEA,0x2E,0x77,0xBE,0xF9,0xFD,
	0xE8,0x25,0x55,0x35,0x5E,0x5F,0x18,0x2A,0xEA,0x7F,0x89,0x7A,0x53,0xCF,0xCB,0xEB,0x40,0x15,0x85,0x91,
	0x15,0x1E,0x78,0x36,0x45,0x9F,0xB5,0x4E,0xDD,0x6A,0x2D,0x86,0xEF,0xBB,0x05,0xF0,0x92,0xDD,0x65,0x34,
	0x2D,0x00,0xEE,0xC2,0x3B,0x9F,0xE9,0xCD,0x90,0xA3,0x0B,0x6F,0xA5,0x19,0x35,0xB6,0xFD,0x3E,0x31,0xFC,
	0xAB,0x52,0x20,0xD5,0xA9,0x62,0x7D,0x71,0xA1,0xD8,0xD2,0x1F,0x16,0x8A,0xCE,0x8D,0x5C,0x82,0xAF,0xD8,
	0xA3,0xD8,0x69,0x29,0xDE,0x5C,0x0E,0x3E,0x45,0x84,0xB4,0x97,0x88,0x06,0x21,0xC7,0xB5,0x94,0xF7,0x9E,
	0x6E,0xC8,0x5D,0x9F,0x5E,0xF5,0xE1,0xCF,0xFB,0xB7,0xE7,0xF7,0xCD,0x04,0xF0,0xDB,0xA5,0x11,0xC0,0x06,
	0x72,0x29,0xBC,0xF6,0x76,0xF0,0x33,0x48,0xBD,0xEA,0x39,0x05,0x47,0x6A,0x6A,0xE8,0xA1,0x44,0x45,0xFD,
	0xC7,0xC0,0x77,0x8B,0xAA,0x0E,0xCD,0x79,0xD1,0x12,0xFD,0x10,0x73,0xD7,0x05,0x2F,0x2E,0x36,0x31,0x0B,
	0xD4,0x5D,0xAB,0x50,0x7F,0x20,0xEC,0xF0,0x1E,0x6E,0xEB,0xAD,0xE3,0xBB,0x47,0x7B,0x32,0xF0,0xEE,0xD4,
	0x1A,0x05,0xBE,0x20,0x0D,0xC6,0x44,0xDB,0x6C,0xED,0x55,0xA7,0x40,0x28,0x9D,0x1C,0x85,0x57,0x01,0x05,
	0x8C,0x30,0x0E,0x14,0x05,0x83,0x4B,0x17,0xD0,0x32,0x7A,0x66,0xD0,0xB5,0x74,0xF5,0x60,0x97,0x41,0xBD,
	0x98,0x9D,0x98,0x79,0x5F,0xD2,0x9D,0x16,0xE8,0xCF,0xF8,0x97,0x32,0xDE,0x0D,0x55,0xC6,0x41,0x8D,0xDD,
	0xCF,0x72,0x4C,0x55,0xE3,0xA8,0x2A,0x34,0x20,0x66,0x95,0xD6,0xA8,0x6C,0x18,0x5C,0x79,0x9A,0xA2,0x68,
	0x80,0x3A,0x34,0x70,0x1B,0xBF,0xEB,0x08,0xF6,0xC7,0xAA,0x01,0xBA,0x72,0x7F,0x27,0x79,0xA2,0xE0,0xDE,
	0x96,0x1A,0x8B,0x62,0x79,0x77,0x14,0x5D,0x13,0xA6,0x3E,0xEC,0xA7,0x9C,0xB0,0xC9,0x38,0x33,0x42,0x3B,
	0x66,0xD8,0xE9,0xE4,0x8D,0xF0,0x13,0x33,0xC3,0x1E,0x3D,0x36,0x97,0xB3,0xB7,0x15,0x52,0xED,0xE7,0xEE,
	0x63,0x43,0xCE,0xC4,0xAB,0xC3,0xF5,0x66,0x5F,0x65,0x8B,0x8A,0xE5,0x82,0x87,0xCB,0x98,0xA8,0xBC,0xBE,
	0xA2,0xBB,0x69,0x9E,0x94,0xB8,0x66,0x35,0x80,0x82,0xBC,0x3E,0xDD,0x3A,0x98,0xF9,0xB7,0xEF,0x46,0x7A,
	0x84,0x8B,0x45,0xCC,0x28,0xA2,0x94,0xAC,0x38,0x4A,0x0A,0x8A,0xC7,0xB6,0x1F,0xA6,0x8F,0x25,0xB2,0xA8,
	0x20,0x91,0x19,0x28,0xE5,0x2D,0x90,0xBB,0x55,0x8B,0x89,0x92,0xBB,0xE0,0xB5,0x81,0x5A,0x89,0x8A,0x90,
	0xAB,0x2D,0x9E,0x84,0x92,0xE6,0xD2,0x6E,0xFC,0x5F,0x41,0xA0,0x7A,0x92,0xC8,0x41,0x7D,0x0B,0x2E,0x17,
	0x6F,0xA7,0x6A,0x28,0x18,0x8A,0xE0,0xBF,0xA7,0x43,0x7D,0x17,0xB2,0xB7,0x28,0xC8,0x6A,0x91,0x3E,0x1D,
	0x0F,0xEB,0x90,0x85,0x83,0x19,0xFB,0x4E,0x6F,0x40,0x74,0xD4,0xD7,0x36,0x00,0xE2,0x72,0xF4,0x0F,0xAE,
	0x28,0x04,0x50,0x50,0x86,0x7E,0x26,0x68,0x08,0x99,0xA7,0x5A,0x1C,0xDA,0x32,0x10,0x55,0xE1,0xDC,0xAA,
	0xF3,0x2E,0x64,0x6E,0xC5,0x06,0x88,0xAB,0x19,0x21,0xD9,0x27,0xF8,0x84,0xCD,0x98,0x45,0x16,0x35,0xAA,
	0xFC,0x8D,0xEE,0x46,0xA1,0xD0,0x11,0x62,0xC8,0x08,0xE7,0xC8,0x75,0x4E,0x04,0x55,0x02,0xD5,0x3C,0x06,
	0xB8,0x2A,0x7F,0x5C,0x1A,0x11,0xC8,0xDD,0xA0,0x95,0x22,0x44,0x6D,0x1F,0x34,0x60,0xCC,0xE1,0xE5,0x22,
	0xC9,0x42,0xA5,0xAE,0xA5,0x32,0xA4,0x12,0x77,0xDB,0x65,0x7D,0x4A,0x21,0x6A,0xF0,0x5D,0x8A,0x7F,0xEE,
	0xAE,0x92,0x82,0x5F,0x02,0xDA,0xC3,0x1C,0xD7,0xFD,0xC6,0xFB,0xAA,0xB3,0xBA,0x03,0x33,0xB9,0x06,0x6A,
	0x16,0x67,0x6E,0x6F,0xB0,0x5B,0xEA,0xA3,0xB8,0xE6,0x12,0xAE,0x41,0xA2,0x03,0xEF,0xBD,0x85,0x7F,0x70,
	0xF4,0x6A,0xDD,0x7E,0x75,0x7C,0xEF,0x96,0x9E,0xF9,0x8A,0xD8,0x7B,0x4C,0x69,0xC6,0xF8,0x23,0xBA,0x10,
	0x95,0x6E,0x07,0x06,0x84,0xF6,0xE3,0x96,0x07,0xBB,0x91,0x94,0x88,0x78,0x70,0xE5,0x80,0x8D,0x84,0xCC,
	0x7F,0xF9,0x9F,0xAE,0x96,0xE5,0x5F,0xEE,0x7B,0xBD,0xEA,0x68,0xC6,0xCF,0x00,0xE0,0xAE,0xCA,0x80,0x99,
	0x75,0x7F,0xF4,0xFA,0x7F,0xC8,0x8C,0xA2,0xDC,0xED,0x6C,0x6C,0x91,0xAB,0x2B,0x8F,0x50,0xC3,0xCD,0x03,
	0x50,0x04,0x7E,0x78,0x7A,0x8D,0x7B,0x8E,0x90,0xC7,0x08,0xD8,0x70,0xFE,0xF9,0x55,0xD5,0x04,0x4A,0x15,
	0xDB,0xE3,0x16,0x48,0x1F,0x13,0x33,0xEE,0x68,0xD1,0x7C,0xB0,0x53,0x69,0xE1,0xD4,0x95,0x1A,0x7F,0x85,
	0x3A,0x64,0x0B,0x47,0x33,0x6D,0xAB,0xA5,0x9E,0x57,0x40,0x9F,0xE5,0x92,0xB0,0x79,0x15,0x26,0x0C,0xE8,
	0x71,0x46,0x45,0x69,0x6B,0xAE,0x70,0x21,0x72,0x21,0x69,0xFF,0x27,0x35,0x57,0x12,0xBE,0xEA,0x17,0xB3,
	0xBF,0x88,0x81,0x72,0xF4,0xA6,0xCF,0x08,0x02,0x22,0x50,0x03,0xCC,0xA5,0x19,0x46,0x04,0x6B,0x05,0xDA,
	0x31,0xBF,0x1C,0xE2,0x8E,0x64,0x5F,0xE6,0x21,0x1C,0x16,0x80,0x2E,0xD1,0xC6,0xFF,0x94,0x40,0x55,0x45,
	0x55,0xEE,0x2A,0x02,0x8D,0xC3,0x40,0x3E,0xDF,0x33,0xC8,0x77,0x08,0x1A,0x8C,0x38,0x03,0xB9,0x1A,0x8B,
	0xDF,0x07,0x62,0x86,0x6D,0x43,0x43,0xA5,0xEF,0x82,0x21,0x55,0xC7,0xC0,0x74,0xE5,0x46,0x1A,0x9A,0x86,
	0x5F,0x0D,0x5D,0x8A,0x98,0x10,0xC9,0xE5,0xF6,0x23,0xC3,0x6B,0xE0,0x6B,0x7D,0x7F,0x1B,0xF5,0x3A,0x5D,
	0xA2,0x39,0x69,0x7E,0xCD,0x38,0x14,0x86,0x15,0x25,0x14,0x89,0x6D,0x80,0x73,0x5E,0x65,0xC8,0x04,0x31,
	0x68,0x3B,0x26,0xD9,0x51,0x13,0x0D,0xCB,0x9E,0xD3,0x17,0xA1,0x9E,0x0A,0x45,0x28,0x2A,0x46,0xEF,0x25,
	0x47,0xA5,0x72,0xE6,0xAE,0x01,0x59,0x2E,0xAF,0x3A,0xFB,0xE4,0xC1,0x42,0xEE,0xBE,0x87,0xB1,0xFD,0x8B,
	0x30,0xD4,0x2A,0xD7,0xF3,0x55,0x55,0xE5,0xB5,0xBB,0x0A,0x24,0x9F,0x8B,0x38,0xEE,0x35,0xDA,0x04,0x5C,
	0x1D,0x83,0xBB,0xA0,0xD5,0x1B,0x63,0xCF,0x81,0x95,0xE5,0x93,0xFC,0x83,0x69,0xDC,0x67,0x10,0x42,0xCB,
	0xDB,0x31,0x7A,0xDE,0xD7,0xEC,0x0A,0x5D,0x31,0x95,0x4F,0xF0,0xF3,0xF4,0x3D,0xCD,0xEB,0xAB,0x61,0xE1,
	0x79,0x75,0x67,0xDD,0x71,0x2D,0xD8,0xE4,0x04,0x1F,0x2E,0xB1,0x2E,0xEF,0xFB,0x7E,0xCD,0x82,0x8C,0x3E,
	0xD0,0x98,0xF4,0xA5,0xD2,0x29,0x43,0x79,0x0C,0x0C,0x3B,0x31,0x7D,0xF1,0xAA,0xDC,0x8F,0xC6,0xE4,0xB0,
	0x55,0x97,0xC1,0x9E,0xBA,0x3F,0x74,0x27,0x24,0x31,0xD3,0x1D,0x18,0x71,0xB7,0x24,0x58,0xB0,0x0A,0xBC,
	0x42,0xA7,0x6D,0xC4,0x25,0x98,0x80,0xC1,0x43,0x73,0x63,0x08,0x19,0xA2,0xCD,0x61,0x1A,0xDE,0x72,0x5D,
	0xE5,0x4B,0xE0,0x98,0x72,0xC3,0xAA,0xCA,0x3C,0xD2,0xD3,0x5F,0xBB,0x78,0x77,0x6A,0xD5,0x08,0x26,0xB4,
	0x3F,0x64,0x45,0xB5,0xBE,0xCF,0xA6,0xD6,0x58,0x0A,0x1F,0x82,0xF8,0xF5,0xCD,0xDE,0x9B,0x4C,0xEF,0xEF,
	0x2F,0x2A,0xB8,0x14,0xA3,0xCC,0xB9,0xFC,0x75,0xBA,0xB0,0x08,0xA3,0xFD,0x80,0xD2,0xEC,0xFE,0xAE,0x08,
	0x0C,0xF1,0xEA,0xC7,0xB4,0xCB,0x97,0xD0,0x9C,0xE8,0xC6,0x2D,0xF7,0x58,0x5D,0x7C,0x13,0xEC,0xCA,0xF1,
	0xF0,0x74,0xA4,0x6C,0x96,0x1F,0x5F,0x5F,0x33,0xF6,0xCB,0xD6,0x8D,0x99,0xB6,0xD1,0x81,0xCA,0x52,0x59,
	0x42,0x57,0x40,0xB5,0xF3,0x99,0x2D,0x1C,0x5B,0x87,0x63,0x23,0x8E,0x31,0xFA,0x67,0x35,0x2F,0x21,0xD1,
	0x59,0x7C,0xEC,0x70,0xAE,0xF1,0xEF,0x77,0x0E,0xFD,0x5E,0x0D,0xD0,0x30,0x21,0x22,0x73,0xAD,0xAD,0x7E,
	0xE0,0x5E,0x28,0x23,0xC6,0x1F,0xC1,0x1F,0x45,0x21,0x52,0x31,0x94,0x3A,0x9E,0xD3,0x99,0x4C,0x80,0x02,
	0x49,0xF6,0xFB,0x1F,0x4C,0xF4,0x50,0x66,0xF5,0xFA,0x42,0xB6,0xB3,0x82,0x48,0x82,0x7E,0x5F,0xB5,0x07,
	0x0A,0xD7,0xBC,0xBF,0xDC,0x15,0x15,0x7D,0xD5,0xBC,0x3D,0xC6,0x23,0x95,0xA8,0xE7,0xAF,0xE1,0xAF,0x7C,
	0x47,0x66,0xBE,0xE1,0x4A,0xFF,0x1A,0x8C,0xB1,0x8A,0x54,0x1E,0x18,0xB2,0x27,0x94,0xBE,0xBE,0xB2,0x0C,
	0x07,0x54,0xFF,0x1B,0x4A,0x62,0xED,0xFD,0xEF,0x30,0x5E,0x10,0x11,0x82,0x7C,0x04,0xB8,0x69,0x57,0xE7,
	0x20,0xBB,0x9D,0xA2,0xDC,0xB9,0x83,0x8A,0xD6,0x2D,0xC0,0x06,0x4F,0xE3,0xE6,0x86,0xAA,0x81,0x61,0x42,
	0x5C,0xDF,0xED,0x0E,0xC1,0xE8,0xA9,0xE7,0x8A,0xB4,0xF9,0xC2,0xCC,0x4C,0x7F,0x0A,0xFD,0x03,0x3A,0x87,
	0x7D,0xF4,0x3B,0x30,0xD1,0xEF,0xBC,0xB2,0xB3,0x24,0x36,0xB9,0x9A,0xC3,0x69,0xA7,0xAC,0x28,0x77,0xA6,
	0x60,0xE0,0xE9,0xDD,0x1C,0xE1,0xEC,0x2A,0x94,0x9D,0x90,0xAC,0xED,0x41,0xF9,0x7D,0x81,0xE1,0xD3,0xEF,
	0x1D,0x86,0xBF,0x1A,0x34,0xDC,0x5D,0x57,0xD0,0x77,0xB9,0xA8,0x69,0xEA,0xAF,0x8E,0x4A,0x86,0x34,0xE6,
	0x49,0xF7,0xC0,0x62,0xE5,0xAE,0xAF,0x6C,0xAD,0x9F,0xC4,0xBA,0xC2,0x77,0xDB,0x0F,0x23,0x15,0xD3,0x55,
	0x49,0xD8,0x68,0x88,0x95,0xAA,0x4E,0xD7,0xFE,0x49,0x40,0xB7,0x4E,0x5D,0x05,0xC5,0x84,0x8A,0xB1,0x27,
	0xF9,0x20,0x9A,0x1F,0xBF,0x79,0x14,0xD8,0x55,0x84,0x84,0x1C,0x8E,0xDF,0x34,0x91,0x68,0xA0,0x61,0x33,
	0x45,0xC6,0x79,0xD3,0x76,0xDD,0xFF,0x4B,0x07,0x50,0x5B,0x4B,0x57,0x61,0x67,0x24,0xA3,0xFB,0x4F,0x91,
	0x94,0x76,0x77,0x32,0x53,0x55,0x85,0xF7,0x45,0xE5,0x39,0x3D,0x72,0x23,0x64,0xC5,0xDD,0xCF,0x47,0xC3,
	0xED,0xE7,0x8D,0x60,0xD8,0xFC,0xA1,0xF6,0xB3,0x72,0xD7,0xAC,0x3A,0x47,0x65,0x11,0x73,0x85,0xAF,0x3D,
	0xC9,0x52,0xFA,0x61,0xE1,0xE3,0xAE,0x41,0x50,0xE9,0x1D,0xD7,0xD9,0x75,0x24,0xEB,0xBF,0x2F,0xFE,0x2A,
	0x87,0x0E,0xD6,0x8A,0x38,0x52,0xBB,0x0F,0x24,0x3C,0xC8,0xC2,0xBE,0x78,0xCA,0x1C,0xE5,0x44,0xBB,0x2E,
	0x8E,0x36,0x63,0x6B,0x15,0x2F,0x59,0xFD,0xB7,0x6F,0x68,0x98,0x15,0xC2,0x7F,0x53,0xE7,0xAE,0xF2,0x26,
	0xB6,0x57,0x20,0x48,0xC3,0x12,0x72,0xD7,0x61,0x71,0x91,0x5F,0x70,0xDE,0xAF,0x9D,0x0C,0x36,0x05,0xD2,
	0x34,0x44,0x84,0xFE,0xA2,0xF2,0x23,0xB1,0xF5,0x1F,0x7E,0xF7,0xCD,0xF3,0xE7,0xA6,0xFA,0x75,0x52,0x3C,
	0x89,0x31,0xCF,0xE1,0xF9,0x30,0x33,0xA4,0x27,0x6B,0x03,0x28,0x69,0x6E,0x47,0xFC,0x7F,0x08,0xA0,0x12,
	0xEA,0xAE,0x94,0xBF,0x94,0xA2,0x91,0x8D,0x9E,0x8E,0xC8,0x7A,0xEB,0xAE,0x80,0xF9,0x74,0x40,0x4B,0xB0,
	0xFA,0xEF,0xF1,0xFF,0xE2,0xED,0xBF,0x13,0x43,0xCE,0x7C,0xF0,0xE1,0xC1,0x05,0x7D,0xD8,0x11,0xC3,0xEF,
	0xFD,0xE1,0x21,0xC6,0x1B,0x4F,0xDE,0xC8,0xE7,0xAD,0xDA,0xFB,0x4F,0xCE,0xD1,0x01,0xC7,0xC8,0xDD,0x4A,
	0x2C,0x0D,0xE5,0xDC,0xE1,0x33,0x80,0x92,0xB4,0x34,0x76,0x2C,0x64,0x63,0x05,0xEA,0xC0,0xA6,0x24,0x7F,
	0x0E,0xD4,0x67,0xD7,0x23,0x3F,0x01,0x06,0x46,0x45,0x07,0x56,0xC6,0xFB,0xBB,0xB7,0xEF,0x70,0x50,0x57,
	0x1D,0x1D,0x3D,0x2A,0xCA,0xFC,0x4F,0xDD,0x8D,0x7D,0xD5,0xC2,0x52,0x9F,0x06,0x79,0xAA,0x28,0x09,0x6B,
	0xF0,0xBF,0x11,0xB8,0x34,0x63,0x5F,0x10,0xE7,0x89,0x02,0x27,0x69,0x39,0x8C,0xDD,0x6C,0x4B,0x2D,0xAF,
	0x2F,0x4E,0x0A,0xD6,0x7D,0x4C,0x40,0x1A,0x30,0xD2,0xF4,0xC2,0x68,0x30,0x34,0x6C,0xEA,0x2F,0x88,0x74,
	0x5E,0xBE,0xF8,0xAC,0x62,0x58,0xA9,0x76,0xA2,0x7D,0x95,0xC0,0x34,0x66,0xAE,0xD4,0x78,0xDA,0x06,0xD6,
	0x0B,0x5A,0x76,0xD3,0xA6,0xF6,0x81,0x71,0xCB,0xD6,0xCD,0xD0,0x60,0xDC,0xF6,0xBD,0xA4,0xAB,0xDF,0xB0,
	0x41,0x96,0xE8,0x1C,0xEB,0x1A,0xB3,0xA7,0x6C,0xF7,0x4D,0x13,0x02,0x1B,0xA8,0x1A,0x8D,0xCE,0xEB,0xF6,
	0x60,0xD4,0xD7,0x17,0xB2,0xC9,0xDF,0xC8,0xDE,0x00,0x23,0x9B,0xBA,0x39,0xF8,0xAF,0x25,0x95,0xF7,0x15,
	0x0B,0x28,0x33,0xF8,0x52,0xA0,0xEB,0x57,0xF7,0x85,0x1A,0xC3,0xC6,0xD0,0xBE,0xB7,0x2D,0x2E,0x5E,0xCC,
	0xEF,0x0C,0x64,0x5C,0xCC,0x7E,0x23,0xFD,0xBE,0xFA,0x19,0x03,0x03,0x09,0x0C,0xBD,0x40,0x3A,0xFB,0xCD,
	0xA8,0x38,0x59,0x4E,0xEC,0x06,0xC3,0x73,0x32,0x7B,0x24,0x66,0x04,0xA3,0x02,0x58,0xEB,0x81,0xDA,0xF7,
	0x88,0xFF,0x2A,0xF4,0xC3,0x46,0x41,0xC7,0xE8,0xAE,0x43,0x16,0x7F,0xD6,0xD5,0xAC,0x85,0x20,0x14,0x17,
	0x62,0xF9,0x3C,0x60,0x77,0xA2,0x88,0x10,0xE2,0x3D,0x88,0x22,0x45,0x44,0x32,0x7E,0x0B,0x7C,0xE7,0x41,
	0xA5,0x0D,0xD4,0x29,0xAA,0x05,0x54,0xD0,0x48,0x94,0x57,0x62,0x07,0xD9,0x90,0x41,0x0F,0xE4,0xD4,0x25,
	0xF7,0xFE,0x76,0x89,0x8A,0x88,0x66,0x72,0x38,0xB1,0xB2,0x5D,0x5D,0x82,0x88,0x63,0x88,0xA2,0xBD,0x53,
	0x5F,0x8A,0x4A,0x0F,0x85,0xD1,0x62,0x47,0x5D,0x8A,0xCA,0x0F,0x0D,0x10,0x04,0x51,0x88,0x0C,0x7F,0x04,
	0x63,0x81,0x92,0x22,0x40,0xD4,0x4B,0x25,0xEC,0x87,0x80,0x26,0x7D,0xDF,0x0F,0x48,0xE5,0xAB,0xAA,0xA5,
	0x09,0xEB,0x2E,0x3A,0x58,0x02,0xAE,0x6F,0xA0,0xF7,0x53,0x3A,0xDA,0x02,0x34,0x0C,0xA1,0x00,0x7E,0x28,
	0xDA,0xE1,0x16,0x93,0xFE,0xD7,0xE8,0x3D,0x02,0x61,0x3C,0x44,0x7F,0xA1,0xE6,0x0D,0x23,0x04,0xC8,0x4F,
	0x71,0xE9,0xE1,0xBB,0x94,0xA7,0x3D,0xD7,0x65,0x8B,0x3D,0xC2,0x65,0xB9,0x68,0xC6,0xB9,0xEF,0x2D,0xD6,
	0x80,0x55,0x1C,0xEC,0xAF,0x1A,0x8C,0xBF,0xBF,0x35,0x3E,0xDE,0xB1,0x38,0xF7,0x79,0x08,0xD5,0x4C,0x34,
	0x28,0xFF,0x57,0x0F,0x37,0x46,0x83,0xB9,0x17,0xD0,0x14,0x32,0x9C,0xA7,0xB1,0xFD,0xE1,0x09,0x4C,0x82,
	0x42,0xE8,0x69,0xDB,0xAB,0x06,0x2F,0x27,0x6C,0xDC,0x55,0x53,0x90,0x83,0xA7,0x04,0xAB,0x94,0x4F,0x47,
	0x8B,0xD6,0x94,0x93,0x74,0xCD,0x69,0xC1,0x99,0x20,0xD2,0x5E,0x51,0x5D,0x8E,0x24,0x76,0x3E,0x7A,0x5A,
	0x19,0x0B,0x49,0xA7,0xB3,0x36,0xF6,0xC7,0x45,0xB1,0x31,0x48,0x9A,0x78,0xE0,0x68,0x01,0x19,0x1C,0x02,
	0xA2,0x46,0x4D,0x37,0x63,0xAF,0x60,0x3C,0x4A,0x31,0x51,0x1F,0x10,0xD5,0x3A,0x06,0x3E,0x32,0xA2,0xC2,
	0x46,0x62,0x4E,0xDA,0x18,0x35,0x5D,0xEC,0x2E,0x7D,0xF9,0x69,0x3B,0x33,0x28,0xE0,0xDD,0x25,0x32,0x10,
	0x5C,0xF6,0x75,0x19,0xCB,0x73,0x46,0xD1,0xDD,0x00,0x9D,0xE1,0x3D,0x04,0xF5,0xDD,0x25,0xCD,0x3F,0xF9,
	0x75,0x38,0xD3,0xCA,0x80,0x27,0xC1,0x02,0x26,0xAA,0x19,0x13,0x2E,0x6B,0xDC,0x4F,0x3A,0xD5,0xD8,0x51,
	0x02,0xDC,0x57,0xF1,0x4B,0xC8,0x52,0x6A,0x1F,0xA2,0x8D,0x5D,0xB0,0xAA,0x38,0x47,0xBA,0x3A,0x60,0xD1,
	0x24,0xC2,0xEA,0xE8,0x45,0x4C,0x6F,0x7A,0x23,0x8B,0x8B,0xA2,0xC2,0x3E,0x1B,0x12,0x73,0x94,0x88,0xA0,
	0x8C,0x0C,0xA6,0x08,0x4B,0x45,0x46,0xF4,0xAD,0x03,0x5C,0xE2,0xB9,0xED,0xD5,0x61,0xAA,0x0D,0xF9,0xB9,
	0x4D,0x66,0xDC,0xA7,0x12,0x7E,0x6A,0xB2,0x32,0x9E,0xB2,0xD1,0x5F,0x18,0x47,0x2D,0xDB,0x4A,0xC0,0x14,
	0x14,0xF4,0x95,0x8D,0xB1,0x70,0x5B,0x73,0x6C,0xB7,0xAE,0x72,0x18,0x84,0x5F,0xC2,0xE1,0x3A,0x93,0x38,
	0x39,0xA2,0xB6,0xF0,0x74,0xFB,0xE0,0x5C,0xDC,0x18,0xC4,0x11,0x7E,0x63,0x81,0x8C,0x89,0xCD,0x36,0xCE,
	0xC4,0x70,0x39,0x69,0x2A,0x73,0x3E,0x04,0x38,0x79,0x55,0xCC,0x8F,0x33,0xCF,0xF7,0xBB,0xC5,0x74,0xF7,
	0xD4,0x77,0x18,0x28,0x82,0x91,0xFE,0xD2,0x1F,0x9E,0xD3,0x61,0x69,0x0D,0xD3,0x8C,0x97,0x99,0x49,0xAC,
	0x16,0x8B,0x69,0x75,0x30,0xB2,0xF3,0x06,0xCB,0x8A,0x9B,0xD8,0x9C,0xED,0xF9,0x34,0xFE,0x52,0x64,0xDF,
	0x20,0xD3,0x06,0xA7,0xB0,0x59,0x0A,0x8E,0xC7,0x47,0x08,0x4B,0xD5,0x4E,0x49,0xBC,0xB9,0x69,0x08,0x1C,
	0x48,0x49,0x58,0x23,0xA2,0xDC,0x8F,0xAF,0x92,0xA9,0x9D,0x74,0x18,0xF8,0x3F,0x2C,0xB6,0x3E,0x5C,0x78,
	0xD5,0x36,0xF9,0x16,0xA6,0xC1,0x59,0xFD,0x1E,0x9A,0xCE,0xE2,0xE9,0xD4,0xEB,0xB8,0xCD,0x21,0xDD,0xFB,
	0x21,0x44,0x93,0x53,0xCB,0xFB,0xF1,0xEA,0xE2,0xE3,0x81,0xEA,0xC7,0x26,0xF0,0x84,0xC5,0x28,0x72,0x55,
	0xF6,0xB6,0x20,0x21,0xC9,0x81,0xF4,0x78,0x6C,0x7A,0xF0,0x42,0xD9,0xB7,0xEA,0x12,0xCA,0xD6,0xA6,0xEB,
	0xD3,0x43,0x33,0x78,0x9E,0x87,0xBB,0xC1,0x41,0xF8,0x2E,0xD7,0x89,0x3A,0xBA,0x8A,0x65,0x22,0xC0,0x6A,
	0xAA,0xFE,0x13,0x8B,0xA5,0x09,0x08,0xD6,0xDC,0xEF,0x17,0x90,0xAB,0x9F,0xD6,0x57,0x61,0xB9,0x0E,0x39,
	0xD2,0xE7,0xDF,0x30,0xF2,0x11,0x6B,0x5C,0x97,0x6C,0x8C,0xB5,0x4A,0x9B,0xAF,0x1E,0x97,0xBE,0x1E,0x7C,
	0x58,0x97,0xC7,0x85,0x3C,0x4C,0x9C,0x80,0x99,0xFA,0xE4,0xD4,0x7C,0xAB,0xAE,0xC8,0x7C,0x4D,0x0B,0x0C,
	0x21,0xAC,0x34,0xD0,0xF5,0xDE,0x0C,0x82,0x5E,0x5F,0x22,0x4C,0x04,0x64,0xDC,0xC2,0xC5,0xD8,0xD8,0x2B,
	0xCF,0x23,0xA8,0xD3,0xAC,0xEF,0xC0,0x28,0x1E,0x98,0x4A,0x03,0x49,0x79,0x90,0x80,0xF8,0x09,0x7C,0x4D,
	0x25,0xFA,0x22,0x08,0x21,0xEE,0xDF,0x77,0xF0,0xBE,0x70,0xB9,0xCE,0xD0,0x14,0x8C,0x06,0xDE,0x9A,0x62,
	0xB3,0xB6,0x08,0x8C,0x6D,0x9E,0x3E,0x61,0xC2,0xEC,0x83,0xFD,0xA0,0x87,0x30,0xB1,0xD2,0x39,0x00,0xF9,
	0xA0,0xA8,0xCE,0x33,0xF6,0xAD,0x93,0xA6,0x6E,0x73,0x18,0x8D,0xB5,0x74,0x6E,0x7C,0x88,0x52,0x73,0xE3,
	0xD3,0x71,0x19,0xBD,0xAC,0x54,0x9E,0x70,0xAE,0x92,0x9A,0x69,0x57,0xDC,0x05,0x1D,0x58,0x10,0x86,0x3C,
	0xEB,0x83,0x09,0x51,0x0C,0x16,0x49,0x64,0x53,0x5A,0xB2,0xDF,0x74,0xA2,0x20,0x04,0x68,0x4E,0x8A,0x63,
	0x38,0x1F,0x09,0xFD,0x3F,0x9C,0x86,0x27,0xAE,0x84,0x77,0x15,0xD1,0xE1,0x48,0x8A,0x07,0xF7,0x4B,0x07,
	0x84,0xF3,0x30,0x36,0x03,0xE6,0x41,0x92,0x27,0x26,0x10,0xA6,0xA0,0x28,0x4C,0x50,0x16,0x05,0x04,0x64,
	0x50,0x0C,0x1C,0x4C,0xE3,0x15,0x29,0x04,0x13,0xEE,0x37,0x25,0x48,0x34,0x89,0x2E,0xA2,0x23,0xA2,0x23,
	0x28,0xA0,0x21,0x95,0x1E,0x93,0x56,0x8B,0x8A,0x09,0x09,0x8C,0xF3,0x7E,0xF5,0x16,0xB2,0xF9,0xE7,0x42,
	0x48,0x0E,0xC1,0x0B,0xAE,0xF4,0x70,0x36,0x24,0xE1,0xBF,0x83,0xD6,0x2A,0x3F,0x97,0xB4,0x06,0x54,0x88,
	0x66,0x8F,0xD8,0x38,0x4B,0x53,0x34,0x22,0xB0,0x9C,0x56,0x1D,0x6A,0x31,0xF0,0x5D,0x51,0x7F,0xEB,0x18,
	0x50,0xA3,0x0E,0xA8,0x2E,0xD6,0x03,0x6A,0x80,0x58,0xA0,0xC6,0x83,0x8D,0x64,0x40,0x98,0x39,0x2F,0xE3,
	0x80,0x7A,0x90,0x2E,0x0E,0x28,0x50,0x98,0x15,0x62,0x68,0x32,0xEA,0xE6,0xFD,0xA1,0xB6,0x7A,0x6D,0x6C,
	0xA6,0xAD,0x26,0x98,0x9A,0x3A,0xA0,0xBA,0xA3,0x93,0x8C,0x7D,0x1F,0xA3,0x56,0xE6,0x38,0xDC,0x48,0x32,
	0x3E,0x28,0x8A,0x83,0x14,0x69,0x92,0x6C,0xA7,0x94,0x70,0x52,0x82,0xA1,0x43,0xA8,0x2D,0x58,0xC5,0xFE,
	0x21,0xBF,0x2E,0xF2,0xA2,0x9C,0x53,0x61,0xCF,0x20,0x06,0x09,0x55,0x16,0x13,0x0B,0xF2,0x41,0xBD,0x29,
	0x84,0x79,0x1A,0xEE,0x64,0x7E,0x21,0x91,0x06,0x7D,0x80,0x4D,0x6B,0x38,0x5C,0x77,0xC5,0xE8,0x39,0xC0,
	0xD2,0x5E,0x75,0x7B,0x59,0x02,0xB0,0x5C,0x40,0xB3,0xCC,0x2D,0xFA,0x0A,0x36,0x40,0xA1,0x96,0x47,0xD0,
	0x14,0x0C,0x5F,0x08,0x00,0xB8,0x98,0x34,0xEC,0x08,0x5C,0xF1,0x91,0xB2,0x31,0x0D,0x46,0xEF,0xEB,0x68,
	0x37,0x24,0x89,0xA4,0x83,0xC8,0x41,0xF6,0xD1,0x11,0x49,0xC3,0xF5,0x18,0x17,0x4F,0xDE,0x49,0xD1,0x16,
	0xC1,0x90,0x84,0x7D,0xC4,0x0A,0xF9,0x3E,0x15,0x49,0x03,0x5D,0xC1,0x2D,0x3F,0x13,0xEE,0x8E,0xBB,0x5E,
	0xAA,0xA2,0x87,0x27,0x87,0x55,0xD7,0xF3,0x69,0x8E,0xA5,0x60,0x6E,0xB0,0x3F,0xAF,0x39,0xAC,0x03,0x63,
	0xA9,0x20,0x54,0xA4,0x78,0x3D,0x35,0x2D,0x80,0x1A,0x79,0x18,0x7E,0x41,0x65,0x88,0x99,0x3D,0xDD,0x28,
	0x3E,0x6D,0xA4,0x2F,0x07,0x19,0x44,0x8A,0x7C,0x7B,0x39,0x29,0x63,0xB0,0x52,0x90,0x3B,0xA4,0x86,0x45,
	0xA8,0xFE,0xA9,0xE3,0x51,0xD3,0x44,0x1F,0x03,0x06,0x02,0xAD,0xC0,0x60,0x08,0xBE,0xB7,0xB7,0x71,0x18,
	0x35,0x46,0x13,0xA4,0xE4,0xF1,0xE2,0x67,0x88,0x3B,0x3D,0x44,0x05,0x71,0xC9,0xC0,0xF0,0x14,0xEC,0x2B,
	0x20,0x83,0x26,0x41,0x19,0x1F,0x12,0x5A,0xBC,0x1D,0x0F,0xA2,0x6F,0xA4,0x9F,0x21,0x8E,0x08,0xBE,0x49,
	0xE2,0x21,0x1E,0xB2,0x59,0xA8,0xBB,0xF3,0x21,0x3E,0x68,0x8F,0x90,0x33,0x20,0x21,0xB9,0xE2,0x2B,0x2D,
	0x1B,0x04,0x0D,0xC6,0x1D,0x3B,0x0D,0xAF,0xF8,0x3E,0xE0,0x11,0x00,0xF5,0xF3,0xA0,0x13,0xED,0xA2,0x82,
	0x84,0xB8,0x19,0x10,0x10,0x21,0x21,0x0A,0x12,0x29,0xB2,0x9C,0x76,0xF1,0xF1,0x20,0xF7,0x09,0x3D,0xA7,
	0xDF,0x5C,0x7C,0x1E,0x8C,0xE8,0xF7,0x21,0x8E,0x87,0x98,0x95,0x32,0x64,0xF1,0xA4,0x85,0x21,0x4D,0x6D,
	0xD9,0xE7,0x0D,0x3A,0x2A,0x55,0x28,0x71,0x55,0xD8,0xFD,0x9A,0xA5,0x78,0x1E,0xFD,0x7E,0xAE,0x86,0xE8,
	0x41,0x4E,0x80,0xAA,0x9B,0x94,0x41,0x26,0x86,0x00,0x7F,0xE4,0xF8,0x9B,0x19,0x04,0x24,0x44,0xE4,0xDC,
	0x14,0x34,0xF9,0x09,0xA5,0x06,0xF5,0x21,0xFB,0xFB,0xD7,0x1F,0xED,0xC2,0x95,0xF5,0x77,0xF4,0xAF,0xCD,
	0xCA,0x32,0xB0,0x95,0xF4,0x41,0xF2,0xDD,0x27,0x0C,0x07,0xB8,0xA4,0xD5,0x90,0xC7,0x3B,0x6B,0x1C,0xF6,
	0xAB,0x5A,0xE9,0x45,0x1D,0x54,0x7F,0xDF,0x18,0x93,0x61,0xDE,0x9F,0x4E,0x7E,0x69,0x94,0x59,0x5F,0xED,
	0xCC,0x0F,0x5B,0x61,0x00,0x82,0x7D,0x29,0x71,0x39,0xE9,0x29,0x08,0x19,0x3B,0x66,0x73,0x79,0x3B,0x95,
	0x9B,0x89,0xC1,0x23,0xC5,0xD0,0x5B,0x69,0x3E,0x6C,0x84,0xC2,0x60,0xCC,0xA5,0xD7,0x87,0x3F,0x59,0x5E,
	0xC7,0xAA,0x5C,0x43,0x30,0xA7,0x14,0x0D,0x84,0x5C,0x57,0xC0,0x94,0x75,0x23,0x04,0x12,0xF1,0xAF,0x39,
	0x75,0x11,0x36,0x85,0xCB,0x72,0x27,0xE6,0xD0,0xFC,0x6E,0xC5,0x00,0x4C,0x4F,0xF1,0x9D,0x9C,0xF0,0xEF,
	0x66,0x83,0xA9,0xC2,0xF2,0x64,0xB8,0x0A,0x85,0x3E,0x42,0x4A,0x7D,0x9A,0x2F,0x77,0xC1,0x68,0xA5,0xE9,
	0x57,0xEB,0x9E,0x13,0xA8,0xF5,0x56,0x63,0xBE,0xC6,0xE0,0x06,0x44,0x4E,0x2D,0x5E,0x72,0xDE,0x3E,0xEE,
	0x33,0x31,0x0D,0xF5,0x49,0x8B,0xB7,0xFC,0x39,0x6D,0x84,0x37,0xF7,0x6B,0x0F,0xD3,0xAB,0x46,0x63,0x72,
	0xC4,0xBD,0xDC,0x1C,0x96,0x6C,0xD6,0x0A,0x05,0x39,0x7A,0x32,0x04,0x7C,0xB8,0x31,0x5A,0x04,0xE9,0xD7,
	0xE6,0x83,0x9E,0xDE,0xD2,0x25,0xD8,0x25,0xF2,0x48,0x5F,0x89,0x79,0xA9,0x6C,0xDD,0x15,0x16,0xA1,0x51,
	0xF2,0xED,0x77,0x30,0x98,0xF0,0x3E,0x2B,0x5D,0xDD,0x3A,0x80,0x5A,0xDF,0x83,0x0D,0xBB,0x86,0xFB,0x33,
	0x5D,0x13,0x05,0x1B,0x41,0x96,0xA5,0x42,0x87,0x64,0xC5,0xB0,0xA3,0x7E,0x0E,0x75,0x4B,0x97,0x82,0x19,
	0xB7,0x65,0xBF,0xC5,0xC4,0xDB,0x3A,0x3A,0xE9,0xDF,0xBE,0x8F,0xAB,0x35,0x4C,0x2F,0x16,0x9F,0xED,0xC0,
	0xA4,0x7B,0x03,0x0A,0xC1,0x80,0x03,0x5D,0xF2,0xC9,0x9A,0x5C,0x01,0x0B,0xCB,0xE2,0x13,0xA7,0x5C,0x19,
	0x83,0x26,0x2D,0x06,0x0F,0xB4,0x10,0x2C,0x06,0x1E,0x27,0x5F,0x19,0x63,0x73,0x22,0xC5,0x48,0x7B,0xDB,
	0x2E,0xFD,0x24,0x1A,0xA8,0x5A,0x1A,0x25,0x90,0xD2,0x75,0x72,0xD5,0x73,0x8A,0xB8,0xB8,0x2B,0x8F,0xB2,
	0x76,0x31,0xF6,0x3E,0xE9,0x35,0xEA,0xEB,0xF4,0xCF,0xAF,0xBA,0xF0,0x60,0xBF,0x06,0x6C,0x80,0x94,0xF2,
	0x80,0xDF,0x17,0x3C,0x54,0xC4,0xF5,0x51,0xCD,0xA6,0xCE,0x47,0x47,0x8B,0x33,0xA8,0x77,0xF2,0x0D,0xB7,
	0x8B,0xF7,0x15,0x48,0x8D,0x47,0x79,0x39,0x84,0xBF,0xB5,0xB0,0x5F,0x88,0x63,0x46,0x37,0xB2,0x8A,0x89,
	0x88,0x2F,0x2C,0x1D,0x26,0x97,0xFC,0xD5,0xAA,0x7C,0xE4,0xA9,0x4E,0x5C,0x75,0x90,0x30,0x6D,0x53,0x1D,
	0x61,0x61,0x89,0x58,0x5F,0xEE,0x0E,0xC8,0x98,0x6C,0xD4,0x77,0xBC,0x80,0xB1,0xC0,0x3D,0x40,0x78,0xF0,
	0x65,0x23,0xC1,0xA4,0x16,0xC5,0x43,0xEB,0x27,0x45,0xD0,0xCD,0x8A,0xCA,0x00,0xE0,0xB6,0x17,0xBD,0x92,
	0xBF,0x9D,0xAD,0x61,0xB2,0x44,0x20,0x78,0x5F,0xC5,0xBC,0x8A,0x01,0x8A,0x1A,0xAD,0x9B,0xC6,0x06,0x63,
	0xE8,0xF1,0xF7,0x35,0x7D,0x6D,0x53,0x17,0xD4,0xD3,0x55,0x05,0x64,0x43,0x80,0x54,0x0A,0x31,0x54,0x00,
	0x79,0xB9,0xBA,0xEA,0x79,0x3A,0xDF,0x5D,0xD9,0xCD,0xEA,0xE2,0x04,0x7F,0x53,0x1B,0x9E,0x24,0x22,0x20,
	0x40,0x36,0xAD,0xBA,0xDB,0x1E,0xD5,0x04,0xD7,0xF6,0x17,0x6B,0xD7,0x6F,0xF6,0xAA,0x93,0xEA,0x39,0xEA,
	0x54,0x8A,0x3B,0x34,0x52,0x30,0xCB,0xA8,0xAC,0x49,0x00,0x09,0xC1,0x84,0x5F,0xAC,0xA9,0x52,0x4E,0x05,
	0x05,0x30,0x1B,0xAC,0xA8,0x73,0xF0,0xA8,0x48,0x0D,0xE5,0x81,0xC7,0x05,0xDA,0xB0,0x1E,0x07,0xF1,0x7F,
	0x01,0xD4,0x81,0xB7,0x37,0x13,0x79,0xFD,0x45,0x26,0xFC,0x83,0x20,0x20,0xAB,0x0A,0xA9,0xD9,0x3A,0x94,
	0xFD,0x55,0x68,0x16,0x94,0xE1,0x47,0xEF,0x2C,0xBC,0x74,0x5D,0x10,0x03,0xD1,0xDC,0x5D,0x13,0x98,0xB0,
	0xA5,0xA0,0x4C,0x7C,0x84,0x5F,0x4D,0xB1,0x23,0x26,0x5C,0x44,0x89,0x89,0x9D,0x11,0x7F,0x78,0x34,0xAB,
	0xBE,0x28,0xD3,0xC9,0xA2,0xF7,0xD1,0x1D,0x9E,0x88,0x57,0x36,0x87,0x33,0x62,0xCE,0x3A,0x54,0xB9,0x7E,
	0xD5,0x4B,0x43,0x2B,0xF0,0x69,0xA9,0xF8,0x15,0x4F,0xB9,0x21,0xBF,0xAA,0x0E,0x10,0x5B,0xB4,0x84,0x19,
	0xE4,0x52,0xC1,0x64,0x8F,0x0E,0x53,0x68,0xE0,0x6B,0x12,0x92,0x8C,0xD6,0x43,0xDD,0xD0,0xC2,0x0C,0x53,
	0x77,0x72,0xFE,0xC2,0xC2,0xD5,0xC4,0x23,0x6F,0x09,0x71,0xB9,0x2A,0x4E,0xD0,0x1A,0x02,0x1B,0x88,0xC6,
	0x17,0x0E,0x0E,0xCC,0x2C,0xF0,0x6D,0xA8,0x97,0xE0,0xAD,0x92,0x11,0xB2,0x8D,0x37,0x0C,0x93,0x2D,0xCE,
	0x4A,0x65,0x7A,0xC8,0x50,0x5E,0x3D,0x40,0x4C,0xF1,0x5A,0x44,0xEC,0x9A,0x76,0xCC,0x1B,0x5D,0x90,0x3C,
	0xF5,0xCA,0x6B,0xE3,0xC8,0x44,0x2C,0xE6,0xC9,0x8F,0x56,0x37,0x74,0xA7,0x5A,0x9E,0x90,0x1C,0x0C,0x2B,
	0x97,0x94,0x0C,0x29,0xC6,0x64,0x7A,0xA1,0x4A,0x01,0x8C,0x1C,0xAA,0x5E,0x6C,0x81,0x21,0xF0,0x20,0x2D,
	0x9E,0x5D,0xAF,0x1E,0xD6,0x75,0xA3,0x50,0x82,0x63,0xE6,0x6B,0xCF,0xB2,0x6E,0x55,0xF1,0x8E,0xB8,0x79,
	0xF0,0x95,0xC0,0xF5,0x13,0x73,0x55,0x2A,0x80,0xC6,0x84,0x0A,0x4C,0xCE,0xCA,0xCA,0x00,0x8F,0x50,0xCF,
	0x72,0xE9,0xDA,0xF9,0xD4,0x34,0x34,0x69,0xC7,0xA6,0xBF,0x48,0x6C,0xD8,0x78,0xAA,0x00,0x89,0x77,0xAF,
	0x5E,0xB5,0xAA,0x20,0x88,0x4A,0x91,0x52,0x75,0xD9,0x8E,0xCE,0x5A,0xE7,0x7C,0x6F,0xD7,0x05,0x91,0x98,
	0x22,0x3A,0x2D,0x5C,0xF4,0x35,0x89,0x9C,0xF2,0xFA,0x53,0x51,0x46,0x85,0xA4,0x31,0xA4,0xDB,0x3D,0x78,
	0x5B,0x73,0x3E,0x46,0xCE,0x28,0x5A,0x33,0xAB,0x22,0x0C,0x2D,0xCF,0x60,0x3B,0x0C,0x0F,0x27,0xAB,0x74,
	0x69,0x63,0x1A,0x11,0x0A,0x7C,0x5E,0x14,0x5C,0x1D,0xEA,0x98,0x1B,0xCA,0x0C,0x4E,0xA9,0xF7,0x97,0xC4,
	0xBE,0x5D,0x23,0xF5,0x08,0x6E,0x9E,0xEE,0xDE,0xE8,0x01,0x53,0x47,0x29,0xA7,0x95,0xF7,0x8A,0xF1,0xF1,
	0x5A,0x19,0xF0,0xF1,0x39,0xD7,0xF4,0xFA,0x6A,0xC1,0xA6,0x62,0x68,0x61,0x22,0xC2,0x85,0x87,0x15,0xA7,
	0x5C,0x60,0x04,0xA7,0x8A,0x9E,0x8C,0x95,0x89,0x8C,0xF7,0x72,0xF9,0x58,0xFC,0x6F,0xD0,0xBC,0xCD,0x3A,
	0xBE,0x78,0xD0,0x4E,0x1D,0x57,0xE5,0xC2,0xC5,0xC2,0xC5,0x67,0xDB,0x8D,0x7C,0xF7,0xC2,0x5C,0x64,0xB7,
	0xD3,0xDE,0xD0,0x16,0xFB,0xF7,0x1F,0x74,0x05,0x00,0xCC,0xF4,0x7A,0xF1,0xEA,0x8D,0xD0,0x49,0x59,0x5F,
	0x7A,0x1A,0x47,0xA3,0xA1,0x40,0x61,0xBB,0xA1,0xFF,0x36,0xEB,0xBB,0x5D,0x1D,0xC8,0x5E,0xCE,0x99,0x15,
	0xAD,0xA7,0x9B,0xFA,0x35,0x8C,0xEB,0x2F,0xD3,0xAA,0x63,0xB1,0xBE,0x42,0xF2,0x43,0x37,0x22,0xAB,0x9A,
	0xAE,0x0E,0x3C,0x46,0xB9,0x4D,0x7E,0x80,0x7A,0x3C,0xAD,0x8E,0xBE,0x42,0x98,0xC4,0x91,0xCF,0x85,0xEB,
	0xEE,0x88,0xAC,0xF3,0x5F,0x59,0x60,0x81,0xC0,0xF2,0xC1,0x2F,0x7D,0x81,0xAF,0x7D,0x60,0xF8,0xCF,0x61,
	0x54,0x14,0x89,0xF9,0x3E,0xE0,0x94,0xDF,0x07,0x32,0x06,0x9B,0xD5,0x6A,0xD5,0xB9,0x4D,0x19,0x65,0xE1,
	0xAB,0x7F,0x57,0x2D,0xD1,0x7D,0x83,0xD0,0xE4,0xBD,0x49,0x53,0x34,0x7F,0xD3,0x07,0xAE,0x0A,0xB0,0x84,
	0xC5,0x4E,0x22,0x45,0xBC,0xAA,0xCA,0x10,0x55,0x07,0xBA,0x29,0xA4,0xAA,0x47,0xA8,0xAA,0x39,0x78,0x8B,
	0xF7,0x17,0x0A,0x98,0xF9,0x5D,0xC9,0x85,0xC1,0x11,0x22,0x89,0x96,0x23,0x11,0x8A,0xF7,0x0B,0xFF,0xBA,
	0x2A,0x82,0xC5,0x7E,0x45,0xAA,0x31,0x68,0x27,0x46,0x4D,0xB1,0xCC,0x2E,0x82,0x51,0xA5,0xDD,0xEF,0xDB,
	0x1E,0xC6,0x6C,0xDD,0x77,0xD4,0x5F,0xDB,0x8A,0xE1,0x21,0xDE,0x8C,0x77,0x7C,0xB7,0xDA,0x34,0x75,0x12,
	0xB0,0x3F,0x3A,0x30,0x0A,0xF8,0x76,0xF3,0x72,0x34,0x2E,0x32,0x13,0xA9,0x1E,0x28,0x85,0xDC,0xAC,0x2B,
	0xF1,0xAD,0x9E,0x9E,0xEF,0xB4,0x8C,0x27,0x93,0x89,0xBC,0x40,0xB9,0xA6,0xFB,0x4A,0xB5,0xBA,0x06,0xAB,
	0x03,0x44,0xBE,0x4B,0xFF,0x71,0x46,0xC3,0x6F,0xEF,0xC6,0x87,0x11,0xE4,0x67,0xBD,0xD7,0x94,0xE8,0x07,
	0x35,0x51,0xD1,0xA7,0x9D,0x6A,0x6F,0xE0,0x8E,0x66,0x9E,0x38,0xCC,0xD8,0xD8,0x18,0x91,0xD2,0xF5,0x48,
	0x01,0x0B,0x68,0x63,0x50,0xEE,0x91,0x02,0xE0,0x08,0x29,0x84,0x2E,0xB6,0x6E,0x37,0x45,0x8C,0x1C,0x1C,
	0x65,0xBE,0x3E,0x0E,0x61,0xFF,0xA7,0xEC,0x53,0x1C,0xB3,0x55,0x91,0x28,0x71,0x5B,0xF3,0xD8,0x57,0xE6,
	0x0E,0x28,0x8C,0x3B,0x43,0x43,0x56,0x22,0x9F,0xD9,0x3C,0x22,0xAE,0x61,0xC4,0x6C,0x51,0x2C,0x07,0x1F,
	0xC5,0x01,0x91,0x50,0xE3,0xD9,0x8E,0x5F,0xAF,0xD4,0xAB,0x1A,0x5E,0xDD,0xFC,0x95,0x63,0xD4,0xA3,0x9D,
	0x8D,0x0B,0x59,0x00,0xA0,0x80,0xF2,0x33,0x57,0x5D,0xDB,0x53,0xE7,0xAF,0x10,0x44,0x05,0xD1,0x94,0xF2,
	0xEA,0x45,0x2B,0xF9,0x26,0x53,0x17,0x59,0x3B,0x09,0x61,0xCF,0xD7,0x3A,0x5A,0x1C,0xB1,0x1F,0xA9,0x58,
	0x15,0x78,0xF0,0x0C,0x84,0xBF,0xC1,0xC9,0x32,0xA8,0x89,0x9C,0x18,0xAC,0xFA,0x96,0x03,0x0E,0xC3,0x8F,
	0x66,0x2C,0x26,0x8B,0x9C,0x2A,0x2D,0x29,0xA8,0xA1,0x20,0xE6,0x22,0x61,0x52,0x77,0xB8,0xAE,0x0B,0x02,
	0xCD,0xEC,0x05,0xBB,0x54,0x1D,0x62,0x93,0x04,0x8F,0xDC,0x37,0x22,0x17,0xE4,0xAB,0x25,0x37,0x4F,0x55,
	0x9D,0x59,0x46,0x65,0x8D,0xEC,0xA4,0xC5,0x38,0x84,0xEE,0x6E,0x0B,0x3B,0x6E,0x3D,0x3A,0xCE,0x5C,0x5C,
	0x60,0x55,0xF8,0x9A,0x8A,0x6A,0x96,0x8A,0xA4,0x88,0xEE,0xBA,0x9B,0x04,0xAC,0x5C,0x1D,0x6A,0x8E,0xAD,
	0xA4,0x49,0x25,0x58,0x2C,0xFB,0x5A,0x55,0x48,0xD1,0x78,0x63,0x20,0x02,0x7F,0x79,0x6D,0xE8,0x58,0xA1,
	0xA6,0xE2,0x7B,0x10,0xEC,0x2C,0xF6,0x2E,0x26,0xFE,0xCA,0xB2,0x6E,0xD2,0x41,0x7F,0x41,0x15,0x2D,0xDC,
	0x97,0xB6,0x6F,0xE2,0x45,0x98,0x70,0x10,0xA0,0x73,0xF4,0x95,0x3C,0x06,0x2F,0x40,0xAE,0x3B,0x56,0x40,
	0x49,0xB8,0x0F,0x5D,0x7E,0x8A,0x87,0x20,0x1D,0x5F,0x15,0x1A,0x2E,0x31,0x12,0xA2,0xB8,0xB3,0x10,0x67,
	0x80,0x64,0xB4,0x68,0xA8,0x8A,0xF2,0x3B,0x68,0x25,0x33,0x49,0x37,0xAD,0x92,0xCD,0xFA,0xDA,0xFB,0x1E,
	0x23,0xF5,0x33,0x82,0x89,0xFE,0xA3,0x4E,0xF8,0x0F,0xE8,0xA9,0xE3,0xB4,0xF8,0xDC,0xA4,0x0C,0xDE,0x1F,
	0x8E,0xD7,0xEC,0x18,0x19,0xB6,0x48,0x5F,0x88,0x05,0x6A,0x32,0x13,0x75,0xA8,0x9D,0x7A,0x7F,0x19,0x94,
	0xFB,0xB7,0x73,0x79,0x84,0xEA,0x13,0x63,0x6F,0xAB,0xC2,0x0C,0x72,0x7F,0x4A,0xF1,0x04,0xAD,0xCE,0x21,
	0xC0,0x50,0xCA,0x94,0x30,0x5D,0x3B,0x8F,0x80,0xA0,0xB1,0x37,0x4C,0x7B,0x35,0xC5,0x35,0x22,0x70,0xE5,
	0xFB,0x36,0xED,0xAA,0x72,0xED,0xBE,0x06,0x6E,0xC0,0x3A,0xA3,0xDC,0x4A,0xBE,0x6F,0x07,0xC2,0xDC,0x77,
	0x2A,0x13,0xBF,0xE5,0x5C,0x80,0x20,0xF1,0x42,0x5C,0x40,0xD6,0xC0,0xF0,0xFF,0x55,0xBB,0x82,0x33,0x24,
	0x26,0xBA,0xB2,0xCD,0xC5,0xB2,0x17,0x93,0x8A,0x78,0x64,0xE8,0x83,0x77,0x74,0xEB,0x9A,0x9D,0xCB,0x35,
	0x93,0x19,0x78,0x2A,0xD4,0x19,0xA1,0x30,0x95,0x46,0x6F,0x55,0x0A,0x6C,0xFA,0x5F,0x60,0xCE,0x08,0x76,
	0xC9,0xB8,0xEA,0x29,0xC7,0x0B,0x90,0xCF,0x0F,0xAD,0xF8,0xD9,0x7C,0xEE,0xE5,0x6B,0x47,0x2C,0x5E,0xB5,
	0xC1,0xC8,0xD4,0x65,0x22,0x6C,0x79,0x95,0x71,0xFE,0x95,0x03,0x5D,0x17,0xE7,0x8C,0x18,0xAC,0xBE,0x18,
	0xB2,0x66,0x5E,0xD6,0xFD,0x55,0x1D,0x1F,0xAA,0xC8,0x0D,0x69,0xF6,0x4B,0xDC,0xF0,0xF5,0xAE,0x6B,0xD5,
	0xFA,0x56,0x1B,0x5F,0xD9,0x8B,0x73,0x99,0x70,0xB3,0xEA,0xAB,0x9A,0xE8,0x72,0x1F,0x0A,0xC6,0x0F,0xBC,
	0xBD,0xFA,0x09,0xFE,0xAA,0x3A,0x8C,0x2C,0x93,0xF1,0xF6,0x4F,0xA1,0xA0,0x11,0x6D,0xEA,0xCA,0x6D,0x39,
	0x20,0xEA,0x12,0x84,0x75,0x39,0xD4,0xB1,0x13,0x96,0xC4,0xDF,0xAD,0xB5,0x2A,0x51,0x5E,0x2A,0xBE,0x9E,
	0xB7,0x12,0xB8,0x2B,0xAC,0x49,0xBB,0xDC,0x98,0x8A,0x8C,0x86,0x85,0xFF,0xCE,0x43,0x56,0x24,0x78,0xB1,
	0x31,0x26,0xC2,0x67,0x2A,0x39,0x4B,0xE3,0x92,0xF8,0xAB,0xE2,0x9E,0xD3,0x93,0x2C,0x5F,0xD9,0x9F,0x1D,
	0x02,0x13,0x8C,0x4B,0xC2,0xE0,0x05,0xBA,0x90,0x15,0x66,0x7A,0x09,0x6F,0x83,0x6D,0x63,0x19,0xEC,0x20,
	0xE9,0x0A,0x10,0xEF,0x5B,0xAE,0x22,0x9B,0x42,0xE4,0xBF,0x99,0x20,0x26,0xAC,0x3C,0x4B,0x6D,0x1A,0xD3,
	0x65,0xAC,0x08,0xAA,0x19,0x65,0x60,0xC2,0xE0,0x57,0x4D,0x05,0xDE,0xAF,0x9A,0xFA,0x6A,0x7B,0x76,0x1E,
	0xD4,0xCF,0x11,0xA1,0x2A,0x36,0xB2,0x22,0xDF,0x9C,0x16,0x14,0x7F,0xEC,0x2F,0x28,0x71,0xC7,0x16,0xAE,
	0x76,0x26,0x1E,0xBC,0xC7,0x0B,0x86,0x47,0xCA,0x9F,0x42,0x48,0xF5,0x18,0xC0,0xE1,0x6B,0xF0,0xB1,0xAF,
	0xFF,0xBC,0xA8,0x00,0xF1,0x58,0xC3,0x40,0x61,0x13,0xB6,0x1C,0xA6,0x73,0xD3,0xBC,0x15,0xB1,0x10,0xEA,
	0x5D,0x54,0xB8,0xB3,0xF8,0x79,0xB4,0xB8,0x11,0x9A,0x3B,0xDA,0xD5,0x45,0xCC,0xBC,0xE5,0x55,0x70,0xD0,
	0x39,0x21,0x2A,0x6C,0x85,0x40,0x51,0x20,0x40,0xE9,0x87,0x65,0xF4,0xEB,0x82,0x7E,0xAC,0x9B,0x22,0x40,
	0xB5,0x24,0xF4,0x1A,0x36,0xA9,0x4C,0x43,0x0F,0xD6,0x28,0x30,0x65,0x96,0xAF,0x4B,0x06,0x5B,0xAE,0x0B,
	0x67,0xCE,0xAB,0x2A,0x1C,0xE5,0xA0,0x12,0x5B,0x5B,0xD8,0x72,0x9A,0xE6,0x56,0x09,0xE1,0xA9,0x47,0x89,
	0x5A,0xAD,0xC0,0x24,0x43,0x96,0x2A,0x3F,0x18,0x45,0xB4,0x3C,0x72,0x46,0x76,0xDF,0xBB,0xA2,0x6A,0x04,
	0x00,0xEB,0x93,0xC2,0x2B,0x96,0x62,0x0C,0xBB,0x87,0xE7,0x7A,0x64,0x12,0x88,0x57,0x25,0xEE,0xCA,0xA5,
	0x9F,0x62,0x98,0x48,0x4F,0xC4,0xAF,0xB6,0xD5,0xBE,0xDC,0xB7,0x44,0xBA,0xDA,0xE9,0x67,0x76,0x03,0xCA,
	0x47,0x9E,0xC6,0x17,0x83,0xE9,0x5A,0x9C,0xCC,0x94,0x20,0x4E,0x5D,0xA7,0x6B,0x09,0x1B,0x23,0xAD,0x57,
	0x47,0x2A,0x38,0x50,0xAE,0x84,0x5F,0xC8,0xF4,0xE9,0x25,0x35,0x9A,0xD7,0x00,0xD4,0x18,0x13,0x01,0xC6,
	0x9C,0x43,0x44,0xD7,0x01,0x7B,0x28,0xA8,0xA0,0x44,0x19,0x07,0x31,0x93,0xF3,0x99,0x87,0xA0,0x71,0x55,
	0xD5,0x66,0xFB,0x5C,0xBE,0xAF,0xE0,0xD3,0x95,0x02,0xAD,0x01,0x04,0xB0,0x75,0xAC,0x8E,0x4A,0xFF,0x95,
	0xFE,0xDC,0x34,0x85,0xC1,0x78,0x93,0xF6,0x78,0xFE,0x76,0x5D,0xEB,0xCA,0xF1,0x0C,0x21,0x66,0x1D,0xAA,
	0xF8,0x39,0xD4,0x07,0x03,0x8E,0x93,0x8D,0x6D,0x8D,0x0A,0xDB,0xB9,0xAA,0x46,0xC1,0xAB,0x55,0xF5,0xFC,
	0x8E,0x3E,0xE9,0x5B,0xB6,0x44,0x39,0x0C,0x4A,0x28,0xBB,0xA6,0xDD,0xA0,0x7E,0xF8,0xDC,0xDA,0xF6,0x55,
	0x7D,0xB5,0xE7,0x8A,0x7A,0x92,0xD3,0x9A,0x8A,0x17,0x88,0x50,0xC0,0x3D,0xB5,0xBC,0x89,0xE3,0x55,0xD0,
	0xDD,0x9E,0xA2,0xBA,0x56,0x32,0xF9,0x8C,0x10,0xA8,0x2B,0x78,0x33,0x84,0xEA,0x75,0xE6,0xE1,0xBB,0x81,
	0x2F,0xBE,0xB5,0x2B,0x57,0xC5,0x10,0x63,0x14,0x6E,0xF6,0x41,0x78,0x16,0x78,0xD5,0xC0,0x7A,0xBC,0xB8,
	0x39,0x08,0x07,0xC2,0xAC,0xEB,0x05,0x35,0xBA,0xAF,0xC4,0xBA,0x10,0x2D,0x45,0x9E,0xBA,0x0E,0x81,0x74,
	0xC2,0xC1,0x8E,0xB0,0x47,0xD7,0x2A,0xC9,0x1C,0x9C,0x4D,0x5D,0xFB,0x0F,0x08,0xA2,0x40,0xFF,0x81,0xEF,
	0xFB,0xDB,0xE8,0x24,0xBF,0x2E,0x75,0xB9,0xF5,0x49,0x69,0xFD,0x74,0xBF,0x3B,0xA7,0x4E,0x60,0xE3,0x35,
	0x5F,0xEB,0x0A,0xF2,0x6A,0x13,0x34,0x2C,0xD5,0x81,0x10,0xD3,0x51,0x24,0xC8,0x24,0x23,0x76,0xB5,0x7E,
	0x69,0xCB,0x4C,0x01,0xDA,0x66,0x56,0xE5,0x3A,0x33,0x38,0x30,0x80,0x33,0xEF,0xCF,0x2F,0x82,0x77,0x57,
	0x10,0xD8,0x40,0xD5,0x80,0xC1,0xAA,0x44,0x2E,0x5E,0x03,0x8B,0x08,0x81,0x2C,0x4B,0xAF,0xBE,0x5E,0x09,
	0xCB,0x92,0x5E,0xB7,0xF4,0xC4,0x9D,0x6E,0xCC,0x37,0xF0,0x41,0x29,0x27,0xBD,0x4E,0x83,0x5E,0x7E,0x22,
	0xBE,0xBE,0xA2,0xCC,0x19,0xCB,0x5E,0xB8,0x4F,0x21,0x62,0x6D,0x60,0x8C,0xE1,0x3E,0xA8,0xD9,0x0F,0x8E,
	0x58,0xEE,0x54,0xD4,0x16,0xD1,0xC0,0x22,0x5A,0x7E,0xDD,0x5B,0x97,0xCF,0x0A,0x2E,0xD8,0x16,0x08,0x33,
	0x0D,0x31,0x21,0xCD,0xC7,0x58,0xDB,0xE7,0x28,0x4D,0x74,0xE0,0xD3,0x85,0x25,0x3B,0x2F,0x5C,0x97,0x9F,
	0x33,0x2D,0x9C,0xB6,0xAD,0x18,0x43,0x0C,0xF9,0x1C,0x00,0xFF,0xFB,0xF2,0x30,0x13,0x17,0x04,0xBD,0x02,
	0xF8,0xB9,0x0A,0x53,0x2A,0x9E,0x3F,0xB8,0xF1,0xF1,0x78,0x19,0x5C,0xE0,0x1C,0x8A,0x76,0x04,0x7B,0xA8,
	0xEE,0xB5,0x3B,0x0A,0xB1,0xEF,0xE6,0xA6,0x8A,0xE3,0x8B,0x3B,0xD9,0xAD,0x62,0x8C,0x06,0xAE,0xDF,0x66,
	0x41,0xC6,0x9E,0xE1,0x70,0x2C,0xB0,0x70,0x7A,0x78,0xF4,0xD7,0xC3,0x6D,0xC8,0xFA,0xDD,0x27,0xA4,0x5F,
	0xBC,0xBF,0x01,0xE4,0x01,0x8E,0x38,0x39,0xBD,0x40,0xE0,0x28,0xC8,0x8A,0xC2,0x3D,0x7F,0x9A,0x17,0x97,
	0xF7,0x19,0x20,0x40,0x04,0x41,0xB6,0x16,0x7D,0x39,0xBA,0x0D,0x74,0x5F,0xB6,0x45,0x11,0x2B,0x9E,0xDF,
	0xC9,0x52,0xE5,0xB5,0x7F,0x5F,0x75,0xE8,0x65,0xEE,0xEF,0x8E,0xEF,0x2C,0x79,0x46,0xDE,0x4F,0xEE,0xE9,
	0x54,0xE7,0xB3,0xC7,0xAB,0x4A,0x16,0x56,0x7E,0xAC,0xBD,0xFC,0xC5,0x6D,0x64,0xED,0x66,0xBD,0xEA,0x1A,
	0x26,0x7C,0x7D,0x01,0xA0,0x3C,0xDC,0xC9,0x5D,0x8D,0xC8,0x00,0x54,0xAC,0xCA,0xD7,0xB5,0xEE,0xCB,0xC7,
	0x58,0x08,0x88,0x29,0x98,0x3F,0xCD,0xF7,0x45,0x7D,0x47,0x10,0x29,0x58,0x58,0x57,0xF0,0xCB,0xB1,0x02,
	0x48,0x19,0x48,0xE8,0x3B,0x57,0x15,0x00,0x31,0x32,0xA4,0x69,0xD7,0x90,0x7F,0xE9,0xC5,0xF7,0xBC,0xEA,
	0xAA,0xF8,0x78,0xC3,0x32,0x8C,0x67,0x1A,0x45,0xEA,0xA2,0xFE,0x88,0xE4,0x4C,0x2D,0x09,0xF5,0x65,0x4A,
	0x6B,0x18,0x2E,0x60,0x44,0x82,0xC9,0xFF,0x45,0x65,0xF1,0x5F,0xAE,0xAC,0xEA,0xB4,0xEA,0x43,0xAD,0x9D,
	0x56,0x7D,0xA8,0x0E,0x11,0x19,0x06,0xCD,0x1F,0x50,0x0C,0x4A,0xC1,0xE3,0xB5,0xFE,0x32,0xF7,0x97,0x28,
	0x8C,0xDB,0xE7,0xD5,0x65,0xDC,0xF7,0x90,0x86,0x7C,0x8B,0x35,0x66,0xB3,0x59,0x42,0x81,0x31,0x14,0xCF,
	0xE4,0xAF,0x00,0xBD,0x80,0x69,0x98,0x86,0xBE,0x83,0x15,0xEA,0xA4,0xB4,0xF2,0xBB,0x97,0xCB,0x1F,0xE5,
	0xFC,0xAF,0x13,0x86,0xE6,0x7A,0xC7,0xDC,0x51,0xB1,0x1A,0x38,0x1F,0x75,0x57,0x40,0x54,0xBB,0x69,0xE5,
	0x60,0x81,0xAD,0x4F,0xC3,0x00,0xAC,0xF2,0x0F,0x18,0xE3,0x01,0x65,0x65,0xE7,0x17,0x5C,0xBF,0x12,0x23,
	0x37,0x71,0x62,0x8B,0x78,0x26,0x2F,0xDB,0x68,0x4A,0x02,0x16,0x80,0xF2,0xBA,0x48,0x0D,0x01,0x97,0x81,
	0xD9,0xC9,0xB2,0x4A,0x3B,0x98,0x06,0xB7,0xE3,0x91,0x95,0x7B,0x20,0x4D,0x0C,0x7A,0xA6,0xFF,0x2C,0x08,
	0x7C,0x2D,0x42,0xA0,0x26,0x8C,0x36,0x4B,0x0C,0xE4,0x60,0x2A,0x30,0xD7,0x28,0x6B,0x24,0x6E,0xE5,0xBB,
	0x9A,0x30,0x1C,0x9B,0xE8,0xEB,0x9C,0xEF,0xA3,0x20,0x58,0x24,0x2D,0x29,0xBB,0x19,0x27,0x89,0x5D,0xDD,
	0x76,0x0B,0xA4,0x4A,0x55,0xE4,0xBA,0xAB,0x06,0x28,0x08,0x51,0x80,0x8F,0xBF,0x6C,0x28,0x29,0xE9,0x46,
	0x3D,0xAC,0x41,0x61,0x5D,0x12,0x79,0x86,0xA1,0xE9,0xAA,0x52,0xB2,0xF1,0xF1,0xFB,0x80,0x07,0xBC,0xC8,
	0x45,0x95,0xDE,0x22,0x18,0x33,0x7B,0xD3,0x6F,0x96,0x47,0x11,0xB3,0xC9,0x4A,0x8D,0x97,0x6E,0x04,0xDE,
	0x3F,0xA1,0xFB,0x10,0x1C,0x34,0x0A,0x0F,0x91,0xDD,0xFE,0xC4,0xD5,0xB2,0x46,0xC2,0x96,0x5A,0x77,0x5F,
	0xE5,0x39,0x77,0x21,0x11,0x25,0xBB,0x6A,0xFE,0x08,0x16,0x48,0x0C,0x90,0x40,0x9E,0xAF,0xFE,0x33,0x77,
	0x0E,0x75,0x47,0xAA,0x08,0xE4,0x7C,0x1A,0x29,0xFF,0x55,0x11,0xC2,0x80,0x6E,0xA9,0xD6,0x18,0x5D,0x65,
	0xA3,0x22,0x5F,0xD5,0x31,0xF7,0x69,0x28,0x55,0x4A,0x16,0xE8,0xE9,0xD4,0x07,0xBE,0x2E,0x80,0x2D,0xC1,
	0x31,0xB4,0x21,0x47,0x7D,0xAF,0x4A,0x47,0xE2,0x04,0xAC,0x06,0x71,0x55,0xCD,0xE4,0xB9,0x7E,0x5D,0x09,
	0xF7,0x92,0x02,0xF4,0x68,0x4F,0x6E,0x28,0x81,0x34,0x2C,0x84,0x68,0x9E,0xD3,0xF4,0x93,0xCF,0x25,0xE3,
	0xAD,0xE5,0xBA,0xE0,0x9C,0x34,0xF0,0x1A,0xF8,0xD0,0xD3,0xEE,0x3A,0xED,0x42,0x80,0xFC,0xC2,0xD5,0x79,
	0x11,0x07,0x72,0x15,0xF2,0x60,0xEA,0x03,0x84,0x1C,0x78,0x0A,0xCA,0x0D,0x90,0xF0,0x55,0x82,0x77,0xE5,
	0x73,0xA7,0x1E,0x28,0x04,0x61,0x75,0x5D,0x3D,0xF6,0x93,0xA9,0x94,0x0F,0xF6,0x3C,0x4F,0x1E,0xC2,0xDB,
	0x36,0x7D,0x6D,0x6A,0x5F,0x15,0xC9,0xDA,0x57,0xD5,0x42,0x99,0x81,0x7D,0x40,0xA6,0x11,0x73,0x00,0xC9,
	0x68,0xA5,0xAF,0x23,0xDE,0x90,0x06,0xAD,0x1E,0x2D,0x9A,0xC9,0xA2,0xAA,0xDA,0x49,0xDF,0x97,0x81,0xC2,
	0xF9,0x19,0xDC,0x04,0xFB,0xD0,0xD1,0xB8,0x7D,0x07,0x23,0x16,0xF1,0x65,0x58,0x14,0xBC,0x61,0x99,0xA8,
	0x2E,0x0E,0xC9,0x44,0xD4,0x5A,0x00,0x28,0x0E,0x9F,0x3F,0xD4,0x87,0xAB,0xEA,0xF3,0x50,0x2C,0x18,0xB3,
	0x79,0xD8,0xDF,0xBB,0x99,0x3A,0x30,0x13,0x91,0x42,0x59,0x9D,0x34,0x5D,0x5E,0xFB,0xF8,0x5F,0x38,0x82,
	0x10,0x79,0x5F,0xF9,0x72,0xF0,0xD2,0x2C,0x6A,0xF3,0xC9,0x81,0x3D,0x6B,0xD3,0xB0,0xBA,0x0A,0xDE,0x35,
	0x58,0xCF,0x62,0x92,0xFB,0x4B,0xE9,0xBB,0xD3,0x1A,0x9F,0x0E,0xC6,0x4F,0x30,0xCB,0x61,0x75,0xC6,0x6B,
	0x8B,0x06,0x6A,0x23,0x25,0x55,0xD7,0x3A,0xF9,0x78,0x8B,0xE8,0x06,0x11,0x48,0x83,0x67,0x53,0xA7,0xAE,
	0xB9,0xAB,0x30,0x47,0xFF,0x94,0x30,0x14,0xD5,0x45,0x9E,0xC3,0x57,0x44,0x0C,0x17,0x31,0xB1,0xE5,0x5F,
	0x15,0x25,0x5A,0x4D,0x32,0xE6,0xBF,0xD7,0x25,0x9A,0x5E,0xBE,0xBF,0x55,0x9D,0xDA,0x6E,0xF6,0x7D,0xC1,
	0x40,0xA0,0xBF,0x21,0xF4,0x7F,0xFF,0xD0,0x31,0xD7,0x95,0x20,0x33,0x09,0x68,0x91,0x4E,0xA4,0x7E,0x14,
	0x05,0x42,0x9E,0x74,0xE5,0x75,0xC5,0x8E,0x10,0xC4,0x5E,0x32,0xA8,0xB0,0xB2,0x78,0xED,0xAF,0x55,0xF4,
	0x80,0x47,0xDE,0x9D,0x0A,0xA2,0x9C,0xA3,0x5D,0xD7,0x65,0xE5,0x5E,0x4F,0x16,0xC2,0x95,0x9E,0x6A,0xB1,
	0xD8,0x94,0x11,0xF5,0x5F,0x08,0x5A,0x0A,0xFA,0x76,0x06,0xC4,0x44,0x2D,0x16,0xEE,0x23,0x1C,0x9B,0x16,
	0x1E,0x8B,0xAE,0xE6,0xAB,0x40,0xBF,0x39,0x77,0xC6,0xCF,0x4C,0x2C,0xC9,0xF5,0x9D,0xF9,0x2E,0xBB,0xE9,
	0x54,0x71,0xC8,0x25,0x88,0x9E,0xC2,0xB2,0xEE,0xED,0x7C,0xDE,0x7F,0x5C,0x61,0x60,0x28,0xEC,0x65,0xC4,
	0x01,0x55,0xD2,0x1A,0xD5,0x81,0x84,0x44,0xA4,0x41,0x26,0xD0,0x72,0x64,0x39,0xDA,0xDD,0xBF,0x3A,0x83,
	0xCF,0x95,0xAB,0xF2,0x2C,0x1D,0xB8,0xCC,0xF0,0x8B,0x0E,0xB9,0x94,0xC4,0xBE,0x24,0x35,0x1D,0xEA,0x97,
	0x11,0x9C,0x43,0xA4,0xC5,0x3E,0x42,0x55,0x9F,0x10,0x2D,0x2D,0xAA,0x54,0x64,0xEE,0x54,0x02,0xCC,0xEE,
	0xCF,0xC7,0xF2,0xDC,0x5D,0x7C,0xC6,0x57,0xB7,0xAB,0x7A,0x96,0xB5,0xE3,0x44,0x84,0x30,0x00,0x26,0x15,
	0xAF,0x0B,0xE8,0xF3,0xE0,0x1B,0x85,0x60,0x6C,0xE1,0x29,0x79,0x08,0x3A,0x21,0x5A,0x7F,0x02,0x1E,0x17,
	0xA0,0x4D,0xEA,0x0C,0x04,0x70,0xB0,0x3B,0x5A,0x30,0x41,0xAA,0x2F,0xF4,0xCB,0x79,0x99,0x36,0x33,0x77,
	0x0C,0x33,0xCC,0x3F,0x0E,0x42,0xF4,0xCC,0xB0,0xA8,0x2F,0x08,0xA3,0x77,0x06,0xDC,0xAA,0x48,0x18,0x38,
	0x5D,0x66,0xF2,0x3F,0x2A,0x19,0x20,0x14,0xEB,0xBA,0x41,0xEE,0x61,0x1F,0xF1,0x5D,0x05,0x5A,0x50,0xDF,
	0xA8,0xE7,0x8C,0x97,0xA5,0x01,0x00,0x71,0xDA,0x42,0xF5,0xFD,0x3D,0xC5,0x87,0x3B,0xFD,0x8A,0xDE,0x80,
	0xD5,0xBE,0x72,0x10,0x21,0xC3,0xE7,0xF3,0xE6,0xC3,0x4C,0xCC,0x42,0x7C,0x11,0x91,0xE0,0x0C,0xAF,0x35,
	0xA4,0xD7,0x13,0x13,0xB8,0x17,0xBB,0x4B,0x49,0x2E,0x7D,0x47,0xB3,0x16,0x89,0x47,0xA6,0x78,0x53,0x5D,
	0x91,0x64,0xB8,0xC2,0x5B,0xFC,0xFB,0x09,0x4E,0x2D,0xFC,0x05,0x6F,0x4A,0xA8,0xA8,0x10,0x0C,0xFF,0x6B,
	0x4F,0xEB,0x50,0x11,0x29,0x2B,0x85,0xA1,0xE0,0xA1,0x5D,0x23,0x83,0x93,0xC0,0xC4,0xE9,0x7D,0x45,0xAE,
	0xC6,0x94,0xC7,0x97,0xD1,0xFE,0x88,0x91,0x3D,0xFB,0x3A,0xF2,0xB2,0x55,0x37,0x42,0x14,0xBF,0x67,0xBB,
	0x42,0x25,0x12,0x92,0x79,0x61,0x91,0xC1,0xF5,0x4A,0xCB,0x76,0x7D,0x5D,0x8B,0xF8,0xFD,0xA5,0x73,0xB9,
	0x1C,0xFF,0xDB,0x50,0x34,0xA8,0x00,0xD2,0xC6,0x90,0x1B,0x51,0x1F,0xD2,0xD1,0xB0,0x94,0x8F,0x5C,0x37,
	0xB7,0x0C,0xEE,0x4D,0xEA,0xC0,0x0E,0xCC,0x1C,0x65,0xE1,0xDD,0xA9,0x3B,0x74,0x98,0x83,0x9C,0x82,0xBC,
	0x7F,0xC8,0x9A,0x39,0xCD,0x10,0x5E,0xBF,0xD2,0xA0,0x51,0xD8,0x16,0xFE,0x8A,0xD7,0x51,0x80,0xE4,0xB7,
	0xF6,0x7E,0xBB,0x6A,0xF4,0x5F,0x09,0x20,0x87,0xD6,0x53,0x74,0xB6,0x20,0x15,0x8E,0xED,0xB5,0x69,0x91,
	0xFC,0xAB,0xE6,0x97,0x65,0xD4,0xC5,0xC5,0x29,0x20,0x43,0x5D,0xB9,0xD1,0x41,0x00,0xD6,0x24,0x38,0x91,
	0xDD,0x2F,0xC8,0x0C,0x2B,0x05,0x83,0x0A,0x44,0x33,0x45,0xBF,0xE4,0xDF,0xE3,0xE8,0x4C,0x9D,0xEF,0x73,
	0xC1,0xFE,0xBF,0xE9,0x51,0x28,0x96,0x96,0xD9,0x97,0xA6,0x60,0x28,0xD3,0x97,0xE0,0x99,0xB3,0x6A,0x87,
	0x55,0xC9,0xC0,0x70,0xE2,0xBB,0x23,0x64,0xF4,0x24,0x63,0x72,0xD5,0x4D,0xCF,0x55,0xAD,0xC0,0xA5,0xAA,
	0xC0,0xB5,0x5B,0x68,0x36,0x19,0x64,0x58,0x6A,0xAC,0xDE,0x14,0x0C,0xC8,0x16,0xA9,0x1A,0x67,0xD5,0xE9,
	0x7F,0xAE,0x4E,0xC3,0xC6,0xAB,0xB3,0xF7,0x33,0x17,0xC4,0x63,0x27,0x48,0x54,0xD0,0x1A,0x00,0x67,0x9D,
	0x72,0x8A,0x5C,0x6B,0xE2,0xA6,0x65,0xA9,0xE1,0x56,0x7F,0x8F,0xBF,0xAF,0x2E,0xD3,0xBD,0x2E,0x0C,0xF3,
	0xE4,0x1A,0x4A,0xAB,0x9D,0x2D,0xCA,0x4A,0x10,0x01,0xF4,0xAE,0xB9,0x04,0x76,0x1D,0x1B,0xBC,0x70,0xFD,
	0xE8,0x8A,0x02,0xD3,0x57,0xE6,0xE7,0x63,0x72,0x01,0xBC,0xB3,0xFE,0x61,0xE0,0x19,0x96,0xDC,0x1C,0xB1,
	0xC9,0x70,0x49,0xF4,0x55,0xB4,0x44,0x62,0xD1,0x5F,0xA0,0x7B,0x78,0x5C,0xEB,0xB3,0x31,0x03,0xD2,0x60,
	0xDC,0x1C,0x46,0x57,0x1F,0x59,0xC6,0xFA,0x2F,0xB0,0xDD,0x98,0xEC,0x3F,0x40,0x05,0xD4,0xD7,0x29,0x5D,
	0x08,0x6A,0x9B,0xEF,0xEE,0xBA,0x57,0x25,0xF6,0xBE,0xEF,0xAB,0x76,0x5C,0xFB,0x6B,0x02,0x66,0xB8,0xA0,
	0x19,0xF3,0xAD,0xB3,0xDD,0x48,0xB8,0xBE,0x09,0x2B,0x24,0xDF,0x9D,0xBA,0x22,0xB8,0xFE,0x44,0xB7,0x38,
	0xB2,0x64,0xA8,0x21,0x45,0x70,0xAE,0xC4,0x9D,0x68,0x9A,0xAD,0xFB,0x92,0x0C,0x64,0x98,0x85,0x64,0x24,
	0x01,0x92,0xDC,0x07,0x22,0x9A,0x62,0x8E,0x5A,0x18,0xE0,0xE8,0xE8,0xEB,0xD2,0x94,0x81,0xA9,0x19,0x76,
	0x66,0x4D,0xD2,0x24,0x4D,0x7B,0x53,0x60,0x48,0x7D,0x4D,0x24,0x4D,0xD2,0x24,0x7A,0x72,0x47,0x67,0x74,
	0xBA,0xDD,0x5A,0xD2,0x64,0x69,0xCF,0xF8,0x2E,0x48,0x89,0xA9,0x7D,0xD3,0x74,0x7B,0x2C,0x75,0x07,0xFC,
	0x0A,0x07,0x72,0x5F,0xE7,0x8C,0xEB,0x2A,0x04,0xE2,0xDC,0xE7,0x9D,0x01,0xE3,0xBB,0xCB,0xDC,0x11,0x29,
	0xC3,0x5F,0x08,0xB3,0x5C,0xA5,0x54,0xA0,0xCD,0xE4,0xAF,0xDA,0x0D,0xDD,0x56,0xE0,0x83,0xCD,0xB1,0x3F,
	0xE5,0xA2,0xAE,0x55,0x9C,0x71,0xBF,0x0C,0xEC,0x03,0x76,0xA2,0xF7,0xAE,0x69,0xCA,0xFF,0x40,0xCD,0x9E,
	0x18,0x5B,0x9E,0x59,0x3B,0x59,0x4D,0xBA,0xEE,0x88,0x37,0xE3,0x12,0x2C,0x45,0x8A,0xE5,0xB4,0x24,0x3B,
	0x7F,0x7C,0xF4,0x57,0xEA,0xC3,0xC8,0xC3,0x40,0xEC,0xBA,0x3D,0xF5,0x97,0x62,0x21,0x60,0xAC,0x74,0x8F,
	0x92,0xEA,0x7C,0x86,0xFB,0x5F,0x01,0xB6,0xB8,0x56,0xAE,0xBB,0xAE,0xCC,0x91,0x90,0xDE,0x96,0x04,0x72,
	0x4D,0x5C,0x34,0xA5,0x58,0x68,0x16,0x5E,0x1B,0x12,0x72,0x7D,0x52,0x4A,0x37,0x8C,0xE4,0xDC,0x75,0x3B,
	0x9E,0x99,0xFA,0xE7,0x99,0x36,0x26,0xD8,0xF5,0x47,0x43,0xB6,0x33,0x32,0x5B,0x49,0x5F,0x5D,0x37,0xCD,
	0xC3,0xE8,0x6F,0x19,0x8C,0x1F,0xEC,0x2D,0x9A,0x59,0x2F,0x62,0x60,0xA7,0x25,0x1E,0x81,0x61,0xEF,0xEB,
	0xCC,0x3D,0xD2,0xD6,0x46,0xD7,0xEB,0xE2,0xF0,0xFA,0x4B,0xC8,0x25,0xE4,0x15,0xEF,0x9E,0xA8,0xB2,0x21,
	0xC2,0xB8,0x6E,0xB4,0xA8,0x61,0x81,0xD5,0x45,0xED,0x8C,0x48,0xEF,0xE2,0xBB,0x7B,0x84,0x5D,0xA2,0x50,
	0x68,0x84,0x69,0x95,0x53,0x8D,0x74,0xF7,0x72,0xBA,0x44,0xFB,0xD8,0x5F,0xF5,0xEF,0xF4,0xBF,0x61,0xF0,
	0x1F,0x83,0xAF,0x99,0x60,0x18,0x31,0xA4,0x57,0x65,0x90,0x15,0x12,0x98,0xEA,0x84,0x48,0x51,0xC6,0xD0,
	0xBC,0x55,0x3A,0x46,0x07,0x4A,0x7D,0x66,0x7C,0x77,0x79,0x96,0xEC,0xF9,0x6F,0xEF,0xAF,0xBB,0x7F,0x99,
	0xE0,0xC9,0x79,0x37,0x93,0xC9,0xC2,0x88,0xA0,0xB4,0x9C,0x1F,0x06,0x39,0xC0,0x26,0x6F,0x10,0xDB,0x17,
	0xAB,0x9B,0x49,0xCA,0x4C,0x20,0xC9,0x81,0xF1,0xF8,0x2E,0x3F,0xC3,0xF3,0x86,0x01,0x14,0x06,0xCC,0xD4,
	0xF8,0x1E,0x14,0xD7,0x2F,0xFE,0xB3,0xBF,0xBE,0x26,0x1F,0xF4,0xFA,0x17,0x16,0x25,0x2E,0xFB,0x6A,0x0F,
	0xB7,0xED,0xF9,0x17,0x1A,0xF7,0xBF,0x03,0xE3,0x3B,0x3D,0x07,0x6F,0xCC,0x57,0xCE,0xDB,0x97,0xB5,0xEC,
	0x05,0xB5,0xEE,0x39,0xE1,0x66,0xBC,0x15,0x94,0x9B,0x55,0x00,0x5C,0x95,0x4E,0xC8,0x47,0x57,0x97,0xDF,
	0xF9,0x88,0x88,0x0E,0xA4,0x3B,0xCE,0xEE,0xB5,0xCA,0x8F,0xA7,0x06,0x8F,0xFD,0xCB,0x1D,0x2E,0xD9,0x9F,
	0x14,0x73,0x2D,0xDB,0x8C,0xAA,0x91,0x41,0x01,0x94,0x9B,0x3C,0xE6,0x7C,0x89,0xA8,0x8F,0xD6,0xC5,0x82,
	0x10,0xAB,0x38,0x34,0x31,0xDE,0x3F,0x56,0xEE,0xCA,0xA1,0xA2,0x71,0x3C,0xF3,0x50,0xEF,0xA5,0x48,0x7D,
	0x84,0xEC,0x6F,0x58,0xE0,0x14,0x3A,0xA2,0x81,0xD3,0xAA,0xD8,0xF5,0xDD,0xE4,0xD7,0x5A,0x0F,0xB5,0x9D,
	0xD3,0xBA,0xBB,0x53,0x41,0xBA,0x93,0xE4,0x8F,0x8B,0xC7,0x2F,0x30,0x1F,0xB9,0xC0,0x92,0x82,0xFD,0x44,
	0x41,0x81,0x24,0xCD,0x60,0x15,0xE8,0x50,0xCA,0x36,0x4B,0x14,0x2B,0x04,0x5A,0xCB,0xA1,0xC0,0x31,0xAB,
	0x3A,0xEA,0x06,0xCC,0x1E,0x37,0xB2,0xE3,0x96,0xC9,0x90,0xFD,0xB7,0xC2,0x80,0xAE,0x63,0x23,0xD6,0x3A,
	0x70,0x81,0x39,0xEF,0xE0,0xA7,0x25,0x25,0x88,0xBF,0x88,0x75,0x97,0x8B,0xEB,0xD5,0x1D,0x19,0x79,0xC0,
	0x74,0x57,0x47,0xE7,0x52,0xC0,0xA2,0x14,0x15,0xD8,0x88,0xC4,0xA2,0x04,0x8B,0xED,0x25,0x0E,0x99,0xBF,
	0x96,0x80,0xB0,0xA2,0xC6,0x91,0xEA,0x39,0xE3,0x18,0xFB,0x35,0xBB,0x26,0x33,0x72,0xB3,0xAE,0x96,0x2D,
	0xD1,0xF1,0x6D,0xF1,0xA6,0x07,0x31,0x55,0x1A,0x06,0x64,0x5B,0x2C,0xD8,0x69,0x55,0x66,0x97,0x24,0x5F,
	0xAA,0xBF,0x22,0xC1,0xAE,0x05,0xA3,0xBE,0x11,0x43,0x47,0x73,0xF7,0x9D,0x81,0x40,0x79,0xD0,0xE6,0xCC,
	0x13,0x96,0x9F,0xB0,0x44,0x3F,0xE5,0x0D,0x8F,0x5A,0x55,0xEF,0xA0,0x27,0x98,0x9D,0xD4,0x56,0x56,0x47,
	0x54,0x42,0x40,0x55,0x5B,0x7E,0x95,0x12,0x71,0x93,0xFE,0x6F,0x4B,0x17,0x0C,0x1A,0x26,0xC0,0xBA,0xDA,
	0xF3,0xF0,0x6F,0x27,0x0D,0xA2,0x76,0xA5,0x02,0xDD,0xA5,0xE0,0x75,0x90,0x64,0x0C,0xE4,0xDC,0x49,0xDF,
	0xED,0xE2,0x39,0x3A,0xC9,0xB1,0xD2,0x6B,0xEB,0x51,0xF8,0x28,0x04,0x56,0x2D,0xBF,0x04,0xAB,0xDE,0x0A,
	0x82,0x77,0xD3,0xF6,0x67,0xE3,0xD3,0xB5,0x3B,0x18,0x0E,0x2E,0xB6,0x4A,0x89,0x61,0xB2,0x4C,0x3F,0xBE,
	0x2D,0xBA,0x83,0xF1,0x5A,0xF0,0x0C,0x19,0x42,0xFA,0x8D,0x35,0x47,0x24,0x32,0x77,0x75,0x10,0x41,0x65,
	0x1B,0xE7,0x1F,0x8D,0x69,0x7F,0x65,0x83,0x26,0xBA,0x1D,0x56,0x7C,0xE4,0x02,0xA3,0x97,0xF9,0xCF,0xF3,
	0xB7,0x57,0xE4,0x7F,0x43,0xF5,0x00,0xF9,0x12,0x03,0xE1,0x6F,0x3D,0xFD,0xBD,0x7C,0xD7,0x63,0x30,0xC5,
	0xB9,0x6A,0x07,0x61,0x3E,0xD8,0x98,0x44,0xA3,0x65,0x53,0xF1,0x98,0xA1,0x02,0x8F,0xCA,0xAF,0x1D,0xBC,
	0x7B,0xD5,0x86,0x5D,0x4E,0x3F,0x0E,0x0A,0x60,0x62,0xC2,0xBF,0x6E,0xE0,0x59,0xAD,0xFB,0x54,0xB6,0x8E,
	0xE1,0x3C,0x05,0xD1,0x5E,0xAF,0x29,0x7B,0x74,0x61,0x47,0xF6,0xD7,0x65,0x45,0x6C,0xEE,0x5C,0x2C,0xC9,
	0x68,0xA7,0xFE,0xA8,0xC6,0xE0,0xC4,0xFF,0x01,0x00,0xC5,0xF4,0x59,0xE9,0xF1,0xA8,0xDE,0x94,0x22,0xEF,
	0x87,0xF0,0xCF,0xA4,0xDC,0xAD,0xFE,0xFC,0x90,0x5F,0xA1,0x76,0xFB,0x8E,0x9A,0x1E,0x95,0xDD,0xB9,0xE9,
	0x89,0x48,0x14,0x0C,0x10,0xDA,0xAC,0x88,0xC0,0x99,0xA3,0xC0,0xD2,0x3D,0x64,0x29,0xD0,0xD5,0x6E,0x34,
	0x02,0xF7,0x06,0x7C,0xF0,0x3D,0xC1,0xA7,0x64,0xAA,0xEC,0x09,0xBD,0x38,0xD7,0xB7,0xF8,0x84,0x62,0x5B,
	0x9F,0x0D,0x52,0xB4,0x85,0x51,0xF3,0x83,0xBE,0xBE,0x26,0x48,0x37,0x4C,0x6A,0x84,0x71,0x6C,0x09,0xBE,
	0xFD,0x75,0x24,0x2D,0x55,0x5A,0xB5,0x0E,0x77,0x91,0x08,0xC0,0x77,0x47,0x0C,0x28,0xBF,0xDB,0x3B,0x77,
	0x54,0x1D,0xAA,0xA2,0x75,0x14,0x7D,0xE1,0x5D,0xD4,0x47,0x7D,0xE9,0x5A,0x08,0x03,0x85,0x73,0xE8,0xBB,
	0x8A,0x9B,0x48,0xB0,0x82,0x28,0x8C,0x4D,0x5B,0x40,0x0B,0x69,0xCE,0x69,0x35,0xFE,0x95,0x32,0x33,0xA3,
	0xC6,0x98,0x45,0x69,0x07,0x0D,0x43,0x77,0xC9,0xD3,0x35,0xAB,0xD3,0xAC,0xBA,0xEB,0xC3,0x9D,0x0C,0x06,
	0x70,0xB6,0xDE,0x76,0xAC,0x31,0x41,0xD5,0x3D,0xC5,0xFA,0x35,0xC7,0x42,0x8B,0x34,0x37,0xFE,0x5E,0xCC,
	0x00,0xBE,0x90,0xB9,0x2E,0xF1,0x58,0x76,0x27,0xEE,0x16,0xE1,0x94,0x5C,0x75,0xC1,0xF1,0x61,0xC4,0x4B,
	0xF3,0x74,0x54,0xE3,0xF4,0x80,0x62,0xEC,0x14,0x12,0x73,0x75,0x56,0x19,0x3E,0x3C,0x2C,0x57,0x79,0xF9,
	0xF6,0x0F,0xAF,0x34,0x5E,0xBF,0x61,0x58,0xD2,0xF5,0xD1,0x93,0x02,0x8B,0x97,0x12,0x6F,0xFD,0x1B,0x21,
	0x97,0x24,0xD9,0xE0,0x59,0x2A,0x27,0x52,0xAD,0x4C,0x8B,0xCC,0x3E,0x55,0xF5,0x33,0x39,0x1A,0x59,0x1E,
	0xAF,0xC9,0x15,0xCC,0x79,0x16,0x2D,0xB9,0x40,0x44,0x2E,0x69,0xD8,0x7E,0xFF,0x0E,0x28,0xDB,0xC4,0x54,
	0x1A,0xAD,0x3F,0x1D,0x76,0xE3,0x2B,0x25,0xF9,0xD8,0xA2,0xDD,0xAB,0x8F,0x1A,0x7F,0x35,0x22,0x98,0x99,
	0x76,0x74,0xEB,0xF7,0x4B,0xFB,0x8A,0x5A,0x24,0x8B,0x29,0xE2,0xFD,0xE6,0xD7,0x8E,0xF9,0xE5,0x48,0x52,
	0x9D,0x95,0x42,0x15,0x8F,0x28,0x5E,0x0B,0xF7,0x84,0x57,0x7A,0x6E,0x7D,0x92,0x58,0xE3,0x05,0xA9,0x29,
	0x7C,0x6E,0x5F,0x7E,0x01,0x20,0x69,0xDD,0x23,0xED,0x06,0xD3,0x87,0x7D,0x5A,0xB1,0x1B,0xDE,0x57,0x98,
	0x93,0x98,0x93,0x02,0x72,0x43,0x9F,0x83,0x0E,0x5C,0x4C,0x64,0x9D,0x7D,0x7A,0x4A,0xB5,0x2C,0xFB,0x96,
	0x6D,0x65,0x38,0x5F,0xBF,0x22,0xFC,0xBE,0x66,0xFC,0x7F,0xEE,0xBA,0x28,0xA9,0x7E,0x6B,0xB7,0xAF,0x97,
	0xF0,0xDF,0xF0,0xB3,0x73,0xB7,0x3B,0x53,0x5D,0x98,0x58,0xDE,0x85,0x66,0x5F,0x2E,0x0A,0xF4,0x19,0x43,
	0x10,0x02,0xED,0x73,0x23,0xDF,0x35,0x0C,0x0B,0xB0,0xBA,0x39,0x5E,0x65,0x58,0xDD,0xEB,0x82,0xAC,0xA7,
	0x31,0x1E,0xB0,0x8E,0x5D,0xF7,0x91,0x1C,0xB2,0x4B,0xD6,0x22,0x22,0xFF,0x05,0x1A,0x33,0x2B,0x39,0xF6,
	0x89,0xF9,0x93,0xF2,0xAF,0x15,0x37,0x9A,0x72,0x30,0xC9,0x67,0x8F,0x0C,0xD6,0x45,0xD3,0x09,0x63,0x63,
	0xFB,0xEA,0xFE,0x2D,0x73,0x70,0x25,0xDA,0x9E,0xC8,0x47,0xA7,0x83,0x40,0x0D,0xC6,0x20,0x13,0x9A,0x7E,
	0x1B,0xD4,0x75,0x81,0xCE,0x46,0xF4,0x4A,0xE9,0x0C,0x3C,0xF0,0x03,0xA4,0x3B,0x1E,0xC7,0x0B,0x81,0xC2,
	0xA2,0x1B,0x5A,0x2A,0x0C,0xC6,0x29,0x80,0x18,0xB3,0x8E,0x79,0xEE,0xC6,0xF0,0xE3,0x78,0x97,0x12,0x32,
	0xCB,0xC1,0xFF,0x5D,0xAC,0xD7,0x5F,0x3C,0x93,0xEE,0x8F,0xF8,0x77,0xA9,0xE3,0x0A,0xD0,0x7D,0xD8,0x5F,
	0x1A,0x03,0x1F,0x5A,0x93,0x35,0x56,0x07,0x7B,0x62,0xDD,0x7A,0x75,0x5B,0xC6,0x00,0x28,0x05,0xFA,0x7E,
	0xED,0xF0,0xE4,0x78,0x39,0x60,0xED,0xFF,0x05,0xE4,0x75,0x16,0xE3,0x76,0x33,0xB1,0x35,0x35,0x20,0x2C,
	0x51,0x22,0xEB,0x7D,0x77,0x60,0xA8,0xC9,0x75,0xBC,0x7B,0x91,0x66,0x0C,0x2A,0x31,0xF9,0x11,0x0C,0x6A,
	0x1D,0x65,0x5B,0x09,0xE5,0x3F,0xA5,0xEC,0xF0,0x0A,0xBA,0x16,0xBB,0x92,0x94,0x80,0x43,0xEC,0xFD,0x1E,
	0xA2,0x52,0xB3,0xBB,0xE5,0xEF,0xBA,0x80,0x53,0xEA,0xFB,0xA4,0xDD,0x5F,0x83,0x9B,0xB1,0xAE,0x4A,0x73,
	0x5E,0x00,0xC3,0x42,0xC2,0xC1,0x66,0xA4,0xDD,0x7D,0x7D,0xB1,0x56,0x33,0x83,0x4F,0xC6,0x47,0x6A,0x1B,
	0x97,0x08,0x83,0xB4,0x07,0x90,0x26,0x00,0xAF,0x63,0x31,0x18,0xA4,0x96,0x17,0xDF,0xBB,0xFC,0x09,0x8D,
	0x31,0x1A,0xAA,0x36,0x5B,0x1F,0x84,0x35,0x70,0x33,0x7E,0x0A,0x7B,0x60,0xD5,0x3B,0x16,0x99,0x2A,0x18,
	0x05,0x88,0xEC,0x1A,0xF5,0x34,0x05,0xC2,0xD2,0xDD,0x29,0x69,0xA5,0x17,0x44,0xFF,0x75,0x24,0x55,0x7B,
	0xC2,0xA5,0xED,0x73,0xBE,0x5A,0x38,0xAA,0xEB,0xAA,0xEC,0xAC,0x11,0x2A,0x13,0x2D,0x86,0x13,0xEE,0xFD,
	0xC7,0x08,0x52,0xD7,0x7F,0x4D,0x65,0xB8,0x21,0xCD,0x53,0x77,0xBA,0x54,0x29,0xC0,0x75,0xDA,0x3B,0x43,
	0x7F,0x3C,0x63,0x9C,0x72,0x5D,0x7F,0x68,0xFB,0x48,0x5D,0x4B,0xD4,0x07,0xA8,0xF6,0x61,0xF5,0xC4,0x5D,
	0xAD,0x48,0x7C,0xE5,0xA8,0xB5,0xF9,0x31,0x70,0xC5,0xB5,0xD4,0x2D,0xA8,0x0B,0x2A,0x02,0xFA,0x83,0xC9,
	0x25,0x39,0x6F,0xAE,0xCF,0xC1,0x84,0xDE,0x2E,0xBE,0x7B,0x46,0x5E,0x4A,0x9E,0xCC,0x46,0x04,0xCB,0x91,
	0xCB,0xFA,0xD2,0x0D,0xDF,0xD0,0x41,0xD4,0x0F,0xF7,0x87,0xBC,0xD5,0xBF,0x14,0xA8,0x77,0x97,0xD7,0x76,
	0x81,0x8B,0x98,0x51,0x68,0x8B,0x3D,0xE2,0xF7,0x17,0xFB,0x8F,0xD4,0x7F,0xCB,0x2E,0xAB,0x6F,0x5D,0x8C,
	0x6F,0x46,0x9F,0xC7,0xE8,0xD2,0x9D,0xC5,0xA5,0x17,0x50,0x7E,0x8C,0xD0,0xB0,0x70,0x55,0x10,0x69,0x4A,
	0x7B,0x5B,0x4B,0x36,0x4F,0x0F,0x85,0xE2,0xD4,0xA9,0x58,0xF8,0xEF,0x82,0x77,0x3A,0x38,0x13,0x36,0x22,
	0xFC,0x0B,0xDE,0xCA,0xEB,0x7A,0x88,0xFE,0x5F,0x64,0xCB,0x80,0x83,0xAE,0xD5,0x84,0x0A,0x32,0xCF,0x08,
	0x26,0x20,0x9B,0xA3,0xFB,0x05,0xC8,0xE2,0xCD,0x2A,0xFE,0x78,0x25,0xD2,0x94,0xDE,0xBD,0x20,0xAD,0x03,
	0x78,0x3D,0x10,0x2B,0x4C,0xD3,0x86,0x20,0x5E,0x4A,0xAB,0xEA,0xD0,0xD2,0x31,0x47,0x93,0xFB,0xAB,0x69,
	0xE5,0xBF,0x8C,0x82,0xC5,0x14,0xC4,0x1E,0xEF,0x13,0xE9,0x77,0x61,0x62,0xC1,0x58,0x65,0x67,0x7C,0x26,
	0xC1,0x31,0xAE,0xBB,0x76,0xD9,0x75,0x6A,0xE6,0xD4,0xB5,0x7B,0x73,0xDD,0xFB,0x6F,0x80,0xB7,0xFA,0xEE,
	0x0D,0x39,0x4E,0x71,0x62,0x68,0x2E,0x9C,0xCA,0x8E,0x40,0x85,0x60,0x53,0x29,0x1D,0x51,0x46,0xD2,0xF4,
	0xBB,0x3B,0x84,0xD5,0x85,0x80,0xC6,0xDA,0x40,0xED,0x63,0xF4,0xBE,0x0C,0x48,0x08,0x25,0x23,0x0C,0x9A,
	0x0D,0x71,0xAA,0x11,0x38,0x4A,0x85,0xDE,0x12,0x41,0x95,0x2F,0xB8,0xF4,0x75,0x86,0x52,0x35,0xD5,0x51,
	0x11,0xB8,0x02,0x4E,0xB8,0x5A,0xE3,0x93,0x2B,0xBB,0xEE,0xA4,0xA1,0xD6,0xD5,0xB1,0x02,0xF6,0x42,0xBA,
	0xF6,0xDD,0x88,0x87,0xB9,0xF6,0x39,0xAE,0x20,0x9F,0x57,0xF7,0x94,0x44,0x3D,0x86,0xC0,0x1C,0x29,0xFF,
	0x97,0xB7,0xFD,0xF5,0x16,0x5E,0x63,0xF6,0x46,0x1A,0xFD,0x6E,0x10,0x41,0xAD,0xEE,0xF9,0xBF,0x0E,0x71,
	0x2D,0x88,0x14,0x9F,0x64,0xA1,0x1B,0x2B,0x68,0x6C,0xC4,0xC8,0xF8,0x8D,0x2E,0x6F,0xF3,0x57,0xFA,0x81,
	0xA0,0x2F,0x94,0xEA,0x3F,0x61,0xAE,0x5F,0x32,0xDC,0x20,0x09,0x0D,0x36,0x92,0x6F,0x44,0x82,0x8F,0x45,
	0xED,0xDF,0x91,0x2A,0xEF,0xD3,0x5D,0xA8,0x59,0x21,0xE7,0xAB,0x83,0x31,0x8B,0xBD,0x77,0x3B,0x14,0x6B,
	0xE0,0x0A,0xD7,0x3E,0x40,0x42,0x8F,0xA2,0xFD,0xBE,0xBF,0xCC,0x45,0x4D,0x34,0x0E,0xBB,0x34,0x04,0x24,
	0xC4,0x3C,0x0D,0xC9,0x1C,0x63,0xA5,0x89,0x6A,0xC3,0xE1,0xF3,0x9B,0xD0,0x59,0xD3,0x0A,0xCE,0x93,0x0B,
	0x38,0x81,0x7A,0x58,0x26,0x24,0x55,0xDD,0x89,0xD0,0x7A,0x1D,0x56,0xFD,0x09,0xD6,0x23,0xC0,0xFE,0x2D,
	0x50,0x2C,0xE6,0x82,0x5C,0xBD,0xDD,0x57,0x2A,0xE2,0xB1,0x44,0x0D,0x8A,0x9C,0x74,0x5D,0x5F,0xD8,0x81,
	0xB6,0x28,0xB4,0xED,0x74,0xA2,0x94,0xC9,0xA7,0x94,0xBE,0x4A,0x3B,0x52,0x48,0x34,0x43,0x76,0x0E,0xE3,
	0x43,0x8B,0x8B,0x55,0x2B,0x8F,0xB2,0x3B,0x05,0xC2,0xA6,0x0B,0x17,0x86,0xBE,0xDA,0x10,0xC9,0xA5,0x08,
	0x2C,0x0E,0x01,0x8E,0xBA,0x83,0x1B,0xA8,0xF2,0x11,0x81,0x4A,0xF7,0x76,0x0F,0xDF,0xAB,0x2A,0xB2,0xD0,
	0xA6,0xE9,0x57,0x43,0xC5,0x4B,0x77,0x9D,0x5D,0x10,0x0A,0x51,0x25,0x1B,0x06,0x16,0xA5,0x3F,0x66,0x90,
	0x8F,0x0F,0xF8,0xD5,0xE3,0xF6,0xDC,0x5A,0x67,0x9B,0x69,0xC5,0x57,0x48,0x75,0xAE,0xE2,0x1B,0x5D,0xB0,
	0xF4,0x70,0x17,0xC9,0xAD,0xE4,0xCA,0x5E,0xB8,0x5F,0x91,0xEB,0xF3,0xBF,0x68,0xEF,0x44,0xAE,0xEA,0x01,
	0xBE,0x0B,0x49,0x82,0x12,0xDD,0xF4,0xA6,0xDA,0x62,0x6A,0x78,0x5D,0x3F,0x0A,0x46,0x0F,0x87,0x86,0xD2,
	0x34,0xCE,0x57,0x40,0xA7,0xCA,0xB4,0x7B,0xFE,0x5A,0x51,0x5E,0x97,0x52,0x00,0xB0,0xC2,0xF0,0xDB,0xB8,
	0x2E,0xD6,0xEF,0xAD,0xD5,0xB8,0x26,0xE8,0xE5,0x29,0x72,0xC3,0xFF,0x7D,0x9E,0x95,0xC4,0x44,0x30,0x9F,
	0x76,0xB2,0xAE,0x3E,0x71,0xFB,0x2E,0x64,0xA2,0xC4,0x68,0xB7,0x04,0x8B,0x99,0x01,0x03,0xA0,0xB2,0x55,
	0x3D,0xAB,0x26,0x27,0xFD,0x2E,0x96,0xF8,0x0D,0x83,0x75,0x19,0xFD,0xAF,0xE6,0x78,0x5F,0x8C,0x17,0x6C,
	0x6A,0x60,0x1B,0xEC,0x7D,0x0C,0x12,0xE2,0xAF,0x51,0xC3,0x03,0x74,0x1A,0x61,0x9A,0xA6,0x06,0x7C,0x74,
	0x6C,0x14,0xB6,0x44,0x05,0xBA,0x0A,0x6E,0xF0,0x24,0x64,0xD9,0x29,0x6B,0x43,0x36,0x3B,0x5C,0xF5,0x2E,
	0xBC,0xDF,0x60,0x4D,0x17,0x1F,0xF2,0x11,0xD6,0x54,0x45,0xE1,0xE3,0x2B,0xE8,0x5C,0xD7,0x09,0x44,0x54,
	0x0A,0x88,0x68,0x65,0x89,0x40,0x9B,0x85,0x57,0x75,0x3A,0xCD,0x18,0xAB,0xEB,0xFA,0xC7,0xF6,0xE1,0x5B,
	0x3A,0xB5,0x21,0xED,0x45,0x83,0xB6,0x84,0xA7,0x04,0xC9,0x68,0x17,0x2E,0x8B,0xD7,0x55,0xA8,0xB2,0x88,
	0x24,0xEB,0xC9,0x35,0x47,0xFD,0xF3,0x76,0x6E,0xDD,0x49,0xB2,0xCA,0x59,0x82,0x4D,0xFA,0xDD,0x35,0x5C,
	0x01,0x5B,0x13,0xC7,0xA3,0x2A,0xC1,0x0A,0xA4,0x05,0x13,0xC3,0xAA,0xFD,0xB3,0xD0,0x56,0xA1,0x52,0xCA,
	0x92,0xC5,0xB1,0x53,0x24,0x1D,0x8C,0x88,0x01,0xD7,0x5F,0x5B,0x45,0xEC,0x33,0x85,0x59,0xFA,0x54,0x75,
	0x20,0xFA,0x5D,0x7C,0xDD,0x43,0x75,0x22,0xBE,0x92,0xAF,0x3A,0x80,0x82,0x0D,0x5D,0x60,0xB8,0x28,0x2E,
	0xEC,0x0F,0x87,0xEF,0x37,0xCB,0xD8,0xA9,0xED,0xA9,0xB5,0x7F,0x65,0xE4,0xB3,0x2B,0x56,0x5D,0x6C,0x2A,
	0x63,0xC3,0x7D,0x7E,0xC5,0xE0,0x45,0x36,0x0D,0xEA,0xCF,0xA7,0x62,0x59,0x27,0x7E,0xAE,0x82,0x39,0xA7,
	0x4C,0x41,0x85,0x60,0xE5,0x66,0xF6,0x5E,0xD6,0xA3,0x6A,0xCF,0x8D,0x97,0xF6,0xF8,0xE1,0x82,0xAA,0x19,
	0x5E,0xEC,0xA8,0x81,0x79,0x65,0xC9,0xD1,0xF1,0x0F,0x98,0x26,0x96,0xF6,0xFE,0x5F,0xA0,0xD1,0xC2,0x6F,
	0x70,0x91,0xEB,0xCE,0x0B,0xDC,0x44,0xF6,0x21,0x7D,0x87,0xFE,0xA6,0x4F,0xD7,0x4E,0xFF,0xAC,0xE1,0xAC,
	0xB2,0xA2,0x5B,0xE0,0x30,0x49,0x07,0xD1,0x80,0xB8,0xDC,0x9C,0xB8,0x2E,0x18,0x9D,0xBA,0xB9,0x88,0x41,
	0xA0,0x66,0xDA,0xA1,0x9A,0xAB,0xAF,0x9D,0x55,0x27,0x47,0x5E,0x97,0x5E,0xA8,0x10,0x50,0xAA,0x63,0x81,
	0x17,0x0D,0x11,0x41,0xBF,0x0C,0xA8,0x06,0x30,0x8A,0xEB,0x8C,0x33,0xE9,0x24,0x9D,0xB6,0x03,0x50,0xA1,
	0x2B,0x1F,0xAD,0x1C,0x40,0x2C,0x72,0x0E,0x18,0x3B,0x54,0x16,0xBA,0x7A,0xE2,0xF6,0x1A,0x77,0x77,0x87,
	0xAB,0xB6,0x50,0xFE,0x51,0xE4,0xFA,0x50,0x58,0xA0,0xB5,0x92,0xAD,0xEE,0x7A,0xA0,0x6D,0x65,0xA9,0x30,
	0xAB,0x2E,0x07,0x89,0x5C,0xF9,0xF5,0x8D,0x97,0x3A,0xD5,0xD4,0x37,0x8F,0xA0,0xE8,0x2C,0xFE,0xF1,0xD1,
	0x61,0x02,0xDA,0x34,0x41,0x39,0x08,0x54,0x4C,0xA4,0xC7,0x37,0x23,0xB8,0xEF,0xBD,0x05,0x55,0x75,0xA1,
	0x7D,0x21,0xC9,0x9D,0x5D,0x9F,0x11,0xF9,0xF6,0xE6,0xFB,0x19,0x74,0xEC,0xEA,0x22,0x87,0xC7,0xA4,0xE1,
	0xD5,0x3A,0x4F,0xFE,0xFD,0x03,0xEB,0xEE,0x1E,0xBF,0x62,0xDD,0x25,0xA8,0xAC,0xCB,0x60,0x2E,0x84,0xF2,
	0x5F,0xAE,0x89,0x4B,0xF3,0x99,0x79,0xB1,0xEE,0xD2,0x94,0x35,0x74,0x50,0x7A,0xBA,0xF2,0x82,0x65,0xAA,
	0x69,0x50,0x10,0x53,0x29,0xBA,0x46,0xFF,0xAF,0xE2,0xAC,0xA4,0xE2,0x47,0x41,0x5A,0x26,0x4D,0x2E,0x65,
	0x07,0x8F,0x95,0xA3,0x85,0xB6,0x7E,0x67,0x6C,0x74,0xB4,0xE9,0xA8,0x45,0xA7,0x45,0xE3,0xDC,0x2B,0x1F,
	0x8E,0x1F,0x7D,0xBB,0xFA,0x58,0xAB,0x1F,0xE9,0x35,0xA9,0x15,0x3F,0xFF,0x3D,0xA0,0x80,0x0C,0xDC,0x12,
	0xD1,0x57,0xA9,0xD6,0xEA,0x29,0x80,0x43,0xB0,0x19,0x1E,0x57,0x33,0xD0,0x00,0x10,0x75,0xE5,0x8C,0x43,
	0xB9,0xD8,0xAD,0xC0,0x9C,0x49,0xB1,0xE6,0x4C,0xB8,0x97,0xC8,0xC6,0x50,0xCE,0xF1,0x9A,0xE6,0x92,0xEB,
	0xC0,0x07,0x5A,0x28,0xC5,0xFB,0x8C,0x2E,0x67,0xAC,0x05,0xCB,0xC1,0xE7,0xE4,0x38,0x3A,0xA8,0x0A,0xE5,
	0xD3,0x4B,0xAF,0xBB,0x43,0xC5,0xC2,0x90,0x9F,0x7E,0x7A,0xCF,0x08,0x38,0x7C,0xE0,0xD2,0xC0,0x5D,0x29,
	0x20,0x00,0x2A,0x4F,0x24,0x3A,0x5A,0x27,0x7B,0x2D,0xB8,0xF6,0xB0,0x72,0x73,0x4A,0x7B,0x72,0x16,0x1C,
	0x11,0x62,0x9E,0xBB,0x31,0x50,0xF8,0x3B,0xA9,0x2D,0x1F,0x5C,0x25,0xF2,0xBE,0x97,0x6E,0x33,0x72,0x89,
	0x0F,0x95,0xD9,0x3F,0x2E,0x18,0x54,0x8C,0xFC,0xBC,0x2C,0xCF,0xF6,0x92,0x89,0x9C,0xB0,0xC9,0x43,0x5D,
	0x4D,0x8F,0xC0,0x56,0x15,0x0E,0xA9,0x4D,0x67,0x98,0xD7,0x21,0xB0,0xB6,0x94,0x90,0x75,0x14,0x78,0x19,
	0xC3,0x8D,0xFA,0x82,0x54,0x30,0x4B,0x42,0x03,0xF2,0x11,0x28,0x96,0x26,0x56,0xE6,0x93,0x94,0xC5,0xDE,
	0x77,0x89,0xDC,0x7A,0x4C,0x5A,0xE6,0x08,0xE8,0xD5,0x9D,0x16,0x12,0xD5,0xDD,0x45,0x9F,0xFB,0xC1,0x78,
	0x4C,0xEE,0x5E,0x9D,0xD4,0x81,0x08,0x06,0x59,0xF5,0x57,0x40,0x81,0x51,0xA5,0xD7,0xB9,0x78,0xE5,0x7B,
	0x38,0x6C,0x5F,0x3B,0x92,0x24,0x49,0x21,0x7E,0x4F,0x78,0x61,0x10,0x73,0x84,0x49,0x6A,0x6B,0xCF,0x69,
	0x03,0xB3,0x85,0x61,0x31,0x9F,0xA4,0xB8,0x39,0x9F,0x23,0xDD,0x5C,0xEC,0x62,0xEB,0xDB,0x60,0xE0,0x62,
	0x1D,0x7A,0xBD,0xA3,0x1F,0xB9,0x09,0x6F,0x0B,0xCC,0x12,0xB7,0x1F,0x06,0x5D,0x34,0xA0,0x02,0x0C,0x4F,
	0x71,0x08,0x4C,0x34,0x4E,0xF1,0xB9,0x2E,0xBA,0x5E,0x75,0x62,0xD6,0x84,0x85,0xC7,0xD6,0x17,0x1F,0xDA,
	0x41,0xA0,0x75,0x79,0xD9,0xAD,0xF2,0x59,0xB9,0x9A,0x9F,0x55,0x86,0xD4,0x9D,0x76,0x65,0x0A,0xC7,0x05,
	0xFA,0x5D,0x5E,0xBF,0x24,0x49,0xEA,0x5D,0x45,0x43,0x00,0x32,0xDC,0x05,0xB0,0x0D,0x27,0xE9,0x6A,0x2B,
	0x12,0xC1,0xB9,0x04,0x0A,0x99,0x4F,0x53,0x74,0x28,0xFB,0xEE,0x99,0x8C,0xE8,0xEE,0x0C,0xFB,0x1A,0x3D,
	0xAF,0xE3,0xCE,0xB6,0x4E,0x11,0xCD,0x41,0x34,0x70,0x57,0x2E,0xFE,0xEA,0x7A,0xA4,0x04,0x98,0x2C,0x45,
	0x05,0x71,0x72,0xD1,0xDD,0x89,0x9A,0x61,0x1F,0xAC,0x27,0xF8,0xBA,0xDC,0xA4,0xCB,0x21,0x24,0xDE,0x90,
	0xA2,0x50,0x7A,0x6E,0x66,0xAB,0x25,0xCF,0x28,0xE5,0x35,0x2C,0xD7,0x2B,0x94,0x37,0x75,0x6E,0x93,0x97,
	0xF8,0xA8,0xF0,0x08,0xB8,0xBA,0x65,0xD1,0x22,0xB4,0x84,0xB8,0xC6,0x0D,0xD9,0xA4,0x90,0xC9,0x8B,0xC6,
	0xFE,0x83,0x12,0x9C,0x0B,0xD7,0x2C,0x94,0xA8,0x83,0xAB,0xB0,0x53,0x42,0x9C,0x1C,0x95,0x0B,0x10,0x8C,
	0xDA,0x7E,0x76,0x35,0x7C,0xB9,0xFF,0x2A,0xB0,0x71,0x0A,0x73,0xF0,0x04,0xE2,0x76,0x19,0x00,0xDF,0x56,
	0x48,0x27,0x5E,0x00,0x01,0x79,0x9E,0xDC,0xC8,0x3A,0xF8,0x67,0x13,0x4F,0x96,0xDE,0x9B,0xC7,0x25,0x8C,
	0x48,0xAB,0xB7,0xC2,0x08,0xD5,0x50,0x12,0xAF,0x5A,0x33,0x75,0x06,0x1B,0x89,0xA2,0xF6,0x75,0x09,0x43,
	0xBB,0xEE,0x87,0xEA,0x4C,0xDD,0x9D,0x10,0x0C,0xC8,0xA7,0xBE,0x68,0x92,0xC3,0x65,0xE7,0xAB,0xC7,0xC0,
	0x2B,0x1B,0xFF,0xE7,0x51,0xBB,0x28,0xBE,0xCA,0x8C,0x63,0xF5,0x19,0x74,0xF3,0x75,0x8C,0x23,0xB8,0xE8,
	0xAE,0x83,0x0F,0x1D,0x2C,0x2C,0xBC,0x69,0xFC,0xBA,0x02,0xE8,0xF0,0xD2,0x79,0xBC,0xF6,0xD5,0xDC,0x99,
	0x35,0xE2,0x84,0x57,0x17,0x1B,0x77,0x9F,0x0C,0x6F,0xDD,0x62,0xBC,0xBD,0x91,0xAA,0x46,0x27,0x9C,0x9C,
	0xB7,0x52,0xE5,0x08,0xA9,0x36,0x70,0x2E,0xC6,0x02,0xFD,0x77,0xB9,0x37,0xC8,0x20,0xF2,0x51,0xE2,0x0D,
	0x59,0x75,0xE0,0x20,0xC2,0x0B,0x06,0xCC,0x25,0x51,0x02,0x54,0xDD,0xCB,0xB6,0x3C,0x57,0xDD,0x12,0x3D,
	0x74,0xC1,0x6D,0xDA,0xA7,0x21,0x96,0x6C,0xCB,0x92,0xDD,0x2C,0xCD,0xF0,0x11,0x0A,0x31,0xD5,0x4E,0x7F,
	0x5E,0xEC,0x60,0xFC,0xA6,0xF5,0x09,0x01,0xEA,0xBE,0x15,0xC7,0x70,0xD4,0x12,0xDB,0xDB,0x32,0x70,0xE1,
	0xD7,0xA7,0xD3,0x02,0x80,0x0B,0xE8,0xE6,0x61,0x3B,0xCC,0x4D,0x03,0x33,0x95,0xD9,0xF0,0x3C,0x00,0xA5,
	0x09,0xF2,0xBD,0x85,0xB8,0x65,0xE9,0x24,0xCD,0xD1,0x8B,0x12,0xD2,0xB4,0xE2,0xB2,0x24,0xA8,0xB7,0xBF,
	0xF3,0xCD,0xA6,0x4A,0x21,0x03,0x52,0x9F,0xD7,0xAD,0x52,0xE8,0x78,0x79,0x0F,0x03,0x21,0x33,0xD9,0x41,
	0xDC,0x8C,0x1B,0xD5,0x21,0xAF,0x68,0x03,0xFB,0x7E,0xE6,0x46,0x1F,0xB7,0xF8,0x62,0xE0,0xAC,0x26,0xEA,
	0x3A,0xA0,0x61,0x20,0x68,0x3E,0x59,0xCC,0xF6,0x35,0x54,0xA8,0xA1,0xDC,0x2B,0x2C,0x59,0x2A,0x5B,0xED,
	0x77,0x17,0x13,0xDB,0x95,0x1B,0x99,0xC2,0x1C,0xD8,0xF7,0xF6,0x91,0x5A,0xB0,0x05,0x06,0x99,0x97,0xF0,
	0xEE,0xC2,0x84,0x99,0x9F,0x6B,0x08,0x74,0x21,0x65,0xDB,0x50,0xFC,0x80,0xEC,0xA0,0xAA,0xE2,0xE5,0x8D,
	0xDB,0xFD,0x5B,0x71,0x0A,0x7C,0xD2,0xF7,0xC7,0x29,0x7B,0x54,0x46,0x1C,0x5C,0x00,0xE2,0x9F,0x94,0xAB,
	0xF4,0xF4,0x28,0xF3,0xEC,0xAC,0x4A,0xE9,0xF6,0xB1,0x5E,0xB1,0xD3,0xDD,0xCE,0xD3,0x1B,0x77,0x1F,0xCE,
	0xFF,0x2A,0xA7,0xF7,0xA4,0xD8,0xDC,0xD7,0x19,0xDD,0xFA,0xAF,0x0E,0x09,0x98,0xDC,0xDD,0xCF,0x16,0x50,
	0x29,0x55,0x7F,0x51,0x64,0x5C,0x57,0x46,0x45,0x8C,0x57,0xEE,0xCF,0xE0,0xEE,0xCF,0x4B,0x59,0x8D,0x72,
	0x8F,0x74,0x3F,0xAA,0xC5,0x1A,0xBA,0x61,0xB9,0xEA,0x0A,0x59,0xD6,0x5E,0xDD,0x63,0xF1,0x30,0xB3,0x6D,
	0x01,0x12,0x27,0xEB,0xBF,0xA4,0x52,0x2F,0x70,0xB0,0x83,0x4A,0x4F,0x7C,0x79,0x90,0xFA,0x4B,0x77,0x64,
	0x89,0xEC,0xD8,0x11,0xBC,0xFF,0x36,0xBD,0x3E,0x27,0xAC,0x0D,0x38,0xF2,0x43,0xF6,0x9A,0x41,0x2E,0x57,
	0xAD,0x63,0x77,0x6B,0x17,0x70,0xC8,0x73,0x85,0x08,0x0B,0x08,0x2A,0x02,0x0F,0x6C,0x1F,0xD2,0xD0,0x17,
	0x65,0xD7,0x22,0x88,0x20,0x09,0xB4,0xA4,0x8D,0x92,0x33,0xDF,0x55,0x5A,0x67,0x8E,0x58,0x47,0xBB,0x08,
	0xE3,0x1A,0xAA,0x53,0x29,0x82,0x24,0x45,0x28,0x28,0x3A,0x3C,0x96,0x82,0x25,0x1D,0x92,0x22,0x14,0x48,
	0x7B,0xBE,0x10,0xA9,0x6B,0x9B,0xFE,0xA4,0xCC,0xAA,0x00,0x0B,0x82,0x93,0x24,0x57,0x1F,0x7C,0xF5,0x91,
	0x3B,0x03,0x18,0x19,0xF1,0xBE,0x37,0x49,0xB7,0x03,0x41,0xB5,0xFA,0x70,0xEB,0x23,0x70,0x70,0x79,0x15,
	0x81,0xA3,0x6D,0x38,0xB0,0x66,0xEC,0x3D,0x7D,0x04,0xA5,0x6A,0x29,0x2A,0xA7,0xEB,0xAB,0x39,0x22,0x16,
	0x96,0x53,0x2D,0xF8,0xD2,0xCA,0x23,0xA7,0xD8,0xC1,0x57,0xFD,0xD0,0x08,0xD6,0x56,0x5D,0x71,0xA1,0x90,
	0x65,0x71,0xD2,0xCA,0x95,0xF8,0x24,0xBF,0xAA,0x36,0x55,0xF5,0x71,0x85,0xE5,0x5D,0x89,0xA0,0xAB,0xBA,
	0xB8,0xF0,0xD4,0x17,0xD5,0xF5,0xF9,0xBA,0x02,0x78,0x6F,0x2A,0xE0,0xEA,0x21,0xCC,0xD7,0x95,0x84,0xB3,
	0xA6,0x75,0x61,0xD1,0x1A,0xEA,0x5F,0x6D,0x6E,0x43,0x3A,0x58,0x57,0xB0,0x42,0x90,0x9F,0xF1,0xBA,0xFF,
	0xC8,0x16,0x0B,0x2C,0x06,0x54,0x3C,0x19,0x27,0x3B,0xA4,0x86,0x01,0x55,0x2C,0x8C,0xAA,0x4D,0x84,0xA7,
	0xAB,0x4E,0x11,0x4C,0x88,0x63,0xD7,0x65,0xC5,0x72,0x9D,0x17,0xCB,0x1F,0x56,0xC1,0x01,0xA2,0x7E,0xB9,
	0xEC,0x00,0x44,0x93,0xEB,0xFA,0x66,0x38,0x25,0xEF,0x1D,0x42,0xE2,0x36,0x97,0xAB,0xFF,0x5F,0x1B,0x49,
	0x0E,0xF8,0xC5,0xDD,0x55,0xF7,0x90,0x52,0x16,0x67,0x8A,0xEA,0xA4,0xAB,0x5A,0x1E,0x9D,0x09,0xB9,0xAE,
	0xB6,0xDF,0x50,0xB2,0xCB,0xF0,0x6F,0xBE,0x60,0x63,0xC8,0x12,0xF7,0xC0,0x63,0x0F,0x21,0xE1,0x5C,0x52,
	0x5A,0xA8,0xFE,0x0A,0x7D,0x57,0x60,0x60,0xBF,0x05,0xBE,0x22,0x3E,0xE4,0x90,0xC9,0xE5,0xDE,0x26,0xC8,
	0xAF,0x09,0xD0,0xDD,0x0B,0xB9,0xB7,0xE8,0x61,0xBF,0x7A,0x0C,0x94,0x72,0x2B,0xC1,0x81,0x25,0xC8,0x68,
	0x0E,0x6D,0x3C,0xB2,0x75,0x71,0xE5,0x7B,0xF0,0x89,0xD9,0xA9,0xDC,0xC3,0xF1,0xDA,0xED,0x74,0xD8,0x43,
	0xA3,0xF9,0xA9,0x78,0x29,0x74,0x3E,0x21,0xD5,0xD7,0x69,0x61,0x7E,0xEE,0x33,0xC8,0xFC,0x2F,0x39,0xF3,
	0x62,0xA4,0xAC,0xF5,0xD6,0x58,0x40,0xE5,0x3F,0x27,0x77,0x3D,0xC1,0x5B,0xD7,0x0C,0x6B,0x43,0x46,0xBF,
	0xCA,0xC4,0x98,0xF7,0xEE,0xB4,0xC4,0x5C,0xB5,0x8A,0x69,0x13,0xAF,0xE5,0x77,0x2F,0xB4,0xEA,0x4A,0x7B,
	0x7A,0xBA,0x8D,0x76,0x14,0x0A,0x0C,0xF9,0xAE,0xE3,0x0F,0x53,0x2F,0x58,0xDA,0x8B,0x25,0x91,0x46,0xBF,
	0x2B,0x6B,0xFF,0x3C,0xBC,0xB7,0x4B,0xA1,0xE4,0xE5,0x8C,0x78,0x04,0xB7,0xFA,0x30,0xA4,0x7B,0x92,0x02,
	0xF2,0x49,0x57,0xE3,0x05,0x7E,0xE9,0xBB,0xAB,0xA0,0xD6,0x97,0x1C,0xDE,0x58,0xFF,0x26,0x98,0xEE,0x20,
	0x3C,0x48,0xA5,0xD5,0xF5,0x46,0x55,0xE5,0xE6,0x0F,0x8C,0xB5,0x08,0xBD,0xAE,0x6A,0xCD,0x76,0x17,0x32,
	0x48,0x9F,0x69,0x92,0x0D,0x38,0x3C,0x8B,0xC9,0xC2,0x7D,0xF5,0x88,0x44,0x42,0x4C,0x09,0x7D,0xCB,0x37,
	0x45,0x03,0x44,0x13,0x95,0x03,0xC6,0x14,0x19,0x32,0x16,0x55,0xAE,0x8F,0x62,0x00,0x64,0x50,0xD2,0x4E,
	0x14,0x94,0x11,0xBD,0x43,0xAA,0xB4,0xFB,0xA4,0x98,0x6D,0xC5,0xEE,0xCF,0xD2,0xC5,0x90,0x5E,0x16,0x19,
	0x2B,0x7D,0x43,0x8B,0x65,0x30,0x30,0xA2,0xFC,0x64,0xEE,0x57,0x42,0xB3,0xA0,0x29,0x64,0xAE,0x32,0x13,
	0x9F,0xD0,0x8C,0x95,0x60,0xA0,0x59,0x98,0xBE,0x5F,0x61,0x9C,0x25,0x30,0x5D,0xA2,0x5E,0xCE,0xA6,0x26,
	0xEB,0x9C,0x90,0x56,0x58,0xFC,0xAA,0x1C,0x19,0x34,0x9B,0x60,0x5C,0x7F,0x79,0x9E,0x30,0xBE,0x91,0x09,
	0x31,0xFE,0x3D,0xF1,0x81,0xD8,0xBA,0x78,0x7E,0x0C,0xB5,0xEF,0x0B,0x43,0xBA,0x72,0xB0,0xFE,0x98,0xF7,
	0xA9,0x4F,0x87,0x3D,0x75,0x0F,0xC1,0x40,0x55,0xFB,0xD9,0x55,0x60,0xF4,0x05,0x73,0xA5,0xC2,0xA1,0x2F,
	0x10,0xC3,0xC9,0xAA,0xF1,0x2E,0xD3,0xCB,0xAC,0x2F,0xA6,0xF3,0xDA,0x12,0x1A,0x3F,0xD4,0x60,0xF7,0xCD,
	0xC4,0x93,0x08,0x24,0x60,0x52,0xA7,0xCA,0xD6,0xEC,0x08,0xBE,0xAF,0x05,0x8B,0xD5,0xC4,0xB8,0x18,0x38,
	0x89,0xBC,0xF9,0xC7,0x53,0x5B,0x93,0x8B,0x17,0x23,0x44,0x43,0xC5,0x84,0x84,0x60,0x09,0x98,0xEB,0xFB,
	0x4F,0xE8,0x31,0x02,0x18,0x02,0x71,0x01,0xF4,0x64,0x03,0x59,0x71,0x55,0xA7,0x7D,0x06,0xF3,0x89,0x6D,
	0xC4,0x9F,0x91,0x57,0x8C,0x65,0x05,0xB0,0xF4,0x75,0x61,0x57,0xBD,0x0F,0xFA,0xFE,0x11,0x2D,0x65,0xF6,
	0xB9,0x79,0x96,0x14,0x34,0x76,0x77,0xC5,0x4B,0x76,0x5D,0x23,0x62,0x5E,0xF8,0xB4,0xBB,0x1E,0x05,0x49,
	0xD5,0x97,0x48,0x10,0xC7,0x90,0x65,0x26,0xE8,0x40,0x34,0x01,0x59,0xBE,0xFD,0x74,0x8A,0x74,0x01,0x72,
	0x79,0xE0,0x3C,0x28,0x20,0x4F,0xAF,0x3C,0xDF,0xE2,0x87,0xEB,0x88,0x93,0xF3,0x16,0x9D,0x17,0x41,0x64,
	0x1B,0x42,0xF6,0xAB,0x1A,0xAF,0xAB,0x2B,0x69,0x5F,0x65,0xFF,0xAC,0x38,0xAC,0x4F,0x65,0xD2,0x5B,0x99,
	0xC5,0xA2,0x22,0x5F,0x25,0xD5,0x9A,0x0C,0x9E,0xAC,0x97,0x53,0xE5,0x8E,0x1F,0x63,0x1F,0x24,0x5D,0x20,
	0xDF,0x0C,0xAA,0x4A,0xE0,0x32,0x09,0xB8,0xAD,0x57,0x53,0xF3,0x14,0xEF,0x94,0x59,0xCA,0x70,0x04,0xF0,
	0x48,0x24,0xB2,0x2E,0x81,0x57,0x48,0xB1,0xD6,0xEA,0xDA,0x0D,0x56,0x2E,0x2B,0x28,0xFC,0x4A,0xAA,0x14,
	0x91,0xEB,0x90,0x0C,0xBD,0x5A,0x16,0x5C,0x98,0xC4,0xD0,0x76,0x41,0x86,0x58,0xF3,0x79,0xE7,0x4D,0x6D,
	0x3A,0x89,0xF9,0xE3,0xAC,0x19,0x95,0xD2,0x04,0x3C,0x7A,0xF0,0x31,0x7A,0xF2,0x8F,0xA4,0x9F,0x18,0xF3,
	0xB0,0xC8,0x09,0xD6,0xF8,0x4F,0xAE,0xC3,0x92,0x91,0xD5,0x26,0x97,0x81,0xC3,0x3E,0x5F,0x1A,0x02,0xB7,
	0x2D,0x46,0xCA,0x4A,0x84,0x7A,0xB3,0x0C,0x05,0x63,0xB3,0x51,0x88,0xFE,0xCA,0xF0,0xB7,0x6A,0x54,0x28,
	0x37,0xD7,0x66,0x7E,0x2F,0xE5,0x9F,0xD5,0xBB,0x6E,0x9D,0xBB,0x0F,0xD6,0xF6,0x9D,0x72,0x6D,0x5D,0x0C,
	0xEE,0x44,0xF4,0xD6,0x4A,0x94,0x8F,0x42,0x36,0x4B,0x87,0x34,0x0C,0x98,0x55,0x5B,0x29,0x2E,0x76,0x22,
	0x2F,0x53,0xB6,0x14,0x7D,0x46,0x1D,0xDB,0x55,0x6C,0xC5,0xD3,0xE6,0xAB,0xD8,0xF7,0xA0,0xB8,0x5D,0xEE,
	0xE2,0x63,0x31,0xA5,0x8B,0xDC,0x17,0x0F,0x10,0x6D,0x4E,0xBD,0x37,0x77,0x37,0x65,0x55,0x3A,0x65,0xEA,
	0xD6,0xAE,0x82,0xF0,0x3F,0x5F,0xD5,0x19,0xBA,0xD0,0x73,0xA2,0xC2,0x2E,0x9C,0x9F,0x75,0xB1,0x9D,0xA7,
	0x63,0x3A,0x67,0x9C,0x35,0x3C,0xA5,0xC7,0xCE,0x84,0x05,0xB4,0x11,0x00,0x7D,0x93,0x24,0x89,0x79,0x71,
	0x14,0xB3,0xEE,0xEB,0xC3,0xED,0xEB,0x32,0x33,0x2F,0xB7,0xBB,0xA5,0x55,0xDF,0xB4,0x2F,0x09,0xAD,0x8B,
	0xE9,0x5D,0x30,0x91,0xEE,0xBF,0xD8,0x35,0xFF,0xC6,0x86,0x81,0xFF,0x59,0xBF,0xEF,0xA8,0x78,0xD1,0x9A,
	0x68,0x5F,0x17,0x39,0xE9,0x5A,0xF7,0x05,0x94,0x65,0xBC,0xFB,0x27,0xEF,0xE4,0xF7,0x64,0xF2,0x9A,0x28,
	0x56,0xFD,0x76,0x65,0x54,0xB5,0xF7,0x1C,0xEE,0x0F,0x7A,0xDF,0xE0,0xFB,0xD5,0xA4,0x4F,0xE9,0x74,0x27,
	0xDF,0xD4,0xC2,0xDB,0x5F,0x8F,0xC9,0xAE,0xEB,0x6F,0xF4,0x79,0xFA,0x56,0xFD,0x13,0x28,0x64,0xF9,0xCB,
	0x34,0x19,0xEA,0xCA,0x7D,0x7D,0xC2,0x61,0xDA,0x30,0xC0,0x86,0x66,0x4D,0xD5,0xD8,0x17,0xA8,0x0C,0x47,
	0x18,0xAA,0x2B,0xC1,0xF7,0x4D,0xFB,0xFF,0x71,0xD8,0xF6,0xC0,0xDD,0xF3,0x1E,0x60,0xAB,0x0F,0x59,0x45,
	0x8D,0x53,0x56,0x9E,0xE0,0xBD,0xB0,0x6E,0x23,0xB8,0xFB,0x86,0x22,0x9D,0xBB,0xBA,0x43,0x09,0xD5,0xE4,
	0x61,0x2F,0xC4,0x04,0xE0,0x89,0x5A,0xC2,0x2D,0x1A,0xBD,0x77,0x77,0xE4,0x7A,0x43,0xD4,0x0F,0x4B,0xFF,
	0x80,0xBA,0x0F,0x76,0xD7,0xF5,0xD2,0x8A,0x0A,0xC9,0xEE,0x86,0xB0,0x6D,0xAD,0xC4,0x56,0x4C,0x45,0x26,
	0x98,0xF7,0x92,0xCB,0xA2,0xE5,0x88,0xBD,0x7E,0xAA,0x38,0x5D,0x23,0xBF,0x75,0x80,0x3C,0xD6,0xC9,0xA1,
	0xFE,0xD1,0x28,0x20,0x1B,0xA7,0x5F,0xC2,0x32,0xF3,0x1E,0x5B,0x1A,0x58,0xF7,0x91,0x0F,0x5D,0x40,0x4B,
	0x69,0x55,0xCD,0x41,0xFA,0xF5,0x95,0xAA,0x77,0x7F,0xB0,0xB9,0xAB,0xE1,0x5F,0xBB,0xF7,0x95,0x74,0x00,
	0x42,0x86,0xD6,0x6E,0x51,0xBA,0x1D,0x82,0x53,0x75,0x7A,0xC5,0x66,0xFB,0x0A,0xE6,0xF6,0x4C,0x41,0xBF,
	0x6A,0x48,0x7B,0xFE,0x34,0x06,0x40,0x8E,0xCC,0x7B,0xCA,0x09,0x01,0x32,0xBF,0xAE,0x5F,0x64,0xD3,0x88,
	0xE8,0x02,0x33,0xFB,0x3B,0x60,0xDD,0x59,0x8B,0xEA,0xEB,0x99,0xEB,0x58,0xE4,0xF6,0x75,0x8B,0x7F,0x25,
	0x45,0x17,0x3B,0x16,0x40,0x56,0x89,0x75,0x60,0xC2,0x34,0x63,0x5F,0x85,0xCC,0xE5,0x08,0x72,0x0E,0xAE,
	0xCB,0xD4,0x2F,0xD9,0x07,0x7D,0x7F,0x75,0x28,0xC2,0x89,0x0F,0x28,0x95,0x46,0x07,0x1E,0x2D,0x84,0x9D,
	0x4F,0x67,0xC5,0xD3,0x2B,0x01,0xEA,0x4A,0xD6,0xEF,0x25,0x61,0xF1,0x27,0x5C,0x2F,0xCE,0xDA,0xD4,0x93,
	0x4C,0x3F,0x85,0xBA,0xB0,0x80,0x73,0x34,0x46,0xEA,0x5B,0x64,0x12,0x16,0xA9,0x0F,0x60,0x69,0xF3,0x8B,
	0xEB,0x72,0x8F,0x4F,0xB5,0xF8,0x3E,0xBD,0x3A,0x4A,0x79,0x3E,0x19,0xAF,0xB6,0xE1,0xC8,0xE8,0xF0,0x77,
	0xC9,0x83,0xED,0x01,0xC6,0xD3,0xE1,0x69,0xAE,0xB6,0xC6,0xED,0x37,0x5C,0x56,0x57,0x74,0xA8,0xC1,0x90,
	0x4E,0x03,0x72,0xB9,0xAA,0x70,0xA1,0x6B,0x27,0x28,0xDC,0xDA,0x15,0xFB,0x54,0x9F,0xC7,0x1D,0x86,0x4B,
	0xC1,0x12,0xD2,0xED,0xFB,0x5F,0x87,0x71,0x3E,0xFD,0x01,0x63,0x0D,0xB6,0x94,0xD8,0x59,0xBA,0xD1,0xFE,
	0x43,0x69,0x87,0x6B,0xC3,0xA7,0x5B,0xE4,0xD5,0x1D,0x28,0x0E,0x9D,0x53,0x18,0xE4,0xF1,0x9F,0x80,0x35,
	0x7A,0x0C,0x24,0x74,0x9C,0x1E,0xBF,0x12,0x97,0xA0,0x6A,0x01,0x94,0x89,0x44,0xA7,0xAD,0xF9,0x46,0x3E,
	0xCE,0x7E,0xDE,0xF2,0x42,0xD7,0xD8,0xD5,0xE4,0x7F,0x8D,0xDF,0xFF,0x98,0x77,0x76,0x94,0x75,0x35,0xBE,
	0xEF,0x00,0x8C,0xAD,0xEF,0x1B,0xB9,0xEA,0xCF,0xDD,0x7B,0x8A,0xEB,0x92,0x1D,0x3B,0x23,0x6B,0xA1,0x51,
	0xD4,0xA0,0xFA,0xEB,0x02,0x22,0xDF,0x77,0x27,0x8D,0x5E,0x0D,0x10,0x1B,0x55,0xA4,0x2D,0x97,0x48,0x14,
	0xA7,0xE6,0xF0,0x56,0x8A,0xEB,0x0E,0x25,0xE6,0x40,0xB1,0x53,0xB9,0x57,0xD3,0x26,0x16,0x17,0xFC,0x15,
	0xC0,0x9F,0x75,0x69,0x00,0x86,0xB0,0xAC,0x6B,0xBA,0x35,0x40,0x38,0xBA,0x14,0x14,0x4E,0xE2,0xC4,0x08,
	0x82,0xD1,0x30,0x2C,0x72,0xFC,0x75,0xD5,0xB8,0xB3,0xAE,0xF0,0x08,0x97,0x64,0x53,0x29,0xFE,0xBB,0xF7,
	0x26,0x18,0x95,0x08,0x52,0xCA,0x3F,0x08,0x25,0x5B,0x9A,0x0D,0x9D,0xE7,0xD6,0xDD,0x16,0x5C,0x7A,0x4A,
	0xFE,0xBB,0x18,0x41,0x9A,0xEB,0x2B,0xDE,0xDF,0x8F,0x48,0xC2,0x45,0x1C,0x0C,0x46,0xD4,0xA9,0xED,0x37,
	0xC4,0x4D,0xD8,0x20,0xD2,0x6E,0xB8,0xA9,0xD3,0x57,0x6D,0x55,0x23,0xDA,0x05,0x4B,0x83,0x3F,0xF4,0x64,
	0xFD,0xA0,0x60,0x1D,0xDF,0xA8,0x84,0x79,0x43,0xBB,0x9F,0x57,0xF3,0xBF,0xEF,0x96,0xE6,0x80,0xD8,0x2E,
	0x98,0x44,0x55,0xFA,0x9E,0x25,0x57,0x76,0xCE,0xB5,0x7B,0x54,0x87,0xE5,0x2E,0x97,0x2E,0x55,0x88,0xE7,
	0xE8,0xB5,0x93,0x26,0x66,0x00,0xB9,0x46,0x6C,0x9A,0x93,0x36,0xFD,0x99,0xAD,0x35,0x29,0xEE,0x9A,0x2A,
	0xAC,0x8A,0x81,0xF6,0x02,0x39,0x95,0xDD,0xDF,0xE6,0xF1,0xC4,0xFB,0x8A,0x4B,0x57,0xD5,0x4E,0xD3,0x5D,
	0x5E,0xDD,0xBC,0x2D,0xC1,0xBB,0x92,0xAB,0x24,0xC7,0xF0,0xC4,0xB0,0xD1,0xED,0x77,0xB6,0x26,0xEB,0xFE,
	0x25,0x82,0xAE,0xFB,0xDE,0xB8,0x9E,0x25,0x0F,0x97,0xC2,0xBD,0x64,0x5E,0xD7,0x66,0xF3,0x5F,0x45,0xE6,
	0xF3,0x8F,0xD5,0x53,0x24,0xDD,0x89,0x70,0x7F,0x57,0x89,0x44,0x6D,0xB4,0xA1,0xB6,0xE2,0x71,0xBE,0x52,
	0x76,0x1D,0x97,0xD0,0x8D,0xEF,0x52,0xFF,0xC0,0x9F,0x6F,0x37,0x96,0x37,0xAB,0x95,0xAA,0xDF,0x11,0xF0,
	0xA7,0x98,0x01,0x65,0x82,0xAC,0xD8,0xD8,0xE1,0xED,0x5B,0xD1,0xE1,0xDD,0x40,0xC4,0xAA,0x44,0xD2,0xBE,
	0xAD,0xF3,0x5F,0xF8,0xB5,0x19,0xC2,0xA0,0x06,0xBC,0xFE,0x99,0xEB,0x29,0x26,0xFB,0xB7,0x1D,0xDC,0xE8,
	0xB7,0x1C,0x7D,0xFD,0x5B,0xAD,0xDB,0x67,0x58,0xB5,0xB2,0x4A,0xD0,0xD8,0xFD,0xF2,0x75,0xF5,0xC7,0xEA,
	0x0D,0x51,0x49,0x6C,0xFE,0xDF,0x11,0x29,0x87,0x76,0x66,0x55,0x07,0x76,0xA2,0x00,0x8B,0x5D,0x5D,0x65,
	0x69,0xF7,0xD5,0x57,0x09,0x18,0xBB,0x44,0xC8,0xC5,0xEA,0x96,0x52,0x0F,0x6D,0xDF,0xC0,0xD2,0x82,0xF5,
	0x37,0x5D,0x75,0xE6,0x03,0x30,0xA5,0xDF,0x72,0x9F,0x98,0x8A,0x6E,0xFC,0x2E,0x40,0x0E,0x16,0x87,0x6C,
	0x95,0x72,0x78,0xEF,0x4C,0xB4,0x2B,0xD8,0xF3,0x10,0x29,0x55,0x64,0x35,0xD1,0xB4,0x28,0x8B,0x4A,0x23,
	0xA1,0x05,0x7F,0xF1,0x85,0x94,0xA2,0x2A,0xAC,0xA2,0x9A,0xDF,0x7D,0x54,0x98,0x2B,0x49,0xA8,0x0F,0x68,
	0xDF,0xAB,0xF2,0x9D,0xD5,0x80,0x14,0x0E,0xA0,0x3D,0xAD,0xFE,0x35,0xB2,0x8E,0x69,0x0C,0x20,0x50,0xC9,
	0xA5,0x4C,0xFA,0xE4,0x37,0xC2,0x92,0xE4,0xAE,0x78,0x86,0xA0,0x6C,0x09,0x51,0x39,0x86,0x50,0xED,0xD5,
	0x00,0x75,0x92,0xAF,0xA2,0xB3,0xB1,0x56,0x15,0x2D,0xFE,0x95,0xAE,0xC3,0xDC,0x05,0x06,0xE5,0xD9,0xB0,
	0x71,0x55,0x37,0xCB,0x97,0xDC,0x07,0x78,0xB3,0xAE,0x05,0x3A,0xF7,0x61,0x5A,0xB6,0xEF,0x92,0x4D,0x46,
	0x35,0xAE,0xAA,0x0B,0x27,0x6C,0x95,0x68,0x6E,0x8D,0x2A,0x66,0x5A,0x6B,0x6E,0x54,0x58,0x4F,0x3C,0x55,
	0xB9,0x6B,0xBF,0x39,0xAD,0x5F,0xB6,0xB8,0xFC,0x87,0x6A,0x2F,0x16,0x60,0x0A,0x69,0x05,0xB2,0x20,0x92,
	0xA9,0x0B,0xD7,0xAF,0x8D,0xD5,0x5A,0xAC,0x38,0xD9,0xE2,0x4E,0x1C,0x94,0xC2,0x4C,0x20,0x70,0xC5,0x97,
	0x68,0xD4,0x2F,0x3A,0x4C,0x20,0x77,0x7F,0x52,0x32,0x61,0x4C,0xF2,0xCE,0x77,0x37,0x44,0xBF,0x84,0xFF,
	0xAA,0x34,0xEF,0xF3,0x51,0x91,0x84,0xEC,0x9D,0xCD,0xF1,0xAF,0xA8,0x67,0x25,0x50,0x21,0xF0,0xFF,0x45,
	0x0E,0x12,0x7F,0x74,0x19,0x65,0xC6,0x36,0xEF,0x2A,0xAE,0xCA,0xD0,0x81,0x2F,0xAE,0xEE,0xB2,0x24,0xC2,
	0x5A,0x09,0xDF,0x07,0x2C,0xEE,0xD0,0x77,0x55,0xC9,0xE3,0x99,0xAE,0x0E,0x51,0xE5,0xE9,0x63,0xE0,0x1A,
	0x32,0x75,0x6F,0xA4,0x2F,0x79,0xA7,0x9D,0x45,0xC1,0xBA,0x3B,0x35,0xD1,0x75,0x4C,0xF3,0x41,0xB1,0x18,
	0x8F,0xA3,0x06,0x31,0xEA,0x4B,0x66,0xD7,0x05,0x69,0xEF,0xD5,0x18,0x1F,0xA8,0xBB,0xB1,0x71,0xB5,0xAE,
	0x43,0x5D,0xDE,0x4C,0x56,0x81,0x26,0xD7,0x12,0x45,0x30,0x48,0xBC,0xBE,0xBF,0x45,0x1C,0xBA,0x1D,0x54,
	0x46,0xAB,0xCA,0x85,0xFE,0xD3,0xF2,0xBE,0x2B,0x19,0xA5,0x5F,0x39,0x51,0x64,0xE1,0x6B,0xA4,0xE8,0xA3,
	0x23,0xDA,0x06,0x4E,0x7E,0x8B,0x7B,0xEF,0xF6,0x17,0x65,0x58,0x70,0x12,0x38,0x82,0xA3,0x7F,0xB5,0x2C,
	0x57,0x47,0x38,0x1E,0xC0,0xAD,0xED,0xCF,0xB8,0x04,0x97,0xEE,0x2B,0xEC,0x29,0x9A,0xEF,0x0A,0xE9,0xAA,
	0x0A,0x54,0xBE,0x5E,0x7F,0x05,0xBC,0x65,0x1E,0xD2,0xED,0xB8,0x0D,0x07,0xF3,0x96,0xC3,0x6C,0x4D,0x93,
	0x36,0x7D,0xCB,0xD2,0x89,0x02,0x5C,0x13,0xBC,0x3A,0xDE,0x80,0xD2,0x60,0xA0,0xAE,0x8F,0x13,0x45,0xE0,
	0x94,0x59,0xD6,0xD9,0x8D,0x5F,0x7C,0xF5,0x2A,0xD2,0xA8,0x1F,0xA6,0x55,0xCB,0x7B,0x84,0x6A,0x40,0x02,
	0x33,0xB6,0xB5,0xE5,0xDE,0x96,0x6E,0xF8,0xC5,0x61,0xC2,0x77,0x10,0x01,0x58,0xEF,0x5B,0x01,0x04,0xE8,
	0xEA,0xCF,0xAF,0x02,0x4C,0x1A,0xBE,0x75,0x0A,0x8B,0xB8,0xDC,0x00,0x5B,0xFB,0xE6,0x4B,0x8E,0xFE,0x38,
	0xC5,0x27,0x60,0x42,0xA1,0xB7,0xD3,0xA0,0xE8,0x32,0x6E,0x85,0x44,0x1F,0x3C,0x4C,0x3D,0x1E,0x0C,0x1C,
	0x21,0x32,0x71,0xC7,0xA4,0x08,0xB8,0x34,0x1D,0x52,0xB3,0x39,0x80,0x59,0x2A,0x4E,0x75,0xBB,0xAA,0xD4,
	0x5E,0x6E,0x1A,0x01,0x15,0xD6,0x6C,0x17,0x00,0x58,0x57,0x25,0xFE,0x5E,0x84,0x57,0x55,0x00,0xE9,0xF0,
	0x2A,0xB3,0xEB,0x36,0xA6,0xC0,0x31,0xA1,0x0C,0xEB,0xD6,0xC4,0xEC,0x2E,0x20,0x28,0x32,0xCC,0x02,0x59,
	0x7D,0xC8,0x1A,0xD6,0x05,0x22,0x0F,0x19,0x9F,0xB0,0x3C,0x2C,0x5D,0xFD,0x77,0xF2,0xC7,0xC3,0xBE,0x51,
	0xD6,0x33,0x56,0xDF,0x05,0x7A,0xBB,0x62,0x0E,0xC7,0x33,0xCA,0x98,0x16,0xB0,0xAE,0x2A,0x81,0xDD,0xA2,
	0xAB,0x35,0x0A,0xB1,0xC0,0xB4,0xDF,0x85,0x7F,0x81,0xDE,0xD5,0x76,0xC5,0x72,0xEA,0x66,0xBE,0xE2,0xAF,
	0x2F,0xDF,0x60,0xFF,0x17,0xA9,0x3E,0x3C,0x75,0x81,0x10,0x4B,0xEA,0xA8,0x57,0xFB,0xEB,0xEE,0x93,0x65,
	0x4B,0x81,0x98,0xEA,0x35,0xD1,0x95,0xE2,0x5D,0x23,0x4F,0x77,0x7B,0x30,0x97,0xEA,0xAE,0x19,0x5D,0x01,
	0x3A,0xF9,0x75,0x20,0xAD,0x77,0xF4,0xC4,0xBB,0x70,0x4E,0x7C,0xD2,0x94,0xD5,0x67,0x0D,0xAD,0xCD,0x3E,
	0xFB,0x63,0xB8,0x00,0xF4,0xD3,0x77,0x55,0x95,0x44,0x90,0xFB,0x91,0x41,0xEB,0x52,0xC0,0xAE,0x23,0x5C,
	0x5D,0x41,0xF0,0xCB,0x70,0x7B,0xF2,0xC2,0xF1,0x6D,0x77,0x8B,0x1F,0x90,0x02,0x33,0xBB,0xE4,0x39,0x6F,
	0xB1,0x3A,0xE7,0x6C,0x3F,0x5D,0x59,0xCB,0x93,0x5C,0x12,0x73,0x21,0x5F,0x34,0xA7,0x3F,0x80,0x6B,0x3B,
	0x0D,0xA0,0x0F,0xCA,0xAA,0xA1,0x93,0x1F,0x49,0xC4,0x88,0x6A,0x06,0x5E,0xDD,0x50,0x6B,0xD0,0xAF,0xDF,
	0xE6,0x58,0x78,0x4C,0x39,0xBA,0xCC,0x7A,0x41,0x79,0xBB,0xD4,0xB1,0x3F,0xA8,0xCA,0x7B,0x97,0xB6,0xFD,
	0x85,0x2E,0x48,0x3C,0x16,0xA7,0x0B,0x34,0x6B,0x18,0xC3,0x0B,0x62,0x81,0xC0,0x48,0x09,0x24,0x6A,0xCD,
	0x00,0xCA,0x45,0x73,0xB5,0x08,0x3B,0xA8,0xEE,0x05,0x31,0xD7,0x8F,0xAF,0x33,0x2C,0x1F,0xA8,0xFE,0x0A,
	0x0F,0x77,0xB2,0x30,0x0D,0xD6,0x4A,0x7A,0xCC,0xA6,0x4B,0xCD,0xB8,0x33,0x48,0xDE,0x5D,0x55,0x0A,0x58,
	0xA0,0xBF,0x1C,0x67,0xAC,0xC4,0x9D,0xFE,0xBD,0x98,0x82,0xE9,0x2E,0x2A,0xF7,0xC4,0x19,0x19,0x24,0x7B,
	0x57,0x02,0xD2,0x66,0xC9,0xCA,0xF3,0x96,0xBB,0x15,0x57,0xCB,0x30,0xC4,0x6D,0xFC,0x36,0x89,0x94,0xB2,
	0x74,0xC6,0x32,0x26,0x5D,0x81,0xC6,0xB8,0x77,0xE1,0x81,0x67,0x2F,0x15,0x06,0x68,0xB9,0xC2,0x8E,0xF8,
	0x52,0x50,0x57,0x5D,0x52,0x88,0x77,0xD1,0xC8,0xDA,0x77,0x11,0x2C,0xBB,0x48,0x6B,0x5D,0x26,0x76,0x11,
	0xF2,0x5C,0x1C,0xFE,0x82,0x6A,0x18,0xB2,0x5A,0x7F,0x77,0x1E,0x76,0xBF,0xE2,0x65,0xC6,0x64,0xE9,0x02,
	0x58,0xA6,0xF1,0xAE,0x05,0x3F,0x5A,0x63,0x98,0xB3,0x99,0xA7,0x7C,0x2A,0x8B,0xA9,0x6E,0xB9,0x73,0x75,
	0x67,0x49,0x07,0x57,0x17,0xDC,0xB2,0x37,0x72,0x22,0x79,0x60,0xD0,0xE2,0x44,0x9F,0x55,0x48,0x33,0xC1,
	0x07,0xE7,0xAE,0x68,0xD8,0xEB,0x8C,0x8D,0x0A,0x3A,0x4B,0x7F,0x41,0x29,0x1D,0x31,0x4F,0x1E,0xC0,0x34,
	0x02,0xC7,0x0D,0xF3,0x75,0xC1,0x77,0x22,0xD1,0xA6,0xD0,0x7E,0xF2,0xEF,0x46,0x67,0x94,0xEF,0x48,0xAA,
	0xC9,0xAF,0xBD,0x3E,0xE8,0xEA,0xCA,0x5D,0x80,0x5B,0x8F,0xD9,0x5B,0x20,0x1B,0x65,0xF9,0x9E,0x17,0x49,
	0x52,0x4B,0x83,0x0D,0xB2,0x00,0x5E,0x10,0xF4,0x8F,0x80,0x41,0x27,0x54,0xAA,0xEA,0x46,0x31,0xF8,0xEE,
	0xA1,0xAE,0x5A,0x9C,0x7E,0x5D,0x30,0x6A,0x78,0x26,0x38,0x21,0x93,0x8E,0x6E,0x29,0xDD,0xB1,0xB9,0x48,
	0xB4,0x52,0xFF,0x27,0x03,0x5E,0x2B,0x02,0x85,0xA4,0xCB,0x98,0xA3,0x43,0x3C,0x6F,0x61,0x69,0x0C,0xC5,
	0x6B,0xB7,0x60,0xC9,0x70,0xB4,0x51,0x92,0xA4,0x5B,0x25,0x3B,0x64,0x23,0xED,0x6E,0xD8,0x58,0xFD,0x07,
	0x8A,0x92,0x72,0x2B,0x79,0x78,0xF8,0x6A,0xD3,0xE5,0xB4,0xBA,0x93,0x32,0x3B,0x1A,0x29,0x13,0x49,0xAC,
	0xEB,0x04,0x25,0xB3,0xA1,0xAB,0xDD,0x16,0xA4,0x1C,0x66,0xD5,0x2D,0xB8,0x30,0x18,0xC1,0xDE,0x1F,0xDA,
	0xB6,0xFF,0xED,0x2E,0x5F,0x78,0xA5,0xBE,0x95,0x6D,0xF2,0x43,0x23,0xFB,0x5C,0x00,0x96,0x25,0xA6,0xF3,
	0xD5,0x4B,0x5C,0x79,0x05,0x38,0x26,0x17,0x13,0xFB,0xCA,0xB1,0xDF,0x65,0x66,0x0C,0xCB,0x37,0x0D,0xDA,
	0xBF,0xD4,0x14,0xAF,0x6A,0x81,0xBE,0x8F,0xA5,0x56,0xB6,0x46,0x7A,0x2D,0xB5,0x96,0xA2,0x5D,0xB7,0x51,
	0xE0,0xCF,0x7B,0x5A,0xA1,0x20,0xAD,0x8B,0x20,0xA4,0x51,0x9F,0x0F,0x73,0x24,0xF5,0xED,0xC6,0xDB,0x16,
	0xC5,0xEE,0xE0,0x58,0x44,0x7C,0xB3,0x6E,0xB9,0xEE,0xE2,0x83,0xAF,0x31,0x8C,0x46,0xC1,0x25,0xFF,0x61,
	0x2B,0x1F,0x9B,0xFA,0xEB,0x20,0x49,0x55,0xBD,0xCA,0x0E,0xAA,0x47,0x05,0x07,0xAA,0x64,0xE4,0xBA,0xDE,
	0x99,0xE7,0x5A,0xE5,0x6D,0x47,0x17,0x9E,0x26,0xC4,0x3E,0x74,0x1D,0x2D,0x74,0xB3,0x93,0x9B,0x00,0xC4,
	0xCD,0x83,0x7D,0x55,0x86,0x87,0x53,0xC4,0x9A,0xBA,0x0D,0x9C,0x50,0xE3,0xAB,0xDB,0xDF,0x02,0x83,0xA2,
	0x1E,0xFD,0xA5,0xC3,0x5F,0x6B,0x97,0x39,0xCF,0xEF,0x6B,0x89,0xF0,0xAA,0x50,0xE2,0xEF,0x0A,0xA8,0x3C,
	0xB7,0x2E,0xB7,0xAF,0x57,0x77,0x8B,0xD3,0x7C,0x65,0x5C,0x56,0x7F,0xC2,0x58,0xDE,0x45,0xA8,0x6A,0xDA,
	0x84,0x5A,0xB2,0x50,0xE8,0x45,0x18,0x0B,0x4C,0x07,0xFA,0x52,0x8A,0xFD,0x57,0x78,0xFD,0xDE,0xB2,0x50,
	0xB9,0xF8,0x85,0xBD,0xB1,0xC0,0x27,0x24,0xBF,0x36,0xF9,0x2E,0x38,0xE2,0x7F,0xC7,0x2E,0x46,0x2A,0x41,
	0x6C,0x10,0x95,0xDF,0xDA,0xDA,0xB3,0xD7,0x05,0x5F,0x87,0xB3,0xBE,0x2D,0x94,0x5B,0x1E,0x10,0xF6,0xDE,
	0xD4,0x02,0xD2,0x5F,0xD8,0xE6,0xEE,0xBD,0xD6,0x7C,0x6E,0x99,0x7A,0x0F,0x6E,0x0F,0x2F,0x5C,0xEF,0xBA,
	0xCC,0x55,0x3A,0x98,0x96,0x18,0xAD,0xE9,0xF3,0x73,0xC2,0xAA,0x8E,0xEF,0x55,0xAD,0xBB,0x4B,0x6B,0x51,
	0xC1,0x29,0xB0,0xB0,0xA1,0xAF,0x12,0x6F,0x68,0x23,0x5D,0x60,0xD0,0x22,0x83,0xBF,0x19,0x74,0xA9,0x2C,
	0xCB,0x25,0xE5,0xD1,0x49,0x5A,0x8C,0xAA,0xDF,0x56,0x57,0xFF,0x08,0x83,0x79,0x53,0x6B,0x87,0x25,0xA0,
	0x80,0x9B,0xC6,0xBD,0xEE,0x57,0xE2,0x38,0x92,0xF1,0x54,0x40,0xBC,0xC3,0xA8,0x1D,0x83,0x41,0xD7,0x99,
	0xBC,0xA3,0x87,0xF7,0x95,0x2F,0x45,0x38,0x08,0x3A,0x0F,0x75,0x38,0xB9,0xC9,0x3F,0x9F,0x2E,0x3D,0x68,
	0xCF,0xFF,0xE3,0x53,0xDE,0xEE,0x2A,0x72,0xE9,0x80,0x3D,0x45,0xDD,0x14,0x1C,0x5A,0xD1,0xD0,0x32,0xD0,
	0x5B,0x47,0x5D,0x01,0xB8,0x7A,0x17,0x21,0x0D,0x1E,0x7D,0x3E,0xE8,0x98,0x21,0x88,0xB3,0x28,0x5E,0x44,
	0x64,0x00,0x62,0x1A,0x55,0xB5,0xB8,0x2A,0xAE,0xBE,0xF9,0xCE,0x3B,0x78,0x93,0xB1,0xA2,0xAF,0xFB,0xDC,
	0x22,0x06,0xD4,0x0B,0x4E,0xDF,0x41,0x2A,0xE0,0xB0,0xE4,0x44,0xFC,0x1B,0xA6,0xF7,0x7D,0x2E,0x82,0x74,
	0xE6,0x94,0xEE,0x72,0x06,0xE6,0x78,0xF6,0x2C,0x70,0x7D,0xC7,0xCE,0x75,0xA4,0xF6,0x28,0xFF,0x1D,0x43,
	0x69,0x1B,0x4B,0x50,0x08,0x7B,0xDE,0xF7,0x3E,0x97,0xD5,0xDE,0xE6,0x8E,0x00,0xF3,0x9D,0xEB,0xFD,0x81,
	0x88,0x72,0x84,0xC8,0xAC,0xCB,0xB7,0xE7,0x8C,0xAF,0x24,0xEC,0xD2,0x8F,0xF4,0x05,0x11,0x6E,0xFC,0x1A,
	0xAB,0xAF,0x9A,0xDD,0x23,0x52,0x2C,0x06,0x06,0x81,0x08,0x77,0x63,0x6F,0xAA,0xC0,0xF0,0x45,0xD4,0x51,
	0x66,0x12,0x12,0xD2,0xD0,0x39,0x1E,0x3D,0x7A,0x03,0x13,0xDE,0xBF,0x94,0x72,0x20,0x99,0xE9,0x94,0x2A,
	0x1F,0xDB,0x0C,0xA9,0xB0,0x48,0x94,0x7C,0x09,0xA2,0x67,0xAA,0xBF,0x99,0x53,0x23,0x15,0x38,0x2F,0x54,
	0xD0,0xB5,0xC4,0x33,0xD2,0x18,0x34,0x9B,0x59,0xFF,0x34,0x55,0xA3,0xE9,0x8E,0x14,0x2B,0x96,0xDE,0xCF,
	0xAA,0xEB,0xC0,0x0F,0xFB,0x9F,0xF5,0x67,0xB5,0x82,0xC0,0x76,0x27,0x27,0x67,0x02,0x0B,0x93,0xF9,0xAB,
	0xCB,0xE0,0x09,0x8C,0x30,0xF4,0xF0,0x01,0x49,0x7A,0xFF,0xDD,0xA3,0xCE,0xFC,0xB2,0x05,0x33,0xEC,0xBB,
	0xDA,0x36,0x86,0xDB,0x0E,0xB8,0x61,0x55,0xAE,0x3B,0x4C,0xB2,0xC3,0xA6,0xFE,0x9D,0xD8,0xE8,0xC7,0xA2,
	0x89,0xCA,0xAC,0xC3,0x52,0xA4,0xD3,0xA0,0x40,0x1F,0x06,0x51,0xA3,0x22,0xC1,0x10,0xEE,0x64,0x11,0xC8,
	0x8C,0xEC,0x6E,0x5F,0x7B,0x50,0x84,0x41,0x18,0xB5,0x79,0x59,0xFA,0xEA,0x00,0xAE,0x8B,0xF4,0x2C,0xBF,
	0xDC,0xAE,0x82,0x76,0x30,0xC2,0x92,0xB3,0x5B,0xF2,0xB1,0x01,0x2C,0x86,0xB5,0x61,0x7F,0x37,0xE7,0xEC,
	0x0E,0x19,0x81,0x7A,0xD6,0xC5,0xAF,0x84,0x01,0xE6,0xA4,0x15,0x67,0x54,0x88,0xEF,0x86,0xCC,0x09,0x0E,
	0x32,0xA6,0x56,0xD8,0xB4,0x6A,0xF9,0x2A,0x19,0x17,0xEA,0xDC,0xBA,0xBE,0x73,0x3C,0x93,0xBD,0xD2,0xDE,
	0x08,0x48,0x5C,0x1F,0x55,0x2B,0x72,0x06,0xF8,0x67,0x4D,0x94,0x2C,0x0C,0xF5,0xE6,0xA1,0x63,0x9C,0x8D,
	0x50,0x83,0x07,0x76,0x99,0x6F,0x1C,0x8E,0x9B,0xA8,0x73,0xEE,0x67,0x7D,0x65,0x32,0x59,0x55,0x91,0x1D,
	0x91,0xC4,0xEB,0x03,0x39,0xBC,0xD2,0x82,0xFB,0x91,0x21,0x3C,0x46,0xD9,0xFC,0xDF,0x31,0xE7,0x9A,0x77,
	0x21,0x89,0x13,0xDE,0x9C,0xF3,0x07,0x16,0xCD,0x6F,0xD4,0xD6,0xB8,0x26,0xAE,0x51,0xDE,0xDA,0x69,0x42,
	0x59,0xE5,0x71,0xC9,0x89,0xEB,0xD1,0x0B,0x4B,0x7E,0xF7,0x57,0xD9,0xFC,0xB2,0x1E,0xBA,0xE6,0x4B,0x04,
	0xF3,0xEF,0x2E,0xD9,0xDB,0x7F,0x07,0xBE,0xEA,0x2E,0xC4,0x87,0x55,0x1D,0x77,0xBE,0x5D,0xFE,0x98,0x70,
	0x75,0xED,0x89,0xB4,0xC9,0xC6,0xBA,0x80,0xDE,0x7F,0x75,0xF3,0xDA,0x93,0xBF,0x8D,0xD8,0xB3,0x08,0x0C,
	0xD8,0xA3,0x71,0xAF,0x2B,0x58,0xAA,0x9A,0x5F,0x07,0x66,0x9A,0x8F,0x70,0x72,0x42,0xC7,0xD9,0x66,0x78,
	0xDE,0x79,0xF8,0xC0,0xB1,0x7D,0xCC,0x35,0x7D,0xD5,0x4B,0x30,0x94,0xE9,0x4C,0x65,0x90,0x61,0x00,0xF3,
	0xD5,0x15,0x95,0x86,0xBE,0xD5,0x52,0xE6,0xC4,0xAA,0xAB,0x82,0xB9,0x68,0x4E,0x5E,0x3A,0x60,0x34,0x6D,
	0x5E,0x4E,0xB3,0x5D,0x1E,0xB3,0x11,0xDC,0x6E,0xC4,0x70,0xA1,0xF6,0x61,0xC4,0x72,0x02,0x57,0x56,0xA6,
	0xD2,0xFD,0x2C,0xE6,0x7A,0xB3,0x57,0xAC,0x46,0xAF,0xA9,0x02,0x0B,0xCC,0xA4,0xD3,0x44,0xE2,0x4D,0x01,
	0x8E,0xED,0x9B,0xD7,0x15,0xA2,0xF1,0xBE,0xB7,0x9A,0x5E,0x12,0xF0,0xD6,0x8B,0x33,0xCA,0x34,0x4A,0xEB,
	0xF4,0xF2,0x5D,0x0F,0xC1,0xEF,0x45,0xB6,0xFA,0x8F,0xCB,0x3F,0xC8,0x61,0x44,0xC2,0x3D,0xFD,0x5B,0xCE,
	0xC8,0x30,0x9C,0x38,0x7C,0xFF,0x1E,0xA2,0x3D,0xD6,0xBF,0x35,0xE2,0x61,0xA4,0xEE,0x30,0x34,0x64,0xCE,
	0xF4,0xC2,0xCC,0x6B,0xEE,0x68,0x60,0xA2,0xCB,0xB1,0x72,0xC6,0x6C,0xA2,0xA0,0xC0,0x64,0x28,0x2F,0x7D,
	0x8E,0x53,0x64,0xB7,0x6A,0x8C,0xB1,0x96,0x6D,0x1A,0x72,0x65,0xBF,0x58,0x65,0x08,0x94,0x1E,0x89,0xE6,
	0x55,0xF6,0x53,0x11,0x32,0x0D,0x97,0xBA,0x1B,0xFF,0xA6,0x2E,0xBF,0x32,0xD6,0x46,0x39,0xB5,0x69,0xD3,
	0x09,0xC4,0xDE,0x2D,0xC6,0xF8,0x6E,0x88,0x04,0xFE,0x54,0xB0,0x0E,0x9A,0xC2,0x28,0x9D,0xCE,0x51,0x6D,
	0x02,0x8E,0xAA,0xA8,0xDC,0x57,0x07,0x39,0x29,0xBE,0x27,0xDF,0x27,0x33,0xE7,0x21,0xEE,0xDB,0xD1,0x6B,
	0xA3,0xA0,0x5F,0x33,0xE0,0xD0,0x1C,0xA8,0xBB,0xEC,0xB1,0x8E,0x6C,0x0A,0x12,0x07,0x2A,0x13,0x4D,0x55,
	0xCE,0xDA,0x26,0x1D,0x80,0xC6,0x83,0x54,0x2F,0xFD,0xD4,0x53,0x0D,0xD3,0x9F,0x8E,0xE1,0xA7,0x80,0x83,
	0xBB,0x98,0x87,0x67,0xBC,0x9F,0x22,0xE9,0x11,0x14,0xC9,0x48,0x1B,0x43,0x5F,0xE3,0xB4,0x80,0x74,0x7E,
	0x75,0x9D,0xC8,0xB8,0xA1,0x3E,0x14,0x3C,0x66,0xBD,0x79,0xA8,0x8A,0x90,0x67,0x20,0xA2,0x07,0x7A,0x56,
	0x92,0x6B,0xDC,0x62,0xED,0xB9,0xBF,0xCA,0xDA,0x42,0x4B,0xE1,0x87,0xDA,0xA0,0xD9,0x5F,0xE7,0xBA,0x66,
	0xA3,0xEA,0x24,0x55,0x87,0x51,0xC7,0x4A,0xC8,0x07,0x58,0x7D,0xBD,0x45,0x4D,0x54,0xED,0xC0,0xB6,0xEE,
	0x76,0x05,0x9A,0xED,0x46,0xBD,0x6B,0x50,0x20,0x52,0x98,0xFA,0x55,0xFD,0xBA,0xDA,0xC4,0x18,0xF9,0x7C,
	0x94,0x99,0x81,0x04,0x0D,0xC0,0x8E,0x56,0x73,0xA8,0xEE,0x12,0x30,0xF5,0x2D,0xF6,0xAC,0xE8,0x34,0xB7,
	0x03,0x03,0xFF,0xD4,0x57,0x35,0x27,0xC2,0xDA,0x62,0x5D,0x91,0x47,0xD5,0xC7,0x93,0x39,0xF7,0x55,0xDE,
	0xBA,0x9C,0x8A,0xA1,0xF4,0x06,0x83,0xB6,0xB0,0x28,0xD9,0xEA,0xBF,0xD6,0xAB,0xE4,0xFA,0x28,0xC0,0x93,
	0x77,0x8D,0x0C,0x21,0xB1,0x27,0x00,0x79,0x4F,0xE0,0xF6,0x9F,0xCC,0xD8,0x6D,0x0D,0xC0,0xC3,0xC5,0xC4,
	0x82,0xDB,0xC0,0xA1,0x5E,0xBC,0x20,0xCC,0xAA,0x80,0xB9,0x9A,0xAB,0xAA,0x49,0xAC,0xC6,0x19,0x68,0xDC,
	0xAD,0xA8,0xC4,0xEF,0x9A,0x29,0x67,0xA5,0xFF,0xEA,0xE8,0x2A,0x83,0x61,0x86,0x98,0x89,0x4C,0x59,0xAF,
	0x2F,0x06,0xCB,0x20,0x59,0x5D,0x85,0x61,0x13,0xFD,0x55,0x5E,0x7E,0x53,0xF7,0x1B,0x93,0x68,0x31,0xFF,
	0x8D,0xD3,0xA9,0xFF,0x4A,0x3E,0x53,0x37,0x33,0x0C,0xFA,0xE6,0xC5,0x69,0x15,0xF7,0x3E,0x1D,0xDC,0x4D,
	0x2F,0x05,0x18,0xEC,0x04,0xDD,0x2A,0x59,0x30,0xB9,0x58,0xDB,0x4C,0x5F,0xB7,0x1F,0x3E,0x23,0x61,0x78,
	0x10,0x41,0x33,0xC1,0xF7,0x0D,0xD2,0x97,0xE4,0xD7,0x05,0xC3,0xD7,0x42,0xD7,0x3F,0x66,0x92,0x5D,0x3A,
	0x8C,0xB4,0x1F,0x46,0x10,0x0D,0x9E,0xD7,0x96,0x06,0xD2,0x56,0xDB,0x5B,0xE2,0x02,0x87,0xC6,0xEE,0x4B,
	0x74,0xDE,0xDD,0x37,0x08,0x57,0x8C,0xD6,0x84,0xCD,0xB0,0xAE,0x2F,0x2D,0x55,0xF5,0x8F,0xD8,0x47,0x37,
	0x6A,0x83,0xD5,0x15,0x00,0x05,0x38,0xC8,0xE9,0x87,0x4B,0x0F,0xFF,0xCC,0x2E,0xB9,0x7A,0x28,0xE9,0x0A,
	0xAF,0x5F,0xB6,0xFF,0x5F,0x11,0xDF,0xDB,0xA7,0x9F,0xEA,0x4E,0x82,0xD6,0x2A,0x0B,0x9D,0x8E,0xB8,0xB7,
	0x95,0x1D,0x37,0xB0,0xB9,0x15,0x1A,0x6B,0xD0,0xB6,0xFD,0x1F,0x81,0x45,0xA3,0x86,0xF5,0xE4,0xFC,0xDE,
	0x17,0x0E,0x93,0xF7,0x88,0x6F,0x3B,0x0B,0x06,0x81,0xDF,0xA8,0xD8,0xAA,0x27,0xAA,0xE2,0x00,0x4E,0x93,
	0x5C,0xC4,0x98,0x84,0x69,0x7D,0x15,0x91,0xBF,0xFC,0x86,0xFD,0xD7,0x07,0x1F,0x0A,0xCC,0x4F,0xF9,0x21,
	0x2E,0x0C,0x12,0x78,0x21,0x7D,0x9E,0xF2,0x8C,0x31,0x5C,0x95,0x10,0x09,0x44,0x34,0x9F,0x5C,0x7F,0x45,
	0x7A,0x92,0xE2,0x96,0xE7,0xF3,0xA5,0xF2,0xF5,0x2A,0xD2,0xB8,0xB1,0xD5,0xFB,0xD5,0x51,0xC1,0x8D,0x84,
	0x0F,0xDF,0x75,0x5D,0x9A,0x83,0xA6,0xBB,0xCA,0xAA,0x8F,0xBB,0xD4,0x3D,0x42,0xB3,0x0A,0x8F,0x93,0x53,
	0xA0,0x7A,0x9D,0xF8,0xAE,0x25,0xBE,0xEB,0xD1,0x32,0xFA,0x0F,0x40,0xD1,0xAA,0x23,0xDC,0x70,0xC8,0xDF,
	0xCB,0xD9,0x87,0xEC,0x75,0x3D,0xDF,0x75,0x64,0xA6,0x4F,0xBB,0x04,0xC1,0x80,0x15,0xF3,0x8B,0x3C,0xD6,
	0x57,0xA5,0xC2,0xB6,0x4B,0x57,0x5C,0x80,0xD7,0xBF,0xAC,0xAF,0x34,0x26,0xA7,0xD7,0xBD,0x1C,0xE8,0xAE,
	0x03,0x2A,0x56,0x58,0x79,0xFC,0x55,0xD9,0x3B,0x57,0x75,0x81,0x19,0x50,0x92,0x06,0x4C,0x42,0x9F,0xB9,
	0x2A,0x37,0xDC,0x37,0xE3,0xBB,0x6E,0xB1,0xB2,0x2C,0x85,0xE1,0x0E,0x0C,0xC8,0xD0,0xC4,0xFF,0x34,0xC0,
	0x8C,0x81,0xF8,0x2A,0x70,0x78,0x60,0x33,0x21,0x31,0x6F,0x79,0x10,0x81,0x82,0xE3,0x0D,0x53,0xAC,0xB0,
	0xB9,0x5D,0x07,0x44,0x80,0x24,0xF2,0xB6,0xBB,0xBE,0xBF,0x85,0xD7,0xD2,0x24,0xC2,0x62,0xF0,0x85,0x75,
	0x1D,0x44,0x19,0x83,0x82,0x94,0x64,0x84,0x99,0x15,0xE4,0x0D,0x7D,0x28,0x00,0x61,0x24,0xD3,0x9E,0xD0,
	0xD2,0x30,0xA2,0xD7,0x63,0xD4,0xAF,0x0A,0x19,0x50,0x20,0x26,0xA2,0xC4,0x38,0x40,0xE0,0xA7,0x81,0x0C,
	0x31,0xEE,0xEF,0xD6,0x48,0x35,0xDA,0xA0,0x50,0x4E,0xEB,0xB5,0x2B,0xD1,0x1A,0x18,0xB7,0xF0,0xB0,0x09,
	0x98,0x0D,0x26,0x48,0x3C,0x35,0x50,0x21,0xB2,0xC1,0x1A,0x70,0x1F,0x04,0x1D,0x1D,0x05,0x00,0x14,0xC9,
	0x20,0x8E,0x7E,0x5E,0x16,0x16,0x0F,0x2C,0x2A,0x4E,0x61,0x15,0x15,0x17,0x1D,0x39,0x5A,0x80,0x09,0xAE,
	0xBA,0x56,0x6E,0x94,0x9B,0x65,0x15,0x89,0xC1,0x40,0x73,0xCF,0xAC,0x29,0x5C,0xCB,0x8C,0x76,0x3E,0x5A,
	0xB0,0x64,0x83,0x8E,0x8B,0xE3,0xBE,0x48,0x54,0xCA,0x0C,0xBC,0x30,0x6A,0x4C,0x0A,0xE0,0x2A,0x2C,0x94,
	0x74,0x99,0x43,0x03,0x94,0x34,0xA7,0x45,0x32,0xD2,0xC4,0xFE,0xB5,0x8A,0xF3,0xAE,0xD2,0x5E,0x56,0x7D,
	0x59,0xC4,0xC1,0xAF,0x02,0xDD,0x1F,0x2D,0xBD,0x8F,0xF0,0xB8,0x73,0xD9,0x1B,0x28,0x78,0x9B,0xEC,0x80,
	0xCF,0x9A,0x35,0x7D,0x71,0xE6,0xBF,0xAA,0x47,0x15,0xB8,0xA8,0xEB,0x9A,0xDB,0xC6,0xA2,0x04,0x0C,0x5F,
	0xDA,0x33,0x9D,0xE6,0xCC,0x2F,0x1B,0xF4,0xB4,0x61,0x14,0x7F,0x25,0x2A,0x74,0x56,0x93,0x70,0xE1,0x7C,
	0x95,0xFF,0x9B,0x9B,0xC7,0x8D,0x98,0xF2,0x9E,0x57,0xBF,0x13,0x5B,0xC3,0x0A,0x36,0x08,0x15,0x90,0xD5,
	0x7B,0xA7,0xE6,0x32,0xAC,0x05,0x92,0x28,0x88,0xC6,0x50,0x55,0xF7,0x09,0x0E,0x16,0xEA,0x80,0x46,0xC4,
	0xFD,0xC0,0x2D,0xDD,0xB7,0xF2,0x7B,0x64,0xA1,0x65,0x8F,0x2D,0x1D,0xBE,0x34,0xA5,0xB9,0xE0,0x6D,0x57,
	0x37,0x48,0x75,0xE1,0xA2,0xDB,0xD9,0xBB,0x14,0x1F,0x4C,0x67,0x10,0xD6,0x74,0xBB,0x88,0x98,0x93,0x2D,
	0xCC,0xE1,0xBB,0xC6,0x4D,0x8A,0xCB,0xC9,0x6F,0xF4,0x78,0xE9,0xBE,0x51,0x0B,0xA4,0xBE,0x9A,0xEC,0x8A,
	0x83,0xC8,0xAA,0xAE,0x3E,0x68,0x31,0x01,0xA8,0xE2,0xCA,0x42,0x0A,0x28,0x0A,0xF5,0xDB,0x4E,0x48,0x15,
	0x84,0xA5,0xBA,0xB9,0xC1,0x51,0xFF,0x03,0xA5,0xB5,0xC2,0xAA,0x6D,0x1B,0x14,0x4F,0x4D,0x13,0x2A,0x01,
	0x03,0x6B,0x43,0x83,0x8F,0x75,0x0D,0x67,0x3F,0x85,0x73,0xC6,0x01,0x86,0x55,0xAA,0xBC,0xA8,0x4B,0x65,
	0xBF,0x2F,0xE2,0xA4,0xC7,0x1C,0xB2,0xCF,0xAE,0x2E,0x7A,0x8E,0xC5,0x8C,0x54,0xAC,0x5C,0x89,0xD2,0xF2,
	0xD1,0xDC,0x1D,0xA2,0x08,0xD2,0xCF,0xC6,0x31,0x1A,0x2C,0x69,0x04,0x3B,0x33,0x41,0x25,0xD8,0xA0,0x70,
	0x6C,0x46,0x4B,0xD5,0xB4,0x21,0x7C,0x45,0x94,0x53,0x15,0x44,0x68,0xE7,0x16,0x2C,0x44,0x56,0x8C,0x38,
	0xCB,0x6A,0x6A,0xB0,0x1A,0xFC,0x7A,0x01,0x10,0x76,0xD7,0xA7,0x21,0x09,0x39,0x24,0xC0,0xF2,0xF8,0xFD,
	0x67,0x17,0x4D,0xF7,0x54,0xDD,0xE2,0x7E,0xC8,0x45,0xD0,0xFE,0xAE,0x72,0x60,0xD8,0xDA,0x66,0xC5,0x24,
	0x66,0xA0,0x7F,0xEB,0x04,0xCA,0x36,0x9A,0xC6,0xD4,0xA4,0x60,0xCC,0x50,0xD6,0x7E,0x5D,0xA3,0xA0,0x3F,
	0x60,0xC1,0x93,0x39,0xC8,0xC4,0x0A,0x0B,0x23,0x2C,0x83,0xDB,0xAE,0xC9,0xA1,0xA5,0xC6,0x1D,0x5B,0x8E,
	0x6C,0x5F,0xD6,0x5E,0x9D,0x1B,0x09,0x90,0xD2,0x8F,0xE1,0x29,0xF1,0x55,0xF5,0x2C,0x35,0x99,0xBE,0x0F,
	0x95,0x50,0xCE,0xC6,0x7F,0x75,0x20,0x82,0xFA,0x81,0xB7,0xDE,0x76,0x5D,0x17,0x9C,0xAE,0xB0,0xBB,0x4A,
	0x68,0xB2,0xE1,0x7E,0xDB,0xFF,0x65,0x61,0x6D,0x62,0x13,0xBA,0x97,0x80,0x2A,0x25,0x7D,0x61,0x50,0x0B,
	0x42,0x85,0xD1,0x5C,0x32,0x61,0x58,0x5B,0x56,0x6D,0xFD,0xFC,0x89,0xFA,0x5D,0xA7,0x61,0x76,0x7D,0x90,
	0xF6,0x60,0x11,0x4C,0x9E,0xB5,0x83,0x6A,0x81,0x31,0xE5,0x81,0xEA,0xA9,0x93,0x8B,0xAE,0xA3,0x4A,0xF0,
	0xBD,0x57,0x53,0x9B,0xEB,0x8A,0xDE,0xC2,0x5C,0x81,0xF0,0xFA,0x83,0x5D,0x41,0xA4,0x05,0xCF,0x85,0x5D,
	0x36,0xD7,0xD5,0x12,0x1C,0x47,0x05,0xA6,0x33,0xC3,0xD0,0x10,0xCB,0xCC,0xD8,0xE4,0xDD,0xB6,0x8C,0x8B,
	0xF6,0x7D,0x25,0x1A,0xD7,0x4E,0xC5,0x39,0x88,0x0C,0xA3,0x99,0x78,0xEC,0x9A,0x54,0x55,0xB6,0xC6,0xAE,
	0xB0,0x3A,0x98,0xCC,0x6D,0x40,0x9C,0xCE,0x51,0x81,0x4E,0xB1,0xF3,0x5C,0xF4,0x6F,0x90,0x74,0x57,0xC1,
	0xFF,0x4F,0x05,0x9A,0x76,0x52,0xDD,0xCD,0x46,0x6D,0xD8,0x5E,0x84,0x2E,0x1B,0xFB,0x8A,0x53,0x4A,0xAE,
	0x22,0x5B,0x16,0x95,0x93,0x82,0x2D,0xD1,0xEF,0xCE,0x52,0xDB,0x72,0x61,0xC1,0xE8,0x2A,0xD1,0x1A,0x62,
	0x72,0x0A,0x48,0x94,0xE8,0xAE,0xE8,0x39,0x38,0xF3,0x88,0xC5,0xAA,0x43,0xB5,0x6C,0xD3,0x97,0x80,0x86,
	0x53,0x30,0x2F,0x67,0xD6,0xD4,0x68,0x23,0xE9,0xBB,0x0A,0xCC,0xAE,0x10,0x4C,0xF6,0x86,0x05,0x66,0xCA,
	0xD9,0x84,0xBF,0x40,0x1D,0x25,0x8D,0x15,0xE0,0x63,0xF6,0x01,0x85,0x9A,0x17,0xFF,0x9D,0x81,0x34,0x79,
	0x85,0x8F,0x91,0xCA,0x96,0x9F,0x4E,0xE6,0x77,0xD4,0xA5,0x60,0x65,0xD6,0x71,0x92,0x50,0x17,0xB6,0xB2,
	0x6C,0x6E,0x8F,0xC9,0xCA,0xC4,0xDE,0xF7,0x85,0x28,0xB7,0x58,0x48,0x00,0xC3,0xA3,0xA4,0xD5,0x3F,0x22,
	0xBC,0x99,0x70,0x04,0x47,0x1C,0x3D,0x8C,0x8D,0x32,0xB6,0x9E,0xDB,0xB5,0xEB,0x77,0xE0,0x73,0xA3,0x39,
	0x45,0xDD,0xBE,0xF0,0xC5,0x1A,0x14,0x0D,0xBE,0x12,0x27,0xBD,0x9E,0x22,0xF5,0x86,0x8B,0xA5,0x7B,0x01,
	0x05,0xD6,0x08,0xA2,0x0A,0x8E,0x56,0x95,0xF0,0xA9,0x7F,0x87,0x94,0x35,0xF7,0xCE,0xD6,0x56,0xEF,0xA3,
	0xDB,0x5C,0x0C,0x69,0xC4,0x8B,0xF3,0xEC,0xBD,0xB7,0x7A,0x8C,0xE8,0xEE,0x6A,0x59,0xA3,0x09,0xDF,0x17,
	0xA1,0x46,0x84,0xD3,0x62,0x0E,0xBB,0xF6,0x76,0xD5,0x98,0x27,0x7B,0x6D,0xCF,0xF9,0x60,0x76,0x82,0x7D,
	0x8F,0x2B,0x12,0xA4,0xFE,0x14,0x61,0x1F,0x2B,0xD6,0xBF,0x63,0x6F,0x0E,0xD3,0x3C,0x4D,0x83,0x5C,0x17,
	0x8A,0x9D,0xF3,0x49,0x58,0xDA,0xD2,0xE6,0xEC,0x96,0x50,0x1E,0xBD,0xFF,0xF9,0xD1,0xD7,0xB0,0xFF,0x3B,
	0xB3,0xAC,0x27,0x42,0x9D,0xDD,0x9C,0xE0,0x25,0x10,0xEE,0x12,0xEE,0x86,0x99,0xC7,0x3B,0x4D,0xD3,0xBE,
	0x1E,0x12,0xF2,0x5D,0x0F,0xD9,0x35,0xAA,0xFA,0x31,0xE2,0x25,0xA1,0x7A,0x53,0xBC,0xFF,0x0D,0x06,0x69,
	0x2A,0xA8,0xDD,0xE4,0xA9,0xF6,0x79,0x4F,0xB3,0xD6,0xBB,0xD7,0xDC,0xCF,0xC9,0x54,0xF2,0xBF,0x4D,0x60,
	0xA0,0xC5,0x04,0x04,0x05,0x32,0xDB,0xFB,0x00,0x5C,0x69,0x86,0xBC,0x5F,0x03,0x7A,0x3A,0xF1,0x7C,0xFD,
	0x06,0xFA,0xF7,0x6D,0x29,0x58,0xF7,0x45,0x58,0x69,0x6F,0x9B,0x7F,0x5F,0x81,0x04,0xC2,0x3C,0xE4,0x79,
	0xA8,0x86,0x80,0x22,0x87,0x5B,0x46,0xBF,0x29,0xD3,0x4F,0x79,0xB3,0x2A,0x88,0x18,0x26,0x8F,0x7B,0x86,
	0x2A,0xCC,0x10,0xE9,0x9E,0xC7,0x44,0x56,0x52,0x41,0x46,0x0D,0x08,0x9F,0x60,0xE2,0x5D,0x67,0x11,0x57,
	0x29,0xE1,0x67,0xE0,0xDF,0x6A,0xF4,0x88,0x02,0xAE,0x7E,0x9D,0xDE,0x11,0x26,0xED,0xDF,0xF8,0x3C,0xFE,
	0x16,0x9D,0x4E,0xC2,0x59,0xE2,0x5D,0x05,0x3B,0x95,0xF2,0xFF,0x76,0x77,0x54,0xE4,0xCB,0xBA,0x23,0x07,
	0xDD,0x8A,0xEC,0x1B,0x50,0xDE,0xF8,0x2A,0xAA,0xD8,0x77,0x54,0xF0,0x66,0xD2,0xFA,0x0D,0x9A,0xFF,0x7E,
	0xBD,0x78,0xE7,0x1C,0x35,0x5D,0x87,0xED,0xEC,0x24,0x0D,0x13,0x4C,0xD5,0x71,0x80,0xF0,0xC7,0x75,0x42,
	0x4E,0x3B,0xDE,0x96,0x54,0xE7,0x89,0xD5,0x5E,0x76,0xF7,0x39,0xF6,0x4C,0xC0,0x75,0x52,0x60,0x4D,0x76,
	0xBE,0x75,0x61,0x83,0x58,0x05,0x3B,0xAE,0x1F,0x3B,0xEC,0xC5,0x9D,0x3F,0xB1,0xEF,0x73,0x9E,0xFD,0xDD,
	0x09,0x38,0xD5,0x24,0xCB,0xEA,0xE2,0xF1,0x81,0xDC,0x55,0x83,0xF5,0x95,0x78,0xB3,0x18,0xC9,0x17,0x62,
	0xF1,0x0F,0x2A,0xFE,0xD5,0xA9,0xCE,0x65,0x1A,0x83,0xA4,0xB3,0x64,0x0A,0xE2,0x0C,0x62,0x53,0x1F,0xE7,
	0x93,0xFB,0x05,0x49,0x11,0x7C,0xB0,0xB0,0xD8,0x25,0xFF,0xCD,0xFC,0x7E,0x4B,0xB2,0x80,0x63,0x89,0xB3,
	0x78,0xD9,0x55,0x2B,0xF9,0x82,0x34,0x18,0x7E,0xB3,0x75,0x2C,0x96,0x85,0x96,0x74,0x62,0xAB,0xC1,0x6C,
	0x60,0xAB,0x61,0x5D,0xFF,0x1E,0x3C,0xC6,0x35,0xFB,0x6A,0x8A,0xAD,0x68,0x88,0xD6,0xEA,0xBF,0x16,0x86,
	0x60,0x7B,0xEB,0x82,0xAA,0xB0,0xEF,0x16,0x0E,0x06,0x2F,0x57,0x81,0xD3,0x82,0xF6,0xD5,0xD1,0x97,0x1C,
	0x5F,0x00,0x41,0xCC,0x90,0x37,0x02,0x7F,0x95,0x83,0xA9,0xDD,0x7B,0xFB,0xAF,0x72,0xB3,0x0A,0x36,0xAB,
	0x03,0x11,0xB8,0x44,0x9D,0xDF,0x57,0xCA,0x1E,0xDD,0xAC,0x36,0x0F,0xB2,0xCF,0xBE,0x7A,0x7F,0xB5,0xE4,
	0x8D,0x19,0x02,0x17,0x14,0x8D,0xC3,0x17,0xF0,0x68,0xC5,0x18,0xC7,0xFE,0x22,0x80,0x2A,0xDD,0xE0,0x88,
	0x47,0x49,0xC5,0xB9,0x17,0xDD,0x78,0xB8,0xB8,0xF8,0x5C,0x1D,0xAE,0x3B,0x93,0x7B,0x36,0x82,0xD9,0xF3,
	0x2F,0x69,0x23,0x26,0x48,0x86,0x38,0x91,0xCB,0x54,0x3B,0x4A,0xCF,0x5C,0x52,0x10,0x43,0x14,0xE2,0xEC,
	0x92,0xE3,0x8C,0x02,0xD1,0xBA,0x0D,0x49,0x36,0x85,0x29,0x08,0x79,0x62,0xB4,0xEC,0xCA,0xF6,0xDB,0x49,
	0xB8,0x5D,0x12,0xAF,0x02,0xF9,0x6F,0x37,0xF8,0x89,0x36,0xBB,0xD7,0xC0,0xFC,0x25,0x13,0xFA,0x60,0x4D,
	0x16,0x68,0xC5,0x2D,0x32,0xB3,0xDF,0xC1,0xB8,0x90,0x01,0xED,0xAA,0x1E,0x09,0x75,0xF9,0xD9,0x1D,0x07,
	0x05,0x5C,0xD7,0xC1,0x3C,0xBD,0xFF,0xE7,0xF7,0x66,0xF6,0xBF,0x66,0x52,0xC9,0x6F,0x65,0x90,0xAA,0x75,
	0x30,0x87,0xD0,0xA5,0x5B,0x25,0xEF,0x6E,0x20,0x28,0xB3,0xD0,0xDD,0x90,0xD7,0xD0,0xF8,0x39,0xC1,0x4D,
	0x4C,0xF6,0x69,0x3D,0xF8,0x46,0x71,0x6C,0xA3,0x3C,0xDA,0x88,0x85,0xA2,0x7A,0x4B,0xF8,0x97,0x79,0xCB,
	0xCB,0xC2,0x02,0x72,0xB3,0x9F,0x6C,0x1D,0x89,0xBD,0x2E,0xB8,0x19,0x18,0x07,0x31,0x2A,0xD6,0x19,0x50,
	0x4D,0xFE,0x42,0x54,0x84,0x18,0x6F,0x9C,0x57,0x8D,0xBB,0xAD,0x83,0xE8,0xD0,0xAD,0x23,0xE2,0xDF,0x14,
	0x73,0x1F,0x25,0xC9,0xCB,0x55,0x92,0xBE,0x2B,0x78,0xF6,0x72,0x5F,0x5D,0x40,0xE6,0x3E,0xD7,0x08,0x44,
	0x17,0x30,0xF5,0x3E,0xE8,0xEF,0xD5,0xDE,0xBB,0x2D,0x7F,0x29,0x55,0x15,0x00,0x1D,0x87,0x78,0x03,0x83,
	0xF9,0xDC,0x23,0xF5,0x7A,0x0A,0x3B,0x16,0x55,0x05,0x94,0xEB,0xEB,0x02,0x22,0x1E,0x5C,0xD9,0xD8,0x16,
	0x67,0xFE,0x2B,0x69,0x44,0x88,0xD8,0x12,0xC7,0xF5,0x83,0x7B,0xF5,0x2F,0xC2,0x75,0x00,0x90,0x89,0x68,
	0xC2,0xB5,0x25,0xFD,0xB0,0xA8,0x7B,0x92,0x72,0xD4,0xB7,0x5F,0x69,0xDA,0xE4,0x23,0x62,0x60,0x62,0x12,
	0x31,0x43,0xD0,0x7D,0x8B,0x91,0x49,0x12,0x92,0x84,0xE1,0xA9,0xE7,0xB8,0x00,0x44,0x88,0xA4,0x81,0x12,
	0x3B,0xFD,0x49,0x77,0x21,0xFC,0x33,0x90,0x26,0x19,0x51,0xE8,0x82,0x6E,0xE9,0xFD,0xBB,0xF7,0x1A,0x92,
	0xF7,0x99,0x70,0x82,0xFE,0xCB,0x12,0x67,0x51,0x3D,0x57,0x51,0x11,0x77,0x61,0xC4,0xF8,0xB3,0x48,0xA0,
	0x7D,0x61,0xCE,0x04,0xE5,0x60,0x02,0xA9,0x63,0xB6,0xB8,0x69,0xBA,0xA5,0x8B,0xD4,0xDB,0x3F,0x9E,0x24,
	0x26,0xC2,0x23,0xFA,0x73,0x1C,0x69,0xF0,0x15,0x77,0x17,0x03,0xAA,0xF2,0xBE,0x9B,0x0C,0x58,0x7A,0xDD,
	0x19,0xAC,0xD3,0xEE,0xA8,0xBF,0x13,0x4C,0x14,0xFC,0xFA,0x03,0x50,0xE9,0xDF,0x3A,0x3C,0x6B,0x92,0x8C,
	0x0B,0xFB,0xDF,0xE9,0x26,0x4E,0x54,0x56,0x1B,0xA6,0x4C,0x5F,0x92,0x9D,0x55,0x45,0x60,0x8A,0x52,0x63,
	0xF4,0xA6,0x36,0xD3,0x22,0xDB,0xA2,0x41,0x17,0x71,0x51,0x24,0x0A,0xA6,0xBB,0x2D,0x31,0xBB,0xBC,0x3B,
	0x2E,0x65,0x7D,0x85,0x69,0xFF,0x57,0x50,0x43,0x5F,0x74,0x89,0xF1,0xE8,0x7F,0x52,0xA1,0x3F,0x47,0xB1,
	0x26,0x7A,0x05,0x45,0xD1,0xAC,0xB3,0x48,0x20,0x24,0x37,0x30,0xBE,0x1A,0x7F,0x01,0x50,0xE9,0x66,0x4A,
	0xB1,0x74,0x0E,0x51,0x5F,0xAC,0xAF,0xD0,0x08,0x9A,0xBC,0x42,0x6C,0xBA,0x7C,0x15,0x4B,0x3B,0x5D,0x2C,
	0xF5,0xAB,0x0A,0x4A,0xBA,0xCD,0xF3,0x05,0xD8,0x43,0xC7,0x2D,0xE7,0xDF,0x15,0x13,0xEC,0x40,0x28,0x73,
	0x81,0x71,0x33,0xA7,0xA3,0x86,0x65,0x78,0x0D,0x88,0x32,0xB0,0xD6,0xD6,0x0E,0xCA,0x30,0xE3,0x02,0xC2,
	0xD5,0xF6,0x4D,0xF2,0xC2,0xA6,0xAE,0x46,0x8B,0xC0,0x87,0xBF,0xEA,0x6E,0xFD,0xB9,0xDA,0x99,0x81,0x53,
	0x76,0x97,0x95,0x02,0xB0,0x7B,0x9F,0xA9,0x1C,0xAF,0xDC,0xBF,0x55,0xFA,0xAF,0x77,0xD2,0x1A,0x8A,0xC5,
	0x36,0xF7,0x00,0x53,0xB7,0x34,0xBB,0x97,0x0F,0xEA,0x22,0x00,0x1A,0x09,0xF5,0x04,0x46,0x08,0xE6,0x5B,
	0x48,0xF7,0xDB,0xD6,0x9E,0x4D,0x7D,0x5F,0xC6,0x99,0xEA,0x48,0x82,0x48,0x99,0x01,0xA1,0xD2,0x7F,0x1F,
	0x2B,0xD8,0x51,0x07,0x9E,0xD2,0xB3,0xE7,0x88,0x05,0xD0,0x2A,0x83,0xC7,0x33,0xFB,0x52,0x82,0x20,0x39,
	0x0D,0xE8,0x57,0x7F,0x40,0x40,0xDF,0x0B,0xDE,0x38,0x01,0x6B,0xC3,0xFC,0x1B,0x44,0x49,0x81,0x75,0x7D,
	0x20,0x0A,0x64,0x03,0x43,0x2E,0x40,0xC0,0xE8,0xE3,0x89,0x40,0x3A,0x27,0x66,0xFB,0x57,0x4A,0x5C,0x5F,
	0x45,0x60,0x1D,0x54,0xC7,0xBE,0x3B,0xCF,0x40,0xD9,0xFB,0x6E,0xA3,0xAB,0x2F,0x4A,0x0F,0x15,0x80,0xF7,
	0xE5,0x93,0x75,0x7B,0xFB,0x0A,0xDA,0x47,0x62,0x9A,0x50,0x99,0x49,0xEA,0x33,0x9C,0x1C,0xF9,0x3B,0xBA,
	0xAA,0x02,0xC8,0xAF,0x3E,0xA6,0x03,0x05,0x2F,0x20,0x7D,0x8D,0x70,0x63,0x08,0x3B,0x3B,0x09,0x7D,0x08,
	0xC2,0xAE,0xB0,0x68,0x0A,0x4E,0x24,0xB9,0x26,0x6F,0x18,0xDD,0xBA,0xFD,0xA4,0x6F,0x12,0xDD,0x2F,0x03,
	0xD6,0x3D,0x12,0xAF,0x6A,0x16,0x86,0x8E,0x6B,0x81,0xF4,0x5D,0xB7,0x50,0xE6,0xE3,0xDA,0xEE,0x0E,0x52,
	0x91,0x79,0xD7,0xEF,0xDB,0x30,0x64,0x64,0xB7,0xD1,0x29,0xA7,0x27,0x63,0x32,0xB2,0xEA,0x99,0x6E,0x8F,
	0xDF,0x15,0xB6,0x4F,0x43,0xA6,0xBA,0x90,0xFA,0x8B,0x04,0xBF,0x0C,0x25,0xF9,0x75,0xFA,0xF7,0xFC,0xF0,
	0x17,0xEF,0xAF,0x4C,0x0E,0x77,0xE0,0x44,0xA5,0x4D,0xF0,0x89,0x52,0x64,0x15,0x7D,0x25,0x2C,0x20,0xDE,
	0xD6,0x45,0x41,0x2B,0x28,0x65,0x63,0x1E,0x08,0x5D,0xE5,0x1B,0x08,0x2B,0x6F,0x03,0x7A,0xCC,0xAB,0x32,
	0xA5,0x4E,0x6F,0x70,0x9B,0xFC,0xEA,0x5D,0xAA,0xD6,0x05,0x34,0xFD,0x23,0x6E,0x51,0xE6,0x71,0x8B,0xAF,
	0xE6,0x61,0x89,0x44,0xFB,0xC0,0x25,0xDD,0x5D,0xC3,0xFC,0x15,0xA1,0x16,0x89,0xBD,0x60,0x83,0x8F,0x21,
	0x35,0x7E,0x37,0xD3,0x7E,0x00,0x8B,0x6A,0x0E,0x1A,0x08,0xE5,0x3A,0x4D,0x75,0xEA,0x78,0x55,0x3E,0xA5,
	0xA5,0xEA,0x98,0x8F,0xA7,0x9D,0x19,0xD6,0x47,0xD7,0x1D,0x2D,0x6E,0x77,0xC0,0x7F,0x55,0xE0,0x56,0xC0,
	0xCF,0x0B,0x33,0x92,0x27,0xFE,0xD7,0x36,0x09,0xE5,0xBF,0xEB,0xBD,0x27,0x6F,0xC7,0xE2,0x55,0x27,0x6F,
	0xB6,0x2A,0x5F,0x15,0x39,0x53,0x49,0x2D,0xB9,0x2A,0x85,0xC1,0x0B,0xF4,0xD9,0xCA,0xCA,0x88,0x71,0xE3,
	0x80,0xDF,0x5A,0xDC,0x7D,0x86,0xA2,0x5B,0x71,0x2E,0x4B,0x8B,0xA7,0x9B,0xD4,0xDF,0x66,0x18,0x04,0xAC,
	0x1D,0x5C,0xC7,0x41,0x47,0xEF,0xDF,0x74,0xEF,0x42,0x5E,0xFF,0x04,0x46,0xAC,0x0B,0x3B,0x56,0x5C,0xDF,
	0xA5,0xA6,0x87,0xA9,0x43,0x4C,0xD1,0x53,0x2C,0x75,0xA2,0xE9,0x4A,0x46,0x31,0x56,0x8D,0xD5,0xDD,0x34,
	0xF5,0x14,0x69,0xB1,0xF0,0x2F,0xF7,0x7B,0xF1,0x9E,0x50,0x13,0x06,0xB9,0x7B,0x3D,0xE4,0x6B,0x03,0x46,
	0x4F,0x5D,0x91,0x79,0x55,0xAC,0xA8,0x35,0xFE,0xEC,0xB7,0x97,0xD8,0x86,0x34,0xB9,0xF2,0x8B,0xAE,0xE3,
	0xE2,0xA1,0x47,0x5F,0xFE,0xA0,0x2F,0xF5,0x02,0xE8,0x8F,0x38,0x24,0x2E,0x96,0xB2,0x75,0x05,0xE6,0x44,
	0xF5,0x0C,0x33,0xB3,0xEA,0xE3,0x91,0x8A,0xBF,0xC3,0xF0,0xD7,0x8D,0xC9,0xCC,0xF4,0xB7,0xD0,0xA1,0xC5,
	0xC0,0x35,0xC3,0xA8,0x4B,0xF6,0xB2,0x2E,0xF1,0xD7,0xFA,0xDF,0x8F,0xD4,0x96,0x4B,0xE3,0xEA,0x06,0xAB,
	0xFD,0x9B,0x8C,0x92,0xE1,0x35,0x60,0x88,0x74,0xFA,0xDA,0xBF,0x74,0x68,0xD1,0xD5,0x9C,0x60,0x08,0x19,
	0xBF,0x3F,0x59,0x18,0x6B,0x41,0x5B,0x24,0x40,0x2C,0x40,0x2A,0x16,0x7D,0x1D,0xD7,0x1E,0x08,0x28,0x5D,
	0x8C,0xBF,0xD4,0x80,0xEC,0x1A,0xCB,0x93,0x71,0x5B,0x76,0x81,0x8B,0xA6,0x61,0x57,0xDF,0x06,0x6F,0x65,
	0xAA,0xBD,0x13,0xAD,0xE7,0xC6,0x77,0xC2,0xF4,0xA6,0xA0,0x10,0xFD,0x4E,0xDC,0x68,0xF5,0x8D,0xEA,0xB9,
	0x7D,0x17,0x39,0x30,0x3D,0x3B,0x77,0xCB,0x38,0x05,0xC3,0xBD,0x29,0x2E,0xCD,0x21,0x54,0x3A,0x47,0x50,
	0xC6,0xB9,0x3E,0xD8,0xF5,0xFB,0x4E,0xD1,0x89,0xBB,0xEF,0xA6,0x30,0x0D,0x62,0x72,0x7D,0x07,0x28,0x3B,
	0x02,0xC9,0xAB,0x0F,0xA1,0xE0,0xDC,0xEE,0xE7,0xB3,0xE4,0x42,0x47,0x86,0x54,0x9D,0xD7,0x77,0xE2,0x92,
	0x53,0x8E,0xBB,0x18,0x7A,0x7D,0x8F,0xDC,0xBB,0x24,0x44,0xDC,0x79,0x4F,0x4D,0xD8,0x5A,0xEE,0x52,0xF5,
	0x77,0x73,0x6C,0x5C,0x41,0xE4,0x9D,0xD7,0x07,0xEC,0x48,0x96,0x6D,0x35,0x94,0x48,0x54,0xDF,0xEC,0xDB,
	0xB5,0x4E,0x9E,0x89,0x44,0x93,0x42,0x89,0x42,0x09,0x37,0xC6,0xAF,0x98,0x11,0x69,0x81,0xF1,0x7D,0x44,
	0x42,0x00,0x28,0xB1,0xF6,0xDF,0x39,0xD0,0x5F,0x07,0xC6,0x78,0xEC,0x6E,0xD4,0x83,0xBA,0x5D,0x3D,0x17,
	0x8B,0x2B,0xBB,0x11,0x33,0xF5,0xC7,0x8D,0x1B,0x8C,0x26,0xEE,0xC2,0x2C,0xFC,0x2A,0x85,0xDB,0x88,0x8B,
	0x2F,0x4D,0xAC,0xDC,0x8B,0x41,0xB8,0xAF,0x17,0xAC,0x4F,0x77,0x43,0xAA,0x85,0x5B,0x44,0xC5,0x9A,0x5B,
	0xF8,0x5D,0xC7,0xF7,0xBA,0x7D,0xFF,0xBB,0x8C,0xEA,0x2A,0x20,0x3E,0x70,0x8A,0xF0,0xB7,0x4D,0x98,0x82,
	0xB8,0xAF,0x0B,0x01,0xA2,0x96,0x99,0xC1,0xA2,0x78,0xFC,0xE2,0x5F,0xFE,0x9B,0x77,0x23,0xFA,0x8F,0x98,
	0x9B,0xEF,0x18,0x4F,0xD2,0x91,0x30,0xE0,0x8D,0xE3,0xBC,0x10,0x69,0x69,0xA0,0x5B,0x47,0xD5,0x56,0x9C,
	0xD7,0xB4,0x18,0xA9,0x3A,0xD6,0x5B,0x87,0xD7,0x39,0x54,0xD5,0xFA,0x9E,0xBB,0x5A,0x9A,0x79,0x46,0x47,
	0xEA,0xB4,0xD4,0x04,0x54,0x5B,0x5D,0xA1,0x51,0x4E,0xA6,0x6D,0x79,0x51,0x0D,0x43,0x72,0x5E,0x22,0x02,
	0xC1,0xC9,0x36,0xD7,0xDC,0x31,0xDC,0xA0,0xAB,0x1E,0x15,0x0F,0xA0,0x56,0x18,0xE4,0xF8,0x1A,0x34,0xFF,
	0x6A,0x3A,0xFC,0xF3,0xB5,0xC2,0xAB,0xDF,0x28,0xFE,0x2B,0x52,0x53,0xD9,0x7A,0xC0,0xAB,0xCF,0x62,0xBD,
	0x13,0x24,0x21,0xEA,0xFE,0x2F,0xFD,0x65,0xEA,0x29,0xD8,0x83,0xE6,0xFF,0xFE,0x9D,0x7D,0x7E,0x60,0x74,
	0xF7,0xF2,0xAD,0x3A,0xE9,0xFA,0x5F,0xE0,0xE1,0xBB,0x00,0x4D,0x8F,0xD8,0x95,0x80,0x05,0x37,0x36,0x52,
	0xCA,0x62,0xC7,0x4F,0xEA,0x77,0x0D,0x50,0x37,0x0D,0xDC,0xBC,0x23,0x7A,0xD0,0xAB,0xAB,0x1F,0xE5,0x03,
	0x03,0x7A,0x91,0x1B,0x3F,0x6B,0x4C,0x4F,0x69,0x3B,0x52,0x14,0x7A,0x8E,0xD4,0x70,0x61,0x58,0x30,0xFA,
	0x44,0x7D,0xD2,0x5D,0x97,0x54,0x89,0x8E,0x5F,0x3C,0x63,0x8D,0xF7,0xB0,0xD3,0x7F,0xC8,0xD6,0x52,0x44,
	0x86,0x95,0xF6,0xC7,0x33,0xD8,0xCF,0xD4,0x84,0x0D,0xFE,0xFB,0xCF,0xCE,0xC8,0x7C,0x41,0xD5,0x7D,0x1E,
	0x3B,0xA7,0xEE,0x5A,0x82,0xA4,0xC4,0xBA,0x7C,0xF2,0xD7,0x21,0x2E,0x67,0x0B,0xEE,0xD5,0x67,0x3D,0x0F,
	0x8A,0x03,0xAA,0x2A,0x2F,0xA8,0xFA,0x67,0x61,0x88,0xF9,0xA3,0xB4,0x14,0xAF,0xC1,0xF9,0x54,0x2F,0xEB,
	0xEB,0xDC,0xB1,0xE2,0x96,0x89,0x87,0x46,0x19,0x59,0xD7,0x47,0x8E,0xDF,0xB4,0xE9,0xBF,0xC4,0x2B,0x48,
	0xEE,0x5E,0x45,0xF5,0x5E,0xF3,0x52,0xAC,0x63,0xF5,0x76,0x30,0x9F,0xBF,0x9D,0xBC,0x32,0xB1,0x57,0xA2,
	0x1B,0x3F,0x33,0x8C,0x61,0x23,0xEC,0x88,0xA4,0x17,0x2C,0x23,0xBA,0xF3,0x89,0x7A,0x52,0x76,0x38,0xAC,
	0xFF,0xB8,0x65,0xD1,0xF5,0x49,0x58,0x28,0x9E,0xD9,0xDB,0x7F,0xBA,0xDB,0x99,0x49,0x8F,0xB2,0xB3,0x55,
	0x09,0x1A,0x6D,0xDD,0x44,0x3C,0xDA,0x2B,0xF7,0x8F,0xB5,0xD1,0xDD,0x4E,0xFF,0xB4,0xD7,0xB8,0xF8,0x9A,
	0x1E,0xDD,0xBD,0x7D,0xC8,0x97,0x18,0x1A,0xD3,0xAC,0xA6,0x2A,0x10,0xAA,0x87,0x7F,0x59,0x46,0xB0,0xEE,
	0xB1,0xBC,0xBB,0xA2,0xA1,0x0B,0x2C,0xF5,0x2D,0x32,0xD2,0x75,0x24,0x45,0x21,0xDE,0x76,0x93,0x6D,0x1D,
	0xED,0xE6,0xBF,0x76,0x2D,0x3D,0x53,0x75,0x99,0x8C,0x9B,0xA7,0xDF,0x63,0xA8,0xAF,0xD2,0xF9,0xB7,0xFD,
	0xAC,0x2E,0xE9,0x76,0xC1,0x01,0xC9,0x9B,0x7A,0x06,0xF1,0x7F,0x24,0x19,0xF7,0xCB,0x1F,0x8F,0x83,0xE0,
	0xC6,0xBA,0xB2,0x78,0x5C,0x8D,0x2F,0xE9,0x20,0xA8,0x00,0x18,0xC5,0x43,0xDE,0xF9,0xEB,0xD0,0x18,0x76,
	0x97,0xAD,0x37,0xA3,0xFE,0x0A,0xBA,0xD5,0x97,0xFE,0x92,0xD2,0xA3,0xC9,0x8A,0xDD,0x53,0xAB,0x2C,0xBA,
	0x02,0x2E,0x84,0x6E,0x0D,0xAE,0xD4,0xA1,0x6B,0xE8,0x93,0xA9,0xB0,0x1D,0x5C,0x18,0xC6,0x15,0xAE,0x29,
	0xD7,0xFD,0xA4,0xFC,0xF1,0xBB,0x6F,0x3D,0x5A,0xF7,0x07,0x99,0x7D,0x17,0x4E,0x23,0xA3,0x95,0x68,0xA9,
	0x6A,0x77,0x97,0x88,0xFB,0xC2,0xC0,0xC0,0xC0,0xB8,0x89,0x37,0xC7,0xB3,0xB1,0x50,0x66,0x28,0xEB,0xBF,
	0x0C,0x75,0x8F,0x37,0x04,0x90,0x78,0xB9,0xF6,0xDD,0xF5,0xAB,0xFF,0x88,0xFD,0xFC,0xE1,0x0F,0x5C,0x37,
	0x6D,0x7D,0xA0,0x5D,0xD8,0xA3,0xAE,0x3A,0x6D,0x45,0x30,0x22,0xBF,0x62,0x6F,0x11,0x4A,0x94,0xBE,0x47,
	0xD2,0xB7,0x87,0xFE,0xEA,0xD0,0xF2,0xF4,0x17,0x90,0xF2,0xEF,0x10,0x64,0x10,0xED,0x0E,0x55,0x71,0xFF,
	0xC1,0x90,0x02,0x0B,0x80,0xFE,0x9A,0x06,0xFB,0xA2,0xBB,0xDC,0xE2,0xD5,0x1E,0xBA,0x2F,0x52,0xF8,0xC0,
	0x13,0x2A,0x93,0x16,0x42,0x55,0xC1,0x6C,0xEE,0x90,0x97,0x01,0x46,0x2C,0x8F,0x2F,0x9C,0x5A,0x07,0xA7,
	0x68,0x61,0x74,0x8C,0xE1,0x43,0x32,0xFF,0xBB,0x58,0xF7,0xAA,0x53,0x57,0xE0,0x36,0x6A,0xC1,0xE0,0xCB,
	0x17,0x10,0x70,0xB5,0xDC,0x65,0xE1,0xFA,0x71,0x84,0xC2,0x3C,0x88,0x0E,0x07,0xBD,0x31,0x18,0x13,0x4C,
	0xB7,0x78,0xD5,0x25,0xE9,0x70,0x7E,0x94,0x38,0x30,0xCE,0x55,0x26,0xE7,0xC1,0x25,0xB0,0x9B,0x0A,0xDC,
	0x90,0x16,0x5F,0x28,0x6E,0xF5,0xBF,0x43,0x4C,0x7A,0x4D,0xCE,0xBA,0x6C,0x58,0x42,0xD8,0x6C,0xCD,0xAC,
	0xBB,0x06,0x06,0x03,0x85,0x66,0x31,0xB3,0xBF,0x62,0x75,0xE4,0xEB,0x28,0xAB,0xD8,0x83,0xFE,0xB5,0xA9,
	0xB7,0xE9,0x4D,0x39,0xBA,0x25,0xFA,0xDE,0x77,0x60,0xC2,0xDA,0x62,0x9B,0x02,0x86,0xA3,0xDC,0x7D,0x35,
	0x80,0x91,0x1A,0xC6,0x71,0x23,0x83,0x20,0x60,0xF4,0x1B,0xCA,0x0D,0x26,0x22,0x95,0x80,0x1F,0x85,0xEC,
	0x64,0x71,0x14,0x50,0x3A,0xEE,0x20,0xDD,0xBE,0x8C,0xAF,0xB7,0xCE,0x87,0x08,0x28,0x1C,0x71,0x3B,0xC9,
	0xB5,0x1B,0x41,0x25,0xEE,0x7F,0x1D,0x51,0xA4,0x81,0xFE,0x50,0x07,0xA5,0xE6,0xBB,0x60,0x96,0xDF,0x99,
	0x45,0x97,0xF5,0xC5,0xCA,0x26,0x0C,0xB1,0xCA,0x84,0x47,0xC9,0x60,0x18,0x72,0xC4,0x6A,0x9D,0xC6,0x95,
	0x73,0x55,0xA4,0x65,0xCE,0xC4,0xE5,0xB7,0xDA,0xB8,0x6C,0x27,0x7C,0x7D,0xD3,0x7D,0xB0,0x32,0x8C,0x87,
	0xB3,0x4C,0xC1,0x0A,0x39,0xF5,0xB2,0x80,0x81,0xC1,0xA1,0x9A,0x80,0x6C,0x55,0x00,0x55,0x01,0x07,0x2B,
	0xD7,0x97,0x61,0x39,0x56,0x41,0xD1,0x66,0xA0,0x07,0x56,0x11,0xE3,0x2A,0x35,0x48,0xCB,0x8E,0x54,0x55,
	0x8A,0xA5,0x34,0x4B,0x87,0x8D,0xA4,0x1A,0xAD,0x99,0x8E,0x3A,0x9B,0xA4,0x29,0xC3,0x73,0x93,0xED,0x14,
	0x24,0x3C,0x30,0xAA,0x52,0xA9,0x9D,0xD8,0x50,0xCD,0xF2,0x91,0xA0,0xE4,0xA4,0x6B,0xF3,0x5D,0xF9,0x4E,
	0x56,0x1C,0x2F,0x05,0x84,0xCE,0x4C,0x91,0xCB,0x02,0x60,0x79,0xDF,0xB0,0x3F,0x22,0xBB,0xFF,0x75,0xDD,
	0xFE,0xFA,0xA5,0xEF,0xE1,0xDB,0xB3,0x4C,0x8C,0x1A,0x43,0x4E,0xAD,0xA9,0x5A,0x1A,0x0C,0xCE,0xC0,0xE2,
	0xC5,0xEE,0xAA,0xC1,0x0C,0xBD,0xE9,0x7D,0xE9,0x01,0x14,0x12,0x01,0x04,0xFE,0x7D,0x78,0x8C,0xFB,0x5A,
	0x10,0x2C,0x97,0x80,0x56,0x65,0xE5,0x03,0xBA,0x00,0x50,0x20,0x34,0x0A,0x8A,0x51,0xDA,0xB3,0xD3,0x99,
	0x08,0xD5,0x99,0xBE,0x83,0xCB,0xD9,0x42,0x49,0x28,0x40,0x2F,0x6E,0xC0,0xAB,0x19,0x0E,0x06,0x2F,0x4A,
	0xC9,0x14,0x05,0xF1,0xB6,0x21,0x35,0xC5,0xA2,0x29,0x50,0x7B,0x89,0xE8,0xAA,0xDD,0xD1,0x96,0x56,0x64,
	0xC9,0x09,0xB5,0x62,0xB9,0xF5,0x20,0xAA,0x2B,0x02,0x00,0x1B,0x8F,0x8F,0xC0,0xCA,0x86,0x05,0xC3,0x02,
	0x8A,0x8D,0x11,0x6B,0x89,0xF5,0x42,0x2D,0xFE,0x47,0xF2,0x36,0x9F,0xFD,0x61,0x19,0xC0,0x52,0xE6,0xDD,
	0x89,0x08,0x46,0xC3,0xAA,0x6D,0xA8,0x18,0x2C,0x01,0x0F,0x42,0x44,0xCB,0xB7,0x8B,0xF9,0x09,0x92,0x02,
	0xA7,0xCB,0xF9,0x95,0xB1,0xD7,0x19,0xEC,0x7F,0x63,0xBB,0xBE,0x0A,0xD1,0x65,0xD1,0xC8,0x4E,0x63,0x03,
	0xDD,0xAB,0xA4,0x69,0x21,0x7C,0xD1,0x1C,0x6C,0x28,0x85,0x6B,0x1F,0x41,0x6F,0xD8,0x4B,0x5E,0xAD,0xA9,
	0xD5,0x6A,0x20,0xB8,0xE3,0xF6,0x4E,0xFC,0xDD,0x55,0xA4,0x8A,0x55,0x74,0x58,0x31,0x9F,0xA4,0x18,0xCC,
	0xDF,0x43,0x4E,0xC5,0x54,0x40,0x8F,0x03,0xAD,0x2B,0x76,0x8D,0xE5,0x5A,0xB3,0x3F,0x9C,0x3E,0x75,0xEE,
	0x7F,0xEE,0x68,0x9A,0x8B,0xB9,0x55,0xCD,0xB9,0xC0,0x8A,0x30,0xBC,0x84,0x4A,0x80,0x84,0x84,0x00,0xA2,
	0xA4,0xA2,0xA0,0x94,0x03,0x5D,0x6F,0xE1,0xAC,0x0F,0xAF,0x9E,0x97,0x1B,0x2A,0xD2,0xAF,0x78,0x03,0x58,
	0x7D,0xC9,0x4A,0x70,0x56,0xC7,0x31,0xE2,0xEA,0x21,0x22,0x4C,0x4E,0x00,0xF3,0x4D,0x80,0x7C,0x78,0x45,
	0x04,0xD6,0xDF,0x61,0x18,0x1B,0xAF,0x32,0x36,0xFE,0xF4,0xDF,0xB9,0xCC,0xAB,0x4B,0x97,0x95,0xBC,0xAE,
	0x9A,0x88,0x2C,0x83,0x90,0x97,0x1E,0x23,0x95,0xD8,0x44,0xEB,0xCF,0x97,0x0F,0xCD,0xCD,0x57,0x35,0x1D,
	0x92,0xAF,0x2F,0x5E,0xD7,0x13,0x06,0xAA,0xB8,0x95,0x6E,0x57,0x8D,0x30,0x11,0x44,0x76,0xF3,0x08,0x5E,
	0x64,0x3A,0x40,0xD1,0x36,0x6E,0x7F,0x1B,0x0B,0xC2,0xCA,0xFE,0xBF,0x21,0xCC,0x57,0x25,0xE2,0xEE,0x40,
	0x75,0xA4,0x61,0x13,0xB6,0x3B,0xC1,0x85,0x18,0x32,0x35,0xC6,0x0C,0xE6,0xC7,0x5D,0xA5,0x82,0x03,0x29,
	0xE0,0xE9,0xE7,0x94,0x43,0x2F,0x74,0x00,0x83,0x21,0x29,0x51,0x2A,0x56,0x2F,0x58,0xE0,0x2C,0xF1,0x28,
	0x07,0x43,0xC2,0x38,0x58,0xA7,0x81,0xF2,0x2B,0x2C,0x53,0x25,0x3A,0xA4,0xC7,0xBC,0xF9,0xE5,0x6C,0xB9,
	0xF6,0x54,0x33,0xBC,0x7E,0x17,0xE8,0x73,0x20,0xD4,0xB5,0xE4,0xAA,0xC9,0x80,0x14,0x9B,0x6C,0xBD,0x2F,
	0x6B,0x89,0xA3,0x7B,0xAA,0xC2,0xA1,0xD5,0xED,0x9B,0xA9,0xC1,0x5E,0xFE,0xFF,0x41,0x93,0x9C,0xF0,0x70,
	0x76,0x6F,0xB0,0x72,0xC8,0x75,0xB6,0xE6,0x7E,0x6C,0x2D,0x21,0xAA,0xB2,0x4C,0xA8,0x5C,0x19,0x14,0x55,
	0x74,0xDC,0xC4,0x89,0xCE,0xF8,0x41,0x7A,0xC5,0xBA,0x3E,0x9A,0x34,0x3A,0xFE,0x91,0xD3,0x51,0x9F,0x9B,
	0x60,0xF5,0x0B,0xEB,0x97,0xB5,0xBF,0xF1,0xDD,0x6B,0xCF,0x55,0x72,0xAB,0x29,0x38,0xBC,0x9C,0xCE,0x18,
	0x55,0x06,0xEC,0xAB,0x01,0xE8,0xD5,0x55,0x98,0x4F,0x1C,0x5F,0x36,0x69,0x80,0x22,0x32,0x30,0x9A,0x33,
	0xAD,0xE7,0x28,0x2E,0x2D,0x1F,0x28,0x02,0x8A,0x2B,0x0E,0x0C,0x48,0x65,0x59,0xD0,0x50,0x42,0x5E,0x91,
	0x25,0x55,0xFD,0x3C,0x57,0x41,0x44,0x4B,0x0B,0x37,0x96,0xFE,0xA4,0x3F,0x85,0x0A,0xE8,0x5F,0x74,0x3B,
	0x8A,0x24,0xD5,0xD4,0x36,0x2A,0x72,0x8C,0xA7,0x5F,0xC5,0x59,0x69,0x86,0xC1,0xF8,0xAE,0x6B,0xD4,0xFF,
	0x58,0x6B,0x9D,0xC2,0x82,0xCC,0x37,0x0C,0x46,0xC9,0x9A,0xAF,0xCF,0xB0,0x37,0x3B,0xBE,0xA6,0xE2,0xF8,
	0x1E,0x1B,0x86,0xB6,0xBA,0x8A,0xE9,0xF1,0x04,0xCC,0x5C,0xF9,0xF3,0xCF,0xA4,0xF5,0xD1,0x19,0xDB,0x2F,
	0x34,0x62,0xDD,0x61,0x3A,0xB2,0x93,0xFA,0x92,0x27,0xBE,0xC4,0x85,0x34,0xA6,0x27,0xF0,0x75,0x0B,0x62,
	0x2B,0x5A,0x25,0xD0,0xDC,0x26,0x83,0x6B,0xA0,0xBB,0x64,0x44,0x41,0x89,0xF8,0x3A,0x1D,0x43,0x68,0x8A,
	0xD1,0xD6,0x48,0x55,0xD4,0x67,0xFE,0x59,0x5F,0x5D,0x39,0x60,0xA0,0x46,0x5A,0xE1,0xF4,0x35,0xC3,0x75,
	0xFC,0x19,0xB0,0x7F,0xEE,0xE1,0x00,0x5F,0x57,0x45,0x26,0x74,0xBF,0xAB,0xAE,0x50,0x49,0x8D,0x25,0x24,
	0xD7,0x88,0xE4,0xA9,0x63,0x03,0x34,0xE3,0xEA,0x28,0x93,0xFF,0xF5,0xC4,0xA9,0x82,0xC6,0xBB,0x26,0xA8,
	0x0B,0xE9,0x76,0x73,0x45,0x98,0x06,0xDB,0x3D,0xCA,0xAB,0xD9,0xCA,0xAE,0x38,0x75,0x85,0x57,0x56,0xED,
	0xE2,0x6D,0xE5,0x02,0x03,0x87,0x75,0x79,0x3C,0x14,0xA9,0xA6,0xC7,0x11,0x40,0x4F,0xDD,0xC7,0x91,0x1F,
	0xAD,0xBE,0x3B,0x7F,0x28,0xDD,0x2A,0x54,0x48,0x32,0xDF,0xE4,0xFE,0x62,0xBC,0xFA,0xAD,0x99,0xF1,0xD5,
	0x49,0xBF,0xF2,0x7A,0xAA,0xD1,0x78,0x21,0x79,0x7D,0x20,0x30,0xFF,0x72,0x73,0x2E,0x15,0x45,0x0A,0x66,
	0x92,0xCB,0x8D,0xEE,0x8F,0xFB,0x8A,0x6E,0xCC,0x5F,0x01,0xD0,0x0D,0x79,0x4C,0xF1,0xBD,0x0A,0x50,0x96,
	0xC7,0x77,0x72,0xD7,0x89,0x7C,0x36,0x37,0xD8,0x88,0x5C,0x5B,0x21,0x4F,0x9E,0x4A,0x77,0x56,0x06,0x5D,
	0xD0,0x44,0xB9,0x9F,0x42,0xF2,0x40,0x2A,0xF0,0x53,0x5E,0x41,0x3D,0xE5,0xE2,0x07,0x88,0x73,0x30,0xBE,
	0x62,0x15,0x4C,0x69,0x3F,0x6B,0x2A,0x03,0x12,0x75,0xAE,0xE6,0x8F,0x09,0x69,0x8C,0xFE,0xBB,0x50,0x9A,
	0x8C,0xB2,0x76,0x89,0x28,0x16,0xE5,0x3C,0x10,0xA6,0xA0,0x48,0x82,0x14,0x41,0x91,0x98,0xDF,0x79,0xEB,
	0x10,0x5C,0x58,0x5D,0xCF,0xEF,0x1B,0xA8,0x7C,0x16,0xEF,0x7F,0xC5,0x18,0x26,0xD8,0xD5,0x5B,0xA8,0xAE,
	0xCA,0x58,0x23,0xA7,0xEA,0xA4,0xD4,0xAC,0x39,0xBF,0xC4,0x85,0x22,0x6B,0x3A,0xF9,0x14,0xA6,0x7D,0xB5,
	0xD0,0xE4,0x29,0x95,0xFE,0xA1,0xA3,0x70,0xF5,0xC6,0xCE,0x09,0x58,0x52,0x74,0xF2,0xFE,0x02,0x20,0x02,
	0xC4,0x8C,0x18,0x78,0x98,0x59,0x94,0x14,0x77,0x68,0x6D,0x61,0x6F,0x84,0x5D,0x04,0xDA,0xD6,0x75,0x62,
	0xE1,0x0E,0x90,0x5E,0xD9,0x4C,0x03,0xD7,0x84,0x95,0x62,0xB0,0x43,0x6A,0xA1,0xFF,0x53,0xB4,0x38,0x3C,
	0xD5,0xB1,0x7C,0xF3,0x6E,0xB6,0x0C,0xC6,0x7C,0xAA,0x2A,0x1A,0xF7,0x50,0x55,0x8C,0x19,0x57,0x19,0x3D,
	0x44,0x73,0xD3,0x5D,0xAF,0xAE,0x65,0x2A,0x7D,0x27,0x47,0x82,0x08,0x22,0x97,0x2F,0x66,0xDC,0x7F,0x29,
	0x39,0xA4,0xF9,0xBF,0x03,0x06,0xEA,0x2E,0x7D,0x25,0x18,0xBC,0x33,0x76,0x70,0x08,0xC5,0x3E,0x85,0xBA,
	0xBE,0x26,0x7A,0x5F,0xF2,0x43,0xB0,0x80,0xBD,0xD1,0x20,0x7F,0xE1,0x8C,0x1B,0x38,0xC9,0xEA,0xB2,0xAD,
	0xD7,0xED,0x5B,0x72,0x41,0x3F,0x62,0x94,0x2C,0xB6,0x68,0x1A,0x23,0xF0,0x9F,0xC1,0xC3,0x02,0xDC,0x11,
	0x5F,0xFD,0x0A,0x0F,0x22,0x0F,0x9E,0xE8,0x9D,0x3F,0xC1,0xAE,0xD2,0x0D,0x39,0x3B,0x66,0x75,0x59,0xAA,
	0x18,0xED,0x53,0x97,0xA0,0xE4,0xDD,0xEE,0x9B,0x53,0x97,0xEA,0xB1,0xAD,0x4A,0x5F,0x82,0xCA,0xD5,0xCD,
	0xAF,0x32,0xAF,0xFD,0x1F,0x09,0xCA,0xAF,0x94,0x31,0xF7,0x9F,0x2F,0x80,0x79,0xB5,0xD6,0x74,0x83,0xB7,
	0x2A,0xE4,0xC6,0x1C,0x1A,0xE2,0xDE,0xC2,0x59,0x19,0x96,0x2E,0x71,0x02,0xCA,0x42,0x30,0xAA,0x9A,0x4F,
	0xC8,0x6E,0xB7,0x7C,0x31,0xA0,0xD8,0x05,0xC2,0xFE,0x15,0x71,0xD9,0x28,0x7B,0xBF,0x40,0x14,0x14,0xD0,
	0x21,0xF9,0x92,0xC0,0x4B,0x53,0xF2,0xF9,0x6F,0xF7,0x76,0x7D,0xF1,0xC1,0xF6,0x8D,0xB9,0x34,0xBE,0xA9,
	0x5A,0x36,0xB3,0xBE,0x5A,0x2D,0xCB,0xBB,0x0D,0x2B,0xC2,0x1A,0xD5,0xC9,0xD2,0xE0,0x7C,0xC5,0xD9,0x2A,
	0xD2,0x3D,0x36,0x4C,0x3D,0x0B,0xC7,0x57,0x11,0x82,0x85,0xF8,0x59,0xA1,0x2D,0xC9,0x9F,0x23,0x8C,0x8E,
	0x4C,0x12,0x48,0x5D,0x9F,0xEA,0xC6,0x9D,0x55,0xA9,0x46,0x7D,0x98,0x48,0x64,0x4B,0x45,0x84,0x59,0x7D,
	0xC0,0xAC,0x26,0x8B,0xB0,0x57,0x7D,0x05,0x1C,0x23,0x9B,0xF6,0xBA,0xA5,0x48,0x7F,0x8F,0xC3,0xB3,0x6A,
	0x50,0x6B,0x9B,0x3D,0xC1,0x88,0x4E,0xBA,0x7B,0xEC,0xEA,0x7A,0x3E,0x59,0xD4,0x2D,0x08,0xA3,0x63,0xF1,
	0x58,0x41,0x0E,0xAC,0xCE,0xD0,0x97,0x7C,0x1F,0x90,0x69,0x5C,0x22,0x6C,0xDA,0x94,0x13,0x01,0x1C,0x2A,
	0xCC,0x54,0xFF,0xE3,0x68,0x3A,0xFE,0xB0,0x5C,0x13,0x57,0x53,0xFC,0xE1,0xAF,0x8B,0xDB,0xCB,0x57,0x14,
	0xAD,0x5F,0x37,0xFC,0x37,0xC1,0x48,0x5E,0x70,0xE0,0x0A,0x35,0x93,0xAD,0x5D,0x08,0xED,0xA9,0xD6,0xE1,
	0xEF,0x93,0xB4,0xFD,0x4A,0x83,0x9B,0x26,0x0A,0xD4,0xAE,0x0D,0x8B,0x97,0x8F,0xA4,0x5D,0x91,0x27,0xCD,
	0x77,0xF2,0x37,0x9C,0x71,0x14,0x89,0xEE,0x63,0x14,0xF2,0xB4,0x53,0x27,0xD4,0xFA,0xFA,0xF4,0x6E,0x0D,
	0xC4,0xAA,0x45,0x8C,0xBA,0xE8,0x95,0xA9,0xC0,0x82,0xA1,0x08,0xC6,0x1B,0xC9,0xD8,0x61,0xCF,0x61,0x55,
	0xC6,0x57,0xB1,0x3B,0xDB,0x1E,0xAC,0xC1,0x5B,0x32,0x5F,0x8E,0x5F,0x24,0x58,0x31,0xA9,0xAA,0x40,0x84,
	0x6C,0xE1,0x39,0x02,0xA2,0xA1,0x53,0x67,0xD5,0x83,0xD7,0x63,0x9A,0x33,0x8D,0xC3,0xD1,0xD4,0x87,0x05,
	0x73,0xE5,0x96,0x2A,0xF4,0xFF,0x53,0x18,0xB1,0xF5,0x5D,0x7A,0x2B,0x8C,0xAB,0x94,0x6E,0x27,0x13,0xF2,
	0x52,0xCD,0xA5,0xA0,0xB7,0xC9,0xE7,0x4A,0xE1,0x5A,0x67,0x2B,0x8A,0xD2,0xB8,0xFF,0xE7,0xDB,0xE4,0x71,
	0xDA,0xCC,0xDC,0x65,0xE6,0xE0,0x46,0xEE,0x54,0x3F,0x85,0x99,0x04,0x34,0x64,0x1F,0x7C,0x15,0xBE,0xB2,
	0x46,0xB5,0xC8,0x58,0x51,0x95,0xFC,0x8C,0xEB,0x92,0x0E,0x41,0x06,0xE6,0xCA,0x58,0x75,0x7F,0xC0,0xD2,
	0xDD,0x78,0xDE,0x79,0x48,0xBA,0x49,0x18,0xC8,0xA8,0x79,0x8B,0xA1,0x92,0x92,0xC8,0xAC,0x73,0xC5,0xC6,
	0x8F,0x4E,0xF7,0x97,0xBB,0x69,0xBA,0x4C,0x40,0xBA,0x6F,0xAA,0x7F,0x8B,0x94,0x79,0x19,0xAC,0x58,0x19,
	0x69,0xAA,0x3D,0x26,0x4F,0x31,0xA5,0xF7,0x2A,0x2B,0xDD,0x09,0x69,0x57,0x6D,0xBC,0xB9,0xFC,0x57,0x14,
	0xB0,0x8E,0x27,0x9E,0xEA,0xBE,0x77,0x8A,0x13,0x2F,0x23,0xC9,0xD6,0x5B,0x39,0x53,0x03,0xFD,0x46,0xAF,
	0x15,0x36,0x31,0x3B,0x77,0x87,0x0D,0x0D,0xD6,0xA8,0xFF,0x5C,0x6C,0x75,0x13,0x1B,0xE4,0xAE,0xC8,0x16,
	0x75,0x25,0x4E,0xFD,0xFB,0x7B,0xAD,0xB0,0x74,0xA5,0x3A,0x42,0x67,0x34,0x00,0x77,0x3D,0x78,0xF0,0xAA,
	0x00,0xB1,0x10,0xFF,0xD9,0xDB,0xDC,0xD6,0xC0,0xB9,0xC1,0x7F,0x63,0x39,0x37,0x7D,0xAC,0x0F,0xCC,0x6E,
	0x5A,0x47,0x13,0xBF,0xB2,0xC2,0x1E,0x90,0xAF,0x26,0xC9,0xEC,0x9E,0x41,0x5A,0x6F,0xBA,0x72,0xDA,0x86,
	0x4F,0xA1,0x8E,0x7E,0xAF,0x4C,0xAC,0x8E,0x86,0x2A,0x45,0xEE,0x0E,0xD8,0x7C,0x4C,0x0F,0x67,0xE6,0xCC,
	0xA8,0xAB,0x44,0xB9,0xAF,0x31,0xEF,0x59,0xFC,0xFD,0x2B,0xF5,0x01,0xD0,0xAA,0x41,0xC7,0xA8,0xD3,0x9D,
	0x3F,0x2C,0x64,0x24,0x52,0x57,0x13,0xF8,0x75,0x58,0x86,0x56,0x22,0xC9,0xFE,0x05,0x68,0x31,0x99,0xB0,
	0x9F,0x1A,0x68,0xDD,0xBE,0xF3,0x9B,0xEE,0x5E,0xEC,0x8A,0xF8,0xEC,0x73,0x1F,0x11,0xC2,0x22,0x55,0xFF,
	0xA5,0xD7,0x9B,0xF1,0x79,0x6A,0xBA,0xEE,0xB1,0xDD,0xED,0xE0,0x14,0x88,0xA1,0x6C,0x90,0x01,0x4F,0x7D,
	0x18,0xE9,0x37,0x0F,0xC6,0x90,0x7D,0x82,0xE9,0x42,0x68,0x80,0xAC,0x30,0x3F,0xF7,0x51,0xA5,0x81,0x74,
	0x4E,0x57,0xD3,0x54,0xEC,0xE7,0xFF,0x1C,0x83,0x25,0xFE,0xBE,0x08,0x92,0x47,0x33,0x4F,0x3C,0x54,0xE3,
	0x8B,0x2E,0xC0,0x6E,0x35,0x59,0xB7,0x5D,0x5D,0x50,0xF1,0x1A,0xC4,0x6D,0xAD,0x06,0xA9,0xAF,0xC4,0xE9,
	0x9A,0xEF,0x22,0xAB,0x0D,0xF5,0x43,0x56,0x2E,0xD5,0xB9,0x22,0x86,0xEB,0xFF,0xF5,0x25,0x71,0x0B,0x46,
	0xD4,0x9A,0x0B,0x69,0x1B,0xA6,0x3E,0x28,0xC9,0x38,0x63,0xFD,0x30,0x73,0xDC,0x98,0x87,0x20,0x75,0x15,
	0xD7,0x6A,0x28,0x24,0x83,0xDF,0x04,0x31,0x06,0xC0,0x63,0x7C,0xE6,0xCC,0xEF,0xE1,0x86,0x05,0x47,0x6B,
	0x4D,0xD5,0xBB,0xCD,0x54,0x54,0x1D,0x92,0x60,0x3F,0x80,0x49,0x72,0x42,0xF4,0x73,0x1B,0xDC,0xD5,0x9F,
	0xCD,0xD5,0x01,0x8B,0x0A,0x85,0x42,0x28,0xD0,0xAC,0x70,0xED,0xF9,0x8D,0x71,0xC8,0x82,0xD9,0xC2,0xB9,
	0xB6,0xC2,0xEF,0x50,0xC7,0xB9,0x68,0x37,0x38,0x15,0x0F,0x14,0x01,0xA2,0x4D,0xCF,0x7D,0x69,0x87,0xF5,
	0xBA,0x01,0x66,0xC0,0xC0,0xC9,0xAA,0xB2,0x5F,0xD1,0xA8,0x29,0xFE,0x16,0x9D,0x22,0xDD,0x5C,0x74,0xD4,
	0xD4,0x7C,0x43,0xC8,0x00,0x4D,0x25,0xED,0x09,0x74,0x34,0x30,0x8D,0x52,0x28,0x2E,0xF9,0xC0,0xC9,0x42,
	0x32,0xD2,0x6F,0xEB,0x54,0xD5,0x2B,0x8E,0x14,0xC5,0xBE,0x20,0x04,0x13,0xA7,0x0E,0x4E,0x53,0x6C,0xB6,
	0x37,0x3F,0x42,0x4E,0x41,0x80,0xC2,0x63,0x71,0xC9,0x19,0x50,0x42,0x78,0xE9,0xC0,0x84,0xB1,0xB7,0x74,
	0xA3,0xC1,0xE6,0x55,0xFB,0x6A,0x64,0x37,0xF2,0x61,0x16,0x37,0x34,0x26,0x78,0xFD,0x2A,0xE0,0xA6,0x09,
	0x57,0x05,0x0D,0xC5,0x99,0xC7,0x5F,0xA7,0x05,0xE2,0x20,0x30,0x30,0x00,0xC6,0xC1,0x1B,0x88,0x14,0x84,
	0x08,0x22,0x88,0x37,0xFE,0x8D,0xA1,0x43,0x5F,0x07,0x41,0x67,0x45,0x1A,0x1C,0x51,0x85,0xAE,0x74,0x10,
	0x69,0xFC,0x9B,0x4B,0x32,0x48,0x83,0xB8,0x4A,0xF3,0x93,0x87,0x5B,0xEB,0xD7,0x82,0x30,0x10,0xEA,0x64,
	0x72,0x3E,0x67,0x85,0x68,0x62,0x34,0x2D,0x20,0x37,0x1A,0x87,0x20,0xB4,0xB2,0x4B,0x39,0x15,0x9A,0x96,
	0xF1,0xEF,0xDB,0x74,0x9D,0xBA,0x13,0x94,0x31,0xB8,0x3A,0xAD,0xD7,0x46,0x22,0x2C,0x1C,0x9F,0x85,0x9D,
	0x07,0x0A,0xC0,0xD4,0xB3,0xDA,0xDA,0x3A,0xA3,0x42,0xA1,0xD5,0x85,0x86,0xFD,0xA1,0xC2,0xCE,0x24,0x5C,
	0x19,0xD3,0xC2,0x39,0x57,0x6A,0xE9,0x84,0x50,0x46,0x6F,0x30,0xAB,0x0E,0x57,0xAB,0xFD,0xBE,0x1C,0xA9,
	0x51,0x90,0x71,0xE2,0x1F,0x14,0x52,0xFF,0xAA,0x07,0x78,0x71,0x23,0x06,0xF2,0x20,0x0A,0xF2,0xCB,0xC0,
	0x7D,0x88,0xB1,0x62,0x18,0x66,0x84,0x73,0x5B,0x0C,0x16,0x07,0x71,0x68,0x4E,0x23,0x63,0x37,0x12,0x33,
	0xE2,0x5D,0xEC,0xEA,0x8A,0x7F,0x30,0x91,0xA2,0xC3,0x75,0x4E,0x37,0x21,0x88,0x02,0xC6,0xF9,0x6E,0x98,
	0x1B,0x4B,0x04,0xD7,0x7B,0x74,0x86,0x88,0xE2,0xA0,0xFA,0xF9,0x1B,0xE5,0x5A,0xCF,0x85,0x8E,0xDE,0x2D,
	0x17,0xE9,0x4E,0x6E,0x8D,0x73,0x37,0x5A,0x8F,0xD3,0xF5,0xBE,0xA6,0xF0,0x0A,0x76,0x49,0xA3,0x8A,0xF1,
	0x8B,0x62,0xD7,0xD7,0x3B,0x8B,0xD0,0x51,0x8D,0xA9,0x68,0x14,0x6C,0xB3,0x15,0x5B,0x5B,0xAF,0x31,0x46,
	0x71,0x19,0x58,0x17,0xE8,0x17,0x95,0xEF,0x0F,0x5A,0x63,0x1E,0xEF,0xAA,0xF8,0x3D,0x8F,0x25,0xEF,0xDE,
	0x5C,0xB7,0xC7,0x3F,0x4A,0xA6,0xA6,0x76,0x93,0xA6,0x22,0x34,0x4E,0x20,0x4B,0xC6,0x75,0x15,0xB8,0xA4,
	0xAB,0xEA,0xA4,0x95,0xA3,0x63,0xBE,0xAF,0x6C,0xBB,0x08,0xC1,0xC2,0xC0,0xB4,0xB1,0xFC,0x63,0xB5,0x69,
	0xB1,0x53,0x00,0x10,0xC3,0x2A,0x5D,0x24,0x92,0x03,0x26,0x0F,0x1D,0x14,0xF6,0x32,0xE5,0xD3,0x34,0x91,
	0x48,0x86,0xE0,0xF5,0xFD,0x21,0xDB,0xAB,0x2A,0xC1,0x44,0x57,0x72,0xC8,0x0B,0x66,0xD0,0x44,0xB9,0x37,
	0x34,0x73,0x41,0xB7,0x1D,0x10,0x78,0x9E,0xBF,0x2D,0xBC,0x58,0x79,0x40,0x77,0xBF,0xFA,0x94,0x30,0x37,
	0xA2,0x38,0xA4,0x90,0xFE,0x25,0x56,0xE9,0xA1,0x66,0x57,0x22,0x58,0x91,0x1E,0xE8,0xF1,0xD5,0x09,0x96,
	0x31,0x72,0x27,0x35,0xE2,0x80,0xB9,0xEA,0x31,0x16,0x8C,0x56,0x91,0x98,0xD9,0xD5,0x03,0x79,0x41,0x78,
	0x5E,0xAB,0x65,0x83,0x9B,0x66,0xC0,0xD9,0x88,0x72,0x93,0x5F,0x58,0x4A,0x73,0xBF,0x93,0xDB,0x7D,0xAC,
	0xE7,0x26,0xEC,0x3B,0x28,0x81,0x56,0xFE,0xBE,0x38,0xF6,0x4C,0x84,0x94,0x5E,0xA7,0x60,0x24,0x7F,0x31,
	0xD2,0x78,0x94,0x31,0x21,0x87,0x9C,0xDF,0x6B,0xE7,0x2A,0x1F,0x5E,0x32,0xC1,0x7D,0xFB,0x84,0x57,0x77,
	0xF9,0xFB,0x57,0xD5,0x39,0x7F,0xC4,0x30,0x0C,0x25,0x50,0x7D,0xF7,0x0D,0x5B,0x07,0x01,0xEB,0x22,0xC6,
	0xA2,0x1A,0x87,0x65,0xD0,0xBC,0xE9,0x5A,0x58,0x5E,0xEF,0x39,0x4A,0xB7,0xFA,0x90,0xD5,0x22,0x0B,0x90,
	0x98,0x52,0xD8,0x55,0xAD,0x33,0x5F,0x5E,0x08,0x20,0x4C,0x81,0xA2,0x72,0xAE,0x51,0x85,0x24,0x43,0x8D,
	0xFE,0x88,0x2E,0xEB,0x31,0xD6,0x05,0x5A,0xD6,0x3F,0xC7,0xB0,0xBF,0x94,0x60,0xAC,0x14,0xF4,0xFF,0x32,
	0xB5,0xE0,0x1A,0x11,0x57,0xBE,0xFC,0x2D,0x84,0x0F,0x38,0x80,0xB5,0x81,0xAB,0x22,0x57,0xF7,0x7F,0xDF,
	0xD2,0xFD,0x3F,0xA6,0x0E,0x95,0x7D,0x1F,0x5A,0x77,0x31,0xD9,0xB4,0x06,0x08,0x82,0x02,0x26,0x14,0xDA,
	0xA7,0x71,0x8B,0x4A,0xEB,0x16,0xB2,0x60,0x29,0x49,0x5D,0x54,0x24,0xED,0xD3,0x1B,0x64,0x68,0xF0,0xF5,
	0x25,0xDA,0x96,0xF5,0x69,0xFD,0x59,0x4E,0x57,0xE0,0x25,0xED,0xB3,0x47,0x79,0x4F,0xE9,0x34,0x29,0x62,
	0x0F,0x8E,0x51,0xFE,0x87,0x6C,0xF0,0x77,0xF9,0x75,0x85,0x15,0xA3,0xE1,0xD2,0xA9,0x94,0x35,0xA1,0x4E,
	0x53,0x1C,0x1C,0xB5,0xEF,0xFC,0xA8,0xB8,0xD1,0x25,0x42,0x78,0xD1,0xC3,0x08,0x51,0x6D,0x4A,0xD1,0x42,
	0x5B,0xB4,0xF1,0xFC,0x85,0x19,0x28,0xDB,0xE9,0x3F,0xAD,0xA0,0x87,0x59,0xB4,0xC2,0xAE,0xB9,0xC2,0x26,
	0x15,0x39,0x77,0x9F,0x10,0x16,0x17,0xEB,0xC2,0x17,0xE2,0x70,0x9D,0x0F,0x10,0x16,0x15,0x1A,0xFF,0xB9,
	0x6C,0x3C,0xA3,0x02,0xA3,0x23,0x55,0x4D,0x03,0x9B,0x86,0x61,0xF1,0x7B,0x0E,0xC0,0x55,0x89,0x5F,0x9B,
	0xD5,0x80,0x65,0x65,0xC3,0x53,0xAE,0x61,0xCC,0x18,0xCD,0xF1,0xA9,0xDC,0xAF,0x85,0xB0,0x2E,0x73,0xBA,
	0xFA,0x3E,0xC7,0x06,0x11,0xA4,0xB7,0x90,0x96,0x33,0x38,0xA1,0x57,0xDA,0xAF,0xB9,0x5E,0xBC,0x5F,0xAC,
	0xBE,0x2D,0xD5,0xE2,0x94,0x07,0xEC,0x3F,0x1D,0xBC,0x7B,0x09,0x5E,0x77,0xD8,0xD0,0xFC,0xA8,0x8A,0x41,
	0x04,0x59,0xEC,0xB0,0x64,0xE3,0xDF,0x65,0x0B,0x1C,0xA1,0xCF,0xB9,0x02,0xCF,0xC9,0x53,0xC1,0x87,0xF5,
	0x43,0x65,0xCD,0x91,0xD0,0xD3,0x6C,0x8F,0xF1,0xC4,0x57,0xB7,0x5A,0x82,0x50,0x6E,0x02,0xD0,0x08,0x9E,
	0x9D,0x3A,0x30,0x57,0xAB,0xA0,0xCD,0xBB,0xC5,0x25,0x68,0x04,0xC7,0xDA,0xB1,0x92,0xC8,0x70,0xC4,0x88,
	0xF9,0xC3,0xC6,0xDB,0x15,0x76,0x3D,0x9B,0x55,0xB1,0x1A,0x62,0x2B,0x60,0x18,0x32,0xDC,0x39,0xBB,0xC5,
	0x56,0x90,0xAF,0x16,0xBE,0x5D,0xAB,0x54,0x15,0x47,0xBB,0xBF,0xCB,0x7A,0xB3,0x83,0x96,0x7A,0x37,0x54,
	0xF7,0x63,0xFC,0x83,0xC3,0xB0,0xFC,0x57,0x39,0x2E,0xC3,0xEE,0xF0,0x90,0x0F,0xE4,0xDC,0xD8,0x62,0xE7,
	0xE0,0xED,0xC8,0xF0,0xB5,0xA8,0xEE,0x3F,0x5A,0xA8,0xE0,0xF2,0x84,0x36,0x71,0xB9,0x08,0xFF,0x18,0x6A,
	0x67,0xE3,0xA1,0x88,0x25,0x90,0xEB,0xDF,0x8D,0xC9,0x5B,0x70,0xF0,0xC0,0x22,0x03,0xCA,0x96,0x7B,0xFD,
	0x30,0xB0,0xC8,0x36,0x07,0xC7,0x38,0x7A,0x7D,0xA5,0x32,0x43,0x40,0xFA,0x8B,0x38,0x89,0xAB,0x51,0xD8,
	0x3A,0x0B,0x72,0x53,0x19,0xAC,0xBE,0xD5,0xF8,0x1D,0x57,0xD7,0xC8,0x02,0x7D,0xAE,0x1E,0xBB,0x56,0xB1,
	0x56,0x2C,0x56,0x15,0x43,0x75,0x31,0xB6,0xBA,0x96,0x33,0x64,0x35,0x75,0xE8,0xD2,0x5F,0x75,0x55,0xE7,
	0xFD,0x40,0x51,0xC7,0xAE,0xE0,0x46,0x1A,0x5D,0xAC,0xA1,0xEF,0x78,0xAF,0x8B,0x1E,0x9D,0xE7,0xEF,0xC8,
	0x51,0x58,0x0E,0xC9,0x50,0x7F,0x45,0xEF,0x87,0x60,0x51,0x40,0x27,0xFB,0x20,0x8B,0xAA,0xC4,0x87,0xAB,
	0x72,0xB6,0x28,0xF9,0x92,0xDA,0xFC,0x75,0x45,0xD6,0xAA,0xAC,0xD6,0x9C,0x3F,0xDF,0x3B,0xFD,0xFA,0x82,
	0x72,0xD8,0xBC,0xB2,0xC9,0xB8,0x0F,0x37,0x58,0xE8,0x5A,0x55,0x99,0xFB,0x4D,0xFB,0x44,0x36,0xF1,0xB6,
	0x5C,0xBE,0x8F,0xA0,0x82,0x6F,0xE0,0xC7,0xAB,0x40,0x19,0xC5,0x99,0x88,0x2F,0x5E,0xEB,0xD7,0x52,0xAE,
	0x32,0xC9,0xA2,0xF9,0x14,0xE4,0x25,0x64,0xE4,0x29,0xFA,0xAD,0xBA,0x20,0xED,0x0E,0x07,0x41,0x81,0x47,
	0x05,0x95,0x19,0x76,0xD9,0xB2,0xA6,0x5E,0x54,0x56,0x88,0x17,0x00,0xD2,0xF1,0x05,0xB2,0x4B,0xBF,0x85,
	0x54,0x0A,0x50,0x3A,0x65,0x1B,0xDE,0xD5,0xFE,0xB6,0x44,0x01,0xA1,0x53,0x95,0x53,0xEC,0x90,0x56,0xEE,
	0x5B,0x58,0xEB,0xF1,0x86,0x40,0x35,0x62,0x20,0x93,0x39,0xD2,0x8A,0xA0,0x59,0x91,0x20,0x19,0xDF,0x63,
	0x04,0x76,0x29,0x41,0xB6,0x84,0x63,0xE4,0xFB,0xB3,0x15,0x22,0x13,0x21,0x7C,0xD5,0x97,0x60,0x63,0x23,
	0x68,0x38,0x66,0x4E,0xDA,0xE1,0x01,0x49,0xEA,0x59,0x0F,0x52,0x41,0x61,0xE2,0x61,0xBC,0xFA,0xC1,0xAA,
	0x34,0x72,0x0A,0xFC,0xFD,0x9C,0xA7,0xC2,0xB9,0xF3,0x81,0xC4,0x45,0x80,0x40,0x3F,0xE2,0xF2,0x51,0x2D,
	0xF8,0x0C,0xAF,0x68,0x01,0x88,0x38,0x56,0x5D,0x2E,0xD4,0xAB,0xD0,0xAF,0x5F,0xBC,0xB9,0x56,0xED,0x98,
	0x9D,0xA3,0xB6,0x6C,0x26,0xE2,0x13,0x76,0x57,0xAB,0xE2,0x42,0xFD,0xBB,0x1D,0xDC,0x01,0xC5,0x02,0x69,
	0x7D,0x97,0x82,0x81,0xA7,0x93,0xB1,0xD9,0xA4,0xBD,0x78,0x5F,0xE5,0x80,0x6B,0x38,0x73,0x50,0x18,0xDD,
	0x10,0xDE,0x2C,0xB1,0xBF,0x6A,0x93,0x1C,0x17,0xFD,0xD1,0x4D,0x12,0x26,0xDE,0x61,0xAF,0xD2,0xBB,0x4B,
	0xB8,0xE9,0x54,0x85,0x4F,0xD7,0x64,0xE1,0xD3,0x4F,0x4D,0x89,0x23,0xAA,0x02,0x63,0x56,0xB5,0x10,0x41,
	0x35,0x30,0xBF,0xB5,0x28,0xAB,0x0F,0xC5,0x4D,0x05,0x74,0x2D,0xC7,0xD2,0x37,0x4E,0x2B,0xC9,0x4D,0x41,
	0x6E,0x62,0x89,0x0D,0x76,0x5D,0x3F,0x35,0xBD,0x75,0xAA,0x01,0xA4,0xB9,0x80,0x01,0x52,0x87,0x4E,0xDA,
	0xFE,0xD5,0x55,0xD4,0x80,0x22,0x96,0x1F,0x84,0x0A,0x4A,0x18,0xEB,0x82,0x38,0xAB,0xF7,0xCE,0x5D,0x11,
	0xB3,0xB8,0x3A,0xD4,0x34,0xE6,0x4C,0x59,0xBA,0xBF,0x50,0xB8,0xC4,0x8A,0x17,0x5A,0xA3,0xB7,0xF0,0x5F,
	0x4B,0xDC,0x03,0x7A,0xC2,0x45,0xCF,0x0A,0x74,0x83,0xA9,0x3D,0x31,0x37,0xDC,0x90,0x48,0xBB,0xC0,0xBB,
	0x60,0x30,0x4E,0x55,0xD7,0x54,0x17,0xE8,0xF4,0x1D,0xEE,0xCC,0xEB,0x6F,0x74,0x8E,0x91,0xBF,0x9B,0xCE,
	0x14,0x57,0xED,0x53,0xD5,0xA3,0xD5,0xFF,0xAF,0x9D,0x01,0x36,0xE3,0xC2,0x9B,0x1F,0x33,0xFC,0x5E,0x26,
	0xD5,0x50,0x55,0x07,0x50,0x04,0x04,0x1B,0xEF,0xFE,0x03,0x2C,0x77,0x54,0xF7,0x56,0xC3,0x1D,0x72,0x0E,
	0xFE,0x86,0xEE,0xD4,0x82,0xBF,0x72,0xBD,0xF1,0x24,0x24,0x24,0x83,0xBD,0xB3,0xD0,0xDF,0xC0,0xF2,0x99,
	0xEC,0xBD,0x3B,0xFC,0x4C,0x6C,0x54,0xAB,0x84,0x72,0x6A,0x27,0x74,0x07,0xBA,0x16,0x04,0xCE,0xB6,0x40,
	0x59,0xA8,0x7D,0x46,0xD0,0xAB,0x6C,0x00,0x15,0x71,0x02,0xDD,0x07,0xF9,0x19,0x9F,0x6D,0x00,0x48,0x78,
	0xDD,0x4F,0x8A,0x84,0xAD,0x6F,0x68,0xCF,0xE2,0x08,0xF6,0xAC,0x57,0xD1,0x7F,0x1B,0x5E,0x55,0x4E,0x5B,
	0x0B,0x50,0xF3,0x29,0xAF,0x9A,0xBA,0x04,0x26,0xA6,0x0E,0x26,0x90,0x8A,0x30,0x5A,0xF2,0xF1,0xEC,0x99,
	0x0C,0x8E,0x8F,0xF8,0x4C,0x35,0x63,0x82,0x5B,0xE5,0x77,0xC4,0xD2,0xD5,0xBF,0xA3,0xF1,0xB8,0x33,0x4B,
	0xAC,0x4E,0xC1,0x91,0x45,0xA1,0xA6,0xDD,0x57,0x8D,0x30,0x90,0x88,0x70,0xB7,0xF2,0x7A,0xFE,0x59,0x4F,
	0xC1,0x84,0x1D,0x1B,0xB4,0x27,0xEB,0x4E,0xB1,0xAB,0x18,0xE8,0x48,0x10,0x55,0x70,0x6B,0xFD,0x73,0x43,
	0x39,0x6A,0x5D,0xF4,0x04,0x34,0x1D,0x83,0xE1,0x15,0x3A,0x2D,0xC3,0xED,0x5F,0x71,0x24,0x3B,0xED,0x52,
	0xDA,0xB9,0x75,0xFF,0xB6,0x64,0x90,0x81,0x4A,0x5C,0xDF,0xFB,0x0E,0x71,0xED,0xD3,0x83,0xFE,0x12,0x59,
	0x17,0x4D,0x80,0xEB,0xF6,0xBB,0x81,0x17,0x2B,0x92,0x08,0xDA,0x09,0x75,0x8C,0x66,0xC3,0x31,0xCF,0x47,
	0x33,0x05,0x65,0xFF,0x5D,0xD6,0x3F,0x53,0xDB,0xD6,0x4C,0x12,0x43,0xE9,0x2F,0x40,0xFE,0x76,0xC7,0xB7,
	0xE4,0x19,0x06,0x08,0x5B,0x82,0xAE,0xC4,0x69,0xF8,0x09,0x46,0xCD,0xE9,0xEF,0x73,0x85,0xD5,0x5E,0xC2,
	0xC8,0xB0,0x3B,0x31,0xE2,0x58,0x65,0xF7,0x91,0xB8,0x60,0x56,0x24,0xF6,0x41,0xF8,0x7B,0xDB,0x26,0x98,
	0xBF,0x4D,0xC1,0xBB,0x7F,0x93,0xBE,0xC3,0x97,0x6B,0x1E,0x1C,0xF8,0xD9,0x0C,0x1D,0xF3,0x2D,0x5D,0xC6,
	0xD0,0xFE,0xE5,0xB9,0x2E,0x7F,0x17,0xB2,0xA8,0x00,0x3F,0x74,0x25,0x0E,0x12,0xE0,0xC2,0x46,0x18,0x5F,
	0xBD,0x68,0x59,0xCD,0xBF,0x76,0xB9,0xC4,0xFF,0xE2,0x2E,0x68,0xB0,0x44,0xBA,0xD4,0x28,0xB1,0xD1,0x14,
	0x84,0x5E,0xBB,0xB7,0xFA,0x2E,0x95,0x3B,0x5D,0x7D,0x22,0x6A,0x08,0xBF,0x9A,0xA0,0x92,0xEA,0xF7,0xBB,
	0xC1,0x1E,0x5F,0xFD,0x35,0xF7,0xD5,0x2D,0xDF,0xC2,0x12,0xB1,0xAC,0x3A,0xBC,0x59,0xA1,0xF9,0x15,0x41,
	0x2A,0xD9,0x73,0xB6,0x5B,0x17,0x80,0xE7,0x5D,0x87,0xA4,0x33,0xBF,0x47,0x87,0x18,0xFF,0xFF,0xE2,0xCC,
	0xF2,0x82,0x15,0x93,0x3C,0x84,0x69,0xCE,0xA1,0xBB,0xA5,0xD4,0xB8,0xCF,0x50,0x12,0xF2,0xC6,0x3C,0x0A,
	0xB9,0x3C,0x60,0x69,0x1D,0xFA,0xFB,0x90,0xB6,0x28,0x52,0x6D,0xF4,0xEA,0xCF,0x21,0x3E,0x5D,0xEC,0x83,
	0x79,0x27,0x6D,0xDE,0xFF,0x92,0x86,0x20,0x1F,0xF7,0xE0,0x7E,0x79,0xEA,0x5E,0x7A,0x07,0xFC,0x2A,0xE2,
	0xC3,0x0B,0x90,0xFD,0x36,0x5E,0x0C,0xD2,0x4C,0xAC,0x4E,0xD6,0xF4,0x2C,0xE4,0x96,0x7E,0x95,0x23,0xF3,
	0x8C,0x81,0x57,0x19,0x9C,0x32,0x33,0x3F,0xA8,0xF2,0xC8,0x65,0x0A,0x52,0x57,0x20,0xCF,0x0B,0xC2,0x8A,
	0x76,0x58,0xA1,0xFD,0xB3,0x5F,0xAD,0xDC,0x59,0x28,0x8B,0x8A,0x4F,0xA8,0x96,0x16,0xD4,0xDE,0x4C,0x68,
	0x66,0x44,0xE8,0x45,0x55,0xB1,0x72,0x60,0x30,0xCD,0xA5,0xFB,0xD6,0xD4,0x22,0xE0,0x52,0x94,0x5F,0xD8,
	0xEC,0x1B,0x19,0x22,0xDA,0x5C,0xFC,0xFB,0xEC,0x57,0x45,0xA0,0x05,0xE0,0x7F,0x45,0xCB,0xF6,0x72,0x9B,
	0xBF,0xD7,0xBB,0x4F,0x83,0xF0,0x22,0x34,0x52,0xBF,0xC8,0xA5,0xC1,0x95,0x52,0x2F,0xB5,0xAE,0x0E,0xBF,
	0xAE,0xEE,0x93,0x81,0x85,0xA0,0x13,0xD4,0xA4,0x10,0xBD,0xD0,0x63,0xD4,0xC2,0xB5,0x6A,0x27,0x45,0x2A,
	0x26,0xFE,0x50,0xC0,0xC9,0x9B,0x11,0xF5,0xEB,0x07,0xEB,0x12,0xFA,0xB3,0x2B,0xFA,0x32,0x8B,0xFA,0x26,
	0xBA,0x02,0xC8,0xCD,0x0F,0xFD,0x47,0x34,0x19,0x62,0x3A,0x58,0xFC,0x1C,0xD8,0xB2,0xE8,0x21,0xD0,0x55,
	0x15,0x9E,0xCD,0x0B,0xC7,0xAF,0x9A,0x5E,0xF4,0x6C,0x80,0x7E,0x18,0x99,0x74,0x5E,0x73,0x06,0xDC,0x60,
	0x31,0xBF,0x08,0x89,0x0B,0x14,0x06,0x79,0x7A,0xC9,0xB7,0x28,0xBB,0xDE,0xB0,0xCC,0x4A,0xC8,0xF8,0x85,
	0xE9,0x73,0x48,0x10,0xCD,0x82,0x33,0x41,0x9D,0xC7,0x27,0xF0,0x83,0x2B,0x3A,0x97,0x97,0xDF,0x31,0x57,
	0xBD,0xC4,0x7D,0x75,0xA5,0x57,0x85,0x2A,0x71,0x7E,0x39,0xF2,0xF5,0x97,0xB1,0xBA,0x1C,0x7C,0xC4,0xDA,
	0xA5,0x28,0xD5,0x74,0x1C,0x79,0x34,0xE6,0xAB,0xAA,0x46,0x13,0xB0,0xFF,0x95,0x33,0x27,0x18,0x7E,0x7D,
	0x4C,0xA5,0x71,0xBE,0x7B,0xA8,0xB9,0xCF,0xAB,0x26,0x63,0xA0,0x2A,0x20,0x5F,0x19,0x5D,0x7F,0x68,0xF0,
	0x15,0x5D,0x13,0x34,0x7D,0xD9,0xB0,0x34,0x3D,0xDE,0x0D,0xDD,0x8B,0x1F,0x34,0x39,0x47,0x44,0x4C,0x30,
	0x0B,0x52,0x18,0x1D,0x46,0x24,0x77,0x39,0xDB,0xE3,0xEA,0xBE,0x01,0x45,0xC8,0xDC,0x1D,0x80,0x75,0x9D,
	0x49,0x1B,0x6F,0x43,0xAE,0x0D,0xCF,0x80,0x68,0xAE,0x16,0x52,0x1B,0xA7,0xDC,0xE3,0x93,0x26,0xB1,0xBD,
	0x9B,0x0C,0xE3,0x5D,0x4C,0xD7,0xF6,0xA0,0x30,0x62,0x1B,0x70,0x55,0x0C,0x88,0xFA,0x64,0xCD,0xBC,0xA0,
	0x49,0xAF,0xC6,0x88,0x05,0xB0,0x5A,0xC1,0x2F,0x45,0x9F,0xA6,0x9C,0x56,0x62,0xF8,0xE2,0x2D,0x98,0xF9,
	0xE2,0x1D,0x83,0x15,0x2F,0x8A,0x3C,0x0A,0x22,0xDE,0xB8,0x0C,0xEC,0xDE,0x35,0xCD,0xF5,0x65,0xB4,0xE6,
	0x3A,0x83,0x12,0x94,0xA0,0xDA,0xFF,0xBD,0xF1,0x2A,0xFC,0x92,0x08,0x93,0x11,0xCD,0xC0,0x33,0x03,0xB4,
	0x38,0x55,0x8C,0xDB,0x07,0xC2,0x77,0xA8,0x0B,0xA4,0x92,0xC2,0x5D,0xAD,0xA4,0xA3,0xDA,0xAC,0x40,0x95,
	0x1A,0x47,0x45,0x42,0x7F,0x70,0xA5,0x69,0x5D,0x25,0xC3,0x0A,0xA8,0x4B,0xD1,0x43,0x63,0xFA,0x25,0x78,
	0xAF,0x06,0x91,0x75,0xC3,0x91,0x45,0x49,0x82,0xAE,0xC9,0x91,0x42,0xB2,0xAE,0xCA,0x20,0x1C,0x72,0xFD,
	0x9B,0x90,0xE2,0xB9,0xBA,0x22,0xAB,0xFF,0x4E,0xEC,0xD0,0x87,0x59,0xC1,0x45,0xC7,0x26,0x52,0xAF,0x6C,
	0x7F,0xE8,0xC1,0x6C,0xC9,0xAF,0x28,0xFA,0x57,0x47,0xE9,0x2C,0x0A,0x6F,0x0A,0xD9,0x92,0xCD,0x68,0xD7,
	0x04,0x4C,0x55,0xE4,0x89,0xBF,0xD6,0x50,0x10,0x49,0x74,0x7D,0x78,0xAE,0x84,0x65,0x43,0xBB,0xBA,0x9F,
	0x2B,0x2B,0xF4,0x43,0x7F,0x96,0xBE,0x3A,0x94,0x03,0x10,0xD4,0xBB,0x80,0x8F,0x38,0xA4,0x86,0x82,0x16,
	0x2D,0x92,0x1D,0xDD,0xB5,0x32,0x3E,0xD0,0xAA,0x3E,0x3E,0xDC,0x57,0x5D,0x6D,0xFD,0x3D,0x4B,0xC5,0x03,
	0x37,0x80,0x28,0x78,0x5F,0x97,0xB0,0x47,0x3F,0x95,0xFE,0xF9,0x64,0x0A,0x7A,0x7D,0xCB,0x94,0x5F,0x5D,
	0xF4,0x8A,0x61,0x54,0xDE,0x21,0xF5,0x25,0x5F,0xD5,0x0A,0xCC,0x3A,0xDC,0x4C,0x70,0x96,0x77,0xD2,0x0D,
	0x89,0x47,0x3D,0x7E,0xF7,0x63,0xB2,0xA5,0x0F,0x46,0xFC,0x34,0xC6,0x85,0x13,0xF8,0xDA,0xEF,0x6A,0x37,
	0x15,0x33,0xBB,0x2B,0xAA,0x32,0x25,0x1D,0x68,0x92,0xE0,0x18,0x7D,0xCC,0x1A,0x2A,0x05,0x3B,0x27,0x37,
	0x60,0xF6,0x1E,0xFA,0x48,0xE7,0xB8,0x49,0x0D,0xB6,0x09,0x75,0x88,0xC0,0xC2,0x1D,0x88,0x0B,0x10,0xAF,
	0x01,0xE0,0xA2,0x30,0xB8,0x73,0x31,0xB9,0x60,0x7C,0xF7,0xB6,0x4E,0x72,0x8B,0xE2,0xAE,0x0C,0x10,0x81,
	0xBA,0xA9,0x75,0x7D,0x7B,0x7C,0x2D,0xFF,0x24,0xDC,0xD7,0xD7,0xB3,0xF5,0xBE,0x8A,0xDD,0x59,0x51,0xB6,
	0xA1,0x81,0x60,0x57,0x6F,0x4A,0x72,0x51,0x60,0x0F,0x6C,0x82,0x22,0x5B,0x1E,0x35,0xD4,0xBF,0x07,0xA1,
	0x95,0xDB,0x17,0xEB,0xFE,0x5F,0x89,0xCC,0xFC,0x37,0x74,0x92,0xB3,0x96,0x28,0x97,0x0E,0x5C,0x71,0x38,
	0x38,0xBF,0x86,0x1D,0x8C,0xD0,0xF4,0xB4,0xAF,0xBE,0x0C,0x50,0x07,0xCE,0xBD,0x14,0x97,0xF4,0xAB,0xA4,
	0x0A,0x90,0xAD,0x85,0xC1,0x28,0x12,0x93,0xCB,0x2A,0xB7,0x35,0xE7,0x89,0xB5,0xBA,0xFB,0x17,0x00,0x98,
	0xC9,0x6C,0x29,0xA3,0xE0,0xAD,0xCB,0xF5,0xDE,0xAF,0x1D,0x0E,0x1C,0xE1,0x49,0x07,0x38,0xC0,0xC0,0x1C,
	0xE7,0x9B,0x59,0xE4,0xEB,0xCB,0x29,0xF8,0x40,0x9B,0x77,0x6D,0xBB,0xBE,0xD5,0x70,0x1F,0x76,0x4E,0xD5,
	0x31,0x85,0xFD,0x75,0x1C,0xF6,0x99,0xEE,0xF6,0xAC,0x05,0x43,0xD7,0x1B,0x16,0x37,0x01,0x1D,0x15,0x27,
	0xEB,0x11,0x93,0xA2,0x1E,0x4C,0x91,0x19,0x96,0x31,0x64,0x21,0x78,0x1C,0x30,0xEA,0x1A,0x61,0x10,0x3A,
	0xB9,0xE4,0xAD,0xE9,0x45,0xAF,0x12,0x55,0x2C,0x42,0xBA,0x21,0x38,0x2F,0xFB,0x44,0xF8,0x21,0x4B,0xA5,
	0x32,0x93,0x3C,0x18,0x61,0x6E,0xD3,0x99,0xBE,0x1E,0x85,0x1F,0xEC,0x90,0x73,0xB4,0x21,0x1B,0xE1,0x2C,
	0x48,0xD6,0xD7,0x81,0x20,0x70,0xF0,0xE0,0xFD,0xBF,0x9C,0xFF,0x2B,0x4F,0x78,0x9A,0x09,0x66,0x99,0x69,
	0x41,0x94,0x64,0xCA,0x57,0x55,0xD2,0x5F,0x00,0x37,0xDB,0x52,0x68,0xA2,0x52,0x97,0x38,0x53,0x5D,0x3D,
	0xEA,0x82,0xAA,0x29,0x48,0x44,0x7F,0x16,0xE5,0x38,0xE9,0x80,0x44,0x76,0x0F,0x21,0xE4,0x33,0xD9,0x15,
	0xDE,0x69,0x4E,0x76,0xAA,0x3B,0x1E,0x4D,0xDD,0xD7,0x20,0x8D,0xCF,0xBB,0x23,0xF4,0xAA,0xBA,0xFD,0xAE,
	0x94,0x63,0x48,0x14,0xBB,0xD9,0x99,0xC0,0xD8,0xFC,0x0A,0x48,0x00,0xAF,0x2A,0xCD,0x44,0xA1,0xAF,0x12,
	0x6D,0x80,0x42,0xDD,0x95,0x2C,0xF1,0x48,0x5F,0x4A,0x10,0xAF,0x66,0xEC,0xCE,0xE4,0x57,0xEB,0x99,0x73,
	0xBB,0x8B,0xAD,0xCF,0x23,0xE3,0xE2,0xAE,0x69,0x99,0xDF,0x6C,0x6B,0x4C,0x54,0xB5,0x5D,0x45,0xDF,0xAA,
	0x87,0x98,0x17,0x7E,0x9D,0x32,0x54,0x30,0x41,0xE7,0x8E,0x53,0xE4,0x00,0x02,0x58,0x1A,0xD5,0x8C,0x52,
	0x10,0x8E,0x5E,0x11,0x86,0x1D,0xC1,0x31,0x06,0x7D,0x5A,0x53,0xC0,0x94,0x02,0x9A,0x50,0xDC,0xFF,0xEC,
	0xEC,0x7D,0x54,0x56,0xA0,0xC2,0xF2,0x93,0x87,0x84,0x01,0x9C,0xF8,0xBC,0x63,0x25,0x25,0xF5,0xED,0x9F,
	0x92,0xCB,0xC1,0x8C,0x70,0x09,0x58,0x99,0x8E,0x3B,0xED,0xA9,0xC9,0x69,0xE3,0x45,0x59,0x69,0x91,0x8C,
	0x90,0xDF,0xAE,0x6C,0x90,0x92,0x61,0xBB,0x64,0x86,0xA6,0x7F,0xF9,0x4E,0x50,0x87,0x6B,0x25,0x60,0x3D,
	0x6E,0x31,0xF3,0x55,0x0A,0x03,0x03,0xE8,0xC6,0x19,0xF8,0x20,0xE8,0xEF,0xF1,0x24,0x73,0xE9,0x2C,0xD7,
	0x95,0x24,0xEC,0xAD,0xEB,0x98,0x22,0x68,0x54,0x4C,0x08,0x1E,0x9A,0x3C,0x30,0x41,0xD5,0xF1,0x17,0xEA,
	0xBB,0x26,0x65,0x6C,0x0B,0x18,0x1C,0x65,0x51,0x8E,0xE7,0xDA,0xFA,0xDC,0x01,0x99,0x61,0x0E,0x15,0xD6,
	0xCE,0x0E,0x4A,0x79,0x95,0x4E,0xC8,0x59,0x08,0xA7,0xFF,0xFC,0xD5,0x45,0x49,0xF4,0x1E,0x92,0xD8,0x18,
	0xAF,0x89,0x03,0x55,0x3A,0x90,0x8E,0x05,0x0E,0x81,0x63,0x76,0x64,0x7D,0xBF,0x95,0x82,0xEA,0xDF,0xC2,
	0x8E,0x51,0xAC,0xB0,0x70,0x37,0xE5,0xD7,0x2F,0x07,0x08,0xA9,0xAB,0xC1,0x62,0xA0,0x6E,0x5B,0x75,0x0A,
	0xEF,0xAF,0xD4,0x91,0xE9,0x26,0x5C,0x7F,0x32,0x47,0x94,0x45,0x90,0xB2,0xD7,0xE2,0xC5,0xBE,0x71,0xCB,
	0xEA,0x55,0x5D,0x28,0x95,0xA2,0x3D,0x71,0x31,0xBB,0xEB,0x37,0x3E,0xEF,0xCB,0x36,0x5D,0x3D,0x7D,0xD5,
	0x8A,0x5D,0x28,0xF6,0xF5,0x86,0xBB,0x58,0x94,0x98,0x7E,0x4D,0x4C,0x24,0x49,0x51,0xAF,0x28,0xD4,0x6E,
	0xDD,0x2A,0x5D,0x92,0xA2,0x24,0x36,0x37,0x82,0xBD,0x1A,0x1A,0x55,0x60,0x62,0xB0,0x4E,0x45,0x4F,0x79,
	0xC5,0x7D,0x00,0xD8,0x1E,0x90,0x0D,0x37,0x9F,0x00,0x5D,0x17,0xE8,0x11,0xE0,0x05,0x56,0x77,0xB5,0xC8,
	0xEF,0x42,0x64,0xFD,0x8B,0xB1,0xCE,0x10,0x75,0x4F,0xD1,0xF5,0x81,0xA6,0x2D,0xED,0xA4,0xC9,0x21,0x86,
	0xCB,0xAD,0x7D,0xA9,0xD6,0xEF,0x2B,0xF0,0x2F,0xB0,0x95,0x3F,0xBA,0x50,0x6B,0xEB,0xB4,0xF6,0x7E,0x98,
	0x32,0xAC,0xB9,0x27,0xC1,0xC5,0x10,0x63,0x41,0x94,0x88,0x45,0x8F,0xCB,0x22,0x70,0x2B,0x74,0xB3,0xBA,
	0x9D,0xF1,0x1F,0xDA,0xBE,0xC6,0x71,0x5D,0x29,0xE0,0xD5,0x2E,0x4C,0x00,0xBB,0xFE,0x24,0xE9,0x95,0xCD,
	0x6D,0xFB,0x6A,0x47,0xBA,0x9D,0x59,0xAA,0x62,0xD9,0xDE,0xD9,0x42,0x2B,0xC2,0x77,0x54,0x74,0xAB,0xCB,
	0x61,0xD9,0xFF,0xAE,0x26,0xE8,0xAB,0x0A,0xFD,0x11,0xA9,0x55,0x55,0x56,0x32,0x43,0x15,0x8C,0x02,0xD5,
	0x4E,0x57,0xF5,0x22,0x77,0xC9,0xA8,0xEF,0xD0,0xE9,0x8B,0x40,0x00,0xC4,0x26,0x4A,0x0D,0xD4,0x73,0x30,
	0x93,0xFF,0x14,0x5D,0xE9,0x62,0x50,0x89,0x7F,0xAD,0x5F,0x33,0x1D,0x52,0x2F,0xC5,0xC8,0xC8,0x09,0x2A,
	0xCE,0x15,0x32,0x78,0x55,0x0A,0x1E,0x80,0xB5,0x30,0x4C,0x7B,0x37,0x07,0x2F,0xC7,0xAF,0xC3,0xFC,0x64,
	0xEA,0xFA,0x13,0x32,0x4D,0xD8,0xAD,0xB9,0x31,0x57,0x2D,0x4A,0xF9,0xFC,0x37,0x88,0xD1,0xE7,0xAA,0xF8,
	0xCC,0x1D,0xA2,0x98,0xF6,0x5B,0xE9,0x46,0x37,0xEB,0xC4,0x46,0xFD,0x38,0xCE,0x15,0x64,0x2C,0x5A,0xD6,
	0x3E,0xDC,0x81,0x5E,0x07,0xD0,0xB7,0xF3,0x6D,0x88,0xE5,0x19,0x5A,0x77,0xBF,0xBC,0x30,0x4A,0x28,0x90,
	0x66,0xAF,0x7F,0x4F,0x5B,0xF5,0x50,0x03,0xE7,0x21,0x8B,0x77,0x0C,0x49,0x85,0xCC,0xAF,0x52,0xA6,0x2E,
	0x00,0x45,0x80,0xAE,0x8C,0x35,0xFF,0x1F,0xBA,0xBB,0x62,0xB6,0x1D,0x74,0xF6,0x2B,0x4E,0x2A,0x44,0xD5,
	0x80,0x57,0xB7,0x4E,0xBF,0x63,0xE9,0x43,0x40,0xCF,0x75,0x82,0xEA,0x38,0xBC,0xEB,0x9A,0xB8,0x2A,0x82,
	0xFB,0x9E,0xA4,0xB4,0xE5,0xDF,0xD7,0xCA,0x46,0x28,0xE3,0x5C,0xB8,0x13,0xE1,0x38,0x4F,0x75,0xC0,0x47,
	0x27,0x78,0xB2,0x32,0xC1,0x09,0x4F,0x56,0xBD,0x39,0xFC,0xF6,0x47,0x5D,0x57,0xF7,0x18,0x36,0x80,0xAF,
	0x07,0x51,0x50,0x9E,0x11,0xE8,0x49,0x36,0x32,0x77,0xBB,0xF2,0xCB,0x52,0xD8,0x36,0xED,0x03,0x6F,0xBE,
	0xFF,0xFC,0x5F,0xAF,0x59,0xE9,0xDE,0x98,0x45,0xE7,0xDB,0x67,0x35,0x03,0xDA,0xF0,0xEA,0xD4,0x22,0x01,
	0xE3,0x6D,0xDB,0x2D,0x00,0xF1,0x17,0x52,0xE9,0xAD,0x4F,0x0A,0xA4,0xC0,0x8B,0xB2,0x08,0x30,0xA9,0x43,
	0xA2,0x83,0x14,0x49,0x91,0x4F,0xBD,0xA9,0x46,0xDF,0x27,0x11,0xA4,0xB9,0xC6,0xFC,0x1E,0x2D,0xBB,0x77,
	0x21,0x3C,0x23,0x1B,0xE6,0x9F,0xF9,0x91,0x1A,0xA5,0x56,0x47,0xAB,0x4F,0x9F,0x05,0x9E,0x05,0xF5,0xE0,
	0x2E,0x54,0x7F,0x70,0xAD,0x96,0x3C,0xBD,0xC1,0x7A,0x1A,0xD9,0x37,0xB7,0x21,0xFE,0x37,0x79,0x57,0xB1,
	0xBD,0x1A,0xB8,0x0F,0x66,0xA1,0x29,0x70,0x6A,0xE2,0xB4,0xBC,0x0F,0x0A,0x5C,0x52,0x54,0xCD,0x3D,0x54,
	0x23,0x16,0x11,0xAC,0x58,0xBB,0xD0,0xC5,0x60,0xF5,0x8E,0xBF,0x84,0xA2,0x32,0xF7,0x0C,0x0D,0x5B,0xDF,
	0x6A,0x29,0x2B,0x17,0x27,0xF6,0x98,0x1B,0x01,0x91,0x0F,0x97,0xF0,0xC6,0xDC,0xFD,0xE5,0x25,0x41,0x85,
	0x35,0xA2,0xB2,0x0D,0x3C,0x2B,0x07,0x87,0xFE,0xFF,0x85,0x23,0xF8,0xBC,0x50,0x3D,0xD9,0xE3,0x58,0xAB,
	0x43,0xF5,0x50,0xF0,0xDA,0x1B,0x36,0xBC,0x73,0xAA,0xDF,0x8B,0xF9,0x6A,0xF5,0x1F,0xD1,0xF9,0xE2,0x3A,
	0x0A,0xE4,0xC2,0x24,0xC4,0xBE,0xE8,0x94,0x18,0x17,0x12,0xBB,0x43,0x62,0x9B,0x5C,0xAD,0xE2,0xFE,0xB1,
	0xE9,0x4D,0xAC,0x1E,0x88,0x6D,0x86,0xA1,0xA9,0x65,0xE1,0xB8,0x61,0xC9,0xEB,0x8C,0x05,0xB4,0x7F,0x1B,
	0xA3,0xFF,0xBD,0x33,0x43,0xCD,0xFB,0x8D,0x78,0xF7,0x74,0x75,0x55,0xB7,0x91,0x62,0x5C,0xA1,0x3F,0x3A,
	0x27,0xC6,0x06,0x4F,0x65,0x79,0x37,0x7E,0xD7,0x11,0x3B,0x97,0xA7,0xB7,0xAB,0xD1,0xD7,0x12,0x9C,0xBF,
	0x1A,0xCD,0xB3,0xFA,0xCD,0xF1,0xD2,0xBC,0xCB,0x35,0xEF,0xAF,0x61,0x68,0x8B,0x45,0xEA,0x7D,0xFE,0xAF,
	0x80,0xB4,0xEA,0xDC,0x26,0x6E,0x2E,0xB5,0x0E,0xD7,0xF5,0x58,0xAC,0xAE,0x80,0xDB,0x4C,0x50,0x5F,0xC6,
	0x21,0x89,0x57,0x32,0xD6,0x96,0xBD,0x9A,0x14,0xC8,0x95,0x8C,0xC8,0xBA,0x08,0x9C,0xF7,0xD7,0xBE,0xFA,
	0xFA,0xEB,0x4A,0x76,0x25,0x9E,0x52,0xCE,0xD3,0xC0,0x53,0x40,0xC3,0x3F,0xD0,0xA9,0xAD,0x4A,0xA5,0x55,
	0x32,0xD8,0x5E,0xDD,0x30,0x4B,0x4E,0x33,0xB6,0x90,0x28,0xC1,0x65,0xC5,0x9B,0xAF,0xE0,0xD0,0xFD,0x9A,
	0xAA,0x93,0x9D,0xD1,0x6A,0x1B,0x95,0x45,0xED,0xEB,0x4A,0x74,0xDC,0xD7,0x20,0xF1,0x30,0x88,0x2D,0x4B,
	0x79,0xAB,0x9B,0x5B,0x9B,0x23,0xA8,0xA4,0xBD,0xC3,0xBE,0xAB,0x05,0x60,0xC3,0xD5,0x81,0x9F,0xDB,0xE0,
	0xEA,0xE1,0x4C,0x2B,0x23,0x22,0xAC,0x0A,0x0A,0xBB,0x66,0x70,0x6E,0x99,0x52,0xA6,0x52,0x0A,0x1D,0x31,
	0xA8,0xDE,0x6E,0x21,0xE9,0x60,0x9D,0x52,0x92,0x4E,0x09,0x6B,0x44,0x5F,0x92,0x12,0x13,0x46,0x42,0x55,
	0xF8,0x2C,0xEA,0x93,0xEA,0x8E,0x3E,0x63,0xBA,0xA7,0x6F,0x00,0x94,0x23,0xFA,0xC5,0x0A,0xA0,0xCF,0xD6,
	0xA6,0xBE,0x84,0x86,0x8A,0xE4,0xDF,0xDA,0x38,0x91,0x04,0x8E,0xE4,0xF9,0x84,0x5F,0x35,0xA2,0xAE,0x9A,
	0x5A,0x8F,0xC0,0xA6,0x46,0x36,0x99,0xAF,0xE0,0x2F,0x70,0x74,0xFD,0x95,0x0A,0xD8,0x4B,0x1D,0x8A,0x85,
	0x2A,0x2A,0x2F,0x2E,0x70,0x05,0x07,0x58,0xBD,0x8A,0xBF,0x88,0xEF,0xAB,0xCA,0x36,0x51,0x1C,0x49,0x2B,
	0x90,0x23,0x69,0x4A,0xBF,0x0C,0x6B,0x97,0x09,0xE0,0xFA,0xCC,0x34,0x5B,0x4A,0x7D,0xCA,0x5F,0xA3,0x21,
	0x50,0xAE,0xBB,0xC6,0x92,0xC8,0x57,0x75,0x23,0xDC,0xFE,0x3E,0xC7,0x14,0x7F,0x82,0x84,0xC2,0x1E,0xF1,
	0xAA,0xB2,0xCF,0xCE,0x6B,0xAA,0xEC,0x29,0x8A,0xCE,0xF8,0x2E,0x65,0xB7,0x0E,0x10,0xFA,0x20,0xE3,0x98,
	0xE9,0xEE,0x8E,0x3B,0x76,0xA5,0xD5,0x32,0xC8,0xDC,0xE2,0x9E,0x83,0x18,0x97,0x57,0xEB,0x3F,0x6D,0xEE,
	0x88,0xE5,0x76,0x2E,0x11,0x85,0x7C,0x7D,0xFE,0xF8,0xA8,0xB8,0x80,0x1F,0xC6,0x44,0xBF,0xFC,0xB8,0xEF,
	0x8B,0x80,0x02,0x1F,0x85,0xEF,0xEE,0x36,0x96,0xFC,0xBD,0x28,0x0A,0x6D,0x4C,0x6E,0xFE,0x05,0xF2,0x95,
	0x8C,0x0C,0x4C,0x2A,0x3C,0x58,0xEE,0x97,0x4C,0xD4,0x3D,0xDA,0xCB,0x04,0x9A,0x9A,0x3D,0x64,0xB6,0x76,
	0x4D,0x39,0x99,0x31,0xEF,0x92,0xB5,0xF5,0xD0,0xDC,0xF5,0x3D,0xD4,0xFB,0x62,0x99,0x51,0xEB,0xC8,0xDE,
	0x7F,0xBF,0x2F,0x08,0xF7,0x32,0xFF,0x1D,0x2C,0x66,0x32,0xA1,0x44,0x85,0x7F,0x5F,0xFD,0xAB,0x0C,0x25,
	0xA6,0xDC,0xAE,0x2E,0x72,0xEA,0x77,0xF9,0x6E,0x1E,0xFB,0x7C,0x6B,0x65,0x14,0x2B,0xAE,0xAA,0x14,0xB8,
	0xA0,0x0C,0xF4,0xA3,0xB2,0xE8,0xB1,0xA6,0xBC,0x17,0xA2,0x6B,0xBE,0x25,0x54,0x45,0x03,0xCE,0x8B,0xCD,
	0x6C,0x8D,0x8F,0x8A,0xFA,0x8F,0x48,0x96,0xC4,0xBC,0x95,0xBF,0x3A,0xF6,0x9E,0xE7,0xCC,0xAD,0x85,0xD5,
	0xF0,0x57,0xBC,0x4E,0x33,0x8D,0x3E,0xA0,0xA0,0x24,0x75,0xCF,0x5B,0x4F,0xB9,0xCB,0xAE,0xA6,0x7A,0x09,
	0x7F,0xAE,0xB2,0x4E,0x0C,0x1A,0xFE,0xDF,0x49,0x51,0xF5,0xC9,0x14,0x87,0xDF,0xF6,0x9A,0x80,0xA9,0x43,
	0x6F,0xA2,0x37,0xAA,0xBD,0xAC,0x37,0xF4,0x8D,0x91,0xF9,0x1B,0x30,0xA9,0x33,0x83,0x4E,0xED,0xBE,0xA7,
	0x60,0x2A,0x17,0xBE,0xC6,0xD7,0x5D,0xE7,0x97,0x60,0xD5,0x65,0x2F,0x81,0x8C,0xE1,0x17,0x24,0x64,0x40,
	0xF1,0x08,0x3E,0x32,0x26,0x94,0x58,0xD8,0x40,0x76,0x49,0x33,0xF0,0xE0,0x51,0x66,0xB3,0xE0,0xF6,0x25,
	0x63,0xDA,0xF7,0xED,0xD4,0x96,0x14,0x8D,0xF1,0x61,0xBE,0x24,0x48,0x69,0x16,0x24,0x37,0xE3,0xF3,0x3A,
	0x55,0x21,0xE5,0x2A,0xED,0x5E,0x23,0x4A,0x1A,0x5C,0x6A,0x94,0xDF,0xB2,0xED,0xAE,0xD4,0xD4,0x61,0x23,
	0x95,0xE8,0x40,0x64,0x96,0xCE,0x4B,0xA0,0x0D,0xC2,0xFD,0x4E,0x92,0x5E,0xF8,0xCF,0xF8,0x0C,0x68,0xEF,
	0x27,0x22,0x74,0xD0,0x98,0xAC,0x8A,0xA5,0x85,0x19,0xAB,0x05,0x3D,0x12,0xB7,0xFF,0x1A,0x9B,0x1D,0xA4,
	0x40,0x63,0xB2,0x04,0x8A,0xC8,0xD9,0x70,0xC0,0x82,0x48,0x71,0x46,0x8B,0xD4,0x08,0xBD,0xEB,0x02,0x42,
	0x82,0x4A,0xEF,0x71,0x6D,0x2B,0x40,0x3A,0x80,0x31,0x78,0x22,0xA4,0x7B,0x2C,0xB0,0x04,0x81,0xD5,0x72,
	0x24,0xFE,0x19,0x9F,0x5C,0x75,0x4B,0x15,0xF7,0x72,0xD5,0x5A,0x6E,0x52,0xC3,0x2B,0x02,0xB7,0xE0,0x0D,
	0xD6,0x5A,0x18,0xAA,0xFC,0xA0,0x25,0x59,0x95,0xA3,0x04,0x48,0x5A,0xD1,0xB7,0x3B,0x14,0x70,0x9F,0x64,
	0x40,0x16,0x37,0x9A,0x91,0xD0,0x88,0x46,0x2F,0x99,0xD3,0x91,0x48,0x94,0xA1,0xCE,0x18,0x40,0x5D,0x43,
	0x34,0x4B,0x51,0xD0,0x0C,0xED,0x80,0x34,0x33,0xFC,0x54,0x34,0xFE,0x34,0x97,0x33,0x89,0x44,0x68,0x1B,
	0x38,0x00,0x3D,0x96,0xE3,0xC1,0xF8,0x20,0x01,0xB6,0xEC,0xEC,0x95,0x58,0xAE,0xCB,0x60,0x57,0xEF,0xAE,
	0x3C,0xFC,0xD7,0x40,0x21,0xDA,0x3A,0x72,0x2A,0x1A,0x63,0x5A,0x79,0x85,0xFA,0x3A,0x2A,0x8D,0xA2,0xB6,
	0x79,0x8B,0x84,0x81,0xAF,0x96,0x82,0xF5,0xE4,0x48,0x16,0x1E,0x24,0x5B,0x31,0xC7,0x8B,0xCC,0x16,0xFF,
	0x4B,0xCE,0x8B,0xE7,0xB1,0x56,0x6A,0xA1,0xA3,0x51,0xC4,0x42,0x00,0x25,0x05,0x12,0xAC,0x72,0xF3,0x34,
	0xAB,0xBB,0xAE,0x19,0x9D,0xE3,0xA0,0xEB,0xA0,0x97,0x52,0x3B,0xAA,0x3A,0xE3,0xFA,0x53,0x86,0xED,0x7B,
	0xE5,0x3D,0x5F,0x85,0xCF,0xFE,0x1B,0x32,0xC5,0x44,0xAB,0x34,0xD6,0xC5,0xB2,0xF4,0xFD,0xEE,0x4B,0x22,
	0xAC,0xD2,0xF1,0x2F,0x96,0x5F,0xE1,0xC9,0xB5,0x52,0x95,0x0D,0x9F,0x44,0xD4,0x2D,0x34,0xF5,0x19,0xB8,
	0x72,0x47,0x17,0xB2,0xBC,0x3A,0x40,0x04,0x5A,0x5F,0xCD,0x6E,0xCD,0x17,0xA7,0x5F,0xDD,0x9D,0x67,0x33,
	0x5C,0xE1,0x57,0x38,0x90,0xA7,0x00,0x1C,0x75,0x57,0x69,0x29,0xF8,0xF8,0x6F,0x7D,0x20,0x67,0xDD,0xA4,
	0x2E,0x14,0xAD,0xC1,0xBE,0xB6,0x1C,0x9C,0x47,0xED,0x7F,0xEE,0x51,0xF4,0x5D,0xF1,0xCE,0x96,0xF0,0xEE,
	0x10,0x08,0xA3,0x53,0xD3,0x7F,0xCA,0x7A,0x77,0xF7,0x04,0xEA,0xCF,0x88,0xFF,0xEE,0x04,0xF8,0x3A,0xFA,
	0x0D,0x3C,0x75,0x6F,0xE3,0x2F,0x66,0x3A,0x71,0x2A,0xF4,0x3C,0x7A,0xE3,0xA8,0x4B,0xC4,0x7B,0x6B,0xAE,
	0x56,0x0E,0x9F,0x03,0xB4,0xA2,0xA6,0x82,0x3F,0x75,0x21,0x0F,0xC2,0x1C,0x8A,0x11,0xF0,0x77,0x01,0x55,
	0x1E,0xE0,0xFF,0x51,0x24,0x09,0x29,0x49,0x5F,0x2E,0x30,0x84,0x18,0xDD,0x15,0x42,0xFF,0x92,0x5B,0x17,
	0x39,0xFB,0x42,0x3F,0x82,0x62,0xA7,0x21,0x43,0xA2,0xEA,0xD2,0xA0,0xF4,0x61,0xE7,0xFE,0xDE,0xC2,0x08,
	0x45,0x42,0x9B,0xCE,0xE4,0x0B,0xC2,0xA7,0xD3,0xDD,0xCD,0x20,0xE6,0xB8,0x3D,0xC6,0x13,0xCF,0x44,0xD9,
	0x7D,0x8C,0xEE,0x0E,0xAE,0xB9,0xE4,0xFD,0x3B,0x8A,0x44,0x3C,0x9E,0xCB,0x38,0xF2,0xA8,0x1C,0x75,0x91,
	0xB9,0xB2,0x7A,0xBC,0xF0,0xFF,0x80,0xF0,0xDD,0x81,0xC8,0xFD,0x3B,0xAC,0x12,0x1A,0x9A,0xE5,0xA6,0x24,
	0x54,0x55,0x08,0x9D,0x76,0x53,0x57,0x2A,0x1B,0x1D,0x28,0x73,0x40,0xAC,0xE2,0xE0,0xFF,0x27,0xC6,0xA2,
	0xBD,0x1C,0x45,0x86,0x03,0x77,0x57,0xC8,0x39,0xBE,0xBE,0xDE,0x77,0x85,0x72,0x5D,0xED,0x4D,0xEE,0x28,
	0xDA,0xB6,0xEF,0x4C,0xBC,0x5D,0xB1,0xAF,0xF6,0x43,0xE0,0x6F,0x88,0x7C,0x58,0x7D,0x9F,0x64,0xBF,0x49,
	0xB5,0xEF,0x75,0xD1,0xFC,0x56,0x17,0xAD,0xF6,0x1B,0x39,0xEE,0xC6,0x59,0x21,0xFD,0x2B,0xA8,0x39,0xFD,
	0x74,0x9F,0x9C,0x5A,0xD4,0x29,0x3B,0xC8,0x99,0xA5,0x7D,0xC3,0x71,0x3F,0xAB,0x24,0x44,0x11,0xED,0x9E,
	0xA0,0x75,0xF1,0x96,0x1A,0x85,0x3B,0x5F,0xBB,0x21,0x52,0x41,0x45,0xDC,0xF4,0x17,0x6D,0x97,0x18,0x0A,
	0xC1,0x88,0xA9,0xF0,0x8F,0x88,0x25,0x88,0x21,0x86,0x7A,0x60,0x5A,0x70,0x2E,0x5C,0x69,0x0C,0x55,0xBF,
	0x84,0xDA,0x70,0xD2,0xC0,0xC2,0xA3,0x6B,0x50,0x2F,0x23,0x84,0xAE,0x16,0xD0,0xFF,0xA4,0xD6,0xE9,0x1E,
	0xD5,0x8A,0x61,0xA9,0xAC,0x99,0xF8,0xEA,0xEC,0x1F,0xEF,0x17,0x4C,0x1C,0x91,0x2D,0xE5,0x21,0x98,0xA0,
	0x9A,0x16,0x42,0x90,0x61,0x65,0x07,0x8E,0x8E,0xB4,0xA0,0x01,0x2B,0xC9,0xB9,0xBF,0x70,0x1C,0xF6,0x85,
	0xCA,0x75,0xBB,0x0A,0x9C,0x65,0x22,0x2D,0xFF,0xBF,0xC8,0x4A,0xEB,0x2C,0xEA,0x1D,0x0C,0x48,0xA3,0x5A,
	0xBD,0xC3,0x96,0x8D,0xC0,0x22,0x2D,0xB9,0xDA,0x97,0x11,0x95,0xBB,0x99,0x7E,0xF6,0x4D,0x51,0x0A,0xCB,
	0x71,0xA4,0x7D,0x91,0x8E,0x6D,0x62,0xC7,0xFB,0x1A,0x2B,0x88,0xF6,0x54,0x54,0x68,0xB4,0xAD,0x4B,0x3E,
	0xBE,0x4E,0xD7,0x9B,0x8E,0xB9,0x1D,0x0E,0xF1,0xB9,0x7D,0x9E,0xF2,0xEA,0x82,0x40,0x16,0x96,0x90,0xFD,
	0xAB,0xE3,0x56,0x3D,0xD2,0xDF,0x7A,0x0A,0xDF,0x4E,0x9D,0x81,0x79,0x69,0x9B,0xFE,0x44,0x9B,0x6E,0xDC,
	0x64,0xA3,0x32,0x23,0x29,0xC8,0x6D,0x28,0x35,0x00,0x2E,0x3D,0x27,0xC2,0x02,0x37,0xAA,0xEA,0x48,0x2E,
	0x3C,0xF3,0x82,0x1C,0x5E,0xF6,0x2E,0xA7,0xB8,0x24,0xCB,0xEE,0x3F,0x7C,0x15,0x5B,0x2E,0x7F,0xF1,0x51,
	0x0D,0x33,0x12,0x25,0xB6,0x8E,0xF3,0x9F,0x85,0x59,0xCA,0x93,0x47,0x4D,0x9A,0x79,0xF3,0x4B,0xFA,0x6B,
	0xC5,0xF6,0xFE,0x9D,0xE2,0xA9,0x9A,0x03,0x00,0xD6,0xEF,0x5F,0x37,0x2A,0x76,0xE4,0xEE,0x6B,0x8C,0xB2,
	0x65,0xDB,0x4F,0x92,0x5F,0x20,0x38,0x3E,0xF7,0x81,0x59,0x1B,0xE9,0xB6,0xDE,0xB1,0xF4,0x9F,0x9F,0x7D,
	0x83,0xB9,0x2A,0xEA,0xB0,0x37,0x9C,0xF3,0xAF,0x5A,0x7A,0x64,0x85,0x68,0xF3,0x3F,0x6F,0xBA,0xAE,0x94,
	0xF0,0xDE,0x7F,0x49,0x2E,0x17,0xF6,0xDC,0xB3,0x8D,0xDA,0xD9,0x9A,0x19,0x7D,0x99,0x86,0xD4,0x06,0x68,
	0x5F,0xAD,0x05,0x2E,0xC5,0xAB,0x3A,0x2B,0x49,0x52,0x8B,0x90,0x91,0x7E,0x0E,0x46,0x28,0xB6,0x26,0x71,
	0x3F,0x95,0x45,0x26,0x4B,0x64,0x56,0x17,0xAA,0xAD,0xDD,0xD0,0x57,0x2E,0x84,0x29,0x9A,0x7A,0x66,0x40,
	0x2B,0x38,0xFE,0x15,0x70,0xFF,0xFF,0x8A,0x6C,0xB1,0x5B,0x6B,0xF6,0x68,0x99,0xC8,0xB2,0x01,0x89,0x99,
	0xE1,0xAA,0xED,0xBF,0x92,0xF9,0xFD,0x03,0x83,0xA1,0xC1,0x8F,0xAE,0x3E,0xF7,0x2C,0x58,0xDD,0xD6,0xCB,
	0xF3,0x5D,0x75,0x4C,0xCC,0xA5,0x1E,0x53,0xEF,0xA8,0xA0,0x19,0x03,0x06,0xE4,0xB8,0x13,0x85,0x56,0xB7,
	0xA8,0xBB,0x6E,0x25,0x8B,0xCA,0xAB,0x72,0x9C,0xC5,0x1E,0x87,0xE4,0x7D,0x0A,0xBA,0xCA,0x1C,0xFA,0xB1,
	0xC1,0x4A,0xAB,0xCE,0xB7,0x4F,0xA4,0x9B,0xFF,0x65,0x55,0x25,0x4E,0x86,0x91,0x42,0x93,0x6D,0x6D,0x37,
	0x7D,0x7D,0x03,0x57,0x3F,0x3C,0xFE,0x4B,0xFA,0x77,0x4C,0xF0,0xBE,0xF4,0xDD,0xEA,0x9C,0xBD,0x63,0xE2,
	0x22,0x51,0x2C,0x8E,0xBC,0x2E,0xFA,0x1F,0xC1,0xAF,0x78,0x0D,0x6B,0x33,0x15,0x8D,0x16,0x72,0x6A,0x58,
	0x25,0x58,0x5C,0x21,0xC2,0xCE,0xAA,0x2C,0x6C,0xF5,0x54,0x9F,0xC2,0x8A,0x0A,0x28,0x3F,0xB2,0x00,0xF8,
	0x9D,0xDC,0x65,0xA1,0x40,0x12,0x5C,0x7B,0x25,0x9F,0x22,0xC0,0xFB,0x74,0xEA,0x3E,0x7E,0xC8,0xEC,0x30,
	0x06,0x6B,0x6F,0x2E,0x26,0xAB,0xAF,0x0A,0xDB,0xBC,0x11,0x3F,0x46,0x09,0xAD,0x62,0x07,0x04,0x9D,0x6C,
	0x19,0xB0,0x59,0xEA,0xAC,0x7B,0x92,0x6A,0x95,0x6D,0x7D,0xD5,0xEF,0x43,0x45,0x98,0x03,0xB4,0x89,0x4E,
	0x40,0x92,0x10,0x80,0x9E,0x93,0xF4,0xEC,0x41,0xAA,0xAE,0x54,0xAF,0xAF,0x55,0xA0,0xF7,0x3F,0xB2,0xEB,
	0x74,0x95,0x24,0x5C,0x16,0x47,0x2D,0x3B,0xE8,0x36,0x05,0x1D,0x40,0x48,0x72,0x12,0xC3,0x0F,0x62,0x4E,
	0x0A,0x67,0x4B,0x15,0xE5,0x6D,0x19,0x6C,0xDD,0x4E,0xD7,0xED,0x72,0x0E,0x50,0x55,0x17,0x99,0x5A,0xE9,
	0x0F,0x44,0x5A,0x27,0x68,0x55,0x1D,0x1A,0x56,0x0A,0x17,0xC5,0xD8,0x92,0xCB,0x66,0xED,0xAF,0x60,0xCC,
	0xDD,0x6C,0xA9,0xAF,0x5F,0x7E,0xCC,0x7D,0xEE,0x1C,0x6D,0x34,0x18,0x83,0x73,0x8B,0x3D,0x88,0x00,0xD7,
	0xC5,0x65,0x25,0xF9,0xF4,0x27,0xAE,0x59,0xDC,0xE4,0x04,0x52,0x09,0x4B,0xE0,0xC5,0x67,0x1C,0xEB,0xBD,
	0xAE,0xAA,0x5E,0x15,0xB6,0x14,0xED,0x42,0xBD,0x86,0x80,0x17,0xA8,0xF5,0xD5,0xF3,0xD4,0xEB,0x16,0x4B,
	0xFC,0xB8,0x23,0xCB,0x5E,0x06,0xDD,0xB4,0xE5,0xE8,0x90,0xD5,0xBA,0xBA,0x52,0xD4,0x91,0xC4,0xB9,0x46,
	0x3B,0x41,0xC1,0x5F,0x7B,0x96,0xC8,0x5F,0xC4,0xCC,0x07,0x3A,0x7E,0x2C,0x0E,0xEE,0xAA,0x36,0x60,0x0D,
	0x5D,0xD5,0xE2,0x1A,0x65,0x9F,0x9F,0x1E,0x28,0x00,0xB9,0x7D,0x93,0x34,0xE2,0x84,0x61,0x61,0x89,0xBA,
	0xD2,0x62,0x2E,0x6D,0x95,0x76,0x8C,0xEF,0x4F,0x19,0x99,0x01,0xBA,0x44,0x11,0x8E,0xEA,0xB7,0xD7,0x8B,
	0x0A,0x84,0xA2,0x01,0x3E,0x1A,0x0D,0x47,0x92,0xA6,0x37,0xA2,0x7C,0x5F,0x2D,0xAF,0x0D,0xC7,0x00,0x16,
	0x94,0xCF,0x77,0x4A,0xC4,0xE0,0xF7,0xE6,0x2B,0x5D,0xCF,0xD6,0x67,0x6E,0xA0,0xAB,0x9E,0xAA,0x1C,0xD0,
	0x75,0x46,0xE2,0x43,0x9B,0xAF,0xA2,0xB1,0x46,0x2A,0x20,0xE3,0x0D,0xF8,0xC6,0x8A,0xD2,0xE3,0xBA,0xC6,
	0xAE,0x85,0xC7,0x0C,0x00,0x5C,0xA0,0x30,0x4D,0x2B,0xEF,0x85,0xC0,0x3A,0xF0,0x36,0xB0,0x23,0xD6,0x57,
	0x8A,0x14,0x56,0x30,0xB5,0x20,0x3F,0x2C,0xDA,0x9F,0xAA,0x89,0x5D,0xE2,0xE8,0xBA,0xA3,0x48,0x14,0x49,
	0x76,0x9A,0x85,0xE4,0x5D,0xC9,0x99,0x7F,0x89,0xDD,0x27,0x2F,0x1B,0xB5,0x80,0x49,0xD7,0x11,0x20,0x7E,
	0x26,0x53,0xA3,0x42,0x63,0x8F,0x8D,0x56,0xCD,0x95,0x77,0x89,0x5D,0x08,0x58,0xB5,0xAD,0xD6,0x2A,0xE7,
	0x17,0x24,0x9F,0xA1,0xEF,0xBA,0xC6,0x27,0x42,0x0B,0xC9,0xB2,0xCB,0x17,0x51,0xFF,0x87,0xC6,0x94,0xDA,
	0x64,0xDA,0x58,0xB4,0x20,0xD2,0x14,0xCC,0x69,0x99,0x60,0x85,0xD4,0xE4,0x0E,0x1D,0xC6,0x94,0x5C,0x81,
	0x1D,0x51,0x2A,0x8E,0xD1,0x83,0x02,0x76,0x14,0xED,0xD8,0xDD,0xD7,0xF1,0xC4,0x2C,0x78,0xE7,0xAB,0xEC,
	0x72,0xC4,0x86,0x81,0x06,0xFC,0x81,0xF9,0xB7,0xB7,0xD5,0xFC,0x6B,0xBC,0xBF,0xDB,0x19,0x28,0x3D,0x05,
	0x0B,0xEF,0xAE,0x01,0xA6,0x75,0x24,0x46,0x86,0x5B,0x70,0x64,0x57,0x86,0xCD,0xC3,0x11,0xA0,0x8D,0xFE,
	0xDF,0x1E,0xC3,0xFB,0xC1,0x68,0x17,0x15,0x36,0xD7,0x6D,0x2F,0x1C,0xB1,0x27,0xF7,0xDB,0xD9,0x40,0x61,
	0x46,0xBE,0x35,0x30,0xEC,0x57,0x3A,0xED,0xEA,0xA2,0x40,0xE7,0x5F,0xE9,0x6D,0xA7,0x12,0x7C,0x9D,0x23,
	0xC2,0xD0,0x21,0x05,0xAD,0x37,0xBA,0x5F,0xAA,0x80,0xA3,0x12,0x20,0xF6,0x9C,0x24,0x57,0x8D,0xE7,0x48,
	0x48,0x51,0x71,0xE7,0x94,0xCB,0x35,0x0B,0x27,0x24,0x2D,0x63,0xE3,0x24,0x6D,0xED,0x2A,0xBC,0x98,0xED,
	0x45,0xA0,0x57,0x5C,0x3D,0xDD,0xC9,0x34,0x70,0x2B,0xEE,0xED,0xCA,0xDA,0xEB,0x48,0xBE,0x92,0x5F,0x29,
	0xF7,0x76,0xBD,0x7B,0xEF,0x2A,0x21,0x72,0xAA,0xDC,0x58,0x37,0x37,0xFF,0x9E,0xF5,0xBB,0xCC,0xE2,0x56,
	0x77,0xF3,0x97,0x4E,0x97,0xEE,0xD5,0x71,0x74,0xAD,0x2F,0xFC,0xA5,0x7C,0xFE,0x77,0x16,0xC7,0xE1,0xC8,
	0x35,0x7D,0xC0,0xAA,0xA8,0xFD,0xFA,0xA8,0xC5,0x89,0xAF,0x3A,0x18,0xC7,0x57,0x05,0xF2,0xEC,0x51,0x46,
	0x57,0xED,0x13,0x67,0xEC,0x1B,0x46,0x86,0x76,0xF7,0x7B,0x8A,0x0D,0x70,0xEE,0x11,0xAF,0x8F,0x6A,0x08,
	0x75,0x85,0x0E,0x31,0x0C,0x1B,0x33,0x8E,0xDE,0x78,0x02,0x62,0x82,0xA8,0x30,0x40,0x8D,0x21,0xC1,0xA5,
	0x04,0x56,0x67,0x5E,0x23,0x99,0x77,0x9F,0xE8,0xA2,0xF1,0x8E,0xB5,0xD7,0xFE,0x81,0x86,0xF7,0x25,0x91,
	0x9C,0xF8,0x3A,0xE0,0x41,0x6E,0xD5,0xD5,0x6C,0x3B,0x39,0x10,0x83,0x6C,0xD2,0x5D,0xF1,0xB4,0xCD,0xE9,
	0xE9,0xBB,0xA8,0x02,0x83,0xAE,0xF0,0x11,0x76,0x87,0xBA,0x53,0xAF,0x6F,0xD7,0x90,0x94,0x83,0xF9,0xC2,
	0xAA,0xFE,0xAA,0x40,0xCB,0xFD,0xDF,0xDC,0x18,0x02,0xAA,0xC1,0xD0,0xCB,0xBE,0x21,0x20,0x86,0x80,0x41,
	0x44,0x5F,0x02,0x62,0x08,0x88,0x2E,0x29,0x14,0x1F,0x6D,0x44,0xE3,0x09,0x19,0xCA,0x8E,0x28,0xB8,0xAA,
	0xC6,0x05,0x8F,0xED,0x63,0x0D,0x00,0xC6,0x6D,0x69,0xD5,0xED,0x66,0x14,0x23,0xEB,0x87,0x49,0x05,0x75,
	0xC9,0x05,0x90,0xCC,0x25,0x0B,0x56,0x2C,0x90,0x71,0x49,0x3F,0xFE,0x5F,0x0D,0xFC,0x3F,0xA8,0x7A,0x17,
	0xCE,0x28,0x72,0xF5,0x41,0xFE,0x5F,0x28,0x45,0x2C,0xFF,0x97,0x60,0xD6,0xB8,0x37,0x2A,0xFB,0xAC,0x7B,
	0xC3,0xF4,0x4D,0x87,0xA6,0x91,0xD0,0x9D,0xDF,0x9D,0x97,0x95,0xC5,0x06,0x7D,0x6F,0x34,0xCC,0x72,0x75,
	0x2C,0x26,0xD6,0x91,0xCC,0xEE,0xAE,0x1F,0x81,0xD7,0xC0,0x60,0xE8,0x12,0xDE,0xA3,0x71,0xFE,0x72,0x81,
	0xB9,0xA8,0x50,0x55,0x85,0x0C,0x33,0x03,0xD6,0x5B,0x78,0x7B,0x14,0x0A,0xB0,0x54,0x52,0x1A,0x21,0x16,
	0x90,0xE8,0xFF,0x26,0x2C,0x6E,0x09,0xB2,0x07,0x00,0x0E,0x0B,0x8E,0x61,0x69,0x15,0xA5,0xCC,0x5B,0x58,
	0xA3,0x59,0x04,0x58,0x73,0x39,0x27,0x90,0xC5,0x6F,0xDB,0x3A,0x60,0x11,0x44,0x7B,0x57,0xB9,0x37,0xDD,
	0x85,0x24,0x6E,0x4E,0xC3,0x75,0x16,0x45,0xC4,0xE7,0xD1,0x38,0x04,0xFC,0xAC,0xCB,0x25,0xAE,0x35,0x5B,
	0xB0,0xDA,0x84,0xBD,0x8A,0x95,0xB1,0x08,0xD7,0x4F,0xFA,0x20,0xFE,0xFB,0x84,0xB3,0x26,0x36,0x48,0xF5,
	0x2A,0xCC,0x06,0x60,0xEB,0xA2,0xFC,0xBB,0x82,0xD9,0x88,0xC5,0x26,0x47,0x88,0x9C,0x75,0x85,0x71,0xC1,
	0xC1,0xDC,0x4D,0x95,0xB3,0xF3,0x27,0x81,0x4E,0x0F,0x8E,0xD9,0xFF,0x88,0x59,0x2D,0x8E,0xBA,0x6A,0x9D,
	0xC2,0x2D,0xE7,0xE5,0x56,0xA5,0xB8,0x25,0xBC,0x30,0x46,0x48,0x9C,0xD9,0xA8,0xC2,0xB8,0xD6,0x87,0xBF,
	0x51,0x03,0x80,0x98,0xE9,0x99,0x92,0x07,0x78,0x24,0x75,0xEF,0xEB,0xB0,0xB9,0xB3,0x30,0x36,0x61,0xD7,
	0xE4,0xCD,0x39,0xAF,0x24,0x30,0xE8,0x67,0x16,0x2F,0x0A,0xD2,0x98,0x01,0x50,0xBB,0x15,0x65,0x4D,0x72,
	0x1A,0xE6,0x4E,0x07,0x01,0x01,0x87,0x7A,0x3D,0x9D,0x12,0x42,0x06,0x3D,0xD8,0x87,0xFD,0xA1,0x91,0x6D,
	0xA8,0x77,0x27,0x2C,0x48,0x6F,0xC9,0x77,0x21,0x40,0x0A,0x39,0x8D,0x7C,0x1C,0x4B,0x9C,0x6D,0x37,0x45,
	0x4C,0xDC,0xFF,0x7E,0x8A,0xE8,0x06,0x9E,0x54,0x48,0x3C,0x17,0x89,0x53,0xA5,0x4B,0xC1,0x7D,0x17,0xAC,
	0x3E,0x1B,0xF3,0xFE,0x42,0x8F,0x27,0x61,0x20,0x7D,0x4C,0x31,0x9B,0xC7,0xE1,0x1A,0x28,0x8C,0xC1,0x84,
	0xBE,0x32,0x11,0xAB,0xF7,0x99,0x99,0xF3,0xCA,0xB4,0x81,0x6D,0x0D,0x2B,0x90,0x83,0x3D,0xA9,0x3B,0x1C,
	0x31,0x19,0x31,0xCA,0x92,0x5B,0xA1,0x62,0xAD,0xBA,0x1A,0x91,0x11,0xB6,0xFB,0xCD,0xEB,0x04,0xE9,0x18,
	0xBF,0x93,0xF4,0xAE,0x9A,0x48,0x6D,0x1A,0x7E,0xB3,0x71,0x5C,0x05,0x86,0x05,0x8B,0x8C,0x75,0x6F,0xAD,
	0x43,0xAA,0x4B,0x63,0x07,0xF3,0x72,0xB0,0x0E,0x2B,0x99,0xCF,0x26,0x56,0xDA,0x45,0x15,0xC5,0x72,0x94,
	0xCB,0xE6,0xFE,0x63,0x41,0x18,0x57,0x0E,0x78,0x5F,0xA8,0x1D,0x2B,0x3C,0xBF,0x47,0x1F,0xB0,0x22,0xE6,
	0x3E,0x77,0x79,0x3E,0x41,0x7E,0x5B,0x1F,0x07,0xDB,0x8B,0xAD,0xF3,0x19,0x6B,0xCC,0xF2,0x06,0x31,0x01,
	0xCC,0x3A,0x49,0x42,0x00,0xC5,0x04,0x43,0x39,0x83,0x84,0x81,0xAC,0x76,0xDE,0xEF,0xE4,0xC8,0xCC,0x34,
	0x19,0x25,0xEE,0xE4,0x34,0xEB,0x70,0x64,0x22,0x98,0xC2,0x5B,0xA4,0xFC,0xE9,0x5B,0xF8,0xB6,0xEA,0xAA,
	0x16,0xE4,0x44,0x54,0xD9,0xB8,0xB6,0x81,0xA1,0xD7,0x33,0x44,0x2D,0x01,0x9A,0xED,0x29,0xC3,0x11,0xD8,
	0xF2,0x9B,0x97,0x6A,0x37,0x04,0x9B,0x6A,0xC6,0x31,0xEF,0x9F,0xB0,0xE1,0x5D,0x17,0x48,0xF5,0xAF,0xFA,
	0x62,0x55,0x6D,0x64,0x89,0xA2,0xE6,0x24,0x39,0x19,0x2F,0x37,0x6E,0x30,0xCF,0x95,0xE7,0xC0,0xCD,0x77,
	0x10,0xE4,0x80,0x79,0x62,0x08,0x08,0x8A,0xB2,0x64,0x77,0x03,0x18,0x36,0x28,0x2E,0xA2,0x79,0x69,0xBE,
	0xFB,0x8E,0xF0,0xD5,0x1B,0x4C,0x4A,0xD6,0x4C,0x00,0xFB,0x8A,0xD8,0xD5,0x64,0xB9,0x1A,0xEF,0x62,0xD3,
	0xAD,0x5B,0x77,0x50,0x97,0xB5,0x97,0x26,0x1A,0x6C,0x3C,0x2A,0x1D,0x5C,0x0E,0xFF,0x05,0x71,0x79,0x7F,
	0x31,0xCB,0x7F,0x1C,0x3B,0x3A,0x07,0xCF,0xE1,0xFC,0x82,0x4D,0x72,0xF4,0x11,0x88,0x98,0x30,0xFF,0x19,
	0xEC,0x89,0xAD,0x60,0x66,0xEA,0xAB,0x86,0xE0,0x0F,0xCA,0x8C,0x0D,0x45,0x2A,0x2C,0x89,0x54,0x5F,0x55,
	0xB7,0x86,0xCF,0x09,0xF5,0xAE,0xB7,0xB8,0x4D,0x84,0x50,0x7D,0x55,0x70,0xE1,0xB1,0xB8,0xAE,0x53,0x42,
	0xA9,0x5C,0x18,0x38,0x00,0x4C,0x61,0x99,0xF9,0xA4,0x0A,0xC0,0x78,0xD4,0xE5,0x45,0xC7,0x7E,0xC7,0x36,
	0x56,0x06,0x23,0x50,0xBB,0x7C,0x27,0x3E,0xCA,0x28,0xCB,0x4D,0x54,0xB0,0xF4,0xED,0x2A,0x35,0xE2,0xA8,
	0xAE,0x0A,0x52,0xF3,0xAD,0xD5,0x22,0xDE,0x6D,0x08,0x16,0x13,0x6D,0x1F,0x46,0x15,0x98,0xE8,0x20,0x21,
	0xCE,0x69,0x7D,0xF9,0xAF,0xC9,0xAA,0xAB,0x68,0xED,0x23,0xD5,0x83,0x84,0xC0,0x43,0x05,0xD0,0x46,0x6E,
	0x54,0x59,0xD1,0x23,0xB4,0x2E,0xEF,0x7A,0xFF,0xFE,0x70,0x5D,0x3D,0x67,0xC8,0x2C,0xF4,0x70,0xCB,0x51,
	0x0B,0xA2,0xE3,0x44,0x9E,0xC9,0x35,0xE9,0x59,0x7D,0x35,0x25,0x6A,0xB6,0x05,0x12,0x11,0x92,0x95,0x3C,
	0x57,0xEB,0xC0,0xC4,0xB0,0xC5,0x17,0x0A,0xC4,0xD8,0xC5,0xE6,0x5A,0x9B,0xF6,0xC3,0x6B,0x27,0xF6,0xFF,
	0xAC,0x3D,0xC8,0x2A,0xDD,0xCC,0x30,0x2B,0xB9,0xB6,0x66,0x15,0x2D,0x4A,0xD5,0xA4,0x05,0xCD,0x43,0xA5,
	0x9B,0xAC,0x83,0x75,0xA8,0x01,0x8F,0x4B,0x16,0x6F,0xAA,0x70,0xE5,0x0D,0x39,0xE7,0x4C,0x43,0x09,0xA2,
	0xF3,0xE9,0x54,0x68,0xC2,0x06,0x58,0x97,0xE0,0x64,0x93,0x33,0x3A,0x0F,0x43,0xEF,0x95,0xA5,0x1B,0x35,
	0xE0,0xA8,0x66,0x56,0x07,0x51,0x69,0x03,0x31,0xB5,0xC1,0x64,0x33,0x1D,0x8B,0xA4,0xAD,0xEA,0x62,0x8C,
	0x69,0x13,0x18,0xBE,0x39,0xB9,0x42,0xC2,0xD3,0xB7,0x4D,0xA6,0xA1,0x94,0x79,0xD8,0x2A,0x14,0x7C,0x31,
	0x33,0x6D,0x09,0xBC,0x02,0xDE,0x55,0xD1,0xF2,0xDD,0x52,0x2E,0x0C,0xC4,0xB3,0x62,0xE6,0x00,0x36,0x54,
	0x9B,0x50,0xDB,0x8D,0xE8,0x0A,0x8F,0xB1,0xE0,0x87,0x0D,0x14,0xB0,0xC2,0x89,0x25,0xC1,0xD5,0xBC,0xE1,
	0x6A,0x98,0x23,0xD6,0xEC,0x82,0x30,0x39,0xB4,0xEF,0xAF,0xD0,0x7A,0xC2,0x8C,0xF1,0x92,0x55,0x92,0x35,
	0x64,0xAF,0xEC,0xA0,0xEA,0xF1,0x6B,0x2B,0x2C,0xF4,0xD4,0xD3,0x16,0xE9,0x84,0xC8,0xAC,0x6F,0x10,0x2B,
	0x23,0x5F,0x4C,0x21,0xFB,0x22,0x12,0x44,0x25,0x98,0x31,0x46,0xA4,0x30,0xE2,0xCA,0xDD,0x95,0xAD,0x88,
	0xAF,0x3E,0x22,0x5D,0x83,0x7E,0x8F,0x21,0xC4,0xC3,0xFF,0x4B,0xA1,0x3D,0x93,0xB1,0xC9,0x1B,0x4D,0x9D,
	0x01,0xCE,0xFE,0xEB,0xA4,0x96,0xD1,0x8F,0x7A,0x6A,0x06,0x77,0xAA,0x74,0x57,0xF6,0x00,0x5F,0xAB,0x5D,
	0x4F,0xCB,0x65,0x51,0x45,0xA6,0x46,0x31,0x51,0x2B,0x96,0x4F,0xB1,0x37,0x20,0x01,0x6D,0x12,0x23,0x37,
	0x51,0x0E,0xD4,0xDF,0xBD,0x1D,0x38,0x02,0x03,0xCF,0xB0,0xC0,0x8C,0xD3,0xDA,0xAB,0x49,0xE7,0x57,0x94,
	0x9F,0x93,0x8D,0xB2,0x45,0x83,0xD5,0xA9,0x80,0xA6,0x60,0xBF,0xDA,0x81,0xA1,0x07,0xB4,0x6B,0xFE,0x7F,
	0x05,0x4F,0xDF,0xA3,0xDA,0x27,0x4D,0x31,0x41,0xE0,0xF4,0x5A,0x50,0xFE,0x45,0x65,0x52,0xDC,0x95,0x43,
	0x00,0x8A,0x47,0xA9,0xAB,0xEB,0xBB,0x4A,0x79,0x57,0xB5,0x58,0xEB,0x62,0x36,0x4F,0x3A,0xD8,0xF6,0x83,
	0x93,0x42,0xAE,0x49,0x54,0x51,0x57,0xA9,0x91,0x6F,0x1E,0x27,0x72,0xBC,0x5B,0xF1,0xD7,0xB1,0x52,0xBD,
	0x8B,0x47,0x87,0x05,0x66,0x5D,0x05,0x4B,0xCF,0x21,0x2A,0x22,0x59,0x5E,0x53,0x0A,0x2C,0x20,0xD4,0xD3,
	0x60,0x62,0x6B,0x09,0x99,0x82,0x56,0x17,0xDD,0xE1,0x79,0x0C,0x61,0x5D,0xFB,0x55,0x99,0xE6,0x6A,0x0F,
	0x49,0x1B,0x58,0xF4,0x97,0x79,0x19,0xFB,0x72,0x24,0x46,0x11,0xFF,0x78,0x25,0xD2,0x0C,0xF8,0x62,0x99,
	0xA9,0x3A,0xFF,0xA6,0x62,0x84,0x2C,0x01,0xA3,0x52,0xA1,0xF5,0x8E,0x04,0xAE,0x85,0xBD,0xB7,0x88,0x53,
	0xB8,0x47,0x87,0x17,0xB7,0xA2,0x76,0xB0,0xEB,0x9A,0x2C,0xE8,0x72,0xE4,0xBB,0x17,0x6C,0x3F,0x45,0x9A,
	0xA6,0xE0,0x2E,0x80,0x61,0x1F,0x83,0xF6,0xE0,0x1C,0x2C,0x6C,0x4A,0xC6,0x11,0x4B,0x64,0x94,0x2E,0x57,
	0x2C,0xB4,0xD5,0xDC,0x6D,0x1A,0x04,0x49,0x6E,0xDF,0x4E,0x96,0x00,0x5A,0xC4,0xBF,0x72,0x6D,0xB7,0x4C,
	0x90,0x90,0x1D,0x65,0xA0,0x81,0x88,0xDC,0xDF,0x60,0x91,0xDA,0x0A,0x55,0x75,0x10,0xF9,0x7E,0xCB,0x82,
	0x22,0xFE,0xAB,0x4A,0x60,0xFE,0xAB,0xE2,0x47,0x2E,0x09,0xF0,0xA7,0x89,0x55,0x3E,0x5E,0xA1,0x3A,0x04,
	0xEA,0xD2,0xA9,0xEF,0x2E,0xBC,0x6A,0xB0,0x72,0xD2,0xE2,0x03,0xC5,0xFC,0x5F,0xFE,0xDC,0xE0,0xF5,0x88,
	0xEB,0x08,0x7A,0xED,0xA2,0x15,0x96,0xA4,0x48,0x22,0xEC,0xD4,0x89,0xFB,0xEB,0x13,0x24,0x67,0x9A,0x63,
	0xEC,0x7D,0xC4,0xFD,0xF1,0x86,0x3A,0x8E,0x0C,0xCF,0x17,0x85,0x9D,0x01,0xD5,0x05,0x08,0x51,0x4D,0x4B,
	0xC7,0xAE,0xE3,0xBA,0x84,0x29,0xE9,0x27,0xC8,0x88,0x9C,0xD1,0x42,0x77,0x95,0xA4,0x04,0x0C,0x1A,0x1A,
	0xA4,0x81,0xC1,0xF3,0x92,0xE1,0x79,0x55,0xA5,0x8F,0xF3,0x36,0xEE,0x5F,0xA9,0xA4,0x49,0x75,0xD2,0x05,
	0x40,0x00,0x5F,0x49,0xF4,0xD3,0xC8,0xA9,0xF5,0xC2,0x10,0x75,0x72,0xBD,0xAE,0x6F,0xB9,0xB5,0xB1,0x14,
	0x07,0x7D,0x25,0x99,0x09,0x51,0xAC,0x5D,0xE4,0x34,0x30,0xBF,0x7F,0x30,0x10,0x8C,0x14,0x5C,0x67,0x0E,
	0xF4,0x6C,0x99,0xF8,0x51,0x58,0x23,0xBD,0xAA,0x2E,0x18,0xA7,0xEA,0x26,0xF1,0xAE,0x28,0x02,0x71,0xE0,
	0x94,0x3F,0x59,0xF1,0x35,0x65,0x5F,0x43,0x1E,0x82,0x6A,0xA3,0x58,0x5A,0x69,0xC7,0xF6,0x56,0x95,0xF9,
	0xA2,0xEE,0x8F,0x95,0xBC,0x7D,0x15,0x97,0xD7,0xA5,0xFC,0x02,0xED,0x64,0x7C,0xAD,0xCA,0xAA,0x54,0x70,
	0x0B,0xC1,0xA9,0xD3,0x2F,0x26,0x06,0xBD,0xFB,0x7E,0x49,0x52,0x05,0x7F,0xB0,0x11,0x5F,0x95,0xD0,0x45,
	0x1F,0x75,0x35,0xEE,0x90,0x9B,0x68,0x9E,0xE1,0xE5,0xB0,0x7C,0xA9,0xCA,0xE6,0xFC,0x25,0x49,0x92,0x2A,
	0xB9,0xD2,0xB7,0xCC,0xBB,0xC6,0xE9,0xFD,0x1A,0x7C,0x27,0xC5,0x92,0xA4,0x0A,0x4C,0x3B,0x1F,0x54,0x1D,
	0x42,0xD4,0x55,0xC5,0x8E,0x55,0x49,0xF5,0x51,0x89,0xBA,0x63,0x94,0x59,0x01,0x51,0xE3,0x5D,0x1D,0x80,
	0xFE,0x03,0x92,0x56,0x4F,0x7F,0x1D,0x0C,0x36,0x50,0x6B,0xCB,0xA8,0x2A,0x3C,0x21,0xD5,0x8D,0x04,0x51,
	0x26,0x55,0x9A,0xD7,0x3E,0xCA,0xD7,0x5E,0x84,0x77,0xFF,0xF9,0x44,0xC9,0xCB,0x25,0x28,0x62,0xEF,0x5F,
	0x1B,0x51,0xCF,0x56,0x37,0x51,0x84,0x66,0xAD,0x5B,0x28,0xBB,0x55,0x2C,0x5D,0x95,0x58,0x5D,0x0A,0x18,
	0xE0,0x18,0x90,0x53,0xFB,0x8F,0x5E,0x55,0x05,0x1D,0xF8,0x0B,0x47,0xBA,0xAB,0xC9,0x8B,0xA8,0xA8,0xBA,
	0xBD,0x2B,0x0B,0x63,0x96,0x42,0xCE,0x0F,0x3C,0xF4,0x43,0xBB,0x85,0x6A,0x3B,0x10,0xD7,0xC3,0xB4,0x77,
	0xE3,0xCE,0x28,0x50,0x78,0xAA,0x51,0xBD,0x76,0xC3,0xFB,0x72,0xD8,0xBA,0x89,0x5B,0x5D,0x31,0x9B,0xD7,
	0xB7,0x63,0x06,0xF9,0x81,0xD6,0x24,0x20,0x0B,0x6B,0x5A,0x16,0x74,0xC1,0x1C,0x2C,0xFE,0x4C,0xE4,0x0D,
	0x8A,0x72,0x9C,0x36,0xEA,0xAC,0x0B,0x70,0x13,0x04,0xE3,0x95,0x4B,0x8A,0xA2,0xA8,0x10,0xFB,0x1F,0x4F,
	0x15,0x10,0xB5,0x17,0xA0,0x64,0x77,0xA1,0xF8,0x4B,0xB5,0xF4,0x1D,0xA8,0xC5,0x2B,0x57,0x2F,0xF9,0xE0,
	0xA8,0x01,0x56,0xD1,0x95,0x0F,0xDA,0xD6,0x3A,0x33,0x8A,0x62,0xCF,0xBD,0xC5,0x3B,0xA4,0xB6,0xB0,0x4E,
	0xB9,0xD2,0xEF,0xF3,0xFA,0x5D,0x26,0xAE,0x55,0x40,0x8C,0xE7,0x1A,0x18,0x06,0xB9,0x5F,0xFB,0x17,0x18,
	0x2D,0x14,0xDF,0x40,0xD8,0x07,0x7E,0x90,0x13,0x19,0xE4,0xBE,0x3C,0xFD,0xEF,0x32,0x98,0x0F,0x92,0xB1,
	0x92,0x70,0x7F,0xF8,0x5C,0xD7,0xE5,0x1B,0xEC,0x39,0xAA,0xBB,0xAF,0xB1,0x4E,0x7F,0x50,0xD7,0x63,0xF7,
	0x67,0x2A,0x00,0x40,0x2F,0x14,0x5B,0xC4,0xD5,0x58,0x29,0x2E,0xA8,0xFE,0x02,0x00,0x72,0xAB,0xAD,0xAD,
	0x35,0x22,0xFA,0x06,0x23,0xEC,0xDE,0xE2,0x0C,0x25,0x23,0xD5,0x28,0x71,0x01,0x64,0x49,0xD2,0x68,0x5F,
	0x05,0x27,0x6C,0x45,0xC7,0x01,0xB3,0xAF,0xAA,0x7E,0x56,0x28,0x1A,0x13,0xCF,0xFC,0x02,0x15,0xFA,0xB5,
	0xBA,0x36,0x65,0x0F,0xD9,0xFF,0x7B,0x10,0x91,0x6B,0x3C,0x09,0x5B,0x0B,0x70,0x95,0x9B,0xED,0xAA,0xED,
	0x76,0x9A,0x85,0x1C,0x75,0x1F,0xBD,0x8C,0x2A,0xDF,0x85,0xC6,0xB0,0xF0,0x4F,0x57,0x6A,0x58,0x69,0xE4,
	0x95,0xE9,0x03,0x87,0x25,0x5F,0xCD,0x89,0x4E,0xFF,0x5D,0x39,0x56,0xFF,0x9D,0xEA,0x34,0x6C,0xAF,0x9C,
	0x1A,0x83,0x52,0xC1,0xEC,0x50,0xA2,0xE4,0xDC,0x17,0x0B,0xB3,0x39,0xFE,0xEA,0x26,0xA9,0x75,0xAD,0x0D,
	0x77,0xE5,0x6B,0xAE,0x95,0x44,0x5D,0x17,0x53,0x61,0xCF,0x9C,0x47,0x0B,0x12,0x0A,0xF4,0xA1,0x85,0x67,
	0x13,0x4E,0x60,0xBE,0xB0,0x43,0x11,0x31,0x54,0x82,0x2F,0xE1,0x6D,0x55,0x48,0x15,0x98,0xA6,0x4B,0xAC,
	0x29,0x44,0x55,0x35,0x5C,0x91,0x14,0x13,0x6A,0xDF,0x68,0x90,0x5C,0xD8,0x5D,0x43,0x34,0xD4,0x04,0x24,
	0x59,0x10,0xDD,0x52,0x30,0x2E,0x6E,0x90,0x4E,0x1D,0x52,0x43,0x55,0x89,0x69,0x88,0x22,0xD0,0xB1,0x92,
	0x50,0xC1,0x7C,0xE1,0xD7,0x3B,0x3F,0xF7,0xCD,0x62,0x88,0x98,0xE6,0xE5,0xE8,0xF9,0x32,0xC2,0x0C,0xB6,
	0xAC,0x19,0x98,0xA1,0x83,0xA2,0x1A,0xF7,0x68,0xB2,0xFE,0x15,0xBC,0x1C,0xD7,0x08,0x33,0x82,0xFB,0xAE,
	0x0A,0xE5,0x46,0x0D,0x91,0x49,0x33,0x48,0x59,0x2B,0x57,0x90,0x28,0x51,0x23,0xAF,0xCC,0xE0,0x24,0x4C,
	0xFA,0xB8,0xAA,0x0D,0x1D,0x9A,0x80,0xA4,0x61,0x55,0x36,0x03,0x03,0xC0,0x4E,0x55,0x09,0x44,0xF6,0x8E,
	0xBB,0x97,0x34,0x11,0x04,0x40,0xFB,0xA0,0xC7,0xFA,0x6B,0x51,0xED,0x88,0x5D,0x8A,0x1F,0x25,0xB4,0x63,
	0x33,0x9A,0xEA,0x07,0x09,0x95,0x38,0x86,0xFC,0xA8,0x4C,0xBD,0x2E,0xBE,0x0D,0xC2,0x38,0x46,0x80,0x7F,
	0xB5,0x20,0xDD,0x88,0xA1,0x42,0xC5,0xC7,0x83,0xB7,0xFB,0x25,0x44,0x93,0xDA,0x78,0x98,0xAA,0xAB,0xF2,
	0x48,0x9C,0x15,0xAF,0x97,0x50,0x67,0x2E,0x20,0xE7,0x98,0x23,0x8A,0x50,0xB4,0x1B,0xFD,0x08,0xD1,0x80,
	0xCE,0x97,0x42,0xD0,0x24,0x5A,0x36,0x18,0x06,0x54,0x4A,0xB9,0x9B,0xA5,0xE6,0x42,0xC8,0x60,0x8B,0x58,
	0x73,0xFC,0xDB,0xE1,0x77,0x55,0x2D,0x2C,0xA5,0x91,0xDA,0x39,0x71,0xA5,0x64,0x5D,0xF7,0x6B,0x41,0x40,
	0x0E,0x86,0x00,0x05,0x06,0x01,0x59,0x90,0xEF,0xE3,0xED,0xD5,0xC4,0x24,0x4D,0xF2,0x9D,0xD8,0x96,0xCE,
	0x88,0xD1,0xA9,0x4E,0xD9,0x77,0x63,0xFD,0x55,0x42,0xEF,0xB1,0x69,0x12,0x91,0x9E,0x06,0x6C,0xBD,0x96,
	0x65,0xAB,0xA2,0x69,0x1C,0xE0,0x35,0x0B,0xDF,0xBF,0x86,0xBB,0xBA,0x17,0x87,0x01,0x6A,0xBF,0xF9,0xE1,
	0xD7,0xAD,0xAB,0x64,0xD0,0xE4,0xB1,0x6B,0x61,0x4B,0x4F,0x06,0x4D,0x36,0x5B,0x44,0x2B,0xF8,0x77,0x75,
	0x53,0x64,0xA4,0x9A,0xCC,0x3B,0x2A,0x03,0xDD,0x55,0x31,0xD4,0xB9,0x1D,0x92,0x0D,0x54,0xD6,0xED,0x56,
	0xC5,0xDC,0x55,0x49,0xF3,0x1F,0xA5,0xB8,0x6A,0xB2,0xD7,0x79,0x77,0xD5,0x5B,0xFF,0x8E,0xAE,0x42,0x31,
	0xCB,0xC3,0x09,0xD9,0xBF,0xB0,0xE3,0xDD,0x75,0x76,0xED,0xE0,0xFE,0x1E,0xB3,0xEF,0xC8,0xC9,0xA1,0x2F,
	0x84,0xC2,0xBD,0xC3,0x98,0x17,0x92,0x5F,0xED,0xB2,0x5D,0x6D,0x57,0x5C,0x24,0x68,0x32,0x62,0xDF,0xD2,
	0xE3,0x19,0x2D,0xFF,0xFE,0xF8,0x31,0x92,0xDB,0xAD,0x74,0x7E,0x05,0x10,0x9C,0x39,0xB7,0xF4,0x6B,0xA1,
	0x8B,0x59,0x56,0xD7,0x39,0x46,0xE8,0x57,0xF1,0xB8,0x33,0x9D,0xAC,0xCF,0x1E,0x08,0xED,0xFF,0x0F,0xC9,
	0xD3,0xAF,0xC6,0xF2,0x2B,0x59,0x65,0x01,0x2D,0x1B,0x58,0xF8,0x5F,0x25,0xB7,0x2E,0x1B,0x1B,0x9D,0xC6,
	0xFC,0x9D,0x13,0x69,0x05,0x58,0x92,0xEB,0x12,0xDF,0x78,0xEB,0xFE,0xEE,0x40,0x6A,0xDD,0x7C,0xC5,0x48,
	0xBA,0x64,0x11,0x09,0x4A,0x03,0xDA,0x24,0x3F,0x05,0x4C,0xDB,0x57,0xD8,0x44,0x5B,0x4E,0x43,0xCC,0x75,
	0xFB,0xEE,0x25,0xFB,0x7F,0xAA,0x2A,0x48,0x91,0x61,0xB5,0xC2,0x62,0xEB,0x06,0xEC,0xE2,0xB7,0xA7,0xA0,
	0xE0,0x29,0x0C,0x5A,0xE0,0xBE,0x4C,0x10,0x2D,0x67,0xA0,0x47,0x68,0x0C,0xA5,0xB1,0x37,0xDB,0xCD,0x24,
	0xBA,0xE3,0x91,0xAE,0xEF,0x84,0xC1,0x23,0xC6,0xF5,0xA9,0xD5,0xD5,0xE2,0x0A,0xDF,0x47,0x35,0xF4,0xC5,
	0xA8,0xA7,0x2B,0x4E,0xB4,0x89,0xB0,0x60,0x43,0xD3,0x42,0xE9,0x42,0x35,0x5D,0x61,0x17,0x92,0x24,0x73,
	0xE7,0x14,0x89,0x2E,0x5D,0x1B,0xD8,0xFD,0xE9,0xE6,0x62,0x89,0x64,0x19,0x24,0x71,0x76,0x06,0x8B,0x3C,
	0xF7,0x31,0x0F,0x01,0x01,0x4F,0x89,0xB1,0x89,0x9A,0x33,0x96,0x45,0xE9,0x5D,0xB1,0x1B,0x4C,0x26,0x04,
	0x1E,0x2D,0x14,0x4C,0x20,0xF0,0x46,0x24,0x46,0x7D,0xDA,0xDF,0x8D,0x78,0x18,0x30,0xB9,0x5D,0xA0,0xD4,
	0x2B,0xA9,0x5B,0x36,0x9E,0x9B,0x24,0xA1,0x55,0x18,0x9A,0x8C,0x32,0x6A,0x5D,0x42,0xF1,0x51,0xA6,0x6F,
	0x85,0xA1,0x11,0x36,0x89,0x1C,0xED,0xD3,0x81,0xAF,0x14,0x04,0xE7,0x8F,0x6E,0x06,0x0E,0x99,0x5F,0x7C,
	0x63,0x2A,0xA0,0x84,0xD2,0x88,0xE1,0xC6,0x40,0xAE,0x19,0x01,0xC2,0xE6,0x06,0x09,0xA3,0x06,0x0B,0x6F,
	0x1C,0xFE,0x03,0x4B,0x88,0xFE,0xA3,0x06,0x0E,0x1B,0x5D,0xC4,0x21,0x38,0x1C,0x97,0xE0,0xEA,0xA0,0x17,
	0x70,0x56,0xE5,0x54,0x62,0x18,0x05,0xA9,0x6E,0x39,0x72,0x0A,0xDE,0x19,0x69,0x98,0x17,0x14,0xB8,0xC8,
	0x3A,0x7E,0x67,0xBA,0x6A,0xF4,0x32,0xB5,0x76,0x5D,0xA5,0x4A,0x13,0x94,0x2A,0xBC,0x3B,0x49,0x07,0xFF,
	0xFE,0x57,0x91,0xD9,0x2C,0xF0,0xC4,0x38,0x1E,0x1D,0x64,0x20,0x17,0x95,0x2B,0xDC,0xA3,0xBB,0xE6,0xC5,
	0x7C,0x66,0x45,0xF9,0x90,0x61,0x76,0x62,0xE5,0xAA,0x2D,0x77,0x92,0x5B,0x54,0x35,0x28,0x8B,0xA2,0x9A,
	0xAC,0x05,0x57,0xE2,0x6E,0xA8,0x08,0xBB,0x32,0x8B,0xE4,0x25,0xCC,0x22,0x43,0xDD,0xCB,0x4A,0xDC,0x62,
	0x8D,0x80,0x53,0x26,0xE6,0x04,0xC7,0x4C,0xB7,0xE5,0xC2,0x32,0xF1,0x9B,0x7E,0xFC,0xD0,0x93,0x53,0xF5,
	0x89,0x65,0x9A,0x3F,0x13,0x2B,0x57,0xCE,0xF5,0x5B,0x02,0xE5,0xBF,0xAE,0x69,0xCC,0xC7,0x4B,0x92,0x22,
	0xE3,0xE0,0xF9,0x77,0x3F,0x7C,0xB1,0xD4,0xEE,0xF9,0xBC,0x8F,0x98,0x0B,0xBB,0x93,0xAD,0x5D,0xE9,0xBF,
	0x5C,0x5B,0x01,0xF9,0xBF,0x2C,0x7D,0x38,0xF2,0x50,0x30,0x54,0xE2,0x5A,0x17,0x54,0xEC,0xC1,0xA2,0x4F,
	0x0C,0xEA,0xEB,0x93,0x16,0x5C,0xC1,0x94,0xC6,0xE5,0x7F,0x46,0xEB,0x73,0xC0,0x24,0x2F,0xC3,0x75,0x52,
	0x16,0xD8,0x83,0x93,0x0C,0x10,0x70,0xB7,0xF3,0x0B,0x54,0x1E,0x51,0xE8,0x54,0xE2,0xA8,0x60,0xB5,0xF1,
	0x24,0x1B,0x21,0x62,0x84,0x1F,0x6C,0x59,0xE4,0xA1,0x61,0x86,0x0E,0x72,0x6B,0xE4,0xD2,0x14,0x9B,0xD5,
	0x56,0xEA,0xD7,0xC4,0x96,0xD8,0x75,0x85,0x7D,0x47,0x4E,0x40,0x22,0x0B,0x49,0x99,0xBB,0x22,0x2A,0x0D,
	0x9D,0x87,0x4D,0x04,0x7A,0xDB,0x97,0x85,0xBB,0x0F,0x86,0x47,0xB3,0x4D,0x21,0x94,0x33,0x8B,0x65,0x8A,
	0xD9,0x27,0x25,0x98,0x3B,0xF1,0xF7,0xE0,0xFF,0x57,0x10,0x66,0xD5,0x69,0x00,0x75,0x64,0x05,0xED,0x7A,
	0xA8,0xE5,0x66,0xD7,0xD7,0x3F,0x03,0x14,0xF1,0xAC,0xAF,0x1B,0x4A,0x0E,0x84,0x32,0x92,0x7C,0x55,0x12,
	0x50,0xF1,0x0A,0x02,0x4E,0xE0,0x1B,0x9E,0x70,0x25,0x06,0x4A,0x87,0x0A,0xC9,0x43,0x23,0x5E,0x36,0x30,
	0x08,0x8F,0x2A,0x62,0x1C,0xDF,0x99,0x12,0x62,0x41,0x71,0x5D,0xCA,0x24,0xA6,0xED,0x06,0xA0,0xC5,0xC5,
	0x47,0xFA,0x0F,0xC9,0x80,0x41,0x49,0x95,0x04,0x32,0xF6,0x21,0x82,0x84,0xAA,0x24,0xB6,0x4D,0x7F,0x17,
	0xAB,0x80,0x03,0xBA,0x55,0xA8,0x6F,0x43,0x06,0xBF,0x5F,0xAA,0x6F,0xFE,0x55,0x45,0xE2,0x20,0x03,0xA8,
	0x1A,0x05,0xC1,0xCB,0x3D,0xC8,0xEF,0x55,0xA1,0xAA,0x38,0xD8,0xE4,0x92,0x07,0x02,0x7B,0xA1,0xEA,0x87,
	0xC1,0xDB,0xE8,0xE7,0x05,0x71,0x10,0x02,0xA8,0xD4,0xC0,0xCF,0xF4,0xE9,0xF5,0xCD,0x07,0x54,0xC4,0xFA,
	0x89,0x2B,0x00,0x72,0x57,0xF1,0x33,0x4F,0x0D,0x01,0x4D,0xFB,0x6D,0x0A,0x7B,0xCC,0xE1,0x76,0xFF,0xB8,
	0xEE,0xB4,0xFB,0x8E,0x01,0xC3,0x44,0x16,0x6D,0x70,0x55,0xBD,0xDF,0x55,0xC3,0xE3,0x61,0xBE,0xDE,0xB1,
	0x0A,0xB7,0xDE,0xA9,0x3B,0xFD,0x9C,0xF0,0xBE,0xE0,0x74,0x55,0x00,0x67,0xEF,0x35,0xD2,0xD5,0xF2,0x0A,
	0x1A,0xD1,0xC6,0xC7,0x59,0xB3,0xB0,0x55,0x45,0xC2,0x2B,0x31,0xE4,0xFB,0x0F,0xFF,0x8D,0xEA,0x24,0x59,
	0xD1,0xE5,0xAE,0x2A,0x44,0x13,0xBE,0xAB,0x48,0x63,0xDD,0xE8,0xFF,0x0C,0xBE,0x25,0xD0,0x15,0xD1,0x13,
	0x88,0xDF,0x9F,0x92,0x4D,0x4E,0x4E,0x99,0x5A,0xEF,0x75,0x61,0x75,0x05,0xA8,0x9A,0xA0,0xD3,0xE4,0xAB,
	0xEC,0xE3,0xBB,0x91,0xF1,0x03,0x95,0xE8,0x99,0xD6,0x90,0xE2,0xB9,0xA2,0x60,0x62,0xFA,0xE6,0xBB,0xCA,
	0xB8,0x14,0x0A,0xE9,0x9E,0xE6,0x78,0x8A,0x3F,0x0C,0xC3,0x61,0x72,0x68,0x84,0x0C,0x37,0xF6,0x3C,0x02,
	0x31,0xB2,0x76,0x41,0x31,0x00,0x15,0x22,0xA0,0xF2,0xE4,0x88,0x9B,0xA3,0x8E,0xBB,0x4C,0x7E,0x35,0x7A,
	0x0F,0x09,0xEA,0xCC,0xAB,0x18,0x2C,0xC9,0xDC,0xC8,0xCD,0x0A,0x94,0xE4,0xE3,0x64,0x5C,0xAE,0xFA,0x11,
	0x06,0x0C,0x70,0x05,0x3B,0xBE,0xB6,0x08,0x1E,0xDD,0x24,0x54,0x9B,0x6D,0xE0,0x9C,0xAF,0x0E,0x00,0x19,
	0x94,0x86,0x54,0x07,0x89,0x6C,0x50,0x8A,0xF1,0x2A,0x7B,0x60,0x4C,0x92,0x81,0x0F,0xB6,0xAD,0xF9,0xF4,
	0x75,0x31,0x11,0xAE,0xF5,0x91,0x84,0x66,0x8A,0xC1,0x96,0x84,0xB5,0xE2,0xB0,0xBF,0xEF,0x2F,0xCC,0x12,
	0xE1,0x7F,0x84,0xBC,0xF4,0x75,0x23,0x8A,0x54,0x7D,0xE4,0x05,0x87,0x1F,0x86,0x1E,0x33,0x5D,0x75,0xE8,
	0x99,0x6A,0x22,0x15,0x43,0x66,0x73,0x86,0xE5,0xA6,0x6A,0xC0,0x9B,0xE6,0x9A,0xD4,0x11,0x24,0x5D,0xD5,
	0xE0,0xFF,0x91,0x18,0xD9,0xB0,0x76,0xFF,0x00,0xDB,0xF4,0x34,0x77,0xB8,0x7B,0x33,0x2E,0x3E,0x2B,0xD2,
	0x06,0x1B,0x39,0x4E,0xDA,0x80,0x07,0x5E,0xAB,0xC0,0x51,0xFB,0x05,0x47,0x26,0xFC,0xAF,0xD7,0xED,0x3A,
	0xAF,0x4D,0xFF,0xC7,0x48,0x55,0xA5,0x17,0x29,0xA4,0x59,0x21,0x89,0x71,0x9E,0x36,0xE3,0xDF,0x25,0x5F,
	0xC3,0x45,0xCF,0x8F,0x9D,0x90,0x88,0xD5,0x3B,0x64,0x84,0x0A,0x85,0x80,0x68,0xEC,0xFA,0x7C,0xC6,0xE9,
	0x15,0xF3,0xD4,0x81,0x44,0x06,0xBC,0x01,0xE6,0x01,0x76,0xC2,0x7E,0x17,0xC3,0xF0,0xF1,0xCF,0x37,0x5F,
	0x9A,0x83,0x9B,0xC0,0x2D,0x05,0x63,0x69,0xC5,0xDE,0xDB,0x58,0xDE,0xCA,0x45,0xB7,0x49,0x4C,0xB9,0xFA,
	0xF5,0x11,0xC8,0xEF,0xCD,0xC0,0xE7,0xB2,0x7D,0xE8,0x92,0xFA,0xE6,0xCA,0xF2,0xDD,0xFC,0x8B,0xB4,0xEA,
	0xAA,0xC2,0x68,0x3D,0xA0,0x93,0x26,0xF5,0xEF,0xB5,0xB2,0xA5,0x01,0x9A,0xAD,0x09,0x56,0x2A,0xF1,0x8D,
	0x62,0xB4,0x5B,0x46,0x68,0xBA,0x25,0xF2,0x12,0x7B,0x85,0x26,0x7E,0xDC,0x17,0xBC,0xBA,0xEA,0x69,0xB5,
	0xFF,0x3C,0xAE,0x2A,0xA1,0xB6,0x39,0xC7,0x20,0x8B,0xDD,0x99,0x8F,0x53,0x2E,0x56,0x90,0xE4,0xA6,0x8B,
	0x57,0x6E,0x08,0x87,0x55,0xD6,0x5B,0x7B,0xC3,0x86,0x60,0x83,0xD9,0x69,0xE2,0x83,0xAF,0x8B,0xB4,0xF9,
	0xAC,0x8D,0x84,0x62,0xD9,0xED,0xA3,0x8E,0x1B,0x10,0x41,0x52,0x8F,0xA8,0x7C,0x8D,0xBA,0x35,0xEB,0xB6,
	0xA8,0x06,0xA0,0xA1,0xC6,0x89,0x32,0x15,0xF0,0x95,0xEF,0x15,0xAA,0x0E,0xBF,0x22,0xCA,0xFA,0x26,0x81,
	0xCD,0xCB,0xC8,0x05,0x22,0x54,0x06,0xCC,0x45,0x1B,0x2B,0x0C,0x3F,0xC0,0xEC,0xD0,0xD8,0x04,0x2C,0x58,
	0x82,0xA4,0x1E,0xEC,0x54,0x51,0xAF,0xAB,0xDC,0x8D,0xB8,0x65,0x25,0xB8,0x85,0x3B,0x40,0xCB,0x6C,0xD8,
	0x41,0x2B,0x2E,0x40,0x06,0xCB,0x0B,0x5B,0x2F,0x12,0xAB,0xEA,0x3D,0x10,0x04,0x59,0x60,0x76,0x12,0x64,
	0x1D,0x5C,0x72,0x79,0x54,0xC2,0xD6,0x93,0x7B,0xE3,0xD2,0x14,0xA2,0x35,0xD4,0xB6,0x94,0xB4,0xDB,0xF5,
	0x6A,0x6F,0x25,0x63,0xFA,0x5B,0xD7,0x64,0xA6,0x2F,0x0B,0x57,0x2C,0xF4,0xFA,0x72,0xA6,0xA0,0x03,0x5F,
	0x5D,0x23,0x90,0x38,0xDE,0x06,0x8A,0x75,0x87,0x41,0xBB,0x27,0x23,0x90,0xC9,0xF2,0xCB,0x45,0x95,0xA5,
	0x53,0x5F,0x93,0xC8,0x34,0x2E,0x4B,0xF8,0x7B,0x1D,0xF7,0x0D,0x6C,0x8C,0xB0,0x4C,0xC1,0x48,0xF6,0x1F,
	0xD5,0x51,0x60,0xD3,0x5F,0x03,0x4A,0xAA,0x4A,0xA6,0x04,0xD4,0x88,0x16,0x7F,0x01,0x19,0xF2,0xF7,0x8D,
	0x84,0xEE,0x62,0xBE,0xEF,0xA6,0x9A,0x13,0xFC,0x37,0x41,0xB1,0x96,0xBA,0xBA,0x18,0x37,0xCF,0xC1,0xC5,
	0xD7,0x01,0xEB,0xE2,0x41,0xEA,0x49,0x66,0x24,0x74,0xFC,0xF7,0x15,0x2E,0x06,0xE1,0xBA,0xCC,0xE7,0x1B,
	0xB2,0xCA,0xB0,0x8E,0xC5,0x8C,0x3A,0x0F,0xDE,0xBD,0x7D,0xEA,0x59,0x97,0x04,0xD8,0xC4,0xC1,0x51,0xB9,
	0x0B,0x71,0x17,0xEB,0x90,0xE9,0x83,0x8D,0xE9,0x3B,0xE9,0xC5,0x31,0x36,0xE5,0x1C,0x0D,0xB5,0x58,0xAA,
	0x83,0xAE,0x5C,0x95,0xF2,0x9E,0xD8,0x30,0xF9,0x3E,0x42,0x9E,0xEB,0xD8,0x2E,0x9C,0x3D,0x10,0x7E,0x6A,
	0xC0,0xD8,0xAF,0xE0,0x58,0xE0,0xEE,0xE9,0xDF,0xB9,0x9F,0x98,0xA2,0xFE,0x75,0xF2,0xE7,0xF5,0x70,0x69,
	0xCE,0xD9,0x59,0xE6,0x88,0xCD,0x5D,0xC4,0x8A,0xBB,0x5C,0x8D,0x11,0xDB,0x56,0xFC,0x7B,0x2A,0x84,0x66,
	0x57,0xD7,0x3D,0x5E,0x60,0x40,0xAA,0xC0,0x7B,0x44,0x50,0xA2,0x1D,0x46,0x37,0xBB,0xF6,0xE1,0x0B,0xCA,
	0xFB,0xA3,0x01,0xAE,0x1F,0x64,0x07,0x78,0xEB,0xB7,0x71,0x02,0x9B,0x02,0x85,0xAB,0xAE,0xF9,0x95,0x86,
	0x23,0x45,0x78,0xE4,0xAD,0x2F,0x04,0x02,0x31,0xA3,0x3C,0x3E,0x9B,0x23,0x2D,0x24,0x1D,0x02,0x6F,0xBE,
	0xAB,0x17,0x3F,0x59,0xA3,0xFB,0xF7,0xCC,0x55,0x45,0x54,0x7D,0x40,0xB5,0xFE,0x0F,0x20,0xFC,0x8B,0xF7,
	0xAE,0x4A,0xFF,0x1F,0x41,0x7F,0x34,0xE0,0x75,0x97,0xF1,0xBE,0x2B,0xB3,0xA9,0xC6,0x28,0xD8,0x28,0x70,
	0xB1,0x00,0xAD,0x7A,0x77,0x80,0xFE,0x1B,0x59,0xD4,0x59,0xD4,0xFE,0x88,0xB0,0x60,0x27,0x57,0x3C,0x9B,
	0xB0,0xC8,0x95,0x80,0xEF,0x88,0xFB,0x13,0x1F,0xF4,0x9D,0x7F,0x45,0xB4,0xAF,0x0F,0xB8,0xEA,0xB1,0x0B,
	0x55,0x59,0x15,0x91,0x73,0xDF,0xCB,0x6D,0x59,0x20,0x91,0xF5,0xAC,0xDF,0xC1,0x68,0x80,0x57,0x6A,0xFE,
	0x7D,0x96,0x53,0x4B,0x07,0x5C,0x7A,0xB5,0x03,0x73,0x26,0x25,0xFE,0x87,0x0D,0x4C,0x30,0x56,0x50,0xBD,
	0x05,0x0E,0xF0,0x8D,0x9D,0x3A,0x7C,0x35,0x44,0xE8,0x99,0x9C,0xDD,0x80,0x3C,0x42,0x9A,0x3B,0x90,0x57,
	0xF1,0xF4,0xDC,0x9E,0x34,0xA3,0x2E,0x00,0x97,0xE5,0xF0,0x61,0x54,0xB0,0x0E,0x7A,0x8D,0x18,0xEB,0xFF,
	0xA1,0x51,0x55,0x8C,0x6B,0xA2,0x0E,0x30,0x0C,0xB5,0x1D,0xC7,0x57,0x20,0x68,0x2D,0xBB,0x1C,0x30,0x0A,
	0xDB,0x42,0x91,0xA3,0x71,0x57,0x9E,0x32,0x30,0x51,0x88,0xC5,0x72,0x51,0xB7,0xF0,0xC5,0x10,0x56,0x56,
	0xFB,0xBE,0xCE,0x00,0xC7,0x78,0x00,0x18,0xB3,0xFB,0x21,0x83,0x86,0x20,0x4E,0x7F,0x3D,0xF1,0x21,0xA1,
	0x69,0x02,0x67,0xD7,0xDF,0x31,0x5E,0xD3,0xCE,0xB3,0x41,0x52,0x5A,0x9B,0xDE,0x09,0x92,0x9B,0x10,0x39,
	0x53,0xCB,0x17,0xE4,0x94,0xA2,0x87,0x5D,0xB1,0xA1,0xDF,0x59,0x0E,0x26,0x19,0x80,0xC5,0x20,0xB6,0x51,
	0xFD,0x33,0xF1,0xE3,0x77,0x1F,0xBD,0x79,0x1A,0x1A,0x91,0x88,0xCF,0x56,0x8D,0x7B,0x03,0x67,0x33,0xF9,
	0x8F,0xFE,0x12,0x61,0xD1,0x9B,0x14,0xDB,0x1D,0x5B,0x49,0xC4,0x56,0x32,0x56,0x88,0x77,0x47,0x99,0x77,
	0xE6,0xDB,0x0E,0x07,0xD2,0xAD,0x9A,0xA6,0x1F,0xF1,0x18,0x72,0x7B,0x01,0xD3,0x1F,0xCC,0x7A,0xBE,0x47,
	0x31,0x29,0xE2,0x98,0x88,0x10,0x4F,0x5C,0x2F,0x43,0x79,0xBA,0x44,0x7E,0x5D,0xAB,0xD3,0x3A,0x02,0x8F,
	0x11,0x28,0x9F,0x42,0x7F,0x2C,0x16,0x72,0xE8,0x3D,0xD2,0xB8,0x90,0x57,0x06,0xCC,0xEB,0xD1,0x71,0xE3,
	0x02,0xF1,0x08,0x4C,0x0D,0x0E,0x94,0x7A,0xD1,0xE7,0xB8,0x43,0x51,0xBE,0x5E,0xBE,0x4F,0xAE,0x3A,0xDC,
	0x2E,0x3A,0xC4,0xFE,0x35,0x42,0x56,0x7D,0x9C,0x6F,0xBD,0xA3,0xAB,0xE0,0xFD,0x97,0xAF,0x77,0x52,0x7C,
	0x57,0xB1,0xD1,0x8A,0x77,0xAE,0x1E,0x27,0x5F,0xA7,0xE6,0xCB,0x94,0x30,0xBB,0xA2,0xEF,0x04,0xBC,0x0C,
	0xC8,0x20,0x1D,0xD8,0x21,0x2E,0x88,0xC9,0x73,0x3B,0xB8,0xEB,0x9D,0x9F,0x46,0xA8,0xBF,0x86,0xED,0xA4,
	0xED,0x83,0x06,0x6A,0x24,0x15,0x85,0x42,0x97,0x00,0xBB,0x25,0x44,0x5E,0x1D,0xEE,0xFB,0x1B,0x7C,0x47,
	0x4E,0xEF,0x00,0x12,0xE5,0x2F,0xB4,0xC4,0x23,0xD2,0xD1,0x78,0xB8,0x0A,0xD8,0x18,0xA2,0xD8,0xA1,0x15,
	0x68,0x40,0xE9,0xF7,0xC9,0x82,0xAC,0x83,0x18,0x81,0x45,0xB0,0x6B,0x88,0x82,0xFC,0x02,0x7B,0x89,0x4B,
	0x57,0x21,0x5F,0xD5,0x3A,0xC1,0xD0,0x40,0xAF,0x8B,0x09,0xA1,0x1C,0xA9,0x2D,0x5B,0xD5,0x28,0x03,0x27,
	0x0A,0x8D,0x61,0xA7,0x11,0x84,0x13,0x16,0xDA,0x97,0x46,0x31,0x36,0xE6,0xD0,0xA4,0xBE,0xFB,0x33,0x4C,
	0xD1,0x63,0x6E,0x8C,0x19,0xB1,0xAC,0x86,0x2E,0x87,0x1C,0x62,0x68,0xDE,0xAF,0x0E,0x54,0x44,0xAE,0x21,
	0x1F,0x5D,0x4B,0xC2,0xA6,0xB8,0x6D,0x69,0xD4,0xC2,0x84,0xAA,0x6A,0x06,0x76,0x90,0x38,0x0B,0xFB,0x21,
	0x86,0xCA,0x78,0xA9,0xB3,0x2D,0x4D,0x8D,0x89,0xC3,0x7E,0xE3,0xA6,0x36,0xD6,0x55,0xF5,0xBC,0xF1,0x02,
	0xD6,0x57,0xEE,0x14,0x54,0x8D,0x63,0x3F,0x9C,0x21,0x47,0xD8,0x07,0xA6,0xE8,0xCA,0x7D,0x60,0x98,0x64,
	0xA6,0x5F,0x35,0xD2,0x47,0xE5,0xE3,0x57,0xD9,0x00,0x80,0xBD,0xAE,0xAF,0x8A,0xDC,0xEA,0x8B,0x78,0x0A,
	0x4C,0xEB,0xB8,0x75,0x39,0xBA,0xC5,0xCD,0xF5,0x55,0xFC,0x0E,0xB6,0xF2,0x20,0x46,0xA5,0x2F,0xED,0x5A,
	0xCF,0xC7,0x45,0xA7,0xD3,0x87,0xDB,0xD1,0x95,0xC0,0x55,0xC0,0x12,0x6D,0x2F,0xDD,0x06,0x6F,0x7F,0xD5,
	0x12,0x6B,0x42,0x8A,0x27,0x97,0x23,0xEC,0xF0,0x0A,0x8A,0x86,0xFA,0x9B,0x75,0x9B,0x4A,0xC5,0xEE,0x24,
	0x91,0x81,0xD1,0xEB,0x68,0xB4,0x8C,0x31,0xF4,0xA9,0x40,0x2A,0xCD,0xA1,0x13,0x2C,0x38,0xC2,0x98,0x09,
	0x63,0x84,0x20,0xDE,0xDB,0x20,0x26,0xC1,0x80,0x18,0x43,0x18,0xA9,0xCA,0xBE,0x2E,0x8F,0xA5,0x3E,0xB1,
	0xA3,0x22,0x1A,0xFB,0x4C,0x2A,0x9B,0x87,0x82,0xA0,0x76,0x77,0x3B,0x1A,0xE8,0x35,0x7E,0xAE,0xFE,0xDC,
	0x4A,0xF0,0x7F,0x20,0x1F,0xBB,0x8B,0x26,0xFD,0x2C,0x67,0x21,0x3C,0x41,0x45,0xFE,0x77,0xD9,0x12,0x42,
	0x41,0x7D,0x3F,0x7D,0xC7,0xA1,0x42,0x23,0xA0,0x30,0xC2,0xDA,0x18,0xAB,0xFE,0x46,0x63,0xB5,0xEC,0x4C,
	0x0B,0xDF,0x39,0xEE,0x7D,0x78,0x75,0x2F,0xEF,0x49,0x59,0x44,0xD5,0x09,0x59,0xF1,0xB3,0x2E,0x9E,0xF7,
	0x37,0xB2,0xE1,0x98,0x9D,0x10,0x11,0x51,0xEF,0x0E,0x50,0xEF,0x24,0x3C,0x21,0x1D,0x18,0x31,0xEE,0x93,
	0xDE,0x7D,0xC9,0xD2,0xF5,0x01,0xD0,0x7D,0xF9,0xF4,0xEB,0x03,0x46,0xBE,0xD6,0x88,0xD2,0xFE,0xD2,0x84,
	0x20,0x92,0x19,0xE1,0xA0,0x25,0x5F,0xD5,0xA6,0x69,0x9A,0x26,0x2C,0x53,0xC9,0xC7,0xDD,0xA3,0x80,0x23,
	0x2B,0x46,0x9A,0xA8,0x0B,0x7C,0x10,0xB6,0x39,0x60,0x9C,0x1B,0x1F,0x54,0x0E,0x23,0x4D,0xC4,0x82,0x2A,
	0x68,0x72,0x85,0x31,0x0F,0xCC,0x2D,0xC7,0x46,0x93,0x03,0xC6,0x39,0x46,0x74,0x8F,0xD9,0xB0,0x33,0x61,
	0x66,0x91,0xBC,0xB2,0x89,0x5E,0xB2,0x12,0xAE,0x70,0xF2,0xC0,0x26,0x04,0xB6,0x62,0x59,0xE2,0x03,0x23,
	0xBE,0x6C,0xA1,0x53,0xBF,0xF3,0xC2,0x88,0x7F,0x5C,0x57,0xEB,0x12,0xC2,0x93,0xA1,0xA2,0xA8,0x07,0xF3,
	0x87,0x04,0x2E,0x55,0x39,0x75,0xD7,0xD8,0xED,0x9F,0xC3,0x44,0x18,0xA1,0x0A,0x74,0x5E,0x67,0x57,0x57,
	0x68,0x76,0x55,0xC7,0xE0,0xB8,0x01,0x72,0xFA,0x60,0x38,0x76,0x8C,0x82,0x23,0xBE,0x0B,0xCC,0xB5,0xCF,
	0x1B,0x86,0x46,0xAF,0xAF,0xE2,0x02,0x6F,0xB8,0xD8,0x34,0x57,0x8C,0x7D,0xBA,0x52,0x3B,0xEF,0x00,0x4D,
	0x75,0x7C,0xD6,0x8B,0xF4,0x22,0x2B,0xC3,0x90,0x3E,0x5C,0x7D,0xE1,0xFB,0x5B,0xBB,0x4E,0x67,0xAF,0xEB,
	0x06,0xEA,0x03,0x27,0x44,0x3C,0x33,0x5D,0xED,0x9E,0x21,0xBB,0xF6,0x4F,0x47,0xE1,0x1E,0xAE,0x3B,0x9B,
	0x07,0x7F,0xE9,0x58,0xC0,0x5B,0x0F,0xA2,0xD7,0xE3,0xE7,0x97,0xFF,0x00,0x54,0xEA,0xE9,0x1B,0xAC,0x3B,
	0x45,0x3C,0x41,0xC7,0x3F,0xC1,0x2E,0x86,0x39,0xB4,0x41,0xB8,0x96,0xAA,0x02,0xD0,0x1B,0x3A,0x8E,0x41,
	0x39,0x97,0x21,0xA8,0x4E,0x61,0x4E,0x80,0xD6,0x8A,0x5F,0x89,0xF9,0x8D,0x33,0x14,0x19,0x0A,0xBB,0x87,
	0x22,0x7F,0x97,0x48,0x96,0xBC,0xEE,0x82,0xEA,0x7C,0x18,0x17,0xB6,0x78,0xDD,0x95,0x86,0x3D,0xDB,0x07,
	0x5E,0x1A,0x8C,0x1D,0x2B,0x5A,0x64,0x42,0x2E,0x6F,0x09,0x48,0x5D,0x2B,0x4D,0xC4,0xBA,0xFC,0x66,0xF5,
	0x72,0x46,0xAA,0x7D,0x86,0xD3,0x19,0x90,0xBA,0x44,0xCF,0x19,0xB8,0xAB,0x4A,0x97,0x92,0x8F,0xB5,0xCC,
	0x61,0xC1,0xF0,0xC1,0x00,0x66,0xAE,0x3B,0x35,0x0E,0x58,0xB3,0xB6,0x79,0xE5,0x12,0xE0,0x4F,0xD5,0x42,
	0xFB,0xE3,0xEA,0x2A,0xC5,0x5F,0x49,0xD8,0x75,0xA1,0xFE,0xEA,0xB1,0x69,0x5E,0x77,0x99,0x36,0xD0,0x5A,
	0x2C,0x62,0x79,0x22,0xD4,0x39,0x8D,0xD9,0x47,0x3E,0xD7,0x2E,0x28,0x3D,0x73,0xB4,0xAC,0x59,0x5D,0x4D,
	0x1E,0x47,0xC0,0x47,0x67,0x90,0xA9,0xA5,0xFF,0x75,0xA2,0xD2,0xE6,0xF5,0x15,0x50,0xFA,0x3C,0xF1,0x4E,
	0x3B,0x8D,0x2B,0x71,0xB5,0x99,0xC5,0xB2,0x50,0x15,0xF5,0xAC,0x20,0x85,0xA1,0xC9,0x9A,0x7D,0x95,0xCC,
	0x75,0x01,0x2B,0x63,0x75,0xE5,0x09,0xF5,0xBB,0xE7,0xAA,0xA4,0xDE,0xAE,0x0F,0x70,0xFF,0x22,0x96,0xD6,
	0xEE,0x79,0x53,0x92,0x03,0x7C,0xE8,0x1F,0x09,0x89,0x04,0xC6,0x72,0x58,0xBE,0x45,0x3A,0x64,0x35,0xDF,
	0x2A,0x7E,0x9D,0xDD,0x7D,0x29,0xAF,0x0A,0x81,0xFE,0xBF,0xAE,0x91,0xFD,0xF6,0x21,0x1B,0xF8,0x3C,0x67,
	0x58,0xDB,0x7D,0x89,0x10,0x63,0x79,0x69,0x36,0x66,0x0F,0xC0,0x3A,0x8A,0x5C,0x76,0x50,0xA1,0x5B,0xFD,
	0xF9,0xBE,0xEA,0x0A,0xA8,0xB5,0x85,0x29,0x16,0xC2,0x18,0x39,0xF8,0xF7,0xD7,0x85,0xBA,0x75,0x82,0x22,
	0x2E,0x51,0x91,0xDD,0x5C,0xE0,0x3B,0xE9,0xEB,0x55,0x0E,0x7C,0x55,0xEC,0x2B,0x2B,0xEC,0xF4,0x50,0xDE,
	0x5D,0x69,0x36,0xB8,0x11,0xC1,0x40,0x3C,0x89,0x99,0xE9,0x8C,0xEC,0x86,0x8C,0x92,0x6A,0x57,0x41,0x14,
	0x9C,0x9A,0xE8,0x0E,0x30,0xAF,0xAF,0x66,0x57,0x98,0x84,0xF6,0x8E,0x8F,0xAF,0x22,0x23,0x7D,0xC2,0xB7,
	0x74,0x84,0x8B,0xF2,0xB6,0xE6,0x3A,0x0B,0x57,0x57,0x61,0x77,0x92,0xD6,0xFE,0xDA,0x9D,0x5F,0x21,0xC2,
	0xFE,0x6D,0x8B,0xF8,0x73,0xDB,0xB8,0x4E,0x0C,0x50,0x4C,0xA9,0xC9,0xD8,0xA3,0x74,0x7F,0x15,0x18,0x70,
	0xA9,0x78,0x42,0x14,0xE4,0x28,0xEB,0x08,0xEF,0x2B,0xAB,0xA8,0xC6,0xA3,0x34,0x05,0x35,0x66,0x18,0xC7,
	0xFB,0xC7,0x07,0x56,0x9D,0x5F,0x51,0x99,0x32,0x69,0x6A,0x4F,0xA9,0x56,0x41,0x8F,0x5D,0xF5,0x8E,0x75,
	0xE1,0xFA,0x3B,0x86,0x5C,0x14,0x11,0x86,0x54,0x10,0x0D,0x67,0x76,0xA0,0x5F,0x9C,0x15,0x72,0xDF,0x4F,
	0x32,0x8C,0xFE,0x3E,0x59,0x91,0xA9,0x9D,0xFE,0x2B,0x09,0x61,0xB7,0xAC,0x0F,0xDC,0x80,0x54,0x30,0xA9,
	0xEC,0x57,0x23,0x8C,0x17,0x17,0x67,0x3E,0x02,0xE3,0x5F,0xAF,0xC1,0xBF,0x2A,0x6C,0xE5,0x76,0x6B,0x4B,
	0xD0,0xD7,0xB5,0x42,0xD9,0xBB,0xAE,0x1F,0x87,0x47,0x5F,0x65,0x7E,0x57,0x45,0x0D,0x5E,0x73,0x85,0x72,
	0xEA,0x0A,0xB0,0x02,0xD4,0x77,0x16,0x14,0xFC,0x6D,0x7D,0x10,0xB6,0xEA,0x34,0x44,0x10,0xD3,0xC9,0xAB,
	0x46,0xBB,0xBF,0xFB,0xDE,0xBE,0x2B,0x98,0x42,0x0B,0xB3,0x55,0x25,0x77,0x55,0xD0,0xDC,0xB3,0x24,0xE8,
	0xC1,0xFF,0x04,0x4F,0x44,0x7D,0x16,0x52,0x76,0xC3,0xDD,0xC7,0xD8,0x7B,0x2E,0x14,0xAE,0x2B,0x19,0x39,
	0xFF,0x5E,0x7F,0x6D,0xE5,0xEF,0x4F,0xF4,0x28,0xF8,0x3E,0x09,0x1A,0x10,0x3D,0xEA,0x0A,0x71,0x14,0x54,
	0x22,0x97,0x6B,0xDF,0xEE,0x43,0x14,0xF7,0xFC,0x6D,0x18,0xA1,0xBD,0xAB,0x77,0x2A,0x1F,0xA5,0xEB,0x73,
	0xAE,0x9B,0x32,0xF7,0x27,0x64,0x06,0x85,0xAC,0xEE,0x5D,0xAE,0x01,0x04,0xF9,0x75,0xA1,0xD6,0xBF,0x25,
	0x43,0x37,0x75,0x2A,0xBB,0xC3,0x57,0x8A,0xC0,0x63,0x57,0x67,0xB0,0x41,0x7F,0xAD,0x03,0xFC,0xBB,0x51,
	0x4C,0x0F,0x56,0x95,0x94,0x83,0xA8,0xE2,0xBA,0xFB,0x65,0xAF,0xA6,0xE8,0xCE,0x33,0x29,0xBE,0x2B,0x15,
	0xD5,0x0C,0xB5,0xE9,0x84,0xBB,0x3D,0x5D,0x07,0xA7,0xEF,0xA4,0xDD,0x29,0x4A,0x59,0xB2,0xE9,0x2F,0xC5,
	0x35,0x4C,0xFD,0x4E,0x83,0xBE,0x10,0xB0,0x75,0x71,0x8F,0x1B,0xEF,0xD4,0xEA,0xC0,0xA9,0xD8,0x04,0x98,
	0x16,0xF8,0x2E,0xDE,0xC1,0xC1,0xC8,0xCE,0x5F,0x57,0x1D,0xC1,0x0D,0x4D,0xAF,0x6B,0xEF,0x30,0x07,0x8F,
	0x75,0x55,0xD1,0x88,0x5A,0x37,0x71,0x95,0x10,0xED,0x38,0x2A,0x5E,0x1C,0x5C,0xBE,0xDD,0xC5,0x47,0x89,
	0xE7,0x1C,0x83,0xED,0x5F,0xC0,0x5D,0x42,0x81,0x67,0x03,0x42,0x30,0x53,0x69,0xBC,0xFA,0xE1,0xE0,0xBA,
	0x1C,0xA4,0x84,0xC0,0xD5,0x3B,0x4C,0xE1,0x74,0xB7,0x40,0x9F,0x9B,0xEE,0x1E,0xEB,0x2A,0xC7,0x7E,0xF8,
	0xD7,0x42,0x68,0xB8,0x9A,0xEB,0x0B,0x0D,0xEE,0x9B,0xC1,0xB0,0xC1,0xE2,0x97,0x9B,0x2E,0x62,0x51,0x5F,
	0x12,0x45,0x00,0xFA,0x1E,0xE1,0x18,0x87,0xF4,0x42,0x1F,0xFE,0xDC,0xEA,0xEA,0xFB,0xDA,0x2C,0x84,0xBE,
	0xD9,0x18,0x48,0x4D,0xFF,0x4D,0xBD,0xBF,0x28,0x4D,0x3E,0xB6,0xA3,0xC8,0xFB,0x3B,0xFC,0xEB,0xDF,0x72,
	0x0C,0xBD,0x18,0x60,0x0F,0xBD,0xC4,0xF2,0x2B,0x01,0xFA,0x55,0xC7,0xA0,0x4B,0x5E,0x47,0x00,0xBF,0x0B,
	0xD3,0xBD,0x1E,0x1C,0x14,0x9F,0xA5,0xF1,0x8C,0x14,0xF8,0xAA,0x6B,0x4E,0xDA,0x9E,0x7D,0xFD,0x13,0x26,
	0xEC,0x04,0xD3,0x44,0x73,0x56,0x39,0x31,0x1A,0x62,0x58,0x6D,0x1C,0x62,0x3A,0x8C,0xFF,0xE5,0xEB,0xB0,
	0xEA,0x2A,0x87,0xAA,0xED,0xB4,0xEB,0x2C,0xF7,0xA0,0xA0,0xD5,0x5D,0xB1,0x76,0x52,0xF9,0x9C,0x6B,0x07,
	0x9E,0x7F,0x6C,0x30,0xB0,0x8D,0xFF,0x71,0xF0,0x71,0x47,0x0B,0xC1,0x5D,0xEE,0x73,0xD1,0x50,0x01,0x4A,
	0x2F,0xA7,0xBB,0x62,0x0E,0x5F,0x39,0x6A,0xFE,0x5B,0xEE,0x05,0xCB,0xDF,0x74,0xB8,0xB0,0x09,0x4C,0x3B,
	0xC8,0xC7,0xC5,0x60,0x62,0xD4,0x70,0x3E,0xFD,0x0A,0x52,0x8E,0xB3,0x1A,0xAC,0x8C,0xF2,0x6C,0x1E,0x61,
	0x63,0x1C,0x92,0x0B,0x92,0xF9,0x4C,0x0C,0xD2,0xBF,0xA9,0x72,0x3D,0x64,0x0E,0x43,0x1E,0xEA,0x97,0x70,
	0x5F,0x54,0x94,0x43,0x01,0x0B,0x69,0x74,0xF0,0x6E,0x4F,0x58,0x04,0x25,0x9F,0x5C,0x03,0x21,0x7F,0x15,
	0x74,0x2A,0x2C,0x66,0x5D,0x5F,0xAF,0x39,0xAE,0xF1,0xEB,0xE5,0x29,0x74,0xE3,0xEB,0x22,0x15,0x20,0xAB,
	0x75,0x20,0x93,0xF4,0xAE,0x6C,0x67,0x3A,0x22,0xDD,0xF0,0x7B,0x73,0xBD,0x6B,0x25,0xFB,0x06,0xEB,0x69,
	0xF7,0x53,0x2A,0xF4,0xC6,0xE3,0xFD,0x53,0xC0,0xC1,0x77,0xA5,0x1B,0x2E,0xF7,0xC6,0x4C,0x3C,0x4C,0x62,
	0x25,0xF9,0xC6,0xC5,0xA2,0x89,0x09,0x2D,0xC4,0x2A,0x49,0x7F,0x87,0x8C,0x2A,0x73,0xE3,0xE5,0xDF,0x6A,
	0x84,0x57,0xC7,0x27,0x5F,0xCD,0x80,0xA4,0x2D,0x80,0xCC,0x1F,0xB9,0xC1,0x81,0xB5,0xC0,0x4D,0x2A,0x3C,
	0xD0,0x13,0x03,0x47,0x7D,0x30,0x30,0x88,0x64,0xFC,0xE3,0x98,0xA4,0x7F,0x86,0xC1,0xDF,0x1D,0xC2,0x5D,
	0x9D,0xAB,0x32,0xDC,0x61,0x5A,0xAE,0xBF,0x70,0xFF,0xFC,0xFB,0x3E,0xA7,0xFF,0x4B,0xC9,0xCF,0xDF,0xC7,
	0xA6,0xAB,0xC4,0x5D,0xA5,0x65,0xB8,0x7D,0xA7,0x21,0xF7,0x52,0x27,0x00,0x8E,0x91,0x22,0x5B,0x00,0xA9,
	0x04,0x99,0xED,0x16,0x46,0x30,0x46,0x99,0x5E,0xED,0x84,0x6F,0x16,0x94,0x7D,0x85,0x6C,0x43,0x27,0xA3,
	0xB1,0x52,0x6C,0x26,0x55,0xF0,0xBA,0x0F,0x4A,0xF6,0xF5,0xAF,0x87,0x6B,0x80,0x3A,0x30,0x92,0xD2,0x85,
	0x4E,0xCF,0x47,0x0B,0x3C,0x27,0x62,0xCF,0x38,0x59,0x67,0x60,0x12,0xEB,0x8A,0xFC,0xEC,0x2E,0x06,0x44,
	0xE7,0xEB,0x06,0x7B,0x61,0x1C,0xD3,0x12,0x92,0xAE,0xAA,0xD9,0x07,0x3E,0x40,0x09,0x96,0x96,0x9B,0xFF,
	0xAF,0x9C,0xE2,0x81,0xB9,0x26,0x39,0x06,0x87,0xF8,0x00,0x76,0x13,0x3C,0xD8,0xE2,0xC1,0x10,0x1F,0xE6,
	0x66,0x06,0x61,0x58,0x35,0x57,0x12,0x2A,0x43,0x05,0xB3,0x25,0x24,0x0B,0xB4,0x07,0xB0,0x58,0x67,0x54,
	0x4C,0x70,0x01,0x40,0xF1,0x74,0xDF,0xAF,0xA4,0x17,0x61,0xAA,0x56,0x76,0x4B,0x75,0x4B,0xD0,0xA3,0x27,
	0x54,0xD3,0xAD,0xF8,0x9E,0xFC,0x32,0xED,0xD6,0x26,0xF7,0xB1,0x7F,0x14,0xD9,0xC4,0xEF,0x5A,0x67,0xCC,
	0x35,0xED,0x8E,0x0C,0xD3,0xBF,0x50,0x5A,0x1B,0x10,0x92,0x40,0xF1,0x85,0x4F,0x82,0x9B,0xB4,0xFE,0x07,
	0x0B,0x0C,0xFA,0x68,0x67,0x69,0xD7,0x06,0xD5,0x4F,0xCE,0xCC,0x40,0x4F,0x28,0x50,0xB4,0xC5,0xCC,0x4D,
	0xC4,0xAC,0x59,0x63,0x2F,0x8C,0x17,0xC4,0x10,0x1F,0x0E,0xED,0xB0,0xFF,0xF9,0x18,0xEE,0x84,0xD4,0x75,
	0x83,0x1B,0x22,0x94,0x8C,0xE3,0x68,0x08,0xD5,0x5A,0xB6,0xA6,0x9D,0x78,0x0D,0xD3,0x64,0x9D,0x9D,0x2F,
	0x61,0x02,0x12,0x32,0x36,0x3C,0x7B,0xF9,0x89,0x08,0xFE,0x19,0x6D,0x96,0x99,0x72,0xC7,0xAB,0xE4,0xCD,
	0x0A,0x0D,0xC0,0x3E,0x32,0xDA,0x52,0x32,0xB5,0x53,0x6B,0x60,0xC1,0xFD,0x3B,0xFE,0x6A,0x81,0x79,0x4E,
	0x3B,0xA5,0x4B,0x64,0x6E,0x61,0x37,0xF3,0x5F,0x38,0xC4,0x4A,0x01,0x5C,0xFE,0xC7,0xFC,0xF7,0xFA,0xC0,
	0xF8,0xF0,0x2C,0xD0,0xD4,0xAB,0xC7,0xB4,0x61,0xD1,0xE8,0x7A,0x8A,0xA1,0xAA,0x40,0x02,0x07,0x15,0xC4,
	0x66,0x1D,0x14,0x7B,0x60,0xDC,0x79,0x05,0x08,0x63,0xA8,0x45,0x70,0x0D,0x11,0x1B,0x01,0x26,0x0F,0xAC,
	0xE9,0xF1,0xF9,0x03,0x29,0x05,0x29,0x73,0x35,0xEE,0xB7,0x01,0xD9,0x7D,0x76,0x74,0xA7,0x78,0xB7,0x23,
	0x7D,0xD2,0x6D,0xFB,0xD8,0x5C,0xEF,0xC6,0x4C,0x1B,0x26,0x55,0x23,0x3B,0xC7,0xEB,0x0D,0x00,0x06,0x10,
	0x86,0x19,0xAB,0xB3,0x6F,0x89,0x90,0xEB,0xD4,0x32,0x50,0xD0,0x60,0x31,0x51,0x03,0x54,0xDE,0x7A,0xA2,
	0xB6,0xAF,0x24,0x83,0x50,0xC8,0xA6,0x93,0x62,0xA1,0x46,0x86,0xFE,0x74,0xA9,0xC3,0x96,0xAE,0x00,0x3F,
	0xA8,0xBA,0x5B,0x6D,0x06,0x50,0xF8,0x9E,0x76,0xA9,0x28,0x75,0xF7,0x5E,0xE8,0x8F,0xCD,0xFC,0xF2,0xB3,
	0xDE,0xAF,0xBF,0xD7,0xBC,0x98,0xE8,0x30,0xB0,0xE5,0xB7,0x64,0x88,0x4E,0x98,0x44,0x90,0x5C,0x8C,0x97,
	0x5E,0x75,0xAE,0x30,0x23,0xB2,0x86,0x4A,0x86,0x7F,0xC0,0x7A,0x58,0xA0,0x30,0xE9,0x7F,0x77,0xAD,0x42,
	0x27,0x2D,0x23,0xEA,0xAB,0x3B,0x5A,0x7A,0x7F,0x35,0x02,0xDB,0xCB,0x7D,0xF8,0x0E,0x67,0xCC,0xB7,0x24,
	0xD8,0x12,0xD4,0x0B,0x1F,0x34,0xEE,0x86,0xE0,0x03,0x2C,0x23,0xBF,0x60,0x01,0xA0,0x19,0x75,0x64,0x07,
	0xEA,0xE7,0x22,0xF9,0x28,0xEB,0x1E,0x87,0x34,0x0A,0xFB,0x45,0x7D,0xBC,0x98,0x83,0x98,0xC8,0xDE,0xFF,
	0xAF,0x64,0xBE,0xD5,0x55,0x72,0x16,0x74,0xDB,0xFF,0x6A,0xC3,0xE5,0x88,0x97,0x0B,0xAD,0xFD,0x37,0x29,
	0x4E,0x53,0x77,0x2E,0x5E,0xB1,0xF2,0x4C,0x55,0x6B,0x12,0x7D,0x01,0x4D,0x99,0x67,0xDB,0x91,0xFB,0xD1,
	0x42,0x13,0x95,0x6D,0x7F,0x23,0xE4,0xCB,0x03,0xBC,0x74,0x71,0x0F,0x4D,0x1A,0x68,0x0A,0xEE,0x45,0x32,
	0xC4,0x26,0xBF,0x53,0x03,0xB3,0xA5,0x34,0x4D,0xC4,0x34,0x2B,0x30,0x3F,0xE3,0xDD,0x98,0x4C,0x30,0x7E,
	0x54,0x8B,0x69,0x77,0x10,0x14,0xD8,0xF9,0xED,0xE3,0x00,0x00,0x90,0x90,0xE1,0xEF,0x73,0x3D,0xE7,0x69,
	0x9A,0x1A,0x06,0xAC,0xCC,0xC8,0x13,0xA3,0x7A,0x2F,0xDE,0xD3,0x24,0x99,0xA6,0xF3,0xA7,0x43,0xC9,0x62,
	0x13,0x4C,0xD3,0x34,0x4D,0x3B,0xE3,0xFF,0xD3,0x87,0x66,0xE8,0x49,0xA6,0x69,0x92,0x33,0x07,0xDA,0x77,
	0x1F,0x5E,0x34,0x4D,0xD3,0x34,0x37,0x17,0xEF,0xCB,0xA3,0x69,0x9A,0x24,0xD3,0x83,0x4B,0x3C,0x1B,0x0E,
	0xDB,0xD3,0x24,0x99,0xA6,0xE7,0x9A,0x4F,0x25,0x67,0x6E,0x4C,0xD3,0x34,0x4D,0x4B,0xB7,0x93,0xFE,0xC3,
	0x23,0x42,0x9A,0xA6,0x69,0x92,0x12,0x46,0x63,0xA6,0xC3,0xC0,0x1E,0xAA,0x69,0xFA,0xF2,0x26,0x87,0x75,
	0xCC,0xCF,0x5C,0x66,0x8F,0xA2,0x65,0xE0,0x69,0x9A,0x06,0xF3,0x43,0x8F,0x93,0xC3,0x24,0x2F,0x89,0xBA,
	0x8B,0x26,0xC9,0x34,0x4D,0xEB,0xF7,0xDE,0x2A,0xA0,0x07,0x63,0x9A,0xA6,0x69,0x9A,0x32,0xC2,0xD3,0xE2,
	0x93,0x34,0x4D,0x92,0x69,0x83,0x97,0xCF,0xE6,0xC3,0xEB,0xCC,0x4F,0x4D,0xD3,0x13,0x07,0x03,0x3F,0x9A,
	0x26,0x87,0x79,0x43,0x5A,0x93,0x7B,0x06,0x76,0x98,0x8F,0x62,0x47,0x1C,0x26,0x91,0x63,0x06,0x02,0x06,
	0x22,0x46,0x4D,0x92,0x69,0x9A,0xC2,0x9A,0x37,0x0D,0x62,0x0E,0x3C,0x4D,0xD3,0x34,0xC7,0xF2,0xE7,0xCE,
	0x39,0xCC,0x4D,0x0D,0xA3,0x9B,0xFE,0x16,0xC0,0xD3,0x34,0xDA,0x4B,0x33,0x03,0x10,0x63,0xD3,0x4A,0x4A,
	0x6E,0x7F,0x61,0x74,0x69,0x77,0x7D,0x06,0x40,0xD0,0x00,0xBE,0x92,0x9F,0x89,0x96,0xBB,0x8B,0x8C,0x81,
	0xF4,0xB0,0x9D,0x81,0x89,0x9D,0x87,0x8A,0x84,0x9F,0xB0,0x79,0x0C,0xBC,0xB3,0x83,0x88,0x94,0x8C,0x9B,
	0xC1,0x84,0x9F,0xA3,0xBF,0xA4,0xB4,0xB7,0xB8,0x88,0xAB,0xA3,0xBE,0xAE,0x9A,0x32,0x2D,0x3A,0xA8,0xA9,
	0x6B,0xFC,0x0D,0x25,0xEB,0xD1,0xD2,0xD0,0xF3,0xD7,0xC1,0xCB,0x63,0x79,0x76,0xF0,0xB6,0x52,0xD0,0x21,
	0xD0,0xE5,0xDC,0xA1,0x84,0xF8,0x67,0x00,0x60,0x40,0xC9,0x57,0x59,0xCB,0x63,0xE8,0x46,0x99,0x14,0x3A,
	0xC1,0xC1,0xD0,0xD6,0x07,0x00,0x00,0xA0,0x40,0xB2,0x7C,0x45,0xCE,0xFE,0xDD,0x37,0xCD,0x43,0xDF,0xF5,
	0x01,0xCA,0xD1,0xEB,0xEF,0x69,0x4C,0xDC,0xA6,0xE3,0xB9,0x79,0xC8,0x6E,0x00,0x00,0x20,0x6F,0xAA,0x47,
	0xAC,0x76,0x4C,0xF2,0xE1,0xB8,0xC2,0x25,0x51,0x11,0xCD,0xD8,0x21,0xB7,0xEC,0x76,0xE7,0xB1,0xCC,0x00,
	0x00,0x44,0x00,0xB4,0xD7,0x6B,0xCA,0x03,0x87,0x59,0xE2,0x67,0x64,0xEC,0x49,0xA4,0x20,0xAC,0x40,0x37,
	0xF9,0xAE,0xC9,0x0D,0x70,0xA9,0xC0,0x4A,0x9D,0xAE,0x79,0x46,0xF3,0x0D,0xD7,0x38,0x56,0xAB,0x99,0x44,
	0x34,0xDF,0xA2,0x8E,0xCF,0x12,0xCD,0x28,0x38,0xD2,0x33,0xA7,0xAB,0x5E,0x5C,0x93,0x4F,0x63,0x80,0xF4,
	0x68,0x04,0xBD,0x1D,0xFB,0x3A,0xC9,0x4D,0x23,0x78,0x00,0x00,0x00,0x00,0x43,0x3C,0x9C,0xD5,0x54,0x84,
	0xCE,0x3F,0x9B,0x7E,0xE2,0x72,0xCC,0xD5,0x37,0xD4,0x97,0xB7,0x56,0xF3,0x5C,0x59,0xE6,0xBB,0x88,0x5C,
	0xEA,0x2F,0xAC,0x36,0xFB,0xA6,0x40,0x04,0x00,0x00,0x43,0x60,0x30,0x6F,0x37,0x60,0xEA,0x2B,0xF6,0x15,
	0x0B,0xF1,0xE0,0x3B,0x63,0x5C,0xF2,0x89,0xED,0x62,0x22,0xEF,0x22,0xE5,0x1A,0x0F,0x28,0x00,0x00,0x00,
	0x00,0xF9,0x9D,0x3C,0x9F,0xAB,0xCB,0x8F,0x20,0xD7,0x6D,0xF8,0xB5,0xD6,0x36,0xCA,0x46,0x22,0x57,0x85,
	0x66,0x30,0x71,0x27,0xB1,0x4C,0x1B,0x74,0x8D,0xCA,0x07,0xFE,0x07,0x00,0x00,0x00,0x22,0xB7,0xCF,0xF6,
	0x5A,0x15,0x14,0x6B,0x37,0x1D,0x77,0x8A,0x3B,0xF7,0x95,0x9B,0x16,0xF3,0xAC,0x90,0xD4,0x55,0xE2,0xE8,
	0x2A,0xAD,0x67,0x8A,0x4F,0x15,0x00,0x00,0x2D,0xD0,0x06,0xB1,0x8A,0x92,0x0E,0xD2,0x45,0x60,0x6D,0x1C,
	0x9E,0x40,0x46,0x8B,0x49,0xC3,0xA3,0x43,0x34,0xCF,0x20,0x1C,0x90,0xDB,0x9A,0x0F,0x7D,0x00,0x00,0x00,
	0x60,0x3F,0xAC,0xD0,0xF6,0x3A,0x7D,0xB8,0x63,0xB8,0xC5,0xD2,0x7F,0x59,0xC0,0x58,0x9F,0x83,0x7C,0xFB,
	0xF3,0xEC,0x9B,0x98,0x5A,0xAA,0x87,0xDC,0xC2,0x11,0x00,0x10,0x01,0x17,0xBB,0x4B,0xE6,0x9D,0x33,0xC7,
	0xD3,0xD5,0x7B,0x4E,0xA1,0x05,0x71,0x24,0x8A,0x49,0xAC,0x98,0xD3,0x6D,0xC3,0x76,0x10,0x01,0x00,0xF0,
	0x2E,0xA8,0xB7,0x7B,0x39,0xCA,0x6C,0x02,0x40,0x6C,0xAD,0x7F,0xA2,0xFC,0xF6,0x27,0xA7,0xA0,0x71,0x01,
	0xFF,0x00,0x5A,0x2B,0x4C,0x73,0xCB,0xC1,0xA6,0xC1,0xDC,0x33,0x00,0x00,0x00,0x00,0xB4,0x98,0x50,0x79,
	0x6A,0x2F,0xEC,0x11,0x4C,0x87,0x46,0x23,0xC1,0xDE,0x3F,0xF1,0xBA,0x89,0x66,0xF4,0xF9,0x70,0xC5,0x0D,
	0xF3,0xF1,0xCE,0xE0,0x25,0x53,0x7C,0x6F,0x9A,0x1D,0x00,0x00,0x6D,0xFA,0x0D,0xFB,0x98,0xB3,0x8D,0x9C,
	0x27,0x44,0xC7,0xAC,0x51,0x2B,0xFE,0x30,0xC9,0xEB,0x32,0x00,0x60,0x7B,0x85,0xEE,0xBE,0x3F,0x43,0x98,
	0x42,0x3C,0x85,0x05,0x42,0x48,0xDA,0x1F,0x26,0x2B,0xA6,0x01,0xB1,0x71,0x50,0x70,0x60,0xF2,0x82,0x73,
	0x3D,0x46,0x14,0x20,0x02,0x57,0x2D,0xD4,0x73,0xB1,0x90,0xEB,0x4A,0x0E,0xB9,0x21,0xCE,0x35,0x84,0x9E,
	0x4C,0x1E,0x5D,0x00,0x31,0x13,0x16,0x1A,0x99,0x88,0x49,0xE0,0x6C,0x8F,0x30,0x07,0x45,0xF3,0x3C,0x0B,
	0x43,0x04,0xC9,0xE4,0x3B,0x33,0x34,0x33,0x36,0x39,0x38,0x22,0x19,0x24,0x37,0x44,0x72,0x18,0x3F,0x23,
	0xF4,0x95,0xF7,0xCF,0x74,0x00,0x00,0x00,0xC0,0x87,0x4B,0x1D,0xBC,0xC8,0x9B,0x5A,0x0F,0x4D,0x9C,0xCF,
	0xE5,0x71,0x89,0x5F,0xB9,0xF0,0xD3,0x98,0x1A,0x65,0x38,0xF1,0x54,0xB6,0x6E,0xC2,0x21,0x61,0xC6,0xA6,
	0x0F,0x00,0x00,0xF7,0xF2,0xB5,0x3B,0x96,0xC0,0xD3,0xC3,0xF5,0x90,0xA0,0x57,0x82,0x5F,0x99,0x8F,0x9C,
	0xC0,0x83,0xE2,0xD1,0xEA,0x30,0x4C,0xE2,0x57,0x9B,0x3E,0x79,0x46,0xD2,0xED,0xE9,0xF5,0x58,0x9E,0x39,
	0x8C,0xF9,0x51,0x08,0x10,0x39,0xC6,0x06,0x97,0xE5,0xE6,0x4C,0x34,0x91,0x10,0x64,0xF8,0xDB,0x40,0xC7,
	0x3B,0xE9,0x4D,0x25,0x24,0xD5,0x0D,0x34,0x4D,0x0E,0x83,0x65,0x6B,0x71,0x4F,0xEC,0x34,0x4D,0xD3,0x4B,
	0x55,0x1D,0x0B,0x9F,0x26,0x87,0x0D,0x27,0xC3,0xE3,0xD8,0x6F,0xA6,0x31,0xAD,0x23,0x3F,0x4F,0x92,0x69,
	0x72,0xBB,0xE3,0x25,0x2C,0x6B,0x6F,0x3D,0xED,0x03,0x17,0x69,0x9A,0x26,0x9A,0x2F,0x21,0x3F,0x49,0x7C,
	0xAF,0x9A,0xA6,0x9B,0x7F,0x59,0x13,0x77,0x4C,0xCF,0xCD,0x4D,0xD3,0x34,0x4D,0x33,0x15,0x71,0x47,0xBD,
	0xEB,0x65,0x0D,0x19,0x34,0x29,0x87,0x65,0x5C,0x6B,0x22,0xB6,0x47,0x4D,0xD3,0x23,0xA6,0x45,0x03,0xD7,
	0x3F,0x87,0x4E,0x37,0x74,0x76,0x4C,0x6F,0x55,0x2C,0x2E,0xA5,0x39,0xA7,0x16,0x15,0xDB,0x9B,0xA7,0xAB,
	0xA6,0x17,0x9F,0x18,0xC9,0xE1,0xFD,0xE8,0xC4,0xB1,0x47,0x69,0x9A,0x88,0xED,0x5B,0x21,0xD1,0xB7,0xB5,
	0x62,0xFA,0x98,0x16,0x71,0xAD,0x41,0x67,0x9B,0xA6,0x1F,0x97,0x17,0x55,0xB3,0xD3,0x44,0x1D,0xD3,0x25,
	0x39,0x22,0x86,0x35,0x4D,0x3B,0x4B,0xA7,0x77,0xFF,0xA5,0xA6,0x69,0x6F,0x51,0x0D,0x4C,0xCF,0x61,0x2E,
	0xA9,0x5F,0x88,0x69,0x4D,0xF4,0xA3,0x9D,0xF3,0x74,0x13,0xB1,0xE8,0xCF,0xD9,0x86,0x55,0xFA,0x38,0x4F,
	0x7C,0x6A,0x32,0x3D,0x0D,0xD3,0x34,0x4D,0x3F,0x9D,0xAB,0x7F,0x3F,0x3D,0x87,0x3E,0x4D,0x8F,0x6D,0x54,
	0x4D,0x1F,0xAE,0x19,0x51,0xCD,0xB3,0x8B,0xD8,0x9D,0x38,0x5C,0xFD,0x28,0x1B,0x3B,0x8B,0xE7,0xA5,0x87,
	0x51,0x06,0x11,0xD3,0x43,0x33,0x26,0xE2,0xD3,0x7D,0x5F,0x17,0xE4,0xB0,0x69,0x9A,0xF1,0xFB,0x85,0x87,
	0x9F,0xA7,0x98,0xDE,0x89,0xB6,0x45,0xF1,0xAD,0xB7,0xAF,0x44,0x5C,0x6B,0x22,0xF3,0xF3,0x25,0x06,0x62,
	0x70,0xD3,0x27,0xD9,0x8C,0x89,0x88,0x8B,0xF9,0xEA,0xA5,0x02,0x60,0x95,0x54,0x03,0x50,0x96,0x99,0x90,
	0x9B,0x94,0x9D,0x79,0xED,0x38,0xAA,0x52,0x76,0xB1,0x00,0x6F,0xFB,0x5E,0x1D,0x64,0x0C,0xEA,0xB0,0xB0,
	0x14,0x5A,0xB7,0x43,0xD5,0x2C,0x30,0xFC,0xE1,0xFA,0xE3,0xF2,0xE5,0xEE,0x45,0x26,0xAA,0x88,0x3C,0x28,
	0x1A,0x36,0x73,0xBD,0x1C,0x32,0x11,0x34,0x8B,0x2A,0xFE,0xD9,0xD4,0x53,0x9A,0xC1,0x4D,0xE1,0xCF,0xC5,
	0x14,0x2E,0xAA,0x30,0x28,0xE2,0x05,0x6B,0x37,0x23,0xFF,0xB1,0x7F,0x5A,0xA5,0x9F,0x2C,0x9B,0xCB,0x83,
	0x35,0xDB,0x9D,0xBD,0x01,0x98,0x4E,0xDF,0x20,0x65,0x26,0x67,0x50,0x69,0x4C,0x6B,0x96,0x91,0xAA,0xE5,
	0x7E,0x74,0xB1,0x9D,0x3A,0x48,0xD2,0x4E,0x45,0x53,0x54,0xC4,0x4A,0x28,0x3D,0x2B,0x6A,0x73,0x85,0x54,
	0x3E,0xAD,0x16,0xB0,0xC9,0x7C,0x98,0xC5,0x4A,0x76,0x20,0x5A,0xBB,0xBC,0x4F,0x77,0xE6,0xB3,0x93,0xCF,
	0x13,0x0C,0xB2,0x5E,0xAE,0x8C,0x5D,0x20,0x22,0x7A,0x46,0x7D,0x05,0x24,0xEB,0x69,0xB5,0x04,0xF3,0x56,
	0x4C,0x2B,0x5B,0x45,0x51,0x54,0xC8,0xC2,0xD6,0xE2,0x7A,0x23,0x7B,0x61,0xFB,0xBC,0x9A,0x2F,0xA5,0x48,
	0x76,0xF4,0x2F,0xB7,0x14,0xD3,0x2B,0x7A,0x8D,0x3D,0xA8,0x56,0xF4,0xFB,0xCC,0xE8,0x89,0xE9,0x19,0x87,
	0x92,0xE4,0x7B,0xFE,0xB5,0xB1,0xBD,0xBF,0x7D,0x5E,0xF6,0x15,0xFF,0x3C,0xCB,0xF1,0x3F,0x5F,0x77,0xCD,
	0xCB,0xE1,0x35,0x6F,0x3C,0x7F,0x68,0xB2,0x7B,0x45,0xB2,0xA0,0x9E,0x94,0x77,0xAF,0x8B,0x72,0x36,0xE8,
	0x9F,0x36,0x78,0x18,0xA8,0xE6,0x7F,0xFE,0xB6,0x2F,0x0F,0xD9,0x4B,0x06,0x99,0xEE,0xD5,0xE5,0xC0,0xFE,
	0xE2,0x1F,0x54,0x9F,0x97,0x65,0x9F,0x6B,0x24,0x6F,0xB4,0x28,0xFB,0xB3,0xCF,0xA3,0xC6,0xA4,0x7A,0xE6,
	0x17,0x45,0x51,0x04,0x68,0x15,0x6E,0x17,0x76,0x48,0x2A,0x3C,0x34,0xA2,0x03,0x85,0x40,0xA2,0xA5,0x15,
	0x3C,0x2A,0x9A,0xA8,0xB8,0x90,0x11,0x24,0xAB,0x50,0xB7,0xFA,0x56,0xAE,0xC8,0x6B,0xDE,0xE1,0xC6,0xEF,
	0x73,0xD5,0xCF,0x9A,0x91,0xD9,0x8C,0x67,0x97,0xEF,0x45,0xC6,0xB5,0x46,0xBC,0xD7,0xFF,0x1F,0xB8,0xD3,
	0x14,0x8A,0xAF,0x1F,0xDF,0xF4,0xB5,0x1D,0x4C,0x9F,0xEB,0x5E,0x23,0x04,0xC4,0xA1,0x8A,0xA6,0x7A,0x0A,
	0x05,0x74,0xBE,0x4C,0xAF,0xBA,0x6C,0x16,0x79,0x2A,0x5F,0x43,0xE9,0x75,0x2E,0x0C,0x90,0xC7,0xE7,0x5E,
	0x6B,0xE9,0x5E,0x3D,0x6D,0x1B,0xE6,0x77,0x9E,0x9F,0x26,0x77,0x89,0xF4,0x8A,0xEA,0x5C,0x2F,0x66,0x40,
	0x57,0x14,0x19,0xE8,0x36,0x04,0x30,0x73,0x85,0x68,0x3A,0x98,0x6D,0xF8,0xCC,0x7D,0x12,0x89,0xAA,0xE6,
	0xE8,0xEE,0xC3,0x5B,0xF1,0x19,0x9F,0xAB,0x7C,0xF5,0xBD,0xD9,0x75,0x78,0xF1,0x7A,0xAC,0x6F,0xE5,0x85,
	0x2B,0xC1,0xDB,0x0B,0x75,0x79,0x19,0xF2,0x3F,0x2B,0x1C,0xBA,0x18,0x44,0xBF,0x0F,0xAE,0x41,0xC9,0xE6,
	0xEB,0x7B,0x53,0x75,0xBA,0x82,0x35,0x32,0x73,0x7D,0x73,0x21,0xE8,0xDE,0x5F,0xBE,0xC9,0x4B,0x36,0xD7,
	0xC2,0xF3,0x7B,0xE7,0x32,0xAD,0x64,0xAE,0xC5,0x94,0x34,0xBF,0x52,0x15,0xCB,0x74,0x2E,0xF8,0x20,0x45,
	0x91,0xC5,0xF3,0x66,0x74,0x50,0x5C,0x85,0xCE,0x15,0x36,0xAE,0x3F,0x97,0xC8,0xB4,0x79,0x04,0x2F,0x3C,
	0xE9,0xAB,0x99,0x0B,0x9A,0xDC,0xDE,0xC4,0x25,0x9B,0xFA,0xB8,0x1E,0x2F,0x19,0x82,0xE3,0x4E,0x0E,0xFD,
	0xEC,0xE3,0xBD,0x46,0xBB,0x4A,0xE2,0x72,0x98,0xF3,0x3F,0x17,0x06,0xD7,0x85,0xEB,0x49,0x4C,0xAB,0xC6,
	0x65,0x65,0x1C,0xAF,0x77,0x3A,0xD3,0x6B,0x2C,0xBF,0xDB,0x1B,0xCD,0x6B,0x9F,0x7B,0xF0,0x2E,0xA8,0x2B,
	0xC9,0x7F,0x8E,0xB8,0x5C,0x50,0x3D,0xD4,0x5B,0xF2,0x32,0xCB,0x27,0xC7,0xFB,0x97,0x29,0x8D,0x6D,0xA2,
	0xF8,0x11,0xBC,0x3A,0x78,0xF7,0x17,0x45,0x00,0x40,0xE8,0x14,0xE0,0x16,0xC2,0x18,0x8E,0x1A,0x50,0x1C,
	0x16,0x1E,0xEC,0xBA,0x56,0xB4,0x0C,0x72,0x79,0x1C,0x38,0x52,0x14,0x45,0x4C,0x2A,0x0C,0x1E,0x61,0xF3,
	0x2E,0xE7,0xA5,0x47,0x5D,0x6F,0x8A,0x20,0x5F,0x53,0x46,0x59,0x44,0x2C,0xEF,0x1E,0x73,0x8B,0x45,0x0E,
	0xF3,0x56,0x6D,0x0B,0x8C,0x68,0x8F,0x22,0x5F,0x52,0x2A,0x84,0xA2,0x29,0x8A,0x5F,0x6A,0xC3,0x82,0xEA,
	0x1E,0xAE,0x68,0x8A,0xDD,0xB4,0xD0,0xD3,0x14,0x49,0xA7,0x9B,0xEE,0x91,0x9A,0xE0,0x7A,0x45,0xB3,0xBE,
	0xB9,0xBA,0x34,0x41,0xB3,0x28,0xAC,0x36,0xEE,0xE5,0x8A,0x22,0xE8,0x54,0xF6,0x8B,0x5A,0xC5,0x49,0xA0,
	0x1B,0xBC,0xA7,0x82,0x6D,0xD1,0x14,0xD2,0xFA,0xBC,0x44,0xAA,0x17,0xD9,0x2C,0x67,0xDF,0xA8,0x55,0x70,
	0x2D,0x22,0xFF,0x46,0xAF,0x61,0x66,0xAB,0xF9,0xC0,0x08,0x97,0xD7,0xBC,0xC8,0x2F,0x78,0x22,0xF8,0x16,
	0x11,0x19,0xC6,0x05,0x28,0x45,0xC4,0xE0,0x8B,0x2F,0x4B,0x30,0x8A,0x22,0xA8,0x16,0x69,0x1A,0xB6,0x2D,
	0x51,0x64,0x44,0xAB,0x33,0xD0,0xB2,0x58,0x34,0x4D,0x58,0x2C,0x0A,0x1B,0x5C,0xA8,0x26,0xBA,0x28,0xB4,
	0x40,0x91,0x50,0x34,0x1D,0xAE,0x36,0xC5,0xDB,0xB3,0xA3,0xC8,0x66,0x5B,0x59,0xB3,0x45,0x16,0x8B,0xA6,
	0xA9,0x61,0x61,0x9C,0x65,0x9A,0x22,0xE6,0x52,0x7F,0xBA,0x36,0x8A,0xA6,0x48,0x28,0xAE,0x1F,0xB5,0xE5,
	0xD0,0x68,0x8A,0xA4,0x3B,0x1E,0xF8,0xD7,0x7E,0x51,0x64,0xB1,0x8D,0x2B,0x96,0x98,0x22,0xA3,0xD9,0x8D,
	0x0A,0x82,0xF0,0xAD,0x68,0x8A,0xE1,0x02,0xFC,0x08,0x8E,0x15,0x4D,0x5C,0xE6,0x7D,0x82,0xC4,0x34,0xAE,
	0xA2,0xBE,0x2B,0x77,0x08,0xB2,0x45,0x51,0x72,0xBD,0x1A,0xD1,0x76,0x17,0x79,0xA8,0xF2,0x53,0x73,0x8A,
	0xA6,0xC8,0x68,0x2B,0xA1,0x5F,0x8C,0xC7,0x22,0xA1,0x68,0x20,0x23,0xF7,0x6C,0x0A,0x54,0x51,0x04,0x88,
	0x49,0x0E,0x33,0x34,0x09,0xD5,0xAD,0x3C,0xDF,0x36,0x45,0x0E,0xB3,0x58,0x7D,0xB5,0xFE,0x15,0x8B,0x22,
	0x62,0xD1,0xC1,0x3E,0x14,0x94,0xC8,0x61,0x46,0x98,0x17,0x38,0x9C,0x69,0x8A,0x26,0x69,0x27,0xCB,0x19,
	0xC1,0x4D,0x70,0xA8,0xA2,0x00,0xFD,0x36,0x0C,0x6A,0xA1,0xCC,0xF6,0x5C,0x82,0xC5,0x45,0x6F,0xDE,0x76,
	0xD7,0xCD,0x15,0x99,0x2D,0x6E,0x08,0xFB,0xA6,0x68,0x8A,0x88,0xF4,0x6F,0xC4,0x16,0xE9,0xAA,0x16,0x2F,
	0x8A,0x63,0x96,0x45,0x42,0x91,0x34,0x9C,0x21,0x95,0xB5,0x50,0x14,0x19,0x14,0x3B,0x41,0xB3,0x1C,0xAA,
	0x32,0x52,0x91,0x8C,0x98,0x41,0x14,0x49,0xA3,0x75,0x9D,0x24,0xE0,0x79,0xAC,0x2A,0x80,0x66,0x59,0x7D,
	0x82,0xC5,0x50,0x44,0x34,0x8F,0xDE,0x70,0xC6,0xE9,0x14,0x4D,0x91,0x49,0xDE,0x57,0x99,0x63,0x51,0x34,
	0x3D,0xEE,0xA1,0x85,0x43,0x8B,0xAE,0xA2,0xC8,0x95,0x3A,0x6E,0x14,0x19,0xD1,0x6B,0xDE,0xD9,0x4F,0x15,
	0x4D,0x53,0xD8,0xB2,0xF4,0xEF,0xAC,0x68,0x8A,0x88,0x90,0xF6,0xA7,0xDB,0x5E,0x37,0x45,0xF0,0xCC,0xE5,
	0xA5,0xAB,0x8B,0x26,0x09,0x63,0xF7,0x7D,0xDB,0x5C,0xE5,0x6C,0x09,0xFF,0x98,0xCA,0x57,0x6E,0xC2,0xF3,
	0xEE,0xCD,0x32,0x2D,0x74,0xAE,0xE7,0xAA,0xC1,0xAB,0xBC,0x0B,0x32,0x65,0x79,0x11,0xDA,0x9B,0xD7,0x75,
	0x70,0x9F,0xF8,0xDC,0x7D,0xEA,0x64,0x26,0x78,0x02,0xAF,0x5E,0x44,0xEE,0x15,0x00,0xC7,0xE6,0xFA,0x14,
	0xAA,0x16,0x7A,0x18,0x1C,0x1A,0xAA,0x17,0xAF,0x2B,0x73,0x6C,0x47,0x4D,0x91,0x41,0x2A,0x2E,0x31,0x24,
	0x45,0x0E,0xB3,0xB8,0x2B,0x1E,0x43,0x6A,0x8A,0x88,0xE5,0x78,0x58,0x6F,0x16,0x4D,0x52,0xCF,0xAE,0x14,
	0x4B,0x6B,0x8B,0xA6,0x88,0xC8,0x40,0x61,0x38,0x7E,0x7A,0x55,0x04,0x85,0x31,0x51,0x2A,0x33,0xB9,0x3B,
	0x7E,0x93,0xAB,0xCC,0xE5,0x22,0xA2,0x53,0x14,0x8E,0xC1,0xAA,0xA6,0x48,0x28,0x9A,0x26,0x8D,0xFC,0x84,
	0xBD,0x16,0xD7,0xD1,0xAB,0xB5,0x63,0x62,0x73,0x15,0x55,0x64,0xB6,0xE8,0xDB,0xBF,0xD8,0xF2,0x28,0x9A,
	0xA4,0x72,0xC4,0x61,0xD7,0xA2,0x48,0x28,0x32,0xB9,0xA8,0x90,0xD3,0xFD,0xE6,0x6A,0x04,0xC9,0x4C,0x93,
	0xAF,0xD1,0x64,0xC2,0x26,0x45,0xD3,0x14,0x11,0x81,0x1F,0xC6,0x03,0xEC,0x7D,0x56,0x85,0x42,0x44,0xF4,
	0xA2,0x8A,0x1E,0x49,0xB5,0xAA,0xC7,0xAB,0xB1,0xCD,0xAB,0x4C,0x62,0x9E,0x55,0x54,0x5D,0xF9,0x65,0x8A,
	0x84,0xA2,0x29,0x27,0x44,0x73,0xF2,0xA3,0xE8,0xCA,0xA0,0x68,0x20,0x0C,0x6D,0x20,0x73,0x15,0x3D,0xA7,
	0x66,0x9F,0x14,0x59,0x2C,0x9A,0x9D,0x75,0xA2,0x28,0x88,0x49,0x7C,0x51,0xA0,0x96,0xA0,0xA2,0x69,0x8A,
	0xA6,0x19,0xB5,0xE7,0x16,0xDC,0xFC,0x99,0xCF,0x55,0x83,0xB3,0x2F,0x2B,0x57,0x12,0xD1,0x14,0x45,0xC6,
	0xE7,0xE3,0xE0,0x9A,0xAB,0x9A,0x60,0x5B,0x50,0x38,0xE4,0x36,0xDD,0x45,0x7F,0x47,0xB1,0xA0,0xA2,0x29,
	0x32,0x85,0xC9,0x45,0xB1,0x0E,0x56,0x35,0xC1,0x6A,0x64,0x34,0x45,0xC4,0xA1,0x8B,0xC9,0x4A,0x91,0x76,
	0xB5,0x2A,0x9F,0x8D,0x51,0x78,0x95,0xC3,0x2C,0xF1,0x1B,0x18,0xDC,0x28,0x2A,0x1C,0x30,0x12,0x8A,0xA6,
	0xC8,0x92,0x06,0x5B,0x48,0xA7,0x64,0xF1,0xB9,0x2A,0x0D,0x18,0x6A,0x8A,0x20,0xDB,0x9C,0xD8,0x17,0x29,
	0x93,0x90,0x31,0xBC,0xBA,0x3A,0x89,0x69,0x15,0x4D,0x9C,0x88,0x17,0xEB,0x55,0x0F,0x57,0xAB,0x11,0x54,
	0xCA,0xF6,0x13,0x6A,0x44,0xAA,0x8D,0xE3,0x2A,0x33,0xB9,0xA2,0x53,0x11,0x47,0x4F,0xC5,0xD9,0xD5,0xC6,
	0x55,0x34,0xC1,0xB4,0x32,0xA0,0x14,0x5E,0x5D,0x14,0x45,0x53,0xB7,0xA6,0x79,0xD4,0xFE,0xC3,0xBA,0x62,
	0xA6,0x81,0x56,0x8D,0x2C,0x26,0x22,0x1E,0xAA,0x44,0xB0,0xEC,0x08,0xB3,0xAD,0xAA,0xD9,0x13,0xD3,0xAB,
	0x11,0x68,0x16,0x4D,0x91,0x74,0x59,0xF1,0x54,0xCB,0x8A,0xA6,0x88,0x78,0x8C,0x49,0xCD,0xA6,0x54,0xEE,
	0x0A,0x8D,0xEB,0x1A,0x91,0xCA,0x90,0xB9,0xAA,0x91,0x85,0x63,0xD1,0xCD,0xC8,0x8C,0x11,0x2C,0x3B,0x57,
	0xF2,0xBC,0xEA,0xF1,0x2A,0x63,0xD1,0xCD,0x50,0x5D,0x18,0xBF,0xAC,0x5C,0x85,0x3C,0xC5,0xAB,0x4E,0x2E,
	0x86,0xAA,0x6E,0xAE,0x12,0x99,0xAB,0x42,0xE7,0xE5,0xBA,0x1F,0x13,0xAB,0x22,0x96,0xE5,0x06,0x09,0x16,
	0xEF,0x2A,0x9B,0xAC,0x3A,0x73,0x5D,0x25,0x6B,0xEA,0xE5,0x2A,0x91,0xB9,0x4A,0x6C,0xAE,0xED,0xE6,0x2A,
	0xF1,0x3C,0x9D,0xEB,0xD6,0x2A,0xC5,0xE7,0xAE,0x5F,0x14,0xF9,0xB9,0xD4,0x58,0x7A,0xB5,0xC6,0xBD,0xEA,
	0x68,0x8A,0x98,0xC9,0x2B,0x3C,0x32,0x29,0x9A,0x22,0xA1,0x12,0x3B,0x0A,0x3A,0x00,0x20,0x70,0x35,0xE0,
	0x4A,0x5E,0xC1,0xAA,0x84,0x32,0x51,0x8A,0xA6,0x88,0xD8,0x56,0xE0,0x6D,0xF6,0x8B,0x98,0x43,0x5D,0x78,
	0xD4,0xDD,0xF9,0xFB,0xF9,0xBC,0x22,0x19,0xF4,0x17,0x4A,0x8A,0x94,0xAE,0xC6,0xF2,0xEB,0x90,0xE8,0xAA,
	0x9B,0x72,0x98,0xD1,0xAE,0xC1,0xF5,0x45,0xF2,0xF8,0x2A,0xC4,0x8F,0xF1,0x70,0x2C,0x82,0xC1,0xA2,0x9B,
	0xB6,0xAB,0x4A,0x57,0x8C,0xD7,0xB8,0x16,0x4D,0xC4,0xF9,0xEB,0x82,0x55,0x55,0xE5,0x2A,0xCE,0x89,0x9B,
	0xAA,0x32,0x32,0xCC,0xF0,0x9A,0x56,0x55,0xCC,0xB0,0xAA,0x4D,0x57,0x44,0xF9,0xF6,0x88,0xFC,0x45,0x36,
	0x1C,0xCE,0xAB,0x68,0xBA,0x53,0x1E,0x38,0x4D,0x58,0x45,0xCE,0xB1,0x3C,0x9D,0x29,0x9A,0x22,0xA2,0x60,
	0x01,0x58,0x35,0xDD,0xA8,0xEF,0x55,0x04,0xAA,0x29,0x32,0x9E,0x79,0x6A,0xE3,0x81,0xAB,0x4A,0xF0,0xE8,
	0x55,0x7D,0x0D,0x27,0x75,0x8F,0xA2,0xE9,0x73,0xCC,0x26,0x6D,0xAE,0x62,0xAA,0x08,0xE9,0x8C,0x67,0x55,
	0x91,0x1F,0x0A,0x55,0x4D,0x90,0xC8,0x00,0xF3,0x2A,0xB1,0xB8,0x49,0x1C,0xC5,0xAB,0x4C,0x72,0x8E,0x7F,
	0x45,0xE2,0x86,0xE0,0xDE,0x6C,0x0C,0xAF,0xF8,0x94,0x87,0xAB,0xE7,0x12,0x8A,0xA6,0x88,0x87,0xA7,0xB0,
	0xE3,0x4A,0xE7,0x51,0x99,0xAB,0xDE,0xFD,0x53,0x55,0xC6,0xA6,0xA8,0x0A,0x1A,0x55,0x8E,0x11,0xC5,0xAF,
	0x36,0x1A,0xAE,0x32,0x36,0x75,0xCC,0xEA,0x24,0x24,0xC3,0xF4,0x50,0x25,0xB6,0x65,0xB0,0x0A,0xAA,0x8A,
	0xAD,0x74,0xF1,0x45,0xD1,0xF4,0xF7,0x05,0xEF,0x9A,0x56,0x68,0x8A,0x98,0xE9,0xA9,0x73,0x1B,0xF0,0x8B,
	0x22,0xA1,0xE6,0x01,0xCF,0x98,0xCB,0x5C,0x57,0x44,0x3E,0xB9,0xCA,0xCE,0x55,0xB8,0x3A,0x49,0xE3,0x97,
	0x92,0xD1,0xDD,0x06,0xAE,0xEB,0xD1,0xA8,0xC8,0x66,0x12,0xD3,0x3F,0xB2,0x99,0xBD,0x2A,0x53,0x1D,0xBA,
	0xAA,0x08,0xC0,0xF4,0xEB,0x6B,0xD3,0x7F,0xC2,0x86,0x5E,0x15,0x39,0xDB,0x14,0xCD,0x95,0x8A,0x22,0x19,
	0x2B,0x36,0x76,0xD0,0x55,0x14,0x11,0xA3,0x40,0x45,0xF8,0x5E,0x15,0x6A,0xD4,0xF2,0xAA,0xE8,0x6B,0x8C,
	0x24,0x1C,0x9F,0xAB,0x4A,0xD1,0x24,0x14,0x45,0x60,0x95,0x92,0xE4,0xF0,0xB9,0x3A,0x45,0x42,0x73,0xB9,
	0xB8,0x8D,0x98,0xC7,0xF9,0x0C,0xBB,0xA2,0x93,0xFD,0x5C,0xA7,0x96,0x8D,0xAA,0x12,0x8A,0x4E,0xD1,0xF5,
	0x1B,0x5E,0x25,0x41,0x79,0x55,0xC8,0xCB,0x42,0x2A,0x91,0xEB,0x73,0xCB,0xF0,0xAA,0x91,0x6C,0xE7,0x32,
	0x9E,0xD7,0x65,0xEA,0x86,0x5E,0xB5,0x78,0x75,0xD5,0x8A,0xB9,0x18,0x25,0x5A,0x62,0x73,0x55,0x62,0x7B,
	0x55,0x86,0xD7,0x87,0xCF,0x5B,0xA0,0xAB,0x08,0x1E,0x1D,0xC7,0xF0,0xAA,0x3F,0x52,0x7C,0xAE,0xCA,0xAB,
	0xCA,0x14,0xAF,0xAE,0x1A,0x11,0xDB,0x3D,0x55,0x45,0xF4,0x7C,0xD6,0x62,0x91,0xB9,0xAA,0xCA,0x02,0xB9,
	0x3A,0x4D,0x56,0x10,0x41,0xAA,0x7E,0xA9,0x70,0x93,0xB9,0x0A,0xC5,0xBF,0xC4,0xE4,0x2A,0x88,0x69,0xC1,
	0xE5,0x36,0x74,0x4D,0xFC,0x77,0x8A,0xBA,0xA2,0xFF,0xE9,0x62,0x66,0x66,0x35,0xFE,0xAA,0x7C,0x98,0xAA,
	0x2C,0xBB,0xCE,0x9B,0x3A,0x5F,0x10,0xED,0xB1,0x57,0x8D,0x5E,0x25,0xAA,0x22,0x21,0x33,0xF3,0x9B,0x88,
	0x66,0x53,0x77,0xF1,0x91,0x5D,0x35,0xD8,0x55,0xAE,0xBA,0x19,0x32,0xB9,0xF0,0xE8,0x6A,0x91,0x55,0x53,
	0x24,0xDD,0xAB,0xFD,0x9F,0x08,0x87,0x64,0x7B,0x94,0x00,0xFE,0xE8,0xB8,0x76,0xFB,0xA2,0x8A,0x4A,0x9B,
	0xE8,0xAA,0xF3,0xFA,0x07,0xD1,0xAB,0x1A,0xB3,0xBE,0x7D,0x66,0xBB,0x66,0xF5,0xEA,0x44,0x55,0x71,0xA8,
	0x8A,0xFC,0x20,0x68,0x57,0x35,0x45,0x13,0xE5,0x0D,0x62,0xCC,0x62,0x78,0xD5,0x8E,0xBA,0xFD,0xE8,0x63,
	0x45,0x8B,0xA6,0xC8,0xA1,0x7E,0x45,0xFC,0xB3,0x32,0x48,0x5E,0x15,0x6C,0x1E,0xE6,0xEA,0xA4,0xDB,0x6B,
	0x67,0xAE,0xE7,0xC5,0xBC,0x6F,0x66,0x3E,0x57,0xA7,0x88,0xE0,0x55,0xEF,0xA3,0x73,0x55,0xC4,0x18,0x93,
	0xB9,0x2A,0x21,0xD6,0xE0,0xFB,0xAD,0xFA,0x64,0x8A,0x6C,0xE0,0xEA,0x37,0xAC,0x2A,0x55,0x7D,0xF2,0x38,
	0xD5,0x4D,0x11,0x11,0xCF,0x56,0x97,0xC4,0x55,0x9D,0xCA,0x74,0xEA,0xF3,0x87,0x04,0x75,0x72,0x55,0x19,
	0x9A,0x17,0x22,0x57,0xA3,0x1C,0x74,0x55,0x08,0xB5,0x5A,0x14,0xC1,0xBE,0x13,0x10,0xCF,0x55,0x93,0x57,
	0x1C,0x8B,0xAE,0x86,0x08,0xE4,0xEF,0xB0,0xBF,0x11,0x9D,0x2A,0x14,0xC9,0xF0,0xB0,0x01,0x62,0x73,0x5E,
	0xAF,0x54,0x75,0xA2,0x7A,0x55,0x2D,0xAF,0xF2,0x7B,0x02,0x46,0x4C,0xE6,0xFF,0xF9,0xF0,0xEA,0x46,0xAF,
	0x1C,0xCF,0xAB,0x42,0x9E,0x57,0x49,0xA6,0x27,0x5E,0x85,0xE5,0xD5,0x2A,0x57,0x23,0x38,0x64,0xD5,0xC9,
	0xF4,0x08,0xE4,0xDC,0x5C,0xF5,0x73,0x67,0xDD,0xB9,0x2A,0x83,0x20,0x1A,0x99,0x4C,0xE7,0x0D,0x67,0x73,
	0xD5,0xC0,0xD5,0x8A,0x46,0xD5,0xA1,0x7D,0x88,0xDC,0x55,0x56,0x75,0x82,0x48,0xC8,0x82,0x57,0x8F,0xFC,
	0x86,0x3A,0x53,0xB9,0x22,0x80,0xC5,0xAB,0x7A,0xE8,0x6A,0xE7,0xAA,0x32,0xD2,0x0D,0x97,0xAB,0xAB,0x1B,
	0xB9,0xAA,0x2A,0x8D,0x0B,0x95,0xB9,0x2A,0x0C,0xAF,0x53,0x77,0x45,0x70,0xAE,0xBA,0x5E,0x95,0x4A,0x7F,
	0xCE,0x55,0x27,0x18,0x1E,0x39,0xA2,0xD7,0xD5,0x2F,0x22,0x73,0x5D,0x70,0xE7,0xAE,0x12,0xD1,0xEA,0x89,
	0x4A,0x45,0xD5,0x6A,0xCC,0xE7,0x26,0xF7,0x95,0xA6,0x73,0xE5,0xBE,0x22,0x3E,0x08,0x50,0x34,0x45,0x4E,
	0xD2,0xD2,0xD2,0xD0,0xA1,0x0A,0x45,0x91,0xDF,0xC5,0xC4,0x57,0x75,0xFC,0x54,0xC9,0xBC,0xEB,0xE7,0x95,
	0xC0,0xB1,0x9B,0x1A,0x9B,0xEA,0x32,0xA8,0x50,0x24,0xAC,0xA6,0x49,0xF7,0x34,0x45,0x98,0x96,0x86,0x8B,
	0xFF,0x7A,0x35,0x71,0x0B,0x8D,0x4A,0x3E,0x7B,0x18,0x3C,0xC0,0x15,0x5C,0x24,0x08,0xF3,0xCD,0x20,0xE2,
	0x30,0xC4,0x31,0x04,0x19,0x44,0x90,0xD8,0x57,0x1C,0x32,0x08,0x41,0xC4,0xE4,0x66,0x4C,0xF4,0xC8,0x20,
	0x83,0x08,0x71,0x78,0x83,0x84,0x60,0x9E,0x25,0x6F,0x0C,0xEA,0x63,0x90,0x41,0xC4,0x31,0x04,0xE1,0xD8,
	0xD7,0x41,0x06,0x19,0x64,0xCD,0xCB,0xB1,0x2C,0xE2,0x38,0x94,0xBE,0x2F,0xA6,0x19,0x64,0x10,0x71,0x9D,
	0x94,0x83,0x64,0x90,0x41,0x06,0x8A,0x70,0x7E,0x38,0x26,0xC7,0x1B,0xEB,0x89,0xEF,0xF6,0x83,0xD2,0x7C,
	0x5F,0x5F,0xCB,0x1F,0xFB,0xB4,0x77,0x7E,0x3E,0x2B,0xB8,0xA4,0x9D,0x91,0xAE,0x64,0x80,0xBC,0x58,0x3C,
	0xF6,0xA7,0x34,0xCA,0x63,0xE9,0xD8,0xE9,0x30,0xCC,0x2C,0xD4,0x0D,0xA3,0x6E,0xA7,0x28,0xD8,0x24,0xC4,
	0x2C,0x7C,0xAA,0x69,0x75,0xE0,0x9C,0x6E,0x8F,0xDA,0x55,0xFB,0xB0,0x2B,0x8F,0xF3,0xA9,0x5D,0x1C,0x1F,
	0x14,0x59,0xD5,0x98,0x91,0x64,0xD5,0xC7,0xB7,0x19,0x55,0xF3,0xEC,0x50,0x1D,0xBA,0x16,0x8F,0xAE,0xA4,
	0xAB,0x75,0x2C,0xDA,0xCF,0xA7,0xC4,0xF1,0xA9,0xC5,0xF3,0xF6,0x57,0x7C,0x5B,0x4F,0x3D,0x8F,0xAB,0xFF,
	0xF1,0xE9,0xC3,0xFD,0xCD,0xB7,0x6A,0x37,0xC5,0xA3,0xAA,0xD8,0x5F,0xF1,0xFC,0xC0,0xC4,0x80,0x5F,0xFE,
	0x15,0xD1,0xD4,0xC9,0xC6,0x03,0x13,0x19,0xC8,0x1B,0xCF,0xCE,0x72,0xC5,0xB2,0x43,0x03,0xAC,0x7C,0x2A,
	0x34,0xB0,0x91,0xC8,0xB3,0xB3,0xEC,0x72,0xB5,0xB9,0x4C,0xC3,0x48,0x8E,0xAB,0x32,0xB9,0x87,0xCF,0x82,
	0xF8,0x4C,0x23,0xA8,0xBC,0x87,0x7C,0x21,0x88,0x44,0xB2,0xA8,0xF8,0x50,0xFE,0x7F,0xE4,0x1C,0x92,0xC3,
	0x26,0x97,0xA4,0xBC,0xEA,0x24,0x0F,0xCB,0x35,0xCB,0xC8,0xDB,0x5C,0xD1,0x82,0x28,0x8A,0x00,0xF8,0xD0,
	0x18,0x00,0x1B,0x32,0x1D,0x6F,0x54,0x14,0xD3,0xDA,0xA1,0xD8,0x5C,0x87,0x28,0x82,0x28,0x28,0xFC,0xD3,
	0xA0,0xD1,0x6A,0x26,0xF8,0xC8,0xDC,0xCA,0x22,0x69,0x98,0xAC,0xF1,0x74,0xF9,0xBF,0xC2,0x9B,0x9A,0x48,
	0x13,0x69,0x10,0xF1,0x86,0xB6,0xF8,0x5E,0x7B,0x75,0x13,0x89,0x44,0xEC,0x27,0xEB,0xA0,0xB1,0x3A,0x1C,
	0x31,0xCC,0xA3,0x52,0x98,0x4D,0x1E,0x23,0xC1,0x98,0xFC,0x74,0xF2,0x6D,0x6A,0x4E,0xE4,0xB0,0x69,0x22,
	0xEF,0xF3,0x29,0x41,0x8D,0x48,0x24,0xA2,0x89,0x1E,0x4C,0x1B,0x72,0x13,0x1D,0x08,0x38,0x0D,0x1C,0x49,
	0xDB,0x22,0x91,0x30,0x5C,0x37,0x10,0xED,0x37,0x89,0x44,0x72,0x18,0x13,0x8E,0xAF,0x1A,0x29,0x1C,0x22,
	0x4E,0x33,0x49,0x13,0x1B,0xF3,0x67,0x15,0x57,0xBF,0x92,0x86,0xD1,0xB2,0x37,0xFA,0xF4,0xFF,0xE0,0x58,
	0x0C,0x0B,0x18,0xFC,0x9C,0xD4,0x57,0x6C,0x73,0x2E,0x49,0xAB,0x60,0x77,0x73,0x5A,0x7C,0x20,0x72,0xD2,
	0xBF,0x44,0x7A,0x6C,0x66,0x8D,0x79,0x8E,0x52,0x46,0xA8,0x18,0x67,0x1A,0x2C,0x82,0x9C,0x9B,0x9D,0xB3,
	0xB6,0x93,0x73,0xCD,0x54,0xCB,0x9A,0x8D,0x99,0x06,0x80,0x8C,0xA2,0xA2,0xBF,0xAE,0x82,0xA8,0xA6,0xA3,
	0xAA,0xA0,0xFC,0x16,0x72,0x86,0x6A,0xD0,0xC8,0xEB,0x2E,0x72,0xD4,0xFC,0xDA,0x0A,0x91,0xB1,0x0D,0xCD,
	0xFC,0xF8,0xDD,0xF3,0x07,0x15,0xD3,0x32,0xC6,0xFA,0xC0,0x8D,0xA5,0x2D,0x86,0x20,0x00,0x07,0xD8,0x3A,
	0x8B,0x0E,0xD3,0x1E,0xC3,0x13,0xBF,0xBB,0x1E,0x24,0x13,0x52,0x31,0x0D,0x7E,0x67,0x43,0x5C,0x6E,0xFE,
	0xE5,0xC2,0x88,0x5F,0x62,0x61,0x64,0xB3,0xCA,0x56,0x6D,0x7C,0x79,0x0C,0xD1,0x4C,0xCB,0xA3,0x68,0xDE,
	0xDA,0xF2,0x0B,0xCF,0x6B,0x73,0x2C,0x65,0x34,0x61,0xB6,0xA0,0x8D,0xD9,0xE6,0x1F,0x55,0xDF,0x35,0x88,
	0xE3,0xE7,0x4C,0x42,0xD7,0x7B,0xE0,0xAC,0xAD,0xF7,0xBE,0xC6,0xFD,0xEF,0x0A,0x2C,0x5E,0xE9,0xF8,0xFD,
	0xBF,0xD3,0xB8,0x3F,0x0A,0x10,0xA3,0xF4,0xEE,0xF0,0xF0,0xE7,0xED,0xF6,0xEE,0x41,0xD0,0x1A,0xA2,0x0E,
	0x1B,0x1A,0x01,0x00,0x3A,0xFC,0xD5,0x97,0x04,0x58,0x88,0xAB,0xC3,0x08,0xC4,0x77,0x87,0xF2,0x14,0xEB,
	0x65,0x8A,0x6D,0x17,0x15,0x8E,0x51,0xE7,0xAE,0x63,0x67,0x25,0x92,0x5C,0x20,0xEE,0x5B,0x5E,0x00,0x19,
	0x5A,0x4E,0x47,0x98,0x7F,0xA7,0x67,0x0E,0x1D,0x22,0x7F,0x57,0x94,0x83,0x62,0x49,0x50,0x05,0x6A,0x45,
	0xA5,0xA5,0xAD,0xE9,0x41,0x2C,0xB3,0x4A,0x4C,0xBA,0x18,0x1F,0x56,0x15,0xAD,0x68,0xA3,0xFB,0x00,0xAB,
	0x6E,0x71,0x77,0x62,0x89,0x93,0xCB,0x24,0x7E,0x2D,0xF3,0xA8,0xA9,0x92,0xBC,0xE2,0x07,0xA2,0x5C,0x97,
	0x8E,0x87,0xAC,0x9A,0x95,0x89,0x81,0x85,0x0A,0x20,0xA1,0xA3,0xB2,0xB3,0xAF,0xB2,0xA8,0xBB,0xB2,0x8B,
	0x8A,0xFB,0x88,0xA0,0xA3,0x09,0x8B,0xB6,0xB1,0xBA,0xAA,0x44,0x7D,0xED,0xF1,0xE9,0xB5,0xBC,0x1D,0x6E,
	0x97,0xAA,0xCD,0x5B,0x1E,0xBA,0xBE,0xC7,0x8C,0x0E,0x33,0xD3,0xE2,0xE9,0xC5,0xDF,0xC4,0x03,0xF3,0xB6,
	0x79,0x39,0xBB,0x50,0x5C,0xD7,0xF2,0x9B,0xC3,0xBB,0x66,0xE5,0xAC,0x2E,0x99,0xE3,0x56,0x51,0xD7,0xE1,
	0x90,0x2F,0x0F,0x0F,0x0A,0x00,0x00,0x00,0xE8,0xED,0xC3,0x8A,0x28,0x96,0xA6,0xDA,0x1A,0xE4,0x4B,0x53,
	0x2C,0x9E,0xAF,0x3F,0xDB,0xC9,0x1E,0xB2,0xA7,0xA7,0x0C,0x59,0x0B,0xFC,0x01,0x82,0x01,0x00,0x00,0x00,
	0x61,0x90,0x6A,0x70,0xA1,0x70,0x4F,0xD8,0x2C,0xB1,0x85,0x47,0x7B,0xBE,0xA2,0x34,0x65,0xA1,0xCA,0xED,
	0xBE,0xB7,0x72,0x10,0xEB,0x8B,0x76,0x03,0x61,0x93,0x65,0x02,0x00,0x20,0x67,0x7C,0x09,0x5F,0x29,0x8F,
	0x9C,0x1C,0x3E,0x5C,0xA5,0x28,0x50,0xAE,0x1D,0xD4,0x7C,0x53,0x72,0xDC,0x17,0x03,0x97,0xB5,0x74,0x6A,
	0x7A,0xB6,0xCC,0xEC,0xD7,0x08,0xB1,0xF0,0x57,0xB6,0x62,0xB2,0xB8,0xDF,0xF5,0x8C,0xD4,0x88,0xC2,0xBF,
	0x1C,0xE2,0x42,0x1D,0x36,0x2F,0x9A,0x84,0x83,0x21,0xAF,0x0E,0xF5,0x99,0x5D,0xA1,0x72,0x3B,0xB1,0x99,
	0xB9,0x9C,0x41,0xA9,0xBF,0x86,0x43,0x95,0xA0,0xF4,0xAA,0xA0,0xB3,0xC5,0xAC,0x6A,0xFA,0xE9,0xE1,0x8E,
	0x55,0xD3,0x11,0xC6,0xD8,0xFB,0x97,0x28,0x44,0x17,0xD1,0xCE,0xC1,0xAD,0xF0,0x8B,0x20,0xCD,0xCC,0xFD,
	0xEC,0x3A,0x97,0x2A,0x73,0x54,0x9F,0xB7,0xE8,0x55,0x67,0xBA,0x4C,0x2E,0xA2,0xF6,0x16,0x16,0x22,0x0C,
	0x40,0x71,0x68,0xC2,0x30,0x07,0x13,0x01,0xFA,0x29,0x4B,0x5A,0x25,0x0D,0x76,0xFD,0xF0,0x15,0x68,0xB9,
	0x3A,0x85,0x48,0x2E,0x4E,0x0A,0x8A,0x74,0x12,0x10,0x0F,0x11,0x02,0x02,0xEB,0x71,0x42,0x18,0x1E,0x42,
	0x19,0x57,0x85,0xCB,0x2B,0x3F,0x04,0x1D,0x0B,0x0E,0x50,0x32,0x15,0x61,0x7E,0xB2,0x74,0xD3,0x93,0xE6,
	0x82,0xBE,0x57,0x47,0x40,0xBA,0x64,0xA6,0xBA,0x3D,0x03,0x40,0x6E,0xA2,0x6E,0x68,0x71,0xAE,0x72,0x6A,
	0x6B,0xAA,0x61,0x6C,0xA9,0x35,0xFA,0x75,0xCD,0xA1,0x6D,0x95,0x96,0x86,0x9F,0x94,0x9C,0x92,0xE5,0xFA,
	0x2B,0x9B,0x88,0x9A,0x8A,0x7D,0x54,0x87,0x86,0x51,0xD3,0xB6,0xDD,0xB9,0xFE,0x61,0x9A,0xB6,0x66,0xA3,
	0xFA,0x80,0x89,0x5D,0x36,0x87,0x93,0x9B,0x81,0x84,0x95,0xF7,0xB9,0xDD,0x31,0x5D,0xF4,0x0E,0x5C,0xA1,
	0xBB,0xB6,0x04,0xBE,0x64,0xED,0xD2,0xD1,0x72,0xF8,0xE5,0x32,0xCE,0xCE,0x76,0xCE,0x59,0x75,0x98,0x67,
	0xE2,0xB2,0x8E,0xE0,0xBD,0x8D,0xA6,0xED,0x78,0xFF,0xE2,0xB3,0x00,0x06,0x93,0xFE,0x80,0x41,0x34,0xC3,
	0xE8,0x99,0xAA,0x34,0x19,0x64,0x90,0xB3,0xBC,0xC5,0xC2,0x4D,0xD3,0x34,0x19,0xCB,0xD8,0xDD,0xD2,0xD0,
	0x34,0x4D,0xD3,0x34,0xED,0xEB,0xF8,0xFE,0xE4,0xD3,0x34,0x4D,0xD3,0xE3,0xE1,0xE0,0x1E,0x26,0x4D,0xD3,
	0x34,0x4D,0x2D,0x24,0x3C,0x24,0x2C,0x25,0x34,0x4D,0xD3,0x34,0x1E,0x67,0x60,0x62,0x64,0xD3,0x34,0x4D,
	0xD3,0x6E,0x58,0x5B,0x2E,0x30,0x4D,0xD3,0x34,0x4D,0x34,0xCF,0xDA,0xC6,0xC1,0xFC,0x34,0x4D,0xD3,0x34,
	0xC8,0xCB,0xDE,0xD1,0xB3,0xD3,0x34,0x4D,0xD3,0xBD,0xB7,0xA8,0x59,0x59,0x2F,0x1B,0x34,0x4D,0x68,0x6E,
	0x73,0x22,0x1E,0x35,0x4D,0x43,0x7C,0x72,0x6B,0x69,0x9A,0xA6,0x69,0x0C,0x04,0x1A,0x2D,0xBE,0xC4,0xB4,
	0x9A,0xA6,0xAD,0x9A,0xF4,0x49,0x2E,0x5F,0x5D,0x29,0x6B,0x92,0x69,0x9A,0xA6,0x70,0x82,0xD2,0xE7,0x29,
	0x0F,0x49,0xA6,0xC9,0x61,0x50,0x96,0xC8,0xF8,0xFC,0xBE,0x9A,0x24,0xD3,0x34,0x72,0x34,0xE4,0xED,0xBB,
	0x70,0x32,0x4D,0x92,0x69,0x3C,0xF7,0xDA,0xAA,0x6D,0xD0,0xD7,0x24,0x99,0xA6,0x49,0x83,0x5F,0x1D,0xDC,
	0xC4,0xDD,0x69,0x92,0x4C,0xD3,0x19,0x68,0xAA,0xB5,0xE1,0xD4,0x93,0x64,0x9A,0xA6,0x0D,0x72,0x6F,0x92,
	0x92,0x8C,0x24,0xD3,0x34,0x4D,0xB6,0xA8,0xAB,0x88,0x76,0x85,0xAF,0x49,0xA6,0x69,0x9A,0xDB,0x12,0x6D,
	0xA4,0x68,0x07,0x48,0xA6,0x49,0x32,0x98,0x63,0xE5,0x5F,0x30,0x5E,0x9D,0x55,0x95,0x83,0x6A,0x92,0x49,
	0x12,0xD9,0xA2,0xAA,0x36,0x2F,0xFE,0x6A,0x92,0x7B,0xF5,0xDF,0xE4,0xE5,0xE8,0xD5,0x24,0xF5,0x8A,0xBB,
	0x91,0x57,0x92,0x49,0x4F,0x0D,0xDE,0xC5,0x4A,0x32,0x49,0x26,0x86,0x5F,0xEE,0xFE,0x94,0xE3,0x2E,0xA6,
	0x49,0x22,0xF3,0xBC,0xE4,0x4B,0xDC,0x8C,0x87,0x22,0x91,0x48,0x14,0xF2,0x13,0x54,0x11,0xB0,0x14,0x91,
	0xD8,0x9D,0x94,0x0A,0xB4,0x04,0x89,0xDC,0xAB,0x86,0xF9,0x30,0x01,0x12,0x09,0x5D,0x12,0x0E,0x04,0x1A,
	0x09,0x0E,0x26,0x89,0xC3,0x24,0x32,0x15,0xF3,0x48,0x1C,0xC2,0x2D,0x4D,0xD3,0x34,0x49,0x67,0xFF,0xAE,
	0xA1,0x9E,0xD2,0x8B,0xF2,0xDB,0x34,0x4D,0x2B,0xCC,0xE5,0xA7,0xBC,0x94,0xD6,0xEF,0x47,0x73,0x5B,0x12,
	0x8F,0xEB,0x6E,0xA3,0xA5,0x49,0x7C,0x9C,0x87,0xD1,0xC6,0x96,0x23,0x7B,0x4E,0xCF,0xE3,0x58,0x33,0x4D,
	0xE5,0xA2,0xF2,0xE6,0x60,0x43,0x9D,0xCB,0xCA,0xA1,0xD9,0x2E,0x3A,0x27,0xF7,0x11,0x22,0x91,0x48,0x24,
	0xB3,0x5A,0xE6,0x43,0xF5,0x58,0xB9,0x51,0x1B,0x67,0x24,0x12,0x89,0x44,0xB4,0x64,0x80,0x12,0x8F,0x08,
	0xE3,0x0E,0x28,0x44,0x22,0x91,0x48,0x0D,0xA8,0x6B,0x3D,0x66,0xE2,0x74,0xB2,0x7B,0x1E,0x3E,0x12,0x89,
	0x69,0x7E,0x69,0x7D,0x96,0x78,0x8E,0x51,0x97,0x48,0x67,0xC4,0x72,0x22,0x91,0x48,0x1A,0x3F,0x8D,0x72,
	0x90,0x57,0x67,0x23,0x5A,0x24,0x12,0x89,0x44,0x09,0x51,0xE6,0x5D,0xF6,0x58,0xED,0x57,0x3E,0x44,0x22,
	0x91,0x48,0x25,0x6E,0x28,0xC1,0x0F,0x51,0x0D,0x1D,0x0B,0x48,0x24,0x12,0x89,0x0E,0x31,0x71,0x27,0xA2,
	0x25,0x1B,0x32,0xD0,0x38,0x41,0x3F,0xA7,0x91,0xB5,0x41,0xB9,0x89,0x44,0xD2,0x30,0x9A,0xBE,0xE7,0xBE,
	0x80,0xBE,0x15,0xB9,0x91,0x48,0x24,0x12,0x5B,0xB0,0x4A,0xBB,0x1C,0x82,0x5C,0x84,0x23,0xB6,0x26,0x89,
	0x44,0x22,0xDA,0xB0,0x09,0xAD,0xE3,0xAE,0x77,0x9D,0x10,0xC1,0x04,0x48,0xA7,0xE5,0xE7,0x64,0xC3,0xB8,
	0x8F,0x71,0xDD,0xCA,0xD7,0x02,0x4C,0x33,0xE1,0xAF,0xD1,0x83,0xAE,0x00,0x11,0xF5,0x85,0x4E,0x79,0xC1,
	0x0D,0xD8,0xD0,0x19,0x13,0xDB,0x00,0x00,0x00,0x80,0xF0,0xF0,0xF3,0x67,0x9A,0x9A,0x99,0x6B,0x6A,0xDC,
	0xB2,0x6F,0x6A,0x07,0xDF,0x73,0xC2,0xC2,0xC1,0x77,0x4F,0x67,0xC1,0x7B,0x62,0x4A,0xC3,0x7F,0x3B,0x3C,
	0x12,0x49,0xC3,0x00,0xBC,0x03,0xBA,0xBA,0xB9,0x07,0x17,0x76,0x3B,0x12,0x2D,0x3E,0x89,0x34,0x4D,0x24,
	0x2A,0x22,0x27,0x22,0x20,0x1F,0x9B,0x1A,0xA4,0x61,0x3A,0x16,0x35,0x40,0xD3,0x4F,0x8F,0x30,0xD8,0xD9,
	0x7A,0x8C,0x4F,0xA6,0x7F,0x33,0x92,0x86,0x49,0xEE,0xD5,0x1B,0xD4,0xB7,0xE9,0xC9,0xF7,0xFE,0xEB,0xDB,
	0x3C,0xEB,0xBE,0x06,0xDB,0xB1,0xD3,0x44,0xBB,0xA7,0xEA,0xDB,0xE7,0xEA,0xEE,0x34,0xC9,0xA7,0x77,0x03,
	0x57,0x5F,0x13,0xEA,0xBB,0xEB,0x63,0x79,0x2E,0x8B,0xB3,0x29,0x5D,0x2C,0x0F,0xFA,0xA3,0xF6,0xB6,0xF7,
	0xF6,0xDF,0x8B,0xFA,0x56,0xF3,0x69,0x17,0xE4,0x59,0xFD,0x9D,0xAB,0xAE,0x1C,0xFB,0xBE,0xB3,0xAC,0x55,
	0x3C,0x62,0x53,0x1F,0x6B,0x4B,0x19,0xD5,0x7C,0x8A,0x97,0x8D,0x4D,0xC4,0xE3,0x52,0x8C,0x6A,0x72,0xE5,
	0x52,0xD7,0x34,0x65,0x68,0x44,0x2C,0xAF,0xBF,0x68,0x7E,0xD9,0x90,0xF1,0xE8,0x41,0x5D,0x2F,0x6A,0x90,
	0x0D,0x28,0xA8,0x01,0xFC,0xA1,0x45,0x29,0x9E,0xBD,0x33,0xD4,0x44,0xF1,0xEC,0x26,0xFC,0xF9,0x2D,0x68,
	0xA2,0x98,0xE7,0xFF,0xAA,0x7B,0xFB,0x6F,0xF2,0x7F,0xED,0xB3,0xFC,0x88,0xE6,0x79,0x2F,0xA2,0xB5,0xD6,
	0xD8,0x56,0x2D,0xB2,0xA1,0xC9,0xF8,0x84,0x9C,0x6F,0x3B,0x48,0x74,0x0B,0x64,0xDB,0xBB,0xD7,0xE8,0xF6,
	0x3D,0x61,0x91,0x5C,0x5F,0x58,0xE4,0x9A,0xAB,0x59,0xEB,0x71,0x8F,0x49,0x61,0x54,0x15,0xC0,0xC6,0x2D,
	0xC8,0x20,0x9A,0xB5,0xAC,0xD4,0x75,0xE0,0x9F,0x97,0x2D,0x88,0x58,0x93,0x00,0x80,0x8E,0x81,0xF5,0xED,
	0xF3,0xE2,0x16,0x0D,0x1A,0xC1,0x15,0x15,0x54,0xD4,0xDF,0x30,0xF7,0x5D,0xD3,0x80,0x08,0x3E,0xD3,0x5D,
	0x85,0xC7,0x33,0x02,0x0B,0x31,0x1E,0x22,0xB8,0x2F,0x80,0x34,0x32,0x30,0x30,0x73,0x1F,0x3E,0x34,0x3A,
	0x22,0xE4,0x81,0x9B,0xD6,0x06,0x02,0x15,0x07,0x0E,0x00,0xC0,0x04,0x00,0x39,0x34,0x2B,0x1A,0x79,0x58,
	0xB7,0xC9,0x37,0x37,0x37,0x27,0x24,0x26,0x21,0x3B,0x39,0x3F,0x32,0x07,0x0D,0x65,0x17,0xB4,0xBE,0x00,
	0xA4,0x67,0x4B,0x46,0x49,0x5D,0x71,0x72,0x6B,0xE9,0xC3,0x15,0x9E,0x3C,0xF9,0xD3,0xC3,0xA6,0x3C,0x38,
	0x03,0x93,0x23,0xAC,0xCF,0xCC,0x97,0xAB,0x33,0x4D,0xA3,0xAF,0xA7,0x8B,0x5D,0x10,0xF0,0x40,0xE5,0xF1,
	0xF2,0xDC,0xF8,0xBF,0xBA,0xE5,0xA0,0xD4,0x88,0x2A,0x52,0x49,0xD2,0xB6,0xA2,0xBF,0xDD,0xD7,0x1D,0xBB,
	0xC9,0xEF,0x8B,0x20,0x75,0xF1,0xD1,0x9D,0x7E,0xF4,0x97,0x04,0xB5,0x80,0x87,0x71,0x0A,0x1D,0x9C,0x83,
	0x98,0x95,0x8C,0xD3,0x44,0x9A,0x26,0x2F,0x50,0x60,0xA4,0xA9,0xE0,0xD0,0x89,0x34,0x4D,0xFC,0x2D,0x77,
	0x4B,0x26,0xA0,0x26,0x87,0x71,0x42,0x79,0x45,0x51,0x44,0x93,0xC3,0xC8,0x52,0x21,0xD8,0x9C,0x58,0x31,
	0x8C,0xD8,0x36,0x4D,0xDE,0x98,0xFE,0x82,0x41,0x27,0x87,0xB9,0xDE,0x3C,0x9F,0x4D,0x1A,0xC6,0x01,0xB8,
	0x0C,0xAD,0x99,0x3C,0xD4,0xE4,0x30,0x88,0xB8,0xE6,0xE5,0x00,0x00,0x10,0xC3,0xD8,0x82,0x15,0xCB,0xA8,
	0x3C,0xF7,0x6D,0x56,0x81,0x33,0xC9,0x5B,0x99,0x9B,0x60,0x26,0xD5,0x00,0x00,0x00,0x00,0x62,0x53,0xAD,
	0x17,0x94,0x34,0x4F,0x58,0xB8,0x23,0x71,0x4D,0xCC,0xEE,0x1E,0xBB,0x5B,0x4C,0xE8,0x09,0x29,0xC3,0xBC,
	0x5E,0x96,0x2F,0x19,0x83,0x4D,0xEA,0x5A,0x65,0xF1,0x00,0x00,0x00,0xCA,0x3A,0xB8,0xFD,0x66,0xA7,0xA5,
	0x48,0xFC,0xD1,0x2B,0x9B,0xA2,0xFB,0x42,0xD3,0x7B,0x41,0xBD,0x3C,0x41,0x01,0xC1,0x6C,0x75,0x00,0x00,
	0x50,0x6C,0x02,0xE8,0xF8,0x5E,0xA3,0x7B,0x68,0x0C,0xDD,0x25,0x61,0x88,0x1B,0x60,0xA5,0xE0,0x82,0xE6,
	0x6A,0xAF,0x00,0x28,0xD8,0xA0,0x44,0xF9,0x9E,0xF2,0x3E,0xDB,0xD8,0xCA,0x38,0x73,0xBA,0x00,0x00,0x00,
	0x00,0xA5,0x3E,0x2B,0x49,0x7A,0xBE,0x58,0x23,0xED,0x1B,0x5C,0xB1,0x15,0xF2,0x0E,0xD1,0xFF,0x15,0x41,
	0xF3,0xF9,0xDC,0x8F,0x26,0xDD,0x03,0xED,0x46,0x00,0xFC,0x7B,0x66,0x00,0x6C,0x9E,0x5D,0xD6,0x5A,0x6B,
	0x6D,0x22,0x52,0x90,0xAA,0x3A,0xDE,0x89,0x62,0xD8,0x01,0xA6,0x51,0x82,0x01,0x39,0x9E,0x07,0x1C,0xB9,
	0xC2,0x8E,0x2A,0xD9,0x14,0xC3,0x25,0x0B,0x70,0x36,0x2E,0x2F,0xC9,0x07,0xAC,0x7B,0xBB,0xBE,0xCE,0xA5,
	0x00,0x00,0x7D,0x10,0xDB,0x03,0x31,0xED,0x1A,0x04,0x1A,0x23,0x1F,0x0A,0x24,0x85,0xE0,0x08,0x16,0xE0,
	0x64,0x24,0x35,0x1A,0xE1,0x79,0x03,0x37,0x5D,0x4C,0xEC,0x37,0x1C,0x54,0x31,0xBC,0x2C,0x1E,0xEE,0x74,
	0xB9,0xA8,0x40,0xE7,0xDF,0x1C,0x9B,0xFD,0xFA,0x00,0x82,0x18,0x44,0x25,0xE5,0x2C,0xB5,0xDB,0x38,0x86,
	0xBF,0xBF,0xC0,0x9F,0x3E,0x39,0x22,0xD2,0x33,0x28,0xDE,0xEC,0x27,0x6B,0xFD,0xE8,0x73,0x91,0x8B,0xF3,
	0x0F,0x9A,0x7C,0xFF,0xA5,0xA4,0xE7,0x00,0x82,0x00,0x0C,0xD2,0xBC,0x80,0xF4,0x18,0x18,0x9B,0x0D,0x62,
	0x62,0xE1,0x11,0x3E,0x68,0x5B,0x1F,0x81,0xE4,0x1C,0x21,0x1D,0x02,0xA6,0x0D,0xEF,0xDB,0xA7,0x1D,0x14,
	0x9F,0x55,0x3D,0x47,0xD6,0x90,0xCF,0xA2,0x47,0x26,0x8B,0xCE,0xC5,0xC1,0x25,0xAE,0x45,0x0D,0xB7,0xB9,
	0x38,0xA0,0x8D,0xF0,0x5A,0x15,0x28,0x7B,0x9A,0x29,0x08,0x3A,0x16,0x00,0xB3,0x21,0x76,0x8D,0xA2,0x5E,
	0x01,0xDD,0x31,0x63,0x08,0x19,0xD8,0xAA,0x14,0x81,0x23,0x05,0x80,0x7A,0x0E,0x5E,0x10,0xA1,0xA7,0xD3,
	0x7E,0xA9,0x82,0xA2,0x75,0x26,0x31,0x6C,0x78,0x6D,0xFF,0x91,0xE3,0xED,0x52,0xE3,0x8B,0x00,0x80,0x48,
	0x8E,0xEB,0x85,0xCD,0xF2,0x94,0xE4,0x00,0x27,0x64,0x1A,0xDC,0xDC,0x46,0xDE,0xA9,0xE3,0x0D,0x00,0x88,
	0x00,0x23,0x9C,0x5E,0xFE,0x52,0x0F,0x41,0xD3,0xE5,0x49,0x9B,0x51,0x3A,0x82,0x0E,0x4C,0xA2,0x1F,0xA8,
	0x55,0xD9,0xEA,0xFE,0xC9,0xB1,0x11,0x71,0x2B,0x05,0xAC,0xE7,0x25,0x8E,0xBE,0xCF,0x14,0x06,0x00,0x50,
	0xDB,0xFF,0x25,0x90,0x41,0x5C,0x23,0xBE,0x11,0x70,0x0D,0xA5,0x23,0x3E,0x45,0x49,0x1B,0xE4,0xD0,0x9F,
	0xF7,0x07,0x78,0x72,0x9E,0xBD,0xE8,0x16,0x68,0xF0,0xE1,0x1A,0x78,0xCC,0xB0,0x97,0x9B,0x95,0xAE,0x9F,
	0x4B,0xC7,0xCA,0x95,0x92,0x43,0x41,0x54,0x2B,0xBD,0x3C,0x30,0x97,0xE5,0xB2,0x23,0x1C,0x60,0x72,0xED,
	0x0E,0x1D,0x03,0x0C,0xA1,0x2A,0x67,0xAD,0x80,0xD3,0x2A,0x20,0xA5,0xEB,0x18,0x7B,0xF4,0xED,0x0D,0x03,
	0xE5,0xF5,0xD2,0x3E,0x8C,0xA1,0x00,0xB5,0x91,0x3F,0x7A,0xD6,0xFD,0x97,0x73,0x76,0x6A,0x59,0x25,0x32,
	0x7E,0x9B,0x8A,0x68,0xCB,0xEF,0x33,0xA0,0x34,0x46,0x65,0x55,0xA7,0xF9,0xE9,0x63,0x99,0x2E,0xD5,0x1E,
	0xCB,0xD5,0xA4,0x49,0x87,0x73,0xC8,0x8A,0x32,0x3C,0x81,0x3E,0xA2,0x36,0x5D,0x30,0x5E,0x33,0x8A,0xFB,
	0xFA,0x1D,0xF3,0xA4,0x97,0x83,0x93,0xCF,0x43,0xEA,0xB4,0x9B,0x3C,0x36,0x4D,0xBF,0x97,0x43,0xA1,0x37,
	0xC0,0x22,0xFE,0x5E,0x55,0x41,0x5F,0x15,0xDC,0xDF,0xD6,0x93,0x31,0x80,0x7B,0xE1,0xDD,0xC2,0xDF,0xCF,
	0xCF,0x74,0x55,0x0D,0xE3,0x73,0x5D,0x39,0xB6,0x7F,0x75,0x9E,0x81,0xE2,0x08,0x74,0x63,0x26,0xAA,0x2B,
	0x1F,0x9B,0x31,0x1D,0x45,0x69,0x2F,0x25,0xBC,0x8F,0xEF,0xCA,0xBA,0x42,0x41,0x73,0x58,0x5D,0x4B,0x87,
	0xBF,0x0A,0xE2,0x5D,0x41,0x4A,0x2B,0xF1,0x0C,0x49,0x47,0x72,0x76,0x71,0x79,0x54,0x63,0x19,0xBF,0x46,
	0xEA,0xD2,0xD9,0x48,0x4F,0xB4,0x72,0x5B,0xF5,0xAF,0x34,0xD7,0x10,0x95,0x95,0x8B,0xB6,0x2A,0xD3,0xA2,
	0xB8,0xD1,0xC7,0x32,0x8D,0x8F,0x94,0xC9,0xB6,0x6F,0xAC,0xA7,0x19,0xB2,0x99,0xF8,0xE3,0x14,0xD1,0x00,
	0xED,0xD7,0xCC,0xE4,0xFA,0xE8,0xEE,0xC5,0x5E,0x55,0x44,0xCE,0x4D,0x36,0x8A,0xC9,0x29,0x4E,0xCA,0x3C,
	0xAB,0x99,0xEE,0xAA,0xB0,0x14,0xC0,0xC0,0x68,0xAF,0x50,0xE8,0xAB,0xFE,0x2B,0x21,0xFC,0xD9,0x75,0x59,
	0x08,0x2C,0xD2,0x0A,0x98,0x66,0x4D,0x7F,0x8B,0x28,0x68,0x45,0x73,0x65,0x2F,0x14,0xC8,0x59,0x46,0x5E,
	0x6E,0x63,0x72,0x4B,0x65,0x26,0x1A,0x0F,0x75,0x94,0x94,0x8A,0x56,0x75,0x8B,0xAF,0x83,0x81,0xAE,0xCD,
	0x82,0x7E,0x90,0xA6,0x19,0xB9,0x6F,0xAE,0xB5,0xD2,0xF1,0xF9,0x57,0xA0,0xAE,0x51,0x11,0xD8,0x72,0xBC,
	0x96,0xBC,0xEA,0x14,0x8F,0xAF,0xE8,0x52,0xBA,0xD6,0xD0,0xFB,0xD1,0xD8,0x25,0x9F,0xA7,0xAC,0xED,0x02,
	0x15,0x2A,0x52,0xCB,0xE6,0xF7,0x1A,0x2A,0xC9,0xF3,0x75,0x06,0x65,0x81,0xE1,0xEA,0x15,0x2B,0x85,0x9F,
	0x37,0x06,0x00,0x03,0x39,0x04,0xFD,0x69,0x0B,0xF5,0xA4,0x6A,0xD3,0x9E,0x36,0x35,0xAE,0xD4,0xDA,0xEA,
	0x4A,0x99,0xC9,0x37,0x02,0x49,0xB4,0x82,0xB0,0x17,0x12,0xA5,0x0B,0x05,0x6E,0x51,0x76,0x5C,0xFA,0x5D,
	0x51,0xA3,0x65,0x5F,0x62,0x2D,0xA4,0xBE,0x0A,0x42,0xC5,0xDA,0xB1,0x58,0x6F,0x4D,0x5D,0xBF,0xF5,0x13,
	0xDE,0xE0,0x5B,0xF0,0x83,0xA0,0x32,0x9B,0xB8,0x9C,0x41,0xB5,0xB7,0x8E,0x50,0x7D,0x51,0x21,0xE4,0xF5,
	0x78,0x7C,0xE2,0x72,0xA6,0xF0,0x95,0xCB,0x35,0x34,0x0F,0xBD,0x12,0x4E,0x95,0xFA,0x6F,0xBA,0xCE,0xCA,
	0xB7,0xBF,0x66,0xED,0x26,0xF8,0x55,0x1B,0x5E,0xE3,0x26,0xEC,0x00,0x75,0x1E,0xD9,0xC5,0xF1,0xB8,0x52,
	0xDE,0x16,0x75,0xB1,0xB1,0x4B,0x0E,0x1D,0x19,0x56,0x9E,0x81,0xF3,0x81,0x22,0x4B,0x4B,0x1D,0x3F,0x3E,
	0x93,0x7F,0x63,0x57,0x24,0xA3,0xCD,0xA7,0xE0,0x19,0x38,0x09,0x17,0x05,0x7B,0x3F,0x7E,0x3F,0x04,0x2C,
	0x32,0xD7,0x87,0x5F,0xE6,0xEA,0xD1,0xA9,0xA1,0xDA,0xE5,0xE7,0x7C,0xF8,0x07,0xDE,0x6F,0x21,0xBE,0x60,
	0x6D,0xA3,0x22,0x1E,0x95,0xA4,0xD9,0xBA,0xF9,0x4A,0xEE,0x57,0xD7,0x7A,0xB5,0xD7,0x79,0x56,0x89,0x46,
	0xB4,0x0A,0x80,0xB3,0xAE,0xCD,0xC2,0xF6,0xB5,0xE1,0xF0,0xFD,0xE6,0x51,0x2D,0x4B,0x7F,0xE5,0x02,0x93,
	0xFE,0xCB,0xD1,0x8F,0xF4,0x52,0xF1,0xEC,0xB9,0x90,0x93,0xE6,0x09,0x0A,0xE6,0x17,0xA1,0x10,0x1F,0x9B,
	0xEF,0x95,0x0A,0x13,0xF9,0x33,0x2A,0x0E,0x23,0xBF,0x6A,0x85,0x79,0x51,0x50,0xA4,0x51,0xF2,0x56,0x5D,
	0x46,0x70,0x5F,0x35,0xD5,0xB7,0x50,0x68,0x74,0x1D,0xFC,0x7F,0x52,0x83,0x1F,0x57,0x79,0x51,0x8A,0x60,
	0x55,0x0F,0x7D,0xDB,0x22,0x7D,0xBE,0x96,0x79,0xA6,0x94,0xD3,0x18,0x5D,0xB8,0x3A,0x33,0xEC,0x28,0x95,
	0x89,0x90,0x4A,0x03,0xCC,0x20,0x43,0x9B,0x8F,0xA8,0xC4,0xC0,0xDE,0xFA,0x61,0xEB,0x6F,0xC8,0x16,0xEC,
	0x36,0xDF,0xD4,0xB4,0x2E,0x9F,0xFE,0x05,0xD3,0x4F,0x6E,0xCE,0x75,0xF5,0xB8,0xB0,0x3B,0x13,0x42,0x9D,
	0x7E,0xA7,0x50,0x67,0x72,0x87,0xFB,0xD7,0x73,0x3D,0x5B,0xA4,0x71,0x0B,0x3D,0x21,0xC7,0x7C,0x9D,0x90,
	0x70,0x49,0xB2,0x1F,0x0A,0x23,0x28,0x0E,0x30,0x91,0xA8,0x9C,0xC9,0x68,0x2C,0x40,0x42,0x5A,0x4B,0x76,
	0x26,0x60,0x8F,0x22,0x54,0x4F,0x51,0xA6,0xCE,0x53,0xAE,0x6F,0x78,0x14,0xCF,0x81,0x68,0x52,0x7E,0x7D,
	0x60,0x78,0xEA,0xE8,0xB6,0xB5,0x6D,0xAC,0x07,0x55,0xE6,0x86,0x9F,0x47,0xFC,0x05,0xA1,0x80,0x83,0x80,
	0x8D,0x46,0xCF,0xFA,0x48,0x56,0x58,0x64,0xC9,0x1E,0x2B,0x84,0xB1,0xB9,0xA5,0xCA,0x86,0x13,0xDE,0xCC,
	0xCD,0x89,0x43,0xF1,0xC0,0xD5,0xC6,0xD2,0x2D,0xC8,0xF5,0xD7,0x9B,0xB7,0x84,0xA4,0xA0,0x3B,0x6D,0x40,
	0x92,0x9C,0xF3,0xDA,0x1B,0xD5,0x02,0x75,0xF2,0x16,0x14,0xAD,0x83,0x44,0x45,0x4B,0x38,0x2E,0x35,0x2B,
	0x3B,0x31,0x2A,0x6F,0x02,0x7C,0x08,0x02,0x12,0xB6,0x0A,0xCF,0x20,0x3B,0x05,0x06,0x08,0x16,0x69,0x27,
	0xE2,0xBE,0x3E,0x89,0x4B,0x39,0x9A,0x1C,0xE1,0xB8,0x4F,0x2E,0x8E,0xF9,0xDD,0x3D,0x59,0x6F,0xE1,0x9E,
	0x48,0x4E,0x16,0xC4,0xA5,0x5B,0x5E,0x7C,0x0D,0x7A,0xD2,0xFD,0x63,0x00,0x00,0x20,0xC6,0x2C,0xCC,0x18,
	0xC6,0x87,0x9A,0x26,0x11,0xB3,0x19,0x89,0xD9,0xF8,0xD8,0x00,0x3D,0x08,0xAC,0xB3,0x74,0xE6,0xF5,0x90,
	0x87,0x89,0x65,0x90,0x60,0xF4,0x02,0xA3,0x98,0x46,0xAB,0x2B,0xD2,0x34,0x39,0x0C,0xD0,0xCD,0xBD,0xA1,
	0xB5,0x49,0x6D,0x34,0x3D,0xEC,0x31,0xCC,0x51,0x99,0x6D,0xFC,0x36,0x4D,0xD3,0xB1,0x65,0xA9,0x1D,0x61,
	0x89,0xDB,0x1E,0x9B,0x05,0xE6,0x9D,0xEA,0xB3,0xA7,0xA7,0xC1,0xB9,0xA4,0x3F,0x07,0x2F,0x21,0x1D,0x0E,
	0x1E,0x0A,0xF4,0xDB,0xD8,0xE7,0x19,0x08,0x70,0x57,0xF5,0x1C,0x36,0x00,0x0E,0x0B,0x50,0xD1,0xD0,0x16,
	0x48,0x1A,0x88,0x84,0x58,0xF7,0x46,0xC4,0xB7,0xAF,0xE1,0x16,0x1B,0x1B,0x2E,0xAD,0xD0,0x32,0x00,0x94,
	0xC9,0xD1,0xFA,0x45,0xE3,0xFE,0x3C,0x98,0x4E,0x32,0x3F,0x3E,0xC3,0x00,0x08,0xB0,0xB3,0x74,0x5A,0x01,
	0x9D,0xBD,0x5E,0xC1,0x1C,0x8B,0x81,0xD3,0x7C,0xDF,0x0D,0x9E,0xF1,0x09,0xC6,0x9A,0x4E,0x47,0x3C,0xB4,
	0xA6,0xB7,0xE7,0x7B,0x9E,0x1E,0x9E,0x6C,0xA4,0x84,0x8C,0xD3,0xD2,0x07,0xE6,0x58,0x2C,0x9B,0x22,0x2B,
	0x7D,0x85,0x16,0x13,0x89,0xA4,0x61,0xF5,0x17,0xA1,0xE8,0x9D,0xE0,0xED,0x18,0xCA,0x34,0x4D,0xD9,0x29,
	0x01,0xE9,0x28,0x22,0x91,0x34,0x0C,0xEC,0x15,0xD1,0x59,0xD6,0xE9,0xDB,0x65,0x3F,0x48,0xA6,0x49,0xC3,
	0xDC,0xDE,0x39,0xD3,0x55,0x3B,0x41,0x4D,0x0E,0x63,0x4C,0x48,0x0D,0x19,0x15,0x22,0x4D,0xD3,0x34,0x31,
	0x3D,0x29,0x25,0x6F,0xE1,0x4D,0xC4,0xB2,0x69,0xED,0xF9,0xE9,0xD1,0x00,0x00,0xC0,0x34,0xC9,0xC1,0x64,
	0x06,0xD0,0x30,0x00,0x69,0x72,0x61,0x44,0x4D,0x58,0x54,0x50,0x49,0x38,0x7E,0x69,0x62,0x43,0x7B,0x05,
	0x5A,0x5F,0x47,0x2C,0x82,0x01,0x6A,0x41,0x4E,0x4D,0x46,0x4E,0x4D,0x40,0x42,0x3D,0x68,0x63,0x58,0xC2,
	0x3C,0x20,0x63,0xE6,0xF8,0x15,0x11,0x00,0x08,0x0E,0x10,0x75,0x04,0x00,0x33,0x5B,0x18,0x1B,0x11,0x1C,
	0x19,0x0E,0x16,0x89,0x3F,0x1B,0x0B,0x2C,0x24,0x26,0x15,0x88,0x00,0x48,0x59,0x0F,0x21,0x11,0xE0,0xEE,
	0xFA,0xEB,0xE8,0xF7,0xD7,0xE5,0xDF,0xE9,0xE9,0x86,0xD0,0x94,0x01,0x44,0xFA,0xE9,0xE7,0xFC,0xC7,0xCD,
	0xCB,0xA9,0xCA,0xE0,0x98,0xCF,0x00,0xA8,0xCA,0xE4,0xE4,0xF5,0xDA,0xFA,0xDB,0x99,0xC3,0xC0,0xD1,0xD2,
	0x80,0x8E,0x89,0x70,0xD4,0xD5,0xC4,0xE4,0xC5,0xC4,0xDC,0xD2,0xE7,0xC3,0xC2,0xD4,0x49,0x03,0x02,0x8E,
	0x9E,0xA4,0xB4,0xAA,0x92,0xB7,0xBF,0x2A,0x6E,0xD0,0x37,0xB0,0xA8,0x97,0x85,0x98,0xA9,0xA2,0xAD,0x00,
	0x00,0x00,0x05,0xA2,0xA9,0xDD,0x24,0x9C,0xA3,0xA0,0xA2,0xA0,0xB9,0x86,0xF8,0x81,0xE0,0xE0,0x93,0xB2,
	0xB2,0x98,0x9F,0x87,0x87,0xA9,0x9B,0x67,0x00,0x00,0x00,0xB6,0xAC,0xB3,0xA7,0x91,0x80,0x10,0x07,0x88,
	0x18,0x87,0x85,0x9F,0xB9,0xAE,0x9E,0xFC,0x39,0x71,0x31,0x52,0x03,0x7F,0x79,0x05,0x03,0x31,0x03,0x20,
	0x51,0x79,0x51,0x79,0x47,0x66,0x7A,0x60,0x66,0x6C,0x5D,0x79,0x57,0xED,0x6F,0x3B,0x4F,0x49,0x92,0x43,
	0xC2,0x5A,0x4F,0x56,0x2B,0x56,0x5C,0xA6,0x0C,0x36,0x5C,0x5C,0x44,0x57,0x57,0x5A,0x47,0xC9,0x53,0xB2,
	0x4F,0x6A,0x7A,0x3D,0x58,0x04,0x7D,0x83,0x82,0x1A,0x12,0x33,0x10,0x15,0x2A,0x3F,0x26,0x22,0x2F,0xD0,
	0x18,0xAF,0x57,0x34,0x68,0x1F,0x2C,0x0E,0x24,0x22,0x00,0x00,0x00,0x36,0x0B,0x06,0x2B,0x38,0x04,0x7E,
	0x1B,0x2A,0x23,0x2B,0x45,0x3F,0x2A,0x30,0x50,0x05,0x7D,0x08,0x47,0x32,0x3F,0x02,0x1C,0x00,0x11,0x30,
	0xAE,0xC6,0x01,0x00,0xE9,0x5F,0x7A,0x41,0x0A,0xE0,0x20,0x1D,0xD5,0x37,0x1D,0x6C,0x40,0xFE,0xCF,0xD2,
	0xC7,0xB4,0x83,0xD2,0xFB,0xE7,0xF1,0xEA,0x3E,0x0F,0x1B,0x80,0xEC,0xE8,0xF6,0xCD,0xEF,0xCB,0xED,0xED,
	0xD7,0x0B,0xD0,0xF4,0x82,0xDA,0xD9,0x9E,0xE3,0xA2,0xE8,0xD5,0xCB,0x5B,0xEE,0x83,0xE0,0xC6,0x82,0x32,
	0x57,0xDB,0xDB,0xC9,0xE3,0xCF,0xC7,0xAF,0xD4,0xB9,0x50,0xA5,0xBB,0xC3,0xBC,0xAF,0x9A,0xA3,0x28,0x01,
	0x96,0x30,0x86,0x82,0xB6,0xA2,0x14,0x38,0x00,0x84,0xA9,0xFF,0xA4,0x03,0xA0,0xA1,0x85,0x94,0xBE,0x90,
	0x9C,0x7B,0x7D,0xF2,0x8C,0x9C,0x9B,0x56,0xAA,0x91,0x85,0x8E,0x21,0x80,0x21,0x35,0xF4,0x4F,0xEB,0x83,
	0x7F,0x01,0x00,0x19,0x83,0x9A,0xFC,0x52,0x6A,0x78,0x54,0x31,0x15,0x78,0x2D,0x77,0x7D,0x67,0x6D,0x45,
	0x11,0x23,0x65,0xBA,0x6E,0x68,0xA6,0x78,0x25,0x86,0x94,0xA1,0x48,0x49,0x4F,0x5D,0xDA,0x49,0x6F,0x57,
	0x4C,0x11,0x22,0x00,0x2A,0x4A,0x47,0x7B,0x56,0x6A,0x46,0x5B,0x71,0x3A,0x41,0x51,0x5D,0x72,0x54,0x03,
	0x0B,0x00,0x00,0x00,0x48,0xD3,0xA0,0x18,0x26,0x2F,0x30,0x2E,0x32,0x30,0x2B,0x3E,0x29,0x6B,0x21,0x39,
	0x3E,0x45,0x1B,0xCD,0x3D,0x3B,0x0C,0x38,0x00,0x32,0x3C,0x37,0x71,0x8F,0xC3,0x25,0x11,0x31,0xD8,0x43,
	0x9E,0x0A,0x08,0xA6,0x5A,0x7A,0x30,0x1D,0x04,0x25,0xB1,0x23,0x64,0x80,0x00,0x15,0x20,0x4F,0x1F,0x57,
	0x1F,0x14,0x14,0x1D,0xE7,0x57,0xA2,0xD3,0x1B,0x15,0xD0,0x87,0x30,0x1D,0x20,0xEB,0xDE,0xF0,0xFF,0xDA,
	0xF3,0xB0,0xFC,0x94,0xF6,0x70,0xCD,0x9C,0xE1,0x83,0x08,0xE3,0xFB,0xFC,0xF9,0xF9,0x70,0x19,0xCE,0x11,
	0xCD,0xB8,0x3A,0x5D,0xE8,0xC2,0xC9,0xDE,0xDB,0xDB,0xE9,0x21,0xC5,0xD5,0xD8,0x7F,0xDC,0xC4,0xEA,0x69,
	0xA5,0x4F,0x35,0xBE,0xAF,0x27,0x0D,0x00,0x49,0xEF,0x3C,0xEE,0xAA,0xA5,0xF2,0xBF,0xB8,0xC4,0xAE,0xFA,
	0xAF,0x24,0xB3,0x4D,0x11,0xA5,0x47,0x53,0xF3,0xA0,0xE2,0x8A,0x57,0x85,0xFE,0x02,0xB6,0x85,0x0D,0x15,
	0xEC,0xB3,0x02,0xC3,0xB2,0x60,0xDD,0x8D,0x1A,0x85,0x0C,0x00,0xA4,0xB6,0xF8,0xAF,0x63,0x6D,0x6E,0x48,
	0x68,0x3D,0x02,0x40,0x57,0x7C,0x7A,0x6D,0x34,0xA5,0x6B,0xB5,0x7A,0x6E,0x27,0x48,0x51,0xC4,0x80,0x72,
	0x3A,0x48,0x6B,0xD2,0x7D,0x29,0xD9,0x1E,0x5C,0xEE,0x4C,0xC0,0xDA,0xA1,0x50,0x47,0x70,0x0C,0x0F,0x39,
	0x42,0x49,0x2F,0x0E,0x2D,0xD8,0x05,0x61,0x2B,0x73,0x3B,0x06,0xE7,0x00,0x61,0x8B,0x89,0x2F,0xC7,0x03,
	0x69,0x09,0x2F,0x43,0xC6,0x25,0xED,0x9C,0x9D,0x98,0xA5,0xCF,0x11,0x27,0x8C,0xF8,0x7A,0xF6,0x6E,0x29,
	0xF0,0x61,0x3E,0x35,0x07,0xDE,0x2B,0x19,0x0D,0x2C,0x8B,0x2D,0x8A,0x84,0x0C,0x0F,0x04,0xEF,0x0F,0x4B,
	0xFC,0xA8,0x29,0xEA,0x74,0x0C,0xA4,0xFA,0xD0,0xA7,0xDC,0xF3,0x93,0xF2,0xE4,0xA8,0xB8,0x18,0x6D,0xE1,
	0xC2,0xCB,0xE4,0xDE,0xE6,0x53,0x85,0xA6,0x89,0x39,0x8F,0xC5,0xC6,0xC5,0x5D,0x84,0xFE,0xC9,0x6B,0xD7,
	0xDD,0xD7,0x6B,0x28,0xD2,0x1E,0x29,0x0B,0xC8,0x65,0x68,0x83,0x2B,0x20,0x70,0xCE,0x94,0x68,0x26,0xB5,
	0x80,0x07,0x09,0xEB,0x64,0xB9,0x67,0xF8,0xCB,0xAC,0xB2,0x18,0x7B,0x96,0x33,0x25,0x4A,0x86,0x73,0x92,
	0x2B,0x42,0xC6,0xA9,0x88,0xD3,0x55,0x21,0xBA,0x93,0x9E,0xE8,0xD9,0xA6,0xB5,0x8B,0xCC,0x92,0xBA,0x03,
	0x24,0x46,0xD1,0x88,0x8D,0xD6,0xB3,0x8C,0xC3,0x9F,0x89,0x8E,0x85,0x70,0xDC,0x7A,0x84,0xF1,0xCF,0xD9,
	0x97,0x72,0xF9,0x22,0x43,0x09,0x60,0x78,0x7E,0x7B,0xD4,0x1B,0x11,0x19,0x77,0x6D,0x7B,0x75,0x60,0x59,
	0x6B,0xA3,0x78,0xEC,0xAB,0x6A,0x5E,0x11,0xF4,0xAD,0x03,0x90,0x62,0x3D,0x49,0x4F,0x0D,0x42,0x5E,0x78,
	0x5B,0x6C,0x4E,0xC4,0xD3,0xB7,0xDB,0xF1,0xA8,0x4A,0x37,0x59,0x3F,0x69,0x56,0x88,0x40,0x49,0x00,0x36,
	0xA6,0x52,0x5E,0xA4,0x32,0xC7,0x87,0xE9,0xC2,0x9C,0x62,0x9B,0xA5,0x49,0xC7,0x97,0xE2,0x50,0xB1,0x1E,
	0x17,0x9A,0xFE,0x1E,0x37,0x19,0xFF,0x5F,0x4D,0xAB,0xE4,0xD1,0xE0,0xCC,0x28,0xD8,0x16,0x84,0x07,0x08,
	0xD2,0xD9,0x01,0x4C,0x4A,0x06,0x4D,0x0A,0x18,0xF2,0x4E,0xEA,0x82,0xDC,0xEA,0x41,0x54,0xC5,0x12,0xA4,
	0xA6,0xDF,0x89,0x7A,0x2F,0x56,0x9B,0x91,0x55,0x14,0xB1,0x9B,0xCE,0xEE,0xFF,0xAF,0x71,0x19,0xB8,0xC8,
	0xE9,0xB5,0x72,0x95,0x8A,0xA3,0xAB,0x1A,0x8F,0x91,0x53,0xA0,0xA0,0xAC,0xC5,0x40,0x0A,0x53,0x69,0xAF,
	0x85,0x83,0xDC,0x6B,0x37,0x9E,0x06,0xDD,0x8E,0xAA,0x50,0x88,0x7B,0x42,0xA3,0x92,0x31,0x0F,0x65,0x8D,
	0xE7,0xD4,0x20,0x30,0x05,0x07,0x7C,0xBF,0x73,0x0E,0x60,0x0C,0x54,0x2C,0x0E,0x76,0x4E,0x91,0xB5,0xF2,
	0x5F,0x72,0x3F,0xA2,0x63,0xE5,0x2B,0x22,0x3D,0x96,0x34,0xF2,0x35,0x2D,0xC4,0x2A,0x84,0xA8,0x3F,0x49,
	0x85,0x0A,0xE5,0x38,0x85,0x5F,0x28,0xF2,0x27,0x00,0xA2,0xB0,0x5F,0x3B,0x10,0x44,0x0C,0x20,0xAD,0x34,
	0x39,0xDB,0x31,0x06,0x0A,0x14,0x0C,0x3C,0xCC,0x34,0x6B,0x27,0x78,0x2D,0x25,0x09,0x46,0xBB,0x3E,0x5D,
	0xC5,0x12,0x51,0x87,0x59,0xAC,0x05,0xC2,0x7A,0x17,0x01,0x24,0x4A,0x5C,0xF7,0xF9,0xB2,0xE6,0xD5,0xE9,
	0xE7,0xEE,0x90,0x1D,0x26,0x0A,0xE1,0xC6,0xE6,0x20,0xEC,0xB0,0xD5,0xE3,0x9D,0xD1,0xA2,0xD2,0x17,0xB4,
	0xF9,0x03,0xC1,0xE3,0xD9,0x7B,0xDA,0xD6,0xD3,0xC7,0xD9,0xAE,0x5F,0x71,0xF2,0x36,0xC2,0xF3,0x8B,0xA1,
	0x0F,0x06,0xEE,0xBC,0x82,0xA5,0xBD,0xBE,0x1C,0xC4,0xF6,0x21,0x9B,0xB7,0xA1,0xBD,0xA0,0x87,0xE2,0xEA,
	0x1E,0x75,0xBA,0xAD,0x87,0x7E,0xC6,0x4D,0x2F,0xAF,0xBE,0x25,0xA8,0x8C,0x84,0x9A,0x56,0xEB,0x9E,0x89,
	0x9D,0x99,0x94,0x7B,0x90,0x2B,0x9E,0x80,0x40,0xD4,0x82,0x54,0x8E,0x8E,0x18,0x70,0x5E,0x78,0x40,0x58,
	0x58,0x85,0x8A,0x75,0x4D,0x64,0x7C,0x57,0x6E,0x00,0x84,0xF8,0xBA,0x0F,0x41,0xE3,0x71,0x63,0x47,0x61,
	0x59,0x47,0x7D,0x71,0x00,0x1F,0xDC,0x2D,0x76,0x69,0x50,0x74,0x61,0x30,0x10,0x83,0x5F,0x90,0x8A,0x4D,
	0xD3,0x65,0x14,0x62,0x5C,0x09,0x3F,0x53,0x25,0xD4,0x7B,0x87,0x97,0xBA,0xB9,0x8C,0x47,0x73,0x83,0x3A,
	0xC8,0xBA,0x1C,0x06,0xBF,0xDB,0x00,0x0D,0xA7,0x5D,0x1E,0x1C,0x02,0x42,0x01,0x04,0x65,0x21,0xF6,0x9C,
	0xF2,0x0E,0x14,0x2F,0x63,0x65,0xA0,0x4E,0xD5,0xF2,0xC4,0x32,0x64,0x0C,0xDC,0x17,0xE8,0x2D,0x13,0x50,
	0xAD,0x76,0x58,0x84,0x88,0x95,0x46,0x8E,0x71,0x1B,0x84,0x85,0x90,0xC2,0x1C,0xE8,0x09,0x41,0x05,0xDE,
	0xDC,0xDD,0x47,0x9A,0xAA,0xBA,0xD4,0xB3,0x00,0x00,0xC9,0x2C,0xEB,0xE5,0xD0,0xF1,0xEB,0xC9,0xE5,0xE3,
	0x41,0x1A,0xD2,0xE7,0x14,0xE7,0xB9,0xB4,0x01,0x28,0x5B,0x3E,0xAF,0xD6,0xA0,0x57,0x75,0x5C,0xD0,0xC7,
	0xC4,0xC0,0x17,0x3A,0x7E,0x85,0xD6,0x95,0xCF,0xCD,0xCC,0xF3,0xCF,0xF6,0x08,0x05,0xAF,0xAE,0x5C,0xF9,
	0x88,0x55,0xC2,0x08,0xB9,0x86,0xA8,0x00,0xBC,0xBA,0xC5,0xEC,0xA7,0x0D,0x9A,0xF3,0xD8,0xF0,0xA0,0x12,
	0xA2,0x02,0x10,0x97,0xA0,0x3E,0xEF,0xDF,0xFB,0xAC,0xE9,0xA2,0x5D,0xDA,0xBC,0x78,0x65,0x28,0xEE,0xFE,
	0x68,0x5D,0x45,0x13,0x4D,0xC4,0x88,0x39,0x41,0xDD,0xA6,0x82,0xBD,0xC4,0x68,0x98,0xC8,0xB2,0xB1,0x79,
	0x92,0x3D,0x84,0xF8,0x42,0x6D,0x0C,0x73,0x8D,0x5A,0x55,0x76,0x1C,0x88,0xFD,0xA9,0x76,0x6D,0x49,0x51,
	0xF1,0xA2,0xB4,0x75,0x3A,0x5C,0x54,0xEC,0x92,0xE2,0xA2,0x45,0x45,0xC9,0x3D,0x58,0xCF,0xF7,0xAA,0xA5,
	0xF3,0x45,0x3F,0x41,0xB5,0x00,0x00,0x08,0x38,0x9E,0x65,0xC6,0x84,0x20,0x13,0x38,0x24,0x3E,0x87,0xFD,
	0x6D,0xAE,0x2A,0x2C,0x21,0x17,0x39,0x2F,0x00,0x40,0xC3,0x11,0x3E,0x25,0x38,0x3B,0x91,0x19,0x3A,0x1D,
	0x39,0x78,0x15,0x09,0x0B,0x2D,0x13,0x00,0x28,0xD0,0xAA,0x86,0x1F,0x04,0x58,0x11,0x12,0x2C,0x4A,0x7E,
	0x49,0x1E,0x15,0xBC,0x0D,0x6C,0xF0,0x17,0x88,0x24,0x54,0x2B,0x37,0x25,0x66,0x8C,0x7F,0x44,0xB4,0xA8,
	0x02,0x50,0xB6,0x60,0x6D,0xD2,0xED,0xD5,0x6D,0xA6,0x28,0xC3,0xD6,0xEB,0x45,0xA4,0xAD,0xC1,0xC5,0xFB,
	0xC0,0xC0,0xEA,0x5F,0xC9,0x23,0xC3,0xB3,0xAC,0x0A,0xB3,0x82,0x74,0x91,0x22,0xC9,0xD2,0xCE,0xB7,0x51,
	0xC3,0x89,0xC1,0x6A,0x17,0x2C,0xC2,0xD0,0xC6,0xD7,0xC8,0xCA,0x2F,0xE9,0x50,0x05,0xF9,0xE2,0xA1,0xA2,
	0x98,0x9F,0x46,0x55,0x54,0xF3,0xAF,0x81,0xA0,0x12,0xC7,0x40,0xA8,0x8F,0xA2,0xA1,0x8E,0x10,0x99,0x1C,
	0xA6,0xB9,0x86,0xBE,0xB2,0xB9,0x9E,0x8B,0x9C,0x16,0x1A,0x09,0x2B,0x80,0x8D,0x99,0x9A,0x82,0x75,0xA3,
	0xE8,0x05,0xAF,0xC0,0x93,0x87,0x3E,0x2A,0x77,0x66,0x49,0xD8,0x8F,0x98,0x9F,0x88,0x54,0x4F,0x6F,0x41,
	0x54,0x90,0xA2,0x5B,0xF7,0x05,0x33,0x30,0x3C,0xAB,0xF4,0xE8,0x5A,0x3C,0x3E,0x71,0x30,0x60,0x11,0x57,
	0x81,0x0F,0xE8,0x01,0xAF,0x2A,0x27,0x35,0xAC,0x0A,0x24,0x0E,0x01,0x25,0x2C,0x36,0x36,0x10,0x1F,0x5C,
	0xEB,0x52,0x1C,0x16,0xEB,0x7E,0x6F,0xD9,0xAF,0xC9,0xC2,0xF4,0x06,0xAF,0x1D,0x6E,0xD7,0xEB,0x5B,0x1D,
	0x42,0x9F,0x99,0xF1,0xE7,0x76,0xC0,0x11,0xFE,0x2A,0x69,0x15,0xD1,0xFF,0xE5,0xFF,0xED,0xBE,0x02,0x7E,
	0x17,0xE1,0xE6,0x45,0x85,0xC0,0x56,0xFF,0xDA,0x67,0xDD,0x4A,0x92,0x94,0x54,0xEF,0xD8,0xD5,0x37,0xAB,
	0x31,0xAF,0x0E,0xDB,0x90,0x23,0xED,0xDE,0x60,0x06,0x99,0x00,0xD6,0xB4,0x7F,0x1C,0xA4,0x4F,0x14,0xCB,
	0xFC,0x28,0xA2,0x75,0xA8,0x69,0x5C,0x5A,0x5E,0xD1,0xFC,0x99,0xDE,0x24,0x38,0x83,0x70,0x51,0x28,0x9B,
	0x10,0xCC,0x13,0x8F,0x6F,0xC4,0x31,0x1F,0x03,0x00,0x00,0x00,0x00,0xA8,0x00,0x2C,0x86,0x08,0xBF,0x3D,
	0x21,0x1F,0x96,0xA9,0x77,0x1A,0x42,0x31,0x08,0x10,0xCF,0x90,0xD2,0xC4,0x0C,0x6A,0x03,0x40,0xCB,0x86,
	0x7E,0x27,0x4E,0x51,0x8D,0x37,0x81,0xF5,0x0D,0x85,0xC7,0x30,0xA9,0x18,0x00,0xAE,0xAB,0xAE,0x93,0xFC,
	0x08,0x84,0xF9,0x25,0xDF,0xD6,0xE7,0xEF,0xB9,0xF1,0xB0,0xBD,0xA3,0x00,0x00,0x00,0x6D,0xA7,0xE0,0x66,
	0x22,0x95,0xC7,0xDC,0x2B,0x56,0x96,0xCB,0x5F,0x10,0xAC,0xD9,0x5D,0xA9,0xF0,0xF3,0x53,0x16,0xF3,0xCB,
	0xC8,0x5A,0x00,0xD0,0x9B,0x38,0x6F,0x97,0x43,0xBD,0xCE,0xC6,0x39,0x91,0x91,0x52,0x3F,0xB5,0xE7,0xCE,
	0x6C,0x89,0xC2,0x33,0xD1,0xE3,0x00,0x00,0x00,0x34,0x46,0xDD,0xEF,0xFF,0x20,0xF0,0xAD,0x2B,0x4C,0xA0,
	0x96,0x52,0x98,0x51,0xDC,0x94,0x14,0x9A,0xA3,0xDA,0xFD,0xA7,0x71,0x94,0xE3,0x85,0x03,0x00,0x52,0xC5,
	0x7A,0x9D,0xAA,0x71,0x7D,0x73,0x8B,0xB7,0x86,0x08,0x8B,0x86,0xF0,0x64,0xC5,0x00,0x00,0x00,0x72,0x19,
	0xBF,0x95,0x74,0xBA,0xBA,0x69,0xFE,0xB3,0xF5,0xB3,0x70,0x58,0xB4,0xF8,0x34,0x51,0x92,0x86,0xA4,0x30,
	0x41,0x23,0x6C,0x18,0x00,0x00,0x11,0x36,0x65,0x1F,0xA2,0x8B,0x63,0x53,0x9F,0xAD,0xF6,0x05,0xD8,0xBB,
	0x5A,0xAB,0xFD,0xD5,0x97,0x41,0xBA,0x1A,0xAE,0x00,0x50,0x52,0x09,0xA6,0x43,0x0A,0x27,0x35,0x34,0x30,
	0x34,0x37,0x62,0x05,0x21,0x4B,0xC4,0xEA,0xE1,0x02,0x5F,0x1C,0x3C,0x61,0xD3,0x0D,0x15,0xF6,0x54,0x40,
	0x73,0x58,0x30,0xCF,0x5B,0x0A,0x1D,0x42,0x2C,0x79,0x26,0xE6,0x02,0x00,0x21,0xE6,0x64,0x3B,0x06,0x6C,
	0x01,0x10,0xE8,0x4E,0x95,0xA2,0xC6,0xB9,0xF4,0x4A,0x72,0x51,0x91,0x2F,0x10,0x10,0x5E,0x94,0x28,0xF0,
	0xF3,0x04,0x78,0x01,0x53,0x54,0x10,0x74,0x06,0x00,0x48,0xB8,0x4A,0xCD,0xF1,0x27,0x0D,0x80,0xAD,0x8B,
	0xF4,0xFF,0x58,0x2E,0x5E,0xF4,0x46,0x04,0x06,0xE8,0x66,0xAE,0xEC,0xB7,0x7A,0xB5,0xF5,0xB9,0xD3,0x49,
	0xAD,0x1C,0xA6,0xFE,0x00,0x00,0x00,0xF0,0xD8,0x15,0xD0,0xB9,0x5B,0x01,0x8F,0x1E,0x04,0x42,0x88,0xC8,
	0x0F,0x85,0xC3,0x04,0xC0,0xE7,0xC2,0x49,0x8A,0xB7,0x78,0xFF,0xB5,0x78,0x31,0xC0,0x40,0xA9,0x7B,0x7B,
	0xBD,0x3C,0x38,0xB6,0x28,0x92,0x89,0x12,0x48,0x53,0x01,0x97,0x56,0xD8,0xA7,0x2B,0x6E,0x59,0x51,0x0C,
	0x5C,0x57,0x4E,0xD1,0x51,0x3A,0x72,0x2B,0x67,0xC5,0x7D,0x09,0x23,0x42,0x66,0x07,0x84,0x92,0x45,0x04,
	0x84,0x96,0xB0,0xC4,0xAE,0x06,0xD8,0x0A,0x85,0x4C,0xDF,0x81,0xBB,0x79,0xCB,0x39,0x6E,0xC0,0x71,0xD1,
	0x30,0x40,0x51,0x73,0x84,0xB0,0xEA,0x9B,0xC0,0xC1,0x3E,0x8F,0x2A,0x00,0xD8,0xB8,0x90,0x38,0x88,0x1E,
	0x0E,0x34,0x38,0x3A,0x3B,0x33,0x75,0x20,0x3C,0x72,0x6A,0x18,0x00,0x00,0x3D,0x3F,0x2E,0x2A,0x6D,0x2A,
	0x3E,0x24,0x2A,0x3C,0x2E,0x29,0x2B,0x7E,0x63,0x67,0x32,0x60,0x17,0x15,0xC4,0xBD,0x36,0x80,0x4D,0x41,
	0x08,0xF2,0x5B,0xD1,0x49,0x45,0x45,0xA2,0xE7,0xA9,0x02,0x47,0x49,0x2C,0xDB,0x66,0x12,0x56,0xA0,0xA7,
	0xDA,0x6A,0x8A,0xED,0x09,0xF8,0x05,0x4A,0x03,0xE4,0x00,0x88,0xD5,0x6B,0x10,0x17,0xF8,0xBF,0xAB,0xAA,
	0xB8,0xA4,0x1D,0x00,0xE8,0x78,0x99,0xF2,0x0E,0x83,0xE3,0x11,0xCE,0xB4,0xB4,0x67,0x64,0xE8,0x37,0xE2,
	0xAF,0x1C,0x95,0x08,0x1A,0x69,0xDE,0xDA,0xE3,0x02,0x02,0xFA,0x5E,0x19,0xAD,0xDF,0x55,0x40,0xDC,0xAB,
	0xA2,0x8F,0xC2,0x7A,0x0B,0xC9,0x19,0x96,0x6A,0x91,0x2A,0x43,0xC5,0x5F,0x85,0x0B,0x00,0xBC,0x7B,0x34,
	0xBE,0x50,0x63,0x92,0x77,0x3E,0x1C,0xF8,0x82,0x34,0xAA,0x38,0x9E,0x2E,0x68,0x22,0xD3,0x79,0x3E,0x55,
	0x2B,0xBF,0x21,0xBF,0x29,0x17,0xC8,0x52,0x00,0x8B,0x58,0xDE,0x98,0x72,0x13,0xDA,0x9D,0xC7,0xD2,0x87,
	0xC6,0xC1,0x6F,0xF9,0xF5,0x12,0x02,0xC3,0xFF,0x54,0x53,0x45,0xE9,0x97,0x95,0x09,0x9F,0xA5,0xF4,0x4C,
	0x4A,0x58,0x26,0x2A,0x5A,0x4B,0x16,0x40,0x22,0x6C,0x30,0x08,0xE5,0x33,0x76,0x6C,0x0C,0x63,0xE2,0x95,
	0x2A,0xA0,0xE9,0x0C,0x0E,0xA4,0x3A,0x79,0x33,0xF2,0xCC,0xD7,0xE7,0x4C,0x30,0x5A,0x4C,0x0B,0x89,0x1A,
	0x03,0x27,0x46,0x26,0xE6,0x13,0x3C,0x91,0x10,0x22,0x01,0x3B,0xD6,0x36,0x2B,0x98,0xAB,0xE1,0x6C,0x86,
	0x48,0xD4,0x34,0x55,0xE1,0x19,0x08,0xF9,0x38,0x63,0x22,0xFB,0x4A,0x0C,0xCC,0x38,0x9B,0x24,0x61,0xA7,
	0x55,0x25,0xE8,0x0C,0x00,0xF0,0x04,0x00,0x0C,0x00,0x00,0x00,0x05,0x30,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x01,0x00,0x10,0x00,0x00,0x00,0x18,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x01,0x00,0x00,0x00,0x30,0x00,0x00,0x80,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x09,0x08,0x00,0x00,0x48,0x00,0x00,0x00,
	0x60,0xC0,0x04,0x00,0xDC,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0xDC,0x01,0x34,0x00,0x00,0x00,0x56,0x00,0x53,0x00,0x5F,0x00,0x56,0x00,0x45,0x00,
	0x52,0x00,0x53,0x00,0x49,0x00,0x4F,0x00,0x4E,0x00,0x5F,0x00,0x49,0x00,0x4E,0x00,0x46,0x00,0x4F,0x00,
	0x00,0x00,0x00,0x00,0xBD,0x04,0xEF,0xFE,0x00,0x00,0x01,0x00,0x04,0x00,0x02,0x00,0x01,0x00,0x0C,0x00,
	0x04,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x3F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,
	0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x01,0x00,0x00,
	0x01,0x00,0x53,0x00,0x74,0x00,0x72,0x00,0x69,0x00,0x6E,0x00,0x67,0x00,0x46,0x00,0x69,0x00,0x6C,0x00,
	0x65,0x00,0x49,0x00,0x6E,0x00,0x66,0x00,0x6F,0x00,0x00,0x00,0x18,0x01,0x00,0x00,0x01,0x00,0x30,0x00,
	0x30,0x00,0x30,0x00,0x30,0x00,0x30,0x00,0x34,0x00,0x62,0x00,0x30,0x00,0x00,0x00,0x4A,0x00,0x15,0x00,
	0x01,0x00,0x43,0x00,0x6F,0x00,0x6D,0x00,0x70,0x00,0x61,0x00,0x6E,0x00,0x79,0x00,0x4E,0x00,0x61,0x00,
	0x6D,0x00,0x65,0x00,0x00,0x00,0x00,0x00,0x55,0x00,0x6E,0x00,0x34,0x00,0x73,0x00,0x65,0x00,0x65,0x00,
	0x6E,0x00,0x20,0x00,0x44,0x00,0x65,0x00,0x76,0x00,0x65,0x00,0x6C,0x00,0x6F,0x00,0x70,0x00,0x6D,0x00,
	0x65,0x00,0x6E,0x00,0x74,0x00,0x73,0x00,0x00,0x00,0x00,0x00,0x32,0x00,0x05,0x00,0x01,0x00,0x46,0x00,
	0x69,0x00,0x6C,0x00,0x65,0x00,0x44,0x00,0x65,0x00,0x73,0x00,0x63,0x00,0x72,0x00,0x69,0x00,0x70,0x00,
	0x74,0x00,0x69,0x00,0x6F,0x00,0x6E,0x00,0x00,0x00,0x00,0x00,0x42,0x00,0x41,0x00,0x53,0x00,0x53,0x00,
	0x00,0x00,0x00,0x00,0x2E,0x00,0x07,0x00,0x01,0x00,0x46,0x00,0x69,0x00,0x6C,0x00,0x65,0x00,0x56,0x00,
	0x65,0x00,0x72,0x00,0x73,0x00,0x69,0x00,0x6F,0x00,0x6E,0x00,0x00,0x00,0x00,0x00,0x32,0x00,0x2E,0x00,
	0x34,0x00,0x2E,0x00,0x31,0x00,0x32,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x16,0x00,0x01,0x00,0x4C,0x00,
	0x65,0x00,0x67,0x00,0x61,0x00,0x6C,0x00,0x43,0x00,0x6F,0x00,0x70,0x00,0x79,0x00,0x72,0x00,0x69,0x00,
	0x67,0x00,0x68,0x00,0x74,0x00,0x00,0x00,0x43,0x00,0x6F,0x00,0x70,0x00,0x79,0x00,0x72,0x00,0x69,0x00,
	0x67,0x00,0x68,0x00,0x74,0x00,0x20,0x00,0xA9,0x00,0x20,0x00,0x31,0x00,0x39,0x00,0x39,0x00,0x39,0x00,
	0x2D,0x00,0x32,0x00,0x30,0x00,0x31,0x00,0x36,0x00,0x00,0x00,0x44,0x00,0x00,0x00,0x01,0x00,0x56,0x00,
	0x61,0x00,0x72,0x00,0x46,0x00,0x69,0x00,0x6C,0x00,0x65,0x00,0x49,0x00,0x6E,0x00,0x66,0x00,0x6F,0x00,
	0x00,0x00,0x00,0x00,0x24,0x00,0x04,0x00,0x00,0x00,0x54,0x00,0x72,0x00,0x61,0x00,0x6E,0x00,0x73,0x00,
	0x6C,0x00,0x61,0x00,0x74,0x00,0x69,0x00,0x6F,0x00,0x6E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xB0,0x04,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xB8,0x00,0xF0,0x04,
	0x10,0x60,0x8D,0xA8,0x00,0x10,0xFB,0xFF,0x68,0x4A,0x92,0x9C,0x15,0x6A,0x40,0x68,0x00,0x30,0x00,0x00,
	0x68,0xDB,0x7A,0x01,0x00,0x6A,0x00,0xFF,0x90,0x58,0x02,0x00,0x00,0x89,0x44,0x24,0x1C,0xBB,0x23,0x03,
	0x00,0x00,0x8D,0xB5,0xE5,0xAC,0x01,0x00,0x8B,0xF8,0x50,0xE8,0x0A,0x00,0x00,0x00,0x74,0x07,0x8B,0x44,
	0x24,0x24,0xFF,0x50,0x10,0xC3,0x55,0x81,0xFB,0x00,0x00,0x01,0x00,0x73,0x0E,0x6A,0x05,0x68,0x60,0xC0,
	0xFF,0xFF,0x68,0x60,0xFC,0xFF,0xFF,0xEB,0x0C,0x6A,0x08,0x68,0x00,0x83,0xFF,0xFF,0x68,0x00,0xFB,0xFF,
	0xFF,0x6A,0xFF,0x33,0xD2,0x33,0xC9,0xAC,0x32,0xC3,0xAA,0x4B,0x7E,0x62,0xE8,0x63,0x00,0x00,0x00,0x73,
	0xF2,0x33,0xED,0xE8,0x66,0x00,0x00,0x00,0x83,0xE9,0x03,0x73,0x06,0x8B,0x04,0x24,0x41,0xEB,0x22,0x8B,
	0xC1,0x8B,0x4C,0x24,0x0C,0xE8,0x44,0x00,0x00,0x00,0x13,0xC0,0xE2,0xF7,0xF7,0xD0,0x3B,0x44,0x24,0x04,
	0x83,0xD5,0x01,0x3B,0x44,0x24,0x08,0x83,0xD5,0x00,0x89,0x04,0x24,0xE8,0x28,0x00,0x00,0x00,0x13,0xC9,
	0xE8,0x21,0x00,0x00,0x00,0x13,0xC9,0x75,0x08,0xE8,0x24,0x00,0x00,0x00,0x83,0xC1,0x02,0x03,0xCD,0x2B,
	0xD9,0x72,0x09,0x56,0x8D,0x34,0x38,0xF3,0xA4,0x5E,0xEB,0x9C,0x58,0x58,0x58,0x58,0x5D,0xC3,0x03,0xD2,
	0x75,0x07,0x8B,0x16,0x83,0xEE,0xFC,0x13,0xD2,0xC3,0x41,0xE8,0xEE,0xFF,0xFF,0xFF,0x13,0xC9,0xE8,0xE7,
	0xFF,0xFF,0xFF,0x72,0xF2,0xC3,0x00,0x00,0x4D,0x65,0x73,0x73,0x61,0x67,0x65,0x42,0x6F,0x78,0x41,0x00,
	0x00,0x00,0x77,0x73,0x70,0x72,0x69,0x6E,0x74,0x66,0x41,0x00,0x00,0x00,0x45,0x78,0x69,0x74,0x50,0x72,
	0x6F,0x63,0x65,0x73,0x73,0x00,0x00,0x00,0x47,0x65,0x74,0x4D,0x6F,0x64,0x75,0x6C,0x65,0x48,0x61,0x6E,
	0x64,0x6C,0x65,0x41,0x00,0x00,0x00,0x00,0x47,0x65,0x74,0x50,0x72,0x6F,0x63,0x41,0x64,0x64,0x72,0x65,
	0x73,0x73,0x00,0x00,0x00,0x00,0x56,0x69,0x72,0x74,0x75,0x61,0x6C,0x50,0x72,0x6F,0x74,0x65,0x63,0x74,
	0x00,0x00,0x00,0x00,0x56,0x69,0x72,0x74,0x75,0x61,0x6C,0x41,0x6C,0x6C,0x6F,0x63,0x00,0x00,0x00,0x00,
	0x56,0x69,0x72,0x74,0x75,0x61,0x6C,0x46,0x72,0x65,0x65,0x00,0x00,0x00,0x61,0x63,0x6D,0x53,0x74,0x72,
	0x65,0x61,0x6D,0x53,0x69,0x7A,0x65,0x00,0x00,0x00,0x6D,0x69,0x78,0x65,0x72,0x4F,0x70,0x65,0x6E,0x00,
	0x00,0x00,0x43,0x6F,0x49,0x6E,0x69,0x74,0x69,0x61,0x6C,0x69,0x7A,0x65,0x00,0x00,0x00,0x00,0x66,0x72,
	0x65,0x65,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x84,0xF2,0x04,0x00,
	0x3C,0xF2,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x8F,0xF2,0x04,0x00,
	0x48,0xF2,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x9C,0xF2,0x04,0x00,
	0x64,0xF2,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xA8,0xF2,0x04,0x00,
	0x6C,0xF2,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xB2,0xF2,0x04,0x00,
	0x74,0xF2,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xBC,0xF2,0x04,0x00,
	0x7C,0xF2,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0xFE,0xF0,0x04,0x00,0x0C,0xF1,0x04,0x00,0x00,0x00,0x00,0x00,0x18,0xF1,0x04,0x00,
	0x26,0xF1,0x04,0x00,0x3A,0xF1,0x04,0x00,0x4C,0xF1,0x04,0x00,0x5E,0xF1,0x04,0x00,0x6E,0xF1,0x04,0x00,
	0x00,0x00,0x00,0x00,0x7C,0xF1,0x04,0x00,0x00,0x00,0x00,0x00,0x8C,0xF1,0x04,0x00,0x00,0x00,0x00,0x00,
	0x98,0xF1,0x04,0x00,0x00,0x00,0x00,0x00,0xA8,0xF1,0x04,0x00,0x00,0x00,0x00,0x00,0x75,0x73,0x65,0x72,
	0x33,0x32,0x2E,0x64,0x6C,0x6C,0x00,0x6B,0x65,0x72,0x6E,0x65,0x6C,0x33,0x32,0x2E,0x64,0x6C,0x6C,0x00,
	0x4D,0x53,0x41,0x43,0x4D,0x33,0x32,0x2E,0x64,0x6C,0x6C,0x00,0x57,0x49,0x4E,0x4D,0x4D,0x2E,0x64,0x6C,
	0x6C,0x00,0x6F,0x6C,0x65,0x33,0x32,0x2E,0x64,0x6C,0x6C,0x00,0x4D,0x53,0x56,0x43,0x52,0x54,0x2E,0x64,
	0x6C,0x6C,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x05,0x15,0x57,0x00,0x00,0x00,0x00,0x93,0xFE,0x04,0x00,
	0x01,0x00,0x00,0x00,0x66,0x00,0x00,0x00,0x66,0x00,0x00,0x00,0xF0,0xF2,0x04,0x00,0x88,0xF4,0x04,0x00,
	0x20,0xF6,0x04,0x00,0x6F,0x4C,0x02,0x00,0x24,0x0D,0x02,0x00,0xBA,0x09,0x02,0x00,0xD4,0x36,0x02,0x00,
	0x2F,0x37,0x02,0x00,0xC1,0x17,0x02,0x00,0xF9,0x17,0x02,0x00,0x6E,0x27,0x02,0x00,0x53,0x0B,0x02,0x00,
	0xB8,0x07,0x02,0x00,0xFC,0x20,0x02,0x00,0xC2,0x30,0x02,0x00,0xD0,0x2C,0x02,0x00,0x65,0x20,0x02,0x00,
	0xA2,0xF5,0x01,0x00,0x02,0x07,0x02,0x00,0x68,0x18,0x02,0x00,0x8B,0x32,0x02,0x00,0x7C,0x31,0x02,0x00,
	0x89,0x05,0x02,0x00,0x1B,0x36,0x02,0x00,0x1A,0x3A,0x02,0x00,0x0D,0x38,0x02,0x00,0xA0,0x34,0x02,0x00,
	0x52,0x0D,0x02,0x00,0x8B,0x36,0x02,0x00,0x05,0x37,0x02,0x00,0xA8,0x17,0x02,0x00,0xDF,0x17,0x02,0x00,
	0xD7,0x35,0x02,0x00,0xB8,0x0B,0x02,0x00,0xA1,0x38,0x02,0x00,0x81,0x37,0x02,0x00,0x01,0x20,0x02,0x00,
	0x31,0x33,0x02,0x00,0x13,0x18,0x02,0x00,0x5F,0x31,0x02,0x00,0x37,0x32,0x02,0x00,0xD1,0x59,0x02,0x00,
	0x8F,0x3A,0x02,0x00,0xA1,0x3A,0x02,0x00,0x7D,0x3A,0x02,0x00,0x17,0x3B,0x02,0x00,0x43,0x3D,0x02,0x00,
	0xE5,0x4A,0x02,0x00,0x05,0x4C,0x02,0x00,0x32,0xB8,0x01,0x00,0x43,0x61,0x02,0x00,0x84,0x61,0x02,0x00,
	0x2D,0x46,0x02,0x00,0x0F,0x46,0x02,0x00,0x8F,0x46,0x02,0x00,0x2B,0x4D,0x02,0x00,0xD8,0x46,0x02,0x00,
	0xC6,0x59,0x02,0x00,0xD1,0x49,0x02,0x00,0xC5,0x3D,0x02,0x00,0xEA,0xFC,0x01,0x00,0xA7,0xFE,0x01,0x00,
	0x46,0x48,0x02,0x00,0x75,0x62,0x02,0x00,0x16,0x63,0x02,0x00,0xA5,0x61,0x02,0x00,0x54,0x4F,0x02,0x00,
	0x11,0x53,0x02,0x00,0x36,0x53,0x02,0x00,0x8A,0x53,0x02,0x00,0xB4,0x56,0x02,0x00,0x3B,0x54,0x02,0x00,
	0x7F,0x4F,0x02,0x00,0xD8,0x52,0x02,0x00,0x84,0x54,0x02,0x00,0x80,0x58,0x02,0x00,0x65,0xC4,0x01,0x00,
	0xE5,0xC4,0x01,0x00,0x56,0xC6,0x01,0x00,0x82,0xC9,0x01,0x00,0x38,0xC5,0x01,0x00,0x98,0xC5,0x01,0x00,
	0x30,0xC3,0x01,0x00,0x03,0xC5,0x01,0x00,0xD5,0xC5,0x01,0x00,0xE2,0xC9,0x01,0x00,0x60,0x4A,0x02,0x00,
	0x43,0x4B,0x02,0x00,0x27,0x61,0x02,0x00,0x69,0x61,0x02,0x00,0xDB,0x45,0x02,0x00,0x90,0x4C,0x02,0x00,
	0xF0,0x48,0x02,0x00,0x88,0x47,0x02,0x00,0x31,0x48,0x02,0x00,0x28,0xF5,0x01,0x00,0x52,0xF2,0x01,0x00,
	0x39,0xF4,0x01,0x00,0xC2,0xF2,0x01,0x00,0x7B,0xF5,0x01,0x00,0xEA,0xF6,0x01,0x00,0x5F,0xFA,0x01,0x00,
	0xC0,0xFB,0x01,0x00,0xF0,0xB7,0x01,0x00,0x30,0x9B,0x02,0x00,0xEC,0xF6,0x04,0x00,0xF9,0xF6,0x04,0x00,
	0x13,0xF7,0x04,0x00,0x25,0xF7,0x04,0x00,0x41,0xF7,0x04,0x00,0x5B,0xF7,0x04,0x00,0x74,0xF7,0x04,0x00,
	0x8F,0xF7,0x04,0x00,0xA3,0xF7,0x04,0x00,0xB9,0xF7,0x04,0x00,0xCD,0xF7,0x04,0x00,0xE3,0xF7,0x04,0x00,
	0xF8,0xF7,0x04,0x00,0x0F,0xF8,0x04,0x00,0x27,0xF8,0x04,0x00,0x3B,0xF8,0x04,0x00,0x50,0xF8,0x04,0x00,
	0x66,0xF8,0x04,0x00,0x77,0xF8,0x04,0x00,0x89,0xF8,0x04,0x00,0x9A,0xF8,0x04,0x00,0xB0,0xF8,0x04,0x00,
	0xC5,0xF8,0x04,0x00,0xDC,0xF8,0x04,0x00,0xF3,0xF8,0x04,0x00,0x0D,0xF9,0x04,0x00,0x29,0xF9,0x04,0x00,
	0x43,0xF9,0x04,0x00,0x5C,0xF9,0x04,0x00,0x77,0xF9,0x04,0x00,0x8A,0xF9,0x04,0x00,0xA0,0xF9,0x04,0x00,
	0xB2,0xF9,0x04,0x00,0xC6,0xF9,0x04,0x00,0xDE,0xF9,0x04,0x00,0xF2,0xF9,0x04,0x00,0x0D,0xFA,0x04,0x00,
	0x1E,0xFA,0x04,0x00,0x31,0xFA,0x04,0x00,0x43,0xFA,0x04,0x00,0x58,0xFA,0x04,0x00,0x65,0xFA,0x04,0x00,
	0x7A,0xFA,0x04,0x00,0x8D,0xFA,0x04,0x00,0x97,0xFA,0x04,0x00,0xA9,0xFA,0x04,0x00,0xBC,0xFA,0x04,0x00,
	0xC8,0xFA,0x04,0x00,0xD7,0xFA,0x04,0x00,0xE9,0xFA,0x04,0x00,0xFE,0xFA,0x04,0x00,0x0D,0xFB,0x04,0x00,
	0x20,0xFB,0x04,0x00,0x36,0xFB,0x04,0x00,0x43,0xFB,0x04,0x00,0x53,0xFB,0x04,0x00,0x62,0xFB,0x04,0x00,
	0x6C,0xFB,0x04,0x00,0x7B,0xFB,0x04,0x00,0x8A,0xFB,0x04,0x00,0x95,0xFB,0x04,0x00,0xA5,0xFB,0x04,0x00,
	0xB8,0xFB,0x04,0x00,0xC8,0xFB,0x04,0x00,0xD8,0xFB,0x04,0x00,0xED,0xFB,0x04,0x00,0x06,0xFC,0x04,0x00,
	0x19,0xFC,0x04,0x00,0x2D,0xFC,0x04,0x00,0x45,0xFC,0x04,0x00,0x55,0xFC,0x04,0x00,0x6A,0xFC,0x04,0x00,
	0x7E,0xFC,0x04,0x00,0x8F,0xFC,0x04,0x00,0xA1,0xFC,0x04,0x00,0xB1,0xFC,0x04,0x00,0xC7,0xFC,0x04,0x00,
	0xDE,0xFC,0x04,0x00,0xF1,0xFC,0x04,0x00,0x04,0xFD,0x04,0x00,0x14,0xFD,0x04,0x00,0x27,0xFD,0x04,0x00,
	0x3A,0xFD,0x04,0x00,0x4A,0xFD,0x04,0x00,0x5C,0xFD,0x04,0x00,0x6F,0xFD,0x04,0x00,0x7E,0xFD,0x04,0x00,
	0x90,0xFD,0x04,0x00,0x9F,0xFD,0x04,0x00,0xB5,0xFD,0x04,0x00,0xC4,0xFD,0x04,0x00,0xCF,0xFD,0x04,0x00,
	0xD9,0xFD,0x04,0x00,0xEB,0xFD,0x04,0x00,0x01,0xFE,0x04,0x00,0x1B,0xFE,0x04,0x00,0x30,0xFE,0x04,0x00,
	0x40,0xFE,0x04,0x00,0x5B,0xFE,0x04,0x00,0x6E,0xFE,0x04,0x00,0x85,0xFE,0x04,0x00,0x91,0xFE,0x04,0x00,
	0x00,0x00,0x01,0x00,0x02,0x00,0x03,0x00,0x04,0x00,0x05,0x00,0x06,0x00,0x07,0x00,0x08,0x00,0x09,0x00,
	0x0A,0x00,0x0B,0x00,0x0C,0x00,0x0D,0x00,0x0E,0x00,0x0F,0x00,0x10,0x00,0x11,0x00,0x12,0x00,0x13,0x00,
	0x14,0x00,0x15,0x00,0x16,0x00,0x17,0x00,0x18,0x00,0x19,0x00,0x1A,0x00,0x1B,0x00,0x1C,0x00,0x1D,0x00,
	0x1E,0x00,0x1F,0x00,0x20,0x00,0x21,0x00,0x22,0x00,0x23,0x00,0x24,0x00,0x25,0x00,0x26,0x00,0x27,0x00,
	0x28,0x00,0x29,0x00,0x2A,0x00,0x2B,0x00,0x2C,0x00,0x2D,0x00,0x2E,0x00,0x2F,0x00,0x30,0x00,0x31,0x00,
	0x32,0x00,0x33,0x00,0x34,0x00,0x35,0x00,0x36,0x00,0x37,0x00,0x38,0x00,0x39,0x00,0x3A,0x00,0x3B,0x00,
	0x3C,0x00,0x3D,0x00,0x3E,0x00,0x3F,0x00,0x40,0x00,0x41,0x00,0x42,0x00,0x43,0x00,0x44,0x00,0x45,0x00,
	0x46,0x00,0x47,0x00,0x48,0x00,0x49,0x00,0x4A,0x00,0x4B,0x00,0x4C,0x00,0x4D,0x00,0x4E,0x00,0x4F,0x00,
	0x50,0x00,0x51,0x00,0x52,0x00,0x53,0x00,0x54,0x00,0x55,0x00,0x56,0x00,0x57,0x00,0x58,0x00,0x59,0x00,
	0x5A,0x00,0x5B,0x00,0x5C,0x00,0x5D,0x00,0x5E,0x00,0x5F,0x00,0x60,0x00,0x61,0x00,0x62,0x00,0x63,0x00,
	0x64,0x00,0x65,0x00,0x42,0x41,0x53,0x53,0x5F,0x41,0x70,0x70,0x6C,0x79,0x33,0x44,0x00,0x42,0x41,0x53,
	0x53,0x5F,0x43,0x68,0x61,0x6E,0x6E,0x65,0x6C,0x42,0x79,0x74,0x65,0x73,0x32,0x53,0x65,0x63,0x6F,0x6E,
	0x64,0x73,0x00,0x42,0x41,0x53,0x53,0x5F,0x43,0x68,0x61,0x6E,0x6E,0x65,0x6C,0x46,0x6C,0x61,0x67,0x73,
	0x00,0x42,0x41,0x53,0x53,0x5F,0x43,0x68,0x61,0x6E,0x6E,0x65,0x6C,0x47,0x65,0x74,0x33,0x44,0x41,0x74,
	0x74,0x72,0x69,0x62,0x75,0x74,0x65,0x73,0x00,0x42,0x41,0x53,0x53,0x5F,0x43,0x68,0x61,0x6E,0x6E,0x65,
	0x6C,0x47,0x65,0x74,0x33,0x44,0x50,0x6F,0x73,0x69,0x74,0x69,0x6F,0x6E,0x00,0x42,0x41,0x53,0x53,0x5F,
	0x43,0x68,0x61,0x6E,0x6E,0x65,0x6C,0x47,0x65,0x74,0x41,0x74,0x74,0x72,0x69,0x62,0x75,0x74,0x65,0x00,
	0x42,0x41,0x53,0x53,0x5F,0x43,0x68,0x61,0x6E,0x6E,0x65,0x6C,0x47,0x65,0x74,0x41,0x74,0x74,0x72,0x69,
	0x62,0x75,0x74,0x65,0x45,0x78,0x00,0x42,0x41,0x53,0x53,0x5F,0x43,0x68,0x61,0x6E,0x6E,0x65,0x6C,0x47,
	0x65,0x74,0x44,0x61,0x74,0x61,0x00,0x42,0x41,0x53,0x53,0x5F,0x43,0x68,0x61,0x6E,0x6E,0x65,0x6C,0x47,
	0x65,0x74,0x44,0x65,0x76,0x69,0x63,0x65,0x00,0x42,0x41,0x53,0x53,0x5F,0x43,0x68,0x61,0x6E,0x6E,0x65,
	0x6C,0x47,0x65,0x74,0x49,0x6E,0x66,0x6F,0x00,0x42,0x41,0x53,0x53,0x5F,0x43,0x68,0x61,0x6E,0x6E,0x65,
	0x6C,0x47,0x65,0x74,0x4C,0x65,0x6E,0x67,0x74,0x68,0x00,0x42,0x41,0x53,0x53,0x5F,0x43,0x68,0x61,0x6E,
	0x6E,0x65,0x6C,0x47,0x65,0x74,0x4C,0x65,0x76,0x65,0x6C,0x00,0x42,0x41,0x53,0x53,0x5F,0x43,0x68,0x61,
	0x6E,0x6E,0x65,0x6C,0x47,0x65,0x74,0x4C,0x65,0x76,0x65,0x6C,0x45,0x78,0x00,0x42,0x41,0x53,0x53,0x5F,
	0x43,0x68,0x61,0x6E,0x6E,0x65,0x6C,0x47,0x65,0x74,0x50,0x6F,0x73,0x69,0x74,0x69,0x6F,0x6E,0x00,0x42,
	0x41,0x53,0x53,0x5F,0x43,0x68,0x61,0x6E,0x6E,0x65,0x6C,0x47,0x65,0x74,0x54,0x61,0x67,0x73,0x00,0x42,
	0x41,0x53,0x53,0x5F,0x43,0x68,0x61,0x6E,0x6E,0x65,0x6C,0x49,0x73,0x41,0x63,0x74,0x69,0x76,0x65,0x00,
	0x42,0x41,0x53,0x53,0x5F,0x43,0x68,0x61,0x6E,0x6E,0x65,0x6C,0x49,0x73,0x53,0x6C,0x69,0x64,0x69,0x6E,
	0x67,0x00,0x42,0x41,0x53,0x53,0x5F,0x43,0x68,0x61,0x6E,0x6E,0x65,0x6C,0x4C,0x6F,0x63,0x6B,0x00,0x42,
	0x41,0x53,0x53,0x5F,0x43,0x68,0x61,0x6E,0x6E,0x65,0x6C,0x50,0x61,0x75,0x73,0x65,0x00,0x42,0x41,0x53,
	0x53,0x5F,0x43,0x68,0x61,0x6E,0x6E,0x65,0x6C,0x50,0x6C,0x61,0x79,0x00,0x42,0x41,0x53,0x53,0x5F,0x43,
	0x68,0x61,0x6E,0x6E,0x65,0x6C,0x52,0x65,0x6D,0x6F,0x76,0x65,0x44,0x53,0x50,0x00,0x42,0x41,0x53,0x53,
	0x5F,0x43,0x68,0x61,0x6E,0x6E,0x65,0x6C,0x52,0x65,0x6D,0x6F,0x76,0x65,0x46,0x58,0x00,0x42,0x41,0x53,
	0x53,0x5F,0x43,0x68,0x61,0x6E,0x6E,0x65,0x6C,0x52,0x65,0x6D,0x6F,0x76,0x65,0x4C,0x69,0x6E,0x6B,0x00,
	0x42,0x41,0x53,0x53,0x5F,0x43,0x68,0x61,0x6E,0x6E,0x65,0x6C,0x52,0x65,0x6D,0x6F,0x76,0x65,0x53,0x79,
	0x6E,0x63,0x00,0x42,0x41,0x53,0x53,0x5F,0x43,0x68,0x61,0x6E,0x6E,0x65,0x6C,0x53,0x65,0x63,0x6F,0x6E,
	0x64,0x73,0x32,0x42,0x79,0x74,0x65,0x73,0x00,0x42,0x41,0x53,0x53,0x5F,0x43,0x68,0x61,0x6E,0x6E,0x65,
	0x6C,0x53,0x65,0x74,0x33,0x44,0x41,0x74,0x74,0x72,0x69,0x62,0x75,0x74,0x65,0x73,0x00,0x42,0x41,0x53,
	0x53,0x5F,0x43,0x68,0x61,0x6E,0x6E,0x65,0x6C,0x53,0x65,0x74,0x33,0x44,0x50,0x6F,0x73,0x69,0x74,0x69,
	0x6F,0x6E,0x00,0x42,0x41,0x53,0x53,0x5F,0x43,0x68,0x61,0x6E,0x6E,0x65,0x6C,0x53,0x65,0x74,0x41,0x74,
	0x74,0x72,0x69,0x62,0x75,0x74,0x65,0x00,0x42,0x41,0x53,0x53,0x5F,0x43,0x68,0x61,0x6E,0x6E,0x65,0x6C,
	0x53,0x65,0x74,0x41,0x74,0x74,0x72,0x69,0x62,0x75,0x74,0x65,0x45,0x78,0x00,0x42,0x41,0x53,0x53,0x5F,
	0x43,0x68,0x61,0x6E,0x6E,0x65,0x6C,0x53,0x65,0x74,0x44,0x53,0x50,0x00,0x42,0x41,0x53,0x53,0x5F,0x43,
	0x68,0x61,0x6E,0x6E,0x65,0x6C,0x53,0x65,0x74,0x44,0x65,0x76,0x69,0x63,0x65,0x00,0x42,0x41,0x53,0x53,
	0x5F,0x43,0x68,0x61,0x6E,0x6E,0x65,0x6C,0x53,0x65,0x74,0x46,0x58,0x00,0x42,0x41,0x53,0x53,0x5F,0x43,
	0x68,0x61,0x6E,0x6E,0x65,0x6C,0x53,0x65,0x74,0x4C,0x69,0x6E,0x6B,0x00,0x42,0x41,0x53,0x53,0x5F,0x43,
	0x68,0x61,0x6E,0x6E,0x65,0x6C,0x53,0x65,0x74,0x50,0x6F,0x73,0x69,0x74,0x69,0x6F,0x6E,0x00,0x42,0x41,
	0x53,0x53,0x5F,0x43,0x68,0x61,0x6E,0x6E,0x65,0x6C,0x53,0x65,0x74,0x53,0x79,0x6E,0x63,0x00,0x42,0x41,
	0x53,0x53,0x5F,0x43,0x68,0x61,0x6E,0x6E,0x65,0x6C,0x53,0x6C,0x69,0x64,0x65,0x41,0x74,0x74,0x72,0x69,
	0x62,0x75,0x74,0x65,0x00,0x42,0x41,0x53,0x53,0x5F,0x43,0x68,0x61,0x6E,0x6E,0x65,0x6C,0x53,0x74,0x6F,
	0x70,0x00,0x42,0x41,0x53,0x53,0x5F,0x43,0x68,0x61,0x6E,0x6E,0x65,0x6C,0x55,0x70,0x64,0x61,0x74,0x65,
	0x00,0x42,0x41,0x53,0x53,0x5F,0x45,0x72,0x72,0x6F,0x72,0x47,0x65,0x74,0x43,0x6F,0x64,0x65,0x00,0x42,
	0x41,0x53,0x53,0x5F,0x46,0x58,0x47,0x65,0x74,0x50,0x61,0x72,0x61,0x6D,0x65,0x74,0x65,0x72,0x73,0x00,
	0x42,0x41,0x53,0x53,0x5F,0x46,0x58,0x52,0x65,0x73,0x65,0x74,0x00,0x42,0x41,0x53,0x53,0x5F,0x46,0x58,
	0x53,0x65,0x74,0x50,0x61,0x72,0x61,0x6D,0x65,0x74,0x65,0x72,0x73,0x00,0x42,0x41,0x53,0x53,0x5F,0x46,
	0x58,0x53,0x65,0x74,0x50,0x72,0x69,0x6F,0x72,0x69,0x74,0x79,0x00,0x42,0x41,0x53,0x53,0x5F,0x46,0x72,
	0x65,0x65,0x00,0x42,0x41,0x53,0x53,0x5F,0x47,0x65,0x74,0x33,0x44,0x46,0x61,0x63,0x74,0x6F,0x72,0x73,
	0x00,0x42,0x41,0x53,0x53,0x5F,0x47,0x65,0x74,0x33,0x44,0x50,0x6F,0x73,0x69,0x74,0x69,0x6F,0x6E,0x00,
	0x42,0x41,0x53,0x53,0x5F,0x47,0x65,0x74,0x43,0x50,0x55,0x00,0x42,0x41,0x53,0x53,0x5F,0x47,0x65,0x74,
	0x43,0x6F,0x6E,0x66,0x69,0x67,0x00,0x42,0x41,0x53,0x53,0x5F,0x47,0x65,0x74,0x43,0x6F,0x6E,0x66,0x69,
	0x67,0x50,0x74,0x72,0x00,0x42,0x41,0x53,0x53,0x5F,0x47,0x65,0x74,0x44,0x53,0x6F,0x75,0x6E,0x64,0x4F,
	0x62,0x6A,0x65,0x63,0x74,0x00,0x42,0x41,0x53,0x53,0x5F,0x47,0x65,0x74,0x44,0x65,0x76,0x69,0x63,0x65,
	0x00,0x42,0x41,0x53,0x53,0x5F,0x47,0x65,0x74,0x44,0x65,0x76,0x69,0x63,0x65,0x49,0x6E,0x66,0x6F,0x00,
	0x42,0x41,0x53,0x53,0x5F,0x47,0x65,0x74,0x45,0x41,0x58,0x50,0x61,0x72,0x61,0x6D,0x65,0x74,0x65,0x72,
	0x73,0x00,0x42,0x41,0x53,0x53,0x5F,0x47,0x65,0x74,0x49,0x6E,0x66,0x6F,0x00,0x42,0x41,0x53,0x53,0x5F,
	0x47,0x65,0x74,0x56,0x65,0x72,0x73,0x69,0x6F,0x6E,0x00,0x42,0x41,0x53,0x53,0x5F,0x47,0x65,0x74,0x56,
	0x6F,0x6C,0x75,0x6D,0x65,0x00,0x42,0x41,0x53,0x53,0x5F,0x49,0x6E,0x69,0x74,0x00,0x42,0x41,0x53,0x53,
	0x5F,0x4D,0x75,0x73,0x69,0x63,0x46,0x72,0x65,0x65,0x00,0x42,0x41,0x53,0x53,0x5F,0x4D,0x75,0x73,0x69,
	0x63,0x4C,0x6F,0x61,0x64,0x00,0x42,0x41,0x53,0x53,0x5F,0x50,0x61,0x75,0x73,0x65,0x00,0x42,0x41,0x53,
	0x53,0x5F,0x50,0x6C,0x75,0x67,0x69,0x6E,0x46,0x72,0x65,0x65,0x00,0x42,0x41,0x53,0x53,0x5F,0x50,0x6C,
	0x75,0x67,0x69,0x6E,0x47,0x65,0x74,0x49,0x6E,0x66,0x6F,0x00,0x42,0x41,0x53,0x53,0x5F,0x50,0x6C,0x75,
	0x67,0x69,0x6E,0x4C,0x6F,0x61,0x64,0x00,0x42,0x41,0x53,0x53,0x5F,0x52,0x65,0x63,0x6F,0x72,0x64,0x46,
	0x72,0x65,0x65,0x00,0x42,0x41,0x53,0x53,0x5F,0x52,0x65,0x63,0x6F,0x72,0x64,0x47,0x65,0x74,0x44,0x65,
	0x76,0x69,0x63,0x65,0x00,0x42,0x41,0x53,0x53,0x5F,0x52,0x65,0x63,0x6F,0x72,0x64,0x47,0x65,0x74,0x44,
	0x65,0x76,0x69,0x63,0x65,0x49,0x6E,0x66,0x6F,0x00,0x42,0x41,0x53,0x53,0x5F,0x52,0x65,0x63,0x6F,0x72,
	0x64,0x47,0x65,0x74,0x49,0x6E,0x66,0x6F,0x00,0x42,0x41,0x53,0x53,0x5F,0x52,0x65,0x63,0x6F,0x72,0x64,
	0x47,0x65,0x74,0x49,0x6E,0x70,0x75,0x74,0x00,0x42,0x41,0x53,0x53,0x5F,0x52,0x65,0x63,0x6F,0x72,0x64,
	0x47,0x65,0x74,0x49,0x6E,0x70,0x75,0x74,0x4E,0x61,0x6D,0x65,0x00,0x42,0x41,0x53,0x53,0x5F,0x52,0x65,
	0x63,0x6F,0x72,0x64,0x49,0x6E,0x69,0x74,0x00,0x42,0x41,0x53,0x53,0x5F,0x52,0x65,0x63,0x6F,0x72,0x64,
	0x53,0x65,0x74,0x44,0x65,0x76,0x69,0x63,0x65,0x00,0x42,0x41,0x53,0x53,0x5F,0x52,0x65,0x63,0x6F,0x72,
	0x64,0x53,0x65,0x74,0x49,0x6E,0x70,0x75,0x74,0x00,0x42,0x41,0x53,0x53,0x5F,0x52,0x65,0x63,0x6F,0x72,
	0x64,0x53,0x74,0x61,0x72,0x74,0x00,0x42,0x41,0x53,0x53,0x5F,0x53,0x61,0x6D,0x70,0x6C,0x65,0x43,0x72,
	0x65,0x61,0x74,0x65,0x00,0x42,0x41,0x53,0x53,0x5F,0x53,0x61,0x6D,0x70,0x6C,0x65,0x46,0x72,0x65,0x65,
	0x00,0x42,0x41,0x53,0x53,0x5F,0x53,0x61,0x6D,0x70,0x6C,0x65,0x47,0x65,0x74,0x43,0x68,0x61,0x6E,0x6E,
	0x65,0x6C,0x00,0x42,0x41,0x53,0x53,0x5F,0x53,0x61,0x6D,0x70,0x6C,0x65,0x47,0x65,0x74,0x43,0x68,0x61,
	0x6E,0x6E,0x65,0x6C,0x73,0x00,0x42,0x41,0x53,0x53,0x5F,0x53,0x61,0x6D,0x70,0x6C,0x65,0x47,0x65,0x74,
	0x44,0x61,0x74,0x61,0x00,0x42,0x41,0x53,0x53,0x5F,0x53,0x61,0x6D,0x70,0x6C,0x65,0x47,0x65,0x74,0x49,
	0x6E,0x66,0x6F,0x00,0x42,0x41,0x53,0x53,0x5F,0x53,0x61,0x6D,0x70,0x6C,0x65,0x4C,0x6F,0x61,0x64,0x00,
	0x42,0x41,0x53,0x53,0x5F,0x53,0x61,0x6D,0x70,0x6C,0x65,0x53,0x65,0x74,0x44,0x61,0x74,0x61,0x00,0x42,
	0x41,0x53,0x53,0x5F,0x53,0x61,0x6D,0x70,0x6C,0x65,0x53,0x65,0x74,0x49,0x6E,0x66,0x6F,0x00,0x42,0x41,
	0x53,0x53,0x5F,0x53,0x61,0x6D,0x70,0x6C,0x65,0x53,0x74,0x6F,0x70,0x00,0x42,0x41,0x53,0x53,0x5F,0x53,
	0x65,0x74,0x33,0x44,0x46,0x61,0x63,0x74,0x6F,0x72,0x73,0x00,0x42,0x41,0x53,0x53,0x5F,0x53,0x65,0x74,
	0x33,0x44,0x50,0x6F,0x73,0x69,0x74,0x69,0x6F,0x6E,0x00,0x42,0x41,0x53,0x53,0x5F,0x53,0x65,0x74,0x43,
	0x6F,0x6E,0x66,0x69,0x67,0x00,0x42,0x41,0x53,0x53,0x5F,0x53,0x65,0x74,0x43,0x6F,0x6E,0x66,0x69,0x67,
	0x50,0x74,0x72,0x00,0x42,0x41,0x53,0x53,0x5F,0x53,0x65,0x74,0x44,0x65,0x76,0x69,0x63,0x65,0x00,0x42,
	0x41,0x53,0x53,0x5F,0x53,0x65,0x74,0x45,0x41,0x58,0x50,0x61,0x72,0x61,0x6D,0x65,0x74,0x65,0x72,0x73,
	0x00,0x42,0x41,0x53,0x53,0x5F,0x53,0x65,0x74,0x56,0x6F,0x6C,0x75,0x6D,0x65,0x00,0x42,0x41,0x53,0x53,
	0x5F,0x53,0x74,0x61,0x72,0x74,0x00,0x42,0x41,0x53,0x53,0x5F,0x53,0x74,0x6F,0x70,0x00,0x42,0x41,0x53,
	0x53,0x5F,0x53,0x74,0x72,0x65,0x61,0x6D,0x43,0x72,0x65,0x61,0x74,0x65,0x00,0x42,0x41,0x53,0x53,0x5F,
	0x53,0x74,0x72,0x65,0x61,0x6D,0x43,0x72,0x65,0x61,0x74,0x65,0x46,0x69,0x6C,0x65,0x00,0x42,0x41,0x53,
	0x53,0x5F,0x53,0x74,0x72,0x65,0x61,0x6D,0x43,0x72,0x65,0x61,0x74,0x65,0x46,0x69,0x6C,0x65,0x55,0x73,
	0x65,0x72,0x00,0x42,0x41,0x53,0x53,0x5F,0x53,0x74,0x72,0x65,0x61,0x6D,0x43,0x72,0x65,0x61,0x74,0x65,
	0x55,0x52,0x4C,0x00,0x42,0x41,0x53,0x53,0x5F,0x53,0x74,0x72,0x65,0x61,0x6D,0x46,0x72,0x65,0x65,0x00,
	0x42,0x41,0x53,0x53,0x5F,0x53,0x74,0x72,0x65,0x61,0x6D,0x47,0x65,0x74,0x46,0x69,0x6C,0x65,0x50,0x6F,
	0x73,0x69,0x74,0x69,0x6F,0x6E,0x00,0x42,0x41,0x53,0x53,0x5F,0x53,0x74,0x72,0x65,0x61,0x6D,0x50,0x75,
	0x74,0x44,0x61,0x74,0x61,0x00,0x42,0x41,0x53,0x53,0x5F,0x53,0x74,0x72,0x65,0x61,0x6D,0x50,0x75,0x74,
	0x46,0x69,0x6C,0x65,0x44,0x61,0x74,0x61,0x00,0x42,0x41,0x53,0x53,0x5F,0x55,0x70,0x64,0x61,0x74,0x65,
	0x00,0x5F,0x00,0x62,0x61,0x73,0x73,0x2E,0x64,0x6C,0x6C,0x00
};

```

`sakura/libs/image/image_DXT.cpp`:

```cpp
/*
	Jonathan Dummer
	2007-07-31-10.32

	simple DXT compression / decompression code

	public domain
*/

#include "image_DXT.h"
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#pragma warning(disable:4018)
#pragma warning(disable:4996)
/*	set this =1 if you want to use the covarince matrix method...
	which is better than my method of using standard deviations
	overall, except on the infintesimal chance that the power
	method fails for finding the largest eigenvector	*/
#define USE_COV_MAT	1

/********* Function Prototypes *********/
/*
	Takes a 4x4 block of pixels and compresses it into 8 bytes
	in DXT1 format (color only, no alpha).  Speed is valued
	over prettyness, at least for now.
*/
void compress_DDS_color_block(
				int channels,
				const unsigned char *const uncompressed,
				unsigned char compressed[8] );
/*
	Takes a 4x4 block of pixels and compresses the alpha
	component it into 8 bytes for use in DXT5 DDS files.
	Speed is valued over prettyness, at least for now.
*/
void compress_DDS_alpha_block(
				const unsigned char *const uncompressed,
				unsigned char compressed[8] );

/********* Actual Exposed Functions *********/
int
	save_image_as_DDS
	(
		const char *filename,
		int width, int height, int channels,
		const unsigned char *const data
	)
{
	/*	variables	*/
	FILE *fout;
	unsigned char *DDS_data;
	DDS_header header;
	int DDS_size;
	/*	error check	*/
	if( (NULL == filename) ||
		(width < 1) || (height < 1) ||
		(channels < 1) || (channels > 4) ||
		(data == NULL ) )
	{
		return 0;
	}
	/*	Convert the image	*/
	if( (channels & 1) == 1 )
	{
		/*	no alpha, just use DXT1	*/
		DDS_data = convert_image_to_DXT1( data, width, height, channels, &DDS_size );
	} else
	{
		/*	has alpha, so use DXT5	*/
		DDS_data = convert_image_to_DXT5( data, width, height, channels, &DDS_size );
	}
	/*	save it	*/
	memset( &header, 0, sizeof( DDS_header ) );
	header.dwMagic = ('D' << 0) | ('D' << 8) | ('S' << 16) | (' ' << 24);
	header.dwSize = 124;
	header.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT | DDSD_LINEARSIZE;
	header.dwWidth = width;
	header.dwHeight = height;
	header.dwPitchOrLinearSize = DDS_size;
	header.sPixelFormat.dwSize = 32;
	header.sPixelFormat.dwFlags = DDPF_FOURCC;
	if( (channels & 1) == 1 )
	{
		header.sPixelFormat.dwFourCC = ('D' << 0) | ('X' << 8) | ('T' << 16) | ('1' << 24);
	} else
	{
		header.sPixelFormat.dwFourCC = ('D' << 0) | ('X' << 8) | ('T' << 16) | ('5' << 24);
	}
	header.sCaps.dwCaps1 = DDSCAPS_TEXTURE;
	/*	write it out	*/
	fout = fopen( filename, "wb");
	fwrite( &header, sizeof( DDS_header ), 1, fout );
	fwrite( DDS_data, 1, DDS_size, fout );
	fclose( fout );
	/*	done	*/
	free( DDS_data );
	return 1;
}

unsigned char* convert_image_to_DXT1(
		const unsigned char *const uncompressed,
		int width, int height, int channels,
		int *out_size )
{
	unsigned char *compressed;
	int i, j, x, y;
	unsigned char ublock[16*3];
	unsigned char cblock[8];
	int index = 0, chan_step = 1;
	int block_count = 0;
	/*	error check	*/
	*out_size = 0;
	if( (width < 1) || (height < 1) ||
		(NULL == uncompressed) ||
		(channels < 1) || (channels > 4) )
	{
		return NULL;
	}
	/*	for channels == 1 or 2, I do not step forward for R,G,B values	*/
	if( channels < 3 )
	{
		chan_step = 0;
	}
	/*	get the RAM for the compressed image
		(8 bytes per 4x4 pixel block)	*/
	*out_size = ((width+3) >> 2) * ((height+3) >> 2) * 8;
	compressed = (unsigned char*)malloc( *out_size );
	/*	go through each block	*/
	for( j = 0; j < height; j += 4 )
	{
		for( i = 0; i < width; i += 4 )
		{
			/*	copy this block into a new one	*/
			int idx = 0;
			int mx = 4, my = 4;
			if( j+4 >= height )
			{
				my = height - j;
			}
			if( i+4 >= width )
			{
				mx = width - i;
			}
			for( y = 0; y < my; ++y )
			{
				for( x = 0; x < mx; ++x )
				{
					ublock[idx++] = uncompressed[(j+y)*width*channels+(i+x)*channels];
					ublock[idx++] = uncompressed[(j+y)*width*channels+(i+x)*channels+chan_step];
					ublock[idx++] = uncompressed[(j+y)*width*channels+(i+x)*channels+chan_step+chan_step];
				}
				for( x = mx; x < 4; ++x )
				{
					ublock[idx++] = ublock[0];
					ublock[idx++] = ublock[1];
					ublock[idx++] = ublock[2];
				}
			}
			for( y = my; y < 4; ++y )
			{
				for( x = 0; x < 4; ++x )
				{
					ublock[idx++] = ublock[0];
					ublock[idx++] = ublock[1];
					ublock[idx++] = ublock[2];
				}
			}
			/*	compress the block	*/
			++block_count;
			compress_DDS_color_block( 3, ublock, cblock );
			/*	copy the data from the block into the main block	*/
			for( x = 0; x < 8; ++x )
			{
				compressed[index++] = cblock[x];
			}
		}
	}
	return compressed;
}

unsigned char* convert_image_to_DXT5(
		const unsigned char *const uncompressed,
		int width, int height, int channels,
		int *out_size )
{
	unsigned char *compressed;
	int i, j, x, y;
	unsigned char ublock[16*4];
	unsigned char cblock[8];
	int index = 0, chan_step = 1;
	int block_count = 0, has_alpha;
	/*	error check	*/
	*out_size = 0;
	if( (width < 1) || (height < 1) ||
		(NULL == uncompressed) ||
		(channels < 1) || ( channels > 4) )
	{
		return NULL;
	}
	/*	for channels == 1 or 2, I do not step forward for R,G,B vales	*/
	if( channels < 3 )
	{
		chan_step = 0;
	}
	/*	# channels = 1 or 3 have no alpha, 2 & 4 do have alpha	*/
	has_alpha = 1 - (channels & 1);
	/*	get the RAM for the compressed image
		(16 bytes per 4x4 pixel block)	*/
	*out_size = ((width+3) >> 2) * ((height+3) >> 2) * 16;
	compressed = (unsigned char*)malloc( *out_size );
	/*	go through each block	*/
	for( j = 0; j < height; j += 4 )
	{
		for( i = 0; i < width; i += 4 )
		{
			/*	local variables, and my block counter	*/
			int idx = 0;
			int mx = 4, my = 4;
			if( j+4 >= height )
			{
				my = height - j;
			}
			if( i+4 >= width )
			{
				mx = width - i;
			}
			for( y = 0; y < my; ++y )
			{
				for( x = 0; x < mx; ++x )
				{
					ublock[idx++] = uncompressed[(j+y)*width*channels+(i+x)*channels];
					ublock[idx++] = uncompressed[(j+y)*width*channels+(i+x)*channels+chan_step];
					ublock[idx++] = uncompressed[(j+y)*width*channels+(i+x)*channels+chan_step+chan_step];
					ublock[idx++] =
						has_alpha * uncompressed[(j+y)*width*channels+(i+x)*channels+channels-1]
						+ (1-has_alpha)*255;
				}
				for( x = mx; x < 4; ++x )
				{
					ublock[idx++] = ublock[0];
					ublock[idx++] = ublock[1];
					ublock[idx++] = ublock[2];
					ublock[idx++] = ublock[3];
				}
			}
			for( y = my; y < 4; ++y )
			{
				for( x = 0; x < 4; ++x )
				{
					ublock[idx++] = ublock[0];
					ublock[idx++] = ublock[1];
					ublock[idx++] = ublock[2];
					ublock[idx++] = ublock[3];
				}
			}
			/*	now compress the alpha block	*/
			compress_DDS_alpha_block( ublock, cblock );
			/*	copy the data from the compressed alpha block into the main buffer	*/
			for( x = 0; x < 8; ++x )
			{
				compressed[index++] = cblock[x];
			}
			/*	then compress the color block	*/
			++block_count;
			compress_DDS_color_block( 4, ublock, cblock );
			/*	copy the data from the compressed color block into the main buffer	*/
			for( x = 0; x < 8; ++x )
			{
				compressed[index++] = cblock[x];
			}
		}
	}
	return compressed;
}

/********* Helper Functions *********/
int convert_bit_range( int c, int from_bits, int to_bits )
{
	int b = (1 << (from_bits - 1)) + c * ((1 << to_bits) - 1);
	return (b + (b >> from_bits)) >> from_bits;
}

int rgb_to_565( int r, int g, int b )
{
	return
		(convert_bit_range( r, 8, 5 ) << 11) |
		(convert_bit_range( g, 8, 6 ) << 05) |
		(convert_bit_range( b, 8, 5 ) << 00);
}

void rgb_888_from_565( unsigned int c, int *r, int *g, int *b )
{
	*r = convert_bit_range( (c >> 11) & 31, 5, 8 );
	*g = convert_bit_range( (c >> 05) & 63, 6, 8 );
	*b = convert_bit_range( (c >> 00) & 31, 5, 8 );
}

void compute_color_line_STDEV(
		const unsigned char *const uncompressed,
		int channels,
		float point[3], float direction[3] )
{
	const float inv_16 = 1.0f / 16.0f;
	int i;
	float sum_r = 0.0f, sum_g = 0.0f, sum_b = 0.0f;
	float sum_rr = 0.0f, sum_gg = 0.0f, sum_bb = 0.0f;
	float sum_rg = 0.0f, sum_rb = 0.0f, sum_gb = 0.0f;
	/*	calculate all data needed for the covariance matrix
		( to compare with _rygdxt code)	*/
	for( i = 0; i < 16*channels; i += channels )
	{
		sum_r += uncompressed[i+0];
		sum_rr += uncompressed[i+0] * uncompressed[i+0];
		sum_g += uncompressed[i+1];
		sum_gg += uncompressed[i+1] * uncompressed[i+1];
		sum_b += uncompressed[i+2];
		sum_bb += uncompressed[i+2] * uncompressed[i+2];
		sum_rg += uncompressed[i+0] * uncompressed[i+1];
		sum_rb += uncompressed[i+0] * uncompressed[i+2];
		sum_gb += uncompressed[i+1] * uncompressed[i+2];
	}
	/*	convert the sums to averages	*/
	sum_r *= inv_16;
	sum_g *= inv_16;
	sum_b *= inv_16;
	/*	and convert the squares to the squares of the value - avg_value	*/
	sum_rr -= 16.0f * sum_r * sum_r;
	sum_gg -= 16.0f * sum_g * sum_g;
	sum_bb -= 16.0f * sum_b * sum_b;
	sum_rg -= 16.0f * sum_r * sum_g;
	sum_rb -= 16.0f * sum_r * sum_b;
	sum_gb -= 16.0f * sum_g * sum_b;
	/*	the point on the color line is the average	*/
	point[0] = sum_r;
	point[1] = sum_g;
	point[2] = sum_b;
	#if USE_COV_MAT
	/*
		The following idea was from ryg.
		(https://mollyrocket.com/forums/viewtopic.php?t=392)
		The method worked great (less RMSE than mine) most of
		the time, but had some issues handling some simple
		boundary cases, like full green next to full red,
		which would generate a covariance matrix like this:

		| 1  -1  0 |
		| -1  1  0 |
		| 0   0  0 |

		For a given starting vector, the power method can
		generate all zeros!  So no starting with {1,1,1}
		as I was doing!  This kind of error is still a
		slight posibillity, but will be very rare.
	*/
	/*	use the covariance matrix directly
		(1st iteration, don't use all 1.0 values!)	*/
	sum_r = 1.0f;
	sum_g = 2.718281828f;
	sum_b = 3.141592654f;
	direction[0] = sum_r*sum_rr + sum_g*sum_rg + sum_b*sum_rb;
	direction[1] = sum_r*sum_rg + sum_g*sum_gg + sum_b*sum_gb;
	direction[2] = sum_r*sum_rb + sum_g*sum_gb + sum_b*sum_bb;
	/*	2nd iteration, use results from the 1st guy	*/
	sum_r = direction[0];
	sum_g = direction[1];
	sum_b = direction[2];
	direction[0] = sum_r*sum_rr + sum_g*sum_rg + sum_b*sum_rb;
	direction[1] = sum_r*sum_rg + sum_g*sum_gg + sum_b*sum_gb;
	direction[2] = sum_r*sum_rb + sum_g*sum_gb + sum_b*sum_bb;
	/*	3rd iteration, use results from the 2nd guy	*/
	sum_r = direction[0];
	sum_g = direction[1];
	sum_b = direction[2];
	direction[0] = sum_r*sum_rr + sum_g*sum_rg + sum_b*sum_rb;
	direction[1] = sum_r*sum_rg + sum_g*sum_gg + sum_b*sum_gb;
	direction[2] = sum_r*sum_rb + sum_g*sum_gb + sum_b*sum_bb;
	#else
	/*	use my standard deviation method
		(very robust, a tiny bit slower and less accurate)	*/
	direction[0] = sqrt( sum_rr );
	direction[1] = sqrt( sum_gg );
	direction[2] = sqrt( sum_bb );
	/*	which has a greater component	*/
	if( sum_gg > sum_rr )
	{
		/*	green has greater component, so base the other signs off of green	*/
		if( sum_rg < 0.0f )
		{
			direction[0] = -direction[0];
		}
		if( sum_gb < 0.0f )
		{
			direction[2] = -direction[2];
		}
	} else
	{
		/*	red has a greater component	*/
		if( sum_rg < 0.0f )
		{
			direction[1] = -direction[1];
		}
		if( sum_rb < 0.0f )
		{
			direction[2] = -direction[2];
		}
	}
	#endif
}

void LSE_master_colors_max_min(
		int *cmax, int *cmin,
		int channels,
		const unsigned char *const uncompressed )
{
	int i, j;
	/*	the master colors	*/
	int c0[3], c1[3];
	/*	used for fitting the line	*/
	float sum_x[] = { 0.0f, 0.0f, 0.0f };
	float sum_x2[] = { 0.0f, 0.0f, 0.0f };
	float dot_max = 1.0f, dot_min = -1.0f;
	float vec_len2 = 0.0f;
	float dot;
	/*	error check	*/
	if( (channels < 3) || (channels > 4) )
	{
		return;
	}
	compute_color_line_STDEV( uncompressed, channels, sum_x, sum_x2 );
	vec_len2 = 1.0f / ( 0.00001f +
			sum_x2[0]*sum_x2[0] + sum_x2[1]*sum_x2[1] + sum_x2[2]*sum_x2[2] );
	/*	finding the max and min vector values	*/
	dot_max =
			(
				sum_x2[0] * uncompressed[0] +
				sum_x2[1] * uncompressed[1] +
				sum_x2[2] * uncompressed[2]
			);
	dot_min = dot_max;
	for( i = 1; i < 16; ++i )
	{
		dot =
			(
				sum_x2[0] * uncompressed[i*channels+0] +
				sum_x2[1] * uncompressed[i*channels+1] +
				sum_x2[2] * uncompressed[i*channels+2]
			);
		if( dot < dot_min )
		{
			dot_min = dot;
		} else if( dot > dot_max )
		{
			dot_max = dot;
		}
	}
	/*	and the offset (from the average location)	*/
	dot = sum_x2[0]*sum_x[0] + sum_x2[1]*sum_x[1] + sum_x2[2]*sum_x[2];
	dot_min -= dot;
	dot_max -= dot;
	/*	post multiply by the scaling factor	*/
	dot_min *= vec_len2;
	dot_max *= vec_len2;
	/*	OK, build the master colors	*/
	for( i = 0; i < 3; ++i )
	{
		/*	color 0	*/
		c0[i] = (int)(0.5f + sum_x[i] + dot_max * sum_x2[i]);
		if( c0[i] < 0 )
		{
			c0[i] = 0;
		} else if( c0[i] > 255 )
		{
			c0[i] = 255;
		}
		/*	color 1	*/
		c1[i] = (int)(0.5f + sum_x[i] + dot_min * sum_x2[i]);
		if( c1[i] < 0 )
		{
			c1[i] = 0;
		} else if( c1[i] > 255 )
		{
			c1[i] = 255;
		}
	}
	/*	down_sample (with rounding?)	*/
	i = rgb_to_565( c0[0], c0[1], c0[2] );
	j = rgb_to_565( c1[0], c1[1], c1[2] );
	if( i > j )
	{
		*cmax = i;
		*cmin = j;
	} else
	{
		*cmax = j;
		*cmin = i;
	}
}

void
	compress_DDS_color_block
	(
		int channels,
		const unsigned char *const uncompressed,
		unsigned char compressed[8]
	)
{
	/*	variables	*/
	int i;
	int next_bit;
	int enc_c0, enc_c1;
	int c0[4], c1[4];
	float color_line[] = { 0.0f, 0.0f, 0.0f, 0.0f };
	float vec_len2 = 0.0f, dot_offset = 0.0f;
	/*	stupid order	*/
	int swizzle4[] = { 0, 2, 3, 1 };
	/*	get the master colors	*/
	LSE_master_colors_max_min( &enc_c0, &enc_c1, channels, uncompressed );
	/*	store the 565 color 0 and color 1	*/
	compressed[0] = (enc_c0 >> 0) & 255;
	compressed[1] = (enc_c0 >> 8) & 255;
	compressed[2] = (enc_c1 >> 0) & 255;
	compressed[3] = (enc_c1 >> 8) & 255;
	/*	zero out the compressed data	*/
	compressed[4] = 0;
	compressed[5] = 0;
	compressed[6] = 0;
	compressed[7] = 0;
	/*	reconstitute the master color vectors	*/
	rgb_888_from_565( enc_c0, &c0[0], &c0[1], &c0[2] );
	rgb_888_from_565( enc_c1, &c1[0], &c1[1], &c1[2] );
	/*	the new vector	*/
	vec_len2 = 0.0f;
	for( i = 0; i < 3; ++i )
	{
		color_line[i] = (float)(c1[i] - c0[i]);
		vec_len2 += color_line[i] * color_line[i];
	}
	if( vec_len2 > 0.0f )
	{
		vec_len2 = 1.0f / vec_len2;
	}
	/*	pre-proform the scaling	*/
	color_line[0] *= vec_len2;
	color_line[1] *= vec_len2;
	color_line[2] *= vec_len2;
	/*	compute the offset (constant) portion of the dot product	*/
	dot_offset = color_line[0]*c0[0] + color_line[1]*c0[1] + color_line[2]*c0[2];
	/*	store the rest of the bits	*/
	next_bit = 8*4;
	for( i = 0; i < 16; ++i )
	{
		/*	find the dot product of this color, to place it on the line
			(should be [-1,1])	*/
		int next_value = 0;
		float dot_product =
			color_line[0] * uncompressed[i*channels+0] +
			color_line[1] * uncompressed[i*channels+1] +
			color_line[2] * uncompressed[i*channels+2] -
			dot_offset;
		/*	map to [0,3]	*/
		next_value = (int)( dot_product * 3.0f + 0.5f );
		if( next_value > 3 )
		{
			next_value = 3;
		} else if( next_value < 0 )
		{
			next_value = 0;
		}
		/*	OK, store this value	*/
		compressed[next_bit >> 3] |= swizzle4[ next_value ] << (next_bit & 7);
		next_bit += 2;
	}
	/*	done compressing to DXT1	*/
}

void
	compress_DDS_alpha_block
	(
		const unsigned char *const uncompressed,
		unsigned char compressed[8]
	)
{
	/*	variables	*/
	int i;
	int next_bit;
	int a0, a1;
	float scale_me;
	/*	stupid order	*/
	int swizzle8[] = { 1, 7, 6, 5, 4, 3, 2, 0 };
	/*	get the alpha limits (a0 > a1)	*/
	a0 = a1 = uncompressed[3];
	for( i = 4+3; i < 16*4; i += 4 )
	{
		if( uncompressed[i] > a0 )
		{
			a0 = uncompressed[i];
		} else if( uncompressed[i] < a1 )
		{
			a1 = uncompressed[i];
		}
	}
	/*	store those limits, and zero the rest of the compressed dataset	*/
	compressed[0] = a0;
	compressed[1] = a1;
	/*	zero out the compressed data	*/
	compressed[2] = 0;
	compressed[3] = 0;
	compressed[4] = 0;
	compressed[5] = 0;
	compressed[6] = 0;
	compressed[7] = 0;
	/*	store the all of the alpha values	*/
	next_bit = 8*2;
	scale_me = 7.9999f / (a0 - a1);
	for( i = 3; i < 16*4; i += 4 )
	{
		/*	convert this alpha value to a 3 bit number	*/
		int svalue;
		int value = (int)((uncompressed[i] - a1) * scale_me);
		svalue = swizzle8[ value&7 ];
		/*	OK, store this value, start with the 1st byte	*/
		compressed[next_bit >> 3] |= svalue << (next_bit & 7);
		if( (next_bit & 7) > 5 )
		{
			/*	spans 2 bytes, fill in the start of the 2nd byte	*/
			compressed[1 + (next_bit >> 3)] |= svalue >> (8 - (next_bit & 7) );
		}
		next_bit += 3;
	}
	/*	done compressing to DXT1	*/
}

```

`sakura/libs/image/image_DXT.h`:

```h
/*
	Jonathan Dummer
	2007-07-31-10.32

	simple DXT compression / decompression code

	public domain
*/

#ifndef HEADER_IMAGE_DXT
#define HEADER_IMAGE_DXT

/**
	Converts an image from an array of unsigned chars (RGB or RGBA) to
	DXT1 or DXT5, then saves the converted image to disk.
	\return 0 if failed, otherwise returns 1
**/
int
save_image_as_DDS
(
    const char *filename,
    int width, int height, int channels,
    const unsigned char *const data
);

/**
	take an image and convert it to DXT1 (no alpha)
**/
unsigned char*
convert_image_to_DXT1
(
    const unsigned char *const uncompressed,
    int width, int height, int channels,
    int *out_size
);

/**
	take an image and convert it to DXT5 (with alpha)
**/
unsigned char*
convert_image_to_DXT5
(
    const unsigned char *const uncompressed,
    int width, int height, int channels,
    int *out_size
);

/**	A bunch of DirectDraw Surface structures and flags **/
typedef struct
{
    unsigned int    dwMagic;
    unsigned int    dwSize;
    unsigned int    dwFlags;
    unsigned int    dwHeight;
    unsigned int    dwWidth;
    unsigned int    dwPitchOrLinearSize;
    unsigned int    dwDepth;
    unsigned int    dwMipMapCount;
    unsigned int    dwReserved1[ 11 ];

    /*  DDPIXELFORMAT	*/
    struct
    {
        unsigned int    dwSize;
        unsigned int    dwFlags;
        unsigned int    dwFourCC;
        unsigned int    dwRGBBitCount;
        unsigned int    dwRBitMask;
        unsigned int    dwGBitMask;
        unsigned int    dwBBitMask;
        unsigned int    dwAlphaBitMask;
    }
    sPixelFormat;

    /*  DDCAPS2	*/
    struct
    {
        unsigned int    dwCaps1;
        unsigned int    dwCaps2;
        unsigned int    dwDDSX;
        unsigned int    dwReserved;
    }
    sCaps;
    unsigned int    dwReserved2;
}
DDS_header ;

/*	the following constants were copied directly off the MSDN website	*/

/*	The dwFlags member of the original DDSURFACEDESC2 structure
	can be set to one or more of the following values.	*/
#define DDSD_CAPS	0x00000001
#define DDSD_HEIGHT	0x00000002
#define DDSD_WIDTH	0x00000004
#define DDSD_PITCH	0x00000008
#define DDSD_PIXELFORMAT	0x00001000
#define DDSD_MIPMAPCOUNT	0x00020000
#define DDSD_LINEARSIZE	0x00080000
#define DDSD_DEPTH	0x00800000

/*	DirectDraw Pixel Format	*/
#define DDPF_ALPHAPIXELS	0x00000001
#define DDPF_FOURCC	0x00000004
#define DDPF_RGB	0x00000040

/*	The dwCaps1 member of the DDSCAPS2 structure can be
	set to one or more of the following values.	*/
#define DDSCAPS_COMPLEX	0x00000008
#define DDSCAPS_TEXTURE	0x00001000
#define DDSCAPS_MIPMAP	0x00400000

/*	The dwCaps2 member of the DDSCAPS2 structure can be
	set to one or more of the following values.		*/
#define DDSCAPS2_CUBEMAP	0x00000200
#define DDSCAPS2_CUBEMAP_POSITIVEX	0x00000400
#define DDSCAPS2_CUBEMAP_NEGATIVEX	0x00000800
#define DDSCAPS2_CUBEMAP_POSITIVEY	0x00001000
#define DDSCAPS2_CUBEMAP_NEGATIVEY	0x00002000
#define DDSCAPS2_CUBEMAP_POSITIVEZ	0x00004000
#define DDSCAPS2_CUBEMAP_NEGATIVEZ	0x00008000
#define DDSCAPS2_VOLUME	0x00200000

#endif /* HEADER_IMAGE_DXT	*/

```

`sakura/libs/image/image_helper.cpp`:

```cpp
/*
    Jonathan Dummer

    image helper functions

    MIT license
*/
#include "image_helper.h"
#include <stdlib.h>
#include <math.h>
#pragma warning(disable:4018)
#pragma warning(disable:4996)
#pragma warning(disable:4244)
/*	Upscaling the image uses simple bilinear interpolation	*/
int
	up_scale_image
	(
		const unsigned char* const orig,
		int width, int height, int channels,
		unsigned char* resampled,
		int resampled_width, int resampled_height
	)
{
	float dx, dy;
	int x, y, c;

    /* error(s) check	*/
    if ( 	(width < 1) || (height < 1) ||
            (resampled_width < 2) || (resampled_height < 2) ||
            (channels < 1) ||
            (NULL == orig) || (NULL == resampled) )
    {
        /*	signify badness	*/
        return 0;
    }
    /*
		for each given pixel in the new map, find the exact location
		from the original map which would contribute to this guy
	*/
    dx = (width - 1.0f) / (resampled_width - 1.0f);
    dy = (height - 1.0f) / (resampled_height - 1.0f);
    for ( y = 0; y < resampled_height; ++y )
    {
    	/* find the base y index and fractional offset from that	*/
    	float sampley = y * dy;
    	int inty = (int)sampley;
    	/*	if( inty < 0 ) { inty = 0; } else	*/
		if( inty > height - 2 ) { inty = height - 2; }
		sampley -= inty;
        for ( x = 0; x < resampled_width; ++x )
        {
			float samplex = x * dx;
			int intx = (int)samplex;
			int base_index;
			/* find the base x index and fractional offset from that	*/
			/*	if( intx < 0 ) { intx = 0; } else	*/
			if( intx > width - 2 ) { intx = width - 2; }
			samplex -= intx;
			/*	base index into the original image	*/
			base_index = (inty * width + intx) * channels;
            for ( c = 0; c < channels; ++c )
            {
            	/*	do the sampling	*/
				float value = 0.5f;
				value += orig[base_index]
							*(1.0f-samplex)*(1.0f-sampley);
				value += orig[base_index+channels]
							*(samplex)*(1.0f-sampley);
				value += orig[base_index+width*channels]
							*(1.0f-samplex)*(sampley);
				value += orig[base_index+width*channels+channels]
							*(samplex)*(sampley);
				/*	move to the next channel	*/
				++base_index;
            	/*	save the new value	*/
            	resampled[y*resampled_width*channels+x*channels+c] =
						(unsigned char)(value);
            }
        }
    }
    /*	done	*/
    return 1;
}

int
	mipmap_image
	(
		const unsigned char* const orig,
		int width, int height, int channels,
		unsigned char* resampled,
		int block_size_x, int block_size_y
	)
{
	int mip_width, mip_height;
	int i, j, c;

	/*	error check	*/
	if( (width < 1) || (height < 1) ||
		(channels < 1) || (orig == NULL) ||
		(resampled == NULL) ||
		(block_size_x < 1) || (block_size_y < 1) )
	{
		/*	nothing to do	*/
		return 0;
	}
	mip_width = width / block_size_x;
	mip_height = height / block_size_y;
	if( mip_width < 1 )
	{
		mip_width = 1;
	}
	if( mip_height < 1 )
	{
		mip_height = 1;
	}
	for( j = 0; j < mip_height; ++j )
	{
		for( i = 0; i < mip_width; ++i )
		{
			for( c = 0; c < channels; ++c )
			{
				const int index = (j*block_size_y)*width*channels + (i*block_size_x)*channels + c;
				int sum_value;
				int u,v;
				int u_block = block_size_x;
				int v_block = block_size_y;
				int block_area;
				/*	do a bit of checking so we don't over-run the boundaries
					(necessary for non-square textures!)	*/
				if( block_size_x * (i+1) > width )
				{
					u_block = width - i*block_size_y;
				}
				if( block_size_y * (j+1) > height )
				{
					v_block = height - j*block_size_y;
				}
				block_area = u_block*v_block;
				/*	for this pixel, see what the average
					of all the values in the block are.
					note: start the sum at the rounding value, not at 0	*/
				sum_value = block_area >> 1;
				for( v = 0; v < v_block; ++v )
				for( u = 0; u < u_block; ++u )
				{
					sum_value += orig[index + v*width*channels + u*channels];
				}
				resampled[j*mip_width*channels + i*channels + c] = sum_value / block_area;
			}
		}
	}
	return 1;
}

int
	scale_image_RGB_to_NTSC_safe
	(
		unsigned char* orig,
		int width, int height, int channels
	)
{
	const float scale_lo = 16.0f - 0.499f;
	const float scale_hi = 235.0f + 0.499f;
	int i, j;
	int nc = channels;
	unsigned char scale_LUT[256];
	/*	error check	*/
	if( (width < 1) || (height < 1) ||
		(channels < 1) || (orig == NULL) )
	{
		/*	nothing to do	*/
		return 0;
	}
	/*	set up the scaling Look Up Table	*/
	for( i = 0; i < 256; ++i )
	{
		scale_LUT[i] = (unsigned char)((scale_hi - scale_lo) * i / 255.0f + scale_lo);
	}
	/*	for channels = 2 or 4, ignore the alpha component	*/
	nc -= 1 - (channels & 1);
	/*	OK, go through the image and scale any non-alpha components	*/
	for( i = 0; i < width*height*channels; i += channels )
	{
		for( j = 0; j < nc; ++j )
		{
			orig[i+j] = scale_LUT[orig[i+j]];
		}
	}
	return 1;
}

unsigned char clamp_byte( int x ) { return ( (x) < 0 ? (0) : ( (x) > 255 ? 255 : (x) ) ); }

/*
	This function takes the RGB components of the image
	and converts them into YCoCg.  3 components will be
	re-ordered to CoYCg (for optimum DXT1 compression),
	while 4 components will be ordered CoCgAY (for DXT5
	compression).
*/
int
	convert_RGB_to_YCoCg
	(
		unsigned char* orig,
		int width, int height, int channels
	)
{
	int i;
	/*	error check	*/
	if( (width < 1) || (height < 1) ||
		(channels < 3) || (channels > 4) ||
		(orig == NULL) )
	{
		/*	nothing to do	*/
		return -1;
	}
	/*	do the conversion	*/
	if( channels == 3 )
	{
		for( i = 0; i < width*height*3; i += 3 )
		{
			int r = orig[i+0];
			int g = (orig[i+1] + 1) >> 1;
			int b = orig[i+2];
			int tmp = (2 + r + b) >> 2;
			/*	Co	*/
			orig[i+0] = clamp_byte( 128 + ((r - b + 1) >> 1) );
			/*	Y	*/
			orig[i+1] = clamp_byte( g + tmp );
			/*	Cg	*/
			orig[i+2] = clamp_byte( 128 + g - tmp );
		}
	} else
	{
		for( i = 0; i < width*height*4; i += 4 )
		{
			int r = orig[i+0];
			int g = (orig[i+1] + 1) >> 1;
			int b = orig[i+2];
			unsigned char a = orig[i+3];
			int tmp = (2 + r + b) >> 2;
			/*	Co	*/
			orig[i+0] = clamp_byte( 128 + ((r - b + 1) >> 1) );
			/*	Cg	*/
			orig[i+1] = clamp_byte( 128 + g - tmp );
			/*	Alpha	*/
			orig[i+2] = a;
			/*	Y	*/
			orig[i+3] = clamp_byte( g + tmp );
		}
	}
	/*	done	*/
	return 0;
}

/*
	This function takes the YCoCg components of the image
	and converts them into RGB.  See above.
*/
int
	convert_YCoCg_to_RGB
	(
		unsigned char* orig,
		int width, int height, int channels
	)
{
	int i;
	/*	error check	*/
	if( (width < 1) || (height < 1) ||
		(channels < 3) || (channels > 4) ||
		(orig == NULL) )
	{
		/*	nothing to do	*/
		return -1;
	}
	/*	do the conversion	*/
	if( channels == 3 )
	{
		for( i = 0; i < width*height*3; i += 3 )
		{
			int co = orig[i+0] - 128;
			int y  = orig[i+1];
			int cg = orig[i+2] - 128;
			/*	R	*/
			orig[i+0] = clamp_byte( y + co - cg );
			/*	G	*/
			orig[i+1] = clamp_byte( y + cg );
			/*	B	*/
			orig[i+2] = clamp_byte( y - co - cg );
		}
	} else
	{
		for( i = 0; i < width*height*4; i += 4 )
		{
			int co = orig[i+0] - 128;
			int cg = orig[i+1] - 128;
			unsigned char a  = orig[i+2];
			int y  = orig[i+3];
			/*	R	*/
			orig[i+0] = clamp_byte( y + co - cg );
			/*	G	*/
			orig[i+1] = clamp_byte( y + cg );
			/*	B	*/
			orig[i+2] = clamp_byte( y - co - cg );
			/*	A	*/
			orig[i+3] = a;
		}
	}
	/*	done	*/
	return 0;
}

float
find_max_RGBE
(
	unsigned char *image,
    int width, int height
)
{
	float max_val = 0.0f;
	unsigned char *img = image;
	int i, j;
	for( i = width * height; i > 0; --i )
	{
		/* float scale = powf( 2.0f, img[3] - 128.0f ) / 255.0f; */
		float scale = ldexp( 1.0f / 255.0f, (int)(img[3]) - 128 );
		for( j = 0; j < 3; ++j )
		{
			if( img[j] * scale > max_val )
			{
				max_val = img[j] * scale;
			}
		}
		/* next pixel */
		img += 4;
	}
	return max_val;
}

int
RGBE_to_RGBdivA
(
    unsigned char *image,
    int width, int height,
    int rescale_to_max
)
{
	/* local variables */
	int i, iv;
	unsigned char *img = image;
	float scale = 1.0f;
	/* error check */
	if( (!image) || (width < 1) || (height < 1) )
	{
		return 0;
	}
	/* convert (note: no negative numbers, but 0.0 is possible) */
	if( rescale_to_max )
	{
		scale = 255.0f / find_max_RGBE( image, width, height );
	}
	for( i = width * height; i > 0; --i )
	{
		/* decode this pixel, and find the max */
		float r,g,b,e, m;
		/* e = scale * powf( 2.0f, img[3] - 128.0f ) / 255.0f; */
		e = scale * ldexp( 1.0f / 255.0f, (int)(img[3]) - 128 );
		r = e * img[0];
		g = e * img[1];
		b = e * img[2];
		m = (r > g) ? r : g;
		m = (b > m) ? b : m;
		/* and encode it into RGBdivA */
		iv = (m != 0.0f) ? (int)(255.0f / m) : 1.0f;
		iv = (iv < 1) ? 1 : iv;
		img[3] = (iv > 255) ? 255 : iv;
		iv = (int)(img[3] * r + 0.5f);
		img[0] = (iv > 255) ? 255 : iv;
		iv = (int)(img[3] * g + 0.5f);
		img[1] = (iv > 255) ? 255 : iv;
		iv = (int)(img[3] * b + 0.5f);
		img[2] = (iv > 255) ? 255 : iv;
		/* and on to the next pixel */
		img += 4;
	}
	return 1;
}

int
RGBE_to_RGBdivA2
(
    unsigned char *image,
    int width, int height,
    int rescale_to_max
)
{
	/* local variables */
	int i, iv;
	unsigned char *img = image;
	float scale = 1.0f;
	/* error check */
	if( (!image) || (width < 1) || (height < 1) )
	{
		return 0;
	}
	/* convert (note: no negative numbers, but 0.0 is possible) */
	if( rescale_to_max )
	{
		scale = 255.0f * 255.0f / find_max_RGBE( image, width, height );
	}
	for( i = width * height; i > 0; --i )
	{
		/* decode this pixel, and find the max */
		float r,g,b,e, m;
		/* e = scale * powf( 2.0f, img[3] - 128.0f ) / 255.0f; */
		e = scale * ldexp( 1.0f / 255.0f, (int)(img[3]) - 128 );
		r = e * img[0];
		g = e * img[1];
		b = e * img[2];
		m = (r > g) ? r : g;
		m = (b > m) ? b : m;
		/* and encode it into RGBdivA */
		iv = (m != 0.0f) ? (int)sqrtf( 255.0f * 255.0f / m ) : 1.0f;
		iv = (iv < 1) ? 1 : iv;
		img[3] = (iv > 255) ? 255 : iv;
		iv = (int)(img[3] * img[3] * r / 255.0f + 0.5f);
		img[0] = (iv > 255) ? 255 : iv;
		iv = (int)(img[3] * img[3] * g / 255.0f + 0.5f);
		img[1] = (iv > 255) ? 255 : iv;
		iv = (int)(img[3] * img[3] * b / 255.0f + 0.5f);
		img[2] = (iv > 255) ? 255 : iv;
		/* and on to the next pixel */
		img += 4;
	}
	return 1;
}

```

`sakura/libs/image/image_helper.h`:

```h
/*
    Jonathan Dummer

    Image helper functions

    MIT license
*/

#ifndef HEADER_IMAGE_HELPER
#define HEADER_IMAGE_HELPER

#ifdef __cplusplus
extern "C" {
#endif

/**
	This function upscales an image.
	Not to be used to create MIPmaps,
	but to make it square,
	or to make it a power-of-two sized.
**/
int
	up_scale_image
	(
		const unsigned char* const orig,
		int width, int height, int channels,
		unsigned char* resampled,
		int resampled_width, int resampled_height
	);

/**
	This function downscales an image.
	Used for creating MIPmaps,
	the incoming image should be a
	power-of-two sized.
**/
int
	mipmap_image
	(
		const unsigned char* const orig,
		int width, int height, int channels,
		unsigned char* resampled,
		int block_size_x, int block_size_y
	);

/**
	This function takes the RGB components of the image
	and scales each channel from [0,255] to [16,235].
	This makes the colors "Safe" for display on NTSC
	displays.  Note that this is _NOT_ a good idea for
	loading images like normal- or height-maps!
**/
int
	scale_image_RGB_to_NTSC_safe
	(
		unsigned char* orig,
		int width, int height, int channels
	);

/**
	This function takes the RGB components of the image
	and converts them into YCoCg.  3 components will be
	re-ordered to CoYCg (for optimum DXT1 compression),
	while 4 components will be ordered CoCgAY (for DXT5
	compression).
**/
int
	convert_RGB_to_YCoCg
	(
		unsigned char* orig,
		int width, int height, int channels
	);

/**
	This function takes the YCoCg components of the image
	and converts them into RGB.  See above.
**/
int
	convert_YCoCg_to_RGB
	(
		unsigned char* orig,
		int width, int height, int channels
	);

/**
	Converts an HDR image from an array
	of unsigned chars (RGBE) to RGBdivA
	\return 0 if failed, otherwise returns 1
**/
int
	RGBE_to_RGBdivA
	(
		unsigned char *image,
		int width, int height,
		int rescale_to_max
	);

/**
	Converts an HDR image from an array
	of unsigned chars (RGBE) to RGBdivA2
	\return 0 if failed, otherwise returns 1
**/
int
	RGBE_to_RGBdivA2
	(
		unsigned char *image,
		int width, int height,
		int rescale_to_max
	);

#ifdef __cplusplus
}
#endif

#endif /* HEADER_IMAGE_HELPER	*/

```

`sakura/libs/image/imstb_rectpack.h`:

```h
// [DEAR IMGUI]
// This is a slightly modified version of stb_rect_pack.h 1.01.
// Grep for [DEAR IMGUI] to find the changes.
// 
// stb_rect_pack.h - v1.01 - public domain - rectangle packing
// Sean Barrett 2014
//
// Useful for e.g. packing rectangular textures into an atlas.
// Does not do rotation.
//
// Before #including,
//
//    #define STB_RECT_PACK_IMPLEMENTATION
//
// in the file that you want to have the implementation.
//
// Not necessarily the awesomest packing method, but better than
// the totally naive one in stb_truetype (which is primarily what
// this is meant to replace).
//
// Has only had a few tests run, may have issues.
//
// More docs to come.
//
// No memory allocations; uses qsort() and assert() from stdlib.
// Can override those by defining STBRP_SORT and STBRP_ASSERT.
//
// This library currently uses the Skyline Bottom-Left algorithm.
//
// Please note: better rectangle packers are welcome! Please
// implement them to the same API, but with a different init
// function.
//
// Credits
//
//  Library
//    Sean Barrett
//  Minor features
//    Martins Mozeiko
//    github:IntellectualKitty
//
//  Bugfixes / warning fixes
//    Jeremy Jaussaud
//    Fabian Giesen
//
// Version history:
//
//     1.01  (2021-07-11)  always use large rect mode, expose STBRP__MAXVAL in public section
//     1.00  (2019-02-25)  avoid small space waste; gracefully fail too-wide rectangles
//     0.99  (2019-02-07)  warning fixes
//     0.11  (2017-03-03)  return packing success/fail result
//     0.10  (2016-10-25)  remove cast-away-const to avoid warnings
//     0.09  (2016-08-27)  fix compiler warnings
//     0.08  (2015-09-13)  really fix bug with empty rects (w=0 or h=0)
//     0.07  (2015-09-13)  fix bug with empty rects (w=0 or h=0)
//     0.06  (2015-04-15)  added STBRP_SORT to allow replacing qsort
//     0.05:  added STBRP_ASSERT to allow replacing assert
//     0.04:  fixed minor bug in STBRP_LARGE_RECTS support
//     0.01:  initial release
//
// LICENSE
//
//   See end of file for license information.

//////////////////////////////////////////////////////////////////////////////
//
//       INCLUDE SECTION
//

#ifndef STB_INCLUDE_STB_RECT_PACK_H
#define STB_INCLUDE_STB_RECT_PACK_H

#define STB_RECT_PACK_VERSION  1

#ifdef STBRP_STATIC
#define STBRP_DEF static
#else
#define STBRP_DEF extern
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef struct stbrp_context stbrp_context;
typedef struct stbrp_node    stbrp_node;
typedef struct stbrp_rect    stbrp_rect;

typedef int            stbrp_coord;

#define STBRP__MAXVAL  0x7fffffff
// Mostly for internal use, but this is the maximum supported coordinate value.

STBRP_DEF int stbrp_pack_rects (stbrp_context *context, stbrp_rect *rects, int num_rects);
// Assign packed locations to rectangles. The rectangles are of type
// 'stbrp_rect' defined below, stored in the array 'rects', and there
// are 'num_rects' many of them.
//
// Rectangles which are successfully packed have the 'was_packed' flag
// set to a non-zero value and 'x' and 'y' store the minimum location
// on each axis (i.e. bottom-left in cartesian coordinates, top-left
// if you imagine y increasing downwards). Rectangles which do not fit
// have the 'was_packed' flag set to 0.
//
// You should not try to access the 'rects' array from another thread
// while this function is running, as the function temporarily reorders
// the array while it executes.
//
// To pack into another rectangle, you need to call stbrp_init_target
// again. To continue packing into the same rectangle, you can call
// this function again. Calling this multiple times with multiple rect
// arrays will probably produce worse packing results than calling it
// a single time with the full rectangle array, but the option is
// available.
//
// The function returns 1 if all of the rectangles were successfully
// packed and 0 otherwise.

struct stbrp_rect
{
   // reserved for your use:
   int            id;

   // input:
   stbrp_coord    w, h;

   // output:
   stbrp_coord    x, y;
   int            was_packed;  // non-zero if valid packing

}; // 16 bytes, nominally


STBRP_DEF void stbrp_init_target (stbrp_context *context, int width, int height, stbrp_node *nodes, int num_nodes);
// Initialize a rectangle packer to:
//    pack a rectangle that is 'width' by 'height' in dimensions
//    using temporary storage provided by the array 'nodes', which is 'num_nodes' long
//
// You must call this function every time you start packing into a new target.
//
// There is no "shutdown" function. The 'nodes' memory must stay valid for
// the following stbrp_pack_rects() call (or calls), but can be freed after
// the call (or calls) finish.
//
// Note: to guarantee best results, either:
//       1. make sure 'num_nodes' >= 'width'
//   or  2. call stbrp_allow_out_of_mem() defined below with 'allow_out_of_mem = 1'
//
// If you don't do either of the above things, widths will be quantized to multiples
// of small integers to guarantee the algorithm doesn't run out of temporary storage.
//
// If you do #2, then the non-quantized algorithm will be used, but the algorithm
// may run out of temporary storage and be unable to pack some rectangles.

STBRP_DEF void stbrp_setup_allow_out_of_mem (stbrp_context *context, int allow_out_of_mem);
// Optionally call this function after init but before doing any packing to
// change the handling of the out-of-temp-memory scenario, described above.
// If you call init again, this will be reset to the default (false).


STBRP_DEF void stbrp_setup_heuristic (stbrp_context *context, int heuristic);
// Optionally select which packing heuristic the library should use. Different
// heuristics will produce better/worse results for different data sets.
// If you call init again, this will be reset to the default.

enum
{
   STBRP_HEURISTIC_Skyline_default=0,
   STBRP_HEURISTIC_Skyline_BL_sortHeight = STBRP_HEURISTIC_Skyline_default,
   STBRP_HEURISTIC_Skyline_BF_sortHeight
};


//////////////////////////////////////////////////////////////////////////////
//
// the details of the following structures don't matter to you, but they must
// be visible so you can handle the memory allocations for them

struct stbrp_node
{
   stbrp_coord  x,y;
   stbrp_node  *next;
};

struct stbrp_context
{
   int width;
   int height;
   int align;
   int init_mode;
   int heuristic;
   int num_nodes;
   stbrp_node *active_head;
   stbrp_node *free_head;
   stbrp_node extra[2]; // we allocate two extra nodes so optimal user-node-count is 'width' not 'width+2'
};

#ifdef __cplusplus
}
#endif

#endif

//////////////////////////////////////////////////////////////////////////////
//
//     IMPLEMENTATION SECTION
//

#ifdef STB_RECT_PACK_IMPLEMENTATION
#ifndef STBRP_SORT
#include <stdlib.h>
#define STBRP_SORT qsort
#endif

#ifndef STBRP_ASSERT
#include <assert.h>
#define STBRP_ASSERT assert
#endif

#ifdef _MSC_VER
#define STBRP__NOTUSED(v)  (void)(v)
#define STBRP__CDECL       __cdecl
#else
#define STBRP__NOTUSED(v)  (void)sizeof(v)
#define STBRP__CDECL
#endif

enum
{
   STBRP__INIT_skyline = 1
};

STBRP_DEF void stbrp_setup_heuristic(stbrp_context *context, int heuristic)
{
   switch (context->init_mode) {
      case STBRP__INIT_skyline:
         STBRP_ASSERT(heuristic == STBRP_HEURISTIC_Skyline_BL_sortHeight || heuristic == STBRP_HEURISTIC_Skyline_BF_sortHeight);
         context->heuristic = heuristic;
         break;
      default:
         STBRP_ASSERT(0);
   }
}

STBRP_DEF void stbrp_setup_allow_out_of_mem(stbrp_context *context, int allow_out_of_mem)
{
   if (allow_out_of_mem)
      // if it's ok to run out of memory, then don't bother aligning them;
      // this gives better packing, but may fail due to OOM (even though
      // the rectangles easily fit). @TODO a smarter approach would be to only
      // quantize once we've hit OOM, then we could get rid of this parameter.
      context->align = 1;
   else {
      // if it's not ok to run out of memory, then quantize the widths
      // so that num_nodes is always enough nodes.
      //
      // I.e. num_nodes * align >= width
      //                  align >= width / num_nodes
      //                  align = ceil(width/num_nodes)

      context->align = (context->width + context->num_nodes-1) / context->num_nodes;
   }
}

STBRP_DEF void stbrp_init_target(stbrp_context *context, int width, int height, stbrp_node *nodes, int num_nodes)
{
   int i;

   for (i=0; i < num_nodes-1; ++i)
      nodes[i].next = &nodes[i+1];
   nodes[i].next = NULL;
   context->init_mode = STBRP__INIT_skyline;
   context->heuristic = STBRP_HEURISTIC_Skyline_default;
   context->free_head = &nodes[0];
   context->active_head = &context->extra[0];
   context->width = width;
   context->height = height;
   context->num_nodes = num_nodes;
   stbrp_setup_allow_out_of_mem(context, 0);

   // node 0 is the full width, node 1 is the sentinel (lets us not store width explicitly)
   context->extra[0].x = 0;
   context->extra[0].y = 0;
   context->extra[0].next = &context->extra[1];
   context->extra[1].x = (stbrp_coord) width;
   context->extra[1].y = (1<<30);
   context->extra[1].next = NULL;
}

// find minimum y position if it starts at x1
static int stbrp__skyline_find_min_y(stbrp_context *c, stbrp_node *first, int x0, int width, int *pwaste)
{
   stbrp_node *node = first;
   int x1 = x0 + width;
   int min_y, visited_width, waste_area;

   STBRP__NOTUSED(c);

   STBRP_ASSERT(first->x <= x0);

   #if 0
   // skip in case we're past the node
   while (node->next->x <= x0)
      ++node;
   #else
   STBRP_ASSERT(node->next->x > x0); // we ended up handling this in the caller for efficiency
   #endif

   STBRP_ASSERT(node->x <= x0);

   min_y = 0;
   waste_area = 0;
   visited_width = 0;
   while (node->x < x1) {
      if (node->y > min_y) {
         // raise min_y higher.
         // we've accounted for all waste up to min_y,
         // but we'll now add more waste for everything we've visted
         waste_area += visited_width * (node->y - min_y);
         min_y = node->y;
         // the first time through, visited_width might be reduced
         if (node->x < x0)
            visited_width += node->next->x - x0;
         else
            visited_width += node->next->x - node->x;
      } else {
         // add waste area
         int under_width = node->next->x - node->x;
         if (under_width + visited_width > width)
            under_width = width - visited_width;
         waste_area += under_width * (min_y - node->y);
         visited_width += under_width;
      }
      node = node->next;
   }

   *pwaste = waste_area;
   return min_y;
}

typedef struct
{
   int x,y;
   stbrp_node **prev_link;
} stbrp__findresult;

static stbrp__findresult stbrp__skyline_find_best_pos(stbrp_context *c, int width, int height)
{
   int best_waste = (1<<30), best_x, best_y = (1 << 30);
   stbrp__findresult fr;
   stbrp_node **prev, *node, *tail, **best = NULL;

   // align to multiple of c->align
   width = (width + c->align - 1);
   width -= width % c->align;
   STBRP_ASSERT(width % c->align == 0);

   // if it can't possibly fit, bail immediately
   if (width > c->width || height > c->height) {
      fr.prev_link = NULL;
      fr.x = fr.y = 0;
      return fr;
   }

   node = c->active_head;
   prev = &c->active_head;
   while (node->x + width <= c->width) {
      int y,waste;
      y = stbrp__skyline_find_min_y(c, node, node->x, width, &waste);
      if (c->heuristic == STBRP_HEURISTIC_Skyline_BL_sortHeight) { // actually just want to test BL
         // bottom left
         if (y < best_y) {
            best_y = y;
            best = prev;
         }
      } else {
         // best-fit
         if (y + height <= c->height) {
            // can only use it if it first vertically
            if (y < best_y || (y == best_y && waste < best_waste)) {
               best_y = y;
               best_waste = waste;
               best = prev;
            }
         }
      }
      prev = &node->next;
      node = node->next;
   }

   best_x = (best == NULL) ? 0 : (*best)->x;

   // if doing best-fit (BF), we also have to try aligning right edge to each node position
   //
   // e.g, if fitting
   //
   //     ____________________
   //    |____________________|
   //
   //            into
   //
   //   |                         |
   //   |             ____________|
   //   |____________|
   //
   // then right-aligned reduces waste, but bottom-left BL is always chooses left-aligned
   //
   // This makes BF take about 2x the time

   if (c->heuristic == STBRP_HEURISTIC_Skyline_BF_sortHeight) {
      tail = c->active_head;
      node = c->active_head;
      prev = &c->active_head;
      // find first node that's admissible
      while (tail->x < width)
         tail = tail->next;
      while (tail) {
         int xpos = tail->x - width;
         int y,waste;
         STBRP_ASSERT(xpos >= 0);
         // find the left position that matches this
         while (node->next->x <= xpos) {
            prev = &node->next;
            node = node->next;
         }
         STBRP_ASSERT(node->next->x > xpos && node->x <= xpos);
         y = stbrp__skyline_find_min_y(c, node, xpos, width, &waste);
         if (y + height <= c->height) {
            if (y <= best_y) {
               if (y < best_y || waste < best_waste || (waste==best_waste && xpos < best_x)) {
                  best_x = xpos;
                  //STBRP_ASSERT(y <= best_y); [DEAR IMGUI]
                  best_y = y;
                  best_waste = waste;
                  best = prev;
               }
            }
         }
         tail = tail->next;
      }
   }

   fr.prev_link = best;
   fr.x = best_x;
   fr.y = best_y;
   return fr;
}

static stbrp__findresult stbrp__skyline_pack_rectangle(stbrp_context *context, int width, int height)
{
   // find best position according to heuristic
   stbrp__findresult res = stbrp__skyline_find_best_pos(context, width, height);
   stbrp_node *node, *cur;

   // bail if:
   //    1. it failed
   //    2. the best node doesn't fit (we don't always check this)
   //    3. we're out of memory
   if (res.prev_link == NULL || res.y + height > context->height || context->free_head == NULL) {
      res.prev_link = NULL;
      return res;
   }

   // on success, create new node
   node = context->free_head;
   node->x = (stbrp_coord) res.x;
   node->y = (stbrp_coord) (res.y + height);

   context->free_head = node->next;

   // insert the new node into the right starting point, and
   // let 'cur' point to the remaining nodes needing to be
   // stiched back in

   cur = *res.prev_link;
   if (cur->x < res.x) {
      // preserve the existing one, so start testing with the next one
      stbrp_node *next = cur->next;
      cur->next = node;
      cur = next;
   } else {
      *res.prev_link = node;
   }

   // from here, traverse cur and free the nodes, until we get to one
   // that shouldn't be freed
   while (cur->next && cur->next->x <= res.x + width) {
      stbrp_node *next = cur->next;
      // move the current node to the free list
      cur->next = context->free_head;
      context->free_head = cur;
      cur = next;
   }

   // stitch the list back in
   node->next = cur;

   if (cur->x < res.x + width)
      cur->x = (stbrp_coord) (res.x + width);

#ifdef _DEBUG
   cur = context->active_head;
   while (cur->x < context->width) {
      STBRP_ASSERT(cur->x < cur->next->x);
      cur = cur->next;
   }
   STBRP_ASSERT(cur->next == NULL);

   {
      int count=0;
      cur = context->active_head;
      while (cur) {
         cur = cur->next;
         ++count;
      }
      cur = context->free_head;
      while (cur) {
         cur = cur->next;
         ++count;
      }
      STBRP_ASSERT(count == context->num_nodes+2);
   }
#endif

   return res;
}

static int STBRP__CDECL rect_height_compare(const void *a, const void *b)
{
   const stbrp_rect *p = (const stbrp_rect *) a;
   const stbrp_rect *q = (const stbrp_rect *) b;
   if (p->h > q->h)
      return -1;
   if (p->h < q->h)
      return  1;
   return (p->w > q->w) ? -1 : (p->w < q->w);
}

static int STBRP__CDECL rect_original_order(const void *a, const void *b)
{
   const stbrp_rect *p = (const stbrp_rect *) a;
   const stbrp_rect *q = (const stbrp_rect *) b;
   return (p->was_packed < q->was_packed) ? -1 : (p->was_packed > q->was_packed);
}

STBRP_DEF int stbrp_pack_rects(stbrp_context *context, stbrp_rect *rects, int num_rects)
{
   int i, all_rects_packed = 1;

   // we use the 'was_packed' field internally to allow sorting/unsorting
   for (i=0; i < num_rects; ++i) {
      rects[i].was_packed = i;
   }

   // sort according to heuristic
   STBRP_SORT(rects, num_rects, sizeof(rects[0]), rect_height_compare);

   for (i=0; i < num_rects; ++i) {
      if (rects[i].w == 0 || rects[i].h == 0) {
         rects[i].x = rects[i].y = 0;  // empty rect needs no space
      } else {
         stbrp__findresult fr = stbrp__skyline_pack_rectangle(context, rects[i].w, rects[i].h);
         if (fr.prev_link) {
            rects[i].x = (stbrp_coord) fr.x;
            rects[i].y = (stbrp_coord) fr.y;
         } else {
            rects[i].x = rects[i].y = STBRP__MAXVAL;
         }
      }
   }

   // unsort
   STBRP_SORT(rects, num_rects, sizeof(rects[0]), rect_original_order);

   // set was_packed flags and all_rects_packed status
   for (i=0; i < num_rects; ++i) {
      rects[i].was_packed = !(rects[i].x == STBRP__MAXVAL && rects[i].y == STBRP__MAXVAL);
      if (!rects[i].was_packed)
         all_rects_packed = 0;
   }

   // return the all_rects_packed status
   return all_rects_packed;
}
#endif

/*
------------------------------------------------------------------------------
This software is available under 2 licenses -- choose whichever you prefer.
------------------------------------------------------------------------------
ALTERNATIVE A - MIT License
Copyright (c) 2017 Sean Barrett
Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
------------------------------------------------------------------------------
ALTERNATIVE B - Public Domain (www.unlicense.org)
This is free and unencumbered software released into the public domain.
Anyone is free to copy, modify, publish, use, compile, sell, or distribute this
software, either in source code form or as a compiled binary, for any purpose,
commercial or non-commercial, and by any means.
In jurisdictions that recognize copyright laws, the author or authors of this
software dedicate any and all copyright interest in the software to the public
domain. We make this dedication for the benefit of the public at large and to
the detriment of our heirs and successors. We intend this dedication to be an
overt act of relinquishment in perpetuity of all present and future rights to
this software under copyright law.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
------------------------------------------------------------------------------
*/

```

`sakura/libs/image/imstb_textedit.h`:

```h
// [DEAR IMGUI]
// This is a slightly modified version of stb_textedit.h 1.14.
// Those changes would need to be pushed into nothings/stb:
// - Fix in stb_textedit_discard_redo (see https://github.com/nothings/stb/issues/321)
// - Fix in stb_textedit_find_charpos to handle last line (see https://github.com/ocornut/imgui/issues/6000)
// Grep for [DEAR IMGUI] to find the changes.

// stb_textedit.h - v1.14  - public domain - Sean Barrett
// Development of this library was sponsored by RAD Game Tools
//
// This C header file implements the guts of a multi-line text-editing
// widget; you implement display, word-wrapping, and low-level string
// insertion/deletion, and stb_textedit will map user inputs into
// insertions & deletions, plus updates to the cursor position,
// selection state, and undo state.
//
// It is intended for use in games and other systems that need to build
// their own custom widgets and which do not have heavy text-editing
// requirements (this library is not recommended for use for editing large
// texts, as its performance does not scale and it has limited undo).
//
// Non-trivial behaviors are modelled after Windows text controls.
//
//
// LICENSE
//
// See end of file for license information.
//
//
// DEPENDENCIES
//
// Uses the C runtime function 'memmove', which you can override
// by defining STB_TEXTEDIT_memmove before the implementation.
// Uses no other functions. Performs no runtime allocations.
//
//
// VERSION HISTORY
//
//   1.14 (2021-07-11) page up/down, various fixes
//   1.13 (2019-02-07) fix bug in undo size management
//   1.12 (2018-01-29) user can change STB_TEXTEDIT_KEYTYPE, fix redo to avoid crash
//   1.11 (2017-03-03) fix HOME on last line, dragging off single-line textfield
//   1.10 (2016-10-25) supress warnings about casting away const with -Wcast-qual
//   1.9  (2016-08-27) customizable move-by-word
//   1.8  (2016-04-02) better keyboard handling when mouse button is down
//   1.7  (2015-09-13) change y range handling in case baseline is non-0
//   1.6  (2015-04-15) allow STB_TEXTEDIT_memmove
//   1.5  (2014-09-10) add support for secondary keys for OS X
//   1.4  (2014-08-17) fix signed/unsigned warnings
//   1.3  (2014-06-19) fix mouse clicking to round to nearest char boundary
//   1.2  (2014-05-27) fix some RAD types that had crept into the new code
//   1.1  (2013-12-15) move-by-word (requires STB_TEXTEDIT_IS_SPACE )
//   1.0  (2012-07-26) improve documentation, initial public release
//   0.3  (2012-02-24) bugfixes, single-line mode; insert mode
//   0.2  (2011-11-28) fixes to undo/redo
//   0.1  (2010-07-08) initial version
//
// ADDITIONAL CONTRIBUTORS
//
//   Ulf Winklemann: move-by-word in 1.1
//   Fabian Giesen: secondary key inputs in 1.5
//   Martins Mozeiko: STB_TEXTEDIT_memmove in 1.6
//   Louis Schnellbach: page up/down in 1.14
//
//   Bugfixes:
//      Scott Graham
//      Daniel Keller
//      Omar Cornut
//      Dan Thompson
//
// USAGE
//
// This file behaves differently depending on what symbols you define
// before including it.
//
//
// Header-file mode:
//
//   If you do not define STB_TEXTEDIT_IMPLEMENTATION before including this,
//   it will operate in "header file" mode. In this mode, it declares a
//   single public symbol, STB_TexteditState, which encapsulates the current
//   state of a text widget (except for the string, which you will store
//   separately).
//
//   To compile in this mode, you must define STB_TEXTEDIT_CHARTYPE to a
//   primitive type that defines a single character (e.g. char, wchar_t, etc).
//
//   To save space or increase undo-ability, you can optionally define the
//   following things that are used by the undo system:
//
//      STB_TEXTEDIT_POSITIONTYPE         small int type encoding a valid cursor position
//      STB_TEXTEDIT_UNDOSTATECOUNT       the number of undo states to allow
//      STB_TEXTEDIT_UNDOCHARCOUNT        the number of characters to store in the undo buffer
//
//   If you don't define these, they are set to permissive types and
//   moderate sizes. The undo system does no memory allocations, so
//   it grows STB_TexteditState by the worst-case storage which is (in bytes):
//
//        [4 + 3 * sizeof(STB_TEXTEDIT_POSITIONTYPE)] * STB_TEXTEDIT_UNDOSTATECOUNT
//      +          sizeof(STB_TEXTEDIT_CHARTYPE)      * STB_TEXTEDIT_UNDOCHARCOUNT
//
//
// Implementation mode:
//
//   If you define STB_TEXTEDIT_IMPLEMENTATION before including this, it
//   will compile the implementation of the text edit widget, depending
//   on a large number of symbols which must be defined before the include.
//
//   The implementation is defined only as static functions. You will then
//   need to provide your own APIs in the same file which will access the
//   static functions.
//
//   The basic concept is that you provide a "string" object which
//   behaves like an array of characters. stb_textedit uses indices to
//   refer to positions in the string, implicitly representing positions
//   in the displayed textedit. This is true for both plain text and
//   rich text; even with rich text stb_truetype interacts with your
//   code as if there was an array of all the displayed characters.
//
// Symbols that must be the same in header-file and implementation mode:
//
//     STB_TEXTEDIT_CHARTYPE             the character type
//     STB_TEXTEDIT_POSITIONTYPE         small type that is a valid cursor position
//     STB_TEXTEDIT_UNDOSTATECOUNT       the number of undo states to allow
//     STB_TEXTEDIT_UNDOCHARCOUNT        the number of characters to store in the undo buffer
//
// Symbols you must define for implementation mode:
//
//    STB_TEXTEDIT_STRING               the type of object representing a string being edited,
//                                      typically this is a wrapper object with other data you need
//
//    STB_TEXTEDIT_STRINGLEN(obj)       the length of the string (ideally O(1))
//    STB_TEXTEDIT_LAYOUTROW(&r,obj,n)  returns the results of laying out a line of characters
//                                        starting from character #n (see discussion below)
//    STB_TEXTEDIT_GETWIDTH(obj,n,i)    returns the pixel delta from the xpos of the i'th character
//                                        to the xpos of the i+1'th char for a line of characters
//                                        starting at character #n (i.e. accounts for kerning
//                                        with previous char)
//    STB_TEXTEDIT_KEYTOTEXT(k)         maps a keyboard input to an insertable character
//                                        (return type is int, -1 means not valid to insert)
//    STB_TEXTEDIT_GETCHAR(obj,i)       returns the i'th character of obj, 0-based
//    STB_TEXTEDIT_NEWLINE              the character returned by _GETCHAR() we recognize
//                                        as manually wordwrapping for end-of-line positioning
//
//    STB_TEXTEDIT_DELETECHARS(obj,i,n)      delete n characters starting at i
//    STB_TEXTEDIT_INSERTCHARS(obj,i,c*,n)   insert n characters at i (pointed to by STB_TEXTEDIT_CHARTYPE*)
//
//    STB_TEXTEDIT_K_SHIFT       a power of two that is or'd in to a keyboard input to represent the shift key
//
//    STB_TEXTEDIT_K_LEFT        keyboard input to move cursor left
//    STB_TEXTEDIT_K_RIGHT       keyboard input to move cursor right
//    STB_TEXTEDIT_K_UP          keyboard input to move cursor up
//    STB_TEXTEDIT_K_DOWN        keyboard input to move cursor down
//    STB_TEXTEDIT_K_PGUP        keyboard input to move cursor up a page
//    STB_TEXTEDIT_K_PGDOWN      keyboard input to move cursor down a page
//    STB_TEXTEDIT_K_LINESTART   keyboard input to move cursor to start of line  // e.g. HOME
//    STB_TEXTEDIT_K_LINEEND     keyboard input to move cursor to end of line    // e.g. END
//    STB_TEXTEDIT_K_TEXTSTART   keyboard input to move cursor to start of text  // e.g. ctrl-HOME
//    STB_TEXTEDIT_K_TEXTEND     keyboard input to move cursor to end of text    // e.g. ctrl-END
//    STB_TEXTEDIT_K_DELETE      keyboard input to delete selection or character under cursor
//    STB_TEXTEDIT_K_BACKSPACE   keyboard input to delete selection or character left of cursor
//    STB_TEXTEDIT_K_UNDO        keyboard input to perform undo
//    STB_TEXTEDIT_K_REDO        keyboard input to perform redo
//
// Optional:
//    STB_TEXTEDIT_K_INSERT              keyboard input to toggle insert mode
//    STB_TEXTEDIT_IS_SPACE(ch)          true if character is whitespace (e.g. 'isspace'),
//                                          required for default WORDLEFT/WORDRIGHT handlers
//    STB_TEXTEDIT_MOVEWORDLEFT(obj,i)   custom handler for WORDLEFT, returns index to move cursor to
//    STB_TEXTEDIT_MOVEWORDRIGHT(obj,i)  custom handler for WORDRIGHT, returns index to move cursor to
//    STB_TEXTEDIT_K_WORDLEFT            keyboard input to move cursor left one word // e.g. ctrl-LEFT
//    STB_TEXTEDIT_K_WORDRIGHT           keyboard input to move cursor right one word // e.g. ctrl-RIGHT
//    STB_TEXTEDIT_K_LINESTART2          secondary keyboard input to move cursor to start of line
//    STB_TEXTEDIT_K_LINEEND2            secondary keyboard input to move cursor to end of line
//    STB_TEXTEDIT_K_TEXTSTART2          secondary keyboard input to move cursor to start of text
//    STB_TEXTEDIT_K_TEXTEND2            secondary keyboard input to move cursor to end of text
//
// Keyboard input must be encoded as a single integer value; e.g. a character code
// and some bitflags that represent shift states. to simplify the interface, SHIFT must
// be a bitflag, so we can test the shifted state of cursor movements to allow selection,
// i.e. (STB_TEXTEDIT_K_RIGHT|STB_TEXTEDIT_K_SHIFT) should be shifted right-arrow.
//
// You can encode other things, such as CONTROL or ALT, in additional bits, and
// then test for their presence in e.g. STB_TEXTEDIT_K_WORDLEFT. For example,
// my Windows implementations add an additional CONTROL bit, and an additional KEYDOWN
// bit. Then all of the STB_TEXTEDIT_K_ values bitwise-or in the KEYDOWN bit,
// and I pass both WM_KEYDOWN and WM_CHAR events to the "key" function in the
// API below. The control keys will only match WM_KEYDOWN events because of the
// keydown bit I add, and STB_TEXTEDIT_KEYTOTEXT only tests for the KEYDOWN
// bit so it only decodes WM_CHAR events.
//
// STB_TEXTEDIT_LAYOUTROW returns information about the shape of one displayed
// row of characters assuming they start on the i'th character--the width and
// the height and the number of characters consumed. This allows this library
// to traverse the entire layout incrementally. You need to compute word-wrapping
// here.
//
// Each textfield keeps its own insert mode state, which is not how normal
// applications work. To keep an app-wide insert mode, update/copy the
// "insert_mode" field of STB_TexteditState before/after calling API functions.
//
// API
//
//    void stb_textedit_initialize_state(STB_TexteditState *state, int is_single_line)
//
//    void stb_textedit_click(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)
//    void stb_textedit_drag(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)
//    int  stb_textedit_cut(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
//    int  stb_textedit_paste(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_CHARTYPE *text, int len)
//    void stb_textedit_key(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXEDIT_KEYTYPE key)
//
//    Each of these functions potentially updates the string and updates the
//    state.
//
//      initialize_state:
//          set the textedit state to a known good default state when initially
//          constructing the textedit.
//
//      click:
//          call this with the mouse x,y on a mouse down; it will update the cursor
//          and reset the selection start/end to the cursor point. the x,y must
//          be relative to the text widget, with (0,0) being the top left.
//
//      drag:
//          call this with the mouse x,y on a mouse drag/up; it will update the
//          cursor and the selection end point
//
//      cut:
//          call this to delete the current selection; returns true if there was
//          one. you should FIRST copy the current selection to the system paste buffer.
//          (To copy, just copy the current selection out of the string yourself.)
//
//      paste:
//          call this to paste text at the current cursor point or over the current
//          selection if there is one.
//
//      key:
//          call this for keyboard inputs sent to the textfield. you can use it
//          for "key down" events or for "translated" key events. if you need to
//          do both (as in Win32), or distinguish Unicode characters from control
//          inputs, set a high bit to distinguish the two; then you can define the
//          various definitions like STB_TEXTEDIT_K_LEFT have the is-key-event bit
//          set, and make STB_TEXTEDIT_KEYTOCHAR check that the is-key-event bit is
//          clear. STB_TEXTEDIT_KEYTYPE defaults to int, but you can #define it to
//          anything other type you wante before including.
//
//
//   When rendering, you can read the cursor position and selection state from
//   the STB_TexteditState.
//
//
// Notes:
//
// This is designed to be usable in IMGUI, so it allows for the possibility of
// running in an IMGUI that has NOT cached the multi-line layout. For this
// reason, it provides an interface that is compatible with computing the
// layout incrementally--we try to make sure we make as few passes through
// as possible. (For example, to locate the mouse pointer in the text, we
// could define functions that return the X and Y positions of characters
// and binary search Y and then X, but if we're doing dynamic layout this
// will run the layout algorithm many times, so instead we manually search
// forward in one pass. Similar logic applies to e.g. up-arrow and
// down-arrow movement.)
//
// If it's run in a widget that *has* cached the layout, then this is less
// efficient, but it's not horrible on modern computers. But you wouldn't
// want to edit million-line files with it.


////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////
////   Header-file mode
////
////

#ifndef INCLUDE_STB_TEXTEDIT_H
#define INCLUDE_STB_TEXTEDIT_H

////////////////////////////////////////////////////////////////////////
//
//     STB_TexteditState
//
// Definition of STB_TexteditState which you should store
// per-textfield; it includes cursor position, selection state,
// and undo state.
//

#ifndef STB_TEXTEDIT_UNDOSTATECOUNT
#define STB_TEXTEDIT_UNDOSTATECOUNT   99
#endif
#ifndef STB_TEXTEDIT_UNDOCHARCOUNT
#define STB_TEXTEDIT_UNDOCHARCOUNT   999
#endif
#ifndef STB_TEXTEDIT_CHARTYPE
#define STB_TEXTEDIT_CHARTYPE        int
#endif
#ifndef STB_TEXTEDIT_POSITIONTYPE
#define STB_TEXTEDIT_POSITIONTYPE    int
#endif

typedef struct
{
   // private data
   STB_TEXTEDIT_POSITIONTYPE  where;
   STB_TEXTEDIT_POSITIONTYPE  insert_length;
   STB_TEXTEDIT_POSITIONTYPE  delete_length;
   int                        char_storage;
} StbUndoRecord;

typedef struct
{
   // private data
   StbUndoRecord          undo_rec [STB_TEXTEDIT_UNDOSTATECOUNT];
   STB_TEXTEDIT_CHARTYPE  undo_char[STB_TEXTEDIT_UNDOCHARCOUNT];
   short undo_point, redo_point;
   int undo_char_point, redo_char_point;
} StbUndoState;

typedef struct
{
   /////////////////////
   //
   // public data
   //

   int cursor;
   // position of the text cursor within the string

   int select_start;          // selection start point
   int select_end;
   // selection start and end point in characters; if equal, no selection.
   // note that start may be less than or greater than end (e.g. when
   // dragging the mouse, start is where the initial click was, and you
   // can drag in either direction)

   unsigned char insert_mode;
   // each textfield keeps its own insert mode state. to keep an app-wide
   // insert mode, copy this value in/out of the app state

   int row_count_per_page;
   // page size in number of row.
   // this value MUST be set to >0 for pageup or pagedown in multilines documents.

   /////////////////////
   //
   // private data
   //
   unsigned char cursor_at_end_of_line; // not implemented yet
   unsigned char initialized;
   unsigned char has_preferred_x;
   unsigned char single_line;
   unsigned char padding1, padding2, padding3;
   float preferred_x; // this determines where the cursor up/down tries to seek to along x
   StbUndoState undostate;
} STB_TexteditState;


////////////////////////////////////////////////////////////////////////
//
//     StbTexteditRow
//
// Result of layout query, used by stb_textedit to determine where
// the text in each row is.

// result of layout query
typedef struct
{
   float x0,x1;             // starting x location, end x location (allows for align=right, etc)
   float baseline_y_delta;  // position of baseline relative to previous row's baseline
   float ymin,ymax;         // height of row above and below baseline
   int num_chars;
} StbTexteditRow;
#endif //INCLUDE_STB_TEXTEDIT_H


////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////
////   Implementation mode
////
////


// implementation isn't include-guarded, since it might have indirectly
// included just the "header" portion
#ifdef STB_TEXTEDIT_IMPLEMENTATION

#ifndef STB_TEXTEDIT_memmove
#include <string.h>
#define STB_TEXTEDIT_memmove memmove
#endif


/////////////////////////////////////////////////////////////////////////////
//
//      Mouse input handling
//

// traverse the layout to locate the nearest character to a display position
static int stb_text_locate_coord(STB_TEXTEDIT_STRING *str, float x, float y)
{
   StbTexteditRow r;
   int n = STB_TEXTEDIT_STRINGLEN(str);
   float base_y = 0, prev_x;
   int i=0, k;

   r.x0 = r.x1 = 0;
   r.ymin = r.ymax = 0;
   r.num_chars = 0;

   // search rows to find one that straddles 'y'
   while (i < n) {
      STB_TEXTEDIT_LAYOUTROW(&r, str, i);
      if (r.num_chars <= 0)
         return n;

      if (i==0 && y < base_y + r.ymin)
         return 0;

      if (y < base_y + r.ymax)
         break;

      i += r.num_chars;
      base_y += r.baseline_y_delta;
   }

   // below all text, return 'after' last character
   if (i >= n)
      return n;

   // check if it's before the beginning of the line
   if (x < r.x0)
      return i;

   // check if it's before the end of the line
   if (x < r.x1) {
      // search characters in row for one that straddles 'x'
      prev_x = r.x0;
      for (k=0; k < r.num_chars; ++k) {
         float w = STB_TEXTEDIT_GETWIDTH(str, i, k);
         if (x < prev_x+w) {
            if (x < prev_x+w/2)
               return k+i;
            else
               return k+i+1;
         }
         prev_x += w;
      }
      // shouldn't happen, but if it does, fall through to end-of-line case
   }

   // if the last character is a newline, return that. otherwise return 'after' the last character
   if (STB_TEXTEDIT_GETCHAR(str, i+r.num_chars-1) == STB_TEXTEDIT_NEWLINE)
      return i+r.num_chars-1;
   else
      return i+r.num_chars;
}

// API click: on mouse down, move the cursor to the clicked location, and reset the selection
static void stb_textedit_click(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)
{
   // In single-line mode, just always make y = 0. This lets the drag keep working if the mouse
   // goes off the top or bottom of the text
   if( state->single_line )
   {
      StbTexteditRow r;
      STB_TEXTEDIT_LAYOUTROW(&r, str, 0);
      y = r.ymin;
   }

   state->cursor = stb_text_locate_coord(str, x, y);
   state->select_start = state->cursor;
   state->select_end = state->cursor;
   state->has_preferred_x = 0;
}

// API drag: on mouse drag, move the cursor and selection endpoint to the clicked location
static void stb_textedit_drag(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)
{
   int p = 0;

   // In single-line mode, just always make y = 0. This lets the drag keep working if the mouse
   // goes off the top or bottom of the text
   if( state->single_line )
   {
      StbTexteditRow r;
      STB_TEXTEDIT_LAYOUTROW(&r, str, 0);
      y = r.ymin;
   }

   if (state->select_start == state->select_end)
      state->select_start = state->cursor;

   p = stb_text_locate_coord(str, x, y);
   state->cursor = state->select_end = p;
}

/////////////////////////////////////////////////////////////////////////////
//
//      Keyboard input handling
//

// forward declarations
static void stb_text_undo(STB_TEXTEDIT_STRING *str, STB_TexteditState *state);
static void stb_text_redo(STB_TEXTEDIT_STRING *str, STB_TexteditState *state);
static void stb_text_makeundo_delete(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int length);
static void stb_text_makeundo_insert(STB_TexteditState *state, int where, int length);
static void stb_text_makeundo_replace(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int old_length, int new_length);

typedef struct
{
   float x,y;    // position of n'th character
   float height; // height of line
   int first_char, length; // first char of row, and length
   int prev_first;  // first char of previous row
} StbFindState;

// find the x/y location of a character, and remember info about the previous row in
// case we get a move-up event (for page up, we'll have to rescan)
static void stb_textedit_find_charpos(StbFindState *find, STB_TEXTEDIT_STRING *str, int n, int single_line)
{
   StbTexteditRow r;
   int prev_start = 0;
   int z = STB_TEXTEDIT_STRINGLEN(str);
   int i=0, first;

   if (n == z && single_line) {
      // special case if it's at the end (may not be needed?)
      STB_TEXTEDIT_LAYOUTROW(&r, str, 0);
      find->y = 0;
      find->first_char = 0;
      find->length = z;
      find->height = r.ymax - r.ymin;
      find->x = r.x1;
      return;
   }

   // search rows to find the one that straddles character n
   find->y = 0;

   for(;;) {
      STB_TEXTEDIT_LAYOUTROW(&r, str, i);
      if (n < i + r.num_chars)
         break;
      if (i + r.num_chars == z && z > 0 && STB_TEXTEDIT_GETCHAR(str, z - 1) != STB_TEXTEDIT_NEWLINE)  // [DEAR IMGUI] special handling for last line
         break;   // [DEAR IMGUI]
      prev_start = i;
      i += r.num_chars;
      find->y += r.baseline_y_delta;
      if (i == z) // [DEAR IMGUI]
         break;   // [DEAR IMGUI]
   }

   find->first_char = first = i;
   find->length = r.num_chars;
   find->height = r.ymax - r.ymin;
   find->prev_first = prev_start;

   // now scan to find xpos
   find->x = r.x0;
   for (i=0; first+i < n; ++i)
      find->x += STB_TEXTEDIT_GETWIDTH(str, first, i);
}

#define STB_TEXT_HAS_SELECTION(s)   ((s)->select_start != (s)->select_end)

// make the selection/cursor state valid if client altered the string
static void stb_textedit_clamp(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
{
   int n = STB_TEXTEDIT_STRINGLEN(str);
   if (STB_TEXT_HAS_SELECTION(state)) {
      if (state->select_start > n) state->select_start = n;
      if (state->select_end   > n) state->select_end = n;
      // if clamping forced them to be equal, move the cursor to match
      if (state->select_start == state->select_end)
         state->cursor = state->select_start;
   }
   if (state->cursor > n) state->cursor = n;
}

// delete characters while updating undo
static void stb_textedit_delete(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int len)
{
   stb_text_makeundo_delete(str, state, where, len);
   STB_TEXTEDIT_DELETECHARS(str, where, len);
   state->has_preferred_x = 0;
}

// delete the section
static void stb_textedit_delete_selection(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
{
   stb_textedit_clamp(str, state);
   if (STB_TEXT_HAS_SELECTION(state)) {
      if (state->select_start < state->select_end) {
         stb_textedit_delete(str, state, state->select_start, state->select_end - state->select_start);
         state->select_end = state->cursor = state->select_start;
      } else {
         stb_textedit_delete(str, state, state->select_end, state->select_start - state->select_end);
         state->select_start = state->cursor = state->select_end;
      }
      state->has_preferred_x = 0;
   }
}

// canoncialize the selection so start <= end
static void stb_textedit_sortselection(STB_TexteditState *state)
{
   if (state->select_end < state->select_start) {
      int temp = state->select_end;
      state->select_end = state->select_start;
      state->select_start = temp;
   }
}

// move cursor to first character of selection
static void stb_textedit_move_to_first(STB_TexteditState *state)
{
   if (STB_TEXT_HAS_SELECTION(state)) {
      stb_textedit_sortselection(state);
      state->cursor = state->select_start;
      state->select_end = state->select_start;
      state->has_preferred_x = 0;
   }
}

// move cursor to last character of selection
static void stb_textedit_move_to_last(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
{
   if (STB_TEXT_HAS_SELECTION(state)) {
      stb_textedit_sortselection(state);
      stb_textedit_clamp(str, state);
      state->cursor = state->select_end;
      state->select_start = state->select_end;
      state->has_preferred_x = 0;
   }
}

#ifdef STB_TEXTEDIT_IS_SPACE
static int is_word_boundary( STB_TEXTEDIT_STRING *str, int idx )
{
   return idx > 0 ? (STB_TEXTEDIT_IS_SPACE( STB_TEXTEDIT_GETCHAR(str,idx-1) ) && !STB_TEXTEDIT_IS_SPACE( STB_TEXTEDIT_GETCHAR(str, idx) ) ) : 1;
}

#ifndef STB_TEXTEDIT_MOVEWORDLEFT
static int stb_textedit_move_to_word_previous( STB_TEXTEDIT_STRING *str, int c )
{
   --c; // always move at least one character
   while( c >= 0 && !is_word_boundary( str, c ) )
      --c;

   if( c < 0 )
      c = 0;

   return c;
}
#define STB_TEXTEDIT_MOVEWORDLEFT stb_textedit_move_to_word_previous
#endif

#ifndef STB_TEXTEDIT_MOVEWORDRIGHT
static int stb_textedit_move_to_word_next( STB_TEXTEDIT_STRING *str, int c )
{
   const int len = STB_TEXTEDIT_STRINGLEN(str);
   ++c; // always move at least one character
   while( c < len && !is_word_boundary( str, c ) )
      ++c;

   if( c > len )
      c = len;

   return c;
}
#define STB_TEXTEDIT_MOVEWORDRIGHT stb_textedit_move_to_word_next
#endif

#endif

// update selection and cursor to match each other
static void stb_textedit_prep_selection_at_cursor(STB_TexteditState *state)
{
   if (!STB_TEXT_HAS_SELECTION(state))
      state->select_start = state->select_end = state->cursor;
   else
      state->cursor = state->select_end;
}

// API cut: delete selection
static int stb_textedit_cut(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
{
   if (STB_TEXT_HAS_SELECTION(state)) {
      stb_textedit_delete_selection(str,state); // implicitly clamps
      state->has_preferred_x = 0;
      return 1;
   }
   return 0;
}

// API paste: replace existing selection with passed-in text
static int stb_textedit_paste_internal(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_CHARTYPE *text, int len)
{
   // if there's a selection, the paste should delete it
   stb_textedit_clamp(str, state);
   stb_textedit_delete_selection(str,state);
   // try to insert the characters
   if (STB_TEXTEDIT_INSERTCHARS(str, state->cursor, text, len)) {
      stb_text_makeundo_insert(state, state->cursor, len);
      state->cursor += len;
      state->has_preferred_x = 0;
      return 1;
   }
   // note: paste failure will leave deleted selection, may be restored with an undo (see https://github.com/nothings/stb/issues/734 for details)
   return 0;
}

#ifndef STB_TEXTEDIT_KEYTYPE
#define STB_TEXTEDIT_KEYTYPE int
#endif

// API key: process a keyboard input
static void stb_textedit_key(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_KEYTYPE key)
{
retry:
   switch (key) {
      default: {
         int c = STB_TEXTEDIT_KEYTOTEXT(key);
         if (c > 0) {
            STB_TEXTEDIT_CHARTYPE ch = (STB_TEXTEDIT_CHARTYPE) c;

            // can't add newline in single-line mode
            if (c == '\n' && state->single_line)
               break;

            if (state->insert_mode && !STB_TEXT_HAS_SELECTION(state) && state->cursor < STB_TEXTEDIT_STRINGLEN(str)) {
               stb_text_makeundo_replace(str, state, state->cursor, 1, 1);
               STB_TEXTEDIT_DELETECHARS(str, state->cursor, 1);
               if (STB_TEXTEDIT_INSERTCHARS(str, state->cursor, &ch, 1)) {
                  ++state->cursor;
                  state->has_preferred_x = 0;
               }
            } else {
               stb_textedit_delete_selection(str,state); // implicitly clamps
               if (STB_TEXTEDIT_INSERTCHARS(str, state->cursor, &ch, 1)) {
                  stb_text_makeundo_insert(state, state->cursor, 1);
                  ++state->cursor;
                  state->has_preferred_x = 0;
               }
            }
         }
         break;
      }

#ifdef STB_TEXTEDIT_K_INSERT
      case STB_TEXTEDIT_K_INSERT:
         state->insert_mode = !state->insert_mode;
         break;
#endif

      case STB_TEXTEDIT_K_UNDO:
         stb_text_undo(str, state);
         state->has_preferred_x = 0;
         break;

      case STB_TEXTEDIT_K_REDO:
         stb_text_redo(str, state);
         state->has_preferred_x = 0;
         break;

      case STB_TEXTEDIT_K_LEFT:
         // if currently there's a selection, move cursor to start of selection
         if (STB_TEXT_HAS_SELECTION(state))
            stb_textedit_move_to_first(state);
         else
            if (state->cursor > 0)
               --state->cursor;
         state->has_preferred_x = 0;
         break;

      case STB_TEXTEDIT_K_RIGHT:
         // if currently there's a selection, move cursor to end of selection
         if (STB_TEXT_HAS_SELECTION(state))
            stb_textedit_move_to_last(str, state);
         else
            ++state->cursor;
         stb_textedit_clamp(str, state);
         state->has_preferred_x = 0;
         break;

      case STB_TEXTEDIT_K_LEFT | STB_TEXTEDIT_K_SHIFT:
         stb_textedit_clamp(str, state);
         stb_textedit_prep_selection_at_cursor(state);
         // move selection left
         if (state->select_end > 0)
            --state->select_end;
         state->cursor = state->select_end;
         state->has_preferred_x = 0;
         break;

#ifdef STB_TEXTEDIT_MOVEWORDLEFT
      case STB_TEXTEDIT_K_WORDLEFT:
         if (STB_TEXT_HAS_SELECTION(state))
            stb_textedit_move_to_first(state);
         else {
            state->cursor = STB_TEXTEDIT_MOVEWORDLEFT(str, state->cursor);
            stb_textedit_clamp( str, state );
         }
         break;

      case STB_TEXTEDIT_K_WORDLEFT | STB_TEXTEDIT_K_SHIFT:
         if( !STB_TEXT_HAS_SELECTION( state ) )
            stb_textedit_prep_selection_at_cursor(state);

         state->cursor = STB_TEXTEDIT_MOVEWORDLEFT(str, state->cursor);
         state->select_end = state->cursor;

         stb_textedit_clamp( str, state );
         break;
#endif

#ifdef STB_TEXTEDIT_MOVEWORDRIGHT
      case STB_TEXTEDIT_K_WORDRIGHT:
         if (STB_TEXT_HAS_SELECTION(state))
            stb_textedit_move_to_last(str, state);
         else {
            state->cursor = STB_TEXTEDIT_MOVEWORDRIGHT(str, state->cursor);
            stb_textedit_clamp( str, state );
         }
         break;

      case STB_TEXTEDIT_K_WORDRIGHT | STB_TEXTEDIT_K_SHIFT:
         if( !STB_TEXT_HAS_SELECTION( state ) )
            stb_textedit_prep_selection_at_cursor(state);

         state->cursor = STB_TEXTEDIT_MOVEWORDRIGHT(str, state->cursor);
         state->select_end = state->cursor;

         stb_textedit_clamp( str, state );
         break;
#endif

      case STB_TEXTEDIT_K_RIGHT | STB_TEXTEDIT_K_SHIFT:
         stb_textedit_prep_selection_at_cursor(state);
         // move selection right
         ++state->select_end;
         stb_textedit_clamp(str, state);
         state->cursor = state->select_end;
         state->has_preferred_x = 0;
         break;

      case STB_TEXTEDIT_K_DOWN:
      case STB_TEXTEDIT_K_DOWN | STB_TEXTEDIT_K_SHIFT:
      case STB_TEXTEDIT_K_PGDOWN:
      case STB_TEXTEDIT_K_PGDOWN | STB_TEXTEDIT_K_SHIFT: {
         StbFindState find;
         StbTexteditRow row;
         int i, j, sel = (key & STB_TEXTEDIT_K_SHIFT) != 0;
         int is_page = (key & ~STB_TEXTEDIT_K_SHIFT) == STB_TEXTEDIT_K_PGDOWN;
         int row_count = is_page ? state->row_count_per_page : 1;

         if (!is_page && state->single_line) {
            // on windows, up&down in single-line behave like left&right
            key = STB_TEXTEDIT_K_RIGHT | (key & STB_TEXTEDIT_K_SHIFT);
            goto retry;
         }

         if (sel)
            stb_textedit_prep_selection_at_cursor(state);
         else if (STB_TEXT_HAS_SELECTION(state))
            stb_textedit_move_to_last(str, state);

         // compute current position of cursor point
         stb_textedit_clamp(str, state);
         stb_textedit_find_charpos(&find, str, state->cursor, state->single_line);

         for (j = 0; j < row_count; ++j) {
            float x, goal_x = state->has_preferred_x ? state->preferred_x : find.x;
            int start = find.first_char + find.length;

            if (find.length == 0)
               break;

            // [DEAR IMGUI]
            // going down while being on the last line shouldn't bring us to that line end
            if (STB_TEXTEDIT_GETCHAR(str, find.first_char + find.length - 1) != STB_TEXTEDIT_NEWLINE)
               break;

            // now find character position down a row
            state->cursor = start;
            STB_TEXTEDIT_LAYOUTROW(&row, str, state->cursor);
            x = row.x0;
            for (i=0; i < row.num_chars; ++i) {
               float dx = STB_TEXTEDIT_GETWIDTH(str, start, i);
               #ifdef STB_TEXTEDIT_GETWIDTH_NEWLINE
               if (dx == STB_TEXTEDIT_GETWIDTH_NEWLINE)
                  break;
               #endif
               x += dx;
               if (x > goal_x)
                  break;
               ++state->cursor;
            }
            stb_textedit_clamp(str, state);

            state->has_preferred_x = 1;
            state->preferred_x = goal_x;

            if (sel)
               state->select_end = state->cursor;

            // go to next line
            find.first_char = find.first_char + find.length;
            find.length = row.num_chars;
         }
         break;
      }

      case STB_TEXTEDIT_K_UP:
      case STB_TEXTEDIT_K_UP | STB_TEXTEDIT_K_SHIFT:
      case STB_TEXTEDIT_K_PGUP:
      case STB_TEXTEDIT_K_PGUP | STB_TEXTEDIT_K_SHIFT: {
         StbFindState find;
         StbTexteditRow row;
         int i, j, prev_scan, sel = (key & STB_TEXTEDIT_K_SHIFT) != 0;
         int is_page = (key & ~STB_TEXTEDIT_K_SHIFT) == STB_TEXTEDIT_K_PGUP;
         int row_count = is_page ? state->row_count_per_page : 1;

         if (!is_page && state->single_line) {
            // on windows, up&down become left&right
            key = STB_TEXTEDIT_K_LEFT | (key & STB_TEXTEDIT_K_SHIFT);
            goto retry;
         }

         if (sel)
            stb_textedit_prep_selection_at_cursor(state);
         else if (STB_TEXT_HAS_SELECTION(state))
            stb_textedit_move_to_first(state);

         // compute current position of cursor point
         stb_textedit_clamp(str, state);
         stb_textedit_find_charpos(&find, str, state->cursor, state->single_line);

         for (j = 0; j < row_count; ++j) {
            float  x, goal_x = state->has_preferred_x ? state->preferred_x : find.x;

            // can only go up if there's a previous row
            if (find.prev_first == find.first_char)
               break;

            // now find character position up a row
            state->cursor = find.prev_first;
            STB_TEXTEDIT_LAYOUTROW(&row, str, state->cursor);
            x = row.x0;
            for (i=0; i < row.num_chars; ++i) {
               float dx = STB_TEXTEDIT_GETWIDTH(str, find.prev_first, i);
               #ifdef STB_TEXTEDIT_GETWIDTH_NEWLINE
               if (dx == STB_TEXTEDIT_GETWIDTH_NEWLINE)
                  break;
               #endif
               x += dx;
               if (x > goal_x)
                  break;
               ++state->cursor;
            }
            stb_textedit_clamp(str, state);

            state->has_preferred_x = 1;
            state->preferred_x = goal_x;

            if (sel)
               state->select_end = state->cursor;

            // go to previous line
            // (we need to scan previous line the hard way. maybe we could expose this as a new API function?)
            prev_scan = find.prev_first > 0 ? find.prev_first - 1 : 0;
            while (prev_scan > 0 && STB_TEXTEDIT_GETCHAR(str, prev_scan - 1) != STB_TEXTEDIT_NEWLINE)
               --prev_scan;
            find.first_char = find.prev_first;
            find.prev_first = prev_scan;
         }
         break;
      }

      case STB_TEXTEDIT_K_DELETE:
      case STB_TEXTEDIT_K_DELETE | STB_TEXTEDIT_K_SHIFT:
         if (STB_TEXT_HAS_SELECTION(state))
            stb_textedit_delete_selection(str, state);
         else {
            int n = STB_TEXTEDIT_STRINGLEN(str);
            if (state->cursor < n)
               stb_textedit_delete(str, state, state->cursor, 1);
         }
         state->has_preferred_x = 0;
         break;

      case STB_TEXTEDIT_K_BACKSPACE:
      case STB_TEXTEDIT_K_BACKSPACE | STB_TEXTEDIT_K_SHIFT:
         if (STB_TEXT_HAS_SELECTION(state))
            stb_textedit_delete_selection(str, state);
         else {
            stb_textedit_clamp(str, state);
            if (state->cursor > 0) {
               stb_textedit_delete(str, state, state->cursor-1, 1);
               --state->cursor;
            }
         }
         state->has_preferred_x = 0;
         break;

#ifdef STB_TEXTEDIT_K_TEXTSTART2
      case STB_TEXTEDIT_K_TEXTSTART2:
#endif
      case STB_TEXTEDIT_K_TEXTSTART:
         state->cursor = state->select_start = state->select_end = 0;
         state->has_preferred_x = 0;
         break;

#ifdef STB_TEXTEDIT_K_TEXTEND2
      case STB_TEXTEDIT_K_TEXTEND2:
#endif
      case STB_TEXTEDIT_K_TEXTEND:
         state->cursor = STB_TEXTEDIT_STRINGLEN(str);
         state->select_start = state->select_end = 0;
         state->has_preferred_x = 0;
         break;

#ifdef STB_TEXTEDIT_K_TEXTSTART2
      case STB_TEXTEDIT_K_TEXTSTART2 | STB_TEXTEDIT_K_SHIFT:
#endif
      case STB_TEXTEDIT_K_TEXTSTART | STB_TEXTEDIT_K_SHIFT:
         stb_textedit_prep_selection_at_cursor(state);
         state->cursor = state->select_end = 0;
         state->has_preferred_x = 0;
         break;

#ifdef STB_TEXTEDIT_K_TEXTEND2
      case STB_TEXTEDIT_K_TEXTEND2 | STB_TEXTEDIT_K_SHIFT:
#endif
      case STB_TEXTEDIT_K_TEXTEND | STB_TEXTEDIT_K_SHIFT:
         stb_textedit_prep_selection_at_cursor(state);
         state->cursor = state->select_end = STB_TEXTEDIT_STRINGLEN(str);
         state->has_preferred_x = 0;
         break;


#ifdef STB_TEXTEDIT_K_LINESTART2
      case STB_TEXTEDIT_K_LINESTART2:
#endif
      case STB_TEXTEDIT_K_LINESTART:
         stb_textedit_clamp(str, state);
         stb_textedit_move_to_first(state);
         if (state->single_line)
            state->cursor = 0;
         else while (state->cursor > 0 && STB_TEXTEDIT_GETCHAR(str, state->cursor-1) != STB_TEXTEDIT_NEWLINE)
            --state->cursor;
         state->has_preferred_x = 0;
         break;

#ifdef STB_TEXTEDIT_K_LINEEND2
      case STB_TEXTEDIT_K_LINEEND2:
#endif
      case STB_TEXTEDIT_K_LINEEND: {
         int n = STB_TEXTEDIT_STRINGLEN(str);
         stb_textedit_clamp(str, state);
         stb_textedit_move_to_first(state);
         if (state->single_line)
             state->cursor = n;
         else while (state->cursor < n && STB_TEXTEDIT_GETCHAR(str, state->cursor) != STB_TEXTEDIT_NEWLINE)
             ++state->cursor;
         state->has_preferred_x = 0;
         break;
      }

#ifdef STB_TEXTEDIT_K_LINESTART2
      case STB_TEXTEDIT_K_LINESTART2 | STB_TEXTEDIT_K_SHIFT:
#endif
      case STB_TEXTEDIT_K_LINESTART | STB_TEXTEDIT_K_SHIFT:
         stb_textedit_clamp(str, state);
         stb_textedit_prep_selection_at_cursor(state);
         if (state->single_line)
            state->cursor = 0;
         else while (state->cursor > 0 && STB_TEXTEDIT_GETCHAR(str, state->cursor-1) != STB_TEXTEDIT_NEWLINE)
            --state->cursor;
         state->select_end = state->cursor;
         state->has_preferred_x = 0;
         break;

#ifdef STB_TEXTEDIT_K_LINEEND2
      case STB_TEXTEDIT_K_LINEEND2 | STB_TEXTEDIT_K_SHIFT:
#endif
      case STB_TEXTEDIT_K_LINEEND | STB_TEXTEDIT_K_SHIFT: {
         int n = STB_TEXTEDIT_STRINGLEN(str);
         stb_textedit_clamp(str, state);
         stb_textedit_prep_selection_at_cursor(state);
         if (state->single_line)
             state->cursor = n;
         else while (state->cursor < n && STB_TEXTEDIT_GETCHAR(str, state->cursor) != STB_TEXTEDIT_NEWLINE)
            ++state->cursor;
         state->select_end = state->cursor;
         state->has_preferred_x = 0;
         break;
      }
   }
}

/////////////////////////////////////////////////////////////////////////////
//
//      Undo processing
//
// @OPTIMIZE: the undo/redo buffer should be circular

static void stb_textedit_flush_redo(StbUndoState *state)
{
   state->redo_point = STB_TEXTEDIT_UNDOSTATECOUNT;
   state->redo_char_point = STB_TEXTEDIT_UNDOCHARCOUNT;
}

// discard the oldest entry in the undo list
static void stb_textedit_discard_undo(StbUndoState *state)
{
   if (state->undo_point > 0) {
      // if the 0th undo state has characters, clean those up
      if (state->undo_rec[0].char_storage >= 0) {
         int n = state->undo_rec[0].insert_length, i;
         // delete n characters from all other records
         state->undo_char_point -= n;
         STB_TEXTEDIT_memmove(state->undo_char, state->undo_char + n, (size_t) (state->undo_char_point*sizeof(STB_TEXTEDIT_CHARTYPE)));
         for (i=0; i < state->undo_point; ++i)
            if (state->undo_rec[i].char_storage >= 0)
               state->undo_rec[i].char_storage -= n; // @OPTIMIZE: get rid of char_storage and infer it
      }
      --state->undo_point;
      STB_TEXTEDIT_memmove(state->undo_rec, state->undo_rec+1, (size_t) (state->undo_point*sizeof(state->undo_rec[0])));
   }
}

// discard the oldest entry in the redo list--it's bad if this
// ever happens, but because undo & redo have to store the actual
// characters in different cases, the redo character buffer can
// fill up even though the undo buffer didn't
static void stb_textedit_discard_redo(StbUndoState *state)
{
   int k = STB_TEXTEDIT_UNDOSTATECOUNT-1;

   if (state->redo_point <= k) {
      // if the k'th undo state has characters, clean those up
      if (state->undo_rec[k].char_storage >= 0) {
         int n = state->undo_rec[k].insert_length, i;
         // move the remaining redo character data to the end of the buffer
         state->redo_char_point += n;
         STB_TEXTEDIT_memmove(state->undo_char + state->redo_char_point, state->undo_char + state->redo_char_point-n, (size_t) ((STB_TEXTEDIT_UNDOCHARCOUNT - state->redo_char_point)*sizeof(STB_TEXTEDIT_CHARTYPE)));
         // adjust the position of all the other records to account for above memmove
         for (i=state->redo_point; i < k; ++i)
            if (state->undo_rec[i].char_storage >= 0)
               state->undo_rec[i].char_storage += n;
      }
      // now move all the redo records towards the end of the buffer; the first one is at 'redo_point'
      // [DEAR IMGUI]
      size_t move_size = (size_t)((STB_TEXTEDIT_UNDOSTATECOUNT - state->redo_point - 1) * sizeof(state->undo_rec[0]));
      const char* buf_begin = (char*)state->undo_rec; (void)buf_begin;
      const char* buf_end   = (char*)state->undo_rec + sizeof(state->undo_rec); (void)buf_end;
      IM_ASSERT(((char*)(state->undo_rec + state->redo_point)) >= buf_begin);
      IM_ASSERT(((char*)(state->undo_rec + state->redo_point + 1) + move_size) <= buf_end);
      STB_TEXTEDIT_memmove(state->undo_rec + state->redo_point+1, state->undo_rec + state->redo_point, move_size);

      // now move redo_point to point to the new one
      ++state->redo_point;
   }
}

static StbUndoRecord *stb_text_create_undo_record(StbUndoState *state, int numchars)
{
   // any time we create a new undo record, we discard redo
   stb_textedit_flush_redo(state);

   // if we have no free records, we have to make room, by sliding the
   // existing records down
   if (state->undo_point == STB_TEXTEDIT_UNDOSTATECOUNT)
      stb_textedit_discard_undo(state);

   // if the characters to store won't possibly fit in the buffer, we can't undo
   if (numchars > STB_TEXTEDIT_UNDOCHARCOUNT) {
      state->undo_point = 0;
      state->undo_char_point = 0;
      return NULL;
   }

   // if we don't have enough free characters in the buffer, we have to make room
   while (state->undo_char_point + numchars > STB_TEXTEDIT_UNDOCHARCOUNT)
      stb_textedit_discard_undo(state);

   return &state->undo_rec[state->undo_point++];
}

static STB_TEXTEDIT_CHARTYPE *stb_text_createundo(StbUndoState *state, int pos, int insert_len, int delete_len)
{
   StbUndoRecord *r = stb_text_create_undo_record(state, insert_len);
   if (r == NULL)
      return NULL;

   r->where = pos;
   r->insert_length = (STB_TEXTEDIT_POSITIONTYPE) insert_len;
   r->delete_length = (STB_TEXTEDIT_POSITIONTYPE) delete_len;

   if (insert_len == 0) {
      r->char_storage = -1;
      return NULL;
   } else {
      r->char_storage = state->undo_char_point;
      state->undo_char_point += insert_len;
      return &state->undo_char[r->char_storage];
   }
}

static void stb_text_undo(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
{
   StbUndoState *s = &state->undostate;
   StbUndoRecord u, *r;
   if (s->undo_point == 0)
      return;

   // we need to do two things: apply the undo record, and create a redo record
   u = s->undo_rec[s->undo_point-1];
   r = &s->undo_rec[s->redo_point-1];
   r->char_storage = -1;

   r->insert_length = u.delete_length;
   r->delete_length = u.insert_length;
   r->where = u.where;

   if (u.delete_length) {
      // if the undo record says to delete characters, then the redo record will
      // need to re-insert the characters that get deleted, so we need to store
      // them.

      // there are three cases:
      //    there's enough room to store the characters
      //    characters stored for *redoing* don't leave room for redo
      //    characters stored for *undoing* don't leave room for redo
      // if the last is true, we have to bail

      if (s->undo_char_point + u.delete_length >= STB_TEXTEDIT_UNDOCHARCOUNT) {
         // the undo records take up too much character space; there's no space to store the redo characters
         r->insert_length = 0;
      } else {
         int i;

         // there's definitely room to store the characters eventually
         while (s->undo_char_point + u.delete_length > s->redo_char_point) {
            // should never happen:
            if (s->redo_point == STB_TEXTEDIT_UNDOSTATECOUNT)
               return;
            // there's currently not enough room, so discard a redo record
            stb_textedit_discard_redo(s);
         }
         r = &s->undo_rec[s->redo_point-1];

         r->char_storage = s->redo_char_point - u.delete_length;
         s->redo_char_point = s->redo_char_point - u.delete_length;

         // now save the characters
         for (i=0; i < u.delete_length; ++i)
            s->undo_char[r->char_storage + i] = STB_TEXTEDIT_GETCHAR(str, u.where + i);
      }

      // now we can carry out the deletion
      STB_TEXTEDIT_DELETECHARS(str, u.where, u.delete_length);
   }

   // check type of recorded action:
   if (u.insert_length) {
      // easy case: was a deletion, so we need to insert n characters
      STB_TEXTEDIT_INSERTCHARS(str, u.where, &s->undo_char[u.char_storage], u.insert_length);
      s->undo_char_point -= u.insert_length;
   }

   state->cursor = u.where + u.insert_length;

   s->undo_point--;
   s->redo_point--;
}

static void stb_text_redo(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
{
   StbUndoState *s = &state->undostate;
   StbUndoRecord *u, r;
   if (s->redo_point == STB_TEXTEDIT_UNDOSTATECOUNT)
      return;

   // we need to do two things: apply the redo record, and create an undo record
   u = &s->undo_rec[s->undo_point];
   r = s->undo_rec[s->redo_point];

   // we KNOW there must be room for the undo record, because the redo record
   // was derived from an undo record

   u->delete_length = r.insert_length;
   u->insert_length = r.delete_length;
   u->where = r.where;
   u->char_storage = -1;

   if (r.delete_length) {
      // the redo record requires us to delete characters, so the undo record
      // needs to store the characters

      if (s->undo_char_point + u->insert_length > s->redo_char_point) {
         u->insert_length = 0;
         u->delete_length = 0;
      } else {
         int i;
         u->char_storage = s->undo_char_point;
         s->undo_char_point = s->undo_char_point + u->insert_length;

         // now save the characters
         for (i=0; i < u->insert_length; ++i)
            s->undo_char[u->char_storage + i] = STB_TEXTEDIT_GETCHAR(str, u->where + i);
      }

      STB_TEXTEDIT_DELETECHARS(str, r.where, r.delete_length);
   }

   if (r.insert_length) {
      // easy case: need to insert n characters
      STB_TEXTEDIT_INSERTCHARS(str, r.where, &s->undo_char[r.char_storage], r.insert_length);
      s->redo_char_point += r.insert_length;
   }

   state->cursor = r.where + r.insert_length;

   s->undo_point++;
   s->redo_point++;
}

static void stb_text_makeundo_insert(STB_TexteditState *state, int where, int length)
{
   stb_text_createundo(&state->undostate, where, 0, length);
}

static void stb_text_makeundo_delete(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int length)
{
   int i;
   STB_TEXTEDIT_CHARTYPE *p = stb_text_createundo(&state->undostate, where, length, 0);
   if (p) {
      for (i=0; i < length; ++i)
         p[i] = STB_TEXTEDIT_GETCHAR(str, where+i);
   }
}

static void stb_text_makeundo_replace(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int old_length, int new_length)
{
   int i;
   STB_TEXTEDIT_CHARTYPE *p = stb_text_createundo(&state->undostate, where, old_length, new_length);
   if (p) {
      for (i=0; i < old_length; ++i)
         p[i] = STB_TEXTEDIT_GETCHAR(str, where+i);
   }
}

// reset the state to default
static void stb_textedit_clear_state(STB_TexteditState *state, int is_single_line)
{
   state->undostate.undo_point = 0;
   state->undostate.undo_char_point = 0;
   state->undostate.redo_point = STB_TEXTEDIT_UNDOSTATECOUNT;
   state->undostate.redo_char_point = STB_TEXTEDIT_UNDOCHARCOUNT;
   state->select_end = state->select_start = 0;
   state->cursor = 0;
   state->has_preferred_x = 0;
   state->preferred_x = 0;
   state->cursor_at_end_of_line = 0;
   state->initialized = 1;
   state->single_line = (unsigned char) is_single_line;
   state->insert_mode = 0;
   state->row_count_per_page = 0;
}

// API initialize
static void stb_textedit_initialize_state(STB_TexteditState *state, int is_single_line)
{
   stb_textedit_clear_state(state, is_single_line);
}

#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wcast-qual"
#endif

static int stb_textedit_paste(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_CHARTYPE const *ctext, int len)
{
   return stb_textedit_paste_internal(str, state, (STB_TEXTEDIT_CHARTYPE *) ctext, len);
}

#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic pop
#endif

#endif//STB_TEXTEDIT_IMPLEMENTATION

/*
------------------------------------------------------------------------------
This software is available under 2 licenses -- choose whichever you prefer.
------------------------------------------------------------------------------
ALTERNATIVE A - MIT License
Copyright (c) 2017 Sean Barrett
Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
------------------------------------------------------------------------------
ALTERNATIVE B - Public Domain (www.unlicense.org)
This is free and unencumbered software released into the public domain.
Anyone is free to copy, modify, publish, use, compile, sell, or distribute this
software, either in source code form or as a compiled binary, for any purpose,
commercial or non-commercial, and by any means.
In jurisdictions that recognize copyright laws, the author or authors of this
software dedicate any and all copyright interest in the software to the public
domain. We make this dedication for the benefit of the public at large and to
the detriment of our heirs and successors. We intend this dedication to be an
overt act of relinquishment in perpetuity of all present and future rights to
this software under copyright law.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
------------------------------------------------------------------------------
*/

```

`sakura/libs/image/imstb_truetype.h`:

```h
// [DEAR IMGUI]
// This is a slightly modified version of stb_truetype.h 1.26.
// Mostly fixing for compiler and static analyzer warnings.
// Grep for [DEAR IMGUI] to find the changes.

// stb_truetype.h - v1.26 - public domain
// authored from 2009-2021 by Sean Barrett / RAD Game Tools
//
// =======================================================================
//
//    NO SECURITY GUARANTEE -- DO NOT USE THIS ON UNTRUSTED FONT FILES
//
// This library does no range checking of the offsets found in the file,
// meaning an attacker can use it to read arbitrary memory.
//
// =======================================================================
//
//   This library processes TrueType files:
//        parse files
//        extract glyph metrics
//        extract glyph shapes
//        render glyphs to one-channel bitmaps with antialiasing (box filter)
//        render glyphs to one-channel SDF bitmaps (signed-distance field/function)
//
//   Todo:
//        non-MS cmaps
//        crashproof on bad data
//        hinting? (no longer patented)
//        cleartype-style AA?
//        optimize: use simple memory allocator for intermediates
//        optimize: build edge-list directly from curves
//        optimize: rasterize directly from curves?
//
// ADDITIONAL CONTRIBUTORS
//
//   Mikko Mononen: compound shape support, more cmap formats
//   Tor Andersson: kerning, subpixel rendering
//   Dougall Johnson: OpenType / Type 2 font handling
//   Daniel Ribeiro Maciel: basic GPOS-based kerning
//
//   Misc other:
//       Ryan Gordon
//       Simon Glass
//       github:IntellectualKitty
//       Imanol Celaya
//       Daniel Ribeiro Maciel
//
//   Bug/warning reports/fixes:
//       "Zer" on mollyrocket       Fabian "ryg" Giesen   github:NiLuJe
//       Cass Everitt               Martins Mozeiko       github:aloucks
//       stoiko (Haemimont Games)   Cap Petschulat        github:oyvindjam
//       Brian Hook                 Omar Cornut           github:vassvik
//       Walter van Niftrik         Ryan Griege
//       David Gow                  Peter LaValle
//       David Given                Sergey Popov
//       Ivan-Assen Ivanov          Giumo X. Clanjor
//       Anthony Pesch              Higor Euripedes
//       Johan Duparc               Thomas Fields
//       Hou Qiming                 Derek Vinyard
//       Rob Loach                  Cort Stratton
//       Kenney Phillis Jr.         Brian Costabile
//       Ken Voskuil (kaesve)
//
// VERSION HISTORY
//
//   1.26 (2021-08-28) fix broken rasterizer
//   1.25 (2021-07-11) many fixes
//   1.24 (2020-02-05) fix warning
//   1.23 (2020-02-02) query SVG data for glyphs; query whole kerning table (but only kern not GPOS)
//   1.22 (2019-08-11) minimize missing-glyph duplication; fix kerning if both 'GPOS' and 'kern' are defined
//   1.21 (2019-02-25) fix warning
//   1.20 (2019-02-07) PackFontRange skips missing codepoints; GetScaleFontVMetrics()
//   1.19 (2018-02-11) GPOS kerning, STBTT_fmod
//   1.18 (2018-01-29) add missing function
//   1.17 (2017-07-23) make more arguments const; doc fix
//   1.16 (2017-07-12) SDF support
//   1.15 (2017-03-03) make more arguments const
//   1.14 (2017-01-16) num-fonts-in-TTC function
//   1.13 (2017-01-02) support OpenType fonts, certain Apple fonts
//   1.12 (2016-10-25) suppress warnings about casting away const with -Wcast-qual
//   1.11 (2016-04-02) fix unused-variable warning
//   1.10 (2016-04-02) user-defined fabs(); rare memory leak; remove duplicate typedef
//   1.09 (2016-01-16) warning fix; avoid crash on outofmem; use allocation userdata properly
//   1.08 (2015-09-13) document stbtt_Rasterize(); fixes for vertical & horizontal edges
//   1.07 (2015-08-01) allow PackFontRanges to accept arrays of sparse codepoints;
//                     variant PackFontRanges to pack and render in separate phases;
//                     fix stbtt_GetFontOFfsetForIndex (never worked for non-0 input?);
//                     fixed an assert() bug in the new rasterizer
//                     replace assert() with STBTT_assert() in new rasterizer
//
//   Full history can be found at the end of this file.
//
// LICENSE
//
//   See end of file for license information.
//
// USAGE
//
//   Include this file in whatever places need to refer to it. In ONE C/C++
//   file, write:
//      #define STB_TRUETYPE_IMPLEMENTATION
//   before the #include of this file. This expands out the actual
//   implementation into that C/C++ file.
//
//   To make the implementation private to the file that generates the implementation,
//      #define STBTT_STATIC
//
//   Simple 3D API (don't ship this, but it's fine for tools and quick start)
//           stbtt_BakeFontBitmap()               -- bake a font to a bitmap for use as texture
//           stbtt_GetBakedQuad()                 -- compute quad to draw for a given char
//
//   Improved 3D API (more shippable):
//           #include "stb_rect_pack.h"           -- optional, but you really want it
//           stbtt_PackBegin()
//           stbtt_PackSetOversampling()          -- for improved quality on small fonts
//           stbtt_PackFontRanges()               -- pack and renders
//           stbtt_PackEnd()
//           stbtt_GetPackedQuad()
//
//   "Load" a font file from a memory buffer (you have to keep the buffer loaded)
//           stbtt_InitFont()
//           stbtt_GetFontOffsetForIndex()        -- indexing for TTC font collections
//           stbtt_GetNumberOfFonts()             -- number of fonts for TTC font collections
//
//   Render a unicode codepoint to a bitmap
//           stbtt_GetCodepointBitmap()           -- allocates and returns a bitmap
//           stbtt_MakeCodepointBitmap()          -- renders into bitmap you provide
//           stbtt_GetCodepointBitmapBox()        -- how big the bitmap must be
//
//   Character advance/positioning
//           stbtt_GetCodepointHMetrics()
//           stbtt_GetFontVMetrics()
//           stbtt_GetFontVMetricsOS2()
//           stbtt_GetCodepointKernAdvance()
//
//   Starting with version 1.06, the rasterizer was replaced with a new,
//   faster and generally-more-precise rasterizer. The new rasterizer more
//   accurately measures pixel coverage for anti-aliasing, except in the case
//   where multiple shapes overlap, in which case it overestimates the AA pixel
//   coverage. Thus, anti-aliasing of intersecting shapes may look wrong. If
//   this turns out to be a problem, you can re-enable the old rasterizer with
//        #define STBTT_RASTERIZER_VERSION 1
//   which will incur about a 15% speed hit.
//
// ADDITIONAL DOCUMENTATION
//
//   Immediately after this block comment are a series of sample programs.
//
//   After the sample programs is the "header file" section. This section
//   includes documentation for each API function.
//
//   Some important concepts to understand to use this library:
//
//      Codepoint
//         Characters are defined by unicode codepoints, e.g. 65 is
//         uppercase A, 231 is lowercase c with a cedilla, 0x7e30 is
//         the hiragana for "ma".
//
//      Glyph
//         A visual character shape (every codepoint is rendered as
//         some glyph)
//
//      Glyph index
//         A font-specific integer ID representing a glyph
//
//      Baseline
//         Glyph shapes are defined relative to a baseline, which is the
//         bottom of uppercase characters. Characters extend both above
//         and below the baseline.
//
//      Current Point
//         As you draw text to the screen, you keep track of a "current point"
//         which is the origin of each character. The current point's vertical
//         position is the baseline. Even "baked fonts" use this model.
//
//      Vertical Font Metrics
//         The vertical qualities of the font, used to vertically position
//         and space the characters. See docs for stbtt_GetFontVMetrics.
//
//      Font Size in Pixels or Points
//         The preferred interface for specifying font sizes in stb_truetype
//         is to specify how tall the font's vertical extent should be in pixels.
//         If that sounds good enough, skip the next paragraph.
//
//         Most font APIs instead use "points", which are a common typographic
//         measurement for describing font size, defined as 72 points per inch.
//         stb_truetype provides a point API for compatibility. However, true
//         "per inch" conventions don't make much sense on computer displays
//         since different monitors have different number of pixels per
//         inch. For example, Windows traditionally uses a convention that
//         there are 96 pixels per inch, thus making 'inch' measurements have
//         nothing to do with inches, and thus effectively defining a point to
//         be 1.333 pixels. Additionally, the TrueType font data provides
//         an explicit scale factor to scale a given font's glyphs to points,
//         but the author has observed that this scale factor is often wrong
//         for non-commercial fonts, thus making fonts scaled in points
//         according to the TrueType spec incoherently sized in practice.
//
// DETAILED USAGE:
//
//  Scale:
//    Select how high you want the font to be, in points or pixels.
//    Call ScaleForPixelHeight or ScaleForMappingEmToPixels to compute
//    a scale factor SF that will be used by all other functions.
//
//  Baseline:
//    You need to select a y-coordinate that is the baseline of where
//    your text will appear. Call GetFontBoundingBox to get the baseline-relative
//    bounding box for all characters. SF*-y0 will be the distance in pixels
//    that the worst-case character could extend above the baseline, so if
//    you want the top edge of characters to appear at the top of the
//    screen where y=0, then you would set the baseline to SF*-y0.
//
//  Current point:
//    Set the current point where the first character will appear. The
//    first character could extend left of the current point; this is font
//    dependent. You can either choose a current point that is the leftmost
//    point and hope, or add some padding, or check the bounding box or
//    left-side-bearing of the first character to be displayed and set
//    the current point based on that.
//
//  Displaying a character:
//    Compute the bounding box of the character. It will contain signed values
//    relative to <current_point, baseline>. I.e. if it returns x0,y0,x1,y1,
//    then the character should be displayed in the rectangle from
//    <current_point+SF*x0, baseline+SF*y0> to <current_point+SF*x1,baseline+SF*y1).
//
//  Advancing for the next character:
//    Call GlyphHMetrics, and compute 'current_point += SF * advance'.
//
//
// ADVANCED USAGE
//
//   Quality:
//
//    - Use the functions with Subpixel at the end to allow your characters
//      to have subpixel positioning. Since the font is anti-aliased, not
//      hinted, this is very import for quality. (This is not possible with
//      baked fonts.)
//
//    - Kerning is now supported, and if you're supporting subpixel rendering
//      then kerning is worth using to give your text a polished look.
//
//   Performance:
//
//    - Convert Unicode codepoints to glyph indexes and operate on the glyphs;
//      if you don't do this, stb_truetype is forced to do the conversion on
//      every call.
//
//    - There are a lot of memory allocations. We should modify it to take
//      a temp buffer and allocate from the temp buffer (without freeing),
//      should help performance a lot.
//
// NOTES
//
//   The system uses the raw data found in the .ttf file without changing it
//   and without building auxiliary data structures. This is a bit inefficient
//   on little-endian systems (the data is big-endian), but assuming you're
//   caching the bitmaps or glyph shapes this shouldn't be a big deal.
//
//   It appears to be very hard to programmatically determine what font a
//   given file is in a general way. I provide an API for this, but I don't
//   recommend it.
//
//
// PERFORMANCE MEASUREMENTS FOR 1.06:
//
//                      32-bit     64-bit
//   Previous release:  8.83 s     7.68 s
//   Pool allocations:  7.72 s     6.34 s
//   Inline sort     :  6.54 s     5.65 s
//   New rasterizer  :  5.63 s     5.00 s

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
////
////  SAMPLE PROGRAMS
////
//
//  Incomplete text-in-3d-api example, which draws quads properly aligned to be lossless.
//  See "tests/truetype_demo_win32.c" for a complete version.
#if 0
#define STB_TRUETYPE_IMPLEMENTATION  // force following include to generate implementation
#include "stb_truetype.h"

unsigned char ttf_buffer[1<<20];
unsigned char temp_bitmap[512*512];

stbtt_bakedchar cdata[96]; // ASCII 32..126 is 95 glyphs
GLuint ftex;

void my_stbtt_initfont(void)
{
   fread(ttf_buffer, 1, 1<<20, fopen("c:/windows/fonts/times.ttf", "rb"));
   stbtt_BakeFontBitmap(ttf_buffer,0, 32.0, temp_bitmap,512,512, 32,96, cdata); // no guarantee this fits!
   // can free ttf_buffer at this point
   glGenTextures(1, &ftex);
   glBindTexture(GL_TEXTURE_2D, ftex);
   glTexImage2D(GL_TEXTURE_2D, 0, GL_ALPHA, 512,512, 0, GL_ALPHA, GL_UNSIGNED_BYTE, temp_bitmap);
   // can free temp_bitmap at this point
   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
}

void my_stbtt_print(float x, float y, char *text)
{
   // assume orthographic projection with units = screen pixels, origin at top left
   glEnable(GL_BLEND);
   glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
   glEnable(GL_TEXTURE_2D);
   glBindTexture(GL_TEXTURE_2D, ftex);
   glBegin(GL_QUADS);
   while (*text) {
      if (*text >= 32 && *text < 128) {
         stbtt_aligned_quad q;
         stbtt_GetBakedQuad(cdata, 512,512, *text-32, &x,&y,&q,1);//1=opengl & d3d10+,0=d3d9
         glTexCoord2f(q.s0,q.t0); glVertex2f(q.x0,q.y0);
         glTexCoord2f(q.s1,q.t0); glVertex2f(q.x1,q.y0);
         glTexCoord2f(q.s1,q.t1); glVertex2f(q.x1,q.y1);
         glTexCoord2f(q.s0,q.t1); glVertex2f(q.x0,q.y1);
      }
      ++text;
   }
   glEnd();
}
#endif
//
//
//////////////////////////////////////////////////////////////////////////////
//
// Complete program (this compiles): get a single bitmap, print as ASCII art
//
#if 0
#include <stdio.h>
#define STB_TRUETYPE_IMPLEMENTATION  // force following include to generate implementation
#include "stb_truetype.h"

char ttf_buffer[1<<25];

int main(int argc, char **argv)
{
   stbtt_fontinfo font;
   unsigned char *bitmap;
   int w,h,i,j,c = (argc > 1 ? atoi(argv[1]) : 'a'), s = (argc > 2 ? atoi(argv[2]) : 20);

   fread(ttf_buffer, 1, 1<<25, fopen(argc > 3 ? argv[3] : "c:/windows/fonts/arialbd.ttf", "rb"));

   stbtt_InitFont(&font, ttf_buffer, stbtt_GetFontOffsetForIndex(ttf_buffer,0));
   bitmap = stbtt_GetCodepointBitmap(&font, 0,stbtt_ScaleForPixelHeight(&font, s), c, &w, &h, 0,0);

   for (j=0; j < h; ++j) {
      for (i=0; i < w; ++i)
         putchar(" .:ioVM@"[bitmap[j*w+i]>>5]);
      putchar('\n');
   }
   return 0;
}
#endif
//
// Output:
//
//     .ii.
//    @@@@@@.
//   V@Mio@@o
//   :i.  V@V
//     :oM@@M
//   :@@@MM@M
//   @@o  o@M
//  :@@.  M@M
//   @@@o@@@@
//   :M@@V:@@.
//
//////////////////////////////////////////////////////////////////////////////
//
// Complete program: print "Hello World!" banner, with bugs
//
#if 0
char buffer[24<<20];
unsigned char screen[20][79];

int main(int arg, char **argv)
{
   stbtt_fontinfo font;
   int i,j,ascent,baseline,ch=0;
   float scale, xpos=2; // leave a little padding in case the character extends left
   char *text = "Heljo World!"; // intentionally misspelled to show 'lj' brokenness

   fread(buffer, 1, 1000000, fopen("c:/windows/fonts/arialbd.ttf", "rb"));
   stbtt_InitFont(&font, buffer, 0);

   scale = stbtt_ScaleForPixelHeight(&font, 15);
   stbtt_GetFontVMetrics(&font, &ascent,0,0);
   baseline = (int) (ascent*scale);

   while (text[ch]) {
      int advance,lsb,x0,y0,x1,y1;
      float x_shift = xpos - (float) floor(xpos);
      stbtt_GetCodepointHMetrics(&font, text[ch], &advance, &lsb);
      stbtt_GetCodepointBitmapBoxSubpixel(&font, text[ch], scale,scale,x_shift,0, &x0,&y0,&x1,&y1);
      stbtt_MakeCodepointBitmapSubpixel(&font, &screen[baseline + y0][(int) xpos + x0], x1-x0,y1-y0, 79, scale,scale,x_shift,0, text[ch]);
      // note that this stomps the old data, so where character boxes overlap (e.g. 'lj') it's wrong
      // because this API is really for baking character bitmaps into textures. if you want to render
      // a sequence of characters, you really need to render each bitmap to a temp buffer, then
      // "alpha blend" that into the working buffer
      xpos += (advance * scale);
      if (text[ch+1])
         xpos += scale*stbtt_GetCodepointKernAdvance(&font, text[ch],text[ch+1]);
      ++ch;
   }

   for (j=0; j < 20; ++j) {
      for (i=0; i < 78; ++i)
         putchar(" .:ioVM@"[screen[j][i]>>5]);
      putchar('\n');
   }

   return 0;
}
#endif


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
////
////   INTEGRATION WITH YOUR CODEBASE
////
////   The following sections allow you to supply alternate definitions
////   of C library functions used by stb_truetype, e.g. if you don't
////   link with the C runtime library.

#ifdef STB_TRUETYPE_IMPLEMENTATION
   // #define your own (u)stbtt_int8/16/32 before including to override this
   #ifndef stbtt_uint8
   typedef unsigned char   stbtt_uint8;
   typedef signed   char   stbtt_int8;
   typedef unsigned short  stbtt_uint16;
   typedef signed   short  stbtt_int16;
   typedef unsigned int    stbtt_uint32;
   typedef signed   int    stbtt_int32;
   #endif

   typedef char stbtt__check_size32[sizeof(stbtt_int32)==4 ? 1 : -1];
   typedef char stbtt__check_size16[sizeof(stbtt_int16)==2 ? 1 : -1];

   // e.g. #define your own STBTT_ifloor/STBTT_iceil() to avoid math.h
   #ifndef STBTT_ifloor
   #include <math.h>
   #define STBTT_ifloor(x)   ((int) floor(x))
   #define STBTT_iceil(x)    ((int) ceil(x))
   #endif

   #ifndef STBTT_sqrt
   #include <math.h>
   #define STBTT_sqrt(x)      sqrt(x)
   #define STBTT_pow(x,y)     pow(x,y)
   #endif

   #ifndef STBTT_fmod
   #include <math.h>
   #define STBTT_fmod(x,y)    fmod(x,y)
   #endif

   #ifndef STBTT_cos
   #include <math.h>
   #define STBTT_cos(x)       cos(x)
   #define STBTT_acos(x)      acos(x)
   #endif

   #ifndef STBTT_fabs
   #include <math.h>
   #define STBTT_fabs(x)      fabs(x)
   #endif

   // #define your own functions "STBTT_malloc" / "STBTT_free" to avoid malloc.h
   #ifndef STBTT_malloc
   #include <stdlib.h>
   #define STBTT_malloc(x,u)  ((void)(u),malloc(x))
   #define STBTT_free(x,u)    ((void)(u),free(x))
   #endif

   #ifndef STBTT_assert
   #include <assert.h>
   #define STBTT_assert(x)    assert(x)
   #endif

   #ifndef STBTT_strlen
   #include <string.h>
   #define STBTT_strlen(x)    strlen(x)
   #endif

   #ifndef STBTT_memcpy
   #include <string.h>
   #define STBTT_memcpy       memcpy
   #define STBTT_memset       memset
   #endif
#endif

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
////
////   INTERFACE
////
////

#ifndef __STB_INCLUDE_STB_TRUETYPE_H__
#define __STB_INCLUDE_STB_TRUETYPE_H__

#ifdef STBTT_STATIC
#define STBTT_DEF static
#else
#define STBTT_DEF extern
#endif

#ifdef __cplusplus
extern "C" {
#endif

// private structure
typedef struct
{
   unsigned char *data;
   int cursor;
   int size;
} stbtt__buf;

//////////////////////////////////////////////////////////////////////////////
//
// TEXTURE BAKING API
//
// If you use this API, you only have to call two functions ever.
//

typedef struct
{
   unsigned short x0,y0,x1,y1; // coordinates of bbox in bitmap
   float xoff,yoff,xadvance;
} stbtt_bakedchar;

STBTT_DEF int stbtt_BakeFontBitmap(const unsigned char *data, int offset,  // font location (use offset=0 for plain .ttf)
                                float pixel_height,                     // height of font in pixels
                                unsigned char *pixels, int pw, int ph,  // bitmap to be filled in
                                int first_char, int num_chars,          // characters to bake
                                stbtt_bakedchar *chardata);             // you allocate this, it's num_chars long
// if return is positive, the first unused row of the bitmap
// if return is negative, returns the negative of the number of characters that fit
// if return is 0, no characters fit and no rows were used
// This uses a very crappy packing.

typedef struct
{
   float x0,y0,s0,t0; // top-left
   float x1,y1,s1,t1; // bottom-right
} stbtt_aligned_quad;

STBTT_DEF void stbtt_GetBakedQuad(const stbtt_bakedchar *chardata, int pw, int ph,  // same data as above
                               int char_index,             // character to display
                               float *xpos, float *ypos,   // pointers to current position in screen pixel space
                               stbtt_aligned_quad *q,      // output: quad to draw
                               int opengl_fillrule);       // true if opengl fill rule; false if DX9 or earlier
// Call GetBakedQuad with char_index = 'character - first_char', and it
// creates the quad you need to draw and advances the current position.
//
// The coordinate system used assumes y increases downwards.
//
// Characters will extend both above and below the current position;
// see discussion of "BASELINE" above.
//
// It's inefficient; you might want to c&p it and optimize it.

STBTT_DEF void stbtt_GetScaledFontVMetrics(const unsigned char *fontdata, int index, float size, float *ascent, float *descent, float *lineGap);
// Query the font vertical metrics without having to create a font first.


//////////////////////////////////////////////////////////////////////////////
//
// NEW TEXTURE BAKING API
//
// This provides options for packing multiple fonts into one atlas, not
// perfectly but better than nothing.

typedef struct
{
   unsigned short x0,y0,x1,y1; // coordinates of bbox in bitmap
   float xoff,yoff,xadvance;
   float xoff2,yoff2;
} stbtt_packedchar;

typedef struct stbtt_pack_context stbtt_pack_context;
typedef struct stbtt_fontinfo stbtt_fontinfo;
#ifndef STB_RECT_PACK_VERSION
typedef struct stbrp_rect stbrp_rect;
#endif

STBTT_DEF int  stbtt_PackBegin(stbtt_pack_context *spc, unsigned char *pixels, int width, int height, int stride_in_bytes, int padding, void *alloc_context);
// Initializes a packing context stored in the passed-in stbtt_pack_context.
// Future calls using this context will pack characters into the bitmap passed
// in here: a 1-channel bitmap that is width * height. stride_in_bytes is
// the distance from one row to the next (or 0 to mean they are packed tightly
// together). "padding" is the amount of padding to leave between each
// character (normally you want '1' for bitmaps you'll use as textures with
// bilinear filtering).
//
// Returns 0 on failure, 1 on success.

STBTT_DEF void stbtt_PackEnd  (stbtt_pack_context *spc);
// Cleans up the packing context and frees all memory.

#define STBTT_POINT_SIZE(x)   (-(x))

STBTT_DEF int  stbtt_PackFontRange(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, float font_size,
                                int first_unicode_char_in_range, int num_chars_in_range, stbtt_packedchar *chardata_for_range);
// Creates character bitmaps from the font_index'th font found in fontdata (use
// font_index=0 if you don't know what that is). It creates num_chars_in_range
// bitmaps for characters with unicode values starting at first_unicode_char_in_range
// and increasing. Data for how to render them is stored in chardata_for_range;
// pass these to stbtt_GetPackedQuad to get back renderable quads.
//
// font_size is the full height of the character from ascender to descender,
// as computed by stbtt_ScaleForPixelHeight. To use a point size as computed
// by stbtt_ScaleForMappingEmToPixels, wrap the point size in STBTT_POINT_SIZE()
// and pass that result as 'font_size':
//       ...,                  20 , ... // font max minus min y is 20 pixels tall
//       ..., STBTT_POINT_SIZE(20), ... // 'M' is 20 pixels tall

typedef struct
{
   float font_size;
   int first_unicode_codepoint_in_range;  // if non-zero, then the chars are continuous, and this is the first codepoint
   int *array_of_unicode_codepoints;       // if non-zero, then this is an array of unicode codepoints
   int num_chars;
   stbtt_packedchar *chardata_for_range; // output
   unsigned char h_oversample, v_oversample; // don't set these, they're used internally
} stbtt_pack_range;

STBTT_DEF int  stbtt_PackFontRanges(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, stbtt_pack_range *ranges, int num_ranges);
// Creates character bitmaps from multiple ranges of characters stored in
// ranges. This will usually create a better-packed bitmap than multiple
// calls to stbtt_PackFontRange. Note that you can call this multiple
// times within a single PackBegin/PackEnd.

STBTT_DEF void stbtt_PackSetOversampling(stbtt_pack_context *spc, unsigned int h_oversample, unsigned int v_oversample);
// Oversampling a font increases the quality by allowing higher-quality subpixel
// positioning, and is especially valuable at smaller text sizes.
//
// This function sets the amount of oversampling for all following calls to
// stbtt_PackFontRange(s) or stbtt_PackFontRangesGatherRects for a given
// pack context. The default (no oversampling) is achieved by h_oversample=1
// and v_oversample=1. The total number of pixels required is
// h_oversample*v_oversample larger than the default; for example, 2x2
// oversampling requires 4x the storage of 1x1. For best results, render
// oversampled textures with bilinear filtering. Look at the readme in
// stb/tests/oversample for information about oversampled fonts
//
// To use with PackFontRangesGather etc., you must set it before calls
// call to PackFontRangesGatherRects.

STBTT_DEF void stbtt_PackSetSkipMissingCodepoints(stbtt_pack_context *spc, int skip);
// If skip != 0, this tells stb_truetype to skip any codepoints for which
// there is no corresponding glyph. If skip=0, which is the default, then
// codepoints without a glyph recived the font's "missing character" glyph,
// typically an empty box by convention.

STBTT_DEF void stbtt_GetPackedQuad(const stbtt_packedchar *chardata, int pw, int ph,  // same data as above
                               int char_index,             // character to display
                               float *xpos, float *ypos,   // pointers to current position in screen pixel space
                               stbtt_aligned_quad *q,      // output: quad to draw
                               int align_to_integer);

STBTT_DEF int  stbtt_PackFontRangesGatherRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects);
STBTT_DEF void stbtt_PackFontRangesPackRects(stbtt_pack_context *spc, stbrp_rect *rects, int num_rects);
STBTT_DEF int  stbtt_PackFontRangesRenderIntoRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects);
// Calling these functions in sequence is roughly equivalent to calling
// stbtt_PackFontRanges(). If you more control over the packing of multiple
// fonts, or if you want to pack custom data into a font texture, take a look
// at the source to of stbtt_PackFontRanges() and create a custom version
// using these functions, e.g. call GatherRects multiple times,
// building up a single array of rects, then call PackRects once,
// then call RenderIntoRects repeatedly. This may result in a
// better packing than calling PackFontRanges multiple times
// (or it may not).

// this is an opaque structure that you shouldn't mess with which holds
// all the context needed from PackBegin to PackEnd.
struct stbtt_pack_context {
   void *user_allocator_context;
   void *pack_info;
   int   width;
   int   height;
   int   stride_in_bytes;
   int   padding;
   int   skip_missing;
   unsigned int   h_oversample, v_oversample;
   unsigned char *pixels;
   void  *nodes;
};

//////////////////////////////////////////////////////////////////////////////
//
// FONT LOADING
//
//

STBTT_DEF int stbtt_GetNumberOfFonts(const unsigned char *data);
// This function will determine the number of fonts in a font file.  TrueType
// collection (.ttc) files may contain multiple fonts, while TrueType font
// (.ttf) files only contain one font. The number of fonts can be used for
// indexing with the previous function where the index is between zero and one
// less than the total fonts. If an error occurs, -1 is returned.

STBTT_DEF int stbtt_GetFontOffsetForIndex(const unsigned char *data, int index);
// Each .ttf/.ttc file may have more than one font. Each font has a sequential
// index number starting from 0. Call this function to get the font offset for
// a given index; it returns -1 if the index is out of range. A regular .ttf
// file will only define one font and it always be at offset 0, so it will
// return '0' for index 0, and -1 for all other indices.

// The following structure is defined publicly so you can declare one on
// the stack or as a global or etc, but you should treat it as opaque.
struct stbtt_fontinfo
{
   void           * userdata;
   unsigned char  * data;              // pointer to .ttf file
   int              fontstart;         // offset of start of font

   int numGlyphs;                     // number of glyphs, needed for range checking

   int loca,head,glyf,hhea,hmtx,kern,gpos,svg; // table locations as offset from start of .ttf
   int index_map;                     // a cmap mapping for our chosen character encoding
   int indexToLocFormat;              // format needed to map from glyph index to glyph

   stbtt__buf cff;                    // cff font data
   stbtt__buf charstrings;            // the charstring index
   stbtt__buf gsubrs;                 // global charstring subroutines index
   stbtt__buf subrs;                  // private charstring subroutines index
   stbtt__buf fontdicts;              // array of font dicts
   stbtt__buf fdselect;               // map from glyph to fontdict
};

STBTT_DEF int stbtt_InitFont(stbtt_fontinfo *info, const unsigned char *data, int offset);
// Given an offset into the file that defines a font, this function builds
// the necessary cached info for the rest of the system. You must allocate
// the stbtt_fontinfo yourself, and stbtt_InitFont will fill it out. You don't
// need to do anything special to free it, because the contents are pure
// value data with no additional data structures. Returns 0 on failure.


//////////////////////////////////////////////////////////////////////////////
//
// CHARACTER TO GLYPH-INDEX CONVERSIOn

STBTT_DEF int stbtt_FindGlyphIndex(const stbtt_fontinfo *info, int unicode_codepoint);
// If you're going to perform multiple operations on the same character
// and you want a speed-up, call this function with the character you're
// going to process, then use glyph-based functions instead of the
// codepoint-based functions.
// Returns 0 if the character codepoint is not defined in the font.


//////////////////////////////////////////////////////////////////////////////
//
// CHARACTER PROPERTIES
//

STBTT_DEF float stbtt_ScaleForPixelHeight(const stbtt_fontinfo *info, float pixels);
// computes a scale factor to produce a font whose "height" is 'pixels' tall.
// Height is measured as the distance from the highest ascender to the lowest
// descender; in other words, it's equivalent to calling stbtt_GetFontVMetrics
// and computing:
//       scale = pixels / (ascent - descent)
// so if you prefer to measure height by the ascent only, use a similar calculation.

STBTT_DEF float stbtt_ScaleForMappingEmToPixels(const stbtt_fontinfo *info, float pixels);
// computes a scale factor to produce a font whose EM size is mapped to
// 'pixels' tall. This is probably what traditional APIs compute, but
// I'm not positive.

STBTT_DEF void stbtt_GetFontVMetrics(const stbtt_fontinfo *info, int *ascent, int *descent, int *lineGap);
// ascent is the coordinate above the baseline the font extends; descent
// is the coordinate below the baseline the font extends (i.e. it is typically negative)
// lineGap is the spacing between one row's descent and the next row's ascent...
// so you should advance the vertical position by "*ascent - *descent + *lineGap"
//   these are expressed in unscaled coordinates, so you must multiply by
//   the scale factor for a given size

STBTT_DEF int  stbtt_GetFontVMetricsOS2(const stbtt_fontinfo *info, int *typoAscent, int *typoDescent, int *typoLineGap);
// analogous to GetFontVMetrics, but returns the "typographic" values from the OS/2
// table (specific to MS/Windows TTF files).
//
// Returns 1 on success (table present), 0 on failure.

STBTT_DEF void stbtt_GetFontBoundingBox(const stbtt_fontinfo *info, int *x0, int *y0, int *x1, int *y1);
// the bounding box around all possible characters

STBTT_DEF void stbtt_GetCodepointHMetrics(const stbtt_fontinfo *info, int codepoint, int *advanceWidth, int *leftSideBearing);
// leftSideBearing is the offset from the current horizontal position to the left edge of the character
// advanceWidth is the offset from the current horizontal position to the next horizontal position
//   these are expressed in unscaled coordinates

STBTT_DEF int  stbtt_GetCodepointKernAdvance(const stbtt_fontinfo *info, int ch1, int ch2);
// an additional amount to add to the 'advance' value between ch1 and ch2

STBTT_DEF int stbtt_GetCodepointBox(const stbtt_fontinfo *info, int codepoint, int *x0, int *y0, int *x1, int *y1);
// Gets the bounding box of the visible part of the glyph, in unscaled coordinates

STBTT_DEF void stbtt_GetGlyphHMetrics(const stbtt_fontinfo *info, int glyph_index, int *advanceWidth, int *leftSideBearing);
STBTT_DEF int  stbtt_GetGlyphKernAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2);
STBTT_DEF int  stbtt_GetGlyphBox(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1);
// as above, but takes one or more glyph indices for greater efficiency

typedef struct stbtt_kerningentry
{
   int glyph1; // use stbtt_FindGlyphIndex
   int glyph2;
   int advance;
} stbtt_kerningentry;

STBTT_DEF int  stbtt_GetKerningTableLength(const stbtt_fontinfo *info);
STBTT_DEF int  stbtt_GetKerningTable(const stbtt_fontinfo *info, stbtt_kerningentry* table, int table_length);
// Retrieves a complete list of all of the kerning pairs provided by the font
// stbtt_GetKerningTable never writes more than table_length entries and returns how many entries it did write.
// The table will be sorted by (a.glyph1 == b.glyph1)?(a.glyph2 < b.glyph2):(a.glyph1 < b.glyph1)

//////////////////////////////////////////////////////////////////////////////
//
// GLYPH SHAPES (you probably don't need these, but they have to go before
// the bitmaps for C declaration-order reasons)
//

#ifndef STBTT_vmove // you can predefine these to use different values (but why?)
   enum {
      STBTT_vmove=1,
      STBTT_vline,
      STBTT_vcurve,
      STBTT_vcubic
   };
#endif

#ifndef stbtt_vertex // you can predefine this to use different values
                   // (we share this with other code at RAD)
   #define stbtt_vertex_type short // can't use stbtt_int16 because that's not visible in the header file
   typedef struct
   {
      stbtt_vertex_type x,y,cx,cy,cx1,cy1;
      unsigned char type,padding;
   } stbtt_vertex;
#endif

STBTT_DEF int stbtt_IsGlyphEmpty(const stbtt_fontinfo *info, int glyph_index);
// returns non-zero if nothing is drawn for this glyph

STBTT_DEF int stbtt_GetCodepointShape(const stbtt_fontinfo *info, int unicode_codepoint, stbtt_vertex **vertices);
STBTT_DEF int stbtt_GetGlyphShape(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **vertices);
// returns # of vertices and fills *vertices with the pointer to them
//   these are expressed in "unscaled" coordinates
//
// The shape is a series of contours. Each one starts with
// a STBTT_moveto, then consists of a series of mixed
// STBTT_lineto and STBTT_curveto segments. A lineto
// draws a line from previous endpoint to its x,y; a curveto
// draws a quadratic bezier from previous endpoint to
// its x,y, using cx,cy as the bezier control point.

STBTT_DEF void stbtt_FreeShape(const stbtt_fontinfo *info, stbtt_vertex *vertices);
// frees the data allocated above

STBTT_DEF unsigned char *stbtt_FindSVGDoc(const stbtt_fontinfo *info, int gl);
STBTT_DEF int stbtt_GetCodepointSVG(const stbtt_fontinfo *info, int unicode_codepoint, const char **svg);
STBTT_DEF int stbtt_GetGlyphSVG(const stbtt_fontinfo *info, int gl, const char **svg);
// fills svg with the character's SVG data.
// returns data size or 0 if SVG not found.

//////////////////////////////////////////////////////////////////////////////
//
// BITMAP RENDERING
//

STBTT_DEF void stbtt_FreeBitmap(unsigned char *bitmap, void *userdata);
// frees the bitmap allocated below

STBTT_DEF unsigned char *stbtt_GetCodepointBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int codepoint, int *width, int *height, int *xoff, int *yoff);
// allocates a large-enough single-channel 8bpp bitmap and renders the
// specified character/glyph at the specified scale into it, with
// antialiasing. 0 is no coverage (transparent), 255 is fully covered (opaque).
// *width & *height are filled out with the width & height of the bitmap,
// which is stored left-to-right, top-to-bottom.
//
// xoff/yoff are the offset it pixel space from the glyph origin to the top-left of the bitmap

STBTT_DEF unsigned char *stbtt_GetCodepointBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint, int *width, int *height, int *xoff, int *yoff);
// the same as stbtt_GetCodepoitnBitmap, but you can specify a subpixel
// shift for the character

STBTT_DEF void stbtt_MakeCodepointBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int codepoint);
// the same as stbtt_GetCodepointBitmap, but you pass in storage for the bitmap
// in the form of 'output', with row spacing of 'out_stride' bytes. the bitmap
// is clipped to out_w/out_h bytes. Call stbtt_GetCodepointBitmapBox to get the
// width and height and positioning info for it first.

STBTT_DEF void stbtt_MakeCodepointBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint);
// same as stbtt_MakeCodepointBitmap, but you can specify a subpixel
// shift for the character

STBTT_DEF void stbtt_MakeCodepointBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int oversample_x, int oversample_y, float *sub_x, float *sub_y, int codepoint);
// same as stbtt_MakeCodepointBitmapSubpixel, but prefiltering
// is performed (see stbtt_PackSetOversampling)

STBTT_DEF void stbtt_GetCodepointBitmapBox(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1);
// get the bbox of the bitmap centered around the glyph origin; so the
// bitmap width is ix1-ix0, height is iy1-iy0, and location to place
// the bitmap top left is (leftSideBearing*scale,iy0).
// (Note that the bitmap uses y-increases-down, but the shape uses
// y-increases-up, so CodepointBitmapBox and CodepointBox are inverted.)

STBTT_DEF void stbtt_GetCodepointBitmapBoxSubpixel(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1);
// same as stbtt_GetCodepointBitmapBox, but you can specify a subpixel
// shift for the character

// the following functions are equivalent to the above functions, but operate
// on glyph indices instead of Unicode codepoints (for efficiency)
STBTT_DEF unsigned char *stbtt_GetGlyphBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int glyph, int *width, int *height, int *xoff, int *yoff);
STBTT_DEF unsigned char *stbtt_GetGlyphBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int glyph, int *width, int *height, int *xoff, int *yoff);
STBTT_DEF void stbtt_MakeGlyphBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int glyph);
STBTT_DEF void stbtt_MakeGlyphBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int glyph);
STBTT_DEF void stbtt_MakeGlyphBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int oversample_x, int oversample_y, float *sub_x, float *sub_y, int glyph);
STBTT_DEF void stbtt_GetGlyphBitmapBox(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1);
STBTT_DEF void stbtt_GetGlyphBitmapBoxSubpixel(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y,float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1);


// @TODO: don't expose this structure
typedef struct
{
   int w,h,stride;
   unsigned char *pixels;
} stbtt__bitmap;

// rasterize a shape with quadratic beziers into a bitmap
STBTT_DEF void stbtt_Rasterize(stbtt__bitmap *result,        // 1-channel bitmap to draw into
                               float flatness_in_pixels,     // allowable error of curve in pixels
                               stbtt_vertex *vertices,       // array of vertices defining shape
                               int num_verts,                // number of vertices in above array
                               float scale_x, float scale_y, // scale applied to input vertices
                               float shift_x, float shift_y, // translation applied to input vertices
                               int x_off, int y_off,         // another translation applied to input
                               int invert,                   // if non-zero, vertically flip shape
                               void *userdata);              // context for to STBTT_MALLOC

//////////////////////////////////////////////////////////////////////////////
//
// Signed Distance Function (or Field) rendering

STBTT_DEF void stbtt_FreeSDF(unsigned char *bitmap, void *userdata);
// frees the SDF bitmap allocated below

STBTT_DEF unsigned char * stbtt_GetGlyphSDF(const stbtt_fontinfo *info, float scale, int glyph, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff);
STBTT_DEF unsigned char * stbtt_GetCodepointSDF(const stbtt_fontinfo *info, float scale, int codepoint, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff);
// These functions compute a discretized SDF field for a single character, suitable for storing
// in a single-channel texture, sampling with bilinear filtering, and testing against
// larger than some threshold to produce scalable fonts.
//        info              --  the font
//        scale             --  controls the size of the resulting SDF bitmap, same as it would be creating a regular bitmap
//        glyph/codepoint   --  the character to generate the SDF for
//        padding           --  extra "pixels" around the character which are filled with the distance to the character (not 0),
//                                 which allows effects like bit outlines
//        onedge_value      --  value 0-255 to test the SDF against to reconstruct the character (i.e. the isocontour of the character)
//        pixel_dist_scale  --  what value the SDF should increase by when moving one SDF "pixel" away from the edge (on the 0..255 scale)
//                                 if positive, > onedge_value is inside; if negative, < onedge_value is inside
//        width,height      --  output height & width of the SDF bitmap (including padding)
//        xoff,yoff         --  output origin of the character
//        return value      --  a 2D array of bytes 0..255, width*height in size
//
// pixel_dist_scale & onedge_value are a scale & bias that allows you to make
// optimal use of the limited 0..255 for your application, trading off precision
// and special effects. SDF values outside the range 0..255 are clamped to 0..255.
//
// Example:
//      scale = stbtt_ScaleForPixelHeight(22)
//      padding = 5
//      onedge_value = 180
//      pixel_dist_scale = 180/5.0 = 36.0
//
//      This will create an SDF bitmap in which the character is about 22 pixels
//      high but the whole bitmap is about 22+5+5=32 pixels high. To produce a filled
//      shape, sample the SDF at each pixel and fill the pixel if the SDF value
//      is greater than or equal to 180/255. (You'll actually want to antialias,
//      which is beyond the scope of this example.) Additionally, you can compute
//      offset outlines (e.g. to stroke the character border inside & outside,
//      or only outside). For example, to fill outside the character up to 3 SDF
//      pixels, you would compare against (180-36.0*3)/255 = 72/255. The above
//      choice of variables maps a range from 5 pixels outside the shape to
//      2 pixels inside the shape to 0..255; this is intended primarily for apply
//      outside effects only (the interior range is needed to allow proper
//      antialiasing of the font at *smaller* sizes)
//
// The function computes the SDF analytically at each SDF pixel, not by e.g.
// building a higher-res bitmap and approximating it. In theory the quality
// should be as high as possible for an SDF of this size & representation, but
// unclear if this is true in practice (perhaps building a higher-res bitmap
// and computing from that can allow drop-out prevention).
//
// The algorithm has not been optimized at all, so expect it to be slow
// if computing lots of characters or very large sizes.



//////////////////////////////////////////////////////////////////////////////
//
// Finding the right font...
//
// You should really just solve this offline, keep your own tables
// of what font is what, and don't try to get it out of the .ttf file.
// That's because getting it out of the .ttf file is really hard, because
// the names in the file can appear in many possible encodings, in many
// possible languages, and e.g. if you need a case-insensitive comparison,
// the details of that depend on the encoding & language in a complex way
// (actually underspecified in truetype, but also gigantic).
//
// But you can use the provided functions in two possible ways:
//     stbtt_FindMatchingFont() will use *case-sensitive* comparisons on
//             unicode-encoded names to try to find the font you want;
//             you can run this before calling stbtt_InitFont()
//
//     stbtt_GetFontNameString() lets you get any of the various strings
//             from the file yourself and do your own comparisons on them.
//             You have to have called stbtt_InitFont() first.


STBTT_DEF int stbtt_FindMatchingFont(const unsigned char *fontdata, const char *name, int flags);
// returns the offset (not index) of the font that matches, or -1 if none
//   if you use STBTT_MACSTYLE_DONTCARE, use a font name like "Arial Bold".
//   if you use any other flag, use a font name like "Arial"; this checks
//     the 'macStyle' header field; i don't know if fonts set this consistently
#define STBTT_MACSTYLE_DONTCARE     0
#define STBTT_MACSTYLE_BOLD         1
#define STBTT_MACSTYLE_ITALIC       2
#define STBTT_MACSTYLE_UNDERSCORE   4
#define STBTT_MACSTYLE_NONE         8   // <= not same as 0, this makes us check the bitfield is 0

STBTT_DEF int stbtt_CompareUTF8toUTF16_bigendian(const char *s1, int len1, const char *s2, int len2);
// returns 1/0 whether the first string interpreted as utf8 is identical to
// the second string interpreted as big-endian utf16... useful for strings from next func

STBTT_DEF const char *stbtt_GetFontNameString(const stbtt_fontinfo *font, int *length, int platformID, int encodingID, int languageID, int nameID);
// returns the string (which may be big-endian double byte, e.g. for unicode)
// and puts the length in bytes in *length.
//
// some of the values for the IDs are below; for more see the truetype spec:
//     http://developer.apple.com/textfonts/TTRefMan/RM06/Chap6name.html
//     http://www.microsoft.com/typography/otspec/name.htm

enum { // platformID
   STBTT_PLATFORM_ID_UNICODE   =0,
   STBTT_PLATFORM_ID_MAC       =1,
   STBTT_PLATFORM_ID_ISO       =2,
   STBTT_PLATFORM_ID_MICROSOFT =3
};

enum { // encodingID for STBTT_PLATFORM_ID_UNICODE
   STBTT_UNICODE_EID_UNICODE_1_0    =0,
   STBTT_UNICODE_EID_UNICODE_1_1    =1,
   STBTT_UNICODE_EID_ISO_10646      =2,
   STBTT_UNICODE_EID_UNICODE_2_0_BMP=3,
   STBTT_UNICODE_EID_UNICODE_2_0_FULL=4
};

enum { // encodingID for STBTT_PLATFORM_ID_MICROSOFT
   STBTT_MS_EID_SYMBOL        =0,
   STBTT_MS_EID_UNICODE_BMP   =1,
   STBTT_MS_EID_SHIFTJIS      =2,
   STBTT_MS_EID_UNICODE_FULL  =10
};

enum { // encodingID for STBTT_PLATFORM_ID_MAC; same as Script Manager codes
   STBTT_MAC_EID_ROMAN        =0,   STBTT_MAC_EID_ARABIC       =4,
   STBTT_MAC_EID_JAPANESE     =1,   STBTT_MAC_EID_HEBREW       =5,
   STBTT_MAC_EID_CHINESE_TRAD =2,   STBTT_MAC_EID_GREEK        =6,
   STBTT_MAC_EID_KOREAN       =3,   STBTT_MAC_EID_RUSSIAN      =7
};

enum { // languageID for STBTT_PLATFORM_ID_MICROSOFT; same as LCID...
       // problematic because there are e.g. 16 english LCIDs and 16 arabic LCIDs
   STBTT_MS_LANG_ENGLISH     =0x0409,   STBTT_MS_LANG_ITALIAN     =0x0410,
   STBTT_MS_LANG_CHINESE     =0x0804,   STBTT_MS_LANG_JAPANESE    =0x0411,
   STBTT_MS_LANG_DUTCH       =0x0413,   STBTT_MS_LANG_KOREAN      =0x0412,
   STBTT_MS_LANG_FRENCH      =0x040c,   STBTT_MS_LANG_RUSSIAN     =0x0419,
   STBTT_MS_LANG_GERMAN      =0x0407,   STBTT_MS_LANG_SPANISH     =0x0409,
   STBTT_MS_LANG_HEBREW      =0x040d,   STBTT_MS_LANG_SWEDISH     =0x041D
};

enum { // languageID for STBTT_PLATFORM_ID_MAC
   STBTT_MAC_LANG_ENGLISH      =0 ,   STBTT_MAC_LANG_JAPANESE     =11,
   STBTT_MAC_LANG_ARABIC       =12,   STBTT_MAC_LANG_KOREAN       =23,
   STBTT_MAC_LANG_DUTCH        =4 ,   STBTT_MAC_LANG_RUSSIAN      =32,
   STBTT_MAC_LANG_FRENCH       =1 ,   STBTT_MAC_LANG_SPANISH      =6 ,
   STBTT_MAC_LANG_GERMAN       =2 ,   STBTT_MAC_LANG_SWEDISH      =5 ,
   STBTT_MAC_LANG_HEBREW       =10,   STBTT_MAC_LANG_CHINESE_SIMPLIFIED =33,
   STBTT_MAC_LANG_ITALIAN      =3 ,   STBTT_MAC_LANG_CHINESE_TRAD =19
};

#ifdef __cplusplus
}
#endif

#endif // __STB_INCLUDE_STB_TRUETYPE_H__

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
////
////   IMPLEMENTATION
////
////

#ifdef STB_TRUETYPE_IMPLEMENTATION

#ifndef STBTT_MAX_OVERSAMPLE
#define STBTT_MAX_OVERSAMPLE   8
#endif

#if STBTT_MAX_OVERSAMPLE > 255
#error "STBTT_MAX_OVERSAMPLE cannot be > 255"
#endif

typedef int stbtt__test_oversample_pow2[(STBTT_MAX_OVERSAMPLE & (STBTT_MAX_OVERSAMPLE-1)) == 0 ? 1 : -1];

#ifndef STBTT_RASTERIZER_VERSION
#define STBTT_RASTERIZER_VERSION 2
#endif

#ifdef _MSC_VER
#define STBTT__NOTUSED(v)  (void)(v)
#else
#define STBTT__NOTUSED(v)  (void)sizeof(v)
#endif

//////////////////////////////////////////////////////////////////////////
//
// stbtt__buf helpers to parse data from file
//

static stbtt_uint8 stbtt__buf_get8(stbtt__buf *b)
{
   if (b->cursor >= b->size)
      return 0;
   return b->data[b->cursor++];
}

static stbtt_uint8 stbtt__buf_peek8(stbtt__buf *b)
{
   if (b->cursor >= b->size)
      return 0;
   return b->data[b->cursor];
}

static void stbtt__buf_seek(stbtt__buf *b, int o)
{
   STBTT_assert(!(o > b->size || o < 0));
   b->cursor = (o > b->size || o < 0) ? b->size : o;
}

static void stbtt__buf_skip(stbtt__buf *b, int o)
{
   stbtt__buf_seek(b, b->cursor + o);
}

static stbtt_uint32 stbtt__buf_get(stbtt__buf *b, int n)
{
   stbtt_uint32 v = 0;
   int i;
   STBTT_assert(n >= 1 && n <= 4);
   for (i = 0; i < n; i++)
      v = (v << 8) | stbtt__buf_get8(b);
   return v;
}

static stbtt__buf stbtt__new_buf(const void *p, size_t size)
{
   stbtt__buf r;
   STBTT_assert(size < 0x40000000);
   r.data = (stbtt_uint8*) p;
   r.size = (int) size;
   r.cursor = 0;
   return r;
}

#define stbtt__buf_get16(b)  stbtt__buf_get((b), 2)
#define stbtt__buf_get32(b)  stbtt__buf_get((b), 4)

static stbtt__buf stbtt__buf_range(const stbtt__buf *b, int o, int s)
{
   stbtt__buf r = stbtt__new_buf(NULL, 0);
   if (o < 0 || s < 0 || o > b->size || s > b->size - o) return r;
   r.data = b->data + o;
   r.size = s;
   return r;
}

static stbtt__buf stbtt__cff_get_index(stbtt__buf *b)
{
   int count, start, offsize;
   start = b->cursor;
   count = stbtt__buf_get16(b);
   if (count) {
      offsize = stbtt__buf_get8(b);
      STBTT_assert(offsize >= 1 && offsize <= 4);
      stbtt__buf_skip(b, offsize * count);
      stbtt__buf_skip(b, stbtt__buf_get(b, offsize) - 1);
   }
   return stbtt__buf_range(b, start, b->cursor - start);
}

static stbtt_uint32 stbtt__cff_int(stbtt__buf *b)
{
   int b0 = stbtt__buf_get8(b);
   if (b0 >= 32 && b0 <= 246)       return b0 - 139;
   else if (b0 >= 247 && b0 <= 250) return (b0 - 247)*256 + stbtt__buf_get8(b) + 108;
   else if (b0 >= 251 && b0 <= 254) return -(b0 - 251)*256 - stbtt__buf_get8(b) - 108;
   else if (b0 == 28)               return stbtt__buf_get16(b);
   else if (b0 == 29)               return stbtt__buf_get32(b);
   STBTT_assert(0);
   return 0;
}

static void stbtt__cff_skip_operand(stbtt__buf *b) {
   int v, b0 = stbtt__buf_peek8(b);
   STBTT_assert(b0 >= 28);
   if (b0 == 30) {
      stbtt__buf_skip(b, 1);
      while (b->cursor < b->size) {
         v = stbtt__buf_get8(b);
         if ((v & 0xF) == 0xF || (v >> 4) == 0xF)
            break;
      }
   } else {
      stbtt__cff_int(b);
   }
}

static stbtt__buf stbtt__dict_get(stbtt__buf *b, int key)
{
   stbtt__buf_seek(b, 0);
   while (b->cursor < b->size) {
      int start = b->cursor, end, op;
      while (stbtt__buf_peek8(b) >= 28)
         stbtt__cff_skip_operand(b);
      end = b->cursor;
      op = stbtt__buf_get8(b);
      if (op == 12)  op = stbtt__buf_get8(b) | 0x100;
      if (op == key) return stbtt__buf_range(b, start, end-start);
   }
   return stbtt__buf_range(b, 0, 0);
}

static void stbtt__dict_get_ints(stbtt__buf *b, int key, int outcount, stbtt_uint32 *out)
{
   int i;
   stbtt__buf operands = stbtt__dict_get(b, key);
   for (i = 0; i < outcount && operands.cursor < operands.size; i++)
      out[i] = stbtt__cff_int(&operands);
}

static int stbtt__cff_index_count(stbtt__buf *b)
{
   stbtt__buf_seek(b, 0);
   return stbtt__buf_get16(b);
}

static stbtt__buf stbtt__cff_index_get(stbtt__buf b, int i)
{
   int count, offsize, start, end;
   stbtt__buf_seek(&b, 0);
   count = stbtt__buf_get16(&b);
   offsize = stbtt__buf_get8(&b);
   STBTT_assert(i >= 0 && i < count);
   STBTT_assert(offsize >= 1 && offsize <= 4);
   stbtt__buf_skip(&b, i*offsize);
   start = stbtt__buf_get(&b, offsize);
   end = stbtt__buf_get(&b, offsize);
   return stbtt__buf_range(&b, 2+(count+1)*offsize+start, end - start);
}

//////////////////////////////////////////////////////////////////////////
//
// accessors to parse data from file
//

// on platforms that don't allow misaligned reads, if we want to allow
// truetype fonts that aren't padded to alignment, define ALLOW_UNALIGNED_TRUETYPE

#define ttBYTE(p)     (* (stbtt_uint8 *) (p))
#define ttCHAR(p)     (* (stbtt_int8 *) (p))
#define ttFixed(p)    ttLONG(p)

static stbtt_uint16 ttUSHORT(stbtt_uint8 *p) { return p[0]*256 + p[1]; }
static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }
static stbtt_uint32 ttULONG(stbtt_uint8 *p)  { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }
static stbtt_int32 ttLONG(stbtt_uint8 *p)    { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }

#define stbtt_tag4(p,c0,c1,c2,c3) ((p)[0] == (c0) && (p)[1] == (c1) && (p)[2] == (c2) && (p)[3] == (c3))
#define stbtt_tag(p,str)           stbtt_tag4(p,str[0],str[1],str[2],str[3])

static int stbtt__isfont(stbtt_uint8 *font)
{
   // check the version number
   if (stbtt_tag4(font, '1',0,0,0))  return 1; // TrueType 1
   if (stbtt_tag(font, "typ1"))   return 1; // TrueType with type 1 font -- we don't support this!
   if (stbtt_tag(font, "OTTO"))   return 1; // OpenType with CFF
   if (stbtt_tag4(font, 0,1,0,0)) return 1; // OpenType 1.0
   if (stbtt_tag(font, "true"))   return 1; // Apple specification for TrueType fonts
   return 0;
}

// @OPTIMIZE: binary search
static stbtt_uint32 stbtt__find_table(stbtt_uint8 *data, stbtt_uint32 fontstart, const char *tag)
{
   stbtt_int32 num_tables = ttUSHORT(data+fontstart+4);
   stbtt_uint32 tabledir = fontstart + 12;
   stbtt_int32 i;
   for (i=0; i < num_tables; ++i) {
      stbtt_uint32 loc = tabledir + 16*i;
      if (stbtt_tag(data+loc+0, tag))
         return ttULONG(data+loc+8);
   }
   return 0;
}

static int stbtt_GetFontOffsetForIndex_internal(unsigned char *font_collection, int index)
{
   // if it's just a font, there's only one valid index
   if (stbtt__isfont(font_collection))
      return index == 0 ? 0 : -1;

   // check if it's a TTC
   if (stbtt_tag(font_collection, "ttcf")) {
      // version 1?
      if (ttULONG(font_collection+4) == 0x00010000 || ttULONG(font_collection+4) == 0x00020000) {
         stbtt_int32 n = ttLONG(font_collection+8);
         if (index >= n)
            return -1;
         return ttULONG(font_collection+12+index*4);
      }
   }
   return -1;
}

static int stbtt_GetNumberOfFonts_internal(unsigned char *font_collection)
{
   // if it's just a font, there's only one valid font
   if (stbtt__isfont(font_collection))
      return 1;

   // check if it's a TTC
   if (stbtt_tag(font_collection, "ttcf")) {
      // version 1?
      if (ttULONG(font_collection+4) == 0x00010000 || ttULONG(font_collection+4) == 0x00020000) {
         return ttLONG(font_collection+8);
      }
   }
   return 0;
}

static stbtt__buf stbtt__get_subrs(stbtt__buf cff, stbtt__buf fontdict)
{
   stbtt_uint32 subrsoff = 0, private_loc[2] = { 0, 0 };
   stbtt__buf pdict;
   stbtt__dict_get_ints(&fontdict, 18, 2, private_loc);
   if (!private_loc[1] || !private_loc[0]) return stbtt__new_buf(NULL, 0);
   pdict = stbtt__buf_range(&cff, private_loc[1], private_loc[0]);
   stbtt__dict_get_ints(&pdict, 19, 1, &subrsoff);
   if (!subrsoff) return stbtt__new_buf(NULL, 0);
   stbtt__buf_seek(&cff, private_loc[1]+subrsoff);
   return stbtt__cff_get_index(&cff);
}

// since most people won't use this, find this table the first time it's needed
static int stbtt__get_svg(stbtt_fontinfo *info)
{
   stbtt_uint32 t;
   if (info->svg < 0) {
      t = stbtt__find_table(info->data, info->fontstart, "SVG ");
      if (t) {
         stbtt_uint32 offset = ttULONG(info->data + t + 2);
         info->svg = t + offset;
      } else {
         info->svg = 0;
      }
   }
   return info->svg;
}

static int stbtt_InitFont_internal(stbtt_fontinfo *info, unsigned char *data, int fontstart)
{
   stbtt_uint32 cmap, t;
   stbtt_int32 i,numTables;

   info->data = data;
   info->fontstart = fontstart;
   info->cff = stbtt__new_buf(NULL, 0);

   cmap = stbtt__find_table(data, fontstart, "cmap");       // required
   info->loca = stbtt__find_table(data, fontstart, "loca"); // required
   info->head = stbtt__find_table(data, fontstart, "head"); // required
   info->glyf = stbtt__find_table(data, fontstart, "glyf"); // required
   info->hhea = stbtt__find_table(data, fontstart, "hhea"); // required
   info->hmtx = stbtt__find_table(data, fontstart, "hmtx"); // required
   info->kern = stbtt__find_table(data, fontstart, "kern"); // not required
   info->gpos = stbtt__find_table(data, fontstart, "GPOS"); // not required

   if (!cmap || !info->head || !info->hhea || !info->hmtx)
      return 0;
   if (info->glyf) {
      // required for truetype
      if (!info->loca) return 0;
   } else {
      // initialization for CFF / Type2 fonts (OTF)
      stbtt__buf b, topdict, topdictidx;
      stbtt_uint32 cstype = 2, charstrings = 0, fdarrayoff = 0, fdselectoff = 0;
      stbtt_uint32 cff;

      cff = stbtt__find_table(data, fontstart, "CFF ");
      if (!cff) return 0;

      info->fontdicts = stbtt__new_buf(NULL, 0);
      info->fdselect = stbtt__new_buf(NULL, 0);

      // @TODO this should use size from table (not 512MB)
      info->cff = stbtt__new_buf(data+cff, 512*1024*1024);
      b = info->cff;

      // read the header
      stbtt__buf_skip(&b, 2);
      stbtt__buf_seek(&b, stbtt__buf_get8(&b)); // hdrsize

      // @TODO the name INDEX could list multiple fonts,
      // but we just use the first one.
      stbtt__cff_get_index(&b);  // name INDEX
      topdictidx = stbtt__cff_get_index(&b);
      topdict = stbtt__cff_index_get(topdictidx, 0);
      stbtt__cff_get_index(&b);  // string INDEX
      info->gsubrs = stbtt__cff_get_index(&b);

      stbtt__dict_get_ints(&topdict, 17, 1, &charstrings);
      stbtt__dict_get_ints(&topdict, 0x100 | 6, 1, &cstype);
      stbtt__dict_get_ints(&topdict, 0x100 | 36, 1, &fdarrayoff);
      stbtt__dict_get_ints(&topdict, 0x100 | 37, 1, &fdselectoff);
      info->subrs = stbtt__get_subrs(b, topdict);

      // we only support Type 2 charstrings
      if (cstype != 2) return 0;
      if (charstrings == 0) return 0;

      if (fdarrayoff) {
         // looks like a CID font
         if (!fdselectoff) return 0;
         stbtt__buf_seek(&b, fdarrayoff);
         info->fontdicts = stbtt__cff_get_index(&b);
         info->fdselect = stbtt__buf_range(&b, fdselectoff, b.size-fdselectoff);
      }

      stbtt__buf_seek(&b, charstrings);
      info->charstrings = stbtt__cff_get_index(&b);
   }

   t = stbtt__find_table(data, fontstart, "maxp");
   if (t)
      info->numGlyphs = ttUSHORT(data+t+4);
   else
      info->numGlyphs = 0xffff;

   info->svg = -1;

   // find a cmap encoding table we understand *now* to avoid searching
   // later. (todo: could make this installable)
   // the same regardless of glyph.
   numTables = ttUSHORT(data + cmap + 2);
   info->index_map = 0;
   for (i=0; i < numTables; ++i) {
      stbtt_uint32 encoding_record = cmap + 4 + 8 * i;
      // find an encoding we understand:
      switch(ttUSHORT(data+encoding_record)) {
         case STBTT_PLATFORM_ID_MICROSOFT:
            switch (ttUSHORT(data+encoding_record+2)) {
               case STBTT_MS_EID_UNICODE_BMP:
               case STBTT_MS_EID_UNICODE_FULL:
                  // MS/Unicode
                  info->index_map = cmap + ttULONG(data+encoding_record+4);
                  break;
            }
            break;
        case STBTT_PLATFORM_ID_UNICODE:
            // Mac/iOS has these
            // all the encodingIDs are unicode, so we don't bother to check it
            info->index_map = cmap + ttULONG(data+encoding_record+4);
            break;
      }
   }
   if (info->index_map == 0)
      return 0;

   info->indexToLocFormat = ttUSHORT(data+info->head + 50);
   return 1;
}

STBTT_DEF int stbtt_FindGlyphIndex(const stbtt_fontinfo *info, int unicode_codepoint)
{
   stbtt_uint8 *data = info->data;
   stbtt_uint32 index_map = info->index_map;

   stbtt_uint16 format = ttUSHORT(data + index_map + 0);
   if (format == 0) { // apple byte encoding
      stbtt_int32 bytes = ttUSHORT(data + index_map + 2);
      if (unicode_codepoint < bytes-6)
         return ttBYTE(data + index_map + 6 + unicode_codepoint);
      return 0;
   } else if (format == 6) {
      stbtt_uint32 first = ttUSHORT(data + index_map + 6);
      stbtt_uint32 count = ttUSHORT(data + index_map + 8);
      if ((stbtt_uint32) unicode_codepoint >= first && (stbtt_uint32) unicode_codepoint < first+count)
         return ttUSHORT(data + index_map + 10 + (unicode_codepoint - first)*2);
      return 0;
   } else if (format == 2) {
      STBTT_assert(0); // @TODO: high-byte mapping for japanese/chinese/korean
      return 0;
   } else if (format == 4) { // standard mapping for windows fonts: binary search collection of ranges
      stbtt_uint16 segcount = ttUSHORT(data+index_map+6) >> 1;
      stbtt_uint16 searchRange = ttUSHORT(data+index_map+8) >> 1;
      stbtt_uint16 entrySelector = ttUSHORT(data+index_map+10);
      stbtt_uint16 rangeShift = ttUSHORT(data+index_map+12) >> 1;

      // do a binary search of the segments
      stbtt_uint32 endCount = index_map + 14;
      stbtt_uint32 search = endCount;

      if (unicode_codepoint > 0xffff)
         return 0;

      // they lie from endCount .. endCount + segCount
      // but searchRange is the nearest power of two, so...
      if (unicode_codepoint >= ttUSHORT(data + search + rangeShift*2))
         search += rangeShift*2;

      // now decrement to bias correctly to find smallest
      search -= 2;
      while (entrySelector) {
         stbtt_uint16 end;
         searchRange >>= 1;
         end = ttUSHORT(data + search + searchRange*2);
         if (unicode_codepoint > end)
            search += searchRange*2;
         --entrySelector;
      }
      search += 2;

      {
         stbtt_uint16 offset, start, last;
         stbtt_uint16 item = (stbtt_uint16) ((search - endCount) >> 1);

         start = ttUSHORT(data + index_map + 14 + segcount*2 + 2 + 2*item);
         last = ttUSHORT(data + endCount + 2*item);
         if (unicode_codepoint < start || unicode_codepoint > last)
            return 0;

         offset = ttUSHORT(data + index_map + 14 + segcount*6 + 2 + 2*item);
         if (offset == 0)
            return (stbtt_uint16) (unicode_codepoint + ttSHORT(data + index_map + 14 + segcount*4 + 2 + 2*item));

         return ttUSHORT(data + offset + (unicode_codepoint-start)*2 + index_map + 14 + segcount*6 + 2 + 2*item);
      }
   } else if (format == 12 || format == 13) {
      stbtt_uint32 ngroups = ttULONG(data+index_map+12);
      stbtt_int32 low,high;
      low = 0; high = (stbtt_int32)ngroups;
      // Binary search the right group.
      while (low < high) {
         stbtt_int32 mid = low + ((high-low) >> 1); // rounds down, so low <= mid < high
         stbtt_uint32 start_char = ttULONG(data+index_map+16+mid*12);
         stbtt_uint32 end_char = ttULONG(data+index_map+16+mid*12+4);
         if ((stbtt_uint32) unicode_codepoint < start_char)
            high = mid;
         else if ((stbtt_uint32) unicode_codepoint > end_char)
            low = mid+1;
         else {
            stbtt_uint32 start_glyph = ttULONG(data+index_map+16+mid*12+8);
            if (format == 12)
               return start_glyph + unicode_codepoint-start_char;
            else // format == 13
               return start_glyph;
         }
      }
      return 0; // not found
   }
   // @TODO
   STBTT_assert(0);
   return 0;
}

STBTT_DEF int stbtt_GetCodepointShape(const stbtt_fontinfo *info, int unicode_codepoint, stbtt_vertex **vertices)
{
   return stbtt_GetGlyphShape(info, stbtt_FindGlyphIndex(info, unicode_codepoint), vertices);
}

static void stbtt_setvertex(stbtt_vertex *v, stbtt_uint8 type, stbtt_int32 x, stbtt_int32 y, stbtt_int32 cx, stbtt_int32 cy)
{
   v->type = type;
   v->x = (stbtt_int16) x;
   v->y = (stbtt_int16) y;
   v->cx = (stbtt_int16) cx;
   v->cy = (stbtt_int16) cy;
}

static int stbtt__GetGlyfOffset(const stbtt_fontinfo *info, int glyph_index)
{
   int g1,g2;

   STBTT_assert(!info->cff.size);

   if (glyph_index >= info->numGlyphs) return -1; // glyph index out of range
   if (info->indexToLocFormat >= 2)    return -1; // unknown index->glyph map format

   if (info->indexToLocFormat == 0) {
      g1 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2) * 2;
      g2 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2 + 2) * 2;
   } else {
      g1 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4);
      g2 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4 + 4);
   }

   return g1==g2 ? -1 : g1; // if length is 0, return -1
}

static int stbtt__GetGlyphInfoT2(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1);

STBTT_DEF int stbtt_GetGlyphBox(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1)
{
   if (info->cff.size) {
      stbtt__GetGlyphInfoT2(info, glyph_index, x0, y0, x1, y1);
   } else {
      int g = stbtt__GetGlyfOffset(info, glyph_index);
      if (g < 0) return 0;

      if (x0) *x0 = ttSHORT(info->data + g + 2);
      if (y0) *y0 = ttSHORT(info->data + g + 4);
      if (x1) *x1 = ttSHORT(info->data + g + 6);
      if (y1) *y1 = ttSHORT(info->data + g + 8);
   }
   return 1;
}

STBTT_DEF int stbtt_GetCodepointBox(const stbtt_fontinfo *info, int codepoint, int *x0, int *y0, int *x1, int *y1)
{
   return stbtt_GetGlyphBox(info, stbtt_FindGlyphIndex(info,codepoint), x0,y0,x1,y1);
}

STBTT_DEF int stbtt_IsGlyphEmpty(const stbtt_fontinfo *info, int glyph_index)
{
   stbtt_int16 numberOfContours;
   int g;
   if (info->cff.size)
      return stbtt__GetGlyphInfoT2(info, glyph_index, NULL, NULL, NULL, NULL) == 0;
   g = stbtt__GetGlyfOffset(info, glyph_index);
   if (g < 0) return 1;
   numberOfContours = ttSHORT(info->data + g);
   return numberOfContours == 0;
}

static int stbtt__close_shape(stbtt_vertex *vertices, int num_vertices, int was_off, int start_off,
    stbtt_int32 sx, stbtt_int32 sy, stbtt_int32 scx, stbtt_int32 scy, stbtt_int32 cx, stbtt_int32 cy)
{
   if (start_off) {
      if (was_off)
         stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+scx)>>1, (cy+scy)>>1, cx,cy);
      stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, sx,sy,scx,scy);
   } else {
      if (was_off)
         stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve,sx,sy,cx,cy);
      else
         stbtt_setvertex(&vertices[num_vertices++], STBTT_vline,sx,sy,0,0);
   }
   return num_vertices;
}

static int stbtt__GetGlyphShapeTT(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)
{
   stbtt_int16 numberOfContours;
   stbtt_uint8 *endPtsOfContours;
   stbtt_uint8 *data = info->data;
   stbtt_vertex *vertices=0;
   int num_vertices=0;
   int g = stbtt__GetGlyfOffset(info, glyph_index);

   *pvertices = NULL;

   if (g < 0) return 0;

   numberOfContours = ttSHORT(data + g);

   if (numberOfContours > 0) {
      stbtt_uint8 flags=0,flagcount;
      stbtt_int32 ins, i,j=0,m,n, next_move, was_off=0, off, start_off=0;
      stbtt_int32 x,y,cx,cy,sx,sy, scx,scy;
      stbtt_uint8 *points;
      endPtsOfContours = (data + g + 10);
      ins = ttUSHORT(data + g + 10 + numberOfContours * 2);
      points = data + g + 10 + numberOfContours * 2 + 2 + ins;

      n = 1+ttUSHORT(endPtsOfContours + numberOfContours*2-2);

      m = n + 2*numberOfContours;  // a loose bound on how many vertices we might need
      vertices = (stbtt_vertex *) STBTT_malloc(m * sizeof(vertices[0]), info->userdata);
      if (vertices == 0)
         return 0;

      next_move = 0;
      flagcount=0;

      // in first pass, we load uninterpreted data into the allocated array
      // above, shifted to the end of the array so we won't overwrite it when
      // we create our final data starting from the front

      off = m - n; // starting offset for uninterpreted data, regardless of how m ends up being calculated

      // first load flags

      for (i=0; i < n; ++i) {
         if (flagcount == 0) {
            flags = *points++;
            if (flags & 8)
               flagcount = *points++;
         } else
            --flagcount;
         vertices[off+i].type = flags;
      }

      // now load x coordinates
      x=0;
      for (i=0; i < n; ++i) {
         flags = vertices[off+i].type;
         if (flags & 2) {
            stbtt_int16 dx = *points++;
            x += (flags & 16) ? dx : -dx; // ???
         } else {
            if (!(flags & 16)) {
               x = x + (stbtt_int16) (points[0]*256 + points[1]);
               points += 2;
            }
         }
         vertices[off+i].x = (stbtt_int16) x;
      }

      // now load y coordinates
      y=0;
      for (i=0; i < n; ++i) {
         flags = vertices[off+i].type;
         if (flags & 4) {
            stbtt_int16 dy = *points++;
            y += (flags & 32) ? dy : -dy; // ???
         } else {
            if (!(flags & 32)) {
               y = y + (stbtt_int16) (points[0]*256 + points[1]);
               points += 2;
            }
         }
         vertices[off+i].y = (stbtt_int16) y;
      }

      // now convert them to our format
      num_vertices=0;
      sx = sy = cx = cy = scx = scy = 0;
      for (i=0; i < n; ++i) {
         flags = vertices[off+i].type;
         x     = (stbtt_int16) vertices[off+i].x;
         y     = (stbtt_int16) vertices[off+i].y;

         if (next_move == i) {
            if (i != 0)
               num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx,sy,scx,scy,cx,cy);

            // now start the new one
            start_off = !(flags & 1);
            if (start_off) {
               // if we start off with an off-curve point, then when we need to find a point on the curve
               // where we can start, and we need to save some state for when we wraparound.
               scx = x;
               scy = y;
               if (!(vertices[off+i+1].type & 1)) {
                  // next point is also a curve point, so interpolate an on-point curve
                  sx = (x + (stbtt_int32) vertices[off+i+1].x) >> 1;
                  sy = (y + (stbtt_int32) vertices[off+i+1].y) >> 1;
               } else {
                  // otherwise just use the next point as our start point
                  sx = (stbtt_int32) vertices[off+i+1].x;
                  sy = (stbtt_int32) vertices[off+i+1].y;
                  ++i; // we're using point i+1 as the starting point, so skip it
               }
            } else {
               sx = x;
               sy = y;
            }
            stbtt_setvertex(&vertices[num_vertices++], STBTT_vmove,sx,sy,0,0);
            was_off = 0;
            next_move = 1 + ttUSHORT(endPtsOfContours+j*2);
            ++j;
         } else {
            if (!(flags & 1)) { // if it's a curve
               if (was_off) // two off-curve control points in a row means interpolate an on-curve midpoint
                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+x)>>1, (cy+y)>>1, cx, cy);
               cx = x;
               cy = y;
               was_off = 1;
            } else {
               if (was_off)
                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, x,y, cx, cy);
               else
                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vline, x,y,0,0);
               was_off = 0;
            }
         }
      }
      num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx,sy,scx,scy,cx,cy);
   } else if (numberOfContours < 0) {
      // Compound shapes.
      int more = 1;
      stbtt_uint8 *comp = data + g + 10;
      num_vertices = 0;
      vertices = 0;
      while (more) {
         stbtt_uint16 flags, gidx;
         int comp_num_verts = 0, i;
         stbtt_vertex *comp_verts = 0, *tmp = 0;
         float mtx[6] = {1,0,0,1,0,0}, m, n;

         flags = ttSHORT(comp); comp+=2;
         gidx = ttSHORT(comp); comp+=2;

         if (flags & 2) { // XY values
            if (flags & 1) { // shorts
               mtx[4] = ttSHORT(comp); comp+=2;
               mtx[5] = ttSHORT(comp); comp+=2;
            } else {
               mtx[4] = ttCHAR(comp); comp+=1;
               mtx[5] = ttCHAR(comp); comp+=1;
            }
         }
         else {
            // @TODO handle matching point
            STBTT_assert(0);
         }
         if (flags & (1<<3)) { // WE_HAVE_A_SCALE
            mtx[0] = mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;
            mtx[1] = mtx[2] = 0;
         } else if (flags & (1<<6)) { // WE_HAVE_AN_X_AND_YSCALE
            mtx[0] = ttSHORT(comp)/16384.0f; comp+=2;
            mtx[1] = mtx[2] = 0;
            mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;
         } else if (flags & (1<<7)) { // WE_HAVE_A_TWO_BY_TWO
            mtx[0] = ttSHORT(comp)/16384.0f; comp+=2;
            mtx[1] = ttSHORT(comp)/16384.0f; comp+=2;
            mtx[2] = ttSHORT(comp)/16384.0f; comp+=2;
            mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;
         }

         // Find transformation scales.
         m = (float) STBTT_sqrt(mtx[0]*mtx[0] + mtx[1]*mtx[1]);
         n = (float) STBTT_sqrt(mtx[2]*mtx[2] + mtx[3]*mtx[3]);

         // Get indexed glyph.
         comp_num_verts = stbtt_GetGlyphShape(info, gidx, &comp_verts);
         if (comp_num_verts > 0) {
            // Transform vertices.
            for (i = 0; i < comp_num_verts; ++i) {
               stbtt_vertex* v = &comp_verts[i];
               stbtt_vertex_type x,y;
               x=v->x; y=v->y;
               v->x = (stbtt_vertex_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));
               v->y = (stbtt_vertex_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));
               x=v->cx; y=v->cy;
               v->cx = (stbtt_vertex_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));
               v->cy = (stbtt_vertex_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));
            }
            // Append vertices.
            tmp = (stbtt_vertex*)STBTT_malloc((num_vertices+comp_num_verts)*sizeof(stbtt_vertex), info->userdata);
            if (!tmp) {
               if (vertices) STBTT_free(vertices, info->userdata);
               if (comp_verts) STBTT_free(comp_verts, info->userdata);
               return 0;
            }
            if (num_vertices > 0 && vertices) STBTT_memcpy(tmp, vertices, num_vertices*sizeof(stbtt_vertex));
            STBTT_memcpy(tmp+num_vertices, comp_verts, comp_num_verts*sizeof(stbtt_vertex));
            if (vertices) STBTT_free(vertices, info->userdata);
            vertices = tmp;
            STBTT_free(comp_verts, info->userdata);
            num_vertices += comp_num_verts;
         }
         // More components ?
         more = flags & (1<<5);
      }
   } else {
      // numberOfCounters == 0, do nothing
   }

   *pvertices = vertices;
   return num_vertices;
}

typedef struct
{
   int bounds;
   int started;
   float first_x, first_y;
   float x, y;
   stbtt_int32 min_x, max_x, min_y, max_y;

   stbtt_vertex *pvertices;
   int num_vertices;
} stbtt__csctx;

#define STBTT__CSCTX_INIT(bounds) {bounds,0, 0,0, 0,0, 0,0,0,0, NULL, 0}

static void stbtt__track_vertex(stbtt__csctx *c, stbtt_int32 x, stbtt_int32 y)
{
   if (x > c->max_x || !c->started) c->max_x = x;
   if (y > c->max_y || !c->started) c->max_y = y;
   if (x < c->min_x || !c->started) c->min_x = x;
   if (y < c->min_y || !c->started) c->min_y = y;
   c->started = 1;
}

static void stbtt__csctx_v(stbtt__csctx *c, stbtt_uint8 type, stbtt_int32 x, stbtt_int32 y, stbtt_int32 cx, stbtt_int32 cy, stbtt_int32 cx1, stbtt_int32 cy1)
{
   if (c->bounds) {
      stbtt__track_vertex(c, x, y);
      if (type == STBTT_vcubic) {
         stbtt__track_vertex(c, cx, cy);
         stbtt__track_vertex(c, cx1, cy1);
      }
   } else {
      stbtt_setvertex(&c->pvertices[c->num_vertices], type, x, y, cx, cy);
      c->pvertices[c->num_vertices].cx1 = (stbtt_int16) cx1;
      c->pvertices[c->num_vertices].cy1 = (stbtt_int16) cy1;
   }
   c->num_vertices++;
}

static void stbtt__csctx_close_shape(stbtt__csctx *ctx)
{
   if (ctx->first_x != ctx->x || ctx->first_y != ctx->y)
      stbtt__csctx_v(ctx, STBTT_vline, (int)ctx->first_x, (int)ctx->first_y, 0, 0, 0, 0);
}

static void stbtt__csctx_rmove_to(stbtt__csctx *ctx, float dx, float dy)
{
   stbtt__csctx_close_shape(ctx);
   ctx->first_x = ctx->x = ctx->x + dx;
   ctx->first_y = ctx->y = ctx->y + dy;
   stbtt__csctx_v(ctx, STBTT_vmove, (int)ctx->x, (int)ctx->y, 0, 0, 0, 0);
}

static void stbtt__csctx_rline_to(stbtt__csctx *ctx, float dx, float dy)
{
   ctx->x += dx;
   ctx->y += dy;
   stbtt__csctx_v(ctx, STBTT_vline, (int)ctx->x, (int)ctx->y, 0, 0, 0, 0);
}

static void stbtt__csctx_rccurve_to(stbtt__csctx *ctx, float dx1, float dy1, float dx2, float dy2, float dx3, float dy3)
{
   float cx1 = ctx->x + dx1;
   float cy1 = ctx->y + dy1;
   float cx2 = cx1 + dx2;
   float cy2 = cy1 + dy2;
   ctx->x = cx2 + dx3;
   ctx->y = cy2 + dy3;
   stbtt__csctx_v(ctx, STBTT_vcubic, (int)ctx->x, (int)ctx->y, (int)cx1, (int)cy1, (int)cx2, (int)cy2);
}

static stbtt__buf stbtt__get_subr(stbtt__buf idx, int n)
{
   int count = stbtt__cff_index_count(&idx);
   int bias = 107;
   if (count >= 33900)
      bias = 32768;
   else if (count >= 1240)
      bias = 1131;
   n += bias;
   if (n < 0 || n >= count)
      return stbtt__new_buf(NULL, 0);
   return stbtt__cff_index_get(idx, n);
}

static stbtt__buf stbtt__cid_get_glyph_subrs(const stbtt_fontinfo *info, int glyph_index)
{
   stbtt__buf fdselect = info->fdselect;
   int nranges, start, end, v, fmt, fdselector = -1, i;

   stbtt__buf_seek(&fdselect, 0);
   fmt = stbtt__buf_get8(&fdselect);
   if (fmt == 0) {
      // untested
      stbtt__buf_skip(&fdselect, glyph_index);
      fdselector = stbtt__buf_get8(&fdselect);
   } else if (fmt == 3) {
      nranges = stbtt__buf_get16(&fdselect);
      start = stbtt__buf_get16(&fdselect);
      for (i = 0; i < nranges; i++) {
         v = stbtt__buf_get8(&fdselect);
         end = stbtt__buf_get16(&fdselect);
         if (glyph_index >= start && glyph_index < end) {
            fdselector = v;
            break;
         }
         start = end;
      }
   }
   if (fdselector == -1) return stbtt__new_buf(NULL, 0); // [DEAR IMGUI] fixed, see #6007 and nothings/stb#1422
   return stbtt__get_subrs(info->cff, stbtt__cff_index_get(info->fontdicts, fdselector));
}

static int stbtt__run_charstring(const stbtt_fontinfo *info, int glyph_index, stbtt__csctx *c)
{
   int in_header = 1, maskbits = 0, subr_stack_height = 0, sp = 0, v, i, b0;
   int has_subrs = 0, clear_stack;
   float s[48];
   stbtt__buf subr_stack[10], subrs = info->subrs, b;
   float f;

#define STBTT__CSERR(s) (0)

   // this currently ignores the initial width value, which isn't needed if we have hmtx
   b = stbtt__cff_index_get(info->charstrings, glyph_index);
   while (b.cursor < b.size) {
      i = 0;
      clear_stack = 1;
      b0 = stbtt__buf_get8(&b);
      switch (b0) {
      // @TODO implement hinting
      case 0x13: // hintmask
      case 0x14: // cntrmask
         if (in_header)
            maskbits += (sp / 2); // implicit "vstem"
         in_header = 0;
         stbtt__buf_skip(&b, (maskbits + 7) / 8);
         break;

      case 0x01: // hstem
      case 0x03: // vstem
      case 0x12: // hstemhm
      case 0x17: // vstemhm
         maskbits += (sp / 2);
         break;

      case 0x15: // rmoveto
         in_header = 0;
         if (sp < 2) return STBTT__CSERR("rmoveto stack");
         stbtt__csctx_rmove_to(c, s[sp-2], s[sp-1]);
         break;
      case 0x04: // vmoveto
         in_header = 0;
         if (sp < 1) return STBTT__CSERR("vmoveto stack");
         stbtt__csctx_rmove_to(c, 0, s[sp-1]);
         break;
      case 0x16: // hmoveto
         in_header = 0;
         if (sp < 1) return STBTT__CSERR("hmoveto stack");
         stbtt__csctx_rmove_to(c, s[sp-1], 0);
         break;

      case 0x05: // rlineto
         if (sp < 2) return STBTT__CSERR("rlineto stack");
         for (; i + 1 < sp; i += 2)
            stbtt__csctx_rline_to(c, s[i], s[i+1]);
         break;

      // hlineto/vlineto and vhcurveto/hvcurveto alternate horizontal and vertical
      // starting from a different place.

      case 0x07: // vlineto
         if (sp < 1) return STBTT__CSERR("vlineto stack");
         goto vlineto;
      case 0x06: // hlineto
         if (sp < 1) return STBTT__CSERR("hlineto stack");
         for (;;) {
            if (i >= sp) break;
            stbtt__csctx_rline_to(c, s[i], 0);
            i++;
      vlineto:
            if (i >= sp) break;
            stbtt__csctx_rline_to(c, 0, s[i]);
            i++;
         }
         break;

      case 0x1F: // hvcurveto
         if (sp < 4) return STBTT__CSERR("hvcurveto stack");
         goto hvcurveto;
      case 0x1E: // vhcurveto
         if (sp < 4) return STBTT__CSERR("vhcurveto stack");
         for (;;) {
            if (i + 3 >= sp) break;
            stbtt__csctx_rccurve_to(c, 0, s[i], s[i+1], s[i+2], s[i+3], (sp - i == 5) ? s[i + 4] : 0.0f);
            i += 4;
      hvcurveto:
            if (i + 3 >= sp) break;
            stbtt__csctx_rccurve_to(c, s[i], 0, s[i+1], s[i+2], (sp - i == 5) ? s[i+4] : 0.0f, s[i+3]);
            i += 4;
         }
         break;

      case 0x08: // rrcurveto
         if (sp < 6) return STBTT__CSERR("rcurveline stack");
         for (; i + 5 < sp; i += 6)
            stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);
         break;

      case 0x18: // rcurveline
         if (sp < 8) return STBTT__CSERR("rcurveline stack");
         for (; i + 5 < sp - 2; i += 6)
            stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);
         if (i + 1 >= sp) return STBTT__CSERR("rcurveline stack");
         stbtt__csctx_rline_to(c, s[i], s[i+1]);
         break;

      case 0x19: // rlinecurve
         if (sp < 8) return STBTT__CSERR("rlinecurve stack");
         for (; i + 1 < sp - 6; i += 2)
            stbtt__csctx_rline_to(c, s[i], s[i+1]);
         if (i + 5 >= sp) return STBTT__CSERR("rlinecurve stack");
         stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);
         break;

      case 0x1A: // vvcurveto
      case 0x1B: // hhcurveto
         if (sp < 4) return STBTT__CSERR("(vv|hh)curveto stack");
         f = 0.0;
         if (sp & 1) { f = s[i]; i++; }
         for (; i + 3 < sp; i += 4) {
            if (b0 == 0x1B)
               stbtt__csctx_rccurve_to(c, s[i], f, s[i+1], s[i+2], s[i+3], 0.0);
            else
               stbtt__csctx_rccurve_to(c, f, s[i], s[i+1], s[i+2], 0.0, s[i+3]);
            f = 0.0;
         }
         break;

      case 0x0A: // callsubr
         if (!has_subrs) {
            if (info->fdselect.size)
               subrs = stbtt__cid_get_glyph_subrs(info, glyph_index);
            has_subrs = 1;
         }
         // FALLTHROUGH
      case 0x1D: // callgsubr
         if (sp < 1) return STBTT__CSERR("call(g|)subr stack");
         v = (int) s[--sp];
         if (subr_stack_height >= 10) return STBTT__CSERR("recursion limit");
         subr_stack[subr_stack_height++] = b;
         b = stbtt__get_subr(b0 == 0x0A ? subrs : info->gsubrs, v);
         if (b.size == 0) return STBTT__CSERR("subr not found");
         b.cursor = 0;
         clear_stack = 0;
         break;

      case 0x0B: // return
         if (subr_stack_height <= 0) return STBTT__CSERR("return outside subr");
         b = subr_stack[--subr_stack_height];
         clear_stack = 0;
         break;

      case 0x0E: // endchar
         stbtt__csctx_close_shape(c);
         return 1;

      case 0x0C: { // two-byte escape
         float dx1, dx2, dx3, dx4, dx5, dx6, dy1, dy2, dy3, dy4, dy5, dy6;
         float dx, dy;
         int b1 = stbtt__buf_get8(&b);
         switch (b1) {
         // @TODO These "flex" implementations ignore the flex-depth and resolution,
         // and always draw beziers.
         case 0x22: // hflex
            if (sp < 7) return STBTT__CSERR("hflex stack");
            dx1 = s[0];
            dx2 = s[1];
            dy2 = s[2];
            dx3 = s[3];
            dx4 = s[4];
            dx5 = s[5];
            dx6 = s[6];
            stbtt__csctx_rccurve_to(c, dx1, 0, dx2, dy2, dx3, 0);
            stbtt__csctx_rccurve_to(c, dx4, 0, dx5, -dy2, dx6, 0);
            break;

         case 0x23: // flex
            if (sp < 13) return STBTT__CSERR("flex stack");
            dx1 = s[0];
            dy1 = s[1];
            dx2 = s[2];
            dy2 = s[3];
            dx3 = s[4];
            dy3 = s[5];
            dx4 = s[6];
            dy4 = s[7];
            dx5 = s[8];
            dy5 = s[9];
            dx6 = s[10];
            dy6 = s[11];
            //fd is s[12]
            stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, dy3);
            stbtt__csctx_rccurve_to(c, dx4, dy4, dx5, dy5, dx6, dy6);
            break;

         case 0x24: // hflex1
            if (sp < 9) return STBTT__CSERR("hflex1 stack");
            dx1 = s[0];
            dy1 = s[1];
            dx2 = s[2];
            dy2 = s[3];
            dx3 = s[4];
            dx4 = s[5];
            dx5 = s[6];
            dy5 = s[7];
            dx6 = s[8];
            stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, 0);
            stbtt__csctx_rccurve_to(c, dx4, 0, dx5, dy5, dx6, -(dy1+dy2+dy5));
            break;

         case 0x25: // flex1
            if (sp < 11) return STBTT__CSERR("flex1 stack");
            dx1 = s[0];
            dy1 = s[1];
            dx2 = s[2];
            dy2 = s[3];
            dx3 = s[4];
            dy3 = s[5];
            dx4 = s[6];
            dy4 = s[7];
            dx5 = s[8];
            dy5 = s[9];
            dx6 = dy6 = s[10];
            dx = dx1+dx2+dx3+dx4+dx5;
            dy = dy1+dy2+dy3+dy4+dy5;
            if (STBTT_fabs(dx) > STBTT_fabs(dy))
               dy6 = -dy;
            else
               dx6 = -dx;
            stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, dy3);
            stbtt__csctx_rccurve_to(c, dx4, dy4, dx5, dy5, dx6, dy6);
            break;

         default:
            return STBTT__CSERR("unimplemented");
         }
      } break;

      default:
         if (b0 != 255 && b0 != 28 && b0 < 32)
            return STBTT__CSERR("reserved operator");

         // push immediate
         if (b0 == 255) {
            f = (float)(stbtt_int32)stbtt__buf_get32(&b) / 0x10000;
         } else {
            stbtt__buf_skip(&b, -1);
            f = (float)(stbtt_int16)stbtt__cff_int(&b);
         }
         if (sp >= 48) return STBTT__CSERR("push stack overflow");
         s[sp++] = f;
         clear_stack = 0;
         break;
      }
      if (clear_stack) sp = 0;
   }
   return STBTT__CSERR("no endchar");

#undef STBTT__CSERR
}

static int stbtt__GetGlyphShapeT2(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)
{
   // runs the charstring twice, once to count and once to output (to avoid realloc)
   stbtt__csctx count_ctx = STBTT__CSCTX_INIT(1);
   stbtt__csctx output_ctx = STBTT__CSCTX_INIT(0);
   if (stbtt__run_charstring(info, glyph_index, &count_ctx)) {
      *pvertices = (stbtt_vertex*)STBTT_malloc(count_ctx.num_vertices*sizeof(stbtt_vertex), info->userdata);
      output_ctx.pvertices = *pvertices;
      if (stbtt__run_charstring(info, glyph_index, &output_ctx)) {
         STBTT_assert(output_ctx.num_vertices == count_ctx.num_vertices);
         return output_ctx.num_vertices;
      }
   }
   *pvertices = NULL;
   return 0;
}

static int stbtt__GetGlyphInfoT2(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1)
{
   stbtt__csctx c = STBTT__CSCTX_INIT(1);
   int r = stbtt__run_charstring(info, glyph_index, &c);
   if (x0)  *x0 = r ? c.min_x : 0;
   if (y0)  *y0 = r ? c.min_y : 0;
   if (x1)  *x1 = r ? c.max_x : 0;
   if (y1)  *y1 = r ? c.max_y : 0;
   return r ? c.num_vertices : 0;
}

STBTT_DEF int stbtt_GetGlyphShape(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)
{
   if (!info->cff.size)
      return stbtt__GetGlyphShapeTT(info, glyph_index, pvertices);
   else
      return stbtt__GetGlyphShapeT2(info, glyph_index, pvertices);
}

STBTT_DEF void stbtt_GetGlyphHMetrics(const stbtt_fontinfo *info, int glyph_index, int *advanceWidth, int *leftSideBearing)
{
   stbtt_uint16 numOfLongHorMetrics = ttUSHORT(info->data+info->hhea + 34);
   if (glyph_index < numOfLongHorMetrics) {
      if (advanceWidth)     *advanceWidth    = ttSHORT(info->data + info->hmtx + 4*glyph_index);
      if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4*glyph_index + 2);
   } else {
      if (advanceWidth)     *advanceWidth    = ttSHORT(info->data + info->hmtx + 4*(numOfLongHorMetrics-1));
      if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4*numOfLongHorMetrics + 2*(glyph_index - numOfLongHorMetrics));
   }
}

STBTT_DEF int  stbtt_GetKerningTableLength(const stbtt_fontinfo *info)
{
   stbtt_uint8 *data = info->data + info->kern;

   // we only look at the first table. it must be 'horizontal' and format 0.
   if (!info->kern)
      return 0;
   if (ttUSHORT(data+2) < 1) // number of tables, need at least 1
      return 0;
   if (ttUSHORT(data+8) != 1) // horizontal flag must be set in format
      return 0;

   return ttUSHORT(data+10);
}

STBTT_DEF int stbtt_GetKerningTable(const stbtt_fontinfo *info, stbtt_kerningentry* table, int table_length)
{
   stbtt_uint8 *data = info->data + info->kern;
   int k, length;

   // we only look at the first table. it must be 'horizontal' and format 0.
   if (!info->kern)
      return 0;
   if (ttUSHORT(data+2) < 1) // number of tables, need at least 1
      return 0;
   if (ttUSHORT(data+8) != 1) // horizontal flag must be set in format
      return 0;

   length = ttUSHORT(data+10);
   if (table_length < length)
      length = table_length;

   for (k = 0; k < length; k++)
   {
      table[k].glyph1 = ttUSHORT(data+18+(k*6));
      table[k].glyph2 = ttUSHORT(data+20+(k*6));
      table[k].advance = ttSHORT(data+22+(k*6));
   }

   return length;
}

static int stbtt__GetGlyphKernInfoAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2)
{
   stbtt_uint8 *data = info->data + info->kern;
   stbtt_uint32 needle, straw;
   int l, r, m;

   // we only look at the first table. it must be 'horizontal' and format 0.
   if (!info->kern)
      return 0;
   if (ttUSHORT(data+2) < 1) // number of tables, need at least 1
      return 0;
   if (ttUSHORT(data+8) != 1) // horizontal flag must be set in format
      return 0;

   l = 0;
   r = ttUSHORT(data+10) - 1;
   needle = glyph1 << 16 | glyph2;
   while (l <= r) {
      m = (l + r) >> 1;
      straw = ttULONG(data+18+(m*6)); // note: unaligned read
      if (needle < straw)
         r = m - 1;
      else if (needle > straw)
         l = m + 1;
      else
         return ttSHORT(data+22+(m*6));
   }
   return 0;
}

static stbtt_int32 stbtt__GetCoverageIndex(stbtt_uint8 *coverageTable, int glyph)
{
   stbtt_uint16 coverageFormat = ttUSHORT(coverageTable);
   switch (coverageFormat) {
      case 1: {
         stbtt_uint16 glyphCount = ttUSHORT(coverageTable + 2);

         // Binary search.
         stbtt_int32 l=0, r=glyphCount-1, m;
         int straw, needle=glyph;
         while (l <= r) {
            stbtt_uint8 *glyphArray = coverageTable + 4;
            stbtt_uint16 glyphID;
            m = (l + r) >> 1;
            glyphID = ttUSHORT(glyphArray + 2 * m);
            straw = glyphID;
            if (needle < straw)
               r = m - 1;
            else if (needle > straw)
               l = m + 1;
            else {
               return m;
            }
         }
         break;
      }

      case 2: {
         stbtt_uint16 rangeCount = ttUSHORT(coverageTable + 2);
         stbtt_uint8 *rangeArray = coverageTable + 4;

         // Binary search.
         stbtt_int32 l=0, r=rangeCount-1, m;
         int strawStart, strawEnd, needle=glyph;
         while (l <= r) {
            stbtt_uint8 *rangeRecord;
            m = (l + r) >> 1;
            rangeRecord = rangeArray + 6 * m;
            strawStart = ttUSHORT(rangeRecord);
            strawEnd = ttUSHORT(rangeRecord + 2);
            if (needle < strawStart)
               r = m - 1;
            else if (needle > strawEnd)
               l = m + 1;
            else {
               stbtt_uint16 startCoverageIndex = ttUSHORT(rangeRecord + 4);
               return startCoverageIndex + glyph - strawStart;
            }
         }
         break;
      }

      default: return -1; // unsupported
   }

   return -1;
}

static stbtt_int32  stbtt__GetGlyphClass(stbtt_uint8 *classDefTable, int glyph)
{
   stbtt_uint16 classDefFormat = ttUSHORT(classDefTable);
   switch (classDefFormat)
   {
      case 1: {
         stbtt_uint16 startGlyphID = ttUSHORT(classDefTable + 2);
         stbtt_uint16 glyphCount = ttUSHORT(classDefTable + 4);
         stbtt_uint8 *classDef1ValueArray = classDefTable + 6;

         if (glyph >= startGlyphID && glyph < startGlyphID + glyphCount)
            return (stbtt_int32)ttUSHORT(classDef1ValueArray + 2 * (glyph - startGlyphID));
         break;
      }

      case 2: {
         stbtt_uint16 classRangeCount = ttUSHORT(classDefTable + 2);
         stbtt_uint8 *classRangeRecords = classDefTable + 4;

         // Binary search.
         stbtt_int32 l=0, r=classRangeCount-1, m;
         int strawStart, strawEnd, needle=glyph;
         while (l <= r) {
            stbtt_uint8 *classRangeRecord;
            m = (l + r) >> 1;
            classRangeRecord = classRangeRecords + 6 * m;
            strawStart = ttUSHORT(classRangeRecord);
            strawEnd = ttUSHORT(classRangeRecord + 2);
            if (needle < strawStart)
               r = m - 1;
            else if (needle > strawEnd)
               l = m + 1;
            else
               return (stbtt_int32)ttUSHORT(classRangeRecord + 4);
         }
         break;
      }

      default:
         return -1; // Unsupported definition type, return an error.
   }

   // "All glyphs not assigned to a class fall into class 0". (OpenType spec)
   return 0;
}

// Define to STBTT_assert(x) if you want to break on unimplemented formats.
#define STBTT_GPOS_TODO_assert(x)

static stbtt_int32 stbtt__GetGlyphGPOSInfoAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2)
{
   stbtt_uint16 lookupListOffset;
   stbtt_uint8 *lookupList;
   stbtt_uint16 lookupCount;
   stbtt_uint8 *data;
   stbtt_int32 i, sti;

   if (!info->gpos) return 0;

   data = info->data + info->gpos;

   if (ttUSHORT(data+0) != 1) return 0; // Major version 1
   if (ttUSHORT(data+2) != 0) return 0; // Minor version 0

   lookupListOffset = ttUSHORT(data+8);
   lookupList = data + lookupListOffset;
   lookupCount = ttUSHORT(lookupList);

   for (i=0; i<lookupCount; ++i) {
      stbtt_uint16 lookupOffset = ttUSHORT(lookupList + 2 + 2 * i);
      stbtt_uint8 *lookupTable = lookupList + lookupOffset;

      stbtt_uint16 lookupType = ttUSHORT(lookupTable);
      stbtt_uint16 subTableCount = ttUSHORT(lookupTable + 4);
      stbtt_uint8 *subTableOffsets = lookupTable + 6;
      if (lookupType != 2) // Pair Adjustment Positioning Subtable
         continue;

      for (sti=0; sti<subTableCount; sti++) {
         stbtt_uint16 subtableOffset = ttUSHORT(subTableOffsets + 2 * sti);
         stbtt_uint8 *table = lookupTable + subtableOffset;
         stbtt_uint16 posFormat = ttUSHORT(table);
         stbtt_uint16 coverageOffset = ttUSHORT(table + 2);
         stbtt_int32 coverageIndex = stbtt__GetCoverageIndex(table + coverageOffset, glyph1);
         if (coverageIndex == -1) continue;

         switch (posFormat) {
            case 1: {
               stbtt_int32 l, r, m;
               int straw, needle;
               stbtt_uint16 valueFormat1 = ttUSHORT(table + 4);
               stbtt_uint16 valueFormat2 = ttUSHORT(table + 6);
               if (valueFormat1 == 4 && valueFormat2 == 0) { // Support more formats?
                  stbtt_int32 valueRecordPairSizeInBytes = 2;
                  stbtt_uint16 pairSetCount = ttUSHORT(table + 8);
                  stbtt_uint16 pairPosOffset = ttUSHORT(table + 10 + 2 * coverageIndex);
                  stbtt_uint8 *pairValueTable = table + pairPosOffset;
                  stbtt_uint16 pairValueCount = ttUSHORT(pairValueTable);
                  stbtt_uint8 *pairValueArray = pairValueTable + 2;

                  if (coverageIndex >= pairSetCount) return 0;

                  needle=glyph2;
                  r=pairValueCount-1;
                  l=0;

                  // Binary search.
                  while (l <= r) {
                     stbtt_uint16 secondGlyph;
                     stbtt_uint8 *pairValue;
                     m = (l + r) >> 1;
                     pairValue = pairValueArray + (2 + valueRecordPairSizeInBytes) * m;
                     secondGlyph = ttUSHORT(pairValue);
                     straw = secondGlyph;
                     if (needle < straw)
                        r = m - 1;
                     else if (needle > straw)
                        l = m + 1;
                     else {
                        stbtt_int16 xAdvance = ttSHORT(pairValue + 2);
                        return xAdvance;
                     }
                  }
               } else
                  return 0;
               break;
            }

            case 2: {
               stbtt_uint16 valueFormat1 = ttUSHORT(table + 4);
               stbtt_uint16 valueFormat2 = ttUSHORT(table + 6);
               if (valueFormat1 == 4 && valueFormat2 == 0) { // Support more formats?
                  stbtt_uint16 classDef1Offset = ttUSHORT(table + 8);
                  stbtt_uint16 classDef2Offset = ttUSHORT(table + 10);
                  int glyph1class = stbtt__GetGlyphClass(table + classDef1Offset, glyph1);
                  int glyph2class = stbtt__GetGlyphClass(table + classDef2Offset, glyph2);

                  stbtt_uint16 class1Count = ttUSHORT(table + 12);
                  stbtt_uint16 class2Count = ttUSHORT(table + 14);
                  stbtt_uint8 *class1Records, *class2Records;
                  stbtt_int16 xAdvance;

                  if (glyph1class < 0 || glyph1class >= class1Count) return 0; // malformed
                  if (glyph2class < 0 || glyph2class >= class2Count) return 0; // malformed

                  class1Records = table + 16;
                  class2Records = class1Records + 2 * (glyph1class * class2Count);
                  xAdvance = ttSHORT(class2Records + 2 * glyph2class);
                  return xAdvance;
               } else
                  return 0;
               break;
            }

            default:
               return 0; // Unsupported position format
         }
      }
   }

   return 0;
}

STBTT_DEF int  stbtt_GetGlyphKernAdvance(const stbtt_fontinfo *info, int g1, int g2)
{
   int xAdvance = 0;

   if (info->gpos)
      xAdvance += stbtt__GetGlyphGPOSInfoAdvance(info, g1, g2);
   else if (info->kern)
      xAdvance += stbtt__GetGlyphKernInfoAdvance(info, g1, g2);

   return xAdvance;
}

STBTT_DEF int  stbtt_GetCodepointKernAdvance(const stbtt_fontinfo *info, int ch1, int ch2)
{
   if (!info->kern && !info->gpos) // if no kerning table, don't waste time looking up both codepoint->glyphs
      return 0;
   return stbtt_GetGlyphKernAdvance(info, stbtt_FindGlyphIndex(info,ch1), stbtt_FindGlyphIndex(info,ch2));
}

STBTT_DEF void stbtt_GetCodepointHMetrics(const stbtt_fontinfo *info, int codepoint, int *advanceWidth, int *leftSideBearing)
{
   stbtt_GetGlyphHMetrics(info, stbtt_FindGlyphIndex(info,codepoint), advanceWidth, leftSideBearing);
}

STBTT_DEF void stbtt_GetFontVMetrics(const stbtt_fontinfo *info, int *ascent, int *descent, int *lineGap)
{
   if (ascent ) *ascent  = ttSHORT(info->data+info->hhea + 4);
   if (descent) *descent = ttSHORT(info->data+info->hhea + 6);
   if (lineGap) *lineGap = ttSHORT(info->data+info->hhea + 8);
}

STBTT_DEF int  stbtt_GetFontVMetricsOS2(const stbtt_fontinfo *info, int *typoAscent, int *typoDescent, int *typoLineGap)
{
   int tab = stbtt__find_table(info->data, info->fontstart, "OS/2");
   if (!tab)
      return 0;
   if (typoAscent ) *typoAscent  = ttSHORT(info->data+tab + 68);
   if (typoDescent) *typoDescent = ttSHORT(info->data+tab + 70);
   if (typoLineGap) *typoLineGap = ttSHORT(info->data+tab + 72);
   return 1;
}

STBTT_DEF void stbtt_GetFontBoundingBox(const stbtt_fontinfo *info, int *x0, int *y0, int *x1, int *y1)
{
   *x0 = ttSHORT(info->data + info->head + 36);
   *y0 = ttSHORT(info->data + info->head + 38);
   *x1 = ttSHORT(info->data + info->head + 40);
   *y1 = ttSHORT(info->data + info->head + 42);
}

STBTT_DEF float stbtt_ScaleForPixelHeight(const stbtt_fontinfo *info, float height)
{
   int fheight = ttSHORT(info->data + info->hhea + 4) - ttSHORT(info->data + info->hhea + 6);
   return (float) height / fheight;
}

STBTT_DEF float stbtt_ScaleForMappingEmToPixels(const stbtt_fontinfo *info, float pixels)
{
   int unitsPerEm = ttUSHORT(info->data + info->head + 18);
   return pixels / unitsPerEm;
}

STBTT_DEF void stbtt_FreeShape(const stbtt_fontinfo *info, stbtt_vertex *v)
{
   STBTT_free(v, info->userdata);
}

STBTT_DEF stbtt_uint8 *stbtt_FindSVGDoc(const stbtt_fontinfo *info, int gl)
{
   int i;
   stbtt_uint8 *data = info->data;
   stbtt_uint8 *svg_doc_list = data + stbtt__get_svg((stbtt_fontinfo *) info);

   int numEntries = ttUSHORT(svg_doc_list);
   stbtt_uint8 *svg_docs = svg_doc_list + 2;

   for(i=0; i<numEntries; i++) {
      stbtt_uint8 *svg_doc = svg_docs + (12 * i);
      if ((gl >= ttUSHORT(svg_doc)) && (gl <= ttUSHORT(svg_doc + 2)))
         return svg_doc;
   }
   return 0;
}

STBTT_DEF int stbtt_GetGlyphSVG(const stbtt_fontinfo *info, int gl, const char **svg)
{
   stbtt_uint8 *data = info->data;
   stbtt_uint8 *svg_doc;

   if (info->svg == 0)
      return 0;

   svg_doc = stbtt_FindSVGDoc(info, gl);
   if (svg_doc != NULL) {
      *svg = (char *) data + info->svg + ttULONG(svg_doc + 4);
      return ttULONG(svg_doc + 8);
   } else {
      return 0;
   }
}

STBTT_DEF int stbtt_GetCodepointSVG(const stbtt_fontinfo *info, int unicode_codepoint, const char **svg)
{
   return stbtt_GetGlyphSVG(info, stbtt_FindGlyphIndex(info, unicode_codepoint), svg);
}

//////////////////////////////////////////////////////////////////////////////
//
// antialiasing software rasterizer
//

STBTT_DEF void stbtt_GetGlyphBitmapBoxSubpixel(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y,float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)
{
   int x0=0,y0=0,x1,y1; // =0 suppresses compiler warning
   if (!stbtt_GetGlyphBox(font, glyph, &x0,&y0,&x1,&y1)) {
      // e.g. space character
      if (ix0) *ix0 = 0;
      if (iy0) *iy0 = 0;
      if (ix1) *ix1 = 0;
      if (iy1) *iy1 = 0;
   } else {
      // move to integral bboxes (treating pixels as little squares, what pixels get touched)?
      if (ix0) *ix0 = STBTT_ifloor( x0 * scale_x + shift_x);
      if (iy0) *iy0 = STBTT_ifloor(-y1 * scale_y + shift_y);
      if (ix1) *ix1 = STBTT_iceil ( x1 * scale_x + shift_x);
      if (iy1) *iy1 = STBTT_iceil (-y0 * scale_y + shift_y);
   }
}

STBTT_DEF void stbtt_GetGlyphBitmapBox(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)
{
   stbtt_GetGlyphBitmapBoxSubpixel(font, glyph, scale_x, scale_y,0.0f,0.0f, ix0, iy0, ix1, iy1);
}

STBTT_DEF void stbtt_GetCodepointBitmapBoxSubpixel(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)
{
   stbtt_GetGlyphBitmapBoxSubpixel(font, stbtt_FindGlyphIndex(font,codepoint), scale_x, scale_y,shift_x,shift_y, ix0,iy0,ix1,iy1);
}

STBTT_DEF void stbtt_GetCodepointBitmapBox(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)
{
   stbtt_GetCodepointBitmapBoxSubpixel(font, codepoint, scale_x, scale_y,0.0f,0.0f, ix0,iy0,ix1,iy1);
}

//////////////////////////////////////////////////////////////////////////////
//
//  Rasterizer

typedef struct stbtt__hheap_chunk
{
   struct stbtt__hheap_chunk *next;
} stbtt__hheap_chunk;

typedef struct stbtt__hheap
{
   struct stbtt__hheap_chunk *head;
   void   *first_free;
   int    num_remaining_in_head_chunk;
} stbtt__hheap;

static void *stbtt__hheap_alloc(stbtt__hheap *hh, size_t size, void *userdata)
{
   if (hh->first_free) {
      void *p = hh->first_free;
      hh->first_free = * (void **) p;
      return p;
   } else {
      if (hh->num_remaining_in_head_chunk == 0) {
         int count = (size < 32 ? 2000 : size < 128 ? 800 : 100);
         stbtt__hheap_chunk *c = (stbtt__hheap_chunk *) STBTT_malloc(sizeof(stbtt__hheap_chunk) + size * count, userdata);
         if (c == NULL)
            return NULL;
         c->next = hh->head;
         hh->head = c;
         hh->num_remaining_in_head_chunk = count;
      }
      --hh->num_remaining_in_head_chunk;
      return (char *) (hh->head) + sizeof(stbtt__hheap_chunk) + size * hh->num_remaining_in_head_chunk;
   }
}

static void stbtt__hheap_free(stbtt__hheap *hh, void *p)
{
   *(void **) p = hh->first_free;
   hh->first_free = p;
}

static void stbtt__hheap_cleanup(stbtt__hheap *hh, void *userdata)
{
   stbtt__hheap_chunk *c = hh->head;
   while (c) {
      stbtt__hheap_chunk *n = c->next;
      STBTT_free(c, userdata);
      c = n;
   }
}

typedef struct stbtt__edge {
   float x0,y0, x1,y1;
   int invert;
} stbtt__edge;


typedef struct stbtt__active_edge
{
   struct stbtt__active_edge *next;
   #if STBTT_RASTERIZER_VERSION==1
   int x,dx;
   float ey;
   int direction;
   #elif STBTT_RASTERIZER_VERSION==2
   float fx,fdx,fdy;
   float direction;
   float sy;
   float ey;
   #else
   #error "Unrecognized value of STBTT_RASTERIZER_VERSION"
   #endif
} stbtt__active_edge;

#if STBTT_RASTERIZER_VERSION == 1
#define STBTT_FIXSHIFT   10
#define STBTT_FIX        (1 << STBTT_FIXSHIFT)
#define STBTT_FIXMASK    (STBTT_FIX-1)

static stbtt__active_edge *stbtt__new_active(stbtt__hheap *hh, stbtt__edge *e, int off_x, float start_point, void *userdata)
{
   stbtt__active_edge *z = (stbtt__active_edge *) stbtt__hheap_alloc(hh, sizeof(*z), userdata);
   float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);
   STBTT_assert(z != NULL);
   if (!z) return z;

   // round dx down to avoid overshooting
   if (dxdy < 0)
      z->dx = -STBTT_ifloor(STBTT_FIX * -dxdy);
   else
      z->dx = STBTT_ifloor(STBTT_FIX * dxdy);

   z->x = STBTT_ifloor(STBTT_FIX * e->x0 + z->dx * (start_point - e->y0)); // use z->dx so when we offset later it's by the same amount
   z->x -= off_x * STBTT_FIX;

   z->ey = e->y1;
   z->next = 0;
   z->direction = e->invert ? 1 : -1;
   return z;
}
#elif STBTT_RASTERIZER_VERSION == 2
static stbtt__active_edge *stbtt__new_active(stbtt__hheap *hh, stbtt__edge *e, int off_x, float start_point, void *userdata)
{
   stbtt__active_edge *z = (stbtt__active_edge *) stbtt__hheap_alloc(hh, sizeof(*z), userdata);
   float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);
   STBTT_assert(z != NULL);
   //STBTT_assert(e->y0 <= start_point);
   if (!z) return z;
   z->fdx = dxdy;
   z->fdy = dxdy != 0.0f ? (1.0f/dxdy) : 0.0f;
   z->fx = e->x0 + dxdy * (start_point - e->y0);
   z->fx -= off_x;
   z->direction = e->invert ? 1.0f : -1.0f;
   z->sy = e->y0;
   z->ey = e->y1;
   z->next = 0;
   return z;
}
#else
#error "Unrecognized value of STBTT_RASTERIZER_VERSION"
#endif

#if STBTT_RASTERIZER_VERSION == 1
// note: this routine clips fills that extend off the edges... ideally this
// wouldn't happen, but it could happen if the truetype glyph bounding boxes
// are wrong, or if the user supplies a too-small bitmap
static void stbtt__fill_active_edges(unsigned char *scanline, int len, stbtt__active_edge *e, int max_weight)
{
   // non-zero winding fill
   int x0=0, w=0;

   while (e) {
      if (w == 0) {
         // if we're currently at zero, we need to record the edge start point
         x0 = e->x; w += e->direction;
      } else {
         int x1 = e->x; w += e->direction;
         // if we went to zero, we need to draw
         if (w == 0) {
            int i = x0 >> STBTT_FIXSHIFT;
            int j = x1 >> STBTT_FIXSHIFT;

            if (i < len && j >= 0) {
               if (i == j) {
                  // x0,x1 are the same pixel, so compute combined coverage
                  scanline[i] = scanline[i] + (stbtt_uint8) ((x1 - x0) * max_weight >> STBTT_FIXSHIFT);
               } else {
                  if (i >= 0) // add antialiasing for x0
                     scanline[i] = scanline[i] + (stbtt_uint8) (((STBTT_FIX - (x0 & STBTT_FIXMASK)) * max_weight) >> STBTT_FIXSHIFT);
                  else
                     i = -1; // clip

                  if (j < len) // add antialiasing for x1
                     scanline[j] = scanline[j] + (stbtt_uint8) (((x1 & STBTT_FIXMASK) * max_weight) >> STBTT_FIXSHIFT);
                  else
                     j = len; // clip

                  for (++i; i < j; ++i) // fill pixels between x0 and x1
                     scanline[i] = scanline[i] + (stbtt_uint8) max_weight;
               }
            }
         }
      }

      e = e->next;
   }
}

static void stbtt__rasterize_sorted_edges(stbtt__bitmap *result, stbtt__edge *e, int n, int vsubsample, int off_x, int off_y, void *userdata)
{
   stbtt__hheap hh = { 0, 0, 0 };
   stbtt__active_edge *active = NULL;
   int y,j=0;
   int max_weight = (255 / vsubsample);  // weight per vertical scanline
   int s; // vertical subsample index
   unsigned char scanline_data[512], *scanline;

   if (result->w > 512)
      scanline = (unsigned char *) STBTT_malloc(result->w, userdata);
   else
      scanline = scanline_data;

   y = off_y * vsubsample;
   e[n].y0 = (off_y + result->h) * (float) vsubsample + 1;

   while (j < result->h) {
      STBTT_memset(scanline, 0, result->w);
      for (s=0; s < vsubsample; ++s) {
         // find center of pixel for this scanline
         float scan_y = y + 0.5f;
         stbtt__active_edge **step = &active;

         // update all active edges;
         // remove all active edges that terminate before the center of this scanline
         while (*step) {
            stbtt__active_edge * z = *step;
            if (z->ey <= scan_y) {
               *step = z->next; // delete from list
               STBTT_assert(z->direction);
               z->direction = 0;
               stbtt__hheap_free(&hh, z);
            } else {
               z->x += z->dx; // advance to position for current scanline
               step = &((*step)->next); // advance through list
            }
         }

         // resort the list if needed
         for(;;) {
            int changed=0;
            step = &active;
            while (*step && (*step)->next) {
               if ((*step)->x > (*step)->next->x) {
                  stbtt__active_edge *t = *step;
                  stbtt__active_edge *q = t->next;

                  t->next = q->next;
                  q->next = t;
                  *step = q;
                  changed = 1;
               }
               step = &(*step)->next;
            }
            if (!changed) break;
         }

         // insert all edges that start before the center of this scanline -- omit ones that also end on this scanline
         while (e->y0 <= scan_y) {
            if (e->y1 > scan_y) {
               stbtt__active_edge *z = stbtt__new_active(&hh, e, off_x, scan_y, userdata);
               if (z != NULL) {
                  // find insertion point
                  if (active == NULL)
                     active = z;
                  else if (z->x < active->x) {
                     // insert at front
                     z->next = active;
                     active = z;
                  } else {
                     // find thing to insert AFTER
                     stbtt__active_edge *p = active;
                     while (p->next && p->next->x < z->x)
                        p = p->next;
                     // at this point, p->next->x is NOT < z->x
                     z->next = p->next;
                     p->next = z;
                  }
               }
            }
            ++e;
         }

         // now process all active edges in XOR fashion
         if (active)
            stbtt__fill_active_edges(scanline, result->w, active, max_weight);

         ++y;
      }
      STBTT_memcpy(result->pixels + j * result->stride, scanline, result->w);
      ++j;
   }

   stbtt__hheap_cleanup(&hh, userdata);

   if (scanline != scanline_data)
      STBTT_free(scanline, userdata);
}

#elif STBTT_RASTERIZER_VERSION == 2

// the edge passed in here does not cross the vertical line at x or the vertical line at x+1
// (i.e. it has already been clipped to those)
static void stbtt__handle_clipped_edge(float *scanline, int x, stbtt__active_edge *e, float x0, float y0, float x1, float y1)
{
   if (y0 == y1) return;
   STBTT_assert(y0 < y1);
   STBTT_assert(e->sy <= e->ey);
   if (y0 > e->ey) return;
   if (y1 < e->sy) return;
   if (y0 < e->sy) {
      x0 += (x1-x0) * (e->sy - y0) / (y1-y0);
      y0 = e->sy;
   }
   if (y1 > e->ey) {
      x1 += (x1-x0) * (e->ey - y1) / (y1-y0);
      y1 = e->ey;
   }

   if (x0 == x)
      STBTT_assert(x1 <= x+1);
   else if (x0 == x+1)
      STBTT_assert(x1 >= x);
   else if (x0 <= x)
      STBTT_assert(x1 <= x);
   else if (x0 >= x+1)
      STBTT_assert(x1 >= x+1);
   else
      STBTT_assert(x1 >= x && x1 <= x+1);

   if (x0 <= x && x1 <= x)
      scanline[x] += e->direction * (y1-y0);
   else if (x0 >= x+1 && x1 >= x+1)
      ;
   else {
      STBTT_assert(x0 >= x && x0 <= x+1 && x1 >= x && x1 <= x+1);
      scanline[x] += e->direction * (y1-y0) * (1-((x0-x)+(x1-x))/2); // coverage = 1 - average x position
   }
}

static float stbtt__sized_trapezoid_area(float height, float top_width, float bottom_width)
{
   STBTT_assert(top_width >= 0);
   STBTT_assert(bottom_width >= 0);
   return (top_width + bottom_width) / 2.0f * height;
}

static float stbtt__position_trapezoid_area(float height, float tx0, float tx1, float bx0, float bx1)
{
   return stbtt__sized_trapezoid_area(height, tx1 - tx0, bx1 - bx0);
}

static float stbtt__sized_triangle_area(float height, float width)
{
   return height * width / 2;
}

static void stbtt__fill_active_edges_new(float *scanline, float *scanline_fill, int len, stbtt__active_edge *e, float y_top)
{
   float y_bottom = y_top+1;

   while (e) {
      // brute force every pixel

      // compute intersection points with top & bottom
      STBTT_assert(e->ey >= y_top);

      if (e->fdx == 0) {
         float x0 = e->fx;
         if (x0 < len) {
            if (x0 >= 0) {
               stbtt__handle_clipped_edge(scanline,(int) x0,e, x0,y_top, x0,y_bottom);
               stbtt__handle_clipped_edge(scanline_fill-1,(int) x0+1,e, x0,y_top, x0,y_bottom);
            } else {
               stbtt__handle_clipped_edge(scanline_fill-1,0,e, x0,y_top, x0,y_bottom);
            }
         }
      } else {
         float x0 = e->fx;
         float dx = e->fdx;
         float xb = x0 + dx;
         float x_top, x_bottom;
         float sy0,sy1;
         float dy = e->fdy;
         STBTT_assert(e->sy <= y_bottom && e->ey >= y_top);

         // compute endpoints of line segment clipped to this scanline (if the
         // line segment starts on this scanline. x0 is the intersection of the
         // line with y_top, but that may be off the line segment.
         if (e->sy > y_top) {
            x_top = x0 + dx * (e->sy - y_top);
            sy0 = e->sy;
         } else {
            x_top = x0;
            sy0 = y_top;
         }
         if (e->ey < y_bottom) {
            x_bottom = x0 + dx * (e->ey - y_top);
            sy1 = e->ey;
         } else {
            x_bottom = xb;
            sy1 = y_bottom;
         }

         if (x_top >= 0 && x_bottom >= 0 && x_top < len && x_bottom < len) {
            // from here on, we don't have to range check x values

            if ((int) x_top == (int) x_bottom) {
               float height;
               // simple case, only spans one pixel
               int x = (int) x_top;
               height = (sy1 - sy0) * e->direction;
               STBTT_assert(x >= 0 && x < len);
               scanline[x]      += stbtt__position_trapezoid_area(height, x_top, x+1.0f, x_bottom, x+1.0f);
               scanline_fill[x] += height; // everything right of this pixel is filled
            } else {
               int x,x1,x2;
               float y_crossing, y_final, step, sign, area;
               // covers 2+ pixels
               if (x_top > x_bottom) {
                  // flip scanline vertically; signed area is the same
                  float t;
                  sy0 = y_bottom - (sy0 - y_top);
                  sy1 = y_bottom - (sy1 - y_top);
                  t = sy0, sy0 = sy1, sy1 = t;
                  t = x_bottom, x_bottom = x_top, x_top = t;
                  dx = -dx;
                  dy = -dy;
                  t = x0, x0 = xb, xb = t;
               }
               STBTT_assert(dy >= 0);
               STBTT_assert(dx >= 0);

               x1 = (int) x_top;
               x2 = (int) x_bottom;
               // compute intersection with y axis at x1+1
               y_crossing = y_top + dy * (x1+1 - x0);

               // compute intersection with y axis at x2
               y_final = y_top + dy * (x2 - x0);

               //           x1    x_top                            x2    x_bottom
               //     y_top  +------|-----+------------+------------+--------|---+------------+
               //            |            |            |            |            |            |
               //            |            |            |            |            |            |
               //       sy0  |      Txxxxx|............|............|............|............|
               // y_crossing |            *xxxxx.......|............|............|............|
               //            |            |     xxxxx..|............|............|............|
               //            |            |     /-   xx*xxxx........|............|............|
               //            |            | dy <       |    xxxxxx..|............|............|
               //   y_final  |            |     \-     |          xx*xxx.........|............|
               //       sy1  |            |            |            |   xxxxxB...|............|
               //            |            |            |            |            |            |
               //            |            |            |            |            |            |
               //  y_bottom  +------------+------------+------------+------------+------------+
               //
               // goal is to measure the area covered by '.' in each pixel

               // if x2 is right at the right edge of x1, y_crossing can blow up, github #1057
               // @TODO: maybe test against sy1 rather than y_bottom?
               if (y_crossing > y_bottom)
                  y_crossing = y_bottom;

               sign = e->direction;

               // area of the rectangle covered from sy0..y_crossing
               area = sign * (y_crossing-sy0);

               // area of the triangle (x_top,sy0), (x1+1,sy0), (x1+1,y_crossing)
               scanline[x1] += stbtt__sized_triangle_area(area, x1+1 - x_top);

               // check if final y_crossing is blown up; no test case for this
               if (y_final > y_bottom) {
                  int denom = (x2 - (x1+1));
                  y_final = y_bottom;
                  if (denom != 0) { // [DEAR IMGUI] Avoid div by zero (https://github.com/nothings/stb/issues/1316)
                     dy = (y_final - y_crossing ) / denom; // if denom=0, y_final = y_crossing, so y_final <= y_bottom
                  }
               }

               // in second pixel, area covered by line segment found in first pixel
               // is always a rectangle 1 wide * the height of that line segment; this
               // is exactly what the variable 'area' stores. it also gets a contribution
               // from the line segment within it. the THIRD pixel will get the first
               // pixel's rectangle contribution, the second pixel's rectangle contribution,
               // and its own contribution. the 'own contribution' is the same in every pixel except
               // the leftmost and rightmost, a trapezoid that slides down in each pixel.
               // the second pixel's contribution to the third pixel will be the
               // rectangle 1 wide times the height change in the second pixel, which is dy.

               step = sign * dy * 1; // dy is dy/dx, change in y for every 1 change in x,
               // which multiplied by 1-pixel-width is how much pixel area changes for each step in x
               // so the area advances by 'step' every time

               for (x = x1+1; x < x2; ++x) {
                  scanline[x] += area + step/2; // area of trapezoid is 1*step/2
                  area += step;
               }
               STBTT_assert(STBTT_fabs(area) <= 1.01f); // accumulated error from area += step unless we round step down
               STBTT_assert(sy1 > y_final-0.01f);

               // area covered in the last pixel is the rectangle from all the pixels to the left,
               // plus the trapezoid filled by the line segment in this pixel all the way to the right edge
               scanline[x2] += area + sign * stbtt__position_trapezoid_area(sy1-y_final, (float) x2, x2+1.0f, x_bottom, x2+1.0f);

               // the rest of the line is filled based on the total height of the line segment in this pixel
               scanline_fill[x2] += sign * (sy1-sy0);
            }
         } else {
            // if edge goes outside of box we're drawing, we require
            // clipping logic. since this does not match the intended use
            // of this library, we use a different, very slow brute
            // force implementation
            // note though that this does happen some of the time because
            // x_top and x_bottom can be extrapolated at the top & bottom of
            // the shape and actually lie outside the bounding box
            int x;
            for (x=0; x < len; ++x) {
               // cases:
               //
               // there can be up to two intersections with the pixel. any intersection
               // with left or right edges can be handled by splitting into two (or three)
               // regions. intersections with top & bottom do not necessitate case-wise logic.
               //
               // the old way of doing this found the intersections with the left & right edges,
               // then used some simple logic to produce up to three segments in sorted order
               // from top-to-bottom. however, this had a problem: if an x edge was epsilon
               // across the x border, then the corresponding y position might not be distinct
               // from the other y segment, and it might ignored as an empty segment. to avoid
               // that, we need to explicitly produce segments based on x positions.

               // rename variables to clearly-defined pairs
               float y0 = y_top;
               float x1 = (float) (x);
               float x2 = (float) (x+1);
               float x3 = xb;
               float y3 = y_bottom;

               // x = e->x + e->dx * (y-y_top)
               // (y-y_top) = (x - e->x) / e->dx
               // y = (x - e->x) / e->dx + y_top
               float y1 = (x - x0) / dx + y_top;
               float y2 = (x+1 - x0) / dx + y_top;

               if (x0 < x1 && x3 > x2) {         // three segments descending down-right
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);
                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x2,y2);
                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);
               } else if (x3 < x1 && x0 > x2) {  // three segments descending down-left
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);
                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x1,y1);
                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);
               } else if (x0 < x1 && x3 > x1) {  // two segments across x, down-right
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);
                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);
               } else if (x3 < x1 && x0 > x1) {  // two segments across x, down-left
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);
                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);
               } else if (x0 < x2 && x3 > x2) {  // two segments across x+1, down-right
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);
                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);
               } else if (x3 < x2 && x0 > x2) {  // two segments across x+1, down-left
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);
                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);
               } else {  // one segment
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x3,y3);
               }
            }
         }
      }
      e = e->next;
   }
}

// directly AA rasterize edges w/o supersampling
static void stbtt__rasterize_sorted_edges(stbtt__bitmap *result, stbtt__edge *e, int n, int vsubsample, int off_x, int off_y, void *userdata)
{
   stbtt__hheap hh = { 0, 0, 0 };
   stbtt__active_edge *active = NULL;
   int y,j=0, i;
   float scanline_data[129], *scanline, *scanline2;

   STBTT__NOTUSED(vsubsample);

   if (result->w > 64)
      scanline = (float *) STBTT_malloc((result->w*2+1) * sizeof(float), userdata);
   else
      scanline = scanline_data;

   scanline2 = scanline + result->w;

   y = off_y;
   e[n].y0 = (float) (off_y + result->h) + 1;

   while (j < result->h) {
      // find center of pixel for this scanline
      float scan_y_top    = y + 0.0f;
      float scan_y_bottom = y + 1.0f;
      stbtt__active_edge **step = &active;

      STBTT_memset(scanline , 0, result->w*sizeof(scanline[0]));
      STBTT_memset(scanline2, 0, (result->w+1)*sizeof(scanline[0]));

      // update all active edges;
      // remove all active edges that terminate before the top of this scanline
      while (*step) {
         stbtt__active_edge * z = *step;
         if (z->ey <= scan_y_top) {
            *step = z->next; // delete from list
            STBTT_assert(z->direction);
            z->direction = 0;
            stbtt__hheap_free(&hh, z);
         } else {
            step = &((*step)->next); // advance through list
         }
      }

      // insert all edges that start before the bottom of this scanline
      while (e->y0 <= scan_y_bottom) {
         if (e->y0 != e->y1) {
            stbtt__active_edge *z = stbtt__new_active(&hh, e, off_x, scan_y_top, userdata);
            if (z != NULL) {
               if (j == 0 && off_y != 0) {
                  if (z->ey < scan_y_top) {
                     // this can happen due to subpixel positioning and some kind of fp rounding error i think
                     z->ey = scan_y_top;
                  }
               }
               STBTT_assert(z->ey >= scan_y_top); // if we get really unlucky a tiny bit of an edge can be out of bounds
               // insert at front
               z->next = active;
               active = z;
            }
         }
         ++e;
      }

      // now process all active edges
      if (active)
         stbtt__fill_active_edges_new(scanline, scanline2+1, result->w, active, scan_y_top);

      {
         float sum = 0;
         for (i=0; i < result->w; ++i) {
            float k;
            int m;
            sum += scanline2[i];
            k = scanline[i] + sum;
            k = (float) STBTT_fabs(k)*255 + 0.5f;
            m = (int) k;
            if (m > 255) m = 255;
            result->pixels[j*result->stride + i] = (unsigned char) m;
         }
      }
      // advance all the edges
      step = &active;
      while (*step) {
         stbtt__active_edge *z = *step;
         z->fx += z->fdx; // advance to position for current scanline
         step = &((*step)->next); // advance through list
      }

      ++y;
      ++j;
   }

   stbtt__hheap_cleanup(&hh, userdata);

   if (scanline != scanline_data)
      STBTT_free(scanline, userdata);
}
#else
#error "Unrecognized value of STBTT_RASTERIZER_VERSION"
#endif

#define STBTT__COMPARE(a,b)  ((a)->y0 < (b)->y0)

static void stbtt__sort_edges_ins_sort(stbtt__edge *p, int n)
{
   int i,j;
   for (i=1; i < n; ++i) {
      stbtt__edge t = p[i], *a = &t;
      j = i;
      while (j > 0) {
         stbtt__edge *b = &p[j-1];
         int c = STBTT__COMPARE(a,b);
         if (!c) break;
         p[j] = p[j-1];
         --j;
      }
      if (i != j)
         p[j] = t;
   }
}

static void stbtt__sort_edges_quicksort(stbtt__edge *p, int n)
{
   /* threshold for transitioning to insertion sort */
   while (n > 12) {
      stbtt__edge t;
      int c01,c12,c,m,i,j;

      /* compute median of three */
      m = n >> 1;
      c01 = STBTT__COMPARE(&p[0],&p[m]);
      c12 = STBTT__COMPARE(&p[m],&p[n-1]);
      /* if 0 >= mid >= end, or 0 < mid < end, then use mid */
      if (c01 != c12) {
         /* otherwise, we'll need to swap something else to middle */
         int z;
         c = STBTT__COMPARE(&p[0],&p[n-1]);
         /* 0>mid && mid<n:  0>n => n; 0<n => 0 */
         /* 0<mid && mid>n:  0>n => 0; 0<n => n */
         z = (c == c12) ? 0 : n-1;
         t = p[z];
         p[z] = p[m];
         p[m] = t;
      }
      /* now p[m] is the median-of-three */
      /* swap it to the beginning so it won't move around */
      t = p[0];
      p[0] = p[m];
      p[m] = t;

      /* partition loop */
      i=1;
      j=n-1;
      for(;;) {
         /* handling of equality is crucial here */
         /* for sentinels & efficiency with duplicates */
         for (;;++i) {
            if (!STBTT__COMPARE(&p[i], &p[0])) break;
         }
         for (;;--j) {
            if (!STBTT__COMPARE(&p[0], &p[j])) break;
         }
         /* make sure we haven't crossed */
         if (i >= j) break;
         t = p[i];
         p[i] = p[j];
         p[j] = t;

         ++i;
         --j;
      }
      /* recurse on smaller side, iterate on larger */
      if (j < (n-i)) {
         stbtt__sort_edges_quicksort(p,j);
         p = p+i;
         n = n-i;
      } else {
         stbtt__sort_edges_quicksort(p+i, n-i);
         n = j;
      }
   }
}

static void stbtt__sort_edges(stbtt__edge *p, int n)
{
   stbtt__sort_edges_quicksort(p, n);
   stbtt__sort_edges_ins_sort(p, n);
}

typedef struct
{
   float x,y;
} stbtt__point;

static void stbtt__rasterize(stbtt__bitmap *result, stbtt__point *pts, int *wcount, int windings, float scale_x, float scale_y, float shift_x, float shift_y, int off_x, int off_y, int invert, void *userdata)
{
   float y_scale_inv = invert ? -scale_y : scale_y;
   stbtt__edge *e;
   int n,i,j,k,m;
#if STBTT_RASTERIZER_VERSION == 1
   int vsubsample = result->h < 8 ? 15 : 5;
#elif STBTT_RASTERIZER_VERSION == 2
   int vsubsample = 1;
#else
   #error "Unrecognized value of STBTT_RASTERIZER_VERSION"
#endif
   // vsubsample should divide 255 evenly; otherwise we won't reach full opacity

   // now we have to blow out the windings into explicit edge lists
   n = 0;
   for (i=0; i < windings; ++i)
      n += wcount[i];

   e = (stbtt__edge *) STBTT_malloc(sizeof(*e) * (n+1), userdata); // add an extra one as a sentinel
   if (e == 0) return;
   n = 0;

   m=0;
   for (i=0; i < windings; ++i) {
      stbtt__point *p = pts + m;
      m += wcount[i];
      j = wcount[i]-1;
      for (k=0; k < wcount[i]; j=k++) {
         int a=k,b=j;
         // skip the edge if horizontal
         if (p[j].y == p[k].y)
            continue;
         // add edge from j to k to the list
         e[n].invert = 0;
         if (invert ? p[j].y > p[k].y : p[j].y < p[k].y) {
            e[n].invert = 1;
            a=j,b=k;
         }
         e[n].x0 = p[a].x * scale_x + shift_x;
         e[n].y0 = (p[a].y * y_scale_inv + shift_y) * vsubsample;
         e[n].x1 = p[b].x * scale_x + shift_x;
         e[n].y1 = (p[b].y * y_scale_inv + shift_y) * vsubsample;
         ++n;
      }
   }

   // now sort the edges by their highest point (should snap to integer, and then by x)
   //STBTT_sort(e, n, sizeof(e[0]), stbtt__edge_compare);
   stbtt__sort_edges(e, n);

   // now, traverse the scanlines and find the intersections on each scanline, use xor winding rule
   stbtt__rasterize_sorted_edges(result, e, n, vsubsample, off_x, off_y, userdata);

   STBTT_free(e, userdata);
}

static void stbtt__add_point(stbtt__point *points, int n, float x, float y)
{
   if (!points) return; // during first pass, it's unallocated
   points[n].x = x;
   points[n].y = y;
}

// tessellate until threshold p is happy... @TODO warped to compensate for non-linear stretching
static int stbtt__tesselate_curve(stbtt__point *points, int *num_points, float x0, float y0, float x1, float y1, float x2, float y2, float objspace_flatness_squared, int n)
{
   // midpoint
   float mx = (x0 + 2*x1 + x2)/4;
   float my = (y0 + 2*y1 + y2)/4;
   // versus directly drawn line
   float dx = (x0+x2)/2 - mx;
   float dy = (y0+y2)/2 - my;
   if (n > 16) // 65536 segments on one curve better be enough!
      return 1;
   if (dx*dx+dy*dy > objspace_flatness_squared) { // half-pixel error allowed... need to be smaller if AA
      stbtt__tesselate_curve(points, num_points, x0,y0, (x0+x1)/2.0f,(y0+y1)/2.0f, mx,my, objspace_flatness_squared,n+1);
      stbtt__tesselate_curve(points, num_points, mx,my, (x1+x2)/2.0f,(y1+y2)/2.0f, x2,y2, objspace_flatness_squared,n+1);
   } else {
      stbtt__add_point(points, *num_points,x2,y2);
      *num_points = *num_points+1;
   }
   return 1;
}

static void stbtt__tesselate_cubic(stbtt__point *points, int *num_points, float x0, float y0, float x1, float y1, float x2, float y2, float x3, float y3, float objspace_flatness_squared, int n)
{
   // @TODO this "flatness" calculation is just made-up nonsense that seems to work well enough
   float dx0 = x1-x0;
   float dy0 = y1-y0;
   float dx1 = x2-x1;
   float dy1 = y2-y1;
   float dx2 = x3-x2;
   float dy2 = y3-y2;
   float dx = x3-x0;
   float dy = y3-y0;
   float longlen = (float) (STBTT_sqrt(dx0*dx0+dy0*dy0)+STBTT_sqrt(dx1*dx1+dy1*dy1)+STBTT_sqrt(dx2*dx2+dy2*dy2));
   float shortlen = (float) STBTT_sqrt(dx*dx+dy*dy);
   float flatness_squared = longlen*longlen-shortlen*shortlen;

   if (n > 16) // 65536 segments on one curve better be enough!
      return;

   if (flatness_squared > objspace_flatness_squared) {
      float x01 = (x0+x1)/2;
      float y01 = (y0+y1)/2;
      float x12 = (x1+x2)/2;
      float y12 = (y1+y2)/2;
      float x23 = (x2+x3)/2;
      float y23 = (y2+y3)/2;

      float xa = (x01+x12)/2;
      float ya = (y01+y12)/2;
      float xb = (x12+x23)/2;
      float yb = (y12+y23)/2;

      float mx = (xa+xb)/2;
      float my = (ya+yb)/2;

      stbtt__tesselate_cubic(points, num_points, x0,y0, x01,y01, xa,ya, mx,my, objspace_flatness_squared,n+1);
      stbtt__tesselate_cubic(points, num_points, mx,my, xb,yb, x23,y23, x3,y3, objspace_flatness_squared,n+1);
   } else {
      stbtt__add_point(points, *num_points,x3,y3);
      *num_points = *num_points+1;
   }
}

// returns number of contours
static stbtt__point *stbtt_FlattenCurves(stbtt_vertex *vertices, int num_verts, float objspace_flatness, int **contour_lengths, int *num_contours, void *userdata)
{
   stbtt__point *points=0;
   int num_points=0;

   float objspace_flatness_squared = objspace_flatness * objspace_flatness;
   int i,n=0,start=0, pass;

   // count how many "moves" there are to get the contour count
   for (i=0; i < num_verts; ++i)
      if (vertices[i].type == STBTT_vmove)
         ++n;

   *num_contours = n;
   if (n == 0) return 0;

   *contour_lengths = (int *) STBTT_malloc(sizeof(**contour_lengths) * n, userdata);

   if (*contour_lengths == 0) {
      *num_contours = 0;
      return 0;
   }

   // make two passes through the points so we don't need to realloc
   for (pass=0; pass < 2; ++pass) {
      float x=0,y=0;
      if (pass == 1) {
         points = (stbtt__point *) STBTT_malloc(num_points * sizeof(points[0]), userdata);
         if (points == NULL) goto error;
      }
      num_points = 0;
      n= -1;
      for (i=0; i < num_verts; ++i) {
         switch (vertices[i].type) {
            case STBTT_vmove:
               // start the next contour
               if (n >= 0)
                  (*contour_lengths)[n] = num_points - start;
               ++n;
               start = num_points;

               x = vertices[i].x, y = vertices[i].y;
               stbtt__add_point(points, num_points++, x,y);
               break;
            case STBTT_vline:
               x = vertices[i].x, y = vertices[i].y;
               stbtt__add_point(points, num_points++, x, y);
               break;
            case STBTT_vcurve:
               stbtt__tesselate_curve(points, &num_points, x,y,
                                        vertices[i].cx, vertices[i].cy,
                                        vertices[i].x,  vertices[i].y,
                                        objspace_flatness_squared, 0);
               x = vertices[i].x, y = vertices[i].y;
               break;
            case STBTT_vcubic:
               stbtt__tesselate_cubic(points, &num_points, x,y,
                                        vertices[i].cx, vertices[i].cy,
                                        vertices[i].cx1, vertices[i].cy1,
                                        vertices[i].x,  vertices[i].y,
                                        objspace_flatness_squared, 0);
               x = vertices[i].x, y = vertices[i].y;
               break;
         }
      }
      (*contour_lengths)[n] = num_points - start;
   }

   return points;
error:
   STBTT_free(points, userdata);
   STBTT_free(*contour_lengths, userdata);
   *contour_lengths = 0;
   *num_contours = 0;
   return NULL;
}

STBTT_DEF void stbtt_Rasterize(stbtt__bitmap *result, float flatness_in_pixels, stbtt_vertex *vertices, int num_verts, float scale_x, float scale_y, float shift_x, float shift_y, int x_off, int y_off, int invert, void *userdata)
{
   float scale            = scale_x > scale_y ? scale_y : scale_x;
   int winding_count      = 0;
   int *winding_lengths   = NULL;
   stbtt__point *windings = stbtt_FlattenCurves(vertices, num_verts, flatness_in_pixels / scale, &winding_lengths, &winding_count, userdata);
   if (windings) {
      stbtt__rasterize(result, windings, winding_lengths, winding_count, scale_x, scale_y, shift_x, shift_y, x_off, y_off, invert, userdata);
      STBTT_free(winding_lengths, userdata);
      STBTT_free(windings, userdata);
   }
}

STBTT_DEF void stbtt_FreeBitmap(unsigned char *bitmap, void *userdata)
{
   STBTT_free(bitmap, userdata);
}

STBTT_DEF unsigned char *stbtt_GetGlyphBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int glyph, int *width, int *height, int *xoff, int *yoff)
{
   int ix0,iy0,ix1,iy1;
   stbtt__bitmap gbm;
   stbtt_vertex *vertices;
   int num_verts = stbtt_GetGlyphShape(info, glyph, &vertices);

   if (scale_x == 0) scale_x = scale_y;
   if (scale_y == 0) {
      if (scale_x == 0) {
         STBTT_free(vertices, info->userdata);
         return NULL;
      }
      scale_y = scale_x;
   }

   stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale_x, scale_y, shift_x, shift_y, &ix0,&iy0,&ix1,&iy1);

   // now we get the size
   gbm.w = (ix1 - ix0);
   gbm.h = (iy1 - iy0);
   gbm.pixels = NULL; // in case we error

   if (width ) *width  = gbm.w;
   if (height) *height = gbm.h;
   if (xoff  ) *xoff   = ix0;
   if (yoff  ) *yoff   = iy0;

   if (gbm.w && gbm.h) {
      gbm.pixels = (unsigned char *) STBTT_malloc(gbm.w * gbm.h, info->userdata);
      if (gbm.pixels) {
         gbm.stride = gbm.w;

         stbtt_Rasterize(&gbm, 0.35f, vertices, num_verts, scale_x, scale_y, shift_x, shift_y, ix0, iy0, 1, info->userdata);
      }
   }
   STBTT_free(vertices, info->userdata);
   return gbm.pixels;
}

STBTT_DEF unsigned char *stbtt_GetGlyphBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int glyph, int *width, int *height, int *xoff, int *yoff)
{
   return stbtt_GetGlyphBitmapSubpixel(info, scale_x, scale_y, 0.0f, 0.0f, glyph, width, height, xoff, yoff);
}

STBTT_DEF void stbtt_MakeGlyphBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int glyph)
{
   int ix0,iy0;
   stbtt_vertex *vertices;
   int num_verts = stbtt_GetGlyphShape(info, glyph, &vertices);
   stbtt__bitmap gbm;

   stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale_x, scale_y, shift_x, shift_y, &ix0,&iy0,0,0);
   gbm.pixels = output;
   gbm.w = out_w;
   gbm.h = out_h;
   gbm.stride = out_stride;

   if (gbm.w && gbm.h)
      stbtt_Rasterize(&gbm, 0.35f, vertices, num_verts, scale_x, scale_y, shift_x, shift_y, ix0,iy0, 1, info->userdata);

   STBTT_free(vertices, info->userdata);
}

STBTT_DEF void stbtt_MakeGlyphBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int glyph)
{
   stbtt_MakeGlyphBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, 0.0f,0.0f, glyph);
}

STBTT_DEF unsigned char *stbtt_GetCodepointBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint, int *width, int *height, int *xoff, int *yoff)
{
   return stbtt_GetGlyphBitmapSubpixel(info, scale_x, scale_y,shift_x,shift_y, stbtt_FindGlyphIndex(info,codepoint), width,height,xoff,yoff);
}

STBTT_DEF void stbtt_MakeCodepointBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int oversample_x, int oversample_y, float *sub_x, float *sub_y, int codepoint)
{
   stbtt_MakeGlyphBitmapSubpixelPrefilter(info, output, out_w, out_h, out_stride, scale_x, scale_y, shift_x, shift_y, oversample_x, oversample_y, sub_x, sub_y, stbtt_FindGlyphIndex(info,codepoint));
}

STBTT_DEF void stbtt_MakeCodepointBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint)
{
   stbtt_MakeGlyphBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, shift_x, shift_y, stbtt_FindGlyphIndex(info,codepoint));
}

STBTT_DEF unsigned char *stbtt_GetCodepointBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int codepoint, int *width, int *height, int *xoff, int *yoff)
{
   return stbtt_GetCodepointBitmapSubpixel(info, scale_x, scale_y, 0.0f,0.0f, codepoint, width,height,xoff,yoff);
}

STBTT_DEF void stbtt_MakeCodepointBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int codepoint)
{
   stbtt_MakeCodepointBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, 0.0f,0.0f, codepoint);
}

//////////////////////////////////////////////////////////////////////////////
//
// bitmap baking
//
// This is SUPER-CRAPPY packing to keep source code small

static int stbtt_BakeFontBitmap_internal(unsigned char *data, int offset,  // font location (use offset=0 for plain .ttf)
                                float pixel_height,                     // height of font in pixels
                                unsigned char *pixels, int pw, int ph,  // bitmap to be filled in
                                int first_char, int num_chars,          // characters to bake
                                stbtt_bakedchar *chardata)
{
   float scale;
   int x,y,bottom_y, i;
   stbtt_fontinfo f;
   f.userdata = NULL;
   if (!stbtt_InitFont(&f, data, offset))
      return -1;
   STBTT_memset(pixels, 0, pw*ph); // background of 0 around pixels
   x=y=1;
   bottom_y = 1;

   scale = stbtt_ScaleForPixelHeight(&f, pixel_height);

   for (i=0; i < num_chars; ++i) {
      int advance, lsb, x0,y0,x1,y1,gw,gh;
      int g = stbtt_FindGlyphIndex(&f, first_char + i);
      stbtt_GetGlyphHMetrics(&f, g, &advance, &lsb);
      stbtt_GetGlyphBitmapBox(&f, g, scale,scale, &x0,&y0,&x1,&y1);
      gw = x1-x0;
      gh = y1-y0;
      if (x + gw + 1 >= pw)
         y = bottom_y, x = 1; // advance to next row
      if (y + gh + 1 >= ph) // check if it fits vertically AFTER potentially moving to next row
         return -i;
      STBTT_assert(x+gw < pw);
      STBTT_assert(y+gh < ph);
      stbtt_MakeGlyphBitmap(&f, pixels+x+y*pw, gw,gh,pw, scale,scale, g);
      chardata[i].x0 = (stbtt_int16) x;
      chardata[i].y0 = (stbtt_int16) y;
      chardata[i].x1 = (stbtt_int16) (x + gw);
      chardata[i].y1 = (stbtt_int16) (y + gh);
      chardata[i].xadvance = scale * advance;
      chardata[i].xoff     = (float) x0;
      chardata[i].yoff     = (float) y0;
      x = x + gw + 1;
      if (y+gh+1 > bottom_y)
         bottom_y = y+gh+1;
   }
   return bottom_y;
}

STBTT_DEF void stbtt_GetBakedQuad(const stbtt_bakedchar *chardata, int pw, int ph, int char_index, float *xpos, float *ypos, stbtt_aligned_quad *q, int opengl_fillrule)
{
   float d3d_bias = opengl_fillrule ? 0 : -0.5f;
   float ipw = 1.0f / pw, iph = 1.0f / ph;
   const stbtt_bakedchar *b = chardata + char_index;
   int round_x = STBTT_ifloor((*xpos + b->xoff) + 0.5f);
   int round_y = STBTT_ifloor((*ypos + b->yoff) + 0.5f);

   q->x0 = round_x + d3d_bias;
   q->y0 = round_y + d3d_bias;
   q->x1 = round_x + b->x1 - b->x0 + d3d_bias;
   q->y1 = round_y + b->y1 - b->y0 + d3d_bias;

   q->s0 = b->x0 * ipw;
   q->t0 = b->y0 * iph;
   q->s1 = b->x1 * ipw;
   q->t1 = b->y1 * iph;

   *xpos += b->xadvance;
}

//////////////////////////////////////////////////////////////////////////////
//
// rectangle packing replacement routines if you don't have stb_rect_pack.h
//

#ifndef STB_RECT_PACK_VERSION

typedef int stbrp_coord;

////////////////////////////////////////////////////////////////////////////////////
//                                                                                //
//                                                                                //
// COMPILER WARNING ?!?!?                                                         //
//                                                                                //
//                                                                                //
// if you get a compile warning due to these symbols being defined more than      //
// once, move #include "stb_rect_pack.h" before #include "stb_truetype.h"         //
//                                                                                //
////////////////////////////////////////////////////////////////////////////////////

typedef struct
{
   int width,height;
   int x,y,bottom_y;
} stbrp_context;

typedef struct
{
   unsigned char x;
} stbrp_node;

struct stbrp_rect
{
   stbrp_coord x,y;
   int id,w,h,was_packed;
};

static void stbrp_init_target(stbrp_context *con, int pw, int ph, stbrp_node *nodes, int num_nodes)
{
   con->width  = pw;
   con->height = ph;
   con->x = 0;
   con->y = 0;
   con->bottom_y = 0;
   STBTT__NOTUSED(nodes);
   STBTT__NOTUSED(num_nodes);
}

static void stbrp_pack_rects(stbrp_context *con, stbrp_rect *rects, int num_rects)
{
   int i;
   for (i=0; i < num_rects; ++i) {
      if (con->x + rects[i].w > con->width) {
         con->x = 0;
         con->y = con->bottom_y;
      }
      if (con->y + rects[i].h > con->height)
         break;
      rects[i].x = con->x;
      rects[i].y = con->y;
      rects[i].was_packed = 1;
      con->x += rects[i].w;
      if (con->y + rects[i].h > con->bottom_y)
         con->bottom_y = con->y + rects[i].h;
   }
   for (   ; i < num_rects; ++i)
      rects[i].was_packed = 0;
}
#endif

//////////////////////////////////////////////////////////////////////////////
//
// bitmap baking
//
// This is SUPER-AWESOME (tm Ryan Gordon) packing using stb_rect_pack.h. If
// stb_rect_pack.h isn't available, it uses the BakeFontBitmap strategy.

STBTT_DEF int stbtt_PackBegin(stbtt_pack_context *spc, unsigned char *pixels, int pw, int ph, int stride_in_bytes, int padding, void *alloc_context)
{
   stbrp_context *context = (stbrp_context *) STBTT_malloc(sizeof(*context)            ,alloc_context);
   int            num_nodes = pw - padding;
   stbrp_node    *nodes   = (stbrp_node    *) STBTT_malloc(sizeof(*nodes  ) * num_nodes,alloc_context);

   if (context == NULL || nodes == NULL) {
      if (context != NULL) STBTT_free(context, alloc_context);
      if (nodes   != NULL) STBTT_free(nodes  , alloc_context);
      return 0;
   }

   spc->user_allocator_context = alloc_context;
   spc->width = pw;
   spc->height = ph;
   spc->pixels = pixels;
   spc->pack_info = context;
   spc->nodes = nodes;
   spc->padding = padding;
   spc->stride_in_bytes = stride_in_bytes != 0 ? stride_in_bytes : pw;
   spc->h_oversample = 1;
   spc->v_oversample = 1;
   spc->skip_missing = 0;

   stbrp_init_target(context, pw-padding, ph-padding, nodes, num_nodes);

   if (pixels)
      STBTT_memset(pixels, 0, pw*ph); // background of 0 around pixels

   return 1;
}

STBTT_DEF void stbtt_PackEnd  (stbtt_pack_context *spc)
{
   STBTT_free(spc->nodes    , spc->user_allocator_context);
   STBTT_free(spc->pack_info, spc->user_allocator_context);
}

STBTT_DEF void stbtt_PackSetOversampling(stbtt_pack_context *spc, unsigned int h_oversample, unsigned int v_oversample)
{
   STBTT_assert(h_oversample <= STBTT_MAX_OVERSAMPLE);
   STBTT_assert(v_oversample <= STBTT_MAX_OVERSAMPLE);
   if (h_oversample <= STBTT_MAX_OVERSAMPLE)
      spc->h_oversample = h_oversample;
   if (v_oversample <= STBTT_MAX_OVERSAMPLE)
      spc->v_oversample = v_oversample;
}

STBTT_DEF void stbtt_PackSetSkipMissingCodepoints(stbtt_pack_context *spc, int skip)
{
   spc->skip_missing = skip;
}

#define STBTT__OVER_MASK  (STBTT_MAX_OVERSAMPLE-1)

static void stbtt__h_prefilter(unsigned char *pixels, int w, int h, int stride_in_bytes, unsigned int kernel_width)
{
   unsigned char buffer[STBTT_MAX_OVERSAMPLE];
   int safe_w = w - kernel_width;
   int j;
   STBTT_memset(buffer, 0, STBTT_MAX_OVERSAMPLE); // suppress bogus warning from VS2013 -analyze
   for (j=0; j < h; ++j) {
      int i;
      unsigned int total;
      STBTT_memset(buffer, 0, kernel_width);

      total = 0;

      // make kernel_width a constant in common cases so compiler can optimize out the divide
      switch (kernel_width) {
         case 2:
            for (i=0; i <= safe_w; ++i) {
               total += pixels[i] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];
               pixels[i] = (unsigned char) (total / 2);
            }
            break;
         case 3:
            for (i=0; i <= safe_w; ++i) {
               total += pixels[i] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];
               pixels[i] = (unsigned char) (total / 3);
            }
            break;
         case 4:
            for (i=0; i <= safe_w; ++i) {
               total += pixels[i] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];
               pixels[i] = (unsigned char) (total / 4);
            }
            break;
         case 5:
            for (i=0; i <= safe_w; ++i) {
               total += pixels[i] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];
               pixels[i] = (unsigned char) (total / 5);
            }
            break;
         default:
            for (i=0; i <= safe_w; ++i) {
               total += pixels[i] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];
               pixels[i] = (unsigned char) (total / kernel_width);
            }
            break;
      }

      for (; i < w; ++i) {
         STBTT_assert(pixels[i] == 0);
         total -= buffer[i & STBTT__OVER_MASK];
         pixels[i] = (unsigned char) (total / kernel_width);
      }

      pixels += stride_in_bytes;
   }
}

static void stbtt__v_prefilter(unsigned char *pixels, int w, int h, int stride_in_bytes, unsigned int kernel_width)
{
   unsigned char buffer[STBTT_MAX_OVERSAMPLE];
   int safe_h = h - kernel_width;
   int j;
   STBTT_memset(buffer, 0, STBTT_MAX_OVERSAMPLE); // suppress bogus warning from VS2013 -analyze
   for (j=0; j < w; ++j) {
      int i;
      unsigned int total;
      STBTT_memset(buffer, 0, kernel_width);

      total = 0;

      // make kernel_width a constant in common cases so compiler can optimize out the divide
      switch (kernel_width) {
         case 2:
            for (i=0; i <= safe_h; ++i) {
               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];
               pixels[i*stride_in_bytes] = (unsigned char) (total / 2);
            }
            break;
         case 3:
            for (i=0; i <= safe_h; ++i) {
               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];
               pixels[i*stride_in_bytes] = (unsigned char) (total / 3);
            }
            break;
         case 4:
            for (i=0; i <= safe_h; ++i) {
               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];
               pixels[i*stride_in_bytes] = (unsigned char) (total / 4);
            }
            break;
         case 5:
            for (i=0; i <= safe_h; ++i) {
               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];
               pixels[i*stride_in_bytes] = (unsigned char) (total / 5);
            }
            break;
         default:
            for (i=0; i <= safe_h; ++i) {
               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];
               pixels[i*stride_in_bytes] = (unsigned char) (total / kernel_width);
            }
            break;
      }

      for (; i < h; ++i) {
         STBTT_assert(pixels[i*stride_in_bytes] == 0);
         total -= buffer[i & STBTT__OVER_MASK];
         pixels[i*stride_in_bytes] = (unsigned char) (total / kernel_width);
      }

      pixels += 1;
   }
}

static float stbtt__oversample_shift(int oversample)
{
   if (!oversample)
      return 0.0f;

   // The prefilter is a box filter of width "oversample",
   // which shifts phase by (oversample - 1)/2 pixels in
   // oversampled space. We want to shift in the opposite
   // direction to counter this.
   return (float)-(oversample - 1) / (2.0f * (float)oversample);
}

// rects array must be big enough to accommodate all characters in the given ranges
STBTT_DEF int stbtt_PackFontRangesGatherRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects)
{
   int i,j,k;
   int missing_glyph_added = 0;

   k=0;
   for (i=0; i < num_ranges; ++i) {
      float fh = ranges[i].font_size;
      float scale = fh > 0 ? stbtt_ScaleForPixelHeight(info, fh) : stbtt_ScaleForMappingEmToPixels(info, -fh);
      ranges[i].h_oversample = (unsigned char) spc->h_oversample;
      ranges[i].v_oversample = (unsigned char) spc->v_oversample;
      for (j=0; j < ranges[i].num_chars; ++j) {
         int x0,y0,x1,y1;
         int codepoint = ranges[i].array_of_unicode_codepoints == NULL ? ranges[i].first_unicode_codepoint_in_range + j : ranges[i].array_of_unicode_codepoints[j];
         int glyph = stbtt_FindGlyphIndex(info, codepoint);
         if (glyph == 0 && (spc->skip_missing || missing_glyph_added)) {
            rects[k].w = rects[k].h = 0;
         } else {
            stbtt_GetGlyphBitmapBoxSubpixel(info,glyph,
                                            scale * spc->h_oversample,
                                            scale * spc->v_oversample,
                                            0,0,
                                            &x0,&y0,&x1,&y1);
            rects[k].w = (stbrp_coord) (x1-x0 + spc->padding + spc->h_oversample-1);
            rects[k].h = (stbrp_coord) (y1-y0 + spc->padding + spc->v_oversample-1);
            if (glyph == 0)
               missing_glyph_added = 1;
         }
         ++k;
      }
   }

   return k;
}

STBTT_DEF void stbtt_MakeGlyphBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int prefilter_x, int prefilter_y, float *sub_x, float *sub_y, int glyph)
{
   stbtt_MakeGlyphBitmapSubpixel(info,
                                 output,
                                 out_w - (prefilter_x - 1),
                                 out_h - (prefilter_y - 1),
                                 out_stride,
                                 scale_x,
                                 scale_y,
                                 shift_x,
                                 shift_y,
                                 glyph);

   if (prefilter_x > 1)
      stbtt__h_prefilter(output, out_w, out_h, out_stride, prefilter_x);

   if (prefilter_y > 1)
      stbtt__v_prefilter(output, out_w, out_h, out_stride, prefilter_y);

   *sub_x = stbtt__oversample_shift(prefilter_x);
   *sub_y = stbtt__oversample_shift(prefilter_y);
}

// rects array must be big enough to accommodate all characters in the given ranges
STBTT_DEF int stbtt_PackFontRangesRenderIntoRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects)
{
   int i,j,k, missing_glyph = -1, return_value = 1;

   // save current values
   int old_h_over = spc->h_oversample;
   int old_v_over = spc->v_oversample;

   k = 0;
   for (i=0; i < num_ranges; ++i) {
      float fh = ranges[i].font_size;
      float scale = fh > 0 ? stbtt_ScaleForPixelHeight(info, fh) : stbtt_ScaleForMappingEmToPixels(info, -fh);
      float recip_h,recip_v,sub_x,sub_y;
      spc->h_oversample = ranges[i].h_oversample;
      spc->v_oversample = ranges[i].v_oversample;
      recip_h = 1.0f / spc->h_oversample;
      recip_v = 1.0f / spc->v_oversample;
      sub_x = stbtt__oversample_shift(spc->h_oversample);
      sub_y = stbtt__oversample_shift(spc->v_oversample);
      for (j=0; j < ranges[i].num_chars; ++j) {
         stbrp_rect *r = &rects[k];
         if (r->was_packed && r->w != 0 && r->h != 0) {
            stbtt_packedchar *bc = &ranges[i].chardata_for_range[j];
            int advance, lsb, x0,y0,x1,y1;
            int codepoint = ranges[i].array_of_unicode_codepoints == NULL ? ranges[i].first_unicode_codepoint_in_range + j : ranges[i].array_of_unicode_codepoints[j];
            int glyph = stbtt_FindGlyphIndex(info, codepoint);
            stbrp_coord pad = (stbrp_coord) spc->padding;

            // pad on left and top
            r->x += pad;
            r->y += pad;
            r->w -= pad;
            r->h -= pad;
            stbtt_GetGlyphHMetrics(info, glyph, &advance, &lsb);
            stbtt_GetGlyphBitmapBox(info, glyph,
                                    scale * spc->h_oversample,
                                    scale * spc->v_oversample,
                                    &x0,&y0,&x1,&y1);
            stbtt_MakeGlyphBitmapSubpixel(info,
                                          spc->pixels + r->x + r->y*spc->stride_in_bytes,
                                          r->w - spc->h_oversample+1,
                                          r->h - spc->v_oversample+1,
                                          spc->stride_in_bytes,
                                          scale * spc->h_oversample,
                                          scale * spc->v_oversample,
                                          0,0,
                                          glyph);

            if (spc->h_oversample > 1)
               stbtt__h_prefilter(spc->pixels + r->x + r->y*spc->stride_in_bytes,
                                  r->w, r->h, spc->stride_in_bytes,
                                  spc->h_oversample);

            if (spc->v_oversample > 1)
               stbtt__v_prefilter(spc->pixels + r->x + r->y*spc->stride_in_bytes,
                                  r->w, r->h, spc->stride_in_bytes,
                                  spc->v_oversample);

            bc->x0       = (stbtt_int16)  r->x;
            bc->y0       = (stbtt_int16)  r->y;
            bc->x1       = (stbtt_int16) (r->x + r->w);
            bc->y1       = (stbtt_int16) (r->y + r->h);
            bc->xadvance =                scale * advance;
            bc->xoff     =       (float)  x0 * recip_h + sub_x;
            bc->yoff     =       (float)  y0 * recip_v + sub_y;
            bc->xoff2    =                (x0 + r->w) * recip_h + sub_x;
            bc->yoff2    =                (y0 + r->h) * recip_v + sub_y;

            if (glyph == 0)
               missing_glyph = j;
         } else if (spc->skip_missing) {
            return_value = 0;
         } else if (r->was_packed && r->w == 0 && r->h == 0 && missing_glyph >= 0) {
            ranges[i].chardata_for_range[j] = ranges[i].chardata_for_range[missing_glyph];
         } else {
            return_value = 0; // if any fail, report failure
         }

         ++k;
      }
   }

   // restore original values
   spc->h_oversample = old_h_over;
   spc->v_oversample = old_v_over;

   return return_value;
}

STBTT_DEF void stbtt_PackFontRangesPackRects(stbtt_pack_context *spc, stbrp_rect *rects, int num_rects)
{
   stbrp_pack_rects((stbrp_context *) spc->pack_info, rects, num_rects);
}

STBTT_DEF int stbtt_PackFontRanges(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, stbtt_pack_range *ranges, int num_ranges)
{
   stbtt_fontinfo info;
   int i, j, n, return_value; // [DEAR IMGUI] removed = 1;
   //stbrp_context *context = (stbrp_context *) spc->pack_info;
   stbrp_rect    *rects;

   // flag all characters as NOT packed
   for (i=0; i < num_ranges; ++i)
      for (j=0; j < ranges[i].num_chars; ++j)
         ranges[i].chardata_for_range[j].x0 =
         ranges[i].chardata_for_range[j].y0 =
         ranges[i].chardata_for_range[j].x1 =
         ranges[i].chardata_for_range[j].y1 = 0;

   n = 0;
   for (i=0; i < num_ranges; ++i)
      n += ranges[i].num_chars;

   rects = (stbrp_rect *) STBTT_malloc(sizeof(*rects) * n, spc->user_allocator_context);
   if (rects == NULL)
      return 0;

   info.userdata = spc->user_allocator_context;
   stbtt_InitFont(&info, fontdata, stbtt_GetFontOffsetForIndex(fontdata,font_index));

   n = stbtt_PackFontRangesGatherRects(spc, &info, ranges, num_ranges, rects);

   stbtt_PackFontRangesPackRects(spc, rects, n);

   return_value = stbtt_PackFontRangesRenderIntoRects(spc, &info, ranges, num_ranges, rects);

   STBTT_free(rects, spc->user_allocator_context);
   return return_value;
}

STBTT_DEF int stbtt_PackFontRange(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, float font_size,
            int first_unicode_codepoint_in_range, int num_chars_in_range, stbtt_packedchar *chardata_for_range)
{
   stbtt_pack_range range;
   range.first_unicode_codepoint_in_range = first_unicode_codepoint_in_range;
   range.array_of_unicode_codepoints = NULL;
   range.num_chars                   = num_chars_in_range;
   range.chardata_for_range          = chardata_for_range;
   range.font_size                   = font_size;
   return stbtt_PackFontRanges(spc, fontdata, font_index, &range, 1);
}

STBTT_DEF void stbtt_GetScaledFontVMetrics(const unsigned char *fontdata, int index, float size, float *ascent, float *descent, float *lineGap)
{
   int i_ascent, i_descent, i_lineGap;
   float scale;
   stbtt_fontinfo info;
   stbtt_InitFont(&info, fontdata, stbtt_GetFontOffsetForIndex(fontdata, index));
   scale = size > 0 ? stbtt_ScaleForPixelHeight(&info, size) : stbtt_ScaleForMappingEmToPixels(&info, -size);
   stbtt_GetFontVMetrics(&info, &i_ascent, &i_descent, &i_lineGap);
   *ascent  = (float) i_ascent  * scale;
   *descent = (float) i_descent * scale;
   *lineGap = (float) i_lineGap * scale;
}

STBTT_DEF void stbtt_GetPackedQuad(const stbtt_packedchar *chardata, int pw, int ph, int char_index, float *xpos, float *ypos, stbtt_aligned_quad *q, int align_to_integer)
{
   float ipw = 1.0f / pw, iph = 1.0f / ph;
   const stbtt_packedchar *b = chardata + char_index;

   if (align_to_integer) {
      float x = (float) STBTT_ifloor((*xpos + b->xoff) + 0.5f);
      float y = (float) STBTT_ifloor((*ypos + b->yoff) + 0.5f);
      q->x0 = x;
      q->y0 = y;
      q->x1 = x + b->xoff2 - b->xoff;
      q->y1 = y + b->yoff2 - b->yoff;
   } else {
      q->x0 = *xpos + b->xoff;
      q->y0 = *ypos + b->yoff;
      q->x1 = *xpos + b->xoff2;
      q->y1 = *ypos + b->yoff2;
   }

   q->s0 = b->x0 * ipw;
   q->t0 = b->y0 * iph;
   q->s1 = b->x1 * ipw;
   q->t1 = b->y1 * iph;

   *xpos += b->xadvance;
}

//////////////////////////////////////////////////////////////////////////////
//
// sdf computation
//

#define STBTT_min(a,b)  ((a) < (b) ? (a) : (b))
#define STBTT_max(a,b)  ((a) < (b) ? (b) : (a))

static int stbtt__ray_intersect_bezier(float orig[2], float ray[2], float q0[2], float q1[2], float q2[2], float hits[2][2])
{
   float q0perp = q0[1]*ray[0] - q0[0]*ray[1];
   float q1perp = q1[1]*ray[0] - q1[0]*ray[1];
   float q2perp = q2[1]*ray[0] - q2[0]*ray[1];
   float roperp = orig[1]*ray[0] - orig[0]*ray[1];

   float a = q0perp - 2*q1perp + q2perp;
   float b = q1perp - q0perp;
   float c = q0perp - roperp;

   float s0 = 0., s1 = 0.;
   int num_s = 0;

   if (a != 0.0) {
      float discr = b*b - a*c;
      if (discr > 0.0) {
         float rcpna = -1 / a;
         float d = (float) STBTT_sqrt(discr);
         s0 = (b+d) * rcpna;
         s1 = (b-d) * rcpna;
         if (s0 >= 0.0 && s0 <= 1.0)
            num_s = 1;
         if (d > 0.0 && s1 >= 0.0 && s1 <= 1.0) {
            if (num_s == 0) s0 = s1;
            ++num_s;
         }
      }
   } else {
      // 2*b*s + c = 0
      // s = -c / (2*b)
      s0 = c / (-2 * b);
      if (s0 >= 0.0 && s0 <= 1.0)
         num_s = 1;
   }

   if (num_s == 0)
      return 0;
   else {
      float rcp_len2 = 1 / (ray[0]*ray[0] + ray[1]*ray[1]);
      float rayn_x = ray[0] * rcp_len2, rayn_y = ray[1] * rcp_len2;

      float q0d =   q0[0]*rayn_x +   q0[1]*rayn_y;
      float q1d =   q1[0]*rayn_x +   q1[1]*rayn_y;
      float q2d =   q2[0]*rayn_x +   q2[1]*rayn_y;
      float rod = orig[0]*rayn_x + orig[1]*rayn_y;

      float q10d = q1d - q0d;
      float q20d = q2d - q0d;
      float q0rd = q0d - rod;

      hits[0][0] = q0rd + s0*(2.0f - 2.0f*s0)*q10d + s0*s0*q20d;
      hits[0][1] = a*s0+b;

      if (num_s > 1) {
         hits[1][0] = q0rd + s1*(2.0f - 2.0f*s1)*q10d + s1*s1*q20d;
         hits[1][1] = a*s1+b;
         return 2;
      } else {
         return 1;
      }
   }
}

static int equal(float *a, float *b)
{
   return (a[0] == b[0] && a[1] == b[1]);
}

static int stbtt__compute_crossings_x(float x, float y, int nverts, stbtt_vertex *verts)
{
   int i;
   float orig[2], ray[2] = { 1, 0 };
   float y_frac;
   int winding = 0;

   // make sure y never passes through a vertex of the shape
   y_frac = (float) STBTT_fmod(y, 1.0f);
   if (y_frac < 0.01f)
      y += 0.01f;
   else if (y_frac > 0.99f)
      y -= 0.01f;

   orig[0] = x;
   orig[1] = y;

   // test a ray from (-infinity,y) to (x,y)
   for (i=0; i < nverts; ++i) {
      if (verts[i].type == STBTT_vline) {
         int x0 = (int) verts[i-1].x, y0 = (int) verts[i-1].y;
         int x1 = (int) verts[i  ].x, y1 = (int) verts[i  ].y;
         if (y > STBTT_min(y0,y1) && y < STBTT_max(y0,y1) && x > STBTT_min(x0,x1)) {
            float x_inter = (y - y0) / (y1 - y0) * (x1-x0) + x0;
            if (x_inter < x)
               winding += (y0 < y1) ? 1 : -1;
         }
      }
      if (verts[i].type == STBTT_vcurve) {
         int x0 = (int) verts[i-1].x , y0 = (int) verts[i-1].y ;
         int x1 = (int) verts[i  ].cx, y1 = (int) verts[i  ].cy;
         int x2 = (int) verts[i  ].x , y2 = (int) verts[i  ].y ;
         int ax = STBTT_min(x0,STBTT_min(x1,x2)), ay = STBTT_min(y0,STBTT_min(y1,y2));
         int by = STBTT_max(y0,STBTT_max(y1,y2));
         if (y > ay && y < by && x > ax) {
            float q0[2],q1[2],q2[2];
            float hits[2][2];
            q0[0] = (float)x0;
            q0[1] = (float)y0;
            q1[0] = (float)x1;
            q1[1] = (float)y1;
            q2[0] = (float)x2;
            q2[1] = (float)y2;
            if (equal(q0,q1) || equal(q1,q2)) {
               x0 = (int)verts[i-1].x;
               y0 = (int)verts[i-1].y;
               x1 = (int)verts[i  ].x;
               y1 = (int)verts[i  ].y;
               if (y > STBTT_min(y0,y1) && y < STBTT_max(y0,y1) && x > STBTT_min(x0,x1)) {
                  float x_inter = (y - y0) / (y1 - y0) * (x1-x0) + x0;
                  if (x_inter < x)
                     winding += (y0 < y1) ? 1 : -1;
               }
            } else {
               int num_hits = stbtt__ray_intersect_bezier(orig, ray, q0, q1, q2, hits);
               if (num_hits >= 1)
                  if (hits[0][0] < 0)
                     winding += (hits[0][1] < 0 ? -1 : 1);
               if (num_hits >= 2)
                  if (hits[1][0] < 0)
                     winding += (hits[1][1] < 0 ? -1 : 1);
            }
         }
      }
   }
   return winding;
}

static float stbtt__cuberoot( float x )
{
   if (x<0)
      return -(float) STBTT_pow(-x,1.0f/3.0f);
   else
      return  (float) STBTT_pow( x,1.0f/3.0f);
}

// x^3 + a*x^2 + b*x + c = 0
static int stbtt__solve_cubic(float a, float b, float c, float* r)
{
   float s = -a / 3;
   float p = b - a*a / 3;
   float q = a * (2*a*a - 9*b) / 27 + c;
   float p3 = p*p*p;
   float d = q*q + 4*p3 / 27;
   if (d >= 0) {
      float z = (float) STBTT_sqrt(d);
      float u = (-q + z) / 2;
      float v = (-q - z) / 2;
      u = stbtt__cuberoot(u);
      v = stbtt__cuberoot(v);
      r[0] = s + u + v;
      return 1;
   } else {
      float u = (float) STBTT_sqrt(-p/3);
      float v = (float) STBTT_acos(-STBTT_sqrt(-27/p3) * q / 2) / 3; // p3 must be negative, since d is negative
      float m = (float) STBTT_cos(v);
      float n = (float) STBTT_cos(v-3.141592/2)*1.732050808f;
      r[0] = s + u * 2 * m;
      r[1] = s - u * (m + n);
      r[2] = s - u * (m - n);

      //STBTT_assert( STBTT_fabs(((r[0]+a)*r[0]+b)*r[0]+c) < 0.05f);  // these asserts may not be safe at all scales, though they're in bezier t parameter units so maybe?
      //STBTT_assert( STBTT_fabs(((r[1]+a)*r[1]+b)*r[1]+c) < 0.05f);
      //STBTT_assert( STBTT_fabs(((r[2]+a)*r[2]+b)*r[2]+c) < 0.05f);
      return 3;
   }
}

STBTT_DEF unsigned char * stbtt_GetGlyphSDF(const stbtt_fontinfo *info, float scale, int glyph, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff)
{
   float scale_x = scale, scale_y = scale;
   int ix0,iy0,ix1,iy1;
   int w,h;
   unsigned char *data;

   if (scale == 0) return NULL;

   stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale, scale, 0.0f,0.0f, &ix0,&iy0,&ix1,&iy1);

   // if empty, return NULL
   if (ix0 == ix1 || iy0 == iy1)
      return NULL;

   ix0 -= padding;
   iy0 -= padding;
   ix1 += padding;
   iy1 += padding;

   w = (ix1 - ix0);
   h = (iy1 - iy0);

   if (width ) *width  = w;
   if (height) *height = h;
   if (xoff  ) *xoff   = ix0;
   if (yoff  ) *yoff   = iy0;

   // invert for y-downwards bitmaps
   scale_y = -scale_y;

   {
      int x,y,i,j;
      float *precompute;
      stbtt_vertex *verts;
      int num_verts = stbtt_GetGlyphShape(info, glyph, &verts);
      data = (unsigned char *) STBTT_malloc(w * h, info->userdata);
      precompute = (float *) STBTT_malloc(num_verts * sizeof(float), info->userdata);

      for (i=0,j=num_verts-1; i < num_verts; j=i++) {
         if (verts[i].type == STBTT_vline) {
            float x0 = verts[i].x*scale_x, y0 = verts[i].y*scale_y;
            float x1 = verts[j].x*scale_x, y1 = verts[j].y*scale_y;
            float dist = (float) STBTT_sqrt((x1-x0)*(x1-x0) + (y1-y0)*(y1-y0));
            precompute[i] = (dist == 0) ? 0.0f : 1.0f / dist;
         } else if (verts[i].type == STBTT_vcurve) {
            float x2 = verts[j].x *scale_x, y2 = verts[j].y *scale_y;
            float x1 = verts[i].cx*scale_x, y1 = verts[i].cy*scale_y;
            float x0 = verts[i].x *scale_x, y0 = verts[i].y *scale_y;
            float bx = x0 - 2*x1 + x2, by = y0 - 2*y1 + y2;
            float len2 = bx*bx + by*by;
            if (len2 != 0.0f)
               precompute[i] = 1.0f / (bx*bx + by*by);
            else
               precompute[i] = 0.0f;
         } else
            precompute[i] = 0.0f;
      }

      for (y=iy0; y < iy1; ++y) {
         for (x=ix0; x < ix1; ++x) {
            float val;
            float min_dist = 999999.0f;
            float sx = (float) x + 0.5f;
            float sy = (float) y + 0.5f;
            float x_gspace = (sx / scale_x);
            float y_gspace = (sy / scale_y);

            int winding = stbtt__compute_crossings_x(x_gspace, y_gspace, num_verts, verts); // @OPTIMIZE: this could just be a rasterization, but needs to be line vs. non-tesselated curves so a new path

            for (i=0; i < num_verts; ++i) {
               float x0 = verts[i].x*scale_x, y0 = verts[i].y*scale_y;

               if (verts[i].type == STBTT_vline && precompute[i] != 0.0f) {
                  float x1 = verts[i-1].x*scale_x, y1 = verts[i-1].y*scale_y;

                  float dist,dist2 = (x0-sx)*(x0-sx) + (y0-sy)*(y0-sy);
                  if (dist2 < min_dist*min_dist)
                     min_dist = (float) STBTT_sqrt(dist2);

                  // coarse culling against bbox
                  //if (sx > STBTT_min(x0,x1)-min_dist && sx < STBTT_max(x0,x1)+min_dist &&
                  //    sy > STBTT_min(y0,y1)-min_dist && sy < STBTT_max(y0,y1)+min_dist)
                  dist = (float) STBTT_fabs((x1-x0)*(y0-sy) - (y1-y0)*(x0-sx)) * precompute[i];
                  STBTT_assert(i != 0);
                  if (dist < min_dist) {
                     // check position along line
                     // x' = x0 + t*(x1-x0), y' = y0 + t*(y1-y0)
                     // minimize (x'-sx)*(x'-sx)+(y'-sy)*(y'-sy)
                     float dx = x1-x0, dy = y1-y0;
                     float px = x0-sx, py = y0-sy;
                     // minimize (px+t*dx)^2 + (py+t*dy)^2 = px*px + 2*px*dx*t + t^2*dx*dx + py*py + 2*py*dy*t + t^2*dy*dy
                     // derivative: 2*px*dx + 2*py*dy + (2*dx*dx+2*dy*dy)*t, set to 0 and solve
                     float t = -(px*dx + py*dy) / (dx*dx + dy*dy);
                     if (t >= 0.0f && t <= 1.0f)
                        min_dist = dist;
                  }
               } else if (verts[i].type == STBTT_vcurve) {
                  float x2 = verts[i-1].x *scale_x, y2 = verts[i-1].y *scale_y;
                  float x1 = verts[i  ].cx*scale_x, y1 = verts[i  ].cy*scale_y;
                  float box_x0 = STBTT_min(STBTT_min(x0,x1),x2);
                  float box_y0 = STBTT_min(STBTT_min(y0,y1),y2);
                  float box_x1 = STBTT_max(STBTT_max(x0,x1),x2);
                  float box_y1 = STBTT_max(STBTT_max(y0,y1),y2);
                  // coarse culling against bbox to avoid computing cubic unnecessarily
                  if (sx > box_x0-min_dist && sx < box_x1+min_dist && sy > box_y0-min_dist && sy < box_y1+min_dist) {
                     int num=0;
                     float ax = x1-x0, ay = y1-y0;
                     float bx = x0 - 2*x1 + x2, by = y0 - 2*y1 + y2;
                     float mx = x0 - sx, my = y0 - sy;
                     float res[3] = {0.f,0.f,0.f};
                     float px,py,t,it,dist2;
                     float a_inv = precompute[i];
                     if (a_inv == 0.0) { // if a_inv is 0, it's 2nd degree so use quadratic formula
                        float a = 3*(ax*bx + ay*by);
                        float b = 2*(ax*ax + ay*ay) + (mx*bx+my*by);
                        float c = mx*ax+my*ay;
                        if (a == 0.0) { // if a is 0, it's linear
                           if (b != 0.0) {
                              res[num++] = -c/b;
                           }
                        } else {
                           float discriminant = b*b - 4*a*c;
                           if (discriminant < 0)
                              num = 0;
                           else {
                              float root = (float) STBTT_sqrt(discriminant);
                              res[0] = (-b - root)/(2*a);
                              res[1] = (-b + root)/(2*a);
                              num = 2; // don't bother distinguishing 1-solution case, as code below will still work
                           }
                        }
                     } else {
                        float b = 3*(ax*bx + ay*by) * a_inv; // could precompute this as it doesn't depend on sample point
                        float c = (2*(ax*ax + ay*ay) + (mx*bx+my*by)) * a_inv;
                        float d = (mx*ax+my*ay) * a_inv;
                        num = stbtt__solve_cubic(b, c, d, res);
                     }
                     dist2 = (x0-sx)*(x0-sx) + (y0-sy)*(y0-sy);
                     if (dist2 < min_dist*min_dist)
                        min_dist = (float) STBTT_sqrt(dist2);

                     if (num >= 1 && res[0] >= 0.0f && res[0] <= 1.0f) {
                        t = res[0], it = 1.0f - t;
                        px = it*it*x0 + 2*t*it*x1 + t*t*x2;
                        py = it*it*y0 + 2*t*it*y1 + t*t*y2;
                        dist2 = (px-sx)*(px-sx) + (py-sy)*(py-sy);
                        if (dist2 < min_dist * min_dist)
                           min_dist = (float) STBTT_sqrt(dist2);
                     }
                     if (num >= 2 && res[1] >= 0.0f && res[1] <= 1.0f) {
                        t = res[1], it = 1.0f - t;
                        px = it*it*x0 + 2*t*it*x1 + t*t*x2;
                        py = it*it*y0 + 2*t*it*y1 + t*t*y2;
                        dist2 = (px-sx)*(px-sx) + (py-sy)*(py-sy);
                        if (dist2 < min_dist * min_dist)
                           min_dist = (float) STBTT_sqrt(dist2);
                     }
                     if (num >= 3 && res[2] >= 0.0f && res[2] <= 1.0f) {
                        t = res[2], it = 1.0f - t;
                        px = it*it*x0 + 2*t*it*x1 + t*t*x2;
                        py = it*it*y0 + 2*t*it*y1 + t*t*y2;
                        dist2 = (px-sx)*(px-sx) + (py-sy)*(py-sy);
                        if (dist2 < min_dist * min_dist)
                           min_dist = (float) STBTT_sqrt(dist2);
                     }
                  }
               }
            }
            if (winding == 0)
               min_dist = -min_dist;  // if outside the shape, value is negative
            val = onedge_value + pixel_dist_scale * min_dist;
            if (val < 0)
               val = 0;
            else if (val > 255)
               val = 255;
            data[(y-iy0)*w+(x-ix0)] = (unsigned char) val;
         }
      }
      STBTT_free(precompute, info->userdata);
      STBTT_free(verts, info->userdata);
   }
   return data;
}

STBTT_DEF unsigned char * stbtt_GetCodepointSDF(const stbtt_fontinfo *info, float scale, int codepoint, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff)
{
   return stbtt_GetGlyphSDF(info, scale, stbtt_FindGlyphIndex(info, codepoint), padding, onedge_value, pixel_dist_scale, width, height, xoff, yoff);
}

STBTT_DEF void stbtt_FreeSDF(unsigned char *bitmap, void *userdata)
{
   STBTT_free(bitmap, userdata);
}

//////////////////////////////////////////////////////////////////////////////
//
// font name matching -- recommended not to use this
//

// check if a utf8 string contains a prefix which is the utf16 string; if so return length of matching utf8 string
static stbtt_int32 stbtt__CompareUTF8toUTF16_bigendian_prefix(stbtt_uint8 *s1, stbtt_int32 len1, stbtt_uint8 *s2, stbtt_int32 len2)
{
   stbtt_int32 i=0;

   // convert utf16 to utf8 and compare the results while converting
   while (len2) {
      stbtt_uint16 ch = s2[0]*256 + s2[1];
      if (ch < 0x80) {
         if (i >= len1) return -1;
         if (s1[i++] != ch) return -1;
      } else if (ch < 0x800) {
         if (i+1 >= len1) return -1;
         if (s1[i++] != 0xc0 + (ch >> 6)) return -1;
         if (s1[i++] != 0x80 + (ch & 0x3f)) return -1;
      } else if (ch >= 0xd800 && ch < 0xdc00) {
         stbtt_uint32 c;
         stbtt_uint16 ch2 = s2[2]*256 + s2[3];
         if (i+3 >= len1) return -1;
         c = ((ch - 0xd800) << 10) + (ch2 - 0xdc00) + 0x10000;
         if (s1[i++] != 0xf0 + (c >> 18)) return -1;
         if (s1[i++] != 0x80 + ((c >> 12) & 0x3f)) return -1;
         if (s1[i++] != 0x80 + ((c >>  6) & 0x3f)) return -1;
         if (s1[i++] != 0x80 + ((c      ) & 0x3f)) return -1;
         s2 += 2; // plus another 2 below
         len2 -= 2;
      } else if (ch >= 0xdc00 && ch < 0xe000) {
         return -1;
      } else {
         if (i+2 >= len1) return -1;
         if (s1[i++] != 0xe0 + (ch >> 12)) return -1;
         if (s1[i++] != 0x80 + ((ch >> 6) & 0x3f)) return -1;
         if (s1[i++] != 0x80 + ((ch     ) & 0x3f)) return -1;
      }
      s2 += 2;
      len2 -= 2;
   }
   return i;
}

static int stbtt_CompareUTF8toUTF16_bigendian_internal(char *s1, int len1, char *s2, int len2)
{
   return len1 == stbtt__CompareUTF8toUTF16_bigendian_prefix((stbtt_uint8*) s1, len1, (stbtt_uint8*) s2, len2);
}

// returns results in whatever encoding you request... but note that 2-byte encodings
// will be BIG-ENDIAN... use stbtt_CompareUTF8toUTF16_bigendian() to compare
STBTT_DEF const char *stbtt_GetFontNameString(const stbtt_fontinfo *font, int *length, int platformID, int encodingID, int languageID, int nameID)
{
   stbtt_int32 i,count,stringOffset;
   stbtt_uint8 *fc = font->data;
   stbtt_uint32 offset = font->fontstart;
   stbtt_uint32 nm = stbtt__find_table(fc, offset, "name");
   if (!nm) return NULL;

   count = ttUSHORT(fc+nm+2);
   stringOffset = nm + ttUSHORT(fc+nm+4);
   for (i=0; i < count; ++i) {
      stbtt_uint32 loc = nm + 6 + 12 * i;
      if (platformID == ttUSHORT(fc+loc+0) && encodingID == ttUSHORT(fc+loc+2)
          && languageID == ttUSHORT(fc+loc+4) && nameID == ttUSHORT(fc+loc+6)) {
         *length = ttUSHORT(fc+loc+8);
         return (const char *) (fc+stringOffset+ttUSHORT(fc+loc+10));
      }
   }
   return NULL;
}

static int stbtt__matchpair(stbtt_uint8 *fc, stbtt_uint32 nm, stbtt_uint8 *name, stbtt_int32 nlen, stbtt_int32 target_id, stbtt_int32 next_id)
{
   stbtt_int32 i;
   stbtt_int32 count = ttUSHORT(fc+nm+2);
   stbtt_int32 stringOffset = nm + ttUSHORT(fc+nm+4);

   for (i=0; i < count; ++i) {
      stbtt_uint32 loc = nm + 6 + 12 * i;
      stbtt_int32 id = ttUSHORT(fc+loc+6);
      if (id == target_id) {
         // find the encoding
         stbtt_int32 platform = ttUSHORT(fc+loc+0), encoding = ttUSHORT(fc+loc+2), language = ttUSHORT(fc+loc+4);

         // is this a Unicode encoding?
         if (platform == 0 || (platform == 3 && encoding == 1) || (platform == 3 && encoding == 10)) {
            stbtt_int32 slen = ttUSHORT(fc+loc+8);
            stbtt_int32 off = ttUSHORT(fc+loc+10);

            // check if there's a prefix match
            stbtt_int32 matchlen = stbtt__CompareUTF8toUTF16_bigendian_prefix(name, nlen, fc+stringOffset+off,slen);
            if (matchlen >= 0) {
               // check for target_id+1 immediately following, with same encoding & language
               if (i+1 < count && ttUSHORT(fc+loc+12+6) == next_id && ttUSHORT(fc+loc+12) == platform && ttUSHORT(fc+loc+12+2) == encoding && ttUSHORT(fc+loc+12+4) == language) {
                  slen = ttUSHORT(fc+loc+12+8);
                  off = ttUSHORT(fc+loc+12+10);
                  if (slen == 0) {
                     if (matchlen == nlen)
                        return 1;
                  } else if (matchlen < nlen && name[matchlen] == ' ') {
                     ++matchlen;
                     if (stbtt_CompareUTF8toUTF16_bigendian_internal((char*) (name+matchlen), nlen-matchlen, (char*)(fc+stringOffset+off),slen))
                        return 1;
                  }
               } else {
                  // if nothing immediately following
                  if (matchlen == nlen)
                     return 1;
               }
            }
         }

         // @TODO handle other encodings
      }
   }
   return 0;
}

static int stbtt__matches(stbtt_uint8 *fc, stbtt_uint32 offset, stbtt_uint8 *name, stbtt_int32 flags)
{
   stbtt_int32 nlen = (stbtt_int32) STBTT_strlen((char *) name);
   stbtt_uint32 nm,hd;
   if (!stbtt__isfont(fc+offset)) return 0;

   // check italics/bold/underline flags in macStyle...
   if (flags) {
      hd = stbtt__find_table(fc, offset, "head");
      if ((ttUSHORT(fc+hd+44) & 7) != (flags & 7)) return 0;
   }

   nm = stbtt__find_table(fc, offset, "name");
   if (!nm) return 0;

   if (flags) {
      // if we checked the macStyle flags, then just check the family and ignore the subfamily
      if (stbtt__matchpair(fc, nm, name, nlen, 16, -1))  return 1;
      if (stbtt__matchpair(fc, nm, name, nlen,  1, -1))  return 1;
      if (stbtt__matchpair(fc, nm, name, nlen,  3, -1))  return 1;
   } else {
      if (stbtt__matchpair(fc, nm, name, nlen, 16, 17))  return 1;
      if (stbtt__matchpair(fc, nm, name, nlen,  1,  2))  return 1;
      if (stbtt__matchpair(fc, nm, name, nlen,  3, -1))  return 1;
   }

   return 0;
}

static int stbtt_FindMatchingFont_internal(unsigned char *font_collection, char *name_utf8, stbtt_int32 flags)
{
   stbtt_int32 i;
   for (i=0;;++i) {
      stbtt_int32 off = stbtt_GetFontOffsetForIndex(font_collection, i);
      if (off < 0) return off;
      if (stbtt__matches((stbtt_uint8 *) font_collection, off, (stbtt_uint8*) name_utf8, flags))
         return off;
   }
}

#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wcast-qual"
#endif

STBTT_DEF int stbtt_BakeFontBitmap(const unsigned char *data, int offset,
                                float pixel_height, unsigned char *pixels, int pw, int ph,
                                int first_char, int num_chars, stbtt_bakedchar *chardata)
{
   return stbtt_BakeFontBitmap_internal((unsigned char *) data, offset, pixel_height, pixels, pw, ph, first_char, num_chars, chardata);
}

STBTT_DEF int stbtt_GetFontOffsetForIndex(const unsigned char *data, int index)
{
   return stbtt_GetFontOffsetForIndex_internal((unsigned char *) data, index);
}

STBTT_DEF int stbtt_GetNumberOfFonts(const unsigned char *data)
{
   return stbtt_GetNumberOfFonts_internal((unsigned char *) data);
}

STBTT_DEF int stbtt_InitFont(stbtt_fontinfo *info, const unsigned char *data, int offset)
{
   return stbtt_InitFont_internal(info, (unsigned char *) data, offset);
}

STBTT_DEF int stbtt_FindMatchingFont(const unsigned char *fontdata, const char *name, int flags)
{
   return stbtt_FindMatchingFont_internal((unsigned char *) fontdata, (char *) name, flags);
}

STBTT_DEF int stbtt_CompareUTF8toUTF16_bigendian(const char *s1, int len1, const char *s2, int len2)
{
   return stbtt_CompareUTF8toUTF16_bigendian_internal((char *) s1, len1, (char *) s2, len2);
}

#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic pop
#endif

#endif // STB_TRUETYPE_IMPLEMENTATION


// FULL VERSION HISTORY
//
//   1.25 (2021-07-11) many fixes
//   1.24 (2020-02-05) fix warning
//   1.23 (2020-02-02) query SVG data for glyphs; query whole kerning table (but only kern not GPOS)
//   1.22 (2019-08-11) minimize missing-glyph duplication; fix kerning if both 'GPOS' and 'kern' are defined
//   1.21 (2019-02-25) fix warning
//   1.20 (2019-02-07) PackFontRange skips missing codepoints; GetScaleFontVMetrics()
//   1.19 (2018-02-11) OpenType GPOS kerning (horizontal only), STBTT_fmod
//   1.18 (2018-01-29) add missing function
//   1.17 (2017-07-23) make more arguments const; doc fix
//   1.16 (2017-07-12) SDF support
//   1.15 (2017-03-03) make more arguments const
//   1.14 (2017-01-16) num-fonts-in-TTC function
//   1.13 (2017-01-02) support OpenType fonts, certain Apple fonts
//   1.12 (2016-10-25) suppress warnings about casting away const with -Wcast-qual
//   1.11 (2016-04-02) fix unused-variable warning
//   1.10 (2016-04-02) allow user-defined fabs() replacement
//                     fix memory leak if fontsize=0.0
//                     fix warning from duplicate typedef
//   1.09 (2016-01-16) warning fix; avoid crash on outofmem; use alloc userdata for PackFontRanges
//   1.08 (2015-09-13) document stbtt_Rasterize(); fixes for vertical & horizontal edges
//   1.07 (2015-08-01) allow PackFontRanges to accept arrays of sparse codepoints;
//                     allow PackFontRanges to pack and render in separate phases;
//                     fix stbtt_GetFontOFfsetForIndex (never worked for non-0 input?);
//                     fixed an assert() bug in the new rasterizer
//                     replace assert() with STBTT_assert() in new rasterizer
//   1.06 (2015-07-14) performance improvements (~35% faster on x86 and x64 on test machine)
//                     also more precise AA rasterizer, except if shapes overlap
//                     remove need for STBTT_sort
//   1.05 (2015-04-15) fix misplaced definitions for STBTT_STATIC
//   1.04 (2015-04-15) typo in example
//   1.03 (2015-04-12) STBTT_STATIC, fix memory leak in new packing, various fixes
//   1.02 (2014-12-10) fix various warnings & compile issues w/ stb_rect_pack, C++
//   1.01 (2014-12-08) fix subpixel position when oversampling to exactly match
//                        non-oversampled; STBTT_POINT_SIZE for packed case only
//   1.00 (2014-12-06) add new PackBegin etc. API, w/ support for oversampling
//   0.99 (2014-09-18) fix multiple bugs with subpixel rendering (ryg)
//   0.9  (2014-08-07) support certain mac/iOS fonts without an MS platformID
//   0.8b (2014-07-07) fix a warning
//   0.8  (2014-05-25) fix a few more warnings
//   0.7  (2013-09-25) bugfix: subpixel glyph bug fixed in 0.5 had come back
//   0.6c (2012-07-24) improve documentation
//   0.6b (2012-07-20) fix a few more warnings
//   0.6  (2012-07-17) fix warnings; added stbtt_ScaleForMappingEmToPixels,
//                        stbtt_GetFontBoundingBox, stbtt_IsGlyphEmpty
//   0.5  (2011-12-09) bugfixes:
//                        subpixel glyph renderer computed wrong bounding box
//                        first vertex of shape can be off-curve (FreeSans)
//   0.4b (2011-12-03) fixed an error in the font baking example
//   0.4  (2011-12-01) kerning, subpixel rendering (tor)
//                    bugfixes for:
//                        codepoint-to-glyph conversion using table fmt=12
//                        codepoint-to-glyph conversion using table fmt=4
//                        stbtt_GetBakedQuad with non-square texture (Zer)
//                    updated Hello World! sample to use kerning and subpixel
//                    fixed some warnings
//   0.3  (2009-06-24) cmap fmt=12, compound shapes (MM)
//                    userdata, malloc-from-userdata, non-zero fill (stb)
//   0.2  (2009-03-11) Fix unsigned/signed char warnings
//   0.1  (2009-03-09) First public release
//

/*
------------------------------------------------------------------------------
This software is available under 2 licenses -- choose whichever you prefer.
------------------------------------------------------------------------------
ALTERNATIVE A - MIT License
Copyright (c) 2017 Sean Barrett
Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
------------------------------------------------------------------------------
ALTERNATIVE B - Public Domain (www.unlicense.org)
This is free and unencumbered software released into the public domain.
Anyone is free to copy, modify, publish, use, compile, sell, or distribute this
software, either in source code form or as a compiled binary, for any purpose,
commercial or non-commercial, and by any means.
In jurisdictions that recognize copyright laws, the author or authors of this
software dedicate any and all copyright interest in the software to the public
domain. We make this dedication for the benefit of the public at large and to
the detriment of our heirs and successors. We intend this dedication to be an
overt act of relinquishment in perpetuity of all present and future rights to
this software under copyright law.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
------------------------------------------------------------------------------
*/

```

`sakura/libs/image/khrplatform.h`:

```h
#ifndef __khrplatform_h_
#define __khrplatform_h_

/*
** Copyright (c) 2008-2018 The Khronos Group Inc.
**
** Permission is hereby granted, free of charge, to any person obtaining a
** copy of this software and/or associated documentation files (the
** "Materials"), to deal in the Materials without restriction, including
** without limitation the rights to use, copy, modify, merge, publish,
** distribute, sublicense, and/or sell copies of the Materials, and to
** permit persons to whom the Materials are furnished to do so, subject to
** the following conditions:
**
** The above copyright notice and this permission notice shall be included
** in all copies or substantial portions of the Materials.
**
** THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
** MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
*/

/* Khronos platform-specific types and definitions.
 *
 * The master copy of khrplatform.h is maintained in the Khronos EGL
 * Registry repository at https://github.com/KhronosGroup/EGL-Registry
 * The last semantic modification to khrplatform.h was at commit ID:
 *      67a3e0864c2d75ea5287b9f3d2eb74a745936692
 *
 * Adopters may modify this file to suit their platform. Adopters are
 * encouraged to submit platform specific modifications to the Khronos
 * group so that they can be included in future versions of this file.
 * Please submit changes by filing pull requests or issues on
 * the EGL Registry repository linked above.
 *
 *
 * See the Implementer's Guidelines for information about where this file
 * should be located on your system and for more details of its use:
 *    http://www.khronos.org/registry/implementers_guide.pdf
 *
 * This file should be included as
 *        #include <KHR/khrplatform.h>
 * by Khronos client API header files that use its types and defines.
 *
 * The types in khrplatform.h should only be used to define API-specific types.
 *
 * Types defined in khrplatform.h:
 *    khronos_int8_t              signed   8  bit
 *    khronos_uint8_t             unsigned 8  bit
 *    khronos_int16_t             signed   16 bit
 *    khronos_uint16_t            unsigned 16 bit
 *    khronos_int32_t             signed   32 bit
 *    khronos_uint32_t            unsigned 32 bit
 *    khronos_int64_t             signed   64 bit
 *    khronos_uint64_t            unsigned 64 bit
 *    khronos_intptr_t            signed   same number of bits as a pointer
 *    khronos_uintptr_t           unsigned same number of bits as a pointer
 *    khronos_ssize_t             signed   size
 *    khronos_usize_t             unsigned size
 *    khronos_float_t             signed   32 bit floating point
 *    khronos_time_ns_t           unsigned 64 bit time in nanoseconds
 *    khronos_utime_nanoseconds_t unsigned time interval or absolute time in
 *                                         nanoseconds
 *    khronos_stime_nanoseconds_t signed time interval in nanoseconds
 *    khronos_boolean_enum_t      enumerated boolean type. This should
 *      only be used as a base type when a client API's boolean type is
 *      an enum. Client APIs which use an integer or other type for
 *      booleans cannot use this as the base type for their boolean.
 *
 * Tokens defined in khrplatform.h:
 *
 *    KHRONOS_FALSE, KHRONOS_TRUE Enumerated boolean false/true values.
 *
 *    KHRONOS_SUPPORT_INT64 is 1 if 64 bit integers are supported; otherwise 0.
 *    KHRONOS_SUPPORT_FLOAT is 1 if floats are supported; otherwise 0.
 *
 * Calling convention macros defined in this file:
 *    KHRONOS_APICALL
 *    KHRONOS_APIENTRY
 *    KHRONOS_APIATTRIBUTES
 *
 * These may be used in function prototypes as:
 *
 *      KHRONOS_APICALL void KHRONOS_APIENTRY funcname(
 *                                  int arg1,
 *                                  int arg2) KHRONOS_APIATTRIBUTES;
 */

/*-------------------------------------------------------------------------
 * Definition of KHRONOS_APICALL
 *-------------------------------------------------------------------------
 * This precedes the return type of the function in the function prototype.
 */
#if defined(_WIN32) && !defined(__SCITECH_SNAP__)
#   define KHRONOS_APICALL __declspec(dllimport)
#elif defined (__SYMBIAN32__)
#   define KHRONOS_APICALL IMPORT_C
#elif defined(__ANDROID__)
#   define KHRONOS_APICALL __attribute__((visibility("default")))
#else
#   define KHRONOS_APICALL
#endif

/*-------------------------------------------------------------------------
 * Definition of KHRONOS_APIENTRY
 *-------------------------------------------------------------------------
 * This follows the return type of the function  and precedes the function
 * name in the function prototype.
 */
#if defined(_WIN32) && !defined(_WIN32_WCE) && !defined(__SCITECH_SNAP__)
    /* Win32 but not WinCE */
#   define KHRONOS_APIENTRY __stdcall
#else
#   define KHRONOS_APIENTRY
#endif

/*-------------------------------------------------------------------------
 * Definition of KHRONOS_APIATTRIBUTES
 *-------------------------------------------------------------------------
 * This follows the closing parenthesis of the function prototype arguments.
 */
#if defined (__ARMCC_2__)
#define KHRONOS_APIATTRIBUTES __softfp
#else
#define KHRONOS_APIATTRIBUTES
#endif

/*-------------------------------------------------------------------------
 * basic type definitions
 *-----------------------------------------------------------------------*/
#if (defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L) || defined(__GNUC__) || defined(__SCO__) || defined(__USLC__)


/*
 * Using <stdint.h>
 */
#include <stdint.h>
typedef int32_t                 khronos_int32_t;
typedef uint32_t                khronos_uint32_t;
typedef int64_t                 khronos_int64_t;
typedef uint64_t                khronos_uint64_t;
#define KHRONOS_SUPPORT_INT64   1
#define KHRONOS_SUPPORT_FLOAT   1

#elif defined(__VMS ) || defined(__sgi)

/*
 * Using <inttypes.h>
 */
#include <inttypes.h>
typedef int32_t                 khronos_int32_t;
typedef uint32_t                khronos_uint32_t;
typedef int64_t                 khronos_int64_t;
typedef uint64_t                khronos_uint64_t;
#define KHRONOS_SUPPORT_INT64   1
#define KHRONOS_SUPPORT_FLOAT   1

#elif defined(_WIN32) && !defined(__SCITECH_SNAP__)

/*
 * Win32
 */
typedef __int32                 khronos_int32_t;
typedef unsigned __int32        khronos_uint32_t;
typedef __int64                 khronos_int64_t;
typedef unsigned __int64        khronos_uint64_t;
#define KHRONOS_SUPPORT_INT64   1
#define KHRONOS_SUPPORT_FLOAT   1

#elif defined(__sun__) || defined(__digital__)

/*
 * Sun or Digital
 */
typedef int                     khronos_int32_t;
typedef unsigned int            khronos_uint32_t;
#if defined(__arch64__) || defined(_LP64)
typedef long int                khronos_int64_t;
typedef unsigned long int       khronos_uint64_t;
#else
typedef long long int           khronos_int64_t;
typedef unsigned long long int  khronos_uint64_t;
#endif /* __arch64__ */
#define KHRONOS_SUPPORT_INT64   1
#define KHRONOS_SUPPORT_FLOAT   1

#elif 0

/*
 * Hypothetical platform with no float or int64 support
 */
typedef int                     khronos_int32_t;
typedef unsigned int            khronos_uint32_t;
#define KHRONOS_SUPPORT_INT64   0
#define KHRONOS_SUPPORT_FLOAT   0

#else

/*
 * Generic fallback
 */
#include <stdint.h>
typedef int32_t                 khronos_int32_t;
typedef uint32_t                khronos_uint32_t;
typedef int64_t                 khronos_int64_t;
typedef uint64_t                khronos_uint64_t;
#define KHRONOS_SUPPORT_INT64   1
#define KHRONOS_SUPPORT_FLOAT   1

#endif


/*
 * Types that are (so far) the same on all platforms
 */
typedef signed   char          khronos_int8_t;
typedef unsigned char          khronos_uint8_t;
typedef signed   short int     khronos_int16_t;
typedef unsigned short int     khronos_uint16_t;

/*
 * Types that differ between LLP64 and LP64 architectures - in LLP64,
 * pointers are 64 bits, but 'long' is still 32 bits. Win64 appears
 * to be the only LLP64 architecture in current use.
 */
#ifdef _WIN64
typedef signed   long long int khronos_intptr_t;
typedef unsigned long long int khronos_uintptr_t;
typedef signed   long long int khronos_ssize_t;
typedef unsigned long long int khronos_usize_t;
#else
typedef signed   long  int     khronos_intptr_t;
typedef unsigned long  int     khronos_uintptr_t;
typedef signed   long  int     khronos_ssize_t;
typedef unsigned long  int     khronos_usize_t;
#endif

#if KHRONOS_SUPPORT_FLOAT
/*
 * Float type
 */
typedef          float         khronos_float_t;
#endif

#if KHRONOS_SUPPORT_INT64
/* Time types
 *
 * These types can be used to represent a time interval in nanoseconds or
 * an absolute Unadjusted System Time.  Unadjusted System Time is the number
 * of nanoseconds since some arbitrary system event (e.g. since the last
 * time the system booted).  The Unadjusted System Time is an unsigned
 * 64 bit value that wraps back to 0 every 584 years.  Time intervals
 * may be either signed or unsigned.
 */
typedef khronos_uint64_t       khronos_utime_nanoseconds_t;
typedef khronos_int64_t        khronos_stime_nanoseconds_t;
#endif

/*
 * Dummy value used to pad enum types to 32 bits.
 */
#ifndef KHRONOS_MAX_ENUM
#define KHRONOS_MAX_ENUM 0x7FFFFFFF
#endif

/*
 * Enumerated boolean type
 *
 * Values other than zero should be considered to be true.  Therefore
 * comparisons should not be made against KHRONOS_TRUE.
 */
typedef enum {
    KHRONOS_FALSE = 0,
    KHRONOS_TRUE  = 1,
    KHRONOS_BOOLEAN_ENUM_FORCE_SIZE = KHRONOS_MAX_ENUM
} khronos_boolean_enum_t;

#endif /* __khrplatform_h_ */

```

`sakura/libs/image/soil.cpp`:

```cpp
/*
	Jonathan Dummer
	2007-07-26-10.36

	Simple OpenGL Image Library

	Public Domain
	using Sean Barret's stb_image as a base

	Thanks to:
	* Sean Barret - for the awesome stb_image
	* Dan Venkitachalam - for finding some non-compliant DDS files, and patching some explicit casts
	* everybody at gamedev.net
*/

#pragma warning(disable:4018)
#pragma warning(disable:4996)
#define SOIL_CHECK_FOR_GL_ERRORS 0

#ifdef WIN32
	#define WIN32_LEAN_AND_MEAN
	#include <windows.h>
	#include <wingdi.h>
	#include <GL/gl.h>
#elif defined(__APPLE__) || defined(__APPLE_CC__)
	/*	I can't test this Apple stuff!	*/
	#include <OpenGL/gl.h>
	#include <Carbon/Carbon.h>
	#define APIENTRY
#else
	#include <GL/gl.h>
	#include <GL/glx.h>
#endif

#include "SOIL.h"
#include "stb_image_aug.h"
#include "image_helper.h"
#include "image_DXT.h"

#include <stdlib.h>
#include <string.h>

/*	error reporting	*/
char *result_string_pointer = "SOIL initialized";

/*	for loading cube maps	*/
enum{
	SOIL_CAPABILITY_UNKNOWN = -1,
	SOIL_CAPABILITY_NONE = 0,
	SOIL_CAPABILITY_PRESENT = 1
};
static int has_cubemap_capability = SOIL_CAPABILITY_UNKNOWN;
int query_cubemap_capability( void );
#define SOIL_TEXTURE_WRAP_R					0x8072
#define SOIL_CLAMP_TO_EDGE					0x812F
#define SOIL_NORMAL_MAP						0x8511
#define SOIL_REFLECTION_MAP					0x8512
#define SOIL_TEXTURE_CUBE_MAP				0x8513
#define SOIL_TEXTURE_BINDING_CUBE_MAP		0x8514
#define SOIL_TEXTURE_CUBE_MAP_POSITIVE_X	0x8515
#define SOIL_TEXTURE_CUBE_MAP_NEGATIVE_X	0x8516
#define SOIL_TEXTURE_CUBE_MAP_POSITIVE_Y	0x8517
#define SOIL_TEXTURE_CUBE_MAP_NEGATIVE_Y	0x8518
#define SOIL_TEXTURE_CUBE_MAP_POSITIVE_Z	0x8519
#define SOIL_TEXTURE_CUBE_MAP_NEGATIVE_Z	0x851A
#define SOIL_PROXY_TEXTURE_CUBE_MAP			0x851B
#define SOIL_MAX_CUBE_MAP_TEXTURE_SIZE		0x851C
/*	for non-power-of-two texture	*/
static int has_NPOT_capability = SOIL_CAPABILITY_UNKNOWN;
int query_NPOT_capability( void );
/*	for texture rectangles	*/
static int has_tex_rectangle_capability = SOIL_CAPABILITY_UNKNOWN;
int query_tex_rectangle_capability( void );
#define SOIL_TEXTURE_RECTANGLE_ARB				0x84F5
#define SOIL_MAX_RECTANGLE_TEXTURE_SIZE_ARB		0x84F8
/*	for using DXT compression	*/
static int has_DXT_capability = SOIL_CAPABILITY_UNKNOWN;
int query_DXT_capability( void );
#define SOIL_RGB_S3TC_DXT1		0x83F0
#define SOIL_RGBA_S3TC_DXT1		0x83F1
#define SOIL_RGBA_S3TC_DXT3		0x83F2
#define SOIL_RGBA_S3TC_DXT5		0x83F3
typedef void (APIENTRY * P_SOIL_GLCOMPRESSEDTEXIMAGE2DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid * data);
P_SOIL_GLCOMPRESSEDTEXIMAGE2DPROC soilGlCompressedTexImage2D = NULL;
unsigned int SOIL_direct_load_DDS(
		const char *filename,
		unsigned int reuse_texture_ID,
		int flags,
		int loading_as_cubemap );
unsigned int SOIL_direct_load_DDS_from_memory(
		const unsigned char *const buffer,
		int buffer_length,
		unsigned int reuse_texture_ID,
		int flags,
		int loading_as_cubemap );
/*	other functions	*/
unsigned int
	SOIL_internal_create_OGL_texture
	(
		const unsigned char *const data,
		int width, int height, int channels,
		unsigned int reuse_texture_ID,
		unsigned int flags,
		unsigned int opengl_texture_type,
		unsigned int opengl_texture_target,
		unsigned int texture_check_size_enum
	);

/*	and the code magic begins here [8^)	*/
unsigned int
	SOIL_load_OGL_texture
	(
		const char *filename,
		int force_channels,
		unsigned int reuse_texture_ID,
		unsigned int flags
	)
{
	/*	variables	*/
	unsigned char* img;
	int width, height, channels;
	unsigned int tex_id;
	/*	does the user want direct uploading of the image as a DDS file?	*/
	if( flags & SOIL_FLAG_DDS_LOAD_DIRECT )
	{
		/*	1st try direct loading of the image as a DDS file
			note: direct uploading will only load what is in the
			DDS file, no MIPmaps will be generated, the image will
			not be flipped, etc.	*/
		tex_id = SOIL_direct_load_DDS( filename, reuse_texture_ID, flags, 0 );
		if( tex_id )
		{
			/*	hey, it worked!!	*/
			return tex_id;
		}
	}
	/*	try to load the image	*/
	img = SOIL_load_image( filename, &width, &height, &channels, force_channels );
	/*	channels holds the original number of channels, which may have been forced	*/
	if( (force_channels >= 1) && (force_channels <= 4) )
	{
		channels = force_channels;
	}
	if( NULL == img )
	{
		/*	image loading failed	*/
		result_string_pointer = stbi_failure_reason();
		return 0;
	}
	/*	OK, make it a texture!	*/
	tex_id = SOIL_internal_create_OGL_texture(
			img, width, height, channels,
			reuse_texture_ID, flags,
			GL_TEXTURE_2D, GL_TEXTURE_2D,
			GL_MAX_TEXTURE_SIZE );
	/*	and nuke the image data	*/
	SOIL_free_image_data( img );
	/*	and return the handle, such as it is	*/
	return tex_id;
}

unsigned int
	SOIL_load_OGL_HDR_texture
	(
		const char *filename,
		int fake_HDR_format,
		int rescale_to_max,
		unsigned int reuse_texture_ID,
		unsigned int flags
	)
{
	/*	variables	*/
	unsigned char* img;
	int width, height, channels;
	unsigned int tex_id;
	/*	no direct uploading of the image as a DDS file	*/
	/* error check */
	if( (fake_HDR_format != SOIL_HDR_RGBE) &&
		(fake_HDR_format != SOIL_HDR_RGBdivA) &&
		(fake_HDR_format != SOIL_HDR_RGBdivA2) )
	{
		result_string_pointer = "Invalid fake HDR format specified";
		return 0;
	}
	/*	try to load the image (only the HDR type) */
	img = stbi_hdr_load_rgbe( filename, &width, &height, &channels, 4 );
	/*	channels holds the original number of channels, which may have been forced	*/
	if( NULL == img )
	{
		/*	image loading failed	*/
		result_string_pointer = stbi_failure_reason();
		return 0;
	}
	/* the load worked, do I need to convert it? */
	if( fake_HDR_format == SOIL_HDR_RGBdivA )
	{
		RGBE_to_RGBdivA( img, width, height, rescale_to_max );
	} else if( fake_HDR_format == SOIL_HDR_RGBdivA2 )
	{
		RGBE_to_RGBdivA2( img, width, height, rescale_to_max );
	}
	/*	OK, make it a texture!	*/
	tex_id = SOIL_internal_create_OGL_texture(
			img, width, height, channels,
			reuse_texture_ID, flags,
			GL_TEXTURE_2D, GL_TEXTURE_2D,
			GL_MAX_TEXTURE_SIZE );
	/*	and nuke the image data	*/
	SOIL_free_image_data( img );
	/*	and return the handle, such as it is	*/
	return tex_id;
}

unsigned int
	SOIL_load_OGL_texture_from_memory
	(
		const unsigned char *const buffer,
		int buffer_length,
		int force_channels,
		unsigned int reuse_texture_ID,
		unsigned int flags
	)
{
	/*	variables	*/
	unsigned char* img;
	int width, height, channels;
	unsigned int tex_id;
	/*	does the user want direct uploading of the image as a DDS file?	*/
	if( flags & SOIL_FLAG_DDS_LOAD_DIRECT )
	{
		/*	1st try direct loading of the image as a DDS file
			note: direct uploading will only load what is in the
			DDS file, no MIPmaps will be generated, the image will
			not be flipped, etc.	*/
		tex_id = SOIL_direct_load_DDS_from_memory(
				buffer, buffer_length,
				reuse_texture_ID, flags, 0 );
		if( tex_id )
		{
			/*	hey, it worked!!	*/
			return tex_id;
		}
	}
	/*	try to load the image	*/
	img = SOIL_load_image_from_memory(
					buffer, buffer_length,
					&width, &height, &channels,
					force_channels );
	/*	channels holds the original number of channels, which may have been forced	*/
	if( (force_channels >= 1) && (force_channels <= 4) )
	{
		channels = force_channels;
	}
	if( NULL == img )
	{
		/*	image loading failed	*/
		result_string_pointer = stbi_failure_reason();
		return 0;
	}
	/*	OK, make it a texture!	*/
	tex_id = SOIL_internal_create_OGL_texture(
			img, width, height, channels,
			reuse_texture_ID, flags,
			GL_TEXTURE_2D, GL_TEXTURE_2D,
			GL_MAX_TEXTURE_SIZE );
	/*	and nuke the image data	*/
	SOIL_free_image_data( img );
	/*	and return the handle, such as it is	*/
	return tex_id;
}

unsigned int
	SOIL_load_OGL_cubemap
	(
		const char *x_pos_file,
		const char *x_neg_file,
		const char *y_pos_file,
		const char *y_neg_file,
		const char *z_pos_file,
		const char *z_neg_file,
		int force_channels,
		unsigned int reuse_texture_ID,
		unsigned int flags
	)
{
	/*	variables	*/
	unsigned char* img;
	int width, height, channels;
	unsigned int tex_id;
	/*	error checking	*/
	if( (x_pos_file == NULL) ||
		(x_neg_file == NULL) ||
		(y_pos_file == NULL) ||
		(y_neg_file == NULL) ||
		(z_pos_file == NULL) ||
		(z_neg_file == NULL) )
	{
		result_string_pointer = "Invalid cube map files list";
		return 0;
	}
	/*	capability checking	*/
	if( query_cubemap_capability() != SOIL_CAPABILITY_PRESENT )
	{
		result_string_pointer = "No cube map capability present";
		return 0;
	}
	/*	1st face: try to load the image	*/
	img = SOIL_load_image( x_pos_file, &width, &height, &channels, force_channels );
	/*	channels holds the original number of channels, which may have been forced	*/
	if( (force_channels >= 1) && (force_channels <= 4) )
	{
		channels = force_channels;
	}
	if( NULL == img )
	{
		/*	image loading failed	*/
		result_string_pointer = stbi_failure_reason();
		return 0;
	}
	/*	upload the texture, and create a texture ID if necessary	*/
	tex_id = SOIL_internal_create_OGL_texture(
			img, width, height, channels,
			reuse_texture_ID, flags,
			SOIL_TEXTURE_CUBE_MAP, SOIL_TEXTURE_CUBE_MAP_POSITIVE_X,
			SOIL_MAX_CUBE_MAP_TEXTURE_SIZE );
	/*	and nuke the image data	*/
	SOIL_free_image_data( img );
	/*	continue?	*/
	if( tex_id != 0 )
	{
		/*	1st face: try to load the image	*/
		img = SOIL_load_image( x_neg_file, &width, &height, &channels, force_channels );
		/*	channels holds the original number of channels, which may have been forced	*/
		if( (force_channels >= 1) && (force_channels <= 4) )
		{
			channels = force_channels;
		}
		if( NULL == img )
		{
			/*	image loading failed	*/
			result_string_pointer = stbi_failure_reason();
			return 0;
		}
		/*	upload the texture, but reuse the assigned texture ID	*/
		tex_id = SOIL_internal_create_OGL_texture(
				img, width, height, channels,
				tex_id, flags,
				SOIL_TEXTURE_CUBE_MAP, SOIL_TEXTURE_CUBE_MAP_NEGATIVE_X,
				SOIL_MAX_CUBE_MAP_TEXTURE_SIZE );
		/*	and nuke the image data	*/
		SOIL_free_image_data( img );
	}
	/*	continue?	*/
	if( tex_id != 0 )
	{
		/*	1st face: try to load the image	*/
		img = SOIL_load_image( y_pos_file, &width, &height, &channels, force_channels );
		/*	channels holds the original number of channels, which may have been forced	*/
		if( (force_channels >= 1) && (force_channels <= 4) )
		{
			channels = force_channels;
		}
		if( NULL == img )
		{
			/*	image loading failed	*/
			result_string_pointer = stbi_failure_reason();
			return 0;
		}
		/*	upload the texture, but reuse the assigned texture ID	*/
		tex_id = SOIL_internal_create_OGL_texture(
				img, width, height, channels,
				tex_id, flags,
				SOIL_TEXTURE_CUBE_MAP, SOIL_TEXTURE_CUBE_MAP_POSITIVE_Y,
				SOIL_MAX_CUBE_MAP_TEXTURE_SIZE );
		/*	and nuke the image data	*/
		SOIL_free_image_data( img );
	}
	/*	continue?	*/
	if( tex_id != 0 )
	{
		/*	1st face: try to load the image	*/
		img = SOIL_load_image( y_neg_file, &width, &height, &channels, force_channels );
		/*	channels holds the original number of channels, which may have been forced	*/
		if( (force_channels >= 1) && (force_channels <= 4) )
		{
			channels = force_channels;
		}
		if( NULL == img )
		{
			/*	image loading failed	*/
			result_string_pointer = stbi_failure_reason();
			return 0;
		}
		/*	upload the texture, but reuse the assigned texture ID	*/
		tex_id = SOIL_internal_create_OGL_texture(
				img, width, height, channels,
				tex_id, flags,
				SOIL_TEXTURE_CUBE_MAP, SOIL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
				SOIL_MAX_CUBE_MAP_TEXTURE_SIZE );
		/*	and nuke the image data	*/
		SOIL_free_image_data( img );
	}
	/*	continue?	*/
	if( tex_id != 0 )
	{
		/*	1st face: try to load the image	*/
		img = SOIL_load_image( z_pos_file, &width, &height, &channels, force_channels );
		/*	channels holds the original number of channels, which may have been forced	*/
		if( (force_channels >= 1) && (force_channels <= 4) )
		{
			channels = force_channels;
		}
		if( NULL == img )
		{
			/*	image loading failed	*/
			result_string_pointer = stbi_failure_reason();
			return 0;
		}
		/*	upload the texture, but reuse the assigned texture ID	*/
		tex_id = SOIL_internal_create_OGL_texture(
				img, width, height, channels,
				tex_id, flags,
				SOIL_TEXTURE_CUBE_MAP, SOIL_TEXTURE_CUBE_MAP_POSITIVE_Z,
				SOIL_MAX_CUBE_MAP_TEXTURE_SIZE );
		/*	and nuke the image data	*/
		SOIL_free_image_data( img );
	}
	/*	continue?	*/
	if( tex_id != 0 )
	{
		/*	1st face: try to load the image	*/
		img = SOIL_load_image( z_neg_file, &width, &height, &channels, force_channels );
		/*	channels holds the original number of channels, which may have been forced	*/
		if( (force_channels >= 1) && (force_channels <= 4) )
		{
			channels = force_channels;
		}
		if( NULL == img )
		{
			/*	image loading failed	*/
			result_string_pointer = stbi_failure_reason();
			return 0;
		}
		/*	upload the texture, but reuse the assigned texture ID	*/
		tex_id = SOIL_internal_create_OGL_texture(
				img, width, height, channels,
				tex_id, flags,
				SOIL_TEXTURE_CUBE_MAP, SOIL_TEXTURE_CUBE_MAP_NEGATIVE_Z,
				SOIL_MAX_CUBE_MAP_TEXTURE_SIZE );
		/*	and nuke the image data	*/
		SOIL_free_image_data( img );
	}
	/*	and return the handle, such as it is	*/
	return tex_id;
}

unsigned int
	SOIL_load_OGL_cubemap_from_memory
	(
		const unsigned char *const x_pos_buffer,
		int x_pos_buffer_length,
		const unsigned char *const x_neg_buffer,
		int x_neg_buffer_length,
		const unsigned char *const y_pos_buffer,
		int y_pos_buffer_length,
		const unsigned char *const y_neg_buffer,
		int y_neg_buffer_length,
		const unsigned char *const z_pos_buffer,
		int z_pos_buffer_length,
		const unsigned char *const z_neg_buffer,
		int z_neg_buffer_length,
		int force_channels,
		unsigned int reuse_texture_ID,
		unsigned int flags
	)
{
	/*	variables	*/
	unsigned char* img;
	int width, height, channels;
	unsigned int tex_id;
	/*	error checking	*/
	if( (x_pos_buffer == NULL) ||
		(x_neg_buffer == NULL) ||
		(y_pos_buffer == NULL) ||
		(y_neg_buffer == NULL) ||
		(z_pos_buffer == NULL) ||
		(z_neg_buffer == NULL) )
	{
		result_string_pointer = "Invalid cube map buffers list";
		return 0;
	}
	/*	capability checking	*/
	if( query_cubemap_capability() != SOIL_CAPABILITY_PRESENT )
	{
		result_string_pointer = "No cube map capability present";
		return 0;
	}
	/*	1st face: try to load the image	*/
	img = SOIL_load_image_from_memory(
			x_pos_buffer, x_pos_buffer_length,
			&width, &height, &channels, force_channels );
	/*	channels holds the original number of channels, which may have been forced	*/
	if( (force_channels >= 1) && (force_channels <= 4) )
	{
		channels = force_channels;
	}
	if( NULL == img )
	{
		/*	image loading failed	*/
		result_string_pointer = stbi_failure_reason();
		return 0;
	}
	/*	upload the texture, and create a texture ID if necessary	*/
	tex_id = SOIL_internal_create_OGL_texture(
			img, width, height, channels,
			reuse_texture_ID, flags,
			SOIL_TEXTURE_CUBE_MAP, SOIL_TEXTURE_CUBE_MAP_POSITIVE_X,
			SOIL_MAX_CUBE_MAP_TEXTURE_SIZE );
	/*	and nuke the image data	*/
	SOIL_free_image_data( img );
	/*	continue?	*/
	if( tex_id != 0 )
	{
		/*	1st face: try to load the image	*/
		img = SOIL_load_image_from_memory(
				x_neg_buffer, x_neg_buffer_length,
				&width, &height, &channels, force_channels );
		/*	channels holds the original number of channels, which may have been forced	*/
		if( (force_channels >= 1) && (force_channels <= 4) )
		{
			channels = force_channels;
		}
		if( NULL == img )
		{
			/*	image loading failed	*/
			result_string_pointer = stbi_failure_reason();
			return 0;
		}
		/*	upload the texture, but reuse the assigned texture ID	*/
		tex_id = SOIL_internal_create_OGL_texture(
				img, width, height, channels,
				tex_id, flags,
				SOIL_TEXTURE_CUBE_MAP, SOIL_TEXTURE_CUBE_MAP_NEGATIVE_X,
				SOIL_MAX_CUBE_MAP_TEXTURE_SIZE );
		/*	and nuke the image data	*/
		SOIL_free_image_data( img );
	}
	/*	continue?	*/
	if( tex_id != 0 )
	{
		/*	1st face: try to load the image	*/
		img = SOIL_load_image_from_memory(
				y_pos_buffer, y_pos_buffer_length,
				&width, &height, &channels, force_channels );
		/*	channels holds the original number of channels, which may have been forced	*/
		if( (force_channels >= 1) && (force_channels <= 4) )
		{
			channels = force_channels;
		}
		if( NULL == img )
		{
			/*	image loading failed	*/
			result_string_pointer = stbi_failure_reason();
			return 0;
		}
		/*	upload the texture, but reuse the assigned texture ID	*/
		tex_id = SOIL_internal_create_OGL_texture(
				img, width, height, channels,
				tex_id, flags,
				SOIL_TEXTURE_CUBE_MAP, SOIL_TEXTURE_CUBE_MAP_POSITIVE_Y,
				SOIL_MAX_CUBE_MAP_TEXTURE_SIZE );
		/*	and nuke the image data	*/
		SOIL_free_image_data( img );
	}
	/*	continue?	*/
	if( tex_id != 0 )
	{
		/*	1st face: try to load the image	*/
		img = SOIL_load_image_from_memory(
				y_neg_buffer, y_neg_buffer_length,
				&width, &height, &channels, force_channels );
		/*	channels holds the original number of channels, which may have been forced	*/
		if( (force_channels >= 1) && (force_channels <= 4) )
		{
			channels = force_channels;
		}
		if( NULL == img )
		{
			/*	image loading failed	*/
			result_string_pointer = stbi_failure_reason();
			return 0;
		}
		/*	upload the texture, but reuse the assigned texture ID	*/
		tex_id = SOIL_internal_create_OGL_texture(
				img, width, height, channels,
				tex_id, flags,
				SOIL_TEXTURE_CUBE_MAP, SOIL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
				SOIL_MAX_CUBE_MAP_TEXTURE_SIZE );
		/*	and nuke the image data	*/
		SOIL_free_image_data( img );
	}
	/*	continue?	*/
	if( tex_id != 0 )
	{
		/*	1st face: try to load the image	*/
		img = SOIL_load_image_from_memory(
				z_pos_buffer, z_pos_buffer_length,
				&width, &height, &channels, force_channels );
		/*	channels holds the original number of channels, which may have been forced	*/
		if( (force_channels >= 1) && (force_channels <= 4) )
		{
			channels = force_channels;
		}
		if( NULL == img )
		{
			/*	image loading failed	*/
			result_string_pointer = stbi_failure_reason();
			return 0;
		}
		/*	upload the texture, but reuse the assigned texture ID	*/
		tex_id = SOIL_internal_create_OGL_texture(
				img, width, height, channels,
				tex_id, flags,
				SOIL_TEXTURE_CUBE_MAP, SOIL_TEXTURE_CUBE_MAP_POSITIVE_Z,
				SOIL_MAX_CUBE_MAP_TEXTURE_SIZE );
		/*	and nuke the image data	*/
		SOIL_free_image_data( img );
	}
	/*	continue?	*/
	if( tex_id != 0 )
	{
		/*	1st face: try to load the image	*/
		img = SOIL_load_image_from_memory(
				z_neg_buffer, z_neg_buffer_length,
				&width, &height, &channels, force_channels );
		/*	channels holds the original number of channels, which may have been forced	*/
		if( (force_channels >= 1) && (force_channels <= 4) )
		{
			channels = force_channels;
		}
		if( NULL == img )
		{
			/*	image loading failed	*/
			result_string_pointer = stbi_failure_reason();
			return 0;
		}
		/*	upload the texture, but reuse the assigned texture ID	*/
		tex_id = SOIL_internal_create_OGL_texture(
				img, width, height, channels,
				tex_id, flags,
				SOIL_TEXTURE_CUBE_MAP, SOIL_TEXTURE_CUBE_MAP_NEGATIVE_Z,
				SOIL_MAX_CUBE_MAP_TEXTURE_SIZE );
		/*	and nuke the image data	*/
		SOIL_free_image_data( img );
	}
	/*	and return the handle, such as it is	*/
	return tex_id;
}

unsigned int
	SOIL_load_OGL_single_cubemap
	(
		const char *filename,
		const char face_order[6],
		int force_channels,
		unsigned int reuse_texture_ID,
		unsigned int flags
	)
{
	/*	variables	*/
	unsigned char* img;
	int width, height, channels, i;
	unsigned int tex_id = 0;
	/*	error checking	*/
	if( filename == NULL )
	{
		result_string_pointer = "Invalid single cube map file name";
		return 0;
	}
	/*	does the user want direct uploading of the image as a DDS file?	*/
	if( flags & SOIL_FLAG_DDS_LOAD_DIRECT )
	{
		/*	1st try direct loading of the image as a DDS file
			note: direct uploading will only load what is in the
			DDS file, no MIPmaps will be generated, the image will
			not be flipped, etc.	*/
		tex_id = SOIL_direct_load_DDS( filename, reuse_texture_ID, flags, 1 );
		if( tex_id )
		{
			/*	hey, it worked!!	*/
			return tex_id;
		}
	}
	/*	face order checking	*/
	for( i = 0; i < 6; ++i )
	{
		if( (face_order[i] != 'N') &&
			(face_order[i] != 'S') &&
			(face_order[i] != 'W') &&
			(face_order[i] != 'E') &&
			(face_order[i] != 'U') &&
			(face_order[i] != 'D') )
		{
			result_string_pointer = "Invalid single cube map face order";
			return 0;
		};
	}
	/*	capability checking	*/
	if( query_cubemap_capability() != SOIL_CAPABILITY_PRESENT )
	{
		result_string_pointer = "No cube map capability present";
		return 0;
	}
	/*	1st off, try to load the full image	*/
	img = SOIL_load_image( filename, &width, &height, &channels, force_channels );
	/*	channels holds the original number of channels, which may have been forced	*/
	if( (force_channels >= 1) && (force_channels <= 4) )
	{
		channels = force_channels;
	}
	if( NULL == img )
	{
		/*	image loading failed	*/
		result_string_pointer = stbi_failure_reason();
		return 0;
	}
	/*	now, does this image have the right dimensions?	*/
	if( (width != 6*height) &&
		(6*width != height) )
	{
		SOIL_free_image_data( img );
		result_string_pointer = "Single cubemap image must have a 6:1 ratio";
		return 0;
	}
	/*	try the image split and create	*/
	tex_id = SOIL_create_OGL_single_cubemap(
			img, width, height, channels,
			face_order, reuse_texture_ID, flags
			);
	/*	nuke the temporary image data and return the texture handle	*/
	SOIL_free_image_data( img );
	return tex_id;
}

unsigned int
	SOIL_load_OGL_single_cubemap_from_memory
	(
		const unsigned char *const buffer,
		int buffer_length,
		const char face_order[6],
		int force_channels,
		unsigned int reuse_texture_ID,
		unsigned int flags
	)
{
	/*	variables	*/
	unsigned char* img;
	int width, height, channels, i;
	unsigned int tex_id = 0;
	/*	error checking	*/
	if( buffer == NULL )
	{
		result_string_pointer = "Invalid single cube map buffer";
		return 0;
	}
	/*	does the user want direct uploading of the image as a DDS file?	*/
	if( flags & SOIL_FLAG_DDS_LOAD_DIRECT )
	{
		/*	1st try direct loading of the image as a DDS file
			note: direct uploading will only load what is in the
			DDS file, no MIPmaps will be generated, the image will
			not be flipped, etc.	*/
		tex_id = SOIL_direct_load_DDS_from_memory(
				buffer, buffer_length,
				reuse_texture_ID, flags, 1 );
		if( tex_id )
		{
			/*	hey, it worked!!	*/
			return tex_id;
		}
	}
	/*	face order checking	*/
	for( i = 0; i < 6; ++i )
	{
		if( (face_order[i] != 'N') &&
			(face_order[i] != 'S') &&
			(face_order[i] != 'W') &&
			(face_order[i] != 'E') &&
			(face_order[i] != 'U') &&
			(face_order[i] != 'D') )
		{
			result_string_pointer = "Invalid single cube map face order";
			return 0;
		};
	}
	/*	capability checking	*/
	if( query_cubemap_capability() != SOIL_CAPABILITY_PRESENT )
	{
		result_string_pointer = "No cube map capability present";
		return 0;
	}
	/*	1st off, try to load the full image	*/
	img = SOIL_load_image_from_memory(
			buffer, buffer_length,
			&width, &height, &channels,
			force_channels );
	/*	channels holds the original number of channels, which may have been forced	*/
	if( (force_channels >= 1) && (force_channels <= 4) )
	{
		channels = force_channels;
	}
	if( NULL == img )
	{
		/*	image loading failed	*/
		result_string_pointer = stbi_failure_reason();
		return 0;
	}
	/*	now, does this image have the right dimensions?	*/
	if( (width != 6*height) &&
		(6*width != height) )
	{
		SOIL_free_image_data( img );
		result_string_pointer = "Single cubemap image must have a 6:1 ratio";
		return 0;
	}
	/*	try the image split and create	*/
	tex_id = SOIL_create_OGL_single_cubemap(
			img, width, height, channels,
			face_order, reuse_texture_ID, flags
			);
	/*	nuke the temporary image data and return the texture handle	*/
	SOIL_free_image_data( img );
	return tex_id;
}

unsigned int
	SOIL_create_OGL_single_cubemap
	(
		const unsigned char *const data,
		int width, int height, int channels,
		const char face_order[6],
		unsigned int reuse_texture_ID,
		unsigned int flags
	)
{
	/*	variables	*/
	unsigned char* sub_img;
	int dw, dh, sz, i;
	unsigned int tex_id;
	/*	error checking	*/
	if( data == NULL )
	{
		result_string_pointer = "Invalid single cube map image data";
		return 0;
	}
	/*	face order checking	*/
	for( i = 0; i < 6; ++i )
	{
		if( (face_order[i] != 'N') &&
			(face_order[i] != 'S') &&
			(face_order[i] != 'W') &&
			(face_order[i] != 'E') &&
			(face_order[i] != 'U') &&
			(face_order[i] != 'D') )
		{
			result_string_pointer = "Invalid single cube map face order";
			return 0;
		};
	}
	/*	capability checking	*/
	if( query_cubemap_capability() != SOIL_CAPABILITY_PRESENT )
	{
		result_string_pointer = "No cube map capability present";
		return 0;
	}
	/*	now, does this image have the right dimensions?	*/
	if( (width != 6*height) &&
		(6*width != height) )
	{
		result_string_pointer = "Single cubemap image must have a 6:1 ratio";
		return 0;
	}
	/*	which way am I stepping?	*/
	if( width > height )
	{
		dw = height;
		dh = 0;
	} else
	{
		dw = 0;
		dh = width;
	}
	sz = dw+dh;
	sub_img = (unsigned char *)malloc( sz*sz*channels );
	/*	do the splitting and uploading	*/
	tex_id = reuse_texture_ID;
	for( i = 0; i < 6; ++i )
	{
		int x, y, idx = 0;
		unsigned int cubemap_target = 0;
		/*	copy in the sub-image	*/
		for( y = i*dh; y < i*dh+sz; ++y )
		{
			for( x = i*dw*channels; x < (i*dw+sz)*channels; ++x )
			{
				sub_img[idx++] = data[y*width*channels+x];
			}
		}
		/*	what is my texture target?
			remember, this coordinate system is
			LHS if viewed from inside the cube!	*/
		switch( face_order[i] )
		{
		case 'N':
			cubemap_target = SOIL_TEXTURE_CUBE_MAP_POSITIVE_Z;
			break;
		case 'S':
			cubemap_target = SOIL_TEXTURE_CUBE_MAP_NEGATIVE_Z;
			break;
		case 'W':
			cubemap_target = SOIL_TEXTURE_CUBE_MAP_NEGATIVE_X;
			break;
		case 'E':
			cubemap_target = SOIL_TEXTURE_CUBE_MAP_POSITIVE_X;
			break;
		case 'U':
			cubemap_target = SOIL_TEXTURE_CUBE_MAP_POSITIVE_Y;
			break;
		case 'D':
			cubemap_target = SOIL_TEXTURE_CUBE_MAP_NEGATIVE_Y;
			break;
		}
		/*	upload it as a texture	*/
		tex_id = SOIL_internal_create_OGL_texture(
				sub_img, sz, sz, channels,
				tex_id, flags,
				SOIL_TEXTURE_CUBE_MAP,
				cubemap_target,
				SOIL_MAX_CUBE_MAP_TEXTURE_SIZE );
	}
	/*	and nuke the image and sub-image data	*/
	SOIL_free_image_data( sub_img );
	/*	and return the handle, such as it is	*/
	return tex_id;
}

unsigned int
	SOIL_create_OGL_texture
	(
		const unsigned char *const data,
		int width, int height, int channels,
		unsigned int reuse_texture_ID,
		unsigned int flags
	)
{
	/*	wrapper function for 2D textures	*/
	return SOIL_internal_create_OGL_texture(
				data, width, height, channels,
				reuse_texture_ID, flags,
				GL_TEXTURE_2D, GL_TEXTURE_2D,
				GL_MAX_TEXTURE_SIZE );
}

#if SOIL_CHECK_FOR_GL_ERRORS
void check_for_GL_errors( const char *calling_location )
{
	/*	check for errors	*/
	GLenum err_code = glGetError();
	while( GL_NO_ERROR != err_code )
	{
		printf( "OpenGL Error @ %s: %i", calling_location, err_code );
		err_code = glGetError();
	}
}
#else
void check_for_GL_errors( const char *calling_location )
{
	/*	no check for errors	*/
}
#endif

unsigned int
	SOIL_internal_create_OGL_texture
	(
		const unsigned char *const data,
		int width, int height, int channels,
		unsigned int reuse_texture_ID,
		unsigned int flags,
		unsigned int opengl_texture_type,
		unsigned int opengl_texture_target,
		unsigned int texture_check_size_enum
	)
{
	/*	variables	*/
	unsigned char* img;
	unsigned int tex_id;
	unsigned int internal_texture_format = 0, original_texture_format = 0;
	int DXT_mode = SOIL_CAPABILITY_UNKNOWN;
	int max_supported_size;
	/*	If the user wants to use the texture rectangle I kill a few flags	*/
	if( flags & SOIL_FLAG_TEXTURE_RECTANGLE )
	{
		/*	well, the user asked for it, can we do that?	*/
		if( query_tex_rectangle_capability() == SOIL_CAPABILITY_PRESENT )
		{
			/*	only allow this if the user in _NOT_ trying to do a cubemap!	*/
			if( opengl_texture_type == GL_TEXTURE_2D )
			{
				/*	clean out the flags that cannot be used with texture rectangles	*/
				flags &= ~(
						SOIL_FLAG_POWER_OF_TWO | SOIL_FLAG_MIPMAPS |
						SOIL_FLAG_TEXTURE_REPEATS
					);
				/*	and change my target	*/
				opengl_texture_target = SOIL_TEXTURE_RECTANGLE_ARB;
				opengl_texture_type = SOIL_TEXTURE_RECTANGLE_ARB;
			} else
			{
				/*	not allowed for any other uses (yes, I'm looking at you, cubemaps!)	*/
				flags &= ~SOIL_FLAG_TEXTURE_RECTANGLE;
			}

		} else
		{
			/*	can't do it, and that is a breakable offense (uv coords use pixels instead of [0,1]!)	*/
			result_string_pointer = "Texture Rectangle extension unsupported";
			return 0;
		}
	}
	/*	create a copy the image data	*/
	img = (unsigned char*)malloc( width*height*channels );
	memcpy( img, data, width*height*channels );
	/*	does the user want me to invert the image?	*/
	if( flags & SOIL_FLAG_INVERT_Y )
	{
		int i, j;
		for( j = 0; j*2 < height; ++j )
		{
			int index1 = j * width * channels;
			int index2 = (height - 1 - j) * width * channels;
			for( i = width * channels; i > 0; --i )
			{
				unsigned char temp = img[index1];
				img[index1] = img[index2];
				img[index2] = temp;
				++index1;
				++index2;
			}
		}
	}
	/*	does the user want me to scale the colors into the NTSC safe RGB range?	*/
	if( flags & SOIL_FLAG_NTSC_SAFE_RGB )
	{
		scale_image_RGB_to_NTSC_safe( img, width, height, channels );
	}
	/*	does the user want me to convert from straight to pre-multiplied alpha?
		(and do we even _have_ alpha?)	*/
	if( flags & SOIL_FLAG_MULTIPLY_ALPHA )
	{
		int i;
		switch( channels )
		{
		case 2:
			for( i = 0; i < 2*width*height; i += 2 )
			{
				img[i] = (img[i] * img[i+1] + 128) >> 8;
			}
			break;
		case 4:
			for( i = 0; i < 4*width*height; i += 4 )
			{
				img[i+0] = (img[i+0] * img[i+3] + 128) >> 8;
				img[i+1] = (img[i+1] * img[i+3] + 128) >> 8;
				img[i+2] = (img[i+2] * img[i+3] + 128) >> 8;
			}
			break;
		default:
			/*	no other number of channels contains alpha data	*/
			break;
		}
	}
	/*	if the user can't support NPOT textures, make sure we force the POT option	*/
	if( (query_NPOT_capability() == SOIL_CAPABILITY_NONE) &&
		!(flags & SOIL_FLAG_TEXTURE_RECTANGLE) )
	{
		/*	add in the POT flag */
		flags |= SOIL_FLAG_POWER_OF_TWO;
	}
	/*	how large of a texture can this OpenGL implementation handle?	*/
	/*	texture_check_size_enum will be GL_MAX_TEXTURE_SIZE or SOIL_MAX_CUBE_MAP_TEXTURE_SIZE	*/
	glGetIntegerv( texture_check_size_enum, &max_supported_size );
	/*	do I need to make it a power of 2?	*/
	if(
		(flags & SOIL_FLAG_POWER_OF_TWO) ||	/*	user asked for it	*/
		(flags & SOIL_FLAG_MIPMAPS) ||		/*	need it for the MIP-maps	*/
		(width > max_supported_size) ||		/*	it's too big, (make sure it's	*/
		(height > max_supported_size) )		/*	2^n for later down-sampling)	*/
	{
		int new_width = 1;
		int new_height = 1;
		while( new_width < width )
		{
			new_width *= 2;
		}
		while( new_height < height )
		{
			new_height *= 2;
		}
		/*	still?	*/
		if( (new_width != width) || (new_height != height) )
		{
			/*	yep, resize	*/
			unsigned char *resampled = (unsigned char*)malloc( channels*new_width*new_height );
			up_scale_image(
					img, width, height, channels,
					resampled, new_width, new_height );
			/*	OJO	this is for debug only!	*/
			/*
			SOIL_save_image( "\\showme.bmp", SOIL_SAVE_TYPE_BMP,
							new_width, new_height, channels,
							resampled );
			*/
			/*	nuke the old guy, then point it at the new guy	*/
			SOIL_free_image_data( img );
			img = resampled;
			width = new_width;
			height = new_height;
		}
	}
	/*	now, if it is too large...	*/
	if( (width > max_supported_size) || (height > max_supported_size) )
	{
		/*	I've already made it a power of two, so simply use the MIPmapping
			code to reduce its size to the allowable maximum.	*/
		unsigned char *resampled;
		int reduce_block_x = 1, reduce_block_y = 1;
		int new_width, new_height;
		if( width > max_supported_size )
		{
			reduce_block_x = width / max_supported_size;
		}
		if( height > max_supported_size )
		{
			reduce_block_y = height / max_supported_size;
		}
		new_width = width / reduce_block_x;
		new_height = height / reduce_block_y;
		resampled = (unsigned char*)malloc( channels*new_width*new_height );
		/*	perform the actual reduction	*/
		mipmap_image(	img, width, height, channels,
						resampled, reduce_block_x, reduce_block_y );
		/*	nuke the old guy, then point it at the new guy	*/
		SOIL_free_image_data( img );
		img = resampled;
		width = new_width;
		height = new_height;
	}
	/*	does the user want us to use YCoCg color space?	*/
	if( flags & SOIL_FLAG_CoCg_Y )
	{
		/*	this will only work with RGB and RGBA images */
		convert_RGB_to_YCoCg( img, width, height, channels );
		/*
		save_image_as_DDS( "CoCg_Y.dds", width, height, channels, img );
		*/
	}
	/*	create the OpenGL texture ID handle
    	(note: allowing a forced texture ID lets me reload a texture)	*/
    tex_id = reuse_texture_ID;
    if( tex_id == 0 )
    {
		glGenTextures( 1, &tex_id );
    }
	check_for_GL_errors( "glGenTextures" );
	/* Note: sometimes glGenTextures fails (usually no OpenGL context)	*/
	if( tex_id )
	{
		/*	and what type am I using as the internal texture format?	*/
		switch( channels )
		{
		case 1:
			original_texture_format = GL_LUMINANCE;
			break;
		case 2:
			original_texture_format = GL_LUMINANCE_ALPHA;
			break;
		case 3:
			original_texture_format = GL_RGB;
			break;
		case 4:
			original_texture_format = GL_RGBA;
			break;
		}
		internal_texture_format = original_texture_format;
		/*	does the user want me to, and can I, save as DXT?	*/
		if( flags & SOIL_FLAG_COMPRESS_TO_DXT )
		{
			DXT_mode = query_DXT_capability();
			if( DXT_mode == SOIL_CAPABILITY_PRESENT )
			{
				/*	I can use DXT, whether I compress it or OpenGL does	*/
				if( (channels & 1) == 1 )
				{
					/*	1 or 3 channels = DXT1	*/
					internal_texture_format = SOIL_RGB_S3TC_DXT1;
				} else
				{
					/*	2 or 4 channels = DXT5	*/
					internal_texture_format = SOIL_RGBA_S3TC_DXT5;
				}
			}
		}
		/*  bind an OpenGL texture ID	*/
		glBindTexture( opengl_texture_type, tex_id );
		check_for_GL_errors( "glBindTexture" );
		/*  upload the main image	*/
		if( DXT_mode == SOIL_CAPABILITY_PRESENT )
		{
			/*	user wants me to do the DXT conversion!	*/
			int DDS_size;
			unsigned char *DDS_data = NULL;
			if( (channels & 1) == 1 )
			{
				/*	RGB, use DXT1	*/
				DDS_data = convert_image_to_DXT1( img, width, height, channels, &DDS_size );
			} else
			{
				/*	RGBA, use DXT5	*/
				DDS_data = convert_image_to_DXT5( img, width, height, channels, &DDS_size );
			}
			if( DDS_data )
			{
				soilGlCompressedTexImage2D(
					opengl_texture_target, 0,
					internal_texture_format, width, height, 0,
					DDS_size, DDS_data );
				check_for_GL_errors( "glCompressedTexImage2D" );
				SOIL_free_image_data( DDS_data );
				/*	printf( "Internal DXT compressor\n" );	*/
			} else
			{
				/*	my compression failed, try the OpenGL driver's version	*/
				glTexImage2D(
					opengl_texture_target, 0,
					internal_texture_format, width, height, 0,
					original_texture_format, GL_UNSIGNED_BYTE, img );
				check_for_GL_errors( "glTexImage2D" );
				/*	printf( "OpenGL DXT compressor\n" );	*/
			}
		} else
		{
			/*	user want OpenGL to do all the work!	*/
			glTexImage2D(
				opengl_texture_target, 0,
				internal_texture_format, width, height, 0,
				original_texture_format, GL_UNSIGNED_BYTE, img );
			check_for_GL_errors( "glTexImage2D" );
			/*printf( "OpenGL DXT compressor\n" );	*/
		}
		/*	are any MIPmaps desired?	*/
		if( flags & SOIL_FLAG_MIPMAPS )
		{
			int MIPlevel = 1;
			int MIPwidth = (width+1) / 2;
			int MIPheight = (height+1) / 2;
			unsigned char *resampled = (unsigned char*)malloc( channels*MIPwidth*MIPheight );
			while( ((1<<MIPlevel) <= width) || ((1<<MIPlevel) <= height) )
			{
				/*	do this MIPmap level	*/
				mipmap_image(
						img, width, height, channels,
						resampled,
						(1 << MIPlevel), (1 << MIPlevel) );
				/*  upload the MIPmaps	*/
				if( DXT_mode == SOIL_CAPABILITY_PRESENT )
				{
					/*	user wants me to do the DXT conversion!	*/
					int DDS_size;
					unsigned char *DDS_data = NULL;
					if( (channels & 1) == 1 )
					{
						/*	RGB, use DXT1	*/
						DDS_data = convert_image_to_DXT1(
								resampled, MIPwidth, MIPheight, channels, &DDS_size );
					} else
					{
						/*	RGBA, use DXT5	*/
						DDS_data = convert_image_to_DXT5(
								resampled, MIPwidth, MIPheight, channels, &DDS_size );
					}
					if( DDS_data )
					{
						soilGlCompressedTexImage2D(
							opengl_texture_target, MIPlevel,
							internal_texture_format, MIPwidth, MIPheight, 0,
							DDS_size, DDS_data );
						check_for_GL_errors( "glCompressedTexImage2D" );
						SOIL_free_image_data( DDS_data );
					} else
					{
						/*	my compression failed, try the OpenGL driver's version	*/
						glTexImage2D(
							opengl_texture_target, MIPlevel,
							internal_texture_format, MIPwidth, MIPheight, 0,
							original_texture_format, GL_UNSIGNED_BYTE, resampled );
						check_for_GL_errors( "glTexImage2D" );
					}
				} else
				{
					/*	user want OpenGL to do all the work!	*/
					glTexImage2D(
						opengl_texture_target, MIPlevel,
						internal_texture_format, MIPwidth, MIPheight, 0,
						original_texture_format, GL_UNSIGNED_BYTE, resampled );
					check_for_GL_errors( "glTexImage2D" );
				}
				/*	prep for the next level	*/
				++MIPlevel;
				MIPwidth = (MIPwidth + 1) / 2;
				MIPheight = (MIPheight + 1) / 2;
			}
			SOIL_free_image_data( resampled );
			/*	instruct OpenGL to use the MIPmaps	*/
			glTexParameteri( opengl_texture_type, GL_TEXTURE_MAG_FILTER, GL_LINEAR );
			glTexParameteri( opengl_texture_type, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR );
			check_for_GL_errors( "GL_TEXTURE_MIN/MAG_FILTER" );
		} else
		{
			/*	instruct OpenGL _NOT_ to use the MIPmaps	*/
			glTexParameteri( opengl_texture_type, GL_TEXTURE_MAG_FILTER, GL_LINEAR );
			glTexParameteri( opengl_texture_type, GL_TEXTURE_MIN_FILTER, GL_LINEAR );
			check_for_GL_errors( "GL_TEXTURE_MIN/MAG_FILTER" );
		}
		/*	does the user want clamping, or wrapping?	*/
		if( flags & SOIL_FLAG_TEXTURE_REPEATS )
		{
			glTexParameteri( opengl_texture_type, GL_TEXTURE_WRAP_S, GL_REPEAT );
			glTexParameteri( opengl_texture_type, GL_TEXTURE_WRAP_T, GL_REPEAT );
			if( opengl_texture_type == SOIL_TEXTURE_CUBE_MAP )
			{
				/*	SOIL_TEXTURE_WRAP_R is invalid if cubemaps aren't supported	*/
				glTexParameteri( opengl_texture_type, SOIL_TEXTURE_WRAP_R, GL_REPEAT );
			}
			check_for_GL_errors( "GL_TEXTURE_WRAP_*" );
		} else
		{
			/*	unsigned int clamp_mode = SOIL_CLAMP_TO_EDGE;	*/
			unsigned int clamp_mode = GL_CLAMP;
			glTexParameteri( opengl_texture_type, GL_TEXTURE_WRAP_S, clamp_mode );
			glTexParameteri( opengl_texture_type, GL_TEXTURE_WRAP_T, clamp_mode );
			if( opengl_texture_type == SOIL_TEXTURE_CUBE_MAP )
			{
				/*	SOIL_TEXTURE_WRAP_R is invalid if cubemaps aren't supported	*/
				glTexParameteri( opengl_texture_type, SOIL_TEXTURE_WRAP_R, clamp_mode );
			}
			check_for_GL_errors( "GL_TEXTURE_WRAP_*" );
		}
		/*	done	*/
		result_string_pointer = "Image loaded as an OpenGL texture";
	} else
	{
		/*	failed	*/
		result_string_pointer = "Failed to generate an OpenGL texture name; missing OpenGL context?";
	}
	SOIL_free_image_data( img );
	return tex_id;
}

int
	SOIL_save_screenshot
	(
		const char *filename,
		int image_type,
		int x, int y,
		int width, int height
	)
{
	unsigned char *pixel_data;
	int i, j;
	int save_result;

	/*	error checks	*/
	if( (width < 1) || (height < 1) )
	{
		result_string_pointer = "Invalid screenshot dimensions";
		return 0;
	}
	if( (x < 0) || (y < 0) )
	{
		result_string_pointer = "Invalid screenshot location";
		return 0;
	}
	if( filename == NULL )
	{
		result_string_pointer = "Invalid screenshot filename";
		return 0;
	}

    /*  Get the data from OpenGL	*/
    pixel_data = (unsigned char*)malloc( 3*width*height );
    glReadPixels (x, y, width, height, GL_RGB, GL_UNSIGNED_BYTE, pixel_data);

    /*	invert the image	*/
    for( j = 0; j*2 < height; ++j )
	{
		int index1 = j * width * 3;
		int index2 = (height - 1 - j) * width * 3;
		for( i = width * 3; i > 0; --i )
		{
			unsigned char temp = pixel_data[index1];
			pixel_data[index1] = pixel_data[index2];
			pixel_data[index2] = temp;
			++index1;
			++index2;
		}
	}

    /*	save the image	*/
    save_result = SOIL_save_image( filename, image_type, width, height, 3, pixel_data);

    /*  And free the memory	*/
    SOIL_free_image_data( pixel_data );
	return save_result;
}

unsigned char*
	SOIL_load_image
	(
		const char *filename,
		int *width, int *height, int *channels,
		int force_channels
	)
{
	unsigned char *result = stbi_load( filename,
			width, height, channels, force_channels );
	if( result == NULL )
	{
		result_string_pointer = stbi_failure_reason();
	} else
	{
		result_string_pointer = "Image loaded";
	}
	return result;
}

unsigned char*
	SOIL_load_image_from_memory
	(
		const unsigned char *const buffer,
		int buffer_length,
		int *width, int *height, int *channels,
		int force_channels
	)
{
	unsigned char *result = stbi_load_from_memory(
				buffer, buffer_length,
				width, height, channels,
				force_channels );
	if( result == NULL )
	{
		result_string_pointer = stbi_failure_reason();
	} else
	{
		result_string_pointer = "Image loaded from memory";
	}
	return result;
}

int
	SOIL_save_image
	(
		const char *filename,
		int image_type,
		int width, int height, int channels,
		const unsigned char *const data
	)
{
	int save_result;

	/*	error check	*/
	if( (width < 1) || (height < 1) ||
		(channels < 1) || (channels > 4) ||
		(data == NULL) ||
		(filename == NULL) )
	{
		return 0;
	}
	if( image_type == SOIL_SAVE_TYPE_BMP )
	{
		save_result = stbi_write_bmp( filename,
				width, height, channels, (void*)data );
	} else
	if( image_type == SOIL_SAVE_TYPE_TGA )
	{
		save_result = stbi_write_tga( filename,
				width, height, channels, (void*)data );
	} else
	if( image_type == SOIL_SAVE_TYPE_DDS )
	{
		save_result = save_image_as_DDS( filename,
				width, height, channels, (const unsigned char *const)data );
	} else
	{
		save_result = 0;
	}
	if( save_result == 0 )
	{
		result_string_pointer = "Saving the image failed";
	} else
	{
		result_string_pointer = "Image saved";
	}
	return save_result;
}

void
	SOIL_free_image_data
	(
		unsigned char *img_data
	)
{
	free( (void*)img_data );
}

const char*
	SOIL_last_result
	(
		void
	)
{
	return result_string_pointer;
}

unsigned int SOIL_direct_load_DDS_from_memory(
		const unsigned char *const buffer,
		int buffer_length,
		unsigned int reuse_texture_ID,
		int flags,
		int loading_as_cubemap )
{
	/*	variables	*/
	DDS_header header;
	unsigned int buffer_index = 0;
	unsigned int tex_ID = 0;
	/*	file reading variables	*/
	unsigned int S3TC_type = 0;
	unsigned char *DDS_data;
	unsigned int DDS_main_size;
	unsigned int DDS_full_size;
	unsigned int width, height;
	int mipmaps, cubemap, uncompressed, block_size = 16;
	unsigned int flag;
	unsigned int cf_target, ogl_target_start, ogl_target_end;
	unsigned int opengl_texture_type;
	int i;
	/*	1st off, does the filename even exist?	*/
	if( NULL == buffer )
	{
		/*	we can't do it!	*/
		result_string_pointer = "NULL buffer";
		return 0;
	}
	if( buffer_length < sizeof( DDS_header ) )
	{
		/*	we can't do it!	*/
		result_string_pointer = "DDS file was too small to contain the DDS header";
		return 0;
	}
	/*	try reading in the header	*/
	memcpy ( (void*)(&header), (const void *)buffer, sizeof( DDS_header ) );
	buffer_index = sizeof( DDS_header );
	/*	guilty until proven innocent	*/
	result_string_pointer = "Failed to read a known DDS header";
	/*	validate the header (warning, "goto"'s ahead, shield your eyes!!)	*/
	flag = ('D'<<0)|('D'<<8)|('S'<<16)|(' '<<24);
	if( header.dwMagic != flag ) {goto quick_exit;}
	if( header.dwSize != 124 ) {goto quick_exit;}
	/*	I need all of these	*/
	flag = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT;
	if( (header.dwFlags & flag) != flag ) {goto quick_exit;}
	/*	According to the MSDN spec, the dwFlags should contain
		DDSD_LINEARSIZE if it's compressed, or DDSD_PITCH if
		uncompressed.  Some DDS writers do not conform to the
		spec, so I need to make my reader more tolerant	*/
	/*	I need one of these	*/
	flag = DDPF_FOURCC | DDPF_RGB;
	if( (header.sPixelFormat.dwFlags & flag) == 0 ) {goto quick_exit;}
	if( header.sPixelFormat.dwSize != 32 ) {goto quick_exit;}
	if( (header.sCaps.dwCaps1 & DDSCAPS_TEXTURE) == 0 ) {goto quick_exit;}
	/*	make sure it is a type we can upload	*/
	if( (header.sPixelFormat.dwFlags & DDPF_FOURCC) &&
		!(
		(header.sPixelFormat.dwFourCC == (('D'<<0)|('X'<<8)|('T'<<16)|('1'<<24))) ||
		(header.sPixelFormat.dwFourCC == (('D'<<0)|('X'<<8)|('T'<<16)|('3'<<24))) ||
		(header.sPixelFormat.dwFourCC == (('D'<<0)|('X'<<8)|('T'<<16)|('5'<<24)))
		) )
	{
		goto quick_exit;
	}
	/*	OK, validated the header, let's load the image data	*/
	result_string_pointer = "DDS header loaded and validated";
	width = header.dwWidth;
	height = header.dwHeight;
	uncompressed = 1 - (header.sPixelFormat.dwFlags & DDPF_FOURCC) / DDPF_FOURCC;
	cubemap = (header.sCaps.dwCaps2 & DDSCAPS2_CUBEMAP) / DDSCAPS2_CUBEMAP;
	if( uncompressed )
	{
		S3TC_type = GL_RGB;
		block_size = 3;
		if( header.sPixelFormat.dwFlags & DDPF_ALPHAPIXELS )
		{
			S3TC_type = GL_RGBA;
			block_size = 4;
		}
		DDS_main_size = width * height * block_size;
	} else
	{
		/*	can we even handle direct uploading to OpenGL DXT compressed images?	*/
		if( query_DXT_capability() != SOIL_CAPABILITY_PRESENT )
		{
			/*	we can't do it!	*/
			result_string_pointer = "Direct upload of S3TC images not supported by the OpenGL driver";
			return 0;
		}
		/*	well, we know it is DXT1/3/5, because we checked above	*/
		switch( (header.sPixelFormat.dwFourCC >> 24) - '0' )
		{
		case 1:
			S3TC_type = SOIL_RGBA_S3TC_DXT1;
			block_size = 8;
			break;
		case 3:
			S3TC_type = SOIL_RGBA_S3TC_DXT3;
			block_size = 16;
			break;
		case 5:
			S3TC_type = SOIL_RGBA_S3TC_DXT5;
			block_size = 16;
			break;
		}
		DDS_main_size = ((width+3)>>2)*((height+3)>>2)*block_size;
	}
	if( cubemap )
	{
		/* does the user want a cubemap?	*/
		if( !loading_as_cubemap )
		{
			/*	we can't do it!	*/
			result_string_pointer = "DDS image was a cubemap";
			return 0;
		}
		/*	can we even handle cubemaps with the OpenGL driver?	*/
		if( query_cubemap_capability() != SOIL_CAPABILITY_PRESENT )
		{
			/*	we can't do it!	*/
			result_string_pointer = "Direct upload of cubemap images not supported by the OpenGL driver";
			return 0;
		}
		ogl_target_start = SOIL_TEXTURE_CUBE_MAP_POSITIVE_X;
		ogl_target_end =   SOIL_TEXTURE_CUBE_MAP_NEGATIVE_Z;
		opengl_texture_type = SOIL_TEXTURE_CUBE_MAP;
	} else
	{
		/* does the user want a non-cubemap?	*/
		if( loading_as_cubemap )
		{
			/*	we can't do it!	*/
			result_string_pointer = "DDS image was not a cubemap";
			return 0;
		}
		ogl_target_start = GL_TEXTURE_2D;
		ogl_target_end =   GL_TEXTURE_2D;
		opengl_texture_type = GL_TEXTURE_2D;
	}
	if( (header.sCaps.dwCaps1 & DDSCAPS_MIPMAP) && (header.dwMipMapCount > 1) )
	{
		int shift_offset;
		mipmaps = header.dwMipMapCount - 1;
		DDS_full_size = DDS_main_size;
		if( uncompressed )
		{
			/*	uncompressed DDS, simple MIPmap size calculation	*/
			shift_offset = 0;
		} else
		{
			/*	compressed DDS, MIPmap size calculation is block based	*/
			shift_offset = 2;
		}
		for( i = 1; i <= mipmaps; ++ i )
		{
			int w, h;
			w = width >> (shift_offset + i);
			h = height >> (shift_offset + i);
			if( w < 1 )
			{
				w = 1;
			}
			if( h < 1 )
			{
				h = 1;
			}
			DDS_full_size += w*h*block_size;
		}
	} else
	{
		mipmaps = 0;
		DDS_full_size = DDS_main_size;
	}
	DDS_data = (unsigned char*)malloc( DDS_full_size );
	/*	got the image data RAM, create or use an existing OpenGL texture handle	*/
	tex_ID = reuse_texture_ID;
	if( tex_ID == 0 )
	{
		glGenTextures( 1, &tex_ID );
	}
	/*  bind an OpenGL texture ID	*/
	glBindTexture( opengl_texture_type, tex_ID );
	/*	do this for each face of the cubemap!	*/
	for( cf_target = ogl_target_start; cf_target <= ogl_target_end; ++cf_target )
	{
		if( buffer_index + DDS_full_size <= buffer_length )
		{
			unsigned int byte_offset = DDS_main_size;
			memcpy( (void*)DDS_data, (const void*)(&buffer[buffer_index]), DDS_full_size );
			buffer_index += DDS_full_size;
			/*	upload the main chunk	*/
			if( uncompressed )
			{
				/*	and remember, DXT uncompressed uses BGR(A),
					so swap to RGB(A) for ALL MIPmap levels	*/
				for( i = 0; i < DDS_full_size; i += block_size )
				{
					unsigned char temp = DDS_data[i];
					DDS_data[i] = DDS_data[i+2];
					DDS_data[i+2] = temp;
				}
				glTexImage2D(
					cf_target, 0,
					S3TC_type, width, height, 0,
					S3TC_type, GL_UNSIGNED_BYTE, DDS_data );
			} else
			{
				soilGlCompressedTexImage2D(
					cf_target, 0,
					S3TC_type, width, height, 0,
					DDS_main_size, DDS_data );
			}
			/*	upload the mipmaps, if we have them	*/
			for( i = 1; i <= mipmaps; ++i )
			{
				int w, h, mip_size;
				w = width >> i;
				h = height >> i;
				if( w < 1 )
				{
					w = 1;
				}
				if( h < 1 )
				{
					h = 1;
				}
				/*	upload this mipmap	*/
				if( uncompressed )
				{
					mip_size = w*h*block_size;
					glTexImage2D(
						cf_target, i,
						S3TC_type, w, h, 0,
						S3TC_type, GL_UNSIGNED_BYTE, &DDS_data[byte_offset] );
				} else
				{
					mip_size = ((w+3)/4)*((h+3)/4)*block_size;
					soilGlCompressedTexImage2D(
						cf_target, i,
						S3TC_type, w, h, 0,
						mip_size, &DDS_data[byte_offset] );
				}
				/*	and move to the next mipmap	*/
				byte_offset += mip_size;
			}
			/*	it worked!	*/
			result_string_pointer = "DDS file loaded";
		} else
		{
			glDeleteTextures( 1, & tex_ID );
			tex_ID = 0;
			cf_target = ogl_target_end + 1;
			result_string_pointer = "DDS file was too small for expected image data";
		}
	}/* end reading each face */
	SOIL_free_image_data( DDS_data );
	if( tex_ID )
	{
		/*	did I have MIPmaps?	*/
		if( mipmaps > 0 )
		{
			/*	instruct OpenGL to use the MIPmaps	*/
			glTexParameteri( opengl_texture_type, GL_TEXTURE_MAG_FILTER, GL_LINEAR );
			glTexParameteri( opengl_texture_type, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR );
		} else
		{
			/*	instruct OpenGL _NOT_ to use the MIPmaps	*/
			glTexParameteri( opengl_texture_type, GL_TEXTURE_MAG_FILTER, GL_LINEAR );
			glTexParameteri( opengl_texture_type, GL_TEXTURE_MIN_FILTER, GL_LINEAR );
		}
		/*	does the user want clamping, or wrapping?	*/
		if( flags & SOIL_FLAG_TEXTURE_REPEATS )
		{
			glTexParameteri( opengl_texture_type, GL_TEXTURE_WRAP_S, GL_REPEAT );
			glTexParameteri( opengl_texture_type, GL_TEXTURE_WRAP_T, GL_REPEAT );
			glTexParameteri( opengl_texture_type, SOIL_TEXTURE_WRAP_R, GL_REPEAT );
		} else
		{
			/*	unsigned int clamp_mode = SOIL_CLAMP_TO_EDGE;	*/
			unsigned int clamp_mode = GL_CLAMP;
			glTexParameteri( opengl_texture_type, GL_TEXTURE_WRAP_S, clamp_mode );
			glTexParameteri( opengl_texture_type, GL_TEXTURE_WRAP_T, clamp_mode );
			glTexParameteri( opengl_texture_type, SOIL_TEXTURE_WRAP_R, clamp_mode );
		}
	}

quick_exit:
	/*	report success or failure	*/
	return tex_ID;
}

unsigned int SOIL_direct_load_DDS(
		const char *filename,
		unsigned int reuse_texture_ID,
		int flags,
		int loading_as_cubemap )
{
	FILE *f;
	unsigned char *buffer;
	size_t buffer_length, bytes_read;
	unsigned int tex_ID = 0;
	/*	error checks	*/
	if( NULL == filename )
	{
		result_string_pointer = "NULL filename";
		return 0;
	}
	f = fopen( filename, "rb" );
	if( NULL == f )
	{
		/*	the file doesn't seem to exist (or be open-able)	*/
		result_string_pointer = "Can not find DDS file";
		return 0;
	}
	fseek( f, 0, SEEK_END );
	buffer_length = ftell( f );
	fseek( f, 0, SEEK_SET );
	buffer = (unsigned char *) malloc( buffer_length );
	if( NULL == buffer )
	{
		result_string_pointer = "malloc failed";
		fclose( f );
		return 0;
	}
	bytes_read = fread( (void*)buffer, 1, buffer_length, f );
	fclose( f );
	if( bytes_read < buffer_length )
	{
		/*	huh?	*/
		buffer_length = bytes_read;
	}
	/*	now try to do the loading	*/
	tex_ID = SOIL_direct_load_DDS_from_memory(
		(const unsigned char *const)buffer, buffer_length,
		reuse_texture_ID, flags, loading_as_cubemap );
	SOIL_free_image_data( buffer );
	return tex_ID;
}

int query_NPOT_capability( void )
{
	/*	check for the capability	*/
	if( has_NPOT_capability == SOIL_CAPABILITY_UNKNOWN )
	{
		/*	we haven't yet checked for the capability, do so	*/
		if(
			(NULL == strstr( (char const*)glGetString( GL_EXTENSIONS ),
				"GL_ARB_texture_non_power_of_two" ) )
			)
		{
			/*	not there, flag the failure	*/
			has_NPOT_capability = SOIL_CAPABILITY_NONE;
		} else
		{
			/*	it's there!	*/
			has_NPOT_capability = SOIL_CAPABILITY_PRESENT;
		}
	}
	/*	let the user know if we can do non-power-of-two textures or not	*/
	return has_NPOT_capability;
}

int query_tex_rectangle_capability( void )
{
	/*	check for the capability	*/
	if( has_tex_rectangle_capability == SOIL_CAPABILITY_UNKNOWN )
	{
		/*	we haven't yet checked for the capability, do so	*/
		if(
			(NULL == strstr( (char const*)glGetString( GL_EXTENSIONS ),
				"GL_ARB_texture_rectangle" ) )
		&&
			(NULL == strstr( (char const*)glGetString( GL_EXTENSIONS ),
				"GL_EXT_texture_rectangle" ) )
		&&
			(NULL == strstr( (char const*)glGetString( GL_EXTENSIONS ),
				"GL_NV_texture_rectangle" ) )
			)
		{
			/*	not there, flag the failure	*/
			has_tex_rectangle_capability = SOIL_CAPABILITY_NONE;
		} else
		{
			/*	it's there!	*/
			has_tex_rectangle_capability = SOIL_CAPABILITY_PRESENT;
		}
	}
	/*	let the user know if we can do texture rectangles or not	*/
	return has_tex_rectangle_capability;
}

int query_cubemap_capability( void )
{
	/*	check for the capability	*/
	if( has_cubemap_capability == SOIL_CAPABILITY_UNKNOWN )
	{
		/*	we haven't yet checked for the capability, do so	*/
		if(
			(NULL == strstr( (char const*)glGetString( GL_EXTENSIONS ),
				"GL_ARB_texture_cube_map" ) )
		&&
			(NULL == strstr( (char const*)glGetString( GL_EXTENSIONS ),
				"GL_EXT_texture_cube_map" ) )
			)
		{
			/*	not there, flag the failure	*/
			has_cubemap_capability = SOIL_CAPABILITY_NONE;
		} else
		{
			/*	it's there!	*/
			has_cubemap_capability = SOIL_CAPABILITY_PRESENT;
		}
	}
	/*	let the user know if we can do cubemaps or not	*/
	return has_cubemap_capability;
}

int query_DXT_capability( void )
{
	/*	check for the capability	*/
	if( has_DXT_capability == SOIL_CAPABILITY_UNKNOWN )
	{
		/*	we haven't yet checked for the capability, do so	*/
		if( NULL == strstr(
				(char const*)glGetString( GL_EXTENSIONS ),
				"GL_EXT_texture_compression_s3tc" ) )
		{
			/*	not there, flag the failure	*/
			has_DXT_capability = SOIL_CAPABILITY_NONE;
		} else
		{
			/*	and find the address of the extension function	*/
			P_SOIL_GLCOMPRESSEDTEXIMAGE2DPROC ext_addr = NULL;
			#ifdef WIN32
				ext_addr = (P_SOIL_GLCOMPRESSEDTEXIMAGE2DPROC)
						wglGetProcAddress
						(
							"glCompressedTexImage2DARB"
						);
			#elif defined(__APPLE__) || defined(__APPLE_CC__)
				/*	I can't test this Apple stuff!	*/
				CFBundleRef bundle;
				CFURLRef bundleURL =
					CFURLCreateWithFileSystemPath(
						kCFAllocatorDefault,
						CFSTR("/System/Library/Frameworks/OpenGL.framework"),
						kCFURLPOSIXPathStyle,
						true );
				CFStringRef extensionName =
					CFStringCreateWithCString(
						kCFAllocatorDefault,
						"glCompressedTexImage2DARB",
						kCFStringEncodingASCII );
				bundle = CFBundleCreate( kCFAllocatorDefault, bundleURL );
				assert( bundle != NULL );
				ext_addr = (P_SOIL_GLCOMPRESSEDTEXIMAGE2DPROC)
						CFBundleGetFunctionPointerForName
						(
							bundle, extensionName
						);
				CFRelease( bundleURL );
				CFRelease( extensionName );
				CFRelease( bundle );
			#else
				ext_addr = (P_SOIL_GLCOMPRESSEDTEXIMAGE2DPROC)
						glXGetProcAddressARB
						(
							(const GLubyte *)"glCompressedTexImage2DARB"
						);
			#endif
			/*	Flag it so no checks needed later	*/
			if( NULL == ext_addr )
			{
				/*	hmm, not good!!  This should not happen, but does on my
					laptop's VIA chipset.  The GL_EXT_texture_compression_s3tc
					spec requires that ARB_texture_compression be present too.
					this means I can upload and have the OpenGL drive do the
					conversion, but I can't use my own routines or load DDS files
					from disk and upload them directly [8^(	*/
				has_DXT_capability = SOIL_CAPABILITY_NONE;
			} else
			{
				/*	all's well!	*/
				soilGlCompressedTexImage2D = ext_addr;
				has_DXT_capability = SOIL_CAPABILITY_PRESENT;
			}
		}
	}
	/*	let the user know if we can do DXT or not	*/
	return has_DXT_capability;
}

```

`sakura/libs/image/soil.h`:

```h
/**
	@mainpage SOIL

	Jonathan Dummer
	2007-07-26-10.36

	Simple OpenGL Image Library

	A tiny c library for uploading images as
	textures into OpenGL.  Also saving and
	loading of images is supported.

	I'm using Sean's Tool Box image loader as a base:
	http://www.nothings.org/

	I'm upgrading it to load TGA and DDS files, and a direct
	path for loading DDS files straight into OpenGL textures,
	when applicable.

	Image Formats:
	- BMP		load & save
	- TGA		load & save
	- DDS		load & save
	- PNG		load
	- JPG		load

	OpenGL Texture Features:
	- resample to power-of-two sizes
	- MIPmap generation
	- compressed texture S3TC formats (if supported)
	- can pre-multiply alpha for you, for better compositing
	- can flip image about the y-axis (except pre-compressed DDS files)

	Thanks to:
	* Sean Barret - for the awesome stb_image
	* Dan Venkitachalam - for finding some non-compliant DDS files, and patching some explicit casts
	* everybody at gamedev.net
**/

#ifndef HEADER_SIMPLE_OPENGL_IMAGE_LIBRARY
#define HEADER_SIMPLE_OPENGL_IMAGE_LIBRARY

#ifdef __cplusplus
extern "C" {
#endif

/**
	The format of images that may be loaded (force_channels).
	SOIL_LOAD_AUTO leaves the image in whatever format it was found.
	SOIL_LOAD_L forces the image to load as Luminous (greyscale)
	SOIL_LOAD_LA forces the image to load as Luminous with Alpha
	SOIL_LOAD_RGB forces the image to load as Red Green Blue
	SOIL_LOAD_RGBA forces the image to load as Red Green Blue Alpha
**/
enum
{
	SOIL_LOAD_AUTO = 0,
	SOIL_LOAD_L = 1,
	SOIL_LOAD_LA = 2,
	SOIL_LOAD_RGB = 3,
	SOIL_LOAD_RGBA = 4
};

/**
	Passed in as reuse_texture_ID, will cause SOIL to
	register a new texture ID using glGenTextures().
	If the value passed into reuse_texture_ID > 0 then
	SOIL will just re-use that texture ID (great for
	reloading image assets in-game!)
**/
enum
{
	SOIL_CREATE_NEW_ID = 0
};

/**
	flags you can pass into SOIL_load_OGL_texture()
	and SOIL_create_OGL_texture().
	(note that if SOIL_FLAG_DDS_LOAD_DIRECT is used
	the rest of the flags with the exception of
	SOIL_FLAG_TEXTURE_REPEATS will be ignored while
	loading already-compressed DDS files.)

	SOIL_FLAG_POWER_OF_TWO: force the image to be POT
	SOIL_FLAG_MIPMAPS: generate mipmaps for the texture
	SOIL_FLAG_TEXTURE_REPEATS: otherwise will clamp
	SOIL_FLAG_MULTIPLY_ALPHA: for using (GL_ONE,GL_ONE_MINUS_SRC_ALPHA) blending
	SOIL_FLAG_INVERT_Y: flip the image vertically
	SOIL_FLAG_COMPRESS_TO_DXT: if the card can display them, will convert RGB to DXT1, RGBA to DXT5
	SOIL_FLAG_DDS_LOAD_DIRECT: will load DDS files directly without _ANY_ additional processing
	SOIL_FLAG_NTSC_SAFE_RGB: clamps RGB components to the range [16,235]
	SOIL_FLAG_CoCg_Y: Google YCoCg; RGB=>CoYCg, RGBA=>CoCgAY
	SOIL_FLAG_TEXTURE_RECTANGE: uses ARB_texture_rectangle ; pixel indexed & no repeat or MIPmaps or cubemaps
**/
enum
{
	SOIL_FLAG_POWER_OF_TWO = 1,
	SOIL_FLAG_MIPMAPS = 2,
	SOIL_FLAG_TEXTURE_REPEATS = 4,
	SOIL_FLAG_MULTIPLY_ALPHA = 8,
	SOIL_FLAG_INVERT_Y = 16,
	SOIL_FLAG_COMPRESS_TO_DXT = 32,
	SOIL_FLAG_DDS_LOAD_DIRECT = 64,
	SOIL_FLAG_NTSC_SAFE_RGB = 128,
	SOIL_FLAG_CoCg_Y = 256,
	SOIL_FLAG_TEXTURE_RECTANGLE = 512
};

/**
	The types of images that may be saved.
	(TGA supports uncompressed RGB / RGBA)
	(BMP supports uncompressed RGB)
	(DDS supports DXT1 and DXT5)
**/
enum
{
	SOIL_SAVE_TYPE_TGA = 0,
	SOIL_SAVE_TYPE_BMP = 1,
	SOIL_SAVE_TYPE_DDS = 2
};

/**
	Defines the order of faces in a DDS cubemap.
	I recommend that you use the same order in single
	image cubemap files, so they will be interchangeable
	with DDS cubemaps when using SOIL.
**/
#define SOIL_DDS_CUBEMAP_FACE_ORDER "EWUDNS"

/**
	The types of internal fake HDR representations

	SOIL_HDR_RGBE:		RGB * pow( 2.0, A - 128.0 )
	SOIL_HDR_RGBdivA:	RGB / A
	SOIL_HDR_RGBdivA2:	RGB / (A*A)
**/
enum
{
	SOIL_HDR_RGBE = 0,
	SOIL_HDR_RGBdivA = 1,
	SOIL_HDR_RGBdivA2 = 2
};

/**
	Loads an image from disk into an OpenGL texture.
	\param filename the name of the file to upload as a texture
	\param force_channels 0-image format, 1-luminous, 2-luminous/alpha, 3-RGB, 4-RGBA
	\param reuse_texture_ID 0-generate a new texture ID, otherwise reuse the texture ID (overwriting the old texture)
	\param flags can be any of SOIL_FLAG_POWER_OF_TWO | SOIL_FLAG_MIPMAPS | SOIL_FLAG_TEXTURE_REPEATS | SOIL_FLAG_MULTIPLY_ALPHA | SOIL_FLAG_INVERT_Y | SOIL_FLAG_COMPRESS_TO_DXT | SOIL_FLAG_DDS_LOAD_DIRECT
	\return 0-failed, otherwise returns the OpenGL texture handle
**/
unsigned int
	SOIL_load_OGL_texture
	(
		const char *filename,
		int force_channels,
		unsigned int reuse_texture_ID,
		unsigned int flags
	);

/**
	Loads 6 images from disk into an OpenGL cubemap texture.
	\param x_pos_file the name of the file to upload as the +x cube face
	\param x_neg_file the name of the file to upload as the -x cube face
	\param y_pos_file the name of the file to upload as the +y cube face
	\param y_neg_file the name of the file to upload as the -y cube face
	\param z_pos_file the name of the file to upload as the +z cube face
	\param z_neg_file the name of the file to upload as the -z cube face
	\param force_channels 0-image format, 1-luminous, 2-luminous/alpha, 3-RGB, 4-RGBA
	\param reuse_texture_ID 0-generate a new texture ID, otherwise reuse the texture ID (overwriting the old texture)
	\param flags can be any of SOIL_FLAG_POWER_OF_TWO | SOIL_FLAG_MIPMAPS | SOIL_FLAG_TEXTURE_REPEATS | SOIL_FLAG_MULTIPLY_ALPHA | SOIL_FLAG_INVERT_Y | SOIL_FLAG_COMPRESS_TO_DXT | SOIL_FLAG_DDS_LOAD_DIRECT
	\return 0-failed, otherwise returns the OpenGL texture handle
**/
unsigned int
	SOIL_load_OGL_cubemap
	(
		const char *x_pos_file,
		const char *x_neg_file,
		const char *y_pos_file,
		const char *y_neg_file,
		const char *z_pos_file,
		const char *z_neg_file,
		int force_channels,
		unsigned int reuse_texture_ID,
		unsigned int flags
	);

/**
	Loads 1 image from disk and splits it into an OpenGL cubemap texture.
	\param filename the name of the file to upload as a texture
	\param face_order the order of the faces in the file, any combination of NSWEUD, for North, South, Up, etc.
	\param force_channels 0-image format, 1-luminous, 2-luminous/alpha, 3-RGB, 4-RGBA
	\param reuse_texture_ID 0-generate a new texture ID, otherwise reuse the texture ID (overwriting the old texture)
	\param flags can be any of SOIL_FLAG_POWER_OF_TWO | SOIL_FLAG_MIPMAPS | SOIL_FLAG_TEXTURE_REPEATS | SOIL_FLAG_MULTIPLY_ALPHA | SOIL_FLAG_INVERT_Y | SOIL_FLAG_COMPRESS_TO_DXT | SOIL_FLAG_DDS_LOAD_DIRECT
	\return 0-failed, otherwise returns the OpenGL texture handle
**/
unsigned int
	SOIL_load_OGL_single_cubemap
	(
		const char *filename,
		const char face_order[6],
		int force_channels,
		unsigned int reuse_texture_ID,
		unsigned int flags
	);

/**
	Loads an HDR image from disk into an OpenGL texture.
	\param filename the name of the file to upload as a texture
	\param fake_HDR_format SOIL_HDR_RGBE, SOIL_HDR_RGBdivA, SOIL_HDR_RGBdivA2
	\param reuse_texture_ID 0-generate a new texture ID, otherwise reuse the texture ID (overwriting the old texture)
	\param flags can be any of SOIL_FLAG_POWER_OF_TWO | SOIL_FLAG_MIPMAPS | SOIL_FLAG_TEXTURE_REPEATS | SOIL_FLAG_MULTIPLY_ALPHA | SOIL_FLAG_INVERT_Y | SOIL_FLAG_COMPRESS_TO_DXT
	\return 0-failed, otherwise returns the OpenGL texture handle
**/
unsigned int
	SOIL_load_OGL_HDR_texture
	(
		const char *filename,
		int fake_HDR_format,
		int rescale_to_max,
		unsigned int reuse_texture_ID,
		unsigned int flags
	);

/**
	Loads an image from RAM into an OpenGL texture.
	\param buffer the image data in RAM just as if it were still in a file
	\param buffer_length the size of the buffer in bytes
	\param force_channels 0-image format, 1-luminous, 2-luminous/alpha, 3-RGB, 4-RGBA
	\param reuse_texture_ID 0-generate a new texture ID, otherwise reuse the texture ID (overwriting the old texture)
	\param flags can be any of SOIL_FLAG_POWER_OF_TWO | SOIL_FLAG_MIPMAPS | SOIL_FLAG_TEXTURE_REPEATS | SOIL_FLAG_MULTIPLY_ALPHA | SOIL_FLAG_INVERT_Y | SOIL_FLAG_COMPRESS_TO_DXT | SOIL_FLAG_DDS_LOAD_DIRECT
	\return 0-failed, otherwise returns the OpenGL texture handle
**/
unsigned int
	SOIL_load_OGL_texture_from_memory
	(
		const unsigned char *const buffer,
		int buffer_length,
		int force_channels,
		unsigned int reuse_texture_ID,
		unsigned int flags
	);

/**
	Loads 6 images from memory into an OpenGL cubemap texture.
	\param x_pos_buffer the image data in RAM to upload as the +x cube face
	\param x_pos_buffer_length the size of the above buffer
	\param x_neg_buffer the image data in RAM to upload as the +x cube face
	\param x_neg_buffer_length the size of the above buffer
	\param y_pos_buffer the image data in RAM to upload as the +x cube face
	\param y_pos_buffer_length the size of the above buffer
	\param y_neg_buffer the image data in RAM to upload as the +x cube face
	\param y_neg_buffer_length the size of the above buffer
	\param z_pos_buffer the image data in RAM to upload as the +x cube face
	\param z_pos_buffer_length the size of the above buffer
	\param z_neg_buffer the image data in RAM to upload as the +x cube face
	\param z_neg_buffer_length the size of the above buffer
	\param force_channels 0-image format, 1-luminous, 2-luminous/alpha, 3-RGB, 4-RGBA
	\param reuse_texture_ID 0-generate a new texture ID, otherwise reuse the texture ID (overwriting the old texture)
	\param flags can be any of SOIL_FLAG_POWER_OF_TWO | SOIL_FLAG_MIPMAPS | SOIL_FLAG_TEXTURE_REPEATS | SOIL_FLAG_MULTIPLY_ALPHA | SOIL_FLAG_INVERT_Y | SOIL_FLAG_COMPRESS_TO_DXT | SOIL_FLAG_DDS_LOAD_DIRECT
	\return 0-failed, otherwise returns the OpenGL texture handle
**/
unsigned int
	SOIL_load_OGL_cubemap_from_memory
	(
		const unsigned char *const x_pos_buffer,
		int x_pos_buffer_length,
		const unsigned char *const x_neg_buffer,
		int x_neg_buffer_length,
		const unsigned char *const y_pos_buffer,
		int y_pos_buffer_length,
		const unsigned char *const y_neg_buffer,
		int y_neg_buffer_length,
		const unsigned char *const z_pos_buffer,
		int z_pos_buffer_length,
		const unsigned char *const z_neg_buffer,
		int z_neg_buffer_length,
		int force_channels,
		unsigned int reuse_texture_ID,
		unsigned int flags
	);

/**
	Loads 1 image from RAM and splits it into an OpenGL cubemap texture.
	\param buffer the image data in RAM just as if it were still in a file
	\param buffer_length the size of the buffer in bytes
	\param face_order the order of the faces in the file, any combination of NSWEUD, for North, South, Up, etc.
	\param force_channels 0-image format, 1-luminous, 2-luminous/alpha, 3-RGB, 4-RGBA
	\param reuse_texture_ID 0-generate a new texture ID, otherwise reuse the texture ID (overwriting the old texture)
	\param flags can be any of SOIL_FLAG_POWER_OF_TWO | SOIL_FLAG_MIPMAPS | SOIL_FLAG_TEXTURE_REPEATS | SOIL_FLAG_MULTIPLY_ALPHA | SOIL_FLAG_INVERT_Y | SOIL_FLAG_COMPRESS_TO_DXT | SOIL_FLAG_DDS_LOAD_DIRECT
	\return 0-failed, otherwise returns the OpenGL texture handle
**/
unsigned int
	SOIL_load_OGL_single_cubemap_from_memory
	(
		const unsigned char *const buffer,
		int buffer_length,
		const char face_order[6],
		int force_channels,
		unsigned int reuse_texture_ID,
		unsigned int flags
	);

/**
	Creates a 2D OpenGL texture from raw image data.  Note that the raw data is
	_NOT_ freed after the upload (so the user can load various versions).
	\param data the raw data to be uploaded as an OpenGL texture
	\param width the width of the image in pixels
	\param height the height of the image in pixels
	\param channels the number of channels: 1-luminous, 2-luminous/alpha, 3-RGB, 4-RGBA
	\param reuse_texture_ID 0-generate a new texture ID, otherwise reuse the texture ID (overwriting the old texture)
	\param flags can be any of SOIL_FLAG_POWER_OF_TWO | SOIL_FLAG_MIPMAPS | SOIL_FLAG_TEXTURE_REPEATS | SOIL_FLAG_MULTIPLY_ALPHA | SOIL_FLAG_INVERT_Y | SOIL_FLAG_COMPRESS_TO_DXT
	\return 0-failed, otherwise returns the OpenGL texture handle
**/
unsigned int
	SOIL_create_OGL_texture
	(
		const unsigned char *const data,
		int width, int height, int channels,
		unsigned int reuse_texture_ID,
		unsigned int flags
	);

/**
	Creates an OpenGL cubemap texture by splitting up 1 image into 6 parts.
	\param data the raw data to be uploaded as an OpenGL texture
	\param width the width of the image in pixels
	\param height the height of the image in pixels
	\param channels the number of channels: 1-luminous, 2-luminous/alpha, 3-RGB, 4-RGBA
	\param face_order the order of the faces in the file, and combination of NSWEUD, for North, South, Up, etc.
	\param reuse_texture_ID 0-generate a new texture ID, otherwise reuse the texture ID (overwriting the old texture)
	\param flags can be any of SOIL_FLAG_POWER_OF_TWO | SOIL_FLAG_MIPMAPS | SOIL_FLAG_TEXTURE_REPEATS | SOIL_FLAG_MULTIPLY_ALPHA | SOIL_FLAG_INVERT_Y | SOIL_FLAG_COMPRESS_TO_DXT | SOIL_FLAG_DDS_LOAD_DIRECT
	\return 0-failed, otherwise returns the OpenGL texture handle
**/
unsigned int
	SOIL_create_OGL_single_cubemap
	(
		const unsigned char *const data,
		int width, int height, int channels,
		const char face_order[6],
		unsigned int reuse_texture_ID,
		unsigned int flags
	);

/**
	Captures the OpenGL window (RGB) and saves it to disk
	\return 0 if it failed, otherwise returns 1
**/
int
	SOIL_save_screenshot
	(
		const char *filename,
		int image_type,
		int x, int y,
		int width, int height
	);

/**
	Loads an image from disk into an array of unsigned chars.
	Note that *channels return the original channel count of the
	image.  If force_channels was other than SOIL_LOAD_AUTO,
	the resulting image has force_channels, but *channels may be
	different (if the original image had a different channel
	count).
	\return 0 if failed, otherwise returns 1
**/
unsigned char*
	SOIL_load_image
	(
		const char *filename,
		int *width, int *height, int *channels,
		int force_channels
	);

/**
	Loads an image from memory into an array of unsigned chars.
	Note that *channels return the original channel count of the
	image.  If force_channels was other than SOIL_LOAD_AUTO,
	the resulting image has force_channels, but *channels may be
	different (if the original image had a different channel
	count).
	\return 0 if failed, otherwise returns 1
**/
unsigned char*
	SOIL_load_image_from_memory
	(
		const unsigned char *const buffer,
		int buffer_length,
		int *width, int *height, int *channels,
		int force_channels
	);

/**
	Saves an image from an array of unsigned chars (RGBA) to disk
	\return 0 if failed, otherwise returns 1
**/
int
	SOIL_save_image
	(
		const char *filename,
		int image_type,
		int width, int height, int channels,
		const unsigned char *const data
	);

/**
	Frees the image data (note, this is just C's "free()"...this function is
	present mostly so C++ programmers don't forget to use "free()" and call
	"delete []" instead [8^)
**/
void
	SOIL_free_image_data
	(
		unsigned char *img_data
	);

/**
	This function resturn a pointer to a string describing the last thing
	that happened inside SOIL.  It can be used to determine why an image
	failed to load.
**/
const char*
	SOIL_last_result
	(
		void
	);


#ifdef __cplusplus
}
#endif

#endif /* HEADER_SIMPLE_OPENGL_IMAGE_LIBRARY	*/

```

`sakura/libs/image/stb_image_aug.cpp`:

```cpp
/* stbi-1.16 - public domain JPEG/PNG reader - http://nothings.org/stb_image.c
                      when you control the images you're loading

   QUICK NOTES:
      Primarily of interest to game developers and other people who can
          avoid problematic images and only need the trivial interface

      JPEG baseline (no JPEG progressive, no oddball channel decimations)
      PNG non-interlaced
      BMP non-1bpp, non-RLE
      TGA (not sure what subset, if a subset)
      PSD (composited view only, no extra channels)
      HDR (radiance rgbE format)
      writes BMP,TGA (define STBI_NO_WRITE to remove code)
      decoded from memory or through stdio FILE (define STBI_NO_STDIO to remove code)
      supports installable dequantizing-IDCT, YCbCr-to-RGB conversion (define STBI_SIMD)

   TODO:
      stbi_info_*

   history:
      1.16   major bugfix - convert_format converted one too many pixels
      1.15   initialize some fields for thread safety
      1.14   fix threadsafe conversion bug; header-file-only version (#define STBI_HEADER_FILE_ONLY before including)
      1.13   threadsafe
      1.12   const qualifiers in the API
      1.11   Support installable IDCT, colorspace conversion routines
      1.10   Fixes for 64-bit (don't use "unsigned long")
             optimized upsampling by Fabian "ryg" Giesen
      1.09   Fix format-conversion for PSD code (bad global variables!)
      1.08   Thatcher Ulrich's PSD code integrated by Nicolas Schulz
      1.07   attempt to fix C++ warning/errors again
      1.06   attempt to fix C++ warning/errors again
      1.05   fix TGA loading to return correct *comp and use good luminance calc
      1.04   default float alpha is 1, not 255; use 'void *' for stbi_image_free
      1.03   bugfixes to STBI_NO_STDIO, STBI_NO_HDR
      1.02   support for (subset of) HDR files, float interface for preferred access to them
      1.01   fix bug: possible bug in handling right-side up bmps... not sure
             fix bug: the stbi_bmp_load() and stbi_tga_load() functions didn't work at all
      1.00   interface to zlib that skips zlib header
      0.99   correct handling of alpha in palette
      0.98   TGA loader by lonesock; dynamically add loaders (untested)
      0.97   jpeg errors on too large a file; also catch another malloc failure
      0.96   fix detection of invalid v value - particleman@mollyrocket forum
      0.95   during header scan, seek to markers in case of padding
      0.94   STBI_NO_STDIO to disable stdio usage; rename all #defines the same
      0.93   handle jpegtran output; verbose errors
      0.92   read 4,8,16,24,32-bit BMP files of several formats
      0.91   output 24-bit Windows 3.0 BMP files
      0.90   fix a few more warnings; bump version number to approach 1.0
      0.61   bugfixes due to Marc LeBlanc, Christopher Lloyd
      0.60   fix compiling as c++
      0.59   fix warnings: merge Dave Moore's -Wall fixes
      0.58   fix bug: zlib uncompressed mode len/nlen was wrong endian
      0.57   fix bug: jpg last huffman symbol before marker was >9 bits but less
                      than 16 available
      0.56   fix bug: zlib uncompressed mode len vs. nlen
      0.55   fix bug: restart_interval not initialized to 0
      0.54   allow NULL for 'int *comp'
      0.53   fix bug in png 3->4; speedup png decoding
      0.52   png handles req_comp=3,4 directly; minor cleanup; jpeg comments
      0.51   obey req_comp requests, 1-component jpegs return as 1-component,
             on 'test' only check type, not whether we support this variant
*/

#pragma warning(disable:4996)
#pragma warning(disable:4838)
#include "stb_image_aug.h"

#ifndef STBI_NO_HDR
#include <math.h>  // ldexp
#include <string.h> // strcmp
#endif

#ifndef STBI_NO_STDIO
#include <stdio.h>
#endif
#include <stdlib.h>
#include <memory.h>
#include <assert.h>
#include <stdarg.h>

#ifndef _MSC_VER
  #ifdef __cplusplus
  #define __forceinline inline
  #else
  #define __forceinline
  #endif
#endif


// implementation:
typedef unsigned char uint8;
typedef unsigned short uint16;
typedef   signed short  int16;
typedef unsigned int   uint32;
typedef   signed int    int32;
typedef unsigned int   uint;

// should produce compiler error if size is wrong
typedef unsigned char validate_uint32[sizeof(uint32)==4];

#if defined(STBI_NO_STDIO) && !defined(STBI_NO_WRITE)
#define STBI_NO_WRITE
#endif

#ifndef STBI_NO_DDS
#include "stbi_DDS_aug.h"
#endif

//	I (JLD) want full messages for SOIL
#define STBI_FAILURE_USERMSG 1

//////////////////////////////////////////////////////////////////////////////
//
// Generic API that works on all image types
//

// this is not threadsafe
static char *failure_reason;

char *stbi_failure_reason(void)
{
   return failure_reason;
}

static int e(char *str)
{
   failure_reason = str;
   return 0;
}

#ifdef STBI_NO_FAILURE_STRINGS
   #define e(x,y)  0
#elif defined(STBI_FAILURE_USERMSG)
   #define e(x,y)  e(y)
#else
   #define e(x,y)  e(x)
#endif

#define epf(x,y)   ((float *) (e(x,y)?NULL:NULL))
#define epuc(x,y)  ((unsigned char *) (e(x,y)?NULL:NULL))

void stbi_image_free(void *retval_from_stbi_load)
{
   free(retval_from_stbi_load);
}

#define MAX_LOADERS  32
stbi_loader *loaders[MAX_LOADERS];
static int max_loaders = 0;

int stbi_register_loader(stbi_loader *loader)
{
   int i;
   for (i=0; i < MAX_LOADERS; ++i) {
      // already present?
      if (loaders[i] == loader)
         return 1;
      // end of the list?
      if (loaders[i] == NULL) {
         loaders[i] = loader;
         max_loaders = i+1;
         return 1;
      }
   }
   // no room for it
   return 0;
}

#ifndef STBI_NO_HDR
static float   *ldr_to_hdr(stbi_uc *data, int x, int y, int comp);
static stbi_uc *hdr_to_ldr(float   *data, int x, int y, int comp);
#endif

#ifndef STBI_NO_STDIO
unsigned char *stbi_load(char const *filename, int *x, int *y, int *comp, int req_comp)
{
   FILE *f = fopen(filename, "rb");
   unsigned char *result;
   if (!f) return epuc("can't fopen", "Unable to open file");
   result = stbi_load_from_file(f,x,y,comp,req_comp);
   fclose(f);
   return result;
}

unsigned char *stbi_load_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)
{
   int i;
   if (stbi_jpeg_test_file(f))
      return stbi_jpeg_load_from_file(f,x,y,comp,req_comp);
   if (stbi_png_test_file(f))
      return stbi_png_load_from_file(f,x,y,comp,req_comp);
   if (stbi_bmp_test_file(f))
      return stbi_bmp_load_from_file(f,x,y,comp,req_comp);
   if (stbi_psd_test_file(f))
      return stbi_psd_load_from_file(f,x,y,comp,req_comp);
   #ifndef STBI_NO_DDS
   if (stbi_dds_test_file(f))
      return stbi_dds_load_from_file(f,x,y,comp,req_comp);
   #endif
   #ifndef STBI_NO_HDR
   if (stbi_hdr_test_file(f)) {
      float *hdr = stbi_hdr_load_from_file(f, x,y,comp,req_comp);
      return hdr_to_ldr(hdr, *x, *y, req_comp ? req_comp : *comp);
   }
   #endif
   for (i=0; i < max_loaders; ++i)
      if (loaders[i]->test_file(f))
         return loaders[i]->load_from_file(f,x,y,comp,req_comp);
   // test tga last because it's a crappy test!
   if (stbi_tga_test_file(f))
      return stbi_tga_load_from_file(f,x,y,comp,req_comp);
   return epuc("unknown image type", "Image not of any known type, or corrupt");
}
#endif

unsigned char *stbi_load_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
{
   int i;
   if (stbi_jpeg_test_memory(buffer,len))
      return stbi_jpeg_load_from_memory(buffer,len,x,y,comp,req_comp);
   if (stbi_png_test_memory(buffer,len))
      return stbi_png_load_from_memory(buffer,len,x,y,comp,req_comp);
   if (stbi_bmp_test_memory(buffer,len))
      return stbi_bmp_load_from_memory(buffer,len,x,y,comp,req_comp);
   if (stbi_psd_test_memory(buffer,len))
      return stbi_psd_load_from_memory(buffer,len,x,y,comp,req_comp);
   #ifndef STBI_NO_DDS
   if (stbi_dds_test_memory(buffer,len))
      return stbi_dds_load_from_memory(buffer,len,x,y,comp,req_comp);
   #endif
   #ifndef STBI_NO_HDR
   if (stbi_hdr_test_memory(buffer, len)) {
      float *hdr = stbi_hdr_load_from_memory(buffer, len,x,y,comp,req_comp);
      return hdr_to_ldr(hdr, *x, *y, req_comp ? req_comp : *comp);
   }
   #endif
   for (i=0; i < max_loaders; ++i)
      if (loaders[i]->test_memory(buffer,len))
         return loaders[i]->load_from_memory(buffer,len,x,y,comp,req_comp);
   // test tga last because it's a crappy test!
   if (stbi_tga_test_memory(buffer,len))
      return stbi_tga_load_from_memory(buffer,len,x,y,comp,req_comp);
   return epuc("unknown image type", "Image not of any known type, or corrupt");
}

#ifndef STBI_NO_HDR

#ifndef STBI_NO_STDIO
float *stbi_loadf(char const *filename, int *x, int *y, int *comp, int req_comp)
{
   FILE *f = fopen(filename, "rb");
   float *result;
   if (!f) return epf("can't fopen", "Unable to open file");
   result = stbi_loadf_from_file(f,x,y,comp,req_comp);
   fclose(f);
   return result;
}

float *stbi_loadf_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)
{
   unsigned char *data;
   #ifndef STBI_NO_HDR
   if (stbi_hdr_test_file(f))
      return stbi_hdr_load_from_file(f,x,y,comp,req_comp);
   #endif
   data = stbi_load_from_file(f, x, y, comp, req_comp);
   if (data)
      return ldr_to_hdr(data, *x, *y, req_comp ? req_comp : *comp);
   return epf("unknown image type", "Image not of any known type, or corrupt");
}
#endif

float *stbi_loadf_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
{
   stbi_uc *data;
   #ifndef STBI_NO_HDR
   if (stbi_hdr_test_memory(buffer, len))
      return stbi_hdr_load_from_memory(buffer, len,x,y,comp,req_comp);
   #endif
   data = stbi_load_from_memory(buffer, len, x, y, comp, req_comp);
   if (data)
      return ldr_to_hdr(data, *x, *y, req_comp ? req_comp : *comp);
   return epf("unknown image type", "Image not of any known type, or corrupt");
}
#endif

// these is-hdr-or-not is defined independent of whether STBI_NO_HDR is
// defined, for API simplicity; if STBI_NO_HDR is defined, it always
// reports false!

int stbi_is_hdr_from_memory(stbi_uc const *buffer, int len)
{
   #ifndef STBI_NO_HDR
   return stbi_hdr_test_memory(buffer, len);
   #else
   return 0;
   #endif
}

#ifndef STBI_NO_STDIO
extern int      stbi_is_hdr          (char const *filename)
{
   FILE *f = fopen(filename, "rb");
   int result=0;
   if (f) {
      result = stbi_is_hdr_from_file(f);
      fclose(f);
   }
   return result;
}

extern int      stbi_is_hdr_from_file(FILE *f)
{
   #ifndef STBI_NO_HDR
   return stbi_hdr_test_file(f);
   #else
   return 0;
   #endif
}

#endif

// @TODO: get image dimensions & components without fully decoding
#ifndef STBI_NO_STDIO
extern int      stbi_info            (char const *filename,           int *x, int *y, int *comp);
extern int      stbi_info_from_file  (FILE *f,                  int *x, int *y, int *comp);
#endif
extern int      stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp);

#ifndef STBI_NO_HDR
static float h2l_gamma_i=1.0f/2.2f, h2l_scale_i=1.0f;
static float l2h_gamma=2.2f, l2h_scale=1.0f;

void   stbi_hdr_to_ldr_gamma(float gamma) { h2l_gamma_i = 1/gamma; }
void   stbi_hdr_to_ldr_scale(float scale) { h2l_scale_i = 1/scale; }

void   stbi_ldr_to_hdr_gamma(float gamma) { l2h_gamma = gamma; }
void   stbi_ldr_to_hdr_scale(float scale) { l2h_scale = scale; }
#endif


//////////////////////////////////////////////////////////////////////////////
//
// Common code used by all image loaders
//

enum
{
   SCAN_load=0,
   SCAN_type,
   SCAN_header,
};

typedef struct
{
   uint32 img_x, img_y;
   int img_n, img_out_n;

   #ifndef STBI_NO_STDIO
   FILE  *img_file;
   #endif
   uint8 *img_buffer, *img_buffer_end;
} stbi;

#ifndef STBI_NO_STDIO
static void start_file(stbi *s, FILE *f)
{
   s->img_file = f;
}
#endif

static void start_mem(stbi *s, uint8 const *buffer, int len)
{
#ifndef STBI_NO_STDIO
   s->img_file = NULL;
#endif
   s->img_buffer = (uint8 *) buffer;
   s->img_buffer_end = (uint8 *) buffer+len;
}

__forceinline static int get8(stbi *s)
{
#ifndef STBI_NO_STDIO
   if (s->img_file) {
      int c = fgetc(s->img_file);
      return c == EOF ? 0 : c;
   }
#endif
   if (s->img_buffer < s->img_buffer_end)
      return *s->img_buffer++;
   return 0;
}

__forceinline static int at_eof(stbi *s)
{
#ifndef STBI_NO_STDIO
   if (s->img_file)
      return feof(s->img_file);
#endif
   return s->img_buffer >= s->img_buffer_end;
}

__forceinline static uint8 get8u(stbi *s)
{
   return (uint8) get8(s);
}

static void skip(stbi *s, int n)
{
#ifndef STBI_NO_STDIO
   if (s->img_file)
      fseek(s->img_file, n, SEEK_CUR);
   else
#endif
      s->img_buffer += n;
}

static int get16(stbi *s)
{
   int z = get8(s);
   return (z << 8) + get8(s);
}

static uint32 get32(stbi *s)
{
   uint32 z = get16(s);
   return (z << 16) + get16(s);
}

static int get16le(stbi *s)
{
   int z = get8(s);
   return z + (get8(s) << 8);
}

static uint32 get32le(stbi *s)
{
   uint32 z = get16le(s);
   return z + (get16le(s) << 16);
}

static void getn(stbi *s, stbi_uc *buffer, int n)
{
#ifndef STBI_NO_STDIO
   if (s->img_file) {
      fread(buffer, 1, n, s->img_file);
      return;
   }
#endif
   memcpy(buffer, s->img_buffer, n);
   s->img_buffer += n;
}

//////////////////////////////////////////////////////////////////////////////
//
//  generic converter from built-in img_n to req_comp
//    individual types do this automatically as much as possible (e.g. jpeg
//    does all cases internally since it needs to colorspace convert anyway,
//    and it never has alpha, so very few cases ). png can automatically
//    interleave an alpha=255 channel, but falls back to this for other cases
//
//  assume data buffer is malloced, so malloc a new one and free that one
//  only failure mode is malloc failing

static uint8 compute_y(int r, int g, int b)
{
   return (uint8) (((r*77) + (g*150) +  (29*b)) >> 8);
}

static unsigned char *convert_format(unsigned char *data, int img_n, int req_comp, uint x, uint y)
{
   int i,j;
   unsigned char *good;

   if (req_comp == img_n) return data;
   assert(req_comp >= 1 && req_comp <= 4);

   good = (unsigned char *) malloc(req_comp * x * y);
   if (good == NULL) {
      free(data);
      return epuc("outofmem", "Out of memory");
   }

   for (j=0; j < (int) y; ++j) {
      unsigned char *src  = data + j * x * img_n   ;
      unsigned char *dest = good + j * x * req_comp;

      #define COMBO(a,b)  ((a)*8+(b))
      #define CASE(a,b)   case COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
      // convert source image with img_n components to one with req_comp components;
      // avoid switch per pixel, so use switch per scanline and massive macros
      switch(COMBO(img_n, req_comp)) {
         CASE(1,2) dest[0]=src[0], dest[1]=255; break;
         CASE(1,3) dest[0]=dest[1]=dest[2]=src[0]; break;
         CASE(1,4) dest[0]=dest[1]=dest[2]=src[0], dest[3]=255; break;
         CASE(2,1) dest[0]=src[0]; break;
         CASE(2,3) dest[0]=dest[1]=dest[2]=src[0]; break;
         CASE(2,4) dest[0]=dest[1]=dest[2]=src[0], dest[3]=src[1]; break;
         CASE(3,4) dest[0]=src[0],dest[1]=src[1],dest[2]=src[2],dest[3]=255; break;
         CASE(3,1) dest[0]=compute_y(src[0],src[1],src[2]); break;
         CASE(3,2) dest[0]=compute_y(src[0],src[1],src[2]), dest[1] = 255; break;
         CASE(4,1) dest[0]=compute_y(src[0],src[1],src[2]); break;
         CASE(4,2) dest[0]=compute_y(src[0],src[1],src[2]), dest[1] = src[3]; break;
         CASE(4,3) dest[0]=src[0],dest[1]=src[1],dest[2]=src[2]; break;
         default: assert(0);
      }
      #undef CASE
   }

   free(data);
   return good;
}

#ifndef STBI_NO_HDR
static float   *ldr_to_hdr(stbi_uc *data, int x, int y, int comp)
{
   int i,k,n;
   float *output = (float *) malloc(x * y * comp * sizeof(float));
   if (output == NULL) { free(data); return epf("outofmem", "Out of memory"); }
   // compute number of non-alpha components
   if (comp & 1) n = comp; else n = comp-1;
   for (i=0; i < x*y; ++i) {
      for (k=0; k < n; ++k) {
         output[i*comp + k] = (float) pow(data[i*comp+k]/255.0f, l2h_gamma) * l2h_scale;
      }
      if (k < comp) output[i*comp + k] = data[i*comp+k]/255.0f;
   }
   free(data);
   return output;
}

#define float2int(x)   ((int) (x))
static stbi_uc *hdr_to_ldr(float   *data, int x, int y, int comp)
{
   int i,k,n;
   stbi_uc *output = (stbi_uc *) malloc(x * y * comp);
   if (output == NULL) { free(data); return epuc("outofmem", "Out of memory"); }
   // compute number of non-alpha components
   if (comp & 1) n = comp; else n = comp-1;
   for (i=0; i < x*y; ++i) {
      for (k=0; k < n; ++k) {
         float z = (float) pow(data[i*comp+k]*h2l_scale_i, h2l_gamma_i) * 255 + 0.5f;
         if (z < 0) z = 0;
         if (z > 255) z = 255;
         output[i*comp + k] = float2int(z);
      }
      if (k < comp) {
         float z = data[i*comp+k] * 255 + 0.5f;
         if (z < 0) z = 0;
         if (z > 255) z = 255;
         output[i*comp + k] = float2int(z);
      }
   }
   free(data);
   return output;
}
#endif

//////////////////////////////////////////////////////////////////////////////
//
//  "baseline" JPEG/JFIF decoder (not actually fully baseline implementation)
//
//    simple implementation
//      - channel subsampling of at most 2 in each dimension
//      - doesn't support delayed output of y-dimension
//      - simple interface (only one output format: 8-bit interleaved RGB)
//      - doesn't try to recover corrupt jpegs
//      - doesn't allow partial loading, loading multiple at once
//      - still fast on x86 (copying globals into locals doesn't help x86)
//      - allocates lots of intermediate memory (full size of all components)
//        - non-interleaved case requires this anyway
//        - allows good upsampling (see next)
//    high-quality
//      - upsampled channels are bilinearly interpolated, even across blocks
//      - quality integer IDCT derived from IJG's 'slow'
//    performance
//      - fast huffman; reasonable integer IDCT
//      - uses a lot of intermediate memory, could cache poorly
//      - load http://nothings.org/remote/anemones.jpg 3 times on 2.8Ghz P4
//          stb_jpeg:   1.34 seconds (MSVC6, default release build)
//          stb_jpeg:   1.06 seconds (MSVC6, processor = Pentium Pro)
//          IJL11.dll:  1.08 seconds (compiled by intel)
//          IJG 1998:   0.98 seconds (MSVC6, makefile provided by IJG)
//          IJG 1998:   0.95 seconds (MSVC6, makefile + proc=PPro)

// huffman decoding acceleration
#define FAST_BITS   9  // larger handles more cases; smaller stomps less cache

typedef struct
{
   uint8  fast[1 << FAST_BITS];
   // weirdly, repacking this into AoS is a 10% speed loss, instead of a win
   uint16 code[256];
   uint8  values[256];
   uint8  size[257];
   unsigned int maxcode[18];
   int    delta[17];   // old 'firstsymbol' - old 'firstcode'
} huffman;

typedef struct
{
   #if STBI_SIMD
   unsigned short dequant2[4][64];
   #endif
   stbi s;
   huffman huff_dc[4];
   huffman huff_ac[4];
   uint8 dequant[4][64];

// sizes for components, interleaved MCUs
   int img_h_max, img_v_max;
   int img_mcu_x, img_mcu_y;
   int img_mcu_w, img_mcu_h;

// definition of jpeg image component
   struct
   {
      int id;
      int h,v;
      int tq;
      int hd,ha;
      int dc_pred;

      int x,y,w2,h2;
      uint8 *data;
      void *raw_data;
      uint8 *linebuf;
   } img_comp[4];

   uint32         code_buffer; // jpeg entropy-coded buffer
   int            code_bits;   // number of valid bits
   unsigned char  marker;      // marker seen while filling entropy buffer
   int            nomore;      // flag if we saw a marker so must stop

   int scan_n, order[4];
   int restart_interval, todo;
} jpeg;

static int build_huffman(huffman *h, int *count)
{
   int i,j,k=0,code;
   // build size list for each symbol (from JPEG spec)
   for (i=0; i < 16; ++i)
      for (j=0; j < count[i]; ++j)
         h->size[k++] = (uint8) (i+1);
   h->size[k] = 0;

   // compute actual symbols (from jpeg spec)
   code = 0;
   k = 0;
   for(j=1; j <= 16; ++j) {
      // compute delta to add to code to compute symbol id
      h->delta[j] = k - code;
      if (h->size[k] == j) {
         while (h->size[k] == j)
            h->code[k++] = (uint16) (code++);
         if (code-1 >= (1 << j)) return e("bad code lengths","Corrupt JPEG");
      }
      // compute largest code + 1 for this size, preshifted as needed later
      h->maxcode[j] = code << (16-j);
      code <<= 1;
   }
   h->maxcode[j] = 0xffffffff;

   // build non-spec acceleration table; 255 is flag for not-accelerated
   memset(h->fast, 255, 1 << FAST_BITS);
   for (i=0; i < k; ++i) {
      int s = h->size[i];
      if (s <= FAST_BITS) {
         int c = h->code[i] << (FAST_BITS-s);
         int m = 1 << (FAST_BITS-s);
         for (j=0; j < m; ++j) {
            h->fast[c+j] = (uint8) i;
         }
      }
   }
   return 1;
}

static void grow_buffer_unsafe(jpeg *j)
{
   do {
      int b = j->nomore ? 0 : get8(&j->s);
      if (b == 0xff) {
         int c = get8(&j->s);
         if (c != 0) {
            j->marker = (unsigned char) c;
            j->nomore = 1;
            return;
         }
      }
      j->code_buffer = (j->code_buffer << 8) | b;
      j->code_bits += 8;
   } while (j->code_bits <= 24);
}

// (1 << n) - 1
static uint32 bmask[17]={0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535};

// decode a jpeg huffman value from the bitstream
__forceinline static int decode(jpeg *j, huffman *h)
{
   unsigned int temp;
   int c,k;

   if (j->code_bits < 16) grow_buffer_unsafe(j);

   // look at the top FAST_BITS and determine what symbol ID it is,
   // if the code is <= FAST_BITS
   c = (j->code_buffer >> (j->code_bits - FAST_BITS)) & ((1 << FAST_BITS)-1);
   k = h->fast[c];
   if (k < 255) {
      if (h->size[k] > j->code_bits)
         return -1;
      j->code_bits -= h->size[k];
      return h->values[k];
   }

   // naive test is to shift the code_buffer down so k bits are
   // valid, then test against maxcode. To speed this up, we've
   // preshifted maxcode left so that it has (16-k) 0s at the
   // end; in other words, regardless of the number of bits, it
   // wants to be compared against something shifted to have 16;
   // that way we don't need to shift inside the loop.
   if (j->code_bits < 16)
      temp = (j->code_buffer << (16 - j->code_bits)) & 0xffff;
   else
      temp = (j->code_buffer >> (j->code_bits - 16)) & 0xffff;
   for (k=FAST_BITS+1 ; ; ++k)
      if (temp < h->maxcode[k])
         break;
   if (k == 17) {
      // error! code not found
      j->code_bits -= 16;
      return -1;
   }

   if (k > j->code_bits)
      return -1;

   // convert the huffman code to the symbol id
   c = ((j->code_buffer >> (j->code_bits - k)) & bmask[k]) + h->delta[k];
   assert((((j->code_buffer) >> (j->code_bits - h->size[c])) & bmask[h->size[c]]) == h->code[c]);

   // convert the id to a symbol
   j->code_bits -= k;
   return h->values[c];
}

// combined JPEG 'receive' and JPEG 'extend', since baseline
// always extends everything it receives.
__forceinline static int extend_receive(jpeg *j, int n)
{
   unsigned int m = 1 << (n-1);
   unsigned int k;
   if (j->code_bits < n) grow_buffer_unsafe(j);
   k = (j->code_buffer >> (j->code_bits - n)) & bmask[n];
   j->code_bits -= n;
   // the following test is probably a random branch that won't
   // predict well. I tried to table accelerate it but failed.
   // maybe it's compiling as a conditional move?
   if (k < m)
      return (-1 << n) + k + 1;
   else
      return k;
}

// given a value that's at position X in the zigzag stream,
// where does it appear in the 8x8 matrix coded as row-major?
static uint8 dezigzag[64+15] =
{
    0,  1,  8, 16,  9,  2,  3, 10,
   17, 24, 32, 25, 18, 11,  4,  5,
   12, 19, 26, 33, 40, 48, 41, 34,
   27, 20, 13,  6,  7, 14, 21, 28,
   35, 42, 49, 56, 57, 50, 43, 36,
   29, 22, 15, 23, 30, 37, 44, 51,
   58, 59, 52, 45, 38, 31, 39, 46,
   53, 60, 61, 54, 47, 55, 62, 63,
   // let corrupt input sample past end
   63, 63, 63, 63, 63, 63, 63, 63,
   63, 63, 63, 63, 63, 63, 63
};

// decode one 64-entry block--
static int decode_block(jpeg *j, short data[64], huffman *hdc, huffman *hac, int b)
{
   int diff,dc,k;
   int t = decode(j, hdc);
   if (t < 0) return e("bad huffman code","Corrupt JPEG");

   // 0 all the ac values now so we can do it 32-bits at a time
   memset(data,0,64*sizeof(data[0]));

   diff = t ? extend_receive(j, t) : 0;
   dc = j->img_comp[b].dc_pred + diff;
   j->img_comp[b].dc_pred = dc;
   data[0] = (short) dc;

   // decode AC components, see JPEG spec
   k = 1;
   do {
      int r,s;
      int rs = decode(j, hac);
      if (rs < 0) return e("bad huffman code","Corrupt JPEG");
      s = rs & 15;
      r = rs >> 4;
      if (s == 0) {
         if (rs != 0xf0) break; // end block
         k += 16;
      } else {
         k += r;
         // decode into unzigzag'd location
         data[dezigzag[k++]] = (short) extend_receive(j,s);
      }
   } while (k < 64);
   return 1;
}

// take a -128..127 value and clamp it and convert to 0..255
__forceinline static uint8 clamp(int x)
{
   x += 128;
   // trick to use a single test to catch both cases
   if ((unsigned int) x > 255) {
      if (x < 0) return 0;
      if (x > 255) return 255;
   }
   return (uint8) x;
}

#define f2f(x)  (int) (((x) * 4096 + 0.5))
#define fsh(x)  ((x) << 12)

// derived from jidctint -- DCT_ISLOW
#define IDCT_1D(s0,s1,s2,s3,s4,s5,s6,s7)       \
   int t0,t1,t2,t3,p1,p2,p3,p4,p5,x0,x1,x2,x3; \
   p2 = s2;                                    \
   p3 = s6;                                    \
   p1 = (p2+p3) * f2f(0.5411961f);             \
   t2 = p1 + p3*f2f(-1.847759065f);            \
   t3 = p1 + p2*f2f( 0.765366865f);            \
   p2 = s0;                                    \
   p3 = s4;                                    \
   t0 = fsh(p2+p3);                            \
   t1 = fsh(p2-p3);                            \
   x0 = t0+t3;                                 \
   x3 = t0-t3;                                 \
   x1 = t1+t2;                                 \
   x2 = t1-t2;                                 \
   t0 = s7;                                    \
   t1 = s5;                                    \
   t2 = s3;                                    \
   t3 = s1;                                    \
   p3 = t0+t2;                                 \
   p4 = t1+t3;                                 \
   p1 = t0+t3;                                 \
   p2 = t1+t2;                                 \
   p5 = (p3+p4)*f2f( 1.175875602f);            \
   t0 = t0*f2f( 0.298631336f);                 \
   t1 = t1*f2f( 2.053119869f);                 \
   t2 = t2*f2f( 3.072711026f);                 \
   t3 = t3*f2f( 1.501321110f);                 \
   p1 = p5 + p1*f2f(-0.899976223f);            \
   p2 = p5 + p2*f2f(-2.562915447f);            \
   p3 = p3*f2f(-1.961570560f);                 \
   p4 = p4*f2f(-0.390180644f);                 \
   t3 += p1+p4;                                \
   t2 += p2+p3;                                \
   t1 += p2+p4;                                \
   t0 += p1+p3;

#if !STBI_SIMD
// .344 seconds on 3*anemones.jpg
static void idct_block(uint8 *out, int out_stride, short data[64], uint8 *dequantize)
{
   int i,val[64],*v=val;
   uint8 *o,*dq = dequantize;
   short *d = data;

   // columns
   for (i=0; i < 8; ++i,++d,++dq, ++v) {
      // if all zeroes, shortcut -- this avoids dequantizing 0s and IDCTing
      if (d[ 8]==0 && d[16]==0 && d[24]==0 && d[32]==0
           && d[40]==0 && d[48]==0 && d[56]==0) {
         //    no shortcut                 0     seconds
         //    (1|2|3|4|5|6|7)==0          0     seconds
         //    all separate               -0.047 seconds
         //    1 && 2|3 && 4|5 && 6|7:    -0.047 seconds
         int dcterm = d[0] * dq[0] << 2;
         v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;
      } else {
         IDCT_1D(d[ 0]*dq[ 0],d[ 8]*dq[ 8],d[16]*dq[16],d[24]*dq[24],
                 d[32]*dq[32],d[40]*dq[40],d[48]*dq[48],d[56]*dq[56])
         // constants scaled things up by 1<<12; let's bring them back
         // down, but keep 2 extra bits of precision
         x0 += 512; x1 += 512; x2 += 512; x3 += 512;
         v[ 0] = (x0+t3) >> 10;
         v[56] = (x0-t3) >> 10;
         v[ 8] = (x1+t2) >> 10;
         v[48] = (x1-t2) >> 10;
         v[16] = (x2+t1) >> 10;
         v[40] = (x2-t1) >> 10;
         v[24] = (x3+t0) >> 10;
         v[32] = (x3-t0) >> 10;
      }
   }

   for (i=0, v=val, o=out; i < 8; ++i,v+=8,o+=out_stride) {
      // no fast case since the first 1D IDCT spread components out
      IDCT_1D(v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7])
      // constants scaled things up by 1<<12, plus we had 1<<2 from first
      // loop, plus horizontal and vertical each scale by sqrt(8) so together
      // we've got an extra 1<<3, so 1<<17 total we need to remove.
      x0 += 65536; x1 += 65536; x2 += 65536; x3 += 65536;
      o[0] = clamp((x0+t3) >> 17);
      o[7] = clamp((x0-t3) >> 17);
      o[1] = clamp((x1+t2) >> 17);
      o[6] = clamp((x1-t2) >> 17);
      o[2] = clamp((x2+t1) >> 17);
      o[5] = clamp((x2-t1) >> 17);
      o[3] = clamp((x3+t0) >> 17);
      o[4] = clamp((x3-t0) >> 17);
   }
}
#else
static void idct_block(uint8 *out, int out_stride, short data[64], unsigned short *dequantize)
{
   int i,val[64],*v=val;
   uint8 *o;
   unsigned short *dq = dequantize;
   short *d = data;

   // columns
   for (i=0; i < 8; ++i,++d,++dq, ++v) {
      // if all zeroes, shortcut -- this avoids dequantizing 0s and IDCTing
      if (d[ 8]==0 && d[16]==0 && d[24]==0 && d[32]==0
           && d[40]==0 && d[48]==0 && d[56]==0) {
         //    no shortcut                 0     seconds
         //    (1|2|3|4|5|6|7)==0          0     seconds
         //    all separate               -0.047 seconds
         //    1 && 2|3 && 4|5 && 6|7:    -0.047 seconds
         int dcterm = d[0] * dq[0] << 2;
         v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;
      } else {
         IDCT_1D(d[ 0]*dq[ 0],d[ 8]*dq[ 8],d[16]*dq[16],d[24]*dq[24],
                 d[32]*dq[32],d[40]*dq[40],d[48]*dq[48],d[56]*dq[56])
         // constants scaled things up by 1<<12; let's bring them back
         // down, but keep 2 extra bits of precision
         x0 += 512; x1 += 512; x2 += 512; x3 += 512;
         v[ 0] = (x0+t3) >> 10;
         v[56] = (x0-t3) >> 10;
         v[ 8] = (x1+t2) >> 10;
         v[48] = (x1-t2) >> 10;
         v[16] = (x2+t1) >> 10;
         v[40] = (x2-t1) >> 10;
         v[24] = (x3+t0) >> 10;
         v[32] = (x3-t0) >> 10;
      }
   }

   for (i=0, v=val, o=out; i < 8; ++i,v+=8,o+=out_stride) {
      // no fast case since the first 1D IDCT spread components out
      IDCT_1D(v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7])
      // constants scaled things up by 1<<12, plus we had 1<<2 from first
      // loop, plus horizontal and vertical each scale by sqrt(8) so together
      // we've got an extra 1<<3, so 1<<17 total we need to remove.
      x0 += 65536; x1 += 65536; x2 += 65536; x3 += 65536;
      o[0] = clamp((x0+t3) >> 17);
      o[7] = clamp((x0-t3) >> 17);
      o[1] = clamp((x1+t2) >> 17);
      o[6] = clamp((x1-t2) >> 17);
      o[2] = clamp((x2+t1) >> 17);
      o[5] = clamp((x2-t1) >> 17);
      o[3] = clamp((x3+t0) >> 17);
      o[4] = clamp((x3-t0) >> 17);
   }
}
static stbi_idct_8x8 stbi_idct_installed = idct_block;

extern void stbi_install_idct(stbi_idct_8x8 func)
{
   stbi_idct_installed = func;
}
#endif

#define MARKER_none  0xff
// if there's a pending marker from the entropy stream, return that
// otherwise, fetch from the stream and get a marker. if there's no
// marker, return 0xff, which is never a valid marker value
static uint8 get_marker(jpeg *j)
{
   uint8 x;
   if (j->marker != MARKER_none) { x = j->marker; j->marker = MARKER_none; return x; }
   x = get8u(&j->s);
   if (x != 0xff) return MARKER_none;
   while (x == 0xff)
      x = get8u(&j->s);
   return x;
}

// in each scan, we'll have scan_n components, and the order
// of the components is specified by order[]
#define RESTART(x)     ((x) >= 0xd0 && (x) <= 0xd7)

// after a restart interval, reset the entropy decoder and
// the dc prediction
static void reset(jpeg *j)
{
   j->code_bits = 0;
   j->code_buffer = 0;
   j->nomore = 0;
   j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = 0;
   j->marker = MARKER_none;
   j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;
   // no more than 1<<31 MCUs if no restart_interal? that's plenty safe,
   // since we don't even allow 1<<30 pixels
}

static int parse_entropy_coded_data(jpeg *z)
{
   reset(z);
   if (z->scan_n == 1) {
      int i,j;
      #if STBI_SIMD
      __declspec(align(16))
      #endif
      short data[64];
      int n = z->order[0];
      // non-interleaved data, we just need to process one block at a time,
      // in trivial scanline order
      // number of blocks to do just depends on how many actual "pixels" this
      // component has, independent of interleaved MCU blocking and such
      int w = (z->img_comp[n].x+7) >> 3;
      int h = (z->img_comp[n].y+7) >> 3;
      for (j=0; j < h; ++j) {
         for (i=0; i < w; ++i) {
            if (!decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+z->img_comp[n].ha, n)) return 0;
            #if STBI_SIMD
            stbi_idct_installed(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data, z->dequant2[z->img_comp[n].tq]);
            #else
            idct_block(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data, z->dequant[z->img_comp[n].tq]);
            #endif
            // every data block is an MCU, so countdown the restart interval
            if (--z->todo <= 0) {
               if (z->code_bits < 24) grow_buffer_unsafe(z);
               // if it's NOT a restart, then just bail, so we get corrupt data
               // rather than no data
               if (!RESTART(z->marker)) return 1;
               reset(z);
            }
         }
      }
   } else { // interleaved!
      int i,j,k,x,y;
      short data[64];
      for (j=0; j < z->img_mcu_y; ++j) {
         for (i=0; i < z->img_mcu_x; ++i) {
            // scan an interleaved mcu... process scan_n components in order
            for (k=0; k < z->scan_n; ++k) {
               int n = z->order[k];
               // scan out an mcu's worth of this component; that's just determined
               // by the basic H and V specified for the component
               for (y=0; y < z->img_comp[n].v; ++y) {
                  for (x=0; x < z->img_comp[n].h; ++x) {
                     int x2 = (i*z->img_comp[n].h + x)*8;
                     int y2 = (j*z->img_comp[n].v + y)*8;
                     if (!decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+z->img_comp[n].ha, n)) return 0;
                     #if STBI_SIMD
                     stbi_idct_installed(z->img_comp[n].data+z->img_comp[n].w2*y2+x2, z->img_comp[n].w2, data, z->dequant2[z->img_comp[n].tq]);
                     #else
                     idct_block(z->img_comp[n].data+z->img_comp[n].w2*y2+x2, z->img_comp[n].w2, data, z->dequant[z->img_comp[n].tq]);
                     #endif
                  }
               }
            }
            // after all interleaved components, that's an interleaved MCU,
            // so now count down the restart interval
            if (--z->todo <= 0) {
               if (z->code_bits < 24) grow_buffer_unsafe(z);
               // if it's NOT a restart, then just bail, so we get corrupt data
               // rather than no data
               if (!RESTART(z->marker)) return 1;
               reset(z);
            }
         }
      }
   }
   return 1;
}

static int process_marker(jpeg *z, int m)
{
   int L;
   switch (m) {
      case MARKER_none: // no marker found
         return e("expected marker","Corrupt JPEG");

      case 0xC2: // SOF - progressive
         return e("progressive jpeg","JPEG format not supported (progressive)");

      case 0xDD: // DRI - specify restart interval
         if (get16(&z->s) != 4) return e("bad DRI len","Corrupt JPEG");
         z->restart_interval = get16(&z->s);
         return 1;

      case 0xDB: // DQT - define quantization table
         L = get16(&z->s)-2;
         while (L > 0) {
            int q = get8(&z->s);
            int p = q >> 4;
            int t = q & 15,i;
            if (p != 0) return e("bad DQT type","Corrupt JPEG");
            if (t > 3) return e("bad DQT table","Corrupt JPEG");
            for (i=0; i < 64; ++i)
               z->dequant[t][dezigzag[i]] = get8u(&z->s);
            #if STBI_SIMD
            for (i=0; i < 64; ++i)
               z->dequant2[t][i] = dequant[t][i];
            #endif
            L -= 65;
         }
         return L==0;

      case 0xC4: // DHT - define huffman table
         L = get16(&z->s)-2;
         while (L > 0) {
            uint8 *v;
            int sizes[16],i,m=0;
            int q = get8(&z->s);
            int tc = q >> 4;
            int th = q & 15;
            if (tc > 1 || th > 3) return e("bad DHT header","Corrupt JPEG");
            for (i=0; i < 16; ++i) {
               sizes[i] = get8(&z->s);
               m += sizes[i];
            }
            L -= 17;
            if (tc == 0) {
               if (!build_huffman(z->huff_dc+th, sizes)) return 0;
               v = z->huff_dc[th].values;
            } else {
               if (!build_huffman(z->huff_ac+th, sizes)) return 0;
               v = z->huff_ac[th].values;
            }
            for (i=0; i < m; ++i)
               v[i] = get8u(&z->s);
            L -= m;
         }
         return L==0;
   }
   // check for comment block or APP blocks
   if ((m >= 0xE0 && m <= 0xEF) || m == 0xFE) {
      skip(&z->s, get16(&z->s)-2);
      return 1;
   }
   return 0;
}

// after we see SOS
static int process_scan_header(jpeg *z)
{
   int i;
   int Ls = get16(&z->s);
   z->scan_n = get8(&z->s);
   if (z->scan_n < 1 || z->scan_n > 4 || z->scan_n > (int) z->s.img_n) return e("bad SOS component count","Corrupt JPEG");
   if (Ls != 6+2*z->scan_n) return e("bad SOS len","Corrupt JPEG");
   for (i=0; i < z->scan_n; ++i) {
      int id = get8(&z->s), which;
      int q = get8(&z->s);
      for (which = 0; which < z->s.img_n; ++which)
         if (z->img_comp[which].id == id)
            break;
      if (which == z->s.img_n) return 0;
      z->img_comp[which].hd = q >> 4;   if (z->img_comp[which].hd > 3) return e("bad DC huff","Corrupt JPEG");
      z->img_comp[which].ha = q & 15;   if (z->img_comp[which].ha > 3) return e("bad AC huff","Corrupt JPEG");
      z->order[i] = which;
   }
   if (get8(&z->s) != 0) return e("bad SOS","Corrupt JPEG");
   get8(&z->s); // should be 63, but might be 0
   if (get8(&z->s) != 0) return e("bad SOS","Corrupt JPEG");

   return 1;
}

static int process_frame_header(jpeg *z, int scan)
{
   stbi *s = &z->s;
   int Lf,p,i,q, h_max=1,v_max=1,c;
   Lf = get16(s);         if (Lf < 11) return e("bad SOF len","Corrupt JPEG"); // JPEG
   p  = get8(s);          if (p != 8) return e("only 8-bit","JPEG format not supported: 8-bit only"); // JPEG baseline
   s->img_y = get16(s);   if (s->img_y == 0) return e("no header height", "JPEG format not supported: delayed height"); // Legal, but we don't handle it--but neither does IJG
   s->img_x = get16(s);   if (s->img_x == 0) return e("0 width","Corrupt JPEG"); // JPEG requires
   c = get8(s);
   if (c != 3 && c != 1) return e("bad component count","Corrupt JPEG");    // JFIF requires
   s->img_n = c;
   for (i=0; i < c; ++i) {
      z->img_comp[i].data = NULL;
      z->img_comp[i].linebuf = NULL;
   }

   if (Lf != 8+3*s->img_n) return e("bad SOF len","Corrupt JPEG");

   for (i=0; i < s->img_n; ++i) {
      z->img_comp[i].id = get8(s);
      if (z->img_comp[i].id != i+1)   // JFIF requires
         if (z->img_comp[i].id != i)  // some version of jpegtran outputs non-JFIF-compliant files!
            return e("bad component ID","Corrupt JPEG");
      q = get8(s);
      z->img_comp[i].h = (q >> 4);  if (!z->img_comp[i].h || z->img_comp[i].h > 4) return e("bad H","Corrupt JPEG");
      z->img_comp[i].v = q & 15;    if (!z->img_comp[i].v || z->img_comp[i].v > 4) return e("bad V","Corrupt JPEG");
      z->img_comp[i].tq = get8(s);  if (z->img_comp[i].tq > 3) return e("bad TQ","Corrupt JPEG");
   }

   if (scan != SCAN_load) return 1;

   if ((1 << 30) / s->img_x / s->img_n < s->img_y) return e("too large", "Image too large to decode");

   for (i=0; i < s->img_n; ++i) {
      if (z->img_comp[i].h > h_max) h_max = z->img_comp[i].h;
      if (z->img_comp[i].v > v_max) v_max = z->img_comp[i].v;
   }

   // compute interleaved mcu info
   z->img_h_max = h_max;
   z->img_v_max = v_max;
   z->img_mcu_w = h_max * 8;
   z->img_mcu_h = v_max * 8;
   z->img_mcu_x = (s->img_x + z->img_mcu_w-1) / z->img_mcu_w;
   z->img_mcu_y = (s->img_y + z->img_mcu_h-1) / z->img_mcu_h;

   for (i=0; i < s->img_n; ++i) {
      // number of effective pixels (e.g. for non-interleaved MCU)
      z->img_comp[i].x = (s->img_x * z->img_comp[i].h + h_max-1) / h_max;
      z->img_comp[i].y = (s->img_y * z->img_comp[i].v + v_max-1) / v_max;
      // to simplify generation, we'll allocate enough memory to decode
      // the bogus oversized data from using interleaved MCUs and their
      // big blocks (e.g. a 16x16 iMCU on an image of width 33); we won't
      // discard the extra data until colorspace conversion
      z->img_comp[i].w2 = z->img_mcu_x * z->img_comp[i].h * 8;
      z->img_comp[i].h2 = z->img_mcu_y * z->img_comp[i].v * 8;
      z->img_comp[i].raw_data = malloc(z->img_comp[i].w2 * z->img_comp[i].h2+15);
      if (z->img_comp[i].raw_data == NULL) {
         for(--i; i >= 0; --i) {
            free(z->img_comp[i].raw_data);
            z->img_comp[i].data = NULL;
         }
         return e("outofmem", "Out of memory");
      }
      // align blocks for installable-idct using mmx/sse
      z->img_comp[i].data = (uint8*) (((size_t) z->img_comp[i].raw_data + 15) & ~15);
      z->img_comp[i].linebuf = NULL;
   }

   return 1;
}

// use comparisons since in some cases we handle more than one case (e.g. SOF)
#define DNL(x)         ((x) == 0xdc)
#define SOI(x)         ((x) == 0xd8)
#define EOI(x)         ((x) == 0xd9)
#define SOF(x)         ((x) == 0xc0 || (x) == 0xc1)
#define SOS(x)         ((x) == 0xda)

static int decode_jpeg_header(jpeg *z, int scan)
{
   int m;
   z->marker = MARKER_none; // initialize cached marker to empty
   m = get_marker(z);
   if (!SOI(m)) return e("no SOI","Corrupt JPEG");
   if (scan == SCAN_type) return 1;
   m = get_marker(z);
   while (!SOF(m)) {
      if (!process_marker(z,m)) return 0;
      m = get_marker(z);
      while (m == MARKER_none) {
         // some files have extra padding after their blocks, so ok, we'll scan
         if (at_eof(&z->s)) return e("no SOF", "Corrupt JPEG");
         m = get_marker(z);
      }
   }
   if (!process_frame_header(z, scan)) return 0;
   return 1;
}

static int decode_jpeg_image(jpeg *j)
{
   int m;
   j->restart_interval = 0;
   if (!decode_jpeg_header(j, SCAN_load)) return 0;
   m = get_marker(j);
   while (!EOI(m)) {
      if (SOS(m)) {
         if (!process_scan_header(j)) return 0;
         if (!parse_entropy_coded_data(j)) return 0;
      } else {
         if (!process_marker(j, m)) return 0;
      }
      m = get_marker(j);
   }
   return 1;
}

// static jfif-centered resampling (across block boundaries)

typedef uint8 *(*resample_row_func)(uint8 *out, uint8 *in0, uint8 *in1,
                                    int w, int hs);

#define div4(x) ((uint8) ((x) >> 2))

static uint8 *resample_row_1(uint8 *out, uint8 *in_near, uint8 *in_far, int w, int hs)
{
   return in_near;
}

static uint8* resample_row_v_2(uint8 *out, uint8 *in_near, uint8 *in_far, int w, int hs)
{
   // need to generate two samples vertically for every one in input
   int i;
   for (i=0; i < w; ++i)
      out[i] = div4(3*in_near[i] + in_far[i] + 2);
   return out;
}

static uint8*  resample_row_h_2(uint8 *out, uint8 *in_near, uint8 *in_far, int w, int hs)
{
   // need to generate two samples horizontally for every one in input
   int i;
   uint8 *input = in_near;
   if (w == 1) {
      // if only one sample, can't do any interpolation
      out[0] = out[1] = input[0];
      return out;
   }

   out[0] = input[0];
   out[1] = div4(input[0]*3 + input[1] + 2);
   for (i=1; i < w-1; ++i) {
      int n = 3*input[i]+2;
      out[i*2+0] = div4(n+input[i-1]);
      out[i*2+1] = div4(n+input[i+1]);
   }
   out[i*2+0] = div4(input[w-2]*3 + input[w-1] + 2);
   out[i*2+1] = input[w-1];
   return out;
}

#define div16(x) ((uint8) ((x) >> 4))

static uint8 *resample_row_hv_2(uint8 *out, uint8 *in_near, uint8 *in_far, int w, int hs)
{
   // need to generate 2x2 samples for every one in input
   int i,t0,t1;
   if (w == 1) {
      out[0] = out[1] = div4(3*in_near[0] + in_far[0] + 2);
      return out;
   }

   t1 = 3*in_near[0] + in_far[0];
   out[0] = div4(t1+2);
   for (i=1; i < w; ++i) {
      t0 = t1;
      t1 = 3*in_near[i]+in_far[i];
      out[i*2-1] = div16(3*t0 + t1 + 8);
      out[i*2  ] = div16(3*t1 + t0 + 8);
   }
   out[w*2-1] = div4(t1+2);
   return out;
}

static uint8 *resample_row_generic(uint8 *out, uint8 *in_near, uint8 *in_far, int w, int hs)
{
   // resample with nearest-neighbor
   int i,j;
   for (i=0; i < w; ++i)
      for (j=0; j < hs; ++j)
         out[i*hs+j] = in_near[i];
   return out;
}

#define float2fixed(x)  ((int) ((x) * 65536 + 0.5))

// 0.38 seconds on 3*anemones.jpg   (0.25 with processor = Pro)
// VC6 without processor=Pro is generating multiple LEAs per multiply!
static void YCbCr_to_RGB_row(uint8 *out, uint8 *y, uint8 *pcb, uint8 *pcr, int count, int step)
{
   int i;
   for (i=0; i < count; ++i) {
      int y_fixed = (y[i] << 16) + 32768; // rounding
      int r,g,b;
      int cr = pcr[i] - 128;
      int cb = pcb[i] - 128;
      r = y_fixed + cr*float2fixed(1.40200f);
      g = y_fixed - cr*float2fixed(0.71414f) - cb*float2fixed(0.34414f);
      b = y_fixed                            + cb*float2fixed(1.77200f);
      r >>= 16;
      g >>= 16;
      b >>= 16;
      if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }
      if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }
      if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }
      out[0] = (uint8)r;
      out[1] = (uint8)g;
      out[2] = (uint8)b;
      out[3] = 255;
      out += step;
   }
}

#if STBI_SIMD
static stbi_YCbCr_to_RGB_run stbi_YCbCr_installed = YCbCr_to_RGB_row;

void stbi_install_YCbCr_to_RGB(stbi_YCbCr_to_RGB_run func)
{
   stbi_YCbCr_installed = func;
}
#endif


// clean up the temporary component buffers
static void cleanup_jpeg(jpeg *j)
{
   int i;
   for (i=0; i < j->s.img_n; ++i) {
      if (j->img_comp[i].data) {
         free(j->img_comp[i].raw_data);
         j->img_comp[i].data = NULL;
      }
      if (j->img_comp[i].linebuf) {
         free(j->img_comp[i].linebuf);
         j->img_comp[i].linebuf = NULL;
      }
   }
}

typedef struct
{
   resample_row_func resample;
   uint8 *line0,*line1;
   int hs,vs;   // expansion factor in each axis
   int w_lores; // horizontal pixels pre-expansion
   int ystep;   // how far through vertical expansion we are
   int ypos;    // which pre-expansion row we're on
} stbi_resample;

static uint8 *load_jpeg_image(jpeg *z, int *out_x, int *out_y, int *comp, int req_comp)
{
   int n, decode_n;
   // validate req_comp
   if (req_comp < 0 || req_comp > 4) return epuc("bad req_comp", "Internal error");
   z->s.img_n = 0;

   // load a jpeg image from whichever source
   if (!decode_jpeg_image(z)) { cleanup_jpeg(z); return NULL; }

   // determine actual number of components to generate
   n = req_comp ? req_comp : z->s.img_n;

   if (z->s.img_n == 3 && n < 3)
      decode_n = 1;
   else
      decode_n = z->s.img_n;

   // resample and color-convert
   {
      int k;
      uint i,j;
      uint8 *output;
      uint8 *coutput[4];

      stbi_resample res_comp[4];

      for (k=0; k < decode_n; ++k) {
         stbi_resample *r = &res_comp[k];

         // allocate line buffer big enough for upsampling off the edges
         // with upsample factor of 4
         z->img_comp[k].linebuf = (uint8 *) malloc(z->s.img_x + 3);
         if (!z->img_comp[k].linebuf) { cleanup_jpeg(z); return epuc("outofmem", "Out of memory"); }

         r->hs      = z->img_h_max / z->img_comp[k].h;
         r->vs      = z->img_v_max / z->img_comp[k].v;
         r->ystep   = r->vs >> 1;
         r->w_lores = (z->s.img_x + r->hs-1) / r->hs;
         r->ypos    = 0;
         r->line0   = r->line1 = z->img_comp[k].data;

         if      (r->hs == 1 && r->vs == 1) r->resample = resample_row_1;
         else if (r->hs == 1 && r->vs == 2) r->resample = resample_row_v_2;
         else if (r->hs == 2 && r->vs == 1) r->resample = resample_row_h_2;
         else if (r->hs == 2 && r->vs == 2) r->resample = resample_row_hv_2;
         else                               r->resample = resample_row_generic;
      }

      // can't error after this so, this is safe
      output = (uint8 *) malloc(n * z->s.img_x * z->s.img_y + 1);
      if (!output) { cleanup_jpeg(z); return epuc("outofmem", "Out of memory"); }

      // now go ahead and resample
      for (j=0; j < z->s.img_y; ++j) {
         uint8 *out = output + n * z->s.img_x * j;
         for (k=0; k < decode_n; ++k) {
            stbi_resample *r = &res_comp[k];
            int y_bot = r->ystep >= (r->vs >> 1);
            coutput[k] = r->resample(z->img_comp[k].linebuf,
                                     y_bot ? r->line1 : r->line0,
                                     y_bot ? r->line0 : r->line1,
                                     r->w_lores, r->hs);
            if (++r->ystep >= r->vs) {
               r->ystep = 0;
               r->line0 = r->line1;
               if (++r->ypos < z->img_comp[k].y)
                  r->line1 += z->img_comp[k].w2;
            }
         }
         if (n >= 3) {
            uint8 *y = coutput[0];
            if (z->s.img_n == 3) {
               #if STBI_SIMD
               stbi_YCbCr_installed(out, y, coutput[1], coutput[2], z->s.img_x, n);
               #else
               YCbCr_to_RGB_row(out, y, coutput[1], coutput[2], z->s.img_x, n);
               #endif
            } else
               for (i=0; i < z->s.img_x; ++i) {
                  out[0] = out[1] = out[2] = y[i];
                  out[3] = 255; // not used if n==3
                  out += n;
               }
         } else {
            uint8 *y = coutput[0];
            if (n == 1)
               for (i=0; i < z->s.img_x; ++i) out[i] = y[i];
            else
               for (i=0; i < z->s.img_x; ++i) *out++ = y[i], *out++ = 255;
         }
      }
      cleanup_jpeg(z);
      *out_x = z->s.img_x;
      *out_y = z->s.img_y;
      if (comp) *comp  = z->s.img_n; // report original components, not output
      return output;
   }
}

#ifndef STBI_NO_STDIO
unsigned char *stbi_jpeg_load_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)
{
   jpeg j;
   start_file(&j.s, f);
   return load_jpeg_image(&j, x,y,comp,req_comp);
}

unsigned char *stbi_jpeg_load(char const *filename, int *x, int *y, int *comp, int req_comp)
{
   unsigned char *data;
   FILE *f = fopen(filename, "rb");
   if (!f) return NULL;
   data = stbi_jpeg_load_from_file(f,x,y,comp,req_comp);
   fclose(f);
   return data;
}
#endif

unsigned char *stbi_jpeg_load_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
{
   jpeg j;
   start_mem(&j.s, buffer,len);
   return load_jpeg_image(&j, x,y,comp,req_comp);
}

#ifndef STBI_NO_STDIO
int stbi_jpeg_test_file(FILE *f)
{
   int n,r;
   jpeg j;
   n = ftell(f);
   start_file(&j.s, f);
   r = decode_jpeg_header(&j, SCAN_type);
   fseek(f,n,SEEK_SET);
   return r;
}
#endif

int stbi_jpeg_test_memory(stbi_uc const *buffer, int len)
{
   jpeg j;
   start_mem(&j.s, buffer,len);
   return decode_jpeg_header(&j, SCAN_type);
}

// @TODO:
#ifndef STBI_NO_STDIO
extern int      stbi_jpeg_info            (char const *filename,           int *x, int *y, int *comp);
extern int      stbi_jpeg_info_from_file  (FILE *f,                  int *x, int *y, int *comp);
#endif
extern int      stbi_jpeg_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp);

// public domain zlib decode    v0.2  Sean Barrett 2006-11-18
//    simple implementation
//      - all input must be provided in an upfront buffer
//      - all output is written to a single output buffer (can malloc/realloc)
//    performance
//      - fast huffman

// fast-way is faster to check than jpeg huffman, but slow way is slower
#define ZFAST_BITS  9 // accelerate all cases in default tables
#define ZFAST_MASK  ((1 << ZFAST_BITS) - 1)

// zlib-style huffman encoding
// (jpegs packs from left, zlib from right, so can't share code)
typedef struct
{
   uint16 fast[1 << ZFAST_BITS];
   uint16 firstcode[16];
   int maxcode[17];
   uint16 firstsymbol[16];
   uint8  size[288];
   uint16 value[288];
} zhuffman;

__forceinline static int bitreverse16(int n)
{
  n = ((n & 0xAAAA) >>  1) | ((n & 0x5555) << 1);
  n = ((n & 0xCCCC) >>  2) | ((n & 0x3333) << 2);
  n = ((n & 0xF0F0) >>  4) | ((n & 0x0F0F) << 4);
  n = ((n & 0xFF00) >>  8) | ((n & 0x00FF) << 8);
  return n;
}

__forceinline static int bit_reverse(int v, int bits)
{
   assert(bits <= 16);
   // to bit reverse n bits, reverse 16 and shift
   // e.g. 11 bits, bit reverse and shift away 5
   return bitreverse16(v) >> (16-bits);
}

static int zbuild_huffman(zhuffman *z, uint8 *sizelist, int num)
{
   int i,k=0;
   int code, next_code[16], sizes[17];

   // DEFLATE spec for generating codes
   memset(sizes, 0, sizeof(sizes));
   memset(z->fast, 255, sizeof(z->fast));
   for (i=0; i < num; ++i)
      ++sizes[sizelist[i]];
   sizes[0] = 0;
   for (i=1; i < 16; ++i)
      assert(sizes[i] <= (1 << i));
   code = 0;
   for (i=1; i < 16; ++i) {
      next_code[i] = code;
      z->firstcode[i] = (uint16) code;
      z->firstsymbol[i] = (uint16) k;
      code = (code + sizes[i]);
      if (sizes[i])
         if (code-1 >= (1 << i)) return e("bad codelengths","Corrupt JPEG");
      z->maxcode[i] = code << (16-i); // preshift for inner loop
      code <<= 1;
      k += sizes[i];
   }
   z->maxcode[16] = 0x10000; // sentinel
   for (i=0; i < num; ++i) {
      int s = sizelist[i];
      if (s) {
         int c = next_code[s] - z->firstcode[s] + z->firstsymbol[s];
         z->size[c] = (uint8)s;
         z->value[c] = (uint16)i;
         if (s <= ZFAST_BITS) {
            int k = bit_reverse(next_code[s],s);
            while (k < (1 << ZFAST_BITS)) {
               z->fast[k] = (uint16) c;
               k += (1 << s);
            }
         }
         ++next_code[s];
      }
   }
   return 1;
}

// zlib-from-memory implementation for PNG reading
//    because PNG allows splitting the zlib stream arbitrarily,
//    and it's annoying structurally to have PNG call ZLIB call PNG,
//    we require PNG read all the IDATs and combine them into a single
//    memory buffer

typedef struct
{
   uint8 *zbuffer, *zbuffer_end;
   int num_bits;
   uint32 code_buffer;

   char *zout;
   char *zout_start;
   char *zout_end;
   int   z_expandable;

   zhuffman z_length, z_distance;
} zbuf;

__forceinline static int zget8(zbuf *z)
{
   if (z->zbuffer >= z->zbuffer_end) return 0;
   return *z->zbuffer++;
}

static void fill_bits(zbuf *z)
{
   do {
      assert(z->code_buffer < (1U << z->num_bits));
      z->code_buffer |= zget8(z) << z->num_bits;
      z->num_bits += 8;
   } while (z->num_bits <= 24);
}

__forceinline static unsigned int zreceive(zbuf *z, int n)
{
   unsigned int k;
   if (z->num_bits < n) fill_bits(z);
   k = z->code_buffer & ((1 << n) - 1);
   z->code_buffer >>= n;
   z->num_bits -= n;
   return k;
}

__forceinline static int zhuffman_decode(zbuf *a, zhuffman *z)
{
   int b,s,k;
   if (a->num_bits < 16) fill_bits(a);
   b = z->fast[a->code_buffer & ZFAST_MASK];
   if (b < 0xffff) {
      s = z->size[b];
      a->code_buffer >>= s;
      a->num_bits -= s;
      return z->value[b];
   }

   // not resolved by fast table, so compute it the slow way
   // use jpeg approach, which requires MSbits at top
   k = bit_reverse(a->code_buffer, 16);
   for (s=ZFAST_BITS+1; ; ++s)
      if (k < z->maxcode[s])
         break;
   if (s == 16) return -1; // invalid code!
   // code size is s, so:
   b = (k >> (16-s)) - z->firstcode[s] + z->firstsymbol[s];
   assert(z->size[b] == s);
   a->code_buffer >>= s;
   a->num_bits -= s;
   return z->value[b];
}

static int expand(zbuf *z, int n)  // need to make room for n bytes
{
   char *q;
   int cur, limit;
   if (!z->z_expandable) return e("output buffer limit","Corrupt PNG");
   cur   = (int) (z->zout     - z->zout_start);
   limit = (int) (z->zout_end - z->zout_start);
   while (cur + n > limit)
      limit *= 2;
   q = (char *) realloc(z->zout_start, limit);
   if (q == NULL) return e("outofmem", "Out of memory");
   z->zout_start = q;
   z->zout       = q + cur;
   z->zout_end   = q + limit;
   return 1;
}

static int length_base[31] = {
   3,4,5,6,7,8,9,10,11,13,
   15,17,19,23,27,31,35,43,51,59,
   67,83,99,115,131,163,195,227,258,0,0 };

static int length_extra[31]=
{ 0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0 };

static int dist_base[32] = { 1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,
257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0};

static int dist_extra[32] =
{ 0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};

static int parse_huffman_block(zbuf *a)
{
   for(;;) {
      int z = zhuffman_decode(a, &a->z_length);
      if (z < 256) {
         if (z < 0) return e("bad huffman code","Corrupt PNG"); // error in huffman codes
         if (a->zout >= a->zout_end) if (!expand(a, 1)) return 0;
         *a->zout++ = (char) z;
      } else {
         uint8 *p;
         int len,dist;
         if (z == 256) return 1;
         z -= 257;
         len = length_base[z];
         if (length_extra[z]) len += zreceive(a, length_extra[z]);
         z = zhuffman_decode(a, &a->z_distance);
         if (z < 0) return e("bad huffman code","Corrupt PNG");
         dist = dist_base[z];
         if (dist_extra[z]) dist += zreceive(a, dist_extra[z]);
         if (a->zout - a->zout_start < dist) return e("bad dist","Corrupt PNG");
         if (a->zout + len > a->zout_end) if (!expand(a, len)) return 0;
         p = (uint8 *) (a->zout - dist);
         while (len--)
            *a->zout++ = *p++;
      }
   }
}

static int compute_huffman_codes(zbuf *a)
{
   static uint8 length_dezigzag[19] = { 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15 };
   static zhuffman z_codelength; // static just to save stack space
   uint8 lencodes[286+32+137];//padding for maximum single op
   uint8 codelength_sizes[19];
   int i,n;

   int hlit  = zreceive(a,5) + 257;
   int hdist = zreceive(a,5) + 1;
   int hclen = zreceive(a,4) + 4;

   memset(codelength_sizes, 0, sizeof(codelength_sizes));
   for (i=0; i < hclen; ++i) {
      int s = zreceive(a,3);
      codelength_sizes[length_dezigzag[i]] = (uint8) s;
   }
   if (!zbuild_huffman(&z_codelength, codelength_sizes, 19)) return 0;

   n = 0;
   while (n < hlit + hdist) {
      int c = zhuffman_decode(a, &z_codelength);
      assert(c >= 0 && c < 19);
      if (c < 16)
         lencodes[n++] = (uint8) c;
      else if (c == 16) {
         c = zreceive(a,2)+3;
         memset(lencodes+n, lencodes[n-1], c);
         n += c;
      } else if (c == 17) {
         c = zreceive(a,3)+3;
         memset(lencodes+n, 0, c);
         n += c;
      } else {
         assert(c == 18);
         c = zreceive(a,7)+11;
         memset(lencodes+n, 0, c);
         n += c;
      }
   }
   if (n != hlit+hdist) return e("bad codelengths","Corrupt PNG");
   if (!zbuild_huffman(&a->z_length, lencodes, hlit)) return 0;
   if (!zbuild_huffman(&a->z_distance, lencodes+hlit, hdist)) return 0;
   return 1;
}

static int parse_uncompressed_block(zbuf *a)
{
   uint8 header[4];
   int len,nlen,k;
   if (a->num_bits & 7)
      zreceive(a, a->num_bits & 7); // discard
   // drain the bit-packed data into header
   k = 0;
   while (a->num_bits > 0) {
      header[k++] = (uint8) (a->code_buffer & 255); // wtf this warns?
      a->code_buffer >>= 8;
      a->num_bits -= 8;
   }
   assert(a->num_bits == 0);
   // now fill header the normal way
   while (k < 4)
      header[k++] = (uint8) zget8(a);
   len  = header[1] * 256 + header[0];
   nlen = header[3] * 256 + header[2];
   if (nlen != (len ^ 0xffff)) return e("zlib corrupt","Corrupt PNG");
   if (a->zbuffer + len > a->zbuffer_end) return e("read past buffer","Corrupt PNG");
   if (a->zout + len > a->zout_end)
      if (!expand(a, len)) return 0;
   memcpy(a->zout, a->zbuffer, len);
   a->zbuffer += len;
   a->zout += len;
   return 1;
}

static int parse_zlib_header(zbuf *a)
{
   int cmf   = zget8(a);
   int cm    = cmf & 15;
   /* int cinfo = cmf >> 4; */
   int flg   = zget8(a);
   if ((cmf*256+flg) % 31 != 0) return e("bad zlib header","Corrupt PNG"); // zlib spec
   if (flg & 32) return e("no preset dict","Corrupt PNG"); // preset dictionary not allowed in png
   if (cm != 8) return e("bad compression","Corrupt PNG"); // DEFLATE required for png
   // window = 1 << (8 + cinfo)... but who cares, we fully buffer output
   return 1;
}

// @TODO: should statically initialize these for optimal thread safety
static uint8 default_length[288], default_distance[32];
static void init_defaults(void)
{
   int i;   // use <= to match clearly with spec
   for (i=0; i <= 143; ++i)     default_length[i]   = 8;
   for (   ; i <= 255; ++i)     default_length[i]   = 9;
   for (   ; i <= 279; ++i)     default_length[i]   = 7;
   for (   ; i <= 287; ++i)     default_length[i]   = 8;

   for (i=0; i <=  31; ++i)     default_distance[i] = 5;
}

static int parse_zlib(zbuf *a, int parse_header)
{
   int final, type;
   if (parse_header)
      if (!parse_zlib_header(a)) return 0;
   a->num_bits = 0;
   a->code_buffer = 0;
   do {
      final = zreceive(a,1);
      type = zreceive(a,2);
      if (type == 0) {
         if (!parse_uncompressed_block(a)) return 0;
      } else if (type == 3) {
         return 0;
      } else {
         if (type == 1) {
            // use fixed code lengths
            if (!default_distance[31]) init_defaults();
            if (!zbuild_huffman(&a->z_length  , default_length  , 288)) return 0;
            if (!zbuild_huffman(&a->z_distance, default_distance,  32)) return 0;
         } else {
            if (!compute_huffman_codes(a)) return 0;
         }
         if (!parse_huffman_block(a)) return 0;
      }
   } while (!final);
   return 1;
}

static int do_zlib(zbuf *a, char *obuf, int olen, int exp, int parse_header)
{
   a->zout_start = obuf;
   a->zout       = obuf;
   a->zout_end   = obuf + olen;
   a->z_expandable = exp;

   return parse_zlib(a, parse_header);
}

char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen)
{
   zbuf a;
   char *p = (char *) malloc(initial_size);
   if (p == NULL) return NULL;
   a.zbuffer = (uint8 *) buffer;
   a.zbuffer_end = (uint8 *) buffer + len;
   if (do_zlib(&a, p, initial_size, 1, 1)) {
      if (outlen) *outlen = (int) (a.zout - a.zout_start);
      return a.zout_start;
   } else {
      free(a.zout_start);
      return NULL;
   }
}

char *stbi_zlib_decode_malloc(char const *buffer, int len, int *outlen)
{
   return stbi_zlib_decode_malloc_guesssize(buffer, len, 16384, outlen);
}

int stbi_zlib_decode_buffer(char *obuffer, int olen, char const *ibuffer, int ilen)
{
   zbuf a;
   a.zbuffer = (uint8 *) ibuffer;
   a.zbuffer_end = (uint8 *) ibuffer + ilen;
   if (do_zlib(&a, obuffer, olen, 0, 1))
      return (int) (a.zout - a.zout_start);
   else
      return -1;
}

char *stbi_zlib_decode_noheader_malloc(char const *buffer, int len, int *outlen)
{
   zbuf a;
   char *p = (char *) malloc(16384);
   if (p == NULL) return NULL;
   a.zbuffer = (uint8 *) buffer;
   a.zbuffer_end = (uint8 *) buffer+len;
   if (do_zlib(&a, p, 16384, 1, 0)) {
      if (outlen) *outlen = (int) (a.zout - a.zout_start);
      return a.zout_start;
   } else {
      free(a.zout_start);
      return NULL;
   }
}

int stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen)
{
   zbuf a;
   a.zbuffer = (uint8 *) ibuffer;
   a.zbuffer_end = (uint8 *) ibuffer + ilen;
   if (do_zlib(&a, obuffer, olen, 0, 0))
      return (int) (a.zout - a.zout_start);
   else
      return -1;
}

// public domain "baseline" PNG decoder   v0.10  Sean Barrett 2006-11-18
//    simple implementation
//      - only 8-bit samples
//      - no CRC checking
//      - allocates lots of intermediate memory
//        - avoids problem of streaming data between subsystems
//        - avoids explicit window management
//    performance
//      - uses stb_zlib, a PD zlib implementation with fast huffman decoding


typedef struct
{
   uint32 length;
   uint32 type;
} chunk;

#define PNG_TYPE(a,b,c,d)  (((a) << 24) + ((b) << 16) + ((c) << 8) + (d))

static chunk get_chunk_header(stbi *s)
{
   chunk c;
   c.length = get32(s);
   c.type   = get32(s);
   return c;
}

static int check_png_header(stbi *s)
{
   static uint8 png_sig[8] = { 137,80,78,71,13,10,26,10 };
   int i;
   for (i=0; i < 8; ++i)
      if (get8(s) != png_sig[i]) return e("bad png sig","Not a PNG");
   return 1;
}

typedef struct
{
   stbi s;
   uint8 *idata, *expanded, *out;
} png;


enum {
   F_none=0, F_sub=1, F_up=2, F_avg=3, F_paeth=4,
   F_avg_first, F_paeth_first,
};

static uint8 first_row_filter[5] =
{
   F_none, F_sub, F_none, F_avg_first, F_paeth_first
};

static int paeth(int a, int b, int c)
{
   int p = a + b - c;
   int pa = abs(p-a);
   int pb = abs(p-b);
   int pc = abs(p-c);
   if (pa <= pb && pa <= pc) return a;
   if (pb <= pc) return b;
   return c;
}

// create the png data from post-deflated data
static int create_png_image(png *a, uint8 *raw, uint32 raw_len, int out_n)
{
   stbi *s = &a->s;
   uint32 i,j,stride = s->img_x*out_n;
   int k;
   int img_n = s->img_n; // copy it into a local for later
   assert(out_n == s->img_n || out_n == s->img_n+1);
   a->out = (uint8 *) malloc(s->img_x * s->img_y * out_n);
   if (!a->out) return e("outofmem", "Out of memory");
   if (raw_len != (img_n * s->img_x + 1) * s->img_y) return e("not enough pixels","Corrupt PNG");
   for (j=0; j < s->img_y; ++j) {
      uint8 *cur = a->out + stride*j;
      uint8 *prior = cur - stride;
      int filter = *raw++;
      if (filter > 4) return e("invalid filter","Corrupt PNG");
      // if first row, use special filter that doesn't sample previous row
      if (j == 0) filter = first_row_filter[filter];
      // handle first pixel explicitly
      for (k=0; k < img_n; ++k) {
         switch(filter) {
            case F_none       : cur[k] = raw[k]; break;
            case F_sub        : cur[k] = raw[k]; break;
            case F_up         : cur[k] = raw[k] + prior[k]; break;
            case F_avg        : cur[k] = raw[k] + (prior[k]>>1); break;
            case F_paeth      : cur[k] = (uint8) (raw[k] + paeth(0,prior[k],0)); break;
            case F_avg_first  : cur[k] = raw[k]; break;
            case F_paeth_first: cur[k] = raw[k]; break;
         }
      }
      if (img_n != out_n) cur[img_n] = 255;
      raw += img_n;
      cur += out_n;
      prior += out_n;
      // this is a little gross, so that we don't switch per-pixel or per-component
      if (img_n == out_n) {
         #define CASE(f) \
             case f:     \
                for (i=s->img_x-1; i >= 1; --i, raw+=img_n,cur+=img_n,prior+=img_n) \
                   for (k=0; k < img_n; ++k)
         switch(filter) {
            CASE(F_none)  cur[k] = raw[k]; break;
            CASE(F_sub)   cur[k] = raw[k] + cur[k-img_n]; break;
            CASE(F_up)    cur[k] = raw[k] + prior[k]; break;
            CASE(F_avg)   cur[k] = raw[k] + ((prior[k] + cur[k-img_n])>>1); break;
            CASE(F_paeth)  cur[k] = (uint8) (raw[k] + paeth(cur[k-img_n],prior[k],prior[k-img_n])); break;
            CASE(F_avg_first)    cur[k] = raw[k] + (cur[k-img_n] >> 1); break;
            CASE(F_paeth_first)  cur[k] = (uint8) (raw[k] + paeth(cur[k-img_n],0,0)); break;
         }
         #undef CASE
      } else {
         assert(img_n+1 == out_n);
         #define CASE(f) \
             case f:     \
                for (i=s->img_x-1; i >= 1; --i, cur[img_n]=255,raw+=img_n,cur+=out_n,prior+=out_n) \
                   for (k=0; k < img_n; ++k)
         switch(filter) {
            CASE(F_none)  cur[k] = raw[k]; break;
            CASE(F_sub)   cur[k] = raw[k] + cur[k-out_n]; break;
            CASE(F_up)    cur[k] = raw[k] + prior[k]; break;
            CASE(F_avg)   cur[k] = raw[k] + ((prior[k] + cur[k-out_n])>>1); break;
            CASE(F_paeth)  cur[k] = (uint8) (raw[k] + paeth(cur[k-out_n],prior[k],prior[k-out_n])); break;
            CASE(F_avg_first)    cur[k] = raw[k] + (cur[k-out_n] >> 1); break;
            CASE(F_paeth_first)  cur[k] = (uint8) (raw[k] + paeth(cur[k-out_n],0,0)); break;
         }
         #undef CASE
      }
   }
   return 1;
}

static int compute_transparency(png *z, uint8 tc[3], int out_n)
{
   stbi *s = &z->s;
   uint32 i, pixel_count = s->img_x * s->img_y;
   uint8 *p = z->out;

   // compute color-based transparency, assuming we've
   // already got 255 as the alpha value in the output
   assert(out_n == 2 || out_n == 4);

   if (out_n == 2) {
      for (i=0; i < pixel_count; ++i) {
         p[1] = (p[0] == tc[0] ? 0 : 255);
         p += 2;
      }
   } else {
      for (i=0; i < pixel_count; ++i) {
         if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])
            p[3] = 0;
         p += 4;
      }
   }
   return 1;
}

static int expand_palette(png *a, uint8 *palette, int len, int pal_img_n)
{
   uint32 i, pixel_count = a->s.img_x * a->s.img_y;
   uint8 *p, *temp_out, *orig = a->out;

   p = (uint8 *) malloc(pixel_count * pal_img_n);
   if (p == NULL) return e("outofmem", "Out of memory");

   // between here and free(out) below, exitting would leak
   temp_out = p;

   if (pal_img_n == 3) {
      for (i=0; i < pixel_count; ++i) {
         int n = orig[i]*4;
         p[0] = palette[n  ];
         p[1] = palette[n+1];
         p[2] = palette[n+2];
         p += 3;
      }
   } else {
      for (i=0; i < pixel_count; ++i) {
         int n = orig[i]*4;
         p[0] = palette[n  ];
         p[1] = palette[n+1];
         p[2] = palette[n+2];
         p[3] = palette[n+3];
         p += 4;
      }
   }
   free(a->out);
   a->out = temp_out;
   return 1;
}

static int parse_png_file(png *z, int scan, int req_comp)
{
   uint8 palette[1024], pal_img_n=0;
   uint8 has_trans=0, tc[3];
   uint32 ioff=0, idata_limit=0, i, pal_len=0;
   int first=1,k;
   stbi *s = &z->s;

   if (!check_png_header(s)) return 0;

   if (scan == SCAN_type) return 1;

   for(;;first=0) {
      chunk c = get_chunk_header(s);
      if (first && c.type != PNG_TYPE('I','H','D','R'))
         return e("first not IHDR","Corrupt PNG");
      switch (c.type) {
         case PNG_TYPE('I','H','D','R'): {
            int depth,color,interlace,comp,filter;
            if (!first) return e("multiple IHDR","Corrupt PNG");
            if (c.length != 13) return e("bad IHDR len","Corrupt PNG");
            s->img_x = get32(s); if (s->img_x > (1 << 24)) return e("too large","Very large image (corrupt?)");
            s->img_y = get32(s); if (s->img_y > (1 << 24)) return e("too large","Very large image (corrupt?)");
            depth = get8(s);  if (depth != 8)        return e("8bit only","PNG not supported: 8-bit only");
            color = get8(s);  if (color > 6)         return e("bad ctype","Corrupt PNG");
            if (color == 3) pal_img_n = 3; else if (color & 1) return e("bad ctype","Corrupt PNG");
            comp  = get8(s);  if (comp) return e("bad comp method","Corrupt PNG");
            filter= get8(s);  if (filter) return e("bad filter method","Corrupt PNG");
            interlace = get8(s); if (interlace) return e("interlaced","PNG not supported: interlaced mode");
            if (!s->img_x || !s->img_y) return e("0-pixel image","Corrupt PNG");
            if (!pal_img_n) {
               s->img_n = (color & 2 ? 3 : 1) + (color & 4 ? 1 : 0);
               if ((1 << 30) / s->img_x / s->img_n < s->img_y) return e("too large", "Image too large to decode");
               if (scan == SCAN_header) return 1;
            } else {
               // if paletted, then pal_n is our final components, and
               // img_n is # components to decompress/filter.
               s->img_n = 1;
               if ((1 << 30) / s->img_x / 4 < s->img_y) return e("too large","Corrupt PNG");
               // if SCAN_header, have to scan to see if we have a tRNS
            }
            break;
         }

         case PNG_TYPE('P','L','T','E'):  {
            if (c.length > 256*3) return e("invalid PLTE","Corrupt PNG");
            pal_len = c.length / 3;
            if (pal_len * 3 != c.length) return e("invalid PLTE","Corrupt PNG");
            for (i=0; i < pal_len; ++i) {
               palette[i*4+0] = get8u(s);
               palette[i*4+1] = get8u(s);
               palette[i*4+2] = get8u(s);
               palette[i*4+3] = 255;
            }
            break;
         }

         case PNG_TYPE('t','R','N','S'): {
            if (z->idata) return e("tRNS after IDAT","Corrupt PNG");
            if (pal_img_n) {
               if (scan == SCAN_header) { s->img_n = 4; return 1; }
               if (pal_len == 0) return e("tRNS before PLTE","Corrupt PNG");
               if (c.length > pal_len) return e("bad tRNS len","Corrupt PNG");
               pal_img_n = 4;
               for (i=0; i < c.length; ++i)
                  palette[i*4+3] = get8u(s);
            } else {
               if (!(s->img_n & 1)) return e("tRNS with alpha","Corrupt PNG");
               if (c.length != (uint32) s->img_n*2) return e("bad tRNS len","Corrupt PNG");
               has_trans = 1;
               for (k=0; k < s->img_n; ++k)
                  tc[k] = (uint8) get16(s); // non 8-bit images will be larger
            }
            break;
         }

         case PNG_TYPE('I','D','A','T'): {
            if (pal_img_n && !pal_len) return e("no PLTE","Corrupt PNG");
            if (scan == SCAN_header) { s->img_n = pal_img_n; return 1; }
            if (ioff + c.length > idata_limit) {
               uint8 *p;
               if (idata_limit == 0) idata_limit = c.length > 4096 ? c.length : 4096;
               while (ioff + c.length > idata_limit)
                  idata_limit *= 2;
               p = (uint8 *) realloc(z->idata, idata_limit); if (p == NULL) return e("outofmem", "Out of memory");
               z->idata = p;
            }
            #ifndef STBI_NO_STDIO
            if (s->img_file)
            {
               if (fread(z->idata+ioff,1,c.length,s->img_file) != c.length) return e("outofdata","Corrupt PNG");
            }
            else
            #endif
            {
               memcpy(z->idata+ioff, s->img_buffer, c.length);
               s->img_buffer += c.length;
            }
            ioff += c.length;
            break;
         }

         case PNG_TYPE('I','E','N','D'): {
            uint32 raw_len;
            if (scan != SCAN_load) return 1;
            if (z->idata == NULL) return e("no IDAT","Corrupt PNG");
            z->expanded = (uint8 *) stbi_zlib_decode_malloc((char *) z->idata, ioff, (int *) &raw_len);
            if (z->expanded == NULL) return 0; // zlib should set error
            free(z->idata); z->idata = NULL;
            if ((req_comp == s->img_n+1 && req_comp != 3 && !pal_img_n) || has_trans)
               s->img_out_n = s->img_n+1;
            else
               s->img_out_n = s->img_n;
            if (!create_png_image(z, z->expanded, raw_len, s->img_out_n)) return 0;
            if (has_trans)
               if (!compute_transparency(z, tc, s->img_out_n)) return 0;
            if (pal_img_n) {
               // pal_img_n == 3 or 4
               s->img_n = pal_img_n; // record the actual colors we had
               s->img_out_n = pal_img_n;
               if (req_comp >= 3) s->img_out_n = req_comp;
               if (!expand_palette(z, palette, pal_len, s->img_out_n))
                  return 0;
            }
            free(z->expanded); z->expanded = NULL;
            return 1;
         }

         default:
            // if critical, fail
            if ((c.type & (1 << 29)) == 0) {
               #ifndef STBI_NO_FAILURE_STRINGS
               // not threadsafe
               static char invalid_chunk[] = "XXXX chunk not known";
               invalid_chunk[0] = (uint8) (c.type >> 24);
               invalid_chunk[1] = (uint8) (c.type >> 16);
               invalid_chunk[2] = (uint8) (c.type >>  8);
               invalid_chunk[3] = (uint8) (c.type >>  0);
               #endif
               return e(invalid_chunk, "PNG not supported: unknown chunk type");
            }
            skip(s, c.length);
            break;
      }
      // end of chunk, read and skip CRC
      get32(s);
   }
}

static unsigned char *do_png(png *p, int *x, int *y, int *n, int req_comp)
{
   unsigned char *result=NULL;
   p->expanded = NULL;
   p->idata = NULL;
   p->out = NULL;
   if (req_comp < 0 || req_comp > 4) return epuc("bad req_comp", "Internal error");
   if (parse_png_file(p, SCAN_load, req_comp)) {
      result = p->out;
      p->out = NULL;
      if (req_comp && req_comp != p->s.img_out_n) {
         result = convert_format(result, p->s.img_out_n, req_comp, p->s.img_x, p->s.img_y);
         p->s.img_out_n = req_comp;
         if (result == NULL) return result;
      }
      *x = p->s.img_x;
      *y = p->s.img_y;
      if (n) *n = p->s.img_n;
   }
   free(p->out);      p->out      = NULL;
   free(p->expanded); p->expanded = NULL;
   free(p->idata);    p->idata    = NULL;

   return result;
}

#ifndef STBI_NO_STDIO
unsigned char *stbi_png_load_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)
{
   png p;
   start_file(&p.s, f);
   return do_png(&p, x,y,comp,req_comp);
}

unsigned char *stbi_png_load(char const *filename, int *x, int *y, int *comp, int req_comp)
{
   unsigned char *data;
   FILE *f = fopen(filename, "rb");
   if (!f) return NULL;
   data = stbi_png_load_from_file(f,x,y,comp,req_comp);
   fclose(f);
   return data;
}
#endif

unsigned char *stbi_png_load_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
{
   png p;
   start_mem(&p.s, buffer,len);
   return do_png(&p, x,y,comp,req_comp);
}

#ifndef STBI_NO_STDIO
int stbi_png_test_file(FILE *f)
{
   png p;
   int n,r;
   n = ftell(f);
   start_file(&p.s, f);
   r = parse_png_file(&p, SCAN_type,STBI_default);
   fseek(f,n,SEEK_SET);
   return r;
}
#endif

int stbi_png_test_memory(stbi_uc const *buffer, int len)
{
   png p;
   start_mem(&p.s, buffer, len);
   return parse_png_file(&p, SCAN_type,STBI_default);
}

// TODO: load header from png
#ifndef STBI_NO_STDIO
extern int      stbi_png_info             (char const *filename,           int *x, int *y, int *comp);
extern int      stbi_png_info_from_file   (FILE *f,                  int *x, int *y, int *comp);
#endif
extern int      stbi_png_info_from_memory (stbi_uc const *buffer, int len, int *x, int *y, int *comp);

// Microsoft/Windows BMP image

static int bmp_test(stbi *s)
{
   int sz;
   if (get8(s) != 'B') return 0;
   if (get8(s) != 'M') return 0;
   get32le(s); // discard filesize
   get16le(s); // discard reserved
   get16le(s); // discard reserved
   get32le(s); // discard data offset
   sz = get32le(s);
   if (sz == 12 || sz == 40 || sz == 56 || sz == 108) return 1;
   return 0;
}

#ifndef STBI_NO_STDIO
int      stbi_bmp_test_file        (FILE *f)
{
   stbi s;
   int r,n = ftell(f);
   start_file(&s,f);
   r = bmp_test(&s);
   fseek(f,n,SEEK_SET);
   return r;
}
#endif

int      stbi_bmp_test_memory      (stbi_uc const *buffer, int len)
{
   stbi s;
   start_mem(&s, buffer, len);
   return bmp_test(&s);
}

// returns 0..31 for the highest set bit
static int high_bit(unsigned int z)
{
   int n=0;
   if (z == 0) return -1;
   if (z >= 0x10000) n += 16, z >>= 16;
   if (z >= 0x00100) n +=  8, z >>=  8;
   if (z >= 0x00010) n +=  4, z >>=  4;
   if (z >= 0x00004) n +=  2, z >>=  2;
   if (z >= 0x00002) n +=  1, z >>=  1;
   return n;
}

static int bitcount(unsigned int a)
{
   a = (a & 0x55555555) + ((a >>  1) & 0x55555555); // max 2
   a = (a & 0x33333333) + ((a >>  2) & 0x33333333); // max 4
   a = (a + (a >> 4)) & 0x0f0f0f0f; // max 8 per 4, now 8 bits
   a = (a + (a >> 8)); // max 16 per 8 bits
   a = (a + (a >> 16)); // max 32 per 8 bits
   return a & 0xff;
}

static int shiftsigned(int v, int shift, int bits)
{
   int result;
   int z=0;

   if (shift < 0) v <<= -shift;
   else v >>= shift;
   result = v;

   z = bits;
   while (z < 8) {
      result += v >> z;
      z += bits;
   }
   return result;
}

static stbi_uc *bmp_load(stbi *s, int *x, int *y, int *comp, int req_comp)
{
   uint8 *out;
   unsigned int mr=0,mg=0,mb=0,ma=0;
   stbi_uc pal[256][4];
   int psize=0,i,j,compress=0,width;
   int bpp, flip_vertically, pad, target, offset, hsz;
   if (get8(s) != 'B' || get8(s) != 'M') return epuc("not BMP", "Corrupt BMP");
   get32le(s); // discard filesize
   get16le(s); // discard reserved
   get16le(s); // discard reserved
   offset = get32le(s);
   hsz = get32le(s);
   if (hsz != 12 && hsz != 40 && hsz != 56 && hsz != 108) return epuc("unknown BMP", "BMP type not supported: unknown");
   failure_reason = "bad BMP";
   if (hsz == 12) {
      s->img_x = get16le(s);
      s->img_y = get16le(s);
   } else {
      s->img_x = get32le(s);
      s->img_y = get32le(s);
   }
   if (get16le(s) != 1) return 0;
   bpp = get16le(s);
   if (bpp == 1) return epuc("monochrome", "BMP type not supported: 1-bit");
   flip_vertically = ((int) s->img_y) > 0;
   s->img_y = abs((int) s->img_y);
   if (hsz == 12) {
      if (bpp < 24)
         psize = (offset - 14 - 24) / 3;
   } else {
      compress = get32le(s);
      if (compress == 1 || compress == 2) return epuc("BMP RLE", "BMP type not supported: RLE");
      get32le(s); // discard sizeof
      get32le(s); // discard hres
      get32le(s); // discard vres
      get32le(s); // discard colorsused
      get32le(s); // discard max important
      if (hsz == 40 || hsz == 56) {
         if (hsz == 56) {
            get32le(s);
            get32le(s);
            get32le(s);
            get32le(s);
         }
         if (bpp == 16 || bpp == 32) {
            mr = mg = mb = 0;
            if (compress == 0) {
               if (bpp == 32) {
                  mr = 0xff << 16;
                  mg = 0xff <<  8;
                  mb = 0xff <<  0;
               } else {
                  mr = 31 << 10;
                  mg = 31 <<  5;
                  mb = 31 <<  0;
               }
            } else if (compress == 3) {
               mr = get32le(s);
               mg = get32le(s);
               mb = get32le(s);
               // not documented, but generated by photoshop and handled by mspaint
               if (mr == mg && mg == mb) {
                  // ?!?!?
                  return NULL;
               }
            } else
               return NULL;
         }
      } else {
         assert(hsz == 108);
         mr = get32le(s);
         mg = get32le(s);
         mb = get32le(s);
         ma = get32le(s);
         get32le(s); // discard color space
         for (i=0; i < 12; ++i)
            get32le(s); // discard color space parameters
      }
      if (bpp < 16)
         psize = (offset - 14 - hsz) >> 2;
   }
   s->img_n = ma ? 4 : 3;
   if (req_comp && req_comp >= 3) // we can directly decode 3 or 4
      target = req_comp;
   else
      target = s->img_n; // if they want monochrome, we'll post-convert
   out = (stbi_uc *) malloc(target * s->img_x * s->img_y);
   if (!out) return epuc("outofmem", "Out of memory");
   if (bpp < 16) {
      int z=0;
      if (psize == 0 || psize > 256) { free(out); return epuc("invalid", "Corrupt BMP"); }
      for (i=0; i < psize; ++i) {
         pal[i][2] = get8(s);
         pal[i][1] = get8(s);
         pal[i][0] = get8(s);
         if (hsz != 12) get8(s);
         pal[i][3] = 255;
      }
      skip(s, offset - 14 - hsz - psize * (hsz == 12 ? 3 : 4));
      if (bpp == 4) width = (s->img_x + 1) >> 1;
      else if (bpp == 8) width = s->img_x;
      else { free(out); return epuc("bad bpp", "Corrupt BMP"); }
      pad = (-width)&3;
      for (j=0; j < (int) s->img_y; ++j) {
         for (i=0; i < (int) s->img_x; i += 2) {
            int v=get8(s),v2=0;
            if (bpp == 4) {
               v2 = v & 15;
               v >>= 4;
            }
            out[z++] = pal[v][0];
            out[z++] = pal[v][1];
            out[z++] = pal[v][2];
            if (target == 4) out[z++] = 255;
            if (i+1 == (int) s->img_x) break;
            v = (bpp == 8) ? get8(s) : v2;
            out[z++] = pal[v][0];
            out[z++] = pal[v][1];
            out[z++] = pal[v][2];
            if (target == 4) out[z++] = 255;
         }
         skip(s, pad);
      }
   } else {
      int rshift=0,gshift=0,bshift=0,ashift=0,rcount=0,gcount=0,bcount=0,acount=0;
      int z = 0;
      int easy=0;
      skip(s, offset - 14 - hsz);
      if (bpp == 24) width = 3 * s->img_x;
      else if (bpp == 16) width = 2*s->img_x;
      else /* bpp = 32 and pad = 0 */ width=0;
      pad = (-width) & 3;
      if (bpp == 24) {
         easy = 1;
      } else if (bpp == 32) {
         if (mb == 0xff && mg == 0xff00 && mr == 0xff000000 && ma == 0xff000000)
            easy = 2;
      }
      if (!easy) {
         if (!mr || !mg || !mb) return epuc("bad masks", "Corrupt BMP");
         // right shift amt to put high bit in position #7
         rshift = high_bit(mr)-7; rcount = bitcount(mr);
         gshift = high_bit(mg)-7; gcount = bitcount(mr);
         bshift = high_bit(mb)-7; bcount = bitcount(mr);
         ashift = high_bit(ma)-7; acount = bitcount(mr);
      }
      for (j=0; j < (int) s->img_y; ++j) {
         if (easy) {
            for (i=0; i < (int) s->img_x; ++i) {
               int a;
               out[z+2] = get8(s);
               out[z+1] = get8(s);
               out[z+0] = get8(s);
               z += 3;
               a = (easy == 2 ? get8(s) : 255);
               if (target == 4) out[z++] = a;
            }
         } else {
            for (i=0; i < (int) s->img_x; ++i) {
               uint32 v = (bpp == 16 ? get16le(s) : get32le(s));
               int a;
               out[z++] = shiftsigned(v & mr, rshift, rcount);
               out[z++] = shiftsigned(v & mg, gshift, gcount);
               out[z++] = shiftsigned(v & mb, bshift, bcount);
               a = (ma ? shiftsigned(v & ma, ashift, acount) : 255);
               if (target == 4) out[z++] = a;
            }
         }
         skip(s, pad);
      }
   }
   if (flip_vertically) {
      stbi_uc t;
      for (j=0; j < (int) s->img_y>>1; ++j) {
         stbi_uc *p1 = out +      j     *s->img_x*target;
         stbi_uc *p2 = out + (s->img_y-1-j)*s->img_x*target;
         for (i=0; i < (int) s->img_x*target; ++i) {
            t = p1[i], p1[i] = p2[i], p2[i] = t;
         }
      }
   }

   if (req_comp && req_comp != target) {
      out = convert_format(out, target, req_comp, s->img_x, s->img_y);
      if (out == NULL) return out; // convert_format frees input on failure
   }

   *x = s->img_x;
   *y = s->img_y;
   if (comp) *comp = target;
   return out;
}

#ifndef STBI_NO_STDIO
stbi_uc *stbi_bmp_load             (char const *filename,           int *x, int *y, int *comp, int req_comp)
{
   stbi_uc *data;
   FILE *f = fopen(filename, "rb");
   if (!f) return NULL;
   data = stbi_bmp_load_from_file(f, x,y,comp,req_comp);
   fclose(f);
   return data;
}

stbi_uc *stbi_bmp_load_from_file   (FILE *f,                  int *x, int *y, int *comp, int req_comp)
{
   stbi s;
   start_file(&s, f);
   return bmp_load(&s, x,y,comp,req_comp);
}
#endif

stbi_uc *stbi_bmp_load_from_memory (stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
{
   stbi s;
   start_mem(&s, buffer, len);
   return bmp_load(&s, x,y,comp,req_comp);
}

// Targa Truevision - TGA
// by Jonathan Dummer

static int tga_test(stbi *s)
{
	int sz;
	get8u(s);		//	discard Offset
	sz = get8u(s);	//	color type
	if( sz > 1 ) return 0;	//	only RGB or indexed allowed
	sz = get8u(s);	//	image type
	if( (sz != 1) && (sz != 2) && (sz != 3) && (sz != 9) && (sz != 10) && (sz != 11) ) return 0;	//	only RGB or grey allowed, +/- RLE
	get16(s);		//	discard palette start
	get16(s);		//	discard palette length
	get8(s);			//	discard bits per palette color entry
	get16(s);		//	discard x origin
	get16(s);		//	discard y origin
	if( get16(s) < 1 ) return 0;		//	test width
	if( get16(s) < 1 ) return 0;		//	test height
	sz = get8(s);	//	bits per pixel
	if( (sz != 8) && (sz != 16) && (sz != 24) && (sz != 32) ) return 0;	//	only RGB or RGBA or grey allowed
	return 1;		//	seems to have passed everything
}

#ifndef STBI_NO_STDIO
int      stbi_tga_test_file        (FILE *f)
{
   stbi s;
   int r,n = ftell(f);
   start_file(&s, f);
   r = tga_test(&s);
   fseek(f,n,SEEK_SET);
   return r;
}
#endif

int      stbi_tga_test_memory      (stbi_uc const *buffer, int len)
{
   stbi s;
   start_mem(&s, buffer, len);
   return tga_test(&s);
}

static stbi_uc *tga_load(stbi *s, int *x, int *y, int *comp, int req_comp)
{
	//	read in the TGA header stuff
	int tga_offset = get8u(s);
	int tga_indexed = get8u(s);
	int tga_image_type = get8u(s);
	int tga_is_RLE = 0;
	int tga_palette_start = get16le(s);
	int tga_palette_len = get16le(s);
	int tga_palette_bits = get8u(s);
	int tga_x_origin = get16le(s);
	int tga_y_origin = get16le(s);
	int tga_width = get16le(s);
	int tga_height = get16le(s);
	int tga_bits_per_pixel = get8u(s);
	int tga_inverted = get8u(s);
	//	image data
	unsigned char *tga_data;
	unsigned char *tga_palette = NULL;
	int i, j;
	unsigned char raw_data[4];
	unsigned char trans_data[] = { 0,0,0,0 };
	int RLE_count = 0;
	int RLE_repeating = 0;
	int read_next_pixel = 1;
	//	do a tiny bit of precessing
	if( tga_image_type >= 8 )
	{
		tga_image_type -= 8;
		tga_is_RLE = 1;
	}
	/* int tga_alpha_bits = tga_inverted & 15; */
	tga_inverted = 1 - ((tga_inverted >> 5) & 1);

	//	error check
	if( //(tga_indexed) ||
		(tga_width < 1) || (tga_height < 1) ||
		(tga_image_type < 1) || (tga_image_type > 3) ||
		((tga_bits_per_pixel != 8) && (tga_bits_per_pixel != 16) &&
		(tga_bits_per_pixel != 24) && (tga_bits_per_pixel != 32))
		)
	{
		return NULL;
	}

	//	If I'm paletted, then I'll use the number of bits from the palette
	if( tga_indexed )
	{
		tga_bits_per_pixel = tga_palette_bits;
	}

	//	tga info
	*x = tga_width;
	*y = tga_height;
	if( (req_comp < 1) || (req_comp > 4) )
	{
		//	just use whatever the file was
		req_comp = tga_bits_per_pixel / 8;
		*comp = req_comp;
	} else
	{
		//	force a new number of components
		*comp = tga_bits_per_pixel/8;
	}
	tga_data = (unsigned char*)malloc( tga_width * tga_height * req_comp );

	//	skip to the data's starting position (offset usually = 0)
	skip(s, tga_offset );
	//	do I need to load a palette?
	if( tga_indexed )
	{
		//	any data to skip? (offset usually = 0)
		skip(s, tga_palette_start );
		//	load the palette
		tga_palette = (unsigned char*)malloc( tga_palette_len * tga_palette_bits / 8 );
		getn(s, tga_palette, tga_palette_len * tga_palette_bits / 8 );
	}
	//	load the data
	for( i = 0; i < tga_width * tga_height; ++i )
	{
		//	if I'm in RLE mode, do I need to get a RLE chunk?
		if( tga_is_RLE )
		{
			if( RLE_count == 0 )
			{
				//	yep, get the next byte as a RLE command
				int RLE_cmd = get8u(s);
				RLE_count = 1 + (RLE_cmd & 127);
				RLE_repeating = RLE_cmd >> 7;
				read_next_pixel = 1;
			} else if( !RLE_repeating )
			{
				read_next_pixel = 1;
			}
		} else
		{
			read_next_pixel = 1;
		}
		//	OK, if I need to read a pixel, do it now
		if( read_next_pixel )
		{
			//	load however much data we did have
			if( tga_indexed )
			{
				//	read in 1 byte, then perform the lookup
				int pal_idx = get8u(s);
				if( pal_idx >= tga_palette_len )
				{
					//	invalid index
					pal_idx = 0;
				}
				pal_idx *= tga_bits_per_pixel / 8;
				for( j = 0; j*8 < tga_bits_per_pixel; ++j )
				{
					raw_data[j] = tga_palette[pal_idx+j];
				}
			} else
			{
				//	read in the data raw
				for( j = 0; j*8 < tga_bits_per_pixel; ++j )
				{
					raw_data[j] = get8u(s);
				}
			}
			//	convert raw to the intermediate format
			switch( tga_bits_per_pixel )
			{
			case 8:
				//	Luminous => RGBA
				trans_data[0] = raw_data[0];
				trans_data[1] = raw_data[0];
				trans_data[2] = raw_data[0];
				trans_data[3] = 255;
				break;
			case 16:
				//	Luminous,Alpha => RGBA
				trans_data[0] = raw_data[0];
				trans_data[1] = raw_data[0];
				trans_data[2] = raw_data[0];
				trans_data[3] = raw_data[1];
				break;
			case 24:
				//	BGR => RGBA
				trans_data[0] = raw_data[2];
				trans_data[1] = raw_data[1];
				trans_data[2] = raw_data[0];
				trans_data[3] = 255;
				break;
			case 32:
				//	BGRA => RGBA
				trans_data[0] = raw_data[2];
				trans_data[1] = raw_data[1];
				trans_data[2] = raw_data[0];
				trans_data[3] = raw_data[3];
				break;
			}
			//	clear the reading flag for the next pixel
			read_next_pixel = 0;
		} // end of reading a pixel
		//	convert to final format
		switch( req_comp )
		{
		case 1:
			//	RGBA => Luminance
			tga_data[i*req_comp+0] = compute_y(trans_data[0],trans_data[1],trans_data[2]);
			break;
		case 2:
			//	RGBA => Luminance,Alpha
			tga_data[i*req_comp+0] = compute_y(trans_data[0],trans_data[1],trans_data[2]);
			tga_data[i*req_comp+1] = trans_data[3];
			break;
		case 3:
			//	RGBA => RGB
			tga_data[i*req_comp+0] = trans_data[0];
			tga_data[i*req_comp+1] = trans_data[1];
			tga_data[i*req_comp+2] = trans_data[2];
			break;
		case 4:
			//	RGBA => RGBA
			tga_data[i*req_comp+0] = trans_data[0];
			tga_data[i*req_comp+1] = trans_data[1];
			tga_data[i*req_comp+2] = trans_data[2];
			tga_data[i*req_comp+3] = trans_data[3];
			break;
		}
		//	in case we're in RLE mode, keep counting down
		--RLE_count;
	}
	//	do I need to invert the image?
	if( tga_inverted )
	{
		for( j = 0; j*2 < tga_height; ++j )
		{
			int index1 = j * tga_width * req_comp;
			int index2 = (tga_height - 1 - j) * tga_width * req_comp;
			for( i = tga_width * req_comp; i > 0; --i )
			{
				unsigned char temp = tga_data[index1];
				tga_data[index1] = tga_data[index2];
				tga_data[index2] = temp;
				++index1;
				++index2;
			}
		}
	}
	//	clear my palette, if I had one
	if( tga_palette != NULL )
	{
		free( tga_palette );
	}
	//	the things I do to get rid of an error message, and yet keep
	//	Microsoft's C compilers happy... [8^(
	tga_palette_start = tga_palette_len = tga_palette_bits =
			tga_x_origin = tga_y_origin = 0;
	//	OK, done
	return tga_data;
}

#ifndef STBI_NO_STDIO
stbi_uc *stbi_tga_load             (char const *filename,           int *x, int *y, int *comp, int req_comp)
{
   stbi_uc *data;
   FILE *f = fopen(filename, "rb");
   if (!f) return NULL;
   data = stbi_tga_load_from_file(f, x,y,comp,req_comp);
   fclose(f);
   return data;
}

stbi_uc *stbi_tga_load_from_file   (FILE *f,                  int *x, int *y, int *comp, int req_comp)
{
   stbi s;
   start_file(&s, f);
   return tga_load(&s, x,y,comp,req_comp);
}
#endif

stbi_uc *stbi_tga_load_from_memory (stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
{
   stbi s;
   start_mem(&s, buffer, len);
   return tga_load(&s, x,y,comp,req_comp);
}


// *************************************************************************************************
// Photoshop PSD loader -- PD by Thatcher Ulrich, integration by Nicholas Schulz, tweaked by STB

static int psd_test(stbi *s)
{
	if (get32(s) != 0x38425053) return 0;	// "8BPS"
	else return 1;
}

#ifndef STBI_NO_STDIO
int stbi_psd_test_file(FILE *f)
{
   stbi s;
   int r,n = ftell(f);
   start_file(&s, f);
   r = psd_test(&s);
   fseek(f,n,SEEK_SET);
   return r;
}
#endif

int stbi_psd_test_memory(stbi_uc const *buffer, int len)
{
   stbi s;
   start_mem(&s, buffer, len);
   return psd_test(&s);
}

static stbi_uc *psd_load(stbi *s, int *x, int *y, int *comp, int req_comp)
{
	int	pixelCount;
	int channelCount, compression;
	int channel, i, count, len;
   int w,h;
   uint8 *out;

	// Check identifier
	if (get32(s) != 0x38425053)	// "8BPS"
		return epuc("not PSD", "Corrupt PSD image");

	// Check file type version.
	if (get16(s) != 1)
		return epuc("wrong version", "Unsupported version of PSD image");

	// Skip 6 reserved bytes.
	skip(s, 6 );

	// Read the number of channels (R, G, B, A, etc).
	channelCount = get16(s);
	if (channelCount < 0 || channelCount > 16)
		return epuc("wrong channel count", "Unsupported number of channels in PSD image");

	// Read the rows and columns of the image.
   h = get32(s);
   w = get32(s);

	// Make sure the depth is 8 bits.
	if (get16(s) != 8)
		return epuc("unsupported bit depth", "PSD bit depth is not 8 bit");

	// Make sure the color mode is RGB.
	// Valid options are:
	//   0: Bitmap
	//   1: Grayscale
	//   2: Indexed color
	//   3: RGB color
	//   4: CMYK color
	//   7: Multichannel
	//   8: Duotone
	//   9: Lab color
	if (get16(s) != 3)
		return epuc("wrong color format", "PSD is not in RGB color format");

	// Skip the Mode Data.  (It's the palette for indexed color; other info for other modes.)
	skip(s,get32(s) );

	// Skip the image resources.  (resolution, pen tool paths, etc)
	skip(s, get32(s) );

	// Skip the reserved data.
	skip(s, get32(s) );

	// Find out if the data is compressed.
	// Known values:
	//   0: no compression
	//   1: RLE compressed
	compression = get16(s);
	if (compression > 1)
		return epuc("bad compression", "PSD has an unknown compression format");

	// Create the destination image.
	out = (stbi_uc *) malloc(4 * w*h);
	if (!out) return epuc("outofmem", "Out of memory");
   pixelCount = w*h;

	// Initialize the data to zero.
	//memset( out, 0, pixelCount * 4 );

	// Finally, the image data.
	if (compression) {
		// RLE as used by .PSD and .TIFF
		// Loop until you get the number of unpacked bytes you are expecting:
		//     Read the next source byte into n.
		//     If n is between 0 and 127 inclusive, copy the next n+1 bytes literally.
		//     Else if n is between -127 and -1 inclusive, copy the next byte -n+1 times.
		//     Else if n is 128, noop.
		// Endloop

		// The RLE-compressed data is preceeded by a 2-byte data count for each row in the data,
		// which we're going to just skip.
		skip(s, h * channelCount * 2 );

		// Read the RLE data by channel.
		for (channel = 0; channel < 4; channel++) {
			uint8 *p;

         p = out+channel;
			if (channel >= channelCount) {
				// Fill this channel with default data.
				for (i = 0; i < pixelCount; i++) *p = (channel == 3 ? 255 : 0), p += 4;
			} else {
				// Read the RLE data.
				count = 0;
				while (count < pixelCount) {
					len = get8(s);
					if (len == 128) {
						// No-op.
					} else if (len < 128) {
						// Copy next len+1 bytes literally.
						len++;
						count += len;
						while (len) {
							*p = get8(s);
                     p += 4;
							len--;
						}
					} else if (len > 128) {
						uint32	val;
						// Next -len+1 bytes in the dest are replicated from next source byte.
						// (Interpret len as a negative 8-bit int.)
						len ^= 0x0FF;
						len += 2;
                  val = get8(s);
						count += len;
						while (len) {
							*p = val;
                     p += 4;
							len--;
						}
					}
				}
			}
		}

	} else {
		// We're at the raw image data.  It's each channel in order (Red, Green, Blue, Alpha, ...)
		// where each channel consists of an 8-bit value for each pixel in the image.

		// Read the data by channel.
		for (channel = 0; channel < 4; channel++) {
			uint8 *p;

         p = out + channel;
			if (channel > channelCount) {
				// Fill this channel with default data.
				for (i = 0; i < pixelCount; i++) *p = channel == 3 ? 255 : 0, p += 4;
			} else {
				// Read the data.
				count = 0;
				for (i = 0; i < pixelCount; i++)
					*p = get8(s), p += 4;
			}
		}
	}

	if (req_comp && req_comp != 4) {
		out = convert_format(out, 4, req_comp, w, h);
		if (out == NULL) return out; // convert_format frees input on failure
	}

	if (comp) *comp = channelCount;
	*y = h;
	*x = w;

	return out;
}

#ifndef STBI_NO_STDIO
stbi_uc *stbi_psd_load(char const *filename, int *x, int *y, int *comp, int req_comp)
{
   stbi_uc *data;
   FILE *f = fopen(filename, "rb");
   if (!f) return NULL;
   data = stbi_psd_load_from_file(f, x,y,comp,req_comp);
   fclose(f);
   return data;
}

stbi_uc *stbi_psd_load_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)
{
   stbi s;
   start_file(&s, f);
   return psd_load(&s, x,y,comp,req_comp);
}
#endif

stbi_uc *stbi_psd_load_from_memory (stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
{
   stbi s;
   start_mem(&s, buffer, len);
   return psd_load(&s, x,y,comp,req_comp);
}


// *************************************************************************************************
// Radiance RGBE HDR loader
// originally by Nicolas Schulz
#ifndef STBI_NO_HDR
static int hdr_test(stbi *s)
{
   char *signature = "#?RADIANCE\n";
   int i;
   for (i=0; signature[i]; ++i)
      if (get8(s) != signature[i])
         return 0;
	return 1;
}

int stbi_hdr_test_memory(stbi_uc const *buffer, int len)
{
   stbi s;
	start_mem(&s, buffer, len);
	return hdr_test(&s);
}

#ifndef STBI_NO_STDIO
int stbi_hdr_test_file(FILE *f)
{
   stbi s;
   int r,n = ftell(f);
   start_file(&s, f);
   r = hdr_test(&s);
   fseek(f,n,SEEK_SET);
   return r;
}
#endif

#define HDR_BUFLEN  1024
static char *hdr_gettoken(stbi *z, char *buffer)
{
   int len=0;
	//char *s = buffer,
	char c = '\0';

   c = get8(z);

	while (!at_eof(z) && c != '\n') {
		buffer[len++] = c;
      if (len == HDR_BUFLEN-1) {
         // flush to end of line
         while (!at_eof(z) && get8(z) != '\n')
            ;
         break;
      }
      c = get8(z);
	}

   buffer[len] = 0;
	return buffer;
}

static void hdr_convert(float *output, stbi_uc *input, int req_comp)
{
	if( input[3] != 0 ) {
      float f1;
		// Exponent
		f1 = (float) ldexp(1.0f, input[3] - (int)(128 + 8));
      if (req_comp <= 2)
         output[0] = (input[0] + input[1] + input[2]) * f1 / 3;
      else {
         output[0] = input[0] * f1;
         output[1] = input[1] * f1;
         output[2] = input[2] * f1;
      }
      if (req_comp == 2) output[1] = 1;
      if (req_comp == 4) output[3] = 1;
	} else {
      switch (req_comp) {
         case 4: output[3] = 1; /* fallthrough */
         case 3: output[0] = output[1] = output[2] = 0;
                 break;
         case 2: output[1] = 1; /* fallthrough */
         case 1: output[0] = 0;
                 break;
      }
	}
}


static float *hdr_load(stbi *s, int *x, int *y, int *comp, int req_comp)
{
   char buffer[HDR_BUFLEN];
	char *token;
	int valid = 0;
	int width, height;
   stbi_uc *scanline;
	float *hdr_data;
	int len;
	unsigned char count, value;
	int i, j, k, c1,c2, z;


	// Check identifier
	if (strcmp(hdr_gettoken(s,buffer), "#?RADIANCE") != 0)
		return epf("not HDR", "Corrupt HDR image");

	// Parse header
	while(1) {
		token = hdr_gettoken(s,buffer);
      if (token[0] == 0) break;
		if (strcmp(token, "FORMAT=32-bit_rle_rgbe") == 0) valid = 1;
   }

	if (!valid)    return epf("unsupported format", "Unsupported HDR format");

   // Parse width and height
   // can't use sscanf() if we're not using stdio!
   token = hdr_gettoken(s,buffer);
   if (strncmp(token, "-Y ", 3))  return epf("unsupported data layout", "Unsupported HDR format");
   token += 3;
   height = strtol(token, &token, 10);
   while (*token == ' ') ++token;
   if (strncmp(token, "+X ", 3))  return epf("unsupported data layout", "Unsupported HDR format");
   token += 3;
   width = strtol(token, NULL, 10);

	*x = width;
	*y = height;

   *comp = 3;
	if (req_comp == 0) req_comp = 3;

	// Read data
	hdr_data = (float *) malloc(height * width * req_comp * sizeof(float));

	// Load image data
   // image data is stored as some number of sca
	if( width < 8 || width >= 32768) {
		// Read flat data
      for (j=0; j < height; ++j) {
         for (i=0; i < width; ++i) {
            stbi_uc rgbe[4];
           main_decode_loop:
            getn(s, rgbe, 4);
            hdr_convert(hdr_data + j * width * req_comp + i * req_comp, rgbe, req_comp);
         }
      }
	} else {
		// Read RLE-encoded data
		scanline = NULL;

		for (j = 0; j < height; ++j) {
         c1 = get8(s);
         c2 = get8(s);
         len = get8(s);
         if (c1 != 2 || c2 != 2 || (len & 0x80)) {
            // not run-length encoded, so we have to actually use THIS data as a decoded
            // pixel (note this can't be a valid pixel--one of RGB must be >= 128)
            stbi_uc rgbe[4] = { c1,c2,len, get8(s) };
            hdr_convert(hdr_data, rgbe, req_comp);
            i = 1;
            j = 0;
            free(scanline);
            goto main_decode_loop; // yes, this is fucking insane; blame the fucking insane format
         }
         len <<= 8;
         len |= get8(s);
         if (len != width) { free(hdr_data); free(scanline); return epf("invalid decoded scanline length", "corrupt HDR"); }
         if (scanline == NULL) scanline = (stbi_uc *) malloc(width * 4);

			for (k = 0; k < 4; ++k) {
				i = 0;
				while (i < width) {
					count = get8(s);
					if (count > 128) {
						// Run
						value = get8(s);
                  count -= 128;
						for (z = 0; z < count; ++z)
							scanline[i++ * 4 + k] = value;
					} else {
						// Dump
						for (z = 0; z < count; ++z)
							scanline[i++ * 4 + k] = get8(s);
					}
				}
			}
         for (i=0; i < width; ++i)
            hdr_convert(hdr_data+(j*width + i)*req_comp, scanline + i*4, req_comp);
		}
      free(scanline);
	}

   return hdr_data;
}

static stbi_uc *hdr_load_rgbe(stbi *s, int *x, int *y, int *comp, int req_comp)
{
   char buffer[HDR_BUFLEN];
	char *token;
	int valid = 0;
	int width, height;
   stbi_uc *scanline;
	stbi_uc *rgbe_data;
	int len;
	unsigned char count, value;
	int i, j, k, c1,c2, z;


	// Check identifier
	if (strcmp(hdr_gettoken(s,buffer), "#?RADIANCE") != 0)
		return epuc("not HDR", "Corrupt HDR image");

	// Parse header
	while(1) {
		token = hdr_gettoken(s,buffer);
      if (token[0] == 0) break;
		if (strcmp(token, "FORMAT=32-bit_rle_rgbe") == 0) valid = 1;
   }

	if (!valid)    return epuc("unsupported format", "Unsupported HDR format");

   // Parse width and height
   // can't use sscanf() if we're not using stdio!
   token = hdr_gettoken(s,buffer);
   if (strncmp(token, "-Y ", 3))  return epuc("unsupported data layout", "Unsupported HDR format");
   token += 3;
   height = strtol(token, &token, 10);
   while (*token == ' ') ++token;
   if (strncmp(token, "+X ", 3))  return epuc("unsupported data layout", "Unsupported HDR format");
   token += 3;
   width = strtol(token, NULL, 10);

	*x = width;
	*y = height;

	// RGBE _MUST_ come out as 4 components
   *comp = 4;
	req_comp = 4;

	// Read data
	rgbe_data = (stbi_uc *) malloc(height * width * req_comp * sizeof(stbi_uc));
	//	point to the beginning
	scanline = rgbe_data;

	// Load image data
   // image data is stored as some number of scan lines
	if( width < 8 || width >= 32768) {
		// Read flat data
      for (j=0; j < height; ++j) {
         for (i=0; i < width; ++i) {
           main_decode_loop:
            //getn(rgbe, 4);
            getn(s,scanline, 4);
			scanline += 4;
         }
      }
	} else {
		// Read RLE-encoded data
		for (j = 0; j < height; ++j) {
         c1 = get8(s);
         c2 = get8(s);
         len = get8(s);
         if (c1 != 2 || c2 != 2 || (len & 0x80)) {
            // not run-length encoded, so we have to actually use THIS data as a decoded
            // pixel (note this can't be a valid pixel--one of RGB must be >= 128)
            scanline[0] = c1;
            scanline[1] = c2;
            scanline[2] = len;
            scanline[3] = get8(s);
            scanline += 4;
            i = 1;
            j = 0;
            goto main_decode_loop; // yes, this is insane; blame the insane format
         }
         len <<= 8;
         len |= get8(s);
         if (len != width) { free(rgbe_data); return epuc("invalid decoded scanline length", "corrupt HDR"); }
			for (k = 0; k < 4; ++k) {
				i = 0;
				while (i < width) {
					count = get8(s);
					if (count > 128) {
						// Run
						value = get8(s);
                  count -= 128;
						for (z = 0; z < count; ++z)
							scanline[i++ * 4 + k] = value;
					} else {
						// Dump
						for (z = 0; z < count; ++z)
							scanline[i++ * 4 + k] = get8(s);
					}
				}
			}
			//	move the scanline on
			scanline += 4 * width;
		}
	}

   return rgbe_data;
}

#ifndef STBI_NO_STDIO
float *stbi_hdr_load_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)
{
   stbi s;
   start_file(&s,f);
   return hdr_load(&s,x,y,comp,req_comp);
}

stbi_uc *stbi_hdr_load_rgbe_file(FILE *f, int *x, int *y, int *comp, int req_comp)
{
   stbi s;
   start_file(&s,f);
   return hdr_load_rgbe(&s,x,y,comp,req_comp);
}

stbi_uc *stbi_hdr_load_rgbe        (char const *filename,           int *x, int *y, int *comp, int req_comp)
{
   FILE *f = fopen(filename, "rb");
   unsigned char *result;
   if (!f) return epuc("can't fopen", "Unable to open file");
   result = stbi_hdr_load_rgbe_file(f,x,y,comp,req_comp);
   fclose(f);
   return result;
}
#endif

float *stbi_hdr_load_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
{
   stbi s;
   start_mem(&s,buffer, len);
   return hdr_load(&s,x,y,comp,req_comp);
}

stbi_uc *stbi_hdr_load_rgbe_memory(stbi_uc *buffer, int len, int *x, int *y, int *comp, int req_comp)
{
   stbi s;
   start_mem(&s,buffer, len);
   return hdr_load_rgbe(&s,x,y,comp,req_comp);
}

#endif // STBI_NO_HDR

/////////////////////// write image ///////////////////////

#ifndef STBI_NO_WRITE

static void write8(FILE *f, int x) { uint8 z = (uint8) x; fwrite(&z,1,1,f); }

static void writefv(FILE *f, char *fmt, va_list v)
{
   while (*fmt) {
      switch (*fmt++) {
         case ' ': break;
         case '1': { uint8 x = va_arg(v, int); write8(f,x); break; }
         case '2': { int16 x = va_arg(v, int); write8(f,x); write8(f,x>>8); break; }
         case '4': { int32 x = va_arg(v, int); write8(f,x); write8(f,x>>8); write8(f,x>>16); write8(f,x>>24); break; }
         default:
            assert(0);
            va_end(v);
            return;
      }
   }
}

static void writef(FILE *f, char *fmt, ...)
{
   va_list v;
   va_start(v, fmt);
   writefv(f,fmt,v);
   va_end(v);
}

static void write_pixels(FILE *f, int rgb_dir, int vdir, int x, int y, int comp, void *data, int write_alpha, int scanline_pad)
{
   uint8 bg[3] = { 255, 0, 255}, px[3];
   uint32 zero = 0;
   int i,j,k, j_end;

   if (vdir < 0)
      j_end = -1, j = y-1;
   else
      j_end =  y, j = 0;

   for (; j != j_end; j += vdir) {
      for (i=0; i < x; ++i) {
         uint8 *d = (uint8 *) data + (j*x+i)*comp;
         if (write_alpha < 0)
            fwrite(&d[comp-1], 1, 1, f);
         switch (comp) {
            case 1:
            case 2: writef(f, "111", d[0],d[0],d[0]);
                    break;
            case 4:
               if (!write_alpha) {
                  for (k=0; k < 3; ++k)
                     px[k] = bg[k] + ((d[k] - bg[k]) * d[3])/255;
                  writef(f, "111", px[1-rgb_dir],px[1],px[1+rgb_dir]);
                  break;
               }
               /* FALLTHROUGH */
            case 3:
               writef(f, "111", d[1-rgb_dir],d[1],d[1+rgb_dir]);
               break;
         }
         if (write_alpha > 0)
            fwrite(&d[comp-1], 1, 1, f);
      }
      fwrite(&zero,scanline_pad,1,f);
   }
}

static int outfile(char const *filename, int rgb_dir, int vdir, int x, int y, int comp, void *data, int alpha, int pad, char *fmt, ...)
{
   FILE *f = fopen(filename, "wb");
   if (f) {
      va_list v;
      va_start(v, fmt);
      writefv(f, fmt, v);
      va_end(v);
      write_pixels(f,rgb_dir,vdir,x,y,comp,data,alpha,pad);
      fclose(f);
   }
   return f != NULL;
}

int stbi_write_bmp(char const *filename, int x, int y, int comp, void *data)
{
   int pad = (-x*3) & 3;
   return outfile(filename,-1,-1,x,y,comp,data,0,pad,
           "11 4 22 4" "4 44 22 444444",
           'B', 'M', 14+40+(x*3+pad)*y, 0,0, 14+40,  // file header
            40, x,y, 1,24, 0,0,0,0,0,0);             // bitmap header
}

int stbi_write_tga(char const *filename, int x, int y, int comp, void *data)
{
   int has_alpha = !(comp & 1);
   return outfile(filename, -1,-1, x, y, comp, data, has_alpha, 0,
                  "111 221 2222 11", 0,0,2, 0,0,0, 0,0,x,y, 24+8*has_alpha, 8*has_alpha);
}

// any other image formats that do interleaved rgb data?
//    PNG: requires adler32,crc32 -- significant amount of code
//    PSD: no, channels output separately
//    TIFF: no, stripwise-interleaved... i think

#endif // STBI_NO_WRITE

//	add in my DDS loading support
#ifndef STBI_NO_DDS
#include "stbi_DDS_aug_c.h"
#endif

```

`sakura/libs/image/stb_image_aug.h`:

```h
/* stbi-1.16 - public domain JPEG/PNG reader - http://nothings.org/stb_image.c
                      when you control the images you're loading

   QUICK NOTES:
      Primarily of interest to game developers and other people who can
          avoid problematic images and only need the trivial interface

      JPEG baseline (no JPEG progressive, no oddball channel decimations)
      PNG non-interlaced
      BMP non-1bpp, non-RLE
      TGA (not sure what subset, if a subset)
      PSD (composited view only, no extra channels)
      HDR (radiance rgbE format)
      writes BMP,TGA (define STBI_NO_WRITE to remove code)
      decoded from memory or through stdio FILE (define STBI_NO_STDIO to remove code)
      supports installable dequantizing-IDCT, YCbCr-to-RGB conversion (define STBI_SIMD)
        
   TODO:
      stbi_info_*
  
   history:
      1.16   major bugfix - convert_format converted one too many pixels
      1.15   initialize some fields for thread safety
      1.14   fix threadsafe conversion bug; header-file-only version (#define STBI_HEADER_FILE_ONLY before including)
      1.13   threadsafe
      1.12   const qualifiers in the API
      1.11   Support installable IDCT, colorspace conversion routines
      1.10   Fixes for 64-bit (don't use "unsigned long")
             optimized upsampling by Fabian "ryg" Giesen
      1.09   Fix format-conversion for PSD code (bad global variables!)
      1.08   Thatcher Ulrich's PSD code integrated by Nicolas Schulz
      1.07   attempt to fix C++ warning/errors again
      1.06   attempt to fix C++ warning/errors again
      1.05   fix TGA loading to return correct *comp and use good luminance calc
      1.04   default float alpha is 1, not 255; use 'void *' for stbi_image_free
      1.03   bugfixes to STBI_NO_STDIO, STBI_NO_HDR
      1.02   support for (subset of) HDR files, float interface for preferred access to them
      1.01   fix bug: possible bug in handling right-side up bmps... not sure
             fix bug: the stbi_bmp_load() and stbi_tga_load() functions didn't work at all
      1.00   interface to zlib that skips zlib header
      0.99   correct handling of alpha in palette
      0.98   TGA loader by lonesock; dynamically add loaders (untested)
      0.97   jpeg errors on too large a file; also catch another malloc failure
      0.96   fix detection of invalid v value - particleman@mollyrocket forum
      0.95   during header scan, seek to markers in case of padding
      0.94   STBI_NO_STDIO to disable stdio usage; rename all #defines the same
      0.93   handle jpegtran output; verbose errors
      0.92   read 4,8,16,24,32-bit BMP files of several formats
      0.91   output 24-bit Windows 3.0 BMP files
      0.90   fix a few more warnings; bump version number to approach 1.0
      0.61   bugfixes due to Marc LeBlanc, Christopher Lloyd
      0.60   fix compiling as c++
      0.59   fix warnings: merge Dave Moore's -Wall fixes
      0.58   fix bug: zlib uncompressed mode len/nlen was wrong endian
      0.57   fix bug: jpg last huffman symbol before marker was >9 bits but less
                      than 16 available
      0.56   fix bug: zlib uncompressed mode len vs. nlen
      0.55   fix bug: restart_interval not initialized to 0
      0.54   allow NULL for 'int *comp'
      0.53   fix bug in png 3->4; speedup png decoding
      0.52   png handles req_comp=3,4 directly; minor cleanup; jpeg comments
      0.51   obey req_comp requests, 1-component jpegs return as 1-component,
             on 'test' only check type, not whether we support this variant
*/

#ifndef HEADER_STB_IMAGE_AUGMENTED
#define HEADER_STB_IMAGE_AUGMENTED

////   begin header file  ////////////////////////////////////////////////////
//
// Limitations:
//    - no progressive/interlaced support (jpeg, png)
//    - 8-bit samples only (jpeg, png)
//    - not threadsafe
//    - channel subsampling of at most 2 in each dimension (jpeg)
//    - no delayed line count (jpeg) -- IJG doesn't support either
//
// Basic usage (see HDR discussion below):
//    int x,y,n;
//    unsigned char *data = stbi_load(filename, &x, &y, &n, 0);
//    // ... process data if not NULL ... 
//    // ... x = width, y = height, n = # 8-bit components per pixel ...
//    // ... replace '0' with '1'..'4' to force that many components per pixel
//    stbi_image_free(data)
//
// Standard parameters:
//    int *x       -- outputs image width in pixels
//    int *y       -- outputs image height in pixels
//    int *comp    -- outputs # of image components in image file
//    int req_comp -- if non-zero, # of image components requested in result
//
// The return value from an image loader is an 'unsigned char *' which points
// to the pixel data. The pixel data consists of *y scanlines of *x pixels,
// with each pixel consisting of N interleaved 8-bit components; the first
// pixel pointed to is top-left-most in the image. There is no padding between
// image scanlines or between pixels, regardless of format. The number of
// components N is 'req_comp' if req_comp is non-zero, or *comp otherwise.
// If req_comp is non-zero, *comp has the number of components that _would_
// have been output otherwise. E.g. if you set req_comp to 4, you will always
// get RGBA output, but you can check *comp to easily see if it's opaque.
//
// An output image with N components has the following components interleaved
// in this order in each pixel:
//
//     N=#comp     components
//       1           grey
//       2           grey, alpha
//       3           red, green, blue
//       4           red, green, blue, alpha
//
// If image loading fails for any reason, the return value will be NULL,
// and *x, *y, *comp will be unchanged. The function stbi_failure_reason()
// can be queried for an extremely brief, end-user unfriendly explanation
// of why the load failed. Define STBI_NO_FAILURE_STRINGS to avoid
// compiling these strings at all, and STBI_FAILURE_USERMSG to get slightly
// more user-friendly ones.
//
// Paletted PNG and BMP images are automatically depalettized.
//
//
// ===========================================================================
//
// HDR image support   (disable by defining STBI_NO_HDR)
//
// stb_image now supports loading HDR images in general, and currently
// the Radiance .HDR file format, although the support is provided
// generically. You can still load any file through the existing interface;
// if you attempt to load an HDR file, it will be automatically remapped to
// LDR, assuming gamma 2.2 and an arbitrary scale factor defaulting to 1;
// both of these constants can be reconfigured through this interface:
//
//     stbi_hdr_to_ldr_gamma(2.2f);
//     stbi_hdr_to_ldr_scale(1.0f);
//
// (note, do not use _inverse_ constants; stbi_image will invert them
// appropriately).
//
// Additionally, there is a new, parallel interface for loading files as
// (linear) floats to preserve the full dynamic range:
//
//    float *data = stbi_loadf(filename, &x, &y, &n, 0);
// 
// If you load LDR images through this interface, those images will
// be promoted to floating point values, run through the inverse of
// constants corresponding to the above:
//
//     stbi_ldr_to_hdr_scale(1.0f);
//     stbi_ldr_to_hdr_gamma(2.2f);
//
// Finally, given a filename (or an open file or memory block--see header
// file for details) containing image data, you can query for the "most
// appropriate" interface to use (that is, whether the image is HDR or
// not), using:
//
//     stbi_is_hdr(char *filename);

#ifndef STBI_NO_STDIO
#include <stdio.h>
#endif

#define STBI_VERSION 1

enum
{
   STBI_default = 0, // only used for req_comp

   STBI_grey       = 1,
   STBI_grey_alpha = 2,
   STBI_rgb        = 3,
   STBI_rgb_alpha  = 4,
};

typedef unsigned char stbi_uc;

#ifdef __cplusplus
extern "C" {
#endif

// WRITING API

#if !defined(STBI_NO_WRITE) && !defined(STBI_NO_STDIO)
// write a BMP/TGA file given tightly packed 'comp' channels (no padding, nor bmp-stride-padding)
// (you must include the appropriate extension in the filename).
// returns TRUE on success, FALSE if couldn't open file, error writing file
extern int      stbi_write_bmp       (char const *filename,     int x, int y, int comp, void *data);
extern int      stbi_write_tga       (char const *filename,     int x, int y, int comp, void *data);
#endif

// PRIMARY API - works on images of any type

// load image by filename, open file, or memory buffer
#ifndef STBI_NO_STDIO
extern stbi_uc *stbi_load            (char const *filename,     int *x, int *y, int *comp, int req_comp);
extern stbi_uc *stbi_load_from_file  (FILE *f,                  int *x, int *y, int *comp, int req_comp);
extern int      stbi_info_from_file  (FILE *f,                  int *x, int *y, int *comp);
#endif
extern stbi_uc *stbi_load_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp);
// for stbi_load_from_file, file pointer is left pointing immediately after image

#ifndef STBI_NO_HDR
#ifndef STBI_NO_STDIO
extern float *stbi_loadf            (char const *filename,     int *x, int *y, int *comp, int req_comp);
extern float *stbi_loadf_from_file  (FILE *f,                  int *x, int *y, int *comp, int req_comp);
#endif
extern float *stbi_loadf_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp);

extern void   stbi_hdr_to_ldr_gamma(float gamma);
extern void   stbi_hdr_to_ldr_scale(float scale);

extern void   stbi_ldr_to_hdr_gamma(float gamma);
extern void   stbi_ldr_to_hdr_scale(float scale);

#endif // STBI_NO_HDR

// get a VERY brief reason for failure
// NOT THREADSAFE
extern char    *stbi_failure_reason  (void); 

// free the loaded image -- this is just free()
extern void     stbi_image_free      (void *retval_from_stbi_load);

// get image dimensions & components without fully decoding
extern int      stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp);
extern int      stbi_is_hdr_from_memory(stbi_uc const *buffer, int len);
#ifndef STBI_NO_STDIO
extern int      stbi_info            (char const *filename,     int *x, int *y, int *comp);
extern int      stbi_is_hdr          (char const *filename);
extern int      stbi_is_hdr_from_file(FILE *f);
#endif

// ZLIB client - used by PNG, available for other purposes

extern char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen);
extern char *stbi_zlib_decode_malloc(const char *buffer, int len, int *outlen);
extern int   stbi_zlib_decode_buffer(char *obuffer, int olen, const char *ibuffer, int ilen);

extern char *stbi_zlib_decode_noheader_malloc(const char *buffer, int len, int *outlen);
extern int   stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen);

// TYPE-SPECIFIC ACCESS

// is it a jpeg?
extern int      stbi_jpeg_test_memory     (stbi_uc const *buffer, int len);
extern stbi_uc *stbi_jpeg_load_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp);
extern int      stbi_jpeg_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp);

#ifndef STBI_NO_STDIO
extern stbi_uc *stbi_jpeg_load            (char const *filename,     int *x, int *y, int *comp, int req_comp);
extern int      stbi_jpeg_test_file       (FILE *f);
extern stbi_uc *stbi_jpeg_load_from_file  (FILE *f,                  int *x, int *y, int *comp, int req_comp);

extern int      stbi_jpeg_info            (char const *filename,     int *x, int *y, int *comp);
extern int      stbi_jpeg_info_from_file  (FILE *f,                  int *x, int *y, int *comp);
#endif

// is it a png?
extern int      stbi_png_test_memory      (stbi_uc const *buffer, int len);
extern stbi_uc *stbi_png_load_from_memory (stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp);
extern int      stbi_png_info_from_memory (stbi_uc const *buffer, int len, int *x, int *y, int *comp);

#ifndef STBI_NO_STDIO
extern stbi_uc *stbi_png_load             (char const *filename,     int *x, int *y, int *comp, int req_comp);
extern int      stbi_png_info             (char const *filename,     int *x, int *y, int *comp);
extern int      stbi_png_test_file        (FILE *f);
extern stbi_uc *stbi_png_load_from_file   (FILE *f,                  int *x, int *y, int *comp, int req_comp);
extern int      stbi_png_info_from_file   (FILE *f,                  int *x, int *y, int *comp);
#endif

// is it a bmp?
extern int      stbi_bmp_test_memory      (stbi_uc const *buffer, int len);

extern stbi_uc *stbi_bmp_load             (char const *filename,     int *x, int *y, int *comp, int req_comp);
extern stbi_uc *stbi_bmp_load_from_memory (stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp);
#ifndef STBI_NO_STDIO
extern int      stbi_bmp_test_file        (FILE *f);
extern stbi_uc *stbi_bmp_load_from_file   (FILE *f,                  int *x, int *y, int *comp, int req_comp);
#endif

// is it a tga?
extern int      stbi_tga_test_memory      (stbi_uc const *buffer, int len);

extern stbi_uc *stbi_tga_load             (char const *filename,     int *x, int *y, int *comp, int req_comp);
extern stbi_uc *stbi_tga_load_from_memory (stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp);
#ifndef STBI_NO_STDIO
extern int      stbi_tga_test_file        (FILE *f);
extern stbi_uc *stbi_tga_load_from_file   (FILE *f,                  int *x, int *y, int *comp, int req_comp);
#endif

// is it a psd?
extern int      stbi_psd_test_memory      (stbi_uc const *buffer, int len);

extern stbi_uc *stbi_psd_load             (char const *filename,     int *x, int *y, int *comp, int req_comp);
extern stbi_uc *stbi_psd_load_from_memory (stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp);
#ifndef STBI_NO_STDIO
extern int      stbi_psd_test_file        (FILE *f);
extern stbi_uc *stbi_psd_load_from_file   (FILE *f,                  int *x, int *y, int *comp, int req_comp);
#endif

// is it an hdr?
extern int      stbi_hdr_test_memory      (stbi_uc const *buffer, int len);

extern float *  stbi_hdr_load             (char const *filename,     int *x, int *y, int *comp, int req_comp);
extern float *  stbi_hdr_load_from_memory (stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp);
extern stbi_uc *stbi_hdr_load_rgbe        (char const *filename,           int *x, int *y, int *comp, int req_comp);
extern float *  stbi_hdr_load_from_memory (stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp);
#ifndef STBI_NO_STDIO
extern int      stbi_hdr_test_file        (FILE *f);
extern float *  stbi_hdr_load_from_file   (FILE *f,                  int *x, int *y, int *comp, int req_comp);
extern stbi_uc *stbi_hdr_load_rgbe_file   (FILE *f,                  int *x, int *y, int *comp, int req_comp);
#endif

// define new loaders
typedef struct
{
   int       (*test_memory)(stbi_uc const *buffer, int len);
   stbi_uc * (*load_from_memory)(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp);
   #ifndef STBI_NO_STDIO
   int       (*test_file)(FILE *f);
   stbi_uc * (*load_from_file)(FILE *f, int *x, int *y, int *comp, int req_comp);
   #endif
} stbi_loader;

// register a loader by filling out the above structure (you must defined ALL functions)
// returns 1 if added or already added, 0 if not added (too many loaders)
// NOT THREADSAFE
extern int stbi_register_loader(stbi_loader *loader);

// define faster low-level operations (typically SIMD support)
#if STBI_SIMD
typedef void (*stbi_idct_8x8)(uint8 *out, int out_stride, short data[64], unsigned short *dequantize);
// compute an integer IDCT on "input"
//     input[x] = data[x] * dequantize[x]
//     write results to 'out': 64 samples, each run of 8 spaced by 'out_stride'
//                             CLAMP results to 0..255
typedef void (*stbi_YCbCr_to_RGB_run)(uint8 *output, uint8 const *y, uint8 const *cb, uint8 const *cr, int count, int step);
// compute a conversion from YCbCr to RGB
//     'count' pixels
//     write pixels to 'output'; each pixel is 'step' bytes (either 3 or 4; if 4, write '255' as 4th), order R,G,B
//     y: Y input channel
//     cb: Cb input channel; scale/biased to be 0..255
//     cr: Cr input channel; scale/biased to be 0..255

extern void stbi_install_idct(stbi_idct_8x8 func);
extern void stbi_install_YCbCr_to_RGB(stbi_YCbCr_to_RGB_run func);
#endif // STBI_SIMD

#ifdef __cplusplus
}
#endif

//
//
////   end header file   /////////////////////////////////////////////////////
#endif // STBI_INCLUDE_STB_IMAGE_H

```

`sakura/libs/image/stbi_DDS_aug.h`:

```h
/*
	adding DDS loading support to stbi
*/

#ifndef HEADER_STB_IMAGE_DDS_AUGMENTATION
#define HEADER_STB_IMAGE_DDS_AUGMENTATION

//	is it a DDS file?
extern int      stbi_dds_test_memory      (stbi_uc const *buffer, int len);

extern stbi_uc *stbi_dds_load             (char *filename,           int *x, int *y, int *comp, int req_comp);
extern stbi_uc *stbi_dds_load_from_memory (stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp);
#ifndef STBI_NO_STDIO
extern int      stbi_dds_test_file        (FILE *f);
extern stbi_uc *stbi_dds_load_from_file   (FILE *f,                  int *x, int *y, int *comp, int req_comp);
#endif

//
//
////   end header file   /////////////////////////////////////////////////////
#endif // HEADER_STB_IMAGE_DDS_AUGMENTATION

```

`sakura/libs/image/stbi_DDS_aug_c.h`:

```h

///	DDS file support, does decoding, _not_ direct uploading
///	(use SOIL for that ;-)

#pragma warning(disable:4018)
#pragma warning(disable:4996)
///	A bunch of DirectDraw Surface structures and flags
typedef struct {
    unsigned int    dwMagic;
    unsigned int    dwSize;
    unsigned int    dwFlags;
    unsigned int    dwHeight;
    unsigned int    dwWidth;
    unsigned int    dwPitchOrLinearSize;
    unsigned int    dwDepth;
    unsigned int    dwMipMapCount;
    unsigned int    dwReserved1[ 11 ];

    //  DDPIXELFORMAT
    struct {
      unsigned int    dwSize;
      unsigned int    dwFlags;
      unsigned int    dwFourCC;
      unsigned int    dwRGBBitCount;
      unsigned int    dwRBitMask;
      unsigned int    dwGBitMask;
      unsigned int    dwBBitMask;
      unsigned int    dwAlphaBitMask;
    }               sPixelFormat;

    //  DDCAPS2
    struct {
      unsigned int    dwCaps1;
      unsigned int    dwCaps2;
      unsigned int    dwDDSX;
      unsigned int    dwReserved;
    }               sCaps;
    unsigned int    dwReserved2;
} DDS_header ;

//	the following constants were copied directly off the MSDN website

//	The dwFlags member of the original DDSURFACEDESC2 structure
//	can be set to one or more of the following values.
#define DDSD_CAPS	0x00000001
#define DDSD_HEIGHT	0x00000002
#define DDSD_WIDTH	0x00000004
#define DDSD_PITCH	0x00000008
#define DDSD_PIXELFORMAT	0x00001000
#define DDSD_MIPMAPCOUNT	0x00020000
#define DDSD_LINEARSIZE	0x00080000
#define DDSD_DEPTH	0x00800000

//	DirectDraw Pixel Format
#define DDPF_ALPHAPIXELS	0x00000001
#define DDPF_FOURCC	0x00000004
#define DDPF_RGB	0x00000040

//	The dwCaps1 member of the DDSCAPS2 structure can be
//	set to one or more of the following values.
#define DDSCAPS_COMPLEX	0x00000008
#define DDSCAPS_TEXTURE	0x00001000
#define DDSCAPS_MIPMAP	0x00400000

//	The dwCaps2 member of the DDSCAPS2 structure can be
//	set to one or more of the following values.
#define DDSCAPS2_CUBEMAP	0x00000200
#define DDSCAPS2_CUBEMAP_POSITIVEX	0x00000400
#define DDSCAPS2_CUBEMAP_NEGATIVEX	0x00000800
#define DDSCAPS2_CUBEMAP_POSITIVEY	0x00001000
#define DDSCAPS2_CUBEMAP_NEGATIVEY	0x00002000
#define DDSCAPS2_CUBEMAP_POSITIVEZ	0x00004000
#define DDSCAPS2_CUBEMAP_NEGATIVEZ	0x00008000
#define DDSCAPS2_VOLUME	0x00200000

static int dds_test(stbi *s)
{
	//	check the magic number
	if (get8(s) != 'D') return 0;
	if (get8(s) != 'D') return 0;
	if (get8(s) != 'S') return 0;
	if (get8(s) != ' ') return 0;
	//	check header size
	if (get32le(s) != 124) return 0;
	return 1;
}
#ifndef STBI_NO_STDIO
int      stbi_dds_test_file        (FILE *f)
{
   stbi s;
   int r,n = ftell(f);
   start_file(&s,f);
   r = dds_test(&s);
   fseek(f,n,SEEK_SET);
   return r;
}
#endif

int      stbi_dds_test_memory      (stbi_uc const *buffer, int len)
{
   stbi s;
   start_mem(&s,buffer, len);
   return dds_test(&s);
}

//	helper functions
int stbi_convert_bit_range( int c, int from_bits, int to_bits )
{
	int b = (1 << (from_bits - 1)) + c * ((1 << to_bits) - 1);
	return (b + (b >> from_bits)) >> from_bits;
}
void stbi_rgb_888_from_565( unsigned int c, int *r, int *g, int *b )
{
	*r = stbi_convert_bit_range( (c >> 11) & 31, 5, 8 );
	*g = stbi_convert_bit_range( (c >> 05) & 63, 6, 8 );
	*b = stbi_convert_bit_range( (c >> 00) & 31, 5, 8 );
}
void stbi_decode_DXT1_block(
			unsigned char uncompressed[16*4],
			unsigned char compressed[8] )
{
	int next_bit = 4*8;
	int i, r, g, b;
	int c0, c1;
	unsigned char decode_colors[4*4];
	//	find the 2 primary colors
	c0 = compressed[0] + (compressed[1] << 8);
	c1 = compressed[2] + (compressed[3] << 8);
	stbi_rgb_888_from_565( c0, &r, &g, &b );
	decode_colors[0] = r;
	decode_colors[1] = g;
	decode_colors[2] = b;
	decode_colors[3] = 255;
	stbi_rgb_888_from_565( c1, &r, &g, &b );
	decode_colors[4] = r;
	decode_colors[5] = g;
	decode_colors[6] = b;
	decode_colors[7] = 255;
	if( c0 > c1 )
	{
		//	no alpha, 2 interpolated colors
		decode_colors[8] = (2*decode_colors[0] + decode_colors[4]) / 3;
		decode_colors[9] = (2*decode_colors[1] + decode_colors[5]) / 3;
		decode_colors[10] = (2*decode_colors[2] + decode_colors[6]) / 3;
		decode_colors[11] = 255;
		decode_colors[12] = (decode_colors[0] + 2*decode_colors[4]) / 3;
		decode_colors[13] = (decode_colors[1] + 2*decode_colors[5]) / 3;
		decode_colors[14] = (decode_colors[2] + 2*decode_colors[6]) / 3;
		decode_colors[15] = 255;
	} else
	{
		//	1 interpolated color, alpha
		decode_colors[8] = (decode_colors[0] + decode_colors[4]) / 2;
		decode_colors[9] = (decode_colors[1] + decode_colors[5]) / 2;
		decode_colors[10] = (decode_colors[2] + decode_colors[6]) / 2;
		decode_colors[11] = 255;
		decode_colors[12] = 0;
		decode_colors[13] = 0;
		decode_colors[14] = 0;
		decode_colors[15] = 0;
	}
	//	decode the block
	for( i = 0; i < 16*4; i += 4 )
	{
		int idx = ((compressed[next_bit>>3] >> (next_bit & 7)) & 3) * 4;
		next_bit += 2;
		uncompressed[i+0] = decode_colors[idx+0];
		uncompressed[i+1] = decode_colors[idx+1];
		uncompressed[i+2] = decode_colors[idx+2];
		uncompressed[i+3] = decode_colors[idx+3];
	}
	//	done
}
void stbi_decode_DXT23_alpha_block(
			unsigned char uncompressed[16*4],
			unsigned char compressed[8] )
{
	int i, next_bit = 0;
	//	each alpha value gets 4 bits
	for( i = 3; i < 16*4; i += 4 )
	{
		uncompressed[i] = stbi_convert_bit_range(
				(compressed[next_bit>>3] >> (next_bit&7)) & 15,
				4, 8 );
		next_bit += 4;
	}
}
void stbi_decode_DXT45_alpha_block(
			unsigned char uncompressed[16*4],
			unsigned char compressed[8] )
{
	int i, next_bit = 8*2;
	unsigned char decode_alpha[8];
	//	each alpha value gets 3 bits, and the 1st 2 bytes are the range
	decode_alpha[0] = compressed[0];
	decode_alpha[1] = compressed[1];
	if( decode_alpha[0] > decode_alpha[1] )
	{
		//	6 step intermediate
		decode_alpha[2] = (6*decode_alpha[0] + 1*decode_alpha[1]) / 7;
		decode_alpha[3] = (5*decode_alpha[0] + 2*decode_alpha[1]) / 7;
		decode_alpha[4] = (4*decode_alpha[0] + 3*decode_alpha[1]) / 7;
		decode_alpha[5] = (3*decode_alpha[0] + 4*decode_alpha[1]) / 7;
		decode_alpha[6] = (2*decode_alpha[0] + 5*decode_alpha[1]) / 7;
		decode_alpha[7] = (1*decode_alpha[0] + 6*decode_alpha[1]) / 7;
	} else
	{
		//	4 step intermediate, pluss full and none
		decode_alpha[2] = (4*decode_alpha[0] + 1*decode_alpha[1]) / 5;
		decode_alpha[3] = (3*decode_alpha[0] + 2*decode_alpha[1]) / 5;
		decode_alpha[4] = (2*decode_alpha[0] + 3*decode_alpha[1]) / 5;
		decode_alpha[5] = (1*decode_alpha[0] + 4*decode_alpha[1]) / 5;
		decode_alpha[6] = 0;
		decode_alpha[7] = 255;
	}
	for( i = 3; i < 16*4; i += 4 )
	{
		int idx = 0, bit;
		bit = (compressed[next_bit>>3] >> (next_bit&7)) & 1;
		idx += bit << 0;
		++next_bit;
		bit = (compressed[next_bit>>3] >> (next_bit&7)) & 1;
		idx += bit << 1;
		++next_bit;
		bit = (compressed[next_bit>>3] >> (next_bit&7)) & 1;
		idx += bit << 2;
		++next_bit;
		uncompressed[i] = decode_alpha[idx & 7];
	}
	//	done
}
void stbi_decode_DXT_color_block(
			unsigned char uncompressed[16*4],
			unsigned char compressed[8] )
{
	int next_bit = 4*8;
	int i, r, g, b;
	int c0, c1;
	unsigned char decode_colors[4*3];
	//	find the 2 primary colors
	c0 = compressed[0] + (compressed[1] << 8);
	c1 = compressed[2] + (compressed[3] << 8);
	stbi_rgb_888_from_565( c0, &r, &g, &b );
	decode_colors[0] = r;
	decode_colors[1] = g;
	decode_colors[2] = b;
	stbi_rgb_888_from_565( c1, &r, &g, &b );
	decode_colors[3] = r;
	decode_colors[4] = g;
	decode_colors[5] = b;
	//	Like DXT1, but no choicees:
	//	no alpha, 2 interpolated colors
	decode_colors[6] = (2*decode_colors[0] + decode_colors[3]) / 3;
	decode_colors[7] = (2*decode_colors[1] + decode_colors[4]) / 3;
	decode_colors[8] = (2*decode_colors[2] + decode_colors[5]) / 3;
	decode_colors[9] = (decode_colors[0] + 2*decode_colors[3]) / 3;
	decode_colors[10] = (decode_colors[1] + 2*decode_colors[4]) / 3;
	decode_colors[11] = (decode_colors[2] + 2*decode_colors[5]) / 3;
	//	decode the block
	for( i = 0; i < 16*4; i += 4 )
	{
		int idx = ((compressed[next_bit>>3] >> (next_bit & 7)) & 3) * 3;
		next_bit += 2;
		uncompressed[i+0] = decode_colors[idx+0];
		uncompressed[i+1] = decode_colors[idx+1];
		uncompressed[i+2] = decode_colors[idx+2];
	}
	//	done
}
static stbi_uc *dds_load(stbi *s, int *x, int *y, int *comp, int req_comp)
{
	//	all variables go up front
	stbi_uc *dds_data = NULL;
	stbi_uc block[16*4];
	stbi_uc compressed[8];
	int flags, DXT_family;
	int has_alpha, has_mipmap;
	int is_compressed, cubemap_faces;
	int block_pitch, num_blocks;
	DDS_header header;
	int i, sz, cf;
	//	load the header
	if( sizeof( DDS_header ) != 128 )
	{
		return NULL;
	}
	getn( s, (stbi_uc*)(&header), 128 );
	//	and do some checking
	if( header.dwMagic != (('D' << 0) | ('D' << 8) | ('S' << 16) | (' ' << 24)) ) return NULL;
	if( header.dwSize != 124 ) return NULL;
	flags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT;
	if( (header.dwFlags & flags) != flags ) return NULL;
	/*	According to the MSDN spec, the dwFlags should contain
		DDSD_LINEARSIZE if it's compressed, or DDSD_PITCH if
		uncompressed.  Some DDS writers do not conform to the
		spec, so I need to make my reader more tolerant	*/
	if( header.sPixelFormat.dwSize != 32 ) return NULL;
	flags = DDPF_FOURCC | DDPF_RGB;
	if( (header.sPixelFormat.dwFlags & flags) == 0 ) return NULL;
	if( (header.sCaps.dwCaps1 & DDSCAPS_TEXTURE) == 0 ) return NULL;
	//	get the image data
	s->img_x = header.dwWidth;
	s->img_y = header.dwHeight;
	s->img_n = 4;
	is_compressed = (header.sPixelFormat.dwFlags & DDPF_FOURCC) / DDPF_FOURCC;
	has_alpha = (header.sPixelFormat.dwFlags & DDPF_ALPHAPIXELS) / DDPF_ALPHAPIXELS;
	has_mipmap = (header.sCaps.dwCaps1 & DDSCAPS_MIPMAP) && (header.dwMipMapCount > 1);
	cubemap_faces = (header.sCaps.dwCaps2 & DDSCAPS2_CUBEMAP) / DDSCAPS2_CUBEMAP;
	/*	I need cubemaps to have square faces	*/
	cubemap_faces &= (s->img_x == s->img_y);
	cubemap_faces *= 5;
	cubemap_faces += 1;
	block_pitch = (s->img_x+3) >> 2;
	num_blocks = block_pitch * ((s->img_y+3) >> 2);
	/*	let the user know what's going on	*/
	*x = s->img_x;
	*y = s->img_y;
	*comp = s->img_n;
	/*	is this uncompressed?	*/
	if( is_compressed )
	{
		/*	compressed	*/
		//	note: header.sPixelFormat.dwFourCC is something like (('D'<<0)|('X'<<8)|('T'<<16)|('1'<<24))
		DXT_family = 1 + (header.sPixelFormat.dwFourCC >> 24) - '1';
		if( (DXT_family < 1) || (DXT_family > 5) ) return NULL;
		/*	check the expected size...oops, nevermind...
			those non-compliant writers leave
			dwPitchOrLinearSize == 0	*/
		//	passed all the tests, get the RAM for decoding
		sz = (s->img_x)*(s->img_y)*4*cubemap_faces;
		dds_data = (unsigned char*)malloc( sz );
		/*	do this once for each face	*/
		for( cf = 0; cf < cubemap_faces; ++ cf )
		{
			//	now read and decode all the blocks
			for( i = 0; i < num_blocks; ++i )
			{
				//	where are we?
				int bx, by, bw=4, bh=4;
				int ref_x = 4 * (i % block_pitch);
				int ref_y = 4 * (i / block_pitch);
				//	get the next block's worth of compressed data, and decompress it
				if( DXT_family == 1 )
				{
					//	DXT1
					getn( s, compressed, 8 );
					stbi_decode_DXT1_block( block, compressed );
				} else if( DXT_family < 4 )
				{
					//	DXT2/3
					getn( s, compressed, 8 );
					stbi_decode_DXT23_alpha_block ( block, compressed );
					getn( s, compressed, 8 );
					stbi_decode_DXT_color_block ( block, compressed );
				} else
				{
					//	DXT4/5
					getn( s, compressed, 8 );
					stbi_decode_DXT45_alpha_block ( block, compressed );
					getn( s, compressed, 8 );
					stbi_decode_DXT_color_block ( block, compressed );
				}
				//	is this a partial block?
				if( ref_x + 4 > s->img_x )
				{
					bw = s->img_x - ref_x;
				}
				if( ref_y + 4 > s->img_y )
				{
					bh = s->img_y - ref_y;
				}
				//	now drop our decompressed data into the buffer
				for( by = 0; by < bh; ++by )
				{
					int idx = 4*((ref_y+by+cf*s->img_x)*s->img_x + ref_x);
					for( bx = 0; bx < bw*4; ++bx )
					{

						dds_data[idx+bx] = block[by*16+bx];
					}
				}
			}
			/*	done reading and decoding the main image...
				skip MIPmaps if present	*/
			if( has_mipmap )
			{
				int block_size = 16;
				if( DXT_family == 1 )
				{
					block_size = 8;
				}
				for( i = 1; i < header.dwMipMapCount; ++i )
				{
					int mx = s->img_x >> (i + 2);
					int my = s->img_y >> (i + 2);
					if( mx < 1 )
					{
						mx = 1;
					}
					if( my < 1 )
					{
						my = 1;
					}
					skip( s, mx*my*block_size );
				}
			}
		}/* per cubemap face */
	} else
	{
		/*	uncompressed	*/
		DXT_family = 0;
		s->img_n = 3;
		if( has_alpha )
		{
			s->img_n = 4;
		}
		*comp = s->img_n;
		sz = s->img_x*s->img_y*s->img_n*cubemap_faces;
		dds_data = (unsigned char*)malloc( sz );
		/*	do this once for each face	*/
		for( cf = 0; cf < cubemap_faces; ++ cf )
		{
			/*	read the main image for this face	*/
			getn( s, &dds_data[cf*s->img_x*s->img_y*s->img_n], s->img_x*s->img_y*s->img_n );
			/*	done reading and decoding the main image...
				skip MIPmaps if present	*/
			if( has_mipmap )
			{
				for( i = 1; i < header.dwMipMapCount; ++i )
				{
					int mx = s->img_x >> i;
					int my = s->img_y >> i;
					if( mx < 1 )
					{
						mx = 1;
					}
					if( my < 1 )
					{
						my = 1;
					}
					skip( s, mx*my*s->img_n );
				}
			}
		}
		/*	data was BGR, I need it RGB	*/
		for( i = 0; i < sz; i += s->img_n )
		{
			unsigned char temp = dds_data[i];
			dds_data[i] = dds_data[i+2];
			dds_data[i+2] = temp;
		}
	}
	/*	finished decompressing into RGBA,
		adjust the y size if we have a cubemap
		note: sz is already up to date	*/
	s->img_y *= cubemap_faces;
	*y = s->img_y;
	//	did the user want something else, or
	//	see if all the alpha values are 255 (i.e. no transparency)
	has_alpha = 0;
	if( s->img_n == 4)
	{
		for( i = 3; (i < sz) && (has_alpha == 0); i += 4 )
		{
			has_alpha |= (dds_data[i] < 255);
		}
	}
	if( (req_comp <= 4) && (req_comp >= 1) )
	{
		//	user has some requirements, meet them
		if( req_comp != s->img_n )
		{
			dds_data = convert_format( dds_data, s->img_n, req_comp, s->img_x, s->img_y );
			*comp = s->img_n;
		}
	} else
	{
		//	user had no requirements, only drop to RGB is no alpha
		if( (has_alpha == 0) && (s->img_n == 4) )
		{
			dds_data = convert_format( dds_data, 4, 3, s->img_x, s->img_y );
			*comp = 3;
		}
	}
	//	OK, done
	return dds_data;
}

#ifndef STBI_NO_STDIO
stbi_uc *stbi_dds_load_from_file   (FILE *f,                  int *x, int *y, int *comp, int req_comp)
{
	stbi s;
   start_file(&s,f);
   return dds_load(&s,x,y,comp,req_comp);
}

stbi_uc *stbi_dds_load             (char *filename,           int *x, int *y, int *comp, int req_comp)
{
   stbi_uc *data;
   FILE *f = fopen(filename, "rb");
   if (!f) return NULL;
   data = stbi_dds_load_from_file(f,x,y,comp,req_comp);
   fclose(f);
   return data;
}
#endif

stbi_uc *stbi_dds_load_from_memory (stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
{
	stbi s;
   start_mem(&s,buffer, len);
   return dds_load(&s,x,y,comp,req_comp);
}

```

`sakura/libs/opengl/gl.h`:

```h
/*++ BUILD Version: 0004    // Increment this if a change has global effects

Copyright (c) 1985-96, Microsoft Corporation

Module Name:

    gl.h

Abstract:

    Procedure declarations, constant definitions and macros for the OpenGL
    component.

--*/

#ifndef __gl_h_
#ifndef __GL_H__

#define __gl_h_
#define __GL_H__

#include <winapifamily.h>

#ifdef __cplusplus
extern "C" {
#endif

/*
** Copyright 1996 Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#pragma region Desktop Family
#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

typedef unsigned int GLenum;
typedef unsigned char GLboolean;
typedef unsigned int GLbitfield;
typedef signed char GLbyte;
typedef short GLshort;
typedef int GLint;
typedef int GLsizei;
typedef unsigned char GLubyte;
typedef unsigned short GLushort;
typedef unsigned int GLuint;
typedef float GLfloat;
typedef float GLclampf;
typedef double GLdouble;
typedef double GLclampd;
typedef void GLvoid;

/*************************************************************/

/* Version */
#define GL_VERSION_1_1                    1

/* AccumOp */
#define GL_ACCUM                          0x0100
#define GL_LOAD                           0x0101
#define GL_RETURN                         0x0102
#define GL_MULT                           0x0103
#define GL_ADD                            0x0104

/* AlphaFunction */
#define GL_NEVER                          0x0200
#define GL_LESS                           0x0201
#define GL_EQUAL                          0x0202
#define GL_LEQUAL                         0x0203
#define GL_GREATER                        0x0204
#define GL_NOTEQUAL                       0x0205
#define GL_GEQUAL                         0x0206
#define GL_ALWAYS                         0x0207

/* AttribMask */
#define GL_CURRENT_BIT                    0x00000001
#define GL_POINT_BIT                      0x00000002
#define GL_LINE_BIT                       0x00000004
#define GL_POLYGON_BIT                    0x00000008
#define GL_POLYGON_STIPPLE_BIT            0x00000010
#define GL_PIXEL_MODE_BIT                 0x00000020
#define GL_LIGHTING_BIT                   0x00000040
#define GL_FOG_BIT                        0x00000080
#define GL_DEPTH_BUFFER_BIT               0x00000100
#define GL_ACCUM_BUFFER_BIT               0x00000200
#define GL_STENCIL_BUFFER_BIT             0x00000400
#define GL_VIEWPORT_BIT                   0x00000800
#define GL_TRANSFORM_BIT                  0x00001000
#define GL_ENABLE_BIT                     0x00002000
#define GL_COLOR_BUFFER_BIT               0x00004000
#define GL_HINT_BIT                       0x00008000
#define GL_EVAL_BIT                       0x00010000
#define GL_LIST_BIT                       0x00020000
#define GL_TEXTURE_BIT                    0x00040000
#define GL_SCISSOR_BIT                    0x00080000
#define GL_ALL_ATTRIB_BITS                0x000fffff

/* BeginMode */
#define GL_POINTS                         0x0000
#define GL_LINES                          0x0001
#define GL_LINE_LOOP                      0x0002
#define GL_LINE_STRIP                     0x0003
#define GL_TRIANGLES                      0x0004
#define GL_TRIANGLE_STRIP                 0x0005
#define GL_TRIANGLE_FAN                   0x0006
#define GL_QUADS                          0x0007
#define GL_QUAD_STRIP                     0x0008
#define GL_POLYGON                        0x0009

/* BlendingFactorDest */
#define GL_ZERO                           0
#define GL_ONE                            1
#define GL_SRC_COLOR                      0x0300
#define GL_ONE_MINUS_SRC_COLOR            0x0301
#define GL_SRC_ALPHA                      0x0302
#define GL_ONE_MINUS_SRC_ALPHA            0x0303
#define GL_DST_ALPHA                      0x0304
#define GL_ONE_MINUS_DST_ALPHA            0x0305

/* BlendingFactorSrc */
/*      GL_ZERO */
/*      GL_ONE */
#define GL_DST_COLOR                      0x0306
#define GL_ONE_MINUS_DST_COLOR            0x0307
#define GL_SRC_ALPHA_SATURATE             0x0308
/*      GL_SRC_ALPHA */
/*      GL_ONE_MINUS_SRC_ALPHA */
/*      GL_DST_ALPHA */
/*      GL_ONE_MINUS_DST_ALPHA */

/* Boolean */
#define GL_TRUE                           1
#define GL_FALSE                          0

/* ClearBufferMask */
/*      GL_COLOR_BUFFER_BIT */
/*      GL_ACCUM_BUFFER_BIT */
/*      GL_STENCIL_BUFFER_BIT */
/*      GL_DEPTH_BUFFER_BIT */

/* ClientArrayType */
/*      GL_VERTEX_ARRAY */
/*      GL_NORMAL_ARRAY */
/*      GL_COLOR_ARRAY */
/*      GL_INDEX_ARRAY */
/*      GL_TEXTURE_COORD_ARRAY */
/*      GL_EDGE_FLAG_ARRAY */

/* ClipPlaneName */
#define GL_CLIP_PLANE0                    0x3000
#define GL_CLIP_PLANE1                    0x3001
#define GL_CLIP_PLANE2                    0x3002
#define GL_CLIP_PLANE3                    0x3003
#define GL_CLIP_PLANE4                    0x3004
#define GL_CLIP_PLANE5                    0x3005

/* ColorMaterialFace */
/*      GL_FRONT */
/*      GL_BACK */
/*      GL_FRONT_AND_BACK */

/* ColorMaterialParameter */
/*      GL_AMBIENT */
/*      GL_DIFFUSE */
/*      GL_SPECULAR */
/*      GL_EMISSION */
/*      GL_AMBIENT_AND_DIFFUSE */

/* ColorPointerType */
/*      GL_BYTE */
/*      GL_UNSIGNED_BYTE */
/*      GL_SHORT */
/*      GL_UNSIGNED_SHORT */
/*      GL_INT */
/*      GL_UNSIGNED_INT */
/*      GL_FLOAT */
/*      GL_DOUBLE */

/* CullFaceMode */
/*      GL_FRONT */
/*      GL_BACK */
/*      GL_FRONT_AND_BACK */

/* DataType */
#define GL_BYTE                           0x1400
#define GL_UNSIGNED_BYTE                  0x1401
#define GL_SHORT                          0x1402
#define GL_UNSIGNED_SHORT                 0x1403
#define GL_INT                            0x1404
#define GL_UNSIGNED_INT                   0x1405
#define GL_FLOAT                          0x1406
#define GL_2_BYTES                        0x1407
#define GL_3_BYTES                        0x1408
#define GL_4_BYTES                        0x1409
#define GL_DOUBLE                         0x140A

/* DepthFunction */
/*      GL_NEVER */
/*      GL_LESS */
/*      GL_EQUAL */
/*      GL_LEQUAL */
/*      GL_GREATER */
/*      GL_NOTEQUAL */
/*      GL_GEQUAL */
/*      GL_ALWAYS */

/* DrawBufferMode */
#define GL_NONE                           0
#define GL_FRONT_LEFT                     0x0400
#define GL_FRONT_RIGHT                    0x0401
#define GL_BACK_LEFT                      0x0402
#define GL_BACK_RIGHT                     0x0403
#define GL_FRONT                          0x0404
#define GL_BACK                           0x0405
#define GL_LEFT                           0x0406
#define GL_RIGHT                          0x0407
#define GL_FRONT_AND_BACK                 0x0408
#define GL_AUX0                           0x0409
#define GL_AUX1                           0x040A
#define GL_AUX2                           0x040B
#define GL_AUX3                           0x040C

/* Enable */
/*      GL_FOG */
/*      GL_LIGHTING */
/*      GL_TEXTURE_1D */
/*      GL_TEXTURE_2D */
/*      GL_LINE_STIPPLE */
/*      GL_POLYGON_STIPPLE */
/*      GL_CULL_FACE */
/*      GL_ALPHA_TEST */
/*      GL_BLEND */
/*      GL_INDEX_LOGIC_OP */
/*      GL_COLOR_LOGIC_OP */
/*      GL_DITHER */
/*      GL_STENCIL_TEST */
/*      GL_DEPTH_TEST */
/*      GL_CLIP_PLANE0 */
/*      GL_CLIP_PLANE1 */
/*      GL_CLIP_PLANE2 */
/*      GL_CLIP_PLANE3 */
/*      GL_CLIP_PLANE4 */
/*      GL_CLIP_PLANE5 */
/*      GL_LIGHT0 */
/*      GL_LIGHT1 */
/*      GL_LIGHT2 */
/*      GL_LIGHT3 */
/*      GL_LIGHT4 */
/*      GL_LIGHT5 */
/*      GL_LIGHT6 */
/*      GL_LIGHT7 */
/*      GL_TEXTURE_GEN_S */
/*      GL_TEXTURE_GEN_T */
/*      GL_TEXTURE_GEN_R */
/*      GL_TEXTURE_GEN_Q */
/*      GL_MAP1_VERTEX_3 */
/*      GL_MAP1_VERTEX_4 */
/*      GL_MAP1_COLOR_4 */
/*      GL_MAP1_INDEX */
/*      GL_MAP1_NORMAL */
/*      GL_MAP1_TEXTURE_COORD_1 */
/*      GL_MAP1_TEXTURE_COORD_2 */
/*      GL_MAP1_TEXTURE_COORD_3 */
/*      GL_MAP1_TEXTURE_COORD_4 */
/*      GL_MAP2_VERTEX_3 */
/*      GL_MAP2_VERTEX_4 */
/*      GL_MAP2_COLOR_4 */
/*      GL_MAP2_INDEX */
/*      GL_MAP2_NORMAL */
/*      GL_MAP2_TEXTURE_COORD_1 */
/*      GL_MAP2_TEXTURE_COORD_2 */
/*      GL_MAP2_TEXTURE_COORD_3 */
/*      GL_MAP2_TEXTURE_COORD_4 */
/*      GL_POINT_SMOOTH */
/*      GL_LINE_SMOOTH */
/*      GL_POLYGON_SMOOTH */
/*      GL_SCISSOR_TEST */
/*      GL_COLOR_MATERIAL */
/*      GL_NORMALIZE */
/*      GL_AUTO_NORMAL */
/*      GL_VERTEX_ARRAY */
/*      GL_NORMAL_ARRAY */
/*      GL_COLOR_ARRAY */
/*      GL_INDEX_ARRAY */
/*      GL_TEXTURE_COORD_ARRAY */
/*      GL_EDGE_FLAG_ARRAY */
/*      GL_POLYGON_OFFSET_POINT */
/*      GL_POLYGON_OFFSET_LINE */
/*      GL_POLYGON_OFFSET_FILL */

/* ErrorCode */
#define GL_NO_ERROR                       0
#define GL_INVALID_ENUM                   0x0500
#define GL_INVALID_VALUE                  0x0501
#define GL_INVALID_OPERATION              0x0502
#define GL_STACK_OVERFLOW                 0x0503
#define GL_STACK_UNDERFLOW                0x0504
#define GL_OUT_OF_MEMORY                  0x0505

/* FeedBackMode */
#define GL_2D                             0x0600
#define GL_3D                             0x0601
#define GL_3D_COLOR                       0x0602
#define GL_3D_COLOR_TEXTURE               0x0603
#define GL_4D_COLOR_TEXTURE               0x0604

/* FeedBackToken */
#define GL_PASS_THROUGH_TOKEN             0x0700
#define GL_POINT_TOKEN                    0x0701
#define GL_LINE_TOKEN                     0x0702
#define GL_POLYGON_TOKEN                  0x0703
#define GL_BITMAP_TOKEN                   0x0704
#define GL_DRAW_PIXEL_TOKEN               0x0705
#define GL_COPY_PIXEL_TOKEN               0x0706
#define GL_LINE_RESET_TOKEN               0x0707

/* FogMode */
/*      GL_LINEAR */
#define GL_EXP                            0x0800
#define GL_EXP2                           0x0801


/* FogParameter */
/*      GL_FOG_COLOR */
/*      GL_FOG_DENSITY */
/*      GL_FOG_END */
/*      GL_FOG_INDEX */
/*      GL_FOG_MODE */
/*      GL_FOG_START */

/* FrontFaceDirection */
#define GL_CW                             0x0900
#define GL_CCW                            0x0901

/* GetMapTarget */
#define GL_COEFF                          0x0A00
#define GL_ORDER                          0x0A01
#define GL_DOMAIN                         0x0A02

/* GetPixelMap */
/*      GL_PIXEL_MAP_I_TO_I */
/*      GL_PIXEL_MAP_S_TO_S */
/*      GL_PIXEL_MAP_I_TO_R */
/*      GL_PIXEL_MAP_I_TO_G */
/*      GL_PIXEL_MAP_I_TO_B */
/*      GL_PIXEL_MAP_I_TO_A */
/*      GL_PIXEL_MAP_R_TO_R */
/*      GL_PIXEL_MAP_G_TO_G */
/*      GL_PIXEL_MAP_B_TO_B */
/*      GL_PIXEL_MAP_A_TO_A */

/* GetPointerTarget */
/*      GL_VERTEX_ARRAY_POINTER */
/*      GL_NORMAL_ARRAY_POINTER */
/*      GL_COLOR_ARRAY_POINTER */
/*      GL_INDEX_ARRAY_POINTER */
/*      GL_TEXTURE_COORD_ARRAY_POINTER */
/*      GL_EDGE_FLAG_ARRAY_POINTER */

/* GetTarget */
#define GL_CURRENT_COLOR                  0x0B00
#define GL_CURRENT_INDEX                  0x0B01
#define GL_CURRENT_NORMAL                 0x0B02
#define GL_CURRENT_TEXTURE_COORDS         0x0B03
#define GL_CURRENT_RASTER_COLOR           0x0B04
#define GL_CURRENT_RASTER_INDEX           0x0B05
#define GL_CURRENT_RASTER_TEXTURE_COORDS  0x0B06
#define GL_CURRENT_RASTER_POSITION        0x0B07
#define GL_CURRENT_RASTER_POSITION_VALID  0x0B08
#define GL_CURRENT_RASTER_DISTANCE        0x0B09
#define GL_POINT_SMOOTH                   0x0B10
#define GL_POINT_SIZE                     0x0B11
#define GL_POINT_SIZE_RANGE               0x0B12
#define GL_POINT_SIZE_GRANULARITY         0x0B13
#define GL_LINE_SMOOTH                    0x0B20
#define GL_LINE_WIDTH                     0x0B21
#define GL_LINE_WIDTH_RANGE               0x0B22
#define GL_LINE_WIDTH_GRANULARITY         0x0B23
#define GL_LINE_STIPPLE                   0x0B24
#define GL_LINE_STIPPLE_PATTERN           0x0B25
#define GL_LINE_STIPPLE_REPEAT            0x0B26
#define GL_LIST_MODE                      0x0B30
#define GL_MAX_LIST_NESTING               0x0B31
#define GL_LIST_BASE                      0x0B32
#define GL_LIST_INDEX                     0x0B33
#define GL_POLYGON_MODE                   0x0B40
#define GL_POLYGON_SMOOTH                 0x0B41
#define GL_POLYGON_STIPPLE                0x0B42
#define GL_EDGE_FLAG                      0x0B43
#define GL_CULL_FACE                      0x0B44
#define GL_CULL_FACE_MODE                 0x0B45
#define GL_FRONT_FACE                     0x0B46
#define GL_LIGHTING                       0x0B50
#define GL_LIGHT_MODEL_LOCAL_VIEWER       0x0B51
#define GL_LIGHT_MODEL_TWO_SIDE           0x0B52
#define GL_LIGHT_MODEL_AMBIENT            0x0B53
#define GL_SHADE_MODEL                    0x0B54
#define GL_COLOR_MATERIAL_FACE            0x0B55
#define GL_COLOR_MATERIAL_PARAMETER       0x0B56
#define GL_COLOR_MATERIAL                 0x0B57
#define GL_FOG                            0x0B60
#define GL_FOG_INDEX                      0x0B61
#define GL_FOG_DENSITY                    0x0B62
#define GL_FOG_START                      0x0B63
#define GL_FOG_END                        0x0B64
#define GL_FOG_MODE                       0x0B65
#define GL_FOG_COLOR                      0x0B66
#define GL_DEPTH_RANGE                    0x0B70
#define GL_DEPTH_TEST                     0x0B71
#define GL_DEPTH_WRITEMASK                0x0B72
#define GL_DEPTH_CLEAR_VALUE              0x0B73
#define GL_DEPTH_FUNC                     0x0B74
#define GL_ACCUM_CLEAR_VALUE              0x0B80
#define GL_STENCIL_TEST                   0x0B90
#define GL_STENCIL_CLEAR_VALUE            0x0B91
#define GL_STENCIL_FUNC                   0x0B92
#define GL_STENCIL_VALUE_MASK             0x0B93
#define GL_STENCIL_FAIL                   0x0B94
#define GL_STENCIL_PASS_DEPTH_FAIL        0x0B95
#define GL_STENCIL_PASS_DEPTH_PASS        0x0B96
#define GL_STENCIL_REF                    0x0B97
#define GL_STENCIL_WRITEMASK              0x0B98
#define GL_MATRIX_MODE                    0x0BA0
#define GL_NORMALIZE                      0x0BA1
#define GL_VIEWPORT                       0x0BA2
#define GL_MODELVIEW_STACK_DEPTH          0x0BA3
#define GL_PROJECTION_STACK_DEPTH         0x0BA4
#define GL_TEXTURE_STACK_DEPTH            0x0BA5
#define GL_MODELVIEW_MATRIX               0x0BA6
#define GL_PROJECTION_MATRIX              0x0BA7
#define GL_TEXTURE_MATRIX                 0x0BA8
#define GL_ATTRIB_STACK_DEPTH             0x0BB0
#define GL_CLIENT_ATTRIB_STACK_DEPTH      0x0BB1
#define GL_ALPHA_TEST                     0x0BC0
#define GL_ALPHA_TEST_FUNC                0x0BC1
#define GL_ALPHA_TEST_REF                 0x0BC2
#define GL_DITHER                         0x0BD0
#define GL_BLEND_DST                      0x0BE0
#define GL_BLEND_SRC                      0x0BE1
#define GL_BLEND                          0x0BE2
#define GL_LOGIC_OP_MODE                  0x0BF0
#define GL_INDEX_LOGIC_OP                 0x0BF1
#define GL_COLOR_LOGIC_OP                 0x0BF2
#define GL_AUX_BUFFERS                    0x0C00
#define GL_DRAW_BUFFER                    0x0C01
#define GL_READ_BUFFER                    0x0C02
#define GL_SCISSOR_BOX                    0x0C10
#define GL_SCISSOR_TEST                   0x0C11
#define GL_INDEX_CLEAR_VALUE              0x0C20
#define GL_INDEX_WRITEMASK                0x0C21
#define GL_COLOR_CLEAR_VALUE              0x0C22
#define GL_COLOR_WRITEMASK                0x0C23
#define GL_INDEX_MODE                     0x0C30
#define GL_RGBA_MODE                      0x0C31
#define GL_DOUBLEBUFFER                   0x0C32
#define GL_STEREO                         0x0C33
#define GL_RENDER_MODE                    0x0C40
#define GL_PERSPECTIVE_CORRECTION_HINT    0x0C50
#define GL_POINT_SMOOTH_HINT              0x0C51
#define GL_LINE_SMOOTH_HINT               0x0C52
#define GL_POLYGON_SMOOTH_HINT            0x0C53
#define GL_FOG_HINT                       0x0C54
#define GL_TEXTURE_GEN_S                  0x0C60
#define GL_TEXTURE_GEN_T                  0x0C61
#define GL_TEXTURE_GEN_R                  0x0C62
#define GL_TEXTURE_GEN_Q                  0x0C63
#define GL_PIXEL_MAP_I_TO_I               0x0C70
#define GL_PIXEL_MAP_S_TO_S               0x0C71
#define GL_PIXEL_MAP_I_TO_R               0x0C72
#define GL_PIXEL_MAP_I_TO_G               0x0C73
#define GL_PIXEL_MAP_I_TO_B               0x0C74
#define GL_PIXEL_MAP_I_TO_A               0x0C75
#define GL_PIXEL_MAP_R_TO_R               0x0C76
#define GL_PIXEL_MAP_G_TO_G               0x0C77
#define GL_PIXEL_MAP_B_TO_B               0x0C78
#define GL_PIXEL_MAP_A_TO_A               0x0C79
#define GL_PIXEL_MAP_I_TO_I_SIZE          0x0CB0
#define GL_PIXEL_MAP_S_TO_S_SIZE          0x0CB1
#define GL_PIXEL_MAP_I_TO_R_SIZE          0x0CB2
#define GL_PIXEL_MAP_I_TO_G_SIZE          0x0CB3
#define GL_PIXEL_MAP_I_TO_B_SIZE          0x0CB4
#define GL_PIXEL_MAP_I_TO_A_SIZE          0x0CB5
#define GL_PIXEL_MAP_R_TO_R_SIZE          0x0CB6
#define GL_PIXEL_MAP_G_TO_G_SIZE          0x0CB7
#define GL_PIXEL_MAP_B_TO_B_SIZE          0x0CB8
#define GL_PIXEL_MAP_A_TO_A_SIZE          0x0CB9
#define GL_UNPACK_SWAP_BYTES              0x0CF0
#define GL_UNPACK_LSB_FIRST               0x0CF1
#define GL_UNPACK_ROW_LENGTH              0x0CF2
#define GL_UNPACK_SKIP_ROWS               0x0CF3
#define GL_UNPACK_SKIP_PIXELS             0x0CF4
#define GL_UNPACK_ALIGNMENT               0x0CF5
#define GL_PACK_SWAP_BYTES                0x0D00
#define GL_PACK_LSB_FIRST                 0x0D01
#define GL_PACK_ROW_LENGTH                0x0D02
#define GL_PACK_SKIP_ROWS                 0x0D03
#define GL_PACK_SKIP_PIXELS               0x0D04
#define GL_PACK_ALIGNMENT                 0x0D05
#define GL_MAP_COLOR                      0x0D10
#define GL_MAP_STENCIL                    0x0D11
#define GL_INDEX_SHIFT                    0x0D12
#define GL_INDEX_OFFSET                   0x0D13
#define GL_RED_SCALE                      0x0D14
#define GL_RED_BIAS                       0x0D15
#define GL_ZOOM_X                         0x0D16
#define GL_ZOOM_Y                         0x0D17
#define GL_GREEN_SCALE                    0x0D18
#define GL_GREEN_BIAS                     0x0D19
#define GL_BLUE_SCALE                     0x0D1A
#define GL_BLUE_BIAS                      0x0D1B
#define GL_ALPHA_SCALE                    0x0D1C
#define GL_ALPHA_BIAS                     0x0D1D
#define GL_DEPTH_SCALE                    0x0D1E
#define GL_DEPTH_BIAS                     0x0D1F
#define GL_MAX_EVAL_ORDER                 0x0D30
#define GL_MAX_LIGHTS                     0x0D31
#define GL_MAX_CLIP_PLANES                0x0D32
#define GL_MAX_TEXTURE_SIZE               0x0D33
#define GL_MAX_PIXEL_MAP_TABLE            0x0D34
#define GL_MAX_ATTRIB_STACK_DEPTH         0x0D35
#define GL_MAX_MODELVIEW_STACK_DEPTH      0x0D36
#define GL_MAX_NAME_STACK_DEPTH           0x0D37
#define GL_MAX_PROJECTION_STACK_DEPTH     0x0D38
#define GL_MAX_TEXTURE_STACK_DEPTH        0x0D39
#define GL_MAX_VIEWPORT_DIMS              0x0D3A
#define GL_MAX_CLIENT_ATTRIB_STACK_DEPTH  0x0D3B
#define GL_SUBPIXEL_BITS                  0x0D50
#define GL_INDEX_BITS                     0x0D51
#define GL_RED_BITS                       0x0D52
#define GL_GREEN_BITS                     0x0D53
#define GL_BLUE_BITS                      0x0D54
#define GL_ALPHA_BITS                     0x0D55
#define GL_DEPTH_BITS                     0x0D56
#define GL_STENCIL_BITS                   0x0D57
#define GL_ACCUM_RED_BITS                 0x0D58
#define GL_ACCUM_GREEN_BITS               0x0D59
#define GL_ACCUM_BLUE_BITS                0x0D5A
#define GL_ACCUM_ALPHA_BITS               0x0D5B
#define GL_NAME_STACK_DEPTH               0x0D70
#define GL_AUTO_NORMAL                    0x0D80
#define GL_MAP1_COLOR_4                   0x0D90
#define GL_MAP1_INDEX                     0x0D91
#define GL_MAP1_NORMAL                    0x0D92
#define GL_MAP1_TEXTURE_COORD_1           0x0D93
#define GL_MAP1_TEXTURE_COORD_2           0x0D94
#define GL_MAP1_TEXTURE_COORD_3           0x0D95
#define GL_MAP1_TEXTURE_COORD_4           0x0D96
#define GL_MAP1_VERTEX_3                  0x0D97
#define GL_MAP1_VERTEX_4                  0x0D98
#define GL_MAP2_COLOR_4                   0x0DB0
#define GL_MAP2_INDEX                     0x0DB1
#define GL_MAP2_NORMAL                    0x0DB2
#define GL_MAP2_TEXTURE_COORD_1           0x0DB3
#define GL_MAP2_TEXTURE_COORD_2           0x0DB4
#define GL_MAP2_TEXTURE_COORD_3           0x0DB5
#define GL_MAP2_TEXTURE_COORD_4           0x0DB6
#define GL_MAP2_VERTEX_3                  0x0DB7
#define GL_MAP2_VERTEX_4                  0x0DB8
#define GL_MAP1_GRID_DOMAIN               0x0DD0
#define GL_MAP1_GRID_SEGMENTS             0x0DD1
#define GL_MAP2_GRID_DOMAIN               0x0DD2
#define GL_MAP2_GRID_SEGMENTS             0x0DD3
#define GL_TEXTURE_1D                     0x0DE0
#define GL_TEXTURE_2D                     0x0DE1
#define GL_FEEDBACK_BUFFER_POINTER        0x0DF0
#define GL_FEEDBACK_BUFFER_SIZE           0x0DF1
#define GL_FEEDBACK_BUFFER_TYPE           0x0DF2
#define GL_SELECTION_BUFFER_POINTER       0x0DF3
#define GL_SELECTION_BUFFER_SIZE          0x0DF4
/*      GL_TEXTURE_BINDING_1D */
/*      GL_TEXTURE_BINDING_2D */
/*      GL_VERTEX_ARRAY */
/*      GL_NORMAL_ARRAY */
/*      GL_COLOR_ARRAY */
/*      GL_INDEX_ARRAY */
/*      GL_TEXTURE_COORD_ARRAY */
/*      GL_EDGE_FLAG_ARRAY */
/*      GL_VERTEX_ARRAY_SIZE */
/*      GL_VERTEX_ARRAY_TYPE */
/*      GL_VERTEX_ARRAY_STRIDE */
/*      GL_NORMAL_ARRAY_TYPE */
/*      GL_NORMAL_ARRAY_STRIDE */
/*      GL_COLOR_ARRAY_SIZE */
/*      GL_COLOR_ARRAY_TYPE */
/*      GL_COLOR_ARRAY_STRIDE */
/*      GL_INDEX_ARRAY_TYPE */
/*      GL_INDEX_ARRAY_STRIDE */
/*      GL_TEXTURE_COORD_ARRAY_SIZE */
/*      GL_TEXTURE_COORD_ARRAY_TYPE */
/*      GL_TEXTURE_COORD_ARRAY_STRIDE */
/*      GL_EDGE_FLAG_ARRAY_STRIDE */
/*      GL_POLYGON_OFFSET_FACTOR */
/*      GL_POLYGON_OFFSET_UNITS */

/* GetTextureParameter */
/*      GL_TEXTURE_MAG_FILTER */
/*      GL_TEXTURE_MIN_FILTER */
/*      GL_TEXTURE_WRAP_S */
/*      GL_TEXTURE_WRAP_T */
#define GL_TEXTURE_WIDTH                  0x1000
#define GL_TEXTURE_HEIGHT                 0x1001
#define GL_TEXTURE_INTERNAL_FORMAT        0x1003
#define GL_TEXTURE_BORDER_COLOR           0x1004
#define GL_TEXTURE_BORDER                 0x1005
/*      GL_TEXTURE_RED_SIZE */
/*      GL_TEXTURE_GREEN_SIZE */
/*      GL_TEXTURE_BLUE_SIZE */
/*      GL_TEXTURE_ALPHA_SIZE */
/*      GL_TEXTURE_LUMINANCE_SIZE */
/*      GL_TEXTURE_INTENSITY_SIZE */
/*      GL_TEXTURE_PRIORITY */
/*      GL_TEXTURE_RESIDENT */

/* HintMode */
#define GL_DONT_CARE                      0x1100
#define GL_FASTEST                        0x1101
#define GL_NICEST                         0x1102

/* HintTarget */
/*      GL_PERSPECTIVE_CORRECTION_HINT */
/*      GL_POINT_SMOOTH_HINT */
/*      GL_LINE_SMOOTH_HINT */
/*      GL_POLYGON_SMOOTH_HINT */
/*      GL_FOG_HINT */
/*      GL_PHONG_HINT */

/* IndexPointerType */
/*      GL_SHORT */
/*      GL_INT */
/*      GL_FLOAT */
/*      GL_DOUBLE */

/* LightModelParameter */
/*      GL_LIGHT_MODEL_AMBIENT */
/*      GL_LIGHT_MODEL_LOCAL_VIEWER */
/*      GL_LIGHT_MODEL_TWO_SIDE */

/* LightName */
#define GL_LIGHT0                         0x4000
#define GL_LIGHT1                         0x4001
#define GL_LIGHT2                         0x4002
#define GL_LIGHT3                         0x4003
#define GL_LIGHT4                         0x4004
#define GL_LIGHT5                         0x4005
#define GL_LIGHT6                         0x4006
#define GL_LIGHT7                         0x4007

/* LightParameter */
#define GL_AMBIENT                        0x1200
#define GL_DIFFUSE                        0x1201
#define GL_SPECULAR                       0x1202
#define GL_POSITION                       0x1203
#define GL_SPOT_DIRECTION                 0x1204
#define GL_SPOT_EXPONENT                  0x1205
#define GL_SPOT_CUTOFF                    0x1206
#define GL_CONSTANT_ATTENUATION           0x1207
#define GL_LINEAR_ATTENUATION             0x1208
#define GL_QUADRATIC_ATTENUATION          0x1209

/* InterleavedArrays */
/*      GL_V2F */
/*      GL_V3F */
/*      GL_C4UB_V2F */
/*      GL_C4UB_V3F */
/*      GL_C3F_V3F */
/*      GL_N3F_V3F */
/*      GL_C4F_N3F_V3F */
/*      GL_T2F_V3F */
/*      GL_T4F_V4F */
/*      GL_T2F_C4UB_V3F */
/*      GL_T2F_C3F_V3F */
/*      GL_T2F_N3F_V3F */
/*      GL_T2F_C4F_N3F_V3F */
/*      GL_T4F_C4F_N3F_V4F */

/* ListMode */
#define GL_COMPILE                        0x1300
#define GL_COMPILE_AND_EXECUTE            0x1301

/* ListNameType */
/*      GL_BYTE */
/*      GL_UNSIGNED_BYTE */
/*      GL_SHORT */
/*      GL_UNSIGNED_SHORT */
/*      GL_INT */
/*      GL_UNSIGNED_INT */
/*      GL_FLOAT */
/*      GL_2_BYTES */
/*      GL_3_BYTES */
/*      GL_4_BYTES */

/* LogicOp */
#define GL_CLEAR                          0x1500
#define GL_AND                            0x1501
#define GL_AND_REVERSE                    0x1502
#define GL_COPY                           0x1503
#define GL_AND_INVERTED                   0x1504
#define GL_NOOP                           0x1505
#define GL_XOR                            0x1506
#define GL_OR                             0x1507
#define GL_NOR                            0x1508
#define GL_EQUIV                          0x1509
#define GL_INVERT                         0x150A
#define GL_OR_REVERSE                     0x150B
#define GL_COPY_INVERTED                  0x150C
#define GL_OR_INVERTED                    0x150D
#define GL_NAND                           0x150E
#define GL_SET                            0x150F

/* MapTarget */
/*      GL_MAP1_COLOR_4 */
/*      GL_MAP1_INDEX */
/*      GL_MAP1_NORMAL */
/*      GL_MAP1_TEXTURE_COORD_1 */
/*      GL_MAP1_TEXTURE_COORD_2 */
/*      GL_MAP1_TEXTURE_COORD_3 */
/*      GL_MAP1_TEXTURE_COORD_4 */
/*      GL_MAP1_VERTEX_3 */
/*      GL_MAP1_VERTEX_4 */
/*      GL_MAP2_COLOR_4 */
/*      GL_MAP2_INDEX */
/*      GL_MAP2_NORMAL */
/*      GL_MAP2_TEXTURE_COORD_1 */
/*      GL_MAP2_TEXTURE_COORD_2 */
/*      GL_MAP2_TEXTURE_COORD_3 */
/*      GL_MAP2_TEXTURE_COORD_4 */
/*      GL_MAP2_VERTEX_3 */
/*      GL_MAP2_VERTEX_4 */

/* MaterialFace */
/*      GL_FRONT */
/*      GL_BACK */
/*      GL_FRONT_AND_BACK */

/* MaterialParameter */
#define GL_EMISSION                       0x1600
#define GL_SHININESS                      0x1601
#define GL_AMBIENT_AND_DIFFUSE            0x1602
#define GL_COLOR_INDEXES                  0x1603
/*      GL_AMBIENT */
/*      GL_DIFFUSE */
/*      GL_SPECULAR */

/* MatrixMode */
#define GL_MODELVIEW                      0x1700
#define GL_PROJECTION                     0x1701
#define GL_TEXTURE                        0x1702

/* MeshMode1 */
/*      GL_POINT */
/*      GL_LINE */

/* MeshMode2 */
/*      GL_POINT */
/*      GL_LINE */
/*      GL_FILL */

/* NormalPointerType */
/*      GL_BYTE */
/*      GL_SHORT */
/*      GL_INT */
/*      GL_FLOAT */
/*      GL_DOUBLE */

/* PixelCopyType */
#define GL_COLOR                          0x1800
#define GL_DEPTH                          0x1801
#define GL_STENCIL                        0x1802

/* PixelFormat */
#define GL_COLOR_INDEX                    0x1900
#define GL_STENCIL_INDEX                  0x1901
#define GL_DEPTH_COMPONENT                0x1902
#define GL_RED                            0x1903
#define GL_GREEN                          0x1904
#define GL_BLUE                           0x1905
#define GL_ALPHA                          0x1906
#define GL_RGB                            0x1907
#define GL_RGBA                           0x1908
#define GL_LUMINANCE                      0x1909
#define GL_LUMINANCE_ALPHA                0x190A

/* PixelMap */
/*      GL_PIXEL_MAP_I_TO_I */
/*      GL_PIXEL_MAP_S_TO_S */
/*      GL_PIXEL_MAP_I_TO_R */
/*      GL_PIXEL_MAP_I_TO_G */
/*      GL_PIXEL_MAP_I_TO_B */
/*      GL_PIXEL_MAP_I_TO_A */
/*      GL_PIXEL_MAP_R_TO_R */
/*      GL_PIXEL_MAP_G_TO_G */
/*      GL_PIXEL_MAP_B_TO_B */
/*      GL_PIXEL_MAP_A_TO_A */

/* PixelStore */
/*      GL_UNPACK_SWAP_BYTES */
/*      GL_UNPACK_LSB_FIRST */
/*      GL_UNPACK_ROW_LENGTH */
/*      GL_UNPACK_SKIP_ROWS */
/*      GL_UNPACK_SKIP_PIXELS */
/*      GL_UNPACK_ALIGNMENT */
/*      GL_PACK_SWAP_BYTES */
/*      GL_PACK_LSB_FIRST */
/*      GL_PACK_ROW_LENGTH */
/*      GL_PACK_SKIP_ROWS */
/*      GL_PACK_SKIP_PIXELS */
/*      GL_PACK_ALIGNMENT */

/* PixelTransfer */
/*      GL_MAP_COLOR */
/*      GL_MAP_STENCIL */
/*      GL_INDEX_SHIFT */
/*      GL_INDEX_OFFSET */
/*      GL_RED_SCALE */
/*      GL_RED_BIAS */
/*      GL_GREEN_SCALE */
/*      GL_GREEN_BIAS */
/*      GL_BLUE_SCALE */
/*      GL_BLUE_BIAS */
/*      GL_ALPHA_SCALE */
/*      GL_ALPHA_BIAS */
/*      GL_DEPTH_SCALE */
/*      GL_DEPTH_BIAS */

/* PixelType */
#define GL_BITMAP                         0x1A00
/*      GL_BYTE */
/*      GL_UNSIGNED_BYTE */
/*      GL_SHORT */
/*      GL_UNSIGNED_SHORT */
/*      GL_INT */
/*      GL_UNSIGNED_INT */
/*      GL_FLOAT */

/* PolygonMode */
#define GL_POINT                          0x1B00
#define GL_LINE                           0x1B01
#define GL_FILL                           0x1B02

/* ReadBufferMode */
/*      GL_FRONT_LEFT */
/*      GL_FRONT_RIGHT */
/*      GL_BACK_LEFT */
/*      GL_BACK_RIGHT */
/*      GL_FRONT */
/*      GL_BACK */
/*      GL_LEFT */
/*      GL_RIGHT */
/*      GL_AUX0 */
/*      GL_AUX1 */
/*      GL_AUX2 */
/*      GL_AUX3 */

/* RenderingMode */
#define GL_RENDER                         0x1C00
#define GL_FEEDBACK                       0x1C01
#define GL_SELECT                         0x1C02

/* ShadingModel */
#define GL_FLAT                           0x1D00
#define GL_SMOOTH                         0x1D01


/* StencilFunction */
/*      GL_NEVER */
/*      GL_LESS */
/*      GL_EQUAL */
/*      GL_LEQUAL */
/*      GL_GREATER */
/*      GL_NOTEQUAL */
/*      GL_GEQUAL */
/*      GL_ALWAYS */

/* StencilOp */
/*      GL_ZERO */
#define GL_KEEP                           0x1E00
#define GL_REPLACE                        0x1E01
#define GL_INCR                           0x1E02
#define GL_DECR                           0x1E03
/*      GL_INVERT */

/* StringName */
#define GL_VENDOR                         0x1F00
#define GL_RENDERER                       0x1F01
#define GL_VERSION                        0x1F02
#define GL_EXTENSIONS                     0x1F03

/* TextureCoordName */
#define GL_S                              0x2000
#define GL_T                              0x2001
#define GL_R                              0x2002
#define GL_Q                              0x2003

/* TexCoordPointerType */
/*      GL_SHORT */
/*      GL_INT */
/*      GL_FLOAT */
/*      GL_DOUBLE */

/* TextureEnvMode */
#define GL_MODULATE                       0x2100
#define GL_DECAL                          0x2101
/*      GL_BLEND */
/*      GL_REPLACE */

/* TextureEnvParameter */
#define GL_TEXTURE_ENV_MODE               0x2200
#define GL_TEXTURE_ENV_COLOR              0x2201

/* TextureEnvTarget */
#define GL_TEXTURE_ENV                    0x2300

/* TextureGenMode */
#define GL_EYE_LINEAR                     0x2400
#define GL_OBJECT_LINEAR                  0x2401
#define GL_SPHERE_MAP                     0x2402

/* TextureGenParameter */
#define GL_TEXTURE_GEN_MODE               0x2500
#define GL_OBJECT_PLANE                   0x2501
#define GL_EYE_PLANE                      0x2502

/* TextureMagFilter */
#define GL_NEAREST                        0x2600
#define GL_LINEAR                         0x2601

/* TextureMinFilter */
/*      GL_NEAREST */
/*      GL_LINEAR */
#define GL_NEAREST_MIPMAP_NEAREST         0x2700
#define GL_LINEAR_MIPMAP_NEAREST          0x2701
#define GL_NEAREST_MIPMAP_LINEAR          0x2702
#define GL_LINEAR_MIPMAP_LINEAR           0x2703

/* TextureParameterName */
#define GL_TEXTURE_MAG_FILTER             0x2800
#define GL_TEXTURE_MIN_FILTER             0x2801
#define GL_TEXTURE_WRAP_S                 0x2802
#define GL_TEXTURE_WRAP_T                 0x2803
/*      GL_TEXTURE_BORDER_COLOR */
/*      GL_TEXTURE_PRIORITY */

/* TextureTarget */
/*      GL_TEXTURE_1D */
/*      GL_TEXTURE_2D */
/*      GL_PROXY_TEXTURE_1D */
/*      GL_PROXY_TEXTURE_2D */

/* TextureWrapMode */
#define GL_CLAMP                          0x2900
#define GL_REPEAT                         0x2901

/* VertexPointerType */
/*      GL_SHORT */
/*      GL_INT */
/*      GL_FLOAT */
/*      GL_DOUBLE */

/* ClientAttribMask */
#define GL_CLIENT_PIXEL_STORE_BIT         0x00000001
#define GL_CLIENT_VERTEX_ARRAY_BIT        0x00000002
#define GL_CLIENT_ALL_ATTRIB_BITS         0xffffffff

/* polygon_offset */
#define GL_POLYGON_OFFSET_FACTOR          0x8038
#define GL_POLYGON_OFFSET_UNITS           0x2A00
#define GL_POLYGON_OFFSET_POINT           0x2A01
#define GL_POLYGON_OFFSET_LINE            0x2A02
#define GL_POLYGON_OFFSET_FILL            0x8037

/* texture */
#define GL_ALPHA4                         0x803B
#define GL_ALPHA8                         0x803C
#define GL_ALPHA12                        0x803D
#define GL_ALPHA16                        0x803E
#define GL_LUMINANCE4                     0x803F
#define GL_LUMINANCE8                     0x8040
#define GL_LUMINANCE12                    0x8041
#define GL_LUMINANCE16                    0x8042
#define GL_LUMINANCE4_ALPHA4              0x8043
#define GL_LUMINANCE6_ALPHA2              0x8044
#define GL_LUMINANCE8_ALPHA8              0x8045
#define GL_LUMINANCE12_ALPHA4             0x8046
#define GL_LUMINANCE12_ALPHA12            0x8047
#define GL_LUMINANCE16_ALPHA16            0x8048
#define GL_INTENSITY                      0x8049
#define GL_INTENSITY4                     0x804A
#define GL_INTENSITY8                     0x804B
#define GL_INTENSITY12                    0x804C
#define GL_INTENSITY16                    0x804D
#define GL_R3_G3_B2                       0x2A10
#define GL_RGB4                           0x804F
#define GL_RGB5                           0x8050
#define GL_RGB8                           0x8051
#define GL_RGB10                          0x8052
#define GL_RGB12                          0x8053
#define GL_RGB16                          0x8054
#define GL_RGBA2                          0x8055
#define GL_RGBA4                          0x8056
#define GL_RGB5_A1                        0x8057
#define GL_RGBA8                          0x8058
#define GL_RGB10_A2                       0x8059
#define GL_RGBA12                         0x805A
#define GL_RGBA16                         0x805B
#define GL_TEXTURE_RED_SIZE               0x805C
#define GL_TEXTURE_GREEN_SIZE             0x805D
#define GL_TEXTURE_BLUE_SIZE              0x805E
#define GL_TEXTURE_ALPHA_SIZE             0x805F
#define GL_TEXTURE_LUMINANCE_SIZE         0x8060
#define GL_TEXTURE_INTENSITY_SIZE         0x8061
#define GL_PROXY_TEXTURE_1D               0x8063
#define GL_PROXY_TEXTURE_2D               0x8064

/* texture_object */
#define GL_TEXTURE_PRIORITY               0x8066
#define GL_TEXTURE_RESIDENT               0x8067
#define GL_TEXTURE_BINDING_1D             0x8068
#define GL_TEXTURE_BINDING_2D             0x8069

/* vertex_array */
#define GL_VERTEX_ARRAY                   0x8074
#define GL_NORMAL_ARRAY                   0x8075
#define GL_COLOR_ARRAY                    0x8076
#define GL_INDEX_ARRAY                    0x8077
#define GL_TEXTURE_COORD_ARRAY            0x8078
#define GL_EDGE_FLAG_ARRAY                0x8079
#define GL_VERTEX_ARRAY_SIZE              0x807A
#define GL_VERTEX_ARRAY_TYPE              0x807B
#define GL_VERTEX_ARRAY_STRIDE            0x807C
#define GL_NORMAL_ARRAY_TYPE              0x807E
#define GL_NORMAL_ARRAY_STRIDE            0x807F
#define GL_COLOR_ARRAY_SIZE               0x8081
#define GL_COLOR_ARRAY_TYPE               0x8082
#define GL_COLOR_ARRAY_STRIDE             0x8083
#define GL_INDEX_ARRAY_TYPE               0x8085
#define GL_INDEX_ARRAY_STRIDE             0x8086
#define GL_TEXTURE_COORD_ARRAY_SIZE       0x8088
#define GL_TEXTURE_COORD_ARRAY_TYPE       0x8089
#define GL_TEXTURE_COORD_ARRAY_STRIDE     0x808A
#define GL_EDGE_FLAG_ARRAY_STRIDE         0x808C
#define GL_VERTEX_ARRAY_POINTER           0x808E
#define GL_NORMAL_ARRAY_POINTER           0x808F
#define GL_COLOR_ARRAY_POINTER            0x8090
#define GL_INDEX_ARRAY_POINTER            0x8091
#define GL_TEXTURE_COORD_ARRAY_POINTER    0x8092
#define GL_EDGE_FLAG_ARRAY_POINTER        0x8093
#define GL_V2F                            0x2A20
#define GL_V3F                            0x2A21
#define GL_C4UB_V2F                       0x2A22
#define GL_C4UB_V3F                       0x2A23
#define GL_C3F_V3F                        0x2A24
#define GL_N3F_V3F                        0x2A25
#define GL_C4F_N3F_V3F                    0x2A26
#define GL_T2F_V3F                        0x2A27
#define GL_T4F_V4F                        0x2A28
#define GL_T2F_C4UB_V3F                   0x2A29
#define GL_T2F_C3F_V3F                    0x2A2A
#define GL_T2F_N3F_V3F                    0x2A2B
#define GL_T2F_C4F_N3F_V3F                0x2A2C
#define GL_T4F_C4F_N3F_V4F                0x2A2D

/* Extensions */
#define GL_EXT_vertex_array               1
#define GL_EXT_bgra                       1
#define GL_EXT_paletted_texture           1
#define GL_WIN_swap_hint                  1
#define GL_WIN_draw_range_elements        1
// #define GL_WIN_phong_shading              1
// #define GL_WIN_specular_fog               1

/* EXT_vertex_array */
#define GL_VERTEX_ARRAY_EXT               0x8074
#define GL_NORMAL_ARRAY_EXT               0x8075
#define GL_COLOR_ARRAY_EXT                0x8076
#define GL_INDEX_ARRAY_EXT                0x8077
#define GL_TEXTURE_COORD_ARRAY_EXT        0x8078
#define GL_EDGE_FLAG_ARRAY_EXT            0x8079
#define GL_VERTEX_ARRAY_SIZE_EXT          0x807A
#define GL_VERTEX_ARRAY_TYPE_EXT          0x807B
#define GL_VERTEX_ARRAY_STRIDE_EXT        0x807C
#define GL_VERTEX_ARRAY_COUNT_EXT         0x807D
#define GL_NORMAL_ARRAY_TYPE_EXT          0x807E
#define GL_NORMAL_ARRAY_STRIDE_EXT        0x807F
#define GL_NORMAL_ARRAY_COUNT_EXT         0x8080
#define GL_COLOR_ARRAY_SIZE_EXT           0x8081
#define GL_COLOR_ARRAY_TYPE_EXT           0x8082
#define GL_COLOR_ARRAY_STRIDE_EXT         0x8083
#define GL_COLOR_ARRAY_COUNT_EXT          0x8084
#define GL_INDEX_ARRAY_TYPE_EXT           0x8085
#define GL_INDEX_ARRAY_STRIDE_EXT         0x8086
#define GL_INDEX_ARRAY_COUNT_EXT          0x8087
#define GL_TEXTURE_COORD_ARRAY_SIZE_EXT   0x8088
#define GL_TEXTURE_COORD_ARRAY_TYPE_EXT   0x8089
#define GL_TEXTURE_COORD_ARRAY_STRIDE_EXT 0x808A
#define GL_TEXTURE_COORD_ARRAY_COUNT_EXT  0x808B
#define GL_EDGE_FLAG_ARRAY_STRIDE_EXT     0x808C
#define GL_EDGE_FLAG_ARRAY_COUNT_EXT      0x808D
#define GL_VERTEX_ARRAY_POINTER_EXT       0x808E
#define GL_NORMAL_ARRAY_POINTER_EXT       0x808F
#define GL_COLOR_ARRAY_POINTER_EXT        0x8090
#define GL_INDEX_ARRAY_POINTER_EXT        0x8091
#define GL_TEXTURE_COORD_ARRAY_POINTER_EXT 0x8092
#define GL_EDGE_FLAG_ARRAY_POINTER_EXT    0x8093
#define GL_DOUBLE_EXT                     GL_DOUBLE

/* EXT_bgra */
#define GL_BGR_EXT                        0x80E0
#define GL_BGRA_EXT                       0x80E1

/* EXT_paletted_texture */

/* These must match the GL_COLOR_TABLE_*_SGI enumerants */
#define GL_COLOR_TABLE_FORMAT_EXT         0x80D8
#define GL_COLOR_TABLE_WIDTH_EXT          0x80D9
#define GL_COLOR_TABLE_RED_SIZE_EXT       0x80DA
#define GL_COLOR_TABLE_GREEN_SIZE_EXT     0x80DB
#define GL_COLOR_TABLE_BLUE_SIZE_EXT      0x80DC
#define GL_COLOR_TABLE_ALPHA_SIZE_EXT     0x80DD
#define GL_COLOR_TABLE_LUMINANCE_SIZE_EXT 0x80DE
#define GL_COLOR_TABLE_INTENSITY_SIZE_EXT 0x80DF

#define GL_COLOR_INDEX1_EXT               0x80E2
#define GL_COLOR_INDEX2_EXT               0x80E3
#define GL_COLOR_INDEX4_EXT               0x80E4
#define GL_COLOR_INDEX8_EXT               0x80E5
#define GL_COLOR_INDEX12_EXT              0x80E6
#define GL_COLOR_INDEX16_EXT              0x80E7

/* WIN_draw_range_elements */
#define GL_MAX_ELEMENTS_VERTICES_WIN      0x80E8
#define GL_MAX_ELEMENTS_INDICES_WIN       0x80E9

/* WIN_phong_shading */
#define GL_PHONG_WIN                      0x80EA 
#define GL_PHONG_HINT_WIN                 0x80EB 

/* WIN_specular_fog */
#define GL_FOG_SPECULAR_TEXTURE_WIN       0x80EC

/* For compatibility with OpenGL v1.0 */
#define GL_LOGIC_OP GL_INDEX_LOGIC_OP
#define GL_TEXTURE_COMPONENTS GL_TEXTURE_INTERNAL_FORMAT

/*************************************************************/

WINGDIAPI void APIENTRY glAccum (GLenum op, GLfloat value);
WINGDIAPI void APIENTRY glAlphaFunc (GLenum func, GLclampf ref);
WINGDIAPI GLboolean APIENTRY glAreTexturesResident (GLsizei n, const GLuint *textures, GLboolean *residences);
WINGDIAPI void APIENTRY glArrayElement (GLint i);
WINGDIAPI void APIENTRY glBegin (GLenum mode);
WINGDIAPI void APIENTRY glBindTexture (GLenum target, GLuint texture);
WINGDIAPI void APIENTRY glBitmap (GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap);
WINGDIAPI void APIENTRY glBlendFunc (GLenum sfactor, GLenum dfactor);
WINGDIAPI void APIENTRY glCallList (GLuint list);
WINGDIAPI void APIENTRY glCallLists (GLsizei n, GLenum type, const GLvoid *lists);
WINGDIAPI void APIENTRY glClear (GLbitfield mask);
WINGDIAPI void APIENTRY glClearAccum (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
WINGDIAPI void APIENTRY glClearColor (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
WINGDIAPI void APIENTRY glClearDepth (GLclampd depth);
WINGDIAPI void APIENTRY glClearIndex (GLfloat c);
WINGDIAPI void APIENTRY glClearStencil (GLint s);
WINGDIAPI void APIENTRY glClipPlane (GLenum plane, const GLdouble *equation);
WINGDIAPI void APIENTRY glColor3b (GLbyte red, GLbyte green, GLbyte blue);
WINGDIAPI void APIENTRY glColor3bv (const GLbyte *v);
WINGDIAPI void APIENTRY glColor3d (GLdouble red, GLdouble green, GLdouble blue);
WINGDIAPI void APIENTRY glColor3dv (const GLdouble *v);
WINGDIAPI void APIENTRY glColor3f (GLfloat red, GLfloat green, GLfloat blue);
WINGDIAPI void APIENTRY glColor3fv (const GLfloat *v);
WINGDIAPI void APIENTRY glColor3i (GLint red, GLint green, GLint blue);
WINGDIAPI void APIENTRY glColor3iv (const GLint *v);
WINGDIAPI void APIENTRY glColor3s (GLshort red, GLshort green, GLshort blue);
WINGDIAPI void APIENTRY glColor3sv (const GLshort *v);
WINGDIAPI void APIENTRY glColor3ub (GLubyte red, GLubyte green, GLubyte blue);
WINGDIAPI void APIENTRY glColor3ubv (const GLubyte *v);
WINGDIAPI void APIENTRY glColor3ui (GLuint red, GLuint green, GLuint blue);
WINGDIAPI void APIENTRY glColor3uiv (const GLuint *v);
WINGDIAPI void APIENTRY glColor3us (GLushort red, GLushort green, GLushort blue);
WINGDIAPI void APIENTRY glColor3usv (const GLushort *v);
WINGDIAPI void APIENTRY glColor4b (GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha);
WINGDIAPI void APIENTRY glColor4bv (const GLbyte *v);
WINGDIAPI void APIENTRY glColor4d (GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha);
WINGDIAPI void APIENTRY glColor4dv (const GLdouble *v);
WINGDIAPI void APIENTRY glColor4f (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
WINGDIAPI void APIENTRY glColor4fv (const GLfloat *v);
WINGDIAPI void APIENTRY glColor4i (GLint red, GLint green, GLint blue, GLint alpha);
WINGDIAPI void APIENTRY glColor4iv (const GLint *v);
WINGDIAPI void APIENTRY glColor4s (GLshort red, GLshort green, GLshort blue, GLshort alpha);
WINGDIAPI void APIENTRY glColor4sv (const GLshort *v);
WINGDIAPI void APIENTRY glColor4ub (GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha);
WINGDIAPI void APIENTRY glColor4ubv (const GLubyte *v);
WINGDIAPI void APIENTRY glColor4ui (GLuint red, GLuint green, GLuint blue, GLuint alpha);
WINGDIAPI void APIENTRY glColor4uiv (const GLuint *v);
WINGDIAPI void APIENTRY glColor4us (GLushort red, GLushort green, GLushort blue, GLushort alpha);
WINGDIAPI void APIENTRY glColor4usv (const GLushort *v);
WINGDIAPI void APIENTRY glColorMask (GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
WINGDIAPI void APIENTRY glColorMaterial (GLenum face, GLenum mode);
WINGDIAPI void APIENTRY glColorPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
WINGDIAPI void APIENTRY glCopyPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum type);
WINGDIAPI void APIENTRY glCopyTexImage1D (GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLint border);
WINGDIAPI void APIENTRY glCopyTexImage2D (GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
WINGDIAPI void APIENTRY glCopyTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
WINGDIAPI void APIENTRY glCopyTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
WINGDIAPI void APIENTRY glCullFace (GLenum mode);
WINGDIAPI void APIENTRY glDeleteLists (GLuint list, GLsizei range);
WINGDIAPI void APIENTRY glDeleteTextures (GLsizei n, const GLuint *textures);
WINGDIAPI void APIENTRY glDepthFunc (GLenum func);
WINGDIAPI void APIENTRY glDepthMask (GLboolean flag);
WINGDIAPI void APIENTRY glDepthRange (GLclampd zNear, GLclampd zFar);
WINGDIAPI void APIENTRY glDisable (GLenum cap);
WINGDIAPI void APIENTRY glDisableClientState (GLenum array);
WINGDIAPI void APIENTRY glDrawArrays (GLenum mode, GLint first, GLsizei count);
WINGDIAPI void APIENTRY glDrawBuffer (GLenum mode);
WINGDIAPI void APIENTRY glDrawElements (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices);
WINGDIAPI void APIENTRY glDrawPixels (GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
WINGDIAPI void APIENTRY glEdgeFlag (GLboolean flag);
WINGDIAPI void APIENTRY glEdgeFlagPointer (GLsizei stride, const GLvoid *pointer);
WINGDIAPI void APIENTRY glEdgeFlagv (const GLboolean *flag);
WINGDIAPI void APIENTRY glEnable (GLenum cap);
WINGDIAPI void APIENTRY glEnableClientState (GLenum array);
WINGDIAPI void APIENTRY glEnd (void);
WINGDIAPI void APIENTRY glEndList (void);
WINGDIAPI void APIENTRY glEvalCoord1d (GLdouble u);
WINGDIAPI void APIENTRY glEvalCoord1dv (const GLdouble *u);
WINGDIAPI void APIENTRY glEvalCoord1f (GLfloat u);
WINGDIAPI void APIENTRY glEvalCoord1fv (const GLfloat *u);
WINGDIAPI void APIENTRY glEvalCoord2d (GLdouble u, GLdouble v);
WINGDIAPI void APIENTRY glEvalCoord2dv (const GLdouble *u);
WINGDIAPI void APIENTRY glEvalCoord2f (GLfloat u, GLfloat v);
WINGDIAPI void APIENTRY glEvalCoord2fv (const GLfloat *u);
WINGDIAPI void APIENTRY glEvalMesh1 (GLenum mode, GLint i1, GLint i2);
WINGDIAPI void APIENTRY glEvalMesh2 (GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2);
WINGDIAPI void APIENTRY glEvalPoint1 (GLint i);
WINGDIAPI void APIENTRY glEvalPoint2 (GLint i, GLint j);
WINGDIAPI void APIENTRY glFeedbackBuffer (GLsizei size, GLenum type, GLfloat *buffer);
WINGDIAPI void APIENTRY glFinish (void);
WINGDIAPI void APIENTRY glFlush (void);
WINGDIAPI void APIENTRY glFogf (GLenum pname, GLfloat param);
WINGDIAPI void APIENTRY glFogfv (GLenum pname, const GLfloat *params);
WINGDIAPI void APIENTRY glFogi (GLenum pname, GLint param);
WINGDIAPI void APIENTRY glFogiv (GLenum pname, const GLint *params);
WINGDIAPI void APIENTRY glFrontFace (GLenum mode);
WINGDIAPI void APIENTRY glFrustum (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
WINGDIAPI GLuint APIENTRY glGenLists (GLsizei range);
WINGDIAPI void APIENTRY glGenTextures (GLsizei n, GLuint *textures);
WINGDIAPI void APIENTRY glGetBooleanv (GLenum pname, GLboolean *params);
WINGDIAPI void APIENTRY glGetClipPlane (GLenum plane, GLdouble *equation);
WINGDIAPI void APIENTRY glGetDoublev (GLenum pname, GLdouble *params);
WINGDIAPI GLenum APIENTRY glGetError (void);
WINGDIAPI void APIENTRY glGetFloatv (GLenum pname, GLfloat *params);
WINGDIAPI void APIENTRY glGetIntegerv (GLenum pname, GLint *params);
WINGDIAPI void APIENTRY glGetLightfv (GLenum light, GLenum pname, GLfloat *params);
WINGDIAPI void APIENTRY glGetLightiv (GLenum light, GLenum pname, GLint *params);
WINGDIAPI void APIENTRY glGetMapdv (GLenum target, GLenum query, GLdouble *v);
WINGDIAPI void APIENTRY glGetMapfv (GLenum target, GLenum query, GLfloat *v);
WINGDIAPI void APIENTRY glGetMapiv (GLenum target, GLenum query, GLint *v);
WINGDIAPI void APIENTRY glGetMaterialfv (GLenum face, GLenum pname, GLfloat *params);
WINGDIAPI void APIENTRY glGetMaterialiv (GLenum face, GLenum pname, GLint *params);
WINGDIAPI void APIENTRY glGetPixelMapfv (GLenum map, GLfloat *values);
WINGDIAPI void APIENTRY glGetPixelMapuiv (GLenum map, GLuint *values);
WINGDIAPI void APIENTRY glGetPixelMapusv (GLenum map, GLushort *values);
WINGDIAPI void APIENTRY glGetPointerv (GLenum pname, GLvoid* *params);
WINGDIAPI void APIENTRY glGetPolygonStipple (GLubyte *mask);
WINGDIAPI const GLubyte * APIENTRY glGetString (GLenum name);
WINGDIAPI void APIENTRY glGetTexEnvfv (GLenum target, GLenum pname, GLfloat *params);
WINGDIAPI void APIENTRY glGetTexEnviv (GLenum target, GLenum pname, GLint *params);
WINGDIAPI void APIENTRY glGetTexGendv (GLenum coord, GLenum pname, GLdouble *params);
WINGDIAPI void APIENTRY glGetTexGenfv (GLenum coord, GLenum pname, GLfloat *params);
WINGDIAPI void APIENTRY glGetTexGeniv (GLenum coord, GLenum pname, GLint *params);
WINGDIAPI void APIENTRY glGetTexImage (GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels);
WINGDIAPI void APIENTRY glGetTexLevelParameterfv (GLenum target, GLint level, GLenum pname, GLfloat *params);
WINGDIAPI void APIENTRY glGetTexLevelParameteriv (GLenum target, GLint level, GLenum pname, GLint *params);
WINGDIAPI void APIENTRY glGetTexParameterfv (GLenum target, GLenum pname, GLfloat *params);
WINGDIAPI void APIENTRY glGetTexParameteriv (GLenum target, GLenum pname, GLint *params);
WINGDIAPI void APIENTRY glHint (GLenum target, GLenum mode);
WINGDIAPI void APIENTRY glIndexMask (GLuint mask);
WINGDIAPI void APIENTRY glIndexPointer (GLenum type, GLsizei stride, const GLvoid *pointer);
WINGDIAPI void APIENTRY glIndexd (GLdouble c);
WINGDIAPI void APIENTRY glIndexdv (const GLdouble *c);
WINGDIAPI void APIENTRY glIndexf (GLfloat c);
WINGDIAPI void APIENTRY glIndexfv (const GLfloat *c);
WINGDIAPI void APIENTRY glIndexi (GLint c);
WINGDIAPI void APIENTRY glIndexiv (const GLint *c);
WINGDIAPI void APIENTRY glIndexs (GLshort c);
WINGDIAPI void APIENTRY glIndexsv (const GLshort *c);
WINGDIAPI void APIENTRY glIndexub (GLubyte c);
WINGDIAPI void APIENTRY glIndexubv (const GLubyte *c);
WINGDIAPI void APIENTRY glInitNames (void);
WINGDIAPI void APIENTRY glInterleavedArrays (GLenum format, GLsizei stride, const GLvoid *pointer);
WINGDIAPI GLboolean APIENTRY glIsEnabled (GLenum cap);
WINGDIAPI GLboolean APIENTRY glIsList (GLuint list);
WINGDIAPI GLboolean APIENTRY glIsTexture (GLuint texture);
WINGDIAPI void APIENTRY glLightModelf (GLenum pname, GLfloat param);
WINGDIAPI void APIENTRY glLightModelfv (GLenum pname, const GLfloat *params);
WINGDIAPI void APIENTRY glLightModeli (GLenum pname, GLint param);
WINGDIAPI void APIENTRY glLightModeliv (GLenum pname, const GLint *params);
WINGDIAPI void APIENTRY glLightf (GLenum light, GLenum pname, GLfloat param);
WINGDIAPI void APIENTRY glLightfv (GLenum light, GLenum pname, const GLfloat *params);
WINGDIAPI void APIENTRY glLighti (GLenum light, GLenum pname, GLint param);
WINGDIAPI void APIENTRY glLightiv (GLenum light, GLenum pname, const GLint *params);
WINGDIAPI void APIENTRY glLineStipple (GLint factor, GLushort pattern);
WINGDIAPI void APIENTRY glLineWidth (GLfloat width);
WINGDIAPI void APIENTRY glListBase (GLuint base);
WINGDIAPI void APIENTRY glLoadIdentity (void);
WINGDIAPI void APIENTRY glLoadMatrixd (const GLdouble *m);
WINGDIAPI void APIENTRY glLoadMatrixf (const GLfloat *m);
WINGDIAPI void APIENTRY glLoadName (GLuint name);
WINGDIAPI void APIENTRY glLogicOp (GLenum opcode);
WINGDIAPI void APIENTRY glMap1d (GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points);
WINGDIAPI void APIENTRY glMap1f (GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points);
WINGDIAPI void APIENTRY glMap2d (GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points);
WINGDIAPI void APIENTRY glMap2f (GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points);
WINGDIAPI void APIENTRY glMapGrid1d (GLint un, GLdouble u1, GLdouble u2);
WINGDIAPI void APIENTRY glMapGrid1f (GLint un, GLfloat u1, GLfloat u2);
WINGDIAPI void APIENTRY glMapGrid2d (GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2);
WINGDIAPI void APIENTRY glMapGrid2f (GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2);
WINGDIAPI void APIENTRY glMaterialf (GLenum face, GLenum pname, GLfloat param);
WINGDIAPI void APIENTRY glMaterialfv (GLenum face, GLenum pname, const GLfloat *params);
WINGDIAPI void APIENTRY glMateriali (GLenum face, GLenum pname, GLint param);
WINGDIAPI void APIENTRY glMaterialiv (GLenum face, GLenum pname, const GLint *params);
WINGDIAPI void APIENTRY glMatrixMode (GLenum mode);
WINGDIAPI void APIENTRY glMultMatrixd (const GLdouble *m);
WINGDIAPI void APIENTRY glMultMatrixf (const GLfloat *m);
WINGDIAPI void APIENTRY glNewList (GLuint list, GLenum mode);
WINGDIAPI void APIENTRY glNormal3b (GLbyte nx, GLbyte ny, GLbyte nz);
WINGDIAPI void APIENTRY glNormal3bv (const GLbyte *v);
WINGDIAPI void APIENTRY glNormal3d (GLdouble nx, GLdouble ny, GLdouble nz);
WINGDIAPI void APIENTRY glNormal3dv (const GLdouble *v);
WINGDIAPI void APIENTRY glNormal3f (GLfloat nx, GLfloat ny, GLfloat nz);
WINGDIAPI void APIENTRY glNormal3fv (const GLfloat *v);
WINGDIAPI void APIENTRY glNormal3i (GLint nx, GLint ny, GLint nz);
WINGDIAPI void APIENTRY glNormal3iv (const GLint *v);
WINGDIAPI void APIENTRY glNormal3s (GLshort nx, GLshort ny, GLshort nz);
WINGDIAPI void APIENTRY glNormal3sv (const GLshort *v);
WINGDIAPI void APIENTRY glNormalPointer (GLenum type, GLsizei stride, const GLvoid *pointer);
WINGDIAPI void APIENTRY glOrtho (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
WINGDIAPI void APIENTRY glPassThrough (GLfloat token);
WINGDIAPI void APIENTRY glPixelMapfv (GLenum map, GLsizei mapsize, const GLfloat *values);
WINGDIAPI void APIENTRY glPixelMapuiv (GLenum map, GLsizei mapsize, const GLuint *values);
WINGDIAPI void APIENTRY glPixelMapusv (GLenum map, GLsizei mapsize, const GLushort *values);
WINGDIAPI void APIENTRY glPixelStoref (GLenum pname, GLfloat param);
WINGDIAPI void APIENTRY glPixelStorei (GLenum pname, GLint param);
WINGDIAPI void APIENTRY glPixelTransferf (GLenum pname, GLfloat param);
WINGDIAPI void APIENTRY glPixelTransferi (GLenum pname, GLint param);
WINGDIAPI void APIENTRY glPixelZoom (GLfloat xfactor, GLfloat yfactor);
WINGDIAPI void APIENTRY glPointSize (GLfloat size);
WINGDIAPI void APIENTRY glPolygonMode (GLenum face, GLenum mode);
WINGDIAPI void APIENTRY glPolygonOffset (GLfloat factor, GLfloat units);
WINGDIAPI void APIENTRY glPolygonStipple (const GLubyte *mask);
WINGDIAPI void APIENTRY glPopAttrib (void);
WINGDIAPI void APIENTRY glPopClientAttrib (void);
WINGDIAPI void APIENTRY glPopMatrix (void);
WINGDIAPI void APIENTRY glPopName (void);
WINGDIAPI void APIENTRY glPrioritizeTextures (GLsizei n, const GLuint *textures, const GLclampf *priorities);
WINGDIAPI void APIENTRY glPushAttrib (GLbitfield mask);
WINGDIAPI void APIENTRY glPushClientAttrib (GLbitfield mask);
WINGDIAPI void APIENTRY glPushMatrix (void);
WINGDIAPI void APIENTRY glPushName (GLuint name);
WINGDIAPI void APIENTRY glRasterPos2d (GLdouble x, GLdouble y);
WINGDIAPI void APIENTRY glRasterPos2dv (const GLdouble *v);
WINGDIAPI void APIENTRY glRasterPos2f (GLfloat x, GLfloat y);
WINGDIAPI void APIENTRY glRasterPos2fv (const GLfloat *v);
WINGDIAPI void APIENTRY glRasterPos2i (GLint x, GLint y);
WINGDIAPI void APIENTRY glRasterPos2iv (const GLint *v);
WINGDIAPI void APIENTRY glRasterPos2s (GLshort x, GLshort y);
WINGDIAPI void APIENTRY glRasterPos2sv (const GLshort *v);
WINGDIAPI void APIENTRY glRasterPos3d (GLdouble x, GLdouble y, GLdouble z);
WINGDIAPI void APIENTRY glRasterPos3dv (const GLdouble *v);
WINGDIAPI void APIENTRY glRasterPos3f (GLfloat x, GLfloat y, GLfloat z);
WINGDIAPI void APIENTRY glRasterPos3fv (const GLfloat *v);
WINGDIAPI void APIENTRY glRasterPos3i (GLint x, GLint y, GLint z);
WINGDIAPI void APIENTRY glRasterPos3iv (const GLint *v);
WINGDIAPI void APIENTRY glRasterPos3s (GLshort x, GLshort y, GLshort z);
WINGDIAPI void APIENTRY glRasterPos3sv (const GLshort *v);
WINGDIAPI void APIENTRY glRasterPos4d (GLdouble x, GLdouble y, GLdouble z, GLdouble w);
WINGDIAPI void APIENTRY glRasterPos4dv (const GLdouble *v);
WINGDIAPI void APIENTRY glRasterPos4f (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
WINGDIAPI void APIENTRY glRasterPos4fv (const GLfloat *v);
WINGDIAPI void APIENTRY glRasterPos4i (GLint x, GLint y, GLint z, GLint w);
WINGDIAPI void APIENTRY glRasterPos4iv (const GLint *v);
WINGDIAPI void APIENTRY glRasterPos4s (GLshort x, GLshort y, GLshort z, GLshort w);
WINGDIAPI void APIENTRY glRasterPos4sv (const GLshort *v);
WINGDIAPI void APIENTRY glReadBuffer (GLenum mode);
WINGDIAPI void APIENTRY glReadPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels);
WINGDIAPI void APIENTRY glRectd (GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2);
WINGDIAPI void APIENTRY glRectdv (const GLdouble *v1, const GLdouble *v2);
WINGDIAPI void APIENTRY glRectf (GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2);
WINGDIAPI void APIENTRY glRectfv (const GLfloat *v1, const GLfloat *v2);
WINGDIAPI void APIENTRY glRecti (GLint x1, GLint y1, GLint x2, GLint y2);
WINGDIAPI void APIENTRY glRectiv (const GLint *v1, const GLint *v2);
WINGDIAPI void APIENTRY glRects (GLshort x1, GLshort y1, GLshort x2, GLshort y2);
WINGDIAPI void APIENTRY glRectsv (const GLshort *v1, const GLshort *v2);
WINGDIAPI GLint APIENTRY glRenderMode (GLenum mode);
WINGDIAPI void APIENTRY glRotated (GLdouble angle, GLdouble x, GLdouble y, GLdouble z);
WINGDIAPI void APIENTRY glRotatef (GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
WINGDIAPI void APIENTRY glScaled (GLdouble x, GLdouble y, GLdouble z);
WINGDIAPI void APIENTRY glScalef (GLfloat x, GLfloat y, GLfloat z);
WINGDIAPI void APIENTRY glScissor (GLint x, GLint y, GLsizei width, GLsizei height);
WINGDIAPI void APIENTRY glSelectBuffer (GLsizei size, GLuint *buffer);
WINGDIAPI void APIENTRY glShadeModel (GLenum mode);
WINGDIAPI void APIENTRY glStencilFunc (GLenum func, GLint ref, GLuint mask);
WINGDIAPI void APIENTRY glStencilMask (GLuint mask);
WINGDIAPI void APIENTRY glStencilOp (GLenum fail, GLenum zfail, GLenum zpass);
WINGDIAPI void APIENTRY glTexCoord1d (GLdouble s);
WINGDIAPI void APIENTRY glTexCoord1dv (const GLdouble *v);
WINGDIAPI void APIENTRY glTexCoord1f (GLfloat s);
WINGDIAPI void APIENTRY glTexCoord1fv (const GLfloat *v);
WINGDIAPI void APIENTRY glTexCoord1i (GLint s);
WINGDIAPI void APIENTRY glTexCoord1iv (const GLint *v);
WINGDIAPI void APIENTRY glTexCoord1s (GLshort s);
WINGDIAPI void APIENTRY glTexCoord1sv (const GLshort *v);
WINGDIAPI void APIENTRY glTexCoord2d (GLdouble s, GLdouble t);
WINGDIAPI void APIENTRY glTexCoord2dv (const GLdouble *v);
WINGDIAPI void APIENTRY glTexCoord2f (GLfloat s, GLfloat t);
WINGDIAPI void APIENTRY glTexCoord2fv (const GLfloat *v);
WINGDIAPI void APIENTRY glTexCoord2i (GLint s, GLint t);
WINGDIAPI void APIENTRY glTexCoord2iv (const GLint *v);
WINGDIAPI void APIENTRY glTexCoord2s (GLshort s, GLshort t);
WINGDIAPI void APIENTRY glTexCoord2sv (const GLshort *v);
WINGDIAPI void APIENTRY glTexCoord3d (GLdouble s, GLdouble t, GLdouble r);
WINGDIAPI void APIENTRY glTexCoord3dv (const GLdouble *v);
WINGDIAPI void APIENTRY glTexCoord3f (GLfloat s, GLfloat t, GLfloat r);
WINGDIAPI void APIENTRY glTexCoord3fv (const GLfloat *v);
WINGDIAPI void APIENTRY glTexCoord3i (GLint s, GLint t, GLint r);
WINGDIAPI void APIENTRY glTexCoord3iv (const GLint *v);
WINGDIAPI void APIENTRY glTexCoord3s (GLshort s, GLshort t, GLshort r);
WINGDIAPI void APIENTRY glTexCoord3sv (const GLshort *v);
WINGDIAPI void APIENTRY glTexCoord4d (GLdouble s, GLdouble t, GLdouble r, GLdouble q);
WINGDIAPI void APIENTRY glTexCoord4dv (const GLdouble *v);
WINGDIAPI void APIENTRY glTexCoord4f (GLfloat s, GLfloat t, GLfloat r, GLfloat q);
WINGDIAPI void APIENTRY glTexCoord4fv (const GLfloat *v);
WINGDIAPI void APIENTRY glTexCoord4i (GLint s, GLint t, GLint r, GLint q);
WINGDIAPI void APIENTRY glTexCoord4iv (const GLint *v);
WINGDIAPI void APIENTRY glTexCoord4s (GLshort s, GLshort t, GLshort r, GLshort q);
WINGDIAPI void APIENTRY glTexCoord4sv (const GLshort *v);
WINGDIAPI void APIENTRY glTexCoordPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
WINGDIAPI void APIENTRY glTexEnvf (GLenum target, GLenum pname, GLfloat param);
WINGDIAPI void APIENTRY glTexEnvfv (GLenum target, GLenum pname, const GLfloat *params);
WINGDIAPI void APIENTRY glTexEnvi (GLenum target, GLenum pname, GLint param);
WINGDIAPI void APIENTRY glTexEnviv (GLenum target, GLenum pname, const GLint *params);
WINGDIAPI void APIENTRY glTexGend (GLenum coord, GLenum pname, GLdouble param);
WINGDIAPI void APIENTRY glTexGendv (GLenum coord, GLenum pname, const GLdouble *params);
WINGDIAPI void APIENTRY glTexGenf (GLenum coord, GLenum pname, GLfloat param);
WINGDIAPI void APIENTRY glTexGenfv (GLenum coord, GLenum pname, const GLfloat *params);
WINGDIAPI void APIENTRY glTexGeni (GLenum coord, GLenum pname, GLint param);
WINGDIAPI void APIENTRY glTexGeniv (GLenum coord, GLenum pname, const GLint *params);
WINGDIAPI void APIENTRY glTexImage1D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
WINGDIAPI void APIENTRY glTexImage2D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
WINGDIAPI void APIENTRY glTexParameterf (GLenum target, GLenum pname, GLfloat param);
WINGDIAPI void APIENTRY glTexParameterfv (GLenum target, GLenum pname, const GLfloat *params);
WINGDIAPI void APIENTRY glTexParameteri (GLenum target, GLenum pname, GLint param);
WINGDIAPI void APIENTRY glTexParameteriv (GLenum target, GLenum pname, const GLint *params);
WINGDIAPI void APIENTRY glTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels);
WINGDIAPI void APIENTRY glTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
WINGDIAPI void APIENTRY glTranslated (GLdouble x, GLdouble y, GLdouble z);
WINGDIAPI void APIENTRY glTranslatef (GLfloat x, GLfloat y, GLfloat z);
WINGDIAPI void APIENTRY glVertex2d (GLdouble x, GLdouble y);
WINGDIAPI void APIENTRY glVertex2dv (const GLdouble *v);
WINGDIAPI void APIENTRY glVertex2f (GLfloat x, GLfloat y);
WINGDIAPI void APIENTRY glVertex2fv (const GLfloat *v);
WINGDIAPI void APIENTRY glVertex2i (GLint x, GLint y);
WINGDIAPI void APIENTRY glVertex2iv (const GLint *v);
WINGDIAPI void APIENTRY glVertex2s (GLshort x, GLshort y);
WINGDIAPI void APIENTRY glVertex2sv (const GLshort *v);
WINGDIAPI void APIENTRY glVertex3d (GLdouble x, GLdouble y, GLdouble z);
WINGDIAPI void APIENTRY glVertex3dv (const GLdouble *v);
WINGDIAPI void APIENTRY glVertex3f (GLfloat x, GLfloat y, GLfloat z);
WINGDIAPI void APIENTRY glVertex3fv (const GLfloat *v);
WINGDIAPI void APIENTRY glVertex3i (GLint x, GLint y, GLint z);
WINGDIAPI void APIENTRY glVertex3iv (const GLint *v);
WINGDIAPI void APIENTRY glVertex3s (GLshort x, GLshort y, GLshort z);
WINGDIAPI void APIENTRY glVertex3sv (const GLshort *v);
WINGDIAPI void APIENTRY glVertex4d (GLdouble x, GLdouble y, GLdouble z, GLdouble w);
WINGDIAPI void APIENTRY glVertex4dv (const GLdouble *v);
WINGDIAPI void APIENTRY glVertex4f (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
WINGDIAPI void APIENTRY glVertex4fv (const GLfloat *v);
WINGDIAPI void APIENTRY glVertex4i (GLint x, GLint y, GLint z, GLint w);
WINGDIAPI void APIENTRY glVertex4iv (const GLint *v);
WINGDIAPI void APIENTRY glVertex4s (GLshort x, GLshort y, GLshort z, GLshort w);
WINGDIAPI void APIENTRY glVertex4sv (const GLshort *v);
WINGDIAPI void APIENTRY glVertexPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
WINGDIAPI void APIENTRY glViewport (GLint x, GLint y, GLsizei width, GLsizei height);

/* EXT_vertex_array */
typedef void (APIENTRY * PFNGLARRAYELEMENTEXTPROC) (GLint i);
typedef void (APIENTRY * PFNGLDRAWARRAYSEXTPROC) (GLenum mode, GLint first, GLsizei count);
typedef void (APIENTRY * PFNGLVERTEXPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
typedef void (APIENTRY * PFNGLNORMALPOINTEREXTPROC) (GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
typedef void (APIENTRY * PFNGLCOLORPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
typedef void (APIENTRY * PFNGLINDEXPOINTEREXTPROC) (GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
typedef void (APIENTRY * PFNGLTEXCOORDPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
typedef void (APIENTRY * PFNGLEDGEFLAGPOINTEREXTPROC) (GLsizei stride, GLsizei count, const GLboolean *pointer);
typedef void (APIENTRY * PFNGLGETPOINTERVEXTPROC) (GLenum pname, GLvoid* *params);
typedef void (APIENTRY * PFNGLARRAYELEMENTARRAYEXTPROC)(GLenum mode, GLsizei count, const GLvoid* pi);

/* WIN_draw_range_elements */
typedef void (APIENTRY * PFNGLDRAWRANGEELEMENTSWINPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices);

/* WIN_swap_hint */
typedef void (APIENTRY * PFNGLADDSWAPHINTRECTWINPROC)  (GLint x, GLint y, GLsizei width, GLsizei height);

/* EXT_paletted_texture */
typedef void (APIENTRY * PFNGLCOLORTABLEEXTPROC)
    (GLenum target, GLenum internalFormat, GLsizei width, GLenum format,
     GLenum type, const GLvoid *data);
typedef void (APIENTRY * PFNGLCOLORSUBTABLEEXTPROC)
    (GLenum target, GLsizei start, GLsizei count, GLenum format,
     GLenum type, const GLvoid *data);
typedef void (APIENTRY * PFNGLGETCOLORTABLEEXTPROC)
    (GLenum target, GLenum format, GLenum type, GLvoid *data);
typedef void (APIENTRY * PFNGLGETCOLORTABLEPARAMETERIVEXTPROC)
    (GLenum target, GLenum pname, GLint *params);
typedef void (APIENTRY * PFNGLGETCOLORTABLEPARAMETERFVEXTPROC)
    (GLenum target, GLenum pname, GLfloat *params);

#endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
#pragma endregion

#ifdef __cplusplus
}
#endif

#endif /* __GL_H__ */
#endif /* __gl_h_ */

```

`sakura/libs/opengl/gl3w.cpp`:

```cpp
#include "gl3w.h"

#ifdef _MSC_VER
#pragma warning (disable: 4055) // warning C4055: 'type cast' : from data pointer 'void *' to function pointer
#pragma warning (disable: 4152) // warning C4152: nonstandard extension, function/data pointer conversion in expression
#endif

#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN 1
#include <windows.h>

static HMODULE libgl;

static void open_libgl(void)
{
	libgl = LoadLibraryA("opengl32.dll");
}

static void close_libgl(void)
{
	FreeLibrary(libgl);
}

static void *get_proc(const char *proc)
{
	void *res;

	res = wglGetProcAddress(proc);
	if (!res)
		res = GetProcAddress(libgl, proc);
	return res;
}
#elif defined(__APPLE__) || defined(__APPLE_CC__)
#include <Carbon/Carbon.h>

CFBundleRef bundle;
CFURLRef bundleURL;

static void open_libgl(void)
{
	bundleURL = CFURLCreateWithFileSystemPath(kCFAllocatorDefault,
		CFSTR("/System/Library/Frameworks/OpenGL.framework"),
		kCFURLPOSIXPathStyle, true);

	bundle = CFBundleCreate(kCFAllocatorDefault, bundleURL);
	assert(bundle != NULL);
}

static void close_libgl(void)
{
	CFRelease(bundle);
	CFRelease(bundleURL);
}

static void *get_proc(const char *proc)
{
	void *res;

	CFStringRef procname = CFStringCreateWithCString(kCFAllocatorDefault, proc,
		kCFStringEncodingASCII);
	res = CFBundleGetFunctionPointerForName(bundle, procname);
	CFRelease(procname);
	return res;
}
#else
#include <dlfcn.h>
#include <GL/glx.h>

static void *libgl;

static void open_libgl(void)
{
	libgl = dlopen("libGL.so.1", RTLD_LAZY | RTLD_GLOBAL);
}

static void close_libgl(void)
{
	dlclose(libgl);
}

static void *get_proc(const char *proc)
{
	void *res;

	res = (void*)glXGetProcAddress((const GLubyte *)proc);
	if (!res)
		res = dlsym(libgl, proc);
	return res;
}
#endif

static struct {
	int major, minor;
} version;

static int parse_version(void)
{
	if (!glGetIntegerv)
		return -1;

	glGetIntegerv(GL_MAJOR_VERSION, &version.major);
	glGetIntegerv(GL_MINOR_VERSION, &version.minor);

	if (version.major < 3)
		return -1;
	return 0;
}

static void load_procs(void);

int gl3wInit(void)
{
	open_libgl();
	load_procs();
	close_libgl();
	return parse_version();
}

int gl3wIsSupported(int major, int minor)
{
	if (major < 3)
		return 0;
	if (version.major == major)
		return version.minor >= minor;
	return version.major >= major;
}

void *gl3wGetProcAddress(const char *proc)
{
	return get_proc(proc);
}

PFNGLCULLFACEPROC gl3wCullFace;
PFNGLFRONTFACEPROC gl3wFrontFace;
PFNGLHINTPROC gl3wHint;
PFNGLLINEWIDTHPROC gl3wLineWidth;
PFNGLPOINTSIZEPROC gl3wPointSize;
PFNGLPOLYGONMODEPROC gl3wPolygonMode;
PFNGLSCISSORPROC gl3wScissor;
PFNGLTEXPARAMETERFPROC gl3wTexParameterf;
PFNGLTEXPARAMETERFVPROC gl3wTexParameterfv;
PFNGLTEXPARAMETERIPROC gl3wTexParameteri;
PFNGLTEXPARAMETERIVPROC gl3wTexParameteriv;
PFNGLTEXIMAGE1DPROC gl3wTexImage1D;
PFNGLTEXIMAGE2DPROC gl3wTexImage2D;
PFNGLDRAWBUFFERPROC gl3wDrawBuffer;
PFNGLCLEARPROC gl3wClear;
PFNGLCLEARCOLORPROC gl3wClearColor;
PFNGLCLEARSTENCILPROC gl3wClearStencil;
PFNGLCLEARDEPTHPROC gl3wClearDepth;
PFNGLSTENCILMASKPROC gl3wStencilMask;
PFNGLCOLORMASKPROC gl3wColorMask;
PFNGLDEPTHMASKPROC gl3wDepthMask;
PFNGLDISABLEPROC gl3wDisable;
PFNGLENABLEPROC gl3wEnable;
PFNGLFINISHPROC gl3wFinish;
PFNGLFLUSHPROC gl3wFlush;
PFNGLBLENDFUNCPROC gl3wBlendFunc;
PFNGLLOGICOPPROC gl3wLogicOp;
PFNGLSTENCILFUNCPROC gl3wStencilFunc;
PFNGLSTENCILOPPROC gl3wStencilOp;
PFNGLDEPTHFUNCPROC gl3wDepthFunc;
PFNGLPIXELSTOREFPROC gl3wPixelStoref;
PFNGLPIXELSTOREIPROC gl3wPixelStorei;
PFNGLREADBUFFERPROC gl3wReadBuffer;
PFNGLREADPIXELSPROC gl3wReadPixels;
PFNGLGETBOOLEANVPROC gl3wGetBooleanv;
PFNGLGETDOUBLEVPROC gl3wGetDoublev;
PFNGLGETERRORPROC gl3wGetError;
PFNGLGETFLOATVPROC gl3wGetFloatv;
PFNGLGETINTEGERVPROC gl3wGetIntegerv;
PFNGLGETSTRINGPROC gl3wGetString;
PFNGLGETTEXIMAGEPROC gl3wGetTexImage;
PFNGLGETTEXPARAMETERFVPROC gl3wGetTexParameterfv;
PFNGLGETTEXPARAMETERIVPROC gl3wGetTexParameteriv;
PFNGLGETTEXLEVELPARAMETERFVPROC gl3wGetTexLevelParameterfv;
PFNGLGETTEXLEVELPARAMETERIVPROC gl3wGetTexLevelParameteriv;
PFNGLISENABLEDPROC gl3wIsEnabled;
PFNGLDEPTHRANGEPROC gl3wDepthRange;
PFNGLVIEWPORTPROC gl3wViewport;
PFNGLDRAWARRAYSPROC gl3wDrawArrays;
PFNGLDRAWELEMENTSPROC gl3wDrawElements;
PFNGLGETPOINTERVPROC gl3wGetPointerv;
PFNGLPOLYGONOFFSETPROC gl3wPolygonOffset;
PFNGLCOPYTEXIMAGE1DPROC gl3wCopyTexImage1D;
PFNGLCOPYTEXIMAGE2DPROC gl3wCopyTexImage2D;
PFNGLCOPYTEXSUBIMAGE1DPROC gl3wCopyTexSubImage1D;
PFNGLCOPYTEXSUBIMAGE2DPROC gl3wCopyTexSubImage2D;
PFNGLTEXSUBIMAGE1DPROC gl3wTexSubImage1D;
PFNGLTEXSUBIMAGE2DPROC gl3wTexSubImage2D;
PFNGLBINDTEXTUREPROC gl3wBindTexture;
PFNGLDELETETEXTURESPROC gl3wDeleteTextures;
PFNGLGENTEXTURESPROC gl3wGenTextures;
PFNGLISTEXTUREPROC gl3wIsTexture;
PFNGLBLENDCOLORPROC gl3wBlendColor;
PFNGLBLENDEQUATIONPROC gl3wBlendEquation;
PFNGLDRAWRANGEELEMENTSPROC gl3wDrawRangeElements;
PFNGLTEXIMAGE3DPROC gl3wTexImage3D;
PFNGLTEXSUBIMAGE3DPROC gl3wTexSubImage3D;
PFNGLCOPYTEXSUBIMAGE3DPROC gl3wCopyTexSubImage3D;
PFNGLACTIVETEXTUREPROC gl3wActiveTexture;
PFNGLSAMPLECOVERAGEPROC gl3wSampleCoverage;
PFNGLCOMPRESSEDTEXIMAGE3DPROC gl3wCompressedTexImage3D;
PFNGLCOMPRESSEDTEXIMAGE2DPROC gl3wCompressedTexImage2D;
PFNGLCOMPRESSEDTEXIMAGE1DPROC gl3wCompressedTexImage1D;
PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC gl3wCompressedTexSubImage3D;
PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC gl3wCompressedTexSubImage2D;
PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC gl3wCompressedTexSubImage1D;
PFNGLGETCOMPRESSEDTEXIMAGEPROC gl3wGetCompressedTexImage;
PFNGLBLENDFUNCSEPARATEPROC gl3wBlendFuncSeparate;
PFNGLMULTIDRAWARRAYSPROC gl3wMultiDrawArrays;
PFNGLMULTIDRAWELEMENTSPROC gl3wMultiDrawElements;
PFNGLPOINTPARAMETERFPROC gl3wPointParameterf;
PFNGLPOINTPARAMETERFVPROC gl3wPointParameterfv;
PFNGLPOINTPARAMETERIPROC gl3wPointParameteri;
PFNGLPOINTPARAMETERIVPROC gl3wPointParameteriv;
PFNGLGENQUERIESPROC gl3wGenQueries;
PFNGLDELETEQUERIESPROC gl3wDeleteQueries;
PFNGLISQUERYPROC gl3wIsQuery;
PFNGLBEGINQUERYPROC gl3wBeginQuery;
PFNGLENDQUERYPROC gl3wEndQuery;
PFNGLGETQUERYIVPROC gl3wGetQueryiv;
PFNGLGETQUERYOBJECTIVPROC gl3wGetQueryObjectiv;
PFNGLGETQUERYOBJECTUIVPROC gl3wGetQueryObjectuiv;
PFNGLBINDBUFFERPROC gl3wBindBuffer;
PFNGLDELETEBUFFERSPROC gl3wDeleteBuffers;
PFNGLGENBUFFERSPROC gl3wGenBuffers;
PFNGLISBUFFERPROC gl3wIsBuffer;
PFNGLBUFFERDATAPROC gl3wBufferData;
PFNGLBUFFERSUBDATAPROC gl3wBufferSubData;
PFNGLGETBUFFERSUBDATAPROC gl3wGetBufferSubData;
PFNGLMAPBUFFERPROC gl3wMapBuffer;
PFNGLUNMAPBUFFERPROC gl3wUnmapBuffer;
PFNGLGETBUFFERPARAMETERIVPROC gl3wGetBufferParameteriv;
PFNGLGETBUFFERPOINTERVPROC gl3wGetBufferPointerv;
PFNGLBLENDEQUATIONSEPARATEPROC gl3wBlendEquationSeparate;
PFNGLDRAWBUFFERSPROC gl3wDrawBuffers;
PFNGLSTENCILOPSEPARATEPROC gl3wStencilOpSeparate;
PFNGLSTENCILFUNCSEPARATEPROC gl3wStencilFuncSeparate;
PFNGLSTENCILMASKSEPARATEPROC gl3wStencilMaskSeparate;
PFNGLATTACHSHADERPROC gl3wAttachShader;
PFNGLBINDATTRIBLOCATIONPROC gl3wBindAttribLocation;
PFNGLCOMPILESHADERPROC gl3wCompileShader;
PFNGLCREATEPROGRAMPROC gl3wCreateProgram;
PFNGLCREATESHADERPROC gl3wCreateShader;
PFNGLDELETEPROGRAMPROC gl3wDeleteProgram;
PFNGLDELETESHADERPROC gl3wDeleteShader;
PFNGLDETACHSHADERPROC gl3wDetachShader;
PFNGLDISABLEVERTEXATTRIBARRAYPROC gl3wDisableVertexAttribArray;
PFNGLENABLEVERTEXATTRIBARRAYPROC gl3wEnableVertexAttribArray;
PFNGLGETACTIVEATTRIBPROC gl3wGetActiveAttrib;
PFNGLGETACTIVEUNIFORMPROC gl3wGetActiveUniform;
PFNGLGETATTACHEDSHADERSPROC gl3wGetAttachedShaders;
PFNGLGETATTRIBLOCATIONPROC gl3wGetAttribLocation;
PFNGLGETPROGRAMIVPROC gl3wGetProgramiv;
PFNGLGETPROGRAMINFOLOGPROC gl3wGetProgramInfoLog;
PFNGLGETSHADERIVPROC gl3wGetShaderiv;
PFNGLGETSHADERINFOLOGPROC gl3wGetShaderInfoLog;
PFNGLGETSHADERSOURCEPROC gl3wGetShaderSource;
PFNGLGETUNIFORMLOCATIONPROC gl3wGetUniformLocation;
PFNGLGETUNIFORMFVPROC gl3wGetUniformfv;
PFNGLGETUNIFORMIVPROC gl3wGetUniformiv;
PFNGLGETVERTEXATTRIBDVPROC gl3wGetVertexAttribdv;
PFNGLGETVERTEXATTRIBFVPROC gl3wGetVertexAttribfv;
PFNGLGETVERTEXATTRIBIVPROC gl3wGetVertexAttribiv;
PFNGLGETVERTEXATTRIBPOINTERVPROC gl3wGetVertexAttribPointerv;
PFNGLISPROGRAMPROC gl3wIsProgram;
PFNGLISSHADERPROC gl3wIsShader;
PFNGLLINKPROGRAMPROC gl3wLinkProgram;
PFNGLSHADERSOURCEPROC gl3wShaderSource;
PFNGLUSEPROGRAMPROC gl3wUseProgram;
PFNGLUNIFORM1FPROC gl3wUniform1f;
PFNGLUNIFORM2FPROC gl3wUniform2f;
PFNGLUNIFORM3FPROC gl3wUniform3f;
PFNGLUNIFORM4FPROC gl3wUniform4f;
PFNGLUNIFORM1IPROC gl3wUniform1i;
PFNGLUNIFORM2IPROC gl3wUniform2i;
PFNGLUNIFORM3IPROC gl3wUniform3i;
PFNGLUNIFORM4IPROC gl3wUniform4i;
PFNGLUNIFORM1FVPROC gl3wUniform1fv;
PFNGLUNIFORM2FVPROC gl3wUniform2fv;
PFNGLUNIFORM3FVPROC gl3wUniform3fv;
PFNGLUNIFORM4FVPROC gl3wUniform4fv;
PFNGLUNIFORM1IVPROC gl3wUniform1iv;
PFNGLUNIFORM2IVPROC gl3wUniform2iv;
PFNGLUNIFORM3IVPROC gl3wUniform3iv;
PFNGLUNIFORM4IVPROC gl3wUniform4iv;
PFNGLUNIFORMMATRIX2FVPROC gl3wUniformMatrix2fv;
PFNGLUNIFORMMATRIX3FVPROC gl3wUniformMatrix3fv;
PFNGLUNIFORMMATRIX4FVPROC gl3wUniformMatrix4fv;
PFNGLVALIDATEPROGRAMPROC gl3wValidateProgram;
PFNGLVERTEXATTRIB1DPROC gl3wVertexAttrib1d;
PFNGLVERTEXATTRIB1DVPROC gl3wVertexAttrib1dv;
PFNGLVERTEXATTRIB1FPROC gl3wVertexAttrib1f;
PFNGLVERTEXATTRIB1FVPROC gl3wVertexAttrib1fv;
PFNGLVERTEXATTRIB1SPROC gl3wVertexAttrib1s;
PFNGLVERTEXATTRIB1SVPROC gl3wVertexAttrib1sv;
PFNGLVERTEXATTRIB2DPROC gl3wVertexAttrib2d;
PFNGLVERTEXATTRIB2DVPROC gl3wVertexAttrib2dv;
PFNGLVERTEXATTRIB2FPROC gl3wVertexAttrib2f;
PFNGLVERTEXATTRIB2FVPROC gl3wVertexAttrib2fv;
PFNGLVERTEXATTRIB2SPROC gl3wVertexAttrib2s;
PFNGLVERTEXATTRIB2SVPROC gl3wVertexAttrib2sv;
PFNGLVERTEXATTRIB3DPROC gl3wVertexAttrib3d;
PFNGLVERTEXATTRIB3DVPROC gl3wVertexAttrib3dv;
PFNGLVERTEXATTRIB3FPROC gl3wVertexAttrib3f;
PFNGLVERTEXATTRIB3FVPROC gl3wVertexAttrib3fv;
PFNGLVERTEXATTRIB3SPROC gl3wVertexAttrib3s;
PFNGLVERTEXATTRIB3SVPROC gl3wVertexAttrib3sv;
PFNGLVERTEXATTRIB4NBVPROC gl3wVertexAttrib4Nbv;
PFNGLVERTEXATTRIB4NIVPROC gl3wVertexAttrib4Niv;
PFNGLVERTEXATTRIB4NSVPROC gl3wVertexAttrib4Nsv;
PFNGLVERTEXATTRIB4NUBPROC gl3wVertexAttrib4Nub;
PFNGLVERTEXATTRIB4NUBVPROC gl3wVertexAttrib4Nubv;
PFNGLVERTEXATTRIB4NUIVPROC gl3wVertexAttrib4Nuiv;
PFNGLVERTEXATTRIB4NUSVPROC gl3wVertexAttrib4Nusv;
PFNGLVERTEXATTRIB4BVPROC gl3wVertexAttrib4bv;
PFNGLVERTEXATTRIB4DPROC gl3wVertexAttrib4d;
PFNGLVERTEXATTRIB4DVPROC gl3wVertexAttrib4dv;
PFNGLVERTEXATTRIB4FPROC gl3wVertexAttrib4f;
PFNGLVERTEXATTRIB4FVPROC gl3wVertexAttrib4fv;
PFNGLVERTEXATTRIB4IVPROC gl3wVertexAttrib4iv;
PFNGLVERTEXATTRIB4SPROC gl3wVertexAttrib4s;
PFNGLVERTEXATTRIB4SVPROC gl3wVertexAttrib4sv;
PFNGLVERTEXATTRIB4UBVPROC gl3wVertexAttrib4ubv;
PFNGLVERTEXATTRIB4UIVPROC gl3wVertexAttrib4uiv;
PFNGLVERTEXATTRIB4USVPROC gl3wVertexAttrib4usv;
PFNGLVERTEXATTRIBPOINTERPROC gl3wVertexAttribPointer;
PFNGLUNIFORMMATRIX2X3FVPROC gl3wUniformMatrix2x3fv;
PFNGLUNIFORMMATRIX3X2FVPROC gl3wUniformMatrix3x2fv;
PFNGLUNIFORMMATRIX2X4FVPROC gl3wUniformMatrix2x4fv;
PFNGLUNIFORMMATRIX4X2FVPROC gl3wUniformMatrix4x2fv;
PFNGLUNIFORMMATRIX3X4FVPROC gl3wUniformMatrix3x4fv;
PFNGLUNIFORMMATRIX4X3FVPROC gl3wUniformMatrix4x3fv;
PFNGLCOLORMASKIPROC gl3wColorMaski;
PFNGLGETBOOLEANI_VPROC gl3wGetBooleani_v;
PFNGLGETINTEGERI_VPROC gl3wGetIntegeri_v;
PFNGLENABLEIPROC gl3wEnablei;
PFNGLDISABLEIPROC gl3wDisablei;
PFNGLISENABLEDIPROC gl3wIsEnabledi;
PFNGLBEGINTRANSFORMFEEDBACKPROC gl3wBeginTransformFeedback;
PFNGLENDTRANSFORMFEEDBACKPROC gl3wEndTransformFeedback;
PFNGLBINDBUFFERRANGEPROC gl3wBindBufferRange;
PFNGLBINDBUFFERBASEPROC gl3wBindBufferBase;
PFNGLTRANSFORMFEEDBACKVARYINGSPROC gl3wTransformFeedbackVaryings;
PFNGLGETTRANSFORMFEEDBACKVARYINGPROC gl3wGetTransformFeedbackVarying;
PFNGLCLAMPCOLORPROC gl3wClampColor;
PFNGLBEGINCONDITIONALRENDERPROC gl3wBeginConditionalRender;
PFNGLENDCONDITIONALRENDERPROC gl3wEndConditionalRender;
PFNGLVERTEXATTRIBIPOINTERPROC gl3wVertexAttribIPointer;
PFNGLGETVERTEXATTRIBIIVPROC gl3wGetVertexAttribIiv;
PFNGLGETVERTEXATTRIBIUIVPROC gl3wGetVertexAttribIuiv;
PFNGLVERTEXATTRIBI1IPROC gl3wVertexAttribI1i;
PFNGLVERTEXATTRIBI2IPROC gl3wVertexAttribI2i;
PFNGLVERTEXATTRIBI3IPROC gl3wVertexAttribI3i;
PFNGLVERTEXATTRIBI4IPROC gl3wVertexAttribI4i;
PFNGLVERTEXATTRIBI1UIPROC gl3wVertexAttribI1ui;
PFNGLVERTEXATTRIBI2UIPROC gl3wVertexAttribI2ui;
PFNGLVERTEXATTRIBI3UIPROC gl3wVertexAttribI3ui;
PFNGLVERTEXATTRIBI4UIPROC gl3wVertexAttribI4ui;
PFNGLVERTEXATTRIBI1IVPROC gl3wVertexAttribI1iv;
PFNGLVERTEXATTRIBI2IVPROC gl3wVertexAttribI2iv;
PFNGLVERTEXATTRIBI3IVPROC gl3wVertexAttribI3iv;
PFNGLVERTEXATTRIBI4IVPROC gl3wVertexAttribI4iv;
PFNGLVERTEXATTRIBI1UIVPROC gl3wVertexAttribI1uiv;
PFNGLVERTEXATTRIBI2UIVPROC gl3wVertexAttribI2uiv;
PFNGLVERTEXATTRIBI3UIVPROC gl3wVertexAttribI3uiv;
PFNGLVERTEXATTRIBI4UIVPROC gl3wVertexAttribI4uiv;
PFNGLVERTEXATTRIBI4BVPROC gl3wVertexAttribI4bv;
PFNGLVERTEXATTRIBI4SVPROC gl3wVertexAttribI4sv;
PFNGLVERTEXATTRIBI4UBVPROC gl3wVertexAttribI4ubv;
PFNGLVERTEXATTRIBI4USVPROC gl3wVertexAttribI4usv;
PFNGLGETUNIFORMUIVPROC gl3wGetUniformuiv;
PFNGLBINDFRAGDATALOCATIONPROC gl3wBindFragDataLocation;
PFNGLGETFRAGDATALOCATIONPROC gl3wGetFragDataLocation;
PFNGLUNIFORM1UIPROC gl3wUniform1ui;
PFNGLUNIFORM2UIPROC gl3wUniform2ui;
PFNGLUNIFORM3UIPROC gl3wUniform3ui;
PFNGLUNIFORM4UIPROC gl3wUniform4ui;
PFNGLUNIFORM1UIVPROC gl3wUniform1uiv;
PFNGLUNIFORM2UIVPROC gl3wUniform2uiv;
PFNGLUNIFORM3UIVPROC gl3wUniform3uiv;
PFNGLUNIFORM4UIVPROC gl3wUniform4uiv;
PFNGLTEXPARAMETERIIVPROC gl3wTexParameterIiv;
PFNGLTEXPARAMETERIUIVPROC gl3wTexParameterIuiv;
PFNGLGETTEXPARAMETERIIVPROC gl3wGetTexParameterIiv;
PFNGLGETTEXPARAMETERIUIVPROC gl3wGetTexParameterIuiv;
PFNGLCLEARBUFFERIVPROC gl3wClearBufferiv;
PFNGLCLEARBUFFERUIVPROC gl3wClearBufferuiv;
PFNGLCLEARBUFFERFVPROC gl3wClearBufferfv;
PFNGLCLEARBUFFERFIPROC gl3wClearBufferfi;
PFNGLGETSTRINGIPROC gl3wGetStringi;
PFNGLDRAWARRAYSINSTANCEDPROC gl3wDrawArraysInstanced;
PFNGLDRAWELEMENTSINSTANCEDPROC gl3wDrawElementsInstanced;
PFNGLTEXBUFFERPROC gl3wTexBuffer;
PFNGLPRIMITIVERESTARTINDEXPROC gl3wPrimitiveRestartIndex;
PFNGLGETINTEGER64I_VPROC gl3wGetInteger64i_v;
PFNGLGETBUFFERPARAMETERI64VPROC gl3wGetBufferParameteri64v;
PFNGLFRAMEBUFFERTEXTUREPROC gl3wFramebufferTexture;
PFNGLVERTEXATTRIBDIVISORPROC gl3wVertexAttribDivisor;
PFNGLMINSAMPLESHADINGPROC gl3wMinSampleShading;
PFNGLBLENDEQUATIONIPROC gl3wBlendEquationi;
PFNGLBLENDEQUATIONSEPARATEIPROC gl3wBlendEquationSeparatei;
PFNGLBLENDFUNCIPROC gl3wBlendFunci;
PFNGLBLENDFUNCSEPARATEIPROC gl3wBlendFuncSeparatei;
PFNGLISRENDERBUFFERPROC gl3wIsRenderbuffer;
PFNGLBINDRENDERBUFFERPROC gl3wBindRenderbuffer;
PFNGLDELETERENDERBUFFERSPROC gl3wDeleteRenderbuffers;
PFNGLGENRENDERBUFFERSPROC gl3wGenRenderbuffers;
PFNGLRENDERBUFFERSTORAGEPROC gl3wRenderbufferStorage;
PFNGLGETRENDERBUFFERPARAMETERIVPROC gl3wGetRenderbufferParameteriv;
PFNGLISFRAMEBUFFERPROC gl3wIsFramebuffer;
PFNGLBINDFRAMEBUFFERPROC gl3wBindFramebuffer;
PFNGLDELETEFRAMEBUFFERSPROC gl3wDeleteFramebuffers;
PFNGLGENFRAMEBUFFERSPROC gl3wGenFramebuffers;
PFNGLCHECKFRAMEBUFFERSTATUSPROC gl3wCheckFramebufferStatus;
PFNGLFRAMEBUFFERTEXTURE1DPROC gl3wFramebufferTexture1D;
PFNGLFRAMEBUFFERTEXTURE2DPROC gl3wFramebufferTexture2D;
PFNGLFRAMEBUFFERTEXTURE3DPROC gl3wFramebufferTexture3D;
PFNGLFRAMEBUFFERRENDERBUFFERPROC gl3wFramebufferRenderbuffer;
PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC gl3wGetFramebufferAttachmentParameteriv;
PFNGLGENERATEMIPMAPPROC gl3wGenerateMipmap;
PFNGLBLITFRAMEBUFFERPROC gl3wBlitFramebuffer;
PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC gl3wRenderbufferStorageMultisample;
PFNGLFRAMEBUFFERTEXTURELAYERPROC gl3wFramebufferTextureLayer;
PFNGLMAPBUFFERRANGEPROC gl3wMapBufferRange;
PFNGLFLUSHMAPPEDBUFFERRANGEPROC gl3wFlushMappedBufferRange;
PFNGLBINDVERTEXARRAYPROC gl3wBindVertexArray;
PFNGLDELETEVERTEXARRAYSPROC gl3wDeleteVertexArrays;
PFNGLGENVERTEXARRAYSPROC gl3wGenVertexArrays;
PFNGLISVERTEXARRAYPROC gl3wIsVertexArray;
PFNGLGETUNIFORMINDICESPROC gl3wGetUniformIndices;
PFNGLGETACTIVEUNIFORMSIVPROC gl3wGetActiveUniformsiv;
PFNGLGETACTIVEUNIFORMNAMEPROC gl3wGetActiveUniformName;
PFNGLGETUNIFORMBLOCKINDEXPROC gl3wGetUniformBlockIndex;
PFNGLGETACTIVEUNIFORMBLOCKIVPROC gl3wGetActiveUniformBlockiv;
PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC gl3wGetActiveUniformBlockName;
PFNGLUNIFORMBLOCKBINDINGPROC gl3wUniformBlockBinding;
PFNGLCOPYBUFFERSUBDATAPROC gl3wCopyBufferSubData;
PFNGLDRAWELEMENTSBASEVERTEXPROC gl3wDrawElementsBaseVertex;
PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC gl3wDrawRangeElementsBaseVertex;
PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC gl3wDrawElementsInstancedBaseVertex;
PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC gl3wMultiDrawElementsBaseVertex;
PFNGLPROVOKINGVERTEXPROC gl3wProvokingVertex;
PFNGLFENCESYNCPROC gl3wFenceSync;
PFNGLISSYNCPROC gl3wIsSync;
PFNGLDELETESYNCPROC gl3wDeleteSync;
PFNGLCLIENTWAITSYNCPROC gl3wClientWaitSync;
PFNGLWAITSYNCPROC gl3wWaitSync;
PFNGLGETINTEGER64VPROC gl3wGetInteger64v;
PFNGLGETSYNCIVPROC gl3wGetSynciv;
PFNGLTEXIMAGE2DMULTISAMPLEPROC gl3wTexImage2DMultisample;
PFNGLTEXIMAGE3DMULTISAMPLEPROC gl3wTexImage3DMultisample;
PFNGLGETMULTISAMPLEFVPROC gl3wGetMultisamplefv;
PFNGLSAMPLEMASKIPROC gl3wSampleMaski;
PFNGLBLENDEQUATIONIARBPROC gl3wBlendEquationiARB;
PFNGLBLENDEQUATIONSEPARATEIARBPROC gl3wBlendEquationSeparateiARB;
PFNGLBLENDFUNCIARBPROC gl3wBlendFunciARB;
PFNGLBLENDFUNCSEPARATEIARBPROC gl3wBlendFuncSeparateiARB;
PFNGLMINSAMPLESHADINGARBPROC gl3wMinSampleShadingARB;
PFNGLNAMEDSTRINGARBPROC gl3wNamedStringARB;
PFNGLDELETENAMEDSTRINGARBPROC gl3wDeleteNamedStringARB;
PFNGLCOMPILESHADERINCLUDEARBPROC gl3wCompileShaderIncludeARB;
PFNGLISNAMEDSTRINGARBPROC gl3wIsNamedStringARB;
PFNGLGETNAMEDSTRINGARBPROC gl3wGetNamedStringARB;
PFNGLGETNAMEDSTRINGIVARBPROC gl3wGetNamedStringivARB;
PFNGLBINDFRAGDATALOCATIONINDEXEDPROC gl3wBindFragDataLocationIndexed;
PFNGLGETFRAGDATAINDEXPROC gl3wGetFragDataIndex;
PFNGLGENSAMPLERSPROC gl3wGenSamplers;
PFNGLDELETESAMPLERSPROC gl3wDeleteSamplers;
PFNGLISSAMPLERPROC gl3wIsSampler;
PFNGLBINDSAMPLERPROC gl3wBindSampler;
PFNGLSAMPLERPARAMETERIPROC gl3wSamplerParameteri;
PFNGLSAMPLERPARAMETERIVPROC gl3wSamplerParameteriv;
PFNGLSAMPLERPARAMETERFPROC gl3wSamplerParameterf;
PFNGLSAMPLERPARAMETERFVPROC gl3wSamplerParameterfv;
PFNGLSAMPLERPARAMETERIIVPROC gl3wSamplerParameterIiv;
PFNGLSAMPLERPARAMETERIUIVPROC gl3wSamplerParameterIuiv;
PFNGLGETSAMPLERPARAMETERIVPROC gl3wGetSamplerParameteriv;
PFNGLGETSAMPLERPARAMETERIIVPROC gl3wGetSamplerParameterIiv;
PFNGLGETSAMPLERPARAMETERFVPROC gl3wGetSamplerParameterfv;
PFNGLGETSAMPLERPARAMETERIUIVPROC gl3wGetSamplerParameterIuiv;
PFNGLQUERYCOUNTERPROC gl3wQueryCounter;
PFNGLGETQUERYOBJECTI64VPROC gl3wGetQueryObjecti64v;
PFNGLGETQUERYOBJECTUI64VPROC gl3wGetQueryObjectui64v;
PFNGLVERTEXP2UIPROC gl3wVertexP2ui;
PFNGLVERTEXP2UIVPROC gl3wVertexP2uiv;
PFNGLVERTEXP3UIPROC gl3wVertexP3ui;
PFNGLVERTEXP3UIVPROC gl3wVertexP3uiv;
PFNGLVERTEXP4UIPROC gl3wVertexP4ui;
PFNGLVERTEXP4UIVPROC gl3wVertexP4uiv;
PFNGLTEXCOORDP1UIPROC gl3wTexCoordP1ui;
PFNGLTEXCOORDP1UIVPROC gl3wTexCoordP1uiv;
PFNGLTEXCOORDP2UIPROC gl3wTexCoordP2ui;
PFNGLTEXCOORDP2UIVPROC gl3wTexCoordP2uiv;
PFNGLTEXCOORDP3UIPROC gl3wTexCoordP3ui;
PFNGLTEXCOORDP3UIVPROC gl3wTexCoordP3uiv;
PFNGLTEXCOORDP4UIPROC gl3wTexCoordP4ui;
PFNGLTEXCOORDP4UIVPROC gl3wTexCoordP4uiv;
PFNGLMULTITEXCOORDP1UIPROC gl3wMultiTexCoordP1ui;
PFNGLMULTITEXCOORDP1UIVPROC gl3wMultiTexCoordP1uiv;
PFNGLMULTITEXCOORDP2UIPROC gl3wMultiTexCoordP2ui;
PFNGLMULTITEXCOORDP2UIVPROC gl3wMultiTexCoordP2uiv;
PFNGLMULTITEXCOORDP3UIPROC gl3wMultiTexCoordP3ui;
PFNGLMULTITEXCOORDP3UIVPROC gl3wMultiTexCoordP3uiv;
PFNGLMULTITEXCOORDP4UIPROC gl3wMultiTexCoordP4ui;
PFNGLMULTITEXCOORDP4UIVPROC gl3wMultiTexCoordP4uiv;
PFNGLNORMALP3UIPROC gl3wNormalP3ui;
PFNGLNORMALP3UIVPROC gl3wNormalP3uiv;
PFNGLCOLORP3UIPROC gl3wColorP3ui;
PFNGLCOLORP3UIVPROC gl3wColorP3uiv;
PFNGLCOLORP4UIPROC gl3wColorP4ui;
PFNGLCOLORP4UIVPROC gl3wColorP4uiv;
PFNGLSECONDARYCOLORP3UIPROC gl3wSecondaryColorP3ui;
PFNGLSECONDARYCOLORP3UIVPROC gl3wSecondaryColorP3uiv;
PFNGLVERTEXATTRIBP1UIPROC gl3wVertexAttribP1ui;
PFNGLVERTEXATTRIBP1UIVPROC gl3wVertexAttribP1uiv;
PFNGLVERTEXATTRIBP2UIPROC gl3wVertexAttribP2ui;
PFNGLVERTEXATTRIBP2UIVPROC gl3wVertexAttribP2uiv;
PFNGLVERTEXATTRIBP3UIPROC gl3wVertexAttribP3ui;
PFNGLVERTEXATTRIBP3UIVPROC gl3wVertexAttribP3uiv;
PFNGLVERTEXATTRIBP4UIPROC gl3wVertexAttribP4ui;
PFNGLVERTEXATTRIBP4UIVPROC gl3wVertexAttribP4uiv;
PFNGLDRAWARRAYSINDIRECTPROC gl3wDrawArraysIndirect;
PFNGLDRAWELEMENTSINDIRECTPROC gl3wDrawElementsIndirect;
PFNGLUNIFORM1DPROC gl3wUniform1d;
PFNGLUNIFORM2DPROC gl3wUniform2d;
PFNGLUNIFORM3DPROC gl3wUniform3d;
PFNGLUNIFORM4DPROC gl3wUniform4d;
PFNGLUNIFORM1DVPROC gl3wUniform1dv;
PFNGLUNIFORM2DVPROC gl3wUniform2dv;
PFNGLUNIFORM3DVPROC gl3wUniform3dv;
PFNGLUNIFORM4DVPROC gl3wUniform4dv;
PFNGLUNIFORMMATRIX2DVPROC gl3wUniformMatrix2dv;
PFNGLUNIFORMMATRIX3DVPROC gl3wUniformMatrix3dv;
PFNGLUNIFORMMATRIX4DVPROC gl3wUniformMatrix4dv;
PFNGLUNIFORMMATRIX2X3DVPROC gl3wUniformMatrix2x3dv;
PFNGLUNIFORMMATRIX2X4DVPROC gl3wUniformMatrix2x4dv;
PFNGLUNIFORMMATRIX3X2DVPROC gl3wUniformMatrix3x2dv;
PFNGLUNIFORMMATRIX3X4DVPROC gl3wUniformMatrix3x4dv;
PFNGLUNIFORMMATRIX4X2DVPROC gl3wUniformMatrix4x2dv;
PFNGLUNIFORMMATRIX4X3DVPROC gl3wUniformMatrix4x3dv;
PFNGLGETUNIFORMDVPROC gl3wGetUniformdv;
PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC gl3wGetSubroutineUniformLocation;
PFNGLGETSUBROUTINEINDEXPROC gl3wGetSubroutineIndex;
PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC gl3wGetActiveSubroutineUniformiv;
PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC gl3wGetActiveSubroutineUniformName;
PFNGLGETACTIVESUBROUTINENAMEPROC gl3wGetActiveSubroutineName;
PFNGLUNIFORMSUBROUTINESUIVPROC gl3wUniformSubroutinesuiv;
PFNGLGETUNIFORMSUBROUTINEUIVPROC gl3wGetUniformSubroutineuiv;
PFNGLGETPROGRAMSTAGEIVPROC gl3wGetProgramStageiv;
PFNGLPATCHPARAMETERIPROC gl3wPatchParameteri;
PFNGLPATCHPARAMETERFVPROC gl3wPatchParameterfv;
PFNGLBINDTRANSFORMFEEDBACKPROC gl3wBindTransformFeedback;
PFNGLDELETETRANSFORMFEEDBACKSPROC gl3wDeleteTransformFeedbacks;
PFNGLGENTRANSFORMFEEDBACKSPROC gl3wGenTransformFeedbacks;
PFNGLISTRANSFORMFEEDBACKPROC gl3wIsTransformFeedback;
PFNGLPAUSETRANSFORMFEEDBACKPROC gl3wPauseTransformFeedback;
PFNGLRESUMETRANSFORMFEEDBACKPROC gl3wResumeTransformFeedback;
PFNGLDRAWTRANSFORMFEEDBACKPROC gl3wDrawTransformFeedback;
PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC gl3wDrawTransformFeedbackStream;
PFNGLBEGINQUERYINDEXEDPROC gl3wBeginQueryIndexed;
PFNGLENDQUERYINDEXEDPROC gl3wEndQueryIndexed;
PFNGLGETQUERYINDEXEDIVPROC gl3wGetQueryIndexediv;
PFNGLRELEASESHADERCOMPILERPROC gl3wReleaseShaderCompiler;
PFNGLSHADERBINARYPROC gl3wShaderBinary;
PFNGLGETSHADERPRECISIONFORMATPROC gl3wGetShaderPrecisionFormat;
PFNGLDEPTHRANGEFPROC gl3wDepthRangef;
PFNGLCLEARDEPTHFPROC gl3wClearDepthf;
PFNGLGETPROGRAMBINARYPROC gl3wGetProgramBinary;
PFNGLPROGRAMBINARYPROC gl3wProgramBinary;
PFNGLPROGRAMPARAMETERIPROC gl3wProgramParameteri;
PFNGLUSEPROGRAMSTAGESPROC gl3wUseProgramStages;
PFNGLACTIVESHADERPROGRAMPROC gl3wActiveShaderProgram;
PFNGLCREATESHADERPROGRAMVPROC gl3wCreateShaderProgramv;
PFNGLBINDPROGRAMPIPELINEPROC gl3wBindProgramPipeline;
PFNGLDELETEPROGRAMPIPELINESPROC gl3wDeleteProgramPipelines;
PFNGLGENPROGRAMPIPELINESPROC gl3wGenProgramPipelines;
PFNGLISPROGRAMPIPELINEPROC gl3wIsProgramPipeline;
PFNGLGETPROGRAMPIPELINEIVPROC gl3wGetProgramPipelineiv;
PFNGLPROGRAMUNIFORM1IPROC gl3wProgramUniform1i;
PFNGLPROGRAMUNIFORM1IVPROC gl3wProgramUniform1iv;
PFNGLPROGRAMUNIFORM1FPROC gl3wProgramUniform1f;
PFNGLPROGRAMUNIFORM1FVPROC gl3wProgramUniform1fv;
PFNGLPROGRAMUNIFORM1DPROC gl3wProgramUniform1d;
PFNGLPROGRAMUNIFORM1DVPROC gl3wProgramUniform1dv;
PFNGLPROGRAMUNIFORM1UIPROC gl3wProgramUniform1ui;
PFNGLPROGRAMUNIFORM1UIVPROC gl3wProgramUniform1uiv;
PFNGLPROGRAMUNIFORM2IPROC gl3wProgramUniform2i;
PFNGLPROGRAMUNIFORM2IVPROC gl3wProgramUniform2iv;
PFNGLPROGRAMUNIFORM2FPROC gl3wProgramUniform2f;
PFNGLPROGRAMUNIFORM2FVPROC gl3wProgramUniform2fv;
PFNGLPROGRAMUNIFORM2DPROC gl3wProgramUniform2d;
PFNGLPROGRAMUNIFORM2DVPROC gl3wProgramUniform2dv;
PFNGLPROGRAMUNIFORM2UIPROC gl3wProgramUniform2ui;
PFNGLPROGRAMUNIFORM2UIVPROC gl3wProgramUniform2uiv;
PFNGLPROGRAMUNIFORM3IPROC gl3wProgramUniform3i;
PFNGLPROGRAMUNIFORM3IVPROC gl3wProgramUniform3iv;
PFNGLPROGRAMUNIFORM3FPROC gl3wProgramUniform3f;
PFNGLPROGRAMUNIFORM3FVPROC gl3wProgramUniform3fv;
PFNGLPROGRAMUNIFORM3DPROC gl3wProgramUniform3d;
PFNGLPROGRAMUNIFORM3DVPROC gl3wProgramUniform3dv;
PFNGLPROGRAMUNIFORM3UIPROC gl3wProgramUniform3ui;
PFNGLPROGRAMUNIFORM3UIVPROC gl3wProgramUniform3uiv;
PFNGLPROGRAMUNIFORM4IPROC gl3wProgramUniform4i;
PFNGLPROGRAMUNIFORM4IVPROC gl3wProgramUniform4iv;
PFNGLPROGRAMUNIFORM4FPROC gl3wProgramUniform4f;
PFNGLPROGRAMUNIFORM4FVPROC gl3wProgramUniform4fv;
PFNGLPROGRAMUNIFORM4DPROC gl3wProgramUniform4d;
PFNGLPROGRAMUNIFORM4DVPROC gl3wProgramUniform4dv;
PFNGLPROGRAMUNIFORM4UIPROC gl3wProgramUniform4ui;
PFNGLPROGRAMUNIFORM4UIVPROC gl3wProgramUniform4uiv;
PFNGLPROGRAMUNIFORMMATRIX2FVPROC gl3wProgramUniformMatrix2fv;
PFNGLPROGRAMUNIFORMMATRIX3FVPROC gl3wProgramUniformMatrix3fv;
PFNGLPROGRAMUNIFORMMATRIX4FVPROC gl3wProgramUniformMatrix4fv;
PFNGLPROGRAMUNIFORMMATRIX2DVPROC gl3wProgramUniformMatrix2dv;
PFNGLPROGRAMUNIFORMMATRIX3DVPROC gl3wProgramUniformMatrix3dv;
PFNGLPROGRAMUNIFORMMATRIX4DVPROC gl3wProgramUniformMatrix4dv;
PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC gl3wProgramUniformMatrix2x3fv;
PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC gl3wProgramUniformMatrix3x2fv;
PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC gl3wProgramUniformMatrix2x4fv;
PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC gl3wProgramUniformMatrix4x2fv;
PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC gl3wProgramUniformMatrix3x4fv;
PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC gl3wProgramUniformMatrix4x3fv;
PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC gl3wProgramUniformMatrix2x3dv;
PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC gl3wProgramUniformMatrix3x2dv;
PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC gl3wProgramUniformMatrix2x4dv;
PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC gl3wProgramUniformMatrix4x2dv;
PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC gl3wProgramUniformMatrix3x4dv;
PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC gl3wProgramUniformMatrix4x3dv;
PFNGLVALIDATEPROGRAMPIPELINEPROC gl3wValidateProgramPipeline;
PFNGLGETPROGRAMPIPELINEINFOLOGPROC gl3wGetProgramPipelineInfoLog;
PFNGLVERTEXATTRIBL1DPROC gl3wVertexAttribL1d;
PFNGLVERTEXATTRIBL2DPROC gl3wVertexAttribL2d;
PFNGLVERTEXATTRIBL3DPROC gl3wVertexAttribL3d;
PFNGLVERTEXATTRIBL4DPROC gl3wVertexAttribL4d;
PFNGLVERTEXATTRIBL1DVPROC gl3wVertexAttribL1dv;
PFNGLVERTEXATTRIBL2DVPROC gl3wVertexAttribL2dv;
PFNGLVERTEXATTRIBL3DVPROC gl3wVertexAttribL3dv;
PFNGLVERTEXATTRIBL4DVPROC gl3wVertexAttribL4dv;
PFNGLVERTEXATTRIBLPOINTERPROC gl3wVertexAttribLPointer;
PFNGLGETVERTEXATTRIBLDVPROC gl3wGetVertexAttribLdv;
PFNGLVIEWPORTARRAYVPROC gl3wViewportArrayv;
PFNGLVIEWPORTINDEXEDFPROC gl3wViewportIndexedf;
PFNGLVIEWPORTINDEXEDFVPROC gl3wViewportIndexedfv;
PFNGLSCISSORARRAYVPROC gl3wScissorArrayv;
PFNGLSCISSORINDEXEDPROC gl3wScissorIndexed;
PFNGLSCISSORINDEXEDVPROC gl3wScissorIndexedv;
PFNGLDEPTHRANGEARRAYVPROC gl3wDepthRangeArrayv;
PFNGLDEPTHRANGEINDEXEDPROC gl3wDepthRangeIndexed;
PFNGLGETFLOATI_VPROC gl3wGetFloati_v;
PFNGLGETDOUBLEI_VPROC gl3wGetDoublei_v;
PFNGLCREATESYNCFROMCLEVENTARBPROC gl3wCreateSyncFromCLeventARB;
PFNGLDEBUGMESSAGECONTROLARBPROC gl3wDebugMessageControlARB;
PFNGLDEBUGMESSAGEINSERTARBPROC gl3wDebugMessageInsertARB;
PFNGLDEBUGMESSAGECALLBACKARBPROC gl3wDebugMessageCallbackARB;
PFNGLGETDEBUGMESSAGELOGARBPROC gl3wGetDebugMessageLogARB;
PFNGLGETGRAPHICSRESETSTATUSARBPROC gl3wGetGraphicsResetStatusARB;
PFNGLGETNTEXIMAGEARBPROC gl3wGetnTexImageARB;
PFNGLREADNPIXELSARBPROC gl3wReadnPixelsARB;
PFNGLGETNCOMPRESSEDTEXIMAGEARBPROC gl3wGetnCompressedTexImageARB;
PFNGLGETNUNIFORMFVARBPROC gl3wGetnUniformfvARB;
PFNGLGETNUNIFORMIVARBPROC gl3wGetnUniformivARB;
PFNGLGETNUNIFORMUIVARBPROC gl3wGetnUniformuivARB;
PFNGLGETNUNIFORMDVARBPROC gl3wGetnUniformdvARB;
PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC gl3wDrawArraysInstancedBaseInstance;
PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC gl3wDrawElementsInstancedBaseInstance;
PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC gl3wDrawElementsInstancedBaseVertexBaseInstance;
PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC gl3wDrawTransformFeedbackInstanced;
PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC gl3wDrawTransformFeedbackStreamInstanced;
PFNGLGETINTERNALFORMATIVPROC gl3wGetInternalformativ;
PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC gl3wGetActiveAtomicCounterBufferiv;
PFNGLBINDIMAGETEXTUREPROC gl3wBindImageTexture;
PFNGLMEMORYBARRIERPROC gl3wMemoryBarrier;
PFNGLTEXSTORAGE1DPROC gl3wTexStorage1D;
PFNGLTEXSTORAGE2DPROC gl3wTexStorage2D;
PFNGLTEXSTORAGE3DPROC gl3wTexStorage3D;
PFNGLTEXTURESTORAGE1DEXTPROC gl3wTextureStorage1DEXT;
PFNGLTEXTURESTORAGE2DEXTPROC gl3wTextureStorage2DEXT;
PFNGLTEXTURESTORAGE3DEXTPROC gl3wTextureStorage3DEXT;
PFNGLDEBUGMESSAGECONTROLPROC gl3wDebugMessageControl;
PFNGLDEBUGMESSAGEINSERTPROC gl3wDebugMessageInsert;
PFNGLDEBUGMESSAGECALLBACKPROC gl3wDebugMessageCallback;
PFNGLGETDEBUGMESSAGELOGPROC gl3wGetDebugMessageLog;
PFNGLPUSHDEBUGGROUPPROC gl3wPushDebugGroup;
PFNGLPOPDEBUGGROUPPROC gl3wPopDebugGroup;
PFNGLOBJECTLABELPROC gl3wObjectLabel;
PFNGLGETOBJECTLABELPROC gl3wGetObjectLabel;
PFNGLOBJECTPTRLABELPROC gl3wObjectPtrLabel;
PFNGLGETOBJECTPTRLABELPROC gl3wGetObjectPtrLabel;
PFNGLCLEARBUFFERDATAPROC gl3wClearBufferData;
PFNGLCLEARBUFFERSUBDATAPROC gl3wClearBufferSubData;
PFNGLCLEARNAMEDBUFFERDATAEXTPROC gl3wClearNamedBufferDataEXT;
PFNGLCLEARNAMEDBUFFERSUBDATAEXTPROC gl3wClearNamedBufferSubDataEXT;
PFNGLDISPATCHCOMPUTEPROC gl3wDispatchCompute;
PFNGLDISPATCHCOMPUTEINDIRECTPROC gl3wDispatchComputeIndirect;
PFNGLCOPYIMAGESUBDATAPROC gl3wCopyImageSubData;
PFNGLTEXTUREVIEWPROC gl3wTextureView;
PFNGLBINDVERTEXBUFFERPROC gl3wBindVertexBuffer;
PFNGLVERTEXATTRIBFORMATPROC gl3wVertexAttribFormat;
PFNGLVERTEXATTRIBIFORMATPROC gl3wVertexAttribIFormat;
PFNGLVERTEXATTRIBLFORMATPROC gl3wVertexAttribLFormat;
PFNGLVERTEXATTRIBBINDINGPROC gl3wVertexAttribBinding;
PFNGLVERTEXBINDINGDIVISORPROC gl3wVertexBindingDivisor;
PFNGLVERTEXARRAYBINDVERTEXBUFFEREXTPROC gl3wVertexArrayBindVertexBufferEXT;
PFNGLVERTEXARRAYVERTEXATTRIBFORMATEXTPROC gl3wVertexArrayVertexAttribFormatEXT;
PFNGLVERTEXARRAYVERTEXATTRIBIFORMATEXTPROC gl3wVertexArrayVertexAttribIFormatEXT;
PFNGLVERTEXARRAYVERTEXATTRIBLFORMATEXTPROC gl3wVertexArrayVertexAttribLFormatEXT;
PFNGLVERTEXARRAYVERTEXATTRIBBINDINGEXTPROC gl3wVertexArrayVertexAttribBindingEXT;
PFNGLVERTEXARRAYVERTEXBINDINGDIVISOREXTPROC gl3wVertexArrayVertexBindingDivisorEXT;
PFNGLFRAMEBUFFERPARAMETERIPROC gl3wFramebufferParameteri;
PFNGLGETFRAMEBUFFERPARAMETERIVPROC gl3wGetFramebufferParameteriv;
PFNGLNAMEDFRAMEBUFFERPARAMETERIEXTPROC gl3wNamedFramebufferParameteriEXT;
PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVEXTPROC gl3wGetNamedFramebufferParameterivEXT;
PFNGLGETINTERNALFORMATI64VPROC gl3wGetInternalformati64v;
PFNGLINVALIDATETEXSUBIMAGEPROC gl3wInvalidateTexSubImage;
PFNGLINVALIDATETEXIMAGEPROC gl3wInvalidateTexImage;
PFNGLINVALIDATEBUFFERSUBDATAPROC gl3wInvalidateBufferSubData;
PFNGLINVALIDATEBUFFERDATAPROC gl3wInvalidateBufferData;
PFNGLINVALIDATEFRAMEBUFFERPROC gl3wInvalidateFramebuffer;
PFNGLINVALIDATESUBFRAMEBUFFERPROC gl3wInvalidateSubFramebuffer;
PFNGLMULTIDRAWARRAYSINDIRECTPROC gl3wMultiDrawArraysIndirect;
PFNGLMULTIDRAWELEMENTSINDIRECTPROC gl3wMultiDrawElementsIndirect;
PFNGLGETPROGRAMINTERFACEIVPROC gl3wGetProgramInterfaceiv;
PFNGLGETPROGRAMRESOURCEINDEXPROC gl3wGetProgramResourceIndex;
PFNGLGETPROGRAMRESOURCENAMEPROC gl3wGetProgramResourceName;
PFNGLGETPROGRAMRESOURCEIVPROC gl3wGetProgramResourceiv;
PFNGLGETPROGRAMRESOURCELOCATIONPROC gl3wGetProgramResourceLocation;
PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC gl3wGetProgramResourceLocationIndex;
PFNGLSHADERSTORAGEBLOCKBINDINGPROC gl3wShaderStorageBlockBinding;
PFNGLTEXBUFFERRANGEPROC gl3wTexBufferRange;
PFNGLTEXTUREBUFFERRANGEEXTPROC gl3wTextureBufferRangeEXT;
PFNGLTEXSTORAGE2DMULTISAMPLEPROC gl3wTexStorage2DMultisample;
PFNGLTEXSTORAGE3DMULTISAMPLEPROC gl3wTexStorage3DMultisample;
PFNGLTEXTURESTORAGE2DMULTISAMPLEEXTPROC gl3wTextureStorage2DMultisampleEXT;
PFNGLTEXTURESTORAGE3DMULTISAMPLEEXTPROC gl3wTextureStorage3DMultisampleEXT;

static void load_procs(void)
{
	gl3wCullFace = (PFNGLCULLFACEPROC)get_proc("glCullFace");
	gl3wFrontFace = (PFNGLFRONTFACEPROC)get_proc("glFrontFace");
	gl3wHint = (PFNGLHINTPROC)get_proc("glHint");
	gl3wLineWidth = (PFNGLLINEWIDTHPROC)get_proc("glLineWidth");
	gl3wPointSize = (PFNGLPOINTSIZEPROC)get_proc("glPointSize");
	gl3wPolygonMode = (PFNGLPOLYGONMODEPROC)get_proc("glPolygonMode");
	gl3wScissor = (PFNGLSCISSORPROC)get_proc("glScissor");
	gl3wTexParameterf = (PFNGLTEXPARAMETERFPROC)get_proc("glTexParameterf");
	gl3wTexParameterfv = (PFNGLTEXPARAMETERFVPROC)get_proc("glTexParameterfv");
	gl3wTexParameteri = (PFNGLTEXPARAMETERIPROC)get_proc("glTexParameteri");
	gl3wTexParameteriv = (PFNGLTEXPARAMETERIVPROC)get_proc("glTexParameteriv");
	gl3wTexImage1D = (PFNGLTEXIMAGE1DPROC)get_proc("glTexImage1D");
	gl3wTexImage2D = (PFNGLTEXIMAGE2DPROC)get_proc("glTexImage2D");
	gl3wDrawBuffer = (PFNGLDRAWBUFFERPROC)get_proc("glDrawBuffer");
	gl3wClear = (PFNGLCLEARPROC)get_proc("glClear");
	gl3wClearColor = (PFNGLCLEARCOLORPROC)get_proc("glClearColor");
	gl3wClearStencil = (PFNGLCLEARSTENCILPROC)get_proc("glClearStencil");
	gl3wClearDepth = (PFNGLCLEARDEPTHPROC)get_proc("glClearDepth");
	gl3wStencilMask = (PFNGLSTENCILMASKPROC)get_proc("glStencilMask");
	gl3wColorMask = (PFNGLCOLORMASKPROC)get_proc("glColorMask");
	gl3wDepthMask = (PFNGLDEPTHMASKPROC)get_proc("glDepthMask");
	gl3wDisable = (PFNGLDISABLEPROC)get_proc("glDisable");
	gl3wEnable = (PFNGLENABLEPROC)get_proc("glEnable");
	gl3wFinish = (PFNGLFINISHPROC)get_proc("glFinish");
	gl3wFlush = (PFNGLFLUSHPROC)get_proc("glFlush");
	gl3wBlendFunc = (PFNGLBLENDFUNCPROC)get_proc("glBlendFunc");
	gl3wLogicOp = (PFNGLLOGICOPPROC)get_proc("glLogicOp");
	gl3wStencilFunc = (PFNGLSTENCILFUNCPROC)get_proc("glStencilFunc");
	gl3wStencilOp = (PFNGLSTENCILOPPROC)get_proc("glStencilOp");
	gl3wDepthFunc = (PFNGLDEPTHFUNCPROC)get_proc("glDepthFunc");
	gl3wPixelStoref = (PFNGLPIXELSTOREFPROC)get_proc("glPixelStoref");
	gl3wPixelStorei = (PFNGLPIXELSTOREIPROC)get_proc("glPixelStorei");
	gl3wReadBuffer = (PFNGLREADBUFFERPROC)get_proc("glReadBuffer");
	gl3wReadPixels = (PFNGLREADPIXELSPROC)get_proc("glReadPixels");
	gl3wGetBooleanv = (PFNGLGETBOOLEANVPROC)get_proc("glGetBooleanv");
	gl3wGetDoublev = (PFNGLGETDOUBLEVPROC)get_proc("glGetDoublev");
	gl3wGetError = (PFNGLGETERRORPROC)get_proc("glGetError");
	gl3wGetFloatv = (PFNGLGETFLOATVPROC)get_proc("glGetFloatv");
	gl3wGetIntegerv = (PFNGLGETINTEGERVPROC)get_proc("glGetIntegerv");
	gl3wGetString = (PFNGLGETSTRINGPROC)get_proc("glGetString");
	gl3wGetTexImage = (PFNGLGETTEXIMAGEPROC)get_proc("glGetTexImage");
	gl3wGetTexParameterfv = (PFNGLGETTEXPARAMETERFVPROC)get_proc("glGetTexParameterfv");
	gl3wGetTexParameteriv = (PFNGLGETTEXPARAMETERIVPROC)get_proc("glGetTexParameteriv");
	gl3wGetTexLevelParameterfv = (PFNGLGETTEXLEVELPARAMETERFVPROC)get_proc("glGetTexLevelParameterfv");
	gl3wGetTexLevelParameteriv = (PFNGLGETTEXLEVELPARAMETERIVPROC)get_proc("glGetTexLevelParameteriv");
	gl3wIsEnabled = (PFNGLISENABLEDPROC)get_proc("glIsEnabled");
	gl3wDepthRange = (PFNGLDEPTHRANGEPROC)get_proc("glDepthRange");
	gl3wViewport = (PFNGLVIEWPORTPROC)get_proc("glViewport");
	gl3wDrawArrays = (PFNGLDRAWARRAYSPROC)get_proc("glDrawArrays");
	gl3wDrawElements = (PFNGLDRAWELEMENTSPROC)get_proc("glDrawElements");
	gl3wGetPointerv = (PFNGLGETPOINTERVPROC)get_proc("glGetPointerv");
	gl3wPolygonOffset = (PFNGLPOLYGONOFFSETPROC)get_proc("glPolygonOffset");
	gl3wCopyTexImage1D = (PFNGLCOPYTEXIMAGE1DPROC)get_proc("glCopyTexImage1D");
	gl3wCopyTexImage2D = (PFNGLCOPYTEXIMAGE2DPROC)get_proc("glCopyTexImage2D");
	gl3wCopyTexSubImage1D = (PFNGLCOPYTEXSUBIMAGE1DPROC)get_proc("glCopyTexSubImage1D");
	gl3wCopyTexSubImage2D = (PFNGLCOPYTEXSUBIMAGE2DPROC)get_proc("glCopyTexSubImage2D");
	gl3wTexSubImage1D = (PFNGLTEXSUBIMAGE1DPROC)get_proc("glTexSubImage1D");
	gl3wTexSubImage2D = (PFNGLTEXSUBIMAGE2DPROC)get_proc("glTexSubImage2D");
	gl3wBindTexture = (PFNGLBINDTEXTUREPROC)get_proc("glBindTexture");
	gl3wDeleteTextures = (PFNGLDELETETEXTURESPROC)get_proc("glDeleteTextures");
	gl3wGenTextures = (PFNGLGENTEXTURESPROC)get_proc("glGenTextures");
	gl3wIsTexture = (PFNGLISTEXTUREPROC)get_proc("glIsTexture");
	gl3wBlendColor = (PFNGLBLENDCOLORPROC)get_proc("glBlendColor");
	gl3wBlendEquation = (PFNGLBLENDEQUATIONPROC)get_proc("glBlendEquation");
	gl3wDrawRangeElements = (PFNGLDRAWRANGEELEMENTSPROC)get_proc("glDrawRangeElements");
	gl3wTexImage3D = (PFNGLTEXIMAGE3DPROC)get_proc("glTexImage3D");
	gl3wTexSubImage3D = (PFNGLTEXSUBIMAGE3DPROC)get_proc("glTexSubImage3D");
	gl3wCopyTexSubImage3D = (PFNGLCOPYTEXSUBIMAGE3DPROC)get_proc("glCopyTexSubImage3D");
	gl3wActiveTexture = (PFNGLACTIVETEXTUREPROC)get_proc("glActiveTexture");
	gl3wSampleCoverage = (PFNGLSAMPLECOVERAGEPROC)get_proc("glSampleCoverage");
	gl3wCompressedTexImage3D = (PFNGLCOMPRESSEDTEXIMAGE3DPROC)get_proc("glCompressedTexImage3D");
	gl3wCompressedTexImage2D = (PFNGLCOMPRESSEDTEXIMAGE2DPROC)get_proc("glCompressedTexImage2D");
	gl3wCompressedTexImage1D = (PFNGLCOMPRESSEDTEXIMAGE1DPROC)get_proc("glCompressedTexImage1D");
	gl3wCompressedTexSubImage3D = (PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC)get_proc("glCompressedTexSubImage3D");
	gl3wCompressedTexSubImage2D = (PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC)get_proc("glCompressedTexSubImage2D");
	gl3wCompressedTexSubImage1D = (PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC)get_proc("glCompressedTexSubImage1D");
	gl3wGetCompressedTexImage = (PFNGLGETCOMPRESSEDTEXIMAGEPROC)get_proc("glGetCompressedTexImage");
	gl3wBlendFuncSeparate = (PFNGLBLENDFUNCSEPARATEPROC)get_proc("glBlendFuncSeparate");
	gl3wMultiDrawArrays = (PFNGLMULTIDRAWARRAYSPROC)get_proc("glMultiDrawArrays");
	gl3wMultiDrawElements = (PFNGLMULTIDRAWELEMENTSPROC)get_proc("glMultiDrawElements");
	gl3wPointParameterf = (PFNGLPOINTPARAMETERFPROC)get_proc("glPointParameterf");
	gl3wPointParameterfv = (PFNGLPOINTPARAMETERFVPROC)get_proc("glPointParameterfv");
	gl3wPointParameteri = (PFNGLPOINTPARAMETERIPROC)get_proc("glPointParameteri");
	gl3wPointParameteriv = (PFNGLPOINTPARAMETERIVPROC)get_proc("glPointParameteriv");
	gl3wGenQueries = (PFNGLGENQUERIESPROC)get_proc("glGenQueries");
	gl3wDeleteQueries = (PFNGLDELETEQUERIESPROC)get_proc("glDeleteQueries");
	gl3wIsQuery = (PFNGLISQUERYPROC)get_proc("glIsQuery");
	gl3wBeginQuery = (PFNGLBEGINQUERYPROC)get_proc("glBeginQuery");
	gl3wEndQuery = (PFNGLENDQUERYPROC)get_proc("glEndQuery");
	gl3wGetQueryiv = (PFNGLGETQUERYIVPROC)get_proc("glGetQueryiv");
	gl3wGetQueryObjectiv = (PFNGLGETQUERYOBJECTIVPROC)get_proc("glGetQueryObjectiv");
	gl3wGetQueryObjectuiv = (PFNGLGETQUERYOBJECTUIVPROC)get_proc("glGetQueryObjectuiv");
	gl3wBindBuffer = (PFNGLBINDBUFFERPROC)get_proc("glBindBuffer");
	gl3wDeleteBuffers = (PFNGLDELETEBUFFERSPROC)get_proc("glDeleteBuffers");
	gl3wGenBuffers = (PFNGLGENBUFFERSPROC)get_proc("glGenBuffers");
	gl3wIsBuffer = (PFNGLISBUFFERPROC)get_proc("glIsBuffer");
	gl3wBufferData = (PFNGLBUFFERDATAPROC)get_proc("glBufferData");
	gl3wBufferSubData = (PFNGLBUFFERSUBDATAPROC)get_proc("glBufferSubData");
	gl3wGetBufferSubData = (PFNGLGETBUFFERSUBDATAPROC)get_proc("glGetBufferSubData");
	gl3wMapBuffer = (PFNGLMAPBUFFERPROC)get_proc("glMapBuffer");
	gl3wUnmapBuffer = (PFNGLUNMAPBUFFERPROC)get_proc("glUnmapBuffer");
	gl3wGetBufferParameteriv = (PFNGLGETBUFFERPARAMETERIVPROC)get_proc("glGetBufferParameteriv");
	gl3wGetBufferPointerv = (PFNGLGETBUFFERPOINTERVPROC)get_proc("glGetBufferPointerv");
	gl3wBlendEquationSeparate = (PFNGLBLENDEQUATIONSEPARATEPROC)get_proc("glBlendEquationSeparate");
	gl3wDrawBuffers = (PFNGLDRAWBUFFERSPROC)get_proc("glDrawBuffers");
	gl3wStencilOpSeparate = (PFNGLSTENCILOPSEPARATEPROC)get_proc("glStencilOpSeparate");
	gl3wStencilFuncSeparate = (PFNGLSTENCILFUNCSEPARATEPROC)get_proc("glStencilFuncSeparate");
	gl3wStencilMaskSeparate = (PFNGLSTENCILMASKSEPARATEPROC)get_proc("glStencilMaskSeparate");
	gl3wAttachShader = (PFNGLATTACHSHADERPROC)get_proc("glAttachShader");
	gl3wBindAttribLocation = (PFNGLBINDATTRIBLOCATIONPROC)get_proc("glBindAttribLocation");
	gl3wCompileShader = (PFNGLCOMPILESHADERPROC)get_proc("glCompileShader");
	gl3wCreateProgram = (PFNGLCREATEPROGRAMPROC)get_proc("glCreateProgram");
	gl3wCreateShader = (PFNGLCREATESHADERPROC)get_proc("glCreateShader");
	gl3wDeleteProgram = (PFNGLDELETEPROGRAMPROC)get_proc("glDeleteProgram");
	gl3wDeleteShader = (PFNGLDELETESHADERPROC)get_proc("glDeleteShader");
	gl3wDetachShader = (PFNGLDETACHSHADERPROC)get_proc("glDetachShader");
	gl3wDisableVertexAttribArray = (PFNGLDISABLEVERTEXATTRIBARRAYPROC)get_proc("glDisableVertexAttribArray");
	gl3wEnableVertexAttribArray = (PFNGLENABLEVERTEXATTRIBARRAYPROC)get_proc("glEnableVertexAttribArray");
	gl3wGetActiveAttrib = (PFNGLGETACTIVEATTRIBPROC)get_proc("glGetActiveAttrib");
	gl3wGetActiveUniform = (PFNGLGETACTIVEUNIFORMPROC)get_proc("glGetActiveUniform");
	gl3wGetAttachedShaders = (PFNGLGETATTACHEDSHADERSPROC)get_proc("glGetAttachedShaders");
	gl3wGetAttribLocation = (PFNGLGETATTRIBLOCATIONPROC)get_proc("glGetAttribLocation");
	gl3wGetProgramiv = (PFNGLGETPROGRAMIVPROC)get_proc("glGetProgramiv");
	gl3wGetProgramInfoLog = (PFNGLGETPROGRAMINFOLOGPROC)get_proc("glGetProgramInfoLog");
	gl3wGetShaderiv = (PFNGLGETSHADERIVPROC)get_proc("glGetShaderiv");
	gl3wGetShaderInfoLog = (PFNGLGETSHADERINFOLOGPROC)get_proc("glGetShaderInfoLog");
	gl3wGetShaderSource = (PFNGLGETSHADERSOURCEPROC)get_proc("glGetShaderSource");
	gl3wGetUniformLocation = (PFNGLGETUNIFORMLOCATIONPROC)get_proc("glGetUniformLocation");
	gl3wGetUniformfv = (PFNGLGETUNIFORMFVPROC)get_proc("glGetUniformfv");
	gl3wGetUniformiv = (PFNGLGETUNIFORMIVPROC)get_proc("glGetUniformiv");
	gl3wGetVertexAttribdv = (PFNGLGETVERTEXATTRIBDVPROC)get_proc("glGetVertexAttribdv");
	gl3wGetVertexAttribfv = (PFNGLGETVERTEXATTRIBFVPROC)get_proc("glGetVertexAttribfv");
	gl3wGetVertexAttribiv = (PFNGLGETVERTEXATTRIBIVPROC)get_proc("glGetVertexAttribiv");
	gl3wGetVertexAttribPointerv = (PFNGLGETVERTEXATTRIBPOINTERVPROC)get_proc("glGetVertexAttribPointerv");
	gl3wIsProgram = (PFNGLISPROGRAMPROC)get_proc("glIsProgram");
	gl3wIsShader = (PFNGLISSHADERPROC)get_proc("glIsShader");
	gl3wLinkProgram = (PFNGLLINKPROGRAMPROC)get_proc("glLinkProgram");
	gl3wShaderSource = (PFNGLSHADERSOURCEPROC)get_proc("glShaderSource");
	gl3wUseProgram = (PFNGLUSEPROGRAMPROC)get_proc("glUseProgram");
	gl3wUniform1f = (PFNGLUNIFORM1FPROC)get_proc("glUniform1f");
	gl3wUniform2f = (PFNGLUNIFORM2FPROC)get_proc("glUniform2f");
	gl3wUniform3f = (PFNGLUNIFORM3FPROC)get_proc("glUniform3f");
	gl3wUniform4f = (PFNGLUNIFORM4FPROC)get_proc("glUniform4f");
	gl3wUniform1i = (PFNGLUNIFORM1IPROC)get_proc("glUniform1i");
	gl3wUniform2i = (PFNGLUNIFORM2IPROC)get_proc("glUniform2i");
	gl3wUniform3i = (PFNGLUNIFORM3IPROC)get_proc("glUniform3i");
	gl3wUniform4i = (PFNGLUNIFORM4IPROC)get_proc("glUniform4i");
	gl3wUniform1fv = (PFNGLUNIFORM1FVPROC)get_proc("glUniform1fv");
	gl3wUniform2fv = (PFNGLUNIFORM2FVPROC)get_proc("glUniform2fv");
	gl3wUniform3fv = (PFNGLUNIFORM3FVPROC)get_proc("glUniform3fv");
	gl3wUniform4fv = (PFNGLUNIFORM4FVPROC)get_proc("glUniform4fv");
	gl3wUniform1iv = (PFNGLUNIFORM1IVPROC)get_proc("glUniform1iv");
	gl3wUniform2iv = (PFNGLUNIFORM2IVPROC)get_proc("glUniform2iv");
	gl3wUniform3iv = (PFNGLUNIFORM3IVPROC)get_proc("glUniform3iv");
	gl3wUniform4iv = (PFNGLUNIFORM4IVPROC)get_proc("glUniform4iv");
	gl3wUniformMatrix2fv = (PFNGLUNIFORMMATRIX2FVPROC)get_proc("glUniformMatrix2fv");
	gl3wUniformMatrix3fv = (PFNGLUNIFORMMATRIX3FVPROC)get_proc("glUniformMatrix3fv");
	gl3wUniformMatrix4fv = (PFNGLUNIFORMMATRIX4FVPROC)get_proc("glUniformMatrix4fv");
	gl3wValidateProgram = (PFNGLVALIDATEPROGRAMPROC)get_proc("glValidateProgram");
	gl3wVertexAttrib1d = (PFNGLVERTEXATTRIB1DPROC)get_proc("glVertexAttrib1d");
	gl3wVertexAttrib1dv = (PFNGLVERTEXATTRIB1DVPROC)get_proc("glVertexAttrib1dv");
	gl3wVertexAttrib1f = (PFNGLVERTEXATTRIB1FPROC)get_proc("glVertexAttrib1f");
	gl3wVertexAttrib1fv = (PFNGLVERTEXATTRIB1FVPROC)get_proc("glVertexAttrib1fv");
	gl3wVertexAttrib1s = (PFNGLVERTEXATTRIB1SPROC)get_proc("glVertexAttrib1s");
	gl3wVertexAttrib1sv = (PFNGLVERTEXATTRIB1SVPROC)get_proc("glVertexAttrib1sv");
	gl3wVertexAttrib2d = (PFNGLVERTEXATTRIB2DPROC)get_proc("glVertexAttrib2d");
	gl3wVertexAttrib2dv = (PFNGLVERTEXATTRIB2DVPROC)get_proc("glVertexAttrib2dv");
	gl3wVertexAttrib2f = (PFNGLVERTEXATTRIB2FPROC)get_proc("glVertexAttrib2f");
	gl3wVertexAttrib2fv = (PFNGLVERTEXATTRIB2FVPROC)get_proc("glVertexAttrib2fv");
	gl3wVertexAttrib2s = (PFNGLVERTEXATTRIB2SPROC)get_proc("glVertexAttrib2s");
	gl3wVertexAttrib2sv = (PFNGLVERTEXATTRIB2SVPROC)get_proc("glVertexAttrib2sv");
	gl3wVertexAttrib3d = (PFNGLVERTEXATTRIB3DPROC)get_proc("glVertexAttrib3d");
	gl3wVertexAttrib3dv = (PFNGLVERTEXATTRIB3DVPROC)get_proc("glVertexAttrib3dv");
	gl3wVertexAttrib3f = (PFNGLVERTEXATTRIB3FPROC)get_proc("glVertexAttrib3f");
	gl3wVertexAttrib3fv = (PFNGLVERTEXATTRIB3FVPROC)get_proc("glVertexAttrib3fv");
	gl3wVertexAttrib3s = (PFNGLVERTEXATTRIB3SPROC)get_proc("glVertexAttrib3s");
	gl3wVertexAttrib3sv = (PFNGLVERTEXATTRIB3SVPROC)get_proc("glVertexAttrib3sv");
	gl3wVertexAttrib4Nbv = (PFNGLVERTEXATTRIB4NBVPROC)get_proc("glVertexAttrib4Nbv");
	gl3wVertexAttrib4Niv = (PFNGLVERTEXATTRIB4NIVPROC)get_proc("glVertexAttrib4Niv");
	gl3wVertexAttrib4Nsv = (PFNGLVERTEXATTRIB4NSVPROC)get_proc("glVertexAttrib4Nsv");
	gl3wVertexAttrib4Nub = (PFNGLVERTEXATTRIB4NUBPROC)get_proc("glVertexAttrib4Nub");
	gl3wVertexAttrib4Nubv = (PFNGLVERTEXATTRIB4NUBVPROC)get_proc("glVertexAttrib4Nubv");
	gl3wVertexAttrib4Nuiv = (PFNGLVERTEXATTRIB4NUIVPROC)get_proc("glVertexAttrib4Nuiv");
	gl3wVertexAttrib4Nusv = (PFNGLVERTEXATTRIB4NUSVPROC)get_proc("glVertexAttrib4Nusv");
	gl3wVertexAttrib4bv = (PFNGLVERTEXATTRIB4BVPROC)get_proc("glVertexAttrib4bv");
	gl3wVertexAttrib4d = (PFNGLVERTEXATTRIB4DPROC)get_proc("glVertexAttrib4d");
	gl3wVertexAttrib4dv = (PFNGLVERTEXATTRIB4DVPROC)get_proc("glVertexAttrib4dv");
	gl3wVertexAttrib4f = (PFNGLVERTEXATTRIB4FPROC)get_proc("glVertexAttrib4f");
	gl3wVertexAttrib4fv = (PFNGLVERTEXATTRIB4FVPROC)get_proc("glVertexAttrib4fv");
	gl3wVertexAttrib4iv = (PFNGLVERTEXATTRIB4IVPROC)get_proc("glVertexAttrib4iv");
	gl3wVertexAttrib4s = (PFNGLVERTEXATTRIB4SPROC)get_proc("glVertexAttrib4s");
	gl3wVertexAttrib4sv = (PFNGLVERTEXATTRIB4SVPROC)get_proc("glVertexAttrib4sv");
	gl3wVertexAttrib4ubv = (PFNGLVERTEXATTRIB4UBVPROC)get_proc("glVertexAttrib4ubv");
	gl3wVertexAttrib4uiv = (PFNGLVERTEXATTRIB4UIVPROC)get_proc("glVertexAttrib4uiv");
	gl3wVertexAttrib4usv = (PFNGLVERTEXATTRIB4USVPROC)get_proc("glVertexAttrib4usv");
	gl3wVertexAttribPointer = (PFNGLVERTEXATTRIBPOINTERPROC)get_proc("glVertexAttribPointer");
	gl3wUniformMatrix2x3fv = (PFNGLUNIFORMMATRIX2X3FVPROC)get_proc("glUniformMatrix2x3fv");
	gl3wUniformMatrix3x2fv = (PFNGLUNIFORMMATRIX3X2FVPROC)get_proc("glUniformMatrix3x2fv");
	gl3wUniformMatrix2x4fv = (PFNGLUNIFORMMATRIX2X4FVPROC)get_proc("glUniformMatrix2x4fv");
	gl3wUniformMatrix4x2fv = (PFNGLUNIFORMMATRIX4X2FVPROC)get_proc("glUniformMatrix4x2fv");
	gl3wUniformMatrix3x4fv = (PFNGLUNIFORMMATRIX3X4FVPROC)get_proc("glUniformMatrix3x4fv");
	gl3wUniformMatrix4x3fv = (PFNGLUNIFORMMATRIX4X3FVPROC)get_proc("glUniformMatrix4x3fv");
	gl3wColorMaski = (PFNGLCOLORMASKIPROC)get_proc("glColorMaski");
	gl3wGetBooleani_v = (PFNGLGETBOOLEANI_VPROC)get_proc("glGetBooleani_v");
	gl3wGetIntegeri_v = (PFNGLGETINTEGERI_VPROC)get_proc("glGetIntegeri_v");
	gl3wEnablei = (PFNGLENABLEIPROC)get_proc("glEnablei");
	gl3wDisablei = (PFNGLDISABLEIPROC)get_proc("glDisablei");
	gl3wIsEnabledi = (PFNGLISENABLEDIPROC)get_proc("glIsEnabledi");
	gl3wBeginTransformFeedback = (PFNGLBEGINTRANSFORMFEEDBACKPROC)get_proc("glBeginTransformFeedback");
	gl3wEndTransformFeedback = (PFNGLENDTRANSFORMFEEDBACKPROC)get_proc("glEndTransformFeedback");
	gl3wBindBufferRange = (PFNGLBINDBUFFERRANGEPROC)get_proc("glBindBufferRange");
	gl3wBindBufferBase = (PFNGLBINDBUFFERBASEPROC)get_proc("glBindBufferBase");
	gl3wTransformFeedbackVaryings = (PFNGLTRANSFORMFEEDBACKVARYINGSPROC)get_proc("glTransformFeedbackVaryings");
	gl3wGetTransformFeedbackVarying = (PFNGLGETTRANSFORMFEEDBACKVARYINGPROC)get_proc("glGetTransformFeedbackVarying");
	gl3wClampColor = (PFNGLCLAMPCOLORPROC)get_proc("glClampColor");
	gl3wBeginConditionalRender = (PFNGLBEGINCONDITIONALRENDERPROC)get_proc("glBeginConditionalRender");
	gl3wEndConditionalRender = (PFNGLENDCONDITIONALRENDERPROC)get_proc("glEndConditionalRender");
	gl3wVertexAttribIPointer = (PFNGLVERTEXATTRIBIPOINTERPROC)get_proc("glVertexAttribIPointer");
	gl3wGetVertexAttribIiv = (PFNGLGETVERTEXATTRIBIIVPROC)get_proc("glGetVertexAttribIiv");
	gl3wGetVertexAttribIuiv = (PFNGLGETVERTEXATTRIBIUIVPROC)get_proc("glGetVertexAttribIuiv");
	gl3wVertexAttribI1i = (PFNGLVERTEXATTRIBI1IPROC)get_proc("glVertexAttribI1i");
	gl3wVertexAttribI2i = (PFNGLVERTEXATTRIBI2IPROC)get_proc("glVertexAttribI2i");
	gl3wVertexAttribI3i = (PFNGLVERTEXATTRIBI3IPROC)get_proc("glVertexAttribI3i");
	gl3wVertexAttribI4i = (PFNGLVERTEXATTRIBI4IPROC)get_proc("glVertexAttribI4i");
	gl3wVertexAttribI1ui = (PFNGLVERTEXATTRIBI1UIPROC)get_proc("glVertexAttribI1ui");
	gl3wVertexAttribI2ui = (PFNGLVERTEXATTRIBI2UIPROC)get_proc("glVertexAttribI2ui");
	gl3wVertexAttribI3ui = (PFNGLVERTEXATTRIBI3UIPROC)get_proc("glVertexAttribI3ui");
	gl3wVertexAttribI4ui = (PFNGLVERTEXATTRIBI4UIPROC)get_proc("glVertexAttribI4ui");
	gl3wVertexAttribI1iv = (PFNGLVERTEXATTRIBI1IVPROC)get_proc("glVertexAttribI1iv");
	gl3wVertexAttribI2iv = (PFNGLVERTEXATTRIBI2IVPROC)get_proc("glVertexAttribI2iv");
	gl3wVertexAttribI3iv = (PFNGLVERTEXATTRIBI3IVPROC)get_proc("glVertexAttribI3iv");
	gl3wVertexAttribI4iv = (PFNGLVERTEXATTRIBI4IVPROC)get_proc("glVertexAttribI4iv");
	gl3wVertexAttribI1uiv = (PFNGLVERTEXATTRIBI1UIVPROC)get_proc("glVertexAttribI1uiv");
	gl3wVertexAttribI2uiv = (PFNGLVERTEXATTRIBI2UIVPROC)get_proc("glVertexAttribI2uiv");
	gl3wVertexAttribI3uiv = (PFNGLVERTEXATTRIBI3UIVPROC)get_proc("glVertexAttribI3uiv");
	gl3wVertexAttribI4uiv = (PFNGLVERTEXATTRIBI4UIVPROC)get_proc("glVertexAttribI4uiv");
	gl3wVertexAttribI4bv = (PFNGLVERTEXATTRIBI4BVPROC)get_proc("glVertexAttribI4bv");
	gl3wVertexAttribI4sv = (PFNGLVERTEXATTRIBI4SVPROC)get_proc("glVertexAttribI4sv");
	gl3wVertexAttribI4ubv = (PFNGLVERTEXATTRIBI4UBVPROC)get_proc("glVertexAttribI4ubv");
	gl3wVertexAttribI4usv = (PFNGLVERTEXATTRIBI4USVPROC)get_proc("glVertexAttribI4usv");
	gl3wGetUniformuiv = (PFNGLGETUNIFORMUIVPROC)get_proc("glGetUniformuiv");
	gl3wBindFragDataLocation = (PFNGLBINDFRAGDATALOCATIONPROC)get_proc("glBindFragDataLocation");
	gl3wGetFragDataLocation = (PFNGLGETFRAGDATALOCATIONPROC)get_proc("glGetFragDataLocation");
	gl3wUniform1ui = (PFNGLUNIFORM1UIPROC)get_proc("glUniform1ui");
	gl3wUniform2ui = (PFNGLUNIFORM2UIPROC)get_proc("glUniform2ui");
	gl3wUniform3ui = (PFNGLUNIFORM3UIPROC)get_proc("glUniform3ui");
	gl3wUniform4ui = (PFNGLUNIFORM4UIPROC)get_proc("glUniform4ui");
	gl3wUniform1uiv = (PFNGLUNIFORM1UIVPROC)get_proc("glUniform1uiv");
	gl3wUniform2uiv = (PFNGLUNIFORM2UIVPROC)get_proc("glUniform2uiv");
	gl3wUniform3uiv = (PFNGLUNIFORM3UIVPROC)get_proc("glUniform3uiv");
	gl3wUniform4uiv = (PFNGLUNIFORM4UIVPROC)get_proc("glUniform4uiv");
	gl3wTexParameterIiv = (PFNGLTEXPARAMETERIIVPROC)get_proc("glTexParameterIiv");
	gl3wTexParameterIuiv = (PFNGLTEXPARAMETERIUIVPROC)get_proc("glTexParameterIuiv");
	gl3wGetTexParameterIiv = (PFNGLGETTEXPARAMETERIIVPROC)get_proc("glGetTexParameterIiv");
	gl3wGetTexParameterIuiv = (PFNGLGETTEXPARAMETERIUIVPROC)get_proc("glGetTexParameterIuiv");
	gl3wClearBufferiv = (PFNGLCLEARBUFFERIVPROC)get_proc("glClearBufferiv");
	gl3wClearBufferuiv = (PFNGLCLEARBUFFERUIVPROC)get_proc("glClearBufferuiv");
	gl3wClearBufferfv = (PFNGLCLEARBUFFERFVPROC)get_proc("glClearBufferfv");
	gl3wClearBufferfi = (PFNGLCLEARBUFFERFIPROC)get_proc("glClearBufferfi");
	gl3wGetStringi = (PFNGLGETSTRINGIPROC)get_proc("glGetStringi");
	gl3wDrawArraysInstanced = (PFNGLDRAWARRAYSINSTANCEDPROC)get_proc("glDrawArraysInstanced");
	gl3wDrawElementsInstanced = (PFNGLDRAWELEMENTSINSTANCEDPROC)get_proc("glDrawElementsInstanced");
	gl3wTexBuffer = (PFNGLTEXBUFFERPROC)get_proc("glTexBuffer");
	gl3wPrimitiveRestartIndex = (PFNGLPRIMITIVERESTARTINDEXPROC)get_proc("glPrimitiveRestartIndex");
	gl3wGetInteger64i_v = (PFNGLGETINTEGER64I_VPROC)get_proc("glGetInteger64i_v");
	gl3wGetBufferParameteri64v = (PFNGLGETBUFFERPARAMETERI64VPROC)get_proc("glGetBufferParameteri64v");
	gl3wFramebufferTexture = (PFNGLFRAMEBUFFERTEXTUREPROC)get_proc("glFramebufferTexture");
	gl3wVertexAttribDivisor = (PFNGLVERTEXATTRIBDIVISORPROC)get_proc("glVertexAttribDivisor");
	gl3wMinSampleShading = (PFNGLMINSAMPLESHADINGPROC)get_proc("glMinSampleShading");
	gl3wBlendEquationi = (PFNGLBLENDEQUATIONIPROC)get_proc("glBlendEquationi");
	gl3wBlendEquationSeparatei = (PFNGLBLENDEQUATIONSEPARATEIPROC)get_proc("glBlendEquationSeparatei");
	gl3wBlendFunci = (PFNGLBLENDFUNCIPROC)get_proc("glBlendFunci");
	gl3wBlendFuncSeparatei = (PFNGLBLENDFUNCSEPARATEIPROC)get_proc("glBlendFuncSeparatei");
	gl3wIsRenderbuffer = (PFNGLISRENDERBUFFERPROC)get_proc("glIsRenderbuffer");
	gl3wBindRenderbuffer = (PFNGLBINDRENDERBUFFERPROC)get_proc("glBindRenderbuffer");
	gl3wDeleteRenderbuffers = (PFNGLDELETERENDERBUFFERSPROC)get_proc("glDeleteRenderbuffers");
	gl3wGenRenderbuffers = (PFNGLGENRENDERBUFFERSPROC)get_proc("glGenRenderbuffers");
	gl3wRenderbufferStorage = (PFNGLRENDERBUFFERSTORAGEPROC)get_proc("glRenderbufferStorage");
	gl3wGetRenderbufferParameteriv = (PFNGLGETRENDERBUFFERPARAMETERIVPROC)get_proc("glGetRenderbufferParameteriv");
	gl3wIsFramebuffer = (PFNGLISFRAMEBUFFERPROC)get_proc("glIsFramebuffer");
	gl3wBindFramebuffer = (PFNGLBINDFRAMEBUFFERPROC)get_proc("glBindFramebuffer");
	gl3wDeleteFramebuffers = (PFNGLDELETEFRAMEBUFFERSPROC)get_proc("glDeleteFramebuffers");
	gl3wGenFramebuffers = (PFNGLGENFRAMEBUFFERSPROC)get_proc("glGenFramebuffers");
	gl3wCheckFramebufferStatus = (PFNGLCHECKFRAMEBUFFERSTATUSPROC)get_proc("glCheckFramebufferStatus");
	gl3wFramebufferTexture1D = (PFNGLFRAMEBUFFERTEXTURE1DPROC)get_proc("glFramebufferTexture1D");
	gl3wFramebufferTexture2D = (PFNGLFRAMEBUFFERTEXTURE2DPROC)get_proc("glFramebufferTexture2D");
	gl3wFramebufferTexture3D = (PFNGLFRAMEBUFFERTEXTURE3DPROC)get_proc("glFramebufferTexture3D");
	gl3wFramebufferRenderbuffer = (PFNGLFRAMEBUFFERRENDERBUFFERPROC)get_proc("glFramebufferRenderbuffer");
	gl3wGetFramebufferAttachmentParameteriv = (PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC)get_proc("glGetFramebufferAttachmentParameteriv");
	gl3wGenerateMipmap = (PFNGLGENERATEMIPMAPPROC)get_proc("glGenerateMipmap");
	gl3wBlitFramebuffer = (PFNGLBLITFRAMEBUFFERPROC)get_proc("glBlitFramebuffer");
	gl3wRenderbufferStorageMultisample = (PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC)get_proc("glRenderbufferStorageMultisample");
	gl3wFramebufferTextureLayer = (PFNGLFRAMEBUFFERTEXTURELAYERPROC)get_proc("glFramebufferTextureLayer");
	gl3wMapBufferRange = (PFNGLMAPBUFFERRANGEPROC)get_proc("glMapBufferRange");
	gl3wFlushMappedBufferRange = (PFNGLFLUSHMAPPEDBUFFERRANGEPROC)get_proc("glFlushMappedBufferRange");
	gl3wBindVertexArray = (PFNGLBINDVERTEXARRAYPROC)get_proc("glBindVertexArray");
	gl3wDeleteVertexArrays = (PFNGLDELETEVERTEXARRAYSPROC)get_proc("glDeleteVertexArrays");
	gl3wGenVertexArrays = (PFNGLGENVERTEXARRAYSPROC)get_proc("glGenVertexArrays");
	gl3wIsVertexArray = (PFNGLISVERTEXARRAYPROC)get_proc("glIsVertexArray");
	gl3wGetUniformIndices = (PFNGLGETUNIFORMINDICESPROC)get_proc("glGetUniformIndices");
	gl3wGetActiveUniformsiv = (PFNGLGETACTIVEUNIFORMSIVPROC)get_proc("glGetActiveUniformsiv");
	gl3wGetActiveUniformName = (PFNGLGETACTIVEUNIFORMNAMEPROC)get_proc("glGetActiveUniformName");
	gl3wGetUniformBlockIndex = (PFNGLGETUNIFORMBLOCKINDEXPROC)get_proc("glGetUniformBlockIndex");
	gl3wGetActiveUniformBlockiv = (PFNGLGETACTIVEUNIFORMBLOCKIVPROC)get_proc("glGetActiveUniformBlockiv");
	gl3wGetActiveUniformBlockName = (PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC)get_proc("glGetActiveUniformBlockName");
	gl3wUniformBlockBinding = (PFNGLUNIFORMBLOCKBINDINGPROC)get_proc("glUniformBlockBinding");
	gl3wCopyBufferSubData = (PFNGLCOPYBUFFERSUBDATAPROC)get_proc("glCopyBufferSubData");
	gl3wDrawElementsBaseVertex = (PFNGLDRAWELEMENTSBASEVERTEXPROC)get_proc("glDrawElementsBaseVertex");
	gl3wDrawRangeElementsBaseVertex = (PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC)get_proc("glDrawRangeElementsBaseVertex");
	gl3wDrawElementsInstancedBaseVertex = (PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC)get_proc("glDrawElementsInstancedBaseVertex");
	gl3wMultiDrawElementsBaseVertex = (PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC)get_proc("glMultiDrawElementsBaseVertex");
	gl3wProvokingVertex = (PFNGLPROVOKINGVERTEXPROC)get_proc("glProvokingVertex");
	gl3wFenceSync = (PFNGLFENCESYNCPROC)get_proc("glFenceSync");
	gl3wIsSync = (PFNGLISSYNCPROC)get_proc("glIsSync");
	gl3wDeleteSync = (PFNGLDELETESYNCPROC)get_proc("glDeleteSync");
	gl3wClientWaitSync = (PFNGLCLIENTWAITSYNCPROC)get_proc("glClientWaitSync");
	gl3wWaitSync = (PFNGLWAITSYNCPROC)get_proc("glWaitSync");
	gl3wGetInteger64v = (PFNGLGETINTEGER64VPROC)get_proc("glGetInteger64v");
	gl3wGetSynciv = (PFNGLGETSYNCIVPROC)get_proc("glGetSynciv");
	gl3wTexImage2DMultisample = (PFNGLTEXIMAGE2DMULTISAMPLEPROC)get_proc("glTexImage2DMultisample");
	gl3wTexImage3DMultisample = (PFNGLTEXIMAGE3DMULTISAMPLEPROC)get_proc("glTexImage3DMultisample");
	gl3wGetMultisamplefv = (PFNGLGETMULTISAMPLEFVPROC)get_proc("glGetMultisamplefv");
	gl3wSampleMaski = (PFNGLSAMPLEMASKIPROC)get_proc("glSampleMaski");
	gl3wBlendEquationiARB = (PFNGLBLENDEQUATIONIARBPROC)get_proc("glBlendEquationiARB");
	gl3wBlendEquationSeparateiARB = (PFNGLBLENDEQUATIONSEPARATEIARBPROC)get_proc("glBlendEquationSeparateiARB");
	gl3wBlendFunciARB = (PFNGLBLENDFUNCIARBPROC)get_proc("glBlendFunciARB");
	gl3wBlendFuncSeparateiARB = (PFNGLBLENDFUNCSEPARATEIARBPROC)get_proc("glBlendFuncSeparateiARB");
	gl3wMinSampleShadingARB = (PFNGLMINSAMPLESHADINGARBPROC)get_proc("glMinSampleShadingARB");
	gl3wNamedStringARB = (PFNGLNAMEDSTRINGARBPROC)get_proc("glNamedStringARB");
	gl3wDeleteNamedStringARB = (PFNGLDELETENAMEDSTRINGARBPROC)get_proc("glDeleteNamedStringARB");
	gl3wCompileShaderIncludeARB = (PFNGLCOMPILESHADERINCLUDEARBPROC)get_proc("glCompileShaderIncludeARB");
	gl3wIsNamedStringARB = (PFNGLISNAMEDSTRINGARBPROC)get_proc("glIsNamedStringARB");
	gl3wGetNamedStringARB = (PFNGLGETNAMEDSTRINGARBPROC)get_proc("glGetNamedStringARB");
	gl3wGetNamedStringivARB = (PFNGLGETNAMEDSTRINGIVARBPROC)get_proc("glGetNamedStringivARB");
	gl3wBindFragDataLocationIndexed = (PFNGLBINDFRAGDATALOCATIONINDEXEDPROC)get_proc("glBindFragDataLocationIndexed");
	gl3wGetFragDataIndex = (PFNGLGETFRAGDATAINDEXPROC)get_proc("glGetFragDataIndex");
	gl3wGenSamplers = (PFNGLGENSAMPLERSPROC)get_proc("glGenSamplers");
	gl3wDeleteSamplers = (PFNGLDELETESAMPLERSPROC)get_proc("glDeleteSamplers");
	gl3wIsSampler = (PFNGLISSAMPLERPROC)get_proc("glIsSampler");
	gl3wBindSampler = (PFNGLBINDSAMPLERPROC)get_proc("glBindSampler");
	gl3wSamplerParameteri = (PFNGLSAMPLERPARAMETERIPROC)get_proc("glSamplerParameteri");
	gl3wSamplerParameteriv = (PFNGLSAMPLERPARAMETERIVPROC)get_proc("glSamplerParameteriv");
	gl3wSamplerParameterf = (PFNGLSAMPLERPARAMETERFPROC)get_proc("glSamplerParameterf");
	gl3wSamplerParameterfv = (PFNGLSAMPLERPARAMETERFVPROC)get_proc("glSamplerParameterfv");
	gl3wSamplerParameterIiv = (PFNGLSAMPLERPARAMETERIIVPROC)get_proc("glSamplerParameterIiv");
	gl3wSamplerParameterIuiv = (PFNGLSAMPLERPARAMETERIUIVPROC)get_proc("glSamplerParameterIuiv");
	gl3wGetSamplerParameteriv = (PFNGLGETSAMPLERPARAMETERIVPROC)get_proc("glGetSamplerParameteriv");
	gl3wGetSamplerParameterIiv = (PFNGLGETSAMPLERPARAMETERIIVPROC)get_proc("glGetSamplerParameterIiv");
	gl3wGetSamplerParameterfv = (PFNGLGETSAMPLERPARAMETERFVPROC)get_proc("glGetSamplerParameterfv");
	gl3wGetSamplerParameterIuiv = (PFNGLGETSAMPLERPARAMETERIUIVPROC)get_proc("glGetSamplerParameterIuiv");
	gl3wQueryCounter = (PFNGLQUERYCOUNTERPROC)get_proc("glQueryCounter");
	gl3wGetQueryObjecti64v = (PFNGLGETQUERYOBJECTI64VPROC)get_proc("glGetQueryObjecti64v");
	gl3wGetQueryObjectui64v = (PFNGLGETQUERYOBJECTUI64VPROC)get_proc("glGetQueryObjectui64v");
	gl3wVertexP2ui = (PFNGLVERTEXP2UIPROC)get_proc("glVertexP2ui");
	gl3wVertexP2uiv = (PFNGLVERTEXP2UIVPROC)get_proc("glVertexP2uiv");
	gl3wVertexP3ui = (PFNGLVERTEXP3UIPROC)get_proc("glVertexP3ui");
	gl3wVertexP3uiv = (PFNGLVERTEXP3UIVPROC)get_proc("glVertexP3uiv");
	gl3wVertexP4ui = (PFNGLVERTEXP4UIPROC)get_proc("glVertexP4ui");
	gl3wVertexP4uiv = (PFNGLVERTEXP4UIVPROC)get_proc("glVertexP4uiv");
	gl3wTexCoordP1ui = (PFNGLTEXCOORDP1UIPROC)get_proc("glTexCoordP1ui");
	gl3wTexCoordP1uiv = (PFNGLTEXCOORDP1UIVPROC)get_proc("glTexCoordP1uiv");
	gl3wTexCoordP2ui = (PFNGLTEXCOORDP2UIPROC)get_proc("glTexCoordP2ui");
	gl3wTexCoordP2uiv = (PFNGLTEXCOORDP2UIVPROC)get_proc("glTexCoordP2uiv");
	gl3wTexCoordP3ui = (PFNGLTEXCOORDP3UIPROC)get_proc("glTexCoordP3ui");
	gl3wTexCoordP3uiv = (PFNGLTEXCOORDP3UIVPROC)get_proc("glTexCoordP3uiv");
	gl3wTexCoordP4ui = (PFNGLTEXCOORDP4UIPROC)get_proc("glTexCoordP4ui");
	gl3wTexCoordP4uiv = (PFNGLTEXCOORDP4UIVPROC)get_proc("glTexCoordP4uiv");
	gl3wMultiTexCoordP1ui = (PFNGLMULTITEXCOORDP1UIPROC)get_proc("glMultiTexCoordP1ui");
	gl3wMultiTexCoordP1uiv = (PFNGLMULTITEXCOORDP1UIVPROC)get_proc("glMultiTexCoordP1uiv");
	gl3wMultiTexCoordP2ui = (PFNGLMULTITEXCOORDP2UIPROC)get_proc("glMultiTexCoordP2ui");
	gl3wMultiTexCoordP2uiv = (PFNGLMULTITEXCOORDP2UIVPROC)get_proc("glMultiTexCoordP2uiv");
	gl3wMultiTexCoordP3ui = (PFNGLMULTITEXCOORDP3UIPROC)get_proc("glMultiTexCoordP3ui");
	gl3wMultiTexCoordP3uiv = (PFNGLMULTITEXCOORDP3UIVPROC)get_proc("glMultiTexCoordP3uiv");
	gl3wMultiTexCoordP4ui = (PFNGLMULTITEXCOORDP4UIPROC)get_proc("glMultiTexCoordP4ui");
	gl3wMultiTexCoordP4uiv = (PFNGLMULTITEXCOORDP4UIVPROC)get_proc("glMultiTexCoordP4uiv");
	gl3wNormalP3ui = (PFNGLNORMALP3UIPROC)get_proc("glNormalP3ui");
	gl3wNormalP3uiv = (PFNGLNORMALP3UIVPROC)get_proc("glNormalP3uiv");
	gl3wColorP3ui = (PFNGLCOLORP3UIPROC)get_proc("glColorP3ui");
	gl3wColorP3uiv = (PFNGLCOLORP3UIVPROC)get_proc("glColorP3uiv");
	gl3wColorP4ui = (PFNGLCOLORP4UIPROC)get_proc("glColorP4ui");
	gl3wColorP4uiv = (PFNGLCOLORP4UIVPROC)get_proc("glColorP4uiv");
	gl3wSecondaryColorP3ui = (PFNGLSECONDARYCOLORP3UIPROC)get_proc("glSecondaryColorP3ui");
	gl3wSecondaryColorP3uiv = (PFNGLSECONDARYCOLORP3UIVPROC)get_proc("glSecondaryColorP3uiv");
	gl3wVertexAttribP1ui = (PFNGLVERTEXATTRIBP1UIPROC)get_proc("glVertexAttribP1ui");
	gl3wVertexAttribP1uiv = (PFNGLVERTEXATTRIBP1UIVPROC)get_proc("glVertexAttribP1uiv");
	gl3wVertexAttribP2ui = (PFNGLVERTEXATTRIBP2UIPROC)get_proc("glVertexAttribP2ui");
	gl3wVertexAttribP2uiv = (PFNGLVERTEXATTRIBP2UIVPROC)get_proc("glVertexAttribP2uiv");
	gl3wVertexAttribP3ui = (PFNGLVERTEXATTRIBP3UIPROC)get_proc("glVertexAttribP3ui");
	gl3wVertexAttribP3uiv = (PFNGLVERTEXATTRIBP3UIVPROC)get_proc("glVertexAttribP3uiv");
	gl3wVertexAttribP4ui = (PFNGLVERTEXATTRIBP4UIPROC)get_proc("glVertexAttribP4ui");
	gl3wVertexAttribP4uiv = (PFNGLVERTEXATTRIBP4UIVPROC)get_proc("glVertexAttribP4uiv");
	gl3wDrawArraysIndirect = (PFNGLDRAWARRAYSINDIRECTPROC)get_proc("glDrawArraysIndirect");
	gl3wDrawElementsIndirect = (PFNGLDRAWELEMENTSINDIRECTPROC)get_proc("glDrawElementsIndirect");
	gl3wUniform1d = (PFNGLUNIFORM1DPROC)get_proc("glUniform1d");
	gl3wUniform2d = (PFNGLUNIFORM2DPROC)get_proc("glUniform2d");
	gl3wUniform3d = (PFNGLUNIFORM3DPROC)get_proc("glUniform3d");
	gl3wUniform4d = (PFNGLUNIFORM4DPROC)get_proc("glUniform4d");
	gl3wUniform1dv = (PFNGLUNIFORM1DVPROC)get_proc("glUniform1dv");
	gl3wUniform2dv = (PFNGLUNIFORM2DVPROC)get_proc("glUniform2dv");
	gl3wUniform3dv = (PFNGLUNIFORM3DVPROC)get_proc("glUniform3dv");
	gl3wUniform4dv = (PFNGLUNIFORM4DVPROC)get_proc("glUniform4dv");
	gl3wUniformMatrix2dv = (PFNGLUNIFORMMATRIX2DVPROC)get_proc("glUniformMatrix2dv");
	gl3wUniformMatrix3dv = (PFNGLUNIFORMMATRIX3DVPROC)get_proc("glUniformMatrix3dv");
	gl3wUniformMatrix4dv = (PFNGLUNIFORMMATRIX4DVPROC)get_proc("glUniformMatrix4dv");
	gl3wUniformMatrix2x3dv = (PFNGLUNIFORMMATRIX2X3DVPROC)get_proc("glUniformMatrix2x3dv");
	gl3wUniformMatrix2x4dv = (PFNGLUNIFORMMATRIX2X4DVPROC)get_proc("glUniformMatrix2x4dv");
	gl3wUniformMatrix3x2dv = (PFNGLUNIFORMMATRIX3X2DVPROC)get_proc("glUniformMatrix3x2dv");
	gl3wUniformMatrix3x4dv = (PFNGLUNIFORMMATRIX3X4DVPROC)get_proc("glUniformMatrix3x4dv");
	gl3wUniformMatrix4x2dv = (PFNGLUNIFORMMATRIX4X2DVPROC)get_proc("glUniformMatrix4x2dv");
	gl3wUniformMatrix4x3dv = (PFNGLUNIFORMMATRIX4X3DVPROC)get_proc("glUniformMatrix4x3dv");
	gl3wGetUniformdv = (PFNGLGETUNIFORMDVPROC)get_proc("glGetUniformdv");
	gl3wGetSubroutineUniformLocation = (PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC)get_proc("glGetSubroutineUniformLocation");
	gl3wGetSubroutineIndex = (PFNGLGETSUBROUTINEINDEXPROC)get_proc("glGetSubroutineIndex");
	gl3wGetActiveSubroutineUniformiv = (PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC)get_proc("glGetActiveSubroutineUniformiv");
	gl3wGetActiveSubroutineUniformName = (PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC)get_proc("glGetActiveSubroutineUniformName");
	gl3wGetActiveSubroutineName = (PFNGLGETACTIVESUBROUTINENAMEPROC)get_proc("glGetActiveSubroutineName");
	gl3wUniformSubroutinesuiv = (PFNGLUNIFORMSUBROUTINESUIVPROC)get_proc("glUniformSubroutinesuiv");
	gl3wGetUniformSubroutineuiv = (PFNGLGETUNIFORMSUBROUTINEUIVPROC)get_proc("glGetUniformSubroutineuiv");
	gl3wGetProgramStageiv = (PFNGLGETPROGRAMSTAGEIVPROC)get_proc("glGetProgramStageiv");
	gl3wPatchParameteri = (PFNGLPATCHPARAMETERIPROC)get_proc("glPatchParameteri");
	gl3wPatchParameterfv = (PFNGLPATCHPARAMETERFVPROC)get_proc("glPatchParameterfv");
	gl3wBindTransformFeedback = (PFNGLBINDTRANSFORMFEEDBACKPROC)get_proc("glBindTransformFeedback");
	gl3wDeleteTransformFeedbacks = (PFNGLDELETETRANSFORMFEEDBACKSPROC)get_proc("glDeleteTransformFeedbacks");
	gl3wGenTransformFeedbacks = (PFNGLGENTRANSFORMFEEDBACKSPROC)get_proc("glGenTransformFeedbacks");
	gl3wIsTransformFeedback = (PFNGLISTRANSFORMFEEDBACKPROC)get_proc("glIsTransformFeedback");
	gl3wPauseTransformFeedback = (PFNGLPAUSETRANSFORMFEEDBACKPROC)get_proc("glPauseTransformFeedback");
	gl3wResumeTransformFeedback = (PFNGLRESUMETRANSFORMFEEDBACKPROC)get_proc("glResumeTransformFeedback");
	gl3wDrawTransformFeedback = (PFNGLDRAWTRANSFORMFEEDBACKPROC)get_proc("glDrawTransformFeedback");
	gl3wDrawTransformFeedbackStream = (PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC)get_proc("glDrawTransformFeedbackStream");
	gl3wBeginQueryIndexed = (PFNGLBEGINQUERYINDEXEDPROC)get_proc("glBeginQueryIndexed");
	gl3wEndQueryIndexed = (PFNGLENDQUERYINDEXEDPROC)get_proc("glEndQueryIndexed");
	gl3wGetQueryIndexediv = (PFNGLGETQUERYINDEXEDIVPROC)get_proc("glGetQueryIndexediv");
	gl3wReleaseShaderCompiler = (PFNGLRELEASESHADERCOMPILERPROC)get_proc("glReleaseShaderCompiler");
	gl3wShaderBinary = (PFNGLSHADERBINARYPROC)get_proc("glShaderBinary");
	gl3wGetShaderPrecisionFormat = (PFNGLGETSHADERPRECISIONFORMATPROC)get_proc("glGetShaderPrecisionFormat");
	gl3wDepthRangef = (PFNGLDEPTHRANGEFPROC)get_proc("glDepthRangef");
	gl3wClearDepthf = (PFNGLCLEARDEPTHFPROC)get_proc("glClearDepthf");
	gl3wGetProgramBinary = (PFNGLGETPROGRAMBINARYPROC)get_proc("glGetProgramBinary");
	gl3wProgramBinary = (PFNGLPROGRAMBINARYPROC)get_proc("glProgramBinary");
	gl3wProgramParameteri = (PFNGLPROGRAMPARAMETERIPROC)get_proc("glProgramParameteri");
	gl3wUseProgramStages = (PFNGLUSEPROGRAMSTAGESPROC)get_proc("glUseProgramStages");
	gl3wActiveShaderProgram = (PFNGLACTIVESHADERPROGRAMPROC)get_proc("glActiveShaderProgram");
	gl3wCreateShaderProgramv = (PFNGLCREATESHADERPROGRAMVPROC)get_proc("glCreateShaderProgramv");
	gl3wBindProgramPipeline = (PFNGLBINDPROGRAMPIPELINEPROC)get_proc("glBindProgramPipeline");
	gl3wDeleteProgramPipelines = (PFNGLDELETEPROGRAMPIPELINESPROC)get_proc("glDeleteProgramPipelines");
	gl3wGenProgramPipelines = (PFNGLGENPROGRAMPIPELINESPROC)get_proc("glGenProgramPipelines");
	gl3wIsProgramPipeline = (PFNGLISPROGRAMPIPELINEPROC)get_proc("glIsProgramPipeline");
	gl3wGetProgramPipelineiv = (PFNGLGETPROGRAMPIPELINEIVPROC)get_proc("glGetProgramPipelineiv");
	gl3wProgramUniform1i = (PFNGLPROGRAMUNIFORM1IPROC)get_proc("glProgramUniform1i");
	gl3wProgramUniform1iv = (PFNGLPROGRAMUNIFORM1IVPROC)get_proc("glProgramUniform1iv");
	gl3wProgramUniform1f = (PFNGLPROGRAMUNIFORM1FPROC)get_proc("glProgramUniform1f");
	gl3wProgramUniform1fv = (PFNGLPROGRAMUNIFORM1FVPROC)get_proc("glProgramUniform1fv");
	gl3wProgramUniform1d = (PFNGLPROGRAMUNIFORM1DPROC)get_proc("glProgramUniform1d");
	gl3wProgramUniform1dv = (PFNGLPROGRAMUNIFORM1DVPROC)get_proc("glProgramUniform1dv");
	gl3wProgramUniform1ui = (PFNGLPROGRAMUNIFORM1UIPROC)get_proc("glProgramUniform1ui");
	gl3wProgramUniform1uiv = (PFNGLPROGRAMUNIFORM1UIVPROC)get_proc("glProgramUniform1uiv");
	gl3wProgramUniform2i = (PFNGLPROGRAMUNIFORM2IPROC)get_proc("glProgramUniform2i");
	gl3wProgramUniform2iv = (PFNGLPROGRAMUNIFORM2IVPROC)get_proc("glProgramUniform2iv");
	gl3wProgramUniform2f = (PFNGLPROGRAMUNIFORM2FPROC)get_proc("glProgramUniform2f");
	gl3wProgramUniform2fv = (PFNGLPROGRAMUNIFORM2FVPROC)get_proc("glProgramUniform2fv");
	gl3wProgramUniform2d = (PFNGLPROGRAMUNIFORM2DPROC)get_proc("glProgramUniform2d");
	gl3wProgramUniform2dv = (PFNGLPROGRAMUNIFORM2DVPROC)get_proc("glProgramUniform2dv");
	gl3wProgramUniform2ui = (PFNGLPROGRAMUNIFORM2UIPROC)get_proc("glProgramUniform2ui");
	gl3wProgramUniform2uiv = (PFNGLPROGRAMUNIFORM2UIVPROC)get_proc("glProgramUniform2uiv");
	gl3wProgramUniform3i = (PFNGLPROGRAMUNIFORM3IPROC)get_proc("glProgramUniform3i");
	gl3wProgramUniform3iv = (PFNGLPROGRAMUNIFORM3IVPROC)get_proc("glProgramUniform3iv");
	gl3wProgramUniform3f = (PFNGLPROGRAMUNIFORM3FPROC)get_proc("glProgramUniform3f");
	gl3wProgramUniform3fv = (PFNGLPROGRAMUNIFORM3FVPROC)get_proc("glProgramUniform3fv");
	gl3wProgramUniform3d = (PFNGLPROGRAMUNIFORM3DPROC)get_proc("glProgramUniform3d");
	gl3wProgramUniform3dv = (PFNGLPROGRAMUNIFORM3DVPROC)get_proc("glProgramUniform3dv");
	gl3wProgramUniform3ui = (PFNGLPROGRAMUNIFORM3UIPROC)get_proc("glProgramUniform3ui");
	gl3wProgramUniform3uiv = (PFNGLPROGRAMUNIFORM3UIVPROC)get_proc("glProgramUniform3uiv");
	gl3wProgramUniform4i = (PFNGLPROGRAMUNIFORM4IPROC)get_proc("glProgramUniform4i");
	gl3wProgramUniform4iv = (PFNGLPROGRAMUNIFORM4IVPROC)get_proc("glProgramUniform4iv");
	gl3wProgramUniform4f = (PFNGLPROGRAMUNIFORM4FPROC)get_proc("glProgramUniform4f");
	gl3wProgramUniform4fv = (PFNGLPROGRAMUNIFORM4FVPROC)get_proc("glProgramUniform4fv");
	gl3wProgramUniform4d = (PFNGLPROGRAMUNIFORM4DPROC)get_proc("glProgramUniform4d");
	gl3wProgramUniform4dv = (PFNGLPROGRAMUNIFORM4DVPROC)get_proc("glProgramUniform4dv");
	gl3wProgramUniform4ui = (PFNGLPROGRAMUNIFORM4UIPROC)get_proc("glProgramUniform4ui");
	gl3wProgramUniform4uiv = (PFNGLPROGRAMUNIFORM4UIVPROC)get_proc("glProgramUniform4uiv");
	gl3wProgramUniformMatrix2fv = (PFNGLPROGRAMUNIFORMMATRIX2FVPROC)get_proc("glProgramUniformMatrix2fv");
	gl3wProgramUniformMatrix3fv = (PFNGLPROGRAMUNIFORMMATRIX3FVPROC)get_proc("glProgramUniformMatrix3fv");
	gl3wProgramUniformMatrix4fv = (PFNGLPROGRAMUNIFORMMATRIX4FVPROC)get_proc("glProgramUniformMatrix4fv");
	gl3wProgramUniformMatrix2dv = (PFNGLPROGRAMUNIFORMMATRIX2DVPROC)get_proc("glProgramUniformMatrix2dv");
	gl3wProgramUniformMatrix3dv = (PFNGLPROGRAMUNIFORMMATRIX3DVPROC)get_proc("glProgramUniformMatrix3dv");
	gl3wProgramUniformMatrix4dv = (PFNGLPROGRAMUNIFORMMATRIX4DVPROC)get_proc("glProgramUniformMatrix4dv");
	gl3wProgramUniformMatrix2x3fv = (PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC)get_proc("glProgramUniformMatrix2x3fv");
	gl3wProgramUniformMatrix3x2fv = (PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC)get_proc("glProgramUniformMatrix3x2fv");
	gl3wProgramUniformMatrix2x4fv = (PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC)get_proc("glProgramUniformMatrix2x4fv");
	gl3wProgramUniformMatrix4x2fv = (PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC)get_proc("glProgramUniformMatrix4x2fv");
	gl3wProgramUniformMatrix3x4fv = (PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC)get_proc("glProgramUniformMatrix3x4fv");
	gl3wProgramUniformMatrix4x3fv = (PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC)get_proc("glProgramUniformMatrix4x3fv");
	gl3wProgramUniformMatrix2x3dv = (PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC)get_proc("glProgramUniformMatrix2x3dv");
	gl3wProgramUniformMatrix3x2dv = (PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC)get_proc("glProgramUniformMatrix3x2dv");
	gl3wProgramUniformMatrix2x4dv = (PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC)get_proc("glProgramUniformMatrix2x4dv");
	gl3wProgramUniformMatrix4x2dv = (PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC)get_proc("glProgramUniformMatrix4x2dv");
	gl3wProgramUniformMatrix3x4dv = (PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC)get_proc("glProgramUniformMatrix3x4dv");
	gl3wProgramUniformMatrix4x3dv = (PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC)get_proc("glProgramUniformMatrix4x3dv");
	gl3wValidateProgramPipeline = (PFNGLVALIDATEPROGRAMPIPELINEPROC)get_proc("glValidateProgramPipeline");
	gl3wGetProgramPipelineInfoLog = (PFNGLGETPROGRAMPIPELINEINFOLOGPROC)get_proc("glGetProgramPipelineInfoLog");
	gl3wVertexAttribL1d = (PFNGLVERTEXATTRIBL1DPROC)get_proc("glVertexAttribL1d");
	gl3wVertexAttribL2d = (PFNGLVERTEXATTRIBL2DPROC)get_proc("glVertexAttribL2d");
	gl3wVertexAttribL3d = (PFNGLVERTEXATTRIBL3DPROC)get_proc("glVertexAttribL3d");
	gl3wVertexAttribL4d = (PFNGLVERTEXATTRIBL4DPROC)get_proc("glVertexAttribL4d");
	gl3wVertexAttribL1dv = (PFNGLVERTEXATTRIBL1DVPROC)get_proc("glVertexAttribL1dv");
	gl3wVertexAttribL2dv = (PFNGLVERTEXATTRIBL2DVPROC)get_proc("glVertexAttribL2dv");
	gl3wVertexAttribL3dv = (PFNGLVERTEXATTRIBL3DVPROC)get_proc("glVertexAttribL3dv");
	gl3wVertexAttribL4dv = (PFNGLVERTEXATTRIBL4DVPROC)get_proc("glVertexAttribL4dv");
	gl3wVertexAttribLPointer = (PFNGLVERTEXATTRIBLPOINTERPROC)get_proc("glVertexAttribLPointer");
	gl3wGetVertexAttribLdv = (PFNGLGETVERTEXATTRIBLDVPROC)get_proc("glGetVertexAttribLdv");
	gl3wViewportArrayv = (PFNGLVIEWPORTARRAYVPROC)get_proc("glViewportArrayv");
	gl3wViewportIndexedf = (PFNGLVIEWPORTINDEXEDFPROC)get_proc("glViewportIndexedf");
	gl3wViewportIndexedfv = (PFNGLVIEWPORTINDEXEDFVPROC)get_proc("glViewportIndexedfv");
	gl3wScissorArrayv = (PFNGLSCISSORARRAYVPROC)get_proc("glScissorArrayv");
	gl3wScissorIndexed = (PFNGLSCISSORINDEXEDPROC)get_proc("glScissorIndexed");
	gl3wScissorIndexedv = (PFNGLSCISSORINDEXEDVPROC)get_proc("glScissorIndexedv");
	gl3wDepthRangeArrayv = (PFNGLDEPTHRANGEARRAYVPROC)get_proc("glDepthRangeArrayv");
	gl3wDepthRangeIndexed = (PFNGLDEPTHRANGEINDEXEDPROC)get_proc("glDepthRangeIndexed");
	gl3wGetFloati_v = (PFNGLGETFLOATI_VPROC)get_proc("glGetFloati_v");
	gl3wGetDoublei_v = (PFNGLGETDOUBLEI_VPROC)get_proc("glGetDoublei_v");
	gl3wCreateSyncFromCLeventARB = (PFNGLCREATESYNCFROMCLEVENTARBPROC)get_proc("glCreateSyncFromCLeventARB");
	gl3wDebugMessageControlARB = (PFNGLDEBUGMESSAGECONTROLARBPROC)get_proc("glDebugMessageControlARB");
	gl3wDebugMessageInsertARB = (PFNGLDEBUGMESSAGEINSERTARBPROC)get_proc("glDebugMessageInsertARB");
	gl3wDebugMessageCallbackARB = (PFNGLDEBUGMESSAGECALLBACKARBPROC)get_proc("glDebugMessageCallbackARB");
	gl3wGetDebugMessageLogARB = (PFNGLGETDEBUGMESSAGELOGARBPROC)get_proc("glGetDebugMessageLogARB");
	gl3wGetGraphicsResetStatusARB = (PFNGLGETGRAPHICSRESETSTATUSARBPROC)get_proc("glGetGraphicsResetStatusARB");
	gl3wGetnTexImageARB = (PFNGLGETNTEXIMAGEARBPROC)get_proc("glGetnTexImageARB");
	gl3wReadnPixelsARB = (PFNGLREADNPIXELSARBPROC)get_proc("glReadnPixelsARB");
	gl3wGetnCompressedTexImageARB = (PFNGLGETNCOMPRESSEDTEXIMAGEARBPROC)get_proc("glGetnCompressedTexImageARB");
	gl3wGetnUniformfvARB = (PFNGLGETNUNIFORMFVARBPROC)get_proc("glGetnUniformfvARB");
	gl3wGetnUniformivARB = (PFNGLGETNUNIFORMIVARBPROC)get_proc("glGetnUniformivARB");
	gl3wGetnUniformuivARB = (PFNGLGETNUNIFORMUIVARBPROC)get_proc("glGetnUniformuivARB");
	gl3wGetnUniformdvARB = (PFNGLGETNUNIFORMDVARBPROC)get_proc("glGetnUniformdvARB");
	gl3wDrawArraysInstancedBaseInstance = (PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC)get_proc("glDrawArraysInstancedBaseInstance");
	gl3wDrawElementsInstancedBaseInstance = (PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC)get_proc("glDrawElementsInstancedBaseInstance");
	gl3wDrawElementsInstancedBaseVertexBaseInstance = (PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC)get_proc("glDrawElementsInstancedBaseVertexBaseInstance");
	gl3wDrawTransformFeedbackInstanced = (PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC)get_proc("glDrawTransformFeedbackInstanced");
	gl3wDrawTransformFeedbackStreamInstanced = (PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC)get_proc("glDrawTransformFeedbackStreamInstanced");
	gl3wGetInternalformativ = (PFNGLGETINTERNALFORMATIVPROC)get_proc("glGetInternalformativ");
	gl3wGetActiveAtomicCounterBufferiv = (PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC)get_proc("glGetActiveAtomicCounterBufferiv");
	gl3wBindImageTexture = (PFNGLBINDIMAGETEXTUREPROC)get_proc("glBindImageTexture");
	gl3wMemoryBarrier = (PFNGLMEMORYBARRIERPROC)get_proc("glMemoryBarrier");
	gl3wTexStorage1D = (PFNGLTEXSTORAGE1DPROC)get_proc("glTexStorage1D");
	gl3wTexStorage2D = (PFNGLTEXSTORAGE2DPROC)get_proc("glTexStorage2D");
	gl3wTexStorage3D = (PFNGLTEXSTORAGE3DPROC)get_proc("glTexStorage3D");
	gl3wTextureStorage1DEXT = (PFNGLTEXTURESTORAGE1DEXTPROC)get_proc("glTextureStorage1DEXT");
	gl3wTextureStorage2DEXT = (PFNGLTEXTURESTORAGE2DEXTPROC)get_proc("glTextureStorage2DEXT");
	gl3wTextureStorage3DEXT = (PFNGLTEXTURESTORAGE3DEXTPROC)get_proc("glTextureStorage3DEXT");
	gl3wDebugMessageControl = (PFNGLDEBUGMESSAGECONTROLPROC)get_proc("glDebugMessageControl");
	gl3wDebugMessageInsert = (PFNGLDEBUGMESSAGEINSERTPROC)get_proc("glDebugMessageInsert");
	gl3wDebugMessageCallback = (PFNGLDEBUGMESSAGECALLBACKPROC)get_proc("glDebugMessageCallback");
	gl3wGetDebugMessageLog = (PFNGLGETDEBUGMESSAGELOGPROC)get_proc("glGetDebugMessageLog");
	gl3wPushDebugGroup = (PFNGLPUSHDEBUGGROUPPROC)get_proc("glPushDebugGroup");
	gl3wPopDebugGroup = (PFNGLPOPDEBUGGROUPPROC)get_proc("glPopDebugGroup");
	gl3wObjectLabel = (PFNGLOBJECTLABELPROC)get_proc("glObjectLabel");
	gl3wGetObjectLabel = (PFNGLGETOBJECTLABELPROC)get_proc("glGetObjectLabel");
	gl3wObjectPtrLabel = (PFNGLOBJECTPTRLABELPROC)get_proc("glObjectPtrLabel");
	gl3wGetObjectPtrLabel = (PFNGLGETOBJECTPTRLABELPROC)get_proc("glGetObjectPtrLabel");
	gl3wClearBufferData = (PFNGLCLEARBUFFERDATAPROC)get_proc("glClearBufferData");
	gl3wClearBufferSubData = (PFNGLCLEARBUFFERSUBDATAPROC)get_proc("glClearBufferSubData");
	gl3wClearNamedBufferDataEXT = (PFNGLCLEARNAMEDBUFFERDATAEXTPROC)get_proc("glClearNamedBufferDataEXT");
	gl3wClearNamedBufferSubDataEXT = (PFNGLCLEARNAMEDBUFFERSUBDATAEXTPROC)get_proc("glClearNamedBufferSubDataEXT");
	gl3wDispatchCompute = (PFNGLDISPATCHCOMPUTEPROC)get_proc("glDispatchCompute");
	gl3wDispatchComputeIndirect = (PFNGLDISPATCHCOMPUTEINDIRECTPROC)get_proc("glDispatchComputeIndirect");
	gl3wCopyImageSubData = (PFNGLCOPYIMAGESUBDATAPROC)get_proc("glCopyImageSubData");
	gl3wTextureView = (PFNGLTEXTUREVIEWPROC)get_proc("glTextureView");
	gl3wBindVertexBuffer = (PFNGLBINDVERTEXBUFFERPROC)get_proc("glBindVertexBuffer");
	gl3wVertexAttribFormat = (PFNGLVERTEXATTRIBFORMATPROC)get_proc("glVertexAttribFormat");
	gl3wVertexAttribIFormat = (PFNGLVERTEXATTRIBIFORMATPROC)get_proc("glVertexAttribIFormat");
	gl3wVertexAttribLFormat = (PFNGLVERTEXATTRIBLFORMATPROC)get_proc("glVertexAttribLFormat");
	gl3wVertexAttribBinding = (PFNGLVERTEXATTRIBBINDINGPROC)get_proc("glVertexAttribBinding");
	gl3wVertexBindingDivisor = (PFNGLVERTEXBINDINGDIVISORPROC)get_proc("glVertexBindingDivisor");
	gl3wVertexArrayBindVertexBufferEXT = (PFNGLVERTEXARRAYBINDVERTEXBUFFEREXTPROC)get_proc("glVertexArrayBindVertexBufferEXT");
	gl3wVertexArrayVertexAttribFormatEXT = (PFNGLVERTEXARRAYVERTEXATTRIBFORMATEXTPROC)get_proc("glVertexArrayVertexAttribFormatEXT");
	gl3wVertexArrayVertexAttribIFormatEXT = (PFNGLVERTEXARRAYVERTEXATTRIBIFORMATEXTPROC)get_proc("glVertexArrayVertexAttribIFormatEXT");
	gl3wVertexArrayVertexAttribLFormatEXT = (PFNGLVERTEXARRAYVERTEXATTRIBLFORMATEXTPROC)get_proc("glVertexArrayVertexAttribLFormatEXT");
	gl3wVertexArrayVertexAttribBindingEXT = (PFNGLVERTEXARRAYVERTEXATTRIBBINDINGEXTPROC)get_proc("glVertexArrayVertexAttribBindingEXT");
	gl3wVertexArrayVertexBindingDivisorEXT = (PFNGLVERTEXARRAYVERTEXBINDINGDIVISOREXTPROC)get_proc("glVertexArrayVertexBindingDivisorEXT");
	gl3wFramebufferParameteri = (PFNGLFRAMEBUFFERPARAMETERIPROC)get_proc("glFramebufferParameteri");
	gl3wGetFramebufferParameteriv = (PFNGLGETFRAMEBUFFERPARAMETERIVPROC)get_proc("glGetFramebufferParameteriv");
	gl3wNamedFramebufferParameteriEXT = (PFNGLNAMEDFRAMEBUFFERPARAMETERIEXTPROC)get_proc("glNamedFramebufferParameteriEXT");
	gl3wGetNamedFramebufferParameterivEXT = (PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVEXTPROC)get_proc("glGetNamedFramebufferParameterivEXT");
	gl3wGetInternalformati64v = (PFNGLGETINTERNALFORMATI64VPROC)get_proc("glGetInternalformati64v");
	gl3wInvalidateTexSubImage = (PFNGLINVALIDATETEXSUBIMAGEPROC)get_proc("glInvalidateTexSubImage");
	gl3wInvalidateTexImage = (PFNGLINVALIDATETEXIMAGEPROC)get_proc("glInvalidateTexImage");
	gl3wInvalidateBufferSubData = (PFNGLINVALIDATEBUFFERSUBDATAPROC)get_proc("glInvalidateBufferSubData");
	gl3wInvalidateBufferData = (PFNGLINVALIDATEBUFFERDATAPROC)get_proc("glInvalidateBufferData");
	gl3wInvalidateFramebuffer = (PFNGLINVALIDATEFRAMEBUFFERPROC)get_proc("glInvalidateFramebuffer");
	gl3wInvalidateSubFramebuffer = (PFNGLINVALIDATESUBFRAMEBUFFERPROC)get_proc("glInvalidateSubFramebuffer");
	gl3wMultiDrawArraysIndirect = (PFNGLMULTIDRAWARRAYSINDIRECTPROC)get_proc("glMultiDrawArraysIndirect");
	gl3wMultiDrawElementsIndirect = (PFNGLMULTIDRAWELEMENTSINDIRECTPROC)get_proc("glMultiDrawElementsIndirect");
	gl3wGetProgramInterfaceiv = (PFNGLGETPROGRAMINTERFACEIVPROC)get_proc("glGetProgramInterfaceiv");
	gl3wGetProgramResourceIndex = (PFNGLGETPROGRAMRESOURCEINDEXPROC)get_proc("glGetProgramResourceIndex");
	gl3wGetProgramResourceName = (PFNGLGETPROGRAMRESOURCENAMEPROC)get_proc("glGetProgramResourceName");
	gl3wGetProgramResourceiv = (PFNGLGETPROGRAMRESOURCEIVPROC)get_proc("glGetProgramResourceiv");
	gl3wGetProgramResourceLocation = (PFNGLGETPROGRAMRESOURCELOCATIONPROC)get_proc("glGetProgramResourceLocation");
	gl3wGetProgramResourceLocationIndex = (PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC)get_proc("glGetProgramResourceLocationIndex");
	gl3wShaderStorageBlockBinding = (PFNGLSHADERSTORAGEBLOCKBINDINGPROC)get_proc("glShaderStorageBlockBinding");
	gl3wTexBufferRange = (PFNGLTEXBUFFERRANGEPROC)get_proc("glTexBufferRange");
	gl3wTextureBufferRangeEXT = (PFNGLTEXTUREBUFFERRANGEEXTPROC)get_proc("glTextureBufferRangeEXT");
	gl3wTexStorage2DMultisample = (PFNGLTEXSTORAGE2DMULTISAMPLEPROC)get_proc("glTexStorage2DMultisample");
	gl3wTexStorage3DMultisample = (PFNGLTEXSTORAGE3DMULTISAMPLEPROC)get_proc("glTexStorage3DMultisample");
	gl3wTextureStorage2DMultisampleEXT = (PFNGLTEXTURESTORAGE2DMULTISAMPLEEXTPROC)get_proc("glTextureStorage2DMultisampleEXT");
	gl3wTextureStorage3DMultisampleEXT = (PFNGLTEXTURESTORAGE3DMULTISAMPLEEXTPROC)get_proc("glTextureStorage3DMultisampleEXT");
}

```

`sakura/libs/opengl/gl3w.h`:

```h
#ifndef __gl3w_h_
#define __gl3w_h_

#include "glcorearb.h"

#ifndef __gl_h_
#define __gl_h_
#endif

#ifdef __cplusplus
extern "C" {
#endif

	/* gl3w api */
	int gl3wInit(void);
	int gl3wIsSupported(int major, int minor);
	void *gl3wGetProcAddress(const char *proc);

	/* OpenGL functions */
	extern PFNGLCULLFACEPROC gl3wCullFace;
	extern PFNGLFRONTFACEPROC gl3wFrontFace;
	extern PFNGLHINTPROC gl3wHint;
	extern PFNGLLINEWIDTHPROC gl3wLineWidth;
	extern PFNGLPOINTSIZEPROC gl3wPointSize;
	extern PFNGLPOLYGONMODEPROC gl3wPolygonMode;
	extern PFNGLSCISSORPROC gl3wScissor;
	extern PFNGLTEXPARAMETERFPROC gl3wTexParameterf;
	extern PFNGLTEXPARAMETERFVPROC gl3wTexParameterfv;
	extern PFNGLTEXPARAMETERIPROC gl3wTexParameteri;
	extern PFNGLTEXPARAMETERIVPROC gl3wTexParameteriv;
	extern PFNGLTEXIMAGE1DPROC gl3wTexImage1D;
	extern PFNGLTEXIMAGE2DPROC gl3wTexImage2D;
	extern PFNGLDRAWBUFFERPROC gl3wDrawBuffer;
	extern PFNGLCLEARPROC gl3wClear;
	extern PFNGLCLEARCOLORPROC gl3wClearColor;
	extern PFNGLCLEARSTENCILPROC gl3wClearStencil;
	extern PFNGLCLEARDEPTHPROC gl3wClearDepth;
	extern PFNGLSTENCILMASKPROC gl3wStencilMask;
	extern PFNGLCOLORMASKPROC gl3wColorMask;
	extern PFNGLDEPTHMASKPROC gl3wDepthMask;
	extern PFNGLDISABLEPROC gl3wDisable;
	extern PFNGLENABLEPROC gl3wEnable;
	extern PFNGLFINISHPROC gl3wFinish;
	extern PFNGLFLUSHPROC gl3wFlush;
	extern PFNGLBLENDFUNCPROC gl3wBlendFunc;
	extern PFNGLLOGICOPPROC gl3wLogicOp;
	extern PFNGLSTENCILFUNCPROC gl3wStencilFunc;
	extern PFNGLSTENCILOPPROC gl3wStencilOp;
	extern PFNGLDEPTHFUNCPROC gl3wDepthFunc;
	extern PFNGLPIXELSTOREFPROC gl3wPixelStoref;
	extern PFNGLPIXELSTOREIPROC gl3wPixelStorei;
	extern PFNGLREADBUFFERPROC gl3wReadBuffer;
	extern PFNGLREADPIXELSPROC gl3wReadPixels;
	extern PFNGLGETBOOLEANVPROC gl3wGetBooleanv;
	extern PFNGLGETDOUBLEVPROC gl3wGetDoublev;
	extern PFNGLGETERRORPROC gl3wGetError;
	extern PFNGLGETFLOATVPROC gl3wGetFloatv;
	extern PFNGLGETINTEGERVPROC gl3wGetIntegerv;
	extern PFNGLGETSTRINGPROC gl3wGetString;
	extern PFNGLGETTEXIMAGEPROC gl3wGetTexImage;
	extern PFNGLGETTEXPARAMETERFVPROC gl3wGetTexParameterfv;
	extern PFNGLGETTEXPARAMETERIVPROC gl3wGetTexParameteriv;
	extern PFNGLGETTEXLEVELPARAMETERFVPROC gl3wGetTexLevelParameterfv;
	extern PFNGLGETTEXLEVELPARAMETERIVPROC gl3wGetTexLevelParameteriv;
	extern PFNGLISENABLEDPROC gl3wIsEnabled;
	extern PFNGLDEPTHRANGEPROC gl3wDepthRange;
	extern PFNGLVIEWPORTPROC gl3wViewport;
	extern PFNGLDRAWARRAYSPROC gl3wDrawArrays;
	extern PFNGLDRAWELEMENTSPROC gl3wDrawElements;
	extern PFNGLGETPOINTERVPROC gl3wGetPointerv;
	extern PFNGLPOLYGONOFFSETPROC gl3wPolygonOffset;
	extern PFNGLCOPYTEXIMAGE1DPROC gl3wCopyTexImage1D;
	extern PFNGLCOPYTEXIMAGE2DPROC gl3wCopyTexImage2D;
	extern PFNGLCOPYTEXSUBIMAGE1DPROC gl3wCopyTexSubImage1D;
	extern PFNGLCOPYTEXSUBIMAGE2DPROC gl3wCopyTexSubImage2D;
	extern PFNGLTEXSUBIMAGE1DPROC gl3wTexSubImage1D;
	extern PFNGLTEXSUBIMAGE2DPROC gl3wTexSubImage2D;
	extern PFNGLBINDTEXTUREPROC gl3wBindTexture;
	extern PFNGLDELETETEXTURESPROC gl3wDeleteTextures;
	extern PFNGLGENTEXTURESPROC gl3wGenTextures;
	extern PFNGLISTEXTUREPROC gl3wIsTexture;
	extern PFNGLBLENDCOLORPROC gl3wBlendColor;
	extern PFNGLBLENDEQUATIONPROC gl3wBlendEquation;
	extern PFNGLDRAWRANGEELEMENTSPROC gl3wDrawRangeElements;
	extern PFNGLTEXIMAGE3DPROC gl3wTexImage3D;
	extern PFNGLTEXSUBIMAGE3DPROC gl3wTexSubImage3D;
	extern PFNGLCOPYTEXSUBIMAGE3DPROC gl3wCopyTexSubImage3D;
	extern PFNGLACTIVETEXTUREPROC gl3wActiveTexture;
	extern PFNGLSAMPLECOVERAGEPROC gl3wSampleCoverage;
	extern PFNGLCOMPRESSEDTEXIMAGE3DPROC gl3wCompressedTexImage3D;
	extern PFNGLCOMPRESSEDTEXIMAGE2DPROC gl3wCompressedTexImage2D;
	extern PFNGLCOMPRESSEDTEXIMAGE1DPROC gl3wCompressedTexImage1D;
	extern PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC gl3wCompressedTexSubImage3D;
	extern PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC gl3wCompressedTexSubImage2D;
	extern PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC gl3wCompressedTexSubImage1D;
	extern PFNGLGETCOMPRESSEDTEXIMAGEPROC gl3wGetCompressedTexImage;
	extern PFNGLBLENDFUNCSEPARATEPROC gl3wBlendFuncSeparate;
	extern PFNGLMULTIDRAWARRAYSPROC gl3wMultiDrawArrays;
	extern PFNGLMULTIDRAWELEMENTSPROC gl3wMultiDrawElements;
	extern PFNGLPOINTPARAMETERFPROC gl3wPointParameterf;
	extern PFNGLPOINTPARAMETERFVPROC gl3wPointParameterfv;
	extern PFNGLPOINTPARAMETERIPROC gl3wPointParameteri;
	extern PFNGLPOINTPARAMETERIVPROC gl3wPointParameteriv;
	extern PFNGLGENQUERIESPROC gl3wGenQueries;
	extern PFNGLDELETEQUERIESPROC gl3wDeleteQueries;
	extern PFNGLISQUERYPROC gl3wIsQuery;
	extern PFNGLBEGINQUERYPROC gl3wBeginQuery;
	extern PFNGLENDQUERYPROC gl3wEndQuery;
	extern PFNGLGETQUERYIVPROC gl3wGetQueryiv;
	extern PFNGLGETQUERYOBJECTIVPROC gl3wGetQueryObjectiv;
	extern PFNGLGETQUERYOBJECTUIVPROC gl3wGetQueryObjectuiv;
	extern PFNGLBINDBUFFERPROC gl3wBindBuffer;
	extern PFNGLDELETEBUFFERSPROC gl3wDeleteBuffers;
	extern PFNGLGENBUFFERSPROC gl3wGenBuffers;
	extern PFNGLISBUFFERPROC gl3wIsBuffer;
	extern PFNGLBUFFERDATAPROC gl3wBufferData;
	extern PFNGLBUFFERSUBDATAPROC gl3wBufferSubData;
	extern PFNGLGETBUFFERSUBDATAPROC gl3wGetBufferSubData;
	extern PFNGLMAPBUFFERPROC gl3wMapBuffer;
	extern PFNGLUNMAPBUFFERPROC gl3wUnmapBuffer;
	extern PFNGLGETBUFFERPARAMETERIVPROC gl3wGetBufferParameteriv;
	extern PFNGLGETBUFFERPOINTERVPROC gl3wGetBufferPointerv;
	extern PFNGLBLENDEQUATIONSEPARATEPROC gl3wBlendEquationSeparate;
	extern PFNGLDRAWBUFFERSPROC gl3wDrawBuffers;
	extern PFNGLSTENCILOPSEPARATEPROC gl3wStencilOpSeparate;
	extern PFNGLSTENCILFUNCSEPARATEPROC gl3wStencilFuncSeparate;
	extern PFNGLSTENCILMASKSEPARATEPROC gl3wStencilMaskSeparate;
	extern PFNGLATTACHSHADERPROC gl3wAttachShader;
	extern PFNGLBINDATTRIBLOCATIONPROC gl3wBindAttribLocation;
	extern PFNGLCOMPILESHADERPROC gl3wCompileShader;
	extern PFNGLCREATEPROGRAMPROC gl3wCreateProgram;
	extern PFNGLCREATESHADERPROC gl3wCreateShader;
	extern PFNGLDELETEPROGRAMPROC gl3wDeleteProgram;
	extern PFNGLDELETESHADERPROC gl3wDeleteShader;
	extern PFNGLDETACHSHADERPROC gl3wDetachShader;
	extern PFNGLDISABLEVERTEXATTRIBARRAYPROC gl3wDisableVertexAttribArray;
	extern PFNGLENABLEVERTEXATTRIBARRAYPROC gl3wEnableVertexAttribArray;
	extern PFNGLGETACTIVEATTRIBPROC gl3wGetActiveAttrib;
	extern PFNGLGETACTIVEUNIFORMPROC gl3wGetActiveUniform;
	extern PFNGLGETATTACHEDSHADERSPROC gl3wGetAttachedShaders;
	extern PFNGLGETATTRIBLOCATIONPROC gl3wGetAttribLocation;
	extern PFNGLGETPROGRAMIVPROC gl3wGetProgramiv;
	extern PFNGLGETPROGRAMINFOLOGPROC gl3wGetProgramInfoLog;
	extern PFNGLGETSHADERIVPROC gl3wGetShaderiv;
	extern PFNGLGETSHADERINFOLOGPROC gl3wGetShaderInfoLog;
	extern PFNGLGETSHADERSOURCEPROC gl3wGetShaderSource;
	extern PFNGLGETUNIFORMLOCATIONPROC gl3wGetUniformLocation;
	extern PFNGLGETUNIFORMFVPROC gl3wGetUniformfv;
	extern PFNGLGETUNIFORMIVPROC gl3wGetUniformiv;
	extern PFNGLGETVERTEXATTRIBDVPROC gl3wGetVertexAttribdv;
	extern PFNGLGETVERTEXATTRIBFVPROC gl3wGetVertexAttribfv;
	extern PFNGLGETVERTEXATTRIBIVPROC gl3wGetVertexAttribiv;
	extern PFNGLGETVERTEXATTRIBPOINTERVPROC gl3wGetVertexAttribPointerv;
	extern PFNGLISPROGRAMPROC gl3wIsProgram;
	extern PFNGLISSHADERPROC gl3wIsShader;
	extern PFNGLLINKPROGRAMPROC gl3wLinkProgram;
	extern PFNGLSHADERSOURCEPROC gl3wShaderSource;
	extern PFNGLUSEPROGRAMPROC gl3wUseProgram;
	extern PFNGLUNIFORM1FPROC gl3wUniform1f;
	extern PFNGLUNIFORM2FPROC gl3wUniform2f;
	extern PFNGLUNIFORM3FPROC gl3wUniform3f;
	extern PFNGLUNIFORM4FPROC gl3wUniform4f;
	extern PFNGLUNIFORM1IPROC gl3wUniform1i;
	extern PFNGLUNIFORM2IPROC gl3wUniform2i;
	extern PFNGLUNIFORM3IPROC gl3wUniform3i;
	extern PFNGLUNIFORM4IPROC gl3wUniform4i;
	extern PFNGLUNIFORM1FVPROC gl3wUniform1fv;
	extern PFNGLUNIFORM2FVPROC gl3wUniform2fv;
	extern PFNGLUNIFORM3FVPROC gl3wUniform3fv;
	extern PFNGLUNIFORM4FVPROC gl3wUniform4fv;
	extern PFNGLUNIFORM1IVPROC gl3wUniform1iv;
	extern PFNGLUNIFORM2IVPROC gl3wUniform2iv;
	extern PFNGLUNIFORM3IVPROC gl3wUniform3iv;
	extern PFNGLUNIFORM4IVPROC gl3wUniform4iv;
	extern PFNGLUNIFORMMATRIX2FVPROC gl3wUniformMatrix2fv;
	extern PFNGLUNIFORMMATRIX3FVPROC gl3wUniformMatrix3fv;
	extern PFNGLUNIFORMMATRIX4FVPROC gl3wUniformMatrix4fv;
	extern PFNGLVALIDATEPROGRAMPROC gl3wValidateProgram;
	extern PFNGLVERTEXATTRIB1DPROC gl3wVertexAttrib1d;
	extern PFNGLVERTEXATTRIB1DVPROC gl3wVertexAttrib1dv;
	extern PFNGLVERTEXATTRIB1FPROC gl3wVertexAttrib1f;
	extern PFNGLVERTEXATTRIB1FVPROC gl3wVertexAttrib1fv;
	extern PFNGLVERTEXATTRIB1SPROC gl3wVertexAttrib1s;
	extern PFNGLVERTEXATTRIB1SVPROC gl3wVertexAttrib1sv;
	extern PFNGLVERTEXATTRIB2DPROC gl3wVertexAttrib2d;
	extern PFNGLVERTEXATTRIB2DVPROC gl3wVertexAttrib2dv;
	extern PFNGLVERTEXATTRIB2FPROC gl3wVertexAttrib2f;
	extern PFNGLVERTEXATTRIB2FVPROC gl3wVertexAttrib2fv;
	extern PFNGLVERTEXATTRIB2SPROC gl3wVertexAttrib2s;
	extern PFNGLVERTEXATTRIB2SVPROC gl3wVertexAttrib2sv;
	extern PFNGLVERTEXATTRIB3DPROC gl3wVertexAttrib3d;
	extern PFNGLVERTEXATTRIB3DVPROC gl3wVertexAttrib3dv;
	extern PFNGLVERTEXATTRIB3FPROC gl3wVertexAttrib3f;
	extern PFNGLVERTEXATTRIB3FVPROC gl3wVertexAttrib3fv;
	extern PFNGLVERTEXATTRIB3SPROC gl3wVertexAttrib3s;
	extern PFNGLVERTEXATTRIB3SVPROC gl3wVertexAttrib3sv;
	extern PFNGLVERTEXATTRIB4NBVPROC gl3wVertexAttrib4Nbv;
	extern PFNGLVERTEXATTRIB4NIVPROC gl3wVertexAttrib4Niv;
	extern PFNGLVERTEXATTRIB4NSVPROC gl3wVertexAttrib4Nsv;
	extern PFNGLVERTEXATTRIB4NUBPROC gl3wVertexAttrib4Nub;
	extern PFNGLVERTEXATTRIB4NUBVPROC gl3wVertexAttrib4Nubv;
	extern PFNGLVERTEXATTRIB4NUIVPROC gl3wVertexAttrib4Nuiv;
	extern PFNGLVERTEXATTRIB4NUSVPROC gl3wVertexAttrib4Nusv;
	extern PFNGLVERTEXATTRIB4BVPROC gl3wVertexAttrib4bv;
	extern PFNGLVERTEXATTRIB4DPROC gl3wVertexAttrib4d;
	extern PFNGLVERTEXATTRIB4DVPROC gl3wVertexAttrib4dv;
	extern PFNGLVERTEXATTRIB4FPROC gl3wVertexAttrib4f;
	extern PFNGLVERTEXATTRIB4FVPROC gl3wVertexAttrib4fv;
	extern PFNGLVERTEXATTRIB4IVPROC gl3wVertexAttrib4iv;
	extern PFNGLVERTEXATTRIB4SPROC gl3wVertexAttrib4s;
	extern PFNGLVERTEXATTRIB4SVPROC gl3wVertexAttrib4sv;
	extern PFNGLVERTEXATTRIB4UBVPROC gl3wVertexAttrib4ubv;
	extern PFNGLVERTEXATTRIB4UIVPROC gl3wVertexAttrib4uiv;
	extern PFNGLVERTEXATTRIB4USVPROC gl3wVertexAttrib4usv;
	extern PFNGLVERTEXATTRIBPOINTERPROC gl3wVertexAttribPointer;
	extern PFNGLUNIFORMMATRIX2X3FVPROC gl3wUniformMatrix2x3fv;
	extern PFNGLUNIFORMMATRIX3X2FVPROC gl3wUniformMatrix3x2fv;
	extern PFNGLUNIFORMMATRIX2X4FVPROC gl3wUniformMatrix2x4fv;
	extern PFNGLUNIFORMMATRIX4X2FVPROC gl3wUniformMatrix4x2fv;
	extern PFNGLUNIFORMMATRIX3X4FVPROC gl3wUniformMatrix3x4fv;
	extern PFNGLUNIFORMMATRIX4X3FVPROC gl3wUniformMatrix4x3fv;
	extern PFNGLCOLORMASKIPROC gl3wColorMaski;
	extern PFNGLGETBOOLEANI_VPROC gl3wGetBooleani_v;
	extern PFNGLGETINTEGERI_VPROC gl3wGetIntegeri_v;
	extern PFNGLENABLEIPROC gl3wEnablei;
	extern PFNGLDISABLEIPROC gl3wDisablei;
	extern PFNGLISENABLEDIPROC gl3wIsEnabledi;
	extern PFNGLBEGINTRANSFORMFEEDBACKPROC gl3wBeginTransformFeedback;
	extern PFNGLENDTRANSFORMFEEDBACKPROC gl3wEndTransformFeedback;
	extern PFNGLBINDBUFFERRANGEPROC gl3wBindBufferRange;
	extern PFNGLBINDBUFFERBASEPROC gl3wBindBufferBase;
	extern PFNGLTRANSFORMFEEDBACKVARYINGSPROC gl3wTransformFeedbackVaryings;
	extern PFNGLGETTRANSFORMFEEDBACKVARYINGPROC gl3wGetTransformFeedbackVarying;
	extern PFNGLCLAMPCOLORPROC gl3wClampColor;
	extern PFNGLBEGINCONDITIONALRENDERPROC gl3wBeginConditionalRender;
	extern PFNGLENDCONDITIONALRENDERPROC gl3wEndConditionalRender;
	extern PFNGLVERTEXATTRIBIPOINTERPROC gl3wVertexAttribIPointer;
	extern PFNGLGETVERTEXATTRIBIIVPROC gl3wGetVertexAttribIiv;
	extern PFNGLGETVERTEXATTRIBIUIVPROC gl3wGetVertexAttribIuiv;
	extern PFNGLVERTEXATTRIBI1IPROC gl3wVertexAttribI1i;
	extern PFNGLVERTEXATTRIBI2IPROC gl3wVertexAttribI2i;
	extern PFNGLVERTEXATTRIBI3IPROC gl3wVertexAttribI3i;
	extern PFNGLVERTEXATTRIBI4IPROC gl3wVertexAttribI4i;
	extern PFNGLVERTEXATTRIBI1UIPROC gl3wVertexAttribI1ui;
	extern PFNGLVERTEXATTRIBI2UIPROC gl3wVertexAttribI2ui;
	extern PFNGLVERTEXATTRIBI3UIPROC gl3wVertexAttribI3ui;
	extern PFNGLVERTEXATTRIBI4UIPROC gl3wVertexAttribI4ui;
	extern PFNGLVERTEXATTRIBI1IVPROC gl3wVertexAttribI1iv;
	extern PFNGLVERTEXATTRIBI2IVPROC gl3wVertexAttribI2iv;
	extern PFNGLVERTEXATTRIBI3IVPROC gl3wVertexAttribI3iv;
	extern PFNGLVERTEXATTRIBI4IVPROC gl3wVertexAttribI4iv;
	extern PFNGLVERTEXATTRIBI1UIVPROC gl3wVertexAttribI1uiv;
	extern PFNGLVERTEXATTRIBI2UIVPROC gl3wVertexAttribI2uiv;
	extern PFNGLVERTEXATTRIBI3UIVPROC gl3wVertexAttribI3uiv;
	extern PFNGLVERTEXATTRIBI4UIVPROC gl3wVertexAttribI4uiv;
	extern PFNGLVERTEXATTRIBI4BVPROC gl3wVertexAttribI4bv;
	extern PFNGLVERTEXATTRIBI4SVPROC gl3wVertexAttribI4sv;
	extern PFNGLVERTEXATTRIBI4UBVPROC gl3wVertexAttribI4ubv;
	extern PFNGLVERTEXATTRIBI4USVPROC gl3wVertexAttribI4usv;
	extern PFNGLGETUNIFORMUIVPROC gl3wGetUniformuiv;
	extern PFNGLBINDFRAGDATALOCATIONPROC gl3wBindFragDataLocation;
	extern PFNGLGETFRAGDATALOCATIONPROC gl3wGetFragDataLocation;
	extern PFNGLUNIFORM1UIPROC gl3wUniform1ui;
	extern PFNGLUNIFORM2UIPROC gl3wUniform2ui;
	extern PFNGLUNIFORM3UIPROC gl3wUniform3ui;
	extern PFNGLUNIFORM4UIPROC gl3wUniform4ui;
	extern PFNGLUNIFORM1UIVPROC gl3wUniform1uiv;
	extern PFNGLUNIFORM2UIVPROC gl3wUniform2uiv;
	extern PFNGLUNIFORM3UIVPROC gl3wUniform3uiv;
	extern PFNGLUNIFORM4UIVPROC gl3wUniform4uiv;
	extern PFNGLTEXPARAMETERIIVPROC gl3wTexParameterIiv;
	extern PFNGLTEXPARAMETERIUIVPROC gl3wTexParameterIuiv;
	extern PFNGLGETTEXPARAMETERIIVPROC gl3wGetTexParameterIiv;
	extern PFNGLGETTEXPARAMETERIUIVPROC gl3wGetTexParameterIuiv;
	extern PFNGLCLEARBUFFERIVPROC gl3wClearBufferiv;
	extern PFNGLCLEARBUFFERUIVPROC gl3wClearBufferuiv;
	extern PFNGLCLEARBUFFERFVPROC gl3wClearBufferfv;
	extern PFNGLCLEARBUFFERFIPROC gl3wClearBufferfi;
	extern PFNGLGETSTRINGIPROC gl3wGetStringi;
	extern PFNGLDRAWARRAYSINSTANCEDPROC gl3wDrawArraysInstanced;
	extern PFNGLDRAWELEMENTSINSTANCEDPROC gl3wDrawElementsInstanced;
	extern PFNGLTEXBUFFERPROC gl3wTexBuffer;
	extern PFNGLPRIMITIVERESTARTINDEXPROC gl3wPrimitiveRestartIndex;
	extern PFNGLGETINTEGER64I_VPROC gl3wGetInteger64i_v;
	extern PFNGLGETBUFFERPARAMETERI64VPROC gl3wGetBufferParameteri64v;
	extern PFNGLFRAMEBUFFERTEXTUREPROC gl3wFramebufferTexture;
	extern PFNGLVERTEXATTRIBDIVISORPROC gl3wVertexAttribDivisor;
	extern PFNGLMINSAMPLESHADINGPROC gl3wMinSampleShading;
	extern PFNGLBLENDEQUATIONIPROC gl3wBlendEquationi;
	extern PFNGLBLENDEQUATIONSEPARATEIPROC gl3wBlendEquationSeparatei;
	extern PFNGLBLENDFUNCIPROC gl3wBlendFunci;
	extern PFNGLBLENDFUNCSEPARATEIPROC gl3wBlendFuncSeparatei;
	extern PFNGLISRENDERBUFFERPROC gl3wIsRenderbuffer;
	extern PFNGLBINDRENDERBUFFERPROC gl3wBindRenderbuffer;
	extern PFNGLDELETERENDERBUFFERSPROC gl3wDeleteRenderbuffers;
	extern PFNGLGENRENDERBUFFERSPROC gl3wGenRenderbuffers;
	extern PFNGLRENDERBUFFERSTORAGEPROC gl3wRenderbufferStorage;
	extern PFNGLGETRENDERBUFFERPARAMETERIVPROC gl3wGetRenderbufferParameteriv;
	extern PFNGLISFRAMEBUFFERPROC gl3wIsFramebuffer;
	extern PFNGLBINDFRAMEBUFFERPROC gl3wBindFramebuffer;
	extern PFNGLDELETEFRAMEBUFFERSPROC gl3wDeleteFramebuffers;
	extern PFNGLGENFRAMEBUFFERSPROC gl3wGenFramebuffers;
	extern PFNGLCHECKFRAMEBUFFERSTATUSPROC gl3wCheckFramebufferStatus;
	extern PFNGLFRAMEBUFFERTEXTURE1DPROC gl3wFramebufferTexture1D;
	extern PFNGLFRAMEBUFFERTEXTURE2DPROC gl3wFramebufferTexture2D;
	extern PFNGLFRAMEBUFFERTEXTURE3DPROC gl3wFramebufferTexture3D;
	extern PFNGLFRAMEBUFFERRENDERBUFFERPROC gl3wFramebufferRenderbuffer;
	extern PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC gl3wGetFramebufferAttachmentParameteriv;
	extern PFNGLGENERATEMIPMAPPROC gl3wGenerateMipmap;
	extern PFNGLBLITFRAMEBUFFERPROC gl3wBlitFramebuffer;
	extern PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC gl3wRenderbufferStorageMultisample;
	extern PFNGLFRAMEBUFFERTEXTURELAYERPROC gl3wFramebufferTextureLayer;
	extern PFNGLMAPBUFFERRANGEPROC gl3wMapBufferRange;
	extern PFNGLFLUSHMAPPEDBUFFERRANGEPROC gl3wFlushMappedBufferRange;
	extern PFNGLBINDVERTEXARRAYPROC gl3wBindVertexArray;
	extern PFNGLDELETEVERTEXARRAYSPROC gl3wDeleteVertexArrays;
	extern PFNGLGENVERTEXARRAYSPROC gl3wGenVertexArrays;
	extern PFNGLISVERTEXARRAYPROC gl3wIsVertexArray;
	extern PFNGLGETUNIFORMINDICESPROC gl3wGetUniformIndices;
	extern PFNGLGETACTIVEUNIFORMSIVPROC gl3wGetActiveUniformsiv;
	extern PFNGLGETACTIVEUNIFORMNAMEPROC gl3wGetActiveUniformName;
	extern PFNGLGETUNIFORMBLOCKINDEXPROC gl3wGetUniformBlockIndex;
	extern PFNGLGETACTIVEUNIFORMBLOCKIVPROC gl3wGetActiveUniformBlockiv;
	extern PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC gl3wGetActiveUniformBlockName;
	extern PFNGLUNIFORMBLOCKBINDINGPROC gl3wUniformBlockBinding;
	extern PFNGLCOPYBUFFERSUBDATAPROC gl3wCopyBufferSubData;
	extern PFNGLDRAWELEMENTSBASEVERTEXPROC gl3wDrawElementsBaseVertex;
	extern PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC gl3wDrawRangeElementsBaseVertex;
	extern PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC gl3wDrawElementsInstancedBaseVertex;
	extern PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC gl3wMultiDrawElementsBaseVertex;
	extern PFNGLPROVOKINGVERTEXPROC gl3wProvokingVertex;
	extern PFNGLFENCESYNCPROC gl3wFenceSync;
	extern PFNGLISSYNCPROC gl3wIsSync;
	extern PFNGLDELETESYNCPROC gl3wDeleteSync;
	extern PFNGLCLIENTWAITSYNCPROC gl3wClientWaitSync;
	extern PFNGLWAITSYNCPROC gl3wWaitSync;
	extern PFNGLGETINTEGER64VPROC gl3wGetInteger64v;
	extern PFNGLGETSYNCIVPROC gl3wGetSynciv;
	extern PFNGLTEXIMAGE2DMULTISAMPLEPROC gl3wTexImage2DMultisample;
	extern PFNGLTEXIMAGE3DMULTISAMPLEPROC gl3wTexImage3DMultisample;
	extern PFNGLGETMULTISAMPLEFVPROC gl3wGetMultisamplefv;
	extern PFNGLSAMPLEMASKIPROC gl3wSampleMaski;
	extern PFNGLBLENDEQUATIONIARBPROC gl3wBlendEquationiARB;
	extern PFNGLBLENDEQUATIONSEPARATEIARBPROC gl3wBlendEquationSeparateiARB;
	extern PFNGLBLENDFUNCIARBPROC gl3wBlendFunciARB;
	extern PFNGLBLENDFUNCSEPARATEIARBPROC gl3wBlendFuncSeparateiARB;
	extern PFNGLMINSAMPLESHADINGARBPROC gl3wMinSampleShadingARB;
	extern PFNGLNAMEDSTRINGARBPROC gl3wNamedStringARB;
	extern PFNGLDELETENAMEDSTRINGARBPROC gl3wDeleteNamedStringARB;
	extern PFNGLCOMPILESHADERINCLUDEARBPROC gl3wCompileShaderIncludeARB;
	extern PFNGLISNAMEDSTRINGARBPROC gl3wIsNamedStringARB;
	extern PFNGLGETNAMEDSTRINGARBPROC gl3wGetNamedStringARB;
	extern PFNGLGETNAMEDSTRINGIVARBPROC gl3wGetNamedStringivARB;
	extern PFNGLBINDFRAGDATALOCATIONINDEXEDPROC gl3wBindFragDataLocationIndexed;
	extern PFNGLGETFRAGDATAINDEXPROC gl3wGetFragDataIndex;
	extern PFNGLGENSAMPLERSPROC gl3wGenSamplers;
	extern PFNGLDELETESAMPLERSPROC gl3wDeleteSamplers;
	extern PFNGLISSAMPLERPROC gl3wIsSampler;
	extern PFNGLBINDSAMPLERPROC gl3wBindSampler;
	extern PFNGLSAMPLERPARAMETERIPROC gl3wSamplerParameteri;
	extern PFNGLSAMPLERPARAMETERIVPROC gl3wSamplerParameteriv;
	extern PFNGLSAMPLERPARAMETERFPROC gl3wSamplerParameterf;
	extern PFNGLSAMPLERPARAMETERFVPROC gl3wSamplerParameterfv;
	extern PFNGLSAMPLERPARAMETERIIVPROC gl3wSamplerParameterIiv;
	extern PFNGLSAMPLERPARAMETERIUIVPROC gl3wSamplerParameterIuiv;
	extern PFNGLGETSAMPLERPARAMETERIVPROC gl3wGetSamplerParameteriv;
	extern PFNGLGETSAMPLERPARAMETERIIVPROC gl3wGetSamplerParameterIiv;
	extern PFNGLGETSAMPLERPARAMETERFVPROC gl3wGetSamplerParameterfv;
	extern PFNGLGETSAMPLERPARAMETERIUIVPROC gl3wGetSamplerParameterIuiv;
	extern PFNGLQUERYCOUNTERPROC gl3wQueryCounter;
	extern PFNGLGETQUERYOBJECTI64VPROC gl3wGetQueryObjecti64v;
	extern PFNGLGETQUERYOBJECTUI64VPROC gl3wGetQueryObjectui64v;
	extern PFNGLVERTEXP2UIPROC gl3wVertexP2ui;
	extern PFNGLVERTEXP2UIVPROC gl3wVertexP2uiv;
	extern PFNGLVERTEXP3UIPROC gl3wVertexP3ui;
	extern PFNGLVERTEXP3UIVPROC gl3wVertexP3uiv;
	extern PFNGLVERTEXP4UIPROC gl3wVertexP4ui;
	extern PFNGLVERTEXP4UIVPROC gl3wVertexP4uiv;
	extern PFNGLTEXCOORDP1UIPROC gl3wTexCoordP1ui;
	extern PFNGLTEXCOORDP1UIVPROC gl3wTexCoordP1uiv;
	extern PFNGLTEXCOORDP2UIPROC gl3wTexCoordP2ui;
	extern PFNGLTEXCOORDP2UIVPROC gl3wTexCoordP2uiv;
	extern PFNGLTEXCOORDP3UIPROC gl3wTexCoordP3ui;
	extern PFNGLTEXCOORDP3UIVPROC gl3wTexCoordP3uiv;
	extern PFNGLTEXCOORDP4UIPROC gl3wTexCoordP4ui;
	extern PFNGLTEXCOORDP4UIVPROC gl3wTexCoordP4uiv;
	extern PFNGLMULTITEXCOORDP1UIPROC gl3wMultiTexCoordP1ui;
	extern PFNGLMULTITEXCOORDP1UIVPROC gl3wMultiTexCoordP1uiv;
	extern PFNGLMULTITEXCOORDP2UIPROC gl3wMultiTexCoordP2ui;
	extern PFNGLMULTITEXCOORDP2UIVPROC gl3wMultiTexCoordP2uiv;
	extern PFNGLMULTITEXCOORDP3UIPROC gl3wMultiTexCoordP3ui;
	extern PFNGLMULTITEXCOORDP3UIVPROC gl3wMultiTexCoordP3uiv;
	extern PFNGLMULTITEXCOORDP4UIPROC gl3wMultiTexCoordP4ui;
	extern PFNGLMULTITEXCOORDP4UIVPROC gl3wMultiTexCoordP4uiv;
	extern PFNGLNORMALP3UIPROC gl3wNormalP3ui;
	extern PFNGLNORMALP3UIVPROC gl3wNormalP3uiv;
	extern PFNGLCOLORP3UIPROC gl3wColorP3ui;
	extern PFNGLCOLORP3UIVPROC gl3wColorP3uiv;
	extern PFNGLCOLORP4UIPROC gl3wColorP4ui;
	extern PFNGLCOLORP4UIVPROC gl3wColorP4uiv;
	extern PFNGLSECONDARYCOLORP3UIPROC gl3wSecondaryColorP3ui;
	extern PFNGLSECONDARYCOLORP3UIVPROC gl3wSecondaryColorP3uiv;
	extern PFNGLVERTEXATTRIBP1UIPROC gl3wVertexAttribP1ui;
	extern PFNGLVERTEXATTRIBP1UIVPROC gl3wVertexAttribP1uiv;
	extern PFNGLVERTEXATTRIBP2UIPROC gl3wVertexAttribP2ui;
	extern PFNGLVERTEXATTRIBP2UIVPROC gl3wVertexAttribP2uiv;
	extern PFNGLVERTEXATTRIBP3UIPROC gl3wVertexAttribP3ui;
	extern PFNGLVERTEXATTRIBP3UIVPROC gl3wVertexAttribP3uiv;
	extern PFNGLVERTEXATTRIBP4UIPROC gl3wVertexAttribP4ui;
	extern PFNGLVERTEXATTRIBP4UIVPROC gl3wVertexAttribP4uiv;
	extern PFNGLDRAWARRAYSINDIRECTPROC gl3wDrawArraysIndirect;
	extern PFNGLDRAWELEMENTSINDIRECTPROC gl3wDrawElementsIndirect;
	extern PFNGLUNIFORM1DPROC gl3wUniform1d;
	extern PFNGLUNIFORM2DPROC gl3wUniform2d;
	extern PFNGLUNIFORM3DPROC gl3wUniform3d;
	extern PFNGLUNIFORM4DPROC gl3wUniform4d;
	extern PFNGLUNIFORM1DVPROC gl3wUniform1dv;
	extern PFNGLUNIFORM2DVPROC gl3wUniform2dv;
	extern PFNGLUNIFORM3DVPROC gl3wUniform3dv;
	extern PFNGLUNIFORM4DVPROC gl3wUniform4dv;
	extern PFNGLUNIFORMMATRIX2DVPROC gl3wUniformMatrix2dv;
	extern PFNGLUNIFORMMATRIX3DVPROC gl3wUniformMatrix3dv;
	extern PFNGLUNIFORMMATRIX4DVPROC gl3wUniformMatrix4dv;
	extern PFNGLUNIFORMMATRIX2X3DVPROC gl3wUniformMatrix2x3dv;
	extern PFNGLUNIFORMMATRIX2X4DVPROC gl3wUniformMatrix2x4dv;
	extern PFNGLUNIFORMMATRIX3X2DVPROC gl3wUniformMatrix3x2dv;
	extern PFNGLUNIFORMMATRIX3X4DVPROC gl3wUniformMatrix3x4dv;
	extern PFNGLUNIFORMMATRIX4X2DVPROC gl3wUniformMatrix4x2dv;
	extern PFNGLUNIFORMMATRIX4X3DVPROC gl3wUniformMatrix4x3dv;
	extern PFNGLGETUNIFORMDVPROC gl3wGetUniformdv;
	extern PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC gl3wGetSubroutineUniformLocation;
	extern PFNGLGETSUBROUTINEINDEXPROC gl3wGetSubroutineIndex;
	extern PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC gl3wGetActiveSubroutineUniformiv;
	extern PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC gl3wGetActiveSubroutineUniformName;
	extern PFNGLGETACTIVESUBROUTINENAMEPROC gl3wGetActiveSubroutineName;
	extern PFNGLUNIFORMSUBROUTINESUIVPROC gl3wUniformSubroutinesuiv;
	extern PFNGLGETUNIFORMSUBROUTINEUIVPROC gl3wGetUniformSubroutineuiv;
	extern PFNGLGETPROGRAMSTAGEIVPROC gl3wGetProgramStageiv;
	extern PFNGLPATCHPARAMETERIPROC gl3wPatchParameteri;
	extern PFNGLPATCHPARAMETERFVPROC gl3wPatchParameterfv;
	extern PFNGLBINDTRANSFORMFEEDBACKPROC gl3wBindTransformFeedback;
	extern PFNGLDELETETRANSFORMFEEDBACKSPROC gl3wDeleteTransformFeedbacks;
	extern PFNGLGENTRANSFORMFEEDBACKSPROC gl3wGenTransformFeedbacks;
	extern PFNGLISTRANSFORMFEEDBACKPROC gl3wIsTransformFeedback;
	extern PFNGLPAUSETRANSFORMFEEDBACKPROC gl3wPauseTransformFeedback;
	extern PFNGLRESUMETRANSFORMFEEDBACKPROC gl3wResumeTransformFeedback;
	extern PFNGLDRAWTRANSFORMFEEDBACKPROC gl3wDrawTransformFeedback;
	extern PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC gl3wDrawTransformFeedbackStream;
	extern PFNGLBEGINQUERYINDEXEDPROC gl3wBeginQueryIndexed;
	extern PFNGLENDQUERYINDEXEDPROC gl3wEndQueryIndexed;
	extern PFNGLGETQUERYINDEXEDIVPROC gl3wGetQueryIndexediv;
	extern PFNGLRELEASESHADERCOMPILERPROC gl3wReleaseShaderCompiler;
	extern PFNGLSHADERBINARYPROC gl3wShaderBinary;
	extern PFNGLGETSHADERPRECISIONFORMATPROC gl3wGetShaderPrecisionFormat;
	extern PFNGLDEPTHRANGEFPROC gl3wDepthRangef;
	extern PFNGLCLEARDEPTHFPROC gl3wClearDepthf;
	extern PFNGLGETPROGRAMBINARYPROC gl3wGetProgramBinary;
	extern PFNGLPROGRAMBINARYPROC gl3wProgramBinary;
	extern PFNGLPROGRAMPARAMETERIPROC gl3wProgramParameteri;
	extern PFNGLUSEPROGRAMSTAGESPROC gl3wUseProgramStages;
	extern PFNGLACTIVESHADERPROGRAMPROC gl3wActiveShaderProgram;
	extern PFNGLCREATESHADERPROGRAMVPROC gl3wCreateShaderProgramv;
	extern PFNGLBINDPROGRAMPIPELINEPROC gl3wBindProgramPipeline;
	extern PFNGLDELETEPROGRAMPIPELINESPROC gl3wDeleteProgramPipelines;
	extern PFNGLGENPROGRAMPIPELINESPROC gl3wGenProgramPipelines;
	extern PFNGLISPROGRAMPIPELINEPROC gl3wIsProgramPipeline;
	extern PFNGLGETPROGRAMPIPELINEIVPROC gl3wGetProgramPipelineiv;
	extern PFNGLPROGRAMUNIFORM1IPROC gl3wProgramUniform1i;
	extern PFNGLPROGRAMUNIFORM1IVPROC gl3wProgramUniform1iv;
	extern PFNGLPROGRAMUNIFORM1FPROC gl3wProgramUniform1f;
	extern PFNGLPROGRAMUNIFORM1FVPROC gl3wProgramUniform1fv;
	extern PFNGLPROGRAMUNIFORM1DPROC gl3wProgramUniform1d;
	extern PFNGLPROGRAMUNIFORM1DVPROC gl3wProgramUniform1dv;
	extern PFNGLPROGRAMUNIFORM1UIPROC gl3wProgramUniform1ui;
	extern PFNGLPROGRAMUNIFORM1UIVPROC gl3wProgramUniform1uiv;
	extern PFNGLPROGRAMUNIFORM2IPROC gl3wProgramUniform2i;
	extern PFNGLPROGRAMUNIFORM2IVPROC gl3wProgramUniform2iv;
	extern PFNGLPROGRAMUNIFORM2FPROC gl3wProgramUniform2f;
	extern PFNGLPROGRAMUNIFORM2FVPROC gl3wProgramUniform2fv;
	extern PFNGLPROGRAMUNIFORM2DPROC gl3wProgramUniform2d;
	extern PFNGLPROGRAMUNIFORM2DVPROC gl3wProgramUniform2dv;
	extern PFNGLPROGRAMUNIFORM2UIPROC gl3wProgramUniform2ui;
	extern PFNGLPROGRAMUNIFORM2UIVPROC gl3wProgramUniform2uiv;
	extern PFNGLPROGRAMUNIFORM3IPROC gl3wProgramUniform3i;
	extern PFNGLPROGRAMUNIFORM3IVPROC gl3wProgramUniform3iv;
	extern PFNGLPROGRAMUNIFORM3FPROC gl3wProgramUniform3f;
	extern PFNGLPROGRAMUNIFORM3FVPROC gl3wProgramUniform3fv;
	extern PFNGLPROGRAMUNIFORM3DPROC gl3wProgramUniform3d;
	extern PFNGLPROGRAMUNIFORM3DVPROC gl3wProgramUniform3dv;
	extern PFNGLPROGRAMUNIFORM3UIPROC gl3wProgramUniform3ui;
	extern PFNGLPROGRAMUNIFORM3UIVPROC gl3wProgramUniform3uiv;
	extern PFNGLPROGRAMUNIFORM4IPROC gl3wProgramUniform4i;
	extern PFNGLPROGRAMUNIFORM4IVPROC gl3wProgramUniform4iv;
	extern PFNGLPROGRAMUNIFORM4FPROC gl3wProgramUniform4f;
	extern PFNGLPROGRAMUNIFORM4FVPROC gl3wProgramUniform4fv;
	extern PFNGLPROGRAMUNIFORM4DPROC gl3wProgramUniform4d;
	extern PFNGLPROGRAMUNIFORM4DVPROC gl3wProgramUniform4dv;
	extern PFNGLPROGRAMUNIFORM4UIPROC gl3wProgramUniform4ui;
	extern PFNGLPROGRAMUNIFORM4UIVPROC gl3wProgramUniform4uiv;
	extern PFNGLPROGRAMUNIFORMMATRIX2FVPROC gl3wProgramUniformMatrix2fv;
	extern PFNGLPROGRAMUNIFORMMATRIX3FVPROC gl3wProgramUniformMatrix3fv;
	extern PFNGLPROGRAMUNIFORMMATRIX4FVPROC gl3wProgramUniformMatrix4fv;
	extern PFNGLPROGRAMUNIFORMMATRIX2DVPROC gl3wProgramUniformMatrix2dv;
	extern PFNGLPROGRAMUNIFORMMATRIX3DVPROC gl3wProgramUniformMatrix3dv;
	extern PFNGLPROGRAMUNIFORMMATRIX4DVPROC gl3wProgramUniformMatrix4dv;
	extern PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC gl3wProgramUniformMatrix2x3fv;
	extern PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC gl3wProgramUniformMatrix3x2fv;
	extern PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC gl3wProgramUniformMatrix2x4fv;
	extern PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC gl3wProgramUniformMatrix4x2fv;
	extern PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC gl3wProgramUniformMatrix3x4fv;
	extern PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC gl3wProgramUniformMatrix4x3fv;
	extern PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC gl3wProgramUniformMatrix2x3dv;
	extern PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC gl3wProgramUniformMatrix3x2dv;
	extern PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC gl3wProgramUniformMatrix2x4dv;
	extern PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC gl3wProgramUniformMatrix4x2dv;
	extern PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC gl3wProgramUniformMatrix3x4dv;
	extern PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC gl3wProgramUniformMatrix4x3dv;
	extern PFNGLVALIDATEPROGRAMPIPELINEPROC gl3wValidateProgramPipeline;
	extern PFNGLGETPROGRAMPIPELINEINFOLOGPROC gl3wGetProgramPipelineInfoLog;
	extern PFNGLVERTEXATTRIBL1DPROC gl3wVertexAttribL1d;
	extern PFNGLVERTEXATTRIBL2DPROC gl3wVertexAttribL2d;
	extern PFNGLVERTEXATTRIBL3DPROC gl3wVertexAttribL3d;
	extern PFNGLVERTEXATTRIBL4DPROC gl3wVertexAttribL4d;
	extern PFNGLVERTEXATTRIBL1DVPROC gl3wVertexAttribL1dv;
	extern PFNGLVERTEXATTRIBL2DVPROC gl3wVertexAttribL2dv;
	extern PFNGLVERTEXATTRIBL3DVPROC gl3wVertexAttribL3dv;
	extern PFNGLVERTEXATTRIBL4DVPROC gl3wVertexAttribL4dv;
	extern PFNGLVERTEXATTRIBLPOINTERPROC gl3wVertexAttribLPointer;
	extern PFNGLGETVERTEXATTRIBLDVPROC gl3wGetVertexAttribLdv;
	extern PFNGLVIEWPORTARRAYVPROC gl3wViewportArrayv;
	extern PFNGLVIEWPORTINDEXEDFPROC gl3wViewportIndexedf;
	extern PFNGLVIEWPORTINDEXEDFVPROC gl3wViewportIndexedfv;
	extern PFNGLSCISSORARRAYVPROC gl3wScissorArrayv;
	extern PFNGLSCISSORINDEXEDPROC gl3wScissorIndexed;
	extern PFNGLSCISSORINDEXEDVPROC gl3wScissorIndexedv;
	extern PFNGLDEPTHRANGEARRAYVPROC gl3wDepthRangeArrayv;
	extern PFNGLDEPTHRANGEINDEXEDPROC gl3wDepthRangeIndexed;
	extern PFNGLGETFLOATI_VPROC gl3wGetFloati_v;
	extern PFNGLGETDOUBLEI_VPROC gl3wGetDoublei_v;
	extern PFNGLCREATESYNCFROMCLEVENTARBPROC gl3wCreateSyncFromCLeventARB;
	extern PFNGLDEBUGMESSAGECONTROLARBPROC gl3wDebugMessageControlARB;
	extern PFNGLDEBUGMESSAGEINSERTARBPROC gl3wDebugMessageInsertARB;
	extern PFNGLDEBUGMESSAGECALLBACKARBPROC gl3wDebugMessageCallbackARB;
	extern PFNGLGETDEBUGMESSAGELOGARBPROC gl3wGetDebugMessageLogARB;
	extern PFNGLGETGRAPHICSRESETSTATUSARBPROC gl3wGetGraphicsResetStatusARB;
	extern PFNGLGETNTEXIMAGEARBPROC gl3wGetnTexImageARB;
	extern PFNGLREADNPIXELSARBPROC gl3wReadnPixelsARB;
	extern PFNGLGETNCOMPRESSEDTEXIMAGEARBPROC gl3wGetnCompressedTexImageARB;
	extern PFNGLGETNUNIFORMFVARBPROC gl3wGetnUniformfvARB;
	extern PFNGLGETNUNIFORMIVARBPROC gl3wGetnUniformivARB;
	extern PFNGLGETNUNIFORMUIVARBPROC gl3wGetnUniformuivARB;
	extern PFNGLGETNUNIFORMDVARBPROC gl3wGetnUniformdvARB;
	extern PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC gl3wDrawArraysInstancedBaseInstance;
	extern PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC gl3wDrawElementsInstancedBaseInstance;
	extern PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC gl3wDrawElementsInstancedBaseVertexBaseInstance;
	extern PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC gl3wDrawTransformFeedbackInstanced;
	extern PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC gl3wDrawTransformFeedbackStreamInstanced;
	extern PFNGLGETINTERNALFORMATIVPROC gl3wGetInternalformativ;
	extern PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC gl3wGetActiveAtomicCounterBufferiv;
	extern PFNGLBINDIMAGETEXTUREPROC gl3wBindImageTexture;
	extern PFNGLMEMORYBARRIERPROC gl3wMemoryBarrier;
	extern PFNGLTEXSTORAGE1DPROC gl3wTexStorage1D;
	extern PFNGLTEXSTORAGE2DPROC gl3wTexStorage2D;
	extern PFNGLTEXSTORAGE3DPROC gl3wTexStorage3D;
	extern PFNGLTEXTURESTORAGE1DEXTPROC gl3wTextureStorage1DEXT;
	extern PFNGLTEXTURESTORAGE2DEXTPROC gl3wTextureStorage2DEXT;
	extern PFNGLTEXTURESTORAGE3DEXTPROC gl3wTextureStorage3DEXT;
	extern PFNGLDEBUGMESSAGECONTROLPROC gl3wDebugMessageControl;
	extern PFNGLDEBUGMESSAGEINSERTPROC gl3wDebugMessageInsert;
	extern PFNGLDEBUGMESSAGECALLBACKPROC gl3wDebugMessageCallback;
	extern PFNGLGETDEBUGMESSAGELOGPROC gl3wGetDebugMessageLog;
	extern PFNGLPUSHDEBUGGROUPPROC gl3wPushDebugGroup;
	extern PFNGLPOPDEBUGGROUPPROC gl3wPopDebugGroup;
	extern PFNGLOBJECTLABELPROC gl3wObjectLabel;
	extern PFNGLGETOBJECTLABELPROC gl3wGetObjectLabel;
	extern PFNGLOBJECTPTRLABELPROC gl3wObjectPtrLabel;
	extern PFNGLGETOBJECTPTRLABELPROC gl3wGetObjectPtrLabel;
	extern PFNGLCLEARBUFFERDATAPROC gl3wClearBufferData;
	extern PFNGLCLEARBUFFERSUBDATAPROC gl3wClearBufferSubData;
	extern PFNGLCLEARNAMEDBUFFERDATAEXTPROC gl3wClearNamedBufferDataEXT;
	extern PFNGLCLEARNAMEDBUFFERSUBDATAEXTPROC gl3wClearNamedBufferSubDataEXT;
	extern PFNGLDISPATCHCOMPUTEPROC gl3wDispatchCompute;
	extern PFNGLDISPATCHCOMPUTEINDIRECTPROC gl3wDispatchComputeIndirect;
	extern PFNGLCOPYIMAGESUBDATAPROC gl3wCopyImageSubData;
	extern PFNGLTEXTUREVIEWPROC gl3wTextureView;
	extern PFNGLBINDVERTEXBUFFERPROC gl3wBindVertexBuffer;
	extern PFNGLVERTEXATTRIBFORMATPROC gl3wVertexAttribFormat;
	extern PFNGLVERTEXATTRIBIFORMATPROC gl3wVertexAttribIFormat;
	extern PFNGLVERTEXATTRIBLFORMATPROC gl3wVertexAttribLFormat;
	extern PFNGLVERTEXATTRIBBINDINGPROC gl3wVertexAttribBinding;
	extern PFNGLVERTEXBINDINGDIVISORPROC gl3wVertexBindingDivisor;
	extern PFNGLVERTEXARRAYBINDVERTEXBUFFEREXTPROC gl3wVertexArrayBindVertexBufferEXT;
	extern PFNGLVERTEXARRAYVERTEXATTRIBFORMATEXTPROC gl3wVertexArrayVertexAttribFormatEXT;
	extern PFNGLVERTEXARRAYVERTEXATTRIBIFORMATEXTPROC gl3wVertexArrayVertexAttribIFormatEXT;
	extern PFNGLVERTEXARRAYVERTEXATTRIBLFORMATEXTPROC gl3wVertexArrayVertexAttribLFormatEXT;
	extern PFNGLVERTEXARRAYVERTEXATTRIBBINDINGEXTPROC gl3wVertexArrayVertexAttribBindingEXT;
	extern PFNGLVERTEXARRAYVERTEXBINDINGDIVISOREXTPROC gl3wVertexArrayVertexBindingDivisorEXT;
	extern PFNGLFRAMEBUFFERPARAMETERIPROC gl3wFramebufferParameteri;
	extern PFNGLGETFRAMEBUFFERPARAMETERIVPROC gl3wGetFramebufferParameteriv;
	extern PFNGLNAMEDFRAMEBUFFERPARAMETERIEXTPROC gl3wNamedFramebufferParameteriEXT;
	extern PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVEXTPROC gl3wGetNamedFramebufferParameterivEXT;
	extern PFNGLGETINTERNALFORMATI64VPROC gl3wGetInternalformati64v;
	extern PFNGLINVALIDATETEXSUBIMAGEPROC gl3wInvalidateTexSubImage;
	extern PFNGLINVALIDATETEXIMAGEPROC gl3wInvalidateTexImage;
	extern PFNGLINVALIDATEBUFFERSUBDATAPROC gl3wInvalidateBufferSubData;
	extern PFNGLINVALIDATEBUFFERDATAPROC gl3wInvalidateBufferData;
	extern PFNGLINVALIDATEFRAMEBUFFERPROC gl3wInvalidateFramebuffer;
	extern PFNGLINVALIDATESUBFRAMEBUFFERPROC gl3wInvalidateSubFramebuffer;
	extern PFNGLMULTIDRAWARRAYSINDIRECTPROC gl3wMultiDrawArraysIndirect;
	extern PFNGLMULTIDRAWELEMENTSINDIRECTPROC gl3wMultiDrawElementsIndirect;
	extern PFNGLGETPROGRAMINTERFACEIVPROC gl3wGetProgramInterfaceiv;
	extern PFNGLGETPROGRAMRESOURCEINDEXPROC gl3wGetProgramResourceIndex;
	extern PFNGLGETPROGRAMRESOURCENAMEPROC gl3wGetProgramResourceName;
	extern PFNGLGETPROGRAMRESOURCEIVPROC gl3wGetProgramResourceiv;
	extern PFNGLGETPROGRAMRESOURCELOCATIONPROC gl3wGetProgramResourceLocation;
	extern PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC gl3wGetProgramResourceLocationIndex;
	extern PFNGLSHADERSTORAGEBLOCKBINDINGPROC gl3wShaderStorageBlockBinding;
	extern PFNGLTEXBUFFERRANGEPROC gl3wTexBufferRange;
	extern PFNGLTEXTUREBUFFERRANGEEXTPROC gl3wTextureBufferRangeEXT;
	extern PFNGLTEXSTORAGE2DMULTISAMPLEPROC gl3wTexStorage2DMultisample;
	extern PFNGLTEXSTORAGE3DMULTISAMPLEPROC gl3wTexStorage3DMultisample;
	extern PFNGLTEXTURESTORAGE2DMULTISAMPLEEXTPROC gl3wTextureStorage2DMultisampleEXT;
	extern PFNGLTEXTURESTORAGE3DMULTISAMPLEEXTPROC gl3wTextureStorage3DMultisampleEXT;

#define glCullFace		gl3wCullFace
#define glFrontFace		gl3wFrontFace
#define glHint		gl3wHint
#define glLineWidth		gl3wLineWidth
#define glPointSize		gl3wPointSize
#define glPolygonMode		gl3wPolygonMode
#define glScissor		gl3wScissor
#define glTexParameterf		gl3wTexParameterf
#define glTexParameterfv		gl3wTexParameterfv
#define glTexParameteri		gl3wTexParameteri
#define glTexParameteriv		gl3wTexParameteriv
#define glTexImage1D		gl3wTexImage1D
#define glTexImage2D		gl3wTexImage2D
#define glDrawBuffer		gl3wDrawBuffer
#define glClear		gl3wClear
#define glClearColor		gl3wClearColor
#define glClearStencil		gl3wClearStencil
#define glClearDepth		gl3wClearDepth
#define glStencilMask		gl3wStencilMask
#define glColorMask		gl3wColorMask
#define glDepthMask		gl3wDepthMask
#define glDisable		gl3wDisable
#define glEnable		gl3wEnable
#define glFinish		gl3wFinish
#define glFlush		gl3wFlush
#define glBlendFunc		gl3wBlendFunc
#define glLogicOp		gl3wLogicOp
#define glStencilFunc		gl3wStencilFunc
#define glStencilOp		gl3wStencilOp
#define glDepthFunc		gl3wDepthFunc
#define glPixelStoref		gl3wPixelStoref
#define glPixelStorei		gl3wPixelStorei
#define glReadBuffer		gl3wReadBuffer
#define glReadPixels		gl3wReadPixels
#define glGetBooleanv		gl3wGetBooleanv
#define glGetDoublev		gl3wGetDoublev
#define glGetError		gl3wGetError
#define glGetFloatv		gl3wGetFloatv
#define glGetIntegerv		gl3wGetIntegerv
#define glGetString		gl3wGetString
#define glGetTexImage		gl3wGetTexImage
#define glGetTexParameterfv		gl3wGetTexParameterfv
#define glGetTexParameteriv		gl3wGetTexParameteriv
#define glGetTexLevelParameterfv		gl3wGetTexLevelParameterfv
#define glGetTexLevelParameteriv		gl3wGetTexLevelParameteriv
#define glIsEnabled		gl3wIsEnabled
#define glDepthRange		gl3wDepthRange
#define glViewport		gl3wViewport
#define glDrawArrays		gl3wDrawArrays
#define glDrawElements		gl3wDrawElements
#define glGetPointerv		gl3wGetPointerv
#define glPolygonOffset		gl3wPolygonOffset
#define glCopyTexImage1D		gl3wCopyTexImage1D
#define glCopyTexImage2D		gl3wCopyTexImage2D
#define glCopyTexSubImage1D		gl3wCopyTexSubImage1D
#define glCopyTexSubImage2D		gl3wCopyTexSubImage2D
#define glTexSubImage1D		gl3wTexSubImage1D
#define glTexSubImage2D		gl3wTexSubImage2D
#define glBindTexture		gl3wBindTexture
#define glDeleteTextures		gl3wDeleteTextures
#define glGenTextures		gl3wGenTextures
#define glIsTexture		gl3wIsTexture
#define glBlendColor		gl3wBlendColor
#define glBlendEquation		gl3wBlendEquation
#define glDrawRangeElements		gl3wDrawRangeElements
#define glTexImage3D		gl3wTexImage3D
#define glTexSubImage3D		gl3wTexSubImage3D
#define glCopyTexSubImage3D		gl3wCopyTexSubImage3D
#define glActiveTexture		gl3wActiveTexture
#define glSampleCoverage		gl3wSampleCoverage
#define glCompressedTexImage3D		gl3wCompressedTexImage3D
#define glCompressedTexImage2D		gl3wCompressedTexImage2D
#define glCompressedTexImage1D		gl3wCompressedTexImage1D
#define glCompressedTexSubImage3D		gl3wCompressedTexSubImage3D
#define glCompressedTexSubImage2D		gl3wCompressedTexSubImage2D
#define glCompressedTexSubImage1D		gl3wCompressedTexSubImage1D
#define glGetCompressedTexImage		gl3wGetCompressedTexImage
#define glBlendFuncSeparate		gl3wBlendFuncSeparate
#define glMultiDrawArrays		gl3wMultiDrawArrays
#define glMultiDrawElements		gl3wMultiDrawElements
#define glPointParameterf		gl3wPointParameterf
#define glPointParameterfv		gl3wPointParameterfv
#define glPointParameteri		gl3wPointParameteri
#define glPointParameteriv		gl3wPointParameteriv
#define glGenQueries		gl3wGenQueries
#define glDeleteQueries		gl3wDeleteQueries
#define glIsQuery		gl3wIsQuery
#define glBeginQuery		gl3wBeginQuery
#define glEndQuery		gl3wEndQuery
#define glGetQueryiv		gl3wGetQueryiv
#define glGetQueryObjectiv		gl3wGetQueryObjectiv
#define glGetQueryObjectuiv		gl3wGetQueryObjectuiv
#define glBindBuffer		gl3wBindBuffer
#define glDeleteBuffers		gl3wDeleteBuffers
#define glGenBuffers		gl3wGenBuffers
#define glIsBuffer		gl3wIsBuffer
#define glBufferData		gl3wBufferData
#define glBufferSubData		gl3wBufferSubData
#define glGetBufferSubData		gl3wGetBufferSubData
#define glMapBuffer		gl3wMapBuffer
#define glUnmapBuffer		gl3wUnmapBuffer
#define glGetBufferParameteriv		gl3wGetBufferParameteriv
#define glGetBufferPointerv		gl3wGetBufferPointerv
#define glBlendEquationSeparate		gl3wBlendEquationSeparate
#define glDrawBuffers		gl3wDrawBuffers
#define glStencilOpSeparate		gl3wStencilOpSeparate
#define glStencilFuncSeparate		gl3wStencilFuncSeparate
#define glStencilMaskSeparate		gl3wStencilMaskSeparate
#define glAttachShader		gl3wAttachShader
#define glBindAttribLocation		gl3wBindAttribLocation
#define glCompileShader		gl3wCompileShader
#define glCreateProgram		gl3wCreateProgram
#define glCreateShader		gl3wCreateShader
#define glDeleteProgram		gl3wDeleteProgram
#define glDeleteShader		gl3wDeleteShader
#define glDetachShader		gl3wDetachShader
#define glDisableVertexAttribArray		gl3wDisableVertexAttribArray
#define glEnableVertexAttribArray		gl3wEnableVertexAttribArray
#define glGetActiveAttrib		gl3wGetActiveAttrib
#define glGetActiveUniform		gl3wGetActiveUniform
#define glGetAttachedShaders		gl3wGetAttachedShaders
#define glGetAttribLocation		gl3wGetAttribLocation
#define glGetProgramiv		gl3wGetProgramiv
#define glGetProgramInfoLog		gl3wGetProgramInfoLog
#define glGetShaderiv		gl3wGetShaderiv
#define glGetShaderInfoLog		gl3wGetShaderInfoLog
#define glGetShaderSource		gl3wGetShaderSource
#define glGetUniformLocation		gl3wGetUniformLocation
#define glGetUniformfv		gl3wGetUniformfv
#define glGetUniformiv		gl3wGetUniformiv
#define glGetVertexAttribdv		gl3wGetVertexAttribdv
#define glGetVertexAttribfv		gl3wGetVertexAttribfv
#define glGetVertexAttribiv		gl3wGetVertexAttribiv
#define glGetVertexAttribPointerv		gl3wGetVertexAttribPointerv
#define glIsProgram		gl3wIsProgram
#define glIsShader		gl3wIsShader
#define glLinkProgram		gl3wLinkProgram
#define glShaderSource		gl3wShaderSource
#define glUseProgram		gl3wUseProgram
#define glUniform1f		gl3wUniform1f
#define glUniform2f		gl3wUniform2f
#define glUniform3f		gl3wUniform3f
#define glUniform4f		gl3wUniform4f
#define glUniform1i		gl3wUniform1i
#define glUniform2i		gl3wUniform2i
#define glUniform3i		gl3wUniform3i
#define glUniform4i		gl3wUniform4i
#define glUniform1fv		gl3wUniform1fv
#define glUniform2fv		gl3wUniform2fv
#define glUniform3fv		gl3wUniform3fv
#define glUniform4fv		gl3wUniform4fv
#define glUniform1iv		gl3wUniform1iv
#define glUniform2iv		gl3wUniform2iv
#define glUniform3iv		gl3wUniform3iv
#define glUniform4iv		gl3wUniform4iv
#define glUniformMatrix2fv		gl3wUniformMatrix2fv
#define glUniformMatrix3fv		gl3wUniformMatrix3fv
#define glUniformMatrix4fv		gl3wUniformMatrix4fv
#define glValidateProgram		gl3wValidateProgram
#define glVertexAttrib1d		gl3wVertexAttrib1d
#define glVertexAttrib1dv		gl3wVertexAttrib1dv
#define glVertexAttrib1f		gl3wVertexAttrib1f
#define glVertexAttrib1fv		gl3wVertexAttrib1fv
#define glVertexAttrib1s		gl3wVertexAttrib1s
#define glVertexAttrib1sv		gl3wVertexAttrib1sv
#define glVertexAttrib2d		gl3wVertexAttrib2d
#define glVertexAttrib2dv		gl3wVertexAttrib2dv
#define glVertexAttrib2f		gl3wVertexAttrib2f
#define glVertexAttrib2fv		gl3wVertexAttrib2fv
#define glVertexAttrib2s		gl3wVertexAttrib2s
#define glVertexAttrib2sv		gl3wVertexAttrib2sv
#define glVertexAttrib3d		gl3wVertexAttrib3d
#define glVertexAttrib3dv		gl3wVertexAttrib3dv
#define glVertexAttrib3f		gl3wVertexAttrib3f
#define glVertexAttrib3fv		gl3wVertexAttrib3fv
#define glVertexAttrib3s		gl3wVertexAttrib3s
#define glVertexAttrib3sv		gl3wVertexAttrib3sv
#define glVertexAttrib4Nbv		gl3wVertexAttrib4Nbv
#define glVertexAttrib4Niv		gl3wVertexAttrib4Niv
#define glVertexAttrib4Nsv		gl3wVertexAttrib4Nsv
#define glVertexAttrib4Nub		gl3wVertexAttrib4Nub
#define glVertexAttrib4Nubv		gl3wVertexAttrib4Nubv
#define glVertexAttrib4Nuiv		gl3wVertexAttrib4Nuiv
#define glVertexAttrib4Nusv		gl3wVertexAttrib4Nusv
#define glVertexAttrib4bv		gl3wVertexAttrib4bv
#define glVertexAttrib4d		gl3wVertexAttrib4d
#define glVertexAttrib4dv		gl3wVertexAttrib4dv
#define glVertexAttrib4f		gl3wVertexAttrib4f
#define glVertexAttrib4fv		gl3wVertexAttrib4fv
#define glVertexAttrib4iv		gl3wVertexAttrib4iv
#define glVertexAttrib4s		gl3wVertexAttrib4s
#define glVertexAttrib4sv		gl3wVertexAttrib4sv
#define glVertexAttrib4ubv		gl3wVertexAttrib4ubv
#define glVertexAttrib4uiv		gl3wVertexAttrib4uiv
#define glVertexAttrib4usv		gl3wVertexAttrib4usv
#define glVertexAttribPointer		gl3wVertexAttribPointer
#define glUniformMatrix2x3fv		gl3wUniformMatrix2x3fv
#define glUniformMatrix3x2fv		gl3wUniformMatrix3x2fv
#define glUniformMatrix2x4fv		gl3wUniformMatrix2x4fv
#define glUniformMatrix4x2fv		gl3wUniformMatrix4x2fv
#define glUniformMatrix3x4fv		gl3wUniformMatrix3x4fv
#define glUniformMatrix4x3fv		gl3wUniformMatrix4x3fv
#define glColorMaski		gl3wColorMaski
#define glGetBooleani_v		gl3wGetBooleani_v
#define glGetIntegeri_v		gl3wGetIntegeri_v
#define glEnablei		gl3wEnablei
#define glDisablei		gl3wDisablei
#define glIsEnabledi		gl3wIsEnabledi
#define glBeginTransformFeedback		gl3wBeginTransformFeedback
#define glEndTransformFeedback		gl3wEndTransformFeedback
#define glBindBufferRange		gl3wBindBufferRange
#define glBindBufferBase		gl3wBindBufferBase
#define glTransformFeedbackVaryings		gl3wTransformFeedbackVaryings
#define glGetTransformFeedbackVarying		gl3wGetTransformFeedbackVarying
#define glClampColor		gl3wClampColor
#define glBeginConditionalRender		gl3wBeginConditionalRender
#define glEndConditionalRender		gl3wEndConditionalRender
#define glVertexAttribIPointer		gl3wVertexAttribIPointer
#define glGetVertexAttribIiv		gl3wGetVertexAttribIiv
#define glGetVertexAttribIuiv		gl3wGetVertexAttribIuiv
#define glVertexAttribI1i		gl3wVertexAttribI1i
#define glVertexAttribI2i		gl3wVertexAttribI2i
#define glVertexAttribI3i		gl3wVertexAttribI3i
#define glVertexAttribI4i		gl3wVertexAttribI4i
#define glVertexAttribI1ui		gl3wVertexAttribI1ui
#define glVertexAttribI2ui		gl3wVertexAttribI2ui
#define glVertexAttribI3ui		gl3wVertexAttribI3ui
#define glVertexAttribI4ui		gl3wVertexAttribI4ui
#define glVertexAttribI1iv		gl3wVertexAttribI1iv
#define glVertexAttribI2iv		gl3wVertexAttribI2iv
#define glVertexAttribI3iv		gl3wVertexAttribI3iv
#define glVertexAttribI4iv		gl3wVertexAttribI4iv
#define glVertexAttribI1uiv		gl3wVertexAttribI1uiv
#define glVertexAttribI2uiv		gl3wVertexAttribI2uiv
#define glVertexAttribI3uiv		gl3wVertexAttribI3uiv
#define glVertexAttribI4uiv		gl3wVertexAttribI4uiv
#define glVertexAttribI4bv		gl3wVertexAttribI4bv
#define glVertexAttribI4sv		gl3wVertexAttribI4sv
#define glVertexAttribI4ubv		gl3wVertexAttribI4ubv
#define glVertexAttribI4usv		gl3wVertexAttribI4usv
#define glGetUniformuiv		gl3wGetUniformuiv
#define glBindFragDataLocation		gl3wBindFragDataLocation
#define glGetFragDataLocation		gl3wGetFragDataLocation
#define glUniform1ui		gl3wUniform1ui
#define glUniform2ui		gl3wUniform2ui
#define glUniform3ui		gl3wUniform3ui
#define glUniform4ui		gl3wUniform4ui
#define glUniform1uiv		gl3wUniform1uiv
#define glUniform2uiv		gl3wUniform2uiv
#define glUniform3uiv		gl3wUniform3uiv
#define glUniform4uiv		gl3wUniform4uiv
#define glTexParameterIiv		gl3wTexParameterIiv
#define glTexParameterIuiv		gl3wTexParameterIuiv
#define glGetTexParameterIiv		gl3wGetTexParameterIiv
#define glGetTexParameterIuiv		gl3wGetTexParameterIuiv
#define glClearBufferiv		gl3wClearBufferiv
#define glClearBufferuiv		gl3wClearBufferuiv
#define glClearBufferfv		gl3wClearBufferfv
#define glClearBufferfi		gl3wClearBufferfi
#define glGetStringi		gl3wGetStringi
#define glDrawArraysInstanced		gl3wDrawArraysInstanced
#define glDrawElementsInstanced		gl3wDrawElementsInstanced
#define glTexBuffer		gl3wTexBuffer
#define glPrimitiveRestartIndex		gl3wPrimitiveRestartIndex
#define glGetInteger64i_v		gl3wGetInteger64i_v
#define glGetBufferParameteri64v		gl3wGetBufferParameteri64v
#define glFramebufferTexture		gl3wFramebufferTexture
#define glVertexAttribDivisor		gl3wVertexAttribDivisor
#define glMinSampleShading		gl3wMinSampleShading
#define glBlendEquationi		gl3wBlendEquationi
#define glBlendEquationSeparatei		gl3wBlendEquationSeparatei
#define glBlendFunci		gl3wBlendFunci
#define glBlendFuncSeparatei		gl3wBlendFuncSeparatei
#define glIsRenderbuffer		gl3wIsRenderbuffer
#define glBindRenderbuffer		gl3wBindRenderbuffer
#define glDeleteRenderbuffers		gl3wDeleteRenderbuffers
#define glGenRenderbuffers		gl3wGenRenderbuffers
#define glRenderbufferStorage		gl3wRenderbufferStorage
#define glGetRenderbufferParameteriv		gl3wGetRenderbufferParameteriv
#define glIsFramebuffer		gl3wIsFramebuffer
#define glBindFramebuffer		gl3wBindFramebuffer
#define glDeleteFramebuffers		gl3wDeleteFramebuffers
#define glGenFramebuffers		gl3wGenFramebuffers
#define glCheckFramebufferStatus		gl3wCheckFramebufferStatus
#define glFramebufferTexture1D		gl3wFramebufferTexture1D
#define glFramebufferTexture2D		gl3wFramebufferTexture2D
#define glFramebufferTexture3D		gl3wFramebufferTexture3D
#define glFramebufferRenderbuffer		gl3wFramebufferRenderbuffer
#define glGetFramebufferAttachmentParameteriv		gl3wGetFramebufferAttachmentParameteriv
#define glGenerateMipmap		gl3wGenerateMipmap
#define glBlitFramebuffer		gl3wBlitFramebuffer
#define glRenderbufferStorageMultisample		gl3wRenderbufferStorageMultisample
#define glFramebufferTextureLayer		gl3wFramebufferTextureLayer
#define glMapBufferRange		gl3wMapBufferRange
#define glFlushMappedBufferRange		gl3wFlushMappedBufferRange
#define glBindVertexArray		gl3wBindVertexArray
#define glDeleteVertexArrays		gl3wDeleteVertexArrays
#define glGenVertexArrays		gl3wGenVertexArrays
#define glIsVertexArray		gl3wIsVertexArray
#define glGetUniformIndices		gl3wGetUniformIndices
#define glGetActiveUniformsiv		gl3wGetActiveUniformsiv
#define glGetActiveUniformName		gl3wGetActiveUniformName
#define glGetUniformBlockIndex		gl3wGetUniformBlockIndex
#define glGetActiveUniformBlockiv		gl3wGetActiveUniformBlockiv
#define glGetActiveUniformBlockName		gl3wGetActiveUniformBlockName
#define glUniformBlockBinding		gl3wUniformBlockBinding
#define glCopyBufferSubData		gl3wCopyBufferSubData
#define glDrawElementsBaseVertex		gl3wDrawElementsBaseVertex
#define glDrawRangeElementsBaseVertex		gl3wDrawRangeElementsBaseVertex
#define glDrawElementsInstancedBaseVertex		gl3wDrawElementsInstancedBaseVertex
#define glMultiDrawElementsBaseVertex		gl3wMultiDrawElementsBaseVertex
#define glProvokingVertex		gl3wProvokingVertex
#define glFenceSync		gl3wFenceSync
#define glIsSync		gl3wIsSync
#define glDeleteSync		gl3wDeleteSync
#define glClientWaitSync		gl3wClientWaitSync
#define glWaitSync		gl3wWaitSync
#define glGetInteger64v		gl3wGetInteger64v
#define glGetSynciv		gl3wGetSynciv
#define glTexImage2DMultisample		gl3wTexImage2DMultisample
#define glTexImage3DMultisample		gl3wTexImage3DMultisample
#define glGetMultisamplefv		gl3wGetMultisamplefv
#define glSampleMaski		gl3wSampleMaski
#define glBlendEquationiARB		gl3wBlendEquationiARB
#define glBlendEquationSeparateiARB		gl3wBlendEquationSeparateiARB
#define glBlendFunciARB		gl3wBlendFunciARB
#define glBlendFuncSeparateiARB		gl3wBlendFuncSeparateiARB
#define glMinSampleShadingARB		gl3wMinSampleShadingARB
#define glNamedStringARB		gl3wNamedStringARB
#define glDeleteNamedStringARB		gl3wDeleteNamedStringARB
#define glCompileShaderIncludeARB		gl3wCompileShaderIncludeARB
#define glIsNamedStringARB		gl3wIsNamedStringARB
#define glGetNamedStringARB		gl3wGetNamedStringARB
#define glGetNamedStringivARB		gl3wGetNamedStringivARB
#define glBindFragDataLocationIndexed		gl3wBindFragDataLocationIndexed
#define glGetFragDataIndex		gl3wGetFragDataIndex
#define glGenSamplers		gl3wGenSamplers
#define glDeleteSamplers		gl3wDeleteSamplers
#define glIsSampler		gl3wIsSampler
#define glBindSampler		gl3wBindSampler
#define glSamplerParameteri		gl3wSamplerParameteri
#define glSamplerParameteriv		gl3wSamplerParameteriv
#define glSamplerParameterf		gl3wSamplerParameterf
#define glSamplerParameterfv		gl3wSamplerParameterfv
#define glSamplerParameterIiv		gl3wSamplerParameterIiv
#define glSamplerParameterIuiv		gl3wSamplerParameterIuiv
#define glGetSamplerParameteriv		gl3wGetSamplerParameteriv
#define glGetSamplerParameterIiv		gl3wGetSamplerParameterIiv
#define glGetSamplerParameterfv		gl3wGetSamplerParameterfv
#define glGetSamplerParameterIuiv		gl3wGetSamplerParameterIuiv
#define glQueryCounter		gl3wQueryCounter
#define glGetQueryObjecti64v		gl3wGetQueryObjecti64v
#define glGetQueryObjectui64v		gl3wGetQueryObjectui64v
#define glVertexP2ui		gl3wVertexP2ui
#define glVertexP2uiv		gl3wVertexP2uiv
#define glVertexP3ui		gl3wVertexP3ui
#define glVertexP3uiv		gl3wVertexP3uiv
#define glVertexP4ui		gl3wVertexP4ui
#define glVertexP4uiv		gl3wVertexP4uiv
#define glTexCoordP1ui		gl3wTexCoordP1ui
#define glTexCoordP1uiv		gl3wTexCoordP1uiv
#define glTexCoordP2ui		gl3wTexCoordP2ui
#define glTexCoordP2uiv		gl3wTexCoordP2uiv
#define glTexCoordP3ui		gl3wTexCoordP3ui
#define glTexCoordP3uiv		gl3wTexCoordP3uiv
#define glTexCoordP4ui		gl3wTexCoordP4ui
#define glTexCoordP4uiv		gl3wTexCoordP4uiv
#define glMultiTexCoordP1ui		gl3wMultiTexCoordP1ui
#define glMultiTexCoordP1uiv		gl3wMultiTexCoordP1uiv
#define glMultiTexCoordP2ui		gl3wMultiTexCoordP2ui
#define glMultiTexCoordP2uiv		gl3wMultiTexCoordP2uiv
#define glMultiTexCoordP3ui		gl3wMultiTexCoordP3ui
#define glMultiTexCoordP3uiv		gl3wMultiTexCoordP3uiv
#define glMultiTexCoordP4ui		gl3wMultiTexCoordP4ui
#define glMultiTexCoordP4uiv		gl3wMultiTexCoordP4uiv
#define glNormalP3ui		gl3wNormalP3ui
#define glNormalP3uiv		gl3wNormalP3uiv
#define glColorP3ui		gl3wColorP3ui
#define glColorP3uiv		gl3wColorP3uiv
#define glColorP4ui		gl3wColorP4ui
#define glColorP4uiv		gl3wColorP4uiv
#define glSecondaryColorP3ui		gl3wSecondaryColorP3ui
#define glSecondaryColorP3uiv		gl3wSecondaryColorP3uiv
#define glVertexAttribP1ui		gl3wVertexAttribP1ui
#define glVertexAttribP1uiv		gl3wVertexAttribP1uiv
#define glVertexAttribP2ui		gl3wVertexAttribP2ui
#define glVertexAttribP2uiv		gl3wVertexAttribP2uiv
#define glVertexAttribP3ui		gl3wVertexAttribP3ui
#define glVertexAttribP3uiv		gl3wVertexAttribP3uiv
#define glVertexAttribP4ui		gl3wVertexAttribP4ui
#define glVertexAttribP4uiv		gl3wVertexAttribP4uiv
#define glDrawArraysIndirect		gl3wDrawArraysIndirect
#define glDrawElementsIndirect		gl3wDrawElementsIndirect
#define glUniform1d		gl3wUniform1d
#define glUniform2d		gl3wUniform2d
#define glUniform3d		gl3wUniform3d
#define glUniform4d		gl3wUniform4d
#define glUniform1dv		gl3wUniform1dv
#define glUniform2dv		gl3wUniform2dv
#define glUniform3dv		gl3wUniform3dv
#define glUniform4dv		gl3wUniform4dv
#define glUniformMatrix2dv		gl3wUniformMatrix2dv
#define glUniformMatrix3dv		gl3wUniformMatrix3dv
#define glUniformMatrix4dv		gl3wUniformMatrix4dv
#define glUniformMatrix2x3dv		gl3wUniformMatrix2x3dv
#define glUniformMatrix2x4dv		gl3wUniformMatrix2x4dv
#define glUniformMatrix3x2dv		gl3wUniformMatrix3x2dv
#define glUniformMatrix3x4dv		gl3wUniformMatrix3x4dv
#define glUniformMatrix4x2dv		gl3wUniformMatrix4x2dv
#define glUniformMatrix4x3dv		gl3wUniformMatrix4x3dv
#define glGetUniformdv		gl3wGetUniformdv
#define glGetSubroutineUniformLocation		gl3wGetSubroutineUniformLocation
#define glGetSubroutineIndex		gl3wGetSubroutineIndex
#define glGetActiveSubroutineUniformiv		gl3wGetActiveSubroutineUniformiv
#define glGetActiveSubroutineUniformName		gl3wGetActiveSubroutineUniformName
#define glGetActiveSubroutineName		gl3wGetActiveSubroutineName
#define glUniformSubroutinesuiv		gl3wUniformSubroutinesuiv
#define glGetUniformSubroutineuiv		gl3wGetUniformSubroutineuiv
#define glGetProgramStageiv		gl3wGetProgramStageiv
#define glPatchParameteri		gl3wPatchParameteri
#define glPatchParameterfv		gl3wPatchParameterfv
#define glBindTransformFeedback		gl3wBindTransformFeedback
#define glDeleteTransformFeedbacks		gl3wDeleteTransformFeedbacks
#define glGenTransformFeedbacks		gl3wGenTransformFeedbacks
#define glIsTransformFeedback		gl3wIsTransformFeedback
#define glPauseTransformFeedback		gl3wPauseTransformFeedback
#define glResumeTransformFeedback		gl3wResumeTransformFeedback
#define glDrawTransformFeedback		gl3wDrawTransformFeedback
#define glDrawTransformFeedbackStream		gl3wDrawTransformFeedbackStream
#define glBeginQueryIndexed		gl3wBeginQueryIndexed
#define glEndQueryIndexed		gl3wEndQueryIndexed
#define glGetQueryIndexediv		gl3wGetQueryIndexediv
#define glReleaseShaderCompiler		gl3wReleaseShaderCompiler
#define glShaderBinary		gl3wShaderBinary
#define glGetShaderPrecisionFormat		gl3wGetShaderPrecisionFormat
#define glDepthRangef		gl3wDepthRangef
#define glClearDepthf		gl3wClearDepthf
#define glGetProgramBinary		gl3wGetProgramBinary
#define glProgramBinary		gl3wProgramBinary
#define glProgramParameteri		gl3wProgramParameteri
#define glUseProgramStages		gl3wUseProgramStages
#define glActiveShaderProgram		gl3wActiveShaderProgram
#define glCreateShaderProgramv		gl3wCreateShaderProgramv
#define glBindProgramPipeline		gl3wBindProgramPipeline
#define glDeleteProgramPipelines		gl3wDeleteProgramPipelines
#define glGenProgramPipelines		gl3wGenProgramPipelines
#define glIsProgramPipeline		gl3wIsProgramPipeline
#define glGetProgramPipelineiv		gl3wGetProgramPipelineiv
#define glProgramUniform1i		gl3wProgramUniform1i
#define glProgramUniform1iv		gl3wProgramUniform1iv
#define glProgramUniform1f		gl3wProgramUniform1f
#define glProgramUniform1fv		gl3wProgramUniform1fv
#define glProgramUniform1d		gl3wProgramUniform1d
#define glProgramUniform1dv		gl3wProgramUniform1dv
#define glProgramUniform1ui		gl3wProgramUniform1ui
#define glProgramUniform1uiv		gl3wProgramUniform1uiv
#define glProgramUniform2i		gl3wProgramUniform2i
#define glProgramUniform2iv		gl3wProgramUniform2iv
#define glProgramUniform2f		gl3wProgramUniform2f
#define glProgramUniform2fv		gl3wProgramUniform2fv
#define glProgramUniform2d		gl3wProgramUniform2d
#define glProgramUniform2dv		gl3wProgramUniform2dv
#define glProgramUniform2ui		gl3wProgramUniform2ui
#define glProgramUniform2uiv		gl3wProgramUniform2uiv
#define glProgramUniform3i		gl3wProgramUniform3i
#define glProgramUniform3iv		gl3wProgramUniform3iv
#define glProgramUniform3f		gl3wProgramUniform3f
#define glProgramUniform3fv		gl3wProgramUniform3fv
#define glProgramUniform3d		gl3wProgramUniform3d
#define glProgramUniform3dv		gl3wProgramUniform3dv
#define glProgramUniform3ui		gl3wProgramUniform3ui
#define glProgramUniform3uiv		gl3wProgramUniform3uiv
#define glProgramUniform4i		gl3wProgramUniform4i
#define glProgramUniform4iv		gl3wProgramUniform4iv
#define glProgramUniform4f		gl3wProgramUniform4f
#define glProgramUniform4fv		gl3wProgramUniform4fv
#define glProgramUniform4d		gl3wProgramUniform4d
#define glProgramUniform4dv		gl3wProgramUniform4dv
#define glProgramUniform4ui		gl3wProgramUniform4ui
#define glProgramUniform4uiv		gl3wProgramUniform4uiv
#define glProgramUniformMatrix2fv		gl3wProgramUniformMatrix2fv
#define glProgramUniformMatrix3fv		gl3wProgramUniformMatrix3fv
#define glProgramUniformMatrix4fv		gl3wProgramUniformMatrix4fv
#define glProgramUniformMatrix2dv		gl3wProgramUniformMatrix2dv
#define glProgramUniformMatrix3dv		gl3wProgramUniformMatrix3dv
#define glProgramUniformMatrix4dv		gl3wProgramUniformMatrix4dv
#define glProgramUniformMatrix2x3fv		gl3wProgramUniformMatrix2x3fv
#define glProgramUniformMatrix3x2fv		gl3wProgramUniformMatrix3x2fv
#define glProgramUniformMatrix2x4fv		gl3wProgramUniformMatrix2x4fv
#define glProgramUniformMatrix4x2fv		gl3wProgramUniformMatrix4x2fv
#define glProgramUniformMatrix3x4fv		gl3wProgramUniformMatrix3x4fv
#define glProgramUniformMatrix4x3fv		gl3wProgramUniformMatrix4x3fv
#define glProgramUniformMatrix2x3dv		gl3wProgramUniformMatrix2x3dv
#define glProgramUniformMatrix3x2dv		gl3wProgramUniformMatrix3x2dv
#define glProgramUniformMatrix2x4dv		gl3wProgramUniformMatrix2x4dv
#define glProgramUniformMatrix4x2dv		gl3wProgramUniformMatrix4x2dv
#define glProgramUniformMatrix3x4dv		gl3wProgramUniformMatrix3x4dv
#define glProgramUniformMatrix4x3dv		gl3wProgramUniformMatrix4x3dv
#define glValidateProgramPipeline		gl3wValidateProgramPipeline
#define glGetProgramPipelineInfoLog		gl3wGetProgramPipelineInfoLog
#define glVertexAttribL1d		gl3wVertexAttribL1d
#define glVertexAttribL2d		gl3wVertexAttribL2d
#define glVertexAttribL3d		gl3wVertexAttribL3d
#define glVertexAttribL4d		gl3wVertexAttribL4d
#define glVertexAttribL1dv		gl3wVertexAttribL1dv
#define glVertexAttribL2dv		gl3wVertexAttribL2dv
#define glVertexAttribL3dv		gl3wVertexAttribL3dv
#define glVertexAttribL4dv		gl3wVertexAttribL4dv
#define glVertexAttribLPointer		gl3wVertexAttribLPointer
#define glGetVertexAttribLdv		gl3wGetVertexAttribLdv
#define glViewportArrayv		gl3wViewportArrayv
#define glViewportIndexedf		gl3wViewportIndexedf
#define glViewportIndexedfv		gl3wViewportIndexedfv
#define glScissorArrayv		gl3wScissorArrayv
#define glScissorIndexed		gl3wScissorIndexed
#define glScissorIndexedv		gl3wScissorIndexedv
#define glDepthRangeArrayv		gl3wDepthRangeArrayv
#define glDepthRangeIndexed		gl3wDepthRangeIndexed
#define glGetFloati_v		gl3wGetFloati_v
#define glGetDoublei_v		gl3wGetDoublei_v
#define glCreateSyncFromCLeventARB		gl3wCreateSyncFromCLeventARB
#define glDebugMessageControlARB		gl3wDebugMessageControlARB
#define glDebugMessageInsertARB		gl3wDebugMessageInsertARB
#define glDebugMessageCallbackARB		gl3wDebugMessageCallbackARB
#define glGetDebugMessageLogARB		gl3wGetDebugMessageLogARB
#define glGetGraphicsResetStatusARB		gl3wGetGraphicsResetStatusARB
#define glGetnTexImageARB		gl3wGetnTexImageARB
#define glReadnPixelsARB		gl3wReadnPixelsARB
#define glGetnCompressedTexImageARB		gl3wGetnCompressedTexImageARB
#define glGetnUniformfvARB		gl3wGetnUniformfvARB
#define glGetnUniformivARB		gl3wGetnUniformivARB
#define glGetnUniformuivARB		gl3wGetnUniformuivARB
#define glGetnUniformdvARB		gl3wGetnUniformdvARB
#define glDrawArraysInstancedBaseInstance		gl3wDrawArraysInstancedBaseInstance
#define glDrawElementsInstancedBaseInstance		gl3wDrawElementsInstancedBaseInstance
#define glDrawElementsInstancedBaseVertexBaseInstance		gl3wDrawElementsInstancedBaseVertexBaseInstance
#define glDrawTransformFeedbackInstanced		gl3wDrawTransformFeedbackInstanced
#define glDrawTransformFeedbackStreamInstanced		gl3wDrawTransformFeedbackStreamInstanced
#define glGetInternalformativ		gl3wGetInternalformativ
#define glGetActiveAtomicCounterBufferiv		gl3wGetActiveAtomicCounterBufferiv
#define glBindImageTexture		gl3wBindImageTexture
#define glMemoryBarrier		gl3wMemoryBarrier
#define glTexStorage1D		gl3wTexStorage1D
#define glTexStorage2D		gl3wTexStorage2D
#define glTexStorage3D		gl3wTexStorage3D
#define glTextureStorage1DEXT		gl3wTextureStorage1DEXT
#define glTextureStorage2DEXT		gl3wTextureStorage2DEXT
#define glTextureStorage3DEXT		gl3wTextureStorage3DEXT
#define glDebugMessageControl		gl3wDebugMessageControl
#define glDebugMessageInsert		gl3wDebugMessageInsert
#define glDebugMessageCallback		gl3wDebugMessageCallback
#define glGetDebugMessageLog		gl3wGetDebugMessageLog
#define glPushDebugGroup		gl3wPushDebugGroup
#define glPopDebugGroup		gl3wPopDebugGroup
#define glObjectLabel		gl3wObjectLabel
#define glGetObjectLabel		gl3wGetObjectLabel
#define glObjectPtrLabel		gl3wObjectPtrLabel
#define glGetObjectPtrLabel		gl3wGetObjectPtrLabel
#define glClearBufferData		gl3wClearBufferData
#define glClearBufferSubData		gl3wClearBufferSubData
#define glClearNamedBufferDataEXT		gl3wClearNamedBufferDataEXT
#define glClearNamedBufferSubDataEXT		gl3wClearNamedBufferSubDataEXT
#define glDispatchCompute		gl3wDispatchCompute
#define glDispatchComputeIndirect		gl3wDispatchComputeIndirect
#define glCopyImageSubData		gl3wCopyImageSubData
#define glTextureView		gl3wTextureView
#define glBindVertexBuffer		gl3wBindVertexBuffer
#define glVertexAttribFormat		gl3wVertexAttribFormat
#define glVertexAttribIFormat		gl3wVertexAttribIFormat
#define glVertexAttribLFormat		gl3wVertexAttribLFormat
#define glVertexAttribBinding		gl3wVertexAttribBinding
#define glVertexBindingDivisor		gl3wVertexBindingDivisor
#define glVertexArrayBindVertexBufferEXT		gl3wVertexArrayBindVertexBufferEXT
#define glVertexArrayVertexAttribFormatEXT		gl3wVertexArrayVertexAttribFormatEXT
#define glVertexArrayVertexAttribIFormatEXT		gl3wVertexArrayVertexAttribIFormatEXT
#define glVertexArrayVertexAttribLFormatEXT		gl3wVertexArrayVertexAttribLFormatEXT
#define glVertexArrayVertexAttribBindingEXT		gl3wVertexArrayVertexAttribBindingEXT
#define glVertexArrayVertexBindingDivisorEXT		gl3wVertexArrayVertexBindingDivisorEXT
#define glFramebufferParameteri		gl3wFramebufferParameteri
#define glGetFramebufferParameteriv		gl3wGetFramebufferParameteriv
#define glNamedFramebufferParameteriEXT		gl3wNamedFramebufferParameteriEXT
#define glGetNamedFramebufferParameterivEXT		gl3wGetNamedFramebufferParameterivEXT
#define glGetInternalformati64v		gl3wGetInternalformati64v
#define glInvalidateTexSubImage		gl3wInvalidateTexSubImage
#define glInvalidateTexImage		gl3wInvalidateTexImage
#define glInvalidateBufferSubData		gl3wInvalidateBufferSubData
#define glInvalidateBufferData		gl3wInvalidateBufferData
#define glInvalidateFramebuffer		gl3wInvalidateFramebuffer
#define glInvalidateSubFramebuffer		gl3wInvalidateSubFramebuffer
#define glMultiDrawArraysIndirect		gl3wMultiDrawArraysIndirect
#define glMultiDrawElementsIndirect		gl3wMultiDrawElementsIndirect
#define glGetProgramInterfaceiv		gl3wGetProgramInterfaceiv
#define glGetProgramResourceIndex		gl3wGetProgramResourceIndex
#define glGetProgramResourceName		gl3wGetProgramResourceName
#define glGetProgramResourceiv		gl3wGetProgramResourceiv
#define glGetProgramResourceLocation		gl3wGetProgramResourceLocation
#define glGetProgramResourceLocationIndex		gl3wGetProgramResourceLocationIndex
#define glShaderStorageBlockBinding		gl3wShaderStorageBlockBinding
#define glTexBufferRange		gl3wTexBufferRange
#define glTextureBufferRangeEXT		gl3wTextureBufferRangeEXT
#define glTexStorage2DMultisample		gl3wTexStorage2DMultisample
#define glTexStorage3DMultisample		gl3wTexStorage3DMultisample
#define glTextureStorage2DMultisampleEXT		gl3wTextureStorage2DMultisampleEXT
#define glTextureStorage3DMultisampleEXT		gl3wTextureStorage3DMultisampleEXT

#ifdef __cplusplus
}
#endif

#endif
```

`sakura/libs/opengl/glcorearb.h`:

```h
#ifndef __glcorearb_h_
#define __glcorearb_h_

#ifdef __cplusplus
extern "C" {
#endif

	/*
	** Copyright (c) 2007-2012 The Khronos Group Inc.
	**
	** Permission is hereby granted, free of charge, to any person obtaining a
	** copy of this software and/or associated documentation files (the
	** "Materials"), to deal in the Materials without restriction, including
	** without limitation the rights to use, copy, modify, merge, publish,
	** distribute, sublicense, and/or sell copies of the Materials, and to
	** permit persons to whom the Materials are furnished to do so, subject to
	** the following conditions:
	**
	** The above copyright notice and this permission notice shall be included
	** in all copies or substantial portions of the Materials.
	**
	** THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
	** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
	** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
	** MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
	*/

	/* glcorearb.h replaces gl3.h. It is for use with OpenGL core
	 * profile implementations.
	 *
	 * glcorearb.h last updated on $Date: 2012-09-19 19:02:24 -0700 (Wed, 19 Sep 2012) $
	 *
	 * RELEASE NOTES - 2012/09/19
	 *
	 * glcorearb.h should be placed in the same directory as gl.h and
	 * included as
	 * '<GL/glcorearb.h>'.
	 *
	 * glcorearb.h includes only APIs in the latest OpenGL core profile
	 * implementation together with APIs in newer ARB extensions which can be
	 * can be supported by the core profile. It does not, and never will
	 * include functionality removed from the core profile, such as
	 * fixed-function vertex and fragment processing.
	 *
	 * It is not possible to #include both <GL/glcorearb.h> and either of
	 * <GL/gl.h> or <GL/glext.h> in the same source file.
	 *
	 * Feedback can be given by registering for the Khronos Bugzilla
	 * (www.khronos.org/bugzilla) and filing issues there under product
	 * "OpenGL", category "Registry".
	 */

	 /* Function declaration macros - to move into glplatform.h */

#if defined(_WIN32) && !defined(APIENTRY) && !defined(__CYGWIN__) && !defined(__SCITECH_SNAP__)
#define WIN32_LEAN_AND_MEAN 1
#include <windows.h>
#endif

#ifndef APIENTRY
#define APIENTRY
#endif
#ifndef APIENTRYP
#define APIENTRYP APIENTRY *
#endif
#ifndef GLAPI
#define GLAPI extern
#endif

/* Base GL types */

	typedef unsigned int GLenum;
	typedef unsigned char GLboolean;
	typedef unsigned int GLbitfield;
	typedef signed char GLbyte;
	typedef short GLshort;
	typedef int GLint;
	typedef int GLsizei;
	typedef unsigned char GLubyte;
	typedef unsigned short GLushort;
	typedef unsigned int GLuint;
	typedef unsigned short GLhalf;
	typedef float GLfloat;
	typedef float GLclampf;
	typedef double GLdouble;
	typedef double GLclampd;
	typedef void GLvoid;

	/*************************************************************/

#ifndef GL_VERSION_1_1
/* AttribMask */
#define GL_DEPTH_BUFFER_BIT               0x00000100
#define GL_STENCIL_BUFFER_BIT             0x00000400
#define GL_COLOR_BUFFER_BIT               0x00004000
/* Boolean */
#define GL_FALSE                          0
#define GL_TRUE                           1
/* BeginMode */
#define GL_POINTS                         0x0000
#define GL_LINES                          0x0001
#define GL_LINE_LOOP                      0x0002
#define GL_LINE_STRIP                     0x0003
#define GL_TRIANGLES                      0x0004
#define GL_TRIANGLE_STRIP                 0x0005
#define GL_TRIANGLE_FAN                   0x0006
#define GL_QUADS                          0x0007
/* AlphaFunction */
#define GL_NEVER                          0x0200
#define GL_LESS                           0x0201
#define GL_EQUAL                          0x0202
#define GL_LEQUAL                         0x0203
#define GL_GREATER                        0x0204
#define GL_NOTEQUAL                       0x0205
#define GL_GEQUAL                         0x0206
#define GL_ALWAYS                         0x0207
/* BlendingFactorDest */
#define GL_ZERO                           0
#define GL_ONE                            1
#define GL_SRC_COLOR                      0x0300
#define GL_ONE_MINUS_SRC_COLOR            0x0301
#define GL_SRC_ALPHA                      0x0302
#define GL_ONE_MINUS_SRC_ALPHA            0x0303
#define GL_DST_ALPHA                      0x0304
#define GL_ONE_MINUS_DST_ALPHA            0x0305
/* BlendingFactorSrc */
#define GL_DST_COLOR                      0x0306
#define GL_ONE_MINUS_DST_COLOR            0x0307
#define GL_SRC_ALPHA_SATURATE             0x0308
/* DrawBufferMode */
#define GL_NONE                           0
#define GL_FRONT_LEFT                     0x0400
#define GL_FRONT_RIGHT                    0x0401
#define GL_BACK_LEFT                      0x0402
#define GL_BACK_RIGHT                     0x0403
#define GL_FRONT                          0x0404
#define GL_BACK                           0x0405
#define GL_LEFT                           0x0406
#define GL_RIGHT                          0x0407
#define GL_FRONT_AND_BACK                 0x0408
/* ErrorCode */
#define GL_NO_ERROR                       0
#define GL_INVALID_ENUM                   0x0500
#define GL_INVALID_VALUE                  0x0501
#define GL_INVALID_OPERATION              0x0502
#define GL_OUT_OF_MEMORY                  0x0505
/* FrontFaceDirection */
#define GL_CW                             0x0900
#define GL_CCW                            0x0901
/* GetPName */
#define GL_POINT_SIZE                     0x0B11
#define GL_POINT_SIZE_RANGE               0x0B12
#define GL_POINT_SIZE_GRANULARITY         0x0B13
#define GL_LINE_SMOOTH                    0x0B20
#define GL_LINE_WIDTH                     0x0B21
#define GL_LINE_WIDTH_RANGE               0x0B22
#define GL_LINE_WIDTH_GRANULARITY         0x0B23
#define GL_POLYGON_MODE                   0x0B40
#define GL_POLYGON_SMOOTH                 0x0B41
#define GL_CULL_FACE                      0x0B44
#define GL_CULL_FACE_MODE                 0x0B45
#define GL_FRONT_FACE                     0x0B46
#define GL_DEPTH_RANGE                    0x0B70
#define GL_DEPTH_TEST                     0x0B71
#define GL_DEPTH_WRITEMASK                0x0B72
#define GL_DEPTH_CLEAR_VALUE              0x0B73
#define GL_DEPTH_FUNC                     0x0B74
#define GL_STENCIL_TEST                   0x0B90
#define GL_STENCIL_CLEAR_VALUE            0x0B91
#define GL_STENCIL_FUNC                   0x0B92
#define GL_STENCIL_VALUE_MASK             0x0B93
#define GL_STENCIL_FAIL                   0x0B94
#define GL_STENCIL_PASS_DEPTH_FAIL        0x0B95
#define GL_STENCIL_PASS_DEPTH_PASS        0x0B96
#define GL_STENCIL_REF                    0x0B97
#define GL_STENCIL_WRITEMASK              0x0B98
#define GL_VIEWPORT                       0x0BA2
#define GL_DITHER                         0x0BD0
#define GL_BLEND_DST                      0x0BE0
#define GL_BLEND_SRC                      0x0BE1
#define GL_BLEND                          0x0BE2
#define GL_LOGIC_OP_MODE                  0x0BF0
#define GL_COLOR_LOGIC_OP                 0x0BF2
#define GL_DRAW_BUFFER                    0x0C01
#define GL_READ_BUFFER                    0x0C02
#define GL_SCISSOR_BOX                    0x0C10
#define GL_SCISSOR_TEST                   0x0C11
#define GL_COLOR_CLEAR_VALUE              0x0C22
#define GL_COLOR_WRITEMASK                0x0C23
#define GL_DOUBLEBUFFER                   0x0C32
#define GL_STEREO                         0x0C33
#define GL_LINE_SMOOTH_HINT               0x0C52
#define GL_POLYGON_SMOOTH_HINT            0x0C53
#define GL_UNPACK_SWAP_BYTES              0x0CF0
#define GL_UNPACK_LSB_FIRST               0x0CF1
#define GL_UNPACK_ROW_LENGTH              0x0CF2
#define GL_UNPACK_SKIP_ROWS               0x0CF3
#define GL_UNPACK_SKIP_PIXELS             0x0CF4
#define GL_UNPACK_ALIGNMENT               0x0CF5
#define GL_PACK_SWAP_BYTES                0x0D00
#define GL_PACK_LSB_FIRST                 0x0D01
#define GL_PACK_ROW_LENGTH                0x0D02
#define GL_PACK_SKIP_ROWS                 0x0D03
#define GL_PACK_SKIP_PIXELS               0x0D04
#define GL_PACK_ALIGNMENT                 0x0D05
#define GL_MAX_TEXTURE_SIZE               0x0D33
#define GL_MAX_VIEWPORT_DIMS              0x0D3A
#define GL_SUBPIXEL_BITS                  0x0D50
#define GL_TEXTURE_1D                     0x0DE0
#define GL_TEXTURE_2D                     0x0DE1
#define GL_POLYGON_OFFSET_UNITS           0x2A00
#define GL_POLYGON_OFFSET_POINT           0x2A01
#define GL_POLYGON_OFFSET_LINE            0x2A02
#define GL_POLYGON_OFFSET_FILL            0x8037
#define GL_POLYGON_OFFSET_FACTOR          0x8038
#define GL_TEXTURE_BINDING_1D             0x8068
#define GL_TEXTURE_BINDING_2D             0x8069
/* GetTextureParameter */
#define GL_TEXTURE_WIDTH                  0x1000
#define GL_TEXTURE_HEIGHT                 0x1001
#define GL_TEXTURE_INTERNAL_FORMAT        0x1003
#define GL_TEXTURE_BORDER_COLOR           0x1004
#define GL_TEXTURE_RED_SIZE               0x805C
#define GL_TEXTURE_GREEN_SIZE             0x805D
#define GL_TEXTURE_BLUE_SIZE              0x805E
#define GL_TEXTURE_ALPHA_SIZE             0x805F
/* HintMode */
#define GL_DONT_CARE                      0x1100
#define GL_FASTEST                        0x1101
#define GL_NICEST                         0x1102
/* DataType */
#define GL_BYTE                           0x1400
#define GL_UNSIGNED_BYTE                  0x1401
#define GL_SHORT                          0x1402
#define GL_UNSIGNED_SHORT                 0x1403
#define GL_INT                            0x1404
#define GL_UNSIGNED_INT                   0x1405
#define GL_FLOAT                          0x1406
#define GL_DOUBLE                         0x140A
/* ErrorCode */
#define GL_STACK_OVERFLOW                 0x0503
#define GL_STACK_UNDERFLOW                0x0504
/* LogicOp */
#define GL_CLEAR                          0x1500
#define GL_AND                            0x1501
#define GL_AND_REVERSE                    0x1502
#define GL_COPY                           0x1503
#define GL_AND_INVERTED                   0x1504
#define GL_NOOP                           0x1505
#define GL_XOR                            0x1506
#define GL_OR                             0x1507
#define GL_NOR                            0x1508
#define GL_EQUIV                          0x1509
#define GL_INVERT                         0x150A
#define GL_OR_REVERSE                     0x150B
#define GL_COPY_INVERTED                  0x150C
#define GL_OR_INVERTED                    0x150D
#define GL_NAND                           0x150E
#define GL_SET                            0x150F
/* MatrixMode (for gl3.h, FBO attachment type) */
#define GL_TEXTURE                        0x1702
/* PixelCopyType */
#define GL_COLOR                          0x1800
#define GL_DEPTH                          0x1801
#define GL_STENCIL                        0x1802
/* PixelFormat */
#define GL_STENCIL_INDEX                  0x1901
#define GL_DEPTH_COMPONENT                0x1902
#define GL_RED                            0x1903
#define GL_GREEN                          0x1904
#define GL_BLUE                           0x1905
#define GL_ALPHA                          0x1906
#define GL_RGB                            0x1907
#define GL_RGBA                           0x1908
/* PolygonMode */
#define GL_POINT                          0x1B00
#define GL_LINE                           0x1B01
#define GL_FILL                           0x1B02
/* StencilOp */
#define GL_KEEP                           0x1E00
#define GL_REPLACE                        0x1E01
#define GL_INCR                           0x1E02
#define GL_DECR                           0x1E03
/* StringName */
#define GL_VENDOR                         0x1F00
#define GL_RENDERER                       0x1F01
#define GL_VERSION                        0x1F02
#define GL_EXTENSIONS                     0x1F03
/* TextureMagFilter */
#define GL_NEAREST                        0x2600
#define GL_LINEAR                         0x2601
/* TextureMinFilter */
#define GL_NEAREST_MIPMAP_NEAREST         0x2700
#define GL_LINEAR_MIPMAP_NEAREST          0x2701
#define GL_NEAREST_MIPMAP_LINEAR          0x2702
#define GL_LINEAR_MIPMAP_LINEAR           0x2703
/* TextureParameterName */
#define GL_TEXTURE_MAG_FILTER             0x2800
#define GL_TEXTURE_MIN_FILTER             0x2801
#define GL_TEXTURE_WRAP_S                 0x2802
#define GL_TEXTURE_WRAP_T                 0x2803
/* TextureTarget */
#define GL_PROXY_TEXTURE_1D               0x8063
#define GL_PROXY_TEXTURE_2D               0x8064
/* TextureWrapMode */
#define GL_REPEAT                         0x2901
/* PixelInternalFormat */
#define GL_R3_G3_B2                       0x2A10
#define GL_RGB4                           0x804F
#define GL_RGB5                           0x8050
#define GL_RGB8                           0x8051
#define GL_RGB10                          0x8052
#define GL_RGB12                          0x8053
#define GL_RGB16                          0x8054
#define GL_RGBA2                          0x8055
#define GL_RGBA4                          0x8056
#define GL_RGB5_A1                        0x8057
#define GL_RGBA8                          0x8058
#define GL_RGB10_A2                       0x8059
#define GL_RGBA12                         0x805A
#define GL_RGBA16                         0x805B
#endif

#ifndef GL_VERSION_1_2
#define GL_UNSIGNED_BYTE_3_3_2            0x8032
#define GL_UNSIGNED_SHORT_4_4_4_4         0x8033
#define GL_UNSIGNED_SHORT_5_5_5_1         0x8034
#define GL_UNSIGNED_INT_8_8_8_8           0x8035
#define GL_UNSIGNED_INT_10_10_10_2        0x8036
#define GL_TEXTURE_BINDING_3D             0x806A
#define GL_PACK_SKIP_IMAGES               0x806B
#define GL_PACK_IMAGE_HEIGHT              0x806C
#define GL_UNPACK_SKIP_IMAGES             0x806D
#define GL_UNPACK_IMAGE_HEIGHT            0x806E
#define GL_TEXTURE_3D                     0x806F
#define GL_PROXY_TEXTURE_3D               0x8070
#define GL_TEXTURE_DEPTH                  0x8071
#define GL_TEXTURE_WRAP_R                 0x8072
#define GL_MAX_3D_TEXTURE_SIZE            0x8073
#define GL_UNSIGNED_BYTE_2_3_3_REV        0x8362
#define GL_UNSIGNED_SHORT_5_6_5           0x8363
#define GL_UNSIGNED_SHORT_5_6_5_REV       0x8364
#define GL_UNSIGNED_SHORT_4_4_4_4_REV     0x8365
#define GL_UNSIGNED_SHORT_1_5_5_5_REV     0x8366
#define GL_UNSIGNED_INT_8_8_8_8_REV       0x8367
#define GL_UNSIGNED_INT_2_10_10_10_REV    0x8368
#define GL_BGR                            0x80E0
#define GL_BGRA                           0x80E1
#define GL_MAX_ELEMENTS_VERTICES          0x80E8
#define GL_MAX_ELEMENTS_INDICES           0x80E9
#define GL_CLAMP_TO_EDGE                  0x812F
#define GL_TEXTURE_MIN_LOD                0x813A
#define GL_TEXTURE_MAX_LOD                0x813B
#define GL_TEXTURE_BASE_LEVEL             0x813C
#define GL_TEXTURE_MAX_LEVEL              0x813D
#define GL_SMOOTH_POINT_SIZE_RANGE        0x0B12
#define GL_SMOOTH_POINT_SIZE_GRANULARITY  0x0B13
#define GL_SMOOTH_LINE_WIDTH_RANGE        0x0B22
#define GL_SMOOTH_LINE_WIDTH_GRANULARITY  0x0B23
#define GL_ALIASED_LINE_WIDTH_RANGE       0x846E
#endif

#ifndef GL_ARB_imaging
#define GL_CONSTANT_COLOR                 0x8001
#define GL_ONE_MINUS_CONSTANT_COLOR       0x8002
#define GL_CONSTANT_ALPHA                 0x8003
#define GL_ONE_MINUS_CONSTANT_ALPHA       0x8004
#define GL_BLEND_COLOR                    0x8005
#define GL_FUNC_ADD                       0x8006
#define GL_MIN                            0x8007
#define GL_MAX                            0x8008
#define GL_BLEND_EQUATION                 0x8009
#define GL_FUNC_SUBTRACT                  0x800A
#define GL_FUNC_REVERSE_SUBTRACT          0x800B
#endif

#ifndef GL_VERSION_1_3
#define GL_TEXTURE0                       0x84C0
#define GL_TEXTURE1                       0x84C1
#define GL_TEXTURE2                       0x84C2
#define GL_TEXTURE3                       0x84C3
#define GL_TEXTURE4                       0x84C4
#define GL_TEXTURE5                       0x84C5
#define GL_TEXTURE6                       0x84C6
#define GL_TEXTURE7                       0x84C7
#define GL_TEXTURE8                       0x84C8
#define GL_TEXTURE9                       0x84C9
#define GL_TEXTURE10                      0x84CA
#define GL_TEXTURE11                      0x84CB
#define GL_TEXTURE12                      0x84CC
#define GL_TEXTURE13                      0x84CD
#define GL_TEXTURE14                      0x84CE
#define GL_TEXTURE15                      0x84CF
#define GL_TEXTURE16                      0x84D0
#define GL_TEXTURE17                      0x84D1
#define GL_TEXTURE18                      0x84D2
#define GL_TEXTURE19                      0x84D3
#define GL_TEXTURE20                      0x84D4
#define GL_TEXTURE21                      0x84D5
#define GL_TEXTURE22                      0x84D6
#define GL_TEXTURE23                      0x84D7
#define GL_TEXTURE24                      0x84D8
#define GL_TEXTURE25                      0x84D9
#define GL_TEXTURE26                      0x84DA
#define GL_TEXTURE27                      0x84DB
#define GL_TEXTURE28                      0x84DC
#define GL_TEXTURE29                      0x84DD
#define GL_TEXTURE30                      0x84DE
#define GL_TEXTURE31                      0x84DF
#define GL_ACTIVE_TEXTURE                 0x84E0
#define GL_MULTISAMPLE                    0x809D
#define GL_SAMPLE_ALPHA_TO_COVERAGE       0x809E
#define GL_SAMPLE_ALPHA_TO_ONE            0x809F
#define GL_SAMPLE_COVERAGE                0x80A0
#define GL_SAMPLE_BUFFERS                 0x80A8
#define GL_SAMPLES                        0x80A9
#define GL_SAMPLE_COVERAGE_VALUE          0x80AA
#define GL_SAMPLE_COVERAGE_INVERT         0x80AB
#define GL_TEXTURE_CUBE_MAP               0x8513
#define GL_TEXTURE_BINDING_CUBE_MAP       0x8514
#define GL_TEXTURE_CUBE_MAP_POSITIVE_X    0x8515
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_X    0x8516
#define GL_TEXTURE_CUBE_MAP_POSITIVE_Y    0x8517
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Y    0x8518
#define GL_TEXTURE_CUBE_MAP_POSITIVE_Z    0x8519
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Z    0x851A
#define GL_PROXY_TEXTURE_CUBE_MAP         0x851B
#define GL_MAX_CUBE_MAP_TEXTURE_SIZE      0x851C
#define GL_COMPRESSED_RGB                 0x84ED
#define GL_COMPRESSED_RGBA                0x84EE
#define GL_TEXTURE_COMPRESSION_HINT       0x84EF
#define GL_TEXTURE_COMPRESSED_IMAGE_SIZE  0x86A0
#define GL_TEXTURE_COMPRESSED             0x86A1
#define GL_NUM_COMPRESSED_TEXTURE_FORMATS 0x86A2
#define GL_COMPRESSED_TEXTURE_FORMATS     0x86A3
#define GL_CLAMP_TO_BORDER                0x812D
#endif

#ifndef GL_VERSION_1_4
#define GL_BLEND_DST_RGB                  0x80C8
#define GL_BLEND_SRC_RGB                  0x80C9
#define GL_BLEND_DST_ALPHA                0x80CA
#define GL_BLEND_SRC_ALPHA                0x80CB
#define GL_POINT_FADE_THRESHOLD_SIZE      0x8128
#define GL_DEPTH_COMPONENT16              0x81A5
#define GL_DEPTH_COMPONENT24              0x81A6
#define GL_DEPTH_COMPONENT32              0x81A7
#define GL_MIRRORED_REPEAT                0x8370
#define GL_MAX_TEXTURE_LOD_BIAS           0x84FD
#define GL_TEXTURE_LOD_BIAS               0x8501
#define GL_INCR_WRAP                      0x8507
#define GL_DECR_WRAP                      0x8508
#define GL_TEXTURE_DEPTH_SIZE             0x884A
#define GL_TEXTURE_COMPARE_MODE           0x884C
#define GL_TEXTURE_COMPARE_FUNC           0x884D
#endif

#ifndef GL_VERSION_1_5
#define GL_BUFFER_SIZE                    0x8764
#define GL_BUFFER_USAGE                   0x8765
#define GL_QUERY_COUNTER_BITS             0x8864
#define GL_CURRENT_QUERY                  0x8865
#define GL_QUERY_RESULT                   0x8866
#define GL_QUERY_RESULT_AVAILABLE         0x8867
#define GL_ARRAY_BUFFER                   0x8892
#define GL_ELEMENT_ARRAY_BUFFER           0x8893
#define GL_ARRAY_BUFFER_BINDING           0x8894
#define GL_ELEMENT_ARRAY_BUFFER_BINDING   0x8895
#define GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING 0x889F
#define GL_READ_ONLY                      0x88B8
#define GL_WRITE_ONLY                     0x88B9
#define GL_READ_WRITE                     0x88BA
#define GL_BUFFER_ACCESS                  0x88BB
#define GL_BUFFER_MAPPED                  0x88BC
#define GL_BUFFER_MAP_POINTER             0x88BD
#define GL_STREAM_DRAW                    0x88E0
#define GL_STREAM_READ                    0x88E1
#define GL_STREAM_COPY                    0x88E2
#define GL_STATIC_DRAW                    0x88E4
#define GL_STATIC_READ                    0x88E5
#define GL_STATIC_COPY                    0x88E6
#define GL_DYNAMIC_DRAW                   0x88E8
#define GL_DYNAMIC_READ                   0x88E9
#define GL_DYNAMIC_COPY                   0x88EA
#define GL_SAMPLES_PASSED                 0x8914
#define GL_SRC1_ALPHA                     0x8589
#endif

#ifndef GL_VERSION_2_0
#define GL_BLEND_EQUATION_RGB             0x8009
#define GL_VERTEX_ATTRIB_ARRAY_ENABLED    0x8622
#define GL_VERTEX_ATTRIB_ARRAY_SIZE       0x8623
#define GL_VERTEX_ATTRIB_ARRAY_STRIDE     0x8624
#define GL_VERTEX_ATTRIB_ARRAY_TYPE       0x8625
#define GL_CURRENT_VERTEX_ATTRIB          0x8626
#define GL_VERTEX_PROGRAM_POINT_SIZE      0x8642
#define GL_VERTEX_ATTRIB_ARRAY_POINTER    0x8645
#define GL_STENCIL_BACK_FUNC              0x8800
#define GL_STENCIL_BACK_FAIL              0x8801
#define GL_STENCIL_BACK_PASS_DEPTH_FAIL   0x8802
#define GL_STENCIL_BACK_PASS_DEPTH_PASS   0x8803
#define GL_MAX_DRAW_BUFFERS               0x8824
#define GL_DRAW_BUFFER0                   0x8825
#define GL_DRAW_BUFFER1                   0x8826
#define GL_DRAW_BUFFER2                   0x8827
#define GL_DRAW_BUFFER3                   0x8828
#define GL_DRAW_BUFFER4                   0x8829
#define GL_DRAW_BUFFER5                   0x882A
#define GL_DRAW_BUFFER6                   0x882B
#define GL_DRAW_BUFFER7                   0x882C
#define GL_DRAW_BUFFER8                   0x882D
#define GL_DRAW_BUFFER9                   0x882E
#define GL_DRAW_BUFFER10                  0x882F
#define GL_DRAW_BUFFER11                  0x8830
#define GL_DRAW_BUFFER12                  0x8831
#define GL_DRAW_BUFFER13                  0x8832
#define GL_DRAW_BUFFER14                  0x8833
#define GL_DRAW_BUFFER15                  0x8834
#define GL_BLEND_EQUATION_ALPHA           0x883D
#define GL_MAX_VERTEX_ATTRIBS             0x8869
#define GL_VERTEX_ATTRIB_ARRAY_NORMALIZED 0x886A
#define GL_MAX_TEXTURE_IMAGE_UNITS        0x8872
#define GL_FRAGMENT_SHADER                0x8B30
#define GL_VERTEX_SHADER                  0x8B31
#define GL_MAX_FRAGMENT_UNIFORM_COMPONENTS 0x8B49
#define GL_MAX_VERTEX_UNIFORM_COMPONENTS  0x8B4A
#define GL_MAX_VARYING_FLOATS             0x8B4B
#define GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS 0x8B4C
#define GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS 0x8B4D
#define GL_SHADER_TYPE                    0x8B4F
#define GL_FLOAT_VEC2                     0x8B50
#define GL_FLOAT_VEC3                     0x8B51
#define GL_FLOAT_VEC4                     0x8B52
#define GL_INT_VEC2                       0x8B53
#define GL_INT_VEC3                       0x8B54
#define GL_INT_VEC4                       0x8B55
#define GL_BOOL                           0x8B56
#define GL_BOOL_VEC2                      0x8B57
#define GL_BOOL_VEC3                      0x8B58
#define GL_BOOL_VEC4                      0x8B59
#define GL_FLOAT_MAT2                     0x8B5A
#define GL_FLOAT_MAT3                     0x8B5B
#define GL_FLOAT_MAT4                     0x8B5C
#define GL_SAMPLER_1D                     0x8B5D
#define GL_SAMPLER_2D                     0x8B5E
#define GL_SAMPLER_3D                     0x8B5F
#define GL_SAMPLER_CUBE                   0x8B60
#define GL_SAMPLER_1D_SHADOW              0x8B61
#define GL_SAMPLER_2D_SHADOW              0x8B62
#define GL_DELETE_STATUS                  0x8B80
#define GL_COMPILE_STATUS                 0x8B81
#define GL_LINK_STATUS                    0x8B82
#define GL_VALIDATE_STATUS                0x8B83
#define GL_INFO_LOG_LENGTH                0x8B84
#define GL_ATTACHED_SHADERS               0x8B85
#define GL_ACTIVE_UNIFORMS                0x8B86
#define GL_ACTIVE_UNIFORM_MAX_LENGTH      0x8B87
#define GL_SHADER_SOURCE_LENGTH           0x8B88
#define GL_ACTIVE_ATTRIBUTES              0x8B89
#define GL_ACTIVE_ATTRIBUTE_MAX_LENGTH    0x8B8A
#define GL_FRAGMENT_SHADER_DERIVATIVE_HINT 0x8B8B
#define GL_SHADING_LANGUAGE_VERSION       0x8B8C
#define GL_CURRENT_PROGRAM                0x8B8D
#define GL_POINT_SPRITE_COORD_ORIGIN      0x8CA0
#define GL_LOWER_LEFT                     0x8CA1
#define GL_UPPER_LEFT                     0x8CA2
#define GL_STENCIL_BACK_REF               0x8CA3
#define GL_STENCIL_BACK_VALUE_MASK        0x8CA4
#define GL_STENCIL_BACK_WRITEMASK         0x8CA5
#endif

#ifndef GL_VERSION_2_1
#define GL_PIXEL_PACK_BUFFER              0x88EB
#define GL_PIXEL_UNPACK_BUFFER            0x88EC
#define GL_PIXEL_PACK_BUFFER_BINDING      0x88ED
#define GL_PIXEL_UNPACK_BUFFER_BINDING    0x88EF
#define GL_FLOAT_MAT2x3                   0x8B65
#define GL_FLOAT_MAT2x4                   0x8B66
#define GL_FLOAT_MAT3x2                   0x8B67
#define GL_FLOAT_MAT3x4                   0x8B68
#define GL_FLOAT_MAT4x2                   0x8B69
#define GL_FLOAT_MAT4x3                   0x8B6A
#define GL_SRGB                           0x8C40
#define GL_SRGB8                          0x8C41
#define GL_SRGB_ALPHA                     0x8C42
#define GL_SRGB8_ALPHA8                   0x8C43
#define GL_COMPRESSED_SRGB                0x8C48
#define GL_COMPRESSED_SRGB_ALPHA          0x8C49
#endif

#ifndef GL_VERSION_3_0
#define GL_COMPARE_REF_TO_TEXTURE         0x884E
#define GL_CLIP_DISTANCE0                 0x3000
#define GL_CLIP_DISTANCE1                 0x3001
#define GL_CLIP_DISTANCE2                 0x3002
#define GL_CLIP_DISTANCE3                 0x3003
#define GL_CLIP_DISTANCE4                 0x3004
#define GL_CLIP_DISTANCE5                 0x3005
#define GL_CLIP_DISTANCE6                 0x3006
#define GL_CLIP_DISTANCE7                 0x3007
#define GL_MAX_CLIP_DISTANCES             0x0D32
#define GL_MAJOR_VERSION                  0x821B
#define GL_MINOR_VERSION                  0x821C
#define GL_NUM_EXTENSIONS                 0x821D
#define GL_CONTEXT_FLAGS                  0x821E
#define GL_COMPRESSED_RED                 0x8225
#define GL_COMPRESSED_RG                  0x8226
#define GL_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT 0x0001
#define GL_RGBA32F                        0x8814
#define GL_RGB32F                         0x8815
#define GL_RGBA16F                        0x881A
#define GL_RGB16F                         0x881B
#define GL_VERTEX_ATTRIB_ARRAY_INTEGER    0x88FD
#define GL_MAX_ARRAY_TEXTURE_LAYERS       0x88FF
#define GL_MIN_PROGRAM_TEXEL_OFFSET       0x8904
#define GL_MAX_PROGRAM_TEXEL_OFFSET       0x8905
#define GL_CLAMP_READ_COLOR               0x891C
#define GL_FIXED_ONLY                     0x891D
#define GL_MAX_VARYING_COMPONENTS         0x8B4B
#define GL_TEXTURE_1D_ARRAY               0x8C18
#define GL_PROXY_TEXTURE_1D_ARRAY         0x8C19
#define GL_TEXTURE_2D_ARRAY               0x8C1A
#define GL_PROXY_TEXTURE_2D_ARRAY         0x8C1B
#define GL_TEXTURE_BINDING_1D_ARRAY       0x8C1C
#define GL_TEXTURE_BINDING_2D_ARRAY       0x8C1D
#define GL_R11F_G11F_B10F                 0x8C3A
#define GL_UNSIGNED_INT_10F_11F_11F_REV   0x8C3B
#define GL_RGB9_E5                        0x8C3D
#define GL_UNSIGNED_INT_5_9_9_9_REV       0x8C3E
#define GL_TEXTURE_SHARED_SIZE            0x8C3F
#define GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH 0x8C76
#define GL_TRANSFORM_FEEDBACK_BUFFER_MODE 0x8C7F
#define GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS 0x8C80
#define GL_TRANSFORM_FEEDBACK_VARYINGS    0x8C83
#define GL_TRANSFORM_FEEDBACK_BUFFER_START 0x8C84
#define GL_TRANSFORM_FEEDBACK_BUFFER_SIZE 0x8C85
#define GL_PRIMITIVES_GENERATED           0x8C87
#define GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN 0x8C88
#define GL_RASTERIZER_DISCARD             0x8C89
#define GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS 0x8C8A
#define GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS 0x8C8B
#define GL_INTERLEAVED_ATTRIBS            0x8C8C
#define GL_SEPARATE_ATTRIBS               0x8C8D
#define GL_TRANSFORM_FEEDBACK_BUFFER      0x8C8E
#define GL_TRANSFORM_FEEDBACK_BUFFER_BINDING 0x8C8F
#define GL_RGBA32UI                       0x8D70
#define GL_RGB32UI                        0x8D71
#define GL_RGBA16UI                       0x8D76
#define GL_RGB16UI                        0x8D77
#define GL_RGBA8UI                        0x8D7C
#define GL_RGB8UI                         0x8D7D
#define GL_RGBA32I                        0x8D82
#define GL_RGB32I                         0x8D83
#define GL_RGBA16I                        0x8D88
#define GL_RGB16I                         0x8D89
#define GL_RGBA8I                         0x8D8E
#define GL_RGB8I                          0x8D8F
#define GL_RED_INTEGER                    0x8D94
#define GL_GREEN_INTEGER                  0x8D95
#define GL_BLUE_INTEGER                   0x8D96
#define GL_RGB_INTEGER                    0x8D98
#define GL_RGBA_INTEGER                   0x8D99
#define GL_BGR_INTEGER                    0x8D9A
#define GL_BGRA_INTEGER                   0x8D9B
#define GL_SAMPLER_1D_ARRAY               0x8DC0
#define GL_SAMPLER_2D_ARRAY               0x8DC1
#define GL_SAMPLER_1D_ARRAY_SHADOW        0x8DC3
#define GL_SAMPLER_2D_ARRAY_SHADOW        0x8DC4
#define GL_SAMPLER_CUBE_SHADOW            0x8DC5
#define GL_UNSIGNED_INT_VEC2              0x8DC6
#define GL_UNSIGNED_INT_VEC3              0x8DC7
#define GL_UNSIGNED_INT_VEC4              0x8DC8
#define GL_INT_SAMPLER_1D                 0x8DC9
#define GL_INT_SAMPLER_2D                 0x8DCA
#define GL_INT_SAMPLER_3D                 0x8DCB
#define GL_INT_SAMPLER_CUBE               0x8DCC
#define GL_INT_SAMPLER_1D_ARRAY           0x8DCE
#define GL_INT_SAMPLER_2D_ARRAY           0x8DCF
#define GL_UNSIGNED_INT_SAMPLER_1D        0x8DD1
#define GL_UNSIGNED_INT_SAMPLER_2D        0x8DD2
#define GL_UNSIGNED_INT_SAMPLER_3D        0x8DD3
#define GL_UNSIGNED_INT_SAMPLER_CUBE      0x8DD4
#define GL_UNSIGNED_INT_SAMPLER_1D_ARRAY  0x8DD6
#define GL_UNSIGNED_INT_SAMPLER_2D_ARRAY  0x8DD7
#define GL_QUERY_WAIT                     0x8E13
#define GL_QUERY_NO_WAIT                  0x8E14
#define GL_QUERY_BY_REGION_WAIT           0x8E15
#define GL_QUERY_BY_REGION_NO_WAIT        0x8E16
#define GL_BUFFER_ACCESS_FLAGS            0x911F
#define GL_BUFFER_MAP_LENGTH              0x9120
#define GL_BUFFER_MAP_OFFSET              0x9121
/* Reuse tokens from ARB_depth_buffer_float */
/* reuse GL_DEPTH_COMPONENT32F */
/* reuse GL_DEPTH32F_STENCIL8 */
/* reuse GL_FLOAT_32_UNSIGNED_INT_24_8_REV */
/* Reuse tokens from ARB_framebuffer_object */
/* reuse GL_INVALID_FRAMEBUFFER_OPERATION */
/* reuse GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING */
/* reuse GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE */
/* reuse GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE */
/* reuse GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE */
/* reuse GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE */
/* reuse GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE */
/* reuse GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE */
/* reuse GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE */
/* reuse GL_FRAMEBUFFER_DEFAULT */
/* reuse GL_FRAMEBUFFER_UNDEFINED */
/* reuse GL_DEPTH_STENCIL_ATTACHMENT */
/* reuse GL_INDEX */
/* reuse GL_MAX_RENDERBUFFER_SIZE */
/* reuse GL_DEPTH_STENCIL */
/* reuse GL_UNSIGNED_INT_24_8 */
/* reuse GL_DEPTH24_STENCIL8 */
/* reuse GL_TEXTURE_STENCIL_SIZE */
/* reuse GL_TEXTURE_RED_TYPE */
/* reuse GL_TEXTURE_GREEN_TYPE */
/* reuse GL_TEXTURE_BLUE_TYPE */
/* reuse GL_TEXTURE_ALPHA_TYPE */
/* reuse GL_TEXTURE_DEPTH_TYPE */
/* reuse GL_UNSIGNED_NORMALIZED */
/* reuse GL_FRAMEBUFFER_BINDING */
/* reuse GL_DRAW_FRAMEBUFFER_BINDING */
/* reuse GL_RENDERBUFFER_BINDING */
/* reuse GL_READ_FRAMEBUFFER */
/* reuse GL_DRAW_FRAMEBUFFER */
/* reuse GL_READ_FRAMEBUFFER_BINDING */
/* reuse GL_RENDERBUFFER_SAMPLES */
/* reuse GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE */
/* reuse GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME */
/* reuse GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL */
/* reuse GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE */
/* reuse GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER */
/* reuse GL_FRAMEBUFFER_COMPLETE */
/* reuse GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT */
/* reuse GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT */
/* reuse GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER */
/* reuse GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER */
/* reuse GL_FRAMEBUFFER_UNSUPPORTED */
/* reuse GL_MAX_COLOR_ATTACHMENTS */
/* reuse GL_COLOR_ATTACHMENT0 */
/* reuse GL_COLOR_ATTACHMENT1 */
/* reuse GL_COLOR_ATTACHMENT2 */
/* reuse GL_COLOR_ATTACHMENT3 */
/* reuse GL_COLOR_ATTACHMENT4 */
/* reuse GL_COLOR_ATTACHMENT5 */
/* reuse GL_COLOR_ATTACHMENT6 */
/* reuse GL_COLOR_ATTACHMENT7 */
/* reuse GL_COLOR_ATTACHMENT8 */
/* reuse GL_COLOR_ATTACHMENT9 */
/* reuse GL_COLOR_ATTACHMENT10 */
/* reuse GL_COLOR_ATTACHMENT11 */
/* reuse GL_COLOR_ATTACHMENT12 */
/* reuse GL_COLOR_ATTACHMENT13 */
/* reuse GL_COLOR_ATTACHMENT14 */
/* reuse GL_COLOR_ATTACHMENT15 */
/* reuse GL_DEPTH_ATTACHMENT */
/* reuse GL_STENCIL_ATTACHMENT */
/* reuse GL_FRAMEBUFFER */
/* reuse GL_RENDERBUFFER */
/* reuse GL_RENDERBUFFER_WIDTH */
/* reuse GL_RENDERBUFFER_HEIGHT */
/* reuse GL_RENDERBUFFER_INTERNAL_FORMAT */
/* reuse GL_STENCIL_INDEX1 */
/* reuse GL_STENCIL_INDEX4 */
/* reuse GL_STENCIL_INDEX8 */
/* reuse GL_STENCIL_INDEX16 */
/* reuse GL_RENDERBUFFER_RED_SIZE */
/* reuse GL_RENDERBUFFER_GREEN_SIZE */
/* reuse GL_RENDERBUFFER_BLUE_SIZE */
/* reuse GL_RENDERBUFFER_ALPHA_SIZE */
/* reuse GL_RENDERBUFFER_DEPTH_SIZE */
/* reuse GL_RENDERBUFFER_STENCIL_SIZE */
/* reuse GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE */
/* reuse GL_MAX_SAMPLES */
/* Reuse tokens from ARB_framebuffer_sRGB */
/* reuse GL_FRAMEBUFFER_SRGB */
/* Reuse tokens from ARB_half_float_vertex */
/* reuse GL_HALF_FLOAT */
/* Reuse tokens from ARB_map_buffer_range */
/* reuse GL_MAP_READ_BIT */
/* reuse GL_MAP_WRITE_BIT */
/* reuse GL_MAP_INVALIDATE_RANGE_BIT */
/* reuse GL_MAP_INVALIDATE_BUFFER_BIT */
/* reuse GL_MAP_FLUSH_EXPLICIT_BIT */
/* reuse GL_MAP_UNSYNCHRONIZED_BIT */
/* Reuse tokens from ARB_texture_compression_rgtc */
/* reuse GL_COMPRESSED_RED_RGTC1 */
/* reuse GL_COMPRESSED_SIGNED_RED_RGTC1 */
/* reuse GL_COMPRESSED_RG_RGTC2 */
/* reuse GL_COMPRESSED_SIGNED_RG_RGTC2 */
/* Reuse tokens from ARB_texture_rg */
/* reuse GL_RG */
/* reuse GL_RG_INTEGER */
/* reuse GL_R8 */
/* reuse GL_R16 */
/* reuse GL_RG8 */
/* reuse GL_RG16 */
/* reuse GL_R16F */
/* reuse GL_R32F */
/* reuse GL_RG16F */
/* reuse GL_RG32F */
/* reuse GL_R8I */
/* reuse GL_R8UI */
/* reuse GL_R16I */
/* reuse GL_R16UI */
/* reuse GL_R32I */
/* reuse GL_R32UI */
/* reuse GL_RG8I */
/* reuse GL_RG8UI */
/* reuse GL_RG16I */
/* reuse GL_RG16UI */
/* reuse GL_RG32I */
/* reuse GL_RG32UI */
/* Reuse tokens from ARB_vertex_array_object */
/* reuse GL_VERTEX_ARRAY_BINDING */
#endif

#ifndef GL_VERSION_3_1
#define GL_SAMPLER_2D_RECT                0x8B63
#define GL_SAMPLER_2D_RECT_SHADOW         0x8B64
#define GL_SAMPLER_BUFFER                 0x8DC2
#define GL_INT_SAMPLER_2D_RECT            0x8DCD
#define GL_INT_SAMPLER_BUFFER             0x8DD0
#define GL_UNSIGNED_INT_SAMPLER_2D_RECT   0x8DD5
#define GL_UNSIGNED_INT_SAMPLER_BUFFER    0x8DD8
#define GL_TEXTURE_BUFFER                 0x8C2A
#define GL_MAX_TEXTURE_BUFFER_SIZE        0x8C2B
#define GL_TEXTURE_BINDING_BUFFER         0x8C2C
#define GL_TEXTURE_BUFFER_DATA_STORE_BINDING 0x8C2D
#define GL_TEXTURE_RECTANGLE              0x84F5
#define GL_TEXTURE_BINDING_RECTANGLE      0x84F6
#define GL_PROXY_TEXTURE_RECTANGLE        0x84F7
#define GL_MAX_RECTANGLE_TEXTURE_SIZE     0x84F8
#define GL_RED_SNORM                      0x8F90
#define GL_RG_SNORM                       0x8F91
#define GL_RGB_SNORM                      0x8F92
#define GL_RGBA_SNORM                     0x8F93
#define GL_R8_SNORM                       0x8F94
#define GL_RG8_SNORM                      0x8F95
#define GL_RGB8_SNORM                     0x8F96
#define GL_RGBA8_SNORM                    0x8F97
#define GL_R16_SNORM                      0x8F98
#define GL_RG16_SNORM                     0x8F99
#define GL_RGB16_SNORM                    0x8F9A
#define GL_RGBA16_SNORM                   0x8F9B
#define GL_SIGNED_NORMALIZED              0x8F9C
#define GL_PRIMITIVE_RESTART              0x8F9D
#define GL_PRIMITIVE_RESTART_INDEX        0x8F9E
/* Reuse tokens from ARB_copy_buffer */
/* reuse GL_COPY_READ_BUFFER */
/* reuse GL_COPY_WRITE_BUFFER */
/* Reuse tokens from ARB_draw_instanced (none) */
/* Reuse tokens from ARB_uniform_buffer_object */
/* reuse GL_UNIFORM_BUFFER */
/* reuse GL_UNIFORM_BUFFER_BINDING */
/* reuse GL_UNIFORM_BUFFER_START */
/* reuse GL_UNIFORM_BUFFER_SIZE */
/* reuse GL_MAX_VERTEX_UNIFORM_BLOCKS */
/* reuse GL_MAX_FRAGMENT_UNIFORM_BLOCKS */
/* reuse GL_MAX_COMBINED_UNIFORM_BLOCKS */
/* reuse GL_MAX_UNIFORM_BUFFER_BINDINGS */
/* reuse GL_MAX_UNIFORM_BLOCK_SIZE */
/* reuse GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS */
/* reuse GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS */
/* reuse GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT */
/* reuse GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH */
/* reuse GL_ACTIVE_UNIFORM_BLOCKS */
/* reuse GL_UNIFORM_TYPE */
/* reuse GL_UNIFORM_SIZE */
/* reuse GL_UNIFORM_NAME_LENGTH */
/* reuse GL_UNIFORM_BLOCK_INDEX */
/* reuse GL_UNIFORM_OFFSET */
/* reuse GL_UNIFORM_ARRAY_STRIDE */
/* reuse GL_UNIFORM_MATRIX_STRIDE */
/* reuse GL_UNIFORM_IS_ROW_MAJOR */
/* reuse GL_UNIFORM_BLOCK_BINDING */
/* reuse GL_UNIFORM_BLOCK_DATA_SIZE */
/* reuse GL_UNIFORM_BLOCK_NAME_LENGTH */
/* reuse GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS */
/* reuse GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES */
/* reuse GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER */
/* reuse GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER */
/* reuse GL_INVALID_INDEX */
#endif

#ifndef GL_VERSION_3_2
#define GL_CONTEXT_CORE_PROFILE_BIT       0x00000001
#define GL_CONTEXT_COMPATIBILITY_PROFILE_BIT 0x00000002
#define GL_LINES_ADJACENCY                0x000A
#define GL_LINE_STRIP_ADJACENCY           0x000B
#define GL_TRIANGLES_ADJACENCY            0x000C
#define GL_TRIANGLE_STRIP_ADJACENCY       0x000D
#define GL_PROGRAM_POINT_SIZE             0x8642
#define GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS 0x8C29
#define GL_FRAMEBUFFER_ATTACHMENT_LAYERED 0x8DA7
#define GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS 0x8DA8
#define GL_GEOMETRY_SHADER                0x8DD9
#define GL_GEOMETRY_VERTICES_OUT          0x8916
#define GL_GEOMETRY_INPUT_TYPE            0x8917
#define GL_GEOMETRY_OUTPUT_TYPE           0x8918
#define GL_MAX_GEOMETRY_UNIFORM_COMPONENTS 0x8DDF
#define GL_MAX_GEOMETRY_OUTPUT_VERTICES   0x8DE0
#define GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS 0x8DE1
#define GL_MAX_VERTEX_OUTPUT_COMPONENTS   0x9122
#define GL_MAX_GEOMETRY_INPUT_COMPONENTS  0x9123
#define GL_MAX_GEOMETRY_OUTPUT_COMPONENTS 0x9124
#define GL_MAX_FRAGMENT_INPUT_COMPONENTS  0x9125
#define GL_CONTEXT_PROFILE_MASK           0x9126
/* reuse GL_MAX_VARYING_COMPONENTS */
/* reuse GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER */
/* Reuse tokens from ARB_depth_clamp */
/* reuse GL_DEPTH_CLAMP */
/* Reuse tokens from ARB_draw_elements_base_vertex (none) */
/* Reuse tokens from ARB_fragment_coord_conventions (none) */
/* Reuse tokens from ARB_provoking_vertex */
/* reuse GL_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION */
/* reuse GL_FIRST_VERTEX_CONVENTION */
/* reuse GL_LAST_VERTEX_CONVENTION */
/* reuse GL_PROVOKING_VERTEX */
/* Reuse tokens from ARB_seamless_cube_map */
/* reuse GL_TEXTURE_CUBE_MAP_SEAMLESS */
/* Reuse tokens from ARB_sync */
/* reuse GL_MAX_SERVER_WAIT_TIMEOUT */
/* reuse GL_OBJECT_TYPE */
/* reuse GL_SYNC_CONDITION */
/* reuse GL_SYNC_STATUS */
/* reuse GL_SYNC_FLAGS */
/* reuse GL_SYNC_FENCE */
/* reuse GL_SYNC_GPU_COMMANDS_COMPLETE */
/* reuse GL_UNSIGNALED */
/* reuse GL_SIGNALED */
/* reuse GL_ALREADY_SIGNALED */
/* reuse GL_TIMEOUT_EXPIRED */
/* reuse GL_CONDITION_SATISFIED */
/* reuse GL_WAIT_FAILED */
/* reuse GL_TIMEOUT_IGNORED */
/* reuse GL_SYNC_FLUSH_COMMANDS_BIT */
/* reuse GL_TIMEOUT_IGNORED */
/* Reuse tokens from ARB_texture_multisample */
/* reuse GL_SAMPLE_POSITION */
/* reuse GL_SAMPLE_MASK */
/* reuse GL_SAMPLE_MASK_VALUE */
/* reuse GL_MAX_SAMPLE_MASK_WORDS */
/* reuse GL_TEXTURE_2D_MULTISAMPLE */
/* reuse GL_PROXY_TEXTURE_2D_MULTISAMPLE */
/* reuse GL_TEXTURE_2D_MULTISAMPLE_ARRAY */
/* reuse GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY */
/* reuse GL_TEXTURE_BINDING_2D_MULTISAMPLE */
/* reuse GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY */
/* reuse GL_TEXTURE_SAMPLES */
/* reuse GL_TEXTURE_FIXED_SAMPLE_LOCATIONS */
/* reuse GL_SAMPLER_2D_MULTISAMPLE */
/* reuse GL_INT_SAMPLER_2D_MULTISAMPLE */
/* reuse GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE */
/* reuse GL_SAMPLER_2D_MULTISAMPLE_ARRAY */
/* reuse GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY */
/* reuse GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY */
/* reuse GL_MAX_COLOR_TEXTURE_SAMPLES */
/* reuse GL_MAX_DEPTH_TEXTURE_SAMPLES */
/* reuse GL_MAX_INTEGER_SAMPLES */
/* Don't need to reuse tokens from ARB_vertex_array_bgra since they're already in 1.2 core */
#endif

#ifndef GL_VERSION_3_3
#define GL_VERTEX_ATTRIB_ARRAY_DIVISOR    0x88FE
/* Reuse tokens from ARB_blend_func_extended */
/* reuse GL_SRC1_COLOR */
/* reuse GL_ONE_MINUS_SRC1_COLOR */
/* reuse GL_ONE_MINUS_SRC1_ALPHA */
/* reuse GL_MAX_DUAL_SOURCE_DRAW_BUFFERS */
/* Reuse tokens from ARB_explicit_attrib_location (none) */
/* Reuse tokens from ARB_occlusion_query2 */
/* reuse GL_ANY_SAMPLES_PASSED */
/* Reuse tokens from ARB_sampler_objects */
/* reuse GL_SAMPLER_BINDING */
/* Reuse tokens from ARB_shader_bit_encoding (none) */
/* Reuse tokens from ARB_texture_rgb10_a2ui */
/* reuse GL_RGB10_A2UI */
/* Reuse tokens from ARB_texture_swizzle */
/* reuse GL_TEXTURE_SWIZZLE_R */
/* reuse GL_TEXTURE_SWIZZLE_G */
/* reuse GL_TEXTURE_SWIZZLE_B */
/* reuse GL_TEXTURE_SWIZZLE_A */
/* reuse GL_TEXTURE_SWIZZLE_RGBA */
/* Reuse tokens from ARB_timer_query */
/* reuse GL_TIME_ELAPSED */
/* reuse GL_TIMESTAMP */
/* Reuse tokens from ARB_vertex_type_2_10_10_10_rev */
/* reuse GL_INT_2_10_10_10_REV */
#endif

#ifndef GL_VERSION_4_0
#define GL_SAMPLE_SHADING                 0x8C36
#define GL_MIN_SAMPLE_SHADING_VALUE       0x8C37
#define GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET 0x8E5E
#define GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET 0x8E5F
#define GL_TEXTURE_CUBE_MAP_ARRAY         0x9009
#define GL_TEXTURE_BINDING_CUBE_MAP_ARRAY 0x900A
#define GL_PROXY_TEXTURE_CUBE_MAP_ARRAY   0x900B
#define GL_SAMPLER_CUBE_MAP_ARRAY         0x900C
#define GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW  0x900D
#define GL_INT_SAMPLER_CUBE_MAP_ARRAY     0x900E
#define GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY 0x900F
/* Reuse tokens from ARB_texture_query_lod (none) */
/* Reuse tokens from ARB_draw_buffers_blend (none) */
/* Reuse tokens from ARB_draw_indirect */
/* reuse GL_DRAW_INDIRECT_BUFFER */
/* reuse GL_DRAW_INDIRECT_BUFFER_BINDING */
/* Reuse tokens from ARB_gpu_shader5 */
/* reuse GL_GEOMETRY_SHADER_INVOCATIONS */
/* reuse GL_MAX_GEOMETRY_SHADER_INVOCATIONS */
/* reuse GL_MIN_FRAGMENT_INTERPOLATION_OFFSET */
/* reuse GL_MAX_FRAGMENT_INTERPOLATION_OFFSET */
/* reuse GL_FRAGMENT_INTERPOLATION_OFFSET_BITS */
/* reuse GL_MAX_VERTEX_STREAMS */
/* Reuse tokens from ARB_gpu_shader_fp64 */
/* reuse GL_DOUBLE_VEC2 */
/* reuse GL_DOUBLE_VEC3 */
/* reuse GL_DOUBLE_VEC4 */
/* reuse GL_DOUBLE_MAT2 */
/* reuse GL_DOUBLE_MAT3 */
/* reuse GL_DOUBLE_MAT4 */
/* reuse GL_DOUBLE_MAT2x3 */
/* reuse GL_DOUBLE_MAT2x4 */
/* reuse GL_DOUBLE_MAT3x2 */
/* reuse GL_DOUBLE_MAT3x4 */
/* reuse GL_DOUBLE_MAT4x2 */
/* reuse GL_DOUBLE_MAT4x3 */
/* Reuse tokens from ARB_shader_subroutine */
/* reuse GL_ACTIVE_SUBROUTINES */
/* reuse GL_ACTIVE_SUBROUTINE_UNIFORMS */
/* reuse GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS */
/* reuse GL_ACTIVE_SUBROUTINE_MAX_LENGTH */
/* reuse GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH */
/* reuse GL_MAX_SUBROUTINES */
/* reuse GL_MAX_SUBROUTINE_UNIFORM_LOCATIONS */
/* reuse GL_NUM_COMPATIBLE_SUBROUTINES */
/* reuse GL_COMPATIBLE_SUBROUTINES */
/* Reuse tokens from ARB_tessellation_shader */
/* reuse GL_PATCHES */
/* reuse GL_PATCH_VERTICES */
/* reuse GL_PATCH_DEFAULT_INNER_LEVEL */
/* reuse GL_PATCH_DEFAULT_OUTER_LEVEL */
/* reuse GL_TESS_CONTROL_OUTPUT_VERTICES */
/* reuse GL_TESS_GEN_MODE */
/* reuse GL_TESS_GEN_SPACING */
/* reuse GL_TESS_GEN_VERTEX_ORDER */
/* reuse GL_TESS_GEN_POINT_MODE */
/* reuse GL_ISOLINES */
/* reuse GL_FRACTIONAL_ODD */
/* reuse GL_FRACTIONAL_EVEN */
/* reuse GL_MAX_PATCH_VERTICES */
/* reuse GL_MAX_TESS_GEN_LEVEL */
/* reuse GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS */
/* reuse GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS */
/* reuse GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS */
/* reuse GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS */
/* reuse GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS */
/* reuse GL_MAX_TESS_PATCH_COMPONENTS */
/* reuse GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS */
/* reuse GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS */
/* reuse GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS */
/* reuse GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS */
/* reuse GL_MAX_TESS_CONTROL_INPUT_COMPONENTS */
/* reuse GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS */
/* reuse GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS */
/* reuse GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS */
/* reuse GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_CONTROL_SHADER */
/* reuse GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_EVALUATION_SHADER */
/* reuse GL_TESS_EVALUATION_SHADER */
/* reuse GL_TESS_CONTROL_SHADER */
/* Reuse tokens from ARB_texture_buffer_object_rgb32 (none) */
/* Reuse tokens from ARB_transform_feedback2 */
/* reuse GL_TRANSFORM_FEEDBACK */
/* reuse GL_TRANSFORM_FEEDBACK_BUFFER_PAUSED */
/* reuse GL_TRANSFORM_FEEDBACK_BUFFER_ACTIVE */
/* reuse GL_TRANSFORM_FEEDBACK_BINDING */
/* Reuse tokens from ARB_transform_feedback3 */
/* reuse GL_MAX_TRANSFORM_FEEDBACK_BUFFERS */
/* reuse GL_MAX_VERTEX_STREAMS */
#endif

#ifndef GL_VERSION_4_1
/* Reuse tokens from ARB_ES2_compatibility */
/* reuse GL_FIXED */
/* reuse GL_IMPLEMENTATION_COLOR_READ_TYPE */
/* reuse GL_IMPLEMENTATION_COLOR_READ_FORMAT */
/* reuse GL_LOW_FLOAT */
/* reuse GL_MEDIUM_FLOAT */
/* reuse GL_HIGH_FLOAT */
/* reuse GL_LOW_INT */
/* reuse GL_MEDIUM_INT */
/* reuse GL_HIGH_INT */
/* reuse GL_SHADER_COMPILER */
/* reuse GL_SHADER_BINARY_FORMATS */
/* reuse GL_NUM_SHADER_BINARY_FORMATS */
/* reuse GL_MAX_VERTEX_UNIFORM_VECTORS */
/* reuse GL_MAX_VARYING_VECTORS */
/* reuse GL_MAX_FRAGMENT_UNIFORM_VECTORS */
/* reuse GL_RGB565 */
/* Reuse tokens from ARB_get_program_binary */
/* reuse GL_PROGRAM_BINARY_RETRIEVABLE_HINT */
/* reuse GL_PROGRAM_BINARY_LENGTH */
/* reuse GL_NUM_PROGRAM_BINARY_FORMATS */
/* reuse GL_PROGRAM_BINARY_FORMATS */
/* Reuse tokens from ARB_separate_shader_objects */
/* reuse GL_VERTEX_SHADER_BIT */
/* reuse GL_FRAGMENT_SHADER_BIT */
/* reuse GL_GEOMETRY_SHADER_BIT */
/* reuse GL_TESS_CONTROL_SHADER_BIT */
/* reuse GL_TESS_EVALUATION_SHADER_BIT */
/* reuse GL_ALL_SHADER_BITS */
/* reuse GL_PROGRAM_SEPARABLE */
/* reuse GL_ACTIVE_PROGRAM */
/* reuse GL_PROGRAM_PIPELINE_BINDING */
/* Reuse tokens from ARB_shader_precision (none) */
/* Reuse tokens from ARB_vertex_attrib_64bit - all are in GL 3.0 and 4.0 already */
/* Reuse tokens from ARB_viewport_array - some are in GL 1.1 and ARB_provoking_vertex already */
/* reuse GL_MAX_VIEWPORTS */
/* reuse GL_VIEWPORT_SUBPIXEL_BITS */
/* reuse GL_VIEWPORT_BOUNDS_RANGE */
/* reuse GL_LAYER_PROVOKING_VERTEX */
/* reuse GL_VIEWPORT_INDEX_PROVOKING_VERTEX */
/* reuse GL_UNDEFINED_VERTEX */
#endif

#ifndef GL_VERSION_4_2
/* Reuse tokens from ARB_base_instance (none) */
/* Reuse tokens from ARB_shading_language_420pack (none) */
/* Reuse tokens from ARB_transform_feedback_instanced (none) */
/* Reuse tokens from ARB_compressed_texture_pixel_storage */
/* reuse GL_UNPACK_COMPRESSED_BLOCK_WIDTH */
/* reuse GL_UNPACK_COMPRESSED_BLOCK_HEIGHT */
/* reuse GL_UNPACK_COMPRESSED_BLOCK_DEPTH */
/* reuse GL_UNPACK_COMPRESSED_BLOCK_SIZE */
/* reuse GL_PACK_COMPRESSED_BLOCK_WIDTH */
/* reuse GL_PACK_COMPRESSED_BLOCK_HEIGHT */
/* reuse GL_PACK_COMPRESSED_BLOCK_DEPTH */
/* reuse GL_PACK_COMPRESSED_BLOCK_SIZE */
/* Reuse tokens from ARB_conservative_depth (none) */
/* Reuse tokens from ARB_internalformat_query */
/* reuse GL_NUM_SAMPLE_COUNTS */
/* Reuse tokens from ARB_map_buffer_alignment */
/* reuse GL_MIN_MAP_BUFFER_ALIGNMENT */
/* Reuse tokens from ARB_shader_atomic_counters */
/* reuse GL_ATOMIC_COUNTER_BUFFER */
/* reuse GL_ATOMIC_COUNTER_BUFFER_BINDING */
/* reuse GL_ATOMIC_COUNTER_BUFFER_START */
/* reuse GL_ATOMIC_COUNTER_BUFFER_SIZE */
/* reuse GL_ATOMIC_COUNTER_BUFFER_DATA_SIZE */
/* reuse GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS */
/* reuse GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_INDICES */
/* reuse GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_SHADER */
/* reuse GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_CONTROL_SHADER */
/* reuse GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_EVALUATION_SHADER */
/* reuse GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_GEOMETRY_SHADER */
/* reuse GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_FRAGMENT_SHADER */
/* reuse GL_MAX_VERTEX_ATOMIC_COUNTER_BUFFERS */
/* reuse GL_MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS */
/* reuse GL_MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS */
/* reuse GL_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS */
/* reuse GL_MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS */
/* reuse GL_MAX_COMBINED_ATOMIC_COUNTER_BUFFERS */
/* reuse GL_MAX_VERTEX_ATOMIC_COUNTERS */
/* reuse GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS */
/* reuse GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS */
/* reuse GL_MAX_GEOMETRY_ATOMIC_COUNTERS */
/* reuse GL_MAX_FRAGMENT_ATOMIC_COUNTERS */
/* reuse GL_MAX_COMBINED_ATOMIC_COUNTERS */
/* reuse GL_MAX_ATOMIC_COUNTER_BUFFER_SIZE */
/* reuse GL_MAX_ATOMIC_COUNTER_BUFFER_BINDINGS */
/* reuse GL_ACTIVE_ATOMIC_COUNTER_BUFFERS */
/* reuse GL_UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX */
/* reuse GL_UNSIGNED_INT_ATOMIC_COUNTER */
/* Reuse tokens from ARB_shader_image_load_store */
/* reuse GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT */
/* reuse GL_ELEMENT_ARRAY_BARRIER_BIT */
/* reuse GL_UNIFORM_BARRIER_BIT */
/* reuse GL_TEXTURE_FETCH_BARRIER_BIT */
/* reuse GL_SHADER_IMAGE_ACCESS_BARRIER_BIT */
/* reuse GL_COMMAND_BARRIER_BIT */
/* reuse GL_PIXEL_BUFFER_BARRIER_BIT */
/* reuse GL_TEXTURE_UPDATE_BARRIER_BIT */
/* reuse GL_BUFFER_UPDATE_BARRIER_BIT */
/* reuse GL_FRAMEBUFFER_BARRIER_BIT */
/* reuse GL_TRANSFORM_FEEDBACK_BARRIER_BIT */
/* reuse GL_ATOMIC_COUNTER_BARRIER_BIT */
/* reuse GL_ALL_BARRIER_BITS */
/* reuse GL_MAX_IMAGE_UNITS */
/* reuse GL_MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS */
/* reuse GL_IMAGE_BINDING_NAME */
/* reuse GL_IMAGE_BINDING_LEVEL */
/* reuse GL_IMAGE_BINDING_LAYERED */
/* reuse GL_IMAGE_BINDING_LAYER */
/* reuse GL_IMAGE_BINDING_ACCESS */
/* reuse GL_IMAGE_1D */
/* reuse GL_IMAGE_2D */
/* reuse GL_IMAGE_3D */
/* reuse GL_IMAGE_2D_RECT */
/* reuse GL_IMAGE_CUBE */
/* reuse GL_IMAGE_BUFFER */
/* reuse GL_IMAGE_1D_ARRAY */
/* reuse GL_IMAGE_2D_ARRAY */
/* reuse GL_IMAGE_CUBE_MAP_ARRAY */
/* reuse GL_IMAGE_2D_MULTISAMPLE */
/* reuse GL_IMAGE_2D_MULTISAMPLE_ARRAY */
/* reuse GL_INT_IMAGE_1D */
/* reuse GL_INT_IMAGE_2D */
/* reuse GL_INT_IMAGE_3D */
/* reuse GL_INT_IMAGE_2D_RECT */
/* reuse GL_INT_IMAGE_CUBE */
/* reuse GL_INT_IMAGE_BUFFER */
/* reuse GL_INT_IMAGE_1D_ARRAY */
/* reuse GL_INT_IMAGE_2D_ARRAY */
/* reuse GL_INT_IMAGE_CUBE_MAP_ARRAY */
/* reuse GL_INT_IMAGE_2D_MULTISAMPLE */
/* reuse GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY */
/* reuse GL_UNSIGNED_INT_IMAGE_1D */
/* reuse GL_UNSIGNED_INT_IMAGE_2D */
/* reuse GL_UNSIGNED_INT_IMAGE_3D */
/* reuse GL_UNSIGNED_INT_IMAGE_2D_RECT */
/* reuse GL_UNSIGNED_INT_IMAGE_CUBE */
/* reuse GL_UNSIGNED_INT_IMAGE_BUFFER */
/* reuse GL_UNSIGNED_INT_IMAGE_1D_ARRAY */
/* reuse GL_UNSIGNED_INT_IMAGE_2D_ARRAY */
/* reuse GL_UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY */
/* reuse GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE */
/* reuse GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY */
/* reuse GL_MAX_IMAGE_SAMPLES */
/* reuse GL_IMAGE_BINDING_FORMAT */
/* reuse GL_IMAGE_FORMAT_COMPATIBILITY_TYPE */
/* reuse GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE */
/* reuse GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS */
/* reuse GL_MAX_VERTEX_IMAGE_UNIFORMS */
/* reuse GL_MAX_TESS_CONTROL_IMAGE_UNIFORMS */
/* reuse GL_MAX_TESS_EVALUATION_IMAGE_UNIFORMS */
/* reuse GL_MAX_GEOMETRY_IMAGE_UNIFORMS */
/* reuse GL_MAX_FRAGMENT_IMAGE_UNIFORMS */
/* reuse GL_MAX_COMBINED_IMAGE_UNIFORMS */
/* Reuse tokens from ARB_shading_language_packing (none) */
/* Reuse tokens from ARB_texture_storage */
/* reuse GL_TEXTURE_IMMUTABLE_FORMAT */
#endif

#ifndef GL_VERSION_4_3
#define GL_NUM_SHADING_LANGUAGE_VERSIONS  0x82E9
#define GL_VERTEX_ATTRIB_ARRAY_LONG       0x874E
/* Reuse tokens from ARB_arrays_of_arrays (none, GLSL only) */
/* Reuse tokens from ARB_fragment_layer_viewport (none, GLSL only) */
/* Reuse tokens from ARB_shader_image_size (none, GLSL only) */
/* Reuse tokens from ARB_ES3_compatibility */
/* reuse GL_COMPRESSED_RGB8_ETC2 */
/* reuse GL_COMPRESSED_SRGB8_ETC2 */
/* reuse GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 */
/* reuse GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 */
/* reuse GL_COMPRESSED_RGBA8_ETC2_EAC */
/* reuse GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC */
/* reuse GL_COMPRESSED_R11_EAC */
/* reuse GL_COMPRESSED_SIGNED_R11_EAC */
/* reuse GL_COMPRESSED_RG11_EAC */
/* reuse GL_COMPRESSED_SIGNED_RG11_EAC */
/* reuse GL_PRIMITIVE_RESTART_FIXED_INDEX */
/* reuse GL_ANY_SAMPLES_PASSED_CONSERVATIVE */
/* reuse GL_MAX_ELEMENT_INDEX */
/* Reuse tokens from ARB_clear_buffer_object (none) */
/* Reuse tokens from ARB_compute_shader */
/* reuse GL_COMPUTE_SHADER */
/* reuse GL_MAX_COMPUTE_UNIFORM_BLOCKS */
/* reuse GL_MAX_COMPUTE_TEXTURE_IMAGE_UNITS */
/* reuse GL_MAX_COMPUTE_IMAGE_UNIFORMS */
/* reuse GL_MAX_COMPUTE_SHARED_MEMORY_SIZE */
/* reuse GL_MAX_COMPUTE_UNIFORM_COMPONENTS */
/* reuse GL_MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS */
/* reuse GL_MAX_COMPUTE_ATOMIC_COUNTERS */
/* reuse GL_MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS */
/* reuse GL_MAX_COMPUTE_LOCAL_INVOCATIONS */
/* reuse GL_MAX_COMPUTE_WORK_GROUP_COUNT */
/* reuse GL_MAX_COMPUTE_WORK_GROUP_SIZE */
/* reuse GL_COMPUTE_LOCAL_WORK_SIZE */
/* reuse GL_UNIFORM_BLOCK_REFERENCED_BY_COMPUTE_SHADER */
/* reuse GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER */
/* reuse GL_DISPATCH_INDIRECT_BUFFER */
/* reuse GL_DISPATCH_INDIRECT_BUFFER_BINDING */
/* Reuse tokens from ARB_copy_image (none) */
/* Reuse tokens from KHR_debug */
/* reuse GL_DEBUG_OUTPUT_SYNCHRONOUS */
/* reuse GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH */
/* reuse GL_DEBUG_CALLBACK_FUNCTION */
/* reuse GL_DEBUG_CALLBACK_USER_PARAM */
/* reuse GL_DEBUG_SOURCE_API */
/* reuse GL_DEBUG_SOURCE_WINDOW_SYSTEM */
/* reuse GL_DEBUG_SOURCE_SHADER_COMPILER */
/* reuse GL_DEBUG_SOURCE_THIRD_PARTY */
/* reuse GL_DEBUG_SOURCE_APPLICATION */
/* reuse GL_DEBUG_SOURCE_OTHER */
/* reuse GL_DEBUG_TYPE_ERROR */
/* reuse GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR */
/* reuse GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR */
/* reuse GL_DEBUG_TYPE_PORTABILITY */
/* reuse GL_DEBUG_TYPE_PERFORMANCE */
/* reuse GL_DEBUG_TYPE_OTHER */
/* reuse GL_MAX_DEBUG_MESSAGE_LENGTH */
/* reuse GL_MAX_DEBUG_LOGGED_MESSAGES */
/* reuse GL_DEBUG_LOGGED_MESSAGES */
/* reuse GL_DEBUG_SEVERITY_HIGH */
/* reuse GL_DEBUG_SEVERITY_MEDIUM */
/* reuse GL_DEBUG_SEVERITY_LOW */
/* reuse GL_DEBUG_TYPE_MARKER */
/* reuse GL_DEBUG_TYPE_PUSH_GROUP */
/* reuse GL_DEBUG_TYPE_POP_GROUP */
/* reuse GL_DEBUG_SEVERITY_NOTIFICATION */
/* reuse GL_MAX_DEBUG_GROUP_STACK_DEPTH */
/* reuse GL_DEBUG_GROUP_STACK_DEPTH */
/* reuse GL_BUFFER */
/* reuse GL_SHADER */
/* reuse GL_PROGRAM */
/* reuse GL_QUERY */
/* reuse GL_PROGRAM_PIPELINE */
/* reuse GL_SAMPLER */
/* reuse GL_DISPLAY_LIST */
/* reuse GL_MAX_LABEL_LENGTH */
/* reuse GL_DEBUG_OUTPUT */
/* reuse GL_CONTEXT_FLAG_DEBUG_BIT */
/* reuse GL_STACK_UNDERFLOW */
/* reuse GL_STACK_OVERFLOW */
/* Reuse tokens from ARB_explicit_uniform_location */
/* reuse GL_MAX_UNIFORM_LOCATIONS */
/* Reuse tokens from ARB_framebuffer_no_attachments */
/* reuse GL_FRAMEBUFFER_DEFAULT_WIDTH */
/* reuse GL_FRAMEBUFFER_DEFAULT_HEIGHT */
/* reuse GL_FRAMEBUFFER_DEFAULT_LAYERS */
/* reuse GL_FRAMEBUFFER_DEFAULT_SAMPLES */
/* reuse GL_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS */
/* reuse GL_MAX_FRAMEBUFFER_WIDTH */
/* reuse GL_MAX_FRAMEBUFFER_HEIGHT */
/* reuse GL_MAX_FRAMEBUFFER_LAYERS */
/* reuse GL_MAX_FRAMEBUFFER_SAMPLES */
/* Reuse tokens from ARB_internalformat_query2 */
/* reuse GL_INTERNALFORMAT_SUPPORTED */
/* reuse GL_INTERNALFORMAT_PREFERRED */
/* reuse GL_INTERNALFORMAT_RED_SIZE */
/* reuse GL_INTERNALFORMAT_GREEN_SIZE */
/* reuse GL_INTERNALFORMAT_BLUE_SIZE */
/* reuse GL_INTERNALFORMAT_ALPHA_SIZE */
/* reuse GL_INTERNALFORMAT_DEPTH_SIZE */
/* reuse GL_INTERNALFORMAT_STENCIL_SIZE */
/* reuse GL_INTERNALFORMAT_SHARED_SIZE */
/* reuse GL_INTERNALFORMAT_RED_TYPE */
/* reuse GL_INTERNALFORMAT_GREEN_TYPE */
/* reuse GL_INTERNALFORMAT_BLUE_TYPE */
/* reuse GL_INTERNALFORMAT_ALPHA_TYPE */
/* reuse GL_INTERNALFORMAT_DEPTH_TYPE */
/* reuse GL_INTERNALFORMAT_STENCIL_TYPE */
/* reuse GL_MAX_WIDTH */
/* reuse GL_MAX_HEIGHT */
/* reuse GL_MAX_DEPTH */
/* reuse GL_MAX_LAYERS */
/* reuse GL_MAX_COMBINED_DIMENSIONS */
/* reuse GL_COLOR_COMPONENTS */
/* reuse GL_DEPTH_COMPONENTS */
/* reuse GL_STENCIL_COMPONENTS */
/* reuse GL_COLOR_RENDERABLE */
/* reuse GL_DEPTH_RENDERABLE */
/* reuse GL_STENCIL_RENDERABLE */
/* reuse GL_FRAMEBUFFER_RENDERABLE */
/* reuse GL_FRAMEBUFFER_RENDERABLE_LAYERED */
/* reuse GL_FRAMEBUFFER_BLEND */
/* reuse GL_READ_PIXELS */
/* reuse GL_READ_PIXELS_FORMAT */
/* reuse GL_READ_PIXELS_TYPE */
/* reuse GL_TEXTURE_IMAGE_FORMAT */
/* reuse GL_TEXTURE_IMAGE_TYPE */
/* reuse GL_GET_TEXTURE_IMAGE_FORMAT */
/* reuse GL_GET_TEXTURE_IMAGE_TYPE */
/* reuse GL_MIPMAP */
/* reuse GL_MANUAL_GENERATE_MIPMAP */
/* reuse GL_AUTO_GENERATE_MIPMAP */
/* reuse GL_COLOR_ENCODING */
/* reuse GL_SRGB_READ */
/* reuse GL_SRGB_WRITE */
/* reuse GL_FILTER */
/* reuse GL_VERTEX_TEXTURE */
/* reuse GL_TESS_CONTROL_TEXTURE */
/* reuse GL_TESS_EVALUATION_TEXTURE */
/* reuse GL_GEOMETRY_TEXTURE */
/* reuse GL_FRAGMENT_TEXTURE */
/* reuse GL_COMPUTE_TEXTURE */
/* reuse GL_TEXTURE_SHADOW */
/* reuse GL_TEXTURE_GATHER */
/* reuse GL_TEXTURE_GATHER_SHADOW */
/* reuse GL_SHADER_IMAGE_LOAD */
/* reuse GL_SHADER_IMAGE_STORE */
/* reuse GL_SHADER_IMAGE_ATOMIC */
/* reuse GL_IMAGE_TEXEL_SIZE */
/* reuse GL_IMAGE_COMPATIBILITY_CLASS */
/* reuse GL_IMAGE_PIXEL_FORMAT */
/* reuse GL_IMAGE_PIXEL_TYPE */
/* reuse GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST */
/* reuse GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST */
/* reuse GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE */
/* reuse GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE */
/* reuse GL_TEXTURE_COMPRESSED_BLOCK_WIDTH */
/* reuse GL_TEXTURE_COMPRESSED_BLOCK_HEIGHT */
/* reuse GL_TEXTURE_COMPRESSED_BLOCK_SIZE */
/* reuse GL_CLEAR_BUFFER */
/* reuse GL_TEXTURE_VIEW */
/* reuse GL_VIEW_COMPATIBILITY_CLASS */
/* reuse GL_FULL_SUPPORT */
/* reuse GL_CAVEAT_SUPPORT */
/* reuse GL_IMAGE_CLASS_4_X_32 */
/* reuse GL_IMAGE_CLASS_2_X_32 */
/* reuse GL_IMAGE_CLASS_1_X_32 */
/* reuse GL_IMAGE_CLASS_4_X_16 */
/* reuse GL_IMAGE_CLASS_2_X_16 */
/* reuse GL_IMAGE_CLASS_1_X_16 */
/* reuse GL_IMAGE_CLASS_4_X_8 */
/* reuse GL_IMAGE_CLASS_2_X_8 */
/* reuse GL_IMAGE_CLASS_1_X_8 */
/* reuse GL_IMAGE_CLASS_11_11_10 */
/* reuse GL_IMAGE_CLASS_10_10_10_2 */
/* reuse GL_VIEW_CLASS_128_BITS */
/* reuse GL_VIEW_CLASS_96_BITS */
/* reuse GL_VIEW_CLASS_64_BITS */
/* reuse GL_VIEW_CLASS_48_BITS */
/* reuse GL_VIEW_CLASS_32_BITS */
/* reuse GL_VIEW_CLASS_24_BITS */
/* reuse GL_VIEW_CLASS_16_BITS */
/* reuse GL_VIEW_CLASS_8_BITS */
/* reuse GL_VIEW_CLASS_S3TC_DXT1_RGB */
/* reuse GL_VIEW_CLASS_S3TC_DXT1_RGBA */
/* reuse GL_VIEW_CLASS_S3TC_DXT3_RGBA */
/* reuse GL_VIEW_CLASS_S3TC_DXT5_RGBA */
/* reuse GL_VIEW_CLASS_RGTC1_RED */
/* reuse GL_VIEW_CLASS_RGTC2_RG */
/* reuse GL_VIEW_CLASS_BPTC_UNORM */
/* reuse GL_VIEW_CLASS_BPTC_FLOAT */
/* Reuse tokens from ARB_invalidate_subdata (none) */
/* Reuse tokens from ARB_multi_draw_indirect (none) */
/* Reuse tokens from ARB_program_interface_query */
/* reuse GL_UNIFORM */
/* reuse GL_UNIFORM_BLOCK */
/* reuse GL_PROGRAM_INPUT */
/* reuse GL_PROGRAM_OUTPUT */
/* reuse GL_BUFFER_VARIABLE */
/* reuse GL_SHADER_STORAGE_BLOCK */
/* reuse GL_VERTEX_SUBROUTINE */
/* reuse GL_TESS_CONTROL_SUBROUTINE */
/* reuse GL_TESS_EVALUATION_SUBROUTINE */
/* reuse GL_GEOMETRY_SUBROUTINE */
/* reuse GL_FRAGMENT_SUBROUTINE */
/* reuse GL_COMPUTE_SUBROUTINE */
/* reuse GL_VERTEX_SUBROUTINE_UNIFORM */
/* reuse GL_TESS_CONTROL_SUBROUTINE_UNIFORM */
/* reuse GL_TESS_EVALUATION_SUBROUTINE_UNIFORM */
/* reuse GL_GEOMETRY_SUBROUTINE_UNIFORM */
/* reuse GL_FRAGMENT_SUBROUTINE_UNIFORM */
/* reuse GL_COMPUTE_SUBROUTINE_UNIFORM */
/* reuse GL_TRANSFORM_FEEDBACK_VARYING */
/* reuse GL_ACTIVE_RESOURCES */
/* reuse GL_MAX_NAME_LENGTH */
/* reuse GL_MAX_NUM_ACTIVE_VARIABLES */
/* reuse GL_MAX_NUM_COMPATIBLE_SUBROUTINES */
/* reuse GL_NAME_LENGTH */
/* reuse GL_TYPE */
/* reuse GL_ARRAY_SIZE */
/* reuse GL_OFFSET */
/* reuse GL_BLOCK_INDEX */
/* reuse GL_ARRAY_STRIDE */
/* reuse GL_MATRIX_STRIDE */
/* reuse GL_IS_ROW_MAJOR */
/* reuse GL_ATOMIC_COUNTER_BUFFER_INDEX */
/* reuse GL_BUFFER_BINDING */
/* reuse GL_BUFFER_DATA_SIZE */
/* reuse GL_NUM_ACTIVE_VARIABLES */
/* reuse GL_ACTIVE_VARIABLES */
/* reuse GL_REFERENCED_BY_VERTEX_SHADER */
/* reuse GL_REFERENCED_BY_TESS_CONTROL_SHADER */
/* reuse GL_REFERENCED_BY_TESS_EVALUATION_SHADER */
/* reuse GL_REFERENCED_BY_GEOMETRY_SHADER */
/* reuse GL_REFERENCED_BY_FRAGMENT_SHADER */
/* reuse GL_REFERENCED_BY_COMPUTE_SHADER */
/* reuse GL_TOP_LEVEL_ARRAY_SIZE */
/* reuse GL_TOP_LEVEL_ARRAY_STRIDE */
/* reuse GL_LOCATION */
/* reuse GL_LOCATION_INDEX */
/* reuse GL_IS_PER_PATCH */
/* Reuse tokens from ARB_robust_buffer_access_behavior (none) */
/* Reuse tokens from ARB_shader_storage_buffer_object */
/* reuse GL_SHADER_STORAGE_BUFFER */
/* reuse GL_SHADER_STORAGE_BUFFER_BINDING */
/* reuse GL_SHADER_STORAGE_BUFFER_START */
/* reuse GL_SHADER_STORAGE_BUFFER_SIZE */
/* reuse GL_MAX_VERTEX_SHADER_STORAGE_BLOCKS */
/* reuse GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS */
/* reuse GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS */
/* reuse GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS */
/* reuse GL_MAX_FRAGMENT_SHADER_STORAGE_BLOCKS */
/* reuse GL_MAX_COMPUTE_SHADER_STORAGE_BLOCKS */
/* reuse GL_MAX_COMBINED_SHADER_STORAGE_BLOCKS */
/* reuse GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS */
/* reuse GL_MAX_SHADER_STORAGE_BLOCK_SIZE */
/* reuse GL_SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT */
/* reuse GL_SHADER_STORAGE_BARRIER_BIT */
/* reuse GL_MAX_COMBINED_SHADER_OUTPUT_RESOURCES */
/* Reuse tokens from ARB_stencil_texturing */
/* reuse GL_DEPTH_STENCIL_TEXTURE_MODE */
/* Reuse tokens from ARB_texture_buffer_range */
/* reuse GL_TEXTURE_BUFFER_OFFSET */
/* reuse GL_TEXTURE_BUFFER_SIZE */
/* reuse GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT */
/* Reuse tokens from ARB_texture_query_levels (none) */
/* Reuse tokens from ARB_texture_storage_multisample (none) */
/* Reuse tokens from ARB_texture_view */
/* reuse GL_TEXTURE_VIEW_MIN_LEVEL */
/* reuse GL_TEXTURE_VIEW_NUM_LEVELS */
/* reuse GL_TEXTURE_VIEW_MIN_LAYER */
/* reuse GL_TEXTURE_VIEW_NUM_LAYERS */
/* reuse GL_TEXTURE_IMMUTABLE_LEVELS */
/* Reuse tokens from ARB_vertex_attrib_binding */
/* reuse GL_VERTEX_ATTRIB_BINDING */
/* reuse GL_VERTEX_ATTRIB_RELATIVE_OFFSET */
/* reuse GL_VERTEX_BINDING_DIVISOR */
/* reuse GL_VERTEX_BINDING_OFFSET */
/* reuse GL_VERTEX_BINDING_STRIDE */
/* reuse GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET */
/* reuse GL_MAX_VERTEX_ATTRIB_BINDINGS */
#endif

#ifndef GL_ARB_depth_buffer_float
#define GL_DEPTH_COMPONENT32F             0x8CAC
#define GL_DEPTH32F_STENCIL8              0x8CAD
#define GL_FLOAT_32_UNSIGNED_INT_24_8_REV 0x8DAD
#endif

#ifndef GL_ARB_framebuffer_object
#define GL_INVALID_FRAMEBUFFER_OPERATION  0x0506
#define GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING 0x8210
#define GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE 0x8211
#define GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE 0x8212
#define GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE 0x8213
#define GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE 0x8214
#define GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE 0x8215
#define GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE 0x8216
#define GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE 0x8217
#define GL_FRAMEBUFFER_DEFAULT            0x8218
#define GL_FRAMEBUFFER_UNDEFINED          0x8219
#define GL_DEPTH_STENCIL_ATTACHMENT       0x821A
#define GL_MAX_RENDERBUFFER_SIZE          0x84E8
#define GL_DEPTH_STENCIL                  0x84F9
#define GL_UNSIGNED_INT_24_8              0x84FA
#define GL_DEPTH24_STENCIL8               0x88F0
#define GL_TEXTURE_STENCIL_SIZE           0x88F1
#define GL_TEXTURE_RED_TYPE               0x8C10
#define GL_TEXTURE_GREEN_TYPE             0x8C11
#define GL_TEXTURE_BLUE_TYPE              0x8C12
#define GL_TEXTURE_ALPHA_TYPE             0x8C13
#define GL_TEXTURE_DEPTH_TYPE             0x8C16
#define GL_UNSIGNED_NORMALIZED            0x8C17
#define GL_FRAMEBUFFER_BINDING            0x8CA6
#define GL_DRAW_FRAMEBUFFER_BINDING       GL_FRAMEBUFFER_BINDING
#define GL_RENDERBUFFER_BINDING           0x8CA7
#define GL_READ_FRAMEBUFFER               0x8CA8
#define GL_DRAW_FRAMEBUFFER               0x8CA9
#define GL_READ_FRAMEBUFFER_BINDING       0x8CAA
#define GL_RENDERBUFFER_SAMPLES           0x8CAB
#define GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE 0x8CD0
#define GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME 0x8CD1
#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL 0x8CD2
#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE 0x8CD3
#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER 0x8CD4
#define GL_FRAMEBUFFER_COMPLETE           0x8CD5
#define GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT 0x8CD6
#define GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT 0x8CD7
#define GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER 0x8CDB
#define GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER 0x8CDC
#define GL_FRAMEBUFFER_UNSUPPORTED        0x8CDD
#define GL_MAX_COLOR_ATTACHMENTS          0x8CDF
#define GL_COLOR_ATTACHMENT0              0x8CE0
#define GL_COLOR_ATTACHMENT1              0x8CE1
#define GL_COLOR_ATTACHMENT2              0x8CE2
#define GL_COLOR_ATTACHMENT3              0x8CE3
#define GL_COLOR_ATTACHMENT4              0x8CE4
#define GL_COLOR_ATTACHMENT5              0x8CE5
#define GL_COLOR_ATTACHMENT6              0x8CE6
#define GL_COLOR_ATTACHMENT7              0x8CE7
#define GL_COLOR_ATTACHMENT8              0x8CE8
#define GL_COLOR_ATTACHMENT9              0x8CE9
#define GL_COLOR_ATTACHMENT10             0x8CEA
#define GL_COLOR_ATTACHMENT11             0x8CEB
#define GL_COLOR_ATTACHMENT12             0x8CEC
#define GL_COLOR_ATTACHMENT13             0x8CED
#define GL_COLOR_ATTACHMENT14             0x8CEE
#define GL_COLOR_ATTACHMENT15             0x8CEF
#define GL_DEPTH_ATTACHMENT               0x8D00
#define GL_STENCIL_ATTACHMENT             0x8D20
#define GL_FRAMEBUFFER                    0x8D40
#define GL_RENDERBUFFER                   0x8D41
#define GL_RENDERBUFFER_WIDTH             0x8D42
#define GL_RENDERBUFFER_HEIGHT            0x8D43
#define GL_RENDERBUFFER_INTERNAL_FORMAT   0x8D44
#define GL_STENCIL_INDEX1                 0x8D46
#define GL_STENCIL_INDEX4                 0x8D47
#define GL_STENCIL_INDEX8                 0x8D48
#define GL_STENCIL_INDEX16                0x8D49
#define GL_RENDERBUFFER_RED_SIZE          0x8D50
#define GL_RENDERBUFFER_GREEN_SIZE        0x8D51
#define GL_RENDERBUFFER_BLUE_SIZE         0x8D52
#define GL_RENDERBUFFER_ALPHA_SIZE        0x8D53
#define GL_RENDERBUFFER_DEPTH_SIZE        0x8D54
#define GL_RENDERBUFFER_STENCIL_SIZE      0x8D55
#define GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE 0x8D56
#define GL_MAX_SAMPLES                    0x8D57
#endif

#ifndef GL_ARB_framebuffer_sRGB
#define GL_FRAMEBUFFER_SRGB               0x8DB9
#endif

#ifndef GL_ARB_half_float_vertex
#define GL_HALF_FLOAT                     0x140B
#endif

#ifndef GL_ARB_map_buffer_range
#define GL_MAP_READ_BIT                   0x0001
#define GL_MAP_WRITE_BIT                  0x0002
#define GL_MAP_INVALIDATE_RANGE_BIT       0x0004
#define GL_MAP_INVALIDATE_BUFFER_BIT      0x0008
#define GL_MAP_FLUSH_EXPLICIT_BIT         0x0010
#define GL_MAP_UNSYNCHRONIZED_BIT         0x0020
#endif

#ifndef GL_ARB_texture_compression_rgtc
#define GL_COMPRESSED_RED_RGTC1           0x8DBB
#define GL_COMPRESSED_SIGNED_RED_RGTC1    0x8DBC
#define GL_COMPRESSED_RG_RGTC2            0x8DBD
#define GL_COMPRESSED_SIGNED_RG_RGTC2     0x8DBE
#endif

#ifndef GL_ARB_texture_rg
#define GL_RG                             0x8227
#define GL_RG_INTEGER                     0x8228
#define GL_R8                             0x8229
#define GL_R16                            0x822A
#define GL_RG8                            0x822B
#define GL_RG16                           0x822C
#define GL_R16F                           0x822D
#define GL_R32F                           0x822E
#define GL_RG16F                          0x822F
#define GL_RG32F                          0x8230
#define GL_R8I                            0x8231
#define GL_R8UI                           0x8232
#define GL_R16I                           0x8233
#define GL_R16UI                          0x8234
#define GL_R32I                           0x8235
#define GL_R32UI                          0x8236
#define GL_RG8I                           0x8237
#define GL_RG8UI                          0x8238
#define GL_RG16I                          0x8239
#define GL_RG16UI                         0x823A
#define GL_RG32I                          0x823B
#define GL_RG32UI                         0x823C
#endif

#ifndef GL_ARB_vertex_array_object
#define GL_VERTEX_ARRAY_BINDING           0x85B5
#endif

#ifndef GL_ARB_uniform_buffer_object
#define GL_UNIFORM_BUFFER                 0x8A11
#define GL_UNIFORM_BUFFER_BINDING         0x8A28
#define GL_UNIFORM_BUFFER_START           0x8A29
#define GL_UNIFORM_BUFFER_SIZE            0x8A2A
#define GL_MAX_VERTEX_UNIFORM_BLOCKS      0x8A2B
#define GL_MAX_GEOMETRY_UNIFORM_BLOCKS    0x8A2C
#define GL_MAX_FRAGMENT_UNIFORM_BLOCKS    0x8A2D
#define GL_MAX_COMBINED_UNIFORM_BLOCKS    0x8A2E
#define GL_MAX_UNIFORM_BUFFER_BINDINGS    0x8A2F
#define GL_MAX_UNIFORM_BLOCK_SIZE         0x8A30
#define GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS 0x8A31
#define GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS 0x8A32
#define GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS 0x8A33
#define GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT 0x8A34
#define GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH 0x8A35
#define GL_ACTIVE_UNIFORM_BLOCKS          0x8A36
#define GL_UNIFORM_TYPE                   0x8A37
#define GL_UNIFORM_SIZE                   0x8A38
#define GL_UNIFORM_NAME_LENGTH            0x8A39
#define GL_UNIFORM_BLOCK_INDEX            0x8A3A
#define GL_UNIFORM_OFFSET                 0x8A3B
#define GL_UNIFORM_ARRAY_STRIDE           0x8A3C
#define GL_UNIFORM_MATRIX_STRIDE          0x8A3D
#define GL_UNIFORM_IS_ROW_MAJOR           0x8A3E
#define GL_UNIFORM_BLOCK_BINDING          0x8A3F
#define GL_UNIFORM_BLOCK_DATA_SIZE        0x8A40
#define GL_UNIFORM_BLOCK_NAME_LENGTH      0x8A41
#define GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS  0x8A42
#define GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES 0x8A43
#define GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER 0x8A44
#define GL_UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER 0x8A45
#define GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER 0x8A46
#define GL_INVALID_INDEX                  0xFFFFFFFFu
#endif

#ifndef GL_ARB_copy_buffer
#define GL_COPY_READ_BUFFER_BINDING       0x8F36
#define GL_COPY_READ_BUFFER               GL_COPY_READ_BUFFER_BINDING
#define GL_COPY_WRITE_BUFFER_BINDING      0x8F37
#define GL_COPY_WRITE_BUFFER              GL_COPY_WRITE_BUFFER_BINDING
#endif

#ifndef GL_ARB_depth_clamp
#define GL_DEPTH_CLAMP                    0x864F
#endif

#ifndef GL_ARB_draw_elements_base_vertex
#endif

#ifndef GL_ARB_fragment_coord_conventions
#endif

#ifndef GL_ARB_provoking_vertex
#define GL_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION 0x8E4C
#define GL_FIRST_VERTEX_CONVENTION        0x8E4D
#define GL_LAST_VERTEX_CONVENTION         0x8E4E
#define GL_PROVOKING_VERTEX               0x8E4F
#endif

#ifndef GL_ARB_seamless_cube_map
#define GL_TEXTURE_CUBE_MAP_SEAMLESS      0x884F
#endif

#ifndef GL_ARB_sync
#define GL_MAX_SERVER_WAIT_TIMEOUT        0x9111
#define GL_OBJECT_TYPE                    0x9112
#define GL_SYNC_CONDITION                 0x9113
#define GL_SYNC_STATUS                    0x9114
#define GL_SYNC_FLAGS                     0x9115
#define GL_SYNC_FENCE                     0x9116
#define GL_SYNC_GPU_COMMANDS_COMPLETE     0x9117
#define GL_UNSIGNALED                     0x9118
#define GL_SIGNALED                       0x9119
#define GL_ALREADY_SIGNALED               0x911A
#define GL_TIMEOUT_EXPIRED                0x911B
#define GL_CONDITION_SATISFIED            0x911C
#define GL_WAIT_FAILED                    0x911D
#define GL_SYNC_FLUSH_COMMANDS_BIT        0x00000001
#define GL_TIMEOUT_IGNORED                0xFFFFFFFFFFFFFFFFull
#endif

#ifndef GL_ARB_texture_multisample
#define GL_SAMPLE_POSITION                0x8E50
#define GL_SAMPLE_MASK                    0x8E51
#define GL_SAMPLE_MASK_VALUE              0x8E52
#define GL_MAX_SAMPLE_MASK_WORDS          0x8E59
#define GL_TEXTURE_2D_MULTISAMPLE         0x9100
#define GL_PROXY_TEXTURE_2D_MULTISAMPLE   0x9101
#define GL_TEXTURE_2D_MULTISAMPLE_ARRAY   0x9102
#define GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY 0x9103
#define GL_TEXTURE_BINDING_2D_MULTISAMPLE 0x9104
#define GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY 0x9105
#define GL_TEXTURE_SAMPLES                0x9106
#define GL_TEXTURE_FIXED_SAMPLE_LOCATIONS 0x9107
#define GL_SAMPLER_2D_MULTISAMPLE         0x9108
#define GL_INT_SAMPLER_2D_MULTISAMPLE     0x9109
#define GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE 0x910A
#define GL_SAMPLER_2D_MULTISAMPLE_ARRAY   0x910B
#define GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY 0x910C
#define GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY 0x910D
#define GL_MAX_COLOR_TEXTURE_SAMPLES      0x910E
#define GL_MAX_DEPTH_TEXTURE_SAMPLES      0x910F
#define GL_MAX_INTEGER_SAMPLES            0x9110
#endif

#ifndef GL_ARB_vertex_array_bgra
/* reuse GL_BGRA */
#endif

#ifndef GL_ARB_draw_buffers_blend
#endif

#ifndef GL_ARB_sample_shading
#define GL_SAMPLE_SHADING_ARB             0x8C36
#define GL_MIN_SAMPLE_SHADING_VALUE_ARB   0x8C37
#endif

#ifndef GL_ARB_texture_cube_map_array
#define GL_TEXTURE_CUBE_MAP_ARRAY_ARB     0x9009
#define GL_TEXTURE_BINDING_CUBE_MAP_ARRAY_ARB 0x900A
#define GL_PROXY_TEXTURE_CUBE_MAP_ARRAY_ARB 0x900B
#define GL_SAMPLER_CUBE_MAP_ARRAY_ARB     0x900C
#define GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW_ARB 0x900D
#define GL_INT_SAMPLER_CUBE_MAP_ARRAY_ARB 0x900E
#define GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY_ARB 0x900F
#endif

#ifndef GL_ARB_texture_gather
#define GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET_ARB 0x8E5E
#define GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET_ARB 0x8E5F
#define GL_MAX_PROGRAM_TEXTURE_GATHER_COMPONENTS_ARB 0x8F9F
#endif

#ifndef GL_ARB_texture_query_lod
#endif

#ifndef GL_ARB_shading_language_include
#define GL_SHADER_INCLUDE_ARB             0x8DAE
#define GL_NAMED_STRING_LENGTH_ARB        0x8DE9
#define GL_NAMED_STRING_TYPE_ARB          0x8DEA
#endif

#ifndef GL_ARB_texture_compression_bptc
#define GL_COMPRESSED_RGBA_BPTC_UNORM_ARB 0x8E8C
#define GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM_ARB 0x8E8D
#define GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT_ARB 0x8E8E
#define GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_ARB 0x8E8F
#endif

#ifndef GL_ARB_blend_func_extended
#define GL_SRC1_COLOR                     0x88F9
/* reuse GL_SRC1_ALPHA */
#define GL_ONE_MINUS_SRC1_COLOR           0x88FA
#define GL_ONE_MINUS_SRC1_ALPHA           0x88FB
#define GL_MAX_DUAL_SOURCE_DRAW_BUFFERS   0x88FC
#endif

#ifndef GL_ARB_explicit_attrib_location
#endif

#ifndef GL_ARB_occlusion_query2
#define GL_ANY_SAMPLES_PASSED             0x8C2F
#endif

#ifndef GL_ARB_sampler_objects
#define GL_SAMPLER_BINDING                0x8919
#endif

#ifndef GL_ARB_shader_bit_encoding
#endif

#ifndef GL_ARB_texture_rgb10_a2ui
#define GL_RGB10_A2UI                     0x906F
#endif

#ifndef GL_ARB_texture_swizzle
#define GL_TEXTURE_SWIZZLE_R              0x8E42
#define GL_TEXTURE_SWIZZLE_G              0x8E43
#define GL_TEXTURE_SWIZZLE_B              0x8E44
#define GL_TEXTURE_SWIZZLE_A              0x8E45
#define GL_TEXTURE_SWIZZLE_RGBA           0x8E46
#endif

#ifndef GL_ARB_timer_query
#define GL_TIME_ELAPSED                   0x88BF
#define GL_TIMESTAMP                      0x8E28
#endif

#ifndef GL_ARB_vertex_type_2_10_10_10_rev
/* reuse GL_UNSIGNED_INT_2_10_10_10_REV */
#define GL_INT_2_10_10_10_REV             0x8D9F
#endif

#ifndef GL_ARB_draw_indirect
#define GL_DRAW_INDIRECT_BUFFER           0x8F3F
#define GL_DRAW_INDIRECT_BUFFER_BINDING   0x8F43
#endif

#ifndef GL_ARB_gpu_shader5
#define GL_GEOMETRY_SHADER_INVOCATIONS    0x887F
#define GL_MAX_GEOMETRY_SHADER_INVOCATIONS 0x8E5A
#define GL_MIN_FRAGMENT_INTERPOLATION_OFFSET 0x8E5B
#define GL_MAX_FRAGMENT_INTERPOLATION_OFFSET 0x8E5C
#define GL_FRAGMENT_INTERPOLATION_OFFSET_BITS 0x8E5D
/* reuse GL_MAX_VERTEX_STREAMS */
#endif

#ifndef GL_ARB_gpu_shader_fp64
/* reuse GL_DOUBLE */
#define GL_DOUBLE_VEC2                    0x8FFC
#define GL_DOUBLE_VEC3                    0x8FFD
#define GL_DOUBLE_VEC4                    0x8FFE
#define GL_DOUBLE_MAT2                    0x8F46
#define GL_DOUBLE_MAT3                    0x8F47
#define GL_DOUBLE_MAT4                    0x8F48
#define GL_DOUBLE_MAT2x3                  0x8F49
#define GL_DOUBLE_MAT2x4                  0x8F4A
#define GL_DOUBLE_MAT3x2                  0x8F4B
#define GL_DOUBLE_MAT3x4                  0x8F4C
#define GL_DOUBLE_MAT4x2                  0x8F4D
#define GL_DOUBLE_MAT4x3                  0x8F4E
#endif

#ifndef GL_ARB_shader_subroutine
#define GL_ACTIVE_SUBROUTINES             0x8DE5
#define GL_ACTIVE_SUBROUTINE_UNIFORMS     0x8DE6
#define GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS 0x8E47
#define GL_ACTIVE_SUBROUTINE_MAX_LENGTH   0x8E48
#define GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH 0x8E49
#define GL_MAX_SUBROUTINES                0x8DE7
#define GL_MAX_SUBROUTINE_UNIFORM_LOCATIONS 0x8DE8
#define GL_NUM_COMPATIBLE_SUBROUTINES     0x8E4A
#define GL_COMPATIBLE_SUBROUTINES         0x8E4B
/* reuse GL_UNIFORM_SIZE */
/* reuse GL_UNIFORM_NAME_LENGTH */
#endif

#ifndef GL_ARB_tessellation_shader
#define GL_PATCHES                        0x000E
#define GL_PATCH_VERTICES                 0x8E72
#define GL_PATCH_DEFAULT_INNER_LEVEL      0x8E73
#define GL_PATCH_DEFAULT_OUTER_LEVEL      0x8E74
#define GL_TESS_CONTROL_OUTPUT_VERTICES   0x8E75
#define GL_TESS_GEN_MODE                  0x8E76
#define GL_TESS_GEN_SPACING               0x8E77
#define GL_TESS_GEN_VERTEX_ORDER          0x8E78
#define GL_TESS_GEN_POINT_MODE            0x8E79
/* reuse GL_TRIANGLES */
/* reuse GL_QUADS */
#define GL_ISOLINES                       0x8E7A
/* reuse GL_EQUAL */
#define GL_FRACTIONAL_ODD                 0x8E7B
#define GL_FRACTIONAL_EVEN                0x8E7C
/* reuse GL_CCW */
/* reuse GL_CW */
#define GL_MAX_PATCH_VERTICES             0x8E7D
#define GL_MAX_TESS_GEN_LEVEL             0x8E7E
#define GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS 0x8E7F
#define GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS 0x8E80
#define GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS 0x8E81
#define GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS 0x8E82
#define GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS 0x8E83
#define GL_MAX_TESS_PATCH_COMPONENTS      0x8E84
#define GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS 0x8E85
#define GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS 0x8E86
#define GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS 0x8E89
#define GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS 0x8E8A
#define GL_MAX_TESS_CONTROL_INPUT_COMPONENTS 0x886C
#define GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS 0x886D
#define GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS 0x8E1E
#define GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS 0x8E1F
#define GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_CONTROL_SHADER 0x84F0
#define GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_EVALUATION_SHADER 0x84F1
#define GL_TESS_EVALUATION_SHADER         0x8E87
#define GL_TESS_CONTROL_SHADER            0x8E88
#endif

#ifndef GL_ARB_texture_buffer_object_rgb32
/* reuse GL_RGB32F */
/* reuse GL_RGB32UI */
/* reuse GL_RGB32I */
#endif

#ifndef GL_ARB_transform_feedback2
#define GL_TRANSFORM_FEEDBACK             0x8E22
#define GL_TRANSFORM_FEEDBACK_PAUSED      0x8E23
#define GL_TRANSFORM_FEEDBACK_BUFFER_PAUSED GL_TRANSFORM_FEEDBACK_PAUSED
#define GL_TRANSFORM_FEEDBACK_ACTIVE      0x8E24
#define GL_TRANSFORM_FEEDBACK_BUFFER_ACTIVE GL_TRANSFORM_FEEDBACK_ACTIVE
#define GL_TRANSFORM_FEEDBACK_BINDING     0x8E25
#endif

#ifndef GL_ARB_transform_feedback3
#define GL_MAX_TRANSFORM_FEEDBACK_BUFFERS 0x8E70
#define GL_MAX_VERTEX_STREAMS             0x8E71
#endif

#ifndef GL_ARB_ES2_compatibility
#define GL_FIXED                          0x140C
#define GL_IMPLEMENTATION_COLOR_READ_TYPE 0x8B9A
#define GL_IMPLEMENTATION_COLOR_READ_FORMAT 0x8B9B
#define GL_LOW_FLOAT                      0x8DF0
#define GL_MEDIUM_FLOAT                   0x8DF1
#define GL_HIGH_FLOAT                     0x8DF2
#define GL_LOW_INT                        0x8DF3
#define GL_MEDIUM_INT                     0x8DF4
#define GL_HIGH_INT                       0x8DF5
#define GL_SHADER_COMPILER                0x8DFA
#define GL_SHADER_BINARY_FORMATS          0x8DF8
#define GL_NUM_SHADER_BINARY_FORMATS      0x8DF9
#define GL_MAX_VERTEX_UNIFORM_VECTORS     0x8DFB
#define GL_MAX_VARYING_VECTORS            0x8DFC
#define GL_MAX_FRAGMENT_UNIFORM_VECTORS   0x8DFD
#define GL_RGB565                         0x8D62
#endif

#ifndef GL_ARB_get_program_binary
#define GL_PROGRAM_BINARY_RETRIEVABLE_HINT 0x8257
#define GL_PROGRAM_BINARY_LENGTH          0x8741
#define GL_NUM_PROGRAM_BINARY_FORMATS     0x87FE
#define GL_PROGRAM_BINARY_FORMATS         0x87FF
#endif

#ifndef GL_ARB_separate_shader_objects
#define GL_VERTEX_SHADER_BIT              0x00000001
#define GL_FRAGMENT_SHADER_BIT            0x00000002
#define GL_GEOMETRY_SHADER_BIT            0x00000004
#define GL_TESS_CONTROL_SHADER_BIT        0x00000008
#define GL_TESS_EVALUATION_SHADER_BIT     0x00000010
#define GL_ALL_SHADER_BITS                0xFFFFFFFF
#define GL_PROGRAM_SEPARABLE              0x8258
#define GL_ACTIVE_PROGRAM                 0x8259
#define GL_PROGRAM_PIPELINE_BINDING       0x825A
#endif

#ifndef GL_ARB_shader_precision
#endif

#ifndef GL_ARB_vertex_attrib_64bit
/* reuse GL_RGB32I */
/* reuse GL_DOUBLE_VEC2 */
/* reuse GL_DOUBLE_VEC3 */
/* reuse GL_DOUBLE_VEC4 */
/* reuse GL_DOUBLE_MAT2 */
/* reuse GL_DOUBLE_MAT3 */
/* reuse GL_DOUBLE_MAT4 */
/* reuse GL_DOUBLE_MAT2x3 */
/* reuse GL_DOUBLE_MAT2x4 */
/* reuse GL_DOUBLE_MAT3x2 */
/* reuse GL_DOUBLE_MAT3x4 */
/* reuse GL_DOUBLE_MAT4x2 */
/* reuse GL_DOUBLE_MAT4x3 */
#endif

#ifndef GL_ARB_viewport_array
/* reuse GL_SCISSOR_BOX */
/* reuse GL_VIEWPORT */
/* reuse GL_DEPTH_RANGE */
/* reuse GL_SCISSOR_TEST */
#define GL_MAX_VIEWPORTS                  0x825B
#define GL_VIEWPORT_SUBPIXEL_BITS         0x825C
#define GL_VIEWPORT_BOUNDS_RANGE          0x825D
#define GL_LAYER_PROVOKING_VERTEX         0x825E
#define GL_VIEWPORT_INDEX_PROVOKING_VERTEX 0x825F
#define GL_UNDEFINED_VERTEX               0x8260
/* reuse GL_FIRST_VERTEX_CONVENTION */
/* reuse GL_LAST_VERTEX_CONVENTION */
/* reuse GL_PROVOKING_VERTEX */
#endif

#ifndef GL_ARB_cl_event
#define GL_SYNC_CL_EVENT_ARB              0x8240
#define GL_SYNC_CL_EVENT_COMPLETE_ARB     0x8241
#endif

#ifndef GL_ARB_debug_output
#define GL_DEBUG_OUTPUT_SYNCHRONOUS_ARB   0x8242
#define GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH_ARB 0x8243
#define GL_DEBUG_CALLBACK_FUNCTION_ARB    0x8244
#define GL_DEBUG_CALLBACK_USER_PARAM_ARB  0x8245
#define GL_DEBUG_SOURCE_API_ARB           0x8246
#define GL_DEBUG_SOURCE_WINDOW_SYSTEM_ARB 0x8247
#define GL_DEBUG_SOURCE_SHADER_COMPILER_ARB 0x8248
#define GL_DEBUG_SOURCE_THIRD_PARTY_ARB   0x8249
#define GL_DEBUG_SOURCE_APPLICATION_ARB   0x824A
#define GL_DEBUG_SOURCE_OTHER_ARB         0x824B
#define GL_DEBUG_TYPE_ERROR_ARB           0x824C
#define GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR_ARB 0x824D
#define GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR_ARB 0x824E
#define GL_DEBUG_TYPE_PORTABILITY_ARB     0x824F
#define GL_DEBUG_TYPE_PERFORMANCE_ARB     0x8250
#define GL_DEBUG_TYPE_OTHER_ARB           0x8251
#define GL_MAX_DEBUG_MESSAGE_LENGTH_ARB   0x9143
#define GL_MAX_DEBUG_LOGGED_MESSAGES_ARB  0x9144
#define GL_DEBUG_LOGGED_MESSAGES_ARB      0x9145
#define GL_DEBUG_SEVERITY_HIGH_ARB        0x9146
#define GL_DEBUG_SEVERITY_MEDIUM_ARB      0x9147
#define GL_DEBUG_SEVERITY_LOW_ARB         0x9148
#endif

#ifndef GL_ARB_robustness
/* reuse GL_NO_ERROR */
#define GL_CONTEXT_FLAG_ROBUST_ACCESS_BIT_ARB 0x00000004
#define GL_LOSE_CONTEXT_ON_RESET_ARB      0x8252
#define GL_GUILTY_CONTEXT_RESET_ARB       0x8253
#define GL_INNOCENT_CONTEXT_RESET_ARB     0x8254
#define GL_UNKNOWN_CONTEXT_RESET_ARB      0x8255
#define GL_RESET_NOTIFICATION_STRATEGY_ARB 0x8256
#define GL_NO_RESET_NOTIFICATION_ARB      0x8261
#endif

#ifndef GL_ARB_shader_stencil_export
#endif

#ifndef GL_ARB_base_instance
#endif

#ifndef GL_ARB_shading_language_420pack
#endif

#ifndef GL_ARB_transform_feedback_instanced
#endif

#ifndef GL_ARB_compressed_texture_pixel_storage
#define GL_UNPACK_COMPRESSED_BLOCK_WIDTH  0x9127
#define GL_UNPACK_COMPRESSED_BLOCK_HEIGHT 0x9128
#define GL_UNPACK_COMPRESSED_BLOCK_DEPTH  0x9129
#define GL_UNPACK_COMPRESSED_BLOCK_SIZE   0x912A
#define GL_PACK_COMPRESSED_BLOCK_WIDTH    0x912B
#define GL_PACK_COMPRESSED_BLOCK_HEIGHT   0x912C
#define GL_PACK_COMPRESSED_BLOCK_DEPTH    0x912D
#define GL_PACK_COMPRESSED_BLOCK_SIZE     0x912E
#endif

#ifndef GL_ARB_conservative_depth
#endif

#ifndef GL_ARB_internalformat_query
#define GL_NUM_SAMPLE_COUNTS              0x9380
#endif

#ifndef GL_ARB_map_buffer_alignment
#define GL_MIN_MAP_BUFFER_ALIGNMENT       0x90BC
#endif

#ifndef GL_ARB_shader_atomic_counters
#define GL_ATOMIC_COUNTER_BUFFER          0x92C0
#define GL_ATOMIC_COUNTER_BUFFER_BINDING  0x92C1
#define GL_ATOMIC_COUNTER_BUFFER_START    0x92C2
#define GL_ATOMIC_COUNTER_BUFFER_SIZE     0x92C3
#define GL_ATOMIC_COUNTER_BUFFER_DATA_SIZE 0x92C4
#define GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS 0x92C5
#define GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_INDICES 0x92C6
#define GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_SHADER 0x92C7
#define GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_CONTROL_SHADER 0x92C8
#define GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_EVALUATION_SHADER 0x92C9
#define GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_GEOMETRY_SHADER 0x92CA
#define GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_FRAGMENT_SHADER 0x92CB
#define GL_MAX_VERTEX_ATOMIC_COUNTER_BUFFERS 0x92CC
#define GL_MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS 0x92CD
#define GL_MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS 0x92CE
#define GL_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS 0x92CF
#define GL_MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS 0x92D0
#define GL_MAX_COMBINED_ATOMIC_COUNTER_BUFFERS 0x92D1
#define GL_MAX_VERTEX_ATOMIC_COUNTERS     0x92D2
#define GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS 0x92D3
#define GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS 0x92D4
#define GL_MAX_GEOMETRY_ATOMIC_COUNTERS   0x92D5
#define GL_MAX_FRAGMENT_ATOMIC_COUNTERS   0x92D6
#define GL_MAX_COMBINED_ATOMIC_COUNTERS   0x92D7
#define GL_MAX_ATOMIC_COUNTER_BUFFER_SIZE 0x92D8
#define GL_MAX_ATOMIC_COUNTER_BUFFER_BINDINGS 0x92DC
#define GL_ACTIVE_ATOMIC_COUNTER_BUFFERS  0x92D9
#define GL_UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX 0x92DA
#define GL_UNSIGNED_INT_ATOMIC_COUNTER    0x92DB
#endif

#ifndef GL_ARB_shader_image_load_store
#define GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT 0x00000001
#define GL_ELEMENT_ARRAY_BARRIER_BIT      0x00000002
#define GL_UNIFORM_BARRIER_BIT            0x00000004
#define GL_TEXTURE_FETCH_BARRIER_BIT      0x00000008
#define GL_SHADER_IMAGE_ACCESS_BARRIER_BIT 0x00000020
#define GL_COMMAND_BARRIER_BIT            0x00000040
#define GL_PIXEL_BUFFER_BARRIER_BIT       0x00000080
#define GL_TEXTURE_UPDATE_BARRIER_BIT     0x00000100
#define GL_BUFFER_UPDATE_BARRIER_BIT      0x00000200
#define GL_FRAMEBUFFER_BARRIER_BIT        0x00000400
#define GL_TRANSFORM_FEEDBACK_BARRIER_BIT 0x00000800
#define GL_ATOMIC_COUNTER_BARRIER_BIT     0x00001000
#define GL_ALL_BARRIER_BITS               0xFFFFFFFF
#define GL_MAX_IMAGE_UNITS                0x8F38
#define GL_MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS 0x8F39
#define GL_IMAGE_BINDING_NAME             0x8F3A
#define GL_IMAGE_BINDING_LEVEL            0x8F3B
#define GL_IMAGE_BINDING_LAYERED          0x8F3C
#define GL_IMAGE_BINDING_LAYER            0x8F3D
#define GL_IMAGE_BINDING_ACCESS           0x8F3E
#define GL_IMAGE_1D                       0x904C
#define GL_IMAGE_2D                       0x904D
#define GL_IMAGE_3D                       0x904E
#define GL_IMAGE_2D_RECT                  0x904F
#define GL_IMAGE_CUBE                     0x9050
#define GL_IMAGE_BUFFER                   0x9051
#define GL_IMAGE_1D_ARRAY                 0x9052
#define GL_IMAGE_2D_ARRAY                 0x9053
#define GL_IMAGE_CUBE_MAP_ARRAY           0x9054
#define GL_IMAGE_2D_MULTISAMPLE           0x9055
#define GL_IMAGE_2D_MULTISAMPLE_ARRAY     0x9056
#define GL_INT_IMAGE_1D                   0x9057
#define GL_INT_IMAGE_2D                   0x9058
#define GL_INT_IMAGE_3D                   0x9059
#define GL_INT_IMAGE_2D_RECT              0x905A
#define GL_INT_IMAGE_CUBE                 0x905B
#define GL_INT_IMAGE_BUFFER               0x905C
#define GL_INT_IMAGE_1D_ARRAY             0x905D
#define GL_INT_IMAGE_2D_ARRAY             0x905E
#define GL_INT_IMAGE_CUBE_MAP_ARRAY       0x905F
#define GL_INT_IMAGE_2D_MULTISAMPLE       0x9060
#define GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY 0x9061
#define GL_UNSIGNED_INT_IMAGE_1D          0x9062
#define GL_UNSIGNED_INT_IMAGE_2D          0x9063
#define GL_UNSIGNED_INT_IMAGE_3D          0x9064
#define GL_UNSIGNED_INT_IMAGE_2D_RECT     0x9065
#define GL_UNSIGNED_INT_IMAGE_CUBE        0x9066
#define GL_UNSIGNED_INT_IMAGE_BUFFER      0x9067
#define GL_UNSIGNED_INT_IMAGE_1D_ARRAY    0x9068
#define GL_UNSIGNED_INT_IMAGE_2D_ARRAY    0x9069
#define GL_UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY 0x906A
#define GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE 0x906B
#define GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY 0x906C
#define GL_MAX_IMAGE_SAMPLES              0x906D
#define GL_IMAGE_BINDING_FORMAT           0x906E
#define GL_IMAGE_FORMAT_COMPATIBILITY_TYPE 0x90C7
#define GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE 0x90C8
#define GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS 0x90C9
#define GL_MAX_VERTEX_IMAGE_UNIFORMS      0x90CA
#define GL_MAX_TESS_CONTROL_IMAGE_UNIFORMS 0x90CB
#define GL_MAX_TESS_EVALUATION_IMAGE_UNIFORMS 0x90CC
#define GL_MAX_GEOMETRY_IMAGE_UNIFORMS    0x90CD
#define GL_MAX_FRAGMENT_IMAGE_UNIFORMS    0x90CE
#define GL_MAX_COMBINED_IMAGE_UNIFORMS    0x90CF
#endif

#ifndef GL_ARB_shading_language_packing
#endif

#ifndef GL_ARB_texture_storage
#define GL_TEXTURE_IMMUTABLE_FORMAT       0x912F
#endif

#ifndef GL_KHR_texture_compression_astc_ldr
#define GL_COMPRESSED_RGBA_ASTC_4x4_KHR   0x93B0
#define GL_COMPRESSED_RGBA_ASTC_5x4_KHR   0x93B1
#define GL_COMPRESSED_RGBA_ASTC_5x5_KHR   0x93B2
#define GL_COMPRESSED_RGBA_ASTC_6x5_KHR   0x93B3
#define GL_COMPRESSED_RGBA_ASTC_6x6_KHR   0x93B4
#define GL_COMPRESSED_RGBA_ASTC_8x5_KHR   0x93B5
#define GL_COMPRESSED_RGBA_ASTC_8x6_KHR   0x93B6
#define GL_COMPRESSED_RGBA_ASTC_8x8_KHR   0x93B7
#define GL_COMPRESSED_RGBA_ASTC_10x5_KHR  0x93B8
#define GL_COMPRESSED_RGBA_ASTC_10x6_KHR  0x93B9
#define GL_COMPRESSED_RGBA_ASTC_10x8_KHR  0x93BA
#define GL_COMPRESSED_RGBA_ASTC_10x10_KHR 0x93BB
#define GL_COMPRESSED_RGBA_ASTC_12x10_KHR 0x93BC
#define GL_COMPRESSED_RGBA_ASTC_12x12_KHR 0x93BD
#define GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR 0x93D0
#define GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR 0x93D1
#define GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR 0x93D2
#define GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR 0x93D3
#define GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR 0x93D4
#define GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR 0x93D5
#define GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR 0x93D6
#define GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR 0x93D7
#define GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR 0x93D8
#define GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR 0x93D9
#define GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR 0x93DA
#define GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR 0x93DB
#define GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR 0x93DC
#define GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR 0x93DD
#endif

#ifndef GL_KHR_debug
#define GL_DEBUG_OUTPUT_SYNCHRONOUS       0x8242
#define GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH 0x8243
#define GL_DEBUG_CALLBACK_FUNCTION        0x8244
#define GL_DEBUG_CALLBACK_USER_PARAM      0x8245
#define GL_DEBUG_SOURCE_API               0x8246
#define GL_DEBUG_SOURCE_WINDOW_SYSTEM     0x8247
#define GL_DEBUG_SOURCE_SHADER_COMPILER   0x8248
#define GL_DEBUG_SOURCE_THIRD_PARTY       0x8249
#define GL_DEBUG_SOURCE_APPLICATION       0x824A
#define GL_DEBUG_SOURCE_OTHER             0x824B
#define GL_DEBUG_TYPE_ERROR               0x824C
#define GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR 0x824D
#define GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR  0x824E
#define GL_DEBUG_TYPE_PORTABILITY         0x824F
#define GL_DEBUG_TYPE_PERFORMANCE         0x8250
#define GL_DEBUG_TYPE_OTHER               0x8251
#define GL_DEBUG_TYPE_MARKER              0x8268
#define GL_DEBUG_TYPE_PUSH_GROUP          0x8269
#define GL_DEBUG_TYPE_POP_GROUP           0x826A
#define GL_DEBUG_SEVERITY_NOTIFICATION    0x826B
#define GL_MAX_DEBUG_GROUP_STACK_DEPTH    0x826C
#define GL_DEBUG_GROUP_STACK_DEPTH        0x826D
#define GL_BUFFER                         0x82E0
#define GL_SHADER                         0x82E1
#define GL_PROGRAM                        0x82E2
#define GL_QUERY                          0x82E3
#define GL_PROGRAM_PIPELINE               0x82E4
#define GL_SAMPLER                        0x82E6
#define GL_DISPLAY_LIST                   0x82E7
/* DISPLAY_LIST used in compatibility profile only */
#define GL_MAX_LABEL_LENGTH               0x82E8
#define GL_MAX_DEBUG_MESSAGE_LENGTH       0x9143
#define GL_MAX_DEBUG_LOGGED_MESSAGES      0x9144
#define GL_DEBUG_LOGGED_MESSAGES          0x9145
#define GL_DEBUG_SEVERITY_HIGH            0x9146
#define GL_DEBUG_SEVERITY_MEDIUM          0x9147
#define GL_DEBUG_SEVERITY_LOW             0x9148
#define GL_DEBUG_OUTPUT                   0x92E0
#define GL_CONTEXT_FLAG_DEBUG_BIT         0x00000002
/* reuse GL_STACK_UNDERFLOW */
/* reuse GL_STACK_OVERFLOW */
#endif

#ifndef GL_ARB_arrays_of_arrays
#endif

#ifndef GL_ARB_clear_buffer_object
#endif

#ifndef GL_ARB_compute_shader
#define GL_COMPUTE_SHADER                 0x91B9
#define GL_MAX_COMPUTE_UNIFORM_BLOCKS     0x91BB
#define GL_MAX_COMPUTE_TEXTURE_IMAGE_UNITS 0x91BC
#define GL_MAX_COMPUTE_IMAGE_UNIFORMS     0x91BD
#define GL_MAX_COMPUTE_SHARED_MEMORY_SIZE 0x8262
#define GL_MAX_COMPUTE_UNIFORM_COMPONENTS 0x8263
#define GL_MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS 0x8264
#define GL_MAX_COMPUTE_ATOMIC_COUNTERS    0x8265
#define GL_MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS 0x8266
#define GL_MAX_COMPUTE_LOCAL_INVOCATIONS  0x90EB
#define GL_MAX_COMPUTE_WORK_GROUP_COUNT   0x91BE
#define GL_MAX_COMPUTE_WORK_GROUP_SIZE    0x91BF
#define GL_COMPUTE_LOCAL_WORK_SIZE        0x8267
#define GL_UNIFORM_BLOCK_REFERENCED_BY_COMPUTE_SHADER 0x90EC
#define GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER 0x90ED
#define GL_DISPATCH_INDIRECT_BUFFER       0x90EE
#define GL_DISPATCH_INDIRECT_BUFFER_BINDING 0x90EF
#define GL_COMPUTE_SHADER_BIT             0x00000020
#endif

#ifndef GL_ARB_copy_image
#endif

#ifndef GL_ARB_texture_view
#define GL_TEXTURE_VIEW_MIN_LEVEL         0x82DB
#define GL_TEXTURE_VIEW_NUM_LEVELS        0x82DC
#define GL_TEXTURE_VIEW_MIN_LAYER         0x82DD
#define GL_TEXTURE_VIEW_NUM_LAYERS        0x82DE
#define GL_TEXTURE_IMMUTABLE_LEVELS       0x82DF
#endif

#ifndef GL_ARB_vertex_attrib_binding
#define GL_VERTEX_ATTRIB_BINDING          0x82D4
#define GL_VERTEX_ATTRIB_RELATIVE_OFFSET  0x82D5
#define GL_VERTEX_BINDING_DIVISOR         0x82D6
#define GL_VERTEX_BINDING_OFFSET          0x82D7
#define GL_VERTEX_BINDING_STRIDE          0x82D8
#define GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET 0x82D9
#define GL_MAX_VERTEX_ATTRIB_BINDINGS     0x82DA
#endif

#ifndef GL_ARB_robustness_isolation
#endif

#ifndef GL_ARB_ES3_compatibility
#define GL_COMPRESSED_RGB8_ETC2           0x9274
#define GL_COMPRESSED_SRGB8_ETC2          0x9275
#define GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 0x9276
#define GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 0x9277
#define GL_COMPRESSED_RGBA8_ETC2_EAC      0x9278
#define GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC 0x9279
#define GL_COMPRESSED_R11_EAC             0x9270
#define GL_COMPRESSED_SIGNED_R11_EAC      0x9271
#define GL_COMPRESSED_RG11_EAC            0x9272
#define GL_COMPRESSED_SIGNED_RG11_EAC     0x9273
#define GL_PRIMITIVE_RESTART_FIXED_INDEX  0x8D69
#define GL_ANY_SAMPLES_PASSED_CONSERVATIVE 0x8D6A
#define GL_MAX_ELEMENT_INDEX              0x8D6B
#endif

#ifndef GL_ARB_explicit_uniform_location
#define GL_MAX_UNIFORM_LOCATIONS          0x826E
#endif

#ifndef GL_ARB_fragment_layer_viewport
#endif

#ifndef GL_ARB_framebuffer_no_attachments
#define GL_FRAMEBUFFER_DEFAULT_WIDTH      0x9310
#define GL_FRAMEBUFFER_DEFAULT_HEIGHT     0x9311
#define GL_FRAMEBUFFER_DEFAULT_LAYERS     0x9312
#define GL_FRAMEBUFFER_DEFAULT_SAMPLES    0x9313
#define GL_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS 0x9314
#define GL_MAX_FRAMEBUFFER_WIDTH          0x9315
#define GL_MAX_FRAMEBUFFER_HEIGHT         0x9316
#define GL_MAX_FRAMEBUFFER_LAYERS         0x9317
#define GL_MAX_FRAMEBUFFER_SAMPLES        0x9318
#endif

#ifndef GL_ARB_internalformat_query2
/* reuse GL_IMAGE_FORMAT_COMPATIBILITY_TYPE */
/* reuse GL_NUM_SAMPLE_COUNTS */
/* reuse GL_RENDERBUFFER */
/* reuse GL_SAMPLES */
/* reuse GL_TEXTURE_1D */
/* reuse GL_TEXTURE_1D_ARRAY */
/* reuse GL_TEXTURE_2D */
/* reuse GL_TEXTURE_2D_ARRAY */
/* reuse GL_TEXTURE_3D */
/* reuse GL_TEXTURE_CUBE_MAP */
/* reuse GL_TEXTURE_CUBE_MAP_ARRAY */
/* reuse GL_TEXTURE_RECTANGLE */
/* reuse GL_TEXTURE_BUFFER */
/* reuse GL_TEXTURE_2D_MULTISAMPLE */
/* reuse GL_TEXTURE_2D_MULTISAMPLE_ARRAY */
/* reuse GL_TEXTURE_COMPRESSED */
#define GL_INTERNALFORMAT_SUPPORTED       0x826F
#define GL_INTERNALFORMAT_PREFERRED       0x8270
#define GL_INTERNALFORMAT_RED_SIZE        0x8271
#define GL_INTERNALFORMAT_GREEN_SIZE      0x8272
#define GL_INTERNALFORMAT_BLUE_SIZE       0x8273
#define GL_INTERNALFORMAT_ALPHA_SIZE      0x8274
#define GL_INTERNALFORMAT_DEPTH_SIZE      0x8275
#define GL_INTERNALFORMAT_STENCIL_SIZE    0x8276
#define GL_INTERNALFORMAT_SHARED_SIZE     0x8277
#define GL_INTERNALFORMAT_RED_TYPE        0x8278
#define GL_INTERNALFORMAT_GREEN_TYPE      0x8279
#define GL_INTERNALFORMAT_BLUE_TYPE       0x827A
#define GL_INTERNALFORMAT_ALPHA_TYPE      0x827B
#define GL_INTERNALFORMAT_DEPTH_TYPE      0x827C
#define GL_INTERNALFORMAT_STENCIL_TYPE    0x827D
#define GL_MAX_WIDTH                      0x827E
#define GL_MAX_HEIGHT                     0x827F
#define GL_MAX_DEPTH                      0x8280
#define GL_MAX_LAYERS                     0x8281
#define GL_MAX_COMBINED_DIMENSIONS        0x8282
#define GL_COLOR_COMPONENTS               0x8283
#define GL_DEPTH_COMPONENTS               0x8284
#define GL_STENCIL_COMPONENTS             0x8285
#define GL_COLOR_RENDERABLE               0x8286
#define GL_DEPTH_RENDERABLE               0x8287
#define GL_STENCIL_RENDERABLE             0x8288
#define GL_FRAMEBUFFER_RENDERABLE         0x8289
#define GL_FRAMEBUFFER_RENDERABLE_LAYERED 0x828A
#define GL_FRAMEBUFFER_BLEND              0x828B
#define GL_READ_PIXELS                    0x828C
#define GL_READ_PIXELS_FORMAT             0x828D
#define GL_READ_PIXELS_TYPE               0x828E
#define GL_TEXTURE_IMAGE_FORMAT           0x828F
#define GL_TEXTURE_IMAGE_TYPE             0x8290
#define GL_GET_TEXTURE_IMAGE_FORMAT       0x8291
#define GL_GET_TEXTURE_IMAGE_TYPE         0x8292
#define GL_MIPMAP                         0x8293
#define GL_MANUAL_GENERATE_MIPMAP         0x8294
#define GL_AUTO_GENERATE_MIPMAP           0x8295
#define GL_COLOR_ENCODING                 0x8296
#define GL_SRGB_READ                      0x8297
#define GL_SRGB_WRITE                     0x8298
#define GL_SRGB_DECODE_ARB                0x8299
#define GL_FILTER                         0x829A
#define GL_VERTEX_TEXTURE                 0x829B
#define GL_TESS_CONTROL_TEXTURE           0x829C
#define GL_TESS_EVALUATION_TEXTURE        0x829D
#define GL_GEOMETRY_TEXTURE               0x829E
#define GL_FRAGMENT_TEXTURE               0x829F
#define GL_COMPUTE_TEXTURE                0x82A0
#define GL_TEXTURE_SHADOW                 0x82A1
#define GL_TEXTURE_GATHER                 0x82A2
#define GL_TEXTURE_GATHER_SHADOW          0x82A3
#define GL_SHADER_IMAGE_LOAD              0x82A4
#define GL_SHADER_IMAGE_STORE             0x82A5
#define GL_SHADER_IMAGE_ATOMIC            0x82A6
#define GL_IMAGE_TEXEL_SIZE               0x82A7
#define GL_IMAGE_COMPATIBILITY_CLASS      0x82A8
#define GL_IMAGE_PIXEL_FORMAT             0x82A9
#define GL_IMAGE_PIXEL_TYPE               0x82AA
#define GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST 0x82AC
#define GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST 0x82AD
#define GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE 0x82AE
#define GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE 0x82AF
#define GL_TEXTURE_COMPRESSED_BLOCK_WIDTH 0x82B1
#define GL_TEXTURE_COMPRESSED_BLOCK_HEIGHT 0x82B2
#define GL_TEXTURE_COMPRESSED_BLOCK_SIZE  0x82B3
#define GL_CLEAR_BUFFER                   0x82B4
#define GL_TEXTURE_VIEW                   0x82B5
#define GL_VIEW_COMPATIBILITY_CLASS       0x82B6
#define GL_FULL_SUPPORT                   0x82B7
#define GL_CAVEAT_SUPPORT                 0x82B8
#define GL_IMAGE_CLASS_4_X_32             0x82B9
#define GL_IMAGE_CLASS_2_X_32             0x82BA
#define GL_IMAGE_CLASS_1_X_32             0x82BB
#define GL_IMAGE_CLASS_4_X_16             0x82BC
#define GL_IMAGE_CLASS_2_X_16             0x82BD
#define GL_IMAGE_CLASS_1_X_16             0x82BE
#define GL_IMAGE_CLASS_4_X_8              0x82BF
#define GL_IMAGE_CLASS_2_X_8              0x82C0
#define GL_IMAGE_CLASS_1_X_8              0x82C1
#define GL_IMAGE_CLASS_11_11_10           0x82C2
#define GL_IMAGE_CLASS_10_10_10_2         0x82C3
#define GL_VIEW_CLASS_128_BITS            0x82C4
#define GL_VIEW_CLASS_96_BITS             0x82C5
#define GL_VIEW_CLASS_64_BITS             0x82C6
#define GL_VIEW_CLASS_48_BITS             0x82C7
#define GL_VIEW_CLASS_32_BITS             0x82C8
#define GL_VIEW_CLASS_24_BITS             0x82C9
#define GL_VIEW_CLASS_16_BITS             0x82CA
#define GL_VIEW_CLASS_8_BITS              0x82CB
#define GL_VIEW_CLASS_S3TC_DXT1_RGB       0x82CC
#define GL_VIEW_CLASS_S3TC_DXT1_RGBA      0x82CD
#define GL_VIEW_CLASS_S3TC_DXT3_RGBA      0x82CE
#define GL_VIEW_CLASS_S3TC_DXT5_RGBA      0x82CF
#define GL_VIEW_CLASS_RGTC1_RED           0x82D0
#define GL_VIEW_CLASS_RGTC2_RG            0x82D1
#define GL_VIEW_CLASS_BPTC_UNORM          0x82D2
#define GL_VIEW_CLASS_BPTC_FLOAT          0x82D3
#endif

#ifndef GL_ARB_invalidate_subdata
#endif

#ifndef GL_ARB_multi_draw_indirect
#endif

#ifndef GL_ARB_program_interface_query
#define GL_UNIFORM                        0x92E1
#define GL_UNIFORM_BLOCK                  0x92E2
#define GL_PROGRAM_INPUT                  0x92E3
#define GL_PROGRAM_OUTPUT                 0x92E4
#define GL_BUFFER_VARIABLE                0x92E5
#define GL_SHADER_STORAGE_BLOCK           0x92E6
/* reuse GL_ATOMIC_COUNTER_BUFFER */
#define GL_VERTEX_SUBROUTINE              0x92E8
#define GL_TESS_CONTROL_SUBROUTINE        0x92E9
#define GL_TESS_EVALUATION_SUBROUTINE     0x92EA
#define GL_GEOMETRY_SUBROUTINE            0x92EB
#define GL_FRAGMENT_SUBROUTINE            0x92EC
#define GL_COMPUTE_SUBROUTINE             0x92ED
#define GL_VERTEX_SUBROUTINE_UNIFORM      0x92EE
#define GL_TESS_CONTROL_SUBROUTINE_UNIFORM 0x92EF
#define GL_TESS_EVALUATION_SUBROUTINE_UNIFORM 0x92F0
#define GL_GEOMETRY_SUBROUTINE_UNIFORM    0x92F1
#define GL_FRAGMENT_SUBROUTINE_UNIFORM    0x92F2
#define GL_COMPUTE_SUBROUTINE_UNIFORM     0x92F3
#define GL_TRANSFORM_FEEDBACK_VARYING     0x92F4
#define GL_ACTIVE_RESOURCES               0x92F5
#define GL_MAX_NAME_LENGTH                0x92F6
#define GL_MAX_NUM_ACTIVE_VARIABLES       0x92F7
#define GL_MAX_NUM_COMPATIBLE_SUBROUTINES 0x92F8
#define GL_NAME_LENGTH                    0x92F9
#define GL_TYPE                           0x92FA
#define GL_ARRAY_SIZE                     0x92FB
#define GL_OFFSET                         0x92FC
#define GL_BLOCK_INDEX                    0x92FD
#define GL_ARRAY_STRIDE                   0x92FE
#define GL_MATRIX_STRIDE                  0x92FF
#define GL_IS_ROW_MAJOR                   0x9300
#define GL_ATOMIC_COUNTER_BUFFER_INDEX    0x9301
#define GL_BUFFER_BINDING                 0x9302
#define GL_BUFFER_DATA_SIZE               0x9303
#define GL_NUM_ACTIVE_VARIABLES           0x9304
#define GL_ACTIVE_VARIABLES               0x9305
#define GL_REFERENCED_BY_VERTEX_SHADER    0x9306
#define GL_REFERENCED_BY_TESS_CONTROL_SHADER 0x9307
#define GL_REFERENCED_BY_TESS_EVALUATION_SHADER 0x9308
#define GL_REFERENCED_BY_GEOMETRY_SHADER  0x9309
#define GL_REFERENCED_BY_FRAGMENT_SHADER  0x930A
#define GL_REFERENCED_BY_COMPUTE_SHADER   0x930B
#define GL_TOP_LEVEL_ARRAY_SIZE           0x930C
#define GL_TOP_LEVEL_ARRAY_STRIDE         0x930D
#define GL_LOCATION                       0x930E
#define GL_LOCATION_INDEX                 0x930F
#define GL_IS_PER_PATCH                   0x92E7
/* reuse GL_NUM_COMPATIBLE_SUBROUTINES */
/* reuse GL_COMPATIBLE_SUBROUTINES */
#endif

#ifndef GL_ARB_robust_buffer_access_behavior
#endif

#ifndef GL_ARB_shader_image_size
#endif

#ifndef GL_ARB_shader_storage_buffer_object
#define GL_SHADER_STORAGE_BUFFER          0x90D2
#define GL_SHADER_STORAGE_BUFFER_BINDING  0x90D3
#define GL_SHADER_STORAGE_BUFFER_START    0x90D4
#define GL_SHADER_STORAGE_BUFFER_SIZE     0x90D5
#define GL_MAX_VERTEX_SHADER_STORAGE_BLOCKS 0x90D6
#define GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS 0x90D7
#define GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS 0x90D8
#define GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS 0x90D9
#define GL_MAX_FRAGMENT_SHADER_STORAGE_BLOCKS 0x90DA
#define GL_MAX_COMPUTE_SHADER_STORAGE_BLOCKS 0x90DB
#define GL_MAX_COMBINED_SHADER_STORAGE_BLOCKS 0x90DC
#define GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS 0x90DD
#define GL_MAX_SHADER_STORAGE_BLOCK_SIZE  0x90DE
#define GL_SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT 0x90DF
#define GL_SHADER_STORAGE_BARRIER_BIT     0x2000
#define GL_MAX_COMBINED_SHADER_OUTPUT_RESOURCES GL_MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS
/* reuse GL_MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS */
#endif

#ifndef GL_ARB_stencil_texturing
#define GL_DEPTH_STENCIL_TEXTURE_MODE     0x90EA
#endif

#ifndef GL_ARB_texture_buffer_range
#define GL_TEXTURE_BUFFER_OFFSET          0x919D
#define GL_TEXTURE_BUFFER_SIZE            0x919E
#define GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT 0x919F
#endif

#ifndef GL_ARB_texture_query_levels
#endif

#ifndef GL_ARB_texture_storage_multisample
#endif


/*************************************************************/

#include <stddef.h>
#ifndef GL_VERSION_2_0
/* GL type for program/shader text */
	typedef char GLchar;
#endif

#ifndef GL_VERSION_1_5
	/* GL types for handling large vertex buffer objects */
	typedef ptrdiff_t GLintptr;
	typedef ptrdiff_t GLsizeiptr;
#endif

#ifndef GL_ARB_vertex_buffer_object
	/* GL types for handling large vertex buffer objects */
	typedef ptrdiff_t GLintptrARB;
	typedef ptrdiff_t GLsizeiptrARB;
#endif

#ifndef GL_ARB_shader_objects
	/* GL types for program/shader text and shader object handles */
	typedef char GLcharARB;
	typedef unsigned int GLhandleARB;
#endif

	/* GL type for "half" precision (s10e5) float data in host memory */
#ifndef GL_ARB_half_float_pixel
	typedef unsigned short GLhalfARB;
#endif

#ifndef GL_NV_half_float
	typedef unsigned short GLhalfNV;
#endif

#ifndef GLEXT_64_TYPES_DEFINED
	/* This code block is duplicated in glxext.h, so must be protected */
#define GLEXT_64_TYPES_DEFINED
/* Define int32_t, int64_t, and uint64_t types for UST/MSC */
/* (as used in the GL_EXT_timer_query extension). */
#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
#include <inttypes.h>
#elif defined(__sun__) || defined(__digital__)
#include <inttypes.h>
#if defined(__STDC__)
#if defined(__arch64__) || defined(_LP64)
	typedef long int int64_t;
	typedef unsigned long int uint64_t;
#else
	typedef long long int int64_t;
	typedef unsigned long long int uint64_t;
#endif /* __arch64__ */
#endif /* __STDC__ */
#elif defined( __VMS ) || defined(__sgi)
#include <inttypes.h>
#elif defined(__SCO__) || defined(__USLC__)
#include <stdint.h>
#elif defined(__UNIXOS2__) || defined(__SOL64__)
	typedef long int int32_t;
	typedef long long int int64_t;
	typedef unsigned long long int uint64_t;
#elif defined(_WIN32) && defined(__GNUC__)
#include <stdint.h>
#elif defined(_WIN32)
	typedef __int32 int32_t;
	typedef __int64 int64_t;
	typedef unsigned __int64 uint64_t;
#else
/* Fallback if nothing above works */
#include <inttypes.h>
#endif
#endif

#ifndef GL_EXT_timer_query
	typedef int64_t GLint64EXT;
	typedef uint64_t GLuint64EXT;
#endif

#ifndef GL_ARB_sync
	typedef int64_t GLint64;
	typedef uint64_t GLuint64;
	typedef struct __GLsync *GLsync;
#endif

#ifndef GL_ARB_cl_event
	/* These incomplete types let us declare types compatible with OpenCL's cl_context and cl_event */
	struct _cl_context;
	struct _cl_event;
#endif

#ifndef GL_ARB_debug_output
	typedef void (APIENTRY *GLDEBUGPROCARB)(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *message, GLvoid *userParam);
#endif

#ifndef GL_AMD_debug_output
	typedef void (APIENTRY *GLDEBUGPROCAMD)(GLuint id, GLenum category, GLenum severity, GLsizei length, const GLchar *message, GLvoid *userParam);
#endif

#ifndef GL_KHR_debug
	typedef void (APIENTRY *GLDEBUGPROC)(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *message, GLvoid *userParam);
#endif

#ifndef GL_NV_vdpau_interop
	typedef GLintptr GLvdpauSurfaceNV;
#endif

#ifndef GL_VERSION_1_0
#define GL_VERSION_1_0 1
#ifdef GLCOREARB_PROTOTYPES
	GLAPI void APIENTRY glCullFace(GLenum mode);
	GLAPI void APIENTRY glFrontFace(GLenum mode);
	GLAPI void APIENTRY glHint(GLenum target, GLenum mode);
	GLAPI void APIENTRY glLineWidth(GLfloat width);
	GLAPI void APIENTRY glPointSize(GLfloat size);
	GLAPI void APIENTRY glPolygonMode(GLenum face, GLenum mode);
	GLAPI void APIENTRY glScissor(GLint x, GLint y, GLsizei width, GLsizei height);
	GLAPI void APIENTRY glTexParameterf(GLenum target, GLenum pname, GLfloat param);
	GLAPI void APIENTRY glTexParameterfv(GLenum target, GLenum pname, const GLfloat *params);
	GLAPI void APIENTRY glTexParameteri(GLenum target, GLenum pname, GLint param);
	GLAPI void APIENTRY glTexParameteriv(GLenum target, GLenum pname, const GLint *params);
	GLAPI void APIENTRY glTexImage1D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
	GLAPI void APIENTRY glTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
	GLAPI void APIENTRY glDrawBuffer(GLenum mode);
	GLAPI void APIENTRY glClear(GLbitfield mask);
	GLAPI void APIENTRY glClearColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
	GLAPI void APIENTRY glClearStencil(GLint s);
	GLAPI void APIENTRY glClearDepth(GLdouble depth);
	GLAPI void APIENTRY glStencilMask(GLuint mask);
	GLAPI void APIENTRY glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
	GLAPI void APIENTRY glDepthMask(GLboolean flag);
	GLAPI void APIENTRY glDisable(GLenum cap);
	GLAPI void APIENTRY glEnable(GLenum cap);
	GLAPI void APIENTRY glFinish(void);
	GLAPI void APIENTRY glFlush(void);
	GLAPI void APIENTRY glBlendFunc(GLenum sfactor, GLenum dfactor);
	GLAPI void APIENTRY glLogicOp(GLenum opcode);
	GLAPI void APIENTRY glStencilFunc(GLenum func, GLint ref, GLuint mask);
	GLAPI void APIENTRY glStencilOp(GLenum fail, GLenum zfail, GLenum zpass);
	GLAPI void APIENTRY glDepthFunc(GLenum func);
	GLAPI void APIENTRY glPixelStoref(GLenum pname, GLfloat param);
	GLAPI void APIENTRY glPixelStorei(GLenum pname, GLint param);
	GLAPI void APIENTRY glReadBuffer(GLenum mode);
	GLAPI void APIENTRY glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels);
	GLAPI void APIENTRY glGetBooleanv(GLenum pname, GLboolean *params);
	GLAPI void APIENTRY glGetDoublev(GLenum pname, GLdouble *params);
	GLAPI GLenum APIENTRY glGetError(void);
	GLAPI void APIENTRY glGetFloatv(GLenum pname, GLfloat *params);
	GLAPI void APIENTRY glGetIntegerv(GLenum pname, GLint *params);
	GLAPI const GLubyte * APIENTRY glGetString(GLenum name);
	GLAPI void APIENTRY glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels);
	GLAPI void APIENTRY glGetTexParameterfv(GLenum target, GLenum pname, GLfloat *params);
	GLAPI void APIENTRY glGetTexParameteriv(GLenum target, GLenum pname, GLint *params);
	GLAPI void APIENTRY glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat *params);
	GLAPI void APIENTRY glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint *params);
	GLAPI GLboolean APIENTRY glIsEnabled(GLenum cap);
	GLAPI void APIENTRY glDepthRange(GLdouble near, GLdouble far);
	GLAPI void APIENTRY glViewport(GLint x, GLint y, GLsizei width, GLsizei height);
#endif /* GLCOREARB_PROTOTYPES */
	typedef void (APIENTRYP PFNGLCULLFACEPROC) (GLenum mode);
	typedef void (APIENTRYP PFNGLFRONTFACEPROC) (GLenum mode);
	typedef void (APIENTRYP PFNGLHINTPROC) (GLenum target, GLenum mode);
	typedef void (APIENTRYP PFNGLLINEWIDTHPROC) (GLfloat width);
	typedef void (APIENTRYP PFNGLPOINTSIZEPROC) (GLfloat size);
	typedef void (APIENTRYP PFNGLPOLYGONMODEPROC) (GLenum face, GLenum mode);
	typedef void (APIENTRYP PFNGLSCISSORPROC) (GLint x, GLint y, GLsizei width, GLsizei height);
	typedef void (APIENTRYP PFNGLTEXPARAMETERFPROC) (GLenum target, GLenum pname, GLfloat param);
	typedef void (APIENTRYP PFNGLTEXPARAMETERFVPROC) (GLenum target, GLenum pname, const GLfloat *params);
	typedef void (APIENTRYP PFNGLTEXPARAMETERIPROC) (GLenum target, GLenum pname, GLint param);
	typedef void (APIENTRYP PFNGLTEXPARAMETERIVPROC) (GLenum target, GLenum pname, const GLint *params);
	typedef void (APIENTRYP PFNGLTEXIMAGE1DPROC) (GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
	typedef void (APIENTRYP PFNGLTEXIMAGE2DPROC) (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
	typedef void (APIENTRYP PFNGLDRAWBUFFERPROC) (GLenum mode);
	typedef void (APIENTRYP PFNGLCLEARPROC) (GLbitfield mask);
	typedef void (APIENTRYP PFNGLCLEARCOLORPROC) (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
	typedef void (APIENTRYP PFNGLCLEARSTENCILPROC) (GLint s);
	typedef void (APIENTRYP PFNGLCLEARDEPTHPROC) (GLdouble depth);
	typedef void (APIENTRYP PFNGLSTENCILMASKPROC) (GLuint mask);
	typedef void (APIENTRYP PFNGLCOLORMASKPROC) (GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
	typedef void (APIENTRYP PFNGLDEPTHMASKPROC) (GLboolean flag);
	typedef void (APIENTRYP PFNGLDISABLEPROC) (GLenum cap);
	typedef void (APIENTRYP PFNGLENABLEPROC) (GLenum cap);
	typedef void (APIENTRYP PFNGLFINISHPROC) (void);
	typedef void (APIENTRYP PFNGLFLUSHPROC) (void);
	typedef void (APIENTRYP PFNGLBLENDFUNCPROC) (GLenum sfactor, GLenum dfactor);
	typedef void (APIENTRYP PFNGLLOGICOPPROC) (GLenum opcode);
	typedef void (APIENTRYP PFNGLSTENCILFUNCPROC) (GLenum func, GLint ref, GLuint mask);
	typedef void (APIENTRYP PFNGLSTENCILOPPROC) (GLenum fail, GLenum zfail, GLenum zpass);
	typedef void (APIENTRYP PFNGLDEPTHFUNCPROC) (GLenum func);
	typedef void (APIENTRYP PFNGLPIXELSTOREFPROC) (GLenum pname, GLfloat param);
	typedef void (APIENTRYP PFNGLPIXELSTOREIPROC) (GLenum pname, GLint param);
	typedef void (APIENTRYP PFNGLREADBUFFERPROC) (GLenum mode);
	typedef void (APIENTRYP PFNGLREADPIXELSPROC) (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels);
	typedef void (APIENTRYP PFNGLGETBOOLEANVPROC) (GLenum pname, GLboolean *params);
	typedef void (APIENTRYP PFNGLGETDOUBLEVPROC) (GLenum pname, GLdouble *params);
	typedef GLenum(APIENTRYP PFNGLGETERRORPROC) (void);
	typedef void (APIENTRYP PFNGLGETFLOATVPROC) (GLenum pname, GLfloat *params);
	typedef void (APIENTRYP PFNGLGETINTEGERVPROC) (GLenum pname, GLint *params);
	typedef const GLubyte * (APIENTRYP PFNGLGETSTRINGPROC) (GLenum name);
	typedef void (APIENTRYP PFNGLGETTEXIMAGEPROC) (GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels);
	typedef void (APIENTRYP PFNGLGETTEXPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat *params);
	typedef void (APIENTRYP PFNGLGETTEXPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
	typedef void (APIENTRYP PFNGLGETTEXLEVELPARAMETERFVPROC) (GLenum target, GLint level, GLenum pname, GLfloat *params);
	typedef void (APIENTRYP PFNGLGETTEXLEVELPARAMETERIVPROC) (GLenum target, GLint level, GLenum pname, GLint *params);
	typedef GLboolean(APIENTRYP PFNGLISENABLEDPROC) (GLenum cap);
	typedef void (APIENTRYP PFNGLDEPTHRANGEPROC) (GLdouble near, GLdouble far);
	typedef void (APIENTRYP PFNGLVIEWPORTPROC) (GLint x, GLint y, GLsizei width, GLsizei height);
#endif

#ifndef GL_VERSION_1_1
#define GL_VERSION_1_1 1
#ifdef GLCOREARB_PROTOTYPES
	GLAPI void APIENTRY glDrawArrays(GLenum mode, GLint first, GLsizei count);
	GLAPI void APIENTRY glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices);
	GLAPI void APIENTRY glGetPointerv(GLenum pname, GLvoid* *params);
	GLAPI void APIENTRY glPolygonOffset(GLfloat factor, GLfloat units);
	GLAPI void APIENTRY glCopyTexImage1D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
	GLAPI void APIENTRY glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
	GLAPI void APIENTRY glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
	GLAPI void APIENTRY glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
	GLAPI void APIENTRY glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels);
	GLAPI void APIENTRY glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
	GLAPI void APIENTRY glBindTexture(GLenum target, GLuint texture);
	GLAPI void APIENTRY glDeleteTextures(GLsizei n, const GLuint *textures);
	GLAPI void APIENTRY glGenTextures(GLsizei n, GLuint *textures);
	GLAPI GLboolean APIENTRY glIsTexture(GLuint texture);
#endif /* GLCOREARB_PROTOTYPES */
	typedef void (APIENTRYP PFNGLDRAWARRAYSPROC) (GLenum mode, GLint first, GLsizei count);
	typedef void (APIENTRYP PFNGLDRAWELEMENTSPROC) (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices);
	typedef void (APIENTRYP PFNGLGETPOINTERVPROC) (GLenum pname, GLvoid* *params);
	typedef void (APIENTRYP PFNGLPOLYGONOFFSETPROC) (GLfloat factor, GLfloat units);
	typedef void (APIENTRYP PFNGLCOPYTEXIMAGE1DPROC) (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
	typedef void (APIENTRYP PFNGLCOPYTEXIMAGE2DPROC) (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
	typedef void (APIENTRYP PFNGLCOPYTEXSUBIMAGE1DPROC) (GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
	typedef void (APIENTRYP PFNGLCOPYTEXSUBIMAGE2DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
	typedef void (APIENTRYP PFNGLTEXSUBIMAGE1DPROC) (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels);
	typedef void (APIENTRYP PFNGLTEXSUBIMAGE2DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
	typedef void (APIENTRYP PFNGLBINDTEXTUREPROC) (GLenum target, GLuint texture);
	typedef void (APIENTRYP PFNGLDELETETEXTURESPROC) (GLsizei n, const GLuint *textures);
	typedef void (APIENTRYP PFNGLGENTEXTURESPROC) (GLsizei n, GLuint *textures);
	typedef GLboolean(APIENTRYP PFNGLISTEXTUREPROC) (GLuint texture);
#endif

#ifndef GL_VERSION_1_2
#define GL_VERSION_1_2 1
#ifdef GLCOREARB_PROTOTYPES
	GLAPI void APIENTRY glBlendColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
	GLAPI void APIENTRY glBlendEquation(GLenum mode);
	GLAPI void APIENTRY glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices);
	GLAPI void APIENTRY glTexImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
	GLAPI void APIENTRY glTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels);
	GLAPI void APIENTRY glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
#endif /* GLCOREARB_PROTOTYPES */
	typedef void (APIENTRYP PFNGLBLENDCOLORPROC) (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
	typedef void (APIENTRYP PFNGLBLENDEQUATIONPROC) (GLenum mode);
	typedef void (APIENTRYP PFNGLDRAWRANGEELEMENTSPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices);
	typedef void (APIENTRYP PFNGLTEXIMAGE3DPROC) (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
	typedef void (APIENTRYP PFNGLTEXSUBIMAGE3DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels);
	typedef void (APIENTRYP PFNGLCOPYTEXSUBIMAGE3DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
#endif

#ifndef GL_VERSION_1_3
#define GL_VERSION_1_3 1
#ifdef GLCOREARB_PROTOTYPES
	GLAPI void APIENTRY glActiveTexture(GLenum texture);
	GLAPI void APIENTRY glSampleCoverage(GLfloat value, GLboolean invert);
	GLAPI void APIENTRY glCompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data);
	GLAPI void APIENTRY glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data);
	GLAPI void APIENTRY glCompressedTexImage1D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data);
	GLAPI void APIENTRY glCompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data);
	GLAPI void APIENTRY glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data);
	GLAPI void APIENTRY glCompressedTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data);
	GLAPI void APIENTRY glGetCompressedTexImage(GLenum target, GLint level, GLvoid *img);
#endif /* GLCOREARB_PROTOTYPES */
	typedef void (APIENTRYP PFNGLACTIVETEXTUREPROC) (GLenum texture);
	typedef void (APIENTRYP PFNGLSAMPLECOVERAGEPROC) (GLfloat value, GLboolean invert);
	typedef void (APIENTRYP PFNGLCOMPRESSEDTEXIMAGE3DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data);
	typedef void (APIENTRYP PFNGLCOMPRESSEDTEXIMAGE2DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data);
	typedef void (APIENTRYP PFNGLCOMPRESSEDTEXIMAGE1DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data);
	typedef void (APIENTRYP PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data);
	typedef void (APIENTRYP PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data);
	typedef void (APIENTRYP PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC) (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data);
	typedef void (APIENTRYP PFNGLGETCOMPRESSEDTEXIMAGEPROC) (GLenum target, GLint level, GLvoid *img);
#endif

#ifndef GL_VERSION_1_4
#define GL_VERSION_1_4 1
#ifdef GLCOREARB_PROTOTYPES
	GLAPI void APIENTRY glBlendFuncSeparate(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
	GLAPI void APIENTRY glMultiDrawArrays(GLenum mode, const GLint *first, const GLsizei *count, GLsizei drawcount);
	GLAPI void APIENTRY glMultiDrawElements(GLenum mode, const GLsizei *count, GLenum type, const GLvoid* const *indices, GLsizei drawcount);
	GLAPI void APIENTRY glPointParameterf(GLenum pname, GLfloat param);
	GLAPI void APIENTRY glPointParameterfv(GLenum pname, const GLfloat *params);
	GLAPI void APIENTRY glPointParameteri(GLenum pname, GLint param);
	GLAPI void APIENTRY glPointParameteriv(GLenum pname, const GLint *params);
#endif /* GLCOREARB_PROTOTYPES */
	typedef void (APIENTRYP PFNGLBLENDFUNCSEPARATEPROC) (GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
	typedef void (APIENTRYP PFNGLMULTIDRAWARRAYSPROC) (GLenum mode, const GLint *first, const GLsizei *count, GLsizei drawcount);
	typedef void (APIENTRYP PFNGLMULTIDRAWELEMENTSPROC) (GLenum mode, const GLsizei *count, GLenum type, const GLvoid* const *indices, GLsizei drawcount);
	typedef void (APIENTRYP PFNGLPOINTPARAMETERFPROC) (GLenum pname, GLfloat param);
	typedef void (APIENTRYP PFNGLPOINTPARAMETERFVPROC) (GLenum pname, const GLfloat *params);
	typedef void (APIENTRYP PFNGLPOINTPARAMETERIPROC) (GLenum pname, GLint param);
	typedef void (APIENTRYP PFNGLPOINTPARAMETERIVPROC) (GLenum pname, const GLint *params);
#endif

#ifndef GL_VERSION_1_5
#define GL_VERSION_1_5 1
#ifdef GLCOREARB_PROTOTYPES
	GLAPI void APIENTRY glGenQueries(GLsizei n, GLuint *ids);
	GLAPI void APIENTRY glDeleteQueries(GLsizei n, const GLuint *ids);
	GLAPI GLboolean APIENTRY glIsQuery(GLuint id);
	GLAPI void APIENTRY glBeginQuery(GLenum target, GLuint id);
	GLAPI void APIENTRY glEndQuery(GLenum target);
	GLAPI void APIENTRY glGetQueryiv(GLenum target, GLenum pname, GLint *params);
	GLAPI void APIENTRY glGetQueryObjectiv(GLuint id, GLenum pname, GLint *params);
	GLAPI void APIENTRY glGetQueryObjectuiv(GLuint id, GLenum pname, GLuint *params);
	GLAPI void APIENTRY glBindBuffer(GLenum target, GLuint buffer);
	GLAPI void APIENTRY glDeleteBuffers(GLsizei n, const GLuint *buffers);
	GLAPI void APIENTRY glGenBuffers(GLsizei n, GLuint *buffers);
	GLAPI GLboolean APIENTRY glIsBuffer(GLuint buffer);
	GLAPI void APIENTRY glBufferData(GLenum target, GLsizeiptr size, const GLvoid *data, GLenum usage);
	GLAPI void APIENTRY glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid *data);
	GLAPI void APIENTRY glGetBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, GLvoid *data);
	GLAPI GLvoid* APIENTRY glMapBuffer(GLenum target, GLenum access);
	GLAPI GLboolean APIENTRY glUnmapBuffer(GLenum target);
	GLAPI void APIENTRY glGetBufferParameteriv(GLenum target, GLenum pname, GLint *params);
	GLAPI void APIENTRY glGetBufferPointerv(GLenum target, GLenum pname, GLvoid* *params);
#endif /* GLCOREARB_PROTOTYPES */
	typedef void (APIENTRYP PFNGLGENQUERIESPROC) (GLsizei n, GLuint *ids);
	typedef void (APIENTRYP PFNGLDELETEQUERIESPROC) (GLsizei n, const GLuint *ids);
	typedef GLboolean(APIENTRYP PFNGLISQUERYPROC) (GLuint id);
	typedef void (APIENTRYP PFNGLBEGINQUERYPROC) (GLenum target, GLuint id);
	typedef void (APIENTRYP PFNGLENDQUERYPROC) (GLenum target);
	typedef void (APIENTRYP PFNGLGETQUERYIVPROC) (GLenum target, GLenum pname, GLint *params);
	typedef void (APIENTRYP PFNGLGETQUERYOBJECTIVPROC) (GLuint id, GLenum pname, GLint *params);
	typedef void (APIENTRYP PFNGLGETQUERYOBJECTUIVPROC) (GLuint id, GLenum pname, GLuint *params);
	typedef void (APIENTRYP PFNGLBINDBUFFERPROC) (GLenum target, GLuint buffer);
	typedef void (APIENTRYP PFNGLDELETEBUFFERSPROC) (GLsizei n, const GLuint *buffers);
	typedef void (APIENTRYP PFNGLGENBUFFERSPROC) (GLsizei n, GLuint *buffers);
	typedef GLboolean(APIENTRYP PFNGLISBUFFERPROC) (GLuint buffer);
	typedef void (APIENTRYP PFNGLBUFFERDATAPROC) (GLenum target, GLsizeiptr size, const GLvoid *data, GLenum usage);
	typedef void (APIENTRYP PFNGLBUFFERSUBDATAPROC) (GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid *data);
	typedef void (APIENTRYP PFNGLGETBUFFERSUBDATAPROC) (GLenum target, GLintptr offset, GLsizeiptr size, GLvoid *data);
	typedef GLvoid* (APIENTRYP PFNGLMAPBUFFERPROC) (GLenum target, GLenum access);
	typedef GLboolean(APIENTRYP PFNGLUNMAPBUFFERPROC) (GLenum target);
	typedef void (APIENTRYP PFNGLGETBUFFERPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
	typedef void (APIENTRYP PFNGLGETBUFFERPOINTERVPROC) (GLenum target, GLenum pname, GLvoid* *params);
#endif

#ifndef GL_VERSION_2_0
#define GL_VERSION_2_0 1
#ifdef GLCOREARB_PROTOTYPES
	GLAPI void APIENTRY glBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha);
	GLAPI void APIENTRY glDrawBuffers(GLsizei n, const GLenum *bufs);
	GLAPI void APIENTRY glStencilOpSeparate(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
	GLAPI void APIENTRY glStencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask);
	GLAPI void APIENTRY glStencilMaskSeparate(GLenum face, GLuint mask);
	GLAPI void APIENTRY glAttachShader(GLuint program, GLuint shader);
	GLAPI void APIENTRY glBindAttribLocation(GLuint program, GLuint index, const GLchar *name);
	GLAPI void APIENTRY glCompileShader(GLuint shader);
	GLAPI GLuint APIENTRY glCreateProgram(void);
	GLAPI GLuint APIENTRY glCreateShader(GLenum type);
	GLAPI void APIENTRY glDeleteProgram(GLuint program);
	GLAPI void APIENTRY glDeleteShader(GLuint shader);
	GLAPI void APIENTRY glDetachShader(GLuint program, GLuint shader);
	GLAPI void APIENTRY glDisableVertexAttribArray(GLuint index);
	GLAPI void APIENTRY glEnableVertexAttribArray(GLuint index);
	GLAPI void APIENTRY glGetActiveAttrib(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name);
	GLAPI void APIENTRY glGetActiveUniform(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name);
	GLAPI void APIENTRY glGetAttachedShaders(GLuint program, GLsizei maxCount, GLsizei *count, GLuint *obj);
	GLAPI GLint APIENTRY glGetAttribLocation(GLuint program, const GLchar *name);
	GLAPI void APIENTRY glGetProgramiv(GLuint program, GLenum pname, GLint *params);
	GLAPI void APIENTRY glGetProgramInfoLog(GLuint program, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
	GLAPI void APIENTRY glGetShaderiv(GLuint shader, GLenum pname, GLint *params);
	GLAPI void APIENTRY glGetShaderInfoLog(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
	GLAPI void APIENTRY glGetShaderSource(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source);
	GLAPI GLint APIENTRY glGetUniformLocation(GLuint program, const GLchar *name);
	GLAPI void APIENTRY glGetUniformfv(GLuint program, GLint location, GLfloat *params);
	GLAPI void APIENTRY glGetUniformiv(GLuint program, GLint location, GLint *params);
	GLAPI void APIENTRY glGetVertexAttribdv(GLuint index, GLenum pname, GLdouble *params);
	GLAPI void APIENTRY glGetVertexAttribfv(GLuint index, GLenum pname, GLfloat *params);
	GLAPI void APIENTRY glGetVertexAttribiv(GLuint index, GLenum pname, GLint *params);
	GLAPI void APIENTRY glGetVertexAttribPointerv(GLuint index, GLenum pname, GLvoid* *pointer);
	GLAPI GLboolean APIENTRY glIsProgram(GLuint program);
	GLAPI GLboolean APIENTRY glIsShader(GLuint shader);
	GLAPI void APIENTRY glLinkProgram(GLuint program);
	GLAPI void APIENTRY glShaderSource(GLuint shader, GLsizei count, const GLchar* const *string, const GLint *length);
	GLAPI void APIENTRY glUseProgram(GLuint program);
	GLAPI void APIENTRY glUniform1f(GLint location, GLfloat v0);
	GLAPI void APIENTRY glUniform2f(GLint location, GLfloat v0, GLfloat v1);
	GLAPI void APIENTRY glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
	GLAPI void APIENTRY glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
	GLAPI void APIENTRY glUniform1i(GLint location, GLint v0);
	GLAPI void APIENTRY glUniform2i(GLint location, GLint v0, GLint v1);
	GLAPI void APIENTRY glUniform3i(GLint location, GLint v0, GLint v1, GLint v2);
	GLAPI void APIENTRY glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
	GLAPI void APIENTRY glUniform1fv(GLint location, GLsizei count, const GLfloat *value);
	GLAPI void APIENTRY glUniform2fv(GLint location, GLsizei count, const GLfloat *value);
	GLAPI void APIENTRY glUniform3fv(GLint location, GLsizei count, const GLfloat *value);
	GLAPI void APIENTRY glUniform4fv(GLint location, GLsizei count, const GLfloat *value);
	GLAPI void APIENTRY glUniform1iv(GLint location, GLsizei count, const GLint *value);
	GLAPI void APIENTRY glUniform2iv(GLint location, GLsizei count, const GLint *value);
	GLAPI void APIENTRY glUniform3iv(GLint location, GLsizei count, const GLint *value);
	GLAPI void APIENTRY glUniform4iv(GLint location, GLsizei count, const GLint *value);
	GLAPI void APIENTRY glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
	GLAPI void APIENTRY glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
	GLAPI void APIENTRY glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
	GLAPI void APIENTRY glValidateProgram(GLuint program);
	GLAPI void APIENTRY glVertexAttrib1d(GLuint index, GLdouble x);
	GLAPI void APIENTRY glVertexAttrib1dv(GLuint index, const GLdouble *v);
	GLAPI void APIENTRY glVertexAttrib1f(GLuint index, GLfloat x);
	GLAPI void APIENTRY glVertexAttrib1fv(GLuint index, const GLfloat *v);
	GLAPI void APIENTRY glVertexAttrib1s(GLuint index, GLshort x);
	GLAPI void APIENTRY glVertexAttrib1sv(GLuint index, const GLshort *v);
	GLAPI void APIENTRY glVertexAttrib2d(GLuint index, GLdouble x, GLdouble y);
	GLAPI void APIENTRY glVertexAttrib2dv(GLuint index, const GLdouble *v);
	GLAPI void APIENTRY glVertexAttrib2f(GLuint index, GLfloat x, GLfloat y);
	GLAPI void APIENTRY glVertexAttrib2fv(GLuint index, const GLfloat *v);
	GLAPI void APIENTRY glVertexAttrib2s(GLuint index, GLshort x, GLshort y);
	GLAPI void APIENTRY glVertexAttrib2sv(GLuint index, const GLshort *v);
	GLAPI void APIENTRY glVertexAttrib3d(GLuint index, GLdouble x, GLdouble y, GLdouble z);
	GLAPI void APIENTRY glVertexAttrib3dv(GLuint index, const GLdouble *v);
	GLAPI void APIENTRY glVertexAttrib3f(GLuint index, GLfloat x, GLfloat y, GLfloat z);
	GLAPI void APIENTRY glVertexAttrib3fv(GLuint index, const GLfloat *v);
	GLAPI void APIENTRY glVertexAttrib3s(GLuint index, GLshort x, GLshort y, GLshort z);
	GLAPI void APIENTRY glVertexAttrib3sv(GLuint index, const GLshort *v);
	GLAPI void APIENTRY glVertexAttrib4Nbv(GLuint index, const GLbyte *v);
	GLAPI void APIENTRY glVertexAttrib4Niv(GLuint index, const GLint *v);
	GLAPI void APIENTRY glVertexAttrib4Nsv(GLuint index, const GLshort *v);
	GLAPI void APIENTRY glVertexAttrib4Nub(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
	GLAPI void APIENTRY glVertexAttrib4Nubv(GLuint index, const GLubyte *v);
	GLAPI void APIENTRY glVertexAttrib4Nuiv(GLuint index, const GLuint *v);
	GLAPI void APIENTRY glVertexAttrib4Nusv(GLuint index, const GLushort *v);
	GLAPI void APIENTRY glVertexAttrib4bv(GLuint index, const GLbyte *v);
	GLAPI void APIENTRY glVertexAttrib4d(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
	GLAPI void APIENTRY glVertexAttrib4dv(GLuint index, const GLdouble *v);
	GLAPI void APIENTRY glVertexAttrib4f(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
	GLAPI void APIENTRY glVertexAttrib4fv(GLuint index, const GLfloat *v);
	GLAPI void APIENTRY glVertexAttrib4iv(GLuint index, const GLint *v);
	GLAPI void APIENTRY glVertexAttrib4s(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
	GLAPI void APIENTRY glVertexAttrib4sv(GLuint index, const GLshort *v);
	GLAPI void APIENTRY glVertexAttrib4ubv(GLuint index, const GLubyte *v);
	GLAPI void APIENTRY glVertexAttrib4uiv(GLuint index, const GLuint *v);
	GLAPI void APIENTRY glVertexAttrib4usv(GLuint index, const GLushort *v);
	GLAPI void APIENTRY glVertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer);
#endif /* GLCOREARB_PROTOTYPES */
	typedef void (APIENTRYP PFNGLBLENDEQUATIONSEPARATEPROC) (GLenum modeRGB, GLenum modeAlpha);
	typedef void (APIENTRYP PFNGLDRAWBUFFERSPROC) (GLsizei n, const GLenum *bufs);
	typedef void (APIENTRYP PFNGLSTENCILOPSEPARATEPROC) (GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
	typedef void (APIENTRYP PFNGLSTENCILFUNCSEPARATEPROC) (GLenum face, GLenum func, GLint ref, GLuint mask);
	typedef void (APIENTRYP PFNGLSTENCILMASKSEPARATEPROC) (GLenum face, GLuint mask);
	typedef void (APIENTRYP PFNGLATTACHSHADERPROC) (GLuint program, GLuint shader);
	typedef void (APIENTRYP PFNGLBINDATTRIBLOCATIONPROC) (GLuint program, GLuint index, const GLchar *name);
	typedef void (APIENTRYP PFNGLCOMPILESHADERPROC) (GLuint shader);
	typedef GLuint(APIENTRYP PFNGLCREATEPROGRAMPROC) (void);
	typedef GLuint(APIENTRYP PFNGLCREATESHADERPROC) (GLenum type);
	typedef void (APIENTRYP PFNGLDELETEPROGRAMPROC) (GLuint program);
	typedef void (APIENTRYP PFNGLDELETESHADERPROC) (GLuint shader);
	typedef void (APIENTRYP PFNGLDETACHSHADERPROC) (GLuint program, GLuint shader);
	typedef void (APIENTRYP PFNGLDISABLEVERTEXATTRIBARRAYPROC) (GLuint index);
	typedef void (APIENTRYP PFNGLENABLEVERTEXATTRIBARRAYPROC) (GLuint index);
	typedef void (APIENTRYP PFNGLGETACTIVEATTRIBPROC) (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name);
	typedef void (APIENTRYP PFNGLGETACTIVEUNIFORMPROC) (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name);
	typedef void (APIENTRYP PFNGLGETATTACHEDSHADERSPROC) (GLuint program, GLsizei maxCount, GLsizei *count, GLuint *obj);
	typedef GLint(APIENTRYP PFNGLGETATTRIBLOCATIONPROC) (GLuint program, const GLchar *name);
	typedef void (APIENTRYP PFNGLGETPROGRAMIVPROC) (GLuint program, GLenum pname, GLint *params);
	typedef void (APIENTRYP PFNGLGETPROGRAMINFOLOGPROC) (GLuint program, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
	typedef void (APIENTRYP PFNGLGETSHADERIVPROC) (GLuint shader, GLenum pname, GLint *params);
	typedef void (APIENTRYP PFNGLGETSHADERINFOLOGPROC) (GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
	typedef void (APIENTRYP PFNGLGETSHADERSOURCEPROC) (GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source);
	typedef GLint(APIENTRYP PFNGLGETUNIFORMLOCATIONPROC) (GLuint program, const GLchar *name);
	typedef void (APIENTRYP PFNGLGETUNIFORMFVPROC) (GLuint program, GLint location, GLfloat *params);
	typedef void (APIENTRYP PFNGLGETUNIFORMIVPROC) (GLuint program, GLint location, GLint *params);
	typedef void (APIENTRYP PFNGLGETVERTEXATTRIBDVPROC) (GLuint index, GLenum pname, GLdouble *params);
	typedef void (APIENTRYP PFNGLGETVERTEXATTRIBFVPROC) (GLuint index, GLenum pname, GLfloat *params);
	typedef void (APIENTRYP PFNGLGETVERTEXATTRIBIVPROC) (GLuint index, GLenum pname, GLint *params);
	typedef void (APIENTRYP PFNGLGETVERTEXATTRIBPOINTERVPROC) (GLuint index, GLenum pname, GLvoid* *pointer);
	typedef GLboolean(APIENTRYP PFNGLISPROGRAMPROC) (GLuint program);
	typedef GLboolean(APIENTRYP PFNGLISSHADERPROC) (GLuint shader);
	typedef void (APIENTRYP PFNGLLINKPROGRAMPROC) (GLuint program);
	typedef void (APIENTRYP PFNGLSHADERSOURCEPROC) (GLuint shader, GLsizei count, const GLchar* const *string, const GLint *length);
	typedef void (APIENTRYP PFNGLUSEPROGRAMPROC) (GLuint program);
	typedef void (APIENTRYP PFNGLUNIFORM1FPROC) (GLint location, GLfloat v0);
	typedef void (APIENTRYP PFNGLUNIFORM2FPROC) (GLint location, GLfloat v0, GLfloat v1);
	typedef void (APIENTRYP PFNGLUNIFORM3FPROC) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
	typedef void (APIENTRYP PFNGLUNIFORM4FPROC) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
	typedef void (APIENTRYP PFNGLUNIFORM1IPROC) (GLint location, GLint v0);
	typedef void (APIENTRYP PFNGLUNIFORM2IPROC) (GLint location, GLint v0, GLint v1);
	typedef void (APIENTRYP PFNGLUNIFORM3IPROC) (GLint location, GLint v0, GLint v1, GLint v2);
	typedef void (APIENTRYP PFNGLUNIFORM4IPROC) (GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
	typedef void (APIENTRYP PFNGLUNIFORM1FVPROC) (GLint location, GLsizei count, const GLfloat *value);
	typedef void (APIENTRYP PFNGLUNIFORM2FVPROC) (GLint location, GLsizei count, const GLfloat *value);
	typedef void (APIENTRYP PFNGLUNIFORM3FVPROC) (GLint location, GLsizei count, const GLfloat *value);
	typedef void (APIENTRYP PFNGLUNIFORM4FVPROC) (GLint location, GLsizei count, const GLfloat *value);
	typedef void (APIENTRYP PFNGLUNIFORM1IVPROC) (GLint location, GLsizei count, const GLint *value);
	typedef void (APIENTRYP PFNGLUNIFORM2IVPROC) (GLint location, GLsizei count, const GLint *value);
	typedef void (APIENTRYP PFNGLUNIFORM3IVPROC) (GLint location, GLsizei count, const GLint *value);
	typedef void (APIENTRYP PFNGLUNIFORM4IVPROC) (GLint location, GLsizei count, const GLint *value);
	typedef void (APIENTRYP PFNGLUNIFORMMATRIX2FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
	typedef void (APIENTRYP PFNGLUNIFORMMATRIX3FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
	typedef void (APIENTRYP PFNGLUNIFORMMATRIX4FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
	typedef void (APIENTRYP PFNGLVALIDATEPROGRAMPROC) (GLuint program);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB1DPROC) (GLuint index, GLdouble x);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB1DVPROC) (GLuint index, const GLdouble *v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB1FPROC) (GLuint index, GLfloat x);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB1FVPROC) (GLuint index, const GLfloat *v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB1SPROC) (GLuint index, GLshort x);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB1SVPROC) (GLuint index, const GLshort *v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB2DPROC) (GLuint index, GLdouble x, GLdouble y);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB2DVPROC) (GLuint index, const GLdouble *v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB2FPROC) (GLuint index, GLfloat x, GLfloat y);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB2FVPROC) (GLuint index, const GLfloat *v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB2SPROC) (GLuint index, GLshort x, GLshort y);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB2SVPROC) (GLuint index, const GLshort *v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB3DPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB3DVPROC) (GLuint index, const GLdouble *v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB3FPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB3FVPROC) (GLuint index, const GLfloat *v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB3SPROC) (GLuint index, GLshort x, GLshort y, GLshort z);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB3SVPROC) (GLuint index, const GLshort *v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB4NBVPROC) (GLuint index, const GLbyte *v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB4NIVPROC) (GLuint index, const GLint *v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB4NSVPROC) (GLuint index, const GLshort *v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB4NUBPROC) (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB4NUBVPROC) (GLuint index, const GLubyte *v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB4NUIVPROC) (GLuint index, const GLuint *v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB4NUSVPROC) (GLuint index, const GLushort *v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB4BVPROC) (GLuint index, const GLbyte *v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB4DPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB4DVPROC) (GLuint index, const GLdouble *v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB4FPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB4FVPROC) (GLuint index, const GLfloat *v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB4IVPROC) (GLuint index, const GLint *v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB4SPROC) (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB4SVPROC) (GLuint index, const GLshort *v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB4UBVPROC) (GLuint index, const GLubyte *v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB4UIVPROC) (GLuint index, const GLuint *v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB4USVPROC) (GLuint index, const GLushort *v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBPOINTERPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer);
#endif

#ifndef GL_VERSION_2_1
#define GL_VERSION_2_1 1
#ifdef GLCOREARB_PROTOTYPES
	GLAPI void APIENTRY glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
	GLAPI void APIENTRY glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
	GLAPI void APIENTRY glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
	GLAPI void APIENTRY glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
	GLAPI void APIENTRY glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
	GLAPI void APIENTRY glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
#endif /* GLCOREARB_PROTOTYPES */
	typedef void (APIENTRYP PFNGLUNIFORMMATRIX2X3FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
	typedef void (APIENTRYP PFNGLUNIFORMMATRIX3X2FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
	typedef void (APIENTRYP PFNGLUNIFORMMATRIX2X4FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
	typedef void (APIENTRYP PFNGLUNIFORMMATRIX4X2FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
	typedef void (APIENTRYP PFNGLUNIFORMMATRIX3X4FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
	typedef void (APIENTRYP PFNGLUNIFORMMATRIX4X3FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
#endif

#ifndef GL_VERSION_3_0
#define GL_VERSION_3_0 1
	/* OpenGL 3.0 also reuses entry points from these extensions: */
	/* ARB_framebuffer_object */
	/* ARB_map_buffer_range */
	/* ARB_vertex_array_object */
#ifdef GLCOREARB_PROTOTYPES
	GLAPI void APIENTRY glColorMaski(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a);
	GLAPI void APIENTRY glGetBooleani_v(GLenum target, GLuint index, GLboolean *data);
	GLAPI void APIENTRY glGetIntegeri_v(GLenum target, GLuint index, GLint *data);
	GLAPI void APIENTRY glEnablei(GLenum target, GLuint index);
	GLAPI void APIENTRY glDisablei(GLenum target, GLuint index);
	GLAPI GLboolean APIENTRY glIsEnabledi(GLenum target, GLuint index);
	GLAPI void APIENTRY glBeginTransformFeedback(GLenum primitiveMode);
	GLAPI void APIENTRY glEndTransformFeedback(void);
	GLAPI void APIENTRY glBindBufferRange(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
	GLAPI void APIENTRY glBindBufferBase(GLenum target, GLuint index, GLuint buffer);
	GLAPI void APIENTRY glTransformFeedbackVaryings(GLuint program, GLsizei count, const GLchar* const *varyings, GLenum bufferMode);
	GLAPI void APIENTRY glGetTransformFeedbackVarying(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name);
	GLAPI void APIENTRY glClampColor(GLenum target, GLenum clamp);
	GLAPI void APIENTRY glBeginConditionalRender(GLuint id, GLenum mode);
	GLAPI void APIENTRY glEndConditionalRender(void);
	GLAPI void APIENTRY glVertexAttribIPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
	GLAPI void APIENTRY glGetVertexAttribIiv(GLuint index, GLenum pname, GLint *params);
	GLAPI void APIENTRY glGetVertexAttribIuiv(GLuint index, GLenum pname, GLuint *params);
	GLAPI void APIENTRY glVertexAttribI1i(GLuint index, GLint x);
	GLAPI void APIENTRY glVertexAttribI2i(GLuint index, GLint x, GLint y);
	GLAPI void APIENTRY glVertexAttribI3i(GLuint index, GLint x, GLint y, GLint z);
	GLAPI void APIENTRY glVertexAttribI4i(GLuint index, GLint x, GLint y, GLint z, GLint w);
	GLAPI void APIENTRY glVertexAttribI1ui(GLuint index, GLuint x);
	GLAPI void APIENTRY glVertexAttribI2ui(GLuint index, GLuint x, GLuint y);
	GLAPI void APIENTRY glVertexAttribI3ui(GLuint index, GLuint x, GLuint y, GLuint z);
	GLAPI void APIENTRY glVertexAttribI4ui(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
	GLAPI void APIENTRY glVertexAttribI1iv(GLuint index, const GLint *v);
	GLAPI void APIENTRY glVertexAttribI2iv(GLuint index, const GLint *v);
	GLAPI void APIENTRY glVertexAttribI3iv(GLuint index, const GLint *v);
	GLAPI void APIENTRY glVertexAttribI4iv(GLuint index, const GLint *v);
	GLAPI void APIENTRY glVertexAttribI1uiv(GLuint index, const GLuint *v);
	GLAPI void APIENTRY glVertexAttribI2uiv(GLuint index, const GLuint *v);
	GLAPI void APIENTRY glVertexAttribI3uiv(GLuint index, const GLuint *v);
	GLAPI void APIENTRY glVertexAttribI4uiv(GLuint index, const GLuint *v);
	GLAPI void APIENTRY glVertexAttribI4bv(GLuint index, const GLbyte *v);
	GLAPI void APIENTRY glVertexAttribI4sv(GLuint index, const GLshort *v);
	GLAPI void APIENTRY glVertexAttribI4ubv(GLuint index, const GLubyte *v);
	GLAPI void APIENTRY glVertexAttribI4usv(GLuint index, const GLushort *v);
	GLAPI void APIENTRY glGetUniformuiv(GLuint program, GLint location, GLuint *params);
	GLAPI void APIENTRY glBindFragDataLocation(GLuint program, GLuint color, const GLchar *name);
	GLAPI GLint APIENTRY glGetFragDataLocation(GLuint program, const GLchar *name);
	GLAPI void APIENTRY glUniform1ui(GLint location, GLuint v0);
	GLAPI void APIENTRY glUniform2ui(GLint location, GLuint v0, GLuint v1);
	GLAPI void APIENTRY glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2);
	GLAPI void APIENTRY glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
	GLAPI void APIENTRY glUniform1uiv(GLint location, GLsizei count, const GLuint *value);
	GLAPI void APIENTRY glUniform2uiv(GLint location, GLsizei count, const GLuint *value);
	GLAPI void APIENTRY glUniform3uiv(GLint location, GLsizei count, const GLuint *value);
	GLAPI void APIENTRY glUniform4uiv(GLint location, GLsizei count, const GLuint *value);
	GLAPI void APIENTRY glTexParameterIiv(GLenum target, GLenum pname, const GLint *params);
	GLAPI void APIENTRY glTexParameterIuiv(GLenum target, GLenum pname, const GLuint *params);
	GLAPI void APIENTRY glGetTexParameterIiv(GLenum target, GLenum pname, GLint *params);
	GLAPI void APIENTRY glGetTexParameterIuiv(GLenum target, GLenum pname, GLuint *params);
	GLAPI void APIENTRY glClearBufferiv(GLenum buffer, GLint drawbuffer, const GLint *value);
	GLAPI void APIENTRY glClearBufferuiv(GLenum buffer, GLint drawbuffer, const GLuint *value);
	GLAPI void APIENTRY glClearBufferfv(GLenum buffer, GLint drawbuffer, const GLfloat *value);
	GLAPI void APIENTRY glClearBufferfi(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil);
	GLAPI const GLubyte * APIENTRY glGetStringi(GLenum name, GLuint index);
#endif /* GLCOREARB_PROTOTYPES */
	typedef void (APIENTRYP PFNGLCOLORMASKIPROC) (GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a);
	typedef void (APIENTRYP PFNGLGETBOOLEANI_VPROC) (GLenum target, GLuint index, GLboolean *data);
	typedef void (APIENTRYP PFNGLGETINTEGERI_VPROC) (GLenum target, GLuint index, GLint *data);
	typedef void (APIENTRYP PFNGLENABLEIPROC) (GLenum target, GLuint index);
	typedef void (APIENTRYP PFNGLDISABLEIPROC) (GLenum target, GLuint index);
	typedef GLboolean(APIENTRYP PFNGLISENABLEDIPROC) (GLenum target, GLuint index);
	typedef void (APIENTRYP PFNGLBEGINTRANSFORMFEEDBACKPROC) (GLenum primitiveMode);
	typedef void (APIENTRYP PFNGLENDTRANSFORMFEEDBACKPROC) (void);
	typedef void (APIENTRYP PFNGLBINDBUFFERRANGEPROC) (GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
	typedef void (APIENTRYP PFNGLBINDBUFFERBASEPROC) (GLenum target, GLuint index, GLuint buffer);
	typedef void (APIENTRYP PFNGLTRANSFORMFEEDBACKVARYINGSPROC) (GLuint program, GLsizei count, const GLchar* const *varyings, GLenum bufferMode);
	typedef void (APIENTRYP PFNGLGETTRANSFORMFEEDBACKVARYINGPROC) (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name);
	typedef void (APIENTRYP PFNGLCLAMPCOLORPROC) (GLenum target, GLenum clamp);
	typedef void (APIENTRYP PFNGLBEGINCONDITIONALRENDERPROC) (GLuint id, GLenum mode);
	typedef void (APIENTRYP PFNGLENDCONDITIONALRENDERPROC) (void);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBIPOINTERPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
	typedef void (APIENTRYP PFNGLGETVERTEXATTRIBIIVPROC) (GLuint index, GLenum pname, GLint *params);
	typedef void (APIENTRYP PFNGLGETVERTEXATTRIBIUIVPROC) (GLuint index, GLenum pname, GLuint *params);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBI1IPROC) (GLuint index, GLint x);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBI2IPROC) (GLuint index, GLint x, GLint y);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBI3IPROC) (GLuint index, GLint x, GLint y, GLint z);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBI4IPROC) (GLuint index, GLint x, GLint y, GLint z, GLint w);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBI1UIPROC) (GLuint index, GLuint x);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBI2UIPROC) (GLuint index, GLuint x, GLuint y);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBI3UIPROC) (GLuint index, GLuint x, GLuint y, GLuint z);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBI4UIPROC) (GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBI1IVPROC) (GLuint index, const GLint *v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBI2IVPROC) (GLuint index, const GLint *v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBI3IVPROC) (GLuint index, const GLint *v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBI4IVPROC) (GLuint index, const GLint *v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBI1UIVPROC) (GLuint index, const GLuint *v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBI2UIVPROC) (GLuint index, const GLuint *v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBI3UIVPROC) (GLuint index, const GLuint *v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBI4UIVPROC) (GLuint index, const GLuint *v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBI4BVPROC) (GLuint index, const GLbyte *v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBI4SVPROC) (GLuint index, const GLshort *v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBI4UBVPROC) (GLuint index, const GLubyte *v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBI4USVPROC) (GLuint index, const GLushort *v);
	typedef void (APIENTRYP PFNGLGETUNIFORMUIVPROC) (GLuint program, GLint location, GLuint *params);
	typedef void (APIENTRYP PFNGLBINDFRAGDATALOCATIONPROC) (GLuint program, GLuint color, const GLchar *name);
	typedef GLint(APIENTRYP PFNGLGETFRAGDATALOCATIONPROC) (GLuint program, const GLchar *name);
	typedef void (APIENTRYP PFNGLUNIFORM1UIPROC) (GLint location, GLuint v0);
	typedef void (APIENTRYP PFNGLUNIFORM2UIPROC) (GLint location, GLuint v0, GLuint v1);
	typedef void (APIENTRYP PFNGLUNIFORM3UIPROC) (GLint location, GLuint v0, GLuint v1, GLuint v2);
	typedef void (APIENTRYP PFNGLUNIFORM4UIPROC) (GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
	typedef void (APIENTRYP PFNGLUNIFORM1UIVPROC) (GLint location, GLsizei count, const GLuint *value);
	typedef void (APIENTRYP PFNGLUNIFORM2UIVPROC) (GLint location, GLsizei count, const GLuint *value);
	typedef void (APIENTRYP PFNGLUNIFORM3UIVPROC) (GLint location, GLsizei count, const GLuint *value);
	typedef void (APIENTRYP PFNGLUNIFORM4UIVPROC) (GLint location, GLsizei count, const GLuint *value);
	typedef void (APIENTRYP PFNGLTEXPARAMETERIIVPROC) (GLenum target, GLenum pname, const GLint *params);
	typedef void (APIENTRYP PFNGLTEXPARAMETERIUIVPROC) (GLenum target, GLenum pname, const GLuint *params);
	typedef void (APIENTRYP PFNGLGETTEXPARAMETERIIVPROC) (GLenum target, GLenum pname, GLint *params);
	typedef void (APIENTRYP PFNGLGETTEXPARAMETERIUIVPROC) (GLenum target, GLenum pname, GLuint *params);
	typedef void (APIENTRYP PFNGLCLEARBUFFERIVPROC) (GLenum buffer, GLint drawbuffer, const GLint *value);
	typedef void (APIENTRYP PFNGLCLEARBUFFERUIVPROC) (GLenum buffer, GLint drawbuffer, const GLuint *value);
	typedef void (APIENTRYP PFNGLCLEARBUFFERFVPROC) (GLenum buffer, GLint drawbuffer, const GLfloat *value);
	typedef void (APIENTRYP PFNGLCLEARBUFFERFIPROC) (GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil);
	typedef const GLubyte * (APIENTRYP PFNGLGETSTRINGIPROC) (GLenum name, GLuint index);
#endif

#ifndef GL_VERSION_3_1
#define GL_VERSION_3_1 1
	/* OpenGL 3.1 also reuses entry points from these extensions: */
	/* ARB_copy_buffer */
	/* ARB_uniform_buffer_object */
#ifdef GLCOREARB_PROTOTYPES
	GLAPI void APIENTRY glDrawArraysInstanced(GLenum mode, GLint first, GLsizei count, GLsizei instancecount);
	GLAPI void APIENTRY glDrawElementsInstanced(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei instancecount);
	GLAPI void APIENTRY glTexBuffer(GLenum target, GLenum internalformat, GLuint buffer);
	GLAPI void APIENTRY glPrimitiveRestartIndex(GLuint index);
#endif /* GLCOREARB_PROTOTYPES */
	typedef void (APIENTRYP PFNGLDRAWARRAYSINSTANCEDPROC) (GLenum mode, GLint first, GLsizei count, GLsizei instancecount);
	typedef void (APIENTRYP PFNGLDRAWELEMENTSINSTANCEDPROC) (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei instancecount);
	typedef void (APIENTRYP PFNGLTEXBUFFERPROC) (GLenum target, GLenum internalformat, GLuint buffer);
	typedef void (APIENTRYP PFNGLPRIMITIVERESTARTINDEXPROC) (GLuint index);
#endif

#ifndef GL_VERSION_3_2
#define GL_VERSION_3_2 1
	/* OpenGL 3.2 also reuses entry points from these extensions: */
	/* ARB_draw_elements_base_vertex */
	/* ARB_provoking_vertex */
	/* ARB_sync */
	/* ARB_texture_multisample */
#ifdef GLCOREARB_PROTOTYPES
	GLAPI void APIENTRY glGetInteger64i_v(GLenum target, GLuint index, GLint64 *data);
	GLAPI void APIENTRY glGetBufferParameteri64v(GLenum target, GLenum pname, GLint64 *params);
	GLAPI void APIENTRY glFramebufferTexture(GLenum target, GLenum attachment, GLuint texture, GLint level);
#endif /* GLCOREARB_PROTOTYPES */
	typedef void (APIENTRYP PFNGLGETINTEGER64I_VPROC) (GLenum target, GLuint index, GLint64 *data);
	typedef void (APIENTRYP PFNGLGETBUFFERPARAMETERI64VPROC) (GLenum target, GLenum pname, GLint64 *params);
	typedef void (APIENTRYP PFNGLFRAMEBUFFERTEXTUREPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level);
#endif

#ifndef GL_VERSION_3_3
#define GL_VERSION_3_3 1
	/* OpenGL 3.3 also reuses entry points from these extensions: */
	/* ARB_blend_func_extended */
	/* ARB_sampler_objects */
	/* ARB_explicit_attrib_location, but it has none */
	/* ARB_occlusion_query2 (no entry points) */
	/* ARB_shader_bit_encoding (no entry points) */
	/* ARB_texture_rgb10_a2ui (no entry points) */
	/* ARB_texture_swizzle (no entry points) */
	/* ARB_timer_query */
	/* ARB_vertex_type_2_10_10_10_rev */
#ifdef GLCOREARB_PROTOTYPES
	GLAPI void APIENTRY glVertexAttribDivisor(GLuint index, GLuint divisor);
#endif /* GLCOREARB_PROTOTYPES */
	typedef void (APIENTRYP PFNGLVERTEXATTRIBDIVISORPROC) (GLuint index, GLuint divisor);
#endif

#ifndef GL_VERSION_4_0
#define GL_VERSION_4_0 1
	/* OpenGL 4.0 also reuses entry points from these extensions: */
	/* ARB_texture_query_lod (no entry points) */
	/* ARB_draw_indirect */
	/* ARB_gpu_shader5 (no entry points) */
	/* ARB_gpu_shader_fp64 */
	/* ARB_shader_subroutine */
	/* ARB_tessellation_shader */
	/* ARB_texture_buffer_object_rgb32 (no entry points) */
	/* ARB_texture_cube_map_array (no entry points) */
	/* ARB_texture_gather (no entry points) */
	/* ARB_transform_feedback2 */
	/* ARB_transform_feedback3 */
#ifdef GLCOREARB_PROTOTYPES
	GLAPI void APIENTRY glMinSampleShading(GLfloat value);
	GLAPI void APIENTRY glBlendEquationi(GLuint buf, GLenum mode);
	GLAPI void APIENTRY glBlendEquationSeparatei(GLuint buf, GLenum modeRGB, GLenum modeAlpha);
	GLAPI void APIENTRY glBlendFunci(GLuint buf, GLenum src, GLenum dst);
	GLAPI void APIENTRY glBlendFuncSeparatei(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
#endif /* GLCOREARB_PROTOTYPES */
	typedef void (APIENTRYP PFNGLMINSAMPLESHADINGPROC) (GLfloat value);
	typedef void (APIENTRYP PFNGLBLENDEQUATIONIPROC) (GLuint buf, GLenum mode);
	typedef void (APIENTRYP PFNGLBLENDEQUATIONSEPARATEIPROC) (GLuint buf, GLenum modeRGB, GLenum modeAlpha);
	typedef void (APIENTRYP PFNGLBLENDFUNCIPROC) (GLuint buf, GLenum src, GLenum dst);
	typedef void (APIENTRYP PFNGLBLENDFUNCSEPARATEIPROC) (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
#endif

#ifndef GL_VERSION_4_1
#define GL_VERSION_4_1 1
	/* OpenGL 4.1 reuses entry points from these extensions: */
	/* ARB_ES2_compatibility */
	/* ARB_get_program_binary */
	/* ARB_separate_shader_objects */
	/* ARB_shader_precision (no entry points) */
	/* ARB_vertex_attrib_64bit */
	/* ARB_viewport_array */
#endif

#ifndef GL_VERSION_4_2
#define GL_VERSION_4_2 1
/* OpenGL 4.2 reuses entry points from these extensions: */
/* ARB_base_instance */
/* ARB_shading_language_420pack (no entry points) */
/* ARB_transform_feedback_instanced */
/* ARB_compressed_texture_pixel_storage (no entry points) */
/* ARB_conservative_depth (no entry points) */
/* ARB_internalformat_query */
/* ARB_map_buffer_alignment (no entry points) */
/* ARB_shader_atomic_counters */
/* ARB_shader_image_load_store */
/* ARB_shading_language_packing (no entry points) */
/* ARB_texture_storage */
#endif

#ifndef GL_VERSION_4_3
#define GL_VERSION_4_3 1
/* OpenGL 4.3 reuses entry points from these extensions: */
/* ARB_arrays_of_arrays (no entry points, GLSL only) */
/* ARB_fragment_layer_viewport (no entry points, GLSL only) */
/* ARB_shader_image_size (no entry points, GLSL only) */
/* ARB_ES3_compatibility (no entry points) */
/* ARB_clear_buffer_object */
/* ARB_compute_shader */
/* ARB_copy_image */
/* KHR_debug (includes ARB_debug_output commands promoted to KHR without suffixes) */
/* ARB_explicit_uniform_location (no entry points) */
/* ARB_framebuffer_no_attachments */
/* ARB_internalformat_query2 */
/* ARB_invalidate_subdata */
/* ARB_multi_draw_indirect */
/* ARB_program_interface_query */
/* ARB_robust_buffer_access_behavior (no entry points) */
/* ARB_shader_storage_buffer_object */
/* ARB_stencil_texturing (no entry points) */
/* ARB_texture_buffer_range */
/* ARB_texture_query_levels (no entry points) */
/* ARB_texture_storage_multisample */
/* ARB_texture_view */
/* ARB_vertex_attrib_binding */
#endif

#ifndef GL_ARB_depth_buffer_float
#define GL_ARB_depth_buffer_float 1
#endif

#ifndef GL_ARB_framebuffer_object
#define GL_ARB_framebuffer_object 1
#ifdef GLCOREARB_PROTOTYPES
	GLAPI GLboolean APIENTRY glIsRenderbuffer(GLuint renderbuffer);
	GLAPI void APIENTRY glBindRenderbuffer(GLenum target, GLuint renderbuffer);
	GLAPI void APIENTRY glDeleteRenderbuffers(GLsizei n, const GLuint *renderbuffers);
	GLAPI void APIENTRY glGenRenderbuffers(GLsizei n, GLuint *renderbuffers);
	GLAPI void APIENTRY glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
	GLAPI void APIENTRY glGetRenderbufferParameteriv(GLenum target, GLenum pname, GLint *params);
	GLAPI GLboolean APIENTRY glIsFramebuffer(GLuint framebuffer);
	GLAPI void APIENTRY glBindFramebuffer(GLenum target, GLuint framebuffer);
	GLAPI void APIENTRY glDeleteFramebuffers(GLsizei n, const GLuint *framebuffers);
	GLAPI void APIENTRY glGenFramebuffers(GLsizei n, GLuint *framebuffers);
	GLAPI GLenum APIENTRY glCheckFramebufferStatus(GLenum target);
	GLAPI void APIENTRY glFramebufferTexture1D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
	GLAPI void APIENTRY glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
	GLAPI void APIENTRY glFramebufferTexture3D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
	GLAPI void APIENTRY glFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
	GLAPI void APIENTRY glGetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment, GLenum pname, GLint *params);
	GLAPI void APIENTRY glGenerateMipmap(GLenum target);
	GLAPI void APIENTRY glBlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
	GLAPI void APIENTRY glRenderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
	GLAPI void APIENTRY glFramebufferTextureLayer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
#endif /* GLCOREARB_PROTOTYPES */
	typedef GLboolean(APIENTRYP PFNGLISRENDERBUFFERPROC) (GLuint renderbuffer);
	typedef void (APIENTRYP PFNGLBINDRENDERBUFFERPROC) (GLenum target, GLuint renderbuffer);
	typedef void (APIENTRYP PFNGLDELETERENDERBUFFERSPROC) (GLsizei n, const GLuint *renderbuffers);
	typedef void (APIENTRYP PFNGLGENRENDERBUFFERSPROC) (GLsizei n, GLuint *renderbuffers);
	typedef void (APIENTRYP PFNGLRENDERBUFFERSTORAGEPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
	typedef void (APIENTRYP PFNGLGETRENDERBUFFERPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
	typedef GLboolean(APIENTRYP PFNGLISFRAMEBUFFERPROC) (GLuint framebuffer);
	typedef void (APIENTRYP PFNGLBINDFRAMEBUFFERPROC) (GLenum target, GLuint framebuffer);
	typedef void (APIENTRYP PFNGLDELETEFRAMEBUFFERSPROC) (GLsizei n, const GLuint *framebuffers);
	typedef void (APIENTRYP PFNGLGENFRAMEBUFFERSPROC) (GLsizei n, GLuint *framebuffers);
	typedef GLenum(APIENTRYP PFNGLCHECKFRAMEBUFFERSTATUSPROC) (GLenum target);
	typedef void (APIENTRYP PFNGLFRAMEBUFFERTEXTURE1DPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
	typedef void (APIENTRYP PFNGLFRAMEBUFFERTEXTURE2DPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
	typedef void (APIENTRYP PFNGLFRAMEBUFFERTEXTURE3DPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
	typedef void (APIENTRYP PFNGLFRAMEBUFFERRENDERBUFFERPROC) (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
	typedef void (APIENTRYP PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC) (GLenum target, GLenum attachment, GLenum pname, GLint *params);
	typedef void (APIENTRYP PFNGLGENERATEMIPMAPPROC) (GLenum target);
	typedef void (APIENTRYP PFNGLBLITFRAMEBUFFERPROC) (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
	typedef void (APIENTRYP PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
	typedef void (APIENTRYP PFNGLFRAMEBUFFERTEXTURELAYERPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
#endif

#ifndef GL_ARB_framebuffer_sRGB
#define GL_ARB_framebuffer_sRGB 1
#endif

#ifndef GL_ARB_half_float_vertex
#define GL_ARB_half_float_vertex 1
#endif

#ifndef GL_ARB_map_buffer_range
#define GL_ARB_map_buffer_range 1
#ifdef GLCOREARB_PROTOTYPES
	GLAPI GLvoid* APIENTRY glMapBufferRange(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);
	GLAPI void APIENTRY glFlushMappedBufferRange(GLenum target, GLintptr offset, GLsizeiptr length);
#endif /* GLCOREARB_PROTOTYPES */
	typedef GLvoid* (APIENTRYP PFNGLMAPBUFFERRANGEPROC) (GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);
	typedef void (APIENTRYP PFNGLFLUSHMAPPEDBUFFERRANGEPROC) (GLenum target, GLintptr offset, GLsizeiptr length);
#endif

#ifndef GL_ARB_texture_compression_rgtc
#define GL_ARB_texture_compression_rgtc 1
#endif

#ifndef GL_ARB_texture_rg
#define GL_ARB_texture_rg 1
#endif

#ifndef GL_ARB_vertex_array_object
#define GL_ARB_vertex_array_object 1
#ifdef GLCOREARB_PROTOTYPES
	GLAPI void APIENTRY glBindVertexArray(GLuint array);
	GLAPI void APIENTRY glDeleteVertexArrays(GLsizei n, const GLuint *arrays);
	GLAPI void APIENTRY glGenVertexArrays(GLsizei n, GLuint *arrays);
	GLAPI GLboolean APIENTRY glIsVertexArray(GLuint array);
#endif /* GLCOREARB_PROTOTYPES */
	typedef void (APIENTRYP PFNGLBINDVERTEXARRAYPROC) (GLuint array);
	typedef void (APIENTRYP PFNGLDELETEVERTEXARRAYSPROC) (GLsizei n, const GLuint *arrays);
	typedef void (APIENTRYP PFNGLGENVERTEXARRAYSPROC) (GLsizei n, GLuint *arrays);
	typedef GLboolean(APIENTRYP PFNGLISVERTEXARRAYPROC) (GLuint array);
#endif

#ifndef GL_ARB_uniform_buffer_object
#define GL_ARB_uniform_buffer_object 1
#ifdef GLCOREARB_PROTOTYPES
	GLAPI void APIENTRY glGetUniformIndices(GLuint program, GLsizei uniformCount, const GLchar* const *uniformNames, GLuint *uniformIndices);
	GLAPI void APIENTRY glGetActiveUniformsiv(GLuint program, GLsizei uniformCount, const GLuint *uniformIndices, GLenum pname, GLint *params);
	GLAPI void APIENTRY glGetActiveUniformName(GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformName);
	GLAPI GLuint APIENTRY glGetUniformBlockIndex(GLuint program, const GLchar *uniformBlockName);
	GLAPI void APIENTRY glGetActiveUniformBlockiv(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *params);
	GLAPI void APIENTRY glGetActiveUniformBlockName(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformBlockName);
	GLAPI void APIENTRY glUniformBlockBinding(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding);
#endif /* GLCOREARB_PROTOTYPES */
	typedef void (APIENTRYP PFNGLGETUNIFORMINDICESPROC) (GLuint program, GLsizei uniformCount, const GLchar* const *uniformNames, GLuint *uniformIndices);
	typedef void (APIENTRYP PFNGLGETACTIVEUNIFORMSIVPROC) (GLuint program, GLsizei uniformCount, const GLuint *uniformIndices, GLenum pname, GLint *params);
	typedef void (APIENTRYP PFNGLGETACTIVEUNIFORMNAMEPROC) (GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformName);
	typedef GLuint(APIENTRYP PFNGLGETUNIFORMBLOCKINDEXPROC) (GLuint program, const GLchar *uniformBlockName);
	typedef void (APIENTRYP PFNGLGETACTIVEUNIFORMBLOCKIVPROC) (GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *params);
	typedef void (APIENTRYP PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC) (GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformBlockName);
	typedef void (APIENTRYP PFNGLUNIFORMBLOCKBINDINGPROC) (GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding);
#endif

#ifndef GL_ARB_copy_buffer
#define GL_ARB_copy_buffer 1
#ifdef GLCOREARB_PROTOTYPES
	GLAPI void APIENTRY glCopyBufferSubData(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
#endif /* GLCOREARB_PROTOTYPES */
	typedef void (APIENTRYP PFNGLCOPYBUFFERSUBDATAPROC) (GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
#endif

#ifndef GL_ARB_depth_clamp
#define GL_ARB_depth_clamp 1
#endif

#ifndef GL_ARB_draw_elements_base_vertex
#define GL_ARB_draw_elements_base_vertex 1
#ifdef GLCOREARB_PROTOTYPES
	GLAPI void APIENTRY glDrawElementsBaseVertex(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLint basevertex);
	GLAPI void APIENTRY glDrawRangeElementsBaseVertex(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices, GLint basevertex);
	GLAPI void APIENTRY glDrawElementsInstancedBaseVertex(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei instancecount, GLint basevertex);
	GLAPI void APIENTRY glMultiDrawElementsBaseVertex(GLenum mode, const GLsizei *count, GLenum type, const GLvoid* const *indices, GLsizei drawcount, const GLint *basevertex);
#endif /* GLCOREARB_PROTOTYPES */
	typedef void (APIENTRYP PFNGLDRAWELEMENTSBASEVERTEXPROC) (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLint basevertex);
	typedef void (APIENTRYP PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices, GLint basevertex);
	typedef void (APIENTRYP PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC) (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei instancecount, GLint basevertex);
	typedef void (APIENTRYP PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC) (GLenum mode, const GLsizei *count, GLenum type, const GLvoid* const *indices, GLsizei drawcount, const GLint *basevertex);
#endif

#ifndef GL_ARB_fragment_coord_conventions
#define GL_ARB_fragment_coord_conventions 1
#endif

#ifndef GL_ARB_provoking_vertex
#define GL_ARB_provoking_vertex 1
#ifdef GLCOREARB_PROTOTYPES
	GLAPI void APIENTRY glProvokingVertex(GLenum mode);
#endif /* GLCOREARB_PROTOTYPES */
	typedef void (APIENTRYP PFNGLPROVOKINGVERTEXPROC) (GLenum mode);
#endif

#ifndef GL_ARB_seamless_cube_map
#define GL_ARB_seamless_cube_map 1
#endif

#ifndef GL_ARB_sync
#define GL_ARB_sync 1
#ifdef GLCOREARB_PROTOTYPES
	GLAPI GLsync APIENTRY glFenceSync(GLenum condition, GLbitfield flags);
	GLAPI GLboolean APIENTRY glIsSync(GLsync sync);
	GLAPI void APIENTRY glDeleteSync(GLsync sync);
	GLAPI GLenum APIENTRY glClientWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout);
	GLAPI void APIENTRY glWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout);
	GLAPI void APIENTRY glGetInteger64v(GLenum pname, GLint64 *params);
	GLAPI void APIENTRY glGetSynciv(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values);
#endif /* GLCOREARB_PROTOTYPES */
	typedef GLsync(APIENTRYP PFNGLFENCESYNCPROC) (GLenum condition, GLbitfield flags);
	typedef GLboolean(APIENTRYP PFNGLISSYNCPROC) (GLsync sync);
	typedef void (APIENTRYP PFNGLDELETESYNCPROC) (GLsync sync);
	typedef GLenum(APIENTRYP PFNGLCLIENTWAITSYNCPROC) (GLsync sync, GLbitfield flags, GLuint64 timeout);
	typedef void (APIENTRYP PFNGLWAITSYNCPROC) (GLsync sync, GLbitfield flags, GLuint64 timeout);
	typedef void (APIENTRYP PFNGLGETINTEGER64VPROC) (GLenum pname, GLint64 *params);
	typedef void (APIENTRYP PFNGLGETSYNCIVPROC) (GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values);
#endif

#ifndef GL_ARB_texture_multisample
#define GL_ARB_texture_multisample 1
#ifdef GLCOREARB_PROTOTYPES
	GLAPI void APIENTRY glTexImage2DMultisample(GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
	GLAPI void APIENTRY glTexImage3DMultisample(GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
	GLAPI void APIENTRY glGetMultisamplefv(GLenum pname, GLuint index, GLfloat *val);
	GLAPI void APIENTRY glSampleMaski(GLuint index, GLbitfield mask);
#endif /* GLCOREARB_PROTOTYPES */
	typedef void (APIENTRYP PFNGLTEXIMAGE2DMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
	typedef void (APIENTRYP PFNGLTEXIMAGE3DMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
	typedef void (APIENTRYP PFNGLGETMULTISAMPLEFVPROC) (GLenum pname, GLuint index, GLfloat *val);
	typedef void (APIENTRYP PFNGLSAMPLEMASKIPROC) (GLuint index, GLbitfield mask);
#endif

#ifndef GL_ARB_vertex_array_bgra
#define GL_ARB_vertex_array_bgra 1
#endif

#ifndef GL_ARB_draw_buffers_blend
#define GL_ARB_draw_buffers_blend 1
#ifdef GLCOREARB_PROTOTYPES
	GLAPI void APIENTRY glBlendEquationiARB(GLuint buf, GLenum mode);
	GLAPI void APIENTRY glBlendEquationSeparateiARB(GLuint buf, GLenum modeRGB, GLenum modeAlpha);
	GLAPI void APIENTRY glBlendFunciARB(GLuint buf, GLenum src, GLenum dst);
	GLAPI void APIENTRY glBlendFuncSeparateiARB(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
#endif /* GLCOREARB_PROTOTYPES */
	typedef void (APIENTRYP PFNGLBLENDEQUATIONIARBPROC) (GLuint buf, GLenum mode);
	typedef void (APIENTRYP PFNGLBLENDEQUATIONSEPARATEIARBPROC) (GLuint buf, GLenum modeRGB, GLenum modeAlpha);
	typedef void (APIENTRYP PFNGLBLENDFUNCIARBPROC) (GLuint buf, GLenum src, GLenum dst);
	typedef void (APIENTRYP PFNGLBLENDFUNCSEPARATEIARBPROC) (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
#endif

#ifndef GL_ARB_sample_shading
#define GL_ARB_sample_shading 1
#ifdef GLCOREARB_PROTOTYPES
	GLAPI void APIENTRY glMinSampleShadingARB(GLfloat value);
#endif /* GLCOREARB_PROTOTYPES */
	typedef void (APIENTRYP PFNGLMINSAMPLESHADINGARBPROC) (GLfloat value);
#endif

#ifndef GL_ARB_texture_cube_map_array
#define GL_ARB_texture_cube_map_array 1
#endif

#ifndef GL_ARB_texture_gather
#define GL_ARB_texture_gather 1
#endif

#ifndef GL_ARB_texture_query_lod
#define GL_ARB_texture_query_lod 1
#endif

#ifndef GL_ARB_shading_language_include
#define GL_ARB_shading_language_include 1
#ifdef GLCOREARB_PROTOTYPES
	GLAPI void APIENTRY glNamedStringARB(GLenum type, GLint namelen, const GLchar *name, GLint stringlen, const GLchar *string);
	GLAPI void APIENTRY glDeleteNamedStringARB(GLint namelen, const GLchar *name);
	GLAPI void APIENTRY glCompileShaderIncludeARB(GLuint shader, GLsizei count, const GLchar* *path, const GLint *length);
	GLAPI GLboolean APIENTRY glIsNamedStringARB(GLint namelen, const GLchar *name);
	GLAPI void APIENTRY glGetNamedStringARB(GLint namelen, const GLchar *name, GLsizei bufSize, GLint *stringlen, GLchar *string);
	GLAPI void APIENTRY glGetNamedStringivARB(GLint namelen, const GLchar *name, GLenum pname, GLint *params);
#endif /* GLCOREARB_PROTOTYPES */
	typedef void (APIENTRYP PFNGLNAMEDSTRINGARBPROC) (GLenum type, GLint namelen, const GLchar *name, GLint stringlen, const GLchar *string);
	typedef void (APIENTRYP PFNGLDELETENAMEDSTRINGARBPROC) (GLint namelen, const GLchar *name);
	typedef void (APIENTRYP PFNGLCOMPILESHADERINCLUDEARBPROC) (GLuint shader, GLsizei count, const GLchar* *path, const GLint *length);
	typedef GLboolean(APIENTRYP PFNGLISNAMEDSTRINGARBPROC) (GLint namelen, const GLchar *name);
	typedef void (APIENTRYP PFNGLGETNAMEDSTRINGARBPROC) (GLint namelen, const GLchar *name, GLsizei bufSize, GLint *stringlen, GLchar *string);
	typedef void (APIENTRYP PFNGLGETNAMEDSTRINGIVARBPROC) (GLint namelen, const GLchar *name, GLenum pname, GLint *params);
#endif

#ifndef GL_ARB_texture_compression_bptc
#define GL_ARB_texture_compression_bptc 1
#endif

#ifndef GL_ARB_blend_func_extended
#define GL_ARB_blend_func_extended 1
#ifdef GLCOREARB_PROTOTYPES
	GLAPI void APIENTRY glBindFragDataLocationIndexed(GLuint program, GLuint colorNumber, GLuint index, const GLchar *name);
	GLAPI GLint APIENTRY glGetFragDataIndex(GLuint program, const GLchar *name);
#endif /* GLCOREARB_PROTOTYPES */
	typedef void (APIENTRYP PFNGLBINDFRAGDATALOCATIONINDEXEDPROC) (GLuint program, GLuint colorNumber, GLuint index, const GLchar *name);
	typedef GLint(APIENTRYP PFNGLGETFRAGDATAINDEXPROC) (GLuint program, const GLchar *name);
#endif

#ifndef GL_ARB_explicit_attrib_location
#define GL_ARB_explicit_attrib_location 1
#endif

#ifndef GL_ARB_occlusion_query2
#define GL_ARB_occlusion_query2 1
#endif

#ifndef GL_ARB_sampler_objects
#define GL_ARB_sampler_objects 1
#ifdef GLCOREARB_PROTOTYPES
	GLAPI void APIENTRY glGenSamplers(GLsizei count, GLuint *samplers);
	GLAPI void APIENTRY glDeleteSamplers(GLsizei count, const GLuint *samplers);
	GLAPI GLboolean APIENTRY glIsSampler(GLuint sampler);
	GLAPI void APIENTRY glBindSampler(GLuint unit, GLuint sampler);
	GLAPI void APIENTRY glSamplerParameteri(GLuint sampler, GLenum pname, GLint param);
	GLAPI void APIENTRY glSamplerParameteriv(GLuint sampler, GLenum pname, const GLint *param);
	GLAPI void APIENTRY glSamplerParameterf(GLuint sampler, GLenum pname, GLfloat param);
	GLAPI void APIENTRY glSamplerParameterfv(GLuint sampler, GLenum pname, const GLfloat *param);
	GLAPI void APIENTRY glSamplerParameterIiv(GLuint sampler, GLenum pname, const GLint *param);
	GLAPI void APIENTRY glSamplerParameterIuiv(GLuint sampler, GLenum pname, const GLuint *param);
	GLAPI void APIENTRY glGetSamplerParameteriv(GLuint sampler, GLenum pname, GLint *params);
	GLAPI void APIENTRY glGetSamplerParameterIiv(GLuint sampler, GLenum pname, GLint *params);
	GLAPI void APIENTRY glGetSamplerParameterfv(GLuint sampler, GLenum pname, GLfloat *params);
	GLAPI void APIENTRY glGetSamplerParameterIuiv(GLuint sampler, GLenum pname, GLuint *params);
#endif /* GLCOREARB_PROTOTYPES */
	typedef void (APIENTRYP PFNGLGENSAMPLERSPROC) (GLsizei count, GLuint *samplers);
	typedef void (APIENTRYP PFNGLDELETESAMPLERSPROC) (GLsizei count, const GLuint *samplers);
	typedef GLboolean(APIENTRYP PFNGLISSAMPLERPROC) (GLuint sampler);
	typedef void (APIENTRYP PFNGLBINDSAMPLERPROC) (GLuint unit, GLuint sampler);
	typedef void (APIENTRYP PFNGLSAMPLERPARAMETERIPROC) (GLuint sampler, GLenum pname, GLint param);
	typedef void (APIENTRYP PFNGLSAMPLERPARAMETERIVPROC) (GLuint sampler, GLenum pname, const GLint *param);
	typedef void (APIENTRYP PFNGLSAMPLERPARAMETERFPROC) (GLuint sampler, GLenum pname, GLfloat param);
	typedef void (APIENTRYP PFNGLSAMPLERPARAMETERFVPROC) (GLuint sampler, GLenum pname, const GLfloat *param);
	typedef void (APIENTRYP PFNGLSAMPLERPARAMETERIIVPROC) (GLuint sampler, GLenum pname, const GLint *param);
	typedef void (APIENTRYP PFNGLSAMPLERPARAMETERIUIVPROC) (GLuint sampler, GLenum pname, const GLuint *param);
	typedef void (APIENTRYP PFNGLGETSAMPLERPARAMETERIVPROC) (GLuint sampler, GLenum pname, GLint *params);
	typedef void (APIENTRYP PFNGLGETSAMPLERPARAMETERIIVPROC) (GLuint sampler, GLenum pname, GLint *params);
	typedef void (APIENTRYP PFNGLGETSAMPLERPARAMETERFVPROC) (GLuint sampler, GLenum pname, GLfloat *params);
	typedef void (APIENTRYP PFNGLGETSAMPLERPARAMETERIUIVPROC) (GLuint sampler, GLenum pname, GLuint *params);
#endif

#ifndef GL_ARB_shader_bit_encoding
#define GL_ARB_shader_bit_encoding 1
#endif

#ifndef GL_ARB_texture_rgb10_a2ui
#define GL_ARB_texture_rgb10_a2ui 1
#endif

#ifndef GL_ARB_texture_swizzle
#define GL_ARB_texture_swizzle 1
#endif

#ifndef GL_ARB_timer_query
#define GL_ARB_timer_query 1
#ifdef GLCOREARB_PROTOTYPES
	GLAPI void APIENTRY glQueryCounter(GLuint id, GLenum target);
	GLAPI void APIENTRY glGetQueryObjecti64v(GLuint id, GLenum pname, GLint64 *params);
	GLAPI void APIENTRY glGetQueryObjectui64v(GLuint id, GLenum pname, GLuint64 *params);
#endif /* GLCOREARB_PROTOTYPES */
	typedef void (APIENTRYP PFNGLQUERYCOUNTERPROC) (GLuint id, GLenum target);
	typedef void (APIENTRYP PFNGLGETQUERYOBJECTI64VPROC) (GLuint id, GLenum pname, GLint64 *params);
	typedef void (APIENTRYP PFNGLGETQUERYOBJECTUI64VPROC) (GLuint id, GLenum pname, GLuint64 *params);
#endif

#ifndef GL_ARB_vertex_type_2_10_10_10_rev
#define GL_ARB_vertex_type_2_10_10_10_rev 1
#ifdef GLCOREARB_PROTOTYPES
	GLAPI void APIENTRY glVertexP2ui(GLenum type, GLuint value);
	GLAPI void APIENTRY glVertexP2uiv(GLenum type, const GLuint *value);
	GLAPI void APIENTRY glVertexP3ui(GLenum type, GLuint value);
	GLAPI void APIENTRY glVertexP3uiv(GLenum type, const GLuint *value);
	GLAPI void APIENTRY glVertexP4ui(GLenum type, GLuint value);
	GLAPI void APIENTRY glVertexP4uiv(GLenum type, const GLuint *value);
	GLAPI void APIENTRY glTexCoordP1ui(GLenum type, GLuint coords);
	GLAPI void APIENTRY glTexCoordP1uiv(GLenum type, const GLuint *coords);
	GLAPI void APIENTRY glTexCoordP2ui(GLenum type, GLuint coords);
	GLAPI void APIENTRY glTexCoordP2uiv(GLenum type, const GLuint *coords);
	GLAPI void APIENTRY glTexCoordP3ui(GLenum type, GLuint coords);
	GLAPI void APIENTRY glTexCoordP3uiv(GLenum type, const GLuint *coords);
	GLAPI void APIENTRY glTexCoordP4ui(GLenum type, GLuint coords);
	GLAPI void APIENTRY glTexCoordP4uiv(GLenum type, const GLuint *coords);
	GLAPI void APIENTRY glMultiTexCoordP1ui(GLenum texture, GLenum type, GLuint coords);
	GLAPI void APIENTRY glMultiTexCoordP1uiv(GLenum texture, GLenum type, const GLuint *coords);
	GLAPI void APIENTRY glMultiTexCoordP2ui(GLenum texture, GLenum type, GLuint coords);
	GLAPI void APIENTRY glMultiTexCoordP2uiv(GLenum texture, GLenum type, const GLuint *coords);
	GLAPI void APIENTRY glMultiTexCoordP3ui(GLenum texture, GLenum type, GLuint coords);
	GLAPI void APIENTRY glMultiTexCoordP3uiv(GLenum texture, GLenum type, const GLuint *coords);
	GLAPI void APIENTRY glMultiTexCoordP4ui(GLenum texture, GLenum type, GLuint coords);
	GLAPI void APIENTRY glMultiTexCoordP4uiv(GLenum texture, GLenum type, const GLuint *coords);
	GLAPI void APIENTRY glNormalP3ui(GLenum type, GLuint coords);
	GLAPI void APIENTRY glNormalP3uiv(GLenum type, const GLuint *coords);
	GLAPI void APIENTRY glColorP3ui(GLenum type, GLuint color);
	GLAPI void APIENTRY glColorP3uiv(GLenum type, const GLuint *color);
	GLAPI void APIENTRY glColorP4ui(GLenum type, GLuint color);
	GLAPI void APIENTRY glColorP4uiv(GLenum type, const GLuint *color);
	GLAPI void APIENTRY glSecondaryColorP3ui(GLenum type, GLuint color);
	GLAPI void APIENTRY glSecondaryColorP3uiv(GLenum type, const GLuint *color);
	GLAPI void APIENTRY glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value);
	GLAPI void APIENTRY glVertexAttribP1uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint *value);
	GLAPI void APIENTRY glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value);
	GLAPI void APIENTRY glVertexAttribP2uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint *value);
	GLAPI void APIENTRY glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value);
	GLAPI void APIENTRY glVertexAttribP3uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint *value);
	GLAPI void APIENTRY glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value);
	GLAPI void APIENTRY glVertexAttribP4uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint *value);
#endif /* GLCOREARB_PROTOTYPES */
	typedef void (APIENTRYP PFNGLVERTEXP2UIPROC) (GLenum type, GLuint value);
	typedef void (APIENTRYP PFNGLVERTEXP2UIVPROC) (GLenum type, const GLuint *value);
	typedef void (APIENTRYP PFNGLVERTEXP3UIPROC) (GLenum type, GLuint value);
	typedef void (APIENTRYP PFNGLVERTEXP3UIVPROC) (GLenum type, const GLuint *value);
	typedef void (APIENTRYP PFNGLVERTEXP4UIPROC) (GLenum type, GLuint value);
	typedef void (APIENTRYP PFNGLVERTEXP4UIVPROC) (GLenum type, const GLuint *value);
	typedef void (APIENTRYP PFNGLTEXCOORDP1UIPROC) (GLenum type, GLuint coords);
	typedef void (APIENTRYP PFNGLTEXCOORDP1UIVPROC) (GLenum type, const GLuint *coords);
	typedef void (APIENTRYP PFNGLTEXCOORDP2UIPROC) (GLenum type, GLuint coords);
	typedef void (APIENTRYP PFNGLTEXCOORDP2UIVPROC) (GLenum type, const GLuint *coords);
	typedef void (APIENTRYP PFNGLTEXCOORDP3UIPROC) (GLenum type, GLuint coords);
	typedef void (APIENTRYP PFNGLTEXCOORDP3UIVPROC) (GLenum type, const GLuint *coords);
	typedef void (APIENTRYP PFNGLTEXCOORDP4UIPROC) (GLenum type, GLuint coords);
	typedef void (APIENTRYP PFNGLTEXCOORDP4UIVPROC) (GLenum type, const GLuint *coords);
	typedef void (APIENTRYP PFNGLMULTITEXCOORDP1UIPROC) (GLenum texture, GLenum type, GLuint coords);
	typedef void (APIENTRYP PFNGLMULTITEXCOORDP1UIVPROC) (GLenum texture, GLenum type, const GLuint *coords);
	typedef void (APIENTRYP PFNGLMULTITEXCOORDP2UIPROC) (GLenum texture, GLenum type, GLuint coords);
	typedef void (APIENTRYP PFNGLMULTITEXCOORDP2UIVPROC) (GLenum texture, GLenum type, const GLuint *coords);
	typedef void (APIENTRYP PFNGLMULTITEXCOORDP3UIPROC) (GLenum texture, GLenum type, GLuint coords);
	typedef void (APIENTRYP PFNGLMULTITEXCOORDP3UIVPROC) (GLenum texture, GLenum type, const GLuint *coords);
	typedef void (APIENTRYP PFNGLMULTITEXCOORDP4UIPROC) (GLenum texture, GLenum type, GLuint coords);
	typedef void (APIENTRYP PFNGLMULTITEXCOORDP4UIVPROC) (GLenum texture, GLenum type, const GLuint *coords);
	typedef void (APIENTRYP PFNGLNORMALP3UIPROC) (GLenum type, GLuint coords);
	typedef void (APIENTRYP PFNGLNORMALP3UIVPROC) (GLenum type, const GLuint *coords);
	typedef void (APIENTRYP PFNGLCOLORP3UIPROC) (GLenum type, GLuint color);
	typedef void (APIENTRYP PFNGLCOLORP3UIVPROC) (GLenum type, const GLuint *color);
	typedef void (APIENTRYP PFNGLCOLORP4UIPROC) (GLenum type, GLuint color);
	typedef void (APIENTRYP PFNGLCOLORP4UIVPROC) (GLenum type, const GLuint *color);
	typedef void (APIENTRYP PFNGLSECONDARYCOLORP3UIPROC) (GLenum type, GLuint color);
	typedef void (APIENTRYP PFNGLSECONDARYCOLORP3UIVPROC) (GLenum type, const GLuint *color);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBP1UIPROC) (GLuint index, GLenum type, GLboolean normalized, GLuint value);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBP1UIVPROC) (GLuint index, GLenum type, GLboolean normalized, const GLuint *value);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBP2UIPROC) (GLuint index, GLenum type, GLboolean normalized, GLuint value);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBP2UIVPROC) (GLuint index, GLenum type, GLboolean normalized, const GLuint *value);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBP3UIPROC) (GLuint index, GLenum type, GLboolean normalized, GLuint value);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBP3UIVPROC) (GLuint index, GLenum type, GLboolean normalized, const GLuint *value);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBP4UIPROC) (GLuint index, GLenum type, GLboolean normalized, GLuint value);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBP4UIVPROC) (GLuint index, GLenum type, GLboolean normalized, const GLuint *value);
#endif

#ifndef GL_ARB_draw_indirect
#define GL_ARB_draw_indirect 1
#ifdef GLCOREARB_PROTOTYPES
	GLAPI void APIENTRY glDrawArraysIndirect(GLenum mode, const GLvoid *indirect);
	GLAPI void APIENTRY glDrawElementsIndirect(GLenum mode, GLenum type, const GLvoid *indirect);
#endif /* GLCOREARB_PROTOTYPES */
	typedef void (APIENTRYP PFNGLDRAWARRAYSINDIRECTPROC) (GLenum mode, const GLvoid *indirect);
	typedef void (APIENTRYP PFNGLDRAWELEMENTSINDIRECTPROC) (GLenum mode, GLenum type, const GLvoid *indirect);
#endif

#ifndef GL_ARB_gpu_shader5
#define GL_ARB_gpu_shader5 1
#endif

#ifndef GL_ARB_gpu_shader_fp64
#define GL_ARB_gpu_shader_fp64 1
#ifdef GLCOREARB_PROTOTYPES
	GLAPI void APIENTRY glUniform1d(GLint location, GLdouble x);
	GLAPI void APIENTRY glUniform2d(GLint location, GLdouble x, GLdouble y);
	GLAPI void APIENTRY glUniform3d(GLint location, GLdouble x, GLdouble y, GLdouble z);
	GLAPI void APIENTRY glUniform4d(GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
	GLAPI void APIENTRY glUniform1dv(GLint location, GLsizei count, const GLdouble *value);
	GLAPI void APIENTRY glUniform2dv(GLint location, GLsizei count, const GLdouble *value);
	GLAPI void APIENTRY glUniform3dv(GLint location, GLsizei count, const GLdouble *value);
	GLAPI void APIENTRY glUniform4dv(GLint location, GLsizei count, const GLdouble *value);
	GLAPI void APIENTRY glUniformMatrix2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
	GLAPI void APIENTRY glUniformMatrix3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
	GLAPI void APIENTRY glUniformMatrix4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
	GLAPI void APIENTRY glUniformMatrix2x3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
	GLAPI void APIENTRY glUniformMatrix2x4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
	GLAPI void APIENTRY glUniformMatrix3x2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
	GLAPI void APIENTRY glUniformMatrix3x4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
	GLAPI void APIENTRY glUniformMatrix4x2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
	GLAPI void APIENTRY glUniformMatrix4x3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
	GLAPI void APIENTRY glGetUniformdv(GLuint program, GLint location, GLdouble *params);
#endif /* GLCOREARB_PROTOTYPES */
	typedef void (APIENTRYP PFNGLUNIFORM1DPROC) (GLint location, GLdouble x);
	typedef void (APIENTRYP PFNGLUNIFORM2DPROC) (GLint location, GLdouble x, GLdouble y);
	typedef void (APIENTRYP PFNGLUNIFORM3DPROC) (GLint location, GLdouble x, GLdouble y, GLdouble z);
	typedef void (APIENTRYP PFNGLUNIFORM4DPROC) (GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
	typedef void (APIENTRYP PFNGLUNIFORM1DVPROC) (GLint location, GLsizei count, const GLdouble *value);
	typedef void (APIENTRYP PFNGLUNIFORM2DVPROC) (GLint location, GLsizei count, const GLdouble *value);
	typedef void (APIENTRYP PFNGLUNIFORM3DVPROC) (GLint location, GLsizei count, const GLdouble *value);
	typedef void (APIENTRYP PFNGLUNIFORM4DVPROC) (GLint location, GLsizei count, const GLdouble *value);
	typedef void (APIENTRYP PFNGLUNIFORMMATRIX2DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
	typedef void (APIENTRYP PFNGLUNIFORMMATRIX3DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
	typedef void (APIENTRYP PFNGLUNIFORMMATRIX4DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
	typedef void (APIENTRYP PFNGLUNIFORMMATRIX2X3DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
	typedef void (APIENTRYP PFNGLUNIFORMMATRIX2X4DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
	typedef void (APIENTRYP PFNGLUNIFORMMATRIX3X2DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
	typedef void (APIENTRYP PFNGLUNIFORMMATRIX3X4DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
	typedef void (APIENTRYP PFNGLUNIFORMMATRIX4X2DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
	typedef void (APIENTRYP PFNGLUNIFORMMATRIX4X3DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
	typedef void (APIENTRYP PFNGLGETUNIFORMDVPROC) (GLuint program, GLint location, GLdouble *params);
#endif

#ifndef GL_ARB_shader_subroutine
#define GL_ARB_shader_subroutine 1
#ifdef GLCOREARB_PROTOTYPES
	GLAPI GLint APIENTRY glGetSubroutineUniformLocation(GLuint program, GLenum shadertype, const GLchar *name);
	GLAPI GLuint APIENTRY glGetSubroutineIndex(GLuint program, GLenum shadertype, const GLchar *name);
	GLAPI void APIENTRY glGetActiveSubroutineUniformiv(GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint *values);
	GLAPI void APIENTRY glGetActiveSubroutineUniformName(GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei *length, GLchar *name);
	GLAPI void APIENTRY glGetActiveSubroutineName(GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei *length, GLchar *name);
	GLAPI void APIENTRY glUniformSubroutinesuiv(GLenum shadertype, GLsizei count, const GLuint *indices);
	GLAPI void APIENTRY glGetUniformSubroutineuiv(GLenum shadertype, GLint location, GLuint *params);
	GLAPI void APIENTRY glGetProgramStageiv(GLuint program, GLenum shadertype, GLenum pname, GLint *values);
#endif /* GLCOREARB_PROTOTYPES */
	typedef GLint(APIENTRYP PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC) (GLuint program, GLenum shadertype, const GLchar *name);
	typedef GLuint(APIENTRYP PFNGLGETSUBROUTINEINDEXPROC) (GLuint program, GLenum shadertype, const GLchar *name);
	typedef void (APIENTRYP PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC) (GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint *values);
	typedef void (APIENTRYP PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC) (GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei *length, GLchar *name);
	typedef void (APIENTRYP PFNGLGETACTIVESUBROUTINENAMEPROC) (GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei *length, GLchar *name);
	typedef void (APIENTRYP PFNGLUNIFORMSUBROUTINESUIVPROC) (GLenum shadertype, GLsizei count, const GLuint *indices);
	typedef void (APIENTRYP PFNGLGETUNIFORMSUBROUTINEUIVPROC) (GLenum shadertype, GLint location, GLuint *params);
	typedef void (APIENTRYP PFNGLGETPROGRAMSTAGEIVPROC) (GLuint program, GLenum shadertype, GLenum pname, GLint *values);
#endif

#ifndef GL_ARB_tessellation_shader
#define GL_ARB_tessellation_shader 1
#ifdef GLCOREARB_PROTOTYPES
	GLAPI void APIENTRY glPatchParameteri(GLenum pname, GLint value);
	GLAPI void APIENTRY glPatchParameterfv(GLenum pname, const GLfloat *values);
#endif /* GLCOREARB_PROTOTYPES */
	typedef void (APIENTRYP PFNGLPATCHPARAMETERIPROC) (GLenum pname, GLint value);
	typedef void (APIENTRYP PFNGLPATCHPARAMETERFVPROC) (GLenum pname, const GLfloat *values);
#endif

#ifndef GL_ARB_texture_buffer_object_rgb32
#define GL_ARB_texture_buffer_object_rgb32 1
#endif

#ifndef GL_ARB_transform_feedback2
#define GL_ARB_transform_feedback2 1
#ifdef GLCOREARB_PROTOTYPES
	GLAPI void APIENTRY glBindTransformFeedback(GLenum target, GLuint id);
	GLAPI void APIENTRY glDeleteTransformFeedbacks(GLsizei n, const GLuint *ids);
	GLAPI void APIENTRY glGenTransformFeedbacks(GLsizei n, GLuint *ids);
	GLAPI GLboolean APIENTRY glIsTransformFeedback(GLuint id);
	GLAPI void APIENTRY glPauseTransformFeedback(void);
	GLAPI void APIENTRY glResumeTransformFeedback(void);
	GLAPI void APIENTRY glDrawTransformFeedback(GLenum mode, GLuint id);
#endif /* GLCOREARB_PROTOTYPES */
	typedef void (APIENTRYP PFNGLBINDTRANSFORMFEEDBACKPROC) (GLenum target, GLuint id);
	typedef void (APIENTRYP PFNGLDELETETRANSFORMFEEDBACKSPROC) (GLsizei n, const GLuint *ids);
	typedef void (APIENTRYP PFNGLGENTRANSFORMFEEDBACKSPROC) (GLsizei n, GLuint *ids);
	typedef GLboolean(APIENTRYP PFNGLISTRANSFORMFEEDBACKPROC) (GLuint id);
	typedef void (APIENTRYP PFNGLPAUSETRANSFORMFEEDBACKPROC) (void);
	typedef void (APIENTRYP PFNGLRESUMETRANSFORMFEEDBACKPROC) (void);
	typedef void (APIENTRYP PFNGLDRAWTRANSFORMFEEDBACKPROC) (GLenum mode, GLuint id);
#endif

#ifndef GL_ARB_transform_feedback3
#define GL_ARB_transform_feedback3 1
#ifdef GLCOREARB_PROTOTYPES
	GLAPI void APIENTRY glDrawTransformFeedbackStream(GLenum mode, GLuint id, GLuint stream);
	GLAPI void APIENTRY glBeginQueryIndexed(GLenum target, GLuint index, GLuint id);
	GLAPI void APIENTRY glEndQueryIndexed(GLenum target, GLuint index);
	GLAPI void APIENTRY glGetQueryIndexediv(GLenum target, GLuint index, GLenum pname, GLint *params);
#endif /* GLCOREARB_PROTOTYPES */
	typedef void (APIENTRYP PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC) (GLenum mode, GLuint id, GLuint stream);
	typedef void (APIENTRYP PFNGLBEGINQUERYINDEXEDPROC) (GLenum target, GLuint index, GLuint id);
	typedef void (APIENTRYP PFNGLENDQUERYINDEXEDPROC) (GLenum target, GLuint index);
	typedef void (APIENTRYP PFNGLGETQUERYINDEXEDIVPROC) (GLenum target, GLuint index, GLenum pname, GLint *params);
#endif

#ifndef GL_ARB_ES2_compatibility
#define GL_ARB_ES2_compatibility 1
#ifdef GLCOREARB_PROTOTYPES
	GLAPI void APIENTRY glReleaseShaderCompiler(void);
	GLAPI void APIENTRY glShaderBinary(GLsizei count, const GLuint *shaders, GLenum binaryformat, const GLvoid *binary, GLsizei length);
	GLAPI void APIENTRY glGetShaderPrecisionFormat(GLenum shadertype, GLenum precisiontype, GLint *range, GLint *precision);
	GLAPI void APIENTRY glDepthRangef(GLfloat n, GLfloat f);
	GLAPI void APIENTRY glClearDepthf(GLfloat d);
#endif /* GLCOREARB_PROTOTYPES */
	typedef void (APIENTRYP PFNGLRELEASESHADERCOMPILERPROC) (void);
	typedef void (APIENTRYP PFNGLSHADERBINARYPROC) (GLsizei count, const GLuint *shaders, GLenum binaryformat, const GLvoid *binary, GLsizei length);
	typedef void (APIENTRYP PFNGLGETSHADERPRECISIONFORMATPROC) (GLenum shadertype, GLenum precisiontype, GLint *range, GLint *precision);
	typedef void (APIENTRYP PFNGLDEPTHRANGEFPROC) (GLfloat n, GLfloat f);
	typedef void (APIENTRYP PFNGLCLEARDEPTHFPROC) (GLfloat d);
#endif

#ifndef GL_ARB_get_program_binary
#define GL_ARB_get_program_binary 1
#ifdef GLCOREARB_PROTOTYPES
	GLAPI void APIENTRY glGetProgramBinary(GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, GLvoid *binary);
	GLAPI void APIENTRY glProgramBinary(GLuint program, GLenum binaryFormat, const GLvoid *binary, GLsizei length);
	GLAPI void APIENTRY glProgramParameteri(GLuint program, GLenum pname, GLint value);
#endif /* GLCOREARB_PROTOTYPES */
	typedef void (APIENTRYP PFNGLGETPROGRAMBINARYPROC) (GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, GLvoid *binary);
	typedef void (APIENTRYP PFNGLPROGRAMBINARYPROC) (GLuint program, GLenum binaryFormat, const GLvoid *binary, GLsizei length);
	typedef void (APIENTRYP PFNGLPROGRAMPARAMETERIPROC) (GLuint program, GLenum pname, GLint value);
#endif

#ifndef GL_ARB_separate_shader_objects
#define GL_ARB_separate_shader_objects 1
#ifdef GLCOREARB_PROTOTYPES
	GLAPI void APIENTRY glUseProgramStages(GLuint pipeline, GLbitfield stages, GLuint program);
	GLAPI void APIENTRY glActiveShaderProgram(GLuint pipeline, GLuint program);
	GLAPI GLuint APIENTRY glCreateShaderProgramv(GLenum type, GLsizei count, const GLchar* const *strings);
	GLAPI void APIENTRY glBindProgramPipeline(GLuint pipeline);
	GLAPI void APIENTRY glDeleteProgramPipelines(GLsizei n, const GLuint *pipelines);
	GLAPI void APIENTRY glGenProgramPipelines(GLsizei n, GLuint *pipelines);
	GLAPI GLboolean APIENTRY glIsProgramPipeline(GLuint pipeline);
	GLAPI void APIENTRY glGetProgramPipelineiv(GLuint pipeline, GLenum pname, GLint *params);
	GLAPI void APIENTRY glProgramUniform1i(GLuint program, GLint location, GLint v0);
	GLAPI void APIENTRY glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value);
	GLAPI void APIENTRY glProgramUniform1f(GLuint program, GLint location, GLfloat v0);
	GLAPI void APIENTRY glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value);
	GLAPI void APIENTRY glProgramUniform1d(GLuint program, GLint location, GLdouble v0);
	GLAPI void APIENTRY glProgramUniform1dv(GLuint program, GLint location, GLsizei count, const GLdouble *value);
	GLAPI void APIENTRY glProgramUniform1ui(GLuint program, GLint location, GLuint v0);
	GLAPI void APIENTRY glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value);
	GLAPI void APIENTRY glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1);
	GLAPI void APIENTRY glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value);
	GLAPI void APIENTRY glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1);
	GLAPI void APIENTRY glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value);
	GLAPI void APIENTRY glProgramUniform2d(GLuint program, GLint location, GLdouble v0, GLdouble v1);
	GLAPI void APIENTRY glProgramUniform2dv(GLuint program, GLint location, GLsizei count, const GLdouble *value);
	GLAPI void APIENTRY glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1);
	GLAPI void APIENTRY glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value);
	GLAPI void APIENTRY glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2);
	GLAPI void APIENTRY glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value);
	GLAPI void APIENTRY glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
	GLAPI void APIENTRY glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value);
	GLAPI void APIENTRY glProgramUniform3d(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2);
	GLAPI void APIENTRY glProgramUniform3dv(GLuint program, GLint location, GLsizei count, const GLdouble *value);
	GLAPI void APIENTRY glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2);
	GLAPI void APIENTRY glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value);
	GLAPI void APIENTRY glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
	GLAPI void APIENTRY glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value);
	GLAPI void APIENTRY glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
	GLAPI void APIENTRY glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value);
	GLAPI void APIENTRY glProgramUniform4d(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3);
	GLAPI void APIENTRY glProgramUniform4dv(GLuint program, GLint location, GLsizei count, const GLdouble *value);
	GLAPI void APIENTRY glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
	GLAPI void APIENTRY glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value);
	GLAPI void APIENTRY glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
	GLAPI void APIENTRY glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
	GLAPI void APIENTRY glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
	GLAPI void APIENTRY glProgramUniformMatrix2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
	GLAPI void APIENTRY glProgramUniformMatrix3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
	GLAPI void APIENTRY glProgramUniformMatrix4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
	GLAPI void APIENTRY glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
	GLAPI void APIENTRY glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
	GLAPI void APIENTRY glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
	GLAPI void APIENTRY glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
	GLAPI void APIENTRY glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
	GLAPI void APIENTRY glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
	GLAPI void APIENTRY glProgramUniformMatrix2x3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
	GLAPI void APIENTRY glProgramUniformMatrix3x2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
	GLAPI void APIENTRY glProgramUniformMatrix2x4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
	GLAPI void APIENTRY glProgramUniformMatrix4x2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
	GLAPI void APIENTRY glProgramUniformMatrix3x4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
	GLAPI void APIENTRY glProgramUniformMatrix4x3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
	GLAPI void APIENTRY glValidateProgramPipeline(GLuint pipeline);
	GLAPI void APIENTRY glGetProgramPipelineInfoLog(GLuint pipeline, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
#endif /* GLCOREARB_PROTOTYPES */
	typedef void (APIENTRYP PFNGLUSEPROGRAMSTAGESPROC) (GLuint pipeline, GLbitfield stages, GLuint program);
	typedef void (APIENTRYP PFNGLACTIVESHADERPROGRAMPROC) (GLuint pipeline, GLuint program);
	typedef GLuint(APIENTRYP PFNGLCREATESHADERPROGRAMVPROC) (GLenum type, GLsizei count, const GLchar* const *strings);
	typedef void (APIENTRYP PFNGLBINDPROGRAMPIPELINEPROC) (GLuint pipeline);
	typedef void (APIENTRYP PFNGLDELETEPROGRAMPIPELINESPROC) (GLsizei n, const GLuint *pipelines);
	typedef void (APIENTRYP PFNGLGENPROGRAMPIPELINESPROC) (GLsizei n, GLuint *pipelines);
	typedef GLboolean(APIENTRYP PFNGLISPROGRAMPIPELINEPROC) (GLuint pipeline);
	typedef void (APIENTRYP PFNGLGETPROGRAMPIPELINEIVPROC) (GLuint pipeline, GLenum pname, GLint *params);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM1IPROC) (GLuint program, GLint location, GLint v0);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM1IVPROC) (GLuint program, GLint location, GLsizei count, const GLint *value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM1FPROC) (GLuint program, GLint location, GLfloat v0);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM1FVPROC) (GLuint program, GLint location, GLsizei count, const GLfloat *value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM1DPROC) (GLuint program, GLint location, GLdouble v0);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM1DVPROC) (GLuint program, GLint location, GLsizei count, const GLdouble *value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM1UIPROC) (GLuint program, GLint location, GLuint v0);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM1UIVPROC) (GLuint program, GLint location, GLsizei count, const GLuint *value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM2IPROC) (GLuint program, GLint location, GLint v0, GLint v1);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM2IVPROC) (GLuint program, GLint location, GLsizei count, const GLint *value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM2FPROC) (GLuint program, GLint location, GLfloat v0, GLfloat v1);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM2FVPROC) (GLuint program, GLint location, GLsizei count, const GLfloat *value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM2DPROC) (GLuint program, GLint location, GLdouble v0, GLdouble v1);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM2DVPROC) (GLuint program, GLint location, GLsizei count, const GLdouble *value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM2UIPROC) (GLuint program, GLint location, GLuint v0, GLuint v1);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM2UIVPROC) (GLuint program, GLint location, GLsizei count, const GLuint *value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM3IPROC) (GLuint program, GLint location, GLint v0, GLint v1, GLint v2);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM3IVPROC) (GLuint program, GLint location, GLsizei count, const GLint *value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM3FPROC) (GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM3FVPROC) (GLuint program, GLint location, GLsizei count, const GLfloat *value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM3DPROC) (GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM3DVPROC) (GLuint program, GLint location, GLsizei count, const GLdouble *value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM3UIPROC) (GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM3UIVPROC) (GLuint program, GLint location, GLsizei count, const GLuint *value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM4IPROC) (GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM4IVPROC) (GLuint program, GLint location, GLsizei count, const GLint *value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM4FPROC) (GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM4FVPROC) (GLuint program, GLint location, GLsizei count, const GLfloat *value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM4DPROC) (GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM4DVPROC) (GLuint program, GLint location, GLsizei count, const GLdouble *value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM4UIPROC) (GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM4UIVPROC) (GLuint program, GLint location, GLsizei count, const GLuint *value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX2FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX3FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX4FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX2DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX3DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX4DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
	typedef void (APIENTRYP PFNGLVALIDATEPROGRAMPIPELINEPROC) (GLuint pipeline);
	typedef void (APIENTRYP PFNGLGETPROGRAMPIPELINEINFOLOGPROC) (GLuint pipeline, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
#endif

#ifndef GL_ARB_vertex_attrib_64bit
#define GL_ARB_vertex_attrib_64bit 1
#ifdef GLCOREARB_PROTOTYPES
	GLAPI void APIENTRY glVertexAttribL1d(GLuint index, GLdouble x);
	GLAPI void APIENTRY glVertexAttribL2d(GLuint index, GLdouble x, GLdouble y);
	GLAPI void APIENTRY glVertexAttribL3d(GLuint index, GLdouble x, GLdouble y, GLdouble z);
	GLAPI void APIENTRY glVertexAttribL4d(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
	GLAPI void APIENTRY glVertexAttribL1dv(GLuint index, const GLdouble *v);
	GLAPI void APIENTRY glVertexAttribL2dv(GLuint index, const GLdouble *v);
	GLAPI void APIENTRY glVertexAttribL3dv(GLuint index, const GLdouble *v);
	GLAPI void APIENTRY glVertexAttribL4dv(GLuint index, const GLdouble *v);
	GLAPI void APIENTRY glVertexAttribLPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
	GLAPI void APIENTRY glGetVertexAttribLdv(GLuint index, GLenum pname, GLdouble *params);
#endif /* GLCOREARB_PROTOTYPES */
	typedef void (APIENTRYP PFNGLVERTEXATTRIBL1DPROC) (GLuint index, GLdouble x);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBL2DPROC) (GLuint index, GLdouble x, GLdouble y);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBL3DPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBL4DPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBL1DVPROC) (GLuint index, const GLdouble *v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBL2DVPROC) (GLuint index, const GLdouble *v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBL3DVPROC) (GLuint index, const GLdouble *v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBL4DVPROC) (GLuint index, const GLdouble *v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBLPOINTERPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
	typedef void (APIENTRYP PFNGLGETVERTEXATTRIBLDVPROC) (GLuint index, GLenum pname, GLdouble *params);
#endif

#ifndef GL_ARB_viewport_array
#define GL_ARB_viewport_array 1
#ifdef GLCOREARB_PROTOTYPES
	GLAPI void APIENTRY glViewportArrayv(GLuint first, GLsizei count, const GLfloat *v);
	GLAPI void APIENTRY glViewportIndexedf(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h);
	GLAPI void APIENTRY glViewportIndexedfv(GLuint index, const GLfloat *v);
	GLAPI void APIENTRY glScissorArrayv(GLuint first, GLsizei count, const GLint *v);
	GLAPI void APIENTRY glScissorIndexed(GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height);
	GLAPI void APIENTRY glScissorIndexedv(GLuint index, const GLint *v);
	GLAPI void APIENTRY glDepthRangeArrayv(GLuint first, GLsizei count, const GLdouble *v);
	GLAPI void APIENTRY glDepthRangeIndexed(GLuint index, GLdouble n, GLdouble f);
	GLAPI void APIENTRY glGetFloati_v(GLenum target, GLuint index, GLfloat *data);
	GLAPI void APIENTRY glGetDoublei_v(GLenum target, GLuint index, GLdouble *data);
#endif /* GLCOREARB_PROTOTYPES */
	typedef void (APIENTRYP PFNGLVIEWPORTARRAYVPROC) (GLuint first, GLsizei count, const GLfloat *v);
	typedef void (APIENTRYP PFNGLVIEWPORTINDEXEDFPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h);
	typedef void (APIENTRYP PFNGLVIEWPORTINDEXEDFVPROC) (GLuint index, const GLfloat *v);
	typedef void (APIENTRYP PFNGLSCISSORARRAYVPROC) (GLuint first, GLsizei count, const GLint *v);
	typedef void (APIENTRYP PFNGLSCISSORINDEXEDPROC) (GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height);
	typedef void (APIENTRYP PFNGLSCISSORINDEXEDVPROC) (GLuint index, const GLint *v);
	typedef void (APIENTRYP PFNGLDEPTHRANGEARRAYVPROC) (GLuint first, GLsizei count, const GLdouble *v);
	typedef void (APIENTRYP PFNGLDEPTHRANGEINDEXEDPROC) (GLuint index, GLdouble n, GLdouble f);
	typedef void (APIENTRYP PFNGLGETFLOATI_VPROC) (GLenum target, GLuint index, GLfloat *data);
	typedef void (APIENTRYP PFNGLGETDOUBLEI_VPROC) (GLenum target, GLuint index, GLdouble *data);
#endif

#ifndef GL_ARB_cl_event
#define GL_ARB_cl_event 1
#ifdef GLCOREARB_PROTOTYPES
	GLAPI GLsync APIENTRY glCreateSyncFromCLeventARB(struct _cl_context * context, struct _cl_event * event, GLbitfield flags);
#endif /* GLCOREARB_PROTOTYPES */
	typedef GLsync(APIENTRYP PFNGLCREATESYNCFROMCLEVENTARBPROC) (struct _cl_context * context, struct _cl_event * event, GLbitfield flags);
#endif

#ifndef GL_ARB_debug_output
#define GL_ARB_debug_output 1
#ifdef GLCOREARB_PROTOTYPES
	GLAPI void APIENTRY glDebugMessageControlARB(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled);
	GLAPI void APIENTRY glDebugMessageInsertARB(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *buf);
	GLAPI void APIENTRY glDebugMessageCallbackARB(GLDEBUGPROCARB callback, const GLvoid *userParam);
	GLAPI GLuint APIENTRY glGetDebugMessageLogARB(GLuint count, GLsizei bufsize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog);
#endif /* GLCOREARB_PROTOTYPES */
	typedef void (APIENTRYP PFNGLDEBUGMESSAGECONTROLARBPROC) (GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled);
	typedef void (APIENTRYP PFNGLDEBUGMESSAGEINSERTARBPROC) (GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *buf);
	typedef void (APIENTRYP PFNGLDEBUGMESSAGECALLBACKARBPROC) (GLDEBUGPROCARB callback, const GLvoid *userParam);
	typedef GLuint(APIENTRYP PFNGLGETDEBUGMESSAGELOGARBPROC) (GLuint count, GLsizei bufsize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog);
#endif

#ifndef GL_ARB_robustness
#define GL_ARB_robustness 1
#ifdef GLCOREARB_PROTOTYPES
	GLAPI GLenum APIENTRY glGetGraphicsResetStatusARB(void);
	GLAPI void APIENTRY glGetnTexImageARB(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, GLvoid *img);
	GLAPI void APIENTRY glReadnPixelsARB(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, GLvoid *data);
	GLAPI void APIENTRY glGetnCompressedTexImageARB(GLenum target, GLint lod, GLsizei bufSize, GLvoid *img);
	GLAPI void APIENTRY glGetnUniformfvARB(GLuint program, GLint location, GLsizei bufSize, GLfloat *params);
	GLAPI void APIENTRY glGetnUniformivARB(GLuint program, GLint location, GLsizei bufSize, GLint *params);
	GLAPI void APIENTRY glGetnUniformuivARB(GLuint program, GLint location, GLsizei bufSize, GLuint *params);
	GLAPI void APIENTRY glGetnUniformdvARB(GLuint program, GLint location, GLsizei bufSize, GLdouble *params);
#endif /* GLCOREARB_PROTOTYPES */
	typedef GLenum(APIENTRYP PFNGLGETGRAPHICSRESETSTATUSARBPROC) (void);
	typedef void (APIENTRYP PFNGLGETNTEXIMAGEARBPROC) (GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, GLvoid *img);
	typedef void (APIENTRYP PFNGLREADNPIXELSARBPROC) (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, GLvoid *data);
	typedef void (APIENTRYP PFNGLGETNCOMPRESSEDTEXIMAGEARBPROC) (GLenum target, GLint lod, GLsizei bufSize, GLvoid *img);
	typedef void (APIENTRYP PFNGLGETNUNIFORMFVARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLfloat *params);
	typedef void (APIENTRYP PFNGLGETNUNIFORMIVARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLint *params);
	typedef void (APIENTRYP PFNGLGETNUNIFORMUIVARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLuint *params);
	typedef void (APIENTRYP PFNGLGETNUNIFORMDVARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLdouble *params);
#endif

#ifndef GL_ARB_shader_stencil_export
#define GL_ARB_shader_stencil_export 1
#endif

#ifndef GL_ARB_base_instance
#define GL_ARB_base_instance 1
#ifdef GLCOREARB_PROTOTYPES
	GLAPI void APIENTRY glDrawArraysInstancedBaseInstance(GLenum mode, GLint first, GLsizei count, GLsizei instancecount, GLuint baseinstance);
	GLAPI void APIENTRY glDrawElementsInstancedBaseInstance(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLuint baseinstance);
	GLAPI void APIENTRY glDrawElementsInstancedBaseVertexBaseInstance(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLint basevertex, GLuint baseinstance);
#endif /* GLCOREARB_PROTOTYPES */
	typedef void (APIENTRYP PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC) (GLenum mode, GLint first, GLsizei count, GLsizei instancecount, GLuint baseinstance);
	typedef void (APIENTRYP PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLuint baseinstance);
	typedef void (APIENTRYP PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLint basevertex, GLuint baseinstance);
#endif

#ifndef GL_ARB_shading_language_420pack
#define GL_ARB_shading_language_420pack 1
#endif

#ifndef GL_ARB_transform_feedback_instanced
#define GL_ARB_transform_feedback_instanced 1
#ifdef GLCOREARB_PROTOTYPES
	GLAPI void APIENTRY glDrawTransformFeedbackInstanced(GLenum mode, GLuint id, GLsizei instancecount);
	GLAPI void APIENTRY glDrawTransformFeedbackStreamInstanced(GLenum mode, GLuint id, GLuint stream, GLsizei instancecount);
#endif /* GLCOREARB_PROTOTYPES */
	typedef void (APIENTRYP PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC) (GLenum mode, GLuint id, GLsizei instancecount);
	typedef void (APIENTRYP PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC) (GLenum mode, GLuint id, GLuint stream, GLsizei instancecount);
#endif

#ifndef GL_ARB_compressed_texture_pixel_storage
#define GL_ARB_compressed_texture_pixel_storage 1
#endif

#ifndef GL_ARB_conservative_depth
#define GL_ARB_conservative_depth 1
#endif

#ifndef GL_ARB_internalformat_query
#define GL_ARB_internalformat_query 1
#ifdef GLCOREARB_PROTOTYPES
	GLAPI void APIENTRY glGetInternalformativ(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint *params);
#endif /* GLCOREARB_PROTOTYPES */
	typedef void (APIENTRYP PFNGLGETINTERNALFORMATIVPROC) (GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint *params);
#endif

#ifndef GL_ARB_map_buffer_alignment
#define GL_ARB_map_buffer_alignment 1
#endif

#ifndef GL_ARB_shader_atomic_counters
#define GL_ARB_shader_atomic_counters 1
#ifdef GLCOREARB_PROTOTYPES
	GLAPI void APIENTRY glGetActiveAtomicCounterBufferiv(GLuint program, GLuint bufferIndex, GLenum pname, GLint *params);
#endif /* GLCOREARB_PROTOTYPES */
	typedef void (APIENTRYP PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC) (GLuint program, GLuint bufferIndex, GLenum pname, GLint *params);
#endif

#ifndef GL_ARB_shader_image_load_store
#define GL_ARB_shader_image_load_store 1
#ifdef GLCOREARB_PROTOTYPES
	GLAPI void APIENTRY glBindImageTexture(GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format);
	GLAPI void APIENTRY glMemoryBarrier(GLbitfield barriers);
#endif /* GLCOREARB_PROTOTYPES */
	typedef void (APIENTRYP PFNGLBINDIMAGETEXTUREPROC) (GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format);
	typedef void (APIENTRYP PFNGLMEMORYBARRIERPROC) (GLbitfield barriers);
#endif

#ifndef GL_ARB_shading_language_packing
#define GL_ARB_shading_language_packing 1
#endif

#ifndef GL_ARB_texture_storage
#define GL_ARB_texture_storage 1
#ifdef GLCOREARB_PROTOTYPES
	GLAPI void APIENTRY glTexStorage1D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
	GLAPI void APIENTRY glTexStorage2D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
	GLAPI void APIENTRY glTexStorage3D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
	GLAPI void APIENTRY glTextureStorage1DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
	GLAPI void APIENTRY glTextureStorage2DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
	GLAPI void APIENTRY glTextureStorage3DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
#endif /* GLCOREARB_PROTOTYPES */
	typedef void (APIENTRYP PFNGLTEXSTORAGE1DPROC) (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
	typedef void (APIENTRYP PFNGLTEXSTORAGE2DPROC) (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
	typedef void (APIENTRYP PFNGLTEXSTORAGE3DPROC) (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
	typedef void (APIENTRYP PFNGLTEXTURESTORAGE1DEXTPROC) (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
	typedef void (APIENTRYP PFNGLTEXTURESTORAGE2DEXTPROC) (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
	typedef void (APIENTRYP PFNGLTEXTURESTORAGE3DEXTPROC) (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
#endif

#ifndef GL_KHR_texture_compression_astc_ldr
#define GL_KHR_texture_compression_astc_ldr 1
#endif

#ifndef GL_KHR_debug
#define GL_KHR_debug 1
#ifdef GLCOREARB_PROTOTYPES
	GLAPI void APIENTRY glDebugMessageControl(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled);
	GLAPI void APIENTRY glDebugMessageInsert(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *buf);
	GLAPI void APIENTRY glDebugMessageCallback(GLDEBUGPROC callback, const void *userParam);
	GLAPI GLuint APIENTRY glGetDebugMessageLog(GLuint count, GLsizei bufsize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog);
	GLAPI void APIENTRY glPushDebugGroup(GLenum source, GLuint id, GLsizei length, const GLchar *message);
	GLAPI void APIENTRY glPopDebugGroup(void);
	GLAPI void APIENTRY glObjectLabel(GLenum identifier, GLuint name, GLsizei length, const GLchar *label);
	GLAPI void APIENTRY glGetObjectLabel(GLenum identifier, GLuint name, GLsizei bufSize, GLsizei *length, GLchar *label);
	GLAPI void APIENTRY glObjectPtrLabel(const void *ptr, GLsizei length, const GLchar *label);
	GLAPI void APIENTRY glGetObjectPtrLabel(const void *ptr, GLsizei bufSize, GLsizei *length, GLchar *label);
#endif /* GLCOREARB_PROTOTYPES */
	typedef void (APIENTRYP PFNGLDEBUGMESSAGECONTROLPROC) (GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled);
	typedef void (APIENTRYP PFNGLDEBUGMESSAGEINSERTPROC) (GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *buf);
	typedef void (APIENTRYP PFNGLDEBUGMESSAGECALLBACKPROC) (GLDEBUGPROC callback, const void *userParam);
	typedef GLuint(APIENTRYP PFNGLGETDEBUGMESSAGELOGPROC) (GLuint count, GLsizei bufsize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog);
	typedef void (APIENTRYP PFNGLPUSHDEBUGGROUPPROC) (GLenum source, GLuint id, GLsizei length, const GLchar *message);
	typedef void (APIENTRYP PFNGLPOPDEBUGGROUPPROC) (void);
	typedef void (APIENTRYP PFNGLOBJECTLABELPROC) (GLenum identifier, GLuint name, GLsizei length, const GLchar *label);
	typedef void (APIENTRYP PFNGLGETOBJECTLABELPROC) (GLenum identifier, GLuint name, GLsizei bufSize, GLsizei *length, GLchar *label);
	typedef void (APIENTRYP PFNGLOBJECTPTRLABELPROC) (const void *ptr, GLsizei length, const GLchar *label);
	typedef void (APIENTRYP PFNGLGETOBJECTPTRLABELPROC) (const void *ptr, GLsizei bufSize, GLsizei *length, GLchar *label);
#endif

#ifndef GL_ARB_arrays_of_arrays
#define GL_ARB_arrays_of_arrays 1
#endif

#ifndef GL_ARB_clear_buffer_object
#define GL_ARB_clear_buffer_object 1
#ifdef GLCOREARB_PROTOTYPES
	GLAPI void APIENTRY glClearBufferData(GLenum target, GLenum internalformat, GLenum format, GLenum type, const void *data);
	GLAPI void APIENTRY glClearBufferSubData(GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *data);
	GLAPI void APIENTRY glClearNamedBufferDataEXT(GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void *data);
	GLAPI void APIENTRY glClearNamedBufferSubDataEXT(GLuint buffer, GLenum internalformat, GLenum format, GLenum type, GLsizeiptr offset, GLsizeiptr size, const void *data);
#endif /* GLCOREARB_PROTOTYPES */
	typedef void (APIENTRYP PFNGLCLEARBUFFERDATAPROC) (GLenum target, GLenum internalformat, GLenum format, GLenum type, const void *data);
	typedef void (APIENTRYP PFNGLCLEARBUFFERSUBDATAPROC) (GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *data);
	typedef void (APIENTRYP PFNGLCLEARNAMEDBUFFERDATAEXTPROC) (GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void *data);
	typedef void (APIENTRYP PFNGLCLEARNAMEDBUFFERSUBDATAEXTPROC) (GLuint buffer, GLenum internalformat, GLenum format, GLenum type, GLsizeiptr offset, GLsizeiptr size, const void *data);
#endif

#ifndef GL_ARB_compute_shader
#define GL_ARB_compute_shader 1
#ifdef GLCOREARB_PROTOTYPES
	GLAPI void APIENTRY glDispatchCompute(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z);
	GLAPI void APIENTRY glDispatchComputeIndirect(GLintptr indirect);
#endif /* GLCOREARB_PROTOTYPES */
	typedef void (APIENTRYP PFNGLDISPATCHCOMPUTEPROC) (GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z);
	typedef void (APIENTRYP PFNGLDISPATCHCOMPUTEINDIRECTPROC) (GLintptr indirect);
#endif

#ifndef GL_ARB_copy_image
#define GL_ARB_copy_image 1
#ifdef GLCOREARB_PROTOTYPES
	GLAPI void APIENTRY glCopyImageSubData(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth);
#endif /* GLCOREARB_PROTOTYPES */
	typedef void (APIENTRYP PFNGLCOPYIMAGESUBDATAPROC) (GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth);
#endif

#ifndef GL_ARB_texture_view
#define GL_ARB_texture_view 1
#ifdef GLCOREARB_PROTOTYPES
	GLAPI void APIENTRY glTextureView(GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers);
#endif /* GLCOREARB_PROTOTYPES */
	typedef void (APIENTRYP PFNGLTEXTUREVIEWPROC) (GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers);
#endif

#ifndef GL_ARB_vertex_attrib_binding
#define GL_ARB_vertex_attrib_binding 1
#ifdef GLCOREARB_PROTOTYPES
	GLAPI void APIENTRY glBindVertexBuffer(GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
	GLAPI void APIENTRY glVertexAttribFormat(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
	GLAPI void APIENTRY glVertexAttribIFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
	GLAPI void APIENTRY glVertexAttribLFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
	GLAPI void APIENTRY glVertexAttribBinding(GLuint attribindex, GLuint bindingindex);
	GLAPI void APIENTRY glVertexBindingDivisor(GLuint bindingindex, GLuint divisor);
	GLAPI void APIENTRY glVertexArrayBindVertexBufferEXT(GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
	GLAPI void APIENTRY glVertexArrayVertexAttribFormatEXT(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
	GLAPI void APIENTRY glVertexArrayVertexAttribIFormatEXT(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
	GLAPI void APIENTRY glVertexArrayVertexAttribLFormatEXT(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
	GLAPI void APIENTRY glVertexArrayVertexAttribBindingEXT(GLuint vaobj, GLuint attribindex, GLuint bindingindex);
	GLAPI void APIENTRY glVertexArrayVertexBindingDivisorEXT(GLuint vaobj, GLuint bindingindex, GLuint divisor);
#endif /* GLCOREARB_PROTOTYPES */
	typedef void (APIENTRYP PFNGLBINDVERTEXBUFFERPROC) (GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBFORMATPROC) (GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBIFORMATPROC) (GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBLFORMATPROC) (GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBBINDINGPROC) (GLuint attribindex, GLuint bindingindex);
	typedef void (APIENTRYP PFNGLVERTEXBINDINGDIVISORPROC) (GLuint bindingindex, GLuint divisor);
	typedef void (APIENTRYP PFNGLVERTEXARRAYBINDVERTEXBUFFEREXTPROC) (GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
	typedef void (APIENTRYP PFNGLVERTEXARRAYVERTEXATTRIBFORMATEXTPROC) (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
	typedef void (APIENTRYP PFNGLVERTEXARRAYVERTEXATTRIBIFORMATEXTPROC) (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
	typedef void (APIENTRYP PFNGLVERTEXARRAYVERTEXATTRIBLFORMATEXTPROC) (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
	typedef void (APIENTRYP PFNGLVERTEXARRAYVERTEXATTRIBBINDINGEXTPROC) (GLuint vaobj, GLuint attribindex, GLuint bindingindex);
	typedef void (APIENTRYP PFNGLVERTEXARRAYVERTEXBINDINGDIVISOREXTPROC) (GLuint vaobj, GLuint bindingindex, GLuint divisor);
#endif

#ifndef GL_ARB_robustness_isolation
#define GL_ARB_robustness_isolation 1
#endif

#ifndef GL_ARB_ES3_compatibility
#define GL_ARB_ES3_compatibility 1
#endif

#ifndef GL_ARB_explicit_uniform_location
#define GL_ARB_explicit_uniform_location 1
#endif

#ifndef GL_ARB_fragment_layer_viewport
#define GL_ARB_fragment_layer_viewport 1
#endif

#ifndef GL_ARB_framebuffer_no_attachments
#define GL_ARB_framebuffer_no_attachments 1
#ifdef GLCOREARB_PROTOTYPES
	GLAPI void APIENTRY glFramebufferParameteri(GLenum target, GLenum pname, GLint param);
	GLAPI void APIENTRY glGetFramebufferParameteriv(GLenum target, GLenum pname, GLint *params);
	GLAPI void APIENTRY glNamedFramebufferParameteriEXT(GLuint framebuffer, GLenum pname, GLint param);
	GLAPI void APIENTRY glGetNamedFramebufferParameterivEXT(GLuint framebuffer, GLenum pname, GLint *params);
#endif /* GLCOREARB_PROTOTYPES */
	typedef void (APIENTRYP PFNGLFRAMEBUFFERPARAMETERIPROC) (GLenum target, GLenum pname, GLint param);
	typedef void (APIENTRYP PFNGLGETFRAMEBUFFERPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
	typedef void (APIENTRYP PFNGLNAMEDFRAMEBUFFERPARAMETERIEXTPROC) (GLuint framebuffer, GLenum pname, GLint param);
	typedef void (APIENTRYP PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVEXTPROC) (GLuint framebuffer, GLenum pname, GLint *params);
#endif

#ifndef GL_ARB_internalformat_query2
#define GL_ARB_internalformat_query2 1
#ifdef GLCOREARB_PROTOTYPES
	GLAPI void APIENTRY glGetInternalformati64v(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint64 *params);
#endif /* GLCOREARB_PROTOTYPES */
	typedef void (APIENTRYP PFNGLGETINTERNALFORMATI64VPROC) (GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint64 *params);
#endif

#ifndef GL_ARB_invalidate_subdata
#define GL_ARB_invalidate_subdata 1
#ifdef GLCOREARB_PROTOTYPES
	GLAPI void APIENTRY glInvalidateTexSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth);
	GLAPI void APIENTRY glInvalidateTexImage(GLuint texture, GLint level);
	GLAPI void APIENTRY glInvalidateBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr length);
	GLAPI void APIENTRY glInvalidateBufferData(GLuint buffer);
	GLAPI void APIENTRY glInvalidateFramebuffer(GLenum target, GLsizei numAttachments, const GLenum *attachments);
	GLAPI void APIENTRY glInvalidateSubFramebuffer(GLenum target, GLsizei numAttachments, const GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height);
#endif /* GLCOREARB_PROTOTYPES */
	typedef void (APIENTRYP PFNGLINVALIDATETEXSUBIMAGEPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth);
	typedef void (APIENTRYP PFNGLINVALIDATETEXIMAGEPROC) (GLuint texture, GLint level);
	typedef void (APIENTRYP PFNGLINVALIDATEBUFFERSUBDATAPROC) (GLuint buffer, GLintptr offset, GLsizeiptr length);
	typedef void (APIENTRYP PFNGLINVALIDATEBUFFERDATAPROC) (GLuint buffer);
	typedef void (APIENTRYP PFNGLINVALIDATEFRAMEBUFFERPROC) (GLenum target, GLsizei numAttachments, const GLenum *attachments);
	typedef void (APIENTRYP PFNGLINVALIDATESUBFRAMEBUFFERPROC) (GLenum target, GLsizei numAttachments, const GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height);
#endif

#ifndef GL_ARB_multi_draw_indirect
#define GL_ARB_multi_draw_indirect 1
#ifdef GLCOREARB_PROTOTYPES
	GLAPI void APIENTRY glMultiDrawArraysIndirect(GLenum mode, const void *indirect, GLsizei drawcount, GLsizei stride);
	GLAPI void APIENTRY glMultiDrawElementsIndirect(GLenum mode, GLenum type, const void *indirect, GLsizei drawcount, GLsizei stride);
#endif /* GLCOREARB_PROTOTYPES */
	typedef void (APIENTRYP PFNGLMULTIDRAWARRAYSINDIRECTPROC) (GLenum mode, const void *indirect, GLsizei drawcount, GLsizei stride);
	typedef void (APIENTRYP PFNGLMULTIDRAWELEMENTSINDIRECTPROC) (GLenum mode, GLenum type, const void *indirect, GLsizei drawcount, GLsizei stride);
#endif

#ifndef GL_ARB_program_interface_query
#define GL_ARB_program_interface_query 1
#ifdef GLCOREARB_PROTOTYPES
	GLAPI void APIENTRY glGetProgramInterfaceiv(GLuint program, GLenum programInterface, GLenum pname, GLint *params);
	GLAPI GLuint APIENTRY glGetProgramResourceIndex(GLuint program, GLenum programInterface, const GLchar *name);
	GLAPI void APIENTRY glGetProgramResourceName(GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name);
	GLAPI void APIENTRY glGetProgramResourceiv(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum *props, GLsizei bufSize, GLsizei *length, GLint *params);
	GLAPI GLint APIENTRY glGetProgramResourceLocation(GLuint program, GLenum programInterface, const GLchar *name);
	GLAPI GLint APIENTRY glGetProgramResourceLocationIndex(GLuint program, GLenum programInterface, const GLchar *name);
#endif /* GLCOREARB_PROTOTYPES */
	typedef void (APIENTRYP PFNGLGETPROGRAMINTERFACEIVPROC) (GLuint program, GLenum programInterface, GLenum pname, GLint *params);
	typedef GLuint(APIENTRYP PFNGLGETPROGRAMRESOURCEINDEXPROC) (GLuint program, GLenum programInterface, const GLchar *name);
	typedef void (APIENTRYP PFNGLGETPROGRAMRESOURCENAMEPROC) (GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name);
	typedef void (APIENTRYP PFNGLGETPROGRAMRESOURCEIVPROC) (GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum *props, GLsizei bufSize, GLsizei *length, GLint *params);
	typedef GLint(APIENTRYP PFNGLGETPROGRAMRESOURCELOCATIONPROC) (GLuint program, GLenum programInterface, const GLchar *name);
	typedef GLint(APIENTRYP PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC) (GLuint program, GLenum programInterface, const GLchar *name);
#endif

#ifndef GL_ARB_robust_buffer_access_behavior
#define GL_ARB_robust_buffer_access_behavior 1
#endif

#ifndef GL_ARB_shader_image_size
#define GL_ARB_shader_image_size 1
#endif

#ifndef GL_ARB_shader_storage_buffer_object
#define GL_ARB_shader_storage_buffer_object 1
#ifdef GLCOREARB_PROTOTYPES
	GLAPI void APIENTRY glShaderStorageBlockBinding(GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding);
#endif /* GLCOREARB_PROTOTYPES */
	typedef void (APIENTRYP PFNGLSHADERSTORAGEBLOCKBINDINGPROC) (GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding);
#endif

#ifndef GL_ARB_stencil_texturing
#define GL_ARB_stencil_texturing 1
#endif

#ifndef GL_ARB_texture_buffer_range
#define GL_ARB_texture_buffer_range 1
#ifdef GLCOREARB_PROTOTYPES
	GLAPI void APIENTRY glTexBufferRange(GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
	GLAPI void APIENTRY glTextureBufferRangeEXT(GLuint texture, GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
#endif /* GLCOREARB_PROTOTYPES */
	typedef void (APIENTRYP PFNGLTEXBUFFERRANGEPROC) (GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
	typedef void (APIENTRYP PFNGLTEXTUREBUFFERRANGEEXTPROC) (GLuint texture, GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
#endif

#ifndef GL_ARB_texture_query_levels
#define GL_ARB_texture_query_levels 1
#endif

#ifndef GL_ARB_texture_storage_multisample
#define GL_ARB_texture_storage_multisample 1
#ifdef GLCOREARB_PROTOTYPES
	GLAPI void APIENTRY glTexStorage2DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
	GLAPI void APIENTRY glTexStorage3DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
	GLAPI void APIENTRY glTextureStorage2DMultisampleEXT(GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
	GLAPI void APIENTRY glTextureStorage3DMultisampleEXT(GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
#endif /* GLCOREARB_PROTOTYPES */
	typedef void (APIENTRYP PFNGLTEXSTORAGE2DMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
	typedef void (APIENTRYP PFNGLTEXSTORAGE3DMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
	typedef void (APIENTRYP PFNGLTEXTURESTORAGE2DMULTISAMPLEEXTPROC) (GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
	typedef void (APIENTRYP PFNGLTEXTURESTORAGE3DMULTISAMPLEEXTPROC) (GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
#endif


#ifdef __cplusplus
}
#endif

#endif
```

`sakura/libs/opengl/glu.h`:

```h
/*++ BUILD Version: 0004    // Increment this if a change has global effects

Copyright (c) 1985-95, Microsoft Corporation

Module Name:

    glu.h

Abstract:

    Procedure declarations, constant definitions and macros for the OpenGL
    Utility Library.

--*/

#ifndef __glu_h__
#ifndef __GLU_H__

#define __glu_h__
#define __GLU_H__

#include <winapifamily.h>
#include "gl.h"

#ifdef __cplusplus
extern "C" {
#endif

/*
** Copyright 1991-1993, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#pragma region Desktop Family
#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

/*
** Return the error string associated with a particular error code.
** This will return 0 for an invalid error code.
**
** The generic function prototype that can be compiled for ANSI or Unicode
** is defined as follows:
**
** LPCTSTR APIENTRY gluErrorStringWIN (GLenum errCode);
*/
#ifdef UNICODE
#define gluErrorStringWIN(errCode) ((LPCSTR)  gluErrorUnicodeStringEXT(errCode))
#else
#define gluErrorStringWIN(errCode) ((LPCWSTR) gluErrorString(errCode))
#endif

const GLubyte* APIENTRY gluErrorString (
    GLenum   errCode);

const wchar_t* APIENTRY gluErrorUnicodeStringEXT (
    GLenum   errCode);

const GLubyte* APIENTRY gluGetString (
    GLenum   name);

void APIENTRY gluOrtho2D (
    GLdouble left, 
    GLdouble right, 
    GLdouble bottom, 
    GLdouble top);

void APIENTRY gluPerspective (
    GLdouble fovy, 
    GLdouble aspect, 
    GLdouble zNear, 
    GLdouble zFar);

void APIENTRY gluPickMatrix (
    GLdouble x, 
    GLdouble y, 
    GLdouble width, 
    GLdouble height, 
    GLint    viewport[4]);

void APIENTRY gluLookAt (
    GLdouble eyex, 
    GLdouble eyey, 
    GLdouble eyez, 
    GLdouble centerx, 
    GLdouble centery, 
    GLdouble centerz, 
    GLdouble upx, 
    GLdouble upy, 
    GLdouble upz);

int APIENTRY gluProject (
    GLdouble        objx, 
    GLdouble        objy, 
    GLdouble        objz,  
    const GLdouble  modelMatrix[16], 
    const GLdouble  projMatrix[16], 
    const GLint     viewport[4], 
    GLdouble        *winx, 
    GLdouble        *winy, 
    GLdouble        *winz);

int APIENTRY gluUnProject (
    GLdouble       winx, 
    GLdouble       winy, 
    GLdouble       winz, 
    const GLdouble modelMatrix[16], 
    const GLdouble projMatrix[16], 
    const GLint    viewport[4], 
    GLdouble       *objx, 
    GLdouble       *objy, 
    GLdouble       *objz);


int APIENTRY gluScaleImage (
    GLenum      format, 
    GLint       widthin, 
    GLint       heightin, 
    GLenum      typein, 
    const void  *datain, 
    GLint       widthout, 
    GLint       heightout, 
    GLenum      typeout, 
    void        *dataout);


int APIENTRY gluBuild1DMipmaps (
    GLenum      target, 
    GLint       components, 
    GLint       width, 
    GLenum      format, 
    GLenum      type, 
    const void  *data);

int APIENTRY gluBuild2DMipmaps (
    GLenum      target, 
    GLint       components, 
    GLint       width, 
    GLint       height, 
    GLenum      format, 
    GLenum      type, 
    const void  *data);

#ifdef __cplusplus

class GLUnurbs;
class GLUquadric;
class GLUtesselator;

/* backwards compatibility: */
typedef class GLUnurbs GLUnurbsObj;
typedef class GLUquadric GLUquadricObj;
typedef class GLUtesselator GLUtesselatorObj;
typedef class GLUtesselator GLUtriangulatorObj;

#else

typedef struct GLUnurbs GLUnurbs;
typedef struct GLUquadric GLUquadric;
typedef struct GLUtesselator GLUtesselator;

/* backwards compatibility: */
typedef struct GLUnurbs GLUnurbsObj;
typedef struct GLUquadric GLUquadricObj;
typedef struct GLUtesselator GLUtesselatorObj;
typedef struct GLUtesselator GLUtriangulatorObj;

#endif


GLUquadric* APIENTRY gluNewQuadric (void);
void APIENTRY gluDeleteQuadric (
    GLUquadric          *state);

void APIENTRY gluQuadricNormals (
    GLUquadric          *quadObject, 
    GLenum              normals);

void APIENTRY gluQuadricTexture (
    GLUquadric          *quadObject, 
    GLboolean           textureCoords);

void APIENTRY gluQuadricOrientation (
    GLUquadric          *quadObject, 
    GLenum              orientation);

void APIENTRY gluQuadricDrawStyle (
    GLUquadric          *quadObject, 
    GLenum              drawStyle);

void APIENTRY gluCylinder (
    GLUquadric          *qobj, 
    GLdouble            baseRadius, 
    GLdouble            topRadius, 
    GLdouble            height, 
    GLint               slices, 
    GLint               stacks);

void APIENTRY gluDisk (
    GLUquadric          *qobj, 
    GLdouble            innerRadius, 
    GLdouble            outerRadius, 
    GLint               slices, 
    GLint               loops);

void APIENTRY gluPartialDisk (
    GLUquadric          *qobj, 
    GLdouble            innerRadius, 
    GLdouble            outerRadius, 
    GLint               slices, 
    GLint               loops, 
    GLdouble            startAngle, 
    GLdouble            sweepAngle);

void APIENTRY gluSphere (
    GLUquadric          *qobj, 
    GLdouble            radius, 
    GLint               slices, 
    GLint               stacks);

void APIENTRY gluQuadricCallback (
    GLUquadric          *qobj, 
    GLenum              which, 
    void                (CALLBACK* fn)());

GLUtesselator* APIENTRY  gluNewTess(          
    void );

void APIENTRY  gluDeleteTess(       
    GLUtesselator       *tess );

void APIENTRY  gluTessBeginPolygon( 
    GLUtesselator       *tess,
    void                *polygon_data );

void APIENTRY  gluTessBeginContour( 
    GLUtesselator       *tess );

void APIENTRY  gluTessVertex(       
    GLUtesselator       *tess,
    GLdouble            coords[3], 
    void                *data );

void APIENTRY  gluTessEndContour(   
    GLUtesselator       *tess );

void APIENTRY  gluTessEndPolygon(   
    GLUtesselator       *tess );

void APIENTRY  gluTessProperty(     
    GLUtesselator       *tess,
    GLenum              which, 
    GLdouble            value );
 
void APIENTRY  gluTessNormal(       
    GLUtesselator       *tess, 
    GLdouble            x,
    GLdouble            y, 
    GLdouble            z );

void APIENTRY  gluTessCallback(     
    GLUtesselator       *tess,
    GLenum              which, 
    void                (CALLBACK *fn)());

void APIENTRY  gluGetTessProperty(  
    GLUtesselator       *tess,
    GLenum              which, 
    GLdouble            *value );
 
GLUnurbs* APIENTRY gluNewNurbsRenderer (void);

void APIENTRY gluDeleteNurbsRenderer (
    GLUnurbs            *nobj);

void APIENTRY gluBeginSurface (
    GLUnurbs            *nobj);

void APIENTRY gluBeginCurve (
    GLUnurbs            *nobj);

void APIENTRY gluEndCurve (
    GLUnurbs            *nobj);

void APIENTRY gluEndSurface (
    GLUnurbs            *nobj);

void APIENTRY gluBeginTrim (
    GLUnurbs            *nobj);

void APIENTRY gluEndTrim (
    GLUnurbs            *nobj);

void APIENTRY gluPwlCurve (
    GLUnurbs            *nobj, 
    GLint               count, 
    GLfloat             *array, 
    GLint               stride, 
    GLenum              type);

void APIENTRY gluNurbsCurve (
    GLUnurbs            *nobj, 
    GLint               nknots, 
    GLfloat             *knot, 
    GLint               stride, 
    GLfloat             *ctlarray, 
    GLint               order, 
    GLenum              type);

void APIENTRY 
gluNurbsSurface(     
    GLUnurbs            *nobj, 
    GLint               sknot_count, 
    float               *sknot, 
    GLint               tknot_count, 
    GLfloat             *tknot, 
    GLint               s_stride, 
    GLint               t_stride, 
    GLfloat             *ctlarray, 
    GLint               sorder, 
    GLint               torder, 
    GLenum              type);

void APIENTRY 
gluLoadSamplingMatrices (
    GLUnurbs            *nobj, 
    const GLfloat       modelMatrix[16], 
    const GLfloat       projMatrix[16], 
    const GLint         viewport[4] );

void APIENTRY 
gluNurbsProperty (
    GLUnurbs            *nobj, 
    GLenum              property, 
    GLfloat             value );

void APIENTRY 
gluGetNurbsProperty (
    GLUnurbs            *nobj, 
    GLenum              property, 
    GLfloat             *value );

void APIENTRY 
gluNurbsCallback (
    GLUnurbs            *nobj, 
    GLenum              which, 
    void                (CALLBACK* fn)() );


/****           Callback function prototypes    ****/

/* gluQuadricCallback */
typedef void (CALLBACK* GLUquadricErrorProc) (GLenum);

/* gluTessCallback */
typedef void (CALLBACK* GLUtessBeginProc)        (GLenum);
typedef void (CALLBACK* GLUtessEdgeFlagProc)     (GLboolean);
typedef void (CALLBACK* GLUtessVertexProc)       (void *);
typedef void (CALLBACK* GLUtessEndProc)          (void);
typedef void (CALLBACK* GLUtessErrorProc)        (GLenum);
typedef void (CALLBACK* GLUtessCombineProc)      (GLdouble[3],
                                                  void*[4], 
                                                  GLfloat[4],
                                                  void** );
typedef void (CALLBACK* GLUtessBeginDataProc)    (GLenum, void *);
typedef void (CALLBACK* GLUtessEdgeFlagDataProc) (GLboolean, void *);
typedef void (CALLBACK* GLUtessVertexDataProc)   (void *, void *);
typedef void (CALLBACK* GLUtessEndDataProc)      (void *);
typedef void (CALLBACK* GLUtessErrorDataProc)    (GLenum, void *);
typedef void (CALLBACK* GLUtessCombineDataProc)  (GLdouble[3],
                                                  void*[4], 
                                                  GLfloat[4],
                                                  void**,
                                                  void* );

/* gluNurbsCallback */
typedef void (CALLBACK* GLUnurbsErrorProc)   (GLenum);


/****           Generic constants               ****/

/* Version */
#define GLU_VERSION_1_1                 1
#define GLU_VERSION_1_2                 1

/* Errors: (return value 0 = no error) */
#define GLU_INVALID_ENUM        100900
#define GLU_INVALID_VALUE       100901
#define GLU_OUT_OF_MEMORY       100902
#define GLU_INCOMPATIBLE_GL_VERSION     100903

/* StringName */
#define GLU_VERSION             100800
#define GLU_EXTENSIONS          100801

/* Boolean */
#define GLU_TRUE                GL_TRUE
#define GLU_FALSE               GL_FALSE


/****           Quadric constants               ****/

/* QuadricNormal */
#define GLU_SMOOTH              100000
#define GLU_FLAT                100001
#define GLU_NONE                100002

/* QuadricDrawStyle */
#define GLU_POINT               100010
#define GLU_LINE                100011
#define GLU_FILL                100012
#define GLU_SILHOUETTE          100013

/* QuadricOrientation */
#define GLU_OUTSIDE             100020
#define GLU_INSIDE              100021

/* Callback types: */
/*      GLU_ERROR               100103 */


/****           Tesselation constants           ****/

#define GLU_TESS_MAX_COORD              1.0e150

/* TessProperty */
#define GLU_TESS_WINDING_RULE           100140
#define GLU_TESS_BOUNDARY_ONLY          100141
#define GLU_TESS_TOLERANCE              100142

/* TessWinding */
#define GLU_TESS_WINDING_ODD            100130
#define GLU_TESS_WINDING_NONZERO        100131
#define GLU_TESS_WINDING_POSITIVE       100132
#define GLU_TESS_WINDING_NEGATIVE       100133
#define GLU_TESS_WINDING_ABS_GEQ_TWO    100134

/* TessCallback */
#define GLU_TESS_BEGIN          100100  /* void (CALLBACK*)(GLenum    type)  */
#define GLU_TESS_VERTEX         100101  /* void (CALLBACK*)(void      *data) */
#define GLU_TESS_END            100102  /* void (CALLBACK*)(void)            */
#define GLU_TESS_ERROR          100103  /* void (CALLBACK*)(GLenum    errno) */
#define GLU_TESS_EDGE_FLAG      100104  /* void (CALLBACK*)(GLboolean boundaryEdge)  */
#define GLU_TESS_COMBINE        100105  /* void (CALLBACK*)(GLdouble  coords[3],
                                                            void      *data[4],
                                                            GLfloat   weight[4],
                                                            void      **dataOut)     */
#define GLU_TESS_BEGIN_DATA     100106  /* void (CALLBACK*)(GLenum    type,  
                                                            void      *polygon_data) */
#define GLU_TESS_VERTEX_DATA    100107  /* void (CALLBACK*)(void      *data, 
                                                            void      *polygon_data) */
#define GLU_TESS_END_DATA       100108  /* void (CALLBACK*)(void      *polygon_data) */
#define GLU_TESS_ERROR_DATA     100109  /* void (CALLBACK*)(GLenum    errno, 
                                                            void      *polygon_data) */
#define GLU_TESS_EDGE_FLAG_DATA 100110  /* void (CALLBACK*)(GLboolean boundaryEdge,
                                                            void      *polygon_data) */
#define GLU_TESS_COMBINE_DATA   100111  /* void (CALLBACK*)(GLdouble  coords[3],
                                                            void      *data[4],
                                                            GLfloat   weight[4],
                                                            void      **dataOut,
                                                            void      *polygon_data) */

/* TessError */
#define GLU_TESS_ERROR1     100151
#define GLU_TESS_ERROR2     100152
#define GLU_TESS_ERROR3     100153
#define GLU_TESS_ERROR4     100154
#define GLU_TESS_ERROR5     100155
#define GLU_TESS_ERROR6     100156
#define GLU_TESS_ERROR7     100157
#define GLU_TESS_ERROR8     100158

#define GLU_TESS_MISSING_BEGIN_POLYGON  GLU_TESS_ERROR1
#define GLU_TESS_MISSING_BEGIN_CONTOUR  GLU_TESS_ERROR2
#define GLU_TESS_MISSING_END_POLYGON    GLU_TESS_ERROR3
#define GLU_TESS_MISSING_END_CONTOUR    GLU_TESS_ERROR4
#define GLU_TESS_COORD_TOO_LARGE        GLU_TESS_ERROR5
#define GLU_TESS_NEED_COMBINE_CALLBACK  GLU_TESS_ERROR6

/****           NURBS constants                 ****/

/* NurbsProperty */
#define GLU_AUTO_LOAD_MATRIX    100200
#define GLU_CULLING             100201
#define GLU_SAMPLING_TOLERANCE  100203
#define GLU_DISPLAY_MODE        100204
#define GLU_PARAMETRIC_TOLERANCE        100202
#define GLU_SAMPLING_METHOD             100205
#define GLU_U_STEP                      100206
#define GLU_V_STEP                      100207

/* NurbsSampling */
#define GLU_PATH_LENGTH                 100215
#define GLU_PARAMETRIC_ERROR            100216
#define GLU_DOMAIN_DISTANCE             100217


/* NurbsTrim */
#define GLU_MAP1_TRIM_2         100210
#define GLU_MAP1_TRIM_3         100211

/* NurbsDisplay */
/*      GLU_FILL                100012 */
#define GLU_OUTLINE_POLYGON     100240
#define GLU_OUTLINE_PATCH       100241

/* NurbsCallback */
/*      GLU_ERROR               100103 */

/* NurbsErrors */
#define GLU_NURBS_ERROR1        100251
#define GLU_NURBS_ERROR2        100252
#define GLU_NURBS_ERROR3        100253
#define GLU_NURBS_ERROR4        100254
#define GLU_NURBS_ERROR5        100255
#define GLU_NURBS_ERROR6        100256
#define GLU_NURBS_ERROR7        100257
#define GLU_NURBS_ERROR8        100258
#define GLU_NURBS_ERROR9        100259
#define GLU_NURBS_ERROR10       100260
#define GLU_NURBS_ERROR11       100261
#define GLU_NURBS_ERROR12       100262
#define GLU_NURBS_ERROR13       100263
#define GLU_NURBS_ERROR14       100264
#define GLU_NURBS_ERROR15       100265
#define GLU_NURBS_ERROR16       100266
#define GLU_NURBS_ERROR17       100267
#define GLU_NURBS_ERROR18       100268
#define GLU_NURBS_ERROR19       100269
#define GLU_NURBS_ERROR20       100270
#define GLU_NURBS_ERROR21       100271
#define GLU_NURBS_ERROR22       100272
#define GLU_NURBS_ERROR23       100273
#define GLU_NURBS_ERROR24       100274
#define GLU_NURBS_ERROR25       100275
#define GLU_NURBS_ERROR26       100276
#define GLU_NURBS_ERROR27       100277
#define GLU_NURBS_ERROR28       100278
#define GLU_NURBS_ERROR29       100279
#define GLU_NURBS_ERROR30       100280
#define GLU_NURBS_ERROR31       100281
#define GLU_NURBS_ERROR32       100282
#define GLU_NURBS_ERROR33       100283
#define GLU_NURBS_ERROR34       100284
#define GLU_NURBS_ERROR35       100285
#define GLU_NURBS_ERROR36       100286
#define GLU_NURBS_ERROR37       100287

/****           Backwards compatibility for old tesselator           ****/

void APIENTRY   gluBeginPolygon( GLUtesselator *tess );

void APIENTRY   gluNextContour(  GLUtesselator *tess, 
                                 GLenum        type );

void APIENTRY   gluEndPolygon(   GLUtesselator *tess );

/* Contours types -- obsolete! */
#define GLU_CW          100120
#define GLU_CCW         100121
#define GLU_INTERIOR    100122
#define GLU_EXTERIOR    100123
#define GLU_UNKNOWN     100124

/* Names without "TESS_" prefix */
#define GLU_BEGIN       GLU_TESS_BEGIN
#define GLU_VERTEX      GLU_TESS_VERTEX
#define GLU_END         GLU_TESS_END
#define GLU_ERROR       GLU_TESS_ERROR
#define GLU_EDGE_FLAG   GLU_TESS_EDGE_FLAG

#endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
#pragma endregion

#ifdef __cplusplus
}
#endif

#endif /* __GLU_H__ */
#endif /* __glu_h__ */

```

`sakura/libs/xor/xorstr.h`:

```h
/************************************************************************************************************************************
*
*
* 007 HOOK
* Code By: 007 + boy_scout
* msn: david_bs@live.com
* (c)2011
* www.etalking.com.ar
*
*
************************************************************************************************************************************/

#pragma once

///////////////////////////////////////////////////////////////////////////////////////////////////////////

#undef KEY
#undef BUFLEN

///////////////////////////////////////////////////////////////////////////////////////////////////////////

template <int XORSTART, int BUFLEN, int XREFKILLER>

///////////////////////////////////////////////////////////////////////////////////////////////////////////

class XorStr
{
	private: 
		 XorStr();
	public: 
		char s[BUFLEN];

		 XorStr(const char* xs);
#ifndef DEBUG_OPTION
		 ~XorStr(){ for(int i=0;i<BUFLEN;i++)s[i]=0;} // clear string from stack
#endif
};

///////////////////////////////////////////////////////////////////////////////////////////////////////////

template <int XORSTART, int BUFLEN, int XREFKILLER>

///////////////////////////////////////////////////////////////////////////////////////////////////////////

XorStr<XORSTART,BUFLEN,XREFKILLER>::XorStr(const char* xs)
{
	int xvalue = XORSTART;
	int i = 0;
	for(;i<(BUFLEN-1);i++) {
		s[i] = xs[i-XREFKILLER]^xvalue;
		xvalue += 1;
		xvalue %= 256;
	}
	s[BUFLEN-1] = 0;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////

```

`sakura/loader/injector.cpp`:

```cpp
#include "Injector.h"

Injector::OS_VER OsVer;
bool IsGotOsVer = false;

Injector::OS_API OsApi = { NULL };
bool IsGotOsApi = false;

DWORD LoadLibraryAddress = NULL;
#pragma pack( 1 )
struct INJECT_CODE
{
    BYTE  PushOpc;
    DWORD PushAdr;
    BYTE  CallOpc;
    DWORD CallAdr;
    BYTE  DoneOpc;
    WORD  DoneAdr;
    char  ModulePath[MAX_PATH];
};
#pragma pack()

HANDLE WINAPI OpenThread9x(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwThreadId);

LPVOID WINAPI VirtualAllocEx9x(HANDLE hProcess, LPVOID lpAddress, DWORD dwSize, DWORD flAllocationType, DWORD flProtect);

BOOL WINAPI VirtualFreeEx9x(HANDLE hProcess, LPVOID lpAddress, DWORD dwSize, DWORD dwFreeType);

DWORD SearchMemory(DWORD start, DWORD length, BYTE* pattern, CHAR* mask);

bool IsSameName(const char* targetString, const char* sourceString);

bool Injector::GetOsVer(OS_VER* osVer)
{
    OSVERSIONINFO OSVI;
    OSVI.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (!GetVersionEx(&OSVI))
        return false;

    osVer->IsWin98 = (OSVI.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS && OSVI.dwMajorVersion == 4 && OSVI.dwMinorVersion <= 10) ? true : false;
    osVer->IsWinMe = (OSVI.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS && OSVI.dwMajorVersion == 4 && OSVI.dwMinorVersion >= 90) ? true : false;
    osVer->IsWinXp = (OSVI.dwPlatformId == VER_PLATFORM_WIN32_NT) ? true : false;

    return true;
}

bool Injector::GetOsApi(OS_API* osApi)
{
    OS_VER osVer;
    if (GetOsVer(&osVer) == false)
        return false;

    HINSTANCE kernel32 = GetModuleHandle("kernel32.dll");
    if (kernel32 == NULL)
    {
        kernel32 = LoadLibrary("kernel32.dll");
        if (kernel32 == NULL)
            return false;
    }

    *(PDWORD)(&osApi->CreateToolhelp32Snapshot) = (DWORD)GetProcAddress(kernel32, "CreateToolhelp32Snapshot");
    *(PDWORD)(&osApi->Process32First) = (DWORD)GetProcAddress(kernel32, "Process32First");
    *(PDWORD)(&osApi->Process32Next) = (DWORD)GetProcAddress(kernel32, "Process32Next");
    *(PDWORD)(&osApi->Module32First) = (DWORD)GetProcAddress(kernel32, "Module32First");
    *(PDWORD)(&osApi->Module32Next) = (DWORD)GetProcAddress(kernel32, "Module32Next");
    *(PDWORD)(&osApi->Thread32First) = (DWORD)GetProcAddress(kernel32, "Thread32First");
    *(PDWORD)(&osApi->Thread32Next) = (DWORD)GetProcAddress(kernel32, "Thread32Next");
    *(PDWORD)(&osApi->OpenProcess) = (DWORD)GetProcAddress(kernel32, "OpenProcess");
    *(PDWORD)(&osApi->OpenThread) = (DWORD)GetProcAddress(kernel32, "OpenThread");
    *(PDWORD)(&osApi->VirtualAllocEx) = (DWORD)GetProcAddress(kernel32, "VirtualAllocEx");
    *(PDWORD)(&osApi->VirtualFreeEx) = (DWORD)GetProcAddress(kernel32, "VirtualFreeEx");

    if (osVer.IsWin98)
    {
        *(PDWORD)(&osApi->OpenThread) = (DWORD)OpenThread9x;
        *(PDWORD)(&osApi->VirtualAllocEx) = (DWORD)VirtualAllocEx9x;
        *(PDWORD)(&osApi->VirtualFreeEx) = (DWORD)VirtualFreeEx9x;
    }
    else if (osVer.IsWinMe)
    {
        *(PDWORD)(&osApi->VirtualAllocEx) = (DWORD)VirtualAllocEx9x;
        *(PDWORD)(&osApi->VirtualFreeEx) = (DWORD)VirtualFreeEx9x;
    }

    return (osApi->CreateToolhelp32Snapshot
        && osApi->Process32First
        && osApi->Process32Next
        && osApi->Module32First
        && osApi->Module32Next
        && osApi->Thread32First
        && osApi->Thread32Next
        && osApi->OpenProcess
        && osApi->OpenThread
        && osApi->VirtualAllocEx
        && osApi->VirtualFreeEx
        );
}

bool Injector::GetProcessInfo(const char* exeName, PROCESS_INFORMATION* processInfo)
{
    if (IsGotOsApi == false)
        if ((IsGotOsApi = GetOsApi(&OsApi)) == false)
            return false;

    HANDLE snapshotProcess = OsApi.CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (snapshotProcess == INVALID_HANDLE_VALUE)
        return false;

    PROCESSENTRY32 PE32;
    PE32.dwSize = sizeof(PROCESSENTRY32);

    bool isExist = false;
    if (OsApi.Process32First(snapshotProcess, &PE32))
    {
        do
        {
            if (IsSameName(PE32.szExeFile, exeName))
            {
                CloseHandle(snapshotProcess);
                isExist = true;

                break;
            }
        } while (isExist == false && OsApi.Process32Next(snapshotProcess, &PE32));
    }

    CloseHandle(snapshotProcess);

    if (isExist == false)
        return false;

    HANDLE snapshotThread = OsApi.CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
    if (snapshotThread == INVALID_HANDLE_VALUE)
        return false;

    THREADENTRY32 TE32;
    TE32.dwSize = sizeof(THREADENTRY32);

    isExist = false;
    if (OsApi.Thread32First(snapshotThread, &TE32))
    {
        do
        {
            if (TE32.th32OwnerProcessID == PE32.th32ProcessID)
            {
                CloseHandle(snapshotThread);
                isExist = true;

                break;
            }
        } while (isExist == false && OsApi.Thread32Next(snapshotThread, &TE32));
    }

    CloseHandle(snapshotThread);

    if (isExist == false)
        return false;

    processInfo->dwProcessId = PE32.th32ProcessID;
    processInfo->hProcess = OsApi.OpenProcess(PROCESS_ALL_ACCESS, FALSE, PE32.th32ProcessID);
    if (processInfo->hProcess == NULL)
        return false;

    processInfo->dwThreadId = TE32.th32ThreadID;
    processInfo->hThread = OsApi.OpenThread(THREAD_ALL_ACCESS, FALSE, TE32.th32ThreadID);
    if (processInfo->hThread == NULL)
    {
        CloseHandle(processInfo->hProcess);

        return false;
    }

    return true;
}

bool Injector::GetModuleInfo(const char* exeName, const char* moduleName, MODULEENTRY32* moduleEntry32)
{
    PROCESS_INFORMATION processInfo;

    if (IsGotOsApi == false)
        if ((IsGotOsApi = GetOsApi(&OsApi)) == false)
            return false;

    if (GetProcessInfo(exeName, &processInfo) == false)
        return false;

    HANDLE snapshotModule = OsApi.CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, processInfo.dwProcessId);
    if (snapshotModule == INVALID_HANDLE_VALUE)
    {
        CloseHandle(processInfo.hThread);
        CloseHandle(processInfo.hProcess);

        return false;
    }

    MODULEENTRY32 ME32;
    ME32.dwSize = sizeof(MODULEENTRY32);
    if (OsApi.Module32First(snapshotModule, &ME32))
    {
        do
        {
            if (IsSameName(ME32.szExePath, moduleName))
            {
                if (moduleEntry32 != NULL)
                    *moduleEntry32 = ME32;

                CloseHandle(processInfo.hThread);
                CloseHandle(processInfo.hProcess);
                CloseHandle(snapshotModule);

                return true;
            }
        } while (OsApi.Module32Next(snapshotModule, &ME32));
    }

    CloseHandle(processInfo.hThread);
    CloseHandle(processInfo.hProcess);
    CloseHandle(snapshotModule);

    return false;
}

bool Injector::InjectModule(const char* exeName, const char* modulePath)
{
    PROCESS_INFORMATION processInfo;
    DWORD beginPosition, endPosition;
    INJECT_CODE injectCode;

    if (IsGotOsVer == false)
        if ((IsGotOsVer = GetOsVer(&OsVer)) == false)
            return false;

    if (IsGotOsApi == false)
        if ((IsGotOsApi = GetOsApi(&OsApi)) == false)
            return false;

    if (GetModuleInfo(exeName, modulePath, NULL) == true)
        return true;

    if (GetProcessInfo(exeName, &processInfo) == false)
        return false;

    if (LoadLibraryAddress == NULL)
    {
        HINSTANCE kernel32 = GetModuleHandle("kernel32.dll");
        if (kernel32 == NULL)
        {
            kernel32 = LoadLibrary("kernel32.dll");
            if (kernel32 == NULL)
                return false;
        }

        if ((LoadLibraryAddress = (DWORD)GetProcAddress(kernel32, "LoadLibraryA")) == NULL)
        {
            CloseHandle(processInfo.hThread);
            CloseHandle(processInfo.hProcess);

            return false;
        }
    }

    beginPosition = (DWORD)OsApi.VirtualAllocEx(processInfo.hProcess, NULL, sizeof(INJECT_CODE), MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    if (beginPosition == NULL)
    {
        CloseHandle(processInfo.hThread);
        CloseHandle(processInfo.hProcess);

        return false;
    }

    endPosition = beginPosition + offsetof(INJECT_CODE, DoneOpc);

    injectCode.PushOpc = 0x68;
    injectCode.PushAdr = beginPosition + offsetof(INJECT_CODE, ModulePath);
    injectCode.CallOpc = 0xE8;
    injectCode.CallAdr = LoadLibraryAddress - endPosition;
    if (OsVer.IsWin98 || OsVer.IsWinMe)
    {
        injectCode.DoneOpc = 0xEB;
        injectCode.DoneAdr = 0xFE;
    }
    else
    {
        injectCode.DoneOpc = 0xC2;
        injectCode.DoneAdr = 0x0004;
    }
    strcpy_s(injectCode.ModulePath, MAX_PATH, modulePath);

    if (!WriteProcessMemory(processInfo.hProcess, (VOID*)beginPosition, &injectCode, sizeof(INJECT_CODE), NULL))
    {
        OsApi.VirtualFreeEx(processInfo.hProcess, (VOID*)beginPosition, sizeof(INJECT_CODE), MEM_DECOMMIT);
        CloseHandle(processInfo.hThread);
        CloseHandle(processInfo.hProcess);

        return false;
    }

    if (OsVer.IsWin98 || OsVer.IsWinMe)
    {
        if (GetModuleInfo(exeName, "kernel32.dll", NULL) == false)
        {
            OsApi.VirtualFreeEx(processInfo.hProcess, (VOID*)beginPosition, sizeof(INJECT_CODE), MEM_DECOMMIT);
            CloseHandle(processInfo.hThread);
            CloseHandle(processInfo.hProcess);

            return false;
        }
        Sleep(50);

        INT countSuspend;
        CONTEXT orgContext, runContext;

        if (SuspendThread(processInfo.hThread) == 0xFFFFFFFF)
            return false;

        countSuspend = 1;

        orgContext.ContextFlags = CONTEXT_FULL;
        if (!GetThreadContext(processInfo.hThread, &orgContext))
        {
            ResumeThread(processInfo.hThread);
            OsApi.VirtualFreeEx(processInfo.hProcess, (VOID*)beginPosition, sizeof(INJECT_CODE), MEM_DECOMMIT);
            CloseHandle(processInfo.hThread);
            CloseHandle(processInfo.hProcess);

            return false;
        }

        runContext = orgContext;
        runContext.Eip = beginPosition;
        if (!SetThreadContext(processInfo.hThread, &runContext))
        {
            ResumeThread(processInfo.hThread);
            OsApi.VirtualFreeEx(processInfo.hProcess, (VOID*)beginPosition, sizeof(INJECT_CODE), MEM_DECOMMIT);
            CloseHandle(processInfo.hThread);
            CloseHandle(processInfo.hProcess);

            return false;
        }

        while (runContext.Eip != endPosition)
        {
            while (true)
            {
                DWORD returnValue = ResumeThread(processInfo.hThread);

                if (returnValue <= 1)
                {
                    if (returnValue == 1)
                        countSuspend--;

                    break;
                }
                else if (returnValue < 0xFFFFFFFF)
                {
                    countSuspend--;
                }
                else if (returnValue == 0xFFFFFFFF)
                {
                    OsApi.VirtualFreeEx(processInfo.hProcess, (VOID*)beginPosition, sizeof(INJECT_CODE), MEM_DECOMMIT);
                    CloseHandle(processInfo.hThread);
                    CloseHandle(processInfo.hProcess);

                    return false;
                }
            }

            Sleep(50);

            if (SuspendThread(processInfo.hThread) == 0xFFFFFFFF)
            {
                OsApi.VirtualFreeEx(processInfo.hProcess, (VOID*)beginPosition, sizeof(INJECT_CODE), MEM_DECOMMIT);
                CloseHandle(processInfo.hThread);
                CloseHandle(processInfo.hProcess);

                return false;
            }
            countSuspend++;

            if (!GetThreadContext(processInfo.hThread, &runContext))
            {
                if (countSuspend > 0)
                    while (countSuspend-- > 0 && ResumeThread(processInfo.hThread) != 0xFFFFFFFF);
                else if (countSuspend < 0)
                    while (countSuspend++ < 0 && SuspendThread(processInfo.hThread) != 0xFFFFFFFF);

                OsApi.VirtualFreeEx(processInfo.hProcess, (VOID*)beginPosition, sizeof(INJECT_CODE), MEM_DECOMMIT);
                CloseHandle(processInfo.hThread);
                CloseHandle(processInfo.hProcess);

                return false;
            }
        }

        if (!SetThreadContext(processInfo.hThread, &orgContext))
        {
            if (countSuspend > 0)
                while (countSuspend-- > 0 && ResumeThread(processInfo.hThread) != 0xFFFFFFFF);
            else if (countSuspend < 0)
                while (countSuspend++ < 0 && SuspendThread(processInfo.hThread) != 0xFFFFFFFF);

            OsApi.VirtualFreeEx(processInfo.hProcess, (VOID*)beginPosition, sizeof(INJECT_CODE), MEM_DECOMMIT);
            CloseHandle(processInfo.hThread);
            CloseHandle(processInfo.hProcess);

            return false;
        }

        if (countSuspend > 0)
            while (countSuspend-- > 0 && ResumeThread(processInfo.hThread) != 0xFFFFFFFF);
        else if (countSuspend < 0)
            while (countSuspend++ < 0 && SuspendThread(processInfo.hThread) != 0xFFFFFFFF);
    }
    else
    {
        HANDLE remoteThread = CreateRemoteThread(processInfo.hProcess, NULL, 0,
            (LPTHREAD_START_ROUTINE)beginPosition, NULL, 0, NULL);
        if (remoteThread == NULL)
        {
            OsApi.VirtualFreeEx(processInfo.hProcess, (VOID*)beginPosition, sizeof(INJECT_CODE), MEM_DECOMMIT);
            CloseHandle(processInfo.hThread);
            CloseHandle(processInfo.hProcess);

            return false;
        }

        WaitForSingleObject(remoteThread, INFINITE);

        DWORD moduleBase;
        if (!GetExitCodeThread(remoteThread, &moduleBase) || !moduleBase)
        {
            OsApi.VirtualFreeEx(processInfo.hProcess, (VOID*)beginPosition, sizeof(INJECT_CODE), MEM_DECOMMIT);
            CloseHandle(processInfo.hThread);
            CloseHandle(processInfo.hProcess);

            return false;
        }
    }

    OsApi.VirtualFreeEx(processInfo.hProcess, (VOID*)beginPosition, sizeof(INJECT_CODE), MEM_DECOMMIT);
    CloseHandle(processInfo.hThread);
    CloseHandle(processInfo.hProcess);

    return true;
}

HANDLE WINAPI OpenThread9x(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwThreadId)
{
    DWORD  processID, obsfucator, * pThreadDataBase;
    HANDLE hThread;
    HANDLE(WINAPI * pInternalOpenProcess)(DWORD, BOOL, DWORD);

    processID = GetCurrentProcessId();
    __asm mov eax, fs: [0x30] ;
    __asm xor eax, processID;
    __asm mov obsfucator, eax;

    pThreadDataBase = (DWORD*)(dwThreadId ^ obsfucator);
    if (IsBadReadPtr(pThreadDataBase, sizeof(DWORD)) || ((*pThreadDataBase & 0x7) != 0x7))
        return NULL;

    *(PDWORD)(&pInternalOpenProcess) = SearchMemory((DWORD)OpenProcess, 0xFF, (BYTE*)"\xB9\x00\x00\x00\x00", "xxxxx");
    if (pInternalOpenProcess == NULL)
        return NULL;

    __asm mov   eax, pThreadDataBase;
    __asm push  dwThreadId;
    __asm push  bInheritHandle;
    __asm push  dwDesiredAccess;
    __asm call  pInternalOpenProcess;
    __asm mov   hThread, eax;

    return hThread;
}

LPVOID WINAPI VirtualAllocEx9x(HANDLE hProcess, LPVOID lpAddress, DWORD dwSize, DWORD flAllocationType, DWORD flProtect)
{
    LPVOID(WINAPI * pVirtualAlloc)(LPVOID, SIZE_T, DWORD, DWORD);

    HINSTANCE kernel32 = GetModuleHandle("kernel32.dll");
    if (kernel32 == NULL)
        kernel32 = LoadLibrary("kernel32.dll");

    *(PDWORD)(&pVirtualAlloc) = (DWORD)GetProcAddress(kernel32, "VirtualAlloc");

    return pVirtualAlloc(lpAddress, dwSize, flAllocationType | 0x8000000, flProtect);
}

BOOL WINAPI VirtualFreeEx9x(HANDLE hProcess, LPVOID lpAddress, DWORD dwSize, DWORD dwFreeType)
{
    BOOL(WINAPI * pVirtualFree)(LPVOID, SIZE_T, DWORD);

    HINSTANCE kernel32 = GetModuleHandle("kernel32.dll");
    if (kernel32 == NULL)
        kernel32 = LoadLibrary("kernel32.dll");

    *(PDWORD)(&pVirtualFree) = (DWORD)GetProcAddress(kernel32, "VirtualFree");

    return pVirtualFree(lpAddress, dwSize, dwFreeType);
}

DWORD SearchMemory(DWORD start, DWORD length, BYTE* pattern, CHAR* mask)
{
    BYTE* currentAddress;
    BYTE* currentPattern;
    CHAR* currentMask;

    for (DWORD i = 0; i < length; i++)
    {
        currentAddress = (BYTE*)(start + i);
        currentPattern = pattern;
        currentMask = mask;
        for (; *currentMask; currentAddress++, currentPattern++, currentMask++)
        {
            if (*currentMask == 'x' && *currentAddress != *currentPattern)
                break;
        }
        if (*currentMask == NULL) return (start + i);
    }

    return NULL;
}

bool IsSameName(const char* targetString, const char* sourceString)
{
    const char* index, * i, * j;

    for (index = i = targetString; *index; index++)
        if (*index == '\\')
            i = index + 1;

    for (index = j = sourceString; *index; index++)
        if (*index == '\\')
            j = index + 1;

    for (; *i && *j; i++, j++)
    {
        if (tolower(*i) != tolower(*j))
            return false;
    }

    return (*j == 0);
}
```

`sakura/loader/injector.h`:

```h
#ifndef INJECTOR_H
#define INJECTOR_H

#pragma warning(disable:4996)
#include <stddef.h>
#include <windows.h>
#include <TLHELP32.H>

namespace Injector
{
    struct OS_VER
    {
        bool IsWin98;
        bool IsWinMe;
        bool IsWinXp;
    };

    struct OS_API
    {
        HANDLE(WINAPI* CreateToolhelp32Snapshot)(DWORD  dwFlags, DWORD th32ProcessID);
        BOOL(WINAPI* Process32First)          (HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
        BOOL(WINAPI* Process32Next)           (HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
        BOOL(WINAPI* Module32First)           (HANDLE hSnapshot, LPMODULEENTRY32 lpme);
        BOOL(WINAPI* Module32Next)            (HANDLE hSnapshot, LPMODULEENTRY32 lpme);
        BOOL(WINAPI* Thread32First)           (HANDLE hSnapshot, LPTHREADENTRY32 lpte);
        BOOL(WINAPI* Thread32Next)            (HANDLE hSnapshot, LPTHREADENTRY32 lpte);
        HANDLE(WINAPI* OpenProcess)             (DWORD dwDesiredAccess,
            BOOL  bInheritHandle,
            DWORD dwProcessId
            );
        HANDLE(WINAPI* OpenThread)              (DWORD dwDesiredAccess,
            BOOL  bInheritHandle,
            DWORD dwThreadId
            );
        LPVOID(WINAPI* VirtualAllocEx)          (HANDLE hProcess,
            LPVOID lpAddress,
            SIZE_T dwSize,
            DWORD  flAllocationType,
            DWORD  flProtect
            );
        BOOL(WINAPI* VirtualFreeEx)           (HANDLE hProcess,
            LPVOID lpAddress,
            SIZE_T dwSize,
            DWORD  dwFreeType
            );
    };

    bool GetOsVer(OS_VER* osVer);

    bool GetOsApi(OS_API* osApi);

    bool GetProcessInfo(const char* exeName, PROCESS_INFORMATION* processInfo);

    bool GetModuleInfo(const char* exeName, const char* moduleName, MODULEENTRY32* moduleEntry32);

    bool InjectModule(const char* exeName, const char* modulePath);
}

#endif
```

`sakura/loader/loader.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// Chinese (Simplified, PRC) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_CHS)
LANGUAGE LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED
#pragma code_page(936)

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED

#endif    // Chinese (Simplified, PRC) resources
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
#pragma code_page(1252)

/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDI_ICON1               ICON                    "icon.ico"

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`sakura/loader/loader.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LocalDebuggerMergeEnvironment>false</LocalDebuggerMergeEnvironment>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
</Project>
```

`sakura/loader/loader.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\..\imgui\backends\imgui_impl_dx11.h" />
    <ClInclude Include="..\..\imgui\backends\imgui_impl_win32.h" />
    <ClInclude Include="..\..\imgui\imconfig.h" />
    <ClInclude Include="..\..\imgui\imgui.h" />
    <ClInclude Include="..\..\imgui\imgui_internal.h" />
    <ClInclude Include="..\..\imgui\imstb_rectpack.h" />
    <ClInclude Include="..\..\imgui\imstb_textedit.h" />
    <ClInclude Include="..\..\imgui\imstb_truetype.h" />
    <ClInclude Include="injector.h" />
    <ClInclude Include="menu.h" />
    <ClInclude Include="resource.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\..\imgui\backends\imgui_impl_dx11.cpp" />
    <ClCompile Include="..\..\imgui\backends\imgui_impl_win32.cpp" />
    <ClCompile Include="..\..\imgui\imgui.cpp" />
    <ClCompile Include="..\..\imgui\imgui_demo.cpp" />
    <ClCompile Include="..\..\imgui\imgui_draw.cpp" />
    <ClCompile Include="..\..\imgui\imgui_tables.cpp" />
    <ClCompile Include="..\..\imgui\imgui_widgets.cpp" />
    <ClCompile Include="injector.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="menu.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="loader.rc" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="icon.ico" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <SccProjectName />
    <SccLocalPath />
    <ProjectGuid>{675311A9-B1B8-4314-9B85-8F7B9892329B}</ProjectGuid>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>sakura loader</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <PlatformToolset>v143</PlatformToolset>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <PlatformToolset>v143</PlatformToolset>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.Cpp.UpgradeFromVC60.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.Cpp.UpgradeFromVC60.props" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <OutDir>..\sakura\</OutDir>
    <IntDir>..\release\loader\</IntDir>
    <LinkIncremental>false</LinkIncremental>
    <TargetName>sakura</TargetName>
    <ExecutablePath>$(VC_ExecutablePath_x86);$(CommonExecutablePath)</ExecutablePath>
    <IncludePath>$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
    <LibraryPath>$(VC_LibraryPath_x86);$(WindowsSDK_LibraryPath_x86)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <OutDir>..\sakura\</OutDir>
    <IntDir>..\release\loader\</IntDir>
    <LinkIncremental>false</LinkIncremental>
    <TargetName>sakura</TargetName>
    <ExecutablePath>$(VC_ExecutablePath_x86);$(CommonExecutablePath)</ExecutablePath>
    <IncludePath>$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
    <LibraryPath>$(VC_LibraryPath_x86);$(WindowsSDK_LibraryPath_x86)</LibraryPath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
      <InlineFunctionExpansion>Default</InlineFunctionExpansion>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <Optimization>MaxSpeed</Optimization>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <WarningLevel>Level3</WarningLevel>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AssemblerListingLocation>.\release\</AssemblerListingLocation>
      <ObjectFileName>.\release\</ObjectFileName>
      <ProgramDataBaseFileName>.\release\</ProgramDataBaseFileName>
      <SupportJustMyCode>true</SupportJustMyCode>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <EnableFiberSafeOptimizations>true</EnableFiberSafeOptimizations>
      <StringPooling>true</StringPooling>
      <BufferSecurityCheck>true</BufferSecurityCheck>
      <AdditionalIncludeDirectories>$(SolutionDir)imgui;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Midl>
      <SuppressStartupBanner>false</SuppressStartupBanner>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <TypeLibraryName>.\Build\LaserInjector.tlb</TypeLibraryName>
      <MkTypLibCompatible>true</MkTypLibCompatible>
      <TargetEnvironment>Win32</TargetEnvironment>
    </Midl>
    <ResourceCompile>
      <Culture>0x0804</Culture>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Bscmake>
      <SuppressStartupBanner>false</SuppressStartupBanner>
      <OutputFile>.\release\Injector.bsc</OutputFile>
    </Bscmake>
    <Link>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <OutputFile>..\sakura\sakura.exe</OutputFile>
      <AdditionalDependencies>$(DXSDK_DIR)Lib\x86\d3d11.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
      <InlineFunctionExpansion>Default</InlineFunctionExpansion>
      <StringPooling>true</StringPooling>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <Optimization>MaxSpeed</Optimization>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <WarningLevel>Level3</WarningLevel>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AssemblerListingLocation>.\release\</AssemblerListingLocation>
      <ObjectFileName>.\release\</ObjectFileName>
      <ProgramDataBaseFileName>.\release\</ProgramDataBaseFileName>
      <SupportJustMyCode>true</SupportJustMyCode>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <EnableFiberSafeOptimizations>true</EnableFiberSafeOptimizations>
      <AdditionalIncludeDirectories>$(SolutionDir)imgui;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Midl>
      <SuppressStartupBanner>false</SuppressStartupBanner>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <TypeLibraryName>.\Build\LaserInjector.tlb</TypeLibraryName>
      <MkTypLibCompatible>true</MkTypLibCompatible>
      <TargetEnvironment>Win32</TargetEnvironment>
    </Midl>
    <ResourceCompile>
      <Culture>0x0804</Culture>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Bscmake>
      <SuppressStartupBanner>false</SuppressStartupBanner>
      <OutputFile>.\release\Injector.bsc</OutputFile>
    </Bscmake>
    <Link>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <GenerateDebugInformation>DebugFull</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <OutputFile>..\sakura\sakura.exe</OutputFile>
      <AdditionalDependencies>$(DXSDK_DIR)Lib\x86\d3d11.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <ProgramDatabaseFile>../debug/loader.pdb</ProgramDatabaseFile>
    </Link>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`sakura/loader/loader.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="source">
      <UniqueIdentifier>{7ff64f8a-d590-434b-8afa-ebd053d0f441}</UniqueIdentifier>
    </Filter>
    <Filter Include="libs">
      <UniqueIdentifier>{4421d4c1-333e-4080-86ec-d28353d6068d}</UniqueIdentifier>
    </Filter>
    <Filter Include="libs\imgui">
      <UniqueIdentifier>{81689f2c-23f2-49a9-8dcb-ffc0408bec3d}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="resource.h" />
    <ClInclude Include="injector.h">
      <Filter>source</Filter>
    </ClInclude>
    <ClInclude Include="menu.h">
      <Filter>source</Filter>
    </ClInclude>
    <ClInclude Include="..\..\imgui\imgui_internal.h">
      <Filter>libs\imgui</Filter>
    </ClInclude>
    <ClInclude Include="..\..\imgui\imstb_rectpack.h">
      <Filter>libs\imgui</Filter>
    </ClInclude>
    <ClInclude Include="..\..\imgui\imstb_textedit.h">
      <Filter>libs\imgui</Filter>
    </ClInclude>
    <ClInclude Include="..\..\imgui\imstb_truetype.h">
      <Filter>libs\imgui</Filter>
    </ClInclude>
    <ClInclude Include="..\..\imgui\imconfig.h">
      <Filter>libs\imgui</Filter>
    </ClInclude>
    <ClInclude Include="..\..\imgui\imgui.h">
      <Filter>libs\imgui</Filter>
    </ClInclude>
    <ClInclude Include="..\..\imgui\backends\imgui_impl_dx11.h">
      <Filter>libs\imgui</Filter>
    </ClInclude>
    <ClInclude Include="..\..\imgui\backends\imgui_impl_win32.h">
      <Filter>libs\imgui</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="injector.cpp">
      <Filter>source</Filter>
    </ClCompile>
    <ClCompile Include="main.cpp">
      <Filter>source</Filter>
    </ClCompile>
    <ClCompile Include="menu.cpp">
      <Filter>source</Filter>
    </ClCompile>
    <ClCompile Include="..\..\imgui\imgui_tables.cpp">
      <Filter>libs\imgui</Filter>
    </ClCompile>
    <ClCompile Include="..\..\imgui\imgui_widgets.cpp">
      <Filter>libs\imgui</Filter>
    </ClCompile>
    <ClCompile Include="..\..\imgui\imgui.cpp">
      <Filter>libs\imgui</Filter>
    </ClCompile>
    <ClCompile Include="..\..\imgui\imgui_demo.cpp">
      <Filter>libs\imgui</Filter>
    </ClCompile>
    <ClCompile Include="..\..\imgui\imgui_draw.cpp">
      <Filter>libs\imgui</Filter>
    </ClCompile>
    <ClCompile Include="..\..\imgui\backends\imgui_impl_dx11.cpp">
      <Filter>libs\imgui</Filter>
    </ClCompile>
    <ClCompile Include="..\..\imgui\backends\imgui_impl_win32.cpp">
      <Filter>libs\imgui</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="loader.rc" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="icon.ico" />
  </ItemGroup>
</Project>
```

`sakura/loader/loader.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LocalDebuggerCommand>$(ProjectDir)..\hack\loader.exe</LocalDebuggerCommand>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LocalDebuggerMergeEnvironment>false</LocalDebuggerMergeEnvironment>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
</Project>
```

`sakura/loader/main.cpp`:

```cpp
#include "../../imgui/imgui.h"
#include "../../imgui/backends/imgui_impl_win32.h"
#include "../../imgui/backends/imgui_impl_dx11.h"
#include <d3d11.h>
#include <tchar.h>

#include "menu.h"
#include "resource.h"

// Data
static ID3D11Device* g_pd3dDevice = nullptr;
static ID3D11DeviceContext* g_pd3dDeviceContext = nullptr;
static IDXGISwapChain* g_pSwapChain = nullptr;
static ID3D11RenderTargetView* g_mainRenderTargetView = nullptr;

// Forward declarations of helper functions
bool CreateDeviceD3D(HWND hWnd);
void CleanupDeviceD3D();
void CreateRenderTarget();
void CleanupRenderTarget();
LRESULT WINAPI WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

// Main code
int WINAPI wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nShowCmd)
{
    Sakura::Init();

    // Create application window
    WNDCLASSEXW wc = { sizeof(wc), CS_CLASSDC, WndProc, 0L, 0L, GetModuleHandle(nullptr), nullptr, nullptr, nullptr, nullptr, L"Sakura injector", nullptr };
    ::RegisterClassExW(&wc);
    HWND hwnd = ::CreateWindowW(wc.lpszClassName, L"Sakura injector", WS_OVERLAPPEDWINDOW, 100, 100, 200, 200, nullptr, nullptr, wc.hInstance, nullptr);

    SetWindowLong(hwnd, GWL_STYLE,
        GetWindowLong(hwnd, GWL_STYLE) & ~WS_MINIMIZEBOX);

    SetWindowLong(hwnd, GWL_STYLE,
        GetWindowLong(hwnd, GWL_STYLE) & ~WS_MAXIMIZEBOX);

    SetWindowLong(hwnd, GWL_STYLE,
        GetWindowLong(hwnd, GWL_STYLE) & ~WS_SIZEBOX);

    wc.hIcon = LoadIcon(wc.hInstance, MAKEINTRESOURCE(IDI_ICON1));

    // Initialize Direct3D
    if (!CreateDeviceD3D(hwnd))
    {
        CleanupDeviceD3D();
        ::UnregisterClassW(wc.lpszClassName, wc.hInstance);
        return 1;
    }

    // Show the window
    ::ShowWindow(hwnd, SW_SHOWDEFAULT);
    ::UpdateWindow(hwnd);

    // Setup Dear ImGui context
    IMGUI_CHECKVERSION();
    ImGui::CreateContext();
    ImGuiIO& io = ImGui::GetIO(); (void)io;
    io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;     // Enable Keyboard Controls
    io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad;      // Enable Gamepad Controls
    io.IniFilename = NULL;
    io.LogFilename = NULL;

    // Setup Dear ImGui style
    ImGui::StyleColorsDark();

    // Setup Platform/Renderer backends
    ImGui_ImplWin32_Init(hwnd);
    ImGui_ImplDX11_Init(g_pd3dDevice, g_pd3dDeviceContext);

    // Our state
    ImVec4 clear_color = ImVec4(0.45f, 0.55f, 0.60f, 1.00f);

    // Main loop
    bool done = false;
    while (!done)
    {
        // Poll and handle messages (inputs, window resize, etc.)
        // See the WndProc() function below for our to dispatch events to the Win32 backend.
        MSG msg;
        while (::PeekMessage(&msg, nullptr, 0U, 0U, PM_REMOVE))
        {
            ::TranslateMessage(&msg);
            ::DispatchMessage(&msg);
            if (msg.message == WM_QUIT)
                done = true;
        }
        if (done)
            break;

        // Start the Dear ImGui frame
        ImGui_ImplDX11_NewFrame();
        ImGui_ImplWin32_NewFrame();
        ImGui::NewFrame();

        Sakura::Menu::Draw();

        // Rendering
        ImGui::Render();
        const float clear_color_with_alpha[4] = { clear_color.x * clear_color.w, clear_color.y * clear_color.w, clear_color.z * clear_color.w, clear_color.w };
        g_pd3dDeviceContext->OMSetRenderTargets(1, &g_mainRenderTargetView, nullptr);
        g_pd3dDeviceContext->ClearRenderTargetView(g_mainRenderTargetView, clear_color_with_alpha);
        ImGui_ImplDX11_RenderDrawData(ImGui::GetDrawData());

        g_pSwapChain->Present(1, 0); // Present with vsync
        //g_pSwapChain->Present(0, 0); // Present without vsync
    }

    // Cleanup
    ImGui_ImplDX11_Shutdown();
    ImGui_ImplWin32_Shutdown();
    ImGui::DestroyContext();

    CleanupDeviceD3D();
    ::DestroyWindow(hwnd);
    ::UnregisterClassW(wc.lpszClassName, wc.hInstance);

    return 0;
}

// Helper functions

bool CreateDeviceD3D(HWND hWnd)
{
    // Setup swap chain
    DXGI_SWAP_CHAIN_DESC sd;
    ZeroMemory(&sd, sizeof(sd));
    sd.BufferCount = 2;
    sd.BufferDesc.Width = 0;
    sd.BufferDesc.Height = 0;
    sd.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
    sd.BufferDesc.RefreshRate.Numerator = 60;
    sd.BufferDesc.RefreshRate.Denominator = 1;
    sd.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;
    sd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
    sd.OutputWindow = hWnd;
    sd.SampleDesc.Count = 1;
    sd.SampleDesc.Quality = 0;
    sd.Windowed = TRUE;
    sd.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;

    UINT createDeviceFlags = 0;
    //createDeviceFlags |= D3D11_CREATE_DEVICE_DEBUG;
    D3D_FEATURE_LEVEL featureLevel;
    const D3D_FEATURE_LEVEL featureLevelArray[2] = { D3D_FEATURE_LEVEL_11_0, D3D_FEATURE_LEVEL_10_0, };
    HRESULT res = D3D11CreateDeviceAndSwapChain(nullptr, D3D_DRIVER_TYPE_HARDWARE, nullptr, createDeviceFlags, featureLevelArray, 2, D3D11_SDK_VERSION, &sd, &g_pSwapChain, &g_pd3dDevice, &featureLevel, &g_pd3dDeviceContext);
    if (res == DXGI_ERROR_UNSUPPORTED) // Try high-performance WARP software driver if hardware is not available.
        res = D3D11CreateDeviceAndSwapChain(nullptr, D3D_DRIVER_TYPE_WARP, nullptr, createDeviceFlags, featureLevelArray, 2, D3D11_SDK_VERSION, &sd, &g_pSwapChain, &g_pd3dDevice, &featureLevel, &g_pd3dDeviceContext);
    if (res != S_OK)
        return false;

    CreateRenderTarget();
    return true;
}

void CleanupDeviceD3D()
{
    CleanupRenderTarget();
    if (g_pSwapChain) { g_pSwapChain->Release(); g_pSwapChain = nullptr; }
    if (g_pd3dDeviceContext) { g_pd3dDeviceContext->Release(); g_pd3dDeviceContext = nullptr; }
    if (g_pd3dDevice) { g_pd3dDevice->Release(); g_pd3dDevice = nullptr; }
}

void CreateRenderTarget()
{
    ID3D11Texture2D* pBackBuffer;
    g_pSwapChain->GetBuffer(0, IID_PPV_ARGS(&pBackBuffer));
    g_pd3dDevice->CreateRenderTargetView(pBackBuffer, nullptr, &g_mainRenderTargetView);
    pBackBuffer->Release();
}

void CleanupRenderTarget()
{
    if (g_mainRenderTargetView) { g_mainRenderTargetView->Release(); g_mainRenderTargetView = nullptr; }
}

// Forward declare message handler from imgui_impl_win32.cpp
extern IMGUI_IMPL_API LRESULT ImGui_ImplWin32_WndProcHandler(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

// Win32 message handler
// You can read the io.WantCaptureMouse, io.WantCaptureKeyboard flags to tell if dear imgui wants to use your inputs.
// - When io.WantCaptureMouse is true, do not dispatch mouse input data to your main application, or clear/overwrite your copy of the mouse data.
// - When io.WantCaptureKeyboard is true, do not dispatch keyboard input data to your main application, or clear/overwrite your copy of the keyboard data.
// Generally you may always pass all inputs to dear imgui, and hide them from your application based on those two flags.
LRESULT WINAPI WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    if (ImGui_ImplWin32_WndProcHandler(hWnd, msg, wParam, lParam))
        return true;

    switch (msg)
    {
    case WM_SIZE:
        if (g_pd3dDevice != nullptr && wParam != SIZE_MINIMIZED)
        {
            CleanupRenderTarget();
            g_pSwapChain->ResizeBuffers(0, (UINT)LOWORD(lParam), (UINT)HIWORD(lParam), DXGI_FORMAT_UNKNOWN, 0);
            CreateRenderTarget();
        }
        return 0;
    case WM_SYSCOMMAND:
        if ((wParam & 0xfff0) == SC_KEYMENU) // Disable ALT application menu
            return 0;
        break;
    case WM_DESTROY:
        ::PostQuitMessage(0);
        return 0;
    }
    return ::DefWindowProcW(hWnd, msg, wParam, lParam);
}
```

`sakura/loader/menu.cpp`:

```cpp
#include "../libs/xor/xorstr.h"
#include "../../imgui/imgui.h"

#include "menu.h"
#include "injector.h"

#include <iostream>
#include <windows.h>

bool Sakura::Menu::Active = true;
ImGuiWindowFlags Sakura::Menu::WindowFlags = ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoTitleBar;

bool stylesInit = false;
bool autoClose = false;
bool autoInject = false;
char modulePath[MAX_PATH];
char moduleName[32];
char statusText[32];
PROCESS_INFORMATION processInfo;

void Sakura::Init()
{
    sprintf(statusText, /*:)*/XorStr<0xE3, 3, 0xE0B6E8BD>("\xD9\xCD" + 0xE0B6E8BD).s);
    sprintf(moduleName, /*sakura.dll*/XorStr<0x41, 11, 0x13E9D3ED>("\x32\x23\x28\x31\x37\x27\x69\x2C\x25\x26" + 0x13E9D3ED).s);
}

void Sakura::InitStyles()
{
    ImGuiStyle& s = ImGui::GetStyle();
    s.WindowBorderSize = 0;

    s.Colors[ImGuiCol_Button] = ImVec4(0.3529f, 0.1176f, 0.3058f, 0.9f);
    s.Colors[ImGuiCol_ButtonActive] = ImVec4(0.3529f, 0.1176f, 0.3058f, 0.7f);
    s.Colors[ImGuiCol_ButtonHovered] = ImVec4(0.3529f, 0.1176f, 0.3058f, 0.5f);

    s.Colors[ImGuiCol_FrameBg] = ImVec4(0.3529f, 0.1176f, 0.3058f, 0.9f);
    s.Colors[ImGuiCol_FrameBgActive] = ImVec4(0.3529f, 0.1176f, 0.3058f, 0.7f);
    s.Colors[ImGuiCol_FrameBgHovered] = ImVec4(0.3529f, 0.1176f, 0.3058f, 0.5f);

    s.Colors[ImGuiCol_CheckMark] = ImVec4(1.f, 1.f, 1.f, 1.f);

    stylesInit = true;
}

void Sakura::Inject()
{
    bool moduleExists = true;
    bool processExists = true;

    GetModuleFileName(NULL, modulePath, MAX_PATH);
    char* index = strrchr(modulePath, '\\');
    modulePath[index - modulePath + 1] = 0;
    strcat_s(modulePath, MAX_PATH, moduleName);
    WIN32_FIND_DATA WFD;

    if (FindFirstFile(modulePath, &WFD) == INVALID_HANDLE_VALUE)
    {
        sprintf(statusText, /*sakura.dll is missing!*/XorStr<0x59, 23, 0x4747249C>("\x2A\x3B\x30\x29\x2F\x3F\x71\x04\x0D\x0E\x43\x0D\x16\x46\x0A\x01\x1A\x19\x02\x02\x0A\x4F" + 0x4747249C).s);
        moduleExists = false;
    }

    if (Injector::GetProcessInfo("hl.exe", &processInfo) == false && moduleExists)
    {
        sprintf(statusText, /*hl.exe is missing!*/XorStr<0x82, 19, 0x7A22A4AD>("\xEA\xEF\xAA\xE0\xFE\xE2\xA8\xE0\xF9\xAB\xE1\xE4\xFD\xFC\xF9\xFF\xF5\xB2" + 0x7A22A4AD).s);
        processExists = false;
    }

    if (Injector::InjectModule("hl.exe", modulePath) == true && moduleExists && processExists)
    {
        sprintf(statusText, /*Injected!*/XorStr<0xB0, 10, 0xE54EBF17>("\xF9\xDF\xD8\xD6\xD7\xC1\xD3\xD3\x99" + 0xE54EBF17).s);

        if (autoClose)
            exit(0);
    }
}

void Sakura::Menu::Draw()
{
    if (Active)
    {
        if (!stylesInit)
            InitStyles();

        if (autoInject)
            Sakura::Inject();

        ImGui::SetNextWindowSize({ 200, 200 });
        ImGui::SetNextWindowPos({ 0, 0 }, ImGuiCond_Once);
        ImGui::SetNextWindowBgAlpha(1.0f);
        ImGui::Begin(/*##sinj*/XorStr<0xE2, 7, 0xFFCB6CF5>("\xC1\xC0\x97\x8C\x88\x8D" + 0xFFCB6CF5).s, &Active, WindowFlags);
        {
            ImGui::Text(statusText);
            ImGui::Checkbox(/*Auto close on inject*/XorStr<0x23, 21, 0x7822FFE3>("\x62\x51\x51\x49\x07\x4B\x45\x45\x58\x49\x0D\x41\x41\x10\x58\x5C\x59\x51\x56\x42" + 0x7822FFE3).s, &autoClose);
            ImGui::Checkbox(/*Auto inject*/XorStr<0x04, 12, 0x629C4877>("\x45\x70\x72\x68\x28\x60\x64\x61\x69\x6E\x7A" + 0x629C4877).s, &autoInject);
            if (!autoInject && ImGui::Button(/*Inject*/XorStr<0xBE, 7, 0xA29A5E2B>("\xF7\xD1\xAA\xA4\xA1\xB7" + 0xA29A5E2B).s))
                Sakura::Inject();
        }
        ImGui::End();
    }
}
```

`sakura/loader/menu.h`:

```h
#pragma once

namespace Sakura
{
	void Init();
	void InitStyles();
	void Inject();

	namespace Menu
	{
		extern bool Active;
		extern ImGuiWindowFlags WindowFlags;

		void Draw();
	};
};
```

`sakura/loader/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by loader.rc
//
#define IDI_ICON1                       102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`sakura/sakura.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <SccProjectName />
    <SccLocalPath />
    <ProjectGuid>{24F343A3-4BE5-4300-A129-3CBD7B511F65}</ProjectGuid>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>sakura</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <PlatformToolset>v143</PlatformToolset>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
    <WholeProgramOptimization>false</WholeProgramOptimization>
    <LLVMToolsVersion>14.0.6</LLVMToolsVersion>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <PlatformToolset>v143</PlatformToolset>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
    <WholeProgramOptimization>false</WholeProgramOptimization>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.Cpp.UpgradeFromVC60.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.Cpp.UpgradeFromVC60.props" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <OutDir>.\sakura\</OutDir>
    <IntDir>.\release\</IntDir>
    <LinkIncremental>false</LinkIncremental>
    <EnableManagedIncrementalBuild>false</EnableManagedIncrementalBuild>
    <ExtensionsToDeleteOnClean>*.cdf;*.cache;*.obj;*.obj.enc;*.ilk;*.ipdb;*.iobj;*.resources;*.tlb;*.tli;*.tlh;*.tmp;*.rsp;*.pgc;*.pgd;*.meta;*.tlog;*.manifest;*.res;*.pch;*.exp;*.idb;*.rep;*.xdc;*.pdb;*_manifest.rc;*.bsc;*.sbr;*.xml;*.metagen;*.bi</ExtensionsToDeleteOnClean>
    <TargetName>sakura</TargetName>
    <IncludePath>$(IncludePath)</IncludePath>
    <ExternalIncludePath>$(ExternalIncludePath)</ExternalIncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <OutDir>.\sakura\</OutDir>
    <IntDir>.\debug\</IntDir>
    <LinkIncremental>false</LinkIncremental>
    <EnableManagedIncrementalBuild>false</EnableManagedIncrementalBuild>
    <ExtensionsToDeleteOnClean>*.cdf;*.cache;*.obj;*.obj.enc;*.ilk;*.ipdb;*.iobj;*.resources;*.tlb;*.tli;*.tlh;*.tmp;*.rsp;*.pgc;*.pgd;*.meta;*.tlog;*.manifest;*.res;*.pch;*.exp;*.idb;*.rep;*.xdc;*.pdb;*_manifest.rc;*.bsc;*.sbr;*.xml;*.metagen;*.bi</ExtensionsToDeleteOnClean>
    <ExecutablePath>$(VC_ExecutablePath_x86);$(CommonExecutablePath);$(DXSDK_DIR)Utilities\bin\x86</ExecutablePath>
    <LibraryPath>$(VC_LibraryPath_x86);$(WindowsSDK_LibraryPath_x86);$(DXSDK_DIR)Lib\x86</LibraryPath>
    <TargetName>sakura</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <StringPooling>true</StringPooling>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <Optimization>MaxSpeed</Optimization>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <WarningLevel>Level3</WarningLevel>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;HACK_EXPORTS;WIN_X86;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AssemblerListingLocation>.\release\</AssemblerListingLocation>
      <ObjectFileName>.\release\</ObjectFileName>
      <ProgramDataBaseFileName>.\release\</ProgramDataBaseFileName>
      <SupportJustMyCode>true</SupportJustMyCode>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <EnableFiberSafeOptimizations>true</EnableFiberSafeOptimizations>
      <WholeProgramOptimization>false</WholeProgramOptimization>
      <MinimalRebuild>false</MinimalRebuild>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <AdditionalIncludeDirectories>$(ProjectDir)libs;$(SolutionDir)imgui;$(SolutionDir)luabridge\source;$(SolutionDir)lua\;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <DisableSpecificWarnings>28159;%(DisableSpecificWarnings)</DisableSpecificWarnings>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel>Fast</FloatingPointModel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>client.h</PrecompiledHeaderFile>
    </ClCompile>
    <Midl>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <TypeLibraryName>.\Release\hack.tlb</TypeLibraryName>
      <MkTypLibCompatible>true</MkTypLibCompatible>
      <TargetEnvironment>Win32</TargetEnvironment>
    </Midl>
    <ResourceCompile>
      <Culture>0x0409</Culture>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Bscmake>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <OutputFile>.\release\hack.bsc</OutputFile>
    </Bscmake>
    <Link>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <LinkDLL>true</LinkDLL>
      <SubSystem>Console</SubSystem>
      <IgnoreSpecificDefaultLibraries>libc.lib;%(IgnoreSpecificDefaultLibraries)</IgnoreSpecificDefaultLibraries>
      <IgnoreAllDefaultLibraries>false</IgnoreAllDefaultLibraries>
      <AdditionalDependencies>winmm.lib;odbc32.lib;odbccp32.lib;opengl32.lib;Shlwapi.lib;$(ProjectDir)libs\lua54.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <GenerateMapFile>false</GenerateMapFile>
      <ImportLibrary>$(IntDir)$(TargetName).lib</ImportLibrary>
    </Link>
    <ProjectReference>
      <LinkLibraryDependencies>true</LinkLibraryDependencies>
    </ProjectReference>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <InlineFunctionExpansion>Default</InlineFunctionExpansion>
      <StringPooling>true</StringPooling>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <Optimization>MaxSpeed</Optimization>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <WarningLevel>Level3</WarningLevel>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;HACK_EXPORTS;WIN_X86;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AssemblerListingLocation>.\release\</AssemblerListingLocation>
      <ObjectFileName>.\release\</ObjectFileName>
      <ProgramDataBaseFileName>.\release\</ProgramDataBaseFileName>
      <SupportJustMyCode>true</SupportJustMyCode>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <EnableFiberSafeOptimizations>true</EnableFiberSafeOptimizations>
      <WholeProgramOptimization>false</WholeProgramOptimization>
      <MinimalRebuild>false</MinimalRebuild>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>client.h</PrecompiledHeaderFile>
      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
      <AdditionalIncludeDirectories>$(ProjectDir)libs;$(SolutionDir)imgui;$(SolutionDir)luabridge\source;$(SolutionDir)lua\;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Midl>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <TypeLibraryName>.\Release\hack.tlb</TypeLibraryName>
      <MkTypLibCompatible>true</MkTypLibCompatible>
      <TargetEnvironment>Win32</TargetEnvironment>
    </Midl>
    <ResourceCompile>
      <Culture>0x0409</Culture>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Bscmake>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <OutputFile>.\release\hack.bsc</OutputFile>
    </Bscmake>
    <Link>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <LinkDLL>true</LinkDLL>
      <SubSystem>Console</SubSystem>
      <IgnoreSpecificDefaultLibraries>libc.lib;%(IgnoreSpecificDefaultLibraries)</IgnoreSpecificDefaultLibraries>
      <IgnoreAllDefaultLibraries>false</IgnoreAllDefaultLibraries>
      <AdditionalDependencies>winmm.lib;odbc32.lib;odbccp32.lib;opengl32.lib;Shlwapi.lib;$(ProjectDir)libs\lua54.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
      <GenerateDebugInformation>DebugFull</GenerateDebugInformation>
      <ProgramDatabaseFile>$(OutDir)$(TargetName).pdb</ProgramDatabaseFile>
    </Link>
    <ProjectReference>
      <LinkLibraryDependencies>true</LinkLibraryDependencies>
    </ProjectReference>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="..\detours\src\creatwth.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\detours\src\detours.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\detours\src\disasm.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\detours\src\disolarm.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\detours\src\disolarm64.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\detours\src\disolia64.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\detours\src\disolx64.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\detours\src\disolx86.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\detours\src\image.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\detours\src\modules.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\halflife\parsemsg.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\imgui\backends\imgui_impl_opengl2.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\imgui\backends\imgui_impl_opengl3.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\imgui\backends\imgui_impl_win32.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\imgui\imgui.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\imgui\imgui_demo.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\imgui\imgui_draw.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\imgui\imgui_tables.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\imgui\imgui_widgets.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\lua\lapi.c">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\lua\lauxlib.c">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\lua\lbaselib.c">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\lua\lcode.c">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\lua\lcorolib.c">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\lua\lctype.c">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\lua\ldblib.c">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\lua\ldebug.c">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\lua\ldo.c">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\lua\ldump.c">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\lua\lfunc.c">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\lua\lgc.c">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\lua\linit.c">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\lua\liolib.c">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\lua\llex.c">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\lua\lmathlib.c">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\lua\lmem.c">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\lua\loadlib.c">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\lua\lobject.c">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\lua\lopcodes.c">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\lua\loslib.c">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\lua\lparser.c">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\lua\lstate.c">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\lua\lstring.c">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\lua\lstrlib.c">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\lua\ltable.c">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\lua\ltablib.c">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\lua\ltests.c">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\lua\ltm.c">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\lua\lua.c">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\lua\lundump.c">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\lua\lutf8lib.c">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\lua\lvm.c">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\lua\lzio.c">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="libs\bass\dll.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="libs\bass\dll_image.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="libs\image\image_DXT.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="libs\image\image_helper.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="libs\image\soil.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="libs\image\stb_image_aug.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="libs\opengl\gl3w.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="source\client.cpp">
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\config\cvar.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\client.h</PrecompiledHeaderFile>
    </ClCompile>
    <ClCompile Include="source\features\aimbot.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\features\hns\bhop.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\features\hns\fastrun.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\features\hns\groundstrafe.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\features\hns\jumpbug.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\features\hns\strafe.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\features\legit\knife.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\features\legit\laim.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\features\legit\trigger.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\features\lua\luabind.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\features\misc\afk.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\features\misc\chatspammer.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\features\misc\fakelatency.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\features\misc\idhook.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\features\misc\namestealer.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\features\misc\skipframes.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\features\misc\snapshot.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\features\misc\steamid.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\features\rage\antiaim.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\features\rage\autoroute.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\features\rage\fakelag.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\features\rage\norecoil.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\features\rage\nospread.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\features\rage\raim.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\features\sound\killsound.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\features\sound\sound.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\features\sound\soundesp.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\features\visuals\chams\chams.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\features\visuals\chams\studiomodelrender.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\features\visuals\esp\esp.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\features\visuals\esp\hitboxes.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\features\visuals\esp\radar.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\features\visuals\esp\snaplines.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\features\visuals\light\light.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\features\visuals\light\studio.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\features\visuals\local\crosshair.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\features\visuals\local\fov.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\features\visuals\local\removals\fade.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\..\..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\..\..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\features\visuals\local\removals\hands.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\..\..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\..\..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\features\visuals\local\removals\scope.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\..\..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\..\..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\features\visuals\local\skins\skins.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\..\..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\..\..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\features\visuals\local\skins\viewmodel.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\..\..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\..\..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\features\visuals\local\thirdperson.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\features\visuals\local\tracegrenade.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\features\visuals\local\world\bullettrace.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\..\..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\..\..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\features\visuals\local\world\deathmark.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\..\..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\..\..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\features\visuals\local\world\fog.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\..\..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\..\..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\features\visuals\local\world\lightmap.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\..\..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\..\..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\features\visuals\local\world\sky.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\..\..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\..\..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\features\visuals\menu\menu.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\features\visuals\menu\menu_widgets.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\features\visuals\menu\tabs\menu_colors_tab.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\..\..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\..\..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\features\visuals\menu\tabs\menu_legit_tab.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\..\..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\..\..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\features\visuals\menu\tabs\menu_misc_tab.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\..\..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\..\..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\features\visuals\menu\tabs\menu_rage_tab.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\..\..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\..\..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\features\visuals\menu\tabs\menu_visuals_tab.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\..\..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\..\..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\features\visuals\toasts\toasts.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\gui\gui.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\gui\guiwindow.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\gui\guiwindowpop.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\helpers\anim.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\helpers\color.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\client.h</PrecompiledHeaderFile>
      <InlineFunctionExpansion Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">AnySuitable</InlineFunctionExpansion>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
    </ClCompile>
    <ClCompile Include="source\helpers\log.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\helpers\stringfinder.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\helpers\strings.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\helpers\textures.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\helpers\trace.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\helpers\weapons.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\main.cpp">
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\offsets\offset.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\opengl.cpp">
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\other\smth\gl3winit.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="source\other\smth\interface.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="source\player.cpp">
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\sakura_precompiled.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="source\usermsg.cpp">
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\vectors\QAngle.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
    <ClCompile Include="source\vectors\Vector.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\client.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\client.h</PrecompiledHeaderFile>
      <EnableEnhancedInstructionSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Fast</FloatingPointModel>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\detours\src\detours.h" />
    <ClInclude Include="..\detours\src\detver.h" />
    <ClInclude Include="..\halflife\parsemsg.h" />
    <ClInclude Include="..\imgui\backends\imgui_impl_opengl2.h" />
    <ClInclude Include="..\imgui\backends\imgui_impl_opengl3.h" />
    <ClInclude Include="..\imgui\backends\imgui_impl_opengl3_loader.h" />
    <ClInclude Include="..\imgui\backends\imgui_impl_win32.h" />
    <ClInclude Include="..\imgui\imconfig.h" />
    <ClInclude Include="..\imgui\imgui.h" />
    <ClInclude Include="..\imgui\imgui_internal.h" />
    <ClInclude Include="..\imgui\imstb_rectpack.h" />
    <ClInclude Include="..\imgui\imstb_textedit.h" />
    <ClInclude Include="..\imgui\imstb_truetype.h" />
    <ClInclude Include="..\luabridge\Source\LuaBridge\Array.h" />
    <ClInclude Include="..\luabridge\Source\LuaBridge\detail\CFunctions.h" />
    <ClInclude Include="..\luabridge\Source\LuaBridge\detail\ClassInfo.h" />
    <ClInclude Include="..\luabridge\Source\LuaBridge\detail\Config.h" />
    <ClInclude Include="..\luabridge\Source\LuaBridge\detail\Constructor.h" />
    <ClInclude Include="..\luabridge\Source\LuaBridge\detail\dump.h" />
    <ClInclude Include="..\luabridge\Source\LuaBridge\detail\FuncTraits.h" />
    <ClInclude Include="..\luabridge\Source\LuaBridge\detail\Iterator.h" />
    <ClInclude Include="..\luabridge\Source\LuaBridge\detail\LuaException.h" />
    <ClInclude Include="..\luabridge\Source\LuaBridge\detail\LuaHelpers.h" />
    <ClInclude Include="..\luabridge\Source\LuaBridge\detail\LuaRef.h" />
    <ClInclude Include="..\luabridge\Source\LuaBridge\detail\Namespace.h" />
    <ClInclude Include="..\luabridge\Source\LuaBridge\detail\Security.h" />
    <ClInclude Include="..\luabridge\Source\LuaBridge\detail\Stack.h" />
    <ClInclude Include="..\luabridge\Source\LuaBridge\detail\TypeList.h" />
    <ClInclude Include="..\luabridge\Source\LuaBridge\detail\TypeTraits.h" />
    <ClInclude Include="..\luabridge\Source\LuaBridge\detail\Userdata.h" />
    <ClInclude Include="..\luabridge\Source\LuaBridge\List.h" />
    <ClInclude Include="..\luabridge\Source\LuaBridge\LuaBridge.h" />
    <ClInclude Include="..\luabridge\Source\LuaBridge\Map.h" />
    <ClInclude Include="..\luabridge\Source\LuaBridge\Optional.h" />
    <ClInclude Include="..\luabridge\Source\LuaBridge\Pair.h" />
    <ClInclude Include="..\luabridge\Source\LuaBridge\RefCountedObject.h" />
    <ClInclude Include="..\luabridge\Source\LuaBridge\RefCountedPtr.h" />
    <ClInclude Include="..\luabridge\Source\LuaBridge\UnorderedMap.h" />
    <ClInclude Include="..\luabridge\Source\LuaBridge\Vector.h" />
    <ClInclude Include="..\lua\lapi.h" />
    <ClInclude Include="..\lua\lauxlib.h" />
    <ClInclude Include="..\lua\lcode.h" />
    <ClInclude Include="..\lua\lctype.h" />
    <ClInclude Include="..\lua\ldebug.h" />
    <ClInclude Include="..\lua\ldo.h" />
    <ClInclude Include="..\lua\lfunc.h" />
    <ClInclude Include="..\lua\lgc.h" />
    <ClInclude Include="..\lua\ljumptab.h" />
    <ClInclude Include="..\lua\llex.h" />
    <ClInclude Include="..\lua\llimits.h" />
    <ClInclude Include="..\lua\lmem.h" />
    <ClInclude Include="..\lua\lobject.h" />
    <ClInclude Include="..\lua\lopcodes.h" />
    <ClInclude Include="..\lua\lopnames.h" />
    <ClInclude Include="..\lua\lparser.h" />
    <ClInclude Include="..\lua\lprefix.h" />
    <ClInclude Include="..\lua\lstate.h" />
    <ClInclude Include="..\lua\lstring.h" />
    <ClInclude Include="..\lua\ltable.h" />
    <ClInclude Include="..\lua\ltests.h" />
    <ClInclude Include="..\lua\ltm.h" />
    <ClInclude Include="..\lua\lua.h" />
    <ClInclude Include="..\lua\luaconf.h" />
    <ClInclude Include="..\lua\lualib.h" />
    <ClInclude Include="..\lua\lundump.h" />
    <ClInclude Include="..\lua\lvm.h" />
    <ClInclude Include="..\lua\lzio.h" />
    <ClInclude Include="libs\bass\bass.h" />
    <ClInclude Include="libs\bass\dll.h" />
    <ClInclude Include="libs\image\image_DXT.h" />
    <ClInclude Include="libs\image\image_helper.h" />
    <ClInclude Include="libs\image\imstb_rectpack.h" />
    <ClInclude Include="libs\image\imstb_textedit.h" />
    <ClInclude Include="libs\image\imstb_truetype.h" />
    <ClInclude Include="libs\image\khrplatform.h" />
    <ClInclude Include="libs\image\soil.h" />
    <ClInclude Include="libs\image\stbi_DDS_aug.h" />
    <ClInclude Include="libs\image\stbi_DDS_aug_c.h" />
    <ClInclude Include="libs\image\stb_image_aug.h" />
    <ClInclude Include="libs\opengl\gl.h" />
    <ClInclude Include="libs\opengl\gl3w.h" />
    <ClInclude Include="libs\opengl\glcorearb.h" />
    <ClInclude Include="libs\opengl\glu.h" />
    <ClInclude Include="libs\xor\xorstr.h" />
    <ClInclude Include="source\client.h" />
    <ClInclude Include="source\config\cvar.hpp" />
    <ClInclude Include="source\features\aimbot.h" />
    <ClInclude Include="source\features\hns\bhop.h" />
    <ClInclude Include="source\features\hns\fastrun.h" />
    <ClInclude Include="source\features\hns\groundstrafe.h" />
    <ClInclude Include="source\features\hns\jumpbug.h" />
    <ClInclude Include="source\features\hns\strafe.h" />
    <ClInclude Include="source\features\legit\knife.h" />
    <ClInclude Include="source\features\legit\laim.h" />
    <ClInclude Include="source\features\legit\trigger.h" />
    <ClInclude Include="source\features\lua\luabind.h" />
    <ClInclude Include="source\features\misc\afk.h" />
    <ClInclude Include="source\features\misc\chatspammer.h" />
    <ClInclude Include="source\features\misc\fakelatency.h" />
    <ClInclude Include="source\features\misc\idhook.h" />
    <ClInclude Include="source\features\misc\namestealer.h" />
    <ClInclude Include="source\features\misc\skipframes.h" />
    <ClInclude Include="source\features\misc\snapshot.h" />
    <ClInclude Include="source\features\misc\steamid.h" />
    <ClInclude Include="source\features\rage\antiaim.h" />
    <ClInclude Include="source\features\rage\autoroute.h" />
    <ClInclude Include="source\features\rage\fakelag.h" />
    <ClInclude Include="source\features\rage\norecoil.h" />
    <ClInclude Include="source\features\rage\nospread.h" />
    <ClInclude Include="source\features\rage\raim.h" />
    <ClInclude Include="source\features\sound\killsound.h" />
    <ClInclude Include="source\features\sound\sound.h" />
    <ClInclude Include="source\features\sound\soundesp.h" />
    <ClInclude Include="source\features\visuals\chams\chams.h" />
    <ClInclude Include="source\features\visuals\chams\studiomodelrender.h" />
    <ClInclude Include="source\features\visuals\esp\esp.h" />
    <ClInclude Include="source\features\visuals\esp\hitboxes.h" />
    <ClInclude Include="source\features\visuals\esp\radar.h" />
    <ClInclude Include="source\features\visuals\esp\snaplines.h" />
    <ClInclude Include="source\features\visuals\light\light.h" />
    <ClInclude Include="source\features\visuals\light\studio.h" />
    <ClInclude Include="source\features\visuals\local\crosshair.h" />
    <ClInclude Include="source\features\visuals\local\fov.h" />
    <ClInclude Include="source\features\visuals\local\removals\fade.h" />
    <ClInclude Include="source\features\visuals\local\removals\hands.h" />
    <ClInclude Include="source\features\visuals\local\removals\scope.h" />
    <ClInclude Include="source\features\visuals\local\skins\skins.h" />
    <ClInclude Include="source\features\visuals\local\skins\viewmodel.h" />
    <ClInclude Include="source\features\visuals\local\thirdperson.h" />
    <ClInclude Include="source\features\visuals\local\tracegrenade.h" />
    <ClInclude Include="source\features\visuals\local\world\bullettrace.h" />
    <ClInclude Include="source\features\visuals\local\world\deathmark.h" />
    <ClInclude Include="source\features\visuals\local\world\fog.h" />
    <ClInclude Include="source\features\visuals\local\world\lightmap.h" />
    <ClInclude Include="source\features\visuals\local\world\sky.h" />
    <ClInclude Include="source\features\visuals\menu\menu.h" />
    <ClInclude Include="source\features\visuals\menu\menu_widgets.h" />
    <ClInclude Include="source\features\visuals\menu\tabs\menu_colors_tab.h" />
    <ClInclude Include="source\features\visuals\menu\tabs\menu_legit_tab.h" />
    <ClInclude Include="source\features\visuals\menu\tabs\menu_misc_tab.h" />
    <ClInclude Include="source\features\visuals\menu\tabs\menu_rage_tab.h" />
    <ClInclude Include="source\features\visuals\menu\tabs\menu_visuals_tab.h" />
    <ClInclude Include="source\features\visuals\toasts\toasts.h" />
    <ClInclude Include="source\fonts\font.h" />
    <ClInclude Include="source\fonts\icons.h" />
    <ClInclude Include="source\fonts\weapons.h" />
    <ClInclude Include="source\gui\gui.h" />
    <ClInclude Include="source\gui\guiwindow.h" />
    <ClInclude Include="source\gui\guiwindowpop.h" />
    <ClInclude Include="source\helpers\anim.h" />
    <ClInclude Include="source\helpers\color.h" />
    <ClInclude Include="source\helpers\log.h" />
    <ClInclude Include="source\helpers\stringfinder.h" />
    <ClInclude Include="source\helpers\strings.h" />
    <ClInclude Include="source\helpers\textures.h" />
    <ClInclude Include="source\helpers\trace.h" />
    <ClInclude Include="source\helpers\weapons.h" />
    <ClInclude Include="source\offsets\offset.h" />
    <ClInclude Include="source\opengl.h" />
    <ClInclude Include="source\other\smth\defs.h" />
    <ClInclude Include="source\other\smth\gl3winit.h" />
    <ClInclude Include="source\other\smth\interface.h" />
    <ClInclude Include="source\other\smth\keydefs.h" />
    <ClInclude Include="source\player.h" />
    <ClInclude Include="source\usermsg.h" />
    <ClInclude Include="source\vectors\QAngle.h" />
    <ClInclude Include="source\vectors\Vector.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`sakura/sakura.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="source">
      <UniqueIdentifier>{59b91d44-d903-4a56-abc5-bc2cc0d94676}</UniqueIdentifier>
      <Extensions>cpp;c;cxx;rc;def;r;odl;idl;hpj;bat</Extensions>
    </Filter>
    <Filter Include="source\gui">
      <UniqueIdentifier>{451dfda7-6dac-4a23-bd69-913aeb284122}</UniqueIdentifier>
    </Filter>
    <Filter Include="source\config">
      <UniqueIdentifier>{5f13df87-c11a-44d1-8b37-b88e6962a78f}</UniqueIdentifier>
    </Filter>
    <Filter Include="source\features">
      <UniqueIdentifier>{ff3f0b87-18fc-47d8-a946-04929f44e1b1}</UniqueIdentifier>
    </Filter>
    <Filter Include="source\features\hns">
      <UniqueIdentifier>{5d3b8576-db0b-4f33-9619-ddad5b34ff62}</UniqueIdentifier>
    </Filter>
    <Filter Include="source\features\rage">
      <UniqueIdentifier>{c719b55c-9689-4fbe-994a-5d121a7d2de8}</UniqueIdentifier>
    </Filter>
    <Filter Include="source\features\sound">
      <UniqueIdentifier>{fc285a6e-b523-44d2-b10b-88768caf6ebf}</UniqueIdentifier>
    </Filter>
    <Filter Include="source\features\misc">
      <UniqueIdentifier>{c724aefd-3be8-43d0-beda-c335da84bf2f}</UniqueIdentifier>
    </Filter>
    <Filter Include="source\features\visuals">
      <UniqueIdentifier>{1eb19910-e734-41e7-a878-2fb94505b1c1}</UniqueIdentifier>
    </Filter>
    <Filter Include="source\features\visuals\local">
      <UniqueIdentifier>{6651d16e-ad00-4019-b871-6c97e3c664ce}</UniqueIdentifier>
    </Filter>
    <Filter Include="source\features\visuals\local\skins">
      <UniqueIdentifier>{f1112ec1-70c3-4c02-912e-87fe5b47b1bd}</UniqueIdentifier>
    </Filter>
    <Filter Include="source\features\visuals\esp">
      <UniqueIdentifier>{3f26da59-473e-4785-9f82-b4d96772dd78}</UniqueIdentifier>
    </Filter>
    <Filter Include="source\features\visuals\menu">
      <UniqueIdentifier>{836a9e4c-f202-43aa-af73-0696fa301436}</UniqueIdentifier>
    </Filter>
    <Filter Include="source\features\visuals\light">
      <UniqueIdentifier>{d5cdbcea-ea5c-40e7-abac-58e0cc644540}</UniqueIdentifier>
    </Filter>
    <Filter Include="source\features\visuals\chams / glow">
      <UniqueIdentifier>{ff2fb015-13e2-4425-b8a9-b47d645dc4f7}</UniqueIdentifier>
    </Filter>
    <Filter Include="source\features\visuals\notifications">
      <UniqueIdentifier>{bb3fed72-a6d9-4c63-b007-6b2b50c04bdf}</UniqueIdentifier>
    </Filter>
    <Filter Include="source\features\visuals\local\world">
      <UniqueIdentifier>{1bfc653d-9643-4e93-8633-642076bbf5f6}</UniqueIdentifier>
    </Filter>
    <Filter Include="source\features\visuals\local\removals">
      <UniqueIdentifier>{78590fe8-83a6-426d-90d2-98fb055d80fb}</UniqueIdentifier>
    </Filter>
    <Filter Include="source\features\visuals\menu\tabs">
      <UniqueIdentifier>{17dc54f7-24cd-4ec3-b8a4-5f30da8287e8}</UniqueIdentifier>
    </Filter>
    <Filter Include="source\features\lua">
      <UniqueIdentifier>{52f55ef1-1de6-44ac-a819-bb605bc1f9eb}</UniqueIdentifier>
    </Filter>
    <Filter Include="source\helpers">
      <UniqueIdentifier>{f875d7c2-fd95-4e06-9710-dc4372cbe68f}</UniqueIdentifier>
    </Filter>
    <Filter Include="source\offsets">
      <UniqueIdentifier>{8e88f90f-2682-4fdb-b63a-698d9177bfa2}</UniqueIdentifier>
    </Filter>
    <Filter Include="libs">
      <UniqueIdentifier>{71d54813-b9f1-4357-866d-0d69fd68bbff}</UniqueIdentifier>
    </Filter>
    <Filter Include="libs\lua">
      <UniqueIdentifier>{621a3b89-4713-4d1c-825e-80b826e4186f}</UniqueIdentifier>
    </Filter>
    <Filter Include="libs\luabridge">
      <UniqueIdentifier>{9a8ce299-1be4-4f66-b278-81786a736149}</UniqueIdentifier>
    </Filter>
    <Filter Include="libs\xor">
      <UniqueIdentifier>{e2109d56-1b95-48ff-9c4d-eab4c5ab5821}</UniqueIdentifier>
    </Filter>
    <Filter Include="source\vectors">
      <UniqueIdentifier>{0516198c-5d36-4ad4-a6af-b5c94c8b8c16}</UniqueIdentifier>
    </Filter>
    <Filter Include="libs\imgui">
      <UniqueIdentifier>{c57d378f-9b65-4f8f-ae87-6190aea4f350}</UniqueIdentifier>
    </Filter>
    <Filter Include="libs\bass">
      <UniqueIdentifier>{37b13a13-4192-44fa-8145-34c162e5b063}</UniqueIdentifier>
    </Filter>
    <Filter Include="libs\other">
      <UniqueIdentifier>{1c7030e2-18ef-47e3-815a-affc2ace44cd}</UniqueIdentifier>
    </Filter>
    <Filter Include="source\fonts">
      <UniqueIdentifier>{d8638223-d52c-4bd1-944b-7d3c1d00f40e}</UniqueIdentifier>
    </Filter>
    <Filter Include="source\features\legit">
      <UniqueIdentifier>{95344abf-7ce8-4b5f-87eb-6022672c04e7}</UniqueIdentifier>
    </Filter>
    <Filter Include="libs\detours">
      <UniqueIdentifier>{9e173997-9bbb-4795-b849-c7f094238d6e}</UniqueIdentifier>
    </Filter>
    <Filter Include="libs\opengl">
      <UniqueIdentifier>{6d3951c8-ef14-4ae8-a17e-3463b73d79bf}</UniqueIdentifier>
    </Filter>
    <Filter Include="libs\image">
      <UniqueIdentifier>{a814a90d-b3d1-4004-ad26-9d5332e3b38a}</UniqueIdentifier>
    </Filter>
    <Filter Include="libs\luabridge\detail">
      <UniqueIdentifier>{2cd961a5-19f0-4223-90ba-9361e5797288}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="source\config\cvar.cpp">
      <Filter>source\config</Filter>
    </ClCompile>
    <ClCompile Include="source\features\hns\fastrun.cpp">
      <Filter>source\features\hns</Filter>
    </ClCompile>
    <ClCompile Include="source\features\hns\groundstrafe.cpp">
      <Filter>source\features\hns</Filter>
    </ClCompile>
    <ClCompile Include="source\features\hns\jumpbug.cpp">
      <Filter>source\features\hns</Filter>
    </ClCompile>
    <ClCompile Include="source\features\hns\strafe.cpp">
      <Filter>source\features\hns</Filter>
    </ClCompile>
    <ClCompile Include="source\features\hns\bhop.cpp">
      <Filter>source\features\hns</Filter>
    </ClCompile>
    <ClCompile Include="source\features\misc\namestealer.cpp">
      <Filter>source\features\misc</Filter>
    </ClCompile>
    <ClCompile Include="source\features\misc\skipframes.cpp">
      <Filter>source\features\misc</Filter>
    </ClCompile>
    <ClCompile Include="source\features\misc\snapshot.cpp">
      <Filter>source\features\misc</Filter>
    </ClCompile>
    <ClCompile Include="source\features\misc\steamid.cpp">
      <Filter>source\features\misc</Filter>
    </ClCompile>
    <ClCompile Include="source\features\misc\afk.cpp">
      <Filter>source\features\misc</Filter>
    </ClCompile>
    <ClCompile Include="source\features\misc\chatspammer.cpp">
      <Filter>source\features\misc</Filter>
    </ClCompile>
    <ClCompile Include="source\features\misc\fakelatency.cpp">
      <Filter>source\features\misc</Filter>
    </ClCompile>
    <ClCompile Include="source\features\misc\idhook.cpp">
      <Filter>source\features\misc</Filter>
    </ClCompile>
    <ClCompile Include="source\features\rage\antiaim.cpp">
      <Filter>source\features\rage</Filter>
    </ClCompile>
    <ClCompile Include="source\features\rage\autoroute.cpp">
      <Filter>source\features\rage</Filter>
    </ClCompile>
    <ClCompile Include="source\features\rage\fakelag.cpp">
      <Filter>source\features\rage</Filter>
    </ClCompile>
    <ClCompile Include="source\features\rage\norecoil.cpp">
      <Filter>source\features\rage</Filter>
    </ClCompile>
    <ClCompile Include="source\features\rage\nospread.cpp">
      <Filter>source\features\rage</Filter>
    </ClCompile>
    <ClCompile Include="source\features\sound\killsound.cpp">
      <Filter>source\features\sound</Filter>
    </ClCompile>
    <ClCompile Include="source\features\sound\sound.cpp">
      <Filter>source\features\sound</Filter>
    </ClCompile>
    <ClCompile Include="source\features\sound\soundesp.cpp">
      <Filter>source\features\sound</Filter>
    </ClCompile>
    <ClCompile Include="source\features\visuals\chams\chams.cpp">
      <Filter>source\features\visuals\chams / glow</Filter>
    </ClCompile>
    <ClCompile Include="source\features\visuals\chams\studiomodelrender.cpp">
      <Filter>source\features\visuals\chams / glow</Filter>
    </ClCompile>
    <ClCompile Include="source\client.cpp">
      <Filter>source</Filter>
    </ClCompile>
    <ClCompile Include="source\features\visuals\menu\tabs\menu_visuals_tab.cpp">
      <Filter>source\features\visuals\menu\tabs</Filter>
    </ClCompile>
    <ClCompile Include="source\features\visuals\menu\tabs\menu_colors_tab.cpp">
      <Filter>source\features\visuals\menu\tabs</Filter>
    </ClCompile>
    <ClCompile Include="source\features\visuals\menu\tabs\menu_legit_tab.cpp">
      <Filter>source\features\visuals\menu\tabs</Filter>
    </ClCompile>
    <ClCompile Include="source\features\visuals\menu\tabs\menu_misc_tab.cpp">
      <Filter>source\features\visuals\menu\tabs</Filter>
    </ClCompile>
    <ClCompile Include="source\features\visuals\menu\tabs\menu_rage_tab.cpp">
      <Filter>source\features\visuals\menu\tabs</Filter>
    </ClCompile>
    <ClCompile Include="source\features\visuals\menu\menu_widgets.cpp">
      <Filter>source\features\visuals\menu</Filter>
    </ClCompile>
    <ClCompile Include="source\features\visuals\menu\menu.cpp">
      <Filter>source\features\visuals\menu</Filter>
    </ClCompile>
    <ClCompile Include="source\features\visuals\toasts\toasts.cpp">
      <Filter>source\features\visuals\notifications</Filter>
    </ClCompile>
    <ClCompile Include="source\features\visuals\local\removals\fade.cpp">
      <Filter>source\features\visuals\local\removals</Filter>
    </ClCompile>
    <ClCompile Include="source\features\visuals\local\removals\scope.cpp">
      <Filter>source\features\visuals\local\removals</Filter>
    </ClCompile>
    <ClCompile Include="source\features\visuals\local\skins\skins.cpp">
      <Filter>source\features\visuals\local\skins</Filter>
    </ClCompile>
    <ClCompile Include="source\features\visuals\local\skins\viewmodel.cpp">
      <Filter>source\features\visuals\local\skins</Filter>
    </ClCompile>
    <ClCompile Include="source\features\visuals\local\world\deathmark.cpp">
      <Filter>source\features\visuals\local\world</Filter>
    </ClCompile>
    <ClCompile Include="source\features\visuals\local\world\fog.cpp">
      <Filter>source\features\visuals\local\world</Filter>
    </ClCompile>
    <ClCompile Include="source\features\visuals\local\world\lightmap.cpp">
      <Filter>source\features\visuals\local\world</Filter>
    </ClCompile>
    <ClCompile Include="source\features\visuals\local\world\sky.cpp">
      <Filter>source\features\visuals\local\world</Filter>
    </ClCompile>
    <ClCompile Include="source\features\visuals\local\world\bullettrace.cpp">
      <Filter>source\features\visuals\local\world</Filter>
    </ClCompile>
    <ClCompile Include="source\features\visuals\local\crosshair.cpp">
      <Filter>source\features\visuals\local</Filter>
    </ClCompile>
    <ClCompile Include="source\features\visuals\local\fov.cpp">
      <Filter>source\features\visuals\local</Filter>
    </ClCompile>
    <ClCompile Include="source\features\visuals\local\thirdperson.cpp">
      <Filter>source\features\visuals\local</Filter>
    </ClCompile>
    <ClCompile Include="source\features\visuals\local\tracegrenade.cpp">
      <Filter>source\features\visuals\local</Filter>
    </ClCompile>
    <ClCompile Include="source\features\visuals\light\light.cpp">
      <Filter>source\features\visuals\light</Filter>
    </ClCompile>
    <ClCompile Include="source\features\visuals\light\studio.cpp">
      <Filter>source\features\visuals\light</Filter>
    </ClCompile>
    <ClCompile Include="source\features\visuals\esp\hitboxes.cpp">
      <Filter>source\features\visuals\esp</Filter>
    </ClCompile>
    <ClCompile Include="source\features\visuals\esp\radar.cpp">
      <Filter>source\features\visuals\esp</Filter>
    </ClCompile>
    <ClCompile Include="source\features\visuals\esp\snaplines.cpp">
      <Filter>source\features\visuals\esp</Filter>
    </ClCompile>
    <ClCompile Include="source\features\visuals\esp\esp.cpp">
      <Filter>source\features\visuals\esp</Filter>
    </ClCompile>
    <ClCompile Include="source\features\aimbot.cpp">
      <Filter>source\features</Filter>
    </ClCompile>
    <ClCompile Include="source\gui\gui.cpp">
      <Filter>source\gui</Filter>
    </ClCompile>
    <ClCompile Include="source\gui\guiwindow.cpp">
      <Filter>source\gui</Filter>
    </ClCompile>
    <ClCompile Include="source\gui\guiwindowpop.cpp">
      <Filter>source\gui</Filter>
    </ClCompile>
    <ClCompile Include="source\features\lua\luabind.cpp">
      <Filter>source\features\lua</Filter>
    </ClCompile>
    <ClCompile Include="source\helpers\weapons.cpp">
      <Filter>source\helpers</Filter>
    </ClCompile>
    <ClCompile Include="source\helpers\color.cpp">
      <Filter>source\helpers</Filter>
    </ClCompile>
    <ClCompile Include="source\helpers\strings.cpp">
      <Filter>source\helpers</Filter>
    </ClCompile>
    <ClCompile Include="source\vectors\Vector.cpp">
      <Filter>source\vectors</Filter>
    </ClCompile>
    <ClCompile Include="source\vectors\QAngle.cpp">
      <Filter>source\vectors</Filter>
    </ClCompile>
    <ClCompile Include="source\offsets\offset.cpp">
      <Filter>source\offsets</Filter>
    </ClCompile>
    <ClCompile Include="source\helpers\trace.cpp">
      <Filter>source\helpers</Filter>
    </ClCompile>
    <ClCompile Include="source\helpers\stringfinder.cpp">
      <Filter>source\helpers</Filter>
    </ClCompile>
    <ClCompile Include="source\player.cpp">
      <Filter>source</Filter>
    </ClCompile>
    <ClCompile Include="source\sakura_precompiled.cpp">
      <Filter>source</Filter>
    </ClCompile>
    <ClCompile Include="source\usermsg.cpp">
      <Filter>source</Filter>
    </ClCompile>
    <ClCompile Include="source\opengl.cpp">
      <Filter>source</Filter>
    </ClCompile>
    <ClCompile Include="source\main.cpp">
      <Filter>source</Filter>
    </ClCompile>
    <ClCompile Include="source\other\smth\interface.cpp">
      <Filter>libs\other</Filter>
    </ClCompile>
    <ClCompile Include="source\features\visuals\local\removals\hands.cpp">
      <Filter>source\features\visuals\local\removals</Filter>
    </ClCompile>
    <ClCompile Include="source\features\legit\laim.cpp">
      <Filter>source\features\legit</Filter>
    </ClCompile>
    <ClCompile Include="source\features\rage\raim.cpp">
      <Filter>source\features\rage</Filter>
    </ClCompile>
    <ClCompile Include="source\features\legit\trigger.cpp">
      <Filter>source\features\legit</Filter>
    </ClCompile>
    <ClCompile Include="source\features\legit\knife.cpp">
      <Filter>source\features\legit</Filter>
    </ClCompile>
    <ClCompile Include="libs\bass\dll_image.cpp">
      <Filter>libs\bass</Filter>
    </ClCompile>
    <ClCompile Include="libs\bass\dll.cpp">
      <Filter>libs\bass</Filter>
    </ClCompile>
    <ClCompile Include="source\helpers\log.cpp">
      <Filter>source\helpers</Filter>
    </ClCompile>
    <ClCompile Include="source\helpers\anim.cpp">
      <Filter>source\helpers</Filter>
    </ClCompile>
    <ClCompile Include="..\halflife\parsemsg.cpp">
      <Filter>source\helpers</Filter>
    </ClCompile>
    <ClCompile Include="source\helpers\textures.cpp">
      <Filter>source\helpers</Filter>
    </ClCompile>
    <ClCompile Include="..\detours\src\disasm.cpp">
      <Filter>libs\detours</Filter>
    </ClCompile>
    <ClCompile Include="..\detours\src\disolarm.cpp">
      <Filter>libs\detours</Filter>
    </ClCompile>
    <ClCompile Include="..\detours\src\disolarm64.cpp">
      <Filter>libs\detours</Filter>
    </ClCompile>
    <ClCompile Include="..\detours\src\disolia64.cpp">
      <Filter>libs\detours</Filter>
    </ClCompile>
    <ClCompile Include="..\detours\src\disolx64.cpp">
      <Filter>libs\detours</Filter>
    </ClCompile>
    <ClCompile Include="..\detours\src\disolx86.cpp">
      <Filter>libs\detours</Filter>
    </ClCompile>
    <ClCompile Include="..\detours\src\image.cpp">
      <Filter>libs\detours</Filter>
    </ClCompile>
    <ClCompile Include="..\detours\src\modules.cpp">
      <Filter>libs\detours</Filter>
    </ClCompile>
    <ClCompile Include="..\detours\src\creatwth.cpp">
      <Filter>libs\detours</Filter>
    </ClCompile>
    <ClCompile Include="..\detours\src\detours.cpp">
      <Filter>libs\detours</Filter>
    </ClCompile>
    <ClCompile Include="libs\opengl\gl3w.cpp">
      <Filter>libs\opengl</Filter>
    </ClCompile>
    <ClCompile Include="libs\image\soil.cpp">
      <Filter>libs\image</Filter>
    </ClCompile>
    <ClCompile Include="libs\image\stb_image_aug.cpp">
      <Filter>libs\image</Filter>
    </ClCompile>
    <ClCompile Include="libs\image\image_DXT.cpp">
      <Filter>libs\image</Filter>
    </ClCompile>
    <ClCompile Include="libs\image\image_helper.cpp">
      <Filter>libs\image</Filter>
    </ClCompile>
    <ClCompile Include="..\imgui\imgui.cpp">
      <Filter>libs\imgui</Filter>
    </ClCompile>
    <ClCompile Include="..\imgui\imgui_demo.cpp">
      <Filter>libs\imgui</Filter>
    </ClCompile>
    <ClCompile Include="..\imgui\imgui_draw.cpp">
      <Filter>libs\imgui</Filter>
    </ClCompile>
    <ClCompile Include="..\imgui\imgui_tables.cpp">
      <Filter>libs\imgui</Filter>
    </ClCompile>
    <ClCompile Include="..\imgui\imgui_widgets.cpp">
      <Filter>libs\imgui</Filter>
    </ClCompile>
    <ClCompile Include="..\imgui\backends\imgui_impl_win32.cpp">
      <Filter>libs\imgui</Filter>
    </ClCompile>
    <ClCompile Include="..\imgui\backends\imgui_impl_opengl2.cpp">
      <Filter>libs\imgui</Filter>
    </ClCompile>
    <ClCompile Include="..\imgui\backends\imgui_impl_opengl3.cpp">
      <Filter>libs\imgui</Filter>
    </ClCompile>
    <ClCompile Include="source\other\smth\gl3winit.cpp">
      <Filter>libs\other</Filter>
    </ClCompile>
    <ClCompile Include="..\lua\lundump.c">
      <Filter>libs\lua</Filter>
    </ClCompile>
    <ClCompile Include="..\lua\lutf8lib.c">
      <Filter>libs\lua</Filter>
    </ClCompile>
    <ClCompile Include="..\lua\lvm.c">
      <Filter>libs\lua</Filter>
    </ClCompile>
    <ClCompile Include="..\lua\lzio.c">
      <Filter>libs\lua</Filter>
    </ClCompile>
    <ClCompile Include="..\lua\lapi.c">
      <Filter>libs\lua</Filter>
    </ClCompile>
    <ClCompile Include="..\lua\lauxlib.c">
      <Filter>libs\lua</Filter>
    </ClCompile>
    <ClCompile Include="..\lua\lbaselib.c">
      <Filter>libs\lua</Filter>
    </ClCompile>
    <ClCompile Include="..\lua\lcode.c">
      <Filter>libs\lua</Filter>
    </ClCompile>
    <ClCompile Include="..\lua\lcorolib.c">
      <Filter>libs\lua</Filter>
    </ClCompile>
    <ClCompile Include="..\lua\lctype.c">
      <Filter>libs\lua</Filter>
    </ClCompile>
    <ClCompile Include="..\lua\ldblib.c">
      <Filter>libs\lua</Filter>
    </ClCompile>
    <ClCompile Include="..\lua\ldebug.c">
      <Filter>libs\lua</Filter>
    </ClCompile>
    <ClCompile Include="..\lua\ldo.c">
      <Filter>libs\lua</Filter>
    </ClCompile>
    <ClCompile Include="..\lua\ldump.c">
      <Filter>libs\lua</Filter>
    </ClCompile>
    <ClCompile Include="..\lua\lfunc.c">
      <Filter>libs\lua</Filter>
    </ClCompile>
    <ClCompile Include="..\lua\lgc.c">
      <Filter>libs\lua</Filter>
    </ClCompile>
    <ClCompile Include="..\lua\linit.c">
      <Filter>libs\lua</Filter>
    </ClCompile>
    <ClCompile Include="..\lua\liolib.c">
      <Filter>libs\lua</Filter>
    </ClCompile>
    <ClCompile Include="..\lua\llex.c">
      <Filter>libs\lua</Filter>
    </ClCompile>
    <ClCompile Include="..\lua\lmathlib.c">
      <Filter>libs\lua</Filter>
    </ClCompile>
    <ClCompile Include="..\lua\lmem.c">
      <Filter>libs\lua</Filter>
    </ClCompile>
    <ClCompile Include="..\lua\loadlib.c">
      <Filter>libs\lua</Filter>
    </ClCompile>
    <ClCompile Include="..\lua\lobject.c">
      <Filter>libs\lua</Filter>
    </ClCompile>
    <ClCompile Include="..\lua\lopcodes.c">
      <Filter>libs\lua</Filter>
    </ClCompile>
    <ClCompile Include="..\lua\loslib.c">
      <Filter>libs\lua</Filter>
    </ClCompile>
    <ClCompile Include="..\lua\lparser.c">
      <Filter>libs\lua</Filter>
    </ClCompile>
    <ClCompile Include="..\lua\lstate.c">
      <Filter>libs\lua</Filter>
    </ClCompile>
    <ClCompile Include="..\lua\lstring.c">
      <Filter>libs\lua</Filter>
    </ClCompile>
    <ClCompile Include="..\lua\lstrlib.c">
      <Filter>libs\lua</Filter>
    </ClCompile>
    <ClCompile Include="..\lua\ltable.c">
      <Filter>libs\lua</Filter>
    </ClCompile>
    <ClCompile Include="..\lua\ltablib.c">
      <Filter>libs\lua</Filter>
    </ClCompile>
    <ClCompile Include="..\lua\ltests.c">
      <Filter>libs\lua</Filter>
    </ClCompile>
    <ClCompile Include="..\lua\ltm.c">
      <Filter>libs\lua</Filter>
    </ClCompile>
    <ClCompile Include="..\lua\lua.c">
      <Filter>libs\lua</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="source\config\cvar.hpp">
      <Filter>source\config</Filter>
    </ClInclude>
    <ClInclude Include="source\features\hns\bhop.h">
      <Filter>source\features\hns</Filter>
    </ClInclude>
    <ClInclude Include="source\features\hns\fastrun.h">
      <Filter>source\features\hns</Filter>
    </ClInclude>
    <ClInclude Include="source\features\hns\groundstrafe.h">
      <Filter>source\features\hns</Filter>
    </ClInclude>
    <ClInclude Include="source\features\hns\jumpbug.h">
      <Filter>source\features\hns</Filter>
    </ClInclude>
    <ClInclude Include="source\features\hns\strafe.h">
      <Filter>source\features\hns</Filter>
    </ClInclude>
    <ClInclude Include="source\features\misc\idhook.h">
      <Filter>source\features\misc</Filter>
    </ClInclude>
    <ClInclude Include="source\features\misc\namestealer.h">
      <Filter>source\features\misc</Filter>
    </ClInclude>
    <ClInclude Include="source\features\misc\skipframes.h">
      <Filter>source\features\misc</Filter>
    </ClInclude>
    <ClInclude Include="source\features\misc\snapshot.h">
      <Filter>source\features\misc</Filter>
    </ClInclude>
    <ClInclude Include="source\features\misc\steamid.h">
      <Filter>source\features\misc</Filter>
    </ClInclude>
    <ClInclude Include="source\features\misc\afk.h">
      <Filter>source\features\misc</Filter>
    </ClInclude>
    <ClInclude Include="source\features\misc\chatspammer.h">
      <Filter>source\features\misc</Filter>
    </ClInclude>
    <ClInclude Include="source\features\misc\fakelatency.h">
      <Filter>source\features\misc</Filter>
    </ClInclude>
    <ClInclude Include="source\features\rage\nospread.h">
      <Filter>source\features\rage</Filter>
    </ClInclude>
    <ClInclude Include="source\features\rage\antiaim.h">
      <Filter>source\features\rage</Filter>
    </ClInclude>
    <ClInclude Include="source\features\rage\autoroute.h">
      <Filter>source\features\rage</Filter>
    </ClInclude>
    <ClInclude Include="source\features\rage\fakelag.h">
      <Filter>source\features\rage</Filter>
    </ClInclude>
    <ClInclude Include="source\features\rage\norecoil.h">
      <Filter>source\features\rage</Filter>
    </ClInclude>
    <ClInclude Include="source\features\sound\soundesp.h">
      <Filter>source\features\sound</Filter>
    </ClInclude>
    <ClInclude Include="source\features\sound\killsound.h">
      <Filter>source\features\sound</Filter>
    </ClInclude>
    <ClInclude Include="source\features\sound\sound.h">
      <Filter>source\features\sound</Filter>
    </ClInclude>
    <ClInclude Include="source\features\visuals\chams\chams.h">
      <Filter>source\features\visuals\chams / glow</Filter>
    </ClInclude>
    <ClInclude Include="source\features\visuals\chams\studiomodelrender.h">
      <Filter>source\features\visuals\chams / glow</Filter>
    </ClInclude>
    <ClInclude Include="source\client.h">
      <Filter>source</Filter>
    </ClInclude>
    <ClInclude Include="source\features\visuals\menu\tabs\menu_visuals_tab.h">
      <Filter>source\features\visuals\menu\tabs</Filter>
    </ClInclude>
    <ClInclude Include="source\features\visuals\menu\tabs\menu_colors_tab.h">
      <Filter>source\features\visuals\menu\tabs</Filter>
    </ClInclude>
    <ClInclude Include="source\features\visuals\menu\tabs\menu_legit_tab.h">
      <Filter>source\features\visuals\menu\tabs</Filter>
    </ClInclude>
    <ClInclude Include="source\features\visuals\menu\tabs\menu_misc_tab.h">
      <Filter>source\features\visuals\menu\tabs</Filter>
    </ClInclude>
    <ClInclude Include="source\features\visuals\menu\tabs\menu_rage_tab.h">
      <Filter>source\features\visuals\menu\tabs</Filter>
    </ClInclude>
    <ClInclude Include="source\features\visuals\menu\menu.h">
      <Filter>source\features\visuals\menu</Filter>
    </ClInclude>
    <ClInclude Include="source\features\visuals\menu\menu_widgets.h">
      <Filter>source\features\visuals\menu</Filter>
    </ClInclude>
    <ClInclude Include="source\features\visuals\toasts\toasts.h">
      <Filter>source\features\visuals\notifications</Filter>
    </ClInclude>
    <ClInclude Include="source\features\visuals\local\removals\scope.h">
      <Filter>source\features\visuals\local\removals</Filter>
    </ClInclude>
    <ClInclude Include="source\features\visuals\local\removals\fade.h">
      <Filter>source\features\visuals\local\removals</Filter>
    </ClInclude>
    <ClInclude Include="source\features\visuals\local\skins\skins.h">
      <Filter>source\features\visuals\local\skins</Filter>
    </ClInclude>
    <ClInclude Include="source\features\visuals\local\skins\viewmodel.h">
      <Filter>source\features\visuals\local\skins</Filter>
    </ClInclude>
    <ClInclude Include="source\features\visuals\local\world\deathmark.h">
      <Filter>source\features\visuals\local\world</Filter>
    </ClInclude>
    <ClInclude Include="source\features\visuals\local\world\fog.h">
      <Filter>source\features\visuals\local\world</Filter>
    </ClInclude>
    <ClInclude Include="source\features\visuals\local\world\lightmap.h">
      <Filter>source\features\visuals\local\world</Filter>
    </ClInclude>
    <ClInclude Include="source\features\visuals\local\world\sky.h">
      <Filter>source\features\visuals\local\world</Filter>
    </ClInclude>
    <ClInclude Include="source\features\visuals\local\world\bullettrace.h">
      <Filter>source\features\visuals\local\world</Filter>
    </ClInclude>
    <ClInclude Include="source\features\visuals\local\crosshair.h">
      <Filter>source\features\visuals\local</Filter>
    </ClInclude>
    <ClInclude Include="source\features\visuals\local\fov.h">
      <Filter>source\features\visuals\local</Filter>
    </ClInclude>
    <ClInclude Include="source\features\visuals\local\thirdperson.h">
      <Filter>source\features\visuals\local</Filter>
    </ClInclude>
    <ClInclude Include="source\features\visuals\local\tracegrenade.h">
      <Filter>source\features\visuals\local</Filter>
    </ClInclude>
    <ClInclude Include="source\features\visuals\light\studio.h">
      <Filter>source\features\visuals\light</Filter>
    </ClInclude>
    <ClInclude Include="source\features\visuals\light\light.h">
      <Filter>source\features\visuals\light</Filter>
    </ClInclude>
    <ClInclude Include="source\features\visuals\esp\hitboxes.h">
      <Filter>source\features\visuals\esp</Filter>
    </ClInclude>
    <ClInclude Include="source\features\visuals\esp\radar.h">
      <Filter>source\features\visuals\esp</Filter>
    </ClInclude>
    <ClInclude Include="source\features\visuals\esp\snaplines.h">
      <Filter>source\features\visuals\esp</Filter>
    </ClInclude>
    <ClInclude Include="source\features\visuals\esp\esp.h">
      <Filter>source\features\visuals\esp</Filter>
    </ClInclude>
    <ClInclude Include="source\features\aimbot.h">
      <Filter>source\features</Filter>
    </ClInclude>
    <ClInclude Include="source\gui\guiwindowpop.h">
      <Filter>source\gui</Filter>
    </ClInclude>
    <ClInclude Include="source\gui\gui.h">
      <Filter>source\gui</Filter>
    </ClInclude>
    <ClInclude Include="source\gui\guiwindow.h">
      <Filter>source\gui</Filter>
    </ClInclude>
    <ClInclude Include="source\features\lua\luabind.h">
      <Filter>source\features\lua</Filter>
    </ClInclude>
    <ClInclude Include="source\helpers\weapons.h">
      <Filter>source\helpers</Filter>
    </ClInclude>
    <ClInclude Include="source\helpers\color.h">
      <Filter>source\helpers</Filter>
    </ClInclude>
    <ClInclude Include="source\helpers\strings.h">
      <Filter>source\helpers</Filter>
    </ClInclude>
    <ClInclude Include="source\vectors\QAngle.h">
      <Filter>source\vectors</Filter>
    </ClInclude>
    <ClInclude Include="source\vectors\Vector.h">
      <Filter>source\vectors</Filter>
    </ClInclude>
    <ClInclude Include="source\offsets\offset.h">
      <Filter>source\offsets</Filter>
    </ClInclude>
    <ClInclude Include="source\helpers\trace.h">
      <Filter>source\helpers</Filter>
    </ClInclude>
    <ClInclude Include="source\helpers\stringfinder.h">
      <Filter>source\helpers</Filter>
    </ClInclude>
    <ClInclude Include="libs\xor\xorstr.h">
      <Filter>libs\xor</Filter>
    </ClInclude>
    <ClInclude Include="source\player.h">
      <Filter>source</Filter>
    </ClInclude>
    <ClInclude Include="source\usermsg.h">
      <Filter>source</Filter>
    </ClInclude>
    <ClInclude Include="source\opengl.h">
      <Filter>source</Filter>
    </ClInclude>
    <ClInclude Include="source\other\smth\interface.h">
      <Filter>libs\other</Filter>
    </ClInclude>
    <ClInclude Include="source\other\smth\keydefs.h">
      <Filter>libs\other</Filter>
    </ClInclude>
    <ClInclude Include="source\other\smth\defs.h">
      <Filter>libs\other</Filter>
    </ClInclude>
    <ClInclude Include="source\features\visuals\local\removals\hands.h">
      <Filter>source\features\visuals\local\removals</Filter>
    </ClInclude>
    <ClInclude Include="source\fonts\icons.h">
      <Filter>source\fonts</Filter>
    </ClInclude>
    <ClInclude Include="source\fonts\weapons.h">
      <Filter>source\fonts</Filter>
    </ClInclude>
    <ClInclude Include="source\fonts\font.h">
      <Filter>source\fonts</Filter>
    </ClInclude>
    <ClInclude Include="source\features\legit\laim.h">
      <Filter>source\features\legit</Filter>
    </ClInclude>
    <ClInclude Include="source\features\rage\raim.h">
      <Filter>source\features\rage</Filter>
    </ClInclude>
    <ClInclude Include="source\features\legit\trigger.h">
      <Filter>source\features\legit</Filter>
    </ClInclude>
    <ClInclude Include="source\features\legit\knife.h">
      <Filter>source\features\legit</Filter>
    </ClInclude>
    <ClInclude Include="libs\bass\bass.h">
      <Filter>libs\bass</Filter>
    </ClInclude>
    <ClInclude Include="libs\bass\dll.h">
      <Filter>libs\bass</Filter>
    </ClInclude>
    <ClInclude Include="source\helpers\log.h">
      <Filter>source\helpers</Filter>
    </ClInclude>
    <ClInclude Include="source\helpers\anim.h">
      <Filter>source\helpers</Filter>
    </ClInclude>
    <ClInclude Include="..\halflife\parsemsg.h">
      <Filter>source\helpers</Filter>
    </ClInclude>
    <ClInclude Include="source\helpers\textures.h">
      <Filter>source\helpers</Filter>
    </ClInclude>
    <ClInclude Include="..\detours\src\detver.h">
      <Filter>libs\detours</Filter>
    </ClInclude>
    <ClInclude Include="..\detours\src\detours.h">
      <Filter>libs\detours</Filter>
    </ClInclude>
    <ClInclude Include="libs\opengl\gl3w.h">
      <Filter>libs\opengl</Filter>
    </ClInclude>
    <ClInclude Include="libs\opengl\glcorearb.h">
      <Filter>libs\opengl</Filter>
    </ClInclude>
    <ClInclude Include="libs\opengl\glu.h">
      <Filter>libs\opengl</Filter>
    </ClInclude>
    <ClInclude Include="libs\opengl\gl.h">
      <Filter>libs\opengl</Filter>
    </ClInclude>
    <ClInclude Include="libs\image\imstb_textedit.h">
      <Filter>libs\image</Filter>
    </ClInclude>
    <ClInclude Include="libs\image\imstb_truetype.h">
      <Filter>libs\image</Filter>
    </ClInclude>
    <ClInclude Include="libs\image\khrplatform.h">
      <Filter>libs\image</Filter>
    </ClInclude>
    <ClInclude Include="libs\image\soil.h">
      <Filter>libs\image</Filter>
    </ClInclude>
    <ClInclude Include="libs\image\stb_image_aug.h">
      <Filter>libs\image</Filter>
    </ClInclude>
    <ClInclude Include="libs\image\stbi_DDS_aug.h">
      <Filter>libs\image</Filter>
    </ClInclude>
    <ClInclude Include="libs\image\stbi_DDS_aug_c.h">
      <Filter>libs\image</Filter>
    </ClInclude>
    <ClInclude Include="libs\image\image_DXT.h">
      <Filter>libs\image</Filter>
    </ClInclude>
    <ClInclude Include="libs\image\image_helper.h">
      <Filter>libs\image</Filter>
    </ClInclude>
    <ClInclude Include="libs\image\imstb_rectpack.h">
      <Filter>libs\image</Filter>
    </ClInclude>
    <ClInclude Include="..\imgui\imgui.h">
      <Filter>libs\imgui</Filter>
    </ClInclude>
    <ClInclude Include="..\imgui\imgui_internal.h">
      <Filter>libs\imgui</Filter>
    </ClInclude>
    <ClInclude Include="..\imgui\imstb_rectpack.h">
      <Filter>libs\imgui</Filter>
    </ClInclude>
    <ClInclude Include="..\imgui\imstb_textedit.h">
      <Filter>libs\imgui</Filter>
    </ClInclude>
    <ClInclude Include="..\imgui\imstb_truetype.h">
      <Filter>libs\imgui</Filter>
    </ClInclude>
    <ClInclude Include="..\imgui\imconfig.h">
      <Filter>libs\imgui</Filter>
    </ClInclude>
    <ClInclude Include="..\imgui\backends\imgui_impl_win32.h">
      <Filter>libs\imgui</Filter>
    </ClInclude>
    <ClInclude Include="..\imgui\backends\imgui_impl_opengl2.h">
      <Filter>libs\imgui</Filter>
    </ClInclude>
    <ClInclude Include="..\imgui\backends\imgui_impl_opengl3.h">
      <Filter>libs\imgui</Filter>
    </ClInclude>
    <ClInclude Include="..\imgui\backends\imgui_impl_opengl3_loader.h">
      <Filter>libs\imgui</Filter>
    </ClInclude>
    <ClInclude Include="source\other\smth\gl3winit.h">
      <Filter>libs\other</Filter>
    </ClInclude>
    <ClInclude Include="..\luabridge\Source\LuaBridge\LuaBridge.h">
      <Filter>libs\luabridge</Filter>
    </ClInclude>
    <ClInclude Include="..\luabridge\Source\LuaBridge\Map.h">
      <Filter>libs\luabridge</Filter>
    </ClInclude>
    <ClInclude Include="..\luabridge\Source\LuaBridge\Optional.h">
      <Filter>libs\luabridge</Filter>
    </ClInclude>
    <ClInclude Include="..\luabridge\Source\LuaBridge\Pair.h">
      <Filter>libs\luabridge</Filter>
    </ClInclude>
    <ClInclude Include="..\luabridge\Source\LuaBridge\RefCountedObject.h">
      <Filter>libs\luabridge</Filter>
    </ClInclude>
    <ClInclude Include="..\luabridge\Source\LuaBridge\RefCountedPtr.h">
      <Filter>libs\luabridge</Filter>
    </ClInclude>
    <ClInclude Include="..\luabridge\Source\LuaBridge\UnorderedMap.h">
      <Filter>libs\luabridge</Filter>
    </ClInclude>
    <ClInclude Include="..\luabridge\Source\LuaBridge\Vector.h">
      <Filter>libs\luabridge</Filter>
    </ClInclude>
    <ClInclude Include="..\luabridge\Source\LuaBridge\Array.h">
      <Filter>libs\luabridge</Filter>
    </ClInclude>
    <ClInclude Include="..\luabridge\Source\LuaBridge\List.h">
      <Filter>libs\luabridge</Filter>
    </ClInclude>
    <ClInclude Include="..\luabridge\Source\LuaBridge\detail\dump.h">
      <Filter>libs\luabridge\detail</Filter>
    </ClInclude>
    <ClInclude Include="..\luabridge\Source\LuaBridge\detail\FuncTraits.h">
      <Filter>libs\luabridge\detail</Filter>
    </ClInclude>
    <ClInclude Include="..\luabridge\Source\LuaBridge\detail\Iterator.h">
      <Filter>libs\luabridge\detail</Filter>
    </ClInclude>
    <ClInclude Include="..\luabridge\Source\LuaBridge\detail\LuaException.h">
      <Filter>libs\luabridge\detail</Filter>
    </ClInclude>
    <ClInclude Include="..\luabridge\Source\LuaBridge\detail\LuaHelpers.h">
      <Filter>libs\luabridge\detail</Filter>
    </ClInclude>
    <ClInclude Include="..\luabridge\Source\LuaBridge\detail\LuaRef.h">
      <Filter>libs\luabridge\detail</Filter>
    </ClInclude>
    <ClInclude Include="..\luabridge\Source\LuaBridge\detail\Namespace.h">
      <Filter>libs\luabridge\detail</Filter>
    </ClInclude>
    <ClInclude Include="..\luabridge\Source\LuaBridge\detail\Security.h">
      <Filter>libs\luabridge\detail</Filter>
    </ClInclude>
    <ClInclude Include="..\luabridge\Source\LuaBridge\detail\Stack.h">
      <Filter>libs\luabridge\detail</Filter>
    </ClInclude>
    <ClInclude Include="..\luabridge\Source\LuaBridge\detail\TypeList.h">
      <Filter>libs\luabridge\detail</Filter>
    </ClInclude>
    <ClInclude Include="..\luabridge\Source\LuaBridge\detail\TypeTraits.h">
      <Filter>libs\luabridge\detail</Filter>
    </ClInclude>
    <ClInclude Include="..\luabridge\Source\LuaBridge\detail\Userdata.h">
      <Filter>libs\luabridge\detail</Filter>
    </ClInclude>
    <ClInclude Include="..\luabridge\Source\LuaBridge\detail\CFunctions.h">
      <Filter>libs\luabridge\detail</Filter>
    </ClInclude>
    <ClInclude Include="..\luabridge\Source\LuaBridge\detail\ClassInfo.h">
      <Filter>libs\luabridge\detail</Filter>
    </ClInclude>
    <ClInclude Include="..\luabridge\Source\LuaBridge\detail\Config.h">
      <Filter>libs\luabridge\detail</Filter>
    </ClInclude>
    <ClInclude Include="..\luabridge\Source\LuaBridge\detail\Constructor.h">
      <Filter>libs\luabridge\detail</Filter>
    </ClInclude>
    <ClInclude Include="..\lua\lundump.h">
      <Filter>libs\lua</Filter>
    </ClInclude>
    <ClInclude Include="..\lua\lvm.h">
      <Filter>libs\lua</Filter>
    </ClInclude>
    <ClInclude Include="..\lua\lzio.h">
      <Filter>libs\lua</Filter>
    </ClInclude>
    <ClInclude Include="..\lua\lapi.h">
      <Filter>libs\lua</Filter>
    </ClInclude>
    <ClInclude Include="..\lua\lauxlib.h">
      <Filter>libs\lua</Filter>
    </ClInclude>
    <ClInclude Include="..\lua\lcode.h">
      <Filter>libs\lua</Filter>
    </ClInclude>
    <ClInclude Include="..\lua\lctype.h">
      <Filter>libs\lua</Filter>
    </ClInclude>
    <ClInclude Include="..\lua\ldebug.h">
      <Filter>libs\lua</Filter>
    </ClInclude>
    <ClInclude Include="..\lua\ldo.h">
      <Filter>libs\lua</Filter>
    </ClInclude>
    <ClInclude Include="..\lua\lfunc.h">
      <Filter>libs\lua</Filter>
    </ClInclude>
    <ClInclude Include="..\lua\lgc.h">
      <Filter>libs\lua</Filter>
    </ClInclude>
    <ClInclude Include="..\lua\ljumptab.h">
      <Filter>libs\lua</Filter>
    </ClInclude>
    <ClInclude Include="..\lua\llex.h">
      <Filter>libs\lua</Filter>
    </ClInclude>
    <ClInclude Include="..\lua\llimits.h">
      <Filter>libs\lua</Filter>
    </ClInclude>
    <ClInclude Include="..\lua\lmem.h">
      <Filter>libs\lua</Filter>
    </ClInclude>
    <ClInclude Include="..\lua\lobject.h">
      <Filter>libs\lua</Filter>
    </ClInclude>
    <ClInclude Include="..\lua\lopcodes.h">
      <Filter>libs\lua</Filter>
    </ClInclude>
    <ClInclude Include="..\lua\lopnames.h">
      <Filter>libs\lua</Filter>
    </ClInclude>
    <ClInclude Include="..\lua\lparser.h">
      <Filter>libs\lua</Filter>
    </ClInclude>
    <ClInclude Include="..\lua\lprefix.h">
      <Filter>libs\lua</Filter>
    </ClInclude>
    <ClInclude Include="..\lua\lstate.h">
      <Filter>libs\lua</Filter>
    </ClInclude>
    <ClInclude Include="..\lua\lstring.h">
      <Filter>libs\lua</Filter>
    </ClInclude>
    <ClInclude Include="..\lua\ltable.h">
      <Filter>libs\lua</Filter>
    </ClInclude>
    <ClInclude Include="..\lua\ltests.h">
      <Filter>libs\lua</Filter>
    </ClInclude>
    <ClInclude Include="..\lua\ltm.h">
      <Filter>libs\lua</Filter>
    </ClInclude>
    <ClInclude Include="..\lua\lua.h">
      <Filter>libs\lua</Filter>
    </ClInclude>
    <ClInclude Include="..\lua\luaconf.h">
      <Filter>libs\lua</Filter>
    </ClInclude>
    <ClInclude Include="..\lua\lualib.h">
      <Filter>libs\lua</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`sakura/sakura.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LocalDebuggerAttach>false</LocalDebuggerAttach>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
    <LocalDebuggerSQLDebugging>false</LocalDebuggerSQLDebugging>
    <LocalDebuggerMergeEnvironment>false</LocalDebuggerMergeEnvironment>
    <LocalDebuggerCommand>
    </LocalDebuggerCommand>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LocalDebuggerAttach>true</LocalDebuggerAttach>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
    <LocalDebuggerSQLDebugging>false</LocalDebuggerSQLDebugging>
    <LocalDebuggerMergeEnvironment>true</LocalDebuggerMergeEnvironment>
    <LocalDebuggerCommand>Z:\Steam\steamapps\common\Half-Life\hl.exe</LocalDebuggerCommand>
    <LocalDebuggerWorkingDirectory>$(ProjectDir)</LocalDebuggerWorkingDirectory>
  </PropertyGroup>
</Project>
```

`sakura/source/client.cpp`:

```cpp
#include "client.h"

cl_clientfunc_t *g_pClient;
cl_enginefunc_t *g_pEngine;
engine_studio_api_t *g_pStudio;
r_studio_interface_t* g_pInterface;
StudioModelRenderer_t* g_pStudioModelRenderer;
playermove_t* pmove;

CL_Move_t CL_Move_s;
PreS_DynamicSound_t PreS_DynamicSound_s;
cl_clientfunc_t g_Client;
cl_enginefunc_t g_Engine;
engine_studio_api_t g_Studio;
r_studio_interface_t g_Interface;
StudioModelRenderer_t g_StudioModelRenderer;

netchan_t* g_pNetchan;
Netchan_TransmitBits_t Netchan_TransmitBits_s;

Screenshot_t Screenshot_s;
Snapshot_t Snapshot_s;

//EV_HLDM_FireBullets_t EV_HLDM_FireBullets_s;

client_state_t* client_state;
client_static_t* client_static;

DWORD HudRedraw;

void HUD_Redraw(float time, int intermission)
{
	g_Client.HUD_Redraw(time, intermission);
	HudRedraw = GetTickCount();
	DrawOverviewLayer();
	KzFameCount();
}

int HUD_Key_Event(int down, int keynum, const char* pszCurrentBinding)
{
	//preset keys bind
	bool keystrafetoggle	= keynum == cvar.kz_strafe_toggle_key;
	bool thirdpersonkey		= keynum == cvar.misc_thirdperson_key;
	bool keyrush			= cvar.speedhack_active && keynum == cvar.route_rush_key;
	bool keystrafe			= cvar.kz_strafe && keynum == cvar.kz_strafe_key;
	bool keyfast			= cvar.kz_fast_run && keynum == cvar.kz_fastrun_key;
	bool keygstrafe			= cvar.kz_ground_strafe && keynum == cvar.kz_ground_strafe_key;
	bool keybhop			= cvar.kz_bhop && keynum == cvar.kz_bhop_key;
	bool keyjump			= cvar.kz_jump_bug && keynum == cvar.kz_jumpbug_key;
	bool keyrage			= cvar.rage_active && !cvar.rage_auto_fire && !cvar.rage_always_fire && keynum == cvar.rage_auto_fire_key;
	bool keylegit			= !cvar.rage_active && cvar.legit[g_Local.weapon.m_iWeaponID].active && IsCurWeaponGun() && keynum == cvar.legit_key;
	bool keylegittrigger	= !cvar.rage_active && cvar.legit[g_Local.weapon.m_iWeaponID].trigger_active && IsCurWeaponGun() && keynum == cvar.legit_trigger_key;
	bool keymenu			= keynum == cvar.gui_key;

	//send keys to menu
	keysmenu[keynum] = down;
	
	//return game bind for menu bind
	if (keymenu && down)
	{
		bShowMenu = !bShowMenu;

		if(!bShowMenu && cvar.misc_auto_config_save)
			SaveCvar();

		return false;
	}

	//return game bind if menu active
	if (bShowMenu && GetTickCount() - HudRedraw <= 100)
		return false;

	for (size_t i = 0; i < Sakura::Lua::scripts.size(); ++i)
	{
		auto& script = Sakura::Lua::scripts[i];

		if (!script.HasCallback(Sakura::Lua::SAKURA_CALLBACK_TYPE::SAKURA_CALLBACK_AT_CLIENT_BIND))
			continue;

		auto& callbacks = script.GetCallbacks(Sakura::Lua::SAKURA_CALLBACK_TYPE::SAKURA_CALLBACK_AT_CLIENT_BIND);
		for (const auto& callback : callbacks)
		{
			try
			{
				callback(down, keynum);
			}
			catch (luabridge::LuaException const& error)
			{
				if (script.GetState())
				{
					Sakura::Lua::Error("Error has occured in the lua \"On Key Bind\" script: %s", error.what());
					script.RemoveAllCallbacks();
				}
			}
		}
	}

	//check if alive
	if (Sakura::Player::Local::IsAlive())
	{
		if (keystrafetoggle && down)
		{
			Sakura::HNS::Strafe::Active = !Sakura::HNS::Strafe::Active;
			Toast::Create(3, "Strafe %s", Sakura::HNS::Strafe::Active ? "activated" : "deactivated");
		}

		if (thirdpersonkey && down)
		{
			cvar.visual_chase_cam = !cvar.visual_chase_cam;
			Toast::Create(3, "Third person %s", cvar.visual_chase_cam ? "activated" : "deactivated");
		}

		if (keyrush)
		{
			if (down)
			{
				if(cvar.route_activate) cvar.route_auto = 1;
				cvar.misc_wav_speed = cvar.speedhack_speed;
			}
			else
			{
				if (cvar.route_activate) cvar.route_auto = 0;
				cvar.misc_wav_speed = 1;
			}
		}

		if (keystrafe)
			Sakura::HNS::Strafe::Active = down;

		if (keyfast)
			Sakura::HNS::Fastrun::Active = down;

		if (keygstrafe)
			Sakura::HNS::Groundstrafe::Active = down;

		if (keybhop)
			Sakura::HNS::BunnyHop::Active = down;

		if (keyjump)
			Sakura::HNS::Jumpbug::Active = down;

		if (keyrage)
			Sakura::Aimbot::Rage::RageKeyStatus = down;

		if (keylegit)
			Sakura::Aimbot::Legit::LegitKeyStatus = down;

		if (keylegittrigger && down)
		{
			Sakura::Triggerbot::TriggerKeyStatus = !Sakura::Triggerbot::TriggerKeyStatus;
			Toast::Create(3, "Trigger %s", Sakura::Triggerbot::TriggerKeyStatus ? "activated" : "deactivated");
		}
		
		if ((keystrafe || keyfast || keygstrafe || keybhop || keyjump || keyrage || keylegittrigger || keylegit || keyrush) && down)
			return false;
	}
	
	return g_Client.HUD_Key_Event(down, keynum, pszCurrentBinding);
}

void CL_CreateMove(float frametime, usercmd_s* cmd, int active)
{
	g_Client.CL_CreateMove(frametime, cmd, active);

	AdjustSpeed(cvar.misc_wav_speed);
	Sakura::Player::Local::Update(frametime, cmd);

	g_Sequences.Update();

	if (Sakura::Player::Local::IsAlive())
	{
		UpdateWeaponData();
		Sakura::Aimbot::Logic(cmd);
		ContinueFire(cmd);
		ItemPostFrame(cmd);
		NoRecoil(cmd);
		NoSpread(cmd);
		Route(cmd);
		AntiAim::Local(cmd);
		FakeLag(frametime, cmd);
		Sakura::Name::Stealer();

		Sakura::HNS::BunnyHop::Logic(cmd);
		Sakura::HNS::Jumpbug::Logic(frametime, cmd);
		Sakura::HNS::Groundstrafe::Logic(cmd);
		Sakura::HNS::Fastrun::Logic(cmd);
		Sakura::HNS::Strafe::Logic(cmd);

		if (Sakura::Player::Local::InGame())
		{
			Sakura::Fakelatency::Logic();

			if (cvar.visual_weapon_noanim)
				g_Engine.pfnWeaponAnim(0, 0);
		}
	}

	Kz(frametime, cmd);
	Sakura::AntiAfk::Run(cmd);
	BulletTrace::Local(cmd);
	Sakura::ChatSpammer::Logic();

	for (size_t i = 0; i < Sakura::Lua::scripts.size(); ++i)
	{
		auto& script = Sakura::Lua::scripts[i];

		if (!script.HasCallback(Sakura::Lua::SAKURA_CALLBACK_TYPE::SAKURA_CALLBACK_AT_CLIENT_MOVE))
			continue;

		auto& callbacks = script.GetCallbacks(Sakura::Lua::SAKURA_CALLBACK_TYPE::SAKURA_CALLBACK_AT_CLIENT_MOVE);
		for (const auto& callback : callbacks)
		{
			try
			{
				callback(frametime, cmd, active);
			}
			catch (luabridge::LuaException const& error)
			{
				if (script.GetState())
				{
					Sakura::Lua::Error("Error has occured in the lua \"On Create Move\" script: %s", error.what());
					script.RemoveAllCallbacks();
				}
			}
		}
	}
}

void HUD_PostRunCmd(local_state_s* from, local_state_s* to, usercmd_s* cmd, int runfuncs, double time, unsigned int random_seed)
{
	g_Client.HUD_PostRunCmd(from, to, cmd, runfuncs, time, random_seed);

	ItemPreFrame(from, to, cmd, runfuncs, time, random_seed);
}

void bSendpacket(bool status)
{
	static bool bsendpacket_status = true;
	static DWORD NULLTIME = NULL;
	if (status && !bsendpacket_status)
	{
		bsendpacket_status = true;
		*(DWORD*)(c_Offset.dwSendPacketPointer) = c_Offset.dwSendPacketBackup;
	}
	if (!status && bsendpacket_status)
	{
		bsendpacket_status = false;
		*(DWORD*)(c_Offset.dwSendPacketPointer) = (DWORD)& NULLTIME;
	}
}

void CL_Move()
{
	bSendpacket(true);
	CL_Move_s();
}

void AdjustSpeed(double speed)
{
	static double LastSpeed = 1;
	if (speed != LastSpeed)
	{
		*(double*)c_Offset.dwSpeedPointer = (speed * 1000);

		LastSpeed = speed;
	}
}

void HUD_PlayerMoveInit(playermove_s* ppmove)
{
	Sakura::Texture::PM_InitTextureTypes(ppmove);
	return g_Client.HUD_PlayerMoveInit(ppmove);
}

void HUD_ProcessPlayerState(entity_state_s* dst, const entity_state_s* src)
{
	for (size_t i = 0; i < 3; ++i)
		src->mins[i] = i == 2 ? -36 : -16;

	for (size_t i = 0; i < 3; ++i)
		src->maxs[i] = i == 2 ? 36 : 16;

	g_Client.HUD_ProcessPlayerState(dst, src);
}

int HUD_GetHullBounds(int hullnum, float* mins, float* maxs)
{
	if (hullnum == 1)
		maxs[2] = 32.0f;

	return 1;
}

int CL_IsThirdPerson()
{
	if (cvar.visual_chase_cam && Sakura::Player::Local::IsAlive() && Sakura::ScreenShot::IsVisuals())
		return 1;

	return g_Client.CL_IsThirdPerson();
}

void HUD_Frame(double time)
{
	SetSkins();
	Sakura::ScreenShot::Run();
	Sakura::Sky::ChangeTexture();
	Sakura::Fade::Logic();
	Sakura::Map::Light();
	Sakura::Fog::Draw();

	PlayerAim.deque::clear();
	PlayerBone.deque::clear();
	PlayerHitbox.deque::clear();
	PlayerEsp.deque::clear();
	WorldEsp.deque::clear();
	WorldEspPrev.deque::clear();
	WorldBone.deque::clear();
	WorldHitbox.deque::clear();
	PlayerHitboxNum.deque::clear();
	g_Client.HUD_Frame(time);
}

void PreV_CalcRefdef(ref_params_s* pparams)
{
	g_Local.vPunchangle = pparams->punchangle;
	g_Local.vPrevForward = pparams->forward;
	g_Local.iPrevHealth = pparams->health;
	V_CalcRefdefRecoil(pparams);

	if(cvar.rage_active && cvar.rage_no_spread && cvar.rage_no_spread_visual && IsCurWeaponGun())
	{
		pparams->punchangle[0] += g_Local.vNoSpreadAngle[0] * 2;
		pparams->punchangle[1] += g_Local.vNoSpreadAngle[1] * 2;
		pparams->punchangle[2] += g_Local.vNoSpreadAngle[2] * 2;
	}
}

void PostV_CalcRefdef(ref_params_s* pparams)
{
	g_Local.vPostForward = pparams->forward;
	g_Local.iPostHealth = pparams->health;
	GetRadarAngle(pparams);
	ViewModelFov(pparams);
	//ViewModels();
	Sakura::Thirdperson::Logic(pparams);
}

void V_CalcRefdef(ref_params_s* pparams)
{
	PreV_CalcRefdef(pparams);
	g_Client.V_CalcRefdef(pparams);
	PostV_CalcRefdef(pparams);
}

void HUD_CreateEntities()
{
	g_Client.HUD_CreateEntities();
}

int pfnDrawUnicodeCharacter(int x, int y, int ch, int r, int g, int b, unsigned int font)
{
	if (cvar.visual_hud_clear)
		return 1;

	return g_Engine.pfnVGUI2DrawCharacterAdd(x, y, ch, r, g, b, font);
}

void FakeLagHistory(const cl_entity_s* ent, const float flTime)
{
	std::array<int, HISTORY_MAX> m_iHistory;
	const int m_flTime = flTime;

	m_iHistory[m_flTime] = (ent->current_position + HISTORY_MAX - m_flTime) % HISTORY_MAX;

	memcpy(&g_Player[ent->index].playerHistory, ent, sizeof(*ent));
	g_Player[ent->index].playerHistory.curstate.weaponmodel = -1;
	g_Player[ent->index].playerHistory.angles = ent->ph[m_iHistory[m_flTime]].angles;
	g_Player[ent->index].playerHistory.origin = ent->ph[m_iHistory[m_flTime]].origin;
	g_Engine.CL_CreateVisibleEntity(ENTITY_TYPE_NORMAL, &g_Player[ent->index].playerHistory);
}

int HUD_AddEntity(int type, cl_entity_s* ent, const char* modelname)
{
	if (!Sakura::ScreenShot::IsVisuals())
		return g_Client.HUD_AddEntity(type, ent, modelname);

	bool isPlayer = false;
	bool isLocalPlayer = false;

	if (ent && ent->player)
	{
		const int playerIndex = ent->index;

		if (cvar.visual_deathmark_enable && g_Player[playerIndex].deathMark)
			DeathMark::Create(ent);

		isPlayer = Sakura::Player::IsAlive(playerIndex) && playerIndex != pmove->player_index + 1;
		isLocalPlayer = Sakura::Player::Local::IsAlive() && playerIndex == pmove->player_index + 1;
	}

	if (isLocalPlayer && cvar.visual_chase_cam)
	{
		if (cvar.visual_fakelag_history_local)
			FakeLagHistory(ent, DEFAULT_FAKE_LAG_HISTORY);

		if (cvar.rage_antiaim_active && cvar.aa_roll_active)
		{
			AntiAim::Entity(ent);
			g_Engine.CL_CreateVisibleEntity(ENTITY_TYPE_PLAYER, ent);
			return 0;
		}
	}

	if (isPlayer && !(cvar.visual_idhook_only && IdHook::FirstKillPlayer[ent->index] == IDHOOK_PLAYER_OFF))
	{
		const int playerIndex = ent->index;

		if (cvar.visual_dont_render_players && g_Player[playerIndex].iTeam == g_Local.iTeam)
			return 0;

		if ((!cvar.visual_visual_team && g_Player[playerIndex].iTeam == g_Local.iTeam))
			return g_Client.HUD_AddEntity(type, ent, modelname);

		if (cvar.misc_fakelatency)
		{
			Vector entTempOrigin;
			if (Sakura::Backtrack::Player(ent, g_Local.sLerpMSec, entTempOrigin))
			{
				memcpy(&g_Player[ent->index].playerHistory, ent, sizeof(*ent));
				g_Player[ent->index].playerHistory.origin = entTempOrigin;
				g_Engine.CL_CreateVisibleEntity(ENTITY_TYPE_NORMAL, &g_Player[playerIndex].playerHistory);
			}
		}

		BulletTrace::Enemy(ent);
	}

	for (size_t i = 0; i < Sakura::Lua::scripts.size(); ++i)
	{
		auto& script = Sakura::Lua::scripts[i];

		if (!script.HasCallback(Sakura::Lua::SAKURA_CALLBACK_TYPE::SAKURA_CALLBACK_AT_ADDENTITY))
			continue;

		auto& callbacks = script.GetCallbacks(Sakura::Lua::SAKURA_CALLBACK_TYPE::SAKURA_CALLBACK_AT_ADDENTITY);
		for (const auto& callback : callbacks)
		{
			try
			{
				callback(ent ? ent->index : NULL, ent ? ent->player : NULL, ent ? ent->origin : NULL, ent ? ent->angles : NULL);
			}
			catch (luabridge::LuaException const& error)
			{
				Sakura::Lua::Error("Error has occured in the lua \"On Add Entity\" script: %s", error.what());
				script.RemoveAllCallbacks();
			}
		}
	}

	return g_Client.HUD_AddEntity(type, ent, modelname);
}

static void HUD_TempEntUpdate(double frametime, double client_time, double cl_gravity, tempent_s** ppTempEntFree, tempent_s** ppTempEntActive,
	int(*Callback_AddVisibleEntity)(cl_entity_s* pEntity), void(*Callback_TempEntPlaySound)(tempent_s* pTemp, float damp))
{
	if (!Sakura::ScreenShot::IsVisuals())
	{
		g_Client.HUD_TempEntUpdate(frametime, client_time, cl_gravity, ppTempEntFree, ppTempEntActive, Callback_AddVisibleEntity, Callback_TempEntPlaySound);
		return;
	}

	Sakura::DynamicLight::Draw();

	g_Client.HUD_TempEntUpdate(frametime, client_time, cl_gravity, ppTempEntFree, ppTempEntActive, Callback_AddVisibleEntity, Callback_TempEntPlaySound);
}

void pfnSPRSet(HSPRITE hPic, int r, int g, int b)
{
	if (cvar.visual_hud && Sakura::ScreenShot::IsVisuals() && (int)hPic != 13 && (int)hPic != 12) // radar sprite - thanks to oxik
	{
		ImRGBA color = Sakura::Colors::GetCustomizedColor(cvar.visual_hud_color, cvar.rainbow_hud);

		r = (int)(color.r * 255);
		g = (int)(color.g * 255);
		b = (int)(color.b * 255);
	}

	g_Engine.pfnSPR_Set(hPic, r, g, b);
}

void HookClientFunctions()
{
	g_pClient->HUD_CreateEntities = HUD_CreateEntities;
	g_pClient->HUD_Frame = HUD_Frame;
	g_pClient->HUD_Redraw = HUD_Redraw;
	g_pClient->CL_CreateMove = CL_CreateMove;
	g_pClient->HUD_PlayerMoveInit = HUD_PlayerMoveInit;
	g_pClient->V_CalcRefdef = V_CalcRefdef;
	g_pClient->HUD_PostRunCmd = HUD_PostRunCmd;
	g_pClient->HUD_Key_Event = HUD_Key_Event;
	g_pClient->HUD_ProcessPlayerState = HUD_ProcessPlayerState;
	g_pClient->HUD_GetHullBounds = HUD_GetHullBounds;
	g_pClient->CL_IsThirdPerson = CL_IsThirdPerson;

	g_pClient->HUD_TempEntUpdate = HUD_TempEntUpdate;

	g_pEngine->pfnVGUI2DrawCharacterAdd = pfnDrawUnicodeCharacter;
	g_pEngine->pfnSPR_Set = pfnSPRSet;

	g_pClient->HUD_AddEntity = HUD_AddEntity;
}
```

`sakura/source/client.h`:

```h
#ifndef _CLIENT_
#define _CLIENT_

#pragma once

#pragma warning(disable:4005)
#pragma warning(disable:4018)
#pragma warning(disable:4244)
#pragma warning(disable:4715)
#pragma warning(disable:4819)
#pragma warning(disable:4996)
#pragma warning(disable:4700)
#pragma warning(disable:4305)
#pragma warning(disable:4410)
#pragma warning(disable:4409)
#pragma warning(disable:4002)

#define _CRT_SECURE_NO_WARNINGS

#define _USE_MATH_DEFINES
#define IMGUI_DEFINE_MATH_OPERATORS

#define ENTITY_TYPE_NORMAL 0
#define ENTITY_TYPE_PLAYER 1
#define DEFAULT_FAKE_LAG_HISTORY 0.0

#include <ctime>
#include <map>
#include <vector>
#include <fstream>
#include <windows.h>
#include <iostream>
#include <sstream>
#include <array>
#include <deque>
#include <math.h>
#include <list>
#include <filesystem>

namespace Sakura
{
	extern bool Unloading;
	extern char CheatDir[MAX_PATH];
	extern char HLDir[MAX_PATH];
	extern HINSTANCE Module;

	void Unload();
};

#include "../libs/bass/dll.h"
#include "../libs/bass/bass.h"

#include "other/smth/interface.h"

#include "../../imgui/imgui.h"
#include "../../imgui/backends/imgui_impl_win32.h"
#include "../../imgui/backends/imgui_impl_opengl2.h"
#include "../../imgui/backends/imgui_impl_opengl3.h"
#include "../../imgui/imgui_internal.h"
#include "../libs/image/soil.h"
#include "../libs/opengl/gl.h"
#include "../libs/opengl/glu.h"

#include "features/visuals/menu/menu_widgets.h"

#include "vectors/vector.h"
#include "vectors/qangle.h"

#include "../../halflife/engine/wrect.h"
#include "../../halflife/engine/cl_dll.h"
#include "../../halflife/engine/cdll_int.h"
#include "../../halflife/engine/entity_types.h"
#include "../../halflife/engine/pmtrace.h"
#include "../../halflife/engine/pm_defs.h"
#include "../../halflife/engine/pm_movevars.h"
#include "../../halflife/engine/r_efx.h"
#include "../../halflife/engine/studio.h"
#include "../../halflife/engine/studio_event.h"
#include "../../halflife/engine/triangleapi.h"
#include "../../halflife/engine/cvardef.h"
#include "../../halflife/engine/client.h" // client static, client state
#include "../../halflife/common/com_model.h"
#include "../../halflife/common/event_api.h"
#include "../../halflife/common/ref_params.h"
#include "../../halflife/common/screenfade.h"
#include "../../halflife/common/net_api.h"
#include "../../halflife/common/con_nprint.h"
#include "../../halflife/misc/r_studioint.h"
#include "../../halflife/misc/steamtypes.h"
#include "../../halflife/engine/net.h" // netchan
#include "../../halflife/parsemsg.h"

#include "../../detours/src/detours.h"
#include "other/smth/defs.h"
#include "helpers/stringfinder.h"
#include "helpers/trace.h"
#include "helpers/textures.h"
#include "helpers/log.h"
#include "helpers/anim.h"
#include "other/smth/keydefs.h"
#include "../libs/xor/xorstr.h"

extern "C" {
#include "lua.h"
#include "lualib.h"
#include "lauxlib.h"
}

#include "LuaBridge/Vector.h"
#include "LuaBridge/LuaBridge.h"
#include "features/lua/luabind.h" // custom

#include "other/smth/gl3winit.h"

#include "opengl.h"
#include "usermsg.h"
#include "offsets/offset.h"
#include "features/sound/soundesp.h"
#include "helpers/weapons.h"
#include "player.h"
#include "config/cvar.hpp"
#include "helpers/color.h"
#include "features/hns/strafe.h"
#include "features/hns/fastrun.h"
#include "features/hns/jumpbug.h"
#include "features/hns/bhop.h"
#include "features/hns/groundstrafe.h"
#include "features/misc/idhook.h"
#include "features/rage/autoroute.h"
#include "gui/gui.h"
#include "features/visuals/esp/esp.h"
#include "features/visuals/menu/menu.h"
#include "features/visuals/menu/tabs/menu_rage_tab.h"
#include "features/visuals/menu/tabs/menu_legit_tab.h"
#include "features/visuals/menu/tabs/menu_visuals_tab.h"
#include "features/visuals/menu/tabs/menu_misc_tab.h"
#include "features/visuals/menu/tabs/menu_colors_tab.h"
#include "features/misc/snapshot.h"
#include "features/aimbot.h"
#include "features/legit/laim.h"
#include "features/legit/trigger.h"
#include "features/legit/knife.h"
#include "features/rage/raim.h"
#include "features/rage/norecoil.h"
#include "features/rage/nospread.h"
#include "features/visuals/chams/studiomodelrender.h"
#include "features/visuals/chams/chams.h"
#include "features/visuals/local/skins/skins.h"
#include "features/sound/sound.h"
#include "features/visuals/esp/hitboxes.h"
#include "features/visuals/local/crosshair.h"
#include "features/visuals/local/tracegrenade.h"
#include "features/visuals/local/removals/fade.h"
#include "features/visuals/light/studio.h"
#include "features/visuals/light/light.h"
#include "features/visuals/toasts/toasts.h"
#include "gui/guiwindow.h"
#include "features/rage/antiaim.h"
#include "features/rage/fakelag.h"
#include "features/sound/killsound.h"
#include "features/misc/steamid.h"
#include "features/visuals/local/world/lightmap.h"
#include "features/visuals/local/world/sky.h"
#include "features/visuals/esp/radar.h"
#include "helpers/strings.h"
#include "features/visuals/local/skins/viewmodel.h"
#include "features/visuals/local/removals/hands.h"
#include "features/misc/afk.h"
#include "gui/guiwindowpop.h"
#include "features/visuals/local/thirdperson.h"
#include "features/visuals/esp/snaplines.h"
#include "features/misc/namestealer.h"
#include "features/misc/chatspammer.h"
#include "features/visuals/local/world/fog.h"
#include "features/visuals/local/fov.h"
#include "features/misc/skipframes.h"
#include "features/visuals/local/removals/scope.h"
#include "features/misc/fakelatency.h"
#include "features/visuals/local/world/deathmark.h"
#include "features/visuals/local/world/bullettrace.h"

void HookClientFunctions();
void CL_Move();
void bSendpacket(bool status);
void AdjustSpeed(double speed);

typedef struct cl_clientfuncs_s
{
	int(*Initialize) (cl_enginefunc_t *pEnginefuncs, int iVersion);
	int(*HUD_Init) (void);
	int(*HUD_VidInit) (void);
	void(*HUD_Redraw) (float time, int intermission);
	int(*HUD_UpdateClientData) (client_data_t *pcldata, float flTime);
	int(*HUD_Reset) (void);
	void(*HUD_PlayerMove) (struct playermove_s *ppmove, int server);
	void(*HUD_PlayerMoveInit) (struct playermove_s *ppmove);
	char(*HUD_PlayerMoveTexture) (char *name);
	void(*IN_ActivateMouse) (void);
	void(*IN_DeactivateMouse) (void);
	void(*IN_MouseEvent) (int mstate);
	void(*IN_ClearStates) (void);
	void(*IN_Accumulate) (void);
	void(*CL_CreateMove) (float frametime, struct usercmd_s *cmd, int active);
	int(*CL_IsThirdPerson) (void);
	void(*CL_CameraOffset) (float *ofs);
	struct kbutton_s *(*KB_Find) (const char *name);
	void(*CAM_Think) (void);
	void(*V_CalcRefdef) (struct ref_params_s *pparams);
	int(*HUD_AddEntity) (int type, struct cl_entity_s *ent, const char *modelname);
	void(*HUD_CreateEntities) (void);
	void(*HUD_DrawNormalTriangles) (void);
	void(*HUD_DrawTransparentTriangles) (void);
	void(*HUD_StudioEvent) (const struct mstudioevent_s *event, const struct cl_entity_s *entity);
	void(*HUD_PostRunCmd) (struct local_state_s *from, struct local_state_s *to, struct usercmd_s *cmd, int runfuncs, double time, unsigned int random_seed);
	void(*HUD_Shutdown) (void);
	void(*HUD_TxferLocalOverrides) (struct entity_state_s *state, const struct clientdata_s *client);
	void(*HUD_ProcessPlayerState) (struct entity_state_s *dst, const struct entity_state_s *src);
	void(*HUD_TxferPredictionData) (struct entity_state_s *ps, const struct entity_state_s *pps, struct clientdata_s *pcd, const struct clientdata_s *ppcd, struct weapon_data_s *wd, const struct weapon_data_s *pwd);
	void(*Demo_ReadBuffer) (int size, unsigned char *buffer);
	int(*HUD_ConnectionlessPacket) (struct netadr_s *net_from, const char *args, char *response_buffer, int *response_buffer_size);
	int(*HUD_GetHullBounds) (int hullnumber, float *mins, float *maxs);
	void(*HUD_Frame) (double time);
	int(*HUD_Key_Event) (int down, int keynum, const char *pszCurrentBinding);
	void(*HUD_TempEntUpdate) (double frametime, double client_time, double cl_gravity, struct tempent_s **ppTempEntFree, struct tempent_s **ppTempEntActive, int(*Callback_AddVisibleEntity)(struct cl_entity_s *pEntity), void(*Callback_TempEntPlaySound)(struct tempent_s *pTemp, float damp));
	struct cl_entity_s *(*HUD_GetUserEntity) (int index);
	int(*HUD_VoiceStatus) (int entindex, qboolean bTalking);
	int(*HUD_DirectorMessage) (unsigned char command, unsigned int firstObject, unsigned int secondObject, unsigned int flags);
	int(*HUD_GetStudioModelInterface) (int version, struct r_studio_interface_s **ppinterface, struct engine_studio_api_s *pstudio);
	void(*HUD_CHATINPUTPOSITION_FUNCTION) (int *x, int *y);
	int(*HUD_GETPLAYERTEAM_FUNCTION) (int iplayer);
	void(*CLIENTFACTORY) (void);
} cl_clientfunc_t; 

extern cl_clientfunc_t *g_pClient;
extern cl_enginefunc_t *g_pEngine;
extern engine_studio_api_t *g_pStudio;
extern r_studio_interface_t* g_pInterface;
extern StudioModelRenderer_t* g_pStudioModelRenderer;
extern playermove_t* pmove;
typedef void(*CL_Move_t)();

extern CL_Move_t CL_Move_s;
extern PreS_DynamicSound_t PreS_DynamicSound_s;
extern cl_clientfunc_t g_Client;
extern cl_enginefunc_t g_Engine;
extern engine_studio_api_t g_Studio;
extern r_studio_interface_t g_Interface;
extern StudioModelRenderer_t g_StudioModelRenderer;

typedef void(__cdecl *Netchan_TransmitBits_t)(netchan_t*, int, byte*);
extern Netchan_TransmitBits_t Netchan_TransmitBits_s;
extern netchan_t* g_pNetchan;

typedef void(__cdecl* Screenshot_t)();
typedef void(__cdecl* Snapshot_t)();
extern Screenshot_t Screenshot_s;
extern Snapshot_t Snapshot_s;

extern client_state_t* client_state;
extern client_static_t* client_static;

extern DWORD HudRedraw;

#endif
```

`sakura/source/config/cvar.cpp`:

```cpp
#include "../client.h"

CVARlist cvar;
StringFinder names; 
std::vector<Entry> entries;

int Sakura::Config::SelectedConfig = 0;
int Sakura::Config::DefaultConfig = 0;
int Sakura::Config::ConfigCount = 0;
std::vector<std::string> Sakura::Config::List;

const std::string configExtension = /*.ini*/XorStr<0x84, 5, 0x54BDC5D7>("\xAA\xEC\xE8\xEE" + 0x54BDC5D7).s;

void Sakura::Config::GetAll()
{
	List.push_back(/*default.ini*/XorStr<0x43, 12, 0x717EB79D>("\x27\x21\x23\x27\x32\x24\x3D\x64\x22\x22\x24" + 0x717EB79D).s);

	const std::string cd = Sakura::CheatDir;
	const std::string configDir = cd + /*\\configs\\*/XorStr<0x3C, 10, 0x0E5CC77F>("\x60\x5E\x51\x51\x26\x28\x25\x30\x18" + 0x0E5CC77F).s;

	try
	{
		// Check if the configs directory exists
		if (!std::filesystem::is_directory(configDir))
		{
			Sakura::Log::File(/*Config directory not found: %s*/XorStr<0xCC, 31, 0xC6637DC2>("\x8F\xA2\xA0\xA9\xB9\xB6\xF2\xB7\xBD\xA7\xB3\xB4\xAC\xB6\xA8\xA2\xFC\xB3\xB1\xAB\xC0\x87\x8D\x96\x8A\x81\xDC\xC7\xCD\x9A" + 0xC6637DC2).s, configDir.c_str());
			return;
		}

		for (const auto& p : std::filesystem::recursive_directory_iterator(configDir))
		{
			std::string temp = p.path().stem().string() + configExtension;

			// Skip over default.ini
			if (temp == /*default.ini*/XorStr<0xAE, 12, 0x63568316>("\xCA\xCA\xD6\xD0\xC7\xDF\xC0\x9B\xDF\xD9\xD1" + 0x63568316).s) continue;

			ConfigCount++;

			// Add any config files to the configs vector
			if (p.path().extension() == configExtension)
				List.push_back(std::string(temp));
		}
	}
	catch (const std::filesystem::filesystem_error& e)
	{
		Sakura::Log::File(/*Filesystem error while getting configs: %s*/XorStr<0xFA, 43, 0x6B28C767>("\xBC\x92\x90\x98\x8D\x86\x73\x75\x67\x6E\x24\x60\x74\x75\x67\x7B\x2A\x7C\x64\x64\x62\x6A\x30\x76\x77\x67\x60\x7C\x78\x70\x38\x7A\x75\x75\x7A\x74\x79\x6C\x1A\x01\x07\x50" + 0x6B28C767).s, e.what());
	}
}

void Sakura::Config::GetDefault()
{
	const std::string cd = Sakura::CheatDir;

	try
	{
		for (const auto& p : std::filesystem::recursive_directory_iterator(cd + /*\\assets\\*/XorStr<0x9E, 9, 0x246BF17A>("\xC2\xFE\xD3\xD2\xC7\xD7\xD7\xF9" + 0x246BF17A).s))
		{
			if (std::filesystem::is_regular_file(p) && p.path().filename() == /*config.sakura*/XorStr<0x59, 14, 0x23CABD26>("\x3A\x35\x35\x3A\x34\x39\x71\x13\x00\x09\x16\x16\x04" + 0x23CABD26).s)
			{
				std::ifstream file(p.path());

				if (!file.is_open())
				{
					Sakura::Log::File(/*Failed to open file: %s*/XorStr<0x18, 24, 0x2A92DA2B>("\x5E\x78\x73\x77\x79\x79\x3E\x6B\x4F\x01\x4D\x53\x41\x4B\x06\x41\x41\x45\x4F\x11\x0C\x08\x5D" + 0x2A92DA2B).s, p.path());
					break;
				}

				std::string line;
				while (std::getline(file, line))
				{
					try
					{
						SelectedConfig = std::stoi(line);
						DefaultConfig = SelectedConfig;
					}
					catch (const std::invalid_argument& e)
					{
						Sakura::Log::File(/*Invalid argument while reading a default config load: %s*/XorStr<0x45, 57, 0xCAF8C3F1>("\x0C\x28\x31\x29\x25\x23\x2F\x6C\x2C\x3C\x28\x25\x3C\x37\x3D\x20\x75\x21\x3F\x31\x35\x3F\x7B\x2E\x38\x3F\x3B\x09\x0F\x05\x43\x05\x45\x02\x02\x0E\x08\x1F\x07\x18\x4D\x0D\x00\x1E\x17\x1B\x14\x54\x19\x19\x16\x1C\x43\x5A\x5E\x0F" + 0xCAF8C3F1).s, e.what());
					}
					catch (const std::out_of_range& e)
					{
						Sakura::Log::File(/*Out of range while reading a default config load: %s*/XorStr<0x88, 53, 0x9ECBAB9A>("\xC7\xFC\xFE\xAB\xE3\xEB\xAE\xFD\xF1\xFF\xF5\xF6\xB4\xE2\xFE\xFE\xF4\xFC\xBA\xE9\xF9\xFC\xFA\xF6\xCE\xC6\x82\xC2\x84\xC1\xC3\xC1\xC9\xDC\xC6\xDF\x8C\xCE\xC1\xC1\xD6\xD8\xD5\x93\xD8\xDA\xD7\xD3\x82\x99\x9F\xC8" + 0x9ECBAB9A).s, e.what());
					}
				}

				file.close();
				break;
			}
		}
	}
	catch (const std::filesystem::filesystem_error& e)
	{
		Sakura::Log::File(/*Filesystem error while reading a default config load: %s*/XorStr<0x10, 57, 0x3FC1F984>("\x56\x78\x7E\x76\x67\x6C\x65\x63\x7D\x74\x3A\x7E\x6E\x6F\x71\x6D\x00\x56\x4A\x4A\x48\x40\x06\x55\x4D\x48\x4E\x42\x42\x4A\x0E\x4E\x10\x55\x57\x55\x55\x40\x5A\x43\x18\x5A\x55\x55\x5A\x54\x59\x1F\x2C\x2E\x23\x27\x7E\x65\x63\x34" + 0x3FC1F984).s, e.what());
	}
}

void Sakura::Config::SaveDefault()
{
	const std::string cd = Sakura::CheatDir;
	const std::string configPath = cd + /*\\assets\\config.sakura*/XorStr<0x73, 22, 0x2093A6FF>("\x2F\x15\x06\x05\x12\x0C\x0A\x26\x18\x13\x13\x18\x16\xE7\xAF\xF1\xE2\xEF\xF0\xF4\xE6" + 0x2093A6FF).s;

	try
	{
		std::ofstream file(configPath);

		if (!file.is_open())
		{
			Sakura::Log::File(/*Failed to open file for writing: %s*/XorStr<0x37, 36, 0xE756E577>("\x71\x59\x50\x56\x5E\x58\x1D\x4A\x50\x60\x2E\x32\x26\x2A\x65\x20\x2E\x24\x2C\x6A\x2D\x23\x3F\x6E\x38\x22\x38\x26\x3A\x3A\x32\x6C\x77\x7D\x2A" + 0xE756E577).s, configPath.c_str());
			return;
		}

		file << SelectedConfig;
		file.close();
	}
	catch (const std::exception& e)
	{
		Sakura::Log::File(/*Error while saving default config: %s*/XorStr<0x61, 38, 0xD72001AA>("\x24\x10\x11\x0B\x17\x46\x10\x00\x00\x06\x0E\x4C\x1E\x0F\x19\x19\x1F\x15\x53\x10\x10\x10\x16\x0D\x15\x0E\x5B\x1F\x12\x10\x19\xE9\xE6\xB8\xA3\xA1\xF6" + 0xD72001AA).s, e.what());
	}
}

std::string Sakura::Config::GetCurrent()
{
	return List[SelectedConfig];
}

void Sakura::Config::Save(std::ofstream& ofs)
{
	ofs << /*[CVAR]\n*/XorStr<0xD6, 8, 0x81CD2591>("\x8D\x94\x8E\x98\x88\x86\xD6" + 0x81CD2591).s;

	for (names.it_start(); names.it_running(); names.it_next())
	{
		Entry& r = entries[names.num];
		ofs << names.str << /*=*/XorStr<0xDD, 2, 0x12448F07>("\xE0" + 0x12448F07).s << *(float*)r.data << /*\n*/XorStr<0xAF, 2, 0x6981A996>("\xA5" + 0x6981A996).s;
	}
}

void Sakura::Config::Load()
{
	char cvar_f[500];
	DWORD size = 500;

	for (names.it_start(); names.it_running(); names.it_next())
	{
		Entry& r = entries[names.num];

		GetPrivateProfileString(/*CVAR*/XorStr<0x8C, 5, 0x07B4A87E>("\xCF\xDB\xCF\xDD" + 0x07B4A87E).s, names.str, /*NULL*/XorStr<0xB6, 5, 0x0D14959C>("\xF8\xE2\xF4\xF5" + 0x0D14959C).s, cvar_f, size, Sakura::File::GetSakuraDir(GetCurrent().c_str()).c_str());
		*(float*)r.data = atof(cvar_f);
	}
}

void Sakura::Cvar::Add(const char* name, void* data)
{
	int index = entries.size();
	Entry tmp = { data };
	entries.push_back(tmp);
	names.add(name, index);
}

void Sakura::Cvar::New(const char* cvarName, float &cvar, float defaultValue)
{
	Add(cvarName, &cvar);
	cvar = defaultValue;
}

void Sakura::File::Init()
{
	const std::string cd = Sakura::CheatDir;

	std::filesystem::create_directories(cd + /*\\assets\\*/XorStr<0xCE, 9, 0x47946738>("\x92\xAE\xA3\xA2\xB7\xA7\xA7\x89" + 0x47946738).s);
	std::filesystem::create_directories(cd + /*\\assets\\routes\\*/XorStr<0xCA, 16, 0xC777363C>("\x96\xAA\xBF\xBE\xAB\xBB\xA3\x8D\xA0\xBC\xA1\xA1\xB3\xA4\x84" + 0xC777363C).s);
	std::filesystem::create_directories(cd + /*\\configs\\*/XorStr<0x1C, 10, 0x1EFC7AD5>("\x40\x7E\x71\x71\x46\x48\x45\x50\x78" + 0x1EFC7AD5).s);
	std::filesystem::create_directories(cd + /*\\scripts\\*/XorStr<0x03, 10, 0xB372F82C>("\x5F\x77\x66\x74\x6E\x78\x7D\x79\x57" + 0xB372F82C).s);
}

bool Sakura::File::Exists(const char* filename)
{
	WIN32_FIND_DATA finddata;
	HANDLE handle = FindFirstFile(filename, &finddata);
	return (handle != INVALID_HANDLE_VALUE);
}

inline std::string Sakura::File::GetSakuraDir(const char* basename)
{
	if (strstr(basename, "..")) { return ":*?\\/<>\""; }
	std::string ret = Sakura::CheatDir;
	std::string aaa = ret + /*\\configs\\*/XorStr<0x6C, 10, 0x6FB8FB9C>("\x30\x0E\x01\x01\x16\x18\x15\x00\x28" + 0x6FB8FB9C).s;
	return (aaa + basename);
}

void CVARlist::init()
{
	char str[256];

	Sakura::Cvar::New(/*rage_active*/XorStr<0xF6, 12, 0xD8E05FBB>("\x84\x96\x9F\x9C\xA5\x9A\x9F\x89\x97\x89\x65" + 0xD8E05FBB).s, cvar.rage_active);
	Sakura::Cvar::New(/*rage_wall*/XorStr<0x5A, 10, 0x2048D9AB>("\x28\x3A\x3B\x38\x01\x28\x01\x0D\x0E" + 0x2048D9AB).s, cvar.rage_wall);
	Sakura::Cvar::New(/*rage_fov*/XorStr<0x91, 9, 0xB38E9923>("\xE3\xF3\xF4\xF1\xCA\xF0\xF8\xEE" + 0xB38E9923).s, cvar.rage_fov, 45.0);
	Sakura::Cvar::New(/*rage_target_selection*/XorStr<0x6C, 22, 0x6947E2E4>("\x1E\x0C\x09\x0A\x2F\x05\x13\x01\x13\x10\x02\x28\x0B\x1C\x16\x1E\x1F\x09\x17\x10\xEE" + 0x6947E2E4).s, cvar.rage_target_selection);
	Sakura::Cvar::New(/*rage_perfect_silent*/XorStr<0xEF, 20, 0xE749F77F>("\x9D\x91\x96\x97\xAC\x84\x90\x84\x91\x9D\x9A\x8E\xA4\x8F\x94\x92\x9A\x6E\x75" + 0xE749F77F).s, cvar.rage_perfect_silent);
	Sakura::Cvar::New(/*rage_silent*/XorStr<0x0C, 12, 0x80FF611F>("\x7E\x6C\x69\x6A\x4F\x62\x7B\x7F\x71\x7B\x62" + 0x80FF611F).s, cvar.rage_silent);
	Sakura::Cvar::New(/*rage_knife_attack*/XorStr<0x79, 18, 0xD58F0D9A>("\x0B\x1B\x1C\x19\x22\x15\x11\xE9\xE7\xE7\xDC\xE5\xF1\xF2\xE6\xEB\xE2" + 0xD58F0D9A).s, cvar.rage_knife_attack, 1.0);
	Sakura::Cvar::New(/*rage_shield_attack*/XorStr<0x1B, 19, 0xC880C90E>("\x69\x7D\x7A\x7B\x40\x53\x49\x4B\x46\x48\x41\x79\x46\x5C\x5D\x4B\x48\x47" + 0xC880C90E).s, cvar.rage_shield_attack);
	Sakura::Cvar::New(/*rage_nospread_method*/XorStr<0x7C, 21, 0x749DE584>("\x0E\x1C\x19\x1A\xDF\xEF\xED\xF0\xF4\xF7\xE3\xE6\xEC\xD6\xE7\xEE\xF8\xE5\xE1\xEB" + 0x749DE584).s, cvar.rage_nospread_method);
	Sakura::Cvar::New(/*rage_auto_fire*/XorStr<0x6B, 15, 0x4D15290F>("\x19\x0D\x0A\x0B\x30\x11\x04\x06\x1C\x2B\x13\x1F\x05\x1D" + 0x4D15290F).s, cvar.rage_auto_fire);
	Sakura::Cvar::New(/*rage_auto_fire_key*/XorStr<0x24, 19, 0xFCAAFEBD>("\x56\x44\x41\x42\x77\x48\x5F\x5F\x43\x72\x48\x46\x42\x54\x6D\x58\x51\x4C" + 0xFCAAFEBD).s, cvar.rage_auto_fire_key, -1.0);
	Sakura::Cvar::New(/*rage_team*/XorStr<0x86, 10, 0x62FB25EE>("\xF4\xE6\xEF\xEC\xD5\xFF\xE9\xEC\xE3" + 0x62FB25EE).s, cvar.rage_team);
	Sakura::Cvar::New(/*rage_always_fire*/XorStr<0x67, 17, 0x9FDB52D7>("\x15\x09\x0E\x0F\x34\x0D\x01\x19\x0E\x09\x02\x2D\x15\x1D\x07\x13" + 0x9FDB52D7).s, cvar.rage_always_fire);
	Sakura::Cvar::New(/*rage_draw_aim*/XorStr<0x25, 14, 0xB25C2945>("\x57\x47\x40\x4D\x76\x4E\x59\x4D\x5A\x71\x4E\x59\x5C" + 0xB25C2945).s, cvar.rage_draw_aim, 1.0);
	Sakura::Cvar::New(/*rage_no_spread*/XorStr<0xFF, 15, 0x555F94DF>("\x8D\x61\x66\x67\x5C\x6A\x6A\x59\x74\x78\x7B\x6F\x6A\x68" + 0x555F94DF).s, cvar.rage_no_spread);
	Sakura::Cvar::New(/*rage_no_spread_visual*/XorStr<0x9E, 22, 0x0975DA86>("\xEC\xFE\xC7\xC4\xFD\xCD\xCB\xFA\xD5\xD7\xDA\xCC\xCB\xCF\xF3\xDB\xC7\xDC\xC5\xD0\xDE" + 0x0975DA86).s, cvar.rage_no_spread_visual);
	Sakura::Cvar::New(/*rage_no_spread_visual_strength*/XorStr<0x24, 31, 0x471F05E3>("\x56\x44\x41\x42\x77\x47\x45\x74\x5F\x5D\x5C\x4A\x51\x55\x6D\x45\x5D\x46\x43\x56\x54\x66\x49\x4F\x4E\x58\x50\x58\x34\x29" + 0x471F05E3).s, cvar.rage_no_spread_visual_strength, 1.0);
	Sakura::Cvar::New(/*rage_no_recoil*/XorStr<0x20, 15, 0x9F1770B9>("\x52\x40\x45\x46\x7B\x4B\x49\x78\x5A\x4C\x49\x44\x45\x41" + 0x9F1770B9).s, cvar.rage_no_recoil);
	Sakura::Cvar::New(/*rage_tapping_mode*/XorStr<0x81, 18, 0x720770F4>("\xF3\xE3\xE4\xE1\xDA\xF2\xE6\xF8\xF9\xE3\xE5\xEB\xD2\xE3\xE0\xF4\xF4" + 0x720770F4).s, cvar.rage_tapping_mode);
	Sakura::Cvar::New(/*rage_antiaim_active*/XorStr<0x3D, 20, 0xC3B43A24>("\x4F\x5F\x58\x25\x1E\x23\x2D\x30\x2C\x27\x2E\x25\x16\x2B\x28\x38\x24\x38\x2A" + 0xC3B43A24).s, cvar.rage_antiaim_active);
	Sakura::Cvar::New(/*aim_id_mode*/XorStr<0x09, 12, 0xE1C07727>("\x68\x63\x66\x53\x64\x6A\x50\x7D\x7E\x76\x76" + 0xE1C07727).s, cvar.aim_id_mode, 1.0);

	for (size_t i = 1; i <= 30; ++i)
	{
		if (i == WEAPON_GLOCK || i == WEAPON_HEGRENADE || i == WEAPON_C4 || i == WEAPON_SMOKEGRENADE || i == WEAPON_FLASHBANG) continue;

		if (i == WEAPON_KNIFE)
		{
			sprintf(str, /*rage[%d].rage_hitbox*/XorStr<0x68, 21, 0x98367AA6>("\x1A\x08\x0D\x0E\x37\x48\x0A\x32\x5E\x03\x13\x14\x11\x2A\x1E\x1E\x0C\x1B\x15\x03" + 0x98367AA6).s, i);
			Sakura::Cvar::New(str, cvar.rage[i].rage_hitbox, 11.0);
			continue;
		}

		sprintf(str, /*legit[%d].active*/XorStr<0x40, 17, 0x62CF7119>("\x2C\x24\x25\x2A\x30\x1E\x63\x23\x15\x67\x2B\x28\x38\x24\x38\x2A" + 0x62CF7119).s, i);
		Sakura::Cvar::New(str, cvar.legit[i].active);
		sprintf(str, /*legit[%d].speed*/XorStr<0x40, 16, 0xB54E205B>("\x2C\x24\x25\x2A\x30\x1E\x63\x23\x15\x67\x39\x3B\x29\x28\x2A" + 0xB54E205B).s, i);
		Sakura::Cvar::New(str, cvar.legit[i].speed);
		sprintf(str, /*legit[%d].speed_scale_fov*/XorStr<0x70, 26, 0x0838DF34>("\x1C\x14\x15\x1A\x00\x2E\x53\x13\x25\x57\x09\x0B\x19\x18\x1A\x20\xF3\xE2\xE3\xEF\xE1\xDA\xE0\xE8\xFE" + 0x0838DF34).s, i);
		Sakura::Cvar::New(str, cvar.legit[i].speed_scale_fov);
		sprintf(str, /*legit[%d].reaction_time*/XorStr<0x97, 24, 0x5756B52B>("\xFB\xFD\xFE\xF3\xEF\xC7\xB8\xFA\xC2\x8E\xD3\xC7\xC2\xC7\xD1\xCF\xC8\xC6\xF6\xDE\xC2\xC1\xC8" + 0x5756B52B).s, i);
		Sakura::Cvar::New(str, cvar.legit[i].reaction_time);
		sprintf(str, /*legit[%d].humanize*/XorStr<0x43, 19, 0xB07020B8>("\x2F\x21\x22\x2F\x33\x13\x6C\x2E\x16\x62\x25\x3B\x22\x31\x3F\x3B\x29\x31" + 0xB07020B8).s, i);
		Sakura::Cvar::New(str, cvar.legit[i].humanize);
		sprintf(str, /*legit[%d].recoil_compensation_pitch*/XorStr<0x44, 36, 0x6602EBC5>("\x28\x20\x21\x2E\x3C\x12\x6F\x2F\x11\x63\x3C\x2A\x33\x3E\x3B\x3F\x0B\x36\x39\x3A\x28\x3C\x34\x28\x3D\x29\x37\x30\x0E\x3E\x12\x0A\x10\x06\x0E" + 0x6602EBC5).s, i);
		Sakura::Cvar::New(str, cvar.legit[i].recoil_compensation_pitch);
		sprintf(str, /*legit[%d].recoil_compensation_yaw*/XorStr<0x53, 34, 0xA07B2823>("\x3F\x31\x32\x3F\x23\x03\x7C\x3E\x06\x72\x2F\x3B\x3C\x0F\x08\x0E\x3C\x07\x0A\x0B\x17\x0D\x07\x19\x0A\x18\x04\x01\x01\x2F\x08\x13\x04" + 0xA07B2823).s, i);
		Sakura::Cvar::New(str, cvar.legit[i].recoil_compensation_yaw);
		sprintf(str, /*legit[%d].recoil_compensation_after_shots_fired*/XorStr<0xA6, 48, 0x90107666>("\xCA\xC2\xCF\xC0\xDE\xF0\x89\xC9\xF3\x81\xC2\xD4\xD1\xDC\xDD\xD9\xE9\xD4\xD7\xD4\xCA\xDE\xD2\xCE\xDF\xCB\xA9\xAE\xAC\x9C\xA5\xA3\xB2\xA2\xBA\x96\xB9\xA3\xA3\xB9\xBD\x90\xB6\xB8\xA0\xB6\xB0" + 0x90107666).s, i);
		Sakura::Cvar::New(str, cvar.legit[i].recoil_compensation_after_shots_fired);
		sprintf(str, /*legit[%d].recoil_compensation_fov*/XorStr<0x60, 34, 0x45F4C6B8>("\x0C\x04\x05\x0A\x10\x3E\x43\x03\x35\x47\x18\x0E\x0F\x02\x07\x03\x2F\x12\x1D\x1E\x04\x10\x18\x04\x19\x0D\x13\x14\x12\x22\x18\x10\xF6" + 0x45F4C6B8).s, i);
		Sakura::Cvar::New(str, cvar.legit[i].recoil_compensation_fov);
		sprintf(str, /*legit[%d].recoil_compensation_smooth*/XorStr<0x6D, 37, 0x206278D6>("\x01\x0B\x08\x19\x05\x29\x56\x10\x28\x58\x05\x1D\x1A\x15\x12\x10\x22\x1D\x10\xED\xF1\xE7\xED\xF7\xE4\xF2\xEE\xE7\xE7\xD5\xF8\xE1\xE2\xE1\xFB\xF8" + 0x206278D6).s, i);
		Sakura::Cvar::New(str, cvar.legit[i].recoil_compensation_smooth);
		sprintf(str, /*legit[%d].block_attack_after_kill*/XorStr<0x50,34,0xA11B8042>("\x3C\x34\x35\x3A\x20\x0E\x73\x33\x05\x77\x38\x37\x33\x3E\x35\x00\x01\x15\x16\x02\x07\x0E\x39\x06\x0E\x1D\x0F\x19\x33\x06\x07\x03\x1C" + 0xA11B8042).s, i);
		Sakura::Cvar::New(str, cvar.legit[i].block_attack_after_kill);
		sprintf(str, /*legit[%d].accuracy*/XorStr<0xA7, 19, 0x9B9F0BDA>("\xCB\xCD\xCE\xC3\xDF\xF7\x88\xCA\xF2\x9E\xD0\xD1\xD0\xC1\xC7\xD7\xD4\xC1" + 0x9B9F0BDA).s, i);
		Sakura::Cvar::New(str, cvar.legit[i].accuracy);
		sprintf(str, /*legit[%d].hitbox*/XorStr<0x95, 17, 0x1ADD1602>("\xF9\xF3\xF0\xF1\xED\xC1\xBE\xF8\xC0\xB0\xF7\xC9\xD5\xC0\xCC\xDC" + 0x1ADD1602).s, i);
		Sakura::Cvar::New(str, cvar.legit[i].hitbox, 11.0);
		sprintf(str, /*legit[%d].perfect_silent_fov*/XorStr<0x8C, 29, 0x37B5418B>("\xE0\xE8\xE9\xE6\xE4\xCA\xB7\xF7\xC9\xBB\xE6\xF2\xEA\xFF\xFF\xF8\xE8\xC2\xED\xF6\xCC\xC4\xCC\xD7\xFB\xC3\xC9\xD1" + 0x37B5418B).s, i);
		Sakura::Cvar::New(str, cvar.legit[i].perfect_silent_fov);
		sprintf(str, /*legit[%d].perfect_silent_enable*/XorStr<0xE5,32,0x1B6858BB>("\x89\x83\x80\x81\x9D\xB1\xCE\x88\xB0\xC0\x9F\x95\x83\x94\x96\x97\x81\xA9\x84\x91\x95\x9F\x95\x88\xA2\x9B\x91\x61\x63\x6E\x66" + 0x1B6858BB).s, i);
		Sakura::Cvar::New(str, cvar.legit[i].perfect_silent_enable);
		sprintf(str, /*legit[%d].perfect_silent_spread*/XorStr<0x6C, 32, 0x7B93B755>("\x00\x08\x09\x06\x04\x2A\x57\x17\x29\x5B\x06\x12\x0A\x1F\x1F\x18\x08\x22\x0D\x16\xEC\xE4\xEC\xF7\xDB\xF6\xF6\xF5\xED\xE8\xEE" + 0x7B93B755).s, i);
		Sakura::Cvar::New(str, cvar.legit[i].perfect_silent_spread);
		sprintf(str, /*legit[%d].fov*/XorStr<0xBF, 14, 0x53F98C75>("\xD3\xA5\xA6\xAB\xB7\x9F\xE0\xA2\x9A\xE6\xAF\xA5\xBD" + 0x53F98C75).s, i);
		Sakura::Cvar::New(str, cvar.legit[i].fov, 5.0);
		sprintf(str, /*legit[%d].speed_in_attack*/XorStr<0x46, 26, 0xE75E1C51>("\x2A\x22\x2F\x20\x3E\x10\x69\x29\x13\x61\x23\x21\x37\x36\x30\x0A\x3F\x39\x07\x38\x2E\x2F\x3D\x3E\x35" + 0xE75E1C51).s, i);
		Sakura::Cvar::New(str, cvar.legit[i].speed_in_attack, 100.0);
		sprintf(str, /*legit[%d].trigger_active*/XorStr<0x64, 25, 0x1A01CB77>("\x08\x00\x01\x0E\x1C\x32\x4F\x0F\x31\x43\x1A\x1D\x19\x16\x15\x16\x06\x2A\x17\x14\x0C\x10\x0C\x1E" + 0x1A01CB77).s, i);
		Sakura::Cvar::New(str, cvar.legit[i].trigger_active);
		sprintf(str, /*legit[%d].trigger_wall*/XorStr<0x1C, 23, 0x5F439C7D>("\x70\x78\x79\x76\x54\x7A\x07\x47\x79\x0B\x52\x55\x41\x4E\x4D\x4E\x5E\x72\x59\x4E\x5C\x5D" + 0x5F439C7D).s, i);
		Sakura::Cvar::New(str, cvar.legit[i].trigger_wall);
		sprintf(str, /*legit[%d].trigger_accuracy*/XorStr<0xEC, 27, 0x5E67A5A8>("\x80\x88\x89\x86\x84\xAA\xD7\x97\xA9\xDB\x82\x85\x91\x9E\x9D\x9E\x8E\xA2\x9F\x9C\x63\x74\x70\x62\x67\x7C" + 0x5E67A5A8).s, i);
		Sakura::Cvar::New(str, cvar.legit[i].trigger_accuracy);
		sprintf(str, /*legit[%d].trigger_delay_shot*/XorStr<0x38, 29, 0x7563F0FA>("\x54\x5C\x5D\x52\x48\x66\x1B\x5B\x1D\x6F\x36\x31\x2D\x22\x21\x22\x3A\x16\x2E\x2E\x20\x2C\x37\x10\x23\x39\x3D\x27" + 0x7563F0FA).s, i);
		Sakura::Cvar::New(str, cvar.legit[i].trigger_delay_shot);
		sprintf(str, /*legit[%d].trigger_shot_count*/XorStr<0xA7,29,0x3616A9E8>("\xCB\xCD\xCE\xC3\xDF\xF7\x88\xCA\xF2\x9E\xC5\xC0\xDA\xD3\xD2\xD3\xC5\xE7\xCA\xD2\xD4\xC8\xE2\xDD\xD0\xB5\xAF\xB6" + 0x3616A9E8).s, i);
		Sakura::Cvar::New(str, cvar.legit[i].trigger_shot_count, 1.0);
		sprintf(str, /*legit[%d].trigger_shot_type*/XorStr<0x2C,28,0x1D15F97B>("\x40\x48\x49\x46\x44\x6A\x17\x57\x69\x1B\x42\x45\x51\x5E\x5D\x5E\x4E\x62\x4D\x57\x2F\x35\x1D\x37\x3D\x35\x23" + 0x1D15F97B).s, i);
		Sakura::Cvar::New(str, cvar.legit[i].trigger_shot_type);
		sprintf(str, /*legit[%d].trigger_random_max*/XorStr<0xBC, 29, 0x35FA4185>("\xD0\xD8\xD9\xD6\xB4\x9A\xE7\xA7\x99\xEB\xB2\xB5\xA1\xAE\xAD\xAE\xBE\x92\xBC\xAE\xBE\xB5\xBD\xBE\x8B\xB8\xB7\xAF" + 0x35FA4185).s, i);
		Sakura::Cvar::New(str, cvar.legit[i].trigger_random_max, 3.0);
		sprintf(str, /*legit[%d].trigger_hitbox*/XorStr<0x0B, 25, 0x24913136>("\x67\x69\x6A\x67\x7B\x4B\x34\x76\x4E\x3A\x61\x64\x7E\x7F\x7E\x7F\x69\x43\x75\x77\x6B\x42\x4E\x5A" + 0x24913136).s, i);
		Sakura::Cvar::New(str, cvar.legit[i].trigger_hitbox, 11.0);

		sprintf(str, /*rage[%d].rage_delay_shot*/XorStr<0x00, 25, 0x851B77BB>("\x72\x60\x65\x66\x5F\x20\x62\x5A\x26\x7B\x6B\x6C\x69\x52\x6A\x6A\x7C\x70\x6B\x4C\x67\x7D\x79\x63" + 0x851B77BB).s, i);
		Sakura::Cvar::New(str, cvar.rage[i].rage_delay_shot);
		sprintf(str, /*rage[%d].rage_shot_count*/XorStr<0xE1, 25, 0x5B6A98C5>("\x93\x83\x84\x81\xBE\xC3\x83\xB5\xC7\x98\x8A\x8B\x88\xB1\x9C\x98\x9E\x86\xAC\x97\x9A\x83\x99\x8C" + 0x5B6A98C5).s, i);
		Sakura::Cvar::New(str, cvar.rage[i].rage_shot_count, 1.0);
		sprintf(str, /*rage[%d].rage_shot_type*/XorStr<0x84, 24, 0x483CD08B>("\xF6\xE4\xE1\xE2\xD3\xAC\xEE\xD6\xA2\xFF\xEF\xE8\xF5\xCE\xE1\xFB\xFB\xE1\xC9\xE3\xE1\xE9\xFF" + 0x483CD08B).s, i);
		Sakura::Cvar::New(str, cvar.rage[i].rage_shot_type);
		sprintf(str, /*rage[%d].rage_random_max*/XorStr<0x08, 25, 0x2EBF0176>("\x7A\x68\x6D\x6E\x57\x28\x6A\x52\x3E\x63\x73\x74\x71\x4A\x64\x76\x76\x7D\x75\x76\x43\x70\x7F\x67" + 0x2EBF0176).s, i);
		Sakura::Cvar::New(str, cvar.rage[i].rage_random_max, 3.0);
		sprintf(str, /*rage[%d].rage_hitbox*/XorStr<0x2A, 21, 0x802812D0>("\x58\x4A\x4B\x48\x75\x0A\x54\x6C\x1C\x41\x55\x52\x53\x68\x50\x50\x4E\x59\x53\x45" + 0x802812D0).s, i);
		Sakura::Cvar::New(str, cvar.rage[i].rage_hitbox, 11.0);
	}

	Sakura::Cvar::New(/*legit_trigger_only_zoom*/XorStr<0xBC,24,0x9BA0A594>("\xD0\xD8\xD9\xD6\xB4\x9E\xB6\xB1\xAD\xA2\xA1\xA2\xBA\x96\xA5\xA5\xA0\xB4\x91\xB5\xBF\xBE\xBF" + 0x9BA0A594).s, cvar.legit_trigger_only_zoom);
	Sakura::Cvar::New(/*legit_trigger_team*/XorStr<0x2A, 19, 0x27C4E8E1>("\x46\x4E\x4B\x44\x5A\x70\x44\x43\x5B\x54\x53\x50\x44\x68\x4C\x5C\x5B\x56" + 0x27C4E8E1).s, cvar.legit_trigger_team);
	Sakura::Cvar::New(/*legit_trigger_key*/XorStr<0x8C, 18, 0x94E227D3>("\xE0\xE8\xE9\xE6\xE4\xCE\xE6\xE1\xFD\xF2\xF1\xF2\xEA\xC6\xF1\xFE\xE5" + 0x94E227D3).s, cvar.legit_trigger_key, -1.0);
	Sakura::Cvar::New(/*legit_trigger_draw_aim*/XorStr<0xDB, 23, 0x2469A2A5>("\xB7\xB9\xBA\xB7\xAB\xBF\x95\x90\x8A\x83\x82\x83\x95\xB7\x8D\x98\x8A\x9B\xB2\x8F\x86\x9D" + 0x2469A2A5).s, cvar.legit_trigger_draw_aim, 1.0);
	Sakura::Cvar::New(/*legit_fastzoom*/XorStr<0xAC, 15, 0xCFC3448D>("\xC0\xC8\xC9\xC6\xC4\xEE\xD4\xD2\xC7\xC1\xCC\xD8\xD7\xD4" + 0xCFC3448D).s, cvar.legit_fastzoom);
	Sakura::Cvar::New(/*legit_team*/XorStr<0x28, 11, 0x39F07C81>("\x44\x4C\x4D\x42\x58\x72\x5A\x4A\x51\x5C" + 0x39F07C81).s, cvar.legit_team);
	Sakura::Cvar::New(/*legit_key*/XorStr<0xF9, 10, 0xBF4F9A99>("\x95\x9F\x9C\x95\x89\xA1\x94\x65\x78" + 0xBF4F9A99).s, cvar.legit_key, -1.0);
	Sakura::Cvar::New(/*legit_draw_aim*/XorStr<0xCC, 15, 0x097ADCCB>("\xA0\xA8\xA9\xA6\xA4\x8E\xB6\xA1\xB5\xA2\x89\xB6\xB1\xB4" + 0x097ADCCB).s, cvar.legit_draw_aim, 1.0);
	Sakura::Cvar::New(/*legit_flashcheck*/XorStr<0x6D, 17, 0xE658430F>("\x01\x0B\x08\x19\x05\x2D\x15\x18\x14\x05\x1F\x1B\x11\x1F\x18\x17" + 0xE658430F).s, cvar.legit_flashcheck);
	Sakura::Cvar::New(/*legit_flashcheck_percentage*/XorStr<0x2E, 28, 0xFE81BE6D>("\x42\x4A\x57\x58\x46\x6C\x52\x59\x57\x44\x50\x5A\x52\x5E\x5F\x56\x61\x4F\x25\x33\x21\x26\x2A\x31\x27\x20\x2D" + 0xFE81BE6D).s, cvar.legit_flashcheck_percentage, 50.0);
	Sakura::Cvar::New(/*legit_demochecker_bypass*/XorStr<0x78, 25, 0xC4B559E9>("\x14\x1C\x1D\x12\x08\x22\x1A\x1A\xED\xEE\xE1\xEB\xE1\xE6\xED\xE2\xFA\xD6\xE8\xF2\xFC\xEC\xFD\xFC" + 0xC4B559E9).s, cvar.legit_demochecker_bypass);

	Sakura::Cvar::New(/*menu_legit_global_section*/XorStr<0xF4, 26, 0x74D430B3>("\x99\x90\x98\x82\xA7\x95\x9F\x9C\x95\x89\xA1\x98\x6C\x6E\x60\x62\x68\x5A\x75\x62\x6B\x7D\x63\x64\x62" + 0x74D430B3).s, cvar.menu_legit_global_section);
	Sakura::Cvar::New(/*menu_legit_sub_section*/XorStr<0xA5, 23, 0x1DB4ACA9>("\xC8\xC3\xC9\xDD\xF6\xC6\xCE\xCB\xC4\xDA\xF0\xC3\xC4\xD0\xEC\xC7\xD0\xD5\xC3\xD1\xD6\xD4" + 0x1DB4ACA9).s, cvar.menu_legit_sub_section);
	Sakura::Cvar::New(/*menu_rage_global_section*/XorStr<0x40, 25, 0x411AA136>("\x2D\x24\x2C\x36\x1B\x37\x27\x20\x2D\x16\x2D\x27\x23\x2F\x2F\x23\x0F\x22\x37\x30\x20\x3C\x39\x39" + 0x411AA136).s, cvar.menu_rage_global_section);
	Sakura::Cvar::New(/*menu_rage_sub_section*/XorStr<0x94, 22, 0xC8AFA838>("\xF9\xF0\xF8\xE2\xC7\xEB\xFB\xFC\xF9\xC2\xED\xEA\xC2\xFE\xD1\xC6\xC7\xD1\xCF\xC8\xC6" + 0xC8AFA838).s, cvar.menu_rage_sub_section);
	
	Sakura::Cvar::New(/*knifebot_active*/XorStr<0xDA, 16, 0xB605E3F5>("\xB1\xB5\xB5\xBB\xBB\xBD\x8F\x95\xBD\x82\x87\x91\x8F\x91\x8D" + 0xB605E3F5).s, cvar.knifebot_active);
	Sakura::Cvar::New(/*knifebot_attack*/XorStr<0x0A, 16, 0x51979512>("\x61\x65\x65\x6B\x6B\x6D\x7F\x65\x4D\x72\x60\x61\x77\x74\x73" + 0x51979512).s, cvar.knifebot_attack, 1.0);
	Sakura::Cvar::New(/*knifebot_attack_distance*/XorStr<0xDB, 25, 0xAC8C09B0>("\xB0\xB2\xB4\xB8\xBA\x82\x8E\x96\xBC\x85\x91\x92\x86\x8B\x82\xB5\x8F\x85\x9E\x9A\x8E\x9E\x92\x97" + 0xAC8C09B0).s, cvar.knifebot_attack_distance, 72.0);
	Sakura::Cvar::New(/*knifebot_attack2_distance*/XorStr<0xD9, 26, 0x87AC9460>("\xB2\xB4\xB2\xBA\xB8\xBC\xB0\x94\xBE\x83\x97\x90\x84\x85\x8C\xDA\xB6\x8E\x82\x9F\x99\x8F\x81\x93\x94" + 0x87AC9460).s, cvar.knifebot_attack2_distance, 64.0);
	Sakura::Cvar::New(/*knifebot_silent*/XorStr<0xE7, 16, 0x778EBDB0>("\x8C\x86\x80\x8C\x8E\x8E\x82\x9A\xB0\x83\x98\x9E\x96\x9A\x81" + 0x778EBDB0).s, cvar.knifebot_silent);
	Sakura::Cvar::New(/*knifebot_perfect_silent*/XorStr<0x3C, 24, 0x5DB9105E>("\x57\x53\x57\x59\x25\x23\x2D\x37\x1B\x35\x23\x35\x2E\x2C\x29\x3F\x13\x3E\x27\x23\x35\x3F\x26" + 0x5DB9105E).s, cvar.knifebot_perfect_silent);
	Sakura::Cvar::New(/*knifebot_fov*/XorStr<0x55, 13, 0xCB1024AA>("\x3E\x38\x3E\x3E\x3C\x38\x34\x28\x02\x38\x30\x16" + 0xCB1024AA).s, cvar.knifebot_fov, 45.0);
	Sakura::Cvar::New(/*knifebot_team*/XorStr<0x34, 14, 0x1B911F7F>("\x5F\x5B\x5F\x51\x5D\x5B\x55\x4F\x63\x49\x5B\x5E\x2D" + 0x1B911F7F).s, cvar.knifebot_team);
	Sakura::Cvar::New(/*knifebot_draw_aim*/XorStr<0xC9, 18, 0x58C7693B>("\xA2\xA4\xA2\xAA\xA8\xAC\xA0\xA4\x8E\xB6\xA1\xB5\xA2\x89\xB6\xB1\xB4" + 0x58C7693B).s, cvar.knifebot_draw_aim, 1.0);
	Sakura::Cvar::New(/*knifebot_hitbox*/XorStr<0xB6, 16, 0x3AA44F8E>("\xDD\xD9\xD1\xDF\xDF\xD9\xD3\xC9\xE1\xD7\xA9\xB5\xA0\xAC\xBC" + 0x3AA44F8E).s, cvar.knifebot_hitbox, 11.0);
	
	Sakura::Cvar::New(/*bypass_trace_rage*/XorStr<0x32, 18, 0x6E5ED058>("\x50\x4A\x44\x54\x45\x44\x67\x4D\x48\x5A\x5F\x58\x61\x4D\x21\x26\x27" + 0x6E5ED058).s, cvar.bypass_trace_rage, 1.0);
	Sakura::Cvar::New(/*bypass_trace_legit*/XorStr<0xB2, 19, 0x6673A04C>("\xD0\xCA\xC4\xD4\xC5\xC4\xE7\xCD\xC8\xDA\xDF\xD8\xE1\xD3\xA5\xA6\xAB\xB7" + 0x6673A04C).s, cvar.bypass_trace_legit, 1.0);
	Sakura::Cvar::New(/*bypass_trace_trigger*/XorStr<0xAE, 21, 0x596A166D>("\xCC\xD6\xC0\xD0\xC1\xC0\xEB\xC1\xC4\xD6\xDB\xDC\xE5\xCF\xCE\xD4\xD9\xD8\xA5\xB3" + 0x596A166D).s, cvar.bypass_trace_trigger, 1.0);
	Sakura::Cvar::New(/*bypass_trace_knife*/XorStr<0x2A, 19, 0xD90FBBC4>("\x48\x52\x5C\x4C\x5D\x5C\x6F\x45\x40\x52\x57\x50\x69\x5C\x56\x50\x5C\x5E" + 0xD90FBBC4).s, cvar.bypass_trace_knife, 1.0);
	
	Sakura::Cvar::New(/*aa_pitch*/XorStr<0xB5, 9, 0xE72B8459>("\xD4\xD7\xE8\xC8\xD0\xCE\xD8\xD4" + 0xE72B8459).s, cvar.aa_pitch);
	Sakura::Cvar::New(/*aa_edge*/XorStr<0xE9, 8, 0x876A96DC>("\x88\x8B\xB4\x89\x89\x89\x8A" + 0x876A96DC).s, cvar.aa_edge);
	Sakura::Cvar::New(/*aa_yaw*/XorStr<0x67, 7, 0xE3FD7733>("\x06\x09\x36\x13\x0A\x1B" + 0xE3FD7733).s, cvar.aa_yaw);
	Sakura::Cvar::New(/*aa_yaw_static*/XorStr<0xAF, 14, 0x6F06C9AA>("\xCE\xD1\xEE\xCB\xD2\xC3\xEA\xC5\xC3\xD9\xCD\xD3\xD8" + 0x6F06C9AA).s, cvar.aa_yaw_static);
	Sakura::Cvar::New(/*aa_yaw_while_running*/XorStr<0x49, 21, 0xE9592B2E>("\x28\x2B\x14\x35\x2C\x39\x10\x27\x39\x3B\x3F\x31\x0A\x24\x22\x36\x37\x33\x35\x3B" + 0xE9592B2E).s, cvar.aa_yaw_while_running);
	Sakura::Cvar::New(/*aa_yaw_jitter_custom*/XorStr<0xF2, 21, 0xD40B06EA>("\x93\x92\xAB\x8C\x97\x80\xA7\x93\x93\x8F\x88\x98\x8C\xA0\x63\x74\x71\x77\x6B\x68" + 0xD40B06EA).s, cvar.aa_yaw_jitter_custom);
	Sakura::Cvar::New(/*aa_yaw_jitter_angle*/XorStr<0x0A, 20, 0x04EBBC8A>("\x6B\x6A\x53\x74\x6F\x78\x4F\x7B\x7B\x67\x60\x70\x64\x48\x79\x77\x7D\x77\x79" + 0x04EBBC8A).s, cvar.aa_yaw_jitter_angle);
	Sakura::Cvar::New(/*aa_yaw_jitter_much*/XorStr<0x37, 19, 0x0AC91E11>("\x56\x59\x66\x43\x5A\x4B\x62\x54\x56\x34\x35\x27\x31\x1B\x28\x33\x24\x20" + 0x0AC91E11).s, cvar.aa_yaw_jitter_much);
	Sakura::Cvar::New(/*aa_roll*/XorStr<0x64, 8, 0x80C408F6>("\x05\x04\x39\x15\x07\x05\x06" + 0x80C408F6).s, cvar.aa_roll);
	Sakura::Cvar::New(/*aa_roll_active*/XorStr<0xA4, 15, 0x6D16E9D7>("\xC5\xC4\xF9\xD5\xC7\xC5\xC6\xF4\xCD\xCE\xDA\xC6\xC6\xD4" + 0x6D16E9D7).s, cvar.aa_roll_active);
	Sakura::Cvar::New(/*aa_roll_static*/XorStr<0x5D, 15, 0xDCB58F93>("\x3C\x3F\x00\x12\x0E\x0E\x0F\x3B\x16\x12\x06\x1C\x00\x09" + 0xDCB58F93).s, cvar.aa_roll_static);
	Sakura::Cvar::New(/*aa_roll_while_running*/XorStr<0x75, 22, 0x8C363BD1>("\x14\x17\x28\x0A\x16\x16\x17\x23\x0A\x16\x16\xEC\xE4\xDD\xF1\xF1\xEB\xE8\xEE\xE6\xEE" + 0x8C363BD1).s, cvar.aa_roll_while_running);
	
	Sakura::Cvar::New(/*fakelag_active*/XorStr<0xD7, 15, 0x851A5F4F>("\xB1\xB9\xB2\xBF\xB7\xBD\xBA\x81\xBE\x83\x95\x8B\x95\x81" + 0x851A5F4F).s, cvar.fakelag_active);
	Sakura::Cvar::New(/*fakelag_while_shooting*/XorStr<0xD1, 23, 0x4CB1CECE>("\xB7\xB3\xB8\xB1\xB9\xB7\xB0\x87\xAE\xB2\xB2\xB0\xB8\x81\xAC\x88\x8E\x8D\x97\x8D\x8B\x81" + 0x4CB1CECE).s, cvar.fakelag_while_shooting);
	Sakura::Cvar::New(/*fakelag_move*/XorStr<0x94, 13, 0xACFE154D>("\xF2\xF4\xFD\xF2\xF4\xF8\xFD\xC4\xF1\xF2\xE8\xFA" + 0xACFE154D).s, cvar.fakelag_move, 2.0);
	Sakura::Cvar::New(/*fakelag_type*/XorStr<0xB5, 13, 0x61D435FE>("\xD3\xD7\xDC\xDD\xD5\xDB\xDC\xE3\xC9\xC7\xCF\xA5" + 0x61D435FE).s, cvar.fakelag_type, 2.0);
	Sakura::Cvar::New(/*fakelag_limit*/XorStr<0x42, 14, 0x6CA49039>("\x24\x22\x2F\x20\x2A\x26\x2F\x16\x26\x22\x21\x24\x3A" + 0x6CA49039).s, cvar.fakelag_limit);
	Sakura::Cvar::New(/*fakelag_variance*/XorStr<0x3C, 17, 0x391FF779>("\x5A\x5C\x55\x5A\x2C\x20\x25\x1C\x32\x24\x34\x2E\x29\x27\x29\x2E" + 0x391FF779).s, cvar.fakelag_variance);
	
	Sakura::Cvar::New(/*speedhack_active*/XorStr<0xF3, 17, 0x4E182B06>("\x80\x84\x90\x93\x93\x90\x98\x99\x90\xA3\x9C\x9D\x8B\x69\x77\x67" + 0x4E182B06).s, cvar.speedhack_active);
	Sakura::Cvar::New(/*speedhack_speed*/XorStr<0x84, 16, 0x2C289A3B>("\xF7\xF5\xE3\xE2\xEC\xE1\xEB\xE8\xE7\xD2\xFD\xFF\xF5\xF4\xF6" + 0x2C289A3B).s, cvar.speedhack_speed, 64.0);
	
	Sakura::Cvar::New(/*antiss_active*/XorStr<0xF2, 14, 0x11071B71>("\x93\x9D\x80\x9C\x85\x84\xA7\x98\x99\x8F\x95\x8B\x9B" + 0x11071B71).s, cvar.antiss_active);
	Sakura::Cvar::New(/*antiss_minmodels*/XorStr<0x33, 17, 0x56D6B7A2>("\x52\x5A\x41\x5F\x44\x4B\x66\x57\x52\x52\x50\x51\x5B\x25\x2D\x31" + 0x56D6B7A2).s, cvar.antiss_minmodels);
	
	Sakura::Cvar::New(/*misc_wav_speed*/XorStr<0x85, 15, 0x3251B5FF>("\xE8\xEF\xF4\xEB\xD6\xFD\xEA\xFA\xD2\xFD\xFF\xF5\xF4\xF6" + 0x3251B5FF).s, cvar.misc_wav_speed, 1.0);
	Sakura::Cvar::New(/*misc_thirdperson_key*/XorStr<0xA7, 21, 0xE03DCD4E>("\xCA\xC1\xDA\xC9\xF4\xD8\xC5\xC7\xDD\xD4\xC1\xD7\xC1\xC7\xDA\xD8\xE8\xD3\xDC\xC3" + 0xE03DCD4E).s, cvar.misc_thirdperson_key, -1.0);
	Sakura::Cvar::New(/*misc_namestealer*/XorStr<0x19, 17, 0x45FD3D96>("\x74\x73\x68\x7F\x42\x70\x7E\x4D\x44\x51\x57\x41\x44\x4A\x42\x5A" + 0x45FD3D96).s, cvar.misc_namestealer);
	Sakura::Cvar::New(/*misc_namestealer_time*/XorStr<0x32, 22, 0xC020FFB7>("\x5F\x5A\x47\x56\x69\x59\x59\x54\x5F\x48\x48\x58\x5F\x53\x25\x33\x1D\x37\x2D\x28\x23" + 0xC020FFB7).s, cvar.misc_namestealer_time, 5.0);
	Sakura::Cvar::New(/*misc_namestealer_playerlist*/XorStr<0xAB, 28, 0xDA3D80E4>("\xC6\xC5\xDE\xCD\xF0\xDE\xD0\xDF\xD6\xC7\xC1\xD3\xD6\xD4\xDC\xC8\xE4\xCC\xD1\xDF\xC6\xA5\xB3\xAE\xAA\xB7\xB1" + 0xDA3D80E4).s, cvar.misc_namestealer_playerlist);
	Sakura::Cvar::New(/*misc_namestealer_specs*/XorStr<0x15, 23, 0x5B206F1D>("\x78\x7F\x64\x7B\x46\x74\x7A\x71\x78\x6D\x6B\x45\x40\x4E\x46\x56\x7A\x55\x57\x4D\x4A\x59" + 0x5B206F1D).s, cvar.misc_namestealer_specs);
	Sakura::Cvar::New(/*misc_chatspammer*/XorStr<0xB8, 17, 0x147FBCA2>("\xD5\xD0\xC9\xD8\xE3\xDE\xD6\xDE\xB4\xB2\xB2\xA2\xA9\xA8\xA3\xB5" + 0x147FBCA2).s, cvar.misc_chatspammer);
	Sakura::Cvar::New(/*misc_chatspammer_time*/XorStr<0xA3, 22, 0x183C8885>("\xCE\xCD\xD6\xC5\xF8\xCB\xC1\xCB\xDF\xDF\xDD\xCF\xC2\xDD\xD4\xC0\xEC\xC0\xDC\xDB\xD2" + 0x183C8885).s, cvar.misc_chatspammer_time, 5.0);
	Sakura::Cvar::New(/*misc_fire_sounds*/XorStr<0x44, 17, 0x00DC4F89>("\x29\x2C\x35\x24\x17\x2F\x23\x39\x29\x12\x3D\x20\x25\x3F\x36\x20" + 0x00DC4F89).s, cvar.misc_fire_sounds);
	Sakura::Cvar::New(/*misc_fire_sounds_volume*/XorStr<0x90, 24, 0x95953811>("\xFD\xF8\xE1\xF0\xCB\xF3\xFF\xE5\xFD\xC6\xE9\xF4\xE9\xF3\xFA\xEC\xFF\xD7\xCD\xCF\xD1\xC8\xC3" + 0x95953811).s, cvar.misc_fire_sounds_volume, 0.2);
	Sakura::Cvar::New(/*misc_fire_sounds_pitch*/XorStr<0xD2, 23, 0xBB8E9A27>("\xBF\xBA\xA7\xB6\x89\xB1\xB1\xAB\xBF\x84\xAF\xB2\xAB\xB1\x84\x92\xBD\x93\x8D\x91\x85\x8F" + 0xBB8E9A27).s, cvar.misc_fire_sounds_pitch, 100.0);
	Sakura::Cvar::New(/*misc_block_motd*/XorStr<0x0A, 16, 0xE684DA41>("\x67\x62\x7F\x6E\x51\x6D\x7C\x7E\x71\x78\x4B\x78\x79\x63\x7C" + 0xE684DA41).s, cvar.misc_block_motd);
	Sakura::Cvar::New(/*misc_skipframes*/XorStr<0x3B, 16, 0x46C9D230>("\x56\x55\x4E\x5D\x60\x33\x2A\x2B\x33\x22\x37\x27\x2A\x2D\x3A" + 0x46C9D230).s, cvar.misc_skipframes);
	Sakura::Cvar::New(/*misc_skipframes_count*/XorStr<0x95, 22, 0x36216F8D>("\xF8\xFF\xE4\xFB\xC6\xE9\xF0\xF5\xED\xF8\xED\xC1\xCC\xC7\xD0\xFB\xC6\xC9\xD2\xC6\xDD" + 0x36216F8D).s, cvar.misc_skipframes_count);
	Sakura::Cvar::New(/*misc_fakelatency*/XorStr<0x49, 17, 0x1EC55549>("\x24\x23\x38\x2F\x12\x28\x2E\x3B\x34\x3E\x32\x20\x30\x38\x34\x21" + 0x1EC55549).s, cvar.misc_fakelatency);
	Sakura::Cvar::New(/*misc_fakelatency_amount*/XorStr<0xFC, 24, 0x35A131FE>("\x91\x94\x8D\x9C\x5F\x67\x63\x68\x61\x69\x67\x73\x6D\x67\x69\x72\x53\x6C\x63\x60\x65\x7F\x66" + 0x35A131FE).s, cvar.misc_fakelatency_amount, 50.0);
	Sakura::Cvar::New(/*misc_backtrack_chams*/XorStr<0x27, 21, 0x5C80CA2B>("\x4A\x41\x5A\x49\x74\x4E\x4C\x4D\x44\x44\x43\x53\x50\x5F\x6A\x55\x5F\x59\x54\x49" + 0x5C80CA2B).s, cvar.misc_backtrack_chams);
	Sakura::Cvar::New(/*misc_backtrack_wireframe*/XorStr<0x51, 25, 0xD5919F84>("\x3C\x3B\x20\x37\x0A\x34\x36\x3B\x32\x2E\x29\x3D\x3E\x35\x00\x17\x08\x10\x06\x02\x17\x07\x0A\x0D" + 0xD5919F84).s, cvar.misc_backtrack_wireframe);
	Sakura::Cvar::New(/*misc_backtrack_wireframe_mode*/XorStr<0x72, 30, 0x7A0CBFB8>("\x1F\x1A\x07\x16\x29\x15\x19\x1A\x11\x0F\x0E\x1C\x1D\x14\xDF\xF6\xEB\xF1\xE1\xE3\xF4\xE6\xE5\xEC\xD5\xE6\xE3\xE9\xEB" + 0x7A0CBFB8).s, cvar.misc_backtrack_wireframe_mode);
	Sakura::Cvar::New(/*misc_backtrack_chams_color[0]*/XorStr<0x71, 30, 0x004BC030>("\x1C\x1B\x00\x17\x2A\x14\x16\x1B\x12\x0E\x09\x1D\x1E\x15\x20\xE3\xE9\xE3\xEE\xF7\xDA\xE5\xE8\xE4\xE6\xF8\xD0\xBC\xD0" + 0x004BC030).s, cvar.misc_backtrack_chams_color[0], 1.0);
	Sakura::Cvar::New(/*misc_backtrack_chams_color[1]*/XorStr<0x59, 30, 0xA471586E>("\x34\x33\x28\x3F\x02\x3C\x3E\x03\x0A\x16\x11\x05\x06\x0D\x38\x0B\x01\x0B\x06\x1F\x32\x0D\x00\x1C\x1E\x00\x28\x45\x28" + 0xA471586E).s, cvar.misc_backtrack_chams_color[1], 1.0);
	Sakura::Cvar::New(/*misc_backtrack_chams_color[2]*/XorStr<0x4E, 30, 0x17682E0D>("\x23\x26\x23\x32\x0D\x31\x35\x36\x3D\x23\x2A\x38\x39\x30\x03\x3E\x36\x3E\x0D\x12\x3D\x00\x0B\x09\x09\x15\x33\x5B\x37" + 0x17682E0D).s, cvar.misc_backtrack_chams_color[2], 1.0);
	Sakura::Cvar::New(/*misc_backtrack_chams_color[3]*/XorStr<0x26, 30, 0x05826586>("\x4B\x4E\x5B\x4A\x75\x49\x4D\x4E\x45\x5B\x42\x50\x51\x58\x6B\x56\x5E\x56\x55\x4A\x65\x58\x53\x51\x51\x4D\x1B\x72\x1F" + 0x05826586).s, cvar.misc_backtrack_chams_color[3], 1.0);
	Sakura::Cvar::New(/*misc_backtrack_light*/XorStr<0x0E, 21, 0x473B3DA8>("\x63\x66\x63\x72\x4D\x71\x75\x76\x7D\x63\x6A\x78\x79\x70\x43\x71\x77\x78\x48\x55" + 0x473B3DA8).s, cvar.misc_backtrack_light);
	Sakura::Cvar::New(/*misc_backtrack_light_color[0]*/XorStr<0x38, 30, 0x29F74B6C>("\x55\x50\x49\x58\x63\x5F\x5F\x5C\x2B\x35\x30\x22\x27\x2E\x19\x2B\x21\x2E\x22\x3F\x13\x2E\x21\x23\x3F\x23\x09\x63\x09" + 0x29F74B6C).s, cvar.misc_backtrack_light_color[0], 1.0);
	Sakura::Cvar::New(/*misc_backtrack_light_color[1]*/XorStr<0x65, 30, 0x699F2823>("\x08\x0F\x14\x0B\x36\x08\x0A\x0F\x06\x1A\x1D\x11\x12\x19\x2C\x18\x1C\x11\x1F\x0C\x26\x19\x14\x10\x12\x0C\x24\xB1\xDC" + 0x699F2823).s, cvar.misc_backtrack_light_color[1], 1.0);
	Sakura::Cvar::New(/*misc_backtrack_light_color[2]*/XorStr<0x1B, 30, 0x66B2408B>("\x76\x75\x6E\x7D\x40\x42\x40\x41\x48\x50\x57\x47\x44\x43\x76\x46\x42\x4B\x45\x5A\x70\x53\x5E\x5E\x5C\x46\x6E\x04\x6A" + 0x66B2408B).s, cvar.misc_backtrack_light_color[2], 1.0);
	Sakura::Cvar::New(/*misc_backtrack_light_color[3]*/XorStr<0x66, 30, 0x34421600>("\x0B\x0E\x1B\x0A\x35\x09\x0D\x0E\x05\x1B\x02\x10\x11\x18\x2B\x19\x1F\x10\x10\x0D\x25\x18\x13\x11\x11\x0D\xDB\xB2\xDF" + 0x34421600).s, cvar.misc_backtrack_light_color[3], 1.0);
	Sakura::Cvar::New(/*misc_fastswitch*/XorStr<0x45, 16, 0x72D77738>("\x28\x2F\x34\x2B\x16\x2C\x2A\x3F\x39\x3D\x38\x39\x25\x31\x3B" + 0x72D77738).s, cvar.misc_fastswitch);
	//Sakura::Cvar::New(/*misc_fastswitch_delay*/XorStr<0xE7, 22, 0xCC31DDBD>("\x8A\x81\x9A\x89\xB4\x8A\x8C\x9D\x9B\x83\x86\x9B\x87\x97\x9D\xA9\x93\x9D\x95\x9B\x82" + 0xCC31DDBD).s, cvar.misc_fastswitch_delay, 100.0);
	
	Sakura::Cvar::New(/*misc_auto_config_save*/XorStr<0x1F, 22, 0xBC724E62>("\x72\x49\x52\x41\x7C\x45\x50\x52\x48\x77\x4A\x45\x45\x4A\x44\x49\x70\x43\x50\x44\x56" + 0xBC724E62).s, cvar.misc_auto_config_save, 1.0);
	
	Sakura::Cvar::New(/*notifications_enable*/XorStr<0x14, 21, 0x962491BD>("\x7A\x7A\x62\x7E\x7E\x70\x79\x7A\x68\x74\x71\x71\x53\x7E\x47\x4D\x45\x47\x4A\x42" + 0x962491BD).s, cvar.notifications_enable, 1.0);
	Sakura::Cvar::New(/*notifications_text_only*/XorStr<0x93, 24, 0xDD45D0D9>("\xFD\xFB\xE1\xFF\xF1\xF1\xFA\xFB\xEF\xF5\xF2\xF0\xEC\xFF\xD5\xC7\xDB\xD0\xFA\xC9\xC9\xC4\xD0" + 0xDD45D0D9).s, cvar.notifications_text_only);
	Sakura::Cvar::New(/*notifications_fade*/XorStr<0x1C, 19, 0x0EE9D803>("\x72\x72\x6A\x76\x46\x48\x41\x42\x50\x4C\x49\x49\x5B\x76\x4C\x4A\x48\x48" + 0x0EE9D803).s, cvar.notifications_fade, 200.0);
	Sakura::Cvar::New(/*notifications_x*/XorStr<0x4F, 16, 0xEE3C9C33>("\x21\x3F\x25\x3B\x35\x3D\x36\x37\x23\x31\x36\x34\x28\x03\x25" + 0xEE3C9C33).s, cvar.notifications_x, 5.0);
	Sakura::Cvar::New(/*notifications_y*/XorStr<0xA1, 16, 0x2A1BE229>("\xCF\xCD\xD7\xCD\xC3\xCF\xC4\xC9\xDD\xC3\xC4\xC2\xDE\xF1\xD6" + 0x2A1BE229).s, cvar.notifications_y, 5.0);
	Sakura::Cvar::New(/*notifications_text_color[0]*/XorStr<0xC5, 28, 0xC0355928>("\xAB\xA9\xB3\xA1\xAF\xA3\xA8\xAD\xB9\xA7\xA0\xBE\xA2\x8D\xA7\xB1\xAD\xA2\x88\xBB\xB6\xB6\xB4\xAE\x86\xEE\x82" + 0xC0355928).s, cvar.notifications_text_color[0], 1.0);
	Sakura::Cvar::New(/*notifications_text_color[1]*/XorStr<0xCC, 28, 0xC4FFDE88>("\xA2\xA2\xBA\xA6\xB6\xB8\xB1\xB2\xA0\xBC\xB9\xB9\xAB\x86\xAE\xBE\xA4\xA9\x81\xBC\x8F\x8D\x8D\x91\xBF\xD4\xBB" + 0xC4FFDE88).s, cvar.notifications_text_color[1], 1.0);
	Sakura::Cvar::New(/*notifications_text_color[2]*/XorStr<0x8C, 28, 0xAC464881>("\xE2\xE2\xFA\xE6\xF6\xF8\xF1\xF2\xE0\xFC\xF9\xF9\xEB\xC6\xEE\xFE\xE4\xE9\xC1\xFC\xCF\xCD\xCD\xD1\xFF\x97\xFB" + 0xAC464881).s, cvar.notifications_text_color[2], 1.0);
	Sakura::Cvar::New(/*notifications_text_color[3]*/XorStr<0x4A, 28, 0x6BBB7684>("\x24\x24\x38\x24\x28\x26\x33\x30\x26\x3A\x3B\x3B\x25\x08\x2C\x3C\x22\x2F\x03\x3E\x31\x33\x0F\x13\x39\x50\x39" + 0x6BBB7684).s, cvar.notifications_text_color[3]);
	Sakura::Cvar::New(/*notifications_bg_color[0]*/XorStr<0xC7, 26, 0x7358BAE7>("\xA9\xA7\xBD\xA3\xAD\xA5\xAE\xAF\xBB\xB9\xBE\xBC\xA0\x8B\xB7\xB1\x88\xBB\xB6\xB6\xB4\xAE\x86\xEE\x82" + 0x7358BAE7).s, cvar.notifications_bg_color[0], 0.2);
	Sakura::Cvar::New(/*notifications_bg_color[1]*/XorStr<0x38, 26, 0x3058FC79>("\x56\x56\x4E\x52\x5A\x54\x5D\x5E\x34\x28\x2D\x2D\x37\x1A\x24\x20\x17\x2A\x25\x27\x23\x3F\x15\x7E\x0D" + 0x3058FC79).s, cvar.notifications_bg_color[1], 0.2);
	Sakura::Cvar::New(/*notifications_bg_color[2]*/XorStr<0x8F, 26, 0x874CD944>("\xE1\xFF\xE5\xFB\xF5\xFD\xF6\xF7\xE3\xF1\xF6\xF4\xE8\xC3\xFF\xF9\xC0\xC3\xCE\xCE\xCC\xD6\xFE\x94\xFA" + 0x874CD944).s, cvar.notifications_bg_color[2], 0.2);
	Sakura::Cvar::New(/*notifications_bg_color[3]*/XorStr<0x43, 26, 0xEA6C1F8F>("\x2D\x2B\x31\x2F\x21\x21\x2A\x2B\x3F\x25\x22\x20\x3C\x0F\x33\x35\x0C\x37\x3A\x3A\x38\x2A\x02\x69\x06" + 0xEA6C1F8F).s, cvar.notifications_bg_color[3]);
	Sakura::Cvar::New(/*notifications_bg_time_color[0]*/XorStr<0x8C, 31, 0x868F8E73>("\xE2\xE2\xFA\xE6\xF6\xF8\xF1\xF2\xE0\xFC\xF9\xF9\xEB\xC6\xF8\xFC\xC3\xE9\xF7\xF2\xC5\xFE\xC1\xCC\xC8\xCA\xD4\xFC\x98\xF4" + 0x868F8E73).s, cvar.notifications_bg_time_color[0], 1.0);
	Sakura::Cvar::New(/*notifications_bg_time_color[1]*/XorStr<0xF1, 31, 0xDB6B264D>("\x9F\x9D\x87\x9D\x93\x9F\x94\x99\x8D\x93\x94\x92\x8E\xA1\x9D\x67\x5E\x76\x6A\x69\x60\x59\x64\x67\x65\x65\x79\x57\x3C\x53" + 0xDB6B264D).s, cvar.notifications_bg_time_color[1], 1.0);
	Sakura::Cvar::New(/*notifications_bg_time_color[2]*/XorStr<0x12, 31, 0xD9CC3D86>("\x7C\x7C\x60\x7C\x70\x7E\x7B\x78\x6E\x72\x73\x73\x6D\x40\x42\x46\x7D\x57\x4D\x48\x43\x78\x4B\x46\x46\x44\x5E\x76\x1C\x72" + 0xD9CC3D86).s, cvar.notifications_bg_time_color[2], 1.0);
	Sakura::Cvar::New(/*notifications_bg_time_color[3]*/XorStr<0xAD, 31, 0x43B28C25>("\xC3\xC1\xDB\xD9\xD7\xDB\xD0\xD5\xC1\xDF\xD8\xD6\xCA\xE5\xD9\xDB\xE2\xCA\xD6\xAD\xA4\x9D\xA0\xAB\xA9\xA9\xB5\x93\xFA\x97" + 0x43B28C25).s, cvar.notifications_bg_time_color[3]);

	Sakura::Cvar::New(/*kz_strafe_psilent*/XorStr<0xB7, 18, 0xB93966DE>("\xDC\xC2\xE6\xC9\xCF\xCE\xDC\xD8\xDA\x9F\xB1\xB1\xAA\xA8\xA0\xA8\xB3" + 0xB93966DE).s, cvar.kz_strafe_psilent);
	Sakura::Cvar::New(/*kz_strafe*/XorStr<0x92, 10, 0x97A77018>("\xF9\xE9\xCB\xE6\xE2\xE5\xF9\xFF\xFF" + 0x97A77018).s, cvar.kz_strafe);
	Sakura::Cvar::New(/*kz_fast_run*/XorStr<0xB9, 12, 0x194EA787>("\xD2\xC0\xE4\xDA\xDC\xCD\xCB\x9F\xB3\xB7\xAD" + 0x194EA787).s, cvar.kz_fast_run);
	Sakura::Cvar::New(/*kz_ground_strafe*/XorStr<0xBF, 17, 0xC13EAAA7>("\xD4\xBA\x9E\xA5\xB1\xAB\xB0\xA8\xA3\x97\xBA\xBE\xB9\xAD\xAB\xAB" + 0xC13EAAA7).s, cvar.kz_ground_strafe);
	Sakura::Cvar::New(/*kz_bhop*/XorStr<0xF9, 8, 0x54FBBD0A>("\x92\x80\xA4\x9E\x95\x91\x8F" + 0x54FBBD0A).s, cvar.kz_bhop);
	Sakura::Cvar::New(/*kz_bhop_frames_on_ground*/XorStr<0x53, 25, 0x79D11D03>("\x38\x2E\x0A\x34\x3F\x37\x29\x05\x3D\x2E\x3C\x33\x3A\x13\x3E\x0D\x0D\x3B\x02\x14\x08\x1D\x07\x0E" + 0x79D11D03).s, cvar.kz_bhop_frames_on_ground);
	Sakura::Cvar::New(/*kz_bhop_ideal_percentage*/XorStr<0x19, 25, 0x8608C279>("\x72\x60\x44\x7E\x75\x71\x6F\x7F\x48\x46\x46\x45\x49\x79\x57\x4D\x5B\x49\x4E\x42\x59\x4F\x48\x55" + 0x8608C279).s, cvar.kz_bhop_ideal_percentage, 50.0);
	Sakura::Cvar::New(/*kz_jump_bug*/XorStr<0xC4, 12, 0x70774349>("\xAF\xBF\x99\xAD\xBD\xA4\xBA\x94\xAE\xB8\xA9" + 0x70774349).s, cvar.kz_jump_bug);
	Sakura::Cvar::New(/*kz_jump_bug_auto*/XorStr<0x23, 17, 0xB4561747>("\x48\x5E\x7A\x4C\x52\x45\x59\x75\x49\x59\x4A\x71\x4E\x45\x45\x5D" + 0xB4561747).s, cvar.kz_jump_bug_auto);
	Sakura::Cvar::New(/*kz_show_kz*/XorStr<0x46, 11, 0x0C534F05>("\x2D\x3D\x17\x3A\x22\x24\x3B\x12\x25\x35" + 0x0C534F05).s, cvar.kz_show_kz);
	Sakura::Cvar::New(/*kz_display_time*/XorStr<0x45, 16, 0xD16AC5E9>("\x2E\x3C\x18\x2C\x20\x39\x3B\x20\x2C\x37\x10\x24\x38\x3F\x36" + 0xD16AC5E9).s, cvar.kz_display_time, 10.0);
	Sakura::Cvar::New(/*kz_strafe_key*/XorStr<0x6A, 14, 0x95ECCB26>("\x01\x11\x33\x1E\x1A\x1D\x11\x17\x17\x2C\x1F\x10\x0F" + 0x95ECCB26).s, cvar.kz_strafe_key, -1.0);
	Sakura::Cvar::New(/*kz_fastrun_key*/XorStr<0x71, 15, 0x82BFA97A>("\x1A\x08\x2C\x12\x14\x05\x03\x0A\x0C\x14\x24\x17\x18\x07" + 0x82BFA97A).s, cvar.kz_fastrun_key, -1.0);
	Sakura::Cvar::New(/*kz_ground_strafe_key*/XorStr<0xEC, 21, 0x8EB6C531>("\x87\x97\xB1\x88\x82\x9E\x87\x9D\x90\xAA\x85\x83\x8A\x98\x9C\x9E\xA3\x96\x9B\x86" + 0x8EB6C531).s, cvar.kz_ground_strafe_key, -1.0);
	Sakura::Cvar::New(/*kz_bhop_key*/XorStr<0xFF, 12, 0x3F278543>("\x94\x7A\x5E\x60\x6B\x6B\x75\x59\x6C\x6D\x70" + 0x3F278543).s, cvar.kz_bhop_key, -1.0);
	Sakura::Cvar::New(/*kz_jumpbug_key*/XorStr<0x1F, 15, 0xF1C5C9FE>("\x74\x5A\x7E\x48\x56\x49\x55\x44\x52\x4F\x76\x41\x4E\x55" + 0xF1C5C9FE).s, cvar.kz_jumpbug_key, -1.0);
	Sakura::Cvar::New(/*kz_strafe_toggle_key*/XorStr<0xE6, 21, 0xA25AC96F>("\x8D\x9D\xB7\x9A\x9E\x99\x8D\x8B\x8B\xB0\x84\x9E\x95\x94\x98\x90\xA9\x9C\x9D\x80" + 0xA25AC96F).s, cvar.kz_strafe_toggle_key, -1.0);
	Sakura::Cvar::New(/*kz_sgs*/XorStr<0x6A, 7, 0xB791CCEC>("\x01\x11\x33\x1E\x09\x1C" + 0xB791CCEC).s, cvar.kz_sgs);
	Sakura::Cvar::New(/*kz_sgs_ground_origin*/XorStr<0xB2, 21, 0xBF6BE51A>("\xD9\xC9\xEB\xC6\xD1\xC4\xE7\xDE\xC8\xD4\xC9\xD3\xDA\xE0\xAF\xB3\xAB\xA4\xAD\xAB" + 0xBF6BE51A).s, cvar.kz_sgs_ground_origin, 1.0);
	
	Sakura::Cvar::New(/*route_activate*/XorStr<0x4D, 15, 0x10C7503A>("\x3F\x21\x3A\x24\x34\x0D\x32\x37\x21\x3F\x21\x39\x2D\x3F" + 0x10C7503A).s, cvar.route_activate);
	Sakura::Cvar::New(/*route_mode*/XorStr<0xC9, 11, 0x36257626>("\xBB\xA5\xBE\xB8\xA8\x91\xA2\xBF\xB5\xB7" + 0x36257626).s, cvar.route_mode, 1.0);
	Sakura::Cvar::New(/*route_auto*/XorStr<0x81, 11, 0x00542E2F>("\xF3\xED\xF6\xF0\xE0\xD9\xE6\xFD\xFD\xE5" + 0x00542E2F).s, cvar.route_auto);
	Sakura::Cvar::New(/*route_jump*/XorStr<0xED, 11, 0xB1CF4071>("\x9F\x81\x9A\x84\x94\xAD\x99\x81\x98\x86" + 0xB1CF4071).s, cvar.route_jump, 1.0);
	Sakura::Cvar::New(/*route_jump_step*/XorStr<0x60, 16, 0x0683A4DF>("\x12\x0E\x17\x17\x01\x3A\x0C\x12\x05\x19\x35\x18\x18\x08\x1E" + 0x0683A4DF).s, cvar.route_jump_step, 2.0);
	Sakura::Cvar::New(/*route_direction*/XorStr<0xE3, 16, 0x1FBEB5F6>("\x91\x8B\x90\x92\x82\xB7\x8D\x83\x99\x89\x8E\x9A\x86\x9F\x9F" + 0x1FBEB5F6).s, cvar.route_direction, 1.0);
	Sakura::Cvar::New(/*route_direction_step*/XorStr<0x35, 21, 0x5F1E4382>("\x47\x59\x42\x4C\x5C\x65\x5F\x55\x4F\x5B\x5C\x34\x28\x2D\x2D\x1B\x36\x32\x22\x38" + 0x5F1E4382).s, cvar.route_direction_step, 4.0);
	Sakura::Cvar::New(/*route_draw_visual*/XorStr<0x08, 18, 0x709EE604>("\x7A\x66\x7F\x7F\x69\x52\x6A\x7D\x71\x66\x4D\x65\x7D\x66\x63\x76\x74" + 0x709EE604).s, cvar.route_draw_visual);
	Sakura::Cvar::New(/*route_draw*/XorStr<0xA8, 11, 0x622553CA>("\xDA\xC6\xDF\xDF\xC9\xF2\xCA\xDD\xD1\xC6" + 0x622553CA).s, cvar.route_draw, 1.0);
	Sakura::Cvar::New(/*route_rush_key*/XorStr<0x80, 15, 0x00EF74C7>("\xF2\xEE\xF7\xF7\xE1\xDA\xF4\xF2\xFB\xE1\xD5\xE0\xE9\xF4" + 0x00EF74C7).s, cvar.route_rush_key, -1.0);
	Sakura::Cvar::New(/*route_line_color[0]*/XorStr<0xCF, 20, 0xAB3213F3>("\xBD\xBF\xA4\xA6\xB6\x8B\xB9\xBF\xB9\xBD\x86\xB9\xB4\xB0\xB2\xAC\x84\xD0\xBC" + 0xAB3213F3).s, cvar.route_line_color[0], 1.0);
	Sakura::Cvar::New(/*route_line_color[1]*/XorStr<0xCE, 20, 0x5FCC1648>("\xBC\xA0\xA5\xA5\xB7\x8C\xB8\xBC\xB8\xB2\x87\xBA\xB5\xB7\xB3\xAF\x85\xEE\xBD" + 0x5FCC1648).s, cvar.route_line_color[1], 1.0);
	Sakura::Cvar::New(/*route_line_color[2]*/XorStr<0x04, 20, 0x673952C8>("\x76\x6A\x73\x73\x6D\x56\x66\x62\x62\x68\x51\x6C\x7F\x7D\x7D\x61\x4F\x27\x4B" + 0x673952C8).s, cvar.route_line_color[2], 1.0);
	Sakura::Cvar::New(/*route_line_color[3]*/XorStr<0x3B, 20, 0xCF96D14B>("\x49\x53\x48\x4A\x5A\x1F\x2D\x2B\x2D\x21\x1A\x25\x28\x24\x26\x38\x10\x7F\x10" + 0xCF96D14B).s, cvar.route_line_color[3], 1.0);
	Sakura::Cvar::New(/*route_point_color[0]*/XorStr<0x97, 21, 0x5BD8816F>("\xE5\xF7\xEC\xEE\xFE\xC3\xED\xF1\xF6\xCE\xD5\xFD\xC0\xCB\xC9\xC9\xD5\xF3\x99\xF7" + 0x5BD8816F).s, cvar.route_point_color[0], 1.0);
	Sakura::Cvar::New(/*route_point_color[1]*/XorStr<0xE5, 21, 0xACEDA4AC>("\x97\x89\x92\x9C\x8C\xB5\x9B\x83\x84\x80\x9B\xAF\x92\x9D\x9F\x9B\x87\xAD\xC6\xA5" + 0xACEDA4AC).s, cvar.route_point_color[1], 1.0);
	Sakura::Cvar::New(/*route_point_color[2]*/XorStr<0x34, 21, 0xC5C76498>("\x46\x5A\x43\x43\x5D\x66\x4A\x54\x55\x53\x4A\x60\x23\x2E\x2E\x2C\x36\x1E\x74\x1A" + 0xC5C76498).s, cvar.route_point_color[2], 1.0);
	Sakura::Cvar::New(/*route_point_color[3]*/XorStr<0xB8, 21, 0x589DBC20>("\xCA\xD6\xCF\xCF\xD9\xE2\xCE\xD0\xA9\xAF\xB6\x9C\xA7\xAA\xAA\xA8\xBA\x92\xF9\x96" + 0x589DBC20).s, cvar.route_point_color[3], 1.0);
	
	Sakura::Cvar::New(/*visual_model_hitbox*/XorStr<0xAE, 20, 0x0ADDB42A>("\xD8\xC6\xC3\xC4\xD3\xDF\xEB\xD8\xD9\xD3\xDD\xD5\xE5\xD3\xD5\xC9\xDC\xD0\xB8" + 0x0ADDB42A).s, cvar.visual_model_hitbox);
	Sakura::Cvar::New(/*visual_name*/XorStr<0x0B, 12, 0x09D7A67E>("\x7D\x65\x7E\x7B\x6E\x7C\x4E\x7C\x72\x79\x70" + 0x09D7A67E).s, cvar.visual_name);
	Sakura::Cvar::New(/*visual_name_world*/XorStr<0x6A, 18, 0x194D5F9A>("\x1C\x02\x1F\x18\x0F\x03\x2F\x1F\x13\x1E\x11\x2A\x01\x18\x0A\x15\x1E" + 0x194D5F9A).s, cvar.visual_name_world);
	Sakura::Cvar::New(/*visual_model*/XorStr<0xDF, 13, 0x5E58CAC5>("\xA9\x89\x92\x97\x82\x88\xBA\x8B\x88\x8C\x8C\x86" + 0x5E58CAC5).s, cvar.visual_model);
	Sakura::Cvar::New(/*visual_model_world*/XorStr<0x93, 19, 0x3064F015>("\xE5\xFD\xE6\xE3\xF6\xF4\xC6\xF7\xF4\xF8\xF8\xF2\xC0\xD7\xCE\xD0\xCF\xC0" + 0x3064F015).s, cvar.visual_model_world);
	Sakura::Cvar::New(/*visual_weapon*/XorStr<0xB4, 14, 0x124455E3>("\xC2\xDC\xC5\xC2\xD9\xD5\xE5\xCC\xD9\xDC\xCE\xD0\xAE" + 0x124455E3).s, cvar.visual_weapon);
	Sakura::Cvar::New(/*visual_reload_bar*/XorStr<0xEB, 18, 0x2DDB8606>("\x9D\x85\x9E\x9B\x8E\x9C\xAE\x80\x96\x98\x9A\x97\x93\xA7\x9B\x9B\x89" + 0x2DDB8606).s, cvar.visual_reload_bar);
	Sakura::Cvar::New(/*visual_box*/XorStr<0x75, 11, 0xCAA8BF1A>("\x03\x1F\x04\x0D\x18\x16\x24\x1E\x12\x06" + 0xCAA8BF1A).s, cvar.visual_box);
	Sakura::Cvar::New(/*visual_box_color_ct[0]*/XorStr<0x1A, 23, 0x75299F91>("\x6C\x72\x6F\x68\x7F\x73\x7F\x43\x4D\x5B\x7B\x46\x49\x4B\x47\x5B\x75\x48\x58\x76\x1E\x72" + 0x75299F91).s, cvar.visual_box_color_ct[0]);
	Sakura::Cvar::New(/*visual_box_color_ct[1]*/XorStr<0xE4, 23, 0x53286614>("\x92\x8C\x95\x92\x89\x85\xB5\x89\x83\x95\xB1\x8C\x9F\x9D\x9D\x81\xAB\x96\x82\xAC\xC9\xA4" + 0x53286614).s, cvar.visual_box_color_ct[1]);
	Sakura::Cvar::New(/*visual_box_color_ct[2]*/XorStr<0x36, 23, 0x2130D8F9>("\x40\x5E\x4B\x4C\x5B\x57\x63\x5F\x51\x47\x1F\x22\x2D\x2F\x2B\x37\x19\x24\x3C\x12\x78\x16" + 0x2130D8F9).s, cvar.visual_box_color_ct[2], 1.0);
	Sakura::Cvar::New(/*visual_box_color_ct[3]*/XorStr<0xDA, 23, 0x5AED2555>("\xAC\xB2\xAF\xA8\xBF\xB3\xBF\x83\x8D\x9B\xBB\x86\x89\x8B\x87\x9B\xB5\x88\x98\xB6\xDD\xB2" + 0x5AED2555).s, cvar.visual_box_color_ct[3], 1.0);
	Sakura::Cvar::New(/*visual_box_color_tt[0]*/XorStr<0x38, 23, 0x0D220FFB>("\x4E\x50\x49\x4E\x5D\x51\x61\x5D\x2F\x39\x1D\x20\x2B\x29\x29\x35\x17\x3D\x3E\x10\x7C\x10" + 0x0D220FFB).s, cvar.visual_box_color_tt[0], 1.0);
	Sakura::Cvar::New(/*visual_box_color_tt[1]*/XorStr<0x0C, 23, 0x6679ECD7>("\x7A\x64\x7D\x7A\x71\x7D\x4D\x71\x7B\x6D\x49\x74\x77\x75\x75\x69\x43\x69\x6A\x44\x11\x7C" + 0x6679ECD7).s, cvar.visual_box_color_tt[1]);
	Sakura::Cvar::New(/*visual_box_color_tt[2]*/XorStr<0x8B, 23, 0xB25C9635>("\xFD\xE5\xFE\xFB\xEE\xFC\xCE\xF0\xFC\xEC\xCA\xF5\xF8\xF4\xF6\xE8\xC4\xE8\xE9\xC5\xAD\xFD" + 0xB25C9635).s, cvar.visual_box_color_tt[2]);
	Sakura::Cvar::New(/*visual_box_color_tt[3]*/XorStr<0x18, 23, 0x9BE945D2>("\x6E\x70\x69\x6E\x7D\x71\x41\x7D\x4F\x59\x7D\x40\x4B\x49\x49\x55\x77\x5D\x5E\x70\x1F\x70" + 0x9BE945D2).s, cvar.visual_box_color_tt[3], 1.0);
	Sakura::Cvar::New(/*visual_box_draw*/XorStr<0x8E, 16, 0xD82BCF7A>("\xF8\xE6\xE3\xE4\xF3\xFF\xCB\xF7\xF9\xEF\xC7\xFD\xE8\xFA\xEB" + 0xD82BCF7A).s, cvar.visual_box_draw);
	Sakura::Cvar::New(/*visual_box_world*/XorStr<0xA3, 17, 0xB0CD587C>("\xD5\xCD\xD6\xD3\xC6\xC4\xF6\xC8\xC4\xD4\xF2\xD9\xC0\xC2\xDD\xD6" + 0xB0CD587C).s, cvar.visual_box_world);
	Sakura::Cvar::New(/*visual_box_type*/XorStr<0x8F, 16, 0x5D4A9A74>("\xF9\xF9\xE2\xE7\xF2\xF8\xCA\xF4\xF8\xE0\xC6\xEE\xE2\xEC\xF8" + 0x5D4A9A74).s, cvar.visual_box_type);
	Sakura::Cvar::New(/*visual_box_fill*/XorStr<0xDC, 16, 0xE4DBC78F>("\xAA\xB4\xAD\xAA\x81\x8D\xBD\x81\x8B\x9D\xB9\x81\x81\x85\x86" + 0xE4DBC78F).s, cvar.visual_box_fill);
	Sakura::Cvar::New(/*visual_health*/XorStr<0xF3, 14, 0x6C3025D8>("\x85\x9D\x86\x83\x96\x94\xA6\x92\x9E\x9D\x91\x8A\x97" + 0x6C3025D8).s, cvar.visual_health);
	Sakura::Cvar::New(/*visual_visual_team*/XorStr<0x9A, 19, 0x4B29B193>("\xEC\xF2\xEF\xE8\xFF\xF3\xFF\xD7\xCB\xD0\xD1\xC4\xCA\xF8\xDC\xCC\xCB\xC6" + 0x4B29B193).s, cvar.visual_visual_team);
	Sakura::Cvar::New(/*visual_sound_steps*/XorStr<0x7D, 19, 0x91D35E9E>("\x0B\x17\x0C\xF5\xE0\xEE\xDC\xF7\xEA\xF3\xE9\xEC\xD6\xF9\xFF\xE9\xFD\xFD" + 0x91D35E9E).s, cvar.visual_sound_steps);
	Sakura::Cvar::New(/*visual_sound_steps_segments*/XorStr<0xDC, 28, 0x7037A02C>("\xAA\xB4\xAD\xAA\x81\x8D\xBD\x90\x8B\x90\x88\x83\xB7\x9A\x9E\x8E\x9C\x9E\xB1\x9C\x95\x96\x9F\x96\x9A\x81\x85" + 0x7037A02C).s, cvar.visual_sound_steps_segments, 15.0);
	Sakura::Cvar::New(/*visual_sound_steps_segment_thickness*/XorStr<0x0E, 37, 0x6A8A2CA8>("\x78\x66\x63\x64\x73\x7F\x4B\x66\x79\x62\x76\x7D\x45\x68\x68\x78\x6E\x6C\x7F\x52\x47\x44\x49\x40\x48\x53\x77\x5D\x42\x42\x4F\x46\x40\x4A\x43\x42" + 0x6A8A2CA8).s, cvar.visual_sound_steps_segment_thickness, 1.0);
	Sakura::Cvar::New(/*visual_sound_steps_radius*/XorStr<0x0F, 26, 0x43121F15>("\x79\x79\x62\x67\x72\x78\x4A\x65\x78\x6D\x77\x7E\x44\x6F\x69\x7B\x6F\x53\x7E\x50\x42\x40\x4C\x53\x54" + 0x43121F15).s, cvar.visual_sound_steps_radius, 13.0);
	Sakura::Cvar::New(/*visual_sound_steps_color[0]*/XorStr<0x24, 28, 0xCDE36FF3>("\x52\x4C\x55\x52\x49\x45\x75\x58\x43\x58\x40\x4B\x6F\x42\x46\x56\x44\x46\x69\x54\x57\x55\x55\x49\x67\x0D\x63" + 0xCDE36FF3).s, cvar.visual_sound_steps_color[0]);
	Sakura::Cvar::New(/*visual_sound_steps_color[1]*/XorStr<0xA0, 28, 0x19BA8F7A>("\xD6\xC8\xD1\xD6\xC5\xC9\xF9\xD4\xC7\xDC\xC4\xCF\xF3\xDE\xDA\xCA\xC0\xC2\xED\xD0\xDB\xD9\xD9\xC5\xE3\x88\xE7" + 0x19BA8F7A).s, cvar.visual_sound_steps_color[1], 1.0);
	Sakura::Cvar::New(/*visual_sound_steps_color[2]*/XorStr<0xA4, 28, 0xE3D0AEC9>("\xD2\xCC\xD5\xD2\xC9\xC5\xF5\xD8\xC3\xD8\xC0\xCB\xEF\xC2\xC6\xD6\xC4\xC6\xE9\xD4\xD7\xD5\xD5\xC9\xE7\x8F\xE3" + 0xE3D0AEC9).s, cvar.visual_sound_steps_color[2]);
	Sakura::Cvar::New(/*visual_sound_steps_color[3]*/XorStr<0x5E, 28, 0xAEDB1682>("\x28\x36\x13\x14\x03\x0F\x3B\x16\x09\x12\x06\x0D\x35\x18\x18\x08\x1E\x1C\x2F\x12\x1D\x1F\x1B\x07\x2D\x44\x25" + 0xAEDB1682).s, cvar.visual_sound_steps_color[3], 1.0);
	Sakura::Cvar::New(/*visual_sound_steps_color_tt[0]*/XorStr<0xA2, 31, 0xCCB44ABC>("\xD4\xCA\xD7\xD0\xC7\xCB\xF7\xDA\xC5\xDE\xC2\xC9\xF1\xDC\xC4\xD4\xC2\xC0\xEB\xD6\xD9\xDB\xD7\xCB\xE5\xCF\xC8\xE6\x8E\xE2" + 0xCCB44ABC).s, cvar.visual_sound_steps_color_tt[0], 1.0);
	Sakura::Cvar::New(/*visual_sound_steps_color_tt[1]*/XorStr<0x35, 31, 0x324FE2ED>("\x43\x5F\x44\x4D\x58\x56\x64\x4F\x52\x4B\x51\x24\x1E\x31\x37\x21\x35\x35\x18\x2B\x26\x26\x24\x3E\x12\x3A\x3B\x0B\x60\x0F" + 0x324FE2ED).s, cvar.visual_sound_steps_color_tt[1]);
	Sakura::Cvar::New(/*visual_sound_steps_color_tt[2]*/XorStr<0x30, 31, 0x544A64FB>("\x46\x58\x41\x46\x55\x59\x69\x44\x57\x4C\x54\x5F\x63\x4E\x4A\x5A\x30\x32\x1D\x20\x2B\x29\x29\x35\x17\x3D\x3E\x10\x7E\x10" + 0x544A64FB).s, cvar.visual_sound_steps_color_tt[2]);
	Sakura::Cvar::New(/*visual_sound_steps_color_tt[3]*/XorStr<0x54, 31, 0x407CB8E2>("\x22\x3C\x25\x22\x39\x35\x05\x28\x33\x28\x30\x3B\x3F\x12\x16\x06\x14\x16\x39\x04\x07\x05\x05\x19\x33\x19\x1A\x34\x43\x2C" + 0x407CB8E2).s, cvar.visual_sound_steps_color_tt[3], 1.0);
	Sakura::Cvar::New(/*visual_sound_steps_color_ct[0]*/XorStr<0x22, 31, 0xC4F5E22C>("\x54\x4A\x57\x50\x47\x4B\x77\x5A\x45\x5E\x42\x49\x71\x5C\x44\x54\x42\x40\x6B\x56\x59\x5B\x57\x4B\x65\x58\x48\x66\x0E\x62" + 0xC4F5E22C).s, cvar.visual_sound_steps_color_ct[0]);
	Sakura::Cvar::New(/*visual_sound_steps_color_ct[1]*/XorStr<0x8C, 31, 0xD39239C2>("\xFA\xE4\xFD\xFA\xF1\xFD\xCD\xE0\xFB\xE0\xF8\xF3\xC7\xEA\xEE\xFE\xEC\xEE\xC1\xFC\xCF\xCD\xCD\xD1\xFB\xC6\xD2\xFC\x99\xF4" + 0xD39239C2).s, cvar.visual_sound_steps_color_ct[1]);
	Sakura::Cvar::New(/*visual_sound_steps_color_ct[2]*/XorStr<0xD4, 31, 0x0696CB3B>("\xA2\xBC\xA5\xA2\xB9\xB5\x85\xA8\xB3\xA8\xB0\xBB\xBF\x92\x96\x86\x94\x96\xB9\x84\x87\x85\x85\x99\xB3\x8E\x9A\xB4\xC2\xAC" + 0x0696CB3B).s, cvar.visual_sound_steps_color_ct[2], 1.0);
	Sakura::Cvar::New(/*visual_sound_steps_color_ct[3]*/XorStr<0x7C, 31, 0x480D1A9F>("\x0A\x14\x0D\x0A\xE1\xED\xDD\xF0\xEB\xF0\xE8\xE3\xD7\xFA\xFE\xEE\xFC\xFE\xD1\xEC\xFF\xFD\xFD\xE1\xCB\xF6\xE2\xCC\xAB\xC4" + 0x480D1A9F).s, cvar.visual_sound_steps_color_ct[3], 1.0);
	Sakura::Cvar::New(/*visual_idhook_only*/XorStr<0xAF, 19, 0xE7EA9BCD>("\xD9\xD9\xC2\xC7\xD2\xD8\xEA\xDF\xD3\xD0\xD6\xD5\xD0\xE3\xD2\xD0\xD3\xB9" + 0xE7EA9BCD).s, cvar.visual_idhook_only);
	Sakura::Cvar::New(/*visual_noflash_enable*/XorStr<0xCE, 22, 0x68255D1F>("\xB8\xA6\xA3\xA4\xB3\xBF\x8B\xBB\xB9\xB1\xB4\xB8\xA9\xB3\x83\xB8\xB0\xBE\x82\x8D\x87" + 0x68255D1F).s, cvar.visual_noflash_enable);
	Sakura::Cvar::New(/*visual_chase_cam*/XorStr<0x4B, 17, 0x6AE45495>("\x3D\x25\x3E\x3B\x2E\x3C\x0E\x31\x3B\x35\x26\x33\x08\x3B\x38\x37" + 0x6AE45495).s, cvar.visual_chase_cam);
	Sakura::Cvar::New(/*visual_chase_back*/XorStr<0xDF, 18, 0x65A8A22F>("\xA9\x89\x92\x97\x82\x88\xBA\x85\x8F\x89\x9A\x8F\xB4\x8E\x8C\x8D\x84" + 0x65A8A22F).s, cvar.visual_chase_back, 100.0);
	Sakura::Cvar::New(/*visual_chase_up*/XorStr<0x67, 16, 0xD4A42BF4>("\x11\x01\x1A\x1F\x0A\x00\x32\x0D\x07\x11\x02\x17\x2C\x01\x05" + 0xD4A42BF4).s, cvar.visual_chase_up, 16.0);
	Sakura::Cvar::New(/*visual_grenade_trajectory*/XorStr<0xBC, 26, 0xA4209481>("\xCA\xD4\xCD\xCA\xA1\xAD\x9D\xA4\xB6\xA0\xA8\xA6\xAC\xAC\x95\xBF\xBE\xAC\xA4\xAA\xB3\xA5\xBD\xA1\xAD" + 0xA4209481).s, cvar.visual_grenade_trajectory);
	Sakura::Cvar::New(/*visual_grenade_trajectory_point_color[0]*/XorStr<0xAB, 41, 0xAC611A47>("\xDD\xC5\xDE\xDB\xCE\xDC\xEE\xD5\xC1\xD1\xDB\xD7\xD3\xDD\xE6\xCE\xC9\xDD\xD7\xDB\xDC\xB4\xAE\xB0\xBA\x9B\xB5\xA9\xAE\xA6\xBD\x95\xA8\xA3\xA1\xA1\xBD\x8B\xE1\x8F" + 0xAC611A47).s, cvar.visual_grenade_trajectory_point_color[0], 1.0);
	Sakura::Cvar::New(/*visual_grenade_trajectory_point_color[1]*/XorStr<0xA5, 41, 0x261791C8>("\xD3\xCF\xD4\xDD\xC8\xC6\xF4\xCB\xDF\xCB\xC1\xD1\xD5\xD7\xEC\xC0\xC7\xD7\xDD\xDD\xDA\xCE\xD4\xCE\xC4\xE1\xCF\xAF\xA8\xAC\xB7\x9B\xA6\xA9\xAB\xA7\xBB\x91\xFA\x91" + 0x261791C8).s, cvar.visual_grenade_trajectory_point_color[1], 1.0);
	Sakura::Cvar::New(/*visual_grenade_trajectory_point_color[2]*/XorStr<0x80, 41, 0xAD89F306>("\xF6\xE8\xF1\xF6\xE5\xE9\xD9\xE0\xFA\xEC\xE4\xEA\xE8\xE8\xD1\xFB\xE2\xF0\xF8\xF6\xF7\xE1\xF9\xE5\xE1\xC6\xEA\xF4\xF5\xF3\xEA\xC0\xC3\xCE\xCE\xCC\xD6\xFE\x94\xFA" + 0xAD89F306).s, cvar.visual_grenade_trajectory_point_color[2], 1.0);
	Sakura::Cvar::New(/*visual_grenade_trajectory_point_color[3]*/XorStr<0xE0, 41, 0x8C52CFC7>("\x96\x88\x91\x96\x85\x89\xB9\x80\x9A\x8C\x84\x8A\x88\x88\xB1\x9B\x82\x90\x98\x96\x97\x81\x99\x85\x81\xA6\x8A\x94\x95\x93\x8A\xA0\x63\x6E\x6E\x6C\x76\x5E\x35\x5A" + 0x8C52CFC7).s, cvar.visual_grenade_trajectory_point_color[3], 1.0);
	Sakura::Cvar::New(/*visual_grenade_trajectory_line_color[0]*/XorStr<0x20, 40, 0x220B3F53>("\x56\x48\x51\x56\x45\x49\x79\x40\x5A\x4C\x44\x4A\x48\x48\x71\x5B\x42\x50\x58\x56\x57\x41\x59\x45\x41\x66\x56\x52\x52\x58\x61\x5C\x2F\x2D\x2D\x31\x1F\x75\x1B" + 0x220B3F53).s, cvar.visual_grenade_trajectory_line_color[0], 1.0);
	Sakura::Cvar::New(/*visual_grenade_trajectory_line_color[1]*/XorStr<0xF0, 40, 0xB259CC8F>("\x86\x98\x81\x86\x95\x99\xA9\x90\x8A\x9C\x94\x9A\x98\x98\xA1\x8B\x72\x60\x68\x66\x67\x71\x69\x75\x71\x56\x66\x62\x62\x68\x51\x6C\x7F\x7D\x7D\x61\x4F\x24\x4B" + 0xB259CC8F).s, cvar.visual_grenade_trajectory_line_color[1], 1.0);
	Sakura::Cvar::New(/*visual_grenade_trajectory_line_color[2]*/XorStr<0x5C, 40, 0x4FEE4571>("\x2A\x34\x2D\x2A\x01\x0D\x3D\x04\x16\x00\x08\x06\x0C\x0C\x35\x1F\x1E\x0C\x04\x0A\x13\x05\x1D\x01\x0D\x2A\x1A\x1E\x16\x1C\x25\x18\x13\x11\x11\x0D\xDB\xB3\xDF" + 0x4FEE4571).s, cvar.visual_grenade_trajectory_line_color[2]);
	Sakura::Cvar::New(/*visual_grenade_trajectory_line_color[3]*/XorStr<0x01, 40, 0x48E8FB3E>("\x77\x6B\x70\x71\x64\x6A\x58\x6F\x7B\x6F\x65\x6D\x69\x6B\x50\x64\x63\x73\x79\x71\x76\x62\x78\x6A\x60\x45\x77\x75\x73\x7B\x40\x43\x4E\x4E\x4C\x56\x7E\x15\x7A" + 0x48E8FB3E).s, cvar.visual_grenade_trajectory_line_color[3], 1.0);
	Sakura::Cvar::New(/*visual_crosshair*/XorStr<0x37, 17, 0xA2709023>("\x41\x51\x4A\x4F\x5A\x50\x62\x5D\x4D\x2F\x32\x31\x2B\x25\x2C\x34" + 0xA2709023).s, cvar.visual_crosshair);
	Sakura::Cvar::New(/*visual_crosshair_color[0]*/XorStr<0x55, 26, 0x3AEDCD9D>("\x23\x3F\x24\x2D\x38\x36\x04\x3F\x2F\x31\x2C\x13\x09\x03\x0A\x16\x3A\x05\x08\x04\x06\x18\x30\x5C\x30" + 0x3AEDCD9D).s, cvar.visual_crosshair_color[0]);
	Sakura::Cvar::New(/*visual_crosshair_color[1]*/XorStr<0xBB, 26, 0xA58C02CC>("\xCD\xD5\xCE\xCB\xDE\xAC\x9E\xA1\xB1\xAB\xB6\xB5\xAF\xA9\xA0\xB8\x94\xAF\xA2\xA2\xA0\xA2\x8A\xE3\x8E" + 0xA58C02CC).s, cvar.visual_crosshair_color[1], 1.0);
	Sakura::Cvar::New(/*visual_crosshair_color[2]*/XorStr<0x5E, 26, 0xCFBA456E>("\x28\x36\x13\x14\x03\x0F\x3B\x06\x14\x08\x1B\x1A\x02\x0A\x05\x1F\x31\x0C\x1F\x1D\x1D\x01\x2F\x47\x2B" + 0xCFBA456E).s, cvar.visual_crosshair_color[2]);
	Sakura::Cvar::New(/*visual_crosshair_color[3]*/XorStr<0x60, 26, 0x0A1CDFB5>("\x16\x08\x11\x16\x05\x09\x39\x04\x1A\x06\x19\x18\x04\x0C\x07\x1D\x2F\x12\x1D\x1F\x1B\x07\x2D\x44\x25" + 0x0A1CDFB5).s, cvar.visual_crosshair_color[3], 1.0);
	Sakura::Cvar::New(/*visual_vip*/XorStr<0x25, 11, 0xDFF5BC98>("\x53\x4F\x54\x5D\x48\x46\x74\x5A\x44\x5E" + 0xDFF5BC98).s, cvar.visual_vip);
	Sakura::Cvar::New(/*visual_weapon_local*/XorStr<0x97, 20, 0x69CF9F97>("\xE1\xF1\xEA\xEF\xFA\xF0\xC2\xE9\xFA\xC1\xD1\xCD\xCD\xFB\xC9\xC9\xC4\xC9\xC5" + 0x69CF9F97).s, cvar.visual_weapon_local);
	Sakura::Cvar::New(/*visual_weapon_noanim*/XorStr<0xD2, 21, 0xF242C24E>("\xA4\xBA\xA7\xA0\xB7\xBB\x87\xAE\xBF\xBA\xAC\xB2\xB0\x80\x8E\x8E\x83\x8D\x8D\x88" + 0xF242C24E).s, cvar.visual_weapon_noanim);
	Sakura::Cvar::New(/*visual_lightmap*/XorStr<0xFA, 16, 0xF1B79C1F>("\x8C\x92\x8F\x88\x9F\x93\x5F\x6D\x6B\x64\x6C\x71\x6B\x66\x78" + 0xF1B79C1F).s, cvar.visual_lightmap);
	Sakura::Cvar::New(/*visual_lightmap_color[0]*/XorStr<0x1F, 25, 0x1418C445>("\x69\x49\x52\x57\x42\x48\x7A\x4A\x4E\x4F\x41\x5E\x46\x4D\x5D\x71\x4C\x5F\x5D\x5D\x41\x6F\x05\x6B" + 0x1418C445).s, cvar.visual_lightmap_color[0], 1.0);
	Sakura::Cvar::New(/*visual_lightmap_color[1]*/XorStr<0xC8, 25, 0xD84765D4>("\xBE\xA0\xB9\xBE\xAD\xA1\x91\xA3\xB9\xB6\xBA\xA7\xB9\xB4\xA6\x88\xBB\xB6\xB6\xB4\xAE\x86\xEF\x82" + 0xD84765D4).s, cvar.visual_lightmap_color[1], 1.0);
	Sakura::Cvar::New(/*visual_lightmap_color[2]*/XorStr<0x22, 25, 0x7095A28F>("\x54\x4A\x57\x50\x47\x4B\x77\x45\x43\x4C\x44\x59\x43\x4E\x40\x6E\x51\x5C\x58\x5A\x44\x6C\x0A\x64" + 0x7095A28F).s, cvar.visual_lightmap_color[2], 1.0);
	Sakura::Cvar::New(/*visual_sky*/XorStr<0x7C, 11, 0x34BF185C>("\x0A\x14\x0D\x0A\xE1\xED\xDD\xF0\xEF\xFC" + 0x34BF185C).s, cvar.visual_sky);
	Sakura::Cvar::New(/*visual_skins_player*/XorStr<0xBC, 20, 0xE1504526>("\xCA\xD4\xCD\xCA\xA1\xAD\x9D\xB0\xAF\xAC\xA8\xB4\x97\xB9\xA6\xAA\xB5\xA8\xBC" + 0xE1504526).s, cvar.visual_skins_player);
	Sakura::Cvar::New(/*visual_skins_player_weapon*/XorStr<0x0A, 27, 0x29FC20DA>("\x7C\x62\x7F\x78\x6F\x63\x4F\x62\x79\x7A\x7A\x66\x49\x67\x74\x78\x63\x7E\x6E\x42\x69\x7A\x41\x51\x4D\x4D" + 0x29FC20DA).s, cvar.visual_skins_player_weapon);
	Sakura::Cvar::New(/*visual_skins_player_backweapon*/XorStr<0xE4, 31, 0xBE95912A>("\x92\x8C\x95\x92\x89\x85\xB5\x98\x87\x84\x80\x9C\xAF\x81\x9E\x92\x8D\x90\x84\xA8\x9A\x98\x99\x90\x8B\x98\x9F\x8F\x6F\x6F" + 0xBE95912A).s, cvar.visual_skins_player_backweapon);
	Sakura::Cvar::New(/*visual_skins_backpack*/XorStr<0x5A, 22, 0xA5F4DF56>("\x2C\x32\x2F\x28\x3F\x33\x3F\x12\x09\x0A\x0A\x16\x39\x05\x09\x0A\x01\x1B\x0D\x0E\x05" + 0xA5F4DF56).s, cvar.visual_skins_backpack);
	Sakura::Cvar::New(/*visual_skins_thighpack*/XorStr<0x18, 23, 0x96C7297B>("\x6E\x70\x69\x6E\x7D\x71\x41\x6C\x4B\x48\x4C\x50\x7B\x51\x4E\x4E\x4F\x41\x5A\x4A\x4F\x46" + 0x96C7297B).s, cvar.visual_skins_thighpack);
	Sakura::Cvar::New(/*visual_skins_viewmodel*/XorStr<0x42, 23, 0xB5A1B4D0>("\x34\x2A\x37\x30\x27\x2B\x17\x3A\x21\x22\x22\x3E\x11\x39\x39\x34\x25\x3E\x3B\x31\x33\x3B" + 0xB5A1B4D0).s, cvar.visual_skins_viewmodel);
	Sakura::Cvar::New(/*visual_skins_viewmodel_color[0]*/XorStr<0xFF, 32, 0x92590083>("\x89\x69\x72\x77\x62\x68\x5A\x75\x6C\x61\x67\x79\x54\x7A\x64\x6B\x78\x7D\x7E\x76\x76\x78\x4A\x75\x78\x74\x76\x68\x40\x2C\x40" + 0x92590083).s, cvar.visual_skins_viewmodel_color[0], 1.0);
	Sakura::Cvar::New(/*visual_skins_viewmodel_color[1]*/XorStr<0xC8, 32, 0x55C6065A>("\xBE\xA0\xB9\xBE\xAD\xA1\x91\xBC\xBB\xB8\xBC\xA0\x8B\xA3\xBF\xB2\xAF\xB4\xB5\xBF\xB9\xB1\x81\xBC\x8F\x8D\x8D\x91\xBF\xD4\xBB" + 0x55C6065A).s, cvar.visual_skins_viewmodel_color[1], 1.0);
	Sakura::Cvar::New(/*visual_skins_viewmodel_color[2]*/XorStr<0x87, 32, 0x55CEE81E>("\xF1\xE1\xFA\xFF\xEA\xE0\xD2\xFD\xE4\xF9\xFF\xE1\xCC\xE2\xFC\xF3\xE0\xF5\xF6\xFE\xFE\xF0\xC2\xFD\xF0\xCC\xCE\xD0\xF8\x96\xF8" + 0x55CEE81E).s, cvar.visual_skins_viewmodel_color[2], 0.5);
	Sakura::Cvar::New(/*visual_skins_viewmodel_color[3]*/XorStr<0x92, 32, 0xAE43880C>("\xE4\xFA\xE7\xE0\xF7\xFB\xC7\xEA\xF1\xF2\xF2\xEE\xC1\xE9\xC9\xC4\xD5\xCE\xCB\xC1\xC3\xCB\xF7\xCA\xC5\xC7\xC3\xDF\xF5\x9C\xED" + 0xAE43880C).s, cvar.visual_skins_viewmodel_color[3], 1.0);
	Sakura::Cvar::New(/*visual_skins_viewmodel_hands*/XorStr<0x69, 29, 0xD576C626>("\x1F\x03\x18\x19\x0C\x02\x30\x03\x1A\x1B\x1D\x07\x2A\x00\x1E\x1D\x0E\x17\x14\x18\x18\x12\x20\xE8\xE0\xEC\xE7\xF7" + 0xD576C626).s, cvar.visual_skins_viewmodel_hands);
	Sakura::Cvar::New(/*visual_skins_viewmodel_nohands*/XorStr<0x4A, 31, 0x24BF9B75>("\x3C\x22\x3F\x38\x2F\x23\x0F\x22\x39\x3A\x3A\x26\x09\x21\x31\x3C\x2D\x36\x33\x39\x3B\x33\x3F\x0F\x0D\x0B\x05\x0B\x02\x14" + 0x24BF9B75).s, cvar.visual_skins_viewmodel_nohands);
	Sakura::Cvar::New(/*visual_skins_world*/XorStr<0x58, 19, 0xE0276CB4>("\x2E\x30\x29\x2E\x3D\x31\x01\x2C\x0B\x08\x0C\x10\x3B\x12\x09\x15\x04\x0D" + 0xE0276CB4).s, cvar.visual_skins_world);
	Sakura::Cvar::New(/*visual_skins_bullet_shell*/XorStr<0x19, 26, 0xE267E900>("\x6F\x73\x68\x69\x7C\x72\x40\x53\x4A\x4B\x4D\x57\x7A\x44\x52\x44\x45\x4F\x5F\x73\x5E\x46\x4A\x5C\x5D" + 0xE267E900).s, cvar.visual_skins_bullet_shell);
	Sakura::Cvar::New(/*visual_skins_wall*/XorStr<0xB0, 18, 0xD8B13DBB>("\xC6\xD8\xC1\xC6\xD5\xD9\xE9\xC4\xD3\xD0\xD4\xC8\xE3\xCA\xDF\xD3\xAC" + 0xD8B13DBB).s, cvar.visual_skins_wall);
	Sakura::Cvar::New(/*visual_skins_chicken*/XorStr<0x72, 21, 0x22571E1A>("\x04\x1A\x07\x00\x17\x1B\x27\x0A\x11\x12\x12\x0E\x21\x1C\xE8\xE8\xE1\xE8\xE1\xEB" + 0x22571E1A).s, cvar.visual_skins_chicken);
	Sakura::Cvar::New(/*visual_viewmodel_fov*/XorStr<0x67, 21, 0x3D67D728>("\x11\x01\x1A\x1F\x0A\x00\x32\x18\x06\x15\x06\x1F\x1C\x10\x10\x1A\x28\x1E\x16\x0C" + 0x3D67D728).s, cvar.visual_viewmodel_fov);
	Sakura::Cvar::New(/*visual_lambert*/XorStr<0x67, 15, 0xA91D1C20>("\x11\x01\x1A\x1F\x0A\x00\x32\x02\x0E\x1D\x13\x17\x01\x00" + 0xA91D1C20).s, cvar.visual_lambert);
	Sakura::Cvar::New(/*visual_lambert_color_tt[0]*/XorStr<0x54, 27, 0x26D38E2D>("\x22\x3C\x25\x22\x39\x35\x05\x37\x3D\x30\x3C\x3A\x12\x15\x3D\x00\x0B\x09\x09\x15\x37\x1D\x1E\x30\x5C\x30" + 0x26D38E2D).s, cvar.visual_lambert_color_tt[0], 1.0);
	Sakura::Cvar::New(/*visual_lambert_color_tt[1]*/XorStr<0x8F, 27, 0x9A55B263>("\xF9\xF9\xE2\xE7\xF2\xF8\xCA\xFA\xF6\xF5\xFB\xFF\xE9\xE8\xC2\xFD\xF0\xCC\xCE\xD0\xFC\xD0\xD1\xFD\x96\xF5" + 0x9A55B263).s, cvar.visual_lambert_color_tt[1]);
	Sakura::Cvar::New(/*visual_lambert_color_tt[2]*/XorStr<0x62, 27, 0xB5E30E65>("\x14\x0A\x17\x10\x07\x0B\x37\x05\x0B\x06\x0E\x08\x1C\x1B\x2F\x12\x1D\x1F\x1B\x07\x29\x03\x0C\x22\x48\x26" + 0xB5E30E65).s, cvar.visual_lambert_color_tt[2]);
	Sakura::Cvar::New(/*visual_lambert_color_tt[3]*/XorStr<0x4D, 27, 0xE3118096>("\x3B\x27\x3C\x25\x30\x3E\x0C\x38\x34\x3B\x35\x3D\x2B\x2E\x04\x3F\x32\x32\x30\x12\x3E\x16\x17\x3F\x56\x3B" + 0xE3118096).s, cvar.visual_lambert_color_tt[3], 1.0);
	Sakura::Cvar::New(/*visual_lambert_color_ct[0]*/XorStr<0xDC, 27, 0xDDFBFAD6>("\xAA\xB4\xAD\xAA\x81\x8D\xBD\x8F\x85\x88\x84\x82\x9A\x9D\xB5\x88\x83\x81\x81\x9D\xAF\x92\x86\xA8\xC4\xA8" + 0xDDFBFAD6).s, cvar.visual_lambert_color_ct[0]);
	Sakura::Cvar::New(/*visual_lambert_color_ct[1]*/XorStr<0x74, 27, 0xF3ECF952>("\x02\x1C\x05\x02\x19\x15\x25\x17\x1D\x10\x1C\x1A\xF2\xF5\xDD\xE0\xEB\xE9\xE9\xF5\xD7\xEA\xFE\xD0\xBD\xD0" + 0xF3ECF952).s, cvar.visual_lambert_color_ct[1]);
	Sakura::Cvar::New(/*visual_lambert_color_ct[2]*/XorStr<0x26, 27, 0xAF62AC2B>("\x50\x4E\x5B\x5C\x4B\x47\x73\x41\x4F\x42\x52\x54\x40\x47\x6B\x56\x59\x5B\x57\x4B\x65\x58\x48\x66\x0C\x62" + 0xAF62AC2B).s, cvar.visual_lambert_color_ct[2], 1.0);
	Sakura::Cvar::New(/*visual_lambert_color_ct[3]*/XorStr<0xC4, 27, 0xA76A6F6A>("\xB2\xAC\xB5\xB2\xA9\xA5\x95\xA7\xAD\xA0\xAC\xAA\xA2\xA5\x8D\xB0\xBB\xB9\xB9\xA5\x87\xBA\xAE\x80\xEF\x80" + 0xA76A6F6A).s, cvar.visual_lambert_color_ct[3], 1.0);
	Sakura::Cvar::New(/*visual_lambert_local*/XorStr<0x8D, 21, 0xC42B3B1C>("\xFB\xE7\xFC\xE5\xF0\xFE\xCC\xF8\xF4\xFB\xF5\xFD\xEB\xEE\xC4\xF0\xF2\xFD\xFE\xCC" + 0xC42B3B1C).s, cvar.visual_lambert_local);
	Sakura::Cvar::New(/*visual_lambert_color_local[0]*/XorStr<0x6D, 30, 0x3D1C193B>("\x1B\x07\x1C\x05\x10\x1E\x2C\x18\x14\x1B\x15\x1D\x0B\x0E\x24\x1F\x12\x12\x10\xF2\xDE\xEE\xEC\xE7\xE4\xEA\xDC\xB8\xD4" + 0x3D1C193B).s, cvar.visual_lambert_color_local[0]);
	Sakura::Cvar::New(/*visual_lambert_color_local[1]*/XorStr<0xA1, 30, 0x75160067>("\xD7\xCB\xD0\xD1\xC4\xCA\xF8\xC4\xC8\xC7\xC9\xC9\xDF\xDA\xF0\xD3\xDE\xDE\xDC\xC6\xEA\xDA\xD8\xDB\xD8\xD6\xE0\x8D\xE0" + 0x75160067).s, cvar.visual_lambert_color_local[1], 1.0);
	Sakura::Cvar::New(/*visual_lambert_color_local[2]*/XorStr<0x93, 30, 0xC61551D8>("\xE5\xFD\xE6\xE3\xF6\xF4\xC6\xF6\xFA\xF1\xFF\xFB\xED\xD4\xFE\xC1\xCC\xC8\xCA\xD4\xF8\xC4\xC6\xC9\xCA\xC0\xF6\x9C\xF2" + 0xC61551D8).s, cvar.visual_lambert_color_local[2]);
	Sakura::Cvar::New(/*visual_lambert_color_local[3]*/XorStr<0x1F, 30, 0xA2151B1E>("\x69\x49\x52\x57\x42\x48\x7A\x4A\x46\x45\x4B\x4F\x59\x58\x72\x4D\x40\x5C\x5E\x40\x6C\x58\x5A\x55\x56\x54\x62\x09\x66" + 0xA2151B1E).s, cvar.visual_lambert_color_local[3], 1.0);
	Sakura::Cvar::New(/*visual_lambert_world*/XorStr<0x41, 21, 0xC0317926>("\x37\x2B\x30\x31\x24\x2A\x18\x24\x28\x27\x29\x29\x3F\x3A\x10\x27\x3E\x20\x3F\x30" + 0xC0317926).s, cvar.visual_lambert_world);
	Sakura::Cvar::New(/*visual_lambert_world_color[0]*/XorStr<0xAB, 30, 0xB9106A1E>("\xDD\xC5\xDE\xDB\xCE\xDC\xEE\xDE\xD2\xD9\xD7\xD3\xC5\xCC\xE6\xCD\xD4\xCE\xD1\xDA\xE0\xA3\xAE\xAE\xAC\xB6\x9E\xF6\x9A" + 0xB9106A1E).s, cvar.visual_lambert_world_color[0], 1.0);
	Sakura::Cvar::New(/*visual_lambert_world_color[1]*/XorStr<0xAD, 30, 0x6D97D20C>("\xDB\xC7\xDC\xC5\xD0\xDE\xEC\xD8\xD4\xDB\xD5\xDD\xCB\xCE\xE4\xCB\xD2\xCC\xD3\xA4\x9E\xA1\xAC\xA8\xAA\xB4\x9C\xF9\x94" + 0x6D97D20C).s, cvar.visual_lambert_world_color[1], 1.0);
	Sakura::Cvar::New(/*visual_lambert_world_color[2]*/XorStr<0x86, 30, 0xE2D8021A>("\xF0\xEE\xFB\xFC\xEB\xE7\xD3\xE1\xEF\xE2\xF2\xF4\xE0\xE7\xCB\xE2\xF9\xE5\xF4\xFD\xC5\xF8\xF3\xF1\xF1\xED\xFB\x93\xFF" + 0xE2D8021A).s, cvar.visual_lambert_world_color[2], 1.0);
	Sakura::Cvar::New(/*visual_lambert_world_color[3]*/XorStr<0xF6, 30, 0xB8D31663>("\x80\x9E\x8B\x8C\x9B\x97\xA3\x91\x9F\x92\x62\x64\x70\x77\x5B\x72\x69\x75\x64\x6D\x55\x68\x63\x61\x61\x7D\x4B\x22\x4F" + 0xB8D31663).s, cvar.visual_lambert_world_color[3], 1.0);
	Sakura::Cvar::New(/*visual_lambert_viewmodel*/XorStr<0xBB, 25, 0x805F8B1A>("\xCD\xD5\xCE\xCB\xDE\xAC\x9E\xAE\xA2\xA9\xA7\xA3\xB5\xBC\x96\xBC\xA2\xA9\xBA\xA3\xA0\xB4\xB4\xBE" + 0x805F8B1A).s, cvar.visual_lambert_viewmodel);
	Sakura::Cvar::New(/*visual_lambert_viewmodel_color[0]*/XorStr<0x75, 34, 0x4BBFF221>("\x03\x1F\x04\x0D\x18\x16\x24\x10\x1C\x13\x1D\xE5\xF3\xF6\xDC\xF2\xEC\xE3\xF0\xE5\xE6\xEE\xEE\xE0\xD2\xED\xE0\xFC\xFE\xE0\xC8\xA4\xC8" + 0x4BBFF221).s, cvar.visual_lambert_viewmodel_color[0]);
	Sakura::Cvar::New(/*visual_lambert_viewmodel_color[1]*/XorStr<0x67, 34, 0x84A58594>("\x11\x01\x1A\x1F\x0A\x00\x32\x02\x0E\x1D\x13\x17\x01\x00\x2A\x00\x1E\x1D\x0E\x17\x14\x18\x18\x12\x20\xE3\xEE\xEE\xEC\xF6\xDE\xB7\xDA" + 0x84A58594).s, cvar.visual_lambert_viewmodel_color[1], 1.0);
	Sakura::Cvar::New(/*visual_lambert_viewmodel_color[2]*/XorStr<0xED, 34, 0xA9FE7088>("\x9B\x87\x9C\x85\x90\x9E\xAC\x98\x94\x9B\x95\x9D\x8B\x8E\xA4\x8A\x94\x9B\x88\x6D\x6E\x66\x66\x68\x5A\x65\x68\x64\x66\x78\x50\x3E\x50" + 0xA9FE7088).s, cvar.visual_lambert_viewmodel_color[2]);
	Sakura::Cvar::New(/*visual_lambert_viewmodel_color[3]*/XorStr<0xA6, 34, 0x85D54218>("\xD0\xCE\xDB\xDC\xCB\xC7\xF3\xC1\xCF\xC2\xD2\xD4\xC0\xC7\xEB\xC3\xDF\xD2\xCF\xD4\xD5\xDF\xD9\xD1\xE1\xDC\xAF\xAD\xAD\xB1\x9F\xF6\x9B" + 0x85D54218).s, cvar.visual_lambert_viewmodel_color[3], 1.0);
	Sakura::Cvar::New(/*visual_tg_type*/XorStr<0xB4, 15, 0x68A39C46>("\xC2\xDC\xC5\xC2\xD9\xD5\xE5\xCF\xDB\xE2\xCA\xC6\xB0\xA4" + 0x68A39C46).s, cvar.visual_tg_type);
	Sakura::Cvar::New(/*visual_draw_fov*/XorStr<0x5C, 16, 0xEBD63A92>("\x2A\x34\x2D\x2A\x01\x0D\x3D\x07\x16\x04\x11\x38\x0E\x06\x1C" + 0xEBD63A92).s, cvar.visual_draw_fov);
	Sakura::Cvar::New(/*visual_draw_fov_color[0]*/XorStr<0x76, 25, 0x3D579875>("\x00\x1E\x0B\x0C\x1B\x17\x23\x19\x0C\x1E\xF7\xDE\xE4\xEC\xF2\xDA\xE5\xE8\xE4\xE6\xF8\xD0\xBC\xD0" + 0x3D579875).s, cvar.visual_draw_fov_color[0], 1.0);
	Sakura::Cvar::New(/*visual_draw_fov_color[1]*/XorStr<0x94, 25, 0xA8F4E71B>("\xE2\xFC\xE5\xE2\xF9\xF5\xC5\xFF\xEE\xFC\xE9\xC0\xC6\xCE\xD4\xFC\xC7\xCA\xCA\xC8\xDA\xF2\x9B\xF6" + 0xA8F4E71B).s, cvar.visual_draw_fov_color[1], 1.0);
	Sakura::Cvar::New(/*visual_draw_fov_color[2]*/XorStr<0xA2, 25, 0x062E5EEB>("\xD4\xCA\xD7\xD0\xC7\xCB\xF7\xCD\xD8\xCA\xDB\xF2\xC8\xC0\xC6\xEE\xD1\xDC\xD8\xDA\xC4\xEC\x8A\xE4" + 0x062E5EEB).s, cvar.visual_draw_fov_color[2], 1.0);
	Sakura::Cvar::New(/*visual_draw_fov_color[3]*/XorStr<0xF8, 25, 0x6EA9B8B4>("\x8E\x90\x89\x8E\x9D\x91\xA1\x9B\x72\x60\x75\x5C\x62\x6A\x70\x58\x6B\x66\x66\x64\x7E\x56\x3D\x52" + 0x6EA9B8B4).s, cvar.visual_draw_fov_color[3], 1.0);
	Sakura::Cvar::New(/*visual_noflash_color[0]*/XorStr<0x79, 24, 0x26F4412F>("\x0F\x13\x08\x09\x1C\x12\x20\xEE\xEE\xE4\xEF\xE5\xF6\xEE\xD8\xEB\xE6\xE6\xE4\xFE\xD6\xBE\xD2" + 0x26F4412F).s, cvar.visual_noflash_color[0]);
	Sakura::Cvar::New(/*visual_noflash_color[1]*/XorStr<0x57, 24, 0xCFB19641>("\x21\x31\x2A\x2F\x3A\x30\x02\x30\x30\x06\x0D\x03\x10\x0C\x3A\x05\x08\x04\x06\x18\x30\x5D\x30" + 0xCFB19641).s, cvar.visual_noflash_color[1]);
	Sakura::Cvar::New(/*visual_noflash_color[2]*/XorStr<0x63, 24, 0x90FBB281>("\x15\x0D\x16\x13\x06\x04\x36\x04\x04\x0A\x01\x0F\x1C\x18\x2E\x11\x1C\x18\x1A\x04\x2C\x4A\x24" + 0x90FBB281).s, cvar.visual_noflash_color[2], 1.0);
	Sakura::Cvar::New(/*visual_noflash_color[3]*/XorStr<0x37, 24, 0xD10A096A>("\x41\x51\x4A\x4F\x5A\x50\x62\x50\x50\x26\x2D\x23\x30\x2C\x1A\x25\x28\x24\x26\x38\x10\x7F\x10" + 0xD10A096A).s, cvar.visual_noflash_color[3], 0.5);
	Sakura::Cvar::New(/*visual_lines*/XorStr<0xD6, 13, 0xBEA12CAE>("\xA0\xBE\xAB\xAC\xBB\xB7\x83\xB1\xB7\xB1\x85\x92" + 0xBEA12CAE).s, cvar.visual_lines);
	Sakura::Cvar::New(/*visual_lines_thickness*/XorStr<0x77, 23, 0x9F9E8670>("\x01\x11\x0A\x0F\x1A\x10\x22\x12\x16\xEE\xE4\xF1\xDC\xF0\xED\xEF\xE4\xE3\xE7\xEF\xF8\xFF" + 0x9F9E8670).s, cvar.visual_lines_thickness, 1.0);
	Sakura::Cvar::New(/*visual_lines_color_tt[0]*/XorStr<0x86, 25, 0x2967E4AE>("\xF0\xEE\xFB\xFC\xEB\xE7\xD3\xE1\xE7\xE1\xF5\xE2\xCD\xF0\xFB\xF9\xF9\xE5\xC7\xED\xEE\xC0\xAC\xC0" + 0x2967E4AE).s, cvar.visual_lines_color_tt[0], 1.0);
	Sakura::Cvar::New(/*visual_lines_color_tt[1]*/XorStr<0xC9, 25, 0x36177FF7>("\xBF\xA3\xB8\xB9\xAC\xA2\x90\xBC\xB8\xBC\xB6\xA7\x8A\xB5\xB8\xB4\xB6\xA8\x84\xA8\xA9\x85\xEE\xBD" + 0x36177FF7).s, cvar.visual_lines_color_tt[1]);
	Sakura::Cvar::New(/*visual_lines_color_tt[2]*/XorStr<0x91, 25, 0x10351774>("\xE7\xFB\xE0\xE1\xF4\xFA\xC8\xF4\xF0\xF4\xFE\xEF\xC2\xFD\xF0\xCC\xCE\xD0\xFC\xD0\xD1\xFD\x95\xF5" + 0x10351774).s, cvar.visual_lines_color_tt[2]);
	Sakura::Cvar::New(/*visual_lines_color_tt[3]*/XorStr<0xB9, 25, 0x72C6E5EE>("\xCF\xD3\xC8\xC9\xDC\xD2\xE0\xAC\xA8\xAC\xA6\xB7\x9A\xA5\xA8\xA4\xA6\xB8\x94\xB8\xB9\x95\xFC\x8D" + 0x72C6E5EE).s, cvar.visual_lines_color_tt[3], 1.0);
	Sakura::Cvar::New(/*visual_lines_color_ct[0]*/XorStr<0xCC, 25, 0x3747A9E9>("\xBA\xA4\xBD\xBA\xB1\xBD\x8D\xBF\xBD\xBB\xB3\xA4\x87\xBA\xB5\xB7\xB3\xAF\x81\xBC\x94\xBA\xD2\xBE" + 0x3747A9E9).s, cvar.visual_lines_color_ct[0], 1.0);
	Sakura::Cvar::New(/*visual_lines_color_ct[1]*/XorStr<0xDC, 25, 0x08FC3E6C>("\xAA\xB4\xAD\xAA\x81\x8D\xBD\x8F\x8D\x8B\x83\x94\xB7\x8A\x85\x87\x83\x9F\xB1\x8C\x84\xAA\xC3\xAE" + 0x08FC3E6C).s, cvar.visual_lines_color_ct[1]);
	Sakura::Cvar::New(/*visual_lines_color_ct[2]*/XorStr<0x2F, 25, 0x9343B675>("\x59\x59\x42\x47\x52\x58\x6A\x5A\x5E\x56\x5C\x49\x64\x5F\x52\x52\x50\x32\x1E\x21\x37\x1F\x77\x1B" + 0x9343B675).s, cvar.visual_lines_color_ct[2]);
	Sakura::Cvar::New(/*visual_lines_color_ct[3]*/XorStr<0x02, 25, 0xDEE32D13>("\x74\x6A\x77\x70\x67\x6B\x57\x65\x63\x65\x69\x7E\x51\x6C\x7F\x7D\x7D\x61\x4B\x76\x62\x4C\x2B\x44" + 0xDEE32D13).s, cvar.visual_lines_color_ct[3], 1.0);
	Sakura::Cvar::New(/*visual_hud_clear*/XorStr<0xCF, 17, 0x38C73E1A>("\xB9\xB9\xA2\xA7\xB2\xB8\x8A\xBE\xA2\xBC\x86\xB9\xB7\xB9\xBC\xAC" + 0x38C73E1A).s, cvar.visual_hud_clear);
	Sakura::Cvar::New(/*visual_bullet_trace*/XorStr<0xA2, 20, 0x0A69E9A9>("\xD4\xCA\xD7\xD0\xC7\xCB\xF7\xCB\xDF\xC7\xC0\xC8\xDA\xF0\xC4\xC3\xD3\xD0\xD1" + 0x0A69E9A9).s, cvar.visual_bullet_trace);
	Sakura::Cvar::New(/*visual_bullet_trace_local*/XorStr<0x52, 26, 0x8A05692E>("\x24\x3A\x27\x20\x37\x3B\x07\x3B\x2F\x37\x30\x38\x2A\x00\x14\x13\x03\x00\x01\x3A\x0A\x08\x0B\x08\x06" + 0x8A05692E).s, cvar.visual_bullet_trace_local);
	Sakura::Cvar::New(/*visual_bullet_trace_local_thickness*/XorStr<0xA2, 36, 0x83AAA6C8>("\xD4\xCA\xD7\xD0\xC7\xCB\xF7\xCB\xDF\xC7\xC0\xC8\xDA\xF0\xC4\xC3\xD3\xD0\xD1\xEA\xDA\xD8\xDB\xD8\xD6\xE4\xC8\xD5\xD7\xDC\xAB\xAF\xA7\xB0\xB7" + 0x83AAA6C8).s, cvar.visual_bullet_trace_local_thickness, 0.4);
	Sakura::Cvar::New(/*visual_bullet_trace_local_liveness*/XorStr<0xBA, 35, 0x66444948>("\xCC\xD2\xCF\xC8\xDF\xD3\x9F\xA3\xB7\xAF\xA8\xA0\xB2\x98\xBC\xBB\xAB\xA8\xA9\x92\xA2\xA0\xB3\xB0\xBE\x8C\xB8\xBC\xA0\xB2\xB6\xBC\xA9\xA8" + 0x66444948).s, cvar.visual_bullet_trace_local_liveness, 0.3);
	Sakura::Cvar::New(/*visual_bullet_trace_local_color[0]*/XorStr<0xDA, 35, 0x49E7187F>("\xAC\xB2\xAF\xA8\xBF\xB3\xBF\x83\x97\x8F\x88\x80\x92\xB8\x9C\x9B\x8B\x88\x89\xB2\x82\x80\x93\x90\x9E\xAC\x97\x9A\x9A\x98\x8A\xA2\xCA\xA6" + 0x49E7187F).s, cvar.visual_bullet_trace_local_color[0]);
	Sakura::Cvar::New(/*visual_bullet_trace_local_color[1]*/XorStr<0x19, 35, 0x61A64353>("\x6F\x73\x68\x69\x7C\x72\x40\x42\x54\x4E\x4F\x41\x51\x79\x53\x5A\x48\x49\x4E\x73\x41\x41\x4C\x51\x5D\x6D\x50\x5B\x59\x59\x45\x63\x08\x67" + 0x61A64353).s, cvar.visual_bullet_trace_local_color[1], 1.0);
	Sakura::Cvar::New(/*visual_bullet_trace_local_color[2]*/XorStr<0x3B, 35, 0xFDB06F3E>("\x4D\x55\x4E\x4B\x5E\x2C\x1E\x20\x36\x28\x29\x23\x33\x17\x3D\x38\x2A\x2F\x28\x11\x23\x3F\x32\x33\x3F\x0B\x36\x39\x3B\x37\x2B\x01\x69\x01" + 0xFDB06F3E).s, cvar.visual_bullet_trace_local_color[2]);
	Sakura::Cvar::New(/*visual_bullet_trace_local_color[3]*/XorStr<0x2C, 35, 0x11FAAA8A>("\x5A\x44\x5D\x5A\x51\x5D\x6D\x51\x41\x59\x5A\x52\x4C\x66\x4E\x49\x5D\x5E\x5B\x60\x2C\x2E\x21\x22\x28\x1A\x25\x28\x24\x26\x38\x10\x7F\x10" + 0x11FAAA8A).s, cvar.visual_bullet_trace_local_color[3], 1.0);
	Sakura::Cvar::New(/*visual_line_of_sight*/XorStr<0x8C, 21, 0x63A8222C>("\xFA\xE4\xFD\xFA\xF1\xFD\xCD\xFF\xFD\xFB\xF3\xC8\xF7\xFF\xC5\xE8\xF5\xFA\xF6\xEB" + 0x63A8222C).s, cvar.visual_line_of_sight);
	Sakura::Cvar::New(/*visual_line_of_sight_color[0]*/XorStr<0x66, 30, 0x605089A2>("\x10\x0E\x1B\x1C\x0B\x07\x33\x01\x07\x01\x15\x2E\x1D\x15\x2B\x06\x1F\x10\x10\x0D\x25\x18\x13\x11\x11\x0D\xDB\xB1\xDF" + 0x605089A2).s, cvar.visual_line_of_sight_color[0], 1.0);
	Sakura::Cvar::New(/*visual_line_of_sight_color[1]*/XorStr<0xCA, 30, 0x54C9DE3C>("\xBC\xA2\xBF\xB8\xAF\xA3\x8F\xBD\xBB\xBD\xB1\x8A\xB9\xB1\x87\xAA\xB3\xBC\xB4\xA9\x81\xBC\x8F\x8D\x8D\x91\xBF\xD4\xBB" + 0x54C9DE3C).s, cvar.visual_line_of_sight_color[1], 1.0);
	Sakura::Cvar::New(/*visual_line_of_sight_color[2]*/XorStr<0x12, 30, 0x37738C34>("\x64\x7A\x67\x60\x77\x7B\x47\x75\x73\x75\x79\x42\x71\x79\x7F\x52\x4B\x44\x4C\x51\x79\x44\x47\x45\x45\x59\x77\x1F\x73" + 0x37738C34).s, cvar.visual_line_of_sight_color[2]);
	Sakura::Cvar::New(/*visual_line_of_sight_color[3]*/XorStr<0xD1, 30, 0x1919DEB3>("\xA7\xBB\xA0\xA1\xB4\xBA\x88\xB4\xB0\xB4\xBE\x83\xB2\xB8\x80\x93\x88\x85\x8B\x90\xBA\x85\x88\x84\x86\x98\xB0\xDF\xB0" + 0x1919DEB3).s, cvar.visual_line_of_sight_color[3], 1.0);
	Sakura::Cvar::New(/*visual_line_of_sight_distance*/XorStr<0xEA, 30, 0x13EA6A8D>("\x9C\x82\x9F\x98\x8F\x83\xAF\x9D\x9B\x9D\x91\xAA\x99\x91\xA7\x8A\x93\x9C\x94\x89\xA1\x9B\x69\x72\x76\x62\x6A\x66\x63" + 0x13EA6A8D).s, cvar.visual_line_of_sight_distance, 20.0);
	Sakura::Cvar::New(/*visual_menu_color[0]*/XorStr<0x11, 21, 0xA024E9E8>("\x67\x7B\x60\x61\x74\x7A\x48\x75\x7C\x74\x6E\x43\x7E\x71\x73\x4F\x53\x79\x13\x79" + 0xA024E9E8).s, cvar.visual_menu_color[0], 1.0);
	Sakura::Cvar::New(/*visual_menu_color[1]*/XorStr<0xDB, 21, 0x3F62115B>("\xAD\xB5\xAE\xAB\xBE\x8C\xBE\x8F\x86\x8A\x90\xB9\x84\x87\x85\x85\x99\xB7\xDC\xB3" + 0x3F62115B).s, cvar.visual_menu_color[1], 0.07);
	Sakura::Cvar::New(/*visual_menu_color[2]*/XorStr<0xDD, 21, 0x0495D522>("\xAB\xB7\xAC\x95\x80\x8E\xBC\x89\x80\x88\x92\xB7\x8A\x85\x87\x83\x9F\xB5\xDD\xAD" + 0x0495D522).s, cvar.visual_menu_color[2], 0.57);
	Sakura::Cvar::New(/*visual_menu_color[3]*/XorStr<0xD9, 21, 0x7EBEEC0B>("\xAF\xB3\xA8\xA9\xBC\xB2\x80\x8D\x84\x8C\x96\xBB\x86\x89\x8B\x87\x9B\xB1\xD8\xB1" + 0x7EBEEC0B).s, cvar.visual_menu_color[3], 1.0);
	Sakura::Cvar::New(/*visual_menu_color_header[0]*/XorStr<0x59, 28, 0xC2444B89>("\x2F\x33\x28\x29\x3C\x32\x00\x0D\x04\x0C\x16\x3B\x06\x09\x0B\x07\x1B\x35\x03\x09\x0C\x0A\x0A\x02\x2A\x42\x2E" + 0xC2444B89).s, cvar.visual_menu_color_header[0], 0.0745);
	Sakura::Cvar::New(/*visual_menu_color_header[1]*/XorStr<0xDE, 28, 0x3F282727>("\xA8\xB6\x93\x94\x83\x8F\xBB\x88\x83\x89\x9D\xB6\x89\x84\x80\x82\x9C\xB0\x98\x94\x93\x97\x91\x87\xAD\xC6\xA5" + 0x3F282727).s, cvar.visual_menu_color_header[1], 0.0862);
	Sakura::Cvar::New(/*visual_menu_color_header[2]*/XorStr<0x65, 28, 0xC14EAE81>("\x13\x0F\x14\x1D\x08\x06\x34\x01\x08\x00\x1A\x2F\x12\x1D\x1F\x1B\x07\x29\x1F\x1D\x18\x1E\x1E\x0E\x26\x4C\x22" + 0xC14EAE81).s, cvar.visual_menu_color_header[2], 0.1019);
	Sakura::Cvar::New(/*visual_menu_color_header[3]*/XorStr<0x41, 28, 0x01674FBE>("\x37\x2B\x30\x31\x24\x2A\x18\x25\x2C\x24\x3E\x13\x2E\x21\x23\x3F\x23\x0D\x3B\x31\x34\x32\x32\x2A\x02\x69\x06" + 0x01674FBE).s, cvar.visual_menu_color_header[3], 1.0);
	Sakura::Cvar::New(/*visual_menu_color_items[0]*/XorStr<0x9B, 27, 0x818D3B2F>("\xED\xF5\xEE\xEB\xFE\xCC\xFE\xCF\xC6\xCA\xD0\xF9\xC4\xC7\xC5\xC5\xD9\xF3\xC4\xDA\xCA\xDD\xC2\xE9\x83\xE9" + 0x818D3B2F).s, cvar.visual_menu_color_items[0], 0.0980);
	Sakura::Cvar::New(/*visual_menu_color_items[1]*/XorStr<0x1A, 27, 0x3F252882>("\x6C\x72\x6F\x68\x7F\x73\x7F\x4C\x47\x4D\x51\x7A\x45\x48\x44\x46\x58\x74\x45\x59\x4B\x42\x43\x6A\x03\x6E" + 0x3F252882).s, cvar.visual_menu_color_items[1], 0.1176);
	Sakura::Cvar::New(/*visual_menu_color_items[2]*/XorStr<0xA2, 27, 0xC3043CAA>("\xD4\xCA\xD7\xD0\xC7\xCB\xF7\xC4\xCF\xC5\xD9\xF2\xCD\xC0\xDC\xDE\xC0\xEC\xDD\xC1\xD3\xDA\xCB\xE2\x88\xE6" + 0xC3043CAA).s, cvar.visual_menu_color_items[2], 0.1372);
	Sakura::Cvar::New(/*visual_menu_color_items[3]*/XorStr<0x96, 27, 0x0C14E302>("\xE0\xFE\xEB\xEC\xFB\xF7\xC3\xF0\xFB\xF1\xD5\xFE\xC1\xCC\xC8\xCA\xD4\xF8\xC1\xDD\xCF\xC6\xDF\xF6\x9D\xF2" + 0x0C14E302).s, cvar.visual_menu_color_items[3], 1.0);
	Sakura::Cvar::New(/*visual_menu_color_footer[0]*/XorStr<0x1D, 28, 0x70594D85>("\x6B\x77\x6C\x55\x40\x4E\x7C\x49\x40\x48\x52\x77\x4A\x45\x47\x43\x5F\x71\x49\x5F\x5E\x46\x56\x46\x6E\x06\x6A" + 0x70594D85).s, cvar.visual_menu_color_footer[0], 0.1764);
	Sakura::Cvar::New(/*visual_menu_color_footer[1]*/XorStr<0x74, 28, 0xB2755F42>("\x02\x1C\x05\x02\x19\x15\x25\x16\x19\x13\x0B\x20\xE3\xEE\xEE\xEC\xF6\xDA\xE0\xE8\xE7\xFD\xEF\xF9\xD7\xBC\xD3" + 0xB2755F42).s, cvar.visual_menu_color_footer[1], 0.1960);
	Sakura::Cvar::New(/*visual_menu_color_footer[2]*/XorStr<0x33, 28, 0x3682C6BD>("\x45\x5D\x46\x43\x56\x54\x66\x57\x5E\x52\x48\x61\x5C\x2F\x2D\x2D\x31\x1B\x23\x29\x28\x3C\x2C\x38\x10\x7E\x10" + 0x3682C6BD).s, cvar.visual_menu_color_footer[2], 0.2156);
	Sakura::Cvar::New(/*visual_menu_color_footer[3]*/XorStr<0x66, 28, 0x684CA546>("\x10\x0E\x1B\x1C\x0B\x07\x33\x00\x0B\x01\x05\x2E\x11\x1C\x18\x1A\x04\x28\x1E\x16\x15\x0F\x19\x0F\x25\x4C\xDD" + 0x684CA546).s, cvar.visual_menu_color_footer[3], 1.0);
	Sakura::Cvar::New(/*visual_menu_color_widgets[0]*/XorStr<0xA7, 29, 0x27685D40>("\xD1\xC1\xDA\xDF\xCA\xC0\xF2\xC3\xCA\xDE\xC4\xED\xD0\xDB\xD9\xD9\xC5\xE7\xCE\xD3\xDF\xDB\xD8\xCA\xCC\x9B\xF1\x9F" + 0x27685D40).s, cvar.visual_menu_color_widgets[0], 0.1176);
	Sakura::Cvar::New(/*visual_menu_color_widgets[1]*/XorStr<0xF1, 29, 0xF6545FB8>("\x87\x9B\x80\x81\x94\x9A\xA8\x95\x9C\x94\x8E\xA3\x9E\x91\x93\x6F\x73\x5D\x74\x6D\x61\x61\x62\x7C\x7A\x51\x3A\x51" + 0xF6545FB8).s, cvar.visual_menu_color_widgets[1], 0.1372);
	Sakura::Cvar::New(/*visual_menu_color_widgets[2]*/XorStr<0x04, 29, 0x2D4BD966>("\x72\x6C\x75\x72\x69\x65\x55\x66\x69\x63\x7B\x50\x73\x7E\x7E\x7C\x66\x4A\x61\x7E\x7C\x7E\x7F\x6F\x6F\x46\x2C\x42" + 0x2D4BD966).s, cvar.visual_menu_color_widgets[2], 0.1568);
	Sakura::Cvar::New(/*visual_menu_color_widgets[3]*/XorStr<0x66, 29, 0x1767FB78>("\x10\x0E\x1B\x1C\x0B\x07\x33\x00\x0B\x01\x05\x2E\x11\x1C\x18\x1A\x04\x28\x0F\x10\x1E\x1C\x19\x09\x0D\x24\xB3\xDC" + 0x1767FB78).s, cvar.visual_menu_color_widgets[3], 1.0);
	Sakura::Cvar::New(/*visual_menu_color_tab_selected[0]*/XorStr<0xB4, 34, 0x0626E1C1>("\xC2\xDC\xC5\xC2\xD9\xD5\xE5\xD6\xD9\xD3\xCB\xE0\xA3\xAE\xAE\xAC\xB6\x9A\xB2\xA6\xAA\x96\xB9\xAE\xA0\xA8\xAD\xBB\xB5\xB5\x89\xE3\x89" + 0x0626E1C1).s, cvar.visual_menu_color_tab_selected[0], 0.0980);
	Sakura::Cvar::New(/*visual_menu_color_tab_selected[1]*/XorStr<0xB7, 34, 0xF609B3EA>("\xC1\xD1\xCA\xCF\xDA\xD0\xE2\xD3\xDA\xAE\xB4\x9D\xA0\xAB\xA9\xA9\xB5\x97\xBD\xAB\xA9\x93\xBE\xAB\xA3\xB5\xB2\xA6\xB6\xB0\x8E\xE7\x8A" + 0xF609B3EA).s, cvar.visual_menu_color_tab_selected[1], 0.1176);
	Sakura::Cvar::New(/*visual_menu_color_tab_selected[2]*/XorStr<0xDA, 34, 0x9F75DF9C>("\xAC\xB2\xAF\xA8\xBF\xB3\xBF\x8C\x87\x8D\x91\xBA\x85\x88\x84\x86\x98\xB4\x98\x8C\x8C\xB0\x83\x94\x9E\x96\x97\x81\x93\x93\xA3\xCB\xA7" + 0x9F75DF9C).s, cvar.visual_menu_color_tab_selected[2], 0.1372);
	Sakura::Cvar::New(/*visual_menu_color_tab_selected[3]*/XorStr<0x55, 34, 0x994E2A95>("\x23\x3F\x24\x2D\x38\x36\x04\x31\x38\x30\x2A\x3F\x02\x0D\x0F\x0B\x17\x39\x13\x09\x0B\x35\x18\x09\x01\x0B\x0C\x04\x14\x16\x28\x47\x28" + 0x994E2A95).s, cvar.visual_menu_color_tab_selected[3], 1.0);
	Sakura::Cvar::New(/*visual_menu_color_subtab_selected[0]*/XorStr<0xCB, 37, 0x50E1738C>("\xBD\xA5\xBE\xBB\xAE\xBC\x8E\xBF\xB6\xBA\xA0\x89\xB4\xB7\xB5\xB5\xA9\x83\xAE\xAB\xBD\x94\x80\x80\xBC\x97\x80\x8A\x82\x8B\x9D\x8F\x8F\xB7\xDD\xB3" + 0x50E1738C).s, cvar.visual_menu_color_subtab_selected[0], 0.1176);
	Sakura::Cvar::New(/*visual_menu_color_subtab_selected[1]*/XorStr<0x8D, 37, 0x7A0D5FD3>("\xFB\xE7\xFC\xE5\xF0\xFE\xCC\xF9\xF0\xF8\xE2\xC7\xFA\xF5\xF7\xF3\xEF\xC1\xEC\xD5\xC3\xD6\xC2\xC6\xFA\xD5\xC2\xC4\xCC\xC9\xDF\xC9\xC9\xF5\x9E\xED" + 0x7A0D5FD3).s, cvar.visual_menu_color_subtab_selected[1], 0.1372);
	Sakura::Cvar::New(/*visual_menu_color_subtab_selected[2]*/XorStr<0x59, 37, 0x7C08453E>("\x2F\x33\x28\x29\x3C\x32\x00\x0D\x04\x0C\x16\x3B\x06\x09\x0B\x07\x1B\x35\x18\x19\x0F\x1A\x0E\x12\x2E\x01\x16\x18\x10\x15\x03\x1D\x1D\x21\x49\x21" + 0x7C08453E).s, cvar.visual_menu_color_subtab_selected[2], 0.1568);
	Sakura::Cvar::New(/*visual_menu_color_subtab_selected[3]*/XorStr<0xA3, 37, 0x5FDAC600>("\xD5\xCD\xD6\xD3\xC6\xC4\xF6\xC7\xCE\xC2\xD8\xF1\xCC\xDF\xDD\xDD\xC1\xEB\xC6\xC3\xD5\xCC\xD8\xD8\xE4\xCF\xD8\xD2\xDA\xA3\xB5\xA7\xA7\x9F\xF6\x9B" + 0x5FDAC600).s, cvar.visual_menu_color_subtab_selected[3], 1.0);
	Sakura::Cvar::New(/*visual_menu_color_logo[0]*/XorStr<0x69, 26, 0xA464B2A5>("\x1F\x03\x18\x19\x0C\x02\x30\x1D\x14\x1C\x06\x2B\x16\x19\x1B\x17\x0B\x25\x17\x13\x1A\x11\x24\xB0\xDC" + 0xA464B2A5).s, cvar.visual_menu_color_logo[0], 1.f);
	Sakura::Cvar::New(/*visual_menu_color_logo[1]*/XorStr<0x5D, 26, 0x1DB9AB71>("\x2B\x37\x2C\x15\x00\x0E\x3C\x09\x00\x08\x12\x37\x0A\x05\x07\x03\x1F\x31\x03\x1F\x16\x1D\x28\x45\x28" + 0x1DB9AB71).s, cvar.visual_menu_color_logo[1], 0.0784f);
	Sakura::Cvar::New(/*visual_menu_color_logo[2]*/XorStr<0x18, 26, 0x7206A054>("\x6E\x70\x69\x6E\x7D\x71\x41\x72\x45\x4F\x57\x7C\x47\x4A\x4A\x48\x5A\x76\x46\x44\x4B\x42\x75\x1D\x6D" + 0x7206A054).s, cvar.visual_menu_color_logo[2], 0.5764f);
	Sakura::Cvar::New(/*visual_menu_color_logo[3]*/XorStr<0xE4, 26, 0x20E53D06>("\x92\x8C\x95\x92\x89\x85\xB5\x86\x89\x83\x9B\xB0\x93\x9E\x9E\x9C\x86\xAA\x9A\x98\x9F\x96\xA1\xC8\xA1" + 0x20E53D06).s, cvar.visual_menu_color_logo[3], 1.0);
	Sakura::Cvar::New(/*visual_menu_color_footer_text[0]*/XorStr<0xFF, 33, 0xFFA42A84>("\x89\x69\x72\x77\x62\x68\x5A\x6B\x62\x66\x7C\x55\x68\x63\x61\x61\x7D\x4F\x77\x7D\x7C\x60\x70\x64\x48\x6C\x7C\x62\x6F\x47\x2D\x43" + 0xFFA42A84).s, cvar.visual_menu_color_footer_text[0], 0.9803f);
	Sakura::Cvar::New(/*visual_menu_color_footer_text[1]*/XorStr<0x93, 33, 0x15C4F971>("\xE5\xFD\xE6\xE3\xF6\xF4\xC6\xF7\xFE\xF2\xE8\xC1\xFC\xCF\xCD\xCD\xD1\xFB\xC3\xC9\xC8\xDC\xCC\xD8\xF4\xD8\xC8\xD6\xDB\xEB\x80\xEF" + 0x15C4F971).s, cvar.visual_menu_color_footer_text[1], 0.9803f);
	Sakura::Cvar::New(/*visual_menu_color_footer_text[2]*/XorStr<0x78, 33, 0x932BA122>("\x0E\x10\x09\x0E\x1D\x11\x21\x12\xE5\xEF\xF7\xDC\xE7\xEA\xEA\xE8\xFA\xD6\xEC\xE4\xE3\xF9\xEB\xFD\xCF\xE5\xF7\xEB\xE0\xCE\xA4\xCA" + 0x932BA122).s, cvar.visual_menu_color_footer_text[2], 0.9803f);
	Sakura::Cvar::New(/*visual_menu_color_footer_text[3]*/XorStr<0xE2, 33, 0x2717B7BB>("\x94\x8A\x97\x90\x87\x8B\xB7\x84\x8F\x85\x99\xB2\x8D\x80\x9C\x9E\x80\xAC\x92\x9A\x99\x83\x9D\x8B\xA5\x8F\x99\x85\x8A\xA4\x33\x5C" + 0x2717B7BB).s, cvar.visual_menu_color_footer_text[3], 1.0);
	Sakura::Cvar::New(/*visual_menu_raining*/XorStr<0xC9, 20, 0x95863EDC>("\xBF\xA3\xB8\xB9\xAC\xA2\x90\xBD\xB4\xBC\xA6\x8B\xA7\xB7\xBE\xB6\xB0\xB4\xBC" + 0x95863EDC).s, cvar.visual_menu_raining);
	Sakura::Cvar::New(/*visual_menu_raining_count*/XorStr<0x56, 26, 0xC2D0CEBC>("\x20\x3E\x2B\x2C\x3B\x37\x03\x30\x3B\x31\x15\x3E\x10\x02\x0D\x0B\x0F\x09\x0F\x36\x09\x04\x19\x03\x1A" + 0xC2D0CEBC).s, cvar.visual_menu_raining_count, 100.0);
	Sakura::Cvar::New(/*visual_menu_raining_type*/XorStr<0x5F, 25, 0xF9D4970C>("\x29\x09\x12\x17\x02\x08\x3A\x0B\x02\x06\x1C\x35\x19\x0D\x04\x00\x06\x1E\x16\x2D\x07\x0D\x05\x13" + 0xF9D4970C).s, cvar.visual_menu_raining_type);
	Sakura::Cvar::New(/*visual_menu_raining_speed_multipler*/XorStr<0xD4, 36, 0xC62CAAF6>("\xA2\xBC\xA5\xA2\xB9\xB5\x85\xB6\xB9\xB3\xAB\x80\x92\x80\x8B\x8D\x8D\x8B\x81\xB8\x9B\x99\x8F\x8E\x88\xB2\x83\x9A\x9C\x85\x9B\x83\x98\x90\x84" + 0xC62CAAF6).s, cvar.visual_menu_raining_speed_multipler, 1.0);
	Sakura::Cvar::New(/*visual_menu_bg_opacity*/XorStr<0x75, 23, 0x9A118204>("\x03\x1F\x04\x0D\x18\x16\x24\x11\x18\x10\x0A\xDF\xE3\xE5\xDC\xEB\xF5\xE7\xE4\xE1\xFD\xF3" + 0x9A118204).s, cvar.visual_menu_bg_opacity, 0.1);
	Sakura::Cvar::New(/*visual_menu_combo_bg_color[0]*/XorStr<0x92, 30, 0x3BD98107>("\xE4\xFA\xE7\xE0\xF7\xFB\xC7\xF4\xFF\xF5\xE9\xC2\xFD\xF0\xCD\xC3\xCD\xFC\xC6\xC2\xF9\xC4\xC7\xC5\xC5\xD9\xF7\x9D\xF3" + 0x3BD98107).s, cvar.visual_menu_combo_bg_color[0], 0.4705);
	Sakura::Cvar::New(/*visual_menu_combo_bg_color[1]*/XorStr<0x83, 30, 0x47DE398C>("\xF5\xED\xF6\xF3\xE6\xE4\xD6\xE7\xEE\xE2\xF8\xD1\xEC\xFF\xFC\xF0\xFC\xCB\xF7\xF1\xC8\xFB\xF6\xF6\xF4\xEE\xC6\xAF\xC2" + 0x47DE398C).s, cvar.visual_menu_combo_bg_color[1], 0.4705);
	Sakura::Cvar::New(/*visual_menu_combo_bg_color[2]*/XorStr<0x40, 30, 0x9B800D2D>("\x36\x28\x31\x36\x25\x29\x19\x2A\x2D\x27\x3F\x14\x2F\x22\x23\x2D\x3F\x0E\x30\x34\x0B\x36\x39\x3B\x37\x2B\x01\x69\x01" + 0x9B800D2D).s, cvar.visual_menu_combo_bg_color[2], 0.4705);
	Sakura::Cvar::New(/*visual_menu_combo_bg_color[3]*/XorStr<0x4B, 30, 0x27DC8F78>("\x3D\x25\x3E\x3B\x2E\x3C\x0E\x3F\x36\x3A\x20\x09\x34\x37\x34\x38\x34\x03\x3F\x39\x00\x03\x0E\x0E\x0C\x16\x3E\x55\x3A" + 0x27DC8F78).s, cvar.visual_menu_combo_bg_color[3], 1.0);
	Sakura::Cvar::New(/*visual_menu_slider_bg_color[0]*/XorStr<0x56, 31, 0xB8249C13>("\x20\x3E\x2B\x2C\x3B\x37\x03\x30\x3B\x31\x15\x3E\x11\x0F\x0D\x01\x03\x15\x37\x0B\x0D\x34\x0F\x02\x02\x00\x02\x2A\x42\x2E" + 0xB8249C13).s, cvar.visual_menu_slider_bg_color[0], 0.0745);
	Sakura::Cvar::New(/*visual_menu_slider_bg_color[1]*/XorStr<0x54, 31, 0x8A8C4088>("\x22\x3C\x25\x22\x39\x35\x05\x36\x39\x33\x2B\x00\x13\x0D\x0B\x07\x01\x17\x39\x05\x0F\x36\x09\x04\x00\x02\x1C\x34\x41\x2C" + 0x8A8C4088).s, cvar.visual_menu_slider_bg_color[1], 0.0862);
	Sakura::Cvar::New(/*visual_menu_slider_bg_color[2]*/XorStr<0xCF, 31, 0xD2BD7ADE>("\xB9\xB9\xA2\xA7\xB2\xB8\x8A\xBB\xB2\xB6\xAC\x85\xA8\xB0\xB4\xBA\xBA\x92\xBE\x80\x84\xBB\x86\x89\x8B\x87\x9B\xB1\xD9\xB1" + 0xD2BD7ADE).s, cvar.visual_menu_slider_bg_color[2], 0.1019);
	Sakura::Cvar::New(/*visual_menu_slider_bg_color[3]*/XorStr<0x95, 31, 0x3B499453>("\xE3\xFF\xE4\xED\xF8\xF6\xC4\xF1\xF8\xF0\xEA\xFF\xD2\xCE\xCA\xC0\xC0\xD4\xF8\xCA\xCE\xF5\xC8\xC3\xC1\xC1\xDD\xEB\x82\xEF" + 0x3B499453).s, cvar.visual_menu_slider_bg_color[3], 1.0);
	Sakura::Cvar::New(/*visual_fog*/XorStr<0xB6, 11, 0xEF59930F>("\xC0\xDE\xCB\xCC\xDB\xD7\xE3\xDB\xD1\xD8" + 0xEF59930F).s, cvar.visual_fog);
	Sakura::Cvar::New(/*visual_fog_density*/XorStr<0x9B, 19, 0x3BA546F3>("\xED\xF5\xEE\xEB\xFE\xCC\xFE\xC4\xCC\xC3\xFA\xC2\xC2\xC6\xDA\xC3\xDF\xD5" + 0x3BA546F3).s, cvar.visual_fog_density, 5.0);
	Sakura::Cvar::New(/*visual_fog_color[0]*/XorStr<0x88, 20, 0x7AAFBF2F>("\xFE\xE0\xF9\xFE\xED\xE1\xD1\xE9\xFF\xF6\xCD\xF0\xFB\xF9\xF9\xE5\xC3\xA9\xC7" + 0x7AAFBF2F).s, cvar.visual_fog_color[0], 1.0);
	Sakura::Cvar::New(/*visual_fog_color[1]*/XorStr<0x60, 20, 0x6594F431>("\x16\x08\x11\x16\x05\x09\x39\x01\x07\x0E\x35\x08\x03\x01\x01\x1D\x2B\x40\x2F" + 0x6594F431).s, cvar.visual_fog_color[1], 1.0);
	Sakura::Cvar::New(/*visual_fog_color[2]*/XorStr<0x6B, 20, 0xE11EE6E6>("\x1D\x05\x1E\x1B\x0E\x1C\x2E\x14\x1C\x13\x2A\x15\x18\x14\x16\x08\x20\x4E\x20" + 0xE11EE6E6).s, cvar.visual_fog_color[2], 1.0);
	Sakura::Cvar::New(/*visual_fog_color[3]*/XorStr<0x4A, 20, 0x253B7A55>("\x3C\x22\x3F\x38\x2F\x23\x0F\x37\x3D\x34\x0B\x36\x39\x3B\x37\x2B\x01\x68\x01" + 0x253B7A55).s, cvar.visual_fog_color[3], 1.0);
	Sakura::Cvar::New(/*visual_nosmoke*/XorStr<0x17, 15, 0xD28A4851>("\x61\x71\x6A\x6F\x7A\x70\x42\x70\x70\x53\x4C\x4D\x48\x41" + 0xD28A4851).s, cvar.visual_nosmoke);
	Sakura::Cvar::New(/*visual_box_world_color[0]*/XorStr<0xF7, 26, 0xF0BC6781>("\x81\x91\x8A\x8F\x9A\x90\xA2\x9C\x90\x78\x5E\x75\x6C\x76\x69\x62\x58\x6B\x66\x66\x64\x7E\x56\x3E\x52" + 0xF0BC6781).s, cvar.visual_box_world_color[0], 1.0);
	Sakura::Cvar::New(/*visual_box_world_color[1]*/XorStr<0x8A, 26, 0x13D913D6>("\xFC\xE2\xFF\xF8\xEF\xE3\xCF\xF3\xFD\xEB\xCB\xE2\xF9\xE5\xF4\xFD\xC5\xF8\xF3\xF1\xF1\xED\xFB\x90\xFF" + 0x13D913D6).s, cvar.visual_box_world_color[1], 1.0);
	Sakura::Cvar::New(/*visual_box_world_color[2]*/XorStr<0xE5, 26, 0xB6E5A2E6>("\x93\x8F\x94\x9D\x88\x86\xB4\x8E\x82\x96\xB0\x87\x9E\x80\x9F\x90\xAA\x95\x98\x94\x96\x88\xA0\xCE\xA0" + 0xB6E5A2E6).s, cvar.visual_box_world_color[2], 1.0);
	Sakura::Cvar::New(/*visual_box_world_color[3]*/XorStr<0x20, 26, 0x12A3D497>("\x56\x48\x51\x56\x45\x49\x79\x45\x47\x51\x75\x5C\x43\x5F\x42\x4B\x6F\x52\x5D\x5F\x5B\x47\x6D\x04\x65" + 0x12A3D497).s, cvar.visual_box_world_color[3], 1.0);
	Sakura::Cvar::New(/*visual_box_world_type*/XorStr<0xDE, 22, 0x7764AC0F>("\xA8\xB6\x93\x94\x83\x8F\xBB\x87\x89\x9F\xB7\x9E\x85\x99\x80\x89\xB1\x9B\x89\x81\x97" + 0x7764AC0F).s, cvar.visual_box_world_type);
	Sakura::Cvar::New(/*visual_box_world_fill*/XorStr<0xC0, 22, 0x240C56D4>("\xB6\xA8\xB1\xB6\xA5\xA9\x99\xA5\xA7\xB1\x95\xBC\xA3\xBF\xA2\xAB\x8F\xB7\xBB\xBF\xB8" + 0x240C56D4).s, cvar.visual_box_world_fill);
	Sakura::Cvar::New(/*visual_player_glow*/XorStr<0xE1, 19, 0x04E8100D>("\x97\x8B\x90\x91\x84\x8A\xB8\x98\x85\x8B\x92\x89\x9F\xB1\x88\x9C\x9E\x85" + 0x04E8100D).s, cvar.visual_player_glow);
	Sakura::Cvar::New(/*visual_player_glow_thickness*/XorStr<0xAB, 29, 0x55320406>("\xDD\xC5\xDE\xDB\xCE\xDC\xEE\xC2\xDF\xD5\xCC\xD3\xC5\xE7\xDE\xD6\xD4\xCB\xE2\xCA\xD7\xA9\xA2\xA9\xAD\xA1\xB6\xB5" + 0x55320406).s, cvar.visual_player_glow_thickness, 12.0);
	Sakura::Cvar::New(/*visual_player_glow_color_ct[0]*/XorStr<0xA1, 31, 0xB167A50C>("\xD7\xCB\xD0\xD1\xC4\xCA\xF8\xD8\xC5\xCB\xD2\xC9\xDF\xF1\xC8\xDC\xDE\xC5\xEC\xD7\xDA\xDA\xD8\xCA\xE6\xD9\xCF\xE7\x8D\xE3" + 0xB167A50C).s, cvar.visual_player_glow_color_ct[0]);
	Sakura::Cvar::New(/*visual_player_glow_color_ct[1]*/XorStr<0x1F, 31, 0x22841834>("\x69\x49\x52\x57\x42\x48\x7A\x56\x4B\x49\x50\x4F\x59\x73\x4A\x42\x40\x47\x6E\x51\x5C\x58\x5A\x44\x68\x5B\x4D\x61\x0A\x61" + 0x22841834).s, cvar.visual_player_glow_color_ct[1]);
	Sakura::Cvar::New(/*visual_player_glow_color_ct[2]*/XorStr<0xF3, 31, 0xCEA8EDE2>("\x85\x9D\x86\x83\x96\x94\xA6\x8A\x97\x9D\x84\x9B\x8D\x5F\x66\x6E\x6C\x73\x5A\x65\x68\x64\x66\x78\x54\x6F\x79\x55\x3D\x4D" + 0xCEA8EDE2).s, cvar.visual_player_glow_color_ct[2], 1.0);
	Sakura::Cvar::New(/*visual_player_glow_color_ct[3]*/XorStr<0x7F, 31, 0x86E155E4>("\x09\xE9\xF2\xF7\xE2\xE8\xDA\xF6\xEB\xE9\xF0\xEF\xF9\xD3\xEA\xE2\xE0\xE7\xCE\xF1\xFC\xF8\xFA\xE4\xC8\xFB\xED\xC1\xA8\xC1" + 0x86E155E4).s, cvar.visual_player_glow_color_ct[3], 1.0);
	Sakura::Cvar::New(/*visual_player_glow_color_tt[0]*/XorStr<0x3A, 31, 0x04139D6E>("\x4C\x52\x4F\x48\x5F\x53\x1F\x31\x2E\x22\x3D\x20\x34\x18\x2F\x25\x25\x3C\x13\x2E\x21\x23\x3F\x23\x0D\x27\x20\x0E\x66\x0A" + 0x04139D6E).s, cvar.visual_player_glow_color_tt[0], 1.0);
	Sakura::Cvar::New(/*visual_player_glow_color_tt[1]*/XorStr<0xAB, 31, 0x4F8FBA1D>("\xDD\xC5\xDE\xDB\xCE\xDC\xEE\xC2\xDF\xD5\xCC\xD3\xC5\xE7\xDE\xD6\xD4\xCB\xE2\xDD\xD0\xAC\xAE\xB0\x9C\xB0\xB1\x9D\xF6\x95" + 0x4F8FBA1D).s, cvar.visual_player_glow_color_tt[1]);
	Sakura::Cvar::New(/*visual_player_glow_color_tt[2]*/XorStr<0xF7, 31, 0x7142512E>("\x81\x91\x8A\x8F\x9A\x90\xA2\x8E\x93\x61\x78\x67\x71\x5B\x62\x6A\x68\x7F\x56\x69\x64\x60\x62\x7C\x50\x64\x65\x49\x21\x49" + 0x7142512E).s, cvar.visual_player_glow_color_tt[2]);
	Sakura::Cvar::New(/*visual_player_glow_color_tt[3]*/XorStr<0xD0, 31, 0xEAE5036A>("\xA6\xB8\xA1\xA6\xB5\xB9\x89\xA7\xB4\xB8\xA3\xBE\xAE\x82\xB9\xB3\x8F\x96\xBD\x80\x8B\x89\x89\x95\xB7\x9D\x9E\xB0\xDF\xB0" + 0xEAE5036A).s, cvar.visual_player_glow_color_tt[3], 1.0);
	Sakura::Cvar::New(/*visual_viewmodel_glow*/XorStr<0x50, 22, 0x90235EA1>("\x26\x38\x21\x26\x35\x39\x09\x21\x31\x3C\x2D\x36\x33\x39\x3B\x33\x3F\x06\x0E\x0C\x13" + 0x90235EA1).s, cvar.visual_viewmodel_glow);
	Sakura::Cvar::New(/*visual_viewmodel_glow_thickness*/XorStr<0x33, 32, 0xBCB0D0D6>("\x45\x5D\x46\x43\x56\x54\x66\x4C\x52\x59\x4A\x53\x50\x24\x24\x2E\x1C\x23\x29\x29\x30\x17\x3D\x22\x22\x2F\x26\x20\x2A\x23\x22" + 0xBCB0D0D6).s, cvar.visual_viewmodel_glow_thickness, 1.0);
	Sakura::Cvar::New(/*visual_viewmodel_glow_color[0]*/XorStr<0xD3, 31, 0x20E98B8B>("\xA5\xBD\xA6\xA3\xB6\xB4\x86\xAC\xB2\xB9\xAA\xB3\xB0\x84\x84\x8E\xBC\x83\x89\x89\x90\xB7\x8A\x85\x87\x83\x9F\xB5\xDF\xAD" + 0x20E98B8B).s, cvar.visual_viewmodel_glow_color[0], 1.0);
	Sakura::Cvar::New(/*visual_viewmodel_glow_color[1]*/XorStr<0x5E, 31, 0x2BC705BE>("\x28\x36\x13\x14\x03\x0F\x3B\x13\x0F\x02\x1F\x04\x05\x0F\x09\x01\x31\x08\x1C\x1E\x05\x2C\x17\x1A\x1A\x18\x0A\x22\x4B\x26" + 0x2BC705BE).s, cvar.visual_viewmodel_glow_color[1], 1.0);
	Sakura::Cvar::New(/*visual_viewmodel_glow_color[2]*/XorStr<0xBF, 31, 0x37EE55D6>("\xC9\xA9\xB2\xB7\xA2\xA8\x9A\xB0\xAE\xAD\xBE\xA7\xA4\xA8\xA8\xA2\x90\xB7\xBD\xBD\xA4\x8B\xB6\xB9\xBB\xB7\xAB\x81\xE9\x81" + 0x37EE55D6).s, cvar.visual_viewmodel_glow_color[2], 1.0);
	Sakura::Cvar::New(/*visual_viewmodel_glow_color[3]*/XorStr<0xDD, 31, 0x87799F3E>("\xAB\xB7\xAC\x95\x80\x8E\xBC\x92\x8C\x83\x90\x85\x86\x8E\x8E\x80\xB2\x89\x83\x9F\x86\xAD\x90\x9B\x99\x99\x85\xA3\xCA\xA7" + 0x87799F3E).s, cvar.visual_viewmodel_glow_color[3], 1.0);
	Sakura::Cvar::New(/*visual_dont_render_players*/XorStr<0xCF, 27, 0x9E74C0E9>("\xB9\xB9\xA2\xA7\xB2\xB8\x8A\xB2\xB8\xB6\xAD\x85\xA9\xB9\xB3\xBA\xBA\x92\xBE\x92\x8F\x85\x9C\x83\x95\x9B" + 0x9E74C0E9).s, cvar.visual_dont_render_players);
	Sakura::Cvar::New(/*visual_remove_scope*/XorStr<0x12, 20, 0xC8B9E988>("\x64\x7A\x67\x60\x77\x7B\x47\x6B\x7F\x76\x73\x6B\x7B\x40\x53\x42\x4D\x53\x41" + 0xC8B9E988).s, cvar.visual_remove_scope);
	Sakura::Cvar::New(/*visual_fakelag_history_local*/XorStr<0x93, 29, 0x8B942DF7>("\xE5\xFD\xE6\xE3\xF6\xF4\xC6\xFC\xFA\xF7\xF8\xF2\xFE\xC7\xFE\xCA\xCA\xD7\xD1\xC9\xD5\xD1\xF6\xC6\xC4\xCF\xCC\xC2" + 0x8B942DF7).s, cvar.visual_fakelag_history_local);
	Sakura::Cvar::New(/*visual_fakelag_history_local_light*/XorStr<0x00, 35, 0xDF93C81B>("\x76\x68\x71\x76\x65\x69\x59\x61\x69\x62\x6F\x67\x6D\x6A\x51\x67\x79\x62\x66\x7C\x66\x6C\x49\x7B\x77\x7A\x7B\x77\x43\x71\x77\x78\x48\x55" + 0xDF93C81B).s, cvar.visual_fakelag_history_local_light);
	Sakura::Cvar::New(/*visual_fakelag_history_local_chams*/XorStr<0x91, 35, 0xD95A4D1C>("\xE7\xFB\xE0\xE1\xF4\xFA\xC8\xFE\xF8\xF1\xFE\xF0\xFC\xF9\xC0\xC8\xC8\xD1\xD7\xCB\xD7\xDF\xF8\xC4\xC6\xC9\xCA\xC0\xF2\xCD\xC7\xD1\xDC\xC1" + 0xD95A4D1C).s, cvar.visual_fakelag_history_local_chams);
	Sakura::Cvar::New(/*visual_fakelag_history_local_wireframe*/XorStr<0x70, 39, 0x7A98B0B8>("\x06\x18\x01\x06\x15\x19\x29\x11\x19\x12\x1F\x17\x1D\x1A\x21\x17\xE9\xF2\xF6\xEC\xF6\xFC\xD9\xEB\xE7\xEA\xEB\xE7\xD3\xFA\xE7\xFD\xF5\xF7\xE0\xF2\xF9\xF0" + 0x7A98B0B8).s, cvar.visual_fakelag_history_local_wireframe);
	Sakura::Cvar::New(/*visual_fakelag_history_local_wireframe_mode*/XorStr<0xD7, 44, 0x1546C1A3>("\xA1\xB1\xAA\xAF\xBA\xB0\x82\xB8\xBE\x8B\x84\x8E\x82\x83\xBA\x8E\x8E\x9B\x9D\x85\x99\x95\xB2\x82\x80\x93\x90\x9E\xAC\x83\x9C\x84\x92\x9E\x8B\x9B\x96\x99\xA2\x93\x90\x64\x64" + 0x1546C1A3).s, cvar.visual_fakelag_history_local_wireframe_mode);
	Sakura::Cvar::New(/*visual_fakelag_history_local_light_color[0]*/XorStr<0x30, 44, 0xD676FADA>("\x46\x58\x41\x46\x55\x59\x69\x51\x59\x52\x5F\x57\x5D\x5A\x61\x57\x29\x32\x36\x2C\x36\x3C\x19\x2B\x27\x2A\x2B\x27\x13\x21\x27\x28\x38\x25\x0D\x30\x3B\x39\x39\x25\x03\x69\x07" + 0xD676FADA).s, cvar.visual_fakelag_history_local_light_color[0]);
	Sakura::Cvar::New(/*visual_fakelag_history_local_light_color[1]*/XorStr<0x90, 44, 0xB2E07346>("\xE6\xF8\xE1\xE6\xF5\xF9\xC9\xF1\xF9\xF2\xFF\xF7\xFD\xFA\xC1\xF7\xC9\xD2\xD6\xCC\xD6\xDC\xF9\xCB\xC7\xCA\xCB\xC7\xF3\xC1\xC7\xC8\xD8\xC5\xED\xD0\xDB\xD9\xD9\xC5\xE3\x88\xE7" + 0xB2E07346).s, cvar.visual_fakelag_history_local_light_color[1], 1.0);
	Sakura::Cvar::New(/*visual_fakelag_history_local_light_color[2]*/XorStr<0x43, 44, 0x072B1F82>("\x35\x2D\x36\x33\x26\x24\x16\x2C\x2A\x27\x28\x22\x2E\x37\x0E\x3A\x3A\x27\x21\x39\x25\x21\x06\x36\x34\x3F\x3C\x32\x00\x0C\x08\x05\x0B\x10\x3A\x05\x08\x04\x06\x18\x30\x5E\x30" + 0x072B1F82).s, cvar.visual_fakelag_history_local_light_color[2]);
	Sakura::Cvar::New(/*visual_fakelag_history_local_light_color[3]*/XorStr<0xB3, 44, 0xD61AE67E>("\xC5\xDD\xC6\xC3\xD6\xD4\xE6\xDC\xDA\xD7\xD8\xD2\xDE\xA7\x9E\xAA\xAA\xB7\xB1\xA9\xB5\xB1\x96\xA6\xA4\xAF\xAC\xA2\x90\xBC\xB8\xB5\xBB\xA0\x8A\xB5\xB8\xB4\xB6\xA8\x80\xEF\x80" + 0xD61AE67E).s, cvar.visual_fakelag_history_local_light_color[3], 1.0);
	Sakura::Cvar::New(/*visual_fakelag_history_local_chams_color[0]*/XorStr<0x09, 44, 0x106F9926>("\x7F\x63\x78\x79\x6C\x62\x50\x76\x70\x79\x76\x78\x74\x71\x48\x70\x70\x69\x6F\x73\x6F\x67\x40\x4C\x4E\x41\x42\x48\x7A\x45\x4F\x49\x44\x59\x74\x4F\x42\x42\x40\x42\x6A\x02\x6E" + 0x106F9926).s, cvar.visual_fakelag_history_local_chams_color[0]);
	Sakura::Cvar::New(/*visual_fakelag_history_local_chams_color[1]*/XorStr<0xBE, 44, 0x72EC8096>("\xC8\xD6\xB3\xB4\xA3\xAF\x9B\xA3\xA7\xAC\xAD\xA5\xAB\xAC\x93\xA5\xA7\xBC\xA4\xBE\xA0\xAA\x8B\xB9\xB9\xB4\xB9\xB5\x85\xB8\xB4\xBC\xB3\xAC\xBF\x82\x8D\x8F\x8B\x97\xBD\xD6\xB5" + 0x72EC8096).s, cvar.visual_fakelag_history_local_chams_color[1], 1.0);
	Sakura::Cvar::New(/*visual_fakelag_history_local_chams_color[2]*/XorStr<0x5F, 44, 0x5877BF20>("\x29\x09\x12\x17\x02\x08\x3A\x00\x06\x03\x0C\x06\x0A\x0B\x32\x06\x06\x03\x05\x1D\x01\x0D\x2A\x1A\x18\x1B\x18\x16\x24\x1F\x15\x1F\x12\xF3\xDE\xE1\xEC\xE8\xEA\xF4\xDC\xBA\xD4" + 0x5877BF20).s, cvar.visual_fakelag_history_local_chams_color[2]);
	Sakura::Cvar::New(/*visual_fakelag_history_local_chams_color[3]*/XorStr<0x02, 44, 0xBE83E15C>("\x74\x6A\x77\x70\x67\x6B\x57\x6F\x6B\x60\x69\x61\x6F\x68\x4F\x79\x7B\x60\x60\x7A\x64\x6E\x47\x75\x75\x78\x7D\x71\x41\x7C\x48\x40\x4F\x50\x7B\x46\x49\x4B\x47\x5B\x71\x18\x71" + 0xBE83E15C).s, cvar.visual_fakelag_history_local_chams_color[3], 1.0);
	Sakura::Cvar::New(/*visual_deathmark_enable*/XorStr<0x32, 24, 0x67A69268>("\x44\x5A\x47\x40\x57\x5B\x67\x5D\x5F\x5A\x48\x55\x53\x5E\x32\x2A\x1D\x26\x2A\x24\x24\x2B\x2D" + 0x67A69268).s, cvar.visual_deathmark_enable);
	Sakura::Cvar::New(/*visual_deathmark_seconds*/XorStr<0x99, 25, 0x384EA999>("\xEF\xF3\xE8\xE9\xFC\xF2\xC0\xC4\xC4\xC3\xD7\xCC\xC8\xC7\xD5\xC3\xF6\xD9\xCE\xCF\xC2\xC0\xCB\xC3" + 0x384EA999).s, cvar.visual_deathmark_seconds, 5.0);
	Sakura::Cvar::New(/*visual_deathmark_glow*/XorStr<0xBC, 22, 0x00047843>("\xCA\xD4\xCD\xCA\xA1\xAD\x9D\xA7\xA1\xA4\xB2\xAF\xA5\xA8\xB8\xA0\x93\xAA\xA2\xA0\xA7" + 0x00047843).s, cvar.visual_deathmark_glow);
	Sakura::Cvar::New(/*visual_deathmark_transparency*/XorStr<0x09, 30, 0xC9193C85>("\x7F\x63\x78\x79\x6C\x62\x50\x74\x74\x73\x67\x7C\x78\x77\x65\x73\x46\x6E\x69\x7D\x73\x6D\x6F\x41\x53\x47\x4D\x47\x5C" + 0xC9193C85).s, cvar.visual_deathmark_transparency, 128.0);
	Sakura::Cvar::New(/*visual_deathmark_color[0]*/XorStr<0x9A, 26, 0xC96F5E6F>("\xEC\xF2\xEF\xE8\xFF\xF3\xFF\xC5\xC7\xC2\xD0\xCD\xCB\xC6\xDA\xC2\xF5\xC8\xC3\xC1\xC1\xDD\xEB\x81\xEF" + 0xC96F5E6F).s, cvar.visual_deathmark_color[0], 1.0);
	Sakura::Cvar::New(/*visual_deathmark_color[1]*/XorStr<0xDC, 26, 0x542C3000>("\xAA\xB4\xAD\xAA\x81\x8D\xBD\x87\x81\x84\x92\x8F\x85\x88\x98\x80\xB3\x8E\x81\x83\x9F\x83\xA9\xC2\xA9" + 0x542C3000).s, cvar.visual_deathmark_color[1], 1.0);
	Sakura::Cvar::New(/*visual_deathmark_color[2]*/XorStr<0x91, 26, 0x5F1F120B>("\xE7\xFB\xE0\xE1\xF4\xFA\xC8\xFC\xFC\xFB\xEF\xF4\xF0\xFF\xED\xCB\xFE\xC1\xCC\xC8\xCA\xD4\xFC\x9A\xF4" + 0x5F1F120B).s, cvar.visual_deathmark_color[2], 1.0);
	Sakura::Cvar::New(/*visual_deathmark_color[3]*/XorStr<0xA4, 26, 0xB5623B37>("\xD2\xCC\xD5\xD2\xC9\xC5\xF5\xCF\xC9\xCC\xDA\xC7\xDD\xD0\xC0\xD8\xEB\xD6\xD9\xDB\xD7\xCB\xE1\x88\xE1" + 0xB5623B37).s, cvar.visual_deathmark_color[3], 1.0);
	Sakura::Cvar::New(/*visual_player_dynamiclight*/XorStr<0xEF, 27, 0x0F07E37C>("\x99\x99\x82\x87\x92\x98\xAA\x86\x9B\x99\x80\x9F\x89\xA3\x99\x87\x91\x61\x6C\x6B\x60\x68\x6C\x61\x6F\x7C" + 0x0F07E37C).s, cvar.visual_player_dynamiclight);
	Sakura::Cvar::New(/*visual_player_dynamiclight_radius*/XorStr<0xE9, 34, 0xEAFE6D99>("\x9F\x83\x98\x99\x8C\x82\xB0\x80\x9D\x93\x8A\x91\x87\xA9\x93\x81\x97\x9B\x96\x95\x9E\x92\x96\x67\x69\x76\x5C\x76\x64\x62\x6E\x7D\x7A" + 0xEAFE6D99).s, cvar.visual_player_dynamiclight_radius, 1.0);
	Sakura::Cvar::New(/*visual_player_dynamiclight_fading*/XorStr<0x6C, 34, 0x32EDF016>("\x1A\x04\x1D\x1A\x11\x1D\x2D\x03\x18\x14\x0F\x12\x0A\x26\x1E\x02\x12\x1C\x13\x16\xE3\xED\xEB\xE4\xEC\xF1\xD9\xE1\xE9\xED\xE3\xE5\xEB" + 0x32EDF016).s, cvar.visual_player_dynamiclight_fading);
	Sakura::Cvar::New(/*visual_player_dynamiclight_fading_speed*/XorStr<0x8C, 40, 0x847E944D>("\xFA\xE4\xFD\xFA\xF1\xFD\xCD\xE3\xF8\xF4\xEF\xF2\xEA\xC6\xFE\xE2\xF2\xFC\xF3\xF6\xC3\xCD\xCB\xC4\xCC\xD1\xF9\xC1\xC9\xCD\xC3\xC5\xCB\xF2\xDD\xDF\xD5\xD4\xD6" + 0x847E944D).s, cvar.visual_player_dynamiclight_fading_speed, 1.0);
	Sakura::Cvar::New(/*visual_player_dynamiclight_color_tt[0]*/XorStr<0x2F, 39, 0x887FD3E6>("\x59\x59\x42\x47\x52\x58\x6A\x46\x5B\x59\x40\x5F\x49\x63\x59\x47\x51\x21\x2C\x2B\x20\x28\x2C\x21\x2F\x3C\x16\x29\x24\x20\x22\x3C\x10\x24\x25\x09\x63\x09" + 0x887FD3E6).s, cvar.visual_player_dynamiclight_color_tt[0], 1.0);
	Sakura::Cvar::New(/*visual_player_dynamiclight_color_tt[1]*/XorStr<0x4E, 39, 0x9EE7299D>("\x38\x26\x23\x24\x33\x3F\x0B\x25\x3A\x36\x21\x3C\x28\x04\x38\x24\x30\x3E\x0D\x08\x01\x0F\x0D\x02\x0E\x13\x37\x0A\x05\x07\x03\x1F\x31\x1B\x04\x2A\x43\x2E" + 0x9EE7299D).s, cvar.visual_player_dynamiclight_color_tt[1], 1.0);
	Sakura::Cvar::New(/*visual_player_dynamiclight_color_tt[2]*/XorStr<0xCF, 39, 0xA47394B2>("\xB9\xB9\xA2\xA7\xB2\xB8\x8A\xA6\xBB\xB9\xA0\xBF\xA9\x83\xB9\xA7\xB1\x81\x8C\x8B\x80\x88\x8C\x81\x8F\x9C\xB6\x89\x84\x80\x82\x9C\xB0\x84\x85\xA9\xC1\xA9" + 0xA47394B2).s, cvar.visual_player_dynamiclight_color_tt[2]);
	Sakura::Cvar::New(/*visual_player_dynamiclight_color_tt[3]*/XorStr<0xC4, 39, 0xC90C0DE0>("\xB2\xAC\xB5\xB2\xA9\xA5\x95\xBB\xA0\xAC\xB7\xAA\xA2\x8E\xB6\xAA\xBA\xB4\xBB\xBE\xBB\xB5\xB3\xBC\xB4\xA9\x81\xBC\x8F\x8D\x8D\x91\xBB\x91\x92\xBC\xDB\xB4" + 0xC90C0DE0).s, cvar.visual_player_dynamiclight_color_tt[3], 1.0);
	Sakura::Cvar::New(/*visual_player_dynamiclight_color_ct[0]*/XorStr<0x75, 39, 0x5B69627A>("\x03\x1F\x04\x0D\x18\x16\x24\x0C\x11\x1F\x06\xE5\xF3\xDD\xE7\xFD\xEB\xE7\xEA\xE1\xEA\xE6\xE2\xEB\xE5\xFA\xD0\xF3\xFE\xFE\xFC\xE6\xCA\xF5\xE3\xC3\xA9\xC7" + 0x5B69627A).s, cvar.visual_player_dynamiclight_color_ct[0]);
	Sakura::Cvar::New(/*visual_player_dynamiclight_color_ct[1]*/XorStr<0x0B, 39, 0x73214FD8>("\x7D\x65\x7E\x7B\x6E\x7C\x4E\x62\x7F\x75\x6C\x73\x65\x47\x7D\x63\x75\x7D\x70\x77\x7C\x4C\x48\x45\x4B\x50\x7A\x45\x48\x44\x46\x58\x74\x4F\x59\x75\x1E\x6D" + 0x73214FD8).s, cvar.visual_player_dynamiclight_color_ct[1], 1.0);
	Sakura::Cvar::New(/*visual_player_dynamiclight_color_ct[2]*/XorStr<0xA9, 39, 0x83BE83A4>("\xDF\xC3\xD8\xD9\xCC\xC2\xF0\xC0\xDD\xD3\xCA\xD1\xC7\xE9\xD3\xC1\xD7\xDB\xD6\xD5\xDE\xD2\xD6\xA7\xA9\xB6\x9C\xA7\xAA\xAA\xA8\xBA\x96\xA9\xBF\x97\xFF\x93" + 0x83BE83A4).s, cvar.visual_player_dynamiclight_color_ct[2], 1.0);
	Sakura::Cvar::New(/*visual_player_dynamiclight_color_ct[3]*/XorStr<0xA9, 39, 0x7C99C93B>("\xDF\xC3\xD8\xD9\xCC\xC2\xF0\xC0\xDD\xD3\xCA\xD1\xC7\xE9\xD3\xC1\xD7\xDB\xD6\xD5\xDE\xD2\xD6\xA7\xA9\xB6\x9C\xA7\xAA\xAA\xA8\xBA\x96\xA9\xBF\x97\xFE\x93" + 0x7C99C93B).s, cvar.visual_player_dynamiclight_color_ct[3], 1.0);
	Sakura::Cvar::New(/*visual_hud*/XorStr<0x79, 11, 0xA8CBB223>("\x0F\x13\x08\x09\x1C\x12\x20\xE8\xF4\xE6" + 0xA8CBB223).s, cvar.visual_hud);
	Sakura::Cvar::New(/*visual_hud_color[0]*/XorStr<0xBF, 20, 0x9835B862>("\xC9\xA9\xB2\xB7\xA2\xA8\x9A\xAE\xB2\xAC\x96\xA9\xA4\xA0\xA2\xBC\x94\xE0\x8C" + 0x9835B862).s, cvar.visual_hud_color[0]);
	Sakura::Cvar::New(/*visual_hud_color[1]*/XorStr<0x1D, 20, 0x9F75B92F>("\x6B\x77\x6C\x55\x40\x4E\x7C\x4C\x50\x42\x78\x4B\x46\x46\x44\x5E\x76\x1F\x72" + 0x9F75B92F).s, cvar.visual_hud_color[1], 1.0);
	Sakura::Cvar::New(/*visual_hud_color[2]*/XorStr<0x1B, 20, 0x2C01D32F>("\x6D\x75\x6E\x6B\x7E\x4C\x7E\x4A\x56\x40\x7A\x45\x48\x44\x46\x58\x70\x1E\x70" + 0x2C01D32F).s, cvar.visual_hud_color[2]);

	Sakura::Cvar::New(/*visual_fakelag_history_local_wireframe_line_width*/XorStr<0xB0, 50, 0xDBF5F2E5>("\xC6\xD8\xC1\xC6\xD5\xD9\xE9\xD1\xD9\xD2\xDF\xD7\xDD\xDA\xE1\xD7\xA9\xB2\xB6\xAC\xB6\xBC\x99\xAB\xA7\xAA\xAB\xA7\x93\xBA\xA7\xBD\xB5\xB7\xA0\xB2\xB9\xB0\x89\xBB\xB1\xB7\xBF\x84\xAB\xB4\xBA\xAB\x88" + 0xDBF5F2E5).s, cvar.visual_fakelag_history_local_wireframe_line_width, 1.0);
	Sakura::Cvar::New(/*visual_fakelag_history_local_wireframe_point_size*/XorStr<0x4A, 50, 0xF054CF19>("\x3C\x22\x3F\x38\x2F\x23\x0F\x37\x33\x38\x31\x39\x37\x30\x07\x31\x33\x28\x28\x32\x2C\x26\x3F\x0D\x0D\x00\x05\x09\x39\x10\x01\x1B\x0F\x0D\x1E\x0C\x03\x0A\x2F\x01\x1D\x1A\x1A\x01\x29\x04\x11\x03\x1F" + 0xF054CF19).s, cvar.visual_fakelag_history_local_wireframe_point_size, 1.0);
	Sakura::Cvar::New(/*chams_view_model_wireframe_line_width*/XorStr<0x95, 38, 0x785193BC>("\xF6\xFE\xF6\xF5\xEA\xC5\xED\xF5\xF8\xE9\xC0\xCD\xCE\xC6\xC6\xC8\xFA\xD1\xCE\xDA\xCC\xCC\xD9\xCD\xC0\xCB\xF0\xDC\xD8\xDC\xD6\xEB\xC2\xDF\xD3\xCC\xD1" + 0x785193BC).s, cvar.chams_view_model_wireframe_line_width, 1.0);
	Sakura::Cvar::New(/*chams_view_model_wireframe_point_size*/XorStr<0xC5, 38, 0xFB509F9A>("\xA6\xAE\xA6\xA5\xBA\x95\xBD\xA5\xA8\xB9\x90\xBD\xBE\xB6\xB6\xB8\x8A\xA1\xBE\xAA\xBC\xBC\xA9\xBD\xB0\xBB\x80\x90\x8E\x8B\x8D\x90\xBA\x95\x8E\x92\x8C" + 0xFB509F9A).s, cvar.chams_view_model_wireframe_point_size, 1.0);
	Sakura::Cvar::New(/*chams_player_wireframe_line_width*/XorStr<0x9D, 34, 0xDD093D61>("\xFE\xF6\xFE\xCD\xD2\xFD\xD3\xC8\xC4\xDF\xC2\xDA\xF6\xDD\xC2\xDE\xC8\xC8\xDD\xD1\xDC\xD7\xEC\xD8\xDC\xD8\xD2\xE7\xCE\xD3\xDF\xC8\xD5" + 0xDD093D61).s, cvar.chams_player_wireframe_line_width, 1.0);
	Sakura::Cvar::New(/*chams_player_wireframe_point_size*/XorStr<0x7D, 34, 0xC8B9AF27>("\x1E\x16\x1E\xED\xF2\xDD\xF3\xE8\xE4\xFF\xE2\xFA\xD6\xFD\xE2\xFE\xE8\xE8\xFD\xF1\xFC\xF7\xCC\xE4\xFA\xFF\xF9\xEC\xC6\xE9\xF2\xE6\xF8" + 0xC8B9AF27).s, cvar.chams_player_wireframe_point_size, 1.0);
	Sakura::Cvar::New(/*chams_world_wireframe_line_width*/XorStr<0xE7, 33, 0xD43057D1>("\x84\x80\x88\x87\x98\xB3\x9A\x81\x9D\x9C\x95\xAD\x84\x9D\x87\x93\x91\x8A\x98\x97\x9E\xA3\x91\x97\x91\x65\x5E\x75\x6A\x60\x71\x6E" + 0xD43057D1).s, cvar.chams_world_wireframe_line_width, 1.0);
	Sakura::Cvar::New(/*chams_world_wireframe_point_size*/XorStr<0x9B, 33, 0x7E59B000>("\xF8\xF4\xFC\xF3\xEC\xFF\xD6\xCD\xD1\xC8\xC1\xF9\xD0\xC1\xDB\xCF\xCD\xDE\xCC\xC3\xCA\xEF\xC1\xDD\xDA\xDA\xC1\xE9\xC4\xD1\xC3\xDF" + 0x7E59B000).s, cvar.chams_world_wireframe_point_size, 1.0);
	Sakura::Cvar::New(/*chams_local_wireframe_line_width*/XorStr<0xDC, 33, 0x7FF44493>("\xBF\xB5\xBF\xB2\x93\xBE\x8E\x8C\x87\x84\x8A\xB8\x9F\x80\x98\x8E\x8A\x9F\x8F\x82\x95\xAE\x9E\x9A\x9A\x90\xA9\x80\x91\x9D\x8E\x93" + 0x7FF44493).s, cvar.chams_local_wireframe_line_width, 1.0);
	Sakura::Cvar::New(/*chams_local_wireframe_point_size*/XorStr<0x07, 33, 0x0C3962FF>("\x64\x60\x68\x67\x78\x53\x61\x61\x6C\x71\x7D\x4D\x64\x7D\x67\x73\x71\x6A\x78\x77\x7E\x43\x6D\x71\x76\x4E\x55\x7D\x50\x4D\x5F\x43" + 0x0C3962FF).s, cvar.chams_local_wireframe_point_size, 1.0);

	Sakura::Cvar::New(/*skeleton_player_bone*/XorStr<0xFF, 21, 0xFF097867>("\x8C\x6B\x64\x6E\x66\x70\x6A\x68\x58\x78\x65\x6B\x72\x69\x7F\x51\x6D\x7F\x7F\x77" + 0xFF097867).s, cvar.skeleton_player_bone);
	Sakura::Cvar::New(/*skeleton_player_bone_color_tt[0]*/XorStr<0xA5, 33, 0x86B3B1A6>("\xD6\xCD\xC2\xC4\xCC\xDE\xC4\xC2\xF2\xDE\xC3\xD1\xC8\xD7\xC1\xEB\xD7\xD9\xD9\xDD\xE6\xD9\xD4\xD0\xD2\xCC\xE0\xB4\xB5\x99\xF3\x99" + 0x86B3B1A6).s, cvar.skeleton_player_bone_color_tt[0], 1.0);
	Sakura::Cvar::New(/*skeleton_player_bone_color_tt[1]*/XorStr<0x3C, 33, 0xF3CDF3BA>("\x4F\x56\x5B\x53\x25\x35\x2D\x2D\x1B\x35\x2A\x26\x31\x2C\x38\x14\x2E\x22\x20\x2A\x0F\x32\x3D\x3F\x3B\x27\x09\x23\x2C\x02\x6B\x06" + 0xF3CDF3BA).s, cvar.skeleton_player_bone_color_tt[1]);
	Sakura::Cvar::New(/*skeleton_player_bone_color_tt[2]*/XorStr<0xEA, 33, 0x919F6574>("\x99\x80\x89\x81\x8B\x9B\x9F\x9F\xAD\x83\x98\x94\x8F\x92\x8A\xA6\x98\x94\x92\x98\xA1\x9C\x6F\x6D\x6D\x71\x5B\x71\x72\x5C\x3A\x54" + 0x919F6574).s, cvar.skeleton_player_bone_color_tt[2]);
	Sakura::Cvar::New(/*skeleton_player_bone_color_tt[3]*/XorStr<0x22, 33, 0x332728A2>("\x51\x48\x41\x49\x43\x53\x47\x47\x75\x5B\x40\x4C\x57\x4A\x42\x6E\x50\x5C\x5A\x50\x69\x54\x57\x55\x55\x49\x63\x49\x4A\x64\x73\x1C" + 0x332728A2).s, cvar.skeleton_player_bone_color_tt[3], 1.0);
	Sakura::Cvar::New(/*skeleton_player_bone_color_ct[0]*/XorStr<0x5B, 33, 0x7EAC31FF>("\x28\x37\x38\x32\x3A\x14\x0E\x0C\x3C\x14\x09\x07\x1E\x0D\x1B\x35\x09\x03\x03\x0B\x30\x13\x1E\x1E\x1C\x06\x2A\x15\x03\x23\x49\x27" + 0x7EAC31FF).s, cvar.skeleton_player_bone_color_ct[0]);
	Sakura::Cvar::New(/*skeleton_player_bone_color_ct[1]*/XorStr<0x34, 33, 0xF86E0499>("\x47\x5E\x53\x5B\x5D\x4D\x55\x55\x63\x4D\x52\x5E\x39\x24\x30\x1C\x26\x2A\x28\x22\x17\x2A\x25\x27\x23\x3F\x11\x2C\x24\x0A\x63\x0E" + 0xF86E0499).s, cvar.skeleton_player_bone_color_ct[1]);
	Sakura::Cvar::New(/*skeleton_player_bone_color_ct[2]*/XorStr<0x11, 33, 0xAFE9A518>("\x62\x79\x76\x78\x70\x62\x78\x76\x46\x6A\x77\x7D\x64\x7B\x6D\x7F\x43\x4D\x4D\x41\x7A\x45\x48\x44\x46\x58\x74\x4F\x59\x75\x1D\x6D" + 0xAFE9A518).s, cvar.skeleton_player_bone_color_ct[2], 1.0);
	Sakura::Cvar::New(/*skeleton_player_bone_color_ct[3]*/XorStr<0x23, 33, 0x658BA33B>("\x50\x4F\x40\x4A\x42\x5C\x46\x44\x74\x5C\x41\x4F\x56\x55\x43\x6D\x51\x5B\x5B\x53\x68\x5B\x56\x56\x54\x4E\x62\x5D\x4B\x1B\x72\x1F" + 0x658BA33B).s, cvar.skeleton_player_bone_color_ct[3], 1.0);
	Sakura::Cvar::New(/*skeleton_player_hitbox*/XorStr<0x01, 23, 0x1720E72C>("\x72\x69\x66\x68\x60\x72\x68\x66\x56\x7A\x67\x6D\x74\x6B\x7D\x4F\x79\x7B\x67\x76\x7A\x6E" + 0x1720E72C).s, cvar.skeleton_player_hitbox);
	Sakura::Cvar::New(/*skeleton_player_hitbox_color_tt[0]*/XorStr<0x84, 35, 0x02EEE8B5>("\xF7\xEE\xE3\xEB\xED\xFD\xE5\xE5\xD3\xFD\xE2\xEE\xE9\xF4\xE0\xCC\xFC\xFC\xE2\xF5\xF7\xE1\xC5\xF8\xF3\xF1\xF1\xED\xFF\xD5\xD6\xF8\x94\xF8" + 0x02EEE8B5).s, cvar.skeleton_player_hitbox_color_tt[0], 1.0);
	Sakura::Cvar::New(/*skeleton_player_hitbox_color_tt[1]*/XorStr<0x23, 35, 0xD80A1009>("\x50\x4F\x40\x4A\x42\x5C\x46\x44\x74\x5C\x41\x4F\x56\x55\x43\x6D\x5B\x5D\x41\x54\x58\x40\x66\x59\x54\x50\x52\x4C\x60\x34\x35\x19\x72\x19" + 0xD80A1009).s, cvar.skeleton_player_hitbox_color_tt[1]);
	Sakura::Cvar::New(/*skeleton_player_hitbox_color_tt[2]*/XorStr<0xC7, 35, 0xFAEC1AFA>("\xB4\xA3\xAC\xA6\xAE\xB8\xA2\xA0\x90\xA0\xBD\xB3\xAA\xB1\xA7\x89\xBF\xB1\xAD\xB8\xB4\xA4\x82\xBD\xB0\x8C\x8E\x90\xBC\x90\x91\xBD\xD5\xB5" + 0xFAEC1AFA).s, cvar.skeleton_player_hitbox_color_tt[2]);
	Sakura::Cvar::New(/*skeleton_player_hitbox_color_tt[3]*/XorStr<0x6E, 35, 0xFDA76AD6>("\x1D\x04\x15\x1D\x17\x07\x1B\x1B\x29\x07\x14\x18\x03\x1E\x0E\x22\x16\x16\xF4\xE3\xED\xFB\xDB\xE6\xE9\xEB\xE7\xFB\xD5\xFF\xF8\xD6\xBD\xD2" + 0xFDA76AD6).s, cvar.skeleton_player_hitbox_color_tt[3], 1.0);
	Sakura::Cvar::New(/*skeleton_player_hitbox_color_ct[0]*/XorStr<0x44, 35, 0xFE5A9CC9>("\x37\x2E\x23\x2B\x2D\x3D\x25\x25\x13\x3D\x22\x2E\x29\x34\x20\x0C\x3C\x3C\x22\x35\x37\x21\x05\x38\x33\x31\x31\x2D\x3F\x02\x16\x38\x54\x38" + 0xFE5A9CC9).s, cvar.skeleton_player_hitbox_color_ct[0]);
	Sakura::Cvar::New(/*skeleton_player_hitbox_color_ct[1]*/XorStr<0x30, 35, 0xB7820A14>("\x43\x5A\x57\x5F\x51\x41\x59\x59\x67\x49\x56\x5A\x45\x58\x4C\x60\x28\x28\x36\x21\x2B\x3D\x19\x24\x27\x25\x25\x39\x13\x2E\x3A\x14\x61\x0C" + 0xB7820A14).s, cvar.skeleton_player_hitbox_color_ct[1]);
	Sakura::Cvar::New(/*skeleton_player_hitbox_color_ct[2]*/XorStr<0x51, 35, 0x901F9E2F>("\x22\x39\x36\x38\x30\x22\x38\x36\x06\x2A\x37\x3D\x24\x3B\x2D\x3F\x09\x0B\x17\x06\x0A\x1E\x38\x0B\x06\x06\x04\x1E\x32\x0D\x1B\x2B\x43\x2F" + 0x901F9E2F).s, cvar.skeleton_player_hitbox_color_ct[2], 1.0);
	Sakura::Cvar::New(/*skeleton_player_hitbox_color_ct[3]*/XorStr<0xAB, 35, 0xF5CF1C4C>("\xD8\xC7\xC8\xC2\xCA\xC4\xDE\xDC\xEC\xC4\xD9\xD7\xCE\xDD\xCB\xE5\xD3\xD5\xC9\xDC\xD0\xB8\x9E\xA1\xAC\xA8\xAA\xB4\x98\xAB\xBD\x91\xF8\x91" + 0xF5CF1C4C).s, cvar.skeleton_player_hitbox_color_ct[3], 1.0);
	Sakura::Cvar::New(/*skeleton_view_model_hitbox*/XorStr<0x5F, 27, 0x74884DDB>("\x2C\x0B\x04\x0E\x06\x10\x0A\x08\x38\x1E\x00\x0F\x1C\x33\x00\x01\x0B\x15\x1D\x2D\x1B\x1D\x01\x14\x18\x00" + 0x74884DDB).s, cvar.skeleton_view_model_hitbox);
	Sakura::Cvar::New(/*skeleton_view_model_hitbox_color[0]*/XorStr<0x84, 36, 0xFDE31210>("\xF7\xEE\xE3\xEB\xED\xFD\xE5\xE5\xD3\xFB\xE7\xEA\xE7\xCE\xFF\xFC\xF0\xF0\xFA\xC8\xF0\xF0\xEE\xF9\xF3\xE5\xC1\xFC\xCF\xCD\xCD\xD1\xFF\x95\xFB" + 0xFDE31210).s, cvar.skeleton_view_model_hitbox_color[0]);
	Sakura::Cvar::New(/*skeleton_view_model_hitbox_color[1]*/XorStr<0xE5, 36, 0x2CC4CB4F>("\x96\x8D\x82\x84\x8C\x9E\x84\x82\xB2\x98\x86\x95\x86\xAD\x9E\x9B\x91\x93\x9B\xA7\x91\x93\x8F\x9E\x92\x86\xA0\x63\x6E\x6E\x6C\x76\x5E\x37\x5A" + 0x2CC4CB4F).s, cvar.skeleton_view_model_hitbox_color[1], 1.0);
	Sakura::Cvar::New(/*skeleton_view_model_hitbox_color[2]*/XorStr<0xA3, 36, 0x18668F30>("\xD0\xCF\xC0\xCA\xC2\xDC\xC6\xC4\xF4\xDA\xC4\xCB\xD8\xEF\xDC\xDD\xD7\xD1\xD9\xE9\xDF\xD1\xCD\xD8\xD4\xC4\xE2\xDD\xD0\xAC\xAE\xB0\x98\xF6\x98" + 0x18668F30).s, cvar.skeleton_view_model_hitbox_color[2]);
	Sakura::Cvar::New(/*skeleton_view_model_hitbox_color[3]*/XorStr<0x53, 36, 0x3180169F>("\x20\x3F\x30\x3A\x32\x2C\x36\x34\x04\x2A\x34\x3B\x28\x3F\x0C\x0D\x07\x01\x09\x39\x0F\x01\x1D\x08\x04\x14\x32\x0D\x00\x1C\x1E\x00\x28\x47\x28" + 0x3180169F).s, cvar.skeleton_view_model_hitbox_color[3], 1.0);
	Sakura::Cvar::New(/*skeleton_world_bone*/XorStr<0xE3, 20, 0x6A2E7BBF>("\x90\x8F\x80\x8A\x82\x9C\x86\x84\xB4\x9B\x82\x9C\x83\x94\xAE\x90\x9C\x9A\x90" + 0x6A2E7BBF).s, cvar.skeleton_world_bone);
	Sakura::Cvar::New(/*skeleton_world_bone_color[0]*/XorStr<0x81, 29, 0x3D41D2C1>("\xF2\xE9\xE6\xE8\xE0\xF2\xE8\xE6\xD6\xFD\xE4\xFE\xE1\xEA\xD0\xF2\xFE\xFC\xF6\xCB\xF6\xF9\xFB\xF7\xEB\xC1\xAB\xC1" + 0x3D41D2C1).s, cvar.skeleton_world_bone_color[0], 1.0);
	Sakura::Cvar::New(/*skeleton_world_bone_color[1]*/XorStr<0xB2, 29, 0x1CD47FCD>("\xC1\xD8\xD1\xD9\xD3\xC3\xD7\xD7\xE5\xCC\xD3\xCF\xD2\xDB\x9F\xA3\xAD\xAD\xA1\x9A\xA5\xA8\xA4\xA6\xB8\x90\xFD\x90" + 0x1CD47FCD).s, cvar.skeleton_world_bone_color[1], 1.0);
	Sakura::Cvar::New(/*skeleton_world_bone_color[2]*/XorStr<0xAC, 29, 0xD1E63643>("\xDF\xC6\xCB\xC3\xD5\xC5\xDD\xDD\xEB\xC2\xD9\xC5\xD4\xDD\xE5\xD9\xD3\xD3\xDB\xE0\xA3\xAE\xAE\xAC\xB6\x9E\xF4\x9A" + 0xD1E63643).s, cvar.skeleton_world_bone_color[2], 1.0);
	Sakura::Cvar::New(/*skeleton_world_bone_color[3]*/XorStr<0x50, 29, 0xB84AF747>("\x23\x3A\x37\x3F\x31\x21\x39\x39\x07\x2E\x35\x29\x30\x39\x01\x3D\x0F\x0F\x07\x3C\x07\x0A\x0A\x08\x1A\x32\x59\x36" + 0xB84AF747).s, cvar.skeleton_world_bone_color[3], 1.0);
	Sakura::Cvar::New(/*skeleton_world_hitbox*/XorStr<0xB2, 22, 0x5E1BCD4C>("\xC1\xD8\xD1\xD9\xD3\xC3\xD7\xD7\xE5\xCC\xD3\xCF\xD2\xDB\x9F\xA9\xAB\xB7\xA6\xAA\xBE" + 0x5E1BCD4C).s, cvar.skeleton_world_hitbox);
	Sakura::Cvar::New(/*skeleton_world_hitbox_color[0]*/XorStr<0x6E, 31, 0xC076422A>("\x1D\x04\x15\x1D\x17\x07\x1B\x1B\x29\x00\x17\x0B\x16\x1F\x23\x15\x17\x0B\xE2\xEE\xFA\xDC\xE7\xEA\xEA\xE8\xFA\xD2\xBA\xD6" + 0xC076422A).s, cvar.skeleton_world_hitbox_color[0], 1.0);
	Sakura::Cvar::New(/*skeleton_world_hitbox_color[1]*/XorStr<0x2C, 31, 0x29CEE6B1>("\x5F\x46\x4B\x43\x55\x45\x5D\x5D\x6B\x42\x59\x45\x54\x5D\x65\x53\x55\x49\x5C\x50\x38\x1E\x21\x2C\x28\x2A\x34\x1C\x79\x14" + 0x29CEE6B1).s, cvar.skeleton_world_hitbox_color[1], 1.0);
	Sakura::Cvar::New(/*skeleton_world_hitbox_color[2]*/XorStr<0x3B, 31, 0xFEF8BD85>("\x48\x57\x58\x52\x5A\x34\x2E\x2C\x1C\x33\x2A\x34\x2B\x2C\x16\x22\x22\x38\x2F\x21\x37\x0F\x32\x3D\x3F\x3B\x27\x0D\x65\x05" + 0xFEF8BD85).s, cvar.skeleton_world_hitbox_color[2], 1.0);
	Sakura::Cvar::New(/*skeleton_world_hitbox_color[3]*/XorStr<0xCD, 31, 0x3BC984DC>("\xBE\xA5\xAA\xBC\xB4\xA6\xBC\xBA\x8A\xA1\xB8\xAA\xB5\xBE\x84\xB4\xB4\xAA\xBD\x8F\x99\xBD\x80\x8B\x89\x89\x95\xB3\xDA\xB7" + 0x3BC984DC).s, cvar.skeleton_world_hitbox_color[3], 1.0);
	
	Sakura::Cvar::New(/*gui_key*/XorStr<0x01, 8, 0xE345E870>("\x66\x77\x6A\x5B\x6E\x63\x7E" + 0xE345E870).s, cvar.gui_key, -1.0);
	Sakura::Cvar::New(/*radio_kill_sound*/XorStr<0xC7, 17, 0x3EFE40D7>("\xB5\xA9\xAD\xA3\xA4\x93\xA6\xA7\xA3\xBC\x8E\xA1\xBC\xA1\xBB\xB2" + 0x3EFE40D7).s, cvar.radio_kill_sound);
	Sakura::Cvar::New(/*radio_kill_volume*/XorStr<0xA8, 18, 0xCC225892>("\xDA\xC8\xCE\xC2\xC3\xF2\xC5\xC6\xDC\xDD\xED\xC5\xDB\xD9\xC3\xDA\xDD" + 0xCC225892).s, cvar.radio_kill_volume, 15.0);
	Sakura::Cvar::New(/*afk_anti*/XorStr<0x0C, 9, 0xEDB54B79>("\x6D\x6B\x65\x50\x71\x7F\x66\x7A" + 0xEDB54B79).s, cvar.afk_anti);
	Sakura::Cvar::New(/*afk_time*/XorStr<0xAB, 9, 0xBBC33A7D>("\xCA\xCA\xC6\xF1\xDB\xD9\xDC\xD7" + 0xBBC33A7D).s, cvar.afk_time, 90.0);
	Sakura::Cvar::New(/*afk_yaw*/XorStr<0xE0, 8, 0xC32C7260>("\x81\x87\x89\xBC\x9D\x84\x91" + 0xC32C7260).s, cvar.afk_yaw, 5.0);
	Sakura::Cvar::New(/*steamid*/XorStr<0x11, 8, 0xA68A9879>("\x62\x66\x76\x75\x78\x7F\x73" + 0xA68A9879).s, cvar.steamid);
	Sakura::Cvar::New(/*id1*/XorStr<0x95, 4, 0x419B7A47>("\xFC\xF2\xA6" + 0x419B7A47).s, cvar.id1, 1.0);
	Sakura::Cvar::New(/*id2*/XorStr<0x25, 4, 0x9D63515C>("\x4C\x42\x15" + 0x9D63515C).s, cvar.id2, 2.0);
	Sakura::Cvar::New(/*id3*/XorStr<0x80, 4, 0xAB673B8C>("\xE9\xE5\xB1" + 0xAB673B8C).s, cvar.id3, 3.0);
	Sakura::Cvar::New(/*id4*/XorStr<0xEE, 4, 0x13D5E86F>("\x87\x8B\xC4" + 0x13D5E86F).s, cvar.id4, 4.0);
	Sakura::Cvar::New(/*id5*/XorStr<0x46, 4, 0x9AE08B72>("\x2F\x23\x7D" + 0x9AE08B72).s, cvar.id5, 5.0);
	Sakura::Cvar::New(/*id6*/XorStr<0x63, 4, 0xCE9FBCCB>("\x0A\x00\x53" + 0xCE9FBCCB).s, cvar.id6, 6.0);
	Sakura::Cvar::New(/*id7*/XorStr<0x65, 4, 0x2C2EE284>("\x0C\x02\x50" + 0x2C2EE284).s, cvar.id7, 7.0);
	
	Sakura::Cvar::New(/*radar*/XorStr<0x19, 6, 0x4E2147D9>("\x6B\x7B\x7F\x7D\x6F" + 0x4E2147D9).s, cvar.radar);
	Sakura::Cvar::New(/*radar_zoom*/XorStr<0x4C, 11, 0xDD3ECA33>("\x3E\x2C\x2A\x2E\x22\x0E\x28\x3C\x3B\x38" + 0xDD3ECA33).s, cvar.radar_zoom, 5.0);
	Sakura::Cvar::New(/*radar_point_size*/XorStr<0x6C, 17, 0x9B7408BB>("\x1E\x0C\x0A\x0E\x02\x2E\x02\x1C\x1D\x1B\x02\x28\x0B\x10\x00\x1E" + 0x9B7408BB).s, cvar.radar_point_size, 5.0);

	Sakura::Cvar::New(/*visual_local_glow*/XorStr<0x7A, 18, 0xC4753937>("\x0C\x12\x0F\x08\x1F\x13\xDF\xED\xED\xE0\xE5\xE9\xD9\xE0\xE4\xE6\xFD" + 0xC4753937).s, cvar.visual_local_glow);
	Sakura::Cvar::New(/*visual_local_glow_thickness*/XorStr<0x1D, 28, 0x9E6A00FF>("\x6B\x77\x6C\x55\x40\x4E\x7C\x48\x4A\x45\x46\x44\x76\x4D\x47\x43\x5A\x71\x5B\x58\x58\x51\x58\x5A\x50\x45\x44" + 0x9E6A00FF).s, cvar.visual_local_glow_thickness, 12.0);
	Sakura::Cvar::New(/*visual_local_glow_color[0]*/XorStr<0x08, 27, 0x15A6D476>("\x7E\x60\x79\x7E\x6D\x61\x51\x63\x7F\x72\x73\x7F\x4B\x72\x7A\x78\x6F\x46\x79\x74\x70\x72\x6C\x44\x10\x7C" + 0x15A6D476).s, cvar.visual_local_glow_color[0], 1.0);
	Sakura::Cvar::New(/*visual_local_glow_color[1]*/XorStr<0xC4, 27, 0xE54B0BD7>("\xB2\xAC\xB5\xB2\xA9\xA5\x95\xA7\xA3\xAE\xAF\xA3\x8F\xB6\xBE\xBC\xA3\x8A\xB5\xB8\xB4\xB6\xA8\x80\xED\x80" + 0xE54B0BD7).s, cvar.visual_local_glow_color[1], 1.0);
	Sakura::Cvar::New(/*visual_local_glow_color[2]*/XorStr<0x09, 27, 0x6913078F>("\x7F\x63\x78\x79\x6C\x62\x50\x7C\x7E\x71\x72\x78\x4A\x71\x7B\x77\x6E\x45\x78\x73\x71\x71\x6D\x7B\x13\x7F" + 0x6913078F).s, cvar.visual_local_glow_color[2], 1.0);
	Sakura::Cvar::New(/*visual_local_glow_color[3]*/XorStr<0x79, 27, 0xD8CCCAB8>("\x0F\x13\x08\x09\x1C\x12\x20\xEC\xEE\xE1\xE2\xE8\xDA\xE1\xEB\xE7\xFE\xD5\xE8\xE3\xE1\xE1\xFD\xCB\xA2\xCF" + 0xD8CCCAB8).s, cvar.visual_local_glow_color[3], 1.0);
	
	Sakura::Cvar::New(/*chams_local*/XorStr<0xB3, 12, 0x5A09071A>("\xD0\xDC\xD4\xDB\xC4\xE7\xD5\xD5\xD8\xDD\xD1" + 0x5A09071A).s, cvar.chams_local);
	Sakura::Cvar::New(/*chams_local_wireframe*/XorStr<0x5C, 22, 0xBDC170B2>("\x3F\x35\x3F\x32\x13\x3E\x0E\x0C\x07\x04\x0A\x38\x1F\x00\x18\x0E\x0A\x1F\x0F\x02\x15" + 0xBDC170B2).s, cvar.chams_local_wireframe);
	Sakura::Cvar::New(/*chams_local_wireframe_mode*/XorStr<0xC3, 27, 0x4F807651>("\xA0\xAC\xA4\xAB\xB4\x97\xA5\xA5\xA8\xAD\xA1\x91\xB8\xB9\xA3\xB7\xB5\xA6\xB4\xBB\xB2\x87\xB4\xB5\xBF\xB9" + 0x4F807651).s, cvar.chams_local_wireframe_mode);
	Sakura::Cvar::New(/*chams_local_color[0]*/XorStr<0xC5, 21, 0x1C1733C2>("\xA6\xAE\xA6\xA5\xBA\x95\xA7\xA3\xAE\xAF\xA3\x8F\xB2\xBD\xBF\xBB\xA7\x8D\xE7\x85" + 0x1C1733C2).s, cvar.chams_local_color[0], 1.0);
	Sakura::Cvar::New(/*chams_local_color[1]*/XorStr<0x70, 21, 0xB99F5BF1>("\x13\x19\x13\x1E\x07\x2A\x1A\x18\x1B\x18\x16\x24\x1F\x12\x12\x10\xF2\xDA\xB3\xDE" + 0xB99F5BF1).s, cvar.chams_local_color[1], 1.0);
	Sakura::Cvar::New(/*chams_local_color[2]*/XorStr<0x6F, 21, 0xBAA96E6A>("\x0C\x18\x10\x1F\x00\x2B\x19\x19\x14\x19\x15\x25\x18\x13\x11\x11\x0D\xDB\xB3\xDF" + 0xBAA96E6A).s, cvar.chams_local_color[2], 1.0);
	Sakura::Cvar::New(/*chams_local_color[3]*/XorStr<0x12, 21, 0x22CB7D07>("\x71\x7B\x75\x78\x65\x48\x74\x76\x79\x7A\x70\x42\x7D\x70\x4C\x4E\x50\x78\x17\x78" + 0x22CB7D07).s, cvar.chams_local_color[3], 1.0);
	Sakura::Cvar::New(/*chams_view_model*/XorStr<0xFC, 17, 0x4DC477DA>("\x9F\x95\x9F\x92\x73\x5E\x74\x6A\x61\x72\x59\x6A\x67\x6D\x6F\x67" + 0x4DC477DA).s, cvar.chams_view_model);
	Sakura::Cvar::New(/*chams_view_model_wireframe*/XorStr<0x05, 27, 0x76CC0AAC>("\x66\x6E\x66\x65\x7A\x55\x7D\x65\x68\x79\x50\x7D\x7E\x76\x76\x78\x4A\x61\x7E\x6A\x7C\x7C\x69\x7D\x70\x7B" + 0x76CC0AAC).s, cvar.chams_view_model_wireframe);
	Sakura::Cvar::New(/*chams_view_model_wireframe_mode*/XorStr<0xDF, 32, 0xA9A61163>("\xBC\x88\x80\x8F\x90\xBB\x93\x8F\x82\x9F\xB6\x87\x84\x88\x88\x82\xB0\x87\x98\x80\x96\x92\x87\x97\x9A\x9D\xA6\x97\x94\x98\x98" + 0xA9A61163).s, cvar.chams_view_model_wireframe_mode);
	Sakura::Cvar::New(/*chams_player*/XorStr<0xE2, 13, 0x86CE1CE3>("\x81\x8B\x85\x88\x95\xB8\x98\x85\x8B\x92\x89\x9F" + 0x86CE1CE3).s, cvar.chams_player);
	Sakura::Cvar::New(/*chams_player_wireframe*/XorStr<0x49, 23, 0x259FBD38>("\x2A\x22\x2A\x21\x3E\x11\x3F\x3C\x30\x2B\x36\x26\x0A\x21\x3E\x2A\x3C\x3C\x29\x3D\x30\x3B" + 0x259FBD38).s, cvar.chams_player_wireframe);
	Sakura::Cvar::New(/*chams_player_wireframe_mode*/XorStr<0xBE, 28, 0xA5352868>("\xDD\xD7\xA1\xAC\xB1\x9C\xB4\xA9\xA7\xBE\xAD\xBB\x95\xBC\xA5\xBF\xAB\xA9\xA2\xB0\xBF\xB6\x8B\xB8\xB9\xB3\xBD" + 0xA5352868).s, cvar.chams_player_wireframe_mode);
	Sakura::Cvar::New(/*chams_player_color_tt[0]*/XorStr<0x8E, 25, 0xB596C54A>("\xED\xE7\xF1\xFC\xE1\xCC\xE4\xF9\xF7\xEE\xFD\xEB\xC5\xF8\xF3\xF1\xF1\xED\xFF\xD5\xD6\xF8\x94\xF8" + 0xB596C54A).s, cvar.chams_player_color_tt[0], 1.0);
	Sakura::Cvar::New(/*chams_player_color_tt[1]*/XorStr<0x8B, 25, 0xCDF952F9>("\xE8\xE4\xEC\xE3\xFC\xCF\xE1\xFE\xF2\xED\xF0\xE4\xC8\xFB\xF6\xF6\xF4\xEE\xC2\xEA\xEB\xFB\x90\xFF" + 0xCDF952F9).s, cvar.chams_player_color_tt[1]);
	Sakura::Cvar::New(/*chams_player_color_tt[2]*/XorStr<0x87, 25, 0x3DE58B21>("\xE4\xE0\xE8\xE7\xF8\xD3\xFD\xE2\xEE\xE9\xF4\xE0\xCC\xF7\xFA\xFA\xF8\xEA\xC6\xEE\xEF\xC7\xAF\xC3" + 0x3DE58B21).s, cvar.chams_player_color_tt[2]);
	Sakura::Cvar::New(/*chams_player_color_tt[3]*/XorStr<0xD3, 25, 0xEF72B1B5>("\xB0\xBC\xB4\xBB\xA4\x87\xA9\xB6\xBA\xA5\xB8\xAC\x80\x83\x8E\x8E\x8C\x96\xBA\x92\x93\xB3\xDA\xB7" + 0xEF72B1B5).s, cvar.chams_player_color_tt[3], 1.0);
	Sakura::Cvar::New(/*chams_player_color_ct[0]*/XorStr<0x09, 25, 0xE513720B>("\x6A\x62\x6A\x61\x7E\x51\x7F\x7C\x70\x6B\x76\x66\x4A\x75\x78\x74\x76\x68\x44\x7F\x69\x45\x2F\x7D" + 0xE513720B).s, cvar.chams_player_color_ct[0]);
	Sakura::Cvar::New(/*chams_player_color_ct[1]*/XorStr<0x20, 25, 0xC074A212>("\x43\x49\x43\x4E\x57\x7A\x56\x4B\x49\x50\x4F\x59\x73\x4E\x41\x43\x5F\x43\x6D\x50\x40\x6E\x07\x6A" + 0xC074A212).s, cvar.chams_player_color_ct[1]);
	Sakura::Cvar::New(/*chams_player_color_ct[2]*/XorStr<0xD9, 25, 0x6E877C41>("\xBA\xB2\xBA\xB1\xAE\x81\xAF\x8C\x80\x9B\x86\x96\xBA\x85\x88\x84\x86\x98\xB4\x8F\x99\xB5\xDD\xAD" + 0x6E877C41).s, cvar.chams_player_color_ct[2], 1.0);
	Sakura::Cvar::New(/*chams_player_color_ct[3]*/XorStr<0x68, 25, 0x42838F11>("\x0B\x01\x0B\x06\x1F\x32\x1E\x03\x11\x08\x17\x01\x2B\x16\x19\x1B\x17\x0B\x25\x18\x08\x26\x4D\x22" + 0x42838F11).s, cvar.chams_player_color_ct[3], 1.0);
	Sakura::Cvar::New(/*chams_player_wall*/XorStr<0xA7, 18, 0xE223DB8E>("\xC4\xC0\xC8\xC7\xD8\xF3\xDD\xC2\xCE\xC9\xD4\xC0\xEC\xC3\xD4\xDA\xDB" + 0xE223DB8E).s, cvar.chams_player_wall);
	Sakura::Cvar::New(/*chams_player_wall_color_tt[0]*/XorStr<0x20, 30, 0x33683E09>("\x43\x49\x43\x4E\x57\x7A\x56\x4B\x49\x50\x4F\x59\x73\x5A\x4F\x43\x5C\x6E\x51\x5C\x58\x5A\x44\x68\x4C\x4D\x61\x0B\x61" + 0x33683E09).s, cvar.chams_player_wall_color_tt[0], 1.0);
	Sakura::Cvar::New(/*chams_player_wall_color_tt[1]*/XorStr<0x3D, 30, 0x208E3115>("\x5E\x56\x5E\x2D\x32\x1D\x33\x28\x24\x3F\x22\x3A\x16\x3D\x2A\x20\x21\x11\x2C\x3F\x3D\x3D\x21\x0B\x21\x22\x0C\x69\x04" + 0x208E3115).s, cvar.chams_player_wall_color_tt[1]);
	Sakura::Cvar::New(/*chams_player_wall_color_tt[2]*/XorStr<0x46, 30, 0x8A8D769F>("\x25\x2F\x29\x24\x39\x14\x3C\x21\x2F\x36\x35\x23\x0D\x24\x35\x39\x3A\x08\x3B\x36\x36\x34\x2E\x02\x2A\x2B\x3B\x53\x3F" + 0x8A8D769F).s, cvar.chams_player_wall_color_tt[2], 1.0);
	Sakura::Cvar::New(/*chams_player_wall_color_tt[3]*/XorStr<0x94, 30, 0xECE672AB>("\xF7\xFD\xF7\xFA\xEB\xC6\xEA\xF7\xFD\xE4\xFB\xED\xFF\xD6\xC3\xCF\xC8\xFA\xC5\xC8\xC4\xC6\xD8\xF4\xD8\xD9\xF5\x9C\xED" + 0xECE672AB).s, cvar.chams_player_wall_color_tt[3], 1.0);
	Sakura::Cvar::New(/*chams_player_wall_color_ct[0]*/XorStr<0x4D, 30, 0x1B8FCB0B>("\x2E\x26\x2E\x3D\x22\x0D\x23\x38\x34\x2F\x32\x2A\x06\x2D\x3A\x30\x31\x01\x3C\x0F\x0D\x0D\x11\x3B\x06\x12\x3C\x58\x34" + 0x1B8FCB0B).s, cvar.chams_player_wall_color_ct[0]);
	Sakura::Cvar::New(/*chams_player_wall_color_ct[1]*/XorStr<0xED, 30, 0x238AFBAA>("\x8E\x86\x8E\x9D\x82\xAD\x83\x98\x94\x8F\x92\x8A\xA6\x8D\x9A\x90\x91\xA1\x9C\x6F\x6D\x6D\x71\x5B\x66\x72\x5C\x39\x54" + 0x238AFBAA).s, cvar.chams_player_wall_color_ct[1], 1.0);
	Sakura::Cvar::New(/*chams_player_wall_color_ct[2]*/XorStr<0xDB, 30, 0xBD75ADDA>("\xB8\xB4\xBC\xB3\xAC\xBF\x91\x8E\x82\x9D\x80\x94\xB8\x9F\x88\x86\x87\xB3\x8E\x81\x83\x9F\x83\xAD\x90\x80\xAE\xC4\xAA" + 0xBD75ADDA).s, cvar.chams_player_wall_color_ct[2], 1.0);
	Sakura::Cvar::New(/*chams_player_wall_color_ct[3]*/XorStr<0xF9, 30, 0x8DBA408D>("\x9A\x92\x9A\x91\x8E\xA1\x8F\x6C\x60\x7B\x66\x76\x5A\x71\x66\x64\x65\x55\x68\x63\x61\x61\x7D\x4F\x72\x66\x48\x27\x48" + 0x8DBA408D).s, cvar.chams_player_wall_color_ct[3], 1.0);
	Sakura::Cvar::New(/*chams_world*/XorStr<0xA1, 12, 0xDC28A58F>("\xC2\xCA\xC2\xC9\xD6\xF9\xD0\xC7\xDB\xC6\xCF" + 0xDC28A58F).s, cvar.chams_world);
	Sakura::Cvar::New(/*chams_world_color[0]*/XorStr<0xE6, 21, 0x867996C6>("\x85\x8F\x89\x84\x99\xB4\x9B\x82\x9C\x83\x94\xAE\x91\x9C\x98\x9A\x84\xAC\xC8\xA4" + 0x867996C6).s, cvar.chams_world_color[0], 1.0);
	Sakura::Cvar::New(/*chams_world_color[1]*/XorStr<0xD6, 21, 0x408B7F44>("\xB5\xBF\xB9\xB4\xA9\x84\xAB\xB2\xAC\xB3\x84\xBE\x81\x8C\x88\x8A\x94\xBC\xD9\xB4" + 0x408B7F44).s, cvar.chams_world_color[1], 1.0);
	Sakura::Cvar::New(/*chams_world_color[2]*/XorStr<0x00, 21, 0x14C289AC>("\x63\x69\x63\x6E\x77\x5A\x71\x68\x7A\x65\x6E\x54\x6F\x62\x62\x60\x62\x4A\x20\x4E" + 0x14C289AC).s, cvar.chams_world_color[2], 1.0);
	Sakura::Cvar::New(/*chams_world_color[3]*/XorStr<0x33, 21, 0x530F6EF9>("\x50\x5C\x54\x5B\x44\x67\x4E\x55\x49\x50\x59\x61\x5C\x2F\x2D\x2D\x31\x1F\x76\x1B" + 0x530F6EF9).s, cvar.chams_world_color[3], 1.0);
	Sakura::Cvar::New(/*chams_world_wireframe*/XorStr<0xA2, 22, 0x1D218BD9>("\xC1\xCB\xC5\xC8\xD5\xF8\xDF\xC6\xD8\xC7\xC8\xF2\xD9\xC6\xC2\xD4\xD4\xC1\xD5\xD8\xD3" + 0x1D218BD9).s, cvar.chams_world_wireframe);
	Sakura::Cvar::New(/*chams_world_wireframe_mode*/XorStr<0x5A, 27, 0xA2970CAA>("\x39\x33\x3D\x30\x2D\x00\x17\x0E\x10\x0F\x00\x3A\x11\x0E\x1A\x0C\x0C\x19\x0D\x00\x0B\x30\x1D\x1E\x16\x16" + 0xA2970CAA).s, cvar.chams_world_wireframe_mode);
	Sakura::Cvar::New(/*chams_world_wall*/XorStr<0x0F, 17, 0x9938261E>("\x6C\x78\x70\x7F\x60\x4B\x62\x79\x65\x74\x7D\x45\x6C\x7D\x71\x72" + 0x9938261E).s, cvar.chams_world_wall);
	Sakura::Cvar::New(/*chams_world_wall_color[0]*/XorStr<0xC6, 26, 0x15214B79>("\xA5\xAF\xA9\xA4\xB9\x94\xBB\xA2\xBC\xA3\xB4\x8E\xA5\xB2\xB8\xB9\x89\xB4\xB7\xB5\xB5\xA9\x87\xED\x83" + 0x15214B79).s, cvar.chams_world_wall_color[0], 1.0);
	Sakura::Cvar::New(/*chams_world_wall_color[1]*/XorStr<0xBB, 26, 0xFA8AE43F>("\xD8\xD4\xDC\xD3\xCC\x9F\xB6\xAD\xB1\xA8\xA1\x99\xB0\xA9\xA5\xA6\x94\xAF\xA2\xA2\xA0\xA2\x8A\xE3\x8E" + 0xFA8AE43F).s, cvar.chams_world_wall_color[1], 1.0);
	Sakura::Cvar::New(/*chams_world_wall_color[2]*/XorStr<0x1A, 26, 0x562B4680>("\x79\x73\x7D\x70\x6D\x40\x57\x4E\x50\x4F\x40\x7A\x51\x46\x44\x45\x75\x48\x43\x41\x41\x5D\x6B\x03\x6F" + 0x562B4680).s, cvar.chams_world_wall_color[2], 1.0);
	Sakura::Cvar::New(/*chams_world_wall_color[3]*/XorStr<0xA6, 26, 0x5535E9E6>("\xC5\xCF\xC9\xC4\xD9\xF4\xDB\xC2\xDC\xC3\xD4\xEE\xC5\xD2\xD8\xD9\xE9\xD4\xD7\xD5\xD5\xC9\xE7\x8E\xE3" + 0x5535E9E6).s, cvar.chams_world_wall_color[3], 1.0);
	
	Sakura::Cvar::New(/*rainbow_player_light_tt*/XorStr<0xAC, 24, 0x197A2DB1>("\xDE\xCC\xC7\xC1\xD2\xDE\xC5\xEC\xC4\xD9\xD7\xCE\xDD\xCB\xE5\xD7\xD5\xDA\xD6\xCB\x9F\xB5\xB6" + 0x197A2DB1).s, cvar.rainbow_player_light_tt);
	Sakura::Cvar::New(/*rainbow_player_light_ct*/XorStr<0x17, 24, 0x0CF9E6E3>("\x65\x79\x70\x74\x79\x73\x6A\x41\x6F\x4C\x40\x5B\x46\x56\x7A\x4A\x4E\x4F\x41\x5E\x74\x4F\x59" + 0x0CF9E6E3).s, cvar.rainbow_player_light_ct);
	Sakura::Cvar::New(/*rainbow_viewmodel*/XorStr<0x30, 18, 0x7355F629>("\x42\x50\x5B\x5D\x56\x5A\x41\x68\x4E\x50\x5F\x4C\x51\x52\x5A\x5A\x2C" + 0x7355F629).s, cvar.rainbow_viewmodel);
	Sakura::Cvar::New(/*rainbow_viewmodel_glow*/XorStr<0xC4, 23, 0xE61F25E3>("\xB6\xA4\xAF\xA9\xAA\xA6\xBD\x94\xBA\xA4\xAB\xB8\xBD\xBE\xB6\xB6\xB8\x8A\xB1\xBB\xB7\xAE" + 0xE61F25E3).s, cvar.rainbow_viewmodel_glow);
	Sakura::Cvar::New(/*rainbow_viewmodel_light*/XorStr<0x0D, 24, 0x492334F5>("\x7F\x6F\x66\x7E\x73\x7D\x64\x4B\x63\x7F\x72\x6F\x74\x75\x7F\x79\x71\x41\x73\x49\x46\x4A\x57" + 0x492334F5).s, cvar.rainbow_viewmodel_light);
	Sakura::Cvar::New(/*rainbow_viewmodel_hitbox*/XorStr<0x1F, 25, 0x86D87521>("\x6D\x41\x48\x4C\x41\x4B\x52\x79\x51\x41\x4C\x5D\x46\x43\x49\x4B\x43\x6F\x59\x5B\x47\x56\x5A\x4E" + 0x86D87521).s, cvar.rainbow_viewmodel_hitbox);
	Sakura::Cvar::New(/*rainbow_snaplines_tt*/XorStr<0x5B, 21, 0x5AE657B4>("\x29\x3D\x34\x30\x3D\x0F\x16\x3D\x10\x0A\x04\x16\x0B\x01\x07\x0F\x18\x33\x19\x1A" + 0x5AE657B4).s, cvar.rainbow_snaplines_tt);
	Sakura::Cvar::New(/*rainbow_snaplines_ct*/XorStr<0x83, 21, 0xBBD4007F>("\xF1\xE5\xEC\xE8\xE5\xE7\xFE\xD5\xF8\xE2\xEC\xFE\xE3\xF9\xFF\xF7\xE0\xCB\xF6\xE2" + 0xBBD4007F).s, cvar.rainbow_snaplines_ct);
	Sakura::Cvar::New(/*rainbow_menu*/XorStr<0x29, 13, 0x5F9C30B5>("\x5B\x4B\x42\x42\x4F\x41\x58\x6F\x5C\x57\x5D\x41" + 0x5F9C30B5).s, cvar.rainbow_menu);
	Sakura::Cvar::New(/*rainbow_lambert_local*/XorStr<0xCB, 22, 0xC2E1136A>("\xB9\xAD\xA4\xA0\xAD\xBF\xA6\x8D\xBF\xB5\xB8\xB4\xB2\xAA\xAD\x85\xB7\xB3\xBE\xBF\xB3" + 0xC2E1136A).s, cvar.rainbow_lambert_local);
	Sakura::Cvar::New(/*rainbow_chams_local*/XorStr<0xC6, 20, 0x61C2B252>("\xB4\xA6\xA1\xA7\xA8\xA4\xBB\x92\xAD\xA7\xB1\xBC\xA1\x8C\xB8\xBA\xB5\xB6\xB4" + 0x61C2B252).s, cvar.rainbow_chams_local);
	Sakura::Cvar::New(/*rainbow_chams_local_fake*/XorStr<0x50, 25, 0x565A6CD2>("\x22\x30\x3B\x3D\x36\x3A\x21\x08\x3B\x31\x3B\x36\x2F\x02\x32\x30\x03\x00\x0E\x3C\x02\x04\x0D\x02" + 0x565A6CD2).s, cvar.rainbow_chams_local_fake);
	Sakura::Cvar::New(/*rainbow_glow_player_tt*/XorStr<0x83, 23, 0x0ECAC85C>("\xF1\xE5\xEC\xE8\xE5\xE7\xFE\xD5\xEC\xE0\xE2\xF9\xD0\xE0\xFD\xF3\xEA\xF1\xE7\xC9\xE3\xEC" + 0x0ECAC85C).s, cvar.rainbow_glow_player_tt);
	Sakura::Cvar::New(/*rainbow_glow_player_ct*/XorStr<0xE8, 23, 0xA1C68E2C>("\x9A\x88\x83\x85\x8E\x82\x99\xB0\x97\x9D\x9D\x84\xAB\x85\x9A\x96\x81\x9C\x88\xA4\x9F\x89" + 0xA1C68E2C).s, cvar.rainbow_glow_player_ct);
	Sakura::Cvar::New(/*rainbow_chams_player_ct*/XorStr<0xD2, 24, 0xA3B830AB>("\xA0\xB2\xBD\xBB\xB4\xB8\xAF\x86\xB9\xB3\xBD\xB0\xAD\x80\x90\x8D\x83\x9A\x81\x97\xB9\x84\x9C" + 0xA3B830AB).s, cvar.rainbow_chams_player_ct);
	Sakura::Cvar::New(/*rainbow_chams_player_tt*/XorStr<0x1D, 24, 0x4DF1034B>("\x6F\x7F\x76\x4E\x43\x4D\x54\x7B\x46\x4E\x46\x45\x5A\x75\x5B\x40\x4C\x57\x4A\x42\x6E\x46\x47" + 0x4DF1034B).s, cvar.rainbow_chams_player_tt);
	Sakura::Cvar::New(/*rainbow_chams_world*/XorStr<0xAF, 20, 0xC3412E8B>("\xDD\xD1\xD8\xDC\xD1\xDB\xC2\xE9\xD4\xD0\xD8\xD7\xC8\xE3\xCA\xD1\xCD\xAC\xA5" + 0xC3412E8B).s, cvar.rainbow_chams_world);
	Sakura::Cvar::New(/*rainbow_grenade_trajectory_line*/XorStr<0xD5, 32, 0xB9C46F72>("\xA7\xB7\xBE\xB6\xBB\xB5\xAC\x83\xBA\xAC\xBA\x8E\x80\x86\x86\xBB\x91\x94\x86\x82\x8C\x89\x9F\x83\x9F\x97\xB0\x9C\x98\x9C\x96" + 0xB9C46F72).s, cvar.rainbow_grenade_trajectory_line);
	Sakura::Cvar::New(/*rainbow_grenade_trajectory_point*/XorStr<0xD1, 33, 0x803D9D6F>("\xA3\xB3\xBA\xBA\xB7\xB9\xA0\x87\xBE\xA8\xBE\xB2\xBC\xBA\xBA\xBF\x95\x90\x82\x8E\x80\x85\x93\x87\x9B\x93\xB4\x9C\x82\x87\x81\x84" + 0x803D9D6F).s, cvar.rainbow_grenade_trajectory_point);
	Sakura::Cvar::New(/*rainbow_route_line*/XorStr<0x0A, 19, 0xC6D0B5A4>("\x78\x6A\x65\x63\x6C\x60\x67\x4E\x60\x7C\x61\x61\x73\x48\x74\x70\x74\x7E" + 0xC6D0B5A4).s, cvar.rainbow_route_line);
	Sakura::Cvar::New(/*rainbow_route_point*/XorStr<0xA3, 20, 0x60B5A1FF>("\xD1\xC5\xCC\xC8\xC5\xC7\xDE\xF5\xD9\xC3\xD8\xDA\xCA\xEF\xC1\xDD\xDA\xDA\xC1" + 0x60B5A1FF).s, cvar.rainbow_route_point);
	Sakura::Cvar::New(/*rainbow_local_history*/XorStr<0x33, 22, 0x1A13A753>("\x41\x55\x5C\x58\x55\x57\x4E\x65\x57\x53\x5E\x5F\x53\x1F\x29\x2B\x30\x30\x2A\x34\x3E" + 0x1A13A753).s, cvar.rainbow_local_history);
	Sakura::Cvar::New(/*rainbow_backtrack_light*/XorStr<0x79, 24, 0x9C99EFA2>("\x0B\x1B\x12\x12\x1F\x11\x08\xDF\xE3\xE3\xE0\xEF\xF1\xF4\xE6\xEB\xE2\xD5\xE7\xE5\xEA\xE6\xFB" + 0x9C99EFA2).s, cvar.rainbow_backtrack_light);
	Sakura::Cvar::New(/*rainbow_backtrack_chams*/XorStr<0x3E, 24, 0x945BDD1F>("\x4C\x5E\x29\x2F\x20\x2C\x33\x1A\x24\x26\x2B\x22\x3E\x39\x2D\x2E\x25\x10\x33\x39\x33\x3E\x27" + 0x945BDD1F).s, cvar.rainbow_backtrack_chams);
	Sakura::Cvar::New(/*rainbow_world_light*/XorStr<0x2A, 20, 0xC6305B56>("\x58\x4A\x45\x43\x4C\x40\x47\x6E\x45\x5C\x46\x59\x52\x68\x54\x50\x5D\x53\x48" + 0xC6305B56).s, cvar.rainbow_world_light);
	Sakura::Cvar::New(/*rainbow_deathmark_glow*/XorStr<0xBD, 23, 0x1EDBD8A3>("\xCF\xDF\xD6\xAE\xA3\xAD\xB4\x9B\xA1\xA3\xA6\xBC\xA1\xA7\xAA\xBE\xA6\x91\xA8\xBC\xBE\xA5" + 0x1EDBD8A3).s, cvar.rainbow_deathmark_glow);
	Sakura::Cvar::New(/*rainbow_skeleton_tt*/XorStr<0x37, 20, 0x6AC76E17>("\x45\x59\x50\x54\x59\x53\x4A\x61\x4C\x2B\x24\x2E\x26\x30\x2A\x28\x18\x3C\x3D" + 0x6AC76E17).s, cvar.rainbow_skeleton_tt);
	Sakura::Cvar::New(/*rainbow_skeleton_ct*/XorStr<0xC1, 20, 0x6D86DD10>("\xB3\xA3\xAA\xAA\xA7\xA9\xB0\x97\xBA\xA1\xAE\xA0\xA8\xBA\xA0\xBE\x8E\xB1\xA7" + 0x6D86DD10).s, cvar.rainbow_skeleton_ct);
	Sakura::Cvar::New(/*rainbow_box_tt*/XorStr<0x23, 15, 0x0A336B14>("\x51\x45\x4C\x48\x45\x47\x5E\x75\x49\x43\x55\x71\x5B\x44" + 0x0A336B14).s, cvar.rainbow_box_tt);
	Sakura::Cvar::New(/*rainbow_box_ct*/XorStr<0x69, 15, 0x49898D60>("\x1B\x0B\x02\x02\x0F\x01\x18\x2F\x13\x1D\x0B\x2B\x16\x02" + 0x49898D60).s, cvar.rainbow_box_ct);
	Sakura::Cvar::New(/*rainbow_world_box*/XorStr<0xC1, 18, 0x68AE589A>("\xB3\xA3\xAA\xAA\xA7\xA9\xB0\x97\xBE\xA5\xB9\xA0\xA9\x91\xAD\xBF\xA9" + 0x68AE589A).s, cvar.rainbow_world_box);
	Sakura::Cvar::New(/*rainbow_world_bone*/XorStr<0xDC, 19, 0x44790CAB>("\xAE\xBC\xB7\xB1\x82\x8E\x95\xBC\x93\x8A\x94\x8B\x8C\xB6\x88\x84\x82\x88" + 0x44790CAB).s, cvar.rainbow_world_bone);
	Sakura::Cvar::New(/*rainbow_world_hitbox*/XorStr<0xA8, 21, 0x98751926>("\xDA\xC8\xC3\xC5\xCE\xC2\xD9\xF0\xC7\xDE\xC0\xDF\xD0\xEA\xDE\xDE\xCC\xDB\xD5\xC3" + 0x98751926).s, cvar.rainbow_world_hitbox);
	Sakura::Cvar::New(/*rainbow_world_maplight*/XorStr<0xF1, 23, 0x66E0F8D9>("\x83\x93\x9A\x9A\x97\x99\x80\xA7\x8E\x95\x89\x90\x99\xA1\x92\x61\x71\x6E\x6A\x63\x6D\x72" + 0x66E0F8D9).s, cvar.rainbow_world_maplight);
	Sakura::Cvar::New(/*rainbow_local_glow*/XorStr<0x89, 19, 0xB62A5F4A>("\xFB\xEB\xE2\xE2\xEF\xE1\xF8\xCF\xFD\xFD\xF0\xF5\xF9\xC9\xF0\xF4\xF6\xED" + 0xB62A5F4A).s, cvar.rainbow_local_glow);
	Sakura::Cvar::New(/*rainbow_hud*/XorStr<0x8C, 12, 0x8E8585F0>("\xFE\xEC\xE7\xE1\xF2\xFE\xE5\xCC\xFC\xE0\xF2" + 0x8E8585F0).s, cvar.rainbow_hud);
}

void SaveCvar()
{
	std::ofstream ofs(Sakura::File::GetSakuraDir(Sakura::Config::GetCurrent().c_str()).c_str());
	Sakura::Config::Save(ofs);
	ofs.close();
}

void LoadCvar()
{
	cvar.init();
	if (Sakura::File::Exists(Sakura::File::GetSakuraDir(Sakura::Config::GetCurrent().c_str()).c_str()))
		Sakura::Config::Load();
}
```

`sakura/source/config/cvar.hpp`:

```hpp
#ifndef _CVARS_
#define _CVARS_

class CVARlist
{
public:
	void init();

	float rage_active;
	float rage_wall;
	float rage_fov;
	float rage_target_selection;
	float rage_perfect_silent;
	float rage_silent;
	float rage_knife_attack;
	float rage_shield_attack;
	float rage_nospread_method;
	float rage_auto_fire;
	float rage_auto_fire_key;
	float rage_team;
	float rage_always_fire;
	float rage_draw_aim;
	float rage_no_spread;
	float rage_no_spread_visual;
	float rage_no_spread_visual_strength;
	float rage_no_recoil;
	float rage_tapping_mode;

	float rage_antiaim_active;

	float aim_id_mode;

	struct legit_weapons
	{
		float active;
		float speed;
		float speed_scale_fov;
		float reaction_time;
		float humanize;
		float recoil_compensation_pitch;
		float recoil_compensation_yaw;
		float recoil_compensation_after_shots_fired;
		float recoil_compensation_fov;
		float recoil_compensation_smooth;
		float block_attack_after_kill;
		float accuracy;
		float perfect_silent_fov;
		float perfect_silent_enable;
		float perfect_silent_spread;
		float fov;
		float speed_in_attack;
		float hitbox;

		float trigger_active;
		float trigger_wall;
		float trigger_accuracy;
		float trigger_delay_shot;
		float trigger_shot_count;
		float trigger_shot_type;
		float trigger_random_max;
		float trigger_hitbox;
	} legit[31];

	struct rage_weapons
	{
		float rage_delay_shot;
		float rage_shot_count;
		float rage_shot_type;
		float rage_random_max;
		float rage_hitbox;
	} rage[31];

	float legit_trigger_only_zoom;
	float legit_trigger_team;
	float legit_trigger_key;
	float legit_trigger_draw_aim; 

	float legit_fastzoom;
	float legit_key;
	float legit_team;
	float legit_draw_aim;

	float legit_flashcheck;
	float legit_flashcheck_percentage;

	float legit_demochecker_bypass;

	float menu_legit_global_section;
	float menu_legit_sub_section;
	float menu_rage_global_section;
	float menu_rage_sub_section;

	float knifebot_active;
	float knifebot_attack;
	float knifebot_attack_distance;
	float knifebot_attack2_distance;
	float knifebot_silent;
	float knifebot_perfect_silent;
	float knifebot_fov;
	float knifebot_team;
	float knifebot_draw_aim;
	float knifebot_hitbox;

	float bypass_trace_rage;
	float bypass_trace_legit;
	float bypass_trace_trigger;
	float bypass_trace_knife;

	float aa_pitch;
	float aa_edge;
	float aa_yaw;
	float aa_yaw_static;
	float aa_yaw_while_running;
	float aa_yaw_jitter_custom;
	float aa_yaw_jitter_angle;
	float aa_yaw_jitter_much;
	float aa_roll_active;
	float aa_roll;
	float aa_roll_static;
	float aa_roll_while_running;

	float fakelag_active;
	float fakelag_while_shooting;
	float fakelag_move;
	float fakelag_type;
	float fakelag_limit;
	float fakelag_variance;

	float speedhack_active;
	float speedhack_speed;

	float antiss_active;
	float antiss_minmodels;

	float misc_wav_speed;
	float misc_thirdperson_key;
	float misc_namestealer;
	float misc_namestealer_time;
	float misc_namestealer_playerlist;
	float misc_namestealer_specs;
	float misc_chatspammer;
	float misc_chatspammer_time;
	float misc_fire_sounds;
	float misc_fire_sounds_volume;
	float misc_fire_sounds_pitch;
	float misc_block_motd;
	float misc_skipframes;
	float misc_skipframes_count;

	float misc_fakelatency;
	float misc_fakelatency_amount;
	float misc_backtrack_chams;
	float misc_backtrack_wireframe;
	float misc_backtrack_wireframe_line_width;
	float misc_backtrack_wireframe_point_size;
	float misc_backtrack_wireframe_mode;
	float misc_backtrack_chams_color[4];
	float misc_backtrack_light;
	float misc_backtrack_light_color[4];

	float misc_auto_config_save;
	float misc_default_config;

	float misc_fastswitch;
	//float misc_fastswitch_delay;

	float notifications_enable;
	float notifications_fade;
	float notifications_text_only;
	float notifications_x;
	float notifications_y;
	float notifications_text_color[4];
	float notifications_bg_color[4];
	float notifications_bg_time_color[4];

	float kz_strafe;
	float kz_strafe_psilent;
	float kz_fast_run;
	float kz_ground_strafe;
	float kz_bhop;
	float kz_bhop_frames_on_ground;
	float kz_bhop_ideal_percentage;
	float kz_jump_bug;
	float kz_jump_bug_auto;
	float kz_show_kz;
	float kz_display_time;
	float kz_strafe_key;
	float kz_fastrun_key;
	float kz_ground_strafe_key;
	float kz_bhop_key;
	float kz_jumpbug_key;
	float kz_strafe_toggle_key;
	float kz_sgs;
	float kz_sgs_ground_origin;

	float route_mode;
	float route_auto;
	float route_jump;
	float route_jump_step;
	float route_direction;
	float route_direction_step;
	float route_draw_visual;
	float route_draw;
	float route_rush_key;
	float route_activate;
	float route_line_color[4];
	float route_point_color[4];

	float visual_model_hitbox;

	float visual_name;
	float visual_name_world;

	float visual_model;

	float visual_model_world;

	float visual_weapon;

	float visual_reload_bar;

	float visual_box;
	float visual_box_color_ct[4];
	float visual_box_color_tt[4];
	float visual_box_draw;
	float visual_box_type;
	float visual_box_fill;
	float visual_box_world;
	float visual_box_world_type;
	float visual_box_world_color[4];
	float visual_box_world_fill;

	float visual_health;

	float visual_visual_team;

	float visual_sound_steps;
	float visual_sound_steps_segments;
	float visual_sound_steps_segment_thickness;
	float visual_sound_steps_radius;
	float visual_sound_steps_color[4];
	float visual_sound_steps_color_tt[4];
	float visual_sound_steps_color_ct[4];

	float visual_idhook_only;

	float visual_chase_cam;
	float visual_chase_back;
	float visual_chase_up;

	float visual_grenade_trajectory;
	float visual_grenade_trajectory_line_color[4];
	float visual_grenade_trajectory_point_color[4];

	float visual_crosshair;
	float visual_crosshair_color[4];

	float visual_vip;

	float visual_weapon_local;
	float visual_weapon_noanim;

	float visual_lightmap;
	float visual_lightmap_color[4];

	float visual_sky;
	float visual_skins_player;
	float visual_skins_player_weapon;
	float visual_skins_player_backweapon;
	float visual_skins_backpack;
	float visual_skins_thighpack;
	float visual_skins_viewmodel;
	float visual_skins_viewmodel_color[4];
	float visual_skins_viewmodel_hands;
	float visual_skins_viewmodel_nohands;
	float visual_skins_world;
	float visual_skins_bullet_shell;
	float visual_skins_wall;
	float visual_skins_chicken;

	float visual_viewmodel_fov;
	float visual_hud;
	float visual_hud_color[4];

	float visual_lambert;
	float visual_lambert_color_tt[4];
	float visual_lambert_color_ct[4];
	float visual_lambert_local;
	float visual_lambert_color_local[4];
	float visual_lambert_world;
	float visual_lambert_world_color[4];
	float visual_lambert_viewmodel;
	float visual_lambert_viewmodel_color[4];
	
	float visual_player_dynamiclight;
	float visual_player_dynamiclight_radius;
	float visual_player_dynamiclight_fading;
	float visual_player_dynamiclight_fading_speed;
	float visual_player_dynamiclight_color_tt[4];
	float visual_player_dynamiclight_color_ct[4];

	float visual_tg_type;

	float visual_draw_fov;
	float visual_draw_fov_color[4];

	float visual_noflash_enable;
	float visual_noflash_color[4];

	float visual_lines;
	float visual_lines_thickness;
	float visual_lines_color_tt[4];
	float visual_lines_color_ct[4];
	float visual_hud_clear;

	float visual_bullet_trace;
	float visual_bullet_trace_local;
	float visual_bullet_trace_local_color[4];
	float visual_bullet_trace_local_thickness;
	float visual_bullet_trace_local_liveness;

	float visual_line_of_sight;
	float visual_line_of_sight_color[4];
	float visual_line_of_sight_distance;

	float visual_menu_color[4];

	float visual_menu_color_header[4];
	float visual_menu_color_items[4];
	float visual_menu_color_footer[4];
	float visual_menu_color_widgets[4];
	float visual_menu_color_tab_selected[4];
	float visual_menu_color_subtab_selected[4];
	float visual_menu_color_logo[4];
	float visual_menu_color_footer_text[4];
	float visual_menu_raining;
	float visual_menu_raining_count;
	float visual_menu_raining_type;
	float visual_menu_raining_speed_multipler;
	float visual_menu_bg_opacity;
	float visual_menu_combo_bg_color[4];
	float visual_menu_slider_bg_color[4];

	float visual_fog;
	float visual_fog_density;
	float visual_fog_color[4];

	float visual_nosmoke;

	float visual_player_glow;
	float visual_player_glow_thickness;
	float visual_player_glow_color_ct[4];
	float visual_player_glow_color_tt[4];

	float visual_viewmodel_glow;
	float visual_viewmodel_glow_thickness;
	float visual_viewmodel_glow_color[4];

	float visual_dont_render_players;

	float visual_remove_scope;

	float visual_fakelag_history_local;
	float visual_fakelag_history_local_light;
	float visual_fakelag_history_local_chams;
	float visual_fakelag_history_local_wireframe;
	float visual_fakelag_history_local_wireframe_line_width;
	float visual_fakelag_history_local_wireframe_point_size;
	float visual_fakelag_history_local_wireframe_mode;
	float visual_fakelag_history_local_light_color[4];
	float visual_fakelag_history_local_chams_color[4];

	float visual_deathmark_enable;
	float visual_deathmark_seconds;
	float visual_deathmark_transparency;
	float visual_deathmark_glow;
	float visual_deathmark_color[4];
	
	float skeleton_player_bone;
	float skeleton_player_bone_color_tt[4];
	float skeleton_player_bone_color_ct[4];
	float skeleton_player_hitbox;
	float skeleton_player_hitbox_color_tt[4];
	float skeleton_player_hitbox_color_ct[4];
	float skeleton_view_model_hitbox;
	float skeleton_view_model_hitbox_color[4];
	float skeleton_world_bone;
	float skeleton_world_bone_color[4];
	float skeleton_world_hitbox;
	float skeleton_world_hitbox_color[4];

	float gui_key;

	float radio_kill_sound;
	float radio_kill_volume;

	float afk_anti;
	float afk_time;
	float afk_yaw;

	float steamid;
	float id1;
	float id2;
	float id3;
	float id4;
	float id5;
	float id6;
	float id7;

	float radar;
	float radar_zoom;
	float radar_point_size;

	float chams_view_model;
	float chams_view_model_wireframe;
	float chams_view_model_wireframe_line_width;
	float chams_view_model_wireframe_point_size;
	float chams_view_model_wireframe_mode;
	float chams_player;
	float chams_player_wireframe;
	float chams_player_wireframe_line_width;
	float chams_player_wireframe_point_size;
	float chams_player_wireframe_mode;
	float chams_player_color_tt[4];
	float chams_player_color_ct[4];
	float chams_player_wall;
	float chams_player_wall_color_tt[4];
	float chams_player_wall_color_ct[4];
	float chams_world;
	float chams_world_wireframe;
	float chams_world_wireframe_line_width;
	float chams_world_wireframe_point_size;
	float chams_world_wireframe_mode;
	float chams_world_color[4];
	float chams_world_wall;
	float chams_world_wall_color[4];
	float chams_local;
	float chams_local_wireframe;
	float chams_local_wireframe_line_width;
	float chams_local_wireframe_point_size;
	float chams_local_wireframe_mode;
	float chams_local_color[4];
	float visual_local_glow;
	float visual_local_glow_thickness;
	float visual_local_glow_color[4];

	float rainbow_player_light_tt;
	float rainbow_player_light_ct;
	float rainbow_viewmodel;
	float rainbow_viewmodel_glow;
	float rainbow_viewmodel_light;
	float rainbow_viewmodel_hitbox;
	float rainbow_snaplines_tt;
	float rainbow_snaplines_ct;
	float rainbow_menu;
	float rainbow_lambert_local;
	float rainbow_chams_local;
	float rainbow_chams_local_fake;
	float rainbow_glow_player_tt;
	float rainbow_glow_player_ct;
	float rainbow_chams_player_tt;
	float rainbow_chams_player_ct;
	float rainbow_chams_world;
	float rainbow_route_line;
	float rainbow_route_point;
	float rainbow_grenade_trajectory_line;
	float rainbow_grenade_trajectory_point;
	float rainbow_local_history;
	float rainbow_local_glow;
	float rainbow_backtrack_light;
	float rainbow_backtrack_chams;
	float rainbow_world_light;
	float rainbow_deathmark_glow;
	float rainbow_skeleton_tt;
	float rainbow_skeleton_ct;
	float rainbow_box_tt;
	float rainbow_box_ct;
	float rainbow_world_box;
	float rainbow_world_bone;
	float rainbow_world_hitbox;
	float rainbow_world_maplight;
	float rainbow_hud;
};

extern CVARlist cvar;

struct Entry
{
	void* data;
};

namespace Sakura
{
	namespace Config
	{
		extern int SelectedConfig;
		extern int DefaultConfig;
		extern int ConfigCount;

		extern std::vector<std::string> List;

		void GetAll();
		void GetDefault();
		void SaveDefault();

		std::string GetCurrent();

		void Save(std::ofstream& ofs);
		void Load();
	};

	namespace Cvar
	{
		void Add(const char* name, void* data);
		void New(const char* cvarName, float &cvar, float defaultValue = 0.0);
	};

	namespace File
	{
		void Init();
		bool Exists(const char* filename);

		inline std::string GetSakuraDir(const char* basename);
	};
};

extern std::vector<Entry> entries;
extern StringFinder names;

void SaveCvar();
void LoadCvar();

#endif
```

`sakura/source/features/aimbot.cpp`:

```cpp
#include "../client.h"

std::deque<playeraim_t> PlayerAim;
std::deque<playeraimlegit_t> PlayerAimLegit;

DWORD dwReactionTime;

float Sakura::Aimbot::m_flCurrentFOV;

float Sakura::Aimbot::AngleBetween(Vector& v1, Vector& v2)
{
	Vector v4 = v2.Normalized();
	Vector v3 = v1.Normalized();

	return acos(DotProduct(v3, v4)) * static_cast<float>(M_PI / 180.0);
}

bool Sakura::Aimbot::IsBoxIntersectingRay(const Vector& boxMin, const Vector& boxMax, const Vector& origin, const Vector& delta)
{
	ASSERT(boxMin[0] <= boxMax[0]);
	ASSERT(boxMin[1] <= boxMax[1]);
	ASSERT(boxMin[2] <= boxMax[2]);

	float tmin = -FLT_MAX;
	float tmax = FLT_MAX;

	for (unsigned int i = 0; i < 3; ++i)
	{
		if (fabs(delta[i]) < 1e-8)
		{
			if ((origin[i] < boxMin[i]) || (origin[i] > boxMax[i]))
				return false;

			continue;
		}

		float invDelta = 1.0f / delta[i];
		float t1 = (boxMin[i] - origin[i]) * invDelta;
		float t2 = (boxMax[i] - origin[i]) * invDelta;
		if (t1 > t2)
		{
			float temp = t1;
			t1 = t2;
			t2 = temp;
		}
		if (t1 > tmin)
			tmin = t1;
		if (t2 < tmax)
			tmax = t2;
		if (tmin > tmax)
			return false;
		if (tmax < 0)
			return false;
	}

	return true;
}

void Sakura::Aimbot::UTIL_TextureHit(Vector vecSrc, Vector vecEnd, Vector vecDir, int ignore, pmtrace_t& tr)
{
	if (vecSrc[0] == vecEnd[0] && vecSrc[1] == vecEnd[1] && vecSrc[2] == vecEnd[2])
	{
		memset(&tr, NULL, sizeof(pmtrace_t));

		tr.endpos = vecEnd;
		tr.fraction = 1.0f;
		return;
	}

	g_Engine.pEventAPI->EV_SetTraceHull(2);
	g_Engine.pEventAPI->EV_PlayerTrace(vecSrc, vecEnd, PM_GLASS_IGNORE, ignore, &tr);

	if (tr.fraction == 0 && tr.startsolid && !tr.allsolid)
	{
		Vector vecTmp = vecSrc;

		while (!tr.allsolid && tr.fraction == 0.f)
		{
			vecTmp = vecTmp + vecDir;

			g_Engine.pEventAPI->EV_SetTraceHull(2);
			g_Engine.pEventAPI->EV_PlayerTrace(vecTmp, vecEnd, PM_WORLD_ONLY, ignore, &tr);
		}

		if (!tr.allsolid && tr.fraction != 1.0f)
		{
			vecTmp = vecEnd - vecSrc;

			float Length1 = vecTmp.Length();

			vecTmp = tr.endpos - vecSrc;

			float Length2 = vecTmp.Length();

			tr.fraction = Length1 / Length2;
			tr.startsolid = 1.0f;
		}
	}

	if (tr.allsolid)
		tr.fraction = 1.0f;
}

int Sakura::Aimbot::FireBullets(Vector start, Vector end, float flDistance, int iOriginalPenetration, int iBulletType, int iDamage, float flRangeModifier)
{
	Vector vecSrc, vecEnd, vecDir, vecTmp;
	int iPenetration = iOriginalPenetration + 1;
	int iPenetrationPower;
	int iCurrentDamage = iDamage;
	float flPenetrationDistance;
	float flCurrentDistance;

	pmtrace_t tr;
	vecSrc = start;
	vecEnd = end;

	switch (iBulletType)
	{
	case BULLET_PLAYER_9MM:
		iPenetrationPower = 21;
		flPenetrationDistance = 800;
		break;
	case BULLET_PLAYER_45ACP:
		iPenetrationPower = 15;
		flPenetrationDistance = 500;
		break;
	case BULLET_PLAYER_50AE:
		iPenetrationPower = 30;
		flPenetrationDistance = 1000;
		break;
	case BULLET_PLAYER_762MM:
		iPenetrationPower = 39;
		flPenetrationDistance = 5000;
		break;
	case BULLET_PLAYER_556MM:
		iPenetrationPower = 35;
		flPenetrationDistance = 4000;
		break;
	case BULLET_PLAYER_338MAG:
		iPenetrationPower = 45;
		flPenetrationDistance = 8000;
		break;
	case BULLET_PLAYER_57MM:
		iPenetrationPower = 30;
		flPenetrationDistance = 2000;
		break;
	case BULLET_PLAYER_357SIG:
		iPenetrationPower = 25;
		flPenetrationDistance = 800;
		break;
	default:
		iPenetrationPower = 0;
		flPenetrationDistance = 0;
		break;
	}

	vecDir = vecEnd - vecSrc;

	float Length = vecDir.Length();

	vecDir /= Length;

	vecEnd = vecDir * flDistance + vecSrc;

	float flDamageModifier = 0.5;

	while (iPenetration)
	{
		UTIL_TextureHit(vecSrc, vecEnd, vecDir, -1, tr);

		char cTextureType = Sakura::Texture::GetTextureType(&tr, vecSrc, vecEnd);

		switch (cTextureType)
		{
		case CHAR_TEX_CONCRETE:
			iPenetrationPower *= 0.25;
			break;
		case CHAR_TEX_GRATE:
			iPenetrationPower *= 0.5;
			flDamageModifier = 0.4;
			break;
		case CHAR_TEX_METAL:
			iPenetrationPower *= 0.15;
			flDamageModifier = 0.2;
			break;
		case CHAR_TEX_COMPUTER:
			iPenetrationPower *= 0.4;
			flDamageModifier = 0.45;
			break;
		case CHAR_TEX_TILE:
			iPenetrationPower *= 0.65;
			flDamageModifier = 0.3;
			break;
		case CHAR_TEX_VENT:
			iPenetrationPower *= 0.5;
			flDamageModifier = 0.45;
			break;
		case CHAR_TEX_WOOD:
			flDamageModifier = 0.6;
			break;
		default:
			break;
		}

		if (tr.fraction != 1.0)
		{
			iPenetration--;

			vecTmp = tr.endpos - start;

			float tmplen = vecTmp.Length();

			if (tmplen >= Length)
			{
				vecTmp = end - vecSrc;

				float Length1 = vecTmp.Length();

				vecTmp = vecEnd - vecSrc;

				float Length2 = vecTmp.Length();

				tr.fraction = Length1 / Length2;

				flCurrentDistance = flDistance * tr.fraction;

				iCurrentDamage *= pow(flRangeModifier, flCurrentDistance / 500);

				return iCurrentDamage;
			}

			flCurrentDistance = flDistance * tr.fraction;

			iCurrentDamage *= pow(flRangeModifier, flCurrentDistance / 500);

			if (flCurrentDistance > flPenetrationDistance)
				iPenetration = 0;

			if (iPenetration)
			{
				vecSrc = iPenetrationPower * vecDir + tr.endpos;

				flDistance = (flDistance - flCurrentDistance) * 0.5;

				vecEnd = vecDir * flDistance + vecSrc;

				flCurrentDistance = iCurrentDamage;

				iCurrentDamage = flCurrentDistance * flDamageModifier;
			}
			else
			{
				vecSrc = 42 * vecDir + tr.endpos;

				flDistance = (flDistance - flCurrentDistance) * 0.75;

				vecEnd = vecDir * flDistance + vecSrc;

				iCurrentDamage *= 0.75;
			}
		}
		else iPenetration = 0;
	}
	return 0;
}

void Sakura::Aimbot::Logic(usercmd_s* cmd)
{
	Sakura::Triggerbot::iTargetTrigger = 0;
	Sakura::Aimbot::Legit::iTargetLegit = 0;
	Sakura::Knifebot::iTargetKnife = 0;
	Sakura::Aimbot::Rage::iTargetRage = 0;

	if (GetTickCount() - HudRedraw <= 100)
	{
		if (cvar.rage_active)
		{
			Sakura::Aimbot::Rage::Aim(cmd);
			return;
		}

		Sakura::Aimbot::Legit::Aim(cmd);
		Sakura::Triggerbot::Trigger(cmd);
		Sakura::Knifebot::Knife(cmd);
	}
}

void Sakura::Aimbot::Draws()
{
	if (cvar.rage_active)
	{
		Sakura::Aimbot::Rage::Draw();
		return;
	}

	if (cvar.legit[g_Local.weapon.m_iWeaponID].active)
		Sakura::Aimbot::Legit::Draw();
	else
		Sakura::Triggerbot::Draw();

	Sakura::Knifebot::Draw();
}

void ContinueFire(usercmd_s* cmd) // auto pistol
{
	if (cvar.rage_active && cmd->buttons & IN_ATTACK && IsCurWeaponPistol() && !g_Local.weapon.m_iInReload)
	{
		static bool bFire = false;

		if (CanAttack() && bFire)
		{
			cmd->buttons |= IN_ATTACK;
			bFire = false;
		}
		else if (!bFire)
		{
			cmd->buttons &= ~IN_ATTACK;
			bFire = true;
		}
	}
}
```

`sakura/source/features/aimbot.h`:

```h
#ifndef _AIMBOT_
#define _AIMBOT_

namespace Sakura
{
	namespace Aimbot
	{
		extern float m_flCurrentFOV;

		void UTIL_TextureHit(Vector vecSrc, Vector vecEnd, Vector vecDir, int ignore, pmtrace_t& tr);
		int FireBullets(Vector start, Vector end, float flDistance, int iOriginalPenetration, int iBulletType, int iDamage, float flRangeModifier);
		float AngleBetween(Vector& v1, Vector& v2);
		bool IsBoxIntersectingRay(const Vector& boxMin, const Vector& boxMax, const Vector& origin, const Vector& delta);

		void Logic(usercmd_s* cmd);
		void Draws();
	};
};

typedef struct
{
	float HitboxFOV;
	Vector Hitbox;
	float HitboxPointsFOV[8];
	Vector HitboxMulti[8];
} playeraimhitbox_t;

typedef struct
{
	int sequence;
	int index;
	char modelname[MAX_MODEL_NAME];
	Vector origin;
	std::deque<playeraimhitbox_t> PlayerAimHitbox;
} playeraim_t;
extern std::deque<playeraim_t> PlayerAim;

typedef struct
{
	int numhitbox;
	char displaymodel[MAX_QPATH];
	char checkmodel[MAX_QPATH]; 
	int m_iWeaponID;
} playeraimlegit_t;
extern std::deque<playeraimlegit_t> PlayerAimLegit;

//typedef struct
//{
//	int numhitbox;
//	char displaymodel[MAX_QPATH];
//	char checkmodel[MAX_QPATH];
//} model_aim_select_t;
//extern std::deque<model_aim_select_t> Model_Aim_Select;
//
//typedef struct
//{
//	int numhitboxes;
//	char displaymodel[MAX_QPATH];
//	char checkmodel[MAX_QPATH];
//} model_aim_t;
//extern std::deque<model_aim_t> Model_Aim;

static BYTE SkeletonHitboxMatrix[12][2] = { {0,1},{1,2},{2,3},{2,4},{4,5},{5,6},{6,7},{1,5},{0,6},{3,7},{7,4},{0,3}, };
extern DWORD dwReactionTime;
//extern bool TriggerKeyStatus;
//extern bool LegitKeyStatus;
//extern bool RageKeyStatus;

//extern int iTargetTrigger;
//extern int iTargetLegit;
//extern int iTargetRage;
//extern int iTargetKnife;

extern float m_flCurrentFOV;

//void AimBot(struct usercmd_s* cmd);
//void DrawAimBotFOV();
void ContinueFire(usercmd_s* cmd);
//void DrawAimbot();
//void SmoothAimAngles(QAngle MyViewAngles, QAngle AimAngles, QAngle& OutAngles, float Smoothing, bool bSpiral, float SpiralX, float SpiralY);
//int FireBullets(Vector start, Vector end, float flDistance, int iOriginalPenetration, int iBulletType, int iDamage, float flRangeModifier);
//bool IsBoxIntersectingRay(const Vector& boxMin, const Vector& boxMax, const Vector& origin, const Vector& delta);

#endif
```

`sakura/source/features/hns/bhop.cpp`:

```cpp
#include "../../client.h"

int Sakura::HNS::BunnyHop::FramesOnGround = 0;
bool Sakura::HNS::BunnyHop::Active = false;

// TODO: Add scroll emulation.
void Sakura::HNS::BunnyHop::Logic(usercmd_s* cmd)
{
	if (!cvar.kz_bhop)
		return;

	if (!Active)
		return;

	cmd->buttons &= ~IN_JUMP;

	if (pmove->flags & FL_ONGROUND)
	{
		int randPercentage = rand() % 100;

		if (randPercentage <= cvar.kz_bhop_ideal_percentage)
		{
			cmd->buttons |= IN_JUMP;
			return;
		}

		FramesOnGround++;

		if (FramesOnGround >= cvar.kz_bhop_frames_on_ground)
			cmd->buttons |= IN_JUMP;
	}
	else
		FramesOnGround = 0;
}
```

`sakura/source/features/hns/bhop.h`:

```h
#pragma once

namespace Sakura
{
	namespace HNS
	{
		namespace BunnyHop
		{
			extern int FramesOnGround;
			extern bool Active;

			void Logic(usercmd_s* cmd);
		};
	};
};
```

`sakura/source/features/hns/fastrun.cpp`:

```cpp
#include "../../client.h"

bool Sakura::HNS::Fastrun::Active = false;

void Sakura::HNS::Fastrun::Logic(usercmd_s* cmd)
{
	if (!cvar.kz_fast_run)
		return;

	if (!Active)
		return;

	if (!pmove->velocity.Length2D())
		return;

	if (pmove->flFallVelocity != 0)
		return;

	if (Sakura::HNS::Groundstrafe::Active)
		return;

	if (pmove->flags & FL_ONGROUND)
	{
		static bool Run = false;
		if ((cmd->buttons & IN_FORWARD && cmd->buttons & IN_MOVELEFT) || (cmd->buttons & IN_BACK && cmd->buttons & IN_MOVERIGHT))
		{
			if (Run)
			{
				Run = false;
				cmd->sidemove -= 89.6f;
				cmd->forwardmove -= 89.6f;
			}
			else
			{
				Run = true;
				cmd->sidemove += 89.6f;
				cmd->forwardmove += 89.6f;
			}
		}
		else if ((cmd->buttons & IN_FORWARD && cmd->buttons & IN_MOVERIGHT) || (cmd->buttons & IN_BACK && cmd->buttons & IN_MOVELEFT))
		{
			if (Run)
			{
				Run = false;
				cmd->sidemove -= 89.6f;
				cmd->forwardmove += 89.6f;
			}
			else
			{
				Run = true;
				cmd->sidemove += 89.6f;
				cmd->forwardmove -= 89.6f;
			}
		}
		else if (cmd->buttons & IN_FORWARD || cmd->buttons & IN_BACK)
		{
			if (Run)
			{
				Run = false;
				cmd->sidemove -= 126.6f;
			}
			else
			{
				Run = true;
				cmd->sidemove += 126.6f;
			}
		}
		else if (cmd->buttons & IN_MOVELEFT || cmd->buttons & IN_MOVERIGHT)
		{
			if (Run)
			{
				Run = false;
				cmd->forwardmove -= 126.6f;
			}
			else
			{
				Run = true;
				cmd->forwardmove += 126.6f;
			}
		}
	}
}
```

`sakura/source/features/hns/fastrun.h`:

```h
#pragma once

namespace Sakura
{
	namespace HNS
	{
		namespace Fastrun
		{
			extern bool Active;

			void Logic(usercmd_s* cmd);
		}
	};
};
```

`sakura/source/features/hns/groundstrafe.cpp`:

```cpp
#include "../../client.h"

int Sakura::HNS::Groundstrafe::State = 0;
bool Sakura::HNS::Groundstrafe::Active = false;

void Sakura::HNS::Groundstrafe::Logic(usercmd_s* cmd)
{
	if (!cvar.kz_ground_strafe)
		return;

	if (!Active)
		return;

	if (cvar.kz_sgs && g_Local.flHeightorigin < cvar.kz_sgs_ground_origin)
		cmd->buttons |= IN_DUCK;

	switch (State)
	{
	case 0:
		if (pmove->flags & FL_ONGROUND)
		{
			cmd->buttons |= IN_DUCK;
			State = 1;
		}
		break;
	case 1:
		cmd->buttons &= ~IN_DUCK;
		State = 0;
		break;
	}
}
```

`sakura/source/features/hns/groundstrafe.h`:

```h
#pragma once

namespace Sakura
{
	namespace HNS
	{
		namespace Groundstrafe
		{
			extern int State;
			extern bool Active;

			void Logic(usercmd_s* cmd);
		};
	};
};
```

`sakura/source/features/hns/jumpbug.cpp`:

```cpp
#include "../../client.h"

int Sakura::HNS::Jumpbug::State = 0;
bool Sakura::HNS::Jumpbug::Active = false;

double _my_abs(double n)
{
	if (n >= 0)return n; //if positive, return without ant change
	else return 0 - n; //if negative, return a positive version
}

void Sakura::HNS::Jumpbug::Logic(float frametime, usercmd_s* cmd)
{
	if (!cvar.kz_jump_bug)
		return;

	bool jbAuto = false;

	if (cvar.kz_jump_bug_auto && pmove->flFallVelocity >= 404.8f)
		jbAuto = true;

	if (!Active && !jbAuto)
		return;

	if (pmove->flFallVelocity > 0 || jbAuto)
	{
		bool curveang = false;
		float fpheight = 0;

		if (g_Local.flGroundangle > 1 && g_Local.flHeightorigin <= 60)
		{
			curveang = true;
			Vector vTemp = pmove->origin;
			vTemp[2] -= 8192;
			pmtrace_t* trace = g_Engine.PM_TraceLine(pmove->origin, vTemp, 1, 2, -1);
			fpheight = abs(pmove->origin.z - trace->endpos.z - (pmove->flags & FL_DUCKING) ? 18.0f : 36.0f);
		}
		else
			fpheight = g_Local.flHeightorigin;

		static float last_h = 0.0f;
		float cur_frame_zdist = abs((pmove->flFallVelocity + (800 * frametime)) * frametime);

		cmd->buttons |= IN_DUCK;
		cmd->buttons &= ~IN_JUMP;

		switch (State)
		{
		case 1:
			cmd->buttons &= ~IN_DUCK;
			cmd->buttons |= IN_JUMP;
			State = 2;
			break;
		case 2:
			State = 0;
			break;
		default:
			if (_my_abs(fpheight - cur_frame_zdist * 1.5) <= (20.0) && cur_frame_zdist > 0.0f)
			{
				float needspd = _my_abs(fpheight - (19.0));
				float scale = abs(needspd / cur_frame_zdist);
				AdjustSpeed(scale);
				State = 1;
			}
			break;
		}
		last_h = fpheight;
	}
	else 
		State = 0;
}
```

`sakura/source/features/hns/jumpbug.h`:

```h
#pragma once

namespace Sakura
{
	namespace HNS
	{
		namespace Jumpbug
		{
			extern int State;
			extern bool Active;
			
			void Logic(float frametime, usercmd_s* cmd);
		};
	};
};
```

`sakura/source/features/hns/strafe.cpp`:

```cpp
#include "../../client.h"

bool Sakura::HNS::Strafe::Packet = false;
bool Sakura::HNS::Strafe::Active = false;

float FrameCount;
float FpsCount;
float InterpFps;
float PreStrafe;
float JumpOff;

float Keyforwardm = false;
float Keymoveleft = false;
float Keymoveright = false;
float Keyback = false;
float Keyduck = false;
float Keyjump = false;

bool Cstrafe = false;

Vector vStart, vEnd;
Vector vStartjumppos;
float flJumpdist;
float flJumpmesstime;
bool bJumped;

float YawForVec(float* fwd)
{
	if (fwd[1] == 0 && fwd[0] == 0)
		return 0;
	else
	{
		float yaw = atan2(fwd[1], fwd[0]) * (180 / M_PI);
		if (yaw < 0)yaw += 360;
		return yaw;
	}
}

inline float EndSpeed(float StartSpeed, float gravity, float frametime, float distance)
{
	while (distance > 0)
	{
		StartSpeed += gravity * frametime;
		float dist = StartSpeed * frametime;
		distance -= dist;
	}
	return StartSpeed;
}

inline float interp(float s1, float s2, float s3, float f1, float f3)
{
	if (s2 == s1)return f1;
	if (s2 == s3)return f3;
	if (s3 == s1)return f1;
	return f1 + ((s2 - s1) / (s3 - s1)) * ((f3 - f1)/*/1*/);
}

float Damage()
{
	Vector start = pmove->origin;
	Vector vForward, vecEnd;
	float va[3];
	g_Engine.GetViewAngles(va);
	g_Engine.pfnAngleVectors(va, vForward, NULL, NULL);
	vecEnd[0] = start[0] + vForward[0] * 8192; vecEnd[1] = start[1] + vForward[1] * 8192; vecEnd[2] = start[2] + vForward[2] * 8192;
	pmtrace_t* trace = g_Engine.PM_TraceLine(start, vecEnd, 1, 2, -1);
	float fDistance = ((start.z) - (trace->endpos.z)) - (pmove->flags & FL_DUCKING) ? 18.0f : 36.0f;
	float endSpeed = EndSpeed(pmove->flFallVelocity, 800, 1 / 1000.0f, fDistance);
	if (interp(504.80001f, endSpeed, 1000, 1, 100) > 0)
		return interp(504.80001f, endSpeed, 1000, 1, 100);
	else return 0;
}

float Damage2()
{
	float endSpeed = EndSpeed(pmove->flFallVelocity, 800, 1 / 1000.0f, g_Local.flHeightorigin);
	if (interp(504.80001f, endSpeed, 1000, 1, 100) > 0)
		return interp(504.80001f, endSpeed, 1000, 1, 100);
	else return 0;
}

void TraceEdge(int x,int y, float& mind)
{
	Vector start = pmove->origin;
	start[2] -= 0.1f;
	Vector end = start;
	end[1] += x * mind;
	end[0] += y * mind;
	pmtrace_s* t1 = g_Engine.PM_TraceLine(end, start, 1, (pmove->flags & FL_DUCKING) ? 1 : 0, -1);
	if (!(t1->startsolid))
		mind = (t1->endpos - start).Length2D();
}

inline float EdgeDistance() 
{
	float mind = 250;
	TraceEdge(-1, 0, mind);
	TraceEdge(1, 0, mind);
	TraceEdge(0, 1, mind);
	TraceEdge(0, -1, mind);
	TraceEdge(-1, -1, mind);
	TraceEdge(1, 1, mind);
	TraceEdge(1, -1, mind);
	TraceEdge(-1, 1, mind);
	return mind;
}

void Kz(float frametime, struct usercmd_s *cmd)
{
	if (bJumped && (pmove->flags & FL_ONGROUND || pmove->movetype == MOVETYPE_FLY))
	{
		Vector endpos = pmove->origin;

		endpos.z -= (pmove->flags & FL_DUCKING) ? 18.0f : 36.0f;
		vEnd = endpos;

		if (endpos.z == vStartjumppos.z)
		{
			Vector lj = endpos - vStartjumppos;
			float dist = lj.Length() + 32.0625f + 0.003613;

			if (dist >= 200)
			{
				InterpFps = FpsCount / FrameCount;
				FpsCount = 0;
				FrameCount = 0;
				flJumpdist = dist;
				flJumpmesstime = GetTickCount() + (int)cvar.kz_display_time * 1000;
			}
		}

		bJumped = false;
	}

	if (!bJumped && (pmove->flags & FL_ONGROUND) && cmd->buttons & IN_JUMP)
	{
		PreStrafe = pmove->velocity.Length2D();

		if (EdgeDistance() != 250)
			JumpOff = EdgeDistance();
		else 
			JumpOff = 0;

		vStartjumppos = pmove->origin;
		vStartjumppos.z -= (pmove->flags & FL_DUCKING) ? 18.0f : 36.0f;
		vStart = vStartjumppos;
		bJumped = true;
	}

	if (cmd->buttons & IN_FORWARD) 
		Keyforwardm = true;
	else 
		Keyforwardm = false;

	if (cmd->buttons & IN_MOVELEFT) 
		Keymoveleft = true;
	else 
		Keymoveleft = false;

	if (cmd->buttons & IN_MOVERIGHT) 
		Keymoveright = true;
	else 
		Keymoveright = false;

	if (cmd->buttons & IN_BACK) 
		Keyback = true;
	else 
		Keyback = false;

	if (cmd->buttons & IN_DUCK) 
		Keyduck = true;
	else 
		Keyduck = false;

	if (cmd->buttons & IN_JUMP) 
		Keyjump = true;
	else 
		Keyjump = false;
}


void Sakura::HNS::Strafe::Logic(usercmd_s* cmd)
{
	if (!cvar.kz_strafe)
		return;

	if (!Active)
		return;

	if (!(pmove->flags & FL_ONGROUND) && (pmove->movetype != MOVETYPE_FLY) && !(cmd->buttons & IN_ATTACK) && !(cmd->buttons & IN_ATTACK2 && IsCurWeaponKnife()))
	{
		if (cvar.kz_strafe_psilent ? !Packet : 1)
		{
			if (cvar.kz_strafe_psilent)
				bSendpacket(false);

			if (pmove->velocity.Length2D() < 15)
				cmd->forwardmove = 400, cmd->sidemove = 0;
			else
			{
				float dir = 0;
				if (cmd->buttons & IN_MOVERIGHT)
					dir = 90;
				if (cmd->buttons & IN_BACK)
					dir = 180;
				if (cmd->buttons & IN_MOVELEFT)
					dir = -90;

				Vector ViewAngles;

				g_Engine.GetViewAngles(ViewAngles);
				ViewAngles.y += dir;

				Vector vspeed = Vector(pmove->velocity.x / pmove->velocity.Length(), pmove->velocity.y / pmove->velocity.Length(), 0.0f);
				float va_speed = YawForVec(vspeed);
				float adif = va_speed - ViewAngles.y;

				while (adif < -180)
					adif += 360;

				while (adif > 180)
					adif -= 360;

				cmd->sidemove = (437.8928) * (adif > 0 ? 1 : -1);
				cmd->forwardmove = 0;
				cmd->viewangles.y -= (-adif);

				float sdmw = cmd->sidemove;
				float fdmw = cmd->forwardmove;

				if (cmd->buttons & IN_MOVERIGHT)
					cmd->forwardmove = -sdmw, cmd->sidemove = fdmw;

				if (cmd->buttons & IN_BACK)
					cmd->forwardmove = -fdmw, cmd->sidemove = -sdmw;

				if (cmd->buttons & IN_MOVELEFT)
					cmd->forwardmove = sdmw, cmd->sidemove = -fdmw;
			}
		}

		if (cvar.kz_strafe_psilent)
			Packet = !Packet;
	}
	else
		Packet = false;
}

void KzFameCount()
{
	if (bJumped)
	{
		FrameCount += 1;
		FpsCount += (1 / pmove->frametime);
	}
}

void DrawKzWindows()
{
	if (!cvar.kz_show_kz)
		return;

	if (!Sakura::Player::Local::IsAlive())
		return;

	ImVec2 windowpos;
	ImGui::PushStyleColor(ImGuiCol_WindowBg, ImVec4(0.0f, 0.0f, 0.0f, 0.25f));
	ImGui::SetNextWindowPos(ImVec2(20, (ImGui::GetIO().DisplaySize.y / 2) - ImGui::GetIO().DisplaySize.y / 20 * 1), ImGuiCond_Once);
	ImGui::Begin(/*kz*/XorStr<0x1C, 3, 0x85263541>("\x77\x67" + 0x85263541).s, NULL, ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_AlwaysAutoResize);
	{
		ImVec4 col_default_text = ImGui::GetStyleColorVec4(ImGuiCol_Text);
		ImVec4 col = col_default_text;
		ImVec4 col2 = col_default_text;
		static float fMaxPspeed = 0.f;
		if (pmove->velocity.Length2D() == 0)
			fMaxPspeed = 0.0;
		if (pmove->velocity.Length2D() > fMaxPspeed)
			fMaxPspeed = pmove->velocity.Length2D();
		if (Damage() >= g_Local.iPostHealth)
			col = ImColor(1.f, 0.f, 0.f, 1.0f);
		if (Damage2() >= g_Local.iPostHealth)
			col2 = ImColor(1.f, 0.f, 0.f, 1.0f);

		if (flJumpmesstime > GetTickCount())
		{
			ImGui::Text(/*Display Time:   %.1f*/XorStr<0x0B, 21, 0xBF337B20>("\x4F\x65\x7E\x7E\x63\x71\x68\x32\x47\x7D\x78\x73\x2D\x38\x39\x3A\x3E\x32\x2C\x78" + 0xBF337B20).s, (flJumpmesstime - GetTickCount()) / 1000);
			ImGui::TextColored(ImVec4(1.f, 0.f, 1.f, 1.f), /*Fps:            %.1f*/XorStr<0x0F, 21, 0x8B186DF7>("\x49\x60\x62\x28\x33\x34\x35\x36\x37\x38\x39\x3A\x3B\x3C\x3D\x3E\x3A\x0E\x10\x44" + 0x8B186DF7).s, InterpFps);
			ImGui::TextColored(ImVec4(1.f, 0.f, 1.f, 1.f), /*Jump Off Edge:  %.1f*/XorStr<0x94, 21, 0x2239080C>("\xDE\xE0\xFB\xE7\xB8\xD6\xFC\xFD\xBC\xD8\xFA\xF8\xC5\x9B\x82\x83\x81\x8B\x97\xC1" + 0x2239080C).s, JumpOff);
			ImGui::TextColored(ImVec4(1.f, 0.f, 1.f, 1.f), /*Jump Distance:  %.1f*/XorStr<0x8B, 21, 0x33B81E82>("\xC1\xF9\xE0\xFE\xAF\xD4\xF8\xE1\xE7\xF5\xFB\xF5\xF2\xA2\xB9\xBA\xBE\xB2\xAC\xF8" + 0x33B81E82).s, flJumpdist);
			ImGui::TextColored(ImVec4(1.f, 0.f, 1.f, 1.f), /*Start speed:    %.1f*/XorStr<0xE9, 21, 0x529406AE>("\xBA\x9E\x8A\x9E\x99\xCE\x9C\x80\x94\x97\x97\xCE\xD5\xD6\xD7\xD8\xDC\xD4\xCA\x9A" + 0x529406AE).s, PreStrafe);
		}
		ImGui::TextColored(col, /*Damage Predict: %.1f*/XorStr<0x1D, 21, 0x4F78E196>("\x59\x7F\x72\x41\x46\x47\x03\x74\x57\x43\x43\x41\x4A\x5E\x11\x0C\x08\x00\x1E\x56" + 0x4F78E196).s, Damage());
		ImGui::TextColored(col2, /*Damage In Fall: %.1f*/XorStr<0x16, 21, 0x883B6354>("\x52\x76\x75\x78\x7D\x7E\x3C\x54\x70\x3F\x66\x40\x4E\x4F\x1E\x05\x03\x09\x19\x4F" + 0x883B6354).s, Damage2());
		ImGui::Text(/*Height:         %.1f*/XorStr<0x47, 21, 0xF990AF3F>("\x0F\x2D\x20\x2D\x23\x38\x77\x6E\x6F\x70\x71\x72\x73\x74\x75\x76\x72\x76\x68\x3C" + 0xF990AF3F).s, g_Local.flHeightorigin);
		ImGui::Text(/*Ground Angle:   %.1f*/XorStr<0x56, 21, 0x89D13536>("\x11\x25\x37\x2C\x34\x3F\x7C\x1C\x30\x38\x0C\x04\x58\x43\x44\x45\x43\x49\x59\x0F" + 0x89D13536).s, g_Local.flGroundangle);
		ImGui::Text(/*Speed:          %.1f*/XorStr<0xCF, 21, 0x2CBEA599>("\x9C\xA0\xB4\xB7\xB7\xEE\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFA\xCE\xD0\x84" + 0x2CBEA599).s, pmove->velocity.Length2D());
		ImGui::Text(/*Speed Max:      %.1f*/XorStr<0x95, 21, 0x0F78A9B9>("\xC6\xE6\xF2\xFD\xFD\xBA\xD6\xFD\xE5\xA4\xBF\x80\x81\x82\x83\x84\x80\x88\x96\xCE" + 0x0F78A9B9).s, fMaxPspeed);
		ImGui::Text(/*Speed In Fall:  %.1f*/XorStr<0xB1, 21, 0xE1D4154E>("\xE2\xC2\xD6\xD1\xD1\x96\xFE\xD6\x99\xFC\xDA\xD0\xD1\x84\x9F\xE0\xE4\xEC\xF2\xA2" + 0xE1D4154E).s, pmove->flFallVelocity);
		ImGui::TextColored(ImVec4(1.f, 0.f, EdgeDistance(), 1.f), /*Edge Distance:  %.1f*/XorStr<0xB7, 21, 0x39A0BD20>("\xF2\xDC\xDE\xDF\x9B\xF8\xD4\xCD\xCB\xA1\xAF\xA1\xA6\xFE\xE5\xE6\xE2\xE6\xF8\xAC" + 0x39A0BD20).s, EdgeDistance());

		windowpos.x = ImGui::GetWindowPos().x + ImGui::GetWindowSize().x + 5;
		windowpos.y = ImGui::GetWindowPos().y;
	}
	ImGui::PopStyleColor();
	ImGui::End();

	ImGui::PushStyleColor(ImGuiCol_WindowBg, ImVec4(0.0f, 0.0f, 0.0f, 0.25f));
	ImGui::SetNextWindowPos(ImVec2(windowpos.x, windowpos.y), ImGuiCond_Always);
	if (ImGui::Begin(/*kzkeys*/XorStr<0x1B, 7, 0xA3E008BE>("\x70\x66\x76\x7B\x66\x53" + 0xA3E008BE).s, NULL, ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_AlwaysAutoResize))
	{
		ImGui::Text("%s", Keyforwardm ? /*  W*/XorStr<0x6F, 4, 0xCB49D5D9>("\x4F\x50\x26" + 0xCB49D5D9).s : " |");
		ImGui::Text("%s %s %s", Keymoveleft ? /*A*/XorStr<0x47, 2, 0xD9F4BA3C>("\x06" + 0xD9F4BA3C).s : /*-*/XorStr<0xD5, 2, 0xA94E7FFD>("\xF8" + 0xA94E7FFD).s, Keyback ? /*S*/XorStr<0x82, 2, 0x68B5B516>("\xD1" + 0x68B5B516).s : /*+*/XorStr<0x6A, 2, 0x5F495829>("\x41" + 0x5F495829).s, Keymoveright ? /*D*/XorStr<0xC0, 2, 0x65A9A911>("\x84" + 0x65A9A911).s : /*-*/XorStr<0x2C, 2, 0xA376F6C0>("\x01" + 0xA376F6C0).s);
		ImGui::Text(Keyduck ? /* Duck*/XorStr<0xB0, 6, 0x3E5E6182>("\x90\xF5\xC7\xD0\xDF" + 0x3E5E6182).s : " |");
		ImGui::Text(Keyjump ? /* Jump*/XorStr<0xED, 6, 0x33BF3C57>("\xCD\xA4\x9A\x9D\x81" + 0x33BF3C57).s : " |");
	}
	ImGui::PopStyleColor();
	ImGui::End();
}
```

`sakura/source/features/hns/strafe.h`:

```h
#ifndef _STRAFE_
#define _STRAFE_

namespace Sakura
{
	namespace HNS
	{
		namespace Strafe
		{
			extern bool Packet;
			extern bool Active;

			void Logic(usercmd_s* cmd);
		};
	};
};

void Kz(float frametime, struct usercmd_s *cmd);
void DrawKzWindows();
void KzFameCount();

#endif
```

`sakura/source/features/legit/knife.cpp`:

```cpp
#include "../../client.h"

int		Sakura::Knifebot::iTargetKnife;
int		Sakura::Knifebot::iHitboxKnife;
Vector	Sakura::Knifebot::vAimOriginKnife;

void Sakura::Knifebot::SelectTarget(playeraim_t Aim, float& m_flBestDist)
{
	pmtrace_t tr;

	g_Engine.pEventAPI->EV_SetTraceHull(2);

	Vector vEye = pmove->origin + pmove->view_ofs;

	if (cvar.bypass_trace_knife)
		g_Engine.pEventAPI->EV_PlayerTrace(vEye, Aim.PlayerAimHitbox[cvar.knifebot_hitbox].Hitbox, PM_WORLD_ONLY, -1, &tr);
	else
		g_Engine.pEventAPI->EV_PlayerTrace(vEye, Aim.PlayerAimHitbox[cvar.knifebot_hitbox].Hitbox, PM_GLASS_IGNORE, -1, &tr);

	int detect = g_Engine.pEventAPI->EV_IndexFromTrace(&tr);

	if ((cvar.bypass_trace_knife && tr.fraction == 1 && !detect) || (!cvar.bypass_trace_knife && detect == Aim.index))
	{
		if (Aim.PlayerAimHitbox[cvar.knifebot_hitbox].HitboxFOV <= cvar.knifebot_fov)
		{
			float fDistance = (Aim.PlayerAimHitbox[Aim.index].Hitbox - (pmove->origin + pmove->view_ofs)).Length();
			if (fDistance < m_flBestDist)
			{
				m_flBestDist = fDistance;
				iTargetKnife = Aim.index;
				vAimOriginKnife = Aim.PlayerAimHitbox[cvar.knifebot_hitbox].Hitbox;
				iHitboxKnife = cvar.knifebot_hitbox;
			}
		}
	}
}

void Sakura::Knifebot::Knife(usercmd_s* cmd)
{
	if (!cvar.knifebot_active)
		return;

	if (!IsCurWeaponKnife())
		return;

	float bestDistance = 8192.f;

	for (playeraim_t Aim : PlayerAim)
	{
		if (IdHook::FirstKillPlayer[Aim.index] == IDHOOK_PLAYER_ON || cvar.aim_id_mode == IDHOOK_ATTACK_ALL)
		{
			if (!Sakura::Player::IsAlive(Aim.index))
				continue;

			if (!cvar.knifebot_team && g_Player[Aim.index].iTeam == g_Local.iTeam)
				continue;

			SelectTarget(Aim, bestDistance);
		}
	}

	if (!iTargetKnife && cvar.aim_id_mode != IDHOOK_ATTACK_ON)
	{
		for (playeraim_t Aim : PlayerAim)
		{
			if (IdHook::FirstKillPlayer[Aim.index] < IDHOOK_PLAYER_OFF)
			{
				if (!Sakura::Player::IsAlive(Aim.index))
					continue;

				if (!cvar.knifebot_team && g_Player[Aim.index].iTeam == g_Local.iTeam)
					continue;

				SelectTarget(Aim, bestDistance);
			}
		}
	}

	if (!iTargetKnife)
		return;

	int dist = (cvar.knifebot_attack == 0) ? cvar.knifebot_attack_distance : cvar.knifebot_attack2_distance;
	float distanceSquared = (vAimOriginKnife - (pmove->origin + pmove->view_ofs)).LengthSqr();

	if (distanceSquared < dist * dist)
	{
		if (CanAttack())
		{
			bool isPerfectSilentOrSilent = false;
			QAngle aimAngles;
			Vector eyePosition = pmove->origin + pmove->view_ofs;
			VectorAngles(vAimOriginKnife - eyePosition, aimAngles);
			aimAngles.Normalize();

			if (cvar.knifebot_silent)
			{
				MakeAngle(aimAngles, cmd);
				isPerfectSilentOrSilent = true;
			}

			if (cvar.knifebot_perfect_silent)
			{
				MakeAngle(aimAngles, cmd);
				bSendpacket(false);
				isPerfectSilentOrSilent = true;
			}

			if(!isPerfectSilentOrSilent)
			{
				cmd->viewangles = aimAngles;
				g_Engine.SetViewAngles(aimAngles);
			}

			cmd->buttons |= (cvar.knifebot_attack == 0) ? IN_ATTACK : IN_ATTACK2;
		}
		else
			cmd->buttons &= (cvar.knifebot_attack == 0) ? IN_ATTACK : IN_ATTACK2;
	}
}

void Sakura::Knifebot::Draw()
{
	if (!cvar.knifebot_active || !IsCurWeaponKnife() || !Sakura::Player::Local::IsAlive() || !cvar.knifebot_draw_aim || !iTargetKnife)
		return;

	for (playeraim_t Aim : PlayerAim)
	{
		if (Aim.index != iTargetKnife)
			continue;

		float CalcAnglesMin[2], CalcAnglesMax[2];
		for (size_t i = 0; i < 12; ++i)
		{
			if (WorldToScreen(Aim.PlayerAimHitbox[iHitboxKnife].HitboxMulti[SkeletonHitboxMatrix[i][0]], CalcAnglesMin) && WorldToScreen(Aim.PlayerAimHitbox[iHitboxKnife].HitboxMulti[SkeletonHitboxMatrix[i][1]], CalcAnglesMax))
				ImGui::GetCurrentWindow()->DrawList->AddLine({ IM_ROUND(CalcAnglesMin[0]), IM_ROUND(CalcAnglesMin[1]) }, { IM_ROUND(CalcAnglesMax[0]), IM_ROUND(CalcAnglesMax[1]) }, Sakura::Colors::Green());
		}
	}
}
```

`sakura/source/features/legit/knife.h`:

```h
#ifndef _KNIFE_
#define _KNIFE_

namespace Sakura
{
	namespace Knifebot
	{
		extern int		iTargetKnife;
		extern int		iHitboxKnife;
		extern Vector	vAimOriginKnife;

		void SelectTarget(playeraim_t Aim, float& m_flBestDist);
		void Knife(usercmd_s* cmd);
		void Draw();
	};
};

#endif
```

`sakura/source/features/legit/laim.cpp`:

```cpp
#include "../../client.h"

int		Sakura::Aimbot::Legit::iTargetLegit;
int		Sakura::Aimbot::Legit::iHitboxLegit;
bool	Sakura::Aimbot::Legit::LegitKeyStatus;
Vector	Sakura::Aimbot::Legit::vAimOriginLegit;

void Sakura::Aimbot::Legit::SmoothAngles(QAngle MyViewAngles, QAngle AimAngles, QAngle& OutAngles, float Smoothing, bool bSpiral, float SpiralX, float SpiralY)
{
	if (Smoothing < 1)
	{
		OutAngles = AimAngles;
		return;
	}

	OutAngles = AimAngles - MyViewAngles;

	OutAngles.Normalize();

	Vector vecViewAngleDelta;
	VectorCopy(OutAngles, vecViewAngleDelta);

	if (bSpiral && SpiralX != 0 && SpiralY != 0)
		vecViewAngleDelta += Vector(vecViewAngleDelta.y / SpiralX, vecViewAngleDelta.x / SpiralY, 0.0f);

	if (!isnan(Smoothing))
		vecViewAngleDelta /= Smoothing;

	OutAngles = MyViewAngles + vecViewAngleDelta;

	OutAngles.Normalize();
}

void Sakura::Aimbot::Legit::SelectHitbox(playeraim_t Aim, Vector vecFOV, float& flBestFOV, float flSpeedScaleFov, float& flSpeed)
{
	pmtrace_t tr;

	g_Engine.pEventAPI->EV_SetTraceHull(2);

	Vector vEye = pmove->origin + pmove->view_ofs;

	if (cvar.bypass_trace_legit)
		g_Engine.pEventAPI->EV_PlayerTrace(vEye, Aim.PlayerAimHitbox[cvar.legit[g_Local.weapon.m_iWeaponID].hitbox].Hitbox, PM_WORLD_ONLY, -1, &tr);
	else
		g_Engine.pEventAPI->EV_PlayerTrace(vEye, Aim.PlayerAimHitbox[cvar.legit[g_Local.weapon.m_iWeaponID].hitbox].Hitbox, PM_GLASS_IGNORE, -1, &tr);

	int detect = g_Engine.pEventAPI->EV_IndexFromTrace(&tr);

	if ((cvar.bypass_trace_legit && tr.fraction == 1 && !detect) || (!cvar.bypass_trace_legit && detect == Aim.index))
	{
		Vector vEye = pmove->origin + pmove->view_ofs;
		float fov = vecFOV.AngleBetween(Aim.PlayerAimHitbox[cvar.legit[g_Local.weapon.m_iWeaponID].hitbox].Hitbox - vEye);
		if (fov <= flBestFOV)
		{
			flBestFOV = fov;
			iTargetLegit = Aim.index;
			iHitboxLegit = cvar.legit[g_Local.weapon.m_iWeaponID].hitbox;
			vAimOriginLegit = Aim.PlayerAimHitbox[cvar.legit[g_Local.weapon.m_iWeaponID].hitbox].Hitbox;
			if (flSpeedScaleFov > 0 && flSpeedScaleFov <= 100 && g_Local.vPunchangle.IsZero() && !isnan(Aim.PlayerAimHitbox[cvar.legit[g_Local.weapon.m_iWeaponID].hitbox].HitboxFOV))
				flSpeed = flSpeed - (((Aim.PlayerAimHitbox[cvar.legit[g_Local.weapon.m_iWeaponID].hitbox].HitboxFOV * (flSpeed / Sakura::Aimbot::m_flCurrentFOV)) * flSpeedScaleFov) / 100);
		}
	}
}

void Sakura::Aimbot::Legit::Aim(usercmd_s* cmd)
{
	static DWORD dwBlockAttack = 0;

	static float flSpeedSpiralX = 1.3;
	static float flSpeedSpiralY = 3.7;

	if (!cvar.legit[g_Local.weapon.m_iWeaponID].active)
		return;

	bool Attacking;
	if (cvar.legit_key == -1)
		Attacking = cmd->buttons & IN_ATTACK;
	else
		Attacking = LegitKeyStatus;

	Sakura::Aimbot::m_flCurrentFOV = 0;

	if (!IsCurWeaponGun() || g_Local.weapon.m_iInReload || g_Local.weapon.m_iClip < 1 || g_Local.weapon.m_flNextAttack > 0.0)
		return;

	if (cvar.legit_flashcheck &&
		Sakura::Fade::Percentage > cvar.legit_flashcheck_percentage)
		return;

	float flFOV = cvar.legit[g_Local.weapon.m_iWeaponID].fov;

	if (!flFOV)
		return;

	float flSpeed = cvar.legit[g_Local.weapon.m_iWeaponID].speed_in_attack;

	//if (cvar.legit[g_Local.weapon.m_iWeaponID].speed_in_attack)
	//	flSpeed = cvar.legit[g_Local.weapon.m_iWeaponID].speed_in_attack;

	if (cvar.legit[g_Local.weapon.m_iWeaponID].speed && !(Attacking))
		flSpeed = 101 - cvar.legit[g_Local.weapon.m_iWeaponID].speed;

	//if (!flSpeed)
	//	return;

	float flReactionTime = cvar.legit[g_Local.weapon.m_iWeaponID].reaction_time;

	if (flReactionTime > 0 && GetTickCount() - dwReactionTime < flReactionTime)
		return;

	float flSpeedScaleFov = cvar.legit[g_Local.weapon.m_iWeaponID].speed_scale_fov;

	bool bSpeedSpiral = cvar.legit[g_Local.weapon.m_iWeaponID].humanize;

	if (!g_Local.vPunchangle.IsZero2D())
		bSpeedSpiral = false;

	float flRecoilCompensationPitch = 0.02f * cvar.legit[g_Local.weapon.m_iWeaponID].recoil_compensation_pitch;
	float flRecoilCompensationYaw = 0.02f * cvar.legit[g_Local.weapon.m_iWeaponID].recoil_compensation_yaw;

	unsigned int iRecoilCompensationAfterShotsFired = static_cast<int>(cvar.legit[g_Local.weapon.m_iWeaponID].recoil_compensation_after_shots_fired);

	if (iRecoilCompensationAfterShotsFired > 0 && g_Local.weapon.m_iShotsFired <= iRecoilCompensationAfterShotsFired)
	{
		flRecoilCompensationPitch = 0;
		flRecoilCompensationYaw = 0;
	}

	float flBlockAttackAfterKill = cvar.legit[g_Local.weapon.m_iWeaponID].block_attack_after_kill;

	float flAccuracy = cvar.legit[g_Local.weapon.m_iWeaponID].accuracy;

	//float flPSilent = cvar.legit[g_Local.weapon.m_iWeaponID].perfect_silent / 100;

	Vector vecFOV = {};
	{
		QAngle QAngles;

		QAngles.x = (cmd->viewangles.x + g_Local.vPunchangle.x);
		QAngles.y = (cmd->viewangles.y + g_Local.vPunchangle.y);
		QAngles.z = (cmd->viewangles.z + g_Local.vPunchangle.z);

		QAngles.Normalize();
		QAngles.AngleVectors(&vecFOV, NULL, NULL);
		vecFOV.Normalize();
	}

	Sakura::Aimbot::m_flCurrentFOV = flFOV;

	float flBestFOV = flFOV;

	if (cvar.legit[g_Local.weapon.m_iWeaponID].recoil_compensation_fov && g_Local.weapon.m_iShotsFired >= cvar.legit[g_Local.weapon.m_iWeaponID].recoil_compensation_after_shots_fired && (Attacking))
	{
		if ((g_Local.vNoRecoilAngle[0] != 0.f && cvar.legit[g_Local.weapon.m_iWeaponID].recoil_compensation_pitch) ||
			(g_Local.vNoRecoilAngle[1] != 0.f && cvar.legit[g_Local.weapon.m_iWeaponID].recoil_compensation_yaw))
		{
			flBestFOV = flBestFOV + ((flBestFOV * cvar.legit[g_Local.weapon.m_iWeaponID].recoil_compensation_fov) / 100);
			Sakura::Aimbot::m_flCurrentFOV = flBestFOV;
			flSpeed = flSpeed + ((flSpeed * cvar.legit[g_Local.weapon.m_iWeaponID].recoil_compensation_smooth) / 100);
		}
	}

	for (playeraim_t Aim : PlayerAim)
	{
		if (IdHook::FirstKillPlayer[Aim.index] == IDHOOK_PLAYER_ON || cvar.aim_id_mode == IDHOOK_ATTACK_ALL)
		{
			if (!Sakura::Player::IsAlive(Aim.index))
				continue;

			if (!cvar.legit_team && g_Player[Aim.index].iTeam == g_Local.iTeam)
				continue;

			SelectHitbox(Aim, vecFOV, flBestFOV, flSpeedScaleFov, flSpeed);
		}
	}
		
	if (!iTargetLegit && cvar.aim_id_mode != IDHOOK_ATTACK_ON)
	{
		for (playeraim_t Aim : PlayerAim)
		{
			if (IdHook::FirstKillPlayer[Aim.index] < IDHOOK_PLAYER_OFF)
			{
				if (!Sakura::Player::IsAlive(Aim.index))
					continue;

				if (!cvar.legit_team && g_Player[Aim.index].iTeam == g_Local.iTeam)
					continue;

				SelectHitbox(Aim, vecFOV, flBestFOV, flSpeedScaleFov, flSpeed);
			}
		}
	}

	if (iTargetLegit)
	{
		bool bAttack = false;
		bool bBlock = false;

		QAngle QMyAngles, QNewAngles, QSmoothAngles, QAimAngles;

		g_Engine.GetViewAngles(QMyAngles);

		Vector vEye = pmove->origin + pmove->view_ofs;

		VectorAngles(vAimOriginLegit - vEye, QAimAngles);

		if (cvar.legit[g_Local.weapon.m_iWeaponID].perfect_silent_enable && CanAttack())
		{
			QAngle QAnglePerfectSilent = QAimAngles;

			QAnglePerfectSilent += g_Local.vPunchangle;

			QAnglePerfectSilent.Normalize();

			if (cvar.legit[g_Local.weapon.m_iWeaponID].perfect_silent_spread)
				GetSpreadOffset(g_Local.weapon.random_seed, 1, QAnglePerfectSilent, QAnglePerfectSilent);

			Vector vecPsilentFOV;
			QAnglePerfectSilent.AngleVectors(&vecPsilentFOV, NULL, NULL);
			vecPsilentFOV.Normalize();

			Vector vDistance(vAimOriginLegit - vEye);
			float fov = Sakura::Aimbot::AngleBetween(vecPsilentFOV, vDistance);

			if (fov <= cvar.legit[g_Local.weapon.m_iWeaponID].perfect_silent_fov && cmd->buttons & IN_ATTACK)
			{
				//if (cvar.legit[g_Local.weapon.m_iWeaponID].perfect_silent_autoshoot)
				//	cmd->buttons |= IN_ATTACK;

				dwBlockAttack = GetTickCount();

				MakeAngle(QAnglePerfectSilent, cmd);
				bSendpacket(false);

				return;
			}
		}

		QNewAngles[0] = QAimAngles[0] - g_Local.vPunchangle[0] * flRecoilCompensationPitch;
		QNewAngles[1] = QAimAngles[1] - g_Local.vPunchangle[1] * flRecoilCompensationYaw;
		QNewAngles[2] = 0;

		QNewAngles.Normalize();

		SmoothAngles(QMyAngles, QNewAngles, QSmoothAngles, flSpeed, bSpeedSpiral, flSpeedSpiralX, flSpeedSpiralY);

		if (cvar.legit_demochecker_bypass)
		{
			const auto prev_frameid = (client_state->validsequence - 1) % IM_ARRAYSIZE(client_state->commands);

			QAngle QPreviousAngles(client_state->commands[prev_frameid].cmd.viewangles), QPreviousAngles2, QPreviousAngles3(cmd->viewangles);

			g_Engine.GetViewAngles(QPreviousAngles2);

			QPreviousAngles.Normalize();
			QPreviousAngles2.Normalize();
			QPreviousAngles3.Normalize();

			QAngle QDelta = QPreviousAngles.Delta360(QSmoothAngles);
			QAngle QDelta2 = QPreviousAngles2.Delta360(QSmoothAngles);
			QAngle QDelta3 = QPreviousAngles3.Delta360(QSmoothAngles);

			if (QDelta.x > 0.000001 && 0.007 > QDelta.x)
				QSmoothAngles.x = QPreviousAngles.x;

			if (QDelta.y > 0.0 && QDelta.y < 0.000013)
				QSmoothAngles.y = QPreviousAngles.y;

			if (QDelta2.x > 0.000001 && 0.007 > QDelta2.x)
				QSmoothAngles.x = QPreviousAngles2.x;

			if (QDelta2.y > 0.0 && QDelta2.y < 0.000013)
				QSmoothAngles.y = QPreviousAngles2.y;

			if (QDelta3.x > 0.000001 && 0.007 > QDelta3.x)
				QSmoothAngles.x = QPreviousAngles3.x;

			if (QDelta3.y > 0.0 && QDelta3.y < 0.000013)
				QSmoothAngles.y = QPreviousAngles3.y;
		}

		if (flAccuracy > 0)
		{
			// why you want to block attack while player is doing full auto with recoil active
			bBlock = false;

			QAngle QAngleAccuracy = QAimAngles;

			Vector vecSpreadDir;

			if (flAccuracy == 1)
			{
				QSmoothAngles.AngleVectors(&vecSpreadDir, NULL, NULL);

				vecSpreadDir.Normalize();
			}
			else if (flAccuracy == 2) //Recoil
			{
				Vector vecRandom, vecForward;

				SmoothAngles(QMyAngles, QAimAngles, QAngleAccuracy, flSpeed, bSpeedSpiral, flSpeedSpiralX, flSpeedSpiralY);

				QAngleAccuracy[0] += g_Local.vPunchangle[0];
				QAngleAccuracy[1] += g_Local.vPunchangle[1];
				QAngleAccuracy[2] = NULL;

				QAngleAccuracy.Normalize();

				QAngleAccuracy.AngleVectors(&vecForward, NULL, NULL);

				vecSpreadDir = vecForward;

				vecSpreadDir.Normalize();
			}
			else //Recoil / Spread
			{
				Vector vecRandom, vecRight, vecUp, vecForward;

				SmoothAngles(QMyAngles, QAimAngles, QAngleAccuracy, flSpeed, bSpeedSpiral, flSpeedSpiralX, flSpeedSpiralY);

				QAngleAccuracy[0] += g_Local.vPunchangle[0];
				QAngleAccuracy[1] += g_Local.vPunchangle[1];
				QAngleAccuracy[2] = NULL;

				QAngleAccuracy.Normalize();

				QAngleAccuracy.AngleVectors(&vecForward, &vecRight, &vecRight);

				GetSpreadXY(g_Local.weapon.random_seed, 1, vecRandom);

				vecSpreadDir = vecForward + (vecRight * vecRandom[0]) + (vecUp * vecRandom[1]);

				vecSpreadDir.Normalize();
			}
			for (playeraim_t Aim : PlayerAim)
			{
				if (Aim.index != iTargetLegit)
					continue;

				for (size_t i = 0; i < 12; ++i)
				{
					if (Sakura::Aimbot::IsBoxIntersectingRay(Aim.PlayerAimHitbox[cvar.legit[g_Local.weapon.m_iWeaponID].hitbox].HitboxMulti[SkeletonHitboxMatrix[i][0]], Aim.PlayerAimHitbox[cvar.legit[g_Local.weapon.m_iWeaponID].hitbox].HitboxMulti[SkeletonHitboxMatrix[i][1]], vEye, vecSpreadDir))
					{
						bBlock = false;
						break;
					}
				}
			}
		}

		if (Attacking)
			bAttack = true;
		else if (cvar.legit[g_Local.weapon.m_iWeaponID].speed)
		{
			bAttack = true;
			bBlock = true;
		}

		if (bAttack)
		{
			QSmoothAngles.Normalize();

			MakeAngle(QSmoothAngles, cmd);
			cmd->viewangles = QSmoothAngles;
			g_Engine.SetViewAngles(QSmoothAngles);

			if (!bBlock)
			{
				if (g_Local.ViewModel && g_Local.ViewModel->curstate.sequence == 0 && cvar.legit_fastzoom && !g_Local.bScoped && IsCurWeaponSniper())
					cmd->buttons |= IN_ATTACK2;

				cmd->buttons |= IN_ATTACK;

				if (cvar.misc_fastswitch && g_Local.bScoped && (g_Local.weapon.m_iWeaponID == WEAPON_AWP || g_Local.weapon.m_iWeaponID == WEAPON_SCOUT))
				{
					g_Engine.pfnClientCmd(/*lastinv*/XorStr<0xDB, 8, 0x8D579E19>("\xB7\xBD\xAE\xAA\xB6\x8E\x97" + 0x8D579E19).s);
					g_Engine.pfnClientCmd(/*lastinv*/XorStr<0xDB, 8, 0x8D579E19>("\xB7\xBD\xAE\xAA\xB6\x8E\x97" + 0x8D579E19).s);
				}
			}
			else if (Attacking)
			{
				cmd->buttons &= ~IN_ATTACK;
			}

			if (!g_Local.vPunchangle.IsZero2D())
			{
				dwBlockAttack = GetTickCount();
			}
		}
	}
	else
	{
		if (flBlockAttackAfterKill > 0 && GetTickCount() - dwBlockAttack < flBlockAttackAfterKill && Attacking)
			cmd->buttons &= ~IN_ATTACK;
	}
}

void Sakura::Aimbot::Legit::Draw()
{
	if (!IsCurWeaponGun() || !Sakura::Player::Local::IsAlive() || !cvar.legit_draw_aim || !iTargetLegit)
		return;

	for (playeraim_t Aim : PlayerAim)
	{
		if (Aim.index != iTargetLegit)
			continue;

		float CalcAnglesMin[2], CalcAnglesMax[2];
		for (size_t i = 0; i < 12; ++i)
		{
			if (WorldToScreen(Aim.PlayerAimHitbox[iHitboxLegit].HitboxMulti[SkeletonHitboxMatrix[i][0]], CalcAnglesMin) && WorldToScreen(Aim.PlayerAimHitbox[iHitboxLegit].HitboxMulti[SkeletonHitboxMatrix[i][1]], CalcAnglesMax))
				ImGui::GetCurrentWindow()->DrawList->AddLine({ IM_ROUND(CalcAnglesMin[0]), IM_ROUND(CalcAnglesMin[1]) }, { IM_ROUND(CalcAnglesMax[0]), IM_ROUND(CalcAnglesMax[1]) }, Sakura::Colors::Green());
		}
	}
}
```

`sakura/source/features/legit/laim.h`:

```h
#ifndef _LAIM_
#define _LAIM_

namespace Sakura
{
	namespace Aimbot
	{
		namespace Legit
		{
			extern int		iTargetLegit;
			extern int		iHitboxLegit;
			extern bool		LegitKeyStatus;
			extern Vector	vAimOriginLegit;

			void SmoothAngles(QAngle MyViewAngles, QAngle AimAngles, QAngle& OutAngles, float Smoothing, bool bSpiral, float SpiralX, float SpiralY);
			void SelectHitbox(playeraim_t Aim, Vector vecFOV, float& flBestFOV, float flSpeedScaleFov, float& flSpeed);
			void Aim(usercmd_s* cmd);
			void Draw();
		};
	};
};

#endif
```

`sakura/source/features/legit/trigger.cpp`:

```cpp
#include "../../client.h"

int		Sakura::Triggerbot::iTargetTrigger;
bool	Sakura::Triggerbot::TriggerKeyStatus;

void Sakura::Triggerbot::SelectTarget(usercmd_s* cmd, playeraim_t Aim, float& m_flBestFOV, DWORD delay, Vector vecSpreadDir)
{
	Vector vEye = pmove->origin + pmove->view_ofs;

	bool bHitboxPointsVisible[8];

	for (size_t point = 0; point < 8; ++point)
	{
		pmtrace_t tr;

		int detect = 0;

		g_Engine.pEventAPI->EV_SetTraceHull(2);

		if (cvar.bypass_trace_trigger)
			g_Engine.pEventAPI->EV_PlayerTrace(vEye, Aim.PlayerAimHitbox[cvar.legit[g_Local.weapon.m_iWeaponID].trigger_hitbox].HitboxMulti[point], PM_WORLD_ONLY, -1, &tr);
		else
			g_Engine.pEventAPI->EV_PlayerTrace(vEye, Aim.PlayerAimHitbox[cvar.legit[g_Local.weapon.m_iWeaponID].trigger_hitbox].HitboxMulti[point], PM_GLASS_IGNORE, -1, &tr);

		detect = g_Engine.pEventAPI->EV_IndexFromTrace(&tr);

		if ((cvar.bypass_trace_trigger && tr.fraction == 1 && !detect) || (!cvar.bypass_trace_trigger && detect == Aim.index))
		{
			bHitboxPointsVisible[point] = true;
			if (Aim.PlayerAimHitbox[cvar.legit[g_Local.weapon.m_iWeaponID].trigger_hitbox].HitboxPointsFOV[point] < m_flBestFOV)
			{
				m_flBestFOV = Aim.PlayerAimHitbox[cvar.legit[g_Local.weapon.m_iWeaponID].trigger_hitbox].HitboxPointsFOV[point];
				iTargetTrigger = Aim.index;
			}
		}
		else
		{
			bHitboxPointsVisible[point] = false;

			int iOriginalPenetration = CurPenetration();

			if (iOriginalPenetration && cvar.legit[g_Local.weapon.m_iWeaponID].trigger_wall)
			{
				int iDamage = CurDamage();
				int iBulletType = CurBulletType();
				float flDistance = CurDistance();
				float flRangeModifier = CurWallPierce();

				int iCurrentDamage = Sakura::Aimbot::FireBullets(vEye, Aim.PlayerAimHitbox[cvar.legit[g_Local.weapon.m_iWeaponID].trigger_hitbox].HitboxMulti[point], flDistance, iOriginalPenetration, iBulletType, iDamage, flRangeModifier);

				if (iCurrentDamage > 0)
				{
					bHitboxPointsVisible[point] = true;
					if (Aim.PlayerAimHitbox[cvar.legit[g_Local.weapon.m_iWeaponID].trigger_hitbox].HitboxPointsFOV[point] < m_flBestFOV)
					{
						m_flBestFOV = Aim.PlayerAimHitbox[cvar.legit[g_Local.weapon.m_iWeaponID].trigger_hitbox].HitboxPointsFOV[point];
						iTargetTrigger = Aim.index;
					}
				}
			}
		}
	}
	for (size_t i = 0; i < 12; ++i)
	{
		if (bHitboxPointsVisible[SkeletonHitboxMatrix[i][0]] && bHitboxPointsVisible[SkeletonHitboxMatrix[i][1]])
		{
			Vector vEye = pmove->origin + pmove->view_ofs;
			if (Sakura::Aimbot::IsBoxIntersectingRay(Aim.PlayerAimHitbox[cvar.legit[g_Local.weapon.m_iWeaponID].trigger_hitbox].HitboxMulti[SkeletonHitboxMatrix[i][0]], Aim.PlayerAimHitbox[cvar.legit[g_Local.weapon.m_iWeaponID].trigger_hitbox].HitboxMulti[SkeletonHitboxMatrix[i][1]], vEye, vecSpreadDir))
			{
				if (CanAttack() && GetTickCount() - delay > cvar.legit[g_Local.weapon.m_iWeaponID].trigger_delay_shot)
					cmd->buttons |= IN_ATTACK;

				break;
			}
		}
	}
}

void Sakura::Triggerbot::Trigger(usercmd_s* cmd)
{
	if (!cvar.legit[g_Local.weapon.m_iWeaponID].trigger_active || !IsCurWeaponGun())
		return;

	if (!TriggerKeyStatus && cvar.legit_trigger_key > 0 && cvar.legit_trigger_key < 255)
		return;

	if (cvar.legit_trigger_only_zoom && IsCurWeaponSniper() && !g_Local.bScoped)
		return;

	float m_flBestFOV = 180;

	const float flAccuracy = cvar.legit[g_Local.weapon.m_iWeaponID].trigger_accuracy;

	Vector vecSpreadDir, vecForward, vecRight, vecUp, vecRandom;

	QAngle QAngles;

	g_Engine.GetViewAngles(QAngles);

	if (flAccuracy > 0)
	{
		QAngles[0] += g_Local.vPunchangle[0];
		QAngles[1] += g_Local.vPunchangle[1];
		QAngles[2] = NULL;
	}

	QAngles.Normalize();

	QAngles.AngleVectors(&vecForward, &vecRight, &vecUp);

	if (flAccuracy > 1)
	{
		GetSpreadXY(g_Local.weapon.random_seed, 1, vecRandom);
		vecSpreadDir = vecForward + (vecRight * vecRandom[0]) + (vecUp * vecRandom[1]);
		vecSpreadDir.Normalize();
	}
	else
	{
		vecSpreadDir = vecForward;
		vecSpreadDir.Normalize();
	}

	static DWORD delay = 0;
	static int tickcount = 0;

	for (playeraim_t Aim : PlayerAim)
	{
		if (IdHook::FirstKillPlayer[Aim.index] == IDHOOK_PLAYER_ON || cvar.aim_id_mode == IDHOOK_ATTACK_ALL)
		{
			if (!Sakura::Player::IsAlive(Aim.index))
				continue;

			if (!cvar.legit_trigger_team && g_Player[Aim.index].iTeam == g_Local.iTeam)
				continue;

			SelectTarget(cmd, Aim, m_flBestFOV, delay, vecSpreadDir);
		}
	}

	if (!iTargetTrigger && cvar.aim_id_mode != IDHOOK_ATTACK_ON)
	{
		for (playeraim_t Aim : PlayerAim)
		{
			if (IdHook::FirstKillPlayer[Aim.index] < IDHOOK_PLAYER_OFF)
			{
				if (!Sakura::Player::IsAlive(Aim.index))
					continue;

				if (!cvar.legit_trigger_team && g_Player[Aim.index].iTeam == g_Local.iTeam)
					continue;

				SelectTarget(cmd, Aim, m_flBestFOV, delay, vecSpreadDir);
			}
		}
	}

	if (cmd->buttons & IN_ATTACK)
		tickcount++;

	int max_random = (int)cvar.legit[g_Local.weapon.m_iWeaponID].trigger_random_max + 1;
	static int random = rand() % max_random;

	if (tickcount >= (!cvar.legit[g_Local.weapon.m_iWeaponID].trigger_shot_type ? cvar.legit[g_Local.weapon.m_iWeaponID].trigger_shot_count : random))
	{
		delay = GetTickCount();
		tickcount = 0;
	}
}

void Sakura::Triggerbot::DrawTarget(playeraim_t Aim)
{
	Vector vEye = pmove->origin + pmove->view_ofs;

	bool bHitboxPointsVisible[8];

	for (size_t point = 0; point < 8; ++point)
	{
		pmtrace_t tr;

		int detect = 0;

		g_Engine.pEventAPI->EV_SetTraceHull(2);

		if (cvar.bypass_trace_trigger)
			g_Engine.pEventAPI->EV_PlayerTrace(vEye, Aim.PlayerAimHitbox[cvar.legit[g_Local.weapon.m_iWeaponID].trigger_hitbox].HitboxMulti[point], PM_WORLD_ONLY, -1, &tr);
		else
			g_Engine.pEventAPI->EV_PlayerTrace(vEye, Aim.PlayerAimHitbox[cvar.legit[g_Local.weapon.m_iWeaponID].trigger_hitbox].HitboxMulti[point], PM_GLASS_IGNORE, -1, &tr);

		detect = g_Engine.pEventAPI->EV_IndexFromTrace(&tr);

		if ((cvar.bypass_trace_trigger && tr.fraction == 1 && !detect) || (!cvar.bypass_trace_trigger && detect == Aim.index))
			bHitboxPointsVisible[point] = true;
		else
		{
			bHitboxPointsVisible[point] = false;

			int iOriginalPenetration = CurPenetration();

			if (iOriginalPenetration && cvar.legit[g_Local.weapon.m_iWeaponID].trigger_wall)
			{
				int iDamage = CurDamage();
				int iBulletType = CurBulletType();
				float flDistance = CurDistance();
				float flRangeModifier = CurWallPierce();

				int iCurrentDamage = Sakura::Aimbot::FireBullets(vEye, Aim.PlayerAimHitbox[cvar.legit[g_Local.weapon.m_iWeaponID].trigger_hitbox].HitboxMulti[point], flDistance, iOriginalPenetration, iBulletType, iDamage, flRangeModifier);

				if (iCurrentDamage > 0)
					bHitboxPointsVisible[point] = true;
			}
		}
	}

	float CalcAnglesMin[2], CalcAnglesMax[2];
	for (size_t i = 0; i < 12; ++i)
	{
		if (bHitboxPointsVisible[SkeletonHitboxMatrix[i][0]] && bHitboxPointsVisible[SkeletonHitboxMatrix[i][1]])
		{
			if (WorldToScreen(Aim.PlayerAimHitbox[cvar.legit[g_Local.weapon.m_iWeaponID].trigger_hitbox].HitboxMulti[SkeletonHitboxMatrix[i][0]], CalcAnglesMin) && WorldToScreen(Aim.PlayerAimHitbox[cvar.legit[g_Local.weapon.m_iWeaponID].trigger_hitbox].HitboxMulti[SkeletonHitboxMatrix[i][1]], CalcAnglesMax))
				ImGui::GetCurrentWindow()->DrawList->AddLine({ IM_ROUND(CalcAnglesMin[0]), IM_ROUND(CalcAnglesMin[1]) }, { IM_ROUND(CalcAnglesMax[0]), IM_ROUND(CalcAnglesMax[1]) }, Sakura::Colors::Green());
		}
	}
}

void Sakura::Triggerbot::Draw()
{
	if (!cvar.legit[g_Local.weapon.m_iWeaponID].trigger_active || !IsCurWeaponGun() || !Sakura::Player::Local::IsAlive())
		return;

	if (!cvar.legit_trigger_draw_aim || !iTargetTrigger)
		return;

	for (playeraim_t Aim : PlayerAim)
	{
		if (Aim.index != iTargetTrigger)
			continue;

		DrawTarget(Aim);
	}
}
```

`sakura/source/features/legit/trigger.h`:

```h
#ifndef _TRIGGER_
#define _TRIGGER_

namespace Sakura
{
	namespace Triggerbot
	{
		extern int	iTargetTrigger;
		extern bool TriggerKeyStatus;

		void SelectTarget(usercmd_s* cmd, playeraim_t Aim, float& m_flBestFOV, DWORD delay, Vector vecSpreadDir);
		void Trigger(usercmd_s* cmd);
		void DrawTarget(playeraim_t Aim);
		void Draw();
	};
};

#endif
```

`sakura/source/features/lua/luabind.cpp`:

```cpp
#include "../../client.h"

int Sakura::Lua::ScriptsCount = 0;
int Sakura::Lua::currentScriptIndex = 0;

std::vector<Sakura::Lua::LuaScripts> Sakura::Lua::scripts;

std::vector<HSAMPLE> Sakura::Lua::Sounds;

Vector Sakura::Lua::Game::vLastConvertedVector(0, 0, 0);

void Sakura::Lua::Hooks::RegisterCallBack(UINT type, luabridge::LuaRef f)
{
	if (type < 0 || type >= SAKURA_CALLBACK_ALL_CALLBACKS)
		return;

	Sakura::Lua::scripts[currentScriptIndex].RegisterCallback(type, f);
}

void Sakura::Lua::Game::SendPacket(bool status)
{
	bSendpacket(status);
}

DWORD Sakura::Lua::Game::InitSound(const char* filename)
{
	char temp[256];
	sprintf(temp, "%s%s", Sakura::CheatDir, filename);

	HSAMPLE sample = BASS_SampleLoad(false, temp, 0, 0, 60000, 0);

	if (!sample)
		Sakura::Log::File("Failed to load sound '%s' from lua. Error code: %i.", filename, BASS_ErrorGetCode());

	Sounds.push_back(sample);

	return sample;
}

void Sakura::Lua::Game::SoundPlay(DWORD sound, const float volume)
{
	BASS_SAMPLE sampleInfo;
	BASS_SampleGetInfo(sound, &sampleInfo);

	sampleInfo.volume = volume;
	BASS_SampleSetInfo(sound, &sampleInfo);

	HCHANNEL channel = BASS_SampleGetChannel(sound, false);

	BASS_ChannelPlay(channel, false);
}

bool Sakura::Lua::Game::CreateVisibleEntity(const int entityType, const int entityIndexToCopy, Vector origin, const bool checkPlayerEntity)
{
	cl_entity_s* entity = g_Engine.GetEntityByIndex(entityIndexToCopy);

	if (!entity)
		return false;

	if (checkPlayerEntity && !entity->player)
		return false;

	entity->origin = origin;

	g_Engine.CL_CreateVisibleEntity(entityType, entity);

	return true;
}

void Sakura::Lua::Game::CreateBeamPoint(Vector start, Vector end, const ImColor color, const float life, const float width, const float amplitude, const float speed, const int startFrame, const float framerate)
{
	int beamindex = g_Engine.pEventAPI->EV_FindModelIndex("sprites/laserbeam.spr");

	g_Engine.pEfxAPI->R_BeamPoints(start, end, beamindex, life, width, amplitude, color.Value.w, speed, startFrame, framerate, color.Value.x, color.Value.y, color.Value.z);
}

bool Sakura::Lua::Game::WorldToScreen(Vector& in)
{
	return ::WorldToScreen((float*)in, (float*)Sakura::Lua::Game::vLastConvertedVector);
}

Vector Sakura::Lua::Game::GetLastConvertedToScreenVector()
{
	return Sakura::Lua::Game::vLastConvertedVector;
}

DWORD Sakura::Lua::Game::GetTime()
{
	return GetTickCount();
}

float Sakura::Lua::Game::GetClientTime()
{
	return g_Engine.GetClientTime();
}

int Sakura::Lua::LocalPlayer::GetIndex()
{
	return pmove->player_index + 1;
}

int Sakura::Lua::LocalPlayer::GetTeam()
{
	return g_Local.iTeam;
}

int Sakura::Lua::LocalPlayer::GetFlags()
{
	return pmove->flags;
}

int Sakura::Lua::LocalPlayer::GetHealth()
{
	return g_Local.iPrevHealth;
}

bool Sakura::Lua::LocalPlayer::CheckFlag(const int flag)
{
	return (pmove->flags & flag);
}

int Sakura::Lua::LocalPlayer::GetButtons()
{
	return pmove->cmd.buttons;
}

bool Sakura::Lua::LocalPlayer::CheckButton(const usercmd_s* cmd, const int button)
{
	return (cmd->buttons & button);
}

void Sakura::Lua::LocalPlayer::PressButton(usercmd_s* cmd, const int button)
{
	cmd->buttons |= button;
}

void Sakura::Lua::LocalPlayer::ReleaseButton(usercmd_s* cmd, const int button)
{
	cmd->buttons &= ~button;
}

bool Sakura::Lua::LocalPlayer::IsAlive()
{
	return Sakura::Player::Local::IsAlive();
}

bool Sakura::Lua::LocalPlayer::IsScoped()
{
	return g_Local.bScoped;
}

void Sakura::Lua::LocalPlayer::FixMoveStart(usercmd_s* cmd)
{
	::FixMoveStart(cmd);
}

void Sakura::Lua::LocalPlayer::FixMoveEnd(usercmd_s* cmd)
{
	::FixMoveEnd(cmd);
}

Vector Sakura::Lua::LocalPlayer::GetOrigin()
{
	return pmove->origin;
}

Vector Sakura::Lua::LocalPlayer::GetViewAngles()
{
	return pmove->angles;
}

void Sakura::Lua::LocalPlayer::SetViewAngles(Vector angles)
{
	pmove->angles = angles;
}

Vector Sakura::Lua::LocalPlayer::GetEyePosition()
{
	return pmove->origin + pmove->view_ofs;
}

bool Sakura::Lua::LocalPlayer::IsCurWeaponKnife()
{
	return ::IsCurWeaponKnife();
}

bool Sakura::Lua::LocalPlayer::IsCurWeaponPistol()
{
	return ::IsCurWeaponPistol();
}

bool Sakura::Lua::LocalPlayer::IsCurWeaponNade()
{
	return ::IsCurWeaponNade();
}

bool Sakura::Lua::LocalPlayer::IsCurWeaponSniper()
{
	return ::IsCurWeaponSniper();
}

bool Sakura::Lua::LocalPlayer::IsCurWeaponRifle()
{
	return ::IsCurWeaponRifle();
}

bool Sakura::Lua::LocalPlayer::IsCurWeaponShotGun()
{
	return ::IsCurWeaponShotGun();
}

bool Sakura::Lua::LocalPlayer::IsCurWeaponMachineGun()
{
	return ::IsCurWeaponMachineGun();
}

bool Sakura::Lua::LocalPlayer::IsCurWeaponSubMachineGun()
{
	return ::IsCurWeaponSubMachineGun();
}

bool Sakura::Lua::LocalPlayer::IsFlashed()
{
	if (Sakura::Fade::Percentage > 0)
		return true;

	return false;
}

int Sakura::Lua::LocalPlayer::GetFlashPercentage()
{
	return static_cast<int>(Sakura::Fade::Percentage);
}

screenfade_t Sakura::Lua::LocalPlayer::GetScreenFade()
{
	return Sakura::Fade::Screen;
}

void Sakura::Lua::Game::ExecuteCommand(const char* command)
{
	char _command[64];
	sprintf(_command, "%s", command);
	g_Engine.pfnClientCmd(_command);
}

std::string Sakura::Lua::Game::GetCommandString(const char* command)
{
	char _command[64];
	sprintf(_command, "%s", command);
	return g_Engine.pfnGetCvarString(_command);
}

float Sakura::Lua::Game::GetCommandFloat(const char* command)
{
	char _command[64];
	sprintf(_command, "%s", command);
	return g_Engine.pfnGetCvarFloat(_command);
}

int Sakura::Lua::Game::GetCommandInt(const char* command)
{
	char _command[64];
	sprintf(_command, "%s", command);
	return static_cast<int>(g_Engine.pfnGetCvarFloat(_command));
}

int Sakura::Lua::Player::GetTeam(const int index)
{
	if (index < 1 || index >= 32)
		return 0;

	return g_Player[index].iTeam;
}

Vector Sakura::Lua::Player::GetOrigin(const int index)
{
	if (index < 1 || index >= 32)
		return Vector(9999, 0, 0);

	cl_entity_s* player = g_Engine.GetEntityByIndex(index);
	return player->origin;
}

int Sakura::Lua::Player::GetHealth(const int index)
{
	if (index < 1 || index >= 32)
		return 0;

	return g_Player[index].iHealth;
}

std::string Sakura::Lua::Player::GetName(const int index)
{
	if (index < 1 || index >= 32)
		return "Unknown";

	player_info_s* player = g_Studio.PlayerInfo(index - 1);
	return player->name;
}

std::string Sakura::Lua::Player::GetModelName(const int index)
{
	if (index < 1 || index >= 32)
		return "Unknown";

	return PlayerEsp[index].model;
}

int Sakura::Lua::Player::GetDistance(const int index)
{
	if (index < 1 || index >= 32)
		return 0;

	cl_entity_s* player = g_Engine.GetEntityByIndex(index);

	Vector vDifference = player->origin - Sakura::Lua::LocalPlayer::GetEyePosition();
	int iDistance = int(vDifference.Length() / 22.0f);
	return iDistance;
}

float Sakura::Lua::Player::GetActualDistance(const int index)
{
	if (index < 1 || index >= 32)
		return 0;

	cl_entity_s* player = g_Engine.GetEntityByIndex(index);

	Vector vDifference = player->origin - Sakura::Lua::LocalPlayer::GetEyePosition();
	return vDifference.Length();
}

int Sakura::Lua::Player::GetPing(const int index)
{
	if (index < 1 || index >= 32)
		return 0;

	player_info_s* player = g_Studio.PlayerInfo(index - 1);
	return player->ping;
}

bool Sakura::Lua::Player::IsAlive(const int index)
{
	if (index < 1 || index >= 32)
		return 0;

	return ::Sakura::Player::IsAlive(index);
}

void Sakura::Lua::Notify::Create(const char* szTitle, const int secondsDisplay = 3)
{
	Toast::Create(secondsDisplay, szTitle);
}

void Sakura::Lua::ImGui::Window(const char* szTitle, ImGuiWindowFlags flags, luabridge::LuaRef lfFunction)
{
	if (::ImGui::Begin(szTitle, 0, flags))
	{
		try
		{
			lfFunction();
		}
		catch (luabridge::LuaException const& error)
		{
			Sakura::Lua::Error("Error has occured in the lua \"Window Create\" script: %s", error.what());
		}
	}
	::ImGui::End();
}

void Sakura::Lua::ImGui::Text(const char* szText)
{
	::ImGui::Text(szText);
}

bool Sakura::Lua::ImGui::Button(const char* szText)
{
	return ::ImGui::Button(szText);
}

bool Sakura::Lua::ImGui::Checkbox(const char* szText, bool bCurrentValue)
{
	bool bTheValue = bCurrentValue;
	::ImGui::Checkbox(szText, &bTheValue);
	return bTheValue;
}

void Sakura::Lua::ImGui::SameLine()
{
	::ImGui::SameLine();
}

void Sakura::Lua::ImGui::Spacing()
{
	::ImGui::Spacing();
}

int Sakura::Lua::ImGui::Combo(const char* szText, int iCurrentValue, const char* szOptions)
{
	int iTheValue = iCurrentValue;
	::ImGui::Combo(szText, &iTheValue, szOptions);
	return iTheValue;
}

int Sakura::Lua::ImGui::SliderInt(const char* szText, int iTheValue, int iMinimium, int iMaximum)
{
	::ImGui::SliderInt(szText, &iTheValue, iMinimium, iMaximum);
	return iTheValue;
}

float Sakura::Lua::ImGui::KeyBind(const char* szText, int iKey)
{
	float iTheKey = iKey;
	::Sakura::Menu::HudKeyBind(iTheKey, szText, {}, true);
	return iTheKey;
}

ImColor Sakura::Lua::ImGui::Color(const char* szText, ImColor& color)
{
	::Sakura::Menu::Widgets::ColorEdit(szText, (float*)&color, ImGuiColorEditFlags_NoDragDrop | ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_NoLabel | ImGuiColorEditFlags_AlphaBar);
	return color;
}

ImVec2 Sakura::Lua::ImGui::CalcTextSize(const char* label)
{
	return ::ImGui::CalcTextSize(label);
}

ImVec2 Sakura::Lua::ImGui::GetWindowSize()
{
	return ::ImGui::GetWindowSize();
}

void Sakura::Lua::ImGui::Drawings::AddRect(ImVec2& start, ImVec2& end, ImColor& color, float rounding, int flags, float thickness)
{
	::ImGui::GetWindowDrawList()->AddRect(start, end, color, rounding, flags, thickness);
}

void Sakura::Lua::ImGui::Drawings::AddLine(ImVec2& start, ImVec2& end, ImColor& color, float thickness)
{
	::ImGui::GetWindowDrawList()->AddLine(start, end, color, thickness);
}

void Sakura::Lua::ImGui::Drawings::AddText(ImVec2& position, ImColor& color, const char* szText)
{
	::ImGui::GetWindowDrawList()->AddText(position, color, szText);
}

void Sakura::Lua::ImGui::Drawings::AddRectFilled(ImVec2& start, ImVec2& end, ImColor& color, float rounding, int corners)
{
	::ImGui::GetWindowDrawList()->AddRectFilled(start, end, color, rounding, corners);
}

void Sakura::Lua::Log::File(const char* text)
{
	::Sakura::Log::File(text);
}

void Sakura::Lua::Log::Console(const char* text)
{
	::Sakura::Log::Console(text);
}
//s
//void Sakura::Lua::Settings::SaveInt(const std::string name, int value)
//{
//	LogToFile("Saving int from lua: %i", value);
//	std::string luacvar = "lua_" + name;
//	AddCvarFloat(luacvar.c_str(), &value);
//}
//
//void Sakura::Lua::Settings::SaveFloat(const std::string name, float value)
//{
//	LogToFile("Saving float from lua: %.1f", value);
//	std::string luacvar = "lua_" + name;
//	AddCvarFloat(luacvar.c_str(), &value);
//}
//
//void Sakura::Lua::Settings::SaveBool(const std::string name, bool value)
//{
//	LogToFile("Saving bool from lua: %.0f", &value);
//	std::string luacvar = "lua_" + name;
//	AddCvarFloat(luacvar.c_str(), &value);
//}
//
//int Sakura::Lua::Settings::LoadInt(const std::string name, const int value)
//{
//	std::string luacvar = "lua_" + name;
//
//	for (names.it_start(); names.it_running(); names.it_next())
//	{
//		if (strcmp(names.str, luacvar.c_str()) != 0)
//			continue;
//
//		int index = names.num;
//
//		if (entries[index].data == nullptr)
//			break;
//
//		int* floatPtr = static_cast<int*>(entries[index].data);
//		return *floatPtr;
//	}
//
//	return value; // return the default value
//}
//
//float Sakura::Lua::Settings::LoadFloat(const std::string name, const float value)
//{
//	std::string luacvar = "lua_" + name;
//
//	for (names.it_start(); names.it_running(); names.it_next())
//	{
//		if (strcmp(names.str, luacvar.c_str()) != 0)
//			continue;
//
//		int index = names.num;
//
//		if (entries[index].data == nullptr)
//			break;
//
//		float* floatPtr = static_cast<float*>(entries[index].data);
//		return *floatPtr;
//	}
//
//	return value; // return the default value
//}
//
//bool Sakura::Lua::Settings::LoadBool(const std::string name, const bool value)
//{
//	std::string luacvar = "lua_" + name;
//
//	for (names.it_start(); names.it_running(); names.it_next())
//	{
//		if (strcmp(names.str, luacvar.c_str()) != 0)
//			continue;
//
//		int index = names.num;
//
//		if (entries[index].data == nullptr)
//			break;
//
//		bool* floatPtr = static_cast<bool*>(entries[index].data);
//		return *floatPtr;
//	}
//
//	return value; // return the default value
//}

void Sakura::Lua::DynamicSound::ChangeNextSoundVolume(float volume)
{
	::Sakura::Esp::ChangeDynamicSoundVolume(volume);
}

void DefineLuaGlobal(lua_State* L, const char* name, int value)
{
	lua_pushinteger(L, value);
	lua_setglobal(L, name);
}

bool Sakura::Lua::Init(lua_State* L)
{
	luabridge::enableExceptions(L);
	luabridge::getGlobalNamespace(L)

		.beginClass<ImVec2>(/*ImVec2*/XorStr<0x79, 7, 0x84042922>("\x30\x17\x2D\x19\x1E\x4C" + 0x84042922).s)
			.addConstructor<void(*)(float, float)>()
			.addProperty(/*x*/XorStr<0x09, 2, 0x5AA47203>("\x71" + 0x5AA47203).s, &ImVec2::x)
			.addProperty(/*y*/XorStr<0xCC, 2, 0x453C26ED>("\xB5" + 0x453C26ED).s, &ImVec2::y)
		.endClass()

		.beginClass<ImVec4>(/*ImVec4*/XorStr<0x11, 7, 0x0ADE380C>("\x58\x7F\x45\x71\x76\x22" + 0x0ADE380C).s)
			.addConstructor<void(*)(float, float, float, float)>()
			.addProperty(/*x*/XorStr<0x75, 2, 0x5F01E2A4>("\x0D" + 0x5F01E2A4).s, &ImVec4::x)
			.addProperty(/*y*/XorStr<0x6F, 2, 0x54E534EC>("\x16" + 0x54E534EC).s, &ImVec4::y)
			.addProperty(/*z*/XorStr<0x04, 2, 0x22029859>("\x7E" + 0x22029859).s, &ImVec4::z)
			.addProperty(/*w*/XorStr<0x89, 2, 0xE40BE6DD>("\xFE" + 0xE40BE6DD).s, &ImVec4::w)
		.endClass()

		.beginClass<ImColor>(/*ImColor*/XorStr<0x2E, 8, 0x520DBF41>("\x67\x42\x73\x5E\x5E\x5C\x46" + 0x520DBF41).s)
			.addConstructor<void(*)(int, int, int, int)>()
			.addProperty(/*Value*/XorStr<0xEF, 6, 0x7C809B8D>("\xB9\x91\x9D\x87\x96" + 0x7C809B8D).s, &ImColor::Value)
		.endClass()

		.beginClass<Vector2D>(/*Vector2D*/XorStr<0x54, 9, 0x1E92C89F>("\x02\x30\x35\x23\x37\x2B\x68\x1F" + 0x1E92C89F).s)
			.addConstructor<void(*)(float, float)>()
			.addProperty(/*x*/XorStr<0x47, 2, 0xB286AD23>("\x3F" + 0xB286AD23).s, &Vector2D::x)
			.addProperty(/*y*/XorStr<0xBF, 2, 0x03A5DF30>("\xC6" + 0x03A5DF30).s, &Vector2D::y)
			.addFunction(/*Length*/XorStr<0xCD, 7, 0xA337D0F8>("\x81\xAB\xA1\xB7\xA5\xBA" + 0xA337D0F8).s, &Vector2D::Length)
			.addFunction(/*Normalize*/XorStr<0x22, 10, 0x0D8A6053>("\x6C\x4C\x56\x48\x47\x4B\x41\x53\x4F" + 0x0D8A6053).s, &Vector2D::Normalize)
			.addFunction(/*__add*/XorStr<0xD4, 6, 0xBF7D6CDB>("\x8B\x8A\xB7\xB3\xBC" + 0xBF7D6CDB).s, &Vector2D::operator+)
			.addFunction(/*__sub*/XorStr<0x5C, 6, 0x3014A844>("\x03\x02\x2D\x2A\x02" + 0x3014A844).s, &Vector2D::operator-)
			.addFunction(/*__mul*/XorStr<0x99, 6, 0x849D9BB5>("\xC6\xC5\xF6\xE9\xF1" + 0x849D9BB5).s, &Vector2D::operator*)
			.addFunction(/*__div*/XorStr<0xE6, 6, 0x838B1A69>("\xB9\xB8\x8C\x80\x9C" + 0x838B1A69).s, &Vector2D::operator/)
		.endClass()

		.beginClass<Vector>(/*Vector*/XorStr<0x51, 7, 0x61C52BF8>("\x07\x37\x30\x20\x3A\x24" + 0x61C52BF8).s)
			.addConstructor<void(*)(float, float, float)>().addProperty(/*x*/XorStr<0xD8, 2, 0x6406123A>("\xA0" + 0x6406123A).s, &Vector::x)
			.addProperty(/*y*/XorStr<0x73, 2, 0x1515ECAB>("\x0A" + 0x1515ECAB).s, &Vector::y)
			.addProperty(/*z*/XorStr<0xA3, 2, 0xB6924591>("\xD9" + 0xB6924591).s, &Vector::z)
			.addFunction(/*Length*/XorStr<0xC0, 7, 0x563CAFD5>("\x8C\xA4\xAC\xA4\xB0\xAD" + 0x563CAFD5).s, &Vector::Length)
			.addFunction(/*Length2D*/XorStr<0x76, 9, 0x634E347F>("\x3A\x12\x16\x1E\x0E\x13\x4E\x39" + 0x634E347F).s, &Vector::Length2D)
			.addFunction(/*Normalize*/XorStr<0x7C, 10, 0x0E00E7C4>("\x32\x12\x0C\x12\xE1\xED\xEB\xF9\xE1" + 0x0E00E7C4).s, &Vector::Normalize)
			.addFunction(/*IsZero*/XorStr<0x39, 7, 0x403066AF>("\x70\x49\x61\x59\x4F\x51" + 0x403066AF).s, &Vector::IsZero)
			.addFunction(/*IsZero2D*/XorStr<0xAB, 9, 0x4974D96E>("\xE2\xDF\xF7\xCB\xDD\xDF\x83\xF6" + 0x4974D96E).s, &Vector::IsZero2D)
			.addFunction(/*Make2D*/XorStr<0x29, 7, 0x3934EEAE>("\x64\x4B\x40\x49\x1F\x6A" + 0x3934EEAE).s, &Vector::Make2D)
		.endClass()

		.beginClass<usercmd_s>(/*usercmd*/XorStr<0xC4, 8, 0xBF1410D5>("\xB1\xB6\xA3\xB5\xAB\xA4\xAE" + 0xBF1410D5).s)
			.addProperty(/*lerp_msec*/XorStr<0xEF, 10, 0x449F4415>("\x83\x95\x83\x82\xAC\x99\x86\x93\x94" + 0x449F4415).s, &usercmd_s::lerp_msec)
			.addProperty(/*msec*/XorStr<0x3E, 5, 0x1D6742B4>("\x53\x4C\x25\x22" + 0x1D6742B4).s, &usercmd_s::msec)
			.addProperty(/*viewangles*/XorStr<0xDB, 11, 0x0B845F5A>("\xAD\xB5\xB8\xA9\xBE\x8E\x86\x8E\x86\x97" + 0x0B845F5A).s, &usercmd_s::viewangles)
			.addProperty(/*forwardmove*/XorStr<0x88, 12, 0xA6813C6B>("\xEE\xE6\xF8\xFC\xED\xFF\xEA\xE2\xFF\xE7\xF7" + 0xA6813C6B).s, &usercmd_s::forwardmove)
			.addProperty(/*sidemove*/XorStr<0xCB, 9, 0xD64C1431>("\xB8\xA5\xA9\xAB\xA2\xBF\xA7\xB7" + 0xD64C1431).s, &usercmd_s::sidemove)
			.addProperty(/*upmove*/XorStr<0xFA, 7, 0x3388C2ED>("\x8F\x8B\x91\x92\x88\x9A" + 0x3388C2ED).s, &usercmd_s::upmove)
			.addProperty(/*lightlevel*/XorStr<0x6A, 11, 0x61B2FF36>("\x06\x02\x0B\x05\x1A\x03\x15\x07\x17\x1F" + 0x61B2FF36).s, &usercmd_s::lightlevel)
			.addProperty(/*buttons*/XorStr<0xE7, 8, 0x15E11A65>("\x85\x9D\x9D\x9E\x84\x82\x9E" + 0x15E11A65).s, &usercmd_s::buttons)
			.addProperty(/*impulse*/XorStr<0xC4, 8, 0x94950B7B>("\xAD\xA8\xB6\xB2\xA4\xBA\xAF" + 0x94950B7B).s, &usercmd_s::impulse)
			.addProperty(/*weaponselect*/XorStr<0x65, 13, 0x90F95EA3>("\x12\x03\x06\x18\x06\x04\x18\x09\x01\x0B\x0C\x04" + 0x90F95EA3).s, &usercmd_s::weaponselect)
			.addProperty(/*impact_index*/XorStr<0xC6, 13, 0x58F71823>("\xAF\xAA\xB8\xA8\xA9\xBF\x93\xA4\xA0\xAB\xB5\xA9" + 0x58F71823).s, &usercmd_s::impact_index)
			.addProperty(/*impact_position*/XorStr<0xE6, 16, 0xC4AA9336>("\x8F\x8A\x98\x88\x89\x9F\xB3\x9D\x81\x9C\x99\x85\x9B\x9C\x9A" + 0xC4AA9336).s, &usercmd_s::impact_position)
		.endClass()

		.beginClass<CBasePlayerWeapon>(/*player_weapon*/XorStr<0xBC, 14, 0x7CCBED97>("\xCC\xD1\xDF\xC6\xA5\xB3\x9D\xB4\xA1\xA4\xB6\xA8\xA6" + 0x7CCBED97).s)
			.addProperty(/*fire_delay*/XorStr<0xC8, 11, 0x4D44D2A5>("\xAE\xA0\xB8\xAE\x93\xA9\xAB\xA3\xB1\xA8" + 0x4D44D2A5).s, &CBasePlayerWeapon::m_bDelayFire)
			.addProperty(/*weapon_state*/XorStr<0x97, 13, 0xE61D6924>("\xE0\xFD\xF8\xEA\xF4\xF2\xC2\xED\xEB\xC1\xD5\xC7" + 0xE61D6924).s, &CBasePlayerWeapon::m_iWeaponState)
			.addProperty(/*flags*/XorStr<0x25, 6, 0x394BCF77>("\x43\x4A\x46\x4F\x5A" + 0x394BCF77).s, &CBasePlayerWeapon::m_iFlags)
			.addProperty(/*clip*/XorStr<0x6F, 5, 0x45D01AD6>("\x0C\x1C\x18\x02" + 0x45D01AD6).s, &CBasePlayerWeapon::m_iClip)
			.addProperty(/*id*/XorStr<0x3D, 3, 0x9511841B>("\x54\x5A" + 0x9511841B).s, &CBasePlayerWeapon::m_iWeaponID)
			.addProperty(/*in_reload*/XorStr<0xE1, 10, 0x99145262>("\x88\x8C\xBC\x96\x80\x8A\x88\x89\x8D" + 0x99145262).s, &CBasePlayerWeapon::m_iInReload)
			.addProperty(/*penetration*/XorStr<0xEC, 12, 0x58EB3D2F>("\x9C\x88\x80\x8A\x84\x83\x93\x87\x9D\x9A\x98" + 0x58EB3D2F).s, &CBasePlayerWeapon::iPenetration)
			.addProperty(/*bullet_type*/XorStr<0x26, 12, 0x0DDE0999>("\x44\x52\x44\x45\x4F\x5F\x73\x59\x57\x5F\x55" + 0x0DDE0999).s, &CBasePlayerWeapon::iBulletType)
			.addProperty(/*damage_1*/XorStr<0x04, 9, 0x25A030FA>("\x60\x64\x6B\x66\x6F\x6C\x55\x3A" + 0x25A030FA).s, &CBasePlayerWeapon::iDamage1)
			.addProperty(/*damage_2*/XorStr<0x5E, 9, 0x6B650B36>("\x3A\x3E\x0D\x00\x05\x06\x3B\x57" + 0x6B650B36).s, &CBasePlayerWeapon::iDamage2)
			.addProperty(/*shots_fired*/XorStr<0x66, 12, 0x89A02988>("\x15\x0F\x07\x1D\x19\x34\x0A\x04\x1C\x0A\x14" + 0x89A02988).s, &CBasePlayerWeapon::m_iShotsFired)
			.addProperty(/*user3*/XorStr<0xE1, 6, 0x4D6C2377>("\x94\x91\x86\x96\xD6" + 0x4D6C2377).s, &CBasePlayerWeapon::iuser3)
			.addProperty(/*prevtime*/XorStr<0xBA, 9, 0x2C95D71B>("\xCA\xC9\xD9\xCB\xCA\xD6\xAD\xA4" + 0x2C95D71B).s, &CBasePlayerWeapon::prevtime)
			.addProperty(/*curtime*/XorStr<0xF7, 8, 0xF5E92D45>("\x94\x8D\x8B\x8E\x92\x91\x98" + 0xF5E92D45).s, &CBasePlayerWeapon::curtime)
			.addProperty(/*decrease_shots_fired*/XorStr<0x9D, 21, 0x82D3FE2C>("\xF9\xFB\xFC\xD2\xC4\xC3\xD0\xC1\xFA\xD5\xCF\xC7\xDD\xD9\xF4\xCA\xC4\xDC\xCA\xD4" + 0x82D3FE2C).s, &CBasePlayerWeapon::m_flDecreaseShotsFired)
			.addProperty(/*accuracy*/XorStr<0x87, 9, 0xF477CAA5>("\xE6\xEB\xEA\xFF\xF9\xED\xEE\xF7" + 0xF477CAA5).s, &CBasePlayerWeapon::m_flAccuracy)
			.addProperty(/*spread*/XorStr<0x5E, 7, 0x29671F4D>("\x2D\x2F\x12\x04\x03\x07" + 0x29671F4D).s, &CBasePlayerWeapon::m_flSpread)
			.addProperty(/*next_primary_attack*/XorStr<0x7D, 20, 0x2D1EC4DA>("\x13\x1B\x07\xF4\xDE\xF2\xF1\xED\xE8\xE7\xF5\xF1\xD6\xEB\xFF\xF8\xEC\xED\xE4" + 0x2D1EC4DA).s, &CBasePlayerWeapon::m_flNextPrimaryAttack)
			.addProperty(/*next_secondary_attack*/XorStr<0x2A, 22, 0x62014A35>("\x44\x4E\x54\x59\x71\x5C\x55\x52\x5D\x5D\x50\x54\x44\x4E\x67\x58\x4E\x4F\x5D\x5E\x55" + 0x62014A35).s, &CBasePlayerWeapon::m_flNextSecondaryAttack)
			.addProperty(/*next_attack*/XorStr<0x71, 12, 0x78D1B6E4>("\x1F\x17\x0B\x00\x2A\x17\x03\x0C\x18\x19\x10" + 0x78D1B6E4).s, &CBasePlayerWeapon::m_flNextAttack)
			.addProperty(/*penetration_distance*/XorStr<0xAE, 21, 0x9BDB3523>("\xDE\xCA\xDE\xD4\xC6\xC1\xD5\xC1\xDF\xD8\xD6\xE6\xDE\xD2\xCF\xC9\xDF\xD1\xA3\xA4" + 0x9BDB3523).s, &CBasePlayerWeapon::flPenetrationDistance)
			.addProperty(/*wall_pierce_1*/XorStr<0xAA, 14, 0xD264C2B2>("\xDD\xCA\xC0\xC1\xF1\xDF\xD9\xD4\xC0\xD0\xD1\xEA\x87" + 0xD264C2B2).s, &CBasePlayerWeapon::flWallPierce1)
			.addProperty(/*wall_pierce_2*/XorStr<0x67, 14, 0xDC0C26DD>("\x10\x09\x05\x06\x34\x1C\x04\x0B\x1D\x13\x14\x2D\x41" + 0xDC0C26DD).s, &CBasePlayerWeapon::flWallPierce2)
		.endClass()

		.beginClass<screenfade_t>(/*screen_fade*/XorStr<0x24, 12, 0x9DCFAAB6>("\x57\x46\x54\x42\x4D\x47\x75\x4D\x4D\x49\x4B" + 0x9DCFAAB6).s)
			.addProperty(/*speed*/XorStr<0xF8, 6, 0x00D2062B>("\x8B\x89\x9F\x9E\x98" + 0x00D2062B).s, &screenfade_t::fadeSpeed)
			.addProperty(/*_end*/XorStr<0x56, 5, 0xE6C183B7>("\x09\x32\x36\x3D" + 0xE6C183B7).s, &screenfade_t::fadeEnd)
			.addProperty(/*total_end*/XorStr<0x50, 10, 0x185230E4>("\x24\x3E\x26\x32\x38\x0A\x33\x39\x3C" + 0x185230E4).s, &screenfade_t::fadeTotalEnd)
			.addProperty(/*reset*/XorStr<0x33, 6, 0xB6B8B0DA>("\x41\x51\x46\x53\x43" + 0xB6B8B0DA).s, &screenfade_t::fadeReset)
			.addProperty(/*r*/XorStr<0x3F, 2, 0x68C34BD0>("\x4D" + 0x68C34BD0).s, &screenfade_t::fader)
			.addProperty(/*g*/XorStr<0xE5, 2, 0xFA0953AC>("\x82" + 0xFA0953AC).s, &screenfade_t::fadeg)
			.addProperty(/*b*/XorStr<0x69, 2, 0x4B228C12>("\x0B" + 0x4B228C12).s, &screenfade_t::fadeb)
			.addProperty(/*a*/XorStr<0x7B, 2, 0x1D379422>("\x1A" + 0x1D379422).s, &screenfade_t::fadealpha)
			.addProperty(/*flags*/XorStr<0x18, 6, 0xD5B576DC>("\x7E\x75\x7B\x7C\x6F" + 0xD5B576DC).s, &screenfade_t::fadeFlags)
		.endClass()
					
		.beginNamespace(/*Hooks*/XorStr<0xEA, 6, 0x648021F0>("\xA2\x84\x83\x86\x9D" + 0x648021F0).s)
			.addFunction(/*Register*/XorStr<0x7D, 9, 0x999563DC>("\x2F\x1B\x18\xE9\xF2\xF6\xE6\xF6" + 0x999563DC).s, &Sakura::Lua::Hooks::RegisterCallBack)
		.endNamespace()

		.beginNamespace(/*Game*/XorStr<0x29, 5, 0xB6A66ED4>("\x6E\x4B\x46\x49" + 0xB6A66ED4).s)
			.addFunction(/*WorldToScreen*/XorStr<0x37, 14, 0x2162C868>("\x60\x57\x4B\x56\x5F\x68\x52\x6D\x5C\x32\x24\x27\x2D" + 0x2162C868).s, &Sakura::Lua::Game::WorldToScreen)
			.addFunction(/*GameGetLastConvertedToScreenVector*/XorStr<0x64, 35, 0x390E67A9>("\x23\x04\x0B\x02\x2F\x0C\x1E\x27\x0D\x1E\x1A\x2C\x1F\x1F\x04\x16\x06\x01\x13\x13\x2C\x16\x29\x18\x0E\x18\x1B\x11\xD6\xE4\xE1\xF7\xEB\xF7" + 0x390E67A9).s, &Sakura::Lua::Game::GetLastConvertedToScreenVector)
			.addFunction(/*SendPacket*/XorStr<0x2C, 11, 0x1C5B8FB3>("\x7F\x48\x40\x4B\x60\x50\x51\x58\x51\x41" + 0x1C5B8FB3).s, &Sakura::Lua::Game::SendPacket)
			.addFunction(/*LoadSound*/XorStr<0x5E, 10, 0x9B22E119>("\x12\x30\x01\x05\x31\x0C\x11\x0B\x02" + 0x9B22E119).s, &Sakura::Lua::Game::InitSound)
			.addFunction(/*PlaySound*/XorStr<0x07, 10, 0x1DE649F3>("\x57\x64\x68\x73\x58\x63\x78\x60\x6B" + 0x1DE649F3).s, &Sakura::Lua::Game::SoundPlay)
			.addFunction(/*GetTime*/XorStr<0x12, 8, 0x51884B6A>("\x55\x76\x60\x41\x7F\x7A\x7D" + 0x51884B6A).s, &Sakura::Lua::Game::GetTime)
			.addFunction(/*GetClientTime*/XorStr<0xB1, 14, 0x137E8E86>("\xF6\xD7\xC7\xF7\xD9\xDF\xD2\xD6\xCD\xEE\xD2\xD1\xD8" + 0x137E8E86).s, &Sakura::Lua::Game::GetClientTime)
			.addFunction(/*CreateVisibleEntity*/XorStr<0x9A, 20, 0xC6888DB0>("\xD9\xE9\xF9\xFC\xEA\xFA\xF6\xC8\xD1\xCA\xC6\xC9\xC3\xE2\xC6\xDD\xC3\xDF\xD5" + 0xC6888DB0).s, &Sakura::Lua::Game::CreateVisibleEntity)
			.addFunction(/*CreateBeamPoint*/XorStr<0x7A, 16, 0x8F44EF3C>("\x39\x09\x19\x1C\x0A\x1A\xC2\xE4\xE3\xEE\xD4\xEA\xEF\xE9\xFC" + 0x8F44EF3C).s, &Sakura::Lua::Game::CreateBeamPoint)
			.addFunction(/*ChangeNextSoundVolume*/XorStr<0xEC, 22, 0x8E2E4CC1>("\xAF\x85\x8F\x81\x97\x94\xBC\x96\x8C\x81\xA5\x98\x8D\x97\x9E\xAD\x93\x91\x8B\x92\x65" + 0x8E2E4CC1).s, &Sakura::Lua::DynamicSound::ChangeNextSoundVolume)

			.addFunction(/*GetCommandString*/XorStr<0x9F, 17, 0x0E8E3F45>("\xD8\xC5\xD5\xE1\xCC\xC9\xC8\xC7\xC9\xCC\xFA\xDE\xD9\xC5\xC3\xC9" + 0x0E8E3F45).s, &Sakura::Lua::Game::GetCommandString)
			.addFunction(/*GetCommandFloat*/XorStr<0x83, 16, 0x4C1D1239>("\xC4\xE1\xF1\xC5\xE8\xE5\xE4\xEB\xE5\xE8\xCB\xE2\xE0\xF1\xE5" + 0x4C1D1239).s, &Sakura::Lua::Game::GetCommandFloat)
			.addFunction(/*GetCommandInt*/XorStr<0xD6, 14, 0xB8F05874>("\x91\xB2\xAC\x9A\xB5\xB6\xB1\xBC\xB0\xBB\xA9\x8F\x96" + 0xB8F05874).s, &Sakura::Lua::Game::GetCommandInt)
			.addFunction(/*ExecuteCommand*/XorStr<0x98, 15, 0xE14F3820>("\xDD\xE1\xFF\xF8\xE9\xE9\xFB\xDC\xCF\xCC\xCF\xC2\xCA\xC1" + 0xE14F3820).s, &Sakura::Lua::Game::ExecuteCommand)
		.endNamespace()

		.beginNamespace(/*ImGui*/XorStr<0xEB, 6, 0x030A2F7B>("\xA2\x81\xAA\x9B\x86" + 0x030A2F7B).s)
			.addFunction(/*Window*/XorStr<0xF3, 7, 0xFE3DE656>("\xA4\x9D\x9B\x92\x98\x8F" + 0xFE3DE656).s, &Sakura::Lua::ImGui::Window)
			.addFunction(/*Text*/XorStr<0x64, 5, 0xA2F2BC57>("\x30\x00\x1E\x13" + 0xA2F2BC57).s, &Sakura::Lua::ImGui::Text)
			.addFunction(/*Button*/XorStr<0xFC, 7, 0x33955BF3>("\xBE\x88\x8A\x8B\x6F\x6F" + 0x33955BF3).s, &Sakura::Lua::ImGui::Button)
			.addFunction(/*Checkbox*/XorStr<0x3E, 9, 0xFC91CD6E>("\x7D\x57\x25\x22\x29\x21\x2B\x3D" + 0xFC91CD6E).s, &Sakura::Lua::ImGui::Checkbox)
			.addFunction(/*SameLine*/XorStr<0x50, 9, 0x687785C9>("\x03\x30\x3F\x36\x18\x3C\x38\x32" + 0x687785C9).s, &Sakura::Lua::ImGui::SameLine)
			.addFunction(/*Combo*/XorStr<0x3B, 6, 0xB10CC06D>("\x78\x53\x50\x5C\x50" + 0xB10CC06D).s, &Sakura::Lua::ImGui::Combo)
			.addFunction(/*Slider*/XorStr<0xFB, 7, 0x78434745>("\xA8\x90\x94\x9A\x9A\x72" + 0x78434745).s, &Sakura::Lua::ImGui::SliderInt)
			.addFunction(/*KeyBind*/XorStr<0x94, 8, 0xB616A5E0>("\xDF\xF0\xEF\xD5\xF1\xF7\xFE" + 0xB616A5E0).s, &Sakura::Lua::ImGui::KeyBind)
			.addFunction(/*Color*/XorStr<0xD3, 6, 0xF2BB0F8E>("\x90\xBB\xB9\xB9\xA5" + 0xF2BB0F8E).s, &Sakura::Lua::ImGui::Color)
			.addFunction(/*GetWindowSize*/XorStr<0xE7, 14, 0x95D5E7B3>("\xA0\x8D\x9D\xBD\x82\x82\x89\x81\x98\xA3\x98\x88\x96" + 0x95D5E7B3).s, &Sakura::Lua::ImGui::GetWindowSize)
			.addFunction(/*CalcTextSize*/XorStr<0x50, 13, 0x29372F7F>("\x13\x30\x3E\x30\x00\x30\x2E\x23\x0B\x30\x20\x3E" + 0x29372F7F).s, &Sakura::Lua::ImGui::CalcTextSize)
		.endNamespace()

		.beginNamespace(/*Render*/XorStr<0x20, 7, 0x04987D97>("\x72\x44\x4C\x47\x41\x57" + 0x04987D97).s)
			.addFunction(/*AddRect*/XorStr<0xAC, 8, 0xCD4B0D08>("\xED\xC9\xCA\xFD\xD5\xD2\xC6" + 0xCD4B0D08).s, &Sakura::Lua::ImGui::Drawings::AddRect)
			.addFunction(/*AddLine*/XorStr<0x45, 8, 0x7431A3C4>("\x04\x22\x23\x04\x20\x24\x2E" + 0x7431A3C4).s, &Sakura::Lua::ImGui::Drawings::AddLine)
			.addFunction(/*AddText*/XorStr<0x55, 8, 0xCE019B0B>("\x14\x32\x33\x0C\x3C\x22\x2F" + 0xCE019B0B).s, &Sakura::Lua::ImGui::Drawings::AddText)
			.addFunction(/*AddRectFilled*/XorStr<0x21, 14, 0x2ACD8C6C>("\x60\x46\x47\x76\x40\x45\x53\x6E\x40\x46\x47\x49\x49" + 0x2ACD8C6C).s, &Sakura::Lua::ImGui::Drawings::AddRectFilled)
		.endNamespace()

		.beginNamespace(/*LocalPlayer*/XorStr<0xAF, 12, 0x5A79994C>("\xE3\xDF\xD2\xD3\xDF\xE4\xD9\xD7\xCE\xDD\xCB" + 0x5A79994C).s)
			.addFunction(/*GetIndex*/XorStr<0xB4, 9, 0xFF3B03A1>("\xF3\xD0\xC2\xFE\xD6\xDD\xDF\xC3" + 0xFF3B03A1).s, &Sakura::Lua::LocalPlayer::GetIndex)
			.addFunction(/*GetTeam*/XorStr<0x8C, 8, 0x5C960A86>("\xCB\xE8\xFA\xDB\xF5\xF0\xFF" + 0x5C960A86).s, &Sakura::Lua::LocalPlayer::GetTeam)
			.addFunction(/*GetFlags*/XorStr<0xE1, 9, 0x4BA58989>("\xA6\x87\x97\xA2\x89\x87\x80\x9B" + 0x4BA58989).s, &Sakura::Lua::LocalPlayer::GetFlags)
			.addFunction(/*CheckFlag*/XorStr<0xD7, 10, 0xB57C16CB>("\x94\xB0\xBC\xB9\xB0\x9A\xB1\xBF\xB8" + 0xB57C16CB).s, &Sakura::Lua::LocalPlayer::CheckFlag)
			.addFunction(/*GetButtons*/XorStr<0xF7, 11, 0xC1C24A05>("\xB0\x9D\x8D\xB8\x8E\x88\x89\x91\x91\x73" + 0xC1C24A05).s, &Sakura::Lua::LocalPlayer::GetButtons)
			.addFunction(/*CheckButton*/XorStr<0x5C, 12, 0x11A943EA>("\x1F\x35\x3B\x3C\x0B\x23\x17\x17\x10\x0A\x08" + 0x11A943EA).s, &Sakura::Lua::LocalPlayer::CheckButton)
			.addFunction(/*PressButton*/XorStr<0xA5, 12, 0x1D15356B>("\xF5\xD4\xC2\xDB\xDA\xE8\xDE\xD8\xD9\xC1\xC1" + 0x1D15356B).s, &Sakura::Lua::LocalPlayer::PressButton)
			.addFunction(/*ReleaseButton*/XorStr<0x4E, 14, 0xE8CCD6A1>("\x1C\x2A\x3C\x34\x33\x20\x31\x17\x23\x23\x2C\x36\x34" + 0xE8CCD6A1).s, &Sakura::Lua::LocalPlayer::ReleaseButton)
			.addFunction(/*GetOrigin*/XorStr<0xA5, 10, 0x4CEB1440>("\xE2\xC3\xD3\xE7\xDB\xC3\xCC\xC5\xC3" + 0x4CEB1440).s, &Sakura::Lua::LocalPlayer::GetOrigin)
			.addFunction(/*GetHealth*/XorStr<0xFC, 10, 0xF468BD7B>("\xBB\x98\x8A\xB7\x65\x60\x6E\x77\x6C" + 0xF468BD7B).s, &Sakura::Lua::LocalPlayer::GetHealth)
			.addFunction(/*GetFlashPercentage*/XorStr<0x29, 19, 0xC06B38F1>("\x6E\x4F\x5F\x6A\x41\x4F\x5C\x58\x61\x57\x41\x57\x50\x58\x43\x59\x5E\x5F" + 0xC06B38F1).s, &Sakura::Lua::LocalPlayer::GetFlashPercentage)
			.addFunction(/*GetViewAngles*/XorStr<0xCF, 14, 0xF64023AE>("\x88\xB5\xA5\x84\xBA\xB1\xA2\x97\xB9\xBF\xB5\xBF\xA8" + 0xF64023AE).s, &Sakura::Lua::LocalPlayer::GetViewAngles)
			.addFunction(/*SetViewAngles*/XorStr<0x0F, 14, 0x15AB9E07>("\x5C\x75\x65\x44\x7A\x71\x62\x57\x79\x7F\x75\x7F\x68" + 0x15AB9E07).s, &Sakura::Lua::LocalPlayer::SetViewAngles)
			.addFunction(/*IsAlive*/XorStr<0xAA, 8, 0xF34C8DFC>("\xE3\xD8\xED\xC1\xC7\xD9\xD5" + 0xF34C8DFC).s, &Sakura::Lua::LocalPlayer::IsAlive)
			.addFunction(/*IsScoped*/XorStr<0x78, 9, 0x85DE15FD>("\x31\x0A\x29\x18\x13\x0D\x1B\x1B" + 0x85DE15FD).s, &Sakura::Lua::LocalPlayer::IsScoped)
			.addFunction(/*IsInGame*/XorStr<0x99, 9, 0x81962084>("\xD0\xE9\xD2\xF2\xDA\xFF\xF2\xC5" + 0x81962084).s, &Sakura::Player::Local::InGame)
			.addFunction(/*IsFlashed*/XorStr<0x6E, 10, 0x30159D7C>("\x27\x1C\x36\x1D\x13\x00\x1C\x10\x12" + 0x30159D7C).s, &Sakura::Lua::LocalPlayer::IsFlashed)
			.addFunction(/*IsCurWeaponKnife*/XorStr<0x5E, 17, 0x3765BF8E>("\x17\x2C\x23\x14\x10\x34\x01\x04\x16\x08\x06\x22\x04\x02\x0A\x08" + 0x3765BF8E).s, &Sakura::Lua::LocalPlayer::IsCurWeaponKnife)
			.addFunction(/*IsCurWeaponPistol*/XorStr<0x69, 18, 0xAC73FF39>("\x20\x19\x28\x19\x1F\x39\x0A\x11\x01\x1D\x1D\x24\x1C\x05\x03\x17\x15" + 0xAC73FF39).s, &Sakura::Lua::LocalPlayer::IsCurWeaponPistol)
			.addFunction(/*IsCurWeaponNade*/XorStr<0x09, 16, 0x30B4447E>("\x40\x79\x48\x79\x7F\x59\x6A\x71\x61\x7D\x7D\x5A\x74\x72\x72" + 0x30B4447E).s, &Sakura::Lua::LocalPlayer::IsCurWeaponNade)
			.addFunction(/*IsCurWeaponSniper*/XorStr<0xC7, 18, 0x5FC64E88>("\x8E\xBB\x8A\xBF\xB9\x9B\xA8\xAF\xBF\xBF\xBF\x81\xBD\xBD\xA5\xB3\xA5" + 0x5FC64E88).s, &Sakura::Lua::LocalPlayer::IsCurWeaponSniper)
			.addFunction(/*IsCurWeaponRifle*/XorStr<0xE6, 17, 0xF12E93FF>("\xAF\x94\xAB\x9C\x98\xBC\x89\x8C\x9E\x80\x9E\xA3\x9B\x95\x98\x90" + 0xF12E93FF).s, &Sakura::Lua::LocalPlayer::IsCurWeaponRifle)
			.addFunction(/*IsCurWeaponShotGun*/XorStr<0xDC, 19, 0xFD518791>("\x95\xAE\x9D\xAA\x92\xB6\x87\x82\x94\x8A\x88\xB4\x80\x86\x9E\xAC\x99\x83" + 0xFD518791).s, &Sakura::Lua::LocalPlayer::IsCurWeaponShotGun)
			.addFunction(/*IsCurWeaponMachineGun*/XorStr<0x27, 22, 0xC5FCCF40>("\x6E\x5B\x6A\x5F\x59\x7B\x48\x4F\x5F\x5F\x5F\x7F\x52\x57\x5D\x5F\x59\x5D\x7E\x4F\x55" + 0xC5FCCF40).s, &Sakura::Lua::LocalPlayer::IsCurWeaponMachineGun)
			.addFunction(/*IsCurWeaponSubMachineGun*/XorStr<0x7B, 25, 0x7C5556FE>("\x32\x0F\x3E\x0B\x0D\xD7\xE4\xE3\xF3\xEB\xEB\xD5\xF2\xEA\xC4\xEB\xE8\xE4\xE4\xE0\xEA\xD7\xE4\xFC" + 0x7C5556FE).s, &Sakura::Lua::LocalPlayer::IsCurWeaponSubMachineGun)
			.addFunction(/*GetWeapon*/XorStr<0x77, 10, 0x6E2B991C>("\x30\x1D\x0D\x2D\x1E\x1D\x0D\x11\x11" + 0x6E2B991C).s, &GetWeapon)
			.addFunction(/*GetScreenFade*/XorStr<0x03, 14, 0x6FF923B6>("\x44\x61\x71\x55\x64\x7A\x6C\x6F\x65\x4A\x6C\x6A\x6A" + 0x6FF923B6).s, &Sakura::Lua::LocalPlayer::GetScreenFade)
			.addFunction(/*FixMoveStart*/XorStr<0xB9, 13, 0xA90F36E9>("\xFF\xD3\xC3\xF1\xD2\xC8\xDA\x93\xB5\xA3\xB1\xB0" + 0xA90F36E9).s, &Sakura::Lua::LocalPlayer::FixMoveStart)
			.addFunction(/*FixMoveEnd*/XorStr<0x78, 11, 0xCE837532>("\x3E\x10\x02\x36\x13\x0B\x1B\x3A\xEE\xE5" + 0xCE837532).s, &Sakura::Lua::LocalPlayer::FixMoveEnd)
		.endNamespace()

		.beginNamespace(/*Player*/XorStr<0x67, 7, 0x1AB714AC>("\x37\x04\x08\x13\x0E\x1E" + 0x1AB714AC).s)
			.addFunction(/*GetTeam*/XorStr<0x57, 8, 0xD116A49F>("\x10\x3D\x2D\x0E\x3E\x3D\x30" + 0xD116A49F).s, &Sakura::Lua::Player::GetTeam)
			.addFunction(/*GetOrigin*/XorStr<0xA9, 10, 0xD685D264>("\xEE\xCF\xDF\xE3\xDF\xC7\xC8\xD9\xDF" + 0xD685D264).s, &Sakura::Lua::Player::GetOrigin)
			.addFunction(/*GetName*/XorStr<0x70, 8, 0x4E275A2E>("\x37\x14\x06\x3D\x15\x18\x13" + 0x4E275A2E).s, &Sakura::Lua::Player::GetName)
			.addFunction(/*GetModelName*/XorStr<0xFD, 13, 0x0719D729>("\xBA\x9B\x8B\x4D\x6E\x66\x66\x68\x4B\x67\x6A\x6D" + 0x0719D729).s, &Sakura::Lua::Player::GetModelName)
			.addFunction(/*GetDistance*/XorStr<0x57, 12, 0x305936A0>("\x10\x3D\x2D\x1E\x32\x2F\x29\x3F\x31\x03\x04" + 0x305936A0).s, &Sakura::Lua::Player::GetDistance)
			.addFunction(/*GetActualDistance*/XorStr<0xF3, 18, 0x04F0F086>("\xB4\x91\x81\xB7\x94\x8C\x8C\x9B\x97\xB8\x94\x8D\x8B\x61\x6F\x61\x66" + 0x04F0F086).s, &Sakura::Lua::Player::GetActualDistance)
			.addFunction(/*GetPing*/XorStr<0x32, 8, 0xDDB69401>("\x75\x56\x40\x65\x5F\x59\x5F" + 0xDDB69401).s, &Sakura::Lua::Player::GetPing)
			.addFunction(/*GetHealth*/XorStr<0xD7, 10, 0x663EC287>("\x90\xBD\xAD\x92\xBE\xBD\xB1\xAA\xB7" + 0x663EC287).s, &Sakura::Lua::Player::GetHealth)
			.addFunction(/*IsAlive*/XorStr<0xC1, 8, 0x2A9C1877>("\x88\xB1\x82\xA8\xAC\xB0\xA2" + 0x2A9C1877).s, &Sakura::Lua::Player::IsAlive)
		.endNamespace()

		/*.beginNamespace("Settings")
			.addFunction("SaveInt", &Sakura::Lua::Settings::SaveInt)
			.addFunction("SaveFloat", &Sakura::Lua::Settings::SaveFloat)
			.addFunction("SaveBool", &Sakura::Lua::Settings::SaveBool)

			.addFunction("LoadInt", &Sakura::Lua::Settings::LoadInt)
			.addFunction("LoadFloat", &Sakura::Lua::Settings::LoadFloat)
			.addFunction("LoadBool", &Sakura::Lua::Settings::LoadBool)
		.endNamespace()*/

		.beginNamespace(/*Log*/XorStr<0xF5, 4, 0x10379B6D>("\xB9\x99\x90" + 0x10379B6D).s)
			.addFunction(/*File*/XorStr<0x8D, 5, 0xA2D32196>("\xCB\xE7\xE3\xF5" + 0xA2D32196).s, &Sakura::Lua::Log::File)
			.addFunction(/*Console*/XorStr<0xD5, 8, 0x39F62743>("\x96\xB9\xB9\xAB\xB6\xB6\xBE" + 0x39F62743).s, &Sakura::Lua::Log::Console)
		.endNamespace()

		.beginNamespace(/*Notify*/XorStr<0x79, 7, 0x2E21D3B0>("\x37\x15\x0F\x15\x1B\x07" + 0x2E21D3B0).s)
			.addFunction(/*Create*/XorStr<0xA7, 7, 0xB5AE7230>("\xE4\xDA\xCC\xCB\xDF\xC9" + 0xB5AE7230).s, &Sakura::Lua::Notify::Create)
		.endNamespace()
		;

	DefineLuaGlobal(L, /*SAKURA_MENU_RENDER*/XorStr<0x4C, 19, 0x19B92750>("\x1F\x0C\x05\x1A\x02\x10\x0D\x1E\x11\x1B\x03\x08\x0A\x1C\x14\x1F\x19\x0F" + 0x19B92750).s, SAKURA_CALLBACK_AT_RENDERING_MENU);
	DefineLuaGlobal(L, /*SAKURA_WINDOW_RENDER*/XorStr<0x68, 21, 0x0EB9D1A6>("\x3B\x28\x21\x3E\x3E\x2C\x31\x38\x39\x3F\x36\x3C\x23\x2A\x24\x32\x36\x3D\x3F\x29" + 0x0EB9D1A6).s, SAKURA_CALLBACK_AT_RENDERING_WINDOW);
	DefineLuaGlobal(L, /*SAKURA_BACKGROUND_RENDER*/XorStr<0xCF, 25, 0x4CCB2153>("\x9C\x91\x9A\x87\x81\x95\x8A\x94\x96\x9B\x92\x9D\x89\x93\x88\x90\x9B\xBF\xB3\xA7\xAD\xA0\xA0\xB4" + 0x4CCB2153).s, SAKURA_CALLBACK_AT_RENDERING_BACKGROUND);
	DefineLuaGlobal(L, /*SAKURA_CLIENT_MOVE*/XorStr<0xF8, 19, 0xCF863DCD>("\xAB\xB8\xB1\xAE\xAE\xBC\xA1\xBC\x4C\x48\x47\x4D\x50\x5A\x4B\x48\x5E\x4C" + 0xCF863DCD).s, SAKURA_CALLBACK_AT_CLIENT_MOVE);
	DefineLuaGlobal(L, /*SAKURA_CLIENT_BIND*/XorStr<0x46, 19, 0x0CF6079D>("\x15\x06\x03\x1C\x18\x0A\x13\x0E\x02\x06\x15\x1F\x06\x0C\x16\x1C\x18\x13" + 0x0CF6079D).s, SAKURA_CALLBACK_AT_CLIENT_BIND);
	DefineLuaGlobal(L, /*SAKURA_DEATH_MESSAGE*/XorStr<0x44, 21, 0x69D5DBB0>("\x17\x04\x0D\x12\x1A\x08\x15\x0F\x09\x0C\x1A\x07\x0F\x1C\x17\x00\x07\x14\x11\x12" + 0x69D5DBB0).s, SAKURA_CALLBACK_AT_DEATH_MESSAGE);
	DefineLuaGlobal(L, /*SAKURA_NEWROUND_MESSAGE*/XorStr<0x63, 24, 0xAD567DCF>("\x30\x25\x2E\x33\x35\x29\x36\x24\x2E\x3B\x3F\x21\x3A\x3E\x35\x2D\x3E\x31\x26\x25\x36\x3F\x3C" + 0xAD567DCF).s, SAKURA_CALLBACK_AT_RESETHUD_MESSAGE);
	DefineLuaGlobal(L, /*SAKURA_SELFDAMAGE_MESSAGE*/XorStr<0xCD, 26, 0x93562233>("\x9E\x8F\x84\x85\x83\x93\x8C\x87\x90\x9A\x91\x9C\x98\x97\x9A\x9B\x98\x81\x92\xA5\xB2\xB1\xA2\xA3\xA0" + 0x93562233).s, SAKURA_CALLBACK_AT_DAMAGE_MESSAGE);
	DefineLuaGlobal(L, /*SAKURA_ADD_ENTITY*/XorStr<0xC6, 18, 0xBA9823DE>("\x95\x86\x83\x9C\x98\x8A\x93\x8C\x8A\x8B\x8F\x94\x9C\x87\x9D\x81\x8F" + 0xBA9823DE).s, SAKURA_CALLBACK_AT_ADDENTITY);
	DefineLuaGlobal(L, /*SAKURA_DYNAMICSOUND_PLAY*/XorStr<0x65, 25, 0xCDB6662F>("\x36\x27\x2C\x3D\x3B\x2B\x34\x28\x34\x20\x2E\x3D\x38\x31\x20\x3B\x20\x38\x33\x27\x29\x36\x3A\x25" + 0xCDB6662F).s, SAKURA_CALLBACK_AT_DYNAMICSOUND);
	DefineLuaGlobal(L, /*SAKURA_SOUND_INIT*/XorStr<0x63, 18, 0x87D382D6>("\x30\x25\x2E\x33\x35\x29\x36\x39\x24\x39\x23\x2A\x30\x39\x3F\x3B\x27" + 0x87D382D6).s, SAKURA_CALLBACK_AT_INIT_BASS);
	//DefineLuaGlobal(L, "SAKURA_LOAD_CONFIG", SAKURA_CALLBACK_AT_LOAD_CONFIG);
	//DefineLuaGlobal(L, "SAKURA_SAVE_CONFIG", SAKURA_CALLBACK_AT_SAVE_CONFIG);

	DefineLuaGlobal(L, /*TEAM_TT*/XorStr<0x89, 8, 0x5A65E859>("\xDD\xCF\xCA\xC1\xD2\xDA\xDB" + 0x5A65E859).s, TEAM_TT);
	DefineLuaGlobal(L, /*TEAM_CT*/XorStr<0x29, 8, 0xACA054E2>("\x7D\x6F\x6A\x61\x72\x6D\x7B" + 0xACA054E2).s, TEAM_CT);
	
	DefineLuaGlobal(L, /*ENTITY_TYPE_NORMAL*/XorStr<0x67, 19, 0x3DB6DBE4>("\x22\x26\x3D\x23\x3F\x35\x32\x3A\x36\x20\x34\x2D\x3D\x3B\x27\x3B\x36\x34" + 0x3DB6DBE4).s, ENTITY_TYPE_NORMAL);
	DefineLuaGlobal(L, /*ENTITY_TYPE_PLAYER*/XorStr<0x4B, 19, 0x35E35357>("\x0E\x02\x19\x07\x1B\x09\x0E\x06\x0A\x04\x10\x09\x07\x14\x18\x03\x1E\x0E" + 0x35E35357).s, ENTITY_TYPE_PLAYER);
	
	DefineLuaGlobal(L, /*FL_FLY*/XorStr<0x9A, 7, 0xA5BE41C0>("\xDC\xD7\xC3\xDB\xD2\xC6" + 0xA5BE41C0).s, FL_FLY);
	DefineLuaGlobal(L, /*FL_SWIM*/XorStr<0x3F, 8, 0x65389EB5>("\x79\x0C\x1E\x11\x14\x0D\x08" + 0x65389EB5).s, FL_SWIM);
	DefineLuaGlobal(L, /*FL_CONVEYOR*/XorStr<0xEA, 12, 0x2C514EF5>("\xAC\xA7\xB3\xAE\xA1\xA1\xA6\xB4\xAB\xBC\xA6" + 0x2C514EF5).s, FL_CONVEYOR);
	DefineLuaGlobal(L, /*FL_CLIENT*/XorStr<0x72, 10, 0xBB92D0DC>("\x34\x3F\x2B\x36\x3A\x3E\x3D\x37\x2E" + 0xBB92D0DC).s, FL_CLIENT);
	DefineLuaGlobal(L, /*FL_INWATER*/XorStr<0x49, 11, 0x3944B3CD>("\x0F\x06\x14\x05\x03\x19\x0E\x04\x14\x00" + 0x3944B3CD).s, FL_INWATER);
	DefineLuaGlobal(L, /*FL_MONSTER*/XorStr<0x56, 11, 0x13BA11EB>("\x10\x1B\x07\x14\x15\x15\x0F\x09\x1B\x0D" + 0x13BA11EB).s, FL_MONSTER);
	DefineLuaGlobal(L, /*FL_GODMODE*/XorStr<0x04, 11, 0xF0A2FA36>("\x42\x49\x59\x40\x47\x4D\x47\x44\x48\x48" + 0xF0A2FA36).s, FL_GODMODE);
	DefineLuaGlobal(L, /*FL_NOTARGET*/XorStr<0xCD, 12, 0x6896D0B1>("\x8B\x82\x90\x9E\x9E\x86\x92\x86\x92\x93\x83" + 0x6896D0B1).s, FL_NOTARGET);
	DefineLuaGlobal(L, /*FL_SKIPLOCALHOST*/XorStr<0x7D, 17, 0x6ED42F03>("\x3B\x32\x20\xD3\xCA\xCB\xD3\xC8\xCA\xC5\xC6\xC4\xC1\xC5\xD8\xD8" + 0x6ED42F03).s, FL_SKIPLOCALHOST);
	DefineLuaGlobal(L, /*FL_ONGROUND*/XorStr<0x6D, 12, 0x1530A124>("\x2B\x22\x30\x3F\x3F\x35\x21\x3B\x20\x38\x33" + 0x1530A124).s, FL_ONGROUND);
	DefineLuaGlobal(L, /*FL_PARTIALGROUND*/XorStr<0x52, 17, 0x7ACD4DA3>("\x14\x1F\x0B\x05\x17\x05\x0C\x10\x1B\x17\x1B\x0F\x11\x0A\x2E\x25" + 0x7ACD4DA3).s, FL_PARTIALGROUND);
	DefineLuaGlobal(L, /*FL_WATERJUMP*/XorStr<0xC4, 13, 0x6D99C299>("\x82\x89\x99\x90\x89\x9D\x8F\x99\x86\x98\x83\x9F" + 0x6D99C299).s, FL_WATERJUMP);
	DefineLuaGlobal(L, /*FL_FROZEN*/XorStr<0x4D, 10, 0x38D943A2>("\x0B\x02\x10\x16\x03\x1D\x09\x11\x1B" + 0x38D943A2).s, FL_FROZEN);
	DefineLuaGlobal(L, /*FL_FAKECLIENT*/XorStr<0x2A, 14, 0x83486DC3>("\x6C\x67\x73\x6B\x6F\x64\x75\x72\x7E\x7A\x71\x7B\x62" + 0x83486DC3).s, FL_FAKECLIENT);
	DefineLuaGlobal(L, /*FL_DUCKING*/XorStr<0x26, 11, 0x691A8336>("\x60\x6B\x77\x6D\x7F\x68\x67\x64\x60\x68" + 0x691A8336).s, FL_DUCKING);
	DefineLuaGlobal(L, /*FL_FLOAT*/XorStr<0x7B, 9, 0xFBDB0F29>("\x3D\x30\x22\x38\x33\xCF\xC0\xD6" + 0xFBDB0F29).s, FL_FLOAT);
	DefineLuaGlobal(L, /*FL_GRAPHED*/XorStr<0x95, 11, 0x55B79DD7>("\xD3\xDA\xC8\xDF\xCB\xDB\xCB\xD4\xD8\xDA" + 0x55B79DD7).s, FL_GRAPHED);
	DefineLuaGlobal(L, /*FL_IMMUNE_WATER*/XorStr<0x5E, 16, 0x21143A1A>("\x18\x13\x3F\x28\x2F\x2E\x31\x2B\x23\x38\x3F\x28\x3E\x2E\x3E" + 0x21143A1A).s, FL_IMMUNE_WATER);
	DefineLuaGlobal(L, /*FL_IMMUNE_SLIME*/XorStr<0x27, 16, 0xD45B5071>("\x61\x64\x76\x63\x66\x61\x78\x60\x6A\x6F\x62\x7E\x7A\x79\x70" + 0xD45B5071).s, FL_IMMUNE_SLIME);
	DefineLuaGlobal(L, /*FL_IMMUNE_LAVA*/XorStr<0x57, 15, 0xBC96E516>("\x11\x14\x06\x13\x16\x11\x08\x10\x1A\x3F\x2D\x23\x35\x25" + 0xBC96E516).s, FL_IMMUNE_LAVA);
	DefineLuaGlobal(L, /*FL_PROXY*/XorStr<0x5D, 9, 0xE7BF544C>("\x1B\x12\x00\x30\x33\x2D\x3B\x3D" + 0xE7BF544C).s, FL_PROXY);
	DefineLuaGlobal(L, /*FL_ALWAYSTHINK*/XorStr<0xEC, 15, 0x39E9B6C4>("\xAA\xA1\xB1\xAE\xBC\xA6\xB3\xAA\xA7\xA1\xBE\xBE\xB6\xB2" + 0x39E9B6C4).s, FL_ALWAYSTHINK);
	DefineLuaGlobal(L, /*FL_BASEVELOCITY*/XorStr<0xA7, 16, 0x2DFF3B70>("\xE1\xE4\xF6\xE8\xEA\xFF\xE8\xF8\xEA\xFC\xFE\xF1\xFA\xE0\xEC" + 0x2DFF3B70).s, FL_BASEVELOCITY);
	DefineLuaGlobal(L, /*FL_MONSTERCLIP*/XorStr<0x34, 15, 0x88E143C5>("\x72\x79\x69\x7A\x77\x77\x69\x6F\x79\x6F\x7D\x73\x09\x11" + 0x88E143C5).s, FL_MONSTERCLIP);
	DefineLuaGlobal(L, /*FL_ONTRAIN*/XorStr<0xF3, 11, 0x10287021>("\xB5\xB8\xAA\xB9\xB9\xAC\xAB\xBB\xB2\xB2" + 0x10287021).s, FL_ONTRAIN);
	DefineLuaGlobal(L, /*FL_WORLDBRUSH*/XorStr<0x84, 14, 0xF4DA3FB7>("\xC2\xC9\xD9\xD0\xC7\xDB\xC6\xCF\xCE\xDF\xDB\xDC\xD8" + 0xF4DA3FB7).s, FL_WORLDBRUSH);
	DefineLuaGlobal(L, /*FL_SPECTATOR*/XorStr<0xA7, 13, 0x15B4F69E>("\xE1\xE4\xF6\xF9\xFB\xE9\xEE\xFA\xEE\xE4\xFE\xE0" + 0x15B4F69E).s, FL_SPECTATOR);
	DefineLuaGlobal(L, /*FL_CUSTOMENTITY*/XorStr<0x6A, 16, 0xB0B08D08>("\x2C\x27\x33\x2E\x3B\x3C\x24\x3E\x3F\x36\x3A\x21\x3F\x23\x21" + 0xB0B08D08).s, FL_CUSTOMENTITY);
	DefineLuaGlobal(L, /*FL_KILLME*/XorStr<0x10, 10, 0x09E61163>("\x56\x5D\x4D\x58\x5D\x59\x5A\x5A\x5D" + 0x09E61163).s, FL_KILLME);
	DefineLuaGlobal(L, /*FL_DORMANT*/XorStr<0xA0, 11, 0xAE51E3DE>("\xE6\xED\xFD\xE7\xEB\xF7\xEB\xE6\xE6\xFD" + 0xAE51E3DE).s, FL_DORMANT);
	
	DefineLuaGlobal(L, /*K_TAB*/XorStr<0x99, 6, 0x50EFE8A5>("\xD2\xC5\xCF\xDD\xDF" + 0x50EFE8A5).s, K_TAB);
	DefineLuaGlobal(L, /*K_ENTER*/XorStr<0x90, 8, 0x3D347A2D>("\xDB\xCE\xD7\xDD\xC0\xD0\xC4" + 0x3D347A2D).s, K_ENTER);
	DefineLuaGlobal(L, /*K_ESCAPE*/XorStr<0x67, 9, 0xBEED19A3>("\x2C\x37\x2C\x39\x28\x2D\x3D\x2B" + 0xBEED19A3).s, K_ESCAPE);
	DefineLuaGlobal(L, /*K_SPACE*/XorStr<0x26, 8, 0x27CC69A4>("\x6D\x78\x7B\x79\x6B\x68\x69" + 0x27CC69A4).s, K_SPACE);
	DefineLuaGlobal(L, /*K_0*/XorStr<0x0C, 4, 0x284A9893>("\x47\x52\x3E" + 0x284A9893).s, K_0);
	DefineLuaGlobal(L, /*K_1*/XorStr<0x26, 4, 0x3E384E74>("\x6D\x78\x19" + 0x3E384E74).s, K_1);
	DefineLuaGlobal(L, /*K_2*/XorStr<0xA5, 4, 0x7B0DA696>("\xEE\xF9\x95" + 0x7B0DA696).s, K_2);
	DefineLuaGlobal(L, /*K_3*/XorStr<0x81, 4, 0x197C6710>("\xCA\xDD\xB0" + 0x197C6710).s, K_3);
	DefineLuaGlobal(L, /*K_4*/XorStr<0x01, 4, 0xFD6534BB>("\x4A\x5D\x37" + 0xFD6534BB).s, K_4);
	DefineLuaGlobal(L, /*K_5*/XorStr<0x48, 4, 0xD6B64BEB>("\x03\x16\x7F" + 0xD6B64BEB).s, K_5);
	DefineLuaGlobal(L, /*K_6*/XorStr<0x69, 4, 0x1BC01C64>("\x22\x35\x5D" + 0x1BC01C64).s, K_6);
	DefineLuaGlobal(L, /*K_7*/XorStr<0xF2, 4, 0x4B2431F8>("\xB9\xAC\xC3" + 0x4B2431F8).s, K_7);
	DefineLuaGlobal(L, /*K_8*/XorStr<0xC8, 4, 0x292B63AD>("\x83\x96\xF2" + 0x292B63AD).s, K_8);
	DefineLuaGlobal(L, /*K_9*/XorStr<0x30, 4, 0xEB91763F>("\x7B\x6E\x0B" + 0xEB91763F).s, K_9);
	DefineLuaGlobal(L, /*K_A*/XorStr<0x6F, 4, 0x69AFFBC2>("\x24\x2F\x30" + 0x69AFFBC2).s, K_A);
	DefineLuaGlobal(L, /*K_B*/XorStr<0x54, 4, 0xF5A85483>("\x1F\x0A\x14" + 0xF5A85483).s, K_B);
	DefineLuaGlobal(L, /*K_C*/XorStr<0x55, 4, 0xE542EF31>("\x1E\x09\x14" + 0xE542EF31).s, K_C);
	DefineLuaGlobal(L, /*K_D*/XorStr<0xB2, 4, 0xEAB6DA5D>("\xF9\xEC\xF0" + 0xEAB6DA5D).s, K_D);
	DefineLuaGlobal(L, /*K_E*/XorStr<0xC3, 4, 0x7E785372>("\x88\x9B\x80" + 0x7E785372).s, K_E);
	DefineLuaGlobal(L, /*K_F*/XorStr<0xA9, 4, 0x7367529F>("\xE2\xF5\xED" + 0x7367529F).s, K_F);
	DefineLuaGlobal(L, /*K_G*/XorStr<0x59, 4, 0x5D707B25>("\x12\x05\x1C" + 0x5D707B25).s, K_G);
	DefineLuaGlobal(L, /*K_H*/XorStr<0xFB, 4, 0x0DFBACB0>("\xB0\xA3\xB5" + 0x0DFBACB0).s, K_H);
	DefineLuaGlobal(L, /*K_I*/XorStr<0x94, 4, 0xDC5B29C8>("\xDF\xCA\xDF" + 0xDC5B29C8).s, K_I);
	DefineLuaGlobal(L, /*K_J*/XorStr<0xF3, 4, 0x3114AF4A>("\xB8\xAB\xBF" + 0x3114AF4A).s, K_J);
	DefineLuaGlobal(L, /*K_K*/XorStr<0xC2, 4, 0x69F0808C>("\x89\x9C\x8F" + 0x69F0808C).s, K_K);
	DefineLuaGlobal(L, /*K_L*/XorStr<0xE9, 4, 0x6937E72D>("\xA2\xB5\xA7" + 0x6937E72D).s, K_L);
	DefineLuaGlobal(L, /*K_M*/XorStr<0x0E, 4, 0xBD3F5CC5>("\x45\x50\x5D" + 0xBD3F5CC5).s, K_M);
	DefineLuaGlobal(L, /*K_N*/XorStr<0x91, 4, 0x38494C33>("\xDA\xCD\xDD" + 0x38494C33).s, K_N);
	DefineLuaGlobal(L, /*K_O*/XorStr<0x74, 4, 0x1225EA62>("\x3F\x2A\x39" + 0x1225EA62).s, K_O);
	DefineLuaGlobal(L, /*K_P*/XorStr<0x2E, 4, 0xDA78EBB7>("\x65\x70\x60" + 0xDA78EBB7).s, K_P);
	DefineLuaGlobal(L, /*K_Q*/XorStr<0xB7, 4, 0x03A915B8>("\xFC\xE7\xE8" + 0x03A915B8).s, K_Q);
	DefineLuaGlobal(L, /*K_R*/XorStr<0xFC, 4, 0x21EE6843>("\xB7\xA2\xAC" + 0x21EE6843).s, K_R);
	DefineLuaGlobal(L, /*K_S*/XorStr<0x4C, 4, 0x5341AD58>("\x07\x12\x1D" + 0x5341AD58).s, K_S);
	DefineLuaGlobal(L, /*K_T*/XorStr<0xA1, 4, 0x90FCC518>("\xEA\xFD\xF7" + 0x90FCC518).s, K_T);
	DefineLuaGlobal(L, /*K_U*/XorStr<0x99, 4, 0x4C2F7C35>("\xD2\xC5\xCE" + 0x4C2F7C35).s, K_U);
	DefineLuaGlobal(L, /*K_V*/XorStr<0x16, 4, 0xA7E4D916>("\x5D\x48\x4E" + 0xA7E4D916).s, K_V);
	DefineLuaGlobal(L, /*K_W*/XorStr<0xCB, 4, 0x2B3DF020>("\x80\x93\x9A" + 0x2B3DF020).s, K_W);
	DefineLuaGlobal(L, /*K_X*/XorStr<0x80, 4, 0xBDDFCF35>("\xCB\xDE\xDA" + 0xBDDFCF35).s, K_X);
	DefineLuaGlobal(L, /*K_Y*/XorStr<0x55, 4, 0x17E16673>("\x1E\x09\x0E" + 0x17E16673).s, K_Y);
	DefineLuaGlobal(L, /*K_Z*/XorStr<0x86, 4, 0xCF2F59CA>("\xCD\xD8\xD2" + 0xCF2F59CA).s, K_Z);
	DefineLuaGlobal(L, /*K_BACKSPACE*/XorStr<0x91, 12, 0xE201319F>("\xDA\xCD\xD1\xD5\xD6\xDD\xC4\xC8\xD8\xD9\xDE" + 0xE201319F).s, K_BACKSPACE);
	DefineLuaGlobal(L, /*K_UPARROW*/XorStr<0x0E, 10, 0xFB8A47D5>("\x45\x50\x45\x41\x53\x41\x46\x5A\x41" + 0xFB8A47D5).s, K_UPARROW);
	DefineLuaGlobal(L, /*K_DOWNARROW*/XorStr<0xA0, 12, 0xA807A3D4>("\xEB\xFE\xE6\xEC\xF3\xEB\xE7\xF5\xFA\xE6\xFD" + 0xA807A3D4).s, K_DOWNARROW);
	DefineLuaGlobal(L, /*K_LEFTARROW*/XorStr<0xDB, 12, 0xD5C4A7EF>("\x90\x83\x91\x9B\x99\xB4\xA0\xB0\xB1\xAB\xB2" + 0xD5C4A7EF).s, K_LEFTARROW);
	DefineLuaGlobal(L, /*K_RIGHTARROW*/XorStr<0x60, 13, 0x9F1AF8FE>("\x2B\x3E\x30\x2A\x23\x2D\x32\x26\x3A\x3B\x25\x3C" + 0x9F1AF8FE).s, K_RIGHTARROW);
	DefineLuaGlobal(L, /*K_ALT*/XorStr<0xFB, 6, 0xED437B5C>("\xB0\xA3\xBC\xB2\xAB" + 0xED437B5C).s, K_ALT);
	DefineLuaGlobal(L, /*K_CTRL*/XorStr<0x46, 7, 0x1597B484>("\x0D\x18\x0B\x1D\x18\x07" + 0x1597B484).s, K_CTRL);
	DefineLuaGlobal(L, /*K_SHIFT*/XorStr<0x95, 8, 0x99BF8B97>("\xDE\xC9\xC4\xD0\xD0\xDC\xCF" + 0x99BF8B97).s, K_SHIFT);
	DefineLuaGlobal(L, /*K_F1*/XorStr<0x1F, 5, 0x5C9E9444>("\x54\x7F\x67\x13" + 0x5C9E9444).s, K_F1);
	DefineLuaGlobal(L, /*K_F2*/XorStr<0xA5, 5, 0x8DCE8FE4>("\xEE\xF9\xE1\x9A" + 0x8DCE8FE4).s, K_F2);
	DefineLuaGlobal(L, /*K_F3*/XorStr<0x2B, 5, 0xF1BFC6FB>("\x60\x73\x6B\x1D" + 0xF1BFC6FB).s, K_F3);
	DefineLuaGlobal(L, /*K_F4*/XorStr<0x67, 5, 0x2923B943>("\x2C\x37\x2F\x5E" + 0x2923B943).s, K_F4);
	DefineLuaGlobal(L, /*K_F5*/XorStr<0x44, 5, 0xB34B5490>("\x0F\x1A\x00\x72" + 0xB34B5490).s, K_F5);
	DefineLuaGlobal(L, /*K_F6*/XorStr<0xD6, 5, 0xF3548A33>("\x9D\x88\x9E\xEF" + 0xF3548A33).s, K_F6);
	DefineLuaGlobal(L, /*K_F7*/XorStr<0xE4, 5, 0x2A74AE62>("\xAF\xBA\xA0\xD0" + 0x2A74AE62).s, K_F7);
	DefineLuaGlobal(L, /*K_F8*/XorStr<0xA4, 5, 0x100A7623>("\xEF\xFA\xE0\x9F" + 0x100A7623).s, K_F8);
	DefineLuaGlobal(L, /*K_F9*/XorStr<0x2F, 5, 0x912596E9>("\x64\x6F\x77\x0B" + 0x912596E9).s, K_F9);
	DefineLuaGlobal(L, /*K_F10*/XorStr<0x88, 6, 0xE1FE6963>("\xC3\xD6\xCC\xBA\xBC" + 0xE1FE6963).s, K_F10);
	DefineLuaGlobal(L, /*K_F11*/XorStr<0xF2, 6, 0xE477ACD2>("\xB9\xAC\xB2\xC4\xC7" + 0xE477ACD2).s, K_F11);
	DefineLuaGlobal(L, /*K_F12*/XorStr<0x39, 6, 0x919B7B94>("\x72\x65\x7D\x0D\x0F" + 0x919B7B94).s, K_F12);
	DefineLuaGlobal(L, /*K_INS*/XorStr<0x4E, 6, 0x10244010>("\x05\x10\x19\x1F\x01" + 0x10244010).s, K_INS);
	DefineLuaGlobal(L, /*K_DEL*/XorStr<0x06, 6, 0x3C86AE77>("\x4D\x58\x4C\x4C\x46" + 0x3C86AE77).s, K_DEL);
	DefineLuaGlobal(L, /*K_PGDN*/XorStr<0xA6, 7, 0x35A59507>("\xED\xF8\xF8\xEE\xEE\xE5" + 0x35A59507).s, K_PGDN);
	DefineLuaGlobal(L, /*K_PGUP*/XorStr<0x2B, 7, 0x01F586C0>("\x60\x73\x7D\x69\x7A\x60" + 0x01F586C0).s, K_PGUP);
	DefineLuaGlobal(L, /*K_HOME*/XorStr<0x05, 7, 0x2CBCDCE1>("\x4E\x59\x4F\x47\x44\x4F" + 0x2CBCDCE1).s, K_HOME);
	DefineLuaGlobal(L, /*K_END*/XorStr<0x02, 6, 0x62C24766>("\x49\x5C\x41\x4B\x42" + 0x62C24766).s, K_END);
	DefineLuaGlobal(L, /*K_KP_HOME*/XorStr<0x4B, 10, 0xA8FF94FD>("\x00\x13\x06\x1E\x10\x18\x1E\x1F\x16" + 0xA8FF94FD).s, K_KP_HOME);
	DefineLuaGlobal(L, /*K_KP_UPARROW*/XorStr<0xEA, 13, 0xDCA3DBD0>("\xA1\xB4\xA7\xBD\xB1\xBA\xA0\xB0\xA0\xA1\xBB\xA2" + 0xDCA3DBD0).s, K_KP_UPARROW);
	DefineLuaGlobal(L, /*K_KP_PGUP*/XorStr<0xE5, 10, 0xE6AB6B00>("\xAE\xB9\xAC\xB8\xB6\xBA\xAC\xB9\xBD" + 0xE6AB6B00).s, K_KP_PGUP);
	DefineLuaGlobal(L, /*K_KP_LEFTARROW*/XorStr<0x22, 15, 0x8BA3CCDF>("\x69\x7C\x6F\x75\x79\x6B\x6D\x6F\x7E\x6A\x7E\x7F\x61\x78" + 0x8BA3CCDF).s, K_KP_LEFTARROW);
	DefineLuaGlobal(L, /*K_KP_5*/XorStr<0x6F, 7, 0x4842D035>("\x24\x2F\x3A\x22\x2C\x41" + 0x4842D035).s, K_KP_5);
	DefineLuaGlobal(L, /*K_KP_RIGHTARROW*/XorStr<0xEA, 16, 0x09F2A879>("\xA1\xB4\xA7\xBD\xB1\xBD\xB9\xB6\xBA\xA7\xB5\xA7\xA4\xB8\xAF" + 0x09F2A879).s, K_KP_RIGHTARROW);
	DefineLuaGlobal(L, /*K_KP_END*/XorStr<0x87, 9, 0xE5B74A9C>("\xCC\xD7\xC2\xDA\xD4\xC9\xC3\xCA" + 0xE5B74A9C).s, K_KP_END);
	DefineLuaGlobal(L, /*K_KP_DOWNARROW*/XorStr<0x91, 15, 0xCABB96E4>("\xDA\xCD\xD8\xC4\xCA\xD2\xD8\xCF\xD7\xDB\xC9\xCE\xD2\xC9" + 0xCABB96E4).s, K_KP_DOWNARROW);
	DefineLuaGlobal(L, /*K_KP_PGDN*/XorStr<0x05, 10, 0x46B05317>("\x4E\x59\x4C\x58\x56\x5A\x4C\x48\x43" + 0x46B05317).s, K_KP_PGDN);
	DefineLuaGlobal(L, /*K_KP_ENTER*/XorStr<0xF5, 11, 0x49B668A7>("\xBE\xA9\xBC\xA8\xA6\xBF\xB5\xA8\xB8\xAC" + 0x49B668A7).s, K_KP_ENTER);
	DefineLuaGlobal(L, /*K_KP_INS*/XorStr<0x96, 9, 0xFEB6E870>("\xDD\xC8\xD3\xC9\xC5\xD2\xD2\xCE" + 0xFEB6E870).s, K_KP_INS);
	DefineLuaGlobal(L, /*K_KP_DEL*/XorStr<0x5F, 9, 0x2FE8D7FA>("\x14\x3F\x2A\x32\x3C\x20\x20\x2A" + 0x2FE8D7FA).s, K_KP_DEL);
	DefineLuaGlobal(L, /*K_KP_SLASH*/XorStr<0xF1, 11, 0x0EB6366F>("\xBA\xAD\xB8\xA4\xAA\xA5\xBB\xB9\xAA\xB2" + 0x0EB6366F).s, K_KP_SLASH);
	DefineLuaGlobal(L, /*K_KP_MINUS*/XorStr<0x91, 11, 0xC1B5DAD3>("\xDA\xCD\xD8\xC4\xCA\xDB\xDE\xD6\xCC\xC9" + 0xC1B5DAD3).s, K_KP_MINUS);
	DefineLuaGlobal(L, /*K_KP_PLUS*/XorStr<0xAB, 10, 0x905B9DB9>("\xE0\xF3\xE6\xFE\xF0\xE0\xFD\xE7\xE0" + 0x905B9DB9).s, K_KP_PLUS);
	DefineLuaGlobal(L, /*K_CAPSLOCK*/XorStr<0x6B, 11, 0x8684EFCB>("\x20\x33\x2E\x2F\x3F\x23\x3D\x3D\x30\x3F" + 0x8684EFCB).s, K_CAPSLOCK);
	DefineLuaGlobal(L, /*K_MWHEELDOWN*/XorStr<0xCE, 13, 0xF95AA13C>("\x85\x90\x9D\x86\x9A\x96\x91\x99\x92\x98\x8F\x97" + 0xF95AA13C).s, K_MWHEELDOWN);
	DefineLuaGlobal(L, /*K_MWHEELUP*/XorStr<0x3E, 11, 0xF698FA4E>("\x75\x60\x0D\x16\x0A\x06\x01\x09\x13\x17" + 0xF698FA4E).s, K_MWHEELUP);
	DefineLuaGlobal(L, /*K_MOUSE1*/XorStr<0xD6, 9, 0xF05DCFFF>("\x9D\x88\x95\x96\x8F\x88\x99\xEC" + 0xF05DCFFF).s, K_MOUSE1);
	DefineLuaGlobal(L, /*K_MOUSE2*/XorStr<0xB9, 9, 0xE57CD1F1>("\xF2\xE5\xF6\xF3\xE8\xED\xFA\xF2" + 0xE57CD1F1).s, K_MOUSE2);
	DefineLuaGlobal(L, /*K_MOUSE3*/XorStr<0x7D, 9, 0xB0DC29C2>("\x36\x21\x32\xCF\xD4\xD1\xC6\xB7" + 0xB0DC29C2).s, K_MOUSE3);
	DefineLuaGlobal(L, /*K_MOUSE4*/XorStr<0x2F, 9, 0x7764C741>("\x64\x6F\x7C\x7D\x66\x67\x70\x02" + 0x7764C741).s, K_MOUSE4);
	DefineLuaGlobal(L, /*K_MOUSE5*/XorStr<0x6A, 9, 0x8F00B815>("\x21\x34\x21\x22\x3B\x3C\x35\x44" + 0x8F00B815).s, K_MOUSE5);
	DefineLuaGlobal(L, /*K_PAUSE*/XorStr<0x98, 8, 0x7FB84C9D>("\xD3\xC6\xCA\xDA\xC9\xCE\xDB" + 0x7FB84C9D).s, K_PAUSE);
	
	DefineLuaGlobal(L, /*IN_ATTACK*/XorStr<0x25, 10, 0xFA58A27D>("\x6C\x68\x78\x69\x7D\x7E\x6A\x6F\x66" + 0xFA58A27D).s, IN_ATTACK);
	DefineLuaGlobal(L, /*IN_JUMP*/XorStr<0x75, 8, 0xBB88C465>("\x3C\x38\x28\x32\x2C\x37\x2B" + 0xBB88C465).s, IN_JUMP);
	DefineLuaGlobal(L, /*IN_DUCK*/XorStr<0x18, 8, 0x5D80C326>("\x51\x57\x45\x5F\x49\x5E\x55" + 0x5D80C326).s, IN_DUCK);
	DefineLuaGlobal(L, /*IN_FORWARD*/XorStr<0x90, 11, 0xB997D822>("\xD9\xDF\xCD\xD5\xDB\xC7\xC1\xD6\xCA\xDD" + 0xB997D822).s, IN_FORWARD);
	DefineLuaGlobal(L, /*IN_BACK*/XorStr<0xD6, 8, 0xE6D321B9>("\x9F\x99\x87\x9B\x9B\x98\x97" + 0xE6D321B9).s, IN_BACK);
	DefineLuaGlobal(L, /*IN_USE*/XorStr<0x52, 7, 0x67B31D5D>("\x1B\x1D\x0B\x00\x05\x12" + 0x67B31D5D).s, IN_USE);
	DefineLuaGlobal(L, /*IN_CANCEL*/XorStr<0x34, 10, 0x542DBE28>("\x7D\x7B\x69\x74\x79\x77\x79\x7E\x70" + 0x542DBE28).s, IN_CANCEL);
	DefineLuaGlobal(L, /*IN_LEFT*/XorStr<0x44, 8, 0x567A751D>("\x0D\x0B\x19\x0B\x0D\x0F\x1E" + 0x567A751D).s, IN_LEFT);
	DefineLuaGlobal(L, /*IN_RIGHT*/XorStr<0xF6, 9, 0x68E62550>("\xBF\xB9\xA7\xAB\xB3\xBC\xB4\xA9" + 0x68E62550).s, IN_RIGHT);
	DefineLuaGlobal(L, /*IN_MOVELEFT*/XorStr<0x86, 12, 0xF4A51F9F>("\xCF\xC9\xD7\xC4\xC5\xDD\xC9\xC1\xCB\xC9\xC4" + 0xF4A51F9F).s, IN_MOVELEFT);
	DefineLuaGlobal(L, /*IN_MOVERIGHT*/XorStr<0x43, 13, 0xB05819C0>("\x0A\x0A\x1A\x0B\x08\x1E\x0C\x18\x02\x0B\x05\x1A" + 0xB05819C0).s, IN_MOVERIGHT);
	DefineLuaGlobal(L, /*IN_ATTACK2*/XorStr<0x81, 11, 0x47BFAF8C>("\xC8\xCC\xDC\xC5\xD1\xD2\xC6\xCB\xC2\xB8" + 0x47BFAF8C).s, IN_ATTACK2);
	DefineLuaGlobal(L, /*IN_RUN*/XorStr<0xF2, 7, 0x79A52BC2>("\xBB\xBD\xAB\xA7\xA3\xB9" + 0x79A52BC2).s, IN_RUN);
	DefineLuaGlobal(L, /*IN_RELOAD*/XorStr<0x10, 10, 0xA4D0324F>("\x59\x5F\x4D\x41\x51\x59\x59\x56\x5C" + 0xA4D0324F).s, IN_RELOAD);
	DefineLuaGlobal(L, /*IN_ALT1*/XorStr<0xEF, 8, 0x728C7DBD>("\xA6\xBE\xAE\xB3\xBF\xA0\xC4" + 0x728C7DBD).s, IN_ALT1);
	DefineLuaGlobal(L, /*IN_SCORE*/XorStr<0x1E, 9, 0xA6816068>("\x57\x51\x7F\x72\x61\x6C\x76\x60" + 0xA6816068).s, IN_SCORE);
	
	DefineLuaGlobal(L, /*WEAPON_NONE*/XorStr<0xA6, 12, 0xBAA1A6EC>("\xF1\xE2\xE9\xF9\xE5\xE5\xF3\xE3\xE1\xE1\xF5" + 0xBAA1A6EC).s, WEAPON_NONE);
	DefineLuaGlobal(L, /*WEAPON_P228*/XorStr<0x44, 12, 0x43CB6DF2>("\x13\x00\x07\x17\x07\x07\x15\x1B\x7E\x7F\x76" + 0x43CB6DF2).s, WEAPON_P228);
	DefineLuaGlobal(L, /*WEAPON_GLOCK*/XorStr<0xFE, 13, 0x6765D1CA>("\xA9\xBA\x41\x51\x4D\x4D\x5B\x42\x4A\x48\x4B\x42" + 0x6765D1CA).s, WEAPON_GLOCK);
	DefineLuaGlobal(L, /*WEAPON_SCOUT*/XorStr<0xDB, 13, 0xBBBED91A>("\x8C\x99\x9C\x8E\x90\xAE\xBE\xB1\xA0\xAB\xB0\xB2" + 0xBBBED91A).s, WEAPON_SCOUT);
	DefineLuaGlobal(L, /*WEAPON_HEGRENADE*/XorStr<0xAF, 17, 0x5D764106>("\xF8\xF5\xF0\xE2\xFC\xFA\xEA\xFE\xF2\xFF\xEB\xFF\xF5\xFD\xF9\xFB" + 0x5D764106).s, WEAPON_HEGRENADE);
	DefineLuaGlobal(L, /*WEAPON_XM1014*/XorStr<0xF6, 14, 0x8EA38EF9>("\xA1\xB2\xB9\xA9\xB5\xB5\xA3\xA5\xB3\xCE\x30\x30\x36" + 0x8EA38EF9).s, WEAPON_XM1014);
	DefineLuaGlobal(L, /*WEAPON_C4*/XorStr<0x8C, 10, 0xD113E6F8>("\xDB\xC8\xCF\xDF\xDF\xDF\xCD\xD0\xA0" + 0xD113E6F8).s, WEAPON_C4);
	DefineLuaGlobal(L, /*WEAPON_MAC10*/XorStr<0x31, 13, 0x9A228DD4>("\x66\x77\x72\x64\x7A\x78\x68\x75\x78\x79\x0A\x0C" + 0x9A228DD4).s, WEAPON_MAC10);
	DefineLuaGlobal(L, /*WEAPON_AUG*/XorStr<0x9C, 11, 0x4DFB9573>("\xCB\xD8\xDF\xCF\xEF\xEF\xFD\xE2\xF1\xE2" + 0x4DFB9573).s, WEAPON_AUG);
	DefineLuaGlobal(L, /*WEAPON_SMOKEGRENADE*/XorStr<0x09, 20, 0x407CB91F>("\x5E\x4F\x4A\x5C\x42\x40\x50\x43\x5C\x5D\x58\x51\x52\x44\x52\x56\x58\x5E\x5E" + 0x407CB91F).s, WEAPON_SMOKEGRENADE);
	DefineLuaGlobal(L, /*WEAPON_ELITE*/XorStr<0xCD, 13, 0x5CF22115>("\x9A\x8B\x8E\x80\x9E\x9C\x8C\x91\x99\x9F\x83\x9D" + 0x5CF22115).s, WEAPON_ELITE);
	DefineLuaGlobal(L, /*WEAPON_FIVESEVEN*/XorStr<0xDF, 17, 0xA6626DC1>("\x88\xA5\xA0\xB2\xAC\xAA\xBA\xA0\xAE\xBE\xAC\xB9\xAE\xBA\xA8\xA0" + 0xA6626DC1).s, WEAPON_FIVESEVEN);
	DefineLuaGlobal(L, /*WEAPON_UMP45*/XorStr<0x7F, 13, 0x82196606>("\x28\xC5\xC0\xD2\xCC\xCA\xDA\xD3\xCA\xD8\xBD\xBF" + 0x82196606).s, WEAPON_UMP45);
	DefineLuaGlobal(L, /*WEAPON_SG550*/XorStr<0x7A, 13, 0xFA94737E>("\x2D\x3E\x3D\x2D\x31\x31\xDF\xD2\xC5\xB6\xB1\xB5" + 0xFA94737E).s, WEAPON_SG550);
	DefineLuaGlobal(L, /*WEAPON_GALIL*/XorStr<0xA0, 13, 0xC3E74FE7>("\xF7\xE4\xE3\xF3\xEB\xEB\xF9\xE0\xE9\xE5\xE3\xE7" + 0xC3E74FE7).s, WEAPON_GALIL);
	DefineLuaGlobal(L, /*WEAPON_FAMAS*/XorStr<0xD9, 13, 0xECFB8E35>("\x8E\x9F\x9A\x8C\x92\x90\x80\xA6\xA0\xAF\xA2\xB7" + 0xECFB8E35).s, WEAPON_FAMAS);
	DefineLuaGlobal(L, /*WEAPON_USP*/XorStr<0x28, 11, 0xD21CC4C2>("\x7F\x6C\x6B\x7B\x63\x63\x71\x7A\x63\x61" + 0xD21CC4C2).s, WEAPON_USP);
	DefineLuaGlobal(L, /*WEAPON_GLOCK18*/XorStr<0x6D, 15, 0x0A66F9A7>("\x3A\x2B\x2E\x20\x3E\x3C\x2C\x33\x39\x39\x34\x33\x48\x42" + 0x0A66F9A7).s, WEAPON_GLOCK18);
	DefineLuaGlobal(L, /*WEAPON_AWP*/XorStr<0xED, 11, 0xD5808B13>("\xBA\xAB\xAE\xA0\xBE\xBC\xAC\xB5\xA2\xA6" + 0xD5808B13).s, WEAPON_AWP);
	DefineLuaGlobal(L, /*WEAPON_MP5N*/XorStr<0xDC, 12, 0xC8994422>("\x8B\x98\x9F\x8F\xAF\xAF\xBD\xAE\xB4\xD0\xA8" + 0xC8994422).s, WEAPON_MP5N);
	DefineLuaGlobal(L, /*WEAPON_M249*/XorStr<0x68, 12, 0x3CFBB070>("\x3F\x2C\x2B\x3B\x23\x23\x31\x22\x42\x45\x4B" + 0x3CFBB070).s, WEAPON_M249);
	DefineLuaGlobal(L, /*WEAPON_M3*/XorStr<0x24, 10, 0x556DB6BF>("\x73\x60\x67\x77\x67\x67\x75\x66\x1F" + 0x556DB6BF).s, WEAPON_M3);
	DefineLuaGlobal(L, /*WEAPON_M4A1*/XorStr<0xA6, 12, 0x3731CF10>("\xF1\xE2\xE9\xF9\xE5\xE5\xF3\xE0\x9A\xEE\x81" + 0x3731CF10).s, WEAPON_M4A1);
	DefineLuaGlobal(L, /*WEAPON_TMP*/XorStr<0x01, 11, 0x6FFC741A>("\x56\x47\x42\x54\x4A\x48\x58\x5C\x44\x5A" + 0x6FFC741A).s, WEAPON_TMP);
	DefineLuaGlobal(L, /*WEAPON_G3SG1*/XorStr<0xE4, 13, 0x45C1D831>("\xB3\xA0\xA7\xB7\xA7\xA7\xB5\xAC\xDF\xBE\xA9\xDE" + 0x45C1D831).s, WEAPON_G3SG1);
	DefineLuaGlobal(L, /*WEAPON_FLASHBANG*/XorStr<0xD7, 17, 0xC6D0651D>("\x80\x9D\x98\x8A\x94\x92\x82\x98\x93\xA1\xB2\xAA\xA1\xA5\xAB\xA1" + 0xC6D0651D).s, WEAPON_FLASHBANG);
	DefineLuaGlobal(L, /*WEAPON_DEAGLE*/XorStr<0x9C, 14, 0x55194A36>("\xCB\xD8\xDF\xCF\xEF\xEF\xFD\xE7\xE1\xE4\xE1\xEB\xED" + 0x55194A36).s, WEAPON_DEAGLE);
	DefineLuaGlobal(L, /*WEAPON_SG552*/XorStr<0x0E, 13, 0x207668BE>("\x59\x4A\x51\x41\x5D\x5D\x4B\x46\x51\x22\x2D\x2B" + 0x207668BE).s, WEAPON_SG552);
	DefineLuaGlobal(L, /*WEAPON_AK47*/XorStr<0x7E, 12, 0xB04322C2>("\x29\x3A\xC1\xD1\xCD\xCD\xDB\xC4\xCD\xB3\xBF" + 0xB04322C2).s, WEAPON_AK47);
	DefineLuaGlobal(L, /*WEAPON_KNIFE*/XorStr<0xB8, 13, 0xF09F9D9A>("\xEF\xFC\xFB\xEB\xF3\xF3\xE1\xF4\x8E\x88\x84\x86" + 0xF09F9D9A).s, WEAPON_KNIFE);
	DefineLuaGlobal(L, /*WEAPON_P90*/XorStr<0x9F, 11, 0x3BDC6630>("\xC8\xE5\xE0\xF2\xEC\xEA\xFA\xF6\x9E\x98" + 0x3BDC6630).s, WEAPON_P90);
	DefineLuaGlobal(L, /*WEAPON_SHIELDGUN*/XorStr<0xEF, 17, 0x47625727>("\xB8\xB5\xB0\xA2\xBC\xBA\xAA\xA5\xBF\xB1\xBC\xB6\xBF\xBB\xA8\xB0" + 0x47625727).s, WEAPON_SHIELDGUN);

	DefineLuaGlobal(L, /*ImGuiWindowFlags_None*/XorStr<0x30, 22, 0xF087B888>("\x79\x5C\x75\x46\x5D\x62\x5F\x59\x5C\x56\x4D\x7D\x50\x5C\x59\x4C\x1F\x0F\x2D\x2D\x21" + 0xF087B888).s, ImGuiWindowFlags_None);
	DefineLuaGlobal(L, /*ImGuiWindowFlags_NoTitleBar*/XorStr<0x59, 28, 0xD11D4524>("\x10\x37\x1C\x29\x34\x09\x36\x0E\x05\x0D\x14\x22\x09\x07\x00\x1B\x36\x24\x04\x38\x04\x1A\x03\x15\x33\x13\x01" + 0xD11D4524).s, ImGuiWindowFlags_NoTitleBar);
	DefineLuaGlobal(L, /*ImGuiWindowFlags_NoResize*/XorStr<0xA4, 26, 0x32968087>("\xED\xC8\xE1\xD2\xC1\xFE\xC3\xC5\xC8\xC2\xD9\xE9\xDC\xD0\xD5\xC0\xEB\xFB\xD9\xE5\xDD\xCA\xD3\xC1\xD9" + 0x32968087).s, ImGuiWindowFlags_NoResize);
	DefineLuaGlobal(L, /*ImGuiWindowFlags_NoMove*/XorStr<0x0C, 24, 0xE675B0DC>("\x45\x60\x49\x7A\x79\x46\x7B\x7D\x70\x7A\x61\x51\x74\x78\x7D\x68\x43\x53\x71\x52\x4F\x57\x47" + 0xE675B0DC).s, ImGuiWindowFlags_NoMove);
	DefineLuaGlobal(L, /*ImGuiWindowFlags_NoScrollbar*/XorStr<0x23, 29, 0xAA5693FA>("\x6A\x49\x62\x53\x4E\x7F\x40\x44\x4F\x43\x5A\x68\x43\x51\x56\x41\x6C\x7A\x5A\x65\x54\x4A\x56\x56\x57\x5E\x5C\x4C" + 0xAA5693FA).s, ImGuiWindowFlags_NoScrollbar);
	DefineLuaGlobal(L, /*ImGuiWindowFlags_NoScrollWithMouse*/XorStr<0xD8, 35, 0x1B4D1251>("\x91\xB4\x9D\xAE\xB5\x8A\xB7\xB1\x84\x8E\x95\xA5\x88\x84\x81\x94\xB7\xA7\x85\xB8\x8F\x9F\x81\x83\x9C\xA6\x9B\x87\x9C\xB8\x99\x82\x8B\x9C" + 0x1B4D1251).s, ImGuiWindowFlags_NoScrollWithMouse);
	DefineLuaGlobal(L, /*ImGuiWindowFlags_NoCollapse*/XorStr<0xDA, 28, 0x831564A3>("\x93\xB6\x9B\xA8\xB7\x88\x89\x8F\x86\x8C\x93\xA3\x8A\x86\x8F\x9A\xB5\xA5\x83\xAE\x81\x83\x9C\x90\x82\x80\x91" + 0x831564A3).s, ImGuiWindowFlags_NoCollapse);
	DefineLuaGlobal(L, /*ImGuiWindowFlags_AlwaysAutoResize*/XorStr<0xB2, 34, 0x18117048>("\xFB\xDE\xF3\xC0\xDF\xE0\xD1\xD7\xDE\xD4\xCB\xFB\xD2\xDE\xA7\xB2\x9D\x82\xA8\xB2\xA7\xBE\xBB\x88\xBF\xBF\xA3\x9F\xAB\xBC\xB9\xAB\xB7" + 0x18117048).s, ImGuiWindowFlags_AlwaysAutoResize);
	DefineLuaGlobal(L, /*ImGuiWindowFlags_NoBackground*/XorStr<0xE0, 30, 0x563536BA>("\xA9\x8C\xA5\x96\x8D\xB2\x8F\x89\x8C\x86\x9D\xAD\x80\x8C\x89\x9C\xAF\xBF\x9D\xB1\x95\x96\x9D\x90\x8A\x96\x8F\x95\x98" + 0x563536BA).s, ImGuiWindowFlags_NoBackground);
	DefineLuaGlobal(L, /*ImGuiWindowFlags_NoSavedSettings*/XorStr<0x5E, 33, 0x79E9B0DB>("\x17\x32\x27\x14\x0B\x34\x0D\x0B\x02\x08\x1F\x2F\x06\x0A\x0B\x1E\x31\x21\x1F\x22\x13\x05\x11\x11\x25\x12\x0C\x0D\x13\x15\x1B\x0E" + 0x79E9B0DB).s, ImGuiWindowFlags_NoSavedSettings);
	DefineLuaGlobal(L, /*ImGuiWindowFlags_NoMouseInputs*/XorStr<0x01, 31, 0xF0BC749F>("\x48\x6F\x44\x71\x6C\x51\x6E\x66\x6D\x65\x7C\x4A\x61\x6F\x68\x63\x4E\x5C\x7C\x59\x7A\x63\x64\x7D\x50\x74\x6B\x69\x69\x6D" + 0xF0BC749F).s, ImGuiWindowFlags_NoMouseInputs);
	DefineLuaGlobal(L, /*ImGuiWindowFlags_MenuBar*/XorStr<0x94, 25, 0xEF18D739>("\xDD\xF8\xD1\xE2\xF1\xCE\xF3\xF5\xF8\xF2\xE9\xD9\xCC\xC0\xC5\xD0\xFB\xE8\xC3\xC9\xDD\xEB\xCB\xD9" + 0xEF18D739).s, ImGuiWindowFlags_MenuBar);
	DefineLuaGlobal(L, /*ImGuiWindowFlags_HorizontalScrollbar*/XorStr<0xA1, 37, 0x8148588C>("\xE8\xCF\xE4\xD1\xCC\xF1\xCE\xC6\xCD\xC5\xDC\xEA\xC1\xCF\xC8\xC3\xEE\xFA\xDC\xC6\xDC\xCC\xD8\xD6\xCD\xDB\xD7\xEF\xDE\xCC\xD0\xAC\xAD\xA0\xA2\xB6" + 0x8148588C).s, ImGuiWindowFlags_HorizontalScrollbar);
	DefineLuaGlobal(L, /*ImGuiWindowFlags_NoFocusOnAppearing*/XorStr<0x5D, 36, 0x21BD6091>("\x14\x33\x18\x15\x08\x35\x0A\x0A\x01\x09\x10\x2E\x05\x0B\x0C\x1F\x32\x20\x00\x36\x1E\x11\x06\x07\x3A\x18\x36\x08\x09\x1F\x1A\x0E\x14\x10\x18" + 0x21BD6091).s, ImGuiWindowFlags_NoFocusOnAppearing);
	DefineLuaGlobal(L, /*ImGuiWindowFlags_NoBringToFrontOnFocus*/XorStr<0x68, 39, 0x10F4DB5E>("\x21\x04\x2D\x1E\x05\x3A\x07\x01\x14\x1E\x05\x35\x18\x14\x11\x04\x27\x37\x15\x39\x0E\x14\x10\x18\xD4\xEE\xC4\xF1\xEB\xEB\xF2\xC8\xE6\xCF\xE5\xE8\xF9\xFE" + 0x10F4DB5E).s, ImGuiWindowFlags_NoBringToFrontOnFocus);
	DefineLuaGlobal(L, /*ImGuiWindowFlags_AlwaysVerticalScrollbar*/XorStr<0xA8, 41, 0x503CCFFE>("\xE1\xC4\xED\xDE\xC5\xFA\xC7\xC1\xD4\xDE\xC5\xF5\xD8\xD4\xD1\xC4\xE7\xF8\xD6\xCC\xDD\xC4\xCD\xE9\xA5\xB3\xB6\xAA\xA7\xA4\xAA\x94\xAB\xBB\xA5\xA7\xA0\xAF\xAF\xBD" + 0x503CCFFE).s, ImGuiWindowFlags_AlwaysVerticalScrollbar);
	DefineLuaGlobal(L, /*ImGuiWindowFlags_AlwaysHorizontalScrollbar*/XorStr<0xB3, 43, 0xEAD2FE23>("\xFA\xD9\xF2\xC3\xDE\xEF\xD0\xD4\xDF\xD3\xCA\xF8\xD3\xA1\xA6\xB1\x9C\x85\xA9\xB1\xA6\xB1\xBA\x82\xA4\xBE\xA4\xB4\xA0\xBE\xA5\xB3\xBF\x87\xB6\xA4\xB8\xB4\xB5\xB8\xBA\xAE" + 0xEAD2FE23).s, ImGuiWindowFlags_AlwaysHorizontalScrollbar);
	DefineLuaGlobal(L, /*ImGuiWindowFlags_AlwaysUseWindowPadding*/XorStr<0x73, 40, 0x287E665A>("\x3A\x19\x32\x03\x1E\x2F\x10\x14\x1F\x13\x0A\x38\x13\xE1\xE6\xF1\xDC\xC5\xE9\xF1\xE6\xF1\xFA\xDF\xF8\xE9\xDA\xE7\xE1\xF4\xFE\xE5\xC3\xF5\xF1\xF2\xFE\xF6\xFE" + 0x287E665A).s, ImGuiWindowFlags_AlwaysUseWindowPadding);
	DefineLuaGlobal(L, /*ImGuiWindowFlags_NoNavInputs*/XorStr<0xBA, 29, 0x819EB6DE>("\xF3\xD6\xFB\xC8\xD7\xE8\xA9\xAF\xA6\xAC\xB3\x83\xAA\xA6\xAF\xBA\x95\x85\xA3\x83\xAF\xB9\x99\xBF\xA2\xA6\xA0\xA6" + 0x819EB6DE).s, ImGuiWindowFlags_NoNavInputs);
	DefineLuaGlobal(L, /*ImGuiWindowFlags_NoNavFocus*/XorStr<0xEE, 28, 0x2D4B374D>("\xA7\x82\xB7\x84\x9B\xA4\x9D\x9B\x92\x98\x8F\xBF\x96\x9A\x9B\x8E\xA1\xB1\x6F\x4F\x63\x75\x42\x6A\x65\x72\x7B" + 0x2D4B374D).s, ImGuiWindowFlags_NoNavFocus);
	DefineLuaGlobal(L, /*ImGuiWindowFlags_UnsavedDocument*/XorStr<0x57, 33, 0x79B63D67>("\x1E\x35\x1E\x2F\x32\x0B\x34\x30\x3B\x0F\x16\x24\x0F\x05\x02\x15\x38\x3D\x07\x19\x0A\x1A\x08\x0A\x2B\x1F\x12\x07\x1E\x11\x1B\x02" + 0x79B63D67).s, ImGuiWindowFlags_UnsavedDocument);
	DefineLuaGlobal(L, /*ImGuiWindowFlags_NoNav*/XorStr<0x87, 23, 0xB50240FC>("\xCE\xE5\xCE\xFF\xE2\xDB\xE4\xE0\xEB\xFF\xE6\xD4\xFF\xF5\xF2\xE5\xC8\xD6\xF6\xD4\xFA\xEA" + 0xB50240FC).s, ImGuiWindowFlags_NoNav);
	DefineLuaGlobal(L, /*ImGuiWindowFlags_NoDecoration*/XorStr<0x12, 30, 0x3BBBCFDC>("\x5B\x7E\x53\x60\x7F\x40\x71\x77\x7E\x74\x6B\x5B\x72\x7E\x47\x52\x7D\x6D\x4B\x61\x43\x44\x47\x5B\x4B\x5F\x45\x42\x40" + 0x3BBBCFDC).s, ImGuiWindowFlags_NoDecoration);
	DefineLuaGlobal(L, /*ImGuiWindowFlags_NoInputs*/XorStr<0xF6, 26, 0x9989472D>("\xBF\x9A\xBF\x8C\x93\xAC\x95\x93\x9A\x90\x77\x47\x6E\x62\x63\x76\x59\x49\x67\x40\x64\x7B\x79\x79\x7D" + 0x9989472D).s, ImGuiWindowFlags_NoInputs);

	return true;
}

void Sakura::Lua::Close()
{
	if (scripts.size() > 0)
	{
		currentScriptIndex = 0;
		ScriptsCount = 0;

		for (auto& script : scripts)
		{
			script.RemoveAllCallbacks();
			lua_close(script.GetState());
		}

		scripts.clear();
	}
}

void Sakura::Lua::Reload()
{
	Close();

	const std::string cd = Sakura::CheatDir;
	const std::string scriptExtension = /*.lua*/XorStr<0x27, 5, 0x52E70E20>("\x09\x44\x5C\x4B" + 0x52E70E20).s;
	std::string scriptsLoaded;

	for (const auto& p : std::filesystem::recursive_directory_iterator(cd + /*\\scripts\\*/XorStr<0xA3, 10, 0x25B9F64A>("\xFF\xD7\xC6\xD4\xCE\xD8\xDD\xD9\xF7" + 0x25B9F64A).s))
	{
		if (p.path().extension() != scriptExtension)
			continue;

		lua_State* L = luaL_newstate();

		if (!L)
		{
			Sakura::Lua::Error(/*Error creating Lua state for script: %s*/XorStr<0x99, 40, 0x12146F81>("\xDC\xE8\xE9\xF3\xEF\xBE\xFC\xD2\xC4\xC3\xD7\xCD\xCB\xC1\x87\xE4\xDC\xCB\x8B\xDF\xD9\xCF\xDB\xD5\x91\xD4\xDC\xC6\x95\xC5\xD4\xCA\xD0\xCA\xCF\x86\x9D\x9B\xCC" + 0x12146F81).s, p.path().filename().string().c_str());
			continue;
		}

		luaL_openlibs(L);

		Init(L);

		if (luaL_loadfile(L, p.path().string().c_str()) != LUA_OK)
		{
			const char* error_msg = lua_tostring(L, -1);
			Sakura::Lua::Error(/*Error loading Lua script: %s*/XorStr<0x98, 29, 0xAA02A755>("\xDD\xEB\xE8\xF4\xEE\xBD\xF2\xF0\xC1\xC5\xCB\xCD\xC3\x85\xEA\xD2\xC9\x89\xD9\xC8\xDE\xC4\xDE\xDB\x8A\x91\x97\xC0" + 0xAA02A755).s, error_msg);
			lua_close(L);
			continue;
		}

		LuaScripts script(L, p.path().filename().string());
		scripts.push_back(script);

		if (lua_pcall(L, 0, 0, 0) != LUA_OK)
		{
			const char* error_msg = lua_tostring(L, -1);
			Sakura::Lua::Error(/*Error running Lua script: %s*/XorStr<0xE6, 29, 0x45A06148>("\xA3\x95\x9A\x86\x98\xCB\x9E\x98\x80\x81\x99\x9F\x95\xD3\xB8\x80\x97\xD7\x8B\x9A\x88\x92\x8C\x89\xC4\xDF\x25\x72" + 0x45A06148).s, error_msg);
			lua_close(L);
			continue;
		}

		currentScriptIndex++;
		ScriptsCount++;

		scriptsLoaded += /* - */XorStr<0xFA, 4, 0x8CF978D3>("\xDA\xD6\xDC" + 0x8CF978D3).s;
		scriptsLoaded += p.path().filename().string();
		scriptsLoaded += /*\n*/XorStr<0x14, 2, 0x6E034713>("\x1E" + 0x6E034713).s;
	}

	Sakura::Log::File(/*%s (%d): \n%s*/XorStr<0x74, 13, 0xF313DFA4>("\x51\x06\x56\x5F\x5D\x1D\x53\x41\x5C\x77\x5B\x0C" + 0xF313DFA4).s, ScriptsCount > 1 ? /*Loaded scripts*/XorStr<0x4D, 15, 0x7D9CE133>("\x01\x21\x2E\x34\x34\x36\x73\x27\x36\x24\x3E\x28\x2D\x29" + 0x7D9CE133).s : /*Loaded script*/XorStr<0x27, 14, 0x7EC8B322>("\x6B\x47\x48\x4E\x4E\x48\x0D\x5D\x4C\x42\x58\x42\x47" + 0x7EC8B322).s, ScriptsCount, scriptsLoaded);
}
```

`sakura/source/features/lua/luabind.h`:

```h
#pragma once

namespace Sakura
{
	namespace Lua
	{
		enum SAKURA_CALLBACK_TYPE
		{
			SAKURA_CALLBACK_AT_RENDERING_MENU,        // Callback function triggered during rendering of a menu
			SAKURA_CALLBACK_AT_RENDERING_WINDOW,      // Callback function triggered during rendering of a window
			SAKURA_CALLBACK_AT_RENDERING_BACKGROUND,  // Callback function triggered during rendering of a background interface
			SAKURA_CALLBACK_AT_CLIENT_MOVE,           // Callback function triggered when the client is moved
			SAKURA_CALLBACK_AT_CLIENT_BIND,           // Callback function triggered when the client is using a custom bind
			SAKURA_CALLBACK_AT_DEATH_MESSAGE,         // Callback function triggered when a death message is received
			SAKURA_CALLBACK_AT_RESETHUD_MESSAGE,      // Callback function triggered when a reset HUD message is received
			SAKURA_CALLBACK_AT_DAMAGE_MESSAGE,        // Callback function triggered when a damage message is received
			SAKURA_CALLBACK_AT_ADDENTITY,		      // Callback function triggered when an entity message is received
			SAKURA_CALLBACK_AT_INIT_BASS,             // Callback function triggered during initialization of the BASS library
			SAKURA_CALLBACK_AT_DYNAMICSOUND,          // Callback function triggered during playback of a dynamic sound
			//SAKURA_CALLBACK_AT_SAVE_CONFIG,			  // Callback function triggered when a config is saved
			//SAKURA_CALLBACK_AT_LOAD_CONFIG,			  // Callback function triggered when a config is loaded

			SAKURA_CALLBACK_ALL_CALLBACKS
		};

		class LuaScripts
		{
		public:
			LuaScripts(lua_State* state, std::string name) : state_(state), name_(name) {}

			void RegisterCallback(UINT id, const luabridge::LuaRef& callback) {
				callbacks_[id].push_back(callback);
			}

			void RemoveCallback(UINT id) {
				callbacks_.erase(id);
			}

			void RemoveAllCallbacks() {
				callbacks_.clear();
			}

			bool HasCallback(Sakura::Lua::SAKURA_CALLBACK_TYPE type) {
				return callbacks_.find(type) != callbacks_.end();
			}

			std::vector<luabridge::LuaRef>& GetCallbacks(UINT id) {
				return callbacks_[id];
			}

			lua_State* GetState() const {
				return state_;
			}

			std::string GetName() {
				return name_;
			}
		private:
			lua_State* state_;
			std::string name_;
			std::unordered_map<UINT, std::vector<luabridge::LuaRef>> callbacks_;
		};

		extern int ScriptsCount;
		extern std::vector<Sakura::Lua::LuaScripts> scripts;
		extern std::vector<HSAMPLE> Sounds;
		extern int currentScriptIndex;

		bool Init(lua_State* L);
		void Close();
		void Reload();

		namespace Hooks
		{
			void RegisterCallBack(UINT type, luabridge::LuaRef f);
		};

		namespace Game
		{
			extern Vector vLastConvertedVector;
			bool WorldToScreen(Vector& in);
			Vector GetLastConvertedToScreenVector();

			void SendPacket(bool status);
			DWORD InitSound(const char* filename);
			void SoundPlay(const DWORD sound, const float volume);

			bool CreateVisibleEntity(const int entityType, const int entityIndexToCopy, Vector origin, const bool checkPlayerEntity = false);
			void CreateBeamPoint(Vector start, Vector end, const ImColor color = ImColor(255, 255, 255, 255), const float life = 0.001f, const float width = 0.9f, const float amplitude = 0, const float speed = 2, const int startFrame = 0, const float framerate = 0);

			DWORD GetTime();
			float GetClientTime();

			std::string GetCommandString(const char* command);
			int GetCommandInt(const char* command);
			float GetCommandFloat(const char* command);
			void ExecuteCommand(const char* command);
		};

		namespace LocalPlayer
		{
			int GetIndex();
			int GetTeam();
			int GetFlags();
			int GetHealth();
			int GetButtons();
			int GetFlashPercentage();

			Vector GetViewAngles();
			Vector GetOrigin();
			Vector GetEyePosition();

			screenfade_t GetScreenFade();

			bool IsAlive();
			bool IsScoped();
			bool IsFlashed();
			bool CheckFlag(const int flag);
			bool CheckButton(const usercmd_s* cmd, const int button);
			bool IsCurWeaponKnife();
			bool IsCurWeaponPistol();
			bool IsCurWeaponNade();
			bool IsCurWeaponSniper();
			bool IsCurWeaponRifle();
			bool IsCurWeaponShotGun();
			bool IsCurWeaponMachineGun();
			bool IsCurWeaponSubMachineGun();

			void PressButton(usercmd_s* cmd, const int button);
			void ReleaseButton(usercmd_s* cmd, const int button);
			void SetViewAngles(const Vector angles);
			void FixMoveStart(usercmd_s* cmd);
			void FixMoveEnd(usercmd_s* cmd);
		};

		namespace Player
		{
			int GetTeam(const int index);
			int GetHealth(const int index);
			int GetDistance(const int index);
			int GetPing(const int index);
			float GetActualDistance(const int index);
			bool IsAlive(const int index);
			Vector GetOrigin(const int index);
			std::string GetName(const int index);
			std::string GetModelName(const int index);
		};

		namespace Log
		{
			void File(const char* text);
			void Console(const char* text);
		};

		namespace Notify
		{
			void Create(const char* szTitle, const int secondsDisplay);
		};

		namespace ImGui
		{
			void Window(const char* szTitle, ImGuiWindowFlags flags, luabridge::LuaRef lfFunction);
			void Text(const char* szText);
			bool Button(const char* szText);
			bool Checkbox(const char* szText, bool bCurrentValue);
			void SameLine();
			void Spacing();
			int Combo(const char* szText, int iCurrentValue, const char* szOptions);
			int SliderInt(const char* szText, int iTheValue, int iMinimium, int iMaximum);
			float KeyBind(const char* szText, int iKey);

			ImColor Color(const char* szText, ImColor& color);

			ImVec2 GetWindowSize();
			ImVec2 CalcTextSize(const char* label);

			namespace Drawings
			{
				void AddRect(ImVec2& start, ImVec2& end, ImColor& color, float rounding, int flags, float thickness);
				void AddLine(ImVec2& start, ImVec2& end, ImColor& color, float thickness);
				void AddText(ImVec2& position, ImColor& color, const char* szText);
				void AddRectFilled(ImVec2& start, ImVec2& end, ImColor& color, float rounding, int corners);
			};
		};

		namespace Settings
		{
			void SaveInt(const std::string name, int value);
			void SaveFloat(const std::string name, float value);
			void SaveBool(const std::string name, bool value);

			int LoadInt(const std::string name, const int value);
			float LoadFloat(const std::string name, const float value);
			bool LoadBool(const std::string name, const bool value);
		};

		namespace DynamicSound
		{
			void ChangeNextSoundVolume(float volume);
		};
	};
};
```

`sakura/source/features/misc/afk.cpp`:

```cpp
#include "../../client.h"

void Sakura::AntiAfk::Run(usercmd_s* cmd)
{
	int afkTimeInterval = cvar.afk_time * 1000;
	static DWORD currentTime = GetTickCount();
	static Vector prevOrigin;
	static Vector prevAngles;

	if (!cvar.afk_anti)
		return;

	if(!Sakura::Player::Local::IsAlive())
		currentTime = GetTickCount();

	if (pmove->origin != prevOrigin || cmd->viewangles != prevAngles)
		currentTime = GetTickCount();

	prevOrigin = pmove->origin;
	prevAngles = cmd->viewangles;

	if (GetTickCount() - currentTime > afkTimeInterval)
	{
		cmd->buttons |= IN_JUMP;
		cmd->viewangles[1] += static_cast<int>(cvar.afk_yaw);
		g_Engine.SetViewAngles(cmd->viewangles);
	}
}
```

`sakura/source/features/misc/afk.h`:

```h
#ifndef _AFK_
#define _AFK_

namespace Sakura
{
	namespace AntiAfk
	{
		void Run(usercmd_s* cmd);
	};
};

#endif
```

`sakura/source/features/misc/chatspammer.cpp`:

```cpp
#include "../../client.h"

void Sakura::ChatSpammer::Logic()
{
	static DWORD timer = GetTickCount();

	int chatSpammerTimeInSeconds = cvar.misc_chatspammer_time * 1000;

	if (cvar.misc_chatspammer && chatSpammerTimeInSeconds > 0)
	{
		if (GetTickCount() - timer < chatSpammerTimeInSeconds)
			return;

		char chCommand[256];
		sprintf(chCommand, /*say "%s"*/XorStr<0xC3, 9, 0x3563E87F>("\xB0\xA5\xBC\xE6\xE5\xED\xBA\xE8" + 0x3563E87F).s, chatspam);
		g_Engine.pfnClientCmd(chCommand);

		timer = GetTickCount();
	}
}
```

`sakura/source/features/misc/chatspammer.h`:

```h
#pragma once

namespace Sakura
{
	namespace ChatSpammer
	{
		void Logic();
	};
};
```

`sakura/source/features/misc/fakelatency.cpp`:

```cpp
#include "../../client.h"

CSequences g_Sequences;

SequenceList::iterator CSequences::begin()
{
	return m_sequences.begin();
}

SequenceList::iterator CSequences::end()
{
	return m_sequences.end();
}

void CSequences::Update()
{
	if (client_static->netchan.incoming_sequence > m_iLastIncomingSequence)
	{
		m_sequences.push_front(CIncomingSequence{ client_static->netchan.incoming_sequence, pmove->time });
		m_iLastIncomingSequence = client_static->netchan.incoming_sequence;
	}

	if (m_sequences.size() > 2048)
		m_sequences.pop_back();
}

void CSequences::Clear()
{
	if (!m_sequences.empty())
		m_sequences.clear();

	m_iLastIncomingSequence = 0;
}

float Sakura::Math::Clamp(float value, float minimumValue, float maximumValue)
{
    if (maximumValue < minimumValue)
        return maximumValue;
    else if (value < minimumValue)
        return minimumValue;
    else if (value > maximumValue)
        return maximumValue;
    else
        return value;
}

bool Sakura::Backtrack::FindSpanningContexts(cl_entity_t* ent, float targettime, position_history_t** newer, position_history_t** older)
{
    assert(newer);
    assert(older);

    bool extrapolate = true;

    int imod = ent->current_position;
    int against = ent->current_position;
    int i0 = (imod - 0) & HISTORY_MASK;	// curpos (lerp end)
    int i1 = (imod - 1) & HISTORY_MASK;	// oldpos (lerp start)

    for (int i = 1; i < HISTORY_MAX - 1; i++)
    {
        position_history_t c1 = ent->ph[((imod - i) + 0) & HISTORY_MASK];
        position_history_t c2 = ent->ph[((imod - i) + 1) & HISTORY_MASK];

        if (c1.animtime == 0.f)
            break;

        if (c2.animtime >= targettime && c1.animtime <= targettime)
        {
            i0 = ((against - i) + 1) & HISTORY_MASK;
            i1 = ((against - i) + 0) & HISTORY_MASK;
            extrapolate = false;
            break;
        }
    }

    if (newer) *newer = &ent->ph[i0];
    if (older) *older = &ent->ph[i1];

    return extrapolate;
}

bool Sakura::Backtrack::Player(cl_entity_s* pGameEntity, int lerp_msec, Vector& origin)
{
	static cvar_t* sv_unlag = g_Engine.pfnGetCvarPointer("sv_unlag");
	static cvar_t* cl_lw = g_Engine.pfnGetCvarPointer("cl_lw");
	static cvar_t* cl_lc = g_Engine.pfnGetCvarPointer("cl_lc");
	static cvar_t* cl_updaterate = g_Engine.pfnGetCvarPointer("cl_updaterate");
	static cvar_t* sv_maxunlag = g_Engine.pfnGetCvarPointer("sv_maxunlag");
	static cvar_t* ex_interp = g_Engine.pfnGetCvarPointer("ex_interp");
	static cvar_t* sv_unlagpush = g_Engine.pfnGetCvarPointer("sv_unlagpush");

	// Player not wanting lag compensation
	if (!sv_unlag->value || !cl_lw->value || !cl_lc->value)
		return false;

	// Get true latency
	const double fakelatency =
		cvar.misc_fakelatency ?
		cvar.misc_fakelatency_amount / 1000.0 :
		0.0;

	double latency = client_state->frames[client_state->parsecountmod].latency + fakelatency;

	if (latency > 1.5)
		latency = 1.5;

	double update_interval = 0.1;

	if (cl_updaterate->value > 10.f)
		update_interval = 1.0 / double(cl_updaterate->value);

	// Absolute bounds on lag compensation
	double correct = min(1.0f, latency);

	// See if server is applying a lower cap
	if (sv_maxunlag->value)
	{
		// Make sure it's not negative
		if (sv_maxunlag->value < 0.f)
			sv_maxunlag->value = 0.f;

		// Apply server cap
		correct = min(correct, sv_maxunlag->value);
	}

	// Get true timestamp
	const double realtime = g_Engine.GetClientTime();

	// Figure out timestamp for which we are looking for data
	double targettime = realtime - correct;

	// Remove lag based on player interpolation, as well
	double interptime = (lerp_msec == -1) ? ex_interp->value : (lerp_msec / 1000.0);

	if (interptime > 0.1)
		interptime = 0.1;

	if (update_interval > interptime)
		interptime = update_interval;

	targettime -= interptime;

	// Server can apply a fudge, probably not needed, defaults to 0.0f
	targettime += sv_unlagpush->value;

	// Cap target to present time, of course
	targettime = min(realtime, targettime);

	position_history_t* newer, * older;

	FindSpanningContexts(pGameEntity, float(targettime), &newer, &older);

	if (!newer || !older)
		return false;

	float frac = 0.f;

	if (newer->animtime != older->animtime)
	{
		frac = float(targettime - older->animtime) / (newer->animtime - older->animtime);
		frac = Sakura::Math::Clamp(frac, 0.f, 1.f);
	}

	Vector delta = newer->origin - older->origin;

	if (delta.LengthSqr() > (64.f * 64.f))
		return false;

	origin = older->origin + delta * frac;

	return true;
}

void Sakura::Fakelatency::Logic()
{
    if (!cvar.misc_fakelatency)
        return;

    for (const auto& sequence : g_Sequences)
    {
        const auto time_difference = pmove->time - sequence.time;

        if (time_difference >= cvar.misc_fakelatency_amount)
        {
            client_static->netchan.incoming_sequence = sequence.seq;
            break;
        }
    }
}

void __cdecl Netchan_TransmitBits(netchan_t* chan, int length, byte* data)
{
    if (!client_static)
        client_static = (client_static_s*)(((uint32_t)(chan)) - ((uint32_t)offsetof(client_static_s, netchan)));

    Netchan_TransmitBits_s(chan, length, data);
}
```

`sakura/source/features/misc/fakelatency.h`:

```h
#pragma once

class CIncomingSequence
{
public:
	int seq;
	double time;
};

using SequenceList = std::deque<CIncomingSequence>;

class CSequences
{
public:
	SequenceList::iterator begin();
	SequenceList::iterator end();

	void Update();
	void Clear();

private:
	int m_iLastIncomingSequence;
	SequenceList m_sequences;
};

extern CSequences g_Sequences;

namespace Sakura
{
	namespace Math
	{
		float Clamp(float value, float minimumValue, float maximumValue);
	};

	namespace Backtrack
	{
		bool FindSpanningContexts(cl_entity_t* ent, float targettime, position_history_t** newer, position_history_t** older);
		bool Player(cl_entity_s* pGameEntity, int lerp_msec, Vector& origin);
	};

	namespace Fakelatency
	{
		void Logic();
	};
};

void __cdecl Netchan_TransmitBits(netchan_t* chan, int length, byte* data);
```

`sakura/source/features/misc/idhook.cpp`:

```cpp
#include "../../client.h"

int IdHook::FirstKillPlayer[33];

void IdHook::First_Kill_Mode()
{
	switch (static_cast<int>(cvar.aim_id_mode))
	{
	case IDHOOK_ATTACK_ALL:					cvar.aim_id_mode = IDHOOK_ATTACK_ON_DONT_ATTACK_OFF; break;
	case IDHOOK_ATTACK_ON_DONT_ATTACK_OFF:  cvar.aim_id_mode = IDHOOK_PLAYER_OFF; break;
	case IDHOOK_ATTACK_ON:					cvar.aim_id_mode = IDHOOK_ATTACK_ALL; break;
	}
}

void IdHook::AddPlayer(int i)
{
	switch (FirstKillPlayer[i])
	{
	case IDHOOK_PLAYER_NONE: FirstKillPlayer[i] = IDHOOK_PLAYER_ON; break;
	case IDHOOK_PLAYER_ON:   FirstKillPlayer[i] = IDHOOK_PLAYER_OFF; break;
	case IDHOOK_PLAYER_OFF:  FirstKillPlayer[i] = IDHOOK_PLAYER_NONE; break;
	}
}

void IdHook::ClearPlayer()
{
	for (size_t i = 0; i < 33; ++i)
		FirstKillPlayer[i] = IDHOOK_PLAYER_NONE;
}
```

`sakura/source/features/misc/idhook.h`:

```h
#ifndef _IDHOOK_
#define _IDHOOK_

typedef enum
{
	IDHOOK_PLAYER_NONE,
	IDHOOK_PLAYER_ON,
	IDHOOK_PLAYER_OFF
} IDHOOK_PLAYERS;

typedef enum
{
	IDHOOK_ATTACK_ALL,
	IDHOOK_ATTACK_ON_DONT_ATTACK_OFF,
	IDHOOK_ATTACK_ON
} IDHOOK_ATTACKS;

namespace IdHook
{
	extern int FirstKillPlayer[33];
	void ClearPlayer();
	void AddPlayer(int i);
	void First_Kill_Mode();
}

#endif
```

`sakura/source/features/misc/namestealer.cpp`:

```cpp
#include "../../client.h"

void Sakura::Name::Stealer()
{
	if (!cvar.misc_namestealer)
		return;

	static const std::string english[] = { "A", "a", "E", "e", "O", "o", "X", "x", "C", "c", "B", "K", "H", "P", "p", "T", "M" };
	static const std::string russian[] = { u8"À", u8"à", u8"Å", u8"å", u8"Î", u8"î", u8"Õ", u8"õ", u8"Ñ", u8"ñ", u8"Â", u8"Ê", u8"Í", u8"Ð", u8"ð", u8"Ò", u8"Ì" };

	static DWORD timer = GetTickCount();

	int nameStealerTimeInSeconds = cvar.misc_namestealer_time * 1000;

	if (nameStealerTimeInSeconds > 0)
	{
		if (GetTickCount() - timer < nameStealerTimeInSeconds)
			return;

		std::deque<std::string> nicknames;
		hud_player_info_t pInfo;

		for (size_t i = 1; i <= g_Engine.GetMaxClients(); ++i)
		{
			if (i == pmove->player_index + 1)
				continue;

			g_Engine.pfnGetPlayerInfo(i, &pInfo);

			if (pInfo.name == NULL || pInfo.name == "")
				continue;

			if (strlen(pInfo.name) <= 1)
				continue;

			if (cvar.misc_namestealer_specs && (g_Player[i].iTeam != TEAM_TT && g_Player[i].iTeam != TEAM_CT))
				continue;

			if (IdHook::FirstKillPlayer[i] == 2 && cvar.misc_namestealer_playerlist)
				continue;

			nicknames.push_back(pInfo.name);
		}

		while (nicknames.size())
		{
			bool replaced = false;

			int random = g_Engine.pfnRandomLong(0, nicknames.size() - 1);

			assert(random >= 0 && random < nicknames.size());

			std::string nickname = nicknames[random];

			for (size_t j = 0; j < IM_ARRAYSIZE(english); j++)
			{
				auto pos = nickname.find(english[j]);

				if (pos != std::string::npos)
				{
					nickname = nickname.replace(pos, english[j].size(), russian[j]);
					replaced = true;
					break;
				}
			}

			if (!replaced)
			{
				for (size_t j = 0; j < IM_ARRAYSIZE(russian); j++)
				{
					auto pos = nickname.find(russian[j]);

					if (pos != std::string::npos)
					{
						nickname = nickname.replace(pos, russian[j].size(), english[j]);
						replaced = true;
						break;
					}
				}
			}

			if (replaced)
			{
				std::string cmd = "name \"" + nickname + "\"";
				g_Engine.pfnClientCmd(cmd.data());
				break;
			}

			nicknames.erase(nicknames.begin() + random);
		}
	}

	/*static DWORD timer = GetTickCount();

	int nameStealerTimeInSeconds = cvar.misc_namestealer_time * 1000;

	if (cvar.misc_namestealer && nameStealerTimeInSeconds > 0 && Sakura::Player::Local::IsAlive())
	{
		char chCommand[64];
		std::array<std::string, MAX_CLIENTS> cNames;
		int iCount = 0;

		hud_player_info_t pInfo;

		if (GetTickCount() - timer < nameStealerTimeInSeconds)
			return;

		for (size_t i = 1; i <= g_Engine.GetMaxClients(); ++i)
		{
			if (i == pmove->player_index + 1)
				continue;

			g_Engine.pfnGetPlayerInfo(i, &pInfo);

			if (pInfo.name == NULL || pInfo.name == "")
				continue;

			if (strlen(pInfo.name) <= 1)
				continue;

			if (cvar.misc_namestealer_specs && (g_Player[i].iTeam != TEAM_TT && g_Player[i].iTeam != TEAM_CT))
				continue;

			if (IdHook::FirstKillPlayer[i] == 2 && cvar.misc_namestealer_playerlist)
				continue;

			cNames[iCount++] = pInfo.name;
		}

		if (iCount > 0)
		{
			unsigned int n = rand() % iCount;
			sprintf(chCommand, u8"name \"%s ᲼\"", cNames[n].c_str());
			g_Engine.pfnClientCmd(chCommand);
		}

		timer = GetTickCount();
	}*/
}
```

`sakura/source/features/misc/namestealer.h`:

```h
#pragma once

namespace Sakura
{
	namespace Name
	{
		void Green();
		void Custom();
		void Invisible();
		void Stealer();
	};
};
```

`sakura/source/features/misc/skipframes.cpp`:

```cpp
#include "../../client.h"

constexpr int SKIP_FRAME = 1;

SCR_UpdateScreen_t g_pSCR_UpdateScreen;

int SCR_UpdateScreen()
{
	auto oSCR_UpdateScreen = (SCR_UpdateScreen_t)g_pSCR_UpdateScreen;

	if(!cvar.misc_skipframes)
		return oSCR_UpdateScreen();

	static int skippedFrames = 0;

	if (cvar.misc_skipframes_count <= 0)
		cvar.misc_skipframes_count = 1;

	const int framesToSkip = cvar.misc_skipframes_count;

	if (skippedFrames <= framesToSkip)
	{
		skippedFrames++;
		return 1;
	}

	if (skippedFrames > framesToSkip)
		skippedFrames = 0;

	/*if (++skippedFrames % framesToSkip != 0)
		return SKIP_FRAME;*/

	/*if (skippedFrames <= framesToSkip)
		skippedFrames++;

	if (skippedFrames > framesToSkip)
	{
		skippedFrames = 0;
		return SKIP_FRAME;
	}*/

	//skippedFrames = 0;

	return oSCR_UpdateScreen();
}
```

`sakura/source/features/misc/skipframes.h`:

```h
#pragma once

typedef int(*SCR_UpdateScreen_t)();
extern SCR_UpdateScreen_t g_pSCR_UpdateScreen;

int SCR_UpdateScreen();
```

`sakura/source/features/misc/snapshot.cpp`:

```cpp
#include "../../client.h"

int Sakura::ScreenShot::Type = -1;
int Sakura::ScreenShot::SkippedFrames = 0;
bool Sakura::ScreenShot::DrawVisuals = true;
bool Sakura::ScreenShot::CanMakeScreen = true;

bool Sakura::ScreenShot::IsDrawing()
{
	return (DrawVisuals && GetTickCount() - HudRedraw <= 100);
}

bool Sakura::ScreenShot::IsVisuals()
{
	return (DrawVisuals && (!cvar.route_auto || cvar.route_draw_visual) && GetTickCount() - HudRedraw <= 100);
}

void Sakura::ScreenShot::Run()
{
	if (!bInitializeImGui)
	{
		DrawVisuals = true;
		CanMakeScreen = true;
		SkippedFrames = 0;
		return;
	}

	if (!cvar.antiss_active)
		return;

	if (DrawVisuals)
		return;

	SkippedFrames++;

	if (SkippedFrames > 4)
	{
		DrawVisuals = true;
		SkippedFrames = 0;
		CanMakeScreen = true;

		if (cvar.antiss_minmodels)
			g_Engine.pfnClientCmd(/*cl_minmodels 1*/XorStr<0x7A, 15, 0x2DCA9D68>("\x19\x17\x23\x10\x17\x11\xED\xEE\xE6\xE6\xE8\xF6\xA6\xB6" + 0x2DCA9D68).s);
	}

	if (CanMakeScreen)
	{
		CanMakeScreen = false;

		if (Type) // 1 = screenshot
			Screenshot_s();
		else
			Snapshot_s();
	}
}

void Sakura::ScreenShot::Snapshot()
{
	if (!cvar.antiss_active)
	{
		Snapshot_s();
		return;
	}

	Type = MAKING_SNAPSHOT;
	DrawVisuals = false;

	if (cvar.antiss_minmodels)
		g_Engine.pfnClientCmd(/*cl_minmodels 0*/XorStr<0x08, 15, 0x91D8EC5B>("\x6B\x65\x55\x66\x65\x63\x63\x60\x74\x74\x7E\x60\x34\x25" + 0x91D8EC5B).s);
}

void Sakura::ScreenShot::Screenshot()
{
	if (!cvar.antiss_active)
	{
		Screenshot_s();
		return;
	}

	Type = MAKING_SCREENSHOT;
	DrawVisuals = false;

	if (cvar.antiss_minmodels)
		g_Engine.pfnClientCmd(/*cl_minmodels 0*/XorStr<0x23, 15, 0xCC4C351C>("\x40\x48\x7A\x4B\x4E\x46\x44\x45\x4F\x49\x41\x5D\x0F\x00" + 0xCC4C351C).s);
}
```

`sakura/source/features/misc/snapshot.h`:

```h
#ifndef _SNAP_
#define _SNAP_

namespace Sakura
{
	namespace ScreenShot
	{
		enum {
			MAKING_SNAPSHOT,
			MAKING_SCREENSHOT,
			MAKING_MAX_COUNT
		};

		extern int SkippedFrames;
		extern int Type;
		extern bool DrawVisuals;
		extern bool CanMakeScreen;

		bool IsDrawing();
		bool IsVisuals();
		void Run();

		void Snapshot();
		void Screenshot();
	};
};

#endif
```

`sakura/source/features/misc/steamid.cpp`:

```cpp
#include "../../client.h"

char customSteamId[8];

uintptr_t GetDestination(uintptr_t callPtr) 
{ 
	return (intptr_t)(callPtr + 5) + *(intptr_t*)(callPtr + 1); 
}

void SetDestination(uintptr_t callPtr, uintptr_t destPtr)
{
	DWORD dwOldProtect;
	VirtualProtect(LPVOID(callPtr + 1), sizeof(intptr_t), PAGE_EXECUTE_READWRITE, &dwOldProtect);
	*(intptr_t*)(callPtr + 1) = destPtr - (callPtr + 5);
	VirtualProtect(LPVOID(callPtr + 1), sizeof(intptr_t), dwOldProtect, &dwOldProtect);
}

uint32_t RevHash(const char* str)
{
	uint32_t hash = 0x4E67C6A7;
	for (const char* pch = str; *pch != '\0'; pch++) {
		hash ^= (hash >> 2) + (hash << 5) + *pch;
	}
	return hash;
}

const uint8_t g_hashSymbolTable[36] =
{
	'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
	'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',
	'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T',
	'U', 'V', 'W', 'X', 'Y', 'Z'
};

struct RevEmuTicket_s
{
	uint32_t Version;
	uint32_t HighPartAuthID;
	uint32_t Signature;
	uint32_t SecondSignature;
	uint32_t AuthID;
	uint32_t ThirdSignature;
	uint8_t  Hash[128];
} RevEmuTicket_t;

int(*g_pfnSteam_GSInitiateGameConnection)(void* pData, int iMaxBytes, uint64_t SteamID, uint32_t ServerIP, uint16_t ServerPort, bool bIsSecure);
int Steam_GSInitiateGameConnection_Hooked(void* pData, int iMaxBytes, uint64_t g_SteamID, uint32_t g_ServerIP, uint16_t g_ServerPort, bool bIsSecure)
{
	g_Sequences.Clear();

	if (cvar.steamid)
	{
		if (cvar.steamid == 1)
		{
			for (size_t i = 0; i < 7; ++i)
			{
				RevEmuTicket_t.Hash[i] = g_hashSymbolTable[rand() % 36];
			}
		}
		else if(cvar.steamid == 2)
		{
			int steamid[7] = { int(cvar.id1), int(cvar.id2), int(cvar.id3), int(cvar.id4), int(cvar.id5), int(cvar.id6), int(cvar.id7) };
			for (size_t i = 0; i < 7; ++i)
			{
				RevEmuTicket_t.Hash[i] = g_hashSymbolTable[steamid[i] + rand() % 20];
			}
		}
		else if (cvar.steamid == 3)
		{
			for (size_t i = 0; i < 7; ++i)
			{
				RevEmuTicket_t.Hash[i] = customSteamId[i];
			}
		}

		RevEmuTicket_t.Hash[7] = '\0';

		RevEmuTicket_t.Version = 'J';
		RevEmuTicket_t.HighPartAuthID = RevHash((const char*)RevEmuTicket_t.Hash) & 0x7FFFFFFF;
		RevEmuTicket_t.Signature = 'rev';
		RevEmuTicket_t.SecondSignature = 0;
		RevEmuTicket_t.AuthID = RevHash((const char*)RevEmuTicket_t.Hash) << 1;
		RevEmuTicket_t.ThirdSignature = 0x01100001;
		memcpy(pData, &RevEmuTicket_t, sizeof(RevEmuTicket_t));
		return sizeof(RevEmuTicket_t);
	}
	return (*g_pfnSteam_GSInitiateGameConnection)(pData, iMaxBytes, g_SteamID, g_ServerIP, g_ServerPort, bIsSecure);
}
```

`sakura/source/features/misc/steamid.h`:

```h
#ifndef _STEAMID_
#define _STEAMID_

extern char customSteamId[8];

uintptr_t GetDestination(uintptr_t callPtr);
void SetDestination(uintptr_t callPtr, uintptr_t destPtr);
int Steam_GSInitiateGameConnection_Hooked(void* pData, int iMaxBytes, uint64_t g_SteamID, uint32_t g_ServerIP, uint16_t g_ServerPort, bool bIsSecure);
extern int(*g_pfnSteam_GSInitiateGameConnection)(void* pData, int iMaxBytes, uint64_t SteamID, uint32_t ServerIP, uint16_t ServerPort, bool bIsSecure);

#endif
```

`sakura/source/features/rage/antiaim.cpp`:

```cpp
#include "../../client.h"

int yawJitterSide = 0;
float yawFinalAnglesJitter;
float yawRandomAngles;
float pitchRandomAngles;
bool yawSideway = false;
bool yaw180Jitter = false;
bool pitchJitter = false;
bool jitterAngles = false;

bool FakeEdge(float& angle)
{
	float edge_dist = 128;
	float closest_distance = 100.0f;
	float radius = edge_dist + 0.1f;
	float step = M_PI * 2.0 / 8;

	for (float a = 0; a < (M_PI * 2.0); a += step)
	{
		Vector vEye = pmove->origin + pmove->view_ofs;
		Vector location(radius * cos(a) + vEye.x, radius * sin(a) + vEye.y, vEye.z);

		pmtrace_t tr;

		g_Engine.pEventAPI->EV_SetTraceHull(2);
		g_Engine.pEventAPI->EV_PlayerTrace(vEye, location, PM_GLASS_IGNORE, -1, &tr);

		float distance = vEye.Distance(tr.endpos);

		if (distance < closest_distance)
		{
			closest_distance = distance;
			angle = RAD2DEG(a);
		}
	}

	return closest_distance < edge_dist;
}

void AntiAim::Local(usercmd_s* cmd)
{
	if (!cvar.rage_antiaim_active)
		return;

	int localUse = (cmd->buttons & IN_USE);
	int localIsAttacking = (cmd->buttons & IN_ATTACK);
	int localIsKnifeAttacking = (cmd->buttons & IN_ATTACK2) && IsCurWeaponKnife();

	if (localUse)
		return;

	if (IsCurWeaponNonAttack())
		return;

	if ((localIsAttacking && CanAttack()) || ((localIsKnifeAttacking && CanAttack())))
		return;

	FixMoveStart(cmd);

	int target = NULL;
	Vector origin;
	for (playeraim_t Aim : PlayerAim)
	{
		if (Aim.index != Sakura::Aimbot::Rage::iTargetRage)
			continue;

		origin = Aim.origin;
		target = Aim.index;
	}

	Vector vAngles = cmd->viewangles;
	Vector vEye = pmove->origin + pmove->view_ofs;

	if (target > 0) VectorAngles(origin - vEye, vAngles);

	// Yaw AA While running
	if (pmove->velocity.Length2D() > 0 && cvar.aa_yaw_while_running > 0)
	{
		switch (static_cast<int>(cvar.aa_yaw_while_running))
		{
		case AAYaw_180: cmd->viewangles.y = vAngles[1] + 180; break;
		case AAYaw_180Jitter:
			cmd->viewangles.y = yaw180Jitter ? vAngles[1] + 180 : vAngles[1];
			yaw180Jitter = !yaw180Jitter;
			break;
		case AAYaw_SlowSpin: cmd->viewangles.y = fmod(g_Engine.GetClientTime() * 1 * 360.f, 360.f); break;
		case AAYaw_FastSpin: cmd->viewangles.y = fmod(g_Engine.GetClientTime() * 30 * 360.f, 360.f); break;
		case AAYaw_Jitter:
			if (cvar.aa_yaw_jitter_custom)
			{
				yawFinalAnglesJitter = vAngles[1] + cvar.aa_yaw_jitter_angle;

				int checkMuch = !cvar.aa_yaw_jitter_much ? 1 : (int)cvar.aa_yaw_jitter_much;
				
				if (jitterAngles) yawFinalAnglesJitter += rand() % checkMuch;
				else yawFinalAnglesJitter -= rand() % checkMuch;

				cmd->viewangles.y = yawFinalAnglesJitter;

				jitterAngles = !jitterAngles;
			}
			else
			{
				if (yawJitterSide == 0)
					cmd->viewangles.y = vAngles[1] + 0;
				else if (yawJitterSide == 1)
					cmd->viewangles.y = vAngles[1] + 90;
				else if (yawJitterSide == 2)
					cmd->viewangles.y = vAngles[1] + 180;
				else if (yawJitterSide >= 3) {
					cmd->viewangles.y = vAngles[1] + -90;
					yawJitterSide = 0;
				}

				yawJitterSide++;
			}
			break;
		case AAYaw_Sideways:
			cmd->viewangles.y = yawSideway ? vAngles[1] + -90 : vAngles[1] + 90;
			yawSideway = !yawSideway;
			break;
		case AAYaw_Random:
			cmd->viewangles.y = rand() % 361;
			if (cmd->viewangles.y > 180)
				cmd->viewangles.y -= 360;

			yawRandomAngles = cmd->viewangles.y;
			break;
		case AAYaw_Static: cmd->viewangles.y = vAngles[1] + cvar.aa_yaw_static; break;
		}

		// Set fake edge
		float angle = cmd->viewangles.y;
		if ((cvar.aa_edge == 2 || cvar.aa_edge == 3) && FakeEdge(angle))
			cmd->viewangles.y = angle;
	}
	else if (cvar.aa_yaw > 0) // Yaw AA While standing
	{
		switch (static_cast<int>(cvar.aa_yaw))
		{
		case AAYaw_180: cmd->viewangles.y = vAngles[1] + 180; break;
		case AAYaw_180Jitter:
			cmd->viewangles.y = yaw180Jitter ? vAngles[1] + 180 : vAngles[1];
			yaw180Jitter = !yaw180Jitter;
			break;
		case AAYaw_SlowSpin: cmd->viewangles.y = fmod(g_Engine.GetClientTime() * 1 * 360.f, 360.f); break;
		case AAYaw_FastSpin: cmd->viewangles.y = fmod(g_Engine.GetClientTime() * 30 * 360.f, 360.f); break;
		case AAYaw_Jitter:
			if (cvar.aa_yaw_jitter_custom)
			{
				yawFinalAnglesJitter = vAngles[1] + cvar.aa_yaw_jitter_angle;

				int checkMuch = !cvar.aa_yaw_jitter_much ? 1 : (int)cvar.aa_yaw_jitter_much;

				if (jitterAngles) yawFinalAnglesJitter += rand() % checkMuch;
				else yawFinalAnglesJitter -= rand() % checkMuch;

				cmd->viewangles.y = yawFinalAnglesJitter;

				jitterAngles = !jitterAngles;
			}
			else
			{
				if (yawJitterSide == 0)
					cmd->viewangles.y = vAngles[1] + 0;
				else if (yawJitterSide == 1)
					cmd->viewangles.y = vAngles[1] + 90;
				else if (yawJitterSide == 2)
					cmd->viewangles.y = vAngles[1] + 180;
				else if (yawJitterSide >= 3) {
					cmd->viewangles.y = vAngles[1] + -90;
					yawJitterSide = 0;
				}

				yawJitterSide++;
			}
			break;
		case AAYaw_Sideways:
			cmd->viewangles.y = yawSideway ? vAngles[1] + -90 : vAngles[1] + 90;
			yawSideway = !yawSideway;
			break;
		case AAYaw_Random:
			cmd->viewangles.y = rand() % 361;
			if (cmd->viewangles.y > 180)
				cmd->viewangles.y -= 360;
			break;
		case AAYaw_Static: cmd->viewangles.y = vAngles[1] + cvar.aa_yaw_static; break;
		}

		// set fake edge
		float angle = cmd->viewangles.y;
		if ((cvar.aa_edge == 1 || cvar.aa_edge == 3 || cvar.aa_edge == 4) && FakeEdge(angle))
		{
			static float timer = g_Local.weapon.curtime;

			if (g_Local.weapon.curtime - timer > 3 && cvar.aa_edge == 4)
			{
				timer = g_Local.weapon.curtime;

				cmd->viewangles.y = angle + 180;
			}
			else {
				cmd->viewangles.y = angle;
			}
		}
	}

	// Roll AA
	if (cvar.aa_roll_active)
	{
		// Roll AA While Running
		if (pmove->velocity.Length2D() > 0 && cvar.aa_roll_while_running > 0)
		{
			switch (static_cast<int>(cvar.aa_roll_while_running))
			{
			case AAYaw_180: cmd->viewangles.z = vAngles[2] + 180; break;
			case AAYaw_180Jitter:
				cmd->viewangles.z = yaw180Jitter ? vAngles[2] + 180 : vAngles[2];
				yaw180Jitter = !yaw180Jitter;
				break;
			case AAYaw_SlowSpin: cmd->viewangles.z = fmod(g_Engine.GetClientTime() * 1 * 360.f, 360.f); break;
			case AAYaw_FastSpin: cmd->viewangles.z = fmod(g_Engine.GetClientTime() * 30 * 360.f, 360.f); break;
			case AAYaw_Jitter:
				if (cvar.aa_yaw_jitter_custom)
				{
					static bool jitterAngles = false;
					float finalAngles = vAngles[2] + cvar.aa_yaw_jitter_angle;

					int checkMuch = !cvar.aa_yaw_jitter_much ? 1 : (int)cvar.aa_yaw_jitter_much;

					if (jitterAngles) finalAngles += rand() % checkMuch;
					else finalAngles -= rand() % checkMuch;

					cmd->viewangles.z = finalAngles;
				}
				else
				{
					static int rollJitterSide;

					if (rollJitterSide == 0)
						cmd->viewangles.z = vAngles[2] + 0;
					else if (rollJitterSide == 1)
						cmd->viewangles.z = vAngles[2] + 90;
					else if (rollJitterSide == 2)
						cmd->viewangles.z = vAngles[2] + 180;
					else if (rollJitterSide >= 3) {
						cmd->viewangles.z = vAngles[2] + -90;
						rollJitterSide = 0;
					}

					rollJitterSide++;
				}
				break;
			case AAYaw_Sideways:
				cmd->viewangles.z = yawSideway ? vAngles[2] + -90 : vAngles[2] + 90;
				break;
			case AAYaw_Random:
				cmd->viewangles.z = rand() % 361;
				if (cmd->viewangles.z > 180)
					cmd->viewangles.z -= 360;
				break;
			case AAYaw_Static: cmd->viewangles.z = vAngles[2] + cvar.aa_roll_static; break;
			}

			// Set fake edge
			float angle = cmd->viewangles.z;
			if ((cvar.aa_edge == 2 || cvar.aa_edge == 3) && FakeEdge(angle))
				cmd->viewangles.z = angle;
		}
		else if (cvar.aa_roll > 0) // Roll AA While Standing
		{
			static bool roll180Jitter = false;
			static int rollJitterSide;
			static int rollSideways;
			switch (static_cast<int>(cvar.aa_roll))
			{
			case AAYaw_180: cmd->viewangles.z = vAngles[2] + 180; break;
			case AAYaw_180Jitter:
				cmd->viewangles.z = roll180Jitter ? vAngles[2] + 180 : vAngles[2];
				roll180Jitter = !roll180Jitter;
				break;
			case AAYaw_SlowSpin: cmd->viewangles.z = fmod(g_Engine.GetClientTime() * 1 * 360.f, 360.f); break;
			case AAYaw_FastSpin: cmd->viewangles.z = fmod(g_Engine.GetClientTime() * 30 * 360.f, 360.f); break;
			case AAYaw_Jitter:
				if (cvar.aa_yaw_jitter_custom)
				{
					static bool jitterAngles = false;
					float finalAngles = vAngles[2] + cvar.aa_yaw_jitter_angle;

					int checkMuch = !cvar.aa_yaw_jitter_much ? 1 : (int)cvar.aa_yaw_jitter_much;

					if (jitterAngles) finalAngles += rand() % checkMuch;
					else finalAngles -= rand() % checkMuch;

					cmd->viewangles.z = finalAngles;
				}
				else
				{
					static int rollJitterSide;

					if (rollJitterSide == 0)
						cmd->viewangles.z = vAngles[2] + 0;
					else if (rollJitterSide == 1)
						cmd->viewangles.z = vAngles[2] + 90;
					else if (rollJitterSide == 2)
						cmd->viewangles.z = vAngles[2] + 180;
					else if (rollJitterSide >= 3) {
						cmd->viewangles.z = vAngles[2] + -90;
						rollJitterSide = 0;
					}

					rollJitterSide++;
				}
				break;
			case AAYaw_Sideways:
				cmd->viewangles.z = yawSideway ? vAngles[2] + -90 : vAngles[2] + 90;
				break;
			case AAYaw_Random:
				cmd->viewangles.z = rand() % 361;
				if (cmd->viewangles.z > 180)
					cmd->viewangles.z -= 360;
				break;
			case AAYaw_Static: cmd->viewangles.z = vAngles[2] + cvar.aa_roll_static; break;
			}

			// Set fake edge
			float angle = cmd->viewangles.z;
			if ((cvar.aa_edge == 1 || cvar.aa_edge == 3 || cvar.aa_edge == 4) && FakeEdge(angle))
			{
				static float timer = g_Local.weapon.curtime;

				if (g_Local.weapon.curtime - timer > 3 && cvar.aa_edge == 4)
				{
					timer = g_Local.weapon.curtime;

					cmd->viewangles.z = angle + 180;
				}
				else
				{
					cmd->viewangles.z = angle;
				}
			}
		}
	}

	// Pitch AA
	if (cvar.aa_pitch > 0)
	{
		switch (static_cast<int>(cvar.aa_pitch))
		{
		case AAPitch_Down:		cmd->viewangles.x = 89.f;			break;
		case AAPitch_Up:		cmd->viewangles.x = -89.f;			break;
		case AAPitch_FakeDown:	cmd->viewangles.x = 180;			break;
		case AAPitch_FakeUp:	cmd->viewangles.x = -179.99999f;	break;
		case AAPitch_FakeJitter:
			cmd->viewangles.x = pitchJitter ? 180 : -179.99999f;
			pitchJitter = !pitchJitter;
			break;
		case AAPitch_Random:
			cmd->viewangles.x = rand() % 361;
			if (cmd->viewangles.x > 180)
				cmd->viewangles.x -= 360;

			pitchRandomAngles = cmd->viewangles.x;
			break;
		}
	}

	FixMoveEnd(cmd);
}

void AntiAim::Entity(cl_entity_s* ent)
{
	if (!cvar.rage_antiaim_active)
		return;

	if (!Sakura::Player::Local::IsAlive())
		return;

	if (IsCurWeaponNonAttack())
		return;

	int id = NULL;
	float flDist = 8192.f;

	for (unsigned int i = 1; i <= g_Engine.GetMaxClients(); i++)
	{
		cl_entity_s* entindex = g_Engine.GetEntityByIndex(i);

		if (i == pmove->player_index + 1)
			continue;

		if (!Sakura::Player::IsAlive(i))
			continue;

		if (!cvar.rage_team && g_Player[i].iTeam == g_Local.iTeam)
			continue;

		if (entindex->curstate.origin.Distance(pmove->origin) < flDist || id == NULL)
		{
			flDist = entindex->curstate.origin.Distance(pmove->origin);
			id = i;
		}
	}

	Vector vAngles = pmove->angles;
	Vector vEye = pmove->origin + pmove->view_ofs;

	if (id > 0)
	{
		cl_entity_s* entindex = g_Engine.GetEntityByIndex(id);
		VectorAngles(entindex->origin - vEye, vAngles);
	}

	// Yaw AA While running
	if (pmove->velocity.Length2D() > 0 && cvar.aa_yaw_while_running > 0)
	{
		switch (static_cast<int>(cvar.aa_yaw_while_running))
		{
		case AAYaw_180: ent->angles[1] = vAngles[1] + 180; break;
		case AAYaw_180Jitter:
			ent->angles[1] = yaw180Jitter ? vAngles[1] + 180 : vAngles[1];
			//yaw180Jitter = !yaw180Jitter;
			break;
		case AAYaw_SlowSpin: ent->angles[1] = fmod(g_Engine.GetClientTime() * 1 * 360.f, 360.f); break;
		case AAYaw_FastSpin: ent->angles[1] = fmod(g_Engine.GetClientTime() * 30 * 360.f, 360.f); break;
		case AAYaw_Jitter:
			if (cvar.aa_yaw_jitter_custom)
			{
				ent->angles[1] = yawFinalAnglesJitter;
			}
			else
			{
				if (yawJitterSide == 0)
					ent->angles[1] = vAngles[1] + 0;
				else if (yawJitterSide == 1)
					ent->angles[1] = vAngles[1] + 90;
				else if (yawJitterSide == 2)
					ent->angles[1] = vAngles[1] + 180;
				else if (yawJitterSide >= 3) {
					ent->angles[1] = vAngles[1] + -90;
					//yawJitterSide = 0;
				}

				//yawJitterSide++;
			}
			break;
		case AAYaw_Sideways:
			ent->angles[1] = yawSideway ? vAngles[1] + -90 : vAngles[1] + 90;
			break;
		case AAYaw_Random:
			ent->angles[1] = yawRandomAngles;
			break;
		case AAYaw_Static: ent->angles[1] = vAngles[1] + cvar.aa_yaw_static; break;
		}

		// Set fake edge
		float angle = ent->angles[1];
		if ((cvar.aa_edge == 2 || cvar.aa_edge == 3) && FakeEdge(angle))
			ent->angles[1] = angle;
	}
	else if (cvar.aa_yaw > 0) // Yaw AA While standing
	{
		switch (static_cast<int>(cvar.aa_yaw))
		{
		case AAYaw_180: ent->angles[1] = vAngles[1] + 180; break;
		case AAYaw_180Jitter:
			ent->angles[1] = yaw180Jitter ? vAngles[1] + 180 : vAngles[1];
			//yaw180Jitter = !yaw180Jitter;
			break;
		case AAYaw_SlowSpin: ent->angles[1] = fmod(g_Engine.GetClientTime() * 1 * 360.f, 360.f); break;
		case AAYaw_FastSpin: ent->angles[1] = fmod(g_Engine.GetClientTime() * 30 * 360.f, 360.f); break;
		case AAYaw_Jitter:
			if (cvar.aa_yaw_jitter_custom)
			{
				ent->angles[1] = yawFinalAnglesJitter;
			}
			else
			{
				if (yawJitterSide == 0)
					ent->angles[1] = vAngles[1] + 0;
				else if (yawJitterSide == 1)
					ent->angles[1] = vAngles[1] + 90;
				else if (yawJitterSide == 2)
					ent->angles[1] = vAngles[1] + 180;
				else if (yawJitterSide >= 3) {
					ent->angles[1] = vAngles[1] + -90;
					//yawJitterSide = 0;
				}

				//yawJitterSide++;
			}
			break;
		case AAYaw_Sideways:
			ent->angles[1] = yawSideway ? vAngles[1] + -90 : vAngles[1] + 90;
			break;
		case AAYaw_Random:
			ent->angles[1] = yawRandomAngles;
			break;
		case AAYaw_Static: ent->angles[1] = vAngles[1] + cvar.aa_yaw_static; break;
		}

		// set fake edge
		float angle = ent->angles[1];
		if ((cvar.aa_edge == 1 || cvar.aa_edge == 3 || cvar.aa_edge == 4) && FakeEdge(angle))
		{
			static float timer = g_Local.weapon.curtime;

			if (g_Local.weapon.curtime - timer > 3 && cvar.aa_edge == 4)
			{
				timer = g_Local.weapon.curtime;

				ent->angles[1] = angle + 180;
			}
			else {
				ent->angles[1] = angle;
			}
		}
	}

	// Roll AA
	if (cvar.aa_roll_active)
	{
		// Roll AA While Running
		if (pmove->velocity.Length2D() > 0 && cvar.aa_roll_while_running > 0)
		{
			switch (static_cast<int>(cvar.aa_roll_while_running))
			{
			case AAYaw_180: ent->angles[2] = vAngles[2] + 180; break;
			case AAYaw_180Jitter:
				ent->angles[2] = yaw180Jitter ? vAngles[2] + 180 : vAngles[2];
				yaw180Jitter = !yaw180Jitter;
				break;
			case AAYaw_SlowSpin: ent->angles[2] = fmod(g_Engine.GetClientTime() * 1 * 360.f, 360.f); break;
			case AAYaw_FastSpin: ent->angles[2] = fmod(g_Engine.GetClientTime() * 30 * 360.f, 360.f); break;
			case AAYaw_Jitter:
				if (cvar.aa_yaw_jitter_custom)
				{
					static bool jitterAngles = false;
					float finalAngles = vAngles[2] + cvar.aa_yaw_jitter_angle;

					int checkMuch = !cvar.aa_yaw_jitter_much ? 1 : (int)cvar.aa_yaw_jitter_much;

					if (jitterAngles) finalAngles += rand() % checkMuch;
					else finalAngles -= rand() % checkMuch;

					ent->angles[2] = finalAngles;
				}
				else
				{
					static int rollJitterSide;

					if (rollJitterSide == 0)
						ent->angles[2] = vAngles[2] + 0;
					else if (rollJitterSide == 1)
						ent->angles[2] = vAngles[2] + 90;
					else if (rollJitterSide == 2)
						ent->angles[2] = vAngles[2] + 180;
					else if (rollJitterSide >= 3) {
						ent->angles[2] = vAngles[2] + -90;
						rollJitterSide = 0;
					}

					rollJitterSide++;
				}
				break;
			case AAYaw_Sideways:
				ent->angles[2] = yawSideway ? vAngles[2] + -90 : vAngles[2] + 90;
				break;
			case AAYaw_Random:
				ent->angles[2] = rand() % 361;
				if (ent->angles[2] > 180)
					ent->angles[2] -= 360;
				break;
			case AAYaw_Static: ent->angles[2] = vAngles[2] + cvar.aa_roll_static; break;
			}

			// Set fake edge
			float angle = ent->angles[1];
			if ((cvar.aa_edge == 2 || cvar.aa_edge == 3) && FakeEdge(angle))
				ent->angles[1] = angle;
		}
		else if (cvar.aa_roll > 0) // Roll AA While Standing
		{
			static bool roll180Jitter = false;
			static int rollJitterSide;
			static int rollSideways;
			switch (static_cast<int>(cvar.aa_roll))
			{
			case AAYaw_180: ent->angles[2] = vAngles[2] + 180; break;
			case AAYaw_180Jitter:
				ent->angles[2] = roll180Jitter ? vAngles[2] + 180 : vAngles[2];
				roll180Jitter = !roll180Jitter;
				break;
			case AAYaw_SlowSpin: ent->angles[2] = fmod(g_Engine.GetClientTime() * 1 * 360.f, 360.f); break;
			case AAYaw_FastSpin: ent->angles[2] = fmod(g_Engine.GetClientTime() * 30 * 360.f, 360.f); break;
			case AAYaw_Jitter:
				if (cvar.aa_yaw_jitter_custom)
				{
					static bool jitterAngles = false;
					float finalAngles = vAngles[2] + cvar.aa_yaw_jitter_angle;

					int checkMuch = !cvar.aa_yaw_jitter_much ? 1 : (int)cvar.aa_yaw_jitter_much;

					if (jitterAngles) finalAngles += rand() % checkMuch;
					else finalAngles -= rand() % checkMuch;

					ent->angles[2] = finalAngles;
				}
				else
				{
					static int rollJitterSide;

					if (rollJitterSide == 0)
						ent->angles[2] = vAngles[2] + 0;
					else if (rollJitterSide == 1)
						ent->angles[2] = vAngles[2] + 90;
					else if (rollJitterSide == 2)
						ent->angles[2] = vAngles[2] + 180;
					else if (rollJitterSide >= 3) {
						ent->angles[2] = vAngles[2] + -90;
						rollJitterSide = 0;
					}

					rollJitterSide++;
				}
				break;
			case AAYaw_Sideways:
				ent->angles[2] = yawSideway ? vAngles[2] + -90 : vAngles[2] + 90;
				break;
			case AAYaw_Random:
				ent->angles[2] = rand() % 361;
				if (ent->angles[2] > 180)
					ent->angles[2] -= 360;
				break;
			case AAYaw_Static: ent->angles[2] = vAngles[2] + cvar.aa_roll_static; break;
			}

			// Set fake edge
			float angle = ent->angles[2];
			if ((cvar.aa_edge == 1 || cvar.aa_edge == 3 || cvar.aa_edge == 4) && FakeEdge(angle))
			{
				static float timer = g_Local.weapon.curtime;

				if (g_Local.weapon.curtime - timer > 3 && cvar.aa_edge == 4)
				{
					timer = g_Local.weapon.curtime;

					ent->angles[2] = angle + 180;
				}
				else
				{
					ent->angles[2] = angle;
				}
			}
		}
	}

	// Pitch AA
	if (cvar.aa_pitch > 0)
	{
		switch (static_cast<int>(cvar.aa_pitch))
		{
		case AAPitch_Down:		ent->angles[0] = 89.f;			break;
		case AAPitch_Up:		ent->angles[0] = -89.f;			break;
		case AAPitch_FakeDown:	ent->angles[0] = 180;			break;
		case AAPitch_FakeUp:	ent->angles[0] = -179.99999f;	break;
		case AAPitch_FakeJitter:
			ent->angles[0] = pitchJitter ? 180 : -179.99999f;
			pitchJitter = !pitchJitter;
			break;
		case AAPitch_Random:
			ent->angles[0] = pitchRandomAngles;
			break;
		}
	}
}
```

`sakura/source/features/rage/antiaim.h`:

```h
#ifndef _ANTIAIM_
#define _ANTIAIM_

enum AntiAimPitch
{
	AAPitch_Up = 1,
	AAPitch_Down,
	AAPitch_FakeDown,
	AAPitch_FakeUp,
	AAPitch_FakeJitter,
	AAPitch_Random
};

enum AntiAimYaw
{
	AAYaw_180 = 1,
	AAYaw_180Jitter,
	AAYaw_SlowSpin,
	AAYaw_FastSpin,
	AAYaw_Jitter,
	AAYaw_Sideways,
	AAYaw_Random,
	AAYaw_Static
};

extern bool yawSideway;

namespace AntiAim
{
	void Local(usercmd_s* cmd);
	void Entity(cl_entity_s* ent);
	void DrawArrows();
};

//void AntiAim(struct usercmd_s* cmd);
//void SetAntiAimAngles(cl_entity_s* ent);

#endif
```

`sakura/source/features/rage/autoroute.cpp`:

```cpp
#include "../../client.h"

AutoRoute autoroute;

float GetPointDistance(Vector pos)
{
	Vector vEye = pmove->origin + pmove->view_ofs;
	return vEye.Distance(pos);
}

void CalcVec_MeToTarget(float* view)
{
	float EntViewOrg[3];
	VectorCopy(view, EntViewOrg);
	Vector vEye = pmove->origin + pmove->view_ofs;
	view[0] = EntViewOrg[0] - vEye[0];
	view[1] = EntViewOrg[1] - vEye[1];
	view[2] = EntViewOrg[2] - vEye[2];
}

void GetPointAngles(float* point, float* angles)
{
	float vec_to_target[3];
	VectorCopy(point, vec_to_target);
	CalcVec_MeToTarget(vec_to_target);
	VectorAngles(vec_to_target, angles);
	angles[0] *= -1;
	if (angles[0] > 180) angles[0] -= 360;
	if (angles[1] > 180) angles[1] -= 360;
}

void ChangeViewAngle(float* point, usercmd_s* usercmd)
{
	float aim_viewangles[3];
	float vec_to_target[3];
	VectorCopy(point, vec_to_target);
	CalcVec_MeToTarget(vec_to_target);
	VectorAngles(vec_to_target, aim_viewangles);
	aim_viewangles[0] *= -1;
	if (aim_viewangles[0] > 180) aim_viewangles[0] -= 360;
	if (aim_viewangles[1] > 180) aim_viewangles[1] -= 360;
	VectorCopy(aim_viewangles, usercmd->viewangles);
	g_Engine.SetViewAngles(aim_viewangles);
}

bool GetPointVisible(float* point)
{
	strace_t tr;
	tr.finished = false;
	Vector vEye = pmove->origin + pmove->view_ofs;
	TraceThickness(vEye, point, 0, &tr);
	return tr.finished;
}

float CalcTwoAngle(float a, float b)
{
	float c = abs(a - b);
	if (c > 180)
		return abs(c - 360);
	else
		return c;
}

float CalcRouteAngle(float* point, float* point1)
{
	Vector ViewAngles;
	g_Engine.GetViewAngles(ViewAngles);
	float addvec[2];
	float dodgeDir[3];
	dodgeDir[0] = dodgeDir[1] = dodgeDir[2] = 0;
	addvec[0] = point[0] - point1[0];
	addvec[1] = point[1] - point1[1];
	float dist = (float)sqrt(addvec[0] * addvec[0] + addvec[1] * addvec[1]);
	addvec[0] /= dist;
	addvec[1] /= dist;
	dodgeDir[0] -= addvec[0];
	dodgeDir[1] -= addvec[1];
	dodgeDir[2] = 0;
	float dodgeAngles[3];
	VectorAngles(dodgeDir, dodgeAngles);
	return  CalcTwoAngle(dodgeAngles[1], ViewAngles[1]);
}

void AutoRoute::CreateMove(usercmd_s* usercmd)
{
	if (Record)
	{
		if (iRouteLine > -1)
		{
			if (iRoutePoint == routepointcount) { Record = false; return; };
			if (iRoutePoint == -1)
			{
				AddPoint();
			}
			else
			{
				float dist = GetPointDistance(route_line[iRouteLine].point[iRoutePoint].origin);
				if (dist >= 100.f)
				{
					AddPoint();
				}
			}
		}
		return;
	}

	if (bContinueAutoRoute)
	{
		Vector vEye = pmove->origin + pmove->view_ofs;
		if (iRouteLine > -1 && iRoutePoint > -1 && abs(route_line[iRouteLine].point[iRoutePoint].origin[2] - vEye[2]) < 25 && GetPointVisible(route_line[iRouteLine].point[iRoutePoint].origin))
		{
			route_mode = ROUTE_START;
		}
		else
		{
			FindAnyRoute(10000, false);
		}
		bContinueAutoRoute = false;
	}

	if (cvar.route_auto && Sakura::Player::Local::IsAlive())
	{
		if (Sakura::Aimbot::Rage::iTargetRage && g_Local.weapon.m_iClip)
		{
			if (cvar.route_mode || IsCurWeaponKnife())
			{
				iRouteLine = -1;
				iRoutePoint = -1;
				route_mode = ROUTE_NONE;
				return;
			}
		}
		switch (route_mode)
		{
		case ROUTE_NONE:
		{
			FindFowardRoute(-1);
			if (iRoutePoint > -1 && iRouteLine > -1)
			{
				GotoRoutePoint(route_line[iRouteLine].point[iRoutePoint].origin, usercmd);
				route_mode = ROUTE_FROM;
			}
			break;
		}
		case ROUTE_START:
		{
			GotoRoutePoint(route_line[iRouteLine].point[iRoutePoint].origin, usercmd);
			route_mode = ROUTE_FROM;
		}
		break;
		case ROUTE_FROM:
		{
			if (((route_direction == ROUTE_ASC) && (iRoutePoint == route_line[iRouteLine].count - 1)) || ((route_direction == ROUTE_DESC) && (iRoutePoint == 0)))
			{
				FindFowardRoute(iRouteLine);
				if (iRoutePoint > -1 && iRouteLine > -1)
				{
					GotoRoutePoint(route_line[iRouteLine].point[iRoutePoint].origin, usercmd);
					route_mode = ROUTE_FROM;
				}
				else
					route_mode = ROUTE_NONE;
				return;
			}

			if (RouteMoveEnough(route_line[iRouteLine].point[iRoutePoint].origin, usercmd))
			{
				int i = iRoutePoint;
				switch (route_direction)
				{
				case ROUTE_ASC:
				{
					i++;
					if (g_Local.weapon.m_iClip)
					{
						if (i == route_line[iRouteLine].count - 1 && !Sakura::Aimbot::Rage::iTargetRage)
						{
							ChangeViewAngle(route_line[iRouteLine].point[i].origin, usercmd);
						}
					}
					else
					{
						if (i == route_line[iRouteLine].count - 1)
						{
							ChangeViewAngle(route_line[iRouteLine].point[i].origin, usercmd);
						}
					}
				}
				break;
				case ROUTE_DESC:
				{
					i--;
					if (g_Local.weapon.m_iClip)
					{
						if (i == 0 && !Sakura::Aimbot::Rage::iTargetRage)
						{
							ChangeViewAngle(route_line[iRouteLine].point[i].origin, usercmd);
						}
					}
					else
					{
						if (i == 0)
						{
							ChangeViewAngle(route_line[iRouteLine].point[i].origin, usercmd);
						}
					}
				}
				break;
				}
				iRoutePoint = i;
				GotoRoutePoint(route_line[iRouteLine].point[iRoutePoint].origin, usercmd);
			}
			return;
		}
		break;
		case ROUTE_END:
		{
			iRouteLine = -1;
			iRoutePoint = -1;
			route_mode = ROUTE_NONE;
		}
		break;
		}
	}
	else
	{
		iRouteLine = -1;
		iRoutePoint = -1;
		route_mode = ROUTE_NONE;
	}
}

void AutoRoute::GotoRoutePoint(float* point, usercmd_s* usercmd)
{
	Vector ViewAngles;
	g_Engine.GetViewAngles(ViewAngles);
	float addvec[2];
	float dodgeDir[3];
	Vector vEye = pmove->origin + pmove->view_ofs;
	dodgeDir[0] = dodgeDir[1] = dodgeDir[2] = 0;
	addvec[0] = vEye[0] - point[0];
	addvec[1] = vEye[1] - point[1];
	float dist = GetPointDistance(point);
	addvec[0] /= dist;
	addvec[1] /= dist;
	dodgeDir[0] -= addvec[0];
	dodgeDir[1] -= addvec[1];
	dodgeDir[2] = 0;
	float dodgeAngles[3];
	VectorAngles(dodgeDir, dodgeAngles);
	float angle = dodgeAngles[1] - ViewAngles[1];
	while (angle < 0) { angle += 360; }
	while (angle > 360) { angle -= 360; }
	me_forwardmove = (float)cos(angle * (3.1415926 / 180.0)) * dist;
	me_sidemove = (float)-sin(angle * (3.1415926 / 180.0)) * dist;
	usercmd->forwardmove += me_forwardmove;
	usercmd->sidemove += me_sidemove;
}

bool AutoRoute::RouteMoveEnough(float* point, usercmd_s* usercmd)
{
	Vector ViewAngles;
	g_Engine.GetViewAngles(ViewAngles);
	float addvec[2];
	float dodgeDir[3];
	Vector vEye = pmove->origin + pmove->view_ofs;
	dodgeDir[0] = dodgeDir[1] = dodgeDir[2] = 0;
	addvec[0] = vEye[0] - point[0];
	addvec[1] = vEye[1] - point[1];
	float dist = GetPointDistance(point);
	addvec[0] /= dist;
	addvec[1] /= dist;
	dodgeDir[0] -= addvec[0];
	dodgeDir[1] -= addvec[1];
	dodgeDir[2] = 0;
	float dodgeAngles[3];
	VectorAngles(dodgeDir, dodgeAngles);
	float angle = dodgeAngles[1] - ViewAngles[1];
	while (angle < 0) { angle += 360; }
	while (angle > 360) { angle -= 360; }
	me_forwardmove = (float)cos(angle * (3.1415926 / 180.0)) * dist;
	me_sidemove = (float)-sin(angle * (3.1415926 / 180.0)) * dist;
	usercmd->forwardmove = me_forwardmove * 2.5f;
	usercmd->sidemove = me_sidemove * 2.5f;
	if (usercmd->forwardmove > 0 - 230 && usercmd->forwardmove < 230 && usercmd->sidemove>0 - 230 && usercmd->sidemove < 230)
		return true;
	return false;
}

void AutoRoute::FindFowardRoute(int lastroute)
{
	float angles[3];
	float dist1;
	float dist;
	float minangles = 50;
	float minrouteangles = 30;
	float pointangles;
	float routeangle;
	iRouteLine = -1;
	iRoutePoint = -1;
	int i;
	Vector ViewAngles;
	g_Engine.GetViewAngles(ViewAngles);
	for (i = 0; i < routecount; i++)
	{
		if (route_line[i].enabled && i != lastroute)
		{
			float mindist = 150.f;
			for (unsigned int j = 0; j < route_line[i].count; j++)
			{
				dist = GetPointDistance(route_line[i].point[j].origin);
				if (dist < mindist)
				{
					Vector vEye = pmove->origin + pmove->view_ofs;
					if (abs(route_line[i].point[j].origin[2] - vEye[2]) < 25)
					{
						GetPointAngles(route_line[i].point[j].origin, angles);
						pointangles = CalcTwoAngle(ViewAngles[1], angles[1]);
						if (GetPointVisible(route_line[i].point[j].origin) && pointangles <= 50)
						{
							if (j > 0 && j < route_line[i].count - 1)
							{
								dist1 = GetPointDistance(route_line[i].point[j + 1].origin);
								if (dist1 >= dist)
								{
									routeangle = CalcRouteAngle(route_line[i].point[j].origin, route_line[i].point[j + 1].origin);
									if (routeangle < minrouteangles)
									{
										minrouteangles = routeangle;
										route_direction = ROUTE_ASC;
										iRouteLine = i;
										iRoutePoint = j;
									}
								}
								else
								{
									routeangle = CalcRouteAngle(route_line[i].point[j].origin, route_line[i].point[j - 1].origin);
									if (routeangle < minrouteangles)
									{
										minrouteangles = routeangle;
										route_direction = ROUTE_DESC;
										iRouteLine = i;
										iRoutePoint = j;
									}
								}
							}
							else if (j == 0)
							{
								dist1 = GetPointDistance(route_line[i].point[j + 1].origin);
								if (dist1 >= dist)
								{
									routeangle = CalcRouteAngle(route_line[i].point[j].origin, route_line[i].point[j + 1].origin);
									if (routeangle < minrouteangles)
									{
										minrouteangles = routeangle;
										route_direction = ROUTE_ASC;
										iRouteLine = i;
										iRoutePoint = j;
									}
								}
							}
							else if (j == route_line[i].count - 1)
							{
								dist1 = GetPointDistance(route_line[i].point[j - 1].origin);
								if (dist1 >= dist)
								{
									routeangle = CalcRouteAngle(route_line[i].point[j].origin, route_line[i].point[j - 1].origin);
									if (routeangle < minrouteangles)
									{
										minrouteangles = routeangle;
										route_direction = ROUTE_DESC;
										iRouteLine = i;
										iRoutePoint = j;
									}
								}
							}
						}
					}
				}
			}
		}
	}
	if (iRouteLine != -1 && iRoutePoint != -1)return;

	float angles1[3];
	minangles = 50;
	minrouteangles = 20;
	iRouteLine = -1;
	iRoutePoint = -1;

	for (i = 0; i < routecount; i++)
	{
		if (route_line[i].enabled && i != lastroute)
		{
			float mindist = 230;
			for (unsigned int j = 0; j < route_line[i].count; j++)
			{
				dist = GetPointDistance(route_line[i].point[j].origin);
				if (dist < mindist)
				{
					Vector vEye = pmove->origin + pmove->view_ofs;
					if (abs(route_line[i].point[j].origin[2] - vEye[2]) < 25)
					{
						GetPointAngles(route_line[i].point[j].origin, angles);
						pointangles = CalcTwoAngle(ViewAngles[1], angles[1]);
						if (GetPointVisible(route_line[i].point[j].origin) && pointangles <= 50)
						{
							if (j > 0 && j < route_line[i].count - 1)
							{
								dist1 = GetPointDistance(route_line[i].point[j + 1].origin);
								if (dist1 >= dist)
								{
									GetPointAngles(route_line[i].point[j + 1].origin, angles1);
									routeangle = CalcTwoAngle(angles1[1], angles[1]);
									if (routeangle < minrouteangles && CalcTwoAngle(ViewAngles[1], angles1[1]) <= 50)
									{
										mindist = dist;
										minrouteangles = routeangle;
										route_direction = ROUTE_ASC;
										iRouteLine = i;
										iRoutePoint = j;
									}
								}
								else
								{
									GetPointAngles(route_line[i].point[j - 1].origin, angles1);
									routeangle = CalcTwoAngle(angles1[1], angles[1]);
									if (routeangle < minrouteangles && CalcTwoAngle(ViewAngles[1], angles1[1]) <= 50)
									{
										mindist = dist;
										minrouteangles = routeangle;
										route_direction = ROUTE_DESC;
										iRouteLine = i;
										iRoutePoint = j;
									}
								}
							}
							else if (j == 0)
							{
								dist1 = GetPointDistance(route_line[i].point[j + 1].origin);
								if (dist1 >= dist)
								{
									GetPointAngles(route_line[i].point[j + 1].origin, angles1);
									routeangle = CalcTwoAngle(angles1[1], angles[1]);
									if (routeangle < minrouteangles && CalcTwoAngle(ViewAngles[1], angles1[1]) <= 50)
									{
										mindist = dist;
										minrouteangles = routeangle;
										route_direction = ROUTE_ASC;
										iRouteLine = i;
										iRoutePoint = j;
									}
								}
							}
							else if (j == route_line[i].count - 1)
							{
								dist1 = GetPointDistance(route_line[i].point[j - 1].origin);
								if (dist1 >= dist)
								{
									GetPointAngles(route_line[i].point[j - 1].origin, angles1);
									routeangle = CalcTwoAngle(angles1[1], angles[1]);
									if (routeangle < minrouteangles && CalcTwoAngle(ViewAngles[1], angles1[1]) <= 50)
									{
										mindist = dist;
										minrouteangles = routeangle;
										route_direction = ROUTE_DESC;
										iRouteLine = i;
										iRoutePoint = j;
									}
								}
							}
						}
					}
				}
			}
		}
	}
}

void AutoRoute::LoadRoute(char* sfilename)
{
	Record = false;
	char tfilename[256];
	if (sfilename[0] == '\0')
	{
		strcpy(levelname, g_Engine.pfnGetLevelName() + 5);
		int len = strlen(levelname);
		if (len > 4)levelname[len - 4] = (char)0;
		sprintf(tfilename, /*assets/routes/%s.route*/XorStr<0x48, 23, 0xDAB84B3F>("\x29\x3A\x39\x2E\x38\x3E\x61\x3D\x3F\x24\x26\x36\x27\x7A\x73\x24\x76\x2B\x35\x2E\x28\x38" + 0xDAB84B3F).s, levelname);
		sprintf(filename, /*%s%s*/XorStr<0x99, 5, 0xC6A234F4>("\xBC\xE9\xBE\xEF" + 0xC6A234F4).s, Sakura::CheatDir, tfilename);
	}
	else
	{
		sprintf(tfilename, /*assets/routes/%s.route*/XorStr<0x1F, 23, 0x2803FF48>("\x7E\x53\x52\x47\x57\x57\x0A\x54\x48\x5D\x5D\x4F\x58\x03\x08\x5D\x01\x42\x5E\x47\x47\x51" + 0x2803FF48).s, sfilename);
		sprintf(filename, /*%s%s*/XorStr<0x3C, 5, 0x15A832CE>("\x19\x4E\x1B\x4C" + 0x15A832CE).s, Sakura::CheatDir, tfilename);
	}
	ZeroMemory(route_line, sizeof(route_line));
	std::ifstream ifs(filename);
	while (ifs.good())
	{
		char buf[1024] = { 0 };
		ifs.getline(buf, sizeof(buf));
		int i, j;
		float f1 = 0, f2 = 0, f3 = 0;
		if (sscanf(buf, "route(%d)(%d):%f,%f,%f", &i, &j, &f1, &f2, &f3))
		{
			if (f1 != 0 && f2 != 0 && f3 != 0)
			{
				route_line[i].point[j].origin[0] = f1;
				route_line[i].point[j].origin[1] = f2;
				route_line[i].point[j].origin[2] = f3;
				route_line[i].enabled = true;
				route_line[i].count++;
			}
		}
	}
	ifs.close();

}

void AutoRoute::SaveRoute()
{
	char tfilename[256];
	strcpy(levelname, g_Engine.pfnGetLevelName() + 5);
	int len = strlen(levelname);
	if (len > 4)levelname[len - 4] = (char)0;
	sprintf(tfilename, /*assets/routes/%s.route*/XorStr<0x9B, 23, 0xCCBE0DFA>("\xFA\xEF\xEE\xFB\xEB\xD3\x8E\xD0\xCC\xD1\xD1\xC3\xD4\x87\x8C\xD9\x85\xDE\xC2\xDB\xDB\xD5" + 0xCCBE0DFA).s, levelname);
	sprintf(filename, /*%s%s*/XorStr<0x8A, 5, 0x37B452DC>("\xAF\xF8\xA9\xFE" + 0x37B452DC).s, Sakura::CheatDir, tfilename);
	char routepoint[256];
	remove(filename);
	std::ofstream ofs(filename, std::ios::binary | std::ios::app);
	for (unsigned int i = 0; i < routecount; i++)
	{
		if (route_line[i].enabled)
		{
			for (unsigned int j = 0; j < route_line[i].count; j++)
			{
				sprintf(routepoint, "route(%d)(%d):%f,%f,%f", i, j, route_line[i].point[j].origin[0], route_line[i].point[j].origin[1], route_line[i].point[j].origin[2]);
				ofs << routepoint << (char)0x0D << (char)0x0A;
			}
		}
	}
	ofs.close();
}

void AutoRoute::AddPoint()
{
	if (iRouteLine > -1)
	{
		iRoutePoint++;
		if (iRoutePoint == routepointcount)
		{
			iRoutePoint = routepointcount - 1;
			Record = false;
			return;
		}
		Vector vEye = pmove->origin + pmove->view_ofs;
		route_line[iRouteLine].point[iRoutePoint].origin = vEye;
		route_line[iRouteLine].count++;
	}
}

void AutoRoute::ClearAllRoute()
{
	Record = false; 
	memset(route_line, 0, sizeof(route_line));
}

void AutoRoute::RecordAnyRouteStart()
{
	iRouteLine = routecount;
	for (unsigned int i = 0; i < routecount; i++)
	{
		if (!route_line[i].enabled)
		{
			iRouteLine = i;
			break;
		}
	}
	iRoutePoint = -1;
	route_line[iRouteLine].enabled = true;
	route_line[iRouteLine].count = 0;
	Record = true;
}

void AutoRoute::RecordRouteStop()
{
	Record = false;
}

void AutoRoute::FindAnyRoute(float pointdist, bool userand)
{
	iRouteLine = -1;
	iRoutePoint = -1;
	int iRouteLine1 = -1;
	int iRoutePoint1 = -1;
	float mindist = pointdist;
	for (unsigned int i = 0; i < routecount; i++)
	{
		if (route_line[i].enabled)
		{
			if (route_line[i].count > 12)
			{
				for (unsigned int j = 0; j < route_line[i].count; j++)
				{
					if (GetPointVisible(route_line[i].point[j].origin))
					{
						float dist = GetPointDistance(route_line[i].point[j].origin); 
						Vector vEye = pmove->origin + pmove->view_ofs;
						if (dist < mindist && abs(route_line[i].point[j].origin[2] - vEye[2]) < 25)
						{
							mindist = dist;
							iRouteLine1 = i;
							iRoutePoint1 = j;
						}
					}
				}
			}
		}
	}
	if (userand)
	{
		int iRouteLine2 = -1;
		int iRoutePoint2 = -1;
		mindist = pointdist;
		for (unsigned int i = 0; i < routecount; i++)
		{
			if (i == iRouteLine1)
				continue;
			if (route_line[i].enabled)
			{
				if (route_line[i].count > 12)
				{
					for (unsigned int j = 0; j < route_line[i].count; j++)
					{
						if (GetPointVisible(route_line[i].point[j].origin))
						{
							float dist = GetPointDistance(route_line[i].point[j].origin);
							Vector vEye = pmove->origin + pmove->view_ofs;
							if (dist < mindist && abs(route_line[i].point[j].origin[2] - vEye[2]) < 25)
							{
								mindist = dist;
								iRouteLine2 = i;
								iRoutePoint2 = j;
							}
						}
					}
				}
			}
		}
		if (iRouteLine2 == -1)
		{
			iRouteLine2 = iRouteLine1;
			iRoutePoint2 = iRoutePoint1;
		}
		int iRouteLine3 = -1;
		int iRoutePoint3 = -1;
		mindist = pointdist;
		for (unsigned int i = 0; i < routecount; i++)
		{
			if (i == iRouteLine1 || i == iRouteLine2)
				continue;
			if (route_line[i].enabled)
			{
				if (route_line[i].count > 12)
				{
					for (unsigned int j = 0; j < route_line[i].count; j++)
					{
						if (GetPointVisible(route_line[i].point[j].origin))
						{
							float dist = GetPointDistance(route_line[i].point[j].origin);
							Vector vEye = pmove->origin + pmove->view_ofs;
							if (dist < mindist && abs(route_line[i].point[j].origin[2] - vEye[2]) < 25)
							{
								mindist = dist;
								iRouteLine3 = i;
								iRoutePoint3 = j;
							}
						}
					}
				}
			}
		}
		if (iRouteLine3 == -1)
		{
			iRouteLine3 = iRouteLine1;
			iRoutePoint3 = iRoutePoint1;
		}
		srand((unsigned)time(NULL));
		int randnum = rand() % 3 + 1;
		if (randnum == 1)
		{
			iRouteLine = iRouteLine1;
			iRoutePoint = iRoutePoint1;
		}
		else if (randnum == 2)
		{
			iRouteLine = iRouteLine2;
			iRoutePoint = iRoutePoint2;
		}
		else
		{
			iRouteLine = iRouteLine3;
			iRoutePoint = iRoutePoint3;
		}
	}
	else
	{
		iRouteLine = iRouteLine1;
		iRoutePoint = iRoutePoint1;
	}
	if (iRouteLine > -1 && iRoutePoint > -1)
	{
		if (iRoutePoint <= route_line[iRouteLine].count - iRoutePoint)
			route_direction = ROUTE_ASC;
		else
			route_direction = ROUTE_DESC;
		route_mode = ROUTE_START;
	}
	else
	{
		route_mode = ROUTE_NONE;
	}
}

void AutoRoute::RouteTurn()
{
	if (route_mode == ROUTE_FROM || route_mode == ROUTE_START)
	{
		if (route_direction == ROUTE_ASC)
		{
			route_direction = ROUTE_DESC;
			if (iRoutePoint > 0)
				iRoutePoint--;
		}
		else if (route_direction == ROUTE_DESC)
		{
			route_direction = ROUTE_ASC;
			if (iRoutePoint < route_line[iRouteLine].count - 1)
				iRoutePoint++;
		}
		Vector vEye = pmove->origin + pmove->view_ofs;
		if (route_line[iRouteLine].point[iRoutePoint].origin[2] - vEye[2] < 25 && route_line[iRouteLine].point[iRoutePoint].origin[2] - vEye[2] > -100 && GetPointVisible(route_line[iRouteLine].point[iRoutePoint].origin))
			route_mode = ROUTE_START;
		else
		{
			iRouteLine = -1;
			iRoutePoint = -1;
			route_mode = ROUTE_NONE;
			FindAnyRoute(10000, false);
		}
	}
	else
	{
		iRouteLine = -1;
		iRoutePoint = -1;
		route_mode = ROUTE_NONE;
		FindAnyRoute(10000, false);
	}
}

float MySpeed()
{
	return sqrt(pmove->velocity[0] * pmove->velocity[0] + pmove->velocity[1] * pmove->velocity[1]);
}

bool InMove(usercmd_s* cmd)
{
	if (cmd->buttons & IN_FORWARD || cmd->buttons & IN_BACK || cmd->buttons & IN_MOVELEFT || cmd->buttons & IN_MOVERIGHT)
		return true;
	return false;
}

void RouteDirection(usercmd_s* cmd)
{
	static int iTurnMove = false;
	static int iJumpMove = false;
	if (cvar.misc_wav_speed > 1 && !IsFreezePeriod())
	{
		if (InMove(cmd) && MySpeed() < 30)
		{
			iJumpMove++;
			if (iJumpMove >= cvar.route_jump_step)
			{
				if (cvar.route_jump)
					cmd->buttons |= IN_JUMP;
				iJumpMove = false;
			}
			iTurnMove++;
			if (iTurnMove >= cvar.route_direction_step)
			{
				if (cvar.route_direction)
				{
					Vector ViewAngles;
					g_Engine.GetViewAngles(ViewAngles);
					if (g_Local.weapon.m_iClip)
					{
						if (!Sakura::Aimbot::Rage::iTargetRage)
						{
							ViewAngles[1] += 90;
							g_Engine.SetViewAngles(ViewAngles);
							autoroute.RouteTurn();
						}
					}
					else
					{
						ViewAngles[1] += 90;
						g_Engine.SetViewAngles(ViewAngles);
						autoroute.RouteTurn();
					}
				}
				iTurnMove = false;
			}
		}
		else
		{
			iTurnMove = false;
			iJumpMove = false;
		}
	}
}

void DrawRouteLine()
{
	if (cvar.route_activate && cvar.route_draw && Sakura::Player::Local::IsAlive())
	{

		ImColor routeLineColor = Sakura::Colors::Rainbow();
		ImColor routePointColor = Sakura::Colors::Rainbow();

		if (!cvar.rainbow_route_line)
			routeLineColor = ImColor(cvar.route_line_color[0], cvar.route_line_color[1], cvar.route_line_color[2], cvar.route_line_color[3]);

		if (!cvar.rainbow_route_point)
			routePointColor = ImColor(cvar.route_point_color[0], cvar.route_point_color[1], cvar.route_point_color[2], cvar.route_point_color[3]);

		for (unsigned int i = 0; i < autoroute.routecount; i++)
		{
			if (autoroute.route_line[i].enabled)
			{
				for (unsigned int j = 0; j < autoroute.route_line[i].count; j++)
				{
					float dist = GetPointDistance(autoroute.route_line[i].point[j].origin);
					if (dist < 800)
					{
						if (j > 0 && j % 1 == 0)
						{
							Vector vecBegin, vecEnd;
							vecBegin = autoroute.route_line[i].point[j - 1].origin;
							vecBegin[2] -= 37;
							vecEnd = autoroute.route_line[i].point[j].origin;
							vecEnd[2] -= 37;
							float vecScreenMin[2], vecScreenMax[2];
							if (WorldToScreen(vecBegin, vecScreenMin) && WorldToScreen(vecEnd, vecScreenMax))
								ImGui::GetCurrentWindow()->DrawList->AddLine({ IM_ROUND(vecScreenMin[0]), IM_ROUND(vecScreenMin[1]) }, { IM_ROUND(vecScreenMax[0]), IM_ROUND(vecScreenMax[1]) }, routeLineColor);
						}
						if (j == 0 || j == autoroute.route_line[i].count - 1)
						{
							Vector vecPoint;
							vecPoint = autoroute.route_line[i].point[j].origin;
							vecPoint[2] -= 37;
							char str[32];
							sprintf(str, /*%d*/XorStr<0x64, 3, 0x36CA7CB2>("\x41\x01" + 0x36CA7CB2).s, i + 1);
							float vecScreenMin[2];
							if (WorldToScreen(vecPoint, vecScreenMin))
							{
								float label_size = IM_ROUND(ImGui::CalcTextSize(str, NULL, true).x / 2);
								ImGui::GetCurrentWindow()->DrawList->AddRect({ IM_ROUND(vecScreenMin[0]) - label_size - 2, IM_ROUND(vecScreenMin[1]) - 24 }, { IM_ROUND(vecScreenMin[0]) + label_size + 3, IM_ROUND(vecScreenMin[1]) - 10 }, routePointColor);
								ImGui::GetCurrentWindow()->DrawList->AddText({ IM_ROUND(vecScreenMin[0]) - label_size, IM_ROUND(vecScreenMin[1]) - 25 }, Sakura::Colors::White(), str);
								ImGui::GetCurrentWindow()->DrawList->AddRectFilled({ IM_ROUND(vecScreenMin[0]) - 1, IM_ROUND(vecScreenMin[1]) - 1 }, { IM_ROUND(vecScreenMin[0]) + 2, IM_ROUND(vecScreenMin[1]) + 2 }, routePointColor);
							}
						}
					}
				}
			}
		}
	}
}

void Route(usercmd_s* cmd)
{
	autoroute.CreateMove(cmd);
	RouteDirection(cmd);
}

void ContinueRoute()
{
	if (cvar.route_auto)
		autoroute.bContinueAutoRoute = true;
	else
		autoroute.bContinueAutoRoute = false;
	static char CurrentMap[256];
	if (strcmp(CurrentMap, g_Engine.pfnGetLevelName()))
	{
		autoroute.LoadRoute("");
		strcpy(CurrentMap, g_Engine.pfnGetLevelName());
	}
}

```

`sakura/source/features/rage/autoroute.h`:

```h
#ifndef _AUTOROUTE_
#define _AUTOROUTE_

typedef struct
{
	vec3_t	origin;
	int	index;
} Route_Point;

typedef struct
{
	Route_Point	point[300];
	int	index;
	int	count;
	bool enabled;
} Route_Line;

typedef enum
{
	ROUTE_NONE = 0,
	ROUTE_FROM = 1,
	ROUTE_END = 2,
	ROUTE_START = 3,
} ROUTEMODE;

typedef enum
{
	ROUTE_NO_DIRECTION = 0,
	ROUTE_ASC = 1,
	ROUTE_DESC = 2,
} ROUTEDIRECTION;

class AutoRoute
{
public:
	int routecount, routepointcount, iRoutePoint, iRouteLine;
	float me_sidemove, me_forwardmove;
	void GotoRoutePoint(float* point, usercmd_s* usercmd);
	bool RouteMoveEnough(float* point, usercmd_s* usercmd);
	void CreateMove(usercmd_s* usercmd);
	void FindFowardRoute(int lastroute);
	void LoadRoute(char* sfilename);
	void SaveRoute();
	void AddPoint();
	void RouteTurn();
	void ClearAllRoute();
	void RecordAnyRouteStart();
	void RecordRouteStop();
	void FindAnyRoute(float pointdist, bool userand);
	bool bContinueAutoRoute;
	char filename[256], levelname[256];
	bool Record;
	ROUTEMODE route_mode;
	ROUTEDIRECTION route_direction;
	Route_Line route_line[100];
public:
	AutoRoute()
	{
		routepointcount = 300;
		routecount = 100;
		iRoutePoint = -1;
		iRouteLine = -1;
		me_forwardmove = 0;
		me_sidemove = 0;
		Record = false;
		route_direction = ROUTE_ASC;
		RtlZeroMemory(route_line, sizeof(route_line));
	}
};
extern AutoRoute autoroute;

void Route(struct usercmd_s* cmd);
void DrawRouteLine();
void ContinueRoute();
float MySpeed();

#endif
```

`sakura/source/features/rage/fakelag.cpp`:

```cpp
#include "../../client.h"

void FakeLag(float frametime, struct usercmd_s* cmd)
{
	if (cvar.fakelag_active)
	{
		int m_InAttack = (cmd->buttons & IN_ATTACK);

		bool fakelag = false;

		if (!(m_InAttack && CanAttack()))
			fakelag = true;

		if (cvar.fakelag_while_shooting && m_InAttack && CanAttack())
			fakelag = true;

		if (cvar.fakelag_move == 0)//On land
		{
			if (pmove->velocity.Length2D() > 0)
				fakelag = false;
		}
		else if (cvar.fakelag_move == 1)//On move
		{
			if (pmove->velocity.Length2D() <= 0)
				fakelag = false;
		}
		else if (cvar.fakelag_move == 2)//In air
		{
			if (g_Local.flHeightorigin <= 0)
				fakelag = false;
		}

		if (fakelag)
		{
			static int choked = 0;
			static int good = 0;

			if (cvar.fakelag_type == 0)//Dynamic
			{
				if (choked < cvar.fakelag_limit)
				{
					bSendpacket(false);

					choked++;

					good = 0;
				}
				else {
					float one = cvar.fakelag_limit / 100;
					float tmp = one * cvar.fakelag_variance;

					good++;

					if (good > tmp) {
						choked = 0;
					}
				}
			}
			else if (cvar.fakelag_type == 1)//Maximum
			{
				choked++;

				if (choked > 0)
					bSendpacket(false);

				if (choked > cvar.fakelag_limit)
					choked = -1;//1 tick valid
			}
			else if (cvar.fakelag_type == 2)//Flucture
			{
				static bool jitter = false;

				if (jitter)
					bSendpacket(false);

				jitter = !jitter;
			}
			else if (cvar.fakelag_type == 3)//Break lag compensation
			{
				Vector velocity = pmove->velocity;
				velocity.z = 0;

				float len = velocity.Length() * frametime;

				if (len < 64.0f && velocity.Length() > 0.05f)
				{
					int need_choke = 64.0f / len;

					if (need_choke > cvar.fakelag_limit)
						need_choke = cvar.fakelag_limit;

					if (choked < need_choke)
					{
						bSendpacket(false);

						choked++;
					}
					else {
						choked = 0;
					}
				}
			}
		}
	}
}
```

`sakura/source/features/rage/fakelag.h`:

```h
#ifndef _FAKELAG_
#define _FAKELAG_

void FakeLag(float frametime, struct usercmd_s* cmd);

#endif
```

`sakura/source/features/rage/norecoil.cpp`:

```cpp
#include "../../client.h"

void V_CalcRefdefRecoil(struct ref_params_s *pparams)
{
	if (IsCurWeaponGun())
	{
		g_Local.vNoRecoilAngle[0] = pparams->punchangle[0] * 2;
		g_Local.vNoRecoilAngle[1] = pparams->punchangle[1] * 2;
		g_Local.vNoRecoilAngle[2] = 0;

		if (cvar.rage_active && cvar.rage_no_recoil)
		{
			pparams->punchangle[0] = 0;
			pparams->punchangle[1] = 0;
			pparams->punchangle[2] = 0;
		}
	}
}

void NoRecoil(struct usercmd_s *cmd)
{
	if (cvar.rage_active && cvar.rage_no_recoil && IsCurWeaponGun() && cmd->buttons & IN_ATTACK && CanAttack())
		cmd->viewangles -= g_Local.vNoRecoilAngle;
}
```

`sakura/source/features/rage/norecoil.h`:

```h
#ifndef _NORECOIL_
#define _NORECOIL_

void V_CalcRefdefRecoil(struct ref_params_s* pparams);
void NoRecoil(struct usercmd_s *cmd);

#endif
```

`sakura/source/features/rage/nospread.cpp`:

```cpp
#include "../../client.h"

unsigned int glSeed = 0;

unsigned int seed_table[256] =
{
	28985U, 27138U, 26457U, 9451U, 17764U, 10909U, 28790U, 8716U, 6361U, 4853U, 17798U, 21977U, 19643U, 20662U, 10834U, 20103,
	27067U, 28634U, 18623U, 25849U, 8576U, 26234U, 23887U, 18228U, 32587U, 4836U, 3306U, 1811U, 3035U, 24559U, 18399U, 315,
	26766U, 907U, 24102U, 12370U, 9674U, 2972U, 10472U, 16492U, 22683U, 11529U, 27968U, 30406U, 13213U, 2319U, 23620U, 16823,
	10013U, 23772U, 21567U, 1251U, 19579U, 20313U, 18241U, 30130U, 8402U, 20807U, 27354U, 7169U, 21211U, 17293U, 5410U, 19223,
	10255U, 22480U, 27388U, 9946U, 15628U, 24389U, 17308U, 2370U, 9530U, 31683U, 25927U, 23567U, 11694U, 26397U, 32602U, 15031,
	18255U, 17582U, 1422U, 28835U, 23607U, 12597U, 20602U, 10138U, 5212U, 1252U, 10074U, 23166U, 19823U, 31667U, 5902U, 24630,
	18948U, 14330U, 14950U, 8939U, 23540U, 21311U, 22428U, 22391U, 3583U, 29004U, 30498U, 18714U, 4278U, 2437U, 22430U, 3439,
	28313U, 23161U, 25396U, 13471U, 19324U, 15287U, 2563U, 18901U, 13103U, 16867U, 9714U, 14322U, 15197U, 26889U, 19372U, 26241,
	31925U, 14640U, 11497U, 8941U, 10056U, 6451U, 28656U, 10737U, 13874U, 17356U, 8281U, 25937U, 1661U, 4850U, 7448U, 12744,
	21826U, 5477U, 10167U, 16705U, 26897U, 8839U, 30947U, 27978U, 27283U, 24685U, 32298U, 3525U, 12398U, 28726U, 9475U, 10208,
	617U, 13467U, 22287U, 2376U, 6097U, 26312U, 2974U, 9114U, 21787U, 28010U, 4725U, 15387U, 3274U, 10762U, 31695U, 17320,
	18324U, 12441U, 16801U, 27376U, 22464U, 7500U, 5666U, 18144U, 15314U, 31914U, 31627U, 6495U, 5226U, 31203U, 2331U, 4668,
	12650U, 18275U, 351U, 7268U, 31319U, 30119U, 7600U, 2905U, 13826U, 11343U, 13053U, 15583U, 30055U, 31093U, 5067U, 761,
	9685U, 11070U, 21369U, 27155U, 3663U, 26542U, 20169U, 12161U, 15411U, 30401U, 7580U, 31784U, 8985U, 29367U, 20989U, 14203,
	29694U, 21167U, 10337U, 1706U, 28578U, 887U, 3373U, 19477U, 14382U, 675U, 7033U, 15111U, 26138U, 12252U, 30996U, 21409,
	25678U, 18555U, 13256U, 23316U, 22407U, 16727U, 991U, 9236U, 5373U, 29402U, 6117U, 15241U, 27715U, 19291U, 19888U, 19847U
};

unsigned int U_Random()
{
	glSeed *= 69069;
	glSeed += seed_table[glSeed & 0xFF] + 1;
	return (glSeed & 0xFFFFFFF);
}

void U_Srand(unsigned int seed)
{
	glSeed = seed_table[seed & 0xFF];
}

int UTIL_SharedRandomLong(unsigned int seed, int low, int high)
{
	unsigned int range = high - low + 1;
	U_Srand((unsigned int)(high + low + seed));
	if (range != 1)
	{
		int rnum = U_Random();
		int offset = rnum % range;
		return (low + offset);
	}

	return low;
}

float UTIL_SharedRandomFloat(unsigned int seed, float low, float high)
{
	unsigned int range = high - low;
	U_Srand((unsigned int)seed + *(unsigned int *)&low + *(unsigned int *)&high);

	U_Random();
	U_Random();

	if (range)
	{
		int tensixrand = U_Random() & 0xFFFFu;
		float offset = float(tensixrand) / 0x10000u;
		return (low + offset * range);
	}

	return low;
}

void GetSpreadXY(unsigned int seed, int future, float *vec, bool simulate)
{
	vec[0] = UTIL_SharedRandomFloat(seed + future, -0.5, 0.5) + UTIL_SharedRandomFloat(seed + 1 + future, -0.5, 0.5);
	vec[1] = UTIL_SharedRandomFloat(seed + 2 + future, -0.5, 0.5) + UTIL_SharedRandomFloat(seed + 3 + future, -0.5, 0.5);

	if (!simulate) {
		vec[0] *= g_Local.weapon.m_flSpread;
		vec[1] *= g_Local.weapon.m_flSpread;
	}
	else {
		float m_flAccuracy, m_flSpread;
		Simulate(m_flAccuracy, m_flSpread);
		vec[0] *= m_flSpread;
		vec[1] *= m_flSpread;
	}
}

void GetSpreadOffset(unsigned int seed, int future, float *inangles, float *outangles)
{
	if (cvar.rage_nospread_method == 0)
	{
		double PitchSine, PitchCosine;
		double CosineInput, CosinePitch, PitchInput;
		double ReciprocalYaw_1, ReciprocalYaw_2, UpVal, Yaw_1;

		QAngle QAdjusterAngles, QAngles, QInputAngles, QInputRoll, QNewAngles, QTestAngles, QOldAngles;

		Vector Dir, Forward, Right, Up;
		Vector ReciprocalVector, InputRight, InputRight2;

		Vector Spread;

		Vector UnRotatedPitch, RotatedPitch;

		GetSpreadXY(seed, future, Spread);

		QAngles = (QAngle)0;

		QAngles.AngleVectors(&Forward, &Right, &Up);

		Dir = Forward + (-Spread[0] * Right) + (-Spread[1] * Up);

		Dir.Normalize();

		QAngles.Init(inangles);

		QOldAngles = QAngles;

		QAngles = Dir.ToEulerAngles();

		QAngles.Normalize();

		QAngles.AngleVectors(&Forward, &Right, &Up);

		UpVal = Up[2];

		QAngles = QOldAngles;

		CosineInput = QAngles[0] * (M_PI * 2 / 360);

		CosinePitch = cos(CosineInput);

		if (CosinePitch != 0)
		{
			Yaw_1 = 1 / CosinePitch;
		}
		else
		{
			Yaw_1 = 0;
		}

		Yaw_1 *= Dir[1];

		InputRight[1] = Yaw_1;

		if (Yaw_1 >= 1 || Yaw_1 <= -1)
		{
			InputRight[1] = 1 / Yaw_1;

			InputRight[0] = 0;
		}
		else
		{
			InputRight[0] = sqrt((1 - (InputRight[1] * InputRight[1])));
		}

		InputRight[2] = 0;

		QAdjusterAngles[1] = (RAD2DEG(atan2(InputRight[1], InputRight[0])));

		QAdjusterAngles.Normalize();

		InputRight2[1] = Dir[1];

		if (Dir[1] >= 1 || Dir[1] <= -1)
		{
			InputRight2[1] = 1 / Dir[1];

			InputRight2[0] = 0;
		}
		else
		{
			InputRight2[0] = sqrt((1 - (InputRight2[1] * InputRight2[1])));
		}

		if (InputRight[0] != 0)
		{
			ReciprocalYaw_1 = InputRight[1] / InputRight[0];
		}
		else
		{
			ReciprocalYaw_1 = 0;
		}

		if (InputRight2[0] != 0)
		{
			ReciprocalYaw_2 = InputRight2[1] / InputRight2[0];
		}
		else
		{
			ReciprocalYaw_2 = 0;
		}

		PitchInput = 0;

		if (QAngles[0] != 0)
		{
			if (ReciprocalYaw_1 != 0 && ReciprocalYaw_2 != 0)
			{
				PitchInput = 1;

				if (abs(ReciprocalYaw_1) < abs(ReciprocalYaw_2))
				{
					PitchInput = ReciprocalYaw_1 / ReciprocalYaw_2;
				}
				else if (abs(ReciprocalYaw_2) < abs(ReciprocalYaw_1))
				{
					PitchInput = ReciprocalYaw_2 / ReciprocalYaw_1;
				}
			}
		}
		else
		{
			PitchInput = 1;
		}

		QInputAngles = (QAngle)0;

		if (PitchInput > 1 && PitchInput < -1)
		{
			PitchCosine = PitchInput;
			PitchSine = sqrt(1 - PitchInput * PitchInput);

			UnRotatedPitch[0] = PitchSine;
			UnRotatedPitch[1] = PitchCosine;
			UnRotatedPitch[2] = 0;

			double TempPitch = QAngles[0];

			if (TempPitch < 0)
			{
				TempPitch = -TempPitch;
			}

			TempPitch = ((45 - TempPitch) * 2);

			RotatedPitch.VectorRotate(UnRotatedPitch, QAngle(0, TempPitch, 0));

			if (QAngles[0] < 0)
			{
				QInputAngles[0] = RAD2DEG(atan2(RotatedPitch[1], RotatedPitch[0]));
			}
			else
			{
				QInputAngles[0] = RAD2DEG(atan2(-RotatedPitch[1], RotatedPitch[0]));
			}
		}

		QInputAngles.Normalize();

		QInputAngles.AngleVectors(&Forward, &Right, &Up);

		Dir = Forward + (Spread[0] * Right) + (Spread[1] * Up);

		Dir.Normalize();

		QAdjusterAngles[0] = QAngles[0] + (RAD2DEG(atan2(Dir[2], Dir[0])));

		QAdjusterAngles.Normalize();

		QNewAngles = QOldAngles;

		QNewAngles[0] = QAdjusterAngles[0];
		QNewAngles[1] += QAdjusterAngles[1];
		QNewAngles[2] = 0;

		QNewAngles.Normalize();

		for (unsigned int Iterator = 0; Iterator < 5; Iterator++)
		{
			QNewAngles.AngleVectors(&Forward, &Right, &Up);

			Dir = Forward + (Spread[0] * Right) + (Spread[1] * Up);

			Dir.Normalize();

			QTestAngles = Dir.ToEulerAngles();

			QTestAngles.Normalize();

			QNewAngles[0] += (QAngles[0] - QTestAngles[0]);
			QNewAngles[1] += (QAngles[1] - QTestAngles[1]);

			QNewAngles.Normalize();
		}

		outangles[0] = QNewAngles[0];
		outangles[1] = QNewAngles[1];
		outangles[2] = QNewAngles[2];
	}
	else
	{
		Vector vecForward, vecRight, vecUp, vecDir, vecRandom;

		QAngle QAngles, QNewAngles, QTempAngles;

		GetSpreadXY(seed, future, vecRandom);

		QAngles = inangles;

		QTempAngles = (QAngle)0;

		QTempAngles.AngleVectors(&vecForward, &vecRight, &vecUp);

		vecDir = vecForward + (vecRight * vecRandom[0]) + (vecUp * vecRandom[1]);

		vecDir.Normalize();

		QNewAngles = vecDir.ToEulerAngles();

		QNewAngles[0] -= QAngles[0];

		QNewAngles.Normalize();

		QNewAngles.AngleVectorsTranspose(&vecForward, &vecRight, &vecUp);

		vecDir = vecForward;

		QNewAngles = vecDir.ToEulerAngles(&vecUp);

		QNewAngles.Normalize();

		QNewAngles[1] += QAngles[1];

		QNewAngles.Normalize();

		outangles[0] = QNewAngles[0];
		outangles[1] = QNewAngles[1];
		outangles[2] = 0;
	}
}

float forwardmove, sidemove, upmove;//backup for fixmove
Vector vViewForward, vViewRight, vViewUp, vAimForward, vAimRight, vAimUp;//backup for fixmove

void FixMoveStart(struct usercmd_s *cmd)
{
	forwardmove = cmd->forwardmove;
	sidemove = cmd->sidemove;
	upmove = cmd->upmove;

	if (pmove->movetype == MOVETYPE_WALK)
		g_Engine.pfnAngleVectors(Vector(0.0f, cmd->viewangles.y, 0.0f), vViewForward, vViewRight, vViewUp);
	else
		g_Engine.pfnAngleVectors(cmd->viewangles, vViewForward, vViewRight, vViewUp);
}

void NormalizeAngles(float *angles)
{
	for (unsigned int i = 0; i < 3; ++i)
	{
		float flRevolutions = angles[i] / 360;

		if (angles[i] > 180 || angles[i] < -180)
		{
			if (flRevolutions < 0)
			{
				flRevolutions = -flRevolutions;
			}

			flRevolutions = round(flRevolutions);

			if (angles[i] < 0)
			{
				angles[i] = (angles[i] + 360 * flRevolutions);
			}
			else
			{
				angles[i] = (angles[i] - 360 * flRevolutions);
			}
		}
	}
}

void VectorAngles(const float *forward, float *angles)
{
	float tmp, yaw, pitch;

	if (forward[1] == 0 && forward[0] == 0)
	{
		yaw = 0;
		if (forward[2] > 0)
			pitch = 270;
		else
			pitch = 90;
	}
	else
	{
		yaw = (atan2(forward[1], forward[0]) * 180.0 / M_PI);
		if (yaw < 0)
			yaw += 360;

		tmp = sqrt(forward[0] * forward[0] + forward[1] * forward[1]);
		pitch = (atan2(-forward[2], tmp) * 180.0 / M_PI);
		if (pitch < 0)
			pitch += 360;
	}

	angles[0] = pitch;
	angles[1] = yaw;
	angles[2] = 0;

	while (angles[0] < -89) { angles[0] += 180; angles[1] += 180; }
	while (angles[0] > 89) { angles[0] -= 180; angles[1] += 180; }
	while (angles[1] < -180) { angles[1] += 360; }
	while (angles[1] > 180) { angles[1] -= 360; }
}

void FixMoveEnd(struct usercmd_s *cmd)
{
	NormalizeAngles(cmd->viewangles);

	if (pmove->movetype == MOVETYPE_WALK)
		g_Engine.pfnAngleVectors(Vector(0.0f, cmd->viewangles.y, 0.0f), vAimForward, vAimRight, vAimUp);
	else
		g_Engine.pfnAngleVectors(cmd->viewangles, vAimForward, vAimRight, vAimUp);

	Vector forwardmove_normalized = forwardmove * vViewForward;
	Vector sidemove_normalized = sidemove * vViewRight;
	Vector upmove_normalized = upmove * vViewUp;

	cmd->forwardmove = forwardmove_normalized.Dot(vAimForward) + sidemove_normalized.Dot(vAimForward) + upmove_normalized.Dot(vAimForward);
	cmd->sidemove = forwardmove_normalized.Dot(vAimRight) + sidemove_normalized.Dot(vAimRight) + upmove_normalized.Dot(vAimRight);
	cmd->upmove = forwardmove_normalized.Dot(vAimUp) + sidemove_normalized.Dot(vAimUp) + upmove_normalized.Dot(vAimUp);

	Vector vMove(cmd->forwardmove, cmd->sidemove, cmd->upmove);
	float flSpeed = sqrt(vMove.x * vMove.x + vMove.y * vMove.y), flYaw;
	Vector vecMove, vecRealView(cmd->viewangles);
	VectorAngles(vMove, vecMove);
	flYaw = (cmd->viewangles.y - vecRealView.y + vecMove.y) * M_PI / 180.0;

	cmd->forwardmove = cos(flYaw) * flSpeed;

	if (cmd->viewangles.x >= 90 || cmd->viewangles.x <= -90)
		cmd->forwardmove *= -1;

	cmd->sidemove = sin(flYaw) * flSpeed;
}

void MakeAngle(float *angles, struct usercmd_s *cmd)
{
	FixMoveStart(cmd);

	cmd->viewangles[0] = angles[0];
	cmd->viewangles[1] = angles[1];
	cmd->viewangles[2] = angles[2];

	FixMoveEnd(cmd);
}

void NoSpread(usercmd_s *cmd)
{
	if (IsCurWeaponGun() && cmd->buttons & IN_ATTACK && CanAttack())
	{
		Vector vAngles;
		GetSpreadOffset(g_Local.weapon.random_seed, 1, cmd->viewangles, vAngles);
		g_Local.vNoSpreadAngle = cmd->viewangles - vAngles;

		if (cvar.rage_active && cvar.rage_no_spread)
			MakeAngle(vAngles, cmd);
	}
}
```

`sakura/source/features/rage/nospread.h`:

```h
#ifndef _NORSPREAD_
#define _NORSPREAD_

void GetSpreadXY(unsigned int seed, int future, float* vec, bool simulate = false);
void GetSpreadOffset(unsigned int seed, int future, float* inangles, float* outangles);
void VectorAngles(const float* forward, float* angles);
void MakeAngle(float* angles, struct usercmd_s* cmd);
void FixMoveStart(struct usercmd_s* cmd);
void FixMoveEnd(struct usercmd_s* cmd);
void NoSpread(usercmd_s *cmd);

#endif
```

`sakura/source/features/rage/raim.cpp`:

```cpp
#include "../../client.h"

int		Sakura::Aimbot::Rage::iTargetRage;
int		Sakura::Aimbot::Rage::iHitboxRage;
bool	Sakura::Aimbot::Rage::RageKeyStatus;
Vector	Sakura::Aimbot::Rage::vAimOriginRage;

void Sakura::Aimbot::Rage::Target(playeraim_t Aim, float& m_flBestDist, float& m_flBestFOV, int hitbox)
{
	if (IsCurWeaponKnife())
	{
		float fDistance = (Aim.PlayerAimHitbox[hitbox].Hitbox - (pmove->origin + pmove->view_ofs)).Length();
		if (fDistance < m_flBestDist)
		{
			m_flBestDist = Aim.PlayerAimHitbox[hitbox].Hitbox.Distance(pmove->origin + pmove->view_ofs);
			iTargetRage = Aim.index;
			vAimOriginRage = Aim.PlayerAimHitbox[hitbox].Hitbox;
			iHitboxRage = hitbox;
		}
	}
	else
	{
		if (cvar.rage_target_selection == 0)
		{
			if (Aim.PlayerAimHitbox[hitbox].HitboxFOV < m_flBestFOV)
			{
				m_flBestFOV = Aim.PlayerAimHitbox[hitbox].HitboxFOV;
				iTargetRage = Aim.index;
				vAimOriginRage = Aim.PlayerAimHitbox[hitbox].Hitbox;
				iHitboxRage = hitbox;
			}
		}
		if (cvar.rage_target_selection == 1)
		{
			float fDistance = (Aim.PlayerAimHitbox[hitbox].Hitbox - (pmove->origin + pmove->view_ofs)).Length();
			if (fDistance < m_flBestDist)
			{
				m_flBestDist = fDistance;
				iTargetRage = Aim.index;
				vAimOriginRage = Aim.PlayerAimHitbox[hitbox].Hitbox;
				iHitboxRage = hitbox;
			}
		}
		if (cvar.rage_target_selection == 2)
		{
			if (Aim.PlayerAimHitbox[hitbox].HitboxFOV < m_flBestFOV)
			{
				float fDistance = (Aim.PlayerAimHitbox[hitbox].Hitbox - (pmove->origin + pmove->view_ofs)).Length();
				if (fDistance < m_flBestDist)
				{
					m_flBestFOV = Aim.PlayerAimHitbox[hitbox].HitboxFOV;
					m_flBestDist = fDistance;
					iTargetRage = Aim.index;
					vAimOriginRage = Aim.PlayerAimHitbox[hitbox].Hitbox;
					iHitboxRage = hitbox;
				}
			}
		}
	}
}

void Sakura::Aimbot::Rage::SelectHitbox(playeraim_t Aim, float& m_flBestDist, float& m_flBestFOV)
{
	pmtrace_t tr;

	g_Engine.pEventAPI->EV_SetTraceHull(2);

	Vector vEye = pmove->origin + pmove->view_ofs;

	if (cvar.bypass_trace_rage)
		g_Engine.pEventAPI->EV_PlayerTrace(vEye, Aim.PlayerAimHitbox[cvar.rage[g_Local.weapon.m_iWeaponID].rage_hitbox].Hitbox, PM_WORLD_ONLY, -1, &tr);
	else
		g_Engine.pEventAPI->EV_PlayerTrace(vEye, Aim.PlayerAimHitbox[cvar.rage[g_Local.weapon.m_iWeaponID].rage_hitbox].Hitbox, PM_GLASS_IGNORE, -1, &tr);

	int detect = g_Engine.pEventAPI->EV_IndexFromTrace(&tr);

	if ((cvar.bypass_trace_rage && tr.fraction == 1 && !detect) || (!cvar.bypass_trace_rage && detect == Aim.index))
	{
		if (Aim.PlayerAimHitbox[cvar.rage[g_Local.weapon.m_iWeaponID].rage_hitbox].HitboxFOV <= cvar.rage_fov)
			Target(Aim, m_flBestDist, m_flBestFOV, cvar.rage[g_Local.weapon.m_iWeaponID].rage_hitbox);
	}
	else
	{
		int iOriginalPenetration = CurPenetration();

		if (iOriginalPenetration && cvar.rage_wall)
		{
			int iDamage = CurDamage();
			int iBulletType = CurBulletType();
			float flDistance = CurDistance();
			float flRangeModifier = CurWallPierce();

			int iCurrentDamage = Sakura::Aimbot::FireBullets(vEye, Aim.PlayerAimHitbox[cvar.rage[g_Local.weapon.m_iWeaponID].rage_hitbox].Hitbox, flDistance, iOriginalPenetration, iBulletType, iDamage, flRangeModifier);

			if (iCurrentDamage > 0)
			{
				if (Aim.PlayerAimHitbox[cvar.rage[g_Local.weapon.m_iWeaponID].rage_hitbox].HitboxFOV <= cvar.rage_fov)
					Target(Aim, m_flBestDist, m_flBestFOV, cvar.rage[g_Local.weapon.m_iWeaponID].rage_hitbox);
			}
		}
	}
}

void Sakura::Aimbot::Rage::Aim(usercmd_s* cmd)
{
	if (IsCurWeaponNonAttack())
		return;

	if (cvar.rage_tapping_mode && (g_Local.vPunchangle.Length2D() > 0.f || g_Local.weapon.m_iShotsFired))
		return;

	float bestFOV = 180;
	float bestDistance = 8192;

	for (playeraim_t Aim : PlayerAim)
	{
		if (IdHook::FirstKillPlayer[Aim.index] == IDHOOK_PLAYER_ON || cvar.aim_id_mode == IDHOOK_ATTACK_ALL)
		{
			if (!Sakura::Player::IsAlive(Aim.index))
				continue;

			if (!cvar.rage_team && g_Player[Aim.index].iTeam == g_Local.iTeam)
				continue;

			if (!cvar.rage_shield_attack && (Aim.sequence == 97 || Aim.sequence == 98))
				continue;

			SelectHitbox(Aim, bestDistance, bestFOV);
		}
	}

	if (!iTargetRage && cvar.aim_id_mode != IDHOOK_ATTACK_ON)
	{
		for (playeraim_t Aim : PlayerAim)
		{
			if (IdHook::FirstKillPlayer[Aim.index] < IDHOOK_PLAYER_OFF)
			{
				if (!Sakura::Player::IsAlive(Aim.index))
					continue;

				if (!cvar.rage_team && g_Player[Aim.index].iTeam == g_Local.iTeam)
					continue;

				if (!cvar.rage_shield_attack && (Aim.sequence == 97 || Aim.sequence == 98))
					continue;

				SelectHitbox(Aim, bestDistance, bestFOV);
			}
		}
	}

	if (iTargetRage)
	{
		QAngle QAimAngles;

		Vector vEye = pmove->origin + pmove->view_ofs;

		VectorAngles(vAimOriginRage - vEye, QAimAngles);

		static DWORD delay = 0;

		static int tickcount = 0;

		if (cvar.route_auto && cvar.route_mode)
		{
			if (g_Local.weapon.m_iClip)
			{
				if (IsCurWeaponKnife())
				{
					if (cvar.rage_knife_attack == 0)
						cmd->buttons |= IN_ATTACK;
					else if (cvar.rage_knife_attack == 1)
						cmd->buttons |= IN_ATTACK2;
				}
				else
					cmd->buttons |= IN_ATTACK;

				cmd->viewangles = QAimAngles;
				g_Engine.SetViewAngles(QAimAngles);
			}
		}
		else
		{
			if (cvar.rage_always_fire)
			{
				if (cmd->buttons & IN_ATTACK || cmd->buttons & IN_ATTACK2 && IsCurWeaponKnife())
				{
					if (cvar.rage_perfect_silent)
					{
						MakeAngle(QAimAngles, cmd);
						bSendpacket(false);
					}
					else if (cvar.rage_silent)
					{
						MakeAngle(QAimAngles, cmd);
					}
					else
					{
						cmd->viewangles = QAimAngles;
						g_Engine.SetViewAngles(QAimAngles);
					}
				}
			}
			else if (CanAttack())
			{
				if (GetTickCount() - delay > cvar.rage[g_Local.weapon.m_iWeaponID].rage_delay_shot)
				{
					if (cvar.rage_auto_fire || RageKeyStatus)
					{
						if (IsCurWeaponKnife())
						{
							if (cvar.rage_knife_attack == 0)
								cmd->buttons |= IN_ATTACK;
							else if (cvar.rage_knife_attack == 1)
								cmd->buttons |= IN_ATTACK2;
						}
						else
						{
							cmd->buttons |= IN_ATTACK;
							if (cmd->buttons & IN_ATTACK)tickcount++;
							static int random = rand() % (int)cvar.rage[g_Local.weapon.m_iWeaponID].rage_random_max + 1;
							if (tickcount >= (!cvar.rage[g_Local.weapon.m_iWeaponID].rage_shot_type ? cvar.rage[g_Local.weapon.m_iWeaponID].rage_shot_count : random))
							{
								random = rand() % (int)cvar.rage[g_Local.weapon.m_iWeaponID].rage_random_max + 1;
								delay = GetTickCount();
								tickcount = 0;
							}
						}
					}
					if (cmd->buttons & IN_ATTACK || cmd->buttons & IN_ATTACK2 && IsCurWeaponKnife())
					{
						if (cvar.rage_perfect_silent)
						{
							MakeAngle(QAimAngles, cmd);
							bSendpacket(false);
						}
						else if (cvar.rage_silent)
						{
							MakeAngle(QAimAngles, cmd);
						}
						else
						{
							cmd->viewangles = QAimAngles;
							g_Engine.SetViewAngles(QAimAngles);
						}
					}
				}
			}
			else
			{
				if (IsCurWeaponKnife())
				{
					if (cvar.rage_knife_attack == 0)
						cmd->buttons &= ~IN_ATTACK;
					else if (cvar.rage_knife_attack == 1)
						cmd->buttons &= ~IN_ATTACK2;
				}
				else
					cmd->buttons &= ~IN_ATTACK;
			}
		}
	}
}

void Sakura::Aimbot::Rage::Draw()
{
	if (IsCurWeaponNonAttack() || !Sakura::Player::Local::IsAlive() || !cvar.rage_draw_aim || !iTargetRage)
		return;

	for (playeraim_t Aim : PlayerAim)
	{
		if (Aim.index != iTargetRage)
			continue;

		float CalcAnglesMin[2], CalcAnglesMax[2];
		for (unsigned int i = 0; i < 12; ++i)
		{
			if (WorldToScreen(Aim.PlayerAimHitbox[iHitboxRage].HitboxMulti[SkeletonHitboxMatrix[i][0]], CalcAnglesMin) && WorldToScreen(Aim.PlayerAimHitbox[iHitboxRage].HitboxMulti[SkeletonHitboxMatrix[i][1]], CalcAnglesMax))
				ImGui::GetCurrentWindow()->DrawList->AddLine({ IM_ROUND(CalcAnglesMin[0]), IM_ROUND(CalcAnglesMin[1]) }, { IM_ROUND(CalcAnglesMax[0]), IM_ROUND(CalcAnglesMax[1]) }, Sakura::Colors::Green());
		}
	}
}
```

`sakura/source/features/rage/raim.h`:

```h
#ifndef _RAIM_
#define _RAIM_

namespace Sakura
{
	namespace Aimbot
	{
		namespace Rage
		{
			extern int		iTargetRage;
			extern int		iHitboxRage;
			extern bool		RageKeyStatus;
			extern Vector	vAimOriginRage;

			void Target(playeraim_t Aim, float& m_flBestDist, float& m_flBestFOV, int hitbox);
			void SelectHitbox(playeraim_t Aim, float& m_flBestDist, float& m_flBestFOV);
			void Aim(usercmd_s* cmd);
			void Draw();
		};
	};
};

#endif
```

`sakura/source/features/sound/killsound.cpp`:

```cpp
#include "../../client.h"

DWORD Sakura::Sound::MonsterKill;
DWORD Sakura::Sound::TripleKill;
DWORD Sakura::Sound::DoubleKill;
DWORD Sakura::Sound::Headshot;

DWORD Sakura::Sound::dkTimer = 0;
DWORD Sakura::Sound::tkTimer = 0;
DWORD Sakura::Sound::mkTimer = 0;

void Sakura::Sound::KillSound(const int headshot)
{
	if (!cvar.radio_kill_sound)
		return;

	if (GetTickCount() - mkTimer < 1000)
	{
		BASS_ChannelSetAttribute(Sakura::Sound::MonsterKill, BASS_ATTRIB_VOL, cvar.radio_kill_volume / 100.f);
		BASS_ChannelPlay(Sakura::Sound::MonsterKill, true);
		mkTimer = GetTickCount();
	}

	if (GetTickCount() - tkTimer < 1000 && GetTickCount() - mkTimer > 1000)
	{
		BASS_ChannelSetAttribute(Sakura::Sound::TripleKill, BASS_ATTRIB_VOL, cvar.radio_kill_volume / 100.f);
		BASS_ChannelPlay(Sakura::Sound::TripleKill, true);
		mkTimer = GetTickCount();
	}

	if (GetTickCount() - dkTimer < 1000 && GetTickCount() - tkTimer > 1000)
	{
		BASS_ChannelSetAttribute(Sakura::Sound::DoubleKill, BASS_ATTRIB_VOL, cvar.radio_kill_volume / 100.f);
		BASS_ChannelPlay(Sakura::Sound::DoubleKill, true);
		tkTimer = GetTickCount();
	}

	if (headshot && (GetTickCount() - dkTimer > 1000))
	{
		BASS_ChannelSetAttribute(Sakura::Sound::Headshot, BASS_ATTRIB_VOL, cvar.radio_kill_volume / 100.f);
		BASS_ChannelPlay(Sakura::Sound::Headshot, true);
		dkTimer = GetTickCount();
	}

	if (GetTickCount() - dkTimer > 1000)
	{
		dkTimer = GetTickCount();
	}
}
```

`sakura/source/features/sound/killsound.h`:

```h
#ifndef _KILLSOUND_
#define _KILLSOUND_

namespace Sakura
{
	namespace Sound
	{
		extern HSTREAM MonsterKill;
		extern HSTREAM TripleKill;
		extern HSTREAM DoubleKill;
		extern HSTREAM Headshot;

		extern DWORD dkTimer;
		extern DWORD tkTimer;
		extern DWORD mkTimer;

		void KillSound(const int headshot);
	};
};

#endif
```

`sakura/source/features/sound/sound.cpp`:

```cpp
#include "../../client.h"

bool Sakura::Sound::soundInit = false;

void Sakura::Sound::Init()
{
	BASS::bass_lib_handle = BASS::bass_lib.LoadFromMemory(bass_dll_image, sizeof(bass_dll_image));

	if (soundInit)
		return;

	if (!BASS_Init(-1, 44100, 0, 0, NULL))
	{
		Sakura::Log::File(/*Failed to init sound: %i*/XorStr<0x51, 25, 0x975AAABD>("\x17\x33\x3A\x38\x30\x32\x77\x2C\x36\x7A\x32\x32\x34\x2A\x7F\x13\x0E\x17\x0D\x00\x5F\x46\x42\x01" + 0x975AAABD).s, BASS_ErrorGetCode());
		soundInit = true;
		return;
	}

	char filename[256];

	sprintf(filename, "%s%s", Sakura::CheatDir, /*assets/sounds/headshot.wav*/XorStr<0x4A, 27, 0x2E6ED78E>("\x2B\x38\x3F\x28\x3A\x3C\x7F\x22\x3D\x26\x3A\x31\x25\x78\x30\x3C\x3B\x3F\x2F\x35\x31\x2B\x4E\x16\x03\x15" + 0x2E6ED78E).s);
	Sakura::Sound::Headshot = BASS_StreamCreateFile(false, filename, 0, 0, 0);

	sprintf(filename, "%s%s", Sakura::CheatDir, /*assets/sounds/doublekill.wav*/XorStr<0xCC, 29, 0xDF701688>("\xAD\xBE\xBD\xAA\xA4\xA2\xFD\xA0\xBB\xA0\xB8\xB3\xAB\xF6\xBE\xB4\xA9\xBF\xB2\xBA\x8B\x88\x8E\x8F\xCA\x92\x87\x91" + 0xDF701688).s);
	Sakura::Sound::DoubleKill = BASS_StreamCreateFile(false, filename, 0, 0, 0);

	sprintf(filename, "%s%s", Sakura::CheatDir, /*assets/sounds/triplekill.wav*/XorStr<0x2C, 29, 0x566AD073>("\x4D\x5E\x5D\x4A\x44\x42\x1D\x40\x5B\x40\x58\x53\x4B\x16\x4E\x49\x55\x4D\x52\x5A\x2B\x28\x2E\x2F\x6A\x32\x27\x31" + 0x566AD073).s);
	Sakura::Sound::TripleKill = BASS_StreamCreateFile(false, filename, 0, 0, 0);

	sprintf(filename, "%s%s", Sakura::CheatDir, /*assets/sounds/monsterkill.wav*/XorStr<0x00, 30, 0x4D1B799A>("\x61\x72\x71\x66\x70\x76\x29\x74\x67\x7C\x64\x6F\x7F\x22\x63\x60\x7E\x62\x66\x76\x66\x7E\x7F\x7B\x74\x37\x6D\x7A\x6A" + 0x4D1B799A).s);
	Sakura::Sound::MonsterKill = BASS_StreamCreateFile(false, filename, 0, 0, 0);

	for (size_t i = 0; i < Sakura::Lua::scripts.size(); ++i)
	{
		auto& script = Sakura::Lua::scripts[i];

		if (!script.HasCallback(Sakura::Lua::SAKURA_CALLBACK_TYPE::SAKURA_CALLBACK_AT_INIT_BASS))
			continue;

		auto& callbacks = script.GetCallbacks(Sakura::Lua::SAKURA_CALLBACK_TYPE::SAKURA_CALLBACK_AT_INIT_BASS);
		for (const auto& callback : callbacks)
		{
			try
			{
				callback();
			}
			catch (luabridge::LuaException const& error)
			{
				if (script.GetState())
				{
					Sakura::Lua::Error("Error has occured in the lua \"On Init Sound\" script: %s", error.what());
					script.RemoveAllCallbacks();
				}
			}
		}
	}

	soundInit = true;
}

void Sakura::Sound::Free()
{
	BASS_StreamFree(Headshot);
	BASS_StreamFree(DoubleKill);
	BASS_StreamFree(TripleKill);
	BASS_StreamFree(MonsterKill);

	if (Sakura::Lua::Sounds.size() > 0)
	{
		for (auto& sound : Sakura::Lua::Sounds)
		{
			BASS_SampleFree(sound);
		}

		Sakura::Lua::Sounds.clear();
	}

	BASS_Free();
}

void Sakura::Sound::ReInit()
{
	Free();
	soundInit = false;
	Init();
}
```

`sakura/source/features/sound/sound.h`:

```h
#ifndef _BASS_
#define _BASS_

namespace Sakura
{
	namespace Sound
	{
		extern bool soundInit;

		void Init();
		void Free();
		void ReInit();
	};
};

//void InitBass();

#endif

```

`sakura/source/features/sound/soundesp.cpp`:

```cpp
#include "../../client.h"

std::deque<player_sound_no_index_t> Sound_No_Index;
std::deque<player_sound_index_t> Sound_Index;

float Sakura::Esp::realDynamicSoundVolume;

void Sakura::Esp::ChangeDynamicSoundVolume(float newVolume)
{
	realDynamicSoundVolume = newVolume;
}

void Sakura::Esp::DynamicSound(int entid, DWORD entchannel, char* szSoundFile, float* fOrigin, float fVolume, float fAttenuation, int iTimeOff, int iPitch)
{
	realDynamicSoundVolume = fVolume;

	if (!szSoundFile)
		return;

	if (!fOrigin)
		return;

	if (cvar.misc_fire_sounds && strstr(szSoundFile, "weapons"))
	{
		realDynamicSoundVolume = cvar.misc_fire_sounds_volume / 100.f;
		iPitch = cvar.misc_fire_sounds_pitch;
	}

	if (strstr(szSoundFile, "player") &&
		!strstr(szSoundFile, "pl_shell") &&
		!strstr(szSoundFile, "ric") &&
		!strstr(szSoundFile, "glass") &&
		!strstr(szSoundFile, "debris"))
	{
		if (entid > 0 && entid < 33)
		{
			int damage = 0;

			if (strstr(szSoundFile, "bhit_helmet"))
				damage = g_Engine.pfnRandomLong(65, 70);

			if (strstr(szSoundFile, "bhit_kevlar"))
				damage = g_Engine.pfnRandomLong(15, 20);

			if (strstr(szSoundFile, "bhit_flesh"))
				damage = g_Engine.pfnRandomLong(25, 30);

			if (strstr(szSoundFile, "headshot"))
				damage = g_Engine.pfnRandomLong(75, 80);

			if (damage <= g_Player[entid].iHealth)
				g_Player[entid].iHealth -= damage;

			if (strstr(szSoundFile, "die") || strstr(szSoundFile, "death"))
				g_Player[entid].iHealth = 100;

			if (cvar.visual_sound_steps)
			{
				player_sound_index_t sound_index;
				sound_index.index = entid;
				sound_index.origin = fOrigin;
				sound_index.timestamp = GetTickCount();
				Sound_Index.push_back(sound_index);
			}
		}
		else if (cvar.visual_sound_steps)
		{
			player_sound_no_index_t sound_no_index;
			sound_no_index.origin = fOrigin;
			sound_no_index.timestamp = GetTickCount();
			Sound_No_Index.push_back(sound_no_index);
		}
	}

	for (size_t i = 0; i < Sakura::Lua::scripts.size(); ++i)
	{
		auto& script = Sakura::Lua::scripts[i];

		if (!script.HasCallback(Sakura::Lua::SAKURA_CALLBACK_TYPE::SAKURA_CALLBACK_AT_DYNAMICSOUND))
			continue;

		auto& callbacks = script.GetCallbacks(Sakura::Lua::SAKURA_CALLBACK_TYPE::SAKURA_CALLBACK_AT_DYNAMICSOUND);
		for (const auto& callback : callbacks)
		{
			try
			{
				Vector origin;
				origin.x = fOrigin[0];
				origin.x = fOrigin[1];
				origin.x = fOrigin[2];

				callback(entid, std::string(szSoundFile), realDynamicSoundVolume, origin);
			}
			catch (luabridge::LuaException const& error)
			{
				if (script.GetState())
				{
					Sakura::Lua::Error("Error has occured in the lua \"Dynamic Sound\" script: %s", error.what());
					script.RemoveAllCallbacks();
				}
			}
		}
	}

	PreS_DynamicSound_s(entid, entchannel, szSoundFile, fOrigin, realDynamicSoundVolume, fAttenuation, iTimeOff, iPitch);
}

void Sakura::Esp::DrawSoundIndex()
{
	if (!cvar.visual_sound_steps)
		return;

	for (player_sound_index_t sound_index : Sound_Index)
	{
		cl_entity_s* ent = g_Engine.GetEntityByIndex(sound_index.index);

		if (!ent)
			continue;

		if (cvar.visual_idhook_only && IdHook::FirstKillPlayer[sound_index.index] != 1)
			continue;

		if (!cvar.visual_visual_team && g_Player[sound_index.index].iTeam == g_Local.iTeam || ent->index == pmove->player_index + 1)
			continue;

		ImRGBA soundEspColor = Sakura::Colors::GetCustomizedTeamColor(sound_index.index, cvar.visual_sound_steps_color_tt, cvar.visual_sound_steps_color_ct);

		float step = M_PI * 2.0f / cvar.visual_sound_steps_segments;
		float radius = cvar.visual_sound_steps_radius * (1200 - (GetTickCount() - sound_index.timestamp)) / 1200;
		Vector position = Vector(sound_index.origin.x, sound_index.origin.y, sound_index.origin.z - 36);
		for (float i = 0; i < (IM_PI * 2.0f); i += step)
		{
			Vector vPointStart(radius * cosf(i) + position.x, radius * sinf(i) + position.y, position.z);
			Vector vPointEnd(radius * cosf(i + step) + position.x, radius * sinf(i + step) + position.y, position.z);
			float vStart[2], vEnd[2];

			if (WorldToScreen(vPointStart, vStart) && WorldToScreen(vPointEnd, vEnd))
			{
				ImGui::GetCurrentWindow()->DrawList->AddLine({ IM_ROUND(vStart[0]), IM_ROUND(vStart[1]) }, { IM_ROUND(vEnd[0]), IM_ROUND(vEnd[1]) }, ImColor(soundEspColor.r, soundEspColor.g, soundEspColor.b, soundEspColor.a), cvar.visual_sound_steps_segment_thickness);
			}
		}

		if (ent->curstate.messagenum == g_Engine.GetEntityByIndex(pmove->player_index + 1)->curstate.messagenum)
			continue;

		if (GetTickCount() - sound_index.timestamp > 300)
			continue;

		Vector vPointTop = Vector(sound_index.origin.x, sound_index.origin.y, sound_index.origin.z + 10);
		Vector vPointBot = Vector(sound_index.origin.x, sound_index.origin.y, sound_index.origin.z - 10);

		float vTop[2], vBot[2];
		if (WorldToScreen(vPointTop, vTop) && WorldToScreen(vPointBot, vBot))
		{
			float h = vTop[1] - vBot[1]; 
			float w = h;
			float x = vTop[0] - (w / 2);
			float y = vTop[1];

			Player::DrawBox(x, y, w, h, soundEspColor);
			Player::DrawHealth(sound_index.index, x, y, h);
			Player::DrawName(sound_index.index, x + (w / 2), y);
			Player::DrawVip(sound_index.index, x + w, y);
		}
	}
}

void Sakura::Esp::DrawSoundNoIndex()
{
	if (!cvar.visual_sound_steps)
		return;

	ImRGBA soundStepsColor = Sakura::Colors::GetCustomizedColor(cvar.visual_sound_steps_color);

	for (player_sound_no_index_t sound_no_index : Sound_No_Index)
	{
		float step = IM_PI * 2.0f / cvar.visual_sound_steps_segments;
		float radius = cvar.visual_sound_steps_radius * (1200 - (GetTickCount() - sound_no_index.timestamp)) / 1200;
		Vector position = Vector(sound_no_index.origin.x, sound_no_index.origin.y, sound_no_index.origin.z - 36);
		for (float i = 0; i < (IM_PI * 2.0f); i += step)
		{
			Vector vPointStart(radius * cosf(i) + position.x, radius * sinf(i) + position.y, position.z);
			Vector vPointEnd(radius * cosf(i + step) + position.x, radius * sinf(i + step) + position.y, position.z);
			float vStart[2], vEnd[2];
			if (WorldToScreen(vPointStart, vStart) && WorldToScreen(vPointEnd, vEnd))
				ImGui::GetCurrentWindow()->DrawList->AddLine({ IM_ROUND(vStart[0]), IM_ROUND(vStart[1]) }, { IM_ROUND(vEnd[0]), IM_ROUND(vEnd[1]) }, ImColor(soundStepsColor.r, soundStepsColor.g, soundStepsColor.b, soundStepsColor.a), cvar.visual_sound_steps_segment_thickness);
		}

		if (GetTickCount() - sound_no_index.timestamp > 300)
			continue;

		Vector vPointTop = Vector(sound_no_index.origin.x, sound_no_index.origin.y, sound_no_index.origin.z + 10);
		Vector vPointBot = Vector(sound_no_index.origin.x, sound_no_index.origin.y, sound_no_index.origin.z - 10);

		float vTop[2], vBot[2];
		if (WorldToScreen(vPointTop, vTop) && WorldToScreen(vPointBot, vBot))
		{
			float h = vTop[1] - vBot[1];
			float w = h;
			float x = vTop[0] - (w / 2);
			float y = vTop[1];

			Player::DrawBox(x, y, w, h, soundStepsColor);
		}
	}
}
```

`sakura/source/features/sound/soundesp.h`:

```h
#ifndef _SOUND_
#define _SOUND_

typedef void(*PreS_DynamicSound_t)(int, DWORD, char*, float*, float, float, int, int);

typedef struct
{
	int index;
	Vector origin;
	DWORD timestamp;
} player_sound_index_t;
extern std::deque<player_sound_index_t> Sound_Index;

typedef struct
{
	Vector origin;
	DWORD timestamp;
} player_sound_no_index_t;
extern std::deque<player_sound_no_index_t> Sound_No_Index;

namespace Sakura
{
	namespace Esp
	{
		extern float realDynamicSoundVolume;
		void ChangeDynamicSoundVolume(float newVolume);
		void DynamicSound(int entid, DWORD entchannel, char* szSoundFile, float* fOrigin, float fVolume, float fAttenuation, int iTimeOff, int iPitch);
	
		void DrawSoundIndex();
		void DrawSoundNoIndex();
	};
};

//void PreS_DynamicSound(int entid, DWORD entchannel, char* szSoundFile, float* fOrigin, float fVolume, float fAttenuation, int iTimeOff, int iPitch);

#endif

```

`sakura/source/features/visuals/chams/chams.cpp`:

```cpp
#include "../../../client.h"

float Sakura::Chams::player;
float Sakura::Chams::playerFake;
float Sakura::Chams::localPlayer;
float Sakura::Chams::localFakePlayer;
float Sakura::Chams::viewmodel;
float Sakura::Chams::world;
ImRGBA Sakura::Chams::playerColor;
ImRGBA Sakura::Chams::playerFakeColor;
ImRGBA Sakura::Chams::localPlayerColor;
ImRGBA Sakura::Chams::localFakePlayerColor;
ImRGBA Sakura::Chams::viewmodelColor;
ImRGBA Sakura::Chams::worldColor;

constexpr int IS_WF_POINT = 0;
constexpr int IS_CHAMS_2D = 1;

GLenum Sakura::Chams::GetWireframeMode(const float wireframeCvar)
{
	if (wireframeCvar > IS_WF_POINT)
		return GL_POINT;

	return GL_LINE;
}

void Sakura::Chams::TextureEntity(cl_entity_s* ent, const float chamsType, const bool isChamsWall, const ImRGBA chamsColor, const ImRGBA chamsWallColor, float& openglChams, ImRGBA& openglChamsColor, const bool isWireframe, const float wireframeMode, const float wireFramePointSize, const float wireFrameLineWidth)
{
	openglChams = true;

	glLineWidth(wireFrameLineWidth);
	glPointSize(wireFramePointSize);
	glPolygonMode(GL_FRONT_AND_BACK, isWireframe ? Sakura::Chams::GetWireframeMode(wireframeMode) : GL_FILL);

	ent->curstate.rendermode = 0;
	ent->curstate.renderfx = 0;
	ent->curstate.renderamt = 0;
	g_Studio.SetForceFaceFlags(0);

	if (chamsType > IS_CHAMS_2D)
	{
		glDisable(GL_TEXTURE_2D);
		glBindTexture(GL_TEXTURE_2D, 0);
	}

	ent->curstate.rendermode = 0;
	ent->curstate.renderfx = 0;
	ent->curstate.renderamt = 0;
	g_Studio.SetForceFaceFlags(0);

	if (isChamsWall)
	{
		glDepthFunc(GL_GREATER);
		glDisable(GL_DEPTH_TEST);
		openglChamsColor.r = chamsWallColor.r;
		openglChamsColor.g = chamsWallColor.g;
		openglChamsColor.b = chamsWallColor.b;
		oStudioRenderFinal();
	}

	glEnable(GL_DEPTH_TEST);
	glDepthFunc(GL_LESS);
	openglChamsColor.r = chamsColor.r;
	openglChamsColor.g = chamsColor.g;
	openglChamsColor.b = chamsColor.b;
	oStudioRenderFinal();

	if (chamsType > IS_CHAMS_2D)
		glEnable(GL_TEXTURE_2D);

	glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);

	openglChams = false;
}

void Sakura::Chams::GlowEntity(cl_entity_s* ent, const float isChams, const float glowThickness, const ImRGBA glowColor)
{
	glDepthFunc(GL_GREATER);
	glDisable(GL_DEPTH_TEST);

	g_Studio.SetForceFaceFlags(STUDIO_NF_CHROME);
	ent->curstate.renderfx = kRenderFxGlowShell;
	ent->curstate.renderamt = glowThickness;
	ent->curstate.rendermode = 0;

	ent->curstate.rendercolor.r = glowColor.r * 255;
	ent->curstate.rendercolor.g = glowColor.g * 255;
	ent->curstate.rendercolor.b = glowColor.b * 255;

	oStudioRenderFinal();
	glEnable(GL_DEPTH_TEST);

	if (!isChams)
	{
		glDisable(GL_DEPTH_TEST);
		g_Studio.SetForceFaceFlags(0);
		ent->curstate.renderfx = 0;
		oStudioRenderFinal();
		glEnable(GL_DEPTH_TEST);
		glDepthFunc(GL_LESS);
		oStudioRenderFinal();
	}
}

void Sakura::Chams::Studio()
{
	if (!Sakura::ScreenShot::IsVisuals())
	{
		oStudioRenderModel();
		return;
	}

	cl_entity_s* ent = g_Studio.GetCurrentEntity();

	bool isPlayer = false;
	bool isPlayerFake = false;
	bool isLocalFake = false;
	bool isLocalPlayer = false;
	bool isViewModel = false;
	bool isWorld = false;

	if (ent)
	{
		if (ent->player)
		{
			const int playerIndex = ent->index;

			if (Sakura::Player::IsAlive(playerIndex))
			{
				isPlayer =  ent != &g_Player[playerIndex].playerHistory &&
							ent != &g_Player[playerIndex].playerDeathMark[0] &&
							ent != &g_Player[playerIndex].playerDeathMark[1] &&
							(g_Player[playerIndex].iTeam != g_Local.iTeam || cvar.visual_visual_team);

				isPlayerFake = ent == &g_Player[playerIndex].playerHistory;
			}

			if (Sakura::Player::Local::IsAlive())
			{
				isLocalFake = playerIndex == pmove->player_index + 1 &&
							  ent == &g_Player[playerIndex].playerHistory;

				isLocalPlayer = playerIndex == pmove->player_index + 1 &&
								ent != &g_Player[playerIndex].playerHistory &&
								ent != &g_Player[playerIndex].playerDeathMark[0] &&
								ent != &g_Player[playerIndex].playerDeathMark[1];
			}
		}

		isViewModel = Sakura::Player::Local::IsAlive() && ent == g_Local.ViewModel;
		isWorld = ent->model && strstr(ent->model->name, /*/w_*/XorStr<0xC1, 4, 0x46E892EF>("\xEE\xB5\x9C" + 0x46E892EF).s) && ent != g_Local.ViewModel;
	}

	if (isPlayer && !(cvar.visual_idhook_only && IdHook::FirstKillPlayer[ent->index] == IDHOOK_PLAYER_OFF))
	{
		if (cvar.visual_player_glow)
		{
			const ImRGBA playerGlowColor = Sakura::Colors::GetCustomizedTeamColor(ent->index, cvar.visual_player_glow_color_tt, cvar.visual_player_glow_color_ct, cvar.rainbow_glow_player_tt, cvar.rainbow_glow_player_ct);
			Sakura::Chams::GlowEntity(ent, cvar.chams_player, cvar.visual_player_glow_thickness, playerGlowColor);
		}

		if (cvar.chams_player)
		{
			const ImRGBA playerChamsColor = Sakura::Colors::GetCustomizedTeamColor(ent->index, cvar.chams_player_color_tt, cvar.chams_player_color_ct, cvar.rainbow_chams_player_tt, cvar.rainbow_chams_player_ct);
			const ImRGBA playerChamsWallColor = Sakura::Colors::GetCustomizedTeamColor(ent->index, cvar.chams_player_wall_color_tt, cvar.chams_player_wall_color_ct);
			Sakura::Chams::TextureEntity(ent, cvar.chams_player, cvar.chams_player_wall, playerChamsColor, playerChamsWallColor, Sakura::Chams::player, Sakura::Chams::playerColor, cvar.chams_player_wireframe, cvar.chams_player_wireframe_mode, cvar.chams_player_wireframe_point_size, cvar.chams_player_wireframe_line_width);
		
			// dont render model if using wireframe
			if (cvar.chams_player_wireframe)
				return;
		}
	}

	if (isPlayerFake && cvar.misc_backtrack_chams)
	{
		const ImRGBA playerBacktrackChamsColor = Sakura::Colors::GetCustomizedColor(cvar.misc_backtrack_chams_color, cvar.rainbow_backtrack_chams);
		Sakura::Chams::TextureEntity(ent, cvar.misc_backtrack_chams, Sakura::Chams::CHAMS_NONE, playerBacktrackChamsColor, ImRGBA(), Sakura::Chams::playerFake, Sakura::Chams::playerFakeColor, cvar.misc_backtrack_wireframe, cvar.misc_backtrack_wireframe_mode, cvar.misc_backtrack_wireframe_point_size, cvar.misc_backtrack_wireframe_line_width);
	
		// dont render model if using wireframe
		if (cvar.misc_backtrack_wireframe)
			return;
	}

	if (isLocalPlayer)
	{
		if (cvar.visual_local_glow)
		{
			const ImRGBA localPlayerGlowColor = Sakura::Colors::GetCustomizedColor(cvar.visual_local_glow_color, cvar.rainbow_local_glow);
			Sakura::Chams::GlowEntity(ent, cvar.chams_local, cvar.visual_local_glow_thickness, localPlayerGlowColor);
		}

		if (cvar.chams_local)
		{
			const ImRGBA localPlayerChamsColor = Sakura::Colors::GetCustomizedColor(cvar.chams_local_color, cvar.rainbow_chams_local);
			Sakura::Chams::TextureEntity(ent, cvar.chams_local, Sakura::Chams::CHAMS_NONE, localPlayerChamsColor, ImRGBA(), Sakura::Chams::localPlayer, Sakura::Chams::localPlayerColor, cvar.chams_local_wireframe, cvar.chams_local_wireframe_mode, cvar.chams_local_wireframe_point_size, cvar.chams_local_wireframe_line_width);
		
			// dont render model if using wireframe
			if (cvar.chams_local_wireframe)
				return;
		}
	}

	if (isLocalFake && cvar.visual_fakelag_history_local_chams)
	{
		const ImRGBA localPlayerChamsFakeColor = Sakura::Colors::GetCustomizedColor(cvar.visual_fakelag_history_local_chams_color, cvar.rainbow_chams_local_fake);
		Sakura::Chams::TextureEntity(ent, cvar.visual_fakelag_history_local_chams, Sakura::Chams::CHAMS_NONE, localPlayerChamsFakeColor, ImRGBA(), Sakura::Chams::localFakePlayer, Sakura::Chams::localFakePlayerColor, cvar.visual_fakelag_history_local_wireframe, cvar.visual_fakelag_history_local_wireframe_mode, cvar.visual_fakelag_history_local_wireframe_point_size, cvar.visual_fakelag_history_local_wireframe_line_width);
	
		// dont render model if using wireframe
		if (cvar.visual_fakelag_history_local_wireframe)
			return;
	}

	if (isWorld && cvar.chams_world)
	{
		const ImRGBA worldChamsColor = Sakura::Colors::GetCustomizedColor(cvar.chams_world_color, cvar.rainbow_chams_world);
		const ImRGBA worldChamsWallColor = Sakura::Colors::GetCustomizedColor(cvar.chams_world_wall_color);
		Sakura::Chams::TextureEntity(ent, cvar.chams_world, cvar.chams_world_wall, worldChamsColor, worldChamsWallColor, Sakura::Chams::world, Sakura::Chams::worldColor, cvar.chams_world_wireframe, cvar.chams_world_wireframe_mode, cvar.chams_world_wireframe_point_size, cvar.chams_world_wireframe_line_width);
	
		// dont render model if using wireframe
		if (cvar.chams_world_wireframe)
			return;
	}

	if (isViewModel)
	{
		if (cvar.visual_viewmodel_glow)
		{
			const ImRGBA ViewModelGlowColor = Sakura::Colors::GetCustomizedColor(cvar.visual_viewmodel_glow_color, cvar.rainbow_viewmodel_glow);
			GlowEntity(ent, cvar.chams_view_model, cvar.visual_viewmodel_glow_thickness, ViewModelGlowColor);
		}

		if (cvar.chams_view_model)
		{
			const ImRGBA ViewModelChamsColor = Sakura::Colors::GetCustomizedColor(cvar.visual_skins_viewmodel_color, cvar.rainbow_viewmodel);
			Sakura::Chams::TextureEntity(ent, cvar.chams_view_model, Sakura::Chams::CHAMS_NONE, ViewModelChamsColor, ImRGBA(), Sakura::Chams::viewmodel, Sakura::Chams::viewmodelColor, cvar.chams_view_model_wireframe, cvar.chams_view_model_wireframe_mode, cvar.chams_view_model_wireframe_point_size, cvar.chams_view_model_wireframe_line_width);

			// dont render model if using wireframe
			if (cvar.chams_view_model_wireframe)
				return;
		}
	}

	oStudioRenderModel();
}
```

`sakura/source/features/visuals/chams/chams.h`:

```h
#pragma once

namespace Sakura
{
	namespace Chams
	{
		enum TYPES
		{
			CHAMS_NONE = 0
		};

		extern float player;
		extern float playerFake;
		extern float localPlayer;
		extern float localFakePlayer;
		extern float viewmodel;
		extern float world;
		extern ImRGBA playerColor;
		extern ImRGBA playerFakeColor;
		extern ImRGBA localPlayerColor;
		extern ImRGBA localFakePlayerColor;
		extern ImRGBA viewmodelColor;
		extern ImRGBA worldColor;

		GLenum GetWireframeMode(const float wireframeCvar);
		void TextureEntity(cl_entity_s* ent, const float chamsType, const bool isChamsWall, const ImRGBA chamsColor, const ImRGBA chamsWallColor, float& openglChams, ImRGBA& openglChamsColor, const bool isWireframe = false, const float wireframeMode = 0, const float wireFramePointSize = 0, const float wireFrameLineWidth = 0);
		void GlowEntity(cl_entity_s* ent, const float isChams, const float glowThickness, const ImRGBA glowColor);
		void Studio();
	};
};
```

`sakura/source/features/visuals/chams/studiomodelrender.cpp`:

```cpp
#include "../../../client.h"

// This pointer to CStudioModelRenderer class !
StudioModelRenderer_d pThis;

//=========================
// StudioDrawModel
//=========================
int (*pStudioDrawModel)(int flags);
int	StudioDrawModel(int flags)
{
	return pStudioDrawModel(flags);
}

int (*pStudioDrawPlayer)(int flags, entity_state_s* pplayer);
int StudioDrawPlayer(int flags, entity_state_s* pplayer)
{
	return pStudioDrawPlayer(flags, pplayer);
}
//=========================
// StudioGetAnim
// Look up animation data for sequence
//=========================
mstudioanim_t StudioGetAnim(model_t* m_pSubModel, mstudioseqdesc_t* pseqdesc)
{
	return oStudioGetAnim(m_pSubModel, pseqdesc);
}

//=========================
// StudioSetUpTransform
// Interpolate model position and angles and set up matrices
//=========================
void StudioSetUpTransform(int trivial_accept)
{
	oStudioSetUpTransform(trivial_accept);
}

//=========================
// StudioSetupBones
// Set up model bone positions
//=========================
void StudioSetupBones(void)
{
	oStudioSetupBones();
}

//=========================
// StudioCalcAttachments
// Find final attachment points
//=========================
void StudioCalcAttachments(void)
{
	oStudioCalcAttachments();
}

//=========================
// StudioSaveBones
// Save bone matrices and names
//=========================
void StudioSaveBones(void)
{
	oStudioSaveBones();
}

//=========================
// StudioMergeBones
// Merge cached bones with current bones for model
//=========================
void StudioMergeBones(model_t* m_pSubModel)
{
	oStudioMergeBones(m_pSubModel);
}

//=========================
// StudioEstimateInterpolant
// Determine interpolation fraction
//=========================
float StudioEstimateInterpolant(void)
{
	return oStudioEstimateInterpolant();
}

//=========================
// StudioEstimateFrame
// Determine current frame for rendering
//=========================
float StudioEstimateFrame(mstudioseqdesc_t* pseqdesc)
{
	return oStudioEstimateFrame(pseqdesc);
}

//=========================
// StudioFxTransform
// Apply special effects to transform matrix
//=========================
void StudioFxTransform(cl_entity_t* ent, float transform[3][4])
{
	oStudioFxTransform(ent, transform);
}

//=========================
// StudioSlerpBones
// Spherical interpolation of bones
//=========================
void StudioSlerpBones(vec4_t q1[], float pos1[][3], vec4_t q2[], float pos2[][3], float s)
{
	oStudioSlerpBones(q1, pos1, q2, pos2, s);
}

//=========================
// StudioCalcBoneAdj
// Compute bone adjustments ( bone controllers )
//=========================
void StudioCalcBoneAdj(float dadt, float* adj, const byte* pcontroller1, const byte* pcontroller2, byte mouthopen)
{
	oStudioCalcBoneAdj(dadt, adj, pcontroller1, pcontroller2, mouthopen);
}

//=========================
// StudioCalcBoneQuaterion
// Get bone quaternions
//=========================
void StudioCalcBoneQuaterion(int frame, float s, mstudiobone_t* pbone, mstudioanim_t* panim, float* adj, float* q)
{
	oStudioCalcBoneQuaterion(frame, s, pbone, panim, adj, q);
}

//=========================
// StudioCalcBonePosition
// Get bone positions
//=========================
void StudioCalcBonePosition(int frame, float s, mstudiobone_t* pbone, mstudioanim_t* panim, float* adj, float* pos)
{
	oStudioCalcBonePosition(frame, s, pbone, panim, adj, pos);
}

//=========================
// StudioCalcRotations
// Compute rotations
//=========================
void StudioCalcRotations(float pos[][3], vec4_t* q, mstudioseqdesc_t* pseqdesc, mstudioanim_t* panim, float f)
{
	oStudioCalcRotations(pos, q, pseqdesc, panim, f);
}

//=========================
// StudioRenderFinal
// Finalize rendering
//=========================
void StudioRenderFinal(void)
{
	oStudioRenderFinal();
}

//=========================
// StudioRenderFinal_Software
// Software renderer finishing function
//=========================

void StudioRenderFinal_Software(void)
{
	oStudioRenderFinal_Software();
}

//=========================
// StudioRenderFinal_Hardware
// GL&D3D renderer finishing function
//=========================

void StudioRenderFinal_Hardware(void)
{
	oStudioRenderFinal_Hardware();
}

//=========================
// StudioPlayerBlend
// Determine pitch and blending amounts for players
//=========================
void StudioPlayerBlend(mstudioseqdesc_t* pseqdesc, int* pBlend, float* pPitch)
{
	oStudioPlayerBlend(pseqdesc, pBlend, pPitch);
}

//=========================
// StudioEstimateGait
// Estimate gait frame for player
//=========================
void StudioEstimateGait(entity_state_t* pplayer)
{
	oStudioEstimateGait(pplayer);
}

//=========================
// StudioProcessGait
// Process movement of player
//=========================
void StudioProcessGait(entity_state_t* pplayer)
{
	oStudioProcessGait(pplayer);
}

//===================================================================================
// Callgates & Patchgates
//===================================================================================
void __declspec(naked) oStudioRenderModel(void)
{
	_asm
	{
		mov ecx, pThis
		jmp g_StudioModelRenderer.StudioRenderModel;
	}
}
//void __declspec(naked)StudioRenderModel_Gate(void)
//{
//	_asm
//	{
//		mov pThis, ecx
//		jmp StudioRenderModel
//	}
//}
void __declspec(naked)StudioRenderModel_Gate(void)
{
	_asm
	{
		mov pThis, ecx
		jmp Sakura::Chams::Studio;
	}
}

int __declspec(naked) oStudioDrawModel(int flags)
{
	_asm
	{
		mov ecx, pThis
		jmp g_StudioModelRenderer.StudioDrawModel;
	}
}
void __declspec(naked) StudioDrawModel_Gate(void)
{
	_asm
	{
		mov pThis, ecx
		jmp StudioDrawModel
	}
}

int __declspec(naked) oStudioDrawPlayer(int flags, struct entity_state_s* pplayer)
{
	_asm
	{
		mov ecx, pThis
		jmp g_StudioModelRenderer.StudioDrawPlayer;
	}
}
void __declspec(naked) StudioDrawPlayer_Gate(void)
{
	_asm
	{
		mov pThis, ecx
		jmp StudioDrawPlayer
	}
}

mstudioanim_t __declspec(naked) oStudioGetAnim(model_t* m_pSubModel, mstudioseqdesc_t* pseqdesc)
{
	_asm
	{
		mov ecx, pThis
		jmp g_StudioModelRenderer.StudioGetAnim;
	}
}
void __declspec(naked) StudioGetAnim_Gate(void)
{
	_asm
	{
		mov pThis, ecx
		jmp StudioGetAnim
	}
}

void __declspec(naked) oStudioSetUpTransform(int trivial_accept)
{
	_asm
	{
		mov ecx, pThis
		jmp g_StudioModelRenderer.StudioSetUpTransform;
	}
}
void __declspec(naked) StudioSetUpTransform_Gate(void)
{
	_asm
	{
		mov pThis, ecx
		jmp StudioSetUpTransform
	}
}

void __declspec(naked) oStudioSetupBones(void)
{
	_asm
	{
		mov ecx, pThis
		jmp g_StudioModelRenderer.StudioSetupBones;
	}
}
void __declspec(naked) StudioSetupBones_Gate(void)
{
	_asm
	{
		mov pThis, ecx
		jmp StudioSetupBones
	}
}

void __declspec(naked) oStudioCalcAttachments(void)
{
	_asm
	{
		mov ecx, pThis
		jmp g_StudioModelRenderer.StudioCalcAttachments;
	}
}
void __declspec(naked) StudioCalcAttachments_Gate(void)
{
	_asm
	{
		mov pThis, ecx
		jmp StudioCalcAttachments
	}
}

void __declspec(naked) oStudioSaveBones(void)
{
	_asm
	{
		mov ecx, pThis
		jmp g_StudioModelRenderer.StudioSaveBones;
	}
}
void __declspec(naked) StudioSaveBones_Gate(void)
{
	_asm
	{
		mov pThis, ecx
		jmp StudioSaveBones
	}
}

void __declspec(naked) oStudioMergeBones(model_t* m_pSubModel)
{
	_asm
	{
		mov ecx, pThis
		jmp g_StudioModelRenderer.StudioMergeBones;
	}
}
void __declspec(naked) StudioMergeBones_Gate(void)
{
	_asm
	{
		mov pThis, ecx
		jmp StudioMergeBones
	}
}

float __declspec(naked) oStudioEstimateInterpolant(void)
{
	_asm
	{
		mov ecx, pThis
		jmp g_StudioModelRenderer.StudioEstimateInterpolant;
	}
}
void __declspec(naked) StudioEstimateInterpolant_Gate(void)
{
	_asm
	{
		mov pThis, ecx
		jmp StudioEstimateInterpolant
	}
}

float __declspec(naked) oStudioEstimateFrame(mstudioseqdesc_t* pseqdesc)
{
	_asm
	{
		mov ecx, pThis
		jmp g_StudioModelRenderer.StudioEstimateFrame;
	}
}
void __declspec(naked) StudioEstimateFrame_Gate(void)
{
	_asm
	{
		mov pThis, ecx
		jmp StudioEstimateFrame
	}
}

void __declspec(naked) oStudioFxTransform(cl_entity_t* ent, float transform[3][4])
{
	_asm
	{
		mov ecx, pThis
		jmp g_StudioModelRenderer.StudioFxTransform;
	}
}
void __declspec(naked) StudioFxTransforme_Gate(void)
{
	_asm
	{
		mov pThis, ecx
		jmp StudioFxTransform
	}
}

void __declspec(naked) oStudioSlerpBones(vec4_t q1[], float pos1[][3], vec4_t q2[], float pos2[][3], float s)
{
	_asm
	{
		mov ecx, pThis
		jmp g_StudioModelRenderer.StudioSlerpBones;
	}
}
void __declspec(naked) StudioSlerpBones_Gate(void)
{
	_asm
	{
		mov pThis, ecx
		jmp StudioSlerpBones
	}
}

void __declspec(naked) oStudioCalcBoneAdj(float dadt, float* adj, const byte* pcontroller1, const byte* pcontroller2, byte mouthopen)
{
	_asm
	{
		mov ecx, pThis
		jmp g_StudioModelRenderer.StudioCalcBoneAdj;
	}
}
void __declspec(naked) StudioCalcBoneAdj_Gate(void)
{
	_asm
	{
		mov pThis, ecx
		jmp StudioCalcBoneAdj
	}
}

void __declspec(naked) oStudioCalcBoneQuaterion(int frame, float s, mstudiobone_t* pbone, mstudioanim_t* panim, float* adj, float* q)
{
	_asm
	{
		mov ecx, pThis
		jmp g_StudioModelRenderer.StudioCalcBoneQuaterion;
	}
}
void __declspec(naked) StudioCalcBoneQuaterion_Gate(void)
{
	_asm
	{
		mov pThis, ecx
		jmp StudioCalcBoneQuaterion
	}
}

void __declspec(naked) oStudioCalcBonePosition(int frame, float s, mstudiobone_t* pbone, mstudioanim_t* panim, float* adj, float* pos)
{
	_asm
	{
		mov ecx, pThis
		jmp g_StudioModelRenderer.StudioCalcBonePosition;
	}
}
void __declspec(naked) StudioCalcBonePosition_Gate(void)
{
	_asm
	{
		mov pThis, ecx
		jmp StudioCalcBonePosition
	}
}

void __declspec(naked) oStudioCalcRotations(float pos[][3], vec4_t* q, mstudioseqdesc_t* pseqdesc, mstudioanim_t* panim, float f)
{
	_asm
	{
		mov ecx, pThis
		jmp g_StudioModelRenderer.StudioCalcRotations;
	}
}
void __declspec(naked) StudioCalcRotations_Gate(void)
{
	_asm
	{
		mov pThis, ecx
		jmp StudioCalcRotations
	}
}

void __declspec(naked) oStudioRenderFinal(void)
{
	_asm
	{
		mov ecx, pThis
		jmp g_StudioModelRenderer.StudioRenderFinal;
	}
}
void __declspec(naked) StudioRenderFinal_Gate(void)
{
	_asm
	{
		mov pThis, ecx
		jmp StudioRenderFinal
	}
}

void __declspec(naked) oStudioRenderFinal_Software(void)
{
	_asm
	{
		mov ecx, pThis
		jmp g_StudioModelRenderer.StudioRenderFinal_Software;
	}
}
void __declspec(naked) StudioRenderFinal_Software_Gate(void)
{
	_asm
	{
		mov pThis, ecx
		jmp StudioRenderFinal_Software
	}
}

void __declspec(naked) oStudioRenderFinal_Hardware(void)
{
	_asm
	{
		mov ecx, pThis
		jmp g_StudioModelRenderer.StudioRenderFinal_Hardware;
	}
}
void __declspec(naked) StudioRenderFinal_Hardware_Gate(void)
{
	_asm
	{
		mov pThis, ecx
		jmp StudioRenderFinal_Hardware
	}
}

void __declspec(naked) oStudioPlayerBlend(mstudioseqdesc_t* pseqdesc, int* pBlend, float* pPitch)
{
	_asm
	{
		mov ecx, pThis
		jmp g_StudioModelRenderer.StudioPlayerBlend;
	}
}
void __declspec(naked) StudioPlayerBlend_Gate(void)
{
	_asm
	{
		mov pThis, ecx
		jmp StudioPlayerBlend
	}
}

void __declspec(naked) oStudioEstimateGait(entity_state_t* pplayer)
{
	_asm
	{
		mov ecx, pThis
		jmp g_StudioModelRenderer.StudioEstimateGait;
	}
}
void __declspec(naked) StudioEstimateGait_Gate(void)
{
	_asm
	{
		mov pThis, ecx
		jmp StudioEstimateGait
	}
}

void __declspec(naked) oStudioProcessGait(entity_state_t* pplayer)
{
	_asm
	{
		mov ecx, pThis
		jmp g_StudioModelRenderer.StudioProcessGait;
	}
}
void __declspec(naked) StudioProcessGait_Gate(void)
{
	_asm
	{
		mov pThis, ecx
		jmp StudioProcessGait
	}
}

void HookStudiModelRendererFunctions()
{
	c_Offset.EnablePageWrite((DWORD)g_pStudioModelRenderer, sizeof(StudioModelRenderer_t));
	g_pStudioModelRenderer->StudioRenderModel = StudioRenderModel_Gate;
	g_pStudioModelRenderer->StudioSetupBones = StudioSetupBones_Gate;
	g_pStudioModelRenderer->StudioRenderFinal_Hardware = StudioRenderFinal_Hardware_Gate;
	c_Offset.RestorePageProtection((DWORD)g_pStudioModelRenderer, sizeof(StudioModelRenderer_t));
	pStudioDrawPlayer = g_pInterface->StudioDrawPlayer;
	g_pInterface->StudioDrawPlayer = StudioDrawPlayer;
	pStudioDrawModel = g_pInterface->StudioDrawModel;
	g_pInterface->StudioDrawModel = StudioDrawModel;
}

```

`sakura/source/features/visuals/chams/studiomodelrender.h`:

```h
#ifndef __STUDIO_MODEL_RENDERER__
#define __STUDIO_MODEL_RENDERER__

// Prototypes for original calls
void oInit(void);
int oStudioDrawModel(int flags);
int oStudioDrawPlayer(int flags, struct entity_state_s *pplayer);
mstudioanim_t oStudioGetAnim(model_t *m_pSubModel, mstudioseqdesc_t *pseqdesc);
void oStudioSetUpTransform(int trivial_accept);
void oStudioSetupBones(void);
void oStudioCalcAttachments(void);
void oStudioSaveBones(void);
void oStudioMergeBones(model_t *m_pSubModel);
float oStudioEstimateInterpolant(void);
float oStudioEstimateFrame(mstudioseqdesc_t *pseqdesc);
void oStudioFxTransform(cl_entity_t *ent, float transform[3][4]);
void oStudioSlerpBones(vec4_t q1[], float pos1[][3], vec4_t q2[], float pos2[][3], float s);
void oStudioCalcBoneAdj(float dadt, float *adj, const byte *pcontroller1, const byte *pcontroller2, byte mouthopen);
void oStudioCalcBoneQuaterion(int frame, float s, mstudiobone_t *pbone, mstudioanim_t *panim, float *adj, float *q);
void oStudioCalcBonePosition(int frame, float s, mstudiobone_t *pbone, mstudioanim_t *panim, float *adj, float *pos);
void oStudioCalcRotations(float pos[][3], vec4_t *q, mstudioseqdesc_t *pseqdesc, mstudioanim_t *panim, float f);
void oStudioRenderModel(void);
void oStudioRenderFinal(void);
void oStudioRenderFinal_Software(void);
void oStudioRenderFinal_Hardware(void);
void oStudioPlayerBlend(mstudioseqdesc_t *pseqdesc, int *pBlend, float *pPitch);
void oStudioEstimateGait(entity_state_t *pplayer);
void oStudioProcessGait(entity_state_t *pplayer);

// Prototypes for patch gates
void Init_Gate(void);
void StudioDrawModel_Gate(void);
void StudioDrawPlayer_Gate(void);
void StudioGetAnim_Gate(void);
void StudioSetUpTransform_Gate(void);
void StudioSetupBones_Gate(void);
void StudioCalcAttachments_Gate(void);
void StudioSaveBones_Gate(void);
void StudioMergeBones_Gate(void);
void StudioEstimateInterpolant_Gate(void);
void StudioEstimateFrame_Gate(void);
void StudioFxTransform_Gate(void);
void StudioSlerpBones_Gate(void);
void StudioCalcBoneAdj_Gate(void);
void StudioCalcBoneQuaterion_Gate(void);
void StudioCalcBonePosition_Gate(void);
void StudioCalcRotations_Gate(void);
void StudioRenderModel_Gate(void);
void StudioRenderFinal_Gate(void);
void StudioRenderFinal_Software_Gate(void);
void StudioRenderFinal_Hardware_Gate(void);
void StudioPlayerBlend_Gate(void);
void StudioEstimateGait_Gate(void);
void StudioProcessGait_Gate(void);

// Data definition of pThis
typedef struct
{
	double			dummy;
	double			m_clTime;
	double			m_clOldTime;
	int				m_fDoInterp;
	int				m_fGaitEstimation;
	int				m_nFrameCount;
	cvar_t			*m_pCvarHiModels;
	cvar_t			*m_pCvarDeveloper;
	cvar_t			*m_pCvarDrawEntities;
	cl_entity_t		*m_pCurrentEntity;
	model_t			*m_pRenderModel;
	player_info_t	*m_pPlayerInfo;
	int				m_nPlayerIndex;
	float			m_flGaitMovement;
	studiohdr_t		*m_pStudioHeader;
	mstudiobodyparts_t *m_pBodyPart;
	mstudiomodel_t	*m_pSubModel;
	int				m_nTopColor;
	int				m_nBottomColor;
	model_t			*m_pChromeSprite;
	int				m_nCachedBones;
	char			m_nCachedBoneNames[MAXSTUDIOBONES][32];
	float			m_rgCachedBoneTransform[MAXSTUDIOBONES][3][4];
	float			m_rgCachedLightTransform[MAXSTUDIOBONES][3][4];
	float			m_fSoftwareXScale, m_fSoftwareYScale;
	float			m_vUp[3];
	float			m_vRight[3];
	float			m_vNormal[3];
	float			m_vRenderOrigin[3];
	int				*m_pStudioModelCount;
	int				*m_pModelsDrawn;
	float(*m_protationmatrix)[3][4];
	float(*m_paliastransform)[3][4];
	float(*m_pbonetransform)[MAXSTUDIOBONES][3][4];
	float(*m_plighttransform)[MAXSTUDIOBONES][3][4];
} *StudioModelRenderer_d;

typedef struct StudioModelRenderer_s
{
	void(*CStudioModelRenderer)(void);
	void(*Init)(void);
	int(*StudioDrawModel) (int flags);
	int(*StudioDrawPlayer)(int flags, struct entity_state_s *pplayer);
	mstudioanim_t(*StudioGetAnim)(model_t *m_pSubModel, mstudioseqdesc_t *pseqdesc);
	void(*StudioSetUpTransform) (int trivial_accept);
	void(*StudioSetupBones) (void);
	void(*StudioCalcAttachments) (void);
	void(*StudioSaveBones)(void);
	void(*StudioMergeBones)(model_t *m_pSubModel);
	float(*StudioEstimateInterpolant)(void);
	float(*StudioEstimateFrame)(mstudioseqdesc_t *pseqdesc);
	void(*StudioFxTransform)(cl_entity_t *ent, float transform[3][4]);
	void(*StudioSlerpBones)(vec4_t q1[], float pos1[][3], vec4_t q2[], float pos2[][3], float s);
	void(*StudioCalcBoneAdj) (float dadt, float *adj, const byte *pcontroller1, const byte *pcontroller2, byte mouthopen);
	void(*StudioCalcBoneQuaterion)(int frame, float s, mstudiobone_t *pbone, mstudioanim_t *panim, float *adj, float *q);
	void(*StudioCalcBonePosition)(int frame, float s, mstudiobone_t *pbone, mstudioanim_t *panim, float *adj, float *pos);
	void(*StudioCalcRotations)(float pos[][3], vec4_t *q, mstudioseqdesc_t *pseqdesc, mstudioanim_t *panim, float f);
	void(*StudioRenderModel) (void);
	void(*StudioRenderFinal) (void);
	void(*StudioRenderFinal_Software) (void);
	void(*StudioRenderFinal_Hardware) (void);
	void(*StudioPlayerBlend) (mstudioseqdesc_t *pseqdesc, int *pBlend, float *pPitch);
	void(*StudioEstimateGait) (entity_state_t *pplayer);
	void(*StudioProcessGait) (entity_state_t *pplayer);
} StudioModelRenderer_t, *pStudioModelRenderer_t;

//extern float chams_viewmodel_r;
//extern float chams_viewmodel_g;
//extern float chams_viewmodel_b;
//extern float chams_viewmodel;
//
//extern float chams_player_r;
//extern float chams_player_g;
//extern float chams_player_b;
//extern float chams_player;
//
//extern float chams_world_r;
//extern float chams_world_g;
//extern float chams_world_b;
//extern float chams_world;
//
//extern float chams_fake_local;
//extern float chams_fake_local_r;
//extern float chams_fake_local_g;
//extern float chams_fake_local_b;
//
//extern float chams_local_r;
//extern float chams_local_g;
//extern float chams_local_b;
//extern float chams_local;
//
//extern float chams_backtrack_r;
//extern float chams_backtrack_g;
//extern float chams_backtrack_b;
//extern float chams_backtrack;

void HookStudiModelRendererFunctions();

#endif
```

`sakura/source/features/visuals/esp/esp.cpp`:

```cpp
#include "../../../client.h"

std::deque<playeresp_t> PlayerEsp;
std::deque<worldesp_t> WorldEsp;
std::deque<worldespprev_t> WorldEspPrev;

void Rect(Vector2D Pos, Vector2D Size, ImU32 color)
{
	ImGui::GetCurrentWindow()->DrawList->AddRect({ Pos.x, Pos.y }, { Pos.x + Size.x, Pos.y + Size.y }, color);
}

void Corners(Vector2D Pos, Vector2D Size, ImU32 color)
{
	ImGui::GetCurrentWindow()->DrawList->AddLine({ Pos.x, Pos.y }, { Pos.x + (Size.x / 4), Pos.y }, color);
	ImGui::GetCurrentWindow()->DrawList->AddLine({ Pos.x, Pos.y }, { Pos.x, Pos.y + (Size.x / 4) }, color);

	ImGui::GetCurrentWindow()->DrawList->AddLine({ Pos.x, Pos.y + Size.y }, { Pos.x + (Size.x / 4), Pos.y + Size.y }, color);
	ImGui::GetCurrentWindow()->DrawList->AddLine({ Pos.x, Pos.y + Size.y }, { Pos.x, Pos.y + Size.y - (Size.x / 4) }, color);

	ImGui::GetCurrentWindow()->DrawList->AddLine({ Pos.x + Size.x, Pos.y }, { Pos.x + Size.x - (Size.x / 4), Pos.y }, color);
	ImGui::GetCurrentWindow()->DrawList->AddLine({ Pos.x + Size.x, Pos.y }, { Pos.x + Size.x, Pos.y + (Size.x / 4) }, color);

	ImGui::GetCurrentWindow()->DrawList->AddLine({ Pos.x + Size.x, Pos.y + Size.y }, { Pos.x + Size.x - (Size.x / 4), Pos.y + Size.y }, color);
	ImGui::GetCurrentWindow()->DrawList->AddLine({ Pos.x + Size.x, Pos.y + Size.y }, { Pos.x + Size.x, Pos.y + Size.y - (Size.x / 4) }, color);
}

void Coal(Vector2D Pos, Vector2D Size, ImU32 color)
{
	ImGui::GetCurrentWindow()->DrawList->AddLine({ Pos.x, Pos.y }, { Pos.x, Pos.y + Size.y }, color);
	ImGui::GetCurrentWindow()->DrawList->AddLine({ Pos.x, Pos.y }, { Pos.x + (Size.x / 4), Pos.y }, color);
	ImGui::GetCurrentWindow()->DrawList->AddLine({ Pos.x, Pos.y + Size.y }, { Pos.x + (Size.x / 4), Pos.y + Size.y }, color);

	ImGui::GetCurrentWindow()->DrawList->AddLine({ Pos.x + Size.x, Pos.y }, { Pos.x + Size.x, Pos.y + Size.y }, color);
	ImGui::GetCurrentWindow()->DrawList->AddLine({ Pos.x + Size.x, Pos.y }, { Pos.x + Size.x - (Size.x / 4), Pos.y }, color);
	ImGui::GetCurrentWindow()->DrawList->AddLine({ Pos.x + Size.x, Pos.y + Size.y }, { Pos.x + Size.x - (Size.x / 4), Pos.y + Size.y }, color);
}

void Sakura::Esp::Player::DrawBox(const float x, const float y, const float w, const float h, const ImRGBA color)
{
	if (!cvar.visual_box)
		return;

	if (cvar.visual_box_fill > 0) ImGui::GetCurrentWindow()->DrawList->AddRectFilled({ x, y }, { x + w, y + h }, ImColor(color.r, color.g, color.b, cvar.visual_box_fill / 100.f));

	switch ((int)cvar.visual_box_type)
	{
	case 0:
		Rect({ x - 1, y - 1 }, { w, h }, ImColor(0.f, 0.f, 0.f, color.a));
		Rect({ x - 1, y + 1 }, { w, h }, ImColor(0.f, 0.f, 0.f, color.a));
		Rect({ x + 1, y - 1 }, { w, h }, ImColor(0.f, 0.f, 0.f, color.a));
		Rect({ x + 1, y + 1 }, { w, h }, ImColor(0.f, 0.f, 0.f, color.a));
		Rect({ x, y }, { w, h }, ImColor(color.r, color.g, color.b, color.a));
		break;
	case 1:
		Corners({ x - 1, y - 1 }, { w, h }, ImColor(0.f, 0.f, 0.f, color.a));
		Corners({ x - 1, y + 1 }, { w, h }, ImColor(0.f, 0.f, 0.f, color.a));
		Corners({ x + 1, y - 1 }, { w, h }, ImColor(0.f, 0.f, 0.f, color.a));
		Corners({ x + 1, y + 1 }, { w, h }, ImColor(0.f, 0.f, 0.f, color.a));
		Corners({ x, y }, { w, h }, ImColor(color.r, color.g, color.b, color.a));
		break;
	case 2:
		Coal({ x - 1, y - 1 }, { w, h }, ImColor(0.f, 0.f, 0.f, color.a));
		Coal({ x - 1, y + 1 }, { w, h }, ImColor(0.f, 0.f, 0.f, color.a));
		Coal({ x + 1, y - 1 }, { w, h }, ImColor(0.f, 0.f, 0.f, color.a));
		Coal({ x + 1, y + 1 }, { w, h }, ImColor(0.f, 0.f, 0.f, color.a));
		Coal({ x, y }, { w, h }, ImColor(color.r, color.g, color.b, color.a));
	}
}

void Sakura::Esp::Player::DrawHealth(const int index, const float x, const float y, const float h)
{
	if (!cvar.visual_health)
		return;

	static int playerHealth[33];
	static double hp[33][Sakura::Animation::max_count], change_timestamp;

	playerHealth[index] = g_Player[index].iHealth;

	Sakura::Animation::Calculate(hp[index], change_timestamp, playerHealth[index], 100, 0.8);

	float red = 255 - (playerHealth[index] * 2.55);
	float green = playerHealth[index] * 2.55;
	float healthHeight = (h / 100) * hp[index][Sakura::Animation::calculated];

	ImGui::GetCurrentWindow()->DrawList->AddRect({ x - 8, y + h + 1 }, { x - 4, y - 1 }, ImColor(0.f, 0.f, 0.f, 1.f));
	ImGui::GetCurrentWindow()->DrawList->AddRectFilled({ x - 7, y + h }, { x - 5, (y + h) - healthHeight }, ImColor(red / 255.f, green / 222.f, 0.f, 1.f));

	if (playerHealth[index] < 100)
	{
		std::string healthString = std::to_string(static_cast<int>(hp[index][Sakura::Animation::calculated]));
		int calc = ImGui::CalcTextSize(healthString.c_str()).x;
		ImGui::GetCurrentWindow()->DrawList->AddText({ x - 7 - calc, (y + h) - healthHeight }, Sakura::Colors::White(), healthString.c_str());
	}
}

void Sakura::Esp::Player::DrawVip(const int index, const float x, const float y)
{
	if (!cvar.visual_vip || !g_Player[index].bVip)
		return;

	float label_size = ImGui::CalcTextSize("VIP", NULL, true).x / 2.0f;
	ImGui::GetCurrentWindow()->DrawList->AddText({ x - label_size, y }, ImColor(1.f, 1.f, 0.f, 1.f), "VIP");
}

void Sakura::Esp::Player::DrawReload(const int index, const int sequence, const float x, const float y)
{
	int seqinfo = Cstrike_SequenceInfo[sequence];

	if (!cvar.visual_reload_bar || seqinfo != 2)
		return;

	float label_size = ImGui::CalcTextSize("Reloading", NULL, true).x / 2.0f;
	float y2 = cvar.visual_vip && g_Player[index].bVip ? 8 : 0;
	ImGui::GetCurrentWindow()->DrawList->AddText({ x - label_size, y + y2 }, ImColor(0.f, 1.f, 0.f, 1.f), "Reloading");
}

void Sakura::Esp::Player::DrawName(const int index, const float x, const float y)
{
	if (!cvar.visual_name)
		return;

	player_info_s* player = g_Studio.PlayerInfo(index - 1);

	if (!player || !(lstrlenA(player->name) > 0))
		return;

	float label_size = ImGui::CalcTextSize(player->name, NULL, true).x / 2.0f;
	ImGui::GetCurrentWindow()->DrawList->AddText({ x - label_size, y - 16 }, ImColor(1.f, 1.f, 1.f, 1.f), player->name);
}

void Sakura::Esp::Player::DrawWeapon(const int weaponId, const float x, const float y)
{
	model_s* mdl = g_Studio.GetModelByIndex(weaponId);

	if (!cvar.visual_weapon || !mdl)
		return;

	char weapon[256];
	sprintf(weapon, Sakura::Strings::getfilename(mdl->name).c_str() + 2);

	float label_size = ImGui::CalcTextSize(weapon, NULL, true).x / 2.0f;
	ImGui::GetCurrentWindow()->DrawList->AddText({ x - label_size, y }, ImColor(1.f, 1.f, 1.f, 1.f), weapon);
}

void Sakura::Esp::Player::DrawModel(const char* model, const float x, const float y)
{
	if (!cvar.visual_model)
		return;

	float label_size = ImGui::CalcTextSize(model, NULL, true).x / 2.0f;
	float y2 = cvar.visual_weapon ? 8 : 0;
	ImGui::GetCurrentWindow()->DrawList->AddText({ x - label_size, y + y2 }, ImColor(1.f, 1.f, 1.f, 1.f), model);
}

bool bCalcScreen(playeresp_t Esp, float& x, float& y, float& w, float& h, float& xo, float& yo)
{
	float vOrigin[2];
	if (WorldToScreen(Esp.origin, vOrigin))
	{
		xo = IM_ROUND(vOrigin[0]);
		yo = IM_ROUND(vOrigin[1]);
		float x0 = vOrigin[0], x1 = vOrigin[0], y0 = vOrigin[1], y1 = vOrigin[1];
		for (esphitbox_t Hitbox : Esp.PlayerEspHitbox)
		{
			for (unsigned int i = 0; i < 8; i++)
			{
				float vHitbox[2];
				if (WorldToScreen(Hitbox.HitboxMulti[i], vHitbox))
				{
					x0 = min(x0, vHitbox[0]);
					x1 = max(x1, vHitbox[0]);
					y0 = min(y0, vHitbox[1]);
					y1 = max(y1, vHitbox[1]);
				}
			}
		}
		x = IM_ROUND(x0);
		y = IM_ROUND(y0);
		w = IM_ROUND(x1) - IM_ROUND(x0) + 1;
		h = IM_ROUND(y1) - IM_ROUND(y0) + 1;
		return true;
	}
	return false;
}

void Sakura::Esp::Player::Draw()
{
	for (playeresp_t Esp : PlayerEsp)
	{
		if (cvar.visual_idhook_only && IdHook::FirstKillPlayer[Esp.index] == IDHOOK_PLAYER_OFF)
			continue;

		if (!cvar.visual_visual_team && g_Player[Esp.index].iTeam == g_Local.iTeam)
			continue;

		if (!Sakura::Player::IsAlive(Esp.index))
			continue;

		ImRGBA boxColor = Sakura::Colors::GetCustomizedTeamColor(Esp.index, cvar.visual_box_color_tt, cvar.visual_box_color_ct,
			cvar.rainbow_box_tt, cvar.rainbow_box_ct);

		float x, y, w, h, xo, yo;

		if (bCalcScreen(Esp, x, y, w, h, xo, yo))
		{
			DrawBox(x, y, w, h, boxColor);
			DrawHealth(Esp.index, x, y, h);
			DrawReload(Esp.sequence, xo + w, y, Esp.index);
			DrawName(Esp.index, x + (w / 2), y);
			DrawModel(Esp.model, x + (w / 2), y + h);
			DrawWeapon(Esp.weaponmodel, x + (w / 2), y + h);
			DrawVip(Esp.index, x + w, y);
		}
	}
}

void Sakura::Esp::World::DrawBox(const float x, const float y, const float w, const float h)
{
	if (!cvar.visual_box_world) return;

	ImRGBA color = Sakura::Colors::GetCustomizedColor(cvar.visual_box_world_color, cvar.rainbow_world_box);

	if (cvar.visual_box_world_fill > 0) ImGui::GetCurrentWindow()->DrawList->AddRectFilled({ x, y }, { x + w, y + h }, ImColor(color.r, color.g, color.b, cvar.visual_box_world_fill / 100.f));

	switch ((int)cvar.visual_box_world_type)
	{
	case 0:
		Rect({ x - 1, y - 1 }, { w, h }, ImColor(0.f, 0.f, 0.f, color.a));
		Rect({ x - 1, y + 1 }, { w, h }, ImColor(0.f, 0.f, 0.f, color.a));
		Rect({ x + 1, y - 1 }, { w, h }, ImColor(0.f, 0.f, 0.f, color.a));
		Rect({ x + 1, y + 1 }, { w, h }, ImColor(0.f, 0.f, 0.f, color.a));
		Rect({ x, y }, { w, h }, ImColor(color.r, color.g, color.b, color.a));
		break;
	case 1:
		Corners({ x - 1, y - 1 }, { w, h }, ImColor(0.f, 0.f, 0.f, color.a));
		Corners({ x - 1, y + 1 }, { w, h }, ImColor(0.f, 0.f, 0.f, color.a));
		Corners({ x + 1, y - 1 }, { w, h }, ImColor(0.f, 0.f, 0.f, color.a));
		Corners({ x + 1, y + 1 }, { w, h }, ImColor(0.f, 0.f, 0.f, color.a));
		Corners({ x, y }, { w, h }, ImColor(color.r, color.g, color.b, color.a));
		break;
	case 2:
		Coal({ x - 1, y - 1 }, { w, h }, ImColor(0.f, 0.f, 0.f, color.a));
		Coal({ x - 1, y + 1 }, { w, h }, ImColor(0.f, 0.f, 0.f, color.a));
		Coal({ x + 1, y - 1 }, { w, h }, ImColor(0.f, 0.f, 0.f, color.a));
		Coal({ x + 1, y + 1 }, { w, h }, ImColor(0.f, 0.f, 0.f, color.a));
		Coal({ x, y }, { w, h }, ImColor(color.r, color.g, color.b, color.a));
		break;
	}
}

void Sakura::Esp::World::DrawName(const int index, const float x, const float y, const ImU32 color)
{
	if (index < 1 || index > g_Engine.GetMaxClients())
		return;

	if (!cvar.visual_name_world)
		return;

	player_info_s* player = g_Studio.PlayerInfo(index - 1);

	if (!player || !(lstrlenA(player->name) > 0)) 
		return;

	float label_size = ImGui::CalcTextSize(player->name, NULL, true).x / 2;
	ImGui::GetCurrentWindow()->DrawList->AddText({ x - label_size, y }, color, player->name);

	return;
}

void Sakura::Esp::World::DrawModel(const char* name, const float x, const float y, const ImU32 white)
{
	if (!cvar.visual_model_world)
		return;

	char world[256];
	sprintf(world, Sakura::Strings::getfilename(name).c_str() + 2);

	float label_size = ImGui::CalcTextSize(world, NULL, true).x / 2;
	ImGui::GetCurrentWindow()->DrawList->AddText({ x - label_size, y - 16 }, white, world);
}

bool bCalcScreenWorld(worldesp_t Esp, float& x, float& y, float& w, float& h, float& xo, float& yo)
{
	float vOrigin[2];
	if (WorldToScreen(Esp.origin, vOrigin))
	{
		xo = IM_ROUND(vOrigin[0]);
		yo = IM_ROUND(vOrigin[1]);
		float x0 = vOrigin[0], x1 = vOrigin[0], y0 = vOrigin[1], y1 = vOrigin[1];
		for (esphitbox_t Hitbox : Esp.WorldEspHitbox)
		{
			for (unsigned int i = 0; i < 8; i++)
			{
				float vHitbox[2];
				if (WorldToScreen(Hitbox.HitboxMulti[i], vHitbox))
				{
					x0 = min(x0, vHitbox[0]);
					x1 = max(x1, vHitbox[0]);
					y0 = min(y0, vHitbox[1]);
					y1 = max(y1, vHitbox[1]);
				}
			}
		}
		x = IM_ROUND(x0);
		y = IM_ROUND(y0);
		w = IM_ROUND(x1) - IM_ROUND(x0) + 1;
		h = IM_ROUND(y1) - IM_ROUND(y0) + 1;
		return true;
	}
	return false;
}

void Sakura::Esp::World::Draw()
{
	for (worldesp_t Esp : WorldEsp)
	{
		if (!strstr(Esp.name, "w_"))
			continue;

		float x, y, w, h, xo, yo;
		if (bCalcScreenWorld(Esp, x, y, w, h, xo, yo))
		{
			ImU32 teamColor = g_Player[Esp.index].iTeam == 1 ? Sakura::Colors::Red() : Sakura::Colors::Blue();

			DrawBox(x, y, w, h);
			DrawName(Esp.index, x + (w / 2), y + h, teamColor);
			DrawModel(Esp.name, x + (w / 2), y, Sakura::Colors::White());
		}
	}
}
```

`sakura/source/features/visuals/esp/esp.h`:

```h
#ifndef _ESP_
#define _ESP_

typedef struct
{
	Vector HitboxMulti[8];
} esphitbox_t;

typedef struct
{
	Vector Bone;
} espbone_t;

typedef struct
{
	int index;
	int sequence;
	int weaponmodel;
	char model[MAX_MODEL_NAME];
	Vector origin;
	std::deque<esphitbox_t> PlayerEspHitbox;
} playeresp_t;
extern std::deque<playeresp_t> PlayerEsp;

typedef struct
{
	int index;
	Vector origin;
	char name[MAX_MODEL_NAME];
	std::deque<esphitbox_t> WorldEspHitbox;
} worldesp_t;
extern std::deque<worldesp_t> WorldEsp;

typedef struct
{
	Vector origin;
	std::deque<esphitbox_t> WorldEspHitbox;
	std::deque<espbone_t> WorldEspBone;
} worldespprev_t;
extern std::deque<worldespprev_t> WorldEspPrev;

namespace Sakura
{
	namespace Esp
	{
		namespace Player
		{
			void DrawBox(const float x, const float y, const float w, const float h, const ImRGBA color);
			void DrawHealth(const int index, const float x, const float y, const float h);
			void DrawVip(const int index, const float x, const float y);
			void DrawReload(const int index, const int sequence, const float x, const float y);
			void DrawName(const int index, const float x, const float y);
			void DrawWeapon(const int weaponId, const float x, const float y);
			void DrawModel(const char* model, const float x, const float y);
			void Draw();
		};

		namespace World
		{
			void DrawBox(const float x, const float y, const float w, const float h);
			void DrawName(const int index, const float x, const float y, const ImU32 color);
			void DrawModel(const char* name, const float x, const float y, const ImU32 white);
			void Draw();
		};
	};
};

#endif
```

`sakura/source/features/visuals/esp/hitboxes.cpp`:

```cpp
#include "../../../client.h"

int Sakura::Hitboxes::HeadBox[33];
int Sakura::Hitboxes::HitboxBone[33];

std::deque<playermodelfiles_t> PlayerModelFiles;

std::deque<worldbone_t> WorldBone;
std::deque<worldhitbox_t> WorldHitbox;

std::deque<playerbone_t> PlayerBone;
std::deque<playerhitbox_t> PlayerHitbox;
std::deque<playerhitboxnum_t> PlayerHitboxNum;

void Sakura::Hitboxes::TransformVector(Vector in1, float in2[3][4], float* out)
{
	out[0] = DotProduct(in1, in2[0]) + in2[0][3];
	out[1] = DotProduct(in1, in2[1]) + in2[1][3];
	out[2] = DotProduct(in1, in2[2]) + in2[2][3];
}

bool Sakura::Hitboxes::IsShield(const Vector* origin)
{
	int from[12] = { 7, 23, 7, 44, 23, 7, 23, 44, 44, 44, 7, 23 };
	int to[12] = { 8, 27, 8, 52, 27, 8, 27, 52, 52, 52, 8, 27 };

	for (size_t x = 0; x < 12; ++x)
	{
		float fDistance = ((origin[SkeletonHitboxMatrix[x][0]]) - (origin[SkeletonHitboxMatrix[x][1]])).Length();
		int distance = round(fDistance);
		if (distance < from[x] || distance > to[x]) return false;
	}

	return true;
}

bool Sakura::Hitboxes::IsValidModelIndex(const int modelType, const int team)
{
	switch (static_cast<ModelType_e>(modelType))
	{
	case CS_GIGN:
	case CS_GSG9:
	case CS_SAS:
	case CS_URBAN:
	case CS_SPETSNAZ:
		return team == TEAM_CT;
	case CS_LEET:
	case CS_GUERILLA:
	case CS_ARCTIC:
	case CS_TERROR:
	case CS_MILITIA:
		return team == TEAM_TT;
	default:
		break;
	}

	return false;
}

void Sakura::Hitboxes::GetWorldHitboxes(cl_entity_s* ent)
{
	if (!ent)
		return;

	if (!ent->model)
		return;

	if (!ent->model->name)
		return;

	studiohdr_t* pStudioHeader = (studiohdr_t*)g_Studio.Mod_Extradata(ent->model);
	if (!pStudioHeader)
		return;

	mstudiobbox_t* pHitbox = (mstudiobbox_t*)((byte*)pStudioHeader + pStudioHeader->hitboxindex);
	if (!pHitbox)
		return;

	mstudiobone_t* pbones = (mstudiobone_t*)((byte*)pStudioHeader + pStudioHeader->boneindex);
	if (!pbones)
		return;

	BoneMatrix_t* pBoneMatrix = (BoneMatrix_t*)g_Studio.StudioGetBoneTransform();
	if (!pBoneMatrix)
		return;

	if (!strstr(ent->model->name, "w_grenade1.mdl") &&
		!strstr(ent->model->name, "molotov_fire_floor.mdl") &&
		strstr(ent->model->name, "w_") &&
		ent != g_Local.ViewModel)
	{
		if (cvar.skeleton_world_bone)
		{
			for (size_t i = 0; i < pStudioHeader->numbones; ++i)
			{
				worldbone_t Bones;

				Bones.vBone[0] = (*pBoneMatrix)[i][0][3];
				Bones.vBone[1] = (*pBoneMatrix)[i][1][3];
				Bones.vBone[2] = (*pBoneMatrix)[i][2][3];
				Bones.vBoneParent[0] = (*pBoneMatrix)[pbones[i].parent][0][3];
				Bones.vBoneParent[1] = (*pBoneMatrix)[pbones[i].parent][1][3];
				Bones.vBoneParent[2] = (*pBoneMatrix)[pbones[i].parent][2][3];
				Bones.parent = pbones[i].parent;

				WorldBone.push_back(Bones);
			}
		}
		worldesp_t Esp;

		Esp.index = ent->curstate.owner;

		if (pStudioHeader->numbones)
		{
			Esp.origin[0] = (*pBoneMatrix)[0][0][3];
			Esp.origin[1] = (*pBoneMatrix)[0][1][3];
			Esp.origin[2] = (*pBoneMatrix)[0][2][3];
		}
		else
			Esp.origin = ent->origin;

		strcpy(Esp.name, Sakura::Strings::getfilename(ent->model->name).c_str());

		for (size_t i = 0; i < pStudioHeader->numhitboxes; ++i)
		{
			Vector vCubePointsTrans[8], vCubePoints[8];

			vCubePoints[0] = Vector(pHitbox[i].bbmin.x, pHitbox[i].bbmin.y, pHitbox[i].bbmin.z);
			vCubePoints[1] = Vector(pHitbox[i].bbmin.x, pHitbox[i].bbmax.y, pHitbox[i].bbmin.z);
			vCubePoints[2] = Vector(pHitbox[i].bbmax.x, pHitbox[i].bbmax.y, pHitbox[i].bbmin.z);
			vCubePoints[3] = Vector(pHitbox[i].bbmax.x, pHitbox[i].bbmin.y, pHitbox[i].bbmin.z);
			vCubePoints[4] = Vector(pHitbox[i].bbmax.x, pHitbox[i].bbmax.y, pHitbox[i].bbmax.z);
			vCubePoints[5] = Vector(pHitbox[i].bbmin.x, pHitbox[i].bbmax.y, pHitbox[i].bbmax.z);
			vCubePoints[6] = Vector(pHitbox[i].bbmin.x, pHitbox[i].bbmin.y, pHitbox[i].bbmax.z);
			vCubePoints[7] = Vector(pHitbox[i].bbmax.x, pHitbox[i].bbmin.y, pHitbox[i].bbmax.z);

			for (size_t x = 0; x < 8; ++x)
				TransformVector(vCubePoints[x], (*pBoneMatrix)[pHitbox[i].bone], vCubePointsTrans[x]);

			if (cvar.skeleton_world_hitbox)
			{
				worldhitbox_t Hitboxes;

				for (size_t x = 0; x < 8; ++x)
					Hitboxes.vCubePointsTrans[x] = vCubePointsTrans[x];

				WorldHitbox.push_back(Hitboxes);
			}

			esphitbox_t EspHitbox;

			for (size_t x = 0; x < 8; ++x)
				EspHitbox.HitboxMulti[x] = vCubePointsTrans[x];

			Esp.WorldEspHitbox.push_back(EspHitbox);
		}
		WorldEsp.push_back(Esp);
	}

	if (ent == g_Local.ViewModel)
	{
		bool Visuals = Sakura::ScreenShot::IsVisuals();

		if (cvar.skeleton_view_model_hitbox && Visuals)
		{
			glDisable(GL_TEXTURE_2D);
			glEnable(GL_BLEND);
			glEnable(GL_LINE_SMOOTH);
			glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

			ImRGBA viewModelHitboxColor = Sakura::Colors::GetCustomizedColor(cvar.skeleton_view_model_hitbox_color, cvar.rainbow_viewmodel_hitbox);

			for (size_t i = 0; i < pStudioHeader->numhitboxes; ++i)
			{
				Vector vCubePointsTrans[8], vCubePoints[8];

				vCubePoints[0] = Vector(pHitbox[i].bbmin.x, pHitbox[i].bbmin.y, pHitbox[i].bbmin.z);
				vCubePoints[1] = Vector(pHitbox[i].bbmin.x, pHitbox[i].bbmax.y, pHitbox[i].bbmin.z);
				vCubePoints[2] = Vector(pHitbox[i].bbmax.x, pHitbox[i].bbmax.y, pHitbox[i].bbmin.z);
				vCubePoints[3] = Vector(pHitbox[i].bbmax.x, pHitbox[i].bbmin.y, pHitbox[i].bbmin.z);
				vCubePoints[4] = Vector(pHitbox[i].bbmax.x, pHitbox[i].bbmax.y, pHitbox[i].bbmax.z);
				vCubePoints[5] = Vector(pHitbox[i].bbmin.x, pHitbox[i].bbmax.y, pHitbox[i].bbmax.z);
				vCubePoints[6] = Vector(pHitbox[i].bbmin.x, pHitbox[i].bbmin.y, pHitbox[i].bbmax.z);
				vCubePoints[7] = Vector(pHitbox[i].bbmax.x, pHitbox[i].bbmin.y, pHitbox[i].bbmax.z);

				for (size_t x = 0; x < 8; ++x)
					TransformVector(vCubePoints[x], (*pBoneMatrix)[pHitbox[i].bone], vCubePointsTrans[x]);

				glLineWidth(1);
				glColor4f(viewModelHitboxColor.r, viewModelHitboxColor.g, viewModelHitboxColor.b, viewModelHitboxColor.a);

				for (size_t x = 0; x < 12; ++x)
				{
					glBegin(GL_LINES);
					glVertex3fv(vCubePointsTrans[SkeletonHitboxMatrix[x][0]]);
					glVertex3fv(vCubePointsTrans[SkeletonHitboxMatrix[x][1]]);
					glEnd();
				}

				glPointSize(3);
				glColor4f(viewModelHitboxColor.r, viewModelHitboxColor.g, viewModelHitboxColor.b, viewModelHitboxColor.a - 0.3);
				glBegin(GL_POINTS);

				for (size_t x = 0; x < 8; ++x)
					glVertex3fv(vCubePointsTrans[x]);

				glEnd();
			}
			glEnable(GL_TEXTURE_2D);
			glDisable(GL_BLEND);
			glDisable(GL_LINE_SMOOTH);
		}
	}
}

void Sakura::Hitboxes::GetPlayerHitboxes(const cl_entity_s* ent)
{
	if (!ent)
		return;

	if (!ent->player)
		return;

	const int playerIndex = ent->index;

	if (ent == &g_Player[playerIndex].playerHistory ||
		ent == &g_Player[playerIndex].playerDeathMark[0] ||
		ent == &g_Player[playerIndex].playerDeathMark[1])
		return;

	if (playerIndex > 0 && playerIndex <= g_Engine.GetMaxClients())
	{
		static cvar_t* cl_minmodels = g_Engine.pfnGetCvarPointer("cl_minmodels");
		static cvar_t* cl_min_t = g_Engine.pfnGetCvarPointer("cl_min_t");
		static cvar_t* cl_min_ct = g_Engine.pfnGetCvarPointer("cl_min_ct");

		model_s* m_pRenderModel;

		if (cl_minmodels && cl_minmodels->value)
		{
			if (g_Player[playerIndex].iTeam == TEAM_TT)
			{
				int modelindex = (cl_min_t && IsValidModelIndex(cl_min_t->value, TEAM_TT)) ? cl_min_t->value : CS_LEET;
				m_pRenderModel = g_Studio.Mod_ForName(PlayerModelFiles[modelindex].name, false);
			}
			else if (g_Player[playerIndex].iTeam == TEAM_CT)
			{
				if (g_Player[playerIndex].bVip)
				{
					m_pRenderModel = g_Studio.Mod_ForName(PlayerModelFiles[CS_VIP].name, false);
				}
				else
				{
					int modelindex = (cl_min_ct && IsValidModelIndex(cl_min_ct->value, TEAM_CT)) ? cl_min_ct->value : CS_GIGN;
					m_pRenderModel = g_Studio.Mod_ForName(PlayerModelFiles[modelindex].name, false);
				}
			}
		}
		else
			m_pRenderModel = g_Studio.SetupPlayerModel(playerIndex - 1);

		if (!m_pRenderModel)
			return;

		studiohdr_t* pStudioHeader = (studiohdr_t*)g_Studio.Mod_Extradata(m_pRenderModel);
		if (!pStudioHeader)
			return;

		mstudiobbox_t* pHitbox = (mstudiobbox_t*)((byte*)pStudioHeader + pStudioHeader->hitboxindex);
		if (!pHitbox)
			return;

		mstudiobone_t* pbones = (mstudiobone_t*)((byte*)pStudioHeader + pStudioHeader->boneindex);
		if (!pbones)
			return;

		BoneMatrix_t* pBoneMatrix = (BoneMatrix_t*)g_Studio.StudioGetBoneTransform();
		if (!pBoneMatrix)
			return;
		
		HitboxBone[playerIndex] = -1;

		for (size_t i = 0; i < pStudioHeader->numbones; ++i)
		{
			char modelname[255];
			strcpy(modelname, pbones[i].name);
			_strlwr(modelname);
			
			if (strstr(modelname, "head"))
			{
				HitboxBone[playerIndex] = i;
				break;
			}
		}

		if (HitboxBone[playerIndex] != -1)
		{
			bool found = false;

			for (size_t i = 0; i < pStudioHeader->numhitboxes; ++i)
			{
				if (pHitbox[i].bone == HitboxBone[playerIndex])
				{
					found = true;
					HeadBox[playerIndex] = i;
					break;
				}
			}

			if (!found)
				HeadBox[playerIndex] = 0;
		}
		else
			HeadBox[playerIndex] = 0;

		if (cvar.skeleton_player_bone)
		{
			for (size_t i = 0; i < pStudioHeader->numbones; ++i)
			{
				if (pbones[i].parent >= 0)
				{
					playerbone_t Bones;

					Bones.vBone[0] = (*pBoneMatrix)[i][0][3];
					Bones.vBone[1] = (*pBoneMatrix)[i][1][3];
					Bones.vBone[2] = (*pBoneMatrix)[i][2][3];
					Bones.vBoneParent[0] = (*pBoneMatrix)[pbones[i].parent][0][3];
					Bones.vBoneParent[1] = (*pBoneMatrix)[pbones[i].parent][1][3];
					Bones.vBoneParent[2] = (*pBoneMatrix)[pbones[i].parent][2][3];
					Bones.index = playerIndex;

					PlayerBone.push_back(Bones);
				}
			}
		}

		playeresp_t Esp;

		Esp.index = playerIndex;

		if (pStudioHeader->numbones)
		{
			Esp.origin[0] = (*pBoneMatrix)[0][0][3];
			Esp.origin[1] = (*pBoneMatrix)[0][1][3];
			Esp.origin[2] = (*pBoneMatrix)[0][2][3];
		}
		else
			Esp.origin = ent->origin;

		Esp.sequence = ent->curstate.sequence;
		Esp.weaponmodel = ent->curstate.weaponmodel;
		strcpy(Esp.model, Sakura::Strings::getfilename(m_pRenderModel->name).c_str());

		playeraim_t Aim;

		Aim.index = playerIndex;
		Aim.origin = ent->origin;
		Aim.sequence = ent->curstate.sequence;
		strcpy(Aim.modelname, m_pRenderModel->name);

		int numhitboxes = 0;

		for (size_t i = 0; i < pStudioHeader->numhitboxes; ++i)
		{
			Vector vBBMax, vBBMin, vCubePointsTrans[8], vCubePoints[8];
			Vector vEye = pmove->origin + pmove->view_ofs;
			TransformVector(pHitbox[i].bbmin, (*pBoneMatrix)[pHitbox[i].bone], vBBMin);
			TransformVector(pHitbox[i].bbmax, (*pBoneMatrix)[pHitbox[i].bone], vBBMax);

			if (i == 11)
				g_Player[playerIndex].vEye = (vBBMax + vBBMin) * 0.5f + (ent->curstate.origin - ent->prevstate.origin) * (ent->curstate.animtime - ent->prevstate.animtime);

			vCubePoints[0] = Vector(pHitbox[i].bbmin.x, pHitbox[i].bbmin.y, pHitbox[i].bbmin.z);
			vCubePoints[1] = Vector(pHitbox[i].bbmin.x, pHitbox[i].bbmax.y, pHitbox[i].bbmin.z);
			vCubePoints[2] = Vector(pHitbox[i].bbmax.x, pHitbox[i].bbmax.y, pHitbox[i].bbmin.z);
			vCubePoints[3] = Vector(pHitbox[i].bbmax.x, pHitbox[i].bbmin.y, pHitbox[i].bbmin.z);
			vCubePoints[4] = Vector(pHitbox[i].bbmax.x, pHitbox[i].bbmax.y, pHitbox[i].bbmax.z);
			vCubePoints[5] = Vector(pHitbox[i].bbmin.x, pHitbox[i].bbmax.y, pHitbox[i].bbmax.z);
			vCubePoints[6] = Vector(pHitbox[i].bbmin.x, pHitbox[i].bbmin.y, pHitbox[i].bbmax.z);
			vCubePoints[7] = Vector(pHitbox[i].bbmax.x, pHitbox[i].bbmin.y, pHitbox[i].bbmax.z);

			for (size_t x = 0; x < 8; ++x)
				TransformVector(vCubePoints[x], (*pBoneMatrix)[pHitbox[i].bone], vCubePointsTrans[x]);

			if (!IsShield(vCubePointsTrans))
			{
				if (cvar.visual_model_hitbox)
				{
					playerhitboxnum_t HitboxesNum;

					HitboxesNum.HitboxPos = (vBBMax + vBBMin) * 0.5f;
					HitboxesNum.Hitbox = i;

					PlayerHitboxNum.push_back(HitboxesNum);
				}

				if (cvar.skeleton_player_hitbox)
				{
					playerhitbox_t Hitboxes;

					Hitboxes.index = playerIndex;

					for (size_t x = 0; x < 8; ++x)
						Hitboxes.vCubePointsTrans[x] = vCubePointsTrans[x];

					PlayerHitbox.push_back(Hitboxes);
				}

				esphitbox_t EspHitbox;

				for (size_t x = 0; x < 8; ++x)
					EspHitbox.HitboxMulti[x] = vCubePointsTrans[x];

				Esp.PlayerEspHitbox.push_back(EspHitbox);

				playeraimhitbox_t AimHitbox;

				for (size_t x = 0; x < 8; ++x)
				{
					AimHitbox.HitboxMulti[x] = vCubePointsTrans[x];
					AimHitbox.HitboxPointsFOV[x] = g_Local.vPrevForward.AngleBetween(AimHitbox.HitboxMulti[x] - vEye);
				}

				AimHitbox.Hitbox = (vBBMax + vBBMin) * 0.5f;
				AimHitbox.HitboxFOV = g_Local.vPrevForward.AngleBetween(AimHitbox.Hitbox - vEye);
				Aim.PlayerAimHitbox.push_back(AimHitbox);

				numhitboxes++;
			}
		}
		PlayerEsp.push_back(Esp);
		PlayerAim.push_back(Aim);
	}
}

void Sakura::Hitboxes::Get()
{
	cl_entity_s* ent = g_Studio.GetCurrentEntity();

	GetWorldHitboxes(ent);
	GetPlayerHitboxes(ent);
	Snaplines::Draw(ent);
}

void Sakura::Hitboxes::InitPlayerModels()
{
	playermodelfiles_t file;

	sprintf(file.name, /*models/player.mdl*/XorStr<0x6F, 18, 0x4000AC2E>("\x02\x1F\x15\x17\x1F\x07\x5A\x06\x1B\x19\x00\x1F\x09\x52\x10\x1A\x13" + 0x4000AC2E).s);
	PlayerModelFiles.push_back(file);

	sprintf(file.name, /*models/player/leet/leet.mdl*/XorStr<0xD0, 28, 0xE01A4D86>("\xBD\xBE\xB6\xB6\xB8\xA6\xF9\xA7\xB4\xB8\xA3\xBE\xAE\xF2\xB2\xBA\x85\x95\xCD\x8F\x81\x80\x92\xC9\x85\x8D\x86" + 0xE01A4D86).s);
	PlayerModelFiles.push_back(file);

	sprintf(file.name, /*models/player/gign/gign.mdl*/XorStr<0x3A, 28, 0x9B17CB55>("\x57\x54\x58\x58\x52\x4C\x6F\x31\x2E\x22\x3D\x20\x34\x68\x2F\x20\x2D\x25\x63\x2A\x27\x28\x3E\x7F\x3F\x37\x38" + 0x9B17CB55).s);
	PlayerModelFiles.push_back(file);

	sprintf(file.name, /*models/player/vip/vip.mdl*/XorStr<0xE7, 26, 0x1D755FCA>("\x8A\x87\x8D\x8F\x87\x9F\xC2\x9E\x83\x91\x88\x97\x81\xDB\x83\x9F\x87\xD7\x8F\x93\x8B\xD2\x90\x9A\x93" + 0x1D755FCA).s);
	PlayerModelFiles.push_back(file);

	sprintf(file.name, /*models/player/gsg9/gsg9.mdl*/XorStr<0x4B, 28, 0x8EB40DF5>("\x26\x23\x29\x2B\x23\x23\x7E\x22\x3F\x35\x2C\x33\x25\x77\x3E\x29\x3C\x65\x72\x39\x2C\x07\x58\x4C\x0E\x00\x09" + 0x8EB40DF5).s);
	PlayerModelFiles.push_back(file);

	sprintf(file.name, /*models/player/guerilla/guerilla.mdl*/XorStr<0x3C, 36, 0x61A8461B>("\x51\x52\x5A\x5A\x2C\x32\x6D\x33\x28\x24\x3F\x22\x3A\x66\x2D\x3E\x29\x3F\x27\x23\x3C\x30\x7D\x34\x21\x30\x24\x3E\x34\x35\x3B\x75\x31\x39\x32" + 0x61A8461B).s);
	PlayerModelFiles.push_back(file);

	sprintf(file.name, /*models/player/arctic/arctic.mdl*/XorStr<0x0C, 32, 0x97FBDA10>("\x61\x62\x6A\x6A\x7C\x62\x3D\x63\x78\x74\x6F\x72\x6A\x36\x7B\x69\x7F\x69\x77\x7C\x0F\x40\x50\x40\x50\x4C\x45\x09\x45\x4D\x46" + 0x97FBDA10).s);
	PlayerModelFiles.push_back(file);

	sprintf(file.name, /*models/player/sas/sas.mdl*/XorStr<0xA2, 26, 0xD5926CA7>("\xCF\xCC\xC0\xC0\xCA\xD4\x87\xD9\xC6\xCA\xD5\xC8\xDC\x80\xC3\xD0\xC1\x9C\xC7\xD4\xC5\x99\xD5\xDD\xD6" + 0xD5926CA7).s);
	PlayerModelFiles.push_back(file);

	sprintf(file.name, /*models/player/terror/terror.mdl*/XorStr<0x4D, 32, 0xC59B1DBF>("\x20\x21\x2B\x35\x3D\x21\x7C\x24\x39\x37\x2E\x3D\x2B\x75\x2F\x39\x2F\x2C\x30\x12\x4E\x16\x06\x16\x17\x09\x15\x46\x04\x0E\x07" + 0xC59B1DBF).s);
	PlayerModelFiles.push_back(file);

	sprintf(file.name, /*models/player/urban/urban.mdl*/XorStr<0x27, 30, 0xD948B6D7>("\x4A\x47\x4D\x4F\x47\x5F\x02\x5E\x43\x51\x48\x57\x41\x1B\x40\x44\x55\x59\x57\x15\x4E\x4E\x5F\x5F\x51\x6E\x2C\x26\x2F" + 0xD948B6D7).s);
	PlayerModelFiles.push_back(file);

	sprintf(file.name, /*models/player/spetsnaz/spetsnaz.mdl*/XorStr<0x38, 36, 0xA7DC9A3A>("\x55\x56\x5E\x5E\x50\x4E\x11\x4F\x2C\x20\x3B\x26\x36\x6A\x35\x37\x2D\x3D\x39\x25\x2D\x37\x61\x3C\x20\x34\x26\x20\x3A\x34\x2C\x79\x35\x3D\x36" + 0xA7DC9A3A).s);
	PlayerModelFiles.push_back(file);

	sprintf(file.name, /*models/player/militia/militia.mdl*/XorStr<0x17, 34, 0x3D27CA98>("\x7A\x77\x7D\x7F\x77\x6F\x32\x6E\x73\x41\x58\x47\x51\x0B\x48\x4F\x4B\x41\x5D\x43\x4A\x03\x40\x47\x43\x59\x45\x5B\x52\x1A\x58\x52\x5B" + 0x3D27CA98).s);
	PlayerModelFiles.push_back(file);
}

void Sakura::Esp::Player::DrawSkeleton()
{
	if (!Sakura::ScreenShot::IsVisuals())
		return;

	for (playerbone_t Bones : PlayerBone)
	{
		if (cvar.visual_idhook_only && IdHook::FirstKillPlayer[Bones.index] == IDHOOK_PLAYER_OFF)
			continue;

		if (!cvar.visual_visual_team && g_Player[Bones.index].iTeam == g_Local.iTeam)
			continue;

		if (!Sakura::Player::IsAlive(Bones.index))
			continue;

		ImRGBA skeletonColor = Sakura::Colors::GetCustomizedTeamColor(Bones.index, cvar.skeleton_player_bone_color_tt, cvar.skeleton_player_bone_color_ct,
			cvar.rainbow_skeleton_tt, cvar.rainbow_skeleton_ct);

		float CalcAnglesMin[2], CalcAnglesMax[2];
		if (WorldToScreen(Bones.vBone, CalcAnglesMin) && WorldToScreen(Bones.vBoneParent, CalcAnglesMax))
			ImGui::GetCurrentWindow()->DrawList->AddLine({ IM_ROUND(CalcAnglesMin[0]), IM_ROUND(CalcAnglesMin[1]) }, { IM_ROUND(CalcAnglesMax[0]), IM_ROUND(CalcAnglesMax[1]) }, ImColor(skeletonColor.r, skeletonColor.g, skeletonColor.b, skeletonColor.a));
	}

	for (playerhitbox_t Hitbox : PlayerHitbox)
	{
		if (cvar.visual_idhook_only && IdHook::FirstKillPlayer[Hitbox.index] == IDHOOK_PLAYER_OFF)
			continue;

		if (!cvar.visual_visual_team && g_Player[Hitbox.index].iTeam == g_Local.iTeam)
			continue;

		if (!Sakura::Player::IsAlive(Hitbox.index))
			continue;

		ImRGBA hitboxColor = Sakura::Colors::GetCustomizedTeamColor(Hitbox.index, cvar.skeleton_player_hitbox_color_tt, cvar.skeleton_player_hitbox_color_ct);

		for (size_t x = 0; x < 12; ++x)
		{
			float CalcAnglesMin[2], CalcAnglesMax[2];
			if (WorldToScreen(Hitbox.vCubePointsTrans[SkeletonHitboxMatrix[x][0]], CalcAnglesMin) && WorldToScreen(Hitbox.vCubePointsTrans[SkeletonHitboxMatrix[x][1]], CalcAnglesMax))
				ImGui::GetCurrentWindow()->DrawList->AddLine({ IM_ROUND(CalcAnglesMin[0]), IM_ROUND(CalcAnglesMin[1]) }, { IM_ROUND(CalcAnglesMax[0]), IM_ROUND(CalcAnglesMax[1]) }, ImColor(hitboxColor.r, hitboxColor.g, hitboxColor.b, hitboxColor.a));
		}
	}

	for (playerhitboxnum_t HitboxNum : PlayerHitboxNum)
	{
		float CalcAnglesMin[2];
		if (WorldToScreen(HitboxNum.HitboxPos, CalcAnglesMin))
		{
			char str[256];
			sprintf(str, "%d", HitboxNum.Hitbox);
			ImGui::GetCurrentWindow()->DrawList->AddText({ IM_ROUND(CalcAnglesMin[0]), IM_ROUND(CalcAnglesMin[1]) }, Sakura::Colors::White(), str);
		}
	}
}

void Sakura::Esp::World::DrawSkeleton()
{
	const ImRGBA worldBoneColor = Sakura::Colors::GetCustomizedColor(cvar.skeleton_world_bone_color, cvar.rainbow_world_bone);
	const ImRGBA worldHitboxColor = Sakura::Colors::GetCustomizedColor(cvar.skeleton_world_hitbox_color, cvar.rainbow_world_hitbox);

	for (worldbone_t Bone : WorldBone)
	{
		if (Bone.parent >= 0)
		{
			float CalcAnglesMin[2], CalcAnglesMax[2];
			if (WorldToScreen(Bone.vBone, CalcAnglesMin) && WorldToScreen(Bone.vBoneParent, CalcAnglesMax))
				ImGui::GetCurrentWindow()->DrawList->AddLine({ IM_ROUND(CalcAnglesMin[0]), IM_ROUND(CalcAnglesMin[1]) }, { IM_ROUND(CalcAnglesMax[0]), IM_ROUND(CalcAnglesMax[1]) }, ImColor(worldBoneColor.r, worldBoneColor.g, worldBoneColor.b, worldBoneColor.a));

			if (WorldToScreen(Bone.vBoneParent, CalcAnglesMin) && WorldBone[Bone.parent].parent != -1)
				ImGui::GetCurrentWindow()->DrawList->AddRectFilled({ IM_ROUND(CalcAnglesMin[0]) - 1, IM_ROUND(CalcAnglesMin[1]) - 1 }, { IM_ROUND(CalcAnglesMin[0]) + 2, IM_ROUND(CalcAnglesMin[1]) + 2 }, ImColor(worldBoneColor.r, worldBoneColor.g, worldBoneColor.b, worldBoneColor.a - 0.7));
			
			if (WorldToScreen(Bone.vBone, CalcAnglesMin))
				ImGui::GetCurrentWindow()->DrawList->AddRectFilled({ IM_ROUND(CalcAnglesMin[0]) - 1, IM_ROUND(CalcAnglesMin[1]) - 1 }, { IM_ROUND(CalcAnglesMin[0]) + 2, IM_ROUND(CalcAnglesMin[1]) + 2 }, ImColor(worldBoneColor.r, worldBoneColor.g, worldBoneColor.b, worldBoneColor.a - 0.7));
		}
		else
		{
			float CalcAnglesMin[2];
			if (WorldToScreen(Bone.vBone, CalcAnglesMin))
				ImGui::GetCurrentWindow()->DrawList->AddRectFilled({ IM_ROUND(CalcAnglesMin[0]) - 1, IM_ROUND(CalcAnglesMin[1]) - 1 }, { IM_ROUND(CalcAnglesMin[0]) + 2, IM_ROUND(CalcAnglesMin[1]) + 2 }, ImColor(worldBoneColor.r, worldBoneColor.g, worldBoneColor.b, worldBoneColor.a));
		}
	}

	for (worldhitbox_t Hitbox : WorldHitbox)
	{
		for (size_t i = 0; i < 12; ++i)
		{
			float CalcAnglesMin[2], CalcAnglesMax[2];
			if (WorldToScreen(Hitbox.vCubePointsTrans[SkeletonHitboxMatrix[i][0]], CalcAnglesMin) && WorldToScreen(Hitbox.vCubePointsTrans[SkeletonHitboxMatrix[i][1]], CalcAnglesMax))
				ImGui::GetCurrentWindow()->DrawList->AddLine({ IM_ROUND(CalcAnglesMin[0]), IM_ROUND(CalcAnglesMin[1]) }, { IM_ROUND(CalcAnglesMax[0]), IM_ROUND(CalcAnglesMax[1]) }, ImColor(worldHitboxColor.r, worldHitboxColor.g, worldHitboxColor.b, worldHitboxColor.a));
		}

		for (size_t i = 0; i < 8; ++i)
		{
			float CalcAnglesMin[2];
			if (WorldToScreen(Hitbox.vCubePointsTrans[i], CalcAnglesMin))
				ImGui::GetCurrentWindow()->DrawList->AddRectFilled({ IM_ROUND(CalcAnglesMin[0]) - 1, IM_ROUND(CalcAnglesMin[1]) - 1 }, { IM_ROUND(CalcAnglesMin[0]) + 2, IM_ROUND(CalcAnglesMin[1]) + 2 }, ImColor(worldHitboxColor.r, worldHitboxColor.g, worldHitboxColor.b, worldHitboxColor.a - 0.7));
		}
	}
}
```

`sakura/source/features/visuals/esp/hitboxes.h`:

```h
#ifndef _SKELETON_
#define _SKELETON_

typedef struct
{
	int parent;
	Vector vBone;
	Vector vBoneParent;
} worldbone_t;
extern std::deque<worldbone_t> WorldBone;

typedef struct
{
	Vector vCubePointsTrans[8];
} worldhitbox_t;
extern std::deque<worldhitbox_t> WorldHitbox;

typedef struct
{
	int index;
	Vector vBone;
	Vector vBoneParent;
} playerbone_t;
extern std::deque<playerbone_t> PlayerBone;

typedef struct
{
	int index;
	Vector vCubePointsTrans[8];
} playerhitbox_t;
extern std::deque<playerhitbox_t> PlayerHitbox;

typedef struct
{
	int Hitbox;
	Vector HitboxPos;
} playerhitboxnum_t;
extern std::deque<playerhitboxnum_t> PlayerHitboxNum;

typedef struct
{
	char name[64];
} playermodelfiles_t;

namespace Sakura
{
	namespace Esp
	{
		namespace Player
		{
			void DrawSkeleton();
		}

		namespace World
		{
			void DrawSkeleton();
		}
	}

	namespace Hitboxes
	{
		enum {
			HITBOX_BELT,
			HITBOX_LEFT_THIGH,
			HITBOX_LEFT_TIBIA,
			HITBOX_LEFT_FOOT,
			HITBOX_RIGHT_THIGH,
			HITBOX_RIGHT_TIBIA,
			HITBOX_RIGHT_FOOT,
			HITBOX_STOMACH,
			HITBOX_LOWER_CHEST,
			HITBOX_UPPER_CHEST,
			HITBOX_NECK,
			HITBOX_HEAD,
			HITBOX_LEFT_SHOULDER,
			HITBOX_LEFT_ELBOW,
			HITBOX_LEFT_ARM,
			HITBOX_LEFT_HAND,
			HITBOX_RIGHT_SHOULDER,
			HITBOX_RIGHT_ELBOW,
			HITBOX_RIGHT_ARM,
			HITBOX_RIGHT_HAND
		};

		enum ModelType_e
		{
			CS_DEFAULT,
			CS_LEET,
			CS_GIGN,
			CS_VIP,
			CS_GSG9,
			CS_GUERILLA,
			CS_ARCTIC,
			CS_SAS,
			CS_TERROR,
			CS_URBAN,
			CS_SPETSNAZ,
			CS_MILITIA,
		};

		extern int HeadBox[33];
		extern int HitboxBone[33];

		void TransformVector(Vector in1, float in2[3][4], float* out);

		bool IsShield(const Vector* origin);
		bool IsValidModelIndex(const int modelType, const int team);

		void GetWorldHitboxes(cl_entity_s* ent);
		void GetPlayerHitboxes(const cl_entity_s* ent);
		void Get();

		void InitPlayerModels();
	};
};

#endif
```

`sakura/source/features/visuals/esp/radar.cpp`:

```cpp
#include "../../../client.h"

overviewInfo_t m_OverviewData;
int iX, iY, iW, iH;
bool MapLoaded = false;
int xTile = 1, yTile = 1; 
model_s* m_MapSprites;
float RadarAngle[3];
float RadarOrg[3];

int radarPosX = 0;
int radarPosY = 0;
int radarSizeX = 150;
int radarSizeY = 150;

void GetRadarAngle(ref_params_s* pparams)
{
	RadarAngle[0] = pparams->viewangles[0];
	RadarAngle[1] = pparams->viewangles[1];
	RadarAngle[2] = pparams->viewangles[2];
	RadarOrg[0] = pparams->vieworg[0];
	RadarOrg[1] = pparams->vieworg[1];
	RadarOrg[2] = pparams->vieworg[2];
}

bool ParseOverview(char* overview_txt)
{
	m_OverviewData.origin[0] = 0.0f;
	m_OverviewData.origin[1] = 0.0f;
	m_OverviewData.origin[2] = 0.0f;
	m_OverviewData.zoom = 1.0f;
	m_OverviewData.layers = 0;
	m_OverviewData.layersHeights[0] = 0.0f;
	m_OverviewData.layersImages[0][0] = 0;
	char token[1024];
	char* pfile = (char*)g_Engine.COM_LoadFile(overview_txt, 5, NULL);
	if (!pfile)
	{
		MapLoaded = false;
		return false;
	}
	for (;;)
	{
		pfile = g_Engine.COM_ParseFile(pfile, token);
		if (!pfile)
			break;
		if (!_stricmp(token, "global"))
		{
			pfile = g_Engine.COM_ParseFile(pfile, token);
			if (strcmp(token, "{"))
			{
				MapLoaded = false;
				return false;
			}
			pfile = g_Engine.COM_ParseFile(pfile, token);
			if (!pfile)
				break;
			while (strcmp(token, "}"))
			{
				if (!_stricmp(token, "zoom"))
				{
					pfile = g_Engine.COM_ParseFile(pfile, token);
					m_OverviewData.zoom = (float)atof(token);
				}
				else if (!_stricmp(token, "origin"))
				{
					pfile = g_Engine.COM_ParseFile(pfile, token);
					m_OverviewData.origin[0] = (float)atof(token);
					pfile = g_Engine.COM_ParseFile(pfile, token);
					m_OverviewData.origin[1] = (float)atof(token);
					pfile = g_Engine.COM_ParseFile(pfile, token);
					m_OverviewData.origin[2] = (float)atof(token);
				}
				else if (!_stricmp(token, "rotated"))
				{
					pfile = g_Engine.COM_ParseFile(pfile, token);
					m_OverviewData.rotated = atoi(token);
				}
				pfile = g_Engine.COM_ParseFile(pfile, token);
			}
		}
		else if (!_stricmp(token, "layer"))
		{
			pfile = g_Engine.COM_ParseFile(pfile, token);
			if (strcmp(token, "{"))
			{
				MapLoaded = false;
				return false;
			}
			pfile = g_Engine.COM_ParseFile(pfile, token);
			while (strcmp(token, "}"))
			{
				if (!_stricmp(token, "image"))
				{
					pfile = g_Engine.COM_ParseFile(pfile, token);
					strcpy(m_OverviewData.layersImages[m_OverviewData.layers], token);
				}
				else if (!_stricmp(token, "height"))
				{
					pfile = g_Engine.COM_ParseFile(pfile, token);
					float height = (float)atof(token);
					m_OverviewData.layersHeights[m_OverviewData.layers] = height;
				}
				pfile = g_Engine.COM_ParseFile(pfile, token);
			}
			m_OverviewData.layers++;
		}
	}
	return true;
}

void LoadOverview(char* levelname)
{
	static char last_levelname[256] = "";
	char overview_txt[256];

	if (!strcmp(last_levelname, levelname))
		return;

	if (levelname[0] == 0)
		strcpy(levelname, "cs_miltia");

	sprintf(overview_txt, "overviews/%s.txt", levelname);

	if (!ParseOverview(overview_txt))
	{
		strcpy(last_levelname, levelname);
		MapLoaded = false;
		return;
	}

	m_MapSprites = g_Engine.LoadMapSprite(m_OverviewData.layersImages[0]);

	if (!m_MapSprites)
	{
		strcpy(last_levelname, levelname);
		MapLoaded = false;
		return;
	}

	MapLoaded = true;
	int i = (int)sqrt(m_MapSprites->numframes / (4 * 3));
	xTile = i * 4;
	yTile = i * 3;
}

void DrawOverviewLayer()
{
	if (!MapLoaded)
		return;
	if (!cvar.radar)
		return;
	if (!Sakura::ScreenShot::IsVisuals())
		return;

	Vector Org = RadarOrg;
	Vector Angle = RadarAngle;

	glViewport(iX, ImGui::GetIO().DisplaySize.y - (iY + iH), iW, iH);
	if (m_MapSprites) 
	{
		float vStepRight[2], vStepUp[2], inner[2], outer[2];
		float z = ((90.0f - Angle[0]) / 90.0f) * m_OverviewData.layersHeights[0];
		float xStep = (8192.f / cvar.radar_zoom) / xTile;
		float yStep = -(8192.f / (cvar.radar_zoom * (4.f / 3.f))) / yTile;
		float angle = (float)((Angle[1] + 90.0) * (M_PI / 180));
		if (m_OverviewData.rotated)
			angle -= float(M_PI / 2);
		vStepRight[0] = (float)cos(angle) * xStep;
		vStepRight[1] = (float)sin(angle) * xStep;
		vStepUp[0] = (float)cos(angle + (M_PI / 2)) * yStep;
		vStepUp[1] = (float)sin(angle + (M_PI / 2)) * yStep;
		float tile_x, tile_y;
		if (m_OverviewData.rotated) 
		{
			float origin_tilex = (float)(-4.f + m_OverviewData.zoom * (1.0 / 1024.0) * m_OverviewData.origin[0]);
			float origin_tiley = (float)(3.f + m_OverviewData.zoom * (1.0 / 1024.0) * m_OverviewData.origin[1]);
			tile_y = -(float)(origin_tilex - (1.0 / 1024) * m_OverviewData.zoom * Org[0]);
			tile_x = (float)(origin_tiley - (1.0 / 1024) * m_OverviewData.zoom * Org[1]);
		}
		else 
		{ 
			float origin_tilex = (float)(3.f + m_OverviewData.zoom * (1.0 / 1024.0) * m_OverviewData.origin[0]);
			float origin_tiley = (float)(4.f + m_OverviewData.zoom * (1.0 / 1024.0) * m_OverviewData.origin[1]);
			tile_x = (float)(origin_tilex - (1.0 / 1024) * m_OverviewData.zoom * Org[0]);
			tile_y = (float)(origin_tiley - (1.0 / 1024) * m_OverviewData.zoom * Org[1]);
		}
		outer[0] = (ImGui::GetIO().DisplaySize.x / 2) - tile_x * vStepRight[0] - tile_y * vStepUp[0];
		outer[1] = (ImGui::GetIO().DisplaySize.y / 2) - tile_x * vStepRight[1] - tile_y * vStepUp[1];
		g_Engine.pTriAPI->RenderMode(kRenderTransTexture);
		g_Engine.pTriAPI->CullFace(TRI_NONE);
		glEnable(GL_BLEND);
		glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
		for (int ix = 0, frame = 0; ix < yTile; ix++) 
		{
			inner[0] = outer[0];
			inner[1] = outer[1];
			for (int iy = 0; iy < xTile; iy++) 
			{
				g_Engine.pTriAPI->SpriteTexture(m_MapSprites, frame);
				g_Engine.pTriAPI->Begin(TRI_QUADS);
				g_Engine.pTriAPI->TexCoord2f(0, 0);
				g_Engine.pTriAPI->Vertex3f(inner[0], inner[1], z);
				g_Engine.pTriAPI->TexCoord2f(0, 1);
				g_Engine.pTriAPI->Vertex3f(inner[0] + vStepRight[0], inner[1] + vStepRight[1], z);
				g_Engine.pTriAPI->TexCoord2f(1, 1);
				g_Engine.pTriAPI->Vertex3f(inner[0] + vStepRight[0] + vStepUp[0], inner[1] + vStepRight[1] + vStepUp[1], z);
				g_Engine.pTriAPI->TexCoord2f(1, 0);
				g_Engine.pTriAPI->Vertex3f(inner[0] + vStepUp[0], inner[1] + vStepUp[1], z);
				g_Engine.pTriAPI->End();
				frame++;
				inner[0] += vStepUp[0];
				inner[1] += vStepUp[1];
			}
			outer[0] += vStepRight[0];
			outer[1] += vStepRight[1];
		}
		glDisable(GL_BLEND);
	}
	glViewport(0, 0, ImGui::GetIO().DisplaySize.x, ImGui::GetIO().DisplaySize.y);
}

void VectorRotateZ(const float* in, float angle, float* out)
{
	float a, b, c;
	a = (angle * (M_PI / 180));
	b = cos(a);
	c = sin(a);
	out[0] = b * in[0] - c * in[1];
	out[1] = c * in[0] + b * in[1];
}

void DrawOverviewEntities()
{
	if (!cvar.radar)
		return;

	Vector Org = RadarOrg;
	Vector Angle = RadarAngle;

	for (unsigned int i = 1; i <= g_Engine.GetMaxClients(); i++)
	{
		cl_entity_s* ent = g_Engine.GetEntityByIndex(i);

		if (!ent || !ent->player)
			continue;

		if (ent->curstate.messagenum < g_Engine.GetEntityByIndex(pmove->player_index + 1)->curstate.messagenum)
			continue;

		if (!g_Player[ent->index].bAliveInScoreTab)
			continue;

		if (ent->curstate.mins.IsZero())
			continue;

		if (ent->curstate.maxs.IsZero())
			continue;

		if (cvar.visual_idhook_only && IdHook::FirstKillPlayer[ent->index] != 1)
			continue;

		if (!cvar.visual_visual_team && g_Player[ent->index].iTeam == g_Local.iTeam && ent->index != pmove->player_index + 1)
			continue;

		if (g_Player[ent->index].iTeam == 0)
			continue;
		
		Vector origin;
		if (ent->index == pmove->player_index + 1)
			origin = RadarOrg;
		else
			origin = ent->origin;

		float calcscreen[2];
		VectorRotateZ(origin - Org, -Angle[1], calcscreen);
		float screenx = iX + iW / 2 - calcscreen[1] / cvar.radar_zoom * m_OverviewData.zoom * 0.3f * iW / 2 / (ImGui::GetIO().DisplaySize.x / 6.7);
		float screeny = iY + iH / 2 - calcscreen[0] / cvar.radar_zoom * m_OverviewData.zoom * 0.4f * iH / 2 / (ImGui::GetIO().DisplaySize.y / 5.1);

		int boxsize = (cvar.radar_point_size / 2) * 1.4;

		if (screenx > iX + iW / 2 + iW / 2 - boxsize - 2) screenx = iX + iW / 2 + iW / 2 - boxsize - 2;
		if (screenx < iX + iW / 2 - iW / 2 + boxsize + 3) screenx = iX + iW / 2 - iW / 2 + boxsize + 3;
		if (screeny > iY + iH / 2 + iH / 2 - boxsize - 2) screeny = iY + iH / 2 + iH / 2 - boxsize - 2;
		if (screeny < iY + iH / 2 - iH / 2 + boxsize + 3) screeny = iY + iH / 2 - iH / 2 + boxsize + 3;
		
		Vector angles;
		if (ent->index == pmove->player_index + 1)
			angles = RadarAngle;
		else
			angles = ent->angles;

		Vector vforward, vRight, vAngles = Vector(0, -angles[1] + Angle[1] + 90, 0);
		g_Engine.pfnAngleVectors(vAngles, vforward, vRight, NULL);

		ImVec2 center;
		center.x = screenx;
		center.y = screeny;

		float radius = cvar.radar_point_size;

		ImRGBA circleColor = Sakura::Colors::GetTeamColor(g_Player[ent->index].iTeam);

		ImGui::GetWindowDrawList()->AddCircleFilled(center, radius, ImColor(circleColor.r, circleColor.g, circleColor.b, circleColor.a));
	}
}

void DrawOverviewEntitiesSoundIndex()
{
	if (!cvar.radar)
		return;

	Vector Org = RadarOrg;
	Vector Angle = RadarAngle;

	for (player_sound_index_t sound_index : Sound_Index)
	{
		if (GetTickCount() - sound_index.timestamp > 300)
			continue;

		cl_entity_s* ent = g_Engine.GetEntityByIndex(sound_index.index);

		if (!ent)
			continue;

		if (cvar.visual_idhook_only && IdHook::FirstKillPlayer[sound_index.index] != 1)
			continue;

		if (ent->curstate.messagenum == g_Engine.GetEntityByIndex(pmove->player_index + 1)->curstate.messagenum)
			continue;

		if (!cvar.visual_visual_team && g_Player[sound_index.index].iTeam == g_Local.iTeam)
			continue;

		if (g_Player[sound_index.index].iTeam == 0)
			continue;

		if (!g_Player[sound_index.index].bAliveInScoreTab)
			continue;

		float calcscreen[2];
		VectorRotateZ(sound_index.origin - Org, -Angle[1], calcscreen);
		float screenx = IM_ROUND(iX + iW / 2 - calcscreen[1] / cvar.radar_zoom * m_OverviewData.zoom * 0.3f * iW / 2 / (ImGui::GetIO().DisplaySize.x / 6.7));
		float screeny = IM_ROUND(iY + iH / 2 - calcscreen[0] / cvar.radar_zoom * m_OverviewData.zoom * 0.4f * iH / 2 / (ImGui::GetIO().DisplaySize.y / 5.1));

		int boxsize = (cvar.radar_point_size / 2) * 1.4;

		if (screenx > iX + iW / 2 + iW / 2 - boxsize - 2)
			screenx = iX + iW / 2 + iW / 2 - boxsize - 2;
		if (screenx < iX + iW / 2 - iW / 2 + boxsize + 3)
			screenx = iX + iW / 2 - iW / 2 + boxsize + 3;
		if (screeny > iY + iH / 2 + iH / 2 - boxsize - 2)
			screeny = iY + iH / 2 + iH / 2 - boxsize - 2;
		if (screeny < iY + iH / 2 - iH / 2 + boxsize + 3)
			screeny = iY + iH / 2 - iH / 2 + boxsize + 3;

		QAngle QAimAngles;
		VectorAngles(sound_index.origin - Org, QAimAngles);
		Vector vforward, vRight, vAngles = Vector(0, -QAimAngles[1] + Angle[1] - 90, 0);
		g_Engine.pfnAngleVectors(vAngles, vforward, vRight, NULL);

		ImVec2 center;
		center.x = screenx;
		center.y = screeny;

		float radius = cvar.radar_point_size;

		ImRGBA circleColor = Sakura::Colors::GetTeamColor(g_Player[ent->index].iTeam);

		ImGui::GetWindowDrawList()->AddCircleFilled(center, radius, ImColor(circleColor.r, circleColor.g, circleColor.b, circleColor.a));
	}
}

void DrawOverviewEntitiesSoundNoIndex()
{
	if (!cvar.radar)
		return;

	Vector Org = RadarOrg;
	Vector Angle = RadarAngle;

	for (player_sound_no_index_t sound_no_index : Sound_No_Index)
	{
		if (GetTickCount() - sound_no_index.timestamp > 300)
			continue;
		float calcscreen[2];
		VectorRotateZ(sound_no_index.origin - Org, -Angle[1], calcscreen);
		float screenx = IM_ROUND(iX + iW / 2 - calcscreen[1] / cvar.radar_zoom * m_OverviewData.zoom * 0.3f * iW / 2 / (ImGui::GetIO().DisplaySize.x / 6.7));
		float screeny = IM_ROUND(iY + iH / 2 - calcscreen[0] / cvar.radar_zoom * m_OverviewData.zoom * 0.4f * iH / 2 / (ImGui::GetIO().DisplaySize.y / 5.1));

		int boxsize = (cvar.radar_point_size / 2) * 1.4;

		if (screenx > iX + iW / 2 + iW / 2 - boxsize - 2)
			screenx = iX + iW / 2 + iW / 2 - boxsize - 2;
		if (screenx < iX + iW / 2 - iW / 2 + boxsize + 3)
			screenx = iX + iW / 2 - iW / 2 + boxsize + 3;
		if (screeny > iY + iH / 2 + iH / 2 - boxsize - 2)
			screeny = iY + iH / 2 + iH / 2 - boxsize - 2;
		if (screeny < iY + iH / 2 - iH / 2 + boxsize + 3)
			screeny = iY + iH / 2 - iH / 2 + boxsize + 3;

		QAngle QAimAngles;
		VectorAngles(sound_no_index.origin - Org, QAimAngles);
		Vector vforward, vRight, vAngles = Vector(0, -QAimAngles[1] + Angle[1] - 90, 0);
		g_Engine.pfnAngleVectors(vAngles, vforward, vRight, NULL);

		ImVec2 center;
		center.x = screenx;
		center.y = screeny;

		float radius = cvar.radar_point_size;

		ImColor circleColor = Sakura::Colors::Green();

		ImGui::GetWindowDrawList()->AddCircleFilled(center, radius, circleColor);
	}
}

void DrawOverview()
{
	if (cvar.radar)
	{
		ImGui::PushStyleVar(ImGuiStyleVar_WindowMinSize, ImVec2(80.f, 80.f));
		ImGui::PushStyleVar(ImGuiStyleVar_WindowBorderSize, 1.f);
		ImGui::PushStyleVar(ImGuiStyleVar_WindowRounding, 2.f);
		ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(0.f, 0.f));
		ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(0.f, 0.f));
		ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0.f, 0.f));
		ImGui::PushStyleVar(ImGuiStyleVar_ItemInnerSpacing, ImVec2(0.f, 0.f));
		ImGui::PushStyleColor(ImGuiCol_WindowBg, ImVec4(0.f, 0.f, 0.f, 0.f));
		ImGui::SetNextWindowPos(ImVec2(radarPosX, radarPosY), ImGuiCond_Once);
		ImGui::SetNextWindowSize(ImVec2(radarSizeX, radarSizeY), ImGuiCond_Once);
		ImGui::Begin("radaroverview", NULL, ImGuiWindowFlags_NoTitleBar);
		{
			iX = ImGui::GetCursorScreenPos().x;
			iY = ImGui::GetCursorScreenPos().y;
			iW = ImGui::GetContentRegionAvail().x;
			iH = ImGui::GetContentRegionAvail().y;

			static int checkx = ImGui::GetWindowPos().x;
			static int checky = ImGui::GetWindowPos().y;
			static int checkw = ImGui::GetWindowSize().x;
			static int checkh = ImGui::GetWindowSize().y;

			if (!bShowMenu)
			{
				if (checkx != ImGui::GetWindowPos().x ||
					checky != ImGui::GetWindowPos().y ||
					checkw != ImGui::GetWindowSize().x ||
					checkh != ImGui::GetWindowSize().y)
				{
					checkx = ImGui::GetWindowPos().x;
					checky = ImGui::GetWindowPos().y;
					checkw = ImGui::GetWindowSize().x;
					checkh = ImGui::GetWindowSize().y;

					radarPosX = (int)ImGui::GetWindowPos().x;
					radarPosY = (int)ImGui::GetWindowPos().y;
					radarSizeX = (int)ImGui::GetWindowSize().x;
					radarSizeY = (int)ImGui::GetWindowSize().y;

					SaveCvar();
				}
			}
			DrawOverviewEntitiesSoundNoIndex();
			DrawOverviewEntitiesSoundIndex();
			DrawOverviewEntities();
		}
		ImGui::End();
		ImGui::PopStyleColor();
		ImGui::PopStyleVar(7);
	}
}
```

`sakura/source/features/visuals/esp/radar.h`:

```h
#ifndef RADAR_H
#define RADAR_H

typedef struct overviewInfo_s
{
	float	zoom;
	int		layers;
	float	origin[3];
	float	layersHeights[1];
	char	layersImages[1][255];
	int		rotated;
}
overviewInfo_t;

void GetRadarAngle(ref_params_s* pparams);
void DrawOverview(); 
void LoadOverview(char* levelname);
void DrawOverviewLayer();

#endif

```

`sakura/source/features/visuals/esp/snaplines.cpp`:

```cpp
#include "../../../client.h"

void Snaplines::Draw(cl_entity_s* ent)
{
	if (ent && ent->player && Sakura::Player::Local::IsAlive() && cvar.visual_lines && Sakura::Player::IsAlive(ent->index) && Sakura::ScreenShot::IsVisuals())
	{
		if (ent == &g_Player[ent->index].playerHistory || ent == &g_Player[ent->index].playerDeathMark[0] || ent == &g_Player[ent->index].playerDeathMark[1])
			return;

		if (cvar.visual_idhook_only && IdHook::FirstKillPlayer[ent->index] == IDHOOK_PLAYER_OFF)
			return;

		if (!cvar.visual_visual_team && g_Player[ent->index].iTeam == g_Local.iTeam)
			return;

		ImRGBA snaplineColor = Sakura::Colors::GetCustomizedTeamColor(ent->index, cvar.visual_lines_color_tt, cvar.visual_lines_color_ct, cvar.rainbow_snaplines_tt, cvar.rainbow_snaplines_ct);

		Vector localOffsets = cvar.visual_chase_cam ? (pmove->origin + pmove->view_ofs + Vector(0, 0, 10)) : pmove->origin;
		Vector enemyOffsets = cvar.visual_chase_cam ? g_Player[ent->index].vEye : ent->origin;

		glDisable(GL_TEXTURE_2D);
		glEnable(GL_BLEND);
		glEnable(GL_LINE_SMOOTH);
		glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
		glLineWidth(cvar.visual_lines_thickness);
		glColor4f(snaplineColor.r, snaplineColor.g, snaplineColor.b, snaplineColor.a);
		glBegin(GL_LINES);
		glVertex3fv(localOffsets);
		glVertex3fv(enemyOffsets);
		glEnd();
		glEnable(GL_TEXTURE_2D);
		glDisable(GL_BLEND);
		glDisable(GL_LINE_SMOOTH);
	}
}
```

`sakura/source/features/visuals/esp/snaplines.h`:

```h
#pragma once

namespace Snaplines
{
	void Draw(cl_entity_s* ent);
}
```

`sakura/source/features/visuals/light/light.cpp`:

```cpp
#include "../../../client.h"

static float impulseRadius = 0.f;

void Sakura::Light::Entity(alight_s*& plight, const ImRGBA color)
{
	plight->ambientlight = 128;
	plight->shadelight = 192;

	plight->color.x = color.r;
	plight->color.y = color.g;
	plight->color.z = color.b;
}

void Sakura::Light::Studio(alight_s* plight)
{
	if (!Sakura::ScreenShot::IsVisuals())
	{
		g_Studio.StudioEntityLight(plight);
		return;
	}

	cl_entity_s* ent = g_Studio.GetCurrentEntity();

	bool isPlayer = false;
	bool isPlayerFake = false;
	bool isLocalFake = false;
	bool isLocalPlayer = false;
	bool isViewModel = false;
	bool isWorld = false;

	if (ent)
	{
		if (ent->player)
		{
			const int playerIndex = ent->index;

			if (Sakura::Player::IsAlive(playerIndex))
			{
				isPlayer = ent != &g_Player[playerIndex].playerHistory &&
					ent != &g_Player[playerIndex].playerDeathMark[0] &&
					ent != &g_Player[playerIndex].playerDeathMark[1] &&
					(g_Player[playerIndex].iTeam != g_Local.iTeam || cvar.visual_visual_team);

				isPlayerFake = ent == &g_Player[playerIndex].playerHistory;
			}

			if (Sakura::Player::Local::IsAlive())
			{
				isLocalFake = playerIndex == pmove->player_index + 1 &&
					ent == &g_Player[playerIndex].playerHistory;

				isLocalPlayer = playerIndex == pmove->player_index + 1 &&
					ent != &g_Player[playerIndex].playerHistory &&
					ent != &g_Player[playerIndex].playerDeathMark[0] &&
					ent != &g_Player[playerIndex].playerDeathMark[1];
			}
		}

		isViewModel = Sakura::Player::Local::IsAlive() && ent == g_Local.ViewModel;
		isWorld = ent->model && strstr(ent->model->name, "w_") && ent != g_Local.ViewModel;
	}

	if (isLocalPlayer && cvar.visual_lambert_local)
	{
		const ImRGBA localPlayerColor = Colors::GetCustomizedColor(cvar.visual_lambert_color_local, cvar.rainbow_lambert_local);
		Sakura::Light::Entity(plight, localPlayerColor);
	}

	if (isLocalFake && cvar.visual_fakelag_history_local_light)
	{
		const ImRGBA localFakePlayerColor = Sakura::Colors::GetCustomizedColor(cvar.visual_fakelag_history_local_light_color, cvar.rainbow_local_history);
		Sakura::Light::Entity(plight, localFakePlayerColor);
	}

	if (isPlayer && cvar.visual_lambert)
	{
		if (cvar.visual_idhook_only && IdHook::FirstKillPlayer[ent->index] == IDHOOK_PLAYER_OFF)
			return;

		const ImRGBA playerColor = Sakura::Colors::GetCustomizedTeamColor(ent->index, cvar.visual_lambert_color_tt, cvar.visual_lambert_color_ct,
			cvar.rainbow_player_light_tt, cvar.rainbow_player_light_ct);

		Sakura::Light::Entity(plight, playerColor);
	}

	if (isPlayerFake && cvar.misc_backtrack_light)
	{
		const ImRGBA playerFakeColor = Sakura::Colors::GetCustomizedColor(cvar.misc_backtrack_light_color, cvar.rainbow_backtrack_light);
		Sakura::Light::Entity(plight, playerFakeColor);
	}

	if (isWorld && cvar.visual_lambert_world)
	{
		const ImRGBA worldColor = Sakura::Colors::GetCustomizedColor(cvar.visual_lambert_world_color, cvar.rainbow_world_light);
		Sakura::Light::Entity(plight, worldColor);
	}


	if (isViewModel && cvar.visual_lambert_viewmodel)
	{
		const ImRGBA viewModelColor = Sakura::Colors::GetCustomizedColor(cvar.visual_lambert_viewmodel_color, cvar.rainbow_viewmodel_light);
		Sakura::Light::Entity(plight, viewModelColor);
	}

	g_Studio.StudioEntityLight(plight);
}

void Sakura::DynamicLight::Impulse()
{
	static bool plus_or_minus;

	if (impulseRadius <= 0.f || impulseRadius >= 1.f)
		plus_or_minus = !plus_or_minus;

	const float speed = cvar.visual_player_dynamiclight_fading_speed;

	impulseRadius += plus_or_minus ? speed * g_Local.m_flFrameTime : -speed * g_Local.m_flFrameTime;
	impulseRadius = Sakura::Math::Clamp(impulseRadius, 0.f, 1.f);
}

void Sakura::DynamicLight::Light(const cl_entity_s* ent, const ImRGBA color)
{
	dlight_t* dl = g_Engine.pEfxAPI->CL_AllocElight(ent->index);

	dl->origin = ent->origin;
	dl->radius = cvar.visual_player_dynamiclight_radius;

	if (cvar.visual_player_dynamiclight_fading)
		dl->radius *= impulseRadius;

	dl->die = static_cast<float>(client_state->time + 0.01);
	dl->color.r = color.r * 255.f;
	dl->color.g = color.g * 255.f;
	dl->color.b = color.b * 255.f;
}

void Sakura::DynamicLight::Draw()
{
	if (!cvar.visual_player_dynamiclight)
		return;

	Impulse();

	for (int i = 1; i <= g_Engine.GetMaxClients(); i++)
	{
		cl_entity_s* ent = g_Engine.GetEntityByIndex(i);


		if (!ent)
			continue;

		if (!ent->player)
			continue;

		const int playerIndex = ent->index;

		if (ent == &g_Player[playerIndex].playerHistory || ent == &g_Player[playerIndex].playerDeathMark[0] || ent == &g_Player[playerIndex].playerDeathMark[1])
			continue;

		if (!Sakura::Player::IsAlive(playerIndex))
			continue;

		if (ent == g_Local.ViewModel)
			continue;

		if (cvar.visual_idhook_only && IdHook::FirstKillPlayer[playerIndex] == IDHOOK_PLAYER_OFF)
			continue;

		if (g_Player[playerIndex].iTeam == g_Local.iTeam && !cvar.visual_visual_team)
			continue;

		const ImRGBA dynamicLightColor = Sakura::Colors::GetCustomizedTeamColor(playerIndex, cvar.visual_player_dynamiclight_color_tt, cvar.visual_player_dynamiclight_color_ct);

		Sakura::DynamicLight::Light(ent, dynamicLightColor);
	}
}
```

`sakura/source/features/visuals/light/light.h`:

```h
#pragma once

namespace Sakura
{
	namespace Light
	{
		void Entity(alight_s*& plight, const ImRGBA color);
		void Studio(alight_s* plight);
	};

	namespace DynamicLight
	{
		void Impulse();
		void Light(const cl_entity_s* ent, const ImRGBA color);
		void Draw();
	};
};
```

`sakura/source/features/visuals/light/studio.cpp`:

```cpp
#include "../../../client.h"

int StudioCheckBBox(void)
{
	if ((cvar.rage_active && cvar.rage_fov > 45) ||
		(cvar.legit[g_Local.weapon.m_iWeaponID].active && cvar.legit[g_Local.weapon.m_iWeaponID].fov > 45) ||
		(cvar.knifebot_active && cvar.knifebot_fov > 45))
		return 1;
	return g_Studio.StudioCheckBBox();
}

void StudioSetRemapColors(int top, int bottom)
{
	Sakura::Hitboxes::Get();
	g_Studio.StudioSetRemapColors(top, bottom);
}

void StudioDrawPoints()
{
	Sakura::Hands::Remove();
	g_Studio.StudioDrawPoints();
}

void HookStudioFunctions()
{
	g_pStudio->StudioEntityLight = Sakura::Light::Studio;
	g_pStudio->StudioDrawPoints = StudioDrawPoints;
	g_pStudio->StudioSetRemapColors = StudioSetRemapColors;
	g_pStudio->StudioCheckBBox = StudioCheckBBox;
}
```

`sakura/source/features/visuals/light/studio.h`:

```h
#ifndef _STUDIO_
#define _STUDIO_

void HookStudioFunctions();

#endif
```

`sakura/source/features/visuals/local/crosshair.cpp`:

```cpp
#include "../../../client.h"

cvar_t* cl_dynamiccrosshair;
cvar_t* cl_crosshair_size;

int m_iCrosshairScaleBase;

void MakeAngle(float* angle)
{
	static DWORD Tickcount = 0;
	static DWORD Tickcount2 = 0;
	static int m_iAmmoLastCheck;
	static float angles[4] = { 45, 135, 225, 315 };
	static float angles2[4] = { 45, 135, 225, 315 };
	if (g_Local.weapon.m_iShotsFired > m_iAmmoLastCheck)
	{
		Tickcount2 = GetTickCount();
		for (size_t i = 0; i < 4; ++i)
			angles[i] += 90;
	}
	m_iAmmoLastCheck = g_Local.weapon.m_iShotsFired;
	
	if (GetTickCount() - Tickcount2 < 100)
	{
		if (GetTickCount() - Tickcount > 0)
		{
			for (size_t i = 0; i < 4; ++i)
			{
				if (angle[i] < angles[i])
					angle[i] += 15;
			}
			Tickcount = GetTickCount();
		}
	}
	else
	{
		for (size_t i = 0; i < 4; ++i)
			angle[i] = angles2[i];
	}
}

int GetWeaponAccuracyFlags(int iWeaponID)
{
	int flags;

	switch (iWeaponID)
	{
	    case WEAPON_USP:
		{
			flags = (g_Local.weapon.m_iWeaponState & WPNSTATE_USP_SILENCED) < 1 ? 7 : 15;
			break;
		}
		case WEAPON_GLOCK18:
		{
			flags = (g_Local.weapon.m_iWeaponState & WPNSTATE_GLOCK18_BURST_MODE) < 1 ? 7 : 23;
			break;
		}
		case WEAPON_M4A1:
		{
			flags = (g_Local.weapon.m_iWeaponState & WPNSTATE_M4A1_SILENCED) < 1 ? 3 : 11;
			break;
		}
		case WEAPON_FAMAS:
		{
			flags = (g_Local.weapon.m_iWeaponState & WPNSTATE_FAMAS_BURST_MODE) < 1 ? 3 : 19;
			break;
		}
		case WEAPON_MAC10:
		case WEAPON_UMP45:
		case WEAPON_MP5N:
		case WEAPON_TMP:
		{
			flags = 1;
			break;
		}
		case WEAPON_AUG:
		case WEAPON_GALIL:
		case WEAPON_M249:
		case WEAPON_SG552:
		case WEAPON_AK47:
		case WEAPON_P90:
		{
			flags = 3;
			break;
		}
		case WEAPON_P228:
		case WEAPON_FIVESEVEN:
		case WEAPON_DEAGLE:
		{
			flags = 7;
			break;
		}
		default:
		{
			flags = 0;
			break;
		}
	}

	return flags;
}

void CalculateCrosshairSize()
{
	char* value = cl_crosshair_size->string;

	int ScreenWidth = ImGui::GetIO().DisplaySize.x;

	if (!value)
		return;

	int size = atoi(value);

	if (size)
	{
		if (size > 3)
			size = -1;
	}
	else
	{
		if (strcmp(value, "0"))
			size = -1;
	}

	if (!_stricmp(value, "auto"))
		size = 0;
	else if (!_stricmp(value, "small"))
		size = 1;
	else if (!_stricmp(value, "medium"))
		size = 2;
	else if (!_stricmp(value, "large"))
		size = 3;

	if (size == -1)
		return;

	switch (size)
	{
	    case 0:
		{
			if (ScreenWidth >= 1024)
				m_iCrosshairScaleBase = 640;
			else if (ScreenWidth >= 800)
				m_iCrosshairScaleBase = 800;
			else
				m_iCrosshairScaleBase = 1024;

			break;
		}
		case 1:
		{
			m_iCrosshairScaleBase = 1024;
			break;
		}
		case 2:
		{
			m_iCrosshairScaleBase = 800;
			break;
		}
		case 3:
		{
			m_iCrosshairScaleBase = 640;
			break;
		}
	}
}

void DrawCrossHair()
{
	if (cvar.visual_crosshair && Sakura::Player::Local::IsAlive())
	{
		static float angle[4];
		int weaponid = g_Local.weapon.m_iWeaponID;
		int iDistance;
		int iDeltaDistance;
		int iWeaponAccuracyFlags;
		static int iBarSize;
		static float flCrosshairDistance;

		int ScreenWidth = ImGui::GetIO().DisplaySize.x;

		switch (weaponid)
		{
		case WEAPON_P228:
		case WEAPON_HEGRENADE:
		case WEAPON_SMOKEGRENADE:
		case WEAPON_FIVESEVEN:
		case WEAPON_USP:
		case WEAPON_GLOCK18:
		case WEAPON_AWP:
		case WEAPON_FLASHBANG:
		case WEAPON_DEAGLE:
		{
			iDistance = 8;
			iDeltaDistance = 3;
			break;
		}
		case WEAPON_MP5N:
		{
			iDistance = 6;
			iDeltaDistance = 2;
			break;
		}
		case WEAPON_M3:
		{
			iDistance = 8;
			iDeltaDistance = 6;
			break;
		}
		case WEAPON_G3SG1:
		{
			iDistance = 6;
			iDeltaDistance = 4;
			break;
		}
		case WEAPON_AK47:
		{
			iDistance = 4;
			iDeltaDistance = 4;
			break;
		}
		case WEAPON_TMP:
		case WEAPON_KNIFE:
		case WEAPON_P90:
		{
			iDistance = 7;
			iDeltaDistance = 3;
			break;
		}
		case WEAPON_XM1014:
		{
			iDistance = 9;
			iDeltaDistance = 4;
			break;
		}
		case WEAPON_MAC10:
		{
			iDistance = 9;
			iDeltaDistance = 3;
			break;
		}
		case WEAPON_AUG:
		{
			iDistance = 3;
			iDeltaDistance = 3;
			break;
		}
		case WEAPON_C4:
		case WEAPON_UMP45:
		case WEAPON_M249:
		{
			iDistance = 6;
			iDeltaDistance = 4;
			break;
		}
		case WEAPON_SCOUT:
		case WEAPON_SG550:
		case WEAPON_SG552:
		{
			iDistance = 5;
			iDeltaDistance = 3;
			break;
		}
		default:
		{
			iDistance = 4;
			iDeltaDistance = 3;
			break;
		}
		}

		iWeaponAccuracyFlags = GetWeaponAccuracyFlags(weaponid);
		int init = false;
		if (!init)
		{
			cl_dynamiccrosshair = g_Engine.pfnGetCvarPointer("cl_dynamiccrosshair");
			cl_crosshair_size = g_Engine.pfnGetCvarPointer("cl_crosshair_size");
			init = true;
		}
		if (iWeaponAccuracyFlags != 0 && cl_dynamiccrosshair && cl_dynamiccrosshair->value != 0.0)
		{
			if ((pmove->flags & FL_ONGROUND) || !(iWeaponAccuracyFlags & 1))
			{
				if ((pmove->flags & FL_DUCKING) && (iWeaponAccuracyFlags & 4))
				{
					iDistance *= 0.5;
				}
				else
				{
					float flLimitSpeed;

					switch (weaponid)
					{
					case WEAPON_AUG:
					case WEAPON_M4A1:
					case WEAPON_FAMAS:
					case WEAPON_SG550:
					case WEAPON_GALIL:
					case WEAPON_AK47:
					case WEAPON_M249:
					case WEAPON_SG552:
					{
						flLimitSpeed = 140;
						break;
					}
					case WEAPON_P90:
					{
						flLimitSpeed = 170;
						break;
					}
					default:
					{
						flLimitSpeed = 0;
						break;
					}
					}
					if (MySpeed() > flLimitSpeed && (iWeaponAccuracyFlags & 2))
						iDistance *= 1.5;
				}
			}
			else
				iDistance *= 2;

			if (iWeaponAccuracyFlags & 8)
				iDistance *= 1.4;

			if (iWeaponAccuracyFlags & 0x10)
				iDistance *= 1.4;
		}
		static int m_iAmmoLastCheck;
		static float m_flCrosshairDistance;
		int g_iShotsFired = g_Local.weapon.m_iShotsFired;
		if (g_iShotsFired > m_iAmmoLastCheck)
		{
			m_flCrosshairDistance += iDeltaDistance;

			if (m_flCrosshairDistance > 15)
				m_flCrosshairDistance = 15;
		}
		else
		{
			m_flCrosshairDistance -= (0.013 * m_flCrosshairDistance) + 0.1;
		}

		if (g_iShotsFired > 600)
			g_iShotsFired = 1;

		m_iAmmoLastCheck = g_iShotsFired;

		if (iDistance > m_flCrosshairDistance)
			m_flCrosshairDistance = iDistance;

		iBarSize = (int)((m_flCrosshairDistance - (float)iDistance) * 0.5) + 5;
		static DWORD Tickcount;
		if (GetTickCount() - Tickcount > 1000)
		{
			CalculateCrosshairSize();
			Tickcount = GetTickCount();
		}

		flCrosshairDistance = m_flCrosshairDistance;

		if (m_iCrosshairScaleBase != ScreenWidth)
		{
			flCrosshairDistance *= (float)(ScreenWidth) / m_iCrosshairScaleBase;
			iBarSize = (float)(ScreenWidth * iBarSize) / m_iCrosshairScaleBase;
		}

		ImRGBA crosshairColor = Sakura::Colors::GetCustomizedColor(cvar.visual_crosshair_color);

		MakeAngle(angle);
		for (size_t i = 0; i < 4; ++i)
		{
			//float ColorHSV[3];
			//ImGui::ColorConvertRGBtoHSV(color_red, color_green, color_blue, ColorHSV[0], ColorHSV[1], ColorHSV[2]);
			for (size_t x = 0; x < iBarSize; ++x)
			{
				//ColorHSV[0] += 1.0f / iBarSize;
				//if (ColorHSV[0] > 1.0f) ColorHSV[0] -= 1.0f;
				ImVec2 pos1, pos2;
				float radius = flCrosshairDistance + x - 1;
				pos1.x = ImGui::GetIO().DisplaySize.x / 2 - radius * sin(M_PI * 2 * angle[i] / 360);
				pos1.y = ImGui::GetIO().DisplaySize.y / 2 - radius * cos(M_PI * 2 * angle[i] / 360);
				radius++;
				pos2.x = ImGui::GetIO().DisplaySize.x / 2 - radius * sin(M_PI * 2 * angle[i] / 360);
				pos2.y = ImGui::GetIO().DisplaySize.y / 2 - radius * cos(M_PI * 2 * angle[i] / 360);

				ImGui::GetCurrentWindow()->DrawList->AddLine({ pos1.x, pos1.y }, { pos2.x, pos2.y }, ImColor(crosshairColor.r, crosshairColor.g, crosshairColor.b, crosshairColor.a), 2.0f);
			}
		}
	}
}
```

`sakura/source/features/visuals/local/crosshair.h`:

```h
#ifndef _CROSSHAIR_
#define _CROSSHAIR_

void DrawCrossHair();

#endif
```

`sakura/source/features/visuals/local/fov.cpp`:

```cpp
#include "../../../client.h"

float flFov;

void Sakura::FOVS::Aimbot()
{
	if (!Sakura::Player::Local::IsAlive() || !IsCurWeaponGun() || !Sakura::ScreenShot::IsVisuals() || !cvar.legit[g_Local.weapon.m_iWeaponID].active || !cvar.visual_draw_fov || cvar.rage_active)
		return;

	flFov = cvar.legit[g_Local.weapon.m_iWeaponID].fov;

	if (Sakura::Aimbot::m_flCurrentFOV > cvar.legit[g_Local.weapon.m_iWeaponID].fov) flFov = Sakura::Aimbot::m_flCurrentFOV;

	float x = ImGui::GetIO().DisplaySize.x / 2;
	float y = ImGui::GetIO().DisplaySize.y / 2;
	float dx = ImGui::GetIO().DisplaySize.x / g_Local.iFOV;
	float dy = ImGui::GetIO().DisplaySize.y / g_Local.iFOV;


	static double radius[Sakura::Animation::max_count], change_timestamp;
	float current_radius = tanf(DEG2RAD(flFov) * 0.5f) / tanf(DEG2RAD(g_Local.iFOV) * 0.5f) * ImGui::GetIO().DisplaySize.x;

	Sakura::Animation::Calculate(radius, change_timestamp, current_radius, 250.f, 0.2);

	ImVec2 positions;

	positions.x = (x - (dx * g_Local.vNoRecoilAngle[1]));
	positions.y = (y + (dy * g_Local.vNoRecoilAngle[0]));

	for (float angle = 0.f; angle < radius[Sakura::Animation::calculated]; ++angle)
	{
		const float opacity = (0.28 * cvar.visual_draw_fov_color[3]) / radius[Sakura::Animation::calculated] * angle;

		ImGui::GetCurrentWindow()->DrawList->AddCircle({ IM_ROUND(positions.x), IM_ROUND(positions.y) }, angle, ImColor(cvar.visual_draw_fov_color[0], cvar.visual_draw_fov_color[1], cvar.visual_draw_fov_color[2], opacity), 100);
	}
}

void Sakura::FOVS::Spread()
{
	if (!cvar.rage_active)
		return;

	if (!cvar.visual_draw_fov)
		return;

	if (!IsCurWeaponGun())
		return;

	if (!Sakura::Player::Local::IsAlive())
		return;

	float x = ImGui::GetIO().DisplaySize.x / 2;
	float y = ImGui::GetIO().DisplaySize.y / 2;

	static double radius[Sakura::Animation::max_count], change_timestamp;

	float current_radius = g_Local.weapon.m_flSpread > 0 ?
		g_Local.weapon.m_flSpread * 1000.0 / g_Local.iFOV * 90.0 :
		0.0;

	Sakura::Animation::Calculate(radius, change_timestamp, current_radius, 250.f, 0.2);

	if (radius[Sakura::Animation::calculated] < 5.f)
		return;

	for (float angle = 0.f; angle < radius[Sakura::Animation::calculated]; ++angle)
	{
		const float opacity = (0.28 * cvar.visual_draw_fov_color[3]) / radius[Sakura::Animation::calculated] * angle;

		ImGui::GetCurrentWindow()->DrawList->AddCircle({ IM_ROUND(x), IM_ROUND(y) }, angle, ImColor(cvar.visual_draw_fov_color[0], cvar.visual_draw_fov_color[1], cvar.visual_draw_fov_color[2], opacity), 100);
	}

	ImGui::GetCurrentWindow()->DrawList->AddCircle({ IM_ROUND(x), IM_ROUND(y) }, radius[Sakura::Animation::calculated], ImColor(cvar.visual_draw_fov_color[0], cvar.visual_draw_fov_color[1], cvar.visual_draw_fov_color[2], cvar.visual_draw_fov_color[3]), 100);
}
```

`sakura/source/features/visuals/local/fov.h`:

```h
#pragma once

namespace Sakura
{
	namespace FOVS
	{
		void Aimbot();
		void Spread();
	};
};
```

`sakura/source/features/visuals/local/removals/fade.cpp`:

```cpp
#include "../../../../client.h"

float Sakura::Fade::Percentage;
screenfade_t Sakura::Fade::Screen;

void Sakura::Fade::Update()
{
	g_Engine.pfnGetScreenFade(&Screen);
	float flashed;

	if (Screen.fadeEnd > g_Engine.GetClientTime())
		flashed = (Screen.fadeEnd - g_Engine.GetClientTime()) * Screen.fadeSpeed;
	else
		flashed = 0.0f;

	if (flashed > 255.0f) 
		flashed = 255.0f;

	if (flashed < 0.0f) 
		flashed = 0.0f;

	Percentage = (flashed / 255.0f) * 100.0f;
}

void Sakura::Fade::Remove()
{
	if (!cvar.visual_noflash_enable)
		return;

	if (!Sakura::ScreenShot::IsVisuals())
		return;

	if (Screen.fadeEnd <= g_Engine.GetClientTime())
		return;

	screenfade_t tempScreenFade;
	g_Engine.pfnGetScreenFade(&tempScreenFade);

	tempScreenFade.fader = cvar.visual_noflash_color[0] * 255;
	tempScreenFade.fadeg = cvar.visual_noflash_color[1] * 255;
	tempScreenFade.fadeb = cvar.visual_noflash_color[2] * 255;
	tempScreenFade.fadealpha = cvar.visual_noflash_color[3] * 255;

	g_Engine.pfnSetScreenFade(&tempScreenFade);
}

void Sakura::Fade::Logic()
{
	Update();
	Remove();
}
```

`sakura/source/features/visuals/local/removals/fade.h`:

```h
#ifndef _FLASH_
#define _FLASH_

namespace Sakura
{
	namespace Fade
	{
		extern float Percentage;
		extern screenfade_t Screen;

		void Update();
		void Remove();
		void Logic();
	};
};

#endif
```

`sakura/source/features/visuals/local/removals/hands.cpp`:

```cpp
#include "../../../../client.h"

std::deque<viewmodel_t> Sakura::Hands::ViewModel;
std::deque<viewmodeltexture_t> Sakura::Hands::ViewModelTexture;

void Sakura::Hands::Remove()
{
	if (!g_Local.ViewModel || !g_Local.ViewModel->model)
		return;

	studiohdr_t* pStudioHeader = (studiohdr_t*)g_Studio.Mod_Extradata(g_Local.ViewModel->model);

	if (!pStudioHeader)
		return;

	mstudiobodyparts_t* pBodyPart = (mstudiobodyparts_t*)((byte*)pStudioHeader + pStudioHeader->bodypartindex);

	if (!pBodyPart)
		return;

	if (cvar.visual_skins_viewmodel_nohands && Sakura::ScreenShot::IsVisuals())
	{
		for (int k = 0; k < pStudioHeader->numbodyparts; k++)
		{
			mstudiomodel_t* pSubModel = (mstudiomodel_t*)((byte*)pStudioHeader + pBodyPart[k].modelindex);
			for (int i = 0; i < pBodyPart[k].nummodels; i++)
			{
				short* pskinref = (short*)((byte*)pStudioHeader + pStudioHeader->skinindex);
				mstudiotexture_t* ptexture = (mstudiotexture_t*)((byte*)pStudioHeader + pStudioHeader->textureindex);
				mstudiomesh_t* pmesh = (mstudiomesh_t*)((byte*)pStudioHeader + pSubModel[i].meshindex);

				for (int j = pSubModel[i].nummesh - 1; j >= 0; j--)
				{
					for (const viewmodeltexture_t& Tex : ViewModelTexture)
					{
						if (!strcmp(ptexture[pskinref[pmesh[j].skinref]].name, Tex.name))
						{
							bool saved = false;
							for (const viewmodel_t& meshes : ViewModel)
							{
								if (!strcmp(meshes.name, ptexture[pskinref[pmesh[j].skinref]].name) &&
									meshes.meshindex == j && meshes.numbodyparts == k && meshes.nummodels == i &&
									!strcmp(meshes.modelname, g_Local.ViewModel->model->name))
								{
									saved = true;
									break;
								}

							}
							if (!saved)
							{
								viewmodel_t meshes;
								strcpy(meshes.name, ptexture[pskinref[pmesh[j].skinref]].name);
								meshes.meshindex = j;
								meshes.pmesh = pmesh[j];
								meshes.numbodyparts = k;
								meshes.nummodels = i;
								strcpy(meshes.modelname, g_Local.ViewModel->model->name);
								ViewModel.push_back(meshes);
							}

							//LogToFile("DISABLE %s", ptexture[pskinref[pmesh[j].skinref]].name);

							for (int x = j; x < pSubModel[i].nummesh - 1; x++)
							{
								//LogToFile("RECPLACING %s WITH %s", ptexture[pskinref[pmesh[x].skinref]].name, ptexture[pskinref[pmesh[x + 1].skinref]].name);
								pmesh[x] = pmesh[x + 1];
							}
							pSubModel[i].nummesh--;
						}
					}
				}
			}
		}
	}
	else
	{
		for (int i = ViewModel.size() - 1; i >= 0; i--)
		{
			if (!strcmp(ViewModel[i].modelname, g_Local.ViewModel->model->name))
			{
				short* pskinref = (short*)((byte*)pStudioHeader + pStudioHeader->skinindex);
				mstudiotexture_t* ptexture = (mstudiotexture_t*)((byte*)pStudioHeader + pStudioHeader->textureindex);
				mstudiomodel_t* pSubModel = (mstudiomodel_t*)((byte*)pStudioHeader + pBodyPart[ViewModel[i].numbodyparts].modelindex);
				mstudiomesh_t* pmesh = (mstudiomesh_t*)((byte*)pStudioHeader + pSubModel[ViewModel[i].nummodels].meshindex);

				pSubModel[ViewModel[i].nummodels].nummesh++;

				for (int x = pSubModel[ViewModel[i].nummodels].nummesh - 1; x > ViewModel[i].meshindex; x--)
				{
					//LogToFile("RESTORING %s WITH CURRENT %s", ptexture[pskinref[pmesh[x].skinref]].name, ptexture[pskinref[pmesh[x - 1].skinref]].name);
					pmesh[x] = pmesh[x - 1];
				}

				pmesh[ViewModel[i].meshindex] = ViewModel[i].pmesh;

				//LogToFile("ENABLE %s", ptexture[pskinref[pmesh[ViewModel[i].meshindex].skinref]].name);

				ViewModel.erase(ViewModel.begin() + i);
			}
		}
	}
}

void Sakura::Hands::InitTextures()
{
	viewmodeltexture_t Tex;

	sprintf(Tex.name, /*HAND_MALE_LONG.bmp*/XorStr<0x5B, 19, 0x30DCCC50>("\x13\x1D\x13\x1A\x00\x2D\x20\x2E\x26\x3B\x29\x29\x29\x2F\x47\x08\x06\x1C" + 0x30DCCC50).s);
	ViewModelTexture.push_back(Tex);

	sprintf(Tex.name, /*HAND_FEMALE_LONG.bmp*/XorStr<0x48, 21, 0x5C6B114F>("\x00\x08\x04\x0F\x13\x0B\x0B\x02\x11\x1D\x17\x0C\x18\x1A\x18\x10\x76\x3B\x37\x2B" + 0x5C6B114F).s);
	ViewModelTexture.push_back(Tex);

	sprintf(Tex.name, /*by_ramdezz_finger.bmp*/XorStr<0x8F, 22, 0x78291439>("\xED\xE9\xCE\xE0\xF2\xF9\xF1\xF3\xED\xE2\xC6\xFC\xF2\xF2\xFA\xFB\xED\x8E\xC3\xCF\xD3" + 0x78291439).s);
	ViewModelTexture.push_back(Tex);

	sprintf(Tex.name, /*by_ramdezz_skin.BMP*/XorStr<0xCD, 20, 0x0F7595A2>("\xAF\xB7\x90\xA2\xB0\xBF\xB7\xB1\xAF\xAC\x88\xAB\xB2\xB3\xB5\xF2\x9F\x93\x8F" + 0x0F7595A2).s);
	ViewModelTexture.push_back(Tex);

	sprintf(Tex.name, /*by_ramdezz_glove.bmp*/XorStr<0x92, 21, 0x78C9DACB>("\xF0\xEA\xCB\xE7\xF7\xFA\xFC\xFC\xE0\xE1\xC3\xFA\xF2\xF0\xD6\xC4\x8C\xC1\xC9\xD5" + 0x78C9DACB).s);
	ViewModelTexture.push_back(Tex);

	sprintf(Tex.name, /*view_glove.bmp*/XorStr<0x22, 15, 0x034644D3>("\x54\x4A\x41\x52\x79\x40\x44\x46\x5C\x4E\x02\x4F\x43\x5F" + 0x034644D3).s);
	ViewModelTexture.push_back(Tex);

	sprintf(Tex.name, /*view_finger.bmp*/XorStr<0xCC, 16, 0x389A3A1E>("\xBA\xA4\xAB\xB8\x8F\xB7\xBB\xBD\xB3\xB0\xA4\xF9\xBA\xB4\xAA" + 0x389A3A1E).s);
	ViewModelTexture.push_back(Tex);

	sprintf(Tex.name, /*view_skin.BMP*/XorStr<0x15, 14, 0xF04D955C>("\x63\x7F\x72\x6F\x46\x69\x70\x75\x73\x30\x5D\x6D\x71" + 0xF04D955C).s);
	ViewModelTexture.push_back(Tex);

	sprintf(Tex.name, /*view_skin.bmp*/XorStr<0x9C, 14, 0x0F1680CB>("\xEA\xF4\xFB\xE8\xFF\xD2\xC9\xCA\xCA\x8B\xC4\xCA\xD8" + 0x0F1680CB).s);
	ViewModelTexture.push_back(Tex);

	sprintf(Tex.name, /*hands.bmp*/XorStr<0x14, 10, 0x76A56ADD>("\x7C\x74\x78\x73\x6B\x37\x78\x76\x6C" + 0x76A56ADD).s);
	ViewModelTexture.push_back(Tex);

	sprintf(Tex.name, /*CSO_HighQ_Hand_512.BMP*/XorStr<0xAC, 23, 0x07AC324A>("\xEF\xFE\xE1\xF0\xF8\xD8\xD5\xDB\xE5\xEA\xFE\xD6\xD6\xDD\xE5\x8E\x8D\x8F\x90\xFD\x8D\x91" + 0x07AC324A).s);
	ViewModelTexture.push_back(Tex);

	sprintf(Tex.name, /*HighQ_Hand_Long.bmp*/XorStr<0xA2, 20, 0xAD9B2C70>("\xEA\xCA\xC3\xCD\xF7\xF8\xE0\xC8\xC4\xCF\xF3\xE1\xC1\xC1\xD7\x9F\xD0\xDE\xC4" + 0xAD9B2C70).s);
	ViewModelTexture.push_back(Tex);

	sprintf(Tex.name, /*CSO_Girl_Hand.bmp*/XorStr<0x18, 18, 0xF44B9459>("\x5B\x4A\x55\x44\x5B\x74\x6C\x73\x7F\x69\x43\x4D\x40\x0B\x44\x4A\x58" + 0xF44B9459).s);
	ViewModelTexture.push_back(Tex);

	sprintf(Tex.name, /*CSO_Girl_Hand_Long.bmp*/XorStr<0xBC, 23, 0xF9F701C9>("\xFF\xEE\xF1\xE0\x87\xA8\xB0\xAF\x9B\x8D\xA7\xA9\xAC\x96\x86\xA4\xA2\xAA\xE0\xAD\xBD\xA1" + 0xF9F701C9).s);
	ViewModelTexture.push_back(Tex);

	sprintf(Tex.name, /*Arm.bmp*/XorStr<0xFC, 8, 0x4C228B75>("\xBD\x8F\x93\xD1\x62\x6C\x72" + 0x4C228B75).s);
	ViewModelTexture.push_back(Tex);

	sprintf(Tex.name, /*Glove.bmp*/XorStr<0xC0, 10, 0x033C234D>("\x87\xAD\xAD\xB5\xA1\xEB\xA4\xAA\xB8" + 0x033C234D).s);
	ViewModelTexture.push_back(Tex);

	sprintf(Tex.name, /*Thumbs.bmp*/XorStr<0x88, 11, 0x3CA05176>("\xDC\xE1\xFF\xE6\xEE\xFE\xA0\xED\xFD\xE1" + 0x3CA05176).s);
	ViewModelTexture.push_back(Tex);

	sprintf(Tex.name, /*CSO_HighQ_Hand__Long_512.bmp*/XorStr<0x11, 29, 0xF41537B4>("\x52\x41\x5C\x4B\x5D\x7F\x70\x70\x48\x45\x53\x7D\x73\x7A\x40\x7F\x6D\x4D\x4D\x43\x7A\x13\x16\x1A\x07\x48\x46\x5C" + 0xF41537B4).s);
	ViewModelTexture.push_back(Tex);

	sprintf(Tex.name, /*gordon_glove.BMP*/XorStr<0x3D, 17, 0x4A68C26F>("\x5A\x51\x4D\x24\x2E\x2C\x1C\x23\x29\x29\x31\x2D\x67\x08\x06\x1C" + 0x4A68C26F).s);
	ViewModelTexture.push_back(Tex);

	sprintf(Tex.name, /*gordon_sleeve.BMP*/XorStr<0xA0, 18, 0x8FD078C2>("\xC7\xCE\xD0\xC7\xCB\xCB\xF9\xD4\xC4\xCC\xCF\xDD\xC9\x83\xEC\xE2\xE0" + 0x8FD078C2).s);
	ViewModelTexture.push_back(Tex);

	sprintf(Tex.name, /*rubbergloveCHROME.bmp*/XorStr<0x19, 22, 0x6B7E593D>("\x6B\x6F\x79\x7E\x78\x6C\x78\x4C\x4E\x54\x46\x67\x6D\x74\x68\x65\x6C\x04\x49\x41\x5D" + 0x6B7E593D).s);
	ViewModelTexture.push_back(Tex);

	sprintf(Tex.name, /*xbow_sleeve.bmp*/XorStr<0x69, 16, 0xC26D35AA>("\x11\x08\x04\x1B\x32\x1D\x03\x15\x14\x04\x16\x5A\x17\x1B\x07" + 0xC26D35AA).s);
	ViewModelTexture.push_back(Tex);

	sprintf(Tex.name, /*GLOVED_knuckle.bmp*/XorStr<0x8D, 19, 0xEDEB1AEA>("\xCA\xC2\xC0\xC6\xD4\xD6\xCC\xFF\xFB\xE3\xF4\xF3\xF5\xFF\xB5\xFE\xF0\xEE" + 0xEDEB1AEA).s);
	ViewModelTexture.push_back(Tex);

	sprintf(Tex.name, /*GLOVE_handpak.bmp.bmp*/XorStr<0x93, 22, 0x173E20DA>("\xD4\xD8\xDA\xC0\xD2\xC7\xF1\xFB\xF5\xF8\xED\xFF\xF4\x8E\xC3\xCF\xD3\x8A\xC7\xCB\xD7" + 0x173E20DA).s);
	ViewModelTexture.push_back(Tex);

	sprintf(Tex.name, /*CSO_HighQ_Hand__Long_512.BMP*/XorStr<0xF5, 29, 0x589A513E>("\xB6\xA5\xB8\xA7\xB1\x93\x9C\x94\xAC\xA1\xB7\x61\x6F\x66\x5C\x5B\x49\x69\x69\x6F\x56\x3F\x3A\x3E\x23\x4C\x42\x40" + 0x589A513E).s);
	ViewModelTexture.push_back(Tex);

	sprintf(Tex.name, /*CSO_Girl_Hand_long.bmp*/XorStr<0x8A, 23, 0xED044123>("\xC9\xD8\xC3\xD2\xC9\xE6\xE2\xFD\xCD\xDB\xF5\xFB\xF2\xC8\xF4\xF6\xF4\xFC\xB2\xFF\xF3\xEF" + 0xED044123).s);
	ViewModelTexture.push_back(Tex);

	sprintf(Tex.name, /*arms.bmp*/XorStr<0xA5, 9, 0x186DBAF8>("\xC4\xD4\xCA\xDB\x87\xC8\xC6\xDC" + 0x186DBAF8).s);
	ViewModelTexture.push_back(Tex);

	sprintf(Tex.name, /*fingers.bmp*/XorStr<0x57, 12, 0xCA293C5F>("\x31\x31\x37\x3D\x3E\x2E\x2E\x70\x3D\x0D\x11" + 0xCA293C5F).s);
	ViewModelTexture.push_back(Tex);

	sprintf(Tex.name, /*gloves.bmp*/XorStr<0xDE, 11, 0xF6443AC9>("\xB9\xB3\x8F\x97\x87\x90\xCA\x87\x8B\x97" + 0xF6443AC9).s);
	ViewModelTexture.push_back(Tex);

	sprintf(Tex.name, /*hand.bmp*/XorStr<0xEC, 9, 0xE9F2B2F8>("\x84\x8C\x80\x8B\xDE\x93\x9F\x83" + 0xE9F2B2F8).s);
	ViewModelTexture.push_back(Tex);

	sprintf(Tex.name, /*#512512cso_highq_hand__long_512.bmp*/XorStr<0xB9, 36, 0x70E5FE77>("\x9A\x8F\x8A\x8E\x88\x8F\x8D\xA3\xB2\xAD\x9C\xAC\xAC\xA1\xAF\xB9\x96\xA2\xAA\xA2\xA9\x91\x90\xBC\xBE\xBC\xB4\x8B\xE0\xE7\xE5\xF6\xBB\xB7\xAB" + 0x70E5FE77).s);
	ViewModelTexture.push_back(Tex);

	sprintf(Tex.name, /*Serzh_finger.bmp*/XorStr<0x3B, 17, 0xB4B99327>("\x68\x59\x4F\x44\x57\x1F\x27\x2B\x2D\x23\x20\x34\x69\x2A\x24\x3A" + 0xB4B99327).s);
	ViewModelTexture.push_back(Tex);

	sprintf(Tex.name, /*Serzh_skin.bmp*/XorStr<0x7C, 15, 0xE69B2C8F>("\x2F\x18\x0C\x05\xE8\xDE\xF1\xE8\xED\xEB\xA8\xE5\xE5\xF9" + 0xE69B2C8F).s);
	ViewModelTexture.push_back(Tex);

	sprintf(Tex.name, /*Serzh_glove.bmp*/XorStr<0x23, 16, 0x00259CD5>("\x70\x41\x57\x5C\x4F\x77\x4E\x46\x44\x5A\x48\x00\x4D\x5D\x41" + 0x00259CD5).s);
	ViewModelTexture.push_back(Tex);
}
```

`sakura/source/features/visuals/local/removals/hands.h`:

```h
#ifndef _HANDS_
#define _HANDS_

typedef struct
{
	mstudiomesh_t pmesh;
	int meshindex;
	char name[64];
	int numbodyparts;
	int nummodels;
	char modelname[MAX_MODEL_NAME];
} viewmodel_t;

typedef struct
{
	char name[64];
} viewmodeltexture_t;

namespace Sakura
{
	namespace Hands
	{
		extern std::deque<viewmodel_t> ViewModel;
		extern std::deque<viewmodeltexture_t> ViewModelTexture;

		void Remove();
		void InitTextures();
	};
};

#endif
```

`sakura/source/features/visuals/local/removals/scope.cpp`:

```cpp
#include "../../../../client.h"

void Sakura::Scope::Draw()
{
	if (!cvar.visual_remove_scope)
		return;

	if (!g_Local.bScoped)
		return;

	if (!Sakura::Player::Local::IsAlive())
		return;

	ImVec2 wSize = { ImGui::GetIO().DisplaySize.x, ImGui::GetIO().DisplaySize.y };

	ImGui::GetCurrentWindow()->DrawList->AddLine({ wSize.x / 2, 0 }, { wSize.x / 2, wSize.y }, Sakura::Colors::Black());
	ImGui::GetCurrentWindow()->DrawList->AddLine({ 0, wSize.y / 2 }, { wSize.x, wSize.y / 2 }, Sakura::Colors::Black());
}
```

`sakura/source/features/visuals/local/removals/scope.h`:

```h
#pragma once

namespace Sakura
{
	namespace Scope
	{
		void Draw();
	};
};
```

`sakura/source/features/visuals/local/skins/skins.cpp`:

```cpp
#include "../../../../client.h"

#define PLAYER1 31
#define PLAYER2 32
#define PLAYER3 33
#define PLAYER4 34
#define PLAYER5 35
#define PLAYER6 36
#define PLAYER7 37
#define PLAYER8 38

#define BACKPACK1 39

#define THIGHPACK1 40

#define AK471 41
#define AK472 42
#define AK473 43
#define AK474 44
#define AK475 45
#define AK476 46
#define AK477 47
#define AK478 48
#define AK479 49

#define KEVLAR 50

#define AUG1 51
#define AUG2 52
#define AUG3 53
#define AUG4 54

#define AWP1 55
#define AWP2 56
#define AWP3 57
#define AWP4 58
#define AWP5 59
#define AWP6 60
#define AWP7 61
#define AWP8 62
#define AWP9 63
#define AWP10 64
#define AWP11 65

#define C41 66
#define C42 67
#define C43 68
#define C44 69
#define C45 70

#define DEAGLE1 71
#define DEAGLE2 72
#define DEAGLE3 73
#define DEAGLE4 74

#define ELITE1 75
#define ELITE2 76
#define ELITE3 77
#define ELITE4 78
#define ELITE5 79

#define FAMAS1 80
#define FAMAS2 81

#define FIVESEVEN1 82
#define FIVESEVEN2 83
#define FIVESEVEN3 84

#define FLASHBANG1 85
#define FLASHBANG2 86
#define FLASHBANG3 87
#define FLASHBANG4 88
#define FLASHBANG5 89
#define FLASHBANG10 90

#define G3SG11 91
#define G3SG12 92
#define G3SG13 93
#define G3SG14 94
#define G3SG15 95
#define G3SG16 96
#define G3SG17 97
#define G3SG18 98
#define G3SG19 99

#define GALIL1 100
#define GALIL2 101

#define GLOCK181 102
#define GLOCK182 103
#define GLOCK183 104
#define GLOCK184 105
#define GLOCK185 106

#define HEGRENADE1 107
#define HEGRENADE2 108
#define HEGRENADE3 109
#define HEGRENADE4 110
#define HEGRENADE5 111
#define HEGRENADE10 112

#define KNIFE1 113
#define KNIFE2 114

#define M31 115
#define M32 116
#define M33 117
#define M34 118
#define M35 119

#define M4A11 120
#define M4A12 121
#define M4A13 122
#define M4A14 123
#define M4A15 124
#define M4A16 125
#define M4A17 126

#define M2491 127
#define M2492 128
#define M2493 129
#define M2494 130
#define M2495 131
#define M2496 132
#define M2497 133
#define M2498 134
#define M2499 135
#define M24910 136

#define MAC101 137
#define MAC102 138
#define MAC103 139
#define MAC104 140

#define MP51 141
#define MP52 142
#define MP53 143
#define MP54 144
#define MP55 145
#define MP56 146
#define MP57 147
#define MP58 148

#define P901 149
#define P902 150
#define P903 151
#define P904 152
#define P905 153
#define P906 154

#define P2281 155
#define P2282 156
#define P2283 157
#define P2284 158

#define SCOUT1 159
#define SCOUT2 160
#define SCOUT3 161
#define SCOUT4 162
#define SCOUT5 163
#define SCOUT6 164

#define SG5501 165
#define SG5502 166
#define SG5503 167
#define SG5504 168
#define SG5505 169
#define SG5506 170
#define SG5507 171

#define SG5521 172
#define SG5522 173
#define SG5523 174
#define SG5524 175
#define SG5525 176
#define SG5526 177

#define SHIELD1 178
#define SHIELD2 179
#define SHIELD3 180
#define SHIELD31 181

#define SMOKEGRENADE1 182
#define SMOKEGRENADE2 183
#define SMOKEGRENADE3 184
#define SMOKEGRENADE4 185
#define SMOKEGRENADE5 186
#define SMOKEGRENADE10 187

#define TMP1 188
#define TMP2 189
#define TMP3 190
#define TMP4 191
#define TMP5 192
#define TMP6 193
#define TMP7 194
#define TMP8 195
#define TMP9 196
#define TMP10 197

#define UMP451 198
#define UMP452 199
#define UMP453 200
#define UMP454 201

#define USP1 202
#define USP2 203
#define USP3 204
#define USP4 205
#define USP5 206

#define XM10141 207
#define XM10142 208
#define XM10143 209
#define XM10144 210
#define XM10145 211
#define XM10146 212
#define XM10147 213

#define HANDS1 214
#define HANDS39 215
#define HANDS77 216

#define SHELL1 217
#define SHELL2 218
#define SHELL3 219

#define VIPBODY 221
#define VIPHEAD 222
#define VIPBODY2 223
#define VIPHEAD2 224

#define ARCTICBODY 225
#define ARCTICHEAD 226

#define GIGNBODY 227
#define GIGNHEAD 228

#define GSG9BODY 229
#define GSG9HEAD 230

#define GUERILLABODY 231
#define GUERILLAHEAD 232

#define LEETBODY 233
#define LEETHEAD 234

#define SASBODY 235
#define SASHEAD 236

#define TERRORBODY 237
#define TERRORHEAD 238

#define URBANBODY 239
#define URBANHEAD 240
#define URBANCHROME 241

#define CHICKEN 242

bool loadtexturemodel = true;

void GetTextureModel()
{
	Sakura::Texture::Load(/*assets/skins/player/arctic/ARTIC_Working1.bmp*/XorStr<0x59, 46, 0xF15A1086>("\x38\x29\x28\x39\x29\x2D\x70\x13\x0A\x0B\x0D\x17\x4A\x16\x0B\x09\x10\x0F\x19\x43\x0C\x1C\x0C\x04\x18\x11\x5C\x35\x27\x22\x3E\x3B\x26\x2D\x14\x0E\x16\x17\x11\xE7\xB0\xAC\xE1\xE9\xF5" + 0xF15A1086).s, PLAYER1);
	Sakura::Texture::Load(/*assets/skins/player/gign/GIGN_DMBASE2.bmp*/XorStr<0x0B, 42, 0x2B75C729>("\x6A\x7F\x7E\x6B\x7B\x63\x3E\x61\x78\x7D\x7B\x65\x38\x68\x75\x7B\x62\x79\x6F\x31\x78\x49\x46\x4C\x0C\x63\x6C\x61\x69\x77\x6D\x67\x69\x6D\x7E\x6B\x1D\x1E\x53\x5F\x43" + 0x2B75C729).s, PLAYER2);
	Sakura::Texture::Load(/*assets/skins/player/gsg9/GSG9_Working1.bmp*/XorStr<0x16, 43, 0x422D8E71>("\x77\x64\x6B\x7C\x6E\x68\x33\x6E\x75\x76\x4E\x52\x0D\x53\x48\x44\x5F\x42\x5A\x06\x4D\x58\x4B\x14\x01\x68\x63\x76\x0B\x6C\x63\x5A\x44\x5C\x51\x57\x5D\x0A\x12\x5F\x53\x4F" + 0x422D8E71).s, PLAYER3);
	Sakura::Texture::Load(/*assets/skins/player/guerilla/GUERILLA_DMBASE.bmp*/XorStr<0x75, 49, 0xEE8722D0>("\x14\x05\x04\x1D\x0D\x09\x54\x0F\x16\x17\x11\xF3\xAE\xF2\xEF\xE5\xFC\xE3\xF5\xA7\xEE\xFF\xEE\xFE\xE4\xE2\xE3\xF1\xBE\xD5\xC6\xD1\xC7\xDF\xDB\xD4\xD8\xC5\xDF\xD1\xDF\xDF\xCC\xE5\x8F\xC0\xCE\xD4" + 0xEE8722D0).s, PLAYER4);
	Sakura::Texture::Load(/*assets/skins/player/leet/Arab_dmbase1.bmp*/XorStr<0xDF, 42, 0xA21D6AF0>("\xBE\x93\x92\x87\x97\x97\xCA\x95\x8C\x81\x87\x99\xC4\x9C\x81\x8F\x96\x95\x83\xDD\x9F\x91\x90\x82\xD8\xB9\x8B\x9B\x99\xA3\x99\x93\x9D\x61\x72\x67\x32\x2A\x67\x6B\x77" + 0xA21D6AF0).s, PLAYER5);
	Sakura::Texture::Load(/*assets/skins/player/sas/SAS_DMBASE1.bmp*/XorStr<0xA7, 40, 0xB9826153>("\xC6\xDB\xDA\xCF\xDF\xDF\x82\xDD\xC4\xD9\xDF\xC1\x9C\xC4\xD9\xD7\xCE\xDD\xCB\x95\xC8\xDD\xCE\x91\xEC\x81\x92\x9D\x87\x89\x87\x87\x94\x8D\xF8\xE4\xA9\xA1\xBD" + 0xB9826153).s, PLAYER6);
	Sakura::Texture::Load(/*assets/skins/player/terror/Terrorist_Working1.bmp*/XorStr<0xE6, 50, 0x1E2601B0>("\x87\x94\x9B\x8C\x9E\x98\xC3\x9E\x85\x86\x9E\x82\xDD\x83\x98\x94\x8F\x92\x8A\xD6\x8E\x9E\x8E\x8F\x91\x8D\x2F\x55\x67\x71\x76\x6A\x74\x6E\x7B\x7D\x55\x5C\x63\x7F\x65\x66\x7E\x76\x23\x3D\x76\x78\x66" + 0x1E2601B0).s, PLAYER7);
	Sakura::Texture::Load(/*assets/skins/player/urban/SEAL_Working1.bmp*/XorStr<0xA7, 44, 0xC0C4589C>("\xC6\xDB\xDA\xCF\xDF\xDF\x82\xDD\xC4\xD9\xDF\xC1\x9C\xC4\xD9\xD7\xCE\xDD\xCB\x95\xCE\xCE\xDF\xDF\xD1\xEF\x92\x87\x82\x88\x9A\x91\xA8\xBA\xA2\xA3\xA5\xAB\xFC\xE0\xAD\xBD\xA1" + 0xC0C4589C).s, PLAYER8);
	Sakura::Texture::Load(/*assets/skins/player/backpack/Backpack1.bmp*/XorStr<0x89, 43, 0x76E25DD7>("\xE8\xF9\xF8\xE9\xF9\xFD\xA0\xE3\xFA\xFB\xFD\xE7\xBA\xE6\xFB\xF9\xE0\xFF\xE9\xB3\xFF\xFF\xFC\xCB\xD1\xC3\xC0\xCF\x8A\xE4\xC6\xCB\xC2\xDA\xCA\xCF\xC6\x9F\x81\xD2\xDC\xC2" + 0x76E25DD7).s, BACKPACK1);
	Sakura::Texture::Load(/*assets/skins/player/backpack/Backpack2.bmp*/XorStr<0xAF, 43, 0x41F6481C>("\xCE\xC3\xC2\xD7\xC7\xC7\x9A\xC5\xDC\xD1\xD7\xC9\x94\xCC\xD1\xDF\xC6\xA5\xB3\xED\xA1\xA5\xA6\xAD\xB7\xA9\xAA\xA1\xE4\x8E\xAC\xAD\xA4\xA0\xB0\xB1\xB8\xE6\xFB\xB4\xBA\xA8" + 0x41F6481C).s, THIGHPACK1);
	Sakura::Texture::Load(/*assets/skins/weapon/ak47/barrel.bmp*/XorStr<0x6E, 36, 0x1082651C>("\x0F\x1C\x03\x14\x06\x00\x5B\x06\x1D\x1E\x16\x0A\x55\x0C\x19\x1C\x0E\x10\xEE\xAE\xE3\xE8\xB0\xB2\xA9\xE5\xE9\xFB\xF8\xEE\xE0\xA3\xEC\xE2\xE0" + 0x1082651C).s, AK471);
	Sakura::Texture::Load(/*assets/skins/weapon/ak47/forearm.bmp*/XorStr<0xA1, 37, 0xC7D6CFEB>("\xC0\xD1\xD0\xC1\xD1\xD5\x88\xDB\xC2\xC3\xC5\xDF\x82\xD9\xCA\xD1\xC1\xDD\xDD\x9B\xD4\xDD\x83\x8F\x96\xDC\xD4\xCE\xD8\xDF\xCD\xAD\xEF\xA0\xAE\xB4" + 0xC7D6CFEB).s, AK472);
	Sakura::Texture::Load(/*assets/skins/weapon/ak47/handle.bmp*/XorStr<0x09, 36, 0x6DE6E7AD>("\x68\x79\x78\x69\x79\x7D\x20\x63\x7A\x7B\x7D\x67\x3A\x61\x72\x79\x69\x75\x75\x33\x7C\x75\x2B\x17\x0E\x4A\x42\x4A\x41\x4A\x42\x06\x4B\x47\x5B" + 0x6DE6E7AD).s, AK473);
	Sakura::Texture::Load(/*assets/skins/weapon/ak47/lower_body.bmp*/XorStr<0x25, 40, 0xCC1FA995>("\x44\x55\x54\x4D\x5D\x59\x04\x5F\x46\x47\x41\x43\x1E\x45\x56\x55\x45\x59\x59\x17\x58\x51\x0F\x0B\x12\x52\x50\x37\x24\x30\x1C\x26\x2A\x22\x3E\x66\x2B\x27\x3B" + 0xCC1FA995).s, AK474);
	Sakura::Texture::Load(/*assets/skins/weapon/ak47/magazine.bmp*/XorStr<0x93, 38, 0xF4723E89>("\xF2\xE7\xE6\xF3\xE3\xEB\xB6\xE9\xF0\xF5\xF3\xED\xB0\xD7\xC4\xC3\xD3\xCB\xCB\x89\xC6\xC3\x9D\x9D\x84\xC1\xCC\xC9\xCE\xCA\xD8\xDC\xD6\x9A\xD7\xDB\xC7" + 0xF4723E89).s, AK475);
	Sakura::Texture::Load(/*assets/skins/weapon/ak47/reticle.bmp*/XorStr<0xE4, 37, 0x3A21E5A0>("\x85\x96\x95\x82\x9C\x9A\xC5\x98\x87\x84\x80\x9C\xDF\x86\x97\x92\x84\x9A\x98\xD8\x99\x92\xCE\xCC\xD3\x8F\x9B\x8B\x69\x62\x6E\x66\x2A\x67\x6B\x77" + 0x3A21E5A0).s, AK476);
	Sakura::Texture::Load(/*assets/skins/weapon/ak47/upper_body.bmp*/XorStr<0xC6, 40, 0x120DE9D3>("\xA7\xB4\xBB\xAC\xBE\xB8\xE3\xBE\xA5\xA6\xBE\xA2\xFD\xA4\xB1\xB4\xA6\xB8\xB6\xF6\xBB\xB0\xE8\xEA\xF1\xAA\x90\x91\x87\x91\xBB\x87\x89\x83\x91\xC7\x88\x86\x9C" + 0x120DE9D3).s, AK477);
	Sakura::Texture::Load(/*assets/skins/weapon/ak47/wood.bmp*/XorStr<0xEE, 34, 0x503CD009>("\x8F\x9C\x83\x94\x86\x80\xDB\x86\x9D\x9E\x96\x8A\xD5\x8C\x99\x9C\x8E\x90\x6E\x2E\x63\x68\x30\x32\x29\x70\x67\x66\x6E\x25\x6E\x60\x7E" + 0x503CD009).s, AK478);
	Sakura::Texture::Load(/*assets/skins/weapon/ak47/ak47_skin.bmp*/XorStr<0xE5, 39, 0x07DBAC39>("\x84\x95\x94\x8D\x9D\x99\xC4\x9F\x86\x87\x81\x83\xDE\x85\x96\x95\x85\x99\x99\xD7\x98\x91\xCF\xCB\xD2\x9F\x94\x34\x36\x5D\x70\x6F\x6C\x68\x29\x6A\x64\x7A" + 0x07DBAC39).s, AK479);
	Sakura::Texture::Load(/*assets/skins/weapon/assault/kevlar_vest.bmp*/XorStr<0xA4, 44, 0xA3CB2BAE>("\xC5\xD6\xD5\xC2\xDC\xDA\x85\xD8\xC7\xC4\xC0\xDC\x9F\xC6\xD7\xD2\xC4\xDA\xD8\x98\xD9\xCA\xC9\xDA\xC9\xD1\xCA\x90\xAB\xA4\xB4\xAF\xA5\xB7\x99\xB1\xAD\xBA\xBE\xE5\xAE\xA0\xBE" + 0xA3CB2BAE).s, KEVLAR);
	Sakura::Texture::Load(/*assets/skins/weapon/aug/barrel.bmp*/XorStr<0xFF, 35, 0xA741EBA9>("\x9E\x73\x72\x67\x77\x77\x2A\x75\x6C\x61\x67\x79\x24\x7B\x68\x6F\x7F\x7F\x7F\x3D\x72\x61\x72\x39\x75\x79\x6B\x68\x7E\x70\x33\x7C\x72\x50" + 0xA741EBA9).s, AUG1);
	Sakura::Texture::Load(/*assets/skins/weapon/aug/body.bmp*/XorStr<0x97, 33, 0xEC87211C>("\xF6\xEB\xEA\xFF\xEF\xEF\xB2\xED\xF4\xC9\xCF\xD1\x8C\xD3\xC0\xC7\xD7\xC7\xC7\x85\xCA\xD9\xCA\x81\xCD\xDF\xD5\xCB\x9D\xD6\xD8\xC6" + 0xEC87211C).s, AUG2);
	Sakura::Texture::Load(/*assets/skins/weapon/aug/magazine.bmp*/XorStr<0x06, 37, 0xE0276A88>("\x67\x74\x7B\x6C\x7E\x78\x23\x7E\x65\x66\x7E\x62\x3D\x64\x71\x74\x66\x78\x76\x36\x7B\x6E\x7B\x32\x73\x7E\x47\x40\x58\x4A\x4A\x40\x08\x45\x45\x59" + 0xE0276A88).s, AUG3);
	Sakura::Texture::Load(/*assets/skins/weapon/aug/w_aug.bmp*/XorStr<0x91, 34, 0x7D3622E9>("\xF0\xE1\xE0\xF1\xE1\xE5\xB8\xEB\xF2\xF3\xF5\xEF\xB2\xE9\xFA\xC1\xD1\xCD\xCD\x8B\xC4\xD3\xC0\x87\xDE\xF5\xCA\xD9\xCA\x80\xCD\xDD\xC1" + 0x7D3622E9).s, AUG4);
	Sakura::Texture::Load(/*assets/skins/weapon/awp/barrel.bmp*/XorStr<0xE8, 35, 0xA96C9625>("\x89\x9A\x99\x8E\x98\x9E\xC1\x9C\x9B\x98\x9C\x80\xDB\x82\x93\x96\x88\x96\x94\xD4\x9D\x8A\x8E\xD0\x62\x60\x70\x71\x61\x69\x28\x65\x65\x79" + 0xA96C9625).s, AWP1);
	Sakura::Texture::Load(/*assets/skins/weapon/awp/base.bmp*/XorStr<0x21, 33, 0x43F3171F>("\x40\x51\x50\x41\x51\x55\x08\x5B\x42\x43\x45\x5F\x02\x59\x4A\x51\x41\x5D\x5D\x1B\x54\x41\x47\x17\x5B\x5B\x48\x59\x13\x5C\x52\x30" + 0x43F3171F).s, AWP2);
	Sakura::Texture::Load(/*assets/skins/weapon/awp/bolt_handle.bmp*/XorStr<0x1C, 40, 0xA941C980>("\x7D\x6E\x6D\x7A\x54\x52\x0D\x50\x4F\x4C\x48\x54\x07\x5E\x4F\x4A\x5C\x42\x40\x00\x51\x46\x42\x1C\x56\x5A\x5A\x43\x67\x51\x5B\x55\x58\x51\x5B\x11\x22\x2C\x32" + 0xA941C980).s, AWP3);
	Sakura::Texture::Load(/*assets/skins/weapon/awp/buttstock.bmp*/XorStr<0x7E, 38, 0x81AF21EC>("\x1F\x0C\xF3\xE4\xF6\xF0\xAB\xF6\xED\xEE\xE6\xFA\xA5\xFC\xE9\xEC\xFE\xE0\xFE\xBE\xF3\xE4\xE4\xBA\xF4\xE2\xEC\xED\xE9\xEF\xF3\xFE\xF5\xB1\xC2\xCC\xD2" + 0x81AF21EC).s, AWP4);
	Sakura::Texture::Load(/*assets/skins/weapon/awp/ejector_port.bmp*/XorStr<0xDF, 41, 0xA579366E>("\xBE\x93\x92\x87\x97\x97\xCA\x95\x8C\x81\x87\x99\xC4\x9B\x88\x8F\x9F\x9F\x9F\xDD\x92\x83\x85\xD9\x92\x92\x9C\x99\x8F\x93\x8F\xA1\x8F\x6F\x73\x76\x2D\x66\x68\x76" + 0xA579366E).s, AWP5);
	Sakura::Texture::Load(/*assets/skins/weapon/awp/magazine.bmp*/XorStr<0x0E, 37, 0x612A8C48>("\x6F\x7C\x63\x74\x66\x60\x3B\x66\x7D\x7E\x76\x6A\x35\x6C\x79\x7C\x6E\x70\x4E\x0E\x43\x54\x54\x0A\x4B\x46\x4F\x48\x50\x42\x42\x48\x00\x4D\x5D\x41" + 0x612A8C48).s, AWP6);
	Sakura::Texture::Load(/*assets/skins/weapon/awp/newparts.bmp*/XorStr<0x9B, 37, 0xC7E91293>("\xFA\xEF\xEE\xFB\xEB\xD3\x8E\xD1\xC8\xCD\xCB\xD5\x88\xDF\xCC\xCB\xDB\xC3\xC3\x81\xCE\xC7\xC1\x9D\xDD\xD1\xC2\xC6\xD6\xCA\xCD\xC9\x95\xDE\xD0\xCE" + 0xC7E91293).s, AWP7);
	Sakura::Texture::Load(/*assets/skins/weapon/awp/newparts2.bmp*/XorStr<0x9A, 38, 0xD3B49CA7>("\xFB\xE8\xEF\xF8\xEA\xEC\x8F\xD2\xC9\xCA\xCA\xD6\x89\xD0\xCD\xC8\xDA\xC4\xC2\x82\xCF\xD8\xC0\x9E\xDC\xD6\xC3\xC5\xD7\xC5\xCC\xCA\x88\x95\xDE\xD0\xCE" + 0xD3B49CA7).s, AWP8);
	Sakura::Texture::Load(/*assets/skins/weapon/awp/scope.bmp*/XorStr<0x4F, 34, 0xFAA48E3B>("\x2E\x23\x22\x37\x27\x27\x7A\x25\x3C\x31\x37\x29\x74\x2B\x38\x3F\x2F\x0F\x0F\x4D\x02\x13\x15\x49\x14\x0B\x06\x1A\x0E\x42\x0F\x03\x1F" + 0xFAA48E3B).s, AWP9);
	Sakura::Texture::Load(/*assets/skins/weapon/awp/scope_clamps.bmp*/XorStr<0x9A, 41, 0x56A569E5>("\xFB\xE8\xEF\xF8\xEA\xEC\x8F\xD2\xC9\xCA\xCA\xD6\x89\xD0\xCD\xC8\xDA\xC4\xC2\x82\xCF\xD8\xC0\x9E\xC1\xD0\xDB\xC5\xD3\xE8\xDB\xD5\xDB\xD6\xCC\xCE\x90\xDD\xAD\xB1" + 0x56A569E5).s, AWP10);
	Sakura::Texture::Load(/*assets/skins/weapon/awp/w_awp.bmp*/XorStr<0x5D, 34, 0x4FA369EC>("\x3C\x2D\x2C\x05\x15\x11\x4C\x17\x0E\x0F\x09\x1B\x46\x1D\x0E\x0D\x1D\x01\x01\x5F\x10\x05\x03\x5B\x02\x29\x16\x0F\x09\x54\x19\x11\x0D" + 0x4FA369EC).s, AWP11);
	Sakura::Texture::Load(/*assets/skins/weapon/c4/c4base.bmp*/XorStr<0x0E, 34, 0xBCE78ED5>("\x6F\x7C\x63\x74\x66\x60\x3B\x66\x7D\x7E\x76\x6A\x35\x6C\x79\x7C\x6E\x70\x4E\x0E\x41\x17\x0B\x46\x12\x45\x49\x5A\x4F\x05\x4E\x40\x5E" + 0xBCE78ED5).s, C41);
	Sakura::Texture::Load(/*assets/skins/weapon/c4/c4buttons.bmp*/XorStr<0xE3, 37, 0x9C678852>("\x82\x97\x96\x83\x93\x9B\xC6\x99\x80\x85\x83\x9D\xC0\x87\x94\x93\x83\x9B\x9B\xD9\x94\xCC\xD6\x99\xCF\x9E\x88\x8A\x8B\x6F\x6F\x71\x2D\x66\x68\x76" + 0x9C678852).s, C42);
	Sakura::Texture::Load(/*assets/skins/weapon/c4/c4timer.bmp*/XorStr<0x8F, 35, 0x77EF8D64>("\xEE\xE3\xE2\xF7\xE7\xE7\xBA\xE5\xFC\xF1\xF7\xE9\xB4\xEB\xF8\xFF\xEF\xCF\xCF\x8D\xC0\x90\x8A\xC5\x93\xDC\xC0\xC7\xCE\xDE\x83\xCC\xC2\xC0" + 0x77EF8D64).s, C43);
	Sakura::Texture::Load(/*assets/skins/weapon/c4/c4wires.bmp*/XorStr<0x19, 35, 0xB4FBDEDF>("\x78\x69\x68\x79\x69\x6D\x30\x53\x4A\x4B\x4D\x57\x0A\x51\x42\x49\x59\x45\x45\x03\x4E\x1A\x00\x53\x05\x45\x5A\x46\x50\x45\x19\x5A\x54\x4A" + 0xB4FBDEDF).s, C44);
	Sakura::Texture::Load(/*assets/skins/weapon/c4/cbase_front.bmp*/XorStr<0xF8, 39, 0xC7044BA3>("\x99\x8A\x89\x9E\x88\x8E\xD1\x8C\x6B\x68\x6C\x70\x2B\x72\x63\x66\x78\x66\x64\x24\x6F\x39\x21\x6C\x72\x70\x61\x76\x4B\x73\x64\x78\x76\x6D\x34\x79\x71\x6D" + 0xC7044BA3).s, C45);
	Sakura::Texture::Load(/*assets/skins/weapon/deagle/DE_handle.bmp*/XorStr<0xEE, 41, 0x32193C5A>("\x8F\x9C\x83\x94\x86\x80\xDB\x86\x9D\x9E\x96\x8A\xD5\x8C\x99\x9C\x8E\x90\x6E\x2E\x66\x66\x65\x62\x6A\x62\x27\x4D\x4F\x54\x64\x6C\x60\x6B\x7C\x74\x3C\x71\x79\x65" + 0x32193C5A).s, DEAGLE1);
	Sakura::Texture::Load(/*assets/skins/weapon/deagle/DE_slide1.bmp*/XorStr<0xE6, 41, 0x1C7FF6D4>("\x87\x94\x9B\x8C\x9E\x98\xC3\x9E\x85\x86\x9E\x82\xDD\x84\x91\x94\x86\x98\x96\xD6\x9E\x9E\x9D\x9A\x92\x9A\x2F\x45\x47\x5C\x77\x69\x6F\x63\x6D\x38\x24\x69\x61\x7D" + 0x1C7FF6D4).s, DEAGLE2);
	Sakura::Texture::Load(/*assets/skins/weapon/deagle/DE_slide2_eagle.bmp*/XorStr<0x7D, 47, 0x0ED63FF9>("\x1C\x0D\x0C\xE5\xF5\xF1\xAC\xF7\xEE\xEF\xE9\xFB\xA6\xFD\xEE\xED\xFD\xE1\xE1\xBF\xF5\xF7\xF2\xF3\xF9\xF3\xB8\xDC\xDC\xC5\xE8\xF0\xF4\xFA\xFA\x92\xFE\xC7\xC2\xC3\xC9\xC3\x89\xCA\xC4\xDA" + 0x0ED63FF9).s, DEAGLE3);
	Sakura::Texture::Load(/*assets/skins/weapon/deagle/deserteagle_skin.bmp*/XorStr<0x85, 48, 0x9CEA57D5>("\xE4\xF5\xF4\xED\xFD\xF9\xA4\xFF\xE6\xE7\xE1\xE3\xBE\xE5\xF6\xF5\xE5\xF9\xF9\xB7\xFD\xFF\xFA\xFB\xF1\xFB\xB0\xC4\xC4\xD1\xC6\xD6\xD1\xC3\xC6\xCF\xC5\xCF\xF4\xDF\xC6\xC7\xC1\x9E\xD3\xDF\xC3" + 0x9CEA57D5).s, DEAGLE4);
	Sakura::Texture::Load(/*assets/skins/weapon/elite/barrel.bmp*/XorStr<0x56, 37, 0x1BD60FD6>("\x37\x24\x2B\x3C\x2E\x28\x73\x2E\x35\x36\x0E\x12\x4D\x14\x01\x04\x16\x08\x06\x46\x0F\x07\x05\x19\x0B\x40\x12\x10\x00\x01\x11\x19\x58\x15\x15\x09" + 0x1BD60FD6).s, ELITE1);
	Sakura::Texture::Load(/*assets/skins/weapon/elite/handle.bmp*/XorStr<0xA4, 37, 0xAD136411>("\xC5\xD6\xD5\xC2\xDC\xDA\x85\xD8\xC7\xC4\xC0\xDC\x9F\xC6\xD7\xD2\xC4\xDA\xD8\x98\xDD\xD5\xD3\xCF\xD9\x92\xD6\xDE\xAE\xA5\xAE\xA6\xEA\xA7\xAB\xB7" + 0xAD136411).s, ELITE2);
	Sakura::Texture::Load(/*assets/skins/weapon/elite/magazine.bmp*/XorStr<0x1F, 39, 0x9440311C>("\x7E\x53\x52\x47\x57\x57\x0A\x55\x4C\x41\x47\x59\x04\x5B\x48\x4F\x5F\x5F\x5F\x1D\x56\x58\x5C\x42\x52\x17\x54\x5B\x5C\x5D\x47\x57\x51\x25\x6F\x20\x2E\x34" + 0x9440311C).s, ELITE3);
	Sakura::Texture::Load(/*assets/skins/weapon/elite/slide.bmp*/XorStr<0x87, 36, 0xECA37965>("\xE6\xFB\xFA\xEF\xFF\xFF\xA2\xFD\xE4\xF9\xFF\xE1\xBC\xE3\xF0\xF7\xE7\xF7\xF7\xB5\xFE\xF0\xF4\xEA\xFA\x8F\xD2\xCE\xCA\xC0\xC0\x88\xC5\xC5\xD9" + 0xECA37965).s, ELITE4);
	Sakura::Texture::Load(/*assets/skins/weapon/elite/w_elite.bmp*/XorStr<0xF2, 38, 0xA30E1A14>("\x93\x80\x87\x90\x82\x84\xD7\x8A\x91\x92\x92\x8E\xD1\x88\x65\x60\x72\x6C\x6A\x2A\x63\x6B\x61\x7D\x6F\x24\x7B\x52\x6B\x63\x79\x65\x77\x3D\x76\x78\x66" + 0xA30E1A14).s, ELITE5);
	Sakura::Texture::Load(/*assets/skins/weapon/famas/v_famas.bmp*/XorStr<0x28, 38, 0x5236A470>("\x49\x5A\x59\x4E\x58\x5E\x01\x5C\x5B\x58\x5C\x40\x1B\x42\x53\x56\x48\x56\x54\x14\x5A\x5C\x53\x5E\x33\x6E\x34\x1C\x22\x24\x2B\x26\x3B\x67\x28\x26\x3C" + 0x5236A470).s, FAMAS1);
	Sakura::Texture::Load(/*assets/skins/weapon/famas/p_famas.bmp*/XorStr<0x52, 38, 0xF6258D3A>("\x33\x20\x27\x30\x22\x24\x77\x2A\x31\x32\x32\x2E\x71\x28\x05\x00\x12\x0C\x0A\x4A\x00\x06\x05\x08\x19\x44\x1C\x32\x08\x0E\x1D\x10\x01\x5D\x16\x18\x06" + 0xF6258D3A).s, FAMAS2);
	Sakura::Texture::Load(/*assets/skins/weapon/fiveseven/fs1.bmp*/XorStr<0x6F, 38, 0xB98EF099>("\x0E\x03\x02\x17\x07\x07\x5A\x05\x1C\x11\x17\x09\x54\x0B\x18\x1F\x0F\xEF\xEF\xAD\xE5\xED\xF3\xE3\xF4\xED\xFF\xEF\xE5\xA3\xEB\xFD\xBE\xBE\xF3\xFF\xE3" + 0xB98EF099).s, FIVESEVEN1);
	Sakura::Texture::Load(/*assets/skins/weapon/fiveseven/fs2.bmp*/XorStr<0xD9, 38, 0xC24CAF72>("\xB8\xA9\xA8\xB9\xA9\xAD\xF0\x93\x8A\x8B\x8D\x97\xCA\x91\x82\x89\x99\x85\x85\xC3\x8B\x87\x99\x95\x82\x97\x85\x91\x9B\xD9\x91\x8B\xCB\xD4\x99\x91\x8D" + 0xC24CAF72).s, FIVESEVEN2);
	Sakura::Texture::Load(/*assets/skins/weapon/fiveseven/57_profile.bmp*/XorStr<0x88, 45, 0x37036BE2>("\xE9\xFA\xF9\xEE\xF8\xFE\xA1\xFC\xFB\xF8\xFC\xE0\xBB\xE2\xF3\xF6\xE8\xF6\xF4\xB4\xFA\xF4\xE8\xFA\xD3\xC4\xD4\xC6\xCA\x8A\x93\x90\xF7\xD9\xD8\xC4\xCA\xC4\xC2\xCA\x9E\xD3\xDF\xC3" + 0x37036BE2).s, FIVESEVEN3);
	Sakura::Texture::Load(/*assets/skins/weapon/flashbang/v_flash_body.bmp*/XorStr<0x63, 47, 0xCB157148>("\x02\x17\x16\x03\x13\x1B\x46\x19\x00\x05\x03\x1D\x40\x07\x14\x13\x03\x1B\x1B\x59\x11\x14\x18\x09\x13\x1E\x1C\x10\x18\xAF\xF7\xDD\xE5\xE8\xE4\xF5\xEF\xD7\xEB\xE5\xEF\xF5\xA3\xEC\xE2\xE0" + 0xCB157148).s, FLASHBANG1);
	Sakura::Texture::Load(/*assets/skins/weapon/flashbang/flash_spoon.bmp*/XorStr<0xA7, 46, 0x231B2444>("\xC6\xDB\xDA\xCF\xDF\xDF\x82\xDD\xC4\xD9\xDF\xC1\x9C\xC3\xD0\xD7\xC7\xD7\xD7\x95\xDD\xD0\xDC\xCD\xD7\xA2\xA0\xAC\xA4\xEB\xA3\xAA\xA6\xBB\xA1\x95\xB8\xBC\xA2\xA1\xA1\xFE\xB3\xBF\xA3" + 0x231B2444).s, FLASHBANG2);
	Sakura::Texture::Load(/*assets/skins/weapon/flashbang/flash_top.bmp*/XorStr<0x4A, 44, 0xA2951EE9>("\x2B\x38\x3F\x28\x3A\x3C\x7F\x22\x39\x3A\x3A\x26\x79\x20\x3D\x38\x2A\x34\x32\x72\x38\x33\x01\x12\x0A\x01\x05\x0B\x01\x48\x0E\x05\x0B\x18\x04\x32\x1A\x00\x00\x5F\x10\x1E\x04" + 0xA2951EE9).s, FLASHBANG3);
	Sakura::Texture::Load(/*assets/skins/weapon/flashbang/f_body.bmp*/XorStr<0xFA, 41, 0x3C90DEE6>("\x9B\x88\x8F\x98\x8A\x8C\x2F\x72\x69\x6A\x6A\x76\x29\x70\x6D\x68\x7A\x64\x62\x22\x68\x63\x71\x62\x7A\x71\x75\x7B\x71\x38\x7E\x46\x78\x74\x78\x64\x30\x7D\x4D\x51" + 0x3C90DEE6).s, FLASHBANG4);
	Sakura::Texture::Load(/*assets/skins/weapon/flashbang/f_top.bmp*/XorStr<0x36, 40, 0xB202EC88>("\x57\x44\x4B\x5C\x4E\x48\x13\x4E\x55\x56\x2E\x32\x6D\x34\x21\x24\x36\x28\x26\x66\x2C\x27\x2D\x3E\x26\x2D\x31\x3F\x35\x7C\x32\x0A\x22\x38\x28\x77\x38\x36\x2C" + 0xB202EC88).s, FLASHBANG5);
	Sakura::Texture::Load(/*assets/skins/weapon/flashbang/flash_body.bmp*/XorStr<0xFC, 45, 0xA3AFF5E4>("\x9D\x8E\x8D\x9A\x74\x72\x2D\x70\x6F\x6C\x68\x74\x27\x7E\x6F\x6A\x7C\x62\x60\x20\x76\x7D\x73\x60\x7C\x77\x77\x79\x7F\x36\x7C\x77\x7D\x6E\x76\x40\x42\x4E\x46\x5A\x0A\x47\x4B\x57" + 0xA3AFF5E4).s, FLASHBANG10);
	Sakura::Texture::Load(/*assets/skins/weapon/g3sg1/barrel.bmp*/XorStr<0x8B, 37, 0xF89EFE95>("\xEA\xFF\xFE\xEB\xFB\xE3\xBE\xE1\xF8\xFD\xFB\xE5\xB8\xEF\xFC\xFB\xEB\xF3\xF3\xB1\xF8\x93\xD2\xC5\x92\x8B\xC7\xC7\xD5\xDA\xCC\xC6\x85\xCE\xC0\xDE" + 0xF89EFE95).s, G3SG11);
	Sakura::Texture::Load(/*assets/skins/weapon/g3sg1/body.bmp*/XorStr<0xA2, 35, 0x959C6F33>("\xC3\xD0\xD7\xC0\xD2\xD4\x87\xDA\xC1\xC2\xC2\xDE\x81\xD8\xD5\xD0\xC2\xDC\xDA\x9A\xD1\x84\xCB\xDE\x8B\x94\xDE\xD2\xDA\xC6\xEE\xA3\xAF\xB3" + 0x959C6F33).s, G3SG12);
	Sakura::Texture::Load(/*assets/skins/weapon/g3sg1/buttstock.bmp*/XorStr<0xB5, 40, 0x75F7917A>("\xD4\xC5\xC4\xDD\xCD\xC9\x94\xCF\xD6\xD7\xD1\xB3\xEE\xB5\xA6\xA5\xB5\xA9\xA9\xE7\xAE\xF9\xB8\xAB\xFC\xE1\xAD\xA5\xA5\xA6\xA0\xA0\xBA\xB5\xBC\xF6\xBB\xB7\xAB" + 0x75F7917A).s, G3SG13);
	Sakura::Texture::Load(/*assets/skins/weapon/g3sg1/forearm.bmp*/XorStr<0x3E, 38, 0x7A7612BD>("\x5F\x4C\x33\x24\x36\x30\x6B\x36\x2D\x2E\x26\x3A\x65\x3C\x29\x2C\x3E\x20\x3E\x7E\x35\x60\x27\x32\x67\x78\x3E\x36\x28\x3E\x3D\x2F\x33\x71\x02\x0C\x12" + 0x7A7612BD).s, G3SG14);
	Sakura::Texture::Load(/*assets/skins/weapon/g3sg1/lowerbody.bmp*/XorStr<0x54, 40, 0x50CC81E2>("\x35\x26\x25\x32\x2C\x2A\x75\x28\x37\x34\x30\x2C\x4F\x16\x07\x02\x14\x0A\x08\x48\x0F\x5A\x19\x0C\x5D\x42\x02\x00\x07\x14\x00\x11\x1B\x11\x0F\x59\x1A\x14\x0A" + 0x50CC81E2).s, G3SG15);
	Sakura::Texture::Load(/*assets/skins/weapon/g3sg1/scope.bmp*/XorStr<0xA4, 36, 0xB596BDD8>("\xC5\xD6\xD5\xC2\xDC\xDA\x85\xD8\xC7\xC4\xC0\xDC\x9F\xC6\xD7\xD2\xC4\xDA\xD8\x98\xDF\x8A\xC9\xDC\x8D\x92\xCD\xDC\xAF\xB1\xA7\xED\xA6\xA8\xB6" + 0xB596BDD8).s, G3SG16);
	Sakura::Texture::Load(/*assets/skins/weapon/g3sg1/scope_hold.bmp*/XorStr<0xDB, 41, 0x95CDF29C>("\xBA\xAF\xAE\xBB\xAB\x93\xCE\x91\x88\x8D\x8B\x95\xC8\x9F\x8C\x8B\x9B\x83\x83\xC1\x88\xC3\x82\x95\xC2\xDB\x86\x95\x98\x88\x9C\xA5\x93\x93\x91\x9A\xD1\x62\x6C\x72" + 0x95CDF29C).s, G3SG17);
	Sakura::Texture::Load(/*assets/skins/weapon/g3sg1/scope_knob.bmp*/XorStr<0x13, 41, 0x9550CF06>("\x72\x67\x66\x73\x63\x6B\x36\x69\x70\x75\x73\x6D\x30\x57\x44\x43\x53\x4B\x4B\x09\x40\x1B\x5A\x4D\x1A\x03\x5E\x4D\x40\x40\x54\x6D\x58\x5A\x5A\x54\x19\x5A\x54\x4A" + 0x9550CF06).s, G3SG18);
	Sakura::Texture::Load(/*assets/skins/weapon/g3sg1/w_g3sg1.bmp*/XorStr<0x56, 38, 0xDFFA8CC6>("\x37\x24\x2B\x3C\x2E\x28\x73\x2E\x35\x36\x0E\x12\x4D\x14\x01\x04\x16\x08\x06\x46\x0D\x58\x1F\x0A\x5F\x40\x07\x2E\x15\x40\x07\x12\x47\x59\x1A\x14\x0A" + 0xDFFA8CC6).s, G3SG19);
	Sakura::Texture::Load(/*assets/skins/weapon/galil/galil.bmp*/XorStr<0xAB, 36, 0xDFD74D20>("\xCA\xDF\xDE\xCB\xDB\xC3\x9E\xC1\xD8\xDD\xDB\xC5\x98\xCF\xDC\xDB\xCB\xD3\xD3\x91\xD8\xA1\xAD\xAB\xAF\xEB\xA2\xA7\xAB\xA1\xA5\xE4\xA9\xA1\xBD" + 0xDFD74D20).s, GALIL1);
	Sakura::Texture::Load(/*assets/skins/weapon/galil/p_galil.bmp*/XorStr<0x2B, 38, 0x02933E0B>("\x4A\x5F\x5E\x4B\x5B\x43\x1E\x41\x58\x5D\x5B\x45\x18\x4F\x5C\x5B\x4B\x53\x53\x11\x58\x21\x2D\x2B\x2F\x6B\x35\x19\x20\x29\x25\x23\x27\x62\x2F\x23\x3F" + 0x02933E0B).s, GALIL2);
	Sakura::Texture::Load(/*assets/skins/weapon/glock18/glock_barrel.bmp*/XorStr<0x52, 45, 0x0578AE43>("\x33\x20\x27\x30\x22\x24\x77\x2A\x31\x32\x32\x2E\x71\x28\x05\x00\x12\x0C\x0A\x4A\x01\x0B\x07\x0A\x01\x5A\x54\x42\x09\x03\x1F\x12\x19\x2C\x16\x14\x04\x05\x1D\x15\x54\x19\x11\x0D" + 0x0578AE43).s, GLOCK181);
	Sakura::Texture::Load(/*assets/skins/weapon/glock18/glock_base.bmp*/XorStr<0x07, 43, 0x794E6A43>("\x66\x7B\x7A\x6F\x7F\x7F\x22\x7D\x64\x79\x7F\x61\x3C\x63\x70\x77\x67\x77\x77\x35\x7C\x70\x72\x7D\x74\x11\x19\x0D\x44\x48\x4A\x45\x4C\x77\x4B\x4B\x58\x49\x03\x4C\x42\x40" + 0x794E6A43).s, GLOCK182);
	Sakura::Texture::Load(/*assets/skins/weapon/glock18/glock_mag.bmp*/XorStr<0xCB, 42, 0x30F322AF>("\xAA\xBF\xBE\xAB\xBB\xA3\xFE\xA1\xB8\xBD\xBB\xA5\xF8\xAF\xBC\xBB\xAB\xB3\xB3\xF1\xB8\x8C\x8E\x81\x88\xD5\xDD\xC9\x80\x84\x86\x89\x80\xB3\x80\x8F\x88\xDE\x93\x9F\x83" + 0x30F322AF).s, GLOCK183);
	Sakura::Texture::Load(/*assets/skins/weapon/glock18/glock_slide.bmp*/XorStr<0x84, 44, 0xCE929DBE>("\xE5\xF6\xF5\xE2\xFC\xFA\xA5\xF8\xE7\xE4\xE0\xFC\xBF\xE6\xF7\xF2\xE4\xFA\xF8\xB8\xFF\xF5\xF5\xF8\xF7\xAC\xA6\xB0\xC7\xCD\xCD\xC0\xCF\xFA\xD5\xCB\xC1\xCD\xCF\x85\xCE\xC0\xDE" + 0xCE929DBE).s, GLOCK184);
	Sakura::Texture::Load(/*assets/skins/weapon/glock18/w_glock18.bmp*/XorStr<0xF3, 42, 0xD4736D7D>("\x92\x87\x86\x93\x83\x8B\xD6\x89\x90\x95\x93\x8D\xD0\x77\x64\x63\x73\x6B\x6B\x29\x60\x64\x66\x69\x60\x3D\x35\x21\x78\x4F\x76\x7E\x7C\x77\x7E\x27\x2F\x36\x7B\x77\x6B" + 0xD4736D7D).s, GLOCK185);
	Sakura::Texture::Load(/*assets/skins/weapon/hegrenade/v_he_body.bmp*/XorStr<0x3D, 44, 0xD437F4DC>("\x5C\x4D\x4C\x25\x35\x31\x6C\x37\x2E\x2F\x29\x3B\x66\x3D\x2E\x2D\x3D\x21\x21\x7F\x39\x37\x34\x26\x30\x38\x36\x3C\x3C\x75\x2D\x03\x35\x3B\x00\x02\x0E\x06\x1A\x4A\x07\x0B\x17" + 0xD437F4DC).s, HEGRENADE1);
	Sakura::Texture::Load(/*assets/skins/weapon/hegrenade/he_spoon.bmp*/XorStr<0x7E, 43, 0x1AA0D568>("\x1F\x0C\xF3\xE4\xF6\xF0\xAB\xF6\xED\xEE\xE6\xFA\xA5\xFC\xE9\xEC\xFE\xE0\xFE\xBE\xFA\xF6\xF3\xE7\xF3\xF9\xF9\xFD\xFF\xB4\xF4\xF8\xC1\xEC\xD0\xCE\xCD\xCD\x8A\xC7\xCB\xD7" + 0x1AA0D568).s, HEGRENADE2);
	Sakura::Texture::Load(/*assets/skins/weapon/hegrenade/he_top.bmp*/XorStr<0xE9, 41, 0x5832B9B4>("\x88\x99\x98\x89\x99\x9D\xC0\x83\x9A\x9B\x9D\x87\xDA\x81\x92\x99\x89\x95\x95\xD3\x95\x9B\x98\x72\x64\x6C\x62\x60\x60\x29\x6F\x6D\x56\x7E\x64\x7C\x23\x6C\x62\x60" + 0x5832B9B4).s, HEGRENADE3);
	Sakura::Texture::Load(/*assets/skins/weapon/hegrenade/f_body.bmp*/XorStr<0x43, 41, 0xCAD2B8E5>("\x22\x37\x36\x23\x33\x3B\x66\x39\x20\x25\x23\x3D\x60\x27\x34\x33\x23\x3B\x3B\x79\x3F\x3D\x3E\x28\x3E\x32\x3C\x3A\x3A\x4F\x07\x3D\x01\x0B\x01\x1F\x49\x0A\x04\x1A" + 0xCAD2B8E5).s, HEGRENADE4);
	Sakura::Texture::Load(/*assets/skins/weapon/hegrenade/f_top.bmp*/XorStr<0xE4, 40, 0x2407C31F>("\x85\x96\x95\x82\x9C\x9A\xC5\x98\x87\x84\x80\x9C\xDF\x86\x97\x92\x84\x9A\x98\xD8\x90\x9C\x9D\x89\x99\x93\x9F\x9B\x65\x2E\x64\x5C\x70\x6A\x76\x29\x6A\x64\x7A" + 0x2407C31F).s, HEGRENADE5);
	Sakura::Texture::Load(/*assets/skins/weapon/hegrenade/he_body.bmp*/XorStr<0xE2, 42, 0xF0DEA80F>("\x83\x90\x97\x80\x92\x94\xC7\x9A\x81\x82\x82\x9E\xC1\x98\x95\x90\x82\x9C\x9A\xDA\x9E\x92\x9F\x8B\x9F\x95\x9D\x99\x9B\xD0\x68\x64\x5D\x61\x6B\x61\x7F\x29\x6A\x64\x7A" + 0xF0DEA80F).s, HEGRENADE10);
	Sakura::Texture::Load(/*assets/skins/weapon/knife/knifeskin.bmp*/XorStr<0x21, 40, 0x7C02F32D>("\x40\x51\x50\x41\x51\x55\x08\x5B\x42\x43\x45\x5F\x02\x59\x4A\x51\x41\x5D\x5D\x1B\x5E\x58\x5E\x5E\x5C\x15\x50\x52\x54\x58\x5A\x33\x2A\x2B\x2D\x6A\x27\x2B\x37" + 0x7C02F32D).s, KNIFE1);
	Sakura::Texture::Load(/*assets/skins/weapon/knife/pknifeskin.bmp*/XorStr<0x11, 41, 0x86B43C7E>("\x70\x61\x60\x71\x61\x65\x38\x6B\x72\x73\x75\x6F\x32\x69\x7A\x41\x51\x4D\x4D\x0B\x4E\x48\x4E\x4E\x4C\x05\x5B\x47\x43\x47\x49\x55\x42\x59\x5A\x5A\x1B\x54\x5A\x48" + 0x86B43C7E).s, KNIFE2);
	Sakura::Texture::Load(/*assets/skins/weapon/m3/barrel.bmp*/XorStr<0x35, 34, 0xD5605B8C>("\x54\x45\x44\x5D\x4D\x49\x14\x4F\x56\x57\x51\x33\x6E\x35\x26\x25\x35\x29\x29\x67\x24\x79\x64\x2E\x2C\x3C\x3D\x35\x3D\x7C\x31\x39\x25" + 0xD5605B8C).s, M31);
	Sakura::Texture::Load(/*assets/skins/weapon/m3/forearm.bmp*/XorStr<0xA5, 35, 0x868F6868>("\xC4\xD5\xD4\xCD\xDD\xD9\x84\xDF\xC6\xC7\xC1\xC3\x9E\xC5\xD6\xD5\xC5\xD9\xD9\x97\xD4\x89\x94\xDA\xD2\xCC\xDA\xA1\xB3\xAF\xED\xA6\xA8\xB6" + 0x868F6868).s, M32);
	Sakura::Texture::Load(/*assets/skins/weapon/m3/handle.bmp*/XorStr<0x96, 34, 0xC763D1BE>("\xF7\xE4\xEB\xFC\xEE\xE8\xB3\xEE\xF5\xF6\xCE\xD2\x8D\xD4\xC1\xC4\xD6\xC8\xC6\x86\xC7\x98\x83\xC5\xCF\xC1\xD4\xDD\xD7\x9D\xD6\xD8\xC6" + 0xC763D1BE).s, M33);
	Sakura::Texture::Load(/*assets/skins/weapon/m3/sights.bmp*/XorStr<0x0F, 34, 0x8B7199ED>("\x6E\x63\x62\x77\x67\x67\x3A\x65\x7C\x71\x77\x69\x34\x6B\x78\x7F\x6F\x4F\x4F\x0D\x4E\x17\x0A\x55\x4E\x4F\x41\x5E\x58\x02\x4F\x43\x5F" + 0x8B7199ED).s, M34);
	Sakura::Texture::Load(/*assets/skins/weapon/m3/w_m3super90.bmp*/XorStr<0x1D, 39, 0x9649FFE6>("\x7C\x6D\x6C\x45\x55\x51\x0C\x57\x4E\x4F\x49\x5B\x06\x5D\x4E\x4D\x5D\x41\x41\x1F\x5C\x01\x1C\x43\x6A\x5B\x04\x4B\x4C\x4A\x5E\x4E\x04\x0E\x11\x22\x2C\x32" + 0x9649FFE6).s, M35);
	Sakura::Texture::Load(/*assets/skins/weapon/m4a1/barrel.bmp*/XorStr<0x4B, 36, 0xD3FB9B39>("\x2A\x3F\x3E\x2B\x3B\x23\x7E\x21\x38\x3D\x3B\x25\x78\x2F\x3C\x3B\x2B\x33\x33\x71\x32\x54\x00\x53\x4C\x06\x04\x14\x15\x0D\x05\x44\x09\x01\x1D" + 0xD3FB9B39).s, M4A11);
	Sakura::Texture::Load(/*assets/skins/weapon/m4a1/buttstock.bmp*/XorStr<0x39, 39, 0x4F8B308D>("\x58\x49\x48\x59\x49\x4D\x10\x33\x2A\x2B\x2D\x37\x6A\x31\x22\x29\x39\x25\x25\x63\x20\x7A\x2E\x61\x7E\x30\x26\x20\x21\x25\x23\x37\x3A\x31\x75\x3E\x30\x2E" + 0x4F8B308D).s, M4A12);
	Sakura::Texture::Load(/*assets/skins/weapon/m4a1/handle.bmp*/XorStr<0xF8, 36, 0xCC1EC4D4>("\x99\x8A\x89\x9E\x88\x8E\xD1\x8C\x6B\x68\x6C\x70\x2B\x72\x63\x66\x78\x66\x64\x24\x61\x39\x6F\x3E\x3F\x79\x73\x7D\x70\x79\x73\x39\x7A\x74\x6A" + 0xCC1EC4D4).s, M4A13);
	Sakura::Texture::Load(/*assets/skins/weapon/m4a1/magazine.bmp*/XorStr<0x40, 38, 0xEC6C98B0>("\x21\x32\x31\x26\x30\x36\x69\x34\x23\x20\x24\x38\x63\x3A\x2B\x2E\x20\x3E\x3C\x7C\x39\x61\x37\x66\x77\x34\x3B\x3C\x3D\x27\x37\x31\x05\x4F\x00\x0E\x14" + 0xEC6C98B0).s, M4A14);
	Sakura::Texture::Load(/*assets/skins/weapon/m4a1/receiver.bmp*/XorStr<0xBB, 38, 0x169A550F>("\xDA\xCF\xCE\xDB\xCB\xB3\xEE\xB1\xA8\xAD\xAB\xB5\xE8\xBF\xAC\xAB\xBB\xA3\xA3\xE1\xA2\xE4\xB0\xE3\xFC\xA6\xB0\xB5\xB2\xB1\xAF\xBF\xA9\xF2\xBF\xB3\xAF" + 0x169A550F).s, M4A15);
	Sakura::Texture::Load(/*assets/skins/weapon/m4a1/silencer.bmp*/XorStr<0xFA, 38, 0x4EF4145B>("\x9B\x88\x8F\x98\x8A\x8C\x2F\x72\x69\x6A\x6A\x76\x29\x70\x6D\x68\x7A\x64\x62\x22\x63\x3B\x71\x20\x3D\x60\x7D\x79\x73\x79\x7B\x7C\x68\x35\x7E\x70\x6E" + 0x4EF4145B).s, M4A16);
	Sakura::Texture::Load(/*assets/skins/weapon/m4a1/m4a1_skin.bmp*/XorStr<0xF0, 39, 0xFDD7AE87>("\x91\x82\x81\x96\x80\x86\xD9\x84\x93\x90\x94\x88\xD3\x8A\x9B\x9E\x70\x6E\x6C\x2C\x69\x31\x67\x36\x27\x64\x3E\x6A\x3D\x52\x7D\x64\x79\x7F\x3C\x71\x79\x65" + 0xFDD7AE87).s, M4A17);
	Sakura::Texture::Load(/*assets/skins/weapon/m249/ammobox.bmp*/XorStr<0x4C, 37, 0xB3DB980B>("\x2D\x3E\x3D\x2A\x24\x22\x7D\x20\x3F\x3C\x38\x24\x77\x2E\x3F\x3A\x2C\x32\x30\x70\x0D\x53\x56\x5A\x4B\x04\x0B\x0A\x07\x0B\x05\x13\x42\x0F\x03\x1F" + 0xB3DB980B).s, M2491);
	Sakura::Texture::Load(/*assets/skins/weapon/m249/barrel.bmp*/XorStr<0x28, 36, 0x56C87F47>("\x49\x5A\x59\x4E\x58\x5E\x01\x5C\x5B\x58\x5C\x40\x1B\x42\x53\x56\x48\x56\x54\x14\x51\x0F\x0A\x06\x6F\x23\x23\x31\x36\x20\x2A\x69\x2A\x24\x3A" + 0x56C87F47).s, M2492);
	Sakura::Texture::Load(/*assets/skins/weapon/m249/body.bmp*/XorStr<0x8C, 34, 0xA8297D37>("\xED\xFE\xFD\xEA\xE4\xE2\xBD\xE0\xFF\xFC\xF8\xE4\xB7\xEE\xFF\xFA\xEC\xF2\xF0\xB0\xCD\x93\x96\x9A\x8B\xC7\xC9\xC3\xD1\x87\xC8\xC6\xDC" + 0xA8297D37).s, M2493);
	Sakura::Texture::Load(/*assets/skins/weapon/m249/bullet.bmp*/XorStr<0x62, 36, 0xBEAE0AA6>("\x03\x10\x17\x00\x12\x14\x47\x1A\x01\x02\x02\x1E\x41\x18\x15\x10\x02\x1C\x1A\x5A\x1B\x45\x4C\x40\x55\x19\x09\x11\x12\x1A\xF4\xAF\xE0\xEE\xF4" + 0xBEAE0AA6).s, M2494);
	Sakura::Texture::Load(/*assets/skins/weapon/m249/buttstock.bmp*/XorStr<0xBD, 39, 0x8AB9A8C3>("\xDC\xCD\xCC\xA5\xB5\xB1\xEC\xB7\xAE\xAF\xA9\xBB\xE6\xBD\xAE\xAD\xBD\xA1\xA1\xFF\xBC\xE0\xE7\xED\xFA\xB4\xA2\xAC\xAD\xA9\xAF\xB3\xBE\xB5\xF1\x82\x8C\x92" + 0x8AB9A8C3).s, M2495);
	Sakura::Texture::Load(/*assets/skins/weapon/m249/cover.bmp*/XorStr<0xD8, 35, 0xB3D92E75>("\xB9\xAA\xA9\xBE\xA8\xAE\xF1\xAC\x8B\x88\x8C\x90\xCB\x92\x83\x86\x98\x86\x84\xC4\x81\xDF\xDA\xD6\xDF\x92\x9D\x85\x91\x87\xD8\x95\x95\x89" + 0xB3D92E75).s, M2496);
	Sakura::Texture::Load(/*assets/skins/weapon/m249/forearm.bmp*/XorStr<0x75, 37, 0x5A45D217>("\x14\x05\x04\x1D\x0D\x09\x54\x0F\x16\x17\x11\xF3\xAE\xF5\xE6\xE5\xF5\xE9\xE9\xA7\xE4\xB8\xBF\xB5\xA2\xE8\xE0\xE2\xF4\xF3\xE1\xF9\xBB\xF4\xFA\xE8" + 0x5A45D217).s, M2497);
	Sakura::Texture::Load(/*assets/skins/weapon/m249/handle.bmp*/XorStr<0x50, 36, 0x64F8FBF8>("\x31\x22\x21\x36\x20\x26\x79\x24\x33\x30\x34\x28\x73\x2A\x3B\x3E\x10\x0E\x0C\x4C\x09\x57\x52\x5E\x47\x01\x0B\x05\x08\x01\x0B\x41\x12\x1C\x02" + 0x64F8FBF8).s, M2498);
	Sakura::Texture::Load(/*assets/skins/weapon/m249/sight.bmp*/XorStr<0xE5, 35, 0x8DDE8B5D>("\x84\x95\x94\x8D\x9D\x99\xC4\x9F\x86\x87\x81\x83\xDE\x85\x96\x95\x85\x99\x99\xD7\x94\xC8\xCF\xC5\xD2\x8D\x96\x67\x69\x76\x2D\x66\x68\x76" + 0x8DDE8B5D).s, M2499);
	Sakura::Texture::Load(/*assets/skins/weapon/m249/w_m249.bmp*/XorStr<0x83, 36, 0xB58FCF4F>("\xE2\xF7\xF6\xE3\xF3\xFB\xA6\xF9\xE0\xE5\xE3\xFD\xA0\xE7\xF4\xF3\xE3\xFB\xFB\xB9\xFA\xAA\xAD\xA3\xB4\xEB\xC2\xF3\xAD\x94\x98\x8C\xC1\xC9\xD5" + 0xB58FCF4F).s, M24910);
	Sakura::Texture::Load(/*assets/skins/weapon/mac10/body.bmp*/XorStr<0x69, 35, 0x5F293DBC>("\x08\x19\x18\x09\x19\x1D\x40\x03\x1A\x1B\x1D\x07\x5A\x01\x12\x19\x09\x15\x15\x53\x10\x1F\x1C\xB1\xB1\xAD\xE1\xEB\xE1\xFF\xA9\xEA\xE4\xFA" + 0x5F293DBC).s, MAC101);
	Sakura::Texture::Load(/*assets/skins/weapon/mac10/buttstock.bmp*/XorStr<0x4B, 40, 0x0559B927>("\x2A\x3F\x3E\x2B\x3B\x23\x7E\x21\x38\x3D\x3B\x25\x78\x2F\x3C\x3B\x2B\x33\x33\x71\x32\x01\x02\x53\x53\x4B\x07\x13\x13\x1C\x1A\x1E\x04\x0F\x06\x40\x0D\x1D\x01" + 0x0559B927).s, MAC102);
	Sakura::Texture::Load(/*assets/skins/weapon/mac10/handle.bmp*/XorStr<0x63, 37, 0xD968DEC3>("\x02\x17\x16\x03\x13\x1B\x46\x19\x00\x05\x03\x1D\x40\x07\x14\x13\x03\x1B\x1B\x59\x1A\x19\x1A\x4B\x4B\x53\x15\x1F\x11\xE4\xED\xE7\xAD\xE6\xE8\xF6" + 0xD968DEC3).s, MAC103);
	Sakura::Texture::Load(/*assets/skins/weapon/mac10/w_mac10.bmp*/XorStr<0x22, 38, 0xF8FEA09C>("\x43\x50\x57\x40\x52\x54\x07\x5A\x41\x42\x42\x5E\x01\x58\x55\x50\x42\x5C\x5A\x1A\x5B\x56\x5B\x08\x0A\x14\x4B\x62\x53\x5E\x23\x70\x72\x6D\x26\x28\x36" + 0xF8FEA09C).s, MAC104);
	Sakura::Texture::Load(/*assets/skins/weapon/mp5/barrel.bmp*/XorStr<0x02, 35, 0x743B0C2B>("\x63\x70\x77\x60\x72\x74\x27\x7A\x61\x62\x62\x7E\x21\x78\x75\x70\x62\x7C\x7A\x3A\x7B\x67\x2D\x36\x78\x7A\x6E\x6F\x7B\x73\x0E\x43\x4F\x53" + 0x743B0C2B).s, MP51);
	Sakura::Texture::Load(/*assets/skins/weapon/mp5/buttstock.bmp*/XorStr<0x77, 38, 0x79F61E0A>("\x16\x0B\x0A\x1F\x0F\x0F\x52\x0D\x14\xE9\xEF\xF1\xAC\xF3\xE0\xE7\xF7\xE7\xE7\xA5\xE6\xFC\xB8\xA1\xED\xE5\xE5\xE6\xE0\xE0\xFA\xF5\xFC\xB6\xFB\xF7\xEB" + 0x79F61E0A).s, MP52);
	Sakura::Texture::Load(/*assets/skins/weapon/mp5/clip.bmp*/XorStr<0x82, 33, 0x2A66BAFE>("\xE3\xF0\xF7\xE0\xF2\xF4\xA7\xFA\xE1\xE2\xE2\xFE\xA1\xF8\xF5\xF0\xE2\xFC\xFA\xBA\xFB\xE7\xAD\xB6\xF9\xF7\xF5\xED\xB0\xFD\xCD\xD1" + 0x2A66BAFE).s, MP53);
	Sakura::Texture::Load(/*assets/skins/weapon/mp5/forearm.bmp*/XorStr<0xAF, 36, 0x92746ACE>("\xCE\xC3\xC2\xD7\xC7\xC7\x9A\xC5\xDC\xD1\xD7\xC9\x94\xCB\xD8\xDF\xCF\xAF\xAF\xED\xAE\xB4\xF0\xE9\xA1\xA7\xBB\xAF\xAA\xBE\xA0\xE0\xAD\xBD\xA1" + 0x92746ACE).s, MP54);
	Sakura::Texture::Load(/*assets/skins/weapon/mp5/handle.bmp*/XorStr<0x8F, 35, 0xA1DEBD7F>("\xEE\xE3\xE2\xF7\xE7\xE7\xBA\xE5\xFC\xF1\xF7\xE9\xB4\xEB\xF8\xFF\xEF\xCF\xCF\x8D\xCE\xD4\x90\x89\xCF\xC9\xC7\xCE\xC7\xC9\x83\xCC\xC2\xC0" + 0xA1DEBD7F).s, MP55);
	Sakura::Texture::Load(/*assets/skins/weapon/mp5/lowerrec.bmp*/XorStr<0xEB, 37, 0x12045482>("\x8A\x9F\x9E\x8B\x9B\x83\xDE\x81\x98\x9D\x9B\x85\xD8\x8F\x9C\x9B\x8B\x93\x93\xD1\x92\x70\x34\x2D\x6F\x6B\x72\x63\x75\x7A\x6C\x69\x25\x6E\x60\x7E" + 0x12045482).s, MP56);
	Sakura::Texture::Load(/*assets/skins/weapon/mp5/rearsight.bmp*/XorStr<0x8E, 38, 0x3F3421B7>("\xEF\xFC\xE3\xF4\xE6\xE0\xBB\xE6\xFD\xFE\xF6\xEA\xB5\xEC\xF9\xFC\xEE\xF0\xCE\x8E\xCF\xD3\x91\x8A\xD4\xC2\xC9\xDB\xD9\xC2\xCB\xC5\xDA\x81\xD2\xDC\xC2" + 0x3F3421B7).s, MP57);
	Sakura::Texture::Load(/*assets/skins/weapon/mp5/w_mp5.bmp*/XorStr<0x31, 34, 0x385B5211>("\x50\x41\x40\x51\x41\x45\x18\x4B\x52\x53\x55\x4F\x12\x49\x5A\x21\x31\x2D\x2D\x6B\x28\x36\x72\x67\x3E\x15\x26\x3C\x78\x60\x2D\x3D\x21" + 0x385B5211).s, MP58);
	Sakura::Texture::Load(/*assets/skins/weapon/p90/buttstock.bmp*/XorStr<0x8F, 38, 0x0F38D16B>("\xEE\xE3\xE2\xF7\xE7\xE7\xBA\xE5\xFC\xF1\xF7\xE9\xB4\xEB\xF8\xFF\xEF\xCF\xCF\x8D\xD3\x9D\x95\x89\xC5\xDD\xDD\xDE\xD8\xD8\xC2\xCD\xC4\x9E\xD3\xDF\xC3" + 0x0F38D16B).s, P901);
	Sakura::Texture::Load(/*assets/skins/weapon/p90/handle-1.bmp*/XorStr<0x85, 37, 0x44663006>("\xE4\xF5\xF4\xED\xFD\xF9\xA4\xFF\xE6\xE7\xE1\xE3\xBE\xE5\xF6\xF5\xE5\xF9\xF9\xB7\xE9\xA3\xAB\xB3\xF5\xFF\xF1\xC4\xCD\xC7\x8E\x95\x8B\xC4\xCA\xD8" + 0x44663006).s, P902);
	Sakura::Texture::Load(/*assets/skins/weapon/p90/handles.bmp*/XorStr<0x7C, 36, 0xBE53BCDB>("\x1D\x0E\x0D\x1A\xF4\xF2\xAD\xF0\xEF\xEC\xE8\xF4\xA7\xFE\xEF\xEA\xFC\xE2\xE0\xA0\xE0\xA8\xA2\xBC\xFC\xF4\xF8\xF3\xF4\xFC\xE9\xB5\xFE\xF0\xEE" + 0xBE53BCDB).s, P903);
	Sakura::Texture::Load(/*assets/skins/weapon/p90/magazine.bmp*/XorStr<0x7D, 37, 0xEEEFA886>("\x1C\x0D\x0C\xE5\xF5\xF1\xAC\xF7\xEE\xEF\xE9\xFB\xA6\xFD\xEE\xED\xFD\xE1\xE1\xBF\xE1\xAB\xA3\xBB\xF8\xF7\xF0\xF9\xE3\xF3\xF5\xF9\xB3\xFC\xF2\xD0" + 0xEEEFA886).s, P904);
	Sakura::Texture::Load(/*assets/skins/weapon/p90/sights-1.bmp*/XorStr<0xDF, 37, 0xCF9B52AD>("\xBE\x93\x92\x87\x97\x97\xCA\x95\x8C\x81\x87\x99\xC4\x9B\x88\x8F\x9F\x9F\x9F\xDD\x83\xCD\xC5\xD9\x84\x91\x9E\x92\x8F\x8F\xD0\xCF\xD1\x62\x6C\x72" + 0xCF9B52AD).s, P905);
	Sakura::Texture::Load(/*assets/skins/weapon/p90/w_p90.bmp*/XorStr<0xDB, 34, 0x6AA6AB8A>("\xBA\xAF\xAE\xBB\xAB\x93\xCE\x91\x88\x8D\x8B\x95\xC8\x9F\x8C\x8B\x9B\x83\x83\xC1\x9F\xC9\xC1\xDD\x84\xAB\x85\xCF\xC7\xD6\x9B\x97\x8B" + 0x6AA6AB8A).s, P906);
	Sakura::Texture::Load(/*assets/skins/weapon/p228/p228_handle.bmp*/XorStr<0x07, 41, 0x78221EED>("\x66\x7B\x7A\x6F\x7F\x7F\x22\x7D\x64\x79\x7F\x61\x3C\x63\x70\x77\x67\x77\x77\x35\x6B\x2E\x2F\x26\x30\x50\x13\x10\x1B\x7B\x4D\x47\x49\x4C\x45\x4F\x05\x4E\x40\x5E" + 0x78221EED).s, P2281);
	Sakura::Texture::Load(/*assets/skins/weapon/p228/p228_mag.bmp*/XorStr<0x65, 38, 0x3FCC9A67>("\x04\x15\x14\x0D\x1D\x19\x44\x1F\x06\x07\x01\x03\x5E\x05\x16\x15\x05\x19\x19\x57\x09\x48\x49\x44\x52\x0E\x4D\xB2\xB9\xDD\xEE\xE5\xE2\xA8\xE5\xE5\xF9" + 0x3FCC9A67).s, P2282);
	Sakura::Texture::Load(/*assets/skins/weapon/p228/p228_slide.bmp*/XorStr<0x84, 40, 0xEEE5F63D>("\xE5\xF6\xF5\xE2\xFC\xFA\xA5\xF8\xE7\xE4\xE0\xFC\xBF\xE6\xF7\xF2\xE4\xFA\xF8\xB8\xE8\xAB\xA8\xA3\xB3\xED\xAC\xAD\x98\xFE\xD1\xCF\xCD\xC1\xC3\x89\xCA\xC4\xDA" + 0xEEE5F63D).s, P2283);
	Sakura::Texture::Load(/*assets/skins/weapon/p228/w_p228.bmp*/XorStr<0xF3, 36, 0x126F2572>("\x92\x87\x86\x93\x83\x8B\xD6\x89\x90\x95\x93\x8D\xD0\x77\x64\x63\x73\x6B\x6B\x29\x77\x3A\x3B\x32\x24\x7B\x52\x7E\x3D\x22\x29\x3C\x71\x79\x65" + 0x126F2572).s, P2284);
	Sakura::Texture::Load(/*assets/skins/weapon/scout/base.bmp*/XorStr<0xCD, 35, 0x752EB906>("\xAC\xBD\xBC\xB5\xA5\xA1\xFC\xA7\xBE\xBF\xB9\xAB\xF6\xAD\xBE\xBD\xAD\xB1\xB1\xCF\x92\x81\x8C\x91\x91\xC9\x85\x89\x9A\x8F\xC5\x8E\x80\x9E" + 0x752EB906).s, SCOUT1);
	Sakura::Texture::Load(/*assets/skins/weapon/scout/magazine.bmp*/XorStr<0xAB, 39, 0x024E3A31>("\xCA\xDF\xDE\xCB\xDB\xC3\x9E\xC1\xD8\xDD\xDB\xC5\x98\xCF\xDC\xDB\xCB\xD3\xD3\x91\xCC\xA3\xAE\xB7\xB7\xEB\xA8\xA7\xA0\xA9\xB3\xA3\xA5\xA9\xE3\xAC\xA2\xA0" + 0x024E3A31).s, SCOUT2);
	Sakura::Texture::Load(/*assets/skins/weapon/scout/rail.bmp*/XorStr<0x23, 35, 0xB504FDCA>("\x42\x57\x56\x43\x53\x5B\x06\x59\x40\x45\x43\x5D\x00\x47\x54\x53\x43\x5B\x5B\x19\x44\x5B\x56\x4F\x4F\x13\x4F\x5F\x56\x2C\x6F\x20\x2E\x34" + 0xB504FDCA).s, SCOUT3);
	Sakura::Texture::Load(/*assets/skins/weapon/scout/scope.bmp*/XorStr<0x1C, 36, 0x0AAA11CB>("\x7D\x6E\x6D\x7A\x54\x52\x0D\x50\x4F\x4C\x48\x54\x07\x5E\x4F\x4A\x5C\x42\x40\x00\x43\x52\x5D\x46\x40\x1A\x45\x54\x57\x49\x5F\x15\x5E\x50\x4E" + 0x0AAA11CB).s, SCOUT4);
	Sakura::Texture::Load(/*assets/skins/weapon/scout/scope_clamps.bmp*/XorStr<0x80, 43, 0xF7B00AAD>("\xE1\xF2\xF1\xE6\xF0\xF6\xA9\xF4\xE3\xE0\xE4\xF8\xA3\xFA\xEB\xEE\xE0\xFE\xFC\xBC\xE7\xF6\xF9\xE2\xEC\xB6\xE9\xF8\xF3\xED\xFB\xC0\xC3\xCD\xC3\xCE\xD4\xD6\x88\xC5\xC5\xD9" + 0xF7B00AAD).s, SCOUT5);
	Sakura::Texture::Load(/*assets/skins/weapon/scout/w_scout.bmp*/XorStr<0x3D, 38, 0xD47E8B75>("\x5C\x4D\x4C\x25\x35\x31\x6C\x37\x2E\x2F\x29\x3B\x66\x3D\x2E\x2D\x3D\x21\x21\x7F\x22\x31\x3C\x21\x21\x79\x20\x07\x2A\x39\x34\x29\x29\x70\x3D\x0D\x11" + 0xD47E8B75).s, SCOUT6);
	Sakura::Texture::Load(/*assets/skins/weapon/sg550/buttstock.bmp*/XorStr<0x80, 40, 0x14A6FB6D>("\xE1\xF2\xF1\xE6\xF0\xF6\xA9\xF4\xE3\xE0\xE4\xF8\xA3\xFA\xEB\xEE\xE0\xFE\xFC\xBC\xE7\xF2\xA3\xA2\xA8\xB6\xF8\xEE\xE8\xE9\xED\xEB\xCF\xC2\xC9\x8D\xC6\xC8\xD6" + 0x14A6FB6D).s, SG5501);
	Sakura::Texture::Load(/*assets/skins/weapon/sg550/forearm.bmp*/XorStr<0x95, 38, 0x7DFEFB02>("\xF4\xE5\xE4\xFD\xED\xE9\xB4\xEF\xF6\xF7\xF1\xD3\x8E\xD5\xC6\xC5\xD5\xC9\xC9\x87\xDA\xCD\x9E\x99\x9D\x81\xC9\xDF\xC3\xD7\xD2\xC6\xD8\x98\xD5\xD5\xC9" + 0x7DFEFB02).s, SG5502);
	Sakura::Texture::Load(/*assets/skins/weapon/sg550/handle.bmp*/XorStr<0xEC, 37, 0x2D088551>("\x8D\x9E\x9D\x8A\x84\x82\xDD\x80\x9F\x9C\x98\x84\xD7\x8E\x9F\x9A\x8C\x92\x90\xD0\x73\x66\x37\x36\x34\x2A\x6E\x66\x66\x6D\x66\x6E\x22\x6F\x63\x7F" + 0x2D088551).s, SG5503);
	Sakura::Texture::Load(/*assets/skins/weapon/sg550/magazine_transp.bmp*/XorStr<0x8A, 46, 0x009D6189>("\xEB\xF8\xFF\xE8\xFA\xFC\xBF\xE2\xF9\xFA\xFA\xE6\xB9\xE0\xFD\xF8\xEA\xF4\xF2\xB2\xED\xF8\x95\x94\x92\x8C\xC9\xC4\xC1\xC6\xD2\xC0\xC4\xCE\xF3\xD9\xDC\xCE\xDE\xC2\xC2\x9D\xD6\xD8\xC6" + 0x009D6189).s, SG5504);
	Sakura::Texture::Load(/*assets/skins/weapon/sg550/receiver.bmp*/XorStr<0x54, 39, 0x4E5FCAF2>("\x35\x26\x25\x32\x2C\x2A\x75\x28\x37\x34\x30\x2C\x4F\x16\x07\x02\x14\x0A\x08\x48\x1B\x0E\x5F\x5E\x5C\x42\x1C\x0A\x13\x14\x1B\x05\x11\x07\x58\x15\x15\x09" + 0x4E5FCAF2).s, SG5505);
	Sakura::Texture::Load(/*assets/skins/weapon/sg550/scope.bmp*/XorStr<0x5C, 36, 0x9C8910D5>("\x3D\x2E\x2D\x3A\x14\x12\x4D\x10\x0F\x0C\x08\x14\x47\x1E\x0F\x0A\x1C\x02\x00\x40\x03\x16\x47\x46\x44\x5A\x05\x14\x17\x09\x1F\x55\x1E\x10\x0E" + 0x9C8910D5).s, SG5506);
	Sakura::Texture::Load(/*assets/skins/weapon/sg550/sg550_profile.bmp*/XorStr<0x2B, 44, 0x643D3AF2>("\x4A\x5F\x5E\x4B\x5B\x43\x1E\x41\x58\x5D\x5B\x45\x18\x4F\x5C\x5B\x4B\x53\x53\x11\x4C\x27\x74\x77\x73\x6B\x36\x21\x72\x7D\x79\x15\x3B\x3E\x22\x28\x26\x3C\x34\x7C\x31\x39\x25" + 0x643D3AF2).s, SG5507);
	Sakura::Texture::Load(/*assets/skins/weapon/sg552/acog.bmp*/XorStr<0x28, 35, 0x0A305B34>("\x49\x5A\x59\x4E\x58\x5E\x01\x5C\x5B\x58\x5C\x40\x1B\x42\x53\x56\x48\x56\x54\x14\x4F\x5A\x0B\x0A\x72\x6E\x23\x20\x2B\x22\x68\x25\x25\x39" + 0x0A305B34).s, SG5521);
	Sakura::Texture::Load(/*assets/skins/weapon/sg552/buttstock.bmp*/XorStr<0x17, 40, 0xBC5EC91D>("\x76\x6B\x6A\x7F\x6F\x6F\x32\x6D\x74\x49\x4F\x51\x0C\x53\x40\x47\x57\x47\x47\x05\x58\x4B\x18\x1B\x1D\x1F\x53\x47\x47\x40\x46\x42\x58\x5B\x52\x14\x59\x51\x4D" + 0xBC5EC91D).s, SG5522);
	Sakura::Texture::Load(/*assets/skins/weapon/sg552/forearm.bmp*/XorStr<0x77, 38, 0x82E60784>("\x16\x0B\x0A\x1F\x0F\x0F\x52\x0D\x14\xE9\xEF\xF1\xAC\xF3\xE0\xE7\xF7\xE7\xE7\xA5\xF8\xEB\xB8\xBB\xBD\xBF\xF7\xFD\xE1\xF1\xF4\xE4\xFA\xB6\xFB\xF7\xEB" + 0x82E60784).s, SG5523);
	Sakura::Texture::Load(/*assets/skins/weapon/sg552/handle.bmp*/XorStr<0xD1, 37, 0xD7D2334C>("\xB0\xA1\xA0\xB1\xA1\xA5\xF8\xAB\xB2\xB3\xB5\xAF\xF2\xA9\xBA\x81\x91\x8D\x8D\xCB\x96\x81\xD2\xDD\xDB\xC5\x83\x8D\x83\x8A\x83\x95\xDF\x90\x9E\x84" + 0xD7D2334C).s, SG5524);
	Sakura::Texture::Load(/*assets/skins/weapon/sg552/magazine_transp.bmp*/XorStr<0xEA, 46, 0x7D6340A8>("\x8B\x98\x9F\x88\x9A\x9C\xDF\x82\x99\x9A\x9A\x86\xD9\x80\x9D\x98\x8A\x94\x92\xD2\x8D\x98\x35\x34\x30\x2C\x69\x64\x61\x66\x72\x60\x64\x6E\x53\x79\x7C\x6E\x7E\x62\x62\x3D\x76\x78\x66" + 0x7D6340A8).s, SG5525);
	Sakura::Texture::Load(/*assets/skins/weapon/sg552/sg552_skin.bmp*/XorStr<0xF9, 41, 0xD8E17EA7>("\x98\x89\x88\x99\x89\x8D\xD0\x73\x6A\x6B\x6D\x77\x2A\x71\x62\x69\x79\x65\x65\x23\x7E\x69\x3A\x25\x23\x3D\x60\x73\x20\x23\x25\x47\x6A\x71\x72\x72\x33\x7C\x72\x50" + 0xD8E17EA7).s, SG5526);
	Sakura::Texture::Load(/*assets/skins/weapon/shield/shield_back.bmp*/XorStr<0xE8, 43, 0x5B910B60>("\x89\x9A\x99\x8E\x98\x9E\xC1\x9C\x9B\x98\x9C\x80\xDB\x82\x93\x96\x88\x96\x94\xD4\x8F\x95\x97\x9A\x6C\x65\x2D\x70\x6C\x6C\x63\x6B\x6C\x56\x68\x6A\x6F\x66\x20\x6D\x7D\x61" + 0x5B910B60).s, SHIELD1);
	Sakura::Texture::Load(/*assets/skins/weapon/shield/shield_front.bmp*/XorStr<0x23, 44, 0x41762AAF>("\x42\x57\x56\x43\x53\x5B\x06\x59\x40\x45\x43\x5D\x00\x47\x54\x53\x43\x5B\x5B\x19\x44\x50\x50\x5F\x57\x58\x12\x4D\x57\x29\x24\x2E\x27\x1B\x23\x34\x28\x26\x3D\x64\x29\x21\x3D" + 0x41762AAF).s, SHIELD2);
	Sakura::Texture::Load(/*assets/skins/weapon/shield/shield_glass.bmp*/XorStr<0xF8, 44, 0x6462D44D>("\x99\x8A\x89\x9E\x88\x8E\xD1\x8C\x6B\x68\x6C\x70\x2B\x72\x63\x66\x78\x66\x64\x24\x7F\x65\x67\x6A\x7C\x75\x3D\x60\x7C\x7C\x73\x7B\x7C\x46\x7D\x77\x7D\x6E\x6D\x31\x42\x4C\x52" + 0x6462D44D).s, SHIELD3);
	Sakura::Texture::Load(/*assets/skins/weapon/shield/shield.bmp*/XorStr<0x6B, 38, 0x17E7D60E>("\x0A\x1F\x1E\x0B\x1B\x03\x5E\x01\x18\x1D\x1B\x05\x58\x0F\x1C\x1B\x0B\x13\x13\x51\x0C\xE8\xE8\xE7\xEF\xE0\xAA\xF5\xEF\xE1\xEC\xE6\xEF\xA2\xEF\xE3\xFF" + 0x17E7D60E).s, SHIELD31);
	Sakura::Texture::Load(/*assets/skins/weapon/smokegrenade/v_smoke_body.bmp*/XorStr<0x09, 50, 0x0B9D622D>("\x68\x79\x78\x69\x79\x7D\x20\x63\x7A\x7B\x7D\x67\x3A\x61\x72\x79\x69\x75\x75\x33\x6E\x73\x70\x4B\x44\x45\x51\x41\x4B\x47\x43\x4D\x06\x5C\x74\x5F\x40\x41\x44\x55\x6E\x50\x5C\x50\x4C\x18\x55\x55\x49" + 0x0B9D622D).s, SMOKEGRENADE1);
	Sakura::Texture::Load(/*assets/skins/weapon/smokegrenade/smoke_spoon.bmp*/XorStr<0x14, 49, 0xECBBC8BC>("\x75\x66\x65\x72\x6C\x6A\x35\x68\x77\x74\x70\x6C\x0F\x56\x47\x42\x54\x4A\x48\x08\x5B\x44\x45\x40\x49\x4A\x5C\x4A\x5E\x50\x56\x56\x1B\x46\x5B\x58\x53\x5C\x65\x48\x4C\x52\x51\x51\x6E\x23\x2F\x33" + 0xECBBC8BC).s, SMOKEGRENADE2);
	Sakura::Texture::Load(/*assets/skins/weapon/smokegrenade/smoke_top.bmp*/XorStr<0x11, 47, 0xA4AB3390>("\x70\x61\x60\x71\x61\x65\x38\x6B\x72\x73\x75\x6F\x32\x69\x7A\x41\x51\x4D\x4D\x0B\x56\x4B\x48\x43\x4C\x4D\x59\x49\x43\x4F\x4B\x55\x1E\x41\x5E\x5B\x5E\x53\x68\x4C\x56\x4A\x15\x5E\x50\x4E" + 0xA4AB3390).s, SMOKEGRENADE3);
	Sakura::Texture::Load(/*assets/skins/weapon/smokegrenade/f_body.bmp*/XorStr<0x89, 44, 0xA8F293B1>("\xE8\xF9\xF8\xE9\xF9\xFD\xA0\xE3\xFA\xFB\xFD\xE7\xBA\xE1\xF2\xF9\xE9\xF5\xF5\xB3\xEE\xF3\xF0\xCB\xC4\xC5\xD1\xC1\xCB\xC7\xC3\xCD\x86\xCC\xF4\xCE\xC2\xCA\xD6\x9E\xD3\xDF\xC3" + 0xA8F293B1).s, SMOKEGRENADE4);
	Sakura::Texture::Load(/*assets/skins/weapon/smokegrenade/f_top.bmp*/XorStr<0x56, 43, 0x9592599A>("\x37\x24\x2B\x3C\x2E\x28\x73\x2E\x35\x36\x0E\x12\x4D\x14\x01\x04\x16\x08\x06\x46\x19\x06\x03\x06\x0B\x08\x02\x14\x1C\x12\x10\x10\x59\x11\x27\x0D\x15\x0B\x52\x1F\x13\x0F" + 0x9592599A).s, SMOKEGRENADE5);
	Sakura::Texture::Load(/*assets/skins/weapon/smokegrenade/smoke_body.bmp*/XorStr<0xF1, 48, 0x453D9C64>("\x90\x81\x80\x91\x81\x85\xD8\x8B\x92\x93\x95\x8F\xD2\x89\x9A\x61\x71\x6D\x6D\x2B\x76\x6B\x68\x63\x6C\x6D\x79\x69\x63\x6F\x6B\x75\x3E\x61\x7E\x7B\x7E\x73\x48\x7A\x76\x7E\x62\x32\x7F\x73\x6F" + 0x453D9C64).s, SMOKEGRENADE10);
	Sakura::Texture::Load(/*assets/skins/weapon/tmp/barrel.bmp*/XorStr<0x88, 35, 0x85EA661D>("\xE9\xFA\xF9\xEE\xF8\xFE\xA1\xFC\xFB\xF8\xFC\xE0\xBB\xE2\xF3\xF6\xE8\xF6\xF4\xB4\xE8\xF0\xEE\xB0\xC2\xC0\xD0\xD1\xC1\xC9\x88\xC5\xC5\xD9" + 0x85EA661D).s, TMP1);
	Sakura::Texture::Load(/*assets/skins/weapon/tmp/body.bmp*/XorStr<0xFE, 33, 0x90C908BF>("\x9F\x8C\x73\x64\x76\x70\x2B\x76\x6D\x6E\x66\x7A\x25\x7C\x69\x6C\x7E\x60\x7E\x3E\x66\x7E\x64\x3A\x74\x78\x7C\x60\x34\x79\x71\x6D" + 0x90C908BF).s, TMP2);
	Sakura::Texture::Load(/*assets/skins/weapon/tmp/ejector.bmp*/XorStr<0x95, 36, 0xCD2E8054>("\xF4\xE5\xE4\xFD\xED\xE9\xB4\xEF\xF6\xF7\xF1\xD3\x8E\xD5\xC6\xC5\xD5\xC9\xC9\x87\xDD\xC7\xDB\x83\xC8\xC4\xCA\xD3\xC5\xDD\xC1\x9A\xD7\xDB\xC7" + 0xCD2E8054).s, TMP3);
	Sakura::Texture::Load(/*assets/skins/weapon/tmp/forearm.bmp*/XorStr<0x47, 36, 0xFA66A20D>("\x26\x3B\x3A\x2F\x3F\x3F\x62\x3D\x24\x39\x3F\x21\x7C\x23\x30\x37\x27\x37\x37\x75\x2F\x31\x2D\x71\x39\x0F\x13\x07\x02\x16\x08\x48\x05\x05\x19" + 0xFA66A20D).s, TMP4);
	Sakura::Texture::Load(/*assets/skins/weapon/tmp/handle.bmp*/XorStr<0x98, 35, 0x3B438740>("\xF9\xEA\xE9\xFE\xE8\xEE\xB1\xEC\xCB\xC8\xCC\xD0\x8B\xD2\xC3\xC6\xD8\xC6\xC4\x84\xD8\xC0\xDE\x80\xD8\xD0\xDC\xD7\xD8\xD0\x98\xD5\xD5\xC9" + 0x3B438740).s, TMP5);
	Sakura::Texture::Load(/*assets/skins/weapon/tmp/magazine.bmp*/XorStr<0x34, 37, 0x1DFAEF96>("\x55\x46\x45\x52\x4C\x4A\x15\x48\x57\x54\x50\x4C\x6F\x36\x27\x22\x34\x2A\x28\x68\x3C\x24\x3A\x64\x21\x2C\x29\x2E\x2A\x38\x3C\x36\x7A\x37\x3B\x27" + 0x1DFAEF96).s, TMP6);
	Sakura::Texture::Load(/*assets/skins/weapon/tmp/misc.bmp*/XorStr<0xCE, 33, 0x83DC48CA>("\xAF\xBC\xA3\xB4\xA6\xA0\xFB\xA6\xBD\xBE\xB6\xAA\xF5\xAC\xB9\xBC\xAE\xB0\x8E\xCE\x96\x8E\x94\xCA\x8B\x8E\x9B\x8A\xC4\x89\x81\x9D" + 0x83DC48CA).s, TMP7);
	Sakura::Texture::Load(/*assets/skins/weapon/tmp/silencer.bmp*/XorStr<0x3D, 37, 0x7DF65FE5>("\x5C\x4D\x4C\x25\x35\x31\x6C\x37\x2E\x2F\x29\x3B\x66\x3D\x2E\x2D\x3D\x21\x21\x7F\x25\x3F\x23\x7B\x26\x3F\x3B\x3D\x37\x39\x3E\x2E\x73\x3C\x32\x10" + 0x7DF65FE5).s, TMP8);
	Sakura::Texture::Load(/*assets/skins/weapon/tmp/top.bmp*/XorStr<0x15, 32, 0x93F05CBA>("\x74\x65\x64\x7D\x6D\x69\x34\x6F\x76\x77\x71\x53\x0E\x55\x46\x45\x55\x49\x49\x07\x5D\x47\x5B\x03\x59\x41\x5F\x1E\x53\x5F\x43" + 0x93F05CBA).s, TMP9);
	Sakura::Texture::Load(/*assets/skins/weapon/tmp/w_tmp.bmp*/XorStr<0x6A, 34, 0xD3FD8CD1>("\x0B\x18\x1F\x08\x1A\x1C\x5F\x02\x19\x1A\x1A\x06\x59\x00\x1D\x18\x0A\x14\x12\x52\x0A\x12\xF0\xAE\xF5\xDC\xF0\xE8\xF6\xA9\xEA\xE4\xFA" + 0xD3FD8CD1).s, TMP10);
	Sakura::Texture::Load(/*assets/skins/weapon/ump45/buttstock.bmp*/XorStr<0xC3, 40, 0x8709FADA>("\xA2\xB7\xB6\xA3\xB3\xBB\xE6\xB9\xA0\xA5\xA3\xBD\xE0\xA7\xB4\xB3\xA3\xBB\xBB\xF9\xA2\xB5\xA9\xEE\xEE\xF3\xBF\xAB\xAB\x94\x92\x96\x8C\x87\x8E\xC8\x85\x85\x99" + 0x8709FADA).s, UMP451);
	Sakura::Texture::Load(/*assets/skins/weapon/ump45/handle.bmp*/XorStr<0x72, 37, 0xEB3D2A0B>("\x13\x00\x07\x10\x02\x04\x57\x0A\x11\x12\x12\x0E\x51\x08\xE5\xE0\xF2\xEC\xEA\xAA\xF3\xEA\xF8\xBD\xBF\xA4\xE4\xEC\xE0\xEB\xFC\xF4\xBC\xF1\xF9\xE5" + 0xEB3D2A0B).s, UMP452);
	Sakura::Texture::Load(/*assets/skins/weapon/ump45/receiver.bmp*/XorStr<0x7C, 39, 0xE1C138CE>("\x1D\x0E\x0D\x1A\xF4\xF2\xAD\xF0\xEF\xEC\xE8\xF4\xA7\xFE\xEF\xEA\xFC\xE2\xE0\xA0\xE5\xFC\xE2\xA7\xA1\xBA\xE4\xF2\xFB\xFC\xF3\xED\xF9\xEF\xB0\xFD\xCD\xD1" + 0xE1C138CE).s, UMP453);
	Sakura::Texture::Load(/*assets/skins/weapon/ump45/ump_profile.bmp*/XorStr<0x45, 42, 0x873D4D11>("\x24\x35\x34\x2D\x3D\x39\x64\x3F\x26\x27\x21\x23\x7E\x25\x36\x35\x25\x39\x39\x77\x2C\x37\x2B\x68\x68\x71\x2A\x0D\x11\x3D\x13\x16\x0A\x00\x0E\x04\x0C\x44\x09\x01\x1D" + 0x873D4D11).s, UMP454);
	Sakura::Texture::Load(/*assets/skins/weapon/usp/handle.bmp*/XorStr<0x27, 35, 0x1D532F2F>("\x46\x5B\x5A\x4F\x5F\x5F\x02\x5D\x44\x59\x5F\x41\x1C\x43\x50\x57\x47\x57\x57\x15\x4E\x4F\x4D\x11\x57\x21\x2F\x26\x2F\x21\x6B\x24\x2A\x38" + 0x1D532F2F).s, USP1);
	Sakura::Texture::Load(/*assets/skins/weapon/usp/magazine.bmp*/XorStr<0x24, 37, 0x91488234>("\x45\x56\x55\x42\x5C\x5A\x05\x58\x47\x44\x40\x5C\x1F\x46\x57\x52\x44\x5A\x58\x18\x4D\x4A\x4A\x14\x51\x5C\x59\x5E\x3A\x28\x2C\x26\x6A\x27\x2B\x37" + 0x91488234).s, USP2);
	Sakura::Texture::Load(/*assets/skins/weapon/usp/silencer.bmp*/XorStr<0xDA, 37, 0xD4C44EBF>("\xBB\xA8\xAF\xB8\xAA\xAC\xCF\x92\x89\x8A\x8A\x96\xC9\x90\x8D\x88\x9A\x84\x82\xC2\x9B\x9C\x80\xDE\x81\x9A\x98\x90\x98\x94\x9D\x8B\xD4\x99\x91\x8D" + 0xD4C44EBF).s, USP3);
	Sakura::Texture::Load(/*assets/skins/weapon/usp/slide.bmp*/XorStr<0x21, 34, 0xB3FC8001>("\x40\x51\x50\x41\x51\x55\x08\x5B\x42\x43\x45\x5F\x02\x59\x4A\x51\x41\x5D\x5D\x1B\x40\x45\x47\x17\x4A\x56\x52\x58\x58\x10\x5D\x2D\x31" + 0xB3FC8001).s, USP4);
	Sakura::Texture::Load(/*assets/skins/weapon/usp/usp_skin.bmp*/XorStr<0x67, 37, 0x1008A8AB>("\x06\x1B\x1A\x0F\x1F\x1F\x42\x1D\x04\x19\x1F\x01\x5C\x03\x10\x17\x07\x17\x17\x55\x0E\x0F\x0D\x51\x0A\xF3\xF1\xDD\xF0\xEF\xEC\xE8\xA9\xEA\xE4\xFA" + 0x1008A8AB).s, USP5);
	Sakura::Texture::Load(/*assets/skins/weapon/xm1014/barrel.bmp*/XorStr<0x0B, 38, 0xA3F56532>("\x6A\x7F\x7E\x6B\x7B\x63\x3E\x61\x78\x7D\x7B\x65\x38\x6F\x7C\x7B\x6B\x73\x73\x31\x67\x4D\x10\x12\x12\x10\x0A\x44\x46\x5A\x5B\x4F\x47\x02\x4F\x43\x5F" + 0xA3F56532).s, XM10141);
	Sakura::Texture::Load(/*assets/skins/weapon/xm1014/body.bmp*/XorStr<0xEE, 36, 0x5FB6DD05>("\x8F\x9C\x83\x94\x86\x80\xDB\x86\x9D\x9E\x96\x8A\xD5\x8C\x99\x9C\x8E\x90\x6E\x2E\x7A\x6E\x35\x35\x37\x33\x27\x6B\x65\x6F\x75\x23\x6C\x62\x60" + 0x5FB6DD05).s, XM10142);
	Sakura::Texture::Load(/*assets/skins/weapon/xm1014/buttstock.bmp*/XorStr<0xFD, 41, 0x1141D1FF>("\x9C\x8D\x8C\x65\x75\x71\x2C\x77\x6E\x6F\x69\x7B\x26\x7D\x6E\x6D\x7D\x61\x61\x3F\x69\x7F\x22\x24\x24\x22\x38\x7A\x6C\x6E\x6F\x6F\x69\x71\x7C\x4B\x0F\x40\x4E\x54" + 0x1141D1FF).s, XM10143);
	Sakura::Texture::Load(/*assets/skins/weapon/xm1014/forearm.bmp*/XorStr<0xBD, 39, 0xB43814A3>("\xDC\xCD\xCC\xA5\xB5\xB1\xEC\xB7\xAE\xAF\xA9\xBB\xE6\xBD\xAE\xAD\xBD\xA1\xA1\xFF\xA9\xBF\xE2\xE4\xE4\xE2\xF8\xBE\xB6\xA8\xBE\xBD\xAF\xB3\xF1\x82\x8C\x92" + 0xB43814A3).s, XM10144);
	Sakura::Texture::Load(/*assets/skins/weapon/xm1014/rear_sight.bmp*/XorStr<0x20, 42, 0x668CE9BB>("\x41\x52\x51\x46\x50\x56\x09\x54\x43\x40\x44\x58\x03\x5A\x4B\x4E\x40\x5E\x5C\x1C\x4C\x58\x07\x07\x09\x0D\x15\x49\x59\x5C\x4C\x60\x33\x28\x25\x2B\x30\x6B\x24\x2A\x38" + 0x668CE9BB).s, XM10145);
	Sakura::Texture::Load(/*assets/skins/weapon/xm1014/shell.bmp*/XorStr<0x25, 37, 0xD0A47352>("\x44\x55\x54\x4D\x5D\x59\x04\x5F\x46\x47\x41\x43\x1E\x45\x56\x55\x45\x59\x59\x17\x41\x57\x0A\x0C\x0C\x0A\x10\x33\x29\x27\x2F\x28\x6B\x24\x2A\x38" + 0xD0A47352).s, XM10146);
	Sakura::Texture::Load(/*assets/skins/weapon/xm1014/xm1014.bmp*/XorStr<0x1F, 38, 0x5C973306>("\x7E\x53\x52\x47\x57\x57\x0A\x55\x4C\x41\x47\x59\x04\x5B\x48\x4F\x5F\x5F\x5F\x1D\x4B\x59\x04\x06\x06\x0C\x16\x42\x56\x0D\x0D\x0F\x0B\x6E\x23\x2F\x33" + 0x5C973306).s, XM10147);
	Sakura::Texture::Load(/*assets/skins/weapon/hands/view_glove.bmp*/XorStr<0xDA, 41, 0x23E94EF8>("\xBB\xA8\xAF\xB8\xAA\xAC\xCF\x92\x89\x8A\x8A\x96\xC9\x90\x8D\x88\x9A\x84\x82\xC2\x86\x8E\x9E\x95\x81\xDC\x82\x9C\x93\x80\xA7\x9E\x96\x94\x8A\x98\xD0\x9D\x6D\x71" + 0x23E94EF8).s, HANDS1);
	Sakura::Texture::Load(/*assets/skins/weapon/hands/view_finger.bmp*/XorStr<0x4D, 42, 0x04BB2EC5>("\x2C\x3D\x3C\x35\x25\x21\x7C\x27\x3E\x3F\x39\x2B\x76\x2D\x3E\x3D\x2D\x31\x31\x4F\x09\x03\x0D\x00\x16\x49\x11\x01\x0C\x1D\x34\x0A\x04\x00\x08\x15\x03\x5C\x11\x19\x05" + 0x04BB2EC5).s, HANDS39);
	Sakura::Texture::Load(/*assets/skins/weapon/hands/view_skin.bmp*/XorStr<0x63, 40, 0xF3EF839D>("\x02\x17\x16\x03\x13\x1B\x46\x19\x00\x05\x03\x1D\x40\x07\x14\x13\x03\x1B\x1B\x59\x1F\x19\x17\x1E\x08\x53\x0B\x17\x1A\xF7\xDE\xF1\xE8\xED\xEB\xA8\xE5\xE5\xF9" + 0xF3EF839D).s, HANDS77);
	Sakura::Texture::Load(/*assets/skins/weapon/shell/rifle_goldshell.bmp*/XorStr<0x99, 46, 0x2F3823BA>("\xF8\xE9\xE8\xF9\xE9\xED\xB0\xD3\xCA\xCB\xCD\xD7\x8A\xD1\xC2\xC9\xD9\xC5\xC5\x83\xDE\xC6\xCA\xDC\xDD\x9D\xC1\xDD\xD3\xDA\xD2\xE7\xDE\xD5\xD7\xD8\xCE\xD6\xDA\xAC\xAD\xEC\xA1\xA9\xB5" + 0x2F3823BA).s, SHELL1);
	Sakura::Texture::Load(/*assets/skins/weapon/shell/pistol_goldshell.bmp*/XorStr<0x4B, 47, 0x4229F7AB>("\x2A\x3F\x3E\x2B\x3B\x23\x7E\x21\x38\x3D\x3B\x25\x78\x2F\x3C\x3B\x2B\x33\x33\x71\x2C\x08\x04\x0E\x0F\x4B\x15\x0F\x14\x1C\x06\x06\x34\x0B\x02\x02\x0B\x03\x19\x17\x1F\x18\x5B\x14\x1A\x08" + 0x4229F7AB).s, SHELL2);
	Sakura::Texture::Load(/*assets/skins/weapon/shell/shell.bmp*/XorStr<0xE1, 36, 0xC8602DDB>("\x80\x91\x90\x81\x91\x95\xC8\x9B\x82\x83\x85\x9F\xC2\x99\x8A\x91\x81\x9D\x9D\xDB\x86\x9E\x92\x94\x95\xD5\x88\x94\x98\x92\x93\x2E\x63\x6F\x73" + 0xC8602DDB).s, SHELL3);
	Sakura::Texture::Load(/*assets/skins/player/vip/newsvip.bmp*/XorStr<0x74, 36, 0x87CF105A>("\x15\x06\x05\x12\x0C\x0A\x55\x08\x17\x14\x10\x0C\xAF\xF1\xEE\xE2\xFD\xE0\xF4\xA8\xFE\xE0\xFA\xA4\xE2\xE8\xF9\xFC\xE6\xF8\xE2\xBD\xF6\xF8\xE6" + 0x87CF105A).s, VIPBODY);
	Sakura::Texture::Load(/*assets/skins/player/vip/head2.bmp*/XorStr<0x85, 34, 0xDC004E31>("\xE4\xF5\xF4\xED\xFD\xF9\xA4\xFF\xE6\xE7\xE1\xE3\xBE\xE2\xFF\xF5\xEC\xF3\xE5\xB7\xEF\xF3\xEB\xB3\xF5\xFB\xFE\xC4\x93\x8C\xC1\xC9\xD5" + 0xDC004E31).s, VIPHEAD);
	Sakura::Texture::Load(/*assets/skins/player/vip/vip_militant_body.bmp*/XorStr<0x6C, 46, 0xB0D2FD59>("\x0D\x1E\x1D\x0A\x04\x02\x5D\x00\x1F\x1C\x18\x04\x57\x09\x16\x1A\x05\x18\x0C\x50\xF6\xE8\xF2\xAC\xF2\xEC\xF6\xD8\xE5\xE0\xE6\xE2\xF8\xEC\xE0\xFB\xCF\xF3\xFD\xF7\xED\xBB\xF4\xFA\xE8" + 0xB0D2FD59).s, VIPBODY2);
	Sakura::Texture::Load(/*assets/skins/player/vip/vip_militant_head.bmp*/XorStr<0xED, 46, 0xCA15B996>("\x8C\x9D\x9C\x95\x85\x81\xDC\x87\x9E\x9F\x99\x8B\xD6\x8A\x97\x9D\x84\x9B\x8D\x2F\x77\x6B\x73\x2B\x73\x6F\x77\x57\x64\x63\x67\x65\x79\x6F\x61\x64\x4E\x7A\x76\x75\x71\x38\x75\x75\x69" + 0xCA15B996).s, VIPHEAD2);
	Sakura::Texture::Load(/*assets/skins/player/arctic/arctic_body.bmp*/XorStr<0x18, 43, 0x9662A887>("\x79\x6A\x69\x7E\x68\x6E\x31\x6C\x4B\x48\x4C\x50\x0B\x55\x4A\x46\x51\x4C\x58\x04\x4D\x5F\x4D\x5B\x59\x52\x1D\x52\x46\x56\x42\x5E\x5B\x66\x58\x54\x58\x44\x10\x5D\x2D\x31" + 0x9662A887).s, ARCTICBODY);
	Sakura::Texture::Load(/*assets/skins/player/arctic/arctic_head2.bmp*/XorStr<0x50, 44, 0x95A96203>("\x31\x22\x21\x36\x20\x26\x79\x24\x33\x30\x34\x28\x73\x2D\x32\x3E\x19\x04\x10\x4C\x05\x17\x05\x13\x01\x0A\x45\x0A\x1E\x0E\x1A\x06\x13\x2E\x1A\x16\x15\x11\x44\x59\x1A\x14\x0A" + 0x95A96203).s, ARCTICHEAD);
	Sakura::Texture::Load(/*assets/skins/player/gign/body.bmp*/XorStr<0xC3, 34, 0x618CC1E5>("\xA2\xB7\xB6\xA3\xB3\xBB\xE6\xB9\xA0\xA5\xA3\xBD\xE0\xA0\xBD\xB3\xAA\xB1\xA7\xF9\xB0\xB1\xBE\xB4\xF4\xBE\xB2\xBA\xA6\xCE\x83\x8F\x93" + 0x618CC1E5).s, GIGNBODY);
	Sakura::Texture::Load(/*assets/skins/player/gign/helmet.bmp*/XorStr<0xF1, 36, 0x112405CF>("\x90\x81\x80\x91\x81\x85\xD8\x8B\x92\x93\x95\x8F\xD2\x8E\x93\x61\x78\x67\x71\x2B\x62\x6F\x60\x66\x26\x62\x6E\x60\x60\x6B\x7B\x3E\x73\x7F\x63" + 0x112405CF).s, GIGNHEAD);
	Sakura::Texture::Load(/*assets/skins/player/gsg9/gsg9_body.bmp*/XorStr<0x3C, 39, 0x0FC57481>("\x5D\x4E\x4D\x5A\x34\x32\x6D\x30\x2F\x2C\x28\x34\x67\x39\x26\x2A\x35\x28\x3C\x60\x37\x22\x35\x6A\x7B\x32\x25\x30\x61\x06\x38\x34\x38\x24\x70\x3D\x0D\x11" + 0x0FC57481).s, GSG9BODY);
	Sakura::Texture::Load(/*assets/skins/player/gsg9/gsg9_head.bmp*/XorStr<0xB2, 39, 0xEA5A9888>("\xD3\xC0\xC7\xD0\xC2\xC4\x97\xCA\xD1\xD2\xD2\xCE\x91\xCF\xAC\xA0\xBB\xA6\xB6\xEA\xA1\xB4\xAF\xF0\xE5\xAC\xBF\xAA\xF7\x90\xB8\xB4\xB3\xB7\xFA\xB7\xBB\xA7" + 0xEA5A9888).s, GSG9HEAD);
	Sakura::Texture::Load(/*assets/skins/player/guerilla/guerilla_body.bmp*/XorStr<0x0B, 47, 0xE9561D40>("\x6A\x7F\x7E\x6B\x7B\x63\x3E\x61\x78\x7D\x7B\x65\x38\x68\x75\x7B\x62\x79\x6F\x31\x78\x55\x44\x50\x4A\x48\x49\x47\x08\x4F\x5C\x4F\x59\x45\x41\x42\x4E\x6F\x53\x5D\x57\x4D\x1B\x54\x5A\x48" + 0xE9561D40).s, GUERILLABODY);
	Sakura::Texture::Load(/*assets/skins/player/guerilla/guerilla_head.bmp*/XorStr<0x90, 47, 0xD8FE669D>("\xF1\xE2\xE1\xF6\xE0\xE6\xB9\xE4\xF3\xF0\xF4\xE8\xB3\xED\xF2\xFE\xD9\xC4\xD0\x8C\xC3\xD0\xC3\xD5\xC1\xC5\xC6\xCA\x83\xCA\xDB\xCA\xC2\xD8\xDE\xDF\xD5\xEA\xDE\xD2\xD9\xDD\x94\xD9\xD1\xCD" + 0xD8FE669D).s, GUERILLAHEAD);
	Sakura::Texture::Load(/*assets/skins/player/leet/leet_body5.bmp*/XorStr<0x9E, 40, 0x9018B6AA>("\xFF\xEC\xD3\xC4\xD6\xD0\x8B\xD6\xCD\xCE\xC6\xDA\x85\xDB\xC0\xCC\xD7\xCA\xC2\x9E\xDE\xD6\xD1\xC1\x99\xDB\xDD\xDC\xCE\xE4\xDE\xD2\xDA\xC6\xF5\xEF\xA0\xAE\xB4" + 0x9018B6AA).s, LEETBODY);
	Sakura::Texture::Load(/*assets/skins/player/leet/guerilla_head3.bmp*/XorStr<0x4B, 44, 0x476D0054>("\x2A\x3F\x3E\x2B\x3B\x23\x7E\x21\x38\x3D\x3B\x25\x78\x28\x35\x3B\x22\x39\x2F\x71\x33\x05\x04\x16\x4C\x03\x10\x03\x15\x01\x05\x06\x0A\x33\x05\x0B\x0E\x14\x42\x5C\x11\x19\x05" + 0x476D0054).s, LEETHEAD);
	Sakura::Texture::Load(/*assets/skins/player/sas/SAS_body.bmp*/XorStr<0x6B, 37, 0xA691D4AB>("\x0A\x1F\x1E\x0B\x1B\x03\x5E\x01\x18\x1D\x1B\x05\x58\x08\x15\x1B\x02\x19\x0F\x51\x0C\xE1\xF2\xAD\xD0\xC5\xD6\xD9\xE5\xE7\xED\xF3\xA5\xEE\xE0\xFE" + 0xA691D4AB).s, SASBODY);
	Sakura::Texture::Load(/*assets/skins/player/sas/SAS_head.bmp*/XorStr<0x9E, 37, 0xB957D988>("\xFF\xEC\xD3\xC4\xD6\xD0\x8B\xD6\xCD\xCE\xC6\xDA\x85\xDB\xC0\xCC\xD7\xCA\xC2\x9E\xC1\xD2\xC7\x9A\xE5\xF6\xEB\xE6\xD2\xDE\xDD\xD9\x90\xDD\xAD\xB1" + 0xB957D988).s, SASHEAD);
	Sakura::Texture::Load(/*assets/skins/player/terror/terror_body.bmp*/XorStr<0x3F, 43, 0x2E8167AC>("\x5E\x33\x32\x27\x37\x37\x6A\x35\x2C\x21\x27\x39\x64\x3C\x21\x2F\x36\x35\x23\x7D\x27\x31\x27\x24\x38\x2A\x76\x2E\x3E\x2E\x2F\x31\x2D\x3F\x03\x0D\x07\x1D\x4B\x04\x0A\x18" + 0x2E8167AC).s, TERRORBODY);
	Sakura::Texture::Load(/*assets/skins/player/terror/terror_head3.bmp*/XorStr<0xC7, 44, 0x9BE81A48>("\xA6\xBB\xBA\xAF\xBF\xBF\xE2\xBD\xA4\xB9\xBF\xA1\xFC\xA4\xB9\xB7\xAE\xBD\xAB\xF5\xAF\xB9\xAF\xAC\xB0\x92\xCE\x96\x86\x96\x97\x89\x95\xB7\x81\x8F\x8A\x88\xDE\xC0\x8D\x9D\x81" + 0x9BE81A48).s, TERRORHEAD);
	Sakura::Texture::Load(/*assets/skins/player/urban/seal_body.bmp*/XorStr<0x94, 40, 0xB2FCB4CA>("\xF5\xE6\xE5\xF2\xEC\xEA\xB5\xE8\xF7\xF4\xF0\xEC\x8F\xD1\xCE\xC2\xDD\xC0\xD4\x88\xDD\xDB\xC8\xCA\xC2\x82\xDD\xCA\xD1\xDD\xED\xD1\xDB\xD1\xCF\x99\xDA\xD4\xCA" + 0xB2FCB4CA).s, URBANBODY);
	Sakura::Texture::Load(/*assets/skins/player/urban/seal_head.bmp*/XorStr<0xA4, 40, 0x84819A56>("\xC5\xD6\xD5\xC2\xDC\xDA\x85\xD8\xC7\xC4\xC0\xDC\x9F\xC1\xDE\xD2\xCD\xD0\xC4\x98\xCD\xCB\xD8\xDA\xD2\x92\xCD\xDA\xA1\xAD\x9D\xAB\xA1\xA4\xA2\xE9\xAA\xA4\xBA" + 0x84819A56).s, URBANHEAD);
	Sakura::Texture::Load(/*assets/skins/player/urban/seal_chrome.bmp*/XorStr<0x85, 42, 0xCA190A8B>("\xE4\xF5\xF4\xED\xFD\xF9\xA4\xFF\xE6\xE7\xE1\xE3\xBE\xE2\xFF\xF5\xEC\xF3\xE5\xB7\xEC\xE8\xF9\xFD\xF3\xB1\xEC\xC5\xC0\xCE\xFC\xC7\xCD\xD4\xC8\xC5\xCC\x84\xC9\xC1\xDD" + 0xCA190A8B).s, URBANCHROME);
	Sakura::Texture::Load(/*assets/skins/chicken/skin.bmp*/XorStr<0x51, 30, 0xEAA6EE7B>("\x30\x21\x20\x31\x21\x25\x78\x2B\x32\x33\x35\x2F\x72\x3D\x37\x09\x02\x09\x06\x0A\x4A\x15\x0C\x01\x07\x44\x09\x01\x1D" + 0xEAA6EE7B).s, CHICKEN);
}

int iHDmodel = -1;
int iBackWeapons = -1;
int iChicken = -1;
char sServerName[256];

void ReplaceTextureIndex(char* texturename, int textureindex, int restoreindex, char* modelname, int modeltype, float run)
{
	if (restoreindex > 0 && restoreindex < 11 && iHDmodel == 1)
		return;
	if (restoreindex > 10 && restoreindex < 30 && iHDmodel == 0)
		return;
	if (restoreindex > 29 && restoreindex < 46 && iBackWeapons == 0)
		return;
	if (restoreindex == 46 && iChicken == 0)
		return;

	static int RestoreIndex[1024];
	bool checkdraw = run && Sakura::ScreenShot::IsVisuals();
	if (RestoreIndex[restoreindex] == 0 && checkdraw || !checkdraw && RestoreIndex[restoreindex])
	{
		char filename[1024];
		if (modeltype == 1) sprintf(filename, /*models/player/%s/%s.mdl*/XorStr<0x41, 24, 0x39AAEE4C>("\x2C\x2D\x27\x21\x29\x35\x68\x38\x25\x2B\x32\x29\x3F\x61\x6A\x23\x7E\x77\x20\x7A\x38\x32\x3B" + 0x39AAEE4C).s, modelname, modelname);
		if (modeltype == 2) sprintf(filename, /*models/shield/%s.mdl*/XorStr<0x81, 21, 0xA41EBC69>("\xEC\xED\xE7\xE1\xE9\xF5\xA8\xFB\xE1\xE3\xEE\xE0\xE9\xA1\xAA\xE3\xBF\xFF\xF7\xF8" + 0xA41EBC69).s, modelname);
		if (modeltype == 3) sprintf(filename, /*models/%s.mdl*/XorStr<0xD4, 14, 0x2CE0A0BC>("\xB9\xBA\xB2\xB2\xB4\xAA\xF5\xFE\xAF\xF3\xB3\xBB\x8C" + 0x2CE0A0BC).s, modelname);
		
		struct model_s* pModel = g_Studio.Mod_ForName(filename, false);
		if (pModel)
		{
			studiohdr_t* pStudioHeader = (studiohdr_t*)g_Studio.Mod_Extradata(pModel);
			mstudiotexture_t* ptexture = (mstudiotexture_t*)((byte*)pStudioHeader + pStudioHeader->textureindex);
			for (size_t i = 0; i < pStudioHeader->numtextures; ++i)
			{
				if (ptexture[i].name && strstr(ptexture[i].name, texturename))
				{
					if (restoreindex > 0 && restoreindex < 11)
						iHDmodel = 0;
					if (restoreindex > 10 && restoreindex < 30)
						iHDmodel = 1;
					if (checkdraw)
					{
						RestoreIndex[restoreindex] = ptexture[i].index;
						ptexture[i].index = Sakura::Texture::texture_id[textureindex];
					}
					else
					{
						ptexture[i].index = RestoreIndex[restoreindex];
						RestoreIndex[restoreindex] = 0;
					}
				}
			}
		}
		else
		{
			if (restoreindex > 29 && restoreindex < 46)
				iBackWeapons = 0;
			if (restoreindex == 46)
				iChicken = 0;
		}
	}
}

void SetSkins()
{
	static char CurrentServerName[256];
	if (strcmp(CurrentServerName, sServerName))
	{
		iBackWeapons = -1;
		strcpy(CurrentServerName, sServerName);
	}

	static char CurrentMap[256];
	if (strcmp(CurrentMap, g_Engine.pfnGetLevelName()))
	{
		iChicken = -1;
		strcpy(CurrentMap, g_Engine.pfnGetLevelName());
	}

	if (loadtexturemodel)
	{
		GetTextureModel();
		loadtexturemodel = false;
	}
	
	int index = 1;
	ReplaceTextureIndex(/*ARTIC_Working1*/XorStr<0x92, 15, 0x9F140253>("\xD3\xC1\xC0\xDC\xD5\xC8\xCF\xF6\xE8\xF0\xF5\xF3\xF9\xAE" + 0x9F140253).s, PLAYER1, index, /*arctic*/XorStr<0xF3, 7, 0x450A6820>("\x92\x86\x96\x82\x9E\x9B" + 0x450A6820).s, 1, cvar.visual_skins_player), index++;
	ReplaceTextureIndex(/*GIGN_DMBASE2*/XorStr<0x77, 13, 0xA712E74D>("\x30\x31\x3E\x34\x24\x38\x30\x3C\x3E\xD3\xC4\xB0" + 0xA712E74D).s, PLAYER2, index, /*gign*/XorStr<0x94, 5, 0x23422AE2>("\xF3\xFC\xF1\xF9" + 0x23422AE2).s, 1, cvar.visual_skins_player), index++;
	ReplaceTextureIndex(/*GSG9_Working1*/XorStr<0xB5, 14, 0x288875FC>("\xF2\xE5\xF0\x81\xE6\xED\xD4\xCE\xD6\xD7\xD1\xA7\xF0" + 0x288875FC).s, PLAYER3, index, /*gsg9*/XorStr<0x5B, 5, 0xDF089642>("\x3C\x2F\x3A\x67" + 0xDF089642).s, 1, cvar.visual_skins_player), index++;
	ReplaceTextureIndex(/*GUERILLA_DMBASE*/XorStr<0xF2, 16, 0xF15D7F45>("\xB5\xA6\xB1\xA7\xBF\xBB\xB4\xB8\xA5\xBF\xB1\xBF\xBF\xAC\x45" + 0xF15D7F45).s, PLAYER4, index, /*guerilla*/XorStr<0x0B, 9, 0x35A6FF24>("\x6C\x79\x68\x7C\x66\x7C\x7D\x73" + 0x35A6FF24).s, 1, cvar.visual_skins_player), index++;
	ReplaceTextureIndex(/*Arab_dmbase1*/XorStr<0x18, 13, 0xFD310637>("\x59\x6B\x7B\x79\x43\x79\x73\x7D\x41\x52\x47\x12" + 0xFD310637).s, PLAYER5, index, /*leet*/XorStr<0xA6, 5, 0x10469BE7>("\xCA\xC2\xCD\xDD" + 0x10469BE7).s, 1, cvar.visual_skins_player), index++;
	ReplaceTextureIndex(/*SAS_DMBASE1*/XorStr<0xA4, 12, 0xD98E16F8>("\xF7\xE4\xF5\xF8\xEC\xE4\xE8\xEA\xFF\xE8\x9F" + 0xD98E16F8).s, PLAYER6, index, /*sas*/XorStr<0xF7, 4, 0x62BCDB02>("\x84\x99\x8A" + 0x62BCDB02).s, 1, cvar.visual_skins_player), index++;
	ReplaceTextureIndex(/*Terrorist_Working1*/XorStr<0xAC, 19, 0x7B07171E>("\xF8\xC8\xDC\xDD\xDF\xC3\xDB\xC0\xC0\xEA\xE1\xD8\xCA\xD2\xD3\xD5\xDB\x8C" + 0x7B07171E).s, PLAYER7, index, /*terror*/XorStr<0xA0, 7, 0x1A161892>("\xD4\xC4\xD0\xD1\xCB\xD7" + 0x1A161892).s, 1, cvar.visual_skins_player), index++;
	ReplaceTextureIndex(/*SEAL_Working1*/XorStr<0x43, 14, 0x14373E71>("\x10\x01\x04\x0A\x18\x1F\x26\x38\x20\x25\x23\x29\x7E" + 0x14373E71).s, PLAYER8, index, /*urban*/XorStr<0x54, 6, 0x8ED3AD99>("\x21\x27\x34\x36\x36" + 0x8ED3AD99).s, 1, cvar.visual_skins_player), index++;
	ReplaceTextureIndex(/*newsvip*/XorStr<0x8D, 8, 0xE3AF7729>("\xE3\xEB\xF8\xE3\xE7\xFB\xE3" + 0xE3AF7729).s, VIPBODY, index, /*vip*/XorStr<0xEA, 4, 0xA3ED510E>("\x9C\x82\x9C" + 0xA3ED510E).s, 1, cvar.visual_skins_player), index++;
	ReplaceTextureIndex(/*head2*/XorStr<0x98, 6, 0xEE31003F>("\xF0\xFC\xFB\xFF\xAE" + 0xEE31003F).s, VIPHEAD, index, /*vip*/XorStr<0xD8, 4, 0xF42E6793>("\xAE\xB0\xAA" + 0xF42E6793).s, 1, cvar.visual_skins_player), index++;
	ReplaceTextureIndex(/*vip_militant_body*/XorStr<0xDB, 18, 0xF422C405>("\xAD\xB5\xAD\x81\xB2\x89\x8D\x8B\x97\x85\x8B\x92\xB8\x8A\x86\x8E\x92" + 0xF422C405).s, VIPBODY2, index, /*vip*/XorStr<0x5C, 4, 0xE347376C>("\x2A\x34\x2E" + 0xE347376C).s, 1, cvar.visual_skins_player), index++;
	ReplaceTextureIndex(/*vip_militant_head*/XorStr<0x96, 18, 0x32B2A447>("\xE0\xFE\xE8\xC6\xF7\xF2\xF0\xF4\xEA\xFE\xCE\xD5\xFD\xCB\xC1\xC4\xC2" + 0x32B2A447).s, VIPHEAD2, index, /*vip*/XorStr<0x78, 4, 0x71B1CDE2>("\x0E\x10\x0A" + 0x71B1CDE2).s, 1, cvar.visual_skins_player), index++;
	ReplaceTextureIndex(/*arctic_body*/XorStr<0x68, 12, 0x26B1DA7A>("\x09\x1B\x09\x1F\x05\x0E\x31\x0D\x1F\x15\x0B" + 0x26B1DA7A).s, ARCTICBODY, index, /*arctic*/XorStr<0x37, 7, 0x74F808AD>("\x56\x4A\x5A\x4E\x52\x5F" + 0x74F808AD).s, 1, cvar.visual_skins_player), index++;
	ReplaceTextureIndex(/*arctic_head2*/XorStr<0xD6, 13, 0xC30B94B1>("\xB7\xA5\xBB\xAD\xB3\xB8\x83\xB5\xBB\xBE\x84\xD3" + 0xC30B94B1).s, ARCTICHEAD, index, /*arctic*/XorStr<0x73, 7, 0xD9EC9BAE>("\x12\x06\x16\x02\x1E\x1B" + 0xD9EC9BAE).s, 1, cvar.visual_skins_player), index++;
	ReplaceTextureIndex(/*body*/XorStr<0xAD, 5, 0xED051EAD>("\xCF\xC1\xCB\xC9" + 0xED051EAD).s, GIGNBODY, index, /*gign*/XorStr<0x34, 5, 0x750AE730>("\x53\x5C\x51\x59" + 0x750AE730).s, 1, cvar.visual_skins_player), index++;
	ReplaceTextureIndex(/*helmet*/XorStr<0x4F, 7, 0xFB3C4A99>("\x27\x35\x3D\x3F\x36\x20" + 0xFB3C4A99).s, GIGNHEAD, index, /*gign*/XorStr<0xE5, 5, 0xA7E624BE>("\x82\x8F\x80\x86" + 0xA7E624BE).s, 1, cvar.visual_skins_player), index++;
	ReplaceTextureIndex(/*gsg9_body*/XorStr<0xAD, 10, 0x1B242E96>("\xCA\xDD\xC8\x89\xEE\xD0\xDC\xD0\xCC" + 0x1B242E96).s, GSG9BODY, index, /*gsg9*/XorStr<0x3F, 5, 0xCA40CE18>("\x58\x33\x26\x7B" + 0xCA40CE18).s, 1, cvar.visual_skins_player), index++;
	ReplaceTextureIndex(/*gsg9_head*/XorStr<0x8A, 10, 0xA2C46196>("\xED\xF8\xEB\xB4\xD1\xE7\xF5\xF0\xF6" + 0xA2C46196).s, GSG9HEAD, index, /*gsg9*/XorStr<0xF0, 5, 0x51C34F0F>("\x97\x82\x95\xCA" + 0x51C34F0F).s, 1, cvar.visual_skins_player), index++;
	ReplaceTextureIndex(/*guerilla_body*/XorStr<0x51, 14, 0xD8262561>("\x36\x27\x36\x26\x3C\x3A\x3B\x39\x06\x38\x34\x38\x24" + 0xD8262561).s, GUERILLABODY, index, /*guerilla*/XorStr<0x69, 9, 0x76CCAA93>("\x0E\x1F\x0E\x1E\x04\x02\x03\x11" + 0x76CCAA93).s, 1, cvar.visual_skins_player), index++;
	ReplaceTextureIndex(/*guerilla_head*/XorStr<0x86, 14, 0x6BE75B28>("\xE1\xF2\xED\xFB\xE3\xE7\xE0\xEC\xD1\xE7\xF5\xF0\xF6" + 0x6BE75B28).s, GUERILLAHEAD, index, /*guerilla*/XorStr<0xFF, 9, 0x7ED95041>("\x98\x75\x64\x70\x6A\x68\x69\x67" + 0x7ED95041).s, 1, cvar.visual_skins_player), index++;
	ReplaceTextureIndex(/*leet_body5*/XorStr<0x3B, 11, 0x5AFDA483>("\x57\x59\x58\x4A\x60\x22\x2E\x26\x3A\x71" + 0x5AFDA483).s, LEETBODY, index, /*leet*/XorStr<0x7C, 5, 0xADD6A2F7>("\x10\x18\x1B\x0B" + 0xADD6A2F7).s, 1, cvar.visual_skins_player), index++;
	ReplaceTextureIndex(/*guerilla_head3*/XorStr<0xF2, 15, 0xC33B9770>("\x95\x86\x91\x87\x9F\x9B\x94\x98\xA5\x93\x99\x9C\x9A\xCC" + 0xC33B9770).s, LEETHEAD, index, /*leet*/XorStr<0x81, 5, 0x814888D4>("\xED\xE7\xE6\xF0" + 0x814888D4).s, 1, cvar.visual_skins_player), index++;
	ReplaceTextureIndex(/*SAS_body*/XorStr<0x2F, 9, 0x7CB7F00D>("\x7C\x71\x62\x6D\x51\x5B\x51\x4F" + 0x7CB7F00D).s, SASBODY, index, /*sas*/XorStr<0x2D, 4, 0x4D1C1A08>("\x5E\x4F\x5C" + 0x4D1C1A08).s, 1, cvar.visual_skins_player), index++;
	ReplaceTextureIndex(/*SAS_head*/XorStr<0x7A, 9, 0x069043F5>("\x29\x3A\x2F\x22\x16\x1A\xE1\xE5" + 0x069043F5).s, SASHEAD, index, /*sas*/XorStr<0xF3, 4, 0x7829D3C8>("\x80\x95\x86" + 0x7829D3C8).s, 1, cvar.visual_skins_player), index++;
	ReplaceTextureIndex(/*terror_body*/XorStr<0x54, 12, 0xA4B09518>("\x20\x30\x24\x25\x37\x2B\x05\x39\x33\x39\x27" + 0xA4B09518).s, TERRORBODY, index, /*terror*/XorStr<0xCB, 7, 0xA722BEF9>("\xBF\xA9\xBF\xBC\xA0\xA2" + 0xA722BEF9).s, 1, cvar.visual_skins_player), index++;
	ReplaceTextureIndex(/*terror_head3*/XorStr<0x9C, 13, 0xDE0CB665>("\xE8\xF8\xEC\xED\xCF\xD3\xFD\xCB\xC1\xC4\xC2\x94" + 0xDE0CB665).s, TERRORHEAD, index, /*terror*/XorStr<0x83, 7, 0x38FAAD0D>("\xF7\xE1\xF7\xF4\xE8\xFA" + 0x38FAAD0D).s, 1, cvar.visual_skins_player), index++;
	ReplaceTextureIndex(/*seal_body*/XorStr<0x2A, 10, 0xF5B7C3BF>("\x59\x4E\x4D\x41\x71\x4D\x5F\x55\x4B" + 0xF5B7C3BF).s, URBANBODY, index, /*urban*/XorStr<0x14, 6, 0x81A54CB9>("\x61\x67\x74\x76\x76" + 0x81A54CB9).s, 1, cvar.visual_skins_player), index++;
	ReplaceTextureIndex(/*seal_head*/XorStr<0x3C, 10, 0xD73FEF98>("\x4F\x58\x5F\x53\x1F\x29\x27\x22\x20" + 0xD73FEF98).s, URBANHEAD, index, /*urban*/XorStr<0x51, 6, 0x5C35406C>("\x24\x20\x31\x35\x3B" + 0x5C35406C).s, 1, cvar.visual_skins_player), index++;
	ReplaceTextureIndex(/*seal_chrome*/XorStr<0x28, 12, 0xDF2646D1>("\x5B\x4C\x4B\x47\x73\x4E\x46\x5D\x5F\x5C\x57" + 0xDF2646D1).s, URBANCHROME, index, /*urban*/XorStr<0x9F, 6, 0xEBA80BDE>("\xEA\xD2\xC3\xC3\xCD" + 0xEBA80BDE).s, 1, cvar.visual_skins_player), index++;
	ReplaceTextureIndex(/*ak47_skin*/XorStr<0xC8, 10, 0x9D6C2349>("\xA9\xA2\xFE\xFC\x93\xBE\xA5\xA6\xBE" + 0x9D6C2349).s, AK479, index, /*backweapons*/XorStr<0x4F, 12, 0xE86F9F33>("\x2D\x31\x32\x39\x24\x31\x34\x26\x38\x36\x2A" + 0xE86F9F33).s, 3, cvar.visual_skins_player_backweapon), index++;
	ReplaceTextureIndex(/*w_aug*/XorStr<0x67, 6, 0xCEA2854D>("\x10\x37\x08\x1F\x0C" + 0xCEA2854D).s, AUG4, index, /*backweapons*/XorStr<0xFC, 12, 0xB877E156>("\x9E\x9C\x9D\x94\x77\x64\x63\x73\x6B\x6B\x75" + 0xB877E156).s, 3, cvar.visual_skins_player_backweapon), index++;
	ReplaceTextureIndex(/*w_awp*/XorStr<0x5F, 6, 0xBBB65D82>("\x28\x3F\x00\x15\x13" + 0xBBB65D82).s, AWP11, index, /*backweapons*/XorStr<0x82, 12, 0x4F3DB495>("\xE0\xE2\xE7\xEE\xF1\xE2\xE9\xF9\xE5\xE5\xFF" + 0x4F3DB495).s, 3, cvar.visual_skins_player_backweapon), index++;
	ReplaceTextureIndex(/*p_famas*/XorStr<0x8F, 8, 0x92530737>("\xFF\xCF\xF7\xF3\xFE\xF5\xE6" + 0x92530737).s, FAMAS2, index, /*backweapons*/XorStr<0x5F, 12, 0x07256F3E>("\x3D\x01\x02\x09\x14\x01\x04\x16\x08\x06\x1A" + 0x07256F3E).s, 3, cvar.visual_skins_player_backweapon), index++;
	ReplaceTextureIndex(/*w_g3sg1*/XorStr<0xEA, 8, 0x98C7DE1D>("\x9D\xB4\x8B\xDE\x9D\x88\xC1" + 0x98C7DE1D).s, G3SG19, index, /*backweapons*/XorStr<0x57, 12, 0x2F3F4401>("\x35\x39\x3A\x31\x2C\x39\x3C\x2E\x30\x0E\x12" + 0x2F3F4401).s, 3, cvar.visual_skins_player_backweapon), index++;
	ReplaceTextureIndex(/*p_galil*/XorStr<0x76, 8, 0xFBEC9C0E>("\x06\x28\x1F\x18\x16\x12\x10" + 0xFBEC9C0E).s, GALIL2, index, /*backweapons*/XorStr<0x40, 12, 0xC6B7D802>("\x22\x20\x21\x28\x33\x20\x27\x37\x27\x27\x39" + 0xC6B7D802).s, 3, cvar.visual_skins_player_backweapon), index++;
	ReplaceTextureIndex(/*w_m3super90*/XorStr<0xCE, 12, 0x640B221D>("\xB9\x90\xBD\xE2\xA1\xA6\xA4\xB0\xA4\xEE\xE8" + 0x640B221D).s, M35, index, /*backweapons*/XorStr<0x48, 12, 0x3570190D>("\x2A\x28\x29\x20\x3B\x28\x2F\x3F\x3F\x3F\x21" + 0x3570190D).s, 3, cvar.visual_skins_player_backweapon), index++;
	ReplaceTextureIndex(/*m4a1_skin*/XorStr<0x55, 10, 0xE1B07C48>("\x38\x62\x36\x69\x06\x29\x30\x35\x33" + 0xE1B07C48).s, M4A17, index, /*backweapons*/XorStr<0x1C, 12, 0xF7FC33EF>("\x7E\x7C\x7D\x74\x57\x44\x43\x53\x4B\x4B\x55" + 0xF7FC33EF).s, 3, cvar.visual_skins_player_backweapon), index++;
	ReplaceTextureIndex(/*w_m249*/XorStr<0xBE, 7, 0x8ADD1A99>("\xC9\xE0\xAD\xF3\xF6\xFA" + 0x8ADD1A99).s, M24910, index, /*backweapons*/XorStr<0x59, 12, 0xE3D89156>("\x3B\x3B\x38\x37\x2A\x3B\x3E\x10\x0E\x0C\x10" + 0xE3D89156).s, 3, cvar.visual_skins_player_backweapon), index++;
	ReplaceTextureIndex(/*w_mp5*/XorStr<0x0D, 6, 0xD56164A4>("\x7A\x51\x62\x60\x24" + 0xD56164A4).s, MP58, index, /*backweapons*/XorStr<0x6D, 12, 0x1B1B4A52>("\x0F\x0F\x0C\x1B\x06\x17\x12\x04\x1A\x18\x04" + 0x1B1B4A52).s, 3, cvar.visual_skins_player_backweapon), index++;
	ReplaceTextureIndex(/*w_p90*/XorStr<0x03, 6, 0x143CA428>("\x74\x5B\x75\x3F\x37" + 0x143CA428).s, P906, index, /*backweapons*/XorStr<0x43, 12, 0xC61DDFF9>("\x21\x25\x26\x2D\x30\x2D\x28\x3A\x24\x22\x3E" + 0xC61DDFF9).s, 3, cvar.visual_skins_player_backweapon), index++;
	ReplaceTextureIndex(/*w_scout*/XorStr<0xB8, 8, 0x0C6AEFCA>("\xCF\xE6\xC9\xD8\xD3\xC8\xCA" + 0x0C6AEFCA).s, SCOUT6, index, /*backweapons*/XorStr<0xC1, 12, 0x2C4AF193>("\xA3\xA3\xA0\xAF\xB2\xA3\xA6\xB8\xA6\xA4\xB8" + 0x2C4AF193).s, 3, cvar.visual_skins_player_backweapon), index++;
	ReplaceTextureIndex(/*sg550_profile*/XorStr<0xFB, 14, 0x3D67CAF0>("\x88\x9B\xC8\xCB\xCF\x5F\x71\x70\x6C\x62\x6C\x6A\x62" + 0x3D67CAF0).s, SG5507, index, /*backweapons*/XorStr<0x6A, 12, 0x65C2E264>("\x08\x0A\x0F\x06\x19\x0A\x11\x01\x1D\x1D\x07" + 0x65C2E264).s, 3, cvar.visual_skins_player_backweapon), index++;
	ReplaceTextureIndex(/*sg552_skin*/XorStr<0x9C, 11, 0x117F9016>("\xEF\xFA\xAB\xAA\x92\xFE\xD1\xC8\xCD\xCB" + 0x117F9016).s, SG5526, index, /*backweapons*/XorStr<0xB8, 12, 0xFF1C8242>("\xDA\xD8\xD9\xD0\xCB\xD8\xDF\xCF\xAF\xAF\xB1" + 0xFF1C8242).s, 3, cvar.visual_skins_player_backweapon), index++;
	ReplaceTextureIndex(/*ump_profile*/XorStr<0x89, 12, 0x57560BF9>("\xFC\xE7\xFB\xD3\xFD\xFC\xE0\xF6\xF8\xFE\xF6" + 0x57560BF9).s, UMP454, index, /*backweapons*/XorStr<0x6B, 12, 0x015B2E94>("\x09\x0D\x0E\x05\x18\x15\x10\x02\x1C\x1A\x06" + 0x015B2E94).s, 3, cvar.visual_skins_player_backweapon), index++;
	ReplaceTextureIndex(/*xm1014*/XorStr<0x42, 7, 0x87926DAD>("\x3A\x2E\x75\x75\x77\x73" + 0x87926DAD).s, XM10147, index, /*backweapons*/XorStr<0xD5, 12, 0x4CE13527>("\xB7\xB7\xB4\xB3\xAE\xBF\xBA\xAC\xB2\xB0\xAC" + 0x4CE13527).s, 3, cvar.visual_skins_player_backweapon), index++;
	ReplaceTextureIndex(/*skin*/XorStr<0x1A, 5, 0xC87A07D2>("\x69\x70\x75\x73" + 0xC87A07D2).s, CHICKEN, index, /*chick*/XorStr<0x1C, 6, 0x660B492C>("\x7F\x75\x77\x7C\x4B" + 0x660B492C).s, 3, cvar.visual_skins_chicken), index++;
	ReplaceTextureIndex(/*Backpack1*/XorStr<0xE7, 10, 0x511D101D>("\xA5\x89\x8A\x81\x9B\x8D\x8E\x85\xDE" + 0x511D101D).s, BACKPACK1, index, /*arctic*/XorStr<0xE0, 7, 0x21BF99B9>("\x81\x93\x81\x97\x8D\x86" + 0x21BF99B9).s, 1, cvar.visual_skins_backpack), index++;
	ReplaceTextureIndex(/*Backpack1*/XorStr<0x9E, 10, 0xFA727CDB>("\xDC\xFE\xC3\xCA\xD2\xC2\xC7\xCE\x97" + 0xFA727CDB).s, BACKPACK1, index, /*guerilla*/XorStr<0x7A, 9, 0xBF261DEB>("\x1D\x0E\x19\x0F\x17\x13\xEC\xE0" + 0xBF261DEB).s, 1, cvar.visual_skins_backpack), index++;
	ReplaceTextureIndex(/*Backpack1*/XorStr<0xCB, 10, 0x842E61D3>("\x89\xAD\xAE\xA5\xBF\xB1\xB2\xB9\xE2" + 0x842E61D3).s, BACKPACK1, index, /*leet*/XorStr<0xD8, 5, 0xED981061>("\xB4\xBC\xBF\xAF" + 0xED981061).s, 1, cvar.visual_skins_backpack), index++;
	ReplaceTextureIndex(/*Backpack1*/XorStr<0x61, 10, 0xACAEE182>("\x23\x03\x00\x0F\x15\x07\x04\x03\x58" + 0xACAEE182).s, BACKPACK1, index, /*terror*/XorStr<0xA7, 7, 0x8639A488>("\xD3\xCD\xDB\xD8\xC4\xDE" + 0x8639A488).s, 1, cvar.visual_skins_backpack), index++;
	ReplaceTextureIndex(/*Backpack2*/XorStr<0xBA, 10, 0x72CDA852>("\xF8\xDA\xDF\xD6\xCE\xDE\xA3\xAA\xF0" + 0x72CDA852).s, THIGHPACK1, index, /*gign*/XorStr<0xEB, 5, 0x4EC4A7E7>("\x8C\x85\x8A\x80" + 0x4EC4A7E7).s, 1, cvar.visual_skins_thighpack), index++;
	ReplaceTextureIndex(/*Backpack2*/XorStr<0xBB, 10, 0xA43A1F8F>("\xF9\xDD\xDE\xD5\xCF\xA1\xA2\xA9\xF1" + 0xA43A1F8F).s, THIGHPACK1, index, /*gsg9*/XorStr<0xE8, 5, 0xB983F173>("\x8F\x9A\x8D\xD2" + 0xB983F173).s, 1, cvar.visual_skins_thighpack), index++;
	ReplaceTextureIndex(/*Backpack2*/XorStr<0x63, 10, 0x46ACF3A3>("\x21\x05\x06\x0D\x17\x09\x0A\x01\x59" + 0x46ACF3A3).s, THIGHPACK1, index, /*sas*/XorStr<0x99, 4, 0xF9C9FBE4>("\xEA\xFB\xE8" + 0xF9C9FBE4).s, 1, cvar.visual_skins_thighpack), index++;
	ReplaceTextureIndex(/*Backpack2*/XorStr<0xD1, 10, 0x651E4AE6>("\x93\xB3\xB0\xBF\xA5\xB7\xB4\xB3\xEB" + 0x651E4AE6).s, THIGHPACK1, index, /*urban*/XorStr<0xA8, 6, 0x6723B5B3>("\xDD\xDB\xC8\xCA\xC2" + 0x6723B5B3).s, 1, cvar.visual_skins_thighpack), index++;
	ReplaceTextureIndex(/*Backpack1*/XorStr<0x7A, 10, 0x5DF72A61>("\x38\x1A\x1F\x16\x0E\x1E\xE3\xEA\xB3" + 0x5DF72A61).s, BACKPACK1, index, /*w_backpack*/XorStr<0x13, 11, 0x9C379606>("\x64\x4B\x77\x77\x74\x73\x69\x7B\x78\x77" + 0x9C379606).s, 3, cvar.visual_skins_world), index++;
	ReplaceTextureIndex(/*Backpack2*/XorStr<0x66, 10, 0xBF7FB850>("\x24\x06\x0B\x02\x1A\x0A\x0F\x06\x5C" + 0xBF7FB850).s, THIGHPACK1, index, /*w_thighpack*/XorStr<0x4A, 12, 0x75259205>("\x3D\x14\x38\x25\x27\x28\x38\x21\x33\x30\x3F" + 0x75259205).s, 3, cvar.visual_skins_world), index++;
	ReplaceTextureIndex(/*ak47_skin*/XorStr<0x65, 10, 0xE1878BE3>("\x04\x0D\x53\x5F\x36\x19\x00\x05\x03" + 0xE1878BE3).s, AK479, index, /*w_ak47*/XorStr<0x88, 7, 0xD09EF39D>("\xFF\xD6\xEB\xE0\xB8\xBA" + 0xD09EF39D).s, 3, cvar.visual_skins_world), index++;
	ReplaceTextureIndex(/*kevlar_vest*/XorStr<0x21, 12, 0xFF2F29C0>("\x4A\x47\x55\x48\x44\x54\x78\x5E\x4C\x59\x5F" + 0xFF2F29C0).s, KEVLAR, index, /*w_assault*/XorStr<0xB6, 10, 0xF3C30F22>("\xC1\xE8\xD9\xCA\xC9\xDA\xC9\xD1\xCA" + 0xF3C30F22).s, 3, cvar.visual_skins_world), index++;
	ReplaceTextureIndex(/*w_aug*/XorStr<0xDE, 6, 0x2269660C>("\xA9\x80\x81\x94\x85" + 0x2269660C).s, AUG4, index, /*w_aug*/XorStr<0x3E, 6, 0x5033B53A>("\x49\x60\x21\x34\x25" + 0x5033B53A).s, 3, cvar.visual_skins_world), index++;
	ReplaceTextureIndex(/*w_awp*/XorStr<0x88, 6, 0x9B0DF991>("\xFF\xD6\xEB\xFC\xFC" + 0x9B0DF991).s, AWP11, index, /*w_awp*/XorStr<0x24, 6, 0x8E123FA7>("\x53\x7A\x47\x50\x58" + 0x8E123FA7).s, 3, cvar.visual_skins_world), index++;
	ReplaceTextureIndex(/*c4base*/XorStr<0x26, 7, 0x295F2034>("\x45\x13\x4A\x48\x59\x4E" + 0x295F2034).s, C41, index, /*w_c4*/XorStr<0xB2, 5, 0x26275EF8>("\xC5\xEC\xD7\x81" + 0x26275EF8).s, 3, cvar.visual_skins_world), index++;
	ReplaceTextureIndex(/*c4timer*/XorStr<0x92, 8, 0xEB99815F>("\xF1\xA7\xE0\xFC\xFB\xF2\xEA" + 0xEB99815F).s, C43, index, /*w_c4*/XorStr<0x97, 5, 0xFC4964BA>("\xE0\xC7\xFA\xAE" + 0xFC4964BA).s, 3, cvar.visual_skins_world), index++;
	ReplaceTextureIndex(/*c4wires*/XorStr<0xD3, 8, 0x18E641A9>("\xB0\xE0\xA2\xBF\xA5\xBD\xAA" + 0x18E641A9).s, C44, index, /*w_c4*/XorStr<0x35, 5, 0xD3B5DCBA>("\x42\x69\x54\x0C" + 0xD3B5DCBA).s, 3, cvar.visual_skins_world), index++;
	ReplaceTextureIndex(/*deserteagle_skin*/XorStr<0x5A, 17, 0x190636FB>("\x3E\x3E\x2F\x38\x2C\x2B\x05\x00\x05\x0F\x01\x3A\x15\x0C\x01\x07" + 0x190636FB).s, DEAGLE4, index, /*w_deagle*/XorStr<0x10, 9, 0x158D85D5>("\x67\x4E\x76\x76\x75\x72\x7A\x72" + 0x158D85D5).s, 3, cvar.visual_skins_world), index++;
	ReplaceTextureIndex(/*w_elite*/XorStr<0xFE, 8, 0xB18DD0F2>("\x89\xA0\x65\x6D\x6B\x77\x61" + 0xB18DD0F2).s, ELITE5, index, /*w_elite*/XorStr<0x87, 8, 0x5A86F2EE>("\xF0\xD7\xEC\xE6\xE2\xF8\xE8" + 0x5A86F2EE).s, 3, cvar.visual_skins_world), index++;
	ReplaceTextureIndex(/*p_famas*/XorStr<0xF0, 8, 0xDECDA21C>("\x80\xAE\x94\x92\x99\x94\x85" + 0xDECDA21C).s, FAMAS2, index, /*w_famas*/XorStr<0x2E, 8, 0x9198C715>("\x59\x70\x56\x50\x5F\x52\x47" + 0x9198C715).s, 3, cvar.visual_skins_world), index++;
	ReplaceTextureIndex(/*57_profile*/XorStr<0x07, 11, 0xA6D4CD65>("\x32\x3F\x56\x7A\x79\x63\x6B\x67\x63\x75" + 0xA6D4CD65).s, FIVESEVEN3, index, /*w_fiveseven*/XorStr<0x75, 12, 0x3EAFA985>("\x02\x29\x11\x11\x0F\x1F\x08\x19\x0B\x1B\x11" + 0x3EAFA985).s, 3, cvar.visual_skins_world), index++;
	ReplaceTextureIndex(/*f_body*/XorStr<0xF1, 7, 0x56BB5930>("\x97\xAD\x91\x9B\x91\x8F" + 0x56BB5930).s, FLASHBANG4, index, /*w_flashbang*/XorStr<0xAC, 12, 0x9EE9B63A>("\xDB\xF2\xC8\xC3\xD1\xC2\xDA\xD1\xD5\xDB\xD1" + 0x9EE9B63A).s, 3, cvar.visual_skins_world), index++;
	ReplaceTextureIndex(/*f_top*/XorStr<0x93, 6, 0x6C782E98>("\xF5\xCB\xE1\xF9\xE7" + 0x6C782E98).s, FLASHBANG5, index, /*w_flashbang*/XorStr<0x9C, 12, 0xB4275BC9>("\xEB\xC2\xF8\xF3\xC1\xD2\xCA\xC1\xC5\xCB\xC1" + 0xB4275BC9).s, 3, cvar.visual_skins_world), index++;
	ReplaceTextureIndex(/*w_g3sg1*/XorStr<0xC6, 8, 0x9453C352>("\xB1\x98\xAF\xFA\xB9\xAC\xFD" + 0x9453C352).s, G3SG19, index, /*w_g3sg1*/XorStr<0x8D, 8, 0xB839A5F8>("\xFA\xD1\xE8\xA3\xE2\xF5\xA2" + 0xB839A5F8).s, 3, cvar.visual_skins_world), index++;
	ReplaceTextureIndex(/*p_galil*/XorStr<0x80, 8, 0x510AAC9A>("\xF0\xDE\xE5\xE2\xE8\xEC\xEA" + 0x510AAC9A).s, GALIL2, index, /*w_galil*/XorStr<0x27, 8, 0xCE3B4394>("\x50\x77\x4E\x4B\x47\x45\x41" + 0xCE3B4394).s, 3, cvar.visual_skins_world), index++;
	ReplaceTextureIndex(/*w_glock*/XorStr<0x8D, 8, 0xC8B176C0>("\xFA\xD1\xE8\xFC\xFE\xF1\xF8" + 0xC8B176C0).s, GLOCK185, index, /*w_glock18*/XorStr<0x68, 10, 0x477D2458>("\x1F\x36\x0D\x07\x03\x0E\x05\x5E\x48" + 0x477D2458).s, 3, cvar.visual_skins_world), index++;
	ReplaceTextureIndex(/*f_body*/XorStr<0xCF, 7, 0xCBB85F01>("\xA9\x8F\xB3\xBD\xB7\xAD" + 0xCBB85F01).s, HEGRENADE4, index, /*w_hegrenade*/XorStr<0x58, 12, 0x5CCC3A82>("\x2F\x06\x32\x3E\x3B\x2F\x3B\x31\x01\x05\x07" + 0x5CCC3A82).s, 3, cvar.visual_skins_world), index++;
	ReplaceTextureIndex(/*f_top*/XorStr<0xD3, 6, 0x58E0DD78>("\xB5\x8B\xA1\xB9\xA7" + 0x58E0DD78).s, HEGRENADE5, index, /*w_hegrenade*/XorStr<0x70, 12, 0xD7E3F160>("\x07\x2E\x1A\x16\x13\x07\x13\x19\x19\x1D\x1F" + 0xD7E3F160).s, 3, cvar.visual_skins_world), index++;
	ReplaceTextureIndex(/*w_m3super90*/XorStr<0x5F, 12, 0xD1290F37>("\x28\x3F\x0C\x51\x10\x11\x15\x03\x15\x51\x59" + 0xD1290F37).s, M35, index, /*w_m3*/XorStr<0x6C, 5, 0x58FA1F6E>("\x1B\x32\x03\x5C" + 0x58FA1F6E).s, 3, cvar.visual_skins_world), index++;
	ReplaceTextureIndex(/*m4a1_skin*/XorStr<0x14, 10, 0x1FF6BDF3>("\x79\x21\x77\x26\x47\x6A\x71\x72\x72" + 0x1FF6BDF3).s, M4A17, index, /*w_m4a1*/XorStr<0x74, 7, 0xC4019A86>("\x03\x2A\x1B\x43\x19\x48" + 0xC4019A86).s, 3, cvar.visual_skins_world), index++;
	ReplaceTextureIndex(/*w_m249*/XorStr<0x69, 7, 0x773F9A35>("\x1E\x35\x06\x5E\x59\x57" + 0x773F9A35).s, M24910, index, /*w_m249*/XorStr<0x83, 7, 0x3CC1A914>("\xF4\xDB\xE8\xB4\xB3\xB1" + 0x3CC1A914).s, 3, cvar.visual_skins_world), index++;
	ReplaceTextureIndex(/*w_mac10*/XorStr<0x27, 8, 0xCF92E1EF>("\x50\x77\x44\x4B\x48\x1D\x1D" + 0xCF92E1EF).s, MAC104, index, /*w_mac10*/XorStr<0x68, 8, 0xB6C91550>("\x1F\x36\x07\x0A\x0F\x5C\x5E" + 0xB6C91550).s, 3, cvar.visual_skins_world), index++;
	ReplaceTextureIndex(/*w_mp5*/XorStr<0x1F, 6, 0x7B424C4F>("\x68\x7F\x4C\x52\x16" + 0x7B424C4F).s, MP58, index, /*w_mp5*/XorStr<0x6D, 6, 0x105BD0D0>("\x1A\x31\x02\x00\x44" + 0x105BD0D0).s, 3, cvar.visual_skins_world), index++;
	ReplaceTextureIndex(/*w_p90*/XorStr<0x1C, 6, 0xAB122004>("\x6B\x42\x6E\x26\x10" + 0xAB122004).s, P906, index, /*w_p90*/XorStr<0xEF, 6, 0x474567E0>("\x98\xAF\x81\xCB\xC3" + 0x474567E0).s, 3, cvar.visual_skins_world), index++;
	ReplaceTextureIndex(/*w_p228*/XorStr<0x64, 7, 0xE8350B3C>("\x13\x3A\x16\x55\x5A\x51" + 0xE8350B3C).s, P2284, index, /*w_p228*/XorStr<0x08, 7, 0x4791DFF7>("\x7F\x56\x7A\x39\x3E\x35" + 0x4791DFF7).s, 3, cvar.visual_skins_world), index++;
	ReplaceTextureIndex(/*w_scout*/XorStr<0x35, 8, 0x777E8BFD>("\x42\x69\x44\x5B\x56\x4F\x4F" + 0x777E8BFD).s, SCOUT6, index, /*w_scout*/XorStr<0x71, 8, 0x9FF2BEA2>("\x06\x2D\x00\x17\x1A\x03\x03" + 0x9FF2BEA2).s, 3, cvar.visual_skins_world), index++;
	ReplaceTextureIndex(/*sg550_profile*/XorStr<0xC2, 14, 0x3D32F55C>("\xB1\xA4\xF1\xF0\xF6\x98\xB8\xBB\xA5\xAD\xA5\xA1\xAB" + 0x3D32F55C).s, SG5507, index, /*w_sg550*/XorStr<0x6F, 8, 0x91F693A1>("\x18\x2F\x02\x15\x46\x41\x45" + 0x91F693A1).s, 3, cvar.visual_skins_world), index++;
	ReplaceTextureIndex(/*sg552_skin*/XorStr<0xD3, 11, 0x62552980>("\xA0\xB3\xE0\xE3\xE5\x87\xAA\xB1\xB2\xB2" + 0x62552980).s, SG5526, index, /*w_sg552*/XorStr<0x7E, 8, 0x41BEE8D2>("\x09\x20\xF3\xE6\xB7\xB6\xB6" + 0x41BEE8D2).s, 3, cvar.visual_skins_world), index++;
	ReplaceTextureIndex(/*shield_back*/XorStr<0xB5, 12, 0xB03D4EE5>("\xC6\xDE\xDE\xDD\xD5\xDE\xE4\xDE\xDC\xDD\xD4" + 0xB03D4EE5).s, SHIELD1, index, /*w_shield*/XorStr<0x03, 9, 0x3B0CBD1E>("\x74\x5B\x76\x6E\x6E\x6D\x65\x6E" + 0x3B0CBD1E).s, 3, cvar.visual_skins_world), index++;
	ReplaceTextureIndex(/*shield_front*/XorStr<0xD6, 13, 0xA6FF384E>("\xA5\xBF\xB1\xBC\xB6\xBF\x83\xBB\xAC\xB0\x8E\x95" + 0xA6FF384E).s, SHIELD2, index, /*w_shield*/XorStr<0x7C, 9, 0xE8B36C11>("\x0B\x22\x0D\x17\xE9\xE4\xEE\xE7" + 0xE8B36C11).s, 3, cvar.visual_skins_world), index++;
	ReplaceTextureIndex(/*shield_glass*/XorStr<0x06, 13, 0x786801B5>("\x75\x6F\x61\x6C\x66\x6F\x53\x6A\x62\x6E\x63\x62" + 0x786801B5).s, SHIELD3, index, /*w_shield*/XorStr<0x9D, 9, 0x087B36DA>("\xEA\xC1\xEC\xC8\xC8\xC7\xCF\xC0" + 0x087B36DA).s, 3, cvar.visual_skins_world), index++;
	ReplaceTextureIndex(/*f_body*/XorStr<0x14, 7, 0x7945A489>("\x72\x4A\x74\x78\x7C\x60" + 0x7945A489).s, SMOKEGRENADE4, index, /*w_smokegrenade*/XorStr<0x71, 15, 0x9CA799E5>("\x06\x2D\x00\x19\x1A\x1D\x12\x1F\x0B\x1F\x15\x1D\x19\x1B" + 0x9CA799E5).s, 3, cvar.visual_skins_world), index++;
	ReplaceTextureIndex(/*f_top*/XorStr<0x7F, 6, 0x228D7F41>("\x19\xDF\xF5\xED\xF3" + 0x228D7F41).s, SMOKEGRENADE5, index, /*w_smokegrenade*/XorStr<0x23, 15, 0x044A5A4E>("\x54\x7B\x56\x4B\x48\x43\x4C\x4D\x59\x49\x43\x4F\x4B\x55" + 0x044A5A4E).s, 3, cvar.visual_skins_world), index++;
	ReplaceTextureIndex(/*w_tmp*/XorStr<0x66, 6, 0xADD690D2>("\x11\x38\x1C\x04\x1A" + 0xADD690D2).s, TMP10, index, /*w_tmp*/XorStr<0xC5, 6, 0x2679BED5>("\xB2\x99\xB3\xA5\xB9" + 0x2679BED5).s, 3, cvar.visual_skins_world), index++;
	ReplaceTextureIndex(/*ump_profile*/XorStr<0x3A, 12, 0x8E23E2D8>("\x4F\x56\x4C\x62\x4E\x4D\x2F\x27\x2B\x2F\x21" + 0x8E23E2D8).s, UMP454, index, /*w_ump45*/XorStr<0x4A, 8, 0xB1FB8712>("\x3D\x14\x39\x20\x3E\x7B\x65" + 0xB1FB8712).s, 3, cvar.visual_skins_world), index++;
	ReplaceTextureIndex(/*usp_skin*/XorStr<0x54, 9, 0x5654E24A>("\x21\x26\x26\x08\x2B\x32\x33\x35" + 0x5654E24A).s, USP5, index, /*w_usp*/XorStr<0xB2, 6, 0xB295224A>("\xC5\xEC\xC1\xC6\xC6" + 0xB295224A).s, 3, cvar.visual_skins_world), index++;
	ReplaceTextureIndex(/*xm1014*/XorStr<0xED, 7, 0x5B7E30FD>("\x95\x83\xDE\xC0\xC0\xC6" + 0x5B7E30FD).s, XM10147, index, /*w_xm1014*/XorStr<0x5F, 9, 0xF6401741>("\x28\x3F\x19\x0F\x52\x54\x54\x52" + 0xF6401741).s, 3, cvar.visual_skins_world), index++;
	ReplaceTextureIndex(/*ak47_skin*/XorStr<0x56, 10, 0xDD1566F8>("\x37\x3C\x6C\x6E\x05\x28\x37\x34\x30" + 0xDD1566F8).s, AK479, index, /*p_ak47*/XorStr<0x34, 7, 0x005CAFDD>("\x44\x6A\x57\x5C\x0C\x0E" + 0x005CAFDD).s, 3, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*w_aug*/XorStr<0xA3, 6, 0xA9DA79F6>("\xD4\xFB\xC4\xD3\xC0" + 0xA9DA79F6).s, AUG4, index, /*p_aug*/XorStr<0x55, 6, 0x65020E1E>("\x25\x09\x36\x2D\x3E" + 0x65020E1E).s, 3, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*w_awp*/XorStr<0xB9, 6, 0xDCBFD089>("\xCE\xE5\xDA\xCB\xCD" + 0xDCBFD089).s, AWP11, index, /*p_awp*/XorStr<0xA4, 6, 0x568D33EF>("\xD4\xFA\xC7\xD0\xD8" + 0x568D33EF).s, 3, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*c4base*/XorStr<0x05, 7, 0xC36AD599>("\x66\x32\x65\x69\x7A\x6F" + 0xC36AD599).s, C41, index, /*p_c4*/XorStr<0x6F, 5, 0x7AA6FD55>("\x1F\x2F\x12\x46" + 0x7AA6FD55).s, 3, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*c4timer*/XorStr<0xA6, 8, 0xC87F26A0>("\xC5\x93\xDC\xC0\xC7\xCE\xDE" + 0xC87F26A0).s, C43, index, /*p_c4*/XorStr<0xD0, 5, 0xA1EDD855>("\xA0\x8E\xB1\xE7" + 0xA1EDD855).s, 3, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*c4wires*/XorStr<0x61, 8, 0xB40D5335>("\x02\x56\x14\x0D\x17\x03\x14" + 0xB40D5335).s, C44, index, /*p_c4*/XorStr<0xDF, 5, 0x03F18829>("\xAF\xBF\x82\xD6" + 0x03F18829).s, 3, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*deserteagle_skin*/XorStr<0x57, 17, 0xE28A1609>("\x33\x3D\x2A\x3F\x29\x28\x38\x3F\x38\x0C\x04\x3D\x10\x0F\x0C\x08" + 0xE28A1609).s, DEAGLE4, index, /*p_deagle*/XorStr<0xE8, 9, 0xDDF332BE>("\x98\xB6\x8E\x8E\x8D\x8A\x82\x8A" + 0xDDF332BE).s, 3, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*deserteagle_skin*/XorStr<0x95, 17, 0x8F517DAB>("\xF1\xF3\xE4\xFD\xEB\xEE\xFE\xFD\xFA\xF2\xFA\xFF\xD2\xC9\xCA\xCA" + 0x8F517DAB).s, DEAGLE4, index, /*p_shield_deagle*/XorStr<0x6C, 16, 0xAFEC7F2D>("\x1C\x32\x1D\x07\x19\x14\x1E\x17\x2B\x11\x13\x16\x1F\x15\x1F" + 0xAFEC7F2D).s, 2, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*w_elite*/XorStr<0x3D, 8, 0x42ADBF3C>("\x4A\x61\x5A\x2C\x28\x36\x26" + 0x42ADBF3C).s, ELITE5, index, /*p_elite*/XorStr<0xA3, 8, 0x7319BC0B>("\xD3\xFB\xC0\xCA\xCE\xDC\xCC" + 0x7319BC0B).s, 3, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*p_famas*/XorStr<0xB6, 8, 0x77EE41DE>("\xC6\xE8\xDE\xD8\xD7\xDA\xCF" + 0x77EE41DE).s, FAMAS2, index, /*p_famas*/XorStr<0xA2, 8, 0x2CD38E15>("\xD2\xFC\xC2\xC4\xCB\xC6\xDB" + 0x2CD38E15).s, 3, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*57_profile*/XorStr<0x59, 11, 0x261911BA>("\x6C\x6D\x04\x2C\x2F\x31\x39\x09\x0D\x07" + 0x261911BA).s, FIVESEVEN3, index, /*p_fiveseven*/XorStr<0xDF, 12, 0x032E9BF9>("\xAF\xBF\x87\x8B\x95\x81\x96\x83\x91\x8D\x87" + 0x032E9BF9).s, 3, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*57_profile*/XorStr<0x1C, 11, 0x825C266E>("\x29\x2A\x41\x6F\x52\x4E\x44\x4A\x48\x40" + 0x825C266E).s, FIVESEVEN3, index, /*p_shield_fiveseven*/XorStr<0xC4, 19, 0x244BE912>("\xB4\x9A\xB5\xAF\xA1\xAC\xA6\xAF\x93\xAB\xA7\xB9\xB5\xA2\xB7\xA5\xB1\xBB" + 0x244BE912).s, 2, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*f_body*/XorStr<0x21, 7, 0xC0F95B38>("\x47\x7D\x41\x4B\x41\x5F" + 0xC0F95B38).s, FLASHBANG4, index, /*p_flashbang*/XorStr<0x6F, 12, 0x1B4402D0>("\x1F\x2F\x17\x1E\x12\x07\x1D\x14\x16\x16\x1E" + 0x1B4402D0).s, 3, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*f_top*/XorStr<0x9C, 6, 0xCAA23DB2>("\xFA\xC2\xEA\xF0\xD0" + 0xCAA23DB2).s, FLASHBANG5, index, /*p_flashbang*/XorStr<0xC5, 12, 0x69A51296>("\xB5\x99\xA1\xA4\xA8\xB9\xA3\xAE\xAC\xA0\xA8" + 0x69A51296).s, 3, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*f_body*/XorStr<0xA6, 7, 0x2956D6BC>("\xC0\xF8\xCA\xC6\xCE\xD2" + 0x2956D6BC).s, FLASHBANG4, index, /*p_shield_flashbang*/XorStr<0x36, 19, 0xCC8009FA>("\x46\x68\x4B\x51\x53\x5E\x50\x59\x61\x59\x2C\x20\x31\x2B\x26\x24\x28\x20" + 0xCC8009FA).s, 2, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*f_top*/XorStr<0xA7, 6, 0x54E6B8E0>("\xC1\xF7\xDD\xC5\xDB" + 0x54E6B8E0).s, FLASHBANG5, index, /*p_shield_flashbang*/XorStr<0x47, 19, 0xB4362761>("\x37\x17\x3A\x22\x22\x29\x21\x2A\x10\x36\x3D\x33\x20\x3C\x37\x37\x39\x3F" + 0xB4362761).s, 2, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*w_g3sg1*/XorStr<0x07, 8, 0x58988239>("\x70\x57\x6E\x39\x78\x6B\x3C" + 0x58988239).s, G3SG19, index, /*p_g3sg1*/XorStr<0x23, 8, 0x4432697A>("\x53\x7B\x42\x15\x54\x4F\x18" + 0x4432697A).s, 3, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*p_galil*/XorStr<0x60, 8, 0x1971EA89>("\x10\x3E\x05\x02\x08\x0C\x0A" + 0x1971EA89).s, GALIL2, index, /*p_galil*/XorStr<0x17, 8, 0x162D85DC>("\x67\x47\x7E\x7B\x77\x75\x71" + 0x162D85DC).s, 3, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*w_glock*/XorStr<0x29, 8, 0xC2B6811B>("\x5E\x75\x4C\x40\x42\x4D\x44" + 0xC2B6811B).s, GLOCK185, index, /*p_glock18*/XorStr<0xBD, 10, 0x858EAA7D>("\xCD\xE1\xD8\xAC\xAE\xA1\xA8\xF5\xFD" + 0x858EAA7D).s, 3, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*w_glock*/XorStr<0xD3, 8, 0xBB7EEAB8>("\xA4\x8B\xB2\xBA\xB8\xBB\xB2" + 0xBB7EEAB8).s, GLOCK185, index, /*p_shield_glock18*/XorStr<0xA2, 17, 0xFD2C2F59>("\xD2\xFC\xD7\xCD\xCF\xC2\xC4\xCD\xF5\xCC\xC0\xC2\xCD\xC4\x81\x89" + 0xFD2C2F59).s, 2, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*f_body*/XorStr<0x87, 7, 0xA35D034E>("\xE1\xD7\xEB\xE5\xEF\xF5" + 0xA35D034E).s, HEGRENADE4, index, /*p_hegrenade*/XorStr<0x91, 12, 0x6866A06E>("\xE1\xCD\xFB\xF1\xF2\xE4\xF2\xF6\xF8\xFE\xFE" + 0x6866A06E).s, 3, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*f_top*/XorStr<0xC1, 6, 0xFAE2DAF1>("\xA7\x9D\xB7\xAB\xB5" + 0xFAE2DAF1).s, HEGRENADE5, index, /*p_hegrenade*/XorStr<0x82, 12, 0x5E7499DA>("\xF2\xDC\xEC\xE0\xE1\xF5\xED\xE7\xEB\xEF\xE9" + 0x5E7499DA).s, 3, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*f_body*/XorStr<0x49, 7, 0x8C94FA4D>("\x2F\x15\x29\x23\x29\x37" + 0x8C94FA4D).s, HEGRENADE4, index, /*p_shield_hegrenade*/XorStr<0x53, 19, 0x0FBE2C09>("\x23\x0B\x26\x3E\x3E\x3D\x35\x3E\x04\x34\x38\x39\x2D\x05\x0F\x03\x07\x01" + 0x0FBE2C09).s, 2, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*f_top*/XorStr<0x76, 6, 0x7C93C2E5>("\x10\x28\x0C\x16\x0A" + 0x7C93C2E5).s, HEGRENADE5, index, /*p_shield_hegrenade*/XorStr<0x9E, 19, 0x934813BB>("\xEE\xC0\xD3\xC9\xCB\xC6\xC8\xC1\xF9\xCF\xCD\xCE\xD8\xCE\xC2\xCC\xCA\xCA" + 0x934813BB).s, 2, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*pknifeskin*/XorStr<0x22, 11, 0x0002C288>("\x52\x48\x4A\x4C\x40\x42\x5B\x42\x43\x45" + 0x0002C288).s, KNIFE2, index, /*p_knife*/XorStr<0x8C, 8, 0x7DCA6251>("\xFC\xD2\xE5\xE1\xF9\xF7\xF7" + 0x7DCA6251).s, 3, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*w_m3super90*/XorStr<0xFB, 12, 0xB2BBFE20>("\x8C\xA3\x90\xCD\x8C\x75\x71\x67\x71\x3D\x35" + 0xB2BBFE20).s, M35, index, /*p_m3*/XorStr<0xC5, 5, 0x9B6DAA59>("\xB5\x99\xAA\xFB" + 0x9B6DAA59).s, 3, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*m4a1_skin*/XorStr<0x2A, 10, 0xAB1C831E>("\x47\x1F\x4D\x1C\x71\x5C\x5B\x58\x5C" + 0xAB1C831E).s, M4A17, index, /*p_m4a1*/XorStr<0xD2, 7, 0x838C6B73>("\xA2\x8C\xB9\xE1\xB7\xE6" + 0x838C6B73).s, 3, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*w_m249*/XorStr<0x53, 7, 0xEC88BA81>("\x24\x0B\x38\x64\x63\x61" + 0xEC88BA81).s, M24910, index, /*p_m249*/XorStr<0xE5, 7, 0x69C4A9A6>("\x95\xB9\x8A\xDA\xDD\xD3" + 0x69C4A9A6).s, 3, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*w_mac10*/XorStr<0x8E, 8, 0x05E01EC4>("\xF9\xD0\xFD\xF0\xF1\xA2\xA4" + 0x05E01EC4).s, MAC104, index, /*p_mac10*/XorStr<0x63, 8, 0x136A70C2>("\x13\x3B\x08\x07\x04\x59\x59" + 0x136A70C2).s, 3, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*w_mp5*/XorStr<0x99, 6, 0xFC069E5E>("\xEE\xC5\xF6\xEC\xA8" + 0xFC069E5E).s, MP58, index, /*p_mp5*/XorStr<0x17, 6, 0xCE2A6CEC>("\x67\x47\x74\x6A\x2E" + 0xCE2A6CEC).s, 3, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*w_p90*/XorStr<0xA0, 6, 0xEA4293C8>("\xD7\xFE\xD2\x9A\x94" + 0xEA4293C8).s, P906, index, /*p_p90*/XorStr<0xA5, 6, 0x9ABEA5C2>("\xD5\xF9\xD7\x91\x99" + 0x9ABEA5C2).s, 3, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*w_p228*/XorStr<0x1C, 7, 0x4B8694CE>("\x6B\x42\x6E\x2D\x12\x19" + 0x4B8694CE).s, P2284, index, /*p_p228*/XorStr<0x76, 7, 0x8EE13052>("\x06\x28\x08\x4B\x48\x43" + 0x8EE13052).s, 3, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*w_p228*/XorStr<0x57, 7, 0x05A239DD>("\x20\x07\x29\x68\x69\x64" + 0x05A239DD).s, P2284, index, /*p_shield_p228*/XorStr<0xE7, 14, 0x481AA97C>("\x97\xB7\x9A\x82\x82\x89\x81\x8A\xB0\x80\xC3\xC0\xCB" + 0x481AA97C).s, 2, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*w_scout*/XorStr<0x31, 8, 0xDC79B114>("\x46\x6D\x40\x57\x5A\x43\x43" + 0xDC79B114).s, SCOUT6, index, /*p_scout*/XorStr<0xF3, 8, 0xA517D2B9>("\x83\xAB\x86\x95\x98\x8D\x8D" + 0xA517D2B9).s, 3, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*sg550_profile*/XorStr<0x9F, 14, 0x935E1F6D>("\xEC\xC7\x94\x97\x93\xFB\xD5\xD4\xC8\xCE\xC0\xC6\xCE" + 0x935E1F6D).s, SG5507, index, /*p_sg550*/XorStr<0x03, 8, 0x7988A7A7>("\x73\x5B\x76\x61\x32\x3D\x39" + 0x7988A7A7).s, 3, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*sg552_skin*/XorStr<0x89, 11, 0x4C7E1C05>("\xFA\xED\xBE\xB9\xBF\xD1\xFC\xFB\xF8\xFC" + 0x4C7E1C05).s, SG5526, index, /*p_sg552*/XorStr<0x85, 8, 0xCF8A4E9C>("\xF5\xD9\xF4\xEF\xBC\xBF\xB9" + 0xCF8A4E9C).s, 3, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*shield_back*/XorStr<0x35, 12, 0xC0ADB377>("\x46\x5E\x5E\x5D\x55\x5E\x64\x5E\x5C\x5D\x54" + 0xC0ADB377).s, SHIELD1, index, /*p_shield_deagle*/XorStr<0x87, 16, 0x82C0329E>("\xF7\xD7\xFA\xE2\xE2\xE9\xE1\xEA\xD0\xF4\xF4\xF3\xF4\xF8\xF0" + 0x82C0329E).s, 2, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*shield_front*/XorStr<0x1E, 13, 0x828A860A>("\x6D\x77\x49\x44\x4E\x47\x7B\x43\x54\x48\x46\x5D" + 0x828A860A).s, SHIELD2, index, /*p_shield_deagle*/XorStr<0x9A, 16, 0xAF4430C4>("\xEA\xC4\xEF\xF5\xF7\xFA\xCC\xC5\xFD\xC7\xC1\xC4\xC1\xCB\xCD" + 0xAF4430C4).s, 2, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*shield_glass*/XorStr<0x0A, 13, 0xA5B6D264>("\x79\x63\x65\x68\x62\x6B\x4F\x76\x7E\x72\x67\x66" + 0xA5B6D264).s, SHIELD3, index, /*p_shield_deagle*/XorStr<0x46, 16, 0xFE44F958>("\x36\x18\x3B\x21\x23\x2E\x20\x29\x11\x2B\x35\x30\x35\x3F\x31" + 0xFE44F958).s, 2, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*shield_back*/XorStr<0x6E, 12, 0x762B0D06>("\x1D\x07\x19\x14\x1E\x17\x2B\x17\x17\x14\x13" + 0x762B0D06).s, SHIELD1, index, /*p_shield_fiveseven*/XorStr<0xA0, 19, 0xA5614477>("\xD0\xFE\xD1\xCB\xCD\xC0\xCA\xC3\xF7\xCF\xC3\xDD\xC9\xDE\xCB\xD9\xD5\xDF" + 0xA5614477).s, 2, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*shield_front*/XorStr<0xEF, 13, 0x1E463A31>("\x9C\x98\x98\x97\x9F\x90\xAA\x90\x85\x97\x97\x8E" + 0x1E463A31).s, SHIELD2, index, /*p_shield_fiveseven*/XorStr<0xF0, 19, 0x43D929EB>("\x80\xAE\x81\x9B\x9D\x90\x9A\x93\xA7\x9F\x93\x8D\x99\x8E\x9B\x89\x65\x6F" + 0x43D929EB).s, 2, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*shield_glass*/XorStr<0xB4, 13, 0xF4073187>("\xC7\xDD\xDF\xD2\xD4\xDD\xE5\xDC\xD0\xDC\xCD\xCC" + 0xF4073187).s, SHIELD3, index, /*p_shield_fiveseven*/XorStr<0x87, 19, 0x14D55F54>("\xF7\xD7\xFA\xE2\xE2\xE9\xE1\xEA\xD0\xF6\xF8\xE4\xF6\xE7\xF0\xE0\xF2\xF6" + 0x14D55F54).s, 2, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*shield_back*/XorStr<0x44, 12, 0x1480A2EC>("\x37\x2D\x2F\x22\x24\x2D\x15\x29\x2D\x2E\x25" + 0x1480A2EC).s, SHIELD1, index, /*p_shield_flashbang*/XorStr<0x63, 19, 0x3E41D052>("\x13\x3B\x16\x0E\x0E\x0D\x05\x0E\x34\x0A\x01\x0F\x1C\x18\x13\x13\x1D\x13" + 0x3E41D052).s, 2, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*shield_front*/XorStr<0x38, 13, 0xD2184B46>("\x4B\x51\x53\x5E\x50\x59\x61\x59\x32\x2E\x2C\x37" + 0xD2184B46).s, SHIELD2, index, /*p_shield_flashbang*/XorStr<0x24, 19, 0x24E2D05D>("\x54\x7A\x55\x4F\x41\x4C\x46\x4F\x73\x4B\x42\x4E\x43\x59\x50\x52\x5A\x52" + 0x24E2D05D).s, 2, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*shield_glass*/XorStr<0x5C, 13, 0xB261D987>("\x2F\x35\x37\x3A\x0C\x05\x3D\x04\x08\x04\x15\x14" + 0xB261D987).s, SHIELD3, index, /*p_shield_flashbang*/XorStr<0x93, 19, 0xF7B7EC03>("\xE3\xCB\xE6\xFE\xFE\xFD\xF5\xFE\xC4\xFA\xF1\xFF\xEC\xC8\xC3\xC3\xCD\xC3" + 0xF7B7EC03).s, 2, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*shield_back*/XorStr<0x64, 12, 0x0B1AE6D5>("\x17\x0D\x0F\x02\x04\x0D\x35\x09\x0D\x0E\x05" + 0x0B1AE6D5).s, SHIELD1, index, /*p_shield_glock18*/XorStr<0x5D, 17, 0x4246B6E8>("\x2D\x01\x2C\x08\x08\x07\x0F\x00\x3A\x01\x0B\x07\x0A\x01\x5A\x54" + 0x4246B6E8).s, 2, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*shield_front*/XorStr<0xFB, 13, 0x376DD6CA>("\x88\x94\x94\x9B\x93\x64\x5E\x64\x71\x6B\x6B\x72" + 0x376DD6CA).s, SHIELD2, index, /*p_shield_glock18*/XorStr<0x02, 17, 0x33373379>("\x72\x5C\x77\x6D\x6F\x62\x64\x6D\x55\x6C\x60\x62\x6D\x64\x21\x29" + 0x33373379).s, 2, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*shield_glass*/XorStr<0x49, 13, 0x96DC0473>("\x3A\x22\x22\x29\x21\x2A\x10\x37\x3D\x33\x20\x27" + 0x96DC0473).s, SHIELD3, index, /*p_shield_glock18*/XorStr<0x8D, 17, 0xA69B01E1>("\xFD\xD1\xFC\xF8\xF8\xF7\xFF\xF0\xCA\xF1\xFB\xF7\xFA\xF1\xAA\xA4" + 0xA69B01E1).s, 2, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*shield_back*/XorStr<0xEE, 12, 0x5FB97A78>("\x9D\x87\x99\x94\x9E\x97\xAB\x97\x97\x94\x93" + 0x5FB97A78).s, SHIELD1, index, /*p_shield_hegrenade*/XorStr<0xE8, 19, 0xD8B30F06>("\x98\xB6\x99\x83\x85\x88\x82\x8B\xAF\x99\x97\x94\x86\x90\x98\x96\x9C\x9C" + 0xD8B30F06).s, 2, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*shield_front*/XorStr<0x7C, 13, 0x547F5D8A>("\x0F\x15\x17\x1A\xEC\xE5\xDD\xE5\xF6\xEA\xE8\xF3" + 0x547F5D8A).s, SHIELD2, index, /*p_shield_hegrenade*/XorStr<0x8E, 19, 0xE03384FA>("\xFE\xD0\xE3\xF9\xFB\xF6\xF8\xF1\xC9\xFF\xFD\xFE\xE8\xFE\xF2\xFC\xFA\xFA" + 0xE03384FA).s, 2, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*shield_glass*/XorStr<0xD3, 13, 0x0D724FED>("\xA0\xBC\xBC\xB3\xBB\xBC\x86\xBD\xB7\xBD\xAE\xAD" + 0x0D724FED).s, SHIELD3, index, /*p_shield_hegrenade*/XorStr<0x26, 19, 0xA692973B>("\x56\x78\x5B\x41\x43\x4E\x40\x49\x71\x47\x55\x56\x40\x56\x5A\x54\x52\x52" + 0xA692973B).s, 2, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*shield_back*/XorStr<0xAD, 12, 0xF546A149>("\xDE\xC6\xC6\xD5\xDD\xD6\xEC\xD6\xD4\xD5\xDC" + 0xF546A149).s, SHIELD1, index, /*p_shield_knife*/XorStr<0x31, 15, 0x09D4FD3B>("\x41\x6D\x40\x5C\x5C\x53\x5B\x5C\x66\x51\x55\x55\x5B\x5B" + 0x09D4FD3B).s, 2, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*shield_front*/XorStr<0xFB, 13, 0x050D610C>("\x88\x94\x94\x9B\x93\x64\x5E\x64\x71\x6B\x6B\x72" + 0x050D610C).s, SHIELD2, index, /*p_shield_knife*/XorStr<0xFA, 15, 0xAEE3E265>("\x8A\xA4\x8F\x95\x97\x9A\x6C\x65\x5D\x68\x6A\x6C\x60\x62" + 0xAEE3E265).s, 2, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*shield_glass*/XorStr<0xA2, 13, 0x13B546F5>("\xD1\xCB\xCD\xC0\xCA\xC3\xF7\xCE\xC6\xCA\xDF\xDE" + 0x13B546F5).s, SHIELD3, index, /*p_shield_knife*/XorStr<0x47, 15, 0xBAB69BFA>("\x37\x17\x3A\x22\x22\x29\x21\x2A\x10\x3B\x3F\x3B\x35\x31" + 0xBAB69BFA).s, 2, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*shield_back*/XorStr<0x95, 12, 0xB043A375>("\xE6\xFE\xFE\xFD\xF5\xFE\xC4\xFE\xFC\xFD\xF4" + 0xB043A375).s, SHIELD1, index, /*p_shield_p228*/XorStr<0xD0, 14, 0x6BE80402>("\xA0\x8E\xA1\xBB\xBD\xB0\xBA\xB3\x87\xA9\xE8\xE9\xE4" + 0x6BE80402).s, 2, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*shield_front*/XorStr<0xE3, 13, 0x0EFE2C9A>("\x90\x8C\x8C\x83\x8B\x8C\xB6\x8C\x99\x83\x83\x9A" + 0x0EFE2C9A).s, SHIELD2, index, /*p_shield_p228*/XorStr<0xCF, 14, 0x08233BBD>("\xBF\x8F\xA2\xBA\xBA\xB1\xB9\xB2\x88\xA8\xEB\xE8\xE3" + 0x08233BBD).s, 2, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*shield_glass*/XorStr<0x2C, 13, 0x90FCFD1F>("\x5F\x45\x47\x4A\x5C\x55\x6D\x54\x58\x54\x45\x44" + 0x90FCFD1F).s, SHIELD3, index, /*p_shield_p228*/XorStr<0x23, 14, 0x0581C675>("\x53\x7B\x56\x4E\x4E\x4D\x45\x4E\x74\x5C\x1F\x1C\x17" + 0x0581C675).s, 2, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*shield_back*/XorStr<0xE4, 12, 0x4B14F388>("\x97\x8D\x8F\x82\x84\x8D\xB5\x89\x8D\x8E\x85" + 0x4B14F388).s, SHIELD1, index, /*p_shield_smokegrenade*/XorStr<0x7C, 22, 0x539CBDA4>("\x0C\x22\x0D\x17\xE9\xE4\xEE\xE7\xDB\xF6\xEB\xE8\xE3\xEC\xED\xF9\xE9\xE3\xEF\xEB\xF5" + 0x539CBDA4).s, 2, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*shield_front*/XorStr<0xF2, 13, 0xB29F4814>("\x81\x9B\x9D\x90\x9A\x93\xA7\x9F\x88\x94\x92\x89" + 0xB29F4814).s, SHIELD2, index, /*p_shield_smokegrenade*/XorStr<0xF2, 22, 0x9890CC25>("\x82\xAC\x87\x9D\x9F\x92\x94\x9D\xA5\x88\x91\x92\x95\x9A\x67\x73\x67\x6D\x65\x61\x63" + 0x9890CC25).s, 2, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*shield_glass*/XorStr<0x06, 13, 0xAFC8A0CA>("\x75\x6F\x61\x6C\x66\x6F\x53\x6A\x62\x6E\x63\x62" + 0xAFC8A0CA).s, SHIELD3, index, /*p_shield_smokegrenade*/XorStr<0xE0, 22, 0x154337AB>("\x90\xBE\x91\x8B\x8D\x80\x8A\x83\xB7\x9A\x87\x84\x87\x88\x89\x9D\x95\x9F\x93\x97\x91" + 0x154337AB).s, 2, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*shield_back*/XorStr<0xCB, 12, 0x803FBBAA>("\xB8\xA4\xA4\xAB\xA3\xB4\x8E\xB0\xB2\xB7\xBE" + 0x803FBBAA).s, SHIELD1, index, /*p_shield_usp*/XorStr<0xBB, 13, 0x19A26B38>("\xCB\xE3\xCE\xD6\xD6\xA5\xAD\xA6\x9C\xB1\xB6\xB6" + 0x19A26B38).s, 2, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*shield_front*/XorStr<0xD2, 13, 0x077F0A81>("\xA1\xBB\xBD\xB0\xBA\xB3\x87\xBF\xA8\xB4\xB2\xA9" + 0x077F0A81).s, SHIELD2, index, /*p_shield_usp*/XorStr<0x1B, 13, 0xD10084ED>("\x6B\x43\x6E\x76\x76\x45\x4D\x46\x7C\x51\x56\x56" + 0xD10084ED).s, 2, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*shield_glass*/XorStr<0x04, 13, 0xCF82C3CD>("\x77\x6D\x6F\x62\x64\x6D\x55\x6C\x60\x6C\x7D\x7C" + 0xCF82C3CD).s, SHIELD3, index, /*p_shield_usp*/XorStr<0x82, 13, 0x95891D7F>("\xF2\xDC\xF7\xED\xEF\xE2\xE4\xED\xD5\xFE\xFF\xFD" + 0x95891D7F).s, 2, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*f_body*/XorStr<0xD4, 7, 0x5446CA6C>("\xB2\x8A\xB4\xB8\xBC\xA0" + 0x5446CA6C).s, SMOKEGRENADE4, index, /*p_smokegrenade*/XorStr<0xF7, 15, 0x9DD42C8B>("\x87\xA7\x8A\x97\x94\x97\x98\x99\x8D\x65\x6F\x63\x67\x61" + 0x9DD42C8B).s, 3, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*f_top*/XorStr<0x78, 6, 0x58AEB76A>("\x1E\x26\x0E\x14\x0C" + 0x58AEB76A).s, SMOKEGRENADE5, index, /*p_smokegrenade*/XorStr<0xD6, 15, 0x30505BA4>("\xA6\x88\xAB\xB4\xB5\xB0\xB9\xBA\xAC\xBA\x8E\x80\x86\x86" + 0x30505BA4).s, 3, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*f_body*/XorStr<0x0C, 7, 0x9CB7214B>("\x6A\x52\x6C\x60\x74\x68" + 0x9CB7214B).s, SMOKEGRENADE4, index, /*p_shield_smokegrenade*/XorStr<0xE9, 22, 0x9B80F0AB>("\x99\xB5\x98\x84\x84\x8B\x83\x94\xAE\x81\x9E\x9B\x9E\x93\x90\x8A\x9C\x94\x9A\x98\x98" + 0x9B80F0AB).s, 2, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*f_top*/XorStr<0x52, 6, 0xA3990145>("\x34\x0C\x20\x3A\x26" + 0xA3990145).s, SMOKEGRENADE5, index, /*p_shield_smokegrenade*/XorStr<0x1C, 22, 0x711427ED>("\x6C\x42\x6D\x77\x49\x44\x4E\x47\x7B\x56\x4B\x48\x43\x4C\x4D\x59\x49\x43\x4F\x4B\x55" + 0x711427ED).s, 2, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*w_tmp*/XorStr<0x5B, 6, 0x0A4DE05A>("\x2C\x03\x29\x33\x2F" + 0x0A4DE05A).s, TMP10, index, /*p_tmp*/XorStr<0xDD, 6, 0x0099EC7F>("\xAD\x81\xAB\x8D\x91" + 0x0099EC7F).s, 3, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*ump_profile*/XorStr<0xA8, 12, 0x56EDA09B>("\xDD\xC4\xDA\xF4\xDC\xDF\xC1\xC9\xD9\xDD\xD7" + 0x56EDA09B).s, UMP454, index, /*p_ump45*/XorStr<0x73, 8, 0xEC012F67>("\x03\x2B\x00\x1B\x07\x4C\x4C" + 0xEC012F67).s, 3, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*usp_skin*/XorStr<0x22, 9, 0xB6944A42>("\x57\x50\x54\x7A\x55\x4C\x41\x47" + 0xB6944A42).s, USP5, index, /*p_usp*/XorStr<0x01, 6, 0xD2DE8B1E>("\x71\x5D\x76\x77\x75" + 0xD2DE8B1E).s, 3, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*usp_skin*/XorStr<0x8C, 9, 0xECC7FDEC>("\xF9\xFE\xFE\xD0\xE3\xFA\xFB\xFD" + 0xECC7FDEC).s, USP5, index, /*p_shield_usp*/XorStr<0x16, 13, 0x9BA987F4>("\x66\x48\x6B\x71\x73\x7E\x70\x79\x41\x6A\x53\x51" + 0x9BA987F4).s, 2, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*xm1014*/XorStr<0xA9, 7, 0x55940666>("\xD1\xC7\x9A\x9C\x9C\x9A" + 0x55940666).s, XM10147, index, /*p_xm1014*/XorStr<0x94, 9, 0xE8D6E594>("\xE4\xCA\xEE\xFA\xA9\xA9\xAB\xAF" + 0xE8D6E594).s, 3, cvar.visual_skins_player_weapon), index++;
	ReplaceTextureIndex(/*barrel*/XorStr<0x10, 7, 0x32CF0401>("\x72\x70\x60\x61\x71\x79" + 0x32CF0401).s, AK471, index, /*v_ak47*/XorStr<0x43, 7, 0x27218C8C>("\x35\x1B\x24\x2D\x73\x7F" + 0x27218C8C).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*forearm*/XorStr<0xA3, 8, 0xE54DE802>("\xC5\xCB\xD7\xC3\xC6\xDA\xC4" + 0xE54DE802).s, AK472, index, /*v_ak47*/XorStr<0xE9, 7, 0xF16326DF>("\x9F\xB5\x8A\x87\xD9\xD9" + 0xF16326DF).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*handle*/XorStr<0xF6, 7, 0x363B47EE>("\x9E\x96\x96\x9D\x96\x9E" + 0x363B47EE).s, AK473, index, /*v_ak47*/XorStr<0x5C, 7, 0xB349BF3E>("\x2A\x02\x3F\x34\x54\x56" + 0xB349BF3E).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*lower_body*/XorStr<0xD2, 11, 0xBB7D0371>("\xBE\xBC\xA3\xB0\xA4\x88\xBA\xB6\xBE\xA2" + 0xBB7D0371).s, AK474, index, /*v_ak47*/XorStr<0x52, 7, 0xF3551129>("\x24\x0C\x35\x3E\x62\x60" + 0xF3551129).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*magazine*/XorStr<0x76, 9, 0x9526F867>("\x1B\x16\x1F\x18\x00\x12\x12\x18" + 0x9526F867).s, AK475, index, /*v_ak47*/XorStr<0xA6, 7, 0x6FE83CAB>("\xD0\xF8\xC9\xC2\x9E\x9C" + 0x6FE83CAB).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*reticle*/XorStr<0x76, 8, 0x6026E92C>("\x04\x12\x0C\x10\x19\x17\x19" + 0x6026E92C).s, AK476, index, /*v_ak47*/XorStr<0xF5, 7, 0x2E1F8CF7>("\x83\xA9\x96\x93\xCD\xCD" + 0x2E1F8CF7).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*upper_body*/XorStr<0xB1, 11, 0x8D402409>("\xC4\xC2\xC3\xD1\xC7\xE9\xD5\xD7\xDD\xC3" + 0x8D402409).s, AK477, index, /*v_ak47*/XorStr<0x01, 7, 0xE2B3EEEC>("\x77\x5D\x62\x6F\x31\x31" + 0xE2B3EEEC).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*wood*/XorStr<0x0F, 5, 0xACE84860>("\x78\x7F\x7E\x76" + 0xACE84860).s, AK478, index, /*v_ak47*/XorStr<0xA4, 7, 0x84FF2593>("\xD2\xFA\xC7\xCC\x9C\x9E" + 0x84FF2593).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*barrel*/XorStr<0x97, 7, 0x51C92AAA>("\xF5\xF9\xEB\xE8\xFE\xF0" + 0x51C92AAA).s, AUG1, index, /*v_aug*/XorStr<0x14, 6, 0xA75DD0C7>("\x62\x4A\x77\x62\x7F" + 0xA75DD0C7).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*body*/XorStr<0x96, 5, 0xB14BCF34>("\xF4\xF8\xFC\xE0" + 0xB14BCF34).s, AUG2, index, /*v_aug*/XorStr<0xBC, 6, 0x998FE259>("\xCA\xE2\xDF\xCA\xA7" + 0x998FE259).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*magazine*/XorStr<0x36, 9, 0x00DA2AC0>("\x5B\x56\x5F\x58\x40\x52\x52\x58" + 0x00DA2AC0).s, AUG3, index, /*v_aug*/XorStr<0xC8, 6, 0x80BEEA93>("\xBE\x96\xAB\xBE\xAB" + 0x80BEEA93).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*barrel*/XorStr<0x93, 7, 0xC1922FC2>("\xF1\xF5\xE7\xE4\xF2\xF4" + 0xC1922FC2).s, AWP1, index, /*v_awp*/XorStr<0x26, 6, 0x11F4C1AD>("\x50\x78\x49\x5E\x5A" + 0x11F4C1AD).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*base*/XorStr<0x6A, 5, 0x49E834CA>("\x08\x0A\x1F\x08" + 0x49E834CA).s, AWP2, index, /*v_awp*/XorStr<0xFF, 6, 0x3CB620D7>("\x89\x5F\x60\x75\x73" + 0x3CB620D7).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*bolt_handle*/XorStr<0x10, 12, 0x21749889>("\x72\x7E\x7E\x67\x4B\x7D\x77\x79\x7C\x75\x7F" + 0x21749889).s, AWP3, index, /*v_awp*/XorStr<0x5B, 6, 0xBFF158D8>("\x2D\x03\x3C\x29\x2F" + 0xBFF158D8).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*buttstock*/XorStr<0x66, 10, 0xA4F73498>("\x04\x12\x1C\x1D\x19\x1F\x03\x0E\x05" + 0xA4F73498).s, AWP4, index, /*v_awp*/XorStr<0x87, 6, 0xA8291FFD>("\xF1\xD7\xE8\xFD\xFB" + 0xA8291FFD).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*ejector_port*/XorStr<0x72, 13, 0xF5B53B53>("\x17\x19\x11\x16\x02\x18\x0A\x26\x0A\x14\x0E\x09" + 0xF5B53B53).s, AWP5, index, /*v_awp*/XorStr<0xE9, 6, 0x9B594D23>("\x9F\xB5\x8A\x9B\x9D" + 0x9B594D23).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*magazine*/XorStr<0xF0, 9, 0xA2A6436B>("\x9D\x90\x95\x92\x8E\x9C\x98\x92" + 0xA2A6436B).s, AWP6, index, /*v_awp*/XorStr<0xCA, 6, 0x5D890E61>("\xBC\x94\xAD\xBA\xBE" + 0x5D890E61).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*newparts.bmp*/XorStr<0xCB, 13, 0x830369FB>("\xA5\xA9\xBA\xBE\xAE\xA2\xA5\xA1\xFD\xB6\xB8\xA6" + 0x830369FB).s, AWP7, index, /*v_awp*/XorStr<0x33, 6, 0x0A343F22>("\x45\x6B\x54\x41\x47" + 0x0A343F22).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*newparts2*/XorStr<0x5E, 10, 0x9F310D80>("\x30\x3A\x17\x11\x03\x11\x10\x16\x54" + 0x9F310D80).s, AWP8, index, /*v_awp*/XorStr<0xF9, 6, 0x1307684B>("\x8F\xA5\x9A\x8B\x8D" + 0x1307684B).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*scope.bmp*/XorStr<0x7A, 10, 0x76620819>("\x09\x18\x13\x0D\x1B\x51\xE2\xEC\xF2" + 0x76620819).s, AWP9, index, /*v_awp*/XorStr<0x0D, 6, 0xB6873728>("\x7B\x51\x6E\x67\x61" + 0xB6873728).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*scope_clamps*/XorStr<0x2E, 13, 0x2D350D3B>("\x5D\x4C\x5F\x41\x57\x6C\x57\x59\x57\x5A\x48\x4A" + 0x2D350D3B).s, AWP10, index, /*v_awp*/XorStr<0x7E, 6, 0x820743F8>("\x08\x20\xE1\xF6\xF2" + 0x820743F8).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*c4base*/XorStr<0xBB, 7, 0x835A2E7E>("\xD8\x88\xDF\xDF\xCC\xA5" + 0x835A2E7E).s, C41, index, /*v_c4*/XorStr<0xE7, 5, 0xAAEFFD78>("\x91\xB7\x8A\xDE" + 0xAAEFFD78).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*c4buttons*/XorStr<0xA9, 10, 0x12F7AE3A>("\xCA\x9E\xC9\xD9\xD9\xDA\xC0\xDE\xC2" + 0x12F7AE3A).s, C42, index, /*v_c4*/XorStr<0x81, 5, 0xAFF40CA3>("\xF7\xDD\xE0\xB0" + 0xAFF40CA3).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*c4timer*/XorStr<0x9C, 8, 0xB37017B5>("\xFF\xA9\xEA\xF6\xCD\xC4\xD0" + 0xB37017B5).s, C43, index, /*v_c4*/XorStr<0xBC, 5, 0xE08CECA1>("\xCA\xE2\xDD\x8B" + 0xE08CECA1).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*c4wires*/XorStr<0xB0, 8, 0xAC9F3349>("\xD3\x85\xC5\xDA\xC6\xD0\xC5" + 0xAC9F3349).s, C44, index, /*v_c4*/XorStr<0xBC, 5, 0x1C78EF50>("\xCA\xE2\xDD\x8B" + 0x1C78EF50).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*cbase_front*/XorStr<0x1E, 12, 0x13BDD9F2>("\x7D\x7D\x41\x52\x47\x7C\x42\x57\x49\x49\x5C" + 0x13BDD9F2).s, C45, index, /*v_c4*/XorStr<0x38, 5, 0xF84DC1F3>("\x4E\x66\x59\x0F" + 0xF84DC1F3).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*DE_handle*/XorStr<0xAD, 10, 0x67BB4520>("\xE9\xEB\xF0\xD8\xD0\xDC\xD7\xD8\xD0" + 0x67BB4520).s, DEAGLE1, index, /*v_deagle*/XorStr<0x57, 9, 0x17E120A6>("\x21\x07\x3D\x3F\x3A\x3B\x31\x3B" + 0x17E120A6).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*DE_slide1*/XorStr<0xC0, 10, 0xDF72F555>("\x84\x84\x9D\xB0\xA8\xAC\xA2\xA2\xF9" + 0xDF72F555).s, DEAGLE2, index, /*v_deagle*/XorStr<0x79, 9, 0xF0F74268>("\x0F\x25\x1F\x19\x1C\x19\x13\xE5" + 0xF0F74268).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*DE_slide2_eagle*/XorStr<0x22, 16, 0xF8A08960>("\x66\x66\x7B\x56\x4A\x4E\x4C\x4C\x18\x74\x49\x4C\x49\x43\x55" + 0xF8A08960).s, DEAGLE3, index, /*v_deagle*/XorStr<0xDF, 9, 0xFC393041>("\xA9\xBF\x85\x87\x82\x83\x89\x83" + 0xFC393041).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*DE_handle*/XorStr<0x69, 10, 0xEC8CCA60>("\x2D\x2F\x34\x04\x0C\x00\x0B\x1C\x14" + 0xEC8CCA60).s, DEAGLE1, index, /*v_shield_deagle*/XorStr<0x24, 16, 0x1F676A03>("\x52\x7A\x55\x4F\x41\x4C\x46\x4F\x73\x49\x4B\x4E\x57\x5D\x57" + 0x1F676A03).s, 2, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*DE_slide1*/XorStr<0x96, 10, 0x4F27974A>("\xD2\xD2\xC7\xEA\xF6\xF2\xF8\xF8\xAF" + 0x4F27974A).s, DEAGLE2, index, /*v_shield_deagle*/XorStr<0x67, 16, 0x9CE3E7FD>("\x11\x37\x1A\x02\x02\x09\x01\x0A\x30\x14\x14\x13\x14\x18\x10" + 0x9CE3E7FD).s, 2, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*DE_slide2_eagle*/XorStr<0x42, 16, 0x2F713A12>("\x06\x06\x1B\x36\x2A\x2E\x2C\x2C\x78\x14\x29\x2C\x29\x23\x35" + 0x2F713A12).s, DEAGLE3, index, /*v_shield_deagle*/XorStr<0x66, 16, 0xF2FE22A3>("\x10\x38\x1B\x01\x03\x0E\x00\x09\x31\x0B\x15\x10\x15\x1F\x11" + 0xF2FE22A3).s, 2, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*barrel*/XorStr<0xF5, 7, 0x967A2DA2>("\x97\x97\x85\x8A\x9C\x96" + 0x967A2DA2).s, ELITE1, index, /*v_elite*/XorStr<0x61, 8, 0x973722ED>("\x17\x3D\x06\x08\x0C\x12\x02" + 0x973722ED).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*handle*/XorStr<0x61, 7, 0xC98C6D7C>("\x09\x03\x0D\x00\x09\x03" + 0xC98C6D7C).s, ELITE2, index, /*v_elite*/XorStr<0xDA, 8, 0x7AF80C92>("\xAC\x84\xB9\xB1\xB7\xAB\x85" + 0x7AF80C92).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*magazine*/XorStr<0x14, 9, 0x8D6FE172>("\x79\x74\x71\x76\x62\x70\x74\x7E" + 0x8D6FE172).s, ELITE3, index, /*v_elite*/XorStr<0x5B, 8, 0x99EBC002>("\x2D\x03\x38\x32\x36\x14\x04" + 0x99EBC002).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*slide*/XorStr<0x87, 6, 0xB1A5D363>("\xF4\xE4\xE0\xEE\xEE" + 0xB1A5D363).s, ELITE4, index, /*v_elite*/XorStr<0x67, 8, 0x4F7DCB2E>("\x11\x37\x0C\x06\x02\x18\x08" + 0x4F7DCB2E).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*v_famas*/XorStr<0x2C, 8, 0x9E5CFFB6>("\x5A\x72\x48\x4E\x5D\x50\x41" + 0x9E5CFFB6).s, FAMAS1, index, /*v_famas*/XorStr<0x24, 8, 0xBA4D7F3A>("\x52\x7A\x40\x46\x45\x48\x59" + 0xBA4D7F3A).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*fs1*/XorStr<0x9F, 4, 0xB91B3FBF>("\xF9\xD3\x90" + 0xB91B3FBF).s, FIVESEVEN1, index, /*v_fiveseven*/XorStr<0x84, 12, 0x5A036A20>("\xF2\xDA\xE0\xEE\xFE\xEC\xF9\xEE\xFA\xE8\xE0" + 0x5A036A20).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*fs2*/XorStr<0xE0, 4, 0xE66DCD83>("\x86\x92\xD0" + 0xE66DCD83).s, FIVESEVEN2, index, /*v_fiveseven*/XorStr<0xEB, 12, 0xCECF9940>("\x9D\xB3\x8B\x87\x99\x95\x82\x97\x85\x91\x9B" + 0xCECF9940).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*fs1*/XorStr<0xFE, 4, 0xC82250D9>("\x98\x8C\x31" + 0xC82250D9).s, FIVESEVEN1, index, /*v_shield_fiveseven*/XorStr<0x70, 19, 0x52B370CB>("\x06\x2E\x01\x1B\x1D\x10\x1A\x13\x27\x1F\x13\x0D\x19\x0E\x1B\x09\xE5\xEF" + 0x52B370CB).s, 2, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*fs2*/XorStr<0x1E, 4, 0x59C1A281>("\x78\x6C\x12" + 0x59C1A281).s, FIVESEVEN2, index, /*v_shield_fiveseven*/XorStr<0x51, 19, 0xEA3CBF47>("\x27\x0D\x20\x3C\x3C\x33\x3B\x3C\x06\x3C\x32\x2A\x38\x2D\x3A\x16\x04\x0C" + 0xEA3CBF47).s, 2, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*flash_body*/XorStr<0xC3, 11, 0x6DDACDAB>("\xA5\xA8\xA4\xB5\xAF\x97\xAB\xA5\xAF\xB5" + 0x6DDACDAB).s, FLASHBANG1, index, /*v_flashbang*/XorStr<0xC3, 12, 0xFBE8D883>("\xB5\x9B\xA3\xAA\xA6\xBB\xA1\xA8\xAA\xA2\xAA" + 0xFBE8D883).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*flash_spoon*/XorStr<0x49, 12, 0x425A16FA>("\x2F\x26\x2A\x3F\x25\x11\x3C\x20\x3E\x3D\x3D" + 0x425A16FA).s, FLASHBANG2, index, /*v_flashbang*/XorStr<0xEA, 12, 0x5E894409>("\x9C\xB4\x8A\x81\x8F\x9C\x98\x93\x93\x9D\x93" + 0x5E894409).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*flash_top*/XorStr<0x5E, 10, 0x26775D5F>("\x38\x33\x01\x12\x0A\x3C\x10\x0A\x16" + 0x26775D5F).s, FLASHBANG3, index, /*v_flashbang*/XorStr<0x7D, 12, 0x7EEF4E13>("\x0B\x21\x19\xEC\xE0\xF1\xEB\xE6\xE4\xE8\xE0" + 0x7EEF4E13).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*flash_body*/XorStr<0x81, 11, 0x0D180C0A>("\xE7\xEE\xE2\xF7\xED\xD9\xE5\xE7\xED\xF3" + 0x0D180C0A).s, FLASHBANG10, index, /*v_shield_flashbang*/XorStr<0xC4, 19, 0xC208A332>("\xB2\x9A\xB5\xAF\xA1\xAC\xA6\xAF\x93\xAB\xA2\xAE\xA3\xB9\xB0\xB2\xBA\xB2" + 0xC208A332).s, 2, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*flash_spoon*/XorStr<0xC6, 12, 0x3CB888A6>("\xA0\xAB\xA9\xBA\xA2\x94\xBF\xBD\xA1\xA0\xBE" + 0x3CB888A6).s, FLASHBANG2, index, /*v_shield_flashbang*/XorStr<0xF4, 19, 0xE1EBCEA4>("\x82\xAA\x85\x9F\x91\x9C\x96\x9F\xA3\x9B\x92\x9E\x73\x69\x60\x62\x6A\x62" + 0xE1EBCEA4).s, 2, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*flash_top*/XorStr<0x19, 10, 0x79473EA1>("\x7F\x76\x7A\x6F\x75\x41\x6B\x4F\x51" + 0x79473EA1).s, FLASHBANG3, index, /*v_shield_flashbang*/XorStr<0x30, 19, 0x5A4D541B>("\x46\x6E\x41\x5B\x5D\x50\x5A\x53\x67\x5F\x56\x5A\x4F\x55\x5C\x5E\x2E\x26" + 0x5A4D541B).s, 2, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*barrel*/XorStr<0xD5, 7, 0xF6B53CEC>("\xB7\xB7\xA5\xAA\xBC\xB6" + 0xF6B53CEC).s, G3SG11, index, /*v_g3sg1*/XorStr<0xD2, 8, 0xCC6B7842>("\xA4\x8C\xB3\xE6\xA5\xB0\xE9" + 0xCC6B7842).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*body*/XorStr<0x11, 5, 0x2BCEA9E6>("\x73\x7D\x77\x6D" + 0x2BCEA9E6).s, G3SG12, index, /*v_g3sg1*/XorStr<0x5F, 8, 0xA3E38A6D>("\x29\x3F\x06\x51\x10\x03\x54" + 0xA3E38A6D).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*buttstock*/XorStr<0x78, 10, 0x4DA7777E>("\x1A\x0C\x0E\x0F\x0F\x09\x11\x1C\xEB" + 0x4DA7777E).s, G3SG13, index, /*v_g3sg1*/XorStr<0x00, 8, 0x9D59A733>("\x76\x5E\x65\x30\x77\x62\x37" + 0x9D59A733).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*forearm*/XorStr<0xD0, 8, 0xAE86FAF7>("\xB6\xBE\xA0\xB6\xB5\xA7\xBB" + 0xAE86FAF7).s, G3SG14, index, /*v_g3sg1*/XorStr<0xF2, 8, 0x2731218E>("\x84\xAC\x93\xC6\x85\x90\xC9" + 0x2731218E).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*lowerbody*/XorStr<0x5E, 10, 0x7DE945B7>("\x32\x30\x17\x04\x10\x01\x0B\x01\x1F" + 0x7DE945B7).s, G3SG15, index, /*v_g3sg1*/XorStr<0xB1, 8, 0xA86917A1>("\xC7\xED\xD4\x87\xC6\xD1\x86" + 0xA86917A1).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*scope.bmp*/XorStr<0xE7, 10, 0xBD99007C>("\x94\x8B\x86\x9A\x8E\xC2\x8F\x83\x9F" + 0xBD99007C).s, G3SG16, index, /*v_g3sg1*/XorStr<0x88, 8, 0x7DCBD355>("\xFE\xD6\xED\xB8\xFF\xEA\xBF" + 0x7DCBD355).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*scope_hold*/XorStr<0xFF, 11, 0x07B00834>("\x8C\x63\x6E\x72\x66\x5B\x6D\x69\x6B\x6C" + 0x07B00834).s, G3SG17, index, /*v_g3sg1*/XorStr<0x44, 8, 0x7E5062B5>("\x32\x1A\x21\x74\x3B\x2E\x7B" + 0x7E5062B5).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*scope_knob*/XorStr<0x33, 11, 0xB12B0422>("\x40\x57\x5A\x46\x52\x67\x52\x54\x54\x5E" + 0xB12B0422).s, G3SG18, index, /*v_g3sg1*/XorStr<0x04, 8, 0x7BEE74BA>("\x72\x5A\x61\x34\x7B\x6E\x3B" + 0x7BEE74BA).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*galil*/XorStr<0xED, 6, 0x755BD3C5>("\x8A\x8F\x83\x99\x9D" + 0x755BD3C5).s, GALIL1, index, /*v_galil*/XorStr<0x2E, 8, 0x73469545>("\x58\x70\x57\x50\x5E\x5A\x58" + 0x73469545).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*glock_barrel*/XorStr<0x10, 13, 0x1361295D>("\x77\x7D\x7D\x70\x7F\x4A\x74\x76\x6A\x6B\x7F\x77" + 0x1361295D).s, GLOCK181, index, /*v_glock18*/XorStr<0x9A, 10, 0x577E692E>("\xEC\xC4\xFB\xF1\xF1\xFC\xCB\x90\x9A" + 0x577E692E).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*glock_base*/XorStr<0xCF, 11, 0xC70EF95C>("\xA8\xBC\xBE\xB1\xB8\x8B\xB7\xB7\xA4\xBD" + 0xC70EF95C).s, GLOCK182, index, /*v_glock18*/XorStr<0xB7, 10, 0xA802AAF3>("\xC1\xE7\xDE\xD6\xD4\xDF\xD6\x8F\x87" + 0xA802AAF3).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*glock_mag*/XorStr<0x90, 10, 0x7AAB09B7>("\xF7\xFD\xFD\xF0\xFF\xCA\xFB\xF6\xFF" + 0x7AAB09B7).s, GLOCK183, index, /*v_glock18*/XorStr<0xD0, 10, 0xA8892B7C>("\xA6\x8E\xB5\xBF\xBB\xB6\xBD\xE6\xE0" + 0xA8892B7C).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*glock_slide*/XorStr<0x8C, 12, 0x233385ED>("\xEB\xE1\xE1\xEC\xFB\xCE\xE1\xFF\xFD\xF1\xF3" + 0x233385ED).s, GLOCK184, index, /*v_glock18*/XorStr<0xB9, 10, 0xE2758901>("\xCF\xE5\xDC\xD0\xD2\xDD\xD4\xF1\xF9" + 0xE2758901).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*glock_barrel*/XorStr<0x55, 13, 0x0E5951E7>("\x32\x3A\x38\x3B\x32\x05\x39\x3D\x2F\x2C\x3A\x0C" + 0x0E5951E7).s, GLOCK181, index, /*v_shield_glock18*/XorStr<0x40, 17, 0xB2F80DBA>("\x36\x1E\x31\x2B\x2D\x20\x2A\x23\x17\x2E\x26\x24\x2F\x26\x7F\x77" + 0xB2F80DBA).s, 2, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*glock_base*/XorStr<0x08, 11, 0x07168922>("\x6F\x65\x65\x68\x67\x52\x6C\x6E\x63\x74" + 0x07168922).s, GLOCK182, index, /*v_shield_glock18*/XorStr<0xEB, 17, 0xC6FCC814>("\x9D\xB3\x9E\x86\x86\x95\x9D\x96\xAC\x93\x99\x99\x94\x93\xC8\xC2" + 0xC6FCC814).s, 2, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*glock_mag*/XorStr<0x99, 10, 0xE6266CF7>("\xFE\xF6\xF4\xFF\xF6\xC1\xF2\xC1\xC6" + 0xE6266CF7).s, GLOCK183, index, /*v_shield_glock18*/XorStr<0xB6, 17, 0x5537F4A4>("\xC0\xE8\xCB\xD1\xD3\xDE\xD0\xD9\xE1\xD8\xAC\xAE\xA1\xA8\xF5\xFD" + 0x5537F4A4).s, 2, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*glock_slide*/XorStr<0x93, 12, 0x628BEF39>("\xF4\xF8\xFA\xF5\xFC\xC7\xEA\xF6\xF2\xF8\xF8" + 0x628BEF39).s, GLOCK184, index, /*v_shield_glock18*/XorStr<0x0E, 17, 0x949639D5>("\x78\x50\x63\x79\x7B\x76\x78\x71\x49\x70\x74\x76\x79\x70\x2D\x25" + 0x949639D5).s, 2, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*he_body*/XorStr<0xE0, 8, 0x26DAE79F>("\x88\x84\xBD\x81\x8B\x81\x9F" + 0x26DAE79F).s, HEGRENADE1, index, /*v_hegrenade*/XorStr<0xF8, 12, 0x7084180B>("\x8E\xA6\x92\x9E\x9B\x8F\x9B\x91\x61\x65\x67" + 0x7084180B).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*he_spoon*/XorStr<0x34, 9, 0xDBA2C5CF>("\x5C\x50\x69\x44\x48\x56\x55\x55" + 0xDBA2C5CF).s, HEGRENADE2, index, /*v_hegrenade*/XorStr<0x43, 12, 0xEF763F78>("\x35\x1B\x2D\x23\x20\x3A\x2C\x24\x2A\x28\x28" + 0xEF763F78).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*he_top*/XorStr<0x62, 7, 0xB7DB656B>("\x0A\x06\x3B\x11\x09\x17" + 0xB7DB656B).s, HEGRENADE3, index, /*v_hegrenade*/XorStr<0x6B, 12, 0x0ACD9140>("\x1D\x33\x05\x0B\x08\x02\x14\x1C\x12\x10\x10" + 0x0ACD9140).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*he_body*/XorStr<0xE9, 8, 0x9FBA8C50>("\x81\x8F\xB4\x8E\x82\x8A\x96" + 0x9FBA8C50).s, HEGRENADE10, index, /*v_shield_hegrenade*/XorStr<0xBB, 19, 0x67CF515A>("\xCD\xE3\xCE\xD6\xD6\xA5\xAD\xA6\x9C\xAC\xA0\xA1\xB5\xAD\xA7\xAB\xAF\xA9" + 0x67CF515A).s, 2, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*he_spoon*/XorStr<0x59, 9, 0x0D7DCCBA>("\x31\x3F\x04\x2F\x2D\x31\x30\x0E" + 0x0D7DCCBA).s, HEGRENADE2, index, /*v_shield_hegrenade*/XorStr<0xB9, 19, 0xCBFAB395>("\xCF\xE5\xC8\xD4\xD4\xDB\xD3\xA4\x9E\xAA\xA6\xA3\xB7\xA3\xA9\xA9\xAD\xAF" + 0xCBFAB395).s, 2, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*he_top*/XorStr<0x44, 7, 0x39FE6EAA>("\x2C\x20\x19\x33\x27\x39" + 0x39FE6EAA).s, HEGRENADE3, index, /*v_shield_hegrenade*/XorStr<0xD6, 19, 0xB41A5BF5>("\xA0\x88\xAB\xB1\xB3\xBE\xB0\xB9\x81\xB7\x85\x86\x90\x86\x8A\x84\x82\x82" + 0xB41A5BF5).s, 2, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*knifeskin*/XorStr<0x5D, 10, 0x21EAFFEB>("\x36\x30\x36\x06\x04\x11\x08\x0D\x0B" + 0x21EAFFEB).s, KNIFE1, index, /*v_knife*/XorStr<0xDF, 8, 0xE7C2B7DC>("\xA9\xBF\x8A\x8C\x8A\x82\x80" + 0xE7C2B7DC).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*knifeskin*/XorStr<0x29, 10, 0xCEF8BCDA>("\x42\x44\x42\x4A\x48\x5D\x44\x59\x5F" + 0xCEF8BCDA).s, KNIFE2, index, /*v_shield_knife*/XorStr<0xE0, 15, 0x8BE1FE03>("\x96\xBE\x91\x8B\x8D\x80\x8A\x83\xB7\x82\x84\x82\x8A\x88" + 0x8BE1FE03).s, 2, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*barrel*/XorStr<0x82, 7, 0x0B6E316B>("\xE0\xE2\xF6\xF7\xE3\xEB" + 0x0B6E316B).s, M31, index, /*v_m3*/XorStr<0xB1, 5, 0x19DD14D4>("\xC7\xED\xDE\x87" + 0x19DD14D4).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*forearm*/XorStr<0xC7, 8, 0x46778949>("\xA1\xA7\xBB\xAF\xAA\xBE\xA0" + 0x46778949).s, M32, index, /*v_m3*/XorStr<0x3A, 5, 0xA46DFF82>("\x4C\x64\x51\x0E" + 0xA46DFF82).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*handle*/XorStr<0x4B, 7, 0xBE67D280>("\x23\x2D\x23\x2A\x23\x35" + 0xBE67D280).s, M33, index, /*v_m3*/XorStr<0x54, 5, 0xD166F077>("\x22\x0A\x3B\x64" + 0xD166F077).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*sights*/XorStr<0xEF, 7, 0x2A6D91C7>("\x9C\x99\x96\x9A\x87\x87" + 0x2A6D91C7).s, M34, index, /*v_m3*/XorStr<0xA9, 5, 0x9B57A703>("\xDF\xF5\xC6\x9F" + 0x9B57A703).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*barrel*/XorStr<0x26, 7, 0x24FDA369>("\x44\x46\x5A\x5B\x4F\x47" + 0x24FDA369).s, M4A11, index, /*v_m4a1*/XorStr<0x05, 7, 0xB7A75823>("\x73\x59\x6A\x3C\x68\x3B" + 0xB7A75823).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*buttstock*/XorStr<0xA3, 10, 0x055DED56>("\xC1\xD1\xD1\xD2\xD4\xDC\xC6\xC9\xC0" + 0x055DED56).s, M4A12, index, /*v_m4a1*/XorStr<0x3D, 7, 0x584AA73F>("\x4B\x61\x52\x74\x20\x73" + 0x584AA73F).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*handle*/XorStr<0x45, 7, 0x87870A15>("\x2D\x27\x29\x2C\x25\x2F" + 0x87870A15).s, M4A13, index, /*v_m4a1*/XorStr<0xA5, 7, 0x03D3782C>("\xD3\xF9\xCA\x9C\xC8\x9B" + 0x03D3782C).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*magazine*/XorStr<0x2B, 9, 0x68B53A23>("\x46\x4D\x4A\x4F\x55\x59\x5F\x57" + 0x68B53A23).s, M4A14, index, /*v_m4a1*/XorStr<0xB5, 7, 0x58BA281B>("\xC3\xE9\xDA\x8C\xD8\x8B" + 0x58BA281B).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*receiver*/XorStr<0x32, 9, 0xAE7157C5>("\x40\x56\x57\x50\x5F\x41\x5D\x4B" + 0xAE7157C5).s, M4A15, index, /*v_m4a1*/XorStr<0xB5, 7, 0xDA46D668>("\xC3\xE9\xDA\x8C\xD8\x8B" + 0xDA46D668).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*silencer*/XorStr<0xAD, 9, 0x623C9518>("\xDE\xC7\xC3\xD5\xDF\xD1\xD6\xC6" + 0x623C9518).s, M4A16, index, /*v_m4a1*/XorStr<0x04, 7, 0x94BD7529>("\x72\x5A\x6B\x33\x69\x38" + 0x94BD7529).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*ammobox*/XorStr<0x0D, 8, 0xE17D4411>("\x6C\x63\x62\x7F\x73\x7D\x6B" + 0xE17D4411).s, M2491, index, /*v_m249*/XorStr<0xB3, 7, 0xA75260CF>("\xC5\xEB\xD8\x84\x83\x81" + 0xA75260CF).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*barrel*/XorStr<0x75, 7, 0xC61BB4B7>("\x17\x17\x05\x0A\x1C\x16" + 0xC61BB4B7).s, M2492, index, /*v_m249*/XorStr<0x00, 7, 0xAEE0A208>("\x76\x5E\x6F\x31\x30\x3C" + 0xAEE0A208).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*body*/XorStr<0x49, 5, 0x057CD8BE>("\x2B\x25\x2F\x35" + 0x057CD8BE).s, M2493, index, /*v_m249*/XorStr<0xFB, 7, 0xA93656B5>("\x8D\xA3\x90\xCC\xCB\x39" + 0xA93656B5).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*bullet*/XorStr<0xA4, 7, 0xE98B88C8>("\xC6\xD0\xCA\xCB\xCD\xDD" + 0xE98B88C8).s, M2494, index, /*v_m249*/XorStr<0xA0, 7, 0x0D0CD9D7>("\xD6\xFE\xCF\x91\x90\x9C" + 0x0D0CD9D7).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*buttstock*/XorStr<0x5E, 10, 0xEDAFF389>("\x3C\x2A\x14\x15\x11\x17\x0B\x06\x0D" + 0xEDAFF389).s, M2495, index, /*v_m249*/XorStr<0xD9, 7, 0xF1EDDF14>("\xAF\x85\xB6\xEE\xE9\xE7" + 0xF1EDDF14).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*cover*/XorStr<0x8E, 6, 0xC2818651>("\xED\xE0\xE6\xF4\xE0" + 0xC2818651).s, M2496, index, /*v_m249*/XorStr<0xCC, 7, 0x0C606FA9>("\xBA\x92\xA3\xFD\xE4\xE8" + 0x0C606FA9).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*forearm*/XorStr<0x1C, 8, 0x67C0DB00>("\x7A\x72\x6C\x7A\x41\x53\x4F" + 0x67C0DB00).s, M2497, index, /*v_m249*/XorStr<0x37, 7, 0x20131AAB>("\x41\x67\x54\x08\x0F\x05" + 0x20131AAB).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*handle*/XorStr<0xD8, 7, 0xF87FDDE7>("\xB0\xB8\xB4\xBF\xB0\xB8" + 0xF87FDDE7).s, M2498, index, /*v_m249*/XorStr<0x13, 7, 0x0EF1C768>("\x65\x4B\x78\x24\x23\x21" + 0x0EF1C768).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*sight*/XorStr<0x11, 6, 0x9E6BB6C9>("\x62\x7B\x74\x7C\x61" + 0x9E6BB6C9).s, M2499, index, /*v_m249*/XorStr<0x12, 7, 0x1D70056A>("\x64\x4C\x79\x27\x22\x2E" + 0x1D70056A).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*body*/XorStr<0x2D, 5, 0x634BDEC6>("\x4F\x41\x4B\x49" + 0x634BDEC6).s, MAC101, index, /*v_mac10*/XorStr<0x35, 8, 0x576A1287>("\x43\x69\x5A\x59\x5A\x0B\x0B" + 0x576A1287).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*buttstock*/XorStr<0x81, 10, 0xF955080A>("\xE3\xF7\xF7\xF0\xF6\xF2\xE8\xEB\xE2" + 0xF955080A).s, MAC102, index, /*v_mac10*/XorStr<0x1D, 8, 0x317BEDD0>("\x6B\x41\x72\x41\x42\x13\x13" + 0x317BEDD0).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*handle*/XorStr<0x34, 7, 0x71F71E00>("\x5C\x54\x58\x53\x54\x5C" + 0x71F71E00).s, MAC103, index, /*v_mac10*/XorStr<0x2C, 8, 0x98E9B614>("\x5A\x72\x43\x4E\x53\x00\x02" + 0x98E9B614).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*barrel*/XorStr<0x60, 7, 0x2893C101>("\x02\x00\x10\x11\x01\x09" + 0x2893C101).s, MP51, index, /*v_mp5*/XorStr<0xD5, 6, 0x24AF9CE0>("\xA3\x89\xBA\xA8\xEC" + 0x24AF9CE0).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*buttstock*/XorStr<0x7B, 10, 0xE2E28C36>("\x19\x09\x09\x0A\x0C\xF4\xEE\xE1\xE8" + 0xE2E28C36).s, MP52, index, /*v_mp5*/XorStr<0xDA, 6, 0x26949E2C>("\xAC\x84\xB1\xAD\xEB" + 0x26949E2C).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*clip*/XorStr<0x7E, 5, 0xB965E997>("\x1D\x13\xE9\xF1" + 0xB965E997).s, MP53, index, /*v_mp5*/XorStr<0x2D, 6, 0x9517CD1F>("\x5B\x71\x42\x40\x04" + 0x9517CD1F).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*forearm*/XorStr<0x31, 8, 0xE5BC60C2>("\x57\x5D\x41\x51\x54\x44\x5A" + 0xE5BC60C2).s, MP54, index, /*v_mp5*/XorStr<0x89, 6, 0x98AD8622>("\xFF\xD5\xE6\xFC\xB8" + 0x98AD8622).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*handle*/XorStr<0xA4, 7, 0xBAD3B39A>("\xCC\xC4\xC8\xC3\xC4\xCC" + 0xBAD3B39A).s, MP55, index, /*v_mp5*/XorStr<0xEC, 6, 0x064BF899>("\x9A\xB2\x83\x9F\xC5" + 0x064BF899).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*lowerrec*/XorStr<0x06, 9, 0xDBF852AC>("\x6A\x68\x7F\x6C\x78\x79\x69\x6E" + 0xDBF852AC).s, MP56, index, /*v_mp5*/XorStr<0x45, 6, 0x82C0CD07>("\x33\x19\x2A\x38\x7C" + 0x82C0CD07).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*rearsight*/XorStr<0x41, 10, 0x1AAE62ED>("\x33\x27\x22\x36\x36\x2F\x20\x20\x3D" + 0x1AAE62ED).s, MP57, index, /*v_mp5*/XorStr<0x9E, 6, 0xEB3E9541>("\xE8\xC0\xCD\xD1\x97" + 0xEB3E9541).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*buttstock*/XorStr<0x97, 10, 0xA1AF40E3>("\xF5\xED\xED\xEE\xE8\xE8\xF2\xFD\xF4" + 0xA1AF40E3).s, P901, index, /*v_p90*/XorStr<0x8E, 6, 0xD6B47DF0>("\xF8\xD0\xE0\xA8\xA2" + 0xD6B47DF0).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*handle-1*/XorStr<0x2F, 9, 0x6F4E45F6>("\x47\x51\x5F\x56\x5F\x51\x18\x07" + 0x6F4E45F6).s, P902, index, /*v_p90*/XorStr<0x6C, 6, 0x9B63F39A>("\x1A\x32\x1E\x56\x40" + 0x9B63F39A).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*handles*/XorStr<0xDB, 8, 0x50B70C1A>("\xB3\xBD\xB3\xBA\xB3\x85\x92" + 0x50B70C1A).s, P903, index, /*v_p90*/XorStr<0xB7, 6, 0x625546E3>("\xC1\xE7\xC9\x83\x8B" + 0x625546E3).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*magazine*/XorStr<0x89, 9, 0x3A98BCF4>("\xE4\xEB\xEC\xED\xF7\xE7\xE1\xF5" + 0x3A98BCF4).s, P904, index, /*v_p90*/XorStr<0x2B, 6, 0xA0278456>("\x5D\x73\x5D\x17\x1F" + 0xA0278456).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*sights-1*/XorStr<0x8E, 9, 0x6F40A4EF>("\xFD\xE6\xF7\xF9\xE6\xE0\xB9\xA4" + 0x6F40A4EF).s, P905, index, /*v_p90*/XorStr<0x6E, 6, 0x6F0A9A9B>("\x18\x30\x00\x48\x42" + 0x6F0A9A9B).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*p228_handle*/XorStr<0x2A, 12, 0x66A59624>("\x5A\x19\x1E\x15\x71\x47\x51\x5F\x56\x5F\x51" + 0x66A59624).s, P2281, index, /*v_p228*/XorStr<0x63, 7, 0x755B28BB>("\x15\x3B\x15\x54\x55\x50" + 0x755B28BB).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*p228_mag*/XorStr<0x6C, 9, 0x81666613>("\x1C\x5F\x5C\x57\x2F\x1C\x13\x14" + 0x81666613).s, P2282, index, /*v_p228*/XorStr<0x4A, 7, 0x065EB51D>("\x3C\x14\x3C\x7F\x7C\x77" + 0x065EB51D).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*p228_slide*/XorStr<0x9E, 11, 0x283E4666>("\xEE\xAD\x92\x99\xFD\xD0\xC8\xCC\xC2\xC2" + 0x283E4666).s, P2283, index, /*v_p228*/XorStr<0x9A, 7, 0xB23B201A>("\xEC\xC4\xEC\xAF\xAC\xA7" + 0xB23B201A).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*p228_handle*/XorStr<0xFE, 12, 0xB87285CF>("\x8E\xCD\x32\x39\x5D\x6B\x65\x6B\x62\x6B\x6D" + 0xB87285CF).s, P2281, index, /*v_shield_p228*/XorStr<0x41, 14, 0x6E3F5299>("\x37\x1D\x30\x2C\x2C\x23\x2B\x2C\x16\x3A\x79\x7E\x75" + 0x6E3F5299).s, 2, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*p228_mag*/XorStr<0xF7, 9, 0x4859075F>("\x87\xCA\xCB\xC2\xA4\x91\x9C\x99" + 0x4859075F).s, P2282, index, /*v_shield_p228*/XorStr<0x43, 14, 0x49B0097A>("\x35\x1B\x36\x2E\x2E\x2D\x25\x2E\x14\x3C\x7F\x7C\x77" + 0x49B0097A).s, 2, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*p228_slide*/XorStr<0x20, 11, 0x5DA09B5F>("\x50\x13\x10\x1B\x7B\x56\x4A\x4E\x4C\x4C" + 0x5DA09B5F).s, P2283, index, /*v_shield_p228*/XorStr<0x71, 14, 0x5A995FFA>("\x07\x2D\x00\x1C\x1C\x13\x1B\x1C\x26\x0A\x49\x4E\x45" + 0x5A995FFA).s, 2, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*base*/XorStr<0x7A, 5, 0xBC324D60>("\x18\x1A\x0F\x18" + 0xBC324D60).s, SCOUT1, index, /*v_scout*/XorStr<0x10, 8, 0xC875739C>("\x66\x4E\x61\x70\x7B\x60\x62" + 0xC875739C).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*magazine*/XorStr<0xB7, 9, 0x847C82E4>("\xDA\xD9\xDE\xDB\xC1\xD5\xD3\xDB" + 0x847C82E4).s, SCOUT2, index, /*v_scout*/XorStr<0x45, 8, 0xF8E6A475>("\x33\x19\x34\x2B\x26\x3F\x3F" + 0xF8E6A475).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*rail*/XorStr<0x13, 5, 0x4983BD6B>("\x61\x75\x7C\x7A" + 0x4983BD6B).s, SCOUT3, index, /*v_scout*/XorStr<0xDA, 8, 0x6CE9E92A>("\xAC\x84\xAF\xBE\xB1\xAA\x94" + 0x6CE9E92A).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*scope.bmp*/XorStr<0xC6, 10, 0xFB05C6A0>("\xB5\xA4\xA7\xB9\xAF\xE5\xAE\xA0\xBE" + 0xFB05C6A0).s, SCOUT4, index, /*v_scout*/XorStr<0x93, 8, 0x5CC2CDA6>("\xE5\xCB\xE6\xF5\xF8\xED\xED" + 0x5CC2CDA6).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*scope_clamps*/XorStr<0x78, 13, 0xEB627346>("\x0B\x1A\x15\x0B\x19\x22\x1D\x13\xE1\xEC\xF2\xF0" + 0xEB627346).s, SCOUT5, index, /*v_scout*/XorStr<0x3C, 8, 0xCB266253>("\x4A\x62\x4D\x5C\x2F\x34\x36" + 0xCB266253).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*buttstock*/XorStr<0xC0, 10, 0x0C102040>("\xA2\xB4\xB6\xB7\xB7\xB1\xA9\xA4\xA3" + 0x0C102040).s, SG5501, index, /*v_sg550*/XorStr<0xC8, 8, 0x38118E57>("\xBE\x96\xB9\xAC\xF9\xF8\xFE" + 0x38118E57).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*forearm*/XorStr<0xA2, 8, 0xC16E1B8A>("\xC4\xCC\xD6\xC0\xC7\xD5\xC5" + 0xC16E1B8A).s, SG5502, index, /*v_sg550*/XorStr<0x27, 8, 0xA7FEDDFE>("\x51\x77\x5A\x4D\x1E\x19\x1D" + 0xA7FEDDFE).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*handle*/XorStr<0x92, 7, 0x86876E63>("\xFA\xF2\xFA\xF1\xFA\xF2" + 0x86876E63).s, SG5503, index, /*v_sg550*/XorStr<0xEA, 8, 0x643F11EB>("\x9C\xB4\x9F\x8A\xDB\xDA\xC0" + 0x643F11EB).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*magazine_transp*/XorStr<0x02, 16, 0x89F469E5>("\x6F\x62\x63\x64\x7C\x6E\x66\x6C\x55\x7F\x7E\x6C\x60\x7C\x60" + 0x89F469E5).s, SG5504, index, /*v_sg550*/XorStr<0xFC, 8, 0x60CF2221>("\x8A\xA2\x8D\x98\x35\x34\x32" + 0x60CF2221).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*receiver*/XorStr<0x07, 9, 0x0B009020>("\x75\x6D\x6A\x6F\x62\x7A\x68\x7C" + 0x0B009020).s, SG5505, index, /*v_sg550*/XorStr<0xD5, 8, 0x8A9955CB>("\xA3\x89\xA4\xBF\xEC\xEF\xEB" + 0x8A9955CB).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*scope*/XorStr<0x55, 6, 0x8C6E12D0>("\x26\x35\x38\x28\x3C" + 0x8C6E12D0).s, SG5506, index, /*v_sg550*/XorStr<0x9C, 8, 0xF01240F3>("\xEA\xC2\xED\xF8\x95\x94\x92" + 0xF01240F3).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*acog*/XorStr<0x39, 5, 0xA934BECF>("\x58\x59\x54\x5B" + 0xA934BECF).s, SG5521, index, /*v_sg552*/XorStr<0xF0, 8, 0x5DCD2A44>("\x86\xAE\x81\x94\xC1\xC0\xC4" + 0x5DCD2A44).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*buttstock*/XorStr<0x0C, 10, 0x745B3207>("\x6E\x78\x7A\x7B\x63\x65\x7D\x70\x7F" + 0x745B3207).s, SG5522, index, /*v_sg552*/XorStr<0x47, 8, 0x9894F5D0>("\x31\x17\x3A\x2D\x7E\x79\x7F" + 0x9894F5D0).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*forearm*/XorStr<0x28, 8, 0x8586AA6D>("\x4E\x46\x58\x4E\x4D\x5F\x43" + 0x8586AA6D).s, SG5523, index, /*v_sg552*/XorStr<0x98, 8, 0x4548BC9B>("\xEE\xC6\xE9\xFC\xA9\xA8\xAC" + 0x4548BC9B).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*handle*/XorStr<0xA4, 7, 0xBF34E1C0>("\xCC\xC4\xC8\xC3\xC4\xCC" + 0xBF34E1C0).s, SG5524, index, /*v_sg552*/XorStr<0xB3, 8, 0xB93BD22E>("\xC5\xEB\xC6\xD1\x82\x8D\x8B" + 0xB93BD22E).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*magazine_transp*/XorStr<0x42, 16, 0xF4A9D9D7>("\x2F\x22\x23\x24\x3C\x2E\x26\x2C\x15\x3F\x3E\x2C\x20\x3C\x20" + 0xF4A9D9D7).s, SG5525, index, /*v_sg552*/XorStr<0x95, 8, 0x7548044B>("\xE3\xC9\xE4\xFF\xAC\xAF\xA9" + 0x7548044B).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*shield.bmp*/XorStr<0xE8, 11, 0x508BA4C4>("\x9B\x81\x83\x8E\x80\x89\xC0\x8D\x9D\x81" + 0x508BA4C4).s, SHIELD31, index, /*v_shield_deagle*/XorStr<0x8E, 16, 0x13784ADA>("\xF8\xD0\xE3\xF9\xFB\xF6\xF8\xF1\xC9\xF3\xFD\xF8\xFD\xF7\xF9" + 0x13784ADA).s, 2, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*shield_glass*/XorStr<0x34, 13, 0x810ECA74>("\x47\x5D\x5F\x52\x54\x5D\x65\x5C\x50\x5C\x4D\x4C" + 0x810ECA74).s, SHIELD3, index, /*v_shield_deagle*/XorStr<0x7E, 16, 0x86AC4906>("\x08\x20\xF3\xE9\xEB\xE6\xE8\xE1\xD9\xE3\xED\xE8\xED\xE7\xE9" + 0x86AC4906).s, 2, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*shield.bmp*/XorStr<0x69, 11, 0x53E9D92E>("\x1A\x02\x02\x09\x01\x0A\x41\x12\x1C\x02" + 0x53E9D92E).s, SHIELD31, index, /*v_shield_fiveseven*/XorStr<0x56, 19, 0x9602B90C>("\x20\x08\x2B\x31\x33\x3E\x30\x39\x01\x39\x09\x17\x07\x10\x01\x13\x03\x09" + 0x9602B90C).s, 2, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*shield_glass*/XorStr<0x4D, 13, 0x8C41678B>("\x3E\x26\x26\x35\x3D\x36\x0C\x33\x39\x37\x24\x2B" + 0x8C41678B).s, SHIELD3, index, /*v_shield_fiveseven*/XorStr<0x47, 19, 0xD09714BB>("\x31\x17\x3A\x22\x22\x29\x21\x2A\x10\x36\x38\x24\x36\x27\x30\x20\x32\x36" + 0xD09714BB).s, 2, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*shield.bmp*/XorStr<0x89, 11, 0x6ACEACA6>("\xFA\xE2\xE2\xE9\xE1\xEA\xA1\xF2\xFC\xE2" + 0x6ACEACA6).s, SHIELD31, index, /*v_shield_flashbang*/XorStr<0x50, 19, 0x1E60CA96>("\x26\x0E\x21\x3B\x3D\x30\x3A\x33\x07\x3F\x36\x3A\x2F\x35\x3C\x3E\x0E\x06" + 0x1E60CA96).s, 2, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*shield_glass*/XorStr<0x7D, 13, 0xB0730248>("\x0E\x16\x16\xE5\xED\xE6\xDC\xE3\xE9\xE7\xF4\xFB" + 0xB0730248).s, SHIELD3, index, /*v_shield_flashbang*/XorStr<0xDC, 19, 0xF19A82C0>("\xAA\x82\xAD\xB7\x89\x84\x8E\x87\xBB\x83\x8A\x86\x9B\x81\x88\x8A\x82\x8A" + 0xF19A82C0).s, 2, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*shield.bmp*/XorStr<0x9A, 11, 0x5E508629>("\xE9\xF3\xF5\xF8\xF2\xFB\x8E\xC3\xCF\xD3" + 0x5E508629).s, SHIELD31, index, /*v_shield_glock18*/XorStr<0xBC, 17, 0x9AD79FFC>("\xCA\xE2\xCD\xD7\xA9\xA4\xAE\xA7\x9B\xA2\xAA\xA8\xAB\xA2\xFB\xF3" + 0x9AD79FFC).s, 2, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*shield_glass*/XorStr<0x8E, 13, 0x324FD7A8>("\xFD\xE7\xF9\xF4\xFE\xF7\xCB\xF2\xFA\xF6\xEB\xEA" + 0x324FD7A8).s, SHIELD3, index, /*v_shield_glock18*/XorStr<0x8C, 17, 0x94BBAFAA>("\xFA\xD2\xFD\xE7\xF9\xF4\xFE\xF7\xCB\xF2\xFA\xF8\xFB\xF2\xAB\xA3" + 0x94BBAFAA).s, 2, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*shield.bmp*/XorStr<0xD5, 11, 0x47B45AF1>("\xA6\xBE\xBE\xBD\xB5\xBE\xF5\xBE\xB0\xAE" + 0x47B45AF1).s, SHIELD31, index, /*v_shield_hegrenade*/XorStr<0x3A, 19, 0xD47920EF>("\x4C\x64\x4F\x55\x57\x5A\x2C\x25\x1D\x2B\x21\x22\x34\x22\x26\x28\x2E\x2E" + 0xD47920EF).s, 2, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*shield_glass*/XorStr<0x6F, 13, 0xB89290F9>("\x1C\x18\x18\x17\x1F\x10\x2A\x11\x1B\x19\x0A\x09" + 0xB89290F9).s, SHIELD3, index, /*v_shield_hegrenade*/XorStr<0x14, 19, 0x8C3263B7>("\x62\x4A\x65\x7F\x71\x7C\x76\x7F\x43\x75\x7B\x78\x52\x44\x4C\x42\x40\x40" + 0x8C3263B7).s, 2, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*shield.bmp*/XorStr<0x6F, 11, 0xF554F7BC>("\x1C\x18\x18\x17\x1F\x10\x5B\x14\x1A\x08" + 0xF554F7BC).s, SHIELD31, index, /*v_shield_knife*/XorStr<0x61, 15, 0x904951DB>("\x17\x3D\x10\x0C\x0C\x03\x0B\x0C\x36\x01\x05\x05\x0B\x0B" + 0x904951DB).s, 2, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*shield.bmp*/XorStr<0xF9, 11, 0x333ED94E>("\x8A\x92\x92\x99\x91\x9A\xD1\x62\x6C\x72" + 0x333ED94E).s, SHIELD31, index, /*v_shield_p228*/XorStr<0xAE, 14, 0x17252AF9>("\xD8\xF0\xC3\xD9\xDB\xD6\xD8\xD1\xE9\xC7\x8A\x8B\x82" + 0x17252AF9).s, 2, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*shield_glass*/XorStr<0xED, 13, 0xFE0F80A7>("\x9E\x86\x86\x95\x9D\x96\xAC\x93\x99\x97\x84\x8B" + 0xFE0F80A7).s, SHIELD3, index, /*v_shield_p228*/XorStr<0x1E, 14, 0xEC0FE3B1>("\x68\x40\x53\x49\x4B\x46\x48\x41\x79\x57\x1A\x1B\x12" + 0xEC0FE3B1).s, 2, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*shield.bmp*/XorStr<0x42, 11, 0x129EAF9A>("\x31\x2B\x2D\x20\x2A\x23\x66\x2B\x27\x3B" + 0x129EAF9A).s, SHIELD31, index, /*v_shield_smokegrenade*/XorStr<0x20, 22, 0x9648BFF6>("\x56\x7E\x51\x4B\x4D\x40\x4A\x43\x77\x5A\x47\x44\x47\x48\x49\x5D\x55\x5F\x53\x57\x51" + 0x9648BFF6).s, 2, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*shield_glass*/XorStr<0xE8, 13, 0x31D6FB0E>("\x9B\x81\x83\x8E\x80\x89\xB1\x88\x9C\x90\x81\x80" + 0x31D6FB0E).s, SHIELD3, index, /*v_shield_smokegrenade*/XorStr<0x15, 22, 0x8E87B2CA>("\x63\x49\x64\x70\x70\x7F\x77\x78\x42\x6D\x72\x4F\x4A\x47\x44\x56\x40\x48\x46\x4C\x4C" + 0x8E87B2CA).s, 2, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*shield.bmp*/XorStr<0x14, 11, 0x6E4EB785>("\x67\x7D\x7F\x72\x74\x7D\x34\x79\x71\x6D" + 0x6E4EB785).s, SHIELD31, index, /*v_shield_usp*/XorStr<0x10, 13, 0x1A8C0658>("\x66\x4E\x61\x7B\x7D\x70\x7A\x73\x47\x6C\x69\x6B" + 0x1A8C0658).s, 2, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*shield_glass*/XorStr<0x86, 13, 0xEAEB6DBB>("\xF5\xEF\xE1\xEC\xE6\xEF\xD3\xEA\xE2\xEE\xE3\xE2" + 0xEAEB6DBB).s, SHIELD3, index, /*v_shield_usp*/XorStr<0x23, 13, 0x3091247E>("\x55\x7B\x56\x4E\x4E\x4D\x45\x4E\x74\x59\x5E\x5E" + 0x3091247E).s, 2, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*smoke_body*/XorStr<0x40, 11, 0x6C79255E>("\x33\x2C\x2D\x28\x21\x1A\x24\x28\x2C\x30" + 0x6C79255E).s, SMOKEGRENADE1, index, /*v_smokegrenade*/XorStr<0xFA, 15, 0xEC86FEEF>("\x8C\xA4\x8F\x90\x91\x94\x65\x66\x70\x66\x6A\x64\x62\x62" + 0xEC86FEEF).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*smoke_spoon*/XorStr<0x42, 12, 0x079C7D68>("\x31\x2E\x2B\x2E\x23\x18\x3B\x39\x25\x24\x22" + 0x079C7D68).s, SMOKEGRENADE2, index, /*v_smokegrenade*/XorStr<0x7A, 15, 0x7015AB71>("\x0C\x24\x0F\x10\x11\x14\xE5\xE6\xF0\xE6\xEA\xE4\xE2\xE2" + 0x7015AB71).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*smoke_top*/XorStr<0xB9, 10, 0x9A0A370E>("\xCA\xD7\xD4\xD7\xD8\xE1\xCB\xAF\xB1" + 0x9A0A370E).s, SMOKEGRENADE3, index, /*v_smokegrenade*/XorStr<0x46, 15, 0xA60E72A5>("\x30\x18\x3B\x24\x25\x20\x29\x2A\x3C\x2A\x3E\x30\x36\x36" + 0xA60E72A5).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*smoke_body*/XorStr<0xC7, 11, 0xAD0142CF>("\xB4\xA5\xA6\xA1\xAE\x93\xAF\xA1\xAB\xA9" + 0xAD0142CF).s, SMOKEGRENADE10, index, /*v_shield_smokegrenade*/XorStr<0x8B, 22, 0x29356197>("\xFD\xD3\xFE\xE6\xE6\xF5\xFD\xF6\xCC\xE7\xF8\xF9\xFC\xFD\xFE\xE8\xFE\xF2\xFC\xFA\xFA" + 0x29356197).s, 2, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*smoke_spoon*/XorStr<0x75, 12, 0x76663902>("\x06\x1B\x18\x13\x1C\x25\x08\x0C\x12\x11\x11" + 0x76663902).s, SMOKEGRENADE2, index, /*v_shield_smokegrenade*/XorStr<0x32, 22, 0x045F89EE>("\x44\x6C\x47\x5D\x5F\x52\x54\x5D\x65\x48\x51\x52\x55\x5A\x27\x33\x27\x2D\x25\x21\x23" + 0x045F89EE).s, 2, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*smoke_top*/XorStr<0x61, 10, 0xC66D45DC>("\x12\x0F\x0C\x0F\x00\x39\x13\x07\x19" + 0xC66D45DC).s, SMOKEGRENADE3, index, /*v_shield_smokegrenade*/XorStr<0x60, 22, 0x2C01D6FB>("\x16\x3E\x11\x0B\x0D\x00\x0A\x03\x37\x1A\x07\x04\x07\x08\x09\x1D\x15\x1F\x13\x17\x11" + 0x2C01D6FB).s, 2, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*barrel*/XorStr<0x20, 7, 0xDA42F49C>("\x42\x40\x50\x51\x41\x49" + 0xDA42F49C).s, TMP1, index, /*v_tmp*/XorStr<0xB2, 6, 0xB64E0B92>("\xC4\xEC\xC0\xD8\xC6" + 0xB64E0B92).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*body*/XorStr<0x82, 5, 0x65EDBB74>("\xE0\xEC\xE0\xFC" + 0x65EDBB74).s, TMP2, index, /*v_tmp*/XorStr<0x4C, 6, 0xF178948F>("\x3A\x12\x3A\x22\x20" + 0xF178948F).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*ejector*/XorStr<0xBB, 8, 0x90969A20>("\xDE\xD6\xD8\xDD\xCB\xAF\xB3" + 0x90969A20).s, TMP3, index, /*v_tmp*/XorStr<0xBD, 6, 0x5D5AEDCF>("\xCB\xE1\xCB\xAD\xB1" + 0x5D5AEDCF).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*forearm*/XorStr<0x51, 8, 0x17655B94>("\x37\x3D\x21\x31\x34\x24\x3A" + 0x17655B94).s, TMP4, index, /*v_tmp*/XorStr<0x46, 6, 0xD70D46F7>("\x30\x18\x3C\x24\x3A" + 0xD70D46F7).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*handle*/XorStr<0xB6, 7, 0x6413C2AD>("\xDE\xD6\xD6\xDD\xD6\xDE" + 0x6413C2AD).s, TMP5, index, /*v_tmp*/XorStr<0xE9, 6, 0x13EF9C27>("\x9F\xB5\x9F\x81\x9D" + 0x13EF9C27).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*magazine*/XorStr<0x73, 9, 0x629B4C31>("\x1E\x15\x12\x17\x0D\x11\x17\x1F" + 0x629B4C31).s, TMP6, index, /*v_tmp*/XorStr<0xB3, 6, 0xAD82743E>("\xC5\xEB\xC1\xDB\xC7" + 0xAD82743E).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*misc*/XorStr<0xBF, 5, 0x33D9B2F0>("\xD2\xA9\xB2\xA1" + 0x33D9B2F0).s, TMP7, index, /*v_tmp*/XorStr<0x7D, 6, 0x112DA448>("\x0B\x21\x0B\xED\xF1" + 0x112DA448).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*silencer*/XorStr<0xAB, 9, 0x4F30CECE>("\xD8\xC5\xC1\xCB\xC1\xD3\xD4\xC0" + 0x4F30CECE).s, TMP8, index, /*v_tmp*/XorStr<0xB2, 6, 0xA3439E0F>("\xC4\xEC\xC0\xD8\xC6" + 0xA3439E0F).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*top.bmp*/XorStr<0x94, 8, 0x61045BB4>("\xE0\xFA\xE6\xB9\xFA\xF4\xEA" + 0x61045BB4).s, TMP9, index, /*v_tmp*/XorStr<0xE1, 6, 0xE318BA11>("\x97\xBD\x97\x89\x95" + 0xE318BA11).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*buttstock*/XorStr<0x07, 10, 0x6E87126D>("\x65\x7D\x7D\x7E\x78\x78\x62\x6D\x64" + 0x6E87126D).s, UMP451, index, /*v_ump45*/XorStr<0x1C, 8, 0xB15E1903>("\x6A\x42\x6B\x72\x50\x15\x17" + 0xB15E1903).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*handle*/XorStr<0xDC, 7, 0xA6C3BDEB>("\xB4\xBC\xB0\xBB\x8C\x84" + 0xA6C3BDEB).s, UMP452, index, /*v_ump45*/XorStr<0xC4, 8, 0x8FA16FD4>("\xB2\x9A\xB3\xAA\xB8\xFD\xFF" + 0x8FA16FD4).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*receiver*/XorStr<0xEB, 9, 0xC3A5E643>("\x99\x89\x8E\x8B\x86\x86\x94\x80" + 0xC3A5E643).s, UMP453, index, /*v_ump45*/XorStr<0x07, 8, 0x9DBC6A14>("\x71\x57\x7C\x67\x7B\x38\x38" + 0x9DBC6A14).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*handle*/XorStr<0x84, 7, 0x2D0E6F78>("\xEC\xE4\xE8\xE3\xE4\xEC" + 0x2D0E6F78).s, USP1, index, /*v_usp*/XorStr<0x6C, 6, 0x2E2DC127>("\x1A\x32\x1B\x1C\x00" + 0x2E2DC127).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*mag*/XorStr<0xF2, 4, 0xB65266F7>("\x9F\x92\x93" + 0xB65266F7).s, USP2, index, /*v_usp*/XorStr<0x40, 6, 0xD05C54E0>("\x36\x1E\x37\x30\x34" + 0xD05C54E0).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*silencer*/XorStr<0x4D, 9, 0x5143AD1F>("\x3E\x27\x23\x35\x3F\x31\x36\x26" + 0x5143AD1F).s, USP3, index, /*v_usp*/XorStr<0x52, 6, 0x9C3D5E69>("\x24\x0C\x21\x26\x26" + 0x9C3D5E69).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*slide*/XorStr<0x41, 6, 0x96AA2AD0>("\x32\x2E\x2A\x20\x20" + 0x96AA2AD0).s, USP4, index, /*v_usp*/XorStr<0x78, 6, 0xE6CE60CF>("\x0E\x26\x0F\x08\x0C" + 0xE6CE60CF).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*handle*/XorStr<0x3B, 7, 0x08B98B3B>("\x53\x5D\x53\x5A\x53\x25" + 0x08B98B3B).s, USP1, index, /*v_shield_usp*/XorStr<0x42, 13, 0xF8014D09>("\x34\x1C\x37\x2D\x2F\x22\x24\x2D\x15\x3E\x3F\x3D" + 0xF8014D09).s, 2, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*mag*/XorStr<0x64, 4, 0xA5CE3675>("\x09\x04\x01" + 0xA5CE3675).s, USP2, index, /*v_shield_usp*/XorStr<0x36, 13, 0x40D30CDF>("\x40\x68\x4B\x51\x53\x5E\x50\x59\x61\x4A\x33\x31" + 0x40D30CDF).s, 2, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*slide*/XorStr<0x7B, 6, 0x686D6CA3>("\x08\x10\x14\x1A\x1A" + 0x686D6CA3).s, USP4, index, /*v_shield_usp*/XorStr<0x07, 13, 0xBBAEE3A3>("\x71\x57\x7A\x62\x62\x69\x61\x6A\x50\x65\x62\x62" + 0xBBAEE3A3).s, 2, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*barrel*/XorStr<0x68, 7, 0x23A1D8C5>("\x0A\x08\x18\x19\x09\x01" + 0x23A1D8C5).s, XM10141, index, /*v_xm1014*/XorStr<0xB0, 9, 0x23A8795F>("\xC6\xEE\xCA\xDE\x85\x85\x87\x83" + 0x23A8795F).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*body*/XorStr<0x7A, 5, 0xE968E545>("\x18\x14\x18\x04" + 0xE968E545).s, XM10142, index, /*v_xm1014*/XorStr<0x0F, 9, 0x8577C41B>("\x79\x4F\x69\x7F\x22\x24\x24\x22" + 0x8577C41B).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*buttstock*/XorStr<0x37, 10, 0x4E80B944>("\x55\x4D\x4D\x4E\x48\x48\x52\x5D\x54" + 0x4E80B944).s, XM10143, index, /*v_xm1014*/XorStr<0xA3, 9, 0x9AC353EF>("\xD5\xFB\xDD\xCB\x96\x98\x98\x9E" + 0x9AC353EF).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*forearm*/XorStr<0x37, 8, 0x99CA84E6>("\x51\x57\x4B\x5F\x5A\x4E\x50" + 0x99CA84E6).s, XM10144, index, /*v_xm1014*/XorStr<0x02, 9, 0x4081781C>("\x74\x5C\x7C\x68\x37\x37\x39\x3D" + 0x4081781C).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*rear_sight*/XorStr<0x23, 11, 0x316294FB>("\x51\x41\x44\x54\x78\x5B\x40\x4D\x43\x58" + 0x316294FB).s, XM10145, index, /*v_xm1014*/XorStr<0x6F, 9, 0xA86DBDD8>("\x19\x2F\x09\x1F\x42\x44\x44\x42" + 0xA86DBDD8).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*shell*/XorStr<0xE7, 6, 0x7EA614A4>("\x94\x80\x8C\x86\x87" + 0x7EA614A4).s, XM10146, index, /*v_xm1014*/XorStr<0xAE, 9, 0x4632EF40>("\xD8\xF0\xC8\xDC\x83\x83\x85\x81" + 0x4632EF40).s, 3, cvar.visual_skins_viewmodel), index++;
	ReplaceTextureIndex(/*view_glove*/XorStr<0xCC, 11, 0x024A73A7>("\xBA\xA4\xAB\xB8\x8F\xB6\xBE\xBC\xA2\xB0" + 0x024A73A7).s, HANDS1, index, /*v_ak47*/XorStr<0x37, 7, 0x1E75FA6C>("\x41\x67\x58\x51\x0F\x0B" + 0x1E75FA6C).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_glove*/XorStr<0x7C, 11, 0x463E64E1>("\x0A\x14\x1B\x08\xDF\xE6\xEE\xEC\xF2\xE0" + 0x463E64E1).s, HANDS1, index, /*v_aug*/XorStr<0x70, 6, 0xDB353F3E>("\x06\x2E\x13\x06\x13" + 0xDB353F3E).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_glove*/XorStr<0x64, 11, 0x2E1F59F7>("\x12\x0C\x03\x10\x37\x0E\x06\x04\x1A\x08" + 0x2E1F59F7).s, HANDS1, index, /*v_awp*/XorStr<0x3F, 6, 0xF1F400F9>("\x49\x1F\x20\x35\x33" + 0xF1F400F9).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_glove*/XorStr<0x88, 11, 0xBC01F4FB>("\xFE\xE0\xEF\xFC\xD3\xEA\xE2\xE0\xE6\xF4" + 0xBC01F4FB).s, HANDS1, index, /*v_c4*/XorStr<0xE1, 5, 0x2E6B7F65>("\x97\xBD\x80\xD0" + 0x2E6B7F65).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_glove*/XorStr<0xC4, 11, 0x63AF9767>("\xB2\xAC\xA3\xB0\x97\xAE\xA6\xA4\xBA\xA8" + 0x63AF9767).s, HANDS1, index, /*v_deagle*/XorStr<0xBF, 9, 0x52DB150D>("\xC9\x9F\xA5\xA7\xA2\xA3\xA9\xA3" + 0x52DB150D).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_glove*/XorStr<0x22, 11, 0xFF8803F6>("\x54\x4A\x41\x52\x79\x40\x44\x46\x5C\x4E" + 0xFF8803F6).s, HANDS1, index, /*v_elite*/XorStr<0x76, 8, 0xEB0B8E70>("\x00\x28\x1D\x15\x13\x0F\x19" + 0xEB0B8E70).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_glove*/XorStr<0x93, 11, 0x968C0472>("\xE5\xFD\xF0\xE1\xC8\xFF\xF5\xF5\xED\xF9" + 0x968C0472).s, HANDS1, index, /*v_famas*/XorStr<0x52, 8, 0xB08DAE49>("\x24\x0C\x32\x34\x3B\x36\x2B" + 0xB08DAE49).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_glove*/XorStr<0x22, 11, 0xE66E24EE>("\x54\x4A\x41\x52\x79\x40\x44\x46\x5C\x4E" + 0xE66E24EE).s, HANDS1, index, /*v_fiveseven*/XorStr<0xC5, 12, 0x539E8624>("\xB3\x99\xA1\xA1\xBF\xAF\xB8\xA9\xBB\xAB\xA1" + 0x539E8624).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_glove*/XorStr<0x55, 11, 0x6FAE269F>("\x23\x3F\x32\x2F\x06\x3D\x37\x33\x2B\x3B" + 0x6FAE269F).s, HANDS1, index, /*v_flashbang*/XorStr<0x0A, 12, 0x51A30C4C>("\x7C\x54\x6A\x61\x6F\x7C\x78\x73\x73\x7D\x73" + 0x51A30C4C).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_glove*/XorStr<0xB1, 11, 0xD294C456>("\xC7\xDB\xD6\xC3\xEA\xD1\xDB\xD7\xCF\xDF" + 0xD294C456).s, HANDS1, index, /*v_g3sg1*/XorStr<0x01, 8, 0xEE9CA0F2>("\x77\x5D\x64\x37\x76\x61\x36" + 0xEE9CA0F2).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_glove*/XorStr<0x7C, 11, 0x3E53D14A>("\x0A\x14\x1B\x08\xDF\xE6\xEE\xEC\xF2\xE0" + 0x3E53D14A).s, HANDS1, index, /*v_galil*/XorStr<0x0C, 8, 0xA9B68866>("\x7A\x52\x69\x6E\x7C\x78\x7E" + 0xA9B68866).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_glove*/XorStr<0x9C, 11, 0x8AFEF286>("\xEA\xF4\xFB\xE8\xFF\xC6\xCE\xCC\xD2\xC0" + 0x8AFEF286).s, HANDS1, index, /*v_glock18*/XorStr<0xB5, 10, 0x3D2ED580>("\xC3\xE9\xD0\xD4\xD6\xD9\xD0\x8D\x85" + 0x3D2ED580).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_glove*/XorStr<0xC4, 11, 0xF3EF5686>("\xB2\xAC\xA3\xB0\x97\xAE\xA6\xA4\xBA\xA8" + 0xF3EF5686).s, HANDS1, index, /*v_hegrenade*/XorStr<0x9A, 12, 0xE45329A0>("\xEC\xC4\xF4\xF8\xF9\xED\xC5\xCF\xC3\xC7\xC1" + 0xE45329A0).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_glove*/XorStr<0x07, 11, 0x7FD90EC7>("\x71\x61\x6C\x7D\x54\x6B\x61\x61\x79\x75" + 0x7FD90EC7).s, HANDS1, index, /*v_knife*/XorStr<0xE2, 8, 0xC2D374F2>("\x94\xBC\x8F\x8B\x8F\x81\x8D" + 0xC2D374F2).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_glove*/XorStr<0x53, 11, 0x665FA944>("\x25\x3D\x30\x21\x08\x3F\x35\x35\x2D\x39" + 0x665FA944).s, HANDS1, index, /*v_m3*/XorStr<0xB8, 5, 0x1266A81E>("\xCE\xE6\xD7\x88" + 0x1266A81E).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_glove*/XorStr<0x08, 11, 0x0825820A>("\x7E\x60\x6F\x7C\x53\x6A\x62\x60\x66\x74" + 0x0825820A).s, HANDS1, index, /*v_m4a1*/XorStr<0x9B, 7, 0xE967D451>("\xED\xC3\xF0\xAA\xFE\x91" + 0xE967D451).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_glove*/XorStr<0xB8, 11, 0xDBF9A2D4>("\xCE\xD0\xDF\xCC\xE3\xDA\xD2\xD0\xB6\xA4" + 0xDBF9A2D4).s, HANDS1, index, /*v_m249*/XorStr<0xB7, 7, 0xDB82AA5D>("\xC1\xE7\xD4\x88\x8F\x85" + 0xDB82AA5D).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_glove*/XorStr<0x98, 11, 0x86CE3512>("\xEE\xF0\xFF\xEC\xC3\xFA\xF2\xF0\xD6\xC4" + 0x86CE3512).s, HANDS1, index, /*v_mac10*/XorStr<0x35, 8, 0xB53450DD>("\x43\x69\x5A\x59\x5A\x0B\x0B" + 0xB53450DD).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_glove*/XorStr<0x13, 11, 0x8711C2A7>("\x65\x7D\x70\x61\x48\x7F\x75\x75\x6D\x79" + 0x8711C2A7).s, HANDS1, index, /*v_mp5*/XorStr<0x4E, 6, 0x7EABE9EE>("\x38\x10\x3D\x21\x67" + 0x7EABE9EE).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_glove*/XorStr<0xA3, 11, 0x8BB321F8>("\xD5\xCD\xC0\xD1\xF8\xCF\xC5\xC5\xDD\xC9" + 0x8BB321F8).s, HANDS1, index, /*v_p90*/XorStr<0xD9, 6, 0x105D8986>("\xAF\x85\xAB\xE5\xED" + 0x105D8986).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_glove*/XorStr<0xAA, 11, 0x3C77C707>("\xDC\xC2\xC9\xDA\xF1\xC8\xDC\xDE\xC4\xD6" + 0x3C77C707).s, HANDS1, index, /*v_p228*/XorStr<0x15, 7, 0x19540073>("\x63\x49\x67\x2A\x2B\x22" + 0x19540073).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_glove*/XorStr<0xDC, 11, 0xEA8A8EFE>("\xAA\xB4\xBB\xA8\xBF\x86\x8E\x8C\x92\x80" + 0xEA8A8EFE).s, HANDS1, index, /*v_scout*/XorStr<0x48, 8, 0x73CF78D9>("\x3E\x16\x39\x28\x23\x38\x3A" + 0x73CF78D9).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_glove*/XorStr<0x12, 11, 0x0E15AD2C>("\x64\x7A\x71\x62\x49\x70\x74\x76\x6C\x7E" + 0x0E15AD2C).s, HANDS1, index, /*v_sg550*/XorStr<0xAC, 8, 0x41B2FD39>("\xDA\xF2\xDD\xC8\x85\x84\x82" + 0x41B2FD39).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_glove*/XorStr<0x72, 11, 0xC604AC32>("\x04\x1A\x11\x02\x29\x10\x14\x16\x0C\x1E" + 0xC604AC32).s, HANDS1, index, /*v_sg552*/XorStr<0x40, 8, 0xA52415C9>("\x36\x1E\x31\x24\x71\x70\x74" + 0xA52415C9).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_glove*/XorStr<0x81, 11, 0x000269D0>("\xF7\xEB\xE6\xF3\xDA\xE1\xEB\xE7\xFF\xEF" + 0x000269D0).s, HANDS1, index, /*v_smokegrenade*/XorStr<0x32, 15, 0xE730671F>("\x44\x6C\x47\x58\x59\x5C\x5D\x5E\x48\x5E\x52\x5C\x5A\x5A" + 0xE730671F).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_glove*/XorStr<0xD3, 11, 0xE654AA62>("\xA5\xBD\xB0\xA1\x88\xBF\xB5\xB5\xAD\xB9" + 0xE654AA62).s, HANDS1, index, /*v_tmp*/XorStr<0x7A, 6, 0x99730851>("\x0C\x24\x08\x10\x0E" + 0x99730851).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_glove*/XorStr<0x9E, 11, 0x76119CFC>("\xE8\xF6\xC5\xD6\xFD\xC4\xC8\xCA\xD0\xC2" + 0x76119CFC).s, HANDS1, index, /*v_ump45*/XorStr<0xE5, 8, 0x183212DF>("\x93\xB9\x92\x85\x99\xDE\xDE" + 0x183212DF).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_glove*/XorStr<0x50, 11, 0xB57F3394>("\x26\x38\x37\x24\x0B\x32\x3A\x38\x2E\x3C" + 0xB57F3394).s, HANDS1, index, /*v_usp*/XorStr<0x53, 6, 0x18BA946F>("\x25\x0B\x20\x25\x27" + 0x18BA946F).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_glove*/XorStr<0x99, 11, 0x1568FAA3>("\xEF\xF3\xFE\xEB\xC2\xF9\xF3\xCF\xD7\xC7" + 0x1568FAA3).s, HANDS1, index, /*v_xm1014*/XorStr<0xBB, 9, 0x7DE02238>("\xCD\xE3\xC5\xD3\x8E\xF0\xF0\xF6" + 0x7DE02238).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_glove*/XorStr<0x44, 11, 0xD28BFD90>("\x32\x2C\x23\x30\x17\x2E\x26\x24\x3A\x28" + 0xD28BFD90).s, HANDS1, index, /*v_shield_deagle*/XorStr<0xED, 16, 0xC7E07FAC>("\x9B\xB1\x9C\x98\x98\x97\x9F\x90\xAA\x92\x92\x99\x9E\x96\x9E" + 0xC7E07FAC).s, 2, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_glove*/XorStr<0x08, 11, 0xB0733078>("\x7E\x60\x6F\x7C\x53\x6A\x62\x60\x66\x74" + 0xB0733078).s, HANDS1, index, /*v_shield_fiveseven*/XorStr<0x9E, 19, 0x519CD6AA>("\xE8\xC0\xD3\xC9\xCB\xC6\xC8\xC1\xF9\xC1\xC1\xDF\xCF\xD8\xC9\xDB\xCB\xC1" + 0x519CD6AA).s, 2, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_glove*/XorStr<0xCC, 11, 0xD4E38495>("\xBA\xA4\xAB\xB8\x8F\xB6\xBE\xBC\xA2\xB0" + 0xD4E38495).s, HANDS1, index, /*v_shield_flashbang*/XorStr<0x81, 19, 0x920BD37E>("\xF7\xDD\xF0\xEC\xEC\xE3\xEB\xEC\xD6\xEC\xE7\xED\xFE\xE6\xED\xF1\xFF\xF5" + 0x920BD37E).s, 2, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_glove*/XorStr<0x66, 11, 0xEA8E6010>("\x10\x0E\x0D\x1E\x35\x0C\x00\x02\x18\x0A" + 0xEA8E6010).s, HANDS1, index, /*v_shield_glock18*/XorStr<0x20, 17, 0xFC6299E4>("\x56\x7E\x51\x4B\x4D\x40\x4A\x43\x77\x4E\x46\x44\x4F\x46\x1F\x17" + 0xFC6299E4).s, 2, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_glove*/XorStr<0xB7, 11, 0x6EEB3ACD>("\xC1\xD1\xDC\xCD\xE4\xDB\xD1\xD1\xC9\xA5" + 0x6EEB3ACD).s, HANDS1, index, /*v_shield_hegrenade*/XorStr<0xBA, 19, 0x85DEAED3>("\xCC\xE4\xCF\xD5\xD7\xDA\xAC\xA5\x9D\xAB\xA1\xA2\xB4\xA2\xA6\xA8\xAE\xAE" + 0x85DEAED3).s, 2, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_glove*/XorStr<0xB4, 11, 0x0F88FCEE>("\xC2\xDC\xD3\xC0\xE7\xDE\xD6\xD4\xCA\xD8" + 0x0F88FCEE).s, HANDS1, index, /*v_shield_knife*/XorStr<0xD9, 15, 0x5B0A5BA6>("\xAF\x85\xA8\xB4\xB4\xBB\xB3\x84\xBE\x89\x8D\x8D\x83\x83" + 0x5B0A5BA6).s, 2, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_glove*/XorStr<0xB5, 11, 0xD49C6028>("\xC3\xDF\xD2\xCF\xE6\xDD\xD7\xD3\xCB\xDB" + 0xD49C6028).s, HANDS1, index, /*v_shield_p228*/XorStr<0xE3, 14, 0x171A20CE>("\x95\xBB\x96\x8E\x8E\x8D\x85\x8E\xB4\x9C\xDF\xDC\xD7" + 0x171A20CE).s, 2, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_glove*/XorStr<0xA7, 11, 0x035099D6>("\xD1\xC1\xCC\xDD\xF4\xCB\xC1\xC1\xD9\xD5" + 0x035099D6).s, HANDS1, index, /*v_shield_smokegrenade*/XorStr<0xFD, 22, 0x0CC32EC4>("\x8B\xA1\x8C\x68\x68\x67\x6F\x60\x5A\x75\x6A\x67\x62\x6F\x6C\x7E\x68\x60\x6E\x74\x74" + 0x0CC32EC4).s, 2, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_glove*/XorStr<0x9B, 11, 0x7F852B39>("\xED\xF5\xF8\xE9\xC0\xC7\xCD\xCD\xD5\xC1" + 0x7F852B39).s, HANDS1, index, /*v_shield_usp*/XorStr<0xF3, 13, 0xC026E2ED>("\x85\xAB\x86\x9E\x9E\x9D\x95\x9E\xA4\x89\x8E\x8E" + 0xC026E2ED).s, 2, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_finger*/XorStr<0xC6, 12, 0x4A334BBF>("\xB0\xAE\xAD\xBE\x95\xAD\xA5\xA3\xA9\xAA\xA2" + 0x4A334BBF).s, HANDS39, index, /*v_ak47*/XorStr<0x42, 7, 0xB59B1617>("\x34\x1C\x25\x2E\x72\x70" + 0xB59B1617).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_finger*/XorStr<0x24, 12, 0x9F3F90DF>("\x52\x4C\x43\x50\x77\x4F\x43\x45\x4B\x48\x5C" + 0x9F3F90DF).s, HANDS39, index, /*v_aug*/XorStr<0xED, 6, 0xA68AD6A4>("\x9B\xB1\x8E\x85\x96" + 0xA68AD6A4).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_finger*/XorStr<0xB6, 12, 0xD16469A7>("\xC0\xDE\xDD\xCE\xE5\xDD\xD5\xD3\xD9\xDA\xB2" + 0xD16469A7).s, HANDS39, index, /*v_awp*/XorStr<0x0F, 6, 0xEC511870>("\x79\x4F\x70\x65\x63" + 0xEC511870).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_finger*/XorStr<0x4A, 12, 0x23A274D1>("\x3C\x22\x29\x3A\x11\x29\x39\x3F\x35\x36\x26" + 0x23A274D1).s, HANDS39, index, /*v_c4*/XorStr<0xD9, 5, 0x7B3D3FAC>("\xAF\x85\xB8\xE8" + 0x7B3D3FAC).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_finger*/XorStr<0x7F, 12, 0xA898C09F>("\x09\xE9\xE4\xF5\xDC\xE2\xEC\xE8\xE0\xED\xFB" + 0xA898C09F).s, HANDS39, index, /*v_deagle*/XorStr<0x83, 9, 0x7575B489>("\xF5\xDB\xE1\xE3\xE6\xEF\xE5\xEF" + 0x7575B489).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_finger*/XorStr<0x4C, 12, 0xCCEE43D6>("\x3A\x24\x2B\x38\x0F\x37\x3B\x3D\x33\x30\x24" + 0xCCEE43D6).s, HANDS39, index, /*v_elite*/XorStr<0xDB, 8, 0x831D48E8>("\xAD\x83\xB8\xB2\xB6\x94\x84" + 0x831D48E8).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_finger*/XorStr<0x55, 12, 0xC20F5C9C>("\x23\x3F\x32\x2F\x06\x3C\x32\x32\x3A\x3B\x2D" + 0xC20F5C9C).s, HANDS39, index, /*v_famas*/XorStr<0x82, 8, 0x25AAECEC>("\xF4\xDC\xE2\xE4\xEB\xE6\xFB" + 0x25AAECEC).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_finger*/XorStr<0x49, 12, 0x1514E8BD>("\x3F\x23\x2E\x3B\x12\x28\x26\x3E\x36\x37\x21" + 0x1514E8BD).s, HANDS39, index, /*v_fiveseven*/XorStr<0x50, 12, 0xCEBFBA28>("\x26\x0E\x34\x3A\x22\x30\x25\x32\x2E\x3C\x34" + 0xCEBFBA28).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_finger*/XorStr<0xB0, 12, 0xE94412CF>("\xC6\xD8\xD7\xC4\xEB\xD3\xDF\xD9\xDF\xDC\xC8" + 0xE94412CF).s, HANDS39, index, /*v_flashbang*/XorStr<0x97, 12, 0x75EDBBB4>("\xE1\xC7\xFF\xF6\xFA\xEF\xF5\xFC\xFE\xCE\xC6" + 0x75EDBBB4).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_finger*/XorStr<0xEB, 12, 0xC8C28C25>("\x9D\x85\x88\x99\xB0\x96\x98\x9C\x94\x91\x87" + 0xC8C28C25).s, HANDS39, index, /*v_g3sg1*/XorStr<0xAA, 8, 0x7E7154AC>("\xDC\xF4\xCB\x9E\xDD\xC8\x81" + 0x7E7154AC).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_finger*/XorStr<0xD6, 12, 0xC940EDE1>("\xA0\xBE\xBD\xAE\x85\xBD\xB5\xB3\xB9\xBA\x92" + 0xC940EDE1).s, HANDS39, index, /*v_galil*/XorStr<0xDA, 8, 0x5235BAFC>("\xAC\x84\xBB\xBC\xB2\xB6\x8C" + 0x5235BAFC).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_finger*/XorStr<0xA6, 12, 0xAEC027C5>("\xD0\xCE\xCD\xDE\xF5\xCD\xC5\xC3\xC9\xCA\xC2" + 0xAEC027C5).s, HANDS39, index, /*v_glock18*/XorStr<0x2B, 10, 0x9E6C53F2>("\x5D\x73\x4A\x42\x40\x53\x5A\x03\x0B" + 0x9E6C53F2).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_finger*/XorStr<0xCE, 12, 0x8BEA53FD>("\xB8\xA6\xB5\xA6\x8D\xB5\xBD\xBB\xB1\xB2\xAA" + 0x8BEA53FD).s, HANDS39, index, /*v_hegrenade*/XorStr<0x75, 12, 0x238F1E76>("\x03\x29\x1F\x1D\x1E\x08\x1E\x12\x1C\x1A\x1A" + 0x238F1E76).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_finger*/XorStr<0x7A, 12, 0x40308589>("\x0C\x12\x19\x0A\x21\x19\xE9\xEF\xE5\xE6\xF6" + 0x40308589).s, HANDS39, index, /*v_knife*/XorStr<0x22, 8, 0x398E0F8D>("\x54\x7C\x4F\x4B\x4F\x41\x4D" + 0x398E0F8D).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_finger*/XorStr<0x04, 12, 0x5239A828>("\x72\x6C\x63\x70\x57\x6F\x63\x65\x6B\x68\x7C" + 0x5239A828).s, HANDS39, index, /*v_m3*/XorStr<0x43, 5, 0xEAD584D7>("\x35\x1B\x28\x75" + 0xEAD584D7).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_finger*/XorStr<0xF4, 12, 0xB5F1ACFA>("\x82\x9C\x93\x80\xA7\x9F\x93\x95\x9B\x98\x8C" + 0xB5F1ACFA).s, HANDS39, index, /*v_m4a1*/XorStr<0x40, 7, 0x0E9C177C>("\x36\x1E\x2F\x77\x25\x74" + 0x0E9C177C).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_finger*/XorStr<0x78, 12, 0xFD5166F9>("\x0E\x10\x1F\x0C\x23\x1B\x17\x11\xE7\xE4\xF0" + 0xFD5166F9).s, HANDS39, index, /*v_m249*/XorStr<0x2B, 7, 0x99D95B6C>("\x5D\x73\x40\x1C\x1B\x09" + 0x99D95B6C).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_finger*/XorStr<0x0F, 12, 0x42B5C2D8>("\x79\x79\x74\x65\x4C\x72\x7C\x78\x70\x7D\x6B" + 0x42B5C2D8).s, HANDS39, index, /*v_mac10*/XorStr<0xBB, 8, 0x5BD10F0A>("\xCD\xE3\xD0\xDF\xDC\xF1\xF1" + 0x5BD10F0A).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_finger*/XorStr<0x59, 12, 0xDD4CED0E>("\x2F\x33\x3E\x2B\x02\x38\x36\x0E\x06\x07\x11" + 0xDD4CED0E).s, HANDS39, index, /*v_mp5*/XorStr<0x7D, 6, 0x2D07267E>("\x0B\x21\x12\xF0\xB4" + 0x2D07267E).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_finger*/XorStr<0xD2, 12, 0x05C4A114>("\xA4\xBA\xB1\xA2\x89\xB1\xB1\xB7\xBD\xBE\xAE" + 0x05C4A114).s, HANDS39, index, /*v_p90*/XorStr<0xED, 6, 0x27C9AFDA>("\x9B\xB1\x9F\xC9\xC1" + 0x27C9AFDA).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_finger*/XorStr<0xEC, 12, 0x79C63B19>("\x9A\x84\x8B\x98\xAF\x97\x9B\x9D\x93\x90\x84" + 0x79C63B19).s, HANDS39, index, /*v_p228*/XorStr<0x3C, 7, 0x96C13FB5>("\x4A\x62\x4E\x0D\x72\x79" + 0x96C13FB5).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_finger*/XorStr<0x7A, 12, 0x509AC74A>("\x0C\x12\x19\x0A\x21\x19\xE9\xEF\xE5\xE6\xF6" + 0x509AC74A).s, HANDS39, index, /*v_scout*/XorStr<0x7D, 8, 0x868877E7>("\x0B\x21\x0C\xE3\xEE\xF7\xF7" + 0x868877E7).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_finger*/XorStr<0x2B, 12, 0x64B0C04D>("\x5D\x45\x48\x59\x70\x56\x58\x5C\x54\x51\x47" + 0x64B0C04D).s, HANDS39, index, /*v_sg550*/XorStr<0x18, 8, 0x5E8719F1>("\x6E\x46\x69\x7C\x29\x28\x2E" + 0x5E8719F1).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_finger*/XorStr<0x2E, 12, 0x952F5AC9>("\x58\x46\x55\x46\x6D\x55\x5D\x5B\x51\x52\x4A" + 0x952F5AC9).s, HANDS39, index, /*v_sg552*/XorStr<0xAB, 8, 0x32A8F88B>("\xDD\xF3\xDE\xC9\x9A\x85\x83" + 0x32A8F88B).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_finger*/XorStr<0xB2, 12, 0x7520345E>("\xC4\xDA\xD1\xC2\xE9\xD1\xD1\xD7\xDD\xDE\xCE" + 0x7520345E).s, HANDS39, index, /*v_smokegrenade*/XorStr<0xBE, 15, 0xD77CA6D4>("\xC8\xE0\xB3\xAC\xAD\xA8\xA1\xA2\xB4\xA2\xA6\xA8\xAE\xAE" + 0xD77CA6D4).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_finger*/XorStr<0xC9, 12, 0xA90FDB93>("\xBF\xA3\xAE\xBB\x92\xA8\xA6\xBE\xB6\xB7\xA1" + 0xA90FDB93).s, HANDS39, index, /*v_tmp*/XorStr<0xFC, 6, 0x6661F94E>("\x8A\xA2\x8A\x92\x70" + 0x6661F94E).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_finger*/XorStr<0x0C, 12, 0x53782069>("\x7A\x64\x6B\x78\x4F\x77\x7B\x7D\x73\x70\x64" + 0x53782069).s, HANDS39, index, /*v_ump45*/XorStr<0x3E, 8, 0xBD4D109F>("\x48\x60\x35\x2C\x32\x77\x71" + 0xBD4D109F).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_finger*/XorStr<0x18, 12, 0xA82733B8>("\x6E\x70\x7F\x6C\x43\x7B\x77\x71\x47\x44\x50" + 0xA82733B8).s, HANDS39, index, /*v_usp*/XorStr<0x54, 6, 0x7E5D4106>("\x22\x0A\x23\x24\x28" + 0x7E5D4106).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_finger*/XorStr<0x38, 12, 0xF9B6CFAE>("\x4E\x50\x5F\x4C\x63\x5B\x57\x51\x27\x24\x30" + 0xF9B6CFAE).s, HANDS39, index, /*v_xm1014*/XorStr<0x80, 9, 0x8C415745>("\xF6\xDE\xFA\xEE\xB5\xB5\xB7\xB3" + 0x8C415745).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_finger*/XorStr<0xCB, 12, 0x2DC2169C>("\xBD\xA5\xA8\xB9\x90\xB6\xB8\xBC\xB4\xB1\xA7" + 0x2DC2169C).s, HANDS39, index, /*v_shield_deagle*/XorStr<0x95, 16, 0xE5E0A97D>("\xE3\xC9\xE4\xF0\xF0\xFF\xF7\xF8\xC2\xFA\xFA\xC1\xC6\xCE\xC6" + 0xE5E0A97D).s, 2, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_finger*/XorStr<0xD0, 12, 0xF4A21A75>("\xA6\xB8\xB7\xA4\x8B\xB3\xBF\xB9\xBF\xBC\xA8" + 0xF4A21A75).s, HANDS39, index, /*v_shield_fiveseven*/XorStr<0x06, 19, 0x82B3A662>("\x70\x58\x7B\x61\x63\x6E\x60\x69\x51\x69\x79\x67\x77\x60\x71\x63\x73\x79" + 0x82B3A662).s, 2, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_finger*/XorStr<0x58, 12, 0xF3D91756>("\x2E\x30\x3F\x2C\x03\x3B\x37\x31\x07\x04\x10" + 0xF3D91756).s, HANDS39, index, /*v_shield_flashbang*/XorStr<0xE1, 19, 0x1BA852D5>("\x97\xBD\x90\x8C\x8C\x83\x8B\x8C\xB6\x8C\x87\x8D\x9E\x86\x8D\x91\x9F\x95" + 0x1BA852D5).s, 2, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_finger*/XorStr<0x75, 12, 0x640DFD0C>("\x03\x1F\x12\x0F\x26\x1C\x12\x12\x1A\x1B\x0D" + 0x640DFD0C).s, HANDS39, index, /*v_shield_glock18*/XorStr<0x19, 17, 0x8FCDCDC6>("\x6F\x45\x68\x74\x74\x7B\x73\x44\x7E\x45\x4F\x4B\x46\x4D\x16\x10" + 0x8FCDCDC6).s, 2, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_finger*/XorStr<0x80, 12, 0x3236BBDD>("\xF6\xE8\xE7\xF4\xDB\xE3\xEF\xE9\xEF\xEC\xF8" + 0x3236BBDD).s, HANDS39, index, /*v_shield_hegrenade*/XorStr<0x65, 19, 0xCA576EA9>("\x13\x39\x14\x00\x00\x0F\x07\x08\x32\x06\x0A\x17\x03\x17\x1D\x15\x11\x13" + 0xCA576EA9).s, 2, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_finger*/XorStr<0xF2, 12, 0x613DB459>("\x84\x9A\x91\x82\xA9\x91\x91\x97\x9D\x9E\x8E" + 0x613DB459).s, HANDS39, index, /*v_shield_knife*/XorStr<0x7E, 15, 0x6724F9ED>("\x08\x20\xF3\xE9\xEB\xE6\xE8\xE1\xD9\xEC\xE6\xE0\xEC\xEE" + 0x6724F9ED).s, 2, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_finger*/XorStr<0x90, 12, 0xCDF67215>("\xE6\xF8\xF7\xE4\xCB\xF3\xFF\xF9\xFF\xFC\xE8" + 0xCDF67215).s, HANDS39, index, /*v_shield_p228*/XorStr<0xE3, 14, 0xE1CA2FC2>("\x95\xBB\x96\x8E\x8E\x8D\x85\x8E\xB4\x9C\xDF\xDC\xD7" + 0xE1CA2FC2).s, 2, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_finger*/XorStr<0x35, 12, 0xD43354A0>("\x43\x5F\x52\x4F\x66\x5C\x52\x52\x5A\x5B\x4D" + 0xD43354A0).s, HANDS39, index, /*v_shield_smokegrenade*/XorStr<0xD4, 22, 0x097FD30F>("\xA2\x8A\xA5\xBF\xB1\xBC\xB6\xBF\x83\xAE\xB3\xB0\x8B\x84\x85\x91\x81\x8B\x87\x83\x8D" + 0x097FD30F).s, 2, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_finger*/XorStr<0x19, 12, 0x312BB2E4>("\x6F\x73\x7E\x6B\x42\x78\x76\x4E\x46\x47\x51" + 0x312BB2E4).s, HANDS39, index, /*v_shield_usp*/XorStr<0x8D, 13, 0x5F51D944>("\xFB\xD1\xFC\xF8\xF8\xF7\xFF\xF0\xCA\xE3\xE4\xE8" + 0x5F51D944).s, 2, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_skin*/XorStr<0x23, 10, 0x3C8B0704>("\x55\x4D\x40\x51\x78\x5B\x42\x43\x45" + 0x3C8B0704).s, HANDS77, index, /*v_ak47*/XorStr<0xBA, 7, 0x6B6F9C2C>("\xCC\xE4\xDD\xD6\x8A\x88" + 0x6B6F9C2C).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_skin*/XorStr<0xB3, 10, 0xC2173EAA>("\xC5\xDD\xD0\xC1\xE8\xCB\xD2\xD3\xD5" + 0xC2173EAA).s, HANDS77, index, /*v_aug*/XorStr<0xAF, 6, 0xDCA513B8>("\xD9\xEF\xD0\xC7\xD4" + 0xDCA513B8).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_skin*/XorStr<0xD4, 10, 0xF38B0587>("\xA2\xBC\xB3\xA0\x87\xAA\xB1\xB2\xB2" + 0xF38B0587).s, HANDS77, index, /*v_awp*/XorStr<0x96, 6, 0x2FA06FEB>("\xE0\xC8\xF9\xEE\xEA" + 0x2FA06FEB).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_skin*/XorStr<0x6E, 10, 0xADAB9FF0>("\x18\x06\x15\x06\x2D\x00\x1F\x1C\x18" + 0xADAB9FF0).s, HANDS77, index, /*v_c4*/XorStr<0x27, 5, 0x2BAB00C3>("\x51\x77\x4A\x1E" + 0x2BAB00C3).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_skin*/XorStr<0xD3, 10, 0x8FDC4D73>("\xA5\xBD\xB0\xA1\x88\xAB\xB2\xB3\xB5" + 0x8FDC4D73).s, HANDS77, index, /*v_deagle*/XorStr<0xEF, 9, 0xEA5E1501>("\x99\xAF\x95\x97\x92\x93\x99\x93" + 0xEA5E1501).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_skin*/XorStr<0x7D, 10, 0x8B809F80>("\x0B\x17\x1A\xF7\xDE\xF1\xE8\xED\xEB" + 0x8B809F80).s, HANDS77, index, /*v_elite*/XorStr<0x08, 8, 0xC733B985>("\x7E\x56\x6F\x67\x65\x79\x6B" + 0xC733B985).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_skin*/XorStr<0xB1, 10, 0x326382CB>("\xC7\xDB\xD6\xC3\xEA\xC5\xDC\xD1\xD7" + 0x326382CB).s, HANDS77, index, /*v_famas*/XorStr<0x17, 8, 0x0624237F>("\x61\x47\x7F\x7B\x76\x7D\x6E" + 0x0624237F).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_skin*/XorStr<0x8B, 10, 0x54785F49>("\xFD\xE5\xE8\xF9\xD0\xE3\xFA\xFB\xFD" + 0x54785F49).s, HANDS77, index, /*v_fiveseven*/XorStr<0xE3, 12, 0xA86CD4DB>("\x95\xBB\x83\x8F\x91\x8D\x9A\x8F\x9D\x89\x83" + 0xA86CD4DB).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_skin*/XorStr<0xB1, 10, 0xE69141B6>("\xC7\xDB\xD6\xC3\xEA\xC5\xDC\xD1\xD7" + 0xE69141B6).s, HANDS77, index, /*v_flashbang*/XorStr<0xAE, 12, 0x765DB0F0>("\xD8\xF0\xD6\xDD\xD3\xC0\xDC\xD7\xD7\xD9\xDF" + 0x765DB0F0).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_skin*/XorStr<0x94, 10, 0x944CC887>("\xE2\xFC\xF3\xE0\xC7\xEA\xF1\xF2\xF2" + 0x944CC887).s, HANDS77, index, /*v_g3sg1*/XorStr<0xB4, 8, 0x9A43E2F8>("\xC2\xEA\xD1\x84\xCB\xDE\x8B" + 0x9A43E2F8).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_skin*/XorStr<0x27, 10, 0x40D1A683>("\x51\x41\x4C\x5D\x74\x5F\x46\x47\x41" + 0x40D1A683).s, HANDS77, index, /*v_galil*/XorStr<0x57, 8, 0x10C64E3C>("\x21\x07\x3E\x3B\x37\x35\x31" + 0x10C64E3C).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_skin*/XorStr<0x14, 10, 0xE6CD9F4C>("\x62\x7C\x73\x60\x47\x6A\x71\x72\x72" + 0xE6CD9F4C).s, HANDS77, index, /*v_glock18*/XorStr<0x18, 10, 0x9AE6CF79>("\x6E\x46\x7D\x77\x73\x7E\x75\x2E\x18" + 0x9AE6CF79).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_skin*/XorStr<0x26, 10, 0x64324699>("\x50\x4E\x4D\x5E\x75\x58\x47\x44\x40" + 0x64324699).s, HANDS77, index, /*v_hegrenade*/XorStr<0xA9, 12, 0x267A3FE7>("\xDF\xF5\xC3\xC9\xCA\xDC\xCA\xDE\xD0\xD6\xD6" + 0x267A3FE7).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_skin*/XorStr<0x61, 10, 0x13233EB9>("\x17\x0B\x06\x13\x3A\x15\x0C\x01\x07" + 0x13233EB9).s, HANDS77, index, /*v_knife*/XorStr<0x79, 8, 0x1733E3EA>("\x0F\x25\x10\x12\x14\x18\x1A" + 0x1733E3EA).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_skin*/XorStr<0xEE, 10, 0x503EAD04>("\x98\x86\x95\x86\xAD\x80\x9F\x9C\x98" + 0x503EAD04).s, HANDS77, index, /*v_m3*/XorStr<0xA8, 5, 0xC557FAC9>("\xDE\xF6\xC7\x98" + 0xC557FAC9).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_skin*/XorStr<0x92, 10, 0xC7E847B0>("\xE4\xFA\xF1\xE2\xC9\xE4\xF3\xF0\xF4" + 0xC7E847B0).s, HANDS77, index, /*v_m4a1*/XorStr<0xBC, 7, 0x8DC794D2>("\xCA\xE2\xD3\x8B\xA1\xF0" + 0x8DC794D2).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_skin*/XorStr<0xDF, 10, 0x301F6DCD>("\xA9\x89\x84\x95\xBC\x97\x8E\x8F\x89" + 0x301F6DCD).s, HANDS77, index, /*v_m249*/XorStr<0x67, 7, 0x948A0CBA>("\x11\x37\x04\x58\x5F\x55" + 0x948A0CBA).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_skin*/XorStr<0x65, 10, 0x4FD3A28C>("\x13\x0F\x02\x1F\x36\x19\x00\x05\x03" + 0x4FD3A28C).s, HANDS77, index, /*v_mac10*/XorStr<0xE8, 8, 0x372B599D>("\x9E\xB6\x87\x8A\x8F\xDC\xDE" + 0x372B599D).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_skin*/XorStr<0xBA, 10, 0x3B1BD8CC>("\xCC\xD2\xD9\xCA\xE1\xCC\xAB\xA8\xAC" + 0x3B1BD8CC).s, HANDS77, index, /*v_mp5*/XorStr<0xD0, 6, 0x1EAF5B95>("\xA6\x8E\xBF\xA3\xE1" + 0x1EAF5B95).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_skin*/XorStr<0x0F, 10, 0x66A8948E>("\x79\x79\x74\x65\x4C\x67\x7E\x7F\x79" + 0x66A8948E).s, HANDS77, index, /*v_p90*/XorStr<0xA8, 6, 0xEE766B86>("\xDE\xF6\xDA\x92\x9C" + 0xEE766B86).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_skin*/XorStr<0x10, 10, 0xE74EC9D8>("\x66\x78\x77\x64\x4B\x66\x7D\x7E\x76" + 0xE74EC9D8).s, HANDS77, index, /*v_p228*/XorStr<0xB5, 7, 0x01574D83>("\xC3\xE9\xC7\x8A\x8B\x82" + 0x01574D83).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_skin*/XorStr<0xF6, 10, 0x812E40F1>("\x80\x9E\x9D\x8E\xA5\x88\x97\x94\x90" + 0x812E40F1).s, HANDS77, index, /*v_scout*/XorStr<0x3D, 8, 0x7E363494>("\x4B\x61\x4C\x23\x2E\x37\x37" + 0x7E363494).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_skin*/XorStr<0x69, 10, 0xB6907077>("\x1F\x03\x0E\x1B\x32\x1D\x04\x19\x1F" + 0xB6907077).s, HANDS77, index, /*v_sg550*/XorStr<0x6B, 8, 0x10632B07>("\x1D\x33\x1E\x09\x5A\x45\x41" + 0x10632B07).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_skin*/XorStr<0x5C, 10, 0x6119E866>("\x2A\x34\x3B\x28\x3F\x12\x09\x0A\x0A" + 0x6119E866).s, HANDS77, index, /*v_sg552*/XorStr<0xEC, 8, 0xF3D70736>("\x9A\xB2\x9D\x88\xC5\xC4\xC0" + 0xF3D70736).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_skin*/XorStr<0x3A, 10, 0x38B54648>("\x4C\x52\x59\x4A\x61\x4C\x2B\x28\x2C" + 0x38B54648).s, HANDS77, index, /*v_smokegrenade*/XorStr<0x4A, 15, 0x439F4067>("\x3C\x14\x3F\x20\x21\x24\x35\x36\x20\x36\x3A\x34\x32\x32" + 0x439F4067).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_skin*/XorStr<0xEE, 10, 0x7C3E2FDE>("\x98\x86\x95\x86\xAD\x80\x9F\x9C\x98" + 0x7C3E2FDE).s, HANDS77, index, /*v_tmp*/XorStr<0x71, 6, 0x6E4832A1>("\x07\x2D\x07\x19\x05" + 0x6E4832A1).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_skin*/XorStr<0xAE, 10, 0x81B2E631>("\xD8\xC6\xD5\xC6\xED\xC0\xDF\xDC\xD8" + 0x81B2E631).s, HANDS77, index, /*v_ump45*/XorStr<0x2A, 8, 0xE070D756>("\x5C\x74\x59\x40\x5E\x1B\x05" + 0xE070D756).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_skin*/XorStr<0x0F, 10, 0xD69EA87D>("\x79\x79\x74\x65\x4C\x67\x7E\x7F\x79" + 0xD69EA87D).s, HANDS77, index, /*v_usp*/XorStr<0x01, 6, 0xA1E0F2EA>("\x77\x5D\x76\x77\x75" + 0xA1E0F2EA).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_skin*/XorStr<0xE5, 10, 0x62F9DF88>("\x93\x8F\x82\x9F\xB6\x99\x80\x85\x83" + 0x62F9DF88).s, HANDS77, index, /*v_xm1014*/XorStr<0x4D, 9, 0xA471EC43>("\x3B\x11\x37\x3D\x60\x62\x62\x60" + 0xA471EC43).s, 3, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_skin*/XorStr<0xED, 10, 0x3DF4941B>("\x9B\x87\x8A\x87\xAE\x81\x98\x9D\x9B" + 0x3DF4941B).s, HANDS77, index, /*v_shield_deagle*/XorStr<0x87, 16, 0x93EEC40A>("\xF1\xD7\xFA\xE2\xE2\xE9\xE1\xEA\xD0\xF4\xF4\xF3\xF4\xF8\xF0" + 0x93EEC40A).s, 2, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_skin*/XorStr<0xF0, 10, 0x4F1F6087>("\x86\x98\x97\x84\xAB\x86\x9D\x9E\x96" + 0x4F1F6087).s, HANDS77, index, /*v_shield_fiveseven*/XorStr<0x2B, 19, 0x1F789712>("\x5D\x73\x5E\x46\x46\x55\x5D\x56\x6C\x52\x5C\x40\x52\x4B\x5C\x4C\x5E\x52" + 0x1F789712).s, 2, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_skin*/XorStr<0x0D, 10, 0x41CA6A46>("\x7B\x67\x6A\x67\x4E\x61\x78\x7D\x7B" + 0x41CA6A46).s, HANDS77, index, /*v_shield_flashbang*/XorStr<0x9F, 19, 0x730FDBA4>("\xE9\xFF\xD2\xCA\xCA\xC1\xC9\xC2\xF8\xCE\xC5\xCB\xD8\xC4\xCF\xCF\xC1\xD7" + 0x730FDBA4).s, 2, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_skin*/XorStr<0x62, 10, 0x8DB09E54>("\x14\x0A\x01\x12\x39\x14\x03\x00\x04" + 0x8DB09E54).s, HANDS77, index, /*v_shield_glock18*/XorStr<0xAD, 17, 0x875E4AE2>("\xDB\xF1\xDC\xD8\xD8\xD7\xDF\xD0\xEA\xD1\xDB\xD7\xDA\xD1\x8A\x84" + 0x875E4AE2).s, 2, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_skin*/XorStr<0xF8, 10, 0x936EE1EA>("\x8E\x90\x9F\x8C\xA3\x8E\x95\x96\x6E" + 0x936EE1EA).s, HANDS77, index, /*v_shield_hegrenade*/XorStr<0x67, 19, 0x233DD680>("\x11\x37\x1A\x02\x02\x09\x01\x0A\x30\x18\x14\x15\x01\x11\x1B\x17\x13\x1D" + 0x233DD680).s, 2, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_skin*/XorStr<0x76, 10, 0x875F82FD>("\x00\x1E\x1D\x0E\x25\x08\x17\x14\x10" + 0x875F82FD).s, HANDS77, index, /*v_shield_knife*/XorStr<0x11, 15, 0x0BDDD918>("\x67\x4D\x60\x7C\x7C\x73\x7B\x7C\x46\x71\x75\x75\x7B\x7B" + 0x0BDDD918).s, 2, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_skin*/XorStr<0xF0, 10, 0x1BB7B8C6>("\x86\x98\x97\x84\xAB\x86\x9D\x9E\x96" + 0x1BB7B8C6).s, HANDS77, index, /*v_shield_p228*/XorStr<0xB1, 14, 0xBA470A91>("\xC7\xED\xC0\xDC\xDC\xD3\xDB\xDC\xE6\xCA\x89\x8E\x85" + 0xBA470A91).s, 2, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_skin*/XorStr<0x1E, 10, 0x4D147102>("\x68\x76\x45\x56\x7D\x50\x4F\x4C\x48" + 0x4D147102).s, HANDS77, index, /*v_shield_smokegrenade*/XorStr<0x9D, 22, 0xBB809636>("\xEB\xC1\xEC\xC8\xC8\xC7\xCF\xC0\xFA\xD5\xCA\xC7\xC2\xCF\xCC\xDE\xC8\xC0\xCE\xD4\xD4" + 0xBB809636).s, 2, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*view_skin*/XorStr<0xD3, 10, 0xC291C179>("\xA5\xBD\xB0\xA1\x88\xAB\xB2\xB3\xB5" + 0xC291C179).s, HANDS77, index, /*v_shield_usp*/XorStr<0xA3, 13, 0x7F20B0FB>("\xD5\xFB\xD6\xCE\xCE\xCD\xC5\xCE\xF4\xD9\xDE\xDE" + 0x7F20B0FB).s, 2, cvar.visual_skins_viewmodel_hands), index++;
	ReplaceTextureIndex(/*rifle_goldshell*/XorStr<0xAD, 16, 0x219FAB8F>("\xDF\xC7\xC9\xDC\xD4\xED\xD4\xDB\xD9\xD2\xC4\xD0\xDC\xD6\xD7" + 0x219FAB8F).s, SHELL1, index, /*rshell*/XorStr<0xAC, 7, 0x71342647>("\xDE\xDE\xC6\xCA\xDC\xDD" + 0x71342647).s, 3, cvar.visual_skins_bullet_shell), index++;
	ReplaceTextureIndex(/*pistol_goldshell*/XorStr<0x3B, 17, 0x28D7235B>("\x4B\x55\x4E\x4A\x50\x2C\x1E\x25\x2C\x28\x21\x35\x2F\x2D\x25\x26" + 0x28D7235B).s, SHELL2, index, /*pshell*/XorStr<0x14, 7, 0xCF50B494>("\x64\x66\x7E\x72\x74\x75" + 0xCF50B494).s, 3, cvar.visual_skins_bullet_shell), index++;
	ReplaceTextureIndex(/*shell*/XorStr<0x2A, 6, 0x9719895C>("\x59\x43\x49\x41\x42" + 0x9719895C).s, SHELL3, index, /*shotgunshell*/XorStr<0x0C, 13, 0xB26BBE58>("\x7F\x65\x61\x7B\x77\x64\x7C\x60\x7C\x70\x7A\x7B" + 0xB26BBE58).s, 3, cvar.visual_skins_bullet_shell), index++;
	ReplaceTextureIndex(/*rifle_goldshell*/XorStr<0x2C, 16, 0xCF0A0E73>("\x5E\x44\x48\x43\x55\x6E\x55\x5C\x58\x51\x45\x5F\x5D\x55\x56" + 0xCF0A0E73).s, SHELL1, index, /*rshell_big*/XorStr<0x7E, 11, 0x5AD5006F>("\x0C\x0C\xE8\xE4\xEE\xEF\xDB\xE7\xEF\xE0" + 0x5AD5006F).s, 3, cvar.visual_skins_bullet_shell), index++;
}
```

`sakura/source/features/visuals/local/skins/skins.h`:

```h
#ifndef _SKINS_
#define _SKINS_

extern bool loadtexturemodel;
extern char sServerName[256];
void SetSkins();
void GetTextureModel();

#endif
```

`sakura/source/features/visuals/local/skins/viewmodel.cpp`:

```cpp
#include "../../../../client.h"

void ViewModelFov(ref_params_s* pparams)
{
	if (Sakura::ScreenShot::IsVisuals())
	{
		if (g_Local.ViewModel)
		{
			Vector forward = pparams->forward;
			g_Local.ViewModel->origin += forward * cvar.visual_viewmodel_fov;
		}
	}
}
```

`sakura/source/features/visuals/local/skins/viewmodel.h`:

```h
#ifndef _VIEWMODEL_
#define _VIEWMODEL_

void ViewModelFov(ref_params_s* pparams);

#endif
```

`sakura/source/features/visuals/local/thirdperson.cpp`:

```cpp
#include "../../../client.h"

void Sakura::Thirdperson::Logic(ref_params_s* pparams)
{
	if (!cvar.visual_chase_cam)
		return;

	if (!Sakura::ScreenShot::IsVisuals())
		return;

	if (!Sakura::Player::Local::IsAlive())
		return;

	Vector r, u, b;
	Vector tracestart = pparams->vieworg;
	VectorMul(pparams->right, 0, r);
	VectorMul(pparams->up, cvar.visual_chase_up, u);
	VectorMul(pparams->forward, -cvar.visual_chase_back, b);
	VectorCopy(tracestart + r + u + b, pparams->vieworg);

	pmtrace_t trace;
	g_Engine.pEventAPI->EV_SetTraceHull(2);
	g_Engine.pEventAPI->EV_PlayerTrace(tracestart, tracestart + r + u + b, PM_TRACELINE_PHYSENTSONLY, -1, &trace);
	
	if (trace.fraction != 1.0f)
		VectorCopy(trace.endpos, pparams->vieworg);
}
```

`sakura/source/features/visuals/local/thirdperson.h`:

```h
#ifndef _THIRDP_
#define _THIRDP_

namespace Sakura
{
	namespace Thirdperson
	{
		void Logic(ref_params_s* pparams);
	};
};

#endif
```

`sakura/source/features/visuals/local/tracegrenade.cpp`:

```cpp
#include "../../../client.h"

void DrawTraceGrenade()
{
	if (cvar.visual_grenade_trajectory && IsCurWeaponNade() && Sakura::Player::Local::IsAlive())
	{
		Vector vecForward, vecStart, vecEnd;
		pmtrace_t pmtrace;

		float flGravity = pmove->movevars->gravity / SVGRAVITY;

		Vector vecAngles;
		g_Engine.GetViewAngles(vecAngles);
		if (vecAngles[0] < 0)
			vecAngles[0] = -10 + vecAngles[0] * ((90.f - 10.f) / 90.0f);
		else
			vecAngles[0] = -10 + vecAngles[0] * ((90.f + 10.f) / 90.0f);

		float flVel = (90 - vecAngles[0]) * 4;
		if (flVel > 500)
			flVel = 500;

		g_Engine.pfnAngleVectors(vecAngles, vecForward, NULL, NULL);
		vecStart = pmove->origin + pmove->view_ofs + vecForward * 16;
		vecForward = (vecForward * flVel) + pmove->velocity;

		int iCollisions = 0;
		float flTimeAlive;
		float flStep = (3.00f / 50.0f);

		ImRGBA grenadeLineColor = Sakura::Colors::GetCustomizedColor(cvar.visual_grenade_trajectory_line_color, cvar.rainbow_grenade_trajectory_line);
		ImRGBA grenadePointColor = Sakura::Colors::GetCustomizedColor(cvar.visual_grenade_trajectory_point_color, cvar.rainbow_grenade_trajectory_point);

		for (flTimeAlive = 0; flTimeAlive < 3.00f; flTimeAlive += flStep)
		{
			vecEnd = vecStart + vecForward * flStep;

			g_Engine.pEventAPI->EV_SetTraceHull(2);
			g_Engine.pEventAPI->EV_PlayerTrace(vecStart, vecEnd, PM_STUDIO_BOX, -1, &pmtrace);

			if (pmtrace.ent != pmove->player_index + 1 && pmtrace.fraction < 1.0)
			{
				vecEnd = vecStart + vecForward * pmtrace.fraction * flStep;

				if (pmtrace.plane.normal[2] > 0.9 && vecForward[2] <= 0 && vecForward[2] >= (-1 * flGravity * 0.20f))
					return;

				float flProj = vecForward.Dot(pmtrace.plane.normal);

				vecForward = (vecForward * 1.75f - flProj * 2 * pmtrace.plane.normal) * 0.75f;

				iCollisions++;

				if (iCollisions > 30)
					break;

				flTimeAlive -= (flStep * (1 - pmtrace.fraction));
			}

			float VecScreenMin[2], VecScreenMax[2];

			if (cvar.visual_tg_type >= 0)
			{
				if (WorldToScreen(vecStart, VecScreenMin) && WorldToScreen(vecEnd, VecScreenMax))
					ImGui::GetCurrentWindow()->DrawList->AddLine({ IM_ROUND(VecScreenMin[0]), IM_ROUND(VecScreenMin[1]) }, { IM_ROUND(VecScreenMax[0]), IM_ROUND(VecScreenMax[1]) }, ImColor(grenadeLineColor.r, grenadeLineColor.g, grenadeLineColor.b, grenadeLineColor.a));

				if (cvar.visual_tg_type == 1)
				{
					if (WorldToScreen(vecEnd, VecScreenMax))
						ImGui::GetCurrentWindow()->DrawList->AddRectFilled({ IM_ROUND(VecScreenMax[0]) - 1, IM_ROUND(VecScreenMax[1]) - 1 }, { IM_ROUND(VecScreenMax[0]) + 2, IM_ROUND(VecScreenMax[1]) + 2 }, ImColor(grenadePointColor.r, grenadePointColor.g, grenadePointColor.b, grenadePointColor.a));
				}
			}

			vecStart = vecEnd;
			vecForward[2] -= flGravity * pmtrace.fraction * flStep;
		}
	}
}
```

`sakura/source/features/visuals/local/tracegrenade.h`:

```h
#ifndef _TRACEGRENADE_
#define _TRACEGRENADE_

void DrawTraceGrenade();

#endif
```

`sakura/source/features/visuals/local/world/bullettrace.cpp`:

```cpp
#include "../../../../client.h"

int localLastAmmo;

void BulletTrace::Local(struct usercmd_s* cmd)
{
	if (!cvar.visual_bullet_trace_local)
		return;

	if (!Sakura::ScreenShot::IsVisuals())
		return;

	int g_iShotsFired = g_Local.weapon.m_iShotsFired;

	if (g_iShotsFired > localLastAmmo || CanAttack() && !IsFreezePeriod() && cmd->buttons & IN_ATTACK && IsCurWeaponSniper())
	{
		Vector vForward;
		Vector vAngle = cmd->viewangles;
		Vector vEye = pmove->origin + pmove->view_ofs;

		g_Engine.pfnAngleVectors(vAngle, vForward, NULL, NULL);

		int beamindex = g_Engine.pEventAPI->EV_FindModelIndex("sprites/laserbeam.spr");
		pmtrace_t tr;

		g_Engine.pEventAPI->EV_SetTraceHull(2);

		Vector vEnd = vEye + vForward * 8192;

		g_Engine.pEventAPI->EV_PlayerTrace(vEye, vEnd, PM_GLASS_IGNORE, -1, &tr);
		g_Engine.pEfxAPI->R_BeamPoints(vEye, tr.endpos, beamindex, cvar.visual_bullet_trace_local_liveness, cvar.visual_bullet_trace_local_thickness, 0, cvar.visual_bullet_trace_local_color[3], 2, 0, 0, cvar.visual_bullet_trace_local_color[0], cvar.visual_bullet_trace_local_color[1], cvar.visual_bullet_trace_local_color[2]);
	}

	if (g_iShotsFired > 600)
		g_iShotsFired = 1;

	localLastAmmo = g_iShotsFired;
}

void BulletTrace::Enemy(struct cl_entity_s* ent)
{
	if (cvar.visual_bullet_trace || cvar.visual_line_of_sight)
	{
		int beamindex = g_Engine.pEventAPI->EV_FindModelIndex("sprites/laserbeam.spr");

		Vector vecStart, vecEnd, vecEnd2, vecForward;

		pmtrace_t tr;
		pmtrace_t tr2;

		// angles, forward, right, up
		g_Engine.pfnAngleVectors(ent->angles, vecForward, NULL, NULL);
		vecForward.z = -vecForward.z;

		vecStart = g_Player[ent->index].vEye;
		vecEnd = vecStart + vecForward * 8192;
		vecEnd2 = vecStart + vecForward * cvar.visual_line_of_sight_distance;

		g_Engine.pEventAPI->EV_SetTraceHull(2);
		g_Engine.pEventAPI->EV_PlayerTrace(vecStart, vecEnd, PM_GLASS_IGNORE, -1, &tr);
		g_Engine.pEventAPI->EV_PlayerTrace(vecStart, vecEnd2, PM_GLASS_IGNORE, -1, &tr2);

		if (cvar.visual_line_of_sight)
		{
			g_Engine.pEfxAPI->R_BeamPoints(vecStart, tr2.endpos, beamindex, 0.001f, 0.9f, 0, 32, 2, 0, 0, cvar.visual_line_of_sight_color[0], cvar.visual_line_of_sight_color[1], cvar.visual_line_of_sight_color[2]);
		}

		if (cvar.visual_bullet_trace)
		{
			int seq = Cstrike_SequenceInfo[ent->curstate.sequence];

			if (seq == SEQUENCE_SHOOT)
			{
				ImRGBA playerBeamColor = Sakura::Colors::GetTeamColor(ent->index);

				g_Engine.pEfxAPI->R_BeamPoints(vecStart, tr.endpos, beamindex, 0.001f, 0.9f, 0, 32, 2, 0, 0, playerBeamColor.r, playerBeamColor.g, playerBeamColor.b);
			}
		}
	}
}
```

`sakura/source/features/visuals/local/world/bullettrace.h`:

```h
#pragma once

namespace BulletTrace
{
	void Local(struct usercmd_s* cmd);
	void Enemy(struct cl_entity_s* ent);
};
```

`sakura/source/features/visuals/local/world/deathmark.cpp`:

```cpp
#include "../../../../client.h"

DWORD DM_CreationTime[33];
int DM_stayInSeconds[33];
bool DM_Once[33];

void DeathMark::Create(cl_entity_s* ent)
{
	if (!DM_Once[ent->index])
	{
		DM_Once[ent->index] = true;
		DM_stayInSeconds[ent->index] = cvar.visual_deathmark_seconds * 1000;
		DM_CreationTime[ent->index] = GetTickCount();
		g_Player[ent->index].playerDeathMark[0] = *ent;
		g_Player[ent->index].playerDeathMark[0].trivial_accept = 777;
		g_Player[ent->index].playerDeathMark[0].curstate.animtime = FLT_MAX;
		g_Player[ent->index].playerDeathMark[0].curstate.weaponmodel = 0;
		g_Player[ent->index].playerDeathMark[0].origin = ent->curstate.origin;
		g_Player[ent->index].playerDeathMark[0].angles = ent->curstate.angles;

		g_Player[ent->index].playerDeathMark[1] = *ent;
		g_Player[ent->index].playerDeathMark[1].trivial_accept = 777;
		g_Player[ent->index].playerDeathMark[1].curstate.animtime = FLT_MAX;
		g_Player[ent->index].playerDeathMark[1].curstate.weaponmodel = 0;
		g_Player[ent->index].playerDeathMark[1].origin = ent->curstate.origin;
		g_Player[ent->index].playerDeathMark[1].angles = ent->curstate.angles;
	}

	if (GetTickCount() - DM_CreationTime[ent->index] > DM_stayInSeconds[ent->index])
	{
		g_Player[ent->index].deathMark = false;
		DM_Once[ent->index] = false;
		return;
	}

	if (cvar.visual_deathmark_glow)
	{
		g_Player[ent->index].playerDeathMark[0].curstate.rendermode = kRenderTransAlpha;
		g_Player[ent->index].playerDeathMark[0].curstate.renderamt = 1;
		g_Player[ent->index].playerDeathMark[0].curstate.renderfx = kRenderFxGlowShell;

		ImRGBA deathmarkColor = Sakura::Colors::GetCustomizedColor(cvar.visual_deathmark_color, cvar.rainbow_deathmark_glow);

		g_Player[ent->index].playerDeathMark[0].curstate.rendercolor.r = deathmarkColor.r * 255;
		g_Player[ent->index].playerDeathMark[0].curstate.rendercolor.g = deathmarkColor.g * 255;
		g_Player[ent->index].playerDeathMark[0].curstate.rendercolor.b = deathmarkColor.b * 255;

		g_Engine.CL_CreateVisibleEntity(ET_PLAYER, &g_Player[ent->index].playerDeathMark[0]);
	}

	g_Player[ent->index].playerDeathMark[1].curstate.rendermode = kRenderTransAdd;
	g_Player[ent->index].playerDeathMark[1].curstate.renderamt = cvar.visual_deathmark_transparency;

	g_Engine.CL_CreateVisibleEntity(ET_PLAYER, &g_Player[ent->index].playerDeathMark[1]);
}
```

`sakura/source/features/visuals/local/world/deathmark.h`:

```h
#pragma once

extern bool DM_Once[33];

namespace DeathMark
{
	void Create(cl_entity_s* ent);
}
```

`sakura/source/features/visuals/local/world/fog.cpp`:

```cpp
#include "../../../../client.h"

void Sakura::Fog::Draw()
{
	if (!cvar.visual_fog)
		return;
	
	if (!Sakura::ScreenShot::IsVisuals())
		return;

	GLfloat glColor[] = { cvar.visual_fog_color[0], cvar.visual_fog_color[1], cvar.visual_fog_color[2], cvar.visual_fog_color[3] };
	glEnable(GL_FOG);
	glFogi(GL_FOG_MODE, GL_EXP);
	glFogf(GL_FOG_DENSITY, cvar.visual_fog_density / 10000.f);
	glFogfv(GL_FOG_COLOR, glColor);
}
```

`sakura/source/features/visuals/local/world/fog.h`:

```h
#pragma once

namespace Sakura
{
	namespace Fog
	{
		void Draw();
	};
};

void DrawFog();
```

`sakura/source/features/visuals/local/world/lightmap.cpp`:

```cpp
#include "../../../../client.h"

bool Sakura::Map::mapLighted = false;

void Sakura::Map::Light()
{
	if (!cvar.visual_lightmap)
	{
		if (Sakura::Map::mapLighted)
		{
			Sakura::Map::mapLighted = false;
			g_Engine.pfnSetFilterMode(0);
		}

		return;
	}

	if (!Sakura::ScreenShot::IsVisuals())
	{
		if (Sakura::Map::mapLighted)
		{
			Sakura::Map::mapLighted = false;
			g_Engine.pfnSetFilterMode(0);
		}

		return;
	}

	if (Sakura::Map::mapLighted)
	{
		if (cvar.rainbow_world_maplight)
		{
			g_Engine.pfnSetFilterColor(color_red, color_blue, color_green);
		}

		return;
	}

	g_Engine.pfnSetFilterMode(1);
	g_Engine.pfnSetFilterColor(cvar.visual_lightmap_color[0], cvar.visual_lightmap_color[1], cvar.visual_lightmap_color[2]);
	g_Engine.pfnSetFilterBrightness(1);
	Sakura::Map::mapLighted = true;
}
```

`sakura/source/features/visuals/local/world/lightmap.h`:

```h
#ifndef _LIGHTMAP_
#define _LIGHTMAP_

namespace Sakura
{
	namespace Map
	{
		extern bool mapLighted;
		void Light();
	};
};

extern bool runonce;
void Lightmap();

#endif
```

`sakura/source/features/visuals/local/world/sky.cpp`:

```cpp
#include "../../../../client.h"

int Sakura::Sky::skyTextureIndex[6];
bool Sakura::Sky::skyTextureLoaded = false;
bool Sakura::Sky::skyChange = true;

void Sakura::Sky::RemoveTexture()
{
	int* gSkyTexNumber = c_Offset.FindSkyTexNumber();
	for (unsigned int i = 0; i < 6; i++)
	{
		gSkyTexNumber[i] = Sakura::Sky::skyTextureIndex[i];
		Sakura::Sky::skyTextureIndex[i] = 0;
	}
}

void Sakura::Sky::ChangeTexture()
{
	if (!cvar.visual_sky || !Sakura::ScreenShot::IsVisuals())
	{
		if (Sakura::Sky::skyChange)
		{
			Sakura::Sky::RemoveTexture();
			Sakura::Sky::skyChange = false;
		}

		return;
	}

	if (!Sakura::Sky::skyTextureLoaded)
	{
		Sakura::Texture::Load(/*assets/skins/sky/rt.bmp*/XorStr<0x6B, 24, 0x100AA87A>("\x0A\x1F\x1E\x0B\x1B\x03\x5E\x01\x18\x1D\x1B\x05\x58\x0B\x12\x03\x54\x0E\x09\x50\x1D\xED\xF1" + 0x100AA87A).s, 20);
		Sakura::Texture::Load(/*assets/skins/sky/bk.bmp*/XorStr<0xF5, 24, 0xA7C60229>("\x94\x85\x84\x9D\x8D\x89\xD4\x8F\x96\x97\x91\x73\x2E\x71\x68\x7D\x2A\x64\x6C\x26\x6B\x67\x7B" + 0xA7C60229).s, 21);
		Sakura::Texture::Load(/*assets/skins/sky/lf.bmp*/XorStr<0x66, 24, 0x2E3EE73C>("\x07\x14\x1B\x0C\x1E\x18\x43\x1E\x05\x06\x1E\x02\x5D\x00\x1F\x0C\x59\x1B\x1E\x57\x18\x16\x0C" + 0x2E3EE73C).s, 22);
		Sakura::Texture::Load(/*assets/skins/sky/ft.bmp*/XorStr<0x3F, 24, 0x8573E007>("\x5E\x33\x32\x27\x37\x37\x6A\x35\x2C\x21\x27\x39\x64\x3F\x26\x37\x60\x36\x25\x7C\x31\x39\x25" + 0x8573E007).s, 23);
		Sakura::Texture::Load(/*assets/skins/sky/up.bmp*/XorStr<0x94, 24, 0xEA4CFD2D>("\xF5\xE6\xE5\xF2\xEC\xEA\xB5\xE8\xF7\xF4\xF0\xEC\x8F\xD2\xC9\xDA\x8B\xD0\xD6\x89\xCA\xC4\xDA" + 0xEA4CFD2D).s, 24);
		Sakura::Texture::Load(/*assets/skins/sky/dn.bmp*/XorStr<0x02, 24, 0x3BB73BF2>("\x63\x70\x77\x60\x72\x74\x27\x7A\x61\x62\x62\x7E\x21\x7C\x7B\x68\x3D\x77\x7A\x3B\x74\x7A\x68" + 0x3BB73BF2).s, 25);

		Sakura::Sky::skyTextureLoaded = true;
	}

	if (!Sakura::Sky::skyChange)
	{
		int* gSkyTexNumber = c_Offset.FindSkyTexNumber();
		for (unsigned int i = 0; i < 6; i++)
		{
			if (!skyTextureIndex[i])
			{
				skyTextureIndex[i] = gSkyTexNumber[i];
				gSkyTexNumber[i] = Sakura::Texture::texture_id[i + 20];
			}
			else if (!Sakura::Sky::skyTextureLoaded)
				gSkyTexNumber[i] = Sakura::Texture::texture_id[i + 20];
		}

		Sakura::Sky::skyChange = true;
	}
}
```

`sakura/source/features/visuals/local/world/sky.h`:

```h
#ifndef _SKY_
#define _SKY_

namespace Sakura
{
	namespace Sky
	{
		extern int skyTextureIndex[6];
		extern bool skyTextureLoaded;
		extern bool skyChange;
		void ChangeTexture();
		void RemoveTexture();
	}
};

//extern bool loadtexturesky;
//void Sky();

#endif
```

`sakura/source/features/visuals/menu/menu.cpp`:

```cpp
#include "../../../client.h"

int Sakura::Menu::currentAlphaFade;
int Sakura::Menu::itemWidth = 245;
int tab = 0;
int ragebottab = 0, legitbottab = 0, visualstab = 0, misctab = 0, colorstab = 0;
int selectedScriptIndex = 0;

bool bShowMenu = false;
bool keysmenu[256];
bool changewindowfocus = true;
bool snowflakesFirst = false;
bool rainFirst = false;

ImFont* Sakura::Menu::Fonts::defaultFont = nullptr;
ImFont* Sakura::Menu::Fonts::icons = nullptr;
ImFont* Sakura::Menu::Fonts::titleTabFont = nullptr;
ImFont* Sakura::Menu::Fonts::titleCheatFont = nullptr;
ImFont* Sakura::Menu::Fonts::weaponsFont = nullptr;

char nickname[32];
char chatspam[128];

constexpr int MAX_RANDOM_TEXTS = 15;
int perviousTextIndex = -1;
char text[64];

ImColor Sakura::Menu::GetMenuColor(float alpha)
{
	if (cvar.rainbow_menu)
		return ImColor(color_blue, color_green, color_red, alpha);

	return ImColor(cvar.visual_menu_color[0], cvar.visual_menu_color[1], cvar.visual_menu_color[2], alpha);
}

const char* getRandomText()
{
	if (perviousTextIndex >= 0)
		return text;

	perviousTextIndex = rand() % MAX_RANDOM_TEXTS;

	switch (perviousTextIndex)
	{
	case 0: sprintf(text, /*What's up?*/XorStr<0xF9, 11, 0x1C441265>("\xAE\x92\x9A\x88\xDA\x8D\xDF\x75\x71\x3D" + 0x1C441265).s); break;
	case 1: sprintf(text, /*Nice one!*/XorStr<0xB9, 10, 0x3FB9EF51>("\xF7\xD3\xD8\xD9\x9D\xD1\xD1\xA5\xE0" + 0x3FB9EF51).s); break;
	case 2: sprintf(text, /*Error found.*/XorStr<0x55, 13, 0x13CCD2CC>("\x10\x24\x25\x37\x2B\x7A\x3D\x33\x28\x30\x3B\x4E" + 0x13CCD2CC).s); break;
	case 3: sprintf(text, /*Feeling down :(*/XorStr<0xE9, 16, 0x6B37C31B>("\xAF\x8F\x8E\x80\x84\x80\x88\xD0\x95\x9D\x84\x9A\xD5\xCC\xDF" + 0x6B37C31B).s); break;
	case 4: sprintf(text, /*Looking back is a good idea.*/XorStr<0x35, 29, 0xAB321096>("\x79\x59\x58\x53\x50\x54\x5C\x1C\x5F\x5F\x5C\x2B\x61\x2B\x30\x64\x24\x66\x20\x27\x26\x2E\x6B\x25\x29\x2B\x2E\x7E" + 0xAB321096).s); break;
	case 5: sprintf(text, /*That was a mistake.*/XorStr<0x47, 20, 0x833FB605>("\x13\x20\x28\x3E\x6B\x3B\x2C\x3D\x6F\x31\x71\x3F\x3A\x27\x21\x37\x3C\x3D\x77" + 0x833FB605).s); break;
	case 6: sprintf(text, /*Feeling lucky?*/XorStr<0x8A, 15, 0x2FFEDC26>("\xCC\xEE\xE9\xE1\xE7\xE1\xF7\xB1\xFE\xE6\xF7\xFE\xEF\xA8" + 0x2FFEDC26).s); break;
	case 7: sprintf(text, /*Keep it up!*/XorStr<0xA2, 12, 0x0B619C17>("\xE9\xC6\xC1\xD5\x86\xCE\xDC\x89\xDF\xDB\x8D" + 0x0B619C17).s); break;
	case 8: sprintf(text, /*Success awaits.*/XorStr<0x24, 16, 0x045E8347>("\x77\x50\x45\x44\x4D\x5A\x59\x0B\x4D\x5A\x4F\x46\x44\x42\x1C" + 0x045E8347).s); break;
	case 9: sprintf(text, /*Welcome back!*/XorStr<0x54, 14, 0xECB000A6>("\x03\x30\x3A\x34\x37\x34\x3F\x7B\x3E\x3C\x3D\x34\x41" + 0xECB000A6).s); break;
	case 10: sprintf(text, /*Sending love <3*/XorStr<0xAE, 16, 0x22DF9EAE>("\xFD\xCA\xDE\xD5\xDB\xDD\xD3\x95\xDA\xD8\xCE\xDC\x9A\x87\x8F" + 0x22DF9EAE).s); break;
	case 11: sprintf(text, /*Backtracking is key.*/XorStr<0xE3, 21, 0xD56E4389>("\xA1\x85\x86\x8D\x93\x9A\x88\x89\x80\x85\x83\x89\xCF\x99\x82\xD2\x98\x91\x8C\xD8" + 0xD56E4389).s); break;
	case 12: sprintf(text, /*Config updated.*/XorStr<0xF1, 16, 0x146A8965>("\xB2\x9D\x9D\x92\x9C\x91\xD7\x8D\x89\x9E\x9A\x88\x98\x9A\xD1" + 0x146A8965).s); break;
	case 13: sprintf(text, /*Ready to roll?*/XorStr<0x6D, 15, 0x29556B48>("\x3F\x0B\x0E\x14\x08\x52\x07\x1B\x55\x04\x18\x14\x15\x45" + 0x29556B48).s); break;
	case 14: sprintf(text, /*So intriguing!*/XorStr<0x18, 15, 0x8790E5AB>("\x4B\x76\x3A\x72\x72\x69\x6C\x76\x47\x54\x4B\x4D\x43\x04" + 0x8790E5AB).s); break;
	case 15: sprintf(text, /*Hilarious!*/XorStr<0x21, 11, 0xB4B8BD11>("\x69\x4B\x4F\x45\x57\x4F\x48\x5D\x5A\x0B" + 0xB4B8BD11).s); break;
	}

	return text;
}

char* KeyEventChar(int Key)
{
	switch (Key)
	{
	case K_TAB: return "Tab";
	case K_ENTER: return "Enter";
	case K_ESCAPE: return "Escape";
	case K_SPACE: return "Space";
	case K_0: return "0";
	case K_1: return "1";
	case K_2: return "2";
	case K_3: return "3";
	case K_4: return "4";
	case K_5: return "5";
	case K_6: return "6";
	case K_7: return "7";
	case K_8: return "8";
	case K_9: return "9";
	case K_A: return "A";
	case K_B: return "B";
	case K_C: return "C";
	case K_D: return "D";
	case K_E: return "E";
	case K_F: return "F";
	case K_G: return "G";
	case K_H: return "H";
	case K_I: return "I";
	case K_J: return "J";
	case K_K: return "K";
	case K_L: return "L";
	case K_M: return "M";
	case K_N: return "N";
	case K_O: return "O";
	case K_P: return "P";
	case K_Q: return "Q";
	case K_R: return "R";
	case K_S: return "S";
	case K_T: return "T";
	case K_U: return "U";
	case K_V: return "V";
	case K_W: return "W";
	case K_X: return "X";
	case K_Y: return "Y";
	case K_Z: return "Z";
	case K_BACKSPACE: return "Backspace";
	case K_UPARROW: return "Up Arrow";
	case K_DOWNARROW: return "Down Arrow";
	case K_LEFTARROW: return "Left Arrow";
	case K_RIGHTARROW: return "Right Arrow";
	case K_ALT: return "Alt";
	case K_CTRL: return "Ctrl";
	case K_SHIFT: return "Shift";
	case K_F1: return "F1";
	case K_F2: return "F2";
	case K_F3: return "F3";
	case K_F4: return "F4";
	case K_F5: return "F5";
	case K_F6: return "F6";
	case K_F7: return "F7";
	case K_F8: return "F8";
	case K_F9: return "F9";
	case K_F10: return "F10";
	case K_F11: return "F11";
	case K_F12: return "F12";
	case K_INS: return "Insert";
	case K_DEL: return "Delete";
	case K_PGDN: return "Page Down";
	case K_PGUP: return "Page Up";
	case K_HOME: return "Home";
	case K_END: return "End";
	case K_CAPSLOCK: return "Capslock";
	case K_MWHEELDOWN: return "Wheel Down";
	case K_MWHEELUP: return "Wheel Up";
	case K_MOUSE1: return "Mouse 1";
	case K_MOUSE2: return "Mouse 2";
	case K_MOUSE3: return "Mouse 3";
	case K_MOUSE4: return "Mouse 4";
	case K_MOUSE5: return "Mouse 5";
	}
	return "Unknown Ok";
}
	
void Sakura::Menu::HudKeyBind(float& key, const char* keyname, ImVec2 size, bool old)
{
	char str[256];
	char buttonText[256];
	ImVec4 buttonColor = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);

	if (key == -2)
	{
		for (size_t i = 0; i < 255; ++i)
		{
			if (keysmenu[i])
			{
				if (i == K_ESCAPE || i == cvar.gui_key)
				{
					key = -1;
					break;
				}
				key = i;
			}
		}
	}

	if (key == -1)
	{
		sprintf(buttonText, /*No key*/XorStr<0xEE, 7, 0x92F31899>("\xA0\x80\xD0\x9A\x97\x8A" + 0x92F31899).s);
		buttonColor = ImVec4(1.0f, 0.3f, 0.3f, 1.0f);
	}
	else if (key == -2)
	{
		sprintf(buttonText, /*Press key*/XorStr<0xE7, 10, 0x8231A863>("\xB7\x9A\x8C\x99\x98\xCC\x86\x8B\x96" + 0x8231A863).s);
		buttonColor = ImVec4(1.0f, 1.0f, 0.3f, 1.0f);
	}
	else
	{
		sprintf(buttonText, /*%s*/XorStr<0xB6, 3, 0x1E897BEB>("\x93\xC4" + 0x1E897BEB).s, KeyEventChar(key));
		buttonColor = ImVec4(0.3f, 1.0f, 0.3f, 1.0f);
	}

	ImGui::Text(keyname);
	ImGui::PushStyleColor(ImGuiCol_Text, buttonColor);
	sprintf(str, /*[%s]##%s*/XorStr<0x40, 9, 0xC020EFB0>("\x1B\x64\x31\x1E\x67\x66\x63\x34" + 0xC020EFB0).s, buttonText, keyname);

	if (old)
	{
		if (ImGui::Button(str, size))
		{
			if (key == -1)
				key = -2;
			else
				key = -1;
		}
	}
	else
	{
		if (Sakura::Menu::Widgets::Button(str, size))
		{
			if (key == -1)
				key = -2;
			else
				key = -1;
		}
	}

	ImGui::PopStyleColor();
}

void Sakura::Menu::HudMenuBind(float& key)
{
	bool clicked = false;
	static float restorekey;
	if (key != -1)
		restorekey = key;
	if (key == -1)
	{
		for (size_t i = 0; i < 255; ++i)
		{
			if (keysmenu[i])
			{
				if (i == K_MOUSE1 || i == K_ESCAPE) break;
				key = i;
			}
		}
	}
	
	if (key == -1)
	{
		ImGui::Text(/*Menu Key*/XorStr<0x56, 9, 0x2215152F>("\x1B\x32\x36\x2C\x7A\x10\x39\x24" + 0x2215152F).s);
		ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(1.0f, 1.0f, 0.3f, 1.0f));
		if(Sakura::Menu::Widgets::Button(/*[Press key]*/XorStr<0xF2, 12, 0x42CD80D7>("\xA9\xA3\x86\x90\x85\x84\xD8\x92\x9F\x82\xA1" + 0x42CD80D7).s, ImVec2(ImGui::GetWindowSize().x - 6, 0)))
			clicked = true;
		ImGui::PopStyleColor();
	}
	else
	{
		ImGui::Text(/*Menu Key*/XorStr<0xE3, 9, 0x08372CD0>("\xAE\x81\x8B\x93\xC7\xA3\x8C\x93" + 0x08372CD0).s);
		ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.4f, 1.0f, 0.4f, 1.0f));
		char str[256];
		sprintf(str, /*[%s]*/XorStr<0x4A, 5, 0x7D8BC00E>("\x11\x6E\x3F\x10" + 0x7D8BC00E).s, KeyEventChar(key));
		if (Sakura::Menu::Widgets::Button(str, ImVec2(ImGui::GetWindowSize().x - 6, 0)))
			clicked = true;
		ImGui::PopStyleColor();
	}

	if (clicked)
	{
		if (key == -1)
			key = restorekey;
		else
			key = -1;
	}
}

int Sakura::Menu::CheckWeapon(float global, float sub)
{
	if (global == 0 && (sub == 0 || sub == 1 || sub == 2 || sub == 3 || sub == 4 || sub == 5))
	{
		if (sub == 0) return WEAPON_GLOCK18;
		if (sub == 1) return WEAPON_P228;
		if (sub == 2) return WEAPON_DEAGLE;
		if (sub == 3) return WEAPON_ELITE;
		if (sub == 4) return WEAPON_FIVESEVEN;
		if (sub == 5) return WEAPON_USP;
	}
	else if (global == 1 && (sub == 0 || sub == 1 || sub == 2 || sub == 3))
	{
		if (sub == 0) return WEAPON_AWP;
		if (sub == 1) return WEAPON_SCOUT;
		if (sub == 2) return WEAPON_G3SG1;
		if (sub == 3) return WEAPON_SG550;
	}
	else if (global == 2 && (sub == 0 || sub == 1 || sub == 2 || sub == 3 || sub == 4 || sub == 5))
	{
		if (sub == 0) return WEAPON_M4A1;
		if (sub == 1) return WEAPON_GALIL;
		if (sub == 2) return WEAPON_FAMAS;
		if (sub == 3) return WEAPON_AUG;
		if (sub == 4) return WEAPON_AK47;
		if (sub == 5) return WEAPON_SG552;
	}
	else if (global == 3 && (sub == 0 || sub == 1))
	{
		if (sub == 0) return WEAPON_XM1014;
		if (sub == 1) return WEAPON_M3;
	}
	else if (global == 4 && sub == 0)
	{
		if (sub == 0) return WEAPON_M249;
	}
	else if (global == 5 && (sub == 0 || sub == 1 || sub == 2 || sub == 3 || sub == 4))
	{
		if (sub == 0) return WEAPON_TMP;
		if (sub == 1) return WEAPON_P90;
		if (sub == 2) return WEAPON_MP5N;
		if (sub == 3) return WEAPON_MAC10;
		if (sub == 4) return WEAPON_UMP45;
	}
	else return 0;
}

void CheckSubSection(float& global, float& sub)
{
	if (global == 0 && sub > 5) sub = 5;
	if (global == 1 && sub > 3) sub = 3;
	if (global == 2 && sub > 5) sub = 5;
	if (global == 3 && sub > 1) sub = 1;
	if (global == 4 && sub > 0) sub = 0;
	if (global == 5 && sub > 4) sub = 4;
}

void DrawCategoryButtons()
{
	ImGui::Spacing();
	ImGui::Spacing();

	switch (tab)
	{
	case 0:
		if (Sakura::Menu::Widgets::SubTab(/*Aimbot*/XorStr<0x47, 7, 0x68C0C7BA>("\x06\x21\x24\x28\x24\x38" + 0x68C0C7BA).s, ImVec2(150, 25), ragebottab == 0 ? true : false))
			ragebottab = 0;

		ImGui::Spacing();

		if (Sakura::Menu::Widgets::SubTab(/*Anti Aim*/XorStr<0x77, 9, 0xC9FE72E0>("\x36\x16\x0D\x13\x5B\x3D\x14\x13" + 0xC9FE72E0).s, ImVec2(150, 25), ragebottab == 1 ? true : false))
			ragebottab = 1;

		ImGui::Spacing();

		if (Sakura::Menu::Widgets::SubTab(/*Fake Lag*/XorStr<0x2C,9,0xDCD958A0>("\x6A\x4C\x45\x4A\x10\x7D\x53\x54"+0xDCD958A0).s, ImVec2(150, 25), ragebottab == 2 ? true : false))
			ragebottab = 2;

		ImGui::Spacing();

		if (Sakura::Menu::Widgets::SubTab(/*Speedhack*/XorStr<0x13, 10, 0x5277386C>("\x40\x64\x70\x73\x73\x70\x78\x79\x70" + 0x5277386C).s, ImVec2(150, 25), ragebottab == 3 ? true : false))
			ragebottab = 3;
		break;
	case 1:
		if (Sakura::Menu::Widgets::SubTab(/*Aimbot*/XorStr<0x5A, 7, 0x7C571BB6>("\x1B\x32\x31\x3F\x31\x2B" + 0x7C571BB6).s, ImVec2(150, 25), legitbottab == 0 ? true : false))
			legitbottab = 0;

		ImGui::Spacing();

		if (Sakura::Menu::Widgets::SubTab(/*Triggerbot*/XorStr<0x0F, 11, 0x26F86A38>("\x5B\x62\x78\x75\x74\x71\x67\x74\x78\x6C" + 0x26F86A38).s, ImVec2(150, 25), legitbottab == 1 ? true : false))
			legitbottab = 1;

		ImGui::Spacing();

		if (Sakura::Menu::Widgets::SubTab(/*Perfect Silent*/XorStr<0x7D, 15, 0xEFE97515>("\x2D\x1B\x0D\xE6\xE4\xE1\xF7\xA4\xD6\xEF\xEB\xED\xE7\xFE" + 0xEFE97515).s, ImVec2(150, 25), legitbottab == 2 ? true : false))
			legitbottab = 2;

		ImGui::Spacing();

		if (Sakura::Menu::Widgets::SubTab(/*Recoil*/XorStr<0xB3, 7, 0x2BFB339E>("\xE1\xD1\xD6\xD9\xDE\xD4" + 0x2BFB339E).s, ImVec2(150, 25), legitbottab == 3 ? true : false))
			legitbottab = 3;

		ImGui::Spacing();

		if (Sakura::Menu::Widgets::SubTab(/*Knifebot*/XorStr<0xD0, 9, 0x4B190BD1>("\x9B\xBF\xBB\xB5\xB1\xB7\xB9\xA3" + 0x4B190BD1).s, ImVec2(150, 25), legitbottab == 4 ? true : false))
			legitbottab = 4;
		break;
	case 2:
		if (Sakura::Menu::Widgets::SubTab(/*Player*/XorStr<0x73, 7, 0x401FCABE>("\x23\x18\x14\x0F\x12\x0A" + 0x401FCABE).s, ImVec2(150, 25), visualstab == 0 ? true : false))
			visualstab = 0;

		ImGui::Spacing();

		if (Sakura::Menu::Widgets::SubTab(/*Local*/XorStr<0x14, 6, 0x94C33886>("\x58\x7A\x75\x76\x74" + 0x94C33886).s, ImVec2(150, 25), visualstab == 1 ? true : false))
			visualstab = 1;

		ImGui::Spacing();

		if (Sakura::Menu::Widgets::SubTab(/*World*/XorStr<0x31, 6, 0x49BAEB00>("\x66\x5D\x41\x58\x51" + 0x49BAEB00).s, ImVec2(150, 25), visualstab == 2 ? true : false))
			visualstab = 2;

		ImGui::Spacing();

		if (Sakura::Menu::Widgets::SubTab(/*Radar*/XorStr<0xB1, 6, 0xB39A2D33>("\xE3\xD3\xD7\xD5\xC7" + 0xB39A2D33).s, ImVec2(150, 25), visualstab == 3 ? true : false))
			visualstab = 3;

		ImGui::Spacing();

		if (Sakura::Menu::Widgets::SubTab(/*Skins*/XorStr<0x92, 6, 0x481899D7>("\xC1\xF8\xFD\xFB\xE5" + 0x481899D7).s, ImVec2(150, 25), visualstab == 4 ? true : false))
			visualstab = 4;

		ImGui::Spacing();

		if (Sakura::Menu::Widgets::SubTab(/*Removals*/XorStr<0xA8, 9, 0x05010633>("\xFA\xCC\xC7\xC4\xDA\xCC\xC2\xDC" + 0x05010633).s, ImVec2(150, 25), visualstab == 5 ? true : false))
			visualstab = 5;

		ImGui::Spacing();

		if (Sakura::Menu::Widgets::SubTab(/*Sound*/XorStr<0xB7, 6, 0xB37B6E61>("\xE4\xD7\xCC\xD4\xDF" + 0xB37B6E61).s, ImVec2(150, 25), visualstab == 6 ? true : false))
			visualstab = 6;

		ImGui::Spacing();

		if (Sakura::Menu::Widgets::SubTab(/*Menu*/XorStr<0x3A, 5, 0xAAEE34F2>("\x77\x5E\x52\x48" + 0xAAEE34F2).s, ImVec2(150, 25), visualstab == 7 ? true : false))
			visualstab = 7;
		break;
	case 3:
		if (Sakura::Menu::Widgets::SubTab(/*HNS*/XorStr<0xAE, 4, 0xD61C59C6>("\xE6\xE1\xE3" + 0xD61C59C6).s, ImVec2(150, 25), misctab == 0 ? true : false))
			misctab = 0;

		ImGui::Spacing();

		if (Sakura::Menu::Widgets::SubTab(/*Keybindings*/XorStr<0xDB, 12, 0x9DC793B5>("\x90\xB9\xA4\xBC\xB6\x8E\x85\x8B\x8D\x83\x96" + 0x9DC793B5).s, ImVec2(150, 25), misctab == 1 ? true : false))
			misctab = 1;

		ImGui::Spacing();

		if (Sakura::Menu::Widgets::SubTab(/*Player List*/XorStr<0x7D, 12, 0x9BE9C82C>("\x2D\x12\x1E\xF9\xE4\xF0\xA3\xC8\xEC\xF5\xF3" + 0x9BE9C82C).s, ImVec2(150, 25), misctab == 2 ? true : false))
			misctab = 2;

		ImGui::Spacing();

		if (Sakura::Menu::Widgets::SubTab(/*Backtrack*/XorStr<0x4F, 10, 0x184CC124>("\x0D\x31\x32\x39\x27\x26\x34\x35\x3C" + 0x184CC124).s, ImVec2(150, 25), misctab == 3 ? true : false))
			misctab = 3;

		ImGui::Spacing();

		if (Sakura::Menu::Widgets::SubTab(/*Anti AFK*/XorStr<0x9D, 9, 0x24E0E5B1>("\xDC\xF0\xEB\xC9\x81\xE3\xE5\xEF" + 0x24E0E5B1).s, ImVec2(150, 25), misctab == 4 ? true : false))
			misctab = 4;

		ImGui::Spacing();

		if (Sakura::Menu::Widgets::SubTab(/*SID Changer*/XorStr<0x5A, 12, 0x6783DE5A>("\x09\x12\x18\x7D\x1D\x37\x01\x0F\x05\x06\x16" + 0x6783DE5A).s, ImVec2(150, 25), misctab == 5 ? true : false))
			misctab = 5;

		ImGui::Spacing();

		if (Sakura::Menu::Widgets::SubTab(/*Route*/XorStr<0xDC, 6, 0x779C08FC>("\x8E\xB2\xAB\xAB\x85" + 0x779C08FC).s, ImVec2(150, 25), misctab == 6 ? true : false))
			misctab = 6;

		ImGui::Spacing();

		if (Sakura::Menu::Widgets::SubTab(/*Notifications*/XorStr<0x83, 14, 0x55ED0DA5>("\xCD\xEB\xF1\xEF\xE1\xE1\xEA\xEB\xFF\xE5\xE2\xE0\xFC" + 0x55ED0DA5).s, ImVec2(150, 25), misctab == 7 ? true : false))
			misctab = 7;

		ImGui::Spacing();

		if (Sakura::Menu::Widgets::SubTab(/*Name Stealer*/XorStr<0x6F, 13, 0x654059D0>("\x21\x11\x1C\x17\x53\x27\x01\x13\x16\x14\x1C\x08" + 0x654059D0).s, ImVec2(150, 25), misctab == 8 ? true : false))
			misctab = 8;

		ImGui::Spacing();

		if (Sakura::Menu::Widgets::SubTab(/*Chat spammer*/XorStr<0x4E, 13, 0xA7689533>("\x0D\x27\x31\x25\x72\x20\x24\x34\x3B\x3A\x3D\x2B" + 0xA7689533).s, ImVec2(150, 25), misctab == 9 ? true : false))
			misctab = 9;

		ImGui::Spacing();

		if (Sakura::Menu::Widgets::SubTab(/*Config*/XorStr<0xF0, 7, 0x5A2FD6CC>("\xB3\x9E\x9C\x95\x9D\x92" + 0x5A2FD6CC).s, ImVec2(150, 25), misctab == 10 ? true : false))
			misctab = 10;

		ImGui::Spacing();

		if (Sakura::Menu::Widgets::SubTab(/*Info*/XorStr<0x81, 5, 0xC7F5B620>("\xC8\xEC\xE5\xEB" + 0xC7F5B620).s, ImVec2(150, 25), misctab == 11 ? true : false))
			misctab = 11;
		break;
	case 4:
		if (Sakura::Menu::Widgets::SubTab(/*Player*/XorStr<0x5A, 7, 0x66A92CE7>("\x0A\x37\x3D\x24\x3B\x2D" + 0x66A92CE7).s, ImVec2(150, 25), colorstab == 0 ? true : false))
			colorstab = 0;

		ImGui::Spacing();

		if (Sakura::Menu::Widgets::SubTab(/*Local*/XorStr<0x5D, 6, 0x466B0D2F>("\x11\x31\x3C\x01\x0D" + 0x466B0D2F).s, ImVec2(150, 25), colorstab == 1 ? true : false))
			colorstab = 1;

		ImGui::Spacing();

		if (Sakura::Menu::Widgets::SubTab(/*World*/XorStr<0x39, 6, 0x5038EE1A>("\x6E\x55\x49\x50\x59" + 0x5038EE1A).s, ImVec2(150, 25), colorstab == 2 ? true : false))
			colorstab = 2;

		ImGui::Spacing();

		if (Sakura::Menu::Widgets::SubTab(/*Route*/XorStr<0x92, 6, 0x1B5E4198>("\xC0\xFC\xE1\xE1\xF3" + 0x1B5E4198).s, ImVec2(150, 25), colorstab == 3 ? true : false))
			colorstab = 3;

		ImGui::Spacing();

		if (Sakura::Menu::Widgets::SubTab(/*Notification*/XorStr<0x24, 13, 0x575A7563>("\x6A\x4A\x52\x4E\x4E\x40\x49\x4A\x58\x44\x41\x41" + 0x575A7563).s, ImVec2(150, 25), colorstab == 4 ? true : false))
			colorstab = 4;

		ImGui::Spacing();

		if (Sakura::Menu::Widgets::SubTab(/*Menu*/XorStr<0x28, 5, 0x065EA3AD>("\x65\x4C\x44\x5E" + 0x065EA3AD).s, ImVec2(150, 25), colorstab == 5 ? true : false))
			colorstab = 5;
		break;
	}
}

void DrawButtons()
{
	if (Sakura::Menu::Widgets::Tab(/*a*/XorStr<0x25, 2, 0x2D9B042A>("\x44" + 0x2D9B042A).s, /*Ragebot*/XorStr<0x44, 8, 0xCE68DBE4>("\x16\x24\x21\x22\x2A\x26\x3E" + 0xCE68DBE4).s, ImVec2(85, 50), tab == 0 ? true : false))
		tab = 0;
	ImGui::SameLine();
	if (Sakura::Menu::Widgets::Tab(/*b*/XorStr<0xE8, 2, 0xE67E61AB>("\x8A" + 0xE67E61AB).s, /*Legitbot*/XorStr<0x2A, 9, 0xDE7F5068>("\x66\x4E\x4B\x44\x5A\x4D\x5F\x45" + 0xDE7F5068).s, ImVec2(85, 50), tab == 1 ? true : false))
		tab = 1;
	ImGui::SameLine();
	if (Sakura::Menu::Widgets::Tab(/*c*/XorStr<0x3C, 2, 0x26CDB6DF>("\x5F" + 0x26CDB6DF).s, /*Visuals*/XorStr<0x1F, 8, 0xF63CB178>("\x49\x49\x52\x57\x42\x48\x56" + 0xF63CB178).s, ImVec2(80, 50), tab == 2 ? true : false))
		tab = 2;
	ImGui::SameLine();
	if (Sakura::Menu::Widgets::Tab(/*d*/XorStr<0x36, 2, 0x50F89261>("\x52" + 0x50F89261).s, /*Miscellaneous*/XorStr<0xB1, 14, 0x5ACAC934>("\xFC\xDB\xC0\xD7\xD0\xDA\xDB\xD9\xD7\xDF\xD4\xC9\xCE" + 0x5ACAC934).s, ImVec2(115, 50), tab == 3 ? true : false))
		tab = 3;
	ImGui::SameLine();
	if (Sakura::Menu::Widgets::Tab(/*f*/XorStr<0x4E, 2, 0x8DC459AD>("\x28" + 0x8DC459AD).s, /*Colors*/XorStr<0x26, 7, 0xB6BCB496>("\x65\x48\x44\x46\x58\x58" + 0xB6BCB496).s, ImVec2(75, 50), tab == 4 ? true : false))
		tab = 4;
}

void DrawTab()
{
	switch (tab)
	{
	case 0:
		switch (ragebottab)
		{
		case 0:
			Sakura::Menu::Tabs::Rage::Aimbot();
			break;
		case 1:
			Sakura::Menu::Tabs::Rage::AntiAim();
			break;
		case 2:
			Sakura::Menu::Tabs::Rage::FakeLag();
			break;
		case 3:
			Sakura::Menu::Tabs::Rage::Speedhack();
			break;
		}

		break;
	case 1:

		if (legitbottab == 0 || legitbottab == 1 || legitbottab == 2 || legitbottab == 3)
		{
			CheckSubSection(cvar.menu_legit_global_section, cvar.menu_legit_sub_section);

			if (Sakura::Menu::Widgets::SubSubTab(/*J*/XorStr<0x07, 2, 0x1193F7AB>("\x4D" + 0x1193F7AB).s, /*Pistols*/XorStr<0xD1, 8, 0x2478CA3A>("\x81\xBB\xA0\xA0\xBA\xBA\xA4" + 0x2478CA3A).s, ImVec2(70, 30), cvar.menu_legit_global_section == 0 ? true : false, Sakura::Menu::Fonts::weaponsFont))
				cvar.menu_legit_global_section = 0;
			ImGui::SameLine();
			if (Sakura::Menu::Widgets::SubSubTab(/*S*/XorStr<0x44, 2, 0x53B8FCBC>("\x17" + 0x53B8FCBC).s, /*Snipers*/XorStr<0x9D, 8, 0x88A36CA2>("\xCE\xF0\xF6\xD0\xC4\xD0\xD0" + 0x88A36CA2).s, ImVec2(80, 30), cvar.menu_legit_global_section == 1 ? true : false, Sakura::Menu::Fonts::weaponsFont))
				cvar.menu_legit_global_section = 1;
			ImGui::SameLine();
			if (Sakura::Menu::Widgets::SubSubTab(/*A*/XorStr<0xA6, 2, 0x78CCF0CB>("\xE7" + 0x78CCF0CB).s, /*Rifles*/XorStr<0x82, 7, 0x1BD311A6>("\xD0\xEA\xE2\xE9\xE3\xF4" + 0x1BD311A6).s, ImVec2(80, 30), cvar.menu_legit_global_section == 2 ? true : false, Sakura::Menu::Fonts::weaponsFont))
				cvar.menu_legit_global_section = 2;
			ImGui::SameLine();
			if (Sakura::Menu::Widgets::SubSubTab(/*P*/XorStr<0xE9, 2, 0xD848AC79>("\xB9" + 0xD848AC79).s, /*Shotguns*/XorStr<0xE5, 9, 0x98726950>("\xB6\x8E\x88\x9C\x8E\x9F\x85\x9F" + 0x98726950).s, ImVec2(80, 30), cvar.menu_legit_global_section == 3 ? true : false, Sakura::Menu::Fonts::weaponsFont))
				cvar.menu_legit_global_section = 3;
			ImGui::SameLine();
			if (Sakura::Menu::Widgets::SubSubTab(/*L*/XorStr<0x84, 2, 0x6BCA3C62>("\xC8" + 0x6BCA3C62).s, /*Machine guns*/XorStr<0x28, 13, 0xEBD54C47>("\x65\x48\x49\x43\x45\x43\x4B\x0F\x57\x44\x5C\x40" + 0xEBD54C47).s, ImVec2(80, 30), cvar.menu_legit_global_section == 4 ? true : false, Sakura::Menu::Fonts::weaponsFont))
				cvar.menu_legit_global_section = 4;
			ImGui::SameLine();
			if (Sakura::Menu::Widgets::SubSubTab(/*N*/XorStr<0x77, 2, 0xA2A289CA>("\x39" + 0xA2A289CA).s, /*Submachine guns*/XorStr<0x10, 16, 0xBEB79C29>("\x43\x64\x70\x7E\x75\x76\x7E\x7E\x76\x7C\x3A\x7C\x69\x73\x6D" + 0xBEB79C29).s, ImVec2(85, 30), cvar.menu_legit_global_section == 5 ? true : false, Sakura::Menu::Fonts::weaponsFont))
				cvar.menu_legit_global_section = 5;

			switch (static_cast<int>(cvar.menu_legit_global_section))
			{
			case 0: // pistols
				if (Sakura::Menu::Widgets::SubSubTab(/*J*/XorStr<0x1B, 2, 0x366E25FB>("\x51" + 0x366E25FB).s, /*Glock-18*/XorStr<0x17, 9, 0x3E402049>("\x50\x74\x76\x79\x70\x31\x2C\x26" + 0x3E402049).s, ImVec2(80, 30), cvar.menu_legit_sub_section == 0 ? true : false, Sakura::Menu::Fonts::weaponsFont))
					cvar.menu_legit_sub_section = 0;
				ImGui::SameLine();
				if (Sakura::Menu::Widgets::SubSubTab(/*O*/XorStr<0x34, 2, 0x9579515B>("\x7B" + 0x9579515B).s, /*P-228*/XorStr<0x9C, 6, 0x3D582574>("\xCC\xB0\xAC\xAD\x98" + 0x3D582574).s, ImVec2(80, 30), cvar.menu_legit_sub_section == 1 ? true : false, Sakura::Menu::Fonts::weaponsFont))
					cvar.menu_legit_sub_section = 1;
				ImGui::SameLine();
				if (Sakura::Menu::Widgets::SubSubTab(/*D*/XorStr<0xBF, 2, 0x0DE185A2>("\xFB" + 0x0DE185A2).s, /*Desert deagle*/XorStr<0x1B, 14, 0xD5566809>("\x5F\x79\x6E\x7B\x6D\x54\x01\x46\x46\x45\x42\x4A\x42" + 0xD5566809).s, ImVec2(80, 30), cvar.menu_legit_sub_section == 2 ? true : false, Sakura::Menu::Fonts::weaponsFont))
					cvar.menu_legit_sub_section = 2;
				ImGui::SameLine();
				if (Sakura::Menu::Widgets::SubSubTab(/*E*/XorStr<0x46, 2, 0x710B50B5>("\x03" + 0x710B50B5).s, /*Dual berettas*/XorStr<0x59, 14, 0x50365BA0>("\x1D\x2F\x3A\x30\x7D\x3C\x3A\x12\x04\x16\x17\x05\x16" + 0x50365BA0).s, ImVec2(80, 30), cvar.menu_legit_sub_section == 3 ? true : false, Sakura::Menu::Fonts::weaponsFont))
					cvar.menu_legit_sub_section = 3;
				ImGui::SameLine();
				if (Sakura::Menu::Widgets::SubSubTab(/*G*/XorStr<0xF5, 2, 0xEBD96B5F>("\xB2" + 0xEBD96B5F).s, /*Five-seven*/XorStr<0xDB, 11, 0xF64421C8>("\x9D\xB5\xAB\xBB\xF2\x93\x84\x94\x86\x8A" + 0xF64421C8).s, ImVec2(80, 30), cvar.menu_legit_sub_section == 4 ? true : false, Sakura::Menu::Fonts::weaponsFont))
					cvar.menu_legit_sub_section = 4;
				ImGui::SameLine();
				if (Sakura::Menu::Widgets::SubSubTab(/*U*/XorStr<0x1D, 2, 0x3124DF01>("\x48" + 0x3124DF01).s, /*Usp*/XorStr<0x16, 4, 0xEBCFCC42>("\x43\x64\x68" + 0xEBCFCC42).s, ImVec2(80, 30), cvar.menu_legit_sub_section == 5 ? true : false, Sakura::Menu::Fonts::weaponsFont))
					cvar.menu_legit_sub_section = 5;
				break;
			case 1: // snipers
				if (Sakura::Menu::Widgets::SubSubTab(/*C*/XorStr<0x75, 2, 0xB0A8FE51>("\x36" + 0xB0A8FE51).s, /*AWP*/XorStr<0xB4, 4, 0xB1983D22>("\xF5\xE2\xE6" + 0xB1983D22).s, ImVec2(120, 30), cvar.menu_legit_sub_section == 0 ? true : false, Sakura::Menu::Fonts::weaponsFont))
					cvar.menu_legit_sub_section = 0;
				ImGui::SameLine();
				if (Sakura::Menu::Widgets::SubSubTab(/*S*/XorStr<0xDD, 2, 0x6A4B0757>("\x8E" + 0x6A4B0757).s, /*Scout*/XorStr<0xCC, 6, 0xBAECF2E6>("\x9F\xAE\xA1\xBA\xA4" + 0xBAECF2E6).s, ImVec2(120, 30), cvar.menu_legit_sub_section == 1 ? true : false, Sakura::Menu::Fonts::weaponsFont))
					cvar.menu_legit_sub_section = 1;
				ImGui::SameLine();
				if (Sakura::Menu::Widgets::SubSubTab(/*H*/XorStr<0xCE, 2, 0xDF442BCC>("\x86" + 0xDF442BCC).s, /*G3SG1*/XorStr<0x34, 6, 0xA2E62F6B>("\x73\x06\x65\x70\x09" + 0xA2E62F6B).s, ImVec2(120, 30), cvar.menu_legit_sub_section == 2 ? true : false, Sakura::Menu::Fonts::weaponsFont))
					cvar.menu_legit_sub_section = 2;
				ImGui::SameLine();
				if (Sakura::Menu::Widgets::SubSubTab(/*Q*/XorStr<0x56, 2, 0xFC8F7933>("\x07" + 0xFC8F7933).s, /*SG550*/XorStr<0x7B, 6, 0xA20BE07A>("\x28\x3B\x48\x4B\x4F" + 0xA20BE07A).s, ImVec2(120, 30), cvar.menu_legit_sub_section == 3 ? true : false, Sakura::Menu::Fonts::weaponsFont))
					cvar.menu_legit_sub_section = 3;
				break;
			case 2: // rifles
				if (Sakura::Menu::Widgets::SubSubTab(/*K*/XorStr<0xB3, 2, 0xC1C21D22>("\xF8" + 0xC1C21D22).s, /*M4A1*/XorStr<0xCF, 5, 0x62ADDEC7>("\x82\xE4\x90\xE3" + 0x62ADDEC7).s, ImVec2(80, 30), cvar.menu_legit_sub_section == 0 ? true : false, Sakura::Menu::Fonts::weaponsFont))
					cvar.menu_legit_sub_section = 0;
				ImGui::SameLine();
				if (Sakura::Menu::Widgets::SubSubTab(/*I*/XorStr<0xE6, 2, 0x8C2AAD4A>("\xAF" + 0x8C2AAD4A).s, /*Galil*/XorStr<0xBE, 6, 0x84F98779>("\xF9\xDE\xAC\xA8\xAE" + 0x84F98779).s, ImVec2(80, 30), cvar.menu_legit_sub_section == 1 ? true : false, Sakura::Menu::Fonts::weaponsFont))
					cvar.menu_legit_sub_section = 1;
				ImGui::SameLine();
				if (Sakura::Menu::Widgets::SubSubTab(/*F*/XorStr<0xDD, 2, 0x463E1080>("\x9B" + 0x463E1080).s, /*Famas*/XorStr<0xB0, 6, 0x0B810601>("\xF6\xD0\xDF\xD2\xC7" + 0x0B810601).s, ImVec2(80, 30), cvar.menu_legit_sub_section == 2 ? true : false, Sakura::Menu::Fonts::weaponsFont))
					cvar.menu_legit_sub_section = 2;
				ImGui::SameLine();
				if (Sakura::Menu::Widgets::SubSubTab(/*B*/XorStr<0x3D, 2, 0x42616576>("\x7F" + 0x42616576).s, /*Aug*/XorStr<0xEE, 4, 0x17695421>("\xAF\x9A\x97" + 0x17695421).s, ImVec2(80, 30), cvar.menu_legit_sub_section == 3 ? true : false, Sakura::Menu::Fonts::weaponsFont))
					cvar.menu_legit_sub_section = 3;
				ImGui::SameLine();
				if (Sakura::Menu::Widgets::SubSubTab(/*A*/XorStr<0x6B, 2, 0x982B48B2>("\x2A" + 0x982B48B2).s, /*AK-47*/XorStr<0xBE, 6, 0x083D2F4B>("\xFF\xF4\xED\xF5\xF5" + 0x083D2F4B).s, ImVec2(80, 30), cvar.menu_legit_sub_section == 4 ? true : false, Sakura::Menu::Fonts::weaponsFont))
					cvar.menu_legit_sub_section = 4;
				ImGui::SameLine();
				if (Sakura::Menu::Widgets::SubSubTab(/*R*/XorStr<0xD0, 2, 0x912A7965>("\x82" + 0x912A7965).s, /*SG552*/XorStr<0xD6, 6, 0x6B217C62>("\x85\x90\xED\xEC\xE8" + 0x6B217C62).s, ImVec2(80, 30), cvar.menu_legit_sub_section == 5 ? true : false, Sakura::Menu::Fonts::weaponsFont))
					cvar.menu_legit_sub_section = 5;
				break;
			case 3: // shotguns
				if (Sakura::Menu::Widgets::SubSubTab(/*V*/XorStr<0x18,2,0xC145890E>("\x4E"+0xC145890E).s, /*XM1014*/XorStr<0xA9, 7, 0x9AA15A7B>("\xF1\xE7\x9A\x9C\x9C\x9A" + 0x9AA15A7B).s, ImVec2(265, 30), cvar.menu_legit_sub_section == 0 ? true : false, Sakura::Menu::Fonts::weaponsFont))
					cvar.menu_legit_sub_section = 0;
				ImGui::SameLine();
				if (Sakura::Menu::Widgets::SubSubTab(/*P*/XorStr<0x76, 2, 0x10C93ABC>("\x26" + 0x10C93ABC).s, /*M3*/XorStr<0x6D, 3, 0xFCD02E83>("\x20\x5D" + 0xFCD02E83).s, ImVec2(265, 30), cvar.menu_legit_sub_section == 1 ? true : false, Sakura::Menu::Fonts::weaponsFont))
					cvar.menu_legit_sub_section = 1;
				break;
			case 4: // machine guns
				if (Sakura::Menu::Widgets::SubSubTab(/*L*/XorStr<0x3B, 2, 0xFE306131>("\x77" + 0xFE306131).s, /*M249*/XorStr<0x4A, 5, 0xB2C14093>("\x07\x79\x78\x74" + 0xB2C14093).s, ImVec2(530, 30), cvar.menu_legit_sub_section == 0 ? true : false, Sakura::Menu::Fonts::weaponsFont))
					cvar.menu_legit_sub_section = 0;
				break;
			case 5: // submachine guns
				if (Sakura::Menu::Widgets::SubSubTab(/*a*/XorStr<0x8D, 2, 0x1EB76F2E>("\xEC" + 0x1EB76F2E).s, /*Tmp*/XorStr<0xFB, 4, 0xF29825C0>("\xAF\x91\x8D" + 0xF29825C0).s, ImVec2(120, 30), cvar.menu_legit_sub_section == 0 ? true : false, Sakura::Menu::Fonts::weaponsFont))
					cvar.menu_legit_sub_section = 0;
				ImGui::SameLine();
				if (Sakura::Menu::Widgets::SubSubTab(/*N*/XorStr<0xB3, 2, 0xC1A727BC>("\xFD" + 0xC1A727BC).s, /*P90*/XorStr<0x50, 4, 0xCFBC0891>("\x00\x68\x62" + 0xCFBC0891).s, ImVec2(120, 30), cvar.menu_legit_sub_section == 1 ? true : false, Sakura::Menu::Fonts::weaponsFont))
					cvar.menu_legit_sub_section = 1;
				ImGui::SameLine();
				if (Sakura::Menu::Widgets::SubSubTab(/*b*/XorStr<0xEC, 2, 0x5027F728>("\x8E" + 0x5027F728).s, /*Mp5*/XorStr<0xEC, 4, 0xB8B980A2>("\xA1\x9D\xDB" + 0xB8B980A2).s, ImVec2(120, 30), cvar.menu_legit_sub_section == 2 ? true : false, Sakura::Menu::Fonts::weaponsFont))
					cvar.menu_legit_sub_section = 2;
				ImGui::SameLine();
				if (Sakura::Menu::Widgets::SubSubTab(/*M*/XorStr<0x6A, 2, 0x81E72E7A>("\x27" + 0x81E72E7A).s, /*Mac10*/XorStr<0xF1, 6, 0xA84884ED>("\xBC\x93\x90\xC5\xC5" + 0xA84884ED).s, ImVec2(120, 30), cvar.menu_legit_sub_section == 3 ? true : false, Sakura::Menu::Fonts::weaponsFont))
					cvar.menu_legit_sub_section = 3;
				ImGui::SameLine();
				if (Sakura::Menu::Widgets::SubSubTab(/*T*/XorStr<0x42, 2, 0xE48746C6>("\x16" + 0xE48746C6).s, /*Ump45*/XorStr<0x60, 6, 0xC92D2960>("\x35\x0C\x12\x57\x51" + 0xC92D2960).s, ImVec2(120, 30), cvar.menu_legit_sub_section == 4 ? true : false, Sakura::Menu::Fonts::weaponsFont))
					cvar.menu_legit_sub_section = 4;
				break;
			}

			ImGui::Spacing();
			ImGui::Spacing();
		}
		
		switch (legitbottab)
		{
		case 0:
			Sakura::Menu::Tabs::Legit::Aimbot();
			break;
		case 1:
			Sakura::Menu::Tabs::Legit::Triggerbot();
			break;
		case 2:
			Sakura::Menu::Tabs::Legit::PerfectSilent();
			break;
		case 3:
			Sakura::Menu::Tabs::Legit::Recoil();
			break;
		case 4:
			Sakura::Menu::Tabs::Legit::Knifebot();
			break;
		}
		break;
	case 2:
		switch (visualstab)
		{
		case 0:
			Sakura::Menu::Tabs::Visuals::Player();
			break;
		case 1:
			Sakura::Menu::Tabs::Visuals::Local();
			break;
		case 2:
			Sakura::Menu::Tabs::Visuals::World();
			break;
		case 3:
			Sakura::Menu::Tabs::Visuals::Radar();
			break;
		case 4:
			Sakura::Menu::Tabs::Visuals::Skins();
			break;
		case 5:
			Sakura::Menu::Tabs::Visuals::Removals();
			break;
		case 6:
			Sakura::Menu::Tabs::Visuals::Sound();
			break;
		case 7:
			Sakura::Menu::Tabs::Visuals::Other();
			break;
		}
		break;
	case 3:
		switch (misctab)
		{
		case 0:
			Sakura::Menu::Tabs::Misc::Kreedz();
			break;
		case 1:
			Sakura::Menu::Tabs::Misc::Keybindings();
			break;
		case 2:
			Sakura::Menu::Tabs::Misc::PlayerList();
			break;
		case 3:
			Sakura::Menu::Tabs::Misc::Backtrack();
			break;
		case 4:
			Sakura::Menu::Tabs::Misc::AntiAFK();
			break;
		case 5:
			Sakura::Menu::Tabs::Misc::SidChanger();
			break;
		case 6:
			Sakura::Menu::Tabs::Misc::Route();
			break;
		case 7:
			Sakura::Menu::Tabs::Misc::Notify();
			break;
		case 8:
			Sakura::Menu::Tabs::Misc::NameStealer();
			break;
		case 9:
			Sakura::Menu::Tabs::Misc::ChatSpammer();
			break;
		case 10:
			Sakura::Menu::Tabs::Misc::Config();
			break;
		case 11:
			Sakura::Menu::Tabs::Misc::Information();
			break;
		}
		break;
	case 4:
		switch (colorstab)
		{
		case 0:
			Sakura::Menu::Tabs::Colors::Player();
			break;
		case 1:
			Sakura::Menu::Tabs::Colors::Local();
			break;
		case 2:
			Sakura::Menu::Tabs::Colors::World();
			break;
		case 3:
			Sakura::Menu::Tabs::Colors::Route();
			break;
		case 4:
			Sakura::Menu::Tabs::Colors::Notification();
			break;
		case 5:
			Sakura::Menu::Tabs::Colors::Menu();
			break;
		}
		break;
	}
}

void DrawMenuWindow()
{
	static float alpha = 0.f;
	static float snowflakesFirst = false;

	if (alpha > 1.f)
		alpha = 1.f;

	if (alpha < 0.f)
		alpha = 0.f;

	if (bShowMenu && alpha < 1.f)
		alpha += 0.16;
	else if(!bShowMenu && alpha > 0.f)
		alpha -= 0.16;

	Sakura::Menu::currentAlphaFade = alpha * 255;

	if (!bShowMenu && alpha == 0)
	{
		perviousTextIndex = -1;
		return;
	}

	// raining effect
	ImGui::SetNextWindowSize({ ImGui::GetIO().DisplaySize.x, ImGui::GetIO().DisplaySize.y });
	ImGui::SetNextWindowPos({ 0, 0 });
	ImGui::PushStyleVar(ImGuiStyleVar_Alpha, cvar.visual_menu_bg_opacity + alpha - 0.77f);
	ImGui::PushStyleVar(ImGuiStyleVar_WindowRounding, 0);
	ImGui::Begin(/*##bgmenu*/XorStr<0xBF, 9, 0x59E6729E>("\x9C\xE3\xA3\xA5\xAE\xA1\xAB\xB3" + 0x59E6729E).s, nullptr, ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoInputs);
	{
		if (cvar.visual_menu_raining)
		{
			ImDrawList* rainingDraw = ImGui::GetWindowDrawList();
			ImVec2 rainingPos = ImGui::GetWindowPos();

			static const int num_raining = 500;
			static float snowflakes_x[num_raining];
			static float snowflakes_y[num_raining];
			static float snowflakes_size[num_raining];
			static float snowflakes_speed[num_raining];
			static float rain_x[num_raining];
			static float rain_y[num_raining];
			static float rain_size[num_raining];
			static float rain_speed[num_raining];
			static float rain_opacity[num_raining];
			static float rain_wind[num_raining];
			static ImVec2 viewer_pos = ImVec2(ImGui::GetIO().DisplaySize.x * 0.f, ImGui::GetIO().DisplaySize.y * 0.5f);

			switch (static_cast<int>(cvar.visual_menu_raining_type))
			{
			case 0:
				if (!snowflakesFirst)
				{
					for (int i = 0; i < num_raining; i++)
					{
						snowflakes_x[i] = ImGui::GetIO().DisplaySize.x * (float)rand() / RAND_MAX;
						//snowflakes_y[i] = -5;
						snowflakes_y[i] = ImGui::GetIO().DisplaySize.y * (float)rand() / RAND_MAX * -1.0f;
						snowflakes_size[i] = ImGui::GetIO().DisplaySize.x * 0.01 * (float)rand() / RAND_MAX;
						float speed_range = ImGui::GetIO().DisplaySize.y * 0.01;
						float min_speed = ImGui::GetIO().DisplaySize.y * 0.005;
						snowflakes_speed[i] = min_speed + (i * speed_range / num_raining);
						//snowflakes_speed[i] = ((float)rand() / RAND_MAX) * snowflakes_size[i] * 2;
						rain_wind[i] = ((float)rand() / RAND_MAX) * ImGui::GetIO().DisplaySize.x * 0.002; // add some horizontal movement to the drops
					}

					snowflakesFirst = true;
				}

				for (int i = 0; i < cvar.visual_menu_raining_count; i++)
				{
					rainingDraw->AddCircleFilled({ rainingPos.x + snowflakes_x[i], rainingPos.y + snowflakes_y[i] }, snowflakes_size[i], Sakura::Colors::White());

					float minAngle = M_PI / 4;
					float maxAngle = 3 * M_PI / 4;
					float angle = minAngle + (float)rand() / RAND_MAX * (maxAngle - minAngle);

					snowflakes_y[i] += (snowflakes_speed[i] * sin(angle)) * cvar.visual_menu_raining_speed_multipler;

					if (snowflakes_y[i] > ImGui::GetIO().DisplaySize.y + 5)
						snowflakes_y[i] = -5;
				}
				break;
			case 1:
				if (!rainFirst)
				{
					for (int i = 0; i < num_raining; i++)
					{
						rain_x[i] = ImGui::GetIO().DisplaySize.x * (float)rand() / RAND_MAX;
						rain_y[i] = ImGui::GetIO().DisplaySize.y * (float)rand() / RAND_MAX * -1.0f;

						rain_size[i] = ImGui::GetIO().DisplaySize.x * 0.04 * (float)rand() / RAND_MAX;

						float speed_range = ImGui::GetIO().DisplaySize.y * 0.01;
						float min_speed = ImGui::GetIO().DisplaySize.y * 0.005;
						rain_speed[i] = min_speed + (i * speed_range / num_raining);

						rain_opacity[i] = 0.3f + static_cast<float>(rand()) / (static_cast<float>(RAND_MAX / 0.7f));

						float wind_range = ImGui::GetIO().DisplaySize.x * 0.002;
						rain_wind[i] = (float)rand() / RAND_MAX * wind_range - wind_range / 2.0f;
					}

					rainFirst = true;
				}

				for (int i = 0; i < cvar.visual_menu_raining_count; i++)
				{
					float start_x = rain_x[i];
					float start_y = rain_y[i];
					float end_x = start_x + rain_wind[i]; // apply the horizontal movement to the drop's position
					float end_y = start_y + rain_size[i];

					float length_range = ImGui::GetIO().DisplaySize.y * 0.02;
					float min_length = ImGui::GetIO().DisplaySize.y * 0.01;
					float length = min_length + (i * length_range / num_raining);
					end_y = start_y + length;

					// compute distance and angle between raindrop and viewer
					float dx = rain_x[i] - viewer_pos.x;
					float dy = rain_y[i] - viewer_pos.y;
					float distance = sqrt(dx * dx + dy * dy);
					float angle = atan2(dy, dx);

					// adjust opacity based on distance and viewing angle
					float opacity = 0.7f - (distance / ImGui::GetIO().DisplaySize.y) * (0.7f - 0.3f);
					opacity *= cos(angle);

					rainingDraw->AddLine({ rainingPos.x + start_x, rainingPos.y + start_y }, { rainingPos.x + end_x, rainingPos.y + end_y + rain_size[i] }, ImColor(0.89f, 0.89f, 0.89f, opacity));

					rain_x[i] += 0.01f * rain_size[i] + rain_wind[i];
					rain_y[i] += rain_speed[i] * cvar.visual_menu_raining_speed_multipler;

					if (rain_y[i] > ImGui::GetIO().DisplaySize.y + 10)
						rain_y[i] = -10;
					if (rain_x[i] > ImGui::GetIO().DisplaySize.x + 10)
						rain_x[i] = -10;
					if (rain_x[i] < -10)
						rain_x[i] = ImGui::GetIO().DisplaySize.x + 10;
				}
				break;
			}
		}

	}
	ImGui::End();
	ImGui::PopStyleVar(2);
	
	if (Sakura::Lua::scripts.size() > 0)
	{
		ImGui::PushStyleVar(ImGuiStyleVar_Alpha, alpha);
		ImGui::PushStyleColor(ImGuiCol_Header, (ImVec4)Sakura::Menu::GetMenuColor(0.39f));
		ImGui::PushStyleColor(ImGuiCol_HeaderHovered, (ImVec4)Sakura::Menu::GetMenuColor(0.80f));
		ImGui::PushStyleColor(ImGuiCol_HeaderActive, (ImVec4)Sakura::Menu::GetMenuColor(1.00f));
		ImGui::PushStyleColor(ImGuiCol_TitleBg, (ImVec4)Sakura::Menu::GetMenuColor(0.79f));
		ImGui::PushStyleColor(ImGuiCol_TitleBgCollapsed, (ImVec4)Sakura::Menu::GetMenuColor(0.30f));
		ImGui::PushStyleColor(ImGuiCol_TitleBgActive, (ImVec4)Sakura::Menu::GetMenuColor(1.00f));
		ImGui::PushStyleColor(ImGuiCol_CheckMark, (ImVec4)Sakura::Menu::GetMenuColor(1.00f));
		ImGui::PushStyleColor(ImGuiCol_SliderGrab, (ImVec4)Sakura::Menu::GetMenuColor(0.6f));
		ImGui::PushStyleColor(ImGuiCol_SliderGrabActive, (ImVec4)Sakura::Menu::GetMenuColor(1.00f));
		ImGui::PushStyleColor(ImGuiCol_FrameBg, (ImVec4)Sakura::Menu::GetMenuColor(0.39f));
		ImGui::PushStyleColor(ImGuiCol_FrameBgHovered, (ImVec4)Sakura::Menu::GetMenuColor(0.5f));
		ImGui::PushStyleColor(ImGuiCol_FrameBgActive, (ImVec4)Sakura::Menu::GetMenuColor(0.8f));
		ImGui::SetNextWindowPos(ImVec2(40, 20), ImGuiCond_Once);
		ImGui::SetNextWindowCollapsed(true, ImGuiCond_Once);
		ImGui::Begin(/*Sakura - Lua Scripts*/XorStr<0xBB, 21, 0x73438C7B>("\xE8\xDD\xD6\xCB\xCD\xA1\xE1\xEF\xE3\x88\xB0\xA7\xE7\x9B\xAA\xB8\xA2\xBC\xB9\xBD" + 0x73438C7B).s, nullptr, ImGuiWindowFlags_AlwaysAutoResize);
		
		const char** items = new const char* [Sakura::Lua::scripts.size()];
		for (size_t i = 0; i < Sakura::Lua::scripts.size(); ++i)
		{
			auto& script = Sakura::Lua::scripts[i];

			if (!script.HasCallback(Sakura::Lua::SAKURA_CALLBACK_TYPE::SAKURA_CALLBACK_AT_RENDERING_MENU))
				continue;

			char* copy = new char[script.GetName().size() + 1];

			std::strcpy(copy, script.GetName().c_str());

			items[i] = copy;
		}
		
		ImGui::BeginChild(/*##scchoose*/XorStr<0x13, 11, 0x5FFD6DC6>("\x30\x37\x66\x75\x74\x70\x76\x75\x68\x79" + 0x5FFD6DC6).s, ImVec2(145, 250), false, ImGuiWindowFlags_AlwaysAutoResize);
		ImGui::ListBox(/*##sclist*/XorStr<0xA7, 9, 0x420FACF5>("\x84\x8B\xDA\xC9\xC7\xC5\xDE\xDA" + 0x420FACF5).s, &selectedScriptIndex, items, Sakura::Lua::scripts.size(), -1);
		ImGui::EndChild();
		ImGui::SameLine();
		ImGui::BeginChild(/*##sccmenu*/XorStr<0xC1, 10, 0x8A08E65C>("\xE2\xE1\xB0\xA7\xA6\xAB\xA2\xA6\xBC" + 0x8A08E65C).s, ImVec2(400, 250), true, ImGuiWindowFlags_AlwaysVerticalScrollbar | ImGuiWindowFlags_HorizontalScrollbar);
		// Render the selected script
		auto& selectedScript = Sakura::Lua::scripts[selectedScriptIndex];
		auto& callbacks = selectedScript.GetCallbacks(Sakura::Lua::SAKURA_CALLBACK_TYPE::SAKURA_CALLBACK_AT_RENDERING_MENU);
		for (const auto& callback : callbacks)
		{
			try
			{
				callback();
			}
			catch (luabridge::LuaException const& error)
			{
				if (selectedScript.GetState())
				{
					Sakura::Lua::Error(/*Error has occured in the lua "On Menu Render" script: %s*/XorStr<0x51, 57, 0xA94C8E45>("\x14\x20\x21\x3B\x27\x76\x3F\x39\x2A\x7A\x34\x3F\x3E\x2B\x2D\x05\x05\x42\x0A\x0A\x45\x12\x0F\x0D\x49\x06\x1E\x0D\x4D\x4C\x20\x1E\x51\x3F\x16\x1A\x00\x56\x25\x1D\x17\x1E\x1E\x0E\x5F\x5E\x0C\xE3\xF3\xEB\xF3\xF0\xBF\xA6\xA2\xFB" + 0xA94C8E45).s, error.what());
					selectedScript.RemoveAllCallbacks();
				}
			}
		}
		ImGui::EndChild();

		delete[] items;

		ImGui::End();
		ImGui::PopStyleColor(12);
		ImGui::PopStyleVar();
	}

	const char* text = getRandomText();
	const ImVec2 textCalculated = ImGui::CalcTextSize(text);
	const ImVec2 versionCalculated = ImGui::CalcTextSize("v1.103 @ 2023");

	auto flags = ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoTitleBar;
	
	ImGui::PushStyleVar(ImGuiStyleVar_Alpha, alpha);
	ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, { 0, 0 });
	ImGui::SetNextWindowPos(ImVec2(40, 40), ImGuiCond_Once);
	ImGui::SetNextWindowSize({ 720, 490 });
	ImGui::Begin(/*##menu*/XorStr<0x9A, 7, 0x2A9A8C6C>("\xB9\xB8\xF1\xF8\xF0\xEA" + 0x2A9A8C6C).s, nullptr, flags);
	{
		ImDrawList* draw = ImGui::GetWindowDrawList();
		ImVec2 pos = ImGui::GetWindowPos();

		draw->AddRectFilled({ pos.x, pos.y }, { pos.x + 720, pos.y + 50 }, ImColor((int)(cvar.visual_menu_color_header[0] * 255), (int)(cvar.visual_menu_color_header[1] * 255), (int)(cvar.visual_menu_color_header[2] * 255), Sakura::Menu::currentAlphaFade), 6.f, ImDrawCornerFlags_Top);
		draw->AddRectFilled({ pos.x, pos.y + 50 }, { pos.x + 720, pos.y + 490 }, ImColor((int)(cvar.visual_menu_color_items[0] * 255), (int)(cvar.visual_menu_color_items[1] * 255), (int)(cvar.visual_menu_color_items[2] * 255), Sakura::Menu::currentAlphaFade), 6.f, ImDrawCornerFlags_All);
		draw->AddRectFilled({ pos.x, pos.y + 470 }, { pos.x + 720, pos.y + 490 }, ImColor((int)(cvar.visual_menu_color_footer[0] * 255), (int)(cvar.visual_menu_color_footer[1] * 255), (int)(cvar.visual_menu_color_footer[2] * 255), Sakura::Menu::currentAlphaFade), 6.f, ImDrawCornerFlags_Bot);

		draw->AddText({ pos.x + 10, pos.y + 470 + 10 - textCalculated.y / 2 }, ImColor((int)(cvar.visual_menu_color_footer_text[0] * 255), (int)(cvar.visual_menu_color_footer_text[1] * 255), (int)(cvar.visual_menu_color_footer_text[2] * 255), Sakura::Menu::currentAlphaFade), text);
		draw->AddText({ pos.x + 710 - versionCalculated.x, pos.y + 470 + 10 - versionCalculated.y / 2 }, ImColor((int)(cvar.visual_menu_color_footer_text[0] * 255), (int)(cvar.visual_menu_color_footer_text[1] * 255), (int)(cvar.visual_menu_color_footer_text[2] * 255), Sakura::Menu::currentAlphaFade), "v1.103 @ 2023");

		ImGui::PushFont(Sakura::Menu::Fonts::icons);
		ImGui::SetCursorPos({ 20,25 - ImGui::CalcTextSize(/*P*/XorStr<0x6A, 2, 0x100FA605>("\x3A" + 0x100FA605).s).y / 2 });
		ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(cvar.visual_menu_color_logo[0], cvar.visual_menu_color_logo[1], cvar.visual_menu_color_logo[2], 1.f));
		ImGui::Text(/*P*/XorStr<0x6A, 2, 0x100FA605>("\x3A" + 0x100FA605).s);
		ImGui::PopStyleColor();
		ImGui::PopFont();

		ImGui::SameLine();

		ImGui::PushFont(Sakura::Menu::Fonts::titleCheatFont);
		ImGui::SetCursorPos({ 50,25 - ImGui::CalcTextSize(/*Sakura*/XorStr<0xA4,7,0x0D9D1D33>("\xF7\xC4\xCD\xD2\xDA\xC8" + 0x0D9D1D33).s).y / 2 });
		ImGui::Text(/*Sakura*/XorStr<0xA4, 7, 0x0D9D1D33>("\xF7\xC4\xCD\xD2\xDA\xC8" + 0x0D9D1D33).s);
		ImGui::PopFont();

		ImGui::SetCursorPos({ 200,0 });
		ImGui::BeginGroup();
		{
			DrawButtons();
		}
		ImGui::EndGroup();

		ImGui::SetCursorPos({ 10,60 });
		ImGui::BeginGroup();
		{
			DrawCategoryButtons();
		}
		ImGui::EndGroup();

		ImGui::SetCursorPos({ 170,60 });
		ImGui::BeginGroup();
		{
			ImGui::BeginChild(/*##items*/XorStr<0x05, 8, 0x42ADB240>("\x26\x25\x6E\x7C\x6C\x67\x78" + 0x42ADB240).s, { 530, 400 });
			{
				// 30, 35, 40
				draw->AddRectFilled(ImGui::GetWindowPos(), { ImGui::GetWindowPos().x + 530,ImGui::GetWindowPos().y + 400 }, ImColor((int)(cvar.visual_menu_color_widgets[0] * 255), (int)(cvar.visual_menu_color_widgets[1] * 255), (int)(cvar.visual_menu_color_widgets[2] * 255), Sakura::Menu::currentAlphaFade - 55), 8.f);

				ImGui::PushFont(Sakura::Menu::Fonts::titleTabFont);
				ImGui::SetCursorPos({ 10,10 });
				ImGui::BeginGroup();
				{
					ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, { 3, 3 });
					DrawTab();
					ImGui::PopStyleVar();
				}
				ImGui::EndGroup();
				ImGui::PopFont();
			}
			ImGui::EndChild();
		}
		ImGui::EndGroup();

		draw->AddRect({ pos.x, pos.y }, { pos.x + 720, pos.y + 490 }, Sakura::Menu::GetMenuColor(alpha), 6.f);
	}
	ImGui::End();
	ImGui::PopStyleVar(2);
}
```

`sakura/source/features/visuals/menu/menu.h`:

```h
#ifndef _IMGUIMENU_
#define _IMGUIMENU_

namespace Sakura
{
	namespace Menu
	{
		namespace Fonts
		{
			extern ImFont* defaultFont;
			extern ImFont* icons;
			extern ImFont* titleTabFont;
			extern ImFont* titleCheatFont;
			extern ImFont* weaponsFont;
		};

		extern int itemWidth;
		extern int currentAlphaFade;

		ImColor GetMenuColor(float alpha = 1.f);
		int CheckWeapon(float global, float sub);
		void HudKeyBind(float& key, const char* keyname, ImVec2 size = {}, bool old = false);
		void HudMenuBind(float& key);
	};
};

extern bool changewindowfocus;
extern bool keysmenu[256];
extern bool bShowMenu;
extern char nickname[32];
extern char chatspam[128];
void DrawMenuWindow();

#endif
```

`sakura/source/features/visuals/menu/menu_widgets.cpp`:

```cpp
#include "../../../client.h"

static const char* Sakura::Menu::Widgets::Helpers::PatchFormatStringFloatToInt(const char* fmt)
{
	if (fmt[0] == '%' && fmt[1] == '.' && fmt[2] == '0' && fmt[3] == 'f' && fmt[4] == 0) // Fast legacy path for "%.0f" which is expected to be the most common case.
		return "%d";
	const char* fmt_start = ImParseFormatFindStart(fmt);    // Find % (if any, and ignore %%)
	const char* fmt_end = ImParseFormatFindEnd(fmt_start);  // Find end of format specifier, which itself is an exercise of confidence/recklessness (because snprintf is dependent on libc or user).
	if (fmt_end > fmt_start && fmt_end[-1] == 'f')
	{
		if (fmt_start == fmt && fmt_end[0] == 0)
			return "%d";
		ImGuiContext& g = *GImGui;
		ImFormatString(g.TempBuffer.Data, sizeof(g.TempBuffer), "%.*s%%d%s", (int)(fmt_start - fmt), fmt, fmt_end); // Honor leading and trailing decorations, but lose alignment/precision.
		return g.TempBuffer.Data;
	}
	return fmt;
}

static float Sakura::Menu::Widgets::Helpers::CalcMaxPopupHeightFromItemCount(int items_count)
{
	ImGuiContext& g = *GImGui;
	if (items_count <= 0)
		return FLT_MAX;
	return (g.FontSize + g.Style.ItemSpacing.y) * items_count - g.Style.ItemSpacing.y + (g.Style.WindowPadding.y * 2);
}

static bool Sakura::Menu::Widgets::Helpers::Items_ArrayGetter(void* data, int idx, const char** out_text)
{
	const char* const* items = (const char* const*)data;
	if (out_text)
		*out_text = items[idx];
	return true;
}

static bool Sakura::Menu::Widgets::Helpers::Items_SingleStringGetter(void* data, int idx, const char** out_text)
{
	// FIXME-OPT: we could pre-compute the indices to fasten this. But only 1 active combo means the waste is limited.
	const char* items_separated_by_zeros = (const char*)data;
	int items_count = 0;
	const char* p = items_separated_by_zeros;
	while (*p)
	{
		if (idx == items_count)
			break;
		p += strlen(p) + 1;
		items_count++;
	}
	if (!*p)
		return false;
	if (out_text)
		*out_text = p;
	return true;
}

void Sakura::Menu::Widgets::Helpers::RenderCheckMar1k(ImVec2 pos, ImU32 col, float sz)
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = g.CurrentWindow;

	float thickness = ImMax(sz / 5.0f, 1.0f);
	sz -= thickness * 0.5f;
	pos = ImVec2(pos.x + thickness * 0.25f, pos.y + thickness * 0.25f);

	float third = sz / 3.0f;
	float bx = pos.x + third;
	float by = pos.y + sz - third * 0.5f;
	window->DrawList->PathLineTo(ImVec2(bx - third, by - third));
	window->DrawList->PathLineTo(ImVec2(bx, by));
	window->DrawList->PathLineTo(ImVec2(bx + third * 2, by - third * 2));
	window->DrawList->PathStroke(col, false, thickness);
}

bool Sakura::Menu::Widgets::Tab(const char* icon, const char* label, const ImVec2& size_arg, const bool selected)
{
	ImGuiWindow* window = ImGui::GetCurrentWindow();
	if (window->SkipItems)
		return false;

	static float sizeplus = 0.f;

	ImGuiContext& g = *GImGui;
	const ImGuiStyle& style = g.Style;
	const ImGuiID id = window->GetID(label);
	const ImVec2 label_size = ImGui::CalcTextSize(label, NULL, true);

	ImVec2 pos = window->DC.CursorPos;

	ImVec2 size = ImGui::CalcItemSize(size_arg, label_size.x + style.FramePadding.x * 2.f, label_size.y + style.FramePadding.y * 2.f);

	const ImRect bb(pos, ImVec2(pos.x + size.x, pos.y + size.y));
	ImGui::ItemSize(size, style.FramePadding.y);
	if (!ImGui::ItemAdd(bb, id))
		return false;

	bool hovered, held;
	bool pressed = ImGui::ButtonBehavior(bb, id, &hovered, &held, 0);

	float t = selected ? 1.0f : 0.0f;

	float ANIM_SPEED = (ImGui::GetIO().Framerate / 4.f) * (1.f / ImGui::GetIO().Framerate);
	if (g.LastActiveId == g.CurrentWindow->GetID(label))// && g.LastActiveIdTimer < ANIM_SPEED)
	{
		float t_anim = ImSaturate(g.LastActiveIdTimer / ANIM_SPEED);
		t = selected ? (t_anim) : (1.0f - t_anim);
	}

	ImU32 bg_col = ImGui::GetColorU32(ImLerp(ImVec4(cvar.visual_menu_color_items[0], cvar.visual_menu_color_items[1], cvar.visual_menu_color_items[2], 0.f), ImVec4(cvar.visual_menu_color_tab_selected[0], cvar.visual_menu_color_tab_selected[1], cvar.visual_menu_color_tab_selected[2], Sakura::Menu::currentAlphaFade / 255.f), t));

	if (selected)
		window->DrawList->AddRectFilled(bb.Min, bb.Max, bg_col);

	ImGui::PushFont(Sakura::Menu::Fonts::titleTabFont);
	window->DrawList->AddText(ImVec2(bb.Min.x + 35, bb.Min.y + 19), ImColor(255 / 255.f, 255 / 255.f, 255 / 255.f, Sakura::Menu::currentAlphaFade / 255.f), label);
	ImGui::PopFont();

	ImGui::PushFont(Sakura::Menu::Fonts::icons);
	window->DrawList->AddText(ImVec2(bb.Min.x + 5, bb.Min.y + size_arg.y / 2 - ImGui::CalcTextSize(icon).y / 2), GetMenuColor(Sakura::Menu::currentAlphaFade / 255.f), icon);
	ImGui::PopFont();

	return pressed;
}

bool Sakura::Menu::Widgets::SubTab(const char* label, const ImVec2& size_arg, const bool selected)
{
	ImGuiWindow* window = ImGui::GetCurrentWindow();
	if (window->SkipItems)
		return false;

	static float sizeplus = 0.f;

	ImGuiContext& g = *GImGui;
	const ImGuiStyle& style = g.Style;
	const ImGuiID id = window->GetID(label);
	const ImVec2 label_size = ImGui::CalcTextSize(label, NULL, true);

	ImVec2 pos = window->DC.CursorPos;

	ImVec2 size = ImGui::CalcItemSize(size_arg, label_size.x + style.FramePadding.x * 2.0f, label_size.y + style.FramePadding.y * 2.0f);

	const ImRect bb(pos, ImVec2(pos.x + size.x, pos.y + size.y));
	ImGui::ItemSize(size, style.FramePadding.y);
	if (!ImGui::ItemAdd(bb, id))
		return false;

	bool hovered, held;
	bool pressed = ImGui::ButtonBehavior(bb, id, &hovered, &held, 0);

	float t = selected ? 1.0f : 0.0f;

	float ANIM_SPEED = (ImGui::GetIO().Framerate / 4.f) * (1.f / ImGui::GetIO().Framerate);
	if (g.LastActiveId == g.CurrentWindow->GetID(label))
	{
		float t_anim = ImSaturate(g.LastActiveIdTimer / ANIM_SPEED);
		t = selected ? (t_anim) : (1.0f - t_anim);
	}

	ImU32 bg_col = ImGui::GetColorU32(ImLerp(ImVec4(cvar.visual_menu_color_widgets[0], cvar.visual_menu_color_widgets[1], cvar.visual_menu_color_widgets[2], 0.f), ImVec4(cvar.visual_menu_color_subtab_selected[0], cvar.visual_menu_color_subtab_selected[1], cvar.visual_menu_color_subtab_selected[2], Sakura::Menu::currentAlphaFade / 255.f), t));
	ImU32 bg_col2 = ImGui::GetColorU32(ImLerp(ImVec4(cvar.visual_menu_color_widgets[0], cvar.visual_menu_color_widgets[1], cvar.visual_menu_color_widgets[2], 0.f), GetMenuColor(Sakura::Menu::currentAlphaFade / 255.f), t));

	if (selected)
	{
		window->DrawList->AddRectFilled({ bb.Min.x,bb.Min.y }, { bb.Max.x,bb.Max.y }, bg_col);
		window->DrawList->AddRectFilled({ bb.Max.x,bb.Max.y }, { bb.Max.x - 3,bb.Min.y }, bg_col2);
	}

	ImGui::PushFont(Sakura::Menu::Fonts::titleTabFont);
	window->DrawList->AddText(ImVec2(bb.Min.x + 5, bb.Min.y + size_arg.y / 2 - ImGui::CalcTextSize(label).y / 2), ImColor(255 / 255.f, 255 / 255.f, 255 / 255.f, Sakura::Menu::currentAlphaFade / 255.f), label);
	ImGui::PopFont();

	return pressed;
}

bool Sakura::Menu::Widgets::SubSubTab(const char* icon, const char* label, const ImVec2& size_arg, const bool selected, ImFont* customFont)
{
	ImGuiWindow* window = ImGui::GetCurrentWindow();
	if (window->SkipItems)
		return false;

	static float sizeplus = 0.f;

	ImGuiContext& g = *GImGui;
	const ImGuiStyle& style = g.Style;
	const ImGuiID id = window->GetID(label);
	const ImVec2 label_size = ImGui::CalcTextSize(label, NULL, true);

	ImVec2 pos = window->DC.CursorPos;

	ImVec2 size = ImGui::CalcItemSize(size_arg, label_size.x + style.FramePadding.x * 2.f, label_size.y + style.FramePadding.y * 2.f);

	const ImRect bb(pos, ImVec2(pos.x + size.x, pos.y + size.y));
	ImGui::ItemSize(size, style.FramePadding.y);
	if (!ImGui::ItemAdd(bb, id))
		return false;

	bool hovered, held;
	bool pressed = ImGui::ButtonBehavior(bb, id, &hovered, &held, 0);

	float t = selected ? 1.0f : 0.0f;

	float ANIM_SPEED = (ImGui::GetIO().Framerate / 4.f) * (1.f / ImGui::GetIO().Framerate);
	if (g.LastActiveId == g.CurrentWindow->GetID(label))
	{
		float t_anim = ImSaturate(g.LastActiveIdTimer / ANIM_SPEED);
		t = selected ? (t_anim) : (1.0f - t_anim);
	}

	ImU32 bg_col = ImGui::GetColorU32(ImLerp(ImVec4(1.f, 1.f, 1.f, 0.f), GetMenuColor(Sakura::Menu::currentAlphaFade / 255.f), t));

	ImGui::PushFont(customFont ? customFont : Sakura::Menu::Fonts::icons);
	window->DrawList->AddText(ImVec2(bb.Min.x + size_arg.x / 2 - ImGui::CalcTextSize(icon).x / 2, bb.Min.y + size_arg.y / 2 - ImGui::CalcTextSize(icon).y / 2), ImColor(255 / 255.f, 255 / 255.f, 255 / 255.f, Sakura::Menu::currentAlphaFade / 255.f), icon);

	if (selected)
		window->DrawList->AddText(ImVec2(bb.Min.x + size_arg.x / 2 - ImGui::CalcTextSize(icon).x / 2, bb.Min.y + size_arg.y / 2 - ImGui::CalcTextSize(icon).y / 2), bg_col, icon);
	
	ImGui::PopFont();

	if (hovered)
	{
		ImGui::BeginTooltip();
		ImGui::Text(label);
		ImGui::EndTooltip();
	}

	return pressed;
}

bool Sakura::Menu::Widgets::Checkbox(const char* label, float* v)
{
	ImGuiWindow* window = ImGui::GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImGuiContext& g = *GImGui;
	const ImGuiStyle& style = g.Style;
	const ImGuiID id = window->GetID(label);
	const ImVec2 label_size = ImGui::CalcTextSize(label, NULL, true);

	float last_active_id_timer = g.LastActiveIdTimer;

	const float square_sz = ImGui::GetFrameHeight();
	const ImVec2 pos = window->DC.CursorPos;
	const ImRect total_bb(pos, ImVec2(pos.x + square_sz + (label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f), pos.y + label_size.y + style.FramePadding.y * 2.0f));
	ImGui::ItemSize(total_bb, style.FramePadding.y);
	if (!ImGui::ItemAdd(total_bb, id))
		return false;

	bool hovered, held;
	bool pressed = ImGui::ButtonBehavior(total_bb, id, &hovered, &held);
	if (pressed)
	{
		*v = !(*v);
		g.LastActiveIdTimer = 0.0f;
		ImGui::MarkItemEdited(id);
	}

	const ImRect check_bb(pos, ImVec2(pos.x + square_sz, pos.y + square_sz));

	if (g.LastActiveIdTimer == 0.0f && g.LastActiveId == g.CurrentWindow->GetID(label) && !pressed)
		g.LastActiveIdTimer = last_active_id_timer;

	float t = *v ? 1.0f : 0.0f;

	float ANIM_SPEED = (ImGui::GetIO().Framerate / 8.f) * (1.f / ImGui::GetIO().Framerate);
	if (g.LastActiveId == g.CurrentWindow->GetID(label))// && g.LastActiveIdTimer < ANIM_SPEED)
	{
		float t_anim = ImSaturate(g.LastActiveIdTimer / ANIM_SPEED);
		t = *v ? (t_anim) : (1.0f - t_anim);
	}

	ImU32 col_bg = ImGui::GetColorU32(ImVec4(120 / 255.f, 120 / 255.f, 120 / 255.f, 120 / 255.f));
	ImU32 col_bg2 = ImGui::GetColorU32(ImLerp(ImVec4(190 / 255.f, 190 / 255.f, 190 / 255.f, 0.f), ImVec4(GetMenuColor()), t));
	ImU32 col_bg3 = ImGui::GetColorU32(ImLerp(ImVec4(190 / 255.f, 190 / 255.f, 190 / 255.f, 0.f), ImVec4(1.f, 1.f, 1.f, 1.f), t));

	window->DrawList->AddRect(check_bb.Min, check_bb.Max, col_bg, 4.f, 15, 2.f);
	window->DrawList->AddRectFilled(check_bb.Min, check_bb.Max, col_bg2, 4.f);

	if (v)
	{
		Sakura::Menu::Widgets::Helpers::RenderCheckMar1k(ImVec2{ check_bb.Min.x + 4,check_bb.Min.y + 4 }, col_bg3, square_sz - 8);
	}

	if (label_size.x > 0.0f)
		ImGui::RenderText(ImVec2(check_bb.Max.x + style.ItemInnerSpacing.x, check_bb.Min.y + style.FramePadding.y), label);

	return pressed;
}

bool Sakura::Menu::Widgets::SliderScalar(const char* label, ImGuiDataType data_type, void* p_data, const void* p_min, const void* p_max, const char* format)
{
	ImGuiWindow* window = ImGui::GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImGuiContext& g = *GImGui;
	const ImGuiStyle& style = g.Style;
	const ImGuiID id = window->GetID(label);
	const float w = ImGui::CalcItemWidth();

	const ImVec2 label_size = ImGui::CalcTextSize(label, NULL, true);
	const ImRect frame_bb(window->DC.CursorPos, ImVec2(window->DC.CursorPos.x + w, window->DC.CursorPos.y + label_size.y + style.FramePadding.y * 2.0f + 10));
	const ImRect total_bb(frame_bb.Min, ImVec2(frame_bb.Max.x + label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, frame_bb.Max.y + 0.0f));

	ImGui::ItemSize(total_bb, style.FramePadding.y);
	ImGui::ItemAdd(total_bb, id, &frame_bb);


	// Default format string when passing NULL
	if (format == NULL)
		format = ImGui::DataTypeGetInfo(data_type)->PrintFmt;
	else if (data_type == ImGuiDataType_S32 && strcmp(format, "%d") != 0)
		format = Sakura::Menu::Widgets::Helpers::PatchFormatStringFloatToInt(format);

	// Tabbing or CTRL-clicking on Slider turns it into an input box
	const bool hovered = ImGui::ItemHoverable(frame_bb, id);
	bool temp_input_is_active = ImGui::TempInputIsActive(id);
	if (!temp_input_is_active)
	{
		// Tabbing or CTRL-clicking on Slider turns it into an input box
		const bool input_requested_by_tabbing =  (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_FocusedByTabbing) != 0;
		const bool clicked = hovered && ImGui::IsMouseClicked(0, id);
		const bool make_active = (input_requested_by_tabbing || clicked || g.NavActivateId == id);
		if (make_active && clicked)
			ImGui::SetKeyOwner(ImGuiKey_MouseLeft, id);
		if (make_active)
			if (input_requested_by_tabbing || (clicked && g.IO.KeyCtrl) || (g.NavActivateId == id && (g.NavActivateFlags & ImGuiActivateFlags_PreferInput)))
				temp_input_is_active = true;

		if (make_active && !temp_input_is_active)
		{
			ImGui::SetActiveID(id, window);
			ImGui::SetFocusID(id, window);
			ImGui::FocusWindow(window);
			g.ActiveIdUsingNavDirMask |= (1 << ImGuiDir_Left) | (1 << ImGuiDir_Right);
		}
	}

	if (temp_input_is_active)
	{
		// Only clamp CTRL+Click input when ImGuiSliderFlags_AlwaysClamp is set
		const bool is_clamp_input = (0 & ImGuiSliderFlags_AlwaysClamp) != 0;
		return ImGui::TempInputScalar(frame_bb, id, label, data_type, p_data, format, is_clamp_input ? p_min : NULL, is_clamp_input ? p_max : NULL);
	}

	ImGui::RenderNavHighlight(frame_bb, id);
	window->DrawList->AddRectFilled(ImVec2{ frame_bb.Min.x,frame_bb.Min.y + 7 + 10 }, ImVec2{ frame_bb.Max.x,frame_bb.Max.y - 3 }, ImColor((int)(cvar.visual_menu_slider_bg_color[0] * 255), (int)(cvar.visual_menu_slider_bg_color[1] * 255), (int)(cvar.visual_menu_slider_bg_color[2] * 255), Sakura::Menu::currentAlphaFade), 6.f);

	ImRect grab_bb;
	const bool value_changed = ImGui::SliderBehavior(frame_bb, id, data_type, p_data, p_min, p_max, format/*, power*/, ImGuiSliderFlags_None, &grab_bb);
	if (value_changed)
		ImGui::MarkItemEdited(id);

	float t = hovered ? 1.0f : 0.0f;

	float ANIM_SPEED = (ImGui::GetIO().Framerate / 8.f) * (1.f / ImGui::GetIO().Framerate);
	if (g.LastActiveId == g.CurrentWindow->GetID(label))
	{
		float t_anim = ImSaturate(g.LastActiveIdTimer / ANIM_SPEED);
		t = hovered ? (t_anim) : (1.0f - t_anim);
	}

	ImU32 col_bg;

	col_bg = ImGui::GetColorU32(ImLerp((ImVec4)GetMenuColor(0.65f), GetMenuColor(Sakura::Menu::currentAlphaFade / 255.f), t));

	// Render grab
	window->DrawList->AddRectFilled(ImVec2{ frame_bb.Min.x,frame_bb.Min.y + 7 + 10 }, ImVec2{ grab_bb.Min.x + 12,grab_bb.Max.y - 1 }, col_bg, 6.f);

	// Display value using user-provided display format so user can add prefix/suffix/decorations to the value.
	char value_buf[64];
	const char* value_buf_end = value_buf + ImGui::DataTypeFormatString(value_buf, IM_ARRAYSIZE(value_buf), data_type, p_data, format);

	if (label_size.x > 0.0f)
		ImGui::RenderText(ImVec2(frame_bb.Min.x, frame_bb.Min.y + 1), label);

	if (label_size.x > 0.0f)
		ImGui::RenderText(ImVec2(frame_bb.Max.x - ImGui::CalcTextSize(value_buf).x, frame_bb.Min.y + 1), value_buf);

	return value_changed;
}

bool Sakura::Menu::Widgets::SliderFloat(const char* label, float* v, float v_min, float v_max, const char* format)
{
	return SliderScalar(label, ImGuiDataType_Float, v, &v_min, &v_max, format);
}

bool Sakura::Menu::Widgets::SliderInt(const char* label, int* v, int v_min, int v_max, const char* format)
{
	return SliderScalar(label, ImGuiDataType_S32, v, &v_min, &v_max, format);
}

bool Sakura::Menu::Widgets::Button(const char* label, const ImVec2& size_arg, ImGuiButtonFlags flags)
{
	ImGuiWindow* window = ImGui::GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImGuiContext& g = *GImGui;
	const ImGuiStyle& style = g.Style;
	const ImGuiID id = window->GetID(label);
	const ImVec2 label_size = ImGui::CalcTextSize(label, NULL, true);

	ImVec2 pos = window->DC.CursorPos;
	if ((flags & ImGuiButtonFlags_AlignTextBaseLine) && style.FramePadding.y < window->DC.CurrLineTextBaseOffset) // Try to vertically align buttons that are smaller/have no padding so that text baseline matches (bit hacky, since it shouldn't be a flag)
		pos.y += window->DC.CurrLineTextBaseOffset - style.FramePadding.y;
	ImVec2 size = ImGui::CalcItemSize(size_arg, label_size.x + style.FramePadding.x * 2.0f, label_size.y + style.FramePadding.y * 2.0f);

	const ImRect bb(pos, { pos.x + size.x, pos.y + size.y });
	ImGui::ItemSize(size, style.FramePadding.y);
	if (!ImGui::ItemAdd(bb, id))
		return false;

	if (window->Flags & ImGuiItemFlags_ButtonRepeat)
		flags |= ImGuiButtonFlags_Repeat;
	bool hovered, held;
	bool pressed = ImGui::ButtonBehavior(bb, id, &hovered, &held, flags);

	ImU32 col;
	// Render
	if (hovered)
		col = GetMenuColor();
	else
		col = ImColor(120, 120, 120, 120);

	window->DrawList->AddRectFilled(bb.Min, bb.Max, col, 4, 15);
	if (held) window->DrawList->AddRectFilled(bb.Min, bb.Max, col, 4, 15);
	ImGui::RenderTextClipped({ bb.Min.x + style.FramePadding.x, bb.Min.y + style.FramePadding.y }, { bb.Max.x - style.FramePadding.x,  bb.Max.y - style.FramePadding.y }, label, NULL, &label_size, style.ButtonTextAlign, &bb);

	return pressed;
}

bool Sakura::Menu::Widgets::BeginCombo(const char* label, const char* preview_value, ImGuiComboFlags flags)
{
	// Always consume the SetNextWindowSizeConstraint() call in our early return paths
	ImGuiContext& g = *GImGui;
	bool has_window_size_constraint = (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSizeConstraint) != 0;
	g.NextWindowData.Flags &= ~ImGuiNextWindowDataFlags_HasSizeConstraint;

	ImGuiWindow* window = ImGui::GetCurrentWindow();
	if (window->SkipItems)
		return false;

	IM_ASSERT((flags & (ImGuiComboFlags_NoArrowButton | ImGuiComboFlags_NoPreview)) != (ImGuiComboFlags_NoArrowButton | ImGuiComboFlags_NoPreview)); // Can't use both flags together

	const ImGuiStyle& style = g.Style;
	const ImGuiID id = window->GetID(label);

	const float arrow_size = (flags & ImGuiComboFlags_NoArrowButton) ? 0.0f : ImGui::GetFrameHeight();
	const ImVec2 label_size = ImGui::CalcTextSize(label, NULL, true);
	const float expected_w = ImGui::CalcItemWidth();
	const float w = (flags & ImGuiComboFlags_NoPreview) ? arrow_size : expected_w;
	const ImRect frame_bb(window->DC.CursorPos, ImVec2(window->DC.CursorPos.x + w, window->DC.CursorPos.y + label_size.y + style.FramePadding.y * 2.0f + 10));
	const ImRect total_bb(frame_bb.Min, ImVec2(frame_bb.Max.x + label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, frame_bb.Max.y + 0.0f));
	ImGui::ItemSize(total_bb, style.FramePadding.y);
	ImGui::ItemAdd(total_bb, id, &frame_bb);


	bool hovered, held;
	bool pressed = ImGui::ButtonBehavior(frame_bb, id, &hovered, &held);
	bool popup_open = ImGui::IsPopupOpen(label);


	const ImRect value_bb(frame_bb.Min, ImVec2(frame_bb.Max.x - arrow_size, frame_bb.Max.y - 0.0f));

	if (!(flags & ImGuiComboFlags_NoArrowButton))
	{
		ImGui::RenderArrow(window->DrawList, ImVec2(frame_bb.Max.x - arrow_size + style.FramePadding.y, frame_bb.Min.y + style.FramePadding.y + 10), Sakura::Colors::White(), popup_open ? ImGuiDir_Down : ImGuiDir_Left);
	}

	float t = popup_open ? 1.0f : 0.0f;

	float ANIM_SPEED = 0.2f;
	if (g.LastActiveId == g.CurrentWindow->GetID(label))// && g.LastActiveIdTimer < ANIM_SPEED)
	{
		float t_anim = ImSaturate(g.LastActiveIdTimer / ANIM_SPEED);
		t = popup_open ? (t_anim) : (1.0f - t_anim);
	}

	ImU32 col_bg;
	ImU32 col_bg2;
	//ImU32 col_bg3;

	col_bg = ImGui::GetColorU32(ImVec4(cvar.visual_menu_combo_bg_color[0], cvar.visual_menu_combo_bg_color[1], cvar.visual_menu_combo_bg_color[2], 120 / 255.f));
	col_bg2 = ImGui::GetColorU32((ImVec4)GetMenuColor(0.65f));

	window->DrawList->AddRectFilled({ frame_bb.Min.x, frame_bb.Min.y + 10 }, frame_bb.Max, col_bg, 3.f, 15);
	if (hovered)
		window->DrawList->AddRectFilled({ frame_bb.Min.x, frame_bb.Min.y + 10 }, frame_bb.Max, col_bg2, 3.f);

	if (preview_value != NULL && !(flags & ImGuiComboFlags_NoPreview))
		ImGui::RenderTextClipped({ frame_bb.Min.x + style.FramePadding.x,frame_bb.Min.y + style.FramePadding.y + 10 }, value_bb.Max, preview_value, NULL, NULL, ImVec2(0.0f, 0.0f));

	if (label_size.x > 0)
		ImGui::RenderText(ImVec2(frame_bb.Min.x, frame_bb.Min.y + style.FramePadding.y - 10), label);

	if ((pressed || g.NavActivateId == id) && !popup_open)
	{
		if (window->DC.NavLayerCurrent == 0)
			window->NavLastIds[0] = id;
		ImGui::OpenPopupEx(id);
		popup_open = true;
	}

	if (!popup_open)
		return false;

	if (has_window_size_constraint)
	{
		g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasSizeConstraint;
		g.NextWindowData.SizeConstraintRect.Min.x = ImMax(g.NextWindowData.SizeConstraintRect.Min.x, w);
	}
	else
	{
		if ((flags & ImGuiComboFlags_HeightMask_) == 0)
			flags |= ImGuiComboFlags_HeightRegular;
		IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiComboFlags_HeightMask_));    // Only one
		int popup_max_height_in_items = -1;
		if (flags & ImGuiComboFlags_HeightRegular)     popup_max_height_in_items = 8;
		else if (flags & ImGuiComboFlags_HeightSmall)  popup_max_height_in_items = 4;
		else if (flags & ImGuiComboFlags_HeightLarge)  popup_max_height_in_items = 20;
		ImGui::SetNextWindowSizeConstraints(ImVec2(w, 0.0f), ImVec2(FLT_MAX, Sakura::Menu::Widgets::Helpers::CalcMaxPopupHeightFromItemCount(popup_max_height_in_items)));
	}

	char name[16];
	ImFormatString(name, IM_ARRAYSIZE(name), /*##Combo_%02d*/XorStr<0x3F, 13, 0x6EB02304>("\x1C\x63\x02\x2D\x2E\x26\x2A\x19\x62\x78\x7B\x2E" + 0x6EB02304).s, g.BeginPopupStack.Size); // Recycle windows based on depth

	// Peak into expected window size so we can position it
	if (ImGuiWindow* popup_window = ImGui::FindWindowByName(name))
		if (popup_window->WasActive)
		{
			//ImVec2 size_expected = ImGui::CalcWindowExpectedSize(popup_window);
			ImVec2 size_expected = ImGui::CalcWindowNextAutoFitSize(popup_window);
			if (flags & ImGuiComboFlags_PopupAlignLeft)
				popup_window->AutoPosLastDirection = ImGuiDir_Left;
			//ImRect r_outer = ImGui::GetWindowAllowedExtentRect(popup_window);
			ImRect r_outer = ImGui::GetPopupAllowedExtentRect(popup_window);
			ImVec2 pos = ImGui::FindBestWindowPosForPopupEx(frame_bb.GetBL(), size_expected, &popup_window->AutoPosLastDirection, r_outer, frame_bb, ImGuiPopupPositionPolicy_ComboBox);
			ImGui::SetNextWindowPos(pos);
		}

	// We don't use BeginPopupEx() solely because we have a custom name string, which we could make an argument to BeginPopupEx()
	ImGuiWindowFlags window_flags = ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_Popup | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoMove;

	// Horizontally align ourselves with the framed text
	ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(style.FramePadding.x, style.WindowPadding.y));
	bool ret = ImGui::Begin(name, NULL, window_flags);
	ImGui::PopStyleVar();
	if (!ret)
	{
		ImGui::EndPopup();
		IM_ASSERT(0);   // This should never happen as we tested for IsPopupOpen() above
		return false;
	}
	return true;
}

void Sakura::Menu::Widgets::EndCombo()
{
	ImGui::EndPopup();
}

// Old API, prefer using BeginCombo() nowadays if you can.
bool Sakura::Menu::Widgets::Combo(const char* label, float* current_item, bool (*items_getter)(void*, int, const char**), void* data, int items_count, int popup_max_height_in_items)
{
	ImGuiContext& g = *GImGui;

	// Call the getter to obtain the preview string which is a parameter to BeginCombo()
	const char* preview_value = NULL;
	if (*current_item >= 0 && *current_item < items_count)
		items_getter(data, *current_item, &preview_value);

	// The old Combo() API exposed "popup_max_height_in_items". The new more general BeginCombo() API doesn't have/need it, but we emulate it here.
	if (popup_max_height_in_items != -1 && !(g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSizeConstraint))
		ImGui::SetNextWindowSizeConstraints(ImVec2(0, 0), ImVec2(FLT_MAX, Sakura::Menu::Widgets::Helpers::CalcMaxPopupHeightFromItemCount(popup_max_height_in_items)));

	if (!BeginCombo(label, preview_value, ImGuiComboFlags_None))
		return false;

	ImGui::PushStyleColor(ImGuiCol_Header, (ImVec4)Sakura::Menu::GetMenuColor(0.39f));
	ImGui::PushStyleColor(ImGuiCol_HeaderHovered, (ImVec4)Sakura::Menu::GetMenuColor(0.80f));
	ImGui::PushStyleColor(ImGuiCol_HeaderActive, (ImVec4)Sakura::Menu::GetMenuColor(1.00f));
	// Display items
	// FIXME-OPT: Use clipper (but we need to disable it on the appearing frame to make sure our call to SetItemDefaultFocus() is processed)
	bool value_changed = false;
	for (int i = 0; i < items_count; i++)
	{
		ImGui::PushID((void*)(intptr_t)i);
		const bool item_selected = (i == *current_item);
		const char* item_text;
		if (!items_getter(data, i, &item_text))
			item_text = "*Unknown item*";
		if (ImGui::Selectable(item_text, item_selected))
		{
			value_changed = true;
			*current_item = i;
		}
		if (item_selected)
			ImGui::SetItemDefaultFocus();
		ImGui::PopID();
	}
	ImGui::PopStyleColor(3);

	EndCombo();
	return value_changed;
}

// Combo box helper allowing to pass an array of strings.
bool Sakura::Menu::Widgets::Combo(const char* label, float* current_item, const char* const items[], int items_count, int height_in_items)
{
	ImGui::Dummy(ImVec2(0, 2));
	const bool value_changed = Combo(label, current_item, Sakura::Menu::Widgets::Helpers::Items_ArrayGetter, (void*)items, items_count, height_in_items);
	return value_changed;
}

// Combo box helper allowing to pass all items in a single string literal holding multiple zero-terminated items "item1\0item2\0"
bool Sakura::Menu::Widgets::Combo(const char* label, float* current_item, const char* items_separated_by_zeros, int height_in_items)
{
	ImGui::Dummy(ImVec2(0, 2));
	int items_count = 0;
	const char* p = items_separated_by_zeros;       // FIXME-OPT: Avoid computing this, or at least only when combo is open
	while (*p)
	{
		p += strlen(p) + 1;
		items_count++;
	}
	bool value_changed = Combo(label, current_item, Sakura::Menu::Widgets::Helpers::Items_SingleStringGetter, (void*)items_separated_by_zeros, items_count, height_in_items);
	return value_changed;
}

bool Sakura::Menu::Widgets::ColorEdit(const char* label, float* color, ImGuiColorEditFlags flags)
{
	ImGui::PushStyleColor(ImGuiCol_FrameBg, (ImVec4)Sakura::Menu::GetMenuColor(0.39f));
	ImGui::PushStyleColor(ImGuiCol_FrameBgHovered, (ImVec4)Sakura::Menu::GetMenuColor(0.80f));
	ImGui::PushStyleColor(ImGuiCol_FrameBgActive, (ImVec4)Sakura::Menu::GetMenuColor(1.00f));
	ImGui::ColorEdit4(label, color, flags);
	ImGui::PopStyleColor(3);
	ImGui::SameLine();
	ImGui::Text(label);
	return true;
}
```

`sakura/source/features/visuals/menu/menu_widgets.h`:

```h
#pragma once

namespace Sakura
{
	namespace Menu
	{
		namespace Widgets
		{
			namespace Helpers
			{
				void RenderCheckMar1k(ImVec2 pos, ImU32 col, float sz);
				static bool Items_ArrayGetter(void* data, int idx, const char** out_text);
				static bool Items_SingleStringGetter(void* data, int idx, const char** out_text);
				static float CalcMaxPopupHeightFromItemCount(int items_count);
				static const char* PatchFormatStringFloatToInt(const char* fmt);

			};

			bool Combo(const char* label, float* current_item, const char* const items[], int items_count, int height_in_items = -1);
			bool Combo(const char* label, float* current_item, const char* items_separated_by_zeros, int popup_max_height_in_items = -1);      // Separate items with \0 within a string, end item-list with \0\0. e.g. "One\0Two\0Three\0"
			bool Combo(const char* label, float* current_item, bool(*items_getter)(void* data, int idx, const char** out_text), void* data, int items_count, int popup_max_height_in_items = -1);

			bool ColorEdit(const char* label, float* color, ImGuiColorEditFlags flags = 0);

			bool Tab(const char* icon, const char* label, const ImVec2& size_arg, const bool selected);
			bool SubTab(const char* label, const ImVec2& size_arg, const bool selected);
			bool SubSubTab(const char* icon, const char* label, const ImVec2& size_arg, const bool selected, ImFont* customFont = nullptr);
			bool Checkbox(const char* label, float* v);
			bool SliderScalar(const char* label, ImGuiDataType data_type, void* p_data, const void* p_min, const void* p_max, const char* format);
			bool SliderFloat(const char* label, float* v, float v_min, float v_max, const char* format);
			bool SliderInt(const char* label, int* v, int v_min, int v_max, const char* format);
			bool Button(const char* label, const ImVec2& size_arg = {}, ImGuiButtonFlags flags = NULL);
			bool BeginCombo(const char* label, const char* preview_value, ImGuiComboFlags flags);
			void EndCombo();
		};
	};
};
```

`sakura/source/features/visuals/menu/tabs/menu_colors_tab.cpp`:

```cpp
#include "../../../../client.h"

auto pickerFlags = ImGuiColorEditFlags_NoDragDrop | ImGuiColorEditFlags_PickerHueWheel | ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_NoLabel | ImGuiColorEditFlags_AlphaBar;
int playerSplit = 0;
int localPlayerSplit = 0;
int worldSplit = 0;

void Sakura::Menu::Tabs::Colors::Player()
{
	if (Sakura::Menu::Widgets::SubSubTab(/*C*/XorStr<0x9D, 2, 0x8DF2BA10>("\xDE" + 0x8DF2BA10).s, /*Esp*/XorStr<0x20, 4, 0xE1D06C51>("\x65\x52\x52" + 0xE1D06C51).s, ImVec2(65, 40), playerSplit == 0 ? true : false))
		playerSplit = 0;
	ImGui::SameLine();
	if (Sakura::Menu::Widgets::SubSubTab(/*K*/XorStr<0x13, 2, 0xD90A84A2>("\x58" + 0xD90A84A2).s, /*Sound esp*/XorStr<0x60, 10, 0xFD00C6EC>("\x33\x0E\x17\x0D\x00\x45\x03\x14\x18" + 0xFD00C6EC).s, ImVec2(65, 40), playerSplit == 1 ? true : false))
		playerSplit = 1;
	ImGui::SameLine();
	if (Sakura::Menu::Widgets::SubSubTab(/*B*/XorStr<0xB4, 2, 0x0FABC5D3>("\xF6" + 0x0FABC5D3).s, /*Chams*/XorStr<0x39, 6, 0x82488EAF>("\x7A\x52\x5A\x51\x4E" + 0x82488EAF).s, ImVec2(65, 40), playerSplit == 2 ? true : false))
		playerSplit = 2;
	ImGui::SameLine();
	if (Sakura::Menu::Widgets::SubSubTab(/*A*/XorStr<0xEE, 2, 0x5B7CBE0B>("\xAF" + 0x5B7CBE0B).s, /*Glow*/XorStr<0x11, 5, 0x06588C88>("\x56\x7E\x7C\x63" + 0x06588C88).s, ImVec2(65, 40), playerSplit == 3 ? true : false))
		playerSplit = 3;
	ImGui::SameLine();
	if (Sakura::Menu::Widgets::SubSubTab(/*H*/XorStr<0x44, 2, 0x8FF4FCBA>("\x0C" + 0x8FF4FCBA).s, /*Light*/XorStr<0x72, 6, 0xC06F61A6>("\x3E\x1A\x13\x1D\x02" + 0xC06F61A6).s, ImVec2(65, 40), playerSplit == 4 ? true : false))
		playerSplit = 4;
	ImGui::SameLine();
	if (Sakura::Menu::Widgets::SubSubTab(/*J*/XorStr<0x35, 2, 0xC48D0C62>("\x7F" + 0xC48D0C62).s, /*Deathmark*/XorStr<0x2B, 10, 0x0C7E5E0E>("\x6F\x49\x4C\x5A\x47\x5D\x50\x40\x58" + 0x0C7E5E0E).s, ImVec2(65, 40), playerSplit == 5 ? true : false))
		playerSplit = 5;
	ImGui::SameLine();
	if (Sakura::Menu::Widgets::SubSubTab(/*D*/XorStr<0x2C, 2, 0xAE5357B5>("\x68" + 0xAE5357B5).s, /*Backtrack*/XorStr<0xCC, 10, 0x2F788681>("\x8E\xAC\xAD\xA4\xA4\xA3\xB3\xB0\xBF" + 0x2F788681).s, ImVec2(65, 40), playerSplit == 6 ? true : false))
		playerSplit = 6;

	ImGui::Spacing();

	switch (static_cast<int>(playerSplit))
	{
	case 0:
		Sakura::Menu::Tabs::Colors::PlayerEsp();
		break;
	case 1:
		Sakura::Menu::Tabs::Colors::PlayerSoundEsp();
		break;
	case 2:
		Sakura::Menu::Tabs::Colors::PlayerChams();
		break;
	case 3:
		Sakura::Menu::Tabs::Colors::PlayerGlow();
		break;
	case 4:
		Sakura::Menu::Tabs::Colors::PlayerLight();
		break;
	case 5:
		Sakura::Menu::Tabs::Colors::PlayerDeathmark();
		break;
	case 6:
		Sakura::Menu::Tabs::Colors::PlayerBacktrack();
		break;
	}
}

void Sakura::Menu::Tabs::Colors::PlayerEsp()
{
	ImGui::BeginChild(/*##mc1*/XorStr<0x35, 6, 0x8CE92DC1>("\x16\x15\x5A\x5B\x08" + 0x8CE92DC1).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::Checkbox(/*##bttr*/XorStr<0x36, 7, 0x2722A944>("\x15\x14\x5A\x4D\x4E\x49" + 0x2722A944).s, &cvar.rainbow_box_tt);
		ImGui::SameLine();
		Sakura::Menu::Widgets::ColorEdit(/*Box TT*/XorStr<0xB2, 7, 0xD516DA9C>("\xF0\xDC\xCC\x95\xE2\xE3" + 0xD516DA9C).s, (float*)cvar.visual_box_color_tt, pickerFlags);
		Sakura::Menu::Widgets::Checkbox(/*##bctr*/XorStr<0xBC, 7, 0x81CBF1AD>("\x9F\x9E\xDC\xDC\xB4\xB3" + 0x81CBF1AD).s, &cvar.rainbow_box_ct);
		ImGui::SameLine();
		Sakura::Menu::Widgets::ColorEdit(/*Box CT*/XorStr<0x53, 7, 0x9E4A92EB>("\x11\x3B\x2D\x76\x14\x0C" + 0x9E4A92EB).s, (float*)cvar.visual_box_color_ct, pickerFlags);

		ImGui::Spacing();
		ImGui::Spacing();

		Sakura::Menu::Widgets::Checkbox(/*##strtt*/XorStr<0x83, 8, 0xE6DB7421>("\xA0\xA7\xF6\xF2\xF5\xFC\xFD" + 0xE6DB7421).s, &cvar.rainbow_skeleton_tt);
		ImGui::SameLine();
		Sakura::Menu::Widgets::ColorEdit(/*Skeleton TT*/XorStr<0x1D, 12, 0xF91F26A1>("\x4E\x75\x7A\x4C\x44\x56\x4C\x4A\x05\x72\x73" + 0xF91F26A1).s, (float*)cvar.skeleton_player_bone_color_tt, pickerFlags);
		Sakura::Menu::Widgets::Checkbox(/*##strct*/XorStr<0x87, 8, 0x843760EC>("\xA4\xAB\xFA\xFE\xF9\xEF\xF9" + 0x843760EC).s, &cvar.rainbow_skeleton_ct);
		ImGui::SameLine();
		Sakura::Menu::Widgets::ColorEdit(/*Skeleton CT*/XorStr<0xEC, 12, 0xD47352A4>("\xBF\x86\x8B\x83\x95\x85\x9D\x9D\xD4\xB6\xA2" + 0xD47352A4).s, (float*)cvar.skeleton_player_bone_color_ct, pickerFlags);

		ImGui::Spacing();
		ImGui::Spacing();

		Sakura::Menu::Widgets::ColorEdit(/*Hitbox TT*/XorStr<0x0F, 10, 0x2D550465>("\x47\x79\x65\x70\x7C\x6C\x35\x42\x43" + 0x2D550465).s, (float*)cvar.skeleton_player_hitbox_color_tt, pickerFlags);
		Sakura::Menu::Widgets::ColorEdit(/*Hitbox CT*/XorStr<0xE2, 10, 0x063744E4>("\xAA\x8A\x90\x87\x89\x9F\xC8\xAA\xBE" + 0x063744E4).s, (float*)cvar.skeleton_player_hitbox_color_ct, pickerFlags);
	}
	ImGui::EndChild();
	ImGui::SameLine();
	ImGui::BeginChild(/*##mc2*/XorStr<0x1F, 6, 0x114656A9>("\x3C\x03\x4C\x41\x11" + 0x114656A9).s, ImVec2(250, -1));
	{
		ImGui::Spacing();
		ImGui::Spacing();

		Sakura::Menu::Widgets::Checkbox(/*##slc4*/XorStr<0xB7, 7, 0x88F5B95C>("\x94\x9B\xCA\xD6\xD8\x88" + 0x88F5B95C).s, &cvar.rainbow_snaplines_tt);
		ImGui::SameLine();
		Sakura::Menu::Widgets::ColorEdit(/*Snaplines TT*/XorStr<0x5C, 13, 0x6ECA0EE1>("\x0F\x33\x3F\x2F\x0C\x08\x0C\x06\x17\x45\x32\x33" + 0x6ECA0EE1).s, (float*)cvar.visual_lines_color_tt, pickerFlags);

		Sakura::Menu::Widgets::Checkbox(/*##slc5*/XorStr<0x80, 7, 0x3B9F9FEB>("\xA3\xA2\xF1\xEF\xE7\xB0" + 0x3B9F9FEB).s, &cvar.rainbow_snaplines_ct);
		ImGui::SameLine();
		Sakura::Menu::Widgets::ColorEdit(/*Snaplines CT*/XorStr<0xC3, 13, 0xFEA1FF12>("\x90\xAA\xA4\xB6\xAB\xA1\xA7\xAF\xB8\xEC\x8E\x9A" + 0xFEA1FF12).s, (float*)cvar.visual_lines_color_ct, pickerFlags);

		ImGui::Spacing();
		ImGui::Spacing();

		Sakura::Menu::Widgets::ColorEdit(/*Line of Sight*/XorStr<0x62, 14, 0xE4266453>("\x2E\x0A\x0A\x00\x46\x08\x0E\x49\x39\x02\x0B\x05\x1A" + 0xE4266453).s, (float*)cvar.visual_line_of_sight_color, pickerFlags);
	}
	ImGui::EndChild();
}

void Sakura::Menu::Tabs::Colors::PlayerSoundEsp()
{
	ImGui::BeginChild(/*##vlc1*/XorStr<0x24, 7, 0x257B1DB3>("\x07\x06\x50\x4B\x4B\x18" + 0x257B1DB3).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::ColorEdit(/*TT Steps*/XorStr<0x26, 9, 0xE3867BED>("\x72\x73\x08\x7A\x5E\x4E\x5C\x5E" + 0xE3867BED).s, (float*)cvar.visual_sound_steps_color_tt, pickerFlags);
		Sakura::Menu::Widgets::ColorEdit(/*CT Steps*/XorStr<0x89, 9, 0xCFBC6731>("\xCA\xDE\xAB\xDF\xF9\xEB\xFF\xE3" + 0xCFBC6731).s, (float*)cvar.visual_sound_steps_color_ct, pickerFlags);
	}
	ImGui::EndChild();
	ImGui::SameLine();
	ImGui::BeginChild(/*##vlc2*/XorStr<0x4F, 7, 0x57AFCE8E>("\x6C\x73\x27\x3E\x30\x66" + 0x57AFCE8E).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::ColorEdit(/*No index*/XorStr<0x09, 9, 0xBE3404AB>("\x47\x65\x2B\x65\x63\x6A\x6A\x68" + 0xBE3404AB).s, (float*)cvar.visual_sound_steps_color, pickerFlags);
	}
	ImGui::EndChild();
}

void Sakura::Menu::Tabs::Colors::PlayerGlow()
{
	ImGui::BeginChild(/*##vlc1*/XorStr<0x6F, 7, 0xEBBB8C24>("\x4C\x53\x07\x1E\x10\x45" + 0xEBBB8C24).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::Checkbox(/*##gttrc*/XorStr<0xD0, 8, 0x31AD4663>("\xF3\xF2\xB5\xA7\xA0\xA7\xB5" + 0x31AD4663).s, &cvar.rainbow_glow_player_tt);
		ImGui::SameLine();
		Sakura::Menu::Widgets::ColorEdit(/*Glow TT*/XorStr<0xE9, 8, 0xF7E88370>("\xAE\x86\x84\x9B\xCD\xBA\xBB" + 0xF7E88370).s, (float*)cvar.visual_player_glow_color_tt, pickerFlags);

		Sakura::Menu::Widgets::Checkbox(/*##gctrc*/XorStr<0xD7, 8, 0x8410B77C>("\xF4\xFB\xBE\xB9\xAF\xAE\xBE" + 0x8410B77C).s, &cvar.rainbow_glow_player_ct);
		ImGui::SameLine();
		Sakura::Menu::Widgets::ColorEdit(/*Glow CT*/XorStr<0x91, 8, 0xC2FF6E86>("\xD6\xFE\xFC\xE3\xB5\xD5\xC3" + 0xC2FF6E86).s, (float*)cvar.visual_player_glow_color_ct, pickerFlags);
	}
	ImGui::EndChild();
	ImGui::SameLine();
	ImGui::BeginChild(/*##vlc2*/XorStr<0xED, 7, 0x379E7315>("\xCE\xCD\x99\x9C\x92\xC0" + 0x379E7315).s, ImVec2(250, -1));
	{

	}
	ImGui::EndChild();
}

void Sakura::Menu::Tabs::Colors::PlayerChams()
{
	ImGui::BeginChild(/*##vlc1*/XorStr<0x24, 7, 0x257B1DB3>("\x07\x06\x50\x4B\x4B\x18" + 0x257B1DB3).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::Checkbox(/*##cttc*/XorStr<0x26, 7, 0xCE5EF5F2>("\x05\x04\x4B\x5D\x5E\x48" + 0xCE5EF5F2).s, &cvar.rainbow_chams_player_tt);
		ImGui::SameLine();
		Sakura::Menu::Widgets::ColorEdit(/*Chams TT*/XorStr<0x79, 9, 0x0AB783C4>("\x3A\x12\x1A\x11\x0E\x5E\x2B\xD4" + 0x0AB783C4).s, (float*)cvar.chams_player_color_tt, pickerFlags);

		Sakura::Menu::Widgets::Checkbox(/*##cctc*/XorStr<0x8F, 7, 0x9D8387DD>("\xAC\xB3\xF2\xF1\xE7\xF7" + 0x9D8387DD).s, &cvar.rainbow_chams_player_ct);
		ImGui::SameLine();
		Sakura::Menu::Widgets::ColorEdit(/*Chams CT*/XorStr<0x88, 9, 0x2824772A>("\xCB\xE1\xEB\xE6\xFF\xAD\xCD\xDB" + 0x2824772A).s, (float*)cvar.chams_player_color_ct, pickerFlags);
	}
	ImGui::EndChild();
	ImGui::SameLine();
	ImGui::BeginChild(/*##vlc2*/XorStr<0x4F, 7, 0x57AFCE8E>("\x6C\x73\x27\x3E\x30\x66" + 0x57AFCE8E).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::ColorEdit(/*Chams TT Behind Wall*/XorStr<0x20, 21, 0x51517B53>("\x63\x49\x43\x4E\x57\x05\x72\x73\x08\x6B\x4F\x43\x45\x43\x4A\x0F\x67\x50\x5E\x5F" + 0x51517B53).s, (float*)cvar.chams_player_wall_color_tt, pickerFlags);
		Sakura::Menu::Widgets::ColorEdit(/*Chams CT Behind Wall*/XorStr<0xB9, 21, 0xEC072509>("\xFA\xD2\xDA\xD1\xCE\x9E\xFC\x94\xE1\x80\xA6\xAC\xAC\xA8\xA3\xE8\x9E\xAB\xA7\xA0" + 0xEC072509).s, (float*)cvar.chams_player_wall_color_ct, pickerFlags);
	}
	ImGui::EndChild();
}

void Sakura::Menu::Tabs::Colors::PlayerLight()
{
	ImGui::BeginChild(/*##vlc1*/XorStr<0x2D, 7, 0x6FFB9A5E>("\x0E\x0D\x59\x5C\x52\x03" + 0x6FFB9A5E).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::Checkbox(/*##plc44*/XorStr<0x1C, 8, 0x503D6595>("\x3F\x3E\x6E\x73\x43\x15\x16" + 0x503D6595).s, &cvar.rainbow_player_light_tt);
		ImGui::SameLine();
		Sakura::Menu::Widgets::ColorEdit(/*Player Light TT*/XorStr<0x27, 16, 0x412FC83B>("\x77\x44\x48\x53\x4E\x5E\x0D\x62\x46\x57\x59\x46\x13\x60\x61" + 0x412FC83B).s, (float*)cvar.visual_lambert_color_tt, pickerFlags);

		Sakura::Menu::Widgets::Checkbox(/*##plc5*/XorStr<0x42, 7, 0x7631BA74>("\x61\x60\x34\x29\x25\x72" + 0x7631BA74).s, &cvar.rainbow_player_light_ct);
		ImGui::SameLine();
		Sakura::Menu::Widgets::ColorEdit(/*Player Light CT*/XorStr<0x1B, 16, 0x87E80DB4>("\x4B\x70\x7C\x67\x7A\x52\x01\x6E\x4A\x43\x4D\x52\x07\x6B\x7D" + 0x87E80DB4).s, (float*)cvar.visual_lambert_color_ct, pickerFlags);
	}
	ImGui::EndChild();
	ImGui::SameLine();
	ImGui::BeginChild(/*##vlc2*/XorStr<0x6D, 7, 0x63B7BDC7>("\x4E\x4D\x19\x1C\x12\x40" + 0x63B7BDC7).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::ColorEdit(/*Player Dynamic Light TT*/XorStr<0xEB, 24, 0xC716C441>("\xBB\x80\x8C\x97\x8A\x82\xD1\xB6\x8A\x9A\x94\x9B\x9E\x9B\xD9\xB6\x92\x9B\x95\x8A\xDF\x54\x55" + 0xC716C441).s, (float*)cvar.visual_player_dynamiclight_color_tt, pickerFlags);
		Sakura::Menu::Widgets::ColorEdit(/*Player Dynamic Light CT*/XorStr<0xD3, 24, 0x0B7BFEA4>("\x83\xB8\xB4\xAF\xB2\xAA\xF9\x9E\xA2\xB2\xBC\xB3\xB6\x83\xC1\xAE\x8A\x83\x8D\x92\xC7\xAB\xBD" + 0x0B7BFEA4).s, (float*)cvar.visual_player_dynamiclight_color_ct, pickerFlags);
	}
	ImGui::EndChild();
}

void Sakura::Menu::Tabs::Colors::PlayerDeathmark()
{
	ImGui::BeginChild(/*##vlc1*/XorStr<0x2D, 7, 0x6FFB9A5E>("\x0E\x0D\x59\x5C\x52\x03" + 0x6FFB9A5E).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::Checkbox(/*##dmgr*/XorStr<0xA2, 7, 0x98622F7C>("\x81\x80\xC0\xC8\xC1\xD5" + 0x98622F7C).s, &cvar.rainbow_deathmark_glow);
		ImGui::SameLine();
		Sakura::Menu::Widgets::ColorEdit(/*DeathMark*/XorStr<0x0A, 10, 0x2A869D9F>("\x4E\x6E\x6D\x79\x66\x42\x71\x63\x79" + 0x2A869D9F).s, (float*)cvar.visual_deathmark_color, pickerFlags);
	}
	ImGui::EndChild();
	ImGui::SameLine();
	ImGui::BeginChild(/*##vlc2*/XorStr<0x6D, 7, 0x63B7BDC7>("\x4E\x4D\x19\x1C\x12\x40" + 0x63B7BDC7).s, ImVec2(250, -1));
	{

	}
	ImGui::EndChild();
}

void Sakura::Menu::Tabs::Colors::PlayerBacktrack()
{
	ImGui::BeginChild(/*##vlc1*/XorStr<0x7D, 7, 0xDECA4562>("\x5E\x5D\x09\xEC\xE2\xB3" + 0xDECA4562).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::Checkbox(/*##btcr*/XorStr<0x45, 7, 0x0944265F>("\x66\x65\x25\x3C\x2A\x38" + 0x0944265F).s, &cvar.rainbow_backtrack_chams);
		ImGui::SameLine();
		Sakura::Menu::Widgets::ColorEdit(/*Backtrack Chams*/XorStr<0x7A, 16, 0x4ECADB53>("\x38\x1A\x1F\x16\x0A\x0D\xE1\xE2\xE9\xA3\xC7\xED\xE7\xEA\xFB" + 0x4ECADB53).s, (float*)cvar.misc_backtrack_chams_color, pickerFlags);
	}
	ImGui::EndChild();
	ImGui::SameLine();
	ImGui::BeginChild(/*##vlc2*/XorStr<0xA4, 7, 0xA4272245>("\x87\x86\xD0\xCB\xCB\x9B" + 0xA4272245).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::Checkbox(/*##btlr*/XorStr<0xC6, 7, 0x00BA0143>("\xE5\xE4\xAA\xBD\xA6\xB9" + 0x00BA0143).s, &cvar.rainbow_backtrack_light);
		ImGui::SameLine();
		Sakura::Menu::Widgets::ColorEdit(/*Backtrack Light*/XorStr<0xDC, 16, 0x58536407>("\x9E\xBC\xBD\xB4\x94\x93\x83\x80\x8F\xC5\xAA\x8E\x8F\x81\x9E" + 0x58536407).s, (float*)cvar.misc_backtrack_light_color, pickerFlags);
	}
	ImGui::EndChild();
}

void Sakura::Menu::Tabs::Colors::World()
{
	if (Sakura::Menu::Widgets::SubSubTab(/*F*/XorStr<0x22, 2, 0xDFF871FD>("\x64" + 0xDFF871FD).s, /*Esp*/XorStr<0x47, 4, 0x0066CF65>("\x02\x3B\x39" + 0x0066CF65).s, ImVec2(120, 40), worldSplit == 0 ? true : false))
		worldSplit = 0;
	ImGui::SameLine();
	if (Sakura::Menu::Widgets::SubSubTab(/*H*/XorStr<0xCB, 2, 0x2D002853>("\x83" + 0x2D002853).s, /*Light*/XorStr<0x0D, 6, 0x6B189047>("\x41\x67\x68\x78\x65" + 0x6B189047).s, ImVec2(120, 40), worldSplit == 1 ? true : false))
		worldSplit = 1;
	ImGui::SameLine();
	if (Sakura::Menu::Widgets::SubSubTab(/*I*/XorStr<0xB5, 2, 0xFD24B45D>("\xFC" + 0xFD24B45D).s, /*Chams*/XorStr<0xA4, 6, 0xE5D538EF>("\xE7\xCD\xC7\xCA\xDB" + 0xE5D538EF).s, ImVec2(120, 40), worldSplit == 2 ? true : false))
		worldSplit = 2;
	ImGui::SameLine();
	if (Sakura::Menu::Widgets::SubSubTab(/*G*/XorStr<0x2D, 2, 0xFBD0C83D>("\x6A" + 0xFBD0C83D).s, /*Map*/XorStr<0xE2, 4, 0x2CF9E085>("\xAF\x82\x94" + 0x2CF9E085).s, ImVec2(120, 40), worldSplit == 3 ? true : false))
		worldSplit = 3;

	ImGui::Spacing();

	switch (static_cast<int>(worldSplit))
	{
	case 0:
		Sakura::Menu::Tabs::Colors::WorldEsp();
		break;
	case 1:
		Sakura::Menu::Tabs::Colors::WorldLight();
		break;
	case 2:
		Sakura::Menu::Tabs::Colors::WorldChams();
		break;
	case 3:
		Sakura::Menu::Tabs::Colors::WorldMap();
		break;
	}
}

void Sakura::Menu::Tabs::Colors::WorldEsp()
{
	ImGui::BeginChild(/*##vlc1*/XorStr<0x2D, 7, 0x6FFB9A5E>("\x0E\x0D\x59\x5C\x52\x03" + 0x6FFB9A5E).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::Checkbox(/*##wbr*/XorStr<0x03, 6, 0x258688B5>("\x20\x27\x72\x64\x75" + 0x258688B5).s, &cvar.rainbow_world_box);
		ImGui::SameLine();
		Sakura::Menu::Widgets::ColorEdit(/*Box*/XorStr<0xBE, 4, 0xCA847FA1>("\xFC\xD0\xB8" + 0xCA847FA1).s, (float*)cvar.visual_box_world_color, pickerFlags);
	}
	ImGui::EndChild();
	ImGui::SameLine();
	ImGui::BeginChild(/*##vlc2*/XorStr<0x6D, 7, 0x63B7BDC7>("\x4E\x4D\x19\x1C\x12\x40" + 0x63B7BDC7).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::Checkbox(/*##wbbr*/XorStr<0x96, 7, 0x76DF0C9F>("\xB5\xB4\xEF\xFB\xF8\xE9" + 0x76DF0C9F).s, &cvar.rainbow_world_bone);
		ImGui::SameLine();
		Sakura::Menu::Widgets::ColorEdit(/*Bone*/XorStr<0x07, 5, 0xD6EB1C61>("\x45\x67\x67\x6F" + 0xD6EB1C61).s, (float*)cvar.skeleton_world_bone_color, pickerFlags);

		Sakura::Menu::Widgets::Checkbox(/*##wbhr*/XorStr<0x9E, 7, 0xD9D81F25>("\xBD\xBC\xD7\xC3\xCA\xD1" + 0xD9D81F25).s, &cvar.rainbow_world_hitbox);
		ImGui::SameLine();
		Sakura::Menu::Widgets::ColorEdit(/*Hitbox*/XorStr<0xFE, 7, 0x12024F73>("\xB6\x96\x74\x63\x6D\x7B" + 0x12024F73).s, (float*)cvar.skeleton_world_hitbox_color, pickerFlags);
	}
	ImGui::EndChild();
}

void Sakura::Menu::Tabs::Colors::WorldLight()
{
	ImGui::BeginChild(/*##vlc1*/XorStr<0x2D, 7, 0x6FFB9A5E>("\x0E\x0D\x59\x5C\x52\x03" + 0x6FFB9A5E).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::Checkbox(/*##wlr*/XorStr<0x1B, 6, 0xE09C1384>("\x38\x3F\x6A\x72\x6D" + 0xE09C1384).s, &cvar.rainbow_world_light);
		ImGui::SameLine();
		Sakura::Menu::Widgets::ColorEdit(/*Light*/XorStr<0xCF, 6, 0x38942E67>("\x83\xB9\xB6\xBA\xA7" + 0x38942E67).s, (float*)cvar.visual_lambert_world_color, pickerFlags);
	}
	ImGui::EndChild();
	ImGui::SameLine();
	ImGui::BeginChild(/*##vlc2*/XorStr<0x6D, 7, 0x63B7BDC7>("\x4E\x4D\x19\x1C\x12\x40" + 0x63B7BDC7).s, ImVec2(250, -1));
	{

	}
	ImGui::EndChild();
}

void Sakura::Menu::Tabs::Colors::WorldChams()
{
	ImGui::BeginChild(/*##vlc1*/XorStr<0x2D, 7, 0x6FFB9A5E>("\x0E\x0D\x59\x5C\x52\x03" + 0x6FFB9A5E).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::Checkbox(/*##wccww*/XorStr<0xFA, 8, 0x1ADDF153>("\xD9\xD8\x8B\x9E\x9D\x88\x77" + 0x1ADDF153).s, &cvar.rainbow_chams_world);
		ImGui::SameLine();
		Sakura::Menu::Widgets::ColorEdit(/*Chams*/XorStr<0xBD, 6, 0x4CB09395>("\xFE\xD6\xDE\xAD\xB2" + 0x4CB09395).s, (float*)cvar.chams_world_color, pickerFlags);
	}
	ImGui::EndChild();
	ImGui::SameLine();
	ImGui::BeginChild(/*##vlc2*/XorStr<0x6D, 7, 0x63B7BDC7>("\x4E\x4D\x19\x1C\x12\x40" + 0x63B7BDC7).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::ColorEdit(/*Chams behind wall*/XorStr<0x5F, 18, 0x96EBBD42>("\x1C\x08\x00\x0F\x10\x44\x07\x03\x0F\x01\x07\x0E\x4B\x1B\x0C\x02\x03" + 0x96EBBD42).s, (float*)cvar.chams_world_wall_color, pickerFlags);
	}
	ImGui::EndChild();
}

void Sakura::Menu::Tabs::Colors::WorldMap()
{
	ImGui::BeginChild(/*##vlc1*/XorStr<0x2D, 7, 0x6FFB9A5E>("\x0E\x0D\x59\x5C\x52\x03" + 0x6FFB9A5E).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::Checkbox(/*##mlrr*/XorStr<0xBE, 7, 0xF2883D6A>("\x9D\x9C\xAD\xAD\xB0\xB1" + 0xF2883D6A).s, &cvar.rainbow_world_maplight);
		ImGui::SameLine();
		if (Sakura::Menu::Widgets::ColorEdit(/*Light*/XorStr<0x71, 6, 0x2F4784ED>("\x3D\x1B\x14\x1C\x01" + 0x2F4784ED).s, (float*)cvar.visual_lightmap_color, pickerFlags)) Sakura::Map::mapLighted = false;
	}
	ImGui::EndChild();
	ImGui::SameLine();
	ImGui::BeginChild(/*##vlc2*/XorStr<0x6D, 7, 0x63B7BDC7>("\x4E\x4D\x19\x1C\x12\x40" + 0x63B7BDC7).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::ColorEdit(/*Fog*/XorStr<0x66, 4, 0xC4A2F49E>("\x20\x08\x0F" + 0xC4A2F49E).s, (float*)cvar.visual_fog_color, pickerFlags);
	}
	ImGui::EndChild();
}

void Sakura::Menu::Tabs::Colors::Local()
{
	if (Sakura::Menu::Widgets::SubSubTab(/*B*/XorStr<0x9D, 2, 0xF479ECA5>("\xDF" + 0xF479ECA5).s, /*Character*/XorStr<0x4E, 10, 0x73B93AE3>("\x0D\x27\x31\x23\x33\x30\x20\x30\x24" + 0x73B93AE3).s, ImVec2(75, 40), localPlayerSplit == 0 ? true : false))
		localPlayerSplit = 0;
	ImGui::SameLine();
	if (Sakura::Menu::Widgets::SubSubTab(/*D*/XorStr<0x27, 2, 0x0437AE1F>("\x63" + 0x0437AE1F).s, /*Real position*/XorStr<0xCC, 14, 0x387B8359>("\x9E\xA8\xAF\xA3\xF0\xA1\xBD\xA0\xBD\xA1\xBF\xB8\xB6" + 0x387B8359).s, ImVec2(75, 40), localPlayerSplit == 1 ? true : false))
		localPlayerSplit = 1;
	ImGui::SameLine();
	if (Sakura::Menu::Widgets::SubSubTab(/*E*/XorStr<0x60, 2, 0xEF712333>("\x25" + 0xEF712333).s, /*Weapon*/XorStr<0x91, 7, 0xCF875AB7>("\xC6\xF7\xF2\xE4\xFA\xF8" + 0xCF875AB7).s, ImVec2(75, 40), localPlayerSplit == 2 ? true : false))
		localPlayerSplit = 2;
	ImGui::SameLine();
	if (Sakura::Menu::Widgets::SubSubTab(/*M*/XorStr<0x45, 2, 0x3B801CBB>("\x08" + 0x3B801CBB).s, /*Bullet trace*/XorStr<0xA0, 13, 0x43B5029A>("\xE2\xD4\xCE\xCF\xC1\xD1\x86\xD3\xDA\xC8\xC9\xCE" + 0x43B5029A).s, ImVec2(75, 40), localPlayerSplit == 3 ? true : false))
		localPlayerSplit = 3;
	ImGui::SameLine();
	if (Sakura::Menu::Widgets::SubSubTab(/*O*/XorStr<0xA2, 2, 0x294CA546>("\xED" + 0x294CA546).s, /*Grenade trajectory*/XorStr<0x98, 19, 0xC455DF48>("\xDF\xEB\xFF\xF5\xFD\xF9\xFB\xBF\xD4\xD3\xC3\xC9\xC1\xC6\xD2\xC8\xDA\xD0" + 0xC455DF48).s, ImVec2(75, 40), localPlayerSplit == 4 ? true : false))
		localPlayerSplit = 4;
	ImGui::SameLine();
	if (Sakura::Menu::Widgets::SubSubTab(/*L*/XorStr<0x82, 2, 0xE9BBA131>("\xCE" + 0xE9BBA131).s, /*Additions*/XorStr<0x7A, 10, 0xFC236000>("\x3B\x1F\x18\x14\x0A\x16\xEF\xEF\xF1" + 0xFC236000).s, ImVec2(75, 40), localPlayerSplit == 5 ? true : false))
		localPlayerSplit = 5;

	ImGui::Spacing();

	switch (static_cast<int>(localPlayerSplit))
	{
	case 0:
		Sakura::Menu::Tabs::Colors::LocalCharacter();
		break;
	case 1:
		Sakura::Menu::Tabs::Colors::LocalRealPosition();
		break;
	case 2:
		Sakura::Menu::Tabs::Colors::LocalViewModel();
		break;
	case 3:
		Sakura::Menu::Tabs::Colors::LocalBulletTrace();
		break;
	case 4:
		Sakura::Menu::Tabs::Colors::LocalGrenadeTrajectory();
		break;
	case 5:
		Sakura::Menu::Tabs::Colors::LocalOther();
		break;
	}
}

void Sakura::Menu::Tabs::Colors::LocalCharacter()
{
	ImGui::BeginChild(/*##vlc1*/XorStr<0x2D, 7, 0x6FFB9A5E>("\x0E\x0D\x59\x5C\x52\x03" + 0x6FFB9A5E).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::Checkbox(/*##plc4*/XorStr<0x04, 7, 0xF0E5A1BB>("\x27\x26\x76\x6B\x6B\x3D" + 0xF0E5A1BB).s, &cvar.rainbow_lambert_local);
		ImGui::SameLine();
		Sakura::Menu::Widgets::ColorEdit(/*Light*/XorStr<0x37, 6, 0x7E7A89B8>("\x7B\x51\x5E\x52\x4F" + 0x7E7A89B8).s, (float*)cvar.visual_lambert_color_local, pickerFlags);

		Sakura::Menu::Widgets::Checkbox(/*##lgr4*/XorStr<0x5E, 7, 0x9BF64C46>("\x7D\x7C\x0C\x06\x10\x57" + 0x9BF64C46).s, &cvar.rainbow_local_glow);
		ImGui::SameLine();
		Sakura::Menu::Widgets::ColorEdit(/*Glow*/XorStr<0xCF, 5, 0x85A49477>("\x88\xBC\xBE\xA5" + 0x85A49477).s, (float*)cvar.visual_local_glow_color, pickerFlags);
	}
	ImGui::EndChild();
	ImGui::SameLine();
	ImGui::BeginChild(/*##vlc2*/XorStr<0x6D, 7, 0x63B7BDC7>("\x4E\x4D\x19\x1C\x12\x40" + 0x63B7BDC7).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::Checkbox(/*##lcr*/XorStr<0xF4, 6, 0x97E2D175>("\xD7\xD6\x9A\x94\x8A" + 0x97E2D175).s, &cvar.rainbow_chams_local);
		ImGui::SameLine();
		Sakura::Menu::Widgets::ColorEdit(/*Chams*/XorStr<0x0B, 6, 0x6D55F241>("\x48\x64\x6C\x63\x7C" + 0x6D55F241).s, (float*)cvar.chams_local_color, pickerFlags);
	}
	ImGui::EndChild();
}

void Sakura::Menu::Tabs::Colors::LocalRealPosition()
{
	ImGui::BeginChild(/*##vlc1*/XorStr<0x2D, 7, 0x6FFB9A5E>("\x0E\x0D\x59\x5C\x52\x03" + 0x6FFB9A5E).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::Checkbox(/*##lrplr*/XorStr<0xDF, 8, 0x1058184F>("\xFC\xC3\x8D\x90\x93\x88\x97" + 0x1058184F).s, &cvar.rainbow_local_history);
		ImGui::SameLine();
		Sakura::Menu::Widgets::ColorEdit(/*Light*/XorStr<0xDB, 6, 0x63529ACD>("\x97\xB5\xBA\xB6\xAB" + 0x63529ACD).s, (float*)cvar.visual_fakelag_history_local_light_color, pickerFlags);
	}
	ImGui::EndChild();
	ImGui::SameLine();
	ImGui::BeginChild(/*##vlc2*/XorStr<0x6D, 7, 0x63B7BDC7>("\x4E\x4D\x19\x1C\x12\x40" + 0x63B7BDC7).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::Checkbox(/*##lrpcr*/XorStr<0x4C, 8, 0x312D479D>("\x6F\x6E\x22\x3D\x20\x32\x20" + 0x312D479D).s, &cvar.rainbow_chams_local_fake);
		ImGui::SameLine();
		Sakura::Menu::Widgets::ColorEdit(/*Chams*/XorStr<0xD1, 6, 0xD80DACB1>("\x92\xBA\xB2\xB9\xA6" + 0xD80DACB1).s, (float*)cvar.visual_fakelag_history_local_chams_color, pickerFlags);
	}
	ImGui::EndChild();
}

void Sakura::Menu::Tabs::Colors::LocalViewModel()
{
	ImGui::BeginChild(/*##vlc1*/XorStr<0x2D, 7, 0x6FFB9A5E>("\x0E\x0D\x59\x5C\x52\x03" + 0x6FFB9A5E).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::Checkbox(/*##vmgr*/XorStr<0xCF, 7, 0x40AB5099>("\xEC\xF3\xA7\xBF\xB4\xA6" + 0x40AB5099).s, &cvar.rainbow_viewmodel_glow);
		ImGui::SameLine();
		Sakura::Menu::Widgets::ColorEdit(/*Glow*/XorStr<0x8D, 5, 0x2C257997>("\xCA\xE2\xE0\xE7" + 0x2C257997).s, (float*)cvar.visual_viewmodel_glow_color, pickerFlags);

		Sakura::Menu::Widgets::Checkbox(/*##vmlr*/XorStr<0xC6, 7, 0x95F6DC11>("\xE5\xE4\xBE\xA4\xA6\xB9" + 0x95F6DC11).s, &cvar.rainbow_viewmodel_light);
		ImGui::SameLine();
		Sakura::Menu::Widgets::ColorEdit(/*Light*/XorStr<0x03, 6, 0x7FFE6A0A>("\x4F\x6D\x62\x6E\x73" + 0x7FFE6A0A).s, (float*)cvar.visual_lambert_viewmodel_color, pickerFlags);
	}
	ImGui::EndChild();
	ImGui::SameLine();
	ImGui::BeginChild(/*##vlc2*/XorStr<0x6D, 7, 0x63B7BDC7>("\x4E\x4D\x19\x1C\x12\x40" + 0x63B7BDC7).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::Checkbox(/*##vmhr*/XorStr<0xB3, 7, 0x58E78E22>("\x90\x97\xC3\xDB\xDF\xCA" + 0x58E78E22).s, &cvar.rainbow_viewmodel_hitbox);
		ImGui::SameLine();
		Sakura::Menu::Widgets::ColorEdit(/*Hitbox*/XorStr<0xC0, 7, 0xD86639BC>("\x88\xA8\xB6\xA1\xAB\xBD" + 0xD86639BC).s, (float*)cvar.skeleton_view_model_hitbox_color, pickerFlags);
		
		Sakura::Menu::Widgets::Checkbox(/*##vvccr5*/XorStr<0x1B, 9, 0x5C0471CD>("\x38\x3F\x6B\x68\x7C\x43\x53\x17" + 0x5C0471CD).s, &cvar.rainbow_viewmodel);
		ImGui::SameLine();
		Sakura::Menu::Widgets::ColorEdit(/*Chams*/XorStr<0x19, 6, 0xD765A620>("\x5A\x72\x7A\x71\x6E" + 0xD765A620).s, (float*)cvar.visual_skins_viewmodel_color, pickerFlags);
	}
	ImGui::EndChild();
}

void Sakura::Menu::Tabs::Colors::LocalBulletTrace()
{
	ImGui::BeginChild(/*##vlc1*/XorStr<0x2D, 7, 0x6FFB9A5E>("\x0E\x0D\x59\x5C\x52\x03" + 0x6FFB9A5E).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::ColorEdit(/*Beam*/XorStr<0x19, 5, 0x4E5871EF>("\x5B\x7F\x7A\x71" + 0x4E5871EF).s, (float*)cvar.visual_bullet_trace_local_color, pickerFlags);
	}
	ImGui::EndChild();
	ImGui::SameLine();
	ImGui::BeginChild(/*##vlc2*/XorStr<0x6D, 7, 0x63B7BDC7>("\x4E\x4D\x19\x1C\x12\x40" + 0x63B7BDC7).s, ImVec2(250, -1));
	{

	}
	ImGui::EndChild();
}

void Sakura::Menu::Tabs::Colors::LocalGrenadeTrajectory()
{
	ImGui::BeginChild(/*##vlc1*/XorStr<0x2D, 7, 0x6FFB9A5E>("\x0E\x0D\x59\x5C\x52\x03" + 0x6FFB9A5E).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::Checkbox(/*##gtlr1*/XorStr<0x97, 8, 0x7D2C5E62>("\xB4\xBB\xFE\xEE\xF7\xEE\xAC" + 0x7D2C5E62).s, &cvar.rainbow_grenade_trajectory_line);
		ImGui::SameLine();
		Sakura::Menu::Widgets::ColorEdit(/*Line*/XorStr<0xF5, 5, 0x478F3C23>("\xB9\x9F\x99\x9D" + 0x478F3C23).s, (float*)cvar.visual_grenade_trajectory_line_color, pickerFlags);
	}
	ImGui::EndChild();
	ImGui::SameLine();
	ImGui::BeginChild(/*##vlc2*/XorStr<0x6D, 7, 0x63B7BDC7>("\x4E\x4D\x19\x1C\x12\x40" + 0x63B7BDC7).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::Checkbox(/*##gtlr2*/XorStr<0xD2, 8, 0x329B664B>("\xF1\xF0\xB3\xA1\xBA\xA5\xEA" + 0x329B664B).s, &cvar.rainbow_grenade_trajectory_point);
		ImGui::SameLine();
		Sakura::Menu::Widgets::ColorEdit(/*Point*/XorStr<0x48, 6, 0x896CF243>("\x18\x26\x23\x25\x38" + 0x896CF243).s, (float*)cvar.visual_grenade_trajectory_point_color, pickerFlags);
	}
	ImGui::EndChild();
}

void Sakura::Menu::Tabs::Colors::LocalOther()
{
	ImGui::BeginChild(/*##vlc1*/XorStr<0x2D, 7, 0x6FFB9A5E>("\x0E\x0D\x59\x5C\x52\x03" + 0x6FFB9A5E).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::ColorEdit(/*No Flash*/XorStr<0xAB, 9, 0x5CDB91B9>("\xE5\xC3\x8D\xE8\xC3\xD1\xC2\xDA" + 0x5CDB91B9).s, (float*)cvar.visual_noflash_color, pickerFlags);
	}
	ImGui::EndChild();
	ImGui::SameLine();
	ImGui::BeginChild(/*##vlc2*/XorStr<0x6D, 7, 0x63B7BDC7>("\x4E\x4D\x19\x1C\x12\x40" + 0x63B7BDC7).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::ColorEdit(/*Crosshair*/XorStr<0xB7, 10, 0x4F0DEACD>("\xF4\xCA\xD6\xC9\xC8\xD4\xDC\xD7\xCD" + 0x4F0DEACD).s, (float*)cvar.visual_crosshair_color, pickerFlags);
		Sakura::Menu::Widgets::ColorEdit(/*FOV*/XorStr<0x90, 4, 0x4F4E320A>("\xD6\xDE\xC4" + 0x4F4E320A).s, (float*)cvar.visual_draw_fov_color, pickerFlags);
		Sakura::Menu::Widgets::Checkbox(/*##vmlr*/XorStr<0xC6, 7, 0x95F6DC11>("\xE5\xE4\xBE\xA4\xA6\xB9" + 0x95F6DC11).s, &cvar.rainbow_hud);
		ImGui::SameLine();
		Sakura::Menu::Widgets::ColorEdit(/*Hud*/XorStr<0x74, 4, 0x516254A4>("\x3C\x00\x12" + 0x516254A4).s, (float*)cvar.visual_hud_color, pickerFlags);
	}
	ImGui::EndChild();
}

void Sakura::Menu::Tabs::Colors::Route()
{
	ImGui::BeginChild(/*##vlc1*/XorStr<0x6F, 7, 0xEBBB8C24>("\x4C\x53\x07\x1E\x10\x45" + 0xEBBB8C24).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::Checkbox(/*##rlr1*/XorStr<0x67, 7, 0xAB1C170C>("\x44\x4B\x1B\x06\x19\x5D" + 0xAB1C170C).s, &cvar.rainbow_route_line);
		ImGui::SameLine();
		Sakura::Menu::Widgets::ColorEdit(/*Line*/XorStr<0xFC, 5, 0xD9835BAD>("\xB0\x94\x90\x9A" + 0xD9835BAD).s, (float*)cvar.route_line_color, pickerFlags);
	}
	ImGui::EndChild();
	ImGui::SameLine();
	ImGui::BeginChild(/*##vlc2*/XorStr<0xED, 7, 0x379E7315>("\xCE\xCD\x99\x9C\x92\xC0" + 0x379E7315).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::Checkbox(/*##rlr2*/XorStr<0xA0, 7, 0xDCB9A6C5>("\x83\x82\xD0\xCF\xD6\x97" + 0xDCB9A6C5).s, &cvar.rainbow_route_point);
		ImGui::SameLine();
		Sakura::Menu::Widgets::ColorEdit(/*Point*/XorStr<0x6C, 6, 0xA7474319>("\x3C\x02\x07\x01\x04" + 0xA7474319).s, (float*)cvar.route_point_color, pickerFlags);
	}
	ImGui::EndChild();
}

void Sakura::Menu::Tabs::Colors::Notification()
{
	ImGui::BeginChild(/*##vlc1*/XorStr<0x6F, 7, 0xEBBB8C24>("\x4C\x53\x07\x1E\x10\x45" + 0xEBBB8C24).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::ColorEdit(/*Background*/XorStr<0x36, 11, 0xE9D69822>("\x74\x56\x5B\x52\x5D\x49\x53\x48\x50\x5B" + 0xE9D69822).s, (float*)cvar.notifications_bg_color, pickerFlags);
		Sakura::Menu::Widgets::ColorEdit(/*Time background*/XorStr<0xEA, 16, 0x9ED588DB>("\xBE\x82\x81\x88\xCE\x8D\x91\x92\x99\x94\x86\x9A\x83\x99\x9C" + 0x9ED588DB).s, (float*)cvar.notifications_bg_time_color, pickerFlags);
	}
	ImGui::EndChild();
	ImGui::SameLine();
	ImGui::BeginChild(/*##vlc2*/XorStr<0xED, 7, 0x379E7315>("\xCE\xCD\x99\x9C\x92\xC0" + 0x379E7315).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::ColorEdit(/*Text*/XorStr<0x0C, 5, 0x8DD2D691>("\x58\x68\x76\x7B" + 0x8DD2D691).s, (float*)cvar.notifications_text_color, pickerFlags);
	}
	ImGui::EndChild();
}

void Sakura::Menu::Tabs::Colors::Menu()
{
	ImGui::BeginChild(/*##vlc1*/XorStr<0x6F, 7, 0xEBBB8C24>("\x4C\x53\x07\x1E\x10\x45" + 0xEBBB8C24).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::Checkbox(/*##mcr1*/XorStr<0x44, 7, 0x17184293>("\x67\x66\x2B\x24\x3A\x78" + 0x17184293).s, &cvar.rainbow_menu);
		ImGui::SameLine();
		Sakura::Menu::Widgets::ColorEdit(/*Main color*/XorStr<0xA5, 11, 0x2CFC34DB>("\xE8\xC7\xCE\xC6\x89\xC9\xC4\xC0\xC2\xDC" + 0x2CFC34DB).s, (float*)cvar.visual_menu_color, pickerFlags);
		Sakura::Menu::Widgets::ColorEdit(/*Logo*/XorStr<0x0F, 5, 0x8FDB2C7C>("\x43\x7F\x76\x7D" + 0x8FDB2C7C).s, (float*)cvar.visual_menu_color_logo, pickerFlags);
		Sakura::Menu::Widgets::ColorEdit(/*Footer text*/XorStr<0x69, 12, 0x51773C8B>("\x2F\x05\x04\x18\x08\x1C\x4F\x04\x14\x0A\x07" + 0x51773C8B).s, (float*)cvar.visual_menu_color_footer_text, pickerFlags);
	}
	ImGui::EndChild();
	ImGui::SameLine();
	ImGui::BeginChild(/*##vlc2*/XorStr<0xED, 7, 0x379E7315>("\xCE\xCD\x99\x9C\x92\xC0" + 0x379E7315).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::ColorEdit(/*Header background*/XorStr<0xD2, 18, 0xF8BBAC10>("\x9A\xB6\xB5\xB1\xB3\xA5\xF8\xBB\xBB\xB8\xB7\xBA\xAC\xB0\x95\x8F\x86" + 0xF8BBAC10).s, (float*)cvar.visual_menu_color_header, pickerFlags);
		Sakura::Menu::Widgets::ColorEdit(/*Items background*/XorStr<0xF3, 17, 0x48853CA1>("\xBA\x80\x90\x9B\x84\xD8\x9B\x9B\x98\x97\x9A\x8C\x90\x75\x6F\x66" + 0x48853CA1).s, (float*)cvar.visual_menu_color_items, pickerFlags);
		Sakura::Menu::Widgets::ColorEdit(/*Footer background*/XorStr<0x6F, 18, 0x1CB3DEC0>("\x29\x1F\x1E\x06\x16\x06\x55\x14\x16\x1B\x12\x1D\x09\x13\x08\x10\x1B" + 0x1CB3DEC0).s, (float*)cvar.visual_menu_color_footer, pickerFlags);
		Sakura::Menu::Widgets::ColorEdit(/*Widgets background*/XorStr<0x27, 19, 0xA13329FE>("\x70\x41\x4D\x4D\x4E\x58\x5E\x0E\x4D\x51\x52\x59\x54\x46\x5A\x43\x59\x5C" + 0xA13329FE).s, (float*)cvar.visual_menu_color_widgets, pickerFlags);
		Sakura::Menu::Widgets::ColorEdit(/*Selected tab background*/XorStr<0x96, 24, 0xC177A2DE>("\xC5\xF2\xF4\xFC\xF9\xEF\xF9\xF9\xBE\xEB\xC1\xC3\x82\xC1\xC5\xC6\xCD\xC0\xDA\xC6\xDF\xC5\xC8" + 0xC177A2DE).s, (float*)cvar.visual_menu_color_tab_selected, pickerFlags);
		Sakura::Menu::Widgets::ColorEdit(/*Selected subtab background*/XorStr<0x0A, 27, 0x348EA17B>("\x59\x6E\x60\x68\x6D\x7B\x75\x75\x32\x60\x61\x77\x62\x76\x7A\x39\x78\x7A\x7F\x76\x79\x6D\x4F\x54\x4C\x47" + 0x348EA17B).s, (float*)cvar.visual_menu_color_subtab_selected, pickerFlags);
		Sakura::Menu::Widgets::ColorEdit(/*Combo background*/XorStr<0x2C, 17, 0x66ACF5BA>("\x6F\x42\x43\x4D\x5F\x11\x50\x52\x57\x5E\x51\x45\x57\x4C\x54\x5F" + 0x66ACF5BA).s, (float*)cvar.visual_menu_combo_bg_color, pickerFlags);
		Sakura::Menu::Widgets::ColorEdit(/*Slider background*/XorStr<0x18, 18, 0x7363B53A>("\x4B\x75\x73\x7F\x79\x6F\x3E\x7D\x41\x42\x49\x44\x56\x4A\x53\x49\x4C" + 0x7363B53A).s, (float*)cvar.visual_menu_slider_bg_color, pickerFlags);
	}
	ImGui::EndChild();
}
```

`sakura/source/features/visuals/menu/tabs/menu_colors_tab.h`:

```h
#pragma once

namespace Sakura
{
	namespace Menu
	{
		namespace Tabs
		{
			namespace Colors
			{
				void Player();
				void PlayerEsp();
				void PlayerSoundEsp();
				void PlayerGlow();
				void PlayerChams();
				void PlayerLight();
				void PlayerDeathmark();
				void PlayerBacktrack();
				void World();
				void WorldEsp();
				void WorldChams();
				void WorldLight();
				void WorldMap();
				void Local();
				void LocalCharacter();
				void LocalRealPosition();
				void LocalViewModel();
				void LocalGrenadeTrajectory();
				void LocalBulletTrace();
				void LocalOther();
				void Route();
				void Notification();
				void Menu();
			};
		};
	};
};
```

`sakura/source/features/visuals/menu/tabs/menu_legit_tab.cpp`:

```cpp
#include "../../../../client.h"

void Sakura::Menu::Tabs::Legit::Aimbot()
{
	if (Sakura::Menu::CheckWeapon(cvar.menu_legit_global_section, cvar.menu_legit_sub_section))
	{
		ImGui::BeginChild(/*##la1*/XorStr<0xBF, 6, 0xFC6D3994>("\x9C\xE3\xAD\xA3\xF2" + 0xFC6D3994).s, ImVec2(250, -1));
		{
			Sakura::Menu::Widgets::Checkbox(/*Enable*/XorStr<0x1D, 7, 0x7FF1244B>("\x58\x70\x7E\x42\x4D\x47" + 0x7FF1244B).s, &cvar.legit[Sakura::Menu::CheckWeapon(cvar.menu_legit_global_section, cvar.menu_legit_sub_section)].active);
			Sakura::Menu::Widgets::Checkbox(/*Aim Team*/XorStr<0x0D, 9, 0x6FE3A79B>("\x4C\x67\x62\x30\x45\x77\x72\x79" + 0x6FE3A79B).s, &cvar.legit_team);
			Sakura::Menu::Widgets::Checkbox(/*Bypass Trace*/XorStr<0xD3, 13, 0xBB095411>("\x91\xAD\xA5\xB7\xA4\xAB\xF9\x8E\xA9\xBD\xBE\xBB" + 0xBB095411).s, &cvar.bypass_trace_legit);
			Sakura::Menu::Widgets::Checkbox(/*Draw Aim*/XorStr<0x5E, 9, 0x1E924871>("\x1A\x2D\x01\x16\x42\x22\x0D\x08" + 0x1E924871).s, &cvar.legit_draw_aim);
			Sakura::Menu::Widgets::Checkbox(/*Humanize*/XorStr<0x94, 9, 0xA4B54BE2>("\xDC\xE0\xFB\xF6\xF6\xF0\xE0\xFE" + 0xA4B54BE2).s, &cvar.legit[Sakura::Menu::CheckWeapon(cvar.menu_legit_global_section, cvar.menu_legit_sub_section)].humanize);
			Sakura::Menu::Widgets::Checkbox(/*Flash check*/XorStr<0x62, 12, 0x107DCB86>("\x24\x0F\x05\x16\x0E\x47\x0B\x01\x0F\x08\x07" + 0x107DCB86).s, &cvar.legit_flashcheck);
			Sakura::Menu::Widgets::Checkbox("Demochecker bypass", &cvar.legit_demochecker_bypass);

			if (cvar.menu_legit_global_section == 1)
			{
				Sakura::Menu::Widgets::Checkbox(/*Fast zoom*/XorStr<0xFC, 10, 0xA831F29D>("\xBA\x9C\x8D\x8B\x20\x7B\x6D\x6C\x69" + 0xA831F29D).s, &cvar.legit_fastzoom);

				if (cvar.menu_legit_sub_section == 0 || cvar.menu_legit_sub_section == 1)
					Sakura::Menu::Widgets::Checkbox(/*Fast switch*/XorStr<0x2B, 12, 0x76A78DA1>("\x6D\x4D\x5E\x5A\x0F\x43\x46\x5B\x47\x57\x5D" + 0x76A78DA1).s, &cvar.misc_fastswitch);
			}
		}
		ImGui::EndChild();
		ImGui::SameLine();
		ImGui::BeginChild(/*##la2*/XorStr<0x11, 6, 0x410535D9>("\x32\x31\x7F\x75\x27" + 0x410535D9).s, ImVec2(250, -1));
		{
			ImGui::PushItemWidth(itemWidth);
			Sakura::Menu::Widgets::SliderFloat(/*FOV*/XorStr<0xAD, 4, 0x2E936BEE>("\xEB\xE1\xF9" + 0x2E936BEE).s, &cvar.legit[Sakura::Menu::CheckWeapon(cvar.menu_legit_global_section, cvar.menu_legit_sub_section)].fov, 0.f, 45.f, "%.0f");
			Sakura::Menu::Widgets::SliderFloat(/*Smooth*/XorStr<0x36, 7, 0x8B8FED50>("\x65\x5A\x57\x56\x4E\x53" + 0x8B8FED50).s, &cvar.legit[Sakura::Menu::CheckWeapon(cvar.menu_legit_global_section, cvar.menu_legit_sub_section)].speed_in_attack, 0.f, 250.f, "%.0f");
			Sakura::Menu::Widgets::SliderFloat(/*Auto Aim Speed*/XorStr<0x05, 15, 0xF4BFE53F>("\x44\x73\x73\x67\x29\x4B\x62\x61\x2D\x5D\x7F\x75\x74\x76" + 0xF4BFE53F).s, &cvar.legit[Sakura::Menu::CheckWeapon(cvar.menu_legit_global_section, cvar.menu_legit_sub_section)].speed, 0.f, 100.f, "%.0f");
			Sakura::Menu::Widgets::SliderFloat(/*Block Attack After Kill*/XorStr<0xF1, 24, 0x7207467C>("\xB3\x9E\x9C\x97\x9E\xD6\xB6\x8C\x8D\x9B\x98\x97\xDD\xBF\x99\x74\x64\x70\x23\x4F\x6C\x6A\x6B" + 0x7207467C).s, &cvar.legit[Sakura::Menu::CheckWeapon(cvar.menu_legit_global_section, cvar.menu_legit_sub_section)].block_attack_after_kill, 0.f, 1000.f, "%.0fms");
			Sakura::Menu::Widgets::SliderFloat(/*Reaction Time*/XorStr<0x9D, 14, 0x8550E407>("\xCF\xFB\xFE\xC3\xD5\xCB\xCC\xCA\x85\xF2\xCE\xC5\xCC" + 0x8550E407).s, &cvar.legit[Sakura::Menu::CheckWeapon(cvar.menu_legit_global_section, cvar.menu_legit_sub_section)].reaction_time, 0.f, 1000.f, "%.0fms");
			Sakura::Menu::Widgets::SliderFloat(/*Speed Scale FOV*/XorStr<0xD1, 16, 0x6778C188>("\x82\xA2\xB6\xB1\xB1\xF6\x84\xBB\xB8\xB6\xBE\xFC\x9B\x91\x89" + 0x6778C188).s, &cvar.legit[Sakura::Menu::CheckWeapon(cvar.menu_legit_global_section, cvar.menu_legit_sub_section)].speed_scale_fov, 0.f, 100.f, "%.0f%%");
			Sakura::Menu::Widgets::SliderFloat(/*Flash check*/XorStr<0x6D, 12, 0xBD2F26CF>("\x2B\x02\x0E\x03\x19\x52\x10\x1C\x10\x15\x1C" + 0xBD2F26CF).s, &cvar.legit_flashcheck_percentage, 0.f, 100.f, "%.0f%%");
			
			//if (cvar.menu_legit_sub_section == 0 || cvar.menu_legit_sub_section == 1)
			//	Sakura::Menu::Widgets::SliderFloat(/*Fast switch delay*/XorStr<0x17, 18, 0x325EB1C2>("\x51\x79\x6A\x6E\x3B\x6F\x6A\x77\x6B\x43\x49\x02\x47\x41\x49\x47\x5E" + 0x325EB1C2).s, &cvar.misc_fastswitch_delay, 0, 200, "%.0fms");

			Sakura::Menu::Widgets::Combo(/*Hitbox*/XorStr<0x95, 7, 0xE0EB7681>("\xDD\xFF\xE3\xFA\xF6\xE2" + 0xE0EB7681).s,
				&cvar.legit[Sakura::Menu::CheckWeapon(cvar.menu_legit_global_section, cvar.menu_legit_sub_section)].hitbox,
				/*Belt\0Left thigh\0Left tibia\0Left foot\0Right thigh\0Right tibia\0Right foot\0Stomach\0Lower chest\0Upper chest\0Neck\0Head\0Left shoulder\0Left elbow\0Left arm\0Left hand\0Right shoulder\0Right elbow\0Right arm\0Right hand\0*/XorStr<0x0D, 207, 0x025EDD2D>("\x4F\x6B\x63\x64\x11\x5E\x76\x72\x61\x36\x63\x70\x70\x7D\x73\x1C\x51\x7B\x79\x54\x01\x56\x4A\x46\x4C\x47\x27\x64\x4C\x4C\x5F\x0C\x4B\x41\x40\x44\x31\x60\x5A\x53\x5D\x42\x17\x4C\x51\x53\x5C\x54\x3D\x6C\x56\x27\x29\x36\x63\x30\x2C\x24\x2E\x29\x49\x18\x22\x2B\x25\x3A\x6F\x36\x3E\x3D\x27\x54\x06\x22\x38\x35\x38\x39\x33\x5C\x11\x31\x28\x05\x13\x42\x00\x0C\x00\x15\x13\x68\x3C\x1A\x1B\x09\x1F\x4E\x0C\x18\x14\x01\x07\x74\x3B\x13\x14\x13\x79\x32\x1E\x1D\x19\x7E\x33\xE5\xE7\xF6\xA3\xF7\xED\xE9\xF2\xE4\xED\xEF\xF9\x8C\xC1\xEB\xE9\xE4\xB1\xF7\xFF\xF6\xFA\xE1\x97\xD4\xFC\xFC\xEF\xBC\xFC\xEC\xF2\xA0\xED\xC7\xC5\xD0\x85\xCE\xC6\xC6\xCD\xAA\xF9\xC5\xCA\xC6\xDB\x90\xC2\xDA\xDC\xC1\xD9\xD2\xD2\xCA\xB9\xE8\xD2\xDB\xD5\xCA\x9F\xA5\xAD\xA0\xAC\xB3\xC5\x94\xAE\xAF\xA1\xBE\xEB\xAD\xBF\xA3\xCF\x82\xB8\xB5\xBB\xA0\xF5\xBE\xB6\xB6\xBD\xDA" + 0x025EDD2D).s);

			ImGui::PopItemWidth();
		}
		ImGui::EndChild();
	}
}

void Sakura::Menu::Tabs::Legit::Triggerbot()
{
	if (CheckWeapon(cvar.menu_legit_global_section, cvar.menu_legit_sub_section))
	{
		ImGui::BeginChild(/*##vp1*/XorStr<0xC3, 6, 0xBAD48571>("\xE0\xE7\xB3\xB6\xF6" + 0xBAD48571).s, ImVec2(250, -1));
		{
			Sakura::Menu::Widgets::Checkbox(/*Enable*/XorStr<0xC7, 7, 0xD7F218FF>("\x82\xA6\xA8\xA8\xA7\xA9" + 0xD7F218FF).s, &cvar.legit[CheckWeapon(cvar.menu_legit_global_section, cvar.menu_legit_sub_section)].trigger_active);
			Sakura::Menu::Widgets::Checkbox(/*Trigger Team*/XorStr<0xCE, 13, 0xB9BC5D2D>("\x9A\xBD\xB9\xB6\xB5\xB6\xA6\xF5\x82\xB2\xB9\xB4" + 0xB9BC5D2D).s, &cvar.legit_trigger_team);
			Sakura::Menu::Widgets::Checkbox(/*Bypass Trace*/XorStr<0xEA, 13, 0x86930546>("\xA8\x92\x9C\x8C\x9D\x9C\xD0\xA5\x80\x92\x97\x90" + 0x86930546).s, &cvar.bypass_trace_trigger);
			Sakura::Menu::Widgets::Checkbox(/*Draw Aim*/XorStr<0xB7, 9, 0x25EE0CC3>("\xF3\xCA\xD8\xCD\x9B\xFD\xD4\xD3" + 0x25EE0CC3).s, &cvar.legit_trigger_draw_aim);
			Sakura::Menu::Widgets::Checkbox(/*Only Zoom*/XorStr<0xB2, 10, 0xE50A9B5F>("\xFD\xDD\xD8\xCC\x96\xED\xD7\xD6\xD7" + 0xE50A9B5F).s, &cvar.legit_trigger_only_zoom);
			Sakura::Menu::Widgets::Checkbox(/*Wall*/XorStr<0x3C, 5, 0xA5C02BD3>("\x6B\x5C\x52\x53" + 0xA5C02BD3).s, &cvar.legit[CheckWeapon(cvar.menu_legit_global_section, cvar.menu_legit_sub_section)].trigger_wall);
		}
		ImGui::EndChild();
		ImGui::SameLine();
		ImGui::BeginChild(/*##vp2*/XorStr<0xCB, 6, 0xC5DEE80A>("\xE8\xEF\xBB\xBE\xFD" + 0xC5DEE80A).s, ImVec2(250, -1));
		{
			ImGui::PushItemWidth(itemWidth);
			if (!cvar.legit[CheckWeapon(cvar.menu_legit_global_section, cvar.menu_legit_sub_section)].trigger_shot_type)
			{
				Sakura::Menu::Widgets::SliderFloat(/*Count*/XorStr<0x2E, 6, 0xE7B80AED>("\x6D\x40\x45\x5F\x46" + 0xE7B80AED).s, &cvar.legit[CheckWeapon(cvar.menu_legit_global_section, cvar.menu_legit_sub_section)].trigger_shot_count, 1.f, 5.f, "%.0f");
			}
			Sakura::Menu::Widgets::SliderFloat(/*Fire Delay*/XorStr<0x61, 11, 0x8CE872FA>("\x27\x0B\x11\x01\x45\x22\x02\x04\x08\x13" + 0x8CE872FA).s, &cvar.legit[CheckWeapon(cvar.menu_legit_global_section, cvar.menu_legit_sub_section)].trigger_delay_shot, 0.f, 1000.f, "%.0fms");
			if (cvar.legit[CheckWeapon(cvar.menu_legit_global_section, cvar.menu_legit_sub_section)].trigger_shot_type)
			{
				Sakura::Menu::Widgets::SliderFloat(/*Random Max*/XorStr<0x05, 11, 0xC4E3FD73>("\x57\x67\x69\x6C\x66\x67\x2B\x41\x6C\x76" + 0xC4E3FD73).s, &cvar.legit[CheckWeapon(cvar.menu_legit_global_section, cvar.menu_legit_sub_section)].trigger_random_max, 2.f, 5.f, "%.0f");
			}

			Sakura::Menu::Widgets::Combo(
				/*Fire Type*/XorStr<0xA4, 10, 0x44665415>("\xE2\xCC\xD4\xC2\x88\xFD\xD3\xDB\xC9" + 0x44665415).s,
				&cvar.legit[CheckWeapon(cvar.menu_legit_global_section, cvar.menu_legit_sub_section)].trigger_shot_type,
				/*Count\0Random\0*/XorStr<0x5F, 14, 0x36D67F03>("\x1C\x0F\x14\x0C\x17\x64\x37\x07\x09\x0C\x06\x07\x6B" + 0x36D67F03).s);
			
			Sakura::Menu::Widgets::Combo(
				/*Accuracy Boost*/XorStr<0x2C, 15, 0x3F998CED>("\x6D\x4E\x4D\x5A\x42\x50\x51\x4A\x14\x77\x59\x58\x4B\x4D" + 0x3F998CED).s, 
				&cvar.legit[CheckWeapon(cvar.menu_legit_global_section, cvar.menu_legit_sub_section)].trigger_accuracy,
				/*None\0Recoil\0Recoil / Spread\0*/XorStr<0x9C, 29, 0x01B9FEBC>("\xD2\xF2\xF0\xFA\xA0\xF3\xC7\xC0\xCB\xCC\xCA\xA7\xFA\xCC\xC9\xC4\xC5\xC1\x8E\x80\x90\xE2\xC2\xC1\xD1\xD4\xD2\xB7" + 0x01B9FEBC).s);
			
			Sakura::Menu::Widgets::Combo(/*Hitbox*/XorStr<0x95, 7, 0xE0EB7681>("\xDD\xFF\xE3\xFA\xF6\xE2" + 0xE0EB7681).s,
				&cvar.legit[Sakura::Menu::CheckWeapon(cvar.menu_legit_global_section, cvar.menu_legit_sub_section)].trigger_hitbox,
				/*Belt\0Left thigh\0Left tibia\0Left foot\0Right thigh\0Right tibia\0Right foot\0Stomach\0Lower chest\0Upper chest\0Neck\0Head\0Left shoulder\0Left elbow\0Left arm\0Left hand\0Right shoulder\0Right elbow\0Right arm\0Right hand\0*/XorStr<0x0D, 207, 0x025EDD2D>("\x4F\x6B\x63\x64\x11\x5E\x76\x72\x61\x36\x63\x70\x70\x7D\x73\x1C\x51\x7B\x79\x54\x01\x56\x4A\x46\x4C\x47\x27\x64\x4C\x4C\x5F\x0C\x4B\x41\x40\x44\x31\x60\x5A\x53\x5D\x42\x17\x4C\x51\x53\x5C\x54\x3D\x6C\x56\x27\x29\x36\x63\x30\x2C\x24\x2E\x29\x49\x18\x22\x2B\x25\x3A\x6F\x36\x3E\x3D\x27\x54\x06\x22\x38\x35\x38\x39\x33\x5C\x11\x31\x28\x05\x13\x42\x00\x0C\x00\x15\x13\x68\x3C\x1A\x1B\x09\x1F\x4E\x0C\x18\x14\x01\x07\x74\x3B\x13\x14\x13\x79\x32\x1E\x1D\x19\x7E\x33\xE5\xE7\xF6\xA3\xF7\xED\xE9\xF2\xE4\xED\xEF\xF9\x8C\xC1\xEB\xE9\xE4\xB1\xF7\xFF\xF6\xFA\xE1\x97\xD4\xFC\xFC\xEF\xBC\xFC\xEC\xF2\xA0\xED\xC7\xC5\xD0\x85\xCE\xC6\xC6\xCD\xAA\xF9\xC5\xCA\xC6\xDB\x90\xC2\xDA\xDC\xC1\xD9\xD2\xD2\xCA\xB9\xE8\xD2\xDB\xD5\xCA\x9F\xA5\xAD\xA0\xAC\xB3\xC5\x94\xAE\xAF\xA1\xBE\xEB\xAD\xBF\xA3\xCF\x82\xB8\xB5\xBB\xA0\xF5\xBE\xB6\xB6\xBD\xDA" + 0x025EDD2D).s);

			ImGui::PopItemWidth();
		}
		ImGui::EndChild();
	}
}

void Sakura::Menu::Tabs::Legit::PerfectSilent()
{
	if (CheckWeapon(cvar.menu_legit_global_section, cvar.menu_legit_sub_section))
	{
		ImGui::BeginChild(/*##vp1*/XorStr<0x95, 6, 0xB322490F>("\xB6\xB5\xE1\xE8\xA8" + 0xB322490F).s, ImVec2(250, -1));
		{
			Sakura::Menu::Widgets::Checkbox(/*Enable*/XorStr<0xE0, 7, 0x49B16103>("\xA5\x8F\x83\x81\x88\x80" + 0x49B16103).s, &cvar.legit[CheckWeapon(cvar.menu_legit_global_section, cvar.menu_legit_sub_section)].perfect_silent_enable);
			Sakura::Menu::Widgets::Checkbox(/*Enable no spread*/XorStr<0x71, 17, 0x131F4347>("\x34\x1C\x12\x16\x19\x13\x57\x16\x16\x5A\x08\x0C\x0F\x1B\x1E\xE4" + 0x131F4347).s, &cvar.legit[CheckWeapon(cvar.menu_legit_global_section, cvar.menu_legit_sub_section)].perfect_silent_spread);
			//Sakura::Menu::Widgets::Checkbox(/*Auto shoot*/XorStr<0x8D, 11, 0xC50B817C>("\xCC\xFB\xFB\xFF\xB1\xE1\xFB\xFB\xFA\xE2" + 0xC50B817C).s, &cvar.legit[CheckWeapon(cvar.menu_legit_global_section, cvar.menu_legit_sub_section)].perfect_silent_autoshoot);
		}
		ImGui::EndChild();
		ImGui::SameLine();
		ImGui::BeginChild(/*##vp2*/XorStr<0x96, 6, 0x58531295>("\xB5\xB4\xEE\xE9\xA8" + 0x58531295).s, ImVec2(250, -1));
		{
			ImGui::PushItemWidth(itemWidth);
			Sakura::Menu::Widgets::SliderFloat(/*FOV (not working yet)*/XorStr<0x28, 22, 0x4F91C980>("\x6E\x66\x7C\x0B\x04\x43\x41\x5B\x10\x46\x5D\x41\x5F\x5C\x58\x50\x18\x40\x5F\x4F\x15" + 0x4F91C980).s, &cvar.legit[CheckWeapon(cvar.menu_legit_global_section, cvar.menu_legit_sub_section)].perfect_silent_fov, 0.f, 3.f, "%.1f");
			//Sakura::Menu::Widgets::SliderFloat(/*Attack speed*/XorStr<0xAE, 13, 0x02496B8E>("\xEF\xDB\xC4\xD0\xD1\xD8\x94\xC6\xC6\xD2\xDD\xDD" + 0x02496B8E).s, &cvar.legit[CheckWeapon(cvar.menu_legit_global_section, cvar.menu_legit_sub_section)].perfect_silent, 0.f, 100.f, "%.0f");
			ImGui::PopItemWidth();
		}
		ImGui::EndChild();
	}
}

void Sakura::Menu::Tabs::Legit::Hitboxes()
{
	if (CheckWeapon(cvar.menu_legit_global_section, cvar.menu_legit_sub_section))
	{
		ImGui::BeginChild(/*##vp1*/XorStr<0x95, 6, 0xB322490F>("\xB6\xB5\xE1\xE8\xA8" + 0xB322490F).s, ImVec2(250, -1));
		{
			ImGui::BeginListBox(/*Selected hitboxes*/XorStr<0x21, 18, 0xF91AEE44>("\x72\x47\x4F\x41\x46\x52\x42\x4C\x09\x42\x42\x58\x4F\x41\x57\x55\x42" + 0xF91AEE44).s, ImVec2(250, -1));
			{

			}
			ImGui::EndListBox();
		}
		ImGui::EndChild();
		ImGui::SameLine();
		ImGui::BeginChild(/*##vp2*/XorStr<0x96, 6, 0x58531295>("\xB5\xB4\xEE\xE9\xA8" + 0x58531295).s, ImVec2(250, -1));
		{
			ImGui::Text(/*The more hitboxes you will select - the more fps will be eaten during aiming process.*/XorStr<0x91, 86, 0xEFEC2987>("\xC5\xFA\xF6\xB4\xF8\xF9\xE5\xFD\xB9\xF2\xF2\xE8\xFF\xF1\xE7\xC5\xD2\x82\xDA\xCB\xD0\x86\xD0\xC1\xC5\xC6\x8B\xDF\xC8\xC2\xCA\xD3\xC5\x92\x9E\x94\xC1\xDE\xD2\x98\xD4\xD5\xC9\xD9\x9D\xD8\xCF\xB3\xE1\xB5\xAA\xA8\xA9\xE6\xA5\xAD\xE9\xAF\xAA\xB8\xA8\xA0\xEF\xB4\xA4\xA0\xBA\xBA\xB2\xF6\xB6\xB1\xB4\xB3\xB5\xBB\xFD\xAE\xAD\x8F\x82\x87\x90\x97\xCB" + 0xEFEC2987).s);
		}
		ImGui::EndChild();
	}
}

void Sakura::Menu::Tabs::Legit::Knifebot()
{
	ImGui::BeginChild(/*##vp1*/XorStr<0x8E, 6, 0x716FAC5B>("\xAD\xAC\xE6\xE1\xA3" + 0x716FAC5B).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::Checkbox(/*Enable*/XorStr<0x15, 7, 0x0DD3C50D>("\x50\x78\x76\x7A\x75\x7F" + 0x0DD3C50D).s, &cvar.knifebot_active);
		Sakura::Menu::Widgets::Checkbox(/*Knife Team*/XorStr<0xC1, 11, 0x242F928B>("\x8A\xAC\xAA\xA2\xA0\xE6\x93\xAD\xA8\xA7" + 0x242F928B).s, &cvar.knifebot_team);
		Sakura::Menu::Widgets::Checkbox(/*Bypass Trace*/XorStr<0x49, 13, 0xA88ECFD5>("\x0B\x33\x3B\x2D\x3E\x3D\x6F\x04\x23\x33\x30\x31" + 0xA88ECFD5).s, &cvar.bypass_trace_knife);
		Sakura::Menu::Widgets::Checkbox(/*Draw Aim*/XorStr<0x08, 9, 0x8E95455F>("\x4C\x7B\x6B\x7C\x2C\x4C\x67\x62" + 0x8E95455F).s, &cvar.knifebot_draw_aim);
		Sakura::Menu::Widgets::Checkbox(/*Silent*/XorStr<0xF7, 7, 0xEBF2EA7E>("\xA4\x91\x95\x9F\x95\x88" + 0xEBF2EA7E).s, &cvar.knifebot_silent);
		Sakura::Menu::Widgets::Checkbox(/*Perfect Silent*/XorStr<0xD2, 15, 0xA38E094F>("\x82\xB6\xA6\xB3\xB3\xB4\xAC\xF9\x89\xB2\xB0\xB8\xB0\xAB" + 0xA38E094F).s, &cvar.knifebot_perfect_silent);
	}
	ImGui::EndChild();
	ImGui::SameLine();
	ImGui::BeginChild(/*##vp2*/XorStr<0x7A, 6, 0x779E857D>("\x59\x58\x0A\x0D\x4C" + 0x779E857D).s, ImVec2(250, -1));
	{
		ImGui::PushItemWidth(itemWidth);
		Sakura::Menu::Widgets::SliderFloat(/*Field Of View*/XorStr<0xB9, 14, 0xD0CE3BAE>("\xFF\xD3\xDE\xD0\xD9\x9E\xF0\xA6\xE1\x94\xAA\xA1\xB2" + 0xD0CE3BAE).s, &cvar.knifebot_fov, 0.f, 180.f, "%.1f");
		if (cvar.knifebot_attack == 0)
		{
			Sakura::Menu::Widgets::SliderFloat(/*Slash Distance*/XorStr<0x4D, 15, 0x939218BF>("\x1E\x22\x2E\x23\x39\x72\x17\x3D\x26\x22\x36\x36\x3A\x3F" + 0x939218BF).s, &cvar.knifebot_attack_distance, 0.f, 100.f, "%.0f");
		}
		if (cvar.knifebot_attack == 1)
		{
			Sakura::Menu::Widgets::SliderFloat(/*Stab Distance*/XorStr<0xE8,14,0xA78263C7>("\xBB\x9D\x8B\x89\xCC\xA9\x87\x9C\x84\x90\x9C\x90\x91"+0xA78263C7).s, &cvar.knifebot_attack2_distance, 0.f, 100.f, "%.0f");
		
		}

		Sakura::Menu::Widgets::Combo(
			/*Knife Attack Method*/XorStr<0xF3, 20, 0x182ABBD3>("\xB8\x9A\x9C\x90\x92\xD8\xB8\x8E\x8F\x9D\x9E\x95\xDF\x4D\x64\x76\x6B\x6B\x61" + 0x182ABBD3).s,
			&cvar.knifebot_attack,
			/*Slash\0Stab\0*/XorStr<0x6D, 12, 0x6CD24975>("\x3E\x02\x0E\x03\x19\x72\x20\x00\x14\x14\x77" + 0x6CD24975).s);

		Sakura::Menu::Widgets::Combo(/*Hitbox*/XorStr<0x95, 7, 0xE0EB7681>("\xDD\xFF\xE3\xFA\xF6\xE2" + 0xE0EB7681).s,
			&cvar.knifebot_hitbox,
			/*Belt\0Left thigh\0Left tibia\0Left foot\0Right thigh\0Right tibia\0Right foot\0Stomach\0Lower chest\0Upper chest\0Neck\0Head\0Left shoulder\0Left elbow\0Left arm\0Left hand\0Right shoulder\0Right elbow\0Right arm\0Right hand\0*/XorStr<0x0D, 207, 0x025EDD2D>("\x4F\x6B\x63\x64\x11\x5E\x76\x72\x61\x36\x63\x70\x70\x7D\x73\x1C\x51\x7B\x79\x54\x01\x56\x4A\x46\x4C\x47\x27\x64\x4C\x4C\x5F\x0C\x4B\x41\x40\x44\x31\x60\x5A\x53\x5D\x42\x17\x4C\x51\x53\x5C\x54\x3D\x6C\x56\x27\x29\x36\x63\x30\x2C\x24\x2E\x29\x49\x18\x22\x2B\x25\x3A\x6F\x36\x3E\x3D\x27\x54\x06\x22\x38\x35\x38\x39\x33\x5C\x11\x31\x28\x05\x13\x42\x00\x0C\x00\x15\x13\x68\x3C\x1A\x1B\x09\x1F\x4E\x0C\x18\x14\x01\x07\x74\x3B\x13\x14\x13\x79\x32\x1E\x1D\x19\x7E\x33\xE5\xE7\xF6\xA3\xF7\xED\xE9\xF2\xE4\xED\xEF\xF9\x8C\xC1\xEB\xE9\xE4\xB1\xF7\xFF\xF6\xFA\xE1\x97\xD4\xFC\xFC\xEF\xBC\xFC\xEC\xF2\xA0\xED\xC7\xC5\xD0\x85\xCE\xC6\xC6\xCD\xAA\xF9\xC5\xCA\xC6\xDB\x90\xC2\xDA\xDC\xC1\xD9\xD2\xD2\xCA\xB9\xE8\xD2\xDB\xD5\xCA\x9F\xA5\xAD\xA0\xAC\xB3\xC5\x94\xAE\xAF\xA1\xBE\xEB\xAD\xBF\xA3\xCF\x82\xB8\xB5\xBB\xA0\xF5\xBE\xB6\xB6\xBD\xDA" + 0x025EDD2D).s);
		
		ImGui::PopItemWidth();
	}
	ImGui::EndChild();
}

void Sakura::Menu::Tabs::Legit::Recoil()
{
	if (Sakura::Menu::CheckWeapon(cvar.menu_legit_global_section, cvar.menu_legit_sub_section))
	{
		ImGui::BeginChild(/*##la1*/XorStr<0x27, 6, 0x97754AD4>("\x04\x0B\x45\x4B\x1A" + 0x97754AD4).s, ImVec2(250, -1));
		{
			ImGui::PushItemWidth(itemWidth);
			Sakura::Menu::Widgets::SliderFloat(/*Pitch*/XorStr<0x48, 6, 0x4873E5B9>("\x18\x20\x3E\x28\x24" + 0x4873E5B9).s, &cvar.legit[CheckWeapon(cvar.menu_legit_global_section, cvar.menu_legit_sub_section)].recoil_compensation_pitch, 0.f, 100.f, "%.0f%%");
			Sakura::Menu::Widgets::SliderFloat(/*Yaw*/XorStr<0xB5, 4, 0xBFD453D5>("\xEC\xD7\xC0" + 0xBFD453D5).s, &cvar.legit[CheckWeapon(cvar.menu_legit_global_section, cvar.menu_legit_sub_section)].recoil_compensation_yaw, 0.f, 100.f, "%.0f%%");
			Sakura::Menu::Widgets::SliderFloat(/*Additional Fov Percent*/XorStr<0x2D, 23, 0x27222B62>("\x6C\x4A\x4B\x59\x45\x5B\x5C\x5A\x54\x5A\x17\x7E\x56\x4C\x1B\x6C\x58\x4C\x5C\x25\x2F\x36" + 0x27222B62).s, &cvar.legit[CheckWeapon(cvar.menu_legit_global_section, cvar.menu_legit_sub_section)].recoil_compensation_fov, 0.f, 150.f, "%.0f%%");
			Sakura::Menu::Widgets::SliderFloat(/*Additional Smooth Percent*/XorStr<0xAA, 26, 0xC354320A>("\xEB\xCF\xC8\xC4\xDA\xC6\xDF\xDF\xD3\xDF\x94\xE6\xDB\xD8\xD7\xCD\xD2\x9B\xEC\xD8\xCC\xDC\xA5\xAF\xB6" + 0xC354320A).s, &cvar.legit[CheckWeapon(cvar.menu_legit_global_section, cvar.menu_legit_sub_section)].recoil_compensation_smooth, 0.f, 150.f, "%.0f%%");
			Sakura::Menu::Widgets::SliderFloat(/*After Shoots*/XorStr<0xC3, 13, 0x6DF926FF>("\x82\xA2\xB1\xA3\xB5\xE8\x9A\xA2\xA4\xA3\xB9\xBD" + 0x6DF926FF).s, &cvar.legit[CheckWeapon(cvar.menu_legit_global_section, cvar.menu_legit_sub_section)].recoil_compensation_after_shots_fired, 0.f, 10.f, "%.0f");
			ImGui::PopItemWidth();
		}
		ImGui::EndChild();
		ImGui::SameLine();
		ImGui::BeginChild(/*##la2*/XorStr<0x92, 6, 0x9B6AE9B1>("\xB1\xB0\xF8\xF4\xA4" + 0x9B6AE9B1).s, ImVec2(250, -1));
		{
			ImGui::PushItemWidth(itemWidth);

			Sakura::Menu::Widgets::Combo(
				/*Accuracy Boost*/XorStr<0xED, 15, 0x6F26896C>("\xAC\x8D\x8C\x85\x83\x93\x90\x8D\xD5\xB4\x98\x97\x8A\x8E" + 0x6F26896C).s,
				&cvar.legit[CheckWeapon(cvar.menu_legit_global_section, cvar.menu_legit_sub_section)].accuracy,
				/*Off\0Aiming\0Recoil\0Recoil / Spread\0*/XorStr<0xDA, 35, 0x789BCFB9>("\x95\xBD\xBA\xDD\x9F\xB6\x8D\x88\x8C\x84\xE4\xB7\x83\x84\x87\x80\x86\xEB\xBE\x88\x8D\x80\x99\x9D\xD2\xDC\xD4\xA6\x86\x85\x9D\x98\x9E\xFB" + 0x789BCFB9).s);

			ImGui::PopItemWidth();
		}
		ImGui::EndChild();
	}
}
```

`sakura/source/features/visuals/menu/tabs/menu_legit_tab.h`:

```h
#pragma once

namespace Sakura
{
	namespace Menu
	{
		namespace Tabs
		{
			namespace Legit
			{
				void Aimbot();
				void Triggerbot();
				void PerfectSilent();
				void Hitboxes();
				void Knifebot();
				//void Hitboxes();
				void Recoil();
			};
		};
	};
};
```

`sakura/source/features/visuals/menu/tabs/menu_misc_tab.cpp`:

```cpp
#include "../../../../client.h"

char newconfig[256];
int playerSelected;

void Sakura::Menu::Tabs::Misc::Kreedz()
{
	ImGui::BeginChild("##kreedz1", ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::Checkbox(/*Bunnyhop*/XorStr<0x5A, 9, 0x2FC0AE68>("\x18\x2E\x32\x33\x27\x37\x0F\x11" + 0x2FC0AE68).s, &cvar.kz_bhop);
		Sakura::Menu::Widgets::Checkbox(/*Fast Run*/XorStr<0x77, 9, 0xB0DCDD26>("\x31\x19\x0A\x0E\x5B\x2E\x08\x10" + 0xB0DCDD26).s, &cvar.kz_fast_run);
		Sakura::Menu::Widgets::Checkbox(/*Ground Strafe*/XorStr<0xCC, 14, 0x4F9DD0B7>("\x8B\xBF\xA1\xBA\xBE\xB5\xF2\x80\xA0\xA7\xB7\xB1\xBD" + 0x4F9DD0B7).s, &cvar.kz_ground_strafe);
		Sakura::Menu::Widgets::Checkbox(/*StandUp Ground Strafe*/XorStr<0x85, 22, 0xF68F9FAC>("\xD6\xF2\xE6\xE6\xED\xDF\xFB\xAC\xCA\xFC\xE0\xE5\xFF\xF6\xB3\xC7\xE1\xE4\xF6\xFE\xFC" + 0xF68F9FAC).s, &cvar.kz_sgs);
		Sakura::Menu::Widgets::Checkbox(/*Jump Bug*/XorStr<0xC5, 9, 0xC4CBDBAD>("\x8F\xB3\xAA\xB8\xE9\x88\xBE\xAB" + 0xC4CBDBAD).s, &cvar.kz_jump_bug);
		Sakura::Menu::Widgets::Checkbox(/*Jump Bug Auto*/XorStr<0xE4, 14, 0x58186214>("\xAE\x90\x8B\x97\xC8\xAB\x9F\x8C\xCC\xAC\x9B\x9B\x9F" + 0x58186214).s, &cvar.kz_jump_bug_auto);
		Sakura::Menu::Widgets::Checkbox(/*Strafe*/XorStr<0x7D, 7, 0x5900B760>("\x2E\x0A\x0D\xE1\xE7\xE7" + 0x5900B760).s, &cvar.kz_strafe);
		Sakura::Menu::Widgets::Checkbox(/*Strafe Perfect Silent*/XorStr<0x42, 22, 0xA6CF9E9F>("\x11\x37\x36\x24\x20\x22\x68\x19\x2F\x39\x2A\x28\x2D\x3B\x70\x02\x3B\x3F\x31\x3B\x22" + 0xA6CF9E9F).s, &cvar.kz_strafe_psilent);
		Sakura::Menu::Widgets::Checkbox(/*Hns Info Window*/XorStr<0x8C, 16, 0xACB2F8A6>("\xC4\xE3\xFD\xAF\xD9\xFF\xF4\xFC\xB4\xC2\xFF\xF9\xFC\xF6\xED" + 0xACB2F8A6).s, &cvar.kz_show_kz);
		Sakura::Menu::Widgets::Checkbox(/*Frame skip*/XorStr<0x23, 11, 0x6AB29E07>("\x65\x56\x44\x4B\x42\x08\x5A\x41\x42\x5C" + 0x6AB29E07).s, &cvar.misc_skipframes);
	}
	ImGui::EndChild();
	ImGui::SameLine();
	ImGui::BeginChild("##kreedz2", ImVec2(250, -1));
	{
		ImGui::PushItemWidth(itemWidth);
		Sakura::Menu::Widgets::SliderFloat(/*Bhop frames on ground*/XorStr<0x18, 22, 0x376034EF>("\x5A\x71\x75\x6B\x3C\x7B\x6C\x7E\x4D\x44\x51\x03\x4B\x4B\x06\x40\x5A\x46\x5F\x45\x48" + 0x376034EF).s, &cvar.kz_bhop_frames_on_ground, 0, 5, "%.0f");
		Sakura::Menu::Widgets::SliderFloat(/*Bhop ideal percentage*/XorStr<0x06, 22, 0xCAAD3F07>("\x44\x6F\x67\x79\x2A\x62\x68\x68\x6F\x63\x30\x61\x77\x61\x77\x70\x78\x63\x79\x7E\x7F" + 0xCAAD3F07).s, &cvar.kz_bhop_ideal_percentage, 0, 100, "%.0f%%");
		Sakura::Menu::Widgets::SliderFloat(/*SGS Ground origin*/XorStr<0x0B, 18, 0xE2BFA2E0>("\x58\x4B\x5E\x2E\x48\x62\x7E\x67\x7D\x70\x35\x79\x65\x71\x7E\x73\x75" + 0xE2BFA2E0).s, &cvar.kz_sgs_ground_origin, 2, 30, "%.0f");
		Sakura::Menu::Widgets::SliderFloat(/*Display Info Time*/XorStr<0x8C, 18, 0x8A6C3E16>("\xC8\xE4\xFD\xFF\xFC\xF0\xEB\xB3\xDD\xFB\xF0\xF8\xB8\xCD\xF3\xF6\xF9" + 0x8A6C3E16).s, &cvar.kz_display_time, 1, 20, "%.0f");
		Sakura::Menu::Widgets::SliderFloat(/*Frame skip count*/XorStr<0xE2, 17, 0x6F30B2A4>("\xA4\x91\x85\x88\x83\xC7\x9B\x82\x83\x9B\xCC\x8E\x81\x9A\x9E\x85" + 0x6F30B2A4).s, &cvar.misc_skipframes_count, 1, 10, "%.0f");
		ImGui::PopItemWidth();
	}
	ImGui::EndChild();
}

void Sakura::Menu::Tabs::Misc::Keybindings()
{
	ImGui::BeginChild("##keybindings1", ImVec2(250, -1));
	{
		HudMenuBind(cvar.gui_key);
		HudKeyBind(cvar.kz_bhop_key, /*Bhop Key*/XorStr<0x19, 9, 0xB172A456>("\x5B\x72\x74\x6C\x3D\x55\x7A\x59" + 0xB172A456).s, { ImGui::GetWindowSize().x - 6, 0 });
		HudKeyBind(cvar.kz_fastrun_key, /*Fastrun Key*/XorStr<0x8A, 12, 0xA5F66481>("\xCC\xEA\xFF\xF9\xFC\xFA\xFE\xB1\xD9\xF6\xED" + 0xA5F66481).s, { ImGui::GetWindowSize().x - 6, 0 });
		HudKeyBind(cvar.kz_ground_strafe_key, /*Gstrafe Key*/XorStr<0x0C, 12, 0xAF544FDD>("\x4B\x7E\x7A\x7D\x71\x77\x77\x33\x5F\x70\x6F" + 0xAF544FDD).s, { ImGui::GetWindowSize().x - 6, 0 });
		HudKeyBind(cvar.kz_jumpbug_key, /*Jumpbug Key*/XorStr<0xB7, 12, 0x58E2FDD1>("\xFD\xCD\xD4\xCA\xD9\xC9\xDA\x9E\xF4\xA5\xB8" + 0x58E2FDD1).s, { ImGui::GetWindowSize().x - 6, 0 });
		HudKeyBind(cvar.kz_strafe_key, /*Strafe Key*/XorStr<0x1D, 11, 0xABBC9BB7>("\x4E\x6A\x6D\x41\x47\x47\x03\x6F\x40\x5F" + 0xABBC9BB7).s, { ImGui::GetWindowSize().x - 6, 0 });
		HudKeyBind(cvar.kz_strafe_toggle_key, /*Strafe Toggle Key*/XorStr<0x53, 18, 0xB4B15F40>("\x00\x20\x27\x37\x31\x3D\x79\x0E\x34\x3B\x3A\x32\x3A\x40\x2A\x07\x1A" + 0xB4B15F40).s, { ImGui::GetWindowSize().x - 6, 0 });
		HudKeyBind(cvar.route_rush_key, /*Speedhack Key*/XorStr<0x61, 14, 0x05B04C95>("\x32\x12\x06\x01\x01\x0E\x06\x0B\x02\x4A\x20\x09\x14" + 0x05B04C95).s, { ImGui::GetWindowSize().x - 6, 0 });
	}
	ImGui::EndChild();
	ImGui::SameLine();
	ImGui::BeginChild("##keybindings2", ImVec2(250, -1));
	{
		HudKeyBind(cvar.misc_thirdperson_key, /*Thirdperson Key*/XorStr<0xA5, 16, 0xA4A06107>("\xF1\xCE\xCE\xDA\xCD\xDA\xCE\xDE\xDE\xC1\xC1\x90\xFA\xD7\xCA" + 0xA4A06107).s, { ImGui::GetWindowSize().x - 6, 0 });
		HudKeyBind(cvar.legit_key, /*Legit Fire Key*/XorStr<0xE6, 15, 0xBD74EBCF>("\xAA\x82\x8F\x80\x9E\xCB\xAA\x84\x9C\x8A\xD0\xBA\x97\x8A" + 0xBD74EBCF).s, { ImGui::GetWindowSize().x - 6, 0 });
		HudKeyBind(cvar.legit_trigger_key, /*Triggerbot Key*/XorStr<0x06, 15, 0xD8A750A4>("\x52\x75\x61\x6E\x6D\x6E\x7E\x6F\x61\x7B\x30\x5A\x77\x6A" + 0xD8A750A4).s, { ImGui::GetWindowSize().x - 6, 0 });
		HudKeyBind(cvar.rage_auto_fire_key, /*Rage Auto Fire Key*/XorStr<0xE2, 19, 0x4452C61C>("\xB0\x82\x83\x80\xC6\xA6\x9D\x9D\x85\xCB\xAA\x84\x9C\x8A\xD0\xBA\x97\x8A" + 0x4452C61C).s, { ImGui::GetWindowSize().x - 6, 0 });
	}
	ImGui::EndChild();
}

void Sakura::Menu::Tabs::Misc::Backtrack()
{
	ImGui::BeginChild("##backtrack1", ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::Checkbox(/*Enable*/XorStr<0x14, 7, 0x9D2621C8>("\x51\x7B\x77\x75\x74\x7C" + 0x9D2621C8).s, &cvar.misc_fakelatency);
		Sakura::Menu::Widgets::Checkbox(/*Light*/XorStr<0xED, 6, 0x83A61004>("\xA1\x87\x88\x98\x85" + 0x83A61004).s, &cvar.misc_backtrack_light);
		Sakura::Menu::Widgets::Checkbox(/*Chams Wireframe*/XorStr<0xDD, 16, 0x3A89888F>("\x9E\xB6\xBE\x8D\x92\xC2\xB4\x8D\x97\x83\x81\x9A\x88\x87\x8E" + 0x3A89888F).s, &cvar.misc_backtrack_wireframe);
	}
	ImGui::EndChild();
	ImGui::SameLine();
	ImGui::BeginChild("##backtrack2", ImVec2(250, -1));
	{
		ImGui::PushItemWidth(itemWidth);
		Sakura::Menu::Widgets::SliderFloat(/*Latency*/XorStr<0xF3, 8, 0xF7594FCB>("\xBF\x95\x81\x93\x99\x9B\x80" + 0xF7594FCB).s, &cvar.misc_fakelatency_amount, 0, 500, "+%.0fms");
		
		if (cvar.misc_backtrack_wireframe_mode)
			Sakura::Menu::Widgets::SliderFloat(/*Wireframe point size*/XorStr<0xCE, 21, 0x1F241978>("\x99\xA6\xA2\xB4\xB4\xA1\xB5\xB8\xB3\xF7\xA8\xB6\xB3\xB5\xA8\xFD\xAD\xB6\x9A\x84" + 0x1F241978).s, &cvar.misc_backtrack_wireframe_point_size, 1.f, 5.f, "%.1f");
		else
			Sakura::Menu::Widgets::SliderFloat(/*Wireframe line width*/XorStr<0xA2, 21, 0xBBA95C48>("\xF5\xCA\xD6\xC0\xC0\xD5\xC9\xC4\xCF\x8B\xC0\xC4\xC0\xCA\x90\xC6\xDB\xD7\xC0\xDD" + 0xBBA95C48).s, &cvar.misc_backtrack_wireframe_line_width, 1.f, 5.f, "%.1f");

		Sakura::Menu::Widgets::Combo(
			/*Chams*/XorStr<0x31, 6, 0xB8BE549B>("\x72\x5A\x52\x59\x46" + 0xB8BE549B).s,
			&cvar.misc_backtrack_chams,
			/*Off\0Material\0Texture\0Flat\0*/XorStr<0x89, 27, 0x62B4F577>("\xC6\xEC\xED\x8C\xC0\xEF\xFB\xF5\xE3\xFB\xF2\xF8\x95\xC2\xF2\xE0\xED\xEF\xE9\xF9\x9D\xD8\xF3\xC1\xD5\xA2" + 0x62B4F577).s);
		
		Sakura::Menu::Widgets::Combo(
			/*Chams Wireframe Type*/XorStr<0x81, 21, 0xBCB1BE42>("\xC2\xEA\xE2\xE9\xF6\xA6\xD0\xE1\xFB\xEF\xED\xFE\xEC\xE3\xEA\xB0\xC5\xEB\xE3\xF1" + 0xBCB1BE42).s,
			&cvar.misc_backtrack_wireframe_mode,
			/*Lines\0Points\0*/XorStr<0x2E, 14, 0x231B4418>("\x62\x46\x5E\x54\x41\x33\x64\x5A\x5F\x59\x4C\x4A\x3A" + 0x231B4418).s);
		
		ImGui::PopItemWidth();
	}
	ImGui::EndChild();
}

void Sakura::Menu::Tabs::Misc::Route()
{
	ImGui::BeginChild("##route1", ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::Checkbox(/*Enable*/XorStr<0x58, 7, 0x68381F8B>("\x1D\x37\x3B\x39\x30\x38" + 0x68381F8B).s, &cvar.route_activate);
		Sakura::Menu::Widgets::Checkbox(/*Draw Route*/XorStr<0x98, 11, 0x017EBBBC>("\xDC\xEB\xFB\xEC\xBC\xCF\xF1\xEA\xD4\xC4" + 0x017EBBBC).s, &cvar.route_draw);
		Sakura::Menu::Widgets::Checkbox(/*Visual While Rushing*/XorStr<0x6F, 21, 0x199D6821>("\x39\x19\x02\x07\x12\x18\x55\x21\x1F\x11\x15\x1F\x5B\x2E\x08\x0D\x17\xE9\xEF\xE5" + 0x199D6821).s, &cvar.route_draw_visual);
	}
	ImGui::EndChild();
	ImGui::SameLine();
	ImGui::BeginChild("##route2", ImVec2(250, -1));
	{
		ImGui::PushItemWidth(itemWidth);
		Sakura::Menu::Widgets::SliderFloat(/*Direction Steps*/XorStr<0x26, 16, 0x87C477C7>("\x62\x4E\x5A\x4C\x49\x5F\x45\x42\x40\x0F\x63\x45\x57\x43\x47" + 0x87C477C7).s, &cvar.route_direction_step, 1.f, 10.f, "%.0f");
		Sakura::Menu::Widgets::SliderFloat(/*Jump Steps*/XorStr<0x8D, 11, 0x4101FDB6>("\xC7\xFB\xE2\xE0\xB1\xC1\xE7\xF1\xE5\xE5" + 0x4101FDB6).s, &cvar.route_jump_step, 1.f, 10.f, "%.0f");
		
		Sakura::Menu::Widgets::Combo(
			/*Route Mode*/XorStr<0xE2, 11, 0xAB26C36C>("\xB0\x8C\x91\x91\x83\xC7\xA5\x86\x8E\x8E" + 0xAB26C36C).s,
			&cvar.route_mode,
			/*Stay in route\0Go after target\0*/XorStr<0xB2, 31, 0x2518CA81>("\xE1\xC7\xD5\xCC\x96\xDE\xD6\x99\xC8\xD4\xC9\xC9\xDB\xBF\x87\xAE\xE2\xA2\xA2\xB1\xA3\xB5\xE8\xBD\xAB\xB9\xAB\xA8\xBA\xCF" + 0x2518CA81).s);
		
		ImGui::PopItemWidth();

		ImGui::Spacing();
		ImGui::Spacing();
		ImGui::Spacing();
		ImGui::Spacing();
		ImGui::Spacing();
		ImGui::Spacing();

		if (Sakura::Menu::Widgets::Button(/*Start*/XorStr<0x0A, 6, 0x23F9E94C>("\x59\x7F\x6D\x7F\x7A" + 0x23F9E94C).s, { ImGui::GetWindowSize().x - 6, 0 }))
		{
			autoroute.RecordAnyRouteStart();
			Toast::Create(6, /*Recording started!*/XorStr<0x14,19,0x98EDD3D3>("\x46\x70\x75\x78\x6A\x7D\x73\x75\x7B\x3D\x6D\x6B\x41\x53\x56\x46\x40\x04" + 0x98EDD3D3).s);
		}

		if (Sakura::Menu::Widgets::Button(/*Stop*/XorStr<0xB7, 5, 0x9D58765C>("\xE4\xCC\xD6\xCA" + 0x9D58765C).s, { ImGui::GetWindowSize().x - 6, 0 }))
		{
			autoroute.RecordRouteStop();
			Toast::Create(6, /*Recording stopped!*/XorStr<0x53,19,0xC152F01C>("\x01\x31\x36\x39\x25\x3C\x30\x34\x3C\x7C\x2E\x2A\x30\x10\x11\x07\x07\x45" + 0xC152F01C).s);
		}

		if (Sakura::Menu::Widgets::Button(/*Add Point*/XorStr<0xC6, 10, 0x557F41F9>("\x87\xA3\xAC\xE9\x9A\xA4\xA5\xA3\xBA" + 0x557F41F9).s, { ImGui::GetWindowSize().x - 6, 0 }))
		{
			autoroute.AddPoint();
			Toast::Create(3, /*Point added*/XorStr<0x06,12,0xB7D6C6FB>("\x56\x68\x61\x67\x7E\x2B\x6D\x69\x6A\x6A\x74" + 0xB7D6C6FB).s);
		}

		if (Sakura::Menu::Widgets::Button(/*Clear*/XorStr<0x00, 6, 0x9F0AC6F5>("\x43\x6D\x67\x62\x76" + 0x9F0AC6F5).s, { ImGui::GetWindowSize().x - 6, 0 }))
		{
			autoroute.ClearAllRoute();
			Toast::Create(3, /*Cleared route*/XorStr<0xA8,14,0xD3EA6D95>("\xEB\xC5\xCF\xCA\xDE\xC8\xCA\x8F\xC2\xDE\xC7\xC7\xD1" + 0xD3EA6D95).s);
		}

		if (Sakura::Menu::Widgets::Button(/*Save*/XorStr<0x85, 5, 0x38101CED>("\xD6\xE7\xF1\xED" + 0x38101CED).s, { ImGui::GetWindowSize().x - 6, 0 }))
		{
			autoroute.SaveRoute();
			Toast::Create(3, /*Saved*/XorStr<0x66,6,0x82667591>("\x35\x06\x1E\x0C\x0E" + 0x82667591).s);
		}

		if (Sakura::Menu::Widgets::Button(/*Load*/XorStr<0x17, 5, 0xF8C50F5B>("\x5B\x77\x78\x7E" + 0xF8C50F5B).s, { ImGui::GetWindowSize().x - 6, 0 }))
		{
			autoroute.LoadRoute("");
			Toast::Create(3, /*Loaded*/XorStr<0xA2,7,0x67F28644>("\xEE\xCC\xC5\xC1\xC3\xC3" + 0x67F28644).s);
		}
	}
	ImGui::EndChild();
}

void Sakura::Menu::Tabs::Misc::SidChanger()
{
	if (c_Offset.HLType != RENDERTYPE_UNDEFINED)
	{
		int steamid[7] = { int(cvar.id1), int(cvar.id2), int(cvar.id3), int(cvar.id4), int(cvar.id5), int(cvar.id6), int(cvar.id7) };

		ImGui::PushItemWidth(itemWidth * 2);
		
		Sakura::Menu::Widgets::Combo(
			/*Steam ID Method*/XorStr<0xB4, 16, 0x2735908D>("\xE7\xC1\xD3\xD6\xD5\x99\xF3\xFF\x9C\xF0\xDB\xCB\xA8\xAE\xA6" + 0x2735908D).s,
			&cvar.steamid,
			/*Off\0Auto\0Manual\0Custom\0*/XorStr<0xB2, 24, 0x8B5C980B>("\xFD\xD5\xD2\xB5\xF7\xC2\xCC\xD6\xBA\xF6\xDD\xD3\xCB\xDE\xAC\xC1\x81\xB6\xB7\xB1\xA9\xAA\xC8" + 0x8B5C980B).s);
		
		ImGui::PopItemWidth();

		switch (static_cast<int>(cvar.steamid))
		{
		case 1:
			ImGui::Text(/*Your SID will change automatically*/XorStr<0x60, 35, 0x2CA2AAE5>("\x39\x0E\x17\x11\x44\x36\x2F\x23\x48\x1E\x03\x07\x00\x4D\x0D\x07\x11\x1F\x15\x16\x54\x14\x03\x03\x17\x14\x1B\x0F\x15\x1E\x1F\x13\xEC\xF8" + 0x2CA2AAE5).s);
			break;
		case 2:
			ImGui::PushItemWidth(itemWidth * 2);
			//Sakura::Menu::Widgets::SliderFloat("SID", steamid, 0, 35, "%.0f", 1.f);
			ImGui::Text(/*Hold and drag*/XorStr<0xBE, 14, 0x297B4B45>("\xF6\xD0\xAC\xA5\xE2\xA2\xAA\xA1\xE6\xA3\xBA\xA8\xAD" + 0x297B4B45).s);
			ImGui::DragInt4("##1", steamid, 1, 0, 35);
			//ImGui::DragInt7("##1", steamid, 1, 0, 35);
			ImGui::PopItemWidth();

			cvar.id1 = steamid[0];
			cvar.id2 = steamid[1];
			cvar.id3 = steamid[2];
			cvar.id4 = steamid[3];
			cvar.id5 = steamid[4];
			cvar.id6 = steamid[5];
			cvar.id7 = steamid[6];
			if (cvar.id1 > 35 || cvar.id1 < 0)cvar.id1 = 1;
			if (cvar.id2 > 35 || cvar.id2 < 0)cvar.id2 = 2;
			if (cvar.id3 > 35 || cvar.id3 < 0)cvar.id3 = 3;
			if (cvar.id4 > 35 || cvar.id4 < 0)cvar.id4 = 4;
			if (cvar.id5 > 35 || cvar.id5 < 0)cvar.id5 = 5;
			if (cvar.id6 > 35 || cvar.id6 < 0)cvar.id6 = 6;
			if (cvar.id7 > 35 || cvar.id7 < 0)cvar.id7 = 7;
			break;
		case 3:
			ImGui::PushItemWidth(itemWidth * 2);
			ImGui::Text(/*SID:*/XorStr<0x31, 5, 0xFBCD8E7B>("\x62\x7B\x77\x0E" + 0xFBCD8E7B).s);
			ImGui::InputText("", customSteamId, 7);
			ImGui::PopItemWidth();
			break;
		}
	}
	else
		ImGui::Text(/*SID Not Available*/XorStr<0x16, 18, 0x479048D4>("\x45\x5E\x5C\x39\x54\x74\x68\x3D\x5F\x69\x41\x48\x4E\x42\x46\x49\x43" + 0x479048D4).s);
}

void Sakura::Menu::Tabs::Misc::AntiAFK()
{
	ImGui::BeginChild("##antiafk1", ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::Checkbox(/*Enable anti afk*/XorStr<0xBA, 16, 0xEAB0697C>("\xFF\xD5\xDD\xDF\xD2\xDA\xE0\xA0\xAC\xB7\xAD\xE5\xA7\xA1\xA3" + 0xEAB0697C).s, &cvar.afk_anti);
	}
	ImGui::EndChild();
	ImGui::SameLine();
	ImGui::BeginChild("##antiafk2", ImVec2(250, -1));
	{
		ImGui::PushItemWidth(itemWidth);
		Sakura::Menu::Widgets::SliderFloat(/*Time*/XorStr<0x67, 5, 0xFD0EB92C>("\x33\x01\x04\x0F" + 0xFD0EB92C).s, &cvar.afk_time, 3, 90, /*%.0fs*/XorStr<0xAE, 6, 0x0747556F>("\x8B\x81\x80\xD7\xC1" + 0x0747556F).s);
		Sakura::Menu::Widgets::SliderFloat(/*Yaw degree*/XorStr<0xCA, 11, 0xEDA444AF>("\x93\xAA\xBB\xED\xAA\xAA\xB7\xA3\xB7\xB6" + 0xEDA444AF).s, &cvar.afk_yaw, -45, 45, u8"%.0f°");
		ImGui::PopItemWidth();
	}
	ImGui::EndChild();
}

void Sakura::Menu::Tabs::Misc::PlayerList()
{
	ImGui::BeginChild("##playerlist1", ImVec2(250, -1));
	{
		ImGui::PushStyleColor(ImGuiCol_Header, (ImVec4)Sakura::Menu::GetMenuColor(0.39f));
		ImGui::PushStyleColor(ImGuiCol_HeaderHovered, (ImVec4)Sakura::Menu::GetMenuColor(0.80f));
		ImGui::PushStyleColor(ImGuiCol_HeaderActive, (ImVec4)Sakura::Menu::GetMenuColor(1.00f));
		ImGui::PushStyleColor(ImGuiCol_FrameBg, (ImVec4)ImColor(0, 0, 0, 50));
		ImGui::ListBoxHeader(/*playerlist*/XorStr<0xC8, 11, 0xDD30E08A>("\xB8\xA5\xAB\xB2\xA9\xBF\xA2\xA6\xA3\xA5" + 0xDD30E08A).s, ImVec2(250, -1));
		{
			// first we are adding tt players
			for (unsigned int id = 0; id <= g_Engine.GetMaxClients(); id++)
			{
				if (id == pmove->player_index + 1)
					continue;

				player_info_s* player = g_Studio.PlayerInfo(id - 1);

				if (!player || !(lstrlenA(player->name) > 0))
					continue;

				if (g_Player[id].iTeam != TEAM_TT)
					continue;

				bool is_selected = (playerSelected == id);
				ImGui::PushStyleColor(ImGuiCol_Text, g_Player[id].bAliveInScoreTab ? ImVec4(1.f, 0.5f, 0.5f, 1.f) : ImVec4(1.f, 0.15f, 0.15f, 0.5f));
				if (ImGui::Selectable(player->name, &is_selected))
				{
					playerSelected = -1;
					IdHook::AddPlayer(id);
				}
				ImGui::PopStyleColor();

				switch (IdHook::FirstKillPlayer[id])
				{
				case IDHOOK_PLAYER_NONE:

					break;
				case IDHOOK_PLAYER_ON:
					ImGui::SameLine();
					ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.5f, 1.f, 0.5f, 1.f));
					ImGui::Text(/*[ON]*/XorStr<0xAA, 5, 0x2DE0A2A8>("\xF1\xE4\xE2\xF0" + 0x2DE0A2A8).s);
					ImGui::PopStyleColor();
					break;
				case IDHOOK_PLAYER_OFF:
					ImGui::SameLine();
					ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(1.f, 0.f, 0.f, 1.f));
					ImGui::Text(/*[OFF]*/XorStr<0x3D, 6, 0xEBD3A96B>("\x66\x71\x79\x06\x1C" + 0xEBD3A96B).s);
					ImGui::PopStyleColor();
					break;
				}

				if (g_Player[id].bVip)
				{
					ImGui::SameLine();
					ImGui::PushFont(Sakura::Menu::Fonts::icons);
					ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(1.f, 1.f, 0.f, 1.f));
					ImGui::SetCursorPosX(ImGui::GetCursorPosX() - 5);
					ImGui::SetCursorPosY(ImGui::GetCursorPosY() - 5);
					ImGui::Text(/*g*/XorStr<0x64, 2, 0xA25B40C7>("\x03" + 0xA25B40C7).s);
					ImGui::PopStyleColor();
					ImGui::PopFont();
				}
			}

			// now the ct players
			for (unsigned int id = 0; id <= g_Engine.GetMaxClients(); id++)
			{
				if (id == pmove->player_index + 1)
					continue;

				player_info_s* player = g_Studio.PlayerInfo(id - 1);

				if (!player || !(lstrlenA(player->name) > 0))
					continue;

				if (g_Player[id].iTeam != TEAM_CT)
					continue;

				bool is_selected = (playerSelected == id);
				ImGui::PushStyleColor(ImGuiCol_Text, g_Player[id].bAliveInScoreTab ? ImVec4(0.5f, 0.5f, 1.f, 1.f) : ImVec4(0.15f, 0.15f, 1.f, 0.5f));
				if (ImGui::Selectable(player->name, &is_selected))
				{
					playerSelected = -1;
					IdHook::AddPlayer(id);
				}
				ImGui::PopStyleColor();

				switch (IdHook::FirstKillPlayer[id])
				{
				case IDHOOK_PLAYER_NONE:

					break;
				case IDHOOK_PLAYER_ON:
					ImGui::SameLine();
					//ImGui::SetCursorPosX(ImGui::GetCursorPosX() - 5);
					//ImGui::SetCursorPosY(ImGui::GetCursorPosY() - 5);
					ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.5f, 1.f, 0.5f, 1.f));
					ImGui::Text(/*[ON]*/XorStr<0xAA, 5, 0x2DE0A2A8>("\xF1\xE4\xE2\xF0" + 0x2DE0A2A8).s);
					ImGui::PopStyleColor();
					break;
				case IDHOOK_PLAYER_OFF:
					ImGui::SameLine();
					//ImGui::SetCursorPosX(ImGui::GetCursorPosX() - 5);
					//ImGui::SetCursorPosY(ImGui::GetCursorPosY() - 5);
					ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(1.f, 0.f, 0.f, 1.f));
					ImGui::Text(/*[OFF]*/XorStr<0x3D, 6, 0xEBD3A96B>("\x66\x71\x79\x06\x1C" + 0xEBD3A96B).s);
					ImGui::PopStyleColor();
					break;
				}

				if (g_Player[id].bVip)
				{
					ImGui::SameLine();
					ImGui::PushFont(Sakura::Menu::Fonts::icons);
					ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(1.f, 1.f, 0.f, 1.f));
					ImGui::SetCursorPosX(ImGui::GetCursorPosX() - 5);
					ImGui::SetCursorPosY(ImGui::GetCursorPosY() - 5);
					ImGui::Text(/*g*/XorStr<0x64, 2, 0xA25B40C7>("\x03" + 0xA25B40C7).s);
					ImGui::PopStyleColor();
					ImGui::PopFont();
				}
			}
		}
		ImGui::ListBoxFooter();
		ImGui::PopStyleColor(4);
	}
	ImGui::EndChild();
	ImGui::SameLine();
	ImGui::BeginChild("##playerlist2", ImVec2(250, -1));
	{
		switch (static_cast<int>(cvar.aim_id_mode))
		{
		case IDHOOK_ATTACK_ALL:
			if (Sakura::Menu::Widgets::Button(/*Attack all*/XorStr<0x93, 11, 0xDC913528>("\xD2\xE0\xE1\xF7\xF4\xF3\xB9\xFB\xF7\xF0" + 0xDC913528).s, { ImGui::GetWindowSize().x - 6, 0 }))
				IdHook::First_Kill_Mode();

			break;

		case IDHOOK_ATTACK_ON_DONT_ATTACK_OFF:
			if (Sakura::Menu::Widgets::Button(/*Attack on first - don't attack off*/XorStr<0x51, 35, 0x315932F7>("\x10\x26\x27\x35\x36\x3D\x77\x37\x37\x7A\x3D\x35\x2F\x2D\x2B\x40\x4C\x42\x07\x0B\x0B\x41\x13\x48\x08\x1E\x1F\x0D\x0E\x05\x4F\x1F\x17\x14" + 0x315932F7).s, { ImGui::GetWindowSize().x - 6, 0 }))
				IdHook::First_Kill_Mode();

			break;

		case IDHOOK_ATTACK_ON:
			if (Sakura::Menu::Widgets::Button(/*Attack only on*/XorStr<0x3F, 15, 0xC3E2C53C>("\x7E\x34\x35\x23\x20\x2F\x65\x29\x29\x24\x30\x6A\x24\x22" + 0xC3E2C53C).s, { ImGui::GetWindowSize().x - 6, 0 }))
				IdHook::First_Kill_Mode();

			break;
		}

		if (Sakura::Menu::Widgets::Button(/*Clear players*/XorStr<0xF8, 14, 0x4CBFB9BE>("\xBB\x95\x9F\x9A\x8E\xDD\x8E\x93\x61\x78\x67\x71\x77" + 0x4CBFB9BE).s, { ImGui::GetWindowSize().x - 6, 0 }))
			IdHook::ClearPlayer();

		ImGui::Spacing();
		ImGui::Spacing();

		Sakura::Menu::Widgets::Checkbox(/*Don't draw on OFF*/XorStr<0x82, 18, 0x2047F43E>("\xC6\xEC\xEA\xA2\xF2\xA7\xEC\xFB\xEB\xFC\xAC\xE2\xE0\xAF\xDF\xD7\xD4" + 0x2047F43E).s, &cvar.visual_idhook_only);
	}
	ImGui::EndChild();
}

void Sakura::Menu::Tabs::Misc::Notify()
{
	ImVec2 windowSize = ImGui::GetIO().DisplaySize;

	ImGui::BeginChild("##notify1", ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::Checkbox(/*Enable*/XorStr<0x16, 7, 0x2FA43D44>("\x53\x79\x79\x7B\x76\x7E" + 0x2FA43D44).s, &cvar.notifications_enable);
		Sakura::Menu::Widgets::Checkbox(/*No background*/XorStr<0xF3, 14, 0xD8625AF8>("\xBD\x9B\xD5\x94\x96\x9B\x92\x9D\x89\x93\x88\x90\x9B" + 0xD8625AF8).s, &cvar.notifications_text_only);

		ImGui::Spacing();
		ImGui::Spacing();

		Sakura::Menu::Widgets::Checkbox(/*Weapon name on pickup*/XorStr<0x2A, 22, 0x836431C6>("\x7D\x4E\x4D\x5D\x41\x41\x10\x5F\x53\x5E\x51\x15\x59\x59\x18\x49\x53\x58\x57\x48\x4E" + 0x836431C6).s, &cvar.visual_weapon_local);
	}
	ImGui::EndChild();
	ImGui::SameLine();
	ImGui::BeginChild("##notify2", ImVec2(250, -1));
	{
		ImGui::PushItemWidth(itemWidth);
		Sakura::Menu::Widgets::SliderFloat(/*Fade time*/XorStr<0x15, 10, 0xB6BC7FC0>("\x53\x77\x73\x7D\x39\x6E\x72\x71\x78" + 0xB6BC7FC0).s, &cvar.notifications_fade, 50.f, 500.f, "%.0fms");
		Sakura::Menu::Widgets::SliderFloat(/*X Position*/XorStr<0x18, 11, 0x9EB0AA61>("\x40\x39\x4A\x74\x6F\x74\x6A\x76\x4F\x4F" + 0x9EB0AA61).s, &cvar.notifications_x, 0.f, windowSize.x, "%.0f");
		Sakura::Menu::Widgets::SliderFloat(/*Y Position*/XorStr<0x00, 11, 0x70F14FD2>("\x59\x21\x52\x6C\x77\x6C\x72\x6E\x67\x67" + 0x70F14FD2).s, &cvar.notifications_y, 0.f, windowSize.y, "%.0f");
		
		if (Sakura::Menu::Widgets::Button(/*Center*/XorStr<0x25, 7, 0x3269A9E9>("\x66\x43\x49\x5C\x4C\x58" + 0x3269A9E9).s, { ImGui::GetWindowSize().x - 6, 0 }))
		{
			cvar.notifications_x = windowSize.x / 2;
			cvar.notifications_y = windowSize.y / 2;
		}

		ImGui::PopItemWidth();
	}
	ImGui::EndChild();
}

void Sakura::Menu::Tabs::Misc::NameStealer()
{
	ImGui::BeginChild(/*##ns1*/XorStr<0xD3, 6, 0x7793227E>("\xF0\xF7\xBB\xA5\xE6" + 0x7793227E).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::Checkbox(/*Enable*/XorStr<0x02, 7, 0x873F1E85>("\x47\x6D\x65\x67\x6A\x62" + 0x873F1E85).s, &cvar.misc_namestealer);
		Sakura::Menu::Widgets::Checkbox(/*Ignore off players on list*/XorStr<0xB1, 27, 0x39D42FAF>("\xF8\xD5\xDD\xDB\xC7\xD3\x97\xD7\xDF\xDC\x9B\xCC\xD1\xDF\xC6\xA5\xB3\xB1\xE3\xAB\xAB\xE6\xAB\xA1\xBA\xBE" + 0x39D42FAF).s, &cvar.misc_namestealer_playerlist);
		Sakura::Menu::Widgets::Checkbox(/*Ignore spectators*/XorStr<0x74, 18, 0xB6B1FB7D>("\x3D\x12\x18\x18\x0A\x1C\x5A\x08\x0C\x18\x1D\x0B\xE1\xF5\xED\xF1\xF7" + 0xB6B1FB7D).s, &cvar.misc_namestealer_specs);
	}
	ImGui::EndChild();
	ImGui::SameLine();
	ImGui::BeginChild(/*##ns2*/XorStr<0xBC, 6, 0x011CAA0B>("\x9F\x9E\xD0\xCC\xF2" + 0x011CAA0B).s, ImVec2(250, -1));
	{
		ImGui::PushItemWidth(itemWidth);
		Sakura::Menu::Widgets::SliderFloat(/*Time between steal*/XorStr<0xF6, 19, 0x75DE95DE>("\xA2\x9E\x95\x9C\xDA\x99\x99\x89\x89\x9A\x65\x6F\x22\x70\x70\x60\x67\x6B" + 0x75DE95DE).s, &cvar.misc_namestealer_time, 2.f, 15.f, "%.0fs");
		ImGui::PopItemWidth();
	}
	ImGui::EndChild();
}

void Sakura::Menu::Tabs::Misc::ChatSpammer()
{
	ImGui::BeginChild(/*##ns1*/XorStr<0x98, 6, 0xAB637D7C>("\xBB\xBA\xF4\xE8\xAD" + 0xAB637D7C).s, ImVec2(250, 30));
	{
		Sakura::Menu::Widgets::Checkbox(/*Enable*/XorStr<0xC7, 7, 0xA8D5FDAF>("\x82\xA6\xA8\xA8\xA7\xA9" + 0xA8D5FDAF).s, &cvar.misc_chatspammer);
	}
	ImGui::EndChild();
	ImGui::SameLine();
	ImGui::BeginChild(/*##ns2*/XorStr<0xC3, 6, 0x2B0825BA>("\xE0\xE7\xAB\xB5\xF5" + 0x2B0825BA).s, ImVec2(250, 30));
	{
		ImGui::PushItemWidth(itemWidth);
		Sakura::Menu::Widgets::SliderFloat(/*Chat spammer time*/XorStr<0xED, 18, 0x6347BCD9>("\xAE\x86\x8E\x84\xD1\x81\x83\x95\x98\x9B\x92\x8A\xD9\x8E\x92\x91\x98" + 0x6347BCD9).s, &cvar.misc_chatspammer_time, 2.f, 25.f, "%.0fs");
		ImGui::PopItemWidth();
	}
	ImGui::EndChild();
	ImGui::Text(/*Message*/XorStr<0xCC, 8, 0xE278D1E6>("\x81\xA8\xBD\xBC\xB1\xB6\xB7" + 0xE278D1E6).s);
	ImGui::PushItemWidth(itemWidth * 2);
	ImGui::InputText("", chatspam, 128);
	ImGui::PopItemWidth();
}

void Sakura::Menu::Tabs::Misc::Config()
{
	static int loadedConfig = Sakura::Config::SelectedConfig;

	ImGui::BeginChild(/*##mc1*/XorStr<0xD6, 6, 0xDEE8EC02>("\xF5\xF4\xB5\xBA\xEB" + 0xDEE8EC02).s, ImVec2(250, -1));
	{
		const char** items = new const char*[Sakura::Config::List.size()];
		ImGuiWindow* window = ImGui::GetCurrentWindow();

		for (size_t i = 0; i < Sakura::Config::List.size(); i++) {
			char* copy = new char[Sakura::Config::List[i].size() + 1];

			std::strcpy(copy, Sakura::Config::List[i].c_str());

			items[i] = copy;
		}

		ImGui::PushStyleColor(ImGuiCol_Header, (ImVec4)Sakura::Menu::GetMenuColor(0.39f));
		ImGui::PushStyleColor(ImGuiCol_HeaderHovered, (ImVec4)Sakura::Menu::GetMenuColor(0.80f));
		ImGui::PushStyleColor(ImGuiCol_HeaderActive, (ImVec4)Sakura::Menu::GetMenuColor(1.00f));
		ImGui::PushStyleColor(ImGuiCol_FrameBg, (ImVec4)ImColor(0, 0, 0, 50));
		ImGui::BeginListBox(/*##configslist*/XorStr<0x00, 14, 0x769FFB02>("\x23\x22\x61\x6C\x6A\x63\x6F\x60\x7B\x65\x63\x78\x78" + 0x769FFB02).s, ImVec2(250, -1));
		{
			for (int i = 0; i < Sakura::Config::List.size(); i++)
			{
				bool is_selected = (Sakura::Config::SelectedConfig == i);
				if (ImGui::Selectable(Sakura::Config::List[i].c_str(), &is_selected))
				{
					Sakura::Config::SelectedConfig = i;
				}

				if (Sakura::Config::DefaultConfig == i)
				{
					ImGui::SameLine();
					ImGui::PushFont(Sakura::Menu::Fonts::icons);
					ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(1.f, 1.f, 0.f, 1.f));
					ImGui::SetCursorPosX(ImGui::GetCursorPosX() - 5);
					ImGui::SetCursorPosY(ImGui::GetCursorPosY() - 5);
					ImGui::Text(/*g*/XorStr<0x64, 2, 0xA25B40C7>("\x03" + 0xA25B40C7).s);
					ImGui::PopStyleColor();
					ImGui::PopFont();
				}

				if (loadedConfig == i)
				{
					ImGui::SameLine();
					ImGui::PushFont(Sakura::Menu::Fonts::icons);
					ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.f, 1.f, 0.f, 1.f));
					ImGui::SetCursorPosX(ImGui::GetCursorPosX() - 10);
					ImGui::SetCursorPosY(ImGui::GetCursorPosY() - 5);
					ImGui::Text(/*h*/XorStr<0xD6, 2, 0x6A75677A>("\xBE" + 0x6A75677A).s);
					ImGui::PopStyleColor();
					ImGui::PopFont();
				}
			}
		}
		ImGui::EndListBox();
		ImGui::PopStyleColor(4);
		// is this nessecary?
		for (size_t i = 0; i < Sakura::Config::List.size(); i++) {
			delete[] items[i];  // deallocate the copies of the strings
		}
		delete[] items;
	}
	ImGui::EndChild();
	ImGui::SameLine();
	ImGui::BeginChild(/*##mc2*/XorStr<0x55, 6, 0xB5FD1983>("\x76\x75\x3A\x3B\x6B" + 0xB5FD1983).s, ImVec2(250, -1));
	{
		ImGui::InputText("", newconfig, 256);
		ImGui::SameLine();
		if (Sakura::Menu::Widgets::Button(/*Create*/XorStr<0x7C, 7, 0x69A6E480>("\x3F\x0F\x1B\x1E\xF4\xE4" + 0x69A6E480).s, { 75, 0 }))
		{
			std::string e = /*.ini*/XorStr<0x08, 5, 0xF8110B7F>("\x26\x60\x64\x62" + 0xF8110B7F).s;
			std::string temp = newconfig + e;
			Sakura::Config::List.push_back(temp);

			Toast::Create(3, /*Created config %s*/XorStr<0xD0,18,0x49BAC5C2>("\x93\xA3\xB7\xB2\xA0\xB0\xB2\xF7\xBB\xB6\xB4\xBD\xB5\xBA\xFE\xFA\x93" + 0x49BAC5C2).s, temp.c_str());
		}

		ImGui::Spacing();

		if (Sakura::Menu::Widgets::Button(/*Load config*/XorStr<0xE3, 12, 0x042819E3>("\xAF\x8B\x84\x82\xC7\x8B\x86\x84\x8D\x85\x8A" + 0x042819E3).s, { ImGui::GetWindowSize().x - 6, 0 }))
		{
			LoadCvar();
			loadedConfig = Sakura::Config::SelectedConfig;
 
			if (cvar.gui_key < 0 || cvar.gui_key > 254)
				cvar.gui_key = K_INS;
		}

		if (Sakura::Menu::Widgets::Button(/*Save Config*/XorStr<0x8F, 12, 0x7F254F47>("\xDC\xF1\xE7\xF7\xB3\xD7\xFA\xF8\xF1\xF1\xFE" + 0x7F254F47).s, { ImGui::GetWindowSize().x - 6, 0 }))
		{
			SaveCvar();
			Toast::Create(3, /*Saved config %s*/XorStr<0x85,16,0x55B424ED>("\xD6\xE7\xF1\xED\xED\xAA\xE8\xE3\xE3\xE8\xE6\xF7\xB1\xB7\xE0" + 0x55B424ED).s, Sakura::Config::List[Sakura::Config::SelectedConfig].c_str());
		}

		if (Sakura::Menu::Widgets::Button(/*Reload Config*/XorStr<0xA1, 14, 0xAF8631AF>("\xF3\xC7\xCF\xCB\xC4\xC2\x87\xEB\xC6\xC4\xCD\xC5\xCA" + 0xAF8631AF).s, { ImGui::GetWindowSize().x - 6, 0 }))
		{
			LoadCvar();
			Toast::Create(3, /*Reloaded config %s*/XorStr<0xC8,19,0x69BECD03>("\x9A\xAC\xA6\xA4\xAD\xA9\xAB\xAB\xF0\xB2\xBD\xBD\xB2\xBC\xB1\xF7\xFD\xAA" + 0x69BECD03).s, Sakura::Config::List[Sakura::Config::SelectedConfig].c_str());
		}

		if (Sakura::Menu::Widgets::Button(/*Make Config Default*/XorStr<0xFA, 20, 0x11A0245F>("\xB7\x9A\x97\x98\xDE\xBC\x6F\x6F\x64\x6A\x63\x25\x42\x62\x6E\x68\x7F\x67\x78" + 0x11A0245F).s, { ImGui::GetWindowSize().x - 6, 0 }))
		{
			Sakura::Config::DefaultConfig = Sakura::Config::SelectedConfig;
			Sakura::Config::SaveDefault();
			Toast::Create(3, /*Config %s is now default!*/XorStr<0xC6,26,0x1E02EDE2>("\x85\xA8\xA6\xAF\xA3\xAC\xEC\xE8\xBD\xEF\xB9\xA2\xF2\xBD\xBB\xA2\xF6\xB3\xBD\xBF\xBB\xAE\xB0\xA9\xFF" + 0x1E02EDE2).s, Sakura::Config::List[Sakura::Config::SelectedConfig].c_str());
		}

		if (Sakura::Menu::Widgets::Button(/*Reload Lua*/XorStr<0x12, 11, 0x8D4E7E59>("\x40\x76\x78\x7A\x77\x73\x38\x55\x6F\x7A" + 0x8D4E7E59).s, { ImGui::GetWindowSize().x - 6, 0 }))
		{
			Sakura::Lua::Reload();
			Sakura::Sound::ReInit();
			Toast::Create(3, /*Reloaded LUA*/XorStr<0xA8,13,0x688BFE62>("\xFA\xCC\xC6\xC4\xCD\xC9\xCB\xCB\x90\xFD\xE7\xF2" + 0x688BFE62).s);
		}

		if (Sakura::Menu::Widgets::Button(/*Unload*/XorStr<0xAA, 7, 0x40BBB444>("\xFF\xC5\xC0\xC2\xCF\xCB" + 0x40BBB444).s, { ImGui::GetWindowSize().x - 6, 0 }))
		{
			Sakura::Unloading = true;
		}

		ImGui::Spacing();
		ImGui::Spacing();

		Sakura::Menu::Widgets::Checkbox(/*Auto config save*/XorStr<0xCD, 17, 0x6F10C702>("\x8C\xBB\xBB\xBF\xF1\xB1\xBC\xBA\xB3\xBF\xB0\xF8\xAA\xBB\xAD\xB9" + 0x6F10C702).s, &cvar.misc_auto_config_save);
	}
	ImGui::EndChild();
}

void Sakura::Menu::Tabs::Misc::Information()
{
	ImGui::Text(/*Welcome to this information tab!*/XorStr<0x53, 33, 0xC21A02AF>("\x04\x31\x39\x35\x38\x35\x3C\x7A\x2F\x33\x7D\x2A\x37\x09\x12\x42\x0A\x0A\x03\x09\x15\x05\x08\x1E\x02\x03\x03\x4E\x1B\x11\x13\x53" + 0xC21A02AF).s);
	ImGui::Spacing();
	ImGui::Spacing();
	ImGui::Text(/*While there may not be anything particularly useful in this specific message*/XorStr<0x02, 77, 0xFAE31C1C>("\x55\x6B\x6D\x69\x63\x27\x7C\x61\x6F\x79\x69\x2D\x63\x6E\x69\x31\x7C\x7C\x60\x35\x74\x72\x38\x78\x74\x62\x68\x75\x77\x71\x47\x01\x52\x42\x56\x51\x4F\x44\x5D\x45\x4B\x59\x40\x54\x0E\x5A\x43\x54\x54\x46\x58\x15\x5F\x59\x18\x4D\x52\x52\x4F\x1D\x4D\x4F\x25\x22\x2B\x25\x2D\x26\x66\x2A\x2D\x3A\x39\x2A\x2B\x28" + 0xFAE31C1C).s);
	ImGui::Text(/*we would like to provide some context about the creation of this cheat*/XorStr<0x14, 71, 0xAFA6CEB5>("\x63\x70\x36\x60\x77\x6C\x76\x7F\x3C\x71\x77\x74\x45\x01\x56\x4C\x04\x55\x54\x48\x5E\x40\x4E\x4E\x0C\x5E\x41\x42\x55\x11\x51\x5C\x5A\x41\x53\x4F\x4C\x19\x5B\x59\x53\x48\x4A\x1F\x34\x29\x27\x63\x27\x37\x23\x26\x3C\x20\x25\x25\x6C\x22\x28\x6F\x24\x39\x3B\x20\x74\x36\x3E\x32\x39\x2D" + 0xAFA6CEB5).s);
	ImGui::Spacing();
	ImGui::Spacing();
	ImGui::Text(/*It was designed by bitpaper#3408 - and we would like to extend special thanks to:*/XorStr<0xB6, 82, 0x015B598A>("\xFF\xC3\x98\xCE\xDB\xC8\x9C\xD9\xDB\xCC\xA9\xA6\xAC\xA6\xA0\xE5\xA4\xBE\xE8\xAB\xA3\xBF\xBC\xAC\xBE\xAA\xA2\xF2\xE1\xE7\xE4\xED\xF6\xFA\xF8\xB8\xB4\xBF\xFC\xAA\xBB\xFF\x97\x8E\x97\x8F\x80\xC5\x8A\x8E\x83\x8C\xCA\x9F\x83\xCD\x8B\x97\x84\x94\x9C\x97\xD4\x86\x86\x92\x9B\x90\x9B\x97\xDC\x89\x96\x9E\x6E\x6A\x71\x23\x70\x6A\x3C" + 0x015B598A).s);
	ImGui::Text(/* - */XorStr<0xFF, 4, 0xDD194FC6>("\xDF\x2D\x21" + 0xDD194FC6).s);
	ImGui::SameLine();
	ImGui::TextColored(ImColor(1.f, 1.f, 0.5f, 1.f), /*BloodSharp*/XorStr<0x5D, 11, 0xD3031189>("\x1F\x32\x30\x0F\x05\x31\x0B\x05\x17\x16" + 0xD3031189).s);
	ImGui::SameLine();
	ImGui::Text(/* for his coding expertise*/XorStr<0x38, 26, 0x1DA1D491>("\x18\x5F\x55\x49\x1C\x55\x57\x4C\x60\x22\x2D\x27\x2D\x2B\x21\x67\x2D\x31\x3A\x2E\x3E\x39\x27\x3C\x35" + 0x1DA1D491).s);

	ImGui::Text(/* - */XorStr<0x82, 4, 0x58E4118C>("\xA2\xAE\xA4" + 0x58E4118C).s);
	ImGui::SameLine();
	ImGui::TextColored(ImColor(0.5f, 0.5f, 1.f, 1.f), /*Flow of Life#7852*/XorStr<0xF6,18,0x8E935C6D>("\xB0\x9B\x97\x8E\xDA\x94\x9A\xDD\xB2\x96\x66\x64\x21\x34\x3C\x30\x34" + 0x8E935C6D).s);
	ImGui::SameLine();
	ImGui::Text(/* for his motivation and inspiration*/XorStr<0x48, 36, 0x13D35875>("\x68\x2F\x25\x39\x6C\x25\x27\x3C\x70\x3C\x3D\x27\x3D\x23\x37\x23\x31\x36\x34\x7B\x3D\x33\x3A\x7F\x09\x0F\x11\x13\x0D\x17\x07\x13\x01\x06\x04" + 0x13D35875).s);

	ImGui::Text(/* - */XorStr<0xA6, 4, 0xFE8875D5>("\x86\x8A\x88" + 0xFE8875D5).s);
	ImGui::SameLine();
	ImGui::TextColored(ImColor(0.1725f, 0.8f, 0.2901f, 1.f), /*lui1337_#7241*/XorStr<0x65, 14, 0x99747F80>("\x09\x13\x0E\x59\x5A\x59\x5C\x33\x4E\x59\x5D\x44\x40" + 0x99747F80).s);
	ImGui::SameLine();
	ImGui::Text(/* for his valuable testing and feedback*/XorStr<0xF7, 39, 0x7A594312>("\xD7\x9E\x96\x88\xDB\x94\x94\x8D\xDF\x76\x60\x6E\x76\x65\x67\x6A\x62\x28\x7D\x6F\x78\x78\x64\x60\x68\x30\x70\x7C\x77\x34\x73\x73\x72\x7C\x7B\x7B\x78\x77" + 0x7A594312).s);
}
```

`sakura/source/features/visuals/menu/tabs/menu_misc_tab.h`:

```h
#pragma once

namespace Sakura
{
	namespace Menu
	{
		namespace Tabs
		{
			namespace Misc
			{
				void Kreedz();
				void Keybindings();
				void Backtrack();
				void Route();
				void SidChanger();
				void AntiAFK();
				void PlayerList();
				void Notify();
				void NameStealer();
				void ChatSpammer();
				void Config();
				//void ModelHitboxes();
				//void SelectedHitboxes();
				void Information();
			};
		};
	};
};
```

`sakura/source/features/visuals/menu/tabs/menu_rage_tab.cpp`:

```cpp
#include "../../../../client.h"

void Sakura::Menu::Tabs::Rage::Aimbot()
{
	ImGui::BeginChild(/*##ra1*/XorStr<0x06, 6, 0xB1D3746C>("\x25\x24\x7A\x68\x3B" + 0xB1D3746C).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::Checkbox(/*Enable*/XorStr<0x87, 7, 0xFEF547C7>("\xC2\xE6\xE8\xE8\xE7\xE9" + 0xFEF547C7).s, &cvar.rage_active);

		Sakura::Menu::Widgets::Checkbox(/*Aim Team*/XorStr<0xB6, 9, 0x7636BCB0>("\xF7\xDE\xD5\x99\xEE\xDE\xDD\xD0" + 0x7636BCB0).s, &cvar.rage_team);
		Sakura::Menu::Widgets::Checkbox(/*Always Fire Manual*/XorStr<0xD8, 19, 0x42521C49>("\x99\xB5\xAD\xBA\xA5\xAE\xFE\x99\x89\x93\x87\xC3\xA9\x84\x88\x92\x89\x85" + 0x42521C49).s, &cvar.rage_always_fire);

		if (!cvar.rage_always_fire) 
			Sakura::Menu::Widgets::Checkbox(/*Auto Fire*/XorStr<0x69, 10, 0x28DBB124>("\x28\x1F\x1F\x03\x4D\x28\x06\x02\x14" + 0x28DBB124).s, &cvar.rage_auto_fire);

		Sakura::Menu::Widgets::Checkbox(/*Bypass Trace*/XorStr<0xDC, 13, 0xD972BBE3>("\x9E\xA4\xAE\xBE\x93\x92\xC2\xB7\x96\x84\x85\x82" + 0xD972BBE3).s, &cvar.bypass_trace_rage);
		Sakura::Menu::Widgets::Checkbox(/*Draw Aim*/XorStr<0xD3, 9, 0x9CED48EC>("\x97\xA6\xB4\xA1\xF7\x99\xB0\xB7" + 0x9CED48EC).s, &cvar.rage_draw_aim);
		Sakura::Menu::Widgets::Checkbox(/*Perfect Silent*/XorStr<0x7D, 15, 0xD0A0A6FC>("\x2D\x1B\x0D\xE6\xE4\xE1\xF7\xA4\xD6\xEF\xEB\xED\xE7\xFE" + 0xD0A0A6FC).s, &cvar.rage_perfect_silent);
		Sakura::Menu::Widgets::Checkbox(/*Silent Aim*/XorStr<0x9A, 11, 0xF66FEE63>("\xC9\xF2\xF0\xF8\xF0\xEB\x80\xE0\xCB\xCE" + 0xF66FEE63).s, &cvar.rage_silent);
		Sakura::Menu::Widgets::Checkbox(/*Shield Attack*/XorStr<0x19, 14, 0x2499EBA7>("\x4A\x72\x72\x79\x71\x7A\x3F\x61\x55\x56\x42\x47\x4E" + 0x2499EBA7).s, &cvar.rage_shield_attack);
		Sakura::Menu::Widgets::Checkbox(/*Wall*/XorStr<0x83, 5, 0x0AE8527F>("\xD4\xE5\xE9\xEA" + 0x0AE8527F).s, &cvar.rage_wall);
		Sakura::Menu::Widgets::Checkbox(/*Tapping mode*/XorStr<0x75, 13, 0xADEB34D8>("\x21\x17\x07\x08\x10\x14\x1C\x5C\x10\x11\x1B\xE5" + 0xADEB34D8).s, &cvar.rage_tapping_mode);
		Sakura::Menu::Widgets::Checkbox(/*No spread*/XorStr<0x9D, 10, 0x2D6E0551>("\xD3\xF1\xBF\xD3\xD1\xD0\xC6\xC5\xC1" + 0x2D6E0551).s, &cvar.rage_no_spread);
		Sakura::Menu::Widgets::Checkbox(/*No recoil*/XorStr<0x6F, 10, 0x58762388>("\x21\x1F\x51\x00\x16\x17\x1A\x1F\x1B" + 0x58762388).s, &cvar.rage_no_recoil);
	}
	ImGui::EndChild();
	ImGui::SameLine();
	ImGui::BeginChild(/*##ra2*/XorStr<0x40, 6, 0x6EE41BBA>("\x63\x62\x30\x22\x76" + 0x6EE41BBA).s, ImVec2(250, -1));
	{
		ImGui::PushItemWidth(itemWidth);
		Sakura::Menu::Widgets::SliderFloat(/*FOV*/XorStr<0x32, 4, 0x0B29F4F5>("\x74\x7C\x62" + 0x0B29F4F5).s, &cvar.rage_fov, 0.0f, 180.0f, "%.0f");
		if (!cvar.rage_always_fire)
		{
			Sakura::Menu::Widgets::SliderFloat(/*Fire Delay*/XorStr<0x58, 11, 0x95B29151>("\x1E\x30\x28\x3E\x7C\x19\x3B\x33\x01\x18" + 0x95B29151).s, &cvar.rage[g_Local.weapon.m_iWeaponID].rage_delay_shot, 0.0f, 1000.f, "%.0fms");
			if (!cvar.rage[g_Local.weapon.m_iWeaponID].rage_shot_type)
			{
				Sakura::Menu::Widgets::SliderFloat(/*Count*/XorStr<0xAF, 6, 0x64D2767E>("\xEC\xDF\xC4\xDC\xC7" + 0x64D2767E).s, &cvar.rage[g_Local.weapon.m_iWeaponID].rage_shot_count, 1.f, 5.f, "%.0f");
			}
			if (cvar.rage[g_Local.weapon.m_iWeaponID].rage_shot_type)
			{
				Sakura::Menu::Widgets::SliderFloat(/*Random Max*/XorStr<0x83, 11, 0x626D37A5>("\xD1\xE5\xEB\xE2\xE8\xE5\xA9\xC7\xEA\xF4" + 0x626D37A5).s, &cvar.rage[g_Local.weapon.m_iWeaponID].rage_random_max, 2.f, 5.f, "%.0f");
			}
			
			Sakura::Menu::Widgets::Combo(
				/*Fire Type*/XorStr<0x75, 10, 0x1980A897>("\x33\x1F\x05\x1D\x59\x2E\x02\x0C\x18" + 0x1980A897).s,
				&cvar.rage[g_Local.weapon.m_iWeaponID].rage_shot_type,
				/*Count\0Random\0*/XorStr<0x76, 14, 0xC117546E>("\x35\x18\x0D\x17\x0E\x7B\x2E\x1C\x10\x1B\xEF\xEC\x82" + 0xC117546E).s);
		}
		
		Sakura::Menu::Widgets::Combo(
			/*Knife Attack Method*/XorStr<0xDE, 20, 0xC2BF548B>("\x95\xB1\x89\x87\x87\xC3\xA5\x91\x92\x86\x8B\x82\xCA\xA6\x89\x99\x86\x80\x94" + 0xC2BF548B).s,
			&cvar.rage_knife_attack,
			/*Slash\0Stab\0*/XorStr<0x79, 12, 0xF61A5D83>("\x2A\x16\x1A\x0F\x15\x7E\x2C\xF4\xE0\xE0\x83" + 0xF61A5D83).s);
		
		Sakura::Menu::Widgets::Combo(
			/*Target Selection*/XorStr<0x25, 17, 0x4CC45573>("\x71\x47\x55\x4F\x4C\x5E\x0B\x7F\x48\x42\x4A\x53\x45\x5B\x5C\x5A" + 0x4CC45573).s,
			&cvar.rage_target_selection,
			/*Field of view\0Distance\0Cycle\0*/XorStr<0xBD, 30, 0xF8965003>("\xFB\xD7\xDA\xAC\xA5\xE2\xAC\xA2\xE5\xB0\xAE\xAD\xBE\xCA\x8F\xA5\xBE\xBA\xAE\xBE\xB2\xB7\xD3\x97\xAC\xB5\xBB\xBD\xD9" + 0xF8965003).s);
		
		Sakura::Menu::Widgets::Combo(
			/*Spread Method*/XorStr<0xD0, 14, 0x73BE3424>("\x83\xA1\xA0\xB6\xB5\xB1\xF6\x9A\xBD\xAD\xB2\xB4\xB8" + 0x73BE3424).s,
			&cvar.rage_nospread_method,
			/*Pitch / Yaw\0Roll\0*/XorStr<0xE6, 18, 0x4D488743>("\xB6\x8E\x9C\x8A\x82\xCB\xC3\xCD\xB7\x8E\x87\xF1\xA0\x9C\x98\x99\xF6" + 0x4D488743).s);
		
		Sakura::Menu::Widgets::Combo(/*Hitbox*/XorStr<0x95, 7, 0xE0EB7681>("\xDD\xFF\xE3\xFA\xF6\xE2" + 0xE0EB7681).s,
			&cvar.rage[g_Local.weapon.m_iWeaponID].rage_hitbox,
			/*Belt\0Left thigh\0Left tibia\0Left foot\0Right thigh\0Right tibia\0Right foot\0Stomach\0Lower chest\0Upper chest\0Neck\0Head\0Left shoulder\0Left elbow\0Left arm\0Left hand\0Right shoulder\0Right elbow\0Right arm\0Right hand\0*/XorStr<0x0D, 207, 0x025EDD2D>("\x4F\x6B\x63\x64\x11\x5E\x76\x72\x61\x36\x63\x70\x70\x7D\x73\x1C\x51\x7B\x79\x54\x01\x56\x4A\x46\x4C\x47\x27\x64\x4C\x4C\x5F\x0C\x4B\x41\x40\x44\x31\x60\x5A\x53\x5D\x42\x17\x4C\x51\x53\x5C\x54\x3D\x6C\x56\x27\x29\x36\x63\x30\x2C\x24\x2E\x29\x49\x18\x22\x2B\x25\x3A\x6F\x36\x3E\x3D\x27\x54\x06\x22\x38\x35\x38\x39\x33\x5C\x11\x31\x28\x05\x13\x42\x00\x0C\x00\x15\x13\x68\x3C\x1A\x1B\x09\x1F\x4E\x0C\x18\x14\x01\x07\x74\x3B\x13\x14\x13\x79\x32\x1E\x1D\x19\x7E\x33\xE5\xE7\xF6\xA3\xF7\xED\xE9\xF2\xE4\xED\xEF\xF9\x8C\xC1\xEB\xE9\xE4\xB1\xF7\xFF\xF6\xFA\xE1\x97\xD4\xFC\xFC\xEF\xBC\xFC\xEC\xF2\xA0\xED\xC7\xC5\xD0\x85\xCE\xC6\xC6\xCD\xAA\xF9\xC5\xCA\xC6\xDB\x90\xC2\xDA\xDC\xC1\xD9\xD2\xD2\xCA\xB9\xE8\xD2\xDB\xD5\xCA\x9F\xA5\xAD\xA0\xAC\xB3\xC5\x94\xAE\xAF\xA1\xBE\xEB\xAD\xBF\xA3\xCF\x82\xB8\xB5\xBB\xA0\xF5\xBE\xB6\xB6\xBD\xDA" + 0x025EDD2D).s);
		
		ImGui::PopItemWidth();
	}
	ImGui::EndChild();
}

void Sakura::Menu::Tabs::Rage::AntiAim()
{
	ImGui::BeginChild(/*##raa1*/XorStr<0x22, 7, 0x3D843509>("\x01\x00\x56\x44\x47\x16" + 0x3D843509).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::Checkbox(/*Enable*/XorStr<0x8A, 7, 0x868C46E6>("\xCF\xE5\xED\xEF\xE2\xEA" + 0x868C46E6).s, &cvar.rage_antiaim_active);
		Sakura::Menu::Widgets::Checkbox(/*Roll*/XorStr<0x1A, 5, 0xF69E2798>("\x48\x74\x70\x71" + 0xF69E2798).s, &cvar.aa_roll_active);
		Sakura::Menu::Widgets::Checkbox(/*Custom Jitter Yaw*/XorStr<0x10, 18, 0xFF5A05F6>("\x53\x64\x61\x67\x7B\x78\x36\x5D\x71\x6D\x6E\x7E\x6E\x3D\x47\x7E\x57" + 0xFF5A05F6).s, &cvar.aa_yaw_jitter_custom);
	}
	ImGui::EndChild();
	ImGui::SameLine();
	ImGui::BeginChild(/*##raa2*/XorStr<0xBA, 7, 0x29EC639B>("\x99\x98\xCE\xDC\xDF\x8D" + 0x29EC639B).s, ImVec2(250, -1));
	{
		ImGui::PushItemWidth(itemWidth);
		Sakura::Menu::Widgets::SliderFloat(/*Static Roll*/XorStr<0x41, 12, 0xC15AE288>("\x12\x36\x22\x30\x2C\x25\x67\x1A\x26\x26\x27" + 0xC15AE288).s, &cvar.aa_roll_static, -180.f, 180.f, u8"%.0f°");
		Sakura::Menu::Widgets::SliderFloat(/*Static Yaw*/XorStr<0xD7, 11, 0x4C5FA5CF>("\x84\xAC\xB8\xAE\xB2\xBF\xFD\x87\xBE\x97" + 0x4C5FA5CF).s, &cvar.aa_yaw_static, -180.f, 180.f, u8"%.0f°");

		Sakura::Menu::Widgets::SliderFloat(/*Yaw Jitter Angle*/XorStr<0x93, 17, 0x859FF278>("\xCA\xF5\xE2\xB6\xDD\xF1\xED\xEE\xFE\xEE\xBD\xDF\xF1\xC7\xCD\xC7" + 0x859FF278).s, &cvar.aa_yaw_jitter_angle, -180.f, 180.f, u8"%.0f°");
		Sakura::Menu::Widgets::SliderFloat(/*Yaw Jitter Variance*/XorStr<0x3E, 20, 0xE9C49F38>("\x67\x5E\x37\x61\x08\x2A\x30\x31\x23\x35\x68\x1F\x2B\x39\x25\x2C\x20\x2C\x35" + 0xE9C49F38).s, &cvar.aa_yaw_jitter_much, 1.f, 90.f, u8"%.0f°");

		Sakura::Menu::Widgets::Combo(
			/*Edge*/XorStr<0xBF, 5, 0x3E6C04FB>("\xFA\xA4\xA6\xA7" + 0x3E6C04FB).s,
			&cvar.aa_edge,
			/*Off\0Standing\00In move\0All\0All & fake\0*/XorStr<0xA7, 38, 0xCC6265F7>("\xE8\xCE\xCF\xAA\xF8\xD8\xCC\xC0\xCB\xD9\xDF\xD5\xB3\x84\xFC\xD8\x97\xD5\xD6\xCC\xDE\xBC\xFC\xD2\xD3\xC0\x80\xAE\xAF\xE4\xE3\xE6\xA1\xA9\xA2\xAF\xCB" + 0xCC6265F7).s);
		
		Sakura::Menu::Widgets::Combo(
			/*Pitch*/XorStr<0x86, 6, 0xEC9DE074>("\xD6\xEE\xFC\xEA\xE2" + 0xEC9DE074).s,
			&cvar.aa_pitch,
			/*Off\0Down\0Up\0Fake down\0Fake up\0Fake jitter\0Random\0*/XorStr<0xC4, 50, 0xF0A2F67F>("\x8B\xA3\xA0\xC7\x8C\xA6\xBD\xA5\xCC\x98\xBE\xCF\x96\xB0\xB9\xB6\xF4\xB1\xB9\xA0\xB6\xD9\x9C\xBA\xB7\xB8\xFE\xAA\x90\xE1\xA4\x82\x8F\x80\xC6\x8D\x81\x9D\x9E\x8E\x9E\xED\xBC\x8E\x9E\x95\x9D\x9E\xF4" + 0xF0A2F67F).s);

		Sakura::Menu::Widgets::Combo(
			/*Yaw*/XorStr<0xB9, 4, 0xE915FAFB>("\xE0\xDB\xCC" + 0xE915FAFB).s,
			&cvar.aa_yaw, 
			/*Off\0180\0180 jitter\0Slow spin\0Fast spin\0Jitter\0Sideways\0Random\0Static\0*/XorStr<0x1B, 70, 0x4A04F79D>("\x54\x7A\x7B\x1E\x2E\x18\x11\x22\x12\x1C\x15\x06\x4D\x41\x5D\x5E\x4E\x5E\x2D\x7D\x43\x5F\x46\x12\x40\x44\x5C\x58\x37\x7E\x58\x49\x4F\x1C\x4E\x4E\x56\x2E\x41\x08\x2A\x30\x31\x23\x35\x48\x1A\x23\x2F\x29\x3A\x2F\x36\x23\x51\x00\x32\x3A\x31\x39\x3A\x58\x0A\x2E\x3A\x28\x34\x3D\x5F" + 0x4A04F79D).s);
		
		Sakura::Menu::Widgets::Combo(
			/*Yaw While Running*/XorStr<0x80, 18, 0x745DB65C>("\xD9\xE0\xF5\xA3\xD3\xED\xEF\xEB\xED\xA9\xD8\xFE\xE2\xE3\xE7\xE1\xF7" + 0x745DB65C).s, 
			&cvar.aa_yaw_while_running,
			/*Off\0180\0180 jitter\0Slow spin\0Fast spin\0Jitter\0Sideways\0Random\0Static\0*/XorStr<0xE8, 70, 0x7BAD0BB8>("\xA7\x8F\x8C\xEB\xDD\xD5\xDE\xEF\xC1\xC9\xC2\xD3\x9E\x9C\x82\x83\x9D\x8B\xFA\xA8\x90\x92\x89\xDF\x73\x71\x6B\x6D\x04\x43\x67\x74\x7C\x29\x79\x7B\x65\x63\x0E\x45\x79\x65\x66\x76\x66\x15\x45\x7E\x7C\x7C\x6D\x7A\x65\x6E\x1E\x4D\x41\x4F\x46\x4C\x49\x25\x75\x53\x49\x5D\x43\x48\x2C" + 0x7BAD0BB8).s);

		Sakura::Menu::Widgets::Combo(
			/*Roll*/XorStr<0x87, 5, 0x5213CA2C>("\xD5\xE7\xE5\xE6" + 0x5213CA2C).s,
			&cvar.aa_roll,
			/*Off\0180\0180 jitter\0Slow spin\0Fast spin\0Jitter\0Sideways\0Random\0Static\0*/XorStr<0xDA, 70, 0x22E684A4>("\x95\xBD\xBA\xDD\xEF\xE7\xD0\xE1\xD3\xDB\xD4\xC5\x8C\x8E\x9C\x9D\x8F\x99\xEC\xBE\x82\x80\x87\xD1\x81\x83\x9D\x9B\xF6\xB1\x99\x8A\x8E\xDB\x8F\x8D\x97\x91\x00\x4B\x6B\x77\x70\x60\x74\x07\x5B\x60\x6E\x6E\x7B\x6C\x77\x7C\x10\x43\x73\x7D\x70\x7A\x7B\x17\x4B\x6D\x7B\x6F\x75\x7E\x1E" + 0x22E684A4).s);
		
		Sakura::Menu::Widgets::Combo(
			/*Roll While Running*/XorStr<0x6B, 19, 0xD2EDA03A>("\x39\x03\x01\x02\x4F\x27\x19\x1B\x1F\x11\x55\x24\x02\x16\x17\x13\x15\x1B" + 0xD2EDA03A).s,
			&cvar.aa_roll_while_running, 
			/*Off\0180\0180 jitter\0Slow spin\0Fast spin\0Jitter\0Sideways\0Random\0Static\0*/XorStr<0xE4, 70, 0xB2694552>("\xAB\x83\x80\xE7\xD9\xD1\xDA\xEB\xDD\xD5\xDE\xCF\x9A\x98\x86\x87\x91\x87\xF6\xA4\x94\x96\x8D\xDB\x8F\x8D\x97\x91\x00\x47\x63\x70\x70\x25\x75\x77\x61\x67\x0A\x41\x65\x79\x7A\x6A\x62\x11\x41\x7A\x70\x70\x61\x76\x61\x6A\x1A\x49\x7D\x73\x7A\x70\x4D\x21\x71\x57\x45\x51\x4F\x44\x28" + 0xB2694552).s);
		ImGui::PopItemWidth();
	}
	ImGui::EndChild();
}

void Sakura::Menu::Tabs::Rage::FakeLag()
{
	ImGui::BeginChild(/*##rfl1*/XorStr<0x93, 7, 0xF8EC42D9>("\xB0\xB7\xE7\xF0\xFB\xA9" + 0xF8EC42D9).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::Checkbox(/*Enable*/XorStr<0xC6, 7, 0x95427A7B>("\x83\xA9\xA9\xAB\xA6\xAE" + 0x95427A7B).s, &cvar.fakelag_active);
		Sakura::Menu::Widgets::Checkbox(/*Fakelag While Shooting*/XorStr<0x85, 23, 0x6B5C96B2>("\xC3\xE7\xEC\xED\xE5\xEB\xEC\xAC\xDA\xE6\xE6\xFC\xF4\xB2\xC0\xFC\xFA\xF9\xE3\xF1\xF7\xFD" + 0x6B5C96B2).s, &cvar.fakelag_while_shooting);
	}
	ImGui::EndChild();
	ImGui::SameLine();
	ImGui::BeginChild(/*##rfl2*/XorStr<0xF1, 7, 0x65A69B8E>("\xD2\xD1\x81\x92\x99\xC4" + 0x65A69B8E).s, ImVec2(250, -1));
	{
		ImGui::PushItemWidth(itemWidth);
		Sakura::Menu::Widgets::SliderFloat(/*Fakelag Limit*/XorStr<0xCF, 14, 0x80B9CB51>("\x89\xB1\xBA\xB7\xBF\xB5\xB2\xF6\x9B\xB1\xB4\xB3\xAF" + 0x80B9CB51).s, &cvar.fakelag_limit, 0.f, 30.f, "%.0f");
		
		Sakura::Menu::Widgets::SliderFloat(/*Fakelag Variance*/XorStr<0x86, 17, 0xA085BAE0>("\xC0\xE6\xE3\xEC\xE6\xEA\xEB\xAD\xD8\xEE\xE2\xF8\xF3\xFD\xF7\xF0" + 0xA085BAE0).s, &cvar.fakelag_variance, 0.f, 100.f, "%.0f");
		
		Sakura::Menu::Widgets::Combo(
			/*Fakelag Move*/XorStr<0x9A, 13, 0xEAD452CE>("\xDC\xFA\xF7\xF8\xF2\xFE\xC7\x81\xEF\xCC\xD2\xC0" + 0xEAD452CE).s,
			&cvar.fakelag_move,
			/*On land\0On move\0In air\0All\0*/XorStr<0x1C, 28, 0x7D68DBC1>("\x53\x73\x3E\x73\x41\x4F\x46\x23\x6B\x4B\x06\x4A\x47\x5F\x4F\x2B\x65\x43\x0E\x4E\x59\x43\x32\x72\x58\x59\x36" + 0x7D68DBC1).s);
		
		Sakura::Menu::Widgets::Combo(
			/*Fakelag Type*/XorStr<0xF0, 13, 0x63E7B4A2>("\xB6\x90\x99\x96\x98\x94\x91\xD7\xAC\x80\x8A\x9E" + 0x63E7B4A2).s,
			&cvar.fakelag_type,
			/*Dynamic\0Maximum\0Flucture\0Break lag compensation\0*/XorStr<0xAC, 49, 0x963FDCA0>("\xE8\xD4\xC0\xCE\xDD\xD8\xD1\xB3\xF9\xD4\xCE\xDE\xD5\xCC\xD7\xBB\xFA\xD1\xCB\xDC\xB4\xB4\xB0\xA6\xC4\x87\xB4\xA2\xA9\xA2\xEA\xA7\xAD\xAA\xEE\xAC\xBF\xBC\xA2\xB6\xBA\xA6\xB7\xA3\xB1\xB6\xB4\xDB" + 0x963FDCA0).s);
		ImGui::PopItemWidth();
	}
	ImGui::EndChild();
}

void Sakura::Menu::Tabs::Rage::Speedhack()
{
	ImGui::BeginChild(/*##rfl1*/XorStr<0xED, 7, 0x8CC8F835>("\xCE\xCD\x9D\x96\x9D\xC3" + 0x8CC8F835).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::Checkbox(/*Enable*/XorStr<0x6D, 7, 0xB6166C72>("\x28\x00\x0E\x12\x1D\x17" + 0xB6166C72).s, &cvar.speedhack_active);
		Sakura::Menu::Widgets::Checkbox(/*Auto Direction*/XorStr<0xBA, 15, 0x22858E51>("\xFB\xCE\xC8\xD2\x9E\xFB\xA9\xB3\xA7\xA0\xB0\xAC\xA9\xA9" + 0x22858E51).s, &cvar.route_direction);
		Sakura::Menu::Widgets::Checkbox(/*Auto Jump*/XorStr<0x6F, 10, 0x0D479F00>("\x2E\x05\x05\x1D\x53\x3E\x00\x1B\x07" + 0x0D479F00).s, &cvar.route_jump);
	}
	ImGui::EndChild();
	ImGui::SameLine();
	ImGui::BeginChild(/*##rfl2*/XorStr<0x46, 7, 0xE2E7FC68>("\x65\x64\x3A\x2F\x26\x79" + 0xE2E7FC68).s, ImVec2(250, -1));
	{
		ImGui::PushItemWidth(itemWidth);
		Sakura::Menu::Widgets::SliderFloat(/*Speed*/XorStr<0xE2, 6, 0xD2961D90>("\xB1\x93\x81\x80\x82" + 0xD2961D90).s, &cvar.speedhack_speed, 2.f, 64.f, "%.0f");
		ImGui::PopItemWidth();
	}
	ImGui::EndChild();
}
```

`sakura/source/features/visuals/menu/tabs/menu_rage_tab.h`:

```h
#pragma once

namespace Sakura
{
	namespace Menu
	{
		namespace Tabs
		{
			namespace Rage
			{
				void Aimbot();
				void AntiAim();
				void FakeLag();
				void Speedhack();
			};
		};
	};
};
```

`sakura/source/features/visuals/menu/tabs/menu_visuals_tab.cpp`:

```cpp
#include "../../../../client.h"

float playerSplit = 0;
float localPlayerSplit = 0;
float worldSplit = 0;

void Sakura::Menu::Tabs::Visuals::Player()
{
	if (Sakura::Menu::Widgets::SubSubTab(/*C*/XorStr<0x9D, 2, 0x8DF2BA10>("\xDE" + 0x8DF2BA10).s, /*Esp*/XorStr<0x20, 4, 0xE1D06C51>("\x65\x52\x52" + 0xE1D06C51).s, ImVec2(80, 40), playerSplit == 0 ? true : false))
		playerSplit = 0;
	ImGui::SameLine();
	if (Sakura::Menu::Widgets::SubSubTab(/*K*/XorStr<0x13, 2, 0xD90A84A2>("\x58" + 0xD90A84A2).s, /*Sound esp*/XorStr<0x60, 10, 0xFD00C6EC>("\x33\x0E\x17\x0D\x00\x45\x03\x14\x18" + 0xFD00C6EC).s, ImVec2(80, 40), playerSplit == 1 ? true : false))
		playerSplit = 1;
	ImGui::SameLine();
	if (Sakura::Menu::Widgets::SubSubTab(/*B*/XorStr<0xB4, 2, 0x0FABC5D3>("\xF6" + 0x0FABC5D3).s, /*Chams*/XorStr<0x39, 6, 0x82488EAF>("\x7A\x52\x5A\x51\x4E" + 0x82488EAF).s, ImVec2(80, 40), playerSplit == 2 ? true : false))
		playerSplit = 2;
	ImGui::SameLine();
	if (Sakura::Menu::Widgets::SubSubTab(/*A*/XorStr<0xEE, 2, 0x5B7CBE0B>("\xAF" + 0x5B7CBE0B).s, /*Glow*/XorStr<0x11, 5, 0x06588C88>("\x56\x7E\x7C\x63" + 0x06588C88).s, ImVec2(80, 40), playerSplit == 3 ? true : false))
		playerSplit = 3;
	ImGui::SameLine();
	if (Sakura::Menu::Widgets::SubSubTab(/*H*/XorStr<0x44, 2, 0x8FF4FCBA>("\x0C" + 0x8FF4FCBA).s, /*Light*/XorStr<0x72, 6, 0xC06F61A6>("\x3E\x1A\x13\x1D\x02" + 0xC06F61A6).s, ImVec2(80, 40), playerSplit == 4 ? true : false))
		playerSplit = 4;
	ImGui::SameLine();
	if (Sakura::Menu::Widgets::SubSubTab(/*J*/XorStr<0x35, 2, 0xC48D0C62>("\x7F" + 0xC48D0C62).s, /*Deathmark*/XorStr<0x2B, 10, 0x0C7E5E0E>("\x6F\x49\x4C\x5A\x47\x5D\x50\x40\x58" + 0x0C7E5E0E).s, ImVec2(80, 40), playerSplit == 5 ? true : false))
		playerSplit = 5;

	ImGui::Spacing();

	switch (static_cast<int>(playerSplit))
	{
	case 0:
		Sakura::Menu::Tabs::Visuals::PlayerEsp();
		break;
	case 1:
		Sakura::Menu::Tabs::Visuals::PlayerSoundEsp();
		break;
	case 2:
		Sakura::Menu::Tabs::Visuals::PlayerChams();
		break;
	case 3:
		Sakura::Menu::Tabs::Visuals::PlayerGlow();
		break;
	case 4:
		Sakura::Menu::Tabs::Visuals::PlayerDynamicLight();
		break;
	case 5:
		Sakura::Menu::Tabs::Visuals::DeathMarks();
		break;
	}
}

void Sakura::Menu::Tabs::Visuals::PlayerEsp()
{
	ImGui::BeginChild(/*##vp1*/XorStr<0xEF, 6, 0x0FB8EB80>("\xCC\xD3\x87\x82\xC2" + 0x0FB8EB80).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::Checkbox(/*Box*/XorStr<0x00, 4, 0x42D15C07>("\x42\x6E\x7A" + 0x42D15C07).s, &cvar.visual_box);
		Sakura::Menu::Widgets::Checkbox(/*Health*/XorStr<0xAB, 7, 0x04E5670A>("\xE3\xC9\xCC\xC2\xDB\xD8" + 0x04E5670A).s, &cvar.visual_health);
		Sakura::Menu::Widgets::Checkbox(/*Name*/XorStr<0x12, 5, 0xAE49B981>("\x5C\x72\x79\x70" + 0xAE49B981).s, &cvar.visual_name);
		Sakura::Menu::Widgets::Checkbox(/*Reload*/XorStr<0x3B, 7, 0xF5AB74A7>("\x69\x59\x51\x51\x5E\x24" + 0xF5AB74A7).s, &cvar.visual_reload_bar);
		Sakura::Menu::Widgets::Checkbox(/*Vip*/XorStr<0x8E, 4, 0x49B38822>("\xD8\xE6\xE0" + 0x49B38822).s, &cvar.visual_vip);
		Sakura::Menu::Widgets::Checkbox(/*Model Name*/XorStr<0x0D, 11, 0x0A3B44B7>("\x40\x61\x6B\x75\x7D\x32\x5D\x75\x78\x73" + 0x0A3B44B7).s, &cvar.visual_model);
		Sakura::Menu::Widgets::Checkbox(/*Skeleton*/XorStr<0x4C, 9, 0x565770F0>("\x1F\x26\x2B\x23\x35\x25\x3D\x3D" + 0x565770F0).s, &cvar.skeleton_player_bone);
		Sakura::Menu::Widgets::Checkbox(/*HitBox*/XorStr<0xCF, 7, 0x0F3A0D39>("\x87\xB9\xA5\x90\xBC\xAC" + 0x0F3A0D39).s, &cvar.skeleton_player_hitbox);
		Sakura::Menu::Widgets::Checkbox(/*Snaplines*/XorStr<0x24, 10, 0x6E6446FE>("\x77\x4B\x47\x57\x44\x40\x44\x4E\x5F" + 0x6E6446FE).s, &cvar.visual_lines);
		Sakura::Menu::Widgets::Checkbox(/*Weapon Name*/XorStr<0x59, 12, 0x9978B1F5>("\x0E\x3F\x3A\x2C\x32\x30\x7F\x2E\x00\x0F\x06" + 0x9978B1F5).s, &cvar.visual_weapon);
		Sakura::Menu::Widgets::Checkbox(/*Bullet Trace*/XorStr<0x26, 13, 0x7A943B38>("\x64\x52\x44\x45\x4F\x5F\x0C\x79\x5C\x4E\x53\x54" + 0x7A943B38).s, &cvar.visual_bullet_trace);
		Sakura::Menu::Widgets::Checkbox(/*Line of Sight*/XorStr<0xDA, 14, 0xD51D5EA1>("\x96\xB2\xB2\xB8\xFE\xB0\x86\xC1\xB1\x8A\x83\x8D\x92" + 0xD51D5EA1).s, &cvar.visual_line_of_sight);
		Sakura::Menu::Widgets::Checkbox(/*Teammates*/XorStr<0xEC, 10, 0xA198302E>("\xB8\x88\x8F\x82\x9D\x90\x86\x96\x87" + 0xA198302E).s, &cvar.visual_visual_team);
	}
	ImGui::EndChild();
	ImGui::SameLine();
	ImGui::BeginChild(/*##vp2*/XorStr<0xD4, 6, 0xA7365A95>("\xF7\xF6\xA0\xA7\xEA" + 0xA7365A95).s, ImVec2(250, -1));
	{
		ImGui::PushItemWidth(itemWidth);
		Sakura::Menu::Widgets::SliderFloat(/*Snaplines Thickness*/XorStr<0x98, 20, 0xDB2F859B>("\xCB\xF7\xFB\xEB\xF0\xF4\xF0\xFA\xD3\x81\xF6\xCB\xCD\xC6\xCD\xC9\xCD\xDA\xD9" + 0xDB2F859B).s, &cvar.visual_lines_thickness, 1.f, 10.f, "%.0f");
		Sakura::Menu::Widgets::SliderFloat(/*Line of Sight Distance*/XorStr<0x95, 23, 0x0F58B06C>("\xD9\xFF\xF9\xFD\xB9\xF5\xFD\xBC\xCE\xF7\xF8\xC8\xD5\x82\xE7\xCD\xD6\xD2\xC6\xC6\xCA\xCF" + 0x0F58B06C).s, &cvar.visual_line_of_sight_distance, 20.f, 1000.f, "%.0f");
		Sakura::Menu::Widgets::SliderFloat(/*Box fill opacity*/XorStr<0xBF, 17, 0xF223D5BC>("\xFD\xAF\xB9\xE2\xA5\xAD\xA9\xAA\xE7\xA7\xB9\xAB\xA8\xA5\xB9\xB7" + 0xF223D5BC).s, &cvar.visual_box_fill, 0.f, 100.f, "%.0f%%");
		
		Sakura::Menu::Widgets::Combo(
			/*Box Type*/XorStr<0xD8, 9, 0x2E8DE171>("\x9A\xB6\xA2\xFB\x88\xA4\xAE\xBA" + 0x2E8DE171).s,
			&cvar.visual_box_type,
			/*Box\0Corners\0Coal\0*/XorStr<0x44, 18, 0x36C94C71>("\x06\x2A\x3E\x47\x0B\x26\x38\x25\x29\x3F\x3D\x4F\x13\x3E\x33\x3F\x54" + 0x36C94C71).s);

		ImGui::PopItemWidth();
	}
	ImGui::EndChild();
}

void Sakura::Menu::Tabs::Visuals::PlayerChams()
{
	ImGui::BeginChild(/*##vpc1*/XorStr<0x9B, 7, 0x3BCF8DEE>("\xB8\xBF\xEB\xEE\xFC\x91" + 0x3BCF8DEE).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::Checkbox(/*Chams Wall*/XorStr<0x01, 11, 0x323D836D>("\x42\x6A\x62\x69\x76\x26\x50\x69\x65\x66" + 0x323D836D).s, &cvar.chams_player_wall);
		Sakura::Menu::Widgets::Checkbox(/*Chams Wireframe*/XorStr<0xDD, 16, 0x324D0292>("\x9E\xB6\xBE\x8D\x92\xC2\xB4\x8D\x97\x83\x81\x9A\x88\x87\x8E" + 0x324D0292).s, &cvar.chams_player_wireframe);
	}
	ImGui::EndChild();
	ImGui::SameLine();
	ImGui::BeginChild(/*##vpc2*/XorStr<0x5E, 7, 0x7B5BC012>("\x7D\x7C\x16\x11\x01\x51" + 0x7B5BC012).s, ImVec2(250, -1));
	{
		ImGui::PushItemWidth(itemWidth);
		
		if (cvar.chams_player_wireframe_mode)
			Sakura::Menu::Widgets::SliderFloat(/*Wireframe point size*/XorStr<0xCE, 21, 0x1F241978>("\x99\xA6\xA2\xB4\xB4\xA1\xB5\xB8\xB3\xF7\xA8\xB6\xB3\xB5\xA8\xFD\xAD\xB6\x9A\x84" + 0x1F241978).s, &cvar.chams_player_wireframe_point_size, 1.f, 5.f, "%.1f");
		else
			Sakura::Menu::Widgets::SliderFloat(/*Wireframe line width*/XorStr<0xA2, 21, 0xBBA95C48>("\xF5\xCA\xD6\xC0\xC0\xD5\xC9\xC4\xCF\x8B\xC0\xC4\xC0\xCA\x90\xC6\xDB\xD7\xC0\xDD" + 0xBBA95C48).s, &cvar.chams_player_wireframe_line_width, 1.f, 5.f, "%.1f");

		Sakura::Menu::Widgets::Combo(
			/*Chams*/XorStr<0x38, 6, 0x94E296D3>("\x7B\x51\x5B\x56\x4F" + 0x94E296D3).s,
			&cvar.chams_player,
			/*Off\0Material\0Texture\0Flat\0*/XorStr<0xA6, 27, 0xCE4DC42F>("\xE9\xC1\xCE\xA9\xE7\xCA\xD8\xC8\xDC\xC6\xD1\xDD\xB2\xE7\xD1\xCD\xC2\xC2\xCA\xDC\xBA\xFD\xD0\xDC\xCA\xBF" + 0xCE4DC42F).s);
		
		Sakura::Menu::Widgets::Combo(
			/*Wireframe Type*/XorStr<0x3A, 15, 0xB5E5D73F>("\x6D\x52\x4E\x58\x58\x4D\x21\x2C\x27\x63\x10\x3C\x36\x22" + 0xB5E5D73F).s,
			&cvar.chams_player_wireframe_mode,
			/*Lines\0Points\0*/XorStr<0x11, 14, 0x9D8590B9>("\x5D\x7B\x7D\x71\x66\x16\x47\x77\x70\x74\x6F\x6F\x1D" + 0x9D8590B9).s);
		
		ImGui::PopItemWidth();
	}
	ImGui::EndChild();
}

void Sakura::Menu::Tabs::Visuals::PlayerGlow()
{
	ImGui::BeginChild(/*##vpc1*/XorStr<0x61, 7, 0x58CC7DB9>("\x42\x41\x15\x14\x06\x57" + 0x58CC7DB9).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::Checkbox(/*Enable glow*/XorStr<0x65, 12, 0xEB151CFE>("\x20\x08\x06\x0A\x05\x0F\x4B\x0B\x01\x01\x18" + 0xEB151CFE).s, &cvar.visual_player_glow);
	}
	ImGui::EndChild();
	ImGui::SameLine();
	ImGui::BeginChild(/*##vpc2*/XorStr<0xCD, 7, 0x4D94D3F7>("\xEE\xED\xB9\xA0\xB2\xE0" + 0x4D94D3F7).s, ImVec2(250, -1));
	{
		ImGui::PushItemWidth(itemWidth);
		Sakura::Menu::Widgets::SliderFloat(/*Glow thickness*/XorStr<0xB5, 15, 0x6967DC09>("\xF2\xDA\xD8\xCF\x99\xCE\xD3\xD5\xDE\xD5\xD1\xA5\xB2\xB1" + 0x6967DC09).s, &cvar.visual_player_glow_thickness, 12.f, 64.f, "%.0f");
		ImGui::PopItemWidth();
	}
	ImGui::EndChild();
}

void Sakura::Menu::Tabs::Visuals::PlayerDynamicLight()
{
	ImGui::BeginChild(/*##vpc1*/XorStr<0xE5, 7, 0x4E9B1CFC>("\xC6\xC5\x91\x98\x8A\xDB" + 0x4E9B1CFC).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::Checkbox(/*Enable light*/XorStr<0x65, 13, 0x8B0DD7AB>("\x20\x08\x06\x0A\x05\x0F\x4B\x00\x04\x09\x07\x04" + 0x8B0DD7AB).s, &cvar.visual_lambert);
		Sakura::Menu::Widgets::Checkbox(/*Enable dlight*/XorStr<0xCD, 14, 0x09747F29>("\x88\xA0\xAE\xB2\xBD\xB7\xF3\xB0\xB9\xBF\xB0\xB0\xAD" + 0x09747F29).s, &cvar.visual_player_dynamiclight);
		Sakura::Menu::Widgets::Checkbox(/*DLight Impulse*/XorStr<0xAE, 15, 0x900D53C2>("\xEA\xE3\xD9\xD6\xDA\xC7\x94\xFC\xDB\xC7\xCD\xD5\xC9\xDE" + 0x900D53C2).s, &cvar.visual_player_dynamiclight_fading);
	}
	ImGui::EndChild();
	ImGui::SameLine();
	ImGui::BeginChild(/*##vpc2*/XorStr<0xB8, 7, 0x66F21DCC>("\x9B\x9A\xCC\xCB\xDF\x8F" + 0x66F21DCC).s, ImVec2(250, -1));
	{
		ImGui::PushItemWidth(itemWidth);
		Sakura::Menu::Widgets::SliderFloat(/*DLight Radius*/XorStr<0x27, 14, 0xA8A22665>("\x63\x64\x40\x4D\x43\x58\x0D\x7C\x4E\x54\x58\x47\x40" + 0xA8A22665).s, &cvar.visual_player_dynamiclight_radius, 1.f, 100.f, "%.0f");
		Sakura::Menu::Widgets::SliderFloat(/*DLight Impulse Fading speed*/XorStr<0x19, 28, 0xC4AE1FA4>("\x5D\x56\x72\x7B\x75\x6A\x3F\x69\x4C\x52\x56\x48\x56\x43\x07\x6E\x48\x4E\x42\x42\x4A\x0E\x5C\x40\x54\x57\x57" + 0xC4AE1FA4).s, &cvar.visual_player_dynamiclight_fading_speed, 1.f, 50.f, "%.0f");
		ImGui::PopItemWidth();
	}
	ImGui::EndChild();

}

void Sakura::Menu::Tabs::Visuals::PlayerSoundEsp()
{
	ImGui::BeginChild(/*##vpc1*/XorStr<0x34, 7, 0xEB0A4183>("\x17\x16\x40\x47\x5B\x08" + 0xEB0A4183).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::Checkbox(/*Enable sound esp*/XorStr<0xE9, 17, 0xD3A569D5>("\xAC\x84\x8A\x8E\x81\x8B\xCF\x83\x9E\x87\x9D\x90\xD5\x93\x84\x88" + 0xD3A569D5).s, &cvar.visual_sound_steps);
	}
	ImGui::EndChild();
	ImGui::SameLine();
	ImGui::BeginChild(/*##vpc2*/XorStr<0x17, 7, 0xE6908698>("\x34\x3B\x6F\x6A\x78\x2E" + 0xE6908698).s, ImVec2(250, -1));
	{
		ImGui::PushItemWidth(itemWidth);
		Sakura::Menu::Widgets::SliderFloat(/*Segments*/XorStr<0xF5, 9, 0xC6E6097C>("\xA6\x93\x90\x95\x9C\x94\x8F\x8F" + 0xC6E6097C).s, &cvar.visual_sound_steps_segments, 4.f, 100.f, "%.0f");
		Sakura::Menu::Widgets::SliderFloat(/*Segment thickness*/XorStr<0xAC, 18, 0x29686B60>("\xFF\xC8\xC9\xC2\xD5\xDF\xC6\x93\xC0\xDD\xDF\xD4\xD3\xD7\xDF\xC8\xCF" + 0x29686B60).s, &cvar.visual_sound_steps_segment_thickness, 0.1f, 5.0f, "%.1f");
		Sakura::Menu::Widgets::SliderFloat(/*Radius*/XorStr<0xC6, 7, 0x957832F1>("\x94\xA6\xAC\xA0\xBF\xB8" + 0x957832F1).s, &cvar.visual_sound_steps_radius, 5.f, 45.f, "%.0f");
		ImGui::PopItemWidth();
	}
	ImGui::EndChild();
}

void Sakura::Menu::Tabs::Visuals::Local()
{
	if (Sakura::Menu::Widgets::SubSubTab(/*B*/XorStr<0x9D, 2, 0xF479ECA5>("\xDF" + 0xF479ECA5).s, /*Character*/XorStr<0x4E, 10, 0x73B93AE3>("\x0D\x27\x31\x23\x33\x30\x20\x30\x24" + 0x73B93AE3).s, ImVec2(65, 40), localPlayerSplit == 0 ? true : false))
		localPlayerSplit = 0;
	ImGui::SameLine();
	if (Sakura::Menu::Widgets::SubSubTab(/*D*/XorStr<0x27, 2, 0x0437AE1F>("\x63" + 0x0437AE1F).s, /*Real position*/XorStr<0xCC, 14, 0x387B8359>("\x9E\xA8\xAF\xA3\xF0\xA1\xBD\xA0\xBD\xA1\xBF\xB8\xB6" + 0x387B8359).s, ImVec2(65, 40), localPlayerSplit == 1 ? true : false))
		localPlayerSplit = 1;
	ImGui::SameLine();
	if (Sakura::Menu::Widgets::SubSubTab(/*E*/XorStr<0x60, 2, 0xEF712333>("\x25" + 0xEF712333).s, /*Weapon*/XorStr<0x91, 7, 0xCF875AB7>("\xC6\xF7\xF2\xE4\xFA\xF8" + 0xCF875AB7).s, ImVec2(65, 40), localPlayerSplit == 2 ? true : false))
		localPlayerSplit = 2;
	ImGui::SameLine();
	if (Sakura::Menu::Widgets::SubSubTab(/*M*/XorStr<0x45, 2, 0x3B801CBB>("\x08" + 0x3B801CBB).s, /*Bullet trace*/XorStr<0xA0, 13, 0x43B5029A>("\xE2\xD4\xCE\xCF\xC1\xD1\x86\xD3\xDA\xC8\xC9\xCE" + 0x43B5029A).s, ImVec2(65, 40), localPlayerSplit == 3 ? true : false))
		localPlayerSplit = 3;
	ImGui::SameLine();
	if (Sakura::Menu::Widgets::SubSubTab(/*O*/XorStr<0xA2, 2, 0x294CA546>("\xED" + 0x294CA546).s, /*Grenade trajectory*/XorStr<0x98, 19, 0xC455DF48>("\xDF\xEB\xFF\xF5\xFD\xF9\xFB\xBF\xD4\xD3\xC3\xC9\xC1\xC6\xD2\xC8\xDA\xD0" + 0xC455DF48).s, ImVec2(65, 40), localPlayerSplit == 4 ? true : false))
		localPlayerSplit = 4;
	ImGui::SameLine();
	if (Sakura::Menu::Widgets::SubSubTab(/*N*/XorStr<0x17, 2, 0x965EB70A>("\x59" + 0x965EB70A).s, /*Anti screenshot*/XorStr<0x0B, 16, 0x476270C1>("\x4A\x62\x79\x67\x2F\x63\x72\x60\x76\x71\x7B\x65\x7F\x77\x6D" + 0x476270C1).s, ImVec2(65, 40), localPlayerSplit == 5 ? true : false))
		localPlayerSplit = 5;
	ImGui::SameLine();
	if (Sakura::Menu::Widgets::SubSubTab(/*L*/XorStr<0x82, 2, 0xE9BBA131>("\xCE" + 0xE9BBA131).s, /*Additions*/XorStr<0x7A, 10, 0xFC236000>("\x3B\x1F\x18\x14\x0A\x16\xEF\xEF\xF1" + 0xFC236000).s, ImVec2(65, 40), localPlayerSplit == 6 ? true : false))
		localPlayerSplit = 6;

	ImGui::Spacing();

	switch (static_cast<int>(localPlayerSplit))
	{
	case 0:
		Sakura::Menu::Tabs::Visuals::LocalCharacter();
		break;
	case 1:
		Sakura::Menu::Tabs::Visuals::LocalRealPosition();
		break;
	case 2:
		Sakura::Menu::Tabs::Visuals::LocalWeapon();
		break;
	case 3:
		Sakura::Menu::Tabs::Visuals::LocalBulletTrace();
		break;
	case 4:
		Sakura::Menu::Tabs::Visuals::LocalGrenadeTrajectory();
		break;
	case 5:
		Sakura::Menu::Tabs::Visuals::LocalAntiScreenshot();
		break;
	case 6:
		Sakura::Menu::Tabs::Visuals::LocalAdditions();
		break;
	}
}

void Sakura::Menu::Tabs::Visuals::LocalCharacter()
{
	ImGui::BeginChild(/*##lc1*/XorStr<0xAB, 6, 0x4A991F98>("\x88\x8F\xC1\xCD\x9E" + 0x4A991F98).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::Checkbox(/*Light*/XorStr<0x4F, 6, 0x868C92FA>("\x03\x39\x36\x3A\x27" + 0x868C92FA).s, &cvar.visual_lambert_local);
		Sakura::Menu::Widgets::Checkbox(/*Chams Wireframe*/XorStr<0xBC, 16, 0x8C29C6A1>("\xFF\xD5\xDF\xD2\xB3\xE1\x95\xAA\xB6\xA0\xA0\xB5\xA9\xA4\xAF" + 0x8C29C6A1).s, &cvar.chams_local_wireframe);
		Sakura::Menu::Widgets::Checkbox(/*Glow*/XorStr<0x0A, 5, 0x5885979E>("\x4D\x67\x63\x7A" + 0x5885979E).s, &cvar.visual_local_glow);
		Sakura::Menu::Widgets::Checkbox(/*Third person*/XorStr<0x27, 13, 0xC6CD6DD1>("\x73\x40\x40\x58\x4F\x0C\x5D\x4B\x5D\x43\x5E\x5C" + 0xC6CD6DD1).s, &cvar.visual_chase_cam);
	}
	ImGui::EndChild();
	ImGui::SameLine();
	ImGui::BeginChild(/*##lc2*/XorStr<0xB8, 6, 0x63E5757B>("\x9B\x9A\xD6\xD8\x8E" + 0x63E5757B).s, ImVec2(250, -1));
	{
		ImGui::PushItemWidth(itemWidth);

		Sakura::Menu::Widgets::SliderFloat(/*Glow thickness*/XorStr<0xA0, 15, 0x5370D2F5>("\xE7\xCD\xCD\xD4\x84\xD1\xCE\xCE\xCB\xC2\xC4\xCE\xDF\xDE" + 0x5370D2F5).s, &cvar.visual_local_glow_thickness, 4.f, 64.f, "%.0f");
		Sakura::Menu::Widgets::SliderFloat(/*Third person Back*/XorStr<0x0F, 18, 0x8F5B31DA>("\x5B\x78\x78\x60\x77\x34\x65\x73\x65\x6B\x76\x74\x3B\x5E\x7C\x7D\x74" + 0x8F5B31DA).s, &cvar.visual_chase_back, 25.f, 125.f, "%.0f");
		Sakura::Menu::Widgets::SliderFloat(/*Third person Up*/XorStr<0xE9, 16, 0xD5255C85>("\xBD\x82\x82\x9E\x89\xCE\x9F\x95\x83\x81\x9C\x9A\xD5\xA3\x87" + 0xD5255C85).s, &cvar.visual_chase_up, 0.f, 100.f, "%.0f");
		
		if (cvar.chams_local_wireframe_mode)
			Sakura::Menu::Widgets::SliderFloat(/*Wireframe point size*/XorStr<0xCE, 21, 0x1F241978>("\x99\xA6\xA2\xB4\xB4\xA1\xB5\xB8\xB3\xF7\xA8\xB6\xB3\xB5\xA8\xFD\xAD\xB6\x9A\x84" + 0x1F241978).s, &cvar.chams_local_wireframe_point_size, 1.f, 5.f, "%.0f");
		else
			Sakura::Menu::Widgets::SliderFloat(/*Wireframe line width*/XorStr<0xA2, 21, 0xBBA95C48>("\xF5\xCA\xD6\xC0\xC0\xD5\xC9\xC4\xCF\x8B\xC0\xC4\xC0\xCA\x90\xC6\xDB\xD7\xC0\xDD" + 0xBBA95C48).s, &cvar.chams_local_wireframe_line_width, 1.f, 5.f, "%.0f");

		Sakura::Menu::Widgets::Combo(
			/*Chams*/XorStr<0x8C, 6, 0x83AE6DD1>("\xCF\xE5\xEF\xE2\xE3" + 0x83AE6DD1).s,
			&cvar.chams_local,
			/*Off\0Material\0Texture\0Flat\0*/XorStr<0xE0, 27, 0x12B9B5E4>("\xAF\x87\x84\xE3\xA9\x84\x92\x82\x9A\x80\x8B\x87\xEC\xB9\x8B\x97\x84\x84\x80\x96\xF4\xB3\x9A\x96\x8C\xF9" + 0x12B9B5E4).s);
		
		Sakura::Menu::Widgets::Combo(
			/*Chams Wireframe Mode*/XorStr<0x42, 21, 0xD6BD60A4>("\x01\x2B\x25\x28\x35\x67\x1F\x20\x38\x2E\x2A\x3F\x2F\x22\x35\x71\x1F\x3C\x30\x30" + 0xD6BD60A4).s,
			&cvar.chams_local_wireframe_mode,
			/*Lines\0Points\0*/XorStr<0x0B, 14, 0x6BE72393>("\x47\x65\x63\x6B\x7C\x10\x41\x7D\x7A\x7A\x61\x65\x17" + 0x6BE72393).s);
		
		ImGui::PopItemWidth();
	}
	ImGui::EndChild();
}

void Sakura::Menu::Tabs::Visuals::LocalRealPosition()
{
	ImGui::BeginChild(/*##lrp1*/XorStr<0x28, 7, 0xA2D50B31>("\x0B\x0A\x46\x59\x5C\x1C" + 0xA2D50B31).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::Checkbox(/*Enable*/XorStr<0x67, 7, 0xACEBE3C7>("\x22\x06\x08\x08\x07\x09" + 0xACEBE3C7).s, &cvar.visual_fakelag_history_local);
		Sakura::Menu::Widgets::Checkbox(/*Light*/XorStr<0x5A, 6, 0x49988F3E>("\x16\x32\x3B\x35\x2A" + 0x49988F3E).s, &cvar.visual_fakelag_history_local_light);
		Sakura::Menu::Widgets::Checkbox(/*Chams Wireframe*/XorStr<0xC4, 16, 0x1C0C29D6>("\x87\xAD\xA7\xAA\xBB\xE9\x9D\xA2\xBE\xA8\xA8\xBD\xB1\xBC\xB7" + 0x1C0C29D6).s, &cvar.visual_fakelag_history_local_wireframe);
	}
	ImGui::EndChild();
	ImGui::SameLine();
	ImGui::BeginChild(/*##lrp2*/XorStr<0x05, 7, 0x82E6D19E>("\x26\x25\x6B\x7A\x79\x38" + 0x82E6D19E).s, ImVec2(250, -1));
	{
		ImGui::PushItemWidth(itemWidth);
		
		if (cvar.visual_fakelag_history_local_wireframe_mode)
			Sakura::Menu::Widgets::SliderFloat(/*Wireframe point size*/XorStr<0xCE, 21, 0x1F241978>("\x99\xA6\xA2\xB4\xB4\xA1\xB5\xB8\xB3\xF7\xA8\xB6\xB3\xB5\xA8\xFD\xAD\xB6\x9A\x84" + 0x1F241978).s, &cvar.visual_fakelag_history_local_wireframe_point_size, 1.f, 5.f, "%.1f");
		else
			Sakura::Menu::Widgets::SliderFloat(/*Wireframe line width*/XorStr<0xA2, 21, 0xBBA95C48>("\xF5\xCA\xD6\xC0\xC0\xD5\xC9\xC4\xCF\x8B\xC0\xC4\xC0\xCA\x90\xC6\xDB\xD7\xC0\xDD" + 0xBBA95C48).s, &cvar.visual_fakelag_history_local_wireframe_line_width, 1.f, 5.f, "%.1f");

		Sakura::Menu::Widgets::Combo(
			/*Chams*/XorStr<0x0C, 6, 0x7D8CFF9A>("\x4F\x65\x6F\x62\x63" + 0x7D8CFF9A).s,
			&cvar.visual_fakelag_history_local_chams,
			/*Off\0Material\0Texture\0Flat\0*/XorStr<0x28, 27, 0x536E7622>("\x67\x4F\x4C\x2B\x61\x4C\x5A\x4A\x42\x58\x53\x5F\x34\x61\x53\x4F\x4C\x4C\x48\x5E\x3C\x7B\x52\x5E\x34\x41" + 0x536E7622).s);
		
		Sakura::Menu::Widgets::Combo(
			/*Wireframe Type*/XorStr<0x29, 15, 0x3B775FD8>("\x7E\x43\x59\x49\x4B\x5C\x4E\x5D\x54\x12\x67\x4D\x45\x53" + 0x3B775FD8).s,
			&cvar.visual_fakelag_history_local_wireframe_mode,
			/*Lines\0Points\0*/XorStr<0x4F, 14, 0xEABD3895>("\x03\x39\x3F\x37\x20\x54\x05\x39\x3E\x36\x2D\x29\x5B" + 0xEABD3895).s);
		
		ImGui::PopItemWidth();
	}
	ImGui::EndChild();
}

void Sakura::Menu::Tabs::Visuals::LocalWeapon()
{
	ImGui::BeginChild(/*##vo1*/XorStr<0x28, 6, 0x6C8DDCCA>("\x0B\x0A\x5C\x44\x1D" + 0x6C8DDCCA).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::Checkbox(/*Light*/XorStr<0xDE, 6, 0x4BF5EC0A>("\x92\xB6\x87\x89\x96" + 0x4BF5EC0A).s, &cvar.visual_lambert_viewmodel);
		Sakura::Menu::Widgets::Checkbox(/*Chams Wireframe*/XorStr<0xC0, 16, 0xD8820FFE>("\x83\xA9\xA3\xAE\xB7\xE5\x91\xAE\xBA\xAC\xAC\xB9\xAD\xA0\xAB" + 0xD8820FFE).s, &cvar.chams_view_model_wireframe);
		Sakura::Menu::Widgets::Checkbox(/*Glow*/XorStr<0x23, 5, 0x3193B743>("\x64\x48\x4A\x51" + 0x3193B743).s, &cvar.visual_viewmodel_glow);
		Sakura::Menu::Widgets::Checkbox(/*HitBox*/XorStr<0xE8, 7, 0xBA112B65>("\xA0\x80\x9E\xA9\x83\x95" + 0xBA112B65).s, &cvar.skeleton_view_model_hitbox);
		Sakura::Menu::Widgets::Checkbox(/*No animation*/XorStr<0xED, 13, 0xFA014232>("\xA3\x81\xCF\x91\x9F\x9B\x9E\x95\x81\x9F\x98\x96" + 0xFA014232).s, &cvar.visual_weapon_noanim);
	}
	ImGui::EndChild();
	ImGui::SameLine();
	ImGui::BeginChild(/*##vo2*/XorStr<0xB0, 6, 0x9E278B18>("\x93\x92\xC4\xDC\x86" + 0x9E278B18).s, ImVec2(250, -1));
	{
		ImGui::PushItemWidth(itemWidth);
		Sakura::Menu::Widgets::SliderFloat(/*Field of View*/XorStr<0x24, 14, 0xC200355D>("\x62\x4C\x43\x4B\x4C\x09\x45\x4D\x0C\x7B\x47\x4A\x47" + 0xC200355D).s, &cvar.visual_viewmodel_fov, 0, 50, "%.0f");
		Sakura::Menu::Widgets::SliderFloat(/*Glow Thickness*/XorStr<0x37, 15, 0x678F377D>("\x70\x54\x56\x4D\x1B\x68\x55\x57\x5C\x2B\x2F\x27\x30\x37" + 0x678F377D).s, &cvar.visual_viewmodel_glow_thickness, 1, 8, "%.0f");
		
		if (cvar.chams_view_model_wireframe_mode)
			Sakura::Menu::Widgets::SliderFloat(/*Wireframe point size*/XorStr<0xCE, 21, 0x1F241978>("\x99\xA6\xA2\xB4\xB4\xA1\xB5\xB8\xB3\xF7\xA8\xB6\xB3\xB5\xA8\xFD\xAD\xB6\x9A\x84" + 0x1F241978).s, &cvar.chams_view_model_wireframe_point_size, 1.f, 5.f, "%.1f");
		else
			Sakura::Menu::Widgets::SliderFloat(/*Wireframe line width*/XorStr<0xA2, 21, 0xBBA95C48>("\xF5\xCA\xD6\xC0\xC0\xD5\xC9\xC4\xCF\x8B\xC0\xC4\xC0\xCA\x90\xC6\xDB\xD7\xC0\xDD" + 0xBBA95C48).s, &cvar.chams_view_model_wireframe_line_width, 1.f, 5.f, "%.1f");

		Sakura::Menu::Widgets::Combo(
			/*Chams*/XorStr<0xB6, 6, 0xDFE5A85D>("\xF5\xDF\xD9\xD4\xC9" + 0xDFE5A85D).s,
			&cvar.chams_view_model,
			/*Off\0Material\0Texture\0Flat\0*/XorStr<0x4F, 27, 0x4C1796A1>("\x00\x36\x37\x52\x1E\x35\x21\x33\x25\x31\x38\x36\x5B\x08\x38\x26\x2B\x15\x13\x07\x63\x22\x09\x07\x13\x68" + 0x4C1796A1).s);
		
		Sakura::Menu::Widgets::Combo(
			/*Chams Wireframe Type*/XorStr<0xD7, 21, 0xE60496C3>("\x94\xB0\xB8\xB7\xA8\xFC\x8A\xB7\xAD\x85\x87\x90\x82\x89\x80\xC6\xB3\x91\x99\x8F" + 0xE60496C3).s,
			&cvar.chams_view_model_wireframe_mode,
			/*Lines\0Points\0*/XorStr<0x82, 14, 0xD6B8DED0>("\xCE\xEA\xEA\xE0\xF5\x87\xD8\xE6\xE3\xE5\xF8\xFE\x8E" + 0xD6B8DED0).s);
		
		ImGui::PopItemWidth();
	}
	ImGui::EndChild();
}

void Sakura::Menu::Tabs::Visuals::LocalBulletTrace()
{
	ImGui::BeginChild(/*##vo1*/XorStr<0x28, 6, 0x6C8DDCCA>("\x0B\x0A\x5C\x44\x1D" + 0x6C8DDCCA).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::Checkbox(/*Enable bullet trace*/XorStr<0xF5, 20, 0x091EEF63>("\xB0\x98\x96\x9A\x95\x9F\xDB\x9E\x88\x92\x93\x65\x75\x22\x77\x76\x64\x65\x62" + 0x091EEF63).s, &cvar.visual_bullet_trace_local);
	}
	ImGui::EndChild();
	ImGui::SameLine();
	ImGui::BeginChild(/*##vo2*/XorStr<0xB0, 6, 0x9E278B18>("\x93\x92\xC4\xDC\x86" + 0x9E278B18).s, ImVec2(250, -1));
	{
		ImGui::PushItemWidth(itemWidth);
		Sakura::Menu::Widgets::SliderFloat(/*Bullet Trace Thickness*/XorStr<0x53, 23, 0x651FF107>("\x11\x21\x39\x3A\x32\x2C\x79\x0E\x29\x3D\x3E\x3B\x7F\x34\x09\x0B\x00\x0F\x0B\x03\x14\x1B" + 0x651FF107).s, &cvar.visual_bullet_trace_local_thickness, 0.1, 3.f, "%.1f");
		Sakura::Menu::Widgets::SliderFloat(/*Bullet Trace Life*/XorStr<0x34, 18, 0xD66B70B5>("\x76\x40\x5A\x5B\x5D\x4D\x1A\x6F\x4E\x5C\x5D\x5A\x60\x0D\x2B\x25\x21" + 0xD66B70B5).s, &cvar.visual_bullet_trace_local_liveness, 0.1f, 3.f, "%.1fs");
		ImGui::PopItemWidth();
	}
	ImGui::EndChild();
}

void Sakura::Menu::Tabs::Visuals::LocalGrenadeTrajectory()
{
	ImGui::BeginChild(/*##vo1*/XorStr<0x28, 6, 0x6C8DDCCA>("\x0B\x0A\x5C\x44\x1D" + 0x6C8DDCCA).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::Checkbox(/*Enable grenade trajectory*/XorStr<0x6D, 26, 0xBC1355B0>("\x28\x00\x0E\x12\x1D\x17\x53\x13\x07\x13\x19\x19\x1D\x1F\x5B\x08\x0F\x1F\x15\xE5\xE2\xF6\xEC\xF6\xFC" + 0xBC1355B0).s, &cvar.visual_grenade_trajectory);
	}
	ImGui::EndChild();
	ImGui::SameLine();
	ImGui::BeginChild(/*##vo2*/XorStr<0xB0, 6, 0x9E278B18>("\x93\x92\xC4\xDC\x86" + 0x9E278B18).s, ImVec2(250, -1));
	{
		ImGui::PushItemWidth(itemWidth);

		Sakura::Menu::Widgets::Combo(
			/*Trace type*/XorStr<0x9F, 11, 0xDEEF641D>("\xCB\xD2\xC0\xC1\xC6\x84\xD1\xDF\xD7\xCD" + 0xDEEF641D).s,
			&cvar.visual_tg_type,
			/*Line\0Line & points\0*/XorStr<0x2C, 20, 0x85D06906>("\x60\x44\x40\x4A\x30\x7D\x5B\x5D\x51\x15\x10\x17\x48\x56\x53\x55\x48\x4E\x3E" + 0x85D06906).s);

		ImGui::PopItemWidth();
	}
	ImGui::EndChild();
}

void Sakura::Menu::Tabs::Visuals::LocalAntiScreenshot()
{
	ImGui::BeginChild(/*##vo1*/XorStr<0x28, 6, 0x6C8DDCCA>("\x0B\x0A\x5C\x44\x1D" + 0x6C8DDCCA).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::Checkbox(/*Enable anti screenshot*/XorStr<0xAF, 23, 0x1DC967D3>("\xEA\xDE\xD0\xD0\xDF\xD1\x95\xD7\xD9\xCC\xD0\x9A\xC8\xDF\xCF\xDB\xDA\xAE\xB2\xAA\xAC\xB0" + 0x1DC967D3).s, &cvar.antiss_active);
		Sakura::Menu::Widgets::Checkbox(/*Minmodels command*/XorStr<0x27, 18, 0xFD60BF42>("\x6A\x41\x47\x47\x44\x48\x48\x42\x5C\x10\x52\x5D\x5E\x59\x54\x58\x53" + 0xFD60BF42).s, &cvar.antiss_minmodels);
	}
	ImGui::EndChild();
	ImGui::SameLine();
	ImGui::BeginChild(/*##vo2*/XorStr<0xB0, 6, 0x9E278B18>("\x93\x92\xC4\xDC\x86" + 0x9E278B18).s, ImVec2(250, -1));
	{
		ImGui::PushItemWidth(itemWidth);

		ImGui::PopItemWidth();
	}
	ImGui::EndChild();
}

void Sakura::Menu::Tabs::Visuals::LocalAdditions()
{
	ImGui::BeginChild(/*##lrp1*/XorStr<0x86, 7, 0xF333F16A>("\xA5\xA4\xE4\xFB\xFA\xBA" + 0xF333F16A).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::Checkbox(/*Draw FOV*/XorStr<0x2F, 9, 0x8667E736>("\x6B\x42\x50\x45\x13\x72\x7A\x60" + 0x8667E736).s, &cvar.visual_draw_fov);
		Sakura::Menu::Widgets::Checkbox(/*Crosshair*/XorStr<0x77, 10, 0x8F5AD958>("\x34\x0A\x16\x09\x08\x14\x1C\x17\x0D" + 0x8F5AD958).s, &cvar.visual_crosshair);
		Sakura::Menu::Widgets::Checkbox(/*Colored hud*/XorStr<0x4C, 12, 0x6C50BE97>("\x0F\x22\x22\x20\x22\x34\x36\x73\x3C\x20\x32" + 0x6C50BE97).s, &cvar.visual_hud);
		Sakura::Menu::Widgets::Checkbox(/*Visual no spread*/XorStr<0xB2, 17, 0x0EF0A1D7>("\xE4\xDA\xC7\xC0\xD7\xDB\x98\xD7\xD5\x9B\xCF\xCD\xCC\xDA\xA1\xA5" + 0x0EF0A1D7).s, &cvar.rage_no_spread_visual);
	}
	ImGui::EndChild();
	ImGui::SameLine();
	ImGui::BeginChild(/*##lrp2*/XorStr<0x62, 7, 0xA6E82DC4>("\x41\x40\x08\x17\x16\x55" + 0xA6E82DC4).s, ImVec2(250, -1));
	{
		ImGui::PushItemWidth(itemWidth);
		Sakura::Menu::Widgets::SliderFloat(/*Visual no spread strength*/XorStr<0x80, 26, 0x9718FDCE>("\xD6\xE8\xF1\xF6\xE5\xE9\xA6\xE9\xE7\xA9\xF9\xFB\xFE\xE8\xEF\xEB\xB0\xE2\xE6\xE1\xF1\xFB\xF1\xE3\xF0" + 0x9718FDCE).s, &cvar.rage_no_spread_visual_strength, 0.1f, 3.f, "%.2f*");
		ImGui::PopItemWidth();
	}
	ImGui::EndChild();
}

void Sakura::Menu::Tabs::Visuals::Sound()
{
	ImGui::BeginChild(/*##vo1*/XorStr<0xA1, 6, 0x56F93954>("\x82\x81\xD5\xCB\x94" + 0x56F93954).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::Checkbox(/*Fire sounds volume*/XorStr<0x33, 19, 0x46437A26>("\x75\x5D\x47\x53\x17\x4B\x56\x4F\x55\x58\x4E\x1E\x49\x2F\x2D\x37\x2E\x21" + 0x46437A26).s, &cvar.misc_fire_sounds);
		Sakura::Menu::Widgets::Checkbox(/*Enable kill sound*/XorStr<0x36, 18, 0x381ABAC5>("\x73\x59\x59\x5B\x56\x5E\x1C\x56\x57\x53\x2C\x61\x31\x2C\x31\x2B\x22" + 0x381ABAC5).s, &cvar.radio_kill_sound);
	}
	ImGui::EndChild();
	ImGui::SameLine();
	ImGui::BeginChild(/*##vo2*/XorStr<0x8D, 6, 0x1B95C6D6>("\xAE\xAD\xF9\xFF\xA3" + 0x1B95C6D6).s, ImVec2(250, -1));
	{
		ImGui::PushItemWidth(itemWidth);
		Sakura::Menu::Widgets::SliderFloat(/*Fire sounds volume*/XorStr<0xF1, 19, 0x3EA2AAB6>("\xB7\x9B\x81\x91\xD5\x85\x98\x8D\x97\x9E\x88\xDC\x8B\x91\x93\x75\x6C\x67" + 0x3EA2AAB6).s, &cvar.misc_fire_sounds_volume, 0, 100, "%.0f%%");
		Sakura::Menu::Widgets::SliderFloat(/*Fire sounds pitch*/XorStr<0xAE, 18, 0xBD0425E6>("\xE8\xC6\xC2\xD4\x92\xC0\xDB\xC0\xD8\xD3\xCB\x99\xCA\xD2\xC8\xDE\xD6" + 0xBD0425E6).s, &cvar.misc_fire_sounds_pitch, 1, 200, "%.0f");
		Sakura::Menu::Widgets::SliderFloat(/*Kill sound volume*/XorStr<0x9D, 18, 0x764D3B4F>("\xD6\xF7\xF3\xCC\x81\xD1\xCC\xD1\xCB\xC2\x87\xDE\xC6\xC6\xDE\xC1\xC8" + 0x764D3B4F).s, &cvar.radio_kill_volume, 0.f, 100, "%.0f%%");
		ImGui::PopItemWidth();
	}
	ImGui::EndChild();
}

void Sakura::Menu::Tabs::Visuals::Radar()
{
	ImGui::BeginChild(/*##vr1*/XorStr<0x79, 6, 0xA94B69ED>("\x5A\x59\x0D\x0E\x4C" + 0xA94B69ED).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::Checkbox(/*Enable radar*/XorStr<0x18, 13, 0x248493B1>("\x5D\x77\x7B\x79\x70\x78\x3E\x6D\x41\x45\x43\x51" + 0x248493B1).s, &cvar.radar);
	}
	ImGui::EndChild();
	ImGui::SameLine();
	ImGui::BeginChild(/*##vr2*/XorStr<0xB8, 6, 0xD80C97D0>("\x9B\x9A\xCC\xC9\x8E" + 0xD80C97D0).s, ImVec2(250, -1));
	{
		ImGui::PushItemWidth(itemWidth);
		Sakura::Menu::Widgets::SliderFloat(/*Zoom*/XorStr<0x31, 5, 0xAFDFD136>("\x6B\x5D\x5C\x59" + 0xAFDFD136).s, &cvar.radar_zoom, 1, 10, "%.1f");
		Sakura::Menu::Widgets::SliderFloat(/*Point size*/XorStr<0x37, 11, 0xD74C12C2>("\x67\x57\x50\x54\x4F\x1C\x4E\x57\x45\x25" + 0xD74C12C2).s, &cvar.radar_point_size, 5, 25, "%.1f");
		ImGui::PopItemWidth();
	}
	ImGui::EndChild();
}

void Sakura::Menu::Tabs::Visuals::World()
{
	if (Sakura::Menu::Widgets::SubSubTab(/*F*/XorStr<0x22, 2, 0xDFF871FD>("\x64" + 0xDFF871FD).s, /*Esp*/XorStr<0x47, 4, 0x0066CF65>("\x02\x3B\x39" + 0x0066CF65).s, ImVec2(120, 40), worldSplit == 0 ? true : false))
		worldSplit = 0;
	ImGui::SameLine();
	if (Sakura::Menu::Widgets::SubSubTab(/*H*/XorStr<0xCB, 2, 0x2D002853>("\x83" + 0x2D002853).s, /*Light*/XorStr<0x0D, 6, 0x6B189047>("\x41\x67\x68\x78\x65" + 0x6B189047).s, ImVec2(120, 40), worldSplit == 1 ? true : false))
		worldSplit = 1;
	ImGui::SameLine();
	if (Sakura::Menu::Widgets::SubSubTab(/*I*/XorStr<0xB5, 2, 0xFD24B45D>("\xFC" + 0xFD24B45D).s, /*Chams*/XorStr<0xA4, 6, 0xE5D538EF>("\xE7\xCD\xC7\xCA\xDB" + 0xE5D538EF).s, ImVec2(120, 40), worldSplit == 2 ? true : false))
		worldSplit = 2;
	ImGui::SameLine();
	if (Sakura::Menu::Widgets::SubSubTab(/*G*/XorStr<0x2D, 2, 0xFBD0C83D>("\x6A" + 0xFBD0C83D).s, /*Map*/XorStr<0xE2, 4, 0x2CF9E085>("\xAF\x82\x94" + 0x2CF9E085).s, ImVec2(120, 40), worldSplit == 3 ? true : false))
		worldSplit = 3;

	ImGui::Spacing();

	switch (static_cast<int>(worldSplit))
	{
	case 0:
		Sakura::Menu::Tabs::Visuals::WorldEsp();
		break;
	case 1:
		Sakura::Menu::Tabs::Visuals::WorldLight();
		break;
	case 2:
		Sakura::Menu::Tabs::Visuals::WorldChams();
		break;
	case 3:
		Sakura::Menu::Tabs::Visuals::WorldMap();
		break;
	}
}

void Sakura::Menu::Tabs::Visuals::WorldEsp()
{
	ImGui::BeginChild(/*##we1*/XorStr<0xFE, 6, 0x977E290B>("\xDD\xDC\x77\x64\x33" + 0x977E290B).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::Checkbox(/*Box*/XorStr<0xC5, 4, 0x8EA33701>("\x87\xA9\xBF" + 0x8EA33701).s, &cvar.visual_box_world);
		Sakura::Menu::Widgets::Checkbox(/*Model Name*/XorStr<0xA4, 11, 0x87912C87>("\xE9\xCA\xC2\xC2\xC4\x89\xE4\xCA\xC1\xC8" + 0x87912C87).s, &cvar.visual_model_world);
		Sakura::Menu::Widgets::Checkbox(/*Owner Name*/XorStr<0xF6, 11, 0x5B1C2491>("\xB9\x80\x96\x9C\x88\xDB\xB2\x9C\x93\x9A" + 0x5B1C2491).s, &cvar.visual_name_world);
		Sakura::Menu::Widgets::Checkbox(/*Bone*/XorStr<0x0A, 5, 0x4D575A70>("\x48\x64\x62\x68" + 0x4D575A70).s, &cvar.skeleton_world_bone);
		Sakura::Menu::Widgets::Checkbox(/*Hitbox*/XorStr<0x7A, 7, 0x665248DE>("\x32\x12\x08\x1F\x11\x07" + 0x665248DE).s, &cvar.skeleton_world_hitbox);
	}
	ImGui::EndChild();
	ImGui::SameLine();
	ImGui::BeginChild(/*##we2*/XorStr<0x6F, 6, 0x5FD03FBB>("\x4C\x53\x06\x17\x41" + 0x5FD03FBB).s, ImVec2(250, -1));
	{
		ImGui::PushItemWidth(itemWidth);

		Sakura::Menu::Widgets::SliderFloat(/*Box fill opacity*/XorStr<0xCC, 17, 0x409BC2C3>("\x8E\xA2\xB6\xEF\xB6\xB8\xBE\xBF\xF4\xBA\xA6\xB6\xBB\xB0\xAE\xA2" + 0x409BC2C3).s, &cvar.visual_box_world_fill, 0.f, 100.f, "%.0f%%");

		Sakura::Menu::Widgets::Combo(
			/*Box Type*/XorStr<0x1E, 9, 0x85C72A5B>("\x5C\x70\x58\x01\x76\x5A\x54\x40" + 0x85C72A5B).s,
			&cvar.visual_box_world_type,
			/*Box\0Corners\0Coal\0*/XorStr<0x27, 18, 0x50D035EF>("\x65\x47\x51\x2A\x68\x43\x5F\x40\x4A\x42\x42\x32\x70\x5B\x54\x5A\x37" + 0x50D035EF).s);
		
		ImGui::PopItemWidth();
	}
	ImGui::EndChild();
}

void Sakura::Menu::Tabs::Visuals::WorldLight()
{
	ImGui::BeginChild(/*##wl1*/XorStr<0x13, 6, 0x030DD670>("\x30\x37\x62\x7A\x26" + 0x030DD670).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::Checkbox(/*Light*/XorStr<0xDE, 6, 0x24E7E59F>("\x92\xB6\x87\x89\x96" + 0x24E7E59F).s, &cvar.visual_lambert_world);
	}
	ImGui::EndChild();
	ImGui::SameLine();
	ImGui::BeginChild(/*##wl2*/XorStr<0x75, 6, 0x063BDE62>("\x56\x55\x00\x14\x4B" + 0x063BDE62).s, ImVec2(250, -1));
	{

	}
	ImGui::EndChild();
}

void Sakura::Menu::Tabs::Visuals::WorldChams()
{
	ImGui::BeginChild(/*##wc1*/XorStr<0x67, 6, 0x78789F42>("\x44\x4B\x1E\x09\x5A" + 0x78789F42).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::Checkbox(/*Chams Wall*/XorStr<0x3E, 11, 0x0F404D30>("\x7D\x57\x21\x2C\x31\x63\x13\x24\x2A\x2B" + 0x0F404D30).s, &cvar.chams_world_wall);
		Sakura::Menu::Widgets::Checkbox(/*Chams Wireframe*/XorStr<0x1F, 16, 0xDA780B32>("\x5C\x48\x40\x4F\x50\x04\x72\x4F\x55\x4D\x4F\x58\x4A\x41\x48" + 0xDA780B32).s, &cvar.chams_world_wireframe);
	}
	ImGui::EndChild();
	ImGui::SameLine();
	ImGui::BeginChild(/*##wc2*/XorStr<0xE7, 6, 0x44EBCF2F>("\xC4\xCB\x9E\x89\xD9" + 0x44EBCF2F).s, ImVec2(250, -1));
	{
		ImGui::PushItemWidth(itemWidth);

		if (cvar.chams_world_wireframe_mode)
			Sakura::Menu::Widgets::SliderFloat(/*Wireframe point size*/XorStr<0xCE, 21, 0x1F241978>("\x99\xA6\xA2\xB4\xB4\xA1\xB5\xB8\xB3\xF7\xA8\xB6\xB3\xB5\xA8\xFD\xAD\xB6\x9A\x84" + 0x1F241978).s, &cvar.chams_world_wireframe_point_size, 1.f, 5.f, "%.1f");
		else
			Sakura::Menu::Widgets::SliderFloat(/*Wireframe line width*/XorStr<0xA2, 21, 0xBBA95C48>("\xF5\xCA\xD6\xC0\xC0\xD5\xC9\xC4\xCF\x8B\xC0\xC4\xC0\xCA\x90\xC6\xDB\xD7\xC0\xDD" + 0xBBA95C48).s, &cvar.chams_world_wireframe_line_width, 1.f, 5.f, "%.1f");

		Sakura::Menu::Widgets::Combo(
			/*Chams*/XorStr<0xDB, 6, 0xA544FA6B>("\x98\xB4\xBC\xB3\xAC" + 0xA544FA6B).s,
			&cvar.chams_world,
			/*Off\0Material\0Texture\0Flat\0*/XorStr<0x9B, 27, 0xA866CFA7>("\xD4\xFA\xFB\x9E\xD2\xC1\xD5\xC7\xD1\xCD\xC4\xCA\xA7\xFC\xCC\xD2\xDF\xD9\xDF\xCB\xAF\xF6\xDD\xD3\xC7\xB4" + 0xA866CFA7).s);
		
		Sakura::Menu::Widgets::Combo(
			/*Chams Wireframe Type*/XorStr<0x5C, 21, 0x14850FAC>("\x1F\x35\x3F\x32\x13\x41\x35\x0A\x16\x00\x00\x15\x09\x04\x0F\x4B\x38\x14\x1E\x0A" + 0x14850FAC).s,
			&cvar.chams_world_wireframe_mode,
			/*Lines\0Points\0*/XorStr<0xE8, 14, 0x295798AC>("\xA4\x80\x84\x8E\x9F\xED\xBE\x80\x99\x9F\x86\x80\xF4" + 0x295798AC).s);
		
		ImGui::PopItemWidth();
	}
	ImGui::EndChild();
}

void Sakura::Menu::Tabs::Visuals::WorldMap()
{
	ImGui::BeginChild(/*##we1*/XorStr<0x77, 6, 0x6B2A84EA>("\x54\x5B\x0E\x1F\x4A" + 0x6B2A84EA).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::Checkbox(/*Light*/XorStr<0xC4, 6, 0x682740E8>("\x88\xAC\xA1\xAF\xBC" + 0x682740E8).s, &cvar.visual_lightmap);
		Sakura::Menu::Widgets::Checkbox(/*Fog*/XorStr<0xE2, 4, 0x17FA3175>("\xA4\x8C\x83" + 0x17FA3175).s, &cvar.visual_fog);
	}
	ImGui::EndChild();
	ImGui::SameLine();
	ImGui::BeginChild(/*##we2*/XorStr<0xCD, 6, 0xDA92CDF3>("\xEE\xED\xB8\xB5\xE3" + 0xDA92CDF3).s, ImVec2(250, -1));
	{
		ImGui::PushItemWidth(itemWidth);
		Sakura::Menu::Widgets::SliderFloat(/*Fog density*/XorStr<0x0F, 12, 0xC6077D43>("\x49\x7F\x76\x32\x77\x71\x7B\x65\x7E\x6C\x60" + 0xC6077D43).s, &cvar.visual_fog_density, 1.f, 60.f, "%.0f");
		ImGui::PopItemWidth();
	}
	ImGui::EndChild();
}

void Sakura::Menu::Tabs::Visuals::DeathMarks()
{
	ImGui::BeginChild(/*##vd1*/XorStr<0x94, 6, 0x797F6E10>("\xB7\xB6\xE0\xF3\xA9" + 0x797F6E10).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::Checkbox(/*Enable*/XorStr<0x58, 7, 0x2BDC5B50>("\x1D\x37\x3B\x39\x30\x38" + 0x2BDC5B50).s, &cvar.visual_deathmark_enable);
		Sakura::Menu::Widgets::Checkbox(/*Glow*/XorStr<0xD0, 5, 0xAC8A618C>("\x97\xBD\xBD\xA4" + 0xAC8A618C).s, &cvar.visual_deathmark_glow);
	}
	ImGui::EndChild();
	ImGui::SameLine();
	ImGui::BeginChild(/*##vd2*/XorStr<0xE2, 6, 0xABB52439>("\xC1\xC0\x92\x81\xD4" + 0xABB52439).s, ImVec2(250, -1));
	{
		ImGui::PushItemWidth(itemWidth);
		Sakura::Menu::Widgets::SliderFloat(/*Stays*/XorStr<0xC0, 6, 0x4A00E615>("\x93\xB5\xA3\xBA\xB7" + 0x4A00E615).s, &cvar.visual_deathmark_seconds, 0.f, 8.f, "%.0fs");
		Sakura::Menu::Widgets::SliderFloat(/*Transparency*/XorStr<0xAE, 13, 0xF493A40A>("\xFA\xDD\xD1\xDF\xC1\xC3\xD5\xC7\xD3\xD9\xDB\xC0" + 0xF493A40A).s, &cvar.visual_deathmark_transparency, 0.f, 128.f, "%.0f");
		ImGui::PopItemWidth();
	}
	ImGui::EndChild();
}

void Sakura::Menu::Tabs::Visuals::Skins()
{
	ImGui::BeginChild(/*##vs1*/XorStr<0x34, 6, 0x9FBAC6FB>("\x17\x16\x40\x44\x09" + 0x9FBAC6FB).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::Checkbox(/*Sky*/XorStr<0xF1, 4, 0xE0BBCC2C>("\xA2\x99\x8A" + 0xE0BBCC2C).s, &cvar.visual_sky);
		Sakura::Menu::Widgets::Checkbox(/*Player*/XorStr<0x9F, 7, 0xFCB83716>("\xCF\xCC\xC0\xDB\xC6\xD6" + 0xFCB83716).s, &cvar.visual_skins_player);
		Sakura::Menu::Widgets::Checkbox(/*Player Weapon*/XorStr<0x9F, 14, 0x59229B3F>("\xCF\xCC\xC0\xDB\xC6\xD6\x85\xF1\xC2\xC9\xD9\xC5\xC5" + 0x59229B3F).s, &cvar.visual_skins_player_weapon);
		Sakura::Menu::Widgets::Checkbox(/*Player Backweapon*/XorStr<0xE2, 18, 0xA116D8B4>("\xB2\x8F\x85\x9C\x83\x95\xC8\xAB\x8B\x88\x87\x9A\x8B\x8E\x80\x9E\x9C" + 0xA116D8B4).s, &cvar.visual_skins_player_backweapon);
		Sakura::Menu::Widgets::Checkbox(/*Player Backpack*/XorStr<0x1E, 16, 0xA4F186FD>("\x4E\x73\x41\x58\x47\x51\x04\x67\x47\x44\x43\x59\x4B\x48\x47" + 0xA4F186FD).s, &cvar.visual_skins_backpack);
		Sakura::Menu::Widgets::Checkbox(/*Player Thighpack*/XorStr<0x49, 17, 0x3E908334>("\x19\x26\x2A\x35\x28\x3C\x6F\x04\x39\x3B\x34\x3C\x25\x37\x34\x33" + 0x3E908334).s, &cvar.visual_skins_thighpack);
		Sakura::Menu::Widgets::Checkbox(/*View Model Weapon*/XorStr<0x17, 18, 0x2D28AAE7>("\x41\x71\x7C\x6D\x3B\x51\x72\x7A\x7A\x4C\x01\x75\x46\x45\x55\x49\x49" + 0x2D28AAE7).s, &cvar.visual_skins_viewmodel);
		Sakura::Menu::Widgets::Checkbox(/*View Model Hands*/XorStr<0x0C, 17, 0xEA7C47E8>("\x5A\x64\x6B\x78\x30\x5C\x7D\x77\x71\x79\x36\x5F\x79\x77\x7E\x68" + 0xEA7C47E8).s, &cvar.visual_skins_viewmodel_hands);
		Sakura::Menu::Widgets::Checkbox(/*Bullet Shell*/XorStr<0xDC, 13, 0xAA11C6F9>("\x9E\xA8\xB2\xB3\x85\x95\xC2\xB0\x8C\x80\x8A\x8B" + 0xAA11C6F9).s, &cvar.visual_skins_bullet_shell);
		Sakura::Menu::Widgets::Checkbox(/*World*/XorStr<0x61, 6, 0xED494731>("\x36\x0D\x11\x08\x01" + 0xED494731).s, &cvar.visual_skins_world);
		Sakura::Menu::Widgets::Checkbox(/*Chicken*/XorStr<0x24, 8, 0x45C96D8E>("\x67\x4D\x4F\x44\x43\x4C\x44" + 0x45C96D8E).s, &cvar.visual_skins_chicken);
	}
	ImGui::EndChild();
	ImGui::SameLine();
	ImGui::BeginChild(/*##vs2*/XorStr<0x0F, 6, 0xE69EFFDA>("\x2C\x33\x67\x61\x21" + 0xE69EFFDA).s, ImVec2(250, -1));
	{
		if (Sakura::Menu::Widgets::Button(/*Reload Textures*/XorStr<0xFE, 16, 0x6BC39523>("\xAC\x9A\x6C\x6E\x63\x67\x24\x51\x63\x7F\x7C\x7C\x78\x6E\x7F" + 0x6BC39523).s, { ImGui::GetWindowSize().x - 6, 0 })) loadtexturemodel = true;
		if (Sakura::Menu::Widgets::Button(/*Reload Sky Texture*/XorStr<0xA1, 19, 0x6272A992>("\xF3\xC7\xCF\xCB\xC4\xC2\x87\xFB\xC2\xD3\x8B\xF8\xC8\xD6\xDB\xC5\xC3\xD7" + 0x6272A992).s, { ImGui::GetWindowSize().x - 6, 0 })) Sakura::Sky::skyTextureLoaded = false;
	}
	ImGui::EndChild();
}

void Sakura::Menu::Tabs::Visuals::Removals()
{
	ImGui::BeginChild(/*##vo1*/XorStr<0x96, 6, 0xFE378686>("\xB5\xB4\xEE\xF6\xAB" + 0xFE378686).s, ImVec2(250, -1));
	{

		Sakura::Menu::Widgets::Checkbox(/*No Flash*/XorStr<0xF2, 9, 0x76CB1EEF>("\xBC\x9C\xD4\xB3\x9A\x96\x8B\x91" + 0x76CB1EEF).s, &cvar.visual_noflash_enable);
		Sakura::Menu::Widgets::Checkbox(/*No Hands*/XorStr<0xF6, 9, 0xFBA8AD97>("\xB8\x98\xD8\xB1\x9B\x95\x98\x8E" + 0xFBA8AD97).s, &cvar.visual_skins_viewmodel_nohands);
		Sakura::Menu::Widgets::Checkbox(/*No Smoke*/XorStr<0xFB, 9, 0xDDCC5EE9>("\xB5\x93\xDD\xAD\x92\x6F\x6A\x67" + 0xDDCC5EE9).s, &cvar.visual_nosmoke);
		Sakura::Menu::Widgets::Checkbox(/*No Scope*/XorStr<0xDA, 9, 0x250E8B63>("\x94\xB4\xFC\x8E\xBD\xB0\x90\x84" + 0x250E8B63).s, &cvar.visual_remove_scope);
		Sakura::Menu::Widgets::Checkbox(/*No teammates*/XorStr<0x0B, 13, 0x76589BBD>("\x45\x63\x2D\x7A\x6A\x71\x7C\x7F\x72\x60\x70\x65" + 0x76589BBD).s, &cvar.visual_dont_render_players);

		Sakura::Menu::Widgets::Checkbox(/*Hud Clear*/XorStr<0xFF, 10, 0x3DEC93D0>("\xB7\x75\x65\x22\x40\x68\x60\x67\x75" + 0x3DEC93D0).s, &cvar.visual_hud_clear);
		Sakura::Menu::Widgets::Checkbox(/*Block motd*/XorStr<0xEA, 11, 0x485E9E42>("\xA8\x87\x83\x8E\x85\xCF\x9D\x9E\x86\x97" + 0x485E9E42).s, &cvar.misc_block_motd);
	}
	ImGui::EndChild();
	ImGui::SameLine();
	ImGui::BeginChild(/*##vo2*/XorStr<0x52, 6, 0x5A6A72D7>("\x71\x70\x22\x3A\x64" + 0x5A6A72D7).s, ImVec2(250, -1));
	{
		ImGui::PushItemWidth(itemWidth);

		ImGui::PopItemWidth();
	}
	ImGui::EndChild();
}

void Sakura::Menu::Tabs::Visuals::Other()
{
	ImGui::BeginChild(/*##ot1*/XorStr<0x34, 6, 0xDE6A84E7>("\x17\x16\x59\x43\x09" + 0xDE6A84E7).s, ImVec2(250, -1));
	{
		Sakura::Menu::Widgets::Checkbox(/*Enable raining*/XorStr<0x71, 15, 0x227EF62A>("\x34\x1C\x12\x16\x19\x13\x57\x0A\x18\x13\x15\x15\x13\x19" + 0x227EF62A).s, &cvar.visual_menu_raining);
	}
	ImGui::EndChild();
	ImGui::SameLine();
	ImGui::BeginChild(/*##ot2*/XorStr<0x45, 6, 0x2A19FC30>("\x66\x65\x28\x3C\x7B" + 0x2A19FC30).s, ImVec2(250, -1));
	{
		ImGui::PushItemWidth(itemWidth);
		
		Sakura::Menu::Widgets::Combo(
			/*Raining type*/XorStr<0xCA, 13, 0x369755BD>("\x98\xAA\xA5\xA3\xA7\xA1\xB7\xF1\xA6\xAA\xA4\xB0" + 0x369755BD).s,
			&cvar.visual_menu_raining_type,
			/*Snow\0Rain\0*/XorStr<0x90, 11, 0xE89A5E33>("\xC3\xFF\xFD\xE4\x94\xC7\xF7\xFE\xF6\x99" + 0xE89A5E33).s);
		
		Sakura::Menu::Widgets::SliderFloat(/*Raining count*/XorStr<0xD6, 14, 0xD5088BAB>("\x84\xB6\xB1\xB7\xB3\xB5\xBB\xFD\xBD\xB0\x95\x8F\x96" + 0xD5088BAB).s, &cvar.visual_menu_raining_count, 25.f, 500.f, "%.0f");
		Sakura::Menu::Widgets::SliderFloat(/*Raining speed multipler*/XorStr<0x70,24,0x43E1E724>("\x22\x10\x1B\x1D\x1D\x1B\x11\x57\x0B\x09\x1F\x1E\x18\x5D\x13\x0A\xEC\xF5\xEB\xF3\xE8\xE0\xF4"+0x43E1E724).s, &cvar.visual_menu_raining_speed_multipler, 0.3f, 3.0f, "%.1f*");
		Sakura::Menu::Widgets::SliderFloat(/*Menu background opacity*/XorStr<0x47, 24, 0x8458E315>("\x0A\x2D\x27\x3F\x6B\x2E\x2C\x2D\x24\x37\x23\x3D\x26\x3A\x31\x76\x38\x28\x38\x39\x32\x28\x24" + 0x8458E315).s, &cvar.visual_menu_bg_opacity, 0.1, 0.5, "%.4f");
		ImGui::PopItemWidth();
	}
	ImGui::EndChild();
}
```

`sakura/source/features/visuals/menu/tabs/menu_visuals_tab.h`:

```h
#pragma once

namespace Sakura
{
	namespace Menu
	{
		namespace Tabs
		{
			namespace Visuals
			{
				void Player();
				void PlayerEsp();
				void PlayerSoundEsp();
				void PlayerChams();
				void PlayerGlow();
				void PlayerDynamicLight();
				void Local();
				void LocalCharacter();
				void LocalRealPosition();
				void LocalWeapon();
				void LocalBulletTrace();
				void LocalGrenadeTrajectory();
				void LocalAntiScreenshot();
				void LocalAdditions();
				void Sound();
				void Radar();
				void World();
				void WorldEsp();
				void WorldLight();
				void WorldChams();
				void WorldMap();
				void DeathMarks();
				void Skins();
				void Removals();
				void Other();
			};
		};
	};
};
```

`sakura/source/features/visuals/toasts/toasts.cpp`:

```cpp
#include "../../../client.h"

std::vector<ToastInfo> toasts;

void Toast::Create(int displaySeconds, const char* text, ...)
{
	va_list	va_alist;
	char textbf[512];

	va_start(va_alist, text);
	vsprintf(textbf, text, va_alist);
	va_end(va_alist);

	toasts.push_back({
		displaySeconds,
		textbf
	});
}

//void Toast::Create(const ToastInfo& toast)
//{
//	toasts.push_back(toast);
//}

void Toast::Remove(int toastIndex)
{
	toasts.erase(toasts.begin() + toastIndex);
}

void Toast::Render()
{
	if (!cvar.notifications_enable)
		return;

	ImVec2 Screen;
	Screen.x = cvar.notifications_x;
	Screen.y = cvar.notifications_y;

	ImDrawList* toastDraw = ImGui::GetCurrentWindow()->DrawList;

	ImVec2 ds = ImGui::GetIO().DisplaySize;
	float center_x = ds.x / 2;

	for (unsigned i = toasts.size(); i-- > 0;)
	{
		ToastInfo* currentToast = &toasts[i];

		if (currentToast->get_phase() == ToastPhase_Expired)
		{
			Toast::Remove(i);
			continue;
		}

		const auto text = currentToast->get_title();
		const auto opacity = currentToast->get_fade_percent();

		int label_size = ImGui::CalcTextSize(text.c_str(), NULL, true).x;

		int remaining_time = currentToast->get_duration() - (GetTickCount() - currentToast->get_creation_time());
		if (remaining_time < 0) remaining_time = 0;

		int bg_width = remaining_time * (label_size + 12) / currentToast->get_duration();
		if (bg_width > label_size + 12) bg_width = label_size + 12;

		if (cvar.notifications_x < center_x - label_size / 2) {
			Screen.x = cvar.notifications_x;
		}
		else if (cvar.notifications_x > center_x + label_size / 2) {
			Screen.x = cvar.notifications_x - label_size - 12;
		}
		else {
			Screen.x = center_x - label_size / 2;
		}

		if (!cvar.notifications_text_only)
		{
			toastDraw->AddRectFilled({ Screen.x, Screen.y }, { Screen.x + label_size + 12, Screen.y + 16 }, ImColor(cvar.notifications_bg_color[0], cvar.notifications_bg_color[1], cvar.notifications_bg_color[2], opacity), 8);
			toastDraw->AddRectFilled({ Screen.x, Screen.y }, { Screen.x + bg_width, Screen.y + 16 }, ImColor(cvar.notifications_bg_time_color[0], cvar.notifications_bg_time_color[1], cvar.notifications_bg_time_color[2], opacity - 0.8f), 8);
			toastDraw->AddLine({ Screen.x + 4, Screen.y + 16 }, { Screen.x + label_size + 12 - 4, Screen.y + 16 }, Sakura::Menu::GetMenuColor(opacity), 1.5f);
		}
		
		toastDraw->AddText({ Screen.x + 7, Screen.y + 1 }, ImColor(cvar.notifications_text_color[0], cvar.notifications_text_color[1], cvar.notifications_text_color[2], opacity), text.c_str());

		Screen.y += 20;
	}
}
```

`sakura/source/features/visuals/toasts/toasts.h`:

```h
#ifndef _TOAST_
#define _TOAST_

typedef int ToastPhase;

enum ToastPhase_
{
	ToastPhase_FadeIn,
	ToastPhase_Wait,
	ToastPhase_FadeOut,
	ToastPhase_Expired,
	ToastPhase_COUNT
};

class ToastInfo
{
private:
	int seconds;
	char text[512];
	uint64_t creationTime;
 
public:
	auto get_title() -> std::string { return this->text; }

	auto get_duration() -> int { return this->seconds; }

	auto get_elapsed_time() { return GetTickCount() - this->creationTime; }

	auto get_creation_time() -> uint64_t { return this->creationTime; }

	auto get_phase() -> const ToastPhase
	{
		const auto elapsed = get_elapsed_time();

		if (elapsed > cvar.notifications_fade + this->seconds + cvar.notifications_fade)
		{
			return ToastPhase_Expired;
		}
		else if (elapsed > cvar.notifications_fade + this->seconds)
		{
			return ToastPhase_FadeOut;
		}
		else if (elapsed > cvar.notifications_fade)
		{
			return ToastPhase_Wait;
		}
		else
		{
			return ToastPhase_FadeIn;
		}
	}

	auto get_fade_percent() -> const float
	{
		const auto phase = get_phase();
		const auto elapsed = get_elapsed_time();

		if (phase == ToastPhase_FadeIn)
		{
			return ((float)elapsed / (float)cvar.notifications_fade) * 1.0f;
		}
		else if (phase == ToastPhase_FadeOut)
		{
			return (1.f - (((float)elapsed - cvar.notifications_fade - (float)this->seconds) / cvar.notifications_fade)) * 1.0f;
		}

		return 1.f * 1.0f;
	}

	ToastInfo(int displaySeconds, const char* text)
	{
		sprintf_s(this->text, text);
		this->seconds = displaySeconds * 1000;
		this->creationTime = GetTickCount();
	}
};

extern std::vector<ToastInfo> toasts;

namespace Toast
{
	void Create(int displaySeconds, const char* text, ...);
	//void Create(const ToastInfo& toast);
	void Remove(int toastIndex);
	void Render();
}

#endif
```

`sakura/source/fonts/font.h`:

```h
static const unsigned int Droid_compressed_size = 134345;
static const unsigned int Droid_compressed_data[134348 / 4] =
{
    0x0000bc57, 0x00000000, 0x5ce60200, 0x00000400, 0x00010025, 0x82130000, 0x00042e04, 0x45444730, 0x03260046, 0x3d020087, 0x28158220, 0x4f50471e,
    0xa2bd9453, 0x300f82f0, 0xa8000040, 0x555347fa, 0x74916c42, 0xe602008f, 0x271f823c, 0x53544c20, 0xb99bc948, 0x10312b82, 0x0300001c, 0x2f534f86,
    0x95cba032, 0x0100008b, 0x3c1f82b8, 0x616d6360, 0xd411ce70, 0x560000a2, 0x07000078, 0x7476639e, 0x3e7e3920, 0x6800004c, 0x2c23820c, 0x677066fc,
    0x23d3736d, 0x5e0000b0, 0x281f8218, 0x73616705, 0x00040070, 0x206f8207, 0x083f8214, 0x6c670c28, 0x93c26679, 0x000051c6, 0x01001071, 0x64681ea8,
    0x0eef786d, 0x0000abfa, 0x0000a413, 0x6568d442, 0xc6eb6461, 0x4b82350a, 0x2f823c20, 0x82683621, 0x530c2210, 0x211b8209, 0x0f827401, 0x6d68242b,
    0xd7d27874, 0x0000272e, 0x2d5f8202, 0x6f6c040e, 0xfa926163, 0x00004c29, 0x6f82086a, 0x616d0628, 0x2a067078, 0x3f828502, 0x2f829820, 0x6e203208,
    0xb5656d61, 0x00569059, 0x00301902, 0x70a20600, 0xd874736f, 0x0027a950, 0x00d41f02, 0x703f1d00, 0x82706572, 0x001321dc, 0x00206500, 0x00ec0200,
    0x82358201, 0x1d5e2b03, 0x0f5fc1b5, 0x1900f53c, 0x00830008, 0x339ac122, 0x002c0683, 0x038c1bc6, 0xd5fd89fb, 0x62085a09, 0x06221082, 0x2f820200,
    0x33820283, 0xfe6d072d, 0x0900001d, 0xfe89fb64, 0x845a09a2, 0x86198349, 0x80032103, 0x03291183, 0x00a00082, 0x007a0016, 0x25398205, 0x002f0010,
    0x8a82005a, 0x00390123, 0x241d8203, 0x01990403, 0x23198290, 0x059a0508, 0x01216e82, 0x2507851e, 0x6600d003, 0x2782f201, 0x06060b30, 0x02040803,
    0x00e00402, 0x0040ef02, 0x5a825b20, 0x03822820, 0x41310025, 0x82004353, 0xfdff2f10, 0x14fe1f06, 0x6d078400, 0x0020e301, 0x1b839f01, 0x054a0423,
    0x260782b6, 0x04020020, 0x84c100cd, 0x00142311, 0x03830200, 0x9300273e, 0x85003703, 0x33002b05, 0x7b006804, 0x66009a06, 0x6d009e05, 0x8500cf01,
    0x52006802, 0x3d200382, 0x52201782, 0x66260382, 0x3f000002, 0x13829302, 0x93002526, 0x1400fc02, 0x62201382, 0xb2200382, 0x60200382, 0x17202386,
    0x83200782, 0x71200382, 0x5a200382, 0x6a200382, 0x02200383, 0x25222f83, 0x0b823f00, 0x03876620, 0x00680335, 0x00ee0625, 0x00dd046d, 0x00f80400,
    0x00d304c7, 0x8279057d, 0x00392807, 0x00ee03c7, 0x828505c7, 0x009c240f, 0x82b602c7, 0xff2b246f, 0x85a20448, 0xf6062117, 0xd5201b82, 0xf0230382,
    0x82047d00, 0xee05211f, 0xb8200782, 0x27303782, 0x27046800, 0x96051400, 0x8b04b800, 0x12070000, 0x60209f82, 0x37205b82, 0x50200382, 0x6d224382,
    0xb382a400, 0x6d021722, 0x4236e782, 0x4a032900, 0x9e04fcff, 0x3f048901, 0xb0045e00, 0xb403ae00, 0x07827100, 0x4804713a, 0xa2027100, 0x25041d00,
    0xb6042500, 0x1202ae00, 0x1202a000, 0xf803bcff, 0xae240b84, 0xae002b07, 0x04211783, 0x202f849e, 0x213383ae, 0x3f823103, 0x5a009c22, 0x2120ab82,
    0xa4261b82, 0x0000d503, 0x7f82f805, 0x23000028, 0x0a00e903, 0x7f828703, 0x3d00d528, 0xe9016804, 0x7f82d502, 0x66006822, 0x23077b41, 0xbc006804,
    0x44200382, 0x7b200382, 0x1d200382, 0x03232383, 0x827900e3, 0x06332b9b, 0x026400a8, 0x034400a6, 0x7f4100e5, 0x00932205, 0x26138352, 0xfaff0004,
    0x83006d03, 0x8266202f, 0x8231201f, 0x841f2003, 0x00c124cb, 0x823d05ae, 0x002526bf, 0x00a40193, 0x24178223, 0x00cd023f, 0x243f8242, 0x00e50554,
    0x2003823f, 0x2803822c, 0x0068031f, 0x00dd0444, 0x29039300, 0xfeffd106, 0x7d00d304, 0x8b413904, 0x82078705, 0x823e20db, 0x82522003, 0x82112003,
    0x05402503, 0x052f0079, 0x23068741, 0x7d00f005, 0xc782038b, 0x0f848d20, 0xb8009623, 0x21038a05, 0x73823704, 0x57829c20, 0xae00d126, 0x5e003f04,
    0x06290393, 0x035e00aa, 0x047100b4, 0x27038d48, 0xdeff1202, 0xae001202, 0xbd200782, 0xee240382, 0x6f009e04, 0x20088741, 0x8b2b829e, 0x00682203,
    0x201f8266, 0x201f8273, 0x27038ba4, 0x0a00e903, 0xae00b004, 0xff830784, 0x078f8383, 0x7f84fb82, 0xf7820796, 0x4382c720, 0x07827120, 0x07832f20,
    0x82390421, 0x9eab83cf, 0x85052707, 0x25047d00, 0x07982500, 0x47829c20, 0xae00b62e, 0x00009c05, 0x1200b604, 0xf5ffb602, 0xa324e782, 0x3d00b602,
    0xeb200782, 0x30200782, 0xde200782, 0x52240782, 0x44001202, 0xae240786, 0x5200e104, 0xa0245782, 0x48ff2b02, 0xbc261f82, 0xc700a204, 0xe382f803,
    0xee220383, 0x2b82c700, 0x8503ab21, 0x86662007, 0x84ae2007, 0x82662007, 0x00ee2223, 0x2233821d, 0x86d505f6, 0x22078f7b, 0x88ffff46, 0x82f0201b,
    0x009e23bf, 0x078e0571, 0x001f0724, 0xff83077d, 0x7782b820, 0xae003123, 0x20078504, 0x28078660, 0x00270472, 0x009c0368, 0x20079a5a, 0x20cb8214,
    0x8c1f8221, 0x96052707, 0xb604b800, 0x07a7a400, 0x0012072f, 0x00f80514, 0x00370414, 0x00e90300, 0x2707830a, 0x52005004, 0x52008703, 0x0221078f,
    0x23a7824c, 0x04cb0068, 0x2706fb41, 0xfeffd106, 0x5e00aa06, 0x7320db86, 0x9e23ab88, 0x83040201, 0x01752203, 0x2407821b, 0x00120221, 0x240782a0,
    0x007b016d, 0x2217841f, 0x82df009e, 0x82f82007, 0x04143203, 0x02e9ffdd, 0x04930025, 0x06e7ffc9, 0x03e7ff17, 0x240782b2, 0x05e7ff42, 0x26078254,
    0x02e7ff4a, 0x84e4ff9e, 0x44f8206f, 0x042705c7, 0x0425008b, 0x83c70039, 0x9c05219b, 0x2105cf44, 0xab82b602, 0x1382a220, 0x00008b22, 0x2307e744,
    0x52003f04, 0x05219783, 0x82178287, 0x42042327, 0x9f824e00, 0x0625e784, 0x04680023, 0x822b8260, 0x20238207, 0x203f824e, 0x30f78440, 0x037100b0,
    0x045a00a0, 0x02ae00b6, 0x04a4009e, 0x820382b8, 0xd1042213, 0x05fb4200, 0x6f009e22, 0x03231f83, 0x837100a4, 0x87042323, 0x27837100, 0x00f80329,
    0xff1704ae, 0x82c104f2, 0x00232207, 0x271f8400, 0x0571009e, 0x0419000a, 0x0f844782, 0x5b82b420, 0x12009822, 0x05215383, 0x283f8296, 0x05ecff31,
    0x06a400ec, 0x20438406, 0x826b8415, 0x83078333, 0x25e38313, 0x1400a005, 0xe345ee03, 0x20bb8205, 0x20a78268, 0x2a038252, 0xff2b0240, 0x00480748,
    0x82750700, 0x202382ff, 0x22fb8304, 0x841900ae, 0x44dd20eb, 0x2f41062b, 0x33052306, 0x4b830e00, 0x0085062b, 0x005c0404, 0x00d50548, 0x830383c9,
    0x5a052233, 0x052f4100, 0x41064741, 0xd322082b, 0x6f827d00, 0x82041421, 0x072b4153, 0x829a0521, 0x0048266b, 0x00fa07a6, 0x250383c7, 0x14003d05,
    0x5b419606, 0x00c12406, 0x821d083b, 0x82b8200b, 0x3f2008ef, 0x8f045e00, 0x89047500, 0x3303ae00, 0x6004ae00, 0x48042900, 0xc3057100, 0xae030400,
    0xe9044400, 0x03821382, 0xae26d782, 0x10005e04, 0x0f85be05, 0xfb830420, 0x0b82c120, 0x5346b020, 0x87033105, 0xe9032900, 0x93050a00, 0x00047100,
    0xd1042300, 0xac301b82, 0xf4069a00, 0x0407ae00, 0x6d05ae00, 0xfe052900, 0x67831382, 0x3700b224, 0x0b827906, 0x27823f20, 0x04236b82, 0x831200b6,
    0xb403277b, 0x9c037100, 0x8b465a00, 0x02ee2a06, 0x06bcff12, 0x06100083, 0x832b82e5, 0x41ee2023, 0x778206d7, 0xc7208f82, 0x0f433383, 0x43078f07,
    0x0023081f, 0x86085200, 0x4a032703, 0x6601fcff, 0x03831700, 0x00000223, 0x2407823f, 0x00e70219, 0x29038317, 0x3f008103, 0x7b00e303, 0x0382f803,
    0x96000236, 0x93006f06, 0x66005a09, 0x8500cf01, 0x85003703, 0x52004e02, 0x032f0383, 0x019300f6, 0x02a0fe0a, 0x046a00f8, 0x82600068, 0x06442403,
    0x82960000, 0x063f2c07, 0x048d0068, 0x07770000, 0x82c700e7, 0x05252ceb, 0x044e00f0, 0x066600f4, 0x8253000e, 0x82332003, 0x824f2003, 0x04712a03,
    0x046200a6, 0x0529008b, 0x322782ee, 0x044a000c, 0x04660068, 0x05250064, 0x037700a8, 0x84100019, 0x8713830f, 0x00aa2603, 0x00b4046d, 0x2a03841d,
    0x02cf009e, 0x04bcff12, 0x82870100, 0x826f2003, 0x027d2403, 0x822500a6, 0x820c2003, 0x863b2003, 0x472f200b, 0x2120062f, 0x00248f82, 0x00000008,
    0x02290787, 0x020000ab, 0x01000000, 0x20138255, 0x200b8268, 0x200b8225, 0x2010829a, 0x860382cd, 0x00082302, 0x03835400, 0x01376783, 0x04170066,
    0x040a00cd, 0x06000052, 0x061200a0, 0x07c700f6, 0x44ae002b, 0x422e0853, 0xaa02d3fe, 0x33037300, 0x56079300, 0x03831d00, 0x7d34f782, 0x7100aa04,
    0xb800f405, 0xa4002f05, 0x8ffc0000, 0x48fd0000, 0x46200782, 0x04200782, 0x31220382, 0xfb823904, 0xc900d53c, 0x71004804, 0xae00e904, 0x7d00db07,
    0x00006f06, 0x14002505, 0x1400dd04, 0x1f822707, 0xae00b622, 0x002a3f82, 0x0a006404, 0xc7002907, 0x0f821206, 0x1f827f20, 0x0f82f020, 0x0f828b20,
    0x8782a220, 0x39005e2e, 0x1700ae03, 0x68002306, 0xa400ec05, 0x9b427b84, 0x03002205, 0x21e382dd, 0x078400c1, 0x00640931, 0x0058087d, 0x003f0671,
    0x0019057d, 0x82b20771, 0x8250206f, 0x20778607, 0x07074704, 0x6800df24, 0x97827504, 0xf4009e26, 0xe1019e04, 0x07290383, 0x072900e9, 0x052900a6,
    0x201782e7, 0x327382fc, 0x042f009c, 0x04120089, 0x04c7009c, 0x03ae00b0, 0x822f00ee, 0x051222ff, 0x260f8200, 0x06ae0008, 0x820400e9, 0x0404248f,
    0x8248005c, 0x0544229b, 0x2017820a, 0x2037824a, 0x200782a2, 0x2607842b, 0x00f8032f, 0x82440512, 0x82d120cb, 0x00cd2457, 0x82fa04e5, 0x005c2837,
    0x00ac05e5, 0x824408ae, 0x82b820db, 0x00ec26eb, 0x00f2047d, 0x289b8871, 0x03140027, 0x04290087, 0x20d38237, 0x87db82d5, 0x82d32007, 0x003d280b,
    0x00890623, 0x828b0514, 0x0048274f, 0x00bc04a6, 0x0783059a, 0x0784ac20, 0x8204c721, 0x77062757, 0x1d053d00, 0x07873300, 0x00b60229, 0x00850652,
    0x82c30504, 0x824a2003, 0x822d209b, 0x826a2073, 0x0071244b, 0x829c0510, 0x82e92093, 0x82cb200f, 0x87f38207, 0x0607274b, 0xd105c700, 0x3b83ae00,
    0x46070342, 0x04200f5f, 0x21062348, 0xbb828f05, 0x66004822, 0x6b870787, 0x84071741, 0x00b82707, 0x00d5051b, 0x6b8304c9, 0x7b470787, 0x0ad3410e,
    0xb2033b2c, 0xae043700, 0xe9031900, 0x078f0a00, 0x1b44a387, 0x96062107, 0xfe20ab82, 0x21099f41, 0xdb82c304, 0x23002f24, 0x07826004, 0x07820020,
    0x89009c2c, 0x7100b004, 0x8900f406, 0x0782fe06, 0x00fc2e08, 0x0046064e, 0x00c50450, 0x0010044e, 0x00a40750, 0x00a40600, 0x00e50710, 0x002f07c7,
    0x00c305ae, 0x00e1047d, 0x00810571, 0x00120514, 0x26bf8229, 0x00ae036f, 0x825a055c, 0x005e224f, 0x0f0f4110, 0x12200f8e, 0x5e200f8e, 0x7b490fb0,
    0x3904271e, 0x48042700, 0xab491200, 0xb6022717, 0x12025200, 0x07866200, 0xe3489e20, 0x200f8e0f, 0x490f8e33, 0xaa200d13, 0x9b062349, 0x0fdb4807,
    0x44060f44, 0x07970717, 0x4808bb45, 0x03200ae3, 0x2805d34a, 0xfb000071, 0xfc0000db, 0x2007826a, 0x21078589, 0x078264fc, 0x038a7320, 0xa4016426,
    0x10003100, 0x002d0182, 0x01018203, 0x18281a01, 0x010a0101, 0x2504822b, 0x1401160b, 0x00880b05, 0x82141421, 0x1c3d080a, 0x1422260b, 0x0b12010b,
    0x15151915, 0x22191c14, 0x1b161e13, 0x1017151b, 0x01122610, 0x01200105, 0x1c0b1101, 0x192a150b, 0x0a0c0c2e, 0x152e180c, 0x2a120b0b, 0x0b192e0b,
    0x1912161a, 0x20068218, 0x2e448228, 0x0115180b, 0x0b271404, 0x10010401, 0x8211110b, 0x0114294d, 0x01270a11, 0x261c0a01, 0x01210084, 0x21898214,
    0x00821901, 0x22190b22, 0x0b220083, 0x00821522, 0x16132623, 0x21008411, 0x0d821c16, 0x820c1521, 0x2e152100, 0x15230983, 0x822e150b, 0x0b162400,
    0x83112616, 0x1c142101, 0x6b830185, 0x87150121, 0x190b2101, 0x33820185, 0x0c192e22, 0x15280187, 0x150c1517, 0x0c140a0a, 0x24240184, 0x2e190c14,
    0x18240183, 0x15222e19, 0x2a230183, 0x83121628, 0x2a1b2101, 0x0b210186, 0x8301821b, 0x25038743, 0x16260b10, 0x00841226, 0x260b302c, 0x22160111,
    0x012a1b15, 0xc3832401, 0x5b080383, 0x2d151426, 0x150d150c, 0x19222616, 0x15120117, 0x19151922, 0x2211191c, 0x1b201315, 0x19101926, 0x0b261922,
    0x12162e16, 0x15160c0b, 0x172e1616, 0x122d0a16, 0x18151818, 0x01181813, 0x13131912, 0x15121618, 0x0e011812, 0x191b1419, 0x19281519, 0x1530150e,
    0x19221326, 0x1218011f, 0x10211082, 0x08a7821c, 0x1b141327, 0x15101930, 0x17191914, 0x24161910, 0x19141116, 0x19151614, 0x0a19191a, 0x15191316,
    0x191c0b12, 0x161a1916, 0x361f8212, 0x19111918, 0x142e1511, 0x0c0c2a1c, 0x2e18180c, 0x1712160a, 0x830b1001, 0x16262101, 0x1523af83, 0x82151915,
    0x82192003, 0x2b143100, 0x0c191918, 0x0b0b1901, 0x01010b11, 0x0122192a, 0x0c293382, 0x2b1e1726, 0x17170101, 0x2200820b, 0x82141419, 0x01012220,
    0x85008511, 0x852e20f3, 0x01012a06, 0x1611150c, 0x26181c18, 0x22108211, 0x82221414, 0x2c1985f7, 0x1d191519, 0x01262017, 0x18181c01, 0x28938216,
    0x191a0114, 0x18152213, 0x2a018216, 0x19151401, 0x14181d01, 0x82240d1c, 0x012e282c, 0x17011916, 0x82120b13, 0x19192515, 0x01151a12, 0x0a229d82,
    0x9782180b, 0x192e1929, 0x1c141312, 0x8226191b, 0x19193301, 0x1613152a, 0x18191214, 0x160a160a, 0x20191819, 0x32821818, 0x14191823, 0x21cb8212,
    0x82821126, 0x82011621, 0x151522d6, 0x21458218, 0xdc821112, 0xe0411920, 0x11162305, 0x01831630, 0x142c3b82, 0x14121810, 0x1a100116, 0x15170b13,
    0x16236282, 0x82271817, 0x171324aa, 0x42101a12, 0x6042065a, 0x42058b05, 0x09850960, 0x190c1923, 0x9159850c, 0x2e152505, 0x1c192e15, 0x26210187,
    0x20018316, 0x0512410b, 0x00200585, 0x13350083, 0x84030000, 0x00040706, 0x02020203, 0x04050304, 0x03020201, 0x820b8203, 0x86032005, 0x20118300,
    0x271a8203, 0x03040404, 0x02040403, 0x05201a82, 0x0d850b82, 0x84030521, 0x0203212e, 0x03211982, 0x82068304, 0x8402201f, 0x0302231f, 0x15830402,
    0x0a821482, 0x05205087, 0x02200882, 0x38823583, 0x02040423, 0x83398401, 0x21528327, 0x15820405, 0x60847e84, 0x68886282, 0x37850884, 0x00820220,
    0x3f871f8d, 0x84820782, 0xbd860d85, 0x158b0682, 0x02863a82, 0x93847c82, 0xa1859b82, 0xba845285, 0x05228b84, 0x01830204, 0x28844788, 0x05852485,
    0x1f84ad85, 0x04030224, 0x3a820503, 0x4e820c84, 0x82030121, 0x263d8200, 0x04050305, 0x83040205, 0x82032081, 0x04032270, 0x239c8705, 0x04060306,
    0x24823583, 0xf1851e8a, 0x28824c82, 0x02060522, 0x06226782, 0x0e820503, 0x0621b382, 0x82088206, 0x83408210, 0x85068212, 0x040325aa, 0x04040306,
    0x06201d82, 0x04200582, 0xd5820082, 0x11820420, 0x42820320, 0x87820d82, 0x06820520, 0x04060624, 0x72820305, 0x74820320, 0x4d820320, 0x04050523,
    0x20578303, 0x84258205, 0x060627c7, 0x02010102, 0x3d820201, 0x06020323, 0x22088207, 0x82010302, 0x0305240c, 0x82060305, 0x82052041, 0x847d8400,
    0x223b8241, 0x42030404, 0x03200a24, 0x0223cf82, 0x82030102, 0x00002244, 0x204b8206, 0x83358204, 0x02022136, 0x38827a82, 0x00830020, 0x04207182,
    0x3c824c84, 0x0b828182, 0x5c840320, 0x0321af82, 0x21188207, 0x04820506, 0xb4822482, 0x82060621, 0x82032023, 0x04022503, 0x03050503, 0x0f821485,
    0x00820420, 0x18822482, 0x82056b41, 0x8311821d, 0x20ca8302, 0x82728202, 0x2211852a, 0x84020505, 0x833d8417, 0x41318327, 0x2a420ac0, 0x25638405,
    0x02030506, 0x9e840304, 0x05050622, 0xb584bb83, 0xe7840520, 0x0a8b328a, 0x05897f85, 0x960a9642, 0x85168731, 0x00042133, 0x012e0087, 0x09070101,
    0x02040004, 0x04050302, 0x48820506, 0x82040421, 0x83ed8604, 0x83022035, 0x410320c9, 0x0523063a, 0x41020405, 0xed82055e, 0x05050426, 0x04040406,
    0x41066c43, 0x3c8205f8, 0x06020423, 0x20008204, 0x23d68203, 0x04040604, 0x02200682, 0x13841583, 0x02060423, 0x2e1f8303, 0x03030403, 0x02050404,
    0x03020301, 0x83050505, 0x84068203, 0x83042037, 0x85052000, 0x41618200, 0x158406fb, 0x96840620, 0x4b42ec93, 0x076d4305, 0x07410d83, 0x851b8509,
    0x05574305, 0x05200583, 0x7f439385, 0x85058305, 0x86052020, 0x06042206, 0x08bb4306, 0x8205ac41, 0x020421c4, 0x21824b8b, 0x1c846482, 0x05040222,
    0x05213082, 0x05614304, 0x01040223, 0x21008204, 0xbe840205, 0x05020624, 0x1a820304, 0x04225982, 0x40820605, 0x04230b82, 0x42040604, 0x8a820549,
    0x00820420, 0x04030322, 0x07820985, 0x1f827784, 0x82020621, 0x04062118, 0x22057a43, 0x86070702, 0x82032043, 0x8358826a, 0x8605204b, 0x0505294a,
    0x06050808, 0x04070404, 0x41820082, 0x83430620, 0x206a820b, 0x05a34304, 0x04060324, 0x34450404, 0x06062405, 0x82040304, 0x8406200b, 0x26168200,
    0x01030707, 0x42010201, 0x0627051e, 0x02030208, 0x82010302, 0x206c8322, 0x20678207, 0x83008205, 0x86042075, 0x8204208f, 0x82022000, 0x20308503,
    0x2b7a8203, 0x01020207, 0x01010204, 0x07070000, 0x04230982, 0x82060606, 0x030221ec, 0x04210684, 0x21008300, 0x89840504, 0x05060423, 0x22038205,
    0x86070406, 0x2127820f, 0x0c820904, 0x06203282, 0x20054241, 0x87ee8404, 0x221485ce, 0x41030403, 0x0720057e, 0x26822782, 0x1e830320, 0x82040421,
    0x8457820d, 0x05844150, 0x8508c141, 0x85ea8208, 0x4145841f, 0x688609c0, 0x03201b82, 0x0d87a382, 0x5382b584, 0xa9410720, 0x89718605, 0x85098935,
    0x20058a7d, 0x0d1e4202, 0x13853393, 0x00203386, 0x01260087, 0x0a080101, 0x83430005, 0x06072705, 0x04020202, 0x9c460204, 0x202a8605, 0x83118202,
    0x050524e9, 0x82040405, 0x050226d0, 0x06060804, 0x82a38205, 0x8208200d, 0x412e8255, 0x0322071d, 0x2e820504, 0x82080221, 0x0305212b, 0x06221483,
    0xdd820404, 0xef420320, 0x220b8205, 0x82030705, 0x84072010, 0x822482f1, 0x8203202c, 0x83062045, 0x06062303, 0x85460706, 0x820d8209, 0x41178502,
    0x3d8205fb, 0x03820720, 0x4b820420, 0x43020221, 0x05210da3, 0x82418204, 0x43f68803, 0x1b860bb8, 0xb3832182, 0x86040221, 0x82052001, 0x82052047,
    0x2010884f, 0x821e8206, 0x24068603, 0x05070705, 0x41018303, 0x03200864, 0x0320b482, 0x07831d87, 0x04060824, 0x72850404, 0x64820220, 0x06070722,
    0x23052543, 0x01050205, 0x05228082, 0x51850206, 0x17820220, 0x05040623, 0x82038306, 0x06062233, 0x20278205, 0x200f8306, 0x203d8204, 0x202a8202,
    0x21388404, 0x07850402, 0xae825284, 0x05213f82, 0x83078205, 0x02042315, 0x37820808, 0x06233b84, 0x82040804, 0x08062208, 0x840e8406, 0x231d8264,
    0x08050507, 0x05243a82, 0x06040403, 0x8208a343, 0x430d8458, 0x1e8308a3, 0x43020221, 0x042306d1, 0x83060803, 0x21c78201, 0x83430808, 0x280b8206,
    0x02090603, 0x04020203, 0x824a8401, 0x8267826e, 0x82b2836b, 0x8206204f, 0x82042015, 0x06664660, 0x02832f82, 0x0804083b, 0x04010203, 0x00010202,
    0x02080800, 0x07040501, 0x04060808, 0x07030306, 0x21388207, 0x00830005, 0x08318a83, 0x07050506, 0x07040606, 0x08060605, 0x06040407, 0x261e8206,
    0x0a040604, 0x83050608, 0x22fd848b, 0x82080505, 0x8205200e, 0x03042500, 0x06080405, 0x69416f82, 0x22ec8505, 0x42060706, 0x67820729, 0x28820c82,
    0x82070521, 0x432a8201, 0x0620058c, 0x36821182, 0x58820620, 0x04070722, 0xc5830582, 0x00820420, 0x4209c041, 0x0423092c, 0x42060703, 0x052906c1,
    0x06060807, 0x07080404, 0x82558409, 0x42052039, 0x0591055a, 0x89138343, 0x85099b5d, 0x05124139, 0x00820020, 0x02020234, 0x00050c09, 0x04020205,
    0x06080506, 0x06030302, 0x9c460205, 0x06e74205, 0x82020221, 0x20dc8308, 0x82d88205, 0x050321a0, 0xf0830c82, 0x0620ed82, 0x0522b182, 0x12820303,
    0x05202383, 0x0520d682, 0x02212e82, 0x200d8208, 0x21698205, 0x32820505, 0x0320dd82, 0x13841583, 0x04070527, 0x07030505, 0x056d4205, 0x02020628,
    0x07050404, 0x6b430807, 0x84062005, 0x82388337, 0x8307200f, 0x07052200, 0x86008306, 0x08052189, 0x2005fa41, 0x08834302, 0x05201887, 0x0145f285,
    0x88062009, 0x41838319, 0x07470910, 0x04062209, 0x43d88403, 0x03220583, 0x83430204, 0x23db8308, 0x08090507, 0x820dc844, 0x0cc241ce, 0x44050621,
    0x03490689, 0x200e8205, 0x072f4608, 0x83050221, 0x06052859, 0x05070602, 0x82080708, 0x279f8259, 0x04070605, 0x06080605, 0x0521d282, 0x22ef8405,
    0x43060407, 0x10820683, 0x85050421, 0x43238234, 0x06210583, 0x05834306, 0x05273a83, 0x09030404, 0x82050609, 0x83052013, 0x820820cf, 0x07052509,
    0x06070608, 0x06274a86, 0x07070808, 0x41090505, 0x05220563, 0x08830406, 0x0d840620, 0x40840420, 0x2c820820, 0x07040522, 0x24059b44, 0x08020202,
    0x820a8208, 0x0583433c, 0x09222982, 0x5f480409, 0x06033408, 0x0304020b, 0x04010403, 0x05080505, 0x08090507, 0x82080607, 0x217f8500, 0x5c840307,
    0x04060623, 0x09ea4402, 0x05090525, 0x82020309, 0x010227f8, 0x09090000, 0xaa820202, 0x06080829, 0x04030705, 0x82070909, 0x83002082, 0x28078200,
    0x06070805, 0x06060805, 0x82078206, 0x04052303, 0x1e830606, 0x0c050622, 0x08232682, 0x82070807, 0x205682fd, 0x85ee8305, 0x208382a2, 0x84268206,
    0x0606240c, 0x84060506, 0x055c448f, 0x82040621, 0x0707214c, 0xca831584, 0x82080421, 0x824f850a, 0x05764518, 0x05080822, 0x0720c382, 0x5a827482,
    0x82060421, 0x05e0413f, 0x2407ac43, 0x04050506, 0x82768407, 0x82052009, 0x050726e6, 0x09070a05, 0x82298308, 0x065a4219, 0x42115343, 0x0a840a61,
    0x04020423, 0x91598502, 0x823d9105, 0x8700206b, 0x02022f00, 0x060c0a02, 0x02030500, 0x08060604, 0x83430207, 0x89042006, 0x02022161, 0x21058343,
    0x83430606, 0x03042117, 0xe182cf83, 0x20158343, 0x21168204, 0x50850203, 0x04080626, 0x08030505, 0x04211182, 0x43988204, 0x07220683, 0x00840604,
    0x36420920, 0x201b8206, 0x33834306, 0x2008ac44, 0x22834305, 0x9382f282, 0x20069443, 0x07834304, 0x05060722, 0x23368343, 0x05070809, 0x22055c43,
    0x84020603, 0x088343ce, 0x0520e982, 0x220e8343, 0x43080608, 0x07222683, 0x83430605, 0x20088205, 0x82008206, 0x0a83430e, 0x0820f282, 0x0a221482,
    0x0682070a, 0x83430a20, 0x0707241a, 0x43080405, 0x0a211983, 0x0a83430a, 0x430c0921, 0x08230a83, 0x43070905, 0x07230783, 0x43050606, 0x06200883,
    0x2d0b8343, 0x030a050a, 0x03060203, 0x00000102, 0x83430a0a, 0x43082008, 0x0a201083, 0x09204382, 0x08230383, 0x830a0608, 0x07834393, 0x0a210c82,
    0x421d8208, 0x0a23050b, 0x8205060a, 0x0505256c, 0x08050604, 0x2a0c8343, 0x080a0607, 0x04060607, 0x83060404, 0x08052101, 0x201e8343, 0x16834309,
    0x2205a143, 0x82060506, 0x07082163, 0x83436783, 0x0908210a, 0x07211282, 0x68834305, 0x070e0b30, 0x03030600, 0x09060705, 0x03030308, 0x9b4e0606,
    0x86062005, 0x34118300, 0x070a0506, 0x06080707, 0x03080805, 0x0a050703, 0x09060908, 0x240d8207, 0x07060907, 0x822e8207, 0x830620c9, 0x06042803,
    0x05020206, 0x82060a02, 0x47042000, 0x08830727, 0xe3824484, 0x04090627, 0x09040605, 0x27048206, 0x07060604, 0x04040203, 0x08225382, 0x00840705,
    0x06070922, 0x03200082, 0x08220082, 0x00830908, 0x08090622, 0x15840082, 0x06221882, 0x0583050a, 0x00820220, 0x06889b86, 0x84060721, 0x063f4301,
    0x08060822, 0x06201988, 0xed450b82, 0x4d058305, 0x072709fe, 0x07020305, 0x82050505, 0x220382ae, 0x86020503, 0x06082124, 0x0382db82, 0x070a0a23,
    0x44018304, 0x052007c2, 0x0521c682, 0x82498904, 0x82082027, 0x05b04373, 0x7e820220, 0x090a0923, 0x222c8206, 0x43060606, 0x07290683, 0x04090703,
    0x04090809, 0x289b8407, 0x07030908, 0x05080a07, 0x219b8209, 0x64820705, 0x2f820f82, 0x20057242, 0x05aa4a05, 0x08204083, 0x68827184, 0x06040822,
    0x072bbc85, 0x03030306, 0x07080a0a, 0x84070806, 0x0609224b, 0x21098208, 0x4a82080a, 0x82050721, 0x080829ab, 0x09080b0b, 0x070c0707, 0x04203182,
    0x05202682, 0x07204883, 0x2005b143, 0x05a34306, 0x06080828, 0x06060905, 0xf2820406, 0x82020221, 0x820520ab, 0x09042123, 0x09204382, 0x06235882,
    0x47050b0b, 0x052c0607, 0x0d090505, 0x03030503, 0x06040106, 0x09265c82, 0x09090b06, 0x00820907, 0x83070621, 0x25968429, 0x06060706, 0x03820206,
    0x00850420, 0x060b0624, 0x8343040b, 0x0b0b2e07, 0x07070202, 0x070a0a08, 0x04040906, 0x226b820a, 0x83000708, 0x208a8300, 0x23b9840b, 0x080a0607,
    0x93822183, 0x82090821, 0x06082416, 0x82090b0e, 0x201d8268, 0x21558205, 0xd0820606, 0x052b0784, 0x09060704, 0x07050608, 0x82050706, 0x08072d01,
    0x0b070906, 0x0707090a, 0x07060505, 0x0a218584, 0x82498209, 0x21a38242, 0x0b820307, 0xa5411482, 0x070a2205, 0x21218303, 0xc5850a09, 0xee4a4583,
    0x05e04105, 0x8206d244, 0x04062339, 0x67830809, 0x00820620, 0x090a0928, 0x0a060609, 0x2e820b09, 0x84070821, 0x20678477, 0x42059007, 0x0a840a61,
    0x03020323, 0x91598502, 0x20908405, 0x84a78207, 0x214b8503, 0x07470006, 0x0f0c210a, 0x2b058343, 0x080a0708, 0x07040403, 0x03040307, 0x07200582,
    0x03210086, 0x43088203, 0x06230683, 0x82040808, 0x090b21d8, 0x0720f083, 0x0b205082, 0x04281b82, 0x05060404, 0x06070707, 0x06253982, 0x06030307,
    0x28158303, 0x04060407, 0x06090507, 0x20068205, 0x84158204, 0x0706274d, 0x0706040a, 0x2f820a04, 0x07040426, 0x02030807, 0x09233b82, 0x84050909,
    0x0a07231d, 0x00820607, 0x04204f82, 0x82058243, 0x82082065, 0x821c8500, 0x060b2105, 0x4b820482, 0x15889284, 0x84059c41, 0x0628410e, 0x3341ec83,
    0x08374309, 0xd982af82, 0x0382dd83, 0x82060721, 0x826d8245, 0x030625ae, 0x03060406, 0x07236c82, 0x85080709, 0x07092306, 0x83430b0b, 0x087c4105,
    0x0f830420, 0x83074641, 0x090b2107, 0x1e857982, 0x7d820320, 0x0f820a20, 0x09820d82, 0x02070322, 0x03238d84, 0x82060907, 0x088343dc, 0x23820882,
    0x83080921, 0x4366821c, 0x1482059c, 0x06244682, 0x04070705, 0x06210482, 0x20a48206, 0x83108206, 0x821a8339, 0x82062007, 0x0304221a, 0x823a820b,
    0x0707211b, 0x82056e42, 0x080b21a9, 0x08294a87, 0x080b0b08, 0x0c07070a, 0x21008207, 0x76820605, 0xcc822682, 0x06230d82, 0x82090505, 0x221f8240,
    0x82060709, 0x05072222, 0x20f88206, 0x83dd8203, 0x0b05226d, 0x82018309, 0x0c0c2114, 0x2f0b8343, 0x0405030f, 0x04020604, 0x070a0707, 0x0a0d060a,
    0x25058343, 0x08080707, 0xac410707, 0x07072207, 0x0a834303, 0x0c060c2d, 0x07020304, 0x00010203, 0x820c0c00, 0x09072109, 0x07246382, 0x0b050409,
    0x0922b882, 0x00830008, 0x07090623, 0x840d8207, 0x0a0a2303, 0x03820707, 0x0909062b, 0x05080709, 0x0d0e0508, 0x20178209, 0x21a5820b, 0x00820706,
    0x09820c20, 0x07200682, 0x0723a582, 0x8207090a, 0x060721f4, 0x07260582, 0x08090708, 0x11830b0c, 0x70450720, 0x0a062205, 0x82408208, 0x080a2617,
    0x0904080a, 0x09a14109, 0x04090b23, 0x24008207, 0x07060b0a, 0x20018309, 0x84418309, 0x430f8409, 0x052106d5, 0x21638208, 0x6782090a, 0x9e825f82,
    0x0b215b84, 0x827f830a, 0x080621ad, 0x8e096642, 0x0f944309, 0x04030422, 0x89064342, 0x20098763, 0x44b78408, 0x614705f0, 0x20bd8205, 0x2e008700,
    0x0d020202, 0x07000810, 0x08050403, 0x43090b07, 0x14430783, 0x05f24206, 0x06230582, 0x8208080b, 0x09062beb, 0x08030509, 0x0a090b06, 0x9d820a07,
    0x0b070922, 0x04231b82, 0x82070405, 0x8208203c, 0x070426af, 0x06030308, 0x2a2c8303, 0x04060508, 0x070a0608, 0x82050606, 0x06d4436f, 0x0b08062c,
    0x04070605, 0x0706070b, 0x50820505, 0x05030328, 0x0a0a0605, 0x5d82060a, 0x0b220282, 0x00820708, 0x00820520, 0x82090921, 0x820a2015, 0x82092065,
    0x07072100, 0x07211784, 0x09834307, 0xda822f85, 0x06210883, 0x827a8208, 0x4307200b, 0xec83076d, 0x41093141, 0x08220812, 0x67510809, 0x22058305,
    0x82030608, 0x060621c9, 0x82098343, 0x2238821e, 0x840a0809, 0x0c0c2301, 0x01830508, 0x410d8343, 0x07830746, 0xdc820b20, 0x1e850720, 0xa1820420,
    0x0a0b0b26, 0x08060708, 0x03228782, 0x96830208, 0x08030829, 0x090a060a, 0x8408040a, 0x0a0929be, 0x0b080805, 0x090a0709, 0xda829a83, 0x07050a22,
    0x0420b082, 0xc0822a82, 0x08080624, 0x45820604, 0x0e850620, 0x1f820820, 0x82040b21, 0x070b220b, 0x2615820a, 0x0c030505, 0x82080a0c, 0x080821a1,
    0x0b220e82, 0x80820907, 0x82090b21, 0x2a0e824a, 0x0909070a, 0x0b090d0d, 0x820d0808, 0x05072b0d, 0x06090707, 0x07060808, 0x00820809, 0x06050624,
    0xa3430709, 0x0b062406, 0x43080707, 0x08270783, 0x06080606, 0x830a0b05, 0x23c48201, 0x02050d0d, 0x2108674f, 0x83431009, 0x834a8205, 0x0a0d247f,
    0x820a080a, 0x82082000, 0x0c834352, 0x3f06ac41, 0x07050505, 0x040d070d, 0x03070203, 0x00000103, 0x02030d0d, 0x0b0b0708, 0x0a07080b, 0x0b0b0504,
    0x09213d82, 0x2c008300, 0x08070907, 0x08080a0d, 0x0708090c, 0x25bc820c, 0x06070a0c, 0x10820a0a, 0x06080625, 0x820a0e0f, 0x281d821b, 0x08070806,
    0x0c0d0808, 0x05d1410a, 0x49820520, 0x83070921, 0x057c4414, 0x090a0824, 0x33820b0d, 0x05070622, 0x0624b682, 0x090b0707, 0x25059441, 0x090b090b,
    0xf4820b05, 0xa6820920, 0x0e821283, 0x0b244283, 0x0a07070b, 0x0b200182, 0x07204582, 0xe0411a84, 0x092c4205, 0x0b050724, 0x6782060a, 0x07070725,
    0x820c0b08, 0x0d0723ae, 0xa3820d0b, 0x07080923, 0x05df4306, 0x8909d843, 0x0e924309, 0x03050724, 0x59850305, 0x8e830591, 0x87090a21, 0x22b78401,
    0x87000806, 0x03033800, 0x08110e03, 0x04040700, 0x0c080906, 0x0404030a, 0x05040808, 0x88080504, 0x26118300, 0x090c0608, 0x820a0809, 0x050a28cc,
    0x0c070803, 0x48080b0a, 0x0d200553, 0x04239382, 0x43070405, 0x08280504, 0x04080704, 0x0d040704, 0x05213c83, 0x20d68207, 0x83a9820a, 0x82042008,
    0x08082156, 0x0c25e382, 0x05080705, 0x2e2f820c, 0x08080505, 0x05030409, 0x0a0a0705, 0x8409060a, 0x430c2000, 0x0a220883, 0x00830b0a, 0x820b0821,
    0x070a211c, 0x48823983, 0x820c0721, 0x209e8209, 0x884d8504, 0x080722a1, 0x05674307, 0x21072041, 0xc041080a, 0x82188205, 0x070a2112, 0x15820186,
    0x23096751, 0x04030808, 0xae826e83, 0x07040725, 0x41040705, 0x0a200639, 0xdd83d982, 0x430d0c21, 0x6b410683, 0x21c68207, 0x5e410507, 0x0a0d210b,
    0x72851a82, 0x09080428, 0x0b0c0c07, 0xa0850708, 0x08030822, 0x09290082, 0x060b0804, 0x040b090b, 0x279d8309, 0x050b0a08, 0x0a0c0908, 0x0820d282,
    0x62822782, 0x07050b22, 0x04203d82, 0x07822982, 0xd7820620, 0x07820720, 0x49080721, 0x8343055a, 0x0d0d2610, 0x0a08080a, 0x25688209, 0x080b0709,
    0x4b830a0a, 0x12820b20, 0x0b080722, 0x0d261682, 0x090c090d, 0x4f820f08, 0x2382b582, 0x09820820, 0x06821c82, 0x43070521, 0x09220583, 0x3782080b,
    0x05080829, 0x04040707, 0x820c0c04, 0x07082483, 0x830a0d06, 0x07072601, 0x060e0e07, 0x36008203, 0x07060606, 0x110c0607, 0x04040603, 0x08050207,
    0x0b080c08, 0x820a0e07, 0x0b0b24c5, 0x8209080b, 0x0a08217f, 0x57821582, 0xb0840820, 0xe64f0720, 0x07053605, 0x050e070e, 0x04080204, 0x00000103,
    0x03040e0e, 0x0c0b0808, 0x23a9820d, 0x0d0d0605, 0x8343eb82, 0x080a3006, 0x090b0d08, 0x090a0d08, 0x090a0c07, 0x820c0d09, 0x820a2093, 0x09072557,
    0x0b0f1107, 0x0d221b82, 0x3b44080b, 0x0d0e2105, 0x0826be84, 0x08090507, 0x14840a0b, 0x05830720, 0x0d820a20, 0x830c0f21, 0x05072211, 0x83008207,
    0x20498240, 0x43178208, 0x09210583, 0x05454508, 0x0c080926, 0x0709050a, 0x0c236882, 0x830b0807, 0x08092101, 0x84062d47, 0x8308200d, 0x059f460d,
    0x0c050725, 0x8405070b, 0x0c08300f, 0x080b0c0c, 0x0e0c0d07, 0x0a080a0c, 0x41070809, 0xd9460570, 0x07092111, 0x84085a4a, 0x08072538, 0x04050405,
    0x05915985, 0x08204b82, 0x83057248, 0x05514205, 0x300c8343, 0x0009120f, 0x07040408, 0x0b0c080a, 0x08050504, 0x464c8208, 0x08200698, 0x04210082,
    0x2f048204, 0x0a0a0d06, 0x08080a09, 0x04060b0a, 0x0b0d0709, 0x56824a84, 0x08090e28, 0x05060508, 0xab840608, 0x2a820820, 0x042b4882, 0x0909080d,
    0x05070609, 0x430b0708, 0x09200e83, 0x82058343, 0x05052eb6, 0x040a0809, 0x07050503, 0x060b0b0b, 0x2000840a, 0x05ba450d, 0x06060623, 0x8214820a,
    0x84082002, 0x204d8206, 0x20008408, 0x0883430d, 0x09206e82, 0x08200082, 0x07213084, 0x22bb8209, 0x4a0a080a, 0xaa820847, 0x34841884, 0x37430820,
    0x080b2307, 0xb551080b, 0x09042108, 0x0920f282, 0x83439d82, 0x05394108, 0x06820a20, 0xdd830920, 0x4b0e0d21, 0x304105d6, 0x07072105, 0x41059143,
    0x0e210b5e, 0x41c6820b, 0x04200580, 0x0d266482, 0x07090b0d, 0x99820907, 0x03090422, 0x092a9b82, 0x0c09040a, 0x0c0a0c07, 0x81830a04, 0x0623ca82,
    0x820d0a09, 0x830b2040, 0x2962829b, 0x0908060b, 0x08040807, 0xc0820909, 0x09080728, 0x08070704, 0x39820708, 0x08220e82, 0x3882080b, 0x0c20de82,
    0x092a0982, 0x04060607, 0x090b0f0e, 0xd9820b09, 0x080a0823, 0x244c820c, 0x0b0d0b09, 0x2212820b, 0x820b0908, 0x0e0e2616, 0x090a0d0a, 0x247c8210,
    0x08080608, 0x8348830b, 0x21608238, 0x0d830707, 0x0a0d0d2a, 0x0c07080b, 0x06080808, 0x20058343, 0x0583430d, 0x830b0e21, 0x21c48201, 0x83430f0f,
    0x82082007, 0x04122227, 0x08834307, 0x0f080c23, 0x0583430c, 0x0b0a0923, 0x205c8209, 0x82458206, 0x090922b4, 0x43088204, 0x08330683, 0x050f080f,
    0x04080304, 0x00000203, 0x03040f0f, 0x820c0809, 0x0c082573, 0x0e0e0605, 0x83433d82, 0x0b082205, 0x2e4c8208, 0x0b0d090a, 0x0a0d080a, 0x0c0e090a,
    0x820b0708, 0x07092b54, 0x10120709, 0x0c0d090b, 0x0b820c0f, 0x0f225c83, 0x63840b0e, 0x0a060824, 0xba820c08, 0xca820920, 0x0a070928, 0x0c080b09,
    0x3f82100a, 0x41070921, 0x09210579, 0x05994207, 0x09261782, 0x0c06090c, 0x70430a0b, 0x82082005, 0x820b2061, 0x2106823b, 0x1284080d, 0x6e824583,
    0x09200b83, 0x57439183, 0x080a2507, 0x0b0d0608, 0x2506c142, 0x0e0e0e09, 0xa482090c, 0x0a20f384, 0xd5462f83, 0x46118511, 0x08860802, 0x06040623,
    0x09674304, 0x0820098e, 0x83075642, 0x20b98617, 0x0a074700, 0x0a141022, 0x2a058343, 0x040b0d09, 0x09090505, 0x46040504, 0x09200698, 0x04210082,
    0x25048204, 0x0b0b0e07, 0xcc820b0a, 0x04060b26, 0x0c0e0809, 0x0a204a82, 0x0a270d82, 0x0908090e, 0x82050605, 0x820920cf, 0x04092809, 0x04040908,
    0x820e0408, 0x06092731, 0x08090507, 0xe182080c, 0x82060921, 0x82128315, 0x060d2122, 0x0d323082, 0x06090708, 0x0a090906, 0x06060304, 0x0c0c0c08,
    0x00840b07, 0x080a0e22, 0x06200082, 0x0b210082, 0x2010840c, 0x22058409, 0x840a0908, 0x0e09223d, 0x21908508, 0x0f850404, 0x08210586, 0x06644409,
    0x21086d43, 0x9f480b09, 0x43058405, 0x15820837, 0x21098343, 0x4582080a, 0xae826d82, 0x08040827, 0x0c040806, 0x21018309, 0x25820c0b, 0x0924dd82,
    0x060a0f0e, 0x7c480183, 0x08052108, 0x5a410182, 0x0c0e210b, 0x61843e82, 0x82050821, 0x0e0e2134, 0x07207482, 0x8343a084, 0x040b3405, 0x0d070c0a,
    0x0b050d0b, 0x080a080b, 0x060b0b09, 0x820e0a09, 0x090b305e, 0x0d080809, 0x060b0d09, 0x09070908, 0x82090905, 0x0707261c, 0x08050909, 0x20188208,
    0x05eb4609, 0x0c080b29, 0x0909050c, 0x83080c09, 0x0606283c, 0x0b0f0f04, 0x820b0a09, 0x224b827f, 0x820c090e, 0x0b0e2147, 0x0a2e0e82, 0x090d0a08,
    0x10100a0b, 0x0a0a0d0b, 0x31820a10, 0x09090625, 0x8209070b, 0x090b2197, 0xbe820082, 0x09080b25, 0x820e0e09, 0x0d0821d8, 0x06271082, 0x04040708,
    0x830e0e04, 0x0608236a, 0x01830c0e, 0x08080825, 0x47071010, 0x082a0607, 0x140c0708, 0x05050704, 0x4a820208, 0x0d090d28, 0x0b0d1008, 0x00820c0a,
    0x0b0a0923, 0x825c820a, 0x23478215, 0x040a0909, 0x06203782, 0x082e0085, 0x05100810, 0x04090304, 0x00000203, 0x09821010, 0x820c0921, 0x0d092173,
    0x21068343, 0x0083000a, 0x090c0827, 0x0b0d1009, 0x29b98209, 0x0b0c0e09, 0x090e0f09, 0x07820d07, 0x0822c482, 0x17821113, 0x0d100d22, 0x5d830b82,
    0x820f1021, 0x2708822b, 0x080b0608, 0x07090b0e, 0x082e7882, 0x0a0b0809, 0x0b0c090b, 0x0a0d0d11, 0x9841080a, 0x08092e05, 0x0a0b0b0d, 0x090b090a,
    0x0a0d0a0d, 0x41598306, 0x0a2005a3, 0x06206582, 0x0e220a83, 0x1d82080e, 0x45825c82, 0x81820920, 0x0d840c20, 0x43090b21, 0x0927085b, 0x0c0d0608,
    0x820a0608, 0x0909245f, 0x820f0e0e, 0x0e102382, 0x3b820e10, 0xa24e0a20, 0x0e4f4305, 0x2e833f86, 0x8343038b, 0x2033831c, 0x05f84b0a, 0xba820b20,
    0x00820820, 0x20059644, 0x2e008200, 0x11030303, 0x09000a14, 0x0b070404, 0x430c0e09, 0x0f201883, 0x0c2a4182, 0x0c0c0909, 0x080a0506, 0xf0820d0f,
    0x0d820b20, 0x090f0a2b, 0x06050a09, 0x0a070905, 0x21d38209, 0x83430609, 0x090f2a05, 0x060a0a0a, 0x08090608, 0x0e83430d, 0x060e0a37, 0x0e050908,
    0x06090709, 0x0b090a06, 0x06060304, 0x0d0d0d08, 0x822f8207, 0x0a0e2202, 0x20008209, 0x20008206, 0x8214820c, 0x0d092102, 0x4305fb41, 0x6e821083,
    0x00820a20, 0x20059c43, 0x827a8308, 0x08564111, 0x0c0a0c22, 0x4e823186, 0x080c0922, 0x09220186, 0x8343090c, 0x080b2409, 0x430a0405, 0x0d210b83,
    0x20018309, 0x2004820b, 0x24dd820a, 0x0b0f0f0a, 0x43018306, 0x062108cc, 0x43018209, 0x058505a8, 0x820d0f21, 0x05c9411b, 0x88820520, 0x0d0e0e26,
    0x0a08090a, 0x04228782, 0xcf84030a, 0x0d0a0429, 0x0d0b0d08, 0x820b0a05, 0x0c0a251e, 0x0a0a060d, 0x0d203382, 0x0e289b84, 0x060d0e09, 0x09080a09,
    0x43833a82, 0x0a09082b, 0x09090805, 0x0b0a0808, 0x82cf820a, 0x0d0c21aa, 0x09211a82, 0x2809820d, 0x0606090a, 0x0c100f05, 0x82d6820a, 0x090b294b,
    0x0d0d0a0e, 0x0c0f0b0a, 0x0a2d4a82, 0x090e0a09, 0x11110b0c, 0x0a0b0e0b, 0x21688312, 0xf1820906, 0x38844982, 0x08080a22, 0x092efd82, 0x0b0f0f09,
    0x0e08090c, 0x06090909, 0x83430808, 0x0f072209, 0x8201830d, 0x111121c7, 0x21098343, 0x83430f06, 0x090e230b, 0xc5820e12, 0x72820d20, 0x0b0c0a22,
    0x07205c82, 0x22058143, 0x41040a0a, 0x200806ac, 0x09060606, 0x06110911, 0x05090304, 0x00000203, 0x03041111, 0x0f0d0a0a, 0x0d090a0f, 0x10100706,
    0x20b7820d, 0x82008300, 0x11092acd, 0x0f0a0b0e, 0x0f090a0c, 0x20b5820c, 0x2293820e, 0x830a0d0c, 0x121427f1, 0x0d0f0a0d, 0x0b820e11, 0x0a0a0926,
    0x0e10110a, 0xfa820683, 0x0c22ee82, 0x3343080a, 0x0a0b2705, 0x0b0d090c, 0x43820f12, 0x19470820, 0x08092f05, 0x0a0c0c0d, 0x090c090b, 0x0a0e0a0e,
    0xa1820e06, 0x0c220c83, 0x61820b09, 0x090a0627, 0x0e0e090a, 0x22778209, 0x820e090d, 0x080a2245, 0x210b830d, 0x01820d0a, 0x2009b045, 0x20368209,
    0x2c2b8209, 0x0a0a0809, 0x0d100f0f, 0x0e10090b, 0x212e8211, 0x77840b0d, 0x4d08c74d, 0x098309d1, 0x820c0646, 0x0406230c, 0xda4b0406, 0x20059105,
    0x219f820c, 0x01870a0c, 0x44055242, 0x83430596, 0x16123006, 0x0509000b, 0x0a0c0704, 0x05040d0f, 0x820a0a05, 0x0614434c, 0x00820a20, 0x82040421,
    0x10083304, 0x0c0b0b0b, 0x0d0c090a, 0x090a0506, 0x0b0d0d10, 0xda820b0d, 0x82100a21, 0x0705238d, 0x2f820a05, 0x0b080b22, 0x0b370682, 0x05090505,
    0x0b0a0b10, 0x0609070b, 0x090d0a0b, 0x0a06080a, 0x83050a06, 0x820a2044, 0x060f252c, 0x0f060a0a, 0x0626ed82, 0x0c0b0a06, 0x06820404, 0x0d0d0d22,
    0x2305734a, 0x0a0b0f0b, 0x83430082, 0x820a200a, 0x0d0d231b, 0x17840b09, 0x0f0a0a24, 0x00820a08, 0x00820520, 0x11860a20, 0x820b0a21, 0x08604400,
    0x2207f146, 0x870c0b0c, 0x872f821f, 0x20b383fa, 0x08725d06, 0x050a0b27, 0x09090a05, 0x82ae8209, 0x09062203, 0x821e8305, 0x21028203, 0x01820d0a,
    0x0b101023, 0x41018307, 0x0621086a, 0x86018209, 0x22fd8224, 0x82100b0d, 0x06f643dc, 0x82820520, 0x0d0f0f22, 0xa0844f82, 0x28058343, 0x0e0b040b,
    0x0e0c0e08, 0x21be8206, 0xca820a0b, 0x820a0621, 0x20078233, 0x2527820b, 0x0d0e0a0e, 0xb0820906, 0x1c821d82, 0x0b080837, 0x0909060a, 0x0a08090b,
    0x0a080b0c, 0x0a0d0b08, 0x0b060d0c, 0x2807820a, 0x090b0a0d, 0x10050606, 0x20088211, 0x22ed830d, 0x820e0a0c, 0x0c0a2444, 0x820d0d10, 0x0b09210f,
    0x0c270d82, 0x0f0c1212, 0x82130b0b, 0x070a2149, 0x08256a82, 0x0a090b0b, 0x393e820e, 0x0a08080b, 0x0b0b090d, 0x0e0c1010, 0x0a0f080a, 0x08070b0a,
    0x05050509, 0x2082100f, 0x07090b24, 0x01830d10, 0x090a0939, 0x03071212, 0x06030403, 0x08080606, 0x04150f07, 0x09060607, 0x820a0702, 0x090e266a,
    0x0b0d0e13, 0x8200820e, 0x4560828d, 0x0b200530, 0x05200082, 0x080a8343, 0x12091220, 0x0a030506, 0x00020405, 0x05121200, 0x0f0a0b03, 0x0a0b1010,
    0x1107060e, 0x0d0a0d11, 0x0083000c, 0xc2820a20, 0x0c0e1228, 0x0b0d100b, 0x0782100a, 0x93821120, 0x0d0c0e23, 0x2800830a, 0x0a0d1316, 0x0e120e11,
    0x0503500b, 0x82111221, 0x820b2023, 0x0b0725c6, 0x0a0d0e09, 0x09241483, 0x0b0c090a, 0x0c288982, 0x0c0d0f13, 0x0809080b, 0x13827e82, 0x0d0d0f23,
    0x2b17830b, 0x0c0f0c0f, 0x0c0d0e06, 0x0d0a0c0a, 0x65822682, 0x0b060e23, 0x2187820a, 0x77820a0f, 0x0e0a0d27, 0x0a080a0d, 0x431a8308, 0x68830523,
    0x1f820b20, 0x0a0b0c26, 0x090e0f07, 0x0a2d6782, 0x100b0b09, 0x0b0f1011, 0x130f1209, 0x23258210, 0x0c080a0c, 0x8e095c42, 0x05364609, 0x06230589,
    0x43050605, 0x1186117d, 0x0d219082, 0x4301870c, 0x0b2105d4, 0x29008700, 0x13040404, 0x0a000b17, 0x6e820405, 0x040d1024, 0x83430606, 0x0c0c3616,
    0x090a0d0c, 0x05060e0d, 0x0e110a0b, 0x0c0e0b0e, 0x0b0e0a0a, 0x24838211, 0x0a060706, 0x20cd8208, 0x08834309, 0x0d821120, 0x09080b2c, 0x0e0a0b06,
    0x07080a0a, 0x8343070a, 0x0b0a3807, 0x0a0a0710, 0x080a1006, 0x0b06060a, 0x04040c0b, 0x0e0a0706, 0x82080e0e, 0x2102825d, 0x83430c10, 0x820d2007,
    0x83028214, 0x0e0e221b, 0x0783430a, 0x43091021, 0x67431783, 0x0c092106, 0x0d200184, 0x1c41f282, 0x06064109, 0xb3820a20, 0x83430b20, 0x090b240d,
    0x84050a09, 0x0a062201, 0x221e8305, 0x820d0b0e, 0x25b58206, 0x11110a0e, 0x0183080c, 0x2108fc44, 0x01820a06, 0x05852485, 0x830e1121, 0x82082063,
    0x050826cb, 0x100a0c0a, 0x210f8210, 0x00820b09, 0x040b0522, 0xdd820582, 0x090e0b2b, 0x060f0d0f, 0x0b0a0c0c, 0x22ca820a, 0x820c0b06, 0x0e0e2133,
    0x62830c82, 0x0a060e22, 0x24098343, 0x060a0b09, 0x28268209, 0x0b0c0a09, 0x0b090a09, 0x242f840d, 0x0a0e0b0a, 0x2a5b820d, 0x11050606, 0x0b0b0d12,
    0x830b0c0e, 0x821020e9, 0x0d0b231c, 0x4a820e11, 0x0e325a82, 0x120c0e0a, 0x0c100c12, 0x0a0c140c, 0x0b070a0a, 0x83430e0a, 0x09092109, 0x0b2d4082,
    0x0d11110b, 0x0f090a0f, 0x070b0a0a, 0x09834309, 0x11080a23, 0x8201830e, 0x13133035, 0x04030308, 0x07070703, 0x0f070808, 0x43080417, 0x0f260883,
    0x0e0e130a, 0x00820e0c, 0x83437f82, 0x0c0c2309, 0x3045050b, 0x06062606, 0x0a130a06, 0x08834313, 0x0513132f, 0x100a0b03, 0x0a0c1111, 0x1208060f,
    0x20a08312, 0x82008300, 0x130b26f5, 0x110b0c0f, 0x2603820e, 0x130d0e0f, 0x82080a11, 0x0b0a2157, 0x16250182, 0x120b0e14, 0x221d820f, 0x820b0c09,
    0x12132200, 0x2905820e, 0x07090b0b, 0x0e100a0c, 0xe782080a, 0x090b092e, 0x0b0e0b0d, 0x10140c0f, 0x090c0c0e, 0x25069841, 0x0d0d100a, 0x17840c0b,
    0x060c0f25, 0x820d0e10, 0x820e20ef, 0x2361820e, 0x0a0c060e, 0x10213d82, 0x2077820a, 0x2145840e, 0x1a83090a, 0x11828f82, 0x4a090c21, 0x0c28051b,
    0x10070a0b, 0x0b07090f, 0x0b32cd82, 0x1111110b, 0x13090b0f, 0x0e111410, 0x0a0c0d0a, 0xbd460d08, 0x06624208, 0x83430f88, 0x92598513, 0x820b2005,
    0x4b0c2077, 0x0e2105f8, 0x4339850c, 0x14350c83, 0x0a000c18, 0x0d080505, 0x050e110b, 0x0b0b0606, 0x07050605, 0x2100880b, 0x0a820505, 0x0d110938,
    0x0b0e0c0c, 0x070d0e0a, 0x110a0b06, 0x100c100e, 0x0d0b0b0c, 0x1b82120c, 0x12820620, 0x0b0c082e, 0x0a0c090c, 0x050c0b07, 0x13050a05, 0x0c280d82,
    0x0c070908, 0x0a0a0f0a, 0x0721dd82, 0x3b44840b, 0x0c090b0b, 0x0b0a0711, 0x090a1106, 0x0c07070b, 0x04050d0c, 0x0f0a0707, 0x0d090f0f, 0x11200084,
    0x0b205382, 0x07241982, 0x100e0e07, 0x0b210083, 0x21178310, 0x17840c0b, 0x110b0b22, 0x20088343, 0x8211860b, 0x440c201a, 0x0d2107f9, 0x0581430b,
    0x0e090c25, 0x410c0e0c, 0x05830560, 0x0b20fe82, 0x0d250383, 0x070c0d0c, 0x26018705, 0x05060a0d, 0x430a0a0b, 0x23410a83, 0x0c0e2305, 0x01830b10,
    0x0c121223, 0x4c018308, 0x0721080c, 0x4401820b, 0xfb8209cc, 0x5d820f20, 0x06311e85, 0x110b0d0b, 0x0b0b1011, 0x0b0c0c09, 0x040c050c, 0x2900820c,
    0x0f0d050d, 0x110d1109, 0x13820d06, 0x0d0b0b2a, 0x0c0b0710, 0x100b0e11, 0x0b240e82, 0x0f0b0f0b, 0x08220f83, 0x2982060c, 0x080b0b2f, 0x060b0c09,
    0x0a0c0a0a, 0x0c0d0b09, 0x24468209, 0x0f0f0a0d, 0x20378206, 0x2bba820f, 0x07070b0c, 0x0e131306, 0x0d0d0c0b, 0x6a825f82, 0x0e0e0b27, 0x0d110d0b,
    0x2d0e8310, 0x0d0b0f0c, 0x0d13130d, 0x150d0c10, 0x4a820b0c, 0x0a0b2d08, 0x0c0c080f, 0x0c0e0b0a, 0x090c0c0b, 0x0a0f0a09, 0x11110c0c, 0x090b100e,
    0x0c0a0b11, 0x05090908, 0x11110505, 0x0c0a0a0c, 0x0f120809, 0x0b260183, 0x14140a0a, 0x00820408, 0x08080839, 0x0f080a0a, 0x06080517, 0x07030a06,
    0x0b0f0b0b, 0x0f140a10, 0x820f0c10, 0x0c0c2200, 0x2160820e, 0x6482080e, 0x820b0b21, 0x0a0523b6, 0xb2520a0a, 0x0a210806, 0x07140a14, 0x050b0305,
    0x00000204, 0x04051414, 0x11110b0c, 0x100b0d13, 0x12120807, 0x0d0f0b10, 0x24008300, 0x0c0a0e0b, 0x3db48213, 0x0b0d0e12, 0x0d0f0f12, 0x080b1113,
    0x0b100f0f, 0x0a0c0a0c, 0x0c101518, 0x10131012, 0xb683090c, 0x13140c24, 0x00830c0e, 0x0c080a27, 0x0b0f110a, 0x2e788208, 0x0d0a0b0a, 0x0f0c0d0c,
    0x0f11150e, 0x52090c0c, 0x0b200527, 0x0d211d82, 0x2717830d, 0x0d100d10, 0x0d0f1107, 0x22087246, 0x83070e11, 0x1111240c, 0x820f0a0b, 0x22458301,
    0x820e090b, 0x05e041c3, 0x43090d21, 0x0d250555, 0x10080b0c, 0x25678310, 0x0c0c0a0b, 0x27821212, 0x11130928, 0x0b0f1213, 0xaa550e0e, 0x0bfc4805,
    0x60420b89, 0x23098509, 0x05070507, 0x05915985, 0x0d21b784, 0x8501860f, 0x051a482f, 0x00820020, 0x04040438, 0x000d1a15, 0x0806050b, 0x0f110c0e,
    0x0c060604, 0x0607060c, 0x00880c08, 0x0c221183, 0xe8821209, 0x0a0b0e2c, 0x06080f0e, 0x0f120a0c, 0xec820c0f, 0x0c0f0a2d, 0x0b0c0b13, 0x0b060806,
    0x820b0c09, 0x430b20d1, 0x3d820883, 0x07090827, 0x0b100b0c, 0x2206820b, 0x82050c07, 0x27138256, 0x07110c0a, 0x11070c0a, 0x07252f82, 0x0e0c0c07,
    0x0d834306, 0x0b0d1222, 0x08200082, 0x0e210082, 0x2000840f, 0x2005850c, 0x0671430c, 0x820a1221, 0x050b211e, 0x4b820082, 0x0b220289, 0x1a410b0c,
    0x460a2006, 0x0e2205f3, 0x31860e0c, 0x83432f83, 0x20b38207, 0x05dd540c, 0x0d240583, 0x0c05060b, 0x830b8343, 0x0c0f221e, 0x8206850e, 0x0d1422d9,
    0x43018308, 0x0b230564, 0x83070a09, 0x831d8701, 0x10132207, 0x2079820c, 0x27208309, 0x0b0d0c06, 0x0c0f1212, 0x0c21d782, 0x0883430c, 0x100d0629,
    0x110e100a, 0x820d0d06, 0x0f0b2727, 0x0d0c080f, 0x07820f12, 0x0a0b0c26, 0x100b100c, 0x0c250f82, 0x0c060c09, 0x251e820c, 0x0c0c0909, 0x26820a06,
    0x0d0c0a24, 0x16820a0c, 0x1f820f20, 0x0c201a82, 0xdc822f82, 0x06080829, 0x0c0f1413, 0x820d0f0c, 0x0b0e222c, 0x27448312, 0x0f0f120e, 0x0a0d0c0f,
    0x0f284a82, 0x0e14140e, 0x150d0d11, 0x0b244982, 0x0f0b0c08, 0x0a214d82, 0x262f820c, 0x090a0c0c, 0x430b0f0b, 0x0a2d0683, 0x0c0b0b12, 0x05090a08,
    0x12110505, 0x236d820c, 0x1013080a, 0x0c250183, 0x15150b0b, 0x08834309, 0x19120923, 0x05834304, 0x100c0c2a, 0x150b110c, 0x100d0f11, 0x0c200082,
    0xb6835284, 0x820c0c21, 0x050c2253, 0x0530450b, 0x07072208, 0x0b150b07, 0x04050715, 0x0204060c, 0x15150000, 0x0c0d0405, 0x0d131211, 0x0807100b,
    0x0c0f1313, 0x06834310, 0x14318a82, 0x130c0d11, 0x120b0d0f, 0x140d0e0f, 0x10090b11, 0x28a78210, 0x1a0b0c0b, 0x130d1016, 0x221d8211, 0x820c0d0a,
    0x14152200, 0x82058210, 0x830820bf, 0x090b352a, 0x0a0c0b0d, 0x0d0e0a0c, 0x0e110c0f, 0x0d101216, 0x090a0a0d, 0x0b238482, 0x82110b0b, 0x820e2048,
    0x0e112499, 0x82080e11, 0x830b2055, 0x0c0f250c, 0x0f120c0e, 0x3d823b82, 0x0b0b1223, 0x2501820f, 0x090b0f12, 0xc0410a0b, 0x0a0d2309, 0x01830b0c,
    0x0b0c0e26, 0x0a101108, 0x0b202b82, 0x1229d482, 0x0c101212, 0x1512140a, 0x24428212, 0x0e090b0e, 0x1581430c, 0xa3460d20, 0x23088708, 0x05080508,
    0x09915d89, 0x8305f64b, 0x43778505, 0x16270c83, 0x0b000d1a, 0x83080606, 0x070422b5, 0x15834307, 0x830d1321, 0x0f0b28ff, 0x0d06080f, 0x8310130b,
    0x38da824a, 0x0c0c130d, 0x0708070c, 0x0c0d090c, 0x0c0d0a0d, 0x060d0b07, 0x14060b06, 0x2e00820d, 0x0d070a09, 0x0b0b100b, 0x080c080a, 0x8206060c,
    0x0c0c3a28, 0x07120d0b, 0x12070c0b, 0x070c090b, 0x0e0d0d07, 0x08070506, 0x1010100b, 0x822f8209, 0x0d132102, 0x08202583, 0x0f200082, 0x02821482,
    0x0f100c22, 0x0c210082, 0x2317840d, 0x0a120c0c, 0x06201f83, 0x2f850082, 0x08837482, 0x4308f944, 0x0d240581, 0x0f0d0f0a, 0x2f833186, 0x860b0f21,
    0x63158201, 0x06210833, 0x2293820d, 0x510b0b0d, 0x0b230578, 0x41060b07, 0x0f200523, 0x10250685, 0x0d15140d, 0x44018309, 0x072008ee, 0x07202482,
    0x8307ca44, 0x10132407, 0x450c0b0c, 0x062a054b, 0x130c0d0c, 0x0b0d1012, 0x93820d0a, 0x040d0622, 0x062a9f84, 0x110a110d, 0x0d07110f, 0x8e820c0e,
    0x08100f24, 0x33820d0d, 0x0d0f1022, 0x10253782, 0x0810100c, 0x20b0820c, 0x27f78207, 0x0a0a0d0b, 0x0b070d0d, 0x0a22c882, 0xc5840e0d, 0x1a831f83,
    0x0f0c102c, 0x080b0d0c, 0x15140608, 0xc0820d0f, 0x0e224b82, 0x3c82120c, 0x130f0d23, 0x224a820f, 0x820d0b0d, 0x160f3622, 0x0e120f16, 0x0c0d170d,
    0x0c090c0d, 0x0d0a100c, 0x100c0b0d, 0x3800820d, 0x100b0a0a, 0x140d0d0b, 0x0c110e14, 0x0c0c130a, 0x0a0a090d, 0x12060606, 0x22fb8213, 0x43090a0d,
    0x20080883, 0x04091616, 0x08040504, 0x0b0b0808, 0x041a1208, 0x0b070708, 0x0c0c0803, 0x0b120c11, 0x0e101116, 0x20008211, 0x217f820d, 0x83430c0c,
    0x215a8205, 0x8343060c, 0x0b16240a, 0x43060716, 0x16340683, 0x0d040616, 0x1413120c, 0x07110c0d, 0x10141409, 0x000e100d, 0x0c270083, 0x160d0c10,
    0x820d0e11, 0x130c2b11, 0x140e0e11, 0x100a0c12, 0xac821010, 0x1a0b0d29, 0x150e1117, 0x82121611, 0x820c20fd, 0x1516215c, 0x0d22be84, 0xee82090b,
    0x0a0c1022, 0x20050b43, 0x2881820e, 0x13170f11, 0x0a0d0e10, 0x05154a0b, 0x0f120b22, 0x28059441, 0x0e120e12, 0x0f101208, 0x2001820c, 0x059f410d,
    0x0c0d0826, 0x12130c0d, 0x1482b382, 0x45821220, 0x0d206e82, 0x8207e041, 0x0d0b2168, 0x0f3e0182, 0x12090c0d, 0x0d090b11, 0x0d0b0c0c, 0x1413140d,
    0x160b0d11, 0x10131612, 0x0c0f0f0d, 0xc54d0f0a, 0x0b024908, 0x0c200b83, 0x0822008e, 0x43420806, 0x096d4306, 0x8e830987, 0x870e1021, 0x05834301,
    0x20059644, 0x36008200, 0x17050505, 0x0c000e1c, 0x0f080606, 0x0410130d, 0x0d0d0707, 0x43060706, 0x0d200614, 0x06210082, 0x38048206, 0x0e0e140a,
    0x0b0c100e, 0x06081010, 0x11140b0d, 0x0e110d11, 0x0d100c0c, 0x21b98214, 0x83430907, 0x0d0b2b05, 0x0e0c080c, 0x060b0606, 0x32820e14, 0x080a0925,
    0x43110b0e, 0x0d200583, 0x0d204484, 0x1335e482, 0x070d0b08, 0x0d0a0c13, 0x0e0d0808, 0x0805060f, 0x11110b08, 0x05f74d11, 0x82140e21, 0x0c0c2253,
    0x20008208, 0x05a87d10, 0x10110d22, 0x0c210082, 0x2317840d, 0x0b130c0c, 0x20088343, 0x8361820e, 0x820e2002, 0x0d0b2300, 0x484a0e0b, 0x460b2005,
    0xfa8305f3, 0x21092141, 0x01860c10, 0x0e100e22, 0x20098343, 0x0c83430e, 0x060b0824, 0x01830e11, 0x04821020, 0xdd820d20, 0x15140d24, 0x0183090e,
    0x2108064c, 0x01820c08, 0x23094841, 0x11140e10, 0x20088343, 0x23a18207, 0x0d111314, 0x0d22d782, 0x83430d0d, 0x060e3206, 0x120b120e, 0x0e08120f,
    0x0c0d0c0e, 0x0811100c, 0x2133830d, 0x0c821011, 0x0d120c3c, 0x0c081112, 0x080e0a0d, 0x0b0e0d0e, 0x0e0a0a0d, 0x0c0b080d, 0x0d0b0b0e, 0x0e820d0f,
    0x0c100e25, 0x82081011, 0x2bba831a, 0x08080c0e, 0x10161506, 0x0e100d0d, 0x0f206882, 0x11273c82, 0x140f0d11, 0x82101110, 0x120d2b0e, 0x160f100d,
    0x0e130f16, 0x6882180e, 0x0d090d24, 0xab4a100c, 0x372c8205, 0x0b0a0b0d, 0x0d0e0b10, 0x12101414, 0x0c130b0d, 0x0b090e0c, 0x0606060a, 0x0b26dd82,
    0x090b0e0b, 0x01831114, 0x1721c782, 0x07834317, 0x0a0a0a36, 0x08041b12, 0x030b0808, 0x110d0d08, 0x170c120d, 0x110e1112, 0x7f840082, 0x42100d21,
    0x0e24051b, 0x0c060d0e, 0x8205ac41, 0x170c352b, 0x0608170c, 0x05060d04, 0x17000002, 0x0e040617, 0x1414120c, 0x08280482, 0x11151509, 0x000f110d,
    0x0c340083, 0x160e0c11, 0x150d0e12, 0x140c0e10, 0x160e1011, 0x120b0d13, 0x0d2fca82, 0x1c0b0d0b, 0x150f1218, 0x0e131612, 0x820d0e0b, 0x16172200,
    0x27078411, 0x0d0e090b, 0x0b0d1012, 0x2482d982, 0x100d0f30, 0x1810120e, 0x0e0e1114, 0x0c0a0c0b, 0x13820c0b, 0x0f101323, 0x2617830e, 0x0f130f13,
    0x42101208, 0x0f2607ee, 0x0811140d, 0x68820c0e, 0x1023f582, 0x830c100c, 0x0b0d2145, 0x0e20c982, 0x0d238f82, 0x820e0d11, 0x0783433b, 0x46121321,
    0x0d2c06f1, 0x13151414, 0x14160c0e, 0x0d111517, 0x0b224b82, 0x43830d0f, 0x82430393, 0x080c240e, 0x85060806, 0x25059159, 0x0e100e10, 0x01870f11,
    0x20128343, 0x05834318, 0x82100a21, 0x070524b5, 0x820d0d07, 0x1083434c, 0x0f152008, 0x0d100e0f, 0x0911110c, 0x150c0e07, 0x120e1212, 0x110d0d0e,
    0x0d0d150e, 0x0709070d, 0x820e0a0d, 0x0d0e2ad3, 0x060e0d08, 0x16060c06, 0x2b00820e, 0x0e080b0a, 0x0c0c120c, 0x090d090b, 0x3a068343, 0x140e0c0d,
    0x080d0c08, 0x0d0a0c14, 0x0e0e0808, 0x08050610, 0x12120c08, 0x840f0a12, 0x0e142100, 0x0d214e82, 0x21008209, 0x00841210, 0x11120d22, 0x0d210082,
    0x2317840e, 0x0b140d0d, 0x21051444, 0x5f820606, 0xba510283, 0x0e0c2205, 0x050a450c, 0x21058143, 0xf2830b0e, 0x8206a343, 0x08124106, 0x0e110e22,
    0x27094e6b, 0x06070c0f, 0x0c0c0c0e, 0x0382ae82, 0x060c0822, 0x1222d283, 0x0685100e, 0x150e1223, 0x055a4f16, 0x21088a48, 0x01820d08, 0x43821120,
    0x15240387, 0x0d0c0d12, 0x07291e85, 0x140d0f0d, 0x0d0e1214, 0x24aa820b, 0x040e060e, 0x3300820e, 0x120e060f, 0x1310130b, 0x0d0f0f08, 0x110d0d0e,
    0x0f0e0912, 0x12213382, 0x260c8211, 0x130d130d, 0x820d0912, 0x820820b0, 0x0e0c2d29, 0x0e0e0b0b, 0x0e0c0c08, 0x0f0e0b0c, 0x1023c584, 0x8312120d,
    0x0d12351a, 0x0d0e0d11, 0x16070909, 0x0e0e1117, 0x0f0e0f11, 0x140d100d, 0x0e341c82, 0x12111510, 0x0d0e0e11, 0x110d130e, 0x10171710, 0x190e0f14,
    0x0d290d82, 0x100d0d0a, 0x0c0e0e0b, 0x281c820d, 0x0a0b0e0e, 0x0e0c100c, 0x0583430e, 0x0d0d1426, 0x0b0b0a0e, 0x83058343, 0x150a226d, 0x08018312,
    0x0c0c0d23, 0x040a1818, 0x09040504, 0x0b0b0909, 0x051c120a, 0x0c08080a, 0x0d0d0803, 0x0c130d12, 0x0f121318, 0x82008212, 0x22ba827f, 0x820d0911,
    0x430f2000, 0x18220e83, 0x8343180c, 0x18183108, 0x0d0e0406, 0x0f161514, 0x0a08130d, 0x0e121616, 0x82068343, 0x170e334d, 0x150e0f13, 0x150d0f11,
    0x170e1112, 0x130b0d14, 0xac821212, 0x1c0c0e32, 0x160f1319, 0x0e131713, 0x0e0d0f0b, 0x17180e0e, 0x07821682, 0x0f0a0c26, 0x0d10140d, 0x2b060b43,
    0x0e110e10, 0x15191012, 0x0b0e0f12, 0x0c21e882, 0x2301820d, 0x0e101114, 0x13291783, 0x090f130f, 0x0d101014, 0x22f98210, 0x82100e11, 0x0f092265,
    0x823d820d, 0x0d1122f5, 0x21458411, 0xde410b0d, 0x455d8207, 0x103906b8, 0x140a0d0e, 0x0e0a0c12, 0x0e0c0d0d, 0x1515150e, 0x170c0d13, 0x11151814,
    0x21a5820e, 0xc54d100b, 0x0b024908, 0x60420b83, 0x22098509, 0x42090609, 0x63890643, 0x4b820987, 0x470a8343, 0x1a480551, 0x82002005, 0x05052200,
    0x20058205, 0x22038603, 0x8201001c, 0x02002409, 0x830300d8, 0xe2042509, 0xbc020400, 0x9c081182, 0x00800090, 0x00100006, 0x017f017e, 0x01a10192,
    0x01f001b0, 0x021902ff, 0x02c702bc, 0x02dd02c9, 0x030103f3, 0x03090303, 0x0323030f, 0x038c038a, 0x03ce03a1, 0x04d603d2, 0x044f040d, 0x0486045f,
    0x1e130591, 0x1e3f1e01, 0x1ef11e85, 0x204d1ff9, 0x2015200b, 0x2022201e, 0x20302026, 0x203a2033, 0x2044203c, 0x20a4207f, 0x21ac20a7, 0x21132105,
    0x21222116, 0x212e2126, 0x2202225e, 0x220f2206, 0x221a2212, 0x222b221e, 0x22602248, 0xfbca2565, 0xfffffe04, 0x00fffffd, 0x00200000, 0x229182a0,
    0x82af01a0, 0x02fa2291, 0x20918218, 0x209182c6, 0x209182d8, 0x20918800, 0x24918284, 0x03a3038e, 0x349182d1, 0x040e0400, 0x04600450, 0x1e920488,
    0x1e3e1e00, 0x1ea01e80, 0x269182f2, 0x20132000, 0x84202017, 0x20322291, 0x20918639, 0x209182a3, 0x20918cab, 0x2091865b, 0x20918a11, 0x20918264,
    0x08918201, 0xfffffc3a, 0xc2ffe3ff, 0xbf00b0ff, 0x6100b200, 0x31ff49ff, 0x85fe96ff, 0x76fe84fe, 0x63ff68ff, 0x5dff62ff, 0x44ff6700, 0xcffdd0fd,
    0xcdfdcefd, 0x7ffe82fe, 0x9afd0000, 0x0cfe0000, 0x55080382, 0xe458e409, 0xe47ae318, 0xe300007d, 0xe142e20d, 0xe1eee1ef, 0xe1eae1ed, 0xe1e0e1e1,
    0xe1dae1db, 0xe199e1d3, 0x0074e176, 0xe118e100, 0xe009e10b, 0xe0fbe0fe, 0xe0c8e0f4, 0xe022e025, 0xe019e01a, 0xe00fe012, 0xdfe7df03, 0xdccddfd0,
    0x03000069, 0x0053024f, 0x00af0001, 0x30826020, 0x03827820, 0x03829420, 0x9c200287, 0x07940887, 0x15948e20, 0x6c20148f, 0x6f081085, 0x9c016802,
    0x9e019d01, 0xa0019f01, 0xa201a101, 0xa401a301, 0xa601a501, 0x6902a701, 0xea016a02, 0xec01eb01, 0xee01ed01, 0xf001ef01, 0xf201f101, 0xf401f301,
    0x6b02f501, 0xf701f601, 0x94029302, 0x96029502, 0x98029702, 0x9a029902, 0xf901f801, 0x01020002, 0x70036f03, 0x72037103, 0x74037303, 0x1c027503,
    0x35023402, 0x5e025d02, 0x0a020600, 0x01217583, 0x10074100, 0x02000122, 0x1c830182, 0x9d000221, 0x05414100, 0x0003bc08, 0x00050004, 0x00070006,
    0x00090008, 0x000b000a, 0x000d000c, 0x000f000e, 0x00110010, 0x00130012, 0x00150014, 0x00170016, 0x00190018, 0x001b001a, 0x001d001c, 0x001f001e,
    0x00210020, 0x00230022, 0x00250024, 0x00270026, 0x00290028, 0x002b002a, 0x002d002c, 0x002f002e, 0x00310030, 0x00330032, 0x00350034, 0x00370036,
    0x00390038, 0x003b003a, 0x003d003c, 0x003f003e, 0x00410040, 0x00430042, 0x00450044, 0x00470046, 0x00490048, 0x004b004a, 0x004d004c, 0x004f004e,
    0x00510050, 0x00530052, 0x00550054, 0x00570056, 0x00590058, 0x005b005a, 0x005d005c, 0x005f005e, 0x82610060, 0x86de08e0, 0x89008700, 0x93008b00,
    0x9e009800, 0xa200a300, 0xa600a400, 0xa700a500, 0xab00a900, 0xac00aa00, 0xaf00ad00, 0xb000ae00, 0xb300b100, 0xb400b500, 0xb800b600, 0xbc00b700,
    0xbd00bb00, 0x0d02be00, 0x64007200, 0x69006500, 0x78000f02, 0x7000a100, 0x20026b00, 0x6a007600, 0x88003002, 0x2d029a00, 0x31027300, 0x67003202,
    0x27027700, 0x29022a02, 0x2e028d01, 0x7c006c00, 0xa8002102, 0x8100ba00, 0x6e006300, 0x42012c02, 0x28022f02, 0x7d006d00, 0x62001002, 0x85008200,
    0x14019700, 0x02021501, 0x0a020302, 0x06020b02, 0xb9000702, 0xc1003302, 0x17023a01, 0x14021c02, 0x34021502, 0x0e023502, 0x08027900, 0x11020c02,
    0x8c008400, 0x8d008300, 0x8f008a00, 0x91009000, 0x95008e00, 0xe1829600, 0x9c00943c, 0x9b009d00, 0x4b01f300, 0x71005201, 0x4f014e01, 0x7a005001,
    0x51015301, 0x04104c01, 0x08bc02c5, 0x45400057, 0x54555859, 0x50515253, 0x4c4d4e4f, 0x48494a4b, 0x44454647, 0x40414243, 0x3c3d3e3f, 0x38393a3b,
    0x31353637, 0x2d2e2f30, 0x2627282c, 0x22232425, 0x14181f21, 0x0e0f1011, 0x090a0b0d, 0x05060708, 0x01020304, 0x23452c00, 0xb0206046, 0x04b06026,
    0x48482326, 0x210f832d, 0x10826123, 0x108a6120, 0x20b06022, 0x46201282, 0xb021238d, 0x20378320, 0x8c1a8261, 0x82402029, 0x8e662029, 0x85402029,
    0x88402029, 0x10013553, 0x3c003c20, 0x45202c2d, 0xcdb02023, 0xb8202344, 0x58515a01, 0x8d260b82, 0x20592344, 0x0b84edb0, 0x0b844d20, 0x84260421,
    0x820d200c, 0x2121210c, 0x23083182, 0x68184520, 0x01b02044, 0xb0452060, 0x8a687646, 0x2d446045, 0x0bb1012c, 0x4323430a, 0x2c2d0a65, 0x0b0ab100,
    0x0b200a82, 0xb0280982, 0xb1702328, 0x013e2801, 0x02280884, 0xb13a4528, 0x0d080002, 0x45364482, 0x452503b0, 0x50b06461, 0x44455851, 0x5921211b,
    0xb0492c2d, 0x4982230e, 0x00215582, 0x24528443, 0xb04306b0, 0x22528407, 0x82b06920, 0x8b0037ba, 0xc02cb120, 0x10b88c8a, 0x2b606200, 0x6423640c,
    0xb0585c61, 0x3b826103, 0x45038a3c, 0xb0878a8a, 0x29b02b11, 0x29b04423, 0x2d18e47a, 0xb065452c, 0x4544232c, 0x55832bb0, 0x88524b21, 0x894b2067,
    0xb0012972, 0x23102505, 0x00f58a20, 0x2322ce82, 0xc782eced, 0x6120118a, 0x06241186, 0x00f51025, 0x24081c83, 0x60462346, 0x23468a8a, 0x608a4620,
    0xffb8618a, 0x20236280, 0xb18a2310, 0x708a0c0c, 0xb0206045, 0xb0585000, 0x2c178201, 0xb01b8bba, 0xb0598c46, 0x01686010, 0x2eec863a, 0xb04b5246,
    0x585b5113, 0x462502b0, 0x82616820, 0x260282fe, 0x3821233f, 0x8211211b, 0x22f582c0, 0x82462503, 0x2b1e953f, 0x4307b000, 0x0b4306b0, 0x21212c2d,
    0x8b24f883, 0x620040b8, 0xb0230c82, 0x85585180, 0x00202c0f, 0x00b21b62, 0x592b2f40, 0x836002b0, 0x87c02019, 0x55152119, 0x80201983, 0x3e881987,
    0x23602d08, 0x4b2c2d21, 0xb08a5853, 0x64492504, 0xb0694523, 0xb0618b40, 0x20b06280, 0x0eb06a61, 0x10234423, 0x1bf60eb0, 0x128a2321, 0x2f392011,
    0x2b82a382, 0xb4822020, 0x69644928, 0x2605b020, 0x358306b0, 0xb022308b, 0x32832604, 0x04828a20, 0x82442321, 0x2344833b, 0x1bed0eb0, 0x26256082,
    0x39201211, 0x83468223, 0x23452347, 0x02866045, 0x18687622, 0x20307182, 0x48b02c2d, 0x202c2d2b, 0x5400b045, 0x4440b058, 0x40210882, 0x06164261,
    0x30b14523, 0x2631822f, 0x01b06061, 0x82446960, 0x585129b1, 0x70232fb0, 0x422314b0, 0x22053742, 0x8358514b, 0x69452396, 0x32845853, 0x45271585,
    0xb04314b0, 0x86636000, 0x2fb02235, 0x253b8245, 0x45202345, 0x0884608a, 0x06834520, 0x51234b33, 0x3300b958, 0x34b1e0ff, 0x33b31b20, 0x59003400,
    0x081d8244, 0x4316b02c, 0x2603b058, 0x64588a45, 0x601fb066, 0x20b0641b, 0x58206660, 0x40b0211b, 0x6101b059, 0x65582359, 0x2329b059, 0xb0102344,
    0x6e82e029, 0x21212123, 0x2bc28259, 0x58544302, 0x4b23534b, 0x38585a51, 0x59201582, 0x18831984, 0x04224e83, 0x468e4525, 0x1b582322, 0xb0304685,
    0x08b02505, 0x58200825, 0x59031b02, 0x102504b0, 0x20211082, 0x22088246, 0x823c4223, 0x07b02305, 0x03820825, 0x06b01023, 0x82158425, 0x241882d1,
    0x1b015820, 0x822d8700, 0x29b02586, 0x44654520, 0x0f832786, 0x0c82548c, 0x43250323, 0x244d8748, 0x03b02506, 0x24478225, 0x211b4843, 0x83bd8259,
    0x2c2d2202, 0x201e8202, 0x21628420, 0x82824223, 0x23820820, 0x87484521, 0x2503221a, 0x221e8220, 0x8202b008, 0x08138246, 0x452c2d24, 0x18452023,
    0x5000b020, 0x65235820, 0x68235923, 0x5040b020, 0x40b02158, 0x65582359, 0x44608a59, 0x0c412c2d, 0x45202106, 0x95410d82, 0x544b2205, 0x410d8b58,
    0x2d240a2c, 0x2100b02c, 0x38201e82, 0xb0272885, 0x58544302, 0x412b46b0, 0x0f840843, 0x0f844720, 0x21076b41, 0x1e8e48b0, 0x0f844920, 0x202b1e82,
    0x4b23088a, 0x514b8a53, 0x8623585a, 0x82002050, 0xb04924b9, 0x82585300, 0x113821a6, 0x2d2ef682, 0x2346012c, 0x46236046, 0x10202361, 0xcf434620,
    0xb18a3505, 0x708a4040, 0x3a686045, 0x8a202c2d, 0x8a644923, 0x3c585323, 0x4b262d84, 0x1b7d5852, 0xa782597a, 0x00122a08, 0x544b014b, 0xb12c2d42,
    0xb1420002, 0x51880123, 0x880140b1, 0xb9585a53, 0x20000010, 0xb2585488, 0x43020102, 0xb1594260, 0x251b8224, 0x0020b958, 0x15844000, 0x15830220,
    0x22831483, 0x0c832020, 0x52204983, 0x08202f82, 0x1b252f84, 0x000040b9, 0x202a8480, 0x84108404, 0xb863230f, 0x13840001, 0x13822485, 0x63000124,
    0x138502b8, 0x27871020, 0x13820220, 0x13850420, 0x13844020, 0x00825920, 0x452c2d38, 0x4b236818, 0x20235851, 0xb0642045, 0x7c585040, 0x608a6859,
    0xc5824459, 0xb0160024, 0x02822502, 0x01b00137, 0xb0003e23, 0xb13e2302, 0x0c060201, 0x65230ab0, 0x230bb042, 0x20178342, 0x2017833f, 0x2017853f,
    0x31178306, 0xb0422307, 0x2d011601, 0x108a7a2c, 0x18f52345, 0xdb82002d, 0x09105c08, 0x1fff03f8, 0xf79ff78f, 0x01f37f02, 0xb801f260, 0x2b40e8ff,
    0x46100ceb, 0x55dd33df, 0x55dcffde, 0xdd01dd30, 0xdc550301, 0x301ffa03, 0xc06f01c2, 0xfc02c0ef, 0x301f18b6, 0xb76001b7, 0xb802b780, 0x3840c0ff,
    0x46130fb7, 0x1f01b1e7, 0x3faf2faf, 0xaf4f03af, 0xaf6faf5f, 0x82af4003, 0xac3a0815, 0x1f1f1851, 0x029c5f9c, 0x03019be0, 0x1f019a2b, 0x9a90019a,
    0x73029aa0, 0x029a839a, 0xeaffb805, 0x099a1940, 0x97af460b, 0x030297bf, 0x1f01962b, 0x969f0196, 0x7c0296af, 0x1d840196, 0x82968521, 0x2f59081d,
    0x4f923f92, 0x92400392, 0x2f460f0c, 0x919f0191, 0x18868701, 0x507c401f, 0x1003027c, 0x30742074, 0x74020374, 0x0174f201, 0xff016f0a, 0x6fa9016f,
    0x016f9701, 0x6f856f75, 0x016f4b02, 0xff016e0a, 0x6ea9016e, 0x016e9701, 0x06016e4b, 0x5518011a, 0x1fff1319, 0x1fff0407, 0x08fb8206, 0x01673f23,
    0x672f671f, 0x67ff673f, 0x50664004, 0xb066a066, 0x653f0466, 0xaf650f01, 0xa0050265, 0x0264e064, 0x08e48303, 0x06644f4e, 0x5f61460a, 0x5f601f2b,
    0x505f1f47, 0x5bf71f22, 0x015bec01, 0x5b845b54, 0x015b4902, 0xf9015b3b, 0x5aef015a, 0x015a6b01, 0x3b015a4b, 0x1306015a, 0x05551233, 0x04550301,
    0x1f550333, 0x030f0103, 0x03af033f, 0x1f570f03, 0x03572f57, 0xb32b5383, 0x46151256, 0xb3e0ffb8, 0x820b0756, 0xb3c02207, 0x080f8454, 0x6d40c087,
    0x460b0654, 0x1f2b5052, 0x504f503f, 0xfa03505f, 0x48ef0148, 0x01488701, 0x56014865, 0x483a0148, 0x0147fa01, 0x870147ef, 0x473b0147, 0x1b1c0601,
    0x33161fff, 0x01115515, 0x3310550f, 0x0102550f, 0x47015500, 0xfafb5500, 0x1bfa1f2b, 0x0f0f1f12, 0xcf0f1f01, 0x0f0f020f, 0x06020fff, 0x007f006f,
    0x00ef00af, 0x01001004, 0x05011680, 0x9001b801, 0x2b5354b1, 0x07b84b2b, 0xb04b52ff, 0xb05b5006, 0x25b08801, 0x08058353, 0x5a514022, 0xb08806b0,
    0x5b5a5500, 0x0101b158, 0x8d85598e, 0x1d42008d, 0x5332b04b, 0x1d60b058, 0x64b04b59, 0x40200882, 0x80200883, 0x102d0882, 0x0016b11d, 0x73735942,
    0x7574735e, 0x2200862b, 0x88735f01, 0x73002300, 0x1683012b, 0x00735f24, 0x08827473, 0x0f831b8c, 0x835f2b21, 0x7373233b, 0x0d820074, 0x1e852b20,
    0x3e847420, 0x31827420, 0x10827420, 0x07822b20, 0x01732b22, 0x73242882, 0x735f7474, 0x00200785, 0x01276382, 0x732b002b, 0x83730174, 0x822b2005,
    0x2b732206, 0x2102822b, 0x3d822b01, 0x182b0034, 0x0014065e, 0x054e000b, 0x001700b6, 0x05b60575, 0x008c00cd, 0x004a0429, 0x008f0014, 0x83ecff00,
    0x22058916, 0x83fe14fe, 0x2103c810, 0x00840008, 0xb600ac24, 0x0982bc00, 0x0382d520, 0x552c0283, 0x97008300, 0x7d009f00, 0xae00e500, 0x71220182,
    0x16837100, 0x00ba0023, 0x830382c5, 0x82a4200a, 0x838c201d, 0xc7002108, 0x7d200182, 0x0c842982, 0xb0240486, 0x8a00b900, 0x9b220b84, 0xc782a600,
    0x0b847720, 0x96200485, 0x05840685, 0x6e006929, 0xb4009000, 0x8700c100, 0x00002e79, 0x006f0066, 0x00960078, 0x01d500c0, 0x24258447, 0x01fe0000,
    0x2079823a, 0x22078278, 0x86f60116, 0x20068f13, 0x221082ee, 0x82880096, 0x009633ad, 0x000c0189, 0x00180196, 0x001d0300, 0x005a0294, 0x75830382,
    0x8400a821, 0x790231b1, 0xb400d900, 0x00000a01, 0x6d008301, 0xa0007f00, 0x00203982, 0x88200982, 0x048b0784, 0x1b849320, 0x89008222, 0x05291489,
    0x0094fcb6, 0x00efff11, 0x83d78283, 0x006d2216, 0x8606837b, 0x01bc2403, 0x845403aa, 0x00bc260b, 0x01d701b6, 0x300b8295, 0x00000196, 0xfeb605ae,
    0xfe6ffebc, 0x026f0083, 0x211382ad, 0x0185002a, 0x006fba08, 0x012901a1, 0x037102e2, 0x034d0329, 0x03ac037c, 0x040f04e2, 0x045b0444, 0x05b40495,
    0x053f0506, 0x06120694, 0x07cc0665, 0x0867073f, 0x08820811, 0x093d09da, 0x09bb0979, 0x0b6a0af7, 0x0ca00b34, 0x0c740c17, 0x0dec0cb3, 0x0d970d39,
    0x0e100ecd, 0x0e970e49, 0x0f2b0fb7, 0x10d50f7c, 0x108b1022, 0x116611fc, 0x12e511a7, 0x13ee1238, 0x139e134d, 0x14f713d1, 0x143b1417, 0x14701459,
    0x15081595, 0x16ae1569, 0x166b160e, 0x17a217ce, 0x181418e3, 0x18af185f, 0x193919c8, 0x1ac01977, 0x1a831a22, 0x1b391bc9, 0x1ccf1b8e, 0x1dd41c27,
    0x1ece1d65, 0x1e751e1b, 0x1ff51e99, 0x0b018248, 0xf41f90bc, 0x01216a20, 0xa4217421, 0xa1225d22, 0xb4234a23, 0x35240824, 0x0c253d24, 0x7e252325,
    0x0a26ba25, 0xa4267f26, 0x2b27ee26, 0xab276527, 0x2a28e227, 0xa3287a28, 0xf728c828, 0x85296d29, 0xb4299c29, 0xe429cb29, 0x722a092a, 0x9d2a852a,
    0xcc2ab42a, 0xfd2ae52a, 0x2b2b142b, 0xa82b442b, 0xd72bbf2b, 0x052cee2b, 0x362c1d2c, 0x1c2d9b2c, 0x4b2d342d, 0x7c2d632d, 0xdd2d932d, 0x8f2e782e,
    0xbb2ea52e, 0xe92ed12e, 0xb12f012f, 0xdb2fc42f, 0x0730f12f, 0x37301f30, 0x65304e30, 0x0e317e30, 0x3b312431, 0x68315131, 0x98317f31, 0x82320932,
    0xaf329932, 0xde32c532, 0x5933f432, 0x89337133, 0xb6339f33, 0xe333cc33, 0x17340034, 0x46342f34, 0x75345e34, 0xa5348e34, 0xd534bd34, 0xf034e834,
    0x80356935, 0xad359635, 0xda35c335, 0x0536f135, 0x3d362636, 0x6a365336, 0x97368036, 0xc536ae36, 0xf036dd36, 0x1e370637, 0x8c373b37, 0xfe37e737,
    0x2c381538, 0x5a384338, 0x84387138, 0xaf389838, 0xf138c838, 0x2c391539, 0x56394339, 0xb2396939, 0xe739ca39, 0x0e3afa39, 0x3e3a263a, 0x743a513a,
    0x0e3bc13a, 0x3b3b253b, 0x623b4f3b, 0x903b793b, 0x133cb23b, 0x833c6c3c, 0xb03c993c, 0xe03cc73c, 0x693df83c, 0x0f3ef73d, 0x383e253e, 0x643e4c3e,
    0x933e7c3e, 0xc03ea93e, 0xea3ed63e, 0x143ffd3e, 0x3d3f2a3f, 0x683f513f, 0xd13f7a3f, 0x53403b40, 0x81406940, 0xae409740, 0xdd40c440, 0x0e41f540,
    0x39412641, 0x63414c41, 0x91417a41, 0xc041a741, 0xed41d741, 0x1b420442, 0x48423242, 0xdf427b42, 0x9644c143, 0xc544ae44, 0xf244dc44, 0x18450545,
    0x84454e45, 0xd7459c45, 0x4e46fe45, 0xc2467b46, 0x32470547, 0xbc47a347, 0x1b48f647, 0x82484148, 0xe748b348, 0x28490f49, 0x38493049, 0xb6496a49,
    0xc649be49, 0x3d4ace49, 0x4d4a454a, 0xa14a994a, 0xf64aa94a, 0x294bfe4a, 0x794b314b, 0x894b814b, 0x204c184c, 0x104d8e4c, 0x424d294d, 0x6e4d584d,
    0x9c4d844d, 0x234eb14d, 0x044fa54e, 0x08508c4f, 0xae506e50, 0x5e512051, 0xe2516651, 0x72523052, 0x1a531253, 0xc8536e53, 0x90543754, 0x1c55da54,
    0x2e569a55, 0x19578f56, 0x4b573257, 0x77576157, 0xae579557, 0x3f582858, 0xb258aa58, 0xd358ba58, 0x7259db58, 0x2f5ad159, 0x5d5a465a, 0xae5aa65a,
    0x095b015b, 0x845b115b, 0x195c8c5b, 0xfb5c9c5c, 0x5b5d135d, 0xc75dbf5d, 0xd75dcf5d, 0xe75ddf5d, 0xf75def5d, 0x6f5e675e, 0xac5e775e, 0x3b5ff35e,
    0xe75f915f, 0x8b603d60, 0x6561ee60, 0xea61e261, 0xd7626562, 0x6563ff62, 0xe2636d63, 0xa4646064, 0xf564bb64, 0xa5654065, 0xf365eb65, 0x24661c66,
    0x6b662c66, 0xf0667366, 0x3267f866, 0xbd677267, 0x73681668, 0x1f69d568, 0xfc698869, 0x6b6a536a, 0xf06ada6a, 0x546b4c6b, 0x756b5c6b, 0xf56b7d6b,
    0xae6c546c, 0xda6cc46c, 0x546d1f6d, 0x976d7f6d, 0xc56dae6d, 0xf66ddc6d, 0x286e106e, 0x5b6e406e, 0x916e766e, 0xe56eba6e, 0x446f116f, 0xce6f726f,
    0x94702a70, 0x7571ef70, 0x5d72b871, 0x32732a73, 0x6d733a73, 0xb473a273, 0x1574d273, 0xf7747074, 0x15768175, 0x4177c376, 0x7e78f777, 0xe9788678,
    0x41791279, 0x9b797079, 0x627a157a, 0xdb7a917a, 0x2d7b017b, 0x1a7cc97b, 0x1b7da37c, 0xa47d607d, 0x0f7ef07d, 0x707e2d7e, 0xc97ea37e, 0x137fee7e,
    0x9f7f567f, 0x5b80fc7f, 0x27818a80, 0x01999181, 0xdb82820a, 0x5a834e83, 0x0b846283, 0x24858884, 0x52853b85, 0x7a856685, 0xf485a785, 0x74864786,
    0x1587a086, 0xdb877c87, 0x63883e88, 0xcf888888, 0x2e890e89, 0x5e894689, 0x8c897589, 0xe48a298a, 0xda8b658b, 0xbc8c4b8c, 0xd38d408d, 0x178f6b8e,
    0x5c90b88f, 0xba910a91, 0x9393a492, 0xa3939b93, 0x70941094, 0x3895d094, 0x6c955295, 0x42962c96, 0x4697c896, 0x33994a98, 0xe69af999, 0x979b489b,
    0x9b9c569c, 0x0d9dde9c, 0x1d9e3e9d, 0x619fbb9e, 0x44a0e99f, 0x24a1a8a0, 0x11a2b2a1, 0xcfa261a2, 0xd1a333a3, 0x9ca486a4, 0x26a5b2a4, 0xffa591a5,
    0xd8a672a6, 0x8ea744a7, 0x2ea8e0a7, 0xd0a887a8, 0x89a91ea9, 0xadaafca9, 0x6bab57ab, 0xceab7fab, 0x25ac1dac, 0xf9ac88ac, 0x0fae68ad, 0x36afcfae,
    0xf3af94af, 0xb6b04fb0, 0x67b119b1, 0x2fb2adb1, 0x4cb3bfb2, 0xeeb3e6b3, 0x1cb405b4, 0xf9b48ab4, 0xc4b56cb5, 0x77b616b6, 0x17b7beb6, 0xbdb771b7,
    0xc1b841b8, 0xe0b8c9b8, 0x0fb9f6b8, 0x2fb927b9, 0x4eb937b9, 0xcab964b9, 0x42ba28ba, 0x74ba5bba, 0xa8ba8eba, 0x2cbbc2ba, 0xacbb94bb, 0xddbbc3bb,
    0x0fbcf6bb, 0x30bc28bc, 0x51bc38bc, 0x83bc69bc, 0xb5bc9dbc, 0xe5bccbbc, 0x16bdfdbc, 0x47bd2ebd, 0xa6bd5fbd, 0xfabde1bd, 0x25be13be, 0x50be37be,
    0xe7be66be, 0xe4bf9abf, 0x66c0ecbf, 0x8bc1f2c0, 0xa2c21dc2, 0xbbc328c3, 0x84c428c4, 0x4fc5ebc4, 0x26c6cbc5, 0x05c787c6, 0x9dc789c7, 0xc8c7b1c7,
    0xf6c7dfc7, 0x27c80dc8, 0x5ac840c8, 0x8dc873c8, 0xc0c8a6c8, 0xfdc8d9c8, 0x37c91ec9, 0x69c950c9, 0x9bc982c9, 0xcdc9b4c9, 0x08cae6c9, 0x40ca29ca,
    0x6eca57ca, 0x9dca85ca, 0xcdcab3ca, 0x00cbe6ca, 0x33cb19cb, 0x66cb4ccb, 0xa3cb7fcb, 0xdbcbc4cb, 0x0accf2cb, 0x39cc22cc, 0x68cc51cc, 0x98cc7fcc,
    0xcbccb2cc, 0xfecce5cc, 0x31cd18cd, 0x6dcd4bcd, 0xa8cd91cd, 0xd7cdbfcd, 0x06ceeecd, 0x36ce1ece, 0x65ce4dce, 0x94ce7dce, 0xc3ceacce, 0xf2cedace,
    0x1fcf07cf, 0x4acf34cf, 0x78cf60cf, 0xa5cf8dcf, 0xd5cfbdcf, 0x02d0ebcf, 0x30d019d0, 0x5ad046d0, 0xf6d09dd0, 0xbad14bd1, 0x7ad22fd2, 0x29d3c8d2,
    0xbfd392d3, 0x0fd4e7d3, 0x02000000, 0x0000c100, 0xb6050a04, 0x07000300, 0x0b402b00, 0x09020205, 0x80037004, 0x05e54a03, 0x09060927, 0x03040348,
    0x331e8207, 0x332f323f, 0x5d2b2f01, 0x2f331133, 0x13303133, 0x37211121, 0xc1300382, 0xb7fc4903, 0xfd790268, 0xfab60587, 0xe604684a, 0x93245382,
    0x9101e3ff, 0x30085384, 0xb93a0017, 0xf0ff0100, 0x140a1340, 0x80191048, 0xa0199019, 0x0e030419, 0x0202049a, 0xc0ffb804, 0x0a070a40, 0x09010448,
    0x0302139b, 0xf52f3f00, 0x086182ce, 0x102f3347, 0x315d32e1, 0x23012b30, 0x34033303, 0x3233023e, 0x1415021e, 0x2223020e, 0x5001022e, 0xf0df3379,
    0x1b2e2214, 0x14222f1a, 0x1a2f2214, 0x14222e1b, 0x18049e01, 0x3526b9fa, 0x210f0f21, 0x35252635, 0x22101022, 0x24dd8335, 0x02a60385, 0x3e8984b2,
    0x40370007, 0x07980423, 0x09d00907, 0x2f0209e0, 0x7f096f09, 0x98000309, 0x03100300, 0x82f003e0, 0x020624e4, 0x82030702, 0x82332085, 0x2f0130df,
    0x5d5de15d, 0xe12f3912, 0x03013031, 0x82210323, 0x4a012f03, 0x02297329, 0x2972292d, 0xf0fdb605, 0x03831002, 0x33246383, 0xf8040000, 0x70086382,
    0x001f001b, 0x03584099, 0x181a1a03, 0x071d1e16, 0x17170604, 0x01001906, 0xb1050404, 0x15211818, 0x04081c1f, 0x12141409, 0x040b0e0f, 0x500ab113,
    0x10100110, 0x50090c0c, 0x1c0a010a, 0x010d4801, 0x080cae0d, 0x001f0c04, 0x1911ae10, 0x113f1115, 0x11df114f, 0x0c110c03, 0x13170511, 0x00050a06,
    0x333f332f, 0x2f393912, 0x33115d2f, 0x32e11033, 0x22068432, 0x8232325d, 0x2db383ac, 0xe4105d2f, 0x11323917, 0x11391712, 0x0a832f33, 0x0b863320,
    0x832f3321, 0x152121c5, 0x1320c582, 0x35230384, 0x82211321, 0x03332303, 0x03821321, 0x82011521, 0x0331080e, 0x18013fd7, 0x9352cdfe, 0x52ddfe54,
    0xfefe4e90, 0xfe411d01, 0x522b01ee, 0x25015293, 0x01549054, 0x01ebfc06, 0xddfe4023, 0xb8fe7d03, 0x0154fe89, 0x270383ac, 0x89480189, 0x50feb001,
    0x80080383, 0x01b8fe89, 0x00030048, 0x0389ff7b, 0x001206d9, 0x0036002d, 0x40b4003f, 0x292f3433, 0x212f2901, 0x70062101, 0x3c013c2f, 0x1e011e2f,
    0x01072013, 0x2e0d0707, 0x000f246e, 0xff02001f, 0x00000100, 0x41000701, 0x6e370d0d, 0x190119e0, 0x40c0ffb8, 0x480b0830, 0x14143319, 0x133c3c29,
    0x3d08372e, 0x25217328, 0x0e401f21, 0x1f1f4811, 0x0121501e, 0x211f210f, 0x34210802, 0x0e087313, 0x05060608, 0x33348208, 0x480d0ab3, 0x2b2f0008,
    0x112f3333, 0x32e11033, 0x5d5d5e2f, 0x2b200b82, 0x12320c84, 0x39123939, 0x11333311, 0x2b2f0133, 0x2f33e15d, 0x1e82d610, 0xe1327125, 0x822f3911,
    0x335d2525, 0x5d32e15d, 0x28080182, 0x14013031, 0x1507020e, 0x2e223523, 0x1e352702, 0x2e113303, 0x3e343503, 0x33353702, 0x17161615, 0x27262607,
    0x07031e11, 0x081d8234, 0x363611d8, 0x021e1401, 0x06061117, 0x5d32d903, 0x328a5485, 0x20546066, 0x65605721, 0x5683592f, 0x815b312a, 0xa9648a4f,
    0x8c384243, 0x5b87584a, 0x2b14b02e, 0x5b5d3346, 0x281112fe, 0x53593142, 0x7246be01, 0xe60c3754, 0x1a1209dd, 0x2110ac11, 0xb201111a, 0x6e55421e,
    0x536f434a, 0xb0b40935, 0x911f2a05, 0xfe062919, 0x53421f5a, 0x3721486b, 0xfe12262d, 0x02620e8b, 0x2f3924a3, 0x71011126, 0x00005910, 0xff660005,
    0x053306ec, 0x000900cb, 0x0027001d, 0x003f003b, 0x103cb25d, 0xf0ffb83e, 0x3e3c3340, 0x14283e3c, 0xb532b41e, 0x4128b423, 0x0501410f, 0x00b50ab4,
    0x201410b4, 0x03143014, 0x3e063f14, 0x37b62518, 0x2db621b7, 0x0fb60319, 0x19b607b7, 0xe13f0007, 0x0384e1f4, 0x2f013f23, 0x220b825d, 0x82de105d,
    0x12113505, 0x2f2f3939, 0x30313838, 0x33161413, 0x23101132, 0x14050622, 0x20059643, 0x06a64335, 0x19990120, 0x0123013d, 0x9c5047fa, 0x0147509c,
    0x734a24c7, 0x4c70494f, 0x71492326, 0x4d714b4e, 0x86ac0127, 0x23c62119, 0x4a221982, 0x19864b70, 0x274c2708, 0xd5fc00ff, 0x042c039e, 0x01a5a502,
    0xa348014a, 0x76ac6ca5, 0xac763f3f, 0x75aa6c6c, 0xaa753e3e, 0xa4a54afd, 0x18844901, 0x1883ab20, 0x1887ab20, 0x92035608, 0xb6054afa, 0x00030000,
    0x05ecff6d, 0x00cd057d, 0x00210011, 0x40800053, 0x1718274d, 0x2c49044a, 0x470a4849, 0x42474136, 0x36014220, 0x1d423642, 0x473c3b05, 0x47004804,
    0x2c102c00, 0x2c2c0802, 0x01482022, 0x481d5548, 0x22202210, 0x41412202, 0x4f511231, 0x323b8416, 0x3b3c470f, 0x49310405, 0x31500f15, 0x3fe12f00,
    0x82391712, 0xe13f2b02, 0x012f3911, 0x10e15d2f, 0x09825dc6, 0xe15d5e23, 0x2b178211, 0x2f2f3939, 0x10e1105d, 0x113311e1, 0x31382482, 0x1e140130,
    0x033e1702, 0x022e3435, 0x13062223, 0x37023e32, 0x15030e01, 0x25211582, 0x420b8234, 0xf2440569, 0x07620807, 0x37033e01, 0x07030e33, 0x0e272301,
    0x2e222303, 0x10a60102, 0x3b243421, 0x191c3856, 0x562a422f, 0x623a8764, 0xfe204854, 0x3750347d, 0x6042231c, 0x4d287dfe, 0x3c1f476f, 0x5e321c2d,
    0x8353588a, 0x5432305b, 0x60013c6d, 0x1b222b1b, 0x290fb80a, 0x01274135, 0x31a8e115, 0x4e7c6c60, 0x3d73a769, 0xd9828d04, 0x25436608, 0x46403e23,
    0x2c3d2429, 0xaffb5919, 0x1f362817, 0x3f219701, 0x36385548, 0xf024415b, 0x56647a4e, 0x574d242a, 0x774b3963, 0x532b2b53, 0x6d404b77, 0xfe244f5d,
    0x443c1d8c, 0x6f422f4e, 0xfe295562, 0x472dacdb, 0x67351b31, 0x00010095, 0x01a60385, 0x00b6054a, 0x402a0003, 0xd005c01c, 0x0305e005, 0x056f052f,
    0x0b6c4502, 0x03020227, 0x333f0003, 0x0568452f, 0x23056445, 0x73294a01, 0x20065b45, 0x24478200, 0x02bcfe52, 0x2a47822b, 0x401a0013, 0xf20e060d,
    0x823ff009, 0xf90e2615, 0x3f00f805, 0x0837833f, 0x3132e438, 0x3e341330, 0x06333702, 0x1e141502, 0x2e231702, 0x4a245203, 0x8cac4e71, 0x6a472591,
    0x714eaa45, 0x3102244a, 0xd3e5f37d, 0x32fec15d, 0xe2ec77f4, 0xce5a5ed4, 0x5d83f0e1, 0x5d823d20, 0x5d841720, 0x0e401c22, 0x0b225d82, 0x5d82b0f0,
    0xf80e1524, 0x5e83f905, 0x5dde1023, 0x3f5f83e1, 0x020e1401, 0x033e2307, 0x27023435, 0x02031e33, 0x714b2417, 0x6a45aa4e, 0x8d902448, 0x4b714eac,
    0x7c315f82, 0x5acee1f0, 0xece2d45e, 0xce01f477, 0xe5d35dc1, 0x2ebd84f3, 0x14047702, 0x0e001406, 0x15402400, 0x8201101f, 0x800e39fc, 0x030e900e,
    0x061f0e08, 0x00060601, 0x323f0000, 0x2f015d2f, 0x5de55d5e, 0x3708ff83, 0x13051725, 0x27030307, 0x05372513, 0x2b980203, 0xfe1a8d01, 0xb0b2f586,
    0xfef2b89e, 0x87011d89, 0xfe14062b, 0x1cc16f77, 0x0160bafe, 0x609afe66, 0xc11c4601, 0x0089016f, 0x3008b582, 0x04060166, 0x00a20402, 0x4029000b,
    0x010d1018, 0x03aa0906, 0x200100ef, 0xa0006000, 0x09000300, 0x0306ad00, 0x333f00b3, 0x2f0132e1, 0xe1325d5d, 0x08708332, 0x21352120, 0x21113311,
    0x23112115, 0x7dfee901, 0x01968301, 0x967dfe83, 0x01968702, 0x967bfe85, 0x59837ffe, 0xf8fe3f30, 0xee007901, 0x38000c00, 0x0ecf1440, 0xc1821001,
    0x0ea02108, 0x2b0c1b03, 0x010c020c, 0xb8070697, 0x0d40c0ff, 0x5f481410, 0x07100107, 0x9c060701, 0xed2f000c, 0x2b256583, 0x5d32ed33, 0x0868825d,
    0x0e172522, 0x3e230703, 0x6a013703, 0x2f270e0f, 0x0f8a1933, 0x08161b1d, 0x7a3617ee, 0x3d387b7c, 0x357d8384, 0x52266983, 0x4202d101, 0xae827902,
    0x09401525, 0x82400502, 0xb90025d6, 0xe12f0001, 0x102e4c82, 0x133031ce, 0x52152135, 0xd101f001, 0x1a82a8a8, 0xff932708, 0x009101e3, 0x001300fa,
    0x801b4035, 0xa0159015, 0x15110315, 0xc0960a01, 0x0200d000, 0x00440034, 0x00740064, 0x9e820004, 0x0a07b627, 0x9b050048, 0x2397840f, 0xed5d5d2b,
    0x37209483, 0x200e5648, 0x0f514893, 0x4c486f20, 0x0001280f, 0x02000014, 0x82b605e7, 0xb11e26a1, 0xffb80201, 0x25a782f0, 0x00100003, 0x12820105,
    0x112f3f38, 0x32383301, 0x3133382f, 0x23010130, 0xfde70201, 0x2102b3e0, 0x8544b605, 0x00022805, 0x04ecff62, 0x82cd0508, 0x00273db1, 0x1e154026,
    0x1029006f, 0x6f140129, 0x0a010a20, 0x070f7323, 0x19057319, 0x3fe13f00, 0xe124ef83, 0xe1de105d, 0x14394782, 0x23060602, 0x02262622, 0x36123435,
    0x16323336, 0x14051216, 0x3233021e, 0x0811823e, 0x23022e53, 0x04020e22, 0xb2713308, 0x73af767f, 0xb16f3339, 0x74b0777e, 0x1e13fd3a, 0x4d4d6b42,
    0x1f1f456c, 0x4d4d6c45, 0x021e426b, 0xe8feb1dd, 0xc26666c2, 0xb1b11801, 0x66c11801, 0xe8fec165, 0x95e096b2, 0xe1944a4b, 0x94e09697, 0xe0944a4a,
    0x00010000, 0x20e182b2, 0x08e182c7, 0x35001066, 0x12402140, 0x0e010f01, 0xbf6e000e, 0x0201ff01, 0x0001017e, 0x20011001, 0x04014001, 0x0f0d0106,
    0x00180006, 0x01cd3f3f, 0x5d5d5e2f, 0x2f33e15d, 0x315d3311, 0x11232130, 0x37023e34, 0x0707030e, 0x02330127, 0x0301b0c7, 0x1a110103, 0x94151e1b,
    0x967f0160, 0x622b9103, 0x12225961, 0x121b181a, 0x2b017b79, 0x2b087182, 0x03000060, 0x00cb05f0, 0x403c0023, 0x6f082320, 0x10251b1b, 0x6f220125,
    0x11012101, 0x01012011, 0x10220801, 0x0716730d, 0x01742202, 0xe1297082, 0x33e13f32, 0x2f013912, 0x2771835d, 0x115ded10, 0x33e12f33, 0x21227882,
    0x52450135, 0x27072308, 0x3f45033e, 0x154c0809, 0xfcf00321, 0x4b5e0170, 0x222c5376, 0x5f35563f, 0x28664599, 0x41766a5c, 0x3b6c9b60, 0x4b815d35,
    0xb102e7fe, 0x517d019c, 0x4c818086, 0x203f5a3b, 0x24773c4d, 0x361b2e3f, 0x555b9165, 0x5196959a, 0x0008d5fe, 0x52000100, 0xee03ecff, 0x4008a982,
    0x405d0039, 0x2130210b, 0x6f1a1230, 0x006f2709, 0x40c0ffb8, 0x48171428, 0x3b090000, 0x4f013b20, 0x06120112, 0x21ab7320, 0x01217901, 0x0801210b,
    0x2f152121, 0x0735732c, 0x0e127315, 0x333f0019, 0x41c184e1, 0xc8830536, 0xce105d2d, 0xe12b2f32, 0x3911e110, 0x482f2f39, 0x1621077a, 0x05f04a16,
    0x35272624, 0xef411616, 0x35232108, 0x22210a88, 0x08e68706, 0x2ec103a6, 0xb1477453, 0xca8441b8, 0x55c16d8a, 0x5c5dcb57, 0x35295786, 0x85598d62,
    0x557e5185, 0x5c42242c, 0x4aa36b38, 0x6e5d265c, 0xa36c467d, 0x6004386e, 0x39587849, 0xb516060c, 0x74a06091, 0xaa2d2240, 0x4a28322e, 0x6144436c,
    0x28971e3f, 0x343d664a, 0x431e3952, 0x361f7d36, 0x61361829, 0x00020085, 0x04000017, 0x00be053f, 0x0018000a, 0x092c404e, 0x00010056, 0x116e0200,
    0x20070b0c, 0x03030103, 0x011a101a, 0x18871877, 0x055f1802, 0x06090501, 0x05017418, 0x07110205, 0x00180206, 0x12333f3f, 0xe1332f39, 0x2105a64a,
    0x0c825d5d, 0x82335d21, 0x32e12400, 0x82325d2f, 0x234608ee, 0x21112311, 0x11330135, 0x34112133, 0x2337023e, 0x0107030e, 0xb0d53f04, 0x97025dfd,
    0x7bfed5bc, 0x01050403, 0x19150709, 0x65fe0b1a, 0xb8fe4801, 0x039f4801, 0x0130fcd7, 0x757b3864, 0x31142266, 0xfd102e31, 0x918200a0, 0xecff8328,
    0xb605f603, 0xa3822a00, 0x26182e08, 0x2c056f1a, 0x27012c10, 0x68282424, 0x23590123, 0xf0232301, 0xb80f010f, 0x1240c0ff, 0x0f480b08, 0x0000731d,
    0x24742715, 0x10731506, 0x0698410a, 0xe1279b82, 0x5d2b2f01, 0x825d2f33, 0x331126a3, 0xe1de105d, 0x4ca38233, 0x27230a7f, 0x41031e35, 0x95080584,
    0x0e222326, 0x13270702, 0x03211521, 0x21023636, 0x487fab63, 0x80c58644, 0x525b6333, 0x62592121, 0x7c4f2a63, 0xa8b02e56, 0x393f3f1b, 0x02375a15,
    0x27ecfdb2, 0x81036920, 0x69a06c37, 0x437eb672, 0x141e130a, 0x182417ac, 0x764e250d, 0x05978f51, 0x39040908, 0xfea6b002, 0x000e065d, 0x71000200,
    0x0a04ecff, 0x2b00cb05, 0x37003f00, 0x6e312040, 0x1041220c, 0x3b170141, 0x1000006f, 0x03002000, 0x1d753600, 0x732c071d, 0x73101927, 0x3f000707,
    0x11e13fe1, 0xbf822f39, 0x32e15d22, 0x3228b882, 0x133031e1, 0x33043e34, 0x1722bc82, 0xad832615, 0x33070422, 0x24091943, 0x022e2223, 0x0a484401,
    0x14158808, 0x1571021e, 0xc68e5c35, 0x2f2e1385, 0x5823112b, 0x64895a2b, 0x03142a43, 0x4c39140c, 0x9a5f3b5f, 0x743e3b6c, 0xaf6466a4, 0xdb014a80,
    0x2748633c, 0x42634221, 0x2b4e6f43, 0x026e4925, 0xbfd06971, 0x024579a4, 0x9b050705, 0x4e2b0c0c, 0x5094836c, 0x1a2d3f24, 0x6aa5723b, 0x447fb672,
    0xfef2a04e, 0x7f5329b9, 0x4e6f4657, 0x604b2f2a, 0x6a854330, 0x00010043, 0x0400005a, 0x00b60506, 0xb12b0006, 0xffb80006, 0x821140f0, 0x05012afc,
    0x01081008, 0x74020502, 0x05674403, 0x0132e127, 0xce105d2f, 0x08e08232, 0x31333880, 0x21012130, 0x01152135, 0x33021901, 0xac030efd, 0x1005d5fd,
    0xdbfa91a6, 0x6a000300, 0x0004ecff, 0x2700cd05, 0x4a003a00, 0x53408000, 0x6e32231e, 0x48280a0f, 0xd305c36e, 0x05b50205, 0x0f050501, 0x014c104c,
    0x3e196e28, 0x0123d56e, 0xba0123cc, 0x23230123, 0x19201910, 0x1e0a1902, 0x38983868, 0x01385902, 0x38383828, 0x38033848, 0x26014393, 0x02435643,
    0x2d004343, 0x3b191473, 0x6a410073, 0x5d5d2708, 0x5d5d5dc1, 0x9a823939, 0x822f3321, 0x10e12209, 0x82a383e1, 0x12e1260a, 0x11e11039, 0x09394239,
    0x031e0722, 0x2205cf43, 0x4935022e, 0x032009e4, 0x270acb45, 0x06062727, 0x15062201, 0x08071c4a, 0x350226b7, 0x42719554, 0x38604628, 0x35576f3a,
    0x66a97943, 0x3d75ab6e, 0x3a684c2d, 0x253f5631, 0xc7957243, 0x48684420, 0x24486b46, 0x3f664927, 0x01807e1e, 0x237d6a16, 0x3033573e, 0x7e243f55,
    0x582ccd05, 0x6c435884, 0x1f1c4557, 0x49765f4c, 0x3868955c, 0x5c926536, 0x4a60784b, 0x5a491f1c, 0x8357426d, 0xa6fb2c58, 0x233f5935, 0x385c4123,
    0x40485434, 0x9b3c0e1f, 0x656a5403, 0x33405239, 0x42341618, 0x6a653654, 0x00020000, 0x04ecff6a, 0x00cb0504, 0x003d0029, 0x391e4035, 0x3f006f15,
    0x2f013f10, 0x20100c6e, 0x20022020, 0x1b1b7534, 0x25732a07, 0x07751007, 0x0b87421a, 0x5de13330, 0x32e1de10, 0x14013031, 0x2223040e, 0xcc44022e,
    0x23372107, 0x4c05cb4a, 0x22220835, 0xf983020e, 0x23055843, 0x0404022e, 0x3e078842, 0x23112c2e, 0xae872b58, 0x0d052b66, 0x604c3814, 0x6c9a5f3b,
    0xa5733f3b, 0x80ae6566, 0x4225fe4a, 0x443c0786, 0x252b4e6e, 0x46036e49, 0xa5bed169, 0x05024578, 0x0d9c0506, 0xd6a15e0c, 0x2e3e2477, 0x29058442,
    0x4e447fb7, 0x4701f3a0, 0x84425428, 0x426b210b, 0x933be183, 0x9101e3ff, 0x13006604, 0x3e002700, 0x29101c40, 0x29902980, 0x1e0429a0, 0x4814960a,
    0x40291150, 0x480a070b, 0x199b2300, 0x05554810, 0x01ed3f2c, 0x5d5d2b2f, 0x5d32e533, 0x58483031, 0x4811200f, 0x78481f68, 0x9103361f, 0x0e213527,
    0x2735210e, 0x10223425, 0x00342210, 0xfe3f0002, 0x08af84f8, 0x20000c2b, 0x2f406100, 0x22802210, 0x22a02290, 0xc0961704, 0x020dd00d, 0x0d740d64,
    0x010d5002, 0x3b010d44, 0x0d1f010d, 0x0d020d2f, 0x0db2490d, 0xb2491120, 0x9b1c2309, 0xb6491012, 0x29c88305, 0x332b5d5d, 0x335d32ed, 0x00845d2f,
    0xc049e520, 0x108b510b, 0x200cd049, 0x49c98f11, 0x02210be1, 0x08c58fed, 0x66000141, 0x0204ee00, 0x0600dd04, 0x30404e00, 0x08400800, 0x01014001,
    0x05010201, 0x6f060305, 0x02007f00, 0x00010030, 0x03200400, 0x70035001, 0xd0038003, 0x0503f003, 0x0001033f, 0x03060103, 0x825e2f00, 0x337121a0,
    0x3228a883, 0x2f3d3912, 0x18013333, 0x4e08b482, 0x3031ce10, 0x01350125, 0x04010115, 0x0364fc02, 0x0221fd9c, 0xa801eedf, 0xa0e10166, 0xbefe94fe,
    0x66000200, 0x0204ba01, 0x0300e903, 0x5c000700, 0x02073d40, 0x01094009, 0x0100c604, 0xa90100bb, 0x00860100, 0x01007b01, 0x42010068, 0x82390100,
    0xad043981, 0x052f051f, 0x01057f02, 0x05100500, 0x05050602, 0x01f0ad00, 0x6f010f01, 0x0020ab82, 0xe1217282, 0x228b8333, 0x4101e171, 0x5d260633,
    0x105d335d, 0xb24a32ce, 0x35012605, 0x03661521, 0x2889839c, 0x95955403, 0x969666fe, 0x8c548200, 0x840520fb, 0x01062efb, 0x01040506, 0x6f000301,
    0x02067f06, 0x210e8230, 0xfba10206, 0xfb8e3320, 0x84011321, 0x026624fc, 0x8320fde0, 0x8f012b76, 0x6c014201, 0x661ffea0, 0xfb8258fe, 0xff253108,
    0x052503e3, 0x002700cb, 0x403e003b, 0x289a3221, 0x00462728, 0x460b1400, 0x3d2f3d1c, 0x170b1401, 0x0601000f, 0x9b2d0000, 0x51101337, 0x3f000417,
    0xe521dd82, 0x21e08232, 0xdf823912, 0xe1de1025, 0x822f3911, 0x31e12812, 0x34350130, 0x4937023e, 0x36210a75, 0x08754936, 0x15030e23, 0x102d4215,
    0x0f192008, 0x30324227, 0x1e152b44, 0x53385539, 0x513f4696, 0x955d61bc, 0x361b3868, 0x42343650, 0x42bb0e26, 0x26080f40, 0x39259e01, 0x2a4d505c,
    0x4f454329, 0x394f3035, 0x9122341f, 0x60333b2a, 0x6943578b, 0x2d2f545a, 0x2c423f43, 0x4bd1fe12, 0x71080fa9, 0xff6d0002, 0x0581064a, 0x005700b6,
    0x406f0068, 0x6017583f, 0x01171f27, 0x1701277f, 0x27464627, 0x314e0317, 0x00010020, 0x016a406a, 0x014e403b, 0x5b0c2c4e, 0x64120712, 0x1f120f1c,
    0x0312bf12, 0x011c0006, 0x121c1207, 0x5336401c, 0x49454003, 0xc1332f00, 0x3912c13f, 0x5e2f2f39, 0x105d5e5d, 0x103311c1, 0x013232c1, 0x5dc15d2f,
    0xc171de10, 0x19821711, 0x825d2f21, 0xc1102118, 0x440aeb44, 0x17250ee3, 0x14060603, 0x0be54414, 0x04222322, 0x2a05b74e, 0x023e3233, 0x06061537,
    0x4b242223, 0x242805ea, 0x16043233, 0x16140112, 0xc5081984, 0x23262637, 0x06020e22, 0x39251381, 0x2d3a614c, 0x06213449, 0x47361204, 0x774d3559,
    0x6f3b2b52, 0x5a2d629e, 0x17174552, 0x22150101, 0x462e172b, 0x9856182f, 0xfea97bd1, 0x4f5aaffe, 0x3d93e399, 0x2b646f77, 0xb382d856, 0x66c3e7fe,
    0x3701db76, 0x06019cc1, 0x15fc6abf, 0x4e375565, 0x0e041a32, 0x4a2a4d1c, 0x021c3f65, 0x717d3edb, 0x1e294861, 0x25234132, 0x381c3142, 0x65568e65,
    0x08447aa8, 0xfe08110e, 0x101b1660, 0x44350308, 0x683d0f28, 0xdd8e4e8c, 0xc76f4f98, 0x97a2effe, 0x0e52a0ea, 0x8d111f18, 0xc3662c26, 0xbcb31901,
    0x88ee4501, 0xf1febd65, 0x7785d5fe, 0x4573532d, 0x3a0d08fd, 0x0000785e, 0x00820002, 0xdd047e08, 0x0700bc05, 0x84001400, 0x05062440, 0x46010246,
    0x14020114, 0x01084903, 0x08010149, 0x0e0e0001, 0x10000003, 0x07800107, 0x07d00790, 0xffb80703, 0x061840c0, 0x1007480a, 0x0f160707, 0x2f161f16,
    0x9f168f16, 0x0616df16, 0xb8040307, 0x1140f0ff, 0x0e5f0204, 0x480e0a20, 0x1414050e, 0x00040305, 0x323f0012, 0x122f393f, 0x01e12b39, 0x5e33382f,
    0x2f33115d, 0x715d2b38, 0x39121133, 0x2416823d, 0x125d5d39, 0x08048239, 0x31333397, 0x21032130, 0x33012303, 0x2e030101, 0x030e2703, 0x1f040307,
    0xa2dffda0, 0xaa1902bc, 0x67fe1a02, 0x12110694, 0x12070812, 0x91061112, 0x3bfec501, 0x44fabc05, 0xa8016a02, 0x413c3412, 0x3d421f1f, 0x58fe1133,
    0x00030000, 0x040000c7, 0x00b60587, 0x00220017, 0x4062002f, 0x5a1e0b3e, 0xe5010605, 0x0206f506, 0x060106d6, 0x5b2a2406, 0x11801170, 0x31671102,
    0x318f317f, 0x01311002, 0x175a2418, 0x230b3064, 0x01187960, 0x0801180b, 0x24001818, 0x22121760, 0x494f8260, 0x5e3b06c7, 0x39e15d5d, 0xe1f61001,
    0x105d5d32, 0x12e15df6, 0x5d5d2f39, 0x3132e171, 0x4a211330, 0x0721068e, 0x06554815, 0x47132121, 0x26270538, 0x11112323, 0x4e3e3221, 0x7508051c,
    0x808f01c7, 0x274283c3, 0x45456d4a, 0x41345a79, 0xfe6fb07b, 0x54f4ba1b, 0x9a1f4672, 0x0a01dfa6, 0x20497758, 0x5c7c4b21, 0x5727b605, 0x6c3e678d,
    0x0a093752, 0x784f2d0c, 0x6d9d6456, 0x1e4a033a, 0x783b593b, 0xfd97fd68, 0x654828f0, 0x435e383d, 0x01000025, 0xecff7d00, 0xcb059804, 0x4c002300,
    0x0eaf1440, 0x15400e01, 0x0e0e4818, 0x0120ba18, 0x20702060, 0xb3412002, 0x20203807, 0x0125af25, 0x66185b05, 0x5f002124, 0x0a0d041d, 0x0013135f,
    0x8233e13f, 0x26d68302, 0x2f33115d, 0x825d5d2b, 0x5d2b24d6, 0x48013031, 0x36240800, 0x030e1537, 0x080cf34e, 0x2607176a, 0x6b190326, 0x3b437bae,
    0x5976b076, 0x4e274ea0, 0xa43b6155, 0x574c9df0, 0x6ca2faa9, 0x3f4e4fc4, 0x51270594, 0x8d89da98, 0x234e96db, 0x170fa217, 0xc66c070e, 0xa6a91601,
    0x6ec61401, 0x209c2a2c, 0x0002002e, 0x040000c7, 0x00b605fc, 0x0017000c, 0x0d154026, 0x1967005b, 0x14011910, 0x1864065a, 0x03076013, 0x12066014,
    0x3f219f82, 0x229d84e1, 0x82e1f610, 0x02143495, 0x21230406, 0x16322111, 0x34071216, 0x2323022e, 0x82203311, 0x60300846, 0xa8f7feb6, 0x970192fe,
    0x5faef899, 0xb87e42c5, 0x01a2c975, 0x020c0108, 0xe9feb9e9, 0xb6055ebb, 0xf4feb55c, 0x8ad592b6, 0x0189fb43, 0x01000024, 0x03217d83, 0x087d82be,
    0x42000b29, 0x08142640, 0x01080801, 0x0d670004, 0x015a0a06, 0x5f090c64, 0x0f01064f, 0x0206af06, 0x0a060608, 0x03025f05, 0x85015f0a, 0x3912258c,
    0x715d5e2f, 0x322a9384, 0x1132e610, 0x315d2f39, 0x92822130, 0x03861520, 0xfdbe0335, 0xfdf70209, 0xfd1702c3, 0x053d02e9, 0x3cfea4b6, 0x8af8fda2,
    0x00092471, 0x82114070, 0x0f24086e, 0x03ff0103, 0x90038001, 0x0303d003, 0xc0ffb803, 0x0a073840, 0x0b030348, 0x0b2f0b0f, 0x0baf0b8f, 0x00060704,
    0x0a238d82, 0x830f5f09, 0x063f348d, 0x06ff066f, 0x40060804, 0x06481d1a, 0x48151040, 0x83000606, 0x8200209b, 0xe13f2199, 0x2b219882, 0x209a882b,
    0x06ce415e, 0x16827120, 0x23229f82, 0x9f852111, 0xba810122, 0x9a829c87, 0xa4fcfd23, 0x06434200, 0x05f22908, 0x002b00cb, 0x2b1e4037, 0x5a290c2b,
    0x2d670214, 0x1f012d10, 0x2c660c5b, 0x00005f2b, 0x115f1a24, 0x075f2404, 0xe13f0013, 0xe1206a84, 0x29069441, 0x3911e132, 0x0130312f, 0x24421121,
    0x3324280a, 0x07171632, 0x4223032e, 0x55080844, 0x1137023e, 0x010e0321, 0x767037e4, 0xf29d4b82, 0xb65f56a6, 0x6fab0b01, 0x244858cc, 0x2e5d5853,
    0x427fbc7a, 0x86be7837, 0x373e492c, 0x03d5fe1a, 0x1233fd04, 0x690a131c, 0xae1701c3, 0xc31601ac, 0xa22a2c69, 0x0e171e11, 0x89da9851, 0x569cd882,
    0x050b0805, 0xbb83b401, 0x00c72d08, 0x05d50400, 0x000b00b6, 0x0923403d, 0x65005a01, 0x010dc00d, 0x20010dbf, 0x0408010d, 0x0c64055a, 0x080f5f03,
    0x08080801, 0x0503060a, 0x24058f44, 0x5e2f3933, 0x27c1845d, 0x5d5d5d32, 0x32e1f610, 0x3b052241, 0x33112311, 0x33112111, 0xfdbad504, 0x02baba66,
    0xaa02ba9a, 0xb60556fd, 0x680298fd, 0x52246b83, 0x64020000, 0x3b086b84, 0x0b264057, 0x020d2b0d, 0x0d9b0d7b, 0x0dfb0dab, 0x010d5404, 0x0d3b0d2b,
    0x1f030d4b, 0x0802010d, 0x055a0a0b, 0x0103c902, 0xf8ffb803, 0x100d1040, 0x01030048, 0x04090306, 0x0a030306, 0xc1258383, 0x32c13f32, 0x28858201,
    0x32c15d2b, 0x5f32c1f1, 0x2000825d, 0x08858271, 0x37352127, 0x21352711, 0x17110715, 0xeefd6402, 0x1202acac, 0x2966acac, 0x66299804, 0x68fb2966,
    0xff010029, 0x017bfe48, 0x08858273, 0x2f001324, 0x15df1c40, 0x70156001, 0x152f0215, 0x0c5a0f01, 0x0c000303, 0x07020c10, 0x07030d0c, 0x2f00005f,
    0x63833fe1, 0x102f3323, 0x235e82e1, 0x22033031, 0x8209bd50, 0x142408e9, 0x331d020e, 0x4e221c4c, 0x3d4b252d, 0x693bbb26, 0x0d7bfe93, 0x0b09a00b,
    0x44583213, 0x5efab605, 0x31659a69, 0x20076341, 0x377182a2, 0x4064000c, 0x660c022d, 0x000c010c, 0x0b100b0a, 0x0000010b, 0x07020010, 0x00290482,
    0x010eb00e, 0x10010e2f, 0x0575410e, 0x10020d2b, 0x0848100b, 0x40f0ffb8, 0x3208820c, 0x0a050802, 0x05000306, 0x333f0012, 0x3912333f, 0x452b2b39,
    0x5d27064a, 0x382f3311, 0x82335d5e, 0x11332205, 0x270d8239, 0x23213031, 0x23110701, 0x373fa082, 0x04013301, 0x3dfed3a2, 0x79baba8b, 0xfdd1c401,
    0x72ba02f8, 0xb605b8fd, 0x02a825fd, 0x4383fd33, 0x05360bc7, 0x13402300, 0x07af0704, 0x01071001, 0x64005a03, 0x03030106, 0x7082005f, 0x833fe121,
    0x845d206a, 0x8233205a, 0x15212555, 0x3d02bac7, 0xf021df82, 0x059543a6, 0x822f0621, 0x00193cdb, 0x3613408b, 0x00390119, 0x080e1701, 0x39480f0c,
    0x110e010e, 0xffb8195a, 0x821c40f8, 0x0019210e, 0x00321483, 0x090c0d0d, 0x4f1b6510, 0x1b20011b, 0x011b0f01, 0x20830b08, 0x20821a20, 0x010b263a,
    0x5a08020b, 0x181a6409, 0x09100101, 0x0e014812, 0x0c11030b, 0xb6f0ffb8, 0x0c210c82, 0x298a8308, 0x322b3232, 0x2b33333f, 0xfd843311, 0x2b5d3231,
    0x5d5d5d5e, 0x3911f610, 0x2b331139, 0x82e12b33, 0x31323411, 0x215d5d30, 0x17162301, 0x11151616, 0x01211123, 0x82210133, 0x343b0807, 0x37363736,
    0x23030123, 0x060845fe, 0xac050404, 0x9c011401, 0x019e0106, 0x0304ba14, 0xfe080304, 0x4a000541, 0x398b3f49, 0xb60596fc, 0xa80458fb, 0x77034afa,
    0x473d8634, 0x8502fb49, 0x0e0521e7, 0x2d08e782, 0x40510017, 0x01280e29, 0x5a150101, 0xb0196500, 0x198f0119, 0x10190001, 0x0c270219, 0x09030c01,
    0x18640a5a, 0x06100216, 0x0b024818, 0xbd830d03, 0x0d210a82, 0x20bd860a, 0x86a5823f, 0x82b884ba, 0x21af82b0, 0xae892321, 0x3301332e, 0x032e2726,
    0x05331135, 0x31fdd70e, 0xd533aa85, 0x0307cc02, 0x03030104, 0xba04ae01, 0x8e414c4d, 0x82e7fc39, 0x4c4c32a4, 0x4343204a, 0x20031a3e, 0x00020000,
    0x05ecff7d, 0x068f5571, 0x40342108, 0x005b1e20, 0x29c02967, 0x0129bf01, 0x2f012970, 0x02295f29, 0x660a5b14, 0x0f5f2328, 0x055f1904, 0x41058944,
    0x5d2105d9, 0x081d465d, 0x081f9d55, 0x51710548, 0xa39beda0, 0x4c4c9def, 0x9ba3f09e, 0xfb51a0eb, 0xa56b34d1, 0x6ba57272, 0xa46a3232, 0x6ca67272,
    0xa9dd0234, 0x6cc6eafe, 0x1701c66c, 0x1501aaaa, 0xc56b6bc4, 0x89abebfe, 0x515199db, 0x8a89db99, 0x515197da, 0xb183da97, 0x00c74108, 0x05330400,
    0x000e00b6, 0x40460019, 0x285b152c, 0x48003800, 0x67000300, 0x011bcf1b, 0x0f011b40, 0x0f06011b, 0x64085a07, 0x30600f1a, 0x02064006, 0x19070606,
    0x07030960, 0x3f3f0012, 0x2f3911e1, 0x42068544, 0x5d310505, 0x013031e1, 0x23020e14, 0x11231123, 0x021e3221, 0x08454801, 0x33046508, 0x98cf7e37,
    0x6a01ba96, 0x3c7ec286, 0x5d814efd, 0xa42e5b8b, 0x0a04a0ae, 0x4d81a85b, 0xb605c7fd, 0xfea06d39, 0x71472067, 0x00898e51, 0xfe7d0002, 0x05710562,
    0x001d00cd, 0x40380031, 0x005b2822, 0x33c03367, 0x0133bf01, 0x2f013370, 0x02335f33, 0x66145b1e, 0x195f2d32, 0x055f2304, 0x0009130f, 0xe1333f2f,
    0x41066a47, 0x8b8505d9, 0x5d5d0720, 0x41062006, 0x312d2158, 0x2b5d8e5f, 0x67795a89, 0x291133ad, 0x1f624112, 0xb5e2832d, 0x8f5e2684, 0xc6498e3c,
    0x4102027f, 0x3108256b, 0x00b605a0, 0x001c000f, 0x09564082, 0x020f190f, 0x0f010ff9, 0x480f0b08, 0x0c090c0f, 0x010c0701, 0x07085b16, 0x07020718,
    0x010e0907, 0x0ef90ee9, 0x1d830e02, 0x0d0e2008, 0x3f1e0d10, 0x9f1e8f1e, 0xdf1ebf1e, 0x1e20051e, 0x5a011001, 0x0c1d6402, 0x00601003, 0x82080100,
    0x601c3203, 0x010e0303, 0x333f0012, 0x3911e13f, 0xe15d5e2f, 0x08eb4912, 0x3238ce27, 0x32715d2b, 0x2313832f, 0x33115d5e, 0x31310c82, 0x23110130,
    0x16202111, 0x020e1415, 0x01230107, 0x05a94127, 0x022e7008, 0x81012323, 0x016401ba, 0x5131fe0a, 0x8e013768, 0xe5a1fedb, 0x517e5aa4, 0x7f532925,
    0x5c02a057, 0xb605a4fd, 0x8257d1ce, 0xfd143e5d, 0x9e5c0271, 0x45674523, 0x1d406448, 0x68000100, 0xc903ecff, 0x3300cb05, 0x27404200, 0x23012359,
    0x67005a11, 0xff35bf35, 0x35600235, 0x01353f01, 0x1b095a2a, 0x2a113466, 0x245f2705, 0x600e0420, 0x82130509, 0x3fe122b0, 0x83ac8233, 0xe13221ad,
    0x2105b941, 0xbb415d33, 0x22232205, 0x051c5526, 0x34353627, 0x2e27022e, 0x05dd5103, 0x07171625, 0x52232626, 0x5b0806d9, 0xc903031e, 0x73b88045,
    0x2241c16f, 0x32666057, 0x491d99a0, 0x83595d7a, 0x74402955, 0xbe7761a1, 0xa541434a, 0x1e867a58, 0x5b547346, 0x012f5c89, 0x6a996187, 0xb2222337,
    0x0f181f10, 0x50367078, 0x23253f43, 0x54846853, 0x325f8a58, 0x1d9c232d, 0x3960712b, 0x213b4353, 0x7e604c24, 0x5f08d382, 0x04000014, 0x00b60512,
    0x405e0007, 0x01090f32, 0x4f0109d0, 0x0209cf09, 0x09200910, 0xaf030930, 0x0206ef06, 0x06010684, 0x025a0706, 0x03e00340, 0x01030f02, 0x57030308,
    0x77026702, 0xb8020302, 0x0b40c0ff, 0x02480a07, 0x045f0307, 0x00120003, 0x32e13f3f, 0x5d2b2f01, 0x5d5e2f33, 0x32e1105d, 0x2005e04f, 0x05be4771,
    0x15213531, 0xbb710221, 0xfe035efe, 0x12055ffe, 0x8200a4a4, 0xb82b0881, 0xdd04ecff, 0x1700b805, 0x1c402f00, 0x65015a16, 0x0119b019, 0x19af196f,
    0x01191002, 0x640b5a0e, 0x065f1118, 0x03000c13, 0x42323f00, 0x4e4408ff, 0x5f112005, 0x1122074a, 0xf94d1133, 0x112a0806, 0x8542dd04, 0xc48088c9,
    0xadbb4485, 0x528059af, 0xb8050128, 0xc4724cfc, 0x8e4d5290, 0xae037ac7, 0xc0af48fc, 0x51886236, 0x7b82b803, 0x00000024, 0xfd828b04, 0x6c000c34,
    0x02031040, 0x00040909, 0x01700160, 0x01f001b0, 0xdb830104, 0x06162608, 0x1001480a, 0x2f0e0101, 0xbf0e7f0e, 0x400e030e, 0x05480906, 0xf0ffb804,
    0x040504b4, 0xffb80903, 0x110ab3e0, 0x22078248, 0x820a40f0, 0x0209251a, 0x01001203, 0x332daa82, 0x2b33333f, 0x01333f2b, 0x2b33382f, 0x05534d5d,
    0x3912332c, 0x33332f3d, 0x33013031, 0x03822301, 0x17161636, 0x03373636, 0x17fec6c5, 0xc519febb, 0x2a1d2701, 0x1f2e0f11, 0x2705005b, 0xa95b61fc,
    0x61a94a4a, 0x2105a341, 0xa582fe06, 0xdf002a2e, 0x150810b6, 0x0f104818, 0xb5f8ffb8, 0x0f210882, 0x22a58207, 0x821240f8, 0x0001210a, 0x00221983,
    0x06831d16, 0x821c1d21, 0x2f402120, 0x28081682, 0x0714251c, 0x44070401, 0x0307b407, 0x14250407, 0x44252425, 0x05255425, 0x25251607, 0x1e030716,
    0x010e000d, 0x0e800e70, 0x83db82c0, 0x071838f0, 0x100e480a, 0x6f2c0e0e, 0x022c7f2c, 0x2c302c20, 0x012c0f02, 0x821e1f08, 0x134024f2, 0x8220161e,
    0x101621ed, 0x1627e982, 0x031e000d, 0x41252507, 0x07820601, 0x82b6f021, 0x10252416, 0x8400121d, 0x331121fb, 0x33220682, 0x554e2b2b, 0x415d2005,
    0x71310603, 0x39171233, 0x2f2f2f3d, 0x715d5e5d, 0x332b3311, 0x3b04892b, 0x33013031, 0x17031e13, 0x1337033e, 0x03230133, 0x26272626, 0x06070627,
    0x23030706, 0x4d081988, 0xe5c52903, 0x13191d0f, 0x100c0406, 0xc7c80b13, 0xfebc91fe, 0x0c0b1a0e, 0x0a0b0b0b, 0xbcf20e19, 0xdfc57efe, 0x0e11140c,
    0x140f0505, 0xb6050d17, 0x7038a8fc, 0x26265e69, 0x3167635a, 0x4afa7203, 0x6c33aa03, 0x3334372f, 0x36702f37, 0x1f825cfc, 0x632e872a, 0x25265b62,
    0x316f6c62, 0x08061142, 0xb6056044, 0x81000b00, 0x0a091d40, 0x000a0a10, 0x0b010b37, 0x01053808, 0x01020205, 0x70010000, 0xc0008000, 0xb8000300,
    0x1440c0ff, 0x00480a07, 0x0d000010, 0x0d1f0d0f, 0x0d7f0d2f, 0x06070804, 0xb3f0ffb8, 0x6e4f0606, 0x04102b05, 0x27010228, 0x08020108, 0x12820904,
    0x00120030, 0x333f323f, 0x5d393912, 0x382f015d, 0x714f3232, 0x3d392a0c, 0x335d332f, 0x33115d33, 0x25178218, 0x23213031, 0x02820101, 0x01013329,
    0x60040133, 0x829efed3, 0xc50139eb, 0x01c65afe, 0xbe4e014c, 0x7b025bfe, 0xfc0285fd, 0xd1fdba02, 0x4cfd2f02, 0x00209a82, 0x04210082, 0x3dbd8237,
    0x40730008, 0x010aef19, 0x0c09400a, 0x07ab0848, 0x01079801, 0x1b010740, 0x070f0107, 0xa0820701, 0x072f403d, 0x80010507, 0x024f0102, 0x01021b01,
    0x02021002, 0x775a0400, 0x97058705, 0x534f0305, 0x072906b7, 0x01003605, 0x12040100, 0x05d14207, 0x82391221, 0x5d5e25b4, 0x39e15d5d, 0x0782b882,
    0x33113324, 0x0782382f, 0x335d5d26, 0x30315d2b, 0x113ba783, 0x33011123, 0x54011b02, 0xbb42fec8, 0x02cb42fe, 0xfce302d3, 0x02c7fd83, 0x4b87032f,
    0x032106a1, 0x08a182fe, 0x38000921, 0x09092040, 0x0b670703, 0x0b3f0b0f, 0x0b9f0b4f, 0x04080804, 0x0a660104, 0x055f0407, 0x4d080203, 0x392b05cf,
    0x0139e13f, 0x2f32e610, 0x825d5e32, 0x2f322606, 0x21213031, 0x05cc5835, 0xfe032135, 0xc70254fc, 0x83034dfd, 0xdb023afd, 0xa67f0491, 0x8381fb91,
    0xfea42465, 0x823902bc, 0x00073b65, 0x04174026, 0xf106f300, 0x01100100, 0x01c001b0, 0xf5050104, 0xf506f802, 0x395ef901, 0x32ed2108, 0x2135ba82,
    0x23152111, 0x39023311, 0x95016bfe, 0xbcfedfdf, 0xfa95fa06, 0x244b8331, 0x02000017, 0x254b82e9, 0xb7210003, 0x46820102, 0x03000528, 0xb4f0ffb8,
    0xc45e0203, 0x012f3505, 0x1133382f, 0x33113833, 0x01133031, 0x02c90123, 0xe0fdb220, 0x8305c443, 0xfe33243f, 0x84c901bc, 0x4024368b, 0xf3000314,
    0x0660f101, 0x06020670, 0x07f50009, 0x04f503f9, 0x238885f8, 0xe15dd610, 0x17248983, 0x35231133, 0x333f8d82, 0x9601dfdf, 0x05ae6afe, 0x06f995cf,
    0x00010000, 0x04250229, 0x00c10519, 0xb6120006, 0x82080303, 0x00062812, 0x2f01cd3f, 0x832f3311, 0x82332078, 0x0121087a, 0x66cb0129, 0xfea1bf01,
    0x02a3feaf, 0xfc9c0325, 0xfddf0264, 0xff010021, 0x03bcfefc, 0x0048ff4e, 0x293b8203, 0x01050000, 0x0002ba01, 0x3b86e12f, 0x3521012c, 0xfc4e0321,
    0xfe5203ae, 0x56828cbc, 0x89014708, 0x1203d904, 0x0d002106, 0x0a401600, 0x80080600, 0x005f000f, 0x2f000002, 0x01cc1a5d, 0x3031cd2f, 0x032e2301,
    0x1e333527, 0x12031703, 0x4d522378, 0x10db103f, 0x15302e2b, 0x531cd904, 0x151b5158, 0x4c515122, 0x3282001d, 0xff5e6f08, 0x049c03ec, 0x0023005e,
    0x40540032, 0x29011011, 0x34552347, 0x346f340f, 0x48300602, 0xffb81a0c, 0x0d1e40d0, 0x101a4811, 0x1a480c09, 0x33560c1a, 0x1d501619, 0x1010522a,
    0x5024101d, 0x00160702, 0x3f3f0015, 0x393fe133, 0xe110e12f, 0xe6100132, 0x2b2b2f32, 0x5d5ee110, 0x32e1f610, 0x21303132, 0x030e2327, 0x022e2223,
    0x37363435, 0x20643537, 0x27072105, 0x08065755, 0x32251162, 0x3535023e, 0x15030e07, 0x19031614, 0x42210825, 0x453f604e, 0xe7305574, 0x371db8ec,
    0x8f533451, 0xb64a4042, 0x61956664, 0x3d2ffe30, 0x8f2b4c68, 0x20497a5a, 0x412d9861, 0x5127142a, 0xb0a4547b, 0x43450708, 0x3018375a, 0x38288922,
    0x628a5929, 0x267f10fd, 0x634f754d, 0x39200407, 0x565c3351, 0x3308e583, 0x04ecffae, 0x0014063f, 0x002f001f, 0x482db538, 0x31315705, 0x40b8ffb8,
    0x15490a17, 0x12472510, 0x00133054, 0x502a1512, 0x20160a0f, 0x10001b50, 0xe1323f00, 0x3f21d483, 0x20c58401, 0x05cc462b, 0x2e0b315d, 0x11230723,
    0x06141133, 0x33070607, 0x4f17033e, 0x363708a5, 0x02263435, 0x6d9a5e9e, 0x9a6d3c3c, 0x4d603b5e, 0x250c173b, 0x8202b685, 0x08430800, 0x604d3a17,
    0x416b5019, 0x6c411b1b, 0x7f7f8751, 0x8f485e04, 0xd58d8cd4, 0x2b1a4990, 0x068b203a, 0x2388fe14, 0x2628224f, 0x192c3c23, 0x9c683397, 0x6b9d6569,
    0xd0ccda37, 0x000100ce, 0x03ecff71, 0x825e046f, 0x402a3ac1, 0x210d1d18, 0x217f215f, 0x01211002, 0x56054816, 0x0a511320, 0x00511910, 0x09ea5116,
    0xce105d29, 0x05303132, 0x48022e22, 0x440808b0, 0x2223032e, 0x16141506, 0x37363233, 0x02060615, 0x82b06552, 0xb2854c4a, 0x32954e66, 0x3c381736,
    0x909d1a3a, 0x83519491, 0x147b3636, 0x96d5893f, 0x3e89db9d, 0x0a9a1922, 0xc9090f13, 0x25c3d3d4, 0x1e1da219, 0x06c35d00, 0x14060222, 0x20088982,
    0x40340030, 0x1b00261d, 0x32551e47, 0x2e013210, 0x31560b48, 0x001c151f, 0x1016502b, 0x01502010, 0x20908206, 0x09474133, 0x20071142, 0x08104225,
    0x2e05056b, 0x27263317, 0x11352626, 0x25231133, 0x42023e32, 0xaa820723, 0x54032208, 0x4d3b1608, 0x9a5d3c60, 0x6e3c3c6e, 0x603b5d9a, 0x0c163c4d,
    0x04020303, 0xc6fe93b6, 0x1f41694c, 0x064a4102, 0x3d229324, 0x4d411a2e, 0x3a2c3108, 0x1a1f2220, 0xb4011037, 0x2e83ecf9, 0x295e8d5e, 0x21054941,
    0xbf85cdd1, 0xe1033008, 0x1e005e04, 0x43002700, 0x48232840, 0x29571019, 0x6f0129e0, 0x11220129, 0x28560548, 0x221b5011, 0x0f02222b, 0x22060122,
    0x501f1422, 0x4114100a, 0x1224075b, 0x5d5e2f39, 0x2308f650, 0xe132f610, 0x240b6441, 0x1515021e, 0x05d96021, 0x1537b908, 0x2203030e, 0x34210706,
    0x6002022e, 0x4883b66e, 0x65a77842, 0x3b6e9e63, 0x99054cfd, 0x51573397, 0x4d28274c, 0x72605751, 0xec010b85, 0x1458391b, 0x87d28e4a, 0x4e95d688,
    0x6eb58147, 0x0ab6c171, 0xa2121d13, 0x08121c13, 0x959cdb03, 0x2c507144, 0x1d000100, 0xf0020000, 0x1b001f06, 0x4e407000, 0x1ddf1dcf, 0x801d6002,
    0xa01d901d, 0x1d1f041d, 0x1d4f1d3f, 0x7f1b1b03, 0x0210bf10, 0x021a1010, 0x03070347, 0x051f050f, 0x05af052f, 0x00050504, 0x20031003, 0x90038003,
    0x0603a003, 0x05010306, 0x1a00074f, 0x0f1a0701, 0x010d5014, 0x3f001502, 0x5e3fe13f, 0x32e1335d, 0x3205ed50, 0x1033115d, 0x2f3232e1, 0x5d2f395d,
    0x30315d5d, 0x82112301, 0x37352101, 0x200cfe4a, 0x08ef820e, 0x8b0233b0, 0xc2c2b7f5, 0x4e7c552d, 0x2f27633b, 0x2828491f, 0xf513263a, 0x3ffcc103,
    0x444bc103, 0x548d6b60, 0x8d0e1723, 0x3013110b, 0x00684153, 0x25000300, 0xfc0314fe, 0x3f005e04, 0x5e005200, 0x1940a700, 0x5305320d, 0x2f123747,
    0x37703760, 0x37033780, 0x272f372f, 0x47591d48, 0xc0ffb805, 0x0a074d40, 0x01050548, 0xfd011d0a, 0x1db0011d, 0x011d8801, 0x1d301d20, 0x1d031d40,
    0x601f601d, 0xdf60bf01, 0x60a00260, 0x40274001, 0x27480f0c, 0x0d320502, 0x52563c04, 0x5c220a0a, 0x4e2c3c4f, 0x0701170f, 0x103c1717, 0x1b224f45,
    0x000f0001, 0xe782c13f, 0x5e2f3937, 0x1039c15d, 0x2f3911e1, 0x391712e1, 0xc12b2f01, 0x11715d5d, 0x3aea8333, 0x3933715d, 0x10e12b2f, 0x393911c1,
    0x105d2f2f, 0x12e110c1, 0x30313939, 0x62071501, 0x0e2609be, 0x1e141503, 0x195a3302, 0x05dd4407, 0x37023e28, 0x34352626, 0x244c3736, 0x83012009,
    0x36322e25, 0x022e3435, 0x0e222323, 0x16141302, 0x080e8333, 0x222326d2, 0xc5fc0306, 0x5f2f261c, 0x2c165d8c, 0x1b21110e, 0x38291811, 0x805db01f,
    0x86412451, 0xa06b8bcd, 0x4227356a, 0x362a2f57, 0x472b4540, 0x62321b31, 0x4f256192, 0x1a40fe1b, 0xba48613b, 0x5a3718b9, 0x4c23b041, 0x6c5c293f,
    0x69676463, 0x046a6364, 0x231b714a, 0x814c456d, 0x0301355e, 0x2820190a, 0x12211b18, 0x6d502f06, 0x618c583d, 0x71502a34, 0x425b3c47, 0x52130b2a,
    0x2a593d35, 0x60513f12, 0x628c5933, 0xfb090b34, 0x2e402502, 0x2e6c731b, 0x100c213a, 0x60034d2c, 0x776f7073, 0x0078747b, 0x00ae0001, 0x06120400,
    0x00190014, 0x001d4032, 0x1b551947, 0x1b601b10, 0x0f031b80, 0x0b470a0e, 0x04101a54, 0x0c101550, 0x15000b00, 0x3f323f00, 0x2a060157, 0x105d3232,
    0x3031e1f6, 0x82341121, 0x020e27e4, 0x11231115, 0xa2611133, 0x16510805, 0x5c031115, 0x6e517069, 0xb6b61d43, 0x45190a08, 0xb7305c52, 0x82c302b9,
    0x94663482, 0x06c7fd60, 0x9032fe14, 0x142a3f2b, 0x33fdd2bf, 0x00020000, 0x010000a0, 0x00e50575, 0x00110003, 0x10144025, 0x02132013, 0x0447000c,
    0x07125401, 0x020f0f53, 0x057b460f, 0x01e52f27, 0xe132f610, 0x05ab6532, 0x34033322, 0x0806b25b, 0x22230625, 0xb6640126, 0x2d3dc4b6, 0x111d2716,
    0x3d2d2c3f, 0x29014a04, 0x1c0d363c, 0x393a1e2b, 0xff020038, 0x8414febc, 0x13240861, 0x2e002100, 0x23101940, 0x1c022320, 0x140c470f, 0x540c0303,
    0x1f531722, 0x070f0d1f, 0x001b0050, 0x333fe13f, 0xe6246783, 0x10322f32, 0x13206a84, 0x20100854, 0x2f788b13, 0x173f3042, 0x1b23361a, 0xb613232e,
    0x136d4822, 0xfe348389, 0x940b0e14, 0x270f0b0a, 0xf4043341, 0x7b4d18fb, 0x5f072f57, 0x79419489, 0x033a0805, 0x001406f0, 0x405e000e, 0x0404070b,
    0x06030302, 0x05010544, 0x40c0ffb8, 0x480a0717, 0x05051005, 0x2f100f10, 0x0d070210, 0x540a4709, 0x00000b0f, 0x40f8ffb8, 0x480f0c10, 0x04820807,
    0x0307002a, 0x03150a06, 0x3f3f000f, 0x46052854, 0x5e2005c7, 0x2e06e14b, 0x33113333, 0x31331139, 0x01370130, 0x54010133, 0x2508072a, 0x87560103,
    0xfed32501, 0xd1ac016f, 0xb46db0fe, 0x370210b4, 0xfe6901aa, 0x0191fd25, 0x5afe52f8, 0x36fd1406, 0x9f85edfe, 0x82640121, 0x0003329f, 0x100e401a,
    0x02052005, 0x54014700, 0x00000204, 0x23718215, 0xe1f61001, 0x23068a41, 0xb6b66401, 0x4a082782, 0x00ae0001, 0x04870600, 0x002c005e, 0x233f4065,
    0x0bb9470a, 0xa60b9601, 0x0b89020b, 0x770b6701, 0x0b0b020b, 0x2c470016, 0x2ef02e55, 0x012ecf01, 0x2e502e20, 0x012e0f02, 0x47151908, 0x232d5416,
    0x0f041a1a, 0x101f2850, 0x42160f17, 0x3220056d, 0xe122d782, 0x02543232, 0x5d5e2106, 0x2205b34f, 0x822f3911, 0xe15d2208, 0x0d7e4232, 0x260a8842,
    0x033e3317, 0x86163233, 0x152e0806, 0x64d10511, 0x41664969, 0x6963b71e, 0x1b3f684d, 0x0a1a94b6, 0x594f4218, 0x269f782e, 0x57491a08, 0xb1af3260,
    0x8282c302, 0x58875b2f, 0xa842a2fd, 0x4a043009, 0x2a3f2b94, 0x2f5e5814, 0xbf162d44, 0x4133fdd2, 0x04210513, 0x3de18212, 0x40300018, 0x1847001c,
    0x1a101a55, 0x1a801a60, 0x470a0e03, 0x0f19540b, 0x10145004, 0x2c430f0c, 0x122b430e, 0x2a439b88, 0x43948208, 0x8186102a, 0x55657b84, 0x822d2005,
    0x0013227b, 0x3c7d821f, 0x00481a1d, 0x21402157, 0x21e021d0, 0x01210f03, 0x0a481406, 0x501d2056, 0x5017100f, 0x09224805, 0xf1535e20, 0x0dec6e08,
    0xa3440520, 0x2d042c0a, 0x6fb27d43, 0x477fae67, 0x84b37c43, 0x00fd2507, 0x879a9a89, 0x21080383, 0xd5892702, 0x914c4c91, 0xd38889d5, 0x914b4b91,
    0xd3d188d3, 0xcfd1d1d3, 0x020000cf, 0x14feae00, 0x91823f04, 0x20088f82, 0x1e403600, 0x571b482e, 0x01321032, 0x0c061026, 0x31540d47, 0x16115020,
    0x0c0f0e10, 0x05502b1b, 0x25928200, 0x3f3fe132, 0x4d58333f, 0x07414405, 0x2e220524, 0xc1552702, 0x41332008, 0x1e2b0517, 0x0e141502, 0x0e220302,
    0x45150702, 0x2622075b, 0x66499e02, 0x03032c05, 0x94b60402, 0x3a17081a, 0x493c604d, 0x81200681, 0x220b2448, 0x482b1a14, 0xfe280618, 0x9436062b,
    0x1b2d3d23, 0x25073248, 0x5e2edb03, 0x26485f8c, 0xced02106, 0x7120c383, 0x0220c382, 0x1022c382, 0xc3833000, 0x05202b26, 0x55244725, 0x0e2fc683,
    0x31561648, 0x0f221b24, 0x1b500b20, 0x82002c10, 0x06045ccd, 0x013f3f25, 0x48e1f610, 0x322205e8, 0xce483031, 0x4917200e, 0x1e25088e, 0x37331702,
    0x08915633, 0x02030e23, 0x20a88b35, 0x09f04866, 0x173c4c2f, 0xb6931b08, 0x03030204, 0x4d3b160c, 0x0dce4860, 0xbf879720, 0x3d2d1b31, 0xcaf99423,
    0x3a13d501, 0x2222201b, 0x421a2e3d, 0x03210593, 0x08c18208, 0x41001633, 0x03b20b40, 0x900203c2, 0x0203a003, 0xc0ffb803, 0x0b071b40, 0x18030348,
    0x18501830, 0x11031880, 0x540e470d, 0x0d0f0f17, 0x00071215, 0xc13f0010, 0x20c98533, 0x06025b32, 0x01303123, 0x06f35232, 0x0806d345, 0x3e33172c,
    0x1d890203, 0x1c181a48, 0x683f1a3b, 0x94b6294b, 0x39190816, 0x5e045847, 0x05a80505, 0x855f3307, 0x04b0fd51, 0x502bc94a, 0x8b82253d, 0xecff5a24,
    0x8b823f03, 0x00352e08, 0x252d4048, 0x00904713, 0x000200a0, 0x373f3757, 0x379f375f, 0x01371003, 0x9f09472c, 0x021daf1d, 0x2636561d, 0x2c135029,
    0x09102205, 0x05b1420e, 0x123f322c, 0x32e13939, 0x5df61001, 0x3a5ee132, 0x53332005, 0x1f5e0e9f, 0x18a05305, 0x3a3f5d08, 0x6d609a6d, 0x4c1f3b9c,
    0x412c5954, 0x141a395b, 0x48485c35, 0x372b5073, 0x61568c64, 0x413f48a1, 0x62664789, 0x465e3817, 0x2a507148, 0x78502d01, 0x22232851, 0x181f10a6,
    0x3b29160f, 0x31321f24, 0x3c1f1f32, 0x4643614a, 0x2a264a6d, 0x2b1d9322, 0x34233e43, 0x1e1d2f2e, 0x00604b3c, 0x4608df82, 0x02ecff21, 0x0046058f,
    0xb150001d, 0xffb80519, 0x082f40c0, 0x0505480b, 0x4f1f3f1f, 0x1b17021f, 0x121f1447, 0x1202122f, 0x10101000, 0x10b01020, 0x10d010c0, 0x1a100606,
    0x14164f12, 0x50000f17, 0x3f00160b, 0x49333fe1, 0xc6210680, 0x2408825d, 0x2f33115d, 0x25e7822b, 0x023e3225, 0x444d1537, 0x113e0806, 0x37373523,
    0x15211533, 0x16141121, 0x2d12fa01, 0x0d09232a, 0x19343028, 0x2c4d6a3e, 0x694e9b9b, 0xecfe1401, 0x0604813f, 0x068a0308, 0x2005090c, 0x0265854e,
    0xe64e517d, 0x83fd89fc, 0xa9826261, 0xffa42208, 0x040804ec, 0x001a004a, 0x011c4030, 0x551a4717, 0x601c101c, 0x031c801c, 0x540c470f, 0x0f0d181b,
    0x0bd74d12, 0xd1423320, 0x4d312008, 0xce530acb, 0x82352008, 0x75032209, 0x05cd471b, 0x8a5b2208, 0x6ab62f5c, 0x436e516f, 0x2b93b61d, 0x2e14293f,
    0x02699862, 0x823dfdcd, 0x94653482, 0xfb3a0260, 0x060351b6, 0x82d50321, 0x00112f81, 0x1100b96d, 0x0f40f8ff, 0x11480e0a, 0x05820800, 0x0909002c,
    0xb8100f01, 0x12b3c0ff, 0x07834815, 0x071c4025, 0x8210480b, 0x13200800, 0x13cf13bf, 0x500313ef, 0x130f0113, 0x134f132f, 0x01020703, 0x40f0ffb8,
    0x0947010a, 0x010f0901, 0x27060d48, 0x2f015d39, 0x5d5ec138, 0x2906ce52, 0x3912c12b, 0x2b332f3d, 0xbe822b33, 0x2005a252, 0x05bd5233, 0x77012408,
    0xc7bc89fe, 0x191e1e0b, 0x18050704, 0xc70b1e1e, 0x0489febc, 0x219dfd4a, 0x19606c68, 0x686c6019, 0x82630221, 0x000126b0, 0x05000014, 0x25af82e3,
    0xb9c3002f, 0xaf822f00, 0xa9820c20, 0x08002f29, 0x00480e09, 0x82b82027, 0x82122010, 0x1f20210a, 0x1f221083, 0xc7831009, 0x830f1021, 0x82092016,
    0x180f3216, 0x27012754, 0x40e0ffb8, 0x480a0715, 0x1801185b, 0x29078220, 0x18180927, 0x11032709, 0xeb862e2d, 0x40210783, 0x30eb8213, 0x2e2e102e,
    0x30312031, 0x310f0231, 0x11120701, 0x24e282b8, 0x1f2d1116, 0x3ae48209, 0x19270f11, 0x19661906, 0x19031976, 0x00151000, 0x5d33333f, 0x333f3311,
    0x8233335d, 0x823320f4, 0x331125f4, 0x2b2b382f, 0x2207c153, 0x822b5d2b, 0x0ec1531f, 0x2e032127, 0x27262703, 0x0cb65323, 0x23051341, 0x17031e13,
    0x59080985, 0xa8f00301, 0x0d0c0c04, 0x060f0e06, 0x190b0d0e, 0xfed3ac0b, 0x0a83bfe7, 0x040e1214, 0x15110506, 0xc4b30a16, 0x161709ac, 0x03060412,
    0x0b15120d, 0xe4feba89, 0x2d126802, 0x3a193432, 0x323a3f3e, 0x9cfd256a, 0xb8fd4a04, 0x5b67692d, 0x61571a1d, 0x6b02215f, 0x5c2295fd, 0x0d82585f,
    0x6d683008, 0xfb48022f, 0x000100b6, 0x03000023, 0x004a04db, 0x40e5000b, 0x010989a1, 0x06010386, 0x04f70104, 0x0104e501, 0x04010436, 0x0106e805,
    0x82e70306, 0x09890829, 0xf8010209, 0x02ea0102, 0x01023901, 0x056b0102, 0x5702057b, 0x053a0105, 0x6402054a, 0x02017401, 0x35010158, 0x02014501,
    0x01090105, 0x0b030509, 0xf7010806, 0x08e50108, 0x01083601, 0x16400708, 0x40074819, 0x6b48110e, 0x02077b07, 0x3a010757, 0x02074a07, 0x0d100d07,
    0x90020d30, 0x020db00d, 0x06010d0f, 0xc8010ad9, 0x0aba010a, 0x010a0901, 0x4b0b3b0a, 0x0b28020b, 0x150b0501, 0x070b020b, 0x000f0115, 0x2f013f3f,
    0x05216b5d, 0x5d5e5d26, 0xde10715d, 0x2b220d82, 0x0582c12b, 0x17127127, 0x182f3d39, 0x821f832f, 0x8410200e, 0x33112513, 0x5d33335d, 0x312d0b85,
    0x5d5d0030, 0x13330101, 0x01013313, 0x08028323, 0x9ffe9821, 0xcffafacf, 0x75019dfe, 0xfef4fecf, 0x3302cff2, 0x66fe1702, 0xe9fd9a01, 0xb401cdfd,
    0x82004cfe, 0xfe0a32f7, 0x04df0314, 0x0022004a, 0x1022b664, 0x0e000808, 0x0631420f, 0x24080783, 0x0b071d40, 0x0f100f48, 0x24bf240f, 0x24ef24cf,
    0x01245003, 0x242f240f, 0x0703244f, 0xb8000118, 0x0c40f0ff, 0x26368200, 0x15501c23, 0x82000e1b, 0x3f322bc1, 0x333311e1, 0x382f0133, 0x244333c1,
    0x3133240f, 0x42331330, 0x0e220a03, 0xe44a2303, 0x37440809, 0xd7bd0a37, 0x12191d0e, 0x16050604, 0xc70b1d1b, 0x1c4efebc, 0x50745641, 0x151b4c34,
    0x46302340, 0x390f2534, 0x9bfd4a04, 0x52585828, 0x61561923, 0x6302215e, 0x815127fb, 0x060b315a, 0x17070591, 0xa029402c, 0x5224d183, 0x35030000,
    0x092fd182, 0x0b406c00, 0x01039709, 0x0d090803, 0x82070348, 0x114036d6, 0x07480a07, 0x0b3f0b07, 0x0b7f0b5f, 0x01089803, 0xf8ffb808, 0x221e82b5,
    0x82020408, 0x12b7271f, 0x023f4815, 0x2b820201, 0x1240f02c, 0x07480c07, 0x0f054f04, 0x09821002, 0x4f080229, 0x3f001501, 0x832b32e1, 0x2f012703,
    0x33332b5d, 0x42455d2b, 0x5d2b2105, 0x9354d982, 0xfd35330a, 0xfe18021d, 0xfdb00209, 0x7d1e02f4, 0x92894403, 0x9983d1fc, 0xfe3d3008, 0x05a202bc,
    0x002700b6, 0x1a254040, 0x20f70505, 0x1323f127, 0x0c10f60f, 0x0f230c01, 0x0110d9f5, 0x105f100f, 0x29101002, 0xf819f51a, 0x5406f505, 0x122605a1,
    0x5d5d2f39, 0x738239e1, 0x3333e639, 0x2fe232f1, 0x05303132, 0x17021e14, 0x35032e15, 0x23263411, 0x82363235, 0x05c44507, 0x11154b08, 0x15070614,
    0x01151616, 0x412d18f4, 0x5f834d28, 0x7d7d8336, 0x835f3683, 0x2d41284d, 0x73737718, 0x3d301077, 0x96010d23, 0x6e472101, 0x674e014e, 0x67569b56,
    0x6e4e4d01, 0x95012147, 0x3d230d01, 0x69b4fe30, 0x140c147b, 0xb3826a7a, 0xe9014308, 0x7f0214fe, 0x03001406, 0x1f402d00, 0x30010500, 0x70054005,
    0x04058005, 0x0300aa02, 0x03400310, 0x03c00380, 0x02030705, 0x0000001b, 0x2f013f3f, 0x5de15d5e, 0x01303171, 0x01231133, 0x069696e9, 0x1882f814,
    0x33000122, 0x9820fb82, 0x2920fb82, 0x2308fb83, 0xf724240d, 0x1af10007, 0x900314f6, 0x041d011d, 0x19eff51a, 0xd90219ff, 0x19190119, 0x23f5240e,
    0x0ef50df9, 0x20051455, 0x22fb8811, 0x86e63333, 0x341326fb, 0x26353736, 0x7af28226, 0xf2820568, 0x33021e25, 0x82062215, 0x020e2708, 0x033e3507,
    0xe783e135, 0x2123ff87, 0x413e6041, 0x01230901, 0x827a6a3b, 0x697b27dd, 0x3d304c01, 0xf3820d23, 0x47216808, 0xb3fe4e6e, 0x142d4834, 0xfe67569b,
    0x476e4eb2, 0x01960121, 0x303d230d, 0x66000100, 0x02044a02, 0x23005a03, 0x0d403c00, 0x2510251d, 0x010a1001, 0x0aad170a, 0xc0ffb81f, 0x13101640,
    0x051f1f48, 0x0d0f1cad, 0x0d3f0d1f, 0x0d6f0d4f, 0x0d060d8f, 0x335d2f00, 0x2b2fc8f1, 0x2f01e132, 0xce105d5d, 0x2e013031, 0x83222303, 0x3629089c,
    0x021e3233, 0x33031e17, 0x37023e32, 0x22230615, 0x1202022e, 0x292d3725, 0x3b3c1c16, 0x94641938, 0x4337321d, 0x2f37252f, 0x22108428, 0x83956318,
    0x8b022f10, 0x050d1610, 0x192c2113, 0x0d056ca2, 0x0d8c1419, 0x00020033, 0x018bfe93, 0x005e0491, 0x00170003, 0x0000b941, 0x053b7eff, 0xa019302f,
    0xc019b019, 0x04020419, 0x03030e9a, 0x39b2830e, 0x480a070f, 0x9b09000e, 0x10020013, 0x02070202, 0x5d5e2f00, 0x01cef52f, 0x427e2b2f, 0x33132408,
    0x5b132313, 0x8a6d0758, 0x79d53b06, 0x13efdf33, 0x1a1b2e23, 0x1414232e, 0x1b1a2e23, 0x0213232e, 0x05e7fba4, 0x417e2648, 0x066a6d07, 0x01003408,
    0xecffbc00, 0xcb05ba03, 0x5a002500, 0x03122540, 0x04040f46, 0x2715250a, 0x1e012740, 0x300a0048, 0xd00a400a, 0x0a06040a, 0x120f731b, 0x0573210f,
    0x830f0502, 0x0f0c399a, 0x050f4812, 0x1003050f, 0x00190307, 0x39123f3f, 0x2b2f2f39, 0xe1103311, 0x5a420383, 0xc6103005, 0x2f391132, 0x3132e133,
    0x07062430, 0x7c352315, 0x84540d64, 0x7603360c, 0x57894c6e, 0x3534628a, 0x89568b61, 0x352e8848, 0x3b3c3817, 0x06865419, 0x1ed42008, 0x0dcec802,
    0x89c7854b, 0x4b88cb8d, 0x03a4ac0d, 0x0a9a1721, 0xca090f13, 0x25c3d2d4, 0x8200a118, 0x004437c7, 0x05230400, 0x002800c9, 0x0d114075, 0x0f236f11,
    0x020f1f0f, 0x05821f07, 0x17031922, 0xb323b382, 0x82480e0a, 0xc8300807, 0x09063040, 0x2a171748, 0x21012a10, 0x0e0b4019, 0x29191948, 0x0d752110,
    0x227f222f, 0x22af228f, 0x22df22bf, 0x220722ff, 0x74160022, 0x73071819, 0x820a1071, 0x011127cb, 0x332b2f33, 0x0582115d, 0x84332b21, 0x5d5e21f5,
    0x154be284, 0x1521270c, 0x0e141521, 0x07820702, 0x3e358508, 0x23353503, 0x34113335, 0x9a02023e, 0x4242ae6a, 0x304b8d38, 0x01213c52, 0x1788fe78,
    0x021b3327, 0x2c21fcec, 0xc61e3549, 0x92693bc6, 0x232dc905, 0x1b2b1d90, 0xfe425e3b, 0x3ed389d9, 0x102b4059, 0x290b9aa6, 0xd5436144, 0x57440189,
    0x00325f89, 0x017b0002, 0x04ec031d, 0x0023008b, 0x40860037, 0x168f0e23, 0x2e161601, 0x0c0f15ab, 0x211e0618, 0x70000803, 0x12120112, 0x01391039,
    0xaa242004, 0x00010080, 0x4508ff82, 0x0a063140, 0x38000048, 0x011f8017, 0x18060c1f, 0x04060f1e, 0x00ae2909, 0x0d1b011b, 0xcfae3305, 0x0209ef09,
    0x09a00990, 0x1f0309b0, 0x6f093f09, 0x00090309, 0x5d5d5d2f, 0x2f32c6e1, 0x1712e15d, 0xc6331139, 0xff84325d, 0x5d241383, 0x5d2f3311, 0x2b081582,
    0x5d2fc0f1, 0x13303132, 0x27373634, 0x36361737, 0x17163233, 0x16071737, 0x06141516, 0x27071707, 0x22230606, 0x27072726, 0x37262637, 0x080a0f72,
    0x0e222342, 0x1f23ba02, 0x2f7f6281, 0x6b3c3c6c, 0x8263812e, 0x2123251f, 0x2e81607f, 0x6e3c3c6b, 0x7f607f2d, 0x258a231f, 0x33325741, 0x26264259,
    0x32335942, 0x02254157, 0x2f6b3bd3, 0x20816281, 0x81202424, 0x6d202a82, 0x24212a88, 0x22318220, 0x823c6c2d, 0x26262125, 0x00203589, 0x08052b55,
    0x054c0422, 0x001600b6, 0x305b4095, 0x130f0118, 0x15aa160c, 0x0c151501, 0xab010804, 0x021f0102, 0x98020201, 0x2e082882, 0x5a0b0307, 0x14011499,
    0x010c0f10, 0x00010c8a, 0x400c100c, 0x0c07030c, 0x0f600e0a, 0x12060f07, 0x00031360, 0x8f0f7f13, 0x1330020f, 0x8213d001, 0x131f2a48, 0x0f130f02,
    0x120b0113, 0x07755b15, 0x2f2f392d, 0x5d715d5d, 0x10333311, 0x831132e1, 0x2f012204, 0x2811825e, 0xe15d3333, 0x5d393232, 0x341e8232, 0x11393933,
    0x335d2f33, 0x5d393912, 0x01013031, 0x15330133, 0x24018321, 0x21112311, 0x82018335, 0x33022e11, 0xfebf5a01, 0xd3feef7f, 0xd3fe2d01, 0x300685b2,
    0xc085feea, 0xe302d302, 0x9e8900fd, 0x01fafe89, 0x24068206, 0x00000003, 0x0afd4502, 0x00072608, 0x00254039, 0x09300109, 0x09700940, 0x02040980,
    0x0003aa06, 0x40071007, 0xc0078007, 0x07070507, 0x03040304, 0x05054606, 0xaf823920, 0x3322a083, 0x0b4632e1, 0x46112007, 0x9629060f, 0xfc140696,
    0xfc19fef4, 0x085f82f3, 0xff79005e, 0x065e03f6, 0x0045001f, 0x4079005a, 0x0856054b, 0x26214651, 0x463c464c, 0xff102929, 0x21a00121, 0x210221b0,
    0x015cc05c, 0x46015cbf, 0x46170046, 0x00310808, 0x00000100, 0x00300010, 0x00d000c0, 0x080600f0, 0x4c265b00, 0x56175605, 0x0d04294c, 0x152e5037,
    0x010d5014, 0x3fe13f00, 0x33055f42, 0x10013311, 0x715d5ec6, 0xe12f3232, 0x5d5de110, 0x5d5dce10, 0x122b0b83, 0xe1103939, 0x31393911, 0x55341330,
    0x3e22065b, 0x864e3302, 0x15062c07, 0x17021e14, 0x1415031e, 0x5507020e, 0xc8760999, 0x022e2508, 0x37032e27, 0x17242383, 0x3435033e, 0x28080e82,
    0x1a89030e, 0x4b1f3a2d, 0x8c643755, 0x489d6156, 0x478c4138, 0x39186663, 0x7148465f, 0x29182a4e, 0x4c451c34, 0x609b6c3b, 0x05254e6c, 0x452bc508,
    0x1117375d, 0x494c5e33, 0x9a295073, 0x48653f1c, 0x21291423, 0x6c411a15, 0x262f1952, 0x33290317, 0x0f2d4053, 0x3d547226, 0x28254462, 0x271c8b20,
    0x2e1b393b, 0x1c1d2f2c, 0x3e614e41, 0x31445534, 0x4e6d2610, 0x284d6f47, 0x0f9e2021, 0x180e171e, 0x1d1b3327, 0x1f312d2d, 0x644e3e1f, 0x3a3f2559,
    0x0d0f1e37, 0x22382e24, 0x393b4026, 0x2d1f081e, 0x0200003a, 0x0c053301, 0xd9056a03, 0x19000b00, 0x21403500, 0x14af860c, 0x06c01401, 0x10000086,
    0x50004000, 0x00060400, 0x1791030f, 0x09cf099f, 0x01093002, 0x5d2f0009, 0x32e5335d, 0x5d5e2f01, 0x5ddc1ae1, 0x013031e1, 0x32333634, 0x06141516,
    0x25262223, 0x080c0b55, 0x28383324, 0x273a3a27, 0x77013828, 0x23132838, 0x263a101a, 0x73053828, 0x35313036, 0x35323235, 0x190c3036, 0x09821b26,
    0x0300003b, 0xecff6400, 0xcb054406, 0x41002500, 0x6a005500, 0xc5054340, 0x220f0f1a, 0x0801821a, 0xc34c262c, 0xc0013400, 0x57340134, 0x0a26c342,
    0xc90015c9, 0x1f150f1f, 0x7f152f15, 0x9f158f15, 0x00080615, 0x601f101f, 0x801f701f, 0x1782051f, 0x472d1f2d, 0xc8513bc8, 0x3f00042d, 0x57e12fe1,
    0x5e2c0557, 0x10e1105d, 0xe12f01e1, 0x715dde10, 0x11231385, 0x83102f33, 0x084a5bbe, 0xf54e3e20, 0x41342009, 0x012008f9, 0x2105fd77, 0x7d751504,
    0x44042005, 0x2f080f5e, 0x5e3d7b03, 0x3d1d2140, 0x3617435f, 0x18193839, 0x233c3531, 0x33659866, 0x64996936, 0x3e3b843f, 0xbefc6134, 0xa78a6136,
    0xc06868c0, 0x36618aa7, 0x6d280b8b, 0x85eaaf65, 0x65afea85, 0x21080787, 0x532c1d04, 0x784e4b78, 0x0c072b52, 0x0b830911, 0x42070e12, 0x6567aa7a,
    0x214378a7, 0x1c1a7f1d, 0x448ebefe, 0x35628925, 0x82896235, 0x82458b5c, 0x0060084d, 0x44000200, 0x42021003, 0x1e00c705, 0x4e002d00, 0x012d2f40,
    0x1d00e00f, 0x1d021d10, 0x1f2f0f2f, 0x7f2f4f2f, 0x052faf2f, 0x170be024, 0x010b6017, 0xe42d2e0b, 0x011a0f0f, 0x0600e427, 0x1ae413c0, 0xe13f00de,
    0xe1c4dc1a, 0x2f391139, 0xc61001e1, 0x102f325d, 0xd6105de1, 0x3232e15d, 0x27013031, 0x230c625d, 0x06222326, 0x0805615d, 0x1115165c, 0x15030e03,
    0x32331614, 0x3535023e, 0x121ce701, 0x23382f27, 0x1d34482b, 0x3d638f8d, 0x2a5a3038, 0x3c753330, 0x33c9777d, 0x32122944, 0x2b3a222a, 0x521d0319,
    0x0d192316, 0x334d331a, 0x04056c66, 0x1d39481f, 0x241a6416, 0x3afe7a6a, 0x12033901, 0x331d2b1e, 0x412c152d, 0xd382312c, 0x00525308, 0x03930373,
    0x000600c7, 0x4060000d, 0x0d040211, 0x04500aeb, 0x04020460, 0x060a040a, 0xffb8090b, 0x092140c0, 0x0f09480c, 0x0f9f0f0f, 0x06030faf, 0x01039feb,
    0x03000603, 0x0a0a070d, 0x01030305, 0x0108050c, 0x2f332f00, 0x3d391233, 0x1139122f, 0x02823333, 0x2f180123, 0x22dd825d, 0x42322bc6, 0x1021052d,
    0x05ba5fe1, 0x13031726, 0x01250107, 0x523f0684, 0xee753501, 0xcbfe75ee, 0x36019701, 0x74eded74, 0x2902cafe, 0xfe4e9e01, 0x4ea4fea4, 0x891b9b01,
    0x0037080a, 0x01660001, 0x03020406, 0x0005001d, 0x02244039, 0x100701aa, 0x04960107, 0x01048b01, 0x56010479, 0x044b0104, 0x01043801, 0x09010412,
    0x04040104, 0x00b305ad, 0x4d01e13f, 0x5d3d06ca, 0xde105d5d, 0x013031e1, 0x21112311, 0x95020435, 0x1d03f9fc, 0x8101e9fd, 0xffff0096, 0x06e17f00,
    0x00060227, 0x00000010, 0x08374304, 0x00085e08, 0x003a001e, 0x40c2004e, 0xb416a47d, 0x0316c416, 0x17c417b4, 0x01161702, 0x170e1552, 0x15c5160e,
    0x1515140e, 0x00090e0e, 0x091ac519, 0x041504c5, 0x00011a00, 0xd01ac01a, 0x8f07031a, 0x041a0104, 0x451f041a, 0x012d00c3, 0x2d012dc0, 0x1fc33b50,
    0x00c9180e, 0x161b1600, 0xc9081a15, 0x082c821b, 0x1f1a0f26, 0x7f1a2f1a, 0x9f1a8f1a, 0x0008061a, 0x601b101b, 0x801b701b, 0x1b1a051b, 0x40261b1a,
    0x4a1334c8, 0x000426c8, 0x31057a71, 0x5d2f2f39, 0x10715d5e, 0x333311e1, 0x10391211, 0x7b4332e1, 0x201b830c, 0x82158211, 0x39113217, 0x102b1087,
    0x0587c100, 0x01c4102b, 0x5d30315d, 0x06b35a01, 0x14052334, 0x1607020e, 0x17021e17, 0x23032317, 0x33112311, 0x8f431632, 0xe7023d1f, 0x534f5b48,
    0x92014659, 0x1f392d1b, 0x2a173543, 0xb30a0a21, 0xe99d5fce, 0xebfb9ea8, 0x3b288943, 0x45480003, 0x30813b4a, 0x0d28394b, 0x4725576e, 0x01111138,
    0x03a0fe60, 0xc3fe827d, 0x28288343, 0x06faff01, 0x06060414, 0x196561a0, 0x06042708, 0x0c04f4fb, 0x008c1406, 0x7b000200, 0xf2025603, 0x1300cb05,
    0x43002700, 0xab1e2c40, 0x299f290a, 0x30aa1401, 0x1d824000, 0x10ae1930, 0x020f200f, 0x0ff00fe0, 0x010f6f02, 0x0e830f00, 0x0f060326, 0x05ae230f,
    0x2d056276, 0x5d5d5d5e, 0x2f01e171, 0x105de15d, 0xc746e1d6, 0x0b335c05, 0x2a0fbb44, 0x7355327b, 0x56734141, 0x83563232, 0x32552c07, 0x46341e7b,
    0x35462828, 0x83351e1e, 0x1e342307, 0x1e888f04, 0x31557235, 0x41725531, 0x1e344527, 0x2745341e, 0x1f354728, 0x8247351f, 0x662a0897, 0x02040000,
    0x0b00a204, 0x3a000f00, 0x11102140, 0x08080f01, 0x0caa0906, 0xef030101, 0x00200100, 0x00a00060, 0xad0d0003, 0x4318090c, 0x2f200942, 0x5d29a683,
    0x33113333, 0x113232e1, 0x4a431833, 0x2135240f, 0x18e90115, 0x23094e43, 0x9c037dfe, 0x09524318, 0xfafe4208, 0x01009696, 0x4a023100, 0xc9056d02,
    0x40001e00, 0xe1081540, 0x4f201700, 0x02207f20, 0x0a064020, 0x01e11d48, 0xb8010f0f, 0x0e40c0ff, 0x01481815, 0xe50b1d08, 0xe51dde12, 0x3f00dd01,
    0x12e13fe1, 0x06dd4c39, 0x105d2b2f, 0x31e132de, 0x35210130, 0x35033e37, 0x09c84434, 0x0805f857, 0x21070739, 0xc4fd6d02, 0x284839d1, 0x3336420f,
    0x364e2d5d, 0x613c5285, 0x361d2544, 0x0194334f, 0x704a028c, 0x43553ee4, 0x4041223b, 0x305e2632, 0x5b3f2141, 0x55563239, 0x829d375b, 0x021f249f,
    0x82680239, 0x0030389f, 0x033c4061, 0x0e191900, 0x00e11e06, 0x06e11500, 0x8f325f32, 0x83320232, 0x27272aa8, 0x2019400e, 0x19030e48, 0x055f43e4,
    0xdf1a5f35, 0x1a08051a, 0x2326121a, 0x12de2ce5, 0xdf0b0fe5, 0x82333f00, 0x123326b4, 0x5d5e2f39, 0x83ba85e1, 0x33e124b8, 0x8211e12f, 0x39122114,
    0x1421c082, 0x0b944806, 0x43161621, 0x35200742, 0x5d080884, 0x2223022e, 0x3e270706, 0x1e323303, 0x514e0202, 0x28585845, 0x46567e53, 0x843f397b,
    0x6b586235, 0x5c626260, 0x2f231454, 0x33613b1b, 0x443d1d45, 0x69452c4c, 0xe7042346, 0x17186a4e, 0x643c4e6a, 0x1f192847, 0x53262285, 0x71434a49,
    0x2f20404f, 0x25290e1e, 0x1a251760, 0x533c220f, 0x1d640100, 0x00062e0d, 0x0c0f8005, 0x0c020c5f, 0x1a5d2f00, 0x051d64cd, 0x033e3d08, 0x0e153337,
    0x01230703, 0x2f2f1689, 0x10db102a, 0x23514d3f, 0x1df40479, 0x2251514c, 0x58511b15, 0x00001c53, 0xfeae0001, 0x04120414, 0x001d004a, 0x0d224037,
    0x550a4709, 0x201f101f, 0x3507db47, 0x1c471d14, 0x1b1a1e54, 0x16115003, 0x091c150b, 0x333f000f, 0x2b703f3f, 0x5d322305, 0x257df610, 0x057b4605,
    0x11331125, 0x4c232723, 0x966f0517, 0x01333b07, 0x526f6a64, 0xb61c436e, 0x300a1b93, 0x6a486790, 0x02020123, 0x01b6b601, 0x30568287, 0x53932d08,
    0x262a2e54, 0x2a552328, 0x3606c0fe, 0x71289382, 0x6604fcfe, 0x13001406, 0x2d089382, 0x00990421, 0x40053005, 0x04055005, 0x0d050506, 0x15009901,
    0x00011510, 0x020d100d, 0x0012030d, 0x2f000005, 0x01c13f32, 0x105d5d2f, 0xb141e1d6, 0x07cc6005, 0x5f061121, 0x240807b7, 0x66042133, 0x3d79cf78,
    0x6d9b5f55, 0xa677413c, 0xfe330264, 0xf97906fc, 0x12330387, 0x8cc07633, 0x3278c593, 0x26798200, 0x01480293, 0x825e0391, 0x40332b79, 0x8015101a,
    0xa0159015, 0x45180415, 0xe5271d9e, 0x5d2b2f01, 0x435ded5d, 0x932011fd, 0x210f197a, 0xa94fd302, 0x23360812, 0x980114fe, 0x19000000, 0x1f403900,
    0x15131314, 0x128f127f, 0x06121202, 0x1b00840d, 0x8c121a06, 0x0e094015, 0x13151548, 0x00038d0a, 0x392fe12f, 0x01e12b2f, 0xed82c610, 0x2f391127,
    0x1133335d, 0x20ef8233, 0x22ea8214, 0x42352726, 0x34080686, 0x3727022e, 0x031e0733, 0x968d9801, 0x0f0f2d16, 0x50471031, 0x253f2e1a, 0x2239795a,
    0xfe192b3a, 0x066c61e1, 0x03036c03, 0x2318312b, 0xb009131a, 0x291a0873, 0x08ff833a, 0x4a023f3c, 0xb605ba01, 0x34000e00, 0x104f2140, 0x1002107f,
    0x480a0640, 0xe1020e0e, 0x8f037f00, 0x03200203, 0x03020330, 0x090ddd02, 0x00dc00e5, 0x3fcde13f, 0x5d5d2f01, 0x2f33e133, 0x72525d2b, 0x11530805,
    0x37023e34, 0x07070606, 0x87330127, 0x03030191, 0x16260e01, 0xb6054a5e, 0x040294fc, 0x383c3c19, 0x11281116, 0x00006049, 0x03420002, 0x058b0210,
    0x001300c7, 0xb22e001f, 0xb800e01a, 0x1440c0ff, 0x00480f09, 0x01210f21, 0x200ae014, 0xc005e417, 0x490fe41d, 0xf582051b, 0x5de1d625, 0x702bd610,
    0x6c5b0701, 0x0bd35c0a, 0x8b023408, 0x446d4d29, 0x2b4e6a3f, 0x446d4c29, 0x2c4e6b3e, 0x564b3afe, 0x554b4b55, 0x6d044b56, 0x2f598253, 0x5382592f,
    0x2e588153, 0x5381582e, 0x77797977, 0x83737378, 0x0054248f, 0x48960373, 0x562206eb, 0xd0482f40, 0xeb072406, 0x820a0204, 0x0b033701, 0xeb000e09,
    0x1001039f, 0x40032003, 0x0d030303, 0x00060a07, 0x01820a03, 0x230be348, 0x2f2f3d39, 0x2309e348, 0xc610e15d, 0x2d05e248, 0x5de13311, 0x01013031,
    0x37031327, 0x06850501, 0x96032008, 0xed74cafe, 0x360174ed, 0xcbfe68fe, 0x75eeee75, 0x0e023501, 0x014e65fe, 0x4e5c015c, 0x891b62fe, 0x003f080a,
    0x3f00ffff, 0x8b050000, 0x2600b605, 0x00007b00, 0x17022700, 0x00004a02, 0x3c020701, 0xb7fdfc02, 0x1d403000, 0x18160203, 0x16bf0203, 0x01168f01,
    0x1601163f, 0x01114001, 0x11011100, 0x82004000, 0x355d2307, 0x03845d11, 0x35355d26, 0x35353f00, 0x2c205182, 0xa0205182, 0xed205185, 0x35205185,
    0x00235183, 0x82330374, 0x40282d51, 0x18140218, 0x01140002, 0x11b00114, 0x11244c83, 0x01007000, 0x49844c85, 0x4a835182, 0x1f204982, 0xce224982,
    0x9b82c905, 0x9b867520, 0x4983a820, 0x033c0223, 0x2549823f, 0x0327403c, 0x9b823802, 0x38702108, 0x01385001, 0x33b40138, 0x0133a401, 0x64013384,
    0x33500133, 0x01333001, 0x33013320, 0x5d014c0f, 0x5d20a382, 0xac840083, 0x0032a784, 0xfe440002, 0x04440377, 0x0027005e, 0x4044003b, 0xff7d3212,
    0x0b320806, 0x3d0f3d14, 0x460b0801, 0xc0ffb81c, 0x1b0f1040, 0x170b1c48, 0x9b2d2727, 0x10131037, 0x2f001751, 0xe53f33e1, 0x39122f32, 0xe12b2f01,
    0xce105d5e, 0x12823911, 0x31e12f29, 0x14150130, 0x6307020e, 0x322406e5, 0x06173736, 0x24082b44, 0x35033e37, 0x0f7c5335, 0x10500224, 0x057e4127,
    0x54373407, 0x52404596, 0x955d61bc, 0x351b3867, 0x42343651, 0x53ba0e26, 0x25241199, 0x4c515b3a, 0x3509057e, 0x2a922333, 0x8a60333a, 0x5a684458,
    0x432d2f54, 0x132b433e, 0x10442f01, 0xffff220e, 0x08008200, 0x07dd0426, 0x00260273, 0x01000024, 0xff430007, 0x005201bd, 0x1502b415, 0xb8022605,
    0x1bb49cff, 0x25070415, 0x00352b01, 0x2f920282, 0x8d007622, 0x13242f82, 0x21020b40, 0x6c223082, 0x2d9b1b15, 0x004b0123, 0x225d8b1f, 0x931db4ff,
    0x8735205d, 0x202b828d, 0x205d8606, 0x225d821d, 0x922c1e01, 0x882b205d, 0x006a22bb, 0x2c2d8221, 0x030d4017, 0x26051e02, 0x15010203, 0x832f8529,
    0x003521bc, 0x0420bd88, 0x24083186, 0x1f500106, 0x4031007d, 0xef020320, 0x1adf011a, 0x011a5001, 0x20011a40, 0x1a10011a, 0x011a0001, 0x0002031a,
    0x21a0861f, 0x2a420035, 0x35320808, 0xff020000, 0x060000fe, 0x00b60556, 0x0013000f, 0x062a4084, 0x5a0e0a13, 0x10011101, 0xa9130403, 0x13240113,
    0x13541334, 0x01011003, 0x13010c14, 0x04820c01, 0x05033b08, 0x15670008, 0xffb80504, 0x052040f0, 0x065f1309, 0x0d105f03, 0x0a4f0a5f, 0xaf0a0f01,
    0x1008020a, 0x060a100a, 0x5f0e0403, 0x00120105, 0x2fe1333f, 0x2f39393f, 0x715d5e2f, 0x0183e110, 0x2f013228, 0xe6103338, 0x487f1132, 0x5d5d2706,
    0xc4c4877d, 0x21520111, 0x05ef7a05, 0x01230322, 0x0806537a, 0x01211152, 0x06231121, 0xfe08fd56, 0x02bacb25, 0xfdc9038f, 0xfd1602c3, 0xfb3d02ea,
    0x6c930175, 0x3bfec501, 0xfea4b605, 0xf8fda23c, 0xa802c601, 0x00ffff00, 0x0414fe7d, 0x02cb0598, 0x00260026, 0x00070100, 0x00fc017a, 0xb60b0000,
    0x242a4f01, 0x01252018, 0x2a05ff41, 0x030000c7, 0x027307be, 0x84280026, 0xff433425, 0x005201b7, 0x0c01b415, 0xb8012605, 0x12b4c2ff, 0x4200010c,
    0x2f8f0a2f, 0x3f007622, 0x2105d141, 0x30821801, 0x120c4a22, 0x01232d9b, 0x8bf1ff4b, 0xb4fd225d, 0x205d9314, 0x228d882b, 0x42f5ff6a, 0x02290501,
    0x26051501, 0x0c010102, 0x425f8520, 0x3e240801, 0x64020000, 0x2c20bf84, 0xfe21bf85, 0x20618bb5, 0x20bf8fa8, 0x202f8252, 0x222f8a8a, 0x8a78ff76,
    0x8e6a20bf, 0x821120bf, 0x89a9202d, 0x20bf822d, 0x202d860f, 0x20ed820c, 0x20bd8e02, 0x212d8240, 0xbd830777, 0x6a228b85, 0xbd8c0dff, 0xbd8d0020,
    0x02004008, 0x00002f00, 0xb605fc04, 0x1f001000, 0x3a405d00, 0x110e1a1a, 0x2167085b, 0x18012120, 0x100e5a1c, 0x640e0110, 0x5f101b20, 0x01000f18,
    0x003f000f, 0x00af006f, 0x00ff00df, 0x40000806, 0x82481d1a, 0x1c22086e, 0x17120e60, 0x00030260, 0xe13fe13f, 0x2b2f3911, 0x33715d5e, 0x100132e1,
    0x2f3232e6, 0x5d32e110, 0x1683f610, 0x13303123, 0x05d17d33, 0x02141538, 0x21230406, 0x34252311, 0x2323022e, 0x21152111, 0x00203311, 0xd77d982f,
    0x60450805, 0xa8f7feb6, 0x049892fe, 0xb87e4208, 0x5001c975, 0x01a2b0fe, 0x030c0108, 0x5c910225, 0xb0f4feb5, 0xbbe9feb9, 0x6083025e, 0x438ad592,
    0xfea20efe, 0xff24011d, 0x00c700ff, 0x070e0500, 0x00260235, 0x01000031, 0x20f58207, 0x0627418b, 0x26052027, 0x2f210a01, 0x0b43420a, 0xecff7d26,
    0x73077105, 0x32202d82, 0x2105b341, 0x2d825400, 0x02b4152c, 0x02260528, 0xb4abffb8, 0x2f9c282e, 0x02017622, 0x02215d85, 0x22308234, 0x9b2e2858,
    0x4b01232d, 0x2d86ae00, 0x05215e83, 0x835b9330, 0x828b84b9, 0x857d2029, 0x8430208b, 0xb4f0238b, 0x5d923f31, 0xbb882b20, 0xaa006a22, 0x2905e341,
    0x05310203, 0x01020326, 0x2f853c28, 0x0805a142, 0x00010021, 0x032d018d, 0x007b04dd, 0xb987000b, 0xf0ff0600, 0x481714b3, 0xe0ffb806, 0x120f1840,
    0x82100048, 0x2000210d, 0x09200982, 0x09200983, 0x03210983, 0x822485b8, 0x40e02207, 0x341a8230, 0x07010d40, 0x0b030505, 0x03500101, 0x0a080301,
    0x0202040a, 0x2a598220, 0x50002000, 0x80007000, 0x5500a000, 0x092c054a, 0x00b30006, 0x5d5e3f19, 0x33113271, 0x01240282, 0x11335d2f, 0x5d240184,
    0x2b003031, 0x01200082, 0x56080484, 0x01013701, 0x07010117, 0x01270101, 0x69c2fecb, 0x42013d01, 0x01bffe68, 0xbefe663f, 0x0267c3fe, 0x693f01d3,
    0x3e01c2fe, 0xfebffe67, 0x3d0166c0, 0x0067c5fe, 0x7d000300, 0x7105b4ff, 0x1a00fc05, 0x31002600, 0x3a405c00, 0x1e2a1f29, 0x5b271b04, 0x0e0b1901,
    0x78041104, 0x1b390fff, 0x3266115b, 0x2a1e291f, 0x5f222d04, 0x0b0e0119, 0x161a0904, 0x0c5f2d04, 0x06547709, 0x39171226, 0x391711e1, 0x8209617a,
    0x3210830c, 0x07013031, 0x14151216, 0x23060602, 0x27072722, 0x18022637, 0x08070c50, 0x01371780, 0x01171614, 0x22232626, 0x1005020e, 0x16160127,
    0x023e3233, 0x5b5c1405, 0xeda0515e, 0x4e85bd9b, 0x5b615a89, 0xa3f09e4c, 0x5042a15e, 0x302eb7fc, 0x72304302, 0x6ca67247, 0x586a0334, 0x722fbefd,
    0x6ba57245, 0x95ae0532, 0xb7defe63, 0xc6eafea9, 0x4e7f476c, 0x2a016491, 0x1501aabe, 0x262a6bc4, 0x83e1fc7f, 0xb1034ed1, 0x9751201d, 0x01018ada,
    0x1c54fc97, 0xdb99511e, 0xb800ffff, 0x5d47ecff, 0x42382006, 0x3d3106b9, 0x15005201, 0x051801b4, 0xffb80126, 0x181eb4c0, 0x0be9420b, 0x76222f8f,
    0x8b42c500, 0x24012105, 0x48223082, 0x2d9b1e18, 0x004b0123, 0x225d8b79, 0x9320b4fd, 0x022b235d, 0x8d850026, 0x7d006a22, 0x29058b42, 0x05210102,
    0x01010226, 0x5f852c18, 0x220c2f47, 0x82730737, 0x843c2031, 0x007622bf, 0x208f8631, 0x248f8215, 0x070f0963, 0x07eb4502, 0x00020022, 0x3f077b7b,
    0x001b0010, 0x1721403c, 0x1d67005b, 0x10011d9f, 0x0b11011d, 0x64085a07, 0x0660111c, 0x060b601b, 0x07200182, 0x2806707b, 0x2f393912, 0x10e1102f,
    0x051871e1, 0xc1685d20, 0x14012c05, 0x2323020e, 0x33112311, 0x7b323315, 0xba211373, 0x0d737bb0, 0x5b0e032b, 0xfe4d81a8, 0xfcb605c3, 0x07747b39,
    0x82888f21, 0x005d08b2, 0x04ecffae, 0x001f0675, 0x406d004b, 0x2e460748, 0x0f004735, 0x2f191f19, 0x40190319, 0x5f48130d, 0x022e6f2e, 0x001f000f,
    0x0803002f, 0x00002e19, 0x4103192e, 0x57114724, 0x204d104d, 0x034dc04d, 0x54414740, 0x3507244c, 0x503a1603, 0x15410147, 0x161a501f, 0x333f0016,
    0xe13f3fe1, 0x068a4212, 0x83f61021, 0x2f2f270a, 0x5d5d5e2f, 0xcd835d2b, 0x82303121, 0x150421c2, 0x20095258, 0x07f77923, 0x260b5766, 0x2e343504,
    0x67222302, 0x34200501, 0x0805bc70, 0x2bf20353, 0x2b3f4b3f, 0x3946270e, 0x213d5838, 0x558d6538, 0x1a358b61, 0x254c4841, 0x18345138, 0x38482b11,
    0x1635553f, 0x3e483e29, 0x533c2129, 0x42583133, 0x713fb627, 0x985c5c9c, 0xec043c6c, 0x3c495939, 0x151e3637, 0x26312721, 0x60524825, 0x517e573e,
    0x06786627, 0x2d194d08, 0x3b242840, 0x28233a38, 0x2a464344, 0x363f4f36, 0x2a2c433a, 0x1313293e, 0xfb415330, 0x68b0044e, 0x2625558d, 0xffff744c,
    0xecff5e00, 0x21069c03, 0x44002602, 0x06010000, 0x00944300, 0x02b41500, 0x02261133, 0xb4e5ffb8, 0x220c3339, 0x9207f741, 0x3576282d, 0x40130000,
    0x823f020b, 0x3385222e, 0x222b9b39, 0x85e24b01, 0x215a832b, 0x57923b33, 0x87e30521, 0x52012285, 0x202b85bd, 0x2257823b, 0x914a3c29, 0xd9052157,
    0x6a30b188, 0x170000de, 0x02030d40, 0x0326113c, 0x47332f02, 0xd9422d85, 0x20e18508, 0x205b8887, 0x202f8750, 0x212f8338, 0x89863d30, 0x00222f85,
    0x2f820003, 0x44066108, 0x38005e04, 0x50004700, 0x1a407c00, 0x1e4b142f, 0x42420448, 0x26484c00, 0x4f52571d, 0x9f525f52, 0x48390352, 0xffb80e00,
    0x0d2e40c0, 0x0e0e4811, 0x00515600, 0x02421042, 0x00501e42, 0x02041004, 0x1f4b0f04, 0x4b07024b, 0x3c21114b, 0x342c2f50, 0x0a0d4816, 0x11141750,
    0x333f0010, 0x3232e133, 0x11360584, 0x5d5e2f39, 0x32e15d33, 0xe610015d, 0x102b2f32, 0xf6105de1, 0x055fe132, 0x05be5a05, 0x210ff874, 0xfe741716,
    0x72152006, 0x23230a2e, 0x57272622, 0x372205c6, 0xaf571614, 0x0e072405, 0x72220103, 0x5e200544, 0x080d0f75, 0x2ba68327, 0x6167a633, 0xfd396c9a,
    0x93930560, 0x4a4e5531, 0x4f4b2725, 0xca8a3155, 0x5f4c223e, 0x7b474a74, 0x61bd345a, 0x0831754f, 0x6e85032b, 0xd7010b7f, 0x0154371a, 0x0d337533,
    0x555d5523, 0x0f74725d, 0x3673722c, 0x271f3b55, 0x5c527b51, 0x4c752656, 0x63023708, 0x7144959c, 0xff002c50, 0xfe7100ff, 0x046f0314, 0x0026025e,
    0x7d4a0046, 0x00422c05, 0xb60b0000, 0x20262f01, 0x4a250d05, 0x7126067d, 0xe103ecff, 0x25822106, 0x97424820, 0x11282b0b, 0xffb80226, 0x282eb4b9,
    0x97420f05, 0x212d8f0a, 0x3f425276, 0x82342005, 0x2876222e, 0x222b9b2e, 0x85de4b01, 0x215a832b, 0x57923003, 0x88d90521, 0xda6a2185, 0x27066b42,
    0x03261131, 0x3c280002, 0x3b425985, 0xffff2205, 0x214a82ff, 0xb5846701, 0xdb84f320, 0x55fe4322, 0x152cdb82, 0x110401b4, 0xffb80126, 0x040ab49a,
    0x240c054b, 0x020000ae, 0x222f8a42, 0x8230ff76, 0x4013242f, 0x8210010b, 0x04742230, 0x212d8b0a, 0x2d82bdff, 0x2d895520, 0xfe4b0123, 0x832d86bb,
    0x0c00215e, 0xff215b8c, 0x202d82ee, 0x85bb8425, 0x846a208b, 0x40172c2d, 0x0d01020d, 0x01022611, 0x4b180400, 0x61080b31, 0x6f000200, 0x2d04ecff,
    0x27002306, 0x74003900, 0x28124640, 0x20230048, 0x1c041916, 0x221c1822, 0x03181c22, 0x3b57000a, 0x3bd03b40, 0x0f033be0, 0x3206013b, 0x3a560a48,
    0x16231920, 0x21211704, 0x0f502d1d, 0x0faf0f12, 0x30020fbf, 0x0f17010f, 0x011d0f17, 0x16055037, 0x3fe13f00, 0x2f2f3939, 0xee615d5d, 0x45112005,
    0x5e24064b, 0xe6105d5d, 0x8305e24c, 0x53102012, 0x516e05f2, 0x1716270b, 0x27262637, 0x05832705, 0x82163721, 0x0717240d, 0x4507031e, 0x14250748,
    0x3233021e, 0x05676e36, 0xaf688708, 0x763f477f, 0x9a6669a8, 0x781f082b, 0x4a00ff5a, 0x2f5528d9, 0x3b7a4146, 0x43c34ae3, 0xbc2c4f6f, 0x4b6e4622,
    0x21466d4d, 0x4c6d4721, 0x3d02879a, 0x4f98dc8e, 0x77b97f42, 0x417eb877, 0x76043c3b, 0x729951c0, 0x1a371c83, 0x2c48207b, 0x4175718a, 0xb0ddbb9c,
    0x32526b38, 0x5583582e, 0x315a7d4c, 0xffff00c7, 0x0000ae00, 0xe3051204, 0x51002602, 0x06010000, 0x00f95201, 0x0b401300, 0x26112101, 0x30220201,
    0x9142170b, 0x2d04230d, 0x2b822106, 0xbf425220, 0x00d82f05, 0x02b41500, 0x02261120, 0xb4d7ffb8, 0x3b4a2026, 0xff71220c, 0x212d8cec, 0x59845076,
    0x822c0221, 0x204e222e, 0x222b9b26, 0x8afb4b01, 0xb4fa2259, 0x84599228, 0x228784b3, 0x84e25201, 0x8428202d, 0xb4fd2387, 0x5b913729, 0x88d90521,
    0xf96a2bb5, 0xb6190000, 0x11290203, 0xb7820326, 0x20b4f923, 0x0cc34a34, 0x00037508, 0x04f80066, 0x00ac0402, 0x00170003, 0x4060002b, 0x012d3015,
    0x1818aa22, 0x0356aa0e, 0x28020366, 0x02033803, 0xffb80003, 0x092840f0, 0x0400480d, 0x1d10ad27, 0x011d0f01, 0x09011d1d, 0x101300ad, 0x60132013,
    0xc013b013, 0x0713d013, 0x00131307, 0x00b301ad, 0x2f33e13f, 0x11e15d5e, 0x715d2f33, 0x332f01e1, 0x5d5d332b, 0xe12f33e1, 0x1330315d, 0x01152135,
    0x0e435218, 0x0f535218, 0x9c036634, 0x1f12bffd, 0x2a171829, 0x20121220, 0x2918172a, 0x0f8f121f, 0x96870236, 0x23eefe96, 0x0d0d1e2f, 0x21232f1e,
    0x0e0e1f2f, 0xdb022f1f, 0x5508108e, 0x00030000, 0x04b4ff73, 0x0091042f, 0x0024001a, 0x405c002d, 0x281f273b, 0x251b041e, 0x16181748, 0x0a080715,
    0x000d0809, 0x2f402f57, 0x2fe02fd0, 0x012f0f03, 0x0d481b06, 0x1e282e56, 0x2b041f27, 0x0a075022, 0x05041518, 0x2b101216, 0x16050850, 0xe1c63f00,
    0xdc4ac63f, 0x5d5e240a, 0x4af6105d, 0x142209db, 0xd64a020e, 0x35262106, 0x1627e584, 0x07173717, 0x4a051616, 0x062207d9, 0xd84a3405, 0x04363405,
    0xb27d432f, 0x44627d6f, 0x463f5083, 0x6fb37c43, 0x8231713f, 0x453e330b, 0x161300fd, 0x4b1d8d01, 0x02879a2d, 0x72fe2744, 0x0983481f, 0xd5892729,
    0x6d354c91, 0x7148834a, 0x26080576, 0x496c1c1d, 0x86d14981, 0x02338354, 0xcf121187, 0xfd639fd1, 0xd310117b, 0x00ffff00, 0x04ecffa4, 0x02210608,
    0x42580026, 0xa33105bb, 0xb4150000, 0x26111b01, 0x9bffb801, 0x0c1b21b4, 0x0ae94219, 0x76282d8f, 0x13000060, 0x27010b40, 0x57222e82, 0x2b9b211b,
    0x084b0122, 0x5a832b85, 0x92230021, 0xd9052157, 0x6a2b8588, 0x19000002, 0x240102b6, 0x82022611, 0xb4fb2387, 0x5b852f1b, 0x2408e947, 0x0314fe0a,
    0x20b784df, 0x21b7845c, 0x5d850e76, 0x89822f20, 0x29236723, 0x08314600, 0x08076772, 0x0014062a, 0x00310020, 0x2f1f4038, 0x33570a48, 0x27013310,
    0x1b151f20, 0x32541c47, 0x1b1b001d, 0x0f15502c, 0x00502116, 0x3f001005, 0x200a8d7a, 0x4a008232, 0x875906bd, 0x14152505, 0x2223020e, 0x220c7472,
    0x72250711, 0x01210d6a, 0x0b5c7264, 0x2806de7b, 0x04020303, 0x0108b6b6, 0x0bc2711f, 0x72b60321, 0x78720b5e, 0x0008250a, 0x119436fe, 0x220d6d72,
    0x8400ffff, 0xd90524f5, 0x85002602, 0xb16a30f5, 0x40170000, 0x2c01020d, 0x01022611, 0x8537230b, 0x0ce94bf7, 0xc106dd22, 0x22087953, 0x5333004d,
    0x172905a9, 0xb8022605, 0x15b4ffff, 0x0c7b5316, 0xecff5e26, 0x6f059c03, 0x21083f49, 0xc749e64d, 0x82352005, 0x3323225e, 0x056d4934, 0x200c3354,
    0x225b8840, 0x4c21004e, 0x02210545, 0x535c821a, 0x2d860862, 0xee205985, 0x4e215988, 0x205985d4, 0x20598238, 0x07974925, 0x00262b86, 0xdd0442fe,
    0x5988bc05, 0x62035126, 0x14000000, 0x803ae782, 0x27300127, 0x27270001, 0x01250000, 0x355d5d2b, 0x5e00ffff, 0xb80342fe, 0x59865e04, 0x51010724,
    0x2d825a02, 0x16402035, 0x0145f002, 0x900145a0, 0x45800145, 0x01453001, 0x86454500, 0x855d2036, 0xff7d2639, 0x079804ec, 0x081b5373, 0x0a017622,
    0x0127c185, 0x01260530, 0x532a24cd, 0x23530620, 0xff712605, 0x066f03ec, 0x06cb4821, 0x76000636, 0x1700004a, 0x2c010e40, 0x10012611, 0x20a70120,
    0x250d0526, 0x35209482, 0x5d8ec586, 0x004b0123, 0x0af54db4, 0x532c7721, 0x5d89077e, 0x5d898f20, 0xf54b0122, 0x20205d85, 0x28235d83, 0x49285301,
    0x5d20052f, 0x37205d8d, 0x0123bb87, 0x8600024f, 0x822f205d, 0x248022bb, 0x21bb912c, 0xbb86e505, 0x4f010725, 0x85003301, 0x852b205f, 0x204d22bd,
    0x22bd9d28, 0x86a8004c, 0x8229205f, 0x2f6b215f, 0xa020bd91, 0x4c21bd8a, 0x205d8506, 0x235d8325, 0x2b64012b, 0xc726bd8e, 0xfc040000, 0x8f827307,
    0x00002728, 0x4c010701, 0x97424a00, 0x051d2a05, 0xffb80226, 0x1823b4b7, 0x0b414f06, 0xecff7126, 0x14065205, 0x47202f82, 0x02232f83, 0x82d90238,
    0xb60b28bf, 0x3e3e5e02, 0x4a251d1d, 0x47530647, 0x06022306, 0x1d829200, 0x82000221, 0x04420835, 0x0014069e, 0x00380027, 0x1f314055, 0x472d001b,
    0x0b1d1d26, 0x3a552622, 0x36013a10, 0x39560b48, 0x1d251527, 0x1e1e224f, 0x33002010, 0x10001650, 0x10201010, 0x28101003, 0x16060050, 0xe1333f00,
    0x03825d3f, 0x2f391225, 0x7532e133, 0xe62b06b5, 0x2f391132, 0x3232e110, 0x7e303132, 0xa76716a4, 0x33152305, 0xac7e2315, 0x85fe272a, 0x9cb67b01,
    0xb27e939c, 0x46250812, 0x8786cc8a, 0x19478bce, 0x21203a2c, 0x10371a1f, 0xb6b6899e, 0x832bfb89, 0x5a85592c, 0x66956127, 0xc6c3cf34, 0x058153c3,
    0x06be0323, 0x073955c1, 0x004d0122, 0x2607d142, 0x0126050e, 0x4a0d0c02, 0x71260c91, 0xe103ecff, 0xf14a6f05, 0x432d8207, 0x2a260593, 0x11022611,
    0x494b2928, 0x05f1550c, 0x59884020, 0xfbff4e22, 0x20060f42, 0x21598211, 0xc1551606, 0x2059850d, 0x215988ee, 0x5985ea4e, 0x59822d20, 0x4b320f21,
    0x59850d77, 0x59881a20, 0x3f014f2a, 0x13003501, 0x17010b40, 0x07225982, 0xb392140c, 0x5986e520, 0x4f010725, 0x85002b01, 0x8233205b, 0x280c225b,
    0x25b58d30, 0xbe0342fe, 0x5b88b605, 0x21025122, 0x0e382d82, 0xff0100b9, 0x1212b4c1, 0x01250000, 0xffff352b, 0x61fe7100, 0x5e04e103, 0x23085588,
    0x003b0251, 0x4027001f, 0x3bf00213, 0x013be001, 0x90013ba0, 0x3b50013b, 0x013b0001, 0xb4caffb8, 0x1a1a3b3b, 0x5d203a82, 0x35210084, 0x07794100,
    0x23094157, 0xf9ff4c01, 0x210a1f41, 0x1f411704, 0x09f14c12, 0xe44c0122, 0x21091f41, 0x1f413309, 0xff7d240d, 0x84f204ec, 0x002a2859, 0x01070100,
    0x86d7004b, 0x052c2859, 0x346d0126, 0x47010c2c, 0x25240aa1, 0xfc0314fe, 0x4a205984, 0x06232d82, 0x84c64b01, 0x5f032859, 0x03032611, 0x55275f67,
    0x59820e81, 0xf5824020, 0x4e225985, 0x5986c900, 0x59823120, 0x92365f21, 0xee052159, 0x59852d82, 0x00b14e27, 0x03b41500, 0x24588264, 0xb4efffb8,
    0x205b9369, 0x225b8837, 0x860c024f, 0x8337205b, 0x342c215b, 0x0521b591, 0x255b86e5, 0x004f0107, 0x5d8400f2, 0x5d846a20, 0x5fb4ec23, 0x25b98d67,
    0xf2043bfe, 0x5d87cb05, 0x01390223, 0x252f8217, 0x5101b60b, 0x5886322c, 0x00ffff22, 0x220e0b41, 0x412d3a02, 0xb283050b, 0x8d651c21, 0x00c726af,
    0x07d50400, 0x21518273, 0x6541002b, 0x587f2005, 0xff240b41, 0x050c14b4, 0x200b3b41, 0x222f82ae, 0x82aa0712, 0x864b202f, 0x012b392f, 0x401f0089,
    0x010d7014, 0x01010c70, 0x1a011a70, 0x19012602, 0x180b1a22, 0x27059e41, 0x5d5d355d, 0x00020000, 0x30080082, 0xb6059c05, 0x17001300, 0x2f405600,
    0x5a0c0414, 0x19650b07, 0xaf0119b0, 0x19100119, 0x0f031701, 0x6410005a, 0x175f0e18, 0x60120a16, 0x13030713, 0x24018217, 0x120b1001, 0x05496c05,
    0x39123325, 0x6c2f2f39, 0x32220546, 0xd77ee110, 0x5d323005, 0xf6105d5d, 0x3232e132, 0x35133031, 0x82211533, 0x15332603, 0x11231123, 0x38038221,
    0x35013523, 0xbac71521, 0xc7ba9a02, 0x66fdbac7, 0x1b04c7ba, 0xc30466fd, 0x080082f3, 0xd3fb964f, 0x56fdaa02, 0xfe962d04, 0x00dfdf8b, 0x00120001,
    0x06120400, 0x00210014, 0x13344055, 0x2147000b, 0x23102355, 0x23802360, 0x12161703, 0x0b0f470a, 0x0d152254, 0x0ebf124f, 0x0e020ecf, 0x0417100e,
    0x101d0050, 0x031d201d, 0x0010101d, 0x06ea7f0b, 0x82e15d21, 0x5d2f24a7, 0x8632e133, 0x823220a0, 0x12e1229f, 0x0d777d39, 0x33352322, 0x2123a882,
    0x7f152115, 0x9c2711fe, 0x7b01b69c, 0x180885fe, 0x08080440, 0x82829a2f, 0x60946634, 0xd504f0fd, 0x89b6b689, 0x3f2b90b8, 0xd2bf142a, 0xff005cfd,
    0x00f5ffff, 0x07c40200, 0x00260235, 0x0100002c, 0xfe520107, 0x067142f3, 0x26051426, 0x23150101, 0x210b4744, 0x2d82a3ff, 0xe3057222, 0xf3202d82,
    0xa1202d86, 0x22054744, 0x82110c01, 0x1b0d212d, 0x200c7544, 0x222d823d, 0x88c1067c, 0xff4d225b, 0x205b8622, 0x455b830e, 0xff210d57, 0x222d82eb,
    0x886f052a, 0xfe4d225b, 0x205b86d0, 0x215b8306, 0x5b8c0504, 0x2d823020, 0x40078a22, 0x4e215b88, 0x075d5aff, 0x5b821120, 0x59450220, 0xdeff210d,
    0x38222d82, 0x5b88ee05, 0xbdfe4e22, 0x09205b86, 0x02215b82, 0x0c17500e, 0xfe520027, 0x05640242, 0x225b88b6, 0x439c0051, 0x00210527, 0x07a25b19,
    0x00ffff29, 0x0142fe44, 0x82e50583, 0x004c2f25, 0x01060100, 0x00002551, 0x020a4010, 0xa882256f, 0x25240b82, 0x355d2b01, 0x52202782, 0x64227b82,
    0x4d883707, 0x50004f22, 0x20060541, 0x20a98217, 0x0ba94500, 0x2405577c, 0x4a046401, 0x0fff7f00, 0xff7f0f20, 0x4a042113, 0xfe265f83, 0x0529047b,
    0xc14100b6, 0x2d002306, 0xad82b602, 0x40382808, 0x7f18010e, 0x184f0118, 0x07401801, 0xb8184807, 0x1740c0ff, 0xbf480606, 0x21a00121, 0x01218f01,
    0x0f012150, 0x83210121, 0x5d2b211c, 0x2b200083, 0x11200682, 0xa026b183, 0x870314fe, 0x5182e505, 0x0724d983, 0x12024d00, 0x2e3f5182, 0x02032040,
    0x011ecf1e, 0x9f0135df, 0x35800135, 0x01355f01, 0x20013540, 0x35000135, 0x82403501, 0x8247855b, 0x3511214b, 0xff234782, 0x5c7bfe48, 0x2d28065f,
    0x07010000, 0xcafe4b01, 0x1420f986, 0x1c23f983, 0x450e0d14, 0xff2b0983, 0x0214febc, 0x02210657, 0x86370226, 0x07a3412d, 0x26111424, 0x2d8d0001,
    0xfec7002b, 0x05a2043b, 0x002602b6, 0x2e2d822e, 0x73390206, 0xb90e0000, 0xb1ff0100, 0x44130db4, 0xff290573, 0xfeae00ff, 0x06f0033b, 0x20258214,
    0x2025854e, 0x25258621, 0x150fb4c4, 0x7d84050a, 0x00013708, 0x030000ae, 0x004a04f0, 0x40490011, 0x1010010a, 0x440f0f0e, 0xb8110111, 0x1c40c0ff,
    0x11480a07, 0x13111110, 0x132f130f, 0x03070702, 0x12540447, 0x050e010c, 0xb043040f, 0x39332705, 0xf6100139, 0x411832e1, 0x400808ff, 0x11393311,
    0x21303133, 0x23110701, 0x14113311, 0x07060706, 0x01330137, 0xfe230301, 0xb4b46dac, 0x04040305, 0xcd330183, 0xac016ffe, 0xfe51e901, 0xfe4a0468,
    0x26663ce7, 0x01b0242c, 0xfd16fe81, 0x0d1747a0, 0xb7822f20, 0x76000724, 0x574565ff, 0x05122b05, 0xffb80126, 0x0c06b470, 0x3b410400, 0xab002709,
    0x34020000, 0xe782ac07, 0x2f864f20, 0x8b012235, 0x14401f00, 0x70010370, 0x70010102, 0x02100110, 0x53660126, 0x5d23092e, 0x845d5d35, 0x3bfe2169,
    0x8306eb47, 0x02062369, 0x21412d39, 0x88dd2006, 0xffff2963, 0x3bfe6600, 0x14066c01, 0x02245f87, 0x00f7fe39, 0xe0212786, 0x475487b4, 0x052107cf,
    0x842782b7, 0x380234b7, 0xa3ff0001, 0x0d401600, 0x01030b01, 0x60010610, 0x83020c06, 0x625d20b7, 0xae2006bb, 0xb420b782, 0x06385788, 0x003b3802,
    0x11401800, 0x0e400401, 0x40044810, 0x5e480906, 0x03030404, 0x2b22e982, 0x5f88352b, 0x5f87b620, 0x014f012c, 0x0065fde3, 0xab01b60b, 0x10410e06,
    0x05855206, 0x06a2022b, 0x00260014, 0x0100004f, 0x08258207, 0x38fd2d21, 0x16402b00, 0xef0113ff, 0x139f0113, 0x01138f01, 0x5f01137f, 0x131f0113,
    0x01b80101, 0x4804b42e, 0x5d200669, 0x36820085, 0x1d003508, 0xbe030000, 0x0d00b605, 0x32406100, 0x0c05060b, 0x04030005, 0x0504040d, 0x08080a05,
    0x010faf0f, 0x0c010f10, 0x03060d0d, 0x000b5a07, 0x050e640a, 0x040c0d04, 0x012a0182, 0x120a5f07, 0x3f000301, 0x7146e13f, 0x11220806, 0xf6100133,
    0x32e13232, 0x332f3332, 0x33115d5d, 0x2f391211, 0x877d1033, 0x10c4c404, 0x31c4c487, 0x13821330, 0x17372508, 0x15211105, 0x27071121, 0x4ee3bac7,
    0x3d02cffe, 0x496109fd, 0x1203a402, 0x7d8f63fd, 0xa639febe, 0x7d3cf801, 0xff259982, 0x020000f6, 0x2ddf821d, 0x4069000b, 0x500d403b, 0x0609020d,
    0x9e830a05, 0x0b0a0b37, 0xdd04080b, 0x05bb0105, 0x0f0205cb, 0x2f051f05, 0x05060305, 0x2aa48205, 0x08000947, 0x0a0b0c54, 0x820a0405, 0x07012401,
    0x82000115, 0x27a190a2, 0x5d5e2f32, 0x11335d5d, 0x9f88a982, 0x875d0121, 0x110722a1, 0x369f8223, 0x4e6bb6ae, 0x4e6ab6b9, 0x1e03f602, 0x794559fd,
    0x023ffd78, 0x5e79464a, 0x732008cb, 0x2307cb5e, 0xf2007600, 0x220abd4d, 0x531e1855, 0xae260c4b, 0x12040000, 0x2d542106, 0x76002f07, 0x1300006f,
    0x25010b40, 0x5c012611, 0x2d541f19, 0xfec7260c, 0x050e053b, 0x235987b6, 0xd9003902, 0x21078142, 0x5787b4e1, 0x2305f143, 0x5e041204, 0x02225387,
    0xa7424c39, 0xb4de2106, 0xa7915187, 0x004c0123, 0x26a7869c, 0x0126051d, 0x9b182300, 0x4c0128a7, 0x1500000c, 0x821e01b4, 0xffb825a6, 0x1924b4fa,
    0x5d82a98b, 0x04003408, 0x00b605a1, 0x00510027, 0x0100008f, 0xe8070206, 0x40290000, 0x5518001d, 0x0127ef27, 0x9f0127bf, 0x275f0127, 0x01272f01,
    0x08084027, 0x06402748, 0x452b4806, 0x1022053b, 0x328234f6, 0xfec70023, 0x08ed837b, 0x00250044, 0x182a404a, 0x205a1f0c, 0x20150404, 0x27b02765,
    0x01278f01, 0x27102700, 0x0e131702, 0x64155a14, 0x160d1f26, 0x18121503, 0x5f07120c, 0xe12f0000, 0x3f3f333f, 0x10013333, 0x3232e1f6, 0x5d5d5d32,
    0x774de610, 0x30312206, 0x09707c01, 0x18013521, 0x0809fd43, 0x2633012c, 0x35262627, 0x14113311, 0x8b03020e, 0x221b4d33, 0x4b252d4e, 0x08fd263d,
    0x04040608, 0x02d5ac05, 0x040307cc, 0x37ae0503, 0x5b188f64, 0x59180a81, 0x75270b29, 0x7d384141, 0x18200334, 0x6a09935b, 0x2f0805dd, 0x0028005e,
    0x0322403a, 0x470c1703, 0x102a5524, 0x802a602a, 0x161a032a, 0x29541747, 0x2050101a, 0x170f1810, 0x00500715, 0xe13f001b, 0xe13f3f3f, 0x7861b885,
    0x20b18b08, 0x6b461813, 0x03152111, 0x0221b182, 0x0d4818ee, 0x69022909, 0x436e5170, 0x1a94b61d, 0x2208fc48, 0x186d4822, 0x210a1448, 0x0b496d03,
    0x04c72306, 0x0649944a, 0x95fc3b05, 0x2f577b4d, 0x7d00ffff, 0x7105ecff, 0x2602c106, 0x00003200, 0x4d010701, 0x1342bc00, 0x2a022705, 0x00022605,
    0x13422928, 0xff71260c, 0x052d04ec, 0x0707566f, 0x144d012a, 0x40130000, 0x1122020b, 0x20212b82, 0x842b8c21, 0x40072159, 0x4e225988, 0x5986aa00,
    0x59822d20, 0x61320121, 0x59850d55, 0x5988ee20, 0x00004e27, 0x02b41500, 0x24588225, 0xb4ffffb8, 0x0dbd562a, 0x0f625b85, 0x53012308, 0x5b82ec00,
    0x0d40172a, 0x05340203, 0x43020326, 0x820d5361, 0x0e4957e7, 0x46530123, 0x051d5c00, 0x82112c21, 0x5645202f, 0x02210ebf, 0x08618200, 0x05a40644,
    0x001900cd, 0x405b002a, 0x01161436, 0x14001616, 0x27275a18, 0x67001209, 0x012c1f2c, 0x66095b1f, 0x4f5f172b, 0x140f0114, 0x080214af, 0x12191414,
    0x1a03115f, 0x24040e5f, 0x1913045f, 0x0012005f, 0x0185e13f, 0x18391221, 0x27089f60, 0x32e6105d, 0xe12f3911, 0x5d250483, 0x21213031, 0xc4591806,
    0x6517200c, 0xb67409be, 0x37362b08, 0x06262611, 0x2b0afda4, 0x5918305b, 0x623d07c1, 0xfdf40254, 0xfd1702c2, 0xfc3e02e9, 0x6ca67256, 0xa56b3434,
    0x265a3472, 0x0b095926, 0x245b186c, 0x65172008, 0x043a05e1, 0xda975185, 0x99db898a, 0x040f1251, 0x00111058, 0x71000300, 0xe106ecff, 0xdf825e04,
    0x00364108, 0x4064003f, 0x3f03133b, 0x31d0481d, 0x0b313101, 0x1c254837, 0x410f4157, 0x0141ff01, 0x2b014140, 0x40560b48, 0x3f1b501d, 0x0f023f2b,
    0x3f06013f, 0x343c2e3f, 0x10131650, 0x502e2010, 0x16060003, 0x2405bd5c, 0xe133333f, 0xd04e1832, 0x5d5d220a, 0x06b75c71, 0x32e15d2a, 0x30313939,
    0x27262205, 0x2109f868, 0xb55c3233, 0x14012114, 0x09d24c18, 0x2e34053d, 0x06222302, 0x82600507, 0xc63f41cc, 0x7fae6780, 0xb37c4347, 0x3fc3796f,
    0x1875b93c, 0x3711fc4e, 0x9a899afb, 0x978c8b96, 0xf004879a, 0x3e58391b, 0x140b8572, 0x706d6d70, 0x07544818, 0x696a6f23, 0x0f995c70, 0xd13b0230,
    0xdcd1c9d3, 0x4462cfce, 0x9c2c5071, 0x29450095, 0xa0042605, 0x26027307, 0x059f6a00, 0x6f647620, 0x05292b07, 0xffb80226, 0x231db4ee, 0x89480d02,
    0x00ae230a, 0x19570300, 0x00552705, 0x00060100, 0xd345ce76, 0x11232805, 0x17400126, 0x8a030e1d, 0xfec7262b, 0x05a0043b, 0x2b5b86b6, 0x77390206,
    0xb90e0000, 0xb6ff0200, 0x81825588, 0x3bfe6026, 0x5e040803, 0x51832582, 0x39020725, 0x8400f1fe, 0xff012327, 0x5187b408, 0x012aa991, 0x010e004c,
    0xb4150052, 0xa9842202, 0x28b4a923, 0x20a98c1d, 0x22a98272, 0x8721060a, 0x4c012357, 0x578270ff, 0x01b41523, 0x25aa821c, 0xb4e3ffb8, 0xad8c1722,
    0xecff6826, 0x7307c903, 0x36202f82, 0x21056349, 0xc5433b00, 0x40012805, 0x70012605, 0x4e083a34, 0x5a200be9, 0x3f202d82, 0x56205d84, 0x06232d82,
    0x41dc7600, 0x42200507, 0x5d225c82, 0x2b8c3c36, 0x0123598e, 0x86edff4b, 0x82342059, 0x3c222259, 0x8e2d8c34, 0x4b012259, 0x2059859b, 0x22598236,
    0x8c363e1c, 0xfe68262b, 0x05c90314, 0x22b388cb, 0x4135017a, 0xfa22073b, 0x57863ab4, 0x00ffff23, 0x2227825a, 0x825e043f, 0x24ad8327, 0x007a0007,
    0x242782f0, 0x0101b60b, 0x8250873c, 0x22a78f25, 0x86e6ff4c, 0x823920a7, 0x3f1b21a7, 0x4c21a79d, 0x20a78597, 0x21a7823b, 0xa78d4118, 0x3bfe1426,
    0xb6051204, 0x37277f82, 0x06010000, 0x41f93902, 0xd82506e1, 0x030e08b4, 0x066f5205, 0x3bfe2126, 0x46058f02, 0x57202582, 0x07242582, 0x5dff3902,
    0xf724cd87, 0x12241eb4, 0x14262787, 0x12040000, 0x4d867307, 0x4c010724, 0xa786c8ff, 0xa7820d20, 0x08130322, 0x71565185, 0xff212606, 0x06e802ec,
    0x2c558614, 0x6f380206, 0xb60b0000, 0x24246101, 0x05835018, 0x0a275c18, 0x000f5c08, 0x1f4c4073, 0x11e00111, 0xdf115f01, 0x11200211, 0x11401130,
    0x05bf0803, 0x050205ff, 0x5a060a05, 0x50010f01, 0x0202f002, 0x0201021f, 0x01770d02, 0x01970187, 0x01013103, 0x01100100, 0x07030120, 0x600d0a01,
    0x03000007, 0x0206120b, 0x0003035f, 0x3f32e13f, 0x332f3912, 0x490132e1, 0x33360579, 0x125d5d2f, 0x32e11039, 0x395d2f32, 0x715d5d5d, 0x11013031,
    0x0c453521, 0x82232007, 0xb6013c0b, 0xfe035efe, 0x27015ffe, 0xfebbd9fe, 0x013303d7, 0xfea4a4df, 0x62fd9521, 0x18959e02, 0x080a2f49, 0x6a002541,
    0x011f14b6, 0x051c1c20, 0x40c0ffb8, 0x480b0837, 0x2f270505, 0x02273f27, 0x47231b1f, 0x1f160f13, 0x18160216, 0x10100014, 0xb010a010, 0x0510c010,
    0x22111007, 0x1f1f144f, 0x4f1e150b, 0x181b181a, 0x890c3c49, 0x333324a6, 0x82325dc4, 0x115d2ba1, 0x332b2f33, 0x5d003311, 0x49183031, 0x35230c49,
    0x82333523, 0x37372303, 0xb8821533, 0x49180384, 0x8b2e1151, 0x4e9b9b8b, 0xfe140169, 0xfe0201ec, 0x49183ffe, 0xfb2c0d57, 0x4e51f88a, 0xf889fce6,
    0x6261fb8a, 0x21083d66, 0xaf650235, 0x52012306, 0x03826000, 0x01b4152c, 0x01260520, 0xb4ffffb8, 0x0f662f21, 0xffa4260c, 0x050804ec, 0x272f82e3,
    0x01000058, 0xf3520106, 0x22098744, 0x5b322406, 0xb8200c73, 0xef592b82, 0x82382005, 0x0107242b, 0x858f004d, 0x861a205b, 0x1918215b, 0x6f205b92,
    0x4d215b88, 0x265b8521, 0x0126111d, 0x911c1b05, 0x4007215b, 0x4e22b788, 0x694a7d00, 0x6622200b, 0xb5850d95, 0x5988ee20, 0x850c4e21, 0x82202059,
    0x25042159, 0x840dfd5b, 0xd90721b5, 0x50225988, 0x316b7b00, 0x051d2507, 0x00010226, 0xd75a5b87, 0x215d8408, 0x5d888706, 0x5d825020, 0x0d401724,
    0x5e820102, 0x05010222, 0x2f885f87, 0x230e8167, 0xb2005301, 0x24206187, 0x36206183, 0x83102367, 0x5d0e2061, 0x01240917, 0x00005053, 0x27216184,
    0x20918211, 0x108f5c48, 0x42feb826, 0xb805dd04, 0x512ac388, 0x00001902, 0x01b60b00, 0xde67250d, 0xffff2307, 0x2582a400, 0x4a041622, 0x0724b786,
    0xb8025101, 0x0e252585, 0x1a1a2121, 0x06c75825, 0x00001426, 0x7307fe06, 0x3a272582, 0x07010000, 0x45014b01, 0x2b27079f, 0x00012605, 0x501e2b33,
    0x00200a6d, 0x05212d82, 0x20a984e3, 0x212d855a, 0x5382ae00, 0x0b401325, 0x82113001, 0x3038232d, 0xe96f2e11, 0x0afb670e, 0xff4b0123, 0x06c541d0,
    0x5b820920, 0x09110222, 0x5c09fb67, 0x655d076f, 0x4b012209, 0x097b42a9, 0x232b0222, 0x8209655d, 0x2374822b, 0x2b073704, 0x3c20b582, 0x00238783,
    0x41ceff6a, 0x12270763, 0x01022605, 0x851d0901, 0x0895415b, 0x00005223, 0x20e78503, 0x2231843d, 0x86390076, 0x8216208b, 0x0a5e228b, 0x0c275310,
    0x35202d83, 0x5d208b84, 0x20058746, 0x208b85d6, 0x20e58216, 0x222b9260, 0x823707fe, 0x2359848b, 0x29014f01, 0x210ae168, 0x9f6e0a0b, 0x2159840d,
    0x2d82e505, 0x07245983, 0xcd004f01, 0x20064141, 0x205b8215, 0x8a2d9214, 0x4c0123b5, 0x5b86e0ff, 0xb5820f20, 0x63150621, 0x00200cc7, 0x0122b58e,
    0xb585864c, 0x59820f20, 0x2b8b1020, 0x01003308, 0x0000ae00, 0x1f06be02, 0x25001300, 0x09091540, 0x10150015, 0x03152015, 0x54004713, 0x06500d14,
    0x00150001, 0x01e13f3f, 0x5de1f610, 0x312f3311, 0x0d613330, 0x724f1805, 0x2dae320a, 0x3b4e7c55, 0x1f2f2663, 0x3a282848, 0xb0041327, 0x5957186b,
    0x4efb210b, 0x32086582, 0x0314fecb, 0x00cb05e9, 0x404a002b, 0x012d302a, 0x011f1f29, 0x12161247, 0x0a121414, 0x1012000a, 0x40123012, 0x12070412,
    0x16600013, 0x230d2929, 0x82071c50, 0x001b217c, 0x45058379, 0x332107df, 0x2f82822f, 0xe1103311, 0x5d322f32, 0x11013031, 0x23020e14, 0x230a964d,
    0x37352311, 0x11065818, 0x8f021530, 0x4e7b552d, 0x1a1c3d20, 0x3b281f39, 0x58181326, 0xb1880713, 0x4403f624, 0xb4833ffc, 0x9906092d, 0x30130a08,
    0xc3034153, 0x8c89444b, 0x899125c6, 0x00040000, 0xc8080082, 0xaa07dd04, 0x23001600, 0x3e003100, 0x5e400101, 0x29012989, 0x302a2abe, 0x381d3131,
    0x1f0d0f83, 0x0d10020d, 0x0d020d20, 0x6623560d, 0x07230223, 0x69175908, 0x17060217, 0x83321d05, 0x001f000f, 0x0003006f, 0x010ad600, 0x0a470a37,
    0x0ac70a57, 0x03d90a04, 0x48033801, 0xc8035803, 0x1d030403, 0x1005091d, 0x04800104, 0x04d00490, 0xffb80403, 0x061840c0, 0x1004480a, 0x0f400404,
    0x2f401f40, 0x9f408f40, 0x0640df40, 0xb8090807, 0x3140f0ff, 0x235f0709, 0x0e0a201d, 0x030a1d48, 0x0135193c, 0x10128c35, 0x128f013c, 0x600212ef,
    0x31100112, 0x23023120, 0x3131123c, 0x04233c12, 0x04092904, 0x333f0012, 0x3917122f, 0x2000822f, 0x2800825d, 0x115de110, 0x2b333333, 0xc26f1810,
    0x3912260e, 0x5d332f3d, 0x2802835d, 0xe15d2f18, 0x39391211, 0x3a03835d, 0x715d2f33, 0x2f3311e1, 0xed2f3333, 0x0130315d, 0x01070614, 0x03210323,
    0x62260123, 0x1e2c0653, 0x2e030302, 0x030e2703, 0x3e130307, 0x0807ce79, 0x26341326, 0x15062223, 0x33171614, 0x50033632, 0xfc01333c, 0xd3fd9abe,
    0xf801bc9c, 0x3b203a33, 0x54313252, 0x940c233e, 0x0a057018, 0x30158523, 0x08ff792f, 0x3fbc7008, 0x333f3132, 0x3f320c31, 0x60469c05, 0x0123fb19,
    0x0479fe87, 0x466019db, 0x1d384f33, 0xfc4f371d, 0x107d015f, 0x1c3b362e, 0x2e363c1c, 0x0483fe0f, 0x413d188b, 0x16101c40, 0x16424741, 0x3c34f6fe,
    0x3b33343c, 0x05003c03, 0xecff5e00, 0xaa079c03, 0x31000d00, 0x54004000, 0x9c006000, 0x83552340, 0x411f410f, 0x4103412f, 0x4b835b41, 0x824b0d06,
    0x1a500801, 0x47370f1e, 0x3f625531, 0x483e0162, 0xffb8281a, 0x0d3a40d0, 0x10284811, 0x28480c09, 0x61561a28, 0x50508c58, 0x700d600d, 0x0d0d030d,
    0x5e055050, 0x5046408c, 0x46460246, 0x2b502427, 0x1e1e5238, 0x5032102b, 0x0e16150f, 0x01050f15, 0x5d2f0005, 0x0a8d5e18, 0x5d2f3326, 0x2f3911e1,
    0x10210682, 0x059c69e1, 0x2b059d69, 0x113232e1, 0x2f2f3939, 0xe110cd10, 0xe1231c82, 0x41013031, 0x01200842, 0x29af5e18, 0x18140121, 0x200d3a55,
    0x077d4107, 0x36323324, 0x5841c701, 0x23522508, 0x25520178, 0x27d95e18, 0x2386013c, 0x3231543d, 0x21213b52, 0x3032523b, 0x75233e54, 0x3f32313f,
    0x3f313839, 0x6d41b806, 0x5cf9220a, 0x035f1898, 0x08052929, 0x1d385133, 0x334f381d, 0x2406c841, 0x3c3c3534, 0x2d038235, 0xfeffffff, 0x56060000,
    0x26027307, 0xab458800, 0x25022105, 0x2905934c, 0x02260520, 0xb44801b8, 0x1f5b1a14, 0xff5e260c, 0x064406ec, 0x202f8221, 0x212f85a8, 0x53457501,
    0x5d032905, 0x71032611, 0x1c005751, 0x220a9546, 0x72b4ff7d, 0x9a20060b, 0x02202d86, 0x28055345, 0x26053e03, 0x38325803, 0x0b235611, 0xb4ff7324,
    0x5b842f04, 0x0946ba20, 0x05416705, 0x823a0321, 0x2e4c2359, 0xbd4c0d34, 0xfe68220b, 0x0a374c3b, 0x39020622, 0x2107674b, 0xe74cb4da, 0xffff2307,
    0x25825a00, 0x8209354c, 0x4bbb2025, 0xe12106b5, 0x08e14cb4, 0x01016b08, 0x03d90402, 0x0021069a, 0x40250014, 0x040e0f11, 0x08c00004, 0x00800e04,
    0x085f080f, 0x2f000802, 0xcc1a335d, 0x1a2f0132, 0x2f3d39cc, 0x30313333, 0x26262301, 0x07060627, 0x033e3523, 0x031e3337, 0x799a0317, 0x36346c33,
    0x1a79336a, 0x103b4344, 0x433b10c0, 0xd9041945, 0x37376122, 0x1d1b2261, 0x2251514c, 0x4c515122, 0x6b8e001d, 0x10050630, 0x0bc00010, 0x10800d13,
    0x065f060f, 0x6b840602, 0x6b8ccd20, 0x07030e33, 0x27032e23, 0x16163335, 0x37363617, 0x199a0333, 0x2b638645, 0x33791a44, 0x6c34366a, 0x06067933,
    0x50236482, 0x82502323, 0x221b2664, 0x61383861, 0x206b8222, 0x32d7821b, 0x006f055a, 0x40150003, 0x0000010a, 0x5f030f8f, 0x82030203, 0x7ee12064,
    0x212b0508, 0x1b012115, 0xc1fd3f02, 0x82966f05, 0x8221202f, 0x057b2d2f, 0x001500ee, 0x151c402f, 0x0100ff83, 0x83339c82, 0x0a7f000a, 0x0a9f0a8f,
    0x10800a03, 0x5f050f8f, 0x83050205, 0xcd1a2241, 0x27a7825d, 0x5ddc1ae1, 0x013031e1, 0x0805ba6c, 0x1e332731, 0x3e323303, 0x7b033702, 0x6d4d2c04,
    0x496d4947, 0x046c0327, 0x2c43301c, 0x22334124, 0x3dee0504, 0x27294a65, 0x2b3f6649, 0x09071932, 0x8228311b, 0x05a03c62, 0x05750100, 0x000d00e5,
    0x0810401c, 0x91030087, 0x0bcf0b9f, 0x30030bef, 0x820b010b, 0xe55d2369, 0x62822f01, 0x46181320, 0xa0200bcc, 0x09505b18, 0x3c73052f, 0x2b1c0d36,
    0x38393a1e, 0x01020000, 0x08c3826d, 0x87063131, 0x1f001300, 0x2d404000, 0x000f8314, 0x004f003f, 0x0004005f, 0x0a30831a, 0x8c170a01, 0x0f1f0f0f,
    0x0f4f0f3f, 0x0faf0f5f, 0x06070fff, 0x898c1d0f, 0x5ed428d6, 0x2f01e15d, 0x84d4e15d, 0x1ae243d6, 0x43310321, 0x202106a9, 0x0fa94320, 0x43b20521,
    0xed82166f, 0x42fe1f39, 0x00005e01, 0x16001400, 0x80060940, 0x120d8400, 0x000a8e03, 0x822fe12f, 0x1a3908e5, 0x173031cc, 0x32331614, 0x06153736,
    0x26222306, 0x023e3435, 0xb4063337, 0x2d192234, 0x1d401a0e, 0x2f1e6464, 0x8b811a38, 0x052b2dee, 0x08087104, 0x4b2a5a68, 0x85133440, 0x06594200,
    0x05d12808, 0x001b00e3, 0x0f234038, 0x02172f17, 0x20090017, 0x09070209, 0x0e8f0516, 0x48131040, 0x0b07400e, 0x130e0e48, 0x820f098f, 0x2f003489,
    0x33e1325d, 0xe12b2b2f, 0x5e2f0133, 0x315dcc5d, 0x51220130, 0x232005c2, 0x83051367, 0x0e333b87, 0x28fe0203, 0x20464c4f, 0x680e302d, 0x4a352105,
    0x4c512a2e, 0x2e2d1d45, 0x0d83690f, 0xdb042008, 0x35232b23, 0x45623c3e, 0x232a2325, 0x613c3e34, 0x00002645, 0x04df0002, 0x06be03d9, 0x820d0021,
    0x402d2d8f, 0x0e0e1419, 0x00504007, 0x4f003f01, 0x13241c82, 0x1b809205, 0x08964018, 0xed1a332e, 0x5d2f0132, 0x39cd1a5d, 0x3031cd2f, 0x2009cf46,
    0x08964525, 0x2f16df30, 0xc7102a2f, 0x514d3f10, 0x6b016523, 0x0d823015, 0x0d84c620, 0x40186420, 0x6b430cb5, 0xc1401805, 0xf8012108, 0x04208582,
    0x272c8584, 0x10051640, 0x0548110c, 0x000c4006, 0x8182fd82, 0x1a218088, 0x247e82ed, 0x32cd1a33, 0x0c0a462b, 0x0af82308, 0x04101314, 0x2d2106c7,
    0x046c1834, 0x514d1ef4, 0x18152150, 0x2056574e, 0x14010300, 0x89030c05, 0xdf84b406, 0x6600292b, 0x841c1940, 0x241f240f, 0x37048302, 0x240324cf,
    0x480c0940, 0x160d2424, 0xffb80e84, 0x092740c0, 0x0e0e480d, 0x0c3b8086, 0x0c92050d, 0x91111f0c, 0x0119ff27, 0x19b01960, 0x0f0319d0, 0x02191f19,
    0x4f001906, 0xe5230561, 0x822f3932, 0x82332093, 0x2f332491, 0x8211e12b, 0x715d2104, 0x200ca746, 0x0b0d4327, 0x0de74918, 0x190bfe39, 0xcf081618,
    0x3d383012, 0x38ea5220, 0x1a231329, 0x29263a10, 0x18b50138, 0x320af649, 0x4f4b1e87, 0x20142451, 0x2551504d, 0x0c303606, 0x181b2619, 0x250c044a,
    0xe9ffffff, 0xad670000, 0xfd54350c, 0x0097fff1, 0x1a02b618, 0x22300203, 0xe9ffb801, 0x042222b4, 0x18082b5b, 0x82732141, 0x82e720a5, 0x054d30a5,
    0x002700b8, 0x008f0028, 0x01070100, 0x82effd54, 0x2e2a08a7, 0x031101b4, 0xffb81201, 0x0f08b2c0, 0x9dffb848, 0x12120f40, 0x00250202, 0xbf1b6700,
    0x1b0f011b, 0x5d5d0101, 0x0134fe10, 0xe95b2b2b, 0x82ff2005, 0x50052149, 0x26234982, 0x897b2b00, 0x8a312047, 0x82112047, 0x40b12647, 0x06121212,
    0x29478206, 0x011b6f65, 0x10011b2f, 0x0482011b, 0x5d5d5d24, 0x4a8534fe, 0x95850020, 0x84600321, 0x002c2295, 0x22958afc, 0x83164066, 0x12c03696,
    0x0112a001, 0x20011230, 0x12100112, 0x01120001, 0x40a5ffb8, 0x3c58852f, 0xd00100f0, 0x00c00100, 0x0100af01, 0x60010070, 0x00500100, 0x01004001,
    0x0001003f, 0x286c8220, 0x48070740, 0x0907401b, 0x21ba8248, 0x7882115d, 0x35200285, 0x5c059e59, 0xff2c06b7, 0x05ecffe7, 0x00cd05c3, 0x52320026,
    0x2408cd89, 0x02304047, 0xa002032d, 0x2e80012e, 0x012e7001, 0x20012e50, 0x2e10012e, 0x012e0001, 0x0a2e2e24, 0x0001250a, 0x2a708450, 0x37bf6700,
    0x01370f01, 0x82100137, 0x5d5d23da, 0x5f863434, 0xe3866084, 0x84540521, 0x013c22e3, 0x2fe38a1d, 0x0e01b44b, 0xb80f0103, 0x16b6c0ff, 0x0fa04817,
    0x25080a84, 0x481109b2, 0x40d6ffb8, 0x070f0f1c, 0xc0002507, 0x05b00105, 0x01057f01, 0x05010520, 0x2f01183f, 0x180f0118, 0xc9820101, 0x3528d084,
    0x2b5d2b2b, 0x353f0035, 0x06216786, 0x22c98300, 0x895a7601, 0x403539c9, 0x03350123, 0x01362001, 0x00013610, 0x36160136, 0x25131336, 0x011d5000,
    0x1d280282, 0x013fbf67, 0x3f013f0f, 0xbb83bc87, 0xe42a4f87, 0x7702ecff, 0x2602b406, 0xb5848601, 0xd0fe5535, 0x18000000, 0x02030f40, 0x0124c001,
    0x20012440, 0x6a153a24, 0x35230687, 0x82ffff35, 0x0509431d, 0x24000623, 0x07715600, 0xb6058726, 0x25000602, 0x3c081b82, 0x00c70001, 0x05be0300,
    0x000500b6, 0xc40a4043, 0x0200f400, 0x020100b0, 0xc0ffb800, 0x13081f40, 0x07000048, 0x072f070f, 0x076f074f, 0x11400704, 0x5a034818, 0x02066404,
    0x0303055f, 0x07f84d12, 0x115d2b3a, 0x5f2b2f33, 0x30315d5d, 0x11211501, 0xbe031123, 0x05bac3fd, 0xf0faa6b6, 0x00215882, 0x21698302, 0x63846804,
    0x58000e30, 0x04051140, 0x0b020606, 0x7001605b, 0x6f18b001, 0x2608080c, 0x480a0627, 0x2f100101, 0x6f105f10, 0x9f107f10, 0x0610bf10, 0x09064010,
    0x025b0a48, 0x110a2006, 0x03040648, 0x82025f0a, 0x3fe12674, 0x2f012b33, 0x227585e1, 0x4812e15d, 0x2e0806d8, 0x35211525, 0x06073301, 0x21030706,
    0x04262603, 0x01bdfb68, 0x115ebbc2, 0x02fe1d2a, 0x2e1ffcae, 0x05857d7d, 0xa84acd31, 0x020afd5b, 0x41a861f0, 0xfb83060b, 0x00060224, 0x0f830028,
    0x00005226, 0xb605fe03, 0x3d200f82, 0x20082b41, 0x210f84d5, 0x1a82002b, 0x2205c35a, 0x7000cd05, 0x2208056b, 0x00344053, 0x0e010001, 0x67045b22,
    0x012dd02d, 0x80012dcf, 0x2d3f012d, 0x18022d6f, 0x2c660e5b, 0x7d0f6003, 0x042b0614, 0x1d000008, 0x04135f27, 0x18095f1d, 0x27084379, 0x01e15d5e,
    0x5de1f610, 0x06820082, 0x3939122b, 0x30312f2f, 0x21152101, 0x055c7a25, 0x597a2620, 0x18162009, 0x2b10668a, 0x1602ec01, 0x8503eafd, 0x9beda051,
    0x1d6b7318, 0xa1390326, 0xeafea945, 0x1fd07418, 0x84074963, 0x882c20ed, 0x84a220fd, 0x822e200f, 0x820120fd, 0x04003a03, 0x00b6058b, 0x405f000c,
    0xef0e2f1c, 0x030eff0e, 0x1512400e, 0x0d400e48, 0x08048210, 0x4809064c, 0x05050b0c, 0xffb80a09, 0x0a2240f0, 0x4f002f01, 0x9f005f00, 0xcf00af00,
    0x0700ef00, 0x00010010, 0x20050010, 0x05480e0a, 0x000a030b, 0x323f0012, 0x012b333f, 0x5d5d382f, 0x33382f32, 0x332f3d39, 0x2b2b2b33, 0x2130315d,
    0xa44a0123, 0x23013e05, 0x8b043301, 0x1fdbfec6, 0x2a110f2e, 0xc5d9fe1d, 0x03bbe701, 0x4ba8619a, 0xfc5ba84b, 0x278c8260, 0xc700ffff, 0x2f060000,
    0x3020a784, 0x0521b787, 0x200f840e, 0x26b38231, 0x00520003, 0x82ee0300, 0x00032e2a, 0x000b0007, 0x143e4063, 0x011b0100, 0x088e8201, 0x060b0124,
    0x01080006, 0x3f0108c0, 0x0d080108, 0x0d6f0d4f, 0x010d3002, 0x0b700707, 0x4f020b80, 0x030b010b, 0xbf820f5f, 0x0008022d, 0x5f0b0400, 0x5f07120a,
    0x7e000304, 0x6b4906cf, 0x335d2f05, 0x105d5d2f, 0x715d5dce, 0x39112f32, 0x0d822f39, 0x13303126, 0x03211521, 0x013c0382, 0xcd352115, 0x5afda602,
    0xfc4a0352, 0xfc7303b6, 0xa24e0364, 0xfba40a03, 0x00a4a492, 0x2507135d, 0x0602cd05, 0xa9823200, 0xc9830120, 0x82c10421, 0x072008a9, 0x1e403100,
    0x65005a01, 0x0109b009, 0x099f096f, 0x100309af, 0x5a040109, 0x03086405, 0x0503065f, 0x42053c41, 0x1025073f, 0x3031e1f6, 0x05536721, 0xc104212b,
    0xba7bfdbb, 0x1205fa03, 0x41f483fa, 0x0423051f, 0x82b60533, 0x84332065, 0x824e2065, 0x821220cc, 0x0b3a0865, 0x0d405a00, 0x20065b08, 0x02481714,
    0x01060206, 0xc0ffb80a, 0x15062640, 0x0d0a0a48, 0x0d2f0d0f, 0x0d8f0d6f, 0x09070604, 0x012f035b, 0x0102013f, 0x09020208, 0x03045f07, 0x7f835f09,
    0x433fe121, 0x0124057a, 0x335d2f18, 0x2606a163, 0x3939122b, 0x822b2f2f, 0x3324088e, 0x35010135, 0x01211521, 0x4e152101, 0x6efe9e01, 0x58fd7d03,
    0x67fe8501, 0x0298f702, 0x93250266, 0xfdeefda4, 0x20050541, 0x828f8514, 0x0037229f, 0x06b14400, 0xaf843720, 0xaf823c20, 0x00035b08, 0x05ecff68,
    0x00cb05ba, 0x002e0021, 0x4081003b, 0x67022250, 0x5a110111, 0x129a213b, 0x01128701, 0x1201127a, 0x5b281b12, 0x2f3d6708, 0x3d00013d, 0x013dd001,
    0x3dbf3daf, 0x013d9002, 0x30013d5f, 0x3d0f013d, 0x06023d1f, 0x661b5b35, 0x603b223c, 0x2e131013, 0x0221602f, 0x01821321, 0x00131126, 0x3f3f0004,
    0x1124b683, 0x32e11033, 0x01240484, 0x5ee1f610, 0x21059946, 0x0b827171, 0x2f391122, 0x33280d82, 0x325de133, 0x01303132, 0x35052a7c, 0x040e1415,
    0x23152323, 0x2e222335, 0x3e343504, 0x13333302, 0x747b3233, 0x032b2705, 0x15020e22, 0x13821e14, 0xb4025c08, 0xc28649bb, 0x34183c7e, 0x659f7854,
    0x652fbb2f, 0x3554789f, 0xc27e3d18, 0x1abb4a85, 0x2e5b8b5d, 0x577f5329, 0x5739bb39, 0x2e28547f, 0x1a5d8b5b, 0x5eb4cb05, 0x3d66c499, 0x526e7b81,
    0x30e1e130, 0x817b6e52, 0x99c4663d, 0x3b53fc5e, 0x4e589469, 0x3c3c688b, 0x584e8b68, 0x413b6994, 0x6408062d, 0x02b60560, 0x003b0006, 0x00010000,
    0x05000068, 0x00b605ba, 0x40700025, 0x09671f47, 0x1c5a0901, 0x87010a9a, 0x0a7a010a, 0x130a0a01, 0x67005b23, 0x01272f27, 0xd0012700, 0x27af0127,
    0x900227bf, 0x275f0127, 0x01273001, 0x271f270f, 0x5b160602, 0x1f266613, 0x0b08601c, 0x1d24090b, 0x12090314, 0x333f3f00, 0x069f5833, 0x2b151a41,
    0x31325de1, 0x0e140130, 0x11232304, 0x222b0182, 0x1135042e, 0x1e141133, 0x82333302, 0x32332207, 0x210e8236, 0x0341ba05, 0x84c1200e, 0xbb2608ee,
    0xc0b7ba1a, 0x7f3dd703, 0x2e4e6a77, 0xbe0142fe, 0x77684e2d, 0xe3013d7e, 0x8d5821fe, 0x5a033462, 0xb1c6a6fc, 0xdb83e301, 0xdb824e20, 0x05a64908,
    0x002f00cd, 0x0e51407c, 0x5b220b5b, 0x300b2025, 0x0b04020b, 0x3f252f01, 0xef25df25, 0x250b0425, 0x250b0701, 0x2b13250b, 0x1623065b, 0x1d230223,
    0x31d03167, 0x0131cf01, 0x3f013180, 0x02316f31, 0x0d190d09, 0x050d0802, 0x302be682, 0x04185f00, 0x0d0a2226, 0x820c255f, 0xe13324e5, 0x54323232,
    0x332005cc, 0x2905ff41, 0x5d32f610, 0x393911e1, 0x0f842f2f, 0x18e11021, 0x2a0be753, 0x35211517, 0x35032e21, 0x18023e34, 0x20086985, 0x20138221,
    0x0812823e, 0x02022e58, 0x6aa472fa, 0x83512332, 0x01b0fd5f, 0x506f4062, 0xeca0512e, 0xa0eb9b9a, 0x6e502e51, 0xfd620141, 0x51835fb0, 0xa46a3223,
    0x81442905, 0xbb6475ba, 0x934197ab, 0xa88730a4, 0xf4966fc7, 0xac5e5eac, 0xc76f96f4, 0xa43087a8, 0xab974193, 0xba7564bb, 0xff004481, 0x431800ff,
    0x03572ec9, 0x71200834, 0x9104ecff, 0x26022106, 0x00007e01, 0x54010601, 0x13000019, 0x4a020b40, 0x16022611, 0x2f16443e, 0x240a2551, 0x03ecff5a,
    0x202b845c, 0x202b8582, 0x292b84ca, 0x26114601, 0x403a6d01, 0x2b8a2d18, 0x14feae22, 0x21059164, 0x2b858401, 0x2b854420, 0x2b822520, 0x91646220,
    0xffa4240e, 0x847702ec, 0x05e94857, 0xcefe5422, 0x20053f5e, 0x262c8222, 0xb4fdffb8, 0x51152216, 0x2f820b53, 0x063d0423, 0x20b382b4, 0x305b8492,
    0x00001055, 0x0203b212, 0xeeffb801, 0x05422cb4, 0x2487831b, 0x02003535, 0x08dd8400, 0x005e0429, 0x003d0010, 0x381e4038, 0x2f47051e, 0x3f103f28,
    0x16480e01, 0x0f223e56, 0x1b500b1e, 0x2c2f380f, 0x11335000, 0x423f0016, 0x33200614, 0x24066971, 0x32e132d4, 0x1f671832, 0x17162a1a, 0x37363633,
    0x15030e33, 0x0a0c4f11, 0x27022e25, 0x18030e23, 0x08122a67, 0xa2713d2f, 0x31907064, 0x19210a0c, 0x0d130b8f, 0x0e223208, 0x410f0825, 0x323f2622,
    0x160c0c24, 0x83604d3b, 0x6898622f, 0x6b9d650f, 0xd1ccda37, 0x366718cd, 0x55533a08, 0x211f5223, 0x377e7968, 0x333c5dfe, 0x09850307, 0x40271011,
    0x2e3d2230, 0x065d761a, 0x1f067524, 0xe3821b00, 0x40594308, 0x05483934, 0x331f0508, 0x3302332f, 0x15053305, 0x570c472c, 0x303f203f, 0x1522023f,
    0x3e541647, 0x32081b15, 0x01330f50, 0x00333308, 0x11502722, 0x00501c16, 0xe13f0001, 0x1132e13f, 0x5d5e2f39, 0xfc8439e1, 0x34062b6d, 0x5d2f2f39,
    0xe1103912, 0x32013031, 0x1415021e, 0x16150706, 0x05827616, 0x1127262d, 0x3e341123, 0x0e221702, 0x51111502, 0x3525054f, 0x23022e34, 0x29911823,
    0x02660808, 0x76a36077, 0xb08f9843, 0xad783fb9, 0x3ca4606d, 0xa87945b6, 0x4b643863, 0x524e202c, 0x6f502452, 0x60351f46, 0x4d664f84, 0x254e7752,
    0x065f4426, 0x9462311f, 0x17ad9562, 0xbaca1506, 0x376da26c, 0xe9fd1f20, 0xb27b3406, 0x1f963773, 0xfc607f4c, 0x151e1292, 0x6f4d280b, 0x4d755047,
    0x49289825, 0x5e3f3d66, 0x62181f3e, 0x34080a7f, 0x4063001b, 0x12401d16, 0x1d504815, 0x2f1d0f01, 0x031d4f1d, 0x01051a07, 0xb8064805, 0x1540f0ff,
    0x000b0606, 0x1a0c1313, 0x1b201b00, 0x08031b40, 0x0d1b101b, 0x3a19830c, 0x0c1a0c0a, 0x0b00130f, 0x001b0515, 0x33333f3f, 0x2f01333f, 0x382f3338,
    0x4a335d5e, 0x33300574, 0xe1382f18, 0x5d5d5e5d, 0x2530312b, 0x2315030e, 0x3720fa82, 0x0ba96518, 0x60023708, 0x0c182216, 0x251b0fbe, 0xbd60fe15,
    0x1a1e0ed9, 0x05060414, 0x0b1b1914, 0x3e12bcc7, 0x347e8688, 0x8d89792a, 0xfd3e043f, 0x5a5d28ba, 0x521a1b50, 0x02215a5d, 0x0b7d004c, 0x1f440808,
    0x44003200, 0x2e405100, 0x3800461a, 0x332e0505, 0x57240f48, 0xd0464046, 0x0346e046, 0x0601460f, 0x562e483d, 0x42240045, 0x38380a1a, 0x2950420a,
    0x10501516, 0x3f00010a, 0xe13fe133, 0x122f3911, 0x33391239, 0x2206ce46, 0x8332f610, 0x39392512, 0x013031e1, 0x2209b644, 0x182e0717, 0x2108aa83,
    0x8f181e17, 0x01240c17, 0x27022e34, 0x084b4c18, 0x1402c208, 0x25435d38, 0x4a7d5c33, 0x51607144, 0x49204a23, 0x2a335b51, 0x1b12273c, 0x5547623c,
    0x45315c86, 0x676db27f, 0x43477fae, 0xb4019972, 0x3552391e, 0x44687e3a, 0x43694926, 0xaa03998e, 0x62564b20, 0x46694839, 0x271f1422, 0x26149113,
    0x2517121e, 0x3e251b32, 0x3129413d, 0x58937e6c, 0x4383c17f, 0x6eaa753d, 0x537aa36a, 0x6f4551fe, 0x101f4959, 0x6791623a, 0x2d516f42, 0x000100b4,
    0x03ecff5a, 0x005e045c, 0x40590039, 0x01231d37, 0x2d101801, 0x3ba03b57, 0x3bc03bb0, 0x5f3b3f03, 0x3b10023b, 0x23463401, 0x18470523, 0x021e3a56,
    0x0139bf50, 0x39893979, 0x0a393902, 0x10285031, 0x1613500a, 0x062e5a00, 0xe15d5d2d, 0xf6100139, 0xe12f33e1, 0x655d5d5d, 0x122c0527, 0x01303139,
    0x06222315, 0x021e1415, 0x09018a18, 0x35022e27, 0x37023e34, 0x0b2f4135, 0xa9582620, 0x08268205, 0x819c025f, 0x4629858a, 0x5c333760, 0x3b1f4751,
    0xa6716d9e, 0x3f26356c, 0x462b2c52, 0x693a1c33, 0x5a355690, 0x3f284d52, 0x6c47814b, 0x64482773, 0x9987023d, 0x45335e5b, 0x180f122a, 0x22a0101f,
    0x75563129, 0x3e583e43, 0x0e0b0f29, 0x32503e2b, 0x264a6d46, 0x141c1309, 0x4d262293, 0x27402d4d, 0x08f78212, 0x6ffe712b, 0x14066a03, 0x39003300,
    0x032e1f40, 0x1a461f03, 0x14011420, 0xc0351035, 0x480a0235, 0x29000029, 0x2e193456, 0x01500003, 0x23df8200, 0x012f3232, 0x2f27d082, 0x105de110,
    0x82325dd6, 0x7c3320e2, 0x0e2105b4, 0x23441805, 0x2307210a, 0x2005a346, 0x08d68327, 0x36361266, 0x06070637, 0x02ae2306, 0x7eb880b6, 0x2d0d284c,
    0x474b7854, 0x15193a5f, 0xaa162b22, 0x14222b18, 0x4d5b300e, 0x2e5c8759, 0x6cc99a5c, 0x60282f2b, 0x997b052f, 0xb3cd768d, 0x306f859a, 0x23406c59,
    0x3b2e0f11, 0x582d2a48, 0x201f4b52, 0x1d434848, 0x1f222514, 0x6c42110f, 0x01946698, 0x6cd9e801, 0x04020303, 0x08935318, 0x18005e28, 0x1d403100,
    0x6e184700, 0x0e2c0f69, 0x10145004, 0x150b0f0c, 0x3f001b00, 0x220daf68, 0x18013031, 0x290b9671, 0x033e3317, 0x15163233, 0x71180311, 0x93680795,
    0x14fe2309, 0x8668af04, 0x47fb2210, 0x05896600, 0x17042108, 0x13002b06, 0x27001e00, 0x3a405b00, 0x00471925, 0x290f2957, 0x0129d001, 0x299f297f,
    0x01294002, 0x21080d82, 0x471a2406, 0x1a28560a, 0x0124cb50, 0x890124ba, 0x02249924, 0x0801240f, 0x1f142424, 0x14010f50, 0x4a420550, 0x5d5e2108,
    0xe1210082, 0x05a36e01, 0x71200a82, 0x073b5418, 0x67060221, 0x98080c6e, 0x01121616, 0x37023e32, 0x13031e21, 0x07020e22, 0x04020221, 0xb3703417,
    0x74af767e, 0xb16f3338, 0x75b0767e, 0x492bfe3a, 0x03234568, 0x2102cbfd, 0x474a6844, 0x05234466, 0x84093302, 0xfebc0c03, 0x6d6dced7, 0xbc2901ce,
    0xce2901bc, 0xfecd6b6c, 0x4ab9fcd7, 0x9395df94, 0x054b95df, 0xcd894510, 0x01110189, 0x01000013, 0xecffa400, 0x48047702, 0x35001500, 0x09302340,
    0x17090901, 0x17101700, 0x17601720, 0x17901770, 0x17d017c0, 0x47010808, 0x04165414, 0x00160f50, 0x07c44f0f, 0x115d5e24, 0x345d2f33, 0x42162005,
    0x165705fe, 0x11353905, 0x483f5a01, 0x242a2d12, 0x30290d09, 0x6a3e1834, 0x48042c4d, 0x6261fcfc, 0x0ca86b18, 0xff040330, 0x00ae00ff, 0x04f00300,
    0x0006024a, 0x8b8200fa, 0xfff2ff36, 0x061704ec, 0x002e0021, 0x222a4068, 0x121a1515, 0x0a290112, 0x30080182, 0x011a5000, 0x1a441a34, 0x101a0002,
    0x031a201a, 0x60301a1a, 0x02309030, 0x0601300f, 0xffb8002e, 0x000f40f0, 0x0129152e, 0x50170e01, 0x5007161e, 0x058d460e, 0x2f391124, 0x6a183f33,
    0x2608092e, 0x125d5d5d, 0x2f3d3939, 0x33112f18, 0x39121133, 0x30313311, 0x2e270123, 0x06222303, 0x36363507, 0x021e3233, 0x82160117, 0x069256ce,
    0x022e6308, 0x032e0327, 0x06062327, 0x010e0307, 0x1f0d35b8, 0x222b3d2b, 0x421a1432, 0x4f694a23, 0x48011f3f, 0x0e262e12, 0x37170826, 0x2f3b2725,
    0x0b870f25, 0x05161b1d, 0x1f350d06, 0xa03304e5, 0x1b314329, 0x07910507, 0x87592a0a, 0x3636fc5d, 0x85030739, 0x28110e0c, 0xa2012e40, 0x57615e21,
    0x4faa4d19, 0xf782c1fd, 0x0a7b5618, 0x26403f25, 0x18090c0d, 0x2b0f7c56, 0x1b471a00, 0x1b1a1e54, 0x50030d14, 0x0c7f5618, 0x65483320, 0x32322b05,
    0xe1f6105d, 0x30313232, 0x56181401, 0x3a084f83, 0x03000000, 0x004a04cf, 0x403b0014, 0x07131416, 0x470d0007, 0x1016570e, 0x16b00116, 0x01160f01,
    0xb8000106, 0x00b6f0ff, 0x0d151407, 0x3f000f00, 0x01333f32, 0x5e32382f, 0x82715d5d, 0x05f74693, 0x30313c08, 0x1e133311, 0x3e331703, 0x33351202,
    0x06020214, 0xc9bc2307, 0x191e1f0c, 0x725a0605, 0x25b61942, 0xc0759a5c, 0xb0fd4a04, 0x5c676321, 0xe7cd6019, 0xa3970501, 0xf5fee0fe, 0x44007ffd,
    0x46320ad3, 0x4e407e00, 0x113b3b32, 0x4641012a, 0x242d2d38, 0xc765001c, 0x084b0805, 0x461c0101, 0x11011120, 0x5f483f48, 0xef487f48, 0x48100448,
    0x24480701, 0x323c4756, 0x2a395038, 0x591c4900, 0x031c691c, 0x07011c38, 0x16031c24, 0x00004f01, 0x16003916, 0x3f3f00fa, 0xe12f3912, 0x5d391711,
    0x1039115d, 0x513232e1, 0x10280564, 0xc0f15dd6, 0x115d5e2f, 0x33271d82, 0x113912e1, 0x45332f33, 0xa84d05f0, 0x06f94605, 0x5e081845, 0x372105ab,
    0x29078635, 0x06060706, 0x21352323, 0xd84d2315, 0x23032607, 0x577f51a2, 0x142a452d, 0xb8b22708, 0x37664e2f, 0x4f2d7265, 0x27223e6b, 0x3e2e5521,
    0x49378102, 0x20477391, 0x03517246, 0x55318977, 0x604e4171, 0x3645223b, 0x22330814, 0x7f4db5c7, 0x0c114363, 0x4875861c, 0x13314966, 0x04020303,
    0x4e268d99, 0x51354e75, 0xff001c37, 0xff7100ff, 0x042d04ec, 0x0006025e, 0x00000052, 0x82190001, 0xc925080f, 0x18004a04, 0x38405800, 0x168f470a,
    0x0e161601, 0x00141403, 0x02031003, 0x2f1a0303, 0xef1a9f1a, 0x0d10031a, 0x08b65147, 0x48151036, 0x1519540e, 0x1250100c, 0x00150e0f, 0x00160750,
    0x3f3fe13f, 0x33052f41, 0x33e15d2b, 0x2f33115d, 0x112f335d, 0x5d2f3912, 0x253031e1, 0x0809d659, 0x1121113c, 0x35231123, 0x23152137, 0x04161411,
    0x0f2f1c50, 0x71304a0f, 0xb66dfe71, 0x270489dd, 0x0d812fd3, 0x11099008, 0xbe028284, 0xb00350fc, 0xfd9a504a, 0x0037464e, 0xa4000200, 0xb78314fe,
    0x001a002f, 0x40390027, 0x00482521, 0x29cf2957, 0x06744501, 0x0f091f30, 0x28541047, 0x1016501b, 0x50221b0f, 0x92820508, 0x93833320, 0xf6100122,
    0x5e209782, 0x21052853, 0xbb5e3031, 0x27262105, 0x4d08636f, 0x0125067f, 0x11070622, 0x06d36b16, 0x2d044508, 0x68a7753f, 0x06368f4b, 0x01020201,
    0xa97841b6, 0x77a36169, 0x893bfe43, 0x8f360382, 0x7d7b8c4b, 0xd5892702, 0x2d2d4c91, 0x61272e2b, 0x04ddfe2e, 0x91d38813, 0xd3914b4b, 0xc8c41801,
    0x3133acfe, 0xcfd1d1d3, 0x0806ab42, 0x5e046f47, 0x51003100, 0x27273640, 0x00104615, 0x200a100a, 0x330a030a, 0x335f333f, 0x33ef337f, 0x01331004,
    0x561f4800, 0x512d2832, 0x28010a37, 0x48153815, 0x0a150315, 0x0f04001f, 0xfa0f1024, 0x123f3f00, 0x5d5d3917, 0x098b42e1, 0x33e13223, 0x18c9832f,
    0x47090864, 0x3e240b91, 0x16323302, 0x25079749, 0x491c2d01, 0x8e47617e, 0x844d3b10, 0x83493762, 0x954e6ab3, 0x38173632, 0x501a3a3c, 0x02224972,
    0x4e796006, 0x8d47162f, 0x410f3213, 0x9a82b476, 0x224995e2, 0x130a9a19, 0x7039090f, 0x060b4da4, 0x04852808, 0x0016004a, 0x40360029, 0x48212421,
    0x57001012, 0x902b102b, 0xb02ba02b, 0x052be02b, 0x560a4817, 0x5025122a, 0x461c0f0f, 0xc68507f6, 0x32f61023, 0x33471832, 0x15212510, 0x05031e21,
    0x08064149, 0x26343559, 0x0e222327, 0x3e2d0402, 0x6b75b47a, 0x4d447daf, 0x0180ce90, 0x25f6fee9, 0xfd1c3041, 0x6e472100, 0x476d4c4d, 0x3b4b4f21,
    0x2b5a8b5f, 0xc06ff801, 0x8a46508d, 0xda9c85cb, 0x299a3e8a, 0x367c6c5d, 0x3b699055, 0x4e866237, 0x2c59d790, 0x0000a163, 0xff120001, 0x826603e5,
    0x1c2508b1, 0x24403a00, 0x1f0d0f01, 0x0d06020d, 0x1e101e57, 0x3b1a2b01, 0x031a021a, 0xe0181047, 0x02180218, 0x0f1c5019, 0x07f44908, 0x2f01322c,
    0x5dc6e15d, 0x5ee6105d, 0xa656325d, 0x08e64905, 0x0807e746, 0x37352135, 0x8cfe6603, 0x243e2d19, 0x24282a12, 0x2e270d0d, 0x75401b35, 0xd7fe3459,
    0x9a4a0486, 0x523ba2fd, 0x06031733, 0x06870407, 0x1d060b0c, 0x0268864d, 0x83504a73, 0xffa42493, 0x823d04ec, 0x1d260893, 0x18402900, 0x571b4710,
    0x601f101f, 0x031f801f, 0x54054708, 0x0f06151e, 0x1600500d, 0x3fe13f00, 0xf6100133, 0x03825de1, 0x05303125, 0x51022e22, 0x59080723, 0x34353632,
    0x3327022e, 0x1015031e, 0x815c0202, 0xb62964aa, 0x46664220, 0x10098d92, 0x0fb60f17, 0xf4081018, 0xbd8c5014, 0xfd58026d, 0x638c56b2, 0x47f7e836,
    0x3d74757d, 0x8177723d, 0xfec1fe4b, 0x000200d3, 0x0514fe71, 0x005e0425, 0x00350025, 0x313c405e, 0x96164725, 0x1882a600, 0x26060037, 0x37571f48,
    0x0f013720, 0x37e00137, 0x7f376f01, 0x03379f37, 0x3b0f8340, 0x0602371f, 0x56064711, 0x0b502b36, 0x1631101a, 0x16012450, 0x3f001b00, 0x32e1333f,
    0x07530382, 0x08055308, 0x31231782, 0x4b110130, 0x3721050d, 0x051b4c17, 0x34111723, 0x08005136, 0x18011121, 0x0808694e, 0x02033ea2, 0x86b76d66,
    0x4e38204b, 0x3f258d2d, 0x5833192d, 0x91a54074, 0x3766925a, 0x68be9056, 0x361e4f01, 0x311b2b49, 0x7b481625, 0x14fe3359, 0x4305da01, 0x5397d589,
    0x377d8a98, 0x72683360, 0x996f477d, 0x02073061, 0x50c1bc5e, 0x957ac990, 0x054a90d9, 0x250426fe, 0x33659462, 0x41573517, 0x3b07a0fd, 0x00009f6b,
    0xfeecff01, 0x04250414, 0x0028004e, 0x681a40a0, 0x021f781f, 0x7709671f, 0x0309c709, 0x1c760609, 0x011c3701, 0x071e1c1c, 0xc0ffb808, 0x16130e40,
    0x01083448, 0x08081008, 0x120112c0, 0x3d081283, 0x480b0619, 0x0f2a1212, 0x4f2a3f2a, 0x042acf2a, 0xc025b006, 0x25250225, 0xffb81e1d, 0x1e1f40f0,
    0x1b1e291e, 0x06270617, 0x281c1802, 0x091c021c, 0x0004061f, 0x1b16500f, 0x50230f07, 0x36450f00, 0x17123505, 0x3f5d5d39, 0x2f330111, 0x2f333338,
    0x115d5e5d, 0x5d2b2f33, 0x5d3b0d82, 0x3912332b, 0x5d5d2f3d, 0x335d3333, 0x1330315d, 0x17021e32, 0x01330113, 0x5f031e13, 0xa508082a, 0x0327022e,
    0x03012301, 0x22232626, 0x36363507, 0x3a492dbc, 0x017b1531, 0x73feb21f, 0x261d0eb2, 0x2e1a2534, 0x28391610, 0x33475f43, 0xb6fe8317, 0xa0c601c2,
    0x2435471b, 0x043e161c, 0x5c3e1f4e, 0x02a8fe3d, 0xfef8fc4a, 0x33422620, 0x8d03051d, 0x46260b06, 0x6a014166, 0x3e0383fd, 0x594fbe01, 0x0a078f0a,
    0x00010000, 0x0514fea4, 0x00120671, 0x404c0027, 0x4717012f, 0x1e181826, 0x57114706, 0x40293029, 0xb0299029, 0x0529c029, 0x291f290f, 0x47210602,
    0x0b28541e, 0x26010f1f, 0x16191650, 0x00001b17, 0x15423f00, 0x084d4e06, 0x3911e123, 0x060f422f, 0x20064d4c, 0x053e4e33, 0x23110725, 0x42032e11,
    0x4a0806dc, 0x56031117, 0x345f834e, 0x10180f08, 0x101810b6, 0xc4935708, 0xbc6fb26d, 0x36b64c89, 0x0642785a, 0x0973fa12, 0x679c6c3c, 0x837e8047,
    0x7e834849, 0xdc9d447e, 0xfe07458c, 0x04da0126, 0x9ad68841, 0xd9fd1f02, 0x2e619a72, 0x828f0505, 0x713a08c1, 0x9605ecff, 0x3b004a04, 0x48407000,
    0x011d6738, 0x1ad5471d, 0x011ab701, 0x9a011aa9, 0x1a03011a, 0x4825051a, 0x043d5730, 0x023d143d, 0x3df43dc4, 0x9b3d7b02, 0x3d40023d, 0x07560201,
    0x48103a08, 0x1b3c5605, 0x0f0a2a1b, 0x39501520, 0x00160035, 0xe132323f, 0x39333f32, 0x20db862f, 0x06c84b5f, 0x5f21e082, 0x2200825d, 0x43395de1,
    0x342406b0, 0x3337023e, 0x2205f542, 0x433e3233, 0xa14905c0, 0x07c04305, 0x0e142708, 0x26222302, 0x06062327, 0x8c5ae901, 0x1f0f3260, 0x20ba202f,
    0x1d0f1f2f, 0x2e2d4b36, 0xb2162c44, 0x4b2d5163, 0x17831d36, 0x1783bb20, 0x60324708, 0x8b6b5a8d, 0x8b1f0a1f, 0xcb925214, 0x878f5179, 0x86494887,
    0x62528e87, 0x29346596, 0x01396248, 0x81cefe32, 0x9665348b, 0x878e5262, 0x87484986, 0x79518f87, 0x575292cb, 0x00575b5b, 0x1500ffff, 0x7702ecff,
    0x135cd905, 0x6a003b07, 0x0000e2fe, 0x0d401700, 0x111f0102, 0x32010226, 0x00142a16, 0x352b0125, 0x03830035, 0xa4243182, 0x3d04ecff, 0x92263184,
    0x06010000, 0x2f826a00, 0x02b61924, 0x2e832701, 0xdeffb825, 0x53321eb4, 0x3187062f, 0x280fd574, 0x00000e54, 0x020b4013, 0x2131822c, 0x4c18203d,
    0x5d840d1f, 0x82210621, 0x225d848f, 0x84105401, 0x2a01272b, 0x1d012611, 0x5985241e, 0xc9485882, 0x96052106, 0x96202b84, 0x07248982, 0xc3005401,
    0x21248b82, 0x48010940, 0x60302d82, 0xb83c013c, 0x0940c0ff, 0x3d480b09, 0x3005423c, 0x2b21c582, 0x6d46185d, 0x00c72507, 0x07be0300, 0x28915918,
    0x01006908, 0xecff1400, 0xb6050605, 0x85002500, 0x04045a40, 0x0f5a0c13, 0x21df0121, 0x210221ff, 0x270f2755, 0x277f276f, 0xf41a0603, 0x18a00118,
    0x740218b0, 0x18180118, 0x00135a12, 0x40153015, 0xc0155015, 0x15150515, 0x670113b0, 0x02137713, 0x3f01135e, 0x02134f13, 0x13011300, 0x1a1a5f11,
    0x5f151907, 0x12130316, 0x13005f07, 0x27051244, 0x2f391232, 0x5d2f01e1, 0x33250083, 0xe1105d2f, 0x270b8332, 0x105d5e32, 0xe1715df6, 0x31271c82,
    0x26220530, 0x42163527, 0x3526053f, 0x21232634, 0x8b702311, 0x32470807, 0x1515021e, 0x03020e14, 0x19462f9e, 0x2027441d, 0x69213340, 0xbbbbfe7b,
    0xb103acfe, 0x5a015efe, 0x3565925d, 0x14845f35, 0x09a00b0d, 0x5733130c, 0x74738545, 0x120523fd, 0x6ffea4a4, 0x598b5e31, 0x659a6989, 0x5dffff31,
    0x072505df, 0x01260273, 0x05c56661, 0x66330021, 0x012905c5, 0x01260512, 0x040c063e, 0x57551800, 0x014a0808, 0xecff7d00, 0xcb059804, 0x5f002600,
    0x40111340, 0x07481813, 0x1b110711, 0x700123ca, 0x02238023, 0xc0ffb823, 0x0a072440, 0x28232348, 0x050128bf, 0x661b5b08, 0x0f5f0827, 0x0205af05,
    0x0d050508, 0x205f0024, 0x105f0d04, 0x64181316, 0x01240c69, 0x32e1f610, 0x20051245, 0x05215a5d, 0x01303129, 0x07020e22, 0x45211521, 0x0e230606,
    0x5c222303, 0x17330af1, 0x03262607, 0x78a05f19, 0x74020d4d, 0x400586fd, 0x1871ab76, 0x29176a98, 0x6faf7a41, 0x8ac982a2, 0x98182348, 0x5973146b,
    0xcb052707, 0x36000602, 0xe95c0000, 0x30535712, 0xfe48ff27, 0x0573017b, 0x245182b6, 0x0000002d, 0x08558202, 0xdf06e96a, 0x2a00b605, 0x8d003500,
    0x5a2b25b5, 0xb8080d06, 0x5340f8ff, 0x08481714, 0x1e99235a, 0x1e101e01, 0x90060023, 0xe0060206, 0x23b40123, 0x23d423c4, 0x50230003, 0xa0239023,
    0x06070423, 0x15230623, 0x67005b2f, 0x0137cf37, 0x09064037, 0x36151548, 0x250f5f35, 0x080225af, 0x082b2525, 0x1903235f, 0x2b131260, 0x00120660,
    0x250aea77, 0x330111e1, 0xd1792b2f, 0x58392005, 0x5e2a05a4, 0x3833115d, 0x2be1105d, 0x9e491032, 0x11212708, 0x07030e21, 0x0c6d030e, 0x36372c0a,
    0x37121236, 0x32331121, 0x1801021e, 0x0807da65, 0xdf06237d, 0x86c27e3c, 0xc2febffe, 0x22211f0f, 0x4f351410, 0x4a234e6e, 0x203a171c, 0x1a2a3e30,
    0x27200c0c, 0x9302162b, 0x7ecf986d, 0x7777fd37, 0x5b2ea4ae, 0x01585d8b, 0x709e61ac, 0x7112053d, 0x51d4ecf4, 0x3b6fa267, 0x0d9a0b0e, 0x75623f10,
    0x01c83936, 0xaa3a0106, 0x714298fd, 0x849dfe98, 0x3c614688, 0x0002001b, 0x070000c7, 0x00b6050c, 0x00210016, 0x11324053, 0x060e5a17, 0x821b0a06,
    0x233108fe, 0x0f01230f, 0x7f231f23, 0x0423ff23, 0x0a5a090d, 0x08212264, 0x0d0f115f, 0x08020daf, 0x0b0f0d0d, 0x0a601703, 0x3f001206, 0x333fe133,
    0x5d5e2f39, 0x05544b33, 0x5b5d3221, 0x904606a7, 0x0e142305, 0xf3822302, 0x11231125, 0x82211133, 0x21e48d03, 0xe4850c07, 0xbab8fd26, 0xba4802ba,
    0x0229cd94, 0x0556fdaa, 0x0298fdb6, 0x74bc8d68, 0x052105ad, 0x08bd8206, 0x73001550, 0x5a084d40, 0x0f175507, 0x7f176f17, 0xf4060317, 0x14a00114,
    0x740214b0, 0x14140114, 0x0f5a0e00, 0x11301100, 0x11501140, 0x110511c0, 0x010fb011, 0x0f770f67, 0x010f5e02, 0x0f4f0f3f, 0x010f0002, 0x5f11150f,
    0x005f0d12, 0x03120700, 0xd683070f, 0x39123f25, 0x8210e12f, 0x442f20d4, 0x32200a38, 0x5e200c83, 0x2505374a, 0x1e322101, 0xd9821502, 0x210b2f44,
    0x10442302, 0x44ba2005, 0x03290a22, 0x8b5e3181, 0x01f2fd59, 0x071844f6, 0x27050d44, 0x7307a204, 0xb4012602, 0x20060d44, 0x060d4489, 0x26051726,
    0x110b2201, 0x82090d44, 0xff19262d, 0x07ae04ec, 0x202d8269, 0x232d83bd, 0x23003602, 0x27202d86, 0x0d232d82, 0x4413222c, 0x27080b3b, 0x047ffec7,
    0x00b605c1, 0x4063000b, 0xd602c641, 0x5a020202, 0x03d503c5, 0x0103a802, 0x03010396, 0x48110e10, 0x3a010347, 0x28080a82, 0x5a090503, 0xb00d6500,
    0x0d6f010d, 0x0daf0d9f, 0x010d1003, 0x64055a08, 0x03060a0c, 0x02055f08, 0x00050102, 0x2f33332f, 0x07324b10, 0xe2425d20, 0x5d2f3005, 0x5d5d2b5d,
    0x315de15d, 0x11212130, 0x41211123, 0x043405df, 0xb15afec1, 0x02ba5dfe, 0x7ffebb85, 0xb6058101, 0x1005f0fa, 0x420ffb62, 0x04210577, 0x08a18233,
    0x1b001031, 0x2e404b00, 0x0801085f, 0x5b151108, 0x0f1d6700, 0x7f1d5f1d, 0x041dcf1d, 0x5a110b06, 0x1b1c6406, 0xaf0b0f5f, 0x0b08020b, 0x5f0a110b,
    0x43110307, 0x12220776, 0xb7612f39, 0x5e322106, 0x0f829283, 0x01208b82, 0x20066f42, 0x0f4e4315, 0x3c330433, 0xfe86c27e, 0xfd140396, 0xcf9896a6,
    0x4efd377e, 0x053443a0, 0x34438120, 0xa4b62306, 0x1c433cfe, 0x06a3410b, 0x1808a163, 0x2c0a9541, 0x00610106, 0x00020000, 0x057ffe0e, 0x20c5820a,
    0x08c58211, 0x0b408b73, 0x1b281b18, 0x37071b02, 0xb8140114, 0x0b40f8ff, 0x14481714, 0x070f0e5a, 0xb8070701, 0x1040f0ff, 0x0ec00e30, 0x070e0702,
    0x5a12050e, 0x005a0110, 0x40c0ffb8, 0x48151025, 0x65100000, 0x011d201d, 0x08011d0f, 0x05055a04, 0x0e5f141c, 0x08510903, 0x5f06101b, 0x05050003,
    0x3f001203, 0x10332f33, 0x2f3232e1, 0x11e13fe2, 0xe12f3301, 0x105d5d5e, 0x1eab18e4, 0x5d56080a, 0x105d5e38, 0x115d2be1, 0x30315d33, 0x21112301,
    0x33112311, 0x2137053e, 0x11213311, 0x07050e21, 0xfcb00a05, 0x2f71b064, 0x30414d56, 0x6502041d, 0xfe83fec2, 0x2e1f04fa, 0x274d463d, 0x81017ffe,
    0x27027ffe, 0xe6d9c855, 0xfa69e3e8, 0x4c6a04f0, 0xc8d1cab9, 0x9b634bb7, 0x01002710, 0x00000400, 0xf5848106, 0x40cb4f08, 0x7609664e, 0x03098609,
    0x09470937, 0x09030957, 0x0d470606, 0x0d020df7, 0x7900695a, 0x03008900, 0x00480038, 0x00030058, 0x0ea80303, 0x99020eb8, 0x0e86010e, 0x670e5701,
    0x030e770e, 0x0a110e0e, 0x0b080807, 0x70010a00, 0xc00a800a, 0xf660030a, 0x073d0805, 0x100a480a, 0xf0130a0a, 0x13bf0113, 0x13df13cf, 0x0113a003,
    0x4001138f, 0x130f0113, 0x0802131f, 0x10010102, 0xf0ffb811, 0x11110f40, 0x03030612, 0x0e0a1104, 0x04010712, 0x333f0003, 0x23028233, 0x33113912,
    0x2006004c, 0x063d5e11, 0x33115d29, 0x5d2b382f, 0x82333371, 0x3912231a, 0x00825d2f, 0x5d2e0a82, 0x325de15d, 0x5d5d3311, 0x01013031, 0x36840133,
    0x01012408, 0x23110123, 0x02230111, 0xcdedfd25, 0x02b30a02, 0xedfdcd0a, 0xfdd32102, 0xeefdb3ee, 0x02f202d3, 0x873cfdc4, 0x0efd2503, 0x1bfde502,
    0x4e080383, 0x00010000, 0x03ecff48, 0x00cb05ec, 0x40680039, 0x005b273f, 0x30002105, 0x21000021, 0x1c130330, 0x3b670b5b, 0x70013b9f, 0x02138013,
    0x134f133f, 0x1303135f, 0x20053a13, 0x0121aa60, 0x0f012178, 0x21080121, 0x2c2f1921, 0x19043560, 0x47101460, 0xa6820cb6, 0xd0833920, 0x1020b482,
    0x07765c18, 0xf85b1120, 0x0e142306, 0xa0180702, 0x222b07ee, 0x1e352726, 0x36323303, 0x5b263435, 0x23210ae8, 0x276c1822, 0x03920808, 0x7d5b33d1,
    0x5e8a574b, 0xcd884332, 0x55c06e89, 0x6363602b, 0xcfb0b22e, 0x5cb0bfba, 0x2532618e, 0x6e3a5f44, 0x265c4ba9, 0x47837462, 0x3971a66d, 0x78496004,
    0x060c3958, 0x7759390b, 0x74a06048, 0xaa2d2240, 0x0d182417, 0x81878794, 0x65482797, 0x3a53363d, 0x7d36431e, 0x1829361f, 0x00856136, 0xc9000100,
    0x10050000, 0x1700b605, 0x1b406b00, 0x5a0e0b14, 0xd019650d, 0x19af0119, 0x30192001, 0x09160219, 0x64175a02, 0xb8091718, 0x14b3e8ff, 0x07824818,
    0x2340e031, 0x0648130a, 0x26091609, 0x0d090309, 0x82181412, 0x20142117, 0x09351382, 0x29141914, 0x14070314, 0x0003000b, 0x5e32323f, 0x3f2b2b5d,
    0x20048233, 0xfd9a1833, 0xf6103108, 0x313232e1, 0x11331330, 0x07020e14, 0x01330706, 0x09138518, 0x23013108, 0x0201aec9, 0x04040202, 0xd5cc0207,
    0x040406ac, 0x31fd0805, 0xfcb605d7, 0x433e1ae0, 0x4c4a2043, 0x4afab404, 0x8e391903, 0xfb4d4c41, 0xffff0046, 0x0725bd85, 0x01260269, 0x066945b2,
    0x52018932, 0x01b41500, 0x0126051d, 0xb4ebffb8, 0x0c001822, 0x240aa749, 0x040000c7, 0x30ed82a2, 0x405e000a, 0x09090821, 0x00010910, 0x02001000,
    0x08048207, 0xb00c0028, 0x0c2f010c, 0x010c1001, 0x56010a97, 0xb80a010a, 0x1440f8ff, 0x0a480c08, 0x5a030707, 0x070b6404, 0x05080402, 0x45640403,
    0x12332305, 0xd6843939, 0x2b331123, 0x3100835d, 0x382f3311, 0x33335d5e, 0x31331138, 0x01232130, 0xa1422311, 0xa2043705, 0xbabafddb, 0xcf3502ba,
    0xe502cbfd, 0xb6051bfd, 0xc4023cfd, 0xb08242fd, 0xff000025, 0x829304e9, 0x001f258f, 0x0308b162, 0x39086f83, 0x4817143b, 0x19895a03, 0x19101901,
    0xb4011ee0, 0xd41ec41e, 0x1e00031e, 0x1e801e50, 0x1e1e0703, 0x005a0110, 0x210f2165, 0x217f211f, 0x10100803, 0x1e5f0320, 0x11601403, 0x9683130d,
    0x2305bf5c, 0x5e2f3301, 0x2006f845, 0x2599825e, 0xe15d3833, 0xea64322b, 0x16ce4805, 0xba930424, 0xba4885fe, 0x48d0201a, 0x75441aa5, 0x0f4b6606,
    0x01680420, 0x0fb16508, 0xc72b0f82, 0xc1040000, 0x0602b605, 0x86006e01, 0x096b653f, 0x04272f85, 0x02cb0598, 0x84260006, 0x0ceb641f, 0x0806b955,
    0xb605ae5f, 0x6f002100, 0x01121040, 0x21131b1b, 0x00700060, 0x00f000b0, 0xffb80004, 0x061040c0, 0x1000480a, 0x0f230000, 0x02237f23, 0xb8130914,
    0x0c40f0ff, 0xe7221313, 0x021af71a, 0x1a011ad6, 0x40e0ffb8, 0x480e0a10, 0x031a0112, 0x0a5f0d00, 0x00131306, 0x323f0003, 0x11e1333f, 0x5d2b3917,
    0x0694445d, 0x29068c44, 0x11391233, 0x30313333, 0x0e4a0101, 0x0152080d, 0x031e0133, 0x033e3317, 0xae040137, 0x532654fe, 0x336f9c70, 0x5925255a,
    0x42523534, 0xeefd1c38, 0x057f01cc, 0x0409090a, 0x0b0b0302, 0x3701030b, 0xfafbb605, 0x487ba45d, 0x14b90f0f, 0x56351719, 0xfc3f043f, 0x1a180ad7,
    0x1f090917, 0x03071d21, 0x794b0018, 0xba052105, 0x0121ff83, 0x23ff8473, 0x04000000, 0x240bad64, 0x057ffec7, 0x32ff8271, 0x403b000b, 0x025a0321,
    0x005a0902, 0x010db00d, 0x48010daf, 0x002d0a12, 0x02055f08, 0x00120502, 0x102f333f, 0x30d982e1, 0xe1f61001, 0x105d5d5d, 0x2f33e1d4, 0x253031e1,
    0x0b0b4833, 0xfcb0b02a, 0x8502ba06, 0xd9fda6bb, 0x23070b48, 0xa6000100, 0x81207982, 0x32086982, 0x40480015, 0x5a01131d, 0x70176500, 0x0217a017,
    0x1001172f, 0x5a0d0117, 0x0a700a60, 0x0ab00aa0, 0xffb80a04, 0x070e40c0, 0x130a480a, 0x05055f10, 0x42030b14, 0x39270590, 0x0133e12f, 0x845d2b2f,
    0xe1f62178, 0x23058742, 0x22230606, 0x0806c753, 0x32331629, 0x33113736, 0x73ba8104, 0x925d62c3, 0x69ba3565, 0x70b95a7b, 0x2c5602ba, 0x8a5f312e,
    0xfd470259, 0x287473d1, 0x82c60228, 0x00c7248d, 0x84330700, 0x40603af7, 0x01085642, 0x05175a08, 0x96058601, 0x0305a605, 0x05770567, 0x01050502,
    0x08a38209, 0x0d000d32, 0x20020d10, 0x700d500d, 0xc00d800d, 0xe00dd00d, 0x0d0f070d, 0x5a040701, 0x0a0c6401, 0x08030206, 0x12015f04, 0x32e13f00,
    0x0133333f, 0x5ee1f610, 0x2205a859, 0x822f3911, 0x06284908, 0x2905044b, 0x07331121, 0xba94f933, 0x02831f02, 0x24052449, 0x1005f0fa, 0x238f8300,
    0xe3077ffe, 0x47088f82, 0x4071000f, 0x010c564b, 0x09175a0c, 0x96098601, 0x0309a609, 0x09770967, 0x05090902, 0x03005a0d, 0x0002025a, 0x11001165,
    0x20021110, 0x70115011, 0xc0118011, 0xe011d011, 0x110f0711, 0x5a080701, 0x0e106405, 0x0c03060a, 0x8c0eb141, 0x32e4259c, 0xe110e12f, 0xbd41a089,
    0x8411200b, 0xb0b021a4, 0xc441a688, 0x26ab850a, 0x00140002, 0x49d50400, 0x522b06c5, 0x110b3340, 0x0106905a, 0x49080606, 0x012e06c8, 0x1d2f1d0f,
    0x1d5f1d3f, 0x06051daf, 0xca490808, 0x5f08220b, 0x0fca4909, 0x33011124, 0x3c4c5e2f, 0x4d5d2007, 0x35200b30, 0x3810cc49, 0xc27e3cd5, 0xfe95fe86,
    0x950f02ac, 0x377fcf98, 0xaea04efd, 0x8a5c2da3, 0x07cc495d, 0x4ca41221, 0x03260d2c, 0x0000c700, 0xab82cf05, 0x000e3108, 0x001d0019, 0x132b4049,
    0x0100005b, 0x1a060000, 0x1f651d5a, 0x1f9f1f0f, 0x0f090602, 0x1e64065a, 0x090f5f19, 0x080209af, 0x071b0909, 0x1a600f03, 0x5e0be44c, 0x8a68075f,
    0x31e12106, 0x4c050359, 0x012311d9, 0x4a113311, 0xba200773, 0x220e704a, 0x4abb9303, 0xa58c0773, 0x0556fd25, 0x4b4afab6, 0xab830a1d, 0x2e404825,
    0x82905b13, 0x1b6731a9, 0x1b5f1b0f, 0x401b0602, 0x1b481815, 0x48130d40, 0x1a20ae84, 0xad83ae89, 0xe121ac83, 0x091b4b3f, 0x5e2b2b25, 0x74f6105d,
    0xa8910885, 0xa194a497, 0x43088682, 0x04ecff3b, 0x00cb0544, 0x40510024, 0x5b201d2f, 0x161e160c, 0x670c041e, 0xcf26bf26, 0x0326df26, 0x1e250404,
    0x011faa5f, 0x0f011f78, 0x1f08011f, 0x5f1a071f, 0x03131117, 0x04075f00, 0x33e13f00, 0x11e1333f, 0x5d2e9e83, 0x0111e15d, 0x105d2f33, 0x393911e6,
    0x214f2f2f, 0x06222805, 0x36362707, 0x18163233, 0x2108d867, 0x9751022e, 0x12990805, 0x21352113, 0xba01032e, 0x4e3f945e, 0xa26cc44f, 0x5252a2f4,
    0x3aa4f7a5, 0x274e5661, 0xed59a04e, 0x8bfd06f7, 0x47097102, 0x27059d73, 0x2a9c202e, 0xfec16d2c, 0xfeb39df6, 0x076dcae0, 0xa20f170e, 0x17012317,
    0x6fa20601, 0x00407ab0, 0xffc70002, 0x059e07ec, 0x001a00cd, 0x405e002e, 0x0a5b1b3c, 0x11011190, 0x5b250d11, 0x0f306700, 0x303f0130, 0x307f306f,
    0x30ff30ef, 0x11403005, 0x0c104814, 0x2f640d5a, 0x04165f2a, 0x100f5f0b, 0x10100801, 0x0d030e0d, 0x055f2012, 0x21d48213, 0x8d4c3f3f, 0x423f2005,
    0x2b20051e, 0x2408c542, 0x3031e133, 0x08446e01, 0x11212729, 0x11331123, 0x84033e21, 0x099c59e1, 0x022e2b08, 0x020e2223, 0x9b4f9e07, 0xe19796e5,
    0xfe065098, 0x01babaae, 0x98550b56, 0xe59591db, 0xfafb4f9a, 0x6c9d6731, 0x30669d6d, 0x07826530, 0x31679e2e, 0xfea9dd02, 0x646cc6ea, 0xa00301b7,
    0x26051e4f, 0x5aa7ec92, 0x18fec56b, 0x08141fa3, 0x0000192b, 0xb605f203, 0x1c000f00, 0x09409b00, 0xe6010006, 0x0200f600, 0xf8ffb800, 0x0f0b2440,
    0x5a0e1c48, 0x08000003, 0x3f1e650d, 0x9ea1181e, 0x0106280b, 0xf601e601, 0x83010201, 0x820d2028, 0x01590828, 0x0201024b, 0x480b0840, 0xf0ffb802,
    0x02022640, 0x08df5b16, 0x08ff08ef, 0x0f400803, 0x08074813, 0x08020817, 0x1c1d6608, 0x0f0f0360, 0x0b601101, 0x12010e03, 0x3f333f00, 0x2f3912e1,
    0x1001e133, 0x2b5d5ef6, 0x2f33e15d, 0x335d2b38, 0x5d715d2b, 0x11f6105d, 0xe1331139, 0x300c8232, 0x01013031, 0x032e0123, 0x33363435, 0x11231121,
    0x08e15d11, 0x02338908, 0xdbb2fe42, 0x63377d01, 0xfbfd2c4b, 0xbcbb7501, 0x294f734a, 0x51774e27, 0xfd5c02b4, 0x148f02a4, 0x5d88613e, 0x4afac9c6,
    0xbb025c02, 0x44613e1d, 0x284a6942, 0x00ffff00, 0x03ecff5e, 0x025e049c, 0x00440006, 0x00020000, 0x04ecff75, 0x00230621, 0x003b0027, 0x2d2c4049,
    0x571e0948, 0x013dd03d, 0x40013d7f, 0x3d0f013d, 0x37130601, 0x3c560048, 0x19135032, 0x50280819, 0x08091623, 0x0948100b, 0x00010851, 0x3f2be13f,
    0x62056957, 0x102b0964, 0x31e132f6, 0x12341330, 0x82373636, 0x0e172302, 0x02820703, 0x5e183320, 0x01200d0c, 0x83068b6c, 0x07c008cf, 0x75021e14,
    0x71a26831, 0x2166f27d, 0x757d7b32, 0x48643e2c, 0x120d0429, 0x406b543e, 0x32659663, 0x68ae7c45, 0x427bad6b, 0x623ce101, 0x3a1a2646, 0x6a3d415a,
    0x190d3953, 0x93027241, 0xcb1901b5, 0x311b197e, 0x1608a014, 0x0e0a1818, 0x71a57142, 0x20313c1d, 0x6cb48349, 0x458ace89, 0xfefdad59, 0x8f582794,
    0x5f865469, 0x49443033, 0x93bc641a, 0x00030059, 0x040000ae, 0x004a0419, 0x00200015, 0x405c002b, 0x211b033a, 0x0f000046, 0x57094716, 0x012d202d,
    0x2d902d40, 0x2dd02db0, 0x0f052df0, 0x2606012d, 0x540f471b, 0x501a032c, 0x790126bf, 0x02268926, 0x251b2626, 0x1b0f1050, 0x00150f50, 0x600eb865,
    0x2f28098e, 0x313912e1, 0x06140130, 0x29088e4c, 0x32211121, 0x3403021e, 0x09832326, 0x09863e20, 0x82323321, 0xf6500809, 0x61386b7b, 0x652f2947,
    0x39fe719f, 0x8e53c501, 0x82903b67, 0x0100ff80, 0x435d3804, 0x6c6d1e26, 0x3eecf5fe, 0x031f3f5c, 0x12756835, 0x3d240707, 0x74433f5b, 0x4a043056,
    0xfd6b401c, 0xfe485cc7, 0x452a12a8, 0x404d0c02, 0x240fd7fe, 0x0100003c, 0x0321e383, 0x3fe3820a, 0x402f0005, 0x1000001c, 0x00000200, 0x0107a007,
    0x50010781, 0x47020107, 0x01065403, 0x020f0450, 0x09244118, 0x115d5d25, 0x825d2f33, 0x11212fb2, 0x03211123, 0xb65afe0a, 0xb0035c02, 0x458250fc,
    0x29000226, 0x370483fe, 0x5a080982, 0x0017000f, 0x17104079, 0x0c461207, 0x073f072f, 0x1b070b02, 0xb8070207, 0x3940f0ff, 0x0cb20ca2, 0x140c0402,
    0x0c07020c, 0x10050c07, 0x46010e47, 0x0e200000, 0x19550e01, 0x19cf19af, 0x01193002, 0x0401192f, 0x18050546, 0x0f0c4f12, 0x50060e17, 0x00051503,
    0x323f00fb, 0x8232e13f, 0x01112103, 0x2106f966, 0x8b475de4, 0x2f392b06, 0x385d5d2f, 0xe1105d5d, 0xc94f3311, 0x1202210a, 0x0805ca4f, 0x030e2331,
    0xae370407, 0x56ae4efd, 0x22436341, 0x97170201, 0x07c0b2fe, 0x34513a24, 0x7d0183fe, 0x170283fe, 0x01f3df5f, 0x50fc7f00, 0xd7672403, 0x6053c2d1,
    0x032905a5, 0x025e04e1, 0x00480006, 0x05c14f00, 0x82be0521, 0x112208db, 0x1f409c00, 0x0a030306, 0x00000f46, 0xb9010bd6, 0x020bc90b, 0x97010ba6,
    0x0b0b010b, 0x0504070e, 0xe8820805, 0x12b3c024, 0x07834815, 0x24402e08, 0x0f480b07, 0x07060107, 0x13070710, 0x13101300, 0x0113df02, 0x13701330,
    0x0f031390, 0x11070113, 0x0e0d1010, 0x40f0ffb8, 0x120e0e0f, 0x27698203, 0x150a080d, 0x0f010411, 0x2817984f, 0x2f331171, 0x2b5d5e38, 0x0e974f2b,
    0x8432e121, 0x0d8f4ffc, 0x3301013e, 0x01a48f02, 0x58fec5a0, 0xfecece01, 0x44fea443, 0xfecf01cf, 0x3502c558, 0xebfd1502, 0xfd250383, 0xfd2d02cb,
    0x820384d3, 0x32e98213, 0x03ecff44, 0x005e0452, 0x405f0039, 0x1646053a, 0x8239161b, 0x0c310801, 0x57214734, 0xc03bb03b, 0x033bd03b, 0x20013b6f,
    0x0c29013b, 0x381b3a56, 0x0139cf50, 0x39993989, 0x01390f02, 0x11393908, 0x1626502f, 0x10115008, 0x08697200, 0xe15d5d27, 0xe6100139, 0x068a4f32,
    0x2f393923, 0x06884f2f, 0x023e3225, 0x4f263435, 0x15200a6b, 0x85139a4f, 0x23610824, 0x3d710135, 0x73274864, 0x4b81476c, 0x524d283f, 0x9056355a,
    0x331c3a69, 0x522c2b46, 0x6c35263f, 0xaf6d71a6, 0x574c1f3a, 0x60373361, 0x8a852946, 0x12870281, 0x4d2d4027, 0x9322264d, 0x09131c14, 0x466d4a26,
    0x293b4d32, 0x2c0e0b0e, 0x433e5a42, 0x23315675, 0x1f10a622, 0x2a120f18, 0x5b5e3345, 0x05114399, 0x3b043108, 0x0b004a04, 0x1b405100, 0x18091003,
    0x46060348, 0x000d5505, 0x200d100d, 0xc00da00d, 0xf00dd00d, 0xb80d070d, 0x0eb3c0ff, 0xb8094811, 0x1140f0ff, 0x092d2582, 0x540a4600, 0x0b03080c,
    0x0a02060f, 0x06ba4115, 0xf6100127, 0x2b2b32e1, 0x0806845d, 0x01303127, 0x33010711, 0x13112311, 0x01112301, 0x04020c5a, 0xfd0bace9, 0x4a04eafe,
    0x03fc64fd, 0x02b6fb98, 0xfc0f0187, 0x667c826a, 0x043f058b, 0x0217063b, 0x00d20126, 0x02060100, 0x00002536, 0x1101b415, 0xb8012611, 0x16b4ffff,
    0x4f040a0c, 0xae240a4f, 0xe5030000, 0x0a283882, 0x23404100, 0x04010100, 0x37053a63, 0x0c030310, 0x0a010c0f, 0x07470602, 0x02050b54, 0x00070a0a,
    0x07040f08, 0x3f209f83, 0x8405494d, 0x5d3230a2, 0x382f3311, 0x1133335d, 0x01303133, 0x4f010133, 0x022b0635, 0x61fec4fa, 0xfecec601, 0x82b4b44b,
    0xfdf126a5, 0xfd2d02c5, 0x280982d3, 0x000100eb, 0x03f2ff10, 0x087382b0, 0x4c001434, 0x46033140, 0xf4011304, 0x13800113, 0x13c01390, 0x540413d0,
    0x13130113, 0x0047010b, 0x160f1655, 0x16ff162f, 0x0b0b0603, 0x13500315, 0x084f0e0f, 0x81820116, 0x53e13f21, 0x5e200595, 0x2306224f, 0x715d5d5d,
    0x20060874, 0x057d6802, 0x35273008, 0x36323316, 0x21371236, 0xfeb6b003, 0x5f4014fe, 0x311c5682, 0x371b1710, 0x12334559, 0xb0035402, 0x94fefdfe,
    0x060669e6, 0xf1750683, 0x41fa6f01, 0x052105bf, 0x08958210, 0x5e002042, 0x011f3f40, 0x22550046, 0x400122cf, 0x02225022, 0x0601220f, 0x11461013,
    0x0f022154, 0x0f4b0f3b, 0x09030f5b, 0x290f190f, 0x1f0f030f, 0x19340f12, 0x19541944, 0x16190603, 0x03192619, 0x11010919, 0x3325a382, 0x5d5d3333,
    0x2104833f, 0xbf463311, 0x4d102008, 0x0e2a073d, 0x23010703, 0x27032e01, 0x1e822311, 0x17031e35, 0x0137033e, 0xa1100533, 0x12141106, 0x87f8fe07,
    0x8305f7fe, 0xa2320809, 0x0d0b01dd, 0x040f1316, 0x16130e06, 0xd90e010d, 0x39158103, 0xfd12363b, 0x0db00250, 0x1a3e3b31, 0x4a047ffc, 0x432247fd,
    0x1110323c, 0x21413b31, 0x8942bd02, 0x5b44080c, 0x06021740, 0x0d550547, 0x0d200d00, 0x400d3002, 0xd00d500d, 0x050df00d, 0xc0ffb80d, 0x110e2340,
    0x47090148, 0x080c540a, 0x0101eb50, 0x01b901a9, 0x1f010f02, 0x03012f01, 0x0a010106, 0x00031505, 0x323f000f, 0x21056f58, 0x6d495d5d, 0x3132260b,
    0x21110130, 0x057e4e11, 0x01112338, 0xb6210264, 0xb6dffdb6, 0x39fe4a04, 0xb6fbc701, 0x17fee901, 0xb1654a04, 0xae280812, 0x12040000, 0x07004a04,
    0x1c402d00, 0x55044705, 0x20091009, 0x70096009, 0x05098009, 0x54014700, 0x02500708, 0x1500050f, 0x71847883, 0xe5755d20, 0x64012e0c, 0xb66403b6,
    0x4a0408fe, 0xb003b6fb, 0x2b618200, 0x0414feae, 0x025e043f, 0x00530006, 0x71240f83, 0x6f03ecff, 0x462a0f84, 0x01000000, 0x00002900, 0x71845e03,
    0x3c405828, 0xdf010920, 0x6c830109, 0x095f0228, 0x01000f01, 0x058200cc, 0x8200bf21, 0x02003d3d, 0x05600347, 0x05d00570, 0x01051f03, 0x03000505,
    0x03b00310, 0x030403c0, 0x06500501, 0x3006c946, 0x5d2f0132, 0x5d5d2f33, 0x2f32e110, 0x715d5d5e, 0x4603825d, 0x353b07d2, 0xfe5e0321, 0xc1feb7c1,
    0xb0033503, 0xb00350fc, 0x00ffff9a, 0x0314fe0a, 0x824a04df, 0x825c205f, 0x00032c8d, 0x0514fe71, 0x00140623, 0x82220019, 0x74300899, 0x00274b40,
    0x171d460b, 0x49130d0c, 0x0cc90cb9, 0xa70c9702, 0x0c0c020c, 0x05482312, 0x2b202b57, 0x012b0f01, 0x2bef2b9f, 0x012b8002, 0x40012b6f, 0x1f371083,
    0x1a06022b, 0x2a561248, 0x1e260018, 0x10170050, 0x0a501d27, 0x620b160d, 0x322209be, 0x104f013f, 0x759e8305, 0x2b2508c7, 0x32e13333, 0x60ad8232,
    0x83080cac, 0x37023e34, 0x14013311, 0x0e111716, 0x26340503, 0x36361127, 0xbd712103, 0x86474c88, 0x72aa77be, 0x474c89bf, 0xaa79c185, 0xae9c0cfe,
    0x25507d58, 0xaa9b3903, 0x5a0499ac, 0xc68f550c, 0x91c87d7d, 0x24fe0b56, 0x560adc01, 0x7d7ec990, 0x0b558fc7, 0x13fcba01, 0x0313d2bb, 0x673d093c,
    0xccba5e91, 0x14c6fc14, 0xffff00d1, 0x00002300, 0x4a04db03, 0x5b000602, 0x01000000, 0x83feae00, 0x4a04b204, 0x44000b00, 0x4732d682, 0x0601000f,
    0x47070000, 0x0a010a8f, 0x200d100d, 0xf94f600d, 0x06063206, 0x0c540347, 0x0a0f0408, 0x15035006, 0x3f00fb01, 0x0809513f, 0x5dd41028, 0x5e2f33e1,
    0xba47e15d, 0x05ef4f06, 0xb2043336, 0xb6b2fcb6, 0xa0b6f801, 0x7d0183fe, 0x50fc4a04, 0x50fcb003, 0x9a207382, 0xfe208382, 0x18287382, 0x1c403100,
    0x0b470c08, 0x08f29b18, 0x1747012c, 0x03081954, 0x0b121250, 0xf6420915, 0x2f392205, 0x08b664e1, 0x60823220, 0x3314112b, 0x37023e32, 0x23113311,
    0x073a6511, 0x50012b08, 0x4c502db8, 0xb6b62a4d, 0x5e55502c, 0x527a4e3a, 0xfe4a042b, 0x1c0fae66, 0xd5011c2c, 0xe901b6fb, 0x1120301e, 0x4473542f,
    0x9943a601, 0x46062105, 0x2f08f384, 0x00434066, 0xc609b647, 0x09a90209, 0x09740301, 0x09940984, 0x01096703, 0x05090906, 0x55044701, 0x010d200d,
    0x80010d0f, 0x020df00d, 0x40010d6f, 0x2f300d83, 0x0806020d, 0x0c540547, 0x05500800, 0x02060a15, 0x2105e847, 0xed4132e1, 0x07ae6408, 0x5d5d5f22,
    0xe1230282, 0x5a253031, 0x11200628, 0x032f0782, 0xb7ba01d5, 0x01b668fa, 0x039ab6bb, 0x41b6fbb0, 0x89410517, 0xe5062105, 0x0f2d9582, 0x4e407700,
    0x07b6470a, 0xa90207c6, 0x32958207, 0x94078407, 0x07670307, 0x07070601, 0x0e470b03, 0x820e4701, 0x0024082e, 0x0e010ebf, 0x01112011, 0x4001110f,
    0xe0118011, 0x0411f011, 0x112f110f, 0x47060602, 0x0c105403, 0x0e0f0408, 0x200bac41, 0x0aa15132, 0xc4107126, 0x5d2f325d, 0x88050751, 0x5a0120a6,
    0xa88308d1, 0x06331126, 0x7ffab6e5, 0xb182a883, 0xc3419f20, 0xb0032b0b, 0x020050fc, 0x00002900, 0xb182fc04, 0x000e3708, 0x405c001b, 0x04470f3e,
    0x1d501d57, 0x1d901d60, 0x3f041de0, 0x1600011d, 0x0c000a47, 0xb0020c10, 0x020cf00c, 0x0a000c0c, 0x0a500a10, 0x0aa00a60, 0x150a0805, 0xc583bf50,
    0x500c1627, 0x50160f0d, 0x09634b0a, 0x2f01e12c, 0x2f335d5e, 0xe110715d, 0x745c5d32, 0x05e17308, 0x21112128, 0x34012135, 0x5c4b022e, 0x48022506,
    0xccd41401, 0x0805504b, 0x0298fe28, 0x2102021f, 0xff406041, 0x37040100, 0x0226445d, 0x4d9b9c87, 0x032f587c, 0xf8fc9ab0, 0x11284231, 0x2911a8fe,
    0x1b4c0042, 0x053f0805, 0x004a0450, 0x0010000c, 0x4061001d, 0x00471840, 0x20041004, 0xd0047004, 0x04060504, 0x470e0a04, 0x0f1f550d, 0x1fbf011f,
    0x1fdf1fcf, 0xa0041fff, 0x1f0f011f, 0x07021f7f, 0x0a471200, 0x85111e54, 0x0b0f25be, 0x0e50120f, 0x115ebd83, 0x069e4505, 0xc1635e20, 0x05164309,
    0x87323321, 0x01332bc0, 0x01331123, 0x3e323311, 0xc8833502, 0xec640122, 0x622dc186, 0xb6ec03b6, 0xdb14fcb6, 0x26435d38, 0x87c78221, 0x4a0427bf,
    0x4a04b6fb, 0xbe84a4fd, 0xc8833020, 0x02000022, 0x3e08df4c, 0x0019000c, 0x14294040, 0x1b570447, 0x00011b00, 0x701b201b, 0xb01b901b, 0x061bd01b,
    0x820e0008, 0x0d1a21ac, 0x0b22ac85, 0x68410e0f, 0x2f392106, 0x7127a888, 0x31e1f610, 0x89210130, 0x111122a0, 0x219c8921, 0x9d861501, 0x01b63923,
    0x8c989104, 0x014b0894, 0xecff3700, 0x5e044203, 0x5e002600, 0x0e0e3e40, 0x480f0c04, 0x8f285722, 0x0228af28, 0x18012840, 0x041f040f, 0x0403042f,
    0x48110c40, 0x0d275804, 0x010eef50, 0x0eb90ea9, 0x1f0e0f02, 0x030e2f0e, 0x070e0e06, 0x101d5112, 0x70005107, 0xe1250ce1, 0x2be61001, 0x050d4271,
    0x39113223, 0x0cba622f, 0x3521372b, 0x23262621, 0x07020e22, 0x09824e27, 0x42014c08, 0x36367c59, 0x74495283, 0xfe043052, 0x0ddb0123, 0x3b198c92,
    0x3517383c, 0x4e484018, 0x84b36626, 0xba8c514d, 0xa21d1e14, 0x54282519, 0xa69a5c84, 0x130f0997, 0x160c9a0a, 0x893e0910, 0xd4929ddb, 0x0000438a,
    0xffae0002, 0x820806ec, 0x821a20d1, 0x722008d3, 0x481b4b40, 0x0111200a, 0x1101114f, 0x48210d11, 0x0f285700, 0x02282f28, 0x28ff28ef, 0x01284702,
    0x26080c84, 0x0d470c10, 0x50242754, 0x500b1016, 0xa90110ef, 0x0210b910, 0x0b01102c, 0x02101b10, 0x0d101006, 0x150d0f0e, 0x8405501e, 0x123f21e0,
    0x21051552, 0x4551e15d, 0x09374206, 0x51715d21, 0x0e250547, 0x2e222302, 0x0b455102, 0x18021e21, 0x080b9583, 0x40080623, 0x626aab78, 0x074675a2,
    0xb6b6effe, 0x480a1301, 0x6263a076, 0xfd4479a7, 0x8f8e8029, 0x8e8f807e, 0x056b6c7e, 0xbe814230, 0x0417fe7c, 0x7439fe4a, 0x4b3e78b1, 0xa018d391,
    0x3e080b77, 0x03000023, 0x004a0491, 0x001c0011, 0x02144053, 0x18071111, 0x550e470f, 0x6f1e0f1e, 0x031e8f1e, 0xb8010006, 0x1940f0ff, 0x46120101,
    0x15124007, 0x1d560748, 0x18501002, 0x50190018, 0x480f0f0d, 0xce820629, 0x0132e137, 0xe12bf610, 0x33382f33, 0xf6105d5e, 0x391132e1, 0x30313311,
    0x05e45033, 0x023e4208, 0x23112133, 0x14032311, 0x3333021e, 0x06222311, 0x2301c6e9, 0x2841542d, 0x538a6438, 0xf4b6bc01, 0x5a4125dd, 0x6bfedb36,
    0x0ccd0168, 0x476c4c30, 0x2a51794e, 0xb001b6fb, 0x46305401, 0x6601162e, 0x075d485f, 0xd905e12b, 0x48002602, 0x06010000, 0x97741800, 0x01002b1c,
    0x14fe1200, 0x14061204, 0xdb823100, 0x1f322c08, 0x2d470c17, 0x33103355, 0x33803360, 0x1e222303, 0x171b4716, 0x19213254, 0x1a1a1e4f, 0x5010231c,
    0x29102900, 0x29032920, 0x18001c0f, 0x220bbf5c, 0x7c33e15d, 0x32220884, 0x257132e1, 0x39122205, 0x7a5d1831, 0x1811200c, 0x2109c85c, 0x65183523,
    0x142410c6, 0xf002020e, 0x09d15c18, 0x51706928, 0xb61d436e, 0x65189c9c, 0x5c180dd3, 0x44200ed5, 0x15e16518, 0x4dbefc26, 0x002f577b, 0x2e056b4c,
    0x21060a03, 0xcd012602, 0x06010000, 0x66d47600, 0x122705f1, 0x45012611, 0x61030c06, 0x97490b25, 0x00330806, 0x404f0022, 0x16171731, 0x8f240d1f,
    0x0224af24, 0x16012440, 0x56054819, 0xef501923, 0x16a90116, 0x0f0216b9, 0x2f161f16, 0x16060316, 0x51131c16, 0x431c100a, 0xf6261194, 0x5d5d32e1,
    0x9243ce10, 0x022e2107, 0x6e058b7c, 0x0624063b, 0x21152107, 0x2208fe72, 0x18655202, 0x380f35ab, 0x010e928b, 0x0923fedb, 0x83518a92, 0x147b3636,
    0x96d5893f, 0x3e89db9d, 0x05226e22, 0x9aa69729, 0x1925a4b8, 0x821e1da2, 0xff5a23e3, 0x5f4a03ec, 0x00562105, 0xa020f383, 0x7527e982, 0x0602e505,
    0x82004c00, 0xeeff210f, 0x2ded7518, 0xffffff26, 0x0114febc, 0x4d214185, 0x083c8200, 0xff100041, 0x041206f2, 0x001d004a, 0x406b002a, 0x1c460c45,
    0x0a472500, 0x90011cd4, 0x021ca01c, 0x00011c24, 0x0a1c011c, 0x1e140a1c, 0x2c570447, 0x2c2f2c0f, 0x2c5f2c3f, 0x2cbf2c7f, 0x14072cef, 0x45242b14,
    0x25290564, 0x0f1c500c, 0x16114f17, 0x066b4525, 0xe13fe126, 0x5d2f3912, 0x2706f855, 0x3911e1f6, 0x5d2f2f39, 0x10270082, 0xe11032e1, 0x46013031,
    0x2320091b, 0x3610384d, 0x022e3401, 0x33112323, 0x03023e32, 0xcbd4ec87, 0x719f652e, 0x4dd962fe, 0x2b2b0f4a, 0x4121d901, 0xdbd74060, 0x46435d38,
    0x5e4d0af6, 0x0b04470e, 0xae000226, 0x75060000, 0x2a08ef82, 0x00210014, 0x05304053, 0x0f02471c, 0x4715130f, 0xef235709, 0x23800123, 0x01233f01,
    0x01012310, 0x54134712, 0x50111b22, 0x8201bf05, 0x1c002400, 0x4c0f1350, 0xcc820892, 0x655d2f21, 0x1e500803, 0x6b112005, 0x21220896, 0xb9823311,
    0x2208b947, 0x8a112311, 0x640124ce, 0x46b6cf01, 0xfe2e08fa, 0x1505b631, 0x3f614121, 0x5d37dcd8, 0xc04c2644, 0x3dfe2105, 0x4c05bf47, 0xbd8b05c6,
    0x12000127, 0x12040000, 0x26bb8506, 0x01146832, 0x18000b14, 0x21179269, 0x69180e0e, 0x0f230b8d, 0x180b0010, 0x180c8d69, 0x230e8c69, 0x315d3911,
    0x0c84a918, 0x2112c643, 0xb9435c03, 0x18022016, 0x321b8d69, 0x0000ae00, 0x2106e503, 0xd4012602, 0x06010000, 0x43087600, 0x172805a7, 0x0c012611,
    0x0307110b, 0x4c071150, 0x062507b1, 0x00260217, 0x222b835c, 0x85b13602, 0x8228202b, 0x2d0a232b, 0x73180023, 0xc34b09cb, 0x04122205, 0x08d7824a,
    0x3d405924, 0xb70106d6, 0x0206c706, 0x07b54706, 0x07d507c5, 0x86077603, 0x074a0207, 0x0702075a, 0x47010907, 0xd74b5504, 0x0005340a, 0x0c540947,
    0x09500005, 0x0afb0615, 0x3f000f02, 0x4b3f3f33, 0x1128096f, 0x5d5d2f39, 0x5d5de15d, 0x2e08c24a, 0x11211123, 0x01640133, 0xb3feb6f8, 0x4aa0feb7,
    0x1a4a05c2, 0x21a68205, 0xe182c700, 0xe306be31, 0x44000700, 0x5a002c40, 0x03ef03df, 0x500303ff, 0x033505cc, 0xd009b009, 0x090f0209, 0x050209af,
    0x0864065a, 0x20075f04, 0x2e008201, 0x12060307, 0x333f3f00, 0xe1105d2f, 0x82f61001, 0x8211206e, 0xe15d260b, 0x11013031, 0x316f8233, 0x0e031123,
    0xbac3fdb0, 0x2d01b605, 0xf0fa2dfe, 0xc34bb605, 0x0a032305, 0x69828905, 0x1c403034, 0x00004705, 0x00020010, 0x47020900, 0x10085403, 0xff822006,
    0x4f010622, 0x8207f954, 0x8358834e, 0x20558356, 0x05ae5d21, 0xfe0a0332, 0xa601b65a, 0xfcc103b6, 0x014a043f, 0x00ffff3f, 0x0e655818, 0x00430023,
    0x050761e7, 0x26052b2b, 0xacffb801, 0x1e2b31b4, 0x0aa5410e, 0x0d675818, 0x4300062a, 0x1500004c, 0x113001b4, 0x9e252d83, 0x113036b4, 0x182d8d2e,
    0x230bc358, 0xa0017600, 0x13245d82, 0x37010b40, 0x64225e82, 0x5b9a312b, 0x2d820720, 0x00001724, 0x2d821300, 0x5e823c20, 0x36306922, 0x2b2c5b92,
    0x3a002602, 0x07010000, 0x39016a00, 0x19275b82, 0x340102b6, 0x82022605, 0xb4ff23bb, 0x5f853f2b, 0x8408876d, 0xd90521bd, 0x5a203382, 0x00213385,
    0x836182ac, 0x11392133, 0x30213386, 0x88658544, 0x20208233, 0x2b591804, 0x4300230a, 0x214172ff, 0x82092005, 0xffb824c2, 0x180fb4a4, 0x201b2d59,
    0x202f8207, 0x2342824b, 0x2301b415, 0x2f83c482, 0xcb422920, 0x5225080d, 0xae03d101, 0x03007902, 0x00b91d00, 0x40c0ff02, 0x480c060b, 0x00050202,
    0xbd01b900, 0x01e13f00, 0x2f33112f, 0x05537c2b, 0x5c035229, 0xa8a8d101, 0x82000100, 0xa8072035, 0xbb072035, 0xff022835, 0x0331fefc, 0x82d3ff4e,
    0x000734a1, 0x0418402a, 0x05090000, 0xefba0501, 0x0206ff06, 0x78ba0206, 0x01240642, 0xe15d2f00, 0x01220282, 0xb082332f, 0x30313325, 0x84352101,
    0x4e032501, 0x5203aefc, 0xfe250383, 0x8b8c8b31, 0x08bd8200, 0xc1031728, 0xb6055001, 0x25000c00, 0x0e5f1740, 0x070f0601, 0x076f075f, 0x07cf07bf,
    0x980c0705, 0x069c0c01, 0xe53f0003, 0x50822f01, 0x825d3321, 0x272108fb, 0x3337033e, 0x2507030e, 0x2e270e0e, 0x0f891934, 0x08161a1d, 0x3616c103,
    0x387b7c7a, 0x7c83843d, 0x82559335, 0x010f2d4a, 0x016f015f, 0x01cf01bf, 0x9c060105, 0x5583c282, 0x5583a782, 0x82170121, 0x82232051, 0x42012159,
    0x2f335682, 0x0e891933, 0x08161b1d, 0x3716b605, 0x387a7d79, 0x8284843c, 0x26578256, 0x01f8fe3f, 0x82ee0079, 0xb9352cad, 0xc0ff0e00, 0x180a1440,
    0x85980c48, 0x847f205a, 0x06012a5a, 0xc0ffb807, 0x481510b7, 0x20658207, 0x29bb84a8, 0x2f33332b, 0x312be15d, 0x67882530, 0x0e0f6a23, 0x21678227,
    0x67830f8a, 0x8717ee21, 0x837d20bd, 0x031926bd, 0x055201c1, 0x3a6582b6, 0x5f1c402b, 0x0f06010e, 0x6f055f05, 0xbf057f05, 0xdf05cf05, 0x05050705,
    0x880b9800, 0x82e120c2, 0x08c3835b, 0x031e132a, 0x032e2317, 0x08ee3727, 0x0f1d1a16, 0x2e341989, 0x050e0e27, 0x847c35b6, 0x7a383c84, 0x1637797d,
    0x17000200, 0xd102c103, 0x38085b84, 0x40620019, 0x011bbf48, 0x0f011b90, 0x6f1b5f1b, 0x0f13031b, 0x6f145f14, 0xbf147f14, 0xdf14cf14, 0x14140714,
    0x0c0e9819, 0x50010098, 0x70016001, 0xc001b001, 0x0701d001, 0x0da34101, 0x9c0c192d, 0x00030613, 0x32e5333f, 0x845d2f01, 0x852f20e8, 0x5d5d2492,
    0x41013031, 0x212007ae, 0x01210887, 0x0bb841a6, 0x41b8fd21, 0xd14118c6, 0x2cb79e0b, 0x14501400, 0x14701460, 0x14c014b0, 0x2ab785d0, 0x0e5f0e0f,
    0x0ebf0e6f, 0x82050ecf, 0x07a041c2, 0xcf01bf24, 0xc284df01, 0x06130725, 0x82000d9c, 0x833220b7, 0x20b685b7, 0x41b78a5d, 0x212007a8, 0x21151942,
    0x27424802, 0x0b324218, 0x00023008, 0x02f8fe3f, 0x00ee00fa, 0x0019000c, 0xd051407e, 0xf01be01b, 0x1ba4031b, 0x1bc41bb4, 0x011b9003, 0x301b2002,
    0x601b401b, 0x801b701b, 0x8713061b, 0x2bc783c9, 0x19141406, 0xe00e9098, 0x030ef00e, 0x0220ce83, 0xc683c88a, 0x42010621, 0x4024056b, 0x4818100a,
    0xa822cf85, 0xcf843f00, 0x21057042, 0xd1865d2f, 0x5d5d5f23, 0x0a7c425d, 0x8542d389, 0x42d38d0c, 0x9e420b93, 0x0069080b, 0x007b0001, 0x06680300,
    0x000b0014, 0x9052407c, 0xe00da00d, 0x040df00d, 0x10010d6f, 0x400d300d, 0x0607030d, 0x080804c0, 0xf40be403, 0x0bd6020b, 0x010b7701, 0x54010b6a,
    0x0b45010b, 0x010b2601, 0x0a09c00b, 0x36090901, 0xbe020102, 0x03100300, 0x030303a0, 0x05000104, 0x070a0bbf, 0x0008c206, 0x3f2f0003, 0x323232f6,
    0x2a0382e1, 0xe15d2f01, 0x3311325d, 0x82e61033, 0x250283c2, 0x332f3311, 0xcf8433e6, 0x13250136, 0x35051323, 0x03330305, 0xfe680325, 0x37d937b5,
    0x3701c9fe, 0x01310682, 0x1fdd034b, 0xfc0304fc, 0x011eb41f, 0x1e5ffea1, 0x20b58600, 0x08b5827d, 0xb000154e, 0x17007140, 0xb017a001, 0x0317f017,
    0x2001177f, 0x50174017, 0x0d080317, 0x0f0b0ec0, 0x0401050f, 0x12f40112, 0x0112e601, 0x7a011287, 0x12640112, 0x01125501, 0x12461236, 0x10c01202,
    0x10101114, 0x04000315, 0x0a0a05be, 0x05000609, 0x2508b982, 0x05200510, 0x05a00550, 0x080605b0, 0x0b131405, 0x1112bf0c, 0x0fc20d0e, 0x00010900,
    0x0306bf08, 0x05c20702, 0xd3872f00, 0x5e27dc8a, 0x3333715d, 0x83102f33, 0x20e58cea, 0x240d8271, 0xe633332f, 0x06dd5532, 0x87152521, 0x82f087eb,
    0x31022e10, 0xb4fe4c01, 0xfe38d937, 0x2f4c01b4, 0x2205832f, 0x8337d938, 0x012f3013, 0x1fb41ef0, 0x790187fe, 0x011eb41f, 0x83130122, 0xfe782206,
    0x08148388, 0x0000ed32, 0x01960001, 0x036d02e5, 0x001300f2, 0x2f244046, 0x6f155f15, 0xcf157f15, 0xff15ef15, 0x15100715, 0x6f0a5f01, 0xaf0a9f0a,
    0xef0adf0a, 0xd00a060a, 0xb82f3082, 0x0c40c0ff, 0x00480a07, 0x0f010f1f, 0x82010510, 0xc55d25cf, 0x2b2f015d, 0x5d200582, 0x12a69418, 0x24962b08,
    0x3132563f, 0x25254056, 0x32315640, 0x02243f56, 0x3f6447ec, 0x643f1c1c, 0x3f644647, 0x643f1e1e, 0x93000300, 0xdb05e3ff, 0x8582fa00, 0x00278a08,
    0x40a80039, 0x243b1476, 0x3bfb023b, 0x013be401, 0x3bcb3bbb, 0x013ba402, 0x64013b8b, 0x023b743b, 0x34013b4b, 0x3b0b013b, 0x66961e01, 0x02147614,
    0x28001414, 0x01322496, 0xe00132fb, 0x32d40132, 0x0132bb01, 0x8b0132a4, 0x32720132, 0x01326601, 0x3001324b, 0x20020132, 0x320f0132, 0x0a320601,
    0xf000e096, 0x00540200, 0x00020064, 0x20001000, 0x00070300, 0x9b05192d, 0x000f2337, 0xed33332f, 0x2f013232, 0x5d5d5d5e, 0x200583ed, 0x066c425f,
    0x71260682, 0x2f3911ed, 0x1088ed5d, 0x30317124, 0x4a183437, 0x23240974, 0x25022e22, 0x26210f9c, 0xb1951893, 0x91252010, 0x23132211, 0xc5e3182e,
    0x49363208, 0x2135266f, 0x35210f0f, 0x22352526, 0x35221010, 0x080f9b25, 0x07004252, 0xecff6600, 0xcb05f408, 0x1d000900, 0x3b002700, 0x49003f00,
    0x89005d00, 0xb4405c40, 0x1e4ab554, 0x23b532b4, 0x3ea028b4, 0x403c3001, 0x033cb03c, 0x28402830, 0x283c3e02, 0x033e3c28, 0x4ab44514, 0x4f5f3f5f,
    0x7f5f5f5f, 0x055faf5f, 0xb50ab405, 0x0913e118, 0x59b64727, 0x4fb643b7, 0x1be11819, 0xe13f231e, 0xe118e1f4, 0x1229091f, 0x2f2f3917, 0x5d5d5d2f,
    0x2f168210, 0x31e1f410, 0x16141330, 0x10113233, 0x05062223, 0x0e1a5918, 0x19990120, 0x01230122, 0xfa3a1d99, 0x9c9c5047, 0xc7014750, 0x4f734a24,
    0x264c7049, 0x4e714923, 0x274d714b, 0x1986ac01, 0xe118c620, 0x0226163f, 0x9b514797, 0x3a82519b, 0x4a2c208b, 0x04274c72, 0x01a5a502, 0xa348014a,
    0x2e59e118, 0xa502fc25, 0x844901a4, 0x76ab3d37, 0xab763f3f, 0x75aa6c6c, 0xaa753e3e, 0x8500ffff, 0x4a01a603, 0x0602b605, 0x00000a00, 0x02210f85,
    0x080f84b2, 0x00000540, 0x52000100, 0xfc017300, 0x0600c703, 0x04b13c00, 0xc0ffb802, 0x0c091f40, 0x3f080248, 0xaf089f08, 0xef08df08, 0x0608ff08,
    0x039feb06, 0x00060301, 0x05010303, 0x2f2f0001, 0x2f3d3912, 0x9e183333, 0x312309ef, 0x18011330, 0x180dde9e, 0x8c0bd49e, 0x403f2465, 0x4ceb0028,
    0x1025069b, 0x02032003, 0x24698c03, 0x01023f04, 0x25689302, 0x5d2f5d33, 0x9618e15d, 0x0126086c, 0x75cbfefc, 0x9618eded, 0xdf820e5b, 0xe3ff932c,
    0xb6056203, 0x04002700, 0xe082d101, 0x04000622, 0x0932e782, 0x01312fb5, 0x5d013110, 0x0100005d, 0x0000a0fe, 0x23826802, 0x1d000322, 0x0c3dde18,
    0x0012012d, 0x3f3f0003, 0x32382f01, 0x6433382f, 0x022a051d, 0x9dd5fc68, 0xb6052b03, 0x31824afa, 0x00013808, 0x021d036a, 0x00c70593, 0x40410014,
    0x00e00017, 0x16140114, 0x16c01660, 0x16f016e0, 0x01160f04, 0x0be00a0e, 0x40c0ffb8, 0x480f0a0e, 0xc0000a0b, 0x11e4040e, 0x82dc0cde, 0x33e12d56,
    0x0132cc1a, 0x32e12b2f, 0xd6105d5d, 0xb052cb84, 0x3329080a, 0x33363317, 0x02111532, 0x2d3f3f14, 0x7f152a41, 0x40091069, 0x1d03e582, 0x4451a601,
    0x41573415, 0x9d02a6fe, 0xfefa6558, 0x22c18250, 0x82006000, 0x088f82d6, 0x7600112a, 0x10024840, 0x00051002, 0x200b100b, 0x0b0b030b, 0x01133013,
    0x5a04000e, 0xdf050905, 0x07070107, 0x05100500, 0x070305c0, 0x603e0282, 0x11080008, 0x0e0f0e5f, 0x0e6f0e3f, 0x400e0803, 0x08481510, 0x040e080e,
    0x030a5f0d, 0xa3831204, 0x3939122a, 0x5e2b2f2f, 0x11e1105d, 0x070fa618, 0x5d2f3322, 0x32200b84, 0x2f200682, 0x2c05c377, 0x21013031, 0x23112115,
    0x33352311, 0x82098311, 0xc3013e03, 0xdcfe2401, 0x02b0b0b3, 0x02c3fdf0, 0x01eafd16, 0xfafe898f, 0x04890601, 0xfcfda427, 0x20b583a4, 0x32b58244,
    0x00c90523, 0x40870030, 0x150d1110, 0x23272b6f, 0x8223130f, 0x1e4b0801, 0xffb81b03, 0x093e40c0, 0x1b1b480e, 0x01321032, 0x401e2529, 0x1e480e0b,
    0x26752514, 0x29102611, 0x2a0d2a75, 0xd001266f, 0x2a0f012a, 0x2a3f2a1f, 0x2aaf2a4f, 0x26062abf, 0x002a262a, 0x1d741a1e, 0x00730718, 0xe13f0007,
    0x5132e13f, 0xb48407e3, 0x01240484, 0x33332b2f, 0x2b21bd83, 0x22df8433, 0x5c113311, 0x32230708, 0x56071716, 0x152105c0, 0x84c48215, 0x0da91803,
    0x8235200e, 0x343527e4, 0x9a02023e, 0xa918ae6a, 0x01240c11, 0x1788fe78, 0x0c15a918, 0x0f17a918, 0x9e89c031, 0x593e1389, 0xa6102b40, 0x44290b9a,
    0x82154361, 0xdd230810, 0x325f8957, 0x96000300, 0xb605ecff, 0x1b00b605, 0x35002a00, 0x18407900, 0x121c6f31, 0x186e0f10, 0x821c1815, 0x242c0801,
    0x050105ff, 0x48151240, 0xc0ffb805, 0x0e092c40, 0x37050548, 0x3701370f, 0x48100b40, 0x246e232b, 0x180f367c, 0x15121575, 0x1522732b, 0x24300182,
    0x06257335, 0x75001824, 0x3f001909, 0xe13f3fe1, 0xc741ea84, 0xf6102a07, 0x5d2b32e1, 0x2b2f3311, 0x05c2412b, 0x1033112f, 0x103232e1, 0x253031e1,
    0x37023e32, 0x07cd6c15, 0x37352334, 0x33153337, 0x14112315, 0x0e140116, 0x11232302, 0x43771123, 0x064a6206, 0x3b054a08, 0x1e23240f, 0x3f501707,
    0x24405835, 0x6b419c9c, 0xfe34d1d1, 0xcc7c348c, 0xfbb22f98, 0x3a7bbf86, 0x5d1abdfd, 0xa42e5b8b, 0x048139ae, 0x8a030806, 0x4622140c, 0xbf01486a,
    0xd3bd4d52, 0x4c56fe89, 0x5b89034e, 0xfd4d81a8, 0xbdca18c7, 0x0001320d, 0x04ecff3f, 0x00cb054a, 0xb4860039, 0x36280712, 0x08fb8319, 0x0d094b51,
    0x3b191948, 0x2c013b10, 0x05132323, 0x222e6f0d, 0x28012863, 0x23133a28, 0x24102460, 0x2d602c08, 0x245f2d05, 0x248f247f, 0x24ff24ef, 0x1f2d0f05,
    0x5f2d2f2d, 0xcf2d9f2d, 0x2d24062d, 0x37162d24, 0x07337400, 0x1d195f16, 0x333f0019, 0x42e13fe1, 0x5d200506, 0x3005d742, 0xe1103311, 0x33011132,
    0x33335d2f, 0x333232e1, 0x092a4211, 0x2709aa7a, 0x14060714, 0x17141415, 0x2d0b5555, 0x022e2223, 0x33352327, 0x34353426, 0x08823536, 0x33033e22,
    0x08054f42, 0x450803d3, 0x12435e76, 0x41feb001, 0x01020101, 0x2292fe81, 0x874b95b9, 0x5b853b3b, 0x5887b673, 0x0294a415, 0x12a09402, 0x72b88758,
    0x504fa061, 0x27057733, 0x5b8f6334, 0x0c0e0f89, 0x2913091a, 0xb8af8916, 0x1ca21a20, 0xc187491f, 0x1e178979, 0x082e161d, 0x90ca7d89, 0x92312b4e,
    0x00002b1f, 0xff8d0004, 0x05db05f8, 0x000300c1, 0x002b0017, 0x40860048, 0x3902010a, 0x0eb41846, 0xb8020003, 0x4a40f0ff, 0x46904670, 0x46d046a0,
    0x010edf04, 0x46021000, 0x0e00000e, 0x31040246, 0x040fb422, 0xff04ef01, 0x4a040204, 0x3100b440, 0x10310001, 0xe0312031, 0x0531f031, 0xfc423108,
    0xfc3dfd2c, 0xfc270736, 0xfc1dfd13, 0x06031909, 0x3f001801, 0xf4e13f3f, 0x056247e1, 0x715d5e25, 0x82de10e1, 0x17112304, 0x00822f39, 0x5d5d382a,
    0x10331138, 0x113311e1, 0x20063045, 0x0e604701, 0x210f746a, 0xaa562201, 0x2651080a, 0x06222326, 0x32331415, 0x06153736, 0xfc0a0506, 0x2b039dd5,
    0x502d6e01, 0x6e3f4470, 0x502c2f51, 0x6e3e4471, 0x33fe2f52, 0x2b3c2611, 0x11253c2a, 0x2a3c2511, 0x11263c2b, 0x7945cbfd, 0x5c35345a, 0x6433487d,
    0x551f2120, 0xc25f6722, 0x23235a33, 0x05a84563, 0x5398fb29, 0x2d2d577f, 0x87537f57, 0x337e0807, 0x23233e56, 0x3433563e, 0x21213d55, 0x9201553d,
    0x5a805226, 0x2652845f, 0x0d6b0f16, 0xe5767414, 0x126b1011, 0x02000013, 0xecff7700, 0xcb057b03, 0x3a002d00, 0x32405500, 0x4023702e, 0x23481410,
    0x06051123, 0x6e28353c, 0x11101419, 0x11301120, 0x11901180, 0x15181105, 0x11147636, 0x30002828, 0x00071e76, 0x06060b75, 0x3f00190b, 0xe1102f33,
    0x3912e13f, 0xe133332f, 0x2f013232, 0x0782c55d, 0xc1d61022, 0x2b201182, 0x30077143, 0x23030e33, 0x35022e22, 0x07060635, 0x37363635, 0x0ac54911,
    0x11070109, 0x13021e14, 0x0e222334, 0x3e111502, 0x206f0203, 0x031e2e39, 0x46260464, 0x6a3a4669, 0x612e3051, 0x2d5f3431, 0x4b68401c, 0x213d5736,
    0x477c5c35, 0x63372411, 0x17292066, 0x334e3609, 0x32167718, 0x83533b52, 0x5425305a, 0x11e76388, 0x0e790c1c, 0xee010f1e, 0x31536c3b, 0x456f4f2a,
    0x6886a663, 0x30d3fe26, 0x04213b51, 0x321bbc21, 0x6afe2a45, 0x79624e21, 0xc7000400, 0x89070000, 0x1700b605, 0x37002b00, 0xba003b00, 0x010e7240,
    0x39005a15, 0x22e12c39, 0xb0010010, 0x009f0100, 0x40003001, 0x22000200, 0x320a2200, 0x3a0f18e1, 0x3a2f3a1f, 0xef3a3a03, 0x67180118, 0xbf3d6f3d,
    0x033dcf3d, 0x0c013d40, 0x5a090308, 0x2f3c640a, 0xe5351de5, 0xdf1dcf27, 0x031def1d, 0x0b06401d, 0x1f270f48, 0x6f275f27, 0xef277f27, 0x1d060627,
    0x16271d27, 0x18061003, 0x030b0348, 0x0e38e539, 0xb6f0ffb8, 0x0e2b0d82, 0x00120a01, 0x2b33333f, 0x823fe033, 0x39392804, 0x5d5e2f2f, 0x18105d2b,
    0x2908c693, 0x105d5d32, 0x2f325de6, 0xd7571071, 0x4c0a8208, 0x312305ce, 0x18232130, 0x240e8977, 0x1135032e, 0x119d4233, 0x09087418, 0x35032308,
    0xa8041521, 0x0887fdcd, 0x05040406, 0x7602cfa6, 0x01040306, 0xa4010203, 0x4d29e102, 0x6b3f446d, 0x07832c4d, 0x4e6b3e3c, 0x4842fe2c, 0x47475151,
    0x63485151, 0xba04f001, 0x8e414c4d, 0x05e7fc39, 0xd018fbb6, 0xfc2409d9, 0x598253b9, 0x0c969f18, 0x73717e08, 0x6d727173, 0x931ffd6d, 0x00020093,
    0x05e50225, 0x00b60550, 0x00200007, 0x005d40a3, 0x0a1301c4, 0xc011c410, 0xe006d006, 0x066f0306, 0x40063001, 0x03065006, 0x0401061f, 0x11200106,
    0x010211d0, 0x06111106, 0x1e030301, 0xc4181519, 0x17af179f, 0x0f221702, 0x3f222f22, 0x40220322, 0x22481815, 0x48120f40, 0x03ef03cf, 0x091f0302,
    0x180c2009, 0x03070948, 0x141804c8, 0x40e0ffb8, 0x2e0e820c, 0x01081114, 0x04121501, 0x333f0003, 0x822f3333, 0x332b3503, 0x3332e110, 0x0133112b,
    0x2b2b5d2f, 0x5dd6105d, 0x323232e1, 0x4c05dd43, 0x27460574, 0x23013407, 0x21352311, 0x03012315, 0x15031e23, 0x33112311, 0x82331313, 0x3e343b06,
    0x03233702, 0xc47f6801, 0x02c70a02, 0x0107ba40, 0x7b010102, 0xb2bfb4ba, 0x0082017f, 0xc3066408, 0x6502e502, 0x9bfd6c6c, 0x22102502, 0xfe06181e,
    0xfdd10249, 0xfd2702d9, 0x09ac012f, 0x0c23231e, 0xffffdbfd, 0x00004e00, 0xcd05a605, 0x76010602, 0x02000000, 0xddff6600, 0x48048b04, 0x2f002200,
    0x21403b00, 0x111e4a23, 0x4a132f31, 0x05010510, 0x12181d1d, 0x3b2f2b4e, 0x2f2f022f, 0x0c4e2918, 0x5e4e180f, 0x5d2409b2, 0x2f3911e1, 0xe123cb82,
    0x18de1032, 0x2b0ae7c4, 0x1e323304, 0x11211502, 0x3233031e, 0x6408af82, 0x13030e17, 0x23032e11, 0x07020e22, 0x82790211, 0x2c4586c6, 0x8076664c,
    0x8ec2713f, 0x16c5fc51, 0x2e584d40, 0x4d5e744a, 0x53244822, 0x13cc8f6e, 0x355d4d3b, 0x3c495733, 0x9d5e2318, 0xa0636ecc, 0x1d3c5c7e, 0x83d1934f,
    0x2c189cfe, 0x3c201522, 0x39293757, 0x022c4d65, 0x1415018b, 0x1316232a, 0xfe172a21, 0x08d582e9, 0xecff5342, 0xb605d305, 0x7b002600, 0x27000014,
    0x5e021702, 0x07010000, 0x62034002, 0x3000b3fd, 0x03041f40, 0x01192702, 0xe40111f4, 0x11d00111, 0x0111b001, 0x300111a0, 0x2f110111, 0x590f0159,
    0x115d5d01, 0x25058441, 0x353f0035, 0x51823535, 0x51843320, 0x5182c920, 0x51867520, 0x518a8b20, 0x28403c22, 0x23085182, 0xf0011949, 0x33d00133,
    0x0133c401, 0xa00133b4, 0x33940133, 0x01336001, 0x24013330, 0x2f330133, 0x7b0f017b, 0x60825a89, 0x4f205d88, 0xaf825d84, 0x983d0221, 0x823d205d,
    0x01273f5d, 0xc40127d0, 0x27b40127, 0x0127a001, 0x60012794, 0x27300127, 0x01272401, 0x016f2f27, 0x5d956f0f, 0x5d887120, 0x41423f21, 0x3920050d,
    0x3422bb8a, 0xbb822240, 0x01191f3d, 0xeb0109f4, 0x09cb0109, 0x0109b401, 0x7f01099b, 0x092b0109, 0x512f0901, 0x8a510f01, 0x08b38557, 0x00020034,
    0x04ecff62, 0x00c5053b, 0x0043002b, 0x3321403b, 0x57004719, 0x01454045, 0x0601450f, 0x0c21483f, 0x4f384456, 0x212c1313, 0x0427501c, 0x1607502c,
    0x01483f00, 0xe12f2905, 0x32f61001, 0x5d5d5ee1, 0x3a059468, 0x040e1401, 0x022e2223, 0x043e3435, 0x17163233, 0x34353436, 0x0e222326, 0x60350702,
    0x012605da, 0x37043e32, 0x1282032e, 0x15047d08, 0x04021e14, 0x6541203b, 0x6a6db18a, 0x1722538c, 0x99735132, 0x2d935b62, 0x1f898b02, 0x1b414344,
    0x4f4b4318, 0x63a67d25, 0x359efd2a, 0x3543515e, 0x290a0a25, 0x3e2a493b, 0x253a4f66, 0x462d1512, 0xe16aa603, 0x528dbcd4, 0x4c8f6e42, 0x838d8d3c,
    0x454f3d65, 0xbe0b2a13, 0x1f160cc9, 0x170cae13, 0x96590a11, 0x2c73fcc4, 0x857a684d, 0x33452843, 0x6851301e, 0x322f6e6f, 0x00244056, 0x2a08f382,
    0x04000029, 0x00b60562, 0x000e0005, 0x02114058, 0x05090901, 0x04605b0e, 0x04b00470, 0x040404f0, 0x40c0ffb8, 0x480a0627, 0x18100404, 0x37115561,
    0x0d055b0d, 0x0912055f, 0x48110a20, 0x00030109, 0x3f2b333f, 0xe12f01e1, 0x21051f4a, 0xdd4de15d, 0x313b0805, 0x33013730, 0x01211501, 0x06272626,
    0x21030706, 0xbbbe0129, 0xc7fbc001, 0x2d207702, 0x1d2a110f, 0x71a602fa, 0xb9fa4505, 0x619a036f, 0xa84b4ba8, 0x0004fd5b, 0xfec70001, 0x82270514,
    0x00072e99, 0x00114037, 0x0965075a, 0x09300900, 0x05dd6840, 0x97830920, 0x18140f2f, 0x045a0348, 0x5f020864, 0x00040305, 0x08e6681b, 0x105d2b2b,
    0x3031e1f6, 0x11211101, 0x30038223, 0x14fd6d04, 0xfe6004ba, 0xf9fc0614, 0xf8a20704, 0x245d825e, 0x0414fe4a, 0x2f5d82e3, 0x405c000b, 0x705b080b,
    0x06020106, 0x0a000602, 0xb7275782, 0x0a480e09, 0x82070d0a, 0x40e02b63, 0x48180f09, 0x00000309, 0x71840d0c, 0x48181325, 0x18020208, 0x8207c05e,
    0x18e12071, 0x3207c05e, 0x1833112b, 0x2b33332f, 0x2f331132, 0x3939122b, 0x825d2f2f, 0x18132082, 0x3d0ac15e, 0xfd70024a, 0xfc4804a0, 0xfd3a02bc,
    0xfe9b03b0, 0x92037314, 0xa4722b03, 0x9dfc09fd, 0x938200a4, 0x02662408, 0x03020487, 0x0003001d, 0x021f4032, 0x01009605, 0x7901008b, 0x00560100,
    0x01004b01, 0x14010038, 0x82090100, 0xad002427, 0x1800b301, 0x2e0ba0ad, 0x3031ce10, 0x15213513, 0x029c0366, 0x83969687, 0xff25304b, 0x06c504f2,
    0x000800a0, 0x0113402c, 0x83050600, 0x080739de, 0x03030810, 0x070404ae, 0x2f2f0000, 0x01e12f39, 0x33382f2f, 0x2f193939, 0x2208ba82, 0x31333311,
    0x01230530, 0x13213523, 0x73023301, 0xb4ebfe85, 0x02e52901, 0x030e9200, 0x69fd8f0a, 0x8200ac05, 0x77790899, 0x31059101, 0x23000e04, 0x43003300,
    0x4f407600, 0x48011749, 0x45f0010d, 0x5f452f01, 0x273a0245, 0x276a274a, 0x01372a03, 0x27081a37, 0x2f773f04, 0x2f022f97, 0x301220aa, 0x78120212,
    0xab3f013f, 0xae2a3400, 0xae243a17, 0x1a273708, 0x00051704, 0x020d100d, 0x1f0d0d07, 0x2001179f, 0x00170117, 0x335d5d2f, 0x5d5e2f33, 0x39171233,
    0xe11032e1, 0xe12f0132, 0xe15d2f5d, 0x200f825d, 0x2b00825d, 0x5d5d3031, 0x020e1401, 0x27262223, 0x2606f848, 0x33023e34, 0x43171632, 0x8b08055b,
    0x37363205, 0x22232626, 0x1415020e, 0x2201021e, 0x16160706, 0x023e3233, 0x022e3435, 0x4d2b3105, 0x9b5d426d, 0x4e461d41, 0x6e412b53, 0x4e2b2d4f,
    0x9e55436f, 0x4f441d3e, 0x6d423057, 0x7bfc2b4d, 0x31346c3f, 0x4028456b, 0x2c15182c, 0x3f7c0241, 0x6c33376b, 0x2d402744, 0x402e1918, 0x723fcd02,
    0x73693457, 0x1e384f30, 0x4875522c, 0x31567341, 0x4e30706b, 0x522d1f38, 0x6157f975, 0x331d5a5e, 0x42242644, 0x6a011e32, 0x5c5d6157, 0x44080d82,
    0x31432627, 0x0001001c, 0x0314fe10, 0x00140606, 0x40370023, 0xd0251023, 0x04140225, 0x01040601, 0x1bac0d04, 0x15090115, 0x1e101501, 0x1e021e20,
    0x1c12ae19, 0x0000ae07, 0x3fe13f00, 0x5d2f01e1, 0xe15d5d33, 0x20f68432, 0x20e28201, 0x20d98615, 0x93721811, 0x343b080f, 0x8302023e, 0x12164b22,
    0x4233243d, 0x59321027, 0x4b244a7c, 0x233e1417, 0x122a4533, 0x0679572f, 0x93090914, 0x41271109, 0xd7fa2d54, 0x2956865e, 0x0893080b, 0x54402510,
    0x82270530, 0x00282a0e, 0x01660002, 0x0402047b, 0x08a18225, 0x4b004743, 0x1d412e40, 0x01491049, 0x200a102e, 0x400a020a, 0xaf31ad29, 0x0aad1743,
    0x051caf1f, 0xef0ddfad, 0x030dff0d, 0x120f400d, 0x3b0d0d48, 0xb3432ead, 0xe1333f00, 0x5d2b2f33, 0x32f533e1, 0xe1f510e1, 0x26ba8433, 0x3132ce10,
    0x472e0130, 0x3522051d, 0xba183336, 0x0320105a, 0x02271b9a, 0x2d372512, 0x181c1629, 0x201a76ba, 0x2e219a2f, 0x321d9761, 0xbc014337, 0x050d1610,
    0x182c2113, 0x231398ba, 0x1510ae01, 0x20281c82, 0x6da21a2c, 0x14190e05, 0x2d200d85, 0x74082a85, 0x66000100, 0x0204a400, 0x13000405, 0x1140a600,
    0x110e0d0a, 0x12120912, 0x07040300, 0x09081308, 0xf0ffb813, 0x10094f40, 0x09130913, 0x150b1006, 0x01011540, 0xbb0106c6, 0x06a90106, 0x01068601,
    0x6801067b, 0x06420106, 0x01063901, 0x08080906, 0x07ad040d, 0x11121213, 0x1f0ead00, 0x02032f03, 0x0001037f, 0x02031003, 0x0a030306, 0x0f0107f0,
    0x02076f07, 0x08fd4207, 0x33715d2f, 0x113232e1, 0x32e11033, 0x01331133, 0x05bb472f, 0x335d5d22, 0x2905a863, 0x382f2f39, 0x7d331138, 0x0082c487,
    0x10330122, 0x31270784, 0x35230130, 0x82211321, 0x07172603, 0x03211533, 0x08038221, 0x5e01272a, 0x793e01f8, 0xfc0149fe, 0xfa698a85, 0x017bc1fe,
    0x8100feba, 0x96ba0189, 0x01950401, 0x95e03b1b, 0xfe96fcfe, 0x020039ea, 0x2108ef82, 0x04020400, 0x000600dd, 0x4052000a, 0x0c000932, 0x08010c40,
    0x01010140, 0x05050102, 0x006f0603, 0xe718007f, 0xb48433bf, 0x25303135, 0x15013501, 0x21350209, 0xfc020415, 0xfd9c0364, 0x83df0221, 0x01ee2107,
    0x08c8e718, 0x9671fe24, 0x89920096, 0x89850520, 0x0601062a, 0x01010405, 0x066f0003, 0x354de718, 0x13218986, 0x218a8301, 0x8a821501, 0xe2026626,
    0x9c031efd, 0x012c8783, 0x0142018f, 0x1ffea26a, 0xee58fe66, 0x39088785, 0x0400006d, 0x00c3053f, 0x00090005, 0x0236405d, 0x04050901, 0x03070907,
    0x0b00ac06, 0x40010bff, 0x800b500b, 0xc00bb00b, 0x0b0f050b, 0x08020b2f, 0x010310aa, 0x00080303, 0x01820806, 0xad070222, 0xad302c82, 0xe12f0002,
    0x3912e13f, 0x2f2f3d39, 0x33113311, 0x2305ec54, 0xde105d5d, 0x11211483, 0x08128233, 0x30313331, 0x01230101, 0x03093301, 0x3cfe3f04, 0x013efe4c,
    0x0c014cc2, 0xcffecffe, 0xe1023101, 0xdf021ffd, 0x1efde402, 0x00fe0002, 0xff00fefd, 0x821d00ff, 0x172d0897, 0x26001f06, 0x00004900, 0x4c000701,
    0x0000a202, 0x18402400, 0x1daf0102, 0x011d5001, 0x0f011d1f, 0xaf1d011d, 0x2f40012f, 0x012f0f01, 0x06ff495d, 0x86353521, 0x8a06203d, 0x844f203d,
    0x4022223d, 0x263c8e17, 0x21400121, 0x89210f01, 0x01003f3c, 0xd904cf00, 0x1706cd03, 0x3f001500, 0x17002940, 0xaf021720, 0x0217cf17, 0x17701730,
    0x1f820f02, 0x0a000029, 0x06020a30, 0x827f0a0a, 0x0640360c, 0x00004809, 0x00058e10, 0x2f33e12f, 0x01335d2b, 0x335d5e2f, 0x060a5a2f, 0x2105bd45,
    0x494b3327, 0x08568206, 0x8d5d3143, 0x588c6764, 0x05aa0529, 0x354c321b, 0x2236492c, 0x4e170606, 0x27295176, 0x39507750, 0x13102949, 0x0035482b,
    0xfebcff01, 0x04640114, 0x0013004a, 0x10134023, 0x02152015, 0x030c470f, 0x14540c03, 0xafcc180d, 0xc15c1808, 0x30312207, 0x214d1813, 0x33112a0a,
    0x020e1411, 0x173f3042, 0x9dcc181a, 0x7d841809, 0x042c080a, 0x4d18fbf4, 0x002f577b, 0x87010100, 0x7902cd04, 0x0d001406, 0x0c401900, 0x063f8505,
    0x000c0601, 0x0005920c, 0x01e53f00, 0x5ddd332f, 0x0c906e18, 0x0987013a, 0x040e1112, 0x291f06b4, 0x0460162e, 0x514d1ee7, 0x19142150, 0x2056564e,
    0x6f264b82, 0x75023bfe, 0x4b8283ff, 0x09401628, 0x0500000c, 0x49830685, 0x48822f20, 0x2f32e125, 0x18303133, 0x320a8175, 0x181a0b6f, 0x06b20413,
    0x1d362c1f, 0x1956fe62, 0x8253544c, 0x574d2348, 0x95832156, 0xd9047d26, 0x21068302, 0x17224982, 0x49850a40, 0x82920521, 0x86938307, 0x030e384a,
    0x3e352307, 0x02333703, 0x181a0c83, 0x05b20412, 0x1c372d1f, 0x84060662, 0x1815214a, 0x2b089382, 0x00020021, 0x02390225, 0x00c7057f, 0x001d000b,
    0x0619402a, 0x4f1f0ce1, 0x021f7f1f, 0x0a06401f, 0x16e10048, 0xde1be509, 0xdf11e503, 0x24068b46, 0x105d2be1, 0x21f282de, 0xe94e1413, 0x0d045909,
    0x47b81624, 0x00824e51, 0x2b0f9258, 0x02049a95, 0xa79fa1a5, 0xa59f9fa5, 0x26065058, 0x74a96c6c, 0x8200ec3c, 0x020c3c85, 0x058f024a, 0x000a00bc,
    0x40460015, 0xe102092a, 0x0303070b, 0x8f175f17, 0x83170217, 0x15250889, 0x040105e1, 0x0b0f09e5, 0x0b2f0b1f, 0x0b0b0803, 0x07e50f02, 0x00dd02dc,
    0x12e13f3f, 0x5d5e2f39, 0x0132e133, 0x519d822f, 0x5f080626, 0x23013031, 0x21352315, 0x11330135, 0x34352133, 0x030e3736, 0x8f020707, 0x89fe8f7d,
    0x7d8d7901, 0x0303f4fe, 0x18161405, 0x0a039b09, 0x026fc0c0, 0xc3cdfd43, 0x0b31632a, 0x0f282a25, 0x010000f0, 0x37023b00, 0xb6056602, 0x4a002400,
    0x22211740, 0x1d1d1e22, 0xe114200b, 0x264f2605, 0x2602267f, 0x0b359383, 0x40c0ffb8, 0x48181211, 0x00e5170b, 0xe5211100, 0xe511dc1e, 0x05294108,
    0xe1298682, 0x2b2b2f01, 0xe1de105d, 0x21938433, 0x93823311, 0x021e3226, 0x23061415, 0x0ce84618, 0x0e224c08, 0x13270702, 0x07211521, 0x42013636,
    0x2d4f6b3d, 0x793fa1a6, 0x3d3c1a2c, 0x5f55183b, 0x250d595f, 0x430e2527, 0xfeba0121, 0x391412be, 0x44236d04, 0x9d8c4165, 0x128d1a1c, 0x4c0a131b,
    0x04554d58, 0x2b020706, 0xd77ba801, 0x41000603, 0xd53408d1, 0x2d001d00, 0x20403800, 0xe1210a10, 0x2f4f2f00, 0x2f022f7f, 0x152eb583, 0x240ae129,
    0x191915e4, 0x1ede0f10, 0xae8405e5, 0x2f393323, 0x21ae8233, 0xaf8432e1, 0x82391221, 0x0a7753a9, 0x0e173728, 0x36330703, 0xbd823336, 0x36320522,
    0x0806c74c, 0x1e141575, 0x2a7f0202, 0x40446f4e, 0x452f526e, 0x2d6eb27e, 0x40607f4f, 0x631b0b0f, 0x405a364a, 0x44dbfe24, 0x27474d54, 0x19192d3f,
    0x66033d2d, 0x2d506f41, 0x5380582d, 0x6d8fb36e, 0x401b6d27, 0x2b3b604f, 0x69482531, 0x52565cf7, 0x3729195a, 0x35492c1e, 0x0001001d, 0x024a022f,
    0x00b60564, 0xb9380006, 0xf0ff0000, 0x00001f40, 0x05e10102, 0x7f084f08, 0x83080208, 0x02d030c1, 0x02f002e0, 0xe5020203, 0xdd00dc03, 0x823f3f00,
    0x845d20ba, 0x391135b9, 0x3031382f, 0x35210113, 0x8d011521, 0x62fe4001, 0xbffe3502, 0x25085182, 0xfc647bf1, 0x000300f8, 0x02390231, 0x00c70571,
    0x00340025, 0x40770044, 0x21e13822, 0x0a05e142, 0x041c323d, 0x01822105, 0xe12c172a, 0x464f460f, 0x4602467f, 0x38086a83, 0xb817e126, 0x2740c0ff,
    0x17481815, 0x323d1c0a, 0x325b324b, 0x329b326b, 0x320532ab, 0x3db63514, 0x3dd63dc6, 0x29003d03, 0x35df14e5, 0x00de00e5, 0xe13fe13f, 0x115d3911,
    0x24038412, 0x2b2f0139, 0x2b9884e1, 0x2f393912, 0x3917122f, 0xe110e110, 0x22070642, 0x7407020e, 0x74180538, 0x2e2607e1, 0x3e343503, 0x59430302,
    0x022e2e06, 0x06062727, 0x15062213, 0x17021e14, 0x081b823e, 0x520126aa, 0x2a465e34, 0x1e342716, 0x1c303e22, 0x3f694d2a, 0x2a19968b, 0x2e1b1f38,
    0x482b1323, 0x484a625f, 0x27164b4a, 0x410f2137, 0x3f389442, 0x1a2d2012, 0x13202c18, 0x1bc70541, 0x25385437, 0x1128323e, 0x45372d13, 0x425d392a,
    0x2a738324, 0x112b3845, 0x3e352b14, 0x37533825, 0x3b68fd1c, 0x1e3b4646, 0x0f202730, 0x014d2206, 0x1b3637e8, 0x0d1d242a, 0x2c231c0c, 0x0037361c,
    0x02210002, 0x057b0239, 0x002500c9, 0x403b0035, 0xe0113122, 0x37001c09, 0x377f374f, 0x06403702, 0xe129480a, 0x11e42c1c, 0x26051717, 0x0cde21e5,
    0x21065742, 0x584212e1, 0x5d2b2506, 0x3911de10, 0x08144318, 0x21098b45, 0xbf4b2337, 0x021e220b, 0x4bef8325, 0x1d0908ab, 0x5a217b02, 0x401981a2,
    0x19361515, 0x1d406c53, 0x240d0903, 0x3c263d30, 0x29244460, 0x41436c4b, 0xfe305472, 0x4a5644cb, 0x2d3f264c, 0x3e2a1518, 0xbb604204, 0x07085b93,
    0x350a0d7d, 0x123d7257, 0x25111b24, 0x42416647, 0x2f2d516f, 0x5eac9361, 0x19584c58, 0x241a3329, 0x00243b48, 0x54001600, 0xc10781fe, 0x0500ee05,
    0x11000b00, 0x1b001700, 0x23001f00, 0x2b002700, 0x33002f00, 0x3b003700, 0x43003f00, 0x53004700, 0x6f005f00, 0x81007800, 0xe4009000, 0x2c345940,
    0x18381c20, 0x707a5157, 0x6467746f, 0x6b7e8264, 0x51c05170, 0x510351d0, 0x6f6b6b6f, 0x895d0351, 0x8c5f8c4f, 0x448c8c02, 0x17092428, 0x604b505d,
    0x4b4b024b, 0x00313d41, 0x46422a0c, 0x8632263e, 0x796f8f8f, 0x7a707067, 0x546f7a60, 0x6f704848, 0x61026f80, 0xb86f016f, 0x2540c0ff, 0x6f480c07,
    0x4e5a606f, 0x1f788a4e, 0x3f602f60, 0x04606f60, 0x2c016060, 0x0c12181c, 0x07213539, 0x0701010f, 0x5e2f0001, 0x7353335d, 0x12332306, 0x0c832f39,
    0x11332f28, 0x5d2b2f33, 0x0883335d, 0x73441120, 0x822f2006, 0x2103830d, 0x2d822f01, 0x82333321, 0x5e088828, 0x112006d7, 0x06824685, 0x2d843e82,
    0x1330313c, 0x23152111, 0x21352515, 0x01352311, 0x33153311, 0x33352115, 0x21113335, 0x09822135, 0x01152122, 0x01240782, 0x11331123, 0x0b870382,
    0x33200783, 0x35201786, 0x03831783, 0x3526222b, 0x32373634, 0x06141516, 0x06394427, 0x14150625, 0x84330116, 0x15072212, 0x23198316, 0x33132323,
    0x23221c85, 0x09861515, 0x16350523, 0x820a8316, 0x14230863, 0x54222306, 0x05c02f01, 0x6d3001ce, 0xc06f00f9, 0x6dc30e05, 0x110149fd, 0x0e01e1fb,
    0x0e01f2fe, 0x826db704, 0xc2fb3100, 0x30fc1001, 0xc0026f6f, 0x01771001, 0x6fa8fa11, 0x06290082, 0xfa6d6dfe, 0x87877f99, 0x0803837f, 0x3f3f483e,
    0x42424548, 0x6dac9f01, 0x382d2d70, 0xcf5e6d33, 0x242e427b, 0x4a3b3029, 0x34262531, 0x20100e01, 0x7d312514, 0x043d5f68, 0x6f3001be, 0xfe6fc1c1,
    0x02f9c1d0, 0x6dc22f01, 0xd1fec26d, 0x6d326482, 0x6f6ffe06, 0x0e01a8fa, 0x0f010202, 0x6d6d3bfa, 0x7f82a601, 0x69824a20, 0xfc6f4e08, 0x7910012f,
    0x68fd0f01, 0x8afe1001, 0x9b918e9f, 0x8e919c01, 0x5e67689f, 0x5e66665e, 0xea01675e, 0x44315343, 0x440b0408, 0x0159513a, 0x22202262, 0x2b9ae31d,
    0xfc2a2025, 0x24050366, 0xfe920132, 0x00645e72, 0xfe540003, 0x06aa07c1, 0x08098214, 0x2f00233e, 0x28405000, 0x24232304, 0x2a302a20, 0x2a032a40,
    0x01244f2a, 0x1c022424, 0x15020b0b, 0x23230215, 0x2d012d30, 0x0327272d, 0x03101019, 0x332f1900, 0x11332f18, 0x2f332f33, 0x012f335d, 0x0d830e84,
    0x0f820382, 0x06825d20, 0x30313337, 0x35050309, 0x36373634, 0x2e343536, 0x0e222302, 0x36170702, 0x068d4136, 0x15060623, 0x077d4415, 0x23267208,
    0xfe030622, 0x54fcac03, 0xeb0356fc, 0x4d634c21, 0x51835b31, 0x52575a2b, 0x7e445222, 0x273e3f38, 0x1b4a4552, 0x47444647, 0x47464447, 0x56fc1406,
    0xa90357fc, 0x3e2c2ffb, 0x59834c3a, 0x274a6b45, 0x14231b10, 0x3a2e22b2, 0x4144312f, 0x3b507935, 0x493eedfe, 0x49403e49, 0xffff0049, 0x14febcff,
    0x21065502, 0x37022602, 0x07000000, 0xbbfe4c01, 0x21178200, 0x3f691700, 0x06022305, 0x17820702, 0x00025608, 0x04ecff0a, 0x002b06b2, 0x004f000c,
    0x4d474075, 0x3e10430d, 0x47083b00, 0x3b1a4343, 0x10004f47, 0x51101001, 0x3f0151a0, 0x47330151, 0x1a101a00, 0x1a031a20, 0x3e295022, 0x004e4f4f,
    0x1029004e, 0x40293029, 0x05295029, 0x294e2906, 0x5005384e, 0x50380148, 0x05b35315, 0x02581220, 0x33112905, 0x1032e110, 0x5d2f01e1, 0x2406ad6c,
    0x3911e133, 0x2103822f, 0x21821139, 0x01303125, 0x4523032e, 0x05270583, 0x14151616, 0x53060602, 0x2d7f06d5, 0x36362708, 0x021e3233, 0x6c501415,
    0x32332605, 0x26341112, 0x05cb4527, 0x2a081883, 0x03153317, 0x4d390d6a, 0x564c305b, 0x01ab6a2e, 0x4002023c, 0x6f83c481, 0x0a225692, 0x1f1f0a0b,
    0x25103618, 0x32366425, 0x82132c45, 0x1560080f, 0xa43a4e30, 0xae0202a4, 0x274396f2, 0x68597f51, 0x124b75a1, 0x6cd1038f, 0x583d74aa, 0x52693848,
    0x3a168a33, 0xeefe9f1f, 0x5f3773c9, 0x5d28457d, 0x2d184b59, 0x7f0a0f21, 0x321c1a11, 0x56232844, 0x2a2d615d, 0x011f364a, 0x17300132, 0x4b02143e,
    0x43519a78, 0x542e5270, 0x898bdf9c, 0x00010000, 0x7d080082, 0xc3054804, 0x8f002200, 0x24af1b40, 0x240224ef, 0x480c0940, 0x0121ab22, 0x40012198,
    0x211b0121, 0x01210f01, 0xf0ffb821, 0x21214440, 0x0d1b1f00, 0x010d0f01, 0x1612200d, 0xaf0d9f48, 0x0d7d020d, 0x010d6b01, 0x4f010d5a, 0x0d2b010d,
    0x0d020d3b, 0x775a1e0d, 0x971f871f, 0x1f4f031f, 0x101f0001, 0x1f07021f, 0x211f001d, 0x11121f03, 0x3f00040a, 0x123f3fc1, 0x2f013939, 0x5d5d5d5e,
    0xc64e32e1, 0x712b2706, 0x33391171, 0x1382382f, 0x335d5d2a, 0x30315d2b, 0x37033e01, 0x5005f35c, 0x590806e1, 0x07050e07, 0x01112311, 0x191d0233,
    0x183c3f3d, 0x40352f16, 0x112b2329, 0x0b0d200d, 0x1323201c, 0x3632280d, 0xbb133236, 0x02cb42fe, 0xa0a84bdb, 0x3d282c89, 0x08091427, 0x07050391,
    0x18232a17, 0x85806e55, 0xe3fd3c85, 0x87032f02, 0x12000200, 0x6006ecff, 0x1c004a04, 0xfb823c00, 0x19476e08, 0x2f012f67, 0x012cd547, 0xa9012cb7,
    0x2c9a012c, 0x2c2c0301, 0xab483703, 0x0212bb12, 0x143e1212, 0x3e54013e, 0x3e843e64, 0x3eb43ea4, 0x013e4005, 0x013e3002, 0x22013e0f, 0x10030048,
    0x40033003, 0x05035003, 0xffb80306, 0x121540c0, 0x1a034815, 0x272d2d00, 0x50080e1d, 0x27320f0b, 0x16001650, 0xe1323f00, 0x32e13f32, 0x2f391232,
    0x31fe8212, 0xe15d5e2b, 0x5d5f5d5d, 0x3311715d, 0x11e15d2f, 0x0b822f39, 0x13825d20, 0x30313932, 0x35262205, 0x37023e34, 0x21373521, 0x031e2315,
    0x2306244a, 0x03060623, 0x0a235c18, 0x15333523, 0x081b4714, 0x02278b08, 0x12c3b629, 0xfe1a2b20, 0xc80586eb, 0x1b2618f3, 0x6ab5c40f, 0x1f0b1f8b,
    0x2816ba8b, 0x361d121f, 0x442e2d4b, 0x62b3162c, 0x364b2d52, 0x24190f1d, 0xf3ea1415, 0x7b7e7d39, 0x9a504a38, 0x7d7e7b38, 0x57eaf339, 0x03575b5b,
    0x797636c4, 0x83623a7a, 0x4829214e, 0xb0b03962, 0x4e218a82, 0x7a3a6283, 0x00367679, 0xc700ffff, 0x2f060000, 0x26027507, 0x00003000, 0x76000701,
    0x54017901, 0x0b401300, 0x26052701, 0x201a4b01, 0x196f0f09, 0x82ae200a, 0x0687222d, 0x202d8221, 0x822d8650, 0x282d843f, 0x0126113a, 0x16332d7a,
    0x262d8a2b, 0x04d5fd00, 0x82bc05dd, 0x8324202d, 0x5b022f2d, 0x00001b01, 0x03b70d00, 0x151f0102, 0x29830704, 0x83833520, 0xd5fd5e26, 0x5e049c03,
    0x44202782, 0x00212785, 0x212786bc, 0xac183d14, 0xff2508f5, 0xffd3feff, 0xef7918ec, 0x5c02230b, 0x278240fe, 0xb63f3008, 0x032d0203, 0xb8350203,
    0x09b2c0ff, 0xffb8480f, 0x351a4021, 0x250a0a35, 0x00b00001, 0x01008001, 0x5001007f, 0x00400100, 0x01001f01, 0x845d1100, 0x35352700, 0x35352b2b,
    0x03823f00, 0x00020032, 0x02d5fd73, 0x0083ff37, 0x001f0013, 0x1428403a, 0x10517f18, 0x8c1d2008, 0x05100500, 0x05400530, 0x05a00550, 0x060705f0,
    0x0f8c1705, 0xd4e12f00, 0x01e15d5e, 0x18e15d2f, 0x08204b7f, 0x23370220, 0x3231543d, 0x20203b52, 0x3032523b, 0x74233e54, 0x3f323140, 0x40313839,
    0x5133aefe, 0x82181d38, 0x998212bb, 0x68049328, 0xc705d902, 0x99820d00, 0x0940422b, 0x400e3015, 0x110e020e, 0x08ec821a, 0x091c4031, 0x1a1a4810,
    0x04010d2b, 0x020d140d, 0x0c05060d, 0x113f0c05, 0x115f114f, 0x001d1103, 0x395dcc2f, 0x012f2f39, 0x5d5dcd2f, 0x332b2f32, 0x43395dcd, 0x332f0586,
    0x07030e15, 0x36342523, 0x06061537, 0x4c1e1415, 0x013d06b4, 0x18190bb0, 0x12cf0816, 0x1f3e3830, 0x78e3fe52, 0x1f393c7a, 0x2f321f25, 0x8904453a,
    0x4a7d181e, 0x4e783809, 0x164c1f73, 0x1213182e, 0x251c1a10, 0xff004627, 0x001d00ff, 0x50b90600, 0x3a08076f, 0x49002700, 0x0000a202, 0x4c000701,
    0x00004405, 0x26403800, 0x398f0203, 0x01397001, 0x2f013940, 0x390f0139, 0xe0013901, 0x1fb0011f, 0x4baf1f01, 0x014b7001, 0x0f014b40, 0x505d014b,
    0x352005c4, 0x5005a341, 0x062107c9, 0x205992a8, 0x2259844f, 0x99254036, 0x013d2958, 0x40013d70, 0x3d0f013d, 0x4a08588f, 0x7d000200, 0x2506ecff,
    0x20001406, 0x4b003400, 0x061b2c40, 0x5b200913, 0x5b2b0101, 0xc0366709, 0x36bf0136, 0x01367001, 0x365f362f, 0x135b2102, 0x1b063566, 0x205f300e,
    0x5f260418, 0x3f00130e, 0xe1ce3fe1, 0x01393912, 0x82e1f610, 0x825d20b1, 0x2f332206, 0x065146e1, 0x030e1723, 0x084b4607, 0x02262627, 0x36123435,
    0x05bc5636, 0x14013524, 0xa956021e, 0x22232e07, 0x1706020e, 0x3f280c0e, 0x2d2b3f5a, 0xa0791851, 0xef280808, 0x51ec9ea4, 0x08193129, 0x6b34f2fb,
    0xa57272a5, 0x6a32326b, 0xa67272a4, 0x1406346c, 0x61703c16, 0xd859184c, 0xebfeaa7f, 0x0baa7918, 0x0c666f2b, 0x345d4a35, 0xdb89c9fc, 0x7fee1899,
    0xff71260f, 0x04f404ec, 0x08e982f2, 0x4a002c2d, 0x4a172c40, 0x121e1919, 0x0048270a, 0x02001000, 0x2e000007, 0x2e902e10, 0x2eb02ea0, 0x0a482104,
    0x1e122d56, 0x17502a05, 0x7a24100f, 0xc62006fa, 0x1124e988, 0x5d5e2f33, 0xec820d83, 0x860d434e, 0x853320de, 0x0bf57afb, 0x2d042308, 0x6fb27d43,
    0x477fae67, 0x6fb37c43, 0x2e3fa964, 0xc6061934, 0x3f2d100f, 0x24203956, 0x9a8900fd, 0x0383879a, 0x27026608, 0x4c91d589, 0x89d5914c, 0x4b91d388,
    0x370d4447, 0x17335d4b, 0x435e784a, 0x5e9e4114, 0xd1d3d3d1, 0x00d0d0d0, 0xb8000100, 0x4e06ecff, 0x24001406, 0x32405100, 0x08085b06, 0x9f015a23,
    0x0eb0010e, 0x010eaf01, 0x70260e0e, 0xf0268026, 0x265f0326, 0x10260001, 0x5a1b0226, 0x01256418, 0x06240d0d, 0x5f1e0319, 0x05bb4113, 0x2f333323,
    0x06bb4133, 0x5d24d382, 0xe133715d, 0x1523d285, 0x8435033e, 0x4f1120c4, 0x11220720, 0x94451133, 0x37420805, 0x34dd0411, 0xc60a203e, 0x55320f0f,
    0x85425b80, 0xc48088c9, 0xacbb4485, 0x528059b0, 0xb6050128, 0x4e3206c4, 0x47163864, 0x0f4a6982, 0xc47291fd, 0x8e4d5290, 0xae037ac7, 0xbfb048fc,
    0x51886236, 0xbd82b603, 0xffa44708, 0x047905ec, 0x002700f2, 0x1f334054, 0x0121214a, 0x271a4717, 0x29102927, 0xa0298001, 0x0329e029, 0x0001296f,
    0x30292029, 0x0f070329, 0x28540c47, 0x1f26261a, 0x120f0d18, 0x16070250, 0x3f001500, 0x3fe1333f, 0xc086c633, 0x465d5e21, 0x3322056f, 0xc08432e1,
    0x4d272121, 0xb7880770, 0x33113522, 0x0334d589, 0x190a1b75, 0x305c5245, 0x2f5c8a5b, 0x516f6ab6, 0xb61d436e, 0x9324d58a, 0x14293f2b, 0x0fd1d818,
    0xd8827b20, 0x1738653c, 0x486d8847, 0x00b0fc07, 0x8ffc0100, 0x19fed904, 0x0d002106, 0x0a401600, 0xe7180600, 0xfe3a1b9b, 0x51237919, 0xdb10404d,
    0x302e2b10, 0x1cd90416, 0x1b515853, 0x51502315, 0x49821d4c, 0x8248fd21, 0x87d12049, 0x00062549, 0x0c0f8005, 0x17c7c318, 0x1548fd25, 0x822b2e30,
    0x4d3f2b48, 0x04792252, 0x514c1df4, 0x83182350, 0xfc2c0805, 0xffd90446, 0x00e30514, 0x4038001b, 0x4c198418, 0x2842fe37, 0x1f474c4f, 0x680e302d,
    0x4a352105, 0x4d51292e, 0x2e2d1d45, 0x2b0d830f, 0x23db0449, 0x3e35232b, 0x2645613c, 0x0a198418, 0x04fd0128, 0x79feb804, 0x8d828f06, 0x12402628,
    0x0d080805, 0x05821500, 0x190f1234, 0x1902191f, 0x2f000680, 0x325dcc1a, 0x01331139, 0x0683cc2f, 0x25054d43, 0x27230707, 0xba4b033e, 0x06580805,
    0x36363507, 0xfe163233, 0x3c2d1b79, 0x0e710a22, 0x172a3c25, 0x1d322415, 0x1010341c, 0x85852932, 0x3a27d305, 0x6f071b29, 0x181006b0, 0x20181821,
    0x03030713, 0x5b05036c, 0xfd010000, 0xfe98fe31, 0x007dff06, 0xb50f000d, 0x0b008708, 0x2f000391, 0xe12f01e5, 0x34053031, 0x08050e4c, 0x23020e20,
    0x31fd2622, 0x3f2b2d3e, 0x15271d11, 0x3cf63e2d, 0x1d3c3737, 0x370e1c2b, 0xc700ffff, 0xbd180000, 0xc92a2c51, 0x10050000, 0x26027307, 0x7e82b201,
    0x43000734, 0x52014200, 0x01b41500, 0x01260518, 0xb4a3ffb8, 0x5818181e, 0x5f820995, 0xecff712a, 0x2106e103, 0x48002602, 0x06242f82, 0x00944300,
    0x02202d82, 0x1633b318, 0x0000ae24, 0x2d833b04, 0x85d20121, 0x83ca202d, 0x0c01222d, 0x215b8511, 0x49180c12, 0x5f080ca1, 0x07ecff7d, 0x00c9055e,
    0x40710045, 0x39041448, 0x36c5255a, 0xa6369601, 0x36890236, 0x1d363601, 0x670c5b41, 0x10470047, 0x47000247, 0x47504720, 0x47d04770, 0x070647e0,
    0x661d5b2e, 0x33373746, 0x035f2900, 0x22072626, 0x09201404, 0x3c14480e, 0x18115f33, 0x333f0013, 0x2b3232e1, 0x1133333f, 0x12260882, 0x10012f39,
    0x5418e1f6, 0x5d21090e, 0x2315825d, 0x01303139, 0x11215218, 0x23272626, 0x22230606, 0x6a0b0746, 0x14290743, 0x3233021e, 0x33113736, 0x0abe5c11,
    0x3c687708, 0x3b4c2a5e, 0xb777518f, 0x813f407d, 0xaa6f88c6, 0xa84b0249, 0x81c6886e, 0xb77d403f, 0x3b8f5177, 0x3c5f294c, 0x2b507145, 0x5c8a5c2e,
    0xbb2e7639, 0x5c3b762e, 0x2c2e5c8b, 0x25057150, 0x2a9c202e, 0xfeb8632c, 0xfeaaa6f8, 0x3277d2df, 0x77323030, 0xaa2101d2, 0xb80801a6, 0x9c2a2c63,
    0x8a462e20, 0xe58d88cf, 0x262459a4, 0x43febd01, 0xa4592426, 0xcf888de5, 0x3b4c468a, 0xf4053a05, 0x2c004a04, 0x0940e700, 0xc9011065, 0x0222f922,
    0xf0ffb821, 0x48100ab3, 0x2107832c, 0x07841b12, 0x0a19403a, 0x1000480f, 0x26481b0a, 0x210e220d, 0x002c1522, 0x660f5606, 0x0e0f020f, 0x49082582,
    0x0e1f4840, 0x7f0e6f01, 0xdf0e9f0e, 0x0e59040e, 0x010e4f01, 0x6b011574, 0x15240115, 0x24021534, 0x44063406, 0x94067406, 0x060e0506, 0x060e1515,
    0x471b0103, 0x1c101c00, 0x1c1c0702, 0x202e102e, 0xd02e302e, 0x052ee02e, 0x4c830102, 0x26011e2a, 0x481d1540, 0x140c2026, 0x22086d82, 0x0e1b0310,
    0x06150f01, 0x06360626, 0x00220602, 0x323f0015, 0x33115d32, 0x1733333f, 0x012b2b39, 0x8233382f, 0x5e2f2a0d, 0x1712e15d, 0x2f2f3d39, 0x068e4c18,
    0x84715d21, 0x11332618, 0x12113333, 0x36298239, 0x315d2b2b, 0x01215d30, 0x16161333, 0x033e3317, 0x33031337, 0x83031e13, 0x3598080a, 0x02021433,
    0x03230706, 0x0e352626, 0x01030703, 0xbc89fe77, 0x09261ce0, 0x1a150707, 0xa2770f1d, 0x1f0cc9bc, 0x0705181e, 0x1941725a, 0x9a5c25b7, 0x0c77c075,
    0x0906010d, 0x0498040a, 0x5756fd4a, 0x3a16339d, 0x01204541, 0xfdcf010c, 0x676321b0, 0xd067195c, 0xa398ffe2, 0xf5fedffe, 0x54017ffc, 0x01033520,
    0x0a1d1b13, 0x0000aafe, 0x00140002, 0x06bc0400, 0x00160014, 0x409b0021, 0x1700130a, 0x15150c5a, 0xb80c1006, 0x0d40c0ff, 0x2048271a, 0x9002010c,
    0x020ca00c, 0xb3231183, 0x84481813, 0x40440819, 0x0c480e0b, 0x5b1b0e0c, 0x00236706, 0x50233023, 0x80236023, 0x23e00523, 0x01239f01, 0x0e012350,
    0x16005f21, 0x13105f0d, 0x0100b010, 0x4f010089, 0x100f0100, 0x10000701, 0x00111000, 0x120c6017, 0x3fe13f00, 0x2005234f, 0x06db6a5d, 0x01e11023,
    0x370b822f, 0xe1f61071, 0x2b2f3911, 0x715f5d2b, 0x3912332b, 0x32e1102f, 0x01303132, 0x2a07064f, 0x21112123, 0x33112135, 0x82152111, 0x50322005,
    0x3808056a, 0x960a0223, 0x377ecf98, 0x86c27e3c, 0xc4fe96fe, 0x01ba3c01, 0xa087fe79, 0x5b2ea4ae, 0x03815d8b, 0x9871424e, 0x709e6157, 0xa460043d,
    0xf0fe1001, 0x8440fca4, 0x3c614688, 0x0601411b, 0x27056d32, 0x21001400, 0x09408100, 0x47160213, 0x010c0010, 0x472ce684, 0x0c481a0d, 0x0e000c00,
    0x5706471c, 0x103fe882, 0x23700223, 0x23c02390, 0x0e0423e0, 0x01025015, 0x1310500d, 0x1f020f10, 0x40020202, 0x82481e0c, 0x100f34e3, 0x0702101f,
    0x10021002, 0x3001117f, 0x16110111, 0x82150c50, 0x85db82ed, 0x2b7122ef, 0x0916505d, 0x1220ed83, 0x2b221783, 0xe785335d, 0x3230de82, 0x0e141516,
    0x11212302, 0x35333523, 0x01211533, 0x09684518, 0xfee30232, 0xd31501d5, 0x9f652fcd, 0xee39fe71, 0x2b01b6ee, 0x042c1082, 0x26435e37, 0x40604121,
    0xd7feb003, 0x08cb4618, 0x18dddd21, 0x080e7545, 0xecffc737, 0xcb05ec06, 0x58002d00, 0x05082f40, 0x07221b5b, 0x22071111, 0x2a2a1e03, 0x5a1d212f,
    0x2b2e641e, 0x04275f00, 0x5f1c081b, 0x210f0522, 0x21210801, 0x121e031f, 0x2867180d, 0x393f2308, 0x796c5e2f, 0xe13f3205, 0xf6100133, 0x331132e1,
    0x17122f7d, 0x2f2f1839, 0x6cbf822f, 0x1e2c0983, 0x36323303, 0x030e1537, 0x26262223, 0x0c954418, 0x07171627, 0x6d052626, 0x3367185f, 0x75230809,
    0xa05971ac, 0x564e274e, 0xeb9e3a61, 0xfe05529d, 0x01babab0, 0xa7630e56, 0xc46c95e9, 0x953f4e4f, 0x18412705, 0x080e3b67, 0x01b8644a, 0x56fd9f03,
    0x98fdb605, 0x5ca7eb8f, 0x209c2a2c, 0x0100002e, 0xecffae00, 0x5e047105, 0x64002900, 0x1d203940, 0x0c4f0548, 0x0c1f0c01, 0x1427081f, 0x070b2b14,
    0x2a540847, 0x1115511a, 0x06052010, 0xa90c1d50, 0x020bb90b, 0x2906f459, 0x090b0b06, 0x2315080f, 0x5b4f2651, 0x843f2005, 0x21ec86eb, 0xec88e133,
    0x39123322, 0x5d20ed83, 0x0522ed84, 0xdb8f2e22, 0xf1822e20, 0x6d070621, 0x043c0b7a, 0x81a96154, 0xf1fe074f, 0x1301b6b6, 0xa581550c, 0x32954e5e,
    0x3c381736, 0x918c193b, 0x07d84218, 0x3682523b, 0x3a147c35, 0xfe87c17b, 0xfe4a0417, 0x72b58039, 0x9a192234, 0x090f130a, 0xde421897, 0x00002308,
    0x00820002, 0x2f054908, 0x0b00b605, 0xae001800, 0x06084940, 0xe806d801, 0x07070206, 0xe707d701, 0x07a60207, 0x01019b01, 0x00a70077, 0x090a0d02,
    0x0704030c, 0x08131306, 0x000100a7, 0x09050101, 0x00010800, 0x20081008, 0x80087008, 0x0608c008, 0x4f080b82, 0x1a901a08, 0x1a021aa0, 0x40c0ffb8,
    0x4818150f, 0x40011a8f, 0x1a0f011a, 0x05040801, 0x40f0ffb8, 0x030b0513, 0x0a10135f, 0x0c13480e, 0x0004060c, 0x03061209, 0x333f3f00, 0x2f391233,
    0x32e12b39, 0x33382f01, 0x5d5d5d5e, 0x33115d2b, 0x715d382f, 0x33251783, 0x3d39115d, 0x2322832f, 0x39391239, 0x5d2d1c82, 0x31715d71, 0x11232130,
    0x01230123, 0x08038233, 0x21272395, 0x27032e27, 0x0207030e, 0xfe7fa6ec, 0x3902c5fe, 0xc73b02bb, 0xe87afefe, 0x12352301, 0x0711161c, 0x19151109,
    0xfdaa0211, 0xfab60556, 0xa4aa024a, 0x434c308f, 0x41252541, 0x002d4943, 0x0a000200, 0x5a040000, 0x0b004a04, 0xcf001700, 0x02393840, 0x02790259,
    0x1b040289, 0x02022b02, 0x960105b5, 0x0205a605, 0x09010587, 0x02031903, 0x08160806, 0x19120902, 0x11060212, 0x07021116, 0x11020312, 0x00b60908,
    0xffb80001, 0x0a1b40f8, 0x0bb9480f, 0x82080b01, 0x0b003607, 0x0c010cb4, 0x0605050c, 0x10010a06, 0xffb80102, 0x1512b3c0, 0x08078348, 0x07184037,
    0x0101480b, 0xe019c019, 0x19af0219, 0x01195001, 0x191f190f, 0xb80a0902, 0x0f40f0ff, 0x5008040a, 0x11110b0c, 0x0a0f0b01, 0x00150106, 0x3f33333f,
    0x122f3912, 0x05234139, 0x00825d20, 0x2f331126, 0x38332b2b, 0x332e1582, 0x2f3d3912, 0x2b33335d, 0x125d2b5d, 0x02823939, 0x1f825e20, 0x31290283,
    0x015d5d30, 0x23032301, 0x08018211, 0x0123032b, 0x07030e17, 0x27032e33, 0xb401a602, 0xa260bbbc, 0x01bdba60, 0x1b0571b4, 0xf00d2523, 0x1b23250e,
    0xfb4a0404, 0xfee901b6, 0x3f038317, 0x19794a04, 0x225e6055, 0x54605f22, 0x02000019, 0x0000c700, 0xb6052907, 0x20001300, 0x1b40bf00, 0x27081a42,
    0x15050e06, 0x03141112, 0x05263e82, 0x0e0f0100, 0xc383051b, 0x805d6208, 0x1bcb0101, 0x011b8401, 0x1b7b1b2b, 0x1f050f02, 0x7f052f05, 0xdf05cf05,
    0x0705ff05, 0x1b010508, 0x0305011b, 0x00101011, 0x70101010, 0xf010b010, 0x10100510, 0x50223022, 0xd022c022, 0x0522e022, 0x095a080c, 0x06132164,
    0x1b0d5f03, 0x48100920, 0x0e14141b, 0x11010409, 0x030e0a12, 0x3f333f00, 0x06374233, 0x32e13336, 0xf6100132, 0x115d32e1, 0x385d2f33, 0x3d391733,
    0x2f2f182f, 0x24050441, 0x33331138, 0x23018311, 0x11393912, 0x06820282, 0x425d5d21, 0x2122083e, 0x1c822311, 0x42132121, 0x042f0d46, 0xfe81a5e7,
    0x0801c4fd, 0xbaba7ffe, 0x42f1c101, 0x792a054d, 0x352301e9, 0x11151c13, 0x4d420808, 0x05514207, 0x0298fd23, 0x13554268, 0x00ae3c08, 0x04080600,
    0x0013004a, 0x40eb001f, 0x0105a531, 0x05960586, 0x01057702, 0x09160906, 0x29021902, 0x69024902, 0x05027902, 0x1a01020b, 0x08190203, 0x0b120914,
    0x0d110a13, 0x42c60e47, 0x1728064e, 0xc9480f0a, 0x08130113, 0x00290782, 0x0114c413, 0x05051414, 0x05254206, 0x0a2f1332, 0x0aaf0a3f, 0x0a060a03,
    0x540e0106, 0x10010220, 0x080c6242, 0x0b072c3d, 0x21010148, 0xbf0121d0, 0x21600121, 0x21902170, 0x01214f03, 0x08012100, 0x5008040b, 0x19131412,
    0x130f0219, 0x06090e0f, 0x3f001502, 0x3f333333, 0x2f391233, 0xe1333912, 0x41013232, 0x1131053e, 0x2b2b2f33, 0xe6103338, 0x2f393911, 0x33385d2f,
    0x0b6d4211, 0x32e11024, 0x54411211, 0x43112005, 0x5d23059b, 0x4230315d, 0x13200a71, 0x20076041, 0x06794217, 0x42540421, 0xc3280879, 0xb6b6e9fe,
    0x70b55401, 0x42167f42, 0xfe280583, 0x79c70139, 0x5f605419, 0x08098742, 0x00001424, 0xb6056a05, 0x26002300, 0x1140c000, 0x86012286, 0x1259011a,
    0x25021289, 0x480c0910, 0xf0ffb826, 0x08822c40, 0x0a255208, 0x2424060b, 0x261b5a1a, 0x100a0007, 0x030a200a, 0x07071b0a, 0x00030a1b, 0x20111012,
    0x11d00211, 0x90118001, 0xb8110211, 0x3b40c0ff, 0x11480a07, 0x281f2811, 0x0128f001, 0x28df28cf, 0x50284002, 0x03287028, 0x283f280f, 0x00230702,
    0x24611c19, 0x2305190b, 0x0a002d0a, 0x085f2607, 0x00121b03, 0x323f0012, 0x2b073d55, 0x33715d5e, 0x0132e133, 0x5d5e332f, 0x71200082, 0x2105e75a,
    0xc15a3371, 0x10240808, 0x2f3d39e1, 0x33113333, 0x5d5d2b2b, 0x335d3031, 0x37033e13, 0x15213501, 0x17031e01, 0x2e032313, 0x11232303, 0x59080182,
    0x07020e22, 0x21010103, 0x36187b14, 0xfe5f7c54, 0xfe490490, 0x56806185, 0xbe7a1837, 0x3626147b, 0xbb183d4f, 0x364f3d18, 0x017b1426, 0xfd4a01eb,
    0x55c5016f, 0x063a6288, 0x8b8be701, 0x380619fe, 0xfe568962, 0x48c1013b, 0xfd17395f, 0x17b80248, 0xfe485f39, 0x015a033f, 0xef4400b8, 0x04e53506,
    0x0023004a, 0x40c70026, 0x861a760d, 0x031a961a, 0x0c071025, 0x20053d41, 0x3c088218, 0x06011209, 0x060b0123, 0x461a2424, 0x260a251b, 0x011ba707,
    0xc0ffb80a, 0x19161040, 0x08484148, 0x01112023, 0x06d64411, 0x40280783, 0x480b073f, 0x10281111, 0x08064341, 0x9028602e, 0x281f0228, 0x2302284f,
    0x26070a00, 0x1c190850, 0x26241652, 0xa6243624, 0x0b240424, 0x061f060f, 0x065f064f, 0x06060704, 0x121b0f08, 0x2005034b, 0x0518483f, 0x32e15d29,
    0x3232e110, 0x41332f01, 0x2b200748, 0x25074741, 0x33115d2b, 0x4a413311, 0x5d5d2606, 0x315d2b2b, 0x1d484130, 0x21135308, 0x2c167b0a, 0xfe536742,
    0xfecf03ce, 0x436853c9, 0xba7b172c, 0x3024147b, 0xa6043544, 0x30463504, 0x017a1425, 0x0afefcb4, 0x653d5401, 0x0109314d, 0xfe696964, 0x4c31089c,
    0xacfe3d67, 0x48365001, 0xf6fd112b, 0x2b110a02, 0xb0fe3648, 0x2d018302, 0x11450000, 0x89240805, 0x2800b605, 0xca002b00, 0x1f861540, 0x89175901,
    0x0b100217, 0x5a1f2929, 0x09102a20, 0xb82b480c, 0x3340f0ff, 0x2a3c0882, 0x000c2b0f, 0x200f100f, 0x0f07030f, 0x0c20200c, 0x2816030f, 0x00c000b0,
    0x1f000f02, 0x4e084b82, 0x00170700, 0x02161016, 0x16801670, 0x160316c0, 0x40c0ffb8, 0x480a0734, 0xe02d1616, 0x2d9f012d, 0x40022dbf, 0x2d2f012d,
    0x5a060a01, 0x0f2c6407, 0x0d5f2b0c, 0x6121051e, 0x0b0f1029, 0x0b0b0801, 0x07030d08, 0x00032017, 0x173f0012, 0x41333f32, 0xe1210543, 0x05434132,
    0xe1f61023, 0x07344632, 0x21055647, 0x93425d5d, 0x5d5e2706, 0x33113311, 0x4d412b2b, 0x30312608, 0x36361321, 0x06b94337, 0x371a9a42, 0x137b3302,
    0x7bfe1c29, 0xa402baba, 0x4a0495fe, 0x806185fe, 0x7b183755, 0x23069f42, 0x3c19ba19, 0x220c9f42, 0x492e7344, 0x01210565, 0x22a342dd, 0x0000ae38,
    0x4a049806, 0x2b002800, 0x0d40cf00, 0x1f861f76, 0x2a031f96, 0x53410710, 0x822c2006, 0x09280808, 0x0b100117, 0x461f2929, 0x2b0f2a20, 0x0120a70c,
    0x0c0c200f, 0x16030f20, 0x002f001f, 0x0100ff02, 0x17070000, 0x16011620, 0x8306a242, 0x403a0807, 0x480b073f, 0xcf2d1616, 0x2db0012d, 0x012d9f01,
    0x4f012d60, 0x2d00012d, 0x0a022d30, 0x54074706, 0x2b0c0f2c, 0x051e0d50, 0x29a65221, 0x0f102901, 0x020b1f0b, 0x080b0b07, 0x4b820f0d, 0x15000322,
    0x200b5f41, 0x0f60415d, 0x115d5d2d, 0x2b2b2f33, 0x39123371, 0x43715d2f, 0xac4208f5, 0x2b2b2209, 0x2660415d, 0x0121133a, 0x1d107bbc, 0xb6edfe13,
    0xfe0b02b6, 0xfece03d5, 0x436853c9, 0xbb7b172d, 0x2409b742, 0x14243145, 0x06b7427b, 0x204b2a22, 0x2105ef49, 0xbb425e01, 0x018f0820, 0x46fe3900,
    0xd506ec03, 0x9f007600, 0x18212740, 0x59480e09, 0x4d515962, 0x3b51474d, 0x516c675b, 0x67354467, 0x67145114, 0x05443551, 0x725b2e24, 0x5a057867,
    0xc0ffb824, 0x18143640, 0x525d2448, 0x9f568f4d, 0x0356af56, 0x0b074056, 0x47565648, 0x4f60346c, 0x350f0135, 0x080235af, 0x43293535, 0x40036251,
    0x15034761, 0xfb1f5f0a, 0x13006029, 0x3fe13f00, 0xe13f33e1, 0x39123317, 0x715d5e2f, 0x331139e1, 0x335d2b2f, 0x2b2f01e1, 0x4ef610e1, 0x182105e3,
    0x2800822f, 0x10391211, 0x333311e1, 0x2503832f, 0x2b003031, 0xaf5c2205, 0x023e2707, 0x021e3233, 0x866b1517, 0x77232005, 0x2e6d0850, 0x23232205,
    0x098f5635, 0x2707062b, 0x2e373636, 0x33352703, 0x056b6d16, 0x5b171621, 0xcb6207ac, 0x3c5f1805, 0x012d0807, 0x345a47e1, 0x3d240e14, 0x5361412f,
    0x422b3251, 0x080c2331, 0x354d361f, 0x5c4a4731, 0x4f886846, 0x9d663120, 0x5180596c, 0x91673926, 0xbc6b1858, 0x3b80080d, 0x371867a6, 0x79143236,
    0x1a366133, 0x2a4b433b, 0x0b0e2f1f, 0x30161122, 0x52142e30, 0x332b557e, 0x574b7d5b, 0x43325e8a, 0x1214c483, 0x16182920, 0x040e1a24, 0x0a070404,
    0x07b6070f, 0x030c1012, 0x48290203, 0x623c3760, 0x48262646, 0x65474469, 0x27971d3f, 0x363e6448, 0x431e3a53, 0x4b307d36, 0x3f411e11, 0x221b173a,
    0x46243861, 0x05092338, 0x17070577, 0x0d213829, 0x45765c3f, 0x3958774a, 0x0a2e6c18, 0x01008008, 0x73fe1700, 0x52055203, 0xb7007000, 0x18407140,
    0x68480e09, 0x036c6268, 0x586c030c, 0x6c161146, 0x015fe011, 0x3311525f, 0x6c11336c, 0x43055f52, 0x571c474d, 0xd072c072, 0x0372e072, 0x3001727f,
    0x720f0172, 0x46260701, 0x110c4043, 0x16164348, 0x52895051, 0x0f025299, 0x52080152, 0x68486252, 0x40005207, 0x00481410, 0x480c0740, 0x006c5e00,
    0x0c505b03, 0x2b341062, 0x48fb3e50, 0x41162150, 0x333806e2, 0x2f3317e1, 0x33e12b2b, 0x2f391211, 0xe15d5d5e, 0x012f3d39, 0xe12b2f18, 0x5d210b82,
    0x0cea415d, 0xeb415d20, 0x0a356e10, 0x41067264, 0x232007a6, 0x200c0542, 0x15044216, 0x098b6d18, 0x52232621, 0x024205bf, 0xcf02300a, 0x0b0e2f1f,
    0x2e151121, 0x37132d2e, 0x18233f59, 0x080b045e, 0x2f594b53, 0x3a220e0f, 0x5d63322c, 0x47422153, 0x2822090d, 0x5520132c, 0x58396f64, 0x22184070,
    0x376e9056, 0x852c4c64, 0x3d61818a, 0x73274864, 0x4b81476c, 0x416b393f, 0x2c303117, 0x62337912, 0x433a1a36, 0x0952054b, 0x07057705, 0x1f332615,
    0x5845310e, 0x365e1835, 0x5b3a0808, 0x5674443d, 0x261a0e31, 0x18231617, 0x0304030d, 0x0a971316, 0x03060a0f, 0x472e0303, 0x592f2956, 0x2b132a46,
    0x5b5e3345, 0x40271299, 0x264d4d2d, 0x221c9322, 0x373b1c08, 0xfa411532, 0xffff3907, 0x00006800, 0xb605ba05, 0x75010602, 0xffff0000, 0x14fea400,
    0x12067105, 0x47080f82, 0x00000095, 0xff7d0003, 0x057105ec, 0x001300cd, 0x0029001e, 0x2532404f, 0x67005b19, 0x012bd02b, 0x80012bcf, 0x2b3f012b,
    0x24022b6f, 0x660a5b1a, 0x4f601a2a, 0x240f0124, 0x24df24af, 0x24240803, 0x0f5f1f14, 0x055f1404, 0x2005a543, 0x05a04312, 0x2205524b, 0x745d5d5d,
    0x02200725, 0x200efc53, 0xdd851816, 0x032e240e, 0x59517105, 0x9a3e0afa, 0xfd51a0ec, 0x6b9e6a87, 0x9afc0639, 0x9e6b3a06, 0x6c9c696d, 0x6403083d,
    0x9b693b08, 0xf559dd02, 0xc56b370e, 0x07fdebfe, 0x7ac28647, 0x4786c27a, 0x80439a04, 0xb87575b8, 0xd9834380, 0xecff7126, 0x5e042d04, 0x1a22d982,
    0xd9822100, 0x1f333008, 0x57004817, 0xd0234023, 0x0323e023, 0x1e01230f, 0x560a4818, 0xef501822, 0x1ea9011e, 0x0f021eb9, 0x2f1e1f1e, 0x1e06031e,
    0x501b141e, 0x5914100f, 0xe12006fe, 0x5d21da84, 0x05814f5d, 0x0e21d989, 0x094b4402, 0x01021e2f, 0x21373632, 0x22131616, 0x26210706, 0x0df45926,
    0x7fae6734, 0x8d23fe47, 0xbefd0a88, 0x898c8c09, 0x3e020e88, 0xef598a0d, 0x914b250d, 0xb2d4fdd3, 0x03290082, 0xa4a4a244, 0x010000a2, 0x08008200,
    0x05020522, 0x001c00c3, 0x0729405a, 0x010d0b06, 0x0d010dfb, 0x1990080d, 0x190219d0, 0x1e001e19, 0x011eb001, 0x2208b485, 0x1e5f1e4f, 0x07061e7f,
    0xffb80809, 0x080c40f0, 0x04166000, 0x0d030809, 0x00120706, 0x3f33333f, 0x4fe13f33, 0x712c0626, 0x5d2f3311, 0x2f3d3912, 0x3333715d, 0x2e062d51,
    0x33012301, 0x17161601, 0x13373636, 0x7133033e, 0x3c080583, 0x35249604, 0xfe12242a, 0x19fecdd7, 0x1d2701c5, 0x2a0e112e, 0x3d1f8d1a, 0x234b674c,
    0x35171a44, 0x48252d05, 0xe9fb4267, 0x61fcb605, 0x4e4faf5b, 0x000261bc, 0x2b629c71, 0x0997080d, 0x33bf860d, 0x52040e04, 0x6d001f00, 0xff1e00b9,
    0x0a1640f8, 0x081f480e, 0x2b080483, 0x0d20071e, 0x07074811, 0x0116e000, 0xe0ffb816, 0x0a071a40, 0x21161648, 0x21cf21bf, 0x500321ef, 0x210f0121,
    0x214f212f, 0x00010703, 0x0030d084, 0x151f071e, 0x0f134f1a, 0x000f0001, 0xe13f323f, 0xd086d482, 0xd0825d20, 0xd1842b20, 0x33332b27, 0x30312b2b,
    0x07c75411, 0x4208cc8a, 0x07062223, 0xc9bc2303, 0x1a1f200b, 0x14040605, 0x56091918, 0x58433519, 0x11221a3c, 0x2f12260b, 0xf3e0183a, 0xa2fd4a04,
    0x616e6a21, 0x6c5f1919, 0x40012167, 0x1842755e, 0x03870505, 0xfc585005, 0x41ffffdf, 0x0725058f, 0x02260273, 0x38de8280, 0x04760307, 0x005201b8,
    0x0102b619, 0x0226051d, 0x82ffb801, 0x081d31b4, 0x05d35f19, 0x35352b23, 0x23338500, 0x21060e04, 0x81203382, 0x50203386, 0x33834782, 0x84112021,
    0xb4942533, 0x16002034, 0x45083389, 0x7d000300, 0x5a0914fe, 0x1300cd05, 0x4a002700, 0x0a40a100, 0x381e5b00, 0x372f2f4a, 0xffb82829, 0x282340f0,
    0x40004028, 0xf0024010, 0x401f0140, 0x403f402f, 0x011e0003, 0x401e401e, 0x1037360a, 0x37e037d0, 0x064a3702, 0x0b2f0805, 0x4c373748, 0x0f014c0f,
    0x2f4c1f4c, 0x7f4c4f4c, 0xdf4cbf4c, 0x084cef4c, 0x0a5b1407, 0x2f384b66, 0x44284a4a, 0x361b3d50, 0x5f230f28, 0x4319040f, 0x3f2607ca, 0x11e13f33,
    0x6d181139, 0x8e4c0725, 0xc1382605, 0x2f393912, 0x06554b2f, 0x3d280d83, 0x1033332f, 0x013031e1, 0x57053464, 0x16230ae0, 0x5d140512, 0x25200de6,
    0x24099341, 0x030e0133, 0x0a206923, 0x05374808, 0xdd964c1f, 0x93e09891, 0xe1934747, 0x95dd9099, 0x2f23fc4c, 0x67679661, 0x2e2e6096, 0x68679460,
    0x042f6197, 0x0dd7bd43, 0x0413191d, 0x1b170406, 0xbcc70b1d, 0x401d4efe, 0x34507456, 0x40151b4c, 0x34463023, 0x44390f25, 0xab20141c, 0x080e0e5e,
    0x9bfde396, 0x53585828, 0x61561922, 0x6302215e, 0x815127fb, 0x060b315a, 0x17070591, 0xa029402c, 0x00ffff00, 0x0814fe71, 0x005e044e, 0x00520026,
    0x00070100, 0x006f045c, 0xb1110000, 0x04b80202, 0x2f20b414, 0x0125000a, 0x3500352b, 0x00020000, 0x0583ff7d, 0x003106c3, 0x003f001f, 0x30334052,
    0x4167005b, 0x41c441b4, 0x01419002, 0x80413002, 0x5b200241, 0x19406610, 0x180b0118, 0x14080401, 0x38070208, 0x1b5f3b35, 0x28031518, 0x05085f25,
    0x3f00120b, 0x32e13333, 0x322b0484, 0x5d5d5d5e, 0xe1f61001, 0x775d5f5d, 0x142706dc, 0x0607020e, 0x65222306, 0x372d0770, 0x32333636, 0x031e1716,
    0x021e1405, 0x08555f17, 0x022e3423, 0x08268527, 0x05030e95, 0xc58949c3, 0x374a0e7c, 0x810d483b, 0x454587c7, 0x0d81c787, 0x4a373b48, 0x89c57b0e,
    0x2d7ffb4a, 0x11537f57, 0x45313543, 0x57805211, 0x80572d2d, 0x31461052, 0x53114335, 0x022d577f, 0xc0fc95dd, 0x363f177d, 0x7d163f36, 0x9696fec0,
    0x177bbffb, 0x3d33313f, 0xfbbf7d17, 0x92c07496, 0x26301562, 0x62152e28, 0x7374c092, 0x166292bf, 0x30292932, 0xbf916116, 0x00020000, 0x0491ff71,
    0x00b604a8, 0x0037001f, 0x482cb554, 0x39395700, 0xb3c0ffb8, 0x8348140e, 0x24402907, 0x20480c09, 0x38561048, 0x2f0b0d41, 0x50352f32, 0x0f15021b,
    0x50232629, 0x160b0508, 0x41050e41, 0x2b240e0f, 0xe1f6102b, 0x4106215c, 0x1620160d, 0x24060c41, 0x34353636, 0x060b4126, 0x06064808, 0x6b39a804,
    0x3c095f99, 0x083b3a38, 0x3d6e995d, 0x629a6c39, 0x373a3b08, 0x985b093d, 0x85fc3c6d, 0x390b7b6f, 0x0c393234, 0x786e6d79, 0x3432390c, 0x6f7b0b39,
    0xbf762702, 0x39125a8e, 0x12382d2e, 0x77c08e5a, 0x828dbf75, 0x29e8080d, 0x5b123a2a, 0xac75bc8d, 0x202c1fcd, 0xcc1f2a20, 0x20c8a9ab, 0x2d20202b,
    0x0000c81f, 0xff7d0003, 0x083507ec, 0x0045003d, 0x006d005b, 0x379240da, 0x14042414, 0x03241404, 0x0c5b411c, 0x6f006f67, 0x00026f10, 0x506f206f,
    0x906f806f, 0xd06fa06f, 0x086fe06f, 0x661c5b2d, 0x4768636e, 0x51685c47, 0x52505240, 0x52035260, 0x68005f52, 0x68206810, 0x68906880, 0xe0680705,
    0xbf4d014d, 0x0256cf56, 0x46ef5256, 0x47474601, 0x5201524f, 0xc06b6052, 0xe06bd06b, 0x6f6b046b, 0xaf5f7f5f, 0x045fef5f, 0x5f015f10, 0x115f3c32,
    0x8f377f14, 0x40370237, 0x37480a07, 0x13111737, 0x28030325, 0x07215f00, 0x333f0004, 0x113332e1, 0x33333f33, 0x335d2b2f, 0x2f32e110, 0x5dcc5d5d,
    0x33712f32, 0x105dcd10, 0x5dcd5ddd, 0x5d5e2f01, 0x5d2c1d82, 0x32cd10cd, 0x1039112f, 0x715de1f6, 0x210a7a49, 0xe05b3311, 0x0ee24716, 0xdf5b1720,
    0x023e220c, 0x05fc7237, 0x2e34353e, 0x23150302, 0x23022e22, 0x15150622, 0x36343523, 0x021e3233, 0x06140533, 0x36363507, 0x12841e83, 0x3f051622,
    0x250e025c, 0x4745a267, 0x015c67a0, 0x562a2916, 0x1717424e, 0x2a564e42, 0x3d06045c, 0x90561003, 0x2e2a647a, 0x6d7c853a, 0x8577703a, 0x78effe4e,
    0x1f383c79, 0x2e321f24, 0x225c443b, 0x2c2a2310, 0x225c2a2c, 0x23132816, 0x2f1c1c2f, 0x5c591323, 0x022b0622, 0x2a2481a6, 0x10352d24, 0x82656b23,
    0x4de22708, 0x164c1f73, 0x0664192d, 0x268b0805, 0x00030046, 0x05ecff71, 0x000807df, 0x00590043, 0x40b2006c, 0x4567606b, 0x4f675a45, 0x50505040,
    0x5d505002, 0x679f676f, 0x01671002, 0x0b152467, 0x03033f35, 0x3f482c0b, 0x481e6e57, 0x006d560b, 0xdf4b014b, 0x50540154, 0x4401440f, 0x506f4545,
    0x00505001, 0x6ae0016a, 0x6a026af0, 0x5d7f5d0f, 0x2f5d0702, 0x1634511b, 0x10103a16, 0x00512921, 0x10402403, 0x40244815, 0x24480c07, 0x16000624,
    0x32323f00, 0x332b2b2f, 0x5d32e110, 0x2f2506a6, 0x5dcc5d5e, 0x05e14171, 0xdd107129, 0x0171cd5d, 0x82e1f610, 0x39122b02, 0x39122f3d, 0x18333912,
    0xf1415d2f, 0x3031230b, 0x3d432205, 0x022e2305, 0x384d3435, 0x2e072306, 0xb56e2303, 0x37362106, 0x08be7818, 0x5e182220, 0x13200dc4, 0x2318d841,
    0x042e3435, 0x0805d741, 0x5110043d, 0x6a2b2b6d, 0x7fa95f50, 0x936d3f4a, 0x3c401f54, 0x113f1434, 0x122b2b29, 0x888d6970, 0x16297349, 0x29423931,
    0x70698c85, 0x292b2b12, 0x35144011, 0x54203f3c, 0x4a3f6d93, 0x413aa97e, 0x862507d5, 0x70396e7c, 0x05d54178, 0x150f742e, 0x320f151a, 0x14443b2e,
    0x23202023, 0x07955b18, 0x16100939, 0x130a9a0c, 0xd3ca090f, 0x2034c3d3, 0x0e181e10, 0xcad3d3c3, 0x18130f09, 0x2e09355f, 0x3f89d596, 0x2482aa06,
    0x342e242b, 0x416c2311, 0x340808cf, 0x0f0d3329, 0x170f0a0c, 0x46262612, 0x00020000, 0x07ecff7d, 0x0004075e, 0x0053000d, 0x2362409b, 0x335a4712,
    0x960144c5, 0x0244a644, 0x44014489, 0x5b4f2b44, 0x081d821a, 0x1a2b0d47, 0x55005567, 0x00025510, 0x50552055, 0xd0557055, 0x0655e055, 0x2b5b3c07,
    0x45455466, 0x5f370e41, 0x09341130, 0x80000404, 0x023f060a, 0x02cf027f, 0x02ef02df, 0x15340205, 0x234a0430, 0x480e0920, 0x1f5f4123, 0x05695f26,
    0x3f322b32, 0x5d2f3333, 0xcd1a3333, 0x11332f39, 0x32e11033, 0x550a735f, 0x10250557, 0x2f3911e1, 0x08795f5d, 0x23071524, 0x03862327, 0x875f3520,
    0x528b2d42, 0x31b83222, 0x32b83123, 0x1c035022, 0x5f0e9143, 0x07242b94, 0x67ac1b04, 0xac230082, 0x5f21fe1b, 0x00203a9e, 0x2a05795a, 0x00a405f4,
    0x013a000d, 0x820d4023, 0x2a0d2907, 0x0130b90f, 0x2f013082, 0x2006a55f, 0x2207833a, 0x83481b13, 0x19402907, 0xa9480f0a, 0x100e010e, 0x0e211082,
    0x280c8210, 0x341c1b30, 0x1d011d66, 0x0825821c, 0x0f534054, 0x3f1c1f1c, 0x1c4f031c, 0x1c7f1c6f, 0x1cbf1c9f, 0x341c1c05, 0x90232f30, 0x23740123,
    0x01236b01, 0x23342324, 0x140e3a02, 0x24013490, 0x44143414, 0x94147414, 0x34230514, 0x23341414, 0x47290f03, 0x2a102a00, 0x2a2a0702, 0x203c103c,
    0x033c303c, 0x57830f10, 0x410f3521, 0x300806e5, 0x027f020f, 0x029f028f, 0x14400204, 0x34024817, 0x481d1540, 0x140c2034, 0x1e341b48, 0x1c290e03,
    0x14230f0f, 0x14361426, 0x0e301402, 0x333f0015, 0x05c75f33, 0x39171226, 0x2b2f2b2b, 0x2007fc41, 0x0fd25f01, 0x825d2f21, 0x53332027, 0x33310598,
    0x2f183311, 0x3338715d, 0xc0c0875d, 0x5d2b2b01, 0x2903822b, 0x3912115d, 0x312f2f39, 0x13420130, 0x5f03200c, 0x042123eb, 0x07f641ba, 0x50233123,
    0x29f75f04, 0x41a40521, 0xfa2107e4, 0x3003605c, 0x00014908, 0x0414fe7d, 0x00cb0598, 0x40540023, 0x0f5a1117, 0x10070110, 0x48120f40, 0xba181010,
    0x20600120, 0x20022070, 0x40c0ffb8, 0x480a061a, 0xaf252020, 0x5b050125, 0x21246618, 0x041d5f00, 0x135f0a0f, 0x001b1013, 0x33e13f3f, 0x4c06145e,
    0x5d270513, 0x2b2f3912, 0x4ce15d5e, 0x152005e5, 0x2306924a, 0x11231137, 0x08108e62, 0x6b19033a, 0x3b437bae, 0x1d76b076, 0x1525282d, 0xf0a410bb,
    0xa9574c9d, 0xc46ca2fa, 0x943f4e4f, 0x98512705, 0xdb8d89da, 0x09044e96, 0x62fd090d, 0xc66cd801, 0xa6aa1501, 0x6ec61401, 0x0808f95d, 0x14fe7135,
    0x5e046f03, 0x3e001f00, 0x471d2540, 0x110e401c, 0x041c1c48, 0x215f210c, 0x1002217f, 0x48150121, 0x1b205604, 0x161f5118, 0x51121b1c, 0x0010090d,
    0x83e1333f, 0x100128b5, 0x5d5de1f6, 0x8211ce10, 0x20ad82af, 0x077c4504, 0x45171621, 0xb8830c7b, 0xb0ed0128, 0x854c4a82, 0xc15d66b2, 0x909d2908,
    0x683e9491, 0x1412b723, 0x5d07fe44, 0x4e0806b5, 0xc3d3d3ca, 0x5afd141b, 0x0000d801, 0xff680001, 0x057904fa, 0x0113000a, 0x0d674025, 0x02111d11,
    0x011d010d, 0x120b0202, 0x0702020b, 0x07020712, 0x130c1110, 0x01000b12, 0x07020308, 0x0d040f04, 0x120a0c11, 0x0801090b, 0x05070206, 0x820d050e,
    0x0a11211e, 0x12212082, 0x21228209, 0x24820601, 0x04024408, 0x020b0c05, 0x4f0f0e01, 0x0b400101, 0x010b0501, 0x0b010f0f, 0x60120405, 0xf0117011,
    0xb8110311, 0x4d40c0ff, 0x11480a07, 0x15110708, 0x15301520, 0x00060302, 0x01070409, 0x0a130201, 0x0b040d10, 0x82121111, 0x0730080d, 0x0b0b0807,
    0x0c0b0b01, 0x0cc00cb0, 0x1f120f02, 0x08000212, 0x02020810, 0x0c0c0812, 0x04021208, 0x400e0f04, 0x0e480d07, 0x2f000405, 0x332b2f33, 0x20052155,
    0x05cf5c2f, 0x33117123, 0x8203832f, 0x82098214, 0x5d012105, 0x32270782, 0x335d2b2f, 0x822f3917, 0x825d2000, 0x3311210f, 0x10230183, 0x8dc0c087,
    0xc0082103, 0x10210185, 0x25078587, 0x3031c008, 0x58825e00, 0x05015d2a, 0x27032507, 0x05372513, 0x17210384, 0x080f8203, 0x014c0233, 0xe3fe471c,
    0xfeb481b4, 0x1f0146e5, 0x47e4fec6, 0x7fb61d01, 0x4a1f01b6, 0xb001e5fe, 0xfea47ba6, 0x3b014ac7, 0x01a47ba4, 0xa47da45a, 0xfe493901, 0x390c82c4,
    0xc9000100, 0xb0038f04, 0x1500b805, 0x0fb54200, 0x480a0720, 0xe0ffb803, 0x08821e40, 0x120c2808, 0x00001712, 0x20061006, 0xa0069006, 0x06070506,
    0x0f0f1606, 0x0303000b, 0x322f0000, 0x32cd102f, 0x3301112f, 0x825d5e2f, 0x332f29c1, 0x312b2b00, 0x06060130, 0x08065277, 0x3621332f, 0x16323336,
    0x23061415, 0x2c068b01, 0x09283830, 0x011d2517, 0x302d05c1, 0x392b2a38, 0x332cee04, 0x251c3833, 0x312d0916, 0x29393632, 0x26898200, 0x03e504f4,
    0x83d905df, 0x11403c89, 0x08900880, 0x17080802, 0x14101400, 0x07031420, 0xc0ffb814, 0x100d1240, 0x82141448, 0x09143454, 0x05bf400e, 0x09800501,
    0xdd1a2f00, 0x11cd1a5d, 0x83cd2f33, 0x5e2b228c, 0x200a825d, 0x2289825d, 0x83023e32, 0x1528087f, 0x26343523, 0x020e2223, 0x01352323, 0x77854e02,
    0x7c6d3a70, 0x2a2e3a85, 0x55917965, 0x24660510, 0x6c65242b, 0x2e341123, 0x81200882, 0x29088582, 0xd704e101, 0x3506d302, 0x20001100, 0x0e0b1240,
    0x064f063f, 0x3f000602, 0x5f034f03, 0x0f030303, 0x5dcc2f00, 0x5dcd2f01, 0x63823932, 0x0808b067, 0x16141524, 0x26261517, 0x3b44e101, 0x251f322f,
    0x7a3c391f, 0x39b60578, 0x1b262646, 0x1311111a, 0x4c152e19, 0x5d8b731f, 0x5d831320, 0x003f0729, 0x0002004f, 0x6e3f0e03, 0x03200617, 0x0d6e5d85,
    0x087c4a06, 0x2506a448, 0x7a78d302, 0x5748393c, 0xb6052808, 0x4c1f734d, 0x48192e15, 0x082e0b15, 0xc1fe2900, 0x9105c107, 0x27001300, 0x5f823b00,
    0x77006326, 0x9f008b00, 0x65567c82, 0x23072905, 0x32333636, 0x0317021e, 0x01200f8e, 0x21200f8e, 0x1fbf0f8e, 0x036f0435, 0x192e2418, 0x14212f1e,
    0x64054b03, 0x364d3167, 0x924f031e, 0xf4012313, 0x28821703, 0x212f1f27, 0x054c0313, 0x21288565, 0x14922ffb, 0x92310421, 0x20299514, 0x216882f0,
    0x5382192d, 0x68277c84, 0x1f364c31, 0x92bef903, 0xcf04313e, 0x0613231c, 0x1e231205, 0x331c685a, 0xf2f92b48, 0x59270f87, 0x47331d69, 0x8816012b,
    0x210f821f, 0x0d8d2b48, 0x8ddb0321, 0x210d8d0f, 0x0f8819fe, 0x4b836820, 0x27080d8d, 0x00080000, 0x077ffe29, 0x00d3057d, 0x0019000c, 0x00330026,
    0x004d0040, 0x0067005a, 0x0e170500, 0x3e230703, 0x27033703, 0x33200482, 0x012a0c82, 0x17031e37, 0x27032e15, 0x04820705, 0x0c823520, 0x82370121,
    0x2127831a, 0x1f820701, 0x03212783, 0x201a8227, 0x201a8337, 0x83048217, 0x37042e27, 0x201c0a0b, 0x0a611223, 0x05101215, 0x330c8b3b, 0x260e2302,
    0x27575755, 0x575b5d2a, 0x0e68fb25, 0x56575527, 0x03320c85, 0x502202a6, 0x45285654, 0x494e4f25, 0x02eafc1e, 0x0d884f23, 0x14112b33, 0x0f242729,
    0x34331743, 0x6a031732, 0x27281411, 0x240d8225, 0x16323434, 0x21428a23, 0x5c8a9804, 0x9816fe21, 0xaa012284, 0x224f8210, 0x83440f25, 0xfc16224f,
    0x210d8b95, 0x8683de02, 0x46285522, 0xe9208685, 0x0d878683, 0x02004f08, 0x7ffec900, 0x6807d305, 0x31001b00, 0x4840b300, 0x26301c1c, 0x0126d001,
    0x26cf26af, 0x30262002, 0x03268026, 0x0a172626, 0x181a1a19, 0x0007151b, 0x3365175a, 0xaf0133d0, 0x33200133, 0x13023330, 0x095a0c08, 0x9f263264,
    0x401c011c, 0x3e820906, 0x218e2c2d, 0x13fb1a05, 0xb3e8ffb8, 0x82481814, 0x40e03407, 0x48130a26, 0x13161306, 0x09031326, 0x005f1713, 0x82180612,
    0x2006211a, 0x09371682, 0x29061906, 0x06070306, 0x00030a16, 0x5e33333f, 0x3f2b2b5d, 0x833333e1, 0x2e078206, 0x335d2b2f, 0xe1f61001, 0x5d5d3232,
    0x82f4105d, 0x33332807, 0x11332f39, 0x822f3912, 0x33713110, 0x2130312f, 0x37363411, 0x01233736, 0x11331123, 0x09918418, 0x2303332b, 0x030e0313,
    0x022e2223, 0xac411827, 0x04ae0807, 0x04040564, 0x31fd0806, 0x0301aed7, 0x03040103, 0xd5cc0207, 0xa6da8fc3, 0x5d31069d, 0x8c67648d, 0xaa042a58,
    0x4c321c04, 0x37492b35, 0x19030622, 0x4c418f38, 0x0546fb4d, 0x1ae0fcb6, 0x1f44433e, 0xb4044c4a, 0xd9fdf0fa, 0x68078101, 0x2950774d, 0x50774f27,
    0x10294839, 0x35472c12, 0x00020000, 0x0483feae, 0x001706f2, 0x0025000f, 0x103a4096, 0x341a0410, 0x031a841a, 0x0b1a1a07, 0x0e0e0d05, 0x10090c0f,
    0x09481809, 0x0b460002, 0x27a42755, 0x27d427c4, 0x800427f4, 0x00020127, 0x20271027, 0x60275027, 0x06277027, 0xf0ffb803, 0x29822540, 0x0708033f,
    0x26540446, 0x01107f1a, 0x09064010, 0x20101048, 0x0e11158e, 0x050209fb, 0x08600b0f, 0x052a5f04, 0x333fe124, 0x2d413f33, 0x5d2b220c, 0x062f415f,
    0x30412b20, 0x5d5e2108, 0x29052e41, 0x11230113, 0x01071133, 0x23411133, 0x8f032f13, 0xeafefd0b, 0x04020cac, 0xb67bb7e9, 0x1941477a, 0x6d761814,
    0x64fd2e07, 0xfc9803fc, 0x01e9fd50, 0x4e17067d, 0xf1421876, 0x2c123609, 0x02003548, 0x00002f00, 0xb6053304, 0x21001600, 0x2c405200, 0x08096a13,
    0x2006e669, 0x08d2690e, 0x69008921, 0x032009cc, 0x680ecc69, 0xc66908da, 0x15c06905, 0x6906d768, 0x01210bc0, 0x0ac06981, 0xba989826, 0xc5fe3b01,
    0x2114be69, 0xbc69b2b2, 0x28b58209, 0x04000012, 0x00140619, 0x08b58214, 0x3b40613d, 0x1c0e0101, 0x23570847, 0x23bf236f, 0x23ff23df, 0x16000304,
    0x0e111247, 0x50152254, 0x500f0304, 0x04120012, 0x48240740, 0x0f01120f, 0x02121f12, 0x04120407, 0x16001312, 0x6a150e50, 0x71210991, 0x27c5872b,
    0x33c4f610, 0x5d3232e1, 0x1226cc82, 0x30312f39, 0xb3822101, 0x9f692120, 0x6911200d, 0x0125099d, 0xfe170164, 0x099f69e9, 0xb69c9c23, 0x089b6901,
    0x8921053a, 0x9b9ceffd, 0x2f587c4d, 0xf3899804, 0xa8fedafb, 0x30422911, 0x11284231, 0xc720c782, 0x3336c782, 0x1300b605, 0x88002200, 0x051b4f40,
    0x181a061a, 0x07071908, 0x01821906, 0x1e0c4a08, 0x3800285b, 0x03004800, 0xcf246700, 0x24400124, 0x01240f01, 0x5a0c1406, 0x1923640d, 0x1aaf1b18,
    0x141a1a01, 0x07b00622, 0x0c070701, 0x60140805, 0x0b400b30, 0x0c0b0b02, 0x030e6022, 0x3f00120c, 0x3911e13f, 0x39e15d2f, 0x20c78239, 0x0593435d,
    0x43393921, 0x5e2205ae, 0xe0825d5d, 0x12e15d27, 0x2f2f3939, 0x211b8311, 0x4c743239, 0x0e142b06, 0x07170702, 0x23230627, 0xe6822311, 0x021e4f08,
    0x36323301, 0x17372737, 0x34353636, 0x04232326, 0x4b2f1633, 0x816a6e36, 0xba967c5d, 0xc2866a01, 0x4efd3c7e, 0x1f442681, 0x33706d5c, 0xa0aea434,
    0x6f3a0a04, 0x9b205664, 0xfd1bb64e, 0x39b605c7, 0x67fea06d, 0x4c850505, 0x577324a0, 0xf782898e, 0xfeae4b08, 0x043f0414, 0x0023005e, 0x40720039,
    0x32353440, 0x202a3333, 0x371f1f1e, 0x1b2a2148, 0x3b303b57, 0x0c102a01, 0x3a540d47, 0x2f323533, 0x341f340f, 0x34cf346f, 0x34340704, 0x1050242f,
    0x0f0e1016, 0x0020201f, 0x1e211b0c, 0x8651502f, 0x20e38205, 0x23e4823f, 0x333f3f33, 0x5e21f383, 0x85d7825d, 0x823220e8, 0x391127e6, 0x392f39e1,
    0x04821133, 0x3133392e, 0x2e220530, 0x16232702, 0x15161617, 0x3328e182, 0x033e3317, 0x021e3233, 0x08640119, 0x0e220324, 0xbc4c0702, 0x82f78505,
    0x02ad08f6, 0x4d603b9e, 0x030c163c, 0xb6040203, 0x16081a94, 0x3c604d3b, 0x3c6e995e, 0x6a6d525a, 0x46411f75, 0x1f41694c, 0x6c411b02, 0x0f211151,
    0x546e6d6a, 0x2c19147f, 0x1f22203a, 0xfe10371a, 0x9436062b, 0x1b2d3e22, 0x8cd48f48, 0x9a44f2af, 0x0b09a64e, 0x5e2edb03, 0x65295e8d, 0x03376b9d,
    0x9e4c9805, 0xced0ee6a, 0x00010000, 0x0300002f, 0x00b605be, 0x4089000d, 0x2f051f15, 0x05050205, 0x1f000f08, 0x00900200, 0x00e000a0, 0xffb80003,
    0x071e40c0, 0x0000480a, 0x3f0f1f0f, 0xbf0f9f0f, 0x0703040f, 0x0a000c5a, 0x800a0601, 0x0208c008, 0x32228308, 0x480a0626, 0x5f090608, 0x2f0c0f03,
    0x4f0c3f0c, 0x820f040c, 0x0caf3006, 0x0cff0cdf, 0x0c0c0805, 0x0d5f0207, 0x18120703, 0x2a08ee44, 0x32e13371, 0x5d2b2f01, 0x825d5ec6, 0x05cf4d09,
    0x3912712b, 0x30315d2f, 0x11211501, 0x4f5b1821, 0xbe033708, 0x5001c3fd, 0x98bab0fe, 0xa6b60598, 0xfda215fe, 0xa283027d, 0xbd839102, 0xbd821220,
    0x4a040a22, 0x6e3ebd82, 0x0b0b1d40, 0x30062000, 0x06060206, 0xa00f700f, 0x030fc00f, 0x04470d09, 0x02ef02df, 0xc5830202, 0x1512b323, 0x08078348,
    0x06214022, 0x0c00480b, 0x4f094f01, 0x02045f04, 0x1c174004, 0x1b040b48, 0x04070204, 0x50080004, 0x15000f05, 0x2b20a588, 0xa6829c83, 0x87c62b21,
    0x825d20a5, 0x303125a3, 0x35231133, 0x83051e6e, 0x9cae3ca8, 0xfe5c029c, 0xfe17015a, 0x89e101e9, 0xfe9ae001, 0x1ffe89ba, 0xc7000100, 0x820400fe,
    0x003408b5, 0x40660026, 0x01150941, 0x05070707, 0x28125b22, 0x7f0128c0, 0x02288f28, 0x28402810, 0x0a1c1c02, 0x64055a04, 0x5f201d27, 0x60001c17,
    0x0d2f0d0f, 0x0f030d3f, 0xdf2d0482, 0x040dff0d, 0x050d0d08, 0x03065f09, 0x0a3b4105, 0x064fe120, 0x32f12905, 0x5d5d2fc0, 0xe1de105d, 0x00299484,
    0x22015d5e, 0x23110706, 0x4a948311, 0x5608059f, 0x020e1415, 0x022e2223, 0x16163527, 0x34112033, 0xfc01022e, 0xba1a3c25, 0xc3fdf702, 0x9a2d471d,
    0x5257a5f0, 0x3176c992, 0x1f3d444e, 0x01487f3f, 0xae7b4377, 0x05058302, 0xb60587fd, 0x050bfea6, 0xf2ab5c03, 0xa2f8aa97, 0x130c064f, 0x1817a20c,
    0xb979ef01, 0x8200407e, 0xae4a08db, 0xc5030afe, 0x23004a04, 0x39405c00, 0x22192209, 0x14032229, 0x480a1214, 0x250f251f, 0x5f02251f, 0xff257f25,
    0x03030325, 0x12471117, 0x00042454, 0x1a0b510d, 0x07021a1b, 0x16121a1a, 0x120f1350, 0x00510715, 0xe13f001b, 0x805d3f3f, 0x11e92105, 0x23054243,
    0x715d2f39, 0xd182d288, 0xbb842620, 0x35363225, 0x93232634, 0x023b08de, 0x2e6a4b29, 0x76426a2b, 0x1a9d9075, 0x02b61f3e, 0x1d5afe5c, 0xb3661f3b,
    0x6f404c85, 0x1f0afe96, 0x2518a11d, 0xcad4d2c3, 0x35fe080a, 0xfe9a4a04, 0x3e0505c3, 0x969ddb8a, 0x824088d5, 0xfe043cc7, 0x05cb067f, 0x001500b6,
    0x115740e2, 0x48181440, 0x13092011, 0x1a110a48, 0x83000211, 0x8400200e, 0x1a003c0e, 0x10070200, 0x5a020d0d, 0xa80a0a07, 0x0203b803, 0x8d010399,
    0x03570103, 0x82770367, 0x035e08e5, 0x00061203, 0x0f100f0e, 0x48180c40, 0x150f110f, 0x0112045a, 0x12841274, 0x120312c4, 0x40c0ffb8, 0x480a0727,
    0x04171212, 0x17f00117, 0x0117e401, 0x020117a0, 0x17301720, 0x17701760, 0x0f051790, 0x09080117, 0x06080508, 0x40f0ffb8, 0x16060613, 0x0a0dfb13,
    0x080f000a, 0x5f11030b, 0x4e680305, 0x3fe13505, 0x39123333, 0x113f3311, 0x382f3301, 0x33113333, 0x5f5d5d5e, 0x3006b25b, 0xe1715d2b, 0x2b2f3333,
    0x11323338, 0x5f2f3912, 0x8200825d, 0x32e12121, 0x2b332583, 0x2b2b5d2b, 0x01213031, 0x01112311, 0x33010123, 0x82331101, 0x82088244, 0xae053c10,
    0xfdb3eefd, 0x2102d3ee, 0x02cdedfd, 0x0a02b30a, 0x01edfdcd, 0x02b0c3a8, 0x841bfde5, 0x02f22403, 0x873cfdc4, 0xfd2e0803, 0x01d9fdb4, 0x01000081,
    0x83fe0400, 0x4a040406, 0x11011500, 0x10276c40, 0x29021037, 0x020e390e, 0x09360926, 0x370a2702, 0x0427020a, 0x04860437, 0x01370123, 0x1d5e4102,
    0x0d0d1037, 0x0a074602, 0x0103cd0a, 0xa90103b9, 0x03960103, 0x01038701, 0x095a4103, 0x5a410a20, 0x12462805, 0xb3c0ffb8, 0x83481512, 0x17403807,
    0x12480b07, 0x17101712, 0x01170001, 0x17f417e4, 0xc417b402, 0x82170217, 0x13402f23, 0x3048110d, 0x20020117, 0x170f0117, 0x60410701, 0x110f2415,
    0x49030560, 0x60410939, 0x5d2b2512, 0x1171715d, 0x4105bf62, 0x5d200e61, 0x20066241, 0x0661415d, 0x5d5d0024, 0x00835d01, 0x3c156a41, 0x43fef004,
    0xcf44fea4, 0x58fecf01, 0xa49f01c5, 0xfec5a001, 0xc54f0158, 0xfd2d02ae, 0x240384d3, 0xfd150235, 0x080387eb, 0xfd65fe2a, 0xff7d01e9, 0xfe4800ff,
    0x05ec0342, 0x012602cb, 0x010000b1, 0x017f0307, 0x00000048, 0x0101b111, 0xb4ffffb8, 0x0b134248, 0x8206b35c, 0x8244202b, 0x0452222b, 0x202b825e,
    0x212b85d1, 0x2b88f200, 0x2b82f820, 0x86212921, 0x0024082b, 0xfec70001, 0x05ec047f, 0x001000b6, 0x055940a6, 0x48181440, 0x05cd05bd, 0x050305dd,
    0x48100920, 0x052a051a, 0x27050443, 0x00cd00bd, 0x000300dd, 0x003c1584, 0x0602002a, 0x0e081010, 0x0f7f100f, 0x00020f9f, 0x400f300f, 0x0f06030f,
    0x5a04050f, 0x103a7282, 0x01070201, 0x12b01201, 0x5a080c01, 0x0c116409, 0x40f0ffb8, 0x48100b16, 0x04821006, 0x09060c3a, 0x00030a0f, 0x0905055f,
    0x00fb0212, 0x2f333f3f, 0x12333fe1, 0x2b2b3939, 0x2a08af6d, 0xe1335d5e, 0x5e2f3332, 0x82385d5d, 0x33112319, 0x01852b5d, 0x25303129, 0x11231133,
    0x82070123, 0x11333f05, 0x01330137, 0xb1b73504, 0x8b3dfe6c, 0x0179baba, 0xf8fdd1c4, 0x01d9fda6, 0x72ba0281, 0x2d19b8fd, 0x012f091e, 0x83feae00,
    0x4a042b04, 0x99000e00, 0x84086a40, 0xcd0826e7, 0x0308dd08, 0x24d18408, 0x02082a08, 0x26158403, 0xdd03cd03, 0x84030303, 0x033f0815, 0x0802032a,
    0x01004607, 0x01860176, 0x01016d02, 0x2b010155, 0x4b013b01, 0x01140301, 0x01010b01, 0x00010306, 0x02041004, 0x0e100404, 0x0b470a02, 0x02090f54,
    0x0b000e0e, 0x15085003, 0x600cfb05, 0x3f2105ca, 0x44c284e1, 0x322505dc, 0x5d2f3311, 0x05066c33, 0x115d5d22, 0xda89e582, 0x0120cc82, 0xdc84dd85,
    0xc4fa0238, 0x4b0161fe, 0xfe66aec1, 0x04b4b44b, 0xfef1fd4a, 0x01e9fd5f, 0x8118027d, 0x48080937, 0x040000c7, 0x00b605a2, 0xb9970012, 0xe0ff0f00,
    0x15125d40, 0x600f5048, 0x0f22020f, 0x0f420f32, 0x09400203, 0x070b480d, 0x1234085a, 0x12021254, 0x0103570f, 0x041d0c03, 0x01040b01, 0x08000404,
    0x11101364, 0x10000111, 0x08028200, 0x00070220, 0x14b01400, 0x01142f01, 0x0b011410, 0x20080905, 0x40043004, 0x0d040304, 0x09100d04, 0x65820803,
    0x3f323f2e, 0x2f393933, 0x12115d2f, 0x5d013939, 0x2408c083, 0x385d5e2f, 0x33113333, 0x3911e610, 0x335d5d2f, 0x32325dc1, 0x32e1105d, 0x2b003031,
    0x212b5d5d, 0x23150123, 0x06ad4111, 0x15331122, 0x3c08e382, 0xfed3a204, 0xba7785ae, 0x018577ba, 0xf8fdd141, 0x01cdf401, 0xd7fd6264, 0x06fdb605,
    0xb36301a4, 0x65fda601, 0xae000100, 0x23040000, 0x13004a04, 0x11b59c00, 0x48110b40, 0xc0ffb80a, 0x080782b3, 0xffb80e52, 0x085740f0, 0x0a0e480d,
    0x12011226, 0x99138907, 0x0313a913, 0x132f131f, 0x0b03133f, 0x13130113, 0x4702060f, 0x0b145403, 0x0f100c0c, 0x300f2010, 0x0f0f020f, 0x10150015,
    0x15000215, 0x15601540, 0x15a01580, 0x15e015c0, 0x0d0e0707, 0x13080606, 0x022b0182, 0x100f040b, 0x3f001502, 0x82333f33, 0x2f2f2ddc, 0x33113912,
    0x5d5e0133, 0x2f331171, 0xf622e286, 0x684e32e1, 0x20e58405, 0x28e2832b, 0x1127012b, 0x11331123, 0x24db8237, 0x15013313, 0x08ef8301, 0x6dcf0127,
    0x7d6db4b4, 0x50fec5eb, 0xfecfd701, 0xb2017df8, 0x04d3fd7b, 0x7bebfd4a, 0x01b94601, 0x4916fe0d, 0x2701e9fd, 0x057f49cd, 0xa2042708, 0x1400b605,
    0x40408500, 0x14661402, 0x04131401, 0x0e500e40, 0x000e0e02, 0x5a040c10, 0x64050709, 0x10131215, 0xa7411313, 0xb0163b0a, 0x162f0116, 0x01161001,
    0x0c5f060f, 0x02000909, 0x48100b10, 0xf0ffb810, 0x08830c40, 0x12050225, 0x4105030a, 0xcd8206b0, 0x822b2b21, 0xe13322b7, 0x0bb24132, 0x33382f25,
    0x82c6f610, 0x28d38414, 0x5d391211, 0x30313311, 0x055a4321, 0x22053d4d, 0x43231533, 0xa22a0562, 0x8b3dfed3, 0xba9898ba, 0x6443d5d5, 0xba023105,
    0x04b8fd72, 0xb2b2a460, 0xa87bfea4, 0x83fd3302, 0x2208cb82, 0x03000012, 0x001406f0, 0x40840016, 0x0e0e110f, 0x0908040f, 0x14471303, 0x06010600,
    0xb3c0ffb8, 0x83481510, 0x403a0807, 0x480e0935, 0x160f0606, 0x17541401, 0x0d100d0c, 0x0f35100f, 0x100f0001, 0x030f200f, 0x180f0f08, 0x0901180f,
    0x14140211, 0x4f15070f, 0x02010104, 0x0f0c150f, 0x3f000002, 0xc5853f3f, 0x20053f4c, 0x44af8201, 0x33210520, 0x21c98211, 0x1c82c632, 0x712b2b28,
    0x3217e110, 0xca833911, 0x3533132f, 0x15211533, 0x33031121, 0x01330137, 0x08d98601, 0xb49c122e, 0x85fe7b01, 0x01870410, 0x6ffed325, 0xfed1ac01,
    0x9cb46db0, 0xb6b65e05, 0xfe75fe89, 0x6901aaed, 0x91fd25fe, 0xfe52f801, 0x00d5045a, 0x143dd782, 0x44050000, 0x0e00b605, 0x33405700, 0x0d0e0e02,
    0x205a040a, 0x40053005, 0xf0058005, 0x24008205, 0x0d0c0700, 0x0a9e410d, 0x1010102a, 0x050a0201, 0x085f070c, 0x24078541, 0x391233e1, 0x21b28639,
    0xb1823338, 0xae822f20, 0x86e15d21, 0x067541aa, 0x21352123, 0x2aaa8311, 0xfed34405, 0xfebb8b3d, 0x410f02ac, 0x05240a6e, 0x25fda412, 0x08076b41,
    0x00002940, 0x4a04c904, 0x67000d00, 0x0d024040, 0x47060b0d, 0x00010700, 0x20071007, 0xc0076007, 0x07080507, 0x00090307, 0xf501d501, 0x04010201,
    0x03001003, 0x03020310, 0x0f400f03, 0x0f020fe0, 0x3382010f, 0x50090727, 0x070f0a00, 0x05f44203, 0x3912e127, 0x5d013311, 0x06ee425d, 0xa2820783,
    0x715d5e29, 0x113232e1, 0x41303133, 0x11220542, 0xa5821123, 0x11076908, 0xfec5dd03, 0xcfc70160, 0xfeb54cfe, 0x021f0298, 0xf1fd4a04, 0x2d02c5fd,
    0xb003d3fd, 0xedfd029a, 0x00010000, 0x057ffee5, 0x00b605a4, 0x4063000f, 0x045a043f, 0x01740101, 0x01940184, 0x11010103, 0x005a050d, 0xf411e411,
    0x11c00211, 0x11100201, 0x11401120, 0x0c041180, 0x64095a08, 0x0f5f0710, 0x0c08010c, 0x0a0e050c, 0x5f21c382, 0x05264605, 0x3f33e123, 0x20918433,
    0x052646e1, 0x5d5d5f26, 0x32e1dc10, 0x7121af83, 0x071846e1, 0xa06e1120, 0x33112d06, 0xb0b0f404, 0xbb67fdbb, 0xbb9902bb, 0x20051346, 0x05676eaa,
    0x82680221, 0xfeae269b, 0x04db0483, 0x3a9b824a, 0x08524079, 0x0b044700, 0x0f0b0b01, 0xd40cc447, 0x0c0c020c, 0x24110411, 0x83d40211, 0x82b0209e,
    0x8230209e, 0x8250209c, 0x9026089e, 0x0611a011, 0x04470307, 0xfb0d1054, 0x07eb5002, 0xb907a901, 0x070f0207, 0x072f071f, 0x07070603, 0x0f050900,
    0x8551500b, 0x86e12005, 0x5d5d23ad, 0xb0883fe1, 0xad837120, 0x2f33e128, 0x3132e15d, 0xac892130, 0x1133112f, 0x85031123, 0xb6b6dffd, 0xa0b62102,
    0x09e572b6, 0x82054d51, 0x00e536b1, 0x05480600, 0x000d00b6, 0x093b405d, 0x00005a01, 0x010b4005, 0x21b782e0, 0x3e43200f, 0x30210805, 0x600f400f,
    0xb00fa00f, 0x080fe00f, 0x5a040806, 0x0d0e6405, 0x060a0a5f, 0x080f5f03, 0x08080801, 0x078d4206, 0x5e2f3924, 0x8a82e15d, 0x29054941, 0x10715d5e,
    0x11715dc6, 0x95842f39, 0x96882320, 0x21152124, 0x4341f404, 0x0f022406, 0x4102acfe, 0xa4210841, 0x05a14500, 0x04a40523, 0x3391824a, 0x08214068,
    0x09054704, 0x00004701, 0x0e54050b, 0x000f0b0b, 0x02219582, 0x088b8290, 0xd00fc032, 0x050ff00f, 0xc0ffb80f, 0x0c071f40, 0xeb500348, 0x08a90108,
    0x0f0208b9, 0x2f081f08, 0x08060308, 0x0a0d0008, 0x00050f06, 0x323f0015, 0x12c4333f, 0x5d249e83, 0x2b01e15d, 0x33239482, 0x84e6102f, 0x92102099,
    0xb63b219c, 0x23053141, 0x97fe1f02, 0x20093241, 0x089b829a, 0x00fec72e, 0xb605db07, 0x5f002700, 0x0b093a40, 0x12120701, 0x215a2000, 0x5b182521,
    0x296f2908, 0x255a2401, 0x601d2864, 0x032f030f, 0x0f03033f, 0xdf3c0482, 0x0403ff03, 0x25030308, 0x03265f23, 0x13122521, 0x1c0d5f16, 0x33e13f00,
    0xe13f333f, 0x71299284, 0xf61001e1, 0xde105de1, 0x279084e1, 0x30312f39, 0x015d5e00, 0x2317684d, 0x11072223, 0x29054b41, 0x1ec10421, 0xf09a2e49,
    0x6b4d56a5, 0x3d433505, 0x497e3f1f, 0x7c437701, 0x334b6bae, 0xba7bfdbb, 0x1b03fa03, 0x26166b4d, 0x0589fd0c, 0x82eefa12, 0x015808cb, 0x0afeae00,
    0x4a047506, 0x77002400, 0x230b4e40, 0x0302231b, 0x47111903, 0xc2011202, 0x12a60112, 0x770212b6, 0x02128712, 0x0a161212, 0x0f262048, 0x02261f26,
    0x265f264f, 0x26ff26af, 0x01261004, 0x54164715, 0x0b510d25, 0x021b1b1b, 0x161b1b07, 0x0f175014, 0x04151612, 0x8906884d, 0x21e885e9, 0xea85715d,
    0x5d5d5d25, 0x8432e171, 0x158e4dee, 0x4c18e684, 0x04210844, 0x098f4dd9, 0x1f3e1c2a, 0xb608feb6, 0x3f3a6403, 0x28158f4d, 0x50fcb003, 0x27fe4a04,
    0x08914d0c, 0x00026608, 0x05acff7d, 0x00cd0596, 0x0052003e, 0x0550407a, 0x0432104e, 0x005b4900, 0x02201020, 0x20352035, 0x005b3f18, 0x540f5467,
    0x544f541f, 0x547f545f, 0x54af549f, 0x5b2b0707, 0x44536618, 0x00054e60, 0x203a103a, 0x703a603a, 0x063a803a, 0x26073a3a, 0x041d215f, 0x5f303210,
    0x0e5f0713, 0x0013130e, 0xe12f333f, 0x28d08210, 0x12e1333f, 0x395d2f39, 0x20ee8439, 0x3aa2185e, 0xe15d3608, 0x31391712, 0x0e140130, 0x33160702,
    0x15373632, 0x22230606, 0x10046527, 0x6e032e21, 0x3721097d, 0x084f6326, 0x2e340723, 0x08188702, 0x033e17ee, 0x41276f05, 0x51362d55, 0x1d1f4625,
    0x8ba6264f, 0x963c7c32, 0x4d519de8, 0x42a6f29e, 0x0a352578, 0x15333028, 0x336ca976, 0x64a0703c, 0x5b4f2630, 0x4c836037, 0x3962854b, 0x3d2a16c5,
    0x293d2927, 0x36291815, 0x2e422a1f, 0x65a60218, 0x246f90af, 0xaa0b0e19, 0x11620c0d, 0x01c06a11, 0x01b5a50e, 0x1669c71f, 0x0a059c0f, 0x9a510509,
    0xda948dde, 0x69074690, 0x859b1601, 0x383b7bc1, 0x5495c67b, 0x37366389, 0x48508762, 0x27657685, 0x88776221, 0x00020000, 0x04c5ff71, 0x005e04a4,
    0x004d000d, 0x44494079, 0x04321105, 0x5448003f, 0x02216421, 0x21352135, 0x3f480819, 0x573f4a4a, 0x8b4f7b4f, 0x034fbb4f, 0x4f6f4f5f, 0x014f1b02,
    0x07014f0f, 0x19482a02, 0x440b4e56, 0x473a3a05, 0x1e225025, 0x2f321110, 0x50471450, 0x16140e0e, 0x2d0a5a41, 0x2f3912e9, 0x01c13939, 0x5fe1f610,
    0x00825d5e, 0x32e61025, 0x78e1102f, 0x60410530, 0x021e2107, 0x2306e553, 0x22010622, 0x200d9764, 0x0d646616, 0x26373627, 0x3e343526, 0x05395302,
    0x07020e23, 0x07994116, 0xdd029208, 0x152a2014, 0x3d384839, 0x4c01413e, 0x28398845, 0xb3754762, 0x783c3f7a, 0x524279b4, 0x4a13291a, 0x4370542a,
    0x6e431e1c, 0x03322550, 0x55314a39, 0x6f404172, 0x341e2e52, 0x37142745, 0x1c391a1d, 0xf4014219, 0x394b5c35, 0x6b962812, 0xfd7a7a67, 0x11252a68,
    0xcc975717, 0x97d68375, 0x96061053, 0x6f3a1005, 0x945967a0, 0x02083c6b, 0x5e77b442, 0x272b5988, 0x46638a56, 0x1b4d6378, 0x08060d0a, 0xff070993,
    0xfe7d00ff, 0x05980442, 0x002602cb, 0x05754d26, 0x002f022d, 0xb70e0000, 0x32750101, 0x4d20182c, 0x27820572, 0x42fe712a, 0x5e046f03, 0x46002602,
    0x01212785, 0x24278671, 0x05282e52, 0x0827850d, 0x00010057, 0x047ffe14, 0x00b60512, 0x406f000b, 0x010d1f39, 0x5f010de0, 0x020ddf0d, 0x0d300d20,
    0x04030d40, 0x1f010f5a, 0x01070201, 0xef0aaf01, 0x0a0a020a, 0x40065a0b, 0x0207e007, 0x0801070f, 0x06570707, 0x06770667, 0xffb80603, 0x070f40c0,
    0x0b06480a, 0x03085f07, 0x084b4700, 0x32e13f31, 0x5d2b2f01, 0x5d5e2f33, 0x32e1105d, 0x82395d2f, 0x5de12409, 0x47715d5d, 0x35370949, 0x02211521,
    0xbbb0b071, 0xfe035efe, 0xfda65ffe, 0x058101d9, 0x82a4a412, 0x290027b6, 0x5e0383fe, 0x9d844a04, 0x0df04d39, 0x010daf01, 0x0d500d40, 0x010d2f02,
    0x08af470b, 0x08cf08bf, 0x82400803, 0x08330878, 0x0105df08, 0x8f01059d, 0x05050105, 0x60004707, 0xd0027002, 0x021f0302, 0x00020201, 0xb0001000,
    0x0400c000, 0x06fb0900, 0x0f035002, 0x15005007, 0x82e13f00, 0x183f209c, 0x820a568b, 0x82392095, 0x259d83ab, 0x2130315d, 0x98832111, 0x11331138,
    0x68011123, 0x3503c1fe, 0xb69fc1fe, 0x9a9ab003, 0xe9fdeafc, 0x956d7d01, 0x05372707, 0x000602b6, 0xad83003c, 0x14fe0024, 0xad82d503, 0x7c001336,
    0x0a0a1340, 0x01a64700, 0x97018701, 0x01010201, 0x10121103, 0x080c4e50, 0x0b072042, 0x15121248, 0xdf0115f0, 0x0215ef15, 0x15901550, 0x4f0315a0,
    0x15300115, 0x01150f01, 0xffb80304, 0x031040f0, 0x050f0311, 0x020a150a, 0x020a1307, 0x001b0015, 0x33333f3f, 0x333f5d5e, 0x33382f01, 0x0282b082,
    0x2f331129, 0x33382b2b, 0x722f3912, 0x312205ed, 0xb1820130, 0x13333908, 0x3317031e, 0x1337033e, 0x46020133, 0xbc71feb7, 0x1b2010c7, 0x04070514,
    0x10201b15, 0x71febcc7, 0xe80114fe, 0xcffd4e04, 0x4f5e642e, 0x5e4f1919, 0x31022e64, 0x0100b2fb, 0x0021c982, 0x08d58204, 0x0010002e, 0xef19409f,
    0x40120112, 0x00480c09, 0x5a080400, 0x96090d09, 0x09770109, 0x06020987, 0x40c0ffb8, 0x4818150d, 0x0606090b, 0x02030b09, 0x0805b364, 0x0fab383c,
    0x010f9001, 0x0f010f14, 0x10100201, 0x02ef0102, 0x0102d001, 0x800102bf, 0x024f0102, 0x1402025f, 0x02000102, 0x02020701, 0x5f0a0712, 0x0d0d0004,
    0x0f120801, 0x3f000301, 0xc2823f33, 0xe1333928, 0x33011132, 0xdb855e2f, 0x38715d23, 0x20d68233, 0x2ede825d, 0x2f2f3917, 0x5d5d2b2f, 0xe1103311,
    0x823d3932, 0x23e8820a, 0x15013301, 0x0805c255, 0x21352128, 0x02330135, 0xc854011b, 0x270142fe, 0xfebbd9fe, 0xfe2601da, 0xd302cb42, 0x83fce302,
    0xa8fea43d, 0x33a45801, 0xa7418703, 0x0019310b, 0x0e154085, 0x4701170e, 0x0102a606, 0x02970287, 0x07230082, 0x77101615, 0x37080cb2, 0x480b0720,
    0xf01b1616, 0x1bdf011b, 0x50021bef, 0xa01b901b, 0x1b4f031b, 0x011b3001, 0x08011b0f, 0xf0ffb807, 0x15071340, 0x03000f07, 0x150e054f, 0x0e07020e,
    0x01150617, 0x2107ac41, 0xae4132e1, 0x82ec8217, 0x303125c9, 0x11231105, 0x0120c082, 0x2a0bb441, 0x46021521, 0x01f6feb7, 0x4173fe08, 0x012910ba,
    0x9dfe890a, 0x04896301, 0x0ebe414a, 0x89b62b08, 0x00000100, 0xb4047ffe, 0x0f00b605, 0x88400601, 0x48010f47, 0x0f030109, 0x05060b00, 0x070e070a,
    0x090b000c, 0x0d080a05, 0x12820c08, 0x82090021, 0x05320814, 0x030f0c09, 0x080e0606, 0xaa01050a, 0xca05ba05, 0xfa05ea05, 0x30050505, 0x05480e0b,
    0x0d015a04, 0x0e0b100e, 0xbb0eab01, 0xeb0ecb0e, 0x050efb0e, 0x1982400e, 0x000a0e2f, 0xba00aa01, 0xea00ca00, 0x0500fa00, 0x082d8300, 0x04000e3e,
    0x02011401, 0x11010107, 0x11e411d4, 0xc00311f4, 0x20020111, 0x02114011, 0xc0ffb811, 0x14100b40, 0x01110f48, 0x070a0a0b, 0xf0ffb808, 0x28081440,
    0x0c270106, 0x05060c01, 0x07030a0d, 0x28093544, 0x12333f33, 0x5d5d3939, 0x057c5401, 0x5d2b5d24, 0x864d5d5f, 0x33332505, 0x2f715d2b, 0x38240382,
    0x32e11033, 0x11300782, 0x2f3d3912, 0x87103317, 0xc004c00e, 0x0ec08710, 0x08220482, 0x058608c0, 0x37820120, 0x5408cb51, 0x4308058f, 0x03013301,
    0x77b0b6fe, 0x91fe9efe, 0xfec501bc, 0x4c01c65a, 0xfebe4e01, 0xd9fda65b, 0x7b028101, 0xfc0285fd, 0xd1fdba02, 0x4cfd2f02, 0x00010000, 0x0483fe23,
    0x004a041f, 0x4039010f, 0x010d5925, 0xb4010356, 0x203ab282, 0x3d48110e, 0x0c29010c, 0x1b0c0b01, 0x0b0c020c, 0x03000846, 0x0d0d0306, 0xda830401,
    0x15714508, 0x04b54818, 0xa9049901, 0x046a0204, 0x048a047a, 0x55044503, 0x04060204, 0xdb050401, 0xfb02eb02, 0x02c90302, 0x0102bb01, 0x02a60296,
    0x75026502, 0x03028502, 0x025a024a, 0xdf010202, 0xff05ef05, 0x40050305, 0x3b3a6382, 0x02054b05, 0x0a010527, 0x02051a05, 0x01440134, 0x01012802,
    0x01150105, 0x06820502, 0x073b0f24, 0x8a830701, 0x08075408, 0x40c0ffb8, 0x480c0749, 0x60110808, 0x90118011, 0xd011b011, 0xf011e011, 0x0edb0711,
    0x010ec901, 0x65010eba, 0x850e750e, 0x0e4a030e, 0x09020e5a, 0x3b0e010e, 0x020f4b0f, 0x05010f28, 0x020f150f, 0x010d030f, 0x0c50070e, 0x04fb0915,
    0x3f000f01, 0x4e3f3f33, 0x2f24054c, 0xc55d5d5d, 0x2a068e43, 0x2b2f3311, 0x125d2b33, 0x832f3939, 0x22158216, 0x86105d2b, 0x2007861c, 0x0690412b,
    0x8432e121, 0x30312a1d, 0x015d5d00, 0x13133301, 0x05045633, 0x01232c08, 0x98012301, 0xfacf9ffe, 0x9dfecffa, 0xaeaa0f01, 0xfef4fe65, 0x3302cff2,
    0x66fe1702, 0xe9fd9a01, 0xe9fd67fe, 0xb4017d01, 0x46004cfe, 0x0633059f, 0x00b60560, 0x4094000f, 0x045a010d, 0x105a0804, 0x82d00105, 0x08f183fd,
    0x12074444, 0x11050548, 0xa00111df, 0x110f0111, 0x114f112f, 0x0704118f, 0x0e200e10, 0x0e500e40, 0x0e800e60, 0x000e0e06, 0x0b0f095a, 0x0b2f0b1f,
    0x0b6f0b5f, 0x08060baf, 0x09300b0b, 0x09500940, 0x09900980, 0x48830905, 0x0a071123, 0x30248248, 0x030c025f, 0x095f0004, 0x00fb0612, 0x32e13f3f,
    0x063e5a3f, 0x5e2f3322, 0x2005bf46, 0x2fd5825e, 0x2b2f3311, 0x33e1715d, 0x3031e12f, 0x33112125, 0x23210182, 0x062f4611, 0x02710228, 0xb0b0ba85,
    0xcc4606fc, 0x10052106, 0x2305b85f, 0xa4a41205, 0x2926cd82, 0x6d0583fe, 0xcd824a04, 0x0bb68028, 0x020e0e47, 0x7d820f47, 0x180eb323, 0x2a078348,
    0x0b073340, 0x110f0f48, 0x841f110f, 0x82bf20ca, 0x07062ed8, 0x08e00860, 0x080308f0, 0x03470a08, 0x061a421f, 0x0300052a, 0x03600310, 0x03040370,
    0x142fbd84, 0x09034818, 0x060c5005, 0x500a0e0f, 0x8f001503, 0x83bc87bd, 0x852b20ba, 0x880120b9, 0x82bb82b3, 0x6d0524c3, 0x46b2fcb7, 0x012705e7,
    0xfea0b6f8, 0x467d0183, 0x032405ed, 0x0050fcb0, 0xa63ebb82, 0x31057ffe, 0x1d00b605, 0x12406300, 0x0d1b0d0b, 0x5a041a02, 0x1da01d90, 0x031d1d02,
    0x8783005a, 0x072c2b08, 0x00004810, 0x1f1f0f1f, 0x4f1f2f1f, 0x7f1f5f1f, 0xbf1faf1f, 0x1207081f, 0x1e640f5a, 0x0a1a5f15, 0x101b040a, 0x045f1d03,
    0xa2840112, 0x12333f25, 0x4b332f39, 0x9c830618, 0x2307b44e, 0x2311255d, 0x0e260182, 0x2e222303, 0x4f183502, 0x37200883, 0x05350982, 0x3abab031,
    0x31616369, 0x3565925d, 0x2d7b69ba, 0x38665e5a, 0x05be43ba, 0x22165636, 0x5e310c16, 0x4702598b, 0x7473d1fd, 0x141e140a, 0xf0fac602, 0x2308bd82,
    0x0483fe9a, 0x004a049e, 0x4061001c, 0x1b090b17, 0x03092b09, 0x47001507, 0x471c1818, 0x19101900, 0x19031920, 0x2208c283, 0x48150e25, 0x0f1e1919,
    0x7f1e5f1e, 0xcf1ebf1e, 0x470e051e, 0x1a1d540b, 0x501015fb, 0x16000606, 0x48180f0c, 0xba83063d, 0x3f33e127, 0xe1f61001, 0x20ba835d, 0x27bb825d,
    0x303132e1, 0x11215d5e, 0x3323b78a, 0x83023e32, 0x823320b6, 0x480334ce, 0x5e55502c, 0x527a4e3a, 0x2db8b62b, 0x2a4d4c50, 0x18b7a0b6, 0x280baa91,
    0x0fae66fe, 0x011d2b1c, 0x088f4fd5, 0x00a65808, 0x05810400, 0x001d00b6, 0x0b2e4070, 0x02041b04, 0x041d0f1c, 0x020e140e, 0x060e0e07, 0x165a1713,
    0x1f701f65, 0x2f021fa0, 0x1f10011f, 0x605a0901, 0xa0067006, 0x0406b006, 0xc0ffb806, 0x0a071640, 0x100e0648, 0x1b131d0e, 0x5f0c031d, 0x14170101,
    0x12170307, 0x843f3f00, 0x331726be, 0x2f32322f, 0x06f64801, 0x3227c982, 0x5e2f3911, 0x82c1335d, 0x015d21c7, 0x250a7b41, 0x11331133, 0xc7833636,
    0x06112329, 0x23110706, 0x41215002, 0x0c2c067f, 0x44763885, 0x7742baba, 0xfc018539, 0x08097b41, 0xfe580121, 0x192209b4, 0x4afac602, 0x251a5602,
    0x00c9fe0b, 0x009a0001, 0x04fe0300, 0x001c004a, 0x8442406b, 0x072308cd, 0x501c0e1b, 0x0d04010d, 0x0d240d14, 0x0d0d0803, 0x5a161206, 0x101e5515,
    0x801e601e, 0x5a09031e, 0x4a1d5406, 0x0d28068b, 0x121c0d0f, 0x0b031c1a, 0x1625c682, 0x160f0713, 0x74c68d15, 0xc48805f3, 0x5e23c585, 0x8930315d,
    0x913320c8, 0x2f0e21c7, 0x08058e41, 0x2f7d0627, 0xb6b6335b, 0x7d325932, 0x542f6a01, 0xa6014473, 0x01ae66fe, 0x0ee5fe2d, 0xd5012330, 0xe901b6fb,
    0xff103323, 0x57c58200, 0x3a08070f, 0x40500017, 0x14070436, 0x0c070207, 0x19650b5a, 0x195f192f, 0x198f196f, 0x19af199f, 0x19ef19cf, 0x100919ff,
    0x16020119, 0x1864175a, 0x005f1015, 0x02051005, 0x0b170505, 0x83030012, 0x2f3923b9, 0xae57e15d, 0x755d2005, 0x002505a6, 0x33135d5e, 0x06e84f11,
    0x23113308, 0x23263411, 0x07020e22, 0xbac72311, 0x5d62c373, 0xbb356592, 0x5a2d7b68, 0xba38655f, 0xaafdb605, 0x5e312d2d, 0xb8fd598a, 0x75732f02,
    0x141e140a, 0x2d5139fd, 0x04240805, 0x004a0412, 0xb93f0018, 0xe0ff1400, 0x0a072240, 0x18470048, 0x1aef1a55, 0x601a1001, 0x031a801a, 0x0a47090d,
    0x07749418, 0x510a0f21, 0x3921050f, 0x238b8e2f, 0x3411212b, 0x11227e86, 0x4c601133, 0x03112206, 0x06b7425c, 0xc942b620, 0x016b0808, 0x1c0fae9a,
    0x2bfe1c2c, 0x16fe4a04, 0x11202f1f, 0x4473532f, 0x02005afe, 0xecff3d00, 0xcd050606, 0x36002b00, 0x3e406400, 0x0b145b32, 0x380f3867, 0x2902381f,
    0x22012220, 0x5b0c3122, 0x801f7000, 0x031fc01f, 0x0c1f371f, 0x2b4f3160, 0xaf2b0f01, 0x032bff2b, 0x0801250f, 0x252b252b, 0x145f1105, 0x5f2c131a,
    0x3f000405, 0x4d333fe1, 0x5e3905d8, 0x33715d5d, 0x100132e1, 0xe1325dd6, 0x5d2f3332, 0xf6105dc1, 0x3031e132, 0x2ca68301, 0x15121616, 0x031e2115,
    0x37363233, 0x05884315, 0x2227eb08, 0x36343526, 0x06063337, 0x01331415, 0x07020e22, 0x022e3421, 0x5b0a6601, 0x998ddd9c, 0xfc3e88d6, 0x743f0725,
    0xcf8070a9, 0x695b2a5b, 0xeb984c7c, 0x8f095ca4, 0x9c0b129a, 0x02670f06, 0x6e955b89, 0x12030741, 0x038b5625, 0xabf49a39, 0xfec56b5b, 0x7a45abeb,
    0x2c4786c2, 0x1a0faa20, 0xb3610a12, 0x7a759bfd, 0x0f17422a, 0x0161233e, 0xb97e41f0, 0x80b87578, 0x02000043, 0xecff3300, 0x5e04b604, 0x35002c00,
    0x2b408400, 0x1e274831, 0x37ff3757, 0xb0379001, 0x371f0237, 0x3002377f, 0x0f05481f, 0x080108df, 0x05001308, 0x05200510, 0x50054003, 0xb8050205,
    0x2840c0ff, 0x05481310, 0x501f0536, 0x2b121b30, 0x120f0212, 0x2b0b1b01, 0x0b0f020b, 0x0b120601, 0x2d220b12, 0x22101850, 0x16002751, 0xe1323f00,
    0x3912e13f, 0x3b4b2f39, 0xe1333205, 0xc6100132, 0x32715d2b, 0xc15d2f32, 0x5d32e110, 0x0623415d, 0x2e220525, 0x41262702, 0x1621090f, 0x07296233,
    0x21153408, 0x32331616, 0x1537023e, 0x2203030e, 0x34210706, 0x3503022e, 0x4b82b36b, 0x128e8504, 0x0e069509, 0x0e1b3131, 0x5a98744c, 0x3b6e9e63,
    0x99054cfd, 0x19573397, 0x080e9b38, 0x46145982, 0x0281c788, 0x3f27726f, 0x223a0e15, 0xa96c312f, 0x81473e75, 0xc1716eb5, 0x1d130ab6, 0x1c13a212,
    0xdb030812, 0x7144959c, 0x00002c50, 0xfe3d0002, 0x0506067f, 0x002e00cd, 0x40720039, 0x1c5a1b46, 0x5b35221c, 0x3b670b14, 0x3b1f3b0f, 0x25202c02,
    0x34252501, 0x70005b0c, 0xc0228022, 0x3a220322, 0x34600c22, 0x0f012e4f, 0xaf2e3f2e, 0x280f032e, 0x282e0801, 0x1a05282e, 0x1d601114, 0x2ffb1b12,
    0x22062b42, 0x5933e13f, 0x2d420561, 0x39122216, 0x1631422f, 0x23110725, 0x42032e11, 0x252a2a33, 0x3a64584e, 0x8ac480b6, 0x3442084d, 0x170e2d26,
    0xfe020b11, 0x10730191, 0x8eebb06d, 0x08133a42, 0x33000275, 0xb60483fe, 0x2d005e04, 0x92003600, 0x47043040, 0x320b0505, 0x57242d48, 0x0138ff38,
    0x38b03890, 0x7f381f02, 0x25310238, 0xdf150b48, 0x0e0e010e, 0x100b0019, 0x030b200b, 0x0b500b40, 0xffb80b02, 0x102b40c0, 0x370b4813, 0x3150250b,
    0x182b181b, 0x01180f02, 0x112b111b, 0x01110f02, 0x18111806, 0x502e2811, 0x5128101e, 0x1606032d, 0x3f00fb04, 0x4233333f, 0x39412443, 0x06252205,
    0x06284106, 0x201d4c42, 0x06494201, 0x4285042a, 0x54b64c80, 0x03386389, 0x361c4d42, 0x857283fe, 0x1bec010b, 0x20355939, 0x95fe0423, 0x54117501,
    0x426fb284, 0x02211952, 0x064d42f0, 0xffff3a08, 0x00005200, 0xb6056402, 0x2c000602, 0xffff0000, 0x00000400, 0x69078106, 0xb0012602, 0x07010000,
    0xf4003602, 0x13005201, 0x17010b40, 0x00012605, 0x0a11121c, 0x352b0125, 0x85028200, 0xbe05232d, 0x2d821706, 0x2d86d020, 0x18009321, 0x8209af8e,
    0x070e212d, 0x00202d87, 0x08057563, 0xb605e143, 0x67002500, 0x1b1b3f40, 0x115b2105, 0x0a100a09, 0x48180c40, 0x11040a0a, 0x40271027, 0x080b0227,
    0x055a0408, 0x5f1f2664, 0x081c161c, 0x2f600003, 0xef0c5f0c, 0x040cff0c, 0x1510400c, 0x050c0c48, 0x06736309, 0x39123329, 0xe15d2b2f, 0x493f3333,
    0x3223050f, 0x715d3311, 0x382905ca, 0x11e11033, 0x30312f39, 0x05976201, 0x01113324, 0xa1520133, 0x0d756307, 0x4146022c, 0xbaba285c, 0xfdcf3502,
    0x095606d1, 0x487f370d, 0x7c437701, 0x116f02ae, 0x05b0fd0e, 0x023cfdb6, 0x5558fdc4, 0x7663eca3, 0x76b3220e, 0x08db823a, 0x0afeae54, 0x4a04e903,
    0x72002300, 0x080b4740, 0x2202081b, 0x231f1023, 0x1d232301, 0x1e0d0d05, 0x25054814, 0x5f01250f, 0x7f256f25, 0xbf259f25, 0xff25df25, 0x21000725,
    0x1e471d21, 0x1c212454, 0x000b5119, 0x0702001b, 0x221e0000, 0x151e0f1f, 0x0a0e5111, 0xd882001b, 0x21057648, 0xe6825d5e, 0xf6100123, 0x55e383e1,
    0x112006fd, 0x7129fe82, 0x30313338, 0x1e015d00, 0x054f6403, 0x21099263, 0x9363022e, 0x08fb8306, 0x5e2b0229, 0x3f4578a3, 0x4c57966f, 0x692c2f69,
    0x23757643, 0x204e724a, 0xb4b42955, 0x02c49801, 0x8440056a, 0xd59694d0, 0x631f4088, 0x6a2d0592, 0x102d6097, 0x0450fe0d, 0x010afe4a, 0x26dd82f6,
    0x057ffe00, 0x82b60556, 0x733a08dd, 0xb80207b1, 0x4640f8ff, 0x02481714, 0x0118895a, 0xe0181018, 0x1db4011d, 0x1dd41dc4, 0x501d0003, 0x1d07021d,
    0x210f1f1d, 0x5a002222, 0x251f2023, 0x25c02590, 0x0f0325f0, 0xf9821f25, 0x0f080333, 0x5f02fb21, 0x6013031d, 0x5f1f130c, 0x3f001200, 0x2a0184e1,
    0x5d5e2f01, 0x32d4105d, 0x6c39e132, 0x0e820535, 0x38335d2f, 0x322be15d, 0x11213031, 0x07030e21, 0x0cbc7e0e, 0x12363625, 0x6b213712, 0xd92a0519,
    0x200f85fe, 0x14102121, 0xb8184f35, 0xd02c120a, 0xa5d98fc3, 0xf5711205, 0x6751d4eb, 0x12f9b718, 0x20056e4c, 0x08e58200, 0x83fe1041, 0x4a046604,
    0x58001800, 0x46023840, 0x12e412d4, 0x70126002, 0xb012a012, 0x12340412, 0x0a121201, 0x00171716, 0x14151847, 0x1a201a55, 0x0f021ab0, 0x0a08011a,
    0x5002fb16, 0x4f0d0f12, 0x4a141607, 0xd38306e8, 0xf420d185, 0x3925d186, 0x5d5d5d2f, 0x20ca84e1, 0xf8a01802, 0x39c4840f, 0xfefefa02, 0x825f4014,
    0x10311c56, 0x59371c16, 0x02123345, 0xb77ab654, 0xa118037b, 0xfc250f00, 0x01e9fd50, 0x08af837d, 0x00fee53b, 0xb605f404, 0x4b001b00, 0x05052b40,
    0x5a0c1410, 0xc01d6517, 0x1dbf011d, 0x011d2001, 0x105a0f13, 0x5f0e1c64, 0x0801130f, 0x15101313, 0x12100311, 0x00065f09, 0x323f001c, 0x085742e1,
    0xf6100122, 0x2106eb46, 0x334332e1, 0x022e2106, 0x2507d965, 0x23112111, 0x05823311, 0x14113326, 0xd102020e, 0x22078e66, 0x5bfdc6bb, 0x522405c0,
    0x00fec992, 0x23068266, 0x1f02f7f0, 0x2507c95b, 0xf8aaddfa, 0x17434fa2, 0x3b042305, 0xa3824a04, 0x1a406924, 0xa3820303, 0x17473408, 0x1d001d55,
    0x30021d20, 0x501d401d, 0xf01dd01d, 0xb81d051d, 0x2840c0ff, 0x1348110e, 0x5410470f, 0xeb500e1c, 0x13a90113, 0x0f0213b9, 0x2f131f13, 0x84060313,
    0x100f25bf, 0x04510715, 0xbf8a4a82, 0x071d4418, 0x715d2b22, 0xc186c883, 0x22060743, 0x8e35023e, 0x4ca02ac1, 0x692c2f69, 0x3d5b3b42, 0x05a15a1f,
    0x663fb621, 0x2d2f088a, 0x01699661, 0x0417feb2, 0x0139fe4a, 0x66f3fbc7, 0xe5360687, 0xb6057ffe, 0x0f00b605, 0x32405200, 0x0d030302, 0x01045a05,
    0x1a5d1100, 0x50c02007, 0x205d0533, 0xd4102f2b, 0x32e13232, 0x31332f39, 0x03332530, 0xd85b1323, 0x04332609, 0xd98fc2f4, 0x171e5da6, 0x00010029,
    0x0483feae, 0x824a04f2, 0x4076318d, 0x0e0e0d4f, 0x0f470008, 0xbb0bab0c, 0x110b020b, 0x22581c5d, 0x885dd410, 0x0c1c5db1, 0x0320bc82, 0x23071c5d,
    0x7ab67bb7, 0x4209eb5b, 0xa62209a5, 0x8f4d7ffe, 0x40592a06, 0x1a5a1d21, 0x5a00161a, 0x0c824d19, 0x5a0e3008, 0x0b700b60, 0x0bb00ba0, 0xffb80b04,
    0x071440c0, 0x160b480a, 0x06065f11, 0xfb1b1a0c, 0x121a5f1d, 0x00030c17, 0xe13f333f, 0x3912113f, 0x4d33e12f, 0x32250b7e, 0x3031e12f, 0x0b3f4e25,
    0x23059249, 0x23113311, 0x03210182, 0x11f94ec7, 0xa6b0ba24, 0xf74eb001, 0xfe4a2414, 0x4e27027f, 0x754d05fb, 0x40402a06, 0x18471b25, 0x471c1418,
    0x08624d17, 0x0a470d33, 0xfb191d54, 0x05500f14, 0x501b0b05, 0x0b151518, 0x849e840f, 0x05df4e9c, 0xe1f61023, 0x209a8432, 0x12d94e01, 0x33209883,
    0x2113da4e, 0xdb4ea0b6, 0xb6fb2514, 0x170283fe, 0xc73d9782, 0xf2067ffe, 0x1f00b605, 0x36b69a00, 0x0039011f, 0xffb81f01, 0x0c2c40f8, 0x001f480f,
    0x29058208, 0x0c0d0d00, 0x13120910, 0x0d830e13, 0x010e3934, 0x5a151d0e, 0x21101114, 0x21c02120, 0x01210f02, 0x30830b08, 0x2a821020, 0x010b263f,
    0x5a08020b, 0x10206409, 0xffb80c5f, 0x091640f0, 0x09004812, 0x1215030c, 0x011efb12, 0x24468201, 0x0a0e0148, 0x2ad98203, 0x33112b33, 0x33173f3f,
    0x8401e12b, 0x2b5d21d7, 0x2307ad45, 0x2b5d3232, 0x2b05b145, 0x2b331139, 0x30312b33, 0x01215d5d, 0x2308546d, 0x01330121, 0x0805a445, 0x34112339,
    0x3637023e, 0x03012337, 0x0845fe23, 0x06040405, 0x011401ac, 0x9e01069c, 0x90c31401, 0x01baa6d9, 0x03020202, 0x41fe0804, 0x494a0005, 0xfc398b3f,
    0xfbb60596, 0x45a80458, 0x032a059f, 0x413d1977, 0x49471e42, 0x054302fb, 0x05700805, 0x004a04c7, 0x40870024, 0x1807085a, 0x22201018, 0x001e2323,
    0xaf212446, 0x0220bf20, 0x26e02620, 0x0126cf01, 0x26402630, 0x26a02650, 0x01260f04, 0x460f1206, 0x22255410, 0x0e3b01fb, 0x0e5b0e4b, 0x1b0e0b03,
    0x030e2b0e, 0x111e0e0e, 0x3450200f, 0x54184418, 0x18050318, 0x18251815, 0x18100803, 0x00150003, 0x5d32173f, 0x333fe15d, 0x5d5d2f33, 0x2005b850,
    0x21f98232, 0x10435d5d, 0x12112109, 0x3338f882, 0x11213031, 0x0107030e, 0x032e0123, 0x11231127, 0x031e0133, 0x37033e17, 0x2206bb71, 0x18066f04,
    0x2f142da6, 0x0e06050e, 0x010d1613, 0x7bb7d90e, 0x81037ab6, 0x1f31a618, 0x49055443, 0x002b12b5, 0xdd040000, 0x26026907, 0x49002400, 0x212005b5,
    0x2805b549, 0x26051a02, 0x151f0002, 0x08874904, 0x5e263d82, 0xa103ecff, 0x2d821706, 0x2d824420, 0x36020632, 0x130000d4, 0x38020b40, 0x25022611,
    0x220c333d, 0x8207b349, 0x2059852b, 0x2259872b, 0x83006a00, 0x40172c59, 0x1e02030d, 0x02032605, 0x85291501, 0xfd95185b, 0x215d8308, 0x1419059c,
    0xff2d287b, 0x060000fe, 0x02b60556, 0x00880006, 0x239d8500, 0x5e044406, 0xa8200f82, 0xc7240f84, 0xc8030000, 0x2820db84, 0xff21db85, 0x29db85fb,
    0x26051101, 0x0c160601, 0xaf8a0001, 0xdb827120, 0xdb84e120, 0xdb854820, 0x0719ea20, 0x00221641, 0x2b820002, 0x12053e08, 0x1e00cd05, 0x49002900,
    0x1a242f40, 0x2b670e5b, 0x2b8f2b0f, 0x2bbf2baf, 0x0b402b04, 0x5b25480f, 0x2a661903, 0x192f5f25, 0x197f195f, 0x09191903, 0x13135f1f, 0x095f0003,
    0xe13f0004, 0x06597133, 0xf610012a, 0x5d2be132, 0x32e1f610, 0x2005734a, 0x07564f35, 0x09a14718, 0x21355208, 0x3203032e, 0x2137023e, 0x02021e14,
    0x5bcf8079, 0x7d695a2a, 0xa5f4a04c, 0xe89d5154, 0x87d79996, 0x07db033e, 0x43a97340, 0x426d955b, 0x26edfc07, 0x29058c55, 0x0faa202c, 0x6c0a131a,
    0xabe9fec6, 0xc2ebfeae, 0x01c46b68, 0x7a46ab15, 0xfb4786c1, 0x05354f66, 0x00447f22, 0x6620cb82, 0xd722f782, 0xcb825e04, 0x00272d08, 0x22294043,
    0x57054811, 0x0129b029, 0x2301293f, 0x56101948, 0x9f502328, 0xcf10af10, 0x0410df10, 0x1f001010, 0x19160a50, 0x10005114, 0x5d20c58f, 0x3222c587,
    0x534a021e, 0x022e2b05, 0x26213535, 0x0e222326, 0xd7820702, 0x36321322, 0x3a08c284, 0xb66ee701, 0x78424983, 0x9e6366a7, 0xb5023b6e, 0x33979a05,
    0x274c5057, 0x57514c28, 0x0b857360, 0x391b14fe, 0x4a5e0458, 0x8887d28e, 0x474e95d6, 0x716eb581, 0x130ab6c0, 0x82a1121c, 0xfc092203, 0x09834c25,
    0xff712a08, 0x071205ec, 0x0226022b, 0x010000e1, 0x006a0007, 0x00520146, 0x0203b619, 0x03260533, 0xd3ffb802, 0x183e2ab4, 0x2b01250e, 0x08654235,
    0x0521ef84, 0x203382d9, 0x243382e2, 0xc46a0006, 0x21318400, 0x31841131, 0x28b4f425, 0x8c050f3c, 0x00042431, 0x83810600, 0x05d94c65, 0xf4206582,
    0x172c6582, 0x01020d40, 0x0226051b, 0x26120001, 0x8805db4c, 0x21318263, 0x6383be05, 0x00d00122, 0x91219785, 0x82658300, 0x82112030, 0xffb82530,
    0x2612b4ff, 0x8805e14c, 0xff482433, 0x84ec03ec, 0x85b12065, 0xbfff2133, 0x0222cb84, 0x64834301, 0xf4ffb827, 0x134e3ab4, 0x20998c0b, 0x20338244,
    0x20678452, 0x203386d1, 0x20678655, 0x20678543, 0x6c3382d9, 0x6785051c, 0x00010022, 0x64086784, 0x2000b605, 0x2d407200, 0x1c1b5b00, 0x4020205b,
    0x1d481810, 0x1b20201b, 0x160d031d, 0x2267055b, 0x7001229f, 0x020d800d, 0x0d4f0d3f, 0x0d030d5f, 0x1e5f1d20, 0xf0ffb81b, 0x0d071840, 0xaa191b48,
    0x00780100, 0x01000f01, 0x1e000008, 0x0e601303, 0x3f00130a, 0x393fe133, 0x5d5d5e2f, 0x2b33335d, 0x0132e110, 0x230a822f, 0x12e1f610, 0x25054e5c,
    0xe110e110, 0x6f4c3031, 0x9744180b, 0x35233108, 0x21352101, 0x73f40115, 0x434784ba, 0x6e89cd88, 0x0a44bd18, 0x017b2108, 0x03a6fda6, 0x053b033d,
    0x66976435, 0x4074a060, 0x17aa2d22, 0x940d1824, 0x97818787, 0x91a6d101, 0x1b23d382, 0x630314fe, 0x3d080545, 0x003e4064, 0x4a201f4a, 0x13402424,
    0x1f214818, 0x211f2424, 0x47180d03, 0x6f265705, 0x02269f26, 0x0f012630, 0x0d070126, 0x48110c40, 0x5021240d, 0x001d1f22, 0x480c0920, 0x0f220000,
    0x3a4d5013, 0x2f392407, 0x8433332b, 0x832b20c3, 0x18c59fd0, 0x85089652, 0xa83e08c7, 0x497da85f, 0x73ba8447, 0x1f3ab573, 0x36665b4e, 0x30567747,
    0x548b6337, 0xfd92016d, 0x010603c6, 0x754107d5, 0xb76e6ca6, 0x22244984, 0x181f10a6, 0x7d572e0f, 0x527d564e, 0xed017d27, 0xbd18859a, 0x063d0731,
    0x012602c1, 0x010000b2, 0x004d0107, 0x005201b0, 0x1a01b415, 0xb8012605, 0x18b4feff, 0x9b641819, 0x00ae260c, 0x053b0400, 0x202f826f, 0x242f82d2,
    0x394d0106, 0x212d8300, 0x2d83110e, 0x0cb4ff25, 0x44040a0d, 0xc9260ae9, 0x10050000, 0x5d872b07, 0x006a0023, 0x0669429c, 0x69422120, 0x205f8205,
    0x425f852c, 0x91820535, 0xd9206185, 0x00226187, 0xcf42256a, 0x42152005, 0x63820567, 0x63852020, 0x7d243188, 0x7105ecff, 0x00216583, 0x059b4232,
    0x43aa0021, 0x032b0535, 0x26053102, 0x28010203, 0x42000a3c, 0x71250ccd, 0x2d04ecff, 0x21638205, 0x99435200, 0x43f92005, 0x29200599, 0x23059943,
    0x3420b4f9, 0x6384318e, 0x02cd052a, 0x007e0206, 0x00ffff00, 0x04214184, 0x200f825e, 0x880f847f, 0x211f8383, 0xe9820701, 0x04298386, 0x26053303,
    0x2a010304, 0x88518e3e, 0x82022083, 0x06012141, 0x00283182, 0x0d401700, 0x112b0304, 0x00222f82, 0x2f8e3622, 0xb3823b20, 0xe5834420, 0x82c70121,
    0x216182b3, 0x4b4197ff, 0x412e2006, 0xa625054b, 0x043925b4, 0x24e78c0c, 0x03ecff37, 0x21e78342, 0x3386e701, 0xb5433820, 0x41302006, 0xca25054d,
    0x033b27b4, 0x20338c22, 0x26678219, 0x02c106ae, 0x83bd0126, 0x4d012333, 0x11422700, 0x05242105, 0x22051142, 0x46132322, 0x0a2a0bcd, 0xdf0314fe,
    0x26026f05, 0x11425c00, 0x00bb2d05, 0x0b401300, 0x26112501, 0x24230101, 0x0c47f618, 0xc3845b84, 0xf3825b84, 0xc3861220, 0xc3852b20, 0x22b4fd23,
    0x415d8536, 0x131908dd, 0xa7281017, 0x40170000, 0x2c01020d, 0x0122c283, 0x61853723, 0x63852f88, 0xbf887320, 0x66005322, 0x22050d42, 0x832e0102,
    0x95512064, 0x21062161, 0x5321c188, 0x20618600, 0x2061832f, 0x2361905a, 0x040000a6, 0x2005a545, 0x055541c1, 0x87540021, 0x831f2061, 0x160f2261,
    0x0ebb412a, 0x00009a26, 0xd905fe03, 0xe1209382, 0x06233182, 0x86066a00, 0x83222061, 0x19082461, 0x410a172d, 0x434b0983, 0x034b0805, 0x00b605be,
    0x40640009, 0x0100140b, 0xd00100e4, 0x00020100, 0x40c0ffb8, 0x48130835, 0x2f0b0000, 0x6f0b4f0b, 0x040b8f0b, 0x1811400b, 0xbf5a0748, 0x0204cf04,
    0x0f010484, 0x02041f04, 0x03040407, 0x0a64085a, 0x03095f02, 0x5c075f03, 0x3f2006f8, 0x34051a4b, 0x5d5d5e2f, 0x5d2be15d, 0x2b2f3311, 0x715d5d5f,
    0x15013031, 0x078a4c21, 0xc3fdbe2e, 0x05bab0b0, 0x96fba6b6, 0x8101d9fd, 0x01288382, 0x83feae00, 0x4a040a03, 0x4e268d82, 0x02203240, 0x00820230,
    0xc00b2a08, 0x0ba1010b, 0x010b7001, 0x06bf4709, 0x840206cf, 0x060f0106, 0x0702061f, 0x47050606, 0x050a5400, 0x08150950, 0x015004fb, 0x05a6750f,
    0xf6100124, 0x7a8532e1, 0x25056d5d, 0x3330315d, 0x79862111, 0x5c02ae28, 0xb6a05afe, 0x88634a04, 0xffff2d06, 0x0000c700, 0x2b07cf05, 0xc5012602,
    0x20066541, 0x056541fc, 0x2703042b, 0x03042605, 0x06321e00, 0x0cb9421c, 0x3182ae20, 0xd9055022, 0xe5203182, 0xb0203186, 0x8205c941, 0x85112031,
    0x0d0a2131, 0x2f2a318c, 0xbe036dfe, 0x2602b605, 0x31839b02, 0x00800323, 0x2a3182a6, 0x1f01b30a, 0x1001071f, 0x8235113c, 0x82122087, 0x82fd8223,
    0x849c2023, 0x00812223, 0x20238789, 0x2a23870d, 0x046dfe00, 0x00b6059a, 0x843b0026, 0x03802223, 0x35238223, 0x1d01b117, 0xb2c0ffb8, 0xb8481513,
    0x1db49eff, 0x2500001d, 0x95542b01, 0x82232005, 0x04112231, 0x2031824a, 0x2231845b, 0x829a0281, 0xb3122831, 0x011d5001, 0x829affb8, 0x0707212c,
    0x5d212c82, 0x06bb6335, 0x5d826020, 0x00113308, 0x462740b2, 0x020f560f, 0x09590949, 0x01003602, 0x06010639, 0x04000f09, 0x0103030c, 0x3f011130,
    0x11070107, 0x01051107, 0xffb80a0b, 0x0a0ab3f0, 0x07820504, 0x05144034, 0x0e100e0d, 0x1001020e, 0x70010100, 0xc0018001, 0x64820301, 0x2740c028,
    0x01480a07, 0xc0501301, 0x137f3a05, 0x06000804, 0x28090f5f, 0x0c270103, 0x0a0c0301, 0x0d010909, 0x0105030a, 0x06d87012, 0x39112f2b, 0x115d5d39,
    0x0132e133, 0x6106825e, 0x332205b1, 0x0283382f, 0x11250383, 0x2f393912, 0x2621822f, 0x332f3d39, 0x825d3317, 0x30312400, 0x83230101, 0x35212502,
    0x01330121, 0x21260282, 0x01c50215, 0xa961d39b, 0xfe9a2605, 0xfe1401df, 0x06ad6192, 0x018e4008, 0xfdb4021c, 0xfd7b024c, 0xa4b40285, 0xd1fd5e02,
    0xa2fd2f02, 0x000100a4, 0x03000023, 0x004a04db, 0x40170111, 0x900880bf, 0x00080208, 0x0f0b0008, 0xf7010506, 0x05e50105, 0x01053601, 0x82070605,
    0x0d9508f0, 0x0d101001, 0xf8010309, 0x03ea0103, 0x01033901, 0x066b0203, 0x5702067b, 0x063a0106, 0x6402064a, 0x02027402, 0x35010258, 0x02024502,
    0x020d0206, 0x0f03060d, 0xf7010c06, 0x0ce5010c, 0x010c3601, 0x16400b0c, 0x400b4819, 0x6b48110e, 0x020b7b0b, 0x3a010b57, 0x020b4a0b, 0x10130b0b,
    0x02133013, 0x13b01390, 0x01130f02, 0xf8010e09, 0x0eea010e, 0x010e3901, 0x7b0f6b0e, 0x0f58020f, 0x450f3501, 0x0d0f020f, 0x044f100a, 0x0101ef07,
    0x011b010b, 0x015b012b, 0x289c826b, 0x0f020101, 0x0205150b, 0x074c410f, 0x5d5d5e26, 0x32e13333, 0x2405bd48, 0x5d5d5dc1, 0x22028271, 0x822fce10,
    0x2b2b2109, 0x12250f84, 0x2f3d3917, 0x07946118, 0x13841020, 0x83331121, 0x86048201, 0x0572410e, 0x13303123, 0x058e6121, 0x21152122, 0x08067041,
    0x0001685f, 0xfacfcffe, 0xcdfecffa, 0xf7fe0401, 0xfecf4a01, 0xcff2fef4, 0xfbfe4a01, 0xcf017b02, 0x9a0166fe, 0xfe8931fe, 0xfeb4010e, 0x00f2014c,
    0x89000200, 0xf6030000, 0x0e00b605, 0x40001900, 0x19062940, 0x1b65095a, 0x10011b9f, 0x5b15011b, 0x0f1a6600, 0x4f063f5f, 0x9f066f06, 0xdf06bf06,
    0x28008206, 0x095f1907, 0x00030712, 0x09634c3f, 0x9c4be120, 0x34132407, 0x8233023e, 0x211125a7, 0x01022e22, 0x0805d36a, 0x3333162e, 0xcf7f3789,
    0xfebb9598, 0x7ec28695, 0x81b2023c, 0x2e5b8a5d, 0x019fafa3, 0x719857ac, 0xfa680242, 0x9e703d4a, 0x3c1b5f01, 0x84884661, 0x27076747, 0x02140602,
    0x00470006, 0xff23a384, 0x823b06ec, 0x232108a3, 0x63003200, 0x09183f40, 0x1a1a5a32, 0x015a2211, 0x340f3465, 0x9f346f01, 0x0334ef34, 0x34503440,
    0x080e8202, 0x5b2a0633, 0x24336611, 0x2323175f, 0x174f173f, 0x17bf176f, 0x170517df, 0x1d031817, 0x0609602d, 0x3f00130e, 0x32e13333, 0x5d2f393f,
    0xe1102f33, 0xe1f61001, 0xe269185e, 0x39e12f09, 0x01303132, 0x020e1411, 0x27262223, 0x4718030e, 0xd4830756, 0x33161428, 0x35023e32, 0xd8870511,
    0x53080d83, 0x5b2d3b06, 0x99725e8c, 0x523f182b, 0xe4d73f67, 0x96d78a41, 0x6167bb7a, 0x1c33482c, 0x5d81bafd, 0x7e2d5b8b, 0x385b4386, 0xfe500317,
    0x668b5118, 0x264d613a, 0xd2192e3f, 0x72a367d6, 0xfb68023c, 0x1e6970b2, 0x01325039, 0x431ea6e8, 0x82804d6b, 0x294d3e25, 0x7120f383, 0x5a22f382,
    0xf1821406, 0x00433d08, 0x1039405c, 0x5047382c, 0x2e2e012e, 0x0647031b, 0x456f4555, 0x459f457f, 0x45ef45cf, 0x01454005, 0x452f450f, 0x48410602,
    0x0444561b, 0x503e3304, 0x2c102025, 0x50330000, 0x16160b10, 0x3f22ed86, 0x4e18e133, 0x5d21082e, 0x20f3825d, 0x2aff8211, 0x313932e1, 0x36322530,
    0x85331135, 0x022e23f1, 0x16522327, 0x063a6b06, 0x26331725, 0x83262627, 0x031e2220, 0x08ef8221, 0x34353737, 0x2223022e, 0x16141506, 0x626fd304,
    0x8b5c2fb6, 0x5167415b, 0x1b06173d, 0x51795b44, 0x3c6e9a5d, 0x5d9a6e3c, 0x3b4d603b, 0x03030c17, 0x01b60402, 0xfd512c0f, 0x087e7ea6, 0x7f7f873e,
    0x01828283, 0x69c1fe35, 0x1e2e6298, 0x292c4a36, 0x4820374a, 0x8d8cd48f, 0x1a4990d5, 0x0805937e, 0x0111366d, 0x3e92fbb4, 0x2e2d4e6a, 0x295f8c5e,
    0x376b9d65, 0xcdd1ccda, 0x00010000, 0x06ecff4e, 0x00cb0544, 0x4085003f, 0x205b0d56, 0x252b5b00, 0x2b200720, 0x0307202b, 0x365a3316, 0x417f4165,
    0x419f418f, 0x41ff41ef, 0x20410005, 0x03413041, 0x16801670, 0x4f163f02, 0x16160216, 0x60062540, 0x01340007, 0x07df3434, 0x0107aa01, 0x6b010778,
    0x1b280500, 0x133b5f30, 0x1b601215, 0x2109404f, 0x00825d5e, 0x5d2f3327, 0x1139e110, 0x4c078201, 0x11270571, 0x2f2f3917, 0x4c39122f, 0x34270672,
    0x2323022e, 0x4b323335, 0x222106a5, 0xc9af1806, 0x1507230b, 0xa97f031e, 0x0a644106, 0x29033a08, 0x5d926535, 0x8e5cb0bf, 0x44253261, 0xa96e3a5f,
    0x62265c4b, 0x6d478374, 0x333971a6, 0x574b7d5b, 0x18325e8a, 0x6f374f32, 0x6638b762, 0x94575991, 0x87013c6c, 0x21466d4d, 0xd55d1897, 0x1f74080a,
    0x36182936, 0x4a4f8561, 0x0c395877, 0x59390b06, 0x684a4877, 0x81771e41, 0x2dfec901, 0x2e629869, 0x009c642f, 0x50000100, 0xa205ecff, 0x3b005e04,
    0x23408100, 0x20004715, 0x31363146, 0x19310019, 0x03003119, 0x0b470827, 0x3d0f3d55, 0x013dd001, 0x30013dbf, 0xb827013d, 0x2940c0ff, 0x5f481512,
    0x27270127, 0x5019363c, 0xdf09091a, 0x1a99011a, 0x0b021aa9, 0x2e06907d, 0x50232605, 0x5005102c, 0x3f001610, 0x73e13fe1, 0x5d230566, 0x412f335d,
    0x2b20072a, 0x25075243, 0x2f2f3917, 0x2d41112f, 0x1e142308, 0x70423302, 0x3435220c, 0x083e4126, 0x41232621, 0x0331113d, 0x50311552, 0xb660693b,
    0x608f5f2f, 0x3564905c, 0x3b5d1885, 0x4d28360c, 0x56355a52, 0x1c3a6990, 0x322b4633, 0x01223c53, 0x3849274c, 0x09614221, 0x7b542b23, 0x105d184f,
    0x1d13240b, 0x18260913, 0x39088bbb, 0x523e2909, 0x00010000, 0x047ffe4e, 0x00cb059c, 0x40830031, 0x275b0f54, 0x01822209, 0x01184a08, 0x802e705a,
    0x2e2e022e, 0x2f2f5a00, 0x01330033, 0x33d033c0, 0x01339f02, 0x33203300, 0x70033330, 0x02188018, 0x184f183f, 0x32181802, 0x0827fb30, 0x0109df60,
    0x780109aa, 0x090f0109, 0x09090801, 0x60141701, 0x5f2e041d, 0x054f5a01, 0x23072641, 0x3f39e15d, 0x36075042, 0x3311715d, 0x2f32e12f, 0x3912e15d,
    0x122f2f39, 0x3031e139, 0x42112321, 0x15292155, 0x03231133, 0x6738bbec, 0x1f494295, 0x01b0b027, 0x416443a0, 0x1e3c4220, 0xd9fdfa38, 0x50000100,
    0xf20383fe, 0x2d005e04, 0x1a408d00, 0x221d460c, 0x0182061d, 0x00132308, 0x2d292947, 0x302a2047, 0x602a402a, 0xb82a042a, 0x0e40c0ff, 0x2a48130f,
    0x2fc02f2a, 0x2fe02fd0, 0x12831303, 0x122d2a08, 0x135f4815, 0x2e131301, 0x0522fb2b, 0x0106df50, 0x06a90699, 0x5f064f02, 0x060b0206, 0x0702061b,
    0x12000606, 0x1018500f, 0x07925a29, 0x20081441, 0x061441e9, 0x2305a44a, 0x2f32e15d, 0x25071241, 0x3031e110, 0x28421121, 0x1515281e, 0x11231133,
    0x42819c02, 0x2c29191f, 0xa0263f52, 0x5e2b01b7, 0x205f1865, 0x0d0f4209, 0x422c0e25, 0x5a913d5b, 0x770807c7, 0x06e9ff00, 0x00b605ec, 0x40920031,
    0xe706d765, 0x07060206, 0x01d70101, 0x010201f7, 0x10171c5a, 0x8b481810, 0x10170117, 0x17480e07, 0x1e5a311c, 0xe0011eb0, 0x1cb4011c, 0x1cd41cc4,
    0x501c0003, 0xa01c901c, 0x1c07041c, 0x0e1e1c1e, 0x65275a24, 0x6f334f33, 0x9f337f33, 0xdf33af33, 0x33200633, 0x01330f01, 0x1225250e, 0x031c5f01,
    0x2c601221, 0x3f00130b, 0x3f32e133, 0x2f20f782, 0x2207df50, 0x62393911, 0x102f0608, 0x2b3311e1, 0xe1102b5d, 0x5d32715d, 0x5c013031, 0x1420187b,
    0x08478218, 0x23020e27, 0x35022e22, 0x1e885c03, 0x446e6321, 0x92220768, 0x915c3a68, 0xd1fb231a, 0x5e447781, 0x2c4d0809, 0x006c9960, 0x10000100,
    0x0006ecff, 0x28004a04, 0x39405c00, 0x28114601, 0x13a01347, 0x0111db01, 0x900111c4, 0x0211a011, 0x10011124, 0x13110111, 0x1b091311, 0x2a551e47,
    0x2acf2a7f, 0x09032aef, 0x010c1c1c, 0x180f1150, 0x06234f0c, 0x22f98c16, 0x84e1f610, 0x05ac6af7, 0x20066845, 0x11a05c21, 0x5c114d44, 0x414414ae,
    0x6691220b, 0x10b95c36, 0x413dfd25, 0x44204162, 0x2e230933, 0x83699662, 0xffc728d9, 0x052d07ec, 0x821d00b6, 0x1b3724d9, 0x82a05a13, 0x003108ed,
    0x095a0617, 0x1fc01f65, 0xbf1faf01, 0x1f20021f, 0x011f0f01, 0x175a161a, 0x5f151e64, 0x0f07071a, 0x1a08011a, 0x181c171a, 0x03121703, 0x00130e5f,
    0x08d25c3f, 0x20076e48, 0x47d68332, 0x31220882, 0xb0410130, 0x091c5c10, 0x62d50437, 0xb6636e6f, 0x59906638, 0x3a689158, 0xbaba66fd, 0x01ba9a02,
    0x0f884187, 0x782d0121, 0x37080bab, 0x8b06ecff, 0x1f004a04, 0x47406c00, 0x05471a02, 0x470d1e05, 0x00215510, 0x02212021, 0x21502140, 0x21902180,
    0x21f021b0, 0x01210f06, 0x1e471d01, 0x501c2054, 0xeb0e0e01, 0x10c1bd18, 0x1f031e29, 0x0a151e0f, 0x8a161550, 0x05e745c7, 0x9f5d0120, 0x85712005,
    0x32e121c8, 0x8f5dc782, 0x10e14505, 0x1121353b, 0x64011123, 0x15b62102, 0x6a3b5031, 0x5f2fb65f, 0x925b608f, 0xdffd3666, 0x05d35cb6, 0x22138041,
    0x8217fe6e, 0x003808c2, 0xff7d0001, 0x055205ec, 0x002a00cb, 0x2a294047, 0x5b290c2a, 0x09401401, 0x1414480e, 0xbf2c6701, 0x2c70012c, 0x0c5b1f01,
    0x5f2a2b66, 0x1a240000, 0x0411155f, 0x13075f24, 0x3325af83, 0x2f3912e1, 0x27a883e1, 0xe6105d5d, 0x102b2f32, 0xa8821083, 0x18152121, 0x270ca15e,
    0x16323324, 0x032e0717, 0x0805d749, 0x33021e54, 0x35023e32, 0x02170321, 0xde8e423b, 0xa6f29d9c, 0x01b65f56, 0xcc6fab0b, 0x53244858, 0x7a2e5d58,
    0x36427fbc, 0x6c75ab70, 0xfe295d95, 0x56f60288, 0xaffefea8, 0x01c3695b, 0x01acae17, 0x2c69c316, 0x1e11a22a, 0x98510e17, 0xd88289da, 0x7742569c,
    0xc78264a6, 0xecff7131, 0x5e047b04, 0x81002800, 0x28285a40, 0x8247270c, 0x110c21c7, 0x4b08c783, 0x2a142a57, 0xe4022a24, 0x022af42a, 0x02012ad0,
    0x2a502a40, 0x2aa02a80, 0x1d052ac0, 0x29560c48, 0x40005028, 0xcb481915, 0xeb00db00, 0x00a90300, 0x8f0200b9, 0x02009f00, 0x001b000b, 0x0603002b,
    0x18220000, 0x10111550, 0x16075022, 0x5e21f888, 0x2000825d, 0x23fe852b, 0x715d5d5f, 0x440f0141, 0x3421061c, 0x82ef823e, 0x054957fe, 0x2005ac48,
    0x08fe823e, 0x027b0245, 0xba783900, 0x88cb8781, 0xdb954c44, 0x4dad6f8f, 0x5b943c3e, 0x34659561, 0x5e875629, 0x234a7451, 0x4a02b8fe, 0x89c88244,
    0xd3934f47, 0x94d38284, 0x8d272550, 0x6d3a291d, 0x9b5d629d, 0x502d3e70, 0x82004470, 0x821420f7, 0xc93508f7, 0x1900b605, 0x2f406500, 0x65095a06,
    0x7f1b4f1b, 0xaf1b9f1b, 0x1b00041b, 0xef18af01, 0x18840218, 0x00181801, 0x1540135a, 0x01150f01, 0x57151508, 0x77136713, 0x05534613, 0x0a07102c,
    0x15191348, 0x0707165f, 0x52430316, 0x2f392107, 0x74053f55, 0x9d490a90, 0x154e4305, 0x1521352a, 0x62710221, 0xb7626e6f, 0x27054a43, 0x5efe3a69,
    0x5ffefe03, 0x21114943, 0xdf6d9503, 0x08b58205, 0x4a046f3c, 0x6d001b00, 0x470d4a40, 0x0f1d5510, 0x1dcf011d, 0x1dff1def, 0x401d3003, 0x031d601d,
    0x1d1f1d0f, 0x01030f02, 0x0f0103cc, 0x0203bf03, 0x05030306, 0x00601a47, 0x00d00070, 0xf9821f03, 0x1a00003d, 0x1a021a10, 0x0a010e0e, 0x04161550,
    0x0f015000, 0x32e13f00, 0x3911e13f, 0x822f012f, 0x054a75ba, 0x5d5d5e23, 0x062e4971, 0x13303122, 0x1120aa83, 0x3a11d844, 0x35032911, 0x3115c1fe,
    0x5f693b50, 0x8f5f2fb7, 0x66925c60, 0x9ab00336, 0x44d7fd9a, 0x022111bc, 0x207d8235, 0x08c1826f, 0xcb050c43, 0x5d003900, 0x345b13b4, 0xffb8001a,
    0x172e40c0, 0x1a00481a, 0x0a2f1a00, 0x9f3b270a, 0x5b20013b, 0x343a662f, 0x18aa601b, 0x01187801, 0x0801180f, 0x23051818, 0x132a2660, 0x050b600e,
    0x333f0004, 0x820282e1, 0x34a482af, 0x0139e15d, 0x5de1f610, 0x2f32ce10, 0x2f393912, 0x39122b2f, 0x26b182e1, 0x33023e34, 0x77021e32, 0x33210c7f,
    0x08244d15, 0x0e793620, 0x022e2205, 0x08288235, 0x2e353763, 0x733b9c03, 0x7b486da9, 0x5c265a69, 0x3967a24b, 0x2c26445f, 0xc3578257, 0x65925dbf,
    0x6ca4aa35, 0xc05353cc, 0x83c38080, 0x895f3142, 0x54784a57, 0x4f60042d, 0x18366185, 0x7d1f3629, 0x3a1e4336, 0x643e3653, 0x21972748, 0x89436543,
    0xaa2b318e, 0x6f3c2526, 0x7b48609c, 0x060b3d5e, 0x7758390c, 0x30fb8200, 0x03ecff5c, 0x005e046a, 0xb46d0037, 0x011e4632, 0x20fb8323, 0x08fb823d,
    0x23012339, 0x0f2b1801, 0xe039d039, 0x0339f039, 0x4001398f, 0x47050139, 0x1d385618, 0x37ef5002, 0xb937a901, 0x370f0237, 0x372f371f, 0x37370603,
    0x2c502f0a, 0x500a1028, 0x4116130f, 0x1220060a, 0x41058458, 0x5d25060a, 0x32ce105d, 0x090b4111, 0x23150124, 0x43430622, 0x83f78f07, 0x323321ff,
    0x85066a43, 0x02830825, 0x858a819e, 0x37604629, 0x4d576133, 0x73af3c1e, 0x356ba26e, 0x30594328, 0x1e35492b, 0x5690693a, 0x3f50a25a, 0x6647834b,
    0x5f44266d, 0x99870239, 0x45335e5b, 0x160e122a, 0x1da2101e, 0x78563028, 0x405b3d47, 0x0e0b0d29, 0x324d3b29, 0x264a6d46, 0x22932725, 0x2d4d4d26,
    0x00122740, 0x0000ffff, 0x2f056dfe, 0x2602b605, 0x0000b501, 0x80030701, 0x0000b803, 0x01b40d00, 0x00313101, 0x113c1001, 0x83350035, 0xfe102627,
    0x044c046d, 0x2027824a, 0x212784d5, 0x07820281, 0x26212784, 0x26278b26, 0x0498fe00, 0x5dbc05dd, 0x672208cf, 0x4f82d304, 0x0b40132a, 0x27141802,
    0x1b150002, 0x210dcf5d, 0x841898fe, 0x67220cc3, 0x2d866f04, 0x27173626, 0x39330d02, 0x2012d15d, 0x225b88e1, 0x5dd10466, 0x0226054f, 0x0226051b,
    0x2b5e2a21, 0x069c2211, 0x202d828f, 0x23b18344, 0x75046602, 0x39255b86, 0x36022611, 0x132d5e48, 0x5b87d120, 0x04770323, 0x2d5b82cb, 0x0203b619,
    0x03260515, 0xffffb802, 0x5f861db4, 0x26085356, 0x04ecff5e, 0x877f0647, 0x20338261, 0x05595489, 0x33020323, 0x21348211, 0x63863b33, 0x1e823188,
    0x07dd0422, 0x78206589, 0x1d206588, 0x25216587, 0x0e955e1d, 0xecff1224, 0x658a9c03, 0x88047821, 0x843b2065, 0x3b432165, 0x8d052541, 0x4a082165,
    0x7920cb88, 0x0622cba6, 0xcb88f806, 0x65897920, 0x0821cb9b, 0x20658862, 0x20cba27a, 0x21cb835e, 0x65881007, 0xcb8e7a20, 0x31410b20, 0x98fe2511,
    0x7307dd04, 0x002a6585, 0x004b0127, 0x0152011f, 0x57420207, 0x40253105, 0x142d0310, 0x05150227, 0x2a000326, 0x25070430, 0x240ca941, 0x2b00352b,
    0x05595535, 0x98fe5e26, 0x21069c03, 0x00257985, 0xd44b0126, 0x2b458400, 0x0000006f, 0x03164022, 0x0227174b, 0x0d27e883, 0x220c4e48, 0x87250225,
    0x21428688, 0x2782ffff, 0xdd040024, 0xef881308, 0xef847b20, 0x0d401725, 0x82260203, 0x0002237e, 0xb9412129, 0x21ed840e, 0xed88c106, 0x7b047b22,
    0x27071f42, 0x03261144, 0x3f471e02, 0x8914b941, 0xb07c2063, 0xa67c2063, 0x88582063, 0x897d20c7, 0x841a2063, 0x13e742c7, 0x079c0323, 0x20c78806,
    0x2063897d, 0x41c78438, 0x002311b5, 0x42dd0400, 0x7e200a1b, 0x194263a6, 0x8f7e2009, 0x5e502163, 0x250f2b41, 0xdd0498fe, 0x19425b07, 0x004e2408,
    0x426d0121, 0x22270819, 0x2e031640, 0x83022714, 0x2b0026d2, 0x25070431, 0x084c6202, 0x2609d341, 0x0398fe5e, 0x42ee059c, 0x4e200815, 0x230e1542,
    0x0227174c, 0x0d22e283, 0x7d824f49, 0x621e0221, 0x41890762, 0x4182c720, 0xb605be22, 0x28214182, 0x05514200, 0x6544aa20, 0x0f012705, 0x03012714,
    0xe361120c, 0x222d820d, 0x825e04e1, 0x8648202d, 0x85be202d, 0x2b02212d, 0x30246982, 0x0f052e28, 0x260a275d, 0x030000c7, 0x88e107be, 0x0466225b,
    0x05ef4491, 0x05120126, 0x210d0126, 0x20133f62, 0x225b888f, 0x86980466, 0x112e265b, 0x3d2d0226, 0x205b9228, 0x235b8735, 0xd4ff5201, 0x15235b82,
    0x821401b4, 0xffb8255a, 0x2315b4fb, 0xff25b98d, 0x05e103ec, 0x2a5d86e3, 0xde520106, 0x40130000, 0x8230020b, 0x311e225b, 0x235b8f3f, 0xd1075c04,
    0x03235b87, 0x829e0477, 0xb619245b, 0x5b0c0102, 0x142007cf, 0xb344bb86, 0x45712008, 0x4824084b, 0x07010000, 0x250b4b45, 0x03261128, 0x35190302,
    0x318807bb, 0x00002724, 0x658abe03, 0x65887820, 0x0227c282, 0xfdffb801, 0x85141cb4, 0x203388c3, 0x21c58312, 0xc5867f06, 0x45030721, 0xc8820a4b,
    0x38216582, 0x88c98530, 0x00c72631, 0x081b0400, 0x20cb884a, 0x45cba679, 0xcb85054b, 0x960a4b45, 0x236582cb, 0x6208be03, 0x7a206588, 0x7120cba2,
    0x0721cb83, 0x45cb8810, 0xcb970a4b, 0x0398fe25, 0x857307be, 0x27002565, 0xf1ff4b01, 0x3a064b45, 0x000000aa, 0x02104025, 0x01271424, 0x0226050c,
    0x01272103, 0xb8012500, 0x41b4fdff, 0x4b4507a9, 0x8271200a, 0x06e12247, 0x24798521, 0x4b012600, 0x09f942de, 0x16402227, 0x27174003, 0x25e88302,
    0x05433d1c, 0xba41250f, 0x09354309, 0x00005226, 0xe1076402, 0x2c214182, 0x223b8300, 0x42b00366, 0x13200ad9, 0x200ed942, 0x22238262, 0x828f06d7,
    0x86f3202d, 0x825e202d, 0x40132aaf, 0x110a010b, 0x19130126, 0x0ca94204, 0x98fe5226, 0xb6056402, 0x67225b88, 0x2d82be03, 0x01b41523, 0x23dc820f,
    0xb4ffffb8, 0x260e9343, 0x0198fe9e, 0x82e50575, 0x844c202f, 0x0367225d, 0x212f846d, 0xc6821502, 0xfeffb827, 0x041812b4, 0x0a95430c, 0x98fe7d26,
    0xcd057105, 0x32202f82, 0x05212f85, 0x288d855c, 0x27142b02, 0x2e280002, 0x0b075f0a, 0x98fe7126, 0x5e042d04, 0xf3822d82, 0x02070125, 0x85b20467,
    0x8423205d, 0xb4ff235d, 0x2f8c2620, 0x20053160, 0x225d88e1, 0x414e0566, 0x02270519, 0x0226052e, 0x8c283d15, 0xff71262d, 0x062d04ec, 0x225d888f,
    0x86a40466, 0x1126268b, 0x35130226, 0x852d8c20, 0x87d1205b, 0x7703235b, 0x3b5d5805, 0x02032805, 0x03260528, 0x86300502, 0x0c95435d, 0x7f066822,
    0x03235f87, 0x82aa0477, 0xb619255f, 0x11200203, 0xb8243082, 0x28b4faff, 0x77616386, 0x2065890e, 0x20658978, 0x21658430, 0x075f3038, 0x8433200e,
    0x206589c5, 0x20658878, 0x90658728, 0x21cb8499, 0xcb884a08, 0xcba47920, 0xf8062d22, 0x7920cb88, 0x0821cba7, 0x20658862, 0x20cba07a, 0x21cb8371,
    0x65881007, 0xcba37a20, 0x0598fe25, 0x85730771, 0x27002565, 0xae004b01, 0x22059743, 0x48005c05, 0x402d059d, 0x28022714, 0x00032605, 0x000a433d,
    0x09a84125, 0x26095143, 0x0498fe71, 0x8521062d, 0x26002477, 0x43fb4b01, 0xb2200593, 0x28314182, 0x38030940, 0x20022717, 0xb8032611, 0x35b5ffff,
    0x4144833b, 0x47890bbc, 0xecff7d24, 0x8b832506, 0x005f0222, 0x00234182, 0x42060176, 0x4128067f, 0x02022605, 0x01133b35, 0x210db368, 0x7583f404,
    0x82600221, 0x0006342d, 0x00005076, 0x3a02b415, 0xb8022611, 0x2db4ebff, 0x8a190a33, 0x225b8f2d, 0x82540043, 0x202f825b, 0x255a8235, 0xb451ffb8,
    0x5d9c353b, 0x84d84321, 0x842e205d, 0xb4d7235d, 0xdd422d34, 0x22b9820f, 0x852602e1, 0x430220b9, 0x15230539, 0x843c02b4, 0xb4bc225d, 0x205d934a,
    0x832f828f, 0x020721bb, 0x82053b43, 0x8434202f, 0xb4b0235f, 0xbd922d42, 0x5f873520, 0x7d20b982, 0x3d20bd85, 0x96235f84, 0x914c3eb4, 0xe30521bd,
    0x06235f86, 0x84e25201, 0x842d20bd, 0xb4fd235d, 0xbd8d4436, 0x0698fe25, 0x88140625, 0x056723bd, 0x2f84005c, 0x27143827, 0xa7ffb802, 0x0f7941b4,
    0x0498fe25, 0x88f204f4, 0x085744bd, 0x83173021, 0x419b202f, 0xb8200f7b, 0xdd2e2f82, 0x2602b805, 0x00003800, 0x67020701, 0x29442f05, 0x1b012805,
    0x00012714, 0x440b1e18, 0xa4200bb5, 0x08222d82, 0x2d824a04, 0x2d855820, 0x84b80421, 0x1e012b8d, 0xb8012717, 0x1bb4feff, 0xd9410c21, 0xffb8260b,
    0x07dd04ec, 0x225d88e1, 0x421d0566, 0x01270535, 0x0126051e, 0x8d182d11, 0x222d825d, 0x888f0608, 0x0466225d, 0x268b86a6, 0x01261121, 0x8f1b300e,
    0x4e06235b, 0xe9827307, 0x91426120, 0xc5002105, 0x15235b82, 0x823101b4, 0xffb8275a, 0x2b25b490, 0x65420818, 0xffa4260a, 0x067905ec, 0x202f8221,
    0x282f8262, 0x60760006, 0xb1110000, 0x25b68201, 0x2e28b49f, 0x2a84210c, 0xff003527, 0xffb800ff, 0x22598cec, 0x853d0043, 0x84252059, 0xb4082359,
    0x599c252b, 0x86a34321, 0xe2fe2459, 0x91282eb4, 0x87e12059, 0x410220b3, 0x8585050f, 0x3ab45922, 0x85845687, 0x8f20af85, 0x0721af86, 0x050d4102,
    0x56222b85, 0x57923db4, 0x57873520, 0x09491e19, 0xb1842d20, 0x2eb44723, 0x21b1913c, 0x5b86e305, 0x52010623, 0x24b186f3, 0x31b44eff, 0x25b18c3f,
    0x4e0698fe, 0xb1881406, 0x29051f42, 0x2801b415, 0xb8012714, 0x654148ff, 0x98fe2510, 0xf2047905, 0x6720b588, 0x21072142, 0x2f83172b, 0x6a414520,
    0x057f4d09, 0x98fe002a, 0xb6053704, 0x3c002602, 0x20065142, 0x0551427f, 0x5f840c20, 0x09b4ff25, 0x4102070f, 0x0a260ac5, 0xdf0314fe, 0x7d654a04,
    0x02072406, 0x828b0567, 0xb111292f, 0x01b80101, 0x2923b432, 0x5005de65, 0x1882059b, 0x07370423, 0x225b88e1, 0x42710466, 0x0f26067d, 0x14012605,
    0x5991091e, 0x888f0621, 0x04662259, 0x067d424a, 0x82112921, 0x2338212d, 0x850c9b66, 0x8735205b, 0x5201235b, 0x5b86b3ff, 0x5b821120, 0x20120122,
    0x05215b91, 0x083366e3, 0x008c5228, 0x0b401300, 0x59822b01, 0x3a2c0122, 0x7126598c, 0x9e04bcfe, 0x2b821406, 0x0000d328, 0x42000701, 0x6c82b400,
    0xb90e5608, 0xd2ff0200, 0x0b393ab4, 0x2b012523, 0xfb020035, 0xfed904db, 0x002106ba, 0x001b000d, 0x1419402d, 0x40070e0e, 0x3f010050, 0x02004f00,
    0x92071500, 0x010f0f80, 0x0102015f, 0x335d2f00, 0x0132ed1a, 0x1a5d5d2f, 0xcd2f39cd, 0x23013031, 0x3527032e, 0x17031e33, 0x32098805, 0x2364bafe,
    0x103f4d51, 0x2f2a10c6, 0x96fe1530, 0x82522364, 0x84c7200d, 0xd9042d0d, 0x5158531c, 0x5023151b, 0x1b1d4c51, 0x42080b8a, 0x6afc0200, 0xbeffd904,
    0x10007f06, 0x52001c00, 0x0c0d3140, 0x01171004, 0x1c2f4017, 0x1c4f1c3f, 0x04041c03, 0x5f002f1c, 0x9f008f00, 0xc0000400, 0x1b1b1608, 0x8f0c7f04,
    0x800c020c, 0x5f080f00, 0x84080208, 0x5dcc229d, 0x2a988232, 0xcc1a2f01, 0x3d39395d, 0x822f182f, 0x115d23a9, 0xaa833333, 0x27262634, 0x23070606,
    0x37363635, 0x17161633, 0x37033e27, 0x11831533, 0xd9fe3c08, 0x346c3364, 0x65336a36, 0xc0307533, 0x4e337430, 0x1d1d2114, 0x6a2db410, 0xd9046537,
    0x30305422, 0x3b1b2254, 0x84454584, 0x2d19c23b, 0x1521342e, 0x002b673c, 0x0489fb02, 0x86ddfed9, 0x404a2fb1, 0x0c03042a, 0x1601161f, 0x0c0c1c40,
    0x92822f1c, 0x9f088f33, 0xc0080408, 0x12121600, 0x8f037f0c, 0x80030203, 0x20aa8a10, 0x21aa8fcd, 0xa986cd1a, 0x1521a086, 0x20b18623, 0x28088337,
    0x031e3335, 0x336ffc17, 0x34a18474, 0x366a3364, 0x64336b35, 0x6a38644d, 0x1d10b42d, 0x0414201e, 0x20a285f4, 0x29b0851b, 0x3c672bc3, 0x2e342115,
    0x5b41192d, 0x7d200806, 0x1000f806, 0x5e002800, 0x19163840, 0x0e062019, 0x111c1948, 0x3f232f80, 0x03234f23, 0x23040423, 0x250c5e41, 0x261f1919,
    0x62411818, 0x32cc2418, 0x41331139, 0x32230d66, 0x41112b39, 0x13361367, 0x07020e14, 0x36272307, 0x26343536, 0x07062223, 0x33363635, 0x74411632,
    0x14a43310, 0x06192e22, 0x41370a56, 0x27162b39, 0x1f260b0b, 0x7d416463, 0x7601330e, 0x151e2b1d, 0x09835106, 0x1925251f, 0x03520303, 0xdd824503,
    0xfe232682, 0x821007e9, 0x002c2bdd, 0x043b4061, 0x000c0c03, 0x82412828, 0xc0003a09, 0x27001a1a, 0x1fcf8e16, 0x1fef1fdf, 0x09401f03, 0x1f1f480d,
    0x11198e24, 0x16984111, 0x332f3228, 0x2b2f33e1, 0xe382e15d, 0x1a2f332c, 0x325dcc10, 0x3d39112f, 0xe083332f, 0x230f9e41, 0x022e2201, 0x232dd783,
    0x3233033e, 0x3233021e, 0x0e333736, 0x10aa4103, 0x24be0134, 0x1c404547, 0x5d0e2a28, 0x41301d05, 0x454a252a, 0x0d821a3e, 0x1c055c24, 0xbc414130,
    0x5a012a0e, 0x2a1c221c, 0x3b513032, 0x21088221, 0x0883312b, 0xe9820020, 0xd904733b, 0xc106cdfe, 0x1f000b00, 0x19403200, 0x0b0b8006, 0x010c2f1f,
    0x1415c00c, 0x360a8205, 0x0f1a8014, 0x02115f11, 0x5d2f0011, 0x32cd1a33, 0x01cc2f32, 0x821a332f, 0x2f3926bd, 0x3031cd1a, 0x08f24201, 0x030e2528,
    0x27262223, 0xb2821e33, 0x37023e27, 0x20145efd, 0x06f1421e, 0x6f012608, 0x6e4d2b05, 0x06919246, 0x301b046c, 0x41242c44, 0x05052133, 0x2e2c19f8,
    0x3c152135, 0x3c062c67, 0x8c264563, 0x4519197e, 0xfc022108, 0x3829958b, 0x80051e40, 0x1613400b, 0x229a8a48, 0x911f0000, 0x88cd209a, 0x842b209a,
    0x08e4429b, 0x9b8e1720, 0xe342d120, 0x93fc2009, 0x2cdd2a9a, 0x21153c67, 0x192c2e35, 0x419a8e15, 0x072c0731, 0x00130006, 0x4042002a, 0x1c1c1921,
    0x25288a82, 0x002f1325, 0x08090001, 0x222e0e82, 0x1b1bc028, 0x0e800813, 0x055f050f, 0x39410502, 0x2f392206, 0x06e2421a, 0x3d413320, 0x220d8405,
    0x8d013031, 0x4227209b, 0x332411db, 0xcdfe1632, 0x2b20a692, 0x2c06de42, 0x2c394138, 0x150b2715, 0x0563643a, 0x32af8de3, 0x1f2b1d96, 0x5a290614,
    0x25252009, 0x52030318, 0x42004506, 0x132d0add, 0x48002f00, 0x1d1c2740, 0x2b2a081d, 0x30c0842b, 0x2a0809c0, 0xdf22cf19, 0x0322ef22, 0x141c2722,
    0x27c79014, 0x33332f32, 0x32325dcd, 0x82066b41, 0x3311230e, 0xc791332f, 0x9414c242, 0x422f20c7, 0xd08f1ac5, 0xc5425020, 0x00013b13, 0x0142fe31,
    0x00000071, 0x40180014, 0x00800f09, 0x12020808, 0x2f00020b, 0xa682332f, 0x1a332f2e, 0x173031cc, 0x1e332734, 0x06141503, 0x08947b18, 0xdb363a08,
    0x391a818b, 0x64651e2f, 0x0e1a401d, 0x3422192d, 0x138569ee, 0x2a4b4034, 0x0808685a, 0x2b050471, 0x10000100, 0x77016dfe, 0x1100a600, 0x09b61200,
    0x060d1001, 0x2f0000fa, 0x2056833f, 0x070879c4, 0x0806fe7a, 0x11353622, 0x1a017701, 0x263f5939, 0x3b0e163f, 0xa6322e22, 0x6642d9fe, 0x09112446,
    0x310e0796, 0x003c0131, 0x9a204f88, 0x9a224fb4, 0x4f8be5fe, 0xf0823020, 0x1b220282, 0x57824a01, 0x02820882, 0x03823420, 0x03820120, 0x0a226983,
    0x17863400, 0x07000224, 0x0b863e00, 0x15000324, 0x0b864500, 0x89000421, 0x00052423, 0x865a000c, 0x00062417, 0x86660009, 0x0007240b, 0x866f004e,
    0x0008240b, 0x86bd0014, 0x000a240b, 0x86d10067, 0x000d240b, 0x8638012e, 0x000e230b, 0x3b87012a, 0x5f841220, 0x01000324, 0x93820904, 0x90016823,
    0x240b8500, 0x01140001, 0x240b86f8, 0x020e0002, 0x240b860c, 0x022a0003, 0x200b861a, 0x24238a04, 0x022c0005, 0x24178644, 0x02120006, 0x240b8670,
    0x029c0007, 0x240b8682, 0x03280008, 0x240b861e, 0x03ce000a, 0x240b8646, 0x0438000b, 0x240b8614, 0x045c000c, 0x200b864c, 0x200b820d, 0x080b86a8,
    0x54000e54, 0x69440405, 0x69746967, 0x2064657a, 0x61746164, 0x706f6320, 0x67697279, 0xa9207468, 0x30303220, 0x47202c37, 0x6c676f6f, 0x6f432065,
    0x726f7072, 0x6f697461, 0x72442e6e, 0x2064696f, 0x736e6153, 0x75676552, 0x4172616c, 0x6e656373, 0x20726564, 0x1b89202d, 0x72655623, 0x242d8273,
    0x302e3120, 0x83158430, 0x31088430, 0x20736920, 0x72742061, 0x6d656461, 0x206b7261, 0x6587666f, 0x646e6132, 0x79616d20, 0x20656220, 0x69676572,
    0x72657473, 0x69279982, 0x6563206e, 0x82617472, 0x756a2707, 0x64736972, 0x87836369, 0x882e7321, 0x899d8a77, 0x24668580, 0x616d7568, 0x2149826e,
    0xaf827320, 0x65732035, 0x20666972, 0x65707974, 0x65636166, 0x73656420, 0x826e6769, 0x6f662462, 0x82752072, 0x6920221c, 0x8373826e, 0x2073211b,
    0x652f8c83, 0x7463656c, 0x696e6f72, 0x6f632063, 0x82756d6d, 0x05034108, 0x82694c21, 0x827320f2, 0x84752039, 0x687427f8, 0x70412065, 0x06826361,
    0x2c211986, 0x07004120, 0x302e322e, 0x70747468, 0x772f2f3a, 0x612e7777, 0x2e252584, 0x2f67726f, 0x2943856c, 0x494c2f73, 0x534e4543, 0x29822d45,
    0x00440025, 0x82670069, 0x82742003, 0x007a2603, 0x00640065, 0x24038220, 0x00740061, 0x28098261, 0x006f0063, 0x00790070, 0x20258472, 0x22158268,
    0x82a90020, 0x00322217, 0x22018230, 0x822c0037, 0x8247200b, 0x826f2023, 0x826c2043, 0x0020223d, 0x200d8243, 0x20338272, 0x8333826f, 0x82692045,
    0x006e220f, 0x2067822e, 0x20098272, 0x205f8469, 0x245b8253, 0x0073006e, 0x26318252, 0x00750067, 0x8261006c, 0x8241202d, 0x82632011, 0x826e2011,
    0x82652023, 0x0020220f, 0x205d822d, 0x20098244, 0x837d826f, 0x20378797, 0x20258256, 0x852d8272, 0x0020225b, 0x835f8231, 0x0020228f, 0x204d8262,
    0x204f8269, 0x20398264, 0x20178231, 0x87778a33, 0x20518b3d, 0x20458269, 0x20e98420, 0x20af8474, 0x20598264, 0x208d846d, 0x2241826b, 0x9066006f,
    0x006121df, 0x20219f83, 0x20258300, 0x201d8279, 0x20f58462, 0x83c98472, 0x8474204d, 0x0547419b, 0x2b826920, 0x63002022, 0x74201184, 0x0f855582,
    0xa3826a20, 0xd1827220, 0x64007322, 0x63220582, 0x05827400, 0x29826f20, 0xc5827320, 0x41110341, 0x1541154f, 0x84202013, 0x20cd8553, 0x83638268,
    0x846e20a1, 0x82742013, 0x827320a7, 0x846e207f, 0x847320ed, 0x8469208f, 0x007424db, 0x82700079, 0x8266200f, 0x8463201d, 0x826420c9, 0x82732005,
    0x82672035, 0x24c58591, 0x006f0066, 0x20418272, 0x413d8275, 0xc7830597, 0x45847420, 0x73203787, 0x19411f82, 0x00652207, 0x831b826c, 0x827220d7,
    0x20818339, 0x06494263, 0x6d006d22, 0x11859782, 0x220b1b42, 0x82740068, 0x00702401, 0x822f003a, 0x00772101, 0x2e200183, 0x73219182, 0x0b0f4200,
    0x87846320, 0x2e007022, 0x6f201582, 0x2f214982, 0x8737b700, 0x20eb8df5, 0x20df8272, 0x2053842e, 0x22c1826d, 0x8669004c, 0x8273207d, 0x846420cd,
    0x099942ff, 0x27827420, 0x13826520, 0x70004122, 0x6320a782, 0x338d0d86, 0x1f822c20, 0x200fa942, 0x20bd8232, 0x89b79830, 0x842e204b, 0x006722eb,
    0x8b89822f, 0x82732087, 0x004c2a11, 0x00430049, 0x004e0045, 0x21058253, 0x5385002d, 0x02000023, 0x23008400, 0x660066ff, 0x048e0884, 0x00820325,
    0x82020100, 0x03380825, 0x05000400, 0x07000600, 0x09000800, 0x0b000a00, 0x0d000c00, 0x0f000e00, 0x11001000, 0x13001200, 0x15001400, 0x17001600,
    0x19001800, 0x1b001a00, 0x1d001c00, 0x1f001e00, 0x2130cf82, 0x23002200, 0x25002400, 0x27002600, 0x29002800, 0x7061c619, 0x00ac6f0e, 0x008400a3,
    0x00bd0085, 0x00e80096, 0x008e0086, 0x009d008b, 0x01a400a9, 0x018a0003, 0x00830004, 0x00f20093, 0x008d00f3, 0x01880097, 0x00de0005, 0x009e00f1,
    0x00f500aa, 0x00f600f4, 0x00ad00a2, 0x00c700c9, 0x006200ae, 0x00900063, 0x00cb0064, 0x00c80065, 0x00cf00ca, 0x00cd00cc, 0x00e900ce, 0x00d30066,
    0x00d100d0, 0x006700af, 0x009100f0, 0x00d400d6, 0x006800d5, 0x00ed00eb, 0x006a0089, 0x006b0069, 0x006c006d, 0x00a0006e, 0x0071006f, 0x00720070,
    0x00750073, 0x00760074, 0x00ea0077, 0x007a0078, 0x007b0079, 0x007c007d, 0x00a100b8, 0x007e007f, 0x00810080, 0x00ee00ec, 0x010601ba, 0x01080107,
    0x010a0109, 0x00fd000b, 0x010c01fe, 0x010e010d, 0x01ff000f, 0x01100100, 0x01120111, 0x01140113, 0x01160115, 0x01180117, 0x011a0119, 0x011c011b,
    0x011e011d, 0x00f8001f, 0x012001f9, 0x01220121, 0x01240123, 0x01260125, 0x01280127, 0x012a0129, 0x012c012b, 0x012e012d, 0x0030012f, 0x013101d7,
    0x01330132, 0x01350134, 0x01370136, 0x01390138, 0x013b013a, 0x013d013c, 0x003f013e, 0x01e300e2, 0x01410140, 0x01430142, 0x01450144, 0x01470146,
    0x01490148, 0x014b014a, 0x014d014c, 0x00b0004e, 0x014f01b1, 0x01510150, 0x01530152, 0x01550154, 0x01570156, 0x00fb0058, 0x00e400fc, 0x015901e5,
    0x015b015a, 0x015d015c, 0x015f015e, 0x01610160, 0x01630162, 0x01650164, 0x01670166, 0x01690168, 0x016b016a, 0x016d016c, 0x01bb006e, 0x0170016f,
    0x00720171, 0x01e700e6, 0x01a60073, 0x01750174, 0x01770176, 0x01790178, 0x007b017a, 0x01e100d8, 0x00db007c, 0x00dd00dc, 0x00d900e0, 0x017d01df,
    0x017f017e, 0x01810180, 0x01830182, 0x01850184, 0x01870186, 0x01890188, 0x018b018a, 0x018d018c, 0x018f018e, 0x01910190, 0x01930192, 0x01950194,
    0x01970196, 0x01990198, 0x019b019a, 0x019d019c, 0x019f019e, 0x01a101a0, 0x01a301a2, 0x01a501a4, 0x01a701a6, 0x01a901a8, 0x01ab01aa, 0x01ad01ac,
    0x01af01ae, 0x01b101b0, 0x01b301b2, 0x00b501b4, 0x01b6019b, 0x01b801b7, 0x01ba01b9, 0x01bc01bb, 0x01be01bd, 0x01c001bf, 0x01c201c1, 0x01c401c3,
    0x01c601c5, 0x01c801c7, 0x01ca01c9, 0x01cc01cb, 0x01ce01cd, 0x01d001cf, 0x01d201d1, 0x01d401d3, 0x01d601d5, 0x01d801d7, 0x01da01d9, 0x01dc01db,
    0x01de01dd, 0x01e001df, 0x01e201e1, 0x01e401e3, 0x01e601e5, 0x01e801e7, 0x01ea01e9, 0x01ec01eb, 0x01ee01ed, 0x01f001ef, 0x01f201f1, 0x01f401f3,
    0x01f601f5, 0x01f801f7, 0x01fa01f9, 0x01fc01fb, 0x01fe01fd, 0x020002ff, 0x02020201, 0x02040203, 0x02060205, 0x02080207, 0x020a0209, 0x020c020b,
    0x020e020d, 0x0210020f, 0x02120211, 0x02140213, 0x02160215, 0x02180217, 0x021a0219, 0x021c021b, 0x021e021d, 0x0220021f, 0x02220221, 0x02240223,
    0x02260225, 0x02280227, 0x00b20029, 0x022a02b3, 0x00b6002b, 0x02c400b7, 0x00b4002c, 0x00c500b5, 0x00c20082, 0x00ab0087, 0x022d02c6, 0x00be002e,
    0x002f02bf, 0x003002bc, 0x023102f7, 0x02330232, 0x02350234, 0x008c0036, 0x0237029f, 0x02390238, 0x003b023a, 0x003c0298, 0x0099009a, 0x00a500ef,
    0x009c0092, 0x008f00a7, 0x00950094, 0x023d02b9, 0x023f023e, 0x02410240, 0x02430242, 0x02450244, 0x02470246, 0x02490248, 0x024b024a, 0x024d024c,
    0x024f024e, 0x02510250, 0x02530252, 0x02550254, 0x02570256, 0x02590258, 0x025b025a, 0x025d025c, 0x025f025e, 0x02610260, 0x02630262, 0x02650264,
    0x02670266, 0x02690268, 0x026b026a, 0x026d026c, 0x026f026e, 0x02710270, 0x02730272, 0x02750274, 0x02770276, 0x02790278, 0x027b027a, 0x027d027c,
    0x027f027e, 0x02810280, 0x02830282, 0x02850284, 0x02870286, 0x02890288, 0x028b028a, 0x028d028c, 0x028f028e, 0x02910290, 0x02930292, 0x02950294,
    0x02970296, 0x02990298, 0x029b029a, 0x029d029c, 0x029f029e, 0x02a102a0, 0x02a302a2, 0x02a502a4, 0x02a702a6, 0x02a902a8, 0x02ab02aa, 0x02ad02ac,
    0x02af02ae, 0x02b102b0, 0x02b302b2, 0x02b502b4, 0x02b702b6, 0x02b902b8, 0x02bb02ba, 0x02bd02bc, 0x02bf02be, 0x02c102c0, 0x02c302c2, 0x02c502c4,
    0x02c702c6, 0x02c902c8, 0x02cb02ca, 0x02cd02cc, 0x02cf02ce, 0x02d102d0, 0x02d302d2, 0x02d502d4, 0x02d702d6, 0x02d902d8, 0x02db02da, 0x02dd02dc,
    0x02df02de, 0x02e102e0, 0x02e302e2, 0x02e502e4, 0x02e702e6, 0x02e902e8, 0x02eb02ea, 0x02ed02ec, 0x02ef02ee, 0x02f102f0, 0x02f302f2, 0x02f502f4,
    0x02f702f6, 0x02f902f8, 0x02fb02fa, 0x02fd02fc, 0x03ff02fe, 0x03010300, 0x03030302, 0x03050304, 0x03070306, 0x03090308, 0x030b030a, 0x030d030c,
    0x030f030e, 0x03110310, 0x03130312, 0x03150314, 0x03170316, 0x03190318, 0x031b031a, 0x031d031c, 0x031f031e, 0x03210320, 0x03230322, 0x03250324,
    0x03270326, 0x03290328, 0x032b032a, 0x032d032c, 0x032f032e, 0x03310330, 0x03330332, 0x03350334, 0x03370336, 0x03390338, 0x033b033a, 0x033d033c,
    0x033f033e, 0x03410340, 0x03430342, 0x03450344, 0x03470346, 0x03490348, 0x034b034a, 0x034d034c, 0x034f034e, 0x03510350, 0x03530352, 0x03550354,
    0x03570356, 0x03590358, 0x035b035a, 0x035d035c, 0x035f035e, 0x03610360, 0x03630362, 0x03650364, 0x03670366, 0x03690368, 0x036b036a, 0x036d036c,
    0x036f036e, 0x03710370, 0x03730372, 0x03750374, 0x03770376, 0x03790378, 0x037b037a, 0x037d037c, 0x037f037e, 0x03810380, 0x03830382, 0x03850384,
    0x03870386, 0x03890388, 0x6e2e058a, 0x076c6c75, 0x30696e75, 0x09444130, 0x7265766f, 0x726f6373, 0x65700e65, 0x646f6972, 0x746e6563, 0x64657265,
    0x616d4107, 0x6e6f7263, 0x07856107, 0x62410628, 0x65766572, 0x06846106, 0x6f410729, 0x656e6f67, 0x8561076b, 0x430b2d07, 0x63726963, 0x6c666d75,
    0x630b7865, 0x04260b89, 0x746f6443, 0x04826304, 0x63440623, 0x214e8261, 0x06856406, 0x72634425, 0x8274616f, 0x2106830d, 0x63854507, 0x85650721,
    0x45062107, 0x06216484, 0x21068465, 0x3e82450a, 0x83636121, 0x650a2198, 0x07210a88, 0x21798545, 0x07856507, 0x85450621, 0x84652058, 0x470b2106,
    0x0b218389, 0x210b8967, 0x40824704, 0x82670421, 0x470c2604, 0x6d6d6f63, 0x21578561, 0x0c8a670c, 0x89480b21, 0x680b212f, 0x04260b89, 0x72616248,
    0x04826804, 0x74490628, 0x65646c69, 0x06846906, 0x85490721, 0x690721b5, 0x06210785, 0x21b68449, 0x06846906, 0x85490721, 0x6907219f, 0x0a210785,
    0x27c28849, 0x024a4902, 0x4a0b6a69, 0x0b216289, 0x210b896a, 0x938a4b0c, 0x8c6b0c21, 0x7267330c, 0x6c6e6565, 0x69646e61, 0x614c0663, 0x65747563,
    0x06846c06, 0x8b4c0c21, 0x8a6c2027, 0x4c06280c, 0x6f726163, 0x846c066e, 0x4c042106, 0x04218582, 0x2104826c, 0x3f854e06, 0x3f856e20, 0x328a4e20,
    0x8a6e0c21, 0x4e06210c, 0x06213884, 0x3506846e, 0x70616e0b, 0x7274736f, 0x6568706f, 0x676e4503, 0x676e6503, 0xff854f07, 0x856f0721, 0x4f062807,
    0x76657262, 0x846f0665, 0x4f0d2f06, 0x676e7568, 0x6d757261, 0x7475616c, 0x0d8b6f0d, 0x84520621, 0x7206217c, 0x0c210684, 0x21768a52, 0x0c8a720c,
    0x84520621, 0x7206217c, 0x53200685, 0x06212e84, 0x21068473, 0x3a41530b, 0x730b2109, 0x0c210b89, 0x21408a54, 0x0c8a740c, 0x85540621, 0x84742046,
    0x54042606, 0x04726162, 0x28048274, 0x69745506, 0x0665646c, 0x21068475, 0xcd855507, 0x85750721, 0x55062107, 0x0621ce84, 0x27068475, 0x69725505,
    0x7505676e, 0x0d210583, 0x20e18c55, 0x210d8b75, 0xfd415507, 0x75072105, 0x0b210785, 0x21a18957, 0x0b8a770b, 0x0b8a5920, 0x0b897920, 0x845a0621,
    0x7a0621e4, 0x0a210684, 0x0843425a, 0x887a0a21, 0x6c05270a, 0x73676e6f, 0x8b83410a, 0x61202685, 0x07220a88, 0x12844541, 0x65610722, 0x0b260784,
    0x616c734f, 0x0b856873, 0x0b896f20, 0x41530c21, 0x0c210a20, 0x200c8a73, 0x2efe8506, 0x6e6f7405, 0x640d736f, 0x65726569, 0x84736973, 0x410a250d,
    0x6168706c, 0x092e0a84, 0x746f6e61, 0x69656c65, 0x70450c61, 0x91826973, 0x08221684, 0x1f867445, 0x866f4921, 0x4f0c2709, 0x7263696d, 0x1f846e6f,
    0x8a550c21, 0x4f0a242c, 0x8567656d, 0x6911212e, 0x6b8c2e82, 0x6b840520, 0x65420433, 0x47056174, 0x616d6d61, 0x696e7507, 0x34393330, 0x216f8607,
    0x1a825a04, 0x6f820320, 0x68540522, 0x04200982, 0x05367083, 0x7070614b, 0x614c0661, 0x6164626d, 0x02754d02, 0x5802754e, 0x81860769, 0x69500231,
    0x6f685203, 0x67695305, 0x5403616d, 0x86077561, 0x5003258d, 0x43036968, 0x50220382, 0x66856973, 0x0c394122, 0x91874f83, 0x28860f20, 0x0a210f87,
    0x08084161, 0x8a650c21, 0x820820d1, 0x20e78488, 0x84cf8309, 0x75142109, 0xdc8d1f85, 0x04213f84, 0x212e8262, 0xdc836705, 0x65640526, 0x0761746c,
    0x04214b86, 0x2018827a, 0x21038203, 0xda847405, 0x05214c83, 0x20da846b, 0x85da846c, 0x434229a4, 0x02756e02, 0x6f076978, 0x25056141, 0x6f687203,
    0xdc837306, 0x84053121, 0x74032106, 0x7f86e382, 0x82700321, 0x826320df, 0x268e8203, 0x656d6f05, 0x410c6167, 0x0f200b73, 0x0c20a68e, 0xc3845386,
    0x1c860c20, 0x0a200c84, 0x0a843c84, 0x66610929, 0x30316969, 0x87333230, 0x31352109, 0x32200988, 0x1d890988, 0x13883420, 0x09883520, 0x09883620,
    0x09883720, 0x09883820, 0x09873920, 0x88303621, 0x20638809, 0x21638736, 0x4f883431, 0x45883120, 0x45883120, 0x45883120, 0x45883220, 0x45883220,
    0xa9883220, 0x9f883220, 0x4f883220, 0x9f883220, 0x59883220, 0x59883220, 0x59883220, 0x59883320, 0x59883320, 0x59883320, 0x03413320, 0x88332008,
    0x88332063, 0x88332063, 0x88332063, 0x88332063, 0x88332063, 0x88342063, 0x88342063, 0x88342063, 0x88342063, 0x88342063, 0x09174163, 0x63883420,
    0x63883420, 0x63883420, 0x63883420, 0x95883620, 0x31883620, 0x31883620, 0x31883620, 0x31883620, 0x95883720, 0x8b883720, 0x8b883720, 0x8b883720,
    0x59883720, 0x59883720, 0x59883720, 0x59883720, 0x59883720, 0x59883820, 0xef883820, 0x63883820, 0x63883820, 0x63883820, 0x63883820, 0x63883820,
    0x63883820, 0x63883820, 0x63883820, 0x63883920, 0x63883920, 0x63883920, 0x63883920, 0x63883920, 0x63883920, 0x63883920, 0x63883920, 0x45893720,
    0x31216387, 0x21638730, 0x1d873031, 0x42303121, 0x302008bb, 0x31216387, 0x21638730, 0x63873031, 0x87303121, 0x30312163, 0x31216387, 0x21c78730,
    0x63883031, 0x63883120, 0x3520b389, 0x3829db89, 0x72675706, 0x06657661, 0x24068577, 0x75636157, 0x840d8274, 0x57092106, 0x21079d44, 0x09877709,
    0x85590621, 0x84792028, 0x61092d06, 0x30696966, 0x38303230, 0x646e750d, 0x2b06484a, 0x0d6c6264, 0x746f7571, 0x76657265, 0x65251282, 0x696d0664,
    0x2c55836e, 0x6f636573, 0x6509646e, 0x616c6378, 0x2925826d, 0x75736e09, 0x69726570, 0x4785726f, 0x3439382f, 0x65700631, 0x61746573, 0x72754504,
    0x2215846f, 0x42323136, 0x0982068f, 0x3d069f41, 0x35333136, 0x73650932, 0x616d6974, 0x09646574, 0x65656e6f, 0x74686769, 0x68740c68, 0x0b866572,
    0x660b7324, 0x0b877669, 0x82730c21, 0x856e208b, 0x05732e24, 0x746c6544, 0x6e750761, 0x30424669, 0x2a078631, 0x79630d32, 0x6c6c6972, 0x83626369,
    0x64082db7, 0x656c746f, 0x106a7373, 0x6f726163, 0x200b0849, 0x0a14470b, 0x0b8a1120, 0x746f7222, 0x0c248c82, 0x6f72657a, 0x0c24d687, 0x72756f66,
    0x8e820c89, 0x0b230c87, 0x87786973, 0x840d200b, 0x840d889b, 0x233488a4, 0x656e696e, 0xa9830c87, 0x30303223, 0x84078630, 0x303223b9, 0x0f863230,
    0x07863320, 0x07863420, 0x07863520, 0x07863620, 0x07863720, 0x07863820, 0x07863920, 0x07864120, 0x07834220, 0x46454623, 0x22078446, 0x86434646,
    0x83442007, 0x31302307, 0x07843046, 0x84423221, 0x33302317, 0x0f843144, 0x84443321, 0x840f827f, 0x45312367, 0x17834533, 0x47840782, 0x85453121,
    0x840782af, 0x4631222f, 0x2b4f8534, 0x09334632, 0x69736164, 0x69786f61, 0x84078b41, 0x42462bc1, 0x4f053430, 0x6e726f68, 0x05846f05, 0x05845520,
    0x05837520, 0x51857185, 0x41333021, 0x078205bb, 0x6804332e, 0x086b6f6f, 0x62746f64, 0x776f6c65, 0x34202584, 0x34212586, 0x216f8530, 0xbf853534,
    0x86353421, 0x8636200f, 0x8436200f, 0x34302297, 0x21c78536, 0x85843634, 0x34200f82, 0x36214785, 0x84078635, 0x201782df, 0x200f8637, 0x20078638,
    0x20078639, 0x20078641, 0x41078642, 0x34210527, 0x206f8736, 0x20178645, 0x21078546, 0x07863037, 0x07863120, 0x37207f86, 0x37207f86, 0x37207f86,
    0x37207f86, 0x37207f86, 0x37207f86, 0x37207f86, 0x37207f86, 0x37207f86, 0x37207f86, 0x37207f86, 0x37207f86, 0x37207f86, 0x38217f86, 0x21778530,
    0x07863138, 0x38207f86, 0x38207f86, 0x38207f86, 0x38207f86, 0x38207f86, 0x38207786, 0x38207786, 0x38207786, 0x38207786, 0x38207786, 0x38207786,
    0x38207786, 0x39207786, 0x39206786, 0x39206786, 0x39206786, 0x39206786, 0x39206786, 0x3920e786, 0x39206f86, 0x39206f86, 0x39206f86, 0x39206f86,
    0x39206f86, 0x39206f86, 0x39206f86, 0x41216f86, 0x21df8530, 0x07863141, 0x41207f86, 0x41207f86, 0x41207f86, 0x41207f86, 0x41207f86, 0x41207f86,
    0x41207f86, 0x41207f86, 0x41207f86, 0x41207f86, 0x41207f86, 0x41207f86, 0x41207f86, 0x42217f86, 0x21778530, 0x07863142, 0x42207f86, 0x42207f86,
    0x42207f86, 0x42207f86, 0x42207f86, 0x42207f86, 0x42207f86, 0x42207f86, 0x42207f86, 0x8f437f86, 0x42342106, 0x42207f86, 0x42207f86, 0x43217f86,
    0x21778530, 0x07863143, 0x43207f86, 0x43207f86, 0x43207f86, 0x43207f86, 0x43207f86, 0x43207f86, 0x43207f86, 0x43207f86, 0x43207f86, 0x43207f86,
    0x4320ff86, 0x43207f86, 0x43207f86, 0x44217f86, 0x44778530, 0x3420062f, 0x21062f44, 0x7f864434, 0x7f864420, 0x7f864420, 0x7f864420, 0x7f864420,
    0x7f864420, 0x7f864420, 0x7f864420, 0x7f864420, 0x7f864420, 0x7f864420, 0x7f864420, 0x7f864420, 0x7f864520, 0x85314521, 0x86452087, 0x864520ff,
    0x8645207f, 0x8645207f, 0x8645207f, 0x8645207f, 0x8645207f, 0x8645207f, 0x8645207f, 0x8645207f, 0x8645207f, 0x8645207f, 0x8645207f, 0x8645207f,
    0x0637457f, 0x31463422, 0x46207f85, 0x46207f86, 0x46207f86, 0x46207f86, 0x46207f86, 0x46207f86, 0x46207f86, 0x46207f86, 0x46207f86, 0x46207f86,
    0xa7457f86, 0x34302205, 0x207f8646, 0x457f8646, 0x302105c7, 0x06074535, 0x2d453520, 0x46352006, 0x1782052f, 0x35217f85, 0x217f8530, 0x7f853035,
    0x85303521, 0x3035217f, 0x35217f85, 0x217f8530, 0x7f853035, 0x85303521, 0x3035217f, 0x35217f85, 0x21ff8530, 0x7f853035, 0x85303521, 0x3035217f,
    0x3522ff85, 0xf7843031, 0x31313522, 0xff850786, 0x84313521, 0x4531217f, 0x82059f43, 0x821f8407, 0x821f8407, 0x841f8707, 0x840f829f, 0x8407829f,
    0x8407829f, 0x8407829f, 0x8407829f, 0x8407829f, 0x8407829f, 0x8407829f, 0x8407829f, 0x8407829f, 0x8407829f, 0x4531219f, 0x82059f43, 0x46312007,
    0x422005b7, 0x9f437f86, 0x86178205, 0x059f437f, 0x7f860f82, 0x82059f43, 0x437f860f, 0x0f82059f, 0x9f437f86, 0x860f8205, 0x059f437f, 0x7f860f82,
    0x21059f43, 0x9f434531, 0x86078205, 0x8643207f, 0x059f437f, 0x7f861782, 0x82059f43, 0x437f860f, 0x0f82059f, 0x9f437f86, 0x860f8205, 0x059f437f,
    0x7f860f82, 0x82059f43, 0x437f860f, 0x3121059f, 0x059f4345, 0x7f860782, 0x82059f43, 0x067f410f, 0x82059f43, 0x067f410f, 0x82059f43, 0x067f410f,
    0x82059f43, 0x067f410f, 0x82059f43, 0x067f410f, 0x82059f43, 0x067f410f, 0x82059f43, 0x067f410f, 0x21059f43, 0x9f434531, 0x86078205, 0x059f43ff,
    0xff860f82, 0x82059f43, 0x43ff860f, 0x0f82059f, 0x9f43ff86, 0x860f8205, 0x059f43ff, 0xff860f82, 0x82059f43, 0x43ff860f, 0x3121059f, 0x059f4345,
    0x31200782, 0x4305ff41, 0x0f82058f, 0x8f43ef86, 0x860f8205, 0x058f43ef, 0xef840f82, 0x46303221, 0x33230607, 0x51134630, 0x612809af, 0x65747563,
    0x626d6f63, 0x6723138a, 0x84766172, 0x89122013, 0x6f682327, 0x268e6b6f, 0x6c697423, 0x25268464, 0x6572620e, 0x49886576, 0x44880e85, 0x1d840d20,
    0x1c853f87, 0x10203a88, 0x8307cb4a, 0x656c241f, 0x4a117466, 0x692108dc, 0x21138367, 0x118f4355, 0x00434c22, 0x022a0082, 0x02000500, 0x0300ffff,
    0x0d820100, 0x03820c20, 0x15841620, 0x03210d82, 0x20138281, 0x820d8204, 0x2e05860b, 0x001e000a, 0x6c01002c, 0x006e7461, 0x82040008, 0x82002015,
    0x8201203b, 0x6b012307, 0x13837265, 0x84000021, 0x201b820d, 0x20218202, 0x21038301, 0x0d823aa5, 0x01003808, 0x03ea03f0, 0x074c07ea, 0x07d4085a,
    0x0a32095a, 0x0c220bc0, 0x0e3e0d10, 0x0f0a0f24, 0x127e11f0, 0x148213ac, 0x19de14b0, 0x1dee1960, 0x23362190, 0x07822768, 0x8268284c, 0x826e2001,
    0x29802603, 0x2930291a, 0x08098236, 0x48296830, 0x6e285629, 0xea29d429, 0x002aea29, 0xf02ada2a, 0xba2b4c07, 0xd62bc82b, 0x242e242e, 0x6630d62b,
    0x220bac32, 0xe435fe34, 0xfe34fe34, 0x0185240e, 0x37c23623, 0x23018744, 0x9e387e11, 0x39210185, 0x836184a8, 0x25038265, 0x6e284829, 0x0186623e,
    0x7a3e6c22, 0x29230187, 0x86943e48, 0x409e2601, 0x28320924, 0x27038368, 0x68284240, 0x6e28220b, 0x07830183, 0x85d44121, 0x5242214b, 0x0e230783,
    0x83584224, 0x362923db, 0x0183f00f, 0x83d44121, 0x21218505, 0xc3827e11, 0x05854820, 0x43293f85, 0x446e2842, 0x414c444c, 0x20ff82d4, 0x31038360,
    0xea29901d, 0xda2a6823, 0x8227c248, 0x384d8227, 0x73834e50, 0x6e283f08, 0x4a511c51, 0x86515851, 0x26521852, 0xca538c52, 0xee552854, 0xda58b858,
    0x0a5af459, 0xf25db45a, 0x1a5f005e, 0x9a60f45f, 0xf6644064, 0x7e652065, 0xbe65b065, 0x2a6a7066, 0x6828306a, 0x07824a6a, 0xa26a9c38, 0xda6ad06a,
    0x6828086b, 0xbc6b7a6b, 0x186ce26b, 0x446c366c, 0x03825a6c, 0x8a6c6c2c, 0xd66cc46c, 0x2c6d4829, 0xa3833e6d, 0x8c6d8d08, 0x646f6e6e, 0x3473b672,
    0xb4734a73, 0x64759274, 0xa0762a76, 0xf4795678, 0xc47c1a7c, 0x887f4a7d, 0x58819280, 0x2483f281, 0x94857e84, 0xe88b9e86, 0x208e768d, 0x9c8fda8e,
    0x10919690, 0x20929291, 0xfc929692, 0x14948293, 0x74943294, 0x2c95aa94, 0x2896a295, 0x0097b296, 0x20985e97, 0x2499b298, 0xf0999a99, 0x6e284a9a,
    0x229bb09a, 0x6e28689b, 0xb89baa9b, 0x6e286e28, 0x349c2a9c, 0x389dba9c, 0xb09d3e9d, 0x1494269e, 0xea29901d, 0x23250387, 0xa1da2a68, 0x08018290,
    0x9ea19e20, 0x32093209, 0xeea4aca4, 0x24837494, 0x10912098, 0x94852896, 0xf4790097, 0x9280f479, 0x0383aa94, 0x96248325, 0x837e8428, 0xe88b2305,
    0x03832098, 0x20207982, 0x03850f83, 0xa5209827, 0x99da8e30, 0x293b839a, 0x28967e84, 0x5e979e86, 0x11832a76, 0x83289621, 0x83478705, 0x850f8307,
    0x833b831f, 0x230d8369, 0x20989e86, 0x1d830383, 0x76270387, 0x8324832a, 0x834a7324, 0x874d8535, 0x4a732119, 0x94219d83, 0x21b18374, 0x47832896,
    0x3183a587, 0x99851185, 0x87289621, 0x850783b1, 0x5e972169, 0xd1859387, 0xcd89a385, 0x99833f85, 0x09212783, 0x42019532, 0xad420bf5, 0x240e2505,
    0x48297e11, 0xa4210397, 0x250187ac, 0x60196019, 0x0187eea4, 0x2a682323, 0x2f0387da, 0x2400d800, 0x2c00aeff, 0x37002900, 0x39005200, 0x3a240382,
    0x3b006600, 0x3c200f82, 0x3d200b82, 0x46240782, 0x4700c3ff, 0x48200382, 0x4a240382, 0x5200d7ff, 0x54200782, 0x57200382, 0x59201b82, 0x5a240382,
    0x5c001400, 0x82200782, 0x83204782, 0x84200382, 0x85200382, 0x86200382, 0x87200382, 0x88240382, 0x8e005cff, 0x8f201f82, 0x90200382, 0x91200382,
    0x9f200382, 0xa8205b82, 0xa9204382, 0xaa200382, 0xab200382, 0xac200382, 0xad200382, 0xb4200382, 0xb5200382, 0xb6200382, 0xb7200382, 0xb8200382,
    0xba200382, 0xbf200382, 0xc1203782, 0xc2200382, 0xc4205382, 0xc6200382, 0xc9200382, 0xcb201782, 0xcd200382, 0xcf200382, 0xd5200382, 0xd7200382,
    0xd9200382, 0xdb200382, 0xdd200382, 0xec200382, 0xf0203382, 0xf2280382, 0x0f012900, 0x1101c3ff, 0x13200382, 0x15200382, 0x24240382, 0x26015200,
    0x36280382, 0x37016600, 0x38011400, 0x39200b82, 0x3a202782, 0x3b200782, 0xff820782, 0x823f0121, 0xff432407, 0x825f01ae, 0x82692003, 0x82712003,
    0x8279201b, 0x827e203b, 0x82802003, 0x8282201b, 0x828a2007, 0x828c2007, 0x828e2007, 0x82902003, 0x21e38203, 0x07829301, 0x17829420, 0x07829620,
    0x03829920, 0x03829b20, 0x3b829d20, 0x9affa424, 0x0782a601, 0x3d00a824, 0x4f82aa01, 0x85ffae24, 0x0b82b001, 0x7f82b120, 0x0b82b520, 0x1b82bc20,
    0x0f82bd20, 0x0121ef82, 0x820b82c4, 0xd80121d7, 0xdb203b82, 0xdc200382, 0xdd204f82, 0xde200382, 0xea200b82, 0xed200382, 0xfa200382, 0xfb20bb82,
    0xfc203b82, 0xfd200782, 0xfe200782, 0xff300782, 0x00021400, 0x01025200, 0x28022900, 0x5802aeff, 0x60240382, 0x6a02c3ff, 0x6d200382, 0x72201382,
    0x76240f82, 0x7f023d00, 0x81200f82, 0x83200f82, 0x85200382, 0x87200b82, 0x89200382, 0x8b200382, 0x8d200f82, 0x9f200782, 0xa9202382, 0xaa204782,
    0xb2200f82, 0xb4200f82, 0xb5200382, 0xb6200f82, 0xb7200f82, 0xb8200782, 0xb9200782, 0xba200782, 0xbb200782, 0xbd202b82, 0xca200b82, 0xce240782,
    0xd90285ff, 0xdb206382, 0xdd200382, 0xe0200382, 0xe5203782, 0xf0201782, 0xf2200782, 0xf4200382, 0xf7200382, 0xf8200f82, 0xf9203782, 0xfa200782,
    0xfb200782, 0xfc280782, 0x05032900, 0x07033d00, 0x0a240382, 0x0c03c3ff, 0x0e200382, 0x10201382, 0x11240382, 0x160385ff, 0x17240f82, 0x18035200,
    0x1a200f82, 0x1b200b82, 0x1d241382, 0x1f03aeff, 0x21200382, 0x23200382, 0x25200382, 0x27200382, 0x29200382, 0x2b200382, 0x2d200382, 0x2f200382,
    0x31200382, 0x33200382, 0x36200382, 0x38203782, 0x3a200382, 0x3c200382, 0x3e200382, 0x40200382, 0x42200382, 0x44200382, 0x45200382, 0x47205b82,
    0x4a200382, 0x4c200b82, 0x4e200382, 0x50200382, 0x52200382, 0x54200382, 0x56200382, 0x58200382, 0x5a200382, 0x5c200382, 0x5e200382, 0x60200382,
    0x6f200382, 0x70209782, 0x71203782, 0x72200782, 0x73200782, 0x742e0782, 0x03002900, 0x7b002d00, 0x7b00f600, 0x0782a301, 0x26005e26, 0x2a00c3ff,
    0x32200382, 0x34200382, 0x37280382, 0x38009aff, 0x3900d7ff, 0x3a240782, 0x3c00aeff, 0x89200782, 0x94201782, 0x95200382, 0x96200382, 0x97200382,
    0x98200382, 0x9a200382, 0x9b200382, 0x9c202b82, 0x9d200382, 0x9e200382, 0x9f200382, 0xc8202f82, 0xce201782, 0xde200382, 0xe0200382, 0xe2200382,
    0xe4240382, 0x0e01c3ff, 0x12200382, 0x24240382, 0x26019aff, 0x2c240382, 0x3001d7ff, 0x32200382, 0x34200382, 0x36240382, 0x3801aeff, 0x3a201782,
    0x66200382, 0x6d202782, 0x71200382, 0xb8200b82, 0xbb200782, 0xbc200382, 0xfa200b82, 0xfc202382, 0xfe300382, 0x0002aeff, 0x5f029aff, 0x6102c3ff,
    0x6c02d7ff, 0x7e200782, 0x84200382, 0x86200382, 0x88200382, 0x8a200382, 0x8c200382, 0xa9200382, 0xb1202782, 0xb3200782, 0xb5200382, 0xb7200b82,
    0xb9200382, 0xbd200382, 0xe1200382, 0xe3201382, 0xef200382, 0xf1200382, 0xf3240382, 0x1503c3ff, 0x17240382, 0x19039aff, 0x49200782, 0x4b200382,
    0x4d200382, 0x4f200382, 0x51200382, 0x53200382, 0x55200382, 0x57200382, 0x59200382, 0x5b200382, 0x5d200382, 0x8b820382, 0xff610325, 0x826303d7,
    0x82652003, 0x82672003, 0x82692003, 0x826b2003, 0x826d2003, 0x826f2003, 0x82712053, 0xff732603, 0x0017009a, 0x82cd8237, 0x7201250d, 0xb001c3ff,
    0xb520fd82, 0xe1830382, 0xd982c420, 0xd1827620, 0x03829f20, 0xb18bb983, 0x1382bb20, 0xb582bd20, 0x0782ca20, 0x0382ce20, 0x5582e520, 0x03820520,
    0x03820720, 0x03821120, 0x1b2ab583, 0x6300d7ff, 0xaeff0500, 0x03820a00, 0xecff2624, 0x03822a00, 0x03823220, 0x03823420, 0x85ff3724, 0x07823800,
    0xc3ff3924, 0x29823a00, 0x2205df41, 0x829400ec, 0x82952013, 0x82962003, 0x82972003, 0x82982003, 0x829a2003, 0x829b2003, 0x829c2003, 0x829d2003,
    0x829e2003, 0x05df4103, 0xce00ec22, 0xde200b82, 0xe0200382, 0xe2200382, 0xe4240382, 0x0e01ecff, 0x12200382, 0x14200382, 0x2424c982, 0x260185ff,
    0x2c200382, 0x30200f82, 0x32200382, 0x34200382, 0x36200382, 0xe3411b82, 0x01ec2209, 0x2013826d, 0x20278271, 0x200782b8, 0x200382bb, 0x200b82bc,
    0x202382fa, 0x200382fc, 0x20e182fe, 0x24ed8200, 0x02aeff07, 0x2403820b, 0x02ecff5f, 0x20038261, 0x2003826c, 0x2003827e, 0x20038284, 0x20038286,
    0x20038288, 0x2003828a, 0x2403828c, 0x0285ffa9, 0x200782b1, 0x200382b3, 0x200b82b5, 0x200382b7, 0x200382b9, 0x200382bd, 0x201382e1, 0x200382e3,
    0x200382ef, 0x240382f1, 0x03ecfff3, 0x24038215, 0x0385ff17, 0x20078219, 0x20038249, 0x2003824b, 0x2003824d, 0x2003824f, 0x20038251, 0x20038253,
    0x20038255, 0x20038257, 0x20038259, 0x2003825b, 0x2003825d, 0x2003825f, 0x20038261, 0x20038263, 0x20038265, 0x20038267, 0x20038269, 0x2003826b,
    0x4103826d, 0x18260beb, 0xecff2c00, 0x03823700, 0x03823920, 0x03823b20, 0x03823c20, 0xed829f20, 0x03822420, 0x03822620, 0x03823820, 0x03823a20,
    0x03827120, 0x9982bc20, 0xc9840020, 0xb502ec22, 0xb7200782, 0xb9200382, 0xbd200382, 0xec22a984, 0x07824503, 0x61844720, 0x8203ec21, 0x7303212f,
    0x3b264b82, 0x29000500, 0x03820a00, 0x03820c20, 0xd7ff2624, 0x03822a00, 0x03823220, 0x03823420, 0x13824020, 0x03826020, 0x0b828920, 0x03829420,
    0x03829520, 0x03829620, 0x03829720, 0x03829820, 0x03829a20, 0x0382c820, 0x0382ce20, 0x0382de20, 0x0382e020, 0x0382e220, 0xd7ffe424, 0x03820e01,
    0x03821220, 0x03826620, 0x03826d20, 0x0382b820, 0xd7ffbb28, 0x29000702, 0x03820b02, 0x0b825f20, 0x03826c20, 0x03827e20, 0x03828420, 0x03828620,
    0x03828820, 0x03828a20, 0x03828c20, 0x0382b120, 0x0382b320, 0x0382e120, 0x0382e320, 0x0382ef20, 0x0382f120, 0xd7fff324, 0x03821503, 0x03821920,
    0x03824920, 0x03824b20, 0x03824d20, 0x03824f20, 0x03825120, 0x03825320, 0x03825520, 0x03825720, 0x03825920, 0x03825b20, 0x03825d20, 0x00276f82,
    0xff0f004b, 0x821100c3, 0x82242003, 0x055b41fb, 0x3900c322, 0x3a200b82, 0x22085f41, 0x823d00d7, 0x8282200b, 0x82832003, 0x82842003, 0x82852003,
    0x82862003, 0x82872003, 0x82882003, 0x828e203b, 0x828f2007, 0x82902003, 0x82912003, 0x829f2003, 0x82c220f1, 0x82c42007, 0x82c62003, 0x82ec2003,
    0x82f02003, 0xfff22803, 0xff2401ec, 0x822601c3, 0xff362803, 0xff3801ec, 0x823a01d7, 0x823b2003, 0x823d200b, 0x823f2003, 0x82432003, 0x825f2003,
    0x82692003, 0x82712003, 0x82aa2027, 0x82bc2007, 0x82fa2007, 0x82fc2007, 0xfffe2403, 0x820002ec, 0x822820f5, 0x82582007, 0x82722003, 0xffa92403,
    0x82b502c3, 0x82b72003, 0x82b92003, 0x82bd2003, 0x82d92003, 0x82db2017, 0xffdd2803, 0xff1703ec, 0x821d03c3, 0x821f2007, 0x82212003, 0x82232003,
    0x82252003, 0x82272003, 0x82292003, 0x822b2003, 0x822d2003, 0x822f2003, 0x82312003, 0x82332003, 0x091b4203, 0x7103d726, 0x7303d7ff, 0x3926d382,
    0x3d000500, 0x03820a00, 0x29000c28, 0x9aff0f00, 0x03821100, 0x0b822220, 0x1d842420, 0x3a001426, 0x3c001400, 0x27420382, 0x82822007, 0x82832017,
    0x82842003, 0x82852003, 0x82862003, 0x82872003, 0xff882403, 0x829f00c3, 0x82c22027, 0x82c4200b, 0xffc62803, 0x003601d7, 0x82380114, 0x823a2003,
    0x82432003, 0x825f200f, 0x82692003, 0x82aa2003, 0x82fa2003, 0x82fc2013, 0x00fe2403, 0x82000214, 0x00072403, 0x820b023d, 0xff282403, 0x825802d7,
    0x82722003, 0x82d92003, 0x82db2003, 0x82dd2003, 0x821d20ad, 0x821f2003, 0x82212003, 0x82232003, 0x82252003, 0x82272003, 0x82292003, 0x822b2003,
    0x822d2003, 0x822f2003, 0x82312003, 0x82332003, 0x006f2403, 0x82710314, 0x82732003, 0x43e58393, 0xf1440501, 0xff89210f, 0x2019dd44, 0x441b82c8,
    0xec231dc9, 0x44ff6601, 0xa14405a5, 0x0af94206, 0x4402ec21, 0x85441b89, 0x17754407, 0x20327144, 0x43e58b00, 0xdb430de3, 0x4314203b, 0x63268edf,
    0x9aff0500, 0x03820a00, 0x460fcb41, 0xae2409bd, 0xc3ff3a00, 0x41069d48, 0xbd4619df, 0x01ec2135, 0x2019bd46, 0x0aa148c3, 0x2917bd46, 0xfffc01c3,
    0xfffe01c3, 0xbd4602c3, 0x029a2505, 0x029aff0b, 0x45b7bd46, 0xd721176d, 0x056d4500, 0x3c00d723, 0x1f6d45ff, 0x4500d721, 0x3526e76d, 0x33ff0f00,
    0x03821100, 0x7d492420, 0x07ef4706, 0xd7ff3d23, 0x19954e00, 0x89007126, 0x9f00ecff, 0x514e0382, 0x069f440b, 0x1f480120, 0xff3b2407, 0x823d01d7,
    0x823f2003, 0x0b054e03, 0xaeffaa28, 0xecffbb01, 0x03820002, 0x2207614d, 0x4caeff72, 0x03200bf5, 0x212f994c, 0x5f48ff6f, 0x43034209, 0x0342c320,
    0x000b22e8, 0x0adb4937, 0x2107d349, 0xcf49ffa9, 0x20012714, 0x52000500, 0x03820a00, 0x9aff0f24, 0x9f471000, 0x4d85200c, 0x362c109f, 0x3700ecff,
    0x44001400, 0x460085ff, 0x47200382, 0x48200382, 0x4a200382, 0x50243782, 0x5100aeff, 0x52200382, 0x53200f82, 0x54200782, 0x55200782, 0x56200782,
    0x58200782, 0x59240782, 0x5a00c3ff, 0x5b200382, 0x5c200382, 0x5d200382, 0x82200382, 0x83201b82, 0x84200382, 0x85200382, 0x86200382, 0x87200382,
    0x88230382, 0x4d0071ff, 0xa2201bf7, 0xa3202382, 0xa4200382, 0xa5200382, 0xa6200382, 0xa7200382, 0xa8200382, 0xa9200382, 0xaa200382, 0xab200382,
    0xac200382, 0xad200382, 0xb3200382, 0xb4207f82, 0xb5200782, 0xb6200382, 0xb7200382, 0xb8200382, 0xba200382, 0xbb200382, 0xbc201b82, 0xbd200382,
    0xbe200382, 0xbf200382, 0xc1209782, 0xc2200382, 0xc3201b82, 0xc4200382, 0xc5200382, 0xc6200382, 0xc7200382, 0xc8200382, 0xc9201b82, 0xcb200782,
    0xcd200382, 0xce200382, 0xcf200f82, 0xd5200782, 0xd7200382, 0xd9200382, 0xdb200382, 0xdd200382, 0x834e0382, 0xff06240f, 0x820801ae, 0x820a2003,
    0xff0e2803, 0xff0f01c3, 0x82110185, 0x82122003, 0x8213200b, 0x82142007, 0x82152007, 0xff1c2407, 0x821d01ec, 0x821f2007, 0x82202003, 0x8221200b,
    0x82222007, 0x82232007, 0x00242407, 0x82260114, 0x82372003, 0x8239202b, 0x82402003, 0x82432003, 0x82442017, 0x824a2003, 0x825f2003, 0x82662003,
    0x82692013, 0x826d2007, 0x82712007, 0x8279202b, 0x827b200b, 0x827e2073, 0x82802007, 0x82822013, 0x82842007, 0x828a200f, 0x828c200b, 0x828e200b,
    0x82902003, 0x82912003, 0x8293200f, 0x82942007, 0x82962007, 0x82992007, 0x829b2003, 0x82a02003, 0x82aa207b, 0x080b4f07, 0xca205382, 0xf7820f82,
    0x82d80121, 0x82db2007, 0x82dc2003, 0x82dd2033, 0x82de2003, 0x82ea200b, 0x82ed2003, 0x82ee2003, 0x82fb2003, 0x82fd2013, 0xffff2403, 0x820102c3,
    0xff022c03, 0xff0302ae, 0x0007029a, 0x820b0252, 0xff282403, 0x82580285, 0x82592003, 0x825f2003, 0x8260201f, 0x826a2007, 0x826c2003, 0x21bf820b,
    0x0b827202, 0x0b827e20, 0x07827f20, 0x07828120, 0x674f8320, 0x82852006, 0x8286200f, 0x8287200b, 0x82882007, 0x82892007, 0x21cf8207, 0x0b828b02,
    0x03828c20, 0x0f828d20, 0x1400a924, 0x0b82aa02, 0x0382b120, 0x0f82b220, 0x0782b320, 0x0782b420, 0x1782b520, 0x0b82b620, 0x0782b720, 0x0782b820,
    0x0782b920, 0x0782ba20, 0x0782bd20, 0x1f82d920, 0x0382da20, 0x0221d382, 0x200782dc, 0x200382dd, 0x4f0382e0, 0xf0200bab, 0xf1200f82, 0xf2202f82,
    0xf3200782, 0xf4200782, 0xf8200782, 0xfa200782, 0xfc280382, 0x0a03c3ff, 0x0c0385ff, 0x0e200382, 0x10200b82, 0x15200382, 0x16200382, 0x17240f82,
    0x18031400, 0x19200b82, 0x1a200382, 0x1d200f82, 0x1e200382, 0x1f200382, 0x21200382, 0x22200382, 0x23200382, 0x24200382, 0x25200382, 0x26200382,
    0x27200382, 0x28200382, 0x29200382, 0x2a200382, 0x2b200382, 0x2c200382, 0x2d200382, 0x2e200382, 0x2f200382, 0x30200382, 0x31200382, 0x32200382,
    0x33200382, 0x34200382, 0x36200382, 0x38200382, 0x3a200382, 0x3c200382, 0x3e200382, 0x40200382, 0x42200382, 0x44200382, 0x49200382, 0x4a208382,
    0x4b200782, 0x4c200782, 0x4d200782, 0x4e200782, 0x4f200782, 0x50200782, 0x51200782, 0x52200782, 0x53200782, 0x54200782, 0x55200782, 0x56200782,
    0x57200782, 0x58200782, 0x59200782, 0x5a200782, 0x5b200782, 0x5c200782, 0x5d200782, 0x5e200782, 0x5f200782, 0x60200782, 0x62240782, 0x6403aeff,
    0x66200382, 0x68200382, 0x6a200382, 0x6c200382, 0x6e200382, 0x70200382, 0x72202382, 0x742a0382, 0x2300c3ff, 0xd7ff0f00, 0x03821100, 0x334d2420,
    0x00d7211c, 0x200a1f4d, 0x0bf34c01, 0xecffaa23, 0x0bdb4c02, 0x4c0bc74c, 0x00212ec3, 0x0c0f45e8, 0x2109ab4c, 0xd74e00c3, 0x8244200f, 0x0d0f56bb,
    0x5000c322, 0x5120c582, 0x20061756, 0x20078253, 0x20238254, 0x20078255, 0x20038256, 0x20038258, 0x200f8282, 0x20038283, 0x20038284, 0x20038285,
    0x20038286, 0x23038287, 0x0085ff88, 0x201b434b, 0x202382a2, 0x200382a3, 0x200382a4, 0x200382a5, 0x200382a6, 0x560382a7, 0xb3201737, 0xb4206b82,
    0x20163b56, 0x201b82bb, 0x200382bc, 0x200382bd, 0x200382be, 0x202782c2, 0x200382c3, 0x200382c4, 0x200382c5, 0x200382c6, 0x200382c7, 0x561b82c8,
    0xce200b53, 0x57560f82, 0x0fb74f17, 0xd7ff0624, 0x03820801, 0x03820a20, 0x03820e20, 0x20076b56, 0x240b8212, 0x01c3ff13, 0x20078214, 0x20078215,
    0x2007821d, 0x2003821f, 0x20038221, 0x20038223, 0x20138243, 0x20038244, 0x200b824a, 0x2007825f, 0x20078266, 0x20078269, 0x2007826d, 0x20078279,
    0x2007827b, 0x2007827e, 0x20038282, 0x560b8284, 0x93200b67, 0x5f561382, 0x82aa200b, 0x062f500f, 0x82ca0121, 0x0b3b560b, 0x220b3356, 0x44d7ffee,
    0xc3260a8b, 0xc3ff5802, 0x03825902, 0x17825f20, 0x20072756, 0x200b826c, 0x20138272, 0x2007827e, 0x8207827f, 0x8502217b, 0x86200782, 0x87200f82,
    0x88200782, 0x89200782, 0x77500782, 0x828d2007, 0x82b1200b, 0x82b22013, 0x82b32007, 0x82b42007, 0x82d92007, 0x82da2003, 0x82db2003, 0x82dc2003,
    0x82dd2003, 0x82e02003, 0x0b9b5003, 0x0f82f020, 0x2f82f120, 0x0782f220, 0x0782f320, 0xc3fff424, 0x03820a03, 0x03820c20, 0xd7ff1524, 0x07821603,
    0x07821920, 0x07821a20, 0x03821d20, 0x03821e20, 0x03821f20, 0x03822120, 0x03822220, 0x03822320, 0x03822420, 0x03822520, 0x03822620, 0x03822720,
    0x03822820, 0x03822920, 0x03822a20, 0x03822b20, 0x03822c20, 0x03822d20, 0x03822e20, 0x03822f20, 0x03823020, 0x03823120, 0x03823220, 0x03823320,
    0x03823420, 0x201f1756, 0x20838249, 0x2027824a, 0x2007824b, 0x2007824c, 0x2007824d, 0x2007824e, 0x2007824f, 0x20078250, 0x20078251, 0x20078252,
    0x20078253, 0x20078254, 0x20078255, 0x20078256, 0x20078257, 0x20078258, 0x20078259, 0x2007825a, 0x2007825b, 0x2007825c, 0x2007825d, 0x2007825e,
    0x2007825f, 0x20078260, 0x20078262, 0x20038264, 0x20038266, 0x20038268, 0x2003826a, 0x2a03826c, 0x00d7ff6e, 0x000500e9, 0x820a0066, 0xff0f2403,
    0x821100ae, 0x82242003, 0x0fab4d15, 0x13824420, 0x03824620, 0x03824720, 0x03824820, 0xecff4a24, 0x03825000, 0x03825120, 0x0f825220, 0x07825320,
    0x07825420, 0x07825520, 0x07825620, 0x07825820, 0x03825d20, 0x21197d50, 0xcb4f00ae, 0x82a2201b, 0x82a32043, 0x82a42003, 0x82a52003, 0x82a62003,
    0x82a72003, 0x82a82003, 0x82a92003, 0x82aa2003, 0x82ab2003, 0x82ac2003, 0x82ad2003, 0x82b32003, 0x82b4206b, 0x82b52007, 0x82b62003, 0x82b72003,
    0x82b82003, 0x82ba2003, 0x82bb2003, 0x82bc201b, 0x82bd2003, 0x82be2003, 0x82c22003, 0x82c32013, 0x82c42003, 0x82c52003, 0x82c62003, 0x82c72003,
    0x82c82003, 0x82c9201b, 0x82cb2007, 0x82cd2003, 0x82ce2003, 0x82cf200f, 0x82d52007, 0x82d72003, 0x82d92003, 0x82db2003, 0x82dd2003, 0x0f2d5503,
    0xecff0624, 0x03820801, 0x39550a20, 0xff0f2406, 0x821101d7, 0x82122003, 0x8213200f, 0x82142007, 0x82152007, 0x0fa14307, 0x17824020, 0x17824320,
    0x03824420, 0x2205a543, 0x826601d7, 0x82692013, 0x826d200f, 0x82792007, 0x827b2007, 0x827e2007, 0x82822007, 0x82842003, 0x828c200b, 0x828e2007,
    0x82902003, 0x82932003, 0x82962003, 0x82992003, 0x519b2003, 0xdb5006a9, 0xca012106, 0xcf200f82, 0xd8200382, 0xdb200382, 0xde200382, 0xea200382,
    0xed200382, 0xa5430382, 0x02662a05, 0x0266000b, 0x02d7ff28, 0x20038258, 0x24038259, 0x02ecff5f, 0x20078260, 0x2003826a, 0x200b826c, 0x20078272,
    0x2007827e, 0x2007827f, 0x20078284, 0x20078285, 0x20078286, 0x20078287, 0x20078288, 0x55078289, 0x8d2007ad, 0xb1200b82, 0xb2201382, 0xb3200782,
    0xb4200782, 0xd9200782, 0xda200382, 0x7f820382, 0x82dc0221, 0x82dd2007, 0x82e02003, 0x0b475103, 0x0f82f020, 0x2f82f120, 0x0782f220, 0x0782f320,
    0xd7fff424, 0x03820a03, 0x03820c20, 0xecff1524, 0x07821603, 0x07821920, 0x07821a20, 0x03821d20, 0x59521e20, 0x8222200a, 0x8223200b, 0x82242003,
    0x82252003, 0x82262003, 0x82272003, 0x82282003, 0x82292003, 0x822a2003, 0x822b2003, 0x822c2003, 0x822d2003, 0x822e2003, 0x822f2003, 0x82302003,
    0x82312003, 0x82322003, 0x82332003, 0x82342003, 0x82362003, 0x82382003, 0x823a2003, 0x823c2003, 0x823e2003, 0x82402003, 0x82422003, 0x82442003,
    0x82492003, 0x824a2083, 0x824b2007, 0x824c2007, 0x824d2007, 0x824e2007, 0x824f2007, 0x82502007, 0x82512007, 0x82522007, 0x82532007, 0x82542007,
    0x82552007, 0x82562007, 0x82572007, 0x82582007, 0x82592007, 0x825a2007, 0x825b2007, 0x825c2007, 0x825d2007, 0x825e2007, 0x825f2007, 0x82602007,
    0x82622007, 0x82642007, 0x82662003, 0x82682003, 0x826a2003, 0x826c2003, 0xff6e2403, 0x568c00ec, 0x37470813, 0x8246200f, 0x8247201d, 0x82482003,
    0x82522003, 0x82542003, 0x1bfb4603, 0x1f82a820, 0x0382a920, 0x0382aa20, 0x0382ab20, 0x0382ac20, 0x0382ad20, 0x0382b420, 0x0382b520, 0x0382b620,
    0x0382b720, 0x0382b820, 0x0382ba20, 0x2205b746, 0x82cb00ec, 0x82cd200b, 0x05b74603, 0xd500ec22, 0xd7200b82, 0xd9200382, 0xdb200382, 0xdd200382,
    0xb7460382, 0x05ab460f, 0x1101ec25, 0x4601ecff, 0xec2005ab, 0x2106ab46, 0x835601ec, 0x82792007, 0x827e201b, 0x82822003, 0x828c2003, 0x828e2003,
    0x82902003, 0x82932003, 0x82962003, 0x82992003, 0x829b2003, 0x077b4603, 0x0b82cf20, 0x0382d820, 0x0382db20, 0x0382de20, 0x0382ea20, 0xecffed22,
    0x200cc356, 0x200f8260, 0x5603826a, 0x7f2007cb, 0x63460b82, 0x02ec2105, 0x21056346, 0x634602ec, 0x02ec2105, 0x21096346, 0x634602ec, 0x02ec2105,
    0x22056346, 0x82e002ec, 0x0d4f4637, 0xf102ec26, 0xf202d7ff, 0x4f461782, 0x03ec2605, 0x03ecff0a, 0x4603820c, 0xec21054f, 0x054f4603, 0x3603ec22,
    0x38201382, 0x3a200382, 0x3c200382, 0x3e200382, 0x40200382, 0x42200382, 0x44200382, 0xf3450382, 0x03ec2105, 0x2105f345, 0xf34503ec, 0x03ec2105,
    0x2105f345, 0xf34503ec, 0x03ec2105, 0x2105f345, 0xf34503ec, 0x03ec2105, 0x2105f345, 0xf34503ec, 0x03ec2105, 0x2105f345, 0xf34503ec, 0x03ec2105,
    0x2205f345, 0x490601ec, 0x9a201679, 0x28107949, 0x00ecff36, 0x009aff44, 0x20038246, 0x20038247, 0x4e038248, 0xc3260581, 0xc3ff5100, 0x0f825200,
    0x07825320, 0x07825420, 0x07825520, 0xaeff5624, 0x07825800, 0xd7ff5b24, 0x3b825c00, 0x2205794e, 0x8283009a, 0x8284201f, 0x82852003, 0x82862003,
    0x82872003, 0x05794e03, 0x5800d721, 0xa22017a9, 0xa3202382, 0xa4200382, 0xa5200382, 0xa6200382, 0xa7200382, 0xa8200382, 0xa9200382, 0xaa200382,
    0xab200382, 0xac200382, 0xad200382, 0xb3200382, 0xb4207782, 0xb5200782, 0xb6200382, 0xb7200382, 0xb8200382, 0xba200382, 0xbb200382, 0xbc201b82,
    0xbd200382, 0xbe200382, 0xbf200382, 0xc1209b82, 0xc2200382, 0xc3201b82, 0xc4200382, 0xc5200382, 0xc6200382, 0xc7200382, 0xd9420382, 0x009a2205,
    0x200b82cb, 0x420382cd, 0x9a2205d9, 0x0b82d500, 0x0382d720, 0x0382d920, 0x0382db20, 0x0382dd20, 0x240fd942, 0x01c3ff06, 0x20038208, 0x4203820a,
    0x9a2405e5, 0x9aff1101, 0x2006e542, 0x06e5429a, 0x4e019a21, 0xae250579, 0xaeff1f01, 0x05794e01, 0x4e01ae21, 0xae250579, 0xecff3901, 0x056d4e01,
    0x44019a22, 0x4a203b82, 0x5f202382, 0xa5490782, 0x019a2105, 0x2205a549, 0x827b019a, 0x827e2063, 0x82802017, 0x8282202f, 0x82842007, 0x828a200f,
    0x828c200b, 0x828e200b, 0x82902003, 0x82932003, 0x82962003, 0x82992003, 0x829b2003, 0x05614e03, 0x49019a21, 0x9a2209b1, 0x1782cf01, 0x0382d820,
    0x0382db20, 0x3f82dd20, 0x0782de20, 0x0382ea20, 0x0382ed20, 0xaeffee26, 0xecff0102, 0x260ab949, 0xff58029a, 0x8259029a, 0x05b94903, 0x6a029a22,
    0x6c240b82, 0x6d02d7ff, 0x72202782, 0xbd490b82, 0x029a2205, 0x200f8281, 0x08614383, 0x61439a20, 0x439a2006, 0x9a220661, 0x33828a02, 0x1f828b20,
    0x07828c20, 0x37828d20, 0x20056543, 0x0665439a, 0xb8029a22, 0xba201b82, 0xd9200382, 0xda201b82, 0x9f820382, 0x82dc0221, 0x82dd2007, 0x82e02003,
    0x0d814303, 0x81439a20, 0x029a2106, 0x22058143, 0x82f8029a, 0x82fa203b, 0xfffc2803, 0xff0a03ec, 0x820c039a, 0x820e2003, 0x4310200b, 0x9a200895,
    0x22069543, 0x821d039a, 0x821e201b, 0x821f2003, 0x82212003, 0x82222003, 0x82232003, 0x82242003, 0x82252003, 0x82262003, 0x82272003, 0x82282003,
    0x82292003, 0x822a2003, 0x822b2003, 0x822c2003, 0x822d2003, 0x822e2003, 0x822f2003, 0x82302003, 0x82312003, 0x82322003, 0x82332003, 0x82342003,
    0x82362003, 0x82382003, 0x823a2003, 0x823c2003, 0x823e2003, 0x82402003, 0x82422003, 0x82442003, 0x05f14303, 0xf1439a20, 0x439a2006, 0x9a2006f1,
    0x2006f143, 0x06f1439a, 0xf1439a20, 0x439a2006, 0x9a2006f1, 0x2006f143, 0x06f1439a, 0xf1439a20, 0x439a2006, 0x9a2006f1, 0x2606f143, 0xff62039a,
    0x826403c3, 0x82662003, 0x82682003, 0x826a2003, 0x826c2003, 0x826e2003, 0xff702403, 0x827203ec, 0xff742203, 0x0c7758ec, 0x490d4f5e, 0x5d591b91,
    0x05b94821, 0xecff6d23, 0x835d5901, 0x0a000126, 0x0400d7ff, 0x20072f5b, 0x06af5a02, 0x4a260021, 0x592308ef, 0x64001400, 0x14220561, 0x0b82bf00,
    0x1400c124, 0x03823701, 0x03823920, 0x03828020, 0x03828a20, 0x03829120, 0x03829420, 0x0382dc20, 0x0382dd20, 0x0382fb20, 0x0382fd20, 0x1400ff24,
    0x03820102, 0x49000721, 0x6d200543, 0x81200b82, 0x83200382, 0x8b200382, 0xaa200382, 0xb6200382, 0xb8200382, 0xba200382, 0xf8200382, 0xfa200382,
    0xfc240382, 0x0e031400, 0x10200382, 0x18200382, 0x70200382, 0x72200382, 0x74200382, 0x05207f82, 0x2008e347, 0x2559844a, 0x000b0229, 0xc7830029,
    0xc784c320, 0x0a002924, 0xe7462900, 0x03002307, 0xdf825b00, 0xecff5d28, 0xecff4001, 0xd5881f00, 0x0d824420, 0x03824a20, 0x0382a220, 0x0382a320,
    0x0382a420, 0x0382a520, 0x0382a620, 0x0382a720, 0x0382c320, 0x0382c520, 0x3982c720, 0x01232b82, 0x82ecffca, 0x20c58553, 0x200b8259, 0x240382da,
    0x03ecffdc, 0x2003821e, 0x20038222, 0x20038224, 0x20038226, 0x20038228, 0x2003822a, 0x2003822c, 0x2003822e, 0x20038230, 0x20038232, 0x834b8234,
    0x825220b9, 0x0052229d, 0x20b98457, 0x20b98252, 0x55918252, 0x4920070b, 0x3620158a, 0x5220e588, 0xa820bf82, 0xb74b0382, 0x4b012016, 0x13240743,
    0x1501d7ff, 0xf74a0382, 0x4ad8201b, 0x054805df, 0x07c34a08, 0xd7ff7f24, 0x03828502, 0x03828720, 0x03828920, 0x03828d20, 0x0382b220, 0x874ab420,
    0x82f02006, 0x82f22007, 0x0b734a03, 0xd7ff1624, 0x03821a03, 0x03824a20, 0x03824c20, 0x03824e20, 0x03825020, 0x0321af82, 0x20078254, 0x20038256,
    0x20038258, 0x2003825a, 0x2003825c, 0x2003825e, 0x20c78260, 0x089b5d05, 0x3d2cef85, 0x3d000b02, 0x52003200, 0xa800ecff, 0x61490382, 0x26e78216,
    0xff1101ec, 0x821301ec, 0x49152003, 0xd8201e05, 0xde231f82, 0x4802ecff, 0x7f2007e1, 0x85200b82, 0x87200382, 0x89200382, 0x8d200382, 0xb2200382,
    0xb4200382, 0xe0200382, 0xf0200382, 0xf2200382, 0xf4210382, 0x09a948ff, 0x0b821620, 0x03821a20, 0x03824a20, 0x03824c20, 0x03824e20, 0x03825020,
    0xdf82a782, 0x5603ec22, 0x58200b82, 0x5a200382, 0x5c200382, 0x5e200382, 0x60200382, 0x0326bf82, 0xd7ff7101, 0x03827801, 0x29009123, 0x240d8300,
    0xff72019a, 0x221182c3, 0x629300c3, 0x0d2808a3, 0x0f0085ff, 0x1e004400, 0x22240382, 0x2600c3ff, 0x2a203982, 0x2d230382, 0x62005e00, 0x3d241bb7,
    0x49003b00, 0x57202782, 0x59240382, 0x5a00d7ff, 0x5c200782, 0x82200782, 0x97440382, 0x13155c1b, 0x3382bf20, 0xd14dc120, 0x12115e06, 0x00f60023,
    0x28df625e, 0xecff3728, 0x9aff3801, 0xf7823901, 0x07823a20, 0x3b003b23, 0x21ab8201, 0x07823f01, 0x4d5e6620, 0xff712406, 0x82800185, 0x828a201f,
    0x82912003, 0x82942003, 0x82a32003, 0x0b076363, 0x1382dc20, 0x0382dd20, 0x0382fa20, 0x3782fb20, 0x0782fc20, 0x0782fd20, 0x0782fe20, 0xecffff2b,
    0x9aff0002, 0xd7ff0102, 0x131f6302, 0x854d6d20, 0x82812006, 0x82832007, 0x0f2b6303, 0x13828b20, 0x20072f63, 0x630b82aa, 0xb6200b33, 0xb7240f82,
    0xb80285ff, 0xb9200782, 0xba200782, 0x3f630782, 0xf8022116, 0xfa201b82, 0xfc240382, 0x0e03d7ff, 0x10200382, 0x15280382, 0x1703ecff, 0x180385ff,
    0x6306854d, 0x70204f57, 0x71245782, 0x72039aff, 0x73200782, 0x74240782, 0x9000d7ff, 0x42204d42, 0x45423349, 0x4102104e, 0x91209c01, 0x200a4142,
    0x0a8f447f, 0x8f44d720, 0xff57282c, 0xff5900e5, 0x825a00d5, 0xff5c2207, 0x1cb152db, 0x22158744, 0x82c100db, 0x163b4937, 0x202e8744, 0x068744e5,
    0x4401db21, 0xdb261d87, 0xd5ff8a01, 0x03829101, 0x03829420, 0x25118744, 0xffdd01d5, 0x874401db, 0x01e52105, 0x21058744, 0x874401e5, 0x44e52005,
    0xdb200687, 0x2a168744, 0xff7e02db, 0xff8102ec, 0x828302db, 0x11874403, 0x4402db21, 0xd5200987, 0x230cbb67, 0x02d5ffb6, 0x21058744, 0x874402db,
    0x02db2105, 0x22198744, 0x82fa02db, 0xfffc245f, 0x820e03db, 0x82102003, 0x09874403, 0xdf67d520, 0x82702054, 0x05874463, 0x4403db21, 0xdb280587,
    0x05009400, 0x0a0066ff, 0x0d210382, 0x450210ff, 0x06283501, 0x070266ff, 0x0a02aeff, 0x0b200782, 0x20200782, 0x210e3b63, 0x5142ff6d, 0x09f365ed,
    0x65571020, 0x07c94606, 0xecff8424, 0x03828900, 0xc9688a20, 0x17c36b06, 0x22074b44, 0x463d00f6, 0x87480881, 0x82a32007, 0x837b4d13, 0xe34b3720,
    0x83e58f08, 0x678b20e1, 0xdd4022c3, 0x0020229b, 0x1a595d24, 0x2463555d, 0xff0c0056, 0x10376bd7, 0xf6ff2d24, 0x99823600, 0xc3ff3724, 0x1f823900,
    0x200fd165, 0x20138240, 0x6b038260, 0xd9651947, 0xf600292c, 0x1c01f6ff, 0x2001ecff, 0x22200382, 0x2032576b, 0x203382a0, 0x6b4382a3, 0x42208b5f,
    0x240c3d5f, 0x00ecff30, 0x2003823d, 0x1aef4144, 0xd7ff8823, 0x176b4f00, 0x6f4fc220, 0x4fc42006, 0xc6200673, 0x6c06774f, 0x5f820f6d, 0x716c0120,
    0xffaa2407, 0x5fca01ec, 0x59200a81, 0x72200b82, 0xd9200382, 0xda200382, 0xdb200382, 0xdc200382, 0xdd240382, 0x1d03ecff, 0x2006a74f, 0x2007821f,
    0x20038221, 0x20038222, 0x20038223, 0x20038224, 0x06b74f25, 0x07822720, 0x03822820, 0xbf4f2920, 0x4f2b2006, 0x2d2006c3, 0x2006c74f, 0x06cb4f2f,
    0x07823120, 0x796c3220, 0x82342006, 0x002e2a83, 0x00520005, 0x00c3ff09, 0x2507820a, 0x003d000c, 0x716c000d, 0x0dd56405, 0x24094f56, 0x00beff2d,
    0x242f8230, 0x00d7ff32, 0x20038234, 0x24ed8236, 0x00270037, 0x24378239, 0x0014003a, 0x56438240, 0x49230f67, 0x5600e5ff, 0x114e236b, 0x0b735607,
    0x4f826020, 0x56ff8221, 0x0024ec77, 0x01befff6, 0x24437b56, 0x01270024, 0x26038226, 0x01140036, 0x56ecff37, 0x7120248b, 0x79212f82, 0x178f56ff,
    0x5601d721, 0x91240b8f, 0x9301d7ff, 0x94202b82, 0x97560782, 0x82a3200f, 0x82aa20c3, 0x079b561b, 0x5782bc20, 0x0f82ca20, 0x4f0b9f56, 0xec21052d,
    0x0ea35601, 0x82fa0121, 0x82fb20af, 0x82fc20af, 0x82fd2007, 0x82fe2007, 0xffff2207, 0x68bb56ec, 0x2700a923, 0x05614f02, 0xb202d723, 0x09c356ff,
    0x1782b520, 0xd7ffb624, 0x0782b702, 0x8f82b820, 0x0782b920, 0x0782ba20, 0x0782bd20, 0x225bd756, 0x4f270017, 0xd7230699, 0x10ff1a03, 0x0501df16,
    0x0500022a, 0x0a0098ff, 0x0300d7ff, 0x02210987, 0x200d820b, 0x200d8206, 0x2417826f, 0xff49006f, 0x0c3d55db, 0xbe203183, 0xbe221982, 0xc3536100,
    0xff0f2408, 0x821100be, 0xff222803, 0xff4600b4, 0x824700f6, 0x82482003, 0x00492403, 0x824a0014, 0x82522007, 0x82542003, 0x00572403, 0x82a80006,
    0x82a92007, 0x82aa2003, 0x82ab2003, 0x82ac2003, 0x82ad2003, 0x82b42003, 0x82b52003, 0x82b62003, 0x82b72003, 0x82b82003, 0x82ba2003, 0x82c92003,
    0x82cb2003, 0x82cd2003, 0x82cf2003, 0x82d52003, 0x82d72003, 0x82d92003, 0x82db2003, 0xffdd2403, 0x820f01f6, 0x82112003, 0x82132003, 0x82152003,
    0x82792003, 0x827e2003, 0x82822003, 0x828c2003, 0x828e2003, 0x82902003, 0x82932003, 0x82962003, 0x82992003, 0x829b2003, 0x214f8203, 0x0782d801,
    0x0382db20, 0x0382de20, 0x0382ea20, 0xf6ffed2c, 0x3d000702, 0x8dff0802, 0x07820b02, 0x07820c20, 0x81ff1028, 0x0c001502, 0x1b826002, 0x03826a20,
    0x03827f20, 0x03828520, 0x03828720, 0x03828920, 0x03828d20, 0x0382b220, 0x0382b420, 0x0382e020, 0x0382f020, 0x0382f220, 0xf6fff424, 0x03820a03,
    0x03820c20, 0x03821620, 0x03821a20, 0x03823620, 0x03823820, 0x03823a20, 0x03823c20, 0x03823e20, 0x03824020, 0x03824220, 0x03824420, 0x03824a20,
    0x03824c20, 0x03824e20, 0x03825020, 0x03825220, 0x03825420, 0x03825620, 0x03825820, 0x03825a20, 0x03825c20, 0x03825e20, 0xff826020, 0x85410720,
    0x0b515510, 0xdb4f6420, 0x095b5408, 0x5b54e120, 0x2ff9511c, 0x5116af4f, 0x137728f1, 0x097d58ef, 0x8f000c28, 0xa4002200, 0x03824000, 0x52004524,
    0x03824b00, 0x3d004c24, 0x03824d00, 0x0b824e20, 0x03824f20, 0xb800602c, 0xf600ae00, 0xcd00b000, 0x0382b100, 0x1382e720, 0x2f82e920, 0x0a01eb24,
    0x0f82ed00, 0x1b82ef20, 0x2900f124, 0x3382f500, 0xe100f724, 0x1f82f900, 0x0382fc20, 0x5200fe24, 0x03820001, 0x03820220, 0x52000428, 0x8f000702,
    0x6f820b02, 0x2d000126, 0x3a006600, 0x4208734c, 0x52200915, 0x42081542, 0xed411b01, 0x8d377421, 0xe9884220, 0x14003022, 0x2006f14b, 0x0a3177d7,
    0x2405c371, 0x00ecff59, 0x2403825c, 0x00d7ff9f, 0x05095fbf, 0x280cad4b, 0x01ecff23, 0x01d7ff24, 0x20038226, 0x200b8236, 0x20078238, 0x20078239,
    0x2007823a, 0x20038271, 0x200b8280, 0x2003828a, 0x20038291, 0x20038294, 0x200382a0, 0x201782bc, 0x200782dc, 0x770382dd, 0x3d5e0f0d, 0x02292805,
    0x0229000b, 0x5eecff6d, 0x8b200815, 0xa9240b82, 0xaa02d7ff, 0xb5200782, 0xb6200782, 0xb7200782, 0xb8200782, 0xb9200782, 0xba200782, 0xbd200782,
    0xc55d0782, 0x07bd5d0b, 0xd7ff1728, 0xecff1803, 0x07826f03, 0x07827020, 0x07827120, 0x07827220, 0x07827320, 0x83827420, 0xe3601d20, 0x692f1016,
    0x2f105502, 0x20060261, 0x05754401, 0x2015194f, 0x0a8f7b5c, 0x210f194f, 0x194f00ec, 0x3b114f0f, 0x01090f10, 0x238d654f, 0x201d014f, 0x0c014fec,
    0x4e139165, 0x996523f9, 0xff0f251f, 0xff2802d7, 0x22599d65, 0x692700a9, 0xdd4e0607, 0x73d94e0d, 0x10ff1921, 0x0901d50e, 0xf549c520, 0x61102008,
    0x3d580a55, 0xff362707, 0xff3800d7, 0x0d6c00ec, 0x053b5313, 0x5c00d722, 0x6c2e4961, 0x75612f29, 0x82c9200b, 0x09316c8b, 0xcf00ec22, 0x316c0f82,
    0x00ec2115, 0x0f754418, 0xecff0f24, 0x03821101, 0x13631220, 0x05dd7206, 0x1c01ec26, 0x2001d7ff, 0x22200382, 0x44180382, 0x37200f89, 0x39201382,
    0x09590382, 0x07556c07, 0x13828020, 0x47828220, 0x07828a20, 0x520b5d6c, 0xec21059f, 0x059f5201, 0x6c01ec21, 0xa0200765, 0xb8202782, 0xbb202f82,
    0x696c0382, 0x058f520b, 0x6c01d721, 0x01210a71, 0x202b82fb, 0x220382fd, 0x61d7ffff, 0x431805b9, 0x9f630845, 0x6c612005, 0xec210885, 0x07c16102,
    0x13827f20, 0x200bc561, 0x6f0f8285, 0xec21054f, 0x054f6f02, 0x8a02ec22, 0xd1611382, 0x828d2007, 0x056f520b, 0xb202ec22, 0x576f0b82, 0x02ec2205,
    0x207382b6, 0x200382b8, 0x6c0382ba, 0xec2105a5, 0x0d451802, 0x82f02007, 0x054f6f27, 0x6f02ec21, 0xec20054f, 0x240cd961, 0x03ecff0a, 0x6103820c,
    0x16200be1, 0xe1610f82, 0x821a2007, 0x21bd6c0b, 0x4a03ec22, 0x0b6f2782, 0x03ec2105, 0x22050b6f, 0x644f03ec, 0x0b6f064b, 0x03ec2105, 0x21050b6f,
    0x0b6f03ec, 0x03ec2105, 0x22050b6f, 0x825903ec, 0x825a2027, 0x050b6f03, 0x6f03ec21, 0xec21050b, 0x050b6f03, 0x1803ec21, 0x241b8d45, 0x03d7ff70,
    0x24038272, 0x00d7ff74, 0x545d6533, 0x14000b22, 0x24746165, 0x0062010b, 0x05ff7129, 0x6d300782, 0x7101ecff, 0x720185ff, 0x73019aff, 0x7501d7ff,
    0x78200382, 0x88200b82, 0x91241b82, 0x0300c3ff, 0x08cd4218, 0xecff7326, 0x5f010b00, 0x64202f82, 0x67200382, 0x6c200382, 0x70200382, 0xc3203f84,
    0xd7223f82, 0x3b827401, 0x0f827720, 0x07827820, 0x2d828820, 0x10002422, 0x6d224182, 0x3582c3ff, 0x62019a22, 0x200a1b76, 0x20218273, 0x20038276,
    0x20698279, 0x06ed557a, 0x1f827d20, 0x0b827e20, 0xaeff8124, 0x07828201, 0x1f828320, 0x13828420, 0x07828520, 0x07828620, 0x03828720, 0x03828920,
    0x916c8c20, 0x828f2006, 0x82902007, 0x82922003, 0x82932013, 0x82942033, 0x82952027, 0x8296200b, 0x8298200b, 0x8299200b, 0x829a201b, 0xff9b280f,
    0xff0202ae, 0x840302c3, 0x827120cd, 0x82722011, 0x82782003, 0x0119220d, 0x20278279, 0x2003827d, 0x2003827e, 0x20038280, 0x20038281, 0x85c18283,
    0x01d72673, 0x01290088, 0x2013828a, 0x2013828b, 0x2007828c, 0x2007828d, 0x2003828f, 0x200b8290, 0x20078291, 0x20078292, 0x20038293, 0x200b8294,
    0x20078295, 0x85078296, 0x01d7227b, 0x240f829a, 0x00d7ff9b, 0x1049524f, 0x501b5764, 0xfd611b43, 0x21575013, 0x4218d720, 0xd7201a9b, 0x149b4218,
    0x29090b42, 0xff7801c3, 0xff91019a, 0x491801c3, 0x03201e61, 0x184fb165, 0x210bf54a, 0x491800ec, 0x8d421f05, 0x01d72605, 0x01ecff70, 0x20038271,
    0x20038272, 0x42038274, 0xec20058d, 0xec29c182, 0xecff9401, 0xecff0002, 0xa5401803, 0x1871200b, 0x7f083744, 0x97760b49, 0x4344180f, 0xff6d2513,
    0xff7d009a, 0x411d5f76, 0x441835af, 0x5f28254b, 0x620185ff, 0x66019aff, 0x6920e582, 0x6d200782, 0x73230782, 0x4301aeff, 0x85220555, 0x3d7e7a01,
    0x8281200e, 0x05417e23, 0x4301c321, 0x8a240b4d, 0x8c01c3ff, 0x8d202b82, 0x8e200782, 0x8f202382, 0x430a557e, 0x85220559, 0x1b829401, 0x26055943,
    0x0097019a, 0x82980129, 0x8299200f, 0x055d4327, 0xfa019a22, 0x44180f82, 0x02240bbf, 0x03029aff, 0x07200382, 0x44180382, 0x23420ac7, 0x51b22058,
    0x3b1016a1, 0x227101ff, 0x75140062, 0x71210873, 0x05b96bff, 0x2a095546, 0xff7901c3, 0x008801c3, 0x7b8d0129, 0x03201dbf, 0x20f7277b, 0x0b6d4708,
    0xff920125, 0x829501d7, 0x05734303, 0x9a01d726, 0x4600d7ff, 0x61109161, 0x81611789, 0xc94c1846, 0x82622028, 0xff6724a9, 0x486901ec, 0x78201619,
    0xcf551f82, 0xff28240f, 0x605802ec, 0x4c180663, 0x05203fb5, 0x200c3b41, 0x24858281, 0x00290088, 0x18d3782a, 0x181bbf78, 0x181fdb4e, 0x240bff4a,
    0x01aeff73, 0x05a54191, 0x23081970, 0x03d7ff5f, 0x2fa34e18, 0x2748cf20, 0x82222008, 0x4d2420b7, 0x5118127f, 0x40181389, 0x4b1851d1, 0x40182d1b,
    0xec2175e5, 0xe5401800, 0x00ec210d, 0x19e54018, 0x180dfb4d, 0x210de540, 0x401801ec, 0xec2109e5, 0xe5401801, 0xdf4b181b, 0x09434919, 0x0b094118,
    0x490bb56f, 0xd720114f, 0x21184f49, 0x4018ff28, 0xec220bcd, 0x0f826002, 0xecff6122, 0x257e1145, 0xff4a03ec, 0x874d03c3, 0x4dc32005, 0xc3200687,
    0x2106874d, 0x874d03c3, 0x4dc32005, 0xc3200687, 0x2006874d, 0x06874dc3, 0x874dc320, 0x03c32106, 0x2005874d, 0x06874dc3, 0x874dc320, 0x03c32106,
    0x6224df83, 0x6303d7ff, 0x6420e782, 0x65200782, 0x66200782, 0x67200782, 0x68200782, 0x69200782, 0x6a200782, 0x6b200782, 0x6c200782, 0x6d200782,
    0x6e200782, 0x0e1d5518, 0x2209a74c, 0x45290088, 0x21459a25, 0x05ad4a1b, 0x4501d721, 0x36205b25, 0x706d4c18, 0xaeff6228, 0xecff6401, 0x07826901,
    0x07827420, 0x03827820, 0xd7ff8124, 0x03828801, 0xd7ff8e22, 0x0b814c18, 0x3c714c18, 0xe9452920, 0x77b58262, 0x0220091d, 0x2033e545, 0x0cab4ae9,
    0x5c0de566, 0xb54c6151, 0x00d72105, 0x01c34b10, 0x05914d57, 0x1801c321, 0x240bc74b, 0x01c3ff73, 0x21038276, 0x954dff79, 0x187d2009, 0x500ad74b,
    0x852205ef, 0x13828401, 0x03828620, 0x03828720, 0x14008824, 0x4b188901, 0x994d0eeb, 0x01ae210d, 0x07f34b18, 0x27829520, 0x5b829620, 0x3d009724,
    0x0b829801, 0x2205994d, 0x189b01ae, 0x4d14c74b, 0x4b180699, 0x032019c7, 0x01df4a10, 0x002d2103, 0x25050f50, 0xff1100c3, 0xc152009a, 0x019a2511,
    0x01d7ff6d, 0x2105d941, 0xc55201d7, 0x01ae2905, 0x01c3ff7b, 0x01ecff7c, 0x22055152, 0x827f019a, 0x05774f23, 0x5201ae21, 0xe54113cd, 0x01c32105,
    0x21055d52, 0x7f4f019a, 0x019a2505, 0x019aff90, 0x20055d52, 0x08df68c3, 0x20057f4f, 0x0a7f4fae, 0x52019a21, 0x0a250fdd, 0xd7ff5f01, 0x09874b01,
    0x5201d721, 0x742007ed, 0x77209982, 0x78201b82, 0x88240782, 0x1700d7ff, 0x8308a54d, 0x827920c3, 0x22b785b3, 0x827e01ec, 0x8281200b, 0x82852003,
    0x82862003, 0x20a38303, 0x08f5528c, 0x9782ec20, 0x5201d721, 0xec2105f5, 0x0df15201, 0xf152ec20, 0x00ec2a06, 0xff0f000c, 0xff1100ae, 0x208f82ae,
    0x208f84c3, 0x20778269, 0x51461881, 0x82ec2008, 0x01ec21d5, 0x0a774318, 0x86030021, 0x01d722a9, 0x209d8278, 0x1065632c, 0x53073153, 0x09531b1d,
    0x09616321, 0x8b827320, 0xe9868020, 0x9120e183, 0x0cdb4318, 0xa950ec20, 0xee00212f, 0x5d1ac76c, 0x6d2779ad, 0x7d00c3ff, 0x1000d7ff, 0x3f01bf2c,
    0x5617b55d, 0x0f4409d1, 0x01c3231f, 0x0f44ff7e, 0x05754205, 0xe1569a20, 0x0d8f530c, 0x0f44ec20, 0xff8d2208, 0x0e1344d7, 0x5301d721, 0x9a210593,
    0x09ed5601, 0x440b9353, 0x9a200713, 0x5d0cab6c, 0x421016cd, 0x2a0401a7, 0x00880101, 0x01060029, 0x44d7ff79, 0x8c2408fb, 0x9001ecff, 0x93240382,
    0x1400ecff, 0xec201982, 0x2106d545, 0xbd4101ec, 0x01ec2105, 0x58091d45, 0x3183051f, 0x45091b58, 0xec220725, 0x45829501, 0x03829720, 0x03829820,
    0x03829920, 0x51829a20, 0x94010126, 0x0b00ecff, 0x20087d6a, 0x20638249, 0x241b8281, 0x0129008d, 0x2007828e, 0x200f8291, 0x20038294, 0xff5c1896,
    0x02002209, 0x05216701, 0x3789d720, 0x3783b184, 0xb9828c20, 0x20079358, 0x220b8293, 0x18d7ff99, 0x20088742, 0x2225821c, 0x587a01ae, 0xc32008e5,
    0xd726c182, 0xc3ff8101, 0x13828201, 0x20059346, 0x22cd82d7, 0x828601d7, 0x8287200f, 0x09f1587d, 0x8c01d722, 0x8d202782, 0x8f200382, 0x90200382,
    0x91200382, 0x7f420382, 0x82c32005, 0x01c322d9, 0x200f8296, 0x20038298, 0x46038299, 0xc322058b, 0xd7821000, 0x0a005224, 0x9f845200, 0x51827d20,
    0x03827e20, 0x5d828020, 0x20055359, 0x085359ec, 0x13828d20, 0x03829120, 0x9720b383, 0x09154618, 0x45090021, 0x418407fd, 0x21827e20, 0x03828120,
    0x45828220, 0xa5458c20, 0x0d002109, 0x830c3f41, 0x82802067, 0x24638321, 0x013d0088, 0x8531828a, 0x01c3225f, 0x0a0f4194, 0x2409f36b, 0x01140049,
    0x2003828d, 0x2853848e, 0x000b023d, 0x0003003d, 0x203b821e, 0x0505417e, 0x42185f82, 0x7f410afb, 0x01042108, 0x3982cf84, 0x29008a28, 0x14009101,
    0xe56d0700, 0x1801200b, 0x8307d343, 0x0091245b, 0x4b0e0029, 0x718208ef, 0x827d0021, 0x20218333, 0x83638281, 0x838c203f, 0x204b82a7, 0x2007828f,
    0x05fb4190, 0x071d4718, 0x8c040021, 0xff942457, 0x8b1500ec, 0x7901214b, 0x7a203382, 0x7e200382, 0x53850382, 0x8201d722, 0x85200b82, 0x13424782,
    0x01d72205, 0x200f8290, 0x05c94292, 0x82940121, 0x05b1477b, 0x9901d722, 0x8d0a6f41, 0x21498267, 0x5b821300, 0x4101ec21, 0xd72005bb, 0x21063142,
    0x5b4101ec, 0x01292205, 0x204f828c, 0x0873428d, 0x5b09eb42, 0xeb420703, 0x9b01210a, 0x3820b582, 0x2210a777, 0x6b3d002d, 0x91780833, 0x07435f3b,
    0xbd47be20, 0x635f180d, 0x003d2e70, 0x00c3ff05, 0x01c3ff0a, 0x0185ff9d, 0x240382a6, 0x01d7ffb0, 0x200782bc, 0x240782bd, 0x01ecffbf, 0x201b82c1,
    0x6f5718c4, 0x01ec2208, 0x201382df, 0x281382e1, 0x02aeffe4, 0x02c3ff07, 0x2003820b, 0x24c5826d, 0x02d7ff76, 0x200b827c, 0x2003827d, 0x20038280,
    0x20138281, 0x20078282, 0x20078283, 0x2003828b, 0x241f829f, 0x0285ffa9, 0x201382aa, 0x200782b5, 0x200782b6, 0x6a0782b7, 0x852205e7, 0x2382ba02,
    0x2382bb20, 0x1382bd20, 0x1b82bf20, 0x0382c020, 0x0382c120, 0x0382c220, 0x1782ca20, 0x0782d420, 0x0382d520, 0x0b82e520, 0x0382f720, 0x2f82f820,
    0x0782f920, 0x0782fa20, 0x0782fb20, 0x0782fc20, 0x1f82fd20, 0xc3fffe28, 0xd7ff0503, 0x03820703, 0x0b820d20, 0xecff0e24, 0x07820f03, 0x41181020,
    0xc32208a7, 0x8d42d400, 0xff102208, 0x08f17e5c, 0x1811db5c, 0x2c81775f, 0x01ecff9f, 0x019affa4, 0x0185ffaa, 0x200382ae, 0x740382b5, 0xec260517,
    0xc3ffbe01, 0x0f82ca01, 0xd7ffcb24, 0x0b82cc01, 0x0382cd20, 0x5cffce24, 0x1382cf01, 0x0b82d020, 0x0382d120, 0x0382d220, 0x0382d320, 0x0382d420,
    0x1b82d520, 0x0782d620, 0x0382d720, 0x2382d820, 0x0782d920, 0x0382da20, 0x0f4d5918, 0x1382df20, 0x0382e020, 0x0382e120, 0x0382e220, 0x0382e320,
    0x0382e420, 0x0382e520, 0x0382e620, 0x0382e720, 0x0382e820, 0x9782e920, 0x4782ea20, 0x0b82ec20, 0x0782ed20, 0xaeffee28, 0x3d00f001, 0x6782f201,
    0x1382f320, 0x0382f520, 0x0382f720, 0x0382f920, 0x200f675b, 0x06c54d07, 0xecff5f23, 0x05076202, 0x6b028529, 0x6c02c3ff, 0x1802d7ff, 0x20078559,
    0x0155187d, 0x02852108, 0x09895918, 0x8502d726, 0x860285ff, 0x87202782, 0x88200782, 0x89200782, 0x8a200782, 0x8b200782, 0x8c202f82, 0x8d200782,
    0x96200f82, 0x9a200b82, 0xa0200382, 0xa4200382, 0xa6200382, 0xaa200382, 0xac200382, 0xae200382, 0xb0200382, 0xb1200382, 0xb2202b82, 0xb3202b82,
    0xb4200782, 0x24069142, 0x02c3ffb8, 0x200382ba, 0x068142bc, 0x0782c220, 0x0382c420, 0xaeffc528, 0x71ffc602, 0x0782c702, 0x0f82cb20, 0x2f82ce20,
    0x5cffcf24, 0x0b82d102, 0x9942d320, 0x82d72006, 0x18d92007, 0x2218cd59, 0x82e302d7, 0x82e62067, 0x82ec2023, 0x82ee2003, 0x82ef2003, 0x82f0200f,
    0x82f1202f, 0x82f22007, 0x82f32007, 0xd9591807, 0xfe02250e, 0x0003c3ff, 0x06200382, 0x08200382, 0x09280382, 0x0a035cff, 0x0b0385ff, 0x59180782,
    0x11200bf1, 0x12201382, 0x14201382, 0x08b95518, 0x18038522, 0x21660b82, 0x03852205, 0x201f821b, 0x5e1f821c, 0x1f2057eb, 0x2008f946, 0x0821649f,
    0xbe01d726, 0xde01ecff, 0xe1200f82, 0x0720d982, 0x2406fd63, 0x02ecff6c, 0x180f827d, 0x1817d368, 0x20079b45, 0x202382c0, 0x200382c2, 0x0d5318d5,
    0x82f1200e, 0x82f3203f, 0xfffe2e03, 0xff1503d7, 0xff1903ec, 0x010500ec, 0x206982a0, 0x202982dc, 0x200382aa, 0x261982b6, 0x00d7ff18, 0x859f011a,
    0xdd012115, 0x83820782, 0x82e40121, 0x866d2037, 0x954d187f, 0x648b2007, 0x31640641, 0x02ec2205, 0x870f82ba, 0x82c5207b, 0x86c7204d, 0x0a7f6f83,
    0x7b830220, 0x8307836f, 0x09cf7d69, 0x4d0f7f5f, 0xc1833ff5, 0x25062b46, 0x29000b02, 0x6a185f02, 0x3d411e11, 0x3f541807, 0x0631410b, 0x4e072d41,
    0x34203021, 0x29076960, 0x85ffa601, 0xd7ffa801, 0x0382b001, 0xecffb522, 0x21062746, 0x274601ec, 0x01ae2105, 0x21052746, 0x6b4101d7, 0x02c32105,
    0x4607455f, 0xae2a051b, 0xd7ff7d02, 0xaeff8002, 0x03828202, 0x21090f46, 0x0f4602d7, 0x02d72605, 0x0285ffb7, 0x460382b9, 0xae220907, 0x3382c002,
    0x2f82c120, 0x0782c220, 0x0382ca20, 0xecffce24, 0x0f82d402, 0x0b82d520, 0x22050b46, 0x82f902ec, 0x82fb2013, 0x82fd2003, 0xfffe2217, 0x0aff45d7,
    0x0f03ae26, 0x1103aeff, 0x2608fb45, 0xff1b03d7, 0x883100ec, 0x07f546d1, 0xd187d585, 0x8201d721, 0x46cd8871, 0xec2205f1, 0x7182e401, 0xec22d189,
    0x6d827c02, 0x75827d20, 0xec21d189, 0x05e14602, 0xec21d193, 0x05d94602, 0xd182ae20, 0x8502ec21, 0x02ec22d1, 0x22cd88ca, 0x82e502ec, 0x82f7200b,
    0x82f92063, 0x82fb2003, 0x20cd8503, 0x22cd82ec, 0x820703ec, 0x820d20c1, 0x2ecd83c9, 0x0385ff17, 0x00d7ff18, 0xff9d011d, 0x82a6019a, 0x07774103,
    0x2209e742, 0x42f601c3, 0x6d2056eb, 0x2858ab56, 0x01d7ff9f, 0x012900a4, 0x460382b5, 0xd72d05e3, 0xaeffbe01, 0xecffcb01, 0x1400ce01, 0xab571801,
    0x096f680b, 0x4801d721, 0xd722058d, 0x3f82ea01, 0x6944ed20, 0x185f200a, 0x2208a757, 0x826d02d7, 0x094f460b, 0x6802d721, 0xd7220963, 0x1b828502,
    0x21054f46, 0x4f4602d7, 0x02d72205, 0x6813828a, 0xd7220563, 0x57448d02, 0x052f4606, 0x4602d721, 0xd720052f, 0x200c6368, 0x06a948c0, 0x2900ce24,
    0x0b82d502, 0x6c18e020, 0xf0200e05, 0xe7450f82, 0x02d72105, 0x2005e745, 0x0b7368d7, 0xfffe0223, 0xd35718c3, 0xff0e2408, 0x821003d7, 0x00112403,
    0x82150329, 0x44162007, 0x032005cf, 0x2205cb45, 0x821b03d7, 0x2fa15d17, 0xdb4c6720, 0x094d4808, 0xb501712e, 0xbb019aff, 0xbc01d7ff, 0xbe012900,
    0xc42c0782, 0xc9011400, 0xca01ecff, 0xcc01aeff, 0xcd200f82, 0x51480382, 0x01ae2205, 0x200b82d1, 0x200382d2, 0x200382d3, 0x480382d4, 0xd722054d,
    0x0b82d701, 0x2f82d820, 0x0782d920, 0x0382da20, 0x0b82db20, 0x0382de20, 0xf745e020, 0xe2012105, 0xe3200782, 0xe5200382, 0xe6200382, 0xe8200382,
    0xe9200382, 0xea200382, 0xec200382, 0xed200382, 0xee202b82, 0xf0280782, 0xf2015200, 0xf30171ff, 0xf5200b82, 0xf7200382, 0xf9200382, 0x240a6b61,
    0x02aeff6a, 0x240f826b, 0x0285ff72, 0x2007827d, 0x200f827f, 0x20038285, 0x20038287, 0x20038289, 0x2003828d, 0x20178296, 0x2003829a, 0x200382a4,
    0x240382a6, 0x022900a9, 0x200782ac, 0x200382ae, 0x200382b0, 0x202382b2, 0x200382b4, 0x201782b5, 0x200382b7, 0x200382b9, 0x450382bd, 0xc42007ef,
    0xce232382, 0x47029aff, 0xd72105d9, 0x21eb8202, 0x1382d502, 0x0382d720, 0x2205d947, 0x82db02ae, 0x82dc207f, 0x82dd2043, 0x82e02007, 0x20c38207,
    0x21bf8202, 0x0b82f002, 0x0382f220, 0x8344f420, 0xff002806, 0xff0a03d7, 0x820c03ae, 0xff112303, 0x9d47039a, 0x03d72205, 0x240f8216, 0x03290017,
    0x2007821a, 0x2417821b, 0x005cff1c, 0xa4676789, 0x9aff9d30, 0xecff9f01, 0x3d00a401, 0x85ffa601, 0xab43ae01, 0x01ec2108, 0x07cd7018, 0x45ffbe21,
    0x9a22073b, 0x1f82d501, 0x0f82dc20, 0x22059f43, 0x82e701c3, 0x82f2200f, 0x1e8f6703, 0xff6c0223, 0x065b45ec, 0x7e02c322, 0x180a5f45, 0x180f4d49,
    0x20094949, 0x494918d7, 0x0949460e, 0x20097345, 0x067345c3, 0x4902c321, 0xc32a05cb, 0xaeffc702, 0x2900ce02, 0x0382cf02, 0x21055146, 0x374702c3,
    0x45022012, 0xc3210587, 0x077f4503, 0x29001124, 0x03821203, 0x09714918, 0x1903d726, 0x1b03ecff, 0x1c201382, 0x63490382, 0x012a2657, 0x01d7ff9d,
    0x4d0382bc, 0xd7220d9b, 0xe748d001, 0x82e12006, 0xffe4211b, 0x2607874d, 0xff8002d7, 0x828202c3, 0x78a02003, 0xd7210863, 0x05637802, 0xb702d722,
    0xb9202782, 0xbc200382, 0x4d065f78, 0xd7210573, 0x05734d02, 0xcb02d722, 0x734d1782, 0x02d72205, 0x109946e6, 0xfe02c326, 0x0603d7ff, 0x0820f582,
    0x0d240382, 0x0f03c3ff, 0x17200382, 0x2205a944, 0x18002100, 0x2023ff71, 0x82b582b0, 0xbd01217d, 0xbf200782, 0x00206182, 0x76200382, 0x9f200382,
    0x120f7218, 0xa584bb20, 0x47052f47, 0xf5470527, 0x081f4708, 0x21691720, 0x4d8f200e, 0xb9420be5, 0x12494d05, 0x4d07454d, 0x5b519e41, 0x6a022207,
    0x290d10ff, 0x002f6401, 0xff9d0142, 0x00a301d7, 0x00a401f6, 0x82a60129, 0x00aa220b, 0x12f34414, 0x2005e54c, 0x201f82c1, 0x200382c4, 0x202b82ce,
    0x200382d5, 0x200b82e1, 0x320782e7, 0x016600f1, 0x022900f2, 0x02ecff6c, 0x02140072, 0x4cd7ff7c, 0x802008fd, 0x82200b82, 0x12ad5218, 0x4405d744,
    0xad430bd3, 0x82bd2009, 0x82bf202f, 0x05154b03, 0xc202d722, 0xc6200b82, 0xc7440382, 0x02d72209, 0x200f82d5, 0x206b82d9, 0x200382db, 0x440382dd,
    0xd72615d3, 0xd7fffe02, 0x03820d03, 0x6b480f20, 0x09d34406, 0x210ccf44, 0xaf543100, 0x82102008, 0x15a549d5, 0xcb01c322, 0xf1451b82, 0x84ae2009,
    0x000724f5, 0x820b023d, 0x846c2003, 0x02ae22f5, 0x3775187e, 0x05c17116, 0x20055949, 0x20dd84b6, 0x2ad982ae, 0xffc502ae, 0xffc602c3, 0x82c7029a,
    0x23e18707, 0x02aeffd5, 0x125f7518, 0xae21cd82, 0x09994503, 0x4318d720, 0x954508f5, 0x26002106, 0x2408a14e, 0x01ecffb1, 0x084945b5, 0xbe01ec22,
    0xbf200f82, 0xc1200f82, 0xc4200782, 0xc7200382, 0x200a9353, 0x200b827c, 0x20038280, 0x20038282, 0x200382a1, 0x829d82a9, 0x083d453b, 0x21058f41,
    0x3b8202ec, 0x82ce0221, 0x82d4201b, 0x82e72023, 0x82e92003, 0x82f52003, 0x82f72003, 0x099d4c03, 0x0d03ec26, 0x0f03ecff, 0x11240382, 0x1703d7ff,
    0x1b240382, 0x4c00d7ff, 0x210e6554, 0x761800d7, 0xeb670bcf, 0x05af413f, 0x554b3d20, 0x01d72112, 0x2205a942, 0x82e401ae, 0x62f220fd, 0x02200d1d,
    0x181fb341, 0x2107eb76, 0xab41ffc0, 0x2f9f4105, 0xfd831920, 0x21083147, 0x771803d7, 0x56202b13, 0x2494496a, 0x01d7ff9d, 0x200382a4, 0x240382a6,
    0x01ecffaa, 0x550382ae, 0xc322054d, 0x0b82bf01, 0x456ac420, 0x72022519, 0x7602ecff, 0x08077b18, 0x0d2b7718, 0x22050d4f, 0x82ca02c3, 0x82d9201f,
    0x82db2027, 0x82dd2003, 0x0f7b1803, 0x3f77180b, 0x43452047, 0x711808eb, 0xa4246bd9, 0xaa01aeff, 0xae220382, 0x934c9aff, 0x01ec2206, 0x200b82ce,
    0x241382d5, 0x02aefff2, 0x18ed8200, 0x22094f77, 0x825802ae, 0x82722013, 0x05ab4b03, 0x0df97118, 0xaeff0924, 0x734b0b03, 0x03ae2108, 0x2005634b,
    0x3c9f65ae, 0x09514218, 0x57717a18, 0x26053553, 0xffbb01d7, 0x55be01d7, 0x6318057b, 0x8d430cb1, 0x45c32005, 0x8d431841, 0x02c32a09, 0x02c3ffc2,
    0x02aeffc6, 0x450782d5, 0xc3201529, 0x378d7a18, 0x66520121, 0x25107c03, 0x275301fb, 0x01c3ff9f, 0x01ecffa0, 0x21058343, 0x83430185, 0x7b711807,
    0x82be200b, 0x00c42623, 0xffca0114, 0x0a695885, 0x69587120, 0x05655810, 0x58017121, 0xe5203765, 0xe6206782, 0x5d580382, 0x01c32205, 0x236f82ea,
    0x012900eb, 0x21096158, 0x27500185, 0x01852105, 0x180f6158, 0x580ff771, 0x71180761, 0x6d5817ef, 0x58c32005, 0xc3210e6d, 0xf7711802, 0x136d5833,
    0x1400a923, 0x11715802, 0xb202c326, 0xb30285ff, 0x1e177218, 0x1f82bc20, 0x3f82bd20, 0x58075552, 0xc3220581, 0x3b82c602, 0x1b82c720, 0x0382cb20,
    0x2005fb44, 0x2a815871, 0xe302c322, 0x81583782, 0x02c3210d, 0x21058158, 0x721802c3, 0x8158165b, 0x58852012, 0x72180681, 0xe3500d73, 0x03712105,
    0x21058158, 0x721803c3, 0x8b45137f, 0x10712005, 0x0401a727, 0x554b6320, 0xaeff2511, 0x9affaa01, 0x5306e75b, 0xbe270599, 0xc401ecff, 0x53012900,
    0xc3210591, 0x05e35b01, 0xcf017122, 0x4310db5b, 0x9a210b75, 0x09db5b01, 0xde01c322, 0xcf5b5782, 0x1169430f, 0x6543c320, 0x01c32206, 0x5b5b82ee,
    0x654305c7, 0x079d6110, 0xff6a0229, 0xff6b029a, 0x827202c3, 0x827d2007, 0x827f2007, 0x82852007, 0x82872003, 0x82892003, 0x828d2003, 0x07154303,
    0x7f5ba420, 0x0b7b5b06, 0x1f82b220, 0x0382b420, 0x200be142, 0x08d147c6, 0x2213d542, 0x82da029a, 0x82db201f, 0x057d5333, 0xe0029a22, 0xec200b82,
    0x20064b5b, 0x200b82f0, 0x200382f2, 0x5b0382f4, 0x09280733, 0x0a0385ff, 0x0b039aff, 0x0c200782, 0xa1420782, 0x8216200b, 0x821a200f, 0x06914203,
    0x5b510020, 0x05bd4905, 0xa801c32a, 0xaa01ecff, 0xae01d7ff, 0xb0220382, 0x2d4cc3ff, 0x01c32206, 0x200f82bf, 0x200f82c4, 0x200782c7, 0x200782ce,
    0x200382d5, 0x248182f2, 0x02d7ff72, 0x20078276, 0x2003829f, 0x200b82a1, 0xed8018a9, 0x82bb200e, 0x82bd200f, 0x82ca2003, 0x82ce2003, 0x82cf201f,
    0x0b801807, 0xe502210a, 0xe7200f82, 0xe9201782, 0xf5280382, 0x0503d7ff, 0x0703c3ff, 0x11200382, 0x12200b82, 0x17200782, 0x1b200382, 0x1c240b82,
    0x2e00c3ff, 0x220c695b, 0x4e3d00a4, 0xd7210e93, 0x05835301, 0xe101ec22, 0x755b5582, 0xff7c230b, 0x035702ec, 0x02ec2105, 0x5307d34c, 0xb1201353,
    0xb3202782, 0xbf200382, 0x855f0382, 0x02ec2205, 0x06814dc2, 0x1382d420, 0x20055748, 0x084f7fec, 0x21065f5a, 0x1b82fd02, 0xa982fe20, 0x5308e34c,
    0x1b530623, 0x30002106, 0x4f084d4f, 0xbc210b49, 0x06814dff, 0x01140023, 0x4f0b82c1, 0x14200541, 0xd721bd82, 0x0b414f01, 0x5c053d4f, 0xbd87053b,
    0x12657a18, 0xb5850220, 0xc102d722, 0xc2248d82, 0xc502d7ff, 0xc6200382, 0xc7200382, 0x2108254f, 0xc5850214, 0x4f02d721, 0xbd850b25, 0xa14dd720,
    0x24bd8209, 0x03140012, 0x08d95317, 0x3e001424, 0xa1829d01, 0xe100a32a, 0x3d00a401, 0x2900aa01, 0x83087b41, 0x82bd20c5, 0x82be200f, 0x86bf201f,
    0x82c420c9, 0x82c7200b, 0x82ce200b, 0x82d1202b, 0x051d4f07, 0xd984ec20, 0x1b82e420, 0x2921dd8d, 0x059f4102, 0x9b41d720, 0x00a12308, 0xe1830214,
    0xc982aa20, 0x0382b520, 0x8518b620, 0xe9900d1f, 0x20090350, 0x060350ec, 0xdb022926, 0xdd022900, 0xe7200382, 0xe9204b82, 0xf5200382, 0xf7200382,
    0xf9200f82, 0xfb200382, 0xf5950382, 0xf5842920, 0xf9881820, 0x1e002922, 0x230e2762, 0xffa80171, 0x62052762, 0xd720091f, 0x6206215b, 0x7c220513,
    0x7f54c3ff, 0x17155b08, 0x21059d55, 0x438202c3, 0x82d40221, 0xfffd232f, 0x4b5403c3, 0x05e55a09, 0xab5b2020, 0xffbc2214, 0x0a996285, 0x9a257987,
    0x9aff0b02, 0x2079af02, 0x207982c5, 0x970382c7, 0x01232181, 0x830bd94d, 0x071744f7, 0x20054950, 0x069355c3, 0xbf01ec26, 0xd501d7ff, 0xf2200382,
    0x500a0f44, 0x0b440f31, 0x02d72105, 0x22050b44, 0x82cf02c3, 0x82e5202b, 0x0a29507d, 0x220aff43, 0x501203c3, 0xc3220829, 0xf55b1c03, 0x09674e06,
    0xecffa822, 0x2106a544, 0x8d8501d7, 0x4f55d720, 0x01d72206, 0x228d8cce, 0x829f02d7, 0x5dbb2069, 0xd7200845, 0xd7217986, 0x22798d02, 0x820703d7,
    0x05794471, 0x4403d721, 0xd7240575, 0x0a001900, 0xdc204d82, 0x635c0382, 0x01ec2205, 0x200b82e4, 0x5f4d82f6, 0x4e18054f, 0x855f0dcf, 0xb96c1806,
    0xffc02408, 0x82c202ec, 0x82d52003, 0x0d475f03, 0x5f03ec21, 0x21200b47, 0xd020b384, 0xd7226988, 0x0b82df01, 0xe382e120, 0xd7226d89, 0x44187d02,
    0x8b200a23, 0xa0208182, 0x8209f75f, 0x02d72271, 0x200f82ba, 0x870382bc, 0x82cb2075, 0x2079830b, 0x180782e6, 0x250ac165, 0xecfffe02, 0xeb820603,
    0x03820820, 0x2407735b, 0x00d7ff18, 0x07994724, 0x20085757, 0x8f8582dd, 0x078f4e89, 0x8305595c, 0x02d722ff, 0x85618283, 0x02ec2191, 0x87090341,
    0x02ec2191, 0xec219189, 0x18918502, 0x860c7944, 0x03ec2291, 0x7d441808, 0x2091830a, 0x060d4f07, 0xed019a2e, 0xf201ecff, 0xcf029aff, 0x12039aff,
    0x1c2a0382, 0x10009aff, 0x1400ca01, 0x6d59ce01, 0x01d72a08, 0x01c3ffe4, 0x027b00f1, 0x0a19417d, 0x240b4f61, 0x021400da, 0x200382dc, 0x83f982fe,
    0x000d225f, 0x41e1820a, 0xec250577, 0xecffdf01, 0x05534102, 0xb602ec22, 0xbc200b82, 0xcb204582, 0xe6200382, 0x2f412d82, 0xff182407, 0x462000ec,
    0x995d0889, 0x08ef6109, 0x20108d5d, 0x8341826a, 0x716a188f, 0x20a38b1b, 0x182f82e0, 0x200a7d6a, 0x82ab8302, 0x0c0321a5, 0x16208582, 0x1a240382,
    0x1d00d7ff, 0x2408a941, 0x01ecffd1, 0x200382dc, 0x5f0382dd, 0xd72205af, 0x3550f601, 0x15f5610a, 0xb820df85, 0xf5612782, 0x18d5200b, 0x610d6d51,
    0xec220eed, 0xf7882100, 0x7618cb20, 0xe1201241, 0x09457618, 0xd308c14f, 0x692220fb, 0xd0200c63, 0xd1207582, 0xd520fb82, 0x200af162, 0x201382df,
    0x200f82f2, 0x060960f6, 0x430bf162, 0xf5620d33, 0x07e74105, 0x2f82cf20, 0x21052b43, 0x701802ec, 0x27430737, 0x03ec2609, 0x03ecff10, 0x29038212,
    0x03d7ff18, 0x00ecff1c, 0x7d8d0113, 0xdf01ec22, 0xe4207582, 0x7d820382, 0x86144942, 0x087d4361, 0xec204d85, 0x17204d84, 0x8208d341, 0xd8012125,
    0x08bd7418, 0x20054956, 0x189b826a, 0x213ad36b, 0x876a3000, 0xffca270c, 0xffce01d7, 0x6983019a, 0xc3ffd522, 0xd7226d82, 0x1382db01, 0x1400dd24,
    0x0782de01, 0x0382ed20, 0x1f82f220, 0x6d18f620, 0x0225099f, 0x02d7ff6a, 0x200f826d, 0x2007827f, 0x20078281, 0x18038283, 0x200b416d, 0x200f828b,
    0x456d188d, 0x82b8200a, 0x82ba200f, 0xffcf2403, 0x82da02c3, 0x18dc2017, 0x2011596d, 0xfd6e1802, 0x07e3420b, 0x07056f18, 0xc3ff1223, 0x06ef4203,
    0xff1c0323, 0x099d44c3, 0x82490021, 0xffca22a5, 0x21c182ec, 0xbd8501c3, 0xdc01ec22, 0xec22b984, 0x6d82f201, 0x4107a144, 0xaa201733, 0xb2249582,
    0xb402ecff, 0xb6200382, 0xec22a188, 0x6d18dc02, 0x8d851a1b, 0x1803ec28, 0x1a031400, 0x9184ecff, 0x89421c20, 0x0a3d631c, 0xbd459582, 0x0b7d4205,
    0x200fa945, 0x062746cf, 0xd7ffe622, 0x420ca145, 0x1d220b71, 0x4a18cb01, 0xde200e7f, 0xe1200f82, 0xea200382, 0x83062f42, 0x427d20f3, 0x95461e2b,
    0x0b6e180b, 0x2079840e, 0x20df820a, 0x2003820c, 0x82038216, 0x150022eb, 0x059b4a01, 0xdc012922, 0xe4206d86, 0x2406e559, 0x011400e9, 0x05e959f1,
    0x00f60124, 0x79830214, 0xb149aa20, 0x24658706, 0x022900cf, 0x201382d5, 0x244d82fe, 0x03290012, 0x24078218, 0x0029001c, 0x21558216, 0x1b4a013d,
    0x01ec2109, 0x21051b4a, 0xcb860114, 0x192059b8, 0x9a21a782, 0x05bb4601, 0x2407754a, 0xfff60171, 0x060d63c3, 0x28090563, 0x02d7ff8b, 0x029affaa,
    0x180382b6, 0x4507354b, 0x35470b8b, 0xfb6c180d, 0xff182409, 0x431c009a, 0xdc2108af, 0x4e6d90ff, 0x2547082f, 0x2071c505, 0x08254811, 0x4407f144,
    0xd724056f, 0xecfff201, 0xd722df82, 0x0148a002, 0x82cb2006, 0x136b4407, 0xecff1c24, 0x45981000, 0xff46f620, 0x0e0f4506, 0x830cad44, 0x3d5d1841,
    0x82012008, 0x1c00217f, 0x24064944, 0xffd501d7, 0x0649449a, 0x64050d47, 0xb7470597, 0x826a2005, 0x1b014791, 0x9affcf23, 0x0ef94602, 0x22081764,
    0x449aff12, 0x9a2d0a09, 0xeb010200, 0xf4013d00, 0x21003d00, 0x05bb4701, 0xdd019a26, 0xde01c3ff, 0x200a0347, 0x498b82e4, 0xc32205a5, 0x7b827d02,
    0xc3ff8124, 0x03828302, 0x03828b20, 0x41058543, 0xf76a07f5, 0x02d72107, 0x4907f941, 0xd7220537, 0x3782e602, 0x0a6d8418, 0x48fe0221, 0x0e240a07,
    0x1003c3ff, 0x18240382, 0x1f009aff, 0xf743858c, 0x01d72105, 0x02218182, 0xdf6d826d, 0x0101217d, 0x0021e782, 0x0a9b471c, 0x3166ec20, 0x0b89410a,
    0x25071948, 0x000b0229, 0x91410229, 0x178d411f, 0x23088348, 0xd7ffca01, 0x220c7f45, 0x82d7fff2, 0x02ec2155, 0x4513a746, 0xd7211573, 0x05154602,
    0x1802ec21, 0x45138f72, 0xda201373, 0x22c4c16e, 0x6e85ffbc, 0x7f6108c5, 0x294a189e, 0x73c16e10, 0x3f71a920, 0x1bc56e06, 0x220d5b71, 0x82b902c3,
    0x6eba2033, 0xbd2006d1, 0x53560b82, 0xb1d56e0d, 0x2005fd6a, 0x060d69c3, 0x2061d96e, 0xbb981803, 0xc300210b, 0x44b39d18, 0x19198f18, 0x45af9d18,
    0x0b558f18, 0x53a79d18, 0x27a39d18, 0x6f9f9d18, 0x279b9d18, 0x07359018, 0xc3ff6024, 0x03826a02, 0x0b939d18, 0x0f828520, 0x03828720, 0x03828920,
    0x23879d18, 0x5200b924, 0x9d18bb02, 0xf920327f, 0xfb223382, 0x9d183d00, 0x9d181073, 0x7132a36b, 0x73035200, 0x10005200, 0x3d004500, 0x66004900,
    0x07824b00, 0x09c76218, 0x4f003d22, 0x57200f82, 0x59201782, 0x5a200382, 0x5b240382, 0x5c002900, 0x5d280782, 0x70032900, 0x72036600, 0x74200382,
    0x41a70f82, 0x89005221, 0x8c142041, 0x03022e41, 0x0385ff09, 0x0085ff0b, 0x00960002, 0x32018205, 0x000a0000, 0x0001000b, 0x0011000f, 0x00240003,
    0x82060027, 0x8229207d, 0x002c2215, 0x3819822c, 0x002f002e, 0x0032000c, 0x000e0035, 0x003e0037, 0x00440012, 0x001a0046, 0x22c58248, 0x824e001d,
    0x00212201, 0x2edd8250, 0x00550022, 0x00250057, 0x005e0059, 0x826d0028, 0x002e2201, 0x3c01827d, 0x0082002f, 0x00300087, 0x00920089, 0x00940036,
    0x00400098, 0x009f009a, 0x00a20045, 0x224382ad, 0x82b800b3, 0x00ba2c37, 0x005d00bf, 0x00c900c1, 0x82cb0063, 0x006c2401, 0x82cf00cd, 0x00d12643,
    0x007000d1, 0x220182d5, 0x82d70071, 0x00722801, 0x00db00d9, 0x82dd0073, 0x00762201, 0x220182ec, 0x82f00077, 0x00782201, 0x220182f2, 0x82f80079,
    0x007a2801, 0x00fb00fa, 0x82fd007b, 0x7d040901, 0x0101ff00, 0x03017e00, 0x81000301, 0x06010601, 0x08018200, 0x83000801, 0x0a010a01, 0x0e018400,
    0x85000f01, 0x13011101, 0x15018700, 0x8a001501, 0x1d011d01, 0x1f018b00, 0x8c001f01, 0x24012101, 0x26018d00, 0x91002701, 0x2c012c01, 0x30019300,
    0x94003001, 0x32013201, 0x34019500, 0x96003401, 0x3b013601, 0x3d019700, 0x9d003d01, 0x40013f01, 0x43019e00, 0xa0004401, 0x4a014a01, 0x5601a200,
    0xa3005601, 0x62015a01, 0x6401a400, 0xad006401, 0x69016601, 0x6c01ae00, 0xb2006d01, 0x7c016f01, 0x7e01b400, 0xc2008401, 0x88018601, 0x8a01c900,
    0xcc008e01, 0x91019001, 0x9301d100, 0xd3009701, 0x99019901, 0x9b01d800, 0xd900a201, 0xa801a401, 0xaa01e100, 0xe600ae01, 0xb101b001, 0xb401eb00,
    0xed00b401, 0xb801b801, 0xba01ee00, 0xef00c001, 0xc401c301, 0xc601f600, 0xf800c801, 0xd101ca01, 0xd401fb00, 0x03220182, 0x0182d801, 0xda010434,
    0x0501e001, 0xea01e301, 0xec010c01, 0x1401ee01, 0x0182f001, 0x01177a09, 0x01f601f2, 0x02f80118, 0x021d0103, 0x01060206, 0x020a0229, 0x022a010a,
    0x01280228, 0x0258022b, 0x022c0158, 0x01600260, 0x0262022d, 0x022e0162, 0x016a026a, 0x026c022f, 0x02300172, 0x01740274, 0x02760237, 0x0238017c,
    0x018c027e, 0x0295023f, 0x024e019d, 0x01a0029f, 0x02a20257, 0x025901af, 0x01c002b1, 0x02c30267, 0x027701c3, 0x01c502c5, 0x02c70278, 0x027901c7,
    0x01cc02c9, 0x02ce027a, 0x027e01cf, 0x01d302d2, 0x02d60280, 0x028201d9, 0x01db02db, 0x02de0286, 0x028701de, 0x01e902e0, 0x02ef0288, 0x029201fc,
    0x010003ff, 0x030303a0, 0x03a20108, 0x011d030b, 0x031f03a8, 0x03bb011f, 0x01210321, 0x032303bc, 0x03bd0123, 0x01250325, 0x032703be, 0x03bf0127,
    0x01290329, 0x032b03c0, 0x03c1012b, 0x012d032d, 0x032f03c2, 0x03c3012f, 0x01310331, 0x033303c4, 0x03c50133, 0x01360336, 0x033803c6, 0x03c70138,
    0x013a033a, 0x033c03c8, 0x03c9013c, 0x013e033e, 0x034003ca, 0x03cb0140, 0x01420342, 0x034403cc, 0x03cd0145, 0x01470347, 0x034903cf, 0x03d00156,
    0x01580358, 0x035a03de, 0x03df015a, 0x015c035c, 0x035e03e0, 0x03e1015e, 0x01610360, 0x036303e2, 0x03e40163, 0x01660366, 0x036803e5, 0x03e60168,
    0x016a036a, 0x036c03e7, 0x03e8016c, 0x0174036e, 0xfba818e9, 0x001c2208, 0xfba8181e, 0x00002410, 0x05000000, 0x5d0350fa, 0x00000011,
};
```

`sakura/source/fonts/icons.h`:

```h
static const unsigned int compressedIconsSize = 6664;
static const unsigned int compressedIconsData[6664 / 4] =
{
    0x0000bc57, 0x00000000, 0xf01d0000, 0x00000400, 0x00010037, 0x000e0000, 0x00030080, 0x54464660, 0x5c1f9e4d, 0x1d000004, 0x281582d4, 0x4544471c,
    0x004f0046, 0x200f822d, 0x2c0f82b0, 0x2f534f24, 0x65425932, 0x0100000c, 0x2c0f8268, 0x616d6360, 0x64f75470, 0x0200004c, 0x2c138218, 0x7476634a,
    0x02210020, 0x03000079, 0x261f8264, 0x73616704, 0x82ffff70, 0x1d002259, 0x280f82a8, 0x796c6708, 0xf873e966, 0x2c1f8214, 0x170000a0, 0x61656878,
    0xb23d2364, 0x201b8201, 0x210382ec, 0x10826836, 0x02be0723, 0x204b8248, 0x280f8224, 0x746d6824, 0x04ac2c78, 0x200f82b6, 0x280f82c8, 0x636f6c4e,
    0x42ea3c61, 0x833f8266, 0x6d38287f, 0x00707861, 0x82ad0167, 0x2c33821f, 0x616e2000, 0xb39e656d, 0x000067ef, 0x298f821b, 0x6f703702, 0x47027473,
    0xbf82b402, 0x3f825020, 0xeb845820, 0x742b6d82, 0x5f9f4bd1, 0x00f53c0f, 0x82e8031f, 0xdf002417, 0x833744a5, 0x2de02b07, 0xebfe942a, 0x4d05f8fe,
    0x0f825903, 0x02000822, 0x02830582, 0x03273382, 0x003aff29, 0x8215045a, 0x05ec221f, 0x8349844d, 0x20038719, 0x2511840c, 0x007c011b, 0x0083000a,
    0x00000224, 0x13840100, 0x2e004022, 0x002e0b82, 0xea030400, 0x05009001, 0x8a020000, 0x1182bb02, 0x07858c20, 0x00df0125, 0x82020131, 0x05002315,
    0x00870009, 0x0a876f82, 0x50000035, 0x00644566, 0x00410080, 0xff200368, 0x035a0038, 0x82c60029, 0x2323841d, 0xc3021f03, 0x20220b82, 0xc9820100,
    0x09822120, 0x07820020, 0x97200383, 0x97240782, 0x6f001504, 0x09200782, 0x08280382, 0x5300f203, 0x7d00eb03, 0x29200382, 0x7d210f82, 0x32018300,
    0x00ecfe29, 0xff32017d, 0x00030076, 0xff180044, 0x826800db, 0x00532243, 0x200582be, 0x85138200, 0x001c2203, 0x200f8401, 0x83118244, 0x001c2409,
    0x82280004, 0x82062011, 0x00012807, 0x00500002, 0x82ffff68, 0x0041280f, 0xffffff61, 0x86b2ffc2, 0x2212822f, 0x88000601, 0x82e5830c, 0x8a15822d,
    0x8ae98c02, 0x2f0a8b17, 0x06050403, 0x0a090807, 0x0e0d0c0b, 0x1211100f, 0x0b831b8b, 0x15141327, 0x19181716, 0x400b831a, 0x21229503, 0x98827902,
    0x83002a21, 0x76510801, 0xf6009e00, 0x9e014801, 0x30020402, 0xb4028002, 0x2003f402, 0x1c046a03, 0x38054004, 0x32080406, 0x3809d408, 0x4a0be60a,
    0xaa0b900b, 0x0200bc0b, 0x00002100, 0x9a022a01, 0x07000300, 0x01b12e00, 0xb23c2f00, 0xed000407, 0x0506b132, 0x03b23cdc, 0x220a8202, 0x8303b100,
    0x83052016, 0x07b22716, 0x3cfc0106, 0x178301b2, 0x2111333f, 0x11332711, 0x09012123, 0x02c7c7e8, 0x2166fd9a, 0x00005802, 0xff970006, 0x0251038d,
    0x28518251, 0x00230015, 0x002c002b, 0x08a1822d, 0x34262254, 0x14163236, 0x36343501, 0x32013e37, 0x011e1716, 0x2125011d, 0x27263435, 0x0622012e,
    0x15010e07, 0x34363212, 0x14062226, 0x3e021137, 0x945e5e94, 0x2afbfd5e, 0x88864821, 0x2a224885, 0x220292fd, 0x73440d11, 0x0d437478, 0x3450e911,
    0x5c345034, 0x23820101, 0xfe945e3d, 0x3d2b722e, 0x21202110, 0x2b3d1020, 0x11264c72, 0x1a20061c, 0x1c06201a, 0x824e0111, 0x50342526, 0x0030fe28,
    0x978beb82, 0x94000021, 0x9477918f, 0x82ce8263, 0xff6f2ce7, 0x02d3037f, 0x000800e3, 0x821a0011, 0x002f2de9, 0x1700003d, 0x013d2622, 0x15331533,
    0x3b23e883, 0x82231501, 0x35333508, 0x06141533, 0x23351123, 0x16323335, 0x2205011d, 0x36343526, 0x15820a82, 0x0f410520, 0x1ebc2e0c, 0xfeb54c2e,
    0xb51e2eff, 0xb51502b5, 0x2707834c, 0x4ffe2e1e, 0x364c4c36, 0xfe2b0382, 0x2c1c25cb, 0x2d606460, 0x8380251b, 0x024c231a, 0x3083b561, 0x4c9ffd23,
    0x820882b5, 0x2431830d, 0x37364cb0, 0x3a2f834b, 0x2d1d55ff, 0x1616170f, 0x1e2d0f17, 0x00040054, 0x038dff09, 0x005502e0, 0x8219000d, 0x823420ad,
    0x2c7b8cab, 0x26343533, 0x17011e27, 0x011d011e, 0x051d4101, 0x25209f82, 0x2224b882, 0x013e2726, 0x3e211c82, 0x08b38201, 0x24270921, 0x7f87814e,
    0x4229234e, 0x8a4e3842, 0xfd2b262c, 0x5f5f4b86, 0x01606096, 0x0e4b6058, 0x821a0d25, 0x0e330800, 0x604b0e24, 0x3f297273, 0x1f1f2210, 0x293f1022,
    0x5d417472, 0x18220a1f, 0x74263e15, 0x975f7201, 0x4c4b6060, 0x5f4cab5f, 0x521d0604, 0x03234d64, 0x82006006, 0x00023f00, 0x03deff08, 0x007a02bf,
    0x003e0025, 0x15210100, 0x22231523, 0x14011d06, 0x22012b06, 0x0582010f, 0x2627302f, 0x3e373637, 0x23012e04, 0x33373335, 0x28b48201, 0x030e012b,
    0x26221716, 0x08298435, 0x013b163d, 0x24013632, 0xfa299a02, 0x22311812, 0x660c1a8d, 0x128d1a0b, 0x24153b38, 0x0c130803, 0x22290d04, 0x017d152a,
    0x2a111838, 0x030a0502, 0x31220c08, 0x12181812, 0x0218117d, 0x822aa750, 0x31223f15, 0x0417cb18, 0x372b791b, 0x1f230c03, 0xd1131b27, 0x2ab3fe29,
    0x06011811, 0x0c1a1313, 0x22822231, 0x1919112c, 0x53000800, 0x95038bff, 0xff41cd02, 0x00272a08, 0x002f002b, 0x05000042, 0x06f14135, 0x42232121,
    0x0124060d, 0x1d163233, 0x2321b182, 0x34d18325, 0x33363435, 0x07353701, 0x07273727, 0x27351703, 0x11151625, 0x39dd8214, 0x3526012f, 0x013f3411,
    0x02173236, 0x27547dc4, 0x92cefd18, 0x7d542718, 0x0684a001, 0x8360fe21, 0x8c013213, 0xa72aa6a6, 0xa629a7a7, 0x20d401a6, 0x1f1fe520, 0x250582e5,
    0x750f200f, 0x26827d54, 0x92182725, 0x83ee027d, 0x84542005, 0x84fd2a0f, 0x4960bf60, 0xfe62625f, 0x2e0882f9, 0xfe221574, 0x841522f8, 0x15841414,
    0x82080122, 0x08083509, 0x02000000, 0xb5ff7d00, 0xa3026b03, 0x17001300, 0x32010000, 0x27239085, 0x8522010f, 0x37172e91, 0x11271103, 0x0c095603,
    0xdffaeb0f, 0x31068506, 0xa302fadf, 0x8afd090c, 0x574f050f, 0x090c0156, 0x09847602, 0x0166fd26, 0x10fe58f0, 0x00295682, 0xff290007, 0x02bf0361,
    0x2a5782f7, 0x0021001d, 0x00290025, 0x8231002d, 0x2661821a, 0x15070614, 0x822b0614, 0x013d2662, 0x3435012e, 0x240d8801, 0x23153301, 0x08038225,
    0x23150130, 0x07170735, 0x17370527, 0xce8d0107, 0x18394493, 0x1812a612, 0x4d014439, 0x11541118, 0x7da00118, 0x7de9fc7d, 0x54f4017d, 0x593b59fd,
    0x04833002, 0x67932632, 0x4b217444, 0x11181811, 0x4474214b, 0x2a22fe67, 0x2a2a0b83, 0x5454a101, 0x7df40154, 0x2582687d, 0x03821e20, 0x03208582,
    0x8b20f782, 0xcd26f782, 0x16000e00, 0x11821e00, 0x011e3226, 0x07271115, 0x112b0183, 0x22163634, 0x32161406, 0x86363436, 0x8e012507, 0x7d64adcc,
    0x64270084, 0x313144b8, 0x84c93144, 0xcd022605, 0xfe65ad65, 0x28188435, 0x65cb017d, 0x453195ad, 0x82028731, 0x88042055, 0x00172667, 0x0027001f,
    0x2269862a, 0x82070614, 0x862320e2, 0x012e2503, 0x12363435, 0x24206a86, 0x0f220786, 0x75843301, 0x534e592a, 0x53535453, 0x8f64594e, 0x01215a84,
    0x2206841c, 0x847c3efa, 0xa55e237c, 0x7e839434, 0xa5349327, 0xfead655f, 0x227f8aee, 0x83007d4c, 0x82be20e7, 0x009a35e7, 0x0011000b, 0x01000017,
    0x0610011e, 0x013e3507, 0x16272634, 0x35088582, 0x33051611, 0x23271137, 0xa57f4702, 0x755c7fa5, 0x39695c75, 0x06fe3030, 0xa7d0d0a7, 0xcd1c9902,
    0x1ccdf8fe, 0xc49a1b56, 0x6de11c9a, 0x4f01175a, 0xfdd01318, 0x5782d066, 0x76ff292c, 0x6502bf03, 0x26001e00, 0xd5823200, 0x1716202c, 0x23260706,
    0x35360722, 0xc2832634, 0x3732332e, 0x17141506, 0x26222306, 0x32043627, 0x22276c82, 0x33053426, 0x84153315, 0x352908f6, 0x015a0133, 0x0c37f934,
    0x2d4b3e11, 0xac7a032a, 0x18567a7a, 0x0f030a1c, 0x37f99a1e, 0x685f0137, 0x49684949, 0x7d537701, 0x2b02827d, 0x8bad6402, 0x1029201e, 0x7a561114,
    0x06292982, 0x15122421, 0x8b8bad02, 0x3f23820e, 0x7d9c6849, 0x537e7e53, 0xebfe0700, 0xfd047c00, 0x3f003c02, 0x4f004700, 0x6c006000, 0x7c007400,
    0x3522f382, 0x8982013b, 0x1617162a, 0x013b011f, 0x2223011d, 0x21089882, 0x06070607, 0x012b011d, 0x26273435, 0x36372627, 0x1617013f, 0x37013e37,
    0x012e2736, 0x010f2627, 0x0d82012f, 0x35161726, 0x05363734, 0x1d203f82, 0x07872a82, 0x3335372a, 0x011e1732, 0x0e07011f, 0x0f230283, 0x82362501,
    0x0607255b, 0x26272227, 0x17202c88, 0x5f083486, 0x14140704, 0x1d2d5308, 0x0d0d040a, 0x13040a0d, 0x14086d2a, 0x2b410714, 0x0e03040a, 0x493c0e0d,
    0x0609412c, 0x2c410906, 0x110d3b48, 0x29110911, 0x072a0204, 0x5e5f40fb, 0x16015f5e, 0x3d3c3c3d, 0x49cba29a, 0x0a21986b, 0x5e891e0a, 0xba974f35,
    0x210e1103, 0x0c0a0a08, 0x0f090f1b, 0x8cf6fa05, 0x5b200082, 0x02342d83, 0x0d0e0e2e, 0x24381101, 0x1516142d, 0x27170502, 0x0b011758, 0x4a080082,
    0x0a250e01, 0x0a0b0203, 0x0a11300a, 0x1f1f2c43, 0x100b432c, 0x0e0e0a2d, 0x02180e07, 0x09040302, 0x1a1a1701, 0xc8c8941a, 0x0dc8c7c7, 0x143e5811,
    0x14563814, 0x0101050b, 0x0f0a09eb, 0x03171412, 0x18260f0a, 0x931b1b1b, 0x44191a1a, 0x20080c2f, 0x0014000f, 0x26221700, 0x36341135, 0x16322133,
    0x06141115, 0x27212523, 0x1abc2707, 0x021a2525, 0x27058370, 0xfd01cafd, 0x4b618999, 0x28080f88, 0xa4251a90, 0x0084b2cc, 0xfe320105, 0x024d05f8,
    0x007800ca, 0x00b00094, 0x00b200b1, 0x15140100, 0x14061614, 0x0607020e, 0x29588223, 0x023d3634, 0x27343634, 0x0286012e, 0x011d113b, 0x07010e14,
    0x27060706, 0x3d032e30, 0x023c1101, 0x033e2635, 0x013e3037, 0x3e2c8235, 0x26233401, 0x3b37013e, 0x013e3201, 0x3607011e, 0x33321437, 0x1e170616,
    0x011e1501, 0x82171617, 0x20028504, 0x20118214, 0x300e8314, 0x34031516, 0x22070635, 0x2623010e, 0x15141527, 0x42258206, 0x33200503, 0x11205182,
    0x0e221b83, 0x1a882702, 0x82373221, 0x3604835d, 0x02210135, 0x010101a1, 0x03020402, 0x07020607, 0x0c010303, 0x820a0101, 0x05240805, 0x14020401,
    0x10496e2b, 0x02070d09, 0x150e1301, 0x080a1403, 0x0c03021e, 0x01391806, 0x0b121112, 0x0b0a0d01, 0x2d083882, 0x03070101, 0x0407020d, 0x06020303,
    0x06030507, 0x04030501, 0x02020b01, 0x061e274e, 0x5f09171b, 0x1908012c, 0x0d23026b, 0x03020d35, 0x1494030a, 0xf9024008, 0x1801c9fd, 0x0a0152a3,
    0x05030803, 0x02020204, 0x030a0607, 0x1d05f77b, 0x0f030717, 0x04110301, 0xfe031201, 0x0230c7ba, 0x0f020102, 0x051d1709, 0x03070704, 0x0ca60132,
    0x090f2229, 0x8203060b, 0x03330886, 0x06120703, 0x1501022c, 0x01010219, 0x1a040401, 0x0b010104, 0x05020201, 0x11052009, 0x03150205, 0x02062205,
    0x05010313, 0x070e0105, 0x0b071302, 0x82d9fe35, 0x0503240d, 0x82050a02, 0x010927d5, 0x05010d03, 0x3b820701, 0x010c0527, 0x04010270, 0x24028303,
    0x021d040a, 0x221b8203, 0x8502040e, 0x4efd3c1a, 0x75ff0200, 0x7304fffe, 0x16005903, 0x00008400, 0x32213713, 0x00161716, 0x82031617, 0x222125b6,
    0x00262726, 0x052c0282, 0x0607012e, 0x17010e07, 0x27060716, 0x06200b84, 0x15252582, 0x22230614, 0x21088217, 0x1d843637, 0x14830720, 0x16363724,
    0xac411415, 0x05db4105, 0x013b1632, 0x17363435, 0x36373616, 0x37262726, 0x013e3736, 0x0d820482, 0x0b824882, 0x14822720, 0x0607062a, 0x36373435,
    0x2223022e, 0xc4086482, 0x3b010cad, 0x060662dc, 0x04052b01, 0x08069f9e, 0x60dacafe, 0xd2fe0607, 0x1d010204, 0x150a4d01, 0x090b1411, 0x04070704,
    0x46131503, 0x07133a15, 0x170f0b01, 0x2216220b, 0x1506255a, 0x17180102, 0x0a030432, 0x15150608, 0x1d1b120b, 0x10060658, 0x3b0a0203, 0x16151a18,
    0x080b1e0d, 0x2b2b1206, 0x1b030218, 0x020a3915, 0x01022c18, 0x130a200e, 0x1207010a, 0x13481b30, 0x0205021a, 0x090a2e0d, 0x03160909, 0x07031049,
    0x0ef8fd08, 0xfef1fe0a, 0x030503ef, 0x0c020708, 0xf601050c, 0x130114bc, 0x54141715, 0x03031515, 0x02170e10, 0x07081605, 0x0604130e, 0x1744290c,
    0x08040109, 0x4e0e0e08, 0x052f141e, 0x08818204, 0x0c161a6c, 0x1b530505, 0x07051e21, 0x0c0b3e18, 0x09071a1d, 0x250b0404, 0x060f1d72, 0x11010107,
    0x23140208, 0x05021023, 0x080c1713, 0x04070f06, 0x0e150f12, 0x5a0f0404, 0x13153726, 0x000a0001, 0x043dff03, 0x001f036a, 0x00ef009b, 0x011401ff,
    0x013b012b, 0x015e014d, 0x007b016e, 0x013b1300, 0x16171632, 0x1f163217, 0x17011e01, 0x0683021e, 0x82011f21, 0x1e32380d, 0x0e020f01, 0x06222301,
    0x1f160617, 0x15171402, 0x010f0614, 0x8207010e, 0x1601240d, 0x82010f14, 0x1406290d, 0x0614020e, 0x16040e07, 0x1f823982, 0x010e0722, 0x05821782,
    0x2726272e, 0x27262226, 0x012f012e, 0x012e2326, 0x3d240882, 0x013f3601, 0x2305ba41, 0x022e012f, 0x35212082, 0x24118526, 0x3e373634, 0x201b8201,
    0x230e8432, 0x2617013e, 0x23235983, 0x82262706, 0x22012359, 0x69841e06, 0x15062222, 0x2006e143, 0x219c8236, 0x2c821716, 0x83013e21, 0x82368311,
    0x36162d34, 0x37013e34, 0x34262736, 0x26023e37, 0x2e236284, 0x82262301, 0x3426228e, 0x21498413, 0x6782011e, 0x35230282, 0x832e1726, 0x820e20c7,
    0x170124ee, 0x83353616, 0x2627247d, 0x82222603, 0x057a42b8, 0x02844982, 0x26343527, 0x17163601, 0x22f78216, 0x822e2202, 0x173427a4, 0x1e33013e,
    0xf4831701, 0xd8830120, 0x17362632, 0x1e011f33, 0x010e1401, 0x032e012b, 0x0e173435, 0x2e21f382, 0x21548201, 0x9e833237, 0xae822720, 0x16025208,
    0x27260607, 0x15f3012e, 0x03151d25, 0x2c0b0606, 0x2a111712, 0x080d0c14, 0x43556b2c, 0x05081802, 0x0615041d, 0x07331805, 0x274c5229, 0x07020301,
    0x02010a06, 0x04040603, 0x02020103, 0x04020205, 0x02180302, 0x03040b04, 0x201c0802, 0x0302020b, 0x08248201, 0x10050229, 0x201e1006, 0x1d0d320d,
    0x19050304, 0x1739190e, 0x0801040a, 0x01020a5c, 0x010b0101, 0x06030503, 0x04110301, 0x82040704, 0x0e82080f, 0x02020612, 0x140f1603, 0x070f1719,
    0x0d080403, 0x060a0b04, 0x0a0a0213, 0x03020307, 0x040a0e0c, 0x08360402, 0x09050211, 0x0906040c, 0x0a121d02, 0x0c040101, 0x03090403, 0x0a040205,
    0x0f0c090c, 0x0c050905, 0x0a040a07, 0x03050915, 0x1d1f120e, 0x0908110d, 0x11120f01, 0x03060507, 0x01040605, 0x080b2407, 0x132e12d5, 0x2c161018,
    0x0c1f1917, 0x94010305, 0x0d120703, 0x05070b07, 0x0c0a1104, 0xf8820107, 0x01035c08, 0x0e4b0b3c, 0x01032211, 0x332a0c08, 0x06090b0a, 0x0202040c,
    0x03650106, 0x050c0808, 0x06010207, 0x0b061608, 0x0f0f380b, 0x01110503, 0x120c100d, 0x02100402, 0x10140a01, 0x0103045a, 0x250f0601, 0x01031123,
    0x0b02083b, 0x01101318, 0x1501040c, 0x79071d10, 0x06090a0b, 0x820b0603, 0x010e2e63, 0x02021f03, 0x080d0102, 0x131f070a, 0x3bc4820c, 0x01020101,
    0x0d01040b, 0x0d03050b, 0x0102061c, 0x100a0302, 0x07022211, 0x090f0c0f, 0x26089c82, 0x0b190916, 0x0a370d13, 0x3507060e, 0x2d050703, 0x0707070a,
    0x0c1b2d18, 0x0306160c, 0x080c0409, 0x0f070408, 0x82110903, 0x82022099, 0x0a3108d0, 0x14260c07, 0x5a060408, 0x0b0b030b, 0x3b030810, 0x5f0f0508,
    0x4e0a020c, 0x1c280618, 0x2f200f07, 0x040a233f, 0x18040402, 0x0c13140e, 0x03030308, 0x2b6f8204, 0x07073903, 0x01040910, 0x15070906, 0x223ce382,
    0x06040709, 0x05020902, 0x100a0205, 0x0301070c, 0x010b220f, 0x0a070301, 0x040c0901, 0x5608c483, 0x02030104, 0x03051d07, 0x0a170202, 0x0a071008,
    0x0b0b0c04, 0x090e0505, 0x0101080e, 0x13050206, 0x0307ecfe, 0x21230c08, 0x0f020213, 0x0807060f, 0x01030a20, 0x0b070805, 0x0e070a19, 0x12060504,
    0x1110110f, 0xfcfe0102, 0x14050302, 0x0a0b0407, 0x03010323, 0x820c0304, 0x100b240a, 0x8247020f, 0x0a083588, 0x08050610, 0x1111050b, 0x0c102102,
    0x03051001, 0x100c0f0f, 0x0c280783, 0x03050137, 0x01051107, 0x083f6a82, 0x088b0c08, 0x12170a01, 0x13040212, 0x1c0f1302, 0x0507260f, 0x08060c13,
    0x0d04090a, 0x82000f18, 0x02240800, 0x7cff4400, 0xe802b003, 0x77003b00, 0x23250000, 0x3d262722, 0x36373401, 0x2726013b, 0x14152726, 0x012b0607,
    0x06291384, 0x33070607, 0x1d161732, 0x24138401, 0x17161716, 0x84278435, 0x37362313, 0x2c853736, 0x368a2783, 0x548a4583, 0x368a2783, 0x54834583,
    0x40f00238, 0x0c0c0a0e, 0x16400e0a, 0x0c42282c, 0x1048100a, 0x28420c0a, 0x1695162c, 0x0c0ad637, 0x4216520e, 0x080c603e, 0x08124812, 0x423e600c,
    0x0c0e5216, 0x2016960a, 0x8b50a0e8, 0xa2b02067, 0x3c688951, 0x03000000, 0x08001800, 0x9a021804, 0x28001300, 0x00003e00, 0x16272601, 0x010e1415,
    0x21e98226, 0xe3820706, 0x36372030, 0x26273401, 0x06072207, 0x16171415, 0x18823632, 0x3233362d, 0x07140536, 0x04060706, 0x83272627, 0x367b082a,
    0x17203637, 0x03161716, 0x228256ce, 0x2298d098, 0x744a5682, 0x70100170, 0x08b0fe74, 0x32480c08, 0x18080834, 0x30242210, 0xe401100c, 0x86884e0c,
    0x8886d0fe, 0x4c0c0c4e, 0x3001868a, 0x0c4c8a86, 0x46845201, 0x9768443e, 0x45689801, 0x7285453d, 0x4b44444a, 0x0b094b01, 0x33320109, 0x08060c49,
    0x20340911, 0x12d11124, 0x4f4e8416, 0x844e5001, 0x11151216, 0x4e4e5282, 0x82128351, 0x060038c6, 0x3affdbff, 0x28032304, 0x1c000d00, 0x9e002b00,
    0x3601e800, 0x82240000, 0x822320b9, 0x171426b9, 0x37323316, 0x210d8605, 0x0d831415, 0x84113621, 0x82d5840e, 0x0736221c, 0x20d18215, 0x22d48223,
    0x83161716, 0x2209820a, 0x82012f22, 0x280882e3, 0x34272223, 0x26012f26, 0x200b8227, 0x23f08522, 0x3736013f, 0x22201282, 0x21057242, 0x0d823733,
    0x37241885, 0x1f323336, 0x36251c82, 0x33173637, 0x224b8232, 0x83171617, 0x20558713, 0x3353820f, 0x16021f16, 0x15011633, 0x0e010f14, 0x15160701,
    0x07050e07, 0x2e236382, 0x832b2701, 0x23062710, 0x35222726, 0xcf423734, 0x26372206, 0x235e8235, 0x013f013e, 0x17235883, 0x82361732, 0x14172209,
    0x82a58232, 0x841120ab, 0x23b282ac, 0x020e1522, 0x23214f83, 0x82b78207, 0x8206204a, 0x010e2151, 0x23206e82, 0x3422a782, 0x4d892637, 0x34333423,
    0x23438437, 0x3b17011e, 0xa684aa82, 0x82071421, 0xdb01384c, 0x3e3c2a2c, 0x2a2c2c2a, 0x012a3c3e, 0x1e1416e2, 0x2c161420, 0x82161c1e, 0x1c380800,
    0x14162c1e, 0x16141e20, 0x060204dc, 0x2c080c58, 0x04040408, 0x0408262a, 0x101c4208, 0x0c060606, 0x0408046a, 0x1a120c02, 0x06040842, 0x06045206,
    0x02090f12, 0x06560212, 0x5a222783, 0x2f8a0c06, 0x86200c21, 0x8b06202f, 0x05043a2e, 0x0e02050a, 0x02045806, 0x6e010402, 0x06030554, 0x0a021e04,
    0x080c0e12, 0x08118206, 0x1408162f, 0x02121002, 0x04160814, 0x1e042e18, 0x0c545412, 0x08041e06, 0x0416060c, 0x1e160412, 0x08080a08, 0x02042212,
    0x061e0246, 0x1054540c, 0x223a8402, 0x82040a06, 0x1406263b, 0x020a060c, 0x25228208, 0x0c060a02, 0x3f830614, 0x0a292483, 0x14041e08, 0x06121c04,
    0x365b8214, 0x161e1012, 0x02420604, 0x54080a1e, 0x2a2c77f7, 0x3070302a, 0x82bc2a2a, 0x151622ef, 0x08fa831d, 0x21680248, 0x1f2b1613, 0x14141b19,
    0x086ad216, 0x1b0e0602, 0x080a3811, 0x06040604, 0x0401212e, 0x3e060c34, 0x04010d1a, 0x58010702, 0x03340c06, 0x0e4c0601, 0x140a0804, 0x28020c14,
    0x08080e08, 0x0601096a, 0x391a120e, 0xd7820909, 0x222e062a, 0x0c063404, 0x010f1b3d, 0x2f833f82, 0x06047b08, 0x0408104a, 0x06081509, 0x1e02060c,
    0x02040c12, 0x50c7fe03, 0x060a0b07, 0x0c420509, 0x090a0504, 0x03040308, 0x04170b1c, 0x1c0a1804, 0x0c041c0e, 0x070b1e42, 0x15090950, 0x040e4207,
    0x0b030804, 0x281a0a04, 0x18020103, 0x02280228, 0x08420e02, 0x3f020914, 0x180a0850, 0x020e4204, 0x080b0502, 0x04020602, 0x08101a02, 0x0202010f,
    0x10080f01, 0x04190f1a, 0x1309410f, 0x4582080a, 0x820c1221, 0x09032a64, 0x1a081004, 0x27051908, 0x82428219, 0x09123911, 0x02000000, 0x7cff6800,
    0xe8028c03, 0x41003500, 0x14250000, 0x21230607, 0x4b060543, 0x05830502, 0x1732332c, 0x1e17021e, 0x37363201, 0xef42023e, 0x16172105, 0x03200187,
    0x31843382, 0x32362708, 0x2a8c0316, 0x0cfe4628, 0x022a2846, 0x06080404, 0x12101406, 0x221e1e14, 0x10041404, 0x5016080e, 0x08165048, 0x0d82100e,
    0x1e223308, 0x1012141e, 0x08060614, 0xb6020404, 0x44b04440, 0x80b88040, 0x262a4410, 0x28442a26, 0x2c162812, 0x1c241412, 0x0a0c1412, 0x0a0c020c,
    0x18180e04, 0x0a84040e, 0x12140c35, 0x1214241c, 0x1228162c, 0x4458d601, 0x58444040, 0x8380805a, 0x002208c7, 0x000438ff, 0x15003803, 0x00002700,
    0x17011e01, 0x0607010e, 0x010e0702, 0x27012e23, 0x0137013e, 0x1582013e, 0x14011f27, 0x012e0706, 0x08bc8237, 0x3e37328a, 0x289c0301, 0x0e01023a,
    0x3ca7270b, 0x4b243e1a, 0x1b010263, 0x0f6d0119, 0x170dfe26, 0x95012f4d, 0x0186917c, 0x1615283a, 0x037a2409, 0x29330138, 0x4d142b17, 0x193eddfe,
    0x4a66021b, 0x01173f23, 0xfd110e4b, 0x0d3d2cb1, 0x02957c28, 0x2a88be04, 0x5c15031c, 0x0001003e, 0x039fff53, 0x00b70295, 0x17000009, 0x1b252713,
    0x13070501, 0xe343f325, 0x75752c01, 0x43e32c01, 0x0161fffe, 0x011ac525, 0x1aecfe14, 0x9cdbfec5, 0x003db082, 0x030600be, 0x00f00165, 0x25000005,
    0x01173727, 0xeaa80117, 0x9001bd2d, 0x2cea062d, 0x200682bc, 0x22008200, 0x82ae000e, 0x8208825d, 0x00252202, 0x200b864c, 0x20678201, 0x240b8686,
    0x00070002, 0x240b86a0, 0x00260003, 0x240b86f6, 0x01090004, 0x240b8631, 0x010f0005, 0x200b865b, 0x25178206, 0x0003007f, 0xab820401, 0x824a0021,
    0x240b8557, 0x00120001, 0x24178672, 0x000e0002, 0x200b8690, 0x20758203, 0x240b86a8, 0x01120004, 0x240b861d, 0x011e0005, 0x200b863b, 0x28178206,
    0x0043006b, 0x0070006f, 0x2e458279, 0x00670069, 0x00740068, 0x00280020, 0x82290063, 0x00322407, 0x82320030, 0x822c2001, 0x8272200b, 0x007a2427,
    0x82770064, 0x006a2607, 0x006e0065, 0x26058269, 0x006a0020, 0x847a0061, 0x0028080d, 0x79706f43, 0x68676972, 0x63282074, 0x30322029, 0x202c3232,
    0x647a6f72, 0x656a6f77, 0x2065696e, 0x6e7a616a, 0x55000069, 0x74202d82, 0x74223d82, 0x41826c00, 0x31006422, 0x6e261282, 0x6c746974, 0x0a826465,
    0x13825220, 0x75006722, 0x61201b82, 0x002a9382, 0x75676552, 0x0072616c, 0x77824600, 0x9d826e20, 0x72200783, 0x6520a982, 0x2e209f84, 0x2022a182,
    0x0b823a00, 0x17855591, 0x34003224, 0x63822d00, 0x05823120, 0x0031cf87, 0x746e6f46, 0x67726f46, 0x2e322065, 0x203a2030, 0x827f8755, 0x3432250b,
    0x2d31312d, 0xaa9fbd83, 0xaa825620, 0x73007222, 0x6f20ca82, 0x2020d282, 0x30208a82, 0x92836882, 0x0b823020, 0x6556002f, 0x6f697372, 0x3030206e,
    0x30302e31, 0x224d9f30, 0x84000200, 0xb5ff2300, 0x08843200, 0x1b20048f, 0x01201082, 0x242c2582, 0x26002500, 0x28002700, 0x2a002900, 0x22068159,
    0x822f002e, 0x82312072, 0x00333039, 0x00450044, 0x00470046, 0x00490048, 0x834b004a, 0xffff2135, 0x01203782, 0x0c200982, 0x1c200382, 0x022c0382,
    0x03000200, 0x01001200, 0x1a001800, 0x04200582, 0x04821384, 0x05820b82, 0xed4cde23, 0x5c068238, 0xfa050cdf, 0x868d226f,
};
```

`sakura/source/fonts/weapons.h`:

```h
static const unsigned int compressedWeaponsSize = 29695;
static const unsigned int compressedWeaponsData[29696 / 4] =
{
    0x0000bc57, 0x00000000, 0x40ee0000, 0x00000400, 0x00010033, 0x000d0000, 0x00030080, 0x4f504750, 0xbefdaf53, 0x201182eb, 0x2c0382dc, 0x2f534f36,
    0x4f9b8432, 0x01000010, 0x280f8214, 0x616d6360, 0x6e939970, 0x200f82e8, 0x26038274, 0x736167ae, 0x82ffff70, 0x03002239, 0x3c1f8224, 0x796c6708,
    0x07e7fb66, 0x030000f1, 0xe600002c, 0x616568c8, 0x3ea92164, 0xe900007d, 0x211f82f4, 0x10826836, 0x00b80526, 0xea00000b, 0x00291f82, 0x746d6824,
    0xf24d4478, 0x200f8296, 0x241f8250, 0x72656b84, 0x208f826e, 0x200f820f, 0x280f82d4, 0x636f6c12, 0xad0d0061, 0x820f82d8, 0x88002d73, 0x7078616d,
    0xe9022a00, 0x70eb0000, 0x20281f82, 0x656d616e, 0xee54d990, 0x902f0f82, 0x4c020000, 0x74736f70, 0x1f038302, 0x83ed0000, 0x846420bf, 0x000a2edb,
    0x002c001e, 0x4c464401, 0x00080054, 0x83378204, 0x82012002, 0x84012004, 0x8308206f, 0x22038409, 0x82090004, 0x30028307, 0x01a80202, 0x00050090,
    0x028a0200, 0x002f00bc, 0x2807838c, 0xe0015cff, 0x02013100, 0x83008d00, 0x2f118849, 0x64726942, 0x20004000, 0x1f036300, 0x660029ff, 0xd7208b82,
    0x04825b84, 0x823d0221, 0x8200200d, 0x0002251b, 0x00030000, 0x1c203785, 0x01210985, 0x24078222, 0x0100000a, 0x21038262, 0x1c860006, 0x02832782,
    0x90000221, 0x90032000, 0x39108e11, 0x07060504, 0x0b0a0908, 0x0f0e0d0c, 0x13121110, 0x17161514, 0x1b1a1918, 0x28851d1c, 0x201f1e22, 0x05400885,
    0x00042296, 0x26998240, 0x0008000c, 0x82040002, 0x000d2809, 0x005a0020, 0x82ffff63, 0x0000220b, 0x220d820d, 0x82610041, 0xff012a0d, 0xffe3fff5,
    0x00bdffc3, 0x87198401, 0x840c2004, 0x844c2008, 0x00002205, 0x83078605, 0x82012006, 0x860d2004, 0x00022403, 0x86200000, 0x82032003, 0x82412007,
    0x825a2003, 0x82042003, 0x82612003, 0x82632003, 0x821e2003, 0x00002203, 0x2e6b8201, 0xfe020002, 0x030100fe, 0x0034011c, 0x82fd00db, 0x01002114,
    0x21fa0140, 0xfc831a03, 0x0083ff20, 0xfbfffd22, 0xfc240682, 0xfdfffeff, 0xfb200182, 0xf7240d82, 0xafffd8ff, 0xfc200f82, 0xfb240382, 0xc7ffe3ff,
    0xd3222784, 0x1b82a6ff, 0xfcfff524, 0x2784f8ff, 0xfafffd22, 0x04831784, 0x1582fe20, 0xd7ffec2a, 0x02000000, 0x05000300, 0x07280182, 0x09000700,
    0x0e000a00, 0x13200182, 0xfb2a2f84, 0xf9fff6ff, 0xf2fff3ff, 0x0582f4ff, 0xf5fff422, 0xf7200188, 0xfe201984, 0xff202582, 0xfc220382, 0x6782f7ff,
    0x0384fa20, 0x2d82f920, 0x6782fa20, 0xfd200383, 0xf5201184, 0xfc200582, 0xfc206d82, 0xaf830782, 0xfb203183, 0xf4202182, 0xfb200f82, 0x03831782,
    0x89821784, 0x04000522, 0x03838382, 0x06000322, 0x19838384, 0x51830385, 0x6982f220, 0x7b82ee20, 0xe5ffec28, 0xddffcaff, 0x2382b9ff, 0x3382fa20,
    0x03820420, 0x06000528, 0x08000d00, 0xc7820f00, 0x05820d20, 0x16001d24, 0x4f842b00, 0x0c000622, 0x08200782, 0x11201f86, 0x1b22df82, 0x6d820100,
    0xa6005422, 0x20085042, 0x26098202, 0x00070004, 0x82800040, 0x0007222b, 0x262d8203, 0x00050003, 0x8435001b, 0x831b833b, 0x00172213, 0x2039822f,
    0x201f8203, 0x20078205, 0x203f8804, 0x20098200, 0x20008200, 0x82838206, 0x20398206, 0x2406820c, 0xfd010001, 0x23278292, 0xff000002, 0x20057541,
    0x06b541fe, 0xf0fff722, 0xfd20bb82, 0x1183ff82, 0x6943fe20, 0x20958306, 0x20578402, 0x22618203, 0x82110008, 0x82032005, 0x82fb200f, 0x82fc2035,
    0x82fd2040, 0x84fe2003, 0x82002073, 0xfffb2251, 0x832b84f7, 0xfffd220b, 0x860b8cfb, 0xfeff2113, 0x7b821782, 0x83087545, 0x820120a7, 0x23108255,
    0xf4fff5ff, 0xf6200184, 0xf3210584, 0x260187ff, 0xfff9fffd, 0x82f1fff8, 0x00ea241f, 0x820b0009, 0x820d2001, 0x000e2403, 0x8210000e, 0x00142401,
    0x82160013, 0x2155823e, 0x0782feff, 0xc7820220, 0x6782fe20, 0x0d829a82, 0x5b820020, 0x04000322, 0xfa20af84, 0x0b425782, 0x82f92005, 0x84fa2051,
    0x20298503, 0x208f84fd, 0x26b18201, 0x00050003, 0x82080006, 0x82092005, 0x84112005, 0x00032203, 0x22cb8407, 0x82010002, 0x82678401, 0x82fc2063,
    0xfff92203, 0x224582fc, 0x82edfff6, 0x00e92459, 0x8255002a, 0x84022027, 0x82012003, 0x82ff2073, 0x82002055, 0x06454131, 0x20062f41, 0x411182fd,
    0x022005dd, 0x0c226582, 0x17821700, 0x2985b783, 0x19410120, 0x8400200a, 0x83fe20c5, 0x2323871f, 0xf7fffbff, 0xf8207382, 0xfc200f82, 0x33852982,
    0x0b000623, 0x05a34200, 0x7b820220, 0xf1820120, 0x63840420, 0xff232082, 0x41e0fff0, 0xff2208e9, 0x1b82b8ff, 0x2b820720, 0x03000322, 0xcf84eb84,
    0xd1820020, 0x84010021, 0x42fd2025, 0xfc20060d, 0xfe20db82, 0x85084741, 0x844d829d, 0x00002e5d, 0x0068ff02, 0x01df0201, 0x01310072, 0xff0745f5,
    0x21f80346, 0x0084ff15, 0x00830020, 0x24073d42, 0xfffefffa, 0x831682fd, 0x84f92005, 0x82ff2007, 0xfff92611, 0x00fefff1, 0x05434700, 0x0d430020,
    0x000a2605, 0x00080015, 0x24018206, 0x00030005, 0x2201820b, 0x82020012, 0xffff262b, 0xfff3fffc, 0x2c2b82e7, 0x01ffff00, 0x000200a9, 0x00070004,
    0x2064820f, 0x086f4602, 0xf3205385, 0x88074f43, 0xfffc2273, 0x229284f8, 0x83f2fffa, 0x2089826d, 0x08e744f9, 0xf4fffa22, 0xff248f86, 0xabffd5ff,
    0xfc201b82, 0x4f829f88, 0xfe202782, 0xee203d82, 0xfd201382, 0x11820b82, 0x82fdff21, 0x0003236f, 0x9f830002, 0x9b820220, 0x19832e82, 0x82065745,
    0x20c98490, 0x221f8203, 0x82feff01, 0xfffc2601, 0xfff5fffb, 0x21bd82f9, 0x7782fffc, 0x01202082, 0x04202184, 0x82063543, 0x061b41cf, 0x1182ff20,
    0x0222d783, 0x95820600, 0xef84ea20, 0x7d82f920, 0xf6fff722, 0xed200182, 0x4b834782, 0xf7fffc28, 0xf2ffefff, 0x1382e2ff, 0x6184eb20, 0x59858189,
    0x22051346, 0x84030002, 0x820620a9, 0x82022007, 0x05694559, 0x4582fd20, 0xf0fff722, 0xee204382, 0xfc229382, 0x3c82fcff, 0xf584ff20, 0xc586fc20,
    0x2f820420, 0x09000624, 0x01820800, 0x81450720, 0x82fc2006, 0x82eb20c1, 0xffea2203, 0x202582ff, 0x823383fe, 0x82fd2007, 0x82fa2041, 0x84fb2041,
    0xfffe2399, 0x1984fffd, 0xf7201182, 0x5a84ef84, 0x0b831386, 0xcb82fb20, 0x4582f820, 0x3784f420, 0xfe202b83, 0x03209782, 0x77460384, 0x84ff2007,
    0x82fd2045, 0x82dd20e1, 0x84fd2039, 0x84fd20df, 0x84ff2013, 0x82fb20b9, 0x82fd200b, 0x200287ca, 0x086d4101, 0x05000a24, 0x01820400, 0x5d000324,
    0x1e84bb00, 0x2205a341, 0x82050007, 0x000622c9, 0x2113830b, 0x6746feff, 0x83078205, 0x82f384f9, 0x82f62057, 0x208f839e, 0x0a1f46fc, 0x01225985,
    0x61820300, 0x43820120, 0x07820a20, 0x6d840020, 0x51451383, 0x85002005, 0x205982bb, 0x22218203, 0x82070003, 0x82002009, 0x00182869, 0x001c000e,
    0x82090005, 0x8404201f, 0x20188303, 0x054d4102, 0x06200582, 0xfd228b84, 0x0784faff, 0x84ffff21, 0xf8ff23d1, 0x2b82f1ff, 0x20075747, 0x206b8202,
    0x837b8800, 0x82022028, 0x220783dd, 0x830a0006, 0x202b8206, 0x20078404, 0x200f8805, 0x850f8e05, 0x222f8f1f, 0x82080004, 0x841520a3, 0x0002262b,
    0x002e0006, 0x200b825c, 0x20db8402, 0x85198206, 0x820620df, 0x8203200f, 0x460b201d, 0x01220879, 0x81820100, 0x27840720, 0x01232d83, 0x41ffce00,
    0xfe2105af, 0x46cb82ff, 0x308208af, 0x1182ff20, 0x0020db85, 0x24051747, 0xffe5fff3, 0x200182fc, 0x470382fd, 0x0547055b, 0x22ef8507, 0x82110002,
    0x001e2401, 0x84050002, 0x203c8263, 0x822182ff, 0x46482003, 0x6b8308b3, 0xf9fffd22, 0xfa214182, 0x824382ff, 0x20028322, 0x83048301, 0x8a0f8665,
    0x06f54213, 0xfffffe22, 0x01241b8e, 0xfeffffff, 0xfb20b382, 0x01201784, 0x13822786, 0xff230f83, 0x82eefff7, 0x05cb421d, 0x87851382, 0xfe203184,
    0xfa227d82, 0x8182fbff, 0xf3fff926, 0xf1fff8ff, 0xf8200f82, 0x27840384, 0x07823582, 0x00010023, 0x22038203, 0x86090002, 0x00072401, 0x8206000e,
    0x820420d5, 0x00042267, 0x06934907, 0x0220f783, 0x27452b86, 0xfffc2205, 0x247b82f6, 0xfff2fff1, 0x205382e4, 0x836782fb, 0x41fd2083, 0xeb830a57,
    0x3f820220, 0x59820620, 0x49820720, 0x57820420, 0x5b840a20, 0x2005eb43, 0x24658205, 0x00050005, 0x20138406, 0x06954804, 0xef444082, 0x84fd2008,
    0x82fe20d9, 0xfff5245b, 0x82f0fff4, 0xffec2601, 0xffecffe0, 0x217982eb, 0x6943fffc, 0x82fc2005, 0x82fc20d9, 0x00ff2281, 0x209f8400, 0x246d8404,
    0x000f000e, 0x22018210, 0x84110011, 0x00102205, 0x82078208, 0xfaff2121, 0xff20b782, 0x00202982, 0x0220df82, 0x22068d45, 0x82fcfffe, 0x82f92063,
    0x84fa2055, 0x82fd20cb, 0x83138305, 0x20838779, 0x0cb541fe, 0x39820120, 0x0322db83, 0x01820400, 0x26001324, 0x71821800, 0x05000f22, 0x0220ef82,
    0x03205982, 0xfb851582, 0x79820320, 0x2d840420, 0x17820020, 0x09840420, 0x05203985, 0x0220b182, 0x08205584, 0x87423b82, 0x05fd4105, 0x25820120,
    0x4209e741, 0x0320050f, 0x20066b42, 0x20598207, 0x20bf8403, 0x05d94400, 0x01202b86, 0x4f831385, 0xffffff23, 0x834e82fd, 0x88052041, 0x44cf8215,
    0x258209bf, 0x2384fe20, 0x8f840020, 0x4b862c82, 0xf2ff0024, 0x0e82e2ff, 0x1f895b87, 0x20082343, 0x055545ff, 0x0f44fe20, 0x08374b05, 0x37834082,
    0xff270fbf, 0xfff5fffb, 0x86f9fffd, 0x835283c3, 0x860120d9, 0x09634a93, 0x6b84a182, 0x82076b4a, 0x07394320, 0x022c0784, 0x040074fe, 0xf9009103,
    0x4d013701, 0x01df0910, 0x8f03234f, 0x01820100, 0x4805db4b, 0x5d23056b, 0x8300b9fe, 0x000c2200, 0x42068318, 0x9b4b066b, 0x052f4d09, 0xff201a82,
    0x2b052744, 0xfff1fff9, 0xffdbffee, 0xffb8ffdc, 0x4f840082, 0x35820120, 0x1f820020, 0x2307e748, 0xfffcfffe, 0x2007f141, 0x221b8200, 0x82030001,
    0x00012440, 0x82040006, 0x82022009, 0x2c078303, 0xffe2ff05, 0xfffdffc4, 0xfff9fff8, 0x200582f2, 0x05134ff2, 0x02822982, 0xffddff22, 0x49839784,
    0x2006b948, 0x201f82fb, 0x202b84f7, 0x200582fa, 0x4e0382f9, 0x2e820645, 0xfe207d83, 0xfd208182, 0xfb200382, 0xf52a2384, 0xf6ffeaff, 0xfaffebff,
    0x3782f5ff, 0x3b84f820, 0x0d82fd20, 0xd8ffec22, 0xfb852382, 0x15833f85, 0x1982f620, 0x6b82f420, 0x6b82f820, 0x0782f920, 0x2f82f620, 0x0b82f620,
    0x2282f820, 0xe984c982, 0x03876683, 0x85000221, 0x22cb8500, 0x821b000e, 0x000821d9, 0x8305d342, 0x82022005, 0x0003240b, 0x4d490024, 0x04260893,
    0x2a000800, 0x17825300, 0x85050347, 0x0001243f, 0x820c0006, 0x820a203b, 0x05234127, 0x21820120, 0x19000d22, 0xfc20d384, 0xfc20c182, 0xf826cd82,
    0xf8fff1ff, 0x0382efff, 0xcd44f120, 0x46ff2009, 0x3982106f, 0x4b820120, 0x07000628, 0x09000f00, 0x5b841100, 0x08205f83, 0x06240f82, 0x05000d00,
    0x58838382, 0x2207d341, 0x841a000d, 0x0002220e, 0x4be18503, 0x16220a55, 0x47842d00, 0x14000a22, 0x13204b82, 0x0a203b82, 0x01215f84, 0x056b4700,
    0xc4ffe222, 0xff213b83, 0x829582fc, 0x220b839f, 0x4601fe00, 0x00230ceb, 0x4562fc01, 0x1e820659, 0xfffeff22, 0x2205174a, 0x41faffef, 0x14820581,
    0x02000322, 0xb183a582, 0xa7000622, 0xfc201582, 0xfd200382, 0xfc225382, 0x41420000, 0x073f4705, 0xfff5ff25, 0x82ffffeb, 0x059f4719, 0x0b82fc20,
    0xb388fe20, 0x82fffe21, 0x8a4d822f, 0x201b8202, 0x82cd85fd, 0xfffe2151, 0x01209787, 0x09208f82, 0x04217182, 0x20018300, 0x86d18403, 0x051f4535,
    0x2208394b, 0x84010000, 0x845b8243, 0x824c8497, 0xfff52295, 0x249382ea, 0x000c00f8, 0x840d8216, 0x086b5215, 0x42050f43, 0x63410513, 0x20b18206,
    0x20ef82f6, 0x200384f4, 0x850582fd, 0x20798323, 0x20fb8204, 0x20878204, 0x2003820a, 0x08af5008, 0xecfff722, 0x25834f82, 0xff234182, 0x820100fe,
    0x85948219, 0x08b15202, 0x7b82fd20, 0x22096143, 0x82050003, 0x820c20d3, 0x00172893, 0x001b000e, 0x4215000a, 0x01200877, 0x3c834182, 0x61490120,
    0x820d830c, 0x834f8410, 0x82f820e1, 0x8200200c, 0x84072087, 0x8373878b, 0x450b8907, 0x042209b1, 0x2f840700, 0x82ff0021, 0x088f4883, 0x8305ef45,
    0x00072225, 0x2047820d, 0x85838209, 0x86002013, 0x44078583, 0x45850a5b, 0x01200582, 0x00220382, 0xc7820300, 0x02206f83, 0x13840784, 0xfffcff23,
    0x41eb82f7, 0x0987060f, 0x02213184, 0x822b8300, 0x08154103, 0xddffef22, 0x00201982, 0x03207782, 0x3b412982, 0x201d8206, 0x05134dfd, 0xfe212784,
    0x051742ff, 0xa3fffe22, 0xeb472b82, 0x4b052005, 0x12820861, 0xfe241f82, 0xfafffbff, 0x0e820783, 0x022c0287, 0x0300fcff, 0x4b014402, 0x29010501,
    0x01970610, 0x4402212b, 0x21054241, 0x0182fdff, 0x4d05c94b, 0xfc220971, 0x0184d7ff, 0x6f53d620, 0xfff22206, 0x220182fa, 0x82fbfffb, 0x45fc2005,
    0xff2008fb, 0x3d824183, 0x3d55fe20, 0xfff8210a, 0xfa220185, 0x0982f7ff, 0xf6fffb24, 0x0186feff, 0xdb455d85, 0x29058205, 0x04000300, 0xf2ff0100,
    0x0182f1ff, 0xedfff226, 0xeeffefff, 0x47550182, 0xfffe2205, 0x07e145f9, 0x22069946, 0x82050006, 0x43072001, 0x234d0a3f, 0x53002005, 0x9b83087d,
    0x3782f620, 0x7782f920, 0xa382f920, 0x9982fc20, 0xaf82fc20, 0x20058f43, 0x266f8400, 0x00080007, 0x82060007, 0x82052079, 0x052e4249, 0x69820020,
    0x8305bd4e, 0x0d5f4ea9, 0x35820420, 0xcf420120, 0x20078506, 0x200d8202, 0x082d4706, 0x83000621, 0x84022001, 0x201983ab, 0x20558203, 0x83138203,
    0x82042007, 0x82012065, 0x82052029, 0x82032007, 0x82042075, 0x000622bf, 0x20018614, 0x21438403, 0x274c0004, 0x00122207, 0x20018213, 0x20158412,
    0x22758602, 0x84020001, 0x820720ad, 0x00162105, 0x17200183, 0x4608734a, 0x02240519, 0x03000000, 0x0a822d86, 0x31851d82, 0x73820320, 0x20055b4d,
    0x83f78404, 0x839f8383, 0x209783c3, 0x458b8202, 0x00260609, 0xfe000001, 0x4f8200cf, 0x00204083, 0xff231584, 0x82f9fff5, 0x84fa2001, 0xfff82105,
    0x85058544, 0x2005831e, 0x83048201, 0x8202205d, 0x82052065, 0x8208209b, 0x8207204d, 0x01072c07, 0xffffff20, 0xfffbfffe, 0x84f8fffa, 0x82f82003,
    0x45f82041, 0x348206e5, 0x2982028f, 0x8205a541, 0x212f8463, 0x0183fff7, 0x2783fb20, 0xff204782, 0x54828d86, 0xff201184, 0x03226f82, 0x5382fcff,
    0xf5242583, 0xf3fff4ff, 0xf4200382, 0xfa203982, 0x83069d42, 0x203d82b5, 0x064d44ff, 0x9b51db83, 0x22a5830c, 0x840c0005, 0x000b2401, 0x4c10000f,
    0x05200665, 0x0524c182, 0x03000200, 0x0d850184, 0x0a000524, 0x17820600, 0x830a6742, 0x85038485, 0x82022013, 0x8406201d, 0x82022031, 0x2013833b,
    0x20a18207, 0x20118204, 0x42078204, 0x02200503, 0x4108d146, 0x012007a7, 0x01204184, 0x0f84df89, 0x05200485, 0x83069b42, 0x200b833b, 0x48bd8701,
    0xff210555, 0x22fd82fb, 0x82fefffe, 0x8345852c, 0x860c8277, 0x51012002, 0x2b85051f, 0x09871383, 0x83082749, 0x201883e1, 0x84198700, 0x8204880c,
    0x095b4f3f, 0x01000022, 0x8809d34d, 0x00002222, 0x20df8202, 0x82058202, 0x202f821d, 0x479182fd, 0x002306d0, 0x82feff00, 0x82fb2011, 0x82fc2011,
    0x82812003, 0x840620cb, 0x00082403, 0x8a0a0009, 0x820a8241, 0xfff62132, 0x20051d42, 0x207584f9, 0x520582ff, 0xfe20058f, 0xdf859b84, 0x02822982,
    0x27ff0430, 0xd902feff, 0xcd004601, 0xa9017d01, 0x0510d301, 0x562b01e7, 0x0022a98b, 0x394800d7, 0x43002006, 0x04200589, 0x5d430786, 0x05874305,
    0xd2820583, 0x2709ff4b, 0x0000ffff, 0xeafff5ff, 0x22082b44, 0x82fafffc, 0x20058501, 0x200982fa, 0x831d82f6, 0xfffa2203, 0x220d82fb, 0x84f6fffb,
    0xfff9221f, 0x206d82f7, 0x054d4a00, 0x00820020, 0x4d442582, 0x82f82005, 0xfff9221f, 0x200182f8, 0x222b82f5, 0x84fdfff7, 0xffff224d, 0x210182fe,
    0x2751fffd, 0x062f5207, 0xb3834382, 0x8206b94d, 0xfff4222f, 0x214982f3, 0x0785fff4, 0x014bff20, 0x85a38405, 0x83fa2057, 0x0000210b, 0x294c1184,
    0x21f78509, 0x2f430001, 0x00052405, 0x82030004, 0x00042201, 0x20058205, 0x20b58403, 0x205182f5, 0x204d82f8, 0x45aa8201, 0x042207d9, 0x21820800,
    0x80432382, 0x41198205, 0x062007ec, 0x05831784, 0x1a825185, 0x0420a984, 0x04225982, 0xe94f0500, 0x82002008, 0x000d2209, 0x2201820c, 0x8207000d,
    0x82082001, 0x20318303, 0x24238407, 0x00470002, 0x823a838d, 0x4e542003, 0x06200851, 0x65524382, 0x205b8905, 0x852f8205, 0x225183ad, 0x821a0000,
    0x82192001, 0x00012103, 0x8c204383, 0x02833f82, 0x03850d83, 0x0a000824, 0x814e0900, 0x211b8208, 0x1141fdff, 0xf5ff2907, 0x0000e9ff, 0xf7ffffff,
    0xf5200982, 0xf5200586, 0x57410b82, 0xfff62205, 0x200182fb, 0x0c3f41fc, 0x01000224, 0xe150feff, 0xf4ff2307, 0x0182f2ff, 0xf0fff324, 0x0182ecff,
    0xf9fff222, 0x55481b82, 0xfffd2207, 0x226c82fc, 0x82040003, 0xfff82257, 0x223382f8, 0x82f6ffff, 0x82f4200b, 0x84038235, 0x82fe2077, 0x2003832f,
    0x056342fc, 0x82010021, 0x82038231, 0x82f9202d, 0x82f9204b, 0x089f540d, 0x2553ff20, 0x20d38305, 0x23258402, 0x00070003, 0x24057541, 0x00080008,
    0x20798402, 0x205b84fc, 0x827983f9, 0x8204202f, 0x000426f5, 0x00030004, 0x2029820a, 0x07054606, 0x83e3fe21, 0x2003845b, 0x45e184f8, 0xd5830515,
    0x7941fe20, 0x82032008, 0x8202203b, 0x82052061, 0x22678739, 0x82130006, 0x820a2049, 0x82012019, 0xff00225d, 0x207386fd, 0x244b82fb, 0x010000f2,
    0x20e384b1, 0x4f5384fb, 0xd14e0731, 0x05d55c05, 0x4105ed41, 0x062205c9, 0x4b841200, 0x71830120, 0x4b893782, 0x85fff621, 0x22558301, 0x823401fa,
    0x5cf385bd, 0xff2209fd, 0x81410000, 0x22378405, 0x82fcfffa, 0x82fa2071, 0x058b438d, 0x3f82f520, 0xf5fff523, 0x82008200, 0x4902851f, 0x13820797,
    0x01200286, 0x25850786, 0xb384fe20, 0xf8fffa22, 0xf6203b84, 0xfc205d88, 0xfc205b82, 0xff200d82, 0x84069941, 0x43ff2089, 0xe785059d, 0x60fff921,
    0xf4200505, 0x46081548, 0x05830569, 0xfd222183, 0x5753faff, 0x206c8209, 0x06934105, 0x04000424, 0x0f820500, 0x01000122, 0x05830982, 0x07210383,
    0x05e34700, 0xf5820320, 0x22053f4a, 0x860d0007, 0x00082401, 0x82080007, 0x000a2201, 0x20058209, 0x8305820b, 0x05f34731, 0x2009c94e, 0x22238401,
    0x820b0008, 0x8406205d, 0x00022103, 0x210a3941, 0x0d82ffff, 0x11840320, 0x09500320, 0x42158209, 0xfc200967, 0xad4ab182, 0x88168208, 0xffff2102,
    0xfd20f982, 0x01240e86, 0xfaff0000, 0x82069b41, 0x0566412d, 0x82010021, 0x82042011, 0x82032021, 0x067744ab, 0xfffeff23, 0x200182fd, 0x501582fc,
    0xff200537, 0x8206bd54, 0x01002110, 0x05838984, 0x07000228, 0xfafffbff, 0x0582f7ff, 0x3184f620, 0x0582fb20, 0x82082b43, 0x8237826d, 0x08a54839,
    0x4f833e82, 0x5f82fe20, 0xfcfff722, 0xfb213582, 0x057d43ff, 0xfb206f85, 0xfe211382, 0x823383ff, 0x201d8204, 0x824d82fc, 0x05002509, 0xf6ff0500,
    0x2408e741, 0xfff5fff6, 0x240f82f4, 0xfff0fff2, 0x500982ef, 0x314f1043, 0x00002108, 0x20096d41, 0x41b58406, 0x01220757, 0x25820400, 0x03840220,
    0x00215d82, 0x41638206, 0x214f05ab, 0x07bf4105, 0x0f000d22, 0x0e200182, 0x0a241d82, 0x02000800, 0x03204f84, 0x03202d84, 0x4d830d82, 0x09000024,
    0x01820a00, 0x03000f22, 0xff210183, 0x865382ac, 0x05734402, 0x2008df4c, 0x20ef84fb, 0x08b95afb, 0xcb48f383, 0x202f8505, 0x08374503, 0x09820520,
    0x84095342, 0x057f411d, 0xfd203b84, 0x8206b542, 0x821a834f, 0x84fa2013, 0x214b8817, 0x8982ffff, 0x07204383, 0x09200786, 0x4f4c4f82, 0x85308305,
    0x82012003, 0xff022c06, 0x0200006b, 0x013301bd, 0x102b010d, 0x2d013309, 0x47ba0221, 0xff290923, 0x00fefffe, 0xfff6ff01, 0x210384f7, 0x1d48fff7,
    0xfff32305, 0x0383fff2, 0xf8fff722, 0xf7201982, 0x2208d742, 0x82fdffff, 0x82fa2031, 0x84f92025, 0xffef2229, 0x890182f0, 0x051f4f05, 0x20074746,
    0x06f742fb, 0xf9201583, 0xfd223384, 0x0182fbff, 0x8200ff21, 0xfcff2100, 0x82055d42, 0x051b450a, 0x02000122, 0xfe206782, 0x93831f82, 0x01000022,
    0xf9209782, 0x46069946, 0xfd2005e3, 0x2008d15e, 0x220984fc, 0x820200fd, 0x00022625, 0x00040007, 0x43058208, 0xff20059f, 0xf6205982, 0xb9853782,
    0x0982f820, 0xfd207383, 0xf5201582, 0x25826b84, 0x26085554, 0xffeefff0, 0x87edffef, 0x43ff2089, 0xff2006ff, 0x2106f145, 0x8d82faff, 0xfe200383,
    0xff216f82, 0x056346ff, 0xebffec22, 0xc7470182, 0x05eb4305, 0xcb84fb20, 0x61843384, 0x03208f83, 0x03209382, 0x82084f4c, 0x1c002316, 0x06833700,
    0x04201782, 0xb1830384, 0xb5820620, 0x85002021, 0x09df4301, 0x26059b43, 0x000f0007, 0x8409000c, 0x000e24e1, 0x820d000e, 0x00242103, 0x12220185,
    0x018c1100, 0x22050741, 0x59080001, 0xff2009ed, 0xa54cb382, 0x82788408, 0x00092204, 0x83238209, 0x82082003, 0x00072209, 0x20018610, 0x82a98201,
    0x0000251e, 0xf8ff12fe, 0x84063d45, 0x20a9820f, 0x24318203, 0x00410041, 0x20038240, 0x20918206, 0x2613820b, 0xff000006, 0x82fbffff, 0x05994103,
    0xbaffb926, 0xd100b9ff, 0x13833982, 0x0782fe20, 0x5155fd20, 0x07154106, 0x5385d385, 0x2205fd41, 0x5afffffd, 0xf8210851, 0x061f42ff, 0x02981a82,
    0xfffeff23, 0x200182f7, 0x202b82f6, 0x4b3982fb, 0x032209fc, 0x6d83feff, 0x82faff21, 0x84fa2019, 0x82fc2097, 0x05d54a0f, 0x20093b49, 0x201f82fa,
    0x82dd82fa, 0x08e34f17, 0x54052958, 0x022009a7, 0x2206b141, 0x8210000f, 0x000e2401, 0x82070009, 0x450a2001, 0x1d82062f, 0x0020b382, 0xfd205b82,
    0xf9204b86, 0xf7238f82, 0x43ff0000, 0xdd45053f, 0xfff42405, 0x85f5fff4, 0x210023fd, 0x01832200, 0x4306e344, 0xfb20053b, 0xfe212f82, 0x209783ff,
    0x205786ff, 0x82078301, 0x4afd2043, 0xdb840529, 0x12000022, 0x0d220186, 0x1f821100, 0x8f820120, 0x05000a24, 0x01820400, 0x03000522, 0x04200182,
    0xd7540382, 0x20f58208, 0x059546fa, 0x06202186, 0x4f826582, 0x04200d86, 0xc94a3984, 0x41072005, 0xa94b0775, 0x833d8209, 0x08b75c02, 0x2008534f,
    0x20198400, 0x22e582fd, 0x82f3fff2, 0x05c943d5, 0x3983f820, 0x200da54c, 0x21008600, 0x0882ffff, 0x75820220, 0x2009a347, 0x24138400, 0xff00003d,
    0x220182fc, 0x82fbfff8, 0x41f9204d, 0x2c82061f, 0x25820287, 0x37820620, 0x0e000d22, 0xcf420582, 0x2c1a8705, 0xff390002, 0x010402ff, 0x00cf0047,
    0xf9eb45f7, 0x43430220, 0x4100200e, 0x00200559, 0x830a3360, 0xfffd250b, 0xfff4fff5, 0xfe200083, 0xfb241982, 0xecffebff, 0xfb220184, 0x0182faff,
    0x6943fb20, 0xfffa2306, 0x4a4100fd, 0x83068205, 0x45ff2002, 0xfe220595, 0x2184fdff, 0xf1fff822, 0xfb230186, 0x83fffcff, 0x82f92003, 0x61098307,
    0xc54206db, 0x436b8409, 0x2d60056d, 0x83ff2005, 0x5803821b, 0x01210577, 0x067b4800, 0xfff7ff23, 0x208182f6, 0x835782f0, 0x82f82003, 0x4521820f,
    0xaf5d089f, 0x42022009, 0x042006df, 0x57083f45, 0xbb420877, 0x205f8209, 0x22e782f9, 0x69f3fff2, 0x01200cbb, 0x71833b82, 0xf74a0520, 0xff032208,
    0x262182fe, 0x000b0005, 0x820a0009, 0x84032003, 0x0003245d, 0x84070008, 0x002a2103, 0x2b230183, 0x43000400, 0xad85051f, 0x24091155, 0x00140014,
    0x21038215, 0x37450008, 0x058d4805, 0x84083f52, 0x82042091, 0xff022353, 0x00830041, 0x4105af4d, 0xee230509, 0x83ffefff, 0xfffa2203, 0x106954f9,
    0x33820020, 0x53820420, 0x77820920, 0x9d820b20, 0x05200383, 0x45830f84, 0x012b0382, 0xfff6ff36, 0xfffbfff7, 0x82fafffc, 0x05734a01, 0x3944fc20,
    0x08af6805, 0xe782fd20, 0x01000022, 0xfb201582, 0xf9202382, 0x02893682, 0x2007ff4a, 0x834182fc, 0x45078537, 0x0b8305b1, 0x2005d549, 0x201d82f8,
    0x08e555fb, 0x13823d8a, 0x1b84ff20, 0xf4fff524, 0x7182f8ff, 0xfc203989, 0xb1451782, 0x82f92005, 0x66fc2017, 0xfe20085d, 0x05833384, 0xb982fe20,
    0x00202f82, 0x4d054144, 0x05820541, 0x05205e84, 0x0383f182, 0xed820720, 0x0a000a22, 0x0f230582, 0x83000e00, 0x00082203, 0x22018407, 0x82040005,
    0x82042023, 0x05474705, 0x0f840720, 0x4d000321, 0x0e2005d1, 0x0120f382, 0x22083d56, 0x840b0009, 0x41042043, 0x022006d7, 0x04202b82, 0x2208894d,
    0x82fefffa, 0x82012073, 0x87029803, 0x053b472b, 0x93832692, 0x3182168c, 0xfafffa24, 0x698281ff, 0x06000522, 0x87457782, 0x22248c06, 0x66f8ff01,
    0x2f4608d9, 0x4cfe2005, 0x2e820e4f, 0x82ffff21, 0x82082004, 0x82042047, 0xff022c03, 0x03010002, 0x0220013e, 0x4461024d, 0xd553f9e7, 0xbfa940a9,
    0xb5450220, 0x49fe2005, 0xfc23063f, 0x69fffcff, 0xf6200593, 0x43058948, 0xfd2008f3, 0xfd201782, 0x2108c548, 0x008300fc, 0x00000124, 0x0182fbff,
    0x3f5bf920, 0x200d8308, 0x201182fe, 0x831e83fa, 0x523f8203, 0x13440771, 0x220d8205, 0x82ff0000, 0x53002000, 0xfe2205f9, 0x5982f8ff, 0xec230383,
    0x83ffebff, 0x05dd5003, 0x7984f520, 0x20058f54, 0x5b5182fa, 0x4344095f, 0x231f8806, 0xfff4fff5, 0x00203382, 0x24058a41, 0x00000002, 0x205b8203,
    0x08bd46fc, 0x6182fc20, 0x43827582, 0x43092d66, 0x3f4706f0, 0x4aff2008, 0xff2005f1, 0xfd20a385, 0x01204b86, 0x2008fd4e, 0x205582fe, 0x85348401,
    0x212f8321, 0x4145fffd, 0x83a58307, 0x82fd2061, 0x05014145, 0x450bad4c, 0x3c840511, 0x84faff21, 0x82f92001, 0x222f870c, 0x82f9fff9, 0x4af92065,
    0x278408b9, 0x59040021, 0x062608ab, 0x05000700, 0x99840500, 0xf7fff522, 0xf9200186, 0x3983d382, 0xfa234f85, 0x5afff3ff, 0xe324052d, 0xe3ffe4ff,
    0xf3200182, 0xf3241182, 0xf5fff2ff, 0x41083f51, 0x0122051d, 0xc983ffff, 0x00020022, 0x200cf347, 0x06474800, 0x6d550783, 0x20218508, 0x20898204,
    0x083d5504, 0x20058b45, 0x08375c03, 0x09000528, 0x06000a00, 0x01860e00, 0x08000822, 0xcd442b82, 0x00042207, 0x20bb8201, 0x54488206, 0x08200513,
    0x2008d953, 0x06494707, 0x2105eb45, 0xef870007, 0x99820320, 0x0d820220, 0x37840620, 0x67820620, 0x04000524, 0x6f84fbff, 0x71484682, 0xfffe2608,
    0x00fefffd, 0x08635901, 0x3f41fa20, 0x069d4a06, 0x4e0a6d54, 0xfe2005cd, 0x430e4b63, 0x0a2009b6, 0x0420bf82, 0x0e22bf88, 0x01840f00, 0xf1840620,
    0x8305fd52, 0x460720d1, 0xa785066b, 0x0220d783, 0xd748a982, 0x20b18208, 0x200f8204, 0x20df8203, 0x87f38206, 0x0527485d, 0x06224b85, 0x59841000,
    0x4b411020, 0x00062208, 0x20018209, 0x823b8204, 0x0c6d51d9, 0xf4fff322, 0x494fdf82, 0x061d4306, 0x2005a347, 0x055352fb, 0x2505a341, 0x0000ffff,
    0xeb82fdff, 0xf8fff726, 0x3d00fdff, 0x3e200184, 0x08205382, 0x7d855984, 0x5f820320, 0x01000223, 0x850d8700, 0x8602200f, 0x8201200f, 0x20e587b1,
    0x05f5530c, 0xfd225b82, 0x2f8afeff, 0xdd840220, 0x820bed48, 0x830288af, 0x820c825b, 0x0da1498b, 0x00202f83, 0x79897782, 0xc14e0e20, 0x820e2006,
    0x5b0b8367, 0x3f820969, 0x20060372, 0x2c478200, 0xfffbff00, 0xfff1fff2, 0x0090fdf2, 0x20018208, 0x218b8209, 0x4f820001, 0x82faff21, 0x05634319,
    0x2108875f, 0x4d820c00, 0xc74a9c20, 0x8c0d820d, 0x08496e02, 0x4384c982, 0xfdfffa22, 0x02205382, 0xfb214d82, 0x06bb43ff, 0x82020021, 0x21358c01,
    0x6f5c0100, 0x081b4305, 0x1e8a0120, 0xe3720120, 0x8b148a08, 0x0945430a, 0x2008554b, 0x421f82ff, 0x37410977, 0x8a138206, 0x08b34402, 0xe8fffb24,
    0x4382e9ff, 0x2405ff44, 0xff0000fe, 0x234785fe, 0x08000400, 0x4a064142, 0x2b430731, 0x4f052005, 0xfe2008f7, 0xaf41b784, 0x85d58c05, 0x44f58293,
    0xfd2005b7, 0x2649ff84, 0x87868608, 0x0bdf42e5, 0x8206db48, 0x74858257, 0xfe200aa3, 0x97829583, 0x95820420, 0x05000222, 0x05200582, 0x00210582,
    0x492f8500, 0x062005a9, 0x0983af82, 0xb5820820, 0x0a000b22, 0x068c6586, 0x49834582, 0x9984fc20, 0xf5fffb22, 0xf6220182, 0x0d82f6ff, 0xfdfffd22,
    0x3f83d584, 0xf94e0920, 0x053b4410, 0x03000822, 0x4110475b, 0x04200565, 0x8508434c, 0x87d9830f, 0x227f85dd, 0x6e060005, 0xb5830869, 0x238d1585,
    0x11821383, 0x82ffff21, 0xfffa228f, 0x206d88fa, 0x6aed8a04, 0x2983055d, 0x2f5f0020, 0x00032208, 0x08cb7403, 0xfe20d983, 0x01211e82, 0x05f34200,
    0x20059b41, 0x21d18203, 0xa74a0005, 0x051f4209, 0x028a2682, 0x77820120, 0xe75fff20, 0x000b2208, 0x835f820a, 0x820420d7, 0x07c54c7d, 0x83000421,
    0x0a956b7f, 0x00220a82, 0x3983feff, 0x88feff21, 0x8400203b, 0x851a8309, 0x21e58903, 0xeb410002, 0x42198407, 0x75420810, 0x60ff2006, 0xa97708a7,
    0x202b840c, 0x25798400, 0xfafffbff, 0x0182f7ff, 0xfcfffa24, 0x0384fdff, 0x8505b741, 0x72012023, 0xd1720bc9, 0x05936208, 0x1b82fd20, 0x49474382,
    0x83f72006, 0x8303860d, 0x700a8693, 0x3343089d, 0x0829590e, 0x07892787, 0x08000426, 0x04000700, 0x20086f41, 0x20d58401, 0x062546fe, 0xa582f920,
    0x83847f83, 0x7f830020, 0xfeffff22, 0x880c7951, 0x88fd8749, 0x82089210, 0x84ff203b, 0x05d3478b, 0xfb214b83, 0x830082ff, 0xbcff212a, 0x03820583,
    0x03000a23, 0x0aed4100, 0xa14f1b84, 0x208d8305, 0x2e0f82fc, 0x00f3fe03, 0x01720303, 0x01a1014c, 0x10c501b5, 0xc701fd0b, 0x00710322, 0x22058d43,
    0x46fbfffd, 0xf221067d, 0x051566ff, 0x85ffef21, 0x07474f01, 0x9146fb20, 0xfdff210b, 0x21059f51, 0x0182feff, 0xf565f820, 0x05d75408, 0x2982fc20,
    0x83fffe21, 0x82fd200b, 0x57f02009, 0xf3730681, 0x82ff2005, 0x057b506f, 0x00200f84, 0xff200082, 0x07841382, 0x2d82fa20, 0x50ffff21, 0xee200593,
    0xef203584, 0x0f460582, 0xfffc2205, 0x209f82fe, 0x05fb6afa, 0xff223183, 0x8b4bfff6, 0x4a898205, 0xd5420547, 0x081f6a05, 0x02000123, 0x21038300,
    0xe3480006, 0x00042105, 0x06200183, 0xf0205784, 0xff20e382, 0x52083775, 0x4b86091b, 0x2108494c, 0xfd85fff8, 0x820c7b60, 0x05f1501d, 0xf7fffb22,
    0xf820f984, 0x43084563, 0xfe2005a9, 0xe1442182, 0x55098206, 0x655009e7, 0x83c1840a, 0x05554145, 0x22054141, 0x64fcfff8, 0x155e08cb, 0x82022005,
    0xff03210f, 0x2209d75a, 0x84faffff, 0x20bf830d, 0x22c984f1, 0x82efffee, 0xffe52a01, 0xffe9ffea, 0xfff5ffec, 0x200382f6, 0x08f567f7, 0x0986f920,
    0x4500ff21, 0x25410881, 0x0a237606, 0x00241a82, 0x0a001100, 0x2306e351, 0x002a002b, 0x6d520383, 0x86052005, 0x00022491, 0x82010005, 0x0005220b,
    0x20018608, 0x08054c04, 0x24093748, 0x000d0001, 0x0c416204, 0xc3454583, 0x45022005, 0x002206a1, 0x01820e00, 0x47000321, 0x07200521, 0x255c5782,
    0x00152105, 0x20056767, 0x23418203, 0xff040004, 0x82072d41, 0x0500210b, 0x06241382, 0xfefffeff, 0x22083545, 0x82100002, 0x820f2001, 0x002d2403,
    0x822d002c, 0x820c2001, 0x840383bf, 0x83ef88ce, 0x487f859b, 0x03200701, 0x83083349, 0x48038a24, 0x062308c5, 0x4a000600, 0x0722077b, 0x01821f00,
    0x03822020, 0x0a000924, 0x01820900, 0xbd820620, 0x87820f20, 0x3a830620, 0x00ffff24, 0xf746fd00, 0x84042005, 0x820f20a5, 0x6e02201d, 0xff23053b,
    0x59f7fff5, 0xff2808e7, 0x9ffefeff, 0x19001800, 0xff210183, 0x200184e5, 0x576582e4, 0x022005db, 0x02220982, 0xdf82f400, 0x03905483, 0x20082143,
    0x861a90ff, 0x82ff2010, 0xfdff285f, 0xfbfffaff, 0x6800fbff, 0x0050097d, 0x082f4710, 0x6546fe20, 0x08df6706, 0xfd200882, 0x8e08b969, 0x82358267,
    0xfdff21a7, 0x490a9157, 0x022205f1, 0x01820d00, 0x4b820520, 0x82fffe21, 0x09594101, 0xff204984, 0x074e8f82, 0xfff92205, 0x240184f8, 0xffedffec,
    0x200182ec, 0x06a742f6, 0x1584fa20, 0x7b82f820, 0x00224f85, 0x3d420100, 0x00032406, 0x84070006, 0x82082003, 0x00082407, 0x821b0008, 0x001c2201,
    0x482b851b, 0x277608bd, 0x83f7860a, 0x85012041, 0x828f8325, 0x05474b29, 0x83fffc21, 0x47fb2007, 0x7f5b0865, 0x4dfd2007, 0x798605ad, 0x20054f4c,
    0x06674204, 0x53820420, 0x194d1020, 0x228f8306, 0x49050008, 0xa54e0863, 0x0af34c0c, 0xf1ffff26, 0xf0fff2ff, 0x0f4fd982, 0xfffe2205, 0x216183fc,
    0x5554fdff, 0x4cd18308, 0xd98307d7, 0x0b220b85, 0x83821000, 0x0d000123, 0x2200a300, 0x65050006, 0x02200ab1, 0x0120a782, 0x04219982, 0x20018300,
    0x05654d05, 0x82ffff21, 0x05e741ff, 0xa548fc20, 0x84002006, 0x82fc2013, 0x20038591, 0x0a0b7bff, 0x49075d59, 0x8789097b, 0xeb430320, 0x84118806,
    0x0ddf77d1, 0x088a1b88, 0x03859783, 0x2205e14d, 0x82050002, 0x87002001, 0x05c54c8d, 0x2107b742, 0x174afbff, 0x82a78508, 0x20a9845f, 0x052d5bff,
    0x3988cd83, 0x01206483, 0x57820d82, 0x82faff21, 0x84f52019, 0xfff1233b, 0xb360ffc4, 0x82ff2008, 0x06002300, 0x01840800, 0x03862f83, 0xfff7ff28,
    0x00dafff6, 0xf76b0015, 0x20158705, 0x061f42fb, 0xf1fff232, 0x0200f2ff, 0x05001a00, 0x4d012802, 0xdb00c300, 0x21dded48, 0x85431702, 0xfff82206,
    0x200182f0, 0x200382f1, 0x831182f7, 0x05ef4c03, 0x41052759, 0x00260904, 0xfdff0000, 0x1682fcff, 0xeffff122, 0xdd433384, 0x82f82005, 0xfffc2213,
    0x200584fb, 0x202184fd, 0x200d82f9, 0x220982fb, 0x4ffafff8, 0x7d52081f, 0x50258305, 0xfd200521, 0xfe201982, 0x03832382, 0xe7ffe822, 0xe5410183,
    0x86012006, 0x822b8297, 0x22028372, 0x83030003, 0x6d038406, 0x042107bd, 0x09016700, 0x07201f83, 0xff209782, 0x830a3748, 0x0ecf44a7, 0x00243f84,
    0xfffffeff, 0x02206982, 0x20067362, 0x087b4406, 0x83058d45, 0x20138505, 0x22198600, 0x82220001, 0x82212001, 0x002e2403, 0x822e002f, 0x6c0f2001,
    0x795206c7, 0x72012007, 0x02210859, 0x20018300, 0x200f8403, 0x087f7c02, 0x87074743, 0x081d75c5, 0xfe248b82, 0xf9fff9fe, 0x8305c948, 0x5e9b829f,
    0x062009ff, 0x33874182, 0x25820020, 0xf1fff026, 0xe600f0ff, 0x7208cd45, 0x3986080b, 0x10820020, 0x45ffff21, 0xf823075d, 0x4cfffdff, 0xff2005fb,
    0xfb210782, 0x82f98200, 0x82ff2003, 0xff01212b, 0x8309f74f, 0x820120e5, 0x840220af, 0xfff8223b, 0x243f82f8, 0xfff3fff4, 0x410182f2, 0xf72005df,
    0xf6241382, 0xf7fff6ff, 0x51821982, 0x028f3f82, 0x0020df87, 0x0126fd82, 0x06000800, 0xb9820700, 0x0b000424, 0x2a850900, 0x00ffff25, 0x840e000d,
    0x05954903, 0x20055545, 0x24278208, 0x0012000f, 0x20338213, 0x413b8203, 0xd741053d, 0x0d6f4805, 0x4f820420, 0x20055941, 0x0a8b6403, 0x05000024,
    0x0f850400, 0xff83d184, 0xfbfffe22, 0x17820b85, 0x012002a5, 0x9b447982, 0x05434109, 0x438dff20, 0x6a06db42, 0xf72a07d7, 0xf1fff0ff, 0x0000f6ff,
    0x0182fdff, 0x1d82f920, 0xf4fff322, 0x02206c8c, 0x0620af82, 0xf3839b82, 0x08381887, 0x02009bfe, 0x4a01bc03, 0x73010700, 0x93018901, 0xcb01b501,
    0x1102d901, 0x48dd6744, 0x0020108c, 0x01110010, 0xeefe2123, 0x26085b48, 0x00000002, 0x82dc0301, 0x21078205, 0x07830400, 0xffe6ff23, 0x2a0784cd,
    0xffebfff5, 0xfffcfffe, 0x82dbffed, 0x84072019, 0x84ff2013, 0x84f82011, 0x7cfd200b, 0xe96b0ee3, 0x00002206, 0x06674bff, 0x82083f58, 0x203d880f,
    0x840986fb, 0x2004821c, 0x240382fd, 0xffbffffe, 0x0823587f, 0xfafffc22, 0xfd224184, 0x7f43f9ff, 0x844b8909, 0x08f74c09, 0x8205a164, 0x00002127,
    0x22066b43, 0x84fffeff, 0x45138263, 0x04210575, 0x05314400, 0x01000122, 0xcb20db82, 0x83843f83, 0xdd82bf82, 0x896af820, 0x82eb8308, 0xefff233b,
    0x8182e0ff, 0x4f60f520, 0x097d7808, 0x0200f822, 0x2008bf52, 0x206782fe, 0x213b88fe, 0x337afff9, 0x83838305, 0x28188267, 0xcfffe7ff, 0x2c001600,
    0x05c14500, 0xeb860120, 0x3782fc20, 0xfbfffb22, 0x26063d6b, 0x00fdfffe, 0x82ffff00, 0x84f72087, 0xffee2293, 0x201b82dd, 0x208382f8, 0x220f84df,
    0x84e3fff2, 0xfff62207, 0x220784ec, 0x84f6fffb, 0x84a38207, 0xffeb2207, 0x410784d6, 0xfe22050f, 0xef4b0000, 0x00012408, 0x41250012, 0x00230713,
    0x4c5f0030, 0x27220819, 0x33834d00, 0x45040021, 0x4b460641, 0x88012005, 0x8405200f, 0x00012417, 0x8417000c, 0x18012033, 0x24084948, 0x003b0002,
    0x064d4b74, 0x49540620, 0xff022106, 0x2405ef45, 0x00000002, 0x21298201, 0x00830008, 0x07830983, 0xad460020, 0x00412206, 0x4a098281, 0x012005df,
    0x17856982, 0x20051941, 0x220f8603, 0x8415000b, 0x05b54123, 0x15820120, 0x79840320, 0x00202b85, 0x13200084, 0x0320d382, 0x2b831982, 0x1a221083,
    0x06833300, 0x004f0023, 0x823b849c, 0x83ff200c, 0xffc42100, 0x0e200183, 0x27070f41, 0xf8fffcff, 0xf4fff9ff, 0x0c22cf84, 0x2b881800, 0x0553fe20,
    0x24328205, 0x000b00e1, 0x24178216, 0xfff4ff01, 0x824682e9, 0xf7fe2502, 0x9effcfff, 0x200ab741, 0x225b84fd, 0x82fafffd, 0x000224fb, 0x84700037,
    0x1802204f, 0x8208b940, 0xfeff2133, 0x2b822f86, 0x00260e82, 0xf3ffddfd, 0x1f47e6ff, 0x0527410a, 0x1b000d23, 0x42d78300, 0x1f82062b, 0x0382ff20,
    0x1000d524, 0x17822100, 0x43820020, 0x2205694b, 0x83e2fff1, 0x202a820f, 0x21bf82de, 0x4518fff3, 0xab6e0999, 0x8403200b, 0xfffe2297, 0x4dcd82fb,
    0xd5750733, 0x00002205, 0x20138202, 0x0b6168fa, 0x0320ad82, 0x05240382, 0x20000f00, 0x8308ab41, 0x0549632d, 0x4b84fa20, 0x0b00ff22, 0x78821b84,
    0x00259b85, 0x000300c7, 0x842f8807, 0x43458217, 0xfe2005eb, 0x20082d5c, 0x21a582fd, 0x0f85ffff, 0x1782ab82, 0x06000024, 0x07840a00, 0x47059a45,
    0xfe220547, 0x657afaff, 0x8201200c, 0x00032221, 0x08974105, 0xf8fffc22, 0x200a3341, 0x49c38200, 0x438a0573, 0x00040023, 0x20438409, 0x059547fd,
    0x7784ff20, 0x82ffff21, 0x85028849, 0xfeff21cb, 0xf1230784, 0x8300e2ff, 0x82ff207d, 0x82ff204d, 0xfffa2300, 0x4f4dfff5, 0xfff82405, 0x82e4fff3,
    0x82f220b9, 0x82fe2015, 0x88f12007, 0x000a2aaf, 0x00100012, 0x000a001f, 0x849d8215, 0x411b826f, 0xc747052d, 0x2461840c, 0xfff8fffe, 0x85ab85f2,
    0x43058569, 0xf12206e3, 0x8982e3ff, 0x5952fe20, 0x82fe2008, 0x00062717, 0x0027000b, 0xed42004d, 0x00062405, 0x42070003, 0xcf430b4d, 0x00092208,
    0x20778214, 0x201b8200, 0x82078303, 0x06a74163, 0xf7225b86, 0x1784eeff, 0xf9fffc22, 0x47830783, 0xfff6ff27, 0x000900eb, 0x20078211, 0x202f82ed,
    0x0acb52f9, 0x22054541, 0x845d002e, 0x8400202b, 0x86fb2095, 0x08c9641f, 0x9b826b87, 0xff207385, 0x22069d58, 0x86040002, 0x00ff2437, 0x4e250013,
    0x9d830833, 0x00000026, 0xf4fff9ff, 0x3d500582, 0x07894b05, 0x5343f520, 0x00052306, 0x1982ff0b, 0x02205b82, 0x180a6b49, 0x8209734d, 0x071f4163,
    0xad411f82, 0xfffb2205, 0x270b83f8, 0x0d000700, 0x1e001000, 0x02210b82, 0x203d8400, 0x83ab84ff, 0x081d534f, 0xd8ffed22, 0x09583786, 0x83012007,
    0x0500230f, 0x4f880900, 0xdfffef22, 0x1183eb85, 0x824a0021, 0x8404204b, 0x00002603, 0xfff6ff01, 0x087341ec, 0x15820120, 0x08000523, 0x83008300,
    0xff012245, 0x200a83df, 0x052f4500, 0xa7850020, 0x84340021, 0x84048413, 0x05234485, 0xf2fff922, 0x200a6f72, 0xd7441800, 0x0004220c, 0x41018403,
    0x39820585, 0x829eff21, 0x83028404, 0x0ec74233, 0xc7460220, 0x82088208, 0x82382002, 0x05694503, 0x02000022, 0xfe203788, 0xa2203984, 0x85820f83,
    0xc560fd20, 0x420b850a, 0xe78406f3, 0x7d820320, 0xef5c0420, 0x8403200c, 0xfffd263d, 0xfffcfffb, 0x433b88f9, 0x022207bf, 0x31860400, 0x09820520,
    0x05200b83, 0x8383cf82, 0xff2b8182, 0x03030029, 0x0222011b, 0x10130203, 0x13026b0a, 0x01000123, 0x08a96277, 0x83000121, 0x55012000, 0x042008ff,
    0x21088942, 0x0b830003, 0x05820220, 0x2d820520, 0x33490220, 0x08b14509, 0xfbfffd26, 0x0d000c00, 0x0c220182, 0x01820900, 0x03820820, 0x05000324,
    0x4d840600, 0x04205783, 0x2008236c, 0x20158206, 0x431b8206, 0x03200567, 0xa1600d82, 0x8385870b, 0x82052033, 0x7b6d8325, 0x01201541, 0x03208f86,
    0x03246384, 0x1b001a00, 0x0b200384, 0x0c228982, 0x6f840b00, 0x04201b83, 0x85080f43, 0x4400205b, 0xfd240609, 0xe8fffdff, 0xef240186, 0xeffff0ff,
    0x13830182, 0x4018fc20, 0x177808f5, 0x00062109, 0x20093552, 0x8b4b18fc, 0x4ffc2008, 0xf320062d, 0x25081561, 0xfffcfffe, 0x618500fc, 0x4782fe20,
    0x83058154, 0x200d8355, 0x464484fd, 0x8d47089f, 0xfeff2105, 0x2208b56e, 0x82fbfffe, 0x82fc2001, 0xffee2303, 0x0382ffed, 0x0120e182, 0x3884bd84,
    0x22064d46, 0x82f2fff4, 0x62f32077, 0x6384086d, 0x048a2084, 0x12845387, 0xf3544382, 0x86108408, 0x82f920a1, 0xfffc2281, 0x204982f6, 0x84c182f8,
    0xfeff21a1, 0x820a6955, 0x202e8444, 0x84838302, 0x82fc2051, 0x51fa2047, 0x0d6006db, 0x83058305, 0x00fc2381, 0xc3580007, 0x74012009, 0x40820821,
    0xff223982, 0x5984fcff, 0x0582fd20, 0x85ffe721, 0x82f42001, 0xfff422c5, 0x088b52f4, 0xf5fff824, 0xed84f6ff, 0x20090f42, 0x080f5d02, 0xfbffff22,
    0xfa240184, 0xeeffefff, 0xf9200184, 0xc1853982, 0x5d82fc20, 0xf9fffd22, 0x20098d56, 0x22008f00, 0x82050001, 0x84042059, 0x072f4205, 0x20055b63,
    0xc54b180f, 0x00062108, 0x07201f83, 0x2408517e, 0x00190019, 0x22018218, 0x8c0a0009, 0x63062001, 0x0020067d, 0x4b832f82, 0x08000622, 0xfd831182,
    0x06000522, 0x04200182, 0x1585c386, 0x8305d36b, 0x82cb8405, 0x6003201b, 0x04200809, 0x04204182, 0x21080165, 0x0082ff01, 0x84020021, 0x21478343,
    0x0185000c, 0x20055541, 0x08ad6407, 0x3f820120, 0x47460420, 0x05b15a0a, 0x5afff921, 0xff200bb3, 0x4d821f82, 0x200a3946, 0x201184fd, 0x205f82fe,
    0x217f8400, 0x1f590000, 0x84032005, 0xff052483, 0x58fbff67, 0x0120064b, 0x0520cd84, 0xff4ad582, 0xfffc2105, 0x01220182, 0xbb49ff16, 0x0f855e08,
    0xff215985, 0x49c982fe, 0x7d8505c1, 0x5184fe20, 0x20075143, 0x6c4582fc, 0x34831373, 0x23476783, 0x056f4d05, 0x88052f4d, 0x820020c3, 0x24038455,
    0x00030003, 0x083f5a05, 0x21054741, 0xe34c0003, 0x21478205, 0x0182f5ff, 0x6782fe20, 0x0382fd20, 0x48069173, 0xbf89094b, 0x82010021, 0x8302872c,
    0x09c3677b, 0x8505d342, 0x05094385, 0x09435618, 0x078a3187, 0x820a1178, 0x240d8253, 0xfff8fffd, 0x05214ff9, 0x02216584, 0x82008600, 0x0a935b1b,
    0xf7431485, 0x44fe200a, 0x032006c3, 0x01223582, 0xaf570100, 0x83fb2008, 0x08134309, 0x05833685, 0xcd8a0120, 0xff210f82, 0x260182f0, 0xffeffff1,
    0x49e8fffe, 0x002206cb, 0x65660200, 0x8400200e, 0x0006245b, 0x821d001c, 0x821c2001, 0x00052271, 0x20138205, 0x08994302, 0x3483fd83, 0xfe210783,
    0x054541ff, 0x8182fe20, 0xfdfffd22, 0x3f856482, 0xdf820420, 0x0384f920, 0x0b655018, 0x3682fd20, 0x85052f41, 0x820f8235, 0x05135531, 0x09d34318,
    0x03000222, 0x0a24b782, 0x0b000a00, 0x04210382, 0x05eb4800, 0x07840120, 0x71078759, 0x02250569, 0x01000000, 0x823f8300, 0x09574208, 0x22086f46,
    0x42f5fffc, 0xfd2008ef, 0x82060b43, 0x83298382, 0x85318d23, 0x2005860d, 0x216d8202, 0x018b0007, 0x2205b974, 0x82060010, 0x418b836f, 0x154c0e37,
    0x84ff200c, 0xfffa2275, 0x064b56fb, 0x01205483, 0x06204d82, 0x0422cf84, 0xb5840400, 0x16820120, 0x75460220, 0x82002008, 0x000a241b, 0x51050002,
    0xeb420825, 0x6ffe2005, 0x3a821483, 0x0221a182, 0x82009800, 0x37421845, 0x07ed630b, 0x2005575c, 0x42758200, 0x052005dd, 0xdf410982, 0x207b8206,
    0x420d8202, 0x5218055b, 0x002009ed, 0x00201382, 0x200b6341, 0x444b8500, 0x9b410511, 0x00042105, 0x20057d4a, 0x076559fe, 0x835fff21, 0x20838298,
    0x20bd82f8, 0x820b83ff, 0x00062403, 0x82050006, 0x2cbb8507, 0x02020036, 0x014a0104, 0x01490135, 0x750a105d, 0xff246001, 0xf8fffeff, 0xfc200182,
    0x20067544, 0x26008200, 0xff010001, 0x86f2fffb, 0x85fb2001, 0x00002511, 0xfefffdff, 0x21820b87, 0x2205c543, 0x82fffff9, 0x82fb202b, 0x05fb4445,
    0x7b44fa20, 0x4ffd2006, 0xf620067f, 0x028e3182, 0x49854782, 0x0e88178e, 0x20050b45, 0x584986fb, 0xf6200541, 0x99427b82, 0x84268805, 0x84f92047,
    0x82fb207d, 0x60fc2005, 0x012208bb, 0xa7860200, 0x2505b742, 0x00030004, 0x3d830004, 0x33820120, 0x2005a748, 0x205d82fc, 0x20a382f4, 0x201184fa,
    0x080f47fe, 0xc984ff20, 0xd582fb20, 0xf9fffa26, 0xfafffaff, 0xdd7bf782, 0x8e002006, 0xfbff2100, 0xff201f82, 0xfd200582, 0x235d4382, 0x205f8509,
    0x83af82ff, 0x188b832f, 0x840bc14b, 0x22188285, 0x82060006, 0x001f2205, 0x20018220, 0x08294b1f, 0x1b4b0020, 0x18fe200c, 0x2008b554, 0x08216df9,
    0xfb207383, 0x6f839d82, 0x430b5147, 0x0420076f, 0x7361e982, 0x000f2309, 0x0383000e, 0x10001124, 0x01821100, 0x44078948, 0x8d83071f, 0x05000023,
    0x05555900, 0x87820620, 0x1f83af85, 0x24053354, 0x0009000a, 0x6753180a, 0x052b4708, 0x82000121, 0xffff2137, 0x0b22b584, 0x3f820b00, 0x20053b52,
    0x82008300, 0x69072017, 0x0520083d, 0x03203984, 0x00351783, 0x005cff00, 0x00080007, 0xfffdff07, 0xfff4fffe, 0xfff7fff5, 0x240182fb, 0xfffcfffa,
    0x20d182fa, 0x208582ff, 0x226d8209, 0x85fbfe09, 0x2405862f, 0x00010001, 0x826b8202, 0x08cb5f03, 0xff224183, 0x7f72fb00, 0x6a438209, 0xab410501,
    0x08576f0e, 0x27673a82, 0x82fd2008, 0x22f98559, 0x82f6ff00, 0x82fe2001, 0x06bb463d, 0x02851982, 0x01000125, 0x4aff0600, 0xed200529, 0xfc204588,
    0x01201582, 0x2008714b, 0x82bd84ff, 0x06476371, 0x5b45f620, 0x844a850f, 0x000c2205, 0x22c5820b, 0x820a000b, 0x000b2207, 0x84478207, 0x48048816,
    0x0122058d, 0x01820400, 0x00237982, 0x82060005, 0x07634a01, 0xff840420, 0x15820420, 0x23821783, 0xff206982, 0xff213b83, 0x200184fe, 0x233582fc,
    0x00020003, 0x830ed747, 0x00002321, 0xdf82ffff, 0x0386fb20, 0xb382fc20, 0x4946fc20, 0x201d8405, 0x87058201, 0x85f38337, 0x18032087, 0x2208c355,
    0x86100005, 0x00092101, 0x05200185, 0x04221b82, 0x77820600, 0x0382fd20, 0x820a335b, 0x0565410d, 0xfe200583, 0x5207f145, 0x00210c09, 0x06774100,
    0x00220788, 0x575cfbff, 0x49a98208, 0x148208ab, 0xff820298, 0x84020021, 0x086752a1, 0x79437b84, 0x053b4805, 0x00940020, 0x20094b42, 0x05bf4801,
    0xfffdff25, 0x82fbfffa, 0xfff82403, 0x76f7fffc, 0xff210dd3, 0x838d82ff, 0x82fb201b, 0x82af201b, 0x0003244f, 0x820b0003, 0x06034d01, 0xff210683,
    0x820182fe, 0x20218237, 0x210f83fd, 0x61517900, 0x82fa2008, 0x4b038255, 0xfb8908fb, 0x05322883, 0x01009dff, 0x35019a02, 0x4f002700, 0x97007700,
    0x0610cf01, 0x206001eb, 0x703f5c00, 0x85009821, 0x64012000, 0x09830805, 0x14850320, 0x00ffff33, 0x00070002, 0x00060005, 0x000a0009, 0xff030004,
    0x854518fb, 0xfffd2208, 0x210182fe, 0x2b4bfffb, 0x01002908, 0x8bff0000, 0xf7fff8ff, 0xf8200182, 0xfc202982, 0x4408a56b, 0xfd200503, 0xff203b82,
    0x82067d42, 0x83ec8407, 0x82032068, 0x82062065, 0x0008225f, 0x24058208, 0x0011000b, 0x82168310, 0x00fd225d, 0x083d47d9, 0xf5fff622, 0xf6200182,
    0x2006094c, 0x842183f0, 0x203d8303, 0x4ebd8203, 0x0c22054b, 0x01860d00, 0xb7820420, 0x83000421, 0x22268301, 0x82020002, 0x00fc2249, 0x820c830f,
    0x05b94b03, 0x18ff0221, 0x43093d46, 0x058305f7, 0x22825183, 0xaf4c0288, 0x21c58207, 0x45827e00, 0x83053743, 0x820383e7, 0x20a98215, 0x0d755cfe,
    0xa7443b82, 0x06894605, 0x85050d45, 0x44db8405, 0x635f0587, 0xfff72205, 0x057555f6, 0xff000023, 0x230982fe, 0xfff4fff4, 0x4406f34b, 0x1782096d,
    0xfafff924, 0x2b82f5ff, 0xf3fff322, 0xfa202182, 0x55061941, 0x1b4f0561, 0x205b8306, 0x0ff57000, 0x3d820f82, 0x3982fe20, 0xf9fff622, 0x2008a750,
    0x200982ff, 0x266782fd, 0xffe9ffed, 0x82e7ffea, 0x05d36619, 0xf1fff122, 0xfc205982, 0x05455d85, 0x4d898209, 0xfc20052f, 0xf6213782, 0x84b383ff,
    0x7bfb85b5, 0x0b820509, 0xfdfffc22, 0x24082141, 0xffdbfffa, 0x200384da, 0x09cf46f3, 0x0587d185, 0x00231782, 0x18000200, 0x22093d48, 0x822a0006,
    0x82292001, 0x05955003, 0x0c000924, 0x01840b00, 0x24002424, 0x03822500, 0xcb820220, 0x0100ff24, 0x35820400, 0x48180320, 0x0520083b, 0x4c830f82,
    0x01000224, 0x6b4e0700, 0x8313830a, 0x85012003, 0x833b8471, 0xff00220f, 0x212582ff, 0x01850006, 0x16001524, 0x01821500, 0x2005b769, 0x83198205,
    0x0002215d, 0x2f826385, 0x200ea575, 0x20618400, 0x05a14504, 0x0b82db8b, 0x01000022, 0x03831782, 0x3f820420, 0x29860120, 0x0b820320, 0x0520e585,
    0x048b2384, 0xf34f0120, 0x057d4708, 0x06000a22, 0x20087741, 0x20b7825b, 0x4f4718fd, 0x2137880a, 0x4377feff, 0xfffb2208, 0x08d97cfc, 0xb5833b83,
    0x6f820620, 0x0b355518, 0xfbfffa28, 0xf9fff9ff, 0x40881c00, 0xe182088e, 0x694afc20, 0x205d830a, 0x243382fb, 0xfff8fffd, 0x820182fa, 0x0885693d,
    0x0a000924, 0xa3820d00, 0x09000824, 0x468e6100, 0x02200e83, 0x0120bd82, 0x37829f82, 0x03a00e83, 0x21820120, 0x2551b383, 0x052d5b05, 0x83052151,
    0x82038785, 0x208f82e5, 0x08b54afc, 0xb17c0420, 0x820a2008, 0x8203208f, 0x22028243, 0x5cffadff, 0x0b820599, 0x01230290, 0x82000200, 0x85ff2000,
    0x05314361, 0xf382fb20, 0x83fffb21, 0x4af820f9, 0xb54406cb, 0xfffd2105, 0x210dcd6d, 0x03530008, 0x82082005, 0x84002075, 0x82002063, 0xfffb228d,
    0x089f44ff, 0xf2fff326, 0xf8fff3ff, 0xfb200182, 0x5d183b8e, 0x05200b0d, 0x20082556, 0x06f54105, 0x11840220, 0x06000323, 0x52278500, 0x67180561,
    0xf220091f, 0x494b5784, 0x01002108, 0x00200184, 0x20062142, 0x833d8203, 0x83158553, 0x420383e1, 0x0420056d, 0x0120298c, 0xdb84ab82, 0x00930020,
    0x11001225, 0x49000900, 0x102007cd, 0x11220d82, 0x3f841000, 0x05820520, 0x92000221, 0x214f8200, 0x4a1800ff, 0x208a087b, 0x09000922, 0x9b781782,
    0x83a38309, 0x86062027, 0x410420f1, 0xfa200687, 0x4606954c, 0xb7790549, 0x18fe200b, 0x8a11ad42, 0x200a835f, 0x20798403, 0x20a18402, 0x05156106,
    0x6783a784, 0x20075141, 0x82118200, 0x086b5203, 0xfd20fd83, 0x6d5c7384, 0x20488306, 0x05dd5d00, 0x2205db44, 0x82fafffb, 0xfff92201, 0x200184f6,
    0x076343f7, 0x05892785, 0xfffbff23, 0x22fd82f2, 0x82f5fffe, 0x00022c13, 0x01020046, 0x004a01f9, 0x100b01cb, 0x0e012109, 0x8c00f921, 0x08876700,
    0x83fff821, 0x051f5701, 0x7341f320, 0xfffa2406, 0x82fcfff9, 0x0dbf6701, 0x01000024, 0x21840100, 0xf1fffc24, 0x0384f0ff, 0xf4fff424, 0x0382f5ff,
    0x4e08cb58, 0xfc2008e7, 0x20082144, 0x47788201, 0x052809d1, 0x02000500, 0xf6ff0900, 0x5b4c7782, 0xffed2105, 0x4805b96d, 0xfb200755, 0xfb203982,
    0x47089546, 0x414805bb, 0x44062005, 0xb9750867, 0xfeff2108, 0xf8200182, 0xf722af82, 0x9b82f7ff, 0x6b84f820, 0x0021a782, 0x21678206, 0xe94e0004,
    0x20778309, 0x83798203, 0x09f14f89, 0xa7790320, 0x09d35208, 0x22058746, 0x86180006, 0x83498301, 0x09ed4613, 0x87820420, 0x0a000423, 0x05234600,
    0x2007ef43, 0x22008600, 0x84010002, 0x00152467, 0x82140015, 0x4b0a2003, 0x062006d5, 0x05203584, 0x28830582, 0x00246f83, 0x72ff0100, 0x2305874d,
    0xfffffcff, 0xfb200382, 0xd1470582, 0x82fb2007, 0x82fe20d9, 0x8401202a, 0x07654337, 0x01000323, 0x82cb8200, 0x82fb20eb, 0x84fc202f, 0x5ffa2033,
    0x3b8205eb, 0xf9220283, 0x1d84fbff, 0x22094341, 0x82130014, 0x000823ab, 0x03830009, 0x3f820320, 0x83000421, 0x205c8305, 0x083b6b18, 0xf7fff822,
    0xf7213982, 0x0b8b76ff, 0xff212182, 0x820482ff, 0x08c95fa9, 0x8746fc20, 0x82fa2006, 0x487f8339, 0xff200567, 0xff212783, 0x210682fd, 0xed4100fe,
    0x833a8409, 0xefff2104, 0xfd200182, 0x82084179, 0x513d82b1, 0x7744098f, 0x83f38707, 0x84042032, 0x690420f7, 0x012008b1, 0x01225782, 0xb9820600,
    0x0a000222, 0x0c22cb82, 0x5f4a0c00, 0x410c2006, 0x0a20068b, 0x8908bd47, 0x84022009, 0x840720e9, 0x20ff8329, 0x83398208, 0x82042043, 0x0695472b,
    0x09826182, 0xb7852782, 0x0984f389, 0xf547d183, 0x861c8213, 0x06a74102, 0x06920d86, 0x02000223, 0x88008d00, 0x18168769, 0x220a6d5b, 0x82fafff9,
    0x829a2001, 0x820720e9, 0x82062003, 0x000422f5, 0x20818a04, 0x22918201, 0x46f8ffff, 0x8b5006ed, 0x20138406, 0x208983ff, 0x07df57ff, 0x3d820220,
    0xe5820520, 0x08000222, 0xcb840182, 0xff000023, 0x213782fa, 0x0183fff9, 0x43fff121, 0x457907df, 0x24248208, 0x00030001, 0x2b358304, 0x0100f7fe,
    0xe2002803, 0x9d018901, 0x014b0510, 0x4e00200e, 0x719e701b, 0x00250322, 0x9a830087, 0x0b420b84, 0x06694206, 0x82eaff21, 0x82e92001, 0xfffa2103,
    0x62051d44, 0xff200919, 0x20053142, 0x06e743ff, 0x43f9ff21, 0x298306d7, 0x2d82fb20, 0x0382fc20, 0xebfffb22, 0xea200182, 0xda240382, 0xdbffdcff,
    0xf7210182, 0x05a744ff, 0x2f82fa20, 0x2584f920, 0x2705a35d, 0xfffdfffe, 0xfffefffc, 0x83054f65, 0x05c14705, 0x2005a94d, 0x056f5afa, 0x4a000021,
    0xfa2008df, 0xfa243b84, 0xf0fff5ff, 0xf8200182, 0x99833b82, 0x5c18f820, 0x858708a7, 0x0b7d6218, 0x083d5518, 0xfe20a982, 0x215e3186, 0x43fb200d,
    0xff21052f, 0x836782ff, 0x82f920c3, 0x0593738f, 0x8905b144, 0x0579442d, 0x4109315e, 0x0583051f, 0x2d89c783, 0x20055b4f, 0x09b348f8, 0xed857784,
    0xf8202983, 0x4e05d551, 0xe382097b, 0x870c855b, 0x01002919, 0x01000000, 0x06000400, 0x08210182, 0x05914900, 0x1807254a, 0x8309f549, 0x05ab4623,
    0x2005f945, 0x06475a08, 0x44055753, 0x082405c9, 0x12000800, 0x11200184, 0x4f834782, 0x59840220, 0x04204583, 0x03851182, 0x6b820420, 0x85000321,
    0x5e092031, 0x1b830871, 0x19820320, 0x44000621, 0x05220565, 0x8f820500, 0xa14d7585, 0x45052005, 0x0420086f, 0x0022b182, 0x01820200, 0x03000322,
    0x0023c783, 0x820f0010, 0x820a2049, 0x00092455, 0x82feff0a, 0x0002220b, 0x82198201, 0x202b821f, 0x224b8204, 0x82040004, 0x20a1839d, 0x06c94408,
    0x69180420, 0x214708ef, 0x824f8605, 0x8205203b, 0x8503832b, 0x000822a3, 0x205f8211, 0x21058211, 0x01840044, 0x56827184, 0x55832582, 0x0a820420,
    0x06203b83, 0x06220f82, 0xb7450500, 0x50022008, 0x07280865, 0xfdfffeff, 0xfdff5cfd, 0x03209784, 0xa9832782, 0xcf820220, 0xff203a82, 0x2609dd55,
    0xfff7fffc, 0x46c400f6, 0xc54808df, 0x0fd75b08, 0x04842184, 0x3b7d8b88, 0x4d358309, 0xf720059f, 0x02226182, 0x896cfaff, 0x6c678405, 0x3c84089d,
    0x83ff0121, 0x88fb2027, 0x057b6043, 0x840b4555, 0x87048326, 0x84078723, 0x790020f3, 0xfe220cfb, 0x4f82fdff, 0xfcfffc24, 0xd984faff, 0x5b000b21,
    0x7b84081b, 0xb946fe20, 0x08897a05, 0x4305c14d, 0xf9210511, 0x057d50ff, 0x09b34c18, 0x20058755, 0x063959fd, 0x20092371, 0x77581805, 0x05294308,
    0x820cb361, 0x1b461877, 0xfb45180b, 0x182b8309, 0x4b093d6d, 0x968407ed, 0x4305dd7b, 0xd582050d, 0x43830020, 0x0722b982, 0x01820900, 0x08000722,
    0x08210784, 0x055b4200, 0x04000922, 0x03200184, 0x01200584, 0x02222b82, 0x23820300, 0xf77f9f83, 0x0c715f0c, 0x85050345, 0x18258405, 0x4a0c9365,
    0x034a058f, 0x00012107, 0x02200985, 0x45889783, 0x9d411583, 0x67002005, 0x87430829, 0x20198505, 0x83158202, 0x05bb4109, 0x03209383, 0x0020c382,
    0x04200086, 0x06840786, 0x8405b341, 0x7f00200a, 0x0e850869, 0x6d410020, 0x86758805, 0x52068e15, 0xff2005f3, 0x3382c386, 0x48063b41, 0x378e1043,
    0x27830e87, 0x22087351, 0x85000600, 0x221d83bb, 0x82fcff01, 0x0ad3509d, 0x0083ff20, 0x1582fb20, 0x1782bd20, 0x200b795e, 0x0abb4305, 0x03833983,
    0x06825382, 0xf2fe0838, 0x29030000, 0x07001f01, 0x8b020f00, 0xbb02a302, 0xdf02d302, 0x0810e702, 0x489f0133, 0x8f408fc3, 0x007b21ba, 0x01200083,
    0xff210483, 0x200582ff, 0x07ab4306, 0x02820b82, 0xff85012a, 0xffe1fff9, 0xff0000e1, 0x20056748, 0x280782fc, 0xfffeffff, 0xff0200fb, 0x260182ee,
    0xfff2fffa, 0x82f0ffef, 0xfffd2205, 0x220182e4, 0x49eafff8, 0xff20066d, 0xff214983, 0x844482fe, 0x20338202, 0x06d948fc, 0x3d84fb20, 0x83fffd21,
    0x82fc2000, 0x82fc2047, 0x5201200f, 0x218205ed, 0xfbff0224, 0x1582faff, 0x21055d64, 0x198200fc, 0x03201f82, 0x3f832c82, 0x27830320, 0xff000023,
    0xdf7018fb, 0xfdff2109, 0x67829382, 0xfb213782, 0x831f8200, 0x201f84c7, 0x824782f9, 0xf1ff237b, 0x0682f1ff, 0xf7ff0022, 0x20067772, 0x20cb84fc,
    0x830582fa, 0x82a784d3, 0x05a1451f, 0x84057345, 0x8c0a82ed, 0x20818202, 0x835f82ff, 0x82ed20f5, 0x84bf84f9, 0x00012120, 0x63462f83, 0x18ff2005,
    0x20088b58, 0x08ef6ffb, 0xc3820020, 0x4706af4c, 0x796608c1, 0x2b3b820d, 0xecff0800, 0xfaffedff, 0xfcfff8ff, 0x0220e382, 0x54085b79, 0x04200931,
    0xfb207d82, 0xf420e582, 0xf7206382, 0xdf82cd82, 0xf5200582, 0xf7223182, 0x954af9ff, 0x45fe200a, 0x25820519, 0xf3fff524, 0x0182f5ff, 0x0382f420,
    0xf1fff822, 0xf8200182, 0x2108f166, 0xcd5800fd, 0x203b8206, 0x201582f9, 0x427182fe, 0xfd200507, 0xf6204b82, 0x4783b382, 0xe184fc20, 0xff220482,
    0x214900f4, 0x0ee74705, 0x4affff21, 0x5b460e2d, 0x00072805, 0x00fdff07, 0x82040007, 0x13af5d01, 0x0d000d22, 0x14224884, 0x87821300, 0xbd840120,
    0xd384fa20, 0xfd20a183, 0x04208b84, 0x05201982, 0x0e204184, 0x31832d82, 0x11001028, 0x0f001000, 0x0f830900, 0xcb41c984, 0x18058305, 0x2c0b5d43,
    0xffecfff8, 0xffffffed, 0x001600fe, 0x592d8215, 0x012405dd, 0x0b000600, 0x08220182, 0x13820800, 0x05000826, 0xffff0200, 0x0abb6218, 0x1f820320,
    0x13820120, 0x3982f920, 0xfafffb22, 0x0f823f84, 0x17830020, 0xe37ecf82, 0x00022208, 0x201b8203, 0x20dd84ff, 0x22058206, 0x84010003, 0x8201200f,
    0x000d223f, 0x2011820c, 0x065d4800, 0xfb249383, 0xeffffbff, 0xef228f84, 0x6d82fdff, 0x83096b43, 0x000e225b, 0x835f820e, 0x820e20df, 0x058d4739,
    0xa7842482, 0x06000524, 0x4541fdff, 0x00052406, 0x82040005, 0x8268829b, 0x054d4215, 0xdf820420, 0x3d820220, 0x0a000522, 0x0b837f84, 0x7d820720,
    0x8f820920, 0xd982fe20, 0x8f820420, 0x39824382, 0xfeff0722, 0x09222b82, 0x1d820a00, 0xfd820720, 0x75500a20, 0x82092006, 0x00062221, 0x526d820c,
    0x07200511, 0xbb833582, 0x2b0edb65, 0xfdff0000, 0xfafffcff, 0xeefff0ff, 0xf020cb82, 0x4c06874d, 0xf74f096f, 0x43f92005, 0x7b83065f, 0x8752c383,
    0x00172305, 0x9f610018, 0x830f2005, 0x216182b9, 0xd3470001, 0x00022105, 0x20050d51, 0x48c38205, 0x0020058d, 0x9f768f84, 0x85958206, 0x820e2037,
    0x000a21ad, 0x0326bd83, 0x04000400, 0x2f82f9ff, 0x03835f83, 0x43820120, 0x14000c23, 0x05b15200, 0xe7820620, 0xc36aff20, 0x4800200a, 0x2d830a31,
    0x11000926, 0x0e001000, 0x47823f82, 0x82070021, 0x000d2229, 0x0a81660d, 0xffff0022, 0xf4244182, 0x18fcf4ff, 0xfb20ef82, 0x82070f4b, 0x82b3823a,
    0x820020b9, 0x82062033, 0x00052235, 0x82c78403, 0x83002018, 0x01ff2233, 0x8295824c, 0x02002309, 0xa384f3ff, 0x8984f520, 0x08000022, 0x10202d82,
    0x3182ff82, 0x04822c84, 0xfff8ff25, 0x563a00f7, 0xff22084f, 0x0182f3ff, 0x4f49fc20, 0x211e8205, 0x01850013, 0xff21dd84, 0x822782ff, 0xf400218f,
    0x83083f54, 0x4b038217, 0x9e20068f, 0x220c5b5b, 0x828600ff, 0x20029b1a, 0x831c8210, 0x72fa20cb, 0x64820a7d, 0x0920cd82, 0x82083d5c, 0x22df8208,
    0x840100fa, 0x20878423, 0x05a75800, 0xa588fb20, 0x33821582, 0x21820020, 0x13600620, 0x05064708, 0x02851982, 0x08eb6118, 0x1d8e2b85, 0xff225182,
    0x4382feff, 0x83058963, 0xfffe2223, 0x20e582fd, 0x82878702, 0x05cb5812, 0x4108054a, 0x1b820973, 0x77820320, 0x0600fb24, 0x8b6d0200, 0x23a1820c,
    0xfafffbff, 0xfe221384, 0x4b82fdff, 0x4e18fc20, 0x21440811, 0xfff92105, 0xf4260185, 0xf1fff2ff, 0x4982f5ff, 0x09220287, 0x7f820800, 0x1a000624,
    0x7b841900, 0x230c3f68, 0xfdff0000, 0xfb205582, 0x17845182, 0xc1840785, 0xf7792c82, 0x18fe2008, 0x22087f7c, 0x820500f1, 0x05b14a01, 0x07000122,
    0x2306cf4d, 0x000d0002, 0x2105895c, 0x01830006, 0x73820720, 0xd7820020, 0x21844382, 0x0d830782, 0x6582c382, 0xfd205d82, 0x5550cb82, 0x41f42005,
    0x25820a8f, 0xfe208f82, 0x03202982, 0x03210a82, 0x052d4600, 0x0b420120, 0x054f4508, 0x3b84f920, 0x5d85f620, 0x51829782, 0x61842185, 0x8982fc20,
    0x05000e22, 0x08df4618, 0x2007b54c, 0x17511803, 0x82032008, 0x2053892d, 0x20418200, 0x206d82ff, 0x20558401, 0x20a182fb, 0x181182fd, 0x82088173,
    0x00062353, 0x7382ff0c, 0x0620df82, 0x03822783, 0x0720d985, 0x1223e982, 0x82001200, 0x832582a7, 0x43038916, 0x01240757, 0xf6ff0000, 0x08214118,
    0x2005e751, 0x08e55ffc, 0x3b82fe20, 0x1f820420, 0xe984f620, 0x22052b41, 0x82010004, 0x00102257, 0x840e8310, 0x20118357, 0x20298203, 0x065f4402,
    0x830a5341, 0x8503820a, 0x6608821d, 0xbd5f0c7f, 0x18002009, 0x8209f176, 0xffff227b, 0x226f88fd, 0x820d000d, 0x8207200b, 0x85fc20f5, 0x2471826f,
    0x00000002, 0x8301820a, 0x55052077, 0xe95d0a93, 0x20588208, 0x202782fe, 0x06f74406, 0xfc201783, 0x2006bf48, 0x200c82ff, 0x82918501, 0x09fd4421,
    0x22095d5c, 0x82f9fffe, 0x82fd2001, 0x205f832f, 0x088b4302, 0x00213482, 0x05b55d00, 0xf9410a82, 0x84022005, 0x82238ef5, 0x05cf441d, 0x4782fc20,
    0xf7fff822, 0xff214d85, 0x203b82fc, 0x099f41f9, 0x75837d84, 0x5b05ed41, 0xc3821089, 0xfafffa22, 0x820f3364, 0x2002853f, 0x08e55e01, 0x03203983,
    0x39522d82, 0xfdff2408, 0x18ff0800, 0x20096565, 0x8d3085fd, 0x208b8205, 0x473382fd, 0xf92205bf, 0x8b6df5ff, 0x29801810, 0x00fc2209, 0x0ffd7707,
    0x00fbff23, 0x824f8d01, 0xff01240f, 0x4afefffb, 0xfe2006a5, 0xfb203182, 0xed201384, 0xff212785, 0x83cb82fe, 0x200383cf, 0x099d4aff, 0x00030026,
    0x00070005, 0x24059143, 0xff010000, 0x834582e6, 0xfff92623, 0x001000ff, 0x24a78210, 0xfff6fffa, 0x205782f7, 0x417384fd, 0x358305b1, 0x02000d22,
    0x76203d82, 0x05825f85, 0x04201983, 0x69852782, 0x1182fc20, 0x02200285, 0x08205f82, 0x1b833b82, 0xe7fffb22, 0x05821485, 0x210c635a, 0x1182b4ff,
    0x01200283, 0x07837782, 0x17ff032e, 0xfb020200, 0x91025e01, 0xbd02ad02, 0x02990e10, 0x420025bf, 0x04000100, 0x28069549, 0xff030001, 0x00fdfffe,
    0x06434406, 0x74180020, 0x02200839, 0x02202582, 0x830a9b4b, 0x45042033, 0x0d8308d5, 0x5605235d, 0x49820701, 0x88030021, 0x4400201f, 0x04200893,
    0x03836b82, 0xe3490620, 0x85032008, 0x86002027, 0x08f3566b, 0x2207bd4d, 0x82fbfffa, 0x82012033, 0x83072093, 0x06536322, 0x0a000922, 0x09200182,
    0x20087561, 0x20b78204, 0x211b82ff, 0x01850018, 0x27002724, 0x03822800, 0x09000824, 0x01820800, 0x4083af85, 0xb7450120, 0x82ff200e, 0x82022071,
    0x05737013, 0x09820020, 0x9b820120, 0x2007ed43, 0x470b8300, 0x2e820be7, 0x2384ff20, 0x69180220, 0x558308fb, 0x0b000022, 0x01200182, 0x20081556,
    0x228f82fe, 0x83fdfffe, 0x835f821a, 0x82f58345, 0x203f831f, 0x5d1d83ff, 0x2c22071b, 0xdb822c00, 0x61000221, 0x59720bf9, 0x00042205, 0x20198203,
    0x20038205, 0x08db7806, 0x3282978b, 0x45000021, 0xfb2606ab, 0xf4fffcff, 0x0184f5ff, 0xbf84fa20, 0x49fffd21, 0x575f0957, 0x20758305, 0x09cb49fd,
    0x2008f972, 0x585d83fe, 0xfd200881, 0x83065548, 0x83af845d, 0x202b8408, 0x200986ff, 0x08bd5dfc, 0x3f65fe20, 0xff012208, 0x20ed86fb, 0x089b6cfc,
    0xe7ffe822, 0xe8200182, 0xf4209784, 0xfb200582, 0x2106e945, 0xfb82fffd, 0x870acb6c, 0xfffd2157, 0xfe200183, 0xc983c384, 0xf8fff622, 0xfc200184,
    0xfb85b386, 0x20098f55, 0x08e34902, 0xb9454184, 0x0bfc5108, 0xb7760020, 0x0b4d4708, 0x8f4d0220, 0x20a98205, 0x0a7f46fb, 0x83075f5a, 0x82ff2013,
    0x08d76f17, 0xe9839782, 0x0a795d18, 0xff000023, 0x085750f9, 0x4818fc20, 0xfd2008b5, 0x2008f94a, 0x228d82fd, 0x84feff00, 0x057741e5, 0x6d82fe20,
    0xff200f85, 0xf5233982, 0x85fffcff, 0xfff7246f, 0x821200f3, 0x00052601, 0x00040005, 0x20318204, 0x211982fd, 0x7018fff6, 0x52831143, 0xff200384,
    0xfc220083, 0x6d42fcff, 0x84002005, 0x23611800, 0x7f8b180a, 0x82188408, 0x204f8204, 0x3b7118f7, 0x088b7409, 0x2b838d83, 0x1183fd20, 0x1b4f0382,
    0x09a55a05, 0x1f41ff20, 0x055f4706, 0xbd410020, 0x6afc2006, 0xff200819, 0xfd854984, 0x59520583, 0x0aab5806, 0x49186185, 0x8e820cf3, 0x17440120,
    0x00022108, 0x2008b373, 0x099373ff, 0x02000526, 0x0c000d00, 0x19210384, 0x22018500, 0x820b000a, 0x000a2411, 0x82050008, 0x82072001, 0x41458421,
    0x012106dd, 0x0fc95a00, 0x4f880520, 0x01000022, 0xff210b83, 0x820585fe, 0x18012031, 0x2108316b, 0xd5830001, 0xa082f920, 0x1782fa20, 0x17820220,
    0x82067541, 0x05875017, 0x1b820420, 0x3000ff25, 0x8500f6ff, 0x0000226f, 0x20018206, 0x4a7f8203, 0x062105b9, 0x68e382ff, 0xdc8208e9, 0xc542ff20,
    0xfffc2605, 0xfff7fff8, 0x241082db, 0x00040004, 0x715d1807, 0x05555f08, 0xfdffff22, 0xff221182, 0xc7885a01, 0x67820020, 0x3382fd20, 0xa584f820,
    0x3784ff20, 0x49410220, 0x842b8305, 0x820420e7, 0x82b18215, 0x0a795a05, 0x086b4e18, 0x028c1382, 0x24050543, 0x00000002, 0x050b4102, 0x200ed558,
    0x053d4205, 0x9d42ff20, 0x82fd2005, 0xff01240d, 0x49fafffb, 0xfc2008fb, 0x8505774f, 0x00002125, 0x8206b749, 0x8202834e, 0x070f414b, 0x1805d14a,
    0x8311a771, 0x4e038626, 0x2b820855, 0x00020022, 0x20050151, 0x22098205, 0x520e000e, 0xfe2208e3, 0x8384fcff, 0x84053342, 0x86698405, 0x08bf769f,
    0x85fffc21, 0x09795bab, 0x0400f924, 0xbb820300, 0x8918ff20, 0x67180ef9, 0x79410dcf, 0xbd511805, 0x833e8308, 0x6303845f, 0xe54e0f75, 0x871a8405,
    0x24f18204, 0xfff7ff00, 0x82cb83f8, 0x5b47826b, 0x83430599, 0x82ff200c, 0x8203202d, 0x900682d7, 0x093d7d02, 0xfd203b83, 0xff211f83, 0x20b182fe,
    0x08f14ef6, 0x8d692184, 0x83032008, 0x854b8ad5, 0xff0522a3, 0x182f85f5, 0x440a3f93, 0x05450755, 0x955e830b, 0x20658203, 0x843182ff, 0x092342b7,
    0x85852b89, 0x23830120, 0xfd20e784, 0xfb200982, 0x07836d82, 0xf382ff20, 0x7b863382, 0xc384fd20, 0xed420c83, 0xfff72205, 0x41cf82f8, 0xfd2009af,
    0xf7210d82, 0x221583ff, 0x82fcfff8, 0x82fb2001, 0x0521450f, 0x0982fd20, 0x93413783, 0x82fe2007, 0xfffc210f, 0x00234f84, 0x820c000b, 0x000722f9,
    0x2401820a, 0x00070008, 0x5b038206, 0x092205cf, 0x0b820900, 0x47000121, 0x0020092b, 0x05838185, 0x6382cf83, 0x6984fe20, 0xfd206583, 0x05830d84,
    0xf9220383, 0x9d82f9ff, 0xf9fff822, 0x05204f82, 0x04202b82, 0x03226382, 0x4f820500, 0x16001622, 0x83065344, 0x0007216d, 0x210d5355, 0x00830002,
    0x4405a744, 0x002205ab, 0x77460100, 0x82fc2008, 0x83d98253, 0x44038a22, 0xfb22056f, 0x3751fbff, 0x053f410c, 0x7742fd20, 0x0c8b4305, 0xcb575d82,
    0x050b410a, 0x4200fe21, 0x01210583, 0x20958300, 0x830d8203, 0x84fc20c1, 0xfff922c5, 0x0bc976f6, 0x8f48ff20, 0x82042005, 0x844982b9, 0x180320bf,
    0x45088961, 0x155f0717, 0x00062605, 0x000a0009, 0x20fb8202, 0x0be34804, 0xff214d85, 0x8a1382fd, 0x840a89c6, 0x820320b3, 0x0007221d, 0x423b8207,
    0x95820735, 0xcd8a2385, 0x01201085, 0x04212b82, 0x09035100, 0x44000121, 0xff2005df, 0x01202986, 0x03201f82, 0xff206d89, 0x2005c142, 0x205d82fc,
    0x855f8206, 0x820820b3, 0x00032409, 0x8257ff03, 0x82f7203b, 0x44f920f1, 0x6085051f, 0x01200588, 0x2008136e, 0x202f8404, 0x20558204, 0x24668204,
    0xfff1fffe, 0x060f44f9, 0x03000122, 0x04202584, 0x04380784, 0xfaff0500, 0x0400faff, 0x0200b0fe, 0x36016103, 0x1d020502, 0x39022902, 0x02c90d10,
    0x6103233b, 0xc151ffff, 0xfffd2408, 0x18f7fffe, 0x21081f62, 0x074bffe7, 0xffd52105, 0xff200185, 0x200af742, 0x213382ff, 0x5545ff00, 0x8c0f830a,
    0x82022003, 0x8701202d, 0x21638411, 0xc7420005, 0x09136e05, 0x02000227, 0x0300feff, 0x05cf49ff, 0xa961fe20, 0x82f72008, 0xffff2211, 0x06ed45fa,
    0x05000222, 0xfa221982, 0x2982f9ff, 0x21050b45, 0xd569fffa, 0x20628309, 0x206b8203, 0x835d8204, 0x2203830b, 0x82f8ff01, 0x83fd203b, 0x0200240a,
    0x58000100, 0x0020078b, 0x6618db82, 0xff230a09, 0x86ecfffd, 0xffcf2301, 0x0383ffce, 0x20090165, 0x08f77afc, 0x2007f945, 0x418582fc, 0x0446080b,
    0x08894c05, 0xb184ff20, 0xab4afe20, 0x4d778205, 0xe97b0889, 0x82fa2008, 0x82fc20cf, 0xfff52297, 0x822582f4, 0x440020f5, 0x00200885, 0x02202d83,
    0x08536718, 0xb3840220, 0x05820320, 0x05824882, 0x01202783, 0xfd205f82, 0xfb226d82, 0x5182fcff, 0x0582fc20, 0x8408a962, 0x08415c83, 0xff206f86,
    0xf8206982, 0xb3823382, 0x77000021, 0xfd22085f, 0x0182e8ff, 0x0382e720, 0x17822f84, 0x830c776e, 0x206f826e, 0x29078301, 0xebffebff, 0xf6ff0200,
    0x0382f5ff, 0x9144f620, 0x941a8308, 0xffff2103, 0x02201686, 0xe741cd82, 0x00082405, 0x82080007, 0x85d98301, 0x221b83dd, 0x85060001, 0x0d511801,
    0x4973830c, 0x04220597, 0x35840500, 0xfb6f0520, 0x000c2108, 0x05240185, 0x04000300, 0x00205d82, 0x830c0149, 0x05c94a0d, 0x0d000222, 0x04222982,
    0x41820700, 0x03840620, 0x11826986, 0x05201383, 0x834b7782, 0x84072005, 0x08e94f11, 0x00820020, 0xfb235382, 0x83fffaff, 0x05dd4c03, 0x0d82f820,
    0x6b05ed4d, 0x022209c9, 0x81820200, 0x67820520, 0x09820d20, 0xfeff0224, 0x6d84fdff, 0x0b000b22, 0x01209b82, 0x0caf4318, 0x25840420, 0x05820d20,
    0x82095771, 0x20029067, 0x20518205, 0x203d820c, 0x21f58202, 0x43820002, 0x01284586, 0xffff0000, 0x17001600, 0x05200384, 0xcd836782, 0xd7820320,
    0x85840520, 0x73820a20, 0x0a221583, 0x1b820a00, 0x8b820720, 0x8f078141, 0x00012462, 0x84060004, 0x000622fb, 0x20018236, 0x24038235, 0x00310030,
    0x20018230, 0x225d820e, 0x820e0016, 0x00022655, 0x00dffb02, 0x08114e01, 0x20051349, 0x08cd47ff, 0x23820620, 0xa3420120, 0x4b032006, 0xcf21060b,
    0x05434100, 0x89560420, 0x202b8205, 0x223f82fe, 0x821c00fe, 0x00072acb, 0xff020007, 0xfff3fffc, 0x0c9d47f4, 0x3b820220, 0x2582df20, 0xf8fff822,
    0x8908ed59, 0x890120b1, 0x2009830a, 0x677818ff, 0x05f94309, 0x49052549, 0xfc2005a9, 0x4f0c437e, 0x60180581, 0xfd200913, 0x22062343, 0x18f5fff6,
    0x5608735d, 0x5f490541, 0xfffb2205, 0x4f5d18fb, 0x053f410e, 0x04000326, 0x0b000c00, 0x0783b382, 0xf1820d20, 0x09bb9b18, 0x4d49f785, 0xd5411805,
    0x83098309, 0x000022d5, 0x22018202, 0x82060007, 0x82032005, 0x000622bd, 0x22018208, 0x82ffff06, 0x82052051, 0x49032047, 0x22820ea1, 0x7e180285,
    0x117f08d5, 0x84fb2009, 0x85fd8213, 0x20058a21, 0x0acd4301, 0xfc20c983, 0xfd20c782, 0x2008937b, 0x08214ef9, 0x9f45b582, 0x058f4b06, 0xf55b0820,
    0x82042008, 0x65038387, 0x058305c9, 0x1b820420, 0x63820120, 0x07840520, 0x8f490220, 0x00072208, 0x82158207, 0x43058249, 0x0882059d, 0x0f840020,
    0x18feff21, 0x2008bf40, 0x208182fd, 0x213982fb, 0x00820002, 0x0c615018, 0x44058d41, 0x67460743, 0x20248309, 0x034518fb, 0x204b850a, 0x216584f7,
    0x5518ff08, 0x8784081d, 0x09c55d18, 0x0f001024, 0x01821000, 0x83000421, 0x820520a7, 0x0007241d, 0x84020001, 0x207b8479, 0x5b009300, 0x00200bf1,
    0x08037d18, 0x58180120, 0x042208e3, 0x15820400, 0x9106694e, 0x23a58440, 0xfffdfffb, 0x46056741, 0x914d05a9, 0xfdff2108, 0x20086153, 0x08ed7301,
    0x8305e741, 0x00042105, 0x20072b42, 0x08355403, 0x41071d4b, 0x75880a4f, 0xff20ab82, 0x00210082, 0x22e18206, 0x84090009, 0x820220e7, 0x832b8243,
    0x220f8287, 0x820a0003, 0x83308317, 0x82fc2013, 0x4cfc2015, 0x1683092d, 0x01200390, 0x8783f384, 0x08229185, 0x8b890700, 0xff000023, 0x207082fc,
    0x79df82fc, 0x418a0825, 0x0b5b5e18, 0x50000221, 0x7b850551, 0x2f4d0220, 0x09854308, 0x2005a143, 0x0a8553f8, 0x039a2b83, 0x82ffff21, 0x8295207f,
    0x4d2389d5, 0x814c07bd, 0x83c1840c, 0x20c18323, 0x20ab8415, 0x201382fe, 0x23398202, 0xff050004, 0x20059341, 0x222082f6, 0x41040005, 0xff21071d,
    0x176418fa, 0x3029820f, 0x02000055, 0x024901e2, 0x02550231, 0x0281026d, 0x390b10ad, 0xa9673b02, 0xb4022273, 0x2a008900, 0x00020002, 0x00010000,
    0x82080007, 0x82042005, 0x82072005, 0x84012011, 0x44178215, 0xfb2606b3, 0xfafffbff, 0x0182fcff, 0x7900fa21, 0xaf5c09c9, 0x44ff2008, 0x258305cb,
    0x20052f51, 0xd74518fb, 0xfffd2208, 0x475782f9, 0x21550c91, 0x08004b0a, 0xf8225982, 0x0182f6ff, 0x33841186, 0x20051c41, 0x05594500, 0xf8207f86,
    0xfd20598a, 0x5f823582, 0xfff8ff23, 0x826582f9, 0x203582c6, 0x19821800, 0x05b15509, 0x8308874f, 0xff012247, 0x21bf82ff, 0x9218fffd, 0x61830783,
    0x098d7218, 0x04000425, 0x4b000300, 0x5b850525, 0x8205c97e, 0x2061825d, 0x059344fe, 0x86094956, 0x070f48f5, 0x5b823182, 0x0020bf87, 0xfc200882,
    0x9b849982, 0x49833d82, 0xa984fa20, 0x0582f820, 0xf522e983, 0x7918f7ff, 0xfc20087d, 0xff200986, 0xfd206382, 0x0220fb88, 0x51866184, 0x790a8944,
    0xfd2005ed, 0x00201883, 0x2205d545, 0x41fbfffd, 0xe979060b, 0xfffe2405, 0x82f4fff4, 0x05eb501b, 0x08000322, 0x03200186, 0xfc206782, 0xfa222982,
    0x0182f6ff, 0xf2fff926, 0xf0fff1ff, 0x61720582, 0x05a56605, 0xedffec24, 0x0184dfff, 0xb782e020, 0xeeffee23, 0x05ad4500, 0x81820020, 0x0a83fe20,
    0xcf49ff20, 0x18002005, 0x85080180, 0x0020215d, 0x5f470185, 0x000f2205, 0x22018406, 0x82070005, 0x88062001, 0x00082103, 0x220dd946, 0x82050002,
    0x82042001, 0x0587411f, 0x02000422, 0x41620182, 0x1172180b, 0x05296e09, 0x88832185, 0x775a0387, 0x83108208, 0x4679830b, 0x02200975, 0x84072741,
    0x2122828f, 0x33520000, 0x200f890a, 0x915b1802, 0x82138408, 0x82918304, 0x064b484f, 0xb9840120, 0x01000022, 0x23892784, 0x04000022, 0x17821182,
    0x91512784, 0x85022005, 0x2011842b, 0x21df8200, 0x00870006, 0xdd860220, 0x97570320, 0x85168205, 0x82378357, 0x850f840c, 0x5b6f8843, 0x03220a73,
    0x37830100, 0xc54bbf84, 0x88308205, 0x00002143, 0x09574818, 0x0320b789, 0x83088949, 0x822c82f7, 0x411d8281, 0x07220691, 0x01861600, 0x0c000b24,
    0x01820b00, 0x20073941, 0x83d78204, 0x4e8d83d9, 0x51830d65, 0x4b780620, 0x410f830a, 0x02200515, 0x05208182, 0x03261982, 0xf3ff7ffe, 0x0382f4ff,
    0x7083f320, 0xd587af84, 0x79820820, 0x08000722, 0x2106d958, 0x49670019, 0x410a2005, 0x15730817, 0xff002205, 0x210182de, 0x6766ffdd, 0x82052009,
    0x830320c7, 0x06e14325, 0xfcfffc24, 0x0382fbff, 0xf1fff724, 0x6583f0ff, 0x00110025, 0x18e3fe11, 0x2208a741, 0x73fdfffc, 0x0320064d, 0x04223982,
    0x73820500, 0xd3820920, 0xfeff0326, 0x4cffffff, 0xad833182, 0x02840682, 0x50180220, 0x0720089f, 0x08219f82, 0x05775500, 0x71180b85, 0x234d0c5f,
    0x06534c05, 0xf9fff824, 0x0184f5ff, 0xc143f420, 0x09012105, 0x1808f14f, 0x8208ad8f, 0x0597415f, 0x3b6c0020, 0x833b8205, 0x189f8381, 0x8408a38b,
    0x4c022055, 0xb753054d, 0x82002006, 0x05e9430d, 0xd941ae82, 0x33691806, 0x2014820a, 0x223582fe, 0x18f8fff7, 0x550a0b7f, 0xf92005e7, 0x2008dd4b,
    0xf75818fc, 0x20398308, 0x20d9820a, 0x24e78206, 0x00100007, 0x24038211, 0x00020010, 0x2201820b, 0x82030001, 0x82062015, 0x21a78263, 0xaf85ffff,
    0x82092f5a, 0x0003210f, 0x57860184, 0x085d9118, 0x2008635d, 0x208382fe, 0x846b82fa, 0x4f002002, 0xff21064d, 0x06d97cfe, 0xf1fff024, 0x0382f2ff,
    0xfcfff122, 0x038f1b83, 0xff206984, 0x37826582, 0x39430020, 0x216d8305, 0x01830009, 0x0d000a22, 0x4b06cd55, 0x05870505, 0x03822e83, 0x82feff21,
    0xfff82201, 0x847b8bf8, 0x840320bf, 0x084f4bcd, 0xfe22b982, 0xa582fbff, 0xfc222f83, 0xa388fdff, 0xff20ed88, 0x20058f41, 0x082d4efd, 0x1805474d,
    0x18097b4d, 0x24097d40, 0x00060007, 0x08d14404, 0x0f000e22, 0x0f26a182, 0x0a000500, 0x63730900, 0x00012208, 0x21cb8203, 0xe941ff01, 0x098f5e07,
    0xf4fff522, 0xf5200182, 0xa9828383, 0x8f4c0a20, 0x000e2206, 0x20098410, 0x20b7840f, 0x21058209, 0x00890002, 0x89079741, 0x73032011, 0x02240835,
    0x04000500, 0x0a374018, 0x41840020, 0x13840420, 0xa9820520, 0x4406d741, 0xff20076f, 0x180c2759, 0x860fb37e, 0x43fb20af, 0xff20065b, 0x83084541,
    0x9b52184f, 0x44032013, 0xcf4d05fb, 0x090b5b0a, 0x8b054969, 0x840020c7, 0xf189185f, 0x4203200d, 0x0987096f, 0x58fdff21, 0x15840b3b, 0x91480320,
    0x830c8206, 0x201f8202, 0x06c541ff, 0x0400ff22, 0x61481b82, 0x8300200c, 0x8f4a1867, 0x0001240d, 0x4f020001, 0x5f180887, 0x335b0881, 0x8201200e,
    0x20af8521, 0x08274801, 0x83052f41, 0xb966183f, 0x22378e0a, 0x50fcff00, 0x00201287, 0xff200091, 0x22056f42, 0x82050001, 0x4d032001, 0x998308ed,
    0x04200383, 0x6583cb82, 0x0f680020, 0x05375908, 0x26075560, 0xfff5fff9, 0x890e00f5, 0xe9991857, 0x9718890e, 0x82012009, 0x85032059, 0x63ff211c,
    0x05840785, 0x20052345, 0x207f8206, 0x84218203, 0x21048712, 0x7382f2ff, 0x0d820120, 0x03825320, 0xff229982, 0x1b5ffffe, 0xbb4d1805, 0x22d7840a,
    0x84060004, 0x180b2001, 0x22088178, 0x18fbfffd, 0x82090999, 0x117a1835, 0x0b535a09, 0x098f7618, 0xa3410520, 0x08174105, 0x65620320, 0x00012d0a,
    0xff5fff02, 0x01d602ff, 0x01bd0047, 0x3b4b8f82, 0x8d734073, 0x18d50221, 0x23082362, 0xfffeffff, 0xc5220383, 0x4f1889ff, 0xd22208ad, 0xab5ba4ff,
    0xffec2208, 0x232b82da, 0xfff9ff00, 0x22059147, 0x83f8fffc, 0x1800200f, 0x820cdba5, 0xffd4232d, 0xa54300a9, 0x824d8205, 0xfff82e09, 0xfffefff1,
    0xfffdfffc, 0xffecfffa, 0x220784d8, 0x18f6fffb, 0x200887b0, 0x205182fd, 0x222182fe, 0x82ecfff6, 0x00ff282d, 0xff050002, 0x82aeffd6, 0x056f435b,
    0x04000222, 0x05240182, 0x07000500, 0x06241b82, 0x03000100, 0x5105c148, 0xfa2108fb, 0x224f83ff, 0x42fdfffe, 0x01200677, 0xf2205182, 0x65571d84,
    0x43a7840a, 0x04200525, 0x0887a718, 0x55820320, 0x08000423, 0x26008300, 0x00060003, 0x8419000c, 0x002a221b, 0x23128354, 0x2f001700, 0x28220784,
    0x07845000, 0x13000a22, 0x8408fd42, 0x838b8287, 0x82042018, 0x2207839b, 0x830b0006, 0x14002306, 0x77422800, 0x00032406, 0x845c002e, 0x222f8333,
    0x8475003b, 0x8201205f, 0xfd012205, 0x202b83bd, 0x054157ff, 0x0682fc20, 0xeafffd24, 0xcb82d5ff, 0x54fff721, 0x1a84051b, 0x0122d384, 0xff6d0200,
    0x49d38708, 0x0420050d, 0x04206782, 0x51065341, 0xfe200783, 0x0a63a918, 0xa1820220, 0xe5820720, 0x03820a20, 0xc1480b20, 0x00132406, 0x79110009,
    0x022a08b9, 0xf9ff3501, 0xf8fff2ff, 0xae18f1ff, 0xef4910df, 0x20888206, 0x458782fe, 0xeb870521, 0x06000222, 0xf922bf84, 0xa884f3ff, 0x4582fd20,
    0x1f420883, 0x4d002006, 0x534205e5, 0xffed2205, 0x209382da, 0xb77518fc, 0x2099830c, 0x20558200, 0x09076000, 0xffd7ff23, 0x208382ad, 0x84cf83f6,
    0x000a22f7, 0x20a98213, 0x24038210, 0x0010000f, 0x2001820f, 0x2075820d, 0x4baf180b, 0x0aa34b08, 0x4f830020, 0x04000122, 0x09200182, 0x05201f82,
    0x02203f82, 0x200c0b4b, 0x200d8201, 0x08575803, 0x0500ff24, 0x67820a00, 0x0c00f926, 0x08001900, 0x03225982, 0xa3830700, 0xb9832582, 0x08d35a18,
    0x03820f83, 0x0622fb85, 0x1f860a00, 0xc94efd20, 0x46002005, 0xfd220527, 0x1783faff, 0x06205d82, 0x05200784, 0x08845582, 0x3b4c0020, 0x450b8205,
    0x0b8408b7, 0x20085f49, 0x20a7848f, 0x46b58202, 0x1d8505eb, 0xf6fffc22, 0xfa202182, 0xfc200382, 0x20062743, 0x063f41f8, 0x2982fe20, 0xbb820620,
    0x07820520, 0x83000321, 0x18038309, 0x20096358, 0x081543fe, 0x4418fc20, 0xab830891, 0x37493f84, 0x8201200c, 0x00082279, 0x20438212, 0x33038206,
    0xff050000, 0x0305000b, 0x01e7000f, 0x017b0163, 0x01bd01b5, 0x01fb7910, 0xfa022dc8, 0xfbfffeff, 0x0100faff, 0x07000200, 0x04220182, 0x13510600,
    0x77002005, 0xfb2005e7, 0x08759118, 0x85ffee21, 0xffdc2401, 0x82dcffdd, 0x18fd2001, 0x4208d141, 0xf720054f, 0xf8202982, 0x25850382, 0x07915f18,
    0x1584ee20, 0x03851783, 0xd74bf820, 0xfff72108, 0xfa201185, 0x81827f82, 0x098f5518, 0x9a180f84, 0xf920093f, 0x65851986, 0x5b18fa20, 0xfb2008e3,
    0xfc207f82, 0xfa202b82, 0xfa205184, 0x0a417218, 0x27452983, 0x60fe2005, 0xf8200897, 0x17852982, 0x2005d54c, 0x202f82f9, 0x204182f9, 0x23fb82fa,
    0x00ffff00, 0x22053349, 0x82040005, 0x82042009, 0x00012235, 0x20698202, 0x202582ff, 0x09c559fb, 0x00850020, 0xefff0124, 0x0382f0ff, 0x4718ef20,
    0x5b430859, 0x07274705, 0x6b82fe20, 0xdd82f920, 0x21825b82, 0xfc210583, 0x05254400, 0x00850020, 0x83ffff21, 0x22058407, 0x82080008, 0x20058373,
    0x20098209, 0x08f55703, 0x1805ab4c, 0x23099da0, 0x00120011, 0x05850383, 0x02000022, 0x05200184, 0x5b824783, 0x83053f4c, 0x07d54813, 0x200b4c48,
    0x20218200, 0x83658201, 0x83db83e3, 0x845f82e5, 0x8804207f, 0x20258589, 0x08ef6702, 0x12206985, 0x04209182, 0x37833b82, 0x3582c384, 0x0123a583,
    0x82ff0300, 0x228582ef, 0x82070003, 0x82012001, 0x82022063, 0x18062003, 0x200af391, 0x22b38212, 0x86240012, 0x05295c01, 0x16001624, 0x03821500,
    0x23741620, 0x05794508, 0x0020af85, 0x0f836982, 0x07220383, 0xa9180600, 0x73850a19, 0x41104541, 0xfc2306d5, 0x830042fd, 0x1800207d, 0x240c9f47,
    0xfff5fff6, 0x85af82fe, 0x8203209b, 0x05df415b, 0x09000924, 0xf7859b02, 0x2008336c, 0x05ed4afe, 0x18822d82, 0x2108355f, 0x0185fffc, 0xf0fff124,
    0x0182f1ff, 0x0782f020, 0xf8210983, 0x200185ff, 0x55af18fd, 0x05614708, 0xd584fc20, 0xbf4d0420, 0x00102408, 0x8210000f, 0x001f2101, 0xfd210182,
    0x088d4e7f, 0x0122c783, 0x6a82e3ff, 0x4d000021, 0xae20097f, 0x53820f85, 0xcd82fb20, 0xbb820220, 0x8818fe20, 0xfc2108b7, 0x415918ff, 0x892a840d,
    0x09ec5404, 0x5d71d789, 0x850e860e, 0x8305831f, 0x08bf52ab, 0x4e000121, 0x474f074f, 0x82022005, 0x79921881, 0x202b820e, 0x43ef84fe, 0x27820579,
    0x0f470020, 0x0cd74208, 0xfffffe24, 0x0182f8ff, 0x0382fc20, 0x5a18f920, 0xfa2608e5, 0xfdfff9ff, 0x0182fbff, 0x2f841f82, 0x3f550120, 0x20098508,
    0x210f8203, 0xfb5e0006, 0x54052005, 0xc9460801, 0x82062005, 0x500020ad, 0x3e8308a9, 0x2d820220, 0x0f5e0220, 0x057d4106, 0x1947fd20, 0x09f35908,
    0x6f82fe20, 0x097d9c18, 0x3384fd20, 0x0b000b24, 0xe7420400, 0x000a2106, 0x22055943, 0x82050011, 0x82012054, 0xe79e1803, 0x422f840c, 0x51430575,
    0x85798309, 0x440982b1, 0xf282069d, 0x05205382, 0x06214384, 0x20ad8300, 0x08b56203, 0x6c09ed43, 0x138409b7, 0xd76a2182, 0x82fe200b, 0x09954c6d,
    0x820ceb42, 0x23028d26, 0x00010001, 0x15862b83, 0xff228584, 0x1383fdff, 0x2006b344, 0x0cfb4efe, 0x02940c82, 0x19744782, 0x05a74d08, 0xc7820420,
    0x82089b7b, 0x18ff20d6, 0x20085944, 0x7d6582fb, 0xe94b0dcb, 0x06bd5606, 0xdf42fe20, 0xc7ff2105, 0x04204182, 0x89064745, 0xff012274, 0x08db48f6,
    0x1687fd20, 0x00215f83, 0x09f94a39, 0xff211785, 0x08015cff, 0x8509d16c, 0x2405a31a, 0xff000001, 0x509382fe, 0x37890b0b, 0x5d820120, 0x37000022,
    0x63411084, 0x68718508, 0xa6280c3b, 0x7d010000, 0xe1001f01, 0x23e4835b, 0x0004005b, 0x4209ad58, 0x01200509, 0x8206a34a, 0x8a002007, 0x0c477200,
    0xfdfffd26, 0xffff0000, 0x02203b82, 0x870bf768, 0xfeff252e, 0xfbffffff, 0x84091153, 0x0545443b, 0x2005a147, 0x202182ff, 0x894718fe, 0x18fc2008,
    0x59085f82, 0x254305ef, 0x6e51820a, 0x0520091b, 0x0420ad82, 0x08220382, 0x01820500, 0x06000622, 0x6208ab68, 0xfe2c05a1, 0xf9fffaff, 0xf4fff7ff,
    0xeeffefff, 0xf8200382, 0x65820b82, 0x0a53a718, 0x6982f920, 0x08976418, 0xfd208384, 0x03830582, 0x5318f820, 0x01220a49, 0x65840300, 0x03206b83,
    0x2008d545, 0x83138207, 0x063d4273, 0x5f4e2f82, 0x20098206, 0x4d5784fc, 0x3c420989, 0x65be8207, 0x02200845, 0x02203f82, 0x0324b182, 0x0a000b00,
    0x01250184, 0x08000700, 0x46008b00, 0x042005ef, 0x17843384, 0x2f53ff20, 0x057b4409, 0x1b820120, 0xf7840520, 0x09820520, 0x05000425, 0x46ffcc00,
    0xf8200595, 0x7d48e784, 0xfffa2409, 0x84eeffed, 0xfff72303, 0xe383fff7, 0xfafff922, 0x2143f384, 0x48022009, 0x811805f3, 0x032008b7, 0x9d839784,
    0x11001222, 0x10200182, 0x03201f82, 0x08a98b18, 0x27820220, 0x06000422, 0x05200182, 0x1808c747, 0x8408eb51, 0x200485ae, 0x216d8201, 0x0160ffff,
    0xb3701809, 0x1800200a, 0x45091768, 0xc15a05b7, 0x82f62007, 0xfff722c5, 0x06d755f6, 0xf2fff524, 0xad82fbff, 0xc165b583, 0x09c75909, 0x97840320,
    0x200fed4d, 0x0637550f, 0x0d241783, 0x0c000d00, 0x0620cd82, 0x04202982, 0x0120df84, 0x19820582, 0x0082ff20, 0xbf830020, 0x7b410820, 0x001a2506,
    0xff04001b, 0x02226585, 0x01840100, 0x33830787, 0x20050844, 0x83178403, 0x000223df, 0x008a0002, 0x200ca359, 0x846d8202, 0x0825511b, 0x0b840882,
    0x0a845f82, 0x1741fe20, 0xfff92106, 0x2009914a, 0x2c3582fa, 0x010400d8, 0x0023015c, 0x01e100b5, 0xe47b440d, 0xf9520020, 0x005c212a, 0xff200088,
    0x41056f5d, 0x5346074f, 0x089f4108, 0x08862988, 0x1806eb46, 0x51089d4b, 0xff20055f, 0x6d5e0f82, 0x8c298608, 0x08b34406, 0xf9fffa28, 0xeffffbff,
    0x3883f0ff, 0x82f1ff21, 0x82fd2001, 0x05df4f11, 0x0c87318c, 0x00feff23, 0x240b8201, 0x000a0007, 0x22098204, 0x82050005, 0x05d2410d, 0x04850884,
    0xfffbff26, 0xff0000fb, 0x2005fd47, 0x08034803, 0x03832d83, 0x0b000224, 0x83820b00, 0x2005ef47, 0x4d731802, 0x410d820d, 0x0020053c, 0x50064b49,
    0x798309d9, 0x01000023, 0x05735500, 0x2007b542, 0x18118201, 0x7709a17e, 0x13870983, 0x00890020, 0x87e4ff21, 0x83ff200b, 0x82fa20f9, 0x84fb2005,
    0xfffb2209, 0x05815bf4, 0x07861f87, 0x0c000322, 0x0c20ab82, 0x3f460582, 0xdf851805, 0x205f920b, 0x05217400, 0x892257c9, 0x0186eaff, 0xfdfffc22,
    0xff470182, 0x054b5c0f, 0x2005ad5a, 0x20a9820b, 0x089f5c0b, 0x4e000521, 0xc34405fb, 0x00022509, 0x00020003, 0x23067341, 0xe2ffe3ff, 0xe3210382,
    0x07d54eff, 0x2005154c, 0x082d4cfb, 0x5d6b6d86, 0x00002208, 0x413b8406, 0x754c0507, 0x00252305, 0x03830026, 0x794a0920, 0x82032006, 0x00052321,
    0x19410000, 0x82012005, 0x41738309, 0x042105ff, 0x82018500, 0x22028614, 0x47080009, 0x1d82135f, 0xfcff0123, 0x05b94700, 0x8205f141, 0x05674412,
    0xff200582, 0x0b490c82, 0x59601805, 0x6cfd2009, 0xfe2508c5, 0xfafffeff, 0x05d549ff, 0x09bd9418, 0xfd4cfe20, 0x65fe2008, 0x9b610a43, 0x82fa2005,
    0xfff5262f, 0xfff6fff5, 0x085155b7, 0xcb452e82, 0x82ff2008, 0x0531456f, 0x81410220, 0x82578606, 0x20578521, 0x08df74ff, 0x89420120, 0x20b78308,
    0x24c38205, 0x00020002, 0x8757967c, 0x2057af2d, 0x08bd5a06, 0xffffe228, 0x1d015a01, 0x53457b00, 0xfc00217d, 0x0acfb718, 0x2b05354f, 0x00060003,
    0x00210011, 0x001c000e, 0xff210082, 0x937818f9, 0x01002109, 0x20082d56, 0x20098204, 0x221f8404, 0x84f4fffa, 0x62fc2007, 0xff200599, 0x09f77518,
    0x17840320, 0x00230f9e, 0x83070004, 0x57002027, 0xfd24058b, 0xcaffe5ff, 0x200c2d43, 0x461f8603, 0xff2106c3, 0x063d6bff, 0x43820f9e, 0xad42f920,
    0x099f5706, 0x09000522, 0x01221385, 0x5d18000a, 0x414d0967, 0x41002005, 0xff2805eb, 0xffd3ffea, 0xffa1ffd1, 0x1141cf83, 0x431f8505, 0x0220058d,
    0x2a233784, 0x82005500, 0x061b4197, 0x0783f920, 0xff235783, 0x84f2fff8, 0x5ff92007, 0x178a05a7, 0x1786f120, 0xf2281f87, 0xf3fffaff, 0xf6fffbff,
    0x0020eb8c, 0x03285d84, 0x0a000500, 0x0d000600, 0x0e20f982, 0x07883783, 0x0f000822, 0x17890f96, 0xe5829782, 0x9f821420, 0x11480120, 0x00042408,
    0x82040008, 0x82042055, 0x0004303d, 0x01040070, 0x012301b1, 0x011b0107, 0x4247012f, 0x6d477d81, 0x2b99472a, 0xa2202bf5, 0x081dca18, 0xf3fff322,
    0x0aa78418, 0x61fff821, 0xf620053b, 0x44084151, 0x2a5107cd, 0x0b451809, 0xffff2208, 0x09e74900, 0x04000122, 0x00200182, 0x05220082, 0xd4870500,
    0xfe21348c, 0x095552ff, 0x22094147, 0x82070004, 0x82092001, 0x20378333, 0x20518206, 0x82478604, 0x08334d4a, 0x45089772, 0x835209a3, 0x070b470a,
    0xc982ee20, 0xa748f320, 0x5bfe2008, 0x4d4a0935, 0x51fc2008, 0x5818064b, 0xf3830d25, 0xf982f420, 0x76825284, 0x01200283, 0xf2410482, 0x05b14b07,
    0xa7820620, 0xad840820, 0x7f46a583, 0x00042205, 0x21b18203, 0x2d8b0000, 0x03000122, 0x08694d18, 0x21052549, 0xb355fff7, 0x825f8405, 0x84fd2004,
    0x093b4135, 0x0f840320, 0xff630320, 0x0bc14308, 0x8305b150, 0x18042067, 0x200e67b0, 0x08ad5802, 0x06209f83, 0x0a6ba018, 0x09000822, 0x08200182,
    0x05221182, 0x05840400, 0x22051549, 0x84080009, 0x82032001, 0x230284db, 0xfefffbff, 0xfd22ab82, 0x63186dff, 0xb3830a95, 0xaa85fe20, 0x49065549,
    0xff21085d, 0x08df4beb, 0x21057547, 0xb76e0003, 0x20338305, 0x504984fc, 0x1d200583, 0x08774018, 0x0fdfa718, 0x7882fe20, 0x0b5d6b18, 0x63820120,
    0x9f000122, 0x03201582, 0x0223ab82, 0x54000700, 0x012005bf, 0x3742a388, 0x200e8505, 0x08954103, 0x01540020, 0x4cbf8205, 0x2b830b21, 0x17822f84,
    0x5ffffc21, 0x097e050d, 0x43d7870b, 0xff2108cc, 0x220186fb, 0x82f8fff9, 0xfff92401, 0x82f3fff2, 0x82f52001, 0x84fc2015, 0x63ff2003, 0xe94e0861,
    0x0a374b05, 0x42052948, 0x978205a3, 0xcd850283, 0x042cc983, 0x10000500, 0x17001600, 0x0b001900, 0x0c200182, 0x93450382, 0x00012105, 0x83077d4d,
    0x058b4e23, 0x2005bf52, 0x06074201, 0x4707eb48, 0x541809eb, 0x658209d5, 0x410ab95c, 0xd585055d, 0xfdfffa22, 0x59431c82, 0x00002109, 0x200b0f46,
    0x0ab35401, 0xb1758f87, 0x18358309, 0x220d9348, 0x18fefffe, 0x4b081d5b, 0xeb8508eb, 0x41fcff21, 0x6d410633, 0x485c8209, 0x558216ab, 0xa9410285,
    0x41338306, 0xfd200549, 0xf9224782, 0x4b82faff, 0x0382fd20, 0xdb6d4182, 0x00ff2208, 0x0aef4808, 0xab839b85, 0x5b5f0220, 0x496f820b, 0x7b880843,
    0x4e05c347, 0x01410983, 0x180a2007, 0x83092f42, 0x89038243, 0x4e032002, 0x21820573, 0x1485ff20, 0x00ffff31, 0x00a3ff03, 0x01a50200, 0x015f0134,
    0x1087016f, 0x4a017906, 0x47470020, 0xf300213d, 0x08264084, 0x05000300, 0xa9180800, 0x38240849, 0x37003800, 0x04240382, 0x0d000e00, 0x04221b82,
    0xaf760200, 0x000a2406, 0x8206000a, 0x00092429, 0x82070009, 0x054d4233, 0x8405e841, 0xffff2705, 0xf7fff9ff, 0x0383f6ff, 0x44084b73, 0x0021087d,
    0x211f8400, 0xb742fffa, 0x197a1805, 0x29541809, 0x06334207, 0x33856d82, 0x4b180320, 0xed430867, 0x00042205, 0x205b8205, 0x066d5bfb, 0xfbfffc23,
    0x052745ff, 0x0982fb20, 0xfafffe22, 0x200a354c, 0x07174dfe, 0xff209683, 0x615e0086, 0x8518820c, 0x89158523, 0x2209821b, 0x82fefffd, 0x82f520c1,
    0xfffa2255, 0x08635cf8, 0xfc206583, 0xf2206582, 0x088dd018, 0x10e36918, 0x5a188185, 0xf72008eb, 0xfe224782, 0x4782f3ff, 0x82061547, 0x20028974,
    0x4d968401, 0xc98305b7, 0x816cfc20, 0x20228407, 0x51458201, 0x022005e7, 0xff570f82, 0x4b022009, 0x1d83088d, 0x830bc760, 0xffeb23b5, 0x0383ffec,
    0x7582f720, 0xbb86f420, 0x09134b18, 0x830df14f, 0x0a19416f, 0x45068f44, 0xe72005f1, 0x20060379, 0x220782e8, 0x6ee9ffe8, 0x334809e5, 0x0994480e,
    0x7360fc20, 0x8b648a07, 0x0002220a, 0x200e8203, 0x06ed680d, 0x1d001c22, 0x10220184, 0x01841100, 0x06000524, 0x01820500, 0x82084d47, 0x8302842b,
    0x22f18260, 0x821e0004, 0x20118301, 0x08f44202, 0xae000028, 0xfafffeff, 0xb359fbff, 0x86082008, 0xfffe288e, 0xfffdfffb, 0x7a1a00fd, 0x03200ee3,
    0x01202982, 0xad4e4d84, 0x00042405, 0x83040006, 0x24458201, 0x01f6fff7, 0x23608334, 0xfaff0000, 0x85063d64, 0x2205890e, 0x82020001, 0x07dd461b,
    0x4982f820, 0x49000221, 0x7f820c59, 0x2182fb20, 0xf6fff522, 0xfb200582, 0x0ae16418, 0xf6202583, 0x42051743, 0xf92008a5, 0x08ffbb18, 0x1e820120,
    0x8b820520, 0x03840620, 0xc5840320, 0xf9fffc22, 0x08d96018, 0xfa20098b, 0xfa205982, 0xa3821982, 0x82ecff21, 0xeda01801, 0x1845820a, 0x20088764,
    0x05ff4600, 0x05000222, 0x08dd5f18, 0x56082f5a, 0x04200805, 0x9418fb82, 0x022009e1, 0x04200d84, 0x22065147, 0x82080003, 0x4907208d, 0x082006a7,
    0x02223382, 0xc182f7ff, 0xb582fc20, 0x8305514f, 0x00fd2305, 0x8548ff00, 0xff092405, 0x82e6ffe8, 0x6ae42001, 0xfe200869, 0x8407cf42, 0x07c14d31,
    0xcd480020, 0x85a88205, 0x05934102, 0x18000021, 0x210b997a, 0xf948ff00, 0x84062005, 0x26878381, 0x000e000d, 0x520c000d, 0xc1460861, 0x84012005,
    0x9b6018b1, 0x84082009, 0x8202200f, 0x00022205, 0x85018205, 0x76058561, 0x0020060b, 0x2005f941, 0x20598407, 0x08fd5b06, 0xa3820420, 0x8305814b,
    0x8201202d, 0x0e715804, 0x028c1182, 0xfffaff23, 0x21e982fb, 0x0185fff7, 0x8f52f320, 0x07434806, 0x5b44fa20, 0x5e152006, 0x0c20066b, 0x0d20bd84,
    0x2208fd6f, 0x58ffff02, 0x568c0771, 0x85830c8b, 0x01200f83, 0xb585b382, 0x7d450320, 0x00052606, 0xfffdff08, 0x20e782fc, 0x83208204, 0x0001211f,
    0xff210182, 0x20c5827b, 0x209982fa, 0x820382fe, 0x4b83821f, 0x07230b75, 0x85ff1100, 0x82f82000, 0x07b54b1f, 0x8782fe20, 0x8208d950, 0x05394c51,
    0x2e058d43, 0xff020000, 0x0201004c, 0x017601e2, 0x10d70191, 0x8901b907, 0x913df747, 0xe002223d, 0x078b4bff, 0x47ffa423, 0x27008200, 0xfeffffff,
    0x58ffabff, 0xfd220b84, 0x1f85f9ff, 0x00010025, 0x82050003, 0x00022405, 0x82010000, 0x18fc2021, 0x220cefa0, 0x82070005, 0x00082401, 0x820b0008,
    0x000e2401, 0x43020004, 0x0320066f, 0x03200782, 0x08134b18, 0x2405c344, 0xfff2fff8, 0x210182f5, 0x5763fff7, 0x05634c05, 0x1805d147, 0x20098162,
    0x833582fc, 0x828f820d, 0x8202206b, 0x82f6202b, 0xfffe2277, 0xbdaf18fa, 0xfffd2508, 0xffdaffee, 0x4b054d48, 0x5b1805bd, 0xbf840a23, 0xe9880f8c,
    0x86077b57, 0x06b1431d, 0x09899018, 0xfe204b85, 0x830b1948, 0x830f854d, 0x397f1809, 0x220c830c, 0x82d7ffec, 0x820120a3, 0x5a02201b, 0x04240ac5,
    0x05000400, 0x4108837b, 0x217c077c, 0xfffe2109, 0x5585df82, 0x09894483, 0x0f86a985, 0xe6fff322, 0xfd20f784, 0xfe202382, 0x08899818, 0x5782ff20,
    0x11840520, 0xf5fffb22, 0xfd200782, 0x07206b82, 0x374f3785, 0xa74b180e, 0x2047820a, 0x471d86fd, 0x1f8609bf, 0x91836384, 0xfb4ffc20, 0x083d4108,
    0x9b4fd782, 0x84022009, 0x07a344e9, 0x02861a82, 0x2c442187, 0x058d450b, 0x9b820820, 0x03840420, 0x09000522, 0x37582d84, 0xbd871809, 0x89178208,
    0x000a2241, 0x2829820a, 0x0001000a, 0x00060003, 0x0c914d0c, 0x4909cd46, 0x23830525, 0x0f000726, 0xfdfffeff, 0x04242f82, 0x81004000, 0x4e223784,
    0x37839b00, 0x0c4dd918, 0x02224d83, 0x17830500, 0x53020021, 0x23880933, 0xba005d22, 0x8408d742, 0x00002924, 0x7dfdffff, 0xe5fff2ff, 0x4209dd77,
    0x2d820b07, 0x038c0020, 0x49182f82, 0xff200805, 0x83095d4d, 0x82ff204c, 0x0000260f, 0xf9fffdff, 0x050f4fff, 0x17830682, 0x9783038e, 0x04000226,
    0x22001100, 0x2941a382, 0x00042205, 0x737f8507, 0xfe200887, 0xff233583, 0x18fafffe, 0x8208ddcf, 0x50138423, 0x65830579, 0x82058554, 0x6100206b,
    0x996205fb, 0xfff32209, 0x24d382f1, 0xfff0fff0, 0x210182ee, 0x854affeb, 0x88fb2005, 0x05774807, 0x0700f82c, 0x08000900, 0x15000b00, 0x01821300,
    0x6f771120, 0x82092008, 0x82082019, 0x05b7481b, 0x494b0520, 0x55f92008, 0x1d820511, 0x8b880d20, 0xe8fff422, 0x7006b54e, 0x00200971, 0x0a3fd718,
    0xfb420020, 0x42e18507, 0x10830aeb, 0x089d4f18, 0x20089f42, 0x0adf42fe, 0x1185eb85, 0x4418fd20, 0x49180865, 0x4418088d, 0x23440e87, 0x22d18208,
    0x44020016, 0x082006a1, 0x0620d586, 0x0722b582, 0x15820600, 0x03840520, 0x2005b142, 0x08474903, 0xb36f0220, 0x22de830c, 0x84010000, 0x43058306,
    0x1284091f, 0x01262b82, 0x0a000400, 0x0e821400, 0xbb840120, 0xf1fff922, 0xfc200782, 0x00200f82, 0x04205f82, 0x0d206d82, 0x03202582, 0xfe20a384,
    0x08f1a118, 0x260d9f43, 0xffe9fff5, 0x82f7ffee, 0x08a54f01, 0x430bad44, 0x334d1697, 0x82002005, 0x000622cb, 0x2001820b, 0x83e18207, 0x820a20d7,
    0x0011248f, 0x82130009, 0x53022099, 0x48820c73, 0x33410287, 0xb94f1808, 0x82022007, 0x652d8347, 0x03200521, 0x57183b82, 0x37870c49, 0x9d860785,
    0x65820520, 0x01000323, 0x0e2b4400, 0xfffdff23, 0x203f82fb, 0x20078206, 0x200382fa, 0x850f84fb, 0x20058538, 0x83958202, 0x00082209, 0x20068211,
    0x08c96d02, 0x974bfc20, 0xfeff2105, 0x81583984, 0x840b8205, 0xfffd221f, 0x064951f9, 0xfcfffc22, 0xb7200984, 0xff201784, 0x42098743, 0x37820c07,
    0x0af95118, 0x1805c746, 0x2009719b, 0x20b38402, 0x08716004, 0x63880320, 0xfd20b183, 0x43464988, 0x0ec15d08, 0xf5840120, 0x14000a22, 0x35064744,
    0xffdbff07, 0x006b02ff, 0x007700bc, 0x00970087, 0x00c700b3, 0x661800d7, 0x0222eaf9, 0x00830004, 0x06000224, 0x03820300, 0x03830b83, 0x02000126,
    0x0d001200, 0x0a210182, 0x05575500, 0x07a1b018, 0x19820420, 0x22830320, 0xff210383, 0xdd6318fe, 0x07d56e0a, 0xf0fff722, 0xe9200182, 0x0bd54518,
    0xfa202582, 0x22094d42, 0x8300ffff, 0xfff0222b, 0x200184f6, 0xa74518fd, 0x55022008, 0x04230a8b, 0x61000c00, 0x132205ab, 0x87820e00, 0x72827783,
    0xfffeff29, 0xfff2fffc, 0x82edfff3, 0x82f12005, 0x84f42003, 0xfffd2283, 0x210782fb, 0x6d4600fb, 0x00092205, 0x20498208, 0x200d8200, 0x20008400,
    0x86c38205, 0xfdfd2211, 0x22008300, 0x821a000e, 0x831a2055, 0x8203830a, 0x83e5204f, 0x200b8203, 0x24038276, 0x00080000, 0x20038212, 0x820b8411,
    0xf8ff2704, 0xf7ffefff, 0x0a82efff, 0x03824120, 0x1700002a, 0x37002e00, 0x14001500, 0x2d240182, 0x20002100, 0x7b824d82, 0x82feff21, 0xfff32201,
    0x220182e3, 0x82e9ffd9, 0xfff02633, 0xffe6ffc0, 0x218a82cb, 0xc144004c, 0x43032005, 0xff210543, 0x22c984fd, 0x82fafffc, 0x203583cf, 0x05cb4ffe,
    0x84dffd21, 0x0013225f, 0x20598228, 0x267f8827, 0xffd8ffed, 0x82d9ffec, 0x9e26200f, 0x41b720bf, 0xff200c9f, 0xfc205d82, 0x6906c145, 0xf4240573,
    0xf6fff9ff, 0xf820cb82, 0x9f608182, 0x069f4108, 0x9f410f86, 0x282f8506, 0xffedfff9, 0xfff5fff4, 0x181584fb, 0x8408d393, 0x84002085, 0x0003226b,
    0x4a0d8201, 0x05220581, 0xdf820800, 0x200f7760, 0x20eb8203, 0x227382fd, 0x82fdfffc, 0x0005221d, 0x2501820e, 0x00070013, 0xdf520006, 0x820f2005,
    0x0004220f, 0x83858203, 0x82638225, 0x84042057, 0x82012003, 0x20258305, 0x51c38405, 0x00280d6d, 0x01000100, 0x0400f4ff, 0x80824982, 0x41820283,
    0x5418d783, 0x5382084f, 0x1c00be24, 0x1b833800, 0xff230383, 0x82c8ffe4, 0x83c72003, 0x2003840b, 0x881b821d, 0x8263831f, 0x22f18341, 0x45e5ffee,
    0xff280701, 0xffedffe8, 0xfff8ffee, 0x086f4a18, 0x82ffff21, 0x82482053, 0x5ffe205b, 0xfd200825, 0x74181d82, 0x978209f9, 0x0626e782, 0x08000800,
    0x9f8cf6ff, 0xf9fffc23, 0x062d45ff, 0x04227f84, 0x1f8cbeff, 0x6782fd20, 0x1b840382, 0x04200483, 0x2a084346, 0xaac8f800, 0x3c0f5f0e, 0x830b00f5,
    0x00002514, 0x06fe2ce0, 0x07841d82, 0xff74fe27, 0x01bc03fe, 0x220f8276, 0x46020007, 0x032d09f7, 0x0029ff1f, 0xfe3e0266, 0x0382fe74, 0x821786bc,
    0x22028624, 0x861f0221, 0x2b068209, 0x00001401, 0xfefe3e02, 0x68ff3e02, 0x74200782, 0xfc200782, 0x27200382, 0x6b240382, 0x39003e02, 0x02200782,
    0xf3201782, 0x1a200b82, 0x9b200782, 0x29200f82, 0x36200b82, 0x9d200782, 0x46200782, 0xf7201382, 0xf2200382, 0x17200f82, 0xb0200782, 0x55200782,
    0x5f200382, 0x0b200382, 0xa6201f82, 0xd8200382, 0xe2200382, 0x70200382, 0xa3201382, 0x4c200382, 0xdb200382, 0x03827a83, 0x9d900e20, 0x028d1482,
    0x08053808, 0xe80e0000, 0x80150000, 0x641b0000, 0x9c240000, 0x882a0000, 0x702f0000, 0x6c3b0000, 0x5c440000, 0xb8480000, 0x30530000, 0xa45d0000,
    0x8c640000, 0xb46d0000, 0x82730000, 0x287b2c46, 0xcc890000, 0x94970000, 0x82a20000, 0x48b02407, 0x82b50000, 0x58be2843, 0xd0c20000, 0x82c80000,
    0x82ca201f, 0x20d12d33, 0xdcd80000, 0x24e20000, 0xc8e60000, 0x21239384, 0x8200e802, 0x00002179, 0x1222a194, 0x1788de00, 0x23881b20, 0x06000124,
    0x17861b00, 0x07000224, 0x0b862100, 0x17820320, 0x0b862820, 0x0b820420, 0x0b862e20, 0x0b000524, 0x0b863400, 0x17820620, 0x0b863f20, 0x45820d20,
    0x0b864520, 0x1a000e2a, 0x03006000, 0x09040100, 0x36226782, 0x0b867a00, 0x0c000124, 0x0b86b000, 0x0e000224, 0x0b86bc00, 0x17820320, 0x0b86ca20,
    0x0b820420, 0x0b86d620, 0x16000524, 0x0b86e200, 0x17820620, 0x0b86f820, 0x36000d24, 0x0b860401, 0x000e2c08, 0x533a0134, 0x4f204c49, 0x206e6570,
    0x746e6f46, 0x63694c20, 0x65736e65, 0x464f2820, 0x6447294c, 0x66646766, 0x75676552, 0x8572616c, 0x2a05850c, 0x73726556, 0x206e6f69, 0x85302e31,
    0x36449a10, 0x70747468, 0x732f2f3a, 0x70697263, 0x732e7374, 0x6f2e6c69, 0x822f6772, 0x53002f5f, 0x4c004900, 0x4f002000, 0x65007000, 0x09826e00,
    0x6f004622, 0x74200782, 0x4c240982, 0x63006900, 0x73201584, 0x20220582, 0x25822800, 0x2d824620, 0x47002928, 0x66006400, 0x05846700, 0x1b825220,
    0x75006728, 0x61006c00, 0x198c7200, 0x5620258b, 0x72222582, 0x51827300, 0x65846f20, 0x2e003124, 0x2d8c3000, 0x682289b5, 0x01827400, 0x3a007024,
    0x01822f00, 0xaf827320, 0x63827220, 0x13827020, 0x61827320, 0x6c206f83, 0x6f200782, 0x67209982, 0x4f211f82, 0x21bf8300, 0x00840002, 0x009aff23,
    0x8f088423, 0x82212004, 0x00012c10, 0x00030002, 0x00250024, 0x82270026, 0x00292af9, 0x002b002a, 0x002d002c, 0x3247822e, 0x00310030, 0x00330032,
    0x00350034, 0x00370036, 0x82390038, 0x003b2a81, 0x003d003c, 0x00450044, 0x39fa0546, 0x00be9dc0,
};
```

`sakura/source/gui/gui.cpp`:

```cpp
#include "../client.h"
#include "../fonts/icons.h"
#include "../fonts/weapons.h"
#include "../fonts/font.h"

HWND hGameWnd;
WNDPROC hGameWndProc;
LRESULT ImGui_ImplWin32_WndProcHandler(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

LRESULT CALLBACK HOOK_WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	if (bShowMenu || popoup)
		ImGui_ImplWin32_WndProcHandler(hWnd, uMsg, wParam, lParam);

	return CallWindowProc(hGameWndProc, hWnd, uMsg, wParam, lParam);
}

bool bOldOpenGL = true; 
GLint iMajor, iMinor;
bool bInitializeImGui = false;
void InistalizeImgui(HDC hdc)
{
	if (!bInitializeImGui)
	{
		hGameWnd = WindowFromDC(hdc);
		hGameWndProc = (WNDPROC)SetWindowLong(hGameWnd, GWL_WNDPROC, (LONG)HOOK_WndProc);
		glGetIntegerv(GL_MAJOR_VERSION, &iMajor);
		glGetIntegerv(GL_MINOR_VERSION, &iMinor);
		if ((iMajor * 10 + iMinor) >= 32)
			bOldOpenGL = false;
		ImGui::CreateContext();
		ImGui_ImplWin32_Init(hGameWnd);
		if (!bOldOpenGL)
		{
			ImplementGl3();
			ImGui_ImplOpenGL3_Init();
		}
		else
			ImGui_ImplOpenGL2_Init();

		ImGui::StyleColorsDark();
		ImGui::GetStyle().AntiAliasedFill = !bOldOpenGL ? true : false;
		ImGui::GetStyle().AntiAliasedLines = !bOldOpenGL ? true : false;
		ImGui::GetStyle().FrameRounding = 4.0f;
		ImGui::GetStyle().WindowRounding = 6.0f;
		ImGui::GetStyle().ChildRounding = 6.0f;
		ImGui::GetStyle().PopupRounding = 6.0f;
		ImGui::GetStyle().ScrollbarRounding = 0.0f;
		ImGui::GetStyle().GrabRounding = 0.0f;
		ImGui::GetStyle().FramePadding = ImVec2(4, 3);
		ImGui::GetStyle().WindowPadding = ImVec2(5, 5);
		ImGui::GetStyle().WindowBorderSize = 0.0f;
		ImGui::GetStyle().FrameBorderSize = 0.0f;
		ImGui::GetStyle().PopupBorderSize = 1.0f; 
		ImGui::GetStyle().WindowMinSize = ImVec2(10, 10);
		ImGui::GetStyle().ItemSpacing = ImVec2(7, 4);
		ImGui::GetStyle().ItemInnerSpacing = ImVec2(6, 6);
		ImGui::GetStyle().ScrollbarSize = 8.0f;
		ImGui::GetIO().IniFilename = NULL;
		ImGui::GetIO().LogFilename = NULL;

        ImVec4* colors = ImGui::GetStyle().Colors;
        colors[ImGuiCol_ChildBg] = ImVec4(0.00f, 0.00f, 0.00f, 0.00);
        colors[ImGuiCol_FrameBg] = ImVec4(0.31f, 0.31f, 0.31f, 0.63f);
        colors[ImGuiCol_Header] = ImVec4(0.33f, 0.33f, 0.33f, 0.39f);
        colors[ImGuiCol_HeaderHovered] = ImVec4(0.97f, 0.19f, 0.98f, 0.80f);
        colors[ImGuiCol_HeaderActive] = ImVec4(0.97f, 0.19f, 0.98f, 1.00f);
        colors[ImGuiCol_PopupBg] = ImVec4(0.11f, 0.12f, 0.14f, 1.00f);

		ImFontConfig config;
		config.MergeMode = true;
		ImGui::GetIO().Fonts->AddFontDefault();
        ImGui::GetIO().Fonts->AddFontFromMemoryCompressedTTF(Droid_compressed_data, Droid_compressed_size, 12.f, nullptr, ImGui::GetIO().Fonts->GetGlyphRangesCyrillic());
        Sakura::Menu::Fonts::weaponsFont = ImGui::GetIO().Fonts->AddFontFromMemoryCompressedTTF(compressedWeaponsData, compressedWeaponsSize, 55.f, nullptr, ImGui::GetIO().Fonts->GetGlyphRangesCyrillic());
        Sakura::Menu::Fonts::icons = ImGui::GetIO().Fonts->AddFontFromMemoryCompressedTTF(compressedIconsData, compressedIconsSize, 22.f, nullptr, ImGui::GetIO().Fonts->GetGlyphRangesCyrillic());
        Sakura::Menu::Fonts::titleTabFont = ImGui::GetIO().Fonts->AddFontFromMemoryCompressedTTF(Droid_compressed_data, Droid_compressed_size, 14.f, nullptr, ImGui::GetIO().Fonts->GetGlyphRangesCyrillic());
        Sakura::Menu::Fonts::titleCheatFont = ImGui::GetIO().Fonts->AddFontFromMemoryCompressedTTF(Droid_compressed_data, Droid_compressed_size, 20.f, nullptr, ImGui::GetIO().Fonts->GetGlyphRangesCyrillic());
        Sakura::Menu::Fonts::defaultFont = ImGui::GetIO().Fonts->AddFontFromMemoryCompressedTTF(Droid_compressed_data, Droid_compressed_size, 12.f, nullptr, ImGui::GetIO().Fonts->GetGlyphRangesCyrillic());
		ImGui::GetIO().Fonts->Build();

		if (cvar.gui_key < 0 || cvar.gui_key > 254)
			cvar.gui_key = K_INS;

		bInitializeImGui = true;
	}
	static ImVec2 screensize = ImGui::GetIO().DisplaySize;
	if (screensize.x != ImGui::GetIO().DisplaySize.x || screensize.y != ImGui::GetIO().DisplaySize.y)
	{
		//ImGui::GetStyle().WindowMaxSize = ImGui::GetIO().DisplaySize;
		screensize = ImGui::GetIO().DisplaySize;
	}
}

bool checkdrawscreen()
{
    bool checkdrawhud = Sakura::ScreenShot::IsDrawing();
	static bool drawhud = checkdrawhud;
	if (drawhud != checkdrawhud)
	{
		drawhud = checkdrawhud;
		return true;
	}
	return false;
}

bool checkmenu()
{
	static bool checkmenu = bShowMenu;
	if (checkmenu != bShowMenu)
	{
		checkmenu = bShowMenu;
		return true;
	}
	return false;
}

void MenuHandle()
{
    if (checkdrawscreen())
    {
        if (bShowMenu)
        {
            if (Sakura::ScreenShot::IsDrawing())
            {
                ImGui::GetIO().MouseDrawCursor = true;

                if (bShowMenu)
                    changewindowfocus = true;
            }
            else
                ImGui::GetIO().MouseDrawCursor = false;
        }
    }
    if (checkmenu())
    {
        if (bShowMenu)
        {
            ImGui::GetIO().MouseDrawCursor = true;
            g_Client.IN_DeactivateMouse();

            if (bShowMenu)
                changewindowfocus = true;
        }
        else
        {
            SetCursorPos(g_Engine.GetWindowCenterX(), g_Engine.GetWindowCenterY());
            ImGui::GetIO().MouseDrawCursor = false;
            g_Client.IN_ActivateMouse();
        }
    }

    if ((bShowMenu) && ::GetActiveWindow() == hGameWnd)
    {
        POINT ppt;
        if (GetCursorPos(&ppt))
        {
            if (ppt.x == g_Engine.GetWindowCenterX() && ppt.y == g_Engine.GetWindowCenterY())
                g_Client.IN_DeactivateMouse();
        }
    }
}

void ClearHudKeys()
{
	for (size_t i = 0; i < 256; ++i)
	{
		if (keysmenu[i] == true)
			keysmenu[i] = false;
	}
}

void ClearSound()
{
	if (Sound_No_Index.size() && GetTickCount() - Sound_No_Index.front().timestamp > 900)
		Sound_No_Index.pop_front();

	if (Sound_Index.size() && GetTickCount() - Sound_Index.front().timestamp > 900)
		Sound_Index.pop_front();
}

void HookImGui(HDC hdc)
{
	ColorChange();
	ClearSound();
	InistalizeImgui(hdc);

	if (!bOldOpenGL)
		ImGui_ImplOpenGL3_NewFrame();
	else
		ImGui_ImplOpenGL2_NewFrame();

	ImGui_ImplWin32_NewFrame();
	ImGui::NewFrame();
	if (Sakura::ScreenShot::IsVisuals())
	{
		DrawFullScreenWindow();
		DrawOverview();
		DrawKzWindows();

		for (size_t i = 0; i < Sakura::Lua::scripts.size(); ++i)
		{
			auto& script = Sakura::Lua::scripts[i];

			if (!script.HasCallback(Sakura::Lua::SAKURA_CALLBACK_TYPE::SAKURA_CALLBACK_AT_RENDERING_WINDOW))
				continue;

			auto& callbacks = script.GetCallbacks(Sakura::Lua::SAKURA_CALLBACK_TYPE::SAKURA_CALLBACK_AT_RENDERING_WINDOW);
			for (const auto& callback : callbacks)
			{
				try
				{
					callback();
				}
				catch (luabridge::LuaException const& error)
				{
					if (script.GetState())
					{
						Sakura::Lua::Error("Error has occured in the lua \"On Window Render\" script: %s", error.what());
						script.RemoveAllCallbacks();
					}
				}
			}
		}

        DrawMenuWindow();
	}
    DrawPopupWindow();

    ImGui::Render();
    if (!bOldOpenGL)
        ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());
    else
        ImGui_ImplOpenGL2_RenderDrawData(ImGui::GetDrawData());

	MenuHandle();
	ClearHudKeys();
}
```

`sakura/source/gui/gui.h`:

```h
#ifndef _IMGUIHOOK_
#define _IMGUIHOOK_

extern bool bInitializeImGui;
extern bool bOldOpenGL;
extern HWND hGameWnd;
extern WNDPROC hGameWndProc;
void HookImGui(HDC hdc); 

#endif
```

`sakura/source/gui/guiwindow.cpp`:

```cpp
#include "../client.h"

bool WorldToScreen(float* pflOrigin, float* pflVecScreen)
{
	int iResult = g_Engine.pTriAPI->WorldToScreen(pflOrigin, pflVecScreen);
	if (pflVecScreen[0] < 1.5f && pflVecScreen[1] < 1.5f && pflVecScreen[0] > -1.5f && pflVecScreen[1] > -1.5f && !iResult)
	{
		pflVecScreen[0] = pflVecScreen[0] * (ImGui::GetIO().DisplaySize.x / 2) + (ImGui::GetIO().DisplaySize.x / 2);
		pflVecScreen[1] = -pflVecScreen[1] * (ImGui::GetIO().DisplaySize.y / 2) + (ImGui::GetIO().DisplaySize.y / 2);
		return true;
	}
	return false;
}

void ScreenToWorld(float* screen, float* world)
{
	screen[0] = (screen[0] - (ImGui::GetIO().DisplaySize.x / 2)) / (ImGui::GetIO().DisplaySize.x / 2);
	screen[1] = -(screen[1] - (ImGui::GetIO().DisplaySize.y / 2)) / (ImGui::GetIO().DisplaySize.y / 2);
	g_Engine.pTriAPI->ScreenToWorld(screen, world);
}

void DrawFullScreenWindow()
{
	ImGui::PushStyleColor(ImGuiCol_WindowBg, ImVec4(0.0f, 0.0f, 0.0f, 0.0f));
	ImGui::PushStyleVar(ImGuiStyleVar_WindowRounding, 0.f);
	ImGui::PushStyleVar(ImGuiStyleVar_WindowBorderSize, 0.f);
	ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, { 0, 0 });
	ImGui::SetNextWindowPos(ImVec2(0, 0), ImGuiCond_Always);
	ImGui::SetNextWindowSize(ImGui::GetIO().DisplaySize, ImGuiCond_Always);
	ImGui::Begin("fullscreen_sakura", reinterpret_cast<bool*>(true), ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoInputs);
	{
		DrawRouteLine();
		Sakura::Esp::World::DrawSkeleton();
		Sakura::Esp::World::Draw();
		Sakura::Esp::DrawSoundNoIndex();
		Sakura::Esp::DrawSoundIndex();
		Sakura::Esp::Player::DrawSkeleton();
		Sakura::Esp::Player::Draw();
		DrawTraceGrenade();
		DrawWeaponName();
		Sakura::Aimbot::Draws();

		for (size_t i = 0; i < Sakura::Lua::scripts.size(); ++i)
		{
			auto& script = Sakura::Lua::scripts[i];

			if (!script.HasCallback(Sakura::Lua::SAKURA_CALLBACK_TYPE::SAKURA_CALLBACK_AT_RENDERING_BACKGROUND))
				continue;

			auto& callbacks = script.GetCallbacks(Sakura::Lua::SAKURA_CALLBACK_TYPE::SAKURA_CALLBACK_AT_RENDERING_BACKGROUND);
			for (const auto& callback : callbacks)
			{
				try
				{
					callback();
				}
				catch (luabridge::LuaException const& error)
				{
					Sakura::Lua::Error("Error has occured in the lua \"On Background Render\" script: %s", error.what());
					script.RemoveAllCallbacks();
				}
			}
		}

		DrawCrossHair();
		Sakura::Scope::Draw();
		Sakura::FOVS::Aimbot();
		Sakura::FOVS::Spread();

		ImGui::PushFont(Sakura::Menu::Fonts::defaultFont);
		Toast::Render();
		ImGui::PopFont();
	}
	ImGui::End();
	ImGui::PopStyleVar(3);
	ImGui::PopStyleColor();
}
```

`sakura/source/gui/guiwindow.h`:

```h
#ifndef _WINDOW_
#define _WINDOW_

void DrawFullScreenWindow();
bool WorldToScreen(float* pflOrigin, float* pflVecScreen);
void ScreenToWorld(float* screen, float* world);

#endif
```

`sakura/source/gui/guiwindowpop.cpp`:

```cpp
#include "../client.h"

bool popoup = true;
void DrawPopupWindow()
{
	static DWORD closewindow = GetTickCount() + 21000;
	if (closewindow < GetTickCount())
		popoup = false;
	
	static bool hidemouse = true;
	if (hidemouse && !popoup)
	{
		if(!bShowMenu)
			ImGui::GetIO().MouseDrawCursor = false;

		hidemouse = false;
	}
	if (GetTickCount() - HudRedraw <= 100)
		popoup = false;
	if (!popoup)
		return;
	
	static bool showmouse = true;

	if (showmouse)
		ImGui::GetIO().MouseDrawCursor = true,

	showmouse = false;

	ImGui::SetNextWindowPos(ImVec2(100, 100), ImGuiCond_Once);
	ImGui::PushStyleColor(ImGuiCol_WindowBg, (ImVec4)Sakura::Menu::GetMenuColor(0.7f));
	if(ImGui::Begin("##noname_d", &popoup, ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoCollapse))
	{
		if (ImGui::IsWindowHovered())
			popoup = false;
		
		ImGui::PushFont(Sakura::Menu::Fonts::titleCheatFont);
		ImGui::Text(" \n    Sakura loaded!     ");
		ImGui::Text(" \n");
		ImGui::PopFont();
	}
	ImGui::PopStyleColor();
	ImGui::End();
}
```

`sakura/source/gui/guiwindowpop.h`:

```h
#ifndef _POP_
#define _POP_

void DrawPopupWindow();
extern bool popoup;

#endif
```

`sakura/source/helpers/anim.cpp`:

```cpp
#include "../client.h"

float Sakura::Animation::QuadEaseInOut(float t, float b, float c, float d)
{
    t /= d / 2;
    if (t < 1) return c / 2 * t * t + b;
    t--;
    return -c / 2 * (t * (t - 2) - 1) + b;
}

void Sakura::Animation::Calculate(double* variable, double &changeTimestamp, double value, double maxValue, double animationTime)
{
	if (variable[current] != value)
	{
		if (changeTimestamp + animationTime >= client_state->time)
			variable[previous] = variable[calculated];

		variable[current] = value;
		changeTimestamp = client_state->time;
	}

	float elapsed_time = static_cast<float>(client_state->time - changeTimestamp);
	float t = elapsed_time / static_cast<float>(animationTime);
	float eased_variable = QuadEaseInOut(t, variable[previous], variable[current] - variable[previous], 1.f);

	if (elapsed_time >= animationTime)
	{
		variable[calculated] = variable[current];
		variable[previous] = variable[current];
	}
	else
	{
		variable[calculated] = eased_variable;
	}

	if (variable[calculated] > maxValue)
		variable[calculated] = maxValue;
}
```

`sakura/source/helpers/anim.h`:

```h
#ifndef _ANIM_
#define _ANIM_

namespace Sakura
{
	namespace Animation
	{
		enum { 
			previous, 
			current, 
			calculated, 
			max_count 
		};

		float QuadEaseInOut(float t, float b, float c, float d);
		void Calculate(double* variable, double &changeTimestamp, double value, double maxValue, double animationTime = 1.0);
	};
};

#endif
```

`sakura/source/helpers/color.cpp`:

```cpp
#include "../client.h"

float color_red		= 1.f;
float color_green	= 0.f;
float color_blue	= 1.f;

ImColor Sakura::Colors::Red()		{ return ImColor(1.f, 0.f, 0.f, 1.f); }
ImColor Sakura::Colors::Blue()		{ return ImColor(0.f, 0.f, 1.f, 1.f); }
ImColor Sakura::Colors::White()		{ return ImColor(1.f, 1.f, 1.f, 1.f); }
ImColor Sakura::Colors::Green()		{ return ImColor(0.f, 1.f, 0.f, 1.f); }
ImColor Sakura::Colors::Black()		{ return ImColor(0.f, 0.f, 0.f, 1.f); }
ImColor Sakura::Colors::Rainbow()	{ return ImColor(color_red, color_green, color_blue, 1.f); }

ImRGBA Sakura::Colors::GetTeamColor(int playerIndex) {
	if (g_Player[playerIndex].iTeam == TEAM_TT)
		return ImRGBA(1.f, 0.f, 0.f, 1.f);

	if (g_Player[playerIndex].iTeam == TEAM_CT)
		return ImRGBA(0.f, 0.f, 1.f, 1.f);

	return ImRGBA(1.f, 1.f, 1.f, 1.f);
}

ImRGBA Sakura::Colors::GetCustomizedTeamColor(int playerIndex, float colorCvarTT[4], float colorCvarCT[4], bool checkRainbowTT, bool checkRainbowCT)
{
	if (g_Player[playerIndex].iTeam == TEAM_TT)
	{
		if (checkRainbowTT)
			return ImRGBA(color_red, color_green, color_blue, colorCvarTT[3]);

		return ImRGBA(colorCvarTT[0], colorCvarTT[1], colorCvarTT[2], colorCvarTT[3]);
	}

	if (g_Player[playerIndex].iTeam == TEAM_CT)
	{
		if (checkRainbowCT)
			return ImRGBA(color_red, color_green, color_blue, colorCvarCT[3]);

		return ImRGBA(colorCvarCT[0], colorCvarCT[1], colorCvarCT[2], colorCvarCT[3]);
	}

	return ImRGBA(1.f, 1.f, 1.f, 1.f);
}

ImRGBA Sakura::Colors::GetCustomizedColor(float color[4], bool rainbowColor)
{
	if (rainbowColor)
		return ImRGBA(color_red, color_green, color_blue, color[3]);

	return ImRGBA(color[0], color[1], color[2], color[3]);
}

void ColorChange()
{
	static float Color[3];
	static DWORD Tickcount = 0;
	ImGui::ColorConvertRGBtoHSV(color_red, color_green, color_blue, Color[0], Color[1], Color[2]);
	if (GetTickCount() - Tickcount > 0)
	{
		Color[0] += 0.002f;
		Tickcount = GetTickCount();
	}
	if (Color[0] < 0.0f) Color[0] += 1.0f;
	ImGui::ColorConvertHSVtoRGB(Color[0], Color[1], Color[2], color_red, color_green, color_blue);
}
```

`sakura/source/helpers/color.h`:

```h
#ifndef _COLOR_
#define _COLOR_

struct ImRGBA
{
	float r, g, b, a;
	ImRGBA() { r = g = b = a = 1.f; }
	ImRGBA(float _r, float _g, float _b, float _a) { r = _r; g = _g; b = _b; a = _a; }
};

extern float color_red;
extern float color_green;
extern float color_blue;

namespace Sakura
{
	namespace Colors
	{
		ImColor Red();
		ImColor Blue();
		ImColor White();
		ImColor Green();
		ImColor Black();
		ImColor Rainbow();
		ImRGBA GetTeamColor(int playerIndex);
		ImRGBA GetCustomizedTeamColor(int playerIndex, float colorCvarTT[4], float colorCvarCT[4], bool checkRainbowTT = false, bool checkRainbowCT = false);
		ImRGBA GetCustomizedColor(float color[4], bool rainbowColor = false);
	};
};

void ColorChange();

#endif
```

`sakura/source/helpers/log.cpp`:

```cpp
#include "../client.h"

void Sakura::Log::File(const char* text, ...)
{
	va_list		va_alist;
	char		buf[256];
	char		logbuf[1024];
	char		cDirectory[600];
	FILE* file;
	struct tm* current_tm;
	time_t		current_time;

	time(&current_time);
	current_tm = localtime(&current_time);
	sprintf(logbuf, "[%02d-%02d-%02d %02d:%02d:%02d] ",
		current_tm->tm_mday, current_tm->tm_mon + 1, current_tm->tm_year + 1900,
		current_tm->tm_hour, current_tm->tm_min, current_tm->tm_sec);
	va_start(va_alist, text);
	vsprintf(buf, text, va_alist);
	va_end(va_alist);

	strcat(logbuf, buf);
	strcat(logbuf, "\n");
	strcpy(cDirectory, Sakura::CheatDir);
	strcat(cDirectory, "sakura.log");

	if ((file = fopen(cDirectory, "a+")) != NULL)
	{
		fputs(logbuf, file);
		fclose(file);
	}
}

void Sakura::Log::Console(const char* text, ...)
{
	va_list va_alist;
	char buf[256];

	va_start(va_alist, text);
	vsprintf(buf, text, va_alist);
	va_end(va_alist);

	sprintf(buf, "%s%s", buf, "\n");

	g_Engine.Con_DPrintf(buf);
}

void Sakura::Lua::Error(const char* errorMsg, ...)
{
	va_list va_alist;
	char buf[256];

	va_start(va_alist, errorMsg);
	vsprintf(buf, errorMsg, va_alist);
	va_end(va_alist);

	Sakura::Log::File(buf);

	float isInDeveloperMode = g_Engine.pfnGetCvarFloat("developer");

	if (isInDeveloperMode)
		Sakura::Log::Console(buf);
}
```

`sakura/source/helpers/log.h`:

```h
#ifndef _LOG_
#define _LOG_

namespace Sakura
{
	namespace Lua
	{
		void Error(const char* errorMsg, ...);
	};

	namespace Log
	{
		void File(const char* text, ...);
		void Console(const char* text, ...);
	};
};

#endif
```

`sakura/source/helpers/stringfinder.cpp`:

```cpp
#include "../client.h"

typedef std::map<std::string, int, std::less<std::string> > MapStringInt;

struct Private_Data
{
	MapStringInt theMap;
	MapStringInt::iterator pos;

};
#define THE_MAP ( (*((Private_Data*)data)).theMap)
#define THE_POS ( (*((Private_Data*)data)).pos)

StringFinder::StringFinder()
{
	data = new Private_Data;
}

StringFinder::~StringFinder()
{
	delete (Private_Data*)data;
}

void StringFinder::clear()
{
	THE_MAP.clear();
}

void StringFinder::add(const char* str, int num)
{
	if(!str || !*str){ return;}
    typedef MapStringInt::value_type Entry;
    THE_MAP.insert(Entry(str,num));
}

void StringFinder::erase( const char* str )
{
	MapStringInt::iterator foundPos = THE_MAP.find( std::string(str) );
	if(foundPos!=THE_MAP.end()) 
	{ 
	    THE_MAP.erase(foundPos);
	}
}

bool StringFinder::find(const char* str)
{
	if(!str || !*str){ return false; }

	MapStringInt::iterator foundPos = THE_MAP.find(std::string(str) );
	
	if(foundPos==THE_MAP.end()) 
	{ 
		return false;  
	}
	else 
	{
		num = (*foundPos).second;
		return true; 
	}
}

void StringFinder::it_start()
{
	THE_POS = THE_MAP.begin();
	num = (int)THE_POS->second;
	str = THE_POS->first.c_str();
}

bool StringFinder::it_running()
{
	return (THE_POS!=THE_MAP.end());
}

void StringFinder::it_next()
{
	++THE_POS;
	if (THE_POS == THE_MAP.end())
		return;
	num = THE_POS->second;
	str = THE_POS->first.c_str();
}
```

`sakura/source/helpers/stringfinder.h`:

```h
#ifndef _STRINGFINDER_
#define _STRINGFINDER_
//==========================================
class StringFinder
{
public:
	void clear();
	void add(const char* the_string, int the_number);
	void erase( const char* str );

	
	bool find(const char* str);
	int          num;
	const char*  str;

	// iteration. use with for(;;)
	void it_start  ();
	bool it_running();
	void it_next   ();

private:
	void* data;

public:
	StringFinder();
	~StringFinder();
};
#endif
```

`sakura/source/helpers/strings.cpp`:

```cpp
#include "../client.h"

std::string Sakura::Strings::getfilename(std::string path)
{
	path = path.substr(path.find_last_of("/\\") + 1);
	size_t dot_i = path.find_last_of('.');
	return path.substr(0, dot_i);
}

std::string Sakura::Strings::strip(std::string path)
{
	size_t dot = path.find("models/");
	path.erase(path.begin(), path.begin() + dot + 1);
	return path;
}
```

`sakura/source/helpers/strings.h`:

```h
#pragma once

namespace Sakura
{
	namespace Strings
	{
		std::string getfilename(std::string path);
		std::string strip(std::string path);
	};
};
```

`sakura/source/helpers/textures.cpp`:

```cpp
#include "../client.h"

int Sakura::Texture::gcTextures = 0;
char Sakura::Texture::grgszTextureName[CTEXTURESMAX][CBTEXTURENAMEMAX];
char Sakura::Texture::grgchTextureType[CTEXTURESMAX];
GLuint Sakura::Texture::texture_id[2048];

void Sakura::Texture::Load(char* image, int index)
{
	char filename[256];
	int width, height;
	sprintf(filename, "%s%s", Sakura::CheatDir, image);

	GLint last_texture;
	glGetIntegerv(GL_TEXTURE_BINDING_2D, &last_texture);

	if (Sakura::Texture::texture_id[index])
		glDeleteTextures(1, &Sakura::Texture::texture_id[index]);

	GLuint glindex;
	glGenTextures(1, &glindex);

	Sakura::Texture::texture_id[index] = glindex + 20000;
	glBindTexture(GL_TEXTURE_2D, Sakura::Texture::texture_id[index]);

	unsigned char* soilimage = SOIL_load_image(filename, &width, &height, 0, SOIL_LOAD_RGBA);

	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, soilimage);
	SOIL_free_image_data(soilimage);
	glBindTexture(GL_TEXTURE_2D, last_texture);
}

char Sakura::Texture::PM_FindTextureType(char *name)
{
	int left, right, pivot;
	int val;

	left = 0;
	right = gcTextures - 1;

	while (left <= right)
	{
		pivot = (left + right) / 2;

		val = _strnicmp(name, grgszTextureName[pivot], CBTEXTURENAMEMAX - 1);
		if (val == 0)
		{
			return grgchTextureType[pivot];
		}
		else if (val > 0)
		{
			left = pivot + 1;
		}
		else if (val < 0)
		{
			right = pivot - 1;
		}
	}

	return CHAR_TEX_CONCRETE;
}

char Sakura::Texture::GetTextureType(pmtrace_t *tr, float *vecSrc, float *vecEnd)
{
	char chTextureType;
	const char *pTextureName;
	char szbuffer[64];
	int pEntity = g_Engine.pEventAPI->EV_IndexFromTrace(tr);

	if (pEntity > 0 && pEntity <= g_Engine.GetMaxClients())
		return CHAR_TEX_FLESH;

	if (pEntity == 0) 
	{
		pTextureName = (char *)g_Engine.pEventAPI->EV_TraceTexture(tr->ent, vecSrc, vecEnd);
		if (pTextureName)
		{
			if (*pTextureName == '-' || *pTextureName == '+')
				pTextureName += 2;

			if (*pTextureName == '{' || *pTextureName == '!' || *pTextureName == '~' || *pTextureName == ' ')
				pTextureName++;

			strcpy(szbuffer, pTextureName);
			szbuffer[16] = '\0';
			chTextureType = PM_FindTextureType(szbuffer);
		}
		else
			chTextureType = '\0';
	}
	else
		chTextureType = '\0';

	return chTextureType;
}

void Sakura::Texture::PM_SwapTextures(int i, int j)
{
	char chTemp;
	char szTemp[CBTEXTURENAMEMAX];

	strcpy(szTemp, grgszTextureName[i]);
	chTemp = grgchTextureType[i];

	strcpy(grgszTextureName[i], grgszTextureName[j]);
	grgchTextureType[i] = grgchTextureType[j];

	strcpy(grgszTextureName[j], szTemp);
	grgchTextureType[j] = chTemp;
}

void Sakura::Texture::PM_SortTextures()
{
	// Bubble sort, yuck, but this only occurs at startup and it's only 512 elements...
	int i, j;

	for (i = 0; i < gcTextures; ++i)
	{
		for (j = i + 1; j < gcTextures; ++j)
		{
			if (_stricmp(grgszTextureName[i], grgszTextureName[j]) > 0)
			{
				// Swap
				PM_SwapTextures(i, j);
			}
		}
	}
}

void Sakura::Texture::PM_InitTextureTypes(struct playermove_s *ppmove)
{
	char buffer[512];
	int i, j;
	byte *pMemFile;
	int fileSize, filePos = 0;
	static bool bTextureTypeInit = false;

	if (bTextureTypeInit)
		return;

	memset(&(grgszTextureName[0][0]), 0, sizeof(grgszTextureName));
	memset(grgchTextureType, 0, sizeof(grgchTextureType));

	gcTextures = 0;
	memset(buffer, 0, sizeof(buffer));

	pMemFile = ppmove->COM_LoadFile("sound/materials.txt", 5, &fileSize);
	if (!pMemFile)
		return;

	// for each line in the file...
	while (ppmove->memfgets(pMemFile, fileSize, &filePos, buffer, sizeof(buffer) - 1) && (gcTextures < CTEXTURESMAX))
	{
		// skip whitespace
		i = 0;
		while (buffer[i] && isspace(buffer[i]))
			++i;

		if (!buffer[i])
			continue;

		// skip comment lines
		if (buffer[i] == '/' || !isalpha(buffer[i]))
			continue;

		// get texture type
		grgchTextureType[gcTextures] = toupper(buffer[i++]);

		// skip whitespace
		while (buffer[i] && isspace(buffer[i]))
			++i;

		if (!buffer[i])
			continue;

		// get sentence name
		j = i;
		while (buffer[j] && !isspace(buffer[j]))
			j++;

		if (!buffer[j])
			continue;

		// null-terminate name and save in sentences array
		j = min(j, CBTEXTURENAMEMAX - 1 + i);
		buffer[j] = '\0';

		strcpy(&(grgszTextureName[gcTextures++][0]), &(buffer[i]));
	}

	// Must use engine to free since we are in a .dll
	ppmove->COM_FreeFile(pMemFile);

	PM_SortTextures();
	bTextureTypeInit = true;
}
```

`sakura/source/helpers/textures.h`:

```h
#ifndef _TEXTURES_
#define _TEXTURES_

#define CTEXTURESMAX		512			// max number of textures loaded
#define CBTEXTURENAMEMAX	13			// only load first n chars of name

#define CHAR_TEX_CONCRETE	'C'			// texture types
#define CHAR_TEX_METAL		'M'
#define CHAR_TEX_DIRT		'D'
#define CHAR_TEX_VENT		'V'
#define CHAR_TEX_GRATE		'G'
#define CHAR_TEX_TILE		'T'
#define CHAR_TEX_SLOSH		'S'
#define CHAR_TEX_WOOD		'W'
#define CHAR_TEX_COMPUTER	'P'
#define CHAR_TEX_GLASS		'Y'
#define CHAR_TEX_FLESH		'F'

namespace Sakura
{
	namespace Texture
	{
		extern int gcTextures;
		extern char grgszTextureName[CTEXTURESMAX][CBTEXTURENAMEMAX];
		extern char grgchTextureType[CTEXTURESMAX];
		extern GLuint texture_id[2048];

		void Load(char* image, int index);
		void PM_SwapTextures(int i, int j);
		void PM_SortTextures();
		void PM_InitTextureTypes(playermove_s *ppmove);
		char PM_FindTextureType(char* name);
		char GetTextureType(pmtrace_t* tr, float* vecSrc, float* vecEnd);
	};
};

#endif
```

`sakura/source/helpers/trace.cpp`:

```cpp
#include "../client.h"

mleaf_t* GetLeafFromPoint(float* point)
{
	cl_entity_s* entity = g_Engine.GetEntityByIndex(0);
	if (!entity || !entity->model)
		return nullptr;

	mnode_t* node = entity->model->nodes;
	while (node)
	{
		if (node->contents < 0)
			return (mleaf_t*)node;

		mplane_t* plane = node->plane;
		float distance = DotProduct(point, plane->normal) - plane->dist;

		if (distance > 0)
			node = node->children[0];
		else
			node = node->children[1];
	}

	return nullptr;
}

void TraceThickness(float* start, float* end, const float thickness, strace_t* tr)
{
	const mleaf_t* startleaf; 
	const mleaf_t* endleaf;
	const mleaf_t* prevleaf;
	int numsteps, count = 0;
	float move[3], step[3], position[3];
	float stepdist, depth = 0;

	memset(tr, 0, sizeof(strace_t));

	if ((start[0] < -4095) || (start[0] > 4095) || (start[1] < -4095) || (start[1] > 4095) || (start[2] < -4095) || (start[2] > 4095))
	{
		tr->hitsky = true;
		tr->startsolid = true;
		tr->finished = false;
		tr->fraction = 0.0;
		return;
	}

	startleaf = GetLeafFromPoint(start);
	endleaf = GetLeafFromPoint(end);

	if (startleaf->contents == CONTENTS_SOLID)
	{
		tr->startsolid = true;
		VectorCopy(start, tr->endpos);
		tr->finished = false;

		if (endleaf->contents == CONTENTS_SOLID)
			tr->allsolid = true;
	}
	else
	{
		tr->startsolid = false;
		tr->allsolid = false;
	}

	VectorSubtract(end, start, move);
	tr->dist = (float)VectorLength(move);

	if (tr->startsolid)
		return;

	if (startleaf == endleaf)
	{
		tr->finished = true;
		tr->fraction = 1.0;
		VectorCopy(end, tr->endpos);
	}

	if (tr->dist > 1.0)
		numsteps = (int)tr->dist;
	else
		numsteps = 1;

	VectorScale(move, 1.0f / (float)numsteps, step);
	stepdist = (float)VectorLength(step);
	VectorCopy(start, position);
	endleaf = NULL;

	for (; numsteps; numsteps--)
	{
		VectorAdd(position, step, position);
		prevleaf = endleaf;
		endleaf = GetLeafFromPoint(position);

		if (prevleaf != endleaf && endleaf->contents == CONTENTS_SOLID)
			count++;

		if (count == 1 && endleaf->contents == CONTENTS_SOLID)
			depth += stepdist;

		if (endleaf->contents == CONTENTS_SKY)
			tr->hitsky = true;

		if (count > 1 || depth > thickness || tr->hitsky)
		{
			VectorCopy(position, tr->endpos);
			VectorSubtract(position, start, move);
			tr->fraction = (float)VectorLength(move) / tr->dist;
			tr->finished = false;
			return;
		}
	}

	if (numsteps == 0)
	{
		tr->finished = true;
		tr->fraction = 1.0;
		VectorCopy(end, tr->endpos);
	}
}
```

`sakura/source/helpers/trace.h`:

```h
#ifndef _TRACE_
#define _TRACE_

struct strace_t
{
	bool finished;
	bool allsolid;
	bool startsolid;	
	float dist;
	float fraction;		
	float endpos[3];	
	bool hitsky;
};

mleaf_t* GetLeafFromPoint(float* point);
void TraceThickness(float* start, float* end, float thickness, strace_t* tr);

#endif

```

`sakura/source/helpers/weapons.cpp`:

```cpp
#include "../client.h"

uintptr_t m_dwInitPoint;

void ResetAccuracy()
{
    g_Local.weapon.m_bDelayFire = false;
    g_Local.weapon.m_iShotsFired = 0;
    g_Local.weapon.m_flDecreaseShotsFired = g_Local.weapon.curtime;
    g_Local.weapon.prevtime = 0;

    switch (g_Local.weapon.m_iWeaponID)
    {
    case WEAPON_AK47:
    case WEAPON_AUG:
    case WEAPON_FAMAS:
    case WEAPON_G3SG1:
    case WEAPON_GALIL:
    case WEAPON_M4A1:
    case WEAPON_M249:
    case WEAPON_P90:
    case WEAPON_SG552:
    case WEAPON_TMP:
        g_Local.weapon.m_flAccuracy = 0.2f;
        break;
    case WEAPON_DEAGLE:
    case WEAPON_GLOCK18:
    case WEAPON_P228:
        g_Local.weapon.m_flAccuracy = 0.9f;
        break;
    case WEAPON_ELITE:
        g_Local.weapon.m_flAccuracy = 0.88f;
        break;
    case WEAPON_FIVESEVEN:
        g_Local.weapon.m_flAccuracy = 0.92f;
        break;
    case WEAPON_MAC10:
        g_Local.weapon.m_flAccuracy = 0.15f;
        break;
    case WEAPON_USP:
        g_Local.weapon.m_flAccuracy = 0.92f;
        break;
    default:
        g_Local.weapon.m_flAccuracy = 0;
        break;
    }
}

void UpdateWeaponData()
{
    switch (g_Local.weapon.m_iWeaponID)
    {
    case WEAPON_P228:
        g_Local.weapon.iPenetration = WALL_PEN0;
        g_Local.weapon.flPenetrationDistance = 4096.0f;
        g_Local.weapon.flWallPierce1 = 0.8f;
        g_Local.weapon.flWallPierce2 = 0.0f;
        g_Local.weapon.iDamage1 = 32;
        g_Local.weapon.iDamage2 = 0;
        g_Local.weapon.iBulletType = BULLET_PLAYER_357SIG;

        if (!(g_Local.weapon.m_iFlags & FL_ONGROUND))
            g_Local.weapon.m_flSpread = 1.5 * (1.0 - g_Local.weapon.m_flAccuracy);
        else if (pmove->velocity.Length2D() > 0)
            g_Local.weapon.m_flSpread = 0.255 * (1.0 - g_Local.weapon.m_flAccuracy);
        else if (g_Local.weapon.m_iFlags & FL_DUCKING)
            g_Local.weapon.m_flSpread = 0.075 * (1.0 - g_Local.weapon.m_flAccuracy);
        else
            g_Local.weapon.m_flSpread = 0.15 * (1.0 - g_Local.weapon.m_flAccuracy);
        break;
    case WEAPON_SCOUT:
        g_Local.weapon.iPenetration = WALL_PEN2;
        g_Local.weapon.flPenetrationDistance = 8192.0f;
        g_Local.weapon.flWallPierce1 = 0.98f;
        g_Local.weapon.flWallPierce2 = 0.0f;
        g_Local.weapon.iDamage1 = 75;
        g_Local.weapon.iDamage2 = 0;
        g_Local.weapon.iBulletType = BULLET_PLAYER_762MM;

        if (!(g_Local.weapon.m_iFlags & FL_ONGROUND))
            g_Local.weapon.m_flSpread = 0.2;
        else if (pmove->velocity.Length2D() > 170)
            g_Local.weapon.m_flSpread = 0.075;
        else if (g_Local.weapon.m_iFlags & FL_DUCKING)
            g_Local.weapon.m_flSpread = 0;
        else
            g_Local.weapon.m_flSpread = 0.007;

        if (g_Local.iFOV == 90)
            g_Local.weapon.m_flSpread += 0.025f;
        break;
    case WEAPON_XM1014:
        g_Local.weapon.iPenetration = WALL_PEN0;
        g_Local.weapon.flPenetrationDistance = 3048.0f;
        g_Local.weapon.flWallPierce1 = 0.0f;
        g_Local.weapon.flWallPierce2 = 0.0f;
        g_Local.weapon.iDamage1 = 4;
        g_Local.weapon.iDamage2 = 0;
        g_Local.weapon.iBulletType = BULLET_PLAYER_BUCKSHOT;
        g_Local.weapon.m_flSpread = 0;
        break;
    case WEAPON_MAC10:
        g_Local.weapon.iPenetration = WALL_PEN0;
        g_Local.weapon.flPenetrationDistance = 8192.0f;
        g_Local.weapon.flWallPierce1 = 0.82f;
        g_Local.weapon.flWallPierce2 = 0.0f;
        g_Local.weapon.iDamage1 = 29;
        g_Local.weapon.iDamage2 = 0;
        g_Local.weapon.iBulletType = BULLET_PLAYER_45ACP;

        if (g_Local.weapon.m_iFlags & FL_ONGROUND)
            g_Local.weapon.m_flSpread = 0.03 * g_Local.weapon.m_flAccuracy;
        else
            g_Local.weapon.m_flSpread = 0.375 * g_Local.weapon.m_flAccuracy;
        break;
    case WEAPON_AUG:
        g_Local.weapon.iPenetration = WALL_PEN1;
        g_Local.weapon.flPenetrationDistance = 8192.0f;
        g_Local.weapon.flWallPierce1 = 0.96f;
        g_Local.weapon.flWallPierce2 = 0.0f;
        g_Local.weapon.iDamage1 = 32;
        g_Local.weapon.iDamage2 = 0;
        g_Local.weapon.iBulletType = BULLET_PLAYER_556MM;

        if (!(g_Local.weapon.m_iFlags & FL_ONGROUND))
            g_Local.weapon.m_flSpread = g_Local.weapon.m_flAccuracy * 0.4 + 0.035;
        else if (pmove->velocity.Length2D() > 140)
            g_Local.weapon.m_flSpread = g_Local.weapon.m_flAccuracy * 0.07 + 0.035;
        else
            g_Local.weapon.m_flSpread = g_Local.weapon.m_flAccuracy * 0.02;
        break;
    case WEAPON_ELITE:
        g_Local.weapon.iPenetration = WALL_PEN0;
        g_Local.weapon.flPenetrationDistance = 8192.0f;
        g_Local.weapon.flWallPierce1 = 0.75f; // left
        g_Local.weapon.flWallPierce2 = 0.75f; // right
        g_Local.weapon.iDamage1 = 20; // left
        g_Local.weapon.iDamage2 = 27; // right
        g_Local.weapon.iBulletType = BULLET_PLAYER_9MM;

        if (!(g_Local.weapon.m_iFlags & FL_ONGROUND))
            g_Local.weapon.m_flSpread = 1.3 * (1.0 - g_Local.weapon.m_flAccuracy);
        else if (pmove->velocity.Length2D() > 0)
            g_Local.weapon.m_flSpread = 0.175 * (1.0 - g_Local.weapon.m_flAccuracy);
        else if (g_Local.weapon.m_iFlags & FL_DUCKING)
            g_Local.weapon.m_flSpread = 0.08 * (1.0 - g_Local.weapon.m_flAccuracy);
        else
            g_Local.weapon.m_flSpread = 0.1 * (1.0 - g_Local.weapon.m_flAccuracy);
        break;
    case WEAPON_FIVESEVEN:
        g_Local.weapon.iPenetration = WALL_PEN0;
        g_Local.weapon.flPenetrationDistance = 4096.0f;
        g_Local.weapon.flWallPierce1 = 0.885f;
        g_Local.weapon.flWallPierce2 = 0.0f;
        g_Local.weapon.iDamage1 = 14;
        g_Local.weapon.iDamage2 = 0;
        g_Local.weapon.iBulletType = BULLET_PLAYER_357SIG;

        if (!(g_Local.weapon.m_iFlags & FL_ONGROUND))
            g_Local.weapon.m_flSpread = 1.5 * (1.0 - g_Local.weapon.m_flAccuracy);
        else if (pmove->velocity.Length2D() > 0)
            g_Local.weapon.m_flSpread = 0.255 * (1.0 - g_Local.weapon.m_flAccuracy);
        else if (g_Local.weapon.m_iFlags & FL_DUCKING)
            g_Local.weapon.m_flSpread = 0.075 * (1.0 - g_Local.weapon.m_flAccuracy);
        else
            g_Local.weapon.m_flSpread = 0.15 * (1.0 - g_Local.weapon.m_flAccuracy);
        break;
    case WEAPON_UMP45:
        g_Local.weapon.iPenetration = WALL_PEN0;
        g_Local.weapon.flPenetrationDistance = 8192.0f;
        g_Local.weapon.flWallPierce1 = 0.82f;
        g_Local.weapon.flWallPierce2 = 0.0f;
        g_Local.weapon.iDamage1 = 30;
        g_Local.weapon.iDamage2 = 0;
        g_Local.weapon.iBulletType = BULLET_PLAYER_45ACP;

        if (g_Local.weapon.m_iFlags & FL_ONGROUND)
            g_Local.weapon.m_flSpread = 0.04 * g_Local.weapon.m_flAccuracy;
        else
            g_Local.weapon.m_flSpread = 0.24 * g_Local.weapon.m_flAccuracy;
        break;
    case WEAPON_SG550:
        g_Local.weapon.iPenetration = WALL_PEN1;
        g_Local.weapon.flPenetrationDistance = 8192.0f;
        g_Local.weapon.flWallPierce1 = 0.98f;
        g_Local.weapon.flWallPierce2 = 0.0f;
        g_Local.weapon.iDamage1 = 40;
        g_Local.weapon.iDamage2 = 0;
        g_Local.weapon.iBulletType = BULLET_PLAYER_556MM;

        if (!(g_Local.weapon.m_iFlags & FL_ONGROUND))
            g_Local.weapon.m_flSpread = 0.45 * (1.0 - g_Local.weapon.m_flAccuracy);
        else if (pmove->velocity.Length2D() > 0)
            g_Local.weapon.m_flSpread = 0.15;
        else if (g_Local.weapon.m_iFlags & FL_DUCKING)
            g_Local.weapon.m_flSpread = 0.04 * (1.0 - g_Local.weapon.m_flAccuracy);
        else
            g_Local.weapon.m_flSpread = 0.05 * (1.0 - g_Local.weapon.m_flAccuracy);

        if (g_Local.iFOV == 90)
            g_Local.weapon.m_flSpread += 0.025f;
        break;
    case WEAPON_GALIL:
        g_Local.weapon.iPenetration = WALL_PEN1;
        g_Local.weapon.flPenetrationDistance = 8192.0f;
        g_Local.weapon.flWallPierce1 = 0.96f;
        g_Local.weapon.flWallPierce2 = 0.0f;
        g_Local.weapon.iDamage1 = 33;
        g_Local.weapon.iDamage2 = 0;
        g_Local.weapon.iBulletType = BULLET_PLAYER_556MM;

        if (!(g_Local.weapon.m_iFlags & FL_ONGROUND))
            g_Local.weapon.m_flSpread = g_Local.weapon.m_flAccuracy * 0.3 + 0.04;
        else if (pmove->velocity.Length2D() > 140)
            g_Local.weapon.m_flSpread = g_Local.weapon.m_flAccuracy * 0.07 + 0.04;
        else
            g_Local.weapon.m_flSpread = g_Local.weapon.m_flAccuracy * 0.0375;
        break;
    case WEAPON_FAMAS:
        g_Local.weapon.iPenetration = WALL_PEN1;
        g_Local.weapon.flPenetrationDistance = 8192.0f;
        g_Local.weapon.flWallPierce1 = 0.96f;
        g_Local.weapon.flWallPierce2 = 0.0f;
        g_Local.weapon.iDamage1 = 33;
        g_Local.weapon.iDamage2 = 0;
        g_Local.weapon.iBulletType = BULLET_PLAYER_556MM;

        if (!(g_Local.weapon.m_iFlags & FL_ONGROUND))
            g_Local.weapon.m_flSpread = g_Local.weapon.m_flAccuracy * 0.3 + 0.030;
        else if (pmove->velocity.Length2D() > 140)
            g_Local.weapon.m_flSpread = g_Local.weapon.m_flAccuracy * 0.07 + 0.030;
        else
            g_Local.weapon.m_flSpread = g_Local.weapon.m_flAccuracy * 0.02;

        if (!IsCurWeaponInBurst()) g_Local.weapon.m_flSpread += 0.01f;
        break;
    case WEAPON_USP:
        g_Local.weapon.iPenetration = WALL_PEN0;
        g_Local.weapon.flPenetrationDistance = 4096.0f;
        g_Local.weapon.flWallPierce1 = 0.79f; // unsilenced
        g_Local.weapon.flWallPierce2 = 0.79f; // silenced
        g_Local.weapon.iDamage1 = 34; // unsilenced
        g_Local.weapon.iDamage2 = 30; // silenced
        g_Local.weapon.iBulletType = BULLET_PLAYER_45ACP;

        if (IsCurWeaponSilenced())
        {
            if (!(g_Local.weapon.m_iFlags & FL_ONGROUND))
                g_Local.weapon.m_flSpread = 1.3 * (1.0 - g_Local.weapon.m_flAccuracy);
            else if (pmove->velocity.Length2D() > 0)
                g_Local.weapon.m_flSpread = 0.25 * (1.0 - g_Local.weapon.m_flAccuracy);
            else if (g_Local.weapon.m_iFlags & FL_DUCKING)
                g_Local.weapon.m_flSpread = 0.125 * (1.0 - g_Local.weapon.m_flAccuracy);
            else
                g_Local.weapon.m_flSpread = 0.15 * (1.0 - g_Local.weapon.m_flAccuracy);
        }
        else
        {
            if (!(g_Local.weapon.m_iFlags & FL_ONGROUND))
                g_Local.weapon.m_flSpread = 1.2 * (1.0 - g_Local.weapon.m_flAccuracy);
            else if (pmove->velocity.Length2D() > 0)
                g_Local.weapon.m_flSpread = 0.225 * (1.0 - g_Local.weapon.m_flAccuracy);
            else if (g_Local.weapon.m_iFlags & FL_DUCKING)
                g_Local.weapon.m_flSpread = 0.08 * (1.0 - g_Local.weapon.m_flAccuracy);
            else
                g_Local.weapon.m_flSpread = 0.1 * (1.0 - g_Local.weapon.m_flAccuracy);
        }
        break;
    case WEAPON_GLOCK18:
        g_Local.weapon.iPenetration = WALL_PEN0;
        g_Local.weapon.flPenetrationDistance = 8192.0f;
        g_Local.weapon.flWallPierce1 = 0.75f;
        g_Local.weapon.flWallPierce2 = 0.0f;
        g_Local.weapon.iDamage1 = 20;
        g_Local.weapon.iDamage2 = 0;
        g_Local.weapon.iBulletType = BULLET_PLAYER_9MM;

        if (IsCurWeaponInBurst())
        {
            if (!(g_Local.weapon.m_iFlags & FL_ONGROUND))
                g_Local.weapon.m_flSpread = 1.2 * (1.0 - g_Local.weapon.m_flAccuracy);
            else if (pmove->velocity.Length2D() > 0)
                g_Local.weapon.m_flSpread = 0.185 * (1.0 - g_Local.weapon.m_flAccuracy);
            else if (g_Local.weapon.m_iFlags & FL_DUCKING)
                g_Local.weapon.m_flSpread = 0.095 * (1.0 - g_Local.weapon.m_flAccuracy);
            else
                g_Local.weapon.m_flSpread = 0.3 * (1.0 - g_Local.weapon.m_flAccuracy);
        }
        else
        {
            if (!(g_Local.weapon.m_iFlags & FL_ONGROUND))
                g_Local.weapon.m_flSpread = 1.0 * (1.0 - g_Local.weapon.m_flAccuracy);
            else if (pmove->velocity.Length2D() > 0)
                g_Local.weapon.m_flSpread = 0.165 * (1.0 - g_Local.weapon.m_flAccuracy);
            else if (g_Local.weapon.m_iFlags & FL_DUCKING)
                g_Local.weapon.m_flSpread = 0.075 * (1.0 - g_Local.weapon.m_flAccuracy);
            else
                g_Local.weapon.m_flSpread = 0.1 * (1.0 - g_Local.weapon.m_flAccuracy);
        }
        break;
    case WEAPON_AWP:
        g_Local.weapon.iPenetration = WALL_PEN2;
        g_Local.weapon.flPenetrationDistance = 8192.0f;
        g_Local.weapon.flWallPierce1 = 0.99f;
        g_Local.weapon.flWallPierce2 = 0.0f;
        g_Local.weapon.iDamage1 = 115;
        g_Local.weapon.iDamage2 = 0;
        g_Local.weapon.iBulletType = BULLET_PLAYER_338MAG;

        if (!(g_Local.weapon.m_iFlags & FL_ONGROUND))
            g_Local.weapon.m_flSpread = 0.85;
        else if (pmove->velocity.Length2D() > 140)
            g_Local.weapon.m_flSpread = 0.25;
        else if (pmove->velocity.Length2D() > 10)
            g_Local.weapon.m_flSpread = 0.1;
        else if (g_Local.weapon.m_iFlags & FL_DUCKING)
            g_Local.weapon.m_flSpread = 0.0;
        else
            g_Local.weapon.m_flSpread = 0.001;

        if (g_Local.iFOV == 90)
            g_Local.weapon.m_flSpread += 0.08f;
        break;
    case WEAPON_MP5N:
        g_Local.weapon.iPenetration = WALL_PEN0;
        g_Local.weapon.flPenetrationDistance = 8192.0f;
        g_Local.weapon.flWallPierce1 = 0.84f;
        g_Local.weapon.flWallPierce2 = 0.0f;
        g_Local.weapon.iDamage1 = 26;
        g_Local.weapon.iDamage2 = 0;
        g_Local.weapon.iBulletType = BULLET_PLAYER_9MM;

        if (g_Local.weapon.m_iFlags & FL_ONGROUND)
            g_Local.weapon.m_flSpread = 0.04 * g_Local.weapon.m_flAccuracy;
        else
            g_Local.weapon.m_flSpread = 0.2 * g_Local.weapon.m_flAccuracy;
        break;
    case WEAPON_M249:
        g_Local.weapon.iPenetration = WALL_PEN1;
        g_Local.weapon.flPenetrationDistance = 8192.0f;
        g_Local.weapon.flWallPierce1 = 0.97f;
        g_Local.weapon.flWallPierce2 = 0.0f;
        g_Local.weapon.iDamage1 = 32;
        g_Local.weapon.iDamage2 = 0;
        g_Local.weapon.iBulletType = BULLET_PLAYER_556MM;

        if (!(g_Local.weapon.m_iFlags & FL_ONGROUND))
            g_Local.weapon.m_flSpread = g_Local.weapon.m_flAccuracy * 0.5 + 0.045;
        else if (pmove->velocity.Length2D() > 140)
            g_Local.weapon.m_flSpread = g_Local.weapon.m_flAccuracy * 0.095 + 0.045;
        else
            g_Local.weapon.m_flSpread = g_Local.weapon.m_flAccuracy * 0.03;
        break;
    case WEAPON_M3:
        g_Local.weapon.iPenetration = WALL_PEN0;
        g_Local.weapon.flPenetrationDistance = 3000.0f;
        g_Local.weapon.flWallPierce1 = 0.0f;
        g_Local.weapon.flWallPierce2 = 0.0f;
        g_Local.weapon.iDamage1 = 4;
        g_Local.weapon.iDamage2 = 0;
        g_Local.weapon.iBulletType = BULLET_PLAYER_BUCKSHOT;
        g_Local.weapon.m_flSpread = 0.f;
        break;
    case WEAPON_M4A1:
        g_Local.weapon.iPenetration = WALL_PEN1;
        g_Local.weapon.flPenetrationDistance = 8192.0f;
        g_Local.weapon.flWallPierce1 = 0.97f; // unsilenced
        g_Local.weapon.flWallPierce2 = 0.95f; // silenced
        g_Local.weapon.iDamage1 = 32; // unsilenced
        g_Local.weapon.iDamage2 = 33; // silenced
        g_Local.weapon.iBulletType = BULLET_PLAYER_556MM;

        if (IsCurWeaponSilenced())
        {
            if (!(g_Local.weapon.m_iFlags & FL_ONGROUND))
                g_Local.weapon.m_flSpread = g_Local.weapon.m_flAccuracy * 0.4 + 0.035;
            else if (pmove->velocity.Length2D() > 140)
                g_Local.weapon.m_flSpread = g_Local.weapon.m_flAccuracy * 0.07 + 0.035;
            else
                g_Local.weapon.m_flSpread = g_Local.weapon.m_flAccuracy * 0.025;
        }
        else
        {
            if (!(g_Local.weapon.m_iFlags & FL_ONGROUND))
                g_Local.weapon.m_flSpread = g_Local.weapon.m_flAccuracy * 0.4 + 0.035;
            else if (pmove->velocity.Length2D() > 140)
                g_Local.weapon.m_flSpread = g_Local.weapon.m_flAccuracy * 0.07 + 0.035;
            else
                g_Local.weapon.m_flSpread = g_Local.weapon.m_flAccuracy * 0.02;
        }
        break;
    case WEAPON_TMP:
        g_Local.weapon.iPenetration = WALL_PEN0;
        g_Local.weapon.flPenetrationDistance = 8192.0f;
        g_Local.weapon.flWallPierce1 = 0.85f;
        g_Local.weapon.flWallPierce2 = 0.0f;
        g_Local.weapon.iDamage1 = 20;
        g_Local.weapon.iDamage2 = 0;
        g_Local.weapon.iBulletType = BULLET_PLAYER_9MM;

        if (g_Local.weapon.m_iFlags & FL_ONGROUND)
            g_Local.weapon.m_flSpread = 0.03 * g_Local.weapon.m_flAccuracy;
        else
            g_Local.weapon.m_flSpread = 0.25 * g_Local.weapon.m_flAccuracy;
        break;
    case WEAPON_G3SG1:
        g_Local.weapon.iPenetration = WALL_PEN1;
        g_Local.weapon.flPenetrationDistance = 8192.0f;
        g_Local.weapon.flWallPierce1 = 0.98f;
        g_Local.weapon.flWallPierce2 = 0.0f;
        g_Local.weapon.iDamage1 = 60;
        g_Local.weapon.iDamage2 = 0;
        g_Local.weapon.iBulletType = BULLET_PLAYER_762MM;

        if (!(g_Local.weapon.m_iFlags & FL_ONGROUND))
            g_Local.weapon.m_flSpread = 0.45;
        else if (pmove->velocity.Length2D() > 0)
            g_Local.weapon.m_flSpread = 0.15;
        else if (g_Local.weapon.m_iFlags & FL_DUCKING)
            g_Local.weapon.m_flSpread = 0.035;
        else
            g_Local.weapon.m_flSpread = 0.055;

        if (g_Local.iFOV == 90)
            g_Local.weapon.m_flSpread += 0.025f;
        break;
    case WEAPON_DEAGLE:
        g_Local.weapon.iPenetration = WALL_PEN1;
        g_Local.weapon.flPenetrationDistance = 4096.0f;
        g_Local.weapon.flWallPierce1 = 0.81f;
        g_Local.weapon.flWallPierce2 = 0.0f;
        g_Local.weapon.iDamage1 = 54;
        g_Local.weapon.iDamage2 = 0;
        g_Local.weapon.iBulletType = BULLET_PLAYER_50AE;
        //g_Local.weapon.m_flAccuracy = (*(float*)((*(DWORD*)(m_dwInitPoint + 0x3D)) + 0xF8));

        if (!(g_Local.weapon.m_iFlags & FL_ONGROUND))
            g_Local.weapon.m_flSpread = 1.5 * (1.0 - g_Local.weapon.m_flAccuracy);
        else if (pmove->velocity.Length2D() > 0)
            g_Local.weapon.m_flSpread = 0.25 * (1.0 - g_Local.weapon.m_flAccuracy);
        else if (g_Local.weapon.m_iFlags & FL_DUCKING)
            g_Local.weapon.m_flSpread = 0.115 * (1.0 - g_Local.weapon.m_flAccuracy);
        else
            g_Local.weapon.m_flSpread = 0.13 * (1.0 - g_Local.weapon.m_flAccuracy);
        break;
    case WEAPON_SG552:
        g_Local.weapon.iPenetration = WALL_PEN1;
        g_Local.weapon.flPenetrationDistance = 8192.0f;
        g_Local.weapon.flWallPierce1 = 0.955f;
        g_Local.weapon.flWallPierce2 = 0.0f;
        g_Local.weapon.iDamage1 = 33;
        g_Local.weapon.iDamage2 = 0;
        g_Local.weapon.iBulletType = BULLET_PLAYER_556MM;

        if (!(g_Local.weapon.m_iFlags & FL_ONGROUND))
            g_Local.weapon.m_flSpread = g_Local.weapon.m_flAccuracy * 0.45 + 0.035;
        else if (pmove->velocity.Length2D() > 140)
            g_Local.weapon.m_flSpread = g_Local.weapon.m_flAccuracy * 0.075 + 0.035;
        else
            g_Local.weapon.m_flSpread = g_Local.weapon.m_flAccuracy * 0.02;
        break;
    case WEAPON_AK47:
        g_Local.weapon.iPenetration = WALL_PEN1;
        g_Local.weapon.flPenetrationDistance = 8192.0f;
        g_Local.weapon.flWallPierce1 = 0.98f;
        g_Local.weapon.flWallPierce2 = 0.0f;
        g_Local.weapon.iDamage1 = 36;
        g_Local.weapon.iDamage2 = 0;
        g_Local.weapon.iBulletType = BULLET_PLAYER_762MM;

        if (!(g_Local.weapon.m_iFlags & FL_ONGROUND))
            g_Local.weapon.m_flSpread = g_Local.weapon.m_flAccuracy * 0.4 + 0.04;
        else if (pmove->velocity.Length2D() > 140)
            g_Local.weapon.m_flSpread = g_Local.weapon.m_flAccuracy * 0.07 + 0.04;
        else
            g_Local.weapon.m_flSpread = g_Local.weapon.m_flAccuracy * 0.0275;
        break;
    case WEAPON_P90:
        g_Local.weapon.iPenetration = WALL_PEN0;
        g_Local.weapon.flPenetrationDistance = 8192.0f;
        g_Local.weapon.flWallPierce1 = 0.885f;
        g_Local.weapon.flWallPierce2 = 0.0f;
        g_Local.weapon.iDamage1 = 21;
        g_Local.weapon.iDamage2 = 0;
        g_Local.weapon.iBulletType = BULLET_PLAYER_57MM;

        if (!(g_Local.weapon.m_iFlags & FL_ONGROUND))
            g_Local.weapon.m_flSpread = g_Local.weapon.m_flAccuracy * 0.3;
        else if (pmove->velocity.Length2D() > 170)
            g_Local.weapon.m_flSpread = g_Local.weapon.m_flAccuracy * 0.115;
        else
            g_Local.weapon.m_flSpread = g_Local.weapon.m_flAccuracy * 0.045;
        break;
    default:
        g_Local.weapon.iPenetration = WALL_PEN0;
        g_Local.weapon.flPenetrationDistance = 0;
        g_Local.weapon.flWallPierce1 = 0;
        g_Local.weapon.flWallPierce2 = 0;
        g_Local.weapon.iDamage1 = 0;
        g_Local.weapon.iDamage2 = 0;
        g_Local.weapon.iBulletType = BULLET_NONE;
        g_Local.weapon.m_flAccuracy = 0;
        g_Local.weapon.m_flSpread = 0;
        break;
    }
}

void Simulate(float &m_flAccuracy, float &m_flSpread)
{
    bool m_bDelayFire = g_Local.weapon.m_bDelayFire;
    int m_iShotsFired = g_Local.weapon.m_iShotsFired;

    switch (g_Local.weapon.m_iWeaponID)
    {
    case WEAPON_AK47:
        m_bDelayFire = true;
        m_iShotsFired++;

        //m_flAccuracy = static_cast<float>((m_iShotsFired * m_iShotsFired * m_iShotsFired) / 200) + 0.35f;
        m_flAccuracy = (m_iShotsFired * m_iShotsFired * m_iShotsFired / 200) + 0.35;

        if (m_flAccuracy > 1.25f)
            m_flAccuracy = 1.25f;

        if (!(g_Local.weapon.m_iFlags & FL_ONGROUND))
            m_flSpread = m_flAccuracy * 0.4 + 0.04;
        else if (pmove->velocity.Length2D() > 140)
            m_flSpread = m_flAccuracy * 0.07 + 0.04;
        else
            m_flSpread = m_flAccuracy * 0.0275;
        break;
    case WEAPON_AUG:
        m_bDelayFire = true;
        m_iShotsFired++;

        //m_flAccuracy = ((m_iShotsFired * m_iShotsFired * m_iShotsFired) / 215) + 0.3f;
        m_flAccuracy = (m_iShotsFired * m_iShotsFired * m_iShotsFired / 215) + 0.3f;

        if (m_flAccuracy > 1.0f)
            m_flAccuracy = 1.0f;

        if (!(g_Local.weapon.m_iFlags & FL_ONGROUND))
            m_flSpread = m_flAccuracy * 0.4 + 0.035;
        else if (pmove->velocity.Length2D() > 140)
            m_flSpread = m_flAccuracy * 0.07 + 0.035;
        else
            m_flSpread = m_flAccuracy * 0.02;
        break;
    case WEAPON_DEAGLE:

        if (g_Local.weapon.prevtime != 0.0)
        {
            m_flAccuracy -= (0.4f - (g_Local.weapon.curtime - g_Local.weapon.prevtime)) * 0.35f;

            if (m_flAccuracy > 0.9f)
                m_flAccuracy = 0.9f;
            else if (m_flAccuracy < 0.55f)
                m_flAccuracy = 0.55f;
        }

        if (!(g_Local.weapon.m_iFlags & FL_ONGROUND))
            m_flSpread = 1.5 * (1.0 - m_flAccuracy);
        else if (pmove->velocity.Length2D() > 0)
            m_flSpread = 0.25 * (1.0 - m_flAccuracy);
        else if (g_Local.weapon.m_iFlags & FL_DUCKING)
            m_flSpread = 0.115 * (1.0 - m_flAccuracy);
        else
            m_flSpread = 0.13 * (1.0 - m_flAccuracy);
        break;
    case WEAPON_ELITE:

        if (g_Local.weapon.prevtime)
        {
            m_flAccuracy -= (0.325f - g_Local.weapon.curtime - g_Local.weapon.prevtime) * 0.275f;

            if (m_flAccuracy > 0.88f)
                m_flAccuracy = 0.88f;
            else if (m_flAccuracy < 0.55f)
                m_flAccuracy = 0.55f;
        }

        if (!(g_Local.weapon.m_iFlags & FL_ONGROUND))
            m_flSpread = 1.3 * (1.0 - m_flAccuracy);
        else if (pmove->velocity.Length2D() > 0)
            m_flSpread = 0.175 * (1.0 - m_flAccuracy);
        else if (g_Local.weapon.m_iFlags & FL_DUCKING)
            m_flSpread = 0.08 * (1.0 - m_flAccuracy);
        else
            m_flSpread = 0.1 * (1.0 - m_flAccuracy);
        break;
    case WEAPON_FAMAS:
        m_bDelayFire = true;
        m_iShotsFired++;

        //m_flAccuracy = ((m_iShotsFired * m_iShotsFired * m_iShotsFired) / 215) + 0.3f;
        m_flAccuracy = (m_iShotsFired * m_iShotsFired * m_iShotsFired / 215) + 0.3f;

        if (m_flAccuracy > 1.0f)
            m_flAccuracy = 1.0f;

        if (!(g_Local.weapon.m_iFlags & FL_ONGROUND))
            m_flSpread = m_flAccuracy * 0.3 + 0.030;
        else if (pmove->velocity.Length2D() > 140)
            m_flSpread = m_flAccuracy * 0.07 + 0.030;
        else
            m_flSpread = m_flAccuracy * 0.02;

        if (!IsCurWeaponInBurst()) m_flSpread += 0.01f;
        break;
    case WEAPON_FIVESEVEN:

        if (g_Local.weapon.prevtime != 0.0f)
        {
            m_flAccuracy -= (0.275f - (g_Local.weapon.curtime - g_Local.weapon.prevtime)) * 0.25f;

            if (m_flAccuracy > 0.92f)
                m_flAccuracy = 0.92f;
            else if (m_flAccuracy < 0.725f)
            {
                m_flAccuracy = 0.725f;
            }
        }

        if (!(g_Local.weapon.m_iFlags & FL_ONGROUND))
            m_flSpread = 1.5 * (1.0 - m_flAccuracy);
        else if (pmove->velocity.Length2D() > 0)
            m_flSpread = 0.255 * (1.0 - m_flAccuracy);
        else if (g_Local.weapon.m_iFlags & FL_DUCKING)
            m_flSpread = 0.075 * (1.0 - m_flAccuracy);
        else
            m_flSpread = 0.15 * (1.0 - m_flAccuracy);
        break;
    case WEAPON_G3SG1:
        if (g_Local.weapon.prevtime)
        {
            m_flAccuracy = (g_Local.weapon.curtime - g_Local.weapon.prevtime) * 0.3f + 0.55f;

            if (m_flAccuracy > 0.98f)
                m_flAccuracy = 0.98f;
        }
        else
            m_flAccuracy = 0.98f;

        if (!(g_Local.weapon.m_iFlags & FL_ONGROUND))
            m_flSpread = 0.45;
        else if (pmove->velocity.Length2D() > 0)
            m_flSpread = 0.15;
        else if (g_Local.weapon.m_iFlags & FL_DUCKING)
            m_flSpread = 0.035;
        else
            m_flSpread = 0.055;

        if (g_Local.iFOV == 90)
            m_flSpread += 0.025f;
        break;
    case WEAPON_GALIL:
        m_bDelayFire = true;
        m_iShotsFired++;

        m_flAccuracy = (m_iShotsFired * m_iShotsFired * m_iShotsFired / 200) + 0.35f;

        if (m_flAccuracy > 1.25f)
            m_flAccuracy = 1.25f;

        if (!(g_Local.weapon.m_iFlags & FL_ONGROUND))
            m_flSpread = m_flAccuracy * 0.3 + 0.04;
        else if (pmove->velocity.Length2D() > 140)
            m_flSpread = m_flAccuracy * 0.07 + 0.04;
        else
            m_flSpread = m_flAccuracy * 0.0375;
        break;
    case WEAPON_GLOCK18:

        if (g_Local.weapon.prevtime)
        {
            m_flAccuracy -= (0.325f - (g_Local.weapon.curtime - g_Local.weapon.prevtime)) * 0.275f;

            if (m_flAccuracy > 0.9f)
                m_flAccuracy = 0.9f;
            else if (m_flAccuracy < 0.6f)
                m_flAccuracy = 0.6f;
        }

        if (IsCurWeaponInBurst())
        {
            if (!(g_Local.weapon.m_iFlags & FL_ONGROUND))
                m_flSpread = 1.2 * (1.0 - m_flAccuracy);
            else if (pmove->velocity.Length2D() > 0)
                m_flSpread = 0.185 * (1.0 - m_flAccuracy);
            else if (g_Local.weapon.m_iFlags & FL_DUCKING)
                m_flSpread = 0.095 * (1.0 - m_flAccuracy);
            else
                m_flSpread = 0.3 * (1.0 - m_flAccuracy);
        }
        else
        {
            if (!(g_Local.weapon.m_iFlags & FL_ONGROUND))
                m_flSpread = 1.0 * (1.0 - m_flAccuracy);
            else if (pmove->velocity.Length2D() > 0)
                m_flSpread = 0.165 * (1.0 - m_flAccuracy);
            else if (g_Local.weapon.m_iFlags & FL_DUCKING)
                m_flSpread = 0.075 * (1.0 - m_flAccuracy);
            else
                m_flSpread = 0.1 * (1.0 - m_flAccuracy);
        }
        break;
    case WEAPON_M4A1:
        m_bDelayFire = true;
        m_iShotsFired++;

        m_flAccuracy = (m_iShotsFired * m_iShotsFired * m_iShotsFired / 220) + 0.3f;

        if (m_flAccuracy > 1)
            m_flAccuracy = 1;

        if (IsCurWeaponSilenced())
        {
            if (!(g_Local.weapon.m_iFlags & FL_ONGROUND))
                m_flSpread = m_flAccuracy * 0.4 + 0.035;
            else if (pmove->velocity.Length2D() > 140)
                m_flSpread = m_flAccuracy * 0.07 + 0.035;
            else
                m_flSpread = m_flAccuracy * 0.025;
        }
        else
        {
            if (!(g_Local.weapon.m_iFlags & FL_ONGROUND))
                m_flSpread = m_flAccuracy * 0.4 + 0.035;
            else if (pmove->velocity.Length2D() > 140)
                m_flSpread = m_flAccuracy * 0.07 + 0.035;
            else
                m_flSpread = m_flAccuracy * 0.02;
        }
        break;
    case WEAPON_M249:
        m_bDelayFire = true;
        m_iShotsFired++;

        m_flAccuracy = (m_iShotsFired * m_iShotsFired * m_iShotsFired / 175) + 0.4f;

        if (m_flAccuracy > 0.9f)
            m_flAccuracy = 0.9f;

        if (!(g_Local.weapon.m_iFlags & FL_ONGROUND))
            m_flSpread = m_flAccuracy * 0.5 + 0.045;
        else if (pmove->velocity.Length2D() > 140)
            m_flSpread = m_flAccuracy * 0.095 + 0.045;
        else
            m_flSpread = m_flAccuracy * 0.03;
        break;
    case WEAPON_MAC10:
        m_bDelayFire = true;
        m_iShotsFired++;

        m_flAccuracy = (m_iShotsFired * m_iShotsFired * m_iShotsFired / 200) + 0.6f;

        if (m_flAccuracy > 1.65f)
            m_flAccuracy = 1.65f;

        if (g_Local.weapon.m_iFlags & FL_ONGROUND)
            m_flSpread = 0.03 * m_flAccuracy;
        else
            m_flSpread = 0.375 * m_flAccuracy;
        break;
    case WEAPON_MP5N:
        m_bDelayFire = true;
        m_iShotsFired++;

        //m_flAccuracy = ((m_iShotsFired * m_iShotsFired) / 220.1) + 0.45f;
        m_flAccuracy = ((m_iShotsFired * m_iShotsFired) / 220.1) + 0.45;

        if (m_flAccuracy > 0.75f)
            m_flAccuracy = 0.75f;

        if (g_Local.weapon.m_iFlags & FL_ONGROUND)
            m_flSpread = 0.04 * m_flAccuracy;
        else
            m_flSpread = 0.2 * m_flAccuracy;
        break;
    case WEAPON_P90:
        m_bDelayFire = true;
        m_iShotsFired++;

        m_flAccuracy = (m_iShotsFired * m_iShotsFired / 175) + 0.45f;

        if (m_flAccuracy > 1)
            m_flAccuracy = 1;

        if (!(g_Local.weapon.m_iFlags & FL_ONGROUND))
            m_flSpread = m_flAccuracy * 0.3;
        else if (pmove->velocity.Length2D() > 170)
            m_flSpread = m_flAccuracy * 0.115;
        else
            m_flSpread = m_flAccuracy * 0.045;
        break;
    case WEAPON_P228:

        if (g_Local.weapon.prevtime != 0.0f)
        {
            m_flAccuracy -= (0.325f - (g_Local.weapon.curtime - g_Local.weapon.prevtime)) * 0.3f;

            if (m_flAccuracy > 0.9f)
                m_flAccuracy = 0.9f;
            else if (m_flAccuracy < 0.6f)
                m_flAccuracy = 0.6f;
        }

        if (!(g_Local.weapon.m_iFlags & FL_ONGROUND))
            m_flSpread = 1.5 * (1.0 - m_flAccuracy);
        else if (pmove->velocity.Length2D() > 0)
            m_flSpread = 0.255 * (1.0 - m_flAccuracy);
        else if (g_Local.weapon.m_iFlags & FL_DUCKING)
            m_flSpread = 0.075 * (1.0 - m_flAccuracy);
        else
            m_flSpread = 0.15 * (1.0 - m_flAccuracy);
        break;
    case WEAPON_SG550:
        if (g_Local.weapon.prevtime)
        {
            m_flAccuracy = (g_Local.weapon.curtime - g_Local.weapon.prevtime) * 0.35f + 0.65f;

            if (m_flAccuracy > 0.98f)
                m_flAccuracy = 0.98f;
        }

        if (!(g_Local.weapon.m_iFlags & FL_ONGROUND))
            m_flSpread = 0.45 * (1.0 - m_flAccuracy);
        else if (pmove->velocity.Length2D() > 0)
            m_flSpread = 0.15;
        else if (g_Local.weapon.m_iFlags & FL_DUCKING)
            m_flSpread = 0.04 * (1.0 - m_flAccuracy);
        else
            m_flSpread = 0.05 * (1.0 - m_flAccuracy);

        if (g_Local.iFOV == 90)
            m_flSpread += 0.025f;
        break;
    case WEAPON_SG552:
        m_bDelayFire = true;
        m_iShotsFired++;

        m_flAccuracy = (m_iShotsFired * m_iShotsFired * m_iShotsFired / 220) + 0.3f;

        if (m_flAccuracy > 1.0f)
            m_flAccuracy = 1.0f;

        if (!(g_Local.weapon.m_iFlags & FL_ONGROUND))
            m_flSpread = m_flAccuracy * 0.45 + 0.035;
        else if (pmove->velocity.Length2D() > 140)
            m_flSpread = m_flAccuracy * 0.075 + 0.035;
        else
            m_flSpread = m_flAccuracy * 0.02;
        break;
    case WEAPON_TMP:
        m_bDelayFire = true;
        m_iShotsFired++;

        m_flAccuracy = (m_iShotsFired * m_iShotsFired * m_iShotsFired / 200) + 0.55f;

        if (m_flAccuracy > 1.4f)
            m_flAccuracy = 1.4f;

        if (g_Local.weapon.m_iFlags & FL_ONGROUND)
            m_flSpread = 0.03 * m_flAccuracy;
        else
            m_flSpread = 0.25 * m_flAccuracy;
        break;
    case WEAPON_UMP45:
        m_bDelayFire = true;
        m_iShotsFired++;

        m_flAccuracy = (m_iShotsFired * m_iShotsFired / 210) + 0.5f;

        if (m_flAccuracy > 1.0f)
            m_flAccuracy = 1.0f;

        if (g_Local.weapon.m_iFlags & FL_ONGROUND)
            m_flSpread = 0.04 * m_flAccuracy;
        else
            m_flSpread = 0.24 * m_flAccuracy;
        break;
    case WEAPON_USP:

        if (g_Local.weapon.prevtime != 0.0f)
        {
            m_flAccuracy -= (0.3f - (g_Local.weapon.curtime - g_Local.weapon.prevtime)) * 0.275f;

            if (m_flAccuracy > 0.92f)
                m_flAccuracy = 0.92f;
            else if (m_flAccuracy < 0.6f)
                m_flAccuracy = 0.6f;
        }

        if (IsCurWeaponSilenced())
        {
            if (!(g_Local.weapon.m_iFlags & FL_ONGROUND))
                m_flSpread = 1.3 * (1.0 - m_flAccuracy);
            else if (pmove->velocity.Length2D() > 0)
                m_flSpread = 0.25 * (1.0 - m_flAccuracy);
            else if (g_Local.weapon.m_iFlags & FL_DUCKING)
                m_flSpread = 0.125 * (1.0 - m_flAccuracy);
            else
                m_flSpread = 0.15 * (1.0 - m_flAccuracy);
        }
        else
        {
            if (!(g_Local.weapon.m_iFlags & FL_ONGROUND))
                m_flSpread = 1.2 * (1.0 - m_flAccuracy);
            else if (pmove->velocity.Length2D() > 0)
                m_flSpread = 0.225 * (1.0 - m_flAccuracy);
            else if (g_Local.weapon.m_iFlags & FL_DUCKING)
                m_flSpread = 0.08 * (1.0 - m_flAccuracy);
            else
                m_flSpread = 0.1 * (1.0 - m_flAccuracy);
        }
        break;
    }
}

void PrimaryAttack()
{
    switch (g_Local.weapon.m_iWeaponID)
    {
    case WEAPON_AK47:
        g_Local.weapon.m_bDelayFire = true;
        g_Local.weapon.m_iShotsFired++;

        g_Local.weapon.m_flAccuracy = ((g_Local.weapon.m_iShotsFired * g_Local.weapon.m_iShotsFired * g_Local.weapon.m_iShotsFired) / 200) + 0.35f;

        if (g_Local.weapon.m_flAccuracy > 1.25f)
            g_Local.weapon.m_flAccuracy = 1.25f;
        break;
    case WEAPON_AUG:
        g_Local.weapon.m_bDelayFire = true;
        g_Local.weapon.m_iShotsFired++;

        g_Local.weapon.m_flAccuracy = ((g_Local.weapon.m_iShotsFired * g_Local.weapon.m_iShotsFired * g_Local.weapon.m_iShotsFired) / 215) + 0.3f;

        if (g_Local.weapon.m_flAccuracy > 1.0f)
            g_Local.weapon.m_flAccuracy = 1.0f;
        break;
    case WEAPON_DEAGLE:
        if (g_Local.weapon.m_iShotsFired < 1)
            g_Local.weapon.m_iShotsFired++;
        else
            return;

        if (g_Local.weapon.prevtime != 0.0)
        {
            g_Local.weapon.m_flAccuracy -= (0.4f - (g_Local.weapon.curtime - g_Local.weapon.prevtime)) * 0.35f;

            if (g_Local.weapon.m_flAccuracy > 0.9f)
                g_Local.weapon.m_flAccuracy = 0.9f;
            else if (g_Local.weapon.m_flAccuracy < 0.55f)
                g_Local.weapon.m_flAccuracy = 0.55f;
        }
        break;
    case WEAPON_ELITE:
        if (g_Local.weapon.m_iShotsFired < 1)
            g_Local.weapon.m_iShotsFired++;
        else
            return;

        if (g_Local.weapon.prevtime)
        {
            g_Local.weapon.m_flAccuracy -= (0.325f - g_Local.weapon.curtime - g_Local.weapon.prevtime) * 0.275f;

            if (g_Local.weapon.m_flAccuracy > 0.88f)
                g_Local.weapon.m_flAccuracy = 0.88f;
            else if (g_Local.weapon.m_flAccuracy < 0.55f)
                g_Local.weapon.m_flAccuracy = 0.55f;
        }
        break;
    case WEAPON_FAMAS:
        g_Local.weapon.m_bDelayFire = true;
        g_Local.weapon.m_iShotsFired++;

        g_Local.weapon.m_flAccuracy = ((g_Local.weapon.m_iShotsFired * g_Local.weapon.m_iShotsFired * g_Local.weapon.m_iShotsFired) / 215) + 0.3f;

        if (g_Local.weapon.m_flAccuracy > 1.0f)
            g_Local.weapon.m_flAccuracy = 1.0f;
        break;
    case WEAPON_FIVESEVEN:
        if (g_Local.weapon.m_iShotsFired < 1)
            g_Local.weapon.m_iShotsFired++;
        else
            return;

        if (g_Local.weapon.prevtime != 0.0f)
        {
            g_Local.weapon.m_flAccuracy -= (0.275f - (g_Local.weapon.curtime - g_Local.weapon.prevtime)) * 0.25f;

            if (g_Local.weapon.m_flAccuracy > 0.92f)
                g_Local.weapon.m_flAccuracy = 0.92f;
            else if (g_Local.weapon.m_flAccuracy < 0.725f)
            {
                g_Local.weapon.m_flAccuracy = 0.725f;
            }
        }
        break;
    case WEAPON_G3SG1:
        if (g_Local.weapon.prevtime)
        {
            g_Local.weapon.m_flAccuracy = (g_Local.weapon.curtime - g_Local.weapon.prevtime) * 0.3f + 0.55f;

            if (g_Local.weapon.m_flAccuracy > 0.98f)
                g_Local.weapon.m_flAccuracy = 0.98f;
        }
        else
            g_Local.weapon.m_flAccuracy = 0.98f;
        break;
    case WEAPON_GALIL:
        g_Local.weapon.m_bDelayFire = true;
        g_Local.weapon.m_iShotsFired++;

        g_Local.weapon.m_flAccuracy = ((g_Local.weapon.m_iShotsFired * g_Local.weapon.m_iShotsFired * g_Local.weapon.m_iShotsFired) / 200) + 0.35f;

        if (g_Local.weapon.m_flAccuracy > 1.25f)
            g_Local.weapon.m_flAccuracy = 1.25f;
        break;
    case WEAPON_GLOCK18:
        if (!IsCurWeaponInBurst())
        {
            if (g_Local.weapon.m_iShotsFired < 1)
                g_Local.weapon.m_iShotsFired++;
            else
                return;
        }

        if (g_Local.weapon.prevtime)
        {
            g_Local.weapon.m_flAccuracy -= (0.325f - (g_Local.weapon.curtime - g_Local.weapon.prevtime)) * 0.275f;

            if (g_Local.weapon.m_flAccuracy > 0.9f)
                g_Local.weapon.m_flAccuracy = 0.9f;
            else if (g_Local.weapon.m_flAccuracy < 0.6f)
                g_Local.weapon.m_flAccuracy = 0.6f;
        }
        break;
    case WEAPON_M4A1:
        g_Local.weapon.m_bDelayFire = true;
        g_Local.weapon.m_iShotsFired++;

        g_Local.weapon.m_flAccuracy = ((g_Local.weapon.m_iShotsFired * g_Local.weapon.m_iShotsFired * g_Local.weapon.m_iShotsFired) / 220) + 0.3f;

        if (g_Local.weapon.m_flAccuracy > 1)
            g_Local.weapon.m_flAccuracy = 1;
        break;
    case WEAPON_M249:
        g_Local.weapon.m_bDelayFire = true;
        g_Local.weapon.m_iShotsFired++;

        g_Local.weapon.m_flAccuracy = ((g_Local.weapon.m_iShotsFired * g_Local.weapon.m_iShotsFired * g_Local.weapon.m_iShotsFired) / 175) + 0.4f;

        if (g_Local.weapon.m_flAccuracy > 0.9f)
            g_Local.weapon.m_flAccuracy = 0.9f;
        break;
    case WEAPON_MAC10:
        g_Local.weapon.m_bDelayFire = true;
        g_Local.weapon.m_iShotsFired++;

        g_Local.weapon.m_flAccuracy = ((g_Local.weapon.m_iShotsFired * g_Local.weapon.m_iShotsFired * g_Local.weapon.m_iShotsFired) / 200) + 0.6f;

        if (g_Local.weapon.m_flAccuracy > 1.65f)
            g_Local.weapon.m_flAccuracy = 1.65f;
        break;
    case WEAPON_MP5N:
        g_Local.weapon.m_bDelayFire = true;
        g_Local.weapon.m_iShotsFired++;

        g_Local.weapon.m_flAccuracy = ((g_Local.weapon.m_iShotsFired * g_Local.weapon.m_iShotsFired) / 220.1) + 0.45;

        if (g_Local.weapon.m_flAccuracy > 0.75f)
            g_Local.weapon.m_flAccuracy = 0.75f;
        break;
    case WEAPON_P90:
        g_Local.weapon.m_bDelayFire = true;
        g_Local.weapon.m_iShotsFired++;

        g_Local.weapon.m_flAccuracy = ((g_Local.weapon.m_iShotsFired * g_Local.weapon.m_iShotsFired) / 175) + 0.45f;

        if (g_Local.weapon.m_flAccuracy > 1)
            g_Local.weapon.m_flAccuracy = 1;
        break;
    case WEAPON_P228:
        if (g_Local.weapon.m_iShotsFired < 1)
            g_Local.weapon.m_iShotsFired++;
        else
            return;

        if (g_Local.weapon.prevtime != 0.0f)
        {
            g_Local.weapon.m_flAccuracy -= (0.325f - (g_Local.weapon.curtime - g_Local.weapon.prevtime)) * 0.3f;

            if (g_Local.weapon.m_flAccuracy > 0.9f)
                g_Local.weapon.m_flAccuracy = 0.9f;
            else if (g_Local.weapon.m_flAccuracy < 0.6f)
                g_Local.weapon.m_flAccuracy = 0.6f;
        }
        break;
    case WEAPON_SG550:
        if (g_Local.weapon.prevtime)
        {
            g_Local.weapon.m_flAccuracy = (g_Local.weapon.curtime - g_Local.weapon.prevtime) * 0.35f + 0.65f;

            if (g_Local.weapon.m_flAccuracy > 0.98f)
                g_Local.weapon.m_flAccuracy = 0.98f;
        }
        break;
    case WEAPON_SG552:
        g_Local.weapon.m_bDelayFire = true;
        g_Local.weapon.m_iShotsFired++;

        g_Local.weapon.m_flAccuracy = ((g_Local.weapon.m_iShotsFired * g_Local.weapon.m_iShotsFired * g_Local.weapon.m_iShotsFired) / 220) + 0.3f;

        if (g_Local.weapon.m_flAccuracy > 1.0f)
            g_Local.weapon.m_flAccuracy = 1.0f;
        break;
    case WEAPON_TMP:
        g_Local.weapon.m_bDelayFire = true;
        g_Local.weapon.m_iShotsFired++;

        g_Local.weapon.m_flAccuracy = ((g_Local.weapon.m_iShotsFired * g_Local.weapon.m_iShotsFired * g_Local.weapon.m_iShotsFired) / 200) + 0.55f;

        if (g_Local.weapon.m_flAccuracy > 1.4f)
            g_Local.weapon.m_flAccuracy = 1.4f;
        break;
    case WEAPON_UMP45:
        g_Local.weapon.m_bDelayFire = true;
        g_Local.weapon.m_iShotsFired++;

        g_Local.weapon.m_flAccuracy = ((g_Local.weapon.m_iShotsFired * g_Local.weapon.m_iShotsFired) / 210) + 0.5f;

        if (g_Local.weapon.m_flAccuracy > 1.0f)
            g_Local.weapon.m_flAccuracy = 1.0f;
        break;
    case WEAPON_USP:
        if (g_Local.weapon.m_iShotsFired < 1)
            g_Local.weapon.m_iShotsFired++;
        else
            return;

        if (g_Local.weapon.prevtime != 0.0f)
        {
            g_Local.weapon.m_flAccuracy -= (0.3f - (g_Local.weapon.curtime - g_Local.weapon.prevtime)) * 0.275f;

            if (g_Local.weapon.m_flAccuracy > 0.92f)
                g_Local.weapon.m_flAccuracy = 0.92f;
            else if (g_Local.weapon.m_flAccuracy < 0.6f)
                g_Local.weapon.m_flAccuracy = 0.6f;
        }
        break;
    case WEAPON_M3:
        if (g_Local.weapon.m_iShotsFired < 1)
            g_Local.weapon.m_iShotsFired++;
        break;
    case WEAPON_XM1014:
        if (g_Local.weapon.m_iShotsFired < 1)
            g_Local.weapon.m_iShotsFired++;
        break;
    }
     g_Local.weapon.prevtime = g_Local.weapon.curtime;
}

bool IsFreezePeriod(void)
{
	if (g_Local.weapon.iuser3 & PLAYER_FREEZE_TIME_OVER)
		return true;

	return false;
}

void ItemPostFrame(struct usercmd_s *cmd)
{
    static int iOldWeaponID = WEAPON_NONE;

    if (iOldWeaponID != g_Local.weapon.m_iWeaponID)
    {
        ResetAccuracy();
        iOldWeaponID = g_Local.weapon.m_iWeaponID;
    }

    if (cmd->buttons & IN_ATTACK && CanAttack())
    {
        // Can't shoot during the freeze period
        // Always allow firing in single player
        if (!IsFreezePeriod() && (/*m_pPlayer->m_bCanShoot && !m_pPlayer->m_bIsDefusing*/ g_Local.weapon.iuser3 & PLAYER_CAN_SHOOT))
        {
            PrimaryAttack();
        }
    }
    else if (g_Local.weapon.m_iInReload || cmd->buttons & IN_RELOAD)
    {
        // reload when reload is pressed, or if no buttons are down and weapon is empty.
        ResetAccuracy();
    }
    else if (!(cmd->buttons & (IN_ATTACK | IN_ATTACK2)))
    {
        // no fire buttons down

        // The following code prevents the player from tapping the firebutton repeatedly
        // to simulate full auto and retaining the single shot accuracy of single fire
        if (g_Local.weapon.m_bDelayFire)
        {
            g_Local.weapon.m_bDelayFire = false;

            if (g_Local.weapon.m_iShotsFired > 15)
            {
                g_Local.weapon.m_iShotsFired = 15;
            }

            g_Local.weapon.m_flDecreaseShotsFired = g_Local.weapon.curtime + 0.4f;
        }

        // if it's a pistol then set the shots fired to 0 after the player releases a button
        if (IsCurWeaponPistol())
        {
            g_Local.weapon.m_iShotsFired = 0;
        }
        else
        {
            if (g_Local.weapon.m_iShotsFired > 0 && g_Local.weapon.m_flDecreaseShotsFired < g_Local.weapon.curtime)
            {
                g_Local.weapon.m_flDecreaseShotsFired = g_Local.weapon.m_flDecreaseShotsFired + 0.0225f;
                g_Local.weapon.m_iShotsFired--;
            }
        }
    }
}

DWORD delay = 0;

void ItemPreFrame(struct local_state_s *from, struct local_state_s *to, struct usercmd_s *usercmd, int runfuncs, double time, unsigned int random_seed)
{
	if (runfuncs)
	{
		g_Local.weapon.random_seed = random_seed;
		g_Local.weapon.curtime = time;
		g_Local.weapon.m_iFlags = to->client.flags;
		g_Local.weapon.m_iWeaponID = to->client.m_iId;
		g_Local.weapon.m_iClip = to->weapondata[to->client.m_iId].m_iClip;
		g_Local.weapon.m_flNextPrimaryAttack = to->weapondata[to->client.m_iId].m_flNextPrimaryAttack;
		g_Local.weapon.m_flNextSecondaryAttack = to->weapondata[to->client.m_iId].m_flNextSecondaryAttack;
		g_Local.weapon.m_iInReload = (to->weapondata[to->client.m_iId].m_fInReload || !to->weapondata[to->client.m_iId].m_iClip);
		g_Local.weapon.m_iWeaponState = to->weapondata[to->client.m_iId].m_iWeaponState;
		g_Local.weapon.m_flNextAttack = to->client.m_flNextAttack;
		g_Local.weapon.iuser3 = to->client.iuser3;
	}
}

void DrawWeaponName()
{
    static model_s* pervious;

    cl_entity_s* ent = g_Engine.GetEntityByIndex(pmove->player_index + 1);
	if (cvar.visual_weapon_local && Sakura::Player::Local::IsAlive() && ent && ent->curstate.weaponmodel)
	{
		model_s* mdl = g_Studio.GetModelByIndex(ent->curstate.weaponmodel);

        if (mdl && mdl != pervious) Toast::Create(4, "Weapon: %s", Sakura::Strings::getfilename(mdl->name).c_str() + 2);
        pervious = mdl;
	}
}

bool IsCurWeaponSilenced()
{
    if (g_Local.weapon.m_iWeaponID == WEAPON_M4A1 && g_Local.weapon.m_iWeaponState & WPNSTATE_M4A1_SILENCED)
        return true;
    if (g_Local.weapon.m_iWeaponID == WEAPON_USP && g_Local.weapon.m_iWeaponState & WPNSTATE_USP_SILENCED)
        return true;

    return false;
}

bool IsCurWeaponInBurst()
{
    if (g_Local.weapon.m_iWeaponID == WEAPON_GLOCK18 && g_Local.weapon.m_iWeaponState & WPNSTATE_GLOCK18_BURST_MODE)
        return true;
    if (g_Local.weapon.m_iWeaponID == WEAPON_FAMAS && g_Local.weapon.m_iWeaponState & WPNSTATE_FAMAS_BURST_MODE)
        return true;

    return false;
}

bool IsLeftElite()
{
    if (g_Local.weapon.m_iWeaponID == WEAPON_ELITE && g_Local.weapon.m_iWeaponState & WPNSTATE_ELITE_LEFT)
        return true;

    return false;
}

int CurPenetration()
{
    return g_Local.weapon.iPenetration;
}

int CurBulletType()
{
    return g_Local.weapon.iBulletType;
}

float CurDistance()
{
    return g_Local.weapon.flPenetrationDistance;
}

float CurWallPierce()
{
    if (IsCurWeaponSilenced())
        return g_Local.weapon.flWallPierce2;
    else
        return g_Local.weapon.flWallPierce1;
}

int CurDamage()
{
    if (g_Local.weapon.m_iWeaponID == WEAPON_ELITE)
    {
        if (g_Local.weapon.m_iWeaponState & WPNSTATE_ELITE_LEFT)
            return g_Local.weapon.iDamage1;
        else
            return g_Local.weapon.iDamage2;
    }

    if (IsCurWeaponSilenced())
        return g_Local.weapon.iDamage2;
    else
        return g_Local.weapon.iDamage1;
}

bool IsCurWeaponKnife()
{
    if (g_Local.weapon.m_iWeaponID == WEAPON_KNIFE)
        return true;

    return false;
}

bool IsCurWeaponSniper()
{
    switch (g_Local.weapon.m_iWeaponID)
    {
    case WEAPON_AWP:
    case WEAPON_SCOUT:
    case WEAPON_G3SG1:
    case WEAPON_SG550:
        return true;
    }

    return false;
}

bool IsCurWeaponPistol()
{
    switch (g_Local.weapon.m_iWeaponID)
    {
    case WEAPON_GLOCK18:
    case WEAPON_USP:
    case WEAPON_P228:
    case WEAPON_DEAGLE:
    case WEAPON_ELITE:
    case WEAPON_FIVESEVEN:
        return true;
    }

    return false;
}

bool IsCurWeaponWall()
{
	switch (g_Local.weapon.m_iWeaponID)
	{
	case WEAPON_M4A1:
	case WEAPON_GALIL:
	case WEAPON_FAMAS:
	case WEAPON_AUG:
	case WEAPON_AK47:
	case WEAPON_SG552:
	case WEAPON_M249:
	case WEAPON_DEAGLE:
		return true;
	}

	return false;
}

bool IsCurWeaponRifle()
{
    switch (g_Local.weapon.m_iWeaponID)
    {
    case WEAPON_M4A1:
    case WEAPON_GALIL:
    case WEAPON_FAMAS:
    case WEAPON_AUG:
    case WEAPON_AK47:
    case WEAPON_SG552:
        return true;
    }

    return false;
}

bool IsCurWeaponShotGun()
{
    if (g_Local.weapon.m_iWeaponID == WEAPON_XM1014 || g_Local.weapon.m_iWeaponID == WEAPON_M3)
        return true;

    return false;
}

bool IsCurWeaponMachineGun()
{
    if (g_Local.weapon.m_iWeaponID == WEAPON_M249)
        return true;

    return false;
}

bool IsCurWeaponSubMachineGun()
{
    switch (g_Local.weapon.m_iWeaponID)
    {
    case WEAPON_TMP:
    case WEAPON_P90:
    case WEAPON_MP5N:
    case WEAPON_MAC10:
    case WEAPON_UMP45:
        return true;
    }

    return false;
}

int CurWeaponClassType() {
    if (IsCurWeaponKnife())
        return WEAPONCLASS_KNIFE;

    if (IsCurWeaponPistol())
        return WEAPONCLASS_PISTOL;

    if (IsCurWeaponNade())
        return WEAPONCLASS_GRENADE;

    if (IsCurWeaponSniper())
        return WEAPONCLASS_SNIPERRIFLE;

    if (IsCurWeaponRifle())
        return WEAPONCLASS_RIFLE;

    if (IsCurWeaponShotGun())
        return WEAPONCLASS_SHOTGUN;

    if (IsCurWeaponMachineGun())
        return WEAPONCLASS_MACHINEGUN;

    if (IsCurWeaponSubMachineGun())
        return WEAPONCLASS_SUBMACHINEGUN;

    return WEAPONCLASS_NONE;
}

bool IsCurWeaponGun(void)
{
    if (!IsCurWeaponNonAttack() && !IsCurWeaponKnife())
        return true;

    return false;
}

bool IsCurWeaponNonAttack()
{
    switch (g_Local.weapon.m_iWeaponID) {
    case WEAPON_HEGRENADE:
    case WEAPON_FLASHBANG:
    case WEAPON_C4:
    case WEAPON_SMOKEGRENADE:
        return true;
    default:
        return false;
    }
}

bool IsCurWeaponNade(void)
{
    if (g_Local.weapon.m_iWeaponID == WEAPON_HEGRENADE || g_Local.weapon.m_iWeaponID == WEAPON_FLASHBANG || g_Local.weapon.m_iWeaponID == WEAPON_SMOKEGRENADE)
        return true;

    return false;
}

bool IsCurWeaponC4(void)
{
    if (g_Local.weapon.m_iWeaponID == WEAPON_C4)
        return true;
    else
        return false;
}

bool CanAttack(void)
{
    if (g_Local.weapon.m_flNextPrimaryAttack <= 0.0f && !g_Local.weapon.m_iInReload && g_Local.weapon.m_flNextAttack <= 0.0f)
        return true;
    else
        return false;
}

CBasePlayerWeapon GetWeapon()
{
    return g_Local.weapon;
}
```

`sakura/source/helpers/weapons.h`:

```h
#ifndef _WEAPONS_
#define _WEAPONS_

extern uintptr_t m_dwInitPoint;

typedef struct CBasePlayerWeapon CBasePlayerWeapon_t;

struct CBasePlayerWeapon
{
	bool m_bDelayFire;
	unsigned int random_seed;
	int m_iWeaponState;
	int m_iFlags;
	int m_iClip;
	int m_iWeaponID;
	int m_iInReload;
	int iPenetration;
	int iBulletType;
	int iDamage1;
	int iDamage2;
	int m_iShotsFired;
	int iuser3;
	float prevtime;
	float curtime;
	float m_flDecreaseShotsFired;
	float m_flAccuracy;
	float m_flSpread;
	float m_flNextPrimaryAttack;
	float m_flNextSecondaryAttack;
	float m_flNextAttack;
	float flPenetrationDistance;
	float flWallPierce1;
	float flWallPierce2;
};

enum
{
	SEQUENCE_IDLE = 0,
	SEQUENCE_SHOOT = 1,
	SEQUENCE_RELOAD = 2,
	SEQUENCE_DIE = 4,
	SEQUENCE_THROW = 8,
	SEQUENCE_ARM_C4 = 16,
	SEQUENCE_SHIELD = 32,
	SEQUENCE_SHIELD_SIDE = 64
};

enum class ClipSizeType 
{
    P228_MAX_CLIP = 13,
    GLOCK18_MAX_CLIP = 20,
    SCOUT_MAX_CLIP = 10,
    XM1014_MAX_CLIP = 7,
    MAC10_MAX_CLIP = 30,
    AUG_MAX_CLIP = 30,
    ELITE_MAX_CLIP = 30,
    FIVESEVEN_MAX_CLIP = 20,
    UMP45_MAX_CLIP = 25,
    SG550_MAX_CLIP = 30,
    GALIL_MAX_CLIP = 35,
    FAMAS_MAX_CLIP = 25,
    USP_MAX_CLIP = 12,
    AWP_MAX_CLIP = 10,
    MP5N_MAX_CLIP = 30,
    M249_MAX_CLIP = 100,
    M3_MAX_CLIP = 8,
    M4A1_MAX_CLIP = 30,
    TMP_MAX_CLIP = 30,
    G3SG1_MAX_CLIP = 20,
    DEAGLE_MAX_CLIP = 7,
    SG552_MAX_CLIP = 30,
    AK47_MAX_CLIP = 30,
    P90_MAX_CLIP = 50,
};

enum WeaponIdType
{
    WEAPON_NONE,
    WEAPON_P228,
    WEAPON_GLOCK,
    WEAPON_SCOUT,
    WEAPON_HEGRENADE,
    WEAPON_XM1014,
    WEAPON_C4,
    WEAPON_MAC10,
    WEAPON_AUG,
    WEAPON_SMOKEGRENADE,
    WEAPON_ELITE,
    WEAPON_FIVESEVEN,
    WEAPON_UMP45,
    WEAPON_SG550,
    WEAPON_GALIL,
    WEAPON_FAMAS,
    WEAPON_USP,
    WEAPON_GLOCK18,
    WEAPON_AWP,
    WEAPON_MP5N,
    WEAPON_M249,
    WEAPON_M3,
    WEAPON_M4A1,
    WEAPON_TMP,
    WEAPON_G3SG1,
    WEAPON_FLASHBANG,
    WEAPON_DEAGLE,
    WEAPON_SG552,
    WEAPON_AK47,
    WEAPON_KNIFE,
    WEAPON_P90,
    WEAPON_SHIELDGUN = 99
};

enum WeaponState
{
    WPNSTATE_USP_SILENCED = 1,
    WPNSTATE_GLOCK18_BURST_MODE = 2,
    WPNSTATE_M4A1_SILENCED = 4,
    WPNSTATE_ELITE_LEFT = 8,
    WPNSTATE_FAMAS_BURST_MODE = 16,
    WPNSTATE_SHIELD_DRAWN = 32
};

enum WeaponClassType
{
    WEAPONCLASS_NONE,
    WEAPONCLASS_KNIFE,
    WEAPONCLASS_PISTOL,
    WEAPONCLASS_GRENADE,
    WEAPONCLASS_SUBMACHINEGUN,
    WEAPONCLASS_SHOTGUN,
    WEAPONCLASS_MACHINEGUN,
    WEAPONCLASS_RIFLE,
    WEAPONCLASS_SNIPERRIFLE,
};

enum Bullet
{
    BULLET_NONE,
    BULLET_PLAYER_9MM,
    BULLET_PLAYER_MP5,
    BULLET_PLAYER_357,
    BULLET_PLAYER_BUCKSHOT,
    BULLET_PLAYER_CROWBAR,
    BULLET_MONSTER_9MM,
    BULLET_MONSTER_MP5,
    BULLET_MONSTER_12MM,
    BULLET_PLAYER_45ACP,
    BULLET_PLAYER_338MAG,
    BULLET_PLAYER_762MM,
    BULLET_PLAYER_556MM,
    BULLET_PLAYER_50AE,
    BULLET_PLAYER_57MM,
    BULLET_PLAYER_357SIG,
};

enum Penerations
{
    WALL_PEN0,
    WALL_PEN1,
    WALL_PEN2,
};

void ItemPreFrame(struct local_state_s *from, struct local_state_s *to, struct usercmd_s *cmd, int runfuncs, double time, unsigned int random_seed);
void UpdateWeaponData();
void ItemPostFrame(struct usercmd_s *cmd);
void ResetAccuracy();
void Simulate(float &m_flAccuracy, float &m_flSpread);

bool CanAttack(void);

bool IsCurWeaponSilenced(void);
bool IsCurWeaponInBurst(void);
bool IsLeftElite(void);

bool IsCurWeaponGun(void); // Returns true if the current weapon is either a primary or secondary weapon
bool IsCurWeaponKnife(void); // Returns true if the current weapon is a knife
bool IsCurWeaponNonAttack(); // Returns true if the current weapon is not a gun or a knife
bool IsCurWeaponNade(void);
bool IsCurWeaponC4(void);
bool IsCurWeaponSniper(void);
bool IsCurWeaponPistol(void);
bool IsCurWeaponRifle(void);
bool IsCurWeaponShotGun(void);
bool IsCurWeaponMachineGun(void);
bool IsCurWeaponSubMachineGun(void);
bool IsFreezePeriod(void);
bool IsCurWeaponWall(void);

int CurWeaponClassType();
int CurPenetration(void);
int CurBulletType(void);
int CurDamage(void);
float CurWallPierce(void);
float CurDistance(void);
void DrawWeaponName();

CBasePlayerWeapon GetWeapon();

#endif
```

`sakura/source/main.cpp`:

```cpp
#include "client.h"
#include <Shlwapi.h>

bool Sakura::Unloading = false;
char Sakura::CheatDir[MAX_PATH];
char Sakura::HLDir[MAX_PATH];
HINSTANCE Sakura::Module;

void Sakura::Unload()
{
	bShowMenu = false;
	Sakura::Log::File("Sakura has been unloaded");

	if (g_pStudio)
		*g_pStudio = g_Studio;

	if (g_pClient)
		*g_pClient = g_Client;

	if (g_pEngine)
		*g_pEngine = g_Engine;

	if (g_pInterface)
		*g_pInterface = g_Interface;

	if (g_pStudioModelRenderer)
	{
		c_Offset.EnablePageWrite((DWORD)g_pStudioModelRenderer, sizeof(StudioModelRenderer_t));
		*g_pStudioModelRenderer = g_StudioModelRenderer;
		c_Offset.RestorePageProtection((DWORD)g_pStudioModelRenderer, sizeof(StudioModelRenderer_t));
	}

	if (c_Offset.HLType != RENDERTYPE_UNDEFINED)
	{
		g_pfnSteam_GSInitiateGameConnection = (decltype(g_pfnSteam_GSInitiateGameConnection))GetDestination(c_Offset.Steam_GSInitiateGameConnection());
		SetDestination(c_Offset.Steam_GSInitiateGameConnection(), (uintptr_t)g_pfnSteam_GSInitiateGameConnection);
	}

	DetourTransactionBegin();
	DetourUpdateThread(GetCurrentThread());

	DetourDetach(&(PVOID&)g_pSCR_UpdateScreen, SCR_UpdateScreen);
	DetourDetach(&(PVOID&)PreS_DynamicSound_s, Sakura::Esp::DynamicSound);
	DetourDetach(&(PVOID&)CL_Move_s, CL_Move);
	DetourDetach(&(PVOID&)Netchan_TransmitBits_s, Netchan_TransmitBits);
	DetourDetach(&(PVOID&)Snapshot_s, Sakura::ScreenShot::Snapshot);
	DetourDetach(&(PVOID&)Screenshot_s, Sakura::ScreenShot::Screenshot);

	DetourTransactionCommit();

	Sakura::Message::User::UnHook();

	Sakura::Sound::Free();
	Sakura::Lua::Close();

	Sakura::OpenGL::UnHook();

	if (!bOldOpenGL)
		ImGui_ImplOpenGL3_Shutdown();
	else
		ImGui_ImplOpenGL2_Shutdown();

	ImGui_ImplWin32_Shutdown();
	ImGui::DestroyContext();

	if (hGameWndProc)
		SetWindowLong(hGameWnd, GWL_WNDPROC, (LRESULT)(hGameWndProc));

	FreeLibraryAndExitThread(Sakura::Module, 0);
}

DWORD WINAPI Load()
{
	srand(time(NULL));

	while (!c_Offset.GetRendererInfo())
		Sleep(100);

	g_pClient = (cl_clientfunc_t*)c_Offset.ClientFuncs();

	g_pEngine = (cl_enginefunc_t*)c_Offset.EngineFuncs();

	g_pStudio = (engine_studio_api_t*)c_Offset.StudioFuncs();

	g_pInterface = (r_studio_interface_t*)c_Offset.FindInterface((DWORD)*g_pClient->HUD_GetStudioModelInterface);

	g_pStudioModelRenderer = (StudioModelRenderer_t*)c_Offset.FindStudioModelRenderer((DWORD)g_pInterface->StudioDrawModel);

	g_pSCR_UpdateScreen = (decltype(g_pSCR_UpdateScreen))c_Offset.FindUpdateScreen();
	PreS_DynamicSound_s = (decltype(PreS_DynamicSound_s))c_Offset.PreS_DynamicSound();
	CL_Move_s = (decltype(CL_Move_s))c_Offset.CL_Move();
	Netchan_TransmitBits_s = (decltype(Netchan_TransmitBits_s))c_Offset.FindNetchanTransmit();
	Snapshot_s = (decltype(Snapshot_s))c_Offset.FindSnapshot();
	Screenshot_s = (decltype(Screenshot_s))c_Offset.FindScreenshot();

	DetourTransactionBegin();
	DetourUpdateThread(GetCurrentThread());

	DetourAttach(&(PVOID&)g_pSCR_UpdateScreen, SCR_UpdateScreen);
	DetourAttach(&(PVOID&)PreS_DynamicSound_s, Sakura::Esp::DynamicSound);
	DetourAttach(&(PVOID&)CL_Move_s, CL_Move);
	DetourAttach(&(PVOID&)Netchan_TransmitBits_s, Netchan_TransmitBits);
	DetourAttach(&(PVOID&)Snapshot_s, Sakura::ScreenShot::Snapshot);
	DetourAttach(&(PVOID&)Screenshot_s, Sakura::ScreenShot::Screenshot);

	DetourTransactionCommit();

	c_Offset.GlobalTime();

	c_Offset.dwSpeedPointer = (DWORD)c_Offset.FindSpeed();

	c_Offset.PatchInterpolation();

	Sakura::File::Init();

	Sakura::Config::GetDefault();

	Sakura::Config::GetAll();

	LoadCvar();

	while (!g_Client.V_CalcRefdef)
		RtlCopyMemory(&g_Client, g_pClient, sizeof(cl_clientfunc_t));

	while (!g_Engine.V_CalcShake)
		RtlCopyMemory(&g_Engine, g_pEngine, sizeof(cl_enginefunc_t));

	while (!g_Studio.StudioSetupSkin)
		RtlCopyMemory(&g_Studio, g_pStudio, sizeof(engine_studio_api_t));

	while (!g_Interface.StudioDrawModel)
		RtlCopyMemory(&g_Interface, g_pInterface, sizeof(r_studio_interface_t));

	while (!g_StudioModelRenderer.StudioSlerpBones)
		RtlCopyMemory(&g_StudioModelRenderer, g_pStudioModelRenderer, sizeof(StudioModelRenderer_t));

	while (!pmove)
		pmove = (playermove_t*)c_Offset.FindPlayerMove();

	while (!Sakura::Message::User::Base)
		Sakura::Message::User::Base = c_Offset.FindUserMsgBase();

	if (c_Offset.HLType != RENDERTYPE_UNDEFINED)
	{
		g_pfnSteam_GSInitiateGameConnection = (decltype(g_pfnSteam_GSInitiateGameConnection))GetDestination(c_Offset.Steam_GSInitiateGameConnection());
		SetDestination(c_Offset.Steam_GSInitiateGameConnection(), (uintptr_t)&Steam_GSInitiateGameConnection_Hooked);
	}

	HookClientFunctions();

	HookStudioFunctions();

	HookStudiModelRendererFunctions();

	Sakura::Message::User::Hook();

	Sakura::Hands::InitTextures();

	Sakura::Hitboxes::InitPlayerModels();

	Sakura::OpenGL::Hook();

	Sakura::Lua::Reload();

	Sakura::Sound::Init();

	client_state = ((client_state_t*)*(unsigned int*)((unsigned int)(g_Engine.GetEntityByIndex) + 0x19));

	while (true)
	{
		if (Sakura::Unloading)
		{
			Sakura::Unloading = false;
			Sakura::Unload();
			break;
		}

		Sleep(100);
	}

	return NULL;
}

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpReserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		if (GetLastError() != ERROR_ALREADY_EXISTS)
		{
			DisableThreadLibraryCalls(hinstDLL);

			Sakura::Module = hinstDLL;

			GetModuleFileName(hinstDLL, Sakura::CheatDir, 255);
			PathRemoveFileSpec(Sakura::CheatDir);
			strcat_s(Sakura::CheatDir, "\\");

			GetModuleFileName(GetModuleHandle(NULL), Sakura::HLDir, 255);
			PathRemoveFileSpec(Sakura::HLDir);
			strcat_s(Sakura::HLDir, "\\");

			CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)Load, NULL, NULL, NULL);
		}
	}

	return TRUE;
}
```

`sakura/source/offsets/offset.cpp`:

```cpp
#include "../client.h"

AutoOffset c_Offset;

// thanks for bloodsharp
#define offsetof(st, m) ((size_t)&(((st *)0)->m))

#define CompareMemory(Buff1, Buff2, Size) __comparemem((const UCHAR *)Buff1, (const UCHAR *)Buff2, (UINT)Size)
#define FindMemoryClone(Start, End, Clone, Size) __findmemoryclone((const ULONG)Start, (const ULONG)End, (const ULONG)Clone, (UINT)Size)
#define FindReference(Start, End, Address) __findreference((const ULONG)Start, (const ULONG)End, (const ULONG)Address)

typedef void* Pointer;
typedef void** PPointer;
typedef unsigned Cardinal;
typedef unsigned* PCardinal;
typedef unsigned** PPCardinal;
typedef int** PPLongint;

bool AutoOffset::GetRendererInfo()
{
	DWORD GameUI = (DWORD)GetModuleHandle("GameUI.dll");
	DWORD vgui = (DWORD)GetModuleHandle("vgui.dll");
	DWORD vgui2 = (DWORD)GetModuleHandle("vgui2.dll");
	DWORD d3dim = (DWORD)GetModuleHandle("d3dim.dll");

	HwBase = (DWORD)GetModuleHandle("hw.dll"); // Hardware

	if (HwBase == NULL)
	{
		HwBase = (DWORD)GetModuleHandle("sw.dll"); // Software
		if (HwBase == NULL)
		{
			HwBase = (DWORD)GetModuleHandle(NULL); // Non-Steam?
			if (HwBase == NULL) // Invalid module handle.
			{
				Error("Invalid module handle, probably due to non-steam version of Counter-Strike 1.6.");
			}
			else
				HLType = RENDERTYPE_UNDEFINED;
		}
		else
			HLType = RENDERTYPE_SOFTWARE;
	}
	else
	{
		if (d3dim == NULL)
			HLType = RENDERTYPE_HARDWARE;
		else
			HLType = RENDERTYPE_D3D;
	}

	HwSize = (DWORD)GetModuleSize(HwBase);

	if (HwSize == NULL)
	{
		switch (HwSize)
		{
		case RENDERTYPE_HARDWARE: HwSize = 0x122A000; break;
		case RENDERTYPE_UNDEFINED: HwSize = 0x2116000; break;
		case RENDERTYPE_SOFTWARE: HwSize = 0xB53000; break;
		default:Error("Invalid renderer type");
		}
	}

	HwEnd = HwBase + HwSize - 1;

	ClBase = (DWORD)GetModuleHandle("client.dll");
	
	if (ClBase != NULL) {
		ClSize = (DWORD)GetModuleSize(ClBase);
		ClEnd = ClBase + ClSize - 1;
	}
	else {
		ClBase = HwBase;
		ClEnd = HwEnd;
		ClSize = HwSize;
	}

	if (GameUI != NULL)
	{
		UiBase = GameUI;
		UiSize = (DWORD)GetModuleSize(UiBase);
		UiEnd = UiBase + UiSize - 1;
	}

	HlBase = (DWORD)GetModuleHandle(NULL);
	HlSize = (DWORD)GetModuleSize(HlBase);
	HlEnd = HlBase + HlSize - 1;

	return (HwBase && ClBase && GameUI && vgui && vgui2 && HlBase);
}

unsigned AutoOffset::Absolute(DWORD Addr)
{
	return Cardinal(Addr) + *(PCardinal)(Addr)+4;
}

void AutoOffset::Error(char* fmt, ...)
{
	va_list va_alist;
	char buf[256];
	va_start(va_alist, fmt);
	vsprintf_s(buf, fmt, va_alist);
	va_end(va_alist);

	MessageBox(0, buf, "Error", MB_OK | MB_ICONERROR);
	Sakura::Log::File("Error: %s", buf);

	ExitProcess(0);
}

DWORD AutoOffset::GetModuleSize(const DWORD Address)
{
	return PIMAGE_NT_HEADERS(Address + (DWORD)PIMAGE_DOS_HEADER(Address)->e_lfanew)->OptionalHeader.SizeOfImage;
}

DWORD AutoOffset::FarProc(const DWORD Address, DWORD LB, DWORD HB)
{
	return ((Address < LB) || (Address > HB));
}

BOOL AutoOffset::__comparemem(const UCHAR *buff1, const UCHAR *buff2, UINT size)
{
	for (UINT i = 0; i < size; i++, buff1++, buff2++)
	{
		if ((*buff1 != *buff2) && (*buff2 != 0xFF))
			return FALSE;
	}
	return TRUE;
}

ULONG AutoOffset::__findmemoryclone(const ULONG start, const ULONG end, const ULONG clone, UINT size)
{
	for (ULONG ul = start; (ul + size) < end; ul++)
	{
		if (CompareMemory(ul, clone, size))
			return ul;
	}
	return NULL;
}

ULONG AutoOffset::__findreference(const ULONG start, const ULONG end, const ULONG address)
{
	UCHAR Pattern[5];
	Pattern[0] = 0x68;
	*(ULONG*)&Pattern[1] = address;
	return FindMemoryClone(start, end, Pattern, sizeof(Pattern)-1);
}

bool AutoOffset::EnablePageWrite(DWORD addr, DWORD size)
{
	return VirtualProtect((void*)addr, size, PAGE_EXECUTE_READWRITE, &dwOldPageProtection) != 0;
}

bool AutoOffset::RestorePageProtection(DWORD addr, DWORD size)
{
	bool ret = VirtualProtect((void*)addr, size, dwOldPageProtection, &dwOldPageProtection) != 0;
	FlushInstructionCache(GetCurrentProcess(), (void*)addr, size);
	return ret;
}

void native_memwrite(uintptr_t adr, uintptr_t ptr, int size)
{
	DWORD dwOldProtect;
	VirtualProtect(LPVOID(adr), size, PAGE_EXECUTE_READWRITE, &dwOldProtect);
	memcpy(LPVOID(adr), LPVOID(ptr), size);
	VirtualProtect(LPVOID(adr), size, dwOldProtect, &dwOldProtect);
}

DWORD FindPattern(PCHAR pattern, PCHAR mask, DWORD start, DWORD end, DWORD offset)
{
	int patternLength = lstrlenA(pattern);
	bool found = false;
	for (DWORD i = start; i < end - patternLength; i++)
	{
		found = true;
		for (unsigned int idx = 0; idx < patternLength; idx++)
		{
			if (mask[idx] == 'x' && pattern[idx] != *(PCHAR)(i + idx))
			{
				found = false;
				break;
			}
		}
		if (found)
		{
			return i + offset;
		}
	}
	return 0;
}

DWORD FindPattern(PCHAR pattern, DWORD start, DWORD end, DWORD offset)
{
	if (start > end)
	{
		DWORD reverse = end;
		end = start;
		start = reverse;
	}
	size_t patternLength = strlen(pattern);
	bool found = false;
	for (DWORD i = start; i < end - patternLength; i++)
	{
		found = true;

		for (size_t idx = 0; idx < patternLength; idx++)
		{
			if (pattern[idx] != *(PCHAR)(i + idx))
			{
				found = false;
				break;
			}
		}

		if (found)
			return i + offset;
	}
	return 0;
}

DWORD FindPush(DWORD start, DWORD end, PCHAR Message)
{
	char bPushAddrPattern[] = { 0x68 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 };
	DWORD Address = FindPattern(Message, start, end, 0);
	*(PDWORD)& bPushAddrPattern[1] = Address;
	Address = FindPattern((PCHAR)bPushAddrPattern, start, end, 0);
	return Address;
}

BOOL bCompareMemory(LPBYTE bAddress, LPBYTE bCode, UINT uSize, BOOL bPattern)
{
	UINT i;
	for (i = 0; i < uSize; i++, bCode++, bAddress++) {
		if ((*bAddress != *bCode) && (!bPattern || *bCode != 0xFF))
			return FALSE;
	}
	return TRUE;
}

PVOID AutoOffset::ClientFuncs()
{
	DWORD Old = NULL;
	PCHAR String = "ScreenFade";
	DWORD Address = (DWORD)FindMemoryClone(HwBase, HwEnd, String, 11);
	PVOID ClientPtr = (PVOID)*(PDWORD)(FindReference(HwBase, HwEnd, Address) + 0x13); // all patch

	if (FarProc((DWORD)ClientPtr, HwBase, HwEnd))
		Error("Couldn't find Client functions.");

	VirtualProtect(ClientPtr,sizeof(double),PAGE_READWRITE,&Old);

	return ClientPtr;
}

PVOID AutoOffset::EngineFuncs()
{
	DWORD Old = NULL;
	PVOID EnginePtr = (cl_enginefunc_t*)*(DWORD*)((DWORD)g_pClient->Initialize + 0x22); // old patch
	if (FarProc((DWORD)EnginePtr, HwBase, HwEnd) && FarProc((DWORD)EnginePtr, HlBase, HlEnd))
	{
		EnginePtr = (cl_enginefunc_t*)*(DWORD*)((DWORD)g_pClient->Initialize + 0x1C); // new patch
		if (FarProc((DWORD)EnginePtr, ClBase, ClEnd))
		{
			EnginePtr = (cl_enginefunc_t*)*(DWORD*)((DWORD)g_pClient->Initialize + 0x1D); // steam
			if (FarProc((DWORD)EnginePtr, ClBase, ClEnd))
			{
				EnginePtr = (cl_enginefunc_t*)*(DWORD*)((DWORD)g_pClient->Initialize + 0x37); // hl-steam
				if (FarProc((DWORD)EnginePtr, ClBase, ClEnd))
				{
					Error("Couldn't find Engine functions.");
				}
			}
		}
	}

	VirtualProtect(EnginePtr,sizeof(double),PAGE_READWRITE,&Old);

	return EnginePtr;
}

PVOID AutoOffset::StudioFuncs()
{
	DWORD Old = NULL;
	PVOID StudioPtr = (engine_studio_api_t*)*(DWORD*)((DWORD)g_pClient->HUD_GetStudioModelInterface + 0x30); // old patch
	if (FarProc((DWORD)StudioPtr, HwBase, HwEnd) && FarProc((DWORD)StudioPtr, HlBase, HlEnd))
	{
		StudioPtr = (engine_studio_api_t*)*(DWORD*)((DWORD)g_pClient->HUD_GetStudioModelInterface + 0x1A); // new patch / steam	

		if (FarProc((DWORD)StudioPtr, ClBase, ClEnd))
			Error("Couldn't find Studio functions.");
	}

	VirtualProtect(StudioPtr,sizeof(double),PAGE_READWRITE,&Old);

	return StudioPtr;
}

PUserMsg AutoOffset::FindUserMsgBase()
{
	DWORD Address = (DWORD)g_Engine.pfnHookUserMsg;

	DWORD UserMsgBase = Absolute(FindPattern("\x52\x50\xE8\xFF\xFF\xFF\xFF\x83", "xxx????x", Address, Address + 0x32, 3));

	if (FarProc(UserMsgBase, HwBase, HwEnd))
		Error("Couldn't find User message base.");

	UserMsgBase = FindPattern("\xFF\xFF\xFF\x0C\x56\x8B\x35\xFF\xFF\xFF\xFF\x57", "???xxxx????x", UserMsgBase, UserMsgBase + 0x32, 7);

	if (FarProc(UserMsgBase, HwBase, HwEnd))
		Error("Couldn't find User message base.");

	return PUserMsg(**(PDWORD*)UserMsgBase);
}

DWORD AutoOffset::CL_Move(void)
{
	DWORD Address = FindPattern(
		"\x56\x57\x33\xFF\x3B\xC7\x0F\x84\x00\x00\x00\x00\x83\xF8\x01\x0F\x84\x00\x00\x00\x00\x83\xF8\x02\x0F\x84\x00\x00\x00\x00\x83\xF8\x03\x75\x22",
		/*xxxxxxx????xxxxx????xxxxx????xxxxx*/XorStr<0xC3, 35, 0x8D75FE5A>("\xBB\xBC\xBD\xBE\xBF\xB0\xB1\xF5\xF4\xF3\xF2\xB6\xB7\xA8\xA9\xAA\xEC\xEB\xEA\xE9\xAF\xA0\xA1\xA2\xA3\xE3\xE2\xE1\xE0\x98\x99\x9A\x9B\x9C" + 0x8D75FE5A).s,
		HwBase, HwEnd, 0);

	if (FarProc((DWORD)Address, HwBase, HwEnd))
		Error(/*Couldn't find CL_Move.*/XorStr<0x5D, 23, 0x7FE973E9>("\x1E\x31\x2A\x0C\x05\x0C\x44\x10\x45\x00\x0E\x06\x0D\x4A\x28\x20\x32\x23\x00\x06\x14\x5C" + 0x7FE973E9).s);
	else 
	{
		Address = FindPattern(
			"\xC3\x90",
			/*xx*/XorStr<0xB7, 3, 0x8514882F>("\xCF\xC0" + 0x8514882F).s,
			Address - 0x12, HwEnd, 0x2);

		if (FarProc((DWORD)Address, HwBase, HwEnd))
			Error(/*Couldn't find CL_Move. 2*/XorStr<0xEA, 25, 0x7B00429C>("\xA9\x84\x99\x81\x8A\x81\xD7\x85\xD2\x95\x9D\x9B\x92\xD7\xBB\xB5\xA5\xB6\x93\x8B\x9B\xD1\x20\x33" + 0x7B00429C).s);
	}

	return Address;
}

void AutoOffset::GlobalTime()
{
	dwSendPacketPointer = FindPattern(
		"\x75\x13\xD9\x05\x00\x00\x00\x00\xD8\x1D\x00\x00\x00\x00\xDF\xE0\xF6\xC4\x00\x00\x00\xD9\x05\x00\x00\x00\x00\xDC\x1D\x00\x00\x00\x00\xDF\xE0\xF6\xC4\x41",
		"xxxx????xx????xxxx???xx????xx????xxxxx",
		HwBase, HwEnd, 0x1b) + 2;

	if (FarProc(dwSendPacketPointer, HwBase, HwEnd))
		Error("Couldn't find Global time.");

	dwSendPacketBackup = *((uintptr_t *)(dwSendPacketPointer));

	EnablePageWrite(dwSendPacketPointer, sizeof(DWORD));
}

DWORD AutoOffset::FindUpdateScreen()
{
	// \x55\x8B\xEC\x83\xEC\x10\xA1\xFF\xFF\xFF\xFF\x56\x33\xF6\x3B\xC6\x0F xxxxxxx????xxxxxx
	// \x55\x8B\xEC\x83\xEC\x10\xA1\xFF\xFF\xFF\xFF\x56\x33\xF6\x3B\xC6\x0F\x85\xFF\xFF\xFF\xFF original xxxxxxx????xxxxxxx?????
	DWORD Address = FindPattern(
		"\x55\x8B\xEC\x83\xEC\x10\xA1\xFF\xFF\xFF\xFF\x56\x33\xF6\x3B\xC6\x0F\x85\xFF\xFF\xFF\xFF",
		"xxxxxxx????xxxxxxx?????",
		HwBase, HwEnd, 0);

	if (FarProc(Address, HwBase, HwEnd))
		Error("Couldn't find Update screen.");

	return Address;
}

DWORD AutoOffset::FindClientState()
{
	DWORD Address = FindPattern(
		"\x8D\x34\x95\xFF\xFF\xFF\xFF\x56\xC7\x46\x38\x00\x00\x80\xBF\x89\x7E\x40\x89\x7E\x44\x89\x7E\x48",
		"xxx????xxxxxxxxxxxxxxxxx",
		HwBase, HwEnd, 0);
	
	if (FarProc(Address, HwBase, HwEnd))
		Error("Couldn't find Client state.");

	Address = *(DWORD*)(Address + 3);

	Address = (uintptr_t)(client_state_t*)(Address - offsetof(client_state_t, commands));

	return Address;
}

DWORD AutoOffset::FindClientStatic()
{
	DWORD Address = FindPattern("\x55\x8B\xEC\xB8\x00\x00\x00\x00\xE8\x00\x00\x00\x00\x53\x8B\x5D\x08\x8D\x8D\x00\x00\x00\x00\x33\xC0\x89\x4D\xE0\x8A\x4B\x60\x56\x57\xF6\xC1\x02\x89\x45\xCC\xC7\x45\x00\x00\x00\x00\x00\xC7\x45\x00\x00\x00\x00\x00\x89\x45\xE8\x66\x89\x45\xDC\x74\x29\x83\xEC\x14\x8D\x73\x04\xB9\x00\x00\x00\x00\x8B\xFC\xF3\xA5\xE8\x00\x00\x00\x00\x50\x68\x00\x00\x00\x00\xE8\x00\x00\x00\x00\x83\xC4\x1C\x5F\x5E\x5B\x8B\xE5\x5D\xC3",
		"xxxx????x????xxxxxx????xxxxxxxxxxxxxxxxxx?????xx?????xxxxxxxxxxxxxxxx????xxxxx????xx????x????xxxxxxxxxx",
		HwBase, HwEnd, 0);

	if (FarProc(Address, HwBase, HwEnd))
		Error("Couldn't find Client static.");

	return Address;
}

DWORD AutoOffset::FindNetchanTransmit()
{
	DWORD Address = FindPattern("%s:Outgoing message overflow", HwBase, HwEnd, 0);
	Address = FindReference(HwBase, HwEnd, Address) - 0x5B;

	if (FarProc(Address, HwBase, HwEnd))
		Error("Couldn't find Netchan transmit.");

	int limit = 0;

	while (*(PBYTE)Address == 0x90) {
		Address += 0x1;
		limit += 1;
		if (limit > 30) break;
	}

	return Address;
}

//DWORD AutoOffset::FindFireBullets()
//{
//	// \x81\xEC\x00\x00\x00\x00\xB8\x00\x00\x00\x00
//	// xx????x????
//
//	// \x81\xEC\x00\x00\x00\x00\xB8\x00\x00\x00\x00\x53\x8B\x9C\x24\x00\x00\x00\x00
//	// xx????x????xxxx????
//	DWORD Address = FindPattern("\x81\xEC\x00\x00\x00\x00\xB8\x00\x00\x00\x00\x53\x8B\x9C\x24\x00\x00\x00\x00",
//		"xx????x????xxxx????", ClBase, ClEnd, 0);
//
//	if (FarProc(Address, ClBase, ClEnd))
//		Error(/*Couldn't find %s.*/XorStr<0x1B, 18, 0xAB2D5E11>("\x58\x73\x68\x72\x7B\x4E\x06\x56\x03\x42\x4C\x48\x43\x08\x0C\x59\x05" + 0xAB2D5E11).s, __FUNCTION__);
//
//	return Address;
//}

DWORD AutoOffset::FindSpeed()
{
	DWORD Address = FindPattern("Texture load: %6.1fms", HwBase, HwEnd, 0);
	PVOID SpeedPtr = (PVOID)*(DWORD*)(FindReference(HwBase, HwEnd, Address) - 7);

	if (FarProc((DWORD)SpeedPtr, HwBase, HwEnd))
		Error("Couldn't find Speed.");
	else
		EnablePageWrite((DWORD)SpeedPtr, sizeof(double));

	return (DWORD)SpeedPtr;
}

PVOID AutoOffset::FindPlayerMove()
{
	DWORD Address = FindPattern("ScreenFade", HwBase, HwEnd, 0);
	PVOID Ptr = (PVOID)*(PDWORD)(FindReference(HwBase, HwEnd, Address) + 0x18);

	if (FarProc((DWORD)Ptr, HwBase, HwEnd))
		Error("Couldn't find Player move.");

	return Ptr;
}

DWORD AutoOffset::FindStudioModelRenderer(DWORD StudioDrawModel)
{
	PDWORD retAddress = (*(PDWORD*)((DWORD)StudioDrawModel + 0x05));

	if (retAddress) return *retAddress;

	Error("Couldn't find Studio model renderer.");
}

void AutoOffset::PatchInterpolation()
{
	static bool patched = false;

	if (patched)
		return;

	DWORD Address = FindPush(HwBase, HwEnd, "cl_updaterate minimum is %f") - 0x18;

	native_memwrite(Address, (uintptr_t)"\xEB", 1);

	Address = FindPush(HwBase, HwEnd, "cl_updaterate maximum is %f") - 0x18;

	native_memwrite(Address, (uintptr_t)"\xEB", 1);

	Address = FindPush(HwBase, HwEnd, "ex_interp forced up to %i msec\n");
	Address = FindPattern("\x7D", Address - 0x9, Address, 0);

	native_memwrite(Address, (uintptr_t)"\xEB", 1);

	Address = FindPush(HwBase, HwEnd, "ex_interp forced down to %i msec\n") - 0x5;

	native_memwrite(Address, (uintptr_t)"\xEB", 1);

	patched = true;
}

DWORD AutoOffset::PreS_DynamicSound()
{
	DWORD Address = Absolute(FindPush(HwBase, HwEnd, "CL_Parse_Sound: ent = %i, cl.max_edicts %i") - 0x10);

	if (FarProc(Address, HwBase, HwEnd))
	{
		Address = Absolute(FindPush(HwBase, HwEnd, "CL_Parse_Sound: ent = %i, cl.max_edicts %i") - 0x11);

		if (FarProc(Address, HwBase, HwEnd))
			Error("Couldn't find DynamicSound.");

		return Address;
	}

	return Address;
}

DWORD AutoOffset::Steam_GSInitiateGameConnection()
{
	DWORD Address = FindPattern("%c%c%c%cconnect %i %i \"%s\" \"%s\"\n", HwBase, HwEnd, 0);

	Address = FindPattern((PCHAR)"\xE8\xFF\xFF\xFF\xFF\x83\xC4\x1C\x8B\xF8",
		(PCHAR)"x????xxxxx",
		HwBase, HwEnd, 0);

	return Address;
}

DWORD FindCodeAddress(DWORD dwStart, DWORD dwEnd, LPBYTE bCode, UINT CodeSize, INT OpcodeNum, BOOL bPattern)
{
	DWORD i;
	for (i = dwStart; (i + CodeSize) < dwEnd; i++)
	{
		if (bCompareMemory((LPBYTE)i, bCode, CodeSize, bPattern))
			return (DWORD)(i + OpcodeNum);
	}
	return 0;
}

DWORD AutoOffset::FindInterface(DWORD GetStudioModelInterfaceAddress)
{
	BYTE studioPattern[] = { 0xbf,0xff,0xff,0xff,0xff,0xc7 };
	PDWORD retAddress = (PDWORD)FindCodeAddress(GetStudioModelInterfaceAddress, GetStudioModelInterfaceAddress + 0x50, studioPattern, 6, 7, TRUE);
	if (retAddress)
	{
		return *retAddress;
	}
	Error("Couldn't find Interface.");
}

int* AutoOffset::FindSkyTexNumber()
{
	static DWORD Address;
	if (!Address)
	{
		Address = FindPattern("\xD9\x05\xFF\xFF\xFF\xFF\xD8\x4D\xFF\xDE\xC1\xDC\x1D\xFF\xFF\xFF\xFF\xDF\xE0\xF6\xC4\xFF\x0F\xFF\xFF\xFF\xFF\xFF\x8B\x04\xB5\xFF\xFF\xFF\xFF\x8B\x0C\x85\xFF\xFF\xFF\xFF\xFF\xE8\xFF\xFF\xFF\xFF",
			"xx????xx?xxxx????xxxx?x?????xxx????xxx?????x????",
			HwBase, HwBase + HwSize, 0) + 0x26;

		if (FarProc((DWORD)Address, HwBase, HwEnd))
		{
			Address = FindPattern("\xD9\x05\xFF\xFF\xFF\xFF\xD8\x4C\x24\xFF\xDE\xC1\xDC\x1D\xFF\xFF\xFF\xFF\xDF\xE0\xF6\xC4\xFF\x0F\xFF\xFF\xFF\xFF\xFF\x8B\x04\xB5\xFF\xFF\xFF\xFF\x8B\x0C\x85\xFF\xFF\xFF\xFF\xFF\xE8\xFF\xFF\xFF\xFF",
				"xx????xxx?xxxx????xxxx?x?????xxx????xxx?????x????",
				HwBase, HwEnd, 0) + 0x27;

			if (FarProc((DWORD)Address, HwBase, HwEnd))
				Error("Couldn't find Sky texture.");
		}
	}

	return (int*)*(DWORD*)(Address);
}

DWORD AutoOffset::FindScreenshot()
{
	DWORD Address = FindPush(HwBase, HwEnd, "HalfLife__.tga") - 0x45;

	if (FarProc(Address, HwBase, HwEnd))
		Error("Couldn't find Screenshot.");

	return Address;
}

DWORD AutoOffset::FindSnapshot()
{
	DWORD Address = FindPush(HwBase, HwEnd, "%s%04d.bmp") - 0x46;

	if (FarProc(Address, HwBase, HwEnd))
		Error("Couldn't find Snapshot.");

	return Address;
}
```

`sakura/source/offsets/offset.h`:

```h
#ifndef _OFFSET_
#define _OFFSET_

#define RENDERTYPE_UNDEFINED	0
#define RENDERTYPE_SOFTWARE		1
#define RENDERTYPE_HARDWARE		2
#define RENDERTYPE_D3D			3

class AutoOffset
{
private:
	DWORD dwOldPageProtection;

public:
	DWORD HwBase, HwSize, HwEnd;
	DWORD ClBase, ClSize, ClEnd;
	DWORD UiBase, UiSize, UiEnd;
	DWORD HlBase, HlSize, HlEnd;

	DWORD dwSendPacketPointer, dwSendPacketBackup, dwSpeedPointer;

	BOOL __comparemem(const UCHAR *buff1, const UCHAR *buff2, UINT size);
	ULONG __findmemoryclone(const ULONG start, const ULONG end, const ULONG clone, UINT size);
	ULONG __findreference(const ULONG start, const ULONG end, const ULONG address);

	DWORD FarProc(const DWORD Address, DWORD LB, DWORD HB);
	BYTE HLType;

	void GlobalTime(); 
	DWORD FindUpdateScreen();
	void Error(char* fmt, ...);
	void PatchInterpolation(void);
	unsigned Absolute(DWORD Addr);

	bool GetRendererInfo();
	bool EnablePageWrite(DWORD addr, DWORD size);
	bool RestorePageProtection(DWORD addr, DWORD size);
	
	int* FindSkyTexNumber();

	PVOID ClientFuncs();
	PVOID EngineFuncs();
	PVOID StudioFuncs();
	PVOID FindPlayerMove(void);
	DWORD FindStudioModelRenderer(DWORD StudioDrawModel);
	DWORD GetModuleSize(const DWORD Address);
	DWORD CL_Move(void);
	DWORD FindSpeed(void);
	DWORD PreS_DynamicSound(void);
	DWORD Steam_GSInitiateGameConnection(void);
	DWORD FindInterface(DWORD GetStudioModelInterfaceAddress);
	DWORD FindClientState();
	DWORD FindClientStatic();
	DWORD FindNetchanTransmit();
	//DWORD FindFireBullets();
	PUserMsg FindUserMsgBase();
	DWORD FindScreenshot();
	DWORD FindSnapshot();
};
extern AutoOffset c_Offset;

#endif
```

`sakura/source/opengl.cpp`:

```cpp
#include "client.h"

glBegin_t pglBegin = NULL;
wglSwapBuffers_t pwglSwapBuffers = NULL;
glClear_t pglClear = NULL;
glColor4f_t pglColor4f = NULL;
glVertex3fv_t pglVertex3fv = NULL;

bool bSmoke = false;

void APIENTRY Hooked_glBegin(GLenum mode)
{
	if (cvar.visual_nosmoke)
	{
		if (mode == GL_QUADS)
		{
				GLfloat smokecol[4];

				glGetFloatv(GL_CURRENT_COLOR, smokecol);

				if ((smokecol[0] == smokecol[1]) && (smokecol[0] == smokecol[2]) && (smokecol[0] != 0.0) && smokecol[0] != 1.0)
					bSmoke = true;
				else
					bSmoke = false;
		}
	}

	pglBegin(mode);
}

void APIENTRY Hooked_glVertex3fv(GLfloat* v)
{
	if(bSmoke)
		return;

	pglVertex3fv(v);
}

BOOL APIENTRY Hooked_wglSwapBuffers(HDC hdc)
{
	if (hdc)
		HookImGui(hdc);

	return pwglSwapBuffers(hdc);
}

void APIENTRY Hooked_glClear(GLbitfield mask)
{
	if (mask == GL_DEPTH_BUFFER_BIT)
	{
		mask |= GL_DEPTH_BUFFER_BIT;
		glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
	}

	pglClear(mask);
}

void APIENTRY Hooked_glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
{
	if (Sakura::Chams::world)
	{
		if (cvar.chams_world == 1 || cvar.chams_world == 3)
			red = Sakura::Chams::worldColor.r, green = Sakura::Chams::worldColor.g, blue = Sakura::Chams::worldColor.b;
		if (cvar.chams_world == 2)
			red = Sakura::Chams::worldColor.r * red, green = Sakura::Chams::worldColor.g * green, blue = Sakura::Chams::worldColor.b * blue;
	}
	
	if (Sakura::Chams::viewmodel)
	{
		if (cvar.chams_view_model == 1 || cvar.chams_view_model == 3)
			red = Sakura::Chams::viewmodelColor.r, green = Sakura::Chams::viewmodelColor.g, blue = Sakura::Chams::viewmodelColor.b;
		if (cvar.chams_view_model == 2)
			red = Sakura::Chams::viewmodelColor.r * red, green = Sakura::Chams::viewmodelColor.g * green, blue = Sakura::Chams::viewmodelColor.b * blue;
	}

	if (Sakura::Chams::player)
	{
		if (cvar.chams_player == 1 || cvar.chams_player == 3)
			red = Sakura::Chams::playerColor.r, green = Sakura::Chams::playerColor.g, blue = Sakura::Chams::playerColor.b;
		if (cvar.chams_player == 2)
			red = Sakura::Chams::playerColor.r * red, green = Sakura::Chams::playerColor.g * green, blue = Sakura::Chams::playerColor.b * blue;
	}
	
	if (Sakura::Chams::playerFake)
	{
		if (cvar.misc_backtrack_chams == 1 || cvar.misc_backtrack_chams == 3)
			red = Sakura::Chams::playerFakeColor.r, green = Sakura::Chams::playerFakeColor.g, blue = Sakura::Chams::playerFakeColor.b;
		if (cvar.misc_backtrack_chams == 2)
			red = Sakura::Chams::playerFakeColor.r * red, green = Sakura::Chams::playerFakeColor.g * green, blue = Sakura::Chams::playerFakeColor.b * blue;
	}

	if (Sakura::Chams::localFakePlayer)
	{
		if (cvar.visual_fakelag_history_local_chams == 1 || cvar.visual_fakelag_history_local_chams == 3)
			red = Sakura::Chams::localFakePlayerColor.r, green = Sakura::Chams::localFakePlayerColor.g, blue = Sakura::Chams::localFakePlayerColor.b;
		if (cvar.visual_fakelag_history_local_chams == 2)
			red = Sakura::Chams::localFakePlayerColor.r * red, green = Sakura::Chams::localFakePlayerColor.g * green, blue = Sakura::Chams::localFakePlayerColor.b * blue;
	}

	if (Sakura::Chams::localPlayer)
	{
		if (cvar.chams_local == 1 || cvar.chams_local == 3)
			red = Sakura::Chams::localPlayerColor.r, green = Sakura::Chams::localPlayerColor.g, blue = Sakura::Chams::localPlayerColor.b;
		if (cvar.chams_local == 2)
			red = Sakura::Chams::localPlayerColor.r * red, green = Sakura::Chams::localPlayerColor.g * green, blue = Sakura::Chams::localPlayerColor.b * blue;
	}

	pglColor4f(red, green, blue, alpha);
}

void Sakura::OpenGL::Hook()
{
	if (g_Studio.IsHardware() != 1)
		c_Offset.Error("Please run game in OpenGL renderer mode");

	const char* szOpenGLModuleName = "opengl32.dll";

	DetourTransactionBegin();
	DetourUpdateThread(GetCurrentThread());

	pwglSwapBuffers = (decltype(pwglSwapBuffers))DetourFindFunction(szOpenGLModuleName, "wglSwapBuffers");
	pglClear = (decltype(pglClear))DetourFindFunction(szOpenGLModuleName, "glClear");
	pglColor4f = (decltype(pglColor4f))DetourFindFunction(szOpenGLModuleName, "glColor4f");
	pglVertex3fv = (decltype(pglVertex3fv))DetourFindFunction(szOpenGLModuleName, "glVertex3fv");

	DetourAttach(&(PVOID&)pwglSwapBuffers, Hooked_wglSwapBuffers);
	DetourAttach(&(PVOID&)pglClear, Hooked_glClear);
	DetourAttach(&(PVOID&)pglColor4f, Hooked_glColor4f);
	DetourAttach(&(PVOID&)pglVertex3fv, Hooked_glVertex3fv);

	DetourTransactionCommit();
}

void Sakura::OpenGL::UnHook()
{
	DetourTransactionBegin();
	DetourUpdateThread(GetCurrentThread());

	DetourDetach(&(PVOID&)pwglSwapBuffers, Hooked_wglSwapBuffers);
	DetourDetach(&(PVOID&)pglClear, Hooked_glClear);
	DetourDetach(&(PVOID&)pglColor4f, Hooked_glColor4f);
	DetourDetach(&(PVOID&)pglVertex3fv, Hooked_glVertex3fv);

	DetourTransactionCommit();
}
```

`sakura/source/opengl.h`:

```h
#ifndef _OPENGL_
#define _OPENGL_

typedef void (APIENTRY* glBegin_t)(GLenum);
typedef BOOL(APIENTRY* wglSwapBuffers_t)(HDC  hdc);
typedef void (APIENTRY* glClear_t)(GLbitfield mask);
typedef void (APIENTRY* glColor4f_t)(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
typedef void(__stdcall* glReadPixels_t)(GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, GLvoid*);
typedef void (APIENTRY* glVertex3fv_t)(GLfloat* v);

namespace Sakura
{
	namespace OpenGL
	{
		void Hook();
		void UnHook();
	};
};

extern glBegin_t pglBegin;
extern wglSwapBuffers_t pwglSwapBuffers;
extern glClear_t pglClear;
extern glColor4f_t pglColor4f;
extern glReadPixels_t pglReadPixels;
extern glVertex3fv_t pglVertex3fv;

#endif
```

`sakura/source/other/smth/defs.h`:

```h
#ifndef DEFS_H
#define DEFS_H

#ifndef VectorSubtract
#define VectorSubtract(a,b,c) {(c)[0]=(a)[0]-(b)[0];(c)[1]=(a)[1]-(b)[1];(c)[2]=(a)[2]-(b)[2];}
#endif

#ifndef VectorAdd
#define VectorAdd(a,b,c) {(c)[0]=(a)[0]+(b)[0];(c)[1]=(a)[1]+(b)[1];(c)[2]=(a)[2]+(b)[2];}
#endif

#ifndef VectorCopy
#define VectorCopy(a,b) {(b)[0]=(a)[0];(b)[1]=(a)[1];(b)[2]=(a)[2];}
#endif

#ifndef VectorClear
#define VectorClear(a) { a[0]=0.0;a[1]=0.0;a[2]=0.0;}
#endif

#ifndef DotProd
#define DotProd(x,y) ((x)[0]*(y)[0]+(x)[1]*(y)[1]+(x)[2]*(y)[2])
#endif

#ifndef VectorScale
#define VectorScale(a,b,c) {(c)[0]=(b)*(a)[0];(c)[1]=(b)*(a)[1];(c)[2]=(b)*(a)[2];}
#endif

#ifndef POW
#define POW(x) ((x)*(x))
#endif

#ifndef VectorDistance
#define VectorDistance(a,b) sqrt(POW((a)[0]-(b)[0])+POW((a)[1]-(b)[1])+POW((a)[2]-(b)[2]))
#endif

#ifndef VectorLength
#define VectorLength(a) sqrt(POW((a)[0])+POW((a)[1])+POW((a)[2]))
#endif

// player data iuser3
#define PLAYER_CAN_SHOOT		(1<<0)
#define PLAYER_FREEZE_TIME_OVER		(1<<1)
#define PLAYER_IN_BOMB_ZONE		(1<<2)
#define PLAYER_HOLDING_SHIELD		(1<<3)

#define RAD2DEG( x )  ( (float)(x) * (float)(180.f / M_PI) )
#define DEG2RAD( x ) ( (float)(x) * (float)(M_PI / 180.f) )
#define VectorMul(vec,num,res){(res)[0]=(vec)[0]*(num);(res)[1]=(vec)[1]*(num);(res)[2]=(vec)[2]*(num);}

#define NUMBLOOPS 50.0f
#define TIMEALIVE 3.00f
#define OLDDAMPER 1.75f 
#define NEWDAMPER 0.75f
#define SVGRAVITY 3.75f
#define FLOORSTOP 0.20f

#define PM_DEAD_VIEWHEIGHT -8
#define PM_VEC_DUCK_VIEW 12
#define PM_VEC_VIEW	17

#define OBS_NONE				0
#define OBS_CHASE_LOCKED		1
#define OBS_CHASE_FREE			2
#define OBS_ROAMING				3
#define OBS_IN_EYE				4
#define OBS_MAP_FREE			5
#define OBS_MAP_CHASE			6

typedef float BoneMatrix_t[MAXSTUDIOBONES][3][4];

#define CHECKGUNOFFSET(a,b) if(!strcmp(a,gunname)) return b;

#define GL_MAJOR_VERSION                  0x821B
#define GL_MINOR_VERSION                  0x821C

#define GAITSEQUENCE_STAND 1
#define GAITSEQUENCE_DUCK 2
#define GAITSEQUENCE_WALK 3
#define GAITSEQUENCE_RUNNING 4
#define GAITSEQUENCE_DUCKMOVE 5
#define GAITSEQUENCE_JUMP 6

#define DotDist(a,b) sqrt(POW((a)[0]-(b)[0])+POW((a)[1]-(b)[1])+POW((a)[2]-(b)[2]))

#define MOD_HLDM	1
#define MOD_CS		2

#define VIP			            0
#define REDSOUND 1
#define BLUESOUND 2
#define GREENSOUND 3
#define REDARROW 4
#define BLUEARROW 5
#define BACKGRND 6

#endif

```

`sakura/source/other/smth/gl3winit.cpp`:

```cpp
#include "../libs/opengl/gl3w.h"

void ImplementGl3()
{
	gl3wInit();
}
```

`sakura/source/other/smth/gl3winit.h`:

```h
#ifndef _GL3WINIT_
#define _GL3WINIT_

void ImplementGl3();

#endif
```

`sakura/source/other/smth/interface.cpp`:

```cpp
#include "../../client.h"

CreateInterfaceFn CaptureFactory(char* FactoryModule)
{
	CreateInterfaceFn Interface = 0;

	while (!Interface)
	{
		HMODULE hFactoryModule = GetModuleHandleA(FactoryModule);

		if (hFactoryModule)
		{
			Interface = (CreateInterfaceFn)(GetProcAddress(hFactoryModule, CREATEINTERFACE_PROCNAME));
		}

		Sleep(100);
	}

	return Interface;
}

void *CaptureInterface(CreateInterfaceFn Interface, char* InterfaceName)
{
	PVOID dwPointer = nullptr;

	while (!dwPointer)
	{
		dwPointer = (PVOID)(Interface(InterfaceName, 0));

		Sleep(100);
	}

	return dwPointer;
}
```

`sakura/source/other/smth/interface.h`:

```h
//========= Copyright ?1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

// This header defines the interface convention used in the valve engine.
// To make an interface and expose it:
//    1. Derive from IBaseInterface.
//    2. The interface must be ALL pure virtuals, and have no data members.
//    3. Define a name for it.
//    4. In its implementation file, use EXPOSE_INTERFACE or EXPOSE_SINGLE_INTERFACE.

// Versioning
// There are two versioning cases that are handled by this:
// 1. You add functions to the end of an interface, so it is binary compatible with the previous interface. In this case, 
//    you need two EXPOSE_INTERFACEs: one to expose your class as the old interface and one to expose it as the new interface.
// 2. You update an interface so it's not compatible anymore (but you still want to be able to expose the old interface 
//    for legacy code). In this case, you need to make a new version name for your new interface, and make a wrapper interface and 
//    expose it for the old interface.

#ifndef INTERFACE_H
#define INTERFACE_H

#ifdef __cplusplus

// All interfaces derive from this.
class IBaseInterface
{
public:

	virtual			~IBaseInterface() {}
};

#define CREATEINTERFACE_PROCNAME	"CreateInterface"

typedef IBaseInterface* (*CreateInterfaceFn)(const char *pName, int *pReturnCode);
typedef IBaseInterface* (*InstantiateInterfaceFn)();

// This function is automatically exported and allows you to access any interfaces exposed with the above macros.
// if pReturnCode is set, it will return one of the following values
// extend this for other error conditions/code
enum
{
	IFACE_OK = 0,
	IFACE_FAILED
};

void *CaptureInterface(CreateInterfaceFn Interface, char* InterfaceName);
CreateInterfaceFn CaptureFactory(char* FactoryModule);

#endif // __cplusplus

#endif
```

`sakura/source/other/smth/keydefs.h`:

```h
#ifndef KEYDEFS_H
#define KEYDEFS_H

#define	K_TAB			9
#define	K_ENTER			13
#define	K_ESCAPE		27
#define	K_SPACE			32

#define	K_0			    48
#define	K_1			    49
#define	K_2			    50
#define	K_3			    51
#define	K_4			    52
#define	K_5			    53
#define	K_6			    54
#define	K_7			    55
#define	K_8			    56
#define	K_9			    57

#define	K_A	97
#define	K_B	98
#define	K_C	99
#define	K_D	100
#define	K_E	101
#define	K_F	102
#define	K_G	103
#define	K_H	104
#define	K_I	105
#define	K_J	106
#define	K_K	107
#define	K_L	108
#define	K_M	109
#define	K_N	110
#define	K_O	111
#define	K_P	112
#define	K_Q	113
#define	K_R	114
#define	K_S	115
#define	K_T	116
#define	K_U	117
#define	K_V	118
#define	K_W	119
#define	K_X	120
#define	K_Y	121
#define	K_Z	122

#define	K_BACKSPACE		127
#define	K_UPARROW		128
#define	K_DOWNARROW		129
#define	K_LEFTARROW		130
#define	K_RIGHTARROW	131
#define	K_ALT			132
#define	K_CTRL			133
#define	K_SHIFT			134
#define	K_F1			135
#define	K_F2			136
#define	K_F3			137
#define	K_F4			138
#define	K_F5			139
#define	K_F6			140
#define	K_F7			141
#define	K_F8			142
#define	K_F9			143
#define	K_F10			144
#define	K_F11			145
#define	K_F12			146
#define	K_INS			147
#define	K_DEL			148
#define	K_PGDN			149
#define	K_PGUP			150
#define	K_HOME			151
#define	K_END			152
#define K_KP_HOME		160
#define K_KP_UPARROW	161
#define K_KP_PGUP		162
#define	K_KP_LEFTARROW	163
#define K_KP_5			164
#define K_KP_RIGHTARROW	165
#define K_KP_END		166
#define K_KP_DOWNARROW	167
#define K_KP_PGDN		168
#define	K_KP_ENTER		169
#define K_KP_INS   		170
#define	K_KP_DEL		171
#define K_KP_SLASH		172
#define K_KP_MINUS		173
#define K_KP_PLUS		174
#define K_CAPSLOCK		175
#define K_CAPSLOCK		175
#define K_MWHEELDOWN	239
#define K_MWHEELUP		240
#define	K_MOUSE1		241
#define	K_MOUSE2		242
#define	K_MOUSE3		243
#define K_MOUSE4		244
#define K_MOUSE5		245
#define K_PAUSE			255

#endif 

```

`sakura/source/player.cpp`:

```cpp
#include "client.h"

PlayerInfoLocal g_Local;
PlayerInfo g_Player[33];

bool Sakura::Player::IsAlive(const int index)
{
	if (index != pmove->player_index + 1 &&
		g_Player[index].bAliveInScoreTab &&
		!(pmove->iuser1 == OBS_IN_EYE && pmove->iuser2 == index))
		return true;

	return false;
}

bool Sakura::Player::Local::IsAlive()
{
	if (pmove == nullptr) return false; // fixing crash on inject
	cl_entity_s* ent = g_Engine.GetEntityByIndex(pmove->player_index + 1);
	if (ent &&
		ent->player &&
		g_Local.iTeam != 0 &&
		ent->curstate.iuser1 == OBS_NONE &&
		pmove->view_ofs[2] != PM_DEAD_VIEWHEIGHT &&
		g_Local.iPrevHealth > 0)
		return true;

	return false;
}

bool Sakura::Player::Local::InGame()
{
	char* szMap = (char*)g_Engine.pfnGetLevelName();
	return (szMap && szMap[0]);
}

void Sakura::Player::Local::Update(const float frametime, const usercmd_s* cmd)
{
	Vector localPlayerOrigin = pmove->origin;
	localPlayerOrigin[2] -= 8192;

	pmtrace_t* trace = g_Engine.PM_TraceLine(pmove->origin, localPlayerOrigin, 1, (pmove->flags & FL_DUCKING) ? 1 : 0, -1);

	g_Local.ViewModel = g_Engine.GetViewModel();
	g_Local.flHeightorigin = abs(trace->endpos.z - pmove->origin.z);
	g_Local.flGroundangle = acos(trace->plane.normal[2]) / M_PI * 180;
	g_Local.m_flFrameTime = frametime;
	g_Local.sLerpMSec = cmd->lerp_msec;
}

void Sakura::Player::Local::RunCommands()
{
	static bool run = true;
	if (run)
	{
		g_Engine.pfnClientCmd("setinfo revemu 1"); // for steam id changer, some server kicks if doesn't have it
		g_Engine.pfnClientCmd("cl_showfps 1");
		run = false;
	}
}

unsigned int Cstrike_SequenceInfo[] =
{
	0,	0,	0,	0,	0,	0,	0,	0,	0,	0, // 0..9   
	0,	1,	2,	0,	1,	2,	0,	1,	2,	0, // 10..19 
	1,	2,	0,	1,	1,	2,	0,	1,	1,	2, // 20..29 
	0,	1,	2,	0,	1,	2,	0,	1,	2,	0, // 30..39 
	1,	2,	0,	1,	2,	0,	1,	2,	0,	1, // 40..49 
	2,	0,	1,	2,	0,	0,	0,	8,	0,	8, // 50..59 
	0, 16,	0, 16,	0,	0,	1,	1,	2,	0, // 60..69 
	1,	1,	2,	0,	1,	0,	1,	0,	1,	2, // 70..79 
	0,	1,	2, 	32, 40, 32, 40, 32, 32, 32, // 80..89
	33, 64, 33, 34, 64, 65, 34, 32, 32, 4, // 90..99
	4,	4,	4,	4,	4,	4,	4,	4,	4,	4, // 100..109
	4                                      	// 110
};
```

`sakura/source/player.h`:

```h
#ifndef _PLAYERS_
#define _PLAYERS_

#define MAX_PLAYER_NAME_LENGTH	32
#define TEAM_TT 1
#define TEAM_CT 2

class PlayerInfoLocal
{
public:
	int iFOV;
	int iTeam;
	int iPrevHealth;
	int iPostHealth;

	short sLerpMSec;

	float flGroundangle;
	float flHeightorigin;
	float m_flFrameTime;

	bool bScoped;

	Vector vPrevForward;
	Vector vPostForward;
	Vector vNoSpreadAngle;
	Vector vNoRecoilAngle;
	Vector vPunchangle;

	cl_entity_s* ViewModel;

	CBasePlayerWeapon weapon;
};
extern PlayerInfoLocal g_Local;

class PlayerInfo
{
public:
	bool deathMark = false;
	bool bAliveInScoreTab;
	bool bVip;
	int iHealth;
	int iTeam;

	Vector vEye;
	cl_entity_s playerHistory;
	cl_entity_s playerDeathMark[2];
};
extern PlayerInfo g_Player[33];

namespace Sakura
{
	namespace Player
	{
		namespace Local
		{
			bool IsAlive();
			bool InGame();
			void Update(const float frametime, const usercmd_s* cmd);
			void RunCommands();
		};

		bool IsAlive(const int index);
	};
};

extern unsigned int Cstrike_SequenceInfo[];

#endif
```

`sakura/source/sakura_precompiled.cpp`:

```cpp
#include "client.h"
```

`sakura/source/usermsg.cpp`:

```cpp
#include "client.h"

PUserMsg Sakura::Message::User::Base;
pfnUserMsgHook Sakura::Message::User::pResetHUD;
pfnUserMsgHook Sakura::Message::User::pTeamInfo;
pfnUserMsgHook Sakura::Message::User::pDeathMsg;
pfnUserMsgHook Sakura::Message::User::pScoreAttrib;
pfnUserMsgHook Sakura::Message::User::pServerName;
pfnUserMsgHook Sakura::Message::User::pSetFOV;
pfnUserMsgHook Sakura::Message::User::pMOTD;
pfnUserMsgHook Sakura::Message::User::pDamage;

int MOTD(const char* pszName, int iSize, void* pbuf)
{
	BEGIN_READ(pbuf, iSize);

	if (cvar.misc_block_motd)
		return 0;

	return Sakura::Message::User::pMOTD(pszName, iSize, pbuf);
}

int SetFOV(const char* pszName, int iSize, void* pbuf)
{
	BEGIN_READ(pbuf, iSize);
	g_Local.iFOV = READ_BYTE();

	if (g_Local.iFOV == 90)
		g_Local.bScoped = false;
	else if (g_Local.iFOV > 0)
		g_Local.bScoped = true;

	if (cvar.visual_remove_scope && g_Local.bScoped)
	{
		g_Local.iFOV = 90;

		return (*Sakura::Message::User::pSetFOV)(pszName, iSize, &g_Local.iFOV);
	}

	return Sakura::Message::User::pSetFOV(pszName, iSize, pbuf);
}

int ServerName(const char* pszName, int iSize, void* pbuf)
{
	BEGIN_READ(pbuf, iSize);
	char* m_szServerName = READ_STRING();
	sprintf(sServerName, /*%s\0*/XorStr<0x29, 4, 0x248C859F>("\x0C\x59\x2B" + 0x248C859F).s, m_szServerName);
	return Sakura::Message::User::pServerName(pszName, iSize, pbuf);
}

int ScoreAttrib(const char* pszName, int iSize, void* pbuf)
{
	BEGIN_READ(pbuf, iSize);
	int id = READ_BYTE();
	int info = READ_BYTE(); 
	if (id > 0 && id <= g_Engine.GetMaxClients())
	{
		g_Player[id].bVip = (info & (1 << 2));
		g_Player[id].bAliveInScoreTab = !(info & (1 << 0));
	}
	return Sakura::Message::User::pScoreAttrib(pszName, iSize, pbuf);
}

int ResetHUD(const char *pszName, int iSize, void *pbuf)
{
	static char currentMap[100];

	currentMap[sizeof(currentMap) - 1] = '\0';

	if (strcmp(currentMap, g_Engine.pfnGetLevelName())) 
	{
		strcpy(currentMap, g_Engine.pfnGetLevelName());
		currentMap[sizeof(currentMap) - 1] = '\0';
		LoadOverview((char*)Sakura::Strings::getfilename(g_Engine.pfnGetLevelName()).c_str());
	}

	Sakura::Player::Local::RunCommands();
	ContinueRoute(); 
	Sound_No_Index.deque::clear();
	Sound_Index.deque::clear();

	for (size_t i = 1; i <= g_Engine.GetMaxClients(); ++i)
	{
		if (strstr(client_state->levelname, "1hp")) g_Player[i].iHealth = 1;
		else if (strstr(client_state->levelname, "35hp")) g_Player[i].iHealth = 35;
		else g_Player[i].iHealth = 100;

		g_Player[i].deathMark = false;
		DM_Once[i] = false;
	}

	for (size_t i = 0; i < Sakura::Lua::scripts.size(); ++i)
	{
		auto& script = Sakura::Lua::scripts[i];

		if (!script.HasCallback(Sakura::Lua::SAKURA_CALLBACK_TYPE::SAKURA_CALLBACK_AT_RESETHUD_MESSAGE))
			continue;

		auto& callbacks = script.GetCallbacks(Sakura::Lua::SAKURA_CALLBACK_TYPE::SAKURA_CALLBACK_AT_RESETHUD_MESSAGE);
		for (const auto& callback : callbacks)
		{
			try
			{
				callback();
			}
			catch (luabridge::LuaException const& error)
			{
				if (script.GetState())
				{
					Sakura::Lua::Error("Error has occured in the lua \"On New Round\" script: %s", error.what());
					script.RemoveAllCallbacks();
				}
			}
		}
	}

	return Sakura::Message::User::pResetHUD(pszName, iSize, pbuf);
}

int DeathMsg(const char *pszName, int iSize, void *pbuf)
{
	BEGIN_READ(pbuf, iSize);
	int killer = READ_BYTE();
	int victim = READ_BYTE();
	int headshot = READ_BYTE();

	if (killer != victim && killer == pmove->player_index + 1 && victim > 0 && victim <= g_Engine.GetMaxClients())
	{
		dwReactionTime = GetTickCount();
		g_Player[victim].deathMark = true;
		Sakura::Sound::KillSound(headshot);
	}

	if (victim == pmove->player_index + 1)
	{
		Sakura::HNS::BunnyHop::Active = false;
		Sakura::HNS::Groundstrafe::Active = false;
		Sakura::HNS::Fastrun::Active = false;
		Sakura::HNS::Strafe::Active = false;
	}

	for (size_t i = 0; i < Sakura::Lua::scripts.size(); ++i)
	{
		auto& script = Sakura::Lua::scripts[i];

		if (!script.HasCallback(Sakura::Lua::SAKURA_CALLBACK_TYPE::SAKURA_CALLBACK_AT_DEATH_MESSAGE))
			continue;

		auto& callbacks = script.GetCallbacks(Sakura::Lua::SAKURA_CALLBACK_TYPE::SAKURA_CALLBACK_AT_DEATH_MESSAGE);
		for (const auto& callback : callbacks)
		{
			try
			{
				callback(killer, victim, headshot);
			}
			catch (luabridge::LuaException const& error)
			{
				if (script.GetState())
				{
					Sakura::Lua::Error("Error has occured in the lua \"On Death\" script: %s", error.what());
					script.RemoveAllCallbacks();
				}
			}
		}
	}

	return Sakura::Message::User::pDeathMsg(pszName, iSize, pbuf);
}

int TeamInfo(const char *pszName, int iSize, void *pbuf)
{
	BEGIN_READ(pbuf, iSize);
	int id = READ_BYTE();
	char *szTeam = READ_STRING();

	if (id > 0 && id <= g_Engine.GetMaxClients())
	{
		int team = 0;

		if (!lstrcmpA(szTeam, "TERRORIST") || !lstrcmpA(szTeam, "terrorist"))
			team = TEAM_TT;
		else if (!lstrcmpA(szTeam, "CT") || !lstrcmpA(szTeam, "ct"))
			team = TEAM_CT;

		g_Player[id].iTeam = team;

		if (id == pmove->player_index + 1)
			g_Local.iTeam = team;
	}

	return Sakura::Message::User::pTeamInfo(pszName, iSize, pbuf);
}

int Damage(const char* pszName, int iSize, void* pbuf)
{
	BEGIN_READ(pbuf, iSize);

	int damage = READ_BYTE();

	for (size_t i = 0; i < Sakura::Lua::scripts.size(); ++i)
	{
		auto& script = Sakura::Lua::scripts[i];

		if (!script.HasCallback(Sakura::Lua::SAKURA_CALLBACK_TYPE::SAKURA_CALLBACK_AT_DAMAGE_MESSAGE))
			continue;

		auto& callbacks = script.GetCallbacks(Sakura::Lua::SAKURA_CALLBACK_TYPE::SAKURA_CALLBACK_AT_DAMAGE_MESSAGE);
		for (const auto& callback : callbacks)
		{
			try
			{
				callback(damage);
			}
			catch (luabridge::LuaException const& error)
			{
				if (script.GetState())
				{
					Sakura::Lua::Error("Error has occured in the lua \"On Damage\" script: %s", error.what());
					script.RemoveAllCallbacks();
				}
			}
		}
	}

	return Sakura::Message::User::pDamage(pszName, iSize, pbuf);
}

PUserMsg Sakura::Message::User::ByName(char* messageName)
{
	PUserMsg Ptr = NULL;

	Ptr = Base;

	while (Ptr->next)
	{
		if (!strcmp(Ptr->name, messageName))
			return Ptr;

		Ptr = Ptr->next;
	}

	Ptr->pfn = 0;

	return Ptr;
}

pfnUserMsgHook Sakura::Message::User::HookMsg(char* messageName, pfnUserMsgHook pfn)
{
	PUserMsg Ptr = NULL;
	pfnUserMsgHook Original = NULL;

	Ptr = ByName(messageName);

	if (Ptr->pfn != 0)
	{
		Original = Ptr->pfn;
		Ptr->pfn = pfn;
		return Original;
	}
	
	c_Offset.Error("Couldn't find '%s' message.", messageName);
}

void Sakura::Message::User::Hook()
{
	pResetHUD = HookMsg("ResetHUD", ResetHUD);
	pTeamInfo = HookMsg("TeamInfo", TeamInfo);
	pDeathMsg = HookMsg("DeathMsg", DeathMsg);
	pScoreAttrib = HookMsg("ScoreAttrib", ScoreAttrib);
	pServerName = HookMsg("ServerName", ServerName);
	pSetFOV = HookMsg("SetFOV", SetFOV);
	pMOTD = HookMsg("MOTD", MOTD);
	pDamage = HookMsg("Damage", Damage);
}

void Sakura::Message::User::UnHook()
{
	pResetHUD = HookMsg("ResetHUD", pResetHUD);
	pTeamInfo = HookMsg("TeamInfo", pTeamInfo);
	pDeathMsg = HookMsg("DeathMsg", pDeathMsg);
	pScoreAttrib = HookMsg("ScoreAttrib", pScoreAttrib);
	pServerName = HookMsg("ServerName", pServerName);
	pSetFOV = HookMsg("SetFOV", pSetFOV);
	pMOTD = HookMsg("MOTD", pMOTD);
	pDamage = HookMsg("Damage", pDamage);
}
```

`sakura/source/usermsg.h`:

```h
#ifndef _USERMSG_
#define _USERMSG_

typedef struct TUserMsg
{
	int number;
	int size;
	char name[16];
	struct TUserMsg* next;
	pfnUserMsgHook pfn;
} *PUserMsg;

namespace Sakura
{
	namespace Message
	{
		namespace User
		{
			extern PUserMsg Base;

			extern pfnUserMsgHook pResetHUD;
			extern pfnUserMsgHook pTeamInfo;
			extern pfnUserMsgHook pDeathMsg;
			extern pfnUserMsgHook pScoreAttrib;
			extern pfnUserMsgHook pServerName;
			extern pfnUserMsgHook pSetFOV;
			extern pfnUserMsgHook pMOTD;
			extern pfnUserMsgHook pDamage;

			PUserMsg ByName(char* messageName);
			pfnUserMsgHook HookMsg(char* messageName, pfnUserMsgHook pfn);
			void UnHook();
			void Hook();
		};
	};
};

#endif
```

`sakura/source/vectors/QAngle.cpp`:

```cpp
#include "../client.h"

void QAngle::AngleVectors(Vector* Forward, Vector* Right, Vector* Up)
{
	float sp, sy, sr, cp, cy, cr, radx, rady, radz;

	radx = x * (M_PI*2 / 360);
	rady = y * (M_PI*2 / 360);
	radz = z * (M_PI*2 / 360);

	sp = sin(radx); 
	sy = sin(rady); 
	sr = sin(radz); 

	cp = cos(radx);
	cy = cos(rady);
	cr = cos(radz);

	if (Forward)
	{
		Forward->x = cp * cy;
		Forward->y = cp * sy;
		Forward->z = -sp;
	}

	if (Right)
	{
		Right->x = -1 * sr * sp * cy + -1 * cr * -sy;
		Right->y = -1 * sr * sp * sy + -1 * cr * cy;
		Right->z = -1 * sr * cp;
	}

	if (Up)
	{
		Up->x = cr * sp * cy + -sr * -sy;
		Up->y = cr * sp * sy + -sr * cy;
		Up->z = cr * cp;
	}
}

void QAngle::AngleVectorsTranspose (Vector* Forward, Vector* Right, Vector* Up)
{
	float sp, sy, sr, cp, cy, cr, radx, rady, radz;

	radx = x * (M_PI*2 / 360);
	rady = y * (M_PI*2 / 360);
	radz = z * (M_PI*2 / 360);
		
	sp = sin(radx); 
	sy = sin(rady); 
	sr = sin(radz); 

	cp = cos(radx);
	cy = cos(rady);
	cr = cos(radz);

	if (Forward)
	{
		Forward->x = cp * cy;
		Forward->y = sr * sp * cy + cr * -sy;
		Forward->z = cr * sp * cy + -sr * -sy;
	}

	if (Right)
	{
		Right->x = cp * sy;
		Right->y = sr * sp * sy + cr * cy;
		Right->z = cr * sp * sy + -sr * cy;
	}

	if (Up)
	{
		Up->x = -sp;
		Up->y = sr * cp;
		Up->z = cr * cp;
	}
}
```

`sakura/source/vectors/QAngle.h`:

```h
class QAngle;
class Vector;

class QAngle
{
	public:

		QAngle::QAngle ( void ) : x ( 0.0f ), y ( 0.0f ), z ( 0.0f )
		{

		}

		QAngle::QAngle ( float X, float Y, float Z )
		: x ( X ), y ( Y ), z ( Z )
		{

		}

		QAngle::QAngle ( float* p )
		{
			*this = p;
		};

		QAngle::QAngle ( QAngle& in )
		{
			*this = in;
		};

		QAngle::~QAngle ()
		{

		}

		inline QAngle& operator= ( const QAngle& in );
		inline QAngle& operator= ( float* p );
		inline QAngle& operator= ( float f );
		
		inline float& operator[] ( int i ) const;
		
		inline bool operator! ( void ) const;
		
		inline bool operator== ( const QAngle& other ) const;

		inline bool operator!= ( const QAngle& other ) const;

		inline QAngle& operator+= ( const QAngle& other );
		inline QAngle& operator+= ( float* p );
		inline QAngle& operator+= ( float f );

		inline QAngle& operator-= ( const QAngle& other );
		inline QAngle& operator-= ( float* p );
		inline QAngle& operator-= ( float f );
		
		inline QAngle& operator*= ( const QAngle& other );
		inline QAngle& operator*= ( float *p );
		inline QAngle& operator*= ( float f );
		
		inline QAngle& operator/= ( const QAngle& other );
		inline QAngle& operator/= ( float* p );
		inline QAngle& operator/= ( float f );
		
		inline QAngle operator+ ( const QAngle& other ) const;
		inline QAngle operator+ ( float* p ) const;
		inline QAngle operator+ ( float f ) const;
		
		inline QAngle operator- ( const QAngle& other ) const;
		inline QAngle operator- ( float* p ) const;
		inline QAngle operator- ( float f ) const;
		inline QAngle operator- ( void ) const;
		
		inline QAngle operator* ( const QAngle& other ) const;
		inline QAngle operator* ( float* p ) const;
		inline QAngle operator* ( float f ) const;
		
		inline QAngle operator/ ( const QAngle& other ) const;
		inline QAngle operator/ ( float* p ) const;
		inline QAngle operator/ ( float f ) const;

		operator float *()								{ return &x; }
		operator const float *() const					{ return &x; }

		inline bool IsZero ( void ) const
		{
			return x == 0.0f && y == 0.0f && z == 0.0f;
		}

		inline bool IsZero2D ( void )
		{
			return x == 0.0f && y == 0.0f;
		}

		inline QAngle& Clear ( void )
		{
			x = y = z = 0;

			return *this;
		}
		
		inline QAngle& Init ( float X, float Y, float Z )
		{
			x = X;
			y = Y;
			z = Z;

			return *this;
		}

		inline QAngle& Init ( float* p )
		{
			*this = p;

			return *this;
		}

		inline QAngle& Negate ( void )
		{
			x = -x;
			y = -y;
			z = -z;

			return *this;
		}
		
		QAngle& Normalize(void)
		{
			float* Pointer = (float*)this;

			for (int i = 0; i < 3; i++)
			{
				if (Pointer[i] > 180)
				{
					Pointer[i] -= 360;
				}
				else if (Pointer[i] < -180)
				{
					Pointer[i] += 360;
				}
			}

			return *this;
		}

		QAngle Delta360 ( QAngle& other )
		{
			QAngle OutDifference;
						 		
			OutDifference = other - *this;
 			
			for ( int i = 0; i < 3; i++ )
			{
				if ( OutDifference[i] < 0 )
				{
					OutDifference[i] = -OutDifference[i];
			
					if ( OutDifference[i] > 180 )
					{
						OutDifference[i] = 360 - OutDifference[i];
					}
				}
			}

			return OutDifference;
		}

		bool IsWithinFOV ( QAngle& AngIn, float fovX, float fovY )
		{
			QAngle AngleDifference = Delta360 ( AngIn );

			return AngleDifference.x <= fovX && AngleDifference.y <= fovY;
		}
				
		void AngleVectors ( Vector* Forward, Vector* Right, Vector* Up );
		void AngleVectorsTranspose ( Vector* Forward, Vector* Right, Vector* Up );

		inline bool IsValid()
		{
			return isfinite ( x ) && isfinite( y ) && isfinite( z );
		}

	public:

		float x, y, z;
};

inline QAngle& QAngle::operator= ( const QAngle& in )
{
	x = in.x;
	y = in.y;
	z = in.z;

	return *this;
}

inline QAngle& QAngle::operator= ( float* p )
{
	if ( p )
	{
		x = p[0]; y = p[1]; z = p[2];
	}
	else
	{
		x = y = z = 0;
	}

	return *this;
}

inline QAngle& QAngle::operator= ( float f )
{
	x = y = z = f;

	return *this;
}

inline float &QAngle::operator[] ( int i ) const
{
	if ( i >= 0 && i < 3 )
	{
		return ( ( float* )this )[i];
	}

	return ( ( float* )this )[0];
}

inline bool QAngle::operator! ( void ) const
{
	return IsZero();
}

inline bool QAngle::operator== ( const QAngle& other ) const
{
	return x == other.x && y == other.y && z == other.z;
}

inline bool QAngle::operator!= ( const QAngle& other ) const
{
	return x != other.x || y != other.y || z != other.z;
}

inline QAngle& QAngle::operator+= ( const QAngle& other )
{
	x += other.x;
	y += other.y;
	z += other.z;

	return *this;
}

inline QAngle& QAngle::operator+= ( float* p )
{
	x += p[0];
	y += p[1];
	z += p[2];

	return *this;
}

inline QAngle& QAngle::operator+= ( float f )
{
	x += f;
	y += f;
	z += f;

	return *this;
}

inline QAngle& QAngle::operator-= ( const QAngle& other )
{
	x -= other.x;
	y -= other.y;
	z -= other.z;

	return *this;
}

inline QAngle& QAngle::operator-= ( float* p )
{
	x -= p[0];
	y -= p[1];
	z -= p[2];

	return *this;
}
inline QAngle& QAngle::operator-= ( float f )
{
	x -= f;
	y -= f;
	z -= f;

	return *this;
}

inline QAngle& QAngle::operator*= ( const QAngle& other )
{
	x *= other.x;
	y *= other.y;
	z *= other.z;

	return *this;
}

inline QAngle& QAngle::operator*= ( float *p )
{
	x *= p[0];
	y *= p[1];
	z *= p[2];

	return *this;
}

inline QAngle& QAngle::operator*= ( float f )
{
	x *= f;
	y *= f;
	z *= f;

	return *this;
}

inline QAngle& QAngle::operator/= ( const QAngle& other )
{
	if ( other.x != 0 && other.y != 0 && other.z != 0 )
	{
		x /= other.x;
		y /= other.y;
		z /= other.z;
	}

	return *this;
}

inline QAngle& QAngle::operator/= ( float* p )
{
	if ( p[0] != 0 && p[1] != 0 && p[2] != 0 )
	{
		x /= p[0];
		y /= p[1];
		z /= p[2];
	}

	return *this;
}

inline QAngle& QAngle::operator/= ( float f )
{
	if ( f != 0 )
	{
		x /= f;
		y /= f;
		z /= f;
	}

	return *this;
}

inline QAngle QAngle::operator+ ( const QAngle& other ) const
{
	return QAngle ( x + other.x, y + other.y, z + other.z );
}

inline QAngle QAngle::operator+ ( float* p ) const
{
	return QAngle ( x + p[0], y + p[1], z + p[2] );
}

inline QAngle QAngle::operator+ ( float f ) const
{
	return QAngle ( x + f, y + f, z + f );
}

inline QAngle  QAngle::operator- ( const QAngle& other ) const
{
	return QAngle ( x - other.x, y - other.y, z - other.z );
}

inline QAngle  QAngle::operator- ( float* p ) const
{
	return QAngle ( x - p[0], y - p[1], z - p[2] );
}

inline QAngle  QAngle::operator- ( float f ) const
{
	return QAngle ( x - f, y - f, z - f );
}

inline QAngle QAngle::operator- ( void ) const
{
	return QAngle ( -x, -y, -z );
}

inline QAngle QAngle::operator* ( const QAngle& other ) const
{
	return QAngle ( x * other.x, y * other.y, z * other.z );
}

inline QAngle QAngle::operator* ( float* p ) const
{
	return QAngle ( x * p[0], y * p[1], z * p[2] );
}

inline QAngle QAngle::operator* ( float f ) const
{
	return QAngle ( x * f, y * f, z * f );
}

inline QAngle QAngle::operator/ ( const QAngle& other ) const
{
	if ( other.x != 0 && other.y != 0 && other.z != 0 )
	{
		return QAngle ( x / other.x, y / other.y, z / other.z );
	}

	return QAngle ( 0, 0, 0 );
}

inline QAngle QAngle::operator/ ( float* p ) const
{
	if ( p[0] != 0 && p[1] != 0 && p[2] != 0 )
	{
		return QAngle ( x / p[0], y / p[1], z / p[2] );
	}

	return QAngle ( 0, 0, 0 );
}

inline QAngle QAngle::operator/ ( float f ) const
{
	if ( f != 0 )
	{
		return QAngle ( x / f, y / f, z / f );
	}

	return QAngle ( 0, 0, 0 );
}

inline QAngle operator*(float fl, const QAngle& v)	{ return v * fl; };
```

`sakura/source/vectors/Vector.cpp`:

```cpp
#include "../client.h"

void Vector::AngleMatrix(QAngle& Rotation, float (*matrix)[3])
{
	float sp, sy, sr, cp, cy, cr, radx, rady, radz;

	radx = Rotation.x * (M_PI*2 / 360);
	rady = Rotation.y * (M_PI*2 / 360);
	radz = Rotation.z * (M_PI*2 / 360);

	sp = sin(radx); 
	sy = sin(rady); 
	sr = sin(radz); 

	cp = cos(radx);
	cy = cos(rady);
	cr = cos(radz);
		
	matrix[0][0] = cp * cy;
	matrix[0][1] = cp * sy;
	matrix[0][2] = -sp;
	
	matrix[1][0] = 1 * sr * sp * cy + 1 * cr * -sy;
	matrix[1][1] = 1 * sr * sp * sy + 1 * cr * cy;
	matrix[1][2] = 1 * sr * cp;
		
	matrix[2][0] = cr * sp * cy + -sr * -sy;
	matrix[2][1] = cr * sp * sy + -sr * cy;
	matrix[2][2] = cr * cp;
}

void Vector::VectorRotate(Vector& In, QAngle& Rotation)
{
	float matRotate[3][3];

	AngleMatrix(Rotation, matRotate);

	x = In.Dot(matRotate[0]);
	y = In.Dot(matRotate[1]);
	z = In.Dot(matRotate[2]);
}

QAngle Vector::ToEulerAngles()
{
	float Pitch, Yaw, Length;

	Length = Length2D();

	if (Length > 0)
	{
		Pitch = (atan2(-z, Length) * 180.0 / M_PI);

		if (Pitch < 0)
		{
			Pitch += 360;
		}

		Yaw = (atan2(y, x) * 180.0 / M_PI);

		if (Yaw < 0)
		{
			Yaw += 360;
		}
	}
	else
	{
		Pitch = (z > 0.0f) ? 270 : 90;
		Yaw = 0;
	}
			
	return QAngle (Pitch, Yaw, 0);
}

QAngle Vector::ToEulerAngles(Vector* PseudoUp)
{
	Vector Left;

	float Length, Yaw, Pitch, Roll;

	Left.CrossProduct (*PseudoUp, *this);
	
	Left.Normalize();
		
	Length = Length2D();

	if (PseudoUp)
	{        
		if (Length > 0.001)
		{                   							
			Pitch = (atan2(-z, Length) * 180.0 / M_PI);

			if (Pitch < 0)
			{
				Pitch += 360;
			}
        
			Yaw = (atan2(y, x) * 180.0 / M_PI);

			if (Yaw < 0)
			{
				Yaw += 360;
			}

			float up_z = (Left[1] * x) - (Left[0] * y);
                                                     
			Roll = (atan2(Left[2], up_z) * 180.0 / M_PI);

			if (Roll < 0)
			{
				Roll += 360;
			}
		}
		else
		{
			Yaw = (atan2(y, x) * 180.0 / M_PI);

			if (Yaw < 0)
			{
				Yaw += 360;
			}
		
			Pitch = (atan2(-z, Length) * 180.0 / M_PI);
		
			if (Pitch < 0)
			{
				Pitch += 360;
			}

			Roll = 0;
		}
	}
	else
	{
		if (Length > 0)
		{
			Pitch = (atan2 (-z, Length) * 180.0 / M_PI);

			if (Pitch < 0)
			{
				Pitch += 360;
			}

			Yaw = (atan2(y, x) * 180.0 / M_PI);

			if (Yaw < 0)
			{
				Yaw += 360;
			}
		}
		else
		{
			Pitch = (z > 0.0f) ? 270 : 90;
			Yaw = 0;
		}
	}

	return QAngle(Pitch, Yaw, Roll);
}
```

`sakura/source/vectors/Vector.h`:

```h
class QAngle;
class Vector;

typedef float vec_t;

class Vector2D
{
public:
	inline Vector2D(void) {}
	inline Vector2D(float X, float Y) { x = X; y = Y; }
	inline Vector2D operator+(const Vector2D& v)	const { return Vector2D(x + v.x, y + v.y); }
	inline Vector2D operator-(const Vector2D& v)	const { return Vector2D(x - v.x, y - v.y); }
	inline Vector2D operator*(float fl)				const { return Vector2D(x*fl, y*fl); }
	inline Vector2D operator/(float fl)				const { return Vector2D(x / fl, y / fl); }

	inline float Length(void)						const { return (float)sqrt(x*x + y * y); }

	inline Vector2D Normalize(void) const
	{
		Vector2D vec2;

		float flLen = Length();
		if (flLen == 0)
		{
			return Vector2D((float)0, (float)0);
		}
		else
		{
			flLen = 1 / flLen;
			return Vector2D(x * flLen, y * flLen);
		}
	}

	inline float DotProduct(const Vector2D a, const Vector2D b) { return(a.x * b.x + a.y * b.y); }

	vec_t	x, y;
};

class Vector
{
	public:

		Vector::Vector ( void ) : x ( 0.0f ), y ( 0.0f ), z ( 0.0f )
		{

		}

		Vector::Vector ( float X, float Y, float Z )
		: x ( X ), y ( Y ), z ( Z )
		{

		}

		Vector::Vector ( float* p )
		{
			*this = p;
		};

		Vector::Vector ( const Vector& in )
		{
			x = in.x;
			y = in.y;
			z = in.z;
		};

		Vector::~Vector ()
		{

		}

		inline Vector& operator= ( const Vector& in );
		inline Vector& operator= ( float* p );
		inline Vector& operator= ( float f );
		
		inline float& operator[] ( int i ) const;
		
		inline bool operator! ( void ) const;
		
		inline bool operator== ( const Vector& other ) const;

		inline bool operator!= ( const Vector& other ) const;

		inline Vector& operator+= ( const Vector& other );
		inline Vector& operator+= ( float* p );
		inline Vector& operator+= ( float f );

		inline Vector& operator-= ( const Vector& other );
		inline Vector& operator-= ( float* p );
		inline Vector& operator-= ( float f );
		
		inline Vector& operator*= ( const Vector& other );
		inline Vector& operator*= ( float *p );
		inline Vector& operator*= ( float f );
		
		inline Vector& operator/= ( const Vector& other );
		inline Vector& operator/= ( float* p );
		inline Vector& operator/= ( float f );
		
		inline Vector operator+ ( const Vector& other ) const;
		inline Vector operator+ ( float* p ) const;
		inline Vector operator+ ( float f ) const;
		
		inline Vector operator- ( const Vector& other ) const;
		inline Vector operator- ( float* p ) const;
		inline Vector operator- ( float f ) const;
		inline Vector operator- ( void ) const;
		
		inline Vector operator* ( const Vector& other ) const;
		inline Vector operator* ( float* p ) const;
		inline Vector operator* ( float f ) const;
		
		inline Vector operator/ ( const Vector& other ) const;
		inline Vector operator/ ( float* p ) const;
		inline Vector operator/ ( float f ) const;

		operator float *()								{ return &x; }
		operator const float *() const					{ return &x; }
		
		inline bool Vector::IsZero ( void ) const
		{
			return x == 0.0f && y == 0.0f && z == 0.0f;
		}

		inline bool Vector::IsZero2D ( void )
		{
			return x == 0.0f && y == 0.0f;
		}

		inline Vector& Clear ( void )
		{
			x = y = z = 0;
						
			return *this;
		}
		
		inline Vector& Init ( float X, float Y, float Z )
		{
			x = X;
			y = Y;
			z = Z;

			return *this;
		}

		inline Vector& Init ( float* p )
		{
			*this = p;

			return *this;
		}

		inline Vector& Negate ( void )
		{
			x = -x;
			y = -y;
			z = -z;

			return *this;
		}

		inline float Dot ( const Vector& other )
		{
			return x*other.x + y*other.y + z*other.z;
		}

		inline float Dot2D ( const Vector& other )
		{
			return x*other.x + y*other.y;
		}

		inline float Length ( void )
		{
			float Length = 0;

			Length = sqrt ( LengthSqr() );
	
			return Length;
		}

		inline float Length2D ( void )
		{
			float Length = 0;

			Length = sqrt ( LengthSqr2D() );
	
			return Length;
		}

		inline float LengthSqr ( void )
		{
			return x*x + y*y + z*z;
		}

		inline float LengthSqr2D ( void )
		{
			return x*x + y*y;
		}

		inline float Distance ( Vector& ToVector )
		{
			return ( ToVector - *this ).Length();
		}

		inline float Distance2D ( Vector& ToVector )
		{
			return ( ToVector - *this ).Length2D();
		}

		inline float Normalize ( void )
		{
			float RecipLength, VectorLength;

			VectorLength = Length();

			if ( VectorLength != 0 )
			{
				RecipLength = 1 / VectorLength;

				x *= RecipLength;
				y *= RecipLength;
				z *= RecipLength;
			}

			return VectorLength;
		}

		inline Vector Normalized(void)
		{
			float flLen = Length();
			if (flLen == 0) return Vector(0, 0, 1);
			flLen = 1 / flLen;
			return Vector(x * flLen, y * flLen, z * flLen);
		}

		inline float Normalize2D ( void )
		{
			float Length = LengthSqr2D();
			float RecipLength;

			if ( Length != 0 )
			{
				RecipLength = 1 / Length;

				x *= RecipLength;
				y *= RecipLength;
			}

			return Length;
		}

		inline Vector2D Make2D(void) const
		{
			Vector2D	Vec2;

			Vec2.x = x;
			Vec2.y = y;

			return Vec2;
		}

		inline float AngleBetween ( Vector& other )
		{
			other.Normalize();
			Normalize();

			return acos ( Dot ( other ) ) * static_cast<float>(180.0 / M_PI);
		}

		Vector &CrossProduct ( const Vector& a, const Vector& b )
		{
			x = ( a.y * b.z ) - ( a.z * b.y );
			y = ( a.z * b.x ) - ( a.x * b.z );
			z = ( a.x * b.y ) - ( a.y * b.x );

			return *this;
		}
		QAngle ToEulerAngles();
		QAngle ToEulerAngles ( Vector* PseudoUp );
		void AngleMatrix ( QAngle& Rotation, float ( *matrix )[3] );
		void VectorRotate ( Vector& In, QAngle& Rotation );

		void VectorVectors ( Vector& Right, Vector& Up )
		{
			Vector tmp;

			if ( x == 0 && y == 0)
			{
				Right[0] = 1;	
				Right[1] = 0; 
				Right[2] = 0;
				Up[0] = -z; 
				Up[1] = 0; 
				Up[2] = 0;
				return;
			}

			tmp[0] = 0; tmp[1] = 0; tmp[2] = 1.0;
			CrossProduct( tmp, Right );
			Right.Normalize();
			Right.CrossProduct( *this, Up );
			Up.Normalize();
		}

		inline bool IsValid()
		{
			return isfinite ( x ) && isfinite( y ) && isfinite( z );
		}

	public:

		float x, y, z;
};

inline Vector& Vector::operator= ( const Vector& in )
{
	x = in.x;
	y = in.y;
	z = in.z;

	return *this;
}

inline Vector& Vector::operator= ( float* p )
{
	if ( p )
	{
		x = p[0]; y = p[1]; z = p[2];
	}
	else
	{
		x = y = z = 0;
	}

	return *this;
}

inline Vector& Vector::operator= ( float f )
{
	x = y = z = f;

	return *this;
}

inline float &Vector::operator[] ( int i ) const
{
	if ( i >= 0 && i < 3 )
	{
		return ( ( float* )this )[i];
	}

	return ( ( float* )this )[0];
}

inline bool Vector::operator! ( void ) const
{
	return IsZero();
}

inline bool Vector::operator== ( const Vector& other ) const
{
	return x == other.x && y == other.y && z == other.z;
}

inline bool Vector::operator!= ( const Vector& other ) const
{
	return x != other.x || y != other.y || z != other.z;
}

inline Vector& Vector::operator+= ( const Vector& other )
{
	x += other.x;
	y += other.y;
	z += other.z;

	return *this;
}

inline Vector& Vector::operator+= ( float* p )
{
	x += p[0];
	y += p[1];
	z += p[2];

	return *this;
}

inline Vector& Vector::operator+= ( float f )
{
	x += f;
	y += f;
	z += f;

	return *this;
}

inline Vector& Vector::operator-= ( const Vector& other )
{
	x -= other.x;
	y -= other.y;
	z -= other.z;

	return *this;
}

inline Vector& Vector::operator-= ( float* p )
{
	x -= p[0];
	y -= p[1];
	z -= p[2];

	return *this;
}
inline Vector& Vector::operator-= ( float f )
{
	x -= f;
	y -= f;
	z -= f;

	return *this;
}

inline Vector& Vector::operator*= ( const Vector& other )
{
	x *= other.x;
	y *= other.y;
	z *= other.z;

	return *this;
}

inline Vector& Vector::operator*= ( float *p )
{
	x *= p[0];
	y *= p[1];
	z *= p[2];

	return *this;
}

inline Vector& Vector::operator*= ( float f )
{
	x *= f;
	y *= f;
	z *= f;

	return *this;
}

inline Vector& Vector::operator/= ( const Vector& other )
{
	if ( other.x != 0 && other.y != 0 && other.z != 0 )
	{
		x /= other.x;
		y /= other.y;
		z /= other.z;
	}

	return *this;
}

inline Vector& Vector::operator/= ( float* p )
{
	if ( p[0] != 0 && p[1] != 0 && p[2] != 0 )
	{
		x /= p[0];
		y /= p[1];
		z /= p[2];
	}

	return *this;
}

inline Vector& Vector::operator/= ( float f )
{
	if ( f != 0 )
	{
		x /= f;
		y /= f;
		z /= f;
	}

	return *this;
}

inline Vector Vector::operator+ ( const Vector& other ) const
{
	return Vector ( x + other.x, y + other.y, z + other.z );
}

inline Vector Vector::operator+ ( float* p ) const
{
	return Vector ( x + p[0], y + p[1], z + p[2] );
}

inline Vector Vector::operator+ ( float f ) const
{
	return Vector ( x + f, y + f, z + f );
}

inline Vector  Vector::operator- ( const Vector& other ) const
{
	return Vector ( x - other.x, y - other.y, z - other.z );
}

inline Vector  Vector::operator- ( float* p ) const
{
	return Vector ( x - p[0], y - p[1], z - p[2] );
}

inline Vector  Vector::operator- ( float f ) const
{
	return Vector ( x - f, y - f, z - f );
}

inline Vector Vector::operator- ( void ) const
{
	return Vector ( -x, -y, -z );
}

inline Vector Vector::operator* ( const Vector& other ) const
{
	return Vector ( x * other.x, y * other.y, z * other.z );
}

inline Vector Vector::operator* ( float* p ) const
{
	return Vector ( x * p[0], y * p[1], z * p[2] );
}

inline Vector Vector::operator* ( float f ) const
{
	return Vector ( x * f, y * f, z * f );
}

inline Vector Vector::operator/ ( const Vector& other ) const
{
	if ( other.x != 0 && other.y != 0 && other.z != 0 )
	{
		return Vector ( x / other.x, y / other.y, z / other.z );
	}

	return *this;
}

inline Vector Vector::operator/ ( float* p ) const
{
	if ( p[0] != 0 && p[1] != 0 && p[2] != 0 )
	{
		return Vector ( x / p[0], y / p[1], z / p[2] );
	}

	return *this;
}

inline Vector Vector::operator/ ( float f ) const
{
	if ( f != 0 )
	{
		return Vector ( x / f, y / f, z / f );
	}

	return *this;
}

inline Vector operator*(float fl, const Vector& v)	{ return v * fl; };
inline float DotProduct(const Vector& a, const Vector& b) { return(a.x * b.x + a.y * b.y + a.z * b.z); }

#define vec3_t Vector
```