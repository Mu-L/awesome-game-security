Project Path: arc_sailro_EscapeFromTarkov-Trainer_b_g3bb59

Source Tree:

```txt
arc_sailro_EscapeFromTarkov-Trainer_b_g3bb59
├── BepInExPlugin
│   ├── BepInExPlugin.csproj
│   ├── Properties
│   │   └── AssemblyInfo.cs
│   └── SptEftTrainerPlugin.cs
├── Configuration
│   ├── ColorConverter.cs
│   ├── ConfigurationManager.cs
│   ├── ConfigurationPropertyAttribute.cs
│   ├── EnumConverter.cs
│   ├── KeyCodeConverter.cs
│   ├── OrderedProperty.cs
│   └── TrackedItemConverter.cs
├── ConsoleCommands
│   ├── BaseListCommand.cs
│   ├── BaseTemplateCommand.cs
│   ├── BaseTrackCommand.cs
│   ├── BaseTrackListCommand.cs
│   ├── BuiltInCommand.cs
│   ├── ConsoleCommand.cs
│   ├── ConsoleCommandWithArgument.cs
│   ├── ConsoleCommandWithoutArgument.cs
│   ├── Dump.cs
│   ├── List.cs
│   ├── ListRare.cs
│   ├── ListSuperRare.cs
│   ├── LoadTrackList.cs
│   ├── SaveTrackList.cs
│   ├── Spawn.cs
│   ├── SpawnBot.cs
│   ├── SpawnHideoutItems.cs
│   ├── SpawnQuestItems.cs
│   ├── Status.cs
│   ├── Template.cs
│   ├── ToggleFeatureCommand.cs
│   ├── Track.cs
│   ├── TrackList.cs
│   ├── TrackRare.cs
│   ├── TrackSuperRare.cs
│   └── UnTrack.cs
├── Context.cs
├── EFT.Trainer.slnx
├── Extensions
│   ├── CameraExtensions.cs
│   ├── ELootRarityExtensions.cs
│   ├── ExfiltrationPointExtensions.cs
│   ├── HostileType.cs
│   ├── ItemExtensions.cs
│   ├── ItemTemplateExtensions.cs
│   ├── LootItemExtensions.cs
│   ├── NotNullWhenAttribute.cs
│   ├── PlayerExtensions.cs
│   ├── StringExtensions.cs
│   ├── ThrowableExtensions.cs
│   └── WorldInteractiveObjectExtensions.cs
├── Features
│   ├── Aimbot.cs
│   ├── AirDrop.cs
│   ├── Ammunition.cs
│   ├── AutomaticGun.cs
│   ├── BaseMapToggleFeature.cs
│   ├── Bones.cs
│   ├── CachableFeature.cs
│   ├── Commands.cs
│   ├── CrossHair.cs
│   ├── Durability.cs
│   ├── Examine.cs
│   ├── ExfiltrationPoints.cs
│   ├── Feature.cs
│   ├── FeatureFactory.cs
│   ├── FeatureRenderer.cs
│   ├── FovChanger.cs
│   ├── FreeCamera.cs
│   ├── GameState.cs
│   ├── Ghost.cs
│   ├── Grenades.cs
│   ├── Health.cs
│   ├── Hits.cs
│   ├── HoldFeature.cs
│   ├── Hud.cs
│   ├── Interact.cs
│   ├── LootItems.cs
│   ├── LootableContainers.cs
│   ├── Map.cs
│   ├── Mortar.cs
│   ├── NightVision.cs
│   ├── NoCollision.cs
│   ├── NoFlash.cs
│   ├── NoMalfunctions.cs
│   ├── NoRecoil.cs
│   ├── NoSway.cs
│   ├── NoVisor.cs
│   ├── Players.cs
│   ├── PointOfInterest.cs
│   ├── PointOfInterests.cs
│   ├── Quests.cs
│   ├── QuickThrow.cs
│   ├── Radar.cs
│   ├── SceneDumper.cs
│   ├── ShaderCache.cs
│   ├── ShaderProperties.cs
│   ├── Skills.cs
│   ├── Speed.cs
│   ├── Stamina.cs
│   ├── TemplateHelper.cs
│   ├── ThermalVision.cs
│   ├── ToggleFeature.cs
│   ├── TrackedItem.cs
│   ├── Train.cs
│   ├── TriggerFeature.cs
│   ├── WallShoot.cs
│   ├── Weather.cs
│   └── WorldInteractiveObjects.cs
├── Files
│   ├── FirstOutline.shader
│   ├── Managed
│   │   └── NLog.dll.nlog
│   └── outline
├── Installer
│   ├── CompilationContext.cs
│   ├── CompilationResult.cs
│   ├── Compiler.cs
│   ├── ExitCode.cs
│   ├── InstallCommand.cs
│   ├── Installation.cs
│   ├── Installer.csproj
│   ├── ParentProcessHelper.cs
│   ├── Program.cs
│   ├── Properties
│   │   ├── PublishProfiles
│   │   │   └── FolderProfile.pubxml
│   │   ├── Resources.Designer.cs
│   │   └── Resources.resx
│   ├── Registry.cs
│   ├── Resources
│   │   └── 0Harmony.dll
│   ├── UTF8StringWriter.cs
│   ├── UninstallCommand.cs
│   └── VersionChecker.cs
├── KnownTemplateIds.cs
├── LICENSE
├── Loader.cs
├── NLog.EFT.Trainer.csproj
├── Properties
│   ├── AssemblyInfo.cs
│   ├── Strings.Designer.cs
│   ├── Strings.fr.Designer.cs
│   ├── Strings.fr.resx
│   ├── Strings.jp.Designer.cs
│   ├── Strings.jp.resx
│   ├── Strings.resx
│   ├── Strings.zh-cn.Designer.cs
│   └── Strings.zh-cn.resx
├── README.md
└── UI
    ├── ColorPicker.cs
    ├── ColorUtil.cs
    ├── EnumPicker.cs
    ├── Picker.cs
    └── Render.cs

```

`BepInExPlugin/BepInExPlugin.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{00C66BBD-ED7F-4E01-B7E4-0388F76FD31C}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AssemblyName>spt-efttrainer</AssemblyName>
    <TargetFrameworkVersion>v4.7.1</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <LangVersion>latest</LangVersion>
    <EFTBasePath>C:\Battlestate Games\sptarkov</EFTBasePath>
    <EFTDataPath>$(EFTBasePath)\EscapeFromTarkov_Data</EFTDataPath>
    <EFTManagedPath>$(EFTDataPath)\Managed</EFTManagedPath>
    <EFTBepInExPath>$(EFTBasePath)\BepInEx</EFTBepInExPath>
    <EFTBepInExCorePath>$(EFTBepInExPath)\core</EFTBepInExCorePath>
    <EFTBepInExPluginsPath>$(EFTBepInExPath)\plugins</EFTBepInExPluginsPath>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>TRACE;DEBUG</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <ItemGroup>
    <!-- Framework -->
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="netstandard">
      <HintPath>$(EFTManagedPath)\netstandard.dll</HintPath>
    </Reference>
    <!-- Unity -->
    <Reference Include="UnityEngine">
      <HintPath>$(EFTManagedPath)\UnityEngine.dll</HintPath>
    </Reference>
    <Reference Include="UnityEngine.CoreModule">
      <HintPath>$(EFTManagedPath)\UnityEngine.CoreModule.dll</HintPath>
    </Reference>
    <!-- BepInEx -->
    <Reference Include="BepInEx">
      <HintPath>$(EFTBepInExCorePath)\BepInEx.dll</HintPath>
    </Reference>
  </ItemGroup>
  <ItemGroup>
    <Compile Include="SptEftTrainerPlugin.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\NLog.EFT.Trainer.csproj">
      <Project>{f4eb56b6-f914-11e9-aad5-362b9e155667}</Project>
      <Name>NLog.EFT.Trainer</Name>
    </ProjectReference>
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <PropertyGroup>
    <PostBuildEvent>copy /Y "$(TargetPath)" "$(EFTBepInExPluginsPath)"</PostBuildEvent>
  </PropertyGroup>
</Project>
```

`BepInExPlugin/Properties/AssemblyInfo.cs`:

```cs
using System.Reflection;

[assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyProduct("EFT Trainer, BepInEx plugin")]
[assembly: AssemblyCopyright("Copyright © 2024 Sebastien Lebreton")]

```

`BepInExPlugin/SptEftTrainerPlugin.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Reflection;
using BepInEx;
using EFT.Trainer;
using JetBrains.Annotations;
using UnityEngine.SceneManagement;

[BepInPlugin(PluginId, "SPT.EftTrainer", "1.0.0")]
[UsedImplicitly]
public class SptEftTrainerPlugin : BaseUnityPlugin
{
	private const string PluginId = "com.SPT.efttrainer";
	public static bool Loaded = false;

	[UsedImplicitly]
	public void Awake()
	{
		SetupSptBetaReleases();
		SceneManager.sceneLoaded += OnSceneLoaded;
	}

	private void OnSceneLoaded(Scene scene, LoadSceneMode mode)
	{
		LoadTrainer();

		if (Loaded)
			SceneManager.sceneLoaded -= OnSceneLoaded;
	}

	[UsedImplicitly]
	public void OnGUI()
	{
		RemoveSptBetaReleaseWatermark();
	}

	private void LoadTrainer()
	{
		if (Loaded)
			return;

		var scene = SceneManager.GetActiveScene();
		if (string.IsNullOrEmpty(scene.name))
			return;

		Logger.LogInfo($"Found {scene.name}, loading...");

		Loader.Load();
		Loaded = true;
	}

	private void RemoveSptBetaReleaseWatermark()
	{
		if (_commitHash == null)
			return;

		var hash = _commitHash.GetValue(null) as string;
		if (hash == string.Empty)
		{
			Logger.LogInfo("Disabling SPT hash monitoring");

			// Stop monitoring
			_commitHash = null;
			return;
		}

		// Suppress this dumb watermark
		Logger.LogInfo("Removing SPT watermark");
		_commitHash.SetValue(null, string.Empty);
	}

	private static FieldInfo _commitHash;
	private void SetupSptBetaReleases()
	{
		// Whitelist this plugin for spt beta releases
		var menuNotificationManager = Type.GetType("SPT.Custom.Utils.MenuNotificationManager, spt-custom", throwOnError: false);
		if (menuNotificationManager == null)
		{
			Logger.LogInfo("MenuNotificationManager not found");
			return;
		}

		var hashField = GetStaticField(menuNotificationManager, "whitelistedPlugins");
		if (hashField == null)
		{
			Logger.LogInfo("whitelistedPlugins not found");
			return;
		}

		Logger.LogInfo($"White-listing {PluginId}");
		var hashset = hashField.GetValue(null) as HashSet<string>;
		hashset?.Add(PluginId);

		_commitHash = GetStaticField(menuNotificationManager, "commitHash");
	}

	private static FieldInfo GetStaticField(Type type, string name)
	{
		return type.GetField(name, BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static)
			   ?? type.GetField(char.ToUpper(name[0]) + name.Substring(1), BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static);
	}
}

```

`Configuration/ColorConverter.cs`:

```cs
using System;
using System.Linq;
using System.Reflection;
using Newtonsoft.Json;
using UnityEngine;

#nullable enable

namespace EFT.Trainer.Configuration;

public class ColorConverter : JsonConverter
{
	public override void WriteJson(JsonWriter writer, object? value, JsonSerializer serializer)
	{
		if (value is not Color color)
			return;

		serializer.Serialize(writer, new[] { color.r, color.g, color.b, color.a });
	}

	public override object ReadJson(JsonReader reader, Type objectType, object? existingValue, JsonSerializer serializer)
	{
		var array = serializer.Deserialize<float[]>(reader);

		if (Nullable.GetUnderlyingType(objectType) == typeof(Color))
		{
			// Handle Nullable<Color> and previous bug saving a <null> as Color.clear
			if (array is null || new Color(array[0], array[1], array[2], array[3]) == Color.clear)
				return null!;
		}

		return array is null ? Color.clear : new Color(array[0], array[1], array[2], array[3]);
	}

	public override bool CanConvert(Type objectType)
	{
		return objectType == typeof(Color);
	}

	public static Color? Parse(string value)
	{
		if (string.IsNullOrEmpty(value))
			return null;

		value = value
			.Trim()
			.ToLower();

		var colorType = typeof(Color);
		var field = colorType.GetProperty(value, BindingFlags.Static | BindingFlags.Public);
		if (field != null)
			return (Color)field.GetValue(null);

		try
		{
			return JsonConvert.DeserializeObject<Color>(value, new ColorConverter());
		}
		catch (Exception)
		{
			return null;
		}
	}

	public static string[] ColorNames()
	{
		var colorType = typeof(Color);
		return [.. colorType
			.GetProperties(BindingFlags.Static | BindingFlags.Public)
			.Where(p => p.PropertyType == colorType)
			.Select(p => p.Name)];
	}
}

```

`Configuration/ConfigurationManager.cs`:

```cs
using System;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using EFT.Trainer.Features;
using EFT.Trainer.Properties;
using EFT.UI;
using Newtonsoft.Json;

#nullable enable

namespace EFT.Trainer.Configuration;

internal static class ConfigurationManager
{
	public static JsonConverter[] Converters => [new TrackedItemConverter(), new ColorConverter(), new KeyCodeConverter()];

	private static void AddConsoleLog(string log)
	{
		if (PreloaderUI.Instantiated)
			ConsoleScreen.Log(log);
	}

	public static void Load(string filename, Feature[] features, bool warnIfNotExists = true)
	{
		try
		{
			if (!File.Exists(filename))
			{
				if (warnIfNotExists)
					AddConsoleLog(string.Format(Strings.ErrorFileNotFoundFormat, filename));

				return;
			}

			var lines = File.ReadAllLines(filename);

			foreach (var feature in features)
			{
				var featureType = feature.GetType();
				var properties = GetOrderedProperties(featureType);

				foreach (var op in properties)
				{
					var key = $"{featureType.FullName}.{op.Property.Name}=";
					try
					{
						var line = lines.FirstOrDefault(l => l.StartsWith(key));
						if (line == null)
							continue;

						var value = JsonConvert.DeserializeObject(line.Substring(key.Length), op.Property.PropertyType, Converters);
						op.Property.SetValue(feature, value);
					}
					catch (JsonException)
					{
						AddConsoleLog(string.Format(Strings.ErrorCorruptedPropertyFormat, key, filename).Red());
					}
				}
			}

			AddConsoleLog(string.Format(Strings.CommandLoadSuccessFormat, filename));
		}
		catch (Exception ioe)
		{
			AddConsoleLog(string.Format(Strings.ErrorCannotLoadFormat, filename, ioe.Message).Red());
		}
	}

	public static void LoadPropertyValue(string filename, Feature feature, string propertyName)
	{
		try
		{
			if (!File.Exists(filename))
			{
				AddConsoleLog(string.Format(Strings.ErrorFileNotFoundFormat, filename).Red());
				return;
			}

			var text = File.ReadAllText(filename);

			var tlProperty = GetOrderedProperties(feature.GetType())
				.First(p => p.Property.Name == propertyName);

			try
			{
				var value = JsonConvert.DeserializeObject(text, tlProperty.Property.PropertyType, Converters);
				tlProperty.Property.SetValue(feature, value);
			}
			catch (JsonException)
			{
				AddConsoleLog(string.Format(Strings.ErrorCorruptedFileFormat, filename).Red());
			}

			AddConsoleLog(string.Format(Strings.CommandLoadSuccessFormat, filename));
		}
		catch (Exception ioe)
		{
			AddConsoleLog(string.Format(Strings.ErrorCannotLoadFormat, filename, ioe.Message).Red());
		}
	}

	public static void Save(string filename, Feature[] features)
	{
		try
		{
			var content = new StringBuilder();
			content.AppendLine(Comment(Strings.CommandSaveHeader));
			content.AppendLine();

			foreach (var feature in features.OrderBy(f => f.GetType().FullName))
			{
				var featureType = feature.GetType();
				var properties = GetOrderedProperties(featureType);

				foreach (var op in properties)
				{
					var key = $"{featureType.FullName}.{op.Property.Name}";
					var value = JsonConvert.SerializeObject(op.Property.GetValue(feature), Formatting.None, Converters);

					var resourceId = op.Attribute.CommentResourceId;
					if (!string.IsNullOrEmpty(resourceId))
						content.AppendLine(Comment(Strings.ResourceManager.GetString(resourceId)));

					content.AppendLine($"{key}={value}");
				}

				if (properties.Any())
					content.AppendLine();
			}

			File.WriteAllText(filename, content.ToString());
			AddConsoleLog(string.Format(Strings.CommandSaveSuccessFormat, filename));
		}
		catch (Exception ioe)
		{
			AddConsoleLog(string.Format(Strings.ErrorCannotSaveFormat, filename, ioe.Message).Red());
		}
	}

	private static string Comment(string? value)
	{
		if (string.IsNullOrEmpty(value))
			return string.Empty;

		const string commentToken = "; ";

		const string resxNewLine = "\n";
		return commentToken + value!.Replace(resxNewLine, resxNewLine + commentToken);
	}

	public static void SavePropertyValue(string filename, Feature feature, string propertyName)
	{
		try
		{
			var tlProperty = GetOrderedProperties(feature.GetType())
				.First(p => p.Property.Name == propertyName);

			var content = JsonConvert.SerializeObject(tlProperty.Property.GetValue(feature), Formatting.Indented, Converters);
			File.WriteAllText(filename, content);

			AddConsoleLog(string.Format(Strings.CommandSaveSuccessFormat, filename));
		}
		catch (Exception ioe)
		{
			AddConsoleLog(string.Format(Strings.ErrorCannotSaveFormat, filename, ioe.Message).Red());
		}
	}

	public static bool IsSkippedProperty(Feature feature, string name)
	{
		return IsSkippedProperty(feature.GetType(), name);
	}

	public static bool IsSkippedProperty(Type featureType, string name)
	{
		var property = featureType.GetProperty(name, BindingFlags.Instance | BindingFlags.Public | BindingFlags.FlattenHierarchy);
		if (property == null)
			return false;

		var attribute = property.GetCustomAttribute<ConfigurationPropertyAttribute>(true);
		return attribute is { Skip: true };
	}

	public static OrderedProperty[] GetOrderedProperties(Type featureType)
	{
		var properties = featureType.GetProperties(BindingFlags.Instance | BindingFlags.Public | BindingFlags.FlattenHierarchy);

		return
		[.. properties
			.Select(p => new { property = p, attribute = p.GetCustomAttribute<ConfigurationPropertyAttribute>(true) })
			.Where(p => p.attribute is { Skip: false })
			.Select(op => new OrderedProperty(op.attribute, op.property))
			.OrderBy(op => op.Attribute.Order)
			.ThenBy(op => op.Property.Name)
		];
	}
}

```

`Configuration/ConfigurationPropertyAttribute.cs`:

```cs
using System;

#nullable enable

namespace EFT.Trainer.Configuration;

[AttributeUsage(AttributeTargets.Property)]
public class ConfigurationPropertyAttribute : Attribute
{
	public bool Skip { get; set; } = false;
	public int Order { get; set; } = int.MaxValue;
	public string CommentResourceId { get; set; } = string.Empty;
	public bool Browsable { get; set; } = true;
}

```

`Configuration/EnumConverter.cs`:

```cs
using System;
using Newtonsoft.Json;

#nullable enable

namespace EFT.Trainer.Configuration;

public class EnumConverter<T> : JsonConverter where T : Enum
{
	public override void WriteJson(JsonWriter writer, object? value, JsonSerializer serializer)
	{
		value ??= default(T)!;
		serializer.Serialize(writer, Enum.GetName(typeof(T), value));
	}

	public override object ReadJson(JsonReader reader, Type objectType, object? existingValue, JsonSerializer serializer)
	{
		var value = serializer.Deserialize<string>(reader);
		return value == null ? default(T)! : Enum.Parse(typeof(T), value);
	}

	public override bool CanConvert(Type objectType)
	{
		return objectType == typeof(T);
	}
}

```

`Configuration/KeyCodeConverter.cs`:

```cs
using System;
using Newtonsoft.Json;
using UnityEngine;

#nullable enable

namespace EFT.Trainer.Configuration;

public class KeyCodeConverter : EnumConverter<KeyCode>;

```

`Configuration/OrderedProperty.cs`:

```cs
using System.Reflection;

#nullable enable

namespace EFT.Trainer.Configuration;

internal class OrderedProperty(ConfigurationPropertyAttribute attribute, PropertyInfo property)
{
	public ConfigurationPropertyAttribute Attribute { get; } = attribute;
	public PropertyInfo Property { get; } = property;
}

```

`Configuration/TrackedItemConverter.cs`:

```cs
using System;
using EFT.Trainer.Features;
using EFT.Trainer.Properties;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;

#nullable enable

namespace EFT.Trainer.Configuration;

public class TrackedItemConverter : JsonConverter
{
	public override void WriteJson(JsonWriter writer, object? value, JsonSerializer serializer)
	{
		if (value is not TrackedItem item)
			return;

		if (item.Color.HasValue | item.Rarity.HasValue)
			serializer.Serialize(writer, JObject.FromObject(item));
		else
			serializer.Serialize(writer, item.Name);
	}

	public override object ReadJson(JsonReader reader, Type objectType, object? existingValue, JsonSerializer serializer)
	{
		var value = serializer.Deserialize(reader);
		return value switch
		{
			string name => new TrackedItem(name),
			JObject jobject => jobject.ToObject<TrackedItem>()!,
			_ => new TrackedItem(string.Format(Strings.ErrorCorruptedFileFormat, "trainer.ini"))
		};
	}

	public override bool CanConvert(Type objectType)
	{
		return objectType == typeof(TrackedItem);
	}
}

```

`ConsoleCommands/BaseListCommand.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using Comfort.Common;
using EFT.Interactive;
using EFT.InventoryLogic;
using EFT.Trainer.Extensions;
using EFT.Trainer.Features;
using EFT.Trainer.Properties;
using JsonType;

#nullable enable

namespace EFT.Trainer.ConsoleCommands;

internal abstract class BaseListCommand : ConsoleCommandWithArgument
{
	public override string Pattern => OptionalArgumentPattern;
	protected virtual ELootRarity? Rarity => null;

	public override void Execute(Match match)
	{
		ListLootItems(match, Rarity);
	}

	private void ListLootItems(Match match, ELootRarity? rarityFilter = null)
	{
		var search = string.Empty;
		var matchGroup = match.Groups[ValueGroup];
		if (matchGroup is { Success: true })
		{
			search = matchGroup.Value.Trim();
			if (search == TrackedItem.MatchAll)
				search = string.Empty;
		}

		var world = Singleton<GameWorld>.Instance;
		if (world == null)
			return;

		var itemsPerName = new Dictionary<string, List<Item>>();

		// Step 1 - look outside containers and inside corpses (loot items)
		FindLootItems(world, itemsPerName);

		// Step 2 - look inside containers (items)
		if (LootItemsFeature.SearchInsideContainers)
			FindItemsInContainers(world, itemsPerName);

		var names = itemsPerName.Keys.ToList();
		names.Sort();
		names.Reverse();

		var count = 0;
		foreach (var itemName in names)
		{
			if (itemName.IndexOf(search, StringComparison.OrdinalIgnoreCase) < 0)
				continue;

			var list = itemsPerName[itemName];
			var rarity = list.First().Template.GetEstimatedRarity();
			if (rarityFilter.HasValue && rarityFilter.Value != rarity)
				continue;

			var extra = rarity != ELootRarity.Not_exist ? string.Format(Strings.CommandListRarityFormat, rarity.Color()) : string.Empty;
			AddConsoleLog(string.Format(Strings.CommandListEnumerateFormat, itemName, list.Count.ToString().Cyan(), extra));

			count += list.Count;
		}

		AddConsoleLog(Strings.TextSeparator);
		AddConsoleLog(string.Format(Strings.CommandListSuccessFormat, count.ToString().Cyan()));
	}

	private static void FindItemsInRootItem(Dictionary<string, List<Item>> itemsPerName, Item? rootItem)
	{
		var items = rootItem?
			.GetAllItems()?
			.ToArray();

		if (items == null)
			return;

		IndexItems(items, itemsPerName);
	}

	private void FindLootItems(GameWorld world, Dictionary<string, List<Item>> itemsPerName)
	{
		var lootItems = world.LootItems;
		var filteredItems = new List<Item>();
		for (var i = 0; i < lootItems.Count; i++)
		{
			var lootItem = lootItems.GetByIndex(i);
			if (!lootItem.IsValid())
				continue;

			if (lootItem is Corpse corpse)
			{
				if (LootItemsFeature.SearchInsideCorpses)
					FindItemsInRootItem(itemsPerName, corpse.ItemOwner?.RootItem);

				continue;
			}

			filteredItems.Add(lootItem.Item);
		}

		IndexItems(filteredItems, itemsPerName);
	}

	private static void IndexItems(IEnumerable<Item> items, Dictionary<string, List<Item>> itemsPerName)
	{
		foreach (var item in items)
		{
			if (!item.IsValid() || item.IsFiltered())
				continue;

			var itemName = item.ShortName.Localized();
			if (!itemsPerName.TryGetValue(itemName, out var pnList))
			{
				pnList = [];
				itemsPerName[itemName] = pnList;
			}

			pnList.Add(item);
		}
	}

	private static void FindItemsInContainers(GameWorld world, Dictionary<string, List<Item>> itemsPerName)
	{
		var owners = world.ItemOwners; // contains all containers: corpses, LootContainers, ...
		foreach (var owner in owners)
		{
			var rootItem = owner.Key.RootItem;
			if (rootItem is not { IsContainer: true })
				continue;

			if (!rootItem.IsValid() || rootItem.IsFiltered()) // filter default inventory container here, given we special case the corpse container
				continue;

			FindItemsInRootItem(itemsPerName, rootItem);
		}
	}
}

```

`ConsoleCommands/BaseTemplateCommand.cs`:

```cs
#nullable enable

namespace EFT.Trainer.ConsoleCommands;

internal abstract class BaseTemplateCommand : ConsoleCommandWithArgument
{
	public override string Pattern => RequiredArgumentPattern;
}

```

`ConsoleCommands/BaseTrackCommand.cs`:

```cs
using System.Text.RegularExpressions;
using EFT.Trainer.Configuration;
using JsonType;
using UnityEngine;

#nullable enable

namespace EFT.Trainer.ConsoleCommands;

internal abstract class BaseTrackCommand : ConsoleCommandWithArgument
{
	private static string ColorNames => string.Join("|", ColorConverter.ColorNames());
	public override string Pattern => $"(?<{ValueGroup}>.+?)(?<{ExtraGroup}> ({ColorNames}|\\[[\\.,\\d ]*\\]{{1}}))?";
	protected virtual ELootRarity? Rarity => null;

	public override void Execute(Match match)
	{
		TrackLootItem(match, Rarity);
	}

	private void TrackLootItem(Match match, ELootRarity? rarity = null)
	{
		var matchGroup = match.Groups[ValueGroup];
		if (matchGroup is not { Success: true })
			return;

		Color? color = null;
		var extraGroup = match.Groups[ExtraGroup];
		if (extraGroup is { Success: true })
			color = ColorConverter.Parse(extraGroup.Value);

		TrackList.ShowTrackList(this, LootItemsFeature, LootItemsFeature.Track(matchGroup.Value, color, rarity));
	}
}

```

`ConsoleCommands/BaseTrackListCommand.cs`:

```cs
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Text.RegularExpressions;

#nullable enable

namespace EFT.Trainer.ConsoleCommands;

internal abstract class BaseTrackListCommand : ConsoleCommandWithArgument
{
	public override string Pattern => RequiredArgumentPattern;

	protected static bool TryGetTrackListFilename(Match match, [NotNullWhen(true)] out string? filename)
	{
		filename = null;

		var matchGroup = match.Groups[ValueGroup];
		if (matchGroup is not { Success: true })
			return false;

		filename = matchGroup.Value;

		if (!Path.IsPathRooted(filename))
			filename = Path.Combine(Context.UserPath, filename);

		if (!Path.HasExtension(filename))
			filename += ".tl";

		return true;
	}
}

```

`ConsoleCommands/BuiltInCommand.cs`:

```cs
using System;

#nullable enable

namespace EFT.Trainer.ConsoleCommands;

internal class BuiltInCommand(string name, Action action) : ConsoleCommandWithoutArgument
{
	public override string Name => name;

	public override void Execute()
	{
		action();
	}
}

```

`ConsoleCommands/ConsoleCommand.cs`:

```cs
using System;
using EFT.UI;

#nullable enable

namespace EFT.Trainer.ConsoleCommands;

internal abstract class ConsoleCommand
{
	// StayInTarkov (SIT) is exposing a LootItems type in the global namespace, so make sure we use a qualified name here
	private readonly Lazy<Features.LootItems> _lootItems = new(() => Features.FeatureFactory.GetFeature<Features.LootItems>()!);
	protected Features.LootItems LootItemsFeature => _lootItems.Value;

	public abstract string Name { get; }

	internal void AddConsoleLog(string log)
	{
		if (PreloaderUI.Instantiated)
			ConsoleScreen.Log(log);
	}

	public abstract void Register();
}

```

`ConsoleCommands/ConsoleCommandWithArgument.cs`:

```cs
using System.Text.RegularExpressions;
using EFT.Trainer.Properties;
using EFT.UI;

#nullable enable

namespace EFT.Trainer.ConsoleCommands;

internal abstract class ConsoleCommandWithArgument : ConsoleCommand
{
	public abstract string Pattern { get; }

	public abstract void Execute(Match match);

	protected const string ValueGroup = "value";
	protected const string ExtraGroup = "extra";

	protected const string RequiredArgumentPattern = $"(?<{ValueGroup}>.+)";
	protected const string OptionalArgumentPattern = $"(?<{ValueGroup}>.*)";

	public override void Register()
	{
#if DEBUG
		AddConsoleLog(string.Format(Strings.DebugRegisteringCommandWithArgumentsFormat, Name));
#endif
		ConsoleScreen.Processor.RegisterCommand(Name, (string args) =>
		{
			var regex = new Regex("^" + Pattern + "$");
			if (regex.IsMatch(args))
			{
				Execute(regex.Match(args));
			}
			else
			{
				AddConsoleLog(Strings.ErrorInvalidArguments.Red());
			}
		});
	}
}

```

`ConsoleCommands/ConsoleCommandWithoutArgument.cs`:

```cs
using EFT.Trainer.Properties;
using EFT.UI;

#nullable enable

namespace EFT.Trainer.ConsoleCommands;

internal abstract class ConsoleCommandWithoutArgument : ConsoleCommand
{
	public abstract void Execute();

	public override void Register()
	{
#if DEBUG
		AddConsoleLog(string.Format(Strings.DebugRegisteringCommandFormat, Name));
#endif
		ConsoleScreen.Processor.RegisterCommand(Name, Execute);
	}
}

```

`ConsoleCommands/Dump.cs`:

```cs
using System;
using System.IO;
using EFT.Trainer.Features;
using EFT.Trainer.Properties;
using JetBrains.Annotations;
using UnityEngine;
using UnityEngine.SceneManagement;

#nullable enable

namespace EFT.Trainer.ConsoleCommands;

[UsedImplicitly]
internal class Dump : ConsoleCommandWithoutArgument
{
	public override string Name => Strings.CommandDump;

	public override void Execute()
	{
		var dumpfolder = Path.Combine(Context.UserPath, "Dumps");
		var thisDump = Path.Combine(dumpfolder, $"{DateTime.Now:yyyyMMdd-HHmmss}");

		Directory.CreateDirectory(thisDump);

		AddConsoleLog(Strings.CommandDumpScenes);
		for (int i = 0; i < SceneManager.sceneCount; i++)
		{
			var scene = SceneManager.GetSceneAt(i);
			if (!scene.isLoaded)
				continue;

			var json = SceneDumper.DumpScene(scene).ToPrettyJson();
			File.WriteAllText(Path.Combine(thisDump, GetSafeFilename($"@scene - {scene.name}.txt")), json);
		}

		AddConsoleLog(Strings.CommandDumpGameObjects);
		foreach (var go in UnityEngine.Object.FindObjectsOfType<GameObject>())
		{
			if (go == null || go.transform.parent != null || !go.activeSelf)
				continue;

			var filename = GetSafeFilename(go.name + "-" + go.GetHashCode() + ".txt");
			var json = SceneDumper.DumpGameObject(go).ToPrettyJson();
			File.WriteAllText(Path.Combine(thisDump, filename), json);
		}

		AddConsoleLog(string.Format(Strings.CommandDumpSuccessFormat, thisDump));
	}

	private static string GetSafeFilename(string filename)
	{
		return string.Join("_", filename.Split(Path.GetInvalidFileNameChars()));
	}

}

```

`ConsoleCommands/List.cs`:

```cs
using EFT.Trainer.Properties;
using JetBrains.Annotations;

#nullable enable

namespace EFT.Trainer.ConsoleCommands;

[UsedImplicitly]
internal class List : BaseListCommand
{
	public override string Name => Strings.CommandList;
}

```

`ConsoleCommands/ListRare.cs`:

```cs
using EFT.Trainer.Properties;
using JetBrains.Annotations;
using JsonType;

#nullable enable

namespace EFT.Trainer.ConsoleCommands;

[UsedImplicitly]
internal class ListRare : BaseListCommand
{
	public override string Name => Strings.CommandListRare;
	protected override ELootRarity? Rarity => ELootRarity.Rare;
}

```

`ConsoleCommands/ListSuperRare.cs`:

```cs
using EFT.Trainer.Properties;
using JetBrains.Annotations;
using JsonType;

#nullable enable

namespace EFT.Trainer.ConsoleCommands;

[UsedImplicitly]
internal class ListSuperRare : BaseListCommand
{
	public override string Name => Strings.CommandListSuperRare;
	protected override ELootRarity? Rarity => ELootRarity.Superrare;
}

```

`ConsoleCommands/LoadTrackList.cs`:

```cs
using System.Text.RegularExpressions;
using EFT.Trainer.Configuration;
using EFT.Trainer.Properties;
using JetBrains.Annotations;

#nullable enable

namespace EFT.Trainer.ConsoleCommands;

[UsedImplicitly]
internal class LoadTrackList : BaseTrackListCommand
{
	public override string Name => Strings.CommandLoadTrackList;

	public override void Execute(Match match)
	{
		if (!TryGetTrackListFilename(match, out var filename))
			return;

		// StayInTarkov (SIT) is exposing a LootItems type in the global namespace, so make sure we use a qualified name here
		ConfigurationManager.LoadPropertyValue(filename, LootItemsFeature, nameof(Features.LootItems.TrackedNames));
	}
}

```

`ConsoleCommands/SaveTrackList.cs`:

```cs
using System.Text.RegularExpressions;
using EFT.Trainer.Configuration;
using EFT.Trainer.Properties;
using JetBrains.Annotations;

#nullable enable

namespace EFT.Trainer.ConsoleCommands;

[UsedImplicitly]
internal class SaveTrackList : BaseTrackListCommand
{
	public override string Name => Strings.CommandSaveTrackList;

	public override void Execute(Match match)
	{
		if (!TryGetTrackListFilename(match, out var filename))
			return;

		// StayInTarkov (SIT) is exposing a LootItems type in the global namespace, so make sure we use a qualified name here
		ConfigurationManager.SavePropertyValue(filename, LootItemsFeature, nameof(LootItemsFeature.TrackedNames));
	}
}

```

`ConsoleCommands/Spawn.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using Comfort.Common;
using Diz.Utils;
using EFT.CameraControl;
using EFT.InventoryLogic;
using EFT.Trainer.Extensions;
using EFT.Trainer.Features;
using EFT.Trainer.Properties;
using JetBrains.Annotations;
using Random = UnityEngine.Random;

#nullable enable

namespace EFT.Trainer.ConsoleCommands;

[UsedImplicitly]
internal class Spawn : BaseTemplateCommand
{
	public override string Name => Strings.CommandSpawn;

	public override void Execute(Match match)
	{
		var matchGroup = match.Groups[ValueGroup];
		if (matchGroup is not { Success: true })
			return;

		var player = GameState.Current?.LocalPlayer;
		if (player == null)
			return;

		var search = matchGroup.Value;
		var templates = TemplateHelper.FindTemplates(search);

		switch (templates.Length)
		{
			case 0:
				AddConsoleLog(Strings.ErrorNoTemplateFound.Red());
				return;
			case > 1:
				foreach (var template in templates)
					AddConsoleLog(string.Format(Strings.CommandTemplateEnumerateFormat, template._id, template.ShortNameLocalizationKey.Localized().Green(), template.NameLocalizationKey.Localized()));

				AddConsoleLog(string.Format(Strings.ErrorTooManyTemplatesFormat, templates.Length.ToString().Cyan()));
				return;
		}

		var tpl = templates[0];
		SpawnTemplate(tpl, player, this);
	}

	internal static void SpawnTemplate(string template, Player player, ConsoleCommand command, Func<ItemTemplate, bool> filter)
	{
		var result = TemplateHelper.FindTemplates(template)
			.FirstOrDefault(filter);

		if (result == null)
			return;

		SpawnTemplate(result, player, command);
	}

	private static void SpawnTemplate(ItemTemplate template, Player player, ConsoleCommand command)
	{
		var poolManager = Singleton<PoolManagerClass>.Instance;

		poolManager
			.LoadBundlesAndCreatePools(PoolManagerClass.PoolsCategory.Raid, PoolManagerClass.AssemblyType.Online, [.. template.AllResources], JobPriorityClass.Immediate)
			.ContinueWith(task =>
			{
				AsyncWorker.RunInMainTread(delegate
				{
					if (task.IsFaulted)
					{
						command.AddConsoleLog(Strings.ErrorFailedToLoadItemBundle.Red());
					}
					else
					{
						var itemFactory = Singleton<ItemFactoryClass>.Instance;
						var item = itemFactory.CreateItem(MongoID.Generate(), template._id, null);
						if (item == null)
						{
							command.AddConsoleLog(Strings.ErrorFailedToCreateItem.Red());
						}
						else
						{
							_ = new TraderControllerClass(item, item.Id, item.ShortName);
							var go = poolManager.CreateLootPrefab(item, ECameraType.Default);

							go.SetActive(value: true);
							var lootItem = Singleton<GameWorld>.Instance.CreateLootWithRigidbody(go, item, item.ShortName, randomRotation: false, null, out _, true);

							var transform = player.Transform;
							var position = transform.position
										   + transform.right * Random.Range(-1f, 1f)
										   + transform.forward * 2f
										   + transform.up * 0.5f;

							lootItem.transform.SetPositionAndRotation(position, transform.rotation);
							lootItem.LastOwner = player;

							// setup after loot item is created, else we are hitting issues with weapon
							SetupItem(itemFactory, item);
						}
					}
				});

				return Task.CompletedTask;
			});
	}

	private static void SetupItem(ItemFactoryClass itemFactory, Item item)
	{
		item.SpawnedInSession = true; // found in raid

		if (item.TryGetItemComponent<DogtagComponent>(out var dogtag))
		{
			dogtag.AccountId = Random.Range(0, int.MaxValue).ToString();
			dogtag.ProfileId = Random.Range(0, int.MaxValue).ToString();
			dogtag.Nickname = $"Rambo{Random.Range(1, 256)}";
			dogtag.Side = Enum.GetValues(typeof(EPlayerSide)).Cast<EPlayerSide>().Random();
			dogtag.Level = Random.Range(1, 69);
			dogtag.Time = DateTime.Now;
			dogtag.Status = "died";
			dogtag.KillerAccountId = Random.Range(0, int.MaxValue).ToString();
			dogtag.KillerProfileId = Random.Range(0, int.MaxValue).ToString();
			dogtag.KillerName = "";
			dogtag.WeaponName = "";
		}

		if (item.TryGetItemComponent<ArmorHolderComponent>(out var armorHolder))
			FillSlots(itemFactory, armorHolder.ArmorSlots);

		if (item.TryGetItemComponent<RepairableComponent>(out var repairable))
		{
			repairable.MaxDurability = repairable.TemplateDurability;
			repairable.Durability = repairable.MaxDurability;
		}

		if (item is CompoundItem compound)
			FillSlots(itemFactory, compound.AllSlots);

		if (item is IAmmoContainer container) // AmmoBox or Magazine
			FillStackSlot(itemFactory, container.Cartridges);
	}

	private static void FillSlots(ItemFactoryClass itemFactory, IEnumerable<Slot> slots)
	{
		foreach (var slot in slots)
		{
			if (slot.Items.Any())
				continue;

			var filter = slot
				.Filters.FirstOrDefault()?
				.Filter.Random();

			if (filter == null)
				continue;

			var item = itemFactory.CreateItem(MongoID.Generate(), filter, null);
			SetupItem(itemFactory, item);

			slot.AddWithoutRestrictions(item);
		}
	}

	private static void FillStackSlot(ItemFactoryClass itemFactory, StackSlot slot)
	{
		var filter = slot
			.Filters.FirstOrDefault()?
			.Filter.Random();

		if (filter == null)
			return;

		while (slot.Count < slot.MaxCount)
		{
			var item = itemFactory.CreateItem(MongoID.Generate(), filter, null);
			slot.Add(item, false);
		}
	}
}

```

`ConsoleCommands/SpawnBot.cs`:

```cs
using System;
using System.Linq;
using System.Text.RegularExpressions;
using Comfort.Common;
using EFT.Trainer.Extensions;
using EFT.Trainer.Properties;
using JetBrains.Annotations;

#nullable enable

namespace EFT.Trainer.ConsoleCommands;

[UsedImplicitly]
internal class SpawnBot : ConsoleCommandWithArgument
{
	public const string MatchAll = "*";

	public override string Pattern => RequiredArgumentPattern;
	public override string Name => Strings.CommandSpawnBot;

	public override void Execute(Match match)
	{
		var matchGroup = match.Groups[ValueGroup];
		if (matchGroup is not { Success: true })
			return;

		var search = matchGroup.Value.Trim();
		var bots = FindBots(search);

		switch (bots.Length)
		{
			case 0:
				AddConsoleLog(Strings.ErrorNoBotFound.Red());
				return;

			case > 1 when search != MatchAll:
				foreach (var bot in bots)
					AddConsoleLog(string.Format(Strings.CommandSpawnBotEnumerateFormat, bot.Green()));

				AddConsoleLog(string.Format(Strings.ErrorTooManyBotsFormat, bots.Length.ToString().Cyan()));
				return;
		}

		SpawnBots(bots);
	}

	private static void SpawnBots(string[] bots)
	{
		var instance = Singleton<IBotGame>.Instance;
		if (instance == null)
			return;

		var controller = instance.BotsController;
		var spawner = controller?.BotSpawner;

		if (spawner == null)
			return;

		foreach (var bot in bots)
			spawner.SpawnBotByTypeForce(1, (WildSpawnType)Enum.Parse(typeof(WildSpawnType), bot), BotDifficulty.normal, null);
	}

	private static string[] FindBots(string search)
	{
		var names = GetBotNames();

		if (search == MatchAll)
			return names;

		var exactMatch = names
			.Where(n => n.Equals(search, StringComparison.OrdinalIgnoreCase))
			.ToArray();

		if (exactMatch.Length == 1)
			return exactMatch;

		return [.. names.Where(n => n.IndexOf(search, StringComparison.OrdinalIgnoreCase) >= 0)];
	}

	private static string[] GetBotNames()
	{
		var filter = new[] { "test", "event", "spirit", "shooterbtr" };

		return [.. Enum
			.GetNames(typeof(WildSpawnType))
			.Where(n => !filter.Any(f => n.IndexOf(f, StringComparison.OrdinalIgnoreCase) >= 0))
			.OrderBy(n => n)];
	}
}

```

`ConsoleCommands/SpawnHideoutItems.cs`:

```cs
using System.Collections.Generic;
using System.Linq;
using EFT.Trainer.Extensions;
using EFT.Trainer.Features;
using EFT.Trainer.Properties;
using HarmonyLib;
using JetBrains.Annotations;

#nullable enable

namespace EFT.Trainer.ConsoleCommands;

[UsedImplicitly]
internal class SpawnHideoutItems : ConsoleCommandWithoutArgument
{
	public override string Name => Strings.CommandSpawnHideoutItems;

	public override void Execute()
	{
		var player = GameState.Current?.LocalPlayer;
		if (!player.IsValid())
			return;

		var manager = player.Profile?.WishlistManager;
		if (manager == null)
			return;

		// Find the obfuscated method that returns the computed hidout items
		// We need to have the auto-add hideout items enabled in EFT settings
		var method = AccessTools
			.GetDeclaredMethods(manager.GetType())
			.FirstOrDefault(m => m.ReturnType == typeof(IEnumerable<MongoID>));

		if (method?.Invoke(manager, []) is not IEnumerable<MongoID> templates)
			return;

		foreach (var template in templates)
			Spawn.SpawnTemplate(template, player, this, _ => true);
	}
}

```

`ConsoleCommands/SpawnQuestItems.cs`:

```cs
using System.Collections.Generic;
using System.Linq;
using EFT.Quests;
using EFT.Trainer.Extensions;
using EFT.Trainer.Features;
using EFT.Trainer.Properties;
using JetBrains.Annotations;
using UnityEngine;

#nullable enable

namespace EFT.Trainer.ConsoleCommands;

[UsedImplicitly]
internal class SpawnQuestItems : ConsoleCommandWithoutArgument
{
	public override string Name => Strings.CommandSpawnQuestItems;

	public override void Execute()
	{
		var player = GameState.Current?.LocalPlayer;
		if (!player.IsValid())
			return;

		var profile = player.Profile;

		var startedQuests = profile.QuestsData
			.Where(q => q.Status is EQuestStatus.Started && q.Template != null)
			.ToArray();

		if (!startedQuests.Any())
			return;

		foreach (var quest in startedQuests)
		{
			foreach (var condition in GetConditions(quest))
			{
				var count = Mathf.RoundToInt(condition.value);
				if (count is <= 0 or > 20)
					continue;

				foreach (var target in condition.target)
				{
					for (var i = 0; i < count; i++)
						Spawn.SpawnTemplate(target, player, this, t => !t.QuestItem); // for now we are only able to spawn non location-specific items like batteries, meds, keys, etc.
				}
			}
		}
	}

	private static IEnumerable<ConditionMultipleTargets> GetConditions(QuestDataClass quest)
	{
		// do we need to add ConditionMultipleTargets / ConditionItem / ConditionPlaceItem
		var conditions = quest.Template!.Conditions[EQuestStatus.AvailableForFinish];
		return conditions.OfType<ConditionFindItem>();
	}
}

```

`ConsoleCommands/Status.cs`:

```cs
using EFT.Trainer.Features;
using EFT.Trainer.Properties;
using JetBrains.Annotations;
using UnityEngine;

#nullable enable

namespace EFT.Trainer.ConsoleCommands;

[UsedImplicitly]
internal class Status : ConsoleCommandWithoutArgument
{
	public override string Name => Strings.CommandStatus;

	private static string GetFeatureHelpText(ToggleFeature feature)
	{
		var toggleKey = feature.Key != KeyCode.None ? string.Format(Strings.CommandStatusTextToggleFormat, feature.Key) : string.Empty;
		return string
			.Format(Strings.CommandStatusTextFormat, feature.Name, feature.Enabled ? Strings.TextOn.Green() : Strings.TextOff.Red(), toggleKey)
			.Trim();
	}

	public override void Execute()
	{
		foreach (var feature in Context.ToggleableFeatures.Value)
		{
			if (feature is Commands or GameState)
				continue;

			AddConsoleLog(GetFeatureHelpText(feature));
		}
	}
}

```

`ConsoleCommands/Template.cs`:

```cs
using System.Text.RegularExpressions;
using EFT.Trainer.Extensions;
using EFT.Trainer.Features;
using EFT.Trainer.Properties;
using JetBrains.Annotations;

#nullable enable

namespace EFT.Trainer.ConsoleCommands;

[UsedImplicitly]
internal class Template : BaseTemplateCommand
{
	public override string Name => Strings.CommandTemplate;

	public override void Execute(Match match)
	{
		var matchGroup = match.Groups[ValueGroup];
		if (matchGroup is not { Success: true })
			return;

		var search = matchGroup.Value;

		var templates = TemplateHelper.FindTemplates(search);

		foreach (var template in templates)
			AddConsoleLog(string.Format(Strings.CommandTemplateEnumerateFormat, template._id, template.ShortNameLocalizationKey.Localized().Green(), template.NameLocalizationKey.Localized()));

		AddConsoleLog(Strings.TextSeparator);
		AddConsoleLog(string.Format(Strings.CommandTemplateSuccessFormat, templates.Length.ToString().Cyan()));
	}
}

```

`ConsoleCommands/ToggleFeatureCommand.cs`:

```cs
using System.Text.RegularExpressions;
using EFT.Trainer.Features;
using EFT.Trainer.Properties;

#nullable enable

namespace EFT.Trainer.ConsoleCommands;

internal class ToggleFeatureCommand(ToggleFeature feature) : ConsoleCommandWithArgument
{
	public override string Name => feature.Name;
	public override string Pattern => $"(?<{ValueGroup}>({Strings.TextOn})|({Strings.TextOff}))";

	public override void Execute(Match match)
	{
		var matchGroup = match.Groups[ValueGroup];
		if (matchGroup is not { Success: true })
			return;

		var value = matchGroup.Value;
		feature.Enabled = value == Strings.TextOn;
	}
}

```

`ConsoleCommands/Track.cs`:

```cs
using EFT.Trainer.Properties;
using JetBrains.Annotations;

#nullable enable

namespace EFT.Trainer.ConsoleCommands;

[UsedImplicitly]
internal class Track : BaseTrackCommand
{
	public override string Name => Strings.CommandTrack;
}

```

`ConsoleCommands/TrackList.cs`:

```cs
using EFT.Trainer.Extensions;
using EFT.Trainer.Properties;
using JetBrains.Annotations;

#nullable enable

namespace EFT.Trainer.ConsoleCommands;

[UsedImplicitly]
internal class TrackList : ConsoleCommandWithoutArgument
{
	public override string Name => Strings.CommandTrackList;

	public override void Execute()
	{
		ShowTrackList(this, LootItemsFeature);
	}

	// StayInTarkov (SIT) is exposing a LootItems type in the global namespace, so make sure we use a qualified name here
	internal static void ShowTrackList(ConsoleCommand command, Features.LootItems lootItems, bool changed = false)
	{
		if (changed)
			command.AddConsoleLog(Strings.CommandTrackListUpdated);

		foreach (var templateId in lootItems.Wishlist)
			command.AddConsoleLog(string.Format(Strings.CommandTrackListWishListEnumerateFormat, ((MongoID)templateId).LocalizedShortName()));

		foreach (var item in lootItems.TrackedNames)
		{
			var extra = item.Rarity.HasValue ? string.Format(Strings.CommandTrackListRarityFormat, item.Rarity.Value.Color()) : string.Empty;
			command.AddConsoleLog(string.Format(Strings.CommandTrackListEnumerateFormat, item.Color.HasValue ? item.Name.Color(item.Color.Value) : item.Name, extra));
		}
	}
}

```

`ConsoleCommands/TrackRare.cs`:

```cs
using EFT.Trainer.Properties;
using JetBrains.Annotations;
using JsonType;

#nullable enable

namespace EFT.Trainer.ConsoleCommands;

[UsedImplicitly]
internal class TrackRare : BaseTrackCommand
{
	public override string Name => Strings.CommandTrackRare;
	protected override ELootRarity? Rarity => ELootRarity.Rare;
}

```

`ConsoleCommands/TrackSuperRare.cs`:

```cs
using EFT.Trainer.Properties;
using JetBrains.Annotations;
using JsonType;

#nullable enable

namespace EFT.Trainer.ConsoleCommands;

[UsedImplicitly]
internal class TrackSuperRare : BaseTrackCommand
{
	public override string Name => Strings.CommandTrackSuperRare;
	protected override ELootRarity? Rarity => ELootRarity.Superrare;
}

```

`ConsoleCommands/UnTrack.cs`:

```cs
using System.Text.RegularExpressions;
using EFT.Trainer.Properties;
using JetBrains.Annotations;

#nullable enable

namespace EFT.Trainer.ConsoleCommands;

[UsedImplicitly]
internal class UnTrack : BaseTrackCommand
{
	public override string Name => Strings.CommandUnTrack;

	public override void Execute(Match match)
	{
		var matchGroup = match.Groups[ValueGroup];
		if (matchGroup is not { Success: true })
			return;

		TrackList.ShowTrackList(this, LootItemsFeature, LootItemsFeature.UnTrack(matchGroup.Value));
	}
}

```

`Context.cs`:

```cs
using System;
using System.IO;
using System.Linq;
using EFT.Trainer.Features;

namespace EFT.Trainer;

internal static class Context
{
	public static string UserPath => Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments), "Escape from Tarkov");
	public static string ConfigFile => Path.Combine(UserPath, "trainer.ini");

	public static Lazy<Feature[]> Features => new(() => [.. FeatureFactory.GetAllFeatures().OrderBy(f => f.Name)]);
	public static Lazy<ToggleFeature[]> ToggleableFeatures => new(() => [.. FeatureFactory.GetAllToggleableFeatures().OrderByDescending(f => f.Name)]);
}

```

`EFT.Trainer.slnx`:

```slnx
<Solution>
  <Configurations>
    <BuildType Name="Debug" />
    <BuildType Name="DebugPerformance" />
    <BuildType Name="Release" />
  </Configurations>
  <Project Path="BepInExPlugin/BepInExPlugin.csproj" Id="00c66bbd-ed7f-4e01-b7e4-0388f76fd31c">
    <BuildType Solution="DebugPerformance|*" Project="Debug" />
  </Project>
  <Project Path="Installer/Installer.csproj">
    <BuildType Solution="DebugPerformance|*" Project="Debug" />
  </Project>
  <Project Path="NLog.EFT.Trainer.csproj" Id="f4eb56b6-f914-11e9-aad5-362b9e155667" />
</Solution>

```

`Extensions/CameraExtensions.cs`:

```cs
using UnityEngine;

#nullable enable

namespace EFT.Trainer.Extensions;

public static class CameraExtensions
{
	public static Vector2 WorldPointToScreenPoint(this Camera camera, Vector3 worldPoint)
	{
		var screenPoint = camera.WorldToScreenPoint(worldPoint);
		var scale = Screen.height / (float)camera.scaledPixelHeight;
		screenPoint.y = Screen.height - screenPoint.y * scale;
		screenPoint.x *= scale;
		return screenPoint;
	}

	/* Do not use LayerMaskClass here, as it is a deobfuscated class. So this will prevent the auto-disabling feature system from working.

	private static readonly LayerMask _layerMask = LayerMaskClass.LowPolyColliderLayerMask
	                                               | LayerMaskClass.HighPolyWithTerrainNoGrassMask
	                                               | LayerMaskClass.HitColliderMask
	                                               | LayerMaskClass.InteractiveMask;
	*/

	private static readonly LayerMask _layerMask = 0b0010_00100_0101_0001_1000_0000_0000;

	public static bool IsTransformVisible(this Camera camera, Transform transform)
	{
		var origin = camera.transform.position;
		var destination = transform.position;

		origin += (destination - origin).normalized * 0.1f; // Offset origin to avoid self-collision

		if (!Physics.Linecast(origin, destination, out var hitinfo, _layerMask))
			return false;

		return hitinfo.transform == transform;
	}

	public static Vector2 WorldPointToVisibleScreenPoint(this Camera camera, Vector3 worldPoint)
	{
		var screenPoint = camera.WorldToScreenPoint(worldPoint);
		var scale = Screen.height / (float)camera.scaledPixelHeight;
		screenPoint.y = Screen.height - screenPoint.y * scale;
		screenPoint.x *= scale;
		if (screenPoint is { z: > 0.01f, x: > -5f, y: > -5f } && screenPoint.x < Screen.width && screenPoint.y < Screen.height)
			return screenPoint;
		return Vector2.zero;
	}
}

```

`Extensions/ELootRarityExtensions.cs`:

```cs
using JsonType;

#nullable enable

namespace EFT.Trainer.Extensions;

public static class ELootRarityExtensions
{
	public static string Color(this ELootRarity rarity)
	{
		return rarity switch
		{
			ELootRarity.Superrare => nameof(ELootRarity.Superrare).Red(),
			ELootRarity.Rare => nameof(ELootRarity.Rare).Yellow(),
			ELootRarity.Common => nameof(ELootRarity.Common).Green(),
			ELootRarity.Not_exist => nameof(ELootRarity.Not_exist),
			_ => string.Empty
		};
	}
}

```

`Extensions/ExfiltrationPointExtensions.cs`:

```cs
using System.Diagnostics.CodeAnalysis;
using EFT.Interactive;

#nullable enable

namespace EFT.Trainer.Extensions;

public static class ExfiltrationPointExtensions
{
	public static bool IsValid([NotNullWhen(true)] this ExfiltrationPoint? point)
	{
		return point != null
			   && point.Settings?.Name != null
			   && point.transform != null;
	}
}

```

`Extensions/HostileType.cs`:

```cs
namespace EFT.Trainer.Extensions;

public enum HostileType
{
	Scav,
	ScavRaider,
	ScavAssault,
	Boss,
	Cultist,
	Bear,
	Usec,
	Marksman,
	RogueUsec
}

```

`Extensions/ItemExtensions.cs`:

```cs
using System.Diagnostics.CodeAnalysis;
using EFT.InventoryLogic;
using EFT.UI.DragAndDrop;

#nullable enable

namespace EFT.Trainer.Extensions;

public static class ItemExtensions
{
	public static bool IsValid([NotNullWhen(true)] this Item? item)
	{
		return item?.Template != null;
	}

	public static bool IsFiltered(this Item item)
	{
		if (string.IsNullOrEmpty(item.TemplateId))
			return true;

		if (ItemViewFactory.IsSecureContainer(item))
			return true;

		if (item.CurrentAddress?.Container?.ParentItem?.TemplateId.ToString() == KnownTemplateIds.BossContainer)
			return true;

		return item.TemplateId.ToString() switch
		{
			KnownTemplateIds.DefaultInventory or KnownTemplateIds.Pockets => true,
			_ => false
			// KnownTemplateIds.Dollars or KnownTemplateIds.Euros or KnownTemplateIds.Roubles => false,
			// Incompatible with extra mods like AllInOne, setting item weight to zero
			//_ => item.Weight <= 0f,// easy way to remove special items like "Pockets" or "Default Inventory"
		};
	}
}

```

`Extensions/ItemTemplateExtensions.cs`:

```cs
using EFT.InventoryLogic;
using JsonType;

#nullable enable

namespace EFT.Trainer.Extensions;

public static class ItemTemplateExtensions
{
	public static ELootRarity GetEstimatedRarity(this ItemTemplate template)
	{
		return template.LootExperience switch
		{
			<= 0 => ELootRarity.Not_exist,
			<= 20 => ELootRarity.Common,
			<= 40 => ELootRarity.Rare,
			> 40 => ELootRarity.Superrare,
		};
	}
}

```

`Extensions/LootItemExtensions.cs`:

```cs
using System.Diagnostics.CodeAnalysis;
using EFT.Interactive;

#nullable enable

namespace EFT.Trainer.Extensions;

public static class LootItemExtensions
{
	public static bool IsValid([NotNullWhen(true)] this LootItem? lootItem)
	{
		return lootItem != null
			   && lootItem.Item.IsValid();
	}
}

```

`Extensions/NotNullWhenAttribute.cs`:

```cs
namespace System.Diagnostics.CodeAnalysis;

[AttributeUsage(AttributeTargets.Parameter)]
public sealed class NotNullWhenAttribute(bool returnValue) : Attribute
{
	public bool ReturnValue { get; } = returnValue;
}

[AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]
internal sealed class NotNullAttribute : Attribute
{
}

```

`Extensions/PlayerExtensions.cs`:

```cs
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using EFT.InventoryLogic;

#nullable enable

namespace EFT.Trainer.Extensions;

public static class PlayerExtensions
{
	public static bool IsValid([NotNullWhen(true)] this Player? player)
	{
		return player != null
			   && player.Transform != null
			   && player.Transform.Original != null
			   && player.PlayerBones != null
			   && player.PlayerBones.transform != null
			   && player.PlayerBody != null
			   && player.PlayerBody.BodySkins != null;
	}

	public static bool IsAlive([NotNullWhen(true)] this Player? player)
	{
		if (!IsValid(player))
			return false;

		return player.HealthController is { IsAlive: true };
	}

	public static bool HasItemComponentInSlot<T>(this Player? player, EquipmentSlot slot) where T : class, IItemComponent
	{
		if (!IsValid(player))
			return false;

		var playerSlotItem = player.Profile?.Inventory?.Equipment?.GetSlot(slot)?.ContainedItem;
		if (playerSlotItem == null)
			return false;

		return playerSlotItem
			.GetAllItems()
			.GetComponents<T>()
			.Any();
	}

	public static HostileType GetHostileType(this Player player)
	{
		var info = player.Profile?.Info;
		if (info == null)
			return HostileType.Scav;

		var settings = info.Settings;
		if (settings != null)
		{
			var role = settings.Role;

			switch (role)
			{
				case WildSpawnType.pmcBot:
					return HostileType.ScavRaider;
				case WildSpawnType.sectantWarrior:
					return HostileType.Cultist;
				case WildSpawnType.assault:
					return HostileType.Scav;
				case WildSpawnType.assaultGroup:
					return HostileType.ScavAssault;
				case WildSpawnType.marksman:
					return HostileType.Marksman;
				case WildSpawnType.exUsec:
					return HostileType.RogueUsec;
				case WildSpawnType.pmcBEAR:
					return HostileType.Bear;
				case WildSpawnType.pmcUSEC:
					return HostileType.Usec;
			}

			if (settings.IsBoss())
				return HostileType.Boss;
		}

		return info.Side switch
		{
			EPlayerSide.Bear => HostileType.Bear,
			EPlayerSide.Usec => HostileType.Usec,
			_ => HostileType.Scav
		};
	}

}

```

`Extensions/StringExtensions.cs`:

```cs
using UnityEngine;

#nullable enable

namespace EFT.Trainer.Extensions;

public static class StringExtensions
{
	public static string Color(this string str, Color color)
	{
		return $"<color=#{ColorUtility.ToHtmlStringRGB(color)}>{str}</color>";
	}

	public static string Blue(this string str)
	{
		return str.Color(UnityEngine.Color.blue);
	}

	public static string Yellow(this string str)
	{
		return str.Color(UnityEngine.Color.yellow);
	}

	public static string Red(this string str)
	{
		return str.Color(UnityEngine.Color.red);
	}

	public static string Green(this string str)
	{
		return str.Color(UnityEngine.Color.green);
	}

	public static string Cyan(this string str)
	{
		return str.Color(UnityEngine.Color.cyan);
	}
}

```

`Extensions/ThrowableExtensions.cs`:

```cs
using System.Diagnostics.CodeAnalysis;

#nullable enable

namespace EFT.Trainer.Extensions;

public static class ThrowableExtensions
{
	public static bool IsValid([NotNullWhen(true)] this Throwable? throwable)
	{
		return throwable != null
			   && throwable.transform != null;
	}
}

```

`Extensions/WorldInteractiveObjectExtensions.cs`:

```cs
using System.Diagnostics.CodeAnalysis;
using EFT.Interactive;

#nullable enable

namespace EFT.Trainer.Extensions;

public static class WorldInteractiveObjectExtensions
{
	public static bool IsValid([NotNullWhen(true)] this WorldInteractiveObject? obj)
	{
		return obj != null;
	}
}

```

`Features/Aimbot.cs`:

```cs
using System.Diagnostics.CodeAnalysis;
using Comfort.Common;
using EFT.Ballistics;
using EFT.InventoryLogic;
using EFT.Trainer.Configuration;
using EFT.Trainer.Extensions;
using EFT.Trainer.Properties;
using EFT.Trainer.UI;
using JetBrains.Annotations;
using UnityEngine;

#nullable enable

namespace EFT.Trainer.Features;

[UsedImplicitly]
internal class Aimbot : HoldFeature
{
	public override string Name => Strings.FeatureAimbotName;
	public override string Description => Strings.FeatureAimbotDescription;

	public override KeyCode Key { get; set; } = KeyCode.Slash;

	[ConfigurationProperty(Order = 10)]
	public float MaximumDistance { get; set; } = 200f;

	[ConfigurationProperty(Order = 11)]
	public float Smoothness { get; set; } = 0.085f;

	[ConfigurationProperty(Order = 15)]
	public bool ElevationAdjustment { get; set; } = true;

	[ConfigurationProperty(Order = 20)]
	public float FovRadius { get; set; } = 0f;

	[ConfigurationProperty(Order = 21)]
	public bool ShowFovCircle { get; set; } = false;

	[ConfigurationProperty(Order = 22)]
	public Color FovCircleColor { get; set; } = Color.white;

	[ConfigurationProperty(Order = 23)]
	public float FovCircleThickness { get; set; } = 1f;

	[ConfigurationProperty(Order = 30)]
	public bool SilentAim { get; set; } = false;

	[ConfigurationProperty(Order = 31)]
	public float SilentAimNextShotDelay { get; set; } = 0.25f;

	[ConfigurationProperty(Order = 32)]
	public float SilentAimSpeedFactor { get; set; } = 100f;

#pragma warning disable IDE0060
	[UsedImplicitly]
	protected static bool CreateShotPrefix(object ammo, Vector3 origin, ref Vector3 direction, int fireIndex, string player, Item weapon, ref float speedFactor, int fragmentIndex)
	{
		var feature = FeatureFactory.GetFeature<Aimbot>();
		if (feature == null || !feature.SilentAim || feature._silentAimTarget == null)
			return true; // keep using original code, we are not enabled

		var world = Singleton<GameWorld>.Instance;
		if (world == null)
			return true;

		var localPlayer = world.GetEverExistedBridgeByProfileID(player)?.iPlayer;
		if (localPlayer == null)
			return true;

		if (!localPlayer.IsYourPlayer)
			return true; // keep using original code, not our player

		direction = (feature._silentAimTarget.position - origin).normalized;
		speedFactor = feature.SilentAimSpeedFactor;

		return true; // call the original code with updated direction and speedFactor
	}

	[UsedImplicitly]
	[SuppressMessage("ReSharper", "InconsistentNaming")]
	protected static bool ApplyShotPrefix(DamageInfoStruct damageInfo, EBodyPart bodyPartType, EBodyPartColliderType colliderType, EArmorPlateCollider armorPlateCollider, object shotId, Player? __instance)
	{
		var feature = FeatureFactory.GetFeature<Aimbot>();
		if (feature == null || !feature.SilentAim || feature._silentAimTarget == null)
			return true; // keep using original code, we are not enabled

		if (damageInfo.Player?.iPlayer is { IsYourPlayer: true } && __instance is { IsYourPlayer: true })
			return false; // prevent self damage !

		return true; // call the original code
	}

	[UsedImplicitly]
	[SuppressMessage("ReSharper", "InconsistentNaming")]
	protected static bool CreateOpticCalibrationDataPrefix(Weapon? __instance, ref AmmoTemplate ammoTemplate)
	{
		var feature = FeatureFactory.GetFeature<Aimbot>();
		if (feature == null || !feature.ElevationAdjustment)
			return true; // keep using original code, we are not enabled

		// Taken from SPT-BetterZeroing, credits to ehaugw
		// Use the loaded ammo for elevation adjustment calculations rather than a weapon's default ammo
		if (__instance?.GetCurrentMagazine() is { } mag && mag.FirstRealAmmo() is AmmoItemClass { AmmoTemplate: { } magazineTemplate })
		{
			ammoTemplate = magazineTemplate;
		}
		else if (__instance?.Chambers is { Length: > 0 } slots && slots[0]?.ContainedItem is AmmoItemClass { AmmoTemplate: { } chamberedTemplate })
		{
			ammoTemplate = chamberedTemplate;
		}

		return true; // call the original code with updated template
	}

#pragma warning restore IDE0060

	private Transform? _silentAimTarget = null;
	private float _silentAimNextShotTime = 0f;
	protected override void Update()
	{
		base.Update();

		if (!SilentAim)
			return;

		HarmonyPatchOnce(harmony =>
		{
			HarmonyPrefix(harmony, typeof(BallisticsCalculator), nameof(BallisticsCalculator.CreateShot), nameof(CreateShotPrefix));
			HarmonyPrefix(harmony, typeof(Player), nameof(Player.ApplyShot), nameof(ApplyShotPrefix));
			HarmonyPrefix(harmony, typeof(Weapon), nameof(Weapon.CreateOpticCalibrationData), nameof(CreateOpticCalibrationDataPrefix));
		});

		_silentAimTarget = null;

		if (!TryGetNearestTarget(out var player, out var camera, out var nearestTarget))
			return;

		if (player.IsInventoryOpened)
			return;

		if (player.HandsController is not Player.FirearmController controller)
			return;

		if (!camera.IsTransformVisible(nearestTarget))
			return;

		_silentAimTarget = nearestTarget;

		if (_silentAimNextShotTime > Time.time)
			return;

		controller.SetTriggerPressed(true);
		_silentAimNextShotTime = Time.time + SilentAimNextShotDelay;
		controller.SetTriggerPressed(false);
	}

	protected override void UpdateWhenHold()
	{
		if (!TryGetNearestTarget(out var player, out _, out var nearestTarget))
			return;

		AimAtPosition(player, nearestTarget.position, Smoothness);
	}

	private bool TryGetNearestTarget([NotNullWhen(true)] out Player? localPlayer, [NotNullWhen(true)] out Camera? camera, [NotNullWhen(true)] out Transform? nearestTarget)
	{
		localPlayer = null;
		camera = null;
		nearestTarget = null;
		var nearestTargetDistance = float.MaxValue;

		var state = GameState.Current;
		if (state == null)
			return false;

		camera = state.Camera;
		if (camera == null)
			return false;

		localPlayer = state.LocalPlayer;
		if (localPlayer == null)
			return false;

		if (localPlayer.HandsController == null || localPlayer.HandsController.Item is not Weapon weapon)
			return false;

		var template = weapon.CurrentAmmoTemplate;
		if (template == null)
			return false;

		foreach (var hostile in state.Hostiles)
		{
			if (hostile == null)
				continue;

			if (!hostile.IsAlive())
				continue;

			if (!TryGetHeadTransform(hostile, out var hostileTransform))
				continue;

			var destination = hostileTransform.position;
			var screenPosition = camera.WorldPointToVisibleScreenPoint(destination);
			if (screenPosition == Vector2.zero)
				continue;

			if (!IsInFieldOfView(screenPosition))
				continue;

			var distance = Vector3.Distance(camera.transform.position, destination);
			if (distance > MaximumDistance)
				continue;

			if (distance >= nearestTargetDistance)
				continue;

			nearestTargetDistance = distance;
			var travelTime = distance / template.InitialSpeed;
			destination.x += hostile.Velocity.x * travelTime;
			destination.y += hostile.Velocity.y * travelTime;

			nearestTarget = hostileTransform;
		}

		return nearestTarget != null;
	}

	[UsedImplicitly]
	protected void OnGUI()
	{
		if (!ShowFovCircle || FovRadius <= 0)
			return;

		var player = GameState.Current?.LocalPlayer;
		if (!player.IsValid())
			return;

		if (player.HandsController == null || player.HandsController.Item is not Weapon)
			return;

		Render.DrawCircle(Render.ScreenCenter, FovRadius, FovCircleColor, FovCircleThickness, 48);
	}

	private bool IsInFieldOfView(Vector2 screenPosition)
	{
		if (FovRadius <= 0f)
			return true;

		var distance = Vector2.Distance(Render.ScreenCenter, screenPosition);
		return distance <= FovRadius;
	}

	private static void AimAtPosition(Player player, Vector3 targetPosition, float smoothness)
	{
		var firingAngle = player.Fireport.position - player.Fireport.up * 1f;
		var normalized = (targetPosition - firingAngle).normalized;
		var quaternion = Quaternion.LookRotation(normalized);
		var euler = quaternion.eulerAngles;

		//This is necessary due to crossing Y plane with target
		if (euler.x > 180f)
			euler.x -= 360f;

		var playerRotation = player.MovementContext.Rotation;
		var smoothAngle = GetSmoothAngle(playerRotation, new Vector2(euler.y, euler.x), smoothness);
		player.MovementContext.Rotation = smoothAngle;
	}

	private static Vector2 GetSmoothAngle(Vector2 fromAngle, Vector2 toAngle, float smoothness)
	{
		var delta = fromAngle - toAngle;
		NormalizeAngle(ref delta);
		var smoothedDelta = Vector2.Scale(delta, new Vector2(smoothness, smoothness));
		toAngle = fromAngle - smoothedDelta;
		return toAngle;
	}

	private static void NormalizeAngle(ref Vector2 angle)
	{
		var newX = angle.x switch
		{
			<= -180f => angle.x + 360f,
			> 180f => angle.x - 360f,
			_ => angle.x
		};

		var newY = angle.y switch
		{
			> 90f => angle.y - 180f,
			<= -90f => angle.y + 180f,
			_ => angle.y
		};

		angle = new Vector2(newX, newY);
	}

	private static bool TryGetHeadTransform(Player player, [NotNullWhen(true)] out Transform? transform)
	{
		transform = null;

		var bones = player.PlayerBones;
		if (bones == null)
			return false;

		transform = bones.Head.Original;
		return true;
	}
}

```

`Features/AirDrop.cs`:

```cs
using System.Linq;
using EFT.InventoryLogic;
using EFT.Trainer.Properties;
using JetBrains.Annotations;
using UnityEngine;

#nullable enable

namespace EFT.Trainer.Features;

[UsedImplicitly]
internal class AirDrop : TriggerFeature
{
	public override string Name => Strings.FeatureAirDropName;
	public override string Description => Strings.FeatureAirDropDescription;

	public override KeyCode Key { get; set; } = KeyCode.None;

	protected override void UpdateOnceWhenTriggered()
	{
		var player = GameState.Current?.LocalPlayer;
		if (player == null)
			return;

		if (TemplateHelper.FindTemplates(KnownTemplateIds.RedSignalFlare).FirstOrDefault() is not AmmoTemplate template)
			return;

		player.HandleFlareSuccessEvent(player.Transform.position, template);
	}
}

```

`Features/Ammunition.cs`:

```cs
using System;
using Comfort.Common;
using EFT.Ballistics;
using EFT.InventoryLogic;
using EFT.Trainer.Properties;
using JetBrains.Annotations;

#nullable enable

namespace EFT.Trainer.Features;

[UsedImplicitly]
internal class Ammunition : ToggleFeature
{
	public override string Name => Strings.FeatureAmmunitionName;
	public override string Description => Strings.FeatureAmmunitionDescription;

	public override bool Enabled { get; set; } = false;

	[UsedImplicitly]
	private static void ShootPostfix(EftBulletClass shot)
	{
		var feature = FeatureFactory.GetFeature<Ammunition>();
		if (feature == null || !feature.Enabled)
			return;

		if (shot.Weapon is not Weapon weapon)
			return;

		var ammo = shot.Ammo;
		if (ammo == null)
			return;

		var player = shot.Player.iPlayer;
		if (player is not { IsYourPlayer: true })
			return;

		var magazine = weapon.GetCurrentMagazine();
		if (magazine != null)
		{
			if (magazine is CylinderMagazineItemClass cylinderMagazine)
			{
				// Rhino case
				foreach (var slot in cylinderMagazine.Camoras)
					slot.Add(CreateAmmo(ammo), false, true);
			}
			else
			{
				var cartridges = magazine.Cartridges;
				cartridges?.Add(CreateAmmo(ammo), false);
			}
		}
		else
		{
			// no magazine, like mp18, fill all weapon chambers
			foreach (var slot in weapon.Chambers)
				slot.Add(CreateAmmo(ammo), false, true);
		}
	}

	private static Item CreateAmmo(Item ammo)
	{
		var instantiated = Singleton<ItemFactoryClass>.Instantiated;
		if (!instantiated)
			return ammo;

		var instance = Singleton<ItemFactoryClass>.Instance;
		var itemId = Guid.NewGuid().ToString("N").Substring(0, 24);
		return instance.CreateItem(itemId, ammo.TemplateId, null) ?? ammo;
	}

	protected override void UpdateWhenEnabled()
	{
		HarmonyPatchOnce(harmony =>
		{
			HarmonyPostfix(harmony, typeof(BallisticsCalculator), nameof(BallisticsCalculator.Shoot), nameof(ShootPostfix), [typeof(EftBulletClass)]);
		});
	}
}

```

`Features/AutomaticGun.cs`:

```cs
using EFT.InventoryLogic;
using EFT.Trainer.Configuration;
using EFT.Trainer.Extensions;
using EFT.Trainer.Properties;
using JetBrains.Annotations;

#nullable enable

namespace EFT.Trainer.Features;

[UsedImplicitly]
internal class AutomaticGun : ToggleFeature
{
	public override string Name => Strings.FeatureAutomaticGunName;
	public override string Description => Strings.FeatureAutomaticGunDescription;

	public override bool Enabled { get; set; } = false;

	[ConfigurationProperty]
	public int Rate { get; set; } = 500;

	protected override void UpdateWhenEnabled()
	{
		var player = GameState.Current?.LocalPlayer;
		if (!player.IsValid())
			return;

		if (player.HandsController.Item is not Weapon weapon)
			return;

		var fireModeComponent = weapon.GetItemComponent<FireModeComponent>();
		if (fireModeComponent == null)
			return;

		fireModeComponent.FireMode = Weapon.EFireMode.fullauto;

		if (player.HandsController is not Player.FirearmController controller)
			return;

		var template = controller.Item?.Template;
		if (template == null)
			return;

		template.BoltAction = false;
		template.bFirerate = Rate;
	}
}

```

`Features/BaseMapToggleFeature.cs`:

```cs
using System.Collections.Generic;
using EFT.Trainer.Configuration;
using EFT.Trainer.Extensions;
using EFT.Trainer.UI;
using UnityEngine;

#nullable enable

namespace EFT.Trainer.Features;

internal abstract class BaseMapToggleFeature : ToggleFeature
{
	[ConfigurationProperty(Order = 40)]
	public bool ShowPlayers { get; set; } = true;

	[ConfigurationProperty(Order = 40)]
	public bool ShowScavs { get; set; } = true;

	[ConfigurationProperty(Order = 40)]
	public bool ShowScavRaiders { get; set; } = true;

	[ConfigurationProperty(Order = 40)]
	public bool ShowScavAssaults { get; set; } = true;

	[ConfigurationProperty(Order = 40)]
	public bool ShowBosses { get; set; } = true;

	[ConfigurationProperty(Order = 40)]
	public bool ShowCultists { get; set; } = true;

	[ConfigurationProperty(Order = 40)]
	public bool ShowRogues { get; set; } = true;

	[ConfigurationProperty(Order = 40)]
	public bool ShowMarksmen { get; set; } = true;

	[ConfigurationProperty(Order = 90)]
	public bool ChangeTime { get; set; } = false;

	private GameObject? _mapCameraObject = null;
	private Camera? _mapCamera = null;

	protected Camera? MapCamera => _mapCamera;

	private static readonly string[] _directions = [
		Properties.Strings.DirectionNorth,
		Properties.Strings.DirectionNorthEast,
		Properties.Strings.DirectionEast,
		Properties.Strings.DirectionSouthEast,
		Properties.Strings.DirectionSouth,
		Properties.Strings.DirectionSouthWest,
		Properties.Strings.DirectionWest,
		Properties.Strings.DirectionNorthWest,
		Properties.Strings.DirectionNorth
	];

	protected void ToggleMapCameraIfNeeded(bool state)
	{
		if (_mapCamera == null)
			return;

		if (_mapCamera.enabled == state)
			return;

		_mapCamera.enabled = state;
	}

	protected void SetupMapCamera(Camera camera, float x, float y, float sizex, float sizey)
	{
		if (_mapCamera != null)
		{
			_mapCamera.pixelRect = new Rect(x, y, sizex, sizey);
			ToggleMapCameraIfNeeded(true);
			return;
		}

		// We need to setup weather for proper rendering
		Weather.ToClearWeather(ChangeTime);

		_mapCameraObject = new GameObject(GetType().FullName + nameof(_mapCameraObject), typeof(Camera), typeof(PrismEffects));
		_mapCameraObject.GetComponent<PrismEffects>().SetPrismPreset(camera.GetComponent<PrismEffects>().currentPrismPreset);
		_mapCamera = _mapCameraObject.GetComponent<Camera>();
		_mapCamera.name = GetType().FullName + nameof(_mapCamera);
		_mapCamera.pixelRect = new Rect(x, y, sizex, sizey);
		_mapCamera.allowHDR = false;
		_mapCamera.depth = -1;

		// Prevent NullReferenceException in PrismEffects 
		GameWorld.OnDispose -= UpdateWhenDisabled;
		GameWorld.OnDispose += UpdateWhenDisabled;
	}

	protected void UpdateMapCamera(Camera camera, float range)
	{
		if (_mapCameraObject == null)
			return;

		var cameraTransform = camera.transform;

		var mapTransform = _mapCameraObject.transform;
		mapTransform.eulerAngles = new Vector3(90, cameraTransform.eulerAngles.y, cameraTransform.eulerAngles.z);
		mapTransform.localPosition = new Vector3(cameraTransform.localPosition.x, range * Mathf.Tan(45), cameraTransform.localPosition.z);
	}

	protected void DrawHostiles(Camera camera, IEnumerable<Player> hostiles, float range)
	{
		var cameraPosition = camera.transform.position;


		var feature = FeatureFactory.GetFeature<Players>();
		if (feature == null)
			return;

		foreach (var enemy in hostiles)
		{
			if (!enemy.IsValid())
				continue;

			var position = enemy.Transform.position;

			if (MapCamera != null && MapCamera.enabled)
				cameraPosition.y = position.y;

			var distance = Vector3.Distance(cameraPosition, position);
			if (range > 0 && distance > range)
				continue;

			var hostileType = enemy.GetHostileType();

			switch (hostileType)
			{
				case HostileType.Scav when !ShowScavs:
				case HostileType.ScavRaider when !ShowScavRaiders:
				case HostileType.Cultist when !ShowCultists:
				case HostileType.Boss when !ShowBosses:
				case HostileType.ScavAssault when !ShowScavAssaults:
				case HostileType.Marksman when !ShowMarksmen:
				case HostileType.RogueUsec when !ShowRogues:
				case HostileType.Bear or HostileType.Usec when !ShowPlayers:
					continue;

				default:
					{
						var playerColor = feature.GetPlayerColors(hostileType);
						DrawEnemy(camera, enemy, playerColor.Color);
						break;
					}
			}
		}
	}

	protected abstract Vector2 GetTargetPosition(Vector3 playerPosition, Vector3 targetPosition, float playerEulerY);
	protected abstract void AdjustTargetPositionForRender(ref Vector2 position);

	protected void DrawEnemy(Camera camera, Player enemy, Color playerColor)
	{
		var cameraTransform = camera.transform;
		var cameraPosition = cameraTransform.position;

		var enemyPosition = enemy.Transform.position;
		var cameraEulerY = cameraTransform.eulerAngles.y;

		var enemyMap = GetTargetPosition(cameraPosition, enemyPosition, cameraEulerY);
		var enemyLookDirection = enemy.LookDirection;

		var enemyOffset = enemyPosition + enemyLookDirection * 8f;
		var playerRealRight = enemy.MovementContext.PlayerRealRight;

		var enemyOffset2 = enemyPosition + enemyLookDirection * 4f + playerRealRight * 2f;
		var enemyOffset3 = enemyPosition + enemyLookDirection * 4f - playerRealRight * 2f;

		var enemyForward = GetTargetPosition(cameraPosition, enemyOffset, cameraEulerY);
		var enemyArrow = GetTargetPosition(cameraPosition, enemyOffset2, cameraEulerY);
		var enemyArrow2 = GetTargetPosition(cameraPosition, enemyOffset3, cameraEulerY);

		AdjustTargetPositionForRender(ref enemyMap);
		AdjustTargetPositionForRender(ref enemyForward);
		AdjustTargetPositionForRender(ref enemyArrow);
		AdjustTargetPositionForRender(ref enemyArrow2);

		Render.DrawLine(enemyMap, enemyForward, 2f, Color.white);
		Render.DrawLine(enemyArrow, enemyForward, 2f, Color.white);
		Render.DrawLine(enemyArrow2, enemyForward, 2f, Color.white);
		Render.DrawCircle(enemyMap, 10f, playerColor, 2f, 8);
	}

	protected static string GetHeadingAngle(Vector3 direction)
	{
		var heading = Quaternion.LookRotation(direction).eulerAngles.y;
		return _directions[(int)Mathf.Round(heading % 360 / 45)];
	}
}

```

`Features/Bones.cs`:

```cs
using System.Collections.Generic;
using EFT.Trainer.Extensions;
using EFT.Trainer.UI;
using UnityEngine;

namespace EFT.Trainer.Features;

internal static class Bones
{
	public const string Pelvis = "Root_Joint/Base HumanPelvis";
	public const string Spine1 = Pelvis + "/Base HumanSpine1";
	public const string Spine2 = Spine1 + "/Base HumanSpine2";
	public const string Spine3 = Spine2 + "/Base HumanSpine3";
	public const string Neck = Spine3 + "/Base HumanNeck";
	public const string Head = Neck + "/Base HumanHead";

	public const string LThigh1 = Pelvis + "/Base HumanLThigh1";
	public const string LThigh2 = LThigh1 + "/Base HumanLThigh2";
	public const string LCalf = LThigh2 + "/Base HumanLCalf";
	public const string LFoot = LCalf + "/Base HumanLFoot";
	public const string LToe = LFoot + "/Base HumanLToe";
	public const string LCollarbone = Spine3 + "/Base HumanRibcage/Base HumanLCollarbone";
	public const string LForearm1 = LCollarbone + "/Base HumanLUpperarm/Base HumanLForearm1";
	public const string LForearm2 = LForearm1 + "/Base HumanLForearm2";
	public const string LForearm3 = LForearm2 + "/Base HumanLForearm3";
	public const string LPalm = LForearm3 + "/Base HumanLPalm";
	public const string LDigit11 = LPalm + "/Base HumanLDigit11";
	public const string LDigit12 = LDigit11 + "/Base HumanLDigit12";
	public const string LDigit13 = LDigit12 + "/Base HumanLDigit13";
	public const string LDigit21 = LPalm + "/Base HumanLDigit21";
	public const string LDigit22 = LDigit21 + "/Base HumanLDigit22";
	public const string LDigit23 = LDigit22 + "/Base HumanLDigit23";
	public const string LDigit31 = LPalm + "/Base HumanLDigit31";
	public const string LDigit32 = LDigit31 + "/Base HumanLDigit32";
	public const string LDigit33 = LDigit32 + "/Base HumanLDigit33";
	public const string LDigit41 = LPalm + "/Base HumanLDigit41";
	public const string LDigit42 = LDigit41 + "/Base HumanLDigit42";
	public const string LDigit43 = LDigit42 + "/Base HumanLDigit43";
	public const string LDigit51 = LPalm + "/Base HumanLDigit51";
	public const string LDigit52 = LDigit51 + "/Base HumanLDigit52";
	public const string LDigit53 = LDigit52 + "/Base HumanLDigit53";

	public const string RThigh1 = Pelvis + "/Base HumanRThigh1";
	public const string RThigh2 = RThigh1 + "/Base HumanRThigh2";
	public const string RCalf = RThigh2 + "/Base HumanRCalf";
	public const string RFoot = RCalf + "/Base HumanRFoot";
	public const string RToe = RFoot + "/Base HumanRToe";
	public const string RCollarbone = Spine3 + "/Base HumanRibcage/Base HumanRCollarbone";
	public const string RForearm1 = RCollarbone + "/Base HumanRUpperarm/Base HumanRForearm1";
	public const string RForearm2 = RForearm1 + "/Base HumanRForearm2";
	public const string RForearm3 = RForearm2 + "/Base HumanRForearm3";
	public const string RPalm = RForearm3 + "/Base HumanRPalm";
	public const string RDigit11 = RPalm + "/Base HumanRDigit11";
	public const string RDigit12 = RDigit11 + "/Base HumanRDigit12";
	public const string RDigit13 = RDigit12 + "/Base HumanRDigit13";
	public const string RDigit21 = RPalm + "/Base HumanRDigit21";
	public const string RDigit22 = RDigit21 + "/Base HumanRDigit22";
	public const string RDigit23 = RDigit22 + "/Base HumanRDigit23";
	public const string RDigit31 = RPalm + "/Base HumanRDigit31";
	public const string RDigit32 = RDigit31 + "/Base HumanRDigit32";
	public const string RDigit33 = RDigit32 + "/Base HumanRDigit33";
	public const string RDigit41 = RPalm + "/Base HumanRDigit41";
	public const string RDigit42 = RDigit41 + "/Base HumanRDigit42";
	public const string RDigit43 = RDigit42 + "/Base HumanRDigit43";
	public const string RDigit51 = RPalm + "/Base HumanRDigit51";
	public const string RDigit52 = RDigit51 + "/Base HumanRDigit52";
	public const string RDigit53 = RDigit52 + "/Base HumanRDigit53";

	public static readonly List<string[]> Connections =
	[
		[Pelvis, LThigh1],
		[LThigh1, LThigh2],
		[LThigh2, LCalf],
		[LCalf, LFoot],
		[LFoot, LToe],
		[Pelvis, RThigh1],
		[RThigh1, RThigh2],
		[RThigh2, RCalf],
		[RCalf, RFoot],
		[RFoot, RToe],
		[Pelvis, Spine1],
		[Spine1, Spine2],
		[Spine2, Spine3],
		[Spine3, Neck],
		[Neck, Head],
		[Spine3, LCollarbone],
		[LCollarbone, LForearm1],
		[LForearm1, LForearm2],
		[LForearm2, LForearm3],
		[LForearm3, LPalm],
		[Spine3, RCollarbone],
		[RCollarbone, RForearm1],
		[RForearm1, RForearm2],
		[RForearm2, RForearm3],
		[RForearm3, RPalm]
	];

	public static readonly List<string[]> FingerConnections =
	[
		[LPalm, LDigit11],
		[LDigit11, LDigit12],
		[LDigit12, LDigit13],
		[LPalm, LDigit21],
		[LDigit21, LDigit22],
		[LDigit22, LDigit23],
		[LPalm, LDigit31],
		[LDigit31, LDigit32],
		[LDigit32, LDigit33],
		[LPalm, LDigit41],
		[LDigit41, LDigit42],
		[LDigit42, LDigit43],
		[LPalm, LDigit51],
		[LDigit51, LDigit52],
		[LDigit52, LDigit53],
		[RPalm, RDigit11],
		[RDigit11, RDigit12],
		[RDigit12, RDigit13],
		[RPalm, RDigit11],
		[RDigit21, RDigit22],
		[RDigit22, RDigit23],
		[RPalm, RDigit11],
		[RDigit31, RDigit32],
		[RDigit32, RDigit33],
		[RPalm, RDigit11],
		[RDigit41, RDigit42],
		[RDigit42, RDigit43],
		[RPalm, RDigit11],
		[RDigit51, RDigit52],
		[RDigit52, RDigit53]
	];

	private static Vector2 GetScreenPosition(Camera camera, Vector3 position, bool isAiming)
	{
		return isAiming ? Players.ScopePointToScreenPoint(camera, position, true) : camera.WorldPointToScreenPoint(position);
	}

	public static void RenderBone(Dictionary<string, Transform> bones, string from, string to, float thickness, Color color, Camera camera, bool isAiming)
	{
		RenderBone(bones[from].position, bones[to].position, thickness, color, camera, isAiming);
	}

	public static void RenderBone(Vector3 fromPosition, Vector3 toPosition, float thickness, Color color, Camera camera, bool isAiming)
	{
		var fromScreenPosition = GetScreenPosition(camera, fromPosition, isAiming);
		var toScreenPosition = GetScreenPosition(camera, toPosition, isAiming);

		Render.DrawLine(fromScreenPosition, toScreenPosition, thickness, color);
	}

	public static void RenderBones(Player player, float thickness, Color color, Camera camera, bool isAiming, float distance)
	{
		var skeleton = player.PlayerBody.SkeletonRootJoint;
		if (skeleton == null)
			return;

		var bones = skeleton.Bones;
		if (bones == null)
			return;

		foreach (var connection in Connections)
			RenderBone(bones, connection[0], connection[1], thickness, color, camera, isAiming);

		if (distance < 75f)
			foreach (var finger in FingerConnections)
				RenderBone(bones, finger[0], finger[1], thickness, color, camera, isAiming);


		var head = GetScreenPosition(camera, bones[Head].position, isAiming);
		var neck = GetScreenPosition(camera, bones[Neck].position, isAiming);

		var radius = Vector2.Distance(head, neck);

		Render.DrawCircle(head, radius, color, thickness, 8);
	}

	public static void RenderBones(Player player, string[] connections, float thickness, Color color, Camera camera, bool isAiming)
	{
		var skeleton = player.PlayerBody.SkeletonRootJoint;
		if (skeleton == null)
			return;

		var bones = skeleton.Bones;
		if (bones == null)
			return;

		var numberOfConnections = connections.Length;
		for (int i = 0; i < numberOfConnections; i += 2)
		{
			RenderBone(bones, connections[i], connections[i + 1], thickness, color, camera, isAiming);
		}
	}

	public static void RenderHead(Player player, float thickness, Color color, Camera camera, bool isAiming)
	{
		var skeleton = player.PlayerBody.SkeletonRootJoint;
		if (skeleton == null)
			return;

		var bones = skeleton.Bones;
		if (bones == null)
			return;

		var head = GetScreenPosition(camera, bones[Head].position, isAiming);
		var neck = GetScreenPosition(camera, bones[Neck].position, isAiming);

		var radius = Vector2.Distance(head, neck);

		Render.DrawCircle(head, radius, color, thickness, 8);
	}

	public static void RenderFingers(Player player, float thickness, Color color, Camera camera, bool isAiming)
	{
		var skeleton = player.PlayerBody.SkeletonRootJoint;
		if (skeleton == null)
			return;

		var bones = skeleton.Bones;
		if (bones == null)
			return;

		foreach (var connection in FingerConnections)
			RenderBone(bones, connection[0], connection[1], thickness, color, camera, isAiming);
	}
}

```

`Features/CachableFeature.cs`:

```cs
using System.Collections;
using System.Collections.Generic;
using EFT.Trainer.Configuration;
using JetBrains.Annotations;
using UnityEngine;

#nullable enable

namespace EFT.Trainer.Features;

internal abstract class CachableFeature<T> : ToggleFeature
{
	[ConfigurationProperty(Order = 3)]
	public abstract float CacheTimeInSec { get; set; }

	private readonly List<T> _data = [];
	private bool _refreshing = false;

#if DEBUG_PERFORMANCE
		private readonly System.Diagnostics.Stopwatch _stopwatch = new();
#endif

	[UsedImplicitly]
	private void Start()
	{
		StartCoroutine(RefreshDataScheduler());
	}

	private IEnumerator RefreshDataScheduler()
	{
		if (Enabled)
		{
			try
			{
				_refreshing = true;

#if DEBUG_PERFORMANCE
				_stopwatch.Restart();
#endif

				BeforeRefreshData(_data);
				_data.Clear(); // but we'll keep previous capacity
				RefreshData(_data);
			}
			finally
			{
				_refreshing = false;

#if DEBUG_PERFORMANCE
				_stopwatch.Stop();
#endif

			}

#if DEBUG_PERFORMANCE
			AddConsoleLog(string.Format(EFT.Trainer.Properties.Strings.DebugPerformanceRefreshedFormat, GetType().Name, _stopwatch.ElapsedMilliseconds));
#endif
		}

		yield return new WaitForSeconds(CacheTimeInSec);
		StartCoroutine(RefreshDataScheduler());
	}

	protected override void UpdateWhenEnabled()
	{
		if (_refreshing)
			return;

		if (_data.Count > 0)
			ProcessData(_data);
	}

	protected override void OnGUIWhenEnabled()
	{
		if (_refreshing)
			return;

		if (_data.Count > 0)
			ProcessDataOnGUI(_data);
	}

	protected virtual void BeforeRefreshData(IReadOnlyList<T> data) { }
	public abstract void RefreshData(List<T> data);
	public virtual void ProcessData(IReadOnlyList<T> data) { }
	public virtual void ProcessDataOnGUI(IReadOnlyList<T> data) { }
}

```

`Features/Commands.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using EFT.Trainer.Configuration;
using EFT.Trainer.ConsoleCommands;
using EFT.Trainer.Properties;
using EFT.UI;
using UnityEngine;

#nullable enable

namespace EFT.Trainer.Features;

internal class Commands : FeatureRenderer
{
	public override string Name => Strings.FeatureCommandsName;
	public override string Description => Strings.FeatureCommandsDescription;

	[ConfigurationProperty(Skip = true)] // we do not want to offer save/load support for this
	public override bool Enabled { get; set; } = false;

	[ConfigurationProperty]
	public override float X { get; set; } = DefaultX;

	[ConfigurationProperty]
	public override float Y { get; set; } = DefaultY;

	public override KeyCode Key { get; set; } = KeyCode.RightAlt;

	private bool Registered { get; set; } = false;
	private Dictionary<string, string> PropertyDisplays { get; } = [];

	protected override void Update()
	{
		if (Registered)
		{
			base.Update();
			return;
		}

		if (!PreloaderUI.Instantiated)
			return;

#if DEBUG
		ConsoleScreen.IAmDevShowMeLogs = true;
#endif

		RegisterPropertyDisplays();
		RegisterCommands();
	}

	private void RegisterPropertyDisplays()
	{
		const string prefix = nameof(OrderedProperty.Property);

		var properties = typeof(Strings)
				.GetProperties(BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.Public)
				.Where(p => p.Name.StartsWith(prefix));

		PropertyDisplays.Clear();

		foreach (var property in properties)
		{
			var key = property.Name.Substring(prefix.Length);
			var value = property.GetValue(null) as string ?? string.Empty;

			PropertyDisplays.Add(key, value);
		}
	}

	protected override string GetPropertyDisplay(string propertyName)
	{
		if (PropertyDisplays.TryGetValue(propertyName, out var value))
			return value;

		return $"!! [{propertyName}] !!"; // missing translation in Strings.resx
	}

	private void RegisterCommands()
	{
		foreach (var feature in Context.ToggleableFeatures.Value)
		{
			if (feature is Commands or GameState)
				continue;

			new ToggleFeatureCommand(feature)
				.Register();
		}

		// Dynamically register commands
		foreach (var command in GetCommands())
			command.Register();

		// built-in commands
		new BuiltInCommand(Strings.CommandLoadName, () => LoadSettings())
			.Register();

		new BuiltInCommand(Strings.CommandSaveName, SaveSettings)
			.Register();

		// Load default configuration
		LoadSettings(false);
		SetupWindowCoordinates();

		Registered = true;
	}

	private IEnumerable<ConsoleCommand> GetCommands()
	{
		var types = GetType()
			.Assembly
			.GetTypes()
			.Where(t => t.IsSubclassOf(typeof(ConsoleCommand)) && !t.IsAbstract && t.GetConstructor(Type.EmptyTypes) != null);

		foreach (var type in types)
			yield return (ConsoleCommand)Activator.CreateInstance(type);
	}
}

```

`Features/CrossHair.cs`:

```cs
using EFT.Trainer.Configuration;
using EFT.Trainer.Extensions;
using EFT.Trainer.Properties;
using EFT.Trainer.UI;
using JetBrains.Annotations;
using UnityEngine;

#nullable enable

namespace EFT.Trainer.Features;

[UsedImplicitly]
internal class CrossHair : ToggleFeature
{
	public override string Name => Strings.FeatureCrosshairName;
	public override string Description => Strings.FeatureCrosshairDescription;

	public override bool Enabled { get; set; } = false;

	[ConfigurationProperty]
	public Color Color { get; set; } = Color.red;

	[ConfigurationProperty]
	public bool HideWhenAiming { get; set; } = true;

	[ConfigurationProperty]
	public float Size { get; set; } = 10f;

	[ConfigurationProperty]
	public float Thickness { get; set; } = 2f;

	protected override void OnGUIWhenEnabled()
	{
		// do not show when the console is enabled or in the hideout
		if (Cursor.visible)
			return;

		var player = GameState.Current?.LocalPlayer;
		if (!player.IsValid())
			return;

		if (player.HandsController == null)
			return;

		if (player.HandsController.IsAiming && HideWhenAiming)
			return;

		var centerx = Screen.width / 2;
		var centery = Screen.height / 2;

		Render.DrawCrosshair(new Vector2(centerx, centery), Size, Color, Thickness);
	}
}

```

`Features/Durability.cs`:

```cs
using System.Linq;
using EFT.InventoryLogic;
using EFT.Trainer.Extensions;
using EFT.Trainer.Properties;
using JetBrains.Annotations;

#nullable enable

namespace EFT.Trainer.Features;

[UsedImplicitly]
internal class Durability : ToggleFeature
{
	public override string Name => Strings.FeatureDurabilityName;
	public override string Description => Strings.FeatureDurabilityDescription;

	public override bool Enabled { get; set; } = false;

	protected override void UpdateWhenEnabled()
	{
		var player = GameState.Current?.LocalPlayer;
		if (!player.IsValid())
			return;

		var allPlayerItems = player.Profile
			.Inventory
			.GetPlayerItems()
			.ToArray();

		foreach (var item in allPlayerItems)
		{
			var repairable = item?.GetItemComponent<RepairableComponent>();
			if (repairable == null)
				continue;

			repairable.MaxDurability = repairable.TemplateDurability;
			repairable.Durability = repairable.MaxDurability;
		}
	}
}

```

`Features/Examine.cs`:

```cs
using System.Diagnostics.CodeAnalysis;
using EFT.InventoryLogic;
using EFT.Trainer.Properties;
using JetBrains.Annotations;
using static EFT.Player;

#nullable enable

namespace EFT.Trainer.Features;

[UsedImplicitly]
internal class Examine : ToggleFeature
{
	public override string Name => Strings.FeatureExamineName;
	public override string Description => Strings.FeatureExamineDescription;

	public override bool Enabled { get; set; } = false;

	[UsedImplicitly]
	[SuppressMessage("ReSharper", "InconsistentNaming")]
	protected static bool ExaminedPrefix(ref bool __result)
	{
		var feature = FeatureFactory.GetFeature<Examine>();
		if (feature == null || !feature.Enabled)
			return true; // keep using original code, we are not enabled

		__result = true;
		return false; // skip the original code and all other prefix methods 
	}

#pragma warning disable IDE0060
	[UsedImplicitly]
	protected static bool SinglePlayerInventoryControllerConstructorPrefix(Player player, Profile profile, bool isBot, ref bool examined)
	{
		var feature = FeatureFactory.GetFeature<Examine>();
		if (feature == null || !feature.Enabled)
			return true; // keep using original code, we are not enabled

		// this will make the game use the passthrough type implementing IPlayerSearchController, ISearchController with all items known and searched
		examined = true;
		return true;
	}
#pragma warning restore IDE0060

	protected override void UpdateWhenEnabled()
	{
		HarmonyPatchOnce(harmony =>
		{
			HarmonyPrefix(harmony, typeof(Profile), nameof(Profile.Examined), nameof(ExaminedPrefix), [typeof(MongoID)]);
			HarmonyPrefix(harmony, typeof(Profile), nameof(Profile.Examined), nameof(ExaminedPrefix), [typeof(Item)]);
			HarmonyConstructorPrefix(harmony, typeof(SinglePlayerInventoryController), nameof(SinglePlayerInventoryControllerConstructorPrefix), [typeof(Player), typeof(Profile), typeof(bool), typeof(bool)]);
		});
	}
}

```

`Features/ExfiltrationPoints.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Comfort.Common;
using EFT.Interactive;
using EFT.Trainer.Configuration;
using EFT.Trainer.Extensions;
using EFT.Trainer.Properties;
using JetBrains.Annotations;
using UnityEngine;

#nullable enable

namespace EFT.Trainer.Features;

[UsedImplicitly]
internal class ExfiltrationPoints : PointOfInterests
{
	public override string Name => Strings.FeatureExfiltrationPointsName;
	public override string Description => Strings.FeatureExfiltrationPointsDescription;

	[ConfigurationProperty(Order = 10)]
	public Color EligibleColor { get; set; } = Color.green;

	[ConfigurationProperty(Order = 10)]
	public Color NotEligibleColor { get; set; } = Color.yellow;

	[ConfigurationProperty(Order = 20)]
	public bool ShowEligible { get; set; } = true;

	[ConfigurationProperty(Order = 20)]
	public bool ShowNotEligible { get; set; } = true;

	[ConfigurationProperty(Order = 20)]
	public string StatusFilter { get; set; } = string.Empty;

	public override float CacheTimeInSec { get; set; } = 7f;
	public override Color GroupingColor => EligibleColor;

	public override void RefreshData(List<PointOfInterest> data)
	{
		var world = Singleton<GameWorld>.Instance;
		if (world == null)
			return;

		if (world.ExfiltrationController == null)
			return;

		var player = GameState.Current?.LocalPlayer;
		if (!player.IsValid())
			return;

		var profile = player.Profile;
		var info = profile?.Info;
		if (info == null)
			return;

		var side = info.Side;
		var points = GetExfiltrationPoints(side, world);
		if (points == null)
			return;

		var camera = GameState.Current?.Camera;
		if (camera == null)
			return;

		var eligiblePoints = GetEligibleExfiltrationPoints(side, world, profile!);
		if (eligiblePoints == null)
			return;

		foreach (var point in points)
		{
			if (!point.IsValid())
				continue;

			var position = point.transform.position;
			var isEligible = eligiblePoints.Contains(point);

			if (!ShowEligible && isEligible)
				continue;

			if (!ShowNotEligible && !isEligible)
				continue;

			if (!string.IsNullOrEmpty(StatusFilter) && StatusFilter.IndexOf(GetStatus(point.Status), StringComparison.OrdinalIgnoreCase) >= 0)
				continue;

			var poi = Pool.Get();
			poi.Name = GetName(point, isEligible);
			poi.Position = position;
			poi.Color = isEligible ? EligibleColor : NotEligibleColor;
			poi.Owner = null;

			data.Add(poi);
		}
	}

	private static string GetName(ExfiltrationPoint point, bool isEligible)
	{
		var localizedName = point.Settings.Name.Localized();
		return !isEligible ? localizedName : string.Format(Strings.FeatureExfiltrationPointsEligibleFormat, localizedName, GetStatus(point.Status));
	}

	public static string GetStatus(EExfiltrationStatus status)
	{
		return status switch
		{
			EExfiltrationStatus.AwaitsManualActivation => Strings.FeatureExfiltrationPointsStatusActivate,
			EExfiltrationStatus.Countdown => Strings.FeatureExfiltrationPointsStatusTimer,
			EExfiltrationStatus.NotPresent => Strings.FeatureExfiltrationPointsStatusClosed,
			EExfiltrationStatus.Pending => Strings.FeatureExfiltrationPointsStatusPending,
			EExfiltrationStatus.RegularMode => Strings.FeatureExfiltrationPointsStatusOpen,
			EExfiltrationStatus.UncompleteRequirements => Strings.FeatureExfiltrationPointsStatusRequirement,
			_ => string.Empty
		};
	}

	private static ExfiltrationPoint[]? GetExfiltrationPoints(EPlayerSide side, GameWorld world)
	{
		var ect = world.ExfiltrationController;
		// ReSharper disable once CoVariantArrayConversion
		return side == EPlayerSide.Savage ? ect.ScavExfiltrationPoints : ect.ExfiltrationPoints;
	}

	private static ExfiltrationPoint[]? GetEligibleExfiltrationPoints(EPlayerSide side, GameWorld world, Profile profile)
	{
		var ect = world.ExfiltrationController;
		if (side != EPlayerSide.Savage)
			return ect.EligiblePoints(profile);

		var mask = ect.GetScavExfiltrationMask(profile.Id);
		var result = new List<ExfiltrationPoint>();
		var points = ect.ScavExfiltrationPoints;

		for (int i = 0; i < 31; i++)
		{
			if ((mask & (1 << i)) != 0)
				result.Add(points[i]);
		}

		return [.. result];
	}
}

```

`Features/Feature.cs`:

```cs
using System;
using System.Reflection;
using EFT.InputSystem;
using EFT.UI;
using Newtonsoft.Json;

#nullable enable

namespace EFT.Trainer.Features;

internal interface IFeature
{
	[JsonIgnore]
	public string Name { get; }
}

internal abstract class Feature : InputNode, IFeature
{
	public abstract string Name { get; }
	public abstract string Description { get; }

	private string? _harmonyId = null;

	public void HarmonyPatchOnce(Action<HarmonyLib.Harmony> action)
	{
		if (_harmonyId != null) // this is faster than calling HarmonyLib.Harmony.HasAnyPatches(_harmonyId) for every Update
			return;

		_harmonyId = GetType().FullName;
		var harmony = new HarmonyLib.Harmony(_harmonyId);
		action(harmony);
	}

	public void HarmonyDispatch(HarmonyLib.Harmony harmony, Type originalType, string? originalMethod, string? newPrefixMethod, string? newPostfixMethod, Type[]? parameters = null)
	{
		MethodBase original = originalMethod == null
			? HarmonyLib.AccessTools.Constructor(originalType, parameters)
			: HarmonyLib.AccessTools.Method(originalType, originalMethod, parameters);

		if (original == null)
		{
			AddConsoleLog(string.Format(Properties.Strings.ErrorCannotFindOriginalMethodFormat, $"{originalType}.{originalMethod ?? "ctor"}").Red());
			return;
		}

		var prefix = GetTargetMethod(newPrefixMethod, Properties.Strings.ErrorCannotFindPrefixMethodFormat);
		var postfix = GetTargetMethod(newPostfixMethod, Properties.Strings.ErrorCannotFindPostfixMethodFormat);

		if (prefix != null && postfix != null)
			return;

		if (prefix == null && postfix == null)
			return;

		harmony.Patch(original, prefix: prefix, postfix: postfix);
#if DEBUG
		AddConsoleLog(string.Format(Properties.Strings.DebugPatchedMethodFormat, $"{originalType}.{originalMethod}", $"{GetType()}.{newPrefixMethod ?? newPostfixMethod}"));
#endif
	}

	private HarmonyLib.HarmonyMethod? GetTargetMethod(string? methodName, string errorFormat)
	{
		if (methodName == null)
			return null;

		var method = HarmonyLib.AccessTools.Method(GetType(), methodName);
		if (method == null)
			AddConsoleLog(string.Format(errorFormat, methodName).Red());

		return new HarmonyLib.HarmonyMethod(method);
	}

	public void HarmonyPrefix(HarmonyLib.Harmony harmony, Type originalType, string originalMethod, string newMethod, Type[]? parameters = null)
	{
		HarmonyDispatch(harmony, originalType, originalMethod, newPrefixMethod: newMethod, newPostfixMethod: null, parameters);
	}

	public void HarmonyConstructorPrefix(HarmonyLib.Harmony harmony, Type originalType, string newMethod, Type[]? parameters)
	{
		HarmonyDispatch(harmony, originalType, null, newPrefixMethod: newMethod, newPostfixMethod: null, parameters);
	}

	public void HarmonyPostfix(HarmonyLib.Harmony harmony, Type originalType, string originalMethod, string newMethod, Type[]? parameters = null)
	{
		HarmonyDispatch(harmony, originalType, originalMethod, newPrefixMethod: null, newPostfixMethod: newMethod, parameters);
	}

	protected void AddConsoleLog(string log)
	{
		if (PreloaderUI.Instantiated)
			ConsoleScreen.Log(log);
	}

#if EFT_LIVE 
	protected
#else
	public
#endif
	override ETranslateResult TranslateCommand(ECommand command)
	{
		return ETranslateResult.Ignore;
	}

#if EFT_LIVE 
	protected
#else
	public
#endif
	override void TranslateAxes(ref float[] axes)
	{
	}

#if EFT_LIVE 
	protected
#else
	public
#endif
	override ECursorResult ShouldLockCursor()
	{
		return ECursorResult.Ignore;
	}
}

```

`Features/FeatureFactory.cs`:

```cs
using System;
using System.Linq;
using UnityEngine;

#nullable enable

namespace EFT.Trainer.Features;

internal static class FeatureFactory
{
	private static GameObject? _gameObject = null;
	private static readonly Lazy<Type[]> _types = new(() => [.. typeof(FeatureFactory)
		.Assembly
		.GetTypes()
		.Where(t => t.IsSubclassOf(typeof(Feature)) && !t.IsAbstract)]);

	public static Feature[] RegisterAllFeatures(GameObject gameObject)
	{
		_gameObject = gameObject;

		return [.. GetAllFeatureTypes()
			.Select(gameObject.GetOrAddComponent)
			.OfType<Feature>()];
	}

	public static Type[] GetAllFeatureTypes()
	{
		return _types.Value;
	}

	public static T? GetFeature<T>() where T : Feature
	{
		return GetAllFeatures()
			.OfType<T>()
			.FirstOrDefault();
	}

	public static Feature[] GetAllFeatures()
	{
		if (_gameObject == null)
			return [];

		return [.. GetAllFeatureTypes()
			.Select(_gameObject.GetComponent)
			.OfType<Feature>()];
	}

	public static ToggleFeature[] GetAllToggleableFeatures()
	{
		return [.. GetAllFeatures().OfType<ToggleFeature>()];
	}
}

```

`Features/FeatureRenderer.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using EFT.InputSystem;
using EFT.Trainer.Configuration;
using EFT.Trainer.Properties;
using EFT.Trainer.UI;
using UnityEngine;

#nullable enable

namespace EFT.Trainer.Features;

internal abstract class FeatureRenderer : ToggleFeature
{
	public abstract float X { get; set; }
	public abstract float Y { get; set; }

	protected const float DefaultX = 40f;
	protected const float DefaultY = 20f;

	private static GUIStyle LabelStyle => new() { wordWrap = false, normal = { textColor = Color.white }, margin = new RectOffset(8, 0, 8, 0), fixedWidth = 150f, stretchWidth = false };
	private static GUIStyle DescriptionStyle => new() { wordWrap = true, normal = { textColor = Color.white }, margin = new RectOffset(8, 0, 8, 0), stretchWidth = true };
	private static GUIStyle BoxStyle => new(GUI.skin.box) { normal = { background = Texture2D.whiteTexture, textColor = Color.white } };

	protected void SetupWindowCoordinates()
	{
		bool needfix = false;
		X = FixCoordinate(X, Screen.width, DefaultX, ref needfix);
		Y = FixCoordinate(Y, Screen.height, DefaultY, ref needfix);

		if (needfix)
			SaveSettings();
	}

	private static float FixCoordinate(float coord, float maxValue, float defaultValue, ref bool needfix)
	{
		if (coord < 0 || coord >= maxValue)
		{
			coord = defaultValue;
			needfix = true;
		}

		return coord;
	}

	internal enum SelectionContextType { Color = 1, KeyCode = 2 }

	internal class SelectionContext
	{
		public SelectionContext(IFeature feature, OrderedProperty orderedProperty, float parentX, float parentY, Func<object, IPicker> builder, SelectionContextType contextType)
		{
			Feature = feature;
			OrderedProperty = orderedProperty;
			Picker = builder(orderedProperty.Property.GetValue(feature));
			ContextType = contextType;

			var position = Event.current.mousePosition;
			Picker.SetWindowPosition(parentX + LabelStyle.fixedWidth * 3 + LabelStyle.margin.left * 6, position.y + parentY - 32f);
		}

		public IFeature Feature { get; }
		public OrderedProperty OrderedProperty { get; }
		public IPicker Picker { get; }
		public SelectionContextType ContextType { get; }
	}

	private Rect _clientWindowRect;
	private Dictionary<SelectionContextType, SelectionContext> _selectionContexts = new();

	protected override void OnGUIWhenEnabled()
	{
		SetupInputNode();

		_clientWindowRect = new Rect(X, Y, 490, _clientWindowRect.height);
		_clientWindowRect = GUILayout.Window(0, _clientWindowRect, RenderFeatureWindow, Strings.FeatureCommandsTitle, GUILayout.ExpandHeight(true), GUILayout.ExpandWidth(true));
		X = _clientWindowRect.x;
		Y = _clientWindowRect.y;

		foreach (var key in _selectionContexts.Keys)
		{
			if (HandleSelectionContext(_selectionContexts[key]))
				_selectionContexts.Remove(key);
		}
	}

	private bool HandleSelectionContext(SelectionContext? context)
	{
		if (context == null)
			return false;

		var property = context.OrderedProperty.Property;
		var picker = context.Picker;

		picker.DrawWindow((int)context.ContextType, GetPropertyDisplay(property.Name));
		property.SetValue(context.Feature, picker.RawValue);

		return picker.IsSelected;
	}

	private int _selectedTabIndex = 0;
	private void RenderFeatureWindow(int id)
	{
		var fixedTabs = new[] { Strings.FeatureRendererSummary };

		var tabs = fixedTabs
			.Concat
			(
				Context
					.Features
					.Value
					.Select(RenderFeatureText)
			)
			.ToArray();

		var style = new GUIStyle { wordWrap = false, normal = { textColor = Color.white }, alignment = TextAnchor.UpperLeft, fixedHeight = 1, stretchHeight = true };

		GUILayout.BeginHorizontal();
		var lastIndex = _selectedTabIndex;
		_selectedTabIndex = GUILayout.SelectionGrid(_selectedTabIndex, tabs, 1, GUILayout.Width(LabelStyle.fixedWidth));

		if (lastIndex != _selectedTabIndex)
		{
			_selectionContexts.Clear();
		}

		GUILayout.BeginVertical(style);
		GUILayout.Space(4);

		switch (_selectedTabIndex)
		{
			case 0:
				RenderSummary();
				break;
			default:
				var feature = Context.Features.Value[_selectedTabIndex - fixedTabs.Length];
				RenderFeature(feature);

				break;

		}
		GUILayout.EndVertical();
		GUILayout.EndHorizontal();
		GUI.DragWindow();
	}

	private static string RenderFeatureText(Feature feature)
	{
		if (feature is not ToggleFeature toggleFeature || ConfigurationManager.IsSkippedProperty(feature, nameof(Enabled)))
			return feature.Name;

		return string.Format(Strings.CommandStatusTextFormat, feature.Name, toggleFeature.Enabled ? Strings.TextOn.Green() : Strings.TextOff.Red(), string.Empty);
	}

	private void RenderSummary()
	{
		GUILayout.BeginVertical();

		GUILayout.Label($"<i><b>{Strings.FeatureRendererWelcome}</b></i>\n", DescriptionStyle);

		if (GUILayout.Button(Strings.CommandLoadDescription))
			LoadSettings();

		if (GUILayout.Button(Strings.CommandSaveDescription))
			SaveSettings();

		GUILayout.EndVertical();
	}

	protected static void SaveSettings()
	{
		ConfigurationManager.Save(Context.ConfigFile, Context.Features.Value);
	}

	protected void LoadSettings(bool warnIfNotExists = true)
	{
		var cx = X;
		var cy = Y;

		ConfigurationManager.Load(Context.ConfigFile, Context.Features.Value, warnIfNotExists);
		_controlValues.Clear();

		if (!Enabled)
			return;

		X = cx;
		Y = cy;
	}

	private void RenderFeature(Feature feature)
	{
		var orderedProperties = ConfigurationManager.GetOrderedProperties(feature.GetType());

		GUILayout.BeginVertical();

		GUILayout.Label($"<i><b>{feature.Description}</b></i>\n", DescriptionStyle);

		foreach (var property in orderedProperties)
			RenderFeatureProperty(feature, property);

		GUILayout.EndVertical();
	}

	private static readonly Dictionary<string, string> _controlValues = [];
	private void RenderFeatureProperty(Feature feature, OrderedProperty orderedProperty)
	{
		if (!orderedProperty.Attribute.Browsable)
			return;

		var property = orderedProperty.Property;

		GUILayout.FlexibleSpace();
		GUILayout.BeginHorizontal();

		GUILayout.Label(GetPropertyDisplay(property.Name), LabelStyle);
		GUILayout.FlexibleSpace();

		var currentValue = property.GetValue(feature);
		var currentBackgroundColor = GUI.backgroundColor;

		if (currentValue == null)
			return;

		var width = GUILayout.Width(LabelStyle.fixedWidth);
		var newValue = RenderFeaturePropertyAsUIComponent(feature, orderedProperty, currentValue, width);

		if (currentValue != newValue)
			property.SetValue(feature, newValue);

		var focused = GUI.GetNameOfFocusedControl();

		foreach (var key in _selectionContexts.Keys)
		{
			if (ShouldResetSelectionContext(focused, _selectionContexts[key]))
				_selectionContexts.Remove(key);
		}

		GUI.backgroundColor = currentBackgroundColor;
		GUILayout.EndHorizontal();
	}

	protected abstract string GetPropertyDisplay(string propertyName);

	private object RenderFeaturePropertyAsUIComponent(IFeature feature, OrderedProperty orderedProperty, object currentValue, GUILayoutOption width)
	{
		var property = orderedProperty.Property;
		var propertyType = property.PropertyType;

		var newValue = currentValue;
		var controlName = $"{feature.Name}.{property.Name}-{propertyType.Name}";
		GUI.SetNextControlName(controlName);

		switch (propertyType.Name)
		{
			case nameof(Boolean):
				newValue = RenderBooleanProperty(currentValue, width);
				break;

			case nameof(KeyCode):
				RenderKeyCodeProperty(currentValue, controlName, feature, orderedProperty, width);
				break;

			case nameof(Single):
				newValue = RenderFloatProperty(currentValue, controlName, width);
				break;

			case nameof(Int32):
				newValue = RenderIntProperty(currentValue, width);
				break;

			case nameof(Color):
				RenderColorProperty(currentValue, controlName, feature, orderedProperty, width);
				break;

			case nameof(String):
				newValue = RenderStringProperty(currentValue, width);
				break;

			default:
				// Look for inner properties
				if (currentValue is IFeature subFeature)
				{
					var subProperties = ConfigurationManager.GetOrderedProperties(propertyType);
					var length = subProperties.Length;

					if (length > 0)
					{
						width = GUILayout.Width(LabelStyle.fixedWidth / length - length);

						foreach (var innerOrderedProperty in subProperties)
						{
							var innerProperty = innerOrderedProperty.Property;
							var innerPropertyValue = innerProperty.GetValue(subFeature);
							RenderFeaturePropertyAsUIComponent(subFeature, innerOrderedProperty, innerPropertyValue, width);
						}

						break;
					}

				}

				GUILayout.Label(string.Format(Strings.ErrorUnsupportedTypeFormat, propertyType.FullName));
				break;
		}

		return newValue;
	}

	private static bool ShouldResetSelectionContext(string focused, SelectionContext? context)
	{
		return !string.IsNullOrEmpty(focused)
			   && context != null
			   && !focused.EndsWith($"-{context.ContextType.ToString()}");
	}

	private static object RenderIntProperty(object currentValue, GUILayoutOption option)
	{
		object newValue = currentValue;

		if (int.TryParse(GUILayout.TextField(currentValue.ToString(), option), out var intValue))
			newValue = intValue;

		return newValue;
	}

	private static object RenderStringProperty(object currentValue, GUILayoutOption width)
	{
		return GUILayout.TextField(currentValue.ToString(), width);
	}

	private void RenderKeyCodeProperty(object currentValue, string controlName, IFeature feature, OrderedProperty orderedProperty, GUILayoutOption option)
	{
		if (!GUILayout.Button(currentValue.ToString(), option))
			return;

		_selectionContexts[SelectionContextType.KeyCode] = new SelectionContext(feature, orderedProperty, X, Y, o => new EnumPicker<KeyCode>((KeyCode)o), SelectionContextType.KeyCode);
		GUI.FocusControl(controlName);
	}

	private void RenderColorProperty(object currentValue, string controlName, IFeature feature, OrderedProperty orderedProperty, GUILayoutOption option)
	{
		GUI.backgroundColor = (Color)currentValue;

		if (!GUILayout.Button(string.Empty, BoxStyle, option, GUILayout.Height(22f)))
			return;

		_selectionContexts[SelectionContextType.Color] = new SelectionContext(feature, orderedProperty, X, Y, o => new ColorPicker((Color)o), SelectionContextType.Color);
		GUI.FocusControl(controlName);
	}

	private static object RenderFloatProperty(object currentValue, string controlName, GUILayoutOption width)
	{
		const string decimalSeparator = ".";
		const string altDecimalSeparator = ",";

		var culture = CultureInfo.InvariantCulture;
		var newValue = currentValue;

		if (!_controlValues.TryGetValue(controlName, out var controlText))
			controlText = currentValue.ToString();

		if (controlText != currentValue.ToString())
			GUI.backgroundColor = Color.red;

		controlText = GUILayout
			.TextField(controlText, width)
			.Replace(altDecimalSeparator, decimalSeparator);

		if (!controlText.EndsWith(decimalSeparator) && float.TryParse(controlText, NumberStyles.Float, culture, out var floatValue))
		{
			newValue = floatValue;
			controlText = newValue.ToString();
		}

		_controlValues[controlName] = controlText;
		return newValue;
	}

	private object RenderBooleanProperty(object currentValue, GUILayoutOption option)
	{
		var boolValue = (bool)currentValue;
		var newValue = GUILayout.Toggle(boolValue, string.Empty, option);
		if (newValue != boolValue)
		{
			_selectionContexts.Clear();
		}

		return newValue;
	}

#if EFT_LIVE
	protected
#else
	public
#endif
	override ETranslateResult TranslateCommand(ECommand command)
	{
		return command switch
		{
			// We do not want the player to shoot while clicking on a menu button
			ECommand.ToggleShooting when Enabled => ETranslateResult.BlockAll,
			_ => ETranslateResult.Ignore
		};
	}

#if EFT_LIVE
	protected
#else
	public
#endif
	override void TranslateAxes(ref float[] axes)
	{
		// this will disable the axes for player movement
		if (Enabled)
			axes = null!;
	}

#if EFT_LIVE
	protected
#else
	public
#endif
	override ECursorResult ShouldLockCursor()
	{
		return Enabled ? ECursorResult.ShowCursor : ECursorResult.Ignore;
	}

	private void SetupInputNode()
	{
		var player = GameState.Current?.LocalPlayer;
		if (player == null)
			return;

		if (!player.TryGetComponent<PlayerOwner>(out var owner))
			return;

		if (owner.InputTree.Contains(this))
			return;

		owner.InputTree.Add(this);
	}
}

```

`Features/FovChanger.cs`:

```cs
using EFT.Trainer.Configuration;
using EFT.Trainer.Properties;
using JetBrains.Annotations;
using UnityEngine;

namespace EFT.Trainer.Features;

[UsedImplicitly]
internal class FovChanger : ToggleFeature
{
	public override string Name => Strings.FeatureFovChangerName;
	public override string Description => Strings.FeatureFovChangerDescription;

	[ConfigurationProperty(Order = 1)]
	public override bool Enabled { get; set; } = false;

	[ConfigurationProperty(Order = 2)]
	public float Fov { get; set; } = 75f;

	[ConfigurationProperty(Order = 3)]
	public float CameraOffset { get; set; } = 0.05f;

	[UsedImplicitly]
	private void LateUpdate()
	{
		if (!Enabled)
			return;

		var snapshot = GameState.Current;
		if (snapshot == null)
			return;

		var camera = snapshot.Camera;
		if (camera == null)
			return;

		var player = snapshot.LocalPlayer;
		if (player == null)
			return;

		var container = player.ProceduralWeaponAnimation.HandsContainer;
		if (container == null)
			return;

		container.CameraOffset = new Vector3(0.04f, 0.04f, CameraOffset);
		camera.fieldOfView = Fov;
	}
}

```

`Features/FreeCamera.cs`:

```cs
using EFT.Trainer.Configuration;
using EFT.Trainer.Extensions;
using EFT.Trainer.Properties;
using JetBrains.Annotations;
using UnityEngine;

#nullable enable

namespace EFT.Trainer.Features;

[UsedImplicitly]
internal class FreeCamera : ToggleFeature
{
	private const string MouseXAxis = "Mouse X";
	private const string MouseYAxis = "Mouse Y";

	public override string Name => Strings.FeatureCameraName;
	public override string Description => Strings.FeatureCameraDescription;

	[ConfigurationProperty(Skip = true)] // we do not want to offer save/load support for this
	public override bool Enabled { get; set; } = false;

	[ConfigurationProperty(Order = 20)]
	public KeyCode Forward { get; set; } = KeyCode.UpArrow;

	[ConfigurationProperty(Order = 21)]
	public KeyCode Backward { get; set; } = KeyCode.DownArrow;

	[ConfigurationProperty(Order = 22)]
	public KeyCode Left { get; set; } = KeyCode.LeftArrow;

	[ConfigurationProperty(Order = 23)]
	public KeyCode Right { get; set; } = KeyCode.RightArrow;

	[ConfigurationProperty(Order = 24)]
	public KeyCode FastMode { get; set; } = KeyCode.RightShift;

	[ConfigurationProperty(Order = 25)]
	public KeyCode Teleport { get; set; } = KeyCode.T;

	[ConfigurationProperty(Order = 30)]
	public float FreeLookSensitivity { get; set; } = 3f;

	[ConfigurationProperty(Order = 31)]
	public float MovementSpeed { get; set; } = 10f;

	[ConfigurationProperty(Order = 32)]
	public float FastMovementSpeed { get; set; } = 100f;


	private void TogglePlayerActiveStatusIfNeeded()
	{
		var player = GameState.Current?.LocalPlayer;
		if (!player.IsValid())
			return;

		var playerGameObject = player.gameObject;
		if (playerGameObject.activeSelf == Enabled)
			playerGameObject.SetActive(!Enabled);
	}

	protected override void Update()
	{
		base.Update();

		TogglePlayerActiveStatusIfNeeded();
	}

	protected override void UpdateWhenEnabled()
	{
		var camera = GameState.Current?.Camera;
		if (camera == null)
			return;

		var fastMode = Input.GetKey(FastMode);
		var movementSpeed = fastMode ? FastMovementSpeed : MovementSpeed;

		var heading = Vector3.zero;
		var cameraTransform = camera.transform;

		if (Input.GetKey(Left))
			heading = -cameraTransform.right;

		if (Input.GetKey(Right))
			heading = cameraTransform.right;

		if (Input.GetKey(Forward))
			heading = cameraTransform.forward;

		if (Input.GetKey(Backward))
			heading = -cameraTransform.forward;

		if (heading != Vector3.zero)
			cameraTransform.position += movementSpeed * Time.deltaTime * heading;

		var localEulerAngles = cameraTransform.localEulerAngles;
		var newRotationX = localEulerAngles.y + Input.GetAxis(MouseXAxis) * FreeLookSensitivity;
		var newRotationY = localEulerAngles.x - Input.GetAxis(MouseYAxis) * FreeLookSensitivity;
		cameraTransform.localEulerAngles = new Vector3(newRotationY, newRotationX, 0f);

		if (Input.GetKey(Teleport))
		{
			var player = GameState.Current?.LocalPlayer;
			if (!player.IsValid())
				return;

			var position = new Vector3(cameraTransform.position.x, cameraTransform.position.y - 2f, cameraTransform.position.z);
			var playerGameObject = player.gameObject;

			playerGameObject.transform.SetPositionAndRotation(position, cameraTransform.rotation);
			playerGameObject.SetActive(true);
			Enabled = false;
		}
	}
}

```

`Features/GameState.cs`:

```cs
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Comfort.Common;
using EFT.Trainer.Configuration;
using EFT.Trainer.Extensions;
using EFT.Trainer.Properties;
using JetBrains.Annotations;
using UnityEngine;

#nullable enable

namespace EFT.Trainer.Features;

internal class GameState : CachableFeature<GameStateSnapshot>
{
	public override string Name => Strings.FeatureGameStateName;
	public override string Description => Strings.FeatureGameStateDescription;

	public static GameStateSnapshot? Current { get; private set; }

	public override float CacheTimeInSec { get; set; } = 2f;

	[ConfigurationProperty(Skip = true)] // we do not want to offer save/load support for this
	public override bool Enabled { get; set; } = true;

	[ConfigurationProperty(Skip = true)] // we do not want to offer save/load support for this
	public override KeyCode Key { get; set; } = KeyCode.None;

	public static Shader? OutlineShader { get; private set; }

	[UsedImplicitly]
	private void Awake()
	{
		// if we are not able to load our dedicated shader, we'll have OutlineShader==null => Unity will use the magenta-debug-shader, which is a nice fallback
		if (OutlineShader != null)
			return;

		var filename = Path.Combine(Application.dataPath, "outline");
		if (!File.Exists(filename))
			return;

		var bundle = AssetBundle.LoadFromFile(filename);
		if (bundle == null)
			return;

		OutlineShader = bundle.LoadAsset<Shader>("assets/outline.shader");
	}

	public override void RefreshData(List<GameStateSnapshot> data)
	{
		var snapshot = new GameStateSnapshot();
		var world = Singleton<GameWorld>.Instance;

		if (world == null)
			return;

		var players = world
			.RegisteredPlayers?
			.OfType<Player>();

		if (players == null)
			return;

		var hostiles = new List<Player>();
		snapshot.Hostiles = hostiles;

		foreach (var player in players)
		{
			if (player.IsYourPlayer)
			{
				snapshot.LocalPlayer = player;
				continue;
			}

			if (!player.IsAlive())
				continue;

			hostiles.Add(player);
		}

		snapshot.Camera = Camera.main;

		Current = snapshot;
		data.Add(snapshot);
	}
}

public class GameStateSnapshot
{
	public Camera? Camera { get; set; }
	public Camera? MapCamera { get; set; }
	public Player? LocalPlayer { get; set; }
	public IEnumerable<Player> Hostiles { get; set; } = [];
	public bool MapMode { get; set; } = false;
}

```

`Features/Ghost.cs`:

```cs
using System.Diagnostics.CodeAnalysis;
using EFT.Trainer.Extensions;
using EFT.Trainer.Properties;
using JetBrains.Annotations;
using UnityEngine;

#nullable enable

namespace EFT.Trainer.Features;

[UsedImplicitly]
internal class Ghost : ToggleFeature
{
	public override string Name => Strings.FeatureGhostName;
	public override string Description => Strings.FeatureGhostDescription;

	public override bool Enabled { get; set; } = false;

	[UsedImplicitly]
	[SuppressMessage("ReSharper", "InconsistentNaming")]
	private static bool CheckLookEnemy(EnemyInfo __instance)
	{
		var feature = FeatureFactory.GetFeature<Ghost>();
		if (feature == null || !feature.Enabled)
			return true; // keep using original code, we are not enabled

		if (__instance.Person is not { IsYourPlayer: true })
			return true; // use original code

		var groupInfo = __instance.GroupInfo;
		groupInfo.Clear();
		groupInfo.IsHaveSeen = false;
		groupInfo.EnemyLastPosition = Vector3.zero;
		groupInfo.EnemyLastVisiblePosition = Vector3.zero;
		groupInfo.EnemyWeaponRootLastPos = Vector3.zero;
		groupInfo.EnemyLastSeenTimeSense = 0f;
		groupInfo.EnemyLastSeenTimeReal = 0f;

		var memory = __instance.Owner.Memory;
		memory.GoalTarget.Clear();
		memory.GoalEnemy = null;
		memory.LastEnemy = null;

		__instance.SetVisible(false);
		__instance.SetCanShoot(false);
		__instance.SetIgnoreState();

		return false; // skip the original code
	}

	protected override void UpdateWhenEnabled()
	{
		var player = GameState.Current?.LocalPlayer;
		if (!player.IsValid())
			return;

		HarmonyPatchOnce(harmony =>
		{
			HarmonyPrefix(harmony, typeof(EnemyInfo), nameof(EnemyInfo.CheckLookEnemy), nameof(CheckLookEnemy));
		});
	}
}

```

`Features/Grenades.cs`:

```cs
using System.Collections.Generic;
using Comfort.Common;
using EFT.Trainer.Configuration;
using EFT.Trainer.Extensions;
using EFT.Trainer.Properties;
using JetBrains.Annotations;
using UnityEngine;

#nullable enable

namespace EFT.Trainer.Features;

[UsedImplicitly]
internal class Grenades : CachableFeature<Throwable>
{
	public override string Name => Strings.FeatureGrenadesName;
	public override string Description => Strings.FeatureGrenadesDescription;

	[ConfigurationProperty]
	public Color Color { get; set; } = Color.red;

	public override bool Enabled { get; set; } = false;
	public override float CacheTimeInSec { get; set; } = 0.25f;

	public override void RefreshData(List<Throwable> data)
	{
		var world = Singleton<GameWorld>.Instance;
		if (world == null)
			return;

		var grenades = world.Grenades;
		if (grenades == null)
			return;

		for (var i = 0; i < grenades.Count; i++)
		{
			var grenade = grenades.GetByIndex(i);
			if (!grenade.IsValid())
				continue;

			data.Add(grenade);
		}
	}

	public override void ProcessData(IReadOnlyList<Throwable> data)
	{
		foreach (var throwable in data)
		{
			if (!throwable.IsValid())
				return;

			SetShaders(throwable, GameState.OutlineShader, Color);
		}
	}

	private static void SetShaders(Throwable throwable, Shader? shader, Color color)
	{
		var transform = throwable.transform;
		foreach (var renderer in transform.GetComponentsInChildren<Renderer>())
		{
			if (renderer == null)
				continue;

			var material = renderer.material;
			if (material == null)
				continue;

			if (material.shader != null && material.shader == shader)
				continue;

			material.shader = shader;

			material.SetColor(ShaderProperties.FirstOutlineColor, color);
			material.SetFloat(ShaderProperties.FirstOutlineWidth, 0.02f);
			material.SetColor(ShaderProperties.SecondOutlineColor, color);
			material.SetFloat(ShaderProperties.SecondOutlineWidth, 0.0025f);
			material.SetFloat(ShaderProperties.ZTest, (float)UnityEngine.Rendering.CompareFunction.Always);
		}
	}
}

```

`Features/Health.cs`:

```cs
using System;
using System.Diagnostics.CodeAnalysis;
using EFT.Ballistics;
using EFT.HealthSystem;
using EFT.Trainer.Configuration;
using EFT.Trainer.Extensions;
using EFT.Trainer.Properties;
using JetBrains.Annotations;

#nullable enable

namespace EFT.Trainer.Features;

[UsedImplicitly]
internal class Health : ToggleFeature
{
	public override string Name => Strings.FeatureHealthName;
	public override string Description => Strings.FeatureHealthDescription;

	public override bool Enabled { get; set; } = false;

	[ConfigurationProperty]
	public bool VitalsOnly { get; set; } = false;

	[ConfigurationProperty]
	public bool RemoveNegativeEffects { get; set; } = true;

	[ConfigurationProperty]
	public bool FoodWater { get; set; } = true;

	private static readonly Array _bodyParts = Enum.GetValues(typeof(EBodyPart));

#pragma warning disable IDE0060
	[UsedImplicitly]
	[SuppressMessage("ReSharper", "InconsistentNaming")]
	protected static bool ApplyDamagePrefix(EBodyPart bodyPart, ActiveHealthController? __instance, ref float __result)
	{
		if (__instance == null)
			return true; // keep using original code

		if (UseBuiltinDamageLogic(__instance.Player, bodyPart))
			return true; // keep using original code

		__result = 0f;
		return false;  // skip the original code and all other prefix methods 
	}

	[UsedImplicitly]
	[SuppressMessage("ReSharper", "InconsistentNaming")]
	protected static bool ReceiveDamagePrefix(float damage, EBodyPart part, EDamageType type, float absorbed, MaterialType special, Player? __instance)
	{
		return UseBuiltinDamageLogic(__instance, part);
	}
#pragma warning restore IDE0060

	protected static bool UseBuiltinDamageLogic(Player? player, EBodyPart bodyPart)
	{
		var feature = FeatureFactory.GetFeature<Health>();
		if (feature == null || !feature.Enabled)
			return true; // keep using original code, we are not enabled

		if (player == null || !player.IsYourPlayer)
			return true; // keep using original code, apply damage to others

		if (feature.VitalsOnly && bodyPart is not (EBodyPart.Chest or EBodyPart.Head))
			return true; // keep using original code, apply damage to extremities 

		return false;  // skip the original code and all other prefix methods 
	}

	protected override void UpdateWhenEnabled()
	{
		var player = GameState.Current?.LocalPlayer;
		if (!player.IsValid())
			return;

		var healthController = player.ActiveHealthController;
		if (healthController == null)
			return;

		HarmonyPatchOnce(harmony =>
		{
			HarmonyPrefix(harmony, typeof(ActiveHealthController), nameof(ActiveHealthController.ApplyDamage), nameof(ApplyDamagePrefix));
			HarmonyPrefix(harmony, typeof(Player), nameof(Player.ReceiveDamage), nameof(ReceiveDamagePrefix));
		});

		foreach (EBodyPart bodyPart in _bodyParts)
		{
			if (bodyPart == EBodyPart.Common)
				continue;

			if (VitalsOnly && bodyPart is not (EBodyPart.Chest or EBodyPart.Head))
				continue;

			if (healthController.IsBodyPartBroken(bodyPart) || healthController.IsBodyPartDestroyed(bodyPart))
				healthController.RestoreBodyPart(bodyPart, 1);

			if (RemoveNegativeEffects)
			{
				healthController.RemoveNegativeEffects(bodyPart);
				healthController.RemoveNegativeEffects(EBodyPart.Common);
			}

			var bodyPartHealth = healthController.GetBodyPartHealth(bodyPart);
			if (bodyPartHealth.AtMaximum)
				continue;

			if (!VitalsOnly)
				healthController.RestoreFullHealth();

			healthController.ChangeHealth(bodyPart, bodyPartHealth.Maximum, default);

			break;
		}

		if (!healthController.Energy.AtMaximum && FoodWater)
			healthController.ChangeEnergy(healthController.Energy.Maximum);

		if (!healthController.Hydration.AtMaximum && FoodWater)
			healthController.ChangeHydration(healthController.Hydration.Maximum);
	}
}

```

`Features/Hits.cs`:

```cs
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using EFT.HealthSystem;
using EFT.Trainer.Configuration;
using EFT.Trainer.Extensions;
using EFT.Trainer.Properties;
using EFT.Trainer.UI;
using JetBrains.Annotations;
using UnityEngine;

#nullable enable

namespace EFT.Trainer.Features;

[UsedImplicitly]
internal class Hits : ToggleFeature
{
	public override string Name => Strings.FeatureHitsName;
	public override string Description => Strings.FeatureHitsDescription;

	public override bool Enabled { get; set; } = false;

	[ConfigurationProperty(Order = 10)]
	public Color HitMarkerColor { get; set; } = new(225f / 255f, 66f / 255f, 33f / 255f, 1.0f);

	[ConfigurationProperty(Order = 11)]
	public Color ArmorDamageColor { get; set; } = new(0.0f, 126f / 255f, 1.0f, 1.0f);

	[ConfigurationProperty(Order = 12)]
	public Color HealthDamageColor { get; set; } = new(1.0f, 33f / 255f, 33f / 255f, 1.0f);

	[ConfigurationProperty(Order = 20)]
	public float DisplayTime { get; set; } = 2f;

	[ConfigurationProperty(Order = 21)]
	public float FadeOutTime { get; set; } = 1f;

	[ConfigurationProperty(Order = 30)]
	public bool ShowHitMarker { get; set; } = true;

	[ConfigurationProperty(Order = 31)]
	public bool ShowArmorDamage { get; set; } = true;

	[ConfigurationProperty(Order = 32)]
	public bool ShowHealthDamage { get; set; } = true;


	internal class HitMarker(DamageInfoStruct damageInfo)
	{
		public float ElapsedTime { get; set; } = 0.0f;
		public DamageInfoStruct DamageInfo { get; set; } = damageInfo;
		public bool IsTaggedForDeletion { get; set; } = false;
	}

	private static readonly HashSet<HitMarker> _hitMarkers = [];

#pragma warning disable IDE0060
	[UsedImplicitly]
	[SuppressMessage("ReSharper", "InconsistentNaming")]
	protected static void ApplyDamagePostfix(EBodyPart bodyPart, float damage, DamageInfoStruct damageInfo, ActiveHealthController? __instance)
	{
		var feature = FeatureFactory.GetFeature<Hits>();
		if (feature == null || !feature.Enabled)
			return;

		if (__instance == null)
			return;

		var victim = __instance.Player;
		if (victim == null || victim.IsYourPlayer)
			return;

		var shooter = damageInfo.Player?.iPlayer;
		if (shooter is not { IsYourPlayer: true })
			return;

		var marker = new HitMarker(damageInfo);
		_hitMarkers.Add(marker);
	}
#pragma warning restore IDE0060

	protected override void OnGUIWhenEnabled()
	{
		var camera = GameState.Current?.Camera;
		if (camera == null)
			return;

		foreach (var marker in _hitMarkers)
		{
			var damageInfo = marker.DamageInfo;
			marker.ElapsedTime += Time.deltaTime;

			if (damageInfo.Weapon == null || marker.ElapsedTime >= DisplayTime + FadeOutTime)
			{
				marker.IsTaggedForDeletion = true;
				continue;
			}

			var alpha = marker.ElapsedTime > DisplayTime && FadeOutTime > 0f ? (FadeOutTime - marker.ElapsedTime + DisplayTime) / FadeOutTime : 1f;
			var armorDamage = Mathf.Round(damageInfo.ArmorDamage);
			var damage = Mathf.Round(damageInfo.Damage);
			var hitPoint = damageInfo.HitPoint;
			var screenHitPoint = camera.WorldPointToScreenPoint(hitPoint);

			if (ShowHitMarker)
			{
				var radius = 16f + marker.ElapsedTime * 2;
				Render.DrawCircle(screenHitPoint, radius, HitMarkerColor.SetAlpha(alpha), 2.98f, 32);
			}

			var offset = 0f;
			if (armorDamage > 0 && ShowArmorDamage)
			{
				offset = 10f;
				Render.DrawString(new Vector2(screenHitPoint.x, screenHitPoint.y - offset), $"{armorDamage}", ArmorDamageColor.SetAlpha(alpha));
			}

			if (damage > 0 && ShowHealthDamage)
				Render.DrawString(new Vector2(screenHitPoint.x, screenHitPoint.y + offset), $"{damage}", HealthDamageColor.SetAlpha(alpha));
		}

		_hitMarkers.RemoveWhere(m => m.IsTaggedForDeletion);
	}

	protected override void UpdateWhenEnabled()
	{
		var player = GameState.Current?.LocalPlayer;
		if (!player.IsValid())
			return;

		HarmonyPatchOnce(harmony =>
		{
			HarmonyPostfix(harmony, typeof(ActiveHealthController), nameof(ActiveHealthController.ApplyDamage), nameof(ApplyDamagePostfix));
		});
	}
}

```

`Features/HoldFeature.cs`:

```cs
using EFT.Trainer.Configuration;
using JetBrains.Annotations;
using UnityEngine;

#nullable enable

namespace EFT.Trainer.Features;

internal abstract class HoldFeature : Feature
{
	[ConfigurationProperty(Order = 2)]
	public virtual KeyCode Key { get; set; } = KeyCode.None;

	[UsedImplicitly]
	protected virtual void Update()
	{
		if (Key != KeyCode.None && Input.GetKey(Key))
			UpdateWhenHold();
	}

	protected virtual void UpdateWhenHold() { }
}

```

`Features/Hud.cs`:

```cs
using System.Text;
using EFT.InventoryLogic;
using EFT.Trainer.Configuration;
using EFT.Trainer.Extensions;
using EFT.Trainer.Properties;
using EFT.Trainer.UI;
using JetBrains.Annotations;
using UnityEngine;

#nullable enable

namespace EFT.Trainer.Features;

[UsedImplicitly]
internal class Hud : ToggleFeature
{
	public override string Name => Strings.FeatureHudName;
	public override string Description => Strings.FeatureHudDescription;

	[ConfigurationProperty]
	public Color Color { get; set; } = Color.white;

	[ConfigurationProperty]
	public bool ShowCompass { get; set; } = true;

	private static readonly string[] _directions = [
		Strings.DirectionNorth,
		Strings.DirectionNorthEast,
		Strings.DirectionEast,
		Strings.DirectionSouthEast,
		Strings.DirectionSouth,
		Strings.DirectionSouthWest,
		Strings.DirectionWest,
		Strings.DirectionNorthWest,
		Strings.DirectionNorth
	];

	[ConfigurationProperty]
	public bool ShowCoordinates { get; set; } = false;

	private readonly StringBuilder _sb = new();
	protected override void OnGUIWhenEnabled()
	{
		var player = GameState.Current?.LocalPlayer;
		if (!player.IsValid())
			return;

		var camera = GameState.Current?.Camera;
		if (camera == null)
			return;

		if (player.HandsController == null || player.HandsController.Item is not Weapon weapon)
			return;

		var mag = weapon.GetCurrentMagazine();
		if (mag == null)
			return;

		_sb.Clear();

		if (ShowCompass)
		{
			var forward = camera.transform.forward;
			forward.y = 0;

			var heading = Quaternion.LookRotation(forward).eulerAngles.y;
			_sb.Append(_directions[(int)Mathf.Round(heading % 360 / 45)]);
			_sb.Append(Strings.FeatureHudSeparator);
		}

		_sb.Append(string.Format(Strings.FeatureHudWeaponFormat, mag.Count, weapon.ChamberAmmoCount, mag.MaxCount, weapon.SelectedFireMode));

		if (ShowCoordinates)
		{
			_sb.Append(Strings.FeatureHudSeparator);
			var position = player.Transform.position;
			_sb.Append(string.Format(Strings.FeatureHudCoordinatesFormat, Mathf.RoundToInt(position.x), Mathf.RoundToInt(position.z)));
		}

		Render.DrawString(new Vector2(512, Screen.height - 16f), _sb.ToString(), Color);
	}
}

```

`Features/Interact.cs`:

```cs
using EFT.Trainer.Configuration;
using EFT.Trainer.Properties;
using JetBrains.Annotations;

namespace EFT.Trainer.Features;

[UsedImplicitly]
internal class Interact : ToggleFeature
{
	public override string Name => Strings.FeatureInteractName;
	public override string Description => Strings.FeatureInteractDescription;

	public override bool Enabled { get; set; } = false;

	[ConfigurationProperty]
	public float Distance { get; set; } = 1f;

	public static float DefaultLootDistance { get; set; } = EFTHardSettings.Instance.LOOT_RAYCAST_DISTANCE;
	public static float DefaultDoorDistance { get; set; } = EFTHardSettings.Instance.DOOR_RAYCAST_DISTANCE;

	protected override void UpdateWhenEnabled()
	{
		EFTHardSettings.Instance.LOOT_RAYCAST_DISTANCE = Distance;
		EFTHardSettings.Instance.DOOR_RAYCAST_DISTANCE = Distance;
	}

	protected override void UpdateWhenDisabled()
	{
		EFTHardSettings.Instance.LOOT_RAYCAST_DISTANCE = DefaultLootDistance;
		EFTHardSettings.Instance.DOOR_RAYCAST_DISTANCE = DefaultDoorDistance;
	}
}

```

`Features/LootItems.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Comfort.Common;
using EFT.Interactive;
using EFT.InventoryLogic;
using EFT.Trainer.Configuration;
using EFT.Trainer.Extensions;
using EFT.Trainer.Properties;
using JsonType;
using UnityEngine;

#nullable enable

namespace EFT.Trainer.Features;

// StayInTarkov (SIT) is exposing a LootItems type in the global namespace, so make sure to use a qualified name for this one
internal class LootItems : PointOfInterests
{
	public override string Name => Strings.FeatureLootItemsName;
	public override string Description => Strings.FeatureLootItemsDescription;

	[ConfigurationProperty]
	public Color Color { get; set; } = Color.cyan;

	[ConfigurationProperty(Browsable = false, CommentResourceId = nameof(Strings.PropertyTrackedNamesComment))]
	public List<TrackedItem> TrackedNames { get; set; } = [];

	[ConfigurationProperty]
	public bool SearchInsideContainers { get; set; } = true;

	[ConfigurationProperty]
	public bool SearchInsideCorpses { get; set; } = true;

	[ConfigurationProperty]
	public bool ShowPrices { get; set; } = true;

	[ConfigurationProperty]
	public bool TrackWishlist { get; set; } = false;

	[ConfigurationProperty]
	public bool TrackAutoWishlist { get; set; } = false;

	public override float CacheTimeInSec { get; set; } = 3f;
	public override Color GroupingColor => Color;

	public HashSet<string> Wishlist { get; set; } = [];

	public bool Track(string lootname, Color? color, ELootRarity? rarity)
	{
		lootname = lootname.Trim();

		if (TrackedNames.Any(t => t.Name == lootname && t.Rarity == rarity))
			return false;

		TrackedNames.Add(new TrackedItem(lootname, color, rarity));
		return true;

	}

	public bool UnTrack(string lootname)
	{
		lootname = lootname.Trim();

		if (lootname == TrackedItem.MatchAll && TrackedNames.Count > 0)
		{
			TrackedNames.Clear();
			return true;
		}

		return TrackedNames.RemoveAll(t => t.Name == lootname) > 0;
	}

	private HashSet<string> RefreshWishlist()
	{
		if (!TrackWishlist && !TrackAutoWishlist)
			return [];

		var player = GameState.Current?.LocalPlayer;
		if (!player.IsValid())
			return [];

		var manager = player.Profile?.WishlistManager;
		if (manager == null)
			return [];

		return TrackWishlist switch
		{
			true when TrackAutoWishlist => [.. manager.GetWishlist().Keys], // this will get user items + auto-add hideout items if enabled in settings
			true when !TrackAutoWishlist => [.. manager.UserItems.Keys],    // this will get user items only
			false when TrackAutoWishlist => [.. manager.GetWishlist().Keys.Except(manager.UserItems.Keys)],
			_ => []
		};
	}

	public override void RefreshData(List<PointOfInterest> data)
	{
		Wishlist.Clear();
		Wishlist = RefreshWishlist();

		if (TrackedNames.Count == 0 && Wishlist.Count == 0)
			return;

		var world = Singleton<GameWorld>.Instance;
		if (world == null)
			return;

		var player = GameState.Current?.LocalPlayer;
		if (!player.IsValid())
			return;

		var camera = GameState.Current?.Camera;
		if (camera == null)
			return;

		// Step 1 - look outside containers (loot items)
		FindLootItems(world, data);

		// Step 2 - look inside containers (items)
		if (SearchInsideContainers)
			FindItemsInContainers(world, data);
	}

	private void FindItemsInContainers(GameWorld world, List<PointOfInterest> records)
	{
		var owners = world.ItemOwners; // contains all containers: corpses, LootContainers, ...
		foreach (var (key, ownerValue) in owners)
		{
			var rootItem = key.RootItem;
			if (rootItem is not { IsContainer: true })
				continue;

			if (!rootItem.IsValid() || rootItem.IsFiltered()) // filter default inventory container here, given we special case the corpse container
				continue;

			var valueTransform = ownerValue.Transform;
			if (valueTransform == null)
				continue;

			var position = valueTransform.position;
			FindItemsInRootItem(records, rootItem, position);
		}
	}

	private void FindItemsInRootItem(List<PointOfInterest> records, Item? rootItem, Vector3 position)
	{
		var items = rootItem?
			.GetAllItems()?
			.ToArray();

		if (items == null)
			return;

		foreach (var item in items)
		{
			if (!item.IsValid() || item.IsFiltered())
				continue;

			TryAddRecordIfTracked(item, records, position, item.Owner?.RootItem?.TemplateId.LocalizedShortName()); // nicer than ItemOwner.ContainerName which is full caps
		}
	}

	private void FindLootItems(GameWorld world, List<PointOfInterest> records)
	{
		var lootItems = world.LootItems;

		for (var i = 0; i < lootItems.Count; i++)
		{
			var lootItem = lootItems.GetByIndex(i);
			if (!lootItem.IsValid())
				continue;

			var position = lootItem.transform.position;

			if (lootItem is Corpse corpse)
			{
				if (SearchInsideCorpses)
					FindItemsInRootItem(records, corpse.ItemOwner?.RootItem, position);

				continue;
			}

			TryAddRecordIfTracked(lootItem.Item, records, position);
		}
	}

	private string FormatName(string itemName, Item item)
	{
		var price = item.Template.CreditsPrice;
		if (!ShowPrices || price < 1000)
			return itemName;

		return $"{itemName} {price / 1000}K";
	}

	private void TryAddRecordIfTracked(Item item, List<PointOfInterest> records, Vector3 position, string? owner = null)
	{
		var itemName = item.ShortName.Localized();
		var template = item.Template;
		var templateId = template._id;
		var color = Color;

		if (!Wishlist.Contains(templateId))
		{
			var rarity = template.GetEstimatedRarity();
			var trackedItem = TryFindTrackedItem(itemName, templateId, rarity);
			if (trackedItem == null)
				return;

			color = trackedItem.Color ?? color;
		}

		if (owner != null && owner == KnownTemplateIds.DefaultInventoryLocalizedShortName)
			owner = nameof(Corpse);

		var poi = Pool.Get();
		poi.Name = FormatName(itemName, item);
		poi.Owner = string.Equals(itemName, owner, StringComparison.OrdinalIgnoreCase) ? null : owner;
		poi.Position = position;
		poi.Color = color;

		records.Add(poi);
	}

	private TrackedItem? TryFindTrackedItem(string itemName, string templateId, ELootRarity rarity)
	{
		return TrackedNames.FirstOrDefault(t => TextMatches(t, itemName, templateId) && RarityMatches(rarity, t.Rarity));
	}

	private static bool TextMatches(TrackedItem trackedItem, string itemName, string templateId)
	{
		return trackedItem.IsMatchAll
			   || itemName.IndexOf(trackedItem.Name, StringComparison.OrdinalIgnoreCase) >= 0
			   || string.Equals(templateId, trackedItem.Name, StringComparison.OrdinalIgnoreCase);
	}

	private static bool RarityMatches(ELootRarity itemRarity, ELootRarity? trackedRarity)
	{
		if (!trackedRarity.HasValue)
			return true;

		return trackedRarity.Value == itemRarity;
	}
}

```

`Features/LootableContainers.cs`:

```cs
using System.Collections.Generic;
using Comfort.Common;
using EFT.Interactive;
using EFT.Trainer.Configuration;
using EFT.Trainer.Extensions;
using EFT.Trainer.Properties;
using JetBrains.Annotations;
using UnityEngine;

#nullable enable

namespace EFT.Trainer.Features;

[UsedImplicitly]
internal class LootableContainers : PointOfInterests
{
	public override string Name => Strings.FeatureStashName;
	public override string Description => Strings.FeatureStashDescription;

	//Static Hashset for List of Container IDS
	private static readonly HashSet<string> _targetedContainer =
	[
		KnownTemplateIds.BuriedBarrelCache,
		KnownTemplateIds.GroundCache,
		KnownTemplateIds.AirDropCommon,
		KnownTemplateIds.AirDropMedical,
		KnownTemplateIds.AirDropSupply,
		KnownTemplateIds.AirDropWeapon
	];

	[ConfigurationProperty]
	public Color Color { get; set; } = Color.white;

	public override float CacheTimeInSec { get; set; } = 11f;
	public override bool Enabled { get; set; } = false;
	public override Color GroupingColor => Color;

	[ConfigurationProperty]
	public bool ShowContainers { get; set; } = true;

	[ConfigurationProperty]
	public bool ShowCorpses { get; set; } = true;

	public override void RefreshData(List<PointOfInterest> data)
	{
		var world = Singleton<GameWorld>.Instance;
		if (world == null)
			return;

		var player = GameState.Current?.LocalPlayer;
		if (!player.IsValid())
			return;

		var camera = GameState.Current?.Camera;
		if (camera == null)
			return;

		var owners = world.ItemOwners;

		foreach (var owner in owners)
		{
			var itemOwner = owner.Key;
			var rootItem = itemOwner.RootItem;

			if (!rootItem.IsValid())
				continue;

			if (rootItem is not { IsContainer: true })
				continue;

			if (ShowContainers && _targetedContainer.Contains(rootItem.TemplateId))
				AddRecord(rootItem.TemplateId.LocalizedShortName(), owner.Value.Transform.position, data);

			if (ShowCorpses && rootItem.TemplateId == KnownTemplateIds.DefaultInventory
							&& itemOwner is TraderControllerClass { Name: nameof(Corpse) }) // only display dead bodies
				AddRecord(nameof(Corpse), owner.Value.Transform.position, data);
		}
	}

	private void AddRecord(string itemName, Vector3 position, List<PointOfInterest> records)
	{
		var poi = Pool.Get();
		poi.Name = itemName;
		poi.Position = position;
		poi.Color = Color;
		poi.Owner = null;

		records.Add(poi);
	}
}

```

`Features/Map.cs`:

```cs
using EFT.Trainer.Configuration;
using EFT.Trainer.Extensions;
using EFT.Trainer.Properties;
using EFT.Trainer.UI;
using JetBrains.Annotations;
using UnityEngine;

#nullable enable

namespace EFT.Trainer.Features;

[UsedImplicitly]
internal class Map : BaseMapToggleFeature
{
	public override string Name => Strings.FeatureMapName;
	public override string Description => Strings.FeatureMapDescription;

	[ConfigurationProperty(Skip = true)] // we do not want to offer save/load support for this
	public override bool Enabled { get; set; } = false;

	[ConfigurationProperty(Order = 20)]
	public float Range { get; set; } = 400f;

	protected override void OnGUIWhenEnabled()
	{
		if (Range <= 0)
			return;

		var snapshot = GameState.Current;
		if (snapshot == null)
			return;

		snapshot.MapMode = true;

		var camera = snapshot.Camera;
		if (camera == null)
			return;

		var hostiles = snapshot.Hostiles;
		var width = Screen.currentResolution.width;
		var height = Screen.currentResolution.height;

		SetupMapCamera(camera, 0, 0, width, height);
		UpdateMapCamera(camera, Range);

		if (MapCamera == null)
			return;

		if (snapshot.MapCamera != MapCamera)
			snapshot.MapCamera = MapCamera;

		Render.DrawPlayer(Render.ScreenCenter, 10f, Color.white, 2f);

		DrawHostiles(MapCamera, hostiles, Range);
	}

	protected override void UpdateWhenDisabled()
	{
		ToggleMapCameraIfNeeded(false);

		var snapshot = GameState.Current;
		if (snapshot == null)
			return;

		snapshot.MapMode = false;
	}

	protected override Vector2 GetTargetPosition(Vector3 playerPosition, Vector3 targetPosition, float playerEulerY)
	{
		if (MapCamera == null)
			return Vector2.zero;

		return MapCamera.WorldPointToScreenPoint(targetPosition);
	}

	protected override void AdjustTargetPositionForRender(ref Vector2 position)
	{
		// nothing to do for a full map
	}
}

```

`Features/Mortar.cs`:

```cs
using Comfort.Common;
using EFT.Trainer.Properties;
using JetBrains.Annotations;
using UnityEngine;

#nullable enable

namespace EFT.Trainer.Features;

[UsedImplicitly]
internal class Mortar : TriggerFeature
{
	public override string Name => Strings.FeatureMortarName;
	public override string Description => Strings.FeatureMortarDescription;

	public override KeyCode Key { get; set; } = KeyCode.None;

	protected override void UpdateOnceWhenTriggered()
	{
		var world = Singleton<GameWorld>.Instance;
		if (world == null)
			return;

		var player = GameState.Current?.LocalPlayer;
		if (player == null)
			return;

		world.ServerShellingController?.StartShellingPosition(player.Transform.position);
	}
}

```

`Features/NightVision.cs`:

```cs
using EFT.InventoryLogic;
using EFT.Trainer.Extensions;
using EFT.Trainer.Properties;
using JetBrains.Annotations;
using UnityEngine;

#nullable enable

namespace EFT.Trainer.Features;

[UsedImplicitly]
internal class NightVision : ToggleFeature
{
	public override string Name => Strings.FeatureNightVisionName;
	public override string Description => Strings.FeatureNightVisionDescription;

	public override bool Enabled { get; set; } = false;

	protected override void Update()
	{
		base.Update();

		// Do not interact while in hideout or if the player is already wearing compatible equipment
		var player = GameState.Current?.LocalPlayer;
		if (player == null || player is HideoutPlayer || player.HasItemComponentInSlot<NightVisionComponent>(EquipmentSlot.Headwear))
			return;

		var camera = GameState.Current?.Camera;
		if (camera == null)
			return;

		var component = camera.GetComponent<BSG.CameraEffects.NightVision>();
		if (component == null || component.On == Enabled)
			return;

		component.StartSwitch(Enabled);

		if (!Enabled)
			return;

		// component.DiffuseIntensity = 0f; removed with 0.12.12.19078
		component.Intensity = 0f;
		component.NoiseIntensity = 0f;

		component.TextureMask.Color = new Color(0f, 0f, 0f, 0f);
		component.TextureMask.Stretch = false;
		component.TextureMask.Size = 0f;
	}
}

```

`Features/NoCollision.cs`:

```cs
using EFT.Trainer.Properties;
using JetBrains.Annotations;
using UnityEngine;

#nullable enable

namespace EFT.Trainer.Features;

[UsedImplicitly]
internal class NoCollision : ToggleFeature
{
	public override string Name => Strings.FeatureNoCollisionName;
	public override string Description => Strings.FeatureNoCollisionDescription;

	public override bool Enabled { get; set; } = false;

	protected override void Update()
	{
		base.Update();

		var player = GameState.Current?.LocalPlayer;
		if (player == null)
			return;

		foreach (var rigidbody in player.GetComponentsInChildren<Rigidbody>())
		{
			if (rigidbody.detectCollisions == !Enabled)
				continue;

			rigidbody.detectCollisions = !Enabled;
		}
	}
}

```

`Features/NoFlash.cs`:

```cs
using EFT.Trainer.Properties;
using JetBrains.Annotations;

#nullable enable

namespace EFT.Trainer.Features;

[UsedImplicitly]
internal class NoFlash : ToggleFeature
{
	public override string Name => Strings.FeatureNoFlashName;
	public override string Description => Strings.FeatureNoFlashDescription;

	public override bool Enabled { get; set; } = false;

	protected override void UpdateWhenEnabled()
	{
		var camera = GameState.Current?.Camera;
		if (camera == null)
			return;

		if (camera.GetComponent<GrenadeFlashScreenEffect>() is { enabled: true } flash)
		{
			flash.enabled = false;
			flash.EffectStrength = 0;
		}

		if (camera.GetComponent<EyeBurn>() is { enabled: true } eyeburn)
		{
			eyeburn.enabled = false;
			eyeburn.EyesBurn = false;
		}
	}
}

```

`Features/NoMalfunctions.cs`:

```cs
using EFT.Trainer.Extensions;
using EFT.Trainer.Properties;
using JetBrains.Annotations;

#nullable enable

namespace EFT.Trainer.Features;

[UsedImplicitly]
internal class NoMalfunctions : ToggleFeature
{
	public override string Name => Strings.FeatureNoMalfunctionsName;
	public override string Description => Strings.FeatureNoMalfunctionsDescription;

	public override bool Enabled { get; set; } = false;

	protected override void UpdateWhenEnabled()
	{
		var player = GameState.Current?.LocalPlayer;
		if (!player.IsValid())
			return;

		if (player.HandsController is not Player.FirearmController controller)
			return;

		var template = controller.Item?.Template;
		if (template == null)
			return;

		template.AllowFeed = false;
		template.AllowJam = false;
		template.AllowMisfire = false;
		template.AllowOverheat = false;
		template.AllowSlide = false;
	}
}

```

`Features/NoRecoil.cs`:

```cs
using EFT.Trainer.Extensions;
using EFT.Trainer.Properties;
using JetBrains.Annotations;

#nullable enable

namespace EFT.Trainer.Features;

[UsedImplicitly]
internal class NoRecoil : ToggleFeature
{
	public override string Name => Strings.FeatureNoRecoilName;
	public override string Description => Strings.FeatureNoRecoilDescription;

	public override bool Enabled { get; set; } = false;

	protected override void UpdateWhenEnabled()
	{
		var player = GameState.Current?.LocalPlayer;
		if (!player.IsValid())
			return;

		if (player.ProceduralWeaponAnimation == null)
			return;

		var effect = player.ProceduralWeaponAnimation.Shootingg?.CurrentRecoilEffect;
		if (effect == null)
			return;

		effect.CameraRotationRecoilEffect.Intensity = 0f;
		effect.HandPositionRecoilEffect.Intensity = 0f;
		effect.HandRotationRecoilEffect.Intensity = 0f;
	}
}

```

`Features/NoSway.cs`:

```cs
using EFT.Trainer.Extensions;
using EFT.Trainer.Properties;
using JetBrains.Annotations;
using UnityEngine;

#nullable enable

namespace EFT.Trainer.Features;

[UsedImplicitly]
internal class NoSway : ToggleFeature
{
	public override string Name => Strings.FeatureNoSwayName;
	public override string Description => Strings.FeatureNoSwayDescription;

	public override bool Enabled { get; set; } = false;

	protected override void UpdateWhenEnabled()
	{
		var player = GameState.Current?.LocalPlayer;
		if (!player.IsValid())
			return;

		var weaponAnimation = player.ProceduralWeaponAnimation;
		if (weaponAnimation == null)
			return;

		var motionReact = weaponAnimation.MotionReact;
		motionReact.Intensity = 0f;
		motionReact.SwayFactors = Vector3.zero;
		motionReact.Velocity = Vector3.zero;

		weaponAnimation.Breath.Intensity = 0;
		weaponAnimation.Walk.Intensity = 0;
		weaponAnimation.Shootingg.AimingConfiguration_0.AimProceduralIntensity = 0;
		weaponAnimation.ForceReact.Intensity = 0;
		weaponAnimation.WalkEffectorEnabled = false;
	}
}

```

`Features/NoVisor.cs`:

```cs
using System;
using EFT.Trainer.Properties;
using JetBrains.Annotations;
using UnityEngine;

#nullable enable

namespace EFT.Trainer.Features;

[UsedImplicitly]
internal class NoVisor : ToggleFeature
{
	public override string Name => Strings.FeatureNoVisorName;
	public override string Description => Strings.FeatureNoVisorDescription;

	public override bool Enabled { get; set; } = false;

	protected override void Update()
	{
		base.Update();

		var camera = GameState.Current?.Camera;
		if (camera == null)
			return;

		var component = camera.GetComponent<VisorEffect>();
		if (component == null || Mathf.Abs(component.Intensity - Convert.ToInt32(!Enabled)) < Mathf.Epsilon)
			return;

		component.Intensity = Convert.ToInt32(!Enabled);
	}
}

```

`Features/Players.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using EFT.CameraControl;
using EFT.InventoryLogic;
using EFT.Trainer.Configuration;
using EFT.Trainer.Extensions;
using EFT.Trainer.Properties;
using EFT.Trainer.UI;
using JetBrains.Annotations;
using UnityEngine;
using UnityEngine.Rendering;

#nullable enable

namespace EFT.Trainer.Features;

public class PlayerColor(Color color, Color borderColor, Color infoColor) : IFeature
{
	[ConfigurationProperty(Order = 1)]
	public Color Color { get; set; } = color;

	[ConfigurationProperty(Order = 2)]
	public Color BorderColor { get; set; } = borderColor;

	[ConfigurationProperty(Order = 3)]
	public Color InfoColor { get; set; } = infoColor;

	public string Name => nameof(PlayerColor);
}

public class ShootableColor(Color color, Color borderColor) : IFeature
{
	[ConfigurationProperty(Order = 1)]
	public Color Color { get; set; } = color;

	[ConfigurationProperty(Order = 2)]
	public Color BorderColor { get; set; } = borderColor;

	public string Name => nameof(ShootableColor);
}

[UsedImplicitly]
internal class Players : ToggleFeature
{
	public override string Name => Strings.FeaturePlayersName;
	public override string Description => Strings.FeaturePlayersDescription;

	[ConfigurationProperty(Order = 10)]
	public PlayerColor BearColors { get; set; } = new(Color.blue, Color.red, Color.red);

	[ConfigurationProperty(Order = 10)]
	public PlayerColor UsecColors { get; set; } = new(Color.green, Color.red, Color.red);

	[ConfigurationProperty(Order = 10)]
	public PlayerColor ScavColors { get; set; } = new(Color.yellow, Color.red, Color.red);

	[ConfigurationProperty(Order = 10)]
	public PlayerColor BossColors { get; set; } = new(Color.red, Color.red, Color.red);

	[ConfigurationProperty(Order = 10)]
	public PlayerColor CultistColors { get; set; } = new(Color.yellow, Color.red, Color.red);

	[ConfigurationProperty(Order = 10)]
	public PlayerColor ScavRaiderColors { get; set; } = new(Color.yellow, Color.red, Color.red);

	[ConfigurationProperty(Order = 10)]
	public PlayerColor ScavAssaultColors { get; set; } = new(Color.yellow, Color.red, Color.red);

	[ConfigurationProperty(Order = 10)]
	public PlayerColor MarksmanColors { get; set; } = new(Color.yellow, Color.red, Color.red);

	[ConfigurationProperty(Order = 10)]
	public PlayerColor RogueUsecColors { get; set; } = new(Color.gray, Color.red, Color.red);

	[ConfigurationProperty(Order = 20)]
	public bool ShowBoxes { get; set; } = true;

	[ConfigurationProperty(Order = 21)]
	public float BoxThickness { get; set; } = 2f;

	[ConfigurationProperty(Order = 30)]
	public bool ShowCharms { get; set; } = true;

	[ConfigurationProperty(Order = 31)]
	public bool XRayVision { get; set; } = true;

	[ConfigurationProperty(Order = 40)]
	public bool ShowInfos { get; set; } = true;

	[ConfigurationProperty(Order = 50)]
	public bool ShowSkeletons { get; set; } = false;

	[ConfigurationProperty(Order = 51)]
	public float SkeletonThickness { get; set; } = 2;

	[ConfigurationProperty(Order = 60)]
	public bool ShowShootable { get; set; } = false;

	[ConfigurationProperty(Order = 61)]
	public ShootableColor ShootableColors { get; set; } = new(Color.green, Color.red);

	[ConfigurationProperty(Order = 62)]
	public bool ShowNotShootable { get; set; } = false;

	[ConfigurationProperty(Order = 63)]
	public ShootableColor NotShootableColors { get; set; } = new(Color.red, Color.blue);

	[ConfigurationProperty(Order = 19)]
	public float MaximumDistance { get; set; } = 0f;

	private static bool _lastXRayVision = true;
	private static bool _lastShowCharms = true;

	private static Camera? _opticCamera;
	private static (Vector2 center, float radius) _scopeParameters;

	[UsedImplicitly]
	protected void OnGUI()
	{
		var snapshot = GameState.Current;
		if (snapshot == null)
			return;

		if (snapshot.MapMode)
			return;

		var hostiles = snapshot.Hostiles;

		var player = snapshot.LocalPlayer;
		if (player == null)
			return;

		var camera = snapshot.Camera;
		if (camera == null)
			return;

		var cacheComponent = player.GetOrAddComponent<ShaderCache>();
		var cache = cacheComponent.Cache;

		if (!Enabled || XRayVision != _lastXRayVision || ShowCharms != _lastShowCharms)
		{
			_lastXRayVision = XRayVision;
			_lastShowCharms = ShowCharms;

			if (cache.Count > 0)
				ResetShaders(cache);

			return;
		}

		var isAiming = AimingCheck(camera, player);

		foreach (var ennemy in hostiles)
		{
			if (!ennemy.IsValid())
				continue;

			var playerColors = GetPlayerColors(ennemy);
			var borderColor = playerColors.BorderColor;

			if (ShowCharms)
				SetShaders(ennemy, GameState.OutlineShader, playerColors.Color, borderColor, cache);

			var position = ennemy.Transform.position;
			var screenPosition = isAiming ? ScopePointToScreenPoint(camera, position) : camera.WorldPointToVisibleScreenPoint(position);
			if (screenPosition == Vector2.zero)
				continue;

			var distance = Mathf.Round(Vector3.Distance(camera.transform.position, position));
			if (MaximumDistance > 0 && distance > MaximumDistance)
				continue;

			var playerBones = ennemy.PlayerBones;
			if (playerBones == null)
				continue;

			var headScreenPosition = isAiming
				? ScopePointToScreenPoint(camera, playerBones.Head.position)
				: camera.WorldPointToVisibleScreenPoint(playerBones.Head.position);
			var leftShoulderScreenPosition = isAiming
				? ScopePointToScreenPoint(camera, playerBones.LeftShoulder.position)
				: camera.WorldPointToVisibleScreenPoint(playerBones.LeftShoulder.position);

			if (headScreenPosition == Vector2.zero || leftShoulderScreenPosition == Vector2.zero)
				continue;

			if (ShowShootable)
			{
				var bonesToCheck = GetBonesToCheck(playerBones);
				borderColor = bonesToCheck.Any(bone => IsTransformVisibleCached(bone.transform, camera.IsTransformVisible))
					? ShootableColors.BorderColor
					: ShowNotShootable ? NotShootableColors.BorderColor : playerColors.BorderColor;

				if (ShowSkeletons)
				{
					foreach (var bone in bonesToCheck)
					{
						var bonesColor = IsTransformVisibleCached(bone.transform, camera.IsTransformVisible) ? ShootableColors.Color : ShowNotShootable ? NotShootableColors.Color : playerColors.Color;
						Bones.RenderBones(ennemy, bone.bones, SkeletonThickness, bonesColor, camera, isAiming);
					}

					var color = IsTransformVisibleCached(bonesToCheck[0].transform, camera.IsTransformVisible) ? ShootableColors.Color : ShowNotShootable ? NotShootableColors.Color : playerColors.Color;
					Bones.RenderHead(ennemy, SkeletonThickness, color, camera, isAiming);
					if (distance < 75f)
						Bones.RenderFingers(ennemy, SkeletonThickness, color, camera, isAiming);
				}

				ClearTransformCache();
			}
			else if (ShowSkeletons)
				Bones.RenderBones(ennemy, SkeletonThickness, playerColors.Color, camera, isAiming, distance);

			var heightOffset = Mathf.Abs(headScreenPosition.y - leftShoulderScreenPosition.y);

			var boxHeight = Mathf.Abs(headScreenPosition.y - screenPosition.y) + heightOffset * 3f;
			var boxWidth = boxHeight * 0.62f;

			var boxPositionX = screenPosition.x - boxWidth / 2f;
			var boxPositionY = headScreenPosition.y - heightOffset * 2f;

			if (ShowBoxes)
				Render.DrawBox(boxPositionX, boxPositionY, boxWidth, boxHeight, BoxThickness, borderColor);

			var ennemyHealthController = ennemy.HealthController;
			var ennemyHandController = ennemy.HandsController;

			if (!ShowInfos || ennemyHealthController is not { IsAlive: true })
				continue;

			var bodyPartHealth = ennemyHealthController.GetBodyPartHealth(EBodyPart.Common);
			var currentPlayerHealth = bodyPartHealth.Current;
			var maximumPlayerHealth = bodyPartHealth.Maximum;

			var weaponText = ennemyHandController != null && ennemyHandController.Item is Weapon weapon ? weapon.ShortName.Localized() : string.Empty;
			var distanceText = string.Format(Strings.FeaturePointOfInterestsDistanceFormat, distance);
			var infoText = string.Format(Strings.FeaturePlayersFormat, weaponText, Mathf.Round(currentPlayerHealth * 100 / maximumPlayerHealth), distanceText).Trim();

			Render.DrawString(new Vector2(boxPositionX, boxPositionY - 20f), infoText, playerColors.InfoColor, false);
		}
	}

	private static (Transform transform, string[] bones)[] GetBonesToCheck(PlayerBones playerBones)
	{
		return
		[
			(playerBones.Head.Original.transform, [Bones.Neck, Bones.Head]),
			(playerBones.Neck.transform, [Bones.RCollarbone, Bones.Spine3, Bones.LCollarbone, Bones.Spine3, Bones.Spine3, Bones.Neck]),
			(playerBones.Spine1.transform, [Bones.Pelvis, Bones.Spine1, Bones.Spine1, Bones.Spine2, Bones.Spine2, Bones.Spine3]),
			(playerBones.Upperarms[0].transform, [Bones.LCollarbone, Bones.LForearm1, Bones.LForearm1, Bones.LForearm2]),
			(playerBones.Upperarms[1].transform, [Bones.RCollarbone, Bones.RForearm1, Bones.RForearm1, Bones.RForearm2]),
			(playerBones.Forearms[0].transform, [Bones.LForearm2, Bones.LForearm3, Bones.LForearm3, Bones.LPalm]),
			(playerBones.Forearms[1].transform, [Bones.RForearm2, Bones.RForearm3, Bones.RForearm3, Bones.RPalm]),
			(playerBones.LeftThigh1.Original.transform, [Bones.Pelvis, Bones.LThigh1, Bones.LThigh1, Bones.LThigh2]),
			(playerBones.RightThigh1.Original.transform, [Bones.Pelvis, Bones.RThigh1, Bones.RThigh1, Bones.RThigh2]),
			(playerBones.LeftThigh2.Original.transform, [Bones.LThigh2, Bones.LCalf, Bones.LCalf, Bones.LFoot, Bones.LFoot, Bones.LToe]),
			(playerBones.RightThigh2.Original.transform, [Bones.RThigh2, Bones.RCalf, Bones.RCalf, Bones.RFoot, Bones.RFoot, Bones.RToe])
		];
	}

	private readonly Dictionary<Transform, bool> _cache = [];

	private bool IsTransformVisibleCached(Transform value, Func<Transform, bool> isVisibleFunc)
	{
		if (_cache.TryGetValue(value, out bool isVisible))
		{
			return isVisible;
		}

		isVisible = isVisibleFunc(value);
		_cache[value] = isVisible;
		return isVisible;
	}

	private void ClearTransformCache()
	{
		_cache.Clear();
	}

	private static bool AimingCheck(Camera camera, Player player)
	{
		var handsController = player.HandsController;
		if (handsController == null)
			return false;

		var weaponAnimation = player.ProceduralWeaponAnimation;
		if (weaponAnimation == null)
			return false;

		var aimingMod = weaponAnimation.CurrentAimingMod;
		if (aimingMod == null)
			return false;

		if (aimingMod.ScopesCount <= 0)
			return false;

		var zoom = aimingMod.GetCurrentOpticZoom();
		var isAiming = handsController.IsAiming;

		if (isAiming && zoom <= 1)
			isAiming = false;

		var currentOptic = weaponAnimation.HandsContainer.Weapon.GetComponentInChildren<OpticSight>();
		if (isAiming && currentOptic != null)
			GetScopeParameters(camera, currentOptic);

		if (_opticCamera != null)
			return isAiming;

		_opticCamera = Camera.allCameras.FirstOrDefault(c => c.name == "BaseOpticCamera(Clone)");

		return isAiming;
	}

	public PlayerColor GetPlayerColors(Player player)
	{
		var hostileType = player.GetHostileType();
		return GetPlayerColors(hostileType);
	}

	public PlayerColor GetPlayerColors(HostileType hostileType)
	{
		return hostileType switch
		{
			HostileType.Bear => BearColors,
			HostileType.Usec => UsecColors,
			HostileType.Scav => ScavColors,
			HostileType.Boss => BossColors,
			HostileType.Cultist => CultistColors,
			HostileType.ScavRaider => ScavRaiderColors,
			HostileType.ScavAssault => ScavAssaultColors,
			HostileType.Marksman => MarksmanColors,
			HostileType.RogueUsec => RogueUsecColors,
			_ => ScavColors,
		};
	}

	private void SetShaders(Player player, Shader? shader, Color color, Color borderColor, Dictionary<Renderer, Shader?> cache)
	{
		var playerBody = player.PlayerBody;
		if (playerBody == null)
			return;

		var skins = playerBody.BodySkins;
		if (skins == null)
			return;

		foreach (var skin in skins.Values)
		{
			if (skin == null)
				continue;

			foreach (var renderer in skin.GetRenderers())
			{
				if (renderer == null)
					continue;

				var material = renderer.material;
				if (material == null)
					continue;

				if (material.shader != null && material.shader == shader)
					continue;

				// disable custom occlusion/culling system, making the chams flickering or not rendering at all
				renderer.allowOcclusionWhenDynamic = false;
				renderer.forceRenderingOff = false;
				renderer.enabled = true;

				cache[renderer] = material.shader;
				material.shader = shader;

				material.SetColor(ShaderProperties.FirstOutlineColor, borderColor);
				material.SetFloat(ShaderProperties.FirstOutlineWidth, 0.02f);
				material.SetColor(ShaderProperties.SecondOutlineColor, color);
				material.SetFloat(ShaderProperties.SecondOutlineWidth, 0.0025f);
				material.SetFloat(ShaderProperties.ZTest, (float)(XRayVision ? CompareFunction.Always : CompareFunction.Less));
			}
		}
	}

	private static void ResetShaders(Dictionary<Renderer, Shader?> cache)
	{
		var hits = 0;
		foreach (var renderer in cache.Keys)
		{
			if (renderer == null)
				continue;

			if (renderer.material == null)
				continue;

			var shader = cache[renderer];
			if (renderer.material.shader == shader)
				continue;

			renderer.material.shader = shader;
			hits++;
		}

		if (hits == 0 && cache.Count > 0)
			cache.Clear();
	}

	public static Vector2 ScopePointToScreenPoint(Camera camera, Vector3 worldPoint, bool clamp = false)
	{
		if (_opticCamera == null || !GetCameraOffset(camera, out var scale, out var cameraOffset))
			return camera.WorldPointToScreenPoint(worldPoint);

		var scopePoint = (Vector2)_opticCamera.WorldToScreenPoint(worldPoint) + cameraOffset;
		scopePoint.y = Screen.height - scopePoint.y * scale;
		scopePoint.x *= scale;

		if (clamp)
			return ClampPointToScope(scopePoint);

		var distance = Vector2.Distance(_scopeParameters.center, scopePoint);
		if (distance <= _scopeParameters.radius)
			return scopePoint;

		return Vector2.zero;
	}

	private static bool GetCameraOffset(Camera camera, out float scale, out Vector2 cameraOffset)
	{
		scale = 0f;
		cameraOffset = Vector2.zero;

		if (_opticCamera == null)
			return false;

		scale = Screen.height / (float)camera.scaledPixelHeight;
		cameraOffset = new Vector2(
			camera.pixelWidth / 2 - _opticCamera.pixelWidth / 2,
			camera.pixelHeight / 2 - _opticCamera.pixelHeight / 2);

		return true;
	}
	private static Vector2 ClampPointToScope(Vector2 scopePoint)
	{
		var distance = Vector2.Distance(_scopeParameters.center, scopePoint);

		var clampedPoint = scopePoint;

		if (distance > _scopeParameters.radius)
		{
			var clampedVector = (scopePoint - _scopeParameters.center).normalized * _scopeParameters.radius;
			clampedPoint = _scopeParameters.center + clampedVector;
		}

		return clampedPoint;
	}

	private static void GetScopeParameters(Camera camera, OpticSight currentOptic)
	{
		var opticTransform = currentOptic.LensRenderer.transform;
		var lensMesh = currentOptic.LensRenderer.GetComponent<MeshFilter>().mesh;
		var lensUpperRight = opticTransform.TransformPoint(lensMesh.bounds.max);
		var lensUpperLeft = opticTransform.TransformPoint(new Vector3(lensMesh.bounds.min.x, 0, lensMesh.bounds.max.z));

		var lensUpperRight3D = camera.WorldPointToScreenPoint(lensUpperRight);
		var lensUpperLeft3D = camera.WorldPointToScreenPoint(lensUpperLeft);
		_scopeParameters.radius = Vector2.Distance(lensUpperRight3D, lensUpperLeft3D) / 2;
		_scopeParameters.center = camera.WorldPointToScreenPoint(opticTransform.position);
	}
}

```

`Features/PointOfInterest.cs`:

```cs
using UnityEngine;

#nullable enable

namespace EFT.Trainer.Features;

// We do not want to store camera-relative stuff here, given the player is moving.
// We'll need to re-compute the screen-position/distance/... when using OnGUI
internal struct PointOfInterest
{
	public string Name { get; set; }
	public string? Owner { get; set; }
	public Vector3 Position { get; set; }
	public Color Color { get; set; }
}

```

`Features/PointOfInterests.cs`:

```cs
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using EFT.Trainer.Configuration;
using EFT.Trainer.Extensions;
using EFT.Trainer.Properties;
using EFT.Trainer.UI;
using UnityEngine;

#nullable enable

namespace EFT.Trainer.Features;

internal abstract class PointOfInterests : CachableFeature<PointOfInterest>
{
	internal class ObjectPool<T>(Func<T> objectGenerator)
	{
		private readonly ConcurrentBag<T> _objects = [];

		public T Get() => _objects.TryTake(out var item) ? item : objectGenerator();

		public void Return(T item) => _objects.Add(item);
	}

	internal class PointOfInterestPool() : ObjectPool<PointOfInterest>(() => new PointOfInterest());

	public static PointOfInterestPool Pool = new();

	[ConfigurationProperty]
	public float MaximumDistance { get; set; } = 0f;

	public abstract Color GroupingColor { get; }

	protected override void BeforeRefreshData(IReadOnlyList<PointOfInterest> data)
	{
		// return all objects to the pool
		foreach (var poi in data)
			Pool.Return(poi);
	}

	public override void ProcessDataOnGUI(IReadOnlyList<PointOfInterest> data)
	{
		var snapshot = GameState.Current;
		if (snapshot == null)
			return;

		var camera = snapshot.MapMode ? snapshot.MapCamera : snapshot.Camera;
		if (camera == null)
			return;

		var cameraPosition = camera.transform.position;
		var poiPerPosition = data.ToLookup(poi => poi.Position);
		foreach (var positionGroup in poiPerPosition)
		{
			var position = positionGroup.Key;
			var screenPosition = camera.WorldPointToVisibleScreenPoint(position);
			if (screenPosition == Vector2.zero)
				continue;

			if (snapshot.MapMode)
				cameraPosition.y = position.y;

			var distance = Mathf.Round(Vector3.Distance(cameraPosition, position));
			if (MaximumDistance > 0 && distance > MaximumDistance)
				continue;

			var drawPosition = screenPosition;

			var poiPerOwner = positionGroup.ToLookup(poi => poi.Owner);
			foreach (var ownerGroup in poiPerOwner)
			{
				var distinctGroup = ownerGroup
					.DistinctBy(poi => poi.Name)
					.ToList();

				var owner = ownerGroup.Key;
				var flags = GetCaptionFlags.All;

				if (owner != null && distinctGroup.Count > 1)
				{
					flags = GetCaptionFlags.Name;
					var distanceText = string.Format(Strings.FeaturePointOfInterestsDistanceFormat, distance);
					drawPosition = new Vector2(drawPosition.x, drawPosition.y + Render.DrawString(drawPosition, string.Format(Strings.FeaturePointOfInterestsGroupFormat, owner, distanceText), GroupingColor, false).y);
				}

				foreach (var poi in distinctGroup)
				{
					drawPosition = new Vector2(drawPosition.x, drawPosition.y + Render.DrawString(drawPosition, GetCaption(poi, distance, flags), poi.Color, flags == GetCaptionFlags.All).y);
				}
			}
		}
	}

	[Flags]
	public enum GetCaptionFlags
	{
		Name = 1,
		Owner = 2,
		Distance = 4,
		All = Name | Owner | Distance
	}

	public virtual string GetCaption(PointOfInterest poi, double distance, GetCaptionFlags flags = GetCaptionFlags.All)
	{
		var nameText = string.Empty;
		var distanceText = string.Empty;
		var ownerText = string.Empty;

		if ((flags & GetCaptionFlags.Name) != 0)
			nameText = poi.Name;

		if (poi.Owner != null && (flags & GetCaptionFlags.Owner) != 0)
			ownerText = string.Format(Strings.FeaturePointOfInterestsOwnerFormat, poi.Owner);

		if ((flags & GetCaptionFlags.Distance) != 0)
			distanceText = string.Format(Strings.FeaturePointOfInterestsDistanceFormat, distance);

		return string
			.Format(Strings.FeaturePointOfInterestsFormat, nameText, ownerText, distanceText)
			.Replace("  ", " ")
			.Trim();
	}
}

```

`Features/Quests.cs`:

```cs
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using Comfort.Common;
using EFT.Counters;
using EFT.Interactive;
using EFT.Quests;
using EFT.Trainer.Configuration;
using EFT.Trainer.Extensions;
using EFT.Trainer.Properties;
using JetBrains.Annotations;
using UnityEngine;
using UnityEngine.SceneManagement;

#nullable enable

namespace EFT.Trainer.Features;

[UsedImplicitly]
internal class Quests : PointOfInterests
{
	public override string Name => Strings.FeatureQuestsName;
	public override string Description => Strings.FeatureQuestsDescription;

	[ConfigurationProperty]
	public Color Color { get; set; } = Color.magenta;

	public override float CacheTimeInSec { get; set; } = 5f;
	public override bool Enabled { get; set; } = false;
	public override Color GroupingColor => Color;

	private readonly ConcurrentDictionary<string, ExperienceTrigger[]> _experienceTriggerCache = [];
	private readonly ConcurrentDictionary<string, PlaceItemTrigger[]> _placeItemTriggerCache = [];
	private static bool _refreshLookupTables = true;

#pragma warning disable IDE0060
	[UsedImplicitly]
	protected static void OnConditionChangedHandlerPostfix(QuestClass conditional)
	{
		_refreshLookupTables = true;
	}
#pragma warning restore IDE0060

	public override void RefreshData(List<PointOfInterest> data)
	{
		var world = Singleton<GameWorld>.Instance;
		if (world == null)
			return;

		var player = GameState.Current?.LocalPlayer;
		if (!player.IsValid())
			return;

		var camera = GameState.Current?.Camera;
		if (camera == null)
			return;

		var profile = player.Profile;
		if (profile == null)
			return;

		var scene = SceneManager.GetActiveScene();
		if (!scene.isLoaded)
			return;

		var startedQuests = profile.QuestsData
			.Where(q => q.Status is EQuestStatus.Started && q.Template != null)
			.ToArray();

		if (!startedQuests.Any())
			return;

		if (_refreshLookupTables)
		{
			_experienceTriggerCache.Clear();
			_placeItemTriggerCache.Clear();

			_refreshLookupTables = false;
		}

		RefreshPlaceOrRepairItemLocations(scene, startedQuests, profile, data);
		RefreshVisitPlaceLocations(scene, startedQuests, profile, data);
		RefreshFindItemLocations(startedQuests, world, data);
	}

	private void RefreshVisitPlaceLocations(Scene scene, QuestDataClass[] startedQuests, Profile profile, List<PointOfInterest> records)
	{
		if (!_experienceTriggerCache.TryGetValue(scene.name, out var triggers))
		{
			triggers = FindObjectsOfType<ExperienceTrigger>();
			if (triggers.Length > 0)
				_experienceTriggerCache[scene.name] = triggers;
		}

		foreach (var quest in startedQuests)
		{
			var conditions = quest.Template!.Conditions[EQuestStatus.AvailableForFinish].OfType<ConditionCounterCreator>().ToArray();
			foreach (var condition in conditions)
			{
				if (quest.CompletedConditions.Contains(condition.id))
					continue;

				foreach (var cvp in condition.Conditions.OfType<ConditionVisitPlace>())
				{
					var trigger = triggers.FirstOrDefault(t => t.Id == cvp.target);
					if (trigger == null)
						continue;

					var visited = profile.Stats.Eft.OverallCounters.GetInt(CounterTag.TriggerVisited, trigger.Id) > 0;
					if (visited)
						continue;

					var position = trigger.transform.position;
					AddQuestRecord(records, condition, quest, position);
					break;
				}
			}
		}
	}

	private void RefreshFindItemLocations(QuestDataClass[] startedQuests, GameWorld world, List<PointOfInterest> records)
	{
		var lootItems = world.LootItems;

		for (var i = 0; i < lootItems.Count; i++)
		{
			var lootItem = lootItems.GetByIndex(i);
			if (!lootItem.IsValid())
				continue;

			if (!lootItem.Item.QuestItem)
				continue;

			foreach (var quest in startedQuests)
			{
				foreach (var condition in quest.Template!.Conditions[EQuestStatus.AvailableForFinish].OfType<ConditionFindItem>())
				{
					if (!condition.target.Contains(lootItem.Item.TemplateId.ToString()) || quest.CompletedConditions.Contains(condition.id))
						continue;

					var position = lootItem.transform.position;
					AddQuestRecord(records, condition, quest, position);
				}
			}
		}
	}

	private void RefreshPlaceOrRepairItemLocations(Scene scene, QuestDataClass[] startedQuests, Profile profile, List<PointOfInterest> records)
	{
		var allPlayerItems = profile
			.Inventory
			.GetPlayerItems()
			.ToArray();

		if (!_placeItemTriggerCache.TryGetValue(scene.name, out var triggers))
		{
			triggers = FindObjectsOfType<PlaceItemTrigger>();
			if (triggers.Length > 0)
				_placeItemTriggerCache[scene.name] = triggers;
		}

		foreach (var quest in startedQuests)
		{
			var conditions = quest.Template!.Conditions[EQuestStatus.AvailableForFinish].OfType<ConditionZone>().ToArray();
			foreach (var condition in conditions)
			{
				if (quest.CompletedConditions.Contains(condition.id))
					continue;

				var result = allPlayerItems.FirstOrDefault(x => condition.target.Contains(x.TemplateId.ToString()));
				if (result == null)
					continue;

				var trigger = triggers.FirstOrDefault(t => t.Id == condition.zoneId);
				if (trigger == null)
					continue;

				var position = trigger.transform.position;
				AddQuestRecord(records, condition, quest, position);
				break;
			}
		}
	}

	private void AddQuestRecord(List<PointOfInterest> records, Condition condition, QuestDataClass quest, Vector3 position)
	{
		var poi = Pool.Get();
		poi.Name = string.Format(Strings.FeatureQuestsFormat, condition.FormattedDescription, quest.Template!.Name);
		poi.Position = position;
		poi.Color = Color;
		poi.Owner = null;

		records.Add(poi);
	}

	protected override void UpdateWhenEnabled()
	{
		HarmonyPatchOnce(harmony =>
		{
			HarmonyPostfix(harmony, typeof(AbstractQuestControllerClass), nameof(AbstractQuestControllerClass.OnConditionChangedHandler), nameof(OnConditionChangedHandlerPostfix));
		});
	}
}

```

`Features/QuickThrow.cs`:

```cs
using System.Linq;
using EFT.InventoryLogic;
using EFT.Trainer.Extensions;
using EFT.Trainer.Properties;
using JetBrains.Annotations;
using UnityEngine;

#nullable enable

namespace EFT.Trainer.Features;

[UsedImplicitly]
internal class QuickTrow : TriggerFeature
{
	public override string Name => Strings.FeatureQuickTrowName;
	public override string Description => Strings.FeatureQuickTrowDescription;

	public override KeyCode Key { get; set; } = KeyCode.None;

	protected override void UpdateOnceWhenTriggered()
	{
		var player = GameState.Current?.LocalPlayer;
		if (!player.IsValid())
			return;

		var inventory = player
			.Profile
			.Inventory;

		var grenade = inventory
			.GetPlayerItems(EPlayerItems.Equipment)
			.OfType<ThrowWeapItemClass>()
			.FirstOrDefault();

		if (grenade == null)
			return;

		player.SetInHandsForQuickUse(grenade, null);
	}
}

```

`Features/Radar.cs`:

```cs
using EFT.Trainer.Configuration;
using EFT.Trainer.Properties;
using EFT.Trainer.UI;
using JetBrains.Annotations;
using UnityEngine;

#nullable enable

namespace EFT.Trainer.Features;

[UsedImplicitly]
internal class Radar : BaseMapToggleFeature
{
	public override string Name => Strings.FeatureRadarName;
	public override string Description => Strings.FeatureRadarDescription;

	public override bool Enabled { get; set; } = false;

	[ConfigurationProperty(Order = 10)]
	public float RadarPercentage { get; set; } = 10f;

	[ConfigurationProperty(Order = 20)]
	public float RadarRange { get; set; } = 100f;

	[ConfigurationProperty(Order = 30)]
	public Color RadarBackground { get; set; } = new(0f, 0f, 0f, 0.5f);

	[ConfigurationProperty(Order = 30)]
	public Color RadarCrosshair { get; set; } = new(1f, 1f, 1f, 0.5f);

	[ConfigurationProperty(Order = 100)]
	public bool ShowMap { get; set; } = false;

	[ConfigurationProperty(Order = 101)]
	public bool ShowCompass { get; set; } = false;

	private float ScreenPercentage => Mathf.Min(RadarPercentage / 100f, 1);
	private float RadarSize => Mathf.Sqrt(Screen.height * Screen.width * ScreenPercentage) / 2;
	private float RadarX => Screen.width - RadarSize;
	private float RadarY => Screen.height - RadarSize;

	protected override void OnGUIWhenEnabled()
	{
		if (RadarRange <= 0)
			return;

		var snapshot = GameState.Current;
		if (snapshot == null)
			return;

		if (snapshot.MapMode)
			return;

		var camera = snapshot.Camera;
		if (camera == null)
			return;

		var hostiles = snapshot.Hostiles;

		var radarX = RadarX;
		var radarY = RadarY;
		var radarSize = RadarSize;

		if (ShowMap)
		{
			SetupMapCamera(camera, radarX, Screen.currentResolution.height - radarY - radarSize, radarSize, radarSize);
			UpdateMapCamera(camera, RadarRange);

			if (MapCamera != null)
				DrawHostiles(MapCamera, hostiles, RadarRange);
		}
		else
		{
			ToggleMapCameraIfNeeded(false);
			DrawHostiles(camera, hostiles, RadarRange);
		}

		var forward = camera.transform.forward;
		var right = camera.transform.right;
		forward.y = 0;
		right.y = 0;

		var forwardHeading = GetHeadingAngle(forward);
		var rearHeading = GetHeadingAngle(-forward);
		var rightHeading = GetHeadingAngle(right);
		var leftHeading = GetHeadingAngle(-right);

		if (ShowCompass)
		{
			var radarTop = new Vector2(radarX + radarSize / 2, radarY + 12f);
			var radarLeft = new Vector2(radarX + 12f, radarY + radarSize / 2);
			var radarRight = new Vector2(radarX + radarSize - 12f, radarY + radarSize / 2);
			var radarBottom = new Vector2(radarX + radarSize / 2, radarY + radarSize - 12f);
			Render.DrawString(radarTop, forwardHeading, RadarCrosshair);
			Render.DrawString(radarLeft, leftHeading, RadarCrosshair);
			Render.DrawString(radarRight, rightHeading, RadarCrosshair);
			Render.DrawString(radarBottom, rearHeading, RadarCrosshair);
			Render.DrawPlayer(new Vector2(radarX + radarSize / 2, radarY + radarSize / 2), 10f, RadarCrosshair, 2f);
		}
		else
			Render.DrawCrosshair(new Vector2(radarX + radarSize / 2, radarY + radarSize / 2), radarSize / 2, RadarCrosshair, 2f);

		Render.DrawBox(radarX, radarY, radarSize, radarSize, 2f, RadarBackground);
	}

	protected override void UpdateWhenDisabled()
	{
		ToggleMapCameraIfNeeded(false);
	}

	protected override Vector2 GetTargetPosition(Vector3 playerPosition, Vector3 targetPosition, float playerEulerY)
	{
		if (MapCamera != null && MapCamera.enabled)
			return MapCamera.WorldToScreenPoint(targetPosition);

		float enemyY = playerPosition.x - targetPosition.x;
		float enemyX = playerPosition.z - targetPosition.z;
		float enemyAtan = Mathf.Atan2(enemyY, enemyX) * Mathf.Rad2Deg - 270 - playerEulerY;

		var enemyDistance = Vector3.Distance(playerPosition, targetPosition);

		float enemyMapX = enemyDistance * Mathf.Cos(enemyAtan * Mathf.Deg2Rad);
		float enemyMapY = enemyDistance * Mathf.Sin(enemyAtan * Mathf.Deg2Rad);

		var radarSize = RadarSize;
		var range = RadarRange;

		enemyMapX = enemyMapX * (radarSize / range) / 2f;
		enemyMapY = enemyMapY * (radarSize / range) / 2f;

		return new Vector2(RadarX + radarSize / 2f + enemyMapX, RadarY + radarSize / 2f + enemyMapY);
	}

	protected override void AdjustTargetPositionForRender(ref Vector2 position)
	{
		if (MapCamera != null && MapCamera.enabled)
			position.y = Screen.height - position.y;
	}
}

```

`Features/SceneDumper.cs`:

```cs
using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.SceneManagement;

#nullable enable

namespace EFT.Trainer.Features;

internal class SceneDumper
{
	[Serializable]
	public class NamedData
	{
		public string? Name;

		public override string ToString()
		{
			return Name ?? string.Empty;
		}
	}

	[Serializable]
	public class SceneData : NamedData
	{
		public List<GameObjectData> Roots;

		public SceneData()
		{
			Roots = [];
		}
	}

	[Serializable]
	public class GameObjectData : NamedData
	{
		public string? Tag;

		public List<GameObjectData> Childs;
		public List<ComponentData> Components;

		public GameObjectData()
		{
			Childs = [];
			Components = [];
		}
	}

	[Serializable]
	public class ComponentData
	{
		public string? Type;

		public override string ToString()
		{
			return Type ?? string.Empty;
		}
	}

	public static SceneData DumpScene(Scene scene)
	{
		var result = new SceneData { Name = scene.name };

		foreach (var root in scene.GetRootGameObjects())
		{
			if (root != null)
			{
				result.Roots.Add(DumpGameObject(root));
			}
		}

		return result;
	}

	public static GameObjectData DumpGameObject(GameObject root)
	{
		var result = new GameObjectData { Name = root.name, Tag = root.tag };

		foreach (Transform transform in root.transform)
		{
			if (transform != null && transform.gameObject != null)
			{
				result.Childs.Add(DumpGameObject(transform.gameObject));
			}
		}

		foreach (var component in root.GetComponents<Component>())
		{
			if (component != null)
			{
				result.Components.Add(DumpComponent(component));
			}
		}

		return result;
	}

	private static ComponentData DumpComponent(Component component)
	{
		return new() { Type = component.GetType().FullName };
	}
}

```

`Features/ShaderCache.cs`:

```cs
using System.Collections.Generic;
using JetBrains.Annotations;
using UnityEngine;

#nullable enable

namespace EFT.Trainer.Features;

internal class ShaderCache : MonoBehaviour
{
	public Dictionary<Renderer, Shader?> Cache { get; } = [];

	[UsedImplicitly]
	public void OnDestroy()
	{
		Cache.Clear();
	}
}

```

`Features/ShaderProperties.cs`:

```cs
using UnityEngine;

namespace EFT.Trainer.Features;

internal class ShaderProperties
{
	public static readonly int FirstOutlineColor = Shader.PropertyToID("_FirstOutlineColor");
	public static readonly int FirstOutlineWidth = Shader.PropertyToID("_FirstOutlineWidth");
	public static readonly int SecondOutlineColor = Shader.PropertyToID("_SecondOutlineColor");
	public static readonly int SecondOutlineWidth = Shader.PropertyToID("_SecondOutlineWidth");
	public static readonly int ZTest = Shader.PropertyToID("_ZTest");
}

```

`Features/Skills.cs`:

```cs
using EFT.Trainer.Extensions;
using EFT.Trainer.Properties;
using JetBrains.Annotations;
using UnityEngine;

#nullable enable

namespace EFT.Trainer.Features;

[UsedImplicitly]
internal class Skills : TriggerFeature
{
	public override string Name => Strings.FeatureSkillsName;
	public override string Description => Strings.FeatureSkillsDescription;

	public override KeyCode Key { get; set; } = KeyCode.None;

	protected override void UpdateOnceWhenTriggered()
	{
		var player = GameState.Current?.LocalPlayer;
		if (!player.IsValid())
			return;

		if (player.Skills?.Skills == null)
			return;

		foreach (var skill in player.Skills.DisplayList)
			skill.SetLevel(51);

		if (player.Skills.Mastering == null)
			return;

		foreach (var item in player.Skills.Mastering.Values)
			item.Current = item.MasteringGroup.Level2 + item.MasteringGroup.Level3;
	}
}

```

`Features/Speed.cs`:

```cs
using EFT.Trainer.Configuration;
using EFT.Trainer.Extensions;
using EFT.Trainer.Properties;
using JetBrains.Annotations;
using UnityEngine;

#nullable enable

namespace EFT.Trainer.Features;

[UsedImplicitly]
internal class Speed : HoldFeature
{
	public override string Name => Strings.FeatureSpeedName;
	public override string Description => Strings.FeatureSpeedDescription;

	public override KeyCode Key { get; set; } = KeyCode.None;

	[ConfigurationProperty]
	public float Intensity { get; set; } = 2.0f;

	protected override void UpdateWhenHold()
	{
		var player = GameState.Current?.LocalPlayer;
		if (!player.IsValid())
			return;

		var camera = GameState.Current?.Camera;
		if (camera == null)
			return;

		player.Transform.position += Intensity * Time.deltaTime * camera.transform.forward;
	}
}

```

`Features/Stamina.cs`:

```cs
using EFT.Trainer.Extensions;
using EFT.Trainer.Properties;
using JetBrains.Annotations;
using UnityEngine;

#nullable enable

namespace EFT.Trainer.Features;

[UsedImplicitly]
internal class Stamina : ToggleFeature
{
	public override string Name => Strings.FeatureStaminaName;
	public override string Description => Strings.FeatureStaminaDescription;

	public override bool Enabled { get; set; } = false;

	private float _aimDrainRate;
	private float _aimRangeFinderDrainRate;
	private float _sprintDrainRate;
	private float _jumpConsumption;
	private float _proneConsumption;

	private Vector3 _aimConsumptionByPose;
	private Vector3 _overweightConsumptionByPose;
	private Vector2 _crouchConsumption;
	private Vector2 _standupConsumption;
	private Vector2 _walkConsumption;

	private float _oxygenRestoration;
	private float _exhaustedMeleeSpeed;

	private float _baseRestorationRate;

	private bool _staminaExhaustionCausesJiggle;
	private bool _staminaExhaustionRocksCamera;
	private bool _staminaExhaustionStartsBreathSound;

	private bool _isConfigured = false;
	private bool _wasReset = true;

	[UsedImplicitly]
	protected static bool ConsumePrefix()
	{
		var feature = FeatureFactory.GetFeature<Stamina>();
		if (feature == null || !feature.Enabled)
			return true; // keep using original code, we are not enabled

		return false;  // skip the original code and all other prefix methods 
	}

	protected override void UpdateWhenEnabled()
	{
		var player = GameState.Current?.LocalPlayer;
		if (!player.IsValid())
			return;

		var playerPhysical = player.Physical;
		if (playerPhysical == null)
			return;

		HarmonyPatchOnce(harmony =>
		{
			var playerPhysicalStamina = playerPhysical.Stamina;
			if (playerPhysicalStamina == null)
				return;

			HarmonyPrefix(harmony, playerPhysicalStamina.GetType(), nameof(playerPhysicalStamina.Consume), nameof(ConsumePrefix));
		});

		var parameters = playerPhysical.StaminaParameters;
		if (parameters == null)
			return;

		if (!_isConfigured)
		{
			_aimDrainRate = parameters.AimDrainRate;
			_aimRangeFinderDrainRate = parameters.AimRangeFinderDrainRate;
			_sprintDrainRate = parameters.SprintDrainRate;
			_jumpConsumption = parameters.JumpConsumption;
			_proneConsumption = parameters.ProneConsumption;

			_aimConsumptionByPose = parameters.AimConsumptionByPose;
			_overweightConsumptionByPose = parameters.OverweightConsumptionByPose;

			_crouchConsumption = parameters.CrouchConsumption;
			_standupConsumption = parameters.StandupConsumption;
			_walkConsumption = parameters.WalkConsumption;

			_oxygenRestoration = parameters.OxygenRestoration;
			_exhaustedMeleeSpeed = parameters.ExhaustedMeleeSpeed;

			_baseRestorationRate = parameters.BaseRestorationRate;

			_staminaExhaustionCausesJiggle = parameters.StaminaExhaustionCausesJiggle;
			_staminaExhaustionRocksCamera = parameters.StaminaExhaustionRocksCamera;
			_staminaExhaustionStartsBreathSound = parameters.StaminaExhaustionStartsBreathSound;

			_isConfigured = true;
		}

		parameters.AimDrainRate = 0f;
		parameters.AimRangeFinderDrainRate = 0f;
		parameters.SprintDrainRate = 0f;
		parameters.JumpConsumption = 0f;
		parameters.ProneConsumption = 0f;

		parameters.AimConsumptionByPose = Vector3.zero;
		parameters.OverweightConsumptionByPose = Vector3.zero;

		parameters.CrouchConsumption = Vector2.zero;
		parameters.StandupConsumption = Vector2.zero;
		parameters.WalkConsumption = Vector2.zero;

		parameters.OxygenRestoration = 10000f;
		parameters.ExhaustedMeleeSpeed = 10000f;

		parameters.BaseRestorationRate = parameters.Capacity;

		parameters.StaminaExhaustionCausesJiggle = false;
		parameters.StaminaExhaustionRocksCamera = false;
		parameters.StaminaExhaustionStartsBreathSound = false;

		_wasReset = false; // Maintain variables in modified state
	}

	protected override void UpdateWhenDisabled()
	{
		var player = GameState.Current?.LocalPlayer;
		if (!player.IsValid())
			return;

		var playerPhysical = player.Physical;
		if (playerPhysical == null)
			return;

		var parameters = playerPhysical.StaminaParameters;
		if (parameters == null)
			return;

		if (_wasReset)
			return;

		parameters.AimDrainRate = _aimDrainRate;
		parameters.AimRangeFinderDrainRate = _aimRangeFinderDrainRate;
		parameters.SprintDrainRate = _sprintDrainRate;
		parameters.JumpConsumption = _jumpConsumption;
		parameters.ProneConsumption = _proneConsumption;

		parameters.AimConsumptionByPose = _aimConsumptionByPose;
		parameters.OverweightConsumptionByPose = _overweightConsumptionByPose;

		parameters.CrouchConsumption = _crouchConsumption;
		parameters.StandupConsumption = _standupConsumption;
		parameters.WalkConsumption = _walkConsumption;

		parameters.OxygenRestoration = _oxygenRestoration;
		parameters.ExhaustedMeleeSpeed = _exhaustedMeleeSpeed;

		parameters.BaseRestorationRate = _baseRestorationRate;

		parameters.StaminaExhaustionCausesJiggle = _staminaExhaustionCausesJiggle;
		parameters.StaminaExhaustionRocksCamera = _staminaExhaustionRocksCamera;
		parameters.StaminaExhaustionStartsBreathSound = _staminaExhaustionStartsBreathSound;

		_wasReset = true;
	}
}

```

`Features/TemplateHelper.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Comfort.Common;
using EFT.InventoryLogic;

#nullable enable

namespace EFT.Trainer.Features;

internal class TemplateHelper
{
	// We cannot properly search by "partial" mongoId, even if we have implicit conversion to string
	// So keep our own cache of templates
	private static readonly Dictionary<string, ItemTemplate> _templates = [];

	private static void UpdateTemplates()
	{
#if !EFT_LIVE
		if (!Singleton<ItemFactoryClass>.Instantiated)
			return;

		var mongoTemplates = Singleton<ItemFactoryClass>
			.Instance
			.ItemTemplates;

		if (_templates.Count == mongoTemplates.Count)
			return;

		foreach (var kv in mongoTemplates)
		{
			_templates.Add(kv.Key.ToString(), kv.Value);
		}
#endif
	}

	internal static ItemTemplate[] FindTemplates(string searchShortNameOrTemplateId)
	{
		UpdateTemplates();

		// Match by TemplateId
		if (_templates.TryGetValue(searchShortNameOrTemplateId, out var template))
		{
			return [template];
		}

		// Match by short name(s)
		return [.. _templates
			.Values
			.Where(t => t.ShortNameLocalizationKey.Localized().IndexOf(searchShortNameOrTemplateId, StringComparison.OrdinalIgnoreCase) >= 0
						|| t.NameLocalizationKey.Localized().IndexOf(searchShortNameOrTemplateId, StringComparison.OrdinalIgnoreCase) >= 0)];
	}
}

```

`Features/ThermalVision.cs`:

```cs
using EFT.InventoryLogic;
using EFT.Trainer.Extensions;
using EFT.Trainer.Properties;
using JetBrains.Annotations;
using UnityEngine;

#nullable enable

namespace EFT.Trainer.Features;

[UsedImplicitly]
internal class ThermalVision : ToggleFeature
{
	public override string Name => Strings.FeatureThermalVisionName;
	public override string Description => Strings.FeatureThermalVisionDescription;

	public override bool Enabled { get; set; } = false;

	protected override void Update()
	{
		base.Update();

		// Do not interact while in hideout or if the player is already wearing compatible equipment
		var player = GameState.Current?.LocalPlayer;
		if (player == null || player is HideoutPlayer || player.HasItemComponentInSlot<ThermalVisionComponent>(EquipmentSlot.Headwear))
			return;

		var camera = GameState.Current?.Camera;
		if (camera == null)
			return;

		var component = camera.GetComponent<global::ThermalVision>();
		if (component == null || component.On == Enabled)
			return;

		component.StartSwitch(Enabled);

		if (!Enabled)
			return;

		component.IsFpsStuck = false;
		component.IsGlitch = false;
		component.IsMotionBlurred = false;
		component.IsNoisy = false;
		component.IsPixelated = false;

		component.TextureMask.Color = new Color(0f, 0f, 0f, 0f);
		component.TextureMask.Stretch = false;
		component.TextureMask.Size = 0f;
	}
}

```

`Features/ToggleFeature.cs`:

```cs
using EFT.Trainer.Configuration;
using JetBrains.Annotations;
using UnityEngine;

#nullable enable

namespace EFT.Trainer.Features;

internal abstract class ToggleFeature : Feature
{
	[ConfigurationProperty(Order = 1)]
	public virtual bool Enabled { get; set; } = true;

	[ConfigurationProperty(Order = 2)]
	public virtual KeyCode Key { get; set; } = KeyCode.None;

	protected virtual void Update()
	{
		if (Key != KeyCode.None && Input.GetKeyUp(Key))
			Enabled = !Enabled;

		if (Enabled)
			UpdateWhenEnabled();

		if (!Enabled)
			UpdateWhenDisabled();
	}

	[UsedImplicitly]
	private void OnGUI()
	{
		if (Enabled)
			OnGUIWhenEnabled();
	}

	protected virtual void UpdateWhenEnabled() { }

	protected virtual void UpdateWhenDisabled() { }

	protected virtual void OnGUIWhenEnabled() { }
}

```

`Features/TrackedItem.cs`:

```cs
using EFT.Trainer.Configuration;
using JsonType;
using Newtonsoft.Json;
using UnityEngine;

#nullable enable

namespace EFT.Trainer.Features;

internal class TrackedItem(string name, Color? color = null, ELootRarity? rarity = null)
{
	public const string MatchAll = "*";
	public string Name { get; set; } = name;

	[JsonConverter(typeof(ColorConverter))]
	public Color? Color { get; set; } = color;

	public ELootRarity? Rarity { get; set; } = rarity;

	[JsonIgnore]
	public bool IsMatchAll => Name == MatchAll;
}

```

`Features/Train.cs`:

```cs
using System;
using EFT.MovingPlatforms;
using EFT.Trainer.Properties;
using JetBrains.Annotations;
using UnityEngine;

#nullable enable

namespace EFT.Trainer.Features;

[UsedImplicitly]
internal class Train : TriggerFeature
{
	public override string Name => Strings.FeatureTrainName;
	public override string Description => Strings.FeatureTrainDescription;

	public override KeyCode Key { get; set; } = KeyCode.None;

	protected override void UpdateOnceWhenTriggered()
	{
		var locomotive = FindObjectOfType<Locomotive>();
		if (locomotive == null)
			return;

		locomotive.Init(DateTime.UtcNow);
	}
}

```

`Features/TriggerFeature.cs`:

```cs
using EFT.Trainer.Configuration;
using JetBrains.Annotations;
using UnityEngine;

#nullable enable

namespace EFT.Trainer.Features;

internal abstract class TriggerFeature : Feature
{
	[ConfigurationProperty(Order = 2)]
	public virtual KeyCode Key { get; set; } = KeyCode.None;

	[UsedImplicitly]
	private void Update()
	{
		if (Key != KeyCode.None && Input.GetKeyUp(Key))
			UpdateOnceWhenTriggered();
	}

	protected virtual void UpdateOnceWhenTriggered() { }
}

```

`Features/WallShoot.cs`:

```cs
using System.Diagnostics.CodeAnalysis;
using EFT.Ballistics;
using EFT.Trainer.Extensions;
using EFT.Trainer.Properties;
using JetBrains.Annotations;
using UnityEngine;

#nullable enable

namespace EFT.Trainer.Features;

[UsedImplicitly]
internal class WallShoot : ToggleFeature
{
	public override string Name => Strings.FeatureWallShootName;
	public override string Description => Strings.FeatureFeatureWallShootDescription;

#pragma warning disable IDE0060
	[UsedImplicitly]
	[SuppressMessage("ReSharper", "InconsistentNaming")]
	protected static bool IsPenetratedPrefix(EftBulletClass shot, Vector3 hitPoint, BallisticCollider __instance, ref bool __result)
	{
		var feature = FeatureFactory.GetFeature<WallShoot>();
		if (feature == null || !feature.Enabled)
			return true; // keep using original code, we are not enabled

		var player = shot.Player.iPlayer;
		if (player is not { IsYourPlayer: true })
			return true; // keep using original code for other players

		__result = true;
		__instance.PenetrationChance = 1.0f;
		__instance.PenetrationLevel = 0.0f;
		__instance.RicochetChance = 0.0f;
		__instance.FragmentationChance = 0.0f;
		__instance.TrajectoryDeviationChance = 0.0f;
		__instance.TrajectoryDeviation = 0.0f;

		return false; // don't call the original code
	}
#pragma warning restore IDE0060

	protected override void UpdateWhenEnabled()
	{
		var player = GameState.Current?.LocalPlayer;
		if (!player.IsValid())
			return;

		HarmonyPatchOnce(harmony =>
		{
			HarmonyPrefix(harmony, typeof(BallisticCollider), nameof(BallisticCollider.IsPenetrated), nameof(IsPenetratedPrefix));
		});
	}
}

```

`Features/Weather.cs`:

```cs
using EFT.Trainer.Properties;
using EFT.Weather;
using JetBrains.Annotations;
using UnityEngine;

#nullable enable

namespace EFT.Trainer.Features;

[UsedImplicitly]
internal class Weather : TriggerFeature
{
	public override string Name => Strings.FeatureWeatherName;
	public override string Description => Strings.FeatureWeatherDescription;

	public override KeyCode Key { get; set; } = KeyCode.None;

	protected override void UpdateOnceWhenTriggered()
	{
		ToClearWeather();
	}

	public static void ToClearWeather(bool changeTime = true)
	{
		var weatherController = WeatherController.Instance;
		if (weatherController != null)
		{
			var weatherDebug = weatherController.WeatherDebug;
			weatherDebug.Enabled = true;
			weatherDebug.CloudDensity = -0.7f;
			weatherDebug.Fog = 0.004f;
			weatherDebug.LightningThunderProbability = 0f;
			weatherDebug.Rain = 0f;
		}

		if (!changeTime)
			return;

		var sky = TOD_Sky.Instance;
		if (sky == null)
			return;

		sky.Components.Time.GameDateTime = null;
		sky.Cycle.Hour = 12f;
	}
}

```

`Features/WorldInteractiveObjects.cs`:

```cs
using EFT.Interactive;
using EFT.Trainer.Extensions;
using EFT.Trainer.Properties;
using JetBrains.Annotations;
using UnityEngine;

#nullable enable

namespace EFT.Trainer.Features;

[UsedImplicitly]
internal class WorldInteractiveObjects : TriggerFeature
{
	public override string Name => Strings.FeatureWorldInteractiveObjectsName;
	public override string Description => Strings.FeatureWorldInteractiveObjectsDescription;

	public override KeyCode Key { get; set; } = KeyCode.KeypadPeriod;

	protected override void UpdateOnceWhenTriggered()
	{
		var player = GameState.Current?.LocalPlayer;
		if (!player.IsValid())
			return;

		var objects = LocationScene.GetAllObjects<WorldInteractiveObject>();
		foreach (var obj in objects)
		{
			if (!obj.IsValid())
				continue;

			if (obj.DoorState != EDoorState.Locked)
				continue;

			var offset = player.Transform.position - obj.transform.position;
			var sqrLen = offset.sqrMagnitude;

			// only unlock if near me, else you'll get a ban from BattlEye if you brute-force-unlock all objects
			if (sqrLen <= 20.0f)
				obj.DoorState = EDoorState.Shut;
		}
	}
}

```

`Files/FirstOutline.shader`:

```shader
//This version of the shader does not support shadows, but it does support transparent outlines

Shader "Outlined/UltimateOutline"
{
	Properties
	{
		_Color("Main Color", Color) = (0.5,0.5,0.5,1)
		_MainTex("Texture", 2D) = "white" {}

		_FirstOutlineColor("Outline color", Color) = (1,0,0,0.5)
		_FirstOutlineWidth("Outlines width", Range(0.0, 2.0)) = 0.15

		_SecondOutlineColor("Outline color", Color) = (0,0,1,1)
		_SecondOutlineWidth("Outlines width", Range(0.0, 2.0)) = 0.025

		_Angle("Switch shader on angle", Range(0.0, 180.0)) = 89
		
		[Enum(UnityEngine.Rendering.CompareFunction)] _ZTest("ZTest", Float) = 8 //"Always"
	}

		CGINCLUDE
#include "UnityCG.cginc"

			struct appdata {
			float4 vertex : POSITION;
			float4 normal : NORMAL;
		};

		uniform float4 _FirstOutlineColor;
		uniform float _FirstOutlineWidth;

		uniform float4 _SecondOutlineColor;
		uniform float _SecondOutlineWidth;

		uniform sampler2D _MainTex;
		uniform float4 _Color;
		uniform float _Angle;

		ENDCG

			SubShader{
			//First outline
			Pass{
				Tags{ "Queue" = "Transparent" "IgnoreProjector" = "True" "RenderType" = "Transparent" }
				Blend SrcAlpha OneMinusSrcAlpha
				ZWrite Off
				ZTest [_ZTest]
				Cull Back
				CGPROGRAM

				struct v2f {
					float4 pos : SV_POSITION;
				};

				#pragma vertex vert
				#pragma fragment frag

				v2f vert(appdata v) {
					appdata original = v;

					float3 scaleDir = normalize(v.vertex.xyz - float4(0,0,0,1));
					//This shader consists of 2 ways of generating outline that are dynamically switched based on demiliter angle
					//If vertex normal is pointed away from object origin then custom outline generation is used (based on scaling along the origin-vertex vector)
					//Otherwise the old-school normal vector scaling is used
					//This way prevents weird artifacts from being created when using either of the methods
					if (degrees(acos(dot(scaleDir.xyz, v.normal.xyz))) > _Angle) {
						v.vertex.xyz += normalize(v.normal.xyz) * _FirstOutlineWidth;
					}
	else {
	   v.vertex.xyz += scaleDir * _FirstOutlineWidth;
   }

   v2f o;
   o.pos = UnityObjectToClipPos(v.vertex);
   return o;
}

half4 frag(v2f i) : COLOR{
	return _FirstOutlineColor;
}

ENDCG
}


//Second outline
Pass{
	Tags{ "Queue" = "Transparent" "IgnoreProjector" = "True" "RenderType" = "Transparent" }
	Blend SrcAlpha OneMinusSrcAlpha
	ZWrite Off
	ZTest [_ZTest]
	Cull Back
	CGPROGRAM

	struct v2f {
		float4 pos : SV_POSITION;
	};

	#pragma vertex vert
	#pragma fragment frag

	v2f vert(appdata v) {
		appdata original = v;

		float3 scaleDir = normalize(v.vertex.xyz - float4(0,0,0,1));
		//This shader consists of 2 ways of generating outline that are dynamically switched based on demiliter angle
		//If vertex normal is pointed away from object origin then custom outline generation is used (based on scaling along the origin-vertex vector)
		//Otherwise the old-school normal vector scaling is used
		//This way prevents weird artifacts from being created when using either of the methods
		if (degrees(acos(dot(scaleDir.xyz, v.normal.xyz))) > _Angle) {
			v.vertex.xyz += normalize(v.normal.xyz) * _SecondOutlineWidth;
		}
	else {
		v.vertex.xyz += scaleDir * _SecondOutlineWidth;
	}

	v2f o;
	o.pos = UnityObjectToClipPos(v.vertex);
	return o;
	}

	half4 frag(v2f i) : COLOR{
		return _SecondOutlineColor;
	}

	ENDCG
}

//Surface shader
Tags{ "Queue" = "Transparent" }

CGPROGRAM
#pragma surface surf Lambert noshadow

struct Input {
	float2 uv_MainTex;
	float4 color : COLOR;
};

void surf(Input IN, inout SurfaceOutput  o) {
	fixed4 c = tex2D(_MainTex, IN.uv_MainTex) * _Color;
	o.Albedo = c.rgb;
	o.Alpha = c.a;
}
ENDCG
		}
			Fallback "Diffuse"
} 
```

`Files/Managed/NLog.dll.nlog`:

```nlog
<?xml version="1.0" encoding="utf-8" ?>
<nlog xmlns="http://www.nlog-project.org/schemas/NLog.xsd"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">

    <targets>
        <target name="EFTTarget" xsi:type="EFTTarget" />
    </targets>

</nlog>

```

`Installer/CompilationContext.cs`:

```cs
using System.IO.Compression;

namespace Installer;

internal class CompilationContext(Installation installation, string projectTitle, string project)
{
	internal const string DefaultBranch = "master";

	public int Try { get; set; } = 0;
	public Installation Installation { get; set; } = installation;
	public string ProjectTitle { get; set; } = projectTitle;
	public string Project { get; set; } = project;
	public string Branch { get; set; } = DefaultBranch;
	public string[] Exclude { get; set; } = [];
	public string[] Defines { get; set; } = [];
	public ZipArchive? Archive { get; set; }
	public bool IsFatalFailure { get; set; } = false;
	public string Language { get; set; } = "";
}

```

`Installer/CompilationResult.cs`:

```cs
using System.IO.Compression;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;

namespace Installer;

internal class CompilationResult(CSharpCompilation? compilation, ZipArchive? archive, Diagnostic[] errors, ResourceDescription[] resources)
{
	public CSharpCompilation? Compilation { get; } = compilation;
	public ZipArchive? Archive { get; } = archive;
	public Diagnostic[] Errors { get; } = errors;
	public ResourceDescription[] Resources { get; } = resources;

	public string[] ErrorFiles
	{
		get
		{
			return [.. Errors
				.Select(d => d.Location.SourceTree?.FilePath)
				.Where(s => s is not null)
				.OfType<string>()
				.Distinct()];
		}
	}
}

```

`Installer/Compiler.cs`:

```cs
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Resources;
using System.Resources.NetStandard;
using System.Text;
using System.Text.RegularExpressions;
using Installer.Properties;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Text;

namespace Installer;

internal partial class Compiler
{
	private ZipArchive ProjectArchive { get; }
	private Installation Installation { get; }
	private string ProjectContent { get; }

	private string[] Exclude { get; }
	private string[] Defines { get; }

	private static CSharpCompilationOptions CompilationOptions { get; } =
		new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary)
			.WithOverflowChecks(true)
			.WithOptimizationLevel(OptimizationLevel.Release);

	public Compiler(ZipArchive projectArchive, CompilationContext context)
	{
		ProjectArchive = projectArchive;
		Installation = context.Installation;
		Exclude = context.Exclude;
		Defines = context.Defines;
		ProjectContent = string.Empty;

		var entry = projectArchive.Entries.FirstOrDefault(e => e.Name == context.Project) ?? throw new ArgumentException($"Project {context.Project} not found!");
		using var stream = entry.Open();
		using var reader = new StreamReader(stream);
		ProjectContent = reader.ReadToEnd();
	}

	private IEnumerable<string> GetSourceFiles()
	{
		var matches = CompileFileRegex().Matches(ProjectContent);

		foreach (var match in matches.Cast<Match>())
		{
			if (!match.Success)
				continue;

			var file = match.Groups["file"].Value;
			if (!Exclude.Contains(file, StringComparer.OrdinalIgnoreCase))
				yield return file;
			else
			{
#if DEBUG
				Spectre.Console.AnsiConsole.MarkupLine($"[grey]>> Excluding {Spectre.Console.StringExtensions.EscapeMarkup(file)}.[/]");
#endif
			}
		}
	}

	private bool TryGetMetadataReference(string assemblyName, [NotNullWhen(true)] out MetadataReference? reference)
	{
		reference = null;

		if (TryGetAssemblyPath(assemblyName, out var path))
		{
			reference = MetadataReference.CreateFromFile(path);
#if DEBUG
			Spectre.Console.AnsiConsole.MarkupLine($"[grey]>> Resolved {assemblyName} to {Spectre.Console.StringExtensions.EscapeMarkup(path)}.[/]");
#endif
		}

		if (reference == null && TryGetAssemblyBytes(assemblyName, out var stream))
		{
#if DEBUG
			Spectre.Console.AnsiConsole.MarkupLine($"[grey]>> Using memory image for {assemblyName}.[/]");
#endif
			reference = MetadataReference.CreateFromImage(stream);
		}

		if (reference == null)
		{
#if DEBUG
			Spectre.Console.AnsiConsole.MarkupLine($"[grey]>> Unable to resolve {assemblyName}.[/]");
#endif
		}

		return reference != null;
	}

	private bool TryGetAssemblyPath(string assemblyName, out string path)
	{
		path = Path.Combine(Installation.Managed, $"{assemblyName}.dll");
		if (!File.Exists(path))
			path = Path.Combine(Installation.BepInExCore, $"{assemblyName}.dll");

		return File.Exists(path);
	}

	private static bool TryGetAssemblyBytes(string assemblyName, [NotNullWhen(true)] out byte[]? buffer)
	{
		try
		{
			buffer = Resources.ResourceManager.GetObject(assemblyName) as byte[];
		}
		catch
		{
			buffer = null;
		}
		return buffer != null;
	}

	private IEnumerable<MetadataReference> GetReferences()
	{
		yield return MetadataReference.CreateFromFile(Path.Combine(Installation.Managed, "mscorlib.dll"));

		var matches = ProjectReferenceRegex().Matches(ProjectContent);

		foreach (var match in matches.Cast<Match>())
		{
			if (!match.Success)
				continue;

			var assemblyName = match.Groups["assemblyName"].Value;
			// We expect project reference to be compiled first
			assemblyName = Path
				.GetFileName(assemblyName)
				.Replace(".csproj", string.Empty);

			if (TryGetMetadataReference(assemblyName, out var reference))
				yield return reference;
		}
	}

	private IEnumerable<SyntaxTree> GetSyntaxTrees()
	{
		var options = CSharpParseOptions
			.Default
			.WithLanguageVersion(LanguageVersion.Latest)
			.WithPreprocessorSymbols(Defines);

		foreach (var file in GetSourceFiles())
		{
			var entry = ProjectArchive.Entries.FirstOrDefault(e => e.FullName.EndsWith(file.Replace(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar), StringComparison.OrdinalIgnoreCase));
			if (entry == null)
				continue;

			using var stream = entry.Open();
			using var reader = new StreamReader(stream);

			var text = reader.ReadToEnd();
			var sourceText = SourceText.From(text, Encoding.UTF8);
			yield return SyntaxFactory.ParseSyntaxTree(sourceText, options, file);
		}
	}

	public bool IsLocalizationSupported()
	{
		return IsLanguageSupported(null);
	}

	public bool IsLanguageSupported(CompilationContext? context)
	{
		return GetSourceFiles().Any(f => f.EndsWith(string.Concat("Strings.", context?.Language ?? string.Empty, ".Designer.cs").Replace("..", "."), StringComparison.OrdinalIgnoreCase));
	}

	public IEnumerable<ResourceDescription> GetResources(CompilationContext context)
	{
		var matches = ResourceFileRegex().Matches(ProjectContent);

		foreach (var match in matches.Cast<Match>())
		{
			if (!match.Success)
				continue;

			// For now we only select one resource file, and use it as "neutral"
			var file = match.Groups["file"].Value;
			if (!file.EndsWith(string.Concat("Strings.", context.Language, ".resx").Replace("..", "."), StringComparison.OrdinalIgnoreCase))
				continue;

			var entry = ProjectArchive.Entries.FirstOrDefault(e => e.FullName.EndsWith(file.Replace(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar), StringComparison.OrdinalIgnoreCase));
			if (entry == null)
				continue;

			using var stream = entry.Open();
			using var reader = new ResXResourceReader(stream);

			using var memory = new MemoryStream();
			using var writer = new ResourceWriter(memory);

			foreach (DictionaryEntry resourcEntry in reader)
				writer.AddResource(resourcEntry.Key.ToString()!, resourcEntry.Value);

			var resource = new MemoryStream();

			writer.Generate();
			memory.Position = 0;
			memory.CopyTo(resource);
			resource.Position = 0;

			var resourceName = file
				.Replace(@"Properties\Strings", "EFT.Trainer.Properties.Strings")
				.Replace($".{context.Language}.", ".", StringComparison.OrdinalIgnoreCase)
				.Replace(".resx", ".resources");

			yield return new ResourceDescription(resourceName, () => resource, isPublic: true);
		}
	}

	public CSharpCompilation Compile(string assemblyName)
	{
		var syntaxTrees = GetSyntaxTrees()
			.ToArray();

		var references = GetReferences()
			.ToArray();

		return CSharpCompilation.Create(assemblyName, syntaxTrees, references, CompilationOptions);
	}

	[GeneratedRegex("<Compile\\s+Include=\"(?<file>.*)\"\\s*/?>")]
	private static partial Regex CompileFileRegex();

	[GeneratedRegex("<(Project)?Reference\\s+Include=\"(?<assemblyName>.*)\"\\s*/?>")]
	private static partial Regex ProjectReferenceRegex();

	[GeneratedRegex("<EmbeddedResource\\s+Include=\"(?<file>.*)\"\\s*/?>")]
	private static partial Regex ResourceFileRegex();
}

```

`Installer/ExitCode.cs`:

```cs
namespace Installer;

internal enum ExitCode
{
	Success = 0,
	NoInstallationFound = 1,
	CompilationFailed = 2,
	Canceled = 3,
	PluginCompilationFailed = 4,
	Failure = 6,

	CreateDllFailed = 10,
	CreateOutlineFailed = 11,
	CreateHarmonyDllFailed = 12,
	CreatePluginDllFailed = 13,

	RemoveDllFailed = 20,
	RemoveOutlineFailed = 21,
	RemoveHarmonyDllFailed = 22,
	RemovePluginDllFailed = 23,
}

```

`Installer/InstallCommand.cs`:

```cs
using System;
using System.ComponentModel;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Net.Security;
using System.Runtime.Versioning;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Xml;
using Installer.Properties;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Emit;
using Spectre.Console;
using Spectre.Console.Cli;

namespace Installer;

internal sealed class InstallCommand : AsyncCommand<InstallCommand.Settings>
{
	internal class Settings : CommandSettings
	{
		[Description("Path to EFT.")]
		[CommandArgument(0, "[path]")]
		public string? Path { get; set; }

		[Description("Use specific trainer branch version.")]
		[CommandOption("-b|--branch")]
		public string? Branch { get; set; }

		[Description("Disable feature.")]
		[CommandOption("-f|--feature")]
		public string[]? DisabledFeatures { get; set; }

		[Description("Disable command.")]
		[CommandOption("-c|--command")]
		public string[]? DisabledCommands { get; set; }

		[Description("Language.")]
		[CommandOption("-l|--language")]
		public string Language { get; set; } = "";
	}

	public static string[] ToSourceFile(string[]? names, string folder)
	{
		names ??= [];
		return [.. names.Select(f => $"{folder}\\{f}.cs")];
	}

	[SupportedOSPlatform("windows")]
	public override async Task<int> ExecuteAsync(CommandContext commandContext, Settings settings, CancellationToken ct)
	{
		try
		{
			AnsiConsole.MarkupLine("-=[[ [cyan]EscapeFromTarkov-Trainer Universal Installer[/] - [blue]https://github.com/sailro [/]]]=-");
			AnsiConsole.WriteLine();

			var installation = Installation.GetTargetInstallation(settings.Path, "Please select where to install the trainer");
			if (installation == null)
				return (int)ExitCode.NoInstallationFound;

			AnsiConsole.MarkupLine($"Target [green]EscapeFromTarkov ({installation.Version})[/] in [blue]{installation.Location.EscapeMarkup()}[/].");

			if (installation.UsingSpt)
			{
				AnsiConsole.MarkupLine("[green][[SPT]][/] detected. Please make sure you have run the game at least once before installing the trainer.");
				AnsiConsole.MarkupLine("SPT is patching binaries during the first run, and we [underline]need[/] to compile against those patched binaries.");
				AnsiConsole.MarkupLine("If you install this trainer on stock binaries, we'll be unable to compile or the game will freeze at the startup screen.");

				if (installation.UsingSptButNeverRun)
					AnsiConsole.MarkupLine("[yellow]Warning: it seems that you have never run your SPT installation. You should quit now and rerun this installer once it's done.[/]");

				if (!await AnsiConsole.ConfirmAsync("Continue installation (yes I have run the game at least once) ?", cancellationToken: ct))
					return (int)ExitCode.Canceled;
			}

			const string features = "Features";
			const string commands = "ConsoleCommands";

			settings.DisabledFeatures = ToSourceFile(settings.DisabledFeatures, features);
			settings.DisabledCommands = ToSourceFile(settings.DisabledCommands, commands);

			var result = await BuildTrainerAsync(settings, installation, features, commands);

			if (result.Compilation == null)
			{
				// Failure
				AnsiConsole.MarkupLine($"[red]Unable to compile trainer for version {installation.Version}. Please file an issue here : https://github.com/sailro/EscapeFromTarkov-Trainer/issues [/]");
				return (int)ExitCode.CompilationFailed;
			}

			if (!CreateDll(installation, "NLog.EFT.Trainer.dll", dllPath => result.Compilation.Emit(dllPath, manifestResources: result.Resources)))
				return (int)ExitCode.CreateDllFailed;

			if (!CreateDll(installation, "0Harmony.dll", dllPath => File.WriteAllBytes(dllPath, Resources._0Harmony), false))
				return (int)ExitCode.CreateHarmonyDllFailed;

			if (!CreateOutline(installation, result.Archive!))
				return (int)ExitCode.CreateOutlineFailed;

			const string bepInExPluginProject = "BepInExPlugin.csproj";
			if (installation.UsingBepInEx && result.Archive!.Entries.Any(e => e.Name == bepInExPluginProject))
			{
				AnsiConsole.MarkupLine("[green][[BepInEx]][/] detected. Creating plugin instead of using NLog configuration.");

				// reuse successful context for compiling.
				var pluginContext = new CompilationContext(installation, "plugin", bepInExPluginProject)
				{
					Archive = result.Archive,
					Branch = GetInitialBranch(settings)
				};
				var pluginResult = await GetCompilationAsync(pluginContext);

				if (pluginResult.Compilation == null)
				{
					AnsiConsole.MarkupLine($"[red]Unable to compile plugin for version {installation.Version}. Please file an issue here : https://github.com/sailro/EscapeFromTarkov-Trainer/issues [/]");
					return (int)ExitCode.PluginCompilationFailed;
				}

				if (!CreateDll(installation, Path.Combine(installation.BepInExPlugins, "spt-efttrainer.dll"), dllPath => pluginResult.Compilation.Emit(dllPath)))
					return (int)ExitCode.CreatePluginDllFailed;
			}
			else
			{
				var version = new Version(0, 13, 0, 21531);
				if (installation.Version >= version)
				{
					AnsiConsole.MarkupLine($"[yellow]Warning: EscapeFromTarkov {version} or later prevent this trainer to be loaded using NLog configuration.[/]");
					AnsiConsole.MarkupLine("[yellow]It is now mandatory to use SPT/BepInEx, or to find your own way to load the trainer. As is, it will not work.[/]");
				}

				CreateOrPatchConfiguration(installation);
			}

			TryCreateGameDocumentFolder();
		}
		catch (Exception ex)
		{
			AnsiConsole.MarkupLine($"[red]Error: {ex.Message.EscapeMarkup()}. Please file an issue here : https://github.com/sailro/EscapeFromTarkov-Trainer/issues [/]");
			return (int)ExitCode.Failure;
		}

		return (int)ExitCode.Success;
	}

	private static async Task<CompilationResult> BuildTrainerAsync(Settings settings, Installation installation, params string[] folders)
	{
		// Try first to compile against master
		var context = new CompilationContext(installation, "trainer", "NLog.EFT.Trainer.csproj")
		{
			Exclude = [.. settings.DisabledFeatures!, .. settings.DisabledCommands!],
			Branch = GetInitialBranch(settings),
			Defines = installation.UsingSpt ? [] : ["EFT_LIVE"],
			Language = settings.Language
		};

		var result = await GetCompilationAsync(context);
		if (context.IsFatalFailure)
			return result;

		if (result.Compilation == null)
		{
			// Failure, so try with a dedicated branch if exists
			var retryBranch = GetRetryBranch(installation, context);
			if (retryBranch != null)
			{
				context.Branch = retryBranch;
				result = await GetCompilationAsync(context);
			}
		}

		var files = result.ErrorFiles;
		if (!HasFaultingFeatureOrCommand(result, folders, files))
			return result;

		// Failure, retry by removing faulting features if possible
		AnsiConsole.MarkupLine($"[yellow]Trying to disable faulting feature/command: [red]{GetFaultingNames(files)}[/].[/]");

		context.Exclude = [.. files, .. settings.DisabledFeatures, .. settings.DisabledCommands];
		context.Branch = GetFallbackBranch(settings);

		result = await GetCompilationAsync(context);

		if (result.Errors.Length == 0)
			AnsiConsole.MarkupLine("[yellow]We found a fallback! But please file an issue here : https://github.com/sailro/EscapeFromTarkov-Trainer/issues [/]");

		return result;
	}

	private static bool HasFaultingFeatureOrCommand(CompilationResult result, string[] folders, string[] files)
	{
		return result.Compilation == null && files.Length != 0 && files.All(file => folders.Any(file.StartsWith));
	}

	private static string GetFaultingNames(string[] files)
	{
		return string.Join(", ", files
			.Select(Path.GetFileNameWithoutExtension)
			.Where(f => !f!.StartsWith("Base"))
			.Distinct()
			.OrderBy(f => f));
	}

	private static string GetDefaultBranch()
	{
		return CompilationContext.DefaultBranch;
	}

	private static string GetInitialBranch(Settings settings)
	{
		return settings.Branch ?? GetDefaultBranch();
	}

	private static string? GetRetryBranch(Installation installation, CompilationContext context)
	{
		var dedicated = "dev-" + installation.Version;
		return dedicated == context.Branch ? null : dedicated; // no need to reuse the same initial branch for a retry
	}

	private static string GetFallbackBranch(Settings settings)
	{
		return GetInitialBranch(settings);
	}

	private static void TryCreateGameDocumentFolder()
	{
		var folder = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments), "Escape from Tarkov");
		if (Directory.Exists(folder))
			return;

		try
		{
			Directory.CreateDirectory(folder);
			AnsiConsole.MarkupLine($"Created [blue]{folder.EscapeMarkup()}[/] folder.");
		}
		catch (Exception)
		{
			AnsiConsole.MarkupLine($"[yellow]Unable to create [blue]{folder.EscapeMarkup()}[/]. We need this folder to store our [green]trainer.ini[/] later.[/]");
		}
	}

	private static async Task<CompilationResult> GetCompilationAsync(CompilationContext context)
	{
		var errors = Array.Empty<Diagnostic>();
		ResourceDescription[] resources = [];

		var archive = context.Archive ?? await GetSnapshotAsync(context, context.Branch);
		if (archive == null)
		{
			context.Try++;
			return new(null, null, errors, resources);
		}

		CSharpCompilation? compilation = null;

		AnsiConsole
			.Status()
			.Start($"Compiling {context.ProjectTitle}", _ =>
			{
				var compiler = new Compiler(archive, context);
				compilation = compiler.Compile(Path.GetFileNameWithoutExtension(context.Project));
				errors = [.. compilation
					.GetDiagnostics()
					.Where(d => d.Severity == DiagnosticSeverity.Error)];

#if DEBUG
				foreach (var error in errors)
					AnsiConsole.MarkupLine($"[grey]>> {error.Id} [[{error.Location.SourceTree?.FilePath.EscapeMarkup()}]]: {error.GetMessage().EscapeMarkup()}.[/]");
#endif

				if (errors.Length != 0)
				{
					AnsiConsole.MarkupLine($">> [blue]Try #{context.Try}[/] [yellow]Compilation failed for {context.Branch.EscapeMarkup()} branch.[/]");
					compilation = null;
				}
				else
				{
					resources = [.. compiler.GetResources(context)];

					if (compiler.IsLocalizationSupported() && resources.Length == 0)
					{
						AnsiConsole.MarkupLine($"[yellow]Warning: no localization support for language '{context.Language.EscapeMarkup()}'.[/]");
						compilation = null;
						context.IsFatalFailure = true;
					}
					else
					{
						AnsiConsole.MarkupLine($">> [blue]Try #{context.Try}[/] Compilation [green]succeed[/] for [blue]{context.Branch.EscapeMarkup()}[/] branch.");
					}
				}
			});

		context.Try++;
		return new(compilation, archive, errors, resources);
	}

	private static async Task<ZipArchive?> GetSnapshotAsync(CompilationContext context, string branch)
	{
		var status = $"Downloading repository snapshot ({branch} branch)...";
		ZipArchive? result = null;

		try
		{
			await AnsiConsole
				.Status()
				.StartAsync(status, async statusContext =>
				{

					var handler = new HttpClientHandler
					{
						ServerCertificateCustomValidationCallback = (request, certificate, chain, errors) =>
						{
							if (errors == SslPolicyErrors.None)
								return true;

							context.IsFatalFailure = true;
							statusContext.Status = "!";
							statusContext.Refresh();

#if DEBUG
							AnsiConsole.MarkupLine($"[grey][[{errors}]] We found SSL issues.[/]");
							foreach (var chainStatus in chain?.ChainStatus ?? [])
								AnsiConsole.MarkupLine($"[grey][[{chainStatus.Status}]] {chainStatus.StatusInformation.EscapeMarkup()}[/]");
#endif

							AnsiConsole.MarkupLine($@"[yellow]Warning: We have detected a problem while retrieving the source code from {request.RequestUri?.ToString().EscapeMarkup()}[/]");
							AnsiConsole.MarkupLine(@"[yellow]Typically this is a user-side problem when something interferes with HTTPS/SSL: security or malicious software, antivirus, proxies, VPN, DNS, etc.[/]");

							if (certificate?.Subject == null)
								return true;

							AnsiConsole.MarkupLine(@$"[yellow]We got the following certificate [[{certificate.Subject.EscapeMarkup()}]] while expecting something from Github.[/]");
							AnsiConsole.MarkupLine(@"[yellow]Please try to temporarily disable any software preventing this installer from working properly.[/]");

							return true;
						}
					};

					using var client = new HttpClient(handler);
					var buffer = await client.GetByteArrayAsync(new Uri($"https://github.com/sailro/EscapeFromTarkov-Trainer/archive/refs/heads/{branch}.zip"));
					var stream = new MemoryStream(buffer);
					result = new ZipArchive(stream, ZipArchiveMode.Read);
				});
		}
		catch (Exception ex)
		{
			AnsiConsole.MarkupLine(ex is HttpRequestException { StatusCode: HttpStatusCode.NotFound } ? $">> [blue]Try #{context.Try}[/] [yellow]Branch {branch.EscapeMarkup()} not found.[/]" : $"[red]Error: {ex.Message.EscapeMarkup()}[/]");
		}

		return result;
	}

	private static void CreateOrPatchConfiguration(Installation installation)
	{
		const string targetName = "EFTTarget";
		var configPath = Path.Combine(installation.Managed, "NLog.dll.nlog");
		try
		{
			if (File.Exists(configPath))
			{
				var doc = new XmlDocument();
				doc.Load(configPath);

				var nlogNode = doc.DocumentElement;
				var targetsNode = nlogNode?.FirstChild;

				if (nlogNode is not { Name: "nlog" } || targetsNode is not { Name: "targets" })
				{
					AnsiConsole.MarkupLine($"[red]Unable to patch {configPath.EscapeMarkup()}, unexpected xml structure.[/]");
					return;
				}

				if (targetsNode.ChildNodes.Cast<XmlNode>().Any(targetNode => targetNode.Attributes?["name"]?.Value == targetName && targetNode.Attributes?["xsi:type"]?.Value == targetName))
				{
					AnsiConsole.MarkupLine($"Already patched [green]{Path.GetFileName(configPath).EscapeMarkup()}[/] in [blue]{Path.GetDirectoryName(configPath).EscapeMarkup()}[/].");
					return;
				}

				var entry = doc.CreateElement("target");
				var name = doc.CreateAttribute("name");
				name.Value = targetName;
				var type = doc.CreateAttribute("xsi", "type", "http://www.w3.org/2001/XMLSchema-instance");
				type.Value = targetName;
				entry.Attributes.Append(name);
				entry.Attributes.Append(type);
				targetsNode.AppendChild(entry);

				var builder = new StringBuilder();
				using var writer = new UTF8StringWriter(builder);
				doc.Save(writer);
				builder.Replace(" xmlns=\"\"", string.Empty);
				File.WriteAllText(configPath, builder.ToString());

				AnsiConsole.MarkupLine($"Patched [green]{Path.GetFileName(configPath).EscapeMarkup()}[/] in [blue]{Path.GetDirectoryName(configPath).EscapeMarkup()}[/].");
				return;
			}

			var content = $@"<?xml version=""1.0"" encoding=""utf-8"" ?>
<nlog xmlns=""http://www.nlog-project.org/schemas/NLog.xsd"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"">
  <targets>
    <target name=""{targetName}"" xsi:type=""{targetName}"" />
  </targets>
</nlog>";
			File.WriteAllText(configPath, content);
			AnsiConsole.MarkupLine($"Created [green]{Path.GetFileName(configPath).EscapeMarkup()}[/] in [blue]{Path.GetDirectoryName(configPath).EscapeMarkup()}[/].");
		}
		catch (Exception ex)
		{
			AnsiConsole.MarkupLine($"[red]Unable to patch or create {configPath.EscapeMarkup()}: {ex.Message.EscapeMarkup()}.[/]");
		}
	}

	private static bool CreateOutline(Installation installation, ZipArchive archive)
	{
		var outlinePath = Path.Combine(installation.Data, "outline");
		try
		{
			var entry = archive.Entries.FirstOrDefault(e => e.Name.Equals(Path.GetFileName(outlinePath), StringComparison.OrdinalIgnoreCase));
			if (entry == null)
			{
				AnsiConsole.MarkupLine("[red]Unable to find outline in the zip archive.[/]");
				return false;
			}

			using var input = entry.Open();
			using var output = File.Create(outlinePath);
			input.CopyTo(output);

			AnsiConsole.MarkupLine($"Created [green]{Path.GetFileName(outlinePath).EscapeMarkup()}[/] in [blue]{Path.GetDirectoryName(outlinePath).EscapeMarkup()}[/].");
			return true;
		}
		catch (Exception ex)
		{
			AnsiConsole.MarkupLine($"[red]Unable to create {outlinePath.EscapeMarkup()}: {ex.Message.EscapeMarkup()}.[/]");
			return false;
		}
	}

	private static bool CreateDll(Installation installation, string filename, Action<string> creator, bool overwrite = true)
	{
		return CreateDll(installation, filename, s =>
		{
			creator(s);
			return null;
		}, overwrite);
	}

	private static bool CreateDll(Installation installation, string filename, Func<string, EmitResult?> creator, bool overwrite = true)
	{
		var dllPath = Path.IsPathRooted(filename) ? filename : Path.Combine(installation.Managed, filename);
		var dllPathBepInExCore = Path.IsPathRooted(filename) ? null : Path.Combine(installation.BepInExCore, filename);

		try
		{
			// Check for prerequisites, already provided by BepInEx
			if (dllPathBepInExCore != null && File.Exists(dllPathBepInExCore))
				return true;

			if (!overwrite && File.Exists(dllPath))
				return true;

			var result = creator(dllPath);
			if (result != null)
			{
				var errors = result
					.Diagnostics
					.Where(d => d.Severity == DiagnosticSeverity.Error)
					.ToArray();

#if DEBUG
				foreach (var error in errors)
					AnsiConsole.MarkupLine($"[grey]>> {error.Id} [[{error.Location.SourceTree?.FilePath.EscapeMarkup()}]]: {error.GetMessage().EscapeMarkup()}.[/]");
#endif

				if (!result.Success)
					throw new Exception(errors.FirstOrDefault()?.GetMessage() ?? "Unknown error while emitting assembly");
			}

			AnsiConsole.MarkupLine($"Created [green]{Path.GetFileName(dllPath).EscapeMarkup()}[/] in [blue]{Path.GetDirectoryName(dllPath).EscapeMarkup()}[/].");
			return true;
		}
		catch (Exception ex)
		{
			AnsiConsole.MarkupLine($"[red]Unable to create {dllPath.EscapeMarkup()}: {ex.Message.EscapeMarkup()} [/]");
			return false;
		}
	}
}

```

`Installer/Installation.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Linq;
using System.Runtime.Versioning;
using System.Text;
using Spectre.Console;

namespace Installer;

internal class Installation
{
	public Version Version { get; }
	public bool UsingSpt { get; private set; }
	public bool UsingSptButNeverRun { get; private set; }
	public bool UsingBepInEx { get; private set; }
	public string Location { get; }
	public string DisplayString { get; private set; } = string.Empty;

	public string Data => Path.Combine(Location, "EscapeFromTarkov_Data");
	public string Managed => Path.Combine(Data, "Managed");
	public string BepInEx => Path.Combine(Location, "BepInEx");
	public string BepInExCore => Path.Combine(BepInEx, "core");
	public string BepInExPlugins => Path.Combine(BepInEx, "plugins");

	private Installation(string location, Version version)
	{
		if (string.IsNullOrEmpty(location))
			throw new ArgumentException("empty location");

		Location = location;
		Version = version;
	}

	public override bool Equals(object? obj)
	{
		if (obj is not Installation other)
			return false;

		return other.Location == Location;
	}

	public override int GetHashCode()
	{
		return Location.GetHashCode();
	}

	[SupportedOSPlatform("windows")]
	public static Installation? GetTargetInstallation(string? path, string promptTitle)
	{
		var installations = new List<Installation>();

		AnsiConsole
			.Status()
			.Start("Discovering [green]Escape From Tarkov[/] installations...", _ =>
			{
				installations = [.. DiscoverInstallations().Distinct()];

				if (path is not null && TryDiscoverInstallation(path, out var installation))
					installations.Add(installation);
			});

		installations = [.. installations.Distinct().OrderBy(i => i.Location)];

		switch (installations.Count)
		{
			case 0:
				AnsiConsole.MarkupLine("[yellow]No [green]EscapeFromTarkov[/] installation found, please re-run this installer, passing the installation path as argument.[/]");
				return null;
			case 1:
				var first = installations.First();
				return AnsiConsole.Confirm($"Continue with [green]EscapeFromTarkov ({first.Version})[/] in [blue]{first.Location.EscapeMarkup()}[/] ?") ? first : null;
			default:
				var prompt = new SelectionPrompt<Installation> { Title = promptTitle };
				prompt.AddChoices(installations);
				return AnsiConsole.Prompt(prompt);
		}
	}

	[SupportedOSPlatform("windows")]
	private static IEnumerable<Installation> DiscoverInstallations()
	{
		if (TryDiscoverInstallation(Environment.CurrentDirectory, out var installation))
			yield return installation;

		if (TryDiscoverInstallation(Path.GetDirectoryName(AppContext.BaseDirectory), out installation))
			yield return installation;

		// SPT default installation path
		if (TryDiscoverInstallation(Path.Combine(Path.GetPathRoot(Environment.GetFolderPath(Environment.SpecialFolder.System))!, "SPT"), out installation))
			yield return installation;

		// SPT locations from MUI cache
		foreach (var sptpath in Registry.GetSptInstallationsFromMuiCache())
		{
			if (string.IsNullOrEmpty(sptpath))
				continue;

			if (TryDiscoverInstallation(sptpath, out installation))
				yield return installation;

			// Newer SPT versions (>= 4.0) install in SPT subfolder, so check the parent too
			if (TryDiscoverInstallation(Path.Combine(sptpath, ".."), out installation))
				yield return installation;
		}

		if (!Registry.TryGetEscapeFromTarkovInstallationPath(out var path))
			yield break;

		if (TryDiscoverInstallation(path, out installation))
			yield return installation;

		var subFolders = Directory.EnumerateDirectories(Path.Combine(path, ".."));
		foreach (var folder in subFolders)
		{
			if (TryDiscoverInstallation(folder, out installation))
				yield return installation;
		}
	}

	private static bool TryDiscoverInstallation(string? path, [NotNullWhen(true)] out Installation? installation)
	{
		installation = null;

		try
		{
			if (string.IsNullOrEmpty(path))
				return false;

			path = Path.GetFullPath(path.Trim('\"'));
			var exe = Path.Combine(path, "EscapeFromTarkov.exe");
			if (!File.Exists(exe))
				return false;

			var vi = FileVersionInfo.GetVersionInfo(exe);
			if (vi.FileVersion == null)
				return false;

			installation = new Installation(path, new Version(vi.FileVersion));

			if (!Directory.Exists(installation.Managed))
				return false;

			// Starting with 4.0.0, folder layout changed
			installation.UsingSpt = Directory.Exists(Path.Combine(path, "SPT_Data")) || Directory.Exists(Path.Combine(path, "SPT", "SPT_Data"));


			var battleye = Path.Combine(path, "BattlEye");
			installation.UsingSptButNeverRun = installation.UsingSpt && Directory.Exists(battleye);

			installation.UsingBepInEx = Directory.Exists(installation.BepInExPlugins);

			installation.DisplayString = installation.ComputeDisplayString();

			return true;
		}
		catch (IOException)
		{
			return false;
		}
	}

	private string ComputeDisplayString()
	{
		var sb = new StringBuilder();
		sb.Append($"{Location.EscapeMarkup()} - [[{Version}]] ");
		sb.Append(UsingSpt ? "[b]SPT[/] " : "Vanilla ");

		if (UsingSpt && VersionChecker.IsVersionSupported(Version))
			sb.Append("[green](Supported)[/]");

		return sb.ToString();
	}

	public override string ToString()
	{
		return DisplayString;
	}
}

```

`Installer/Installer.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net9.0</TargetFramework>
    <LangVersion>latest</LangVersion>
    <Nullable>enable</Nullable>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
    <NeutralLanguage>en-US</NeutralLanguage>

    <PublishSingleFile>true</PublishSingleFile>
    <SelfContained>true</SelfContained>
    <PublishTrimmed>true</PublishTrimmed>
    <TrimMode>partial</TrimMode>	
    <EnableCompressionInSingleFile>true</EnableCompressionInSingleFile>
    <RuntimeIdentifier>win-x64</RuntimeIdentifier>
    <CETCompat>false</CETCompat> <!-- https://github.com/dotnet/runtime/issues/108589 -->
    <Authors>Sebastien Lebreton</Authors>
    <RepositoryUrl>https://github.com/sailro/EscapeFromTarkov-Trainer</RepositoryUrl>
    <Version>3.2.0.0</Version>
    <Copyright>Sebastien Lebreton</Copyright>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.CodeAnalysis.Analyzers" Version="4.14.0" PrivateAssets="all" />
    <PackageReference Include="Microsoft.CodeAnalysis.Common" Version="4.14.0" />
    <PackageReference Include="Microsoft.CodeAnalysis.CSharp" Version="4.14.0" />
    <PackageReference Include="Microsoft.Unity.Analyzers" Version="1.25.0" PrivateAssets="all" />
    <PackageReference Include="Microsoft.VisualStudio.Threading.Analyzers" Version="17.14.15" PrivateAssets="all" />
    <PackageReference Include="ResXResourceReader.NetStandard" Version="1.3.0" />
    <PackageReference Include="Spectre.Console.Cli" Version="0.53.0" />
    <PackageReference Include="System.Buffers" Version="4.6.1" />
    <PackageReference Include="System.Collections.Immutable" Version="9.0.10" />
    <PackageReference Include="System.IO.Compression" Version="4.3.0" />
    <PackageReference Include="System.Memory" Version="4.6.3" />
    <PackageReference Include="System.Numerics.Vectors" Version="4.6.1" />
    <PackageReference Include="System.Private.Uri" Version="4.3.2" />
    <PackageReference Include="System.Reflection.Metadata" Version="9.0.10" />
    <PackageReference Include="System.Resources.Writer" Version="4.3.0" />
    <PackageReference Include="System.Runtime.CompilerServices.Unsafe" Version="6.1.2" />
    <PackageReference Include="System.Text.Encoding.CodePages" Version="9.0.10" />
    <PackageReference Include="System.Threading.Tasks.Extensions" Version="4.6.3" />
  </ItemGroup>

  <ItemGroup>
    <None Include="Resources\0Harmony.dll" />
  </ItemGroup>

  <Target Name="Husky" BeforeTargets="Restore;CollectPackageReferences" Condition="'$(HUSKY)' != 0">
    <Exec Command="dotnet tool restore" StandardOutputImportance="Low" StandardErrorImportance="High" />
    <Exec Command="dotnet husky install" StandardOutputImportance="Low" StandardErrorImportance="High" WorkingDirectory=".." />
  </Target>

</Project>
```

`Installer/ParentProcessHelper.cs`:

```cs
using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace Installer;

[StructLayout(LayoutKind.Sequential), System.Diagnostics.CodeAnalysis.SuppressMessage("Style", "IDE1006")]
public partial struct ParentProcessHelper
{
	// These members must match PROCESS_BASIC_INFORMATION
	internal IntPtr Reserved1;
	internal IntPtr PebBaseAddress;
	internal IntPtr Reserved2_0;
	internal IntPtr Reserved2_1;
	internal IntPtr UniqueProcessId;
	internal IntPtr InheritedFromUniqueProcessId;

	[LibraryImport("ntdll.dll")]
	private static partial int NtQueryInformationProcess(IntPtr processHandle, int processInformationClass, ref ParentProcessHelper processInformation, int processInformationLength, out int returnLength);

	public static Process? GetParentProcess()
	{
		return GetParentProcess(Process.GetCurrentProcess().Handle);
	}

	public static Process? GetParentProcess(IntPtr handle)
	{
		var pp = new ParentProcessHelper();
		int status = NtQueryInformationProcess(handle, 0, ref pp, Marshal.SizeOf(pp), out _);
		if (status != 0)
			throw new Win32Exception(status);

		try
		{
			return Process.GetProcessById(pp.InheritedFromUniqueProcessId.ToInt32());
		}
		catch (ArgumentException)
		{
			// not found
			return null;
		}
	}
}

```

`Installer/Program.cs`:

```cs
using System;
using System.Runtime.Versioning;
using Spectre.Console.Cli;

namespace Installer;

internal class Program
{
	[SupportedOSPlatform("windows")]
	private static int Main(string[] args)
	{
		var app = new CommandApp<InstallCommand>();
		app.Configure(config =>
		{
			config
				.AddCommand<InstallCommand>("install")
				.WithDescription("Install the trainer");

			config
				.AddCommand<UninstallCommand>("uninstall")
				.WithDescription("Uninstall the trainer");
		});
		var result = app.Run(args);

		if (!StartedByExplorer())
			return result;

		Console.WriteLine();
		Console.WriteLine(@"Press a key to exit...");
		Console.ReadKey();

		return result;
	}

	[SupportedOSPlatform("windows")]
	private static bool StartedByExplorer()
	{
		try
		{
			var parent = ParentProcessHelper.GetParentProcess();
			return parent?.ProcessName.Equals("explorer", StringComparison.OrdinalIgnoreCase) ?? false;
		}
		catch (Exception)
		{
			return false;
		}
	}
}

```

`Installer/Properties/PublishProfiles/FolderProfile.pubxml`:

```pubxml
<?xml version="1.0" encoding="utf-8"?>
<!--
https://go.microsoft.com/fwlink/?LinkID=208121.
-->
<Project>
  <PropertyGroup>
    <Configuration>Release</Configuration>
    <Platform>Any CPU</Platform>
    <PublishDir>bin\Release\net9.0\win-x64\publish\</PublishDir>
    <PublishProtocol>FileSystem</PublishProtocol>
    <_TargetId>Folder</_TargetId>
  </PropertyGroup>
</Project>
```

`Installer/Properties/Resources.Designer.cs`:

```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Installer.Properties {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Installer.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Byte[].
        /// </summary>
        internal static byte[] _0Harmony {
            get {
                object obj = ResourceManager.GetObject("0Harmony", resourceCulture);
                return ((byte[])(obj));
            }
        }
    }
}

```

`Installer/Properties/Resources.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <assembly alias="System.Windows.Forms" name="System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />
  <data name="0Harmony" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\0Harmony.dll;System.Byte[], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
</root>
```

`Installer/Registry.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Linq;
using System.Runtime.Versioning;
using Microsoft.Win32;

namespace Installer
{
	[SupportedOSPlatform("windows")]
	internal class Registry
	{
		public static bool TryGetEscapeFromTarkovInstallationPath([NotNullWhen(true)] out string? installationPath)
		{
			installationPath = null;

			try
			{
				using var hive = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, RegistryView.Registry32);
				using var eft = hive.OpenSubKey(@"Software\Microsoft\Windows\CurrentVersion\Uninstall\EscapeFromTarkov", false);

				if (eft == null)
					return false;

				var exe = eft.GetValue("DisplayIcon") as string;
				if (string.IsNullOrEmpty(exe) || !File.Exists(exe))
					return false;

				var path = Path.GetDirectoryName(exe);
				if (string.IsNullOrEmpty(path) || !Directory.Exists(path))
					return false;

				installationPath = path;
				return true;
			}
			catch
			{
				return false;
			}
		}

		public static IEnumerable<string?> GetSptInstallationsFromMuiCache()
		{
			try
			{
				using var hive = RegistryKey.OpenBaseKey(RegistryHive.CurrentUser, RegistryView.Registry32);
				using var mui = hive.OpenSubKey(@"Software\Classes\Local Settings\Software\Microsoft\Windows\Shell\MuiCache", false);

				if (mui == null)
					return [];

				const string attribute = ".FriendlyAppName";
				string[] candidates = ["SPT.Launcher.exe", "SPT.Server.exe"];

				return mui
					.GetValueNames()
					.Where(v => candidates.Any(c => v.Contains($"{c}{attribute}", StringComparison.OrdinalIgnoreCase)))
					.Select(v => Path.GetDirectoryName(v.Replace(attribute, string.Empty)))
					.Distinct();
			}
			catch
			{
				return [];
			}
		}
	}
}

```

`Installer/UTF8StringWriter.cs`:

```cs
using System.Globalization;
using System.IO;
using System.Text;

namespace Installer;

internal sealed class UTF8StringWriter(StringBuilder stringBuilder) : StringWriter(stringBuilder, CultureInfo.InvariantCulture)
{
	public override Encoding Encoding => new UTF8Encoding();
}

```

`Installer/UninstallCommand.cs`:

```cs
using System;
using System.ComponentModel;
using System.IO;
using System.Linq;
using System.Runtime.Versioning;
using System.Text;
using System.Threading;
using System.Xml;
using Spectre.Console;
using Spectre.Console.Cli;

namespace Installer;

internal sealed class UninstallCommand : Command<UninstallCommand.Settings>
{
	internal class Settings : CommandSettings
	{
		[Description("Path to EFT.")]
		[CommandArgument(0, "[path]")]
		public string? Path { get; set; }
	}

	[SupportedOSPlatform("windows")]
	public override int Execute(CommandContext context, Settings settings, CancellationToken ct)
	{
		try
		{
			AnsiConsole.MarkupLine("-=[[ [cyan]EscapeFromTarkov-Trainer Universal Installer[/] - [blue]https://github.com/sailro [/]]]=-");
			AnsiConsole.WriteLine();

			var installation = Installation.GetTargetInstallation(settings.Path, "Please select from where to uninstall the trainer");
			if (installation == null)
				return (int)ExitCode.NoInstallationFound;

			AnsiConsole.MarkupLine($"Target [green]EscapeFromTarkov ({installation.Version})[/] in [blue]{installation.Location.EscapeMarkup()}[/].");

			if (!RemoveFile(Path.Combine(installation.Managed, "NLog.EFT.Trainer.dll")))
				return (int)ExitCode.RemoveDllFailed;

			// MonoMod.RuntimeDetour is a dependency used by the non-ilmerged 0Harmony.dll used by legacy spt. In this case we are not handling the removal
			if (!File.Exists(Path.Combine(installation.Managed, "MonoMod.RuntimeDetour.dll")))
			{
				if (!RemoveFile(Path.Combine(installation.Managed, "0Harmony.dll")))
					return (int)ExitCode.RemoveHarmonyDllFailed;
			}

			if (!RemoveFile(Path.Combine(installation.Data, "outline")))
				return (int)ExitCode.RemoveOutlineFailed;

			if (!RemoveFile(Path.Combine(installation.BepInExPlugins, "spt-efttrainer.dll")))
				return (int)ExitCode.RemovePluginDllFailed;

			RemoveOrPatchConfiguration(installation);
		}
		catch (Exception ex)
		{
			AnsiConsole.MarkupLine($"[red]Error: {ex.Message.EscapeMarkup()}. Please file an issue here : https://github.com/sailro/EscapeFromTarkov-Trainer/issues [/]");
			return (int)ExitCode.Failure;
		}

		return (int)ExitCode.Success;
	}

	private static bool RemoveFile(string filename)
	{
		try
		{
			if (!File.Exists(filename))
			{
				AnsiConsole.MarkupLine($"No [green]{Path.GetFileName(filename).EscapeMarkup()}[/] in [blue]{Path.GetDirectoryName(filename).EscapeMarkup()}[/].");
			}
			else
			{
				File.Delete(filename);
				AnsiConsole.MarkupLine($"Removed [green]{Path.GetFileName(filename).EscapeMarkup()}[/] in [blue]{Path.GetDirectoryName(filename).EscapeMarkup()}[/].");
			}

			return true;
		}
		catch (Exception ex)
		{
			AnsiConsole.MarkupLine($"[red]Unable to remove {filename.EscapeMarkup()}: {ex.Message.EscapeMarkup()} [/]");
			return false;
		}
	}

	private static void RemoveOrPatchConfiguration(Installation installation)
	{
		const string targetName = "EFTTarget";
		var configPath = Path.Combine(installation.Managed, "NLog.dll.nlog");
		try
		{
			if (!File.Exists(configPath))
			{
				// Only for display
				RemoveFile(configPath);
				return;
			}

			var doc = new XmlDocument();
			doc.Load(configPath);

			var nlogNode = doc.DocumentElement;
			var targetsNode = nlogNode?.FirstChild;

			if (nlogNode is not { Name: "nlog" } || targetsNode is not { Name: "targets" })
			{
				AnsiConsole.MarkupLine($"[red]Unable to unpatch {configPath.EscapeMarkup()}, unexpected xml structure.[/]");
				return;
			}

			var removeNodes = targetsNode
				.ChildNodes
				.Cast<XmlNode>()
				.Where(targetNode => targetNode.Attributes?["name"]?.Value == targetName && targetNode.Attributes?["xsi:type"]?.Value == targetName)
				.ToList();

			if (removeNodes.Count == 0)
			{
				AnsiConsole.MarkupLine($"Not patched [green]{Path.GetFileName(configPath).EscapeMarkup()}[/] in [blue]{Path.GetDirectoryName(configPath).EscapeMarkup()}[/].");
				return;
			}

			foreach (var target in removeNodes)
				targetsNode.RemoveChild(target);

			if (targetsNode.HasChildNodes)
			{
				var builder = new StringBuilder();
				using var writer = new UTF8StringWriter(builder);
				doc.Save(writer);
				builder.Replace(" xmlns=\"\"", string.Empty);
				File.WriteAllText(configPath, builder.ToString());

				AnsiConsole.MarkupLine($"Unpatched [green]{Path.GetFileName(configPath).EscapeMarkup()}[/] in [blue]{Path.GetDirectoryName(configPath).EscapeMarkup()}[/].");
			}
			else
			{
				RemoveFile(configPath);
			}
		}
		catch (Exception ex)
		{
			AnsiConsole.MarkupLine($"[red]Unable to unpatch or remove {configPath.EscapeMarkup()}: {ex.Message.EscapeMarkup()}.[/]");
		}
	}
}

```

`Installer/VersionChecker.cs`:

```cs
#pragma warning disable IDE0079

using System;
using System.Collections.Generic;
using System.Net.Http;
using System.Threading;
using System.Threading.Tasks;

namespace Installer;

internal class VersionChecker
{

	private static readonly Dictionary<Version, bool> _versions = [];
	private static readonly HttpClient _client = new();
	private static readonly SemaphoreSlim _semaphore = new(1, 1);

	public static async Task<bool> IsVersionSupportedAsync(Version version)
	{
		await _semaphore.WaitAsync();

		try
		{
			if (_versions.TryGetValue(version, out var supported))
				return supported;

			var branch = $"dev-{version}";
			var uri = new Uri($"https://github.com/sailro/EscapeFromTarkov-Trainer/tree/{branch}");
			var result = await _client.GetAsync(uri);
			_versions[version] = result.IsSuccessStatusCode;
		}
		catch (Exception e)
		{
#if DEBUG
			Spectre.Console.AnsiConsole.WriteException(e);
#endif
			_ = e;
			_versions[version] = false;
		}
		finally
		{
			_semaphore.Release();
		}

		return _versions[version];
	}

	public static bool IsVersionSupported(Version version)
	{
#pragma warning disable VSTHRD002
		return IsVersionSupportedAsync(version)
			.GetAwaiter()
			.GetResult();
#pragma warning restore VSTHRD002
	}
}

```

`KnownTemplateIds.cs`:

```cs
namespace EFT.Trainer;

public static class KnownTemplateIds
{
	//public const string MultiTool = "590c2e1186f77425357b6124";
	public const string BuriedBarrelCache = "5d6d2bb386f774785b07a77a";
	public const string GroundCache = "5d6d2b5486f774785c2ba8ea";
	//public const string Roubles = "5449016a4bdc2d6f028b456f";
	//public const string Euros = "569668774bdc2da2298b4568";
	//public const string Dollars = "5696686a4bdc2da3298b456a";
	public const string Pockets = "557ffd194bdc2d28148b457f";
	public const string DefaultInventory = "55d7217a4bdc2d86028b456d";
	public const string BossContainer = "5c0a794586f77461c458f892";

	public const string AirDropCommon = "6223349b3136504a544d1608";
	public const string AirDropMedical = "622334c873090231d904a9fc";
	public const string AirDropSupply = "622334fa3136504a544d160c";
	public const string AirDropWeapon = "6223351bb5d97a7b2c635ca7";

	public const string RedSignalFlare = "624c09cfbc2e27219346d955";

	public static string DefaultInventoryLocalizedShortName = ((MongoID)DefaultInventory).LocalizedShortName();
}

```

`LICENSE`:

```
MIT License

Copyright (c) 2020 Sebastien LEBRETON

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`Loader.cs`:

```cs
using EFT.Trainer.Features;
using UnityEngine;

#nullable enable

namespace EFT.Trainer;

public class Loader
{
	private static GameObject HookObject
	{
		get
		{
			var result = GameObject.Find("Application (Main Client)");
			if (result != null)
				return result;

			result = new GameObject(nameof(Loader));
			Object.DontDestroyOnLoad(result);
			return result;
		}
	}

	public static void Load()
	{
		FeatureFactory.RegisterAllFeatures(HookObject);
	}
}

```

`NLog.EFT.Trainer.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="14.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{F4EB56B6-F914-11E9-AAD5-362B9E155667}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>EFT.Trainer</RootNamespace>
    <AssemblyName>NLog.EFT.Trainer</AssemblyName>
    <TargetFrameworkVersion>v4.7.1</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <TargetFrameworkProfile />
    <LangVersion>latest</LangVersion>
    <Nullable>enable</Nullable>
    <EFTBasePath>C:\Battlestate Games\sptarkov</EFTBasePath>
    <EFTDataPath>$(EFTBasePath)\EscapeFromTarkov_Data</EFTDataPath>
    <EFTManagedPath>$(EFTDataPath)\Managed</EFTManagedPath>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>TRACE;DEBUG</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'DebugPerformance|AnyCPU'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\DebugPerformance\</OutputPath>
    <DefineConstants>TRACE;DEBUG;DEBUG_PERFORMANCE</DefineConstants>
    <DebugType>full</DebugType>
    <PlatformTarget>AnyCPU</PlatformTarget>
    <ErrorReport>prompt</ErrorReport>
  </PropertyGroup>
  <ItemGroup>
    <!-- Framework -->
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="netstandard">
      <HintPath>$(EFTManagedPath)\netstandard.dll</HintPath>
    </Reference>
    <!-- Game assemblies -->
    <Reference Include="Assembly-CSharp">
      <HintPath>$(EFTManagedPath)\Assembly-CSharp.dll</HintPath>
    </Reference>
    <Reference Include="bsg.console.core">
      <HintPath>$(EFTManagedPath)\bsg.console.core.dll</HintPath>
    </Reference>
    <Reference Include="Comfort">
      <HintPath>$(EFTManagedPath)\Comfort.dll</HintPath>
    </Reference>
    <Reference Include="Comfort.Unity">
      <HintPath>$(EFTManagedPath)\Comfort.Unity.dll</HintPath>
    </Reference>
    <Reference Include="ItemComponent.Types">
      <HintPath>$(EFTManagedPath)\ItemComponent.Types.dll</HintPath>
    </Reference>
    <Reference Include="Newtonsoft.Json">
      <HintPath>$(EFTManagedPath)\Newtonsoft.Json.dll</HintPath>
    </Reference>
    <Reference Include="ItemTemplate.Types">
      <HintPath>$(EFTManagedPath)\ItemTemplate.Types.dll</HintPath>
    </Reference>
    <Reference Include="DissonanceVoip">
      <HintPath>$(EFTManagedPath)\DissonanceVoip.dll</HintPath>
    </Reference>
    <Reference Include="Sirenix.Serialization">
      <HintPath>$(EFTManagedPath)\Sirenix.Serialization.dll</HintPath>
    </Reference>
    <Reference Include="CommonExtensions">
      <HintPath>$(EFTManagedPath)\CommonExtensions.dll</HintPath>
    </Reference>
    <!-- Unity -->
    <Reference Include="UnityEngine.AssetBundleModule">
      <HintPath>$(EFTManagedPath)\UnityEngine.AssetBundleModule.dll</HintPath>
    </Reference>
    <Reference Include="UnityEngine.CoreModule">
      <HintPath>$(EFTManagedPath)\UnityEngine.CoreModule.dll</HintPath>
    </Reference>
    <Reference Include="UnityEngine.IMGUIModule">
      <HintPath>$(EFTManagedPath)\UnityEngine.IMGUIModule.dll</HintPath>
    </Reference>
    <Reference Include="UnityEngine.PhysicsModule">
      <SpecificVersion>False</SpecificVersion>
      <HintPath>$(EFTManagedPath)\UnityEngine.PhysicsModule.dll</HintPath>
    </Reference>
    <Reference Include="UnityEngine.TextRenderingModule">
      <HintPath>$(EFTManagedPath)\UnityEngine.TextRenderingModule.dll</HintPath>
    </Reference>
    <!-- Optional -->
    <Reference Include="0Harmony">
      <HintPath>Installer\Resources\0Harmony.dll</HintPath>
    </Reference>
  </ItemGroup>
  <!-- Only to work with legacy installer regex parsing -->
  <ItemGroup Condition="Exists('$(EFTManagedPath)\UnityEngine.InputLegacyModule.dll')">
    <Reference Include="UnityEngine.InputLegacyModule">
      <HintPath>$(EFTManagedPath)\UnityEngine.InputLegacyModule.dll</HintPath>
    </Reference>
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Configuration\ColorConverter.cs" />
    <Compile Include="Configuration\ConfigurationManager.cs" />
    <Compile Include="Configuration\ConfigurationPropertyAttribute.cs" />
    <Compile Include="Configuration\EnumConverter.cs" />
    <Compile Include="Configuration\KeyCodeConverter.cs" />
    <Compile Include="Configuration\OrderedProperty.cs" />
    <Compile Include="Configuration\TrackedItemConverter.cs" />
    <Compile Include="ConsoleCommands\BaseListCommand.cs" />
    <Compile Include="ConsoleCommands\BaseTemplateCommand.cs" />
    <Compile Include="ConsoleCommands\BaseTrackCommand.cs" />
    <Compile Include="ConsoleCommands\BaseTrackListCommand.cs" />
    <Compile Include="ConsoleCommands\BuiltInCommand.cs" />
    <Compile Include="ConsoleCommands\ConsoleCommand.cs" />
    <Compile Include="ConsoleCommands\ConsoleCommandWithoutArgument.cs" />
    <Compile Include="ConsoleCommands\ConsoleCommandWithArgument.cs" />
    <Compile Include="ConsoleCommands\Dump.cs" />
    <Compile Include="ConsoleCommands\List.cs" />
    <Compile Include="ConsoleCommands\ListRare.cs" />
    <Compile Include="ConsoleCommands\ListSuperRare.cs" />
    <Compile Include="ConsoleCommands\LoadTrackList.cs" />
    <Compile Include="ConsoleCommands\SaveTrackList.cs" />
    <Compile Include="ConsoleCommands\SpawnHideoutItems.cs" />
    <Compile Include="ConsoleCommands\SpawnQuestItems.cs" />
    <Compile Include="ConsoleCommands\SpawnBot.cs" />
    <Compile Include="ConsoleCommands\Spawn.cs" />
    <Compile Include="ConsoleCommands\Status.cs" />
    <Compile Include="ConsoleCommands\Template.cs" />
    <Compile Include="ConsoleCommands\ToggleFeatureCommand.cs" />
    <Compile Include="ConsoleCommands\Track.cs" />
    <Compile Include="ConsoleCommands\TrackList.cs" />
    <Compile Include="ConsoleCommands\TrackRare.cs" />
    <Compile Include="ConsoleCommands\TrackSuperRare.cs" />
    <Compile Include="ConsoleCommands\UnTrack.cs" />
    <Compile Include="Context.cs" />
    <Compile Include="Extensions\CameraExtensions.cs" />
    <Compile Include="Extensions\ELootRarityExtensions.cs" />
    <Compile Include="Extensions\ExfiltrationPointExtensions.cs" />
    <Compile Include="Extensions\HostileType.cs" />
    <Compile Include="Extensions\ItemTemplateExtensions.cs" />
    <Compile Include="Extensions\ItemExtensions.cs" />
    <Compile Include="Extensions\LootItemExtensions.cs" />
    <Compile Include="Extensions\NotNullWhenAttribute.cs" />
    <Compile Include="Extensions\PlayerExtensions.cs" />
    <Compile Include="Extensions\StringExtensions.cs" />
    <Compile Include="Extensions\ThrowableExtensions.cs" />
    <Compile Include="Extensions\WorldInteractiveObjectExtensions.cs" />
    <Compile Include="Features\Aimbot.cs" />
    <Compile Include="Features\Ammunition.cs" />
    <Compile Include="Features\BaseMapToggleFeature.cs" />
    <Compile Include="Features\FeatureRenderer.cs" />
    <Compile Include="Features\FovChanger.cs" />
    <Compile Include="Features\Durability.cs" />
    <Compile Include="Features\Interact.cs" />
    <Compile Include="Features\AirDrop.cs" />
    <Compile Include="Features\NoMalfunctions.cs" />
    <Compile Include="Features\AutomaticGun.cs" />
    <Compile Include="Features\Bones.cs" />
    <Compile Include="Features\CachableFeature.cs" />
    <Compile Include="Features\Commands.cs" />
    <Compile Include="Features\CrossHair.cs" />
    <Compile Include="Features\ExfiltrationPoints.cs" />
    <Compile Include="Features\Feature.cs" />
    <Compile Include="Features\FeatureFactory.cs" />
    <Compile Include="Features\GameState.cs" />
    <Compile Include="Features\Grenades.cs" />
    <Compile Include="Features\FreeCamera.cs" />
    <Compile Include="Features\Examine.cs" />
    <Compile Include="Features\Hits.cs" />
    <Compile Include="Features\HoldFeature.cs" />
    <Compile Include="Features\Hud.cs" />
    <Compile Include="Features\LootItems.cs" />
    <Compile Include="Features\LootableContainers.cs" />
    <Compile Include="Features\NightVision.cs" />
    <Compile Include="Features\NoCollision.cs" />
    <Compile Include="Features\NoSway.cs" />
    <Compile Include="Features\NoRecoil.cs" />
    <Compile Include="Features\NoFlash.cs" />
    <Compile Include="Features\NoVisor.cs" />
    <Compile Include="Features\Players.cs" />
    <Compile Include="Features\PointOfInterest.cs" />
    <Compile Include="Features\PointOfInterests.cs" />
    <Compile Include="Features\Quests.cs" />
    <Compile Include="Features\Map.cs" />
    <Compile Include="Features\Radar.cs" />
    <Compile Include="Features\SceneDumper.cs" />
    <Compile Include="Features\ShaderCache.cs" />
    <Compile Include="Features\ShaderProperties.cs" />
    <Compile Include="Features\Speed.cs" />
    <Compile Include="Features\Health.cs" />
    <Compile Include="Features\Stamina.cs" />
    <Compile Include="Features\TemplateHelper.cs" />
    <Compile Include="Features\ThermalVision.cs" />
    <Compile Include="Features\ToggleFeature.cs" />
    <Compile Include="Features\TrackedItem.cs" />
    <Compile Include="Features\Mortar.cs" />
    <Compile Include="Features\TriggerFeature.cs" />
    <Compile Include="Features\Ghost.cs" />
    <Compile Include="Features\WallShoot.cs" />
    <Compile Include="Features\Skills.cs" />
    <Compile Include="Features\Train.cs" />
    <Compile Include="Features\Weather.cs" />
    <Compile Include="Features\QuickThrow.cs" />
    <Compile Include="Features\WorldInteractiveObjects.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="Properties\Strings.fr.Designer.cs">
      <DependentUpon>Strings.fr.resx</DependentUpon>
      <AutoGen>True</AutoGen>
      <DesignTime>True</DesignTime>
    </Compile>
    <Compile Include="Properties\Strings.Designer.cs">
      <AutoGen>True</AutoGen>
      <DesignTime>True</DesignTime>
      <DependentUpon>Strings.resx</DependentUpon>
    </Compile>
    <Compile Include="Properties\Strings.zh-cn.Designer.cs">
      <AutoGen>True</AutoGen>
      <DesignTime>True</DesignTime>
      <DependentUpon>Strings.zh-cn.resx</DependentUpon>
    </Compile>
    <Compile Include="Properties\Strings.jp.Designer.cs">
      <AutoGen>True</AutoGen>
      <DesignTime>True</DesignTime>
      <DependentUpon>Strings.jp.resx</DependentUpon>
    </Compile>
    <Compile Include="UI\Picker.cs" />
    <Compile Include="UI\EnumPicker.cs" />
    <Compile Include="UI\ColorPicker.cs" />
    <Compile Include="UI\ColorUtil.cs" />
    <Compile Include="UI\Render.cs" />
    <Compile Include="KnownTemplateIds.cs" />
    <Compile Include="Loader.cs" />
  </ItemGroup>
  <ItemGroup>
    <PackageReference Include="Microsoft.CodeAnalysis.Analyzers" Version="4.14.0" PrivateAssets="all" />
    <PackageReference Include="Microsoft.Unity.Analyzers" Version="1.25.0" PrivateAssets="all" />
  </ItemGroup>
  <ItemGroup>
    <EmbeddedResource Include="Properties\Strings.fr.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Strings.fr.Designer.cs</LastGenOutput>
      <SubType>Designer</SubType>
    </EmbeddedResource>
    <EmbeddedResource Include="Properties\Strings.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Strings.Designer.cs</LastGenOutput>
      <SubType>Designer</SubType>
    </EmbeddedResource>
    <EmbeddedResource Include="Properties\Strings.zh-cn.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Strings.zh-cn.Designer.cs</LastGenOutput>
    </EmbeddedResource>
    <EmbeddedResource Include="Properties\Strings.jp.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Strings.jp.Designer.cs</LastGenOutput>
    </EmbeddedResource>
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <PropertyGroup>
    <PostBuildEvent>copy /Y "$(TargetPath)" "$(EFTManagedPath)"</PostBuildEvent>
  </PropertyGroup>
</Project>
```

`Properties/AssemblyInfo.cs`:

```cs
using System.Reflection;

[assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyProduct("EFT Trainer")]
[assembly: AssemblyCopyright("Copyright © 2024 Sebastien Lebreton")]

```

`Properties/Strings.Designer.cs`:

```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace EFT.Trainer.Properties {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Strings {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Strings() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("EFT.Trainer.Properties.Strings", typeof(Strings).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to dump.
        /// </summary>
        internal static string CommandDump {
            get {
                return ResourceManager.GetString("CommandDump", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Dumping game objects....
        /// </summary>
        internal static string CommandDumpGameObjects {
            get {
                return ResourceManager.GetString("CommandDumpGameObjects", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Dumping Scenes....
        /// </summary>
        internal static string CommandDumpScenes {
            get {
                return ResourceManager.GetString("CommandDumpScenes", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Dump created in {0}.
        /// </summary>
        internal static string CommandDumpSuccessFormat {
            get {
                return ResourceManager.GetString("CommandDumpSuccessFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to list.
        /// </summary>
        internal static string CommandList {
            get {
                return ResourceManager.GetString("CommandList", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {0} [{1}] {2}.
        /// </summary>
        internal static string CommandListEnumerateFormat {
            get {
                return ResourceManager.GetString("CommandListEnumerateFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to listr.
        /// </summary>
        internal static string CommandListRare {
            get {
                return ResourceManager.GetString("CommandListRare", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to ({0}).
        /// </summary>
        internal static string CommandListRarityFormat {
            get {
                return ResourceManager.GetString("CommandListRarityFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Found {0} item(s).
        /// </summary>
        internal static string CommandListSuccessFormat {
            get {
                return ResourceManager.GetString("CommandListSuccessFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to listsr.
        /// </summary>
        internal static string CommandListSuperRare {
            get {
                return ResourceManager.GetString("CommandListSuperRare", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Load settings.
        /// </summary>
        internal static string CommandLoadDescription {
            get {
                return ResourceManager.GetString("CommandLoadDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to load.
        /// </summary>
        internal static string CommandLoadName {
            get {
                return ResourceManager.GetString("CommandLoadName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Loaded {0}.
        /// </summary>
        internal static string CommandLoadSuccessFormat {
            get {
                return ResourceManager.GetString("CommandLoadSuccessFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to loadtl.
        /// </summary>
        internal static string CommandLoadTrackList {
            get {
                return ResourceManager.GetString("CommandLoadTrackList", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Save settings.
        /// </summary>
        internal static string CommandSaveDescription {
            get {
                return ResourceManager.GetString("CommandSaveDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Be careful when updating this file :)
        ///For keys, use https://docs.unity3d.com/ScriptReference/KeyCode.html
        ///Colors are stored as an array of &apos;RGBA&apos; floats.
        /// </summary>
        internal static string CommandSaveHeader {
            get {
                return ResourceManager.GetString("CommandSaveHeader", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to save.
        /// </summary>
        internal static string CommandSaveName {
            get {
                return ResourceManager.GetString("CommandSaveName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Saved {0}.
        /// </summary>
        internal static string CommandSaveSuccessFormat {
            get {
                return ResourceManager.GetString("CommandSaveSuccessFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to savetl.
        /// </summary>
        internal static string CommandSaveTrackList {
            get {
                return ResourceManager.GetString("CommandSaveTrackList", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to spawn.
        /// </summary>
        internal static string CommandSpawn {
            get {
                return ResourceManager.GetString("CommandSpawn", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to spawnbot.
        /// </summary>
        internal static string CommandSpawnBot {
            get {
                return ResourceManager.GetString("CommandSpawnBot", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {0}.
        /// </summary>
        internal static string CommandSpawnBotEnumerateFormat {
            get {
                return ResourceManager.GetString("CommandSpawnBotEnumerateFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to spawnhi.
        /// </summary>
        internal static string CommandSpawnHideoutItems {
            get {
                return ResourceManager.GetString("CommandSpawnHideoutItems", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to spawnqi.
        /// </summary>
        internal static string CommandSpawnQuestItems {
            get {
                return ResourceManager.GetString("CommandSpawnQuestItems", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to status.
        /// </summary>
        internal static string CommandStatus {
            get {
                return ResourceManager.GetString("CommandStatus", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {0} is {1} {2}.
        /// </summary>
        internal static string CommandStatusTextFormat {
            get {
                return ResourceManager.GetString("CommandStatusTextFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to ({0} to toggle).
        /// </summary>
        internal static string CommandStatusTextToggleFormat {
            get {
                return ResourceManager.GetString("CommandStatusTextToggleFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to template.
        /// </summary>
        internal static string CommandTemplate {
            get {
                return ResourceManager.GetString("CommandTemplate", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {0}: {1} [{2}].
        /// </summary>
        internal static string CommandTemplateEnumerateFormat {
            get {
                return ResourceManager.GetString("CommandTemplateEnumerateFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Found {0} template(s).
        /// </summary>
        internal static string CommandTemplateSuccessFormat {
            get {
                return ResourceManager.GetString("CommandTemplateSuccessFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to track.
        /// </summary>
        internal static string CommandTrack {
            get {
                return ResourceManager.GetString("CommandTrack", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to tracklist.
        /// </summary>
        internal static string CommandTrackList {
            get {
                return ResourceManager.GetString("CommandTrackList", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Tracking: {0} {1}.
        /// </summary>
        internal static string CommandTrackListEnumerateFormat {
            get {
                return ResourceManager.GetString("CommandTrackListEnumerateFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to ({0}).
        /// </summary>
        internal static string CommandTrackListRarityFormat {
            get {
                return ResourceManager.GetString("CommandTrackListRarityFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Tracking list updated....
        /// </summary>
        internal static string CommandTrackListUpdated {
            get {
                return ResourceManager.GetString("CommandTrackListUpdated", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Tracking: {0} (Wishlist).
        /// </summary>
        internal static string CommandTrackListWishListEnumerateFormat {
            get {
                return ResourceManager.GetString("CommandTrackListWishListEnumerateFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to trackr.
        /// </summary>
        internal static string CommandTrackRare {
            get {
                return ResourceManager.GetString("CommandTrackRare", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to tracksr.
        /// </summary>
        internal static string CommandTrackSuperRare {
            get {
                return ResourceManager.GetString("CommandTrackSuperRare", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to untrack.
        /// </summary>
        internal static string CommandUnTrack {
            get {
                return ResourceManager.GetString("CommandUnTrack", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Patched {0} with {1}.
        /// </summary>
        internal static string DebugPatchedMethodFormat {
            get {
                return ResourceManager.GetString("DebugPatchedMethodFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Refreshed {0} in {1}ms.
        /// </summary>
        internal static string DebugPerformanceRefreshedFormat {
            get {
                return ResourceManager.GetString("DebugPerformanceRefreshedFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Registering {0} command....
        /// </summary>
        internal static string DebugRegisteringCommandFormat {
            get {
                return ResourceManager.GetString("DebugRegisteringCommandFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Registering {0} command with arguments....
        /// </summary>
        internal static string DebugRegisteringCommandWithArgumentsFormat {
            get {
                return ResourceManager.GetString("DebugRegisteringCommandWithArgumentsFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to E.
        /// </summary>
        internal static string DirectionEast {
            get {
                return ResourceManager.GetString("DirectionEast", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to N.
        /// </summary>
        internal static string DirectionNorth {
            get {
                return ResourceManager.GetString("DirectionNorth", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to NE.
        /// </summary>
        internal static string DirectionNorthEast {
            get {
                return ResourceManager.GetString("DirectionNorthEast", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to NW.
        /// </summary>
        internal static string DirectionNorthWest {
            get {
                return ResourceManager.GetString("DirectionNorthWest", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to S.
        /// </summary>
        internal static string DirectionSouth {
            get {
                return ResourceManager.GetString("DirectionSouth", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to SE.
        /// </summary>
        internal static string DirectionSouthEast {
            get {
                return ResourceManager.GetString("DirectionSouthEast", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to SW.
        /// </summary>
        internal static string DirectionSouthWest {
            get {
                return ResourceManager.GetString("DirectionSouthWest", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to W.
        /// </summary>
        internal static string DirectionWest {
            get {
                return ResourceManager.GetString("DirectionWest", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Unable to find {0} on {1}.
        /// </summary>
        internal static string ErrorCannotFindField {
            get {
                return ResourceManager.GetString("ErrorCannotFindField", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Cannot find original method {0}.
        /// </summary>
        internal static string ErrorCannotFindOriginalMethodFormat {
            get {
                return ResourceManager.GetString("ErrorCannotFindOriginalMethodFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Cannot find postfix method {0}.
        /// </summary>
        internal static string ErrorCannotFindPostfixMethodFormat {
            get {
                return ResourceManager.GetString("ErrorCannotFindPostfixMethodFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Cannot find prefix method {0}.
        /// </summary>
        internal static string ErrorCannotFindPrefixMethodFormat {
            get {
                return ResourceManager.GetString("ErrorCannotFindPrefixMethodFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Unable to load {0}. {1}.
        /// </summary>
        internal static string ErrorCannotLoadFormat {
            get {
                return ResourceManager.GetString("ErrorCannotLoadFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Unable to save {0}. {1}.
        /// </summary>
        internal static string ErrorCannotSaveFormat {
            get {
                return ResourceManager.GetString("ErrorCannotSaveFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {0} seems corrupted. Please fix.
        /// </summary>
        internal static string ErrorCorruptedFileFormat {
            get {
                return ResourceManager.GetString("ErrorCorruptedFileFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {0} seems corrupted in {1}. Please fix.
        /// </summary>
        internal static string ErrorCorruptedPropertyFormat {
            get {
                return ResourceManager.GetString("ErrorCorruptedPropertyFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Failed to create item!.
        /// </summary>
        internal static string ErrorFailedToCreateItem {
            get {
                return ResourceManager.GetString("ErrorFailedToCreateItem", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Failed to load item bundle!.
        /// </summary>
        internal static string ErrorFailedToLoadItemBundle {
            get {
                return ResourceManager.GetString("ErrorFailedToLoadItemBundle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {0} not found!.
        /// </summary>
        internal static string ErrorFileNotFoundFormat {
            get {
                return ResourceManager.GetString("ErrorFileNotFoundFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Invalid arguments.
        /// </summary>
        internal static string ErrorInvalidArguments {
            get {
                return ResourceManager.GetString("ErrorInvalidArguments", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to No bot found!.
        /// </summary>
        internal static string ErrorNoBotFound {
            get {
                return ResourceManager.GetString("ErrorNoBotFound", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to No template found!.
        /// </summary>
        internal static string ErrorNoTemplateFound {
            get {
                return ResourceManager.GetString("ErrorNoTemplateFound", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Found {0} bots, be more specific.
        /// </summary>
        internal static string ErrorTooManyBotsFormat {
            get {
                return ResourceManager.GetString("ErrorTooManyBotsFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Found {0} templates, be more specific.
        /// </summary>
        internal static string ErrorTooManyTemplatesFormat {
            get {
                return ResourceManager.GetString("ErrorTooManyTemplatesFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Unsupported type: {0}.
        /// </summary>
        internal static string ErrorUnsupportedTypeFormat {
            get {
                return ResourceManager.GetString("ErrorUnsupportedTypeFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Aimbot. Automatic aiming and/or shooting (SilentAim)..
        /// </summary>
        internal static string FeatureAimbotDescription {
            get {
                return ResourceManager.GetString("FeatureAimbotDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to aimbot.
        /// </summary>
        internal static string FeatureAimbotName {
            get {
                return ResourceManager.GetString("FeatureAimbotName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Triggers an airdrop at the player&apos;s location..
        /// </summary>
        internal static string FeatureAirDropDescription {
            get {
                return ResourceManager.GetString("FeatureAirDropDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to airdrop.
        /// </summary>
        internal static string FeatureAirDropName {
            get {
                return ResourceManager.GetString("FeatureAirDropName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Unlimited ammo..
        /// </summary>
        internal static string FeatureAmmunitionDescription {
            get {
                return ResourceManager.GetString("FeatureAmmunitionDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to ammo.
        /// </summary>
        internal static string FeatureAmmunitionName {
            get {
                return ResourceManager.GetString("FeatureAmmunitionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Force all guns (even bolt action guns) to use automatic firing mode with customizable fire rate..
        /// </summary>
        internal static string FeatureAutomaticGunDescription {
            get {
                return ResourceManager.GetString("FeatureAutomaticGunDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to autogun.
        /// </summary>
        internal static string FeatureAutomaticGunName {
            get {
                return ResourceManager.GetString("FeatureAutomaticGunName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Free camera with fast mode and teleportation..
        /// </summary>
        internal static string FeatureCameraDescription {
            get {
                return ResourceManager.GetString("FeatureCameraDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to camera.
        /// </summary>
        internal static string FeatureCameraName {
            get {
                return ResourceManager.GetString("FeatureCameraName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This main popup window..
        /// </summary>
        internal static string FeatureCommandsDescription {
            get {
                return ResourceManager.GetString("FeatureCommandsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to commands.
        /// </summary>
        internal static string FeatureCommandsName {
            get {
                return ResourceManager.GetString("FeatureCommandsName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to EFT Trainer.
        /// </summary>
        internal static string FeatureCommandsTitle {
            get {
                return ResourceManager.GetString("FeatureCommandsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Crosshair with customizable size, color, thickness and auto-hide feature when aiming..
        /// </summary>
        internal static string FeatureCrosshairDescription {
            get {
                return ResourceManager.GetString("FeatureCrosshairDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to crosshair.
        /// </summary>
        internal static string FeatureCrosshairName {
            get {
                return ResourceManager.GetString("FeatureCrosshairName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Maximum durability of items..
        /// </summary>
        internal static string FeatureDurabilityDescription {
            get {
                return ResourceManager.GetString("FeatureDurabilityDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to durability.
        /// </summary>
        internal static string FeatureDurabilityName {
            get {
                return ResourceManager.GetString("FeatureDurabilityName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to All items already examined. Instant search..
        /// </summary>
        internal static string FeatureExamineDescription {
            get {
                return ResourceManager.GetString("FeatureExamineDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to examine.
        /// </summary>
        internal static string FeatureExamineName {
            get {
                return ResourceManager.GetString("FeatureExamineName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Exfiltration points with customizable colors given eligibility, status filter, distance..
        /// </summary>
        internal static string FeatureExfiltrationPointsDescription {
            get {
                return ResourceManager.GetString("FeatureExfiltrationPointsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {0} ({1}).
        /// </summary>
        internal static string FeatureExfiltrationPointsEligibleFormat {
            get {
                return ResourceManager.GetString("FeatureExfiltrationPointsEligibleFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to exfil.
        /// </summary>
        internal static string FeatureExfiltrationPointsName {
            get {
                return ResourceManager.GetString("FeatureExfiltrationPointsName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Activate.
        /// </summary>
        internal static string FeatureExfiltrationPointsStatusActivate {
            get {
                return ResourceManager.GetString("FeatureExfiltrationPointsStatusActivate", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Closed.
        /// </summary>
        internal static string FeatureExfiltrationPointsStatusClosed {
            get {
                return ResourceManager.GetString("FeatureExfiltrationPointsStatusClosed", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Open.
        /// </summary>
        internal static string FeatureExfiltrationPointsStatusOpen {
            get {
                return ResourceManager.GetString("FeatureExfiltrationPointsStatusOpen", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Pending.
        /// </summary>
        internal static string FeatureExfiltrationPointsStatusPending {
            get {
                return ResourceManager.GetString("FeatureExfiltrationPointsStatusPending", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Requirement.
        /// </summary>
        internal static string FeatureExfiltrationPointsStatusRequirement {
            get {
                return ResourceManager.GetString("FeatureExfiltrationPointsStatusRequirement", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Timer.
        /// </summary>
        internal static string FeatureExfiltrationPointsStatusTimer {
            get {
                return ResourceManager.GetString("FeatureExfiltrationPointsStatusTimer", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Shoot through wall/helmet/vest/material with maximum penetration and minimal deviation/ricochet..
        /// </summary>
        internal static string FeatureFeatureWallShootDescription {
            get {
                return ResourceManager.GetString("FeatureFeatureWallShootDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Change Field Of View (FOV)..
        /// </summary>
        internal static string FeatureFovChangerDescription {
            get {
                return ResourceManager.GetString("FeatureFovChangerDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to fovchanger.
        /// </summary>
        internal static string FeatureFovChangerName {
            get {
                return ResourceManager.GetString("FeatureFovChangerName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Refresh all game information for other features..
        /// </summary>
        internal static string FeatureGameStateDescription {
            get {
                return ResourceManager.GetString("FeatureGameStateDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to gamestate.
        /// </summary>
        internal static string FeatureGameStateName {
            get {
                return ResourceManager.GetString("FeatureGameStateName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Stop bots from seeing you..
        /// </summary>
        internal static string FeatureGhostDescription {
            get {
                return ResourceManager.GetString("FeatureGhostDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to ghost.
        /// </summary>
        internal static string FeatureGhostName {
            get {
                return ResourceManager.GetString("FeatureGhostName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Grenades outline..
        /// </summary>
        internal static string FeatureGrenadesDescription {
            get {
                return ResourceManager.GetString("FeatureGrenadesDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to grenade.
        /// </summary>
        internal static string FeatureGrenadesName {
            get {
                return ResourceManager.GetString("FeatureGrenadesName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Full health, prevent any damage (so even when falling), keep energy and hydration at maximum..
        /// </summary>
        internal static string FeatureHealthDescription {
            get {
                return ResourceManager.GetString("FeatureHealthDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to health.
        /// </summary>
        internal static string FeatureHealthName {
            get {
                return ResourceManager.GetString("FeatureHealthName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Hit markers (hit, armor, health with configurable colors)..
        /// </summary>
        internal static string FeatureHitsDescription {
            get {
                return ResourceManager.GetString("FeatureHitsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to hits.
        /// </summary>
        internal static string FeatureHitsName {
            get {
                return ResourceManager.GetString("FeatureHitsName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to ({0},{1}).
        /// </summary>
        internal static string FeatureHudCoordinatesFormat {
            get {
                return ResourceManager.GetString("FeatureHudCoordinatesFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to HUD (compass, ammo left in chamber / magazine, fire mode, coordinates)..
        /// </summary>
        internal static string FeatureHudDescription {
            get {
                return ResourceManager.GetString("FeatureHudDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to hud.
        /// </summary>
        internal static string FeatureHudName {
            get {
                return ResourceManager.GetString("FeatureHudName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to  - .
        /// </summary>
        internal static string FeatureHudSeparator {
            get {
                return ResourceManager.GetString("FeatureHudSeparator", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {0}+{1}/{2} [{3}].
        /// </summary>
        internal static string FeatureHudWeaponFormat {
            get {
                return ResourceManager.GetString("FeatureHudWeaponFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Change distance for loot/door interaction..
        /// </summary>
        internal static string FeatureInteractDescription {
            get {
                return ResourceManager.GetString("FeatureInteractDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to interact.
        /// </summary>
        internal static string FeatureInteractName {
            get {
                return ResourceManager.GetString("FeatureInteractName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to List all lootable items and track any item by name or rarity or in-game wishlist in raid (even in containers and corpses). Use track and tracklist commands to control display..
        /// </summary>
        internal static string FeatureLootItemsDescription {
            get {
                return ResourceManager.GetString("FeatureLootItemsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to loot.
        /// </summary>
        internal static string FeatureLootItemsName {
            get {
                return ResourceManager.GetString("FeatureLootItemsName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Full screen map with radar esp..
        /// </summary>
        internal static string FeatureMapDescription {
            get {
                return ResourceManager.GetString("FeatureMapDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to map.
        /// </summary>
        internal static string FeatureMapName {
            get {
                return ResourceManager.GetString("FeatureMapName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Triggers a mortar strike at the player&apos;s location..
        /// </summary>
        internal static string FeatureMortarDescription {
            get {
                return ResourceManager.GetString("FeatureMortarDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to mortar.
        /// </summary>
        internal static string FeatureMortarName {
            get {
                return ResourceManager.GetString("FeatureMortarName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Night vision..
        /// </summary>
        internal static string FeatureNightVisionDescription {
            get {
                return ResourceManager.GetString("FeatureNightVisionDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to night.
        /// </summary>
        internal static string FeatureNightVisionName {
            get {
                return ResourceManager.GetString("FeatureNightVisionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to No physical collisions, making you immune to bullets, grenades and barbed wires..
        /// </summary>
        internal static string FeatureNoCollisionDescription {
            get {
                return ResourceManager.GetString("FeatureNoCollisionDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to nocoll.
        /// </summary>
        internal static string FeatureNoCollisionName {
            get {
                return ResourceManager.GetString("FeatureNoCollisionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to No persistent flash or eye-burn effect after a flash grenade..
        /// </summary>
        internal static string FeatureNoFlashDescription {
            get {
                return ResourceManager.GetString("FeatureNoFlashDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to noflash.
        /// </summary>
        internal static string FeatureNoFlashName {
            get {
                return ResourceManager.GetString("FeatureNoFlashName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to No weapon malfunctions: no misfires or failures to eject or feed. No jammed bolts or overheating..
        /// </summary>
        internal static string FeatureNoMalfunctionsDescription {
            get {
                return ResourceManager.GetString("FeatureNoMalfunctionsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to nomal.
        /// </summary>
        internal static string FeatureNoMalfunctionsName {
            get {
                return ResourceManager.GetString("FeatureNoMalfunctionsName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to No recoil..
        /// </summary>
        internal static string FeatureNoRecoilDescription {
            get {
                return ResourceManager.GetString("FeatureNoRecoilDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to norecoil.
        /// </summary>
        internal static string FeatureNoRecoilName {
            get {
                return ResourceManager.GetString("FeatureNoRecoilName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to No sway..
        /// </summary>
        internal static string FeatureNoSwayDescription {
            get {
                return ResourceManager.GetString("FeatureNoSwayDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to nosway.
        /// </summary>
        internal static string FeatureNoSwayName {
            get {
                return ResourceManager.GetString("FeatureNoSwayName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to No visor, so even when using a face shield-visor you won&apos;t see it..
        /// </summary>
        internal static string FeatureNoVisorDescription {
            get {
                return ResourceManager.GetString("FeatureNoVisorDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to novisor.
        /// </summary>
        internal static string FeatureNoVisorName {
            get {
                return ResourceManager.GetString("FeatureNoVisorName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Players (you&apos;ll see Bear/Boss/Cultist/Scav/Usec with configurable colors through walls). Charms, boxes, info (weapon and health), skeletons and distance..
        /// </summary>
        internal static string FeaturePlayersDescription {
            get {
                return ResourceManager.GetString("FeaturePlayersDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {0} {1}% {2}.
        /// </summary>
        internal static string FeaturePlayersFormat {
            get {
                return ResourceManager.GetString("FeaturePlayersFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to players.
        /// </summary>
        internal static string FeaturePlayersName {
            get {
                return ResourceManager.GetString("FeaturePlayersName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to [{0}m].
        /// </summary>
        internal static string FeaturePointOfInterestsDistanceFormat {
            get {
                return ResourceManager.GetString("FeaturePointOfInterestsDistanceFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {0} {1} {2}.
        /// </summary>
        internal static string FeaturePointOfInterestsFormat {
            get {
                return ResourceManager.GetString("FeaturePointOfInterestsFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &gt;&gt; In {0} {1}.
        /// </summary>
        internal static string FeaturePointOfInterestsGroupFormat {
            get {
                return ResourceManager.GetString("FeaturePointOfInterestsGroupFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to (in {0}).
        /// </summary>
        internal static string FeaturePointOfInterestsOwnerFormat {
            get {
                return ResourceManager.GetString("FeaturePointOfInterestsOwnerFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Locations for taking/placing quest items. Only items related to your started quests are displayed..
        /// </summary>
        internal static string FeatureQuestsDescription {
            get {
                return ResourceManager.GetString("FeatureQuestsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {0} ({1}).
        /// </summary>
        internal static string FeatureQuestsFormat {
            get {
                return ResourceManager.GetString("FeatureQuestsFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to quest.
        /// </summary>
        internal static string FeatureQuestsName {
            get {
                return ResourceManager.GetString("FeatureQuestsName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Quick-throw grenades..
        /// </summary>
        internal static string FeatureQuickTrowDescription {
            get {
                return ResourceManager.GetString("FeatureQuickTrowDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to quickthrow.
        /// </summary>
        internal static string FeatureQuickTrowName {
            get {
                return ResourceManager.GetString("FeatureQuickTrowName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to 2D radar..
        /// </summary>
        internal static string FeatureRadarDescription {
            get {
                return ResourceManager.GetString("FeatureRadarDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to radar.
        /// </summary>
        internal static string FeatureRadarName {
            get {
                return ResourceManager.GetString("FeatureRadarName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to [summary].
        /// </summary>
        internal static string FeatureRendererSummary {
            get {
                return ResourceManager.GetString("FeatureRendererSummary", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Welcome to EFT-Trainer !.
        /// </summary>
        internal static string FeatureRendererWelcome {
            get {
                return ResourceManager.GetString("FeatureRendererWelcome", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to All skills to Elite level (51) and all weapons mastering to level 3..
        /// </summary>
        internal static string FeatureSkillsDescription {
            get {
                return ResourceManager.GetString("FeatureSkillsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to skills.
        /// </summary>
        internal static string FeatureSkillsName {
            get {
                return ResourceManager.GetString("FeatureSkillsName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Speed boost to be able to go through walls/objects, or to move faster. Be careful to not kill yourself..
        /// </summary>
        internal static string FeatureSpeedDescription {
            get {
                return ResourceManager.GetString("FeatureSpeedDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to speed.
        /// </summary>
        internal static string FeatureSpeedName {
            get {
                return ResourceManager.GetString("FeatureSpeedName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Unlimited stamina..
        /// </summary>
        internal static string FeatureStaminaDescription {
            get {
                return ResourceManager.GetString("FeatureStaminaDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to stamina.
        /// </summary>
        internal static string FeatureStaminaName {
            get {
                return ResourceManager.GetString("FeatureStaminaName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Hidden/special stashes like buried barrels, ground caches, air drops or corpses..
        /// </summary>
        internal static string FeatureStashDescription {
            get {
                return ResourceManager.GetString("FeatureStashDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to stash.
        /// </summary>
        internal static string FeatureStashName {
            get {
                return ResourceManager.GetString("FeatureStashName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Thermal vision..
        /// </summary>
        internal static string FeatureThermalVisionDescription {
            get {
                return ResourceManager.GetString("FeatureThermalVisionDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to thermal.
        /// </summary>
        internal static string FeatureThermalVisionName {
            get {
                return ResourceManager.GetString("FeatureThermalVisionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Summon train on compatible maps like Reserve or Lighthouse..
        /// </summary>
        internal static string FeatureTrainDescription {
            get {
                return ResourceManager.GetString("FeatureTrainDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to train.
        /// </summary>
        internal static string FeatureTrainName {
            get {
                return ResourceManager.GetString("FeatureTrainName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to wallshoot.
        /// </summary>
        internal static string FeatureWallShootName {
            get {
                return ResourceManager.GetString("FeatureWallShootName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Clear weather..
        /// </summary>
        internal static string FeatureWeatherDescription {
            get {
                return ResourceManager.GetString("FeatureWeatherDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to weather.
        /// </summary>
        internal static string FeatureWeatherName {
            get {
                return ResourceManager.GetString("FeatureWeatherName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Door/Keycard reader/Car unlocker..
        /// </summary>
        internal static string FeatureWorldInteractiveObjectsDescription {
            get {
                return ResourceManager.GetString("FeatureWorldInteractiveObjectsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to opener.
        /// </summary>
        internal static string FeatureWorldInteractiveObjectsName {
            get {
                return ResourceManager.GetString("FeatureWorldInteractiveObjectsName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Armor-damage color.
        /// </summary>
        internal static string PropertyArmorDamageColor {
            get {
                return ResourceManager.GetString("PropertyArmorDamageColor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Backward.
        /// </summary>
        internal static string PropertyBackward {
            get {
                return ResourceManager.GetString("PropertyBackward", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Bear colors.
        /// </summary>
        internal static string PropertyBearColors {
            get {
                return ResourceManager.GetString("PropertyBearColors", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Border color.
        /// </summary>
        internal static string PropertyBorderColor {
            get {
                return ResourceManager.GetString("PropertyBorderColor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Boss colors.
        /// </summary>
        internal static string PropertyBossColors {
            get {
                return ResourceManager.GetString("PropertyBossColors", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Box thickness.
        /// </summary>
        internal static string PropertyBoxThickness {
            get {
                return ResourceManager.GetString("PropertyBoxThickness", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Cache time (sec).
        /// </summary>
        internal static string PropertyCacheTimeInSec {
            get {
                return ResourceManager.GetString("PropertyCacheTimeInSec", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Camera offset.
        /// </summary>
        internal static string PropertyCameraOffset {
            get {
                return ResourceManager.GetString("PropertyCameraOffset", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Change time.
        /// </summary>
        internal static string PropertyChangeTime {
            get {
                return ResourceManager.GetString("PropertyChangeTime", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Color.
        /// </summary>
        internal static string PropertyColor {
            get {
                return ResourceManager.GetString("PropertyColor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Cultist colors.
        /// </summary>
        internal static string PropertyCultistColors {
            get {
                return ResourceManager.GetString("PropertyCultistColors", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Display time.
        /// </summary>
        internal static string PropertyDisplayTime {
            get {
                return ResourceManager.GetString("PropertyDisplayTime", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Distance.
        /// </summary>
        internal static string PropertyDistance {
            get {
                return ResourceManager.GetString("PropertyDistance", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Elevation adjustment.
        /// </summary>
        internal static string PropertyElevationAdjustment {
            get {
                return ResourceManager.GetString("PropertyElevationAdjustment", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Eligible color.
        /// </summary>
        internal static string PropertyEligibleColor {
            get {
                return ResourceManager.GetString("PropertyEligibleColor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Enabled.
        /// </summary>
        internal static string PropertyEnabled {
            get {
                return ResourceManager.GetString("PropertyEnabled", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Fade-out time.
        /// </summary>
        internal static string PropertyFadeOutTime {
            get {
                return ResourceManager.GetString("PropertyFadeOutTime", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Fast mode.
        /// </summary>
        internal static string PropertyFastMode {
            get {
                return ResourceManager.GetString("PropertyFastMode", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Fast movement speed.
        /// </summary>
        internal static string PropertyFastMovementSpeed {
            get {
                return ResourceManager.GetString("PropertyFastMovementSpeed", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Food / water.
        /// </summary>
        internal static string PropertyFoodWater {
            get {
                return ResourceManager.GetString("PropertyFoodWater", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Forward.
        /// </summary>
        internal static string PropertyForward {
            get {
                return ResourceManager.GetString("PropertyForward", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to FOV.
        /// </summary>
        internal static string PropertyFov {
            get {
                return ResourceManager.GetString("PropertyFov", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to FOV circle color.
        /// </summary>
        internal static string PropertyFovCircleColor {
            get {
                return ResourceManager.GetString("PropertyFovCircleColor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to FOV circle thickness.
        /// </summary>
        internal static string PropertyFovCircleThickness {
            get {
                return ResourceManager.GetString("PropertyFovCircleThickness", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to FOV radius.
        /// </summary>
        internal static string PropertyFovRadius {
            get {
                return ResourceManager.GetString("PropertyFovRadius", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Free look sensitivity.
        /// </summary>
        internal static string PropertyFreeLookSensitivity {
            get {
                return ResourceManager.GetString("PropertyFreeLookSensitivity", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Grouping Color.
        /// </summary>
        internal static string PropertyGroupingColor {
            get {
                return ResourceManager.GetString("PropertyGroupingColor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Health-damage color.
        /// </summary>
        internal static string PropertyHealthDamageColor {
            get {
                return ResourceManager.GetString("PropertyHealthDamageColor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Hide when aiming.
        /// </summary>
        internal static string PropertyHideWhenAiming {
            get {
                return ResourceManager.GetString("PropertyHideWhenAiming", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Hit-marker color.
        /// </summary>
        internal static string PropertyHitMarkerColor {
            get {
                return ResourceManager.GetString("PropertyHitMarkerColor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Info color.
        /// </summary>
        internal static string PropertyInfoColor {
            get {
                return ResourceManager.GetString("PropertyInfoColor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Intensity.
        /// </summary>
        internal static string PropertyIntensity {
            get {
                return ResourceManager.GetString("PropertyIntensity", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Key.
        /// </summary>
        internal static string PropertyKey {
            get {
                return ResourceManager.GetString("PropertyKey", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Left.
        /// </summary>
        internal static string PropertyLeft {
            get {
                return ResourceManager.GetString("PropertyLeft", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Marksman colors.
        /// </summary>
        internal static string PropertyMarksmanColors {
            get {
                return ResourceManager.GetString("PropertyMarksmanColors", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Maximum distance.
        /// </summary>
        internal static string PropertyMaximumDistance {
            get {
                return ResourceManager.GetString("PropertyMaximumDistance", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Movement speed.
        /// </summary>
        internal static string PropertyMovementSpeed {
            get {
                return ResourceManager.GetString("PropertyMovementSpeed", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Not eligible color.
        /// </summary>
        internal static string PropertyNotEligibleColor {
            get {
                return ResourceManager.GetString("PropertyNotEligibleColor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Not shootable colors.
        /// </summary>
        internal static string PropertyNotShootableColors {
            get {
                return ResourceManager.GetString("PropertyNotShootableColors", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Radar background.
        /// </summary>
        internal static string PropertyRadarBackground {
            get {
                return ResourceManager.GetString("PropertyRadarBackground", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Radar crosshair.
        /// </summary>
        internal static string PropertyRadarCrosshair {
            get {
                return ResourceManager.GetString("PropertyRadarCrosshair", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Radar percentage.
        /// </summary>
        internal static string PropertyRadarPercentage {
            get {
                return ResourceManager.GetString("PropertyRadarPercentage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Radar range.
        /// </summary>
        internal static string PropertyRadarRange {
            get {
                return ResourceManager.GetString("PropertyRadarRange", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Range.
        /// </summary>
        internal static string PropertyRange {
            get {
                return ResourceManager.GetString("PropertyRange", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Rate.
        /// </summary>
        internal static string PropertyRate {
            get {
                return ResourceManager.GetString("PropertyRate", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Remove negative effects.
        /// </summary>
        internal static string PropertyRemoveNegativeEffects {
            get {
                return ResourceManager.GetString("PropertyRemoveNegativeEffects", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Right.
        /// </summary>
        internal static string PropertyRight {
            get {
                return ResourceManager.GetString("PropertyRight", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Rogue-Usec colors.
        /// </summary>
        internal static string PropertyRogueUsecColors {
            get {
                return ResourceManager.GetString("PropertyRogueUsecColors", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Scav-assault colors.
        /// </summary>
        internal static string PropertyScavAssaultColors {
            get {
                return ResourceManager.GetString("PropertyScavAssaultColors", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Scav colors.
        /// </summary>
        internal static string PropertyScavColors {
            get {
                return ResourceManager.GetString("PropertyScavColors", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Scav-raider colors.
        /// </summary>
        internal static string PropertyScavRaiderColors {
            get {
                return ResourceManager.GetString("PropertyScavRaiderColors", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Search inside containers.
        /// </summary>
        internal static string PropertySearchInsideContainers {
            get {
                return ResourceManager.GetString("PropertySearchInsideContainers", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Search inside corpses.
        /// </summary>
        internal static string PropertySearchInsideCorpses {
            get {
                return ResourceManager.GetString("PropertySearchInsideCorpses", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Shootable colors.
        /// </summary>
        internal static string PropertyShootableColors {
            get {
                return ResourceManager.GetString("PropertyShootableColors", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show armor damage.
        /// </summary>
        internal static string PropertyShowArmorDamage {
            get {
                return ResourceManager.GetString("PropertyShowArmorDamage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show Bosses.
        /// </summary>
        internal static string PropertyShowBosses {
            get {
                return ResourceManager.GetString("PropertyShowBosses", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show boxes.
        /// </summary>
        internal static string PropertyShowBoxes {
            get {
                return ResourceManager.GetString("PropertyShowBoxes", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show charms.
        /// </summary>
        internal static string PropertyShowCharms {
            get {
                return ResourceManager.GetString("PropertyShowCharms", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show compass.
        /// </summary>
        internal static string PropertyShowCompass {
            get {
                return ResourceManager.GetString("PropertyShowCompass", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show containers.
        /// </summary>
        internal static string PropertyShowContainers {
            get {
                return ResourceManager.GetString("PropertyShowContainers", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show coordinates.
        /// </summary>
        internal static string PropertyShowCoordinates {
            get {
                return ResourceManager.GetString("PropertyShowCoordinates", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show corpses.
        /// </summary>
        internal static string PropertyShowCorpses {
            get {
                return ResourceManager.GetString("PropertyShowCorpses", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show Cultists.
        /// </summary>
        internal static string PropertyShowCultists {
            get {
                return ResourceManager.GetString("PropertyShowCultists", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show eligible.
        /// </summary>
        internal static string PropertyShowEligible {
            get {
                return ResourceManager.GetString("PropertyShowEligible", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show fov circle.
        /// </summary>
        internal static string PropertyShowFovCircle {
            get {
                return ResourceManager.GetString("PropertyShowFovCircle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show health-damage.
        /// </summary>
        internal static string PropertyShowHealthDamage {
            get {
                return ResourceManager.GetString("PropertyShowHealthDamage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show Hit-marker.
        /// </summary>
        internal static string PropertyShowHitMarker {
            get {
                return ResourceManager.GetString("PropertyShowHitMarker", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show infos.
        /// </summary>
        internal static string PropertyShowInfos {
            get {
                return ResourceManager.GetString("PropertyShowInfos", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show map.
        /// </summary>
        internal static string PropertyShowMap {
            get {
                return ResourceManager.GetString("PropertyShowMap", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show Marksmen.
        /// </summary>
        internal static string PropertyShowMarksmen {
            get {
                return ResourceManager.GetString("PropertyShowMarksmen", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show not eligible.
        /// </summary>
        internal static string PropertyShowNotEligible {
            get {
                return ResourceManager.GetString("PropertyShowNotEligible", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show not shootable.
        /// </summary>
        internal static string PropertyShowNotShootable {
            get {
                return ResourceManager.GetString("PropertyShowNotShootable", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show players.
        /// </summary>
        internal static string PropertyShowPlayers {
            get {
                return ResourceManager.GetString("PropertyShowPlayers", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show prices.
        /// </summary>
        internal static string PropertyShowPrices {
            get {
                return ResourceManager.GetString("PropertyShowPrices", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show Rogues.
        /// </summary>
        internal static string PropertyShowRogues {
            get {
                return ResourceManager.GetString("PropertyShowRogues", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show Scav-assaults.
        /// </summary>
        internal static string PropertyShowScavAssaults {
            get {
                return ResourceManager.GetString("PropertyShowScavAssaults", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show Scav-raiders.
        /// </summary>
        internal static string PropertyShowScavRaiders {
            get {
                return ResourceManager.GetString("PropertyShowScavRaiders", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show Scavs.
        /// </summary>
        internal static string PropertyShowScavs {
            get {
                return ResourceManager.GetString("PropertyShowScavs", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show shootable.
        /// </summary>
        internal static string PropertyShowShootable {
            get {
                return ResourceManager.GetString("PropertyShowShootable", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show skeletons.
        /// </summary>
        internal static string PropertyShowSkeletons {
            get {
                return ResourceManager.GetString("PropertyShowSkeletons", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Silent aim.
        /// </summary>
        internal static string PropertySilentAim {
            get {
                return ResourceManager.GetString("PropertySilentAim", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Silent aim next-shot-delay.
        /// </summary>
        internal static string PropertySilentAimNextShotDelay {
            get {
                return ResourceManager.GetString("PropertySilentAimNextShotDelay", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Silent aim speed-factor.
        /// </summary>
        internal static string PropertySilentAimSpeedFactor {
            get {
                return ResourceManager.GetString("PropertySilentAimSpeedFactor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Size.
        /// </summary>
        internal static string PropertySize {
            get {
                return ResourceManager.GetString("PropertySize", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Skeleton thickness.
        /// </summary>
        internal static string PropertySkeletonThickness {
            get {
                return ResourceManager.GetString("PropertySkeletonThickness", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Smoothness.
        /// </summary>
        internal static string PropertySmoothness {
            get {
                return ResourceManager.GetString("PropertySmoothness", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Status filter.
        /// </summary>
        internal static string PropertyStatusFilter {
            get {
                return ResourceManager.GetString("PropertyStatusFilter", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Teleport.
        /// </summary>
        internal static string PropertyTeleport {
            get {
                return ResourceManager.GetString("PropertyTeleport", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Thickness.
        /// </summary>
        internal static string PropertyThickness {
            get {
                return ResourceManager.GetString("PropertyThickness", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Track Auto Wishlist.
        /// </summary>
        internal static string PropertyTrackAutoWishlist {
            get {
                return ResourceManager.GetString("PropertyTrackAutoWishlist", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Example: [&quot;foo&quot;, &quot;bar&quot;] or with extended properties: [{&quot;Name&quot;:&quot;foo&quot;,&quot;Color&quot;:[1.0,0.0,0.0,1.0]},{&quot;Name&quot;:&quot;bar&quot;,&quot;Color&quot;:[1.0,1.0,1.0,0.8],&quot;Rarity&quot;:&quot;Rare&quot;}].
        /// </summary>
        internal static string PropertyTrackedNamesComment {
            get {
                return ResourceManager.GetString("PropertyTrackedNamesComment", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Track Wishlist.
        /// </summary>
        internal static string PropertyTrackWishlist {
            get {
                return ResourceManager.GetString("PropertyTrackWishlist", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Usec colors.
        /// </summary>
        internal static string PropertyUsecColors {
            get {
                return ResourceManager.GetString("PropertyUsecColors", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Vitals only.
        /// </summary>
        internal static string PropertyVitalsOnly {
            get {
                return ResourceManager.GetString("PropertyVitalsOnly", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to X.
        /// </summary>
        internal static string PropertyX {
            get {
                return ResourceManager.GetString("PropertyX", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to XRay-Vision.
        /// </summary>
        internal static string PropertyXRayVision {
            get {
                return ResourceManager.GetString("PropertyXRayVision", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Y.
        /// </summary>
        internal static string PropertyY {
            get {
                return ResourceManager.GetString("PropertyY", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to off.
        /// </summary>
        internal static string TextOff {
            get {
                return ResourceManager.GetString("TextOff", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to on.
        /// </summary>
        internal static string TextOn {
            get {
                return ResourceManager.GetString("TextOn", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to ------.
        /// </summary>
        internal static string TextSeparator {
            get {
                return ResourceManager.GetString("TextSeparator", resourceCulture);
            }
        }
    }
}

```

`Properties/Strings.fr.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="CommandDump" xml:space="preserve">
    <value>dump</value>
  </data>
  <data name="CommandDumpGameObjects" xml:space="preserve">
    <value>Analyse des objets du jeu...</value>
  </data>
  <data name="CommandDumpScenes" xml:space="preserve">
    <value>Analyse des scenes...</value>
  </data>
  <data name="CommandDumpSuccessFormat" xml:space="preserve">
    <value>Analyse crée dans {0}</value>
    <comment>Filename</comment>
  </data>
  <data name="CommandList" xml:space="preserve">
    <value>list</value>
  </data>
  <data name="CommandListEnumerateFormat" xml:space="preserve">
    <value>{0} [{1}] {2}</value>
    <comment>Item name, count, optional rarity</comment>
  </data>
  <data name="CommandListRare" xml:space="preserve">
    <value>listr</value>
  </data>
  <data name="CommandListRarityFormat" xml:space="preserve">
    <value>({0})</value>
    <comment>Rarity</comment>
  </data>
  <data name="CommandListSuccessFormat" xml:space="preserve">
    <value>{0} objet(s) trouvé(s)</value>
    <comment>Item count</comment>
  </data>
  <data name="CommandListSuperRare" xml:space="preserve">
    <value>listsr</value>
  </data>
  <data name="CommandLoadDescription" xml:space="preserve">
    <value>Charger les réglages</value>
  </data>
  <data name="CommandLoadName" xml:space="preserve">
    <value>load</value>
  </data>
  <data name="CommandLoadSuccessFormat" xml:space="preserve">
    <value>Chargement de {0}</value>
    <comment>Filename</comment>
  </data>
  <data name="CommandLoadTrackList" xml:space="preserve">
    <value>loadtl</value>
  </data>
  <data name="CommandSaveDescription" xml:space="preserve">
    <value>Enregistrer les réglages</value>
  </data>
  <data name="CommandSaveHeader" xml:space="preserve">
    <value>Soyez prudent lorsque vous mettez à jour ce fichier :)
Pour les clés, utilisez https://docs.unity3d.com/ScriptReference/KeyCode.html
Les couleurs sont stockées sous la forme d'un tableau de valeurs flottantes 'RGBA'</value>
  </data>
  <data name="CommandSaveName" xml:space="preserve">
    <value>save</value>
  </data>
  <data name="CommandSaveSuccessFormat" xml:space="preserve">
    <value>Enregistrement de {0}</value>
    <comment>Filename</comment>
  </data>
  <data name="CommandSaveTrackList" xml:space="preserve">
    <value>savetl</value>
  </data>
  <data name="CommandSpawn" xml:space="preserve">
    <value>spawn</value>
  </data>
  <data name="CommandStatus" xml:space="preserve">
    <value>status</value>
  </data>
  <data name="CommandStatusTextFormat" xml:space="preserve">
    <value>{0} est {1} {2}</value>
    <comment>Feature name, status, optional toggle text if a key is set</comment>
  </data>
  <data name="CommandStatusTextToggleFormat" xml:space="preserve">
    <value>({0} pour basculer)</value>
    <comment>Key</comment>
  </data>
  <data name="CommandTemplate" xml:space="preserve">
    <value>template</value>
  </data>
  <data name="CommandTemplateEnumerateFormat" xml:space="preserve">
    <value>{0}: {1} [{2}]</value>
    <comment>Template id, short-name, name</comment>
  </data>
  <data name="CommandTemplateSuccessFormat" xml:space="preserve">
    <value>{0} template(s) trouvée(s)</value>
    <comment>Template count</comment>
  </data>
  <data name="CommandTrack" xml:space="preserve">
    <value>track</value>
  </data>
  <data name="CommandTrackList" xml:space="preserve">
    <value>tracklist</value>
  </data>
  <data name="CommandTrackListEnumerateFormat" xml:space="preserve">
    <value>Suivi: {0} {1}</value>
    <comment>Item short-name, optional rarity</comment>
  </data>
  <data name="CommandTrackListRarityFormat" xml:space="preserve">
    <value>({0})</value>
    <comment>Rarity</comment>
  </data>
  <data name="CommandTrackListUpdated" xml:space="preserve">
    <value>Liste de suivi mise à jour...</value>
  </data>
  <data name="CommandTrackListWishListEnumerateFormat" xml:space="preserve">
    <value>Suivi: {0} (Liste de souhaits)</value>
    <comment>Item short-name</comment>
  </data>
  <data name="CommandTrackRare" xml:space="preserve">
    <value>trackr</value>
  </data>
  <data name="CommandTrackSuperRare" xml:space="preserve">
    <value>tracksr</value>
  </data>
  <data name="CommandUnTrack" xml:space="preserve">
    <value>untrack</value>
  </data>
  <data name="DebugPatchedMethodFormat" xml:space="preserve">
    <value>Modification de {0} avec {1}</value>
    <comment>Method names</comment>
  </data>
  <data name="DebugPerformanceRefreshedFormat" xml:space="preserve">
    <value>Rafraichissement de {0} en {1}ms</value>
    <comment>Type name, elapsed milliseconds</comment>
  </data>
  <data name="DebugRegisteringCommandFormat" xml:space="preserve">
    <value>Enregistrement  de la commande {0}...</value>
    <comment>Command name</comment>
  </data>
  <data name="DebugRegisteringCommandWithArgumentsFormat" xml:space="preserve">
    <value>Enregistrement  de la commande {0} avec des arguments...</value>
    <comment>Command name</comment>
  </data>
  <data name="DirectionEast" xml:space="preserve">
    <value>E</value>
  </data>
  <data name="DirectionNorth" xml:space="preserve">
    <value>N</value>
  </data>
  <data name="DirectionNorthEast" xml:space="preserve">
    <value>NE</value>
  </data>
  <data name="DirectionNorthWest" xml:space="preserve">
    <value>NO</value>
  </data>
  <data name="DirectionSouth" xml:space="preserve">
    <value>S</value>
  </data>
  <data name="DirectionSouthEast" xml:space="preserve">
    <value>SE</value>
  </data>
  <data name="DirectionSouthWest" xml:space="preserve">
    <value>SO</value>
  </data>
  <data name="DirectionWest" xml:space="preserve">
    <value>O</value>
  </data>
  <data name="ErrorCannotFindField" xml:space="preserve">
    <value>Impossible de trouver {0} dans {1}</value>
    <comment>Field name, type name</comment>
  </data>
  <data name="ErrorCannotFindOriginalMethodFormat" xml:space="preserve">
    <value>Impossible de trouver la méthode originale {0}</value>
    <comment>Method name</comment>
  </data>
  <data name="ErrorCannotFindPostfixMethodFormat" xml:space="preserve">
    <value>Impossible de trouver la méthode suffixe {0}</value>
    <comment>Method name</comment>
  </data>
  <data name="ErrorCannotFindPrefixMethodFormat" xml:space="preserve">
    <value>Impossible de trouver la méthode préfixe {0}</value>
    <comment>Method name</comment>
  </data>
  <data name="ErrorCannotLoadFormat" xml:space="preserve">
    <value>Impossible de charger {0}. {1}</value>
    <comment>Filename, error message</comment>
  </data>
  <data name="ErrorCannotSaveFormat" xml:space="preserve">
    <value>Impossible d'enregistrer {0}. {1}</value>
    <comment>Filename, error message</comment>
  </data>
  <data name="ErrorCorruptedFileFormat" xml:space="preserve">
    <value>{0} semble corrompu. Merci de corriger</value>
    <comment>Filename</comment>
  </data>
  <data name="ErrorCorruptedPropertyFormat" xml:space="preserve">
    <value>{0} semble corrompu dans {1}. Merci de corriger</value>
    <comment>Key, filename</comment>
  </data>
  <data name="ErrorFailedToCreateItem" xml:space="preserve">
    <value>Impossible de créer l'objet!</value>
  </data>
  <data name="ErrorFailedToLoadItemBundle" xml:space="preserve">
    <value>Impossible de charger le paquet!</value>
  </data>
  <data name="ErrorFileNotFoundFormat" xml:space="preserve">
    <value>{0} introuvable!</value>
    <comment>Filename</comment>
  </data>
  <data name="ErrorInvalidArguments" xml:space="preserve">
    <value>Arguments invalides</value>
  </data>
  <data name="ErrorNoTemplateFound" xml:space="preserve">
    <value>Aucune template trouvée!</value>
  </data>
  <data name="ErrorTooManyTemplatesFormat" xml:space="preserve">
    <value>{0} templates trouvées, essayez d'être plus spécficique</value>
    <comment>Template count &gt; 1</comment>
  </data>
  <data name="ErrorUnsupportedTypeFormat" xml:space="preserve">
    <value>Type non supporté: {0}</value>
    <comment>Property type-name</comment>
  </data>
  <data name="FeatureAimbotDescription" xml:space="preserve">
    <value>Robot de visée. Visée et/ou tir automatique.</value>
  </data>
  <data name="FeatureAimbotName" xml:space="preserve">
    <value>aimbot</value>
  </data>
  <data name="FeatureAmmunitionDescription" xml:space="preserve">
    <value>Munitions illimitées.</value>
  </data>
  <data name="FeatureAmmunitionName" xml:space="preserve">
    <value>ammo</value>
  </data>
  <data name="FeatureAutomaticGunDescription" xml:space="preserve">
    <value>Force toutes les armes (même les fusils à verrou) à utiliser le mode de tir automatique avec une cadence de tir personnalisable.</value>
  </data>
  <data name="FeatureAutomaticGunName" xml:space="preserve">
    <value>autogun</value>
  </data>
  <data name="FeatureCameraDescription" xml:space="preserve">
    <value>Caméra libre avec mode rapide et téléportation.</value>
  </data>
  <data name="FeatureCameraName" xml:space="preserve">
    <value>camera</value>
  </data>
  <data name="FeatureCommandsDescription" xml:space="preserve">
    <value>Cette fenêtre principale.</value>
  </data>
  <data name="FeatureCommandsName" xml:space="preserve">
    <value>commands</value>
  </data>
  <data name="FeatureCommandsTitle" xml:space="preserve">
    <value>EFT Trainer</value>
  </data>
  <data name="FeatureCrosshairDescription" xml:space="preserve">
    <value>Réticule dont la taille, la couleur et l'épaisseur sont personnalisables et qui se masque automatiquement lors de la visée.</value>
  </data>
  <data name="FeatureCrosshairName" xml:space="preserve">
    <value>crosshair</value>
  </data>
  <data name="FeatureDurabilityDescription" xml:space="preserve">
    <value>Durabilité maximale des objets.</value>
  </data>
  <data name="FeatureDurabilityName" xml:space="preserve">
    <value>durability</value>
  </data>
  <data name="FeatureExamineDescription" xml:space="preserve">
    <value>Tous les objets ont déjà été examinés. Recherche instantanée.</value>
  </data>
  <data name="FeatureExamineName" xml:space="preserve">
    <value>examine</value>
  </data>
  <data name="FeatureExfiltrationPointsDescription" xml:space="preserve">
    <value>Points d'exfiltration avec couleurs personnalisables en fonction de l'éligibilité, du filtre de statut, de la distance.</value>
  </data>
  <data name="FeatureExfiltrationPointsEligibleFormat" xml:space="preserve">
    <value>{0} ({1})</value>
    <comment>Name, status</comment>
  </data>
  <data name="FeatureExfiltrationPointsName" xml:space="preserve">
    <value>exfil</value>
  </data>
  <data name="FeatureExfiltrationPointsStatusActivate" xml:space="preserve">
    <value>Activate</value>
  </data>
  <data name="FeatureExfiltrationPointsStatusClosed" xml:space="preserve">
    <value>Closed</value>
  </data>
  <data name="FeatureExfiltrationPointsStatusOpen" xml:space="preserve">
    <value>Open</value>
  </data>
  <data name="FeatureExfiltrationPointsStatusPending" xml:space="preserve">
    <value>Pending</value>
  </data>
  <data name="FeatureExfiltrationPointsStatusRequirement" xml:space="preserve">
    <value>Requirement</value>
  </data>
  <data name="FeatureExfiltrationPointsStatusTimer" xml:space="preserve">
    <value>Timer</value>
  </data>
  <data name="FeatureFeatureWallShootDescription" xml:space="preserve">
    <value>Tirer à travers un mur, un casque, un gilet ou un matériau avec une pénétration maximale et une déviation/ricochet minimale.</value>
  </data>
  <data name="FeatureFovChangerDescription" xml:space="preserve">
    <value>Modification du champ de vision.</value>
  </data>
  <data name="FeatureFovChangerName" xml:space="preserve">
    <value>fovchanger</value>
  </data>
  <data name="FeatureGameStateDescription" xml:space="preserve">
    <value>Rafraîchir toutes les informations sur le jeu pour d'autres fonctionnalités.</value>
  </data>
  <data name="FeatureGameStateName" xml:space="preserve">
    <value>gamestate</value>
  </data>
  <data name="FeatureGhostDescription" xml:space="preserve">
    <value>Empêcher les robots de vous voir.</value>
  </data>
  <data name="FeatureGhostName" xml:space="preserve">
    <value>ghost</value>
  </data>
  <data name="FeatureGrenadesDescription" xml:space="preserve">
    <value>Aperçu des grenades.</value>
  </data>
  <data name="FeatureGrenadesName" xml:space="preserve">
    <value>grenade</value>
  </data>
  <data name="FeatureHealthDescription" xml:space="preserve">
    <value>Pleine santé, éviter tout dommage (même en cas de chute), maintenir l'énergie et l'hydratation au maximum.</value>
  </data>
  <data name="FeatureHealthName" xml:space="preserve">
    <value>health</value>
  </data>
  <data name="FeatureHitsDescription" xml:space="preserve">
    <value>Marqueurs d'impacts (armure, santé avec couleurs configurables).</value>
  </data>
  <data name="FeatureHitsName" xml:space="preserve">
    <value>hits</value>
  </data>
  <data name="FeatureHudCoordinatesFormat" xml:space="preserve">
    <value>({0},{1})</value>
    <comment>X, y</comment>
  </data>
  <data name="FeatureHudDescription" xml:space="preserve">
    <value>Affichage (boussole, munitions restantes dans la chambre / le chargeur, mode de tir, coordonnées).</value>
  </data>
  <data name="FeatureHudName" xml:space="preserve">
    <value>hud</value>
  </data>
  <data name="FeatureHudSeparator" xml:space="preserve">
    <value> - </value>
  </data>
  <data name="FeatureHudWeaponFormat" xml:space="preserve">
    <value>{0}+{1}/{2} [{3}]</value>
    <comment>Magazine count, chamber count, magazine capacity, fire-mode</comment>
  </data>
  <data name="FeatureInteractDescription" xml:space="preserve">
    <value>Modifier la distance pour l'interaction avec le loot et les portes.</value>
  </data>
  <data name="FeatureInteractName" xml:space="preserve">
    <value>interact</value>
  </data>
  <data name="FeatureLootItemsDescription" xml:space="preserve">
    <value>Liste de tous les objets à looter et suivi de n'importe quel objet par nom, rareté ou liste de souhaits dans le raid (même dans les conteneurs et les cadavres). Utilisez les commandes track et tracklist pour contrôler l'affichage.</value>
  </data>
  <data name="FeatureLootItemsName" xml:space="preserve">
    <value>loot</value>
  </data>
  <data name="FeatureMapDescription" xml:space="preserve">
    <value>Carte plein écran avec radar.</value>
  </data>
  <data name="FeatureMapName" xml:space="preserve">
    <value>map</value>
  </data>
  <data name="FeatureNightVisionDescription" xml:space="preserve">
    <value>Vision nocturne.</value>
  </data>
  <data name="FeatureNightVisionName" xml:space="preserve">
    <value>night</value>
  </data>
  <data name="FeatureNoCollisionDescription" xml:space="preserve">
    <value>Pas de collisions physiques, ce qui vous immunise contre les balles, les grenades et les fils barbelés.</value>
  </data>
  <data name="FeatureNoCollisionName" xml:space="preserve">
    <value>nocoll</value>
  </data>
  <data name="FeatureNoMalfunctionsDescription" xml:space="preserve">
    <value>Pas de dysfonctionnement de l'arme : pas de ratés de tir, d'éjection ou d'alimentation. Pas de blocage de la culasse ni de surchauffe.</value>
  </data>
  <data name="FeatureNoMalfunctionsName" xml:space="preserve">
    <value>nomal</value>
  </data>
  <data name="FeatureNoRecoilDescription" xml:space="preserve">
    <value>Pas de recul.</value>
  </data>
  <data name="FeatureNoRecoilName" xml:space="preserve">
    <value>norecoil</value>
  </data>
  <data name="FeatureNoSwayDescription" xml:space="preserve">
    <value>Pas d'oscillation.</value>
  </data>
  <data name="FeatureNoSwayName" xml:space="preserve">
    <value>nosway</value>
  </data>
  <data name="FeatureNoVisorDescription" xml:space="preserve">
    <value>Pas de visière, donc même si vous utilisez un écran facial, vous ne le verrez pas.</value>
  </data>
  <data name="FeatureNoVisorName" xml:space="preserve">
    <value>novisor</value>
  </data>
  <data name="FeaturePlayersDescription" xml:space="preserve">
    <value>Joueurs (vous verrez Bear/Boss/Cultist/Scav/Usec avec des couleurs configurables à travers les murs). Silhouettes, boîtes, infos (armes et santé), squelettes et distance.</value>
  </data>
  <data name="FeaturePlayersFormat" xml:space="preserve">
    <value>{0} {1}% {2}</value>
    <comment>Weapon name, health %, distance</comment>
  </data>
  <data name="FeaturePlayersName" xml:space="preserve">
    <value>players</value>
  </data>
  <data name="FeaturePointOfInterestsDistanceFormat" xml:space="preserve">
    <value>[{0}m]</value>
    <comment>Distance</comment>
  </data>
  <data name="FeaturePointOfInterestsFormat" xml:space="preserve">
    <value>{0} {1} {2}</value>
    <comment>Name, optional formatted owner, optional formatted distance</comment>
  </data>
  <data name="FeaturePointOfInterestsGroupFormat" xml:space="preserve">
    <value>&gt;&gt; In {0} {1}</value>
    <comment>Owner, distance</comment>
  </data>
  <data name="FeaturePointOfInterestsOwnerFormat" xml:space="preserve">
    <value>(in {0})</value>
    <comment>Owner</comment>
  </data>
  <data name="FeatureQuestsDescription" xml:space="preserve">
    <value>Emplacements pour prendre/placer des objets de quête. Seuls les objets liés aux quêtes que vous avez commencées sont affichés.</value>
  </data>
  <data name="FeatureQuestsFormat" xml:space="preserve">
    <value>{0} ({1})</value>
    <comment>Condition description, quest name</comment>
  </data>
  <data name="FeatureQuestsName" xml:space="preserve">
    <value>quest</value>
  </data>
  <data name="FeatureQuickTrowDescription" xml:space="preserve">
    <value>Grenades à lancer rapide.</value>
  </data>
  <data name="FeatureQuickTrowName" xml:space="preserve">
    <value>quickthrow</value>
  </data>
  <data name="FeatureRadarDescription" xml:space="preserve">
    <value>Radar 2D.</value>
  </data>
  <data name="FeatureRadarName" xml:space="preserve">
    <value>radar</value>
  </data>
  <data name="FeatureRendererSummary" xml:space="preserve">
    <value>[sommaire]</value>
  </data>
  <data name="FeatureRendererWelcome" xml:space="preserve">
    <value>Bienvenue à EFT-Trainer !</value>
  </data>
  <data name="FeatureSkillsDescription" xml:space="preserve">
    <value>Toutes les compétences au niveau Elite (51) et toutes les armes au niveau 3.</value>
  </data>
  <data name="FeatureSkillsName" xml:space="preserve">
    <value>skills</value>
  </data>
  <data name="FeatureSpeedDescription" xml:space="preserve">
    <value>Augmentation de la vitesse pour pouvoir passer à travers les murs/objets, ou pour se déplacer plus rapidement. Faites attention à ne pas vous tuer.</value>
  </data>
  <data name="FeatureSpeedName" xml:space="preserve">
    <value>speed</value>
  </data>
  <data name="FeatureStaminaDescription" xml:space="preserve">
    <value>Endurance illimitée.</value>
  </data>
  <data name="FeatureStaminaName" xml:space="preserve">
    <value>stamina</value>
  </data>
  <data name="FeatureStashDescription" xml:space="preserve">
    <value>Voir les cachettes comme des barils enterrés, des caches au sol, des parachutages ou des cadavres.</value>
  </data>
  <data name="FeatureStashName" xml:space="preserve">
    <value>stash</value>
  </data>
  <data name="FeatureThermalVisionDescription" xml:space="preserve">
    <value>Vision thermique.</value>
  </data>
  <data name="FeatureThermalVisionName" xml:space="preserve">
    <value>thermal</value>
  </data>
  <data name="FeatureTrainDescription" xml:space="preserve">
    <value>Appeler un train sur des cartes compatibles comme Reserve ou Lighthouse.</value>
  </data>
  <data name="FeatureTrainName" xml:space="preserve">
    <value>train</value>
  </data>
  <data name="FeatureWallShootName" xml:space="preserve">
    <value>wallshoot</value>
  </data>
  <data name="FeatureWeatherDescription" xml:space="preserve">
    <value>Temps dégagé.</value>
  </data>
  <data name="FeatureWeatherName" xml:space="preserve">
    <value>weather</value>
  </data>
  <data name="FeatureWorldInteractiveObjectsDescription" xml:space="preserve">
    <value>Déverrouillage de porte/lecteur de carte magnétique/voiture.</value>
  </data>
  <data name="FeatureWorldInteractiveObjectsName" xml:space="preserve">
    <value>opener</value>
  </data>
  <data name="PropertyArmorDamageColor" xml:space="preserve">
    <value>Couleur impact armure</value>
  </data>
  <data name="PropertyBackward" xml:space="preserve">
    <value>Arrière</value>
  </data>
  <data name="PropertyBearColors" xml:space="preserve">
    <value>Couleurs Bear</value>
  </data>
  <data name="PropertyBorderColor" xml:space="preserve">
    <value>Couleur bordure</value>
  </data>
  <data name="PropertyBossColors" xml:space="preserve">
    <value>Couleurs Boss</value>
  </data>
  <data name="PropertyBoxThickness" xml:space="preserve">
    <value>Epaisseur boîte</value>
  </data>
  <data name="PropertyCacheTimeInSec" xml:space="preserve">
    <value>Durée de cache (sec)</value>
  </data>
  <data name="PropertyCameraOffset" xml:space="preserve">
    <value>Offset de camera</value>
  </data>
  <data name="PropertyChangeTime" xml:space="preserve">
    <value>Changer l'heure</value>
  </data>
  <data name="PropertyColor" xml:space="preserve">
    <value>Couleur</value>
  </data>
  <data name="PropertyCultistColors" xml:space="preserve">
    <value>Couleurs Cultistes</value>
  </data>
  <data name="PropertyDisplayTime" xml:space="preserve">
    <value>Temps d'affichage</value>
  </data>
  <data name="PropertyDistance" xml:space="preserve">
    <value>Distance</value>
  </data>
  <data name="PropertyEligibleColor" xml:space="preserve">
    <value>Couleur éligible</value>
  </data>
  <data name="PropertyEnabled" xml:space="preserve">
    <value>Activé</value>
  </data>
  <data name="PropertyFadeOutTime" xml:space="preserve">
    <value>Temps de fondu</value>
  </data>
  <data name="PropertyFastMode" xml:space="preserve">
    <value>Mode rapide</value>
  </data>
  <data name="PropertyFastMovementSpeed" xml:space="preserve">
    <value>Vitesse de mvt. rapide</value>
  </data>
  <data name="PropertyFoodWater" xml:space="preserve">
    <value>Nourriture / eau</value>
  </data>
  <data name="PropertyForward" xml:space="preserve">
    <value>Avant</value>
  </data>
  <data name="PropertyFov" xml:space="preserve">
    <value>Champ visuel</value>
  </data>
  <data name="PropertyFovCircleColor" xml:space="preserve">
    <value>Couleur champ visuel</value>
  </data>
  <data name="PropertyFovCircleThickness" xml:space="preserve">
    <value>Epaisseur champ visuel</value>
  </data>
  <data name="PropertyFovRadius" xml:space="preserve">
    <value>Rayon champ visuel</value>
  </data>
  <data name="PropertyFreeLookSensitivity" xml:space="preserve">
    <value>Sensibilité vision libre</value>
  </data>
  <data name="PropertyGroupingColor" xml:space="preserve">
    <value>Couleur de groupement</value>
  </data>
  <data name="PropertyHealthDamageColor" xml:space="preserve">
    <value>Couleur impact santé</value>
  </data>
  <data name="PropertyHideWhenAiming" xml:space="preserve">
    <value>Cacher en cas de visée</value>
  </data>
  <data name="PropertyHitMarkerColor" xml:space="preserve">
    <value>Couleur du marqueur</value>
  </data>
  <data name="PropertyInfoColor" xml:space="preserve">
    <value>Couleur d'information</value>
  </data>
  <data name="PropertyIntensity" xml:space="preserve">
    <value>Intensité</value>
  </data>
  <data name="PropertyKey" xml:space="preserve">
    <value>Touche</value>
  </data>
  <data name="PropertyLeft" xml:space="preserve">
    <value>Gauche</value>
  </data>
  <data name="PropertyMarksmanColors" xml:space="preserve">
    <value>Couleurs Snipers</value>
  </data>
  <data name="PropertyMaximumDistance" xml:space="preserve">
    <value>Distance maximum</value>
  </data>
  <data name="PropertyMovementSpeed" xml:space="preserve">
    <value>Vitesse de mouvement</value>
  </data>
  <data name="PropertyNotEligibleColor" xml:space="preserve">
    <value>Couleur non-éligible</value>
  </data>
  <data name="PropertyNotShootableColors" xml:space="preserve">
    <value>Couleurs des non-cibles</value>
  </data>
  <data name="PropertyRadarBackground" xml:space="preserve">
    <value>Arrière-plan du radar</value>
  </data>
  <data name="PropertyRadarCrosshair" xml:space="preserve">
    <value>Réticule radar</value>
  </data>
  <data name="PropertyRadarPercentage" xml:space="preserve">
    <value>Pourcentage du radar</value>
  </data>
  <data name="PropertyRadarRange" xml:space="preserve">
    <value>Portée du radar</value>
  </data>
  <data name="PropertyRange" xml:space="preserve">
    <value>Portée</value>
  </data>
  <data name="PropertyRate" xml:space="preserve">
    <value>Cadence</value>
  </data>
  <data name="PropertyRemoveNegativeEffects" xml:space="preserve">
    <value>Supprimer effets négatifs</value>
  </data>
  <data name="PropertyRight" xml:space="preserve">
    <value>Droite</value>
  </data>
  <data name="PropertyRogueUsecColors" xml:space="preserve">
    <value>Couleurs Rogue-Usec</value>
  </data>
  <data name="PropertyScavAssaultColors" xml:space="preserve">
    <value>Couleurs Scav-assault</value>
  </data>
  <data name="PropertyScavColors" xml:space="preserve">
    <value>Couleurs Scav</value>
  </data>
  <data name="PropertyScavRaiderColors" xml:space="preserve">
    <value>Couleurs Scav-raider</value>
  </data>
  <data name="PropertySearchInsideContainers" xml:space="preserve">
    <value>Chercher les conteneurs</value>
  </data>
  <data name="PropertySearchInsideCorpses" xml:space="preserve">
    <value>Chercher les cadavres</value>
  </data>
  <data name="PropertyShootableColors" xml:space="preserve">
    <value>Couleurs des cibles</value>
  </data>
  <data name="PropertyShowArmorDamage" xml:space="preserve">
    <value>Montrer impacts armure</value>
  </data>
  <data name="PropertyShowBosses" xml:space="preserve">
    <value>Montrer les Boss</value>
  </data>
  <data name="PropertyShowBoxes" xml:space="preserve">
    <value>Montrer les boites</value>
  </data>
  <data name="PropertyShowCharms" xml:space="preserve">
    <value>Montrer les silhouettes</value>
  </data>
  <data name="PropertyShowCompass" xml:space="preserve">
    <value>Montrer la boussole</value>
  </data>
  <data name="PropertyShowContainers" xml:space="preserve">
    <value>Montrer les conteneurs</value>
  </data>
  <data name="PropertyShowCoordinates" xml:space="preserve">
    <value>Montrer les coordonnées</value>
  </data>
  <data name="PropertyShowCorpses" xml:space="preserve">
    <value>Montrer les cadavres</value>
  </data>
  <data name="PropertyShowCultists" xml:space="preserve">
    <value>Montrer les Cultistes</value>
  </data>
  <data name="PropertyShowEligible" xml:space="preserve">
    <value>Montrer les éligibles</value>
  </data>
  <data name="PropertyShowFovCircle" xml:space="preserve">
    <value>Montrer le champ visuel</value>
  </data>
  <data name="PropertyShowHealthDamage" xml:space="preserve">
    <value>Montrer impacts santé</value>
  </data>
  <data name="PropertyShowHitMarker" xml:space="preserve">
    <value>Montrer les marqueurs</value>
  </data>
  <data name="PropertyShowInfos" xml:space="preserve">
    <value>Montrer les infos</value>
  </data>
  <data name="PropertyShowMap" xml:space="preserve">
    <value>Montrer la carte</value>
  </data>
  <data name="PropertyShowMarksmen" xml:space="preserve">
    <value>Montrer les Snipers</value>
  </data>
  <data name="PropertyShowNotEligible" xml:space="preserve">
    <value>Montrer les non-éligibles</value>
  </data>
  <data name="PropertyShowNotShootable" xml:space="preserve">
    <value>Montrer les non-cibles</value>
  </data>
  <data name="PropertyShowPlayers" xml:space="preserve">
    <value>Montrer les joueurs</value>
  </data>
  <data name="PropertyShowPrices" xml:space="preserve">
    <value>Montrer les prix</value>
  </data>
  <data name="PropertyShowRogues" xml:space="preserve">
    <value>Montrer les Rogues</value>
  </data>
  <data name="PropertyShowScavAssaults" xml:space="preserve">
    <value>Montrer les Scav-assaults</value>
  </data>
  <data name="PropertyShowScavRaiders" xml:space="preserve">
    <value>Montrer les Scav-raiders</value>
  </data>
  <data name="PropertyShowScavs" xml:space="preserve">
    <value>Montrer les Scavs</value>
  </data>
  <data name="PropertyShowShootable" xml:space="preserve">
    <value>Montrer les cibles</value>
  </data>
  <data name="PropertyShowSkeletons" xml:space="preserve">
    <value>Montrer les squelettes</value>
  </data>
  <data name="PropertySilentAim" xml:space="preserve">
    <value>Visée silencieuse</value>
  </data>
  <data name="PropertySilentAimNextShotDelay" xml:space="preserve">
    <value>Delai du prochain tir</value>
  </data>
  <data name="PropertySilentAimSpeedFactor" xml:space="preserve">
    <value>Vitesse de visée</value>
  </data>
  <data name="PropertySize" xml:space="preserve">
    <value>Taille</value>
  </data>
  <data name="PropertySkeletonThickness" xml:space="preserve">
    <value>Epaisseur du squelette</value>
  </data>
  <data name="PropertySmoothness" xml:space="preserve">
    <value>Lissage</value>
  </data>
  <data name="PropertyStatusFilter" xml:space="preserve">
    <value>Filtre de statut</value>
  </data>
  <data name="PropertyTeleport" xml:space="preserve">
    <value>Teleporter</value>
  </data>
  <data name="PropertyThickness" xml:space="preserve">
    <value>Epaisseur</value>
  </data>
  <data name="PropertyTrackedNamesComment" xml:space="preserve">
    <value>Exemple: ["foo", "bar"] ou avec des propriétés étendues: [{"Name":"foo","Color":[1.0,0.0,0.0,1.0]},{"Name":"bar","Color":[1.0,1.0,1.0,0.8],"Rarity":"Rare"}]</value>
  </data>
  <data name="PropertyTrackWishlist" xml:space="preserve">
    <value>Suivre la liste de souhaits</value>
  </data>
  <data name="PropertyUsecColors" xml:space="preserve">
    <value>Couleurs Usec</value>
  </data>
  <data name="PropertyVitalsOnly" xml:space="preserve">
    <value>Organes vitaux seulement</value>
  </data>
  <data name="PropertyX" xml:space="preserve">
    <value>X</value>
  </data>
  <data name="PropertyXRayVision" xml:space="preserve">
    <value>Vision à rayons X</value>
  </data>
  <data name="PropertyY" xml:space="preserve">
    <value>Y</value>
  </data>
  <data name="TextOff" xml:space="preserve">
    <value>off</value>
  </data>
  <data name="TextOn" xml:space="preserve">
    <value>on</value>
  </data>
  <data name="TextSeparator" xml:space="preserve">
    <value>------</value>
  </data>
  <data name="ErrorNoBotFound" xml:space="preserve">
    <value>Auncun bot trouvé!</value>
  </data>
  <data name="CommandSpawnBot" xml:space="preserve">
    <value>spawnbot</value>
  </data>
  <data name="ErrorTooManyBotsFormat" xml:space="preserve">
    <value>{0} bots trouvés, essayez d'être plus spécficique</value>
    <comment>Bot count &gt; 1</comment>
  </data>
  <data name="CommandSpawnBotEnumerateFormat" xml:space="preserve">
    <value>{0}</value>
  </data>
  <data name="CommandSpawnQuestItems" xml:space="preserve">
    <value>spawnqi</value>
  </data>
  <data name="PropertyTrackAutoWishlist" xml:space="preserve">
    <value>Suivre la liste de souhaits auto</value>
  </data>
  <data name="CommandSpawnHideoutItems" xml:space="preserve">
    <value>spawnhi</value>
  </data>
  <data name="FeatureNoFlashName" xml:space="preserve">
    <value>noflash</value>
  </data>
  <data name="FeatureNoFlashDescription" xml:space="preserve">
    <value>Pas d'effet de flash persistant ou de brûlure oculaire après une grenade flash.</value>
  </data>
  <data name="FeatureMortarName" xml:space="preserve">
    <value>mortar</value>
  </data>
  <data name="FeatureMortarDescription" xml:space="preserve">
    <value>Déclenche une attaque de mortier à l'endroit où se trouve le joueur.</value>
  </data>
  <data name="FeatureAirDropName" xml:space="preserve">
    <value>airdrop</value>
  </data>
  <data name="FeatureAirDropDescription" xml:space="preserve">
    <value>Déclenche un largage aérien à l'endroit où se trouve le joueur.</value>
  </data>
  <data name="PropertyElevationAdjustment" xml:space="preserve">
    <value>Ajustement de l'élévation</value>
  </data>
</root>
```

`Properties/Strings.jp.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="CommandDump" xml:space="preserve">
    <value>dump</value>
  </data>
  <data name="CommandDumpGameObjects" xml:space="preserve">
    <value>Dumping game objects...</value>
  </data>
  <data name="CommandDumpScenes" xml:space="preserve">
    <value>Dumping Scenes...</value>
  </data>
  <data name="CommandDumpSuccessFormat" xml:space="preserve">
    <value>Dump created in {0}</value>
    <comment>Filename</comment>
  </data>
  <data name="CommandList" xml:space="preserve">
    <value>list</value>
  </data>
  <data name="CommandListEnumerateFormat" xml:space="preserve">
    <value>{0} [{1}] {2}</value>
    <comment>Item name, count, optional rarity</comment>
  </data>
  <data name="CommandListRare" xml:space="preserve">
    <value>listr</value>
  </data>
  <data name="CommandListRarityFormat" xml:space="preserve">
    <value>({0})</value>
    <comment>Rarity</comment>
  </data>
  <data name="CommandListSuccessFormat" xml:space="preserve">
    <value>Found {0} item(s)</value>
    <comment>Item count</comment>
  </data>
  <data name="CommandListSuperRare" xml:space="preserve">
    <value>listsr</value>
  </data>
  <data name="CommandLoadDescription" xml:space="preserve">
    <value>設定読込</value>
  </data>
  <data name="CommandLoadName" xml:space="preserve">
    <value>load</value>
  </data>
  <data name="CommandLoadSuccessFormat" xml:space="preserve">
    <value>Loaded {0}</value>
    <comment>Filename</comment>
  </data>
  <data name="CommandLoadTrackList" xml:space="preserve">
    <value>loadtl</value>
  </data>
  <data name="CommandSaveDescription" xml:space="preserve">
    <value>設定保存</value>
  </data>
  <data name="CommandSaveHeader" xml:space="preserve">
    <value>このファイルを更新するときは注意してください :)
キーには https://docs.unity3d.com/ScriptReference/KeyCode.html を使用します
色は'RGBA'浮動小数点数の配列として格納されます</value>
  </data>
  <data name="CommandSaveName" xml:space="preserve">
    <value>save</value>
  </data>
  <data name="CommandSaveSuccessFormat" xml:space="preserve">
    <value>Saved {0}</value>
    <comment>Filename</comment>
  </data>
  <data name="CommandSaveTrackList" xml:space="preserve">
    <value>savetl</value>
  </data>
  <data name="CommandSpawn" xml:space="preserve">
    <value>spawn</value>
  </data>
  <data name="CommandStatus" xml:space="preserve">
    <value>status</value>
  </data>
  <data name="CommandStatusTextFormat" xml:space="preserve">
    <value>{0} is {1} {2}</value>
    <comment>Feature name, status, optional toggle text if a key is set</comment>
  </data>
  <data name="CommandStatusTextToggleFormat" xml:space="preserve">
    <value>({0} to toggle)</value>
    <comment>Key</comment>
  </data>
  <data name="CommandTemplate" xml:space="preserve">
    <value>template</value>
  </data>
  <data name="CommandTemplateEnumerateFormat" xml:space="preserve">
    <value>{0}: {1} [{2}]</value>
    <comment>Template id, short-name, name</comment>
  </data>
  <data name="CommandTemplateSuccessFormat" xml:space="preserve">
    <value>Found {0} template(s)</value>
    <comment>Template count</comment>
  </data>
  <data name="CommandTrack" xml:space="preserve">
    <value>track</value>
  </data>
  <data name="CommandTrackList" xml:space="preserve">
    <value>tracklist</value>
  </data>
  <data name="CommandTrackListEnumerateFormat" xml:space="preserve">
    <value>Tracking: {0} {1}</value>
    <comment>Item short-name, optional rarity</comment>
  </data>
  <data name="CommandTrackListRarityFormat" xml:space="preserve">
    <value>({0})</value>
    <comment>Rarity</comment>
  </data>
  <data name="CommandTrackListUpdated" xml:space="preserve">
    <value>Tracking list updated...</value>
  </data>
  <data name="CommandTrackListWishListEnumerateFormat" xml:space="preserve">
    <value>Tracking: {0} (Wishlist)</value>
    <comment>Item short-name</comment>
  </data>
  <data name="CommandTrackRare" xml:space="preserve">
    <value>trackr</value>
  </data>
  <data name="CommandTrackSuperRare" xml:space="preserve">
    <value>tracksr</value>
  </data>
  <data name="CommandUnTrack" xml:space="preserve">
    <value>untrack</value>
  </data>
  <data name="DebugPatchedMethodFormat" xml:space="preserve">
    <value>Patched {0} with {1}</value>
    <comment>Method names</comment>
  </data>
  <data name="DebugPerformanceRefreshedFormat" xml:space="preserve">
    <value>Refreshed {0} in {1}ms</value>
    <comment>Type name, elapsed milliseconds</comment>
  </data>
  <data name="DebugRegisteringCommandFormat" xml:space="preserve">
    <value>Registering {0} command...</value>
    <comment>Command name</comment>
  </data>
  <data name="DebugRegisteringCommandWithArgumentsFormat" xml:space="preserve">
    <value>Registering {0} command with arguments...</value>
    <comment>Command name</comment>
  </data>
  <data name="DirectionEast" xml:space="preserve">
    <value>東</value>
  </data>
  <data name="DirectionNorth" xml:space="preserve">
    <value>北</value>
  </data>
  <data name="DirectionNorthEast" xml:space="preserve">
    <value>北東</value>
  </data>
  <data name="DirectionNorthWest" xml:space="preserve">
    <value>北西</value>
  </data>
  <data name="DirectionSouth" xml:space="preserve">
    <value>南</value>
  </data>
  <data name="DirectionSouthEast" xml:space="preserve">
    <value>南東</value>
  </data>
  <data name="DirectionSouthWest" xml:space="preserve">
    <value>南西</value>
  </data>
  <data name="DirectionWest" xml:space="preserve">
    <value>西</value>
  </data>
  <data name="ErrorCannotFindField" xml:space="preserve">
    <value>Unable to find {0} on {1}</value>
    <comment>Field name, type name</comment>
  </data>
  <data name="ErrorCannotFindOriginalMethodFormat" xml:space="preserve">
    <value>Cannot find original method {0}</value>
    <comment>Method name</comment>
  </data>
  <data name="ErrorCannotFindPostfixMethodFormat" xml:space="preserve">
    <value>Cannot find postfix method {0}</value>
    <comment>Method name</comment>
  </data>
  <data name="ErrorCannotFindPrefixMethodFormat" xml:space="preserve">
    <value>Cannot find prefix method {0}</value>
    <comment>Method name</comment>
  </data>
  <data name="ErrorCannotLoadFormat" xml:space="preserve">
    <value>Unable to load {0}. {1}</value>
    <comment>Filename, error message</comment>
  </data>
  <data name="ErrorCannotSaveFormat" xml:space="preserve">
    <value>Unable to save {0}. {1}</value>
    <comment>Filename, error message</comment>
  </data>
  <data name="ErrorCorruptedFileFormat" xml:space="preserve">
    <value>{0} seems corrupted. Please fix</value>
    <comment>Filename</comment>
  </data>
  <data name="ErrorCorruptedPropertyFormat" xml:space="preserve">
    <value>{0} seems corrupted in {1}. Please fix</value>
    <comment>Key, filename</comment>
  </data>
  <data name="ErrorFailedToCreateItem" xml:space="preserve">
    <value>Failed to create item!</value>
  </data>
  <data name="ErrorFailedToLoadItemBundle" xml:space="preserve">
    <value>Failed to load item bundle!</value>
  </data>
  <data name="ErrorFileNotFoundFormat" xml:space="preserve">
    <value>{0} not found!</value>
    <comment>Filename</comment>
  </data>
  <data name="ErrorInvalidArguments" xml:space="preserve">
    <value>Invalid arguments</value>
  </data>
  <data name="ErrorNoTemplateFound" xml:space="preserve">
    <value>No template found!</value>
  </data>
  <data name="ErrorTooManyTemplatesFormat" xml:space="preserve">
    <value>Found {0} templates, be more specific</value>
    <comment>Template count &gt; 1</comment>
  </data>
  <data name="ErrorUnsupportedTypeFormat" xml:space="preserve">
    <value>Unsupported type: {0}</value>
    <comment>Property type-name</comment>
  </data>
  <data name="FeatureAimbotDescription" xml:space="preserve">
    <value>Aimbot. 自動照準・自動発射 (SilentAim)</value>
  </data>
  <data name="FeatureAimbotName" xml:space="preserve">
    <value>aimbot</value>
  </data>
  <data name="FeatureAmmunitionDescription" xml:space="preserve">
    <value>弾薬無限</value>
  </data>
  <data name="FeatureAmmunitionName" xml:space="preserve">
    <value>ammo</value>
  </data>
  <data name="FeatureAutomaticGunDescription" xml:space="preserve">
    <value>全ての銃(ボルトアクション銃含む)を発射速度が設定可能な自動発射モードにする</value>
  </data>
  <data name="FeatureAutomaticGunName" xml:space="preserve">
    <value>autogun</value>
  </data>
  <data name="FeatureCameraDescription" xml:space="preserve">
    <value>高速モードとテレポート機能を備えたフリーカメラ</value>
  </data>
  <data name="FeatureCameraName" xml:space="preserve">
    <value>camera</value>
  </data>
  <data name="FeatureCommandsDescription" xml:space="preserve">
    <value>このメインポップアップウィンドウ</value>
  </data>
  <data name="FeatureCommandsName" xml:space="preserve">
    <value>commands</value>
  </data>
  <data name="FeatureCommandsTitle" xml:space="preserve">
    <value>EFT Trainer</value>
  </data>
  <data name="FeatureCrosshairDescription" xml:space="preserve">
    <value>照準</value>
  </data>
  <data name="FeatureCrosshairName" xml:space="preserve">
    <value>crosshair</value>
  </data>
  <data name="FeatureDurabilityDescription" xml:space="preserve">
    <value>耐久最大</value>
  </data>
  <data name="FeatureDurabilityName" xml:space="preserve">
    <value>durability</value>
  </data>
  <data name="FeatureExamineDescription" xml:space="preserve">
    <value>インスタントサーチ</value>
  </data>
  <data name="FeatureExamineName" xml:space="preserve">
    <value>examine</value>
  </data>
  <data name="FeatureExfiltrationPointsDescription" xml:space="preserve">
    <value>脱出地点</value>
  </data>
  <data name="FeatureExfiltrationPointsEligibleFormat" xml:space="preserve">
    <value>{0} ({1})</value>
    <comment>Name, status</comment>
  </data>
  <data name="FeatureExfiltrationPointsName" xml:space="preserve">
    <value>exfil</value>
  </data>
  <data name="FeatureExfiltrationPointsStatusActivate" xml:space="preserve">
    <value>Activate</value>
  </data>
  <data name="FeatureExfiltrationPointsStatusClosed" xml:space="preserve">
    <value>Closed</value>
  </data>
  <data name="FeatureExfiltrationPointsStatusOpen" xml:space="preserve">
    <value>Open</value>
  </data>
  <data name="FeatureExfiltrationPointsStatusPending" xml:space="preserve">
    <value>Pending</value>
  </data>
  <data name="FeatureExfiltrationPointsStatusRequirement" xml:space="preserve">
    <value>Requirement</value>
  </data>
  <data name="FeatureExfiltrationPointsStatusTimer" xml:space="preserve">
    <value>Timer</value>
  </data>
  <data name="FeatureFeatureWallShootDescription" xml:space="preserve">
    <value>壁/ヘルメット/ベスト/素材を貫通し最大限の貫通力と最小限の逸脱/跳弾で撃つ</value>
  </data>
  <data name="FeatureFovChangerDescription" xml:space="preserve">
    <value>視野角変更 (FOV)</value>
  </data>
  <data name="FeatureFovChangerName" xml:space="preserve">
    <value>fovchanger</value>
  </data>
  <data name="FeatureGameStateDescription" xml:space="preserve">
    <value>他の機能のためにすべてのゲーム情報をリフレッシュ</value>
  </data>
  <data name="FeatureGameStateName" xml:space="preserve">
    <value>gamestate</value>
  </data>
  <data name="FeatureGhostDescription" xml:space="preserve">
    <value>ボットに見つからないようにする</value>
  </data>
  <data name="FeatureGhostName" xml:space="preserve">
    <value>ghost</value>
  </data>
  <data name="FeatureGrenadesDescription" xml:space="preserve">
    <value>手榴弾輪郭表示</value>
  </data>
  <data name="FeatureGrenadesName" xml:space="preserve">
    <value>grenade</value>
  </data>
  <data name="FeatureHealthDescription" xml:space="preserve">
    <value>あらゆるダメージの防止(転倒時も)エネルギーと水分補給を最大に保つ</value>
  </data>
  <data name="FeatureHealthName" xml:space="preserve">
    <value>health</value>
  </data>
  <data name="FeatureHitsDescription" xml:space="preserve">
    <value>ヒットマーカー(ヒット,アーマー,色で設定可能なヘルス)</value>
  </data>
  <data name="FeatureHitsName" xml:space="preserve">
    <value>hits</value>
  </data>
  <data name="FeatureHudCoordinatesFormat" xml:space="preserve">
    <value>({0},{1})</value>
    <comment>X, y</comment>
  </data>
  <data name="FeatureHudDescription" xml:space="preserve">
    <value>HUD(コンパス,弾薬残量/マガジン,射撃モード,座標)</value>
  </data>
  <data name="FeatureHudName" xml:space="preserve">
    <value>hud</value>
  </data>
  <data name="FeatureHudSeparator" xml:space="preserve">
    <value> - </value>
  </data>
  <data name="FeatureHudWeaponFormat" xml:space="preserve">
    <value>{0}+{1}/{2} [{3}]</value>
    <comment>Magazine count, chamber count, magazine capacity, fire-mode</comment>
  </data>
  <data name="FeatureInteractDescription" xml:space="preserve">
    <value>ルートアイテム/ドアとのインタラクション距離を変更</value>
  </data>
  <data name="FeatureInteractName" xml:space="preserve">
    <value>interact</value>
  </data>
  <data name="FeatureLootItemsDescription" xml:space="preserve">
    <value>すべてのルート可能なアイテムをリストアップし名前やレアリティまたはレイド中のゲーム内ウィッシュリストによってアイテムを追跡します(コンテナや死体でも)。trackコマンドとtracklistコマンドを使用して表示をコントロールします</value>
  </data>
  <data name="FeatureLootItemsName" xml:space="preserve">
    <value>loot</value>
  </data>
  <data name="FeatureMapDescription" xml:space="preserve">
    <value>レーダー付きフルスクリーンマップ</value>
  </data>
  <data name="FeatureMapName" xml:space="preserve">
    <value>map</value>
  </data>
  <data name="FeatureNightVisionDescription" xml:space="preserve">
    <value>暗視</value>
  </data>
  <data name="FeatureNightVisionName" xml:space="preserve">
    <value>night</value>
  </data>
  <data name="FeatureNoCollisionDescription" xml:space="preserve">
    <value>銃弾・手榴弾と有刺鉄線の影響を受けない</value>
  </data>
  <data name="FeatureNoCollisionName" xml:space="preserve">
    <value>nocoll</value>
  </data>
  <data name="FeatureNoMalfunctionsDescription" xml:space="preserve">
    <value>武器の誤作動がない：誤射・排莢や給弾の失敗は無い。ボルトの詰まりやオーバーヒートも無い</value>
  </data>
  <data name="FeatureNoMalfunctionsName" xml:space="preserve">
    <value>nomal</value>
  </data>
  <data name="FeatureNoRecoilDescription" xml:space="preserve">
    <value>無反動</value>
  </data>
  <data name="FeatureNoRecoilName" xml:space="preserve">
    <value>norecoil</value>
  </data>
  <data name="FeatureNoSwayDescription" xml:space="preserve">
    <value>揺れない</value>
  </data>
  <data name="FeatureNoSwayName" xml:space="preserve">
    <value>nosway</value>
  </data>
  <data name="FeatureNoVisorDescription" xml:space="preserve">
    <value>バイザーがないため,フェイスシールドバイザーを使用しても見えない</value>
  </data>
  <data name="FeatureNoVisorName" xml:space="preserve">
    <value>novisor</value>
  </data>
  <data name="FeaturePlayersDescription" xml:space="preserve">
    <value>プレイヤー(壁越しにBear/Boss/カルト/Scav/Usecが設定色で見える)。チャーム,ボックス,情報(武器とヘルス),スケルトンと距離</value>
  </data>
  <data name="FeaturePlayersFormat" xml:space="preserve">
    <value>{0} {1}% {2}</value>
    <comment>Weapon name, health %, distance</comment>
  </data>
  <data name="FeaturePlayersName" xml:space="preserve">
    <value>players</value>
  </data>
  <data name="FeaturePointOfInterestsDistanceFormat" xml:space="preserve">
    <value>[{0}m]</value>
    <comment>Distance</comment>
  </data>
  <data name="FeaturePointOfInterestsFormat" xml:space="preserve">
    <value>{0} {1} {2}</value>
    <comment>Name, optional formatted owner, optional formatted distance</comment>
  </data>
  <data name="FeaturePointOfInterestsGroupFormat" xml:space="preserve">
    <value>&gt;&gt; In {0} {1}</value>
    <comment>Owner, distance</comment>
  </data>
  <data name="FeaturePointOfInterestsOwnerFormat" xml:space="preserve">
    <value>(in {0})</value>
    <comment>Owner</comment>
  </data>
  <data name="FeatureQuestsDescription" xml:space="preserve">
    <value>クエストアイテムを取る/置く場所。開始したクエストに関連するアイテムのみ表示されます</value>
  </data>
  <data name="FeatureQuestsFormat" xml:space="preserve">
    <value>{0} ({1})</value>
    <comment>Condition description, quest name</comment>
  </data>
  <data name="FeatureQuestsName" xml:space="preserve">
    <value>quest</value>
  </data>
  <data name="FeatureQuickTrowDescription" xml:space="preserve">
    <value>ワンタッチ手榴弾投擲</value>
  </data>
  <data name="FeatureQuickTrowName" xml:space="preserve">
    <value>quickthrow</value>
  </data>
  <data name="FeatureRadarDescription" xml:space="preserve">
    <value>2Dレーダー</value>
  </data>
  <data name="FeatureRadarName" xml:space="preserve">
    <value>radar</value>
  </data>
  <data name="FeatureRendererSummary" xml:space="preserve">
    <value>[summary]</value>
  </data>
  <data name="FeatureRendererWelcome" xml:space="preserve">
    <value>Welcome to EFT-Trainer !</value>
  </data>
  <data name="FeatureSkillsDescription" xml:space="preserve">
    <value>全スキルをエリートレベル((51)に全武器をレベル3まで習得</value>
  </data>
  <data name="FeatureSkillsName" xml:space="preserve">
    <value>skills</value>
  </data>
  <data name="FeatureSpeedDescription" xml:space="preserve">
    <value>スピードブーストで壁や物体を通り抜けたり,より速く移動できるようになる。自殺しないように注意</value>
  </data>
  <data name="FeatureSpeedName" xml:space="preserve">
    <value>speed</value>
  </data>
  <data name="FeatureStaminaDescription" xml:space="preserve">
    <value>スタミナ無限</value>
  </data>
  <data name="FeatureStaminaName" xml:space="preserve">
    <value>stamina</value>
  </data>
  <data name="FeatureStashDescription" xml:space="preserve">
    <value>埋められた樽,隠しスタッシュ,地面湧き,エアドロップや死体</value>
  </data>
  <data name="FeatureStashName" xml:space="preserve">
    <value>stash</value>
  </data>
  <data name="FeatureThermalVisionDescription" xml:space="preserve">
    <value>サーマルビジョン</value>
  </data>
  <data name="FeatureThermalVisionName" xml:space="preserve">
    <value>thermal</value>
  </data>
  <data name="FeatureTrainDescription" xml:space="preserve">
    <value>リザーブやライトハウスなど互換性のあるマップで列車を召喚する</value>
  </data>
  <data name="FeatureTrainName" xml:space="preserve">
    <value>train</value>
  </data>
  <data name="FeatureWallShootName" xml:space="preserve">
    <value>wallshoot</value>
  </data>
  <data name="FeatureWeatherDescription" xml:space="preserve">
    <value>天候を晴れに変更</value>
  </data>
  <data name="FeatureWeatherName" xml:space="preserve">
    <value>weather</value>
  </data>
  <data name="FeatureWorldInteractiveObjectsDescription" xml:space="preserve">
    <value>ドア/カードリーダー/車両開錠</value>
  </data>
  <data name="FeatureWorldInteractiveObjectsName" xml:space="preserve">
    <value>opener</value>
  </data>
  <data name="PropertyArmorDamageColor" xml:space="preserve">
    <value>アーマーダメージカラー</value>
  </data>
  <data name="PropertyBackward" xml:space="preserve">
    <value>Backward</value>
  </data>
  <data name="PropertyBearColors" xml:space="preserve">
    <value>Bearカラー</value>
  </data>
  <data name="PropertyBorderColor" xml:space="preserve">
    <value>ボーダーカラー</value>
  </data>
  <data name="PropertyBossColors" xml:space="preserve">
    <value>ボスカラー</value>
  </data>
  <data name="PropertyBoxThickness" xml:space="preserve">
    <value>外枠肉厚</value>
  </data>
  <data name="PropertyCacheTimeInSec" xml:space="preserve">
    <value>保持時間(sec)</value>
  </data>
  <data name="PropertyCameraOffset" xml:space="preserve">
    <value>カメラオフセット</value>
  </data>
  <data name="PropertyChangeTime" xml:space="preserve">
    <value>時間変更</value>
  </data>
  <data name="PropertyColor" xml:space="preserve">
    <value>カラー</value>
  </data>
  <data name="PropertyCultistColors" xml:space="preserve">
    <value>カルトカラー</value>
  </data>
  <data name="PropertyDisplayTime" xml:space="preserve">
    <value>時刻表示</value>
  </data>
  <data name="PropertyDistance" xml:space="preserve">
    <value>距離</value>
  </data>
  <data name="PropertyEligibleColor" xml:space="preserve">
    <value>対象カラー</value>
  </data>
  <data name="PropertyEnabled" xml:space="preserve">
    <value>Enabled</value>
  </data>
  <data name="PropertyFadeOutTime" xml:space="preserve">
    <value>フェードアウトタイム</value>
  </data>
  <data name="PropertyFastMode" xml:space="preserve">
    <value>高速モード</value>
  </data>
  <data name="PropertyFastMovementSpeed" xml:space="preserve">
    <value>高速移動速度</value>
  </data>
  <data name="PropertyFoodWater" xml:space="preserve">
    <value>食料 / 水</value>
  </data>
  <data name="PropertyForward" xml:space="preserve">
    <value>Forward</value>
  </data>
  <data name="PropertyFov" xml:space="preserve">
    <value>FOV</value>
  </data>
  <data name="PropertyFovCircleColor" xml:space="preserve">
    <value>視野円カラー</value>
  </data>
  <data name="PropertyFovCircleThickness" xml:space="preserve">
    <value>視野円厚み</value>
  </data>
  <data name="PropertyFovRadius" xml:space="preserve">
    <value>視野円半径</value>
  </data>
  <data name="PropertyFreeLookSensitivity" xml:space="preserve">
    <value>フリールック感度</value>
  </data>
  <data name="PropertyGroupingColor" xml:space="preserve">
    <value>グループカラー</value>
  </data>
  <data name="PropertyHealthDamageColor" xml:space="preserve">
    <value>ヘルスダメージカラー</value>
  </data>
  <data name="PropertyHideWhenAiming" xml:space="preserve">
    <value>照準時に非表示</value>
  </data>
  <data name="PropertyHitMarkerColor" xml:space="preserve">
    <value>ヒットマーカーカラー</value>
  </data>
  <data name="PropertyInfoColor" xml:space="preserve">
    <value>インフォカラー</value>
  </data>
  <data name="PropertyIntensity" xml:space="preserve">
    <value>強度</value>
  </data>
  <data name="PropertyKey" xml:space="preserve">
    <value>Key</value>
  </data>
  <data name="PropertyLeft" xml:space="preserve">
    <value>Left</value>
  </data>
  <data name="PropertyMarksmanColors" xml:space="preserve">
    <value>スナイパーカラー</value>
  </data>
  <data name="PropertyMaximumDistance" xml:space="preserve">
    <value>最大距離</value>
  </data>
  <data name="PropertyMovementSpeed" xml:space="preserve">
    <value>移動速度</value>
  </data>
  <data name="PropertyNotEligibleColor" xml:space="preserve">
    <value>対象外カラー</value>
  </data>
  <data name="PropertyNotShootableColors" xml:space="preserve">
    <value>発砲不可カラー</value>
  </data>
  <data name="PropertyRadarBackground" xml:space="preserve">
    <value>レーダー背景</value>
  </data>
  <data name="PropertyRadarCrosshair" xml:space="preserve">
    <value>レーダー照準線</value>
  </data>
  <data name="PropertyRadarPercentage" xml:space="preserve">
    <value>レーダー大きさ</value>
  </data>
  <data name="PropertyRadarRange" xml:space="preserve">
    <value>レーダー距離</value>
  </data>
  <data name="PropertyRange" xml:space="preserve">
    <value>レンジ</value>
  </data>
  <data name="PropertyRate" xml:space="preserve">
    <value>レート</value>
  </data>
  <data name="PropertyRemoveNegativeEffects" xml:space="preserve">
    <value>悪影響を取り除く</value>
  </data>
  <data name="PropertyRight" xml:space="preserve">
    <value>Right</value>
  </data>
  <data name="PropertyRogueUsecColors" xml:space="preserve">
    <value>ローグUsecカラー</value>
  </data>
  <data name="PropertyScavAssaultColors" xml:space="preserve">
    <value>Scavアサルトカラー</value>
  </data>
  <data name="PropertyScavColors" xml:space="preserve">
    <value>Scavカラー</value>
  </data>
  <data name="PropertyScavRaiderColors" xml:space="preserve">
    <value>Scavレイダーカラー</value>
  </data>
  <data name="PropertySearchInsideContainers" xml:space="preserve">
    <value>コンテナ内検索</value>
  </data>
  <data name="PropertySearchInsideCorpses" xml:space="preserve">
    <value>死体内検索</value>
  </data>
  <data name="PropertyShootableColors" xml:space="preserve">
    <value>射撃可能カラー</value>
  </data>
  <data name="PropertyShowArmorDamage" xml:space="preserve">
    <value>アーマーダメージ表示</value>
  </data>
  <data name="PropertyShowBosses" xml:space="preserve">
    <value>ボス表示</value>
  </data>
  <data name="PropertyShowBoxes" xml:space="preserve">
    <value>外枠表示</value>
  </data>
  <data name="PropertyShowCharms" xml:space="preserve">
    <value>チャーム表示</value>
  </data>
  <data name="PropertyShowCompass" xml:space="preserve">
    <value>コンパス表示</value>
  </data>
  <data name="PropertyShowContainers" xml:space="preserve">
    <value>コンテナ表示</value>
  </data>
  <data name="PropertyShowCoordinates" xml:space="preserve">
    <value>コーディネート表示</value>
  </data>
  <data name="PropertyShowCorpses" xml:space="preserve">
    <value>死体表示</value>
  </data>
  <data name="PropertyShowCultists" xml:space="preserve">
    <value>カルト表示</value>
  </data>
  <data name="PropertyShowEligible" xml:space="preserve">
    <value>対象表示</value>
  </data>
  <data name="PropertyShowFovCircle" xml:space="preserve">
    <value>視野円表示</value>
  </data>
  <data name="PropertyShowHealthDamage" xml:space="preserve">
    <value>ヘルスダメージ表示</value>
  </data>
  <data name="PropertyShowHitMarker" xml:space="preserve">
    <value>ヒットマーカー表示</value>
  </data>
  <data name="PropertyShowInfos" xml:space="preserve">
    <value>インフォ表示</value>
  </data>
  <data name="PropertyShowMap" xml:space="preserve">
    <value>マップ表示</value>
  </data>
  <data name="PropertyShowMarksmen" xml:space="preserve">
    <value>マークスマン表示</value>
  </data>
  <data name="PropertyShowNotEligible" xml:space="preserve">
    <value>対象外表示</value>
  </data>
  <data name="PropertyShowNotShootable" xml:space="preserve">
    <value>射撃不可表示</value>
  </data>
  <data name="PropertyShowPlayers" xml:space="preserve">
    <value>プレーヤー表示</value>
  </data>
  <data name="PropertyShowPrices" xml:space="preserve">
    <value>価格表示</value>
  </data>
  <data name="PropertyShowRogues" xml:space="preserve">
    <value>ローグ表示</value>
  </data>
  <data name="PropertyShowScavAssaults" xml:space="preserve">
    <value>Scavアサルト表示</value>
  </data>
  <data name="PropertyShowScavRaiders" xml:space="preserve">
    <value>Scavレイダー表示</value>
  </data>
  <data name="PropertyShowScavs" xml:space="preserve">
    <value>Scavs表示</value>
  </data>
  <data name="PropertyShowShootable" xml:space="preserve">
    <value>射撃可表示</value>
  </data>
  <data name="PropertyShowSkeletons" xml:space="preserve">
    <value>骨格表示</value>
  </data>
  <data name="PropertySilentAim" xml:space="preserve">
    <value>Silent aim</value>
  </data>
  <data name="PropertySilentAimNextShotDelay" xml:space="preserve">
    <value>Silent aim next-shot-delay</value>
  </data>
  <data name="PropertySilentAimSpeedFactor" xml:space="preserve">
    <value>Silent aim speed-factor</value>
  </data>
  <data name="PropertySize" xml:space="preserve">
    <value>大きさ</value>
  </data>
  <data name="PropertySkeletonThickness" xml:space="preserve">
    <value>骨格厚み</value>
  </data>
  <data name="PropertySmoothness" xml:space="preserve">
    <value>Smoothness</value>
  </data>
  <data name="PropertyStatusFilter" xml:space="preserve">
    <value>Status filter</value>
  </data>
  <data name="PropertyTeleport" xml:space="preserve">
    <value>テレポート</value>
  </data>
  <data name="PropertyThickness" xml:space="preserve">
    <value>厚み</value>
  </data>
  <data name="PropertyTrackedNamesComment" xml:space="preserve">
    <value>例 : ["foo", "bar"] または拡張プロパティ: [{"Name":"foo","Color":[1.0,0.0,0.0,1.0]},{"Name":"bar","Color":[1.0,1.0,1.0,0.8],"Rarity":"Rare"}]</value>
  </data>
  <data name="PropertyTrackWishlist" xml:space="preserve">
    <value>Track Wishlist</value>
  </data>
  <data name="PropertyUsecColors" xml:space="preserve">
    <value>Usecカラー</value>
  </data>
  <data name="PropertyVitalsOnly" xml:space="preserve">
    <value>バイタルのみ</value>
  </data>
  <data name="PropertyX" xml:space="preserve">
    <value>X</value>
  </data>
  <data name="PropertyXRayVision" xml:space="preserve">
    <value>XRay-Vision</value>
  </data>
  <data name="PropertyY" xml:space="preserve">
    <value>Y</value>
  </data>
  <data name="TextOff" xml:space="preserve">
    <value>off</value>
  </data>
  <data name="TextOn" xml:space="preserve">
    <value>on</value>
  </data>
  <data name="TextSeparator" xml:space="preserve">
    <value>------</value>
  </data>
  <data name="ErrorNoBotFound" xml:space="preserve">
    <value>No bot found!</value>
  </data>
  <data name="CommandSpawnBot" xml:space="preserve">
    <value>spawnbot</value>
  </data>
  <data name="ErrorTooManyBotsFormat" xml:space="preserve">
    <value>Found {0} bots, be more specific</value>
    <comment>Bot count &gt; 1</comment>
  </data>
  <data name="CommandSpawnBotEnumerateFormat" xml:space="preserve">
    <value>{0}</value>
  </data>
  <data name="CommandSpawnQuestItems" xml:space="preserve">
    <value>spawnqi</value>
  </data>
  <data name="PropertyTrackAutoWishlist" xml:space="preserve">
    <value>Track Auto Wishlist</value>
  </data>
  <data name="CommandSpawnHideoutItems" xml:space="preserve">
    <value>spawnhi</value>
  </data>
  <data name="FeatureNoFlashName" xml:space="preserve">
    <value>noflash</value>
  </data>
  <data name="FeatureNoFlashDescription" xml:space="preserve">
    <value>閃光手榴弾で持続的な閃光や眼やけの影響を受けない</value>
  </data>
  <data name="FeatureMortarName" xml:space="preserve">
    <value>mortar</value>
  </data>
  <data name="FeatureMortarDescription" xml:space="preserve">
    <value>プレイヤーの位置で迫撃砲による攻撃を発動</value>
  </data>
  <data name="FeatureAirDropName" xml:space="preserve">
    <value>airdrop</value>
  </data>
  <data name="FeatureAirDropDescription" xml:space="preserve">
    <value>プレイヤーの位置でエアドロップを発動</value>
  </data>
</root>

```

`Properties/Strings.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="CommandDump" xml:space="preserve">
    <value>dump</value>
  </data>
  <data name="CommandDumpGameObjects" xml:space="preserve">
    <value>Dumping game objects...</value>
  </data>
  <data name="CommandDumpScenes" xml:space="preserve">
    <value>Dumping Scenes...</value>
  </data>
  <data name="CommandDumpSuccessFormat" xml:space="preserve">
    <value>Dump created in {0}</value>
    <comment>Filename</comment>
  </data>
  <data name="CommandList" xml:space="preserve">
    <value>list</value>
  </data>
  <data name="CommandListEnumerateFormat" xml:space="preserve">
    <value>{0} [{1}] {2}</value>
    <comment>Item name, count, optional rarity</comment>
  </data>
  <data name="CommandListRare" xml:space="preserve">
    <value>listr</value>
  </data>
  <data name="CommandListRarityFormat" xml:space="preserve">
    <value>({0})</value>
    <comment>Rarity</comment>
  </data>
  <data name="CommandListSuccessFormat" xml:space="preserve">
    <value>Found {0} item(s)</value>
    <comment>Item count</comment>
  </data>
  <data name="CommandListSuperRare" xml:space="preserve">
    <value>listsr</value>
  </data>
  <data name="CommandLoadDescription" xml:space="preserve">
    <value>Load settings</value>
  </data>
  <data name="CommandLoadName" xml:space="preserve">
    <value>load</value>
  </data>
  <data name="CommandLoadSuccessFormat" xml:space="preserve">
    <value>Loaded {0}</value>
    <comment>Filename</comment>
  </data>
  <data name="CommandLoadTrackList" xml:space="preserve">
    <value>loadtl</value>
  </data>
  <data name="CommandSaveDescription" xml:space="preserve">
    <value>Save settings</value>
  </data>
  <data name="CommandSaveHeader" xml:space="preserve">
    <value>Be careful when updating this file :)
For keys, use https://docs.unity3d.com/ScriptReference/KeyCode.html
Colors are stored as an array of 'RGBA' floats</value>
  </data>
  <data name="CommandSaveName" xml:space="preserve">
    <value>save</value>
  </data>
  <data name="CommandSaveSuccessFormat" xml:space="preserve">
    <value>Saved {0}</value>
    <comment>Filename</comment>
  </data>
  <data name="CommandSaveTrackList" xml:space="preserve">
    <value>savetl</value>
  </data>
  <data name="CommandSpawn" xml:space="preserve">
    <value>spawn</value>
  </data>
  <data name="CommandStatus" xml:space="preserve">
    <value>status</value>
  </data>
  <data name="CommandStatusTextFormat" xml:space="preserve">
    <value>{0} is {1} {2}</value>
    <comment>Feature name, status, optional toggle text if a key is set</comment>
  </data>
  <data name="CommandStatusTextToggleFormat" xml:space="preserve">
    <value>({0} to toggle)</value>
    <comment>Key</comment>
  </data>
  <data name="CommandTemplate" xml:space="preserve">
    <value>template</value>
  </data>
  <data name="CommandTemplateEnumerateFormat" xml:space="preserve">
    <value>{0}: {1} [{2}]</value>
    <comment>Template id, short-name, name</comment>
  </data>
  <data name="CommandTemplateSuccessFormat" xml:space="preserve">
    <value>Found {0} template(s)</value>
    <comment>Template count</comment>
  </data>
  <data name="CommandTrack" xml:space="preserve">
    <value>track</value>
  </data>
  <data name="CommandTrackList" xml:space="preserve">
    <value>tracklist</value>
  </data>
  <data name="CommandTrackListEnumerateFormat" xml:space="preserve">
    <value>Tracking: {0} {1}</value>
    <comment>Item short-name, optional rarity</comment>
  </data>
  <data name="CommandTrackListRarityFormat" xml:space="preserve">
    <value>({0})</value>
    <comment>Rarity</comment>
  </data>
  <data name="CommandTrackListUpdated" xml:space="preserve">
    <value>Tracking list updated...</value>
  </data>
  <data name="CommandTrackListWishListEnumerateFormat" xml:space="preserve">
    <value>Tracking: {0} (Wishlist)</value>
    <comment>Item short-name</comment>
  </data>
  <data name="CommandTrackRare" xml:space="preserve">
    <value>trackr</value>
  </data>
  <data name="CommandTrackSuperRare" xml:space="preserve">
    <value>tracksr</value>
  </data>
  <data name="CommandUnTrack" xml:space="preserve">
    <value>untrack</value>
  </data>
  <data name="DebugPatchedMethodFormat" xml:space="preserve">
    <value>Patched {0} with {1}</value>
    <comment>Method names</comment>
  </data>
  <data name="DebugPerformanceRefreshedFormat" xml:space="preserve">
    <value>Refreshed {0} in {1}ms</value>
    <comment>Type name, elapsed milliseconds</comment>
  </data>
  <data name="DebugRegisteringCommandFormat" xml:space="preserve">
    <value>Registering {0} command...</value>
    <comment>Command name</comment>
  </data>
  <data name="DebugRegisteringCommandWithArgumentsFormat" xml:space="preserve">
    <value>Registering {0} command with arguments...</value>
    <comment>Command name</comment>
  </data>
  <data name="DirectionEast" xml:space="preserve">
    <value>E</value>
  </data>
  <data name="DirectionNorth" xml:space="preserve">
    <value>N</value>
  </data>
  <data name="DirectionNorthEast" xml:space="preserve">
    <value>NE</value>
  </data>
  <data name="DirectionNorthWest" xml:space="preserve">
    <value>NW</value>
  </data>
  <data name="DirectionSouth" xml:space="preserve">
    <value>S</value>
  </data>
  <data name="DirectionSouthEast" xml:space="preserve">
    <value>SE</value>
  </data>
  <data name="DirectionSouthWest" xml:space="preserve">
    <value>SW</value>
  </data>
  <data name="DirectionWest" xml:space="preserve">
    <value>W</value>
  </data>
  <data name="ErrorCannotFindField" xml:space="preserve">
    <value>Unable to find {0} on {1}</value>
    <comment>Field name, type name</comment>
  </data>
  <data name="ErrorCannotFindOriginalMethodFormat" xml:space="preserve">
    <value>Cannot find original method {0}</value>
    <comment>Method name</comment>
  </data>
  <data name="ErrorCannotFindPostfixMethodFormat" xml:space="preserve">
    <value>Cannot find postfix method {0}</value>
    <comment>Method name</comment>
  </data>
  <data name="ErrorCannotFindPrefixMethodFormat" xml:space="preserve">
    <value>Cannot find prefix method {0}</value>
    <comment>Method name</comment>
  </data>
  <data name="ErrorCannotLoadFormat" xml:space="preserve">
    <value>Unable to load {0}. {1}</value>
    <comment>Filename, error message</comment>
  </data>
  <data name="ErrorCannotSaveFormat" xml:space="preserve">
    <value>Unable to save {0}. {1}</value>
    <comment>Filename, error message</comment>
  </data>
  <data name="ErrorCorruptedFileFormat" xml:space="preserve">
    <value>{0} seems corrupted. Please fix</value>
    <comment>Filename</comment>
  </data>
  <data name="ErrorCorruptedPropertyFormat" xml:space="preserve">
    <value>{0} seems corrupted in {1}. Please fix</value>
    <comment>Key, filename</comment>
  </data>
  <data name="ErrorFailedToCreateItem" xml:space="preserve">
    <value>Failed to create item!</value>
  </data>
  <data name="ErrorFailedToLoadItemBundle" xml:space="preserve">
    <value>Failed to load item bundle!</value>
  </data>
  <data name="ErrorFileNotFoundFormat" xml:space="preserve">
    <value>{0} not found!</value>
    <comment>Filename</comment>
  </data>
  <data name="ErrorInvalidArguments" xml:space="preserve">
    <value>Invalid arguments</value>
  </data>
  <data name="ErrorNoTemplateFound" xml:space="preserve">
    <value>No template found!</value>
  </data>
  <data name="ErrorTooManyTemplatesFormat" xml:space="preserve">
    <value>Found {0} templates, be more specific</value>
    <comment>Template count &gt; 1</comment>
  </data>
  <data name="ErrorUnsupportedTypeFormat" xml:space="preserve">
    <value>Unsupported type: {0}</value>
    <comment>Property type-name</comment>
  </data>
  <data name="FeatureAimbotDescription" xml:space="preserve">
    <value>Aimbot. Automatic aiming and/or shooting (SilentAim).</value>
  </data>
  <data name="FeatureAimbotName" xml:space="preserve">
    <value>aimbot</value>
  </data>
  <data name="FeatureAmmunitionDescription" xml:space="preserve">
    <value>Unlimited ammo.</value>
  </data>
  <data name="FeatureAmmunitionName" xml:space="preserve">
    <value>ammo</value>
  </data>
  <data name="FeatureAutomaticGunDescription" xml:space="preserve">
    <value>Force all guns (even bolt action guns) to use automatic firing mode with customizable fire rate.</value>
  </data>
  <data name="FeatureAutomaticGunName" xml:space="preserve">
    <value>autogun</value>
  </data>
  <data name="FeatureCameraDescription" xml:space="preserve">
    <value>Free camera with fast mode and teleportation.</value>
  </data>
  <data name="FeatureCameraName" xml:space="preserve">
    <value>camera</value>
  </data>
  <data name="FeatureCommandsDescription" xml:space="preserve">
    <value>This main popup window.</value>
  </data>
  <data name="FeatureCommandsName" xml:space="preserve">
    <value>commands</value>
  </data>
  <data name="FeatureCommandsTitle" xml:space="preserve">
    <value>EFT Trainer</value>
  </data>
  <data name="FeatureCrosshairDescription" xml:space="preserve">
    <value>Crosshair with customizable size, color, thickness and auto-hide feature when aiming.</value>
  </data>
  <data name="FeatureCrosshairName" xml:space="preserve">
    <value>crosshair</value>
  </data>
  <data name="FeatureDurabilityDescription" xml:space="preserve">
    <value>Maximum durability of items.</value>
  </data>
  <data name="FeatureDurabilityName" xml:space="preserve">
    <value>durability</value>
  </data>
  <data name="FeatureExamineDescription" xml:space="preserve">
    <value>All items already examined. Instant search.</value>
  </data>
  <data name="FeatureExamineName" xml:space="preserve">
    <value>examine</value>
  </data>
  <data name="FeatureExfiltrationPointsDescription" xml:space="preserve">
    <value>Exfiltration points with customizable colors given eligibility, status filter, distance.</value>
  </data>
  <data name="FeatureExfiltrationPointsEligibleFormat" xml:space="preserve">
    <value>{0} ({1})</value>
    <comment>Name, status</comment>
  </data>
  <data name="FeatureExfiltrationPointsName" xml:space="preserve">
    <value>exfil</value>
  </data>
  <data name="FeatureExfiltrationPointsStatusActivate" xml:space="preserve">
    <value>Activate</value>
  </data>
  <data name="FeatureExfiltrationPointsStatusClosed" xml:space="preserve">
    <value>Closed</value>
  </data>
  <data name="FeatureExfiltrationPointsStatusOpen" xml:space="preserve">
    <value>Open</value>
  </data>
  <data name="FeatureExfiltrationPointsStatusPending" xml:space="preserve">
    <value>Pending</value>
  </data>
  <data name="FeatureExfiltrationPointsStatusRequirement" xml:space="preserve">
    <value>Requirement</value>
  </data>
  <data name="FeatureExfiltrationPointsStatusTimer" xml:space="preserve">
    <value>Timer</value>
  </data>
  <data name="FeatureFeatureWallShootDescription" xml:space="preserve">
    <value>Shoot through wall/helmet/vest/material with maximum penetration and minimal deviation/ricochet.</value>
  </data>
  <data name="FeatureFovChangerDescription" xml:space="preserve">
    <value>Change Field Of View (FOV).</value>
  </data>
  <data name="FeatureFovChangerName" xml:space="preserve">
    <value>fovchanger</value>
  </data>
  <data name="FeatureGameStateDescription" xml:space="preserve">
    <value>Refresh all game information for other features.</value>
  </data>
  <data name="FeatureGameStateName" xml:space="preserve">
    <value>gamestate</value>
  </data>
  <data name="FeatureGhostDescription" xml:space="preserve">
    <value>Stop bots from seeing you.</value>
  </data>
  <data name="FeatureGhostName" xml:space="preserve">
    <value>ghost</value>
  </data>
  <data name="FeatureGrenadesDescription" xml:space="preserve">
    <value>Grenades outline.</value>
  </data>
  <data name="FeatureGrenadesName" xml:space="preserve">
    <value>grenade</value>
  </data>
  <data name="FeatureHealthDescription" xml:space="preserve">
    <value>Full health, prevent any damage (so even when falling), keep energy and hydration at maximum.</value>
  </data>
  <data name="FeatureHealthName" xml:space="preserve">
    <value>health</value>
  </data>
  <data name="FeatureHitsDescription" xml:space="preserve">
    <value>Hit markers (hit, armor, health with configurable colors).</value>
  </data>
  <data name="FeatureHitsName" xml:space="preserve">
    <value>hits</value>
  </data>
  <data name="FeatureHudCoordinatesFormat" xml:space="preserve">
    <value>({0},{1})</value>
    <comment>X, y</comment>
  </data>
  <data name="FeatureHudDescription" xml:space="preserve">
    <value>HUD (compass, ammo left in chamber / magazine, fire mode, coordinates).</value>
  </data>
  <data name="FeatureHudName" xml:space="preserve">
    <value>hud</value>
  </data>
  <data name="FeatureHudSeparator" xml:space="preserve">
    <value> - </value>
  </data>
  <data name="FeatureHudWeaponFormat" xml:space="preserve">
    <value>{0}+{1}/{2} [{3}]</value>
    <comment>Magazine count, chamber count, magazine capacity, fire-mode</comment>
  </data>
  <data name="FeatureInteractDescription" xml:space="preserve">
    <value>Change distance for loot/door interaction.</value>
  </data>
  <data name="FeatureInteractName" xml:space="preserve">
    <value>interact</value>
  </data>
  <data name="FeatureLootItemsDescription" xml:space="preserve">
    <value>List all lootable items and track any item by name or rarity or in-game wishlist in raid (even in containers and corpses). Use track and tracklist commands to control display.</value>
  </data>
  <data name="FeatureLootItemsName" xml:space="preserve">
    <value>loot</value>
  </data>
  <data name="FeatureMapDescription" xml:space="preserve">
    <value>Full screen map with radar esp.</value>
  </data>
  <data name="FeatureMapName" xml:space="preserve">
    <value>map</value>
  </data>
  <data name="FeatureNightVisionDescription" xml:space="preserve">
    <value>Night vision.</value>
  </data>
  <data name="FeatureNightVisionName" xml:space="preserve">
    <value>night</value>
  </data>
  <data name="FeatureNoCollisionDescription" xml:space="preserve">
    <value>No physical collisions, making you immune to bullets, grenades and barbed wires.</value>
  </data>
  <data name="FeatureNoCollisionName" xml:space="preserve">
    <value>nocoll</value>
  </data>
  <data name="FeatureNoMalfunctionsDescription" xml:space="preserve">
    <value>No weapon malfunctions: no misfires or failures to eject or feed. No jammed bolts or overheating.</value>
  </data>
  <data name="FeatureNoMalfunctionsName" xml:space="preserve">
    <value>nomal</value>
  </data>
  <data name="FeatureNoRecoilDescription" xml:space="preserve">
    <value>No recoil.</value>
  </data>
  <data name="FeatureNoRecoilName" xml:space="preserve">
    <value>norecoil</value>
  </data>
  <data name="FeatureNoSwayDescription" xml:space="preserve">
    <value>No sway.</value>
  </data>
  <data name="FeatureNoSwayName" xml:space="preserve">
    <value>nosway</value>
  </data>
  <data name="FeatureNoVisorDescription" xml:space="preserve">
    <value>No visor, so even when using a face shield-visor you won't see it.</value>
  </data>
  <data name="FeatureNoVisorName" xml:space="preserve">
    <value>novisor</value>
  </data>
  <data name="FeaturePlayersDescription" xml:space="preserve">
    <value>Players (you'll see Bear/Boss/Cultist/Scav/Usec with configurable colors through walls). Charms, boxes, info (weapon and health), skeletons and distance.</value>
  </data>
  <data name="FeaturePlayersFormat" xml:space="preserve">
    <value>{0} {1}% {2}</value>
    <comment>Weapon name, health %, distance</comment>
  </data>
  <data name="FeaturePlayersName" xml:space="preserve">
    <value>players</value>
  </data>
  <data name="FeaturePointOfInterestsDistanceFormat" xml:space="preserve">
    <value>[{0}m]</value>
    <comment>Distance</comment>
  </data>
  <data name="FeaturePointOfInterestsFormat" xml:space="preserve">
    <value>{0} {1} {2}</value>
    <comment>Name, optional formatted owner, optional formatted distance</comment>
  </data>
  <data name="FeaturePointOfInterestsGroupFormat" xml:space="preserve">
    <value>&gt;&gt; In {0} {1}</value>
    <comment>Owner, distance</comment>
  </data>
  <data name="FeaturePointOfInterestsOwnerFormat" xml:space="preserve">
    <value>(in {0})</value>
    <comment>Owner</comment>
  </data>
  <data name="FeatureQuestsDescription" xml:space="preserve">
    <value>Locations for taking/placing quest items. Only items related to your started quests are displayed.</value>
  </data>
  <data name="FeatureQuestsFormat" xml:space="preserve">
    <value>{0} ({1})</value>
    <comment>Condition description, quest name</comment>
  </data>
  <data name="FeatureQuestsName" xml:space="preserve">
    <value>quest</value>
  </data>
  <data name="FeatureQuickTrowDescription" xml:space="preserve">
    <value>Quick-throw grenades.</value>
  </data>
  <data name="FeatureQuickTrowName" xml:space="preserve">
    <value>quickthrow</value>
  </data>
  <data name="FeatureRadarDescription" xml:space="preserve">
    <value>2D radar.</value>
  </data>
  <data name="FeatureRadarName" xml:space="preserve">
    <value>radar</value>
  </data>
  <data name="FeatureRendererSummary" xml:space="preserve">
    <value>[summary]</value>
  </data>
  <data name="FeatureRendererWelcome" xml:space="preserve">
    <value>Welcome to EFT-Trainer !</value>
  </data>
  <data name="FeatureSkillsDescription" xml:space="preserve">
    <value>All skills to Elite level (51) and all weapons mastering to level 3.</value>
  </data>
  <data name="FeatureSkillsName" xml:space="preserve">
    <value>skills</value>
  </data>
  <data name="FeatureSpeedDescription" xml:space="preserve">
    <value>Speed boost to be able to go through walls/objects, or to move faster. Be careful to not kill yourself.</value>
  </data>
  <data name="FeatureSpeedName" xml:space="preserve">
    <value>speed</value>
  </data>
  <data name="FeatureStaminaDescription" xml:space="preserve">
    <value>Unlimited stamina.</value>
  </data>
  <data name="FeatureStaminaName" xml:space="preserve">
    <value>stamina</value>
  </data>
  <data name="FeatureStashDescription" xml:space="preserve">
    <value>Hidden/special stashes like buried barrels, ground caches, air drops or corpses.</value>
  </data>
  <data name="FeatureStashName" xml:space="preserve">
    <value>stash</value>
  </data>
  <data name="FeatureThermalVisionDescription" xml:space="preserve">
    <value>Thermal vision.</value>
  </data>
  <data name="FeatureThermalVisionName" xml:space="preserve">
    <value>thermal</value>
  </data>
  <data name="FeatureTrainDescription" xml:space="preserve">
    <value>Summon train on compatible maps like Reserve or Lighthouse.</value>
  </data>
  <data name="FeatureTrainName" xml:space="preserve">
    <value>train</value>
  </data>
  <data name="FeatureWallShootName" xml:space="preserve">
    <value>wallshoot</value>
  </data>
  <data name="FeatureWeatherDescription" xml:space="preserve">
    <value>Clear weather.</value>
  </data>
  <data name="FeatureWeatherName" xml:space="preserve">
    <value>weather</value>
  </data>
  <data name="FeatureWorldInteractiveObjectsDescription" xml:space="preserve">
    <value>Door/Keycard reader/Car unlocker.</value>
  </data>
  <data name="FeatureWorldInteractiveObjectsName" xml:space="preserve">
    <value>opener</value>
  </data>
  <data name="PropertyArmorDamageColor" xml:space="preserve">
    <value>Armor-damage color</value>
  </data>
  <data name="PropertyBackward" xml:space="preserve">
    <value>Backward</value>
  </data>
  <data name="PropertyBearColors" xml:space="preserve">
    <value>Bear colors</value>
  </data>
  <data name="PropertyBorderColor" xml:space="preserve">
    <value>Border color</value>
  </data>
  <data name="PropertyBossColors" xml:space="preserve">
    <value>Boss colors</value>
  </data>
  <data name="PropertyBoxThickness" xml:space="preserve">
    <value>Box thickness</value>
  </data>
  <data name="PropertyCacheTimeInSec" xml:space="preserve">
    <value>Cache time (sec)</value>
  </data>
  <data name="PropertyCameraOffset" xml:space="preserve">
    <value>Camera offset</value>
  </data>
  <data name="PropertyChangeTime" xml:space="preserve">
    <value>Change time</value>
  </data>
  <data name="PropertyColor" xml:space="preserve">
    <value>Color</value>
  </data>
  <data name="PropertyCultistColors" xml:space="preserve">
    <value>Cultist colors</value>
  </data>
  <data name="PropertyDisplayTime" xml:space="preserve">
    <value>Display time</value>
  </data>
  <data name="PropertyDistance" xml:space="preserve">
    <value>Distance</value>
  </data>
  <data name="PropertyEligibleColor" xml:space="preserve">
    <value>Eligible color</value>
  </data>
  <data name="PropertyEnabled" xml:space="preserve">
    <value>Enabled</value>
  </data>
  <data name="PropertyFadeOutTime" xml:space="preserve">
    <value>Fade-out time</value>
  </data>
  <data name="PropertyFastMode" xml:space="preserve">
    <value>Fast mode</value>
  </data>
  <data name="PropertyFastMovementSpeed" xml:space="preserve">
    <value>Fast movement speed</value>
  </data>
  <data name="PropertyFoodWater" xml:space="preserve">
    <value>Food / water</value>
  </data>
  <data name="PropertyForward" xml:space="preserve">
    <value>Forward</value>
  </data>
  <data name="PropertyFov" xml:space="preserve">
    <value>FOV</value>
  </data>
  <data name="PropertyFovCircleColor" xml:space="preserve">
    <value>FOV circle color</value>
  </data>
  <data name="PropertyFovCircleThickness" xml:space="preserve">
    <value>FOV circle thickness</value>
  </data>
  <data name="PropertyFovRadius" xml:space="preserve">
    <value>FOV radius</value>
  </data>
  <data name="PropertyFreeLookSensitivity" xml:space="preserve">
    <value>Free look sensitivity</value>
  </data>
  <data name="PropertyGroupingColor" xml:space="preserve">
    <value>Grouping Color</value>
  </data>
  <data name="PropertyHealthDamageColor" xml:space="preserve">
    <value>Health-damage color</value>
  </data>
  <data name="PropertyHideWhenAiming" xml:space="preserve">
    <value>Hide when aiming</value>
  </data>
  <data name="PropertyHitMarkerColor" xml:space="preserve">
    <value>Hit-marker color</value>
  </data>
  <data name="PropertyInfoColor" xml:space="preserve">
    <value>Info color</value>
  </data>
  <data name="PropertyIntensity" xml:space="preserve">
    <value>Intensity</value>
  </data>
  <data name="PropertyKey" xml:space="preserve">
    <value>Key</value>
  </data>
  <data name="PropertyLeft" xml:space="preserve">
    <value>Left</value>
  </data>
  <data name="PropertyMarksmanColors" xml:space="preserve">
    <value>Marksman colors</value>
  </data>
  <data name="PropertyMaximumDistance" xml:space="preserve">
    <value>Maximum distance</value>
  </data>
  <data name="PropertyMovementSpeed" xml:space="preserve">
    <value>Movement speed</value>
  </data>
  <data name="PropertyNotEligibleColor" xml:space="preserve">
    <value>Not eligible color</value>
  </data>
  <data name="PropertyNotShootableColors" xml:space="preserve">
    <value>Not shootable colors</value>
  </data>
  <data name="PropertyRadarBackground" xml:space="preserve">
    <value>Radar background</value>
  </data>
  <data name="PropertyRadarCrosshair" xml:space="preserve">
    <value>Radar crosshair</value>
  </data>
  <data name="PropertyRadarPercentage" xml:space="preserve">
    <value>Radar percentage</value>
  </data>
  <data name="PropertyRadarRange" xml:space="preserve">
    <value>Radar range</value>
  </data>
  <data name="PropertyRange" xml:space="preserve">
    <value>Range</value>
  </data>
  <data name="PropertyRate" xml:space="preserve">
    <value>Rate</value>
  </data>
  <data name="PropertyRemoveNegativeEffects" xml:space="preserve">
    <value>Remove negative effects</value>
  </data>
  <data name="PropertyRight" xml:space="preserve">
    <value>Right</value>
  </data>
  <data name="PropertyRogueUsecColors" xml:space="preserve">
    <value>Rogue-Usec colors</value>
  </data>
  <data name="PropertyScavAssaultColors" xml:space="preserve">
    <value>Scav-assault colors</value>
  </data>
  <data name="PropertyScavColors" xml:space="preserve">
    <value>Scav colors</value>
  </data>
  <data name="PropertyScavRaiderColors" xml:space="preserve">
    <value>Scav-raider colors</value>
  </data>
  <data name="PropertySearchInsideContainers" xml:space="preserve">
    <value>Search inside containers</value>
  </data>
  <data name="PropertySearchInsideCorpses" xml:space="preserve">
    <value>Search inside corpses</value>
  </data>
  <data name="PropertyShootableColors" xml:space="preserve">
    <value>Shootable colors</value>
  </data>
  <data name="PropertyShowArmorDamage" xml:space="preserve">
    <value>Show armor damage</value>
  </data>
  <data name="PropertyShowBosses" xml:space="preserve">
    <value>Show Bosses</value>
  </data>
  <data name="PropertyShowBoxes" xml:space="preserve">
    <value>Show boxes</value>
  </data>
  <data name="PropertyShowCharms" xml:space="preserve">
    <value>Show charms</value>
  </data>
  <data name="PropertyShowCompass" xml:space="preserve">
    <value>Show compass</value>
  </data>
  <data name="PropertyShowContainers" xml:space="preserve">
    <value>Show containers</value>
  </data>
  <data name="PropertyShowCoordinates" xml:space="preserve">
    <value>Show coordinates</value>
  </data>
  <data name="PropertyShowCorpses" xml:space="preserve">
    <value>Show corpses</value>
  </data>
  <data name="PropertyShowCultists" xml:space="preserve">
    <value>Show Cultists</value>
  </data>
  <data name="PropertyShowEligible" xml:space="preserve">
    <value>Show eligible</value>
  </data>
  <data name="PropertyShowFovCircle" xml:space="preserve">
    <value>Show fov circle</value>
  </data>
  <data name="PropertyShowHealthDamage" xml:space="preserve">
    <value>Show health-damage</value>
  </data>
  <data name="PropertyShowHitMarker" xml:space="preserve">
    <value>Show Hit-marker</value>
  </data>
  <data name="PropertyShowInfos" xml:space="preserve">
    <value>Show infos</value>
  </data>
  <data name="PropertyShowMap" xml:space="preserve">
    <value>Show map</value>
  </data>
  <data name="PropertyShowMarksmen" xml:space="preserve">
    <value>Show Marksmen</value>
  </data>
  <data name="PropertyShowNotEligible" xml:space="preserve">
    <value>Show not eligible</value>
  </data>
  <data name="PropertyShowNotShootable" xml:space="preserve">
    <value>Show not shootable</value>
  </data>
  <data name="PropertyShowPlayers" xml:space="preserve">
    <value>Show players</value>
  </data>
  <data name="PropertyShowPrices" xml:space="preserve">
    <value>Show prices</value>
  </data>
  <data name="PropertyShowRogues" xml:space="preserve">
    <value>Show Rogues</value>
  </data>
  <data name="PropertyShowScavAssaults" xml:space="preserve">
    <value>Show Scav-assaults</value>
  </data>
  <data name="PropertyShowScavRaiders" xml:space="preserve">
    <value>Show Scav-raiders</value>
  </data>
  <data name="PropertyShowScavs" xml:space="preserve">
    <value>Show Scavs</value>
  </data>
  <data name="PropertyShowShootable" xml:space="preserve">
    <value>Show shootable</value>
  </data>
  <data name="PropertyShowSkeletons" xml:space="preserve">
    <value>Show skeletons</value>
  </data>
  <data name="PropertySilentAim" xml:space="preserve">
    <value>Silent aim</value>
  </data>
  <data name="PropertySilentAimNextShotDelay" xml:space="preserve">
    <value>Silent aim next-shot-delay</value>
  </data>
  <data name="PropertySilentAimSpeedFactor" xml:space="preserve">
    <value>Silent aim speed-factor</value>
  </data>
  <data name="PropertySize" xml:space="preserve">
    <value>Size</value>
  </data>
  <data name="PropertySkeletonThickness" xml:space="preserve">
    <value>Skeleton thickness</value>
  </data>
  <data name="PropertySmoothness" xml:space="preserve">
    <value>Smoothness</value>
  </data>
  <data name="PropertyStatusFilter" xml:space="preserve">
    <value>Status filter</value>
  </data>
  <data name="PropertyTeleport" xml:space="preserve">
    <value>Teleport</value>
  </data>
  <data name="PropertyThickness" xml:space="preserve">
    <value>Thickness</value>
  </data>
  <data name="PropertyTrackedNamesComment" xml:space="preserve">
    <value>Example: ["foo", "bar"] or with extended properties: [{"Name":"foo","Color":[1.0,0.0,0.0,1.0]},{"Name":"bar","Color":[1.0,1.0,1.0,0.8],"Rarity":"Rare"}]</value>
  </data>
  <data name="PropertyTrackWishlist" xml:space="preserve">
    <value>Track Wishlist</value>
  </data>
  <data name="PropertyUsecColors" xml:space="preserve">
    <value>Usec colors</value>
  </data>
  <data name="PropertyVitalsOnly" xml:space="preserve">
    <value>Vitals only</value>
  </data>
  <data name="PropertyX" xml:space="preserve">
    <value>X</value>
  </data>
  <data name="PropertyXRayVision" xml:space="preserve">
    <value>XRay-Vision</value>
  </data>
  <data name="PropertyY" xml:space="preserve">
    <value>Y</value>
  </data>
  <data name="TextOff" xml:space="preserve">
    <value>off</value>
  </data>
  <data name="TextOn" xml:space="preserve">
    <value>on</value>
  </data>
  <data name="TextSeparator" xml:space="preserve">
    <value>------</value>
  </data>
  <data name="ErrorNoBotFound" xml:space="preserve">
    <value>No bot found!</value>
  </data>
  <data name="CommandSpawnBot" xml:space="preserve">
    <value>spawnbot</value>
  </data>
  <data name="ErrorTooManyBotsFormat" xml:space="preserve">
    <value>Found {0} bots, be more specific</value>
    <comment>Bot count &gt; 1</comment>
  </data>
  <data name="CommandSpawnBotEnumerateFormat" xml:space="preserve">
    <value>{0}</value>
  </data>
  <data name="CommandSpawnQuestItems" xml:space="preserve">
    <value>spawnqi</value>
  </data>
  <data name="PropertyTrackAutoWishlist" xml:space="preserve">
    <value>Track Auto Wishlist</value>
  </data>
  <data name="CommandSpawnHideoutItems" xml:space="preserve">
    <value>spawnhi</value>
  </data>
  <data name="FeatureNoFlashName" xml:space="preserve">
    <value>noflash</value>
  </data>
  <data name="FeatureNoFlashDescription" xml:space="preserve">
    <value>No persistent flash or eye-burn effect after a flash grenade.</value>
  </data>
  <data name="FeatureMortarName" xml:space="preserve">
    <value>mortar</value>
  </data>
  <data name="FeatureMortarDescription" xml:space="preserve">
    <value>Triggers a mortar strike at the player's location.</value>
  </data>
  <data name="FeatureAirDropName" xml:space="preserve">
    <value>airdrop</value>
  </data>
  <data name="FeatureAirDropDescription" xml:space="preserve">
    <value>Triggers an airdrop at the player's location.</value>
  </data>
  <data name="PropertyElevationAdjustment" xml:space="preserve">
    <value>Elevation adjustment</value>
  </data>
</root>
```

`Properties/Strings.zh-cn.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="CommandDump" xml:space="preserve">
    <value>dump</value>
  </data>
  <data name="CommandDumpGameObjects" xml:space="preserve">
    <value>分析游戏对象…</value>
  </data>
  <data name="CommandDumpScenes" xml:space="preserve">
    <value>场景分析…</value>
  </data>
  <data name="CommandDumpSuccessFormat" xml:space="preserve">
    <value>创建分析在 {0}</value>
    <comment>Filename</comment>
  </data>
  <data name="CommandList" xml:space="preserve">
    <value>list</value>
  </data>
  <data name="CommandListEnumerateFormat" xml:space="preserve">
    <value>{0} [{1}] {2}</value>
    <comment>Item name, count, optional rarity</comment>
  </data>
  <data name="CommandListRare" xml:space="preserve">
    <value>listr</value>
  </data>
  <data name="CommandListRarityFormat" xml:space="preserve">
    <value>({0})</value>
    <comment>Rarity</comment>
  </data>
  <data name="CommandListSuccessFormat" xml:space="preserve">
    <value>找到 {0} 项</value>
    <comment>Item count</comment>
  </data>
  <data name="CommandListSuperRare" xml:space="preserve">
    <value>listsr</value>
  </data>
  <data name="CommandLoadDescription" xml:space="preserve">
    <value>加载设置</value>
  </data>
  <data name="CommandLoadName" xml:space="preserve">
    <value>load</value>
  </data>
  <data name="CommandLoadSuccessFormat" xml:space="preserve">
    <value>加载成功 {0}</value>
    <comment>Filename</comment>
  </data>
  <data name="CommandLoadTrackList" xml:space="preserve">
    <value>loadtl</value>
  </data>
  <data name="CommandSaveDescription" xml:space="preserve">
    <value>保存设置</value>
  </data>
  <data name="CommandSaveHeader" xml:space="preserve">
    <value>在更新此文件时要小心 :)
对于键码，请使用https：//docs.unity3d.com/ScriptReference/KeyCode.html
颜色以“RGBA”浮点数数组的形式存储。</value>
  </data>
  <data name="CommandSaveName" xml:space="preserve">
    <value>save</value>
  </data>
  <data name="CommandSaveSuccessFormat" xml:space="preserve">
    <value>保存成功 {0}</value>
    <comment>Filename</comment>
  </data>
  <data name="CommandSaveTrackList" xml:space="preserve">
    <value>savetl</value>
  </data>
  <data name="CommandSpawn" xml:space="preserve">
    <value>spawn</value>
  </data>
  <data name="CommandStatus" xml:space="preserve">
    <value>status</value>
  </data>
  <data name="CommandStatusTextFormat" xml:space="preserve">
    <value>{0} 已 {1} {2}</value>
    <comment>Feature name, status, optional toggle text if a key is set</comment>
  </data>
  <data name="CommandStatusTextToggleFormat" xml:space="preserve">
    <value>({0} 切换)</value>
    <comment>Key</comment>
  </data>
  <data name="CommandTemplate" xml:space="preserve">
    <value>template</value>
  </data>
  <data name="CommandTemplateEnumerateFormat" xml:space="preserve">
    <value>{0}: {1} [{2}]</value>
    <comment>Template id, short-name, name</comment>
  </data>
  <data name="CommandTemplateSuccessFormat" xml:space="preserve">
    <value>找到 {0} 模板</value>
    <comment>Template count</comment>
  </data>
  <data name="CommandTrack" xml:space="preserve">
    <value>track</value>
  </data>
  <data name="CommandTrackList" xml:space="preserve">
    <value>tracklist</value>
  </data>
  <data name="CommandTrackListEnumerateFormat" xml:space="preserve">
    <value>跟踪物品: {0} {1}</value>
    <comment>Item short-name, optional rarity</comment>
  </data>
  <data name="CommandTrackListRarityFormat" xml:space="preserve">
    <value>({0})</value>
    <comment>Rarity</comment>
  </data>
  <data name="CommandTrackListUpdated" xml:space="preserve">
    <value>跟踪物品列表更新…</value>
  </data>
  <data name="CommandTrackListWishListEnumerateFormat" xml:space="preserve">
    <value>跟踪物品: {0} (愿望列表)</value>
    <comment>Item short-name</comment>
  </data>
  <data name="CommandTrackRare" xml:space="preserve">
    <value>trackr</value>
  </data>
  <data name="CommandTrackSuperRare" xml:space="preserve">
    <value>tracksr</value>
  </data>
  <data name="CommandUnTrack" xml:space="preserve">
    <value>untrack</value>
  </data>
  <data name="DebugPatchedMethodFormat" xml:space="preserve">
    <value>使用 {1} 修改 {0}</value>
    <comment>Method names</comment>
  </data>
  <data name="DebugPerformanceRefreshedFormat" xml:space="preserve">
    <value>刷新 {0} 在 {1} ms</value>
    <comment>Type name, elapsed milliseconds</comment>
  </data>
  <data name="DebugRegisteringCommandFormat" xml:space="preserve">
    <value>正在注册 {0} 命令…</value>
    <comment>Command name</comment>
  </data>
  <data name="DebugRegisteringCommandWithArgumentsFormat" xml:space="preserve">
    <value>注册带有参数的 {0} 命令…</value>
    <comment>Command name</comment>
  </data>
  <data name="DirectionEast" xml:space="preserve">
    <value>东</value>
  </data>
  <data name="DirectionNorth" xml:space="preserve">
    <value>北</value>
  </data>
  <data name="DirectionNorthEast" xml:space="preserve">
    <value>东北</value>
  </data>
  <data name="DirectionNorthWest" xml:space="preserve">
    <value>西北</value>
  </data>
  <data name="DirectionSouth" xml:space="preserve">
    <value>南</value>
  </data>
  <data name="DirectionSouthEast" xml:space="preserve">
    <value>东南</value>
  </data>
  <data name="DirectionSouthWest" xml:space="preserve">
    <value>西南</value>
  </data>
  <data name="DirectionWest" xml:space="preserve">
    <value>西</value>
  </data>
  <data name="ErrorCannotFindField" xml:space="preserve">
    <value>无法在 {1} 上找到 {0}</value>
    <comment>Field name, type name</comment>
  </data>
  <data name="ErrorCannotFindOriginalMethodFormat" xml:space="preserve">
    <value>找不到原始方法 {0}</value>
    <comment>Method name</comment>
  </data>
  <data name="ErrorCannotFindPostfixMethodFormat" xml:space="preserve">
    <value>找不到后缀方法 {0}</value>
    <comment>Method name</comment>
  </data>
  <data name="ErrorCannotFindPrefixMethodFormat" xml:space="preserve">
    <value>找不到前缀方法 {0}</value>
    <comment>Method name</comment>
  </data>
  <data name="ErrorCannotLoadFormat" xml:space="preserve">
    <value>无法加载 {0}. {1}</value>
    <comment>Filename, error message</comment>
  </data>
  <data name="ErrorCannotSaveFormat" xml:space="preserve">
    <value>无法保存 {0}. {1}</value>
    <comment>Filename, error message</comment>
  </data>
  <data name="ErrorCorruptedFileFormat" xml:space="preserve">
    <value>{0} 似乎已损坏。请修复</value>
    <comment>Filename</comment>
  </data>
  <data name="ErrorCorruptedPropertyFormat" xml:space="preserve">
    <value>{0} 似乎在 {1} 中损坏了。请修复</value>
    <comment>Key, filename</comment>
  </data>
  <data name="ErrorFailedToCreateItem" xml:space="preserve">
    <value>无法创建对象!</value>
  </data>
  <data name="ErrorFailedToLoadItemBundle" xml:space="preserve">
    <value>无法加载包!</value>
  </data>
  <data name="ErrorFileNotFoundFormat" xml:space="preserve">
    <value>找不到 {0} !</value>
    <comment>Filename</comment>
  </data>
  <data name="ErrorInvalidArguments" xml:space="preserve">
    <value>无效的参数</value>
  </data>
  <data name="ErrorNoTemplateFound" xml:space="preserve">
    <value>没有找到模板!</value>
  </data>
  <data name="ErrorTooManyTemplatesFormat" xml:space="preserve">
    <value>找到 {0} 模板，试着更具体一点</value>
    <comment>Template count &gt; 1</comment>
  </data>
  <data name="ErrorUnsupportedTypeFormat" xml:space="preserve">
    <value>不支持的类型: {0}</value>
    <comment>Property type-name</comment>
  </data>
  <data name="FeatureAimbotDescription" xml:space="preserve">
    <value>瞄准机器人。自动瞄准和/或射击（SilentAim）</value>
  </data>
  <data name="FeatureAimbotName" xml:space="preserve">
    <value>自动瞄准</value>
  </data>
  <data name="FeatureAmmunitionDescription" xml:space="preserve">
    <value>武器无限弹药</value>
  </data>
  <data name="FeatureAmmunitionName" xml:space="preserve">
    <value>无限弹药</value>
  </data>
  <data name="FeatureAutomaticGunDescription" xml:space="preserve">
    <value>强制所有武器(甚至是栓动步枪)使用具有可定制射击速度的自动射击模式。</value>
  </data>
  <data name="FeatureAutomaticGunName" xml:space="preserve">
    <value>全自动射击</value>
  </data>
  <data name="FeatureCameraDescription" xml:space="preserve">
    <value>自由视角具有快速移动模式和传送等功能。</value>
  </data>
  <data name="FeatureCameraName" xml:space="preserve">
    <value>自由视角</value>
  </data>
  <data name="FeatureCommandsDescription" xml:space="preserve">
    <value>本功能窗口</value>
  </data>
  <data name="FeatureCommandsName" xml:space="preserve">
    <value>功能窗口</value>
  </data>
  <data name="FeatureCommandsTitle" xml:space="preserve">
    <value>EFT Trainer</value>
  </data>
  <data name="FeatureCrosshairDescription" xml:space="preserve">
    <value>瞄准时可定制尺寸、颜色、厚度和自动隐藏功能的准星。</value>
  </data>
  <data name="FeatureCrosshairName" xml:space="preserve">
    <value>准星</value>
  </data>
  <data name="FeatureDurabilityDescription" xml:space="preserve">
    <value>物品满耐久</value>
  </data>
  <data name="FeatureDurabilityName" xml:space="preserve">
    <value>满耐久</value>
  </data>
  <data name="FeatureExamineDescription" xml:space="preserve">
    <value>等同于容器内所有的东西都已经搜索过。立刻搜索完成容器。</value>
  </data>
  <data name="FeatureExamineName" xml:space="preserve">
    <value>快速搜索</value>
  </data>
  <data name="FeatureExfiltrationPointsDescription" xml:space="preserve">
    <value>撤离点具有自定义颜色,根据角色的撤离资格显示，状态过滤器，距离等功能。</value>
  </data>
  <data name="FeatureExfiltrationPointsEligibleFormat" xml:space="preserve">
    <value>{0} ({1})</value>
    <comment>Name, status</comment>
  </data>
  <data name="FeatureExfiltrationPointsName" xml:space="preserve">
    <value>撤离点</value>
  </data>
  <data name="FeatureExfiltrationPointsStatusActivate" xml:space="preserve">
    <value>激活</value>
  </data>
  <data name="FeatureExfiltrationPointsStatusClosed" xml:space="preserve">
    <value>关闭</value>
  </data>
  <data name="FeatureExfiltrationPointsStatusOpen" xml:space="preserve">
    <value>开放</value>
  </data>
  <data name="FeatureExfiltrationPointsStatusPending" xml:space="preserve">
    <value>待定</value>
  </data>
  <data name="FeatureExfiltrationPointsStatusRequirement" xml:space="preserve">
    <value>条件</value>
  </data>
  <data name="FeatureExfiltrationPointsStatusTimer" xml:space="preserve">
    <value>Timer</value>
  </data>
  <data name="FeatureFeatureWallShootDescription" xml:space="preserve">
    <value>能够射穿墙壁/头盔/背心/任意材料，且穿透力最大，弹道偏差/弹跳几率最小。</value>
  </data>
  <data name="FeatureFovChangerDescription" xml:space="preserve">
    <value>更改视野范围(FOV)。</value>
  </data>
  <data name="FeatureFovChangerName" xml:space="preserve">
    <value>更改FOV</value>
  </data>
  <data name="FeatureGameStateDescription" xml:space="preserve">
    <value>刷新所有其他功能的游戏信息。</value>
  </data>
  <data name="FeatureGameStateName" xml:space="preserve">
    <value>游戏状态</value>
  </data>
  <data name="FeatureGhostDescription" xml:space="preserve">
    <value>机器人将无视你。</value>
  </data>
  <data name="FeatureGhostName" xml:space="preserve">
    <value>幽灵模式</value>
  </data>
  <data name="FeatureGrenadesDescription" xml:space="preserve">
    <value>显示手榴弹轮廓。</value>
  </data>
  <data name="FeatureGrenadesName" xml:space="preserve">
    <value>手榴弹轮廓</value>
  </data>
  <data name="FeatureHealthDescription" xml:space="preserve">
    <value>生命值保持满血状态，免疫任何伤害(即使是摔倒时)，具有保持能量和水分在最大限度功能</value>
  </data>
  <data name="FeatureHealthName" xml:space="preserve">
    <value>无敌</value>
  </data>
  <data name="FeatureHitsDescription" xml:space="preserve">
    <value>命中反馈(命中、护甲、生命值，颜色可配置)。</value>
  </data>
  <data name="FeatureHitsName" xml:space="preserve">
    <value>命中反馈</value>
  </data>
  <data name="FeatureHudCoordinatesFormat" xml:space="preserve">
    <value>({0},{1})</value>
    <comment>X, y</comment>
  </data>
  <data name="FeatureHudDescription" xml:space="preserve">
    <value>HUD(指南针，剩余弹药，射击模式，坐标)。</value>
  </data>
  <data name="FeatureHudName" xml:space="preserve">
    <value>HUD</value>
  </data>
  <data name="FeatureHudSeparator" xml:space="preserve">
    <value> - </value>
  </data>
  <data name="FeatureHudWeaponFormat" xml:space="preserve">
    <value>{0}+{1}/{2} [{3}]</value>
    <comment>Magazine count, chamber count, magazine capacity, fire-mode</comment>
  </data>
  <data name="FeatureInteractDescription" xml:space="preserve">
    <value>改变与容器和门等可交互物品交互的距离。</value>
  </data>
  <data name="FeatureInteractName" xml:space="preserve">
    <value>修改交互距离</value>
  </data>
  <data name="FeatureLootItemsDescription" xml:space="preserve">
    <value>列出所有可掠夺的物品，并在raid中根据名称或稀有程度或游戏内的愿望列表跟踪任何物品(甚至在容器和尸体中)。使用track和tracklist命令来控制显示。</value>
  </data>
  <data name="FeatureLootItemsName" xml:space="preserve">
    <value>战利品追踪</value>
  </data>
  <data name="FeatureMapDescription" xml:space="preserve">
    <value>全屏雷达地图。</value>
  </data>
  <data name="FeatureMapName" xml:space="preserve">
    <value>地图</value>
  </data>
  <data name="FeatureNightVisionDescription" xml:space="preserve">
    <value>夜视仪视角。</value>
  </data>
  <data name="FeatureNightVisionName" xml:space="preserve">
    <value>夜视</value>
  </data>
  <data name="FeatureNoCollisionDescription" xml:space="preserve">
    <value>没有物理碰撞，因此你不会受到子弹、手榴弹和铁丝网的伤害</value>
  </data>
  <data name="FeatureNoCollisionName" xml:space="preserve">
    <value>无物理碰撞</value>
  </data>
  <data name="FeatureNoMalfunctionsDescription" xml:space="preserve">
    <value>没有武器故障:没有哑火、供弹故障。没有枪膛堵塞或武器过热</value>
  </data>
  <data name="FeatureNoMalfunctionsName" xml:space="preserve">
    <value>无武器故障</value>
  </data>
  <data name="FeatureNoRecoilDescription" xml:space="preserve">
    <value>武器没有后坐力。</value>
  </data>
  <data name="FeatureNoRecoilName" xml:space="preserve">
    <value>无后坐力</value>
  </data>
  <data name="FeatureNoSwayDescription" xml:space="preserve">
    <value>没有呼吸产生的视角摆动。更容易瞄准。</value>
  </data>
  <data name="FeatureNoSwayName" xml:space="preserve">
    <value>无视角摆动</value>
  </data>
  <data name="FeatureNoVisorDescription" xml:space="preserve">
    <value>没有面罩遮挡视野，即使你使用面罩，你也不会看到它产生的遮挡。</value>
  </data>
  <data name="FeatureNoVisorName" xml:space="preserve">
    <value>无视野遮挡</value>
  </data>
  <data name="FeaturePlayersDescription" xml:space="preserve">
    <value>显示玩家(通过墙壁你会看到Bear/Boss/邪教徒/Scav/Usec)。可配置颜色、描边、人物盒子、人物信息(武器和生命值)，人物骨骼和距离。
</value>
  </data>
  <data name="FeaturePlayersFormat" xml:space="preserve">
    <value>武器:{0} 血量:{1}% 距你 {2}</value>
    <comment>Weapon name, health %, distance</comment>
  </data>
  <data name="FeaturePlayersName" xml:space="preserve">
    <value>显示玩家</value>
  </data>
  <data name="FeaturePointOfInterestsDistanceFormat" xml:space="preserve">
    <value>[{0}米]</value>
    <comment>Distance</comment>
  </data>
  <data name="FeaturePointOfInterestsFormat" xml:space="preserve">
    <value>{0} {1} {2}</value>
    <comment>Name, optional formatted owner, optional formatted distance</comment>
  </data>
  <data name="FeaturePointOfInterestsGroupFormat" xml:space="preserve">
    <value>&gt;&gt; 在 {0} 中 {1} </value>
    <comment>Owner, distance</comment>
  </data>
  <data name="FeaturePointOfInterestsOwnerFormat" xml:space="preserve">
    <value>(在 {0} 中)</value>
    <comment>Owner</comment>
  </data>
  <data name="FeatureQuestsDescription" xml:space="preserve">
    <value>获取/放置任务物品的位置。只有与你接取的任务中相关的项目才会显示出来。</value>
  </data>
  <data name="FeatureQuestsFormat" xml:space="preserve">
    <value>{0} ({1})</value>
    <comment>Condition description, quest name</comment>
  </data>
  <data name="FeatureQuestsName" xml:space="preserve">
    <value>任务追踪</value>
  </data>
  <data name="FeatureQuickTrowDescription" xml:space="preserve">
    <value>快速投出手榴弹。</value>
  </data>
  <data name="FeatureQuickTrowName" xml:space="preserve">
    <value>快速投掷</value>
  </data>
  <data name="FeatureRadarDescription" xml:space="preserve">
    <value>2D雷达。</value>
  </data>
  <data name="FeatureRadarName" xml:space="preserve">
    <value>雷达</value>
  </data>
  <data name="FeatureRendererSummary" xml:space="preserve">
    <value>[概要]</value>
  </data>
  <data name="FeatureRendererWelcome" xml:space="preserve">
    <value>欢迎来到EFT-Trainer !</value>
  </data>
  <data name="FeatureSkillsDescription" xml:space="preserve">
    <value>所有技能提升至精英级(51级)，所有武器技能提升至3级。</value>
  </data>
  <data name="FeatureSkillsName" xml:space="preserve">
    <value>技能</value>
  </data>
  <data name="FeatureSpeedDescription" xml:space="preserve">
    <value>修改移动速度，使你能够通过墙壁/物体。注意，小心掉出地图自杀。</value>
  </data>
  <data name="FeatureSpeedName" xml:space="preserve">
    <value>移动速度</value>
  </data>
  <data name="FeatureStaminaDescription" xml:space="preserve">
    <value>无限耐力；冲刺时不消耗体力，瞄准时不消耗耐力。</value>
  </data>
  <data name="FeatureStaminaName" xml:space="preserve">
    <value>无限耐力</value>
  </data>
  <data name="FeatureStashDescription" xml:space="preserve">
    <value>显示/特殊藏匿物，如埋桶，地面贮藏物，空投物或尸体。</value>
  </data>
  <data name="FeatureStashName" xml:space="preserve">
    <value>显示容器</value>
  </data>
  <data name="FeatureThermalVisionDescription" xml:space="preserve">
    <value>热成像视角。</value>
  </data>
  <data name="FeatureThermalVisionName" xml:space="preserve">
    <value>热成像</value>
  </data>
  <data name="FeatureTrainDescription" xml:space="preserve">
    <value>在兼容的地图上召唤火车，如储备站或灯塔</value>
  </data>
  <data name="FeatureTrainName" xml:space="preserve">
    <value>召唤火车</value>
  </data>
  <data name="FeatureWallShootName" xml:space="preserve">
    <value>穿墙射击</value>
  </data>
  <data name="FeatureWeatherDescription" xml:space="preserve">
    <value>更改天气为晴朗。</value>
  </data>
  <data name="FeatureWeatherName" xml:space="preserve">
    <value>天气晴朗</value>
  </data>
  <data name="FeatureWorldInteractiveObjectsDescription" xml:space="preserve">
    <value>门/钥匙卡读卡器/汽车开锁；对容器按下绑定的按键，强制开锁。(即使你没有钥匙)</value>
  </data>
  <data name="FeatureWorldInteractiveObjectsName" xml:space="preserve">
    <value>开锁</value>
  </data>
  <data name="PropertyArmorDamageColor" xml:space="preserve">
    <value>命中防弹衣颜色</value>
  </data>
  <data name="PropertyBackward" xml:space="preserve">
    <value>后</value>
  </data>
  <data name="PropertyBearColors" xml:space="preserve">
    <value>Bear 阵营颜色</value>
  </data>
  <data name="PropertyBorderColor" xml:space="preserve">
    <value>边框颜色</value>
  </data>
  <data name="PropertyBossColors" xml:space="preserve">
    <value>Boss 颜色</value>
  </data>
  <data name="PropertyBoxThickness" xml:space="preserve">
    <value>边框厚度</value>
  </data>
  <data name="PropertyCacheTimeInSec" xml:space="preserve">
    <value>缓存时间(秒)</value>
  </data>
  <data name="PropertyCameraOffset" xml:space="preserve">
    <value>相机偏移</value>
  </data>
  <data name="PropertyChangeTime" xml:space="preserve">
    <value>调整时间</value>
  </data>
  <data name="PropertyColor" xml:space="preserve">
    <value>颜色</value>
  </data>
  <data name="PropertyCultistColors" xml:space="preserve">
    <value>邪教徒颜色</value>
  </data>
  <data name="PropertyDisplayTime" xml:space="preserve">
    <value>显示时间</value>
  </data>
  <data name="PropertyDistance" xml:space="preserve">
    <value>距离</value>
  </data>
  <data name="PropertyEligibleColor" xml:space="preserve">
    <value>符合条件颜色</value>
  </data>
  <data name="PropertyEnabled" xml:space="preserve">
    <value>启用</value>
  </data>
  <data name="PropertyFadeOutTime" xml:space="preserve">
    <value>淡出时间</value>
  </data>
  <data name="PropertyFastMode" xml:space="preserve">
    <value>快速移动模式</value>
  </data>
  <data name="PropertyFastMovementSpeed" xml:space="preserve">
    <value>快速移动速度</value>
  </data>
  <data name="PropertyFoodWater" xml:space="preserve">
    <value>食物 / 水</value>
  </data>
  <data name="PropertyForward" xml:space="preserve">
    <value>前</value>
  </data>
  <data name="PropertyFov" xml:space="preserve">
    <value>FOV</value>
  </data>
  <data name="PropertyFovCircleColor" xml:space="preserve">
    <value>视场圈颜色</value>
  </data>
  <data name="PropertyFovCircleThickness" xml:space="preserve">
    <value>视场圈厚度</value>
  </data>
  <data name="PropertyFovRadius" xml:space="preserve">
    <value>视场圈半径</value>
  </data>
  <data name="PropertyFreeLookSensitivity" xml:space="preserve">
    <value>自由视角灵敏度</value>
  </data>
  <data name="PropertyGroupingColor" xml:space="preserve">
    <value>分组颜色</value>
  </data>
  <data name="PropertyHealthDamageColor" xml:space="preserve">
    <value>生命伤害颜色</value>
  </data>
  <data name="PropertyHideWhenAiming" xml:space="preserve">
    <value>瞄准时隐藏</value>
  </data>
  <data name="PropertyHitMarkerColor" xml:space="preserve">
    <value>击中反馈颜色</value>
  </data>
  <data name="PropertyInfoColor" xml:space="preserve">
    <value>信息颜色</value>
  </data>
  <data name="PropertyIntensity" xml:space="preserve">
    <value>强度</value>
  </data>
  <data name="PropertyKey" xml:space="preserve">
    <value>绑定快捷键</value>
  </data>
  <data name="PropertyLeft" xml:space="preserve">
    <value>左</value>
  </data>
  <data name="PropertyMarksmanColors" xml:space="preserve">
    <value>狙击手颜色</value>
  </data>
  <data name="PropertyMaximumDistance" xml:space="preserve">
    <value>最大距离</value>
  </data>
  <data name="PropertyMovementSpeed" xml:space="preserve">
    <value>移动速度</value>
  </data>
  <data name="PropertyNotEligibleColor" xml:space="preserve">
    <value>不符合条件颜色</value>
  </data>
  <data name="PropertyNotShootableColors" xml:space="preserve">
    <value>不可射击时颜色</value>
  </data>
  <data name="PropertyRadarBackground" xml:space="preserve">
    <value>雷达边框颜色</value>
  </data>
  <data name="PropertyRadarCrosshair" xml:space="preserve">
    <value>雷达准星颜色</value>
  </data>
  <data name="PropertyRadarPercentage" xml:space="preserve">
    <value>雷达大小百分比</value>
  </data>
  <data name="PropertyRadarRange" xml:space="preserve">
    <value>雷达范围</value>
  </data>
  <data name="PropertyRange" xml:space="preserve">
    <value>范围</value>
  </data>
  <data name="PropertyRate" xml:space="preserve">
    <value>射速</value>
  </data>
  <data name="PropertyRemoveNegativeEffects" xml:space="preserve">
    <value>去除负面效果</value>
  </data>
  <data name="PropertyRight" xml:space="preserve">
    <value>右</value>
  </data>
  <data name="PropertyRogueUsecColors" xml:space="preserve">
    <value>Usec游荡者 颜色</value>
  </data>
  <data name="PropertyScavAssaultColors" xml:space="preserve">
    <value>Scav巡逻队 颜色</value>
  </data>
  <data name="PropertyScavColors" xml:space="preserve">
    <value>Scav 颜色</value>
  </data>
  <data name="PropertyScavRaiderColors" xml:space="preserve">
    <value>Scav掠夺者 颜色</value>
  </data>
  <data name="PropertySearchInsideContainers" xml:space="preserve">
    <value>在容器内搜索</value>
  </data>
  <data name="PropertySearchInsideCorpses" xml:space="preserve">
    <value>在尸体内搜索</value>
  </data>
  <data name="PropertyShootableColors" xml:space="preserve">
    <value>可射击时颜色</value>
  </data>
  <data name="PropertyShowArmorDamage" xml:space="preserve">
    <value>显示对防弹衣伤害</value>
  </data>
  <data name="PropertyShowBosses" xml:space="preserve">
    <value>显示 Boss</value>
  </data>
  <data name="PropertyShowBoxes" xml:space="preserve">
    <value>显示盒子</value>
  </data>
  <data name="PropertyShowCharms" xml:space="preserve">
    <value>显示描边</value>
  </data>
  <data name="PropertyShowCompass" xml:space="preserve">
    <value>显示指南针</value>
  </data>
  <data name="PropertyShowContainers" xml:space="preserve">
    <value>显示容器</value>
  </data>
  <data name="PropertyShowCoordinates" xml:space="preserve">
    <value>显示坐标</value>
  </data>
  <data name="PropertyShowCorpses" xml:space="preserve">
    <value>显示尸体</value>
  </data>
  <data name="PropertyShowCultists" xml:space="preserve">
    <value>显示邪教徒</value>
  </data>
  <data name="PropertyShowEligible" xml:space="preserve">
    <value>显示符合条件的</value>
  </data>
  <data name="PropertyShowFovCircle" xml:space="preserve">
    <value>显示FOV圈</value>
  </data>
  <data name="PropertyShowHealthDamage" xml:space="preserve">
    <value>显示健康伤害</value>
  </data>
  <data name="PropertyShowHitMarker" xml:space="preserve">
    <value>显示命中反馈</value>
  </data>
  <data name="PropertyShowInfos" xml:space="preserve">
    <value>显示信息</value>
  </data>
  <data name="PropertyShowMap" xml:space="preserve">
    <value>显示地图</value>
  </data>
  <data name="PropertyShowMarksmen" xml:space="preserve">
    <value>显示狙击手</value>
  </data>
  <data name="PropertyShowNotEligible" xml:space="preserve">
    <value>显示不符合条件的</value>
  </data>
  <data name="PropertyShowNotShootable" xml:space="preserve">
    <value>显示不可射击颜色</value>
  </data>
  <data name="PropertyShowPlayers" xml:space="preserve">
    <value>显示玩家</value>
  </data>
  <data name="PropertyShowPrices" xml:space="preserve">
    <value>显示价格</value>
  </data>
  <data name="PropertyShowRogues" xml:space="preserve">
    <value>显示游荡者</value>
  </data>
  <data name="PropertyShowScavAssaults" xml:space="preserve">
    <value>显示Scav巡逻队</value>
  </data>
  <data name="PropertyShowScavRaiders" xml:space="preserve">
    <value>显示Scav掠夺者</value>
  </data>
  <data name="PropertyShowScavs" xml:space="preserve">
    <value>显示Scavs</value>
  </data>
  <data name="PropertyShowShootable" xml:space="preserve">
    <value>显示可射击颜色</value>
  </data>
  <data name="PropertyShowSkeletons" xml:space="preserve">
    <value>显示骨骼</value>
  </data>
  <data name="PropertySilentAim" xml:space="preserve">
    <value>自动开火</value>
  </data>
  <data name="PropertySilentAimNextShotDelay" xml:space="preserve">
    <value>自动开火，下一枪延迟</value>
  </data>
  <data name="PropertySilentAimSpeedFactor" xml:space="preserve">
    <value>自动开火速度</value>
  </data>
  <data name="PropertySize" xml:space="preserve">
    <value>大小</value>
  </data>
  <data name="PropertySkeletonThickness" xml:space="preserve">
    <value>骨架厚度</value>
  </data>
  <data name="PropertySmoothness" xml:space="preserve">
    <value>平滑度</value>
  </data>
  <data name="PropertyStatusFilter" xml:space="preserve">
    <value>状态筛选器</value>
  </data>
  <data name="PropertyTeleport" xml:space="preserve">
    <value>传送</value>
  </data>
  <data name="PropertyThickness" xml:space="preserve">
    <value>厚度</value>
  </data>
  <data name="PropertyTrackedNamesComment" xml:space="preserve">
    <value>示例: ["foo", "bar"] 或使用扩展属性: [{"Name":"foo","Color":[1.0,0.0,0.0,1.0]},{"Name":"bar","Color":[1.0,1.0,1.0,0.8],"Rarity":"Rare"}]</value>
  </data>
  <data name="PropertyTrackWishlist" xml:space="preserve">
    <value>跟踪愿望清单</value>
  </data>
  <data name="PropertyUsecColors" xml:space="preserve">
    <value>Usec颜色</value>
  </data>
  <data name="PropertyVitalsOnly" xml:space="preserve">
    <value>仅重要器官免疫伤害</value>
  </data>
  <data name="PropertyX" xml:space="preserve">
    <value>X轴</value>
  </data>
  <data name="PropertyXRayVision" xml:space="preserve">
    <value>X射线视野</value>
  </data>
  <data name="PropertyY" xml:space="preserve">
    <value>Y轴</value>
  </data>
  <data name="TextOff" xml:space="preserve">
    <value>关闭</value>
  </data>
  <data name="TextOn" xml:space="preserve">
    <value>开启</value>
  </data>
  <data name="TextSeparator" xml:space="preserve">
    <value>------</value>
  </data>
  <data name="ErrorNoBotFound" xml:space="preserve">
    <value>未找到机器人!</value>
  </data>
  <data name="CommandSpawnBot" xml:space="preserve">
    <value>spawnbot</value>
  </data>
  <data name="ErrorTooManyBotsFormat" xml:space="preserve">
    <value>发现{0}个机器人，更具体一点</value>
    <comment>Bot count &gt; 1</comment>
  </data>
  <data name="CommandSpawnBotEnumerateFormat" xml:space="preserve">
    <value>{0}</value>
  </data>
  <data name="CommandSpawnQuestItems" xml:space="preserve">
    <value>spawnqi</value>
  </data>
  <data name="PropertyTrackAutoWishlist" xml:space="preserve">
    <value>自动跟踪愿望单</value>
  </data>
  <data name="CommandSpawnHideoutItems" xml:space="preserve">
    <value>spawnhi</value>
  </data>
  <data name="FeatureNoFlashName" xml:space="preserve">
    <value>免疫闪光</value>
  </data>
  <data name="FeatureNoFlashDescription" xml:space="preserve">
    <value>闪光弹爆炸后不会产生持续闪光或灼伤眼睛的效果。</value>
  </data>
  <data name="FeatureMortarName" xml:space="preserve">
    <value>迫击炮</value>
  </data>
  <data name="FeatureMortarDescription" xml:space="preserve">
    <value>触发对玩家所在位置的迫击炮攻击。</value>
  </data>
  <data name="FeatureAirDropName" xml:space="preserve">
    <value>空投</value>
  </data>
  <data name="FeatureAirDropDescription" xml:space="preserve">
    <value>触发玩家所在位置的空投。</value>
  </data>
  <data name="PropertyElevationAdjustment" xml:space="preserve">
    <value>高度调节</value>
  </data>
</root>
```

`README.md`:

```md

# EscapeFromTarkov-Trainer

[![Sponsor](https://img.shields.io/badge/sponsor-%E2%9D%A4-lightgrey?logo=github&style=flat-square)](https://github.com/sponsors/sailro)

# This project has been discontinued
> After 5 years of proud service, this project has been discontinued. With the release of version 1.0 and, above all, the switch to IL2CPP technology, internal modding is going to be completely different (and much more complex).
> It has been really interesting to find techniques for modding the game, compiling on the go and allowing features to be added easily. Thanks !

*I'm not responsible for any consequences that result from using this code. BattleState / BattlEye will ban you if you try to use it 'live'. Use it safely offline with [SPT](https://sp-tarkov.com/).*

***TLDR => Use the [Universal Installer](https://github.com/sailro/EscapeFromTarkov-Trainer/releases).*** Default key for in-game GUI is `Right-Alt`.

`master` branch can build against `EFT 0.16.9.40087` (tested with [`SPT Version 4.0.4`](https://hub.sp-tarkov.com/files/file/16-spt/#versions)). If you are looking for another version, see [`branches`](https://github.com/sailro/EscapeFromTarkov-Trainer/branches) and [`releases`](https://github.com/sailro/EscapeFromTarkov-Trainer/releases).

> If you want to compile the code yourself, make sure you cleaned-up your solution properly after upgrading your EFT/sptarkov bits (even removing `bin` and `obj` folders) and check all your references.

> If you are using `SPT`, please make sure you have run the game at least once before compiling/installing the trainer. `SPT` is patching binaries during the first run, and we need to compile against those patched binaries.

> The typical issue when something is out of sync is that the game will freeze at the startup screen with type/tokens errors in `%LOCALAPPDATA%Low\Battlestate Games\EscapeFromTarkov\Player.log`

## Features

| trainer.ini section       | GUI/console  | Description |
|---------------------------|--------------|-------------|
| `Aimbot`                  | `aimbot`     | Aimbot (distance, smoothness, silent aim with speed factor and shot delay, fov radius, fov circle). |
| `AirDrop`                 | `airdrop`    | Triggers an airdrop at the player's location. |
| `Ammunition`              | `ammo`       | Unlimited ammo. |
| `AutomaticGun`            | `autogun`    | Force all guns (even bolt action guns) to use automatic firing mode with customizable fire rate. |
| `Commands`                | `commands`   | Popup window to enable/disable all features (use right-alt or setup your own key in [trainer.ini](#sample-trainerini-configuration-file)). |
| `CrossHair`               | `crosshair`  | Crosshair with customizable size, color, thickness and auto-hide feature when aiming. |
| `Durability`              | `durability` | Maximum durability of items. |
| `Examine`                 | `examine`    | All items already examined. Instant search. |
| `ExfiltrationPoints`      | `exfil`      | Exfiltration points with customizable colors given eligibility, status filter, distance. |
| `FovChanger`              | `fovchanger` | Change Field Of View (FOV). |
| `FreeCamera`              | `camera`     | Free camera with fast mode and teleportation. |
| `Ghost`                   | `ghost`      | Stop bots from seeing you. |
| `Grenades`                | `grenade`    | Grenades outline. |
| `Health`                  | `health`     | Full health, prevent any damage (so even when falling), keep energy and hydration at maximum. |
| `Hits`                    | `hits`       | Hit markers (hit, armor, health with configurable colors). |
| `Hud`                     | `hud`        | HUD (compass, ammo left in chamber / magazine, fire mode, coordinates). |
| `Interact`                | `interact`   | Change distance for loot/door interaction. |
| `LootableContainers`      | `stash`      | Hidden/special stashes like buried barrels, ground caches, air drops or corpses. |
| `LootItems`               | `loot`       | List all lootable items and track any item by name or rarity or in-game wishlist in raid (even in containers and corpses). |
| `Map`                     | `map`        | Full screen map with radar esp. |
| `Mortar`                  | `mortar`     | Triggers a mortar strike at the player's location. |
| `NightVision`             | `night`      | Night vision. |
| `NoCollision`             | `nocoll`     | No physical collisions, making you immune to bullets, grenades and barbed wires. |
| `NoFlash`                 | `noflash`    | No persistent flash or eye-burn effect after a flash grenade. |
| `NoMalfunctions`          | `nomal`      | No weapon malfunctions: no misfires or failures to eject or feed. No jammed bolts or overheating. |
| `NoRecoil`                | `norecoil`   | No recoil. |
| `NoSway`                  | `nosway`     | No sway. |
| `NoVisor`                 | `novisor`    | No visor, so even when using a face shield-visor you won't see it. |
| `Players`                 | `players`    | Players (you'll see Bear/Boss/Cultist/Scav/Usec with configurable colors through walls). Charms, boxes, info (weapon and health), skeletons and distance. |
| `Quests`                  | `quest`      | Locations for taking/placing quest items. Only items related to your started quests are displayed. |
| `QuickThrow`              | `quickthrow` | Quick-throw grenades. |
| `Radar`                   | `radar`      | 2D radar. |
| `Skills`                  | `skills`     | All skills to Elite level (51) and all weapons mastering to level 3. |
| `Speed`                   | `speed`      | Speed boost to be able to go through walls/objects, or to move faster. Be careful to not kill yourself. |
| `Stamina`                 | `stamina`    | Unlimited stamina. |
| `ThermalVision`           | `thermal`    | Thermal vision. |
| `Train`                   | `train`      | Summon train on compatible maps like Reserve or Lighthouse. |
| `WallShoot`               | `wallshoot`  | Shoot through wall/helmet/vest/material with maximum penetration and minimal deviation/ricochet. |
| `Weather`                 | `weather`    | Clear weather. |
| `WorldInteractiveObjects` | `opener`     | Door/Keycard reader/Car unlocker. |

You can Load/Save all settings using the `console` or the `GUI`.

![Players](https://user-images.githubusercontent.com/638167/222186879-a88a267e-16ba-4532-85ec-8cb385737947.png)
![Radar](https://user-images.githubusercontent.com/638167/222524208-589dc7ff-f053-4b0c-902b-49fa8d1f7ddd.png)
![Map](https://user-images.githubusercontent.com/769465/224330696-d09960a2-8940-4980-8489-0533b44534f9.png)
![Exfils](https://user-images.githubusercontent.com/638167/135586735-143ab160-ca20-4ec9-8ad4-9ce7bde58295.png)
![Loot](https://user-images.githubusercontent.com/638167/135587083-938a3d9b-2082-4231-9fa8-e7807ad4a3d1.png)
![Quests](https://user-images.githubusercontent.com/638167/121975175-d8d91c00-cd35-11eb-86cd-6b49360fe370.png)
![Stashes](https://user-images.githubusercontent.com/638167/135586933-4cf57740-aff2-47c8-9cec-94e2eb062dd0.png)
![Track](https://user-images.githubusercontent.com/638167/222189119-f25413a7-511b-43cf-b6d8-a57320347034.png)
![NightVision](https://user-images.githubusercontent.com/638167/135586268-c175e999-a60d-40db-9960-06cdf5fe27d7.png)
![Popup](https://user-images.githubusercontent.com/638167/222188079-3ddb81e2-fb4c-446d-8716-5f54a40ad01b.png)

## Easy and automatic installation

Simply use the [Universal Installer](https://github.com/sailro/EscapeFromTarkov-Trainer/releases).

## Configuration

![console](https://user-images.githubusercontent.com/638167/149630825-7d76b102-0836-4eb9-a27f-d33fb519452f.png)

This trainer hooks into the command system, so you can easily setup features using the built-in console:

| Command    | Values              | Default | Description                          |
|------------|---------------------|---------|--------------------------------------|
| ammo       | `on` or `off`       | `off`   | Enable/Disable unlimited ammo        |
| autogun    | `on` or `off`       | `off`   | Enable/Disable automatic gun mode    |
| crosshair  | `on` or `off`       | `off`   | Show/Hide crosshair                  |
| dump       |                     |         | Dump game state for analysis         |
| durability | `on` or `off`       | `off`   | Enable/Disable maximum durability    |
| examine    | `on` or `off`       | `off`   | Enable/Disable all item examined     |
| exfil      | `on` or `off`       | `on`    | Show/Hide exfiltration points        |
| fovchanger | `on` or `off`       | `off`   | Change FOV value                     |
| ghost      | `on` or `off`       | `off`   | Enable/Disable ghost mode            |
| grenade    | `on` or `off`       | `off`   | Show/Hide grenades                   |
| health     | `on` or `off`       | `off`   | Enable/Disable full health           |
| hits       | `on` or `off`       | `off`   | Show/Hide hit markers                |
| hud        | `on` or `off`       | `on`    | Show/Hide hud                        |
| interact   | `on` or `off`       | `off`   | Enable/Disable interaction changes   |
| list       | `[name]` or `*`     |         | List lootable items                  |
| listr      | `[name]` or `*`     |         | List only rare lootable items        |
| listsr     | `[name]` or `*`     |         | List only super rare lootable items  |
| load       |                     |         | Load settings from `trainer.ini`     |
| loadtl     | `[filename]`        |         | Load current tracklist from file     |
| loot       | `on` or `off`       |         | Show/Hide tracked items              |
| night      | `on` or `off`       | `off`   | Enable/Disable night vision          |
| nocoll     | `on` or `off`       | `off`   | Disable/Enable physical collisions   |
| noflash    | `on` or `off`       | `off`   | Disable/Enable flash/eyeburn effects |
| nomal      | `on` or `off`       | `off`   | Disable/Enable weapon malfunctions   |
| norecoil   | `on` or `off`       | `off`   | Disable/Enable recoil                |
| nosway     | `on` or `off`       | `off`   | Disable/Enable sway                  |
| novisor    | `on` or `off`       | `off`   | Disable/Enable visor                 |
| players    | `on` or `off`       | `on`    | Show/hide players                    |
| quest      | `on` or `off`       | `off`   | Show/Hide quest POI                  |
| radar      | `on` or `off`       | `off`   | Show/Hide radar                      |
| save       |                     |         | Save settings to `trainer.ini`       |
| savetl     | `[filename]`        |         | Save current tracklist to file       |
| spawn      | `[name]`            |         | Spawn object in front of player      |
| spawnbot   | `[name]` or `*`     |         | Spawn a bot, ex `spawnbot bossKilla` |
| spawnhi    |                     |         | Spawn required hideout items         |
| spawnqi    |                     |         | Spawn items-to-find in active quests |
| stamina    | `on` or `off`       | `off`   | Enable/Disable unlimited stamina     |
| stash      | `on` or `off`       | `off`   | Show/Hide stashes                    |
| status     |                     |         | Show status of all features          |
| template   | `[name]`            |         | Search for templates by short/name   |
| thermal    | `on` or `off`       | `off`   | Enable/Disable thermal vision        |
| track      | `[name]` or `*`     |         | Track all items matching `name`      |
| track      | `[name]` `<color>`  |         | Ex: track `roler` `red`              |
| track      | `[name]` `<rgba>`   |         | Ex: track `roler` `[1,1,1,0.5]`      |
| trackr     | same as `track`     |         | Track rare items only                |
| tracksr    | same as `track`     |         | Track super rare items only          |
| tracklist  |                     |         | Show tracked items                   |
| untrack    | `[name]` or `*`     |         | Untrack a `name` or `*` for all      |
| wallshoot  | `on` or `off`       | `on`    | Enable/Disable shoot through walls   |

## Translations

This trainer comes in English but we also provide French, Japanese and Chinese simplified versions. You can use the [Universal Installer](https://github.com/sailro/EscapeFromTarkov-Trainer/releases) to specify your language, using `.\Installer -l zh-cn` for Chinese simplified for instance.

You can also tweak or add your own language by having a look [here](https://github.com/sailro/EscapeFromTarkov-Trainer/issues/541).

```

`UI/ColorPicker.cs`:

```cs
using UnityEngine;

namespace EFT.Trainer.UI;

public class ColorPicker : Picker<Color>
{

	public float H => _h;
	public float S => _s;
	public float V => _v;

	private float _h = 0f;
	private float _s = 0f;
	private float _v = 0f;

	private Rect _windowRect = new(20, 20, 165, 100);

	private readonly GUIStyle _previewStyle;
	private readonly GUIStyle _svStyle;
	private readonly GUIStyle _hueStyle;

	private readonly Texture2D _svTexture;
	private readonly Texture2D _circle;
	private readonly Texture2D _rightArrow;
	private readonly Texture2D _leftArrow;

	private const int HsvPickerSize = 120, HuePickerWidth = 16;

	public ColorPicker(Color color) : base(color)
	{
		ColorUtil.RgbToHsv(Value, out _h, out _s, out _v);

		_circle = Resources.Load<Texture2D>("imCircle");
		_rightArrow = Resources.Load<Texture2D>("imRight");
		_leftArrow = Resources.Load<Texture2D>("imLeft");
		_previewStyle = new GUIStyle { normal = { background = Texture2D.whiteTexture } };

		var hueTexture = CreateHueTexture(20, HsvPickerSize);
		_hueStyle = new GUIStyle { normal = { background = hueTexture } };

		_svTexture = CreateSvTexture(Value, HsvPickerSize);
		_svStyle = new GUIStyle { normal = { background = _svTexture } };
	}

	public override void SetWindowPosition(float x, float y)
	{
		_windowRect.x = x;
		_windowRect.y = y;
	}

	public override void DrawWindow(int id, string title)
	{
		_windowRect = GUI.Window(id, _windowRect, DrawColorPickerWindow, title);
	}

	private void DrawColorPickerWindow(int id)
	{
		DrawColorPicker();

		if (Event.current.type == EventType.Repaint)
		{
			var rect = GUILayoutUtility.GetLastRect();
			_windowRect.height = rect.y + rect.height + 10f;
		}

		GUI.DragWindow();
	}

	public void DrawColorPicker()
	{
		using (new GUILayout.VerticalScope())
		{
			GUILayout.Space(5f);
			DrawPreview(Value);

			GUILayout.Space(5f);
			DrawHsvPicker();
		}
	}

	private void DrawPreview(Color color)
	{
		using (new GUILayout.VerticalScope())
		{
			var tmp = GUI.backgroundColor;
			GUI.backgroundColor = new Color(color.r, color.g, color.b);
			GUILayout.Label(string.Empty, _previewStyle, GUILayout.Width(HsvPickerSize + HuePickerWidth + 10), GUILayout.Height(12f));

			GUILayout.Space(1f);

			var alpha = color.a;
			GUI.backgroundColor = new Color(alpha, alpha, alpha);
			GUILayout.Label(string.Empty, _previewStyle, GUILayout.Width(HsvPickerSize + HuePickerWidth + 10), GUILayout.Height(2f));

			GUI.backgroundColor = tmp;
		}
	}

	private void DrawHsvPicker()
	{
		using (new GUILayout.HorizontalScope())
		{
			GUILayout.Label(string.Empty, _svStyle, GUILayout.Width(HsvPickerSize), GUILayout.Height(HsvPickerSize));
			DrawSvHandler(GUILayoutUtility.GetLastRect());

			GUILayout.Space(10f);

			GUILayout.Label(string.Empty, _hueStyle, GUILayout.Width(HuePickerWidth), GUILayout.Height(HsvPickerSize));
			DrawHueHandler(GUILayoutUtility.GetLastRect());
		}
	}

	private void DrawSvHandler(Rect rect)
	{
		const float size = 10f;
		const float offset = 5f;
		GUI.DrawTexture(new Rect(rect.x + _s * rect.width - offset, rect.y + (1f - _v) * rect.height - offset, size, size), _circle);

		var e = Event.current;
		var p = e.mousePosition;

		if (e.button != 0 || e.type != EventType.MouseDown && e.type != EventType.MouseDrag || !rect.Contains(p))
			return;

		_s = (p.x - rect.x) / rect.width;
		_v = 1f - (p.y - rect.y) / rect.height;
		Value = ColorUtil.HsvToRgb(_h, _s, _v);

		e.Use();
	}

	private void DrawHueHandler(Rect rect)
	{
		const float size = 15f;
		GUI.DrawTexture(new Rect(rect.x - size * 0.75f, rect.y + (1f - _h) * rect.height - size * 0.5f, size, size), _rightArrow);
		GUI.DrawTexture(new Rect(rect.x + rect.width - size * 0.25f, rect.y + (1f - _h) * rect.height - size * 0.5f, size, size), _leftArrow);

		var e = Event.current;
		var p = e.mousePosition;

		if (e.button != 0 || e.type != EventType.MouseDown && e.type != EventType.MouseDrag || !rect.Contains(p))
			return;

		_h = 1f - (p.y - rect.y) / rect.height;
		Value = ColorUtil.HsvToRgb(_h, _s, _v);
		UpdateSvTexture(Value, _svTexture);

		e.Use();
	}

	private void UpdateSvTexture(Color c, Texture2D tex)
	{
		ColorUtil.RgbToHsv(c, out var h, out _, out _);

		var size = tex.width;
		for (int y = 0; y < size; y++)
		{
			var v = 1f * y / size;
			for (int x = 0; x < size; x++)
			{
				var s = 1f * x / size;
				var color = ColorUtil.HsvToRgb(h, s, v);
				tex.SetPixel(x, y, color);
			}
		}

		tex.Apply();
	}

	private static Texture2D CreateHueTexture(int width, int height)
	{
		var tex = new Texture2D(width, height);
		for (int y = 0; y < height; y++)
		{
			var h = 1f * y / height;
			var color = ColorUtil.HsvToRgb(h, 1f, 1f);
			for (int x = 0; x < width; x++)
			{
				tex.SetPixel(x, y, color);
			}
		}

		tex.Apply();
		return tex;
	}

	private Texture2D CreateSvTexture(Color c, int size)
	{
		var tex = new Texture2D(size, size);
		UpdateSvTexture(c, tex);
		return tex;
	}
}

```

`UI/ColorUtil.cs`:

```cs
using UnityEngine;

namespace EFT.Trainer.UI;

public class ColorUtil
{

	public static Color HsvToRgb(float h, float s, float v, bool hdr = false)
	{
		var white = Color.white;
		if (s == 0f)
		{
			white.r = v;
			white.g = v;
			white.b = v;
		}
		else if (v == 0f)
		{
			white.r = 0f;
			white.g = 0f;
			white.b = 0f;
		}
		else
		{
			white.r = 0f;
			white.g = 0f;
			white.b = 0f;
			float num = h * 6f;
			int num2 = (int)Mathf.Floor(num);
			float num3 = num - num2;
			float num4 = v * (1f - s);
			float num5 = v * (1f - s * num3);
			float num6 = v * (1f - s * (1f - num3));
			switch (num2 + 1)
			{
				case 0:
					white.r = v;
					white.g = num4;
					white.b = num5;
					break;
				case 1:
					white.r = v;
					white.g = num6;
					white.b = num4;
					break;
				case 2:
					white.r = num5;
					white.g = v;
					white.b = num4;
					break;
				case 3:
					white.r = num4;
					white.g = v;
					white.b = num6;
					break;
				case 4:
					white.r = num4;
					white.g = num5;
					white.b = v;
					break;
				case 5:
					white.r = num6;
					white.g = num4;
					white.b = v;
					break;
				case 6:
					white.r = v;
					white.g = num4;
					white.b = num5;
					break;
				case 7:
					white.r = v;
					white.g = num6;
					white.b = num4;
					break;
			}

			if (hdr)
				return white;

			white.r = Mathf.Clamp(white.r, 0f, 1f);
			white.g = Mathf.Clamp(white.g, 0f, 1f);
			white.b = Mathf.Clamp(white.b, 0f, 1f);
		}

		return white;
	}

	public static void RgbToHsv(Color color, out float h, out float s, out float v)
	{
		if (color.b > color.g && color.b > color.r)
		{
			RgbToHsvHelper(4f, color.b, color.r, color.g, out h, out s, out v);
		}
		else if (color.g > color.r)
		{
			RgbToHsvHelper(2f, color.g, color.b, color.r, out h, out s, out v);
		}
		else
		{
			RgbToHsvHelper(0f, color.r, color.g, color.b, out h, out s, out v);
		}
	}

	private static void RgbToHsvHelper(float offset, float dominantcolor, float colorone, float colortwo, out float h, out float s, out float v)
	{
		v = dominantcolor;
		if (v != 0f)
		{
			var num = colorone > colortwo ? colortwo : colorone;
			float num2 = v - num;
			if (num2 != 0f)
			{
				s = num2 / v;
				h = offset + (colorone - colortwo) / num2;
			}
			else
			{
				s = 0f;
				h = offset + (colorone - colortwo);
			}

			h /= 6f;
			if (h < 0f)
			{
				h += 1f;
			}
		}
		else
		{
			s = 0f;
			h = 0f;
		}
	}
}

```

`UI/EnumPicker.cs`:

```cs
using System;
using System.Linq;
using UnityEngine;

#nullable enable

namespace EFT.Trainer.UI;

public class EnumPicker<T>(T value) : Picker<T>(value) where T : struct, IConvertible
{
	private Rect _windowRect = new(20, 20, 200, 500);
	private Vector2 _scrollViewPosition = new();

	private T[]? _candidates = null;

	public T[] Candidates
	{
		get
		{
			return _candidates ??=
			[
				.. Enum
					.GetValues(typeof(T))
					.OfType<T>()
					.OrderBy(i => i)
			];
		}
	}

	public override void SetWindowPosition(float x, float y)
	{
		_windowRect.x = x;
		_windowRect.y = y;
	}

	public override void DrawWindow(int id, string title)
	{
		_windowRect = GUI.Window(id, _windowRect, DrawEnumPickerWindow, title);
	}

	private void DrawEnumPickerWindow(int id)
	{
		DrawEnumPicker();
		GUI.DragWindow();
	}

	public void DrawEnumPicker()
	{
		GUILayout.BeginVertical();

		_scrollViewPosition = GUILayout.BeginScrollView(_scrollViewPosition, GUI.skin.box);

		foreach (var candidate in Candidates)
		{
			if (!GUILayout.Button(candidate.ToString(), GUI.skin.label))
				continue;

			IsSelected = true;
			Value = candidate;
		}

		GUILayout.EndScrollView();
		GUILayout.EndVertical();
	}
}

```

`UI/Picker.cs`:

```cs
namespace EFT.Trainer.UI;

public interface IPicker
{
	public bool IsSelected { get; set; }
	public object RawValue { get; set; }

	public void SetWindowPosition(float x, float y);
	public void DrawWindow(int id, string title);
}

public abstract class Picker<T>(T value) : IPicker
{
	public object RawValue { get; set; } = value!;
	public T Value
	{
		get => (T)RawValue;
		set => RawValue = value!;
	}

	public bool IsSelected { get; set; } = false;
	public abstract void SetWindowPosition(float x, float y);
	public abstract void DrawWindow(int id, string title);
}

```

`UI/Render.cs`:

```cs
using UnityEngine;

#nullable enable

namespace EFT.Trainer.UI;

public static class Render
{
	private static GUIStyle? _stringStyle = null;
	private static GUIStyle StringStyle
	{
		get
		{
			// delay initialize stringStyle to be sure we are called under OnGui
			return _stringStyle ??= new GUIStyle(GUI.skin.label);
		}
	}

	public static Vector2 ScreenCenter => new(Screen.width / 2f, Screen.height / 2f);

	public static Color Color
	{
		get { return GUI.color; }
		set { GUI.color = value; }
	}

	public static Vector2 DrawString(Vector2 position, string label, Color color, bool centered = true)
	{
		Color = color;
		return DrawString(position, label, centered);
	}

	public static void GetContentAndSize(string label, out GUIContent content, out Vector2 size)
	{
		content = new GUIContent(label);
		size = StringStyle.CalcSize(content);
	}

	public static Vector2 DrawString(Vector2 position, string label, bool centered = true)
	{
		GetContentAndSize(label, out var content, out var size);
		var upperLeft = centered ? position - size / 2f : position;
		GUI.Label(new Rect(upperLeft, size), content);
		return size;
	}

	public static void DrawCrosshair(Vector2 position, float size, Color color, float thickness)
	{
		Color = color;
		var texture = Texture2D.whiteTexture;
		GUI.DrawTexture(new Rect(position.x - size, position.y, size * 2 + thickness, thickness), texture);
		GUI.DrawTexture(new Rect(position.x, position.y - size, thickness, size * 2 + thickness), texture);
	}

	public static void DrawPlayer(Vector2 position, float size, Color color, float thickness)
	{
		var forward = new Vector2(position.x, position.y - size * 2.5f);
		DrawCircle(position, size, color, thickness, 8);
		DrawLine(position, forward, thickness, color);
		DrawLine(new Vector2(position.x - size / 2, position.y - size * 1.25f), forward, thickness, color);
		DrawLine(new Vector2(position.x + size / 2, position.y - size * 1.25f), forward, thickness, color);
	}

	public static void DrawBox(float x, float y, float w, float h, float thickness, Color color)
	{
		Color = color;
		var texture = Texture2D.whiteTexture;
		GUI.DrawTexture(new Rect(x, y, w + thickness, thickness), texture);
		GUI.DrawTexture(new Rect(x, y, thickness, h + thickness), texture);
		GUI.DrawTexture(new Rect(x + w, y, thickness, h + thickness), texture);
		GUI.DrawTexture(new Rect(x, y + h, w + thickness, thickness), texture);
	}

	public static void DrawLine(Vector2 lineStart, Vector2 lineEnd, float thickness, Color color)
	{
		Color = color;

		var vector = lineEnd - lineStart;
		float pivot = /* 180/PI */ Mathf.Rad2Deg * Mathf.Atan(vector.y / vector.x);
		if (vector.x < 0f)
			pivot += 180f;

		thickness = Mathf.Max(thickness, 1f);
		int yOffset = (int)Mathf.Ceil(thickness / 2);

		GUIUtility.RotateAroundPivot(pivot, lineStart);
		GUI.DrawTexture(new Rect(lineStart.x, lineStart.y - yOffset, vector.magnitude, thickness), Texture2D.whiteTexture);
		GUIUtility.RotateAroundPivot(-pivot, lineStart);
	}

	public static void DrawCircle(Vector2 center, float radius, Color color, float width, int segmentsPerQuarter)
	{
		int totalSegments = segmentsPerQuarter * 4;
		float step = 1f / totalSegments;
		var lastV = center + new Vector2(radius, 0);

		for (int i = 1; i <= totalSegments; ++i)
		{
			float t = i * step;
			var currentV = center + new Vector2(
				radius * Mathf.Cos(2 * Mathf.PI * t),
				radius * Mathf.Sin(2 * Mathf.PI * t)
			);
			DrawLine(lastV, currentV, width, color);
			lastV = currentV;
		}
	}
}

```