Project Path: arc_ClaudiuGeorgiu_Obfuscapk_3fmmnm34

Source Tree:

```txt
arc_ClaudiuGeorgiu_Obfuscapk_3fmmnm34
├── LICENSE
├── README.md
├── docs
│   ├── CODE_OF_CONDUCT.md
│   ├── CONTRIBUTING.md
│   ├── FAQ.md
│   ├── SECURITY.md
│   ├── SUPPORT.md
│   ├── TROUBLESHOOTING.md
│   ├── architecture
│   │   └── architecture.png
│   ├── demo
│   │   └── cli.gif
│   ├── logo
│   │   ├── logo.js
│   │   ├── logo.png
│   │   └── preview.png
│   └── paper
│       └── Obfuscapk.pdf
├── pyproject.toml
└── src
    ├── Dockerfile
    ├── obfuscapk
    │   ├── __init__.py
    │   ├── cli.py
    │   ├── main.py
    │   ├── obfuscation.py
    │   ├── obfuscator_category.py
    │   ├── obfuscator_manager.py
    │   ├── obfuscators
    │   │   ├── advanced_reflection
    │   │   │   ├── __init__.py
    │   │   │   └── advanced_reflection.py
    │   │   ├── advanced_reflection.obfuscator
    │   │   ├── arithmetic_branch
    │   │   │   ├── __init__.py
    │   │   │   ├── arithmetic_branch.py
    │   │   │   └── example
    │   │   │       ├── after.smali
    │   │   │       ├── before.smali
    │   │   │       └── original.java
    │   │   ├── arithmetic_branch.obfuscator
    │   │   ├── asset_encryption
    │   │   │   ├── __init__.py
    │   │   │   ├── asset_encryption.py
    │   │   │   └── example
    │   │   │       ├── after.smali
    │   │   │       ├── before.smali
    │   │   │       └── original.java
    │   │   ├── asset_encryption.obfuscator
    │   │   ├── call_indirection
    │   │   │   ├── __init__.py
    │   │   │   ├── call_indirection.py
    │   │   │   └── example
    │   │   │       ├── after.smali
    │   │   │       ├── before.smali
    │   │   │       └── original.java
    │   │   ├── call_indirection.obfuscator
    │   │   ├── class_rename
    │   │   │   ├── __init__.py
    │   │   │   └── class_rename.py
    │   │   ├── class_rename.obfuscator
    │   │   ├── const_string_encryption
    │   │   │   ├── __init__.py
    │   │   │   └── const_string_encryption.py
    │   │   ├── const_string_encryption.obfuscator
    │   │   ├── debug_removal
    │   │   │   ├── __init__.py
    │   │   │   ├── debug_removal.py
    │   │   │   └── example
    │   │   │       ├── after.smali
    │   │   │       ├── before.smali
    │   │   │       └── original.java
    │   │   ├── debug_removal.obfuscator
    │   │   ├── field_rename
    │   │   │   ├── __init__.py
    │   │   │   └── field_rename.py
    │   │   ├── field_rename.obfuscator
    │   │   ├── goto
    │   │   │   ├── __init__.py
    │   │   │   ├── example
    │   │   │   │   ├── after.smali
    │   │   │   │   ├── before.smali
    │   │   │   │   └── original.java
    │   │   │   └── goto.py
    │   │   ├── goto.obfuscator
    │   │   ├── lib_encryption
    │   │   │   ├── __init__.py
    │   │   │   ├── example
    │   │   │   │   ├── after.smali
    │   │   │   │   ├── before.smali
    │   │   │   │   └── original.java
    │   │   │   └── lib_encryption.py
    │   │   ├── lib_encryption.obfuscator
    │   │   ├── method_overload
    │   │   │   ├── __init__.py
    │   │   │   ├── example
    │   │   │   │   ├── after.smali
    │   │   │   │   ├── before.smali
    │   │   │   │   └── original.java
    │   │   │   └── method_overload.py
    │   │   ├── method_overload.obfuscator
    │   │   ├── method_rename
    │   │   │   ├── __init__.py
    │   │   │   └── method_rename.py
    │   │   ├── method_rename.obfuscator
    │   │   ├── new_alignment
    │   │   │   ├── __init__.py
    │   │   │   └── new_alignment.py
    │   │   ├── new_alignment.obfuscator
    │   │   ├── new_signature
    │   │   │   ├── __init__.py
    │   │   │   └── new_signature.py
    │   │   ├── new_signature.obfuscator
    │   │   ├── nop
    │   │   │   ├── __init__.py
    │   │   │   ├── example
    │   │   │   │   ├── after.smali
    │   │   │   │   ├── before.smali
    │   │   │   │   └── original.java
    │   │   │   └── nop.py
    │   │   ├── nop.obfuscator
    │   │   ├── random_manifest
    │   │   │   ├── __init__.py
    │   │   │   ├── example
    │   │   │   │   ├── after.xml
    │   │   │   │   └── before.xml
    │   │   │   └── random_manifest.py
    │   │   ├── random_manifest.obfuscator
    │   │   ├── rebuild
    │   │   │   ├── __init__.py
    │   │   │   └── rebuild.py
    │   │   ├── rebuild.obfuscator
    │   │   ├── reflection
    │   │   │   ├── __init__.py
    │   │   │   └── reflection.py
    │   │   ├── reflection.obfuscator
    │   │   ├── reorder
    │   │   │   ├── __init__.py
    │   │   │   ├── example
    │   │   │   │   ├── after.smali
    │   │   │   │   ├── before.smali
    │   │   │   │   └── original.java
    │   │   │   └── reorder.py
    │   │   ├── reorder.obfuscator
    │   │   ├── res_string_encryption
    │   │   │   ├── __init__.py
    │   │   │   └── res_string_encryption.py
    │   │   ├── res_string_encryption.obfuscator
    │   │   ├── virus_total
    │   │   │   ├── __init__.py
    │   │   │   └── virus_total.py
    │   │   └── virus_total.obfuscator
    │   ├── resources
    │   │   ├── android_class_names_api_27.txt
    │   │   ├── code_block_valid_op_codes.txt
    │   │   ├── dangerous_api.txt
    │   │   ├── java
    │   │   │   └── DecryptAsset.java
    │   │   ├── libs_to_ignore.txt
    │   │   ├── nop_valid_op_codes.txt
    │   │   ├── obfuscation_keystore.jks
    │   │   └── smali
    │   │       ├── AdvancedApiReflection.smali
    │   │       ├── ApiReflection.smali
    │   │       ├── DecryptAsset.smali
    │   │       ├── DecryptString.smali
    │   │       └── overloaded_method_body.smali
    │   ├── tool.py
    │   ├── toolbundledecompiler.py
    │   └── util.py
    ├── requirements.txt
    └── test
        ├── __init__.py
        ├── test_cli.py
        ├── test_fixtures.py
        ├── test_obfuscation.py
        ├── test_resources
        │   └── v1.0
        │       ├── com.obfuscapk.demo.v1.0-original
        │       │   ├── AndroidManifest.xml
        │       │   ├── apktool.yml
        │       │   ├── assets
        │       │   │   └── message.txt
        │       │   ├── lib
        │       │   │   └── x86
        │       │   │       └── libnative-lib.so
        │       │   ├── res
        │       │   │   ├── drawable
        │       │   │   │   ├── $ic_launcher_foreground__0.xml
        │       │   │   │   ├── ic_launcher_background.xml
        │       │   │   │   └── ic_launcher_foreground.xml
        │       │   │   ├── layout
        │       │   │   │   └── activity_main.xml
        │       │   │   ├── mipmap-anydpi-v26
        │       │   │   │   ├── ic_launcher.xml
        │       │   │   │   └── ic_launcher_round.xml
        │       │   │   └── values
        │       │   │       ├── colors.xml
        │       │   │       ├── ids.xml
        │       │   │       ├── public.xml
        │       │   │       ├── strings.xml
        │       │   │       └── styles.xml
        │       │   └── smali
        │       │       └── com
        │       │           └── obfuscapk
        │       │               └── demo
        │       │                   ├── -$$Lambda$MainActivity$nhRfBCF8GXdGfWKghAWk7qFxa0k.smali
        │       │                   ├── AssetDemo.smali
        │       │                   ├── BuildConfig.smali
        │       │                   ├── DebugInfoDemo.smali
        │       │                   ├── MainActivity.smali
        │       │                   ├── NativeLibraryDemo.smali
        │       │                   ├── NopDemo.smali
        │       │                   ├── OrderDemo.smali
        │       │                   ├── R$color.smali
        │       │                   ├── R$drawable.smali
        │       │                   ├── R$id.smali
        │       │                   ├── R$layout.smali
        │       │                   ├── R$mipmap.smali
        │       │                   ├── R$string.smali
        │       │                   ├── R$style.smali
        │       │                   └── R.smali
        │       ├── com.obfuscapk.demo.v1.0-original.apk
        │       └── com.obfuscapk.demo.v1.0-rebuild.apk
        └── test_tool.py

```

`LICENSE`:

```
MIT License

Copyright (c) 2019 Simone Aonzo, Gabriel Claudiu Georgiu, Luca Verderame, Alessio Merlo

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
> [!IMPORTANT]
> This project is archived and no longer maintained.
> 
> Some of the most common questions are answered in
> [FAQ](https://github.com/ClaudiuGeorgiu/Obfuscapk/blob/master/docs/FAQ.md) and
> [troubleshooting](https://github.com/ClaudiuGeorgiu/Obfuscapk/blob/master/docs/TROUBLESHOOTING.md).

![Logo](https://raw.githubusercontent.com/ClaudiuGeorgiu/Obfuscapk/master/docs/logo/logo.png)

> A black-box obfuscation tool for Android apps.

[![Codacy](https://app.codacy.com/project/badge/Grade/076af5e6284541d39679c96d16d83772)](https://www.codacy.com/gh/ClaudiuGeorgiu/Obfuscapk)
[![Code Coverage](https://codecov.io/gh/ClaudiuGeorgiu/Obfuscapk/badge.svg)](https://codecov.io/gh/ClaudiuGeorgiu/Obfuscapk)
[![Python Version](https://img.shields.io/badge/Python-3.7%2B-green.svg?logo=python&logoColor=white)](https://www.python.org/downloads/)
[![License](https://img.shields.io/badge/license-MIT-blue.svg)](https://github.com/ClaudiuGeorgiu/Obfuscapk/blob/master/LICENSE)



**Obfuscapk** is a modular Python tool for obfuscating Android apps without needing
their source code, since [`apktool`](https://ibotpeaches.github.io/Apktool/) is used
to decompile the original apk file and to build a new application, after applying some
obfuscation techniques on the decompiled `smali` code, resources and manifest. The
obfuscated app retains the same functionality as the original one, but the differences
under the hood sometimes make the new application very different from the original
(e.g., to signature-based antivirus software).

### :new: Android App Bundle support :new:

Obfuscapk is adding support for
[Android App Bundles](https://developer.android.com/guide/app-bundle) (aab files) by
using [BundleDecompiler](https://github.com/TamilanPeriyasamy/BundleDecompiler) (see
[#121](https://github.com/ClaudiuGeorgiu/Obfuscapk/pull/121)). In order to use this new
feature, download the latest version of BundleDecompiler available from
[here](https://github.com/TamilanPeriyasamy/BundleDecompiler/tree/master/build/libs),
save it as `BundleDecompiler.jar` in a directory included in `PATH` (e.g., in Ubuntu,
`/usr/local/bin` or `/usr/bin`) and make sure it has the executable flag set.

> [!IMPORTANT]
> BundleDecompiler doesn't work on Windows yet, so app bundle obfuscation is not
> supported by Obfuscapk on Windows platform. Also, app bundle support is still in early
> development, so if you faced any problems or if you want to help us improve, please see
> [contributing](#-contributing).



## ❱ Publication

More details about **Obfuscapk** can be found in the paper
"[Obfuscapk: An *open-source* black-box obfuscation tool for Android apps](https://doi.org/10.1016/j.softx.2020.100403)".
You can cite the paper as follows:

```BibTeX
@article{aonzo2020obfuscapk,
    title = "Obfuscapk: An open-source black-box obfuscation tool for Android apps",
    journal = "SoftwareX",
    volume = "11",
    pages = "100403",
    year = "2020",
    issn = "2352-7110",
    doi = "https://doi.org/10.1016/j.softx.2020.100403",
    url = "https://www.sciencedirect.com/science/article/pii/S2352711019302791",
    author = "Simone Aonzo and Gabriel Claudiu Georgiu and Luca Verderame and Alessio Merlo",
    keywords = "Android, Obfuscation, Program analysis"
}
```



## ❱ Demo

![Demo](https://raw.githubusercontent.com/ClaudiuGeorgiu/Obfuscapk/master/docs/demo/cli.gif)



## ❱ Architecture

![Architecture](https://raw.githubusercontent.com/ClaudiuGeorgiu/Obfuscapk/master/docs/architecture/architecture.png)

Obfuscapk is designed to be modular and easy to extend, so it's built using a
[plugin system](https://github.com/tibonihoo/yapsy). Consequently, every obfuscator is
a plugin that inherits from an abstract
[base class](https://github.com/ClaudiuGeorgiu/Obfuscapk/blob/master/src/obfuscapk/obfuscator_category.py)
and needs to implement the method `obfuscate`. When the tool starts processing a new
Android application file, it creates an
[obfuscation object](https://github.com/ClaudiuGeorgiu/Obfuscapk/blob/master/src/obfuscapk/obfuscation.py)
to store all the needed information (e.g., the location of the decompiled `smali` code)
and the internal state of the operations (e.g., the list of already used obfuscators).
Then the obfuscation object is passed, as a parameter to the `obfuscate` method, to all
the active plugins/obfuscators (in sequence) to be processed and modified. The list and
the order of the active plugins is specified through [command line options](#-usage).

The tool is easily extensible with new obfuscators: it's enough to add the source code
implementing the obfuscation technique and the plugin metadata (a
`<obfuscator-name>.obfuscator` file) in the
[`src/obfuscapk/obfuscators`](https://github.com/ClaudiuGeorgiu/Obfuscapk/tree/master/src/obfuscapk/obfuscators)
directory (take a simple existing obfuscator like
[`Nop`](https://github.com/ClaudiuGeorgiu/Obfuscapk/blob/master/src/obfuscapk/obfuscators/nop/nop.py)
as a starting example). The tool will detect automatically the new plugin, so no
further configuration is needed (the new plugin will be treated like all the other
plugins bundled with the tool).



## ❱ Installation

There are two ways of getting a working copy of Obfuscapk on your own computer: either
by [using Docker](#docker-image) or by [using directly the source code](#from-source)
in a `Python 3` environment. In both cases, the first thing to do is to get a local
copy of this repository, so open up a terminal in the directory where you want to save
the project and clone the repository:

```Shell
$ git clone https://github.com/ClaudiuGeorgiu/Obfuscapk.git
```

### Docker image

----------------------------------------------------------------------------------------

#### Prerequisites

This is the suggested way of installing Obfuscapk, since the only requirement is to
have a recent version of Docker installed:

```Shell
$ docker --version
Docker version 20.10.21, build baeda1f
```

#### Official Docker Hub image

The [official Obfuscapk Docker image](https://hub.docker.com/r/claudiugeorgiu/obfuscapk)
is available on Docker Hub (automatically built from this repository):

```Shell
$ # Download the Docker image.
$ docker pull claudiugeorgiu/obfuscapk
$ # Give it a shorter name.
$ docker tag claudiugeorgiu/obfuscapk obfuscapk
```

#### Install

If you downloaded the official image from Docker Hub, you are ready to use the tool so
go ahead and check the [usage instructions](#-usage), otherwise execute the following
command in the previously created `Obfuscapk/src/` directory (the folder containing the
`Dockerfile`) to build the Docker image:

```Shell
$ # Make sure to run the command in Obfuscapk/src/ directory.
$ # It will take some time to download and install all the dependencies.
$ docker build -t obfuscapk .
```

When the Docker image is ready, make a quick test to check that everything was
installed correctly:

```Shell
$ docker run --rm -it obfuscapk --help
usage: python3 -m obfuscapk.cli [-h] -o OBFUSCATOR [-w DIR] [-d OUT_APK_OR_AAB]
...
```

Obfuscapk is now ready to be used, see the [usage instructions](#-usage) for more
information.

### From source

----------------------------------------------------------------------------------------

#### Prerequisites

Make sure to have a recent version of
[`apktool`](https://ibotpeaches.github.io/Apktool/),
[`apksigner`](https://developer.android.com/studio/command-line/apksigner)
and [`zipalign`](https://developer.android.com/studio/command-line/zipalign) installed
and available from the command line:

```Shell
$ apktool
Apktool v2.9.0 - a tool for reengineering Android apk files
...
```
```Shell
$ apksigner
Usage:  apksigner <command> [options]
        apksigner --version
        apksigner --help
...
```
```Shell
$ zipalign
Zip alignment utility
Copyright (C) 2009 The Android Open Source Project
...
```

To support app bundles obfuscation you also need
[BundleDecompiler](https://github.com/TamilanPeriyasamy/BundleDecompiler), so download
the latest available version from
[here](https://github.com/TamilanPeriyasamy/BundleDecompiler/tree/master/build/libs),
save it as `BundleDecompiler.jar` in a directory included in `PATH` (e.g., in Ubuntu,
`/usr/local/bin` or `/usr/bin`) and make sure it has the executable flag set.

To use BundleDecompiler and `apktool` you also need a recent version of Java. 
`zipalign` and `apksigner` are included in the Android SDK. The location of the
executables can also be specified through the following environment variables:
`APKTOOL_PATH`, `BUNDLE_DECOMPILER_PATH`, `APKSIGNER_PATH` and `ZIPALIGN_PATH` (e.g.,
in Ubuntu, run `export APKTOOL_PATH=/custom/location/apktool` before running Obfuscapk
in the same terminal).

Apart from the above tools, the only requirement of this project is a working
`Python 3` (at least `3.7`) installation (along with its package manager `pip`).

#### Install

Run the following commands in the main directory of the project (`Obfuscapk/`) to
install the needed dependencies:

```Shell
$ # Make sure to run the commands in Obfuscapk/ directory.

$ # The usage of a virtual environment is highly recommended.
$ python3 -m venv venv
$ source venv/bin/activate

$ # Install Obfuscapk's requirements.
$ python3 -m pip install -r src/requirements.txt
```

After the requirements are installed, make a quick test to check that everything works
correctly:

```Shell
$ cd src/
$ # The following command has to be executed always from Obfuscapk/src/ directory
$ # or by adding Obfuscapk/src/ directory to PYTHONPATH environment variable.
$ python3 -m obfuscapk.cli --help
usage: python3 -m obfuscapk.cli [-h] -o OBFUSCATOR [-w DIR] [-d OUT_APK_OR_AAB]
...
```

Obfuscapk is now ready to be used, see the [usage instructions](#-usage) for more
information.



## ❱ Usage

From now on, Obfuscapk will be considered as an executable available as `obfuscapk`,
so you need to adapt the commands according to how you installed the tool:

* **Docker image**: a local directory containing the application to obfuscate has to be
mounted to `/workdir` in the container (e.g., the current directory `"${PWD}"`), so the
command:
    ```Shell
    $ obfuscapk [params...]
    ```
    becomes:
    ```Shell
    $ docker run --rm -it -u $(id -u):$(id -g) -v "${PWD}":"/workdir" obfuscapk [params...]
    ```

* **From source**: every instruction has to be executed from the `Obfuscapk/src/`
directory (or by adding `Obfuscapk/src/` directory to `PYTHONPATH` environment
variable) and the command:
    ```Shell
    $ obfuscapk [params...]
    ```
    becomes:
    ```Shell
    $ python3 -m obfuscapk.cli [params...]
    ```

Let's start by looking at the help message:

```Shell
$ obfuscapk --help
obfuscapk [-h] -o OBFUSCATOR [-w DIR] [-d OUT_APK_OR_AAB] [-i] [-p] [-k VT_API_KEY]
          [--keystore-file KEYSTORE_FILE] [--keystore-password KEYSTORE_PASSWORD]
          [--key-alias KEY_ALIAS] [--key-password KEY_PASSWORD] [--use-aapt2]
          <APK_OR_BUNDLE_FILE>
```

There are two mandatory parameters: `<APK_OR_BUNDLE_FILE>`, the path (relative or
absolute) to the apk or app bundle file to obfuscate and the list with the names of the
obfuscation techniques to apply (specified with a `-o` option that can be used multiple
times, e.g., `-o Rebuild -o NewAlignment -o NewSignature`). The other optional arguments
are as follows:

* `-w DIR` is used to set the working directory where to save the intermediate files
(generated by `apktool`). If not specified, a directory named `obfuscation_working_dir`
is created in the same directory as the input application. This can be useful for
debugging purposes, but if it's not needed it can be set to a temporary directory
(e.g., `-w /tmp/`).

* `-d OUT_APK_OR_AAB` is used to set the path of the destination file: the apk file
generated by the obfuscation process (e.g., `-d /home/user/Desktop/obfuscated.apk` or
`-d /home/user/Desktop/obfuscated.aab`). If not specified, the final obfuscated file
will be saved inside the working directory. Note: existing files will be overwritten
without any warning.

* `-i` is a flag for ignoring known third party libraries during the obfuscation
process, to use fewer resources, to increase performances and to reduce the risk of
errors. The
[list of libraries](https://github.com/ClaudiuGeorgiu/Obfuscapk/blob/master/src/obfuscapk/resources/libs_to_ignore.txt)
to ignore is adapted from [LiteRadar](https://github.com/pkumza/LiteRadar) project.

* `-p` is a flag for showing progress bars during the obfuscation operations. When
using the tool in batch operations/automatic builds it's convenient to have progress
bars disabled, otherwise this flag should be enabled to see the obfuscation progress.

* `-k VT_API_KEY` is needed only when using `VirusTotal` obfuscator, to set the API
key to be used when communicating with Virus Total.

* `--keystore-file KEYSTORE_FILE`, `--keystore-password KEYSTORE_PASSWORD`,
`--key-alias KEY_ALIAS` and `--key-password KEY_PASSWORD` can be used to specify a
custom keystore (needed for the apk signing). If `--keystore-file` is used,
`--keystore-password` and `--key-alias` must be specified too, while `--key-password`
is needed only if the chosen key has a different password from the keystore password.
By default (when `--keystore-file` is not specified), a
[keystore bundled with Obfuscapk](https://github.com/ClaudiuGeorgiu/Obfuscapk/blob/master/src/obfuscapk/resources/obfuscation_keystore.jks)
is used for the signing operations.

* `--ignore-packages-file IGNORE_PACKAGES_FILE` is a path to a file which includes
package names to be ignored. All the classes inside those packages will not be
obfuscated when this option is used. The file should have one package name per line as
shown in the example below:
    ```
    com.mycompany.dontobfuscate
    com.mycompany.ignore
    ...
    ```
* `--use-aapt2` is a flag for using aapt2 option when rebuilding an app with `apktool`.

Let's consider now a simple working example to see how Obfuscapk works:

```Shell
$ # original.apk is a valid Android apk file.
$ obfuscapk -o RandomManifest -o Rebuild -o NewAlignment -o NewSignature original.apk
```

When running the above command, this is what happens behind the scenes:

* since no working directory was specified, a new working directory
(`obfuscation_working_dir`) is created in the same location as `original.apk` (this can
be useful to inspect the `smali` files/manifest/resources in case of errors)

* some checks are performed to make sure that all the needed files/executables are
available and ready to be used

* the actual obfuscation process begins: the specified obfuscators are executed
(in order) one by one until there's no obfuscator left or until an error is encountered

    - when running the first obfuscator, `original.apk` is decompiled with `apktool`
    and the results are stored into the working directory

    - since the first obfuscator is `RandomManifest`, the entries in the decompiled
    Android manifest are reordered randomly (without breaking the `xml` structures)

    - `Rebuild` obfuscator simply rebuilds the application (now with the modified
    manifest) using `apktool`, and since no output file was specified, the resulting
    apk file is saved in the working directory created before

    - `NewAlignment` obfuscator uses `zipalign` tool to align the resulting apk file
      
    - `NewSignature` obfuscator signs the newly created apk file with a custom 
      certificate contained in a
      [keystore bundled with Obfuscapk](https://github.com/ClaudiuGeorgiu/Obfuscapk/blob/master/src/obfuscapk/resources/obfuscation_keystore.jks)
      (though a different keystore can be specified with the `--keystore-file` parameter)

* when all the obfuscators have been executed without errors, the resulting obfuscated
apk file can be found in `obfuscation_working_dir/original_obfuscated.apk`, signed,
aligned and ready to be installed into a device/emulator

As seen in the previous example, `Rebuild`, `NewAlignment` and `NewSignature` 
obfuscators are always needed to complete an obfuscation operation, to build the final
obfuscated apk. They are not actual obfuscation techniques, but they are needed in the
build process, so they are included in the list of obfuscators to keep the overall
architecture modular.

Not working as expected? See
[FAQ](https://github.com/ClaudiuGeorgiu/Obfuscapk/blob/master/docs/FAQ.md) and
[troubleshooting](https://github.com/ClaudiuGeorgiu/Obfuscapk/blob/master/docs/TROUBLESHOOTING.md).



## ❱ Obfuscators

The obfuscators included in Obfuscapk can be divided into different categories,
depending on the operations they perform:

* **Trivial**: as the name suggests, this category includes simple operations (that
do not modify much the original application), like signing the apk file with a new
signature.

* **Rename**: operations that change the names of the used identifiers (classes, fields,
methods).

* **Encryption**: packaging encrypted code/resources and decrypting them during the app
execution. When Obfuscapk starts, it automatically generates a random secret key (32
characters long, using ASCII letters and digits) that will be used for encryption.

* **Code**: all the operations that involve the modification of the decompiled source
code.

* **Resources**: operations on the resource files (like modifying the manifest).

* **Other**

The obfuscators currently bundled with Obfuscapk are briefly presented below (in
alphabetical order). Please refer to the source code of the project for more details.

> [!TIP]
> Not all the obfuscators below correspond to real obfuscation techniques (e.g.,
> `Rebuild`, `NewAlignment`, `NewSignature` and `VirusTotal`), but they are implemented
> as obfuscators to keep the architecture modular and easy to extend with new
> functionality.


<details><summary><b>AdvancedReflection</b> [Code]</summary>

> Uses reflection to invoke dangerous APIs of the Android Framework. To find out if a
> method belongs to the Android Framework, Obfuscapk refers to the mapping discovered by
> [Backes et al](https://www.usenix.org/system/files/conference/usenixsecurity16/sec16_paper_backes-android.pdf).  
> [:page_facing_up: AdvancedReflection source code](https://github.com/ClaudiuGeorgiu/Obfuscapk/tree/master/src/obfuscapk/obfuscators/advanced_reflection)
</details>


<details><summary><b>ArithmeticBranch</b> [Code]</summary>

> Insert junk code. In this case, the junk code is composed by arithmetic computations
> and a branch instruction depending on the result of these computations, crafted in
> such a way that the branch is never taken.  
> [:page_facing_up: ArithmeticBranch source code](https://github.com/ClaudiuGeorgiu/Obfuscapk/tree/master/src/obfuscapk/obfuscators/arithmetic_branch)
</details>


<details><summary><b>AssetEncryption</b> [Encryption]</summary>

> Encrypt asset files.  
> [:page_facing_up: AssetEncryption source code](https://github.com/ClaudiuGeorgiu/Obfuscapk/tree/master/src/obfuscapk/obfuscators/asset_encryption)
</details>


<details><summary><b>CallIndirection</b> [Code]</summary>

> This technique modifies the control-flow graph without impacting the code semantics:
> it adds new methods that invoke the original ones. For example, an invocation to the
> method *m1* will be substituted by a new wrapper method *m2*, that, when invoked, it
> calls the original method *m1*.  
> [:page_facing_up: CallIndirection source code](https://github.com/ClaudiuGeorgiu/Obfuscapk/tree/master/src/obfuscapk/obfuscators/call_indirection)
</details>


<details><summary><b>ClassRename</b> [Rename]</summary>

> Change the package name and rename classes (even in the manifest file).  
> [:page_facing_up: ClassRename source code](https://github.com/ClaudiuGeorgiu/Obfuscapk/tree/master/src/obfuscapk/obfuscators/class_rename)
</details>


<details><summary><b>ConstStringEncryption</b> [Encryption]</summary>

> Encrypt constant strings in code.  
> [:page_facing_up: ConstStringEncryption source code](https://github.com/ClaudiuGeorgiu/Obfuscapk/tree/master/src/obfuscapk/obfuscators/const_string_encryption)
</details>


<details><summary><b>DebugRemoval</b> [Code]</summary>

> Remove debug information.  
> [:page_facing_up: DebugRemoval source code](https://github.com/ClaudiuGeorgiu/Obfuscapk/tree/master/src/obfuscapk/obfuscators/debug_removal)
</details>


<details><summary><b>FieldRename</b> [Rename]</summary>

> Rename fields.  
> [:page_facing_up: FieldRename source code](https://github.com/ClaudiuGeorgiu/Obfuscapk/tree/master/src/obfuscapk/obfuscators/field_rename)
</details>


<details><summary><b>Goto</b> [Code]</summary>

> Given a method, it inserts a `goto` instruction pointing to the end of the method and
> another `goto` pointing to the instruction after the first `goto`; it modifies the
> control-flow graph by adding two new nodes.  
> [:page_facing_up: Goto source code](https://github.com/ClaudiuGeorgiu/Obfuscapk/tree/master/src/obfuscapk/obfuscators/goto)
</details>


<details><summary><b>LibEncryption</b> [Encryption]</summary>

> Encrypt native libs.  
> [:page_facing_up: LibEncryption source code](https://github.com/ClaudiuGeorgiu/Obfuscapk/tree/master/src/obfuscapk/obfuscators/lib_encryption)
</details>


<details><summary><b>MethodOverload</b> [Code]</summary>

> It exploits the overloading feature of the Java programming language to assign the
> same name to different methods but using different arguments. Given an already
> existing method, this technique creates a new void method with the same name and
> arguments, but it also adds new random arguments. Then, the body of the new method
> is filled with random arithmetic instructions.  
> [:page_facing_up: MethodOverload source code](https://github.com/ClaudiuGeorgiu/Obfuscapk/tree/master/src/obfuscapk/obfuscators/method_overload)
</details>


<details><summary><b>MethodRename</b> [Rename]</summary>

> Rename methods.  
> [:page_facing_up: MethodRename source code](https://github.com/ClaudiuGeorgiu/Obfuscapk/tree/master/src/obfuscapk/obfuscators/method_rename)
</details>


<details><summary><b>NewAlignment</b> [Trivial]</summary>

> Realign the application.  
> [:page_facing_up: NewAlignment source code](https://github.com/ClaudiuGeorgiu/Obfuscapk/tree/master/src/obfuscapk/obfuscators/new_alignment)
</details>


<details><summary><b>NewSignature</b> [Trivial]</summary>

> Re-sign the application with a new custom signature.  
> [:page_facing_up: NewSignature source code](https://github.com/ClaudiuGeorgiu/Obfuscapk/tree/master/src/obfuscapk/obfuscators/new_signature)
</details>


<details><summary><b>Nop</b> [Code]</summary>

> Insert junk code. Nop, short for *no-operation*, is a dedicated instruction that does
> nothing. This technique just inserts random `nop` instructions within every method
> implementation.  
> [:page_facing_up: Nop source code](https://github.com/ClaudiuGeorgiu/Obfuscapk/tree/master/src/obfuscapk/obfuscators/nop)
</details>


<details><summary><b>RandomManifest</b> [Resource]</summary>

> Randomly reorder entries in the manifest file.  
> [:page_facing_up: RandomManifest source code](https://github.com/ClaudiuGeorgiu/Obfuscapk/tree/master/src/obfuscapk/obfuscators/random_manifest)
</details>


<details><summary><b>Rebuild</b> [Trivial]</summary>

> Rebuild the application.  
> [:page_facing_up: Rebuild source code](https://github.com/ClaudiuGeorgiu/Obfuscapk/tree/master/src/obfuscapk/obfuscators/rebuild)
</details>


<details><summary><b>Reflection</b> [Code]</summary>

> This technique analyzes the existing code looking for method invocations of the app,
> ignoring the calls to the Android framework (see `AdvancedReflection`). If it finds
> an instruction with a suitable method invocation (i.e., no constructor methods,
> public visibility, enough free registers etc.) such invocation is redirected to a
> custom method that will invoke the original method using the Reflection APIs.  
> [:page_facing_up: Reflection source code](https://github.com/ClaudiuGeorgiu/Obfuscapk/tree/master/src/obfuscapk/obfuscators/reflection)
</details>


<details><summary><b>Reorder</b> [Code]</summary>

> This technique consists of changing the order of basic blocks in the code. When a
> branch instruction is found, the condition is inverted (e.g., *branch if lower than*,
> becomes *branch if greater or equal than*) and the target basic blocks are reordered
> accordingly. Furthermore, it also randomly re-arranges the code abusing `goto`
> instructions.  
> [:page_facing_up: Reorder source code](https://github.com/ClaudiuGeorgiu/Obfuscapk/tree/master/src/obfuscapk/obfuscators/reorder)
</details>


<details><summary><b>ResStringEncryption</b> [Encryption]</summary>

> Encrypt strings in resources (only those called inside code).  
> [:page_facing_up: ResStringEncryption source code](https://github.com/ClaudiuGeorgiu/Obfuscapk/tree/master/src/obfuscapk/obfuscators/res_string_encryption)
</details>


<details><summary><b>VirusTotal</b> [Other]</summary>

> Send the original and the obfuscated application to Virus Total. You must provide
> the VT API key (see `-k` option).  
> [:page_facing_up: VirusTotal source code](https://github.com/ClaudiuGeorgiu/Obfuscapk/tree/master/src/obfuscapk/obfuscators/virus_total)
</details>



## ❱ License

You are free to use this code under the
[MIT License](https://github.com/ClaudiuGeorgiu/Obfuscapk/blob/master/LICENSE).



## ❱ Credits

[![Unige](https://intranet.dibris.unige.it/img/logo_unige.gif)](https://unige.it/en/)
[![Dibris](https://intranet.dibris.unige.it/img/logo_dibris.gif)](https://www.dibris.unige.it/en/)

This software was developed for research purposes at the Computer Security Lab
([CSecLab](https://csec.it/)), hosted at DIBRIS, University of Genoa.



## ❱ Team

* [Simone Aonzo](https://simoneaonzo.it/) - Research Assistant
* [Gabriel Claudiu Georgiu](https://github.com/ClaudiuGeorgiu) - Core Developer
* [Luca Verderame](https://csec.it/people/luca_verderame/) - Postdoctoral Researcher
* [Alessio Merlo](https://csec.it/people/alessio_merlo/) - Faculty Member

```

`docs/CODE_OF_CONDUCT.md`:

```md
# Contributor Covenant Code of Conduct

## Our Pledge

In the interest of fostering an open and welcoming environment, we as
contributors and maintainers pledge to making participation in our project and
our community a harassment-free experience for everyone, regardless of age, body
size, disability, ethnicity, sex characteristics, gender identity and expression,
level of experience, education, socio-economic status, nationality, personal
appearance, race, religion, or sexual identity and orientation.

## Our Standards

Examples of behavior that contributes to creating a positive environment
include:

* Using welcoming and inclusive language
* Being respectful of differing viewpoints and experiences
* Gracefully accepting constructive criticism
* Focusing on what is best for the community
* Showing empathy towards other community members

Examples of unacceptable behavior by participants include:

* The use of sexualized language or imagery and unwelcome sexual attention or
 advances
* Trolling, insulting/derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or electronic
 address, without explicit permission
* Other conduct which could reasonably be considered inappropriate in a
 professional setting

## Our Responsibilities

Project maintainers are responsible for clarifying the standards of acceptable
behavior and are expected to take appropriate and fair corrective action in
response to any instances of unacceptable behavior.

Project maintainers have the right and responsibility to remove, edit, or
reject comments, commits, code, wiki edits, issues, and other contributions
that are not aligned to this Code of Conduct, or to ban temporarily or
permanently any contributor for other behaviors that they deem inappropriate,
threatening, offensive, or harmful.

## Scope

This Code of Conduct applies both within project spaces and in public spaces
when an individual is representing the project or its community. Examples of
representing a project or community include using an official project e-mail
address, posting via an official social media account, or acting as an appointed
representative at an online or offline event. Representation of a project may be
further defined and clarified by project maintainers.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported by contacting the project team. All
complaints will be reviewed and investigated and will result in a response that
is deemed necessary and appropriate to the circumstances. The project team is
obligated to maintain confidentiality with regard to the reporter of an incident.
Further details of specific enforcement policies may be posted separately.

Project maintainers who do not follow or enforce the Code of Conduct in good
faith may face temporary or permanent repercussions as determined by other
members of the project's leadership.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4,
available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html

[homepage]: https://www.contributor-covenant.org

For answers to common questions about this code of conduct, see
https://www.contributor-covenant.org/faq

```

`docs/CONTRIBUTING.md`:

```md
# Contributing

Thank you for considering contributing to this open source project! Please take a moment
to review this document in order to make the contribution process easy and effective for
everyone involved.

Following these guidelines helps to communicate that you respect the time of the
developers managing and developing this open source project. In return, we will
reciprocate that respect by addressing your issue, assessing changes, and helping you
finalize your pull requests.

As for everything else in the project, the contributions are governed by our
[Code of Conduct](https://github.com/ClaudiuGeorgiu/Obfuscapk/blob/master/docs/CODE_OF_CONDUCT.md).



## Issues

Issues should be used to report problems, request new features, or to discuss potential
changes before a pull request is created. When you create a new issue, a template will
be loaded that will guide you through collecting and providing the information we need.

If you find an issue that addresses the problem you're having, please add your own
reproduction information to the existing issue rather than creating a new one.

### Security issues

Review our
[Security Policy](https://github.com/ClaudiuGeorgiu/Obfuscapk/blob/master/docs/SECURITY.md).
Please **do not** use public issues to report security vulnerabilities.

### Bug reports

A bug is a *demonstrable problem* that is caused by the code in the repository. Good bug
reports are extremely helpful - thank you!

Guidelines for bug reports:

1. **Use the GitHub issue search** - check if the issue has already been reported

2. **Check if the issue has been fixed** - try to reproduce it using the latest `master`
branch in the repository

3. **Isolate the problem** - ideally create a reduced test case

A good bug report shouldn't leave others needing to chase you up for more information.
Please try to be as detailed as possible in your report. What is your environment? What
steps will reproduce the issue? What OS experiences the problem? What would you expect
to be the outcome? All these details will help people to fix any potential bugs.

### Feature requests

Feature requests are welcome. But take a moment to find out whether your idea fits with
the scope and aims of the project. It's up to *you* to make a strong case to convince
the project's developers of the merits of this feature. Please provide as much detail
and context as possible.



## Pull requests (PR)

Good pull requests - patches, improvements, new features - are a fantastic help. They
should remain focused in scope and avoid containing unrelated commits. In general, pull
requests should:

* Address a single concern in the least number of changed lines as possible

* Add unit or integration tests for fixed or changed functionality (if a test suite
already exists)

* Include documentation (if appropriate)

* Be accompanied by a complete pull request template (loaded automatically when a PR is
created)

**Please ask first** before embarking on any significant pull request (e.g., new
features that would require breaking changes), otherwise you risk spending a lot of time
working on something that the project's developers might not want to merge into the
project. It's best to open an issue to discuss your proposal first.

`NOTE:` by submitting a PR, you agree to license your work under the same license as
that used by the project.

### For new Contributors

If you never created a pull request before, here's a brief guide:

1. [Fork](http://help.github.com/fork-a-repo/) the project, clone your fork, and
configure the remotes:
    ```Shell
    $ # Clone your fork of the repo into the current directory.
    $ git clone https://github.com/<your-username>/<repo-name>
    $ # Navigate to the newly cloned directory.
    $ cd <repo-name>
    $ # Assign the original repo to a remote called "upstream".
    $ git remote add upstream https://github.com/ClaudiuGeorgiu/<repo-name>
    ```

2. If you cloned a while ago, get the latest changes from upstream:
    ```Shell
    $ git checkout master
    $ git pull upstream master
    ```

3. Create a new topic branch (off the main project development branch) to contain your
feature, change, or fix:
    ```Shell
    $ git checkout -b <topic-branch-name>
    ```

4. Now the fun part: implement your changes.

5. If you added or changed a feature, make sure to document it accordingly.

6. Follow any formatting and testing guidelines specific to this repository.

7. Commit changes and push your topic branch up to your fork:
    ```Shell
    $ git add <changed-files>
    $ git commit -m "<descriptive-commit-message>"
    $ git push origin <topic-branch-name>
    ```

8. [Open a pull request](https://help.github.com/articles/using-pull-requests/) in our
repository and follow the PR template so that we can efficiently review the changes.

```

`docs/FAQ.md`:

```md
## ❱ FAQ

Here you can find the answers to the most common questions about Obfuscapk. If you're
having technical issues when running the tool, visit the
[troubleshooting](https://github.com/ClaudiuGeorgiu/Obfuscapk/blob/master/docs/TROUBLESHOOTING.md)
page.

----------------------------------------------------------------------------------------

#### :speech_balloon: Can I use this tool to bypass antivirus software?

**:white_check_mark:** You can try, no one is going to stop you. However, since
Obfuscapk is public and open-source, probably most antivirus engines will detect it by
now (the first release dates back to September 2019), or at least will mark your
obfuscated application as suspicious. This is a research project that aims at showing
different obfuscation techniques, if you really want to bypass an antivirus you will
have to implement these (and other) techniques in a new and different way, by still
maintaining the core functionality. Here you can find a few suggestions:

* use a different keystore to sign the obfuscated applications;

* use another seed/technique to generate the random strings;

* change the hardcoded package names used by Obfuscapk (e.g.,
`Lcom/decryptstringmanager/DecryptString;` and
`Lcom/apireflectionmanager/AdvancedApiReflection;`);

* use different encryption functions/keys.

----------------------------------------------------------------------------------------

#### :speech_balloon: Is Obfuscapk production ready? How does it compare to other (commercial) products?

**:white_check_mark:** Obfuscapk is a research project and *should* work most of the
time, however, it has some limitations and might break your application in unexpected
ways. Our empirical assessment indicates a success rate of nearly 80% on real apps
downloaded from the Google Play Store (see the
[official publication](https://doi.org/10.1016/j.softx.2020.100403) for more details).
Unfortunately, it is hard to compare Obfuscapk to other commercial obfuscators, since
they typically do not offer an evaluation version, some of them require the
application's source code to work, and they are closed source. Still, Obfuscapk tries
to implement all the advanced obfuscation techniques declared by such proprietary
obfuscators.

----------------------------------------------------------------------------------------

#### :speech_balloon: I'm interested in this topic, where can I find more information about Obfuscapk and Android obfuscation in general?

**:white_check_mark:** You can find further details about Obfuscapk in the paper
"[Obfuscapk: An *open-source* black-box obfuscation tool for Android apps](https://doi.org/10.1016/j.softx.2020.100403)".
The references section of the paper contains many useful resources to learn more about
Android obfuscation. For more information, you can also check the following links
(in no particular order):

* [Obfuscation in Android malware, and how to fight back](https://www.virusbulletin.com/virusbulletin/2014/07/obfuscation-android-malware-and-how-fight-back)

* [A study on obfuscation techniques for Android malware](http://midlab.diag.uniroma1.it/articoli/matteo_pomilia_master_thesis.pdf)

* [How I Defeated an Obfuscated and Anti-Tamper APK](https://www.evilsocket.net/2016/04/18/How-I-defeated-an-obfuscated-and-anti-tamper-APK-with-some-Python-and-a-home-made-Smali-emulator/)

* [Android Deobfuscation Tools and Techniques](https://www.slideshare.net/tekproxy/tetcon-2016)

* [Obfuscated No More - Practical Steps for Defeating Android Obfuscation](https://www.youtube.com/watch?v=rvtmVApVS8c)

* [Simplify: Android virtual machine and deobfuscator](https://github.com/CalebFenton/simplify)

----------------------------------------------------------------------------------------

#### :speech_balloon: What are the prerequisites for using this tool?

**:white_check_mark:** The main target of Obfuscapk are developers and researchers, so
basic knowledge of Android and Python is expected, though not mandatory. However, as
long as you are able to follow the instructions in the
[readme](https://github.com/ClaudiuGeorgiu/Obfuscapk/blob/master/README.md), you should
be able to install and use Obfuscapk without any specific prerequisite.

----------------------------------------------------------------------------------------

#### :speech_balloon: The tool seems to run but nothing is printed in the terminal.

**:white_check_mark:** By default Obfuscapk shows only error messages, if you only want
to see progress bars during the obfuscation operations, use `-p/--show-progress` flag.
You can also
[enable verbose logging](https://github.com/ClaudiuGeorgiu/Obfuscapk/blob/master/docs/TROUBLESHOOTING.md#enable-verbose-logging).

----------------------------------------------------------------------------------------

#### :speech_balloon: Is the order of the obfuscators passed as parameters important?

**:white_check_mark:** The order of the obfuscators matters, since they are executed
sequentially. E.g., if the first obfuscator is encrypting the strings, all the remaining
obfuscators will see the encrypted strings instead of the original ones, so you can
obtain different results by just changing the order of the used obfuscators. However,
remember to preserve the order of `Rebuild`, `NewAlignment` and `NewSignature` and
always use them *after* the other obfuscators.

----------------------------------------------------------------------------------------

#### :speech_balloon: The obfuscation process seems to finish without errors, but the resulting application does not install or does not work as expected.

**:white_check_mark:** It happens, Obfuscapk is not perfect. If the tool finishes
without errors, the obfuscated application is ***NOT*** guaranteed to work exactly like
the original one, for a few reasons:

* the application is using some anti-tampering protection;

* the obfuscation broke something in the app (it's easy to mess up when dealing with
obfuscation, encryption and reflection at the same time);

* some operations (like encryption and reflection) can make the obfuscated application
slower than the original.

For more information, see also
[troubleshooting](https://github.com/ClaudiuGeorgiu/Obfuscapk/blob/master/docs/TROUBLESHOOTING.md).

----------------------------------------------------------------------------------------

#### :speech_balloon: I've used obfuscator *X* but nothing seems to have changed compared to the original application.

**:white_check_mark:** Some obfuscators work only under specific assumptions, so they
may not work for all the applications. E.g., `LibEncryption` obfuscator only encrypts
the native libraries that are loaded inside static constructors, so if the application
is loading the native libraries differently, `LibEncryption` will not work. Moreover,
if you are using `-i/--ignore-libs` flag, Obfuscapk will ignore all code where the
package name matches a
[known third party library](https://github.com/ClaudiuGeorgiu/Obfuscapk/blob/master/src/obfuscapk/resources/libs_to_ignore.txt).

For more information, inspect the source code of the obfuscator that is not working
as expected.

----------------------------------------------------------------------------------------

#### :speech_balloon: What can I do if I have any questions that are not covered here?

**:white_check_mark:** Open a new issue on GitHub and ask your question(s) in
understandable language.

```

`docs/SECURITY.md`:

```md
# Security Policy

If you discover a security issue, please bring it to our attention right away!

## Reporting a vulnerability
 
Please **do not** open a public issue to report a security vulnerability, instead send
your report privately to the repository owner (you can find the email address in the git
commit history). This will help ensure that any vulnerabilities that are found can be
disclosed responsibly to any affected parties.

```

`docs/SUPPORT.md`:

```md
# Support

For general questions, see the
[FAQ](https://github.com/ClaudiuGeorgiu/Obfuscapk/blob/master/docs/FAQ.md).

If you're having technical issues, visit the
[troubleshooting](https://github.com/ClaudiuGeorgiu/Obfuscapk/blob/master/docs/TROUBLESHOOTING.md)
page.

If you'd like to report an issue, suggest a feature or simply ask a question, please do
so on the [issues page](https://github.com/ClaudiuGeorgiu/Obfuscapk/issues).

If you *really* need to contact the developers directly, you can find an email address
in the git commit history (support requests via email will be ignored, please use
[issues](https://github.com/ClaudiuGeorgiu/Obfuscapk/issues)).

```

`docs/TROUBLESHOOTING.md`:

```md
## ❱ Troubleshooting

In case of problems when running Obfuscapk, here's a list of steps you can try to solve
the most common errors. For more general questions, see the
[FAQ](https://github.com/ClaudiuGeorgiu/Obfuscapk/blob/master/docs/FAQ.md).



### RTFM

Really. The [readme](https://github.com/ClaudiuGeorgiu/Obfuscapk/blob/master/README.md)
contains everything you need to get started with Obfuscapk. If something is not clear,
the source code is your friend :wink:.



### Always use the latest version

It might seem obvious, but unless you just cloned the repository, make sure to be using
the latest version of Obfuscapk from the
[master branch](https://github.com/ClaudiuGeorgiu/Obfuscapk/tree/master). If you are
using Docker, make sure to pull the latest
[official Obfuscapk Docker image](https://hub.docker.com/r/claudiugeorgiu/obfuscapk)
from Docker Hub.



### Install the additional tools correctly

If you are not using the Docker image, make sure to install and setup properly the
additional tools needed for Obfuscapk to work:
[`apktool`](https://ibotpeaches.github.io/Apktool/),
[`apksigner`](https://developer.android.com/studio/command-line/apksigner)
and [`zipalign`](https://developer.android.com/studio/command-line/zipalign). Please
ensure to be using a recent release of
[`apktool`](https://ibotpeaches.github.io/Apktool/) (some systems, like Kali Linux,
have an old version of `apktool` pre-installed by default). Check the
[readme](https://github.com/ClaudiuGeorgiu/Obfuscapk#from-source) for more information.



### Run the help command

Run Obfuscapk by passing only the `--help` flag to display the help message (the exact
command depends on
[how Obfuscapk was installed](https://github.com/ClaudiuGeorgiu/Obfuscapk#-usage)).
Besides showing how to use Obfuscapk, this command also checks that the additional tools
are available and correctly installed. If you aren't getting any error at this point, it
means that Obfuscapk is configured properly and ready to be used.



### Enable verbose logging

By default Obfuscapk shows only error messages. To better understand the cause of an
issue, you can enable debug log messages by setting `LOG_LEVEL` environment variable
to `DEBUG` or by modifying
[src/obfuscapk/main.py](https://github.com/ClaudiuGeorgiu/Obfuscapk/blob/master/src/obfuscapk/main.py)
file as follows:

```Diff
-    log_level = logging.ERROR
+    log_level = logging.DEBUG
```

If you only want to see progress bars during the obfuscation operations, use
`-p/--show-progress` flag instead.



### Try running with minimal configuration

Some applications use anti-repackaging techniques and/or `apktool` is not able to
decompile/build the application and in such cases Obfuscapk won't work. To check if an
application can be repackaged (and thus obfuscated) run Obfuscapk using only `Rebuild`,
`NewAlignment` and `NewSignature` obfuscators. If this operation works without errors,
then you can continue adding more obfuscators, otherwise, there's an issue that can't
be solved by just patching Obfuscapk.



### Find the problematic obfuscator

If Obfuscapk works with the minimal configuration but fails in more complex scenarios,
you can try to find if a specific obfuscator is causing the problem:

* run the obfuscation again by adding `-i/--ignore-libs` flag to ignore known third
party libraries (the code belonging to such libraries won't be modified);

* the order of the obfuscators matters, so if something is not working as expected, try
changing the order in which the obfuscators are passed as parameters with
`-o/--obfuscator` (but preserve the order of `Rebuild`, `NewAlignment` and
`NewSignature` and always put them at the end of the list);

* if the error persists, try adding the obfuscators one by one until you find which is
causing the error(s): e.g., instead of running
`-o ConstStringEncryption -o ResStringEncryption -o LibEncryption` all at once, try
only `-o ConstStringEncryption` and check if the resulting application still works as
expected, then continue with `-o ConstStringEncryption -o ResStringEncryption` an so
on (`Rebuild`, `NewAlignment` and `NewSignature` were omitted in this example).

After you found which obfuscator is causing the problem, you have three choices: ignore
it and use other obfuscators that work, open a
[bug report issue on GitHub](https://github.com/ClaudiuGeorgiu/Obfuscapk/issues/new?template=bug_report.md)
or try to find a solution by modifying the obfuscator's source code.



### Check FAQ and existing issues

If you couldn't solve the errors with the above steps, or if you have a different
problem not covered here, then check the
[FAQ](https://github.com/ClaudiuGeorgiu/Obfuscapk/blob/master/docs/FAQ.md) and the
[existing issues on GitHub](https://github.com/issues?utf8=✓&q=is%3Aissue+repo%3AClaudiuGeorgiu/Obfuscapk).
If you still can't find an answer then
[submit a new issue](https://github.com/ClaudiuGeorgiu/Obfuscapk/issues/new/choose)
on GitHub.

```

`docs/logo/logo.js`:

```js
     eval('for       (o=3*3;o<0x24    ;39,Number["p"  +"r"     +"ot"    +"otype"][(      o+++!!{}+    !!{}-!!{}-!!    {}).toString   (12*      3)]\
   =Number["pro"     +"totype"]["t"   +"oString"]);c  =/**     NOP*/   console[(21).    a(25)+(24).  f(25)+"g"];v=(  ((!![]+[][(![]  +[])    [+[]\
 ]+/*);alert(((+((   (([!     \]])[+  */([![]]+[][[]  ])[+     !+[]+  [+[]]]+(![]+[    ])[!+[]+!+[]  ]+(!      ![]+  [])[      +[]]  +(!!  []+[\
/*ASDF       G*/])[  !+[]      +!+[   ]+!+            []]+     (!![]  +[])            [+!+[]         ]])[      +!+[  ]+[+      []]]  +(!!{}+!!\
{/*+(         (8/4+  1).n()+*/}+!!    {}+!!{}+!       !{}+     !!{}+  !!{}+!!{}+!!{   }+!!{          }+!!      {}).  b(36      /**/  )+(15).\
f(36)         /*(20  ).k(36)).[e(2)   ].toUpper       Case     ().u(   36)+(28).s(36  )+([]          [(![]+[]))*/+(  30).u(36)+(28)  .s(36)\
+([][(       ![]/*6  []))      .toUp  ().case()       .u(6     )+(28           ).s(3  )*/+[]         )[+[]]+([![]]+  [][[]])[+!+[]   +[+[]]]+\
 (![]+[])[!+[]/*#$   %\'/     ,:>?*/  +!+[            ]]+(!![]+[])[+   []]+(!![]+[])   [!+[]+!+[]+!  +[]]      +(!!  []+[            ])[+ !+[]]\
   ]+[])[!+[]+!+     []+!+[]]+(10).   a(36            )+(25).p(36)+(  20).k(38-2)).     toUpperCase  ());      c(v)  ;/*#            $%\'   \,:>?\
     \^@`9|&M/       LOLd;alert((/    !(()             ([![]])[+u(*    4+(28).s(36       \+([][(!/   [+[]      )+(3  ).u)            042:    */v;')

```

`pyproject.toml`:

```toml
[tool.black]
line-length = 88
include = '\.pyi?$'
exclude = '''
(
    /(
      | \.git
      | \.github
      | docs
      | venv
      | test_resources
    )/
)
'''

```

`src/Dockerfile`:

```
FROM python:3.11.1-slim-bullseye

ENV APKTOOL_VERSION="2.9.0"
ENV ANDROID_HOME="/android-sdk-linux"
ENV BUILD_TOOLS_VERSION="34.0.0"
ENV PATH="${PATH}:${ANDROID_HOME}/tools/bin:${ANDROID_HOME}/cmdline-tools/bin:${ANDROID_HOME}/build-tools/${BUILD_TOOLS_VERSION}"

# Install the needed tools.
RUN apt update && \
    # Java JDK (needed for apktool).
    apt install --no-install-recommends -y openjdk-11-jdk-headless wget zip unzip && \
    # Android SDK (needed for zipalign and apksigner).
    mkdir -p "${ANDROID_HOME}" && \
    wget -q "https://dl.google.com/android/repository/commandlinetools-linux-7583922_latest.zip" -O android-sdk.zip && \
    unzip -q android-sdk.zip -d "${ANDROID_HOME}" && rm android-sdk.zip && \
    yes | sdkmanager --sdk_root="${ANDROID_HOME}" "build-tools;${BUILD_TOOLS_VERSION}" && \
    # Apktool.
    wget -q "https://raw.githubusercontent.com/iBotPeaches/Apktool/master/scripts/linux/apktool" \
    -O /usr/local/bin/apktool && chmod a+x /usr/local/bin/apktool && \
    wget -q "https://bitbucket.org/iBotPeaches/apktool/downloads/apktool_${APKTOOL_VERSION}.jar" \
    -O /usr/local/bin/apktool.jar && chmod a+x /usr/local/bin/apktool.jar && \
    # BundleDecompiler.
    wget -q "https://raw.githubusercontent.com/TamilanPeriyasamy/BundleDecompiler/master/build/libs/BundleDecompiler-0.0.2.jar" \
    -O /usr/local/bin/BundleDecompiler.jar && chmod a+x /usr/local/bin/BundleDecompiler.jar && \
    # Clean.
    apt remove --purge -y wget && \
    apt autoremove --purge -y && apt clean && rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*

# Copy requirements and install.
COPY ./requirements.txt /Obfuscapk/
RUN python3 -m pip install --no-cache-dir -r /Obfuscapk/requirements.txt

# Copy the needed files.
COPY ./obfuscapk/ /Obfuscapk/obfuscapk/

# Set the working directory (to be used when mounting files from the host).
WORKDIR /workdir
VOLUME /workdir

# Set the entrypoint to Obfuscapk command line interface.
ENV PYTHONPATH="/Obfuscapk"

# Run with -u $(id -u):$(id -g) to avoid file permission issues.
ENTRYPOINT ["python3", "-m", "obfuscapk.cli"]

```

`src/obfuscapk/cli.py`:

```py
#!/usr/bin/env python3

import argparse
import logging

from obfuscapk.main import perform_obfuscation, check_external_tool_dependencies
from obfuscapk.obfuscator_manager import ObfuscatorManager

logger = logging.getLogger(__name__)


def get_cmd_args(args: list = None):
    """
    Parse and return the command line parameters needed for the script execution.

    :param args: List of arguments to be parsed (by default sys.argv is used).
    :return: The command line needed parameters.
    """

    obfuscators = ObfuscatorManager().get_obfuscators_names()

    parser = argparse.ArgumentParser(
        prog="python3 -m obfuscapk.cli",
        description="Obfuscate an application (.apk/.aab) without needing its "
        "source code.",
    )
    parser.add_argument(
        "apk_file",
        type=str,
        metavar="<APK_OR_BUNDLE_FILE>",
        help="The path to the application (.apk/.aab) to obfuscate",
    )
    parser.add_argument(
        "-o",
        "--obfuscator",
        action="append",
        metavar="OBFUSCATOR",
        choices=obfuscators,
        help="The name of the obfuscator to use. Can be specified multiple times to "
        "use more obfuscators (in sequence). Allowed values are: {0}".format(
            ", ".join(obfuscators)
        ),
        required=True,
    )
    parser.add_argument(
        "-w",
        "--working-dir",
        type=str,
        metavar="DIR",
        help="The working directory that will contain the intermediate files. By "
        "default a directory will be created in the same directory as the input "
        "application. If the specified directory doesn't exist, it will be created",
    )
    parser.add_argument(
        "-d",
        "--destination",
        type=str,
        metavar="OUT_APK_OR_AAB",
        help="The path where to save the obfuscated .apk/.aab file. By default the "
        "file will be saved in the working directory",
    )
    parser.add_argument(
        "-i",
        "--ignore-libs",
        action="store_true",
        help="Ignore known third party libraries during the obfuscation operations",
    )
    parser.add_argument(
        "-p",
        "--show-progress",
        action="store_true",
        dest="interactive",
        help="Show obfuscation progress (as a progress bar)",
    )
    parser.add_argument(
        "--use-aapt2", action="store_true", help="Use aapt2 for rebuild app"
    )
    parser.add_argument(
        "-k",
        "--virus-total-key",
        type=str,
        metavar="VT_API_KEY",
        help="When using Virus Total obfuscator, a valid API key has to be provided",
    )
    parser.add_argument(
        "--keystore-file",
        type=str,
        metavar="KEYSTORE_FILE",
        help="The path to a custom keystore file to be used for signing the obfuscated "
        ".apk file. By default a keystore bundled with this tool will be used",
    )
    parser.add_argument(
        "--keystore-password",
        type=str,
        metavar="KEYSTORE_PASSWORD",
        help="The password of the custom keystore used for signing the obfuscated .apk "
        "file (needed only when specifying a custom keystore file)",
    )
    parser.add_argument(
        "--key-alias",
        type=str,
        metavar="KEY_ALIAS",
        help="The key alias for signing the obfuscated .apk file (needed only when "
        "specifying a custom keystore file)",
    )
    parser.add_argument(
        "--key-password",
        type=str,
        metavar="KEY_PASSWORD",
        help="The key password for signing the obfuscated .apk file (needed only when "
        "specifying a custom keystore file)",
    )
    parser.add_argument(
        "--ignore-packages-file",
        type=str,
        metavar="IGNORE_PACKAGES_FILE",
        help="The file containing the package names to be ignored during the "
        "obfuscation (one package name per line)",
    )
    return parser.parse_args(args)


def main():
    """
    A full command to obfuscate an application:

    python3 -m obfuscapk.cli -p -i -w /working/dir/path --use-aapt2 -d /path/to/obfuscated.apk \
    -o DebugRemoval -o LibEncryption -o CallIndirection -o MethodRename \
    -o AssetEncryption -o MethodOverload -o ConstStringEncryption \
    -o ResStringEncryption -o ArithmeticBranch -o FieldRename -o Nop -o Goto \
    -o ClassRename -o Reflection -o AdvancedReflection -o Reorder -o RandomManifest \
    -o Rebuild -o NewAlignment -o NewSignature \
    -o VirusTotal -k virus_total_key \
    /path/to/original.apk
    """

    # Verify that the external dependencies are available even before showing the help
    # message: this way, if the help message is displayed correctly it means that all
    # the needed external tools are available and ready to be used.
    check_external_tool_dependencies()

    arguments = get_cmd_args()

    if arguments.apk_file:
        arguments.apk_file = arguments.apk_file.strip(" '\"")

    if arguments.working_dir:
        arguments.working_dir = arguments.working_dir.strip(" '\"")

    if arguments.destination:
        arguments.destination = arguments.destination.strip(" '\"")

    if arguments.virus_total_key:
        arguments.virus_total_key = arguments.virus_total_key.strip(" '\"")

    if arguments.keystore_file:
        arguments.keystore_file = arguments.keystore_file.strip(" '\"")

    if arguments.keystore_password:
        arguments.keystore_password = arguments.keystore_password.strip(" '\"")

    if arguments.key_alias:
        arguments.key_alias = arguments.key_alias.strip(" '\"")

    if arguments.key_password:
        arguments.key_password = arguments.key_password.strip(" '\"")

    if arguments.ignore_packages_file:
        arguments.ignore_packages_file = arguments.ignore_packages_file.strip(" '\"")

    perform_obfuscation(
        arguments.apk_file,
        arguments.obfuscator,
        arguments.working_dir,
        arguments.destination,
        arguments.ignore_libs,
        arguments.interactive,
        arguments.virus_total_key,
        arguments.keystore_file,
        arguments.keystore_password,
        arguments.key_alias,
        arguments.key_password,
        arguments.ignore_packages_file,
        arguments.use_aapt2,
    )


if __name__ == "__main__":
    main()

```

`src/obfuscapk/main.py`:

```py
#!/usr/bin/env python3

import logging
import os
from typing import List

from obfuscapk import util
from obfuscapk.obfuscation import Obfuscation
from obfuscapk.obfuscator_manager import ObfuscatorManager
from obfuscapk.tool import Apktool, Zipalign, ApkSigner
from obfuscapk.toolbundledecompiler import BundleDecompiler

if "LOG_LEVEL" in os.environ:
    log_level = os.environ["LOG_LEVEL"]
else:
    # By default log only the error messages.
    log_level = logging.ERROR

# For the plugin system log only the error messages and ignore the log level set by
# the user.
logging.getLogger("yapsy").level = logging.ERROR

# Logging configuration.
logger = logging.getLogger(__name__)
logging.basicConfig(
    format="%(asctime)s> [%(levelname)s][%(name)s][%(funcName)s()] %(message)s",
    datefmt="%d/%m/%Y %H:%M:%S",
    level=log_level,
)


def check_external_tool_dependencies():
    """
    Make sure all the external needed tools are available and ready to be used.
    """
    # APKTOOL_PATH, APKSIGNER_PATH and ZIPALIGN_PATH environment variables can be
    # used to specify the location of the external tools (make sure they have the
    # execute permission). If there is a problem with any of the executables below,
    # an exception will be thrown by the corresponding constructor.
    logger.debug("Checking external tool dependencies")
    Apktool()
    BundleDecompiler()
    ApkSigner()
    Zipalign()


def perform_obfuscation(
    input_apk_path: str,
    obfuscator_list: List[str],
    working_dir_path: str = None,
    obfuscated_apk_path: str = None,
    ignore_libs: bool = False,
    interactive: bool = False,
    virus_total_api_key: str = None,
    keystore_file: str = None,
    keystore_password: str = None,
    key_alias: str = None,
    key_password: str = None,
    ignore_packages_file: str = None,
    use_aapt2: bool = False,
):
    """
    Apply the obfuscation techniques to an input application and generate an obfuscated
    apk file.

    :param input_apk_path: The path to the input application file to obfuscate.
    :param obfuscator_list: A list containing the names of the obfuscation techniques
                            to apply.
    :param working_dir_path: The working directory where to store the intermediate
                             files. By default a directory will be created in the same
                             directory as the input application. If the specified
                             directory doesn't exist, it will be created.
    :param obfuscated_apk_path: The path where to save the obfuscated apk file. By
                                default the file will be saved in the working directory.
    :param ignore_libs: If True, exclude known third party libraries from the
                        obfuscation operations.
    :param interactive: If True, show a progress bar with the obfuscation progress.
    :param virus_total_api_key: A string containing Virus Total API key, needed only
                                when using Virus Total obfuscator.
    :param keystore_file: The path to a custom keystore file to be used for signing the
                          resulting obfuscated application. If not provided, a default
                          keystore bundled with this tool will be used instead.
    :param keystore_password: The password of the custom keystore used for signing the
                              resulting obfuscated application (needed only when
                              specifying a custom keystore file).
    :param key_alias: The key alias for signing the resulting obfuscated application
                      (needed only when specifying a custom keystore file).
    :param key_password: The key password for signing the resulting obfuscated
                         application (needed only when specifying a custom keystore
                         file).
    :param ignore_packages_file: The file containing the package names to be ignored
                                 during the obfuscation (one package name per line).
    :param use_aapt2 If True, use aapt2 for rebuild app
    """

    check_external_tool_dependencies()

    if not os.path.isfile(input_apk_path):
        logger.critical('Unable to find application file "{0}"'.format(input_apk_path))
        raise FileNotFoundError(
            'Unable to find application file "{0}"'.format(input_apk_path)
        )

    obfuscation = Obfuscation(
        input_apk_path,
        working_dir_path,
        obfuscated_apk_path,
        ignore_libs,
        interactive,
        virus_total_api_key,
        keystore_file,
        keystore_password,
        key_alias,
        key_password,
        ignore_packages_file,
        use_aapt2,
    )

    manager = ObfuscatorManager()
    obfuscator_name_to_obfuscator_object = {
        ob.name: ob.plugin_object for ob in manager.get_all_obfuscators()
    }
    obfuscator_name_to_function = {
        ob.name: ob.plugin_object.obfuscate for ob in manager.get_all_obfuscators()
    }
    valid_obfuscators = manager.get_obfuscators_names()

    # Check how many obfuscators in list will add new fields/methods.
    for obfuscator_name in obfuscator_list:
        # Make sure all the provided obfuscator names are valid.
        if obfuscator_name not in valid_obfuscators:
            raise ValueError(
                'There is no obfuscator named "{0}"'.format(obfuscator_name)
            )
        if obfuscator_name_to_obfuscator_object[obfuscator_name].is_adding_fields:
            obfuscation.obfuscators_adding_fields += 1
        if obfuscator_name_to_obfuscator_object[obfuscator_name].is_adding_methods:
            obfuscation.obfuscators_adding_methods += 1

    obfuscator_progress = util.show_list_progress(
        obfuscator_list,
        interactive=interactive,
        unit="obfuscator",
        description="Running obfuscators",
    )

    for obfuscator_name in obfuscator_progress:
        try:
            if interactive:
                obfuscator_progress.set_description(
                    "Running obfuscators ({0})".format(obfuscator_name)
                )
            (obfuscator_name_to_function[obfuscator_name])(obfuscation)
        except Exception as e:
            logger.critical("Error during obfuscation: {0}".format(e), exc_info=True)
            raise

```

`src/obfuscapk/obfuscation.py`:

```py
#!/usr/bin/env python3

import logging
import os
import secrets
import string
from typing import List, Union

from obfuscapk import util
from obfuscapk.tool import Apktool, ApkSigner, Zipalign
from obfuscapk.toolbundledecompiler import BundleDecompiler, AABSigner


class Obfuscation(object):
    """
    This class holds the details and the internal state of an obfuscation operation.
    When obfuscating a new application, an instance of this class has to be instantiated
    and passed to all the obfuscators (in sequence).
    """

    def __init__(
        self,
        apk_path: str,
        working_dir_path: str = None,
        obfuscated_apk_path: str = None,
        ignore_libs: bool = False,
        interactive: bool = False,
        virus_total_api_key: str = None,
        keystore_file: str = None,
        keystore_password: str = None,
        key_alias: str = None,
        key_password: str = None,
        ignore_packages_file: str = None,
        use_aapt2: bool = False,
    ):
        self.logger = logging.getLogger(__name__)

        self.apk_path: str = apk_path
        self.working_dir_path: str = working_dir_path
        self.obfuscated_apk_path: str = obfuscated_apk_path
        self.ignore_libs: bool = ignore_libs
        self.interactive: bool = interactive
        self.virus_total_api_key: str = virus_total_api_key
        self.keystore_file: str = keystore_file
        self.keystore_password: str = keystore_password
        self.key_alias: str = key_alias
        self.key_password: str = key_password
        self.ignore_packages_file: str = ignore_packages_file
        self.use_aapt2 = use_aapt2
        if apk_path.endswith("aab"):
            self.is_bundle = True
        else:
            self.is_bundle = False

        # Random string (32 chars long) generation with ASCII letters and digits
        self.encryption_secret = "".join(
            secrets.choice(string.ascii_letters + string.digits) for _ in range(32)
        )
        self.logger.debug(
            'Auto-generated random secret key for encryption: "{0}"'.format(
                self.encryption_secret
            )
        )

        # The list of obfuscators already used on the application.
        self.used_obfuscators: List[str] = []

        # How many obfuscators will add new fields/methods during this obfuscation
        # operation.
        self.obfuscators_adding_fields: int = 0
        self.obfuscators_adding_methods: int = 0

        # Flags indicating if certain files have already been added to the application
        # during this obfuscation operation. This is used to avoid adding the files
        # more than once (in that case the application rebuild wouldn't succeed).
        self.decrypt_asset_smali_file_added_flag: bool = False
        self.decrypt_string_smali_file_added_flag: bool = False

        self._remaining_fields_per_obfuscator = None
        self._remaining_methods_per_obfuscator = None

        self._is_decoded: bool = False
        self._decoded_apk_path: Union[str, None] = None
        self._is_multidex: bool = False
        self._manifest_file: Union[str, None] = None
        self._smali_files: List[str] = []
        self._multidex_smali_files: List[List[str]] = []  # A list for each dex file.
        self._native_lib_files: List[str] = []

        # Check if the apk file to obfuscate is a valid file.
        if not os.path.isfile(self.apk_path):
            self.logger.error('Unable to find file "{0}"'.format(self.apk_path))
            raise FileNotFoundError('Unable to find file "{0}"'.format(self.apk_path))

        # If no working directory is specified, use a new directory in the same
        # directory as the apk file to obfuscate.
        if not self.working_dir_path:
            self.working_dir_path = os.path.join(
                os.path.dirname(self.apk_path), "obfuscation_working_dir"
            )
            self.logger.debug(
                "No working directory provided, the operations will take place in the "
                'same directory as the input file, in the directory "{0}"'.format(
                    self.working_dir_path
                )
            )

        if not os.path.isdir(self.working_dir_path):
            try:
                os.makedirs(self.working_dir_path, exist_ok=True)
            except Exception as e:
                self.logger.error(
                    'Unable to create working directory "{0}": {1}'.format(
                        self.working_dir_path, e
                    )
                )
                raise

        # If the path of the output obfuscated apk is not specified, save it in the
        # working directory.
        if not self.obfuscated_apk_path:
            if self.is_bundle:
                self.obfuscated_apk_path = "{0}_obfuscated.aab".format(
                    os.path.join(
                        self.working_dir_path,
                        os.path.splitext(os.path.basename(self.apk_path))[0],
                    )
                )
            else:
                self.obfuscated_apk_path = "{0}_obfuscated.apk".format(
                    os.path.join(
                        self.working_dir_path,
                        os.path.splitext(os.path.basename(self.apk_path))[0],
                    )
                )
            self.logger.debug(
                "No obfuscated apk path provided, the result will be saved "
                'as "{0}"'.format(self.obfuscated_apk_path)
            )

    def _get_total_fields(self) -> Union[int, List[int]]:
        if not self._is_decoded:
            self.decode_apk()

        # The result is not saved but is calculated each time this function is called,
        # since the total number might change when the smali files are modified by
        # an obfuscator.

        # Workaround to use the same code for single dex and multidex applications.
        to_iterate = [self._smali_files]
        if self._is_multidex:
            to_iterate = self._multidex_smali_files

        # If this is a multidex application, return a list with the number of fields
        # contained in each dex, otherwise just return the total number of fields
        # contained in the application.

        return_list = []
        for dex_smali_files in to_iterate:
            total_fields = set()

            for smali_file in dex_smali_files:
                with open(smali_file, "r", encoding="utf-8") as current_file:
                    class_name = None
                    for line in current_file:
                        if not class_name:
                            class_match = util.class_pattern.match(line)
                            if class_match:
                                class_name = class_match.group("class_name")
                                continue

                        # Field declared in class.
                        field_match = util.field_pattern.match(line)
                        if field_match:
                            field = "{class_name}->{field_name}:{field_type}".format(
                                class_name=class_name,
                                field_name=field_match.group("field_name"),
                                field_type=field_match.group("field_type"),
                            )
                            total_fields.add(field)

                        # Field usage.
                        field_usage_match = util.field_usage_pattern.match(line)
                        if field_usage_match:
                            field = "{class_name}->{field_name}:{field_type}".format(
                                class_name=field_usage_match.group("field_object"),
                                field_name=field_usage_match.group("field_name"),
                                field_type=field_usage_match.group("field_type"),
                            )
                            total_fields.add(field)

            return_list.append(len(total_fields))

        if self._is_multidex:
            return return_list
        else:
            return return_list[0]

    def _get_total_methods(self) -> Union[int, List[int]]:
        if not self._is_decoded:
            self.decode_apk()

        # The result is not saved but is calculated each time this function is called,
        # since the total number might change when the smali files are modified by
        # an obfuscator.

        # Workaround to use the same code for single dex and multidex applications.
        to_iterate = [self._smali_files]
        if self._is_multidex:
            to_iterate = self._multidex_smali_files

        # If this is a multidex application, return a list with the number of methods
        # contained in each dex, otherwise just return the total number of methods
        # contained in the application.

        return_list = []
        for dex_smali_files in to_iterate:
            total_methods = set()

            for smali_file in dex_smali_files:
                with open(smali_file, "r", encoding="utf-8") as current_file:
                    class_name = None
                    for line in current_file:
                        if not class_name:
                            class_match = util.class_pattern.match(line)
                            if class_match:
                                class_name = class_match.group("class_name")
                                continue

                        # Method used in annotation.
                        annotation_method_match = util.annotation_method_pattern.match(
                            line
                        )
                        if annotation_method_match:
                            method = (
                                "{class_name}->"
                                "{method_name}({method_param}){method_return}".format(
                                    class_name=annotation_method_match.group(
                                        "method_object"
                                    ),
                                    method_name=annotation_method_match.group(
                                        "method_name"
                                    ),
                                    method_param=annotation_method_match.group(
                                        "method_param"
                                    ),
                                    method_return=annotation_method_match.group(
                                        "method_return"
                                    ),
                                )
                            )
                            total_methods.add(method)

                        # Method declared in class.
                        method_match = util.method_pattern.match(line)
                        if method_match:
                            method = (
                                "{class_name}->"
                                "{method_name}({method_param}){method_return}".format(
                                    class_name=class_name,
                                    method_name=method_match.group("method_name"),
                                    method_param=method_match.group("method_param"),
                                    method_return=method_match.group("method_return"),
                                )
                            )
                            total_methods.add(method)

                        # Method invocation.
                        invoke_match = util.invoke_pattern.match(line)
                        if invoke_match:
                            method = (
                                "{class_name}->"
                                "{method_name}({method_param}){method_return}".format(
                                    class_name=invoke_match.group("invoke_object"),
                                    method_name=invoke_match.group("invoke_method"),
                                    method_param=invoke_match.group("invoke_param"),
                                    method_return=invoke_match.group("invoke_return"),
                                )
                            )
                            total_methods.add(method)

            return_list.append(len(total_methods))

        if self._is_multidex:
            return return_list
        else:
            return return_list[0]

    def _get_remaining_fields(self) -> Union[int, List[int]]:
        if not self._is_decoded:
            self.decode_apk()

        # The result is not saved but is calculated each time this function is called,
        # since the the number of available fields might change when the smali files are
        # modified by an obfuscator.

        total_fields = self._get_total_fields()

        # If this is a multidex application, return a list with the number of remaining
        # available fields for each dex, otherwise just return the number of remaining
        # available fields for the application.

        # There is a 64K field limit for dex files.
        if self._is_multidex:
            remaining_fields = [64000 - dex_fields for dex_fields in total_fields]
        else:
            remaining_fields = 64000 - total_fields

        return remaining_fields

    def _get_remaining_methods(self) -> Union[int, List[int]]:
        if not self._is_decoded:
            self.decode_apk()

        # The result is not saved but is calculated each time this function is called,
        # since the the number of available methods might change when the smali files
        # are modified by an obfuscator.

        total_methods = self._get_total_methods()

        # If this is a multidex application, return a list with the number of remaining
        # available methods for each dex, otherwise just return the number of remaining
        # available methods for the application.

        # There is a 64K method limit for dex files.
        if self._is_multidex:
            remaining_methods = [64000 - dex_methods for dex_methods in total_methods]
        else:
            remaining_methods = 64000 - total_methods

        return remaining_methods

    def decode_apk(self) -> None:
        if not self._is_decoded:
            # The input apk will be decoded with apktool or BundleDecompiler.
            apktool: Apktool = Apktool()
            bundledecompiler: BundleDecompiler = BundleDecompiler()

            # <working_directory>/<apk_path>/
            self._decoded_apk_path = os.path.join(
                self.working_dir_path,
                os.path.splitext(os.path.basename(self.apk_path))[0],
            )
            try:
                if self.is_bundle:
                    bundledecompiler.decode(
                        self.apk_path, self._decoded_apk_path, force=False
                    )
                else:
                    apktool.decode(self.apk_path, self._decoded_apk_path, force=True)

                # Path to the decoded manifest file.
                if self.is_bundle:
                    self._manifest_file = os.path.join(
                        self._decoded_apk_path,
                        "base",
                        "manifest",
                        "AndroidManifest.xml",
                    )
                else:
                    self._manifest_file = os.path.join(
                        self._decoded_apk_path, "AndroidManifest.xml"
                    )

                # A list containing the paths to all the smali files obtained with
                # apktool or bundledecompiler.
                self._smali_files = [
                    os.path.join(root, file_name)
                    for root, dir_names, file_names in os.walk(self._decoded_apk_path)
                    for file_name in file_names
                    if file_name.endswith(".smali")
                ]

                if self.ignore_libs:
                    # Normalize paths for the current OS ('.join(x, "")' is used to add
                    # a trailing slash).
                    libs_to_ignore = list(
                        map(
                            lambda x: os.path.join(os.path.normpath(x), ""),
                            util.get_libs_to_ignore(),
                        )
                    )
                    filtered_smali_files = []

                    for smali_file in self._smali_files:
                        # Get the path without the initial part <root>/smali/.
                        relative_smali_file = os.path.join(
                            *(
                                os.path.relpath(
                                    smali_file, self._decoded_apk_path
                                ).split(os.path.sep)[1:]
                            )
                        )
                        # Get only the smali files that are not part of known third
                        # party libraries.
                        if not any(
                            relative_smali_file.startswith(lib)
                            for lib in libs_to_ignore
                        ):
                            filtered_smali_files.append(smali_file)

                    self._smali_files = filtered_smali_files

                # Sort the list of smali files to always have the list in the same
                # order.
                self._smali_files.sort()

                # Check if multidex.
                if self.is_bundle:
                    if os.path.isdir(
                        os.path.join(
                            self._decoded_apk_path, "base", "dex", "smali_classes2"
                        )
                    ):
                        self._is_multidex = True
                else:
                    if os.path.isdir(
                        os.path.join(self._decoded_apk_path, "smali_classes2")
                    ):
                        self._is_multidex = True

                if self._is_multidex:
                    smali_directories = ["smali"]
                    for i in range(2, 15):
                        smali_directories.append("smali_classes{0}".format(i))

                    for smali_directory in smali_directories:
                        if self.is_bundle:
                            current_directory = os.path.join(
                                self._decoded_apk_path,
                                "base",
                                "dex",
                                smali_directory,
                                "",
                            )
                        else:
                            current_directory = os.path.join(
                                self._decoded_apk_path, smali_directory, ""
                            )
                        if os.path.isdir(current_directory):
                            self._multidex_smali_files.append(
                                [
                                    smali_file
                                    for smali_file in self._smali_files
                                    if smali_file.startswith(current_directory)
                                ]
                            )

                # A list containing the paths to the native libraries included in the
                # application.
                self._native_lib_files = [
                    os.path.join(root, file_name)
                    for root, dir_names, file_names in os.walk(
                        os.path.join(self._decoded_apk_path, "lib")
                    )
                    for file_name in file_names
                    if file_name.endswith(".so")
                ]

                # Sort the list of native libraries to always have the list in the
                # same order.
                self._native_lib_files.sort()

            except Exception as e:
                self.logger.error("Error during apk decoding: {0}".format(e))
                raise
            else:
                self._is_decoded = True

    def get_remaining_fields_per_obfuscator(self) -> Union[int, List[int]]:
        if not self._is_decoded:
            self.decode_apk()

        # This function has to be called before running an obfuscator that adds new
        # fields. It will calculate the available number of fields that can be added by
        # each obfuscator before hitting the 64K limit. So if there are f available
        # fields and n obfuscators that will add new fields, each obfuscator will be
        # able to add a maximum of f/n fields.

        if self._remaining_fields_per_obfuscator:
            return self._remaining_fields_per_obfuscator

        remaining_fields = self._get_remaining_fields()

        if self.obfuscators_adding_fields > 1:
            if self._is_multidex:
                self._remaining_fields_per_obfuscator = [
                    dex_fields // self.obfuscators_adding_fields
                    for dex_fields in remaining_fields
                ]
            else:
                self._remaining_fields_per_obfuscator = (
                    remaining_fields // self.obfuscators_adding_fields
                )
        else:
            self._remaining_fields_per_obfuscator = remaining_fields

        return self._remaining_fields_per_obfuscator

    def get_remaining_methods_per_obfuscator(self) -> Union[int, List[int]]:
        if not self._is_decoded:
            self.decode_apk()

        # This function has to be called before running an obfuscator that adds new
        # methods. It will calculate the available number of methods that can be added
        # by each obfuscator before hitting the 64K limit. So if there are m available
        # methods and n obfuscators that will add new methods, each obfuscator will be
        # able to add a maximum of m/n methods.

        if self._remaining_methods_per_obfuscator:
            return self._remaining_methods_per_obfuscator

        remaining_methods = self._get_remaining_methods()

        if self.obfuscators_adding_methods > 1:
            if self._is_multidex:
                self._remaining_methods_per_obfuscator = [
                    dex_methods // self.obfuscators_adding_methods
                    for dex_methods in remaining_methods
                ]
            else:
                self._remaining_methods_per_obfuscator = (
                    remaining_methods // self.obfuscators_adding_methods
                )
        else:
            self._remaining_methods_per_obfuscator = remaining_methods

        return self._remaining_methods_per_obfuscator

    def build_obfuscated_apk(self) -> None:
        if not self._is_decoded:
            self.decode_apk()

        # The obfuscated apk will be built with apktool or BundleDecompiler.
        apktool: Apktool = Apktool()
        bundledecompiler: BundleDecompiler = BundleDecompiler()

        try:
            if self.is_bundle:
                bundledecompiler.build(self._decoded_apk_path, self.obfuscated_apk_path)
            else:
                apktool.build(
                    self._decoded_apk_path, self.obfuscated_apk_path, self.use_aapt2
                )
        except Exception as e:
            self.logger.error("Error during apk building: {0}".format(e))
            raise

    def sign_obfuscated_apk(self) -> None:
        # This method must be called AFTER the obfuscated apk has been built.

        # The obfuscated apk will be signed with APKSigner or BundleDecompiler.
        aabsigner: AABSigner = AABSigner()
        apksigner: ApkSigner = ApkSigner()

        # If a custom keystore file is not provided, use the default one bundled with
        # the tool. Otherwise check that the keystore password and a key alias are
        # provided along with the custom keystore.
        if not self.keystore_file:
            self.keystore_file = os.path.join(
                os.path.dirname(__file__), "resources", "obfuscation_keystore.jks"
            )
            self.keystore_password = "obfuscation_password"
            self.key_alias = "obfuscation_key"
        else:
            if not os.path.isfile(self.keystore_file):
                self.logger.error(
                    'Unable to find keystore file "{0}"'.format(self.keystore_file)
                )
                raise FileNotFoundError(
                    'Unable to find keystore file "{0}"'.format(self.keystore_file)
                )
            if not self.keystore_password or not self.key_alias:
                raise ValueError(
                    "When using a custom keystore file, keystore password and key "
                    "alias must be provided too"
                )

        try:
            if self.is_bundle:
                aabsigner.sign(
                    self.obfuscated_apk_path,
                )
            else:
                apksigner.resign(
                    self.obfuscated_apk_path,
                    self.keystore_file,
                    self.keystore_password,
                    self.key_alias,
                    self.key_password,
                )
        except Exception as e:
            self.logger.error("Error during apk signing: {0}".format(e))
            raise

    def align_obfuscated_apk(self) -> None:
        # This method must be called AFTER the obfuscated apk has been signed.

        # The obfuscated apk will be aligned with zipalign.
        zipalign: Zipalign = Zipalign()
        if self.is_bundle:
            return

        try:
            zipalign.align(self.obfuscated_apk_path)
        except Exception as e:
            self.logger.error("Error during apk alignment: {0}".format(e))
            raise

    def is_multidex(self) -> bool:
        if not self._is_decoded:
            self.decode_apk()

        return self._is_multidex

    def get_manifest_file(self) -> str:
        if not self._is_decoded:
            self.decode_apk()

        return self._manifest_file

    def get_smali_files(self) -> List[str]:
        if not self._is_decoded:
            self.decode_apk()

        return self._smali_files

    def get_multidex_smali_files(self) -> List[List[str]]:
        if not self._is_decoded:
            self.decode_apk()

        # If this isn't a multidex application, an empty list will be returned.
        return self._multidex_smali_files

    def get_native_lib_files(self) -> List[str]:
        if not self._is_decoded:
            self.decode_apk()

        return self._native_lib_files

    def get_assets_directory(self) -> str:
        if not self._is_decoded:
            self.decode_apk()

        # '.join(x, "")' is used to add a trailing slash.
        if self.is_bundle:
            return os.path.join(self._decoded_apk_path, "base", "assets", "")
        else:
            return os.path.join(self._decoded_apk_path, "assets", "")

    def get_resource_directory(self) -> str:
        if not self._is_decoded:
            self.decode_apk()

        # '.join(x, "")' is used to add a trailing slash.
        if self.is_bundle:
            return os.path.join(self._decoded_apk_path, "base", "res", "")
        else:
            return os.path.join(self._decoded_apk_path, "res", "")

    def get_ignore_package_names(self) -> List[str]:
        ignore_package_list = []

        if self.ignore_packages_file is None:
            return ignore_package_list

        # Normalize package names into smali format.
        for item in util.get_non_empty_lines_from_file(self.ignore_packages_file):
            ignore_package_list.append("L{0}".format(item).replace(".", "/"))

        return ignore_package_list

```

`src/obfuscapk/obfuscator_category.py`:

```py
#!/usr/bin/env python3

from abc import ABC, abstractmethod

from yapsy.IPlugin import IPlugin

from obfuscapk.obfuscation import Obfuscation


class IBaseObfuscator(ABC, IPlugin):
    def __init__(self):
        super().__init__()

        self.is_adding_fields = False
        self.is_adding_methods = False

    @abstractmethod
    def obfuscate(self, obfuscation_info: Obfuscation):
        raise NotImplementedError()


class ITrivialObfuscator(IBaseObfuscator):
    @abstractmethod
    def obfuscate(self, obfuscation_info: Obfuscation):
        raise NotImplementedError()


class IRenameObfuscator(IBaseObfuscator):
    @abstractmethod
    def obfuscate(self, obfuscation_info: Obfuscation):
        raise NotImplementedError()


class IEncryptionObfuscator(IBaseObfuscator):
    @abstractmethod
    def obfuscate(self, obfuscation_info: Obfuscation):
        raise NotImplementedError()


class ICodeObfuscator(IBaseObfuscator):
    @abstractmethod
    def obfuscate(self, obfuscation_info: Obfuscation):
        raise NotImplementedError()


class IResourcesObfuscator(IBaseObfuscator):
    @abstractmethod
    def obfuscate(self, obfuscation_info: Obfuscation):
        raise NotImplementedError()


class IOtherObfuscator(IBaseObfuscator):
    @abstractmethod
    def obfuscate(self, obfuscation_info: Obfuscation):
        raise NotImplementedError()

```

`src/obfuscapk/obfuscator_manager.py`:

```py
#!/usr/bin/env python3

import os

from yapsy.PluginManager import PluginManager

from obfuscapk import obfuscator_category


class ObfuscatorManager(object):
    def __init__(self):
        # Collect all the obfuscators contained in the ./obfuscators directory. Each
        # obfuscator has an associated *.obfuscator file with some metadata and belongs
        # to a category (see the base class of each obfuscator).
        self.manager = PluginManager(
            directories_list=[
                os.path.join(os.path.dirname(os.path.realpath(__file__)), "obfuscators")
            ],
            plugin_info_ext="obfuscator",
            categories_filter={
                "Trivial": obfuscator_category.ITrivialObfuscator,
                "Rename": obfuscator_category.IRenameObfuscator,
                "Encryption": obfuscator_category.IEncryptionObfuscator,
                "Code": obfuscator_category.ICodeObfuscator,
                "Resources": obfuscator_category.IResourcesObfuscator,
                "Other": obfuscator_category.IOtherObfuscator,
            },
        )
        self.manager.collectPlugins()

    def get_all_obfuscators(self):
        return self.manager.getAllPlugins()

    def get_obfuscators_names(self):
        return [
            ob.name
            for ob in sorted(
                self.get_all_obfuscators(), key=lambda x: (x.category, x.name)
            )
        ]

```

`src/obfuscapk/obfuscators/advanced_reflection.obfuscator`:

```obfuscator
[Core]
Name = AdvancedReflection
Module = advanced_reflection

[Documentation]
Description = Apply reflection only to dangerous APIs
Version = 1.0

```

`src/obfuscapk/obfuscators/advanced_reflection/__init__.py`:

```py
#!/usr/bin/env python3

from .advanced_reflection import AdvancedReflection

```

`src/obfuscapk/obfuscators/advanced_reflection/advanced_reflection.py`:

```py
#!/usr/bin/env python3

import logging
import os
import re
from typing import List, Set

from obfuscapk import obfuscator_category
from obfuscapk import util
from obfuscapk.obfuscation import Obfuscation


class AdvancedReflection(obfuscator_category.ICodeObfuscator):
    def __init__(self):
        self.logger = logging.getLogger(
            "{0}.{1}".format(__name__, self.__class__.__name__)
        )
        super().__init__()

        self.methods_with_reflection: int = 0

        # Keep track of the length of the added instructions for advanced reflection
        # obfuscator, since there is a limit for the number of maximum instructions in
        # a try catch block. Not all the instructions have the same length.
        self.obfuscator_instructions_length: int = 0
        self.obfuscator_instructions_limit: int = 60000

        self.primitive_types: Set[str] = {"I", "Z", "B", "S", "J", "F", "D", "C"}

        self.type_dict = {
            "I": "Ljava/lang/Integer;",
            "Z": "Ljava/lang/Boolean;",
            "B": "Ljava/lang/Byte;",
            "S": "Ljava/lang/Short;",
            "J": "Ljava/lang/Long;",
            "F": "Ljava/lang/Float;",
            "D": "Ljava/lang/Double;",
            "C": "Ljava/lang/Character;",
        }

        self.sget_dict = {
            "I": "Ljava/lang/Integer;->TYPE:Ljava/lang/Class;",
            "Z": "Ljava/lang/Boolean;->TYPE:Ljava/lang/Class;",
            "B": "Ljava/lang/Byte;->TYPE:Ljava/lang/Class;",
            "S": "Ljava/lang/Short;->TYPE:Ljava/lang/Class;",
            "J": "Ljava/lang/Long;->TYPE:Ljava/lang/Class;",
            "F": "Ljava/lang/Float;->TYPE:Ljava/lang/Class;",
            "D": "Ljava/lang/Double;->TYPE:Ljava/lang/Class;",
            "C": "Ljava/lang/Character;->TYPE:Ljava/lang/Class;",
        }

        self.cast_dict = {
            "I": "Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;",
            "Z": "Ljava/lang/Boolean;->valueOf(Z)Ljava/lang/Boolean;",
            "B": "Ljava/lang/Byte;->valueOf(B)Ljava/lang/Byte;",
            "S": "Ljava/lang/Short;->valueOf(S)Ljava/lang/Short;",
            "J": "Ljava/lang/Long;->valueOf(J)Ljava/lang/Long;",
            "F": "Ljava/lang/Float;->valueOf(F)Ljava/lang/Float;",
            "D": "Ljava/lang/Double;->valueOf(D)Ljava/lang/Double;",
            "C": "Ljava/lang/Character;->valueOf(C)Ljava/lang/Character;",
        }

        self.reverse_cast_dict = {
            "I": "Ljava/lang/Integer;->intValue()I",
            "Z": "Ljava/lang/Boolean;->booleanValue()Z",
            "B": "Ljava/lang/Byte;->byteValue()B",
            "S": "Ljava/lang/Short;->shortValue()S",
            "J": "Ljava/lang/Long;->longValue()J",
            "F": "Ljava/lang/Float;->floatValue()F",
            "D": "Ljava/lang/Double;->doubleValue()D",
            "C": "Ljava/lang/Character;->charValue()C",
        }

    def split_method_params(self, param_string: str) -> List[str]:
        params: List[str] = []

        possible_classes = param_string.split(";")
        for possible_class in possible_classes:
            # Make sure the parameter list is not empty.
            if possible_class:
                if possible_class.startswith("L"):
                    # Class.
                    params.append("{0};".format(possible_class))
                elif possible_class.startswith("["):
                    # Array + other optional parameters (e.g. [ILjava/lang/Object).
                    for string_position in range(1, len(possible_class)):
                        if possible_class[string_position] == "[":
                            # Multi-dimensional array, proceed with the next char.
                            continue
                        elif possible_class[string_position] == "L":
                            # Class array, no need to proceed with the next char.
                            params.append("{0};".format(possible_class))
                            break
                        else:
                            # Primitive type array, add it to the list and proceed with
                            # the rest of the string
                            params.append(possible_class[: string_position + 1])
                            params.extend(
                                self.split_method_params(
                                    possible_class[string_position + 1 :]
                                )
                            )
                            break
                elif possible_class[0] in self.primitive_types:
                    # Primitive type + other optional parameters
                    # (e.g. ILjava/lang/Object).
                    params.append(possible_class[0])
                    params.extend(self.split_method_params(possible_class[1:]))

        return params

    def count_needed_registers(self, params: List[str]) -> int:
        needed_registers: int = 0

        for param in params:
            # Long and double variables need 2 registers.
            if param == "J" or param == "D":
                needed_registers += 2
            else:
                needed_registers += 1

        return needed_registers

    def add_smali_reflection_code(
        self, class_name: str, method_name: str, param_string: str
    ) -> str:
        params = self.split_method_params(param_string)

        smali_code = "\n\tconst/4 v1, {param_num:#x}\n\n".format(param_num=len(params))
        self.obfuscator_instructions_length += 1

        if len(params) > 0:
            smali_code += "\tnew-array v1, v1, [Ljava/lang/Class;\n\n"
            self.obfuscator_instructions_length += 2

        for param_index, param in enumerate(params):
            smali_code += "\tconst/4 v2, {param_num:#x}\n\n".format(
                param_num=param_index
            )
            self.obfuscator_instructions_length += 1

            class_param = self.sget_dict.get(param, None)
            if class_param:
                smali_code += "\tsget-object v3, {param}\n\n".format(param=class_param)
                self.obfuscator_instructions_length += 2
            else:
                smali_code += "\tconst-class v3, {param}\n\n".format(param=param)
                self.obfuscator_instructions_length += 2

            smali_code += "\taput-object v3, v1, v2\n\n"
            self.obfuscator_instructions_length += 2

        smali_code += (
            "\tconst-class v2, {class_name}\n\n"
            '\tconst-string v3, "{method_name}"\n\n'.format(
                class_name=class_name, method_name=method_name
            )
        )
        self.obfuscator_instructions_length += 4

        smali_code += (
            "\tinvoke-virtual {v2, v3, v1}, Ljava/lang/Class;->getDeclaredMethod("
            "Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;\n\n"
        )
        self.obfuscator_instructions_length += 3

        smali_code += (
            "\tmove-result-object v1\n\n"
            "\tsget-object v2, Lcom/apireflectionmanager/AdvancedApiReflection;->"
            "obfuscatedMethods:Ljava/util/List;\n\n"
        )
        self.obfuscator_instructions_length += 3

        smali_code += (
            "\tinvoke-interface {v2, v1}, Ljava/util/List;->add(Ljava/lang/Object;)Z\n"
        )
        self.obfuscator_instructions_length += 3

        return smali_code

    def create_reflection_method(
        self,
        num_of_methods: int,
        local_count: int,
        is_virtual_method: bool,
        invoke_registers: str,
        invoke_parameters: str,
    ):
        # Split method passed registers (if the method has no registers there is
        # an empty line that has to be removed, that's why strip() is used).
        invoke_registers = [
            register.strip()
            for register in invoke_registers.split(", ")
            if register.strip()
        ]

        params = self.split_method_params(invoke_parameters)

        param_to_register: List[
            List[str]
        ] = []  # list[i][0] = i-th param, list[i][1] = [i-th param register(s)]

        if is_virtual_method:
            # If this is a virtual method, the first register is the object instance
            # and not a parameter.
            register_index = 1
            for param in params:
                # Long and double variables need 2 registers.
                if param == "J" or param == "D":
                    param_to_register.append(
                        [param, invoke_registers[register_index : register_index + 2]]
                    )
                    register_index += 2
                else:
                    param_to_register.append(
                        [param, [invoke_registers[register_index]]]
                    )
                    register_index += 1
        else:
            # This is a static method, so we don't need a reference to the object
            # instance. If this is a virtual method, the first register is the object
            # instance and not a parameter.
            register_index = 0
            for param in params:
                # Long and double variables need 2 registers.
                if param == "J" or param == "D":
                    param_to_register.append(
                        [param, invoke_registers[register_index : register_index + 2]]
                    )
                    register_index += 2
                else:
                    param_to_register.append(
                        [param, [invoke_registers[register_index]]]
                    )
                    register_index += 1

        smali_code = "\tconst/4 #reg1#, {register_num:#x}\n\n".format(
            register_num=len(params)
        )

        if len(params) > 0:
            smali_code += "\tnew-array #reg1#, #reg1#, [Ljava/lang/Object;\n\n"
            for param_index, param_and_register in enumerate(param_to_register):
                # param_and_register[0] = parameter type
                # param_and_register[1] = [register(s) holding the passed parameter(s)]
                cast_primitive_to_class = self.cast_dict.get(
                    param_and_register[0], None
                )

                if cast_primitive_to_class:
                    if len(param_and_register[1]) > 1:
                        # 2 register parameter.
                        smali_code += (
                            "\tinvoke-static {{{register_pair}}}, {cast}\n\n"
                            "\tmove-result-object #reg2#\n\n".format(
                                register_pair=", ".join(param_and_register[1]),
                                cast=cast_primitive_to_class,
                            )
                        )
                    else:
                        smali_code += (
                            "\tinvoke-static {{{register}}}, {cast}\n\n"
                            "\tmove-result-object #reg2#\n\n".format(
                                register=param_and_register[1][0],
                                cast=cast_primitive_to_class,
                            )
                        )

                    smali_code += (
                        "\tconst/4 #reg4#, {param_index:#x}\n\n"
                        "\taput-object #reg2#, #reg1#, #reg4#\n\n".format(
                            param_index=param_index
                        )
                    )

                else:
                    smali_code += (
                        "\tconst/4 #reg3#, {param_index:#x}\n\n"
                        "\taput-object {register}, #reg1#, #reg3#\n\n".format(
                            param_index=param_index, register=param_and_register[1][0]
                        )
                    )

        smali_code += "\tconst/16 #reg3#, {method_num:#x}\n\n".format(
            method_num=num_of_methods
        )

        if is_virtual_method:
            smali_code += (
                "\tinvoke-static {{#reg3#, {obj_instance}, #reg1#}}, "
                "Lcom/apireflectionmanager/AdvancedApiReflection;->obfuscate("
                "ILjava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;\n".format(
                    obj_instance=invoke_registers[0]
                )
            )
        else:
            smali_code += "\tconst/4 #reg4#, 0x0\n\n"
            smali_code += (
                "\tinvoke-static {#reg3#, #reg4#, #reg1#}, "
                "Lcom/apireflectionmanager/AdvancedApiReflection;->"
                "obfuscate(ILjava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;\n"
            )

        for index in range(0, 4):
            smali_code = smali_code.replace(
                "#reg{0}#".format(index + 1), "v{0}".format(local_count + index)
            )

        return smali_code

    def obfuscate(self, obfuscation_info: Obfuscation):
        self.logger.info('Running "{0}" obfuscator'.format(self.__class__.__name__))

        try:
            dangerous_api: Set[str] = set(util.get_dangerous_api())

            obfuscator_smali_code: str = ""

            move_result_pattern = re.compile(
                r"\s+move-result.*?\s(?P<register>[vp0-9]+)"
            )

            for smali_file in util.show_list_progress(
                obfuscation_info.get_smali_files(),
                interactive=obfuscation_info.interactive,
                description="Obfuscating dangerous APIs using reflection",
            ):
                self.logger.debug(
                    'Obfuscating dangerous APIs using reflection in file "{0}"'.format(
                        smali_file
                    )
                )

                # There is no space for further reflection instructions.
                if (
                    self.obfuscator_instructions_length
                    >= self.obfuscator_instructions_limit
                ):
                    break

                with open(smali_file, "r", encoding="utf-8") as current_file:
                    lines = current_file.readlines()

                # Line numbers where a method is declared.
                method_index: List[int] = []

                # For each method in method_index, True if there are enough registers
                # to perform some operations by using reflection, False otherwise.
                method_is_reflectable: List[bool] = []

                # The number of local registers of each method in method_index.
                method_local_count: List[int] = []

                # Find the method declarations in this smali file.
                for line_number, line in enumerate(lines):
                    method_match = util.method_pattern.match(line)
                    if method_match:
                        method_index.append(line_number)

                        param_count = self.count_needed_registers(
                            self.split_method_params(method_match.group("method_param"))
                        )

                        # Save the number of local registers of this method.
                        local_count = 16
                        local_match = util.locals_pattern.match(lines[line_number + 1])
                        if local_match:
                            local_count = int(local_match.group("local_count"))
                            method_local_count.append(local_count)
                        else:
                            # For some reason the locals declaration was not found where
                            # it should be, so assume the local registers are all used.
                            method_local_count.append(local_count)

                        # If there are enough registers available we can perform some
                        # reflection operations.
                        if param_count + local_count <= 11:
                            method_is_reflectable.append(True)
                        else:
                            method_is_reflectable.append(False)

                # Look for method invocations of dangerous APIs inside the methods
                # declared in this smali file and change normal invocations with
                # invocations through reflection.
                for method_number, index in enumerate(method_index):
                    # If there are enough registers for reflection operations, look for
                    # method invocations inside each method's body.
                    if method_is_reflectable[method_number]:
                        current_line_number = index
                        while not lines[current_line_number].startswith(".end method"):
                            # There is no space for further reflection instructions.
                            if (
                                self.obfuscator_instructions_length
                                >= self.obfuscator_instructions_limit
                            ):
                                break

                            current_line_number += 1

                            invoke_match = util.invoke_pattern.match(
                                lines[current_line_number]
                            )
                            if invoke_match:
                                method = (
                                    "{class_name}->{method_name}"
                                    "({method_param}){method_return}".format(
                                        class_name=invoke_match.group("invoke_object"),
                                        method_name=invoke_match.group("invoke_method"),
                                        method_param=invoke_match.group("invoke_param"),
                                        method_return=invoke_match.group(
                                            "invoke_return"
                                        ),
                                    )
                                )

                                # Use reflection only if this method belongs to
                                # dangerous APIs.
                                if method not in dangerous_api:
                                    continue

                                if (
                                    invoke_match.group("invoke_type")
                                    == "invoke-virtual"
                                ):
                                    tmp_is_virtual = True
                                elif (
                                    invoke_match.group("invoke_type") == "invoke-static"
                                ):
                                    tmp_is_virtual = False
                                else:
                                    continue

                                tmp_register = invoke_match.group("invoke_pass")
                                tmp_class_name = invoke_match.group("invoke_object")
                                tmp_method = invoke_match.group("invoke_method")
                                tmp_param = invoke_match.group("invoke_param")
                                tmp_return_type = invoke_match.group("invoke_return")

                                # Check if the method invocation result is used in the
                                # following lines.
                                for move_result_index in range(
                                    current_line_number + 1,
                                    min(current_line_number + 10, len(lines) - 1),
                                ):
                                    if "invoke-" in lines[move_result_index]:
                                        # New method invocation, the previous method
                                        # result is not used.
                                        break

                                    move_result_match = move_result_pattern.match(
                                        lines[move_result_index]
                                    )
                                    if move_result_match:
                                        tmp_result_register = move_result_match.group(
                                            "register"
                                        )

                                        # Fix the move-result instruction after the
                                        # method invocation.
                                        new_move_result = ""
                                        if tmp_return_type in self.primitive_types:
                                            new_move_result += (
                                                "\tmove-result-object "
                                                "{result_register}\n\n"
                                                "\tcheck-cast {result_register}, "
                                                "{result_class}\n\n".format(
                                                    result_register=tmp_result_register,
                                                    result_class=self.type_dict[
                                                        tmp_return_type
                                                    ],
                                                )
                                            )

                                            new_move_result += (
                                                "\tinvoke-virtual "
                                                "{{{result_register}}}, {cast}\n\n".format(
                                                    result_register=tmp_result_register,
                                                    cast=self.reverse_cast_dict[
                                                        tmp_return_type
                                                    ],
                                                )
                                            )

                                            if (
                                                tmp_return_type == "J"
                                                or tmp_return_type == "D"
                                            ):
                                                new_move_result += (
                                                    "\tmove-result-wide "
                                                    "{result_register}\n".format(
                                                        result_register=tmp_result_register
                                                    )
                                                )
                                            else:
                                                new_move_result += (
                                                    "\tmove-result "
                                                    "{result_register}\n".format(
                                                        result_register=tmp_result_register
                                                    )
                                                )

                                        else:
                                            new_move_result += (
                                                "\tmove-result-object "
                                                "{result_register}\n\n"
                                                "\tcheck-cast {result_register}, "
                                                "{return_type}\n".format(
                                                    result_register=tmp_result_register,
                                                    return_type=tmp_return_type,
                                                )
                                            )

                                        lines[move_result_index] = new_move_result

                                # Add the original method to the list of methods using
                                # reflection.
                                obfuscator_smali_code += self.add_smali_reflection_code(
                                    tmp_class_name, tmp_method, tmp_param
                                )

                                # Change the original code with code using reflection.
                                lines[
                                    current_line_number
                                ] = self.create_reflection_method(
                                    self.methods_with_reflection,
                                    method_local_count[method_number],
                                    tmp_is_virtual,
                                    tmp_register,
                                    tmp_param,
                                )

                                self.methods_with_reflection += 1

                                # Add the registers needed for performing reflection.
                                lines[index + 1] = "\t.locals {0}\n".format(
                                    method_local_count[method_number] + 4
                                )

                with open(smali_file, "w", encoding="utf-8") as current_file:
                    current_file.writelines(lines)

            # Add to the app the code needed for the reflection obfuscator. The code
            # can be put in any smali directory, since it will be moved to the correct
            # directory when rebuilding the application.
            destination_dir = os.path.dirname(obfuscation_info.get_smali_files()[0])
            destination_file = os.path.join(
                destination_dir, "AdvancedApiReflection.smali"
            )
            with open(destination_file, "w", encoding="utf-8") as api_reflection_smali:
                reflection_code = util.get_advanced_api_reflection_smali_code().replace(
                    "#!code_to_replace!#", obfuscator_smali_code
                )
                api_reflection_smali.write(reflection_code)

        except Exception as e:
            self.logger.error(
                'Error during execution of "{0}" obfuscator: {1}'.format(
                    self.__class__.__name__, e
                )
            )
            raise

        finally:
            obfuscation_info.used_obfuscators.append(self.__class__.__name__)

```

`src/obfuscapk/obfuscators/arithmetic_branch.obfuscator`:

```obfuscator
[Core]
Name = ArithmeticBranch
Module = arithmetic_branch

[Documentation]
Description = Insert junk code (arithmetic computations)
Version = 1.0

```

`src/obfuscapk/obfuscators/arithmetic_branch/__init__.py`:

```py
#!/usr/bin/env python3

from .arithmetic_branch import ArithmeticBranch

```

`src/obfuscapk/obfuscators/arithmetic_branch/arithmetic_branch.py`:

```py
#!/usr/bin/env python3

import logging

from obfuscapk import obfuscator_category
from obfuscapk import util
from obfuscapk.obfuscation import Obfuscation


class ArithmeticBranch(obfuscator_category.ICodeObfuscator):
    def __init__(self):
        self.logger = logging.getLogger(
            "{0}.{1}".format(__name__, self.__class__.__name__)
        )
        super().__init__()

    def obfuscate(self, obfuscation_info: Obfuscation):
        self.logger.info('Running "{0}" obfuscator'.format(self.__class__.__name__))

        try:
            for smali_file in util.show_list_progress(
                obfuscation_info.get_smali_files(),
                interactive=obfuscation_info.interactive,
                description="Inserting arithmetic computations in smali files",
            ):
                self.logger.debug(
                    'Inserting arithmetic computations in file "{0}"'.format(smali_file)
                )
                with util.inplace_edit_file(smali_file) as (in_file, out_file):
                    editing_method = False
                    start_label = None
                    end_label = None
                    for line in in_file:
                        if (
                            line.startswith(".method ")
                            and " abstract " not in line
                            and " native " not in line
                            and not editing_method
                        ):
                            # Entering method.
                            out_file.write(line)
                            editing_method = True

                        elif line.startswith(".end method") and editing_method:
                            # Exiting method.
                            if start_label and end_label:
                                out_file.write("\t:{0}\n".format(end_label))
                                out_file.write("\tgoto/32 :{0}\n".format(start_label))
                                start_label = None
                                end_label = None
                            out_file.write(line)
                            editing_method = False

                        elif editing_method:
                            # Inside method.
                            out_file.write(line)
                            match = util.locals_pattern.match(line)
                            if match and int(match.group("local_count")) >= 2:
                                # If there are at least 2 registers available, add a
                                # fake branch at the beginning of the method: one branch
                                # will continue from here, the other branch will go to
                                # the end of the method and then will return here
                                # through a "goto" instruction.
                                v0, v1 = (
                                    util.get_random_int(1, 32),
                                    util.get_random_int(1, 32),
                                )
                                start_label = util.get_random_string(16)
                                end_label = util.get_random_string(16)
                                tmp_label = util.get_random_string(16)
                                out_file.write("\n\tconst v0, {0}\n".format(v0))
                                out_file.write("\tconst v1, {0}\n".format(v1))
                                out_file.write("\tadd-int v0, v0, v1\n")
                                out_file.write("\trem-int v0, v0, v1\n")
                                out_file.write("\tif-gtz v0, :{0}\n".format(tmp_label))
                                out_file.write("\tgoto/32 :{0}\n".format(end_label))
                                out_file.write("\t:{0}\n".format(tmp_label))
                                out_file.write("\t:{0}\n".format(start_label))

                        else:
                            out_file.write(line)

        except Exception as e:
            self.logger.error(
                'Error during execution of "{0}" obfuscator: {1}'.format(
                    self.__class__.__name__, e
                )
            )
            raise

        finally:
            obfuscation_info.used_obfuscators.append(self.__class__.__name__)

```

`src/obfuscapk/obfuscators/arithmetic_branch/example/after.smali`:

```smali
.class public Lcom/obfuscapk/demo/OrderDemo;
.super Ljava/lang/Object;
.source "OrderDemo.java"


# direct methods
.method public constructor <init>()V
    .locals 0

    .prologue
    .line 6
    invoke-direct {p0}, Ljava/lang/Object;-><init>()V

    return-void
.end method

.method public static getGotoMessage()Ljava/lang/String;
    .locals 5

    const v0, 7
    const v1, 4
    add-int v0, v0, v1
    rem-int v0, v0, v1
    if-gtz v0, :EbAukdQwmmPELTjd
    goto/32 :bPdknjDcQesDQUPu
    :EbAukdQwmmPELTjd
    :KbkerIsqVXNivOzU

    .prologue
    .line 9
    new-instance v3, Ljava/util/ArrayList;

    invoke-direct {v3}, Ljava/util/ArrayList;-><init>()V

    .line 11
    .local v3, "messages":Ljava/util/ArrayList;, "Ljava/util/ArrayList<Ljava/lang/String;>;"
    const-string/jumbo v0, "message1"

    .line 12
    .local v0, "message1":Ljava/lang/String;
    invoke-virtual {v3, v0}, Ljava/util/ArrayList;->add(Ljava/lang/Object;)Z

    .line 14
    const-string/jumbo v1, "message2"

    .line 15
    .local v1, "message2":Ljava/lang/String;
    invoke-virtual {v3, v1}, Ljava/util/ArrayList;->add(Ljava/lang/Object;)Z

    .line 17
    const-string/jumbo v2, "message3"

    .line 18
    .local v2, "message3":Ljava/lang/String;
    invoke-virtual {v3, v2}, Ljava/util/ArrayList;->add(Ljava/lang/Object;)Z

    .line 20
    invoke-virtual {v3}, Ljava/util/ArrayList;->toArray()[Ljava/lang/Object;

    move-result-object v4

    invoke-static {v4}, Ljava/util/Arrays;->toString([Ljava/lang/Object;)Ljava/lang/String;

    move-result-object v4

    return-object v4
    :bPdknjDcQesDQUPu
    goto/32 :KbkerIsqVXNivOzU
.end method

```

`src/obfuscapk/obfuscators/arithmetic_branch/example/before.smali`:

```smali
.class public Lcom/obfuscapk/demo/OrderDemo;
.super Ljava/lang/Object;
.source "OrderDemo.java"


# direct methods
.method public constructor <init>()V
    .locals 0

    .prologue
    .line 6
    invoke-direct {p0}, Ljava/lang/Object;-><init>()V

    return-void
.end method

.method public static getGotoMessage()Ljava/lang/String;
    .locals 5

    .prologue
    .line 9
    new-instance v3, Ljava/util/ArrayList;

    invoke-direct {v3}, Ljava/util/ArrayList;-><init>()V

    .line 11
    .local v3, "messages":Ljava/util/ArrayList;, "Ljava/util/ArrayList<Ljava/lang/String;>;"
    const-string/jumbo v0, "message1"

    .line 12
    .local v0, "message1":Ljava/lang/String;
    invoke-virtual {v3, v0}, Ljava/util/ArrayList;->add(Ljava/lang/Object;)Z

    .line 14
    const-string/jumbo v1, "message2"

    .line 15
    .local v1, "message2":Ljava/lang/String;
    invoke-virtual {v3, v1}, Ljava/util/ArrayList;->add(Ljava/lang/Object;)Z

    .line 17
    const-string/jumbo v2, "message3"

    .line 18
    .local v2, "message3":Ljava/lang/String;
    invoke-virtual {v3, v2}, Ljava/util/ArrayList;->add(Ljava/lang/Object;)Z

    .line 20
    invoke-virtual {v3}, Ljava/util/ArrayList;->toArray()[Ljava/lang/Object;

    move-result-object v4

    invoke-static {v4}, Ljava/util/Arrays;->toString([Ljava/lang/Object;)Ljava/lang/String;

    move-result-object v4

    return-object v4
.end method

```

`src/obfuscapk/obfuscators/arithmetic_branch/example/original.java`:

```java
package com.obfuscapk.demo;

import java.util.ArrayList;
import java.util.Arrays;

public class OrderDemo {
    public static String getGotoMessage() {
        // Just some ordered instructions.
        ArrayList<String> messages = new ArrayList<>();

        String message1 = "message1";
        messages.add(message1);

        String message2 = "message2";
        messages.add(message2);

        String message3 = "message3";
        messages.add(message3);

        return Arrays.toString(messages.toArray());
    }
}

```

`src/obfuscapk/obfuscators/asset_encryption.obfuscator`:

```obfuscator
[Core]
Name = AssetEncryption
Module = asset_encryption

[Documentation]
Description = Encrypt asset files
Version = 1.0

```

`src/obfuscapk/obfuscators/asset_encryption/__init__.py`:

```py
#!/usr/bin/env python3

from .asset_encryption import AssetEncryption

```

`src/obfuscapk/obfuscators/asset_encryption/asset_encryption.py`:

```py
#!/usr/bin/env python3

import logging
import os
import re
from typing import List, Set

from Crypto.Cipher import AES
from Crypto.Util.Padding import pad

from obfuscapk import obfuscator_category
from obfuscapk import util
from obfuscapk.obfuscation import Obfuscation


class AssetEncryption(obfuscator_category.IEncryptionObfuscator):
    def __init__(self):
        self.logger = logging.getLogger(
            "{0}.{1}".format(__name__, self.__class__.__name__)
        )
        super().__init__()
        self.encryption_secret = "This-key-need-to-be-32-character"

    def obfuscate(self, obfuscation_info: Obfuscation):
        self.logger.info('Running "{0}" obfuscator'.format(self.__class__.__name__))

        self.encryption_secret = obfuscation_info.encryption_secret
        try:
            # This instruction takes 2 registers, the latter contains the name of the
            # asset file to load.
            open_asset_invoke_pattern = re.compile(
                r"\s+invoke-virtual\s"
                r"{[vp0-9]+,\s(?P<param_register>[vp0-9]+)},\s"
                r"Landroid/content/res/AssetManager;->"
                r"open\(Ljava/lang/String;\)Ljava/io/InputStream;"
            )

            assets_dir = obfuscation_info.get_assets_directory()
            already_encrypted_files: Set[str] = set()

            # Continue only if there are assets file to encrypt.
            if os.path.isdir(assets_dir):
                for smali_file in util.show_list_progress(
                    obfuscation_info.get_smali_files(),
                    interactive=obfuscation_info.interactive,
                    description="Encrypting asset files",
                ):
                    self.logger.debug(
                        'Encrypting asset files used in smali file "{0}"'.format(
                            smali_file
                        )
                    )

                    with open(smali_file, "r", encoding="utf-8") as current_file:
                        lines = current_file.readlines()

                    # Line numbers where an asset file is opened.
                    asset_index: List[int] = []

                    # Registers containing the strings with the names of the opened
                    # asset files.
                    asset_register: List[str] = []

                    # Names of the opened asset files.
                    asset_names: List[str] = []

                    # Each time an asset name is added to asset_names, the line number
                    # of the asset open instruction is added to this list, so the
                    # element in position n in asset_names is opened at the line in
                    # position n in asset_index_for_asset_names. So each time an asset
                    # file is encrypted, the corresponding line is changed to open the
                    # encrypted file. A new variable is needed because asset_index could
                    # have different indices than asset_names because there might be
                    # assets loaded from other variables and not constant strings.
                    asset_index_for_asset_names: List[int] = []

                    for line_number, line in enumerate(lines):
                        invoke_match = open_asset_invoke_pattern.match(line)
                        if invoke_match:
                            # Asset file open instruction.
                            asset_index.append(line_number)
                            asset_register.append(invoke_match.group("param_register"))

                    # Iterate the lines backwards (until the method declaration is
                    # reached) and for each asset file open instruction find the
                    # constant string containing the name of the opened file (if any).
                    for asset_number, index in enumerate(asset_index):
                        for line_number in range(index - 1, 0, -1):
                            if lines[line_number].startswith(".method "):
                                # Method declaration reached, no constant string found
                                # for this asset file so proceed with the next (if any).
                                break

                            # NOTE: if an asset is opened using a constant string, it
                            # will be encrypted. If other code opens the same assets but
                            # using a variable instead of a constant string, it won't
                            # work anymore and this case is not handled by this
                            # obfuscator.

                            string_match = util.const_string_pattern.match(
                                lines[line_number]
                            )
                            if (
                                string_match
                                and string_match.group("register")
                                == asset_register[asset_number]
                            ):
                                # Asset file name string declaration.
                                asset_names.append(string_match.group("string"))
                                asset_index_for_asset_names.append(
                                    asset_index[asset_number]
                                )

                                # Proceed with the next asset file (if any).
                                break

                    # Encrypt the the loaded asset files and replace the old code with
                    # new code to decrypt the encrypted asset files.
                    for index, asset_name in enumerate(asset_names):
                        asset_file = os.path.join(assets_dir, asset_name)
                        if os.path.isfile(asset_file):
                            # Encrypt the asset file (if not already encrypted).
                            if asset_file not in already_encrypted_files:
                                with open(asset_file, "rb") as original_asset_file:
                                    encrypted_content = AES.new(
                                        key=self.encryption_secret.encode(),
                                        mode=AES.MODE_ECB,
                                    ).encrypt(
                                        pad(original_asset_file.read(), AES.block_size)
                                    )

                                with open(asset_file, "wb") as encrypted_asset_file:
                                    encrypted_asset_file.write(encrypted_content)

                                already_encrypted_files.add(asset_file)

                            # Replace the old code with new code to decrypt the
                            # encrypted asset file.
                            lines[asset_index_for_asset_names[index]] = (
                                lines[asset_index_for_asset_names[index]]
                                .replace("invoke-virtual", "invoke-static")
                                .replace(
                                    "Landroid/content/res/AssetManager;->"
                                    "open(Ljava/lang/String;)Ljava/io/InputStream;",
                                    "Lcom/decryptassetmanager/DecryptAsset;->"
                                    "decryptAsset(Landroid/content/res/AssetManager;"
                                    "Ljava/lang/String;)Ljava/io/InputStream;",
                                )
                            )

                    with open(smali_file, "w", encoding="utf-8") as current_file:
                        current_file.writelines(lines)

                if (
                    not obfuscation_info.decrypt_asset_smali_file_added_flag
                    and already_encrypted_files
                ):
                    # Add to the app the code for decrypting the encrypted assets.
                    # The code for decrypting can be put in any smali directory, since
                    # it will be moved to the correct directory when rebuilding the
                    # application.
                    destination_dir = os.path.dirname(
                        obfuscation_info.get_smali_files()[0]
                    )
                    destination_file = os.path.join(
                        destination_dir, "DecryptAsset.smali"
                    )
                    with open(
                        destination_file, "w", encoding="utf-8"
                    ) as decrypt_asset_smali:
                        decrypt_asset_smali.write(
                            util.get_decrypt_asset_smali_code(self.encryption_secret)
                        )
                        obfuscation_info.decrypt_asset_smali_file_added_flag = True

            else:
                self.logger.debug("No assets found")

        except Exception as e:
            self.logger.error(
                'Error during execution of "{0}" obfuscator: {1}'.format(
                    self.__class__.__name__, e
                )
            )
            raise

        finally:
            obfuscation_info.used_obfuscators.append(self.__class__.__name__)

```

`src/obfuscapk/obfuscators/asset_encryption/example/after.smali`:

```smali
.class public Lcom/obfuscapk/demo/AssetDemo;
.super Ljava/lang/Object;
.source "AssetDemo.java"


# direct methods
.method public constructor <init>()V
    .locals 0

    .prologue
    .line 9
    invoke-direct {p0}, Ljava/lang/Object;-><init>()V

    return-void
.end method

.method private static readBytes(Ljava/io/InputStream;)[B
    .locals 4
    .param p0, "inputStream"    # Ljava/io/InputStream;
    .annotation system Ldalvik/annotation/Throws;
        value = {
            Ljava/io/IOException;
        }
    .end annotation

    .prologue
    .line 12
    const/16 v3, 0x400

    new-array v0, v3, [B

    .line 13
    .local v0, "array":[B
    new-instance v1, Ljava/io/ByteArrayOutputStream;

    invoke-direct {v1}, Ljava/io/ByteArrayOutputStream;-><init>()V

    .line 15
    .local v1, "byteArrayOutputStream":Ljava/io/ByteArrayOutputStream;
    :goto_0
    invoke-virtual {p0, v0}, Ljava/io/InputStream;->read([B)I

    move-result v2

    .line 16
    .local v2, "read":I
    const/4 v3, -0x1

    if-ne v2, v3, :cond_0

    .line 21
    invoke-virtual {v1}, Ljava/io/ByteArrayOutputStream;->toByteArray()[B

    move-result-object v3

    return-object v3

    .line 19
    :cond_0
    const/4 v3, 0x0

    invoke-virtual {v1, v0, v3, v2}, Ljava/io/ByteArrayOutputStream;->write([BII)V

    goto :goto_0
.end method


# virtual methods
.method public getMessageFromAsset(Landroid/content/res/AssetManager;)Ljava/lang/String;
    .locals 3
    .param p1, "assetManager"    # Landroid/content/res/AssetManager;
    .annotation system Ldalvik/annotation/Throws;
        value = {
            Ljava/io/IOException;
        }
    .end annotation

    .prologue
    .line 26
    const-string/jumbo v1, "message.txt"

    invoke-static {p1, v1}, Lcom/decryptassetmanager/DecryptAsset;->decryptAsset(Landroid/content/res/AssetManager;Ljava/lang/String;)Ljava/io/InputStream;

    move-result-object v0

    .line 27
    .local v0, "assetInputStream":Ljava/io/InputStream;
    new-instance v1, Ljava/lang/String;

    invoke-static {v0}, Lcom/obfuscapk/demo/AssetDemo;->readBytes(Ljava/io/InputStream;)[B

    move-result-object v2

    invoke-direct {v1, v2}, Ljava/lang/String;-><init>([B)V

    return-object v1
.end method

```

`src/obfuscapk/obfuscators/asset_encryption/example/before.smali`:

```smali
.class public Lcom/obfuscapk/demo/AssetDemo;
.super Ljava/lang/Object;
.source "AssetDemo.java"


# direct methods
.method public constructor <init>()V
    .locals 0

    .prologue
    .line 9
    invoke-direct {p0}, Ljava/lang/Object;-><init>()V

    return-void
.end method

.method private static readBytes(Ljava/io/InputStream;)[B
    .locals 4
    .param p0, "inputStream"    # Ljava/io/InputStream;
    .annotation system Ldalvik/annotation/Throws;
        value = {
            Ljava/io/IOException;
        }
    .end annotation

    .prologue
    .line 12
    const/16 v3, 0x400

    new-array v0, v3, [B

    .line 13
    .local v0, "array":[B
    new-instance v1, Ljava/io/ByteArrayOutputStream;

    invoke-direct {v1}, Ljava/io/ByteArrayOutputStream;-><init>()V

    .line 15
    .local v1, "byteArrayOutputStream":Ljava/io/ByteArrayOutputStream;
    :goto_0
    invoke-virtual {p0, v0}, Ljava/io/InputStream;->read([B)I

    move-result v2

    .line 16
    .local v2, "read":I
    const/4 v3, -0x1

    if-ne v2, v3, :cond_0

    .line 21
    invoke-virtual {v1}, Ljava/io/ByteArrayOutputStream;->toByteArray()[B

    move-result-object v3

    return-object v3

    .line 19
    :cond_0
    const/4 v3, 0x0

    invoke-virtual {v1, v0, v3, v2}, Ljava/io/ByteArrayOutputStream;->write([BII)V

    goto :goto_0
.end method


# virtual methods
.method public getMessageFromAsset(Landroid/content/res/AssetManager;)Ljava/lang/String;
    .locals 3
    .param p1, "assetManager"    # Landroid/content/res/AssetManager;
    .annotation system Ldalvik/annotation/Throws;
        value = {
            Ljava/io/IOException;
        }
    .end annotation

    .prologue
    .line 26
    const-string/jumbo v1, "message.txt"

    invoke-virtual {p1, v1}, Landroid/content/res/AssetManager;->open(Ljava/lang/String;)Ljava/io/InputStream;

    move-result-object v0

    .line 27
    .local v0, "assetInputStream":Ljava/io/InputStream;
    new-instance v1, Ljava/lang/String;

    invoke-static {v0}, Lcom/obfuscapk/demo/AssetDemo;->readBytes(Ljava/io/InputStream;)[B

    move-result-object v2

    invoke-direct {v1, v2}, Ljava/lang/String;-><init>([B)V

    return-object v1
.end method

```

`src/obfuscapk/obfuscators/asset_encryption/example/original.java`:

```java
package com.obfuscapk.demo;

import android.content.res.AssetManager;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;

public class AssetDemo {
    // Helper method.
    private static byte[] readBytes(InputStream inputStream) throws IOException {
        byte[] array = new byte[1024];
        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
        while (true) {
            int read = inputStream.read(array);
            if (read == -1) {
                break;
            }
            byteArrayOutputStream.write(array, 0, read);
        }
        return byteArrayOutputStream.toByteArray();
    }

    public String getMessageFromAsset(AssetManager assetManager) throws IOException {
        // This is the instruction that will be replaced by loading the encrypted asset.
        InputStream assetInputStream = assetManager.open("message.txt");
        return new String(readBytes(assetInputStream));
    }
}

```

`src/obfuscapk/obfuscators/call_indirection.obfuscator`:

```obfuscator
[Core]
Name = CallIndirection
Module = call_indirection

[Documentation]
Description = Modify the call graph of the application
Version = 1.0

```

`src/obfuscapk/obfuscators/call_indirection/__init__.py`:

```py
#!/usr/bin/env python3

from .call_indirection import CallIndirection

```

`src/obfuscapk/obfuscators/call_indirection/call_indirection.py`:

```py
#!/usr/bin/env python3

import logging
import re
from io import StringIO
from typing import List

from obfuscapk import obfuscator_category
from obfuscapk import util
from obfuscapk.obfuscation import Obfuscation


class CallIndirection(obfuscator_category.ICodeObfuscator):
    def __init__(self):
        self.logger = logging.getLogger(
            "{0}.{1}".format(__name__, self.__class__.__name__)
        )
        super().__init__()

        self.is_adding_methods = True

        self.registers_pattern = re.compile(r"[vp]\d{1,3}")

    def is_range(self, invoke_type: str) -> bool:
        return "range" in invoke_type

    def is_static(self, invoke_type: str) -> bool:
        return "static" in invoke_type

    def get_registers(self, invoke_pass: str) -> List[str]:
        return self.registers_pattern.findall(invoke_pass)

    def get_register_range_count(self, register_list: List[str]) -> int:
        return int(register_list[1][1:]) - int(register_list[0][1:]) + 1

    def is_void(self, invoke_return: str) -> bool:
        return invoke_return == "V"

    def is_wide(self, invoke_return: str) -> bool:
        return invoke_return == "J" or invoke_return == "D"

    def is_object(self, invoke_return: str) -> bool:
        # https://github.com/JesusFreke/smali/wiki/TypesMethodsAndFields
        return invoke_return.startswith(("L", "["))

    def is_init(self, invoke_method: str) -> bool:
        return "<init>" in invoke_method or "<clinit>" in invoke_method

    def change_method_call(
        self,
        invoke_type: str,
        invoke_pass: str,
        invoke_object: str,
        invoke_method: str,
        invoke_param: str,
        invoke_return: str,
        class_name: str,
        new_method: StringIO,
        out_file,
    ):
        new_method_name = util.get_random_string(16)

        is_range_invocation = self.is_range(invoke_type)
        is_static_invocation = self.is_static(invoke_type)

        register_list = self.get_registers(invoke_pass)
        if is_range_invocation:
            register_count = self.get_register_range_count(register_list)
        else:
            register_count = len(register_list)

        is_void_value = self.is_void(invoke_return)
        is_wide_value = self.is_wide(invoke_return)
        is_object_value = self.is_object(invoke_return)

        local_register_count = 1
        if is_void_value:
            local_register_count = 0
        if is_wide_value:
            local_register_count = 2

        move_result_str = "move-result v0"
        if is_void_value:
            move_result_str = ""
        if is_wide_value:
            move_result_str = "move-result-wide v0"
        if is_object_value:
            move_result_str = "move-result-object v0"

        return_str = "return v0"
        if is_void_value:
            return_str = "return-void"
        if is_wide_value:
            return_str = "return-wide v0"
        if is_object_value:
            return_str = "return-object v0"

        add_param = "" if is_static_invocation else invoke_object
        new_invoke = "invoke-static/range" if is_range_invocation else "invoke-static"

        # Insert the new method invocation in the smali file.
        out_file.write(
            "\t{invoke_type} {{{invoke_pass}}}, {class_name}->"
            "{method_name}({add_param}{invoke_param}){invoke_return}\n".format(
                invoke_type=new_invoke,
                invoke_pass=invoke_pass,
                class_name=class_name,
                method_name=new_method_name,
                add_param=add_param,
                invoke_param=invoke_param,
                invoke_return=invoke_return,
            )
        )

        # Prepare the new method(s) declaration (will be inserted later into code).
        new_method.write(
            ".method public static "
            "{method_name}({add_param}{invoke_param}){invoke_return}\n".format(
                method_name=new_method_name,
                add_param=add_param,
                invoke_param=invoke_param,
                invoke_return=invoke_return,
            )
        )
        new_method.write(
            "    .locals {local_count}\n\n".format(local_count=local_register_count)
        )
        new_method.write("    {invoke_type} {{".format(invoke_type=invoke_type))
        if is_range_invocation:
            new_method.write("p0 .. p{count}".format(count=(register_count - 1)))
        else:
            for index in range(0, register_count):
                new_method.write("p{count}".format(count=index))
                if index + 1 < register_count:
                    new_method.write(", ")
        new_method.write(
            "}}, {invoke_object}->"
            "{invoke_method}({invoke_param}){invoke_return}\n\n".format(
                invoke_object=invoke_object,
                invoke_method=invoke_method,
                invoke_param=invoke_param,
                invoke_return=invoke_return,
            )
        )
        if move_result_str:
            new_method.write(
                "    {move_result}\n\n".format(move_result=move_result_str)
            )
        new_method.write("    {return_result}\n".format(return_result=return_str))
        new_method.write(".end method\n\n")

    def update_method(self, smali_file: str, new_method: StringIO):
        with util.inplace_edit_file(smali_file) as (in_file, out_file):
            class_name = None
            for line in in_file:
                if not class_name:
                    class_match = util.class_pattern.match(line)
                    if class_match:
                        class_name = class_match.group("class_name")
                        out_file.write(line)
                        continue

                invoke_match = util.invoke_pattern.match(line)
                if invoke_match:
                    if not self.is_init(invoke_match.group("invoke_method")):
                        # The following function will write into the file the new
                        # method invocation.
                        self.change_method_call(
                            invoke_match.group("invoke_type"),
                            invoke_match.group("invoke_pass"),
                            invoke_match.group("invoke_object"),
                            invoke_match.group("invoke_method"),
                            invoke_match.group("invoke_param"),
                            invoke_match.group("invoke_return"),
                            class_name,
                            new_method,
                            out_file,
                        )
                    else:
                        out_file.write(line)
                else:
                    out_file.write(line)

    def add_method(self, smali_file: str, new_method: StringIO):
        with util.inplace_edit_file(smali_file) as (in_file, out_file):
            for line in in_file:
                if line.startswith("# direct methods"):
                    # Add the new indirection method(s) in the direct methods section.
                    out_file.write(line)
                    out_file.write(new_method.getvalue())
                else:
                    out_file.write(line)

    def get_declared_method_number_in_text(self, text: str) -> int:
        return sum(1 for line in text.splitlines() if line.startswith(".method "))

    def add_call_indirections(
        self, smali_files: List[str], max_methods_to_add: int, interactive: bool = False
    ):
        added_methods = 0
        for smali_file in util.show_list_progress(
            smali_files,
            interactive=interactive,
            description="Inserting call indirections in smali files",
        ):
            self.logger.debug(
                'Inserting call indirections in file "{0}"'.format(smali_file)
            )
            if added_methods < max_methods_to_add:
                with StringIO() as new_method:
                    self.update_method(smali_file, new_method)
                    self.add_method(smali_file, new_method)
                    added_methods += self.get_declared_method_number_in_text(
                        new_method.getvalue()
                    )
            else:
                break

        self.logger.debug("{0} new methods were added".format(added_methods))

    def obfuscate(self, obfuscation_info: Obfuscation):
        self.logger.info('Running "{0}" obfuscator'.format(self.__class__.__name__))

        try:
            # There is a method limit for dex files.
            max_methods_to_add = obfuscation_info.get_remaining_methods_per_obfuscator()

            if obfuscation_info.is_multidex():
                for index, dex_smali_files in enumerate(
                    util.show_list_progress(
                        obfuscation_info.get_multidex_smali_files(),
                        interactive=obfuscation_info.interactive,
                        unit="dex",
                        description="Processing multidex",
                    )
                ):
                    max_methods_to_add = (
                        obfuscation_info.get_remaining_methods_per_obfuscator()[index]
                    )
                    self.add_call_indirections(
                        dex_smali_files,
                        max_methods_to_add,
                        obfuscation_info.interactive,
                    )
            else:
                self.add_call_indirections(
                    obfuscation_info.get_smali_files(),
                    max_methods_to_add,
                    obfuscation_info.interactive,
                )

        except Exception as e:
            self.logger.error(
                'Error during execution of "{0}" obfuscator: {1}'.format(
                    self.__class__.__name__, e
                )
            )
            raise

        finally:
            obfuscation_info.used_obfuscators.append(self.__class__.__name__)

```

`src/obfuscapk/obfuscators/call_indirection/example/after.smali`:

```smali
.class public Lcom/obfuscapk/demo/OrderDemo;
.super Ljava/lang/Object;
.source "OrderDemo.java"


# direct methods
.method public static CaxLmSVQaEISXHgM(Ljava/util/ArrayList;Ljava/lang/Object;)Z
    .locals 1

    invoke-virtual {p0, p1}, Ljava/util/ArrayList;->add(Ljava/lang/Object;)Z

    move-result v0

    return v0
.end method

.method public static RFtgxYkkHgZTZAyR(Ljava/util/ArrayList;Ljava/lang/Object;)Z
    .locals 1

    invoke-virtual {p0, p1}, Ljava/util/ArrayList;->add(Ljava/lang/Object;)Z

    move-result v0

    return v0
.end method

.method public static uwzJipmHrJxSPOuT(Ljava/util/ArrayList;Ljava/lang/Object;)Z
    .locals 1

    invoke-virtual {p0, p1}, Ljava/util/ArrayList;->add(Ljava/lang/Object;)Z

    move-result v0

    return v0
.end method

.method public static SOrHOqcDYYLsEuaK(Ljava/util/ArrayList;)[Ljava/lang/Object;
    .locals 1

    invoke-virtual {p0}, Ljava/util/ArrayList;->toArray()[Ljava/lang/Object;

    move-result-object v0

    return-object v0
.end method

.method public static QnaFXsjaPRCCYNho([Ljava/lang/Object;)Ljava/lang/String;
    .locals 1

    invoke-static {p0}, Ljava/util/Arrays;->toString([Ljava/lang/Object;)Ljava/lang/String;

    move-result-object v0

    return-object v0
.end method

.method public constructor <init>()V
    .locals 0

    .prologue
    .line 6
    invoke-direct {p0}, Ljava/lang/Object;-><init>()V

    return-void
.end method

.method public static getGotoMessage()Ljava/lang/String;
    .locals 5

    .prologue
    .line 9
    new-instance v3, Ljava/util/ArrayList;

    invoke-direct {v3}, Ljava/util/ArrayList;-><init>()V

    .line 11
    .local v3, "messages":Ljava/util/ArrayList;, "Ljava/util/ArrayList<Ljava/lang/String;>;"
    const-string/jumbo v0, "message1"

    .line 12
    .local v0, "message1":Ljava/lang/String;
    invoke-static {v3, v0}, Lcom/obfuscapk/demo/OrderDemo;->CaxLmSVQaEISXHgM(Ljava/util/ArrayList;Ljava/lang/Object;)Z

    .line 14
    const-string/jumbo v1, "message2"

    .line 15
    .local v1, "message2":Ljava/lang/String;
    invoke-static {v3, v1}, Lcom/obfuscapk/demo/OrderDemo;->RFtgxYkkHgZTZAyR(Ljava/util/ArrayList;Ljava/lang/Object;)Z

    .line 17
    const-string/jumbo v2, "message3"

    .line 18
    .local v2, "message3":Ljava/lang/String;
    invoke-static {v3, v2}, Lcom/obfuscapk/demo/OrderDemo;->uwzJipmHrJxSPOuT(Ljava/util/ArrayList;Ljava/lang/Object;)Z

    .line 20
    invoke-static {v3}, Lcom/obfuscapk/demo/OrderDemo;->SOrHOqcDYYLsEuaK(Ljava/util/ArrayList;)[Ljava/lang/Object;

    move-result-object v4

    invoke-static {v4}, Lcom/obfuscapk/demo/OrderDemo;->QnaFXsjaPRCCYNho([Ljava/lang/Object;)Ljava/lang/String;

    move-result-object v4

    return-object v4
.end method

```

`src/obfuscapk/obfuscators/call_indirection/example/before.smali`:

```smali
.class public Lcom/obfuscapk/demo/OrderDemo;
.super Ljava/lang/Object;
.source "OrderDemo.java"


# direct methods
.method public constructor <init>()V
    .locals 0

    .prologue
    .line 6
    invoke-direct {p0}, Ljava/lang/Object;-><init>()V

    return-void
.end method

.method public static getGotoMessage()Ljava/lang/String;
    .locals 5

    .prologue
    .line 9
    new-instance v3, Ljava/util/ArrayList;

    invoke-direct {v3}, Ljava/util/ArrayList;-><init>()V

    .line 11
    .local v3, "messages":Ljava/util/ArrayList;, "Ljava/util/ArrayList<Ljava/lang/String;>;"
    const-string/jumbo v0, "message1"

    .line 12
    .local v0, "message1":Ljava/lang/String;
    invoke-virtual {v3, v0}, Ljava/util/ArrayList;->add(Ljava/lang/Object;)Z

    .line 14
    const-string/jumbo v1, "message2"

    .line 15
    .local v1, "message2":Ljava/lang/String;
    invoke-virtual {v3, v1}, Ljava/util/ArrayList;->add(Ljava/lang/Object;)Z

    .line 17
    const-string/jumbo v2, "message3"

    .line 18
    .local v2, "message3":Ljava/lang/String;
    invoke-virtual {v3, v2}, Ljava/util/ArrayList;->add(Ljava/lang/Object;)Z

    .line 20
    invoke-virtual {v3}, Ljava/util/ArrayList;->toArray()[Ljava/lang/Object;

    move-result-object v4

    invoke-static {v4}, Ljava/util/Arrays;->toString([Ljava/lang/Object;)Ljava/lang/String;

    move-result-object v4

    return-object v4
.end method

```

`src/obfuscapk/obfuscators/call_indirection/example/original.java`:

```java
package com.obfuscapk.demo;

import java.util.ArrayList;
import java.util.Arrays;

public class OrderDemo {
    public static String getGotoMessage() {
        // Just some ordered instructions.
        ArrayList<String> messages = new ArrayList<>();

        String message1 = "message1";
        messages.add(message1);

        String message2 = "message2";
        messages.add(message2);

        String message3 = "message3";
        messages.add(message3);

        return Arrays.toString(messages.toArray());
    }
}

```

`src/obfuscapk/obfuscators/class_rename.obfuscator`:

```obfuscator
[Core]
Name = ClassRename
Module = class_rename

[Documentation]
Description = Change the package name and rename classes (even in the manifest file)
Version = 1.0

```

`src/obfuscapk/obfuscators/class_rename/__init__.py`:

```py
#!/usr/bin/env python3

from .class_rename import ClassRename

```

`src/obfuscapk/obfuscators/class_rename/class_rename.py`:

```py
#!/usr/bin/env python3

import logging
import os
import re
import xml.etree.cElementTree as Xml
from typing import List, Set, Dict, Union
from xml.etree.cElementTree import Element

from obfuscapk import obfuscator_category
from obfuscapk import util
from obfuscapk.obfuscation import Obfuscation


class ClassRename(obfuscator_category.IRenameObfuscator):
    def __init__(self):
        self.logger = logging.getLogger(
            "{0}.{1}".format(__name__, self.__class__.__name__)
        )
        super().__init__()

        self.subclass_name_pattern = re.compile(
            r'\s+name\s=\s"(?P<subclass_name>\S+?)"', re.UNICODE
        )

        self.string_pattern = re.compile(r'"(?P<string_value>\S+?)"', re.UNICODE)

        self.split_class_pattern = re.compile(r"[/$]")

        self.package_name: Union[str, None] = None
        self.encrypted_package_name: Union[str, None] = None
        self.ignore_package_names = []

        # Will be populated before running the class rename obfuscator.
        self.class_name_to_smali_file: dict = {}

    def encrypt_identifier(self, identifier: str) -> str:
        identifier_md5 = util.get_string_md5(identifier)
        return "p{0}".format(identifier_md5.lower()[:8])

    def slash_to_dot_notation_for_classes(
        self, rename_transformations: Dict[str, str]
    ) -> Dict[str, str]:
        dot_rename_transformations: Dict[str, str] = {}

        # Remove leading L and trailing ; from class names and replace / and $ with .
        for old_name, new_name in rename_transformations.items():
            dot_rename_transformations[
                old_name[1:-1].replace("/", ".").replace("$", ".")
            ] = (new_name[1:-1].replace("/", ".").replace("$", "."))

        return dot_rename_transformations

    def transform_package_name(self, manifest_xml_root: Element):
        self.encrypted_package_name = ".".join(
            [self.encrypt_identifier(token) for token in self.package_name.split(".")]
        )

        # Rename package name in manifest file.
        manifest_xml_root.set("package", self.encrypted_package_name)
        manifest_xml_root.set(
            "{http://schemas.android.com/apk/res/android}sharedUserId",
            "{0}.uid.shared".format(util.get_random_string(16)),
        )

    def rename_class_declarations(
        self, smali_files: List[str], interactive: bool = False
    ) -> dict:
        renamed_classes = {}

        # Search for class declarations that can be renamed.
        for smali_file in util.show_list_progress(
            smali_files,
            interactive=interactive,
            description="Renaming class declarations",
        ):
            annotation_flag = False
            with util.inplace_edit_file(smali_file) as (in_file, out_file):
                skip_remaining_lines = False
                class_name = None
                r_class = False
                for line in in_file:
                    if skip_remaining_lines:
                        out_file.write(line)
                        continue

                    if not class_name:
                        class_match = util.class_pattern.match(line)
                        if class_match:
                            class_name = class_match.group("class_name")

                            ignore_class = class_name.startswith(
                                tuple(self.ignore_package_names)
                            )

                            # Split class name to its components and encrypt them.
                            class_tokens = self.split_class_pattern.split(
                                class_name[1:-1]
                            )

                            encrypted_class_name = "L"
                            separator_index = 1
                            for token in class_tokens:
                                separator_index += len(token)
                                if token == "R":
                                    r_class = True
                                if token.isdigit():
                                    encrypted_class_name += (
                                        token + class_name[separator_index]
                                    )
                                elif not r_class and not ignore_class:
                                    encrypted_class_name += (
                                        self.encrypt_identifier(token)
                                        + class_name[separator_index]
                                    )
                                else:
                                    encrypted_class_name += (
                                        token + class_name[separator_index]
                                    )
                                separator_index += 1

                            out_file.write(
                                line.replace(class_name, encrypted_class_name)
                            )

                            renamed_classes[class_name] = encrypted_class_name
                            continue

                    if (
                        line.strip()
                        == ".annotation system Ldalvik/annotation/InnerClass;"
                    ):
                        annotation_flag = True
                        out_file.write(line)
                        continue

                    if annotation_flag and 'name = "' in line:
                        # Subclasses have to be renamed as well.
                        subclass_match = self.subclass_name_pattern.match(line)
                        if subclass_match and not r_class:
                            subclass_name = subclass_match.group("subclass_name")
                            out_file.write(
                                line.replace(
                                    subclass_name,
                                    self.encrypt_identifier(subclass_name),
                                )
                            )
                        else:
                            out_file.write(line)
                        continue

                    if line.strip() == ".end annotation":
                        annotation_flag = False
                        out_file.write(line)
                        continue

                    # Method declaration reached, no more class definitions in
                    # this file.
                    if line.startswith(".method "):
                        skip_remaining_lines = True
                        out_file.write(line)
                    else:
                        out_file.write(line)

        return renamed_classes

    def rename_class_usages_in_smali(
        self,
        smali_files: List[str],
        rename_transformations: dict,
        interactive: bool = False,
    ):
        dot_rename_transformations = self.slash_to_dot_notation_for_classes(
            rename_transformations
        )

        # Add package name.
        dot_rename_transformations[self.package_name] = self.encrypted_package_name

        for smali_file in util.show_list_progress(
            smali_files,
            interactive=interactive,
            description="Renaming class usages in smali files",
        ):
            with util.inplace_edit_file(smali_file) as (in_file, out_file):
                for line in in_file:
                    # Rename classes used as strings with . instead of /.
                    string_match = self.string_pattern.search(line)
                    if (
                        string_match
                        and string_match.group("string_value")
                        in dot_rename_transformations
                    ):
                        line = line.replace(
                            string_match.group("string_value"),
                            dot_rename_transformations[
                                string_match.group("string_value")
                            ],
                        )

                    # Sometimes classes are used in annotations as strings
                    # without trailing ;
                    if (
                        string_match
                        and "{0};".format(string_match.group("string_value"))
                        in rename_transformations
                    ):
                        line = line.replace(
                            string_match.group("string_value"),
                            rename_transformations[
                                "{0};".format(string_match.group("string_value"))
                            ][:-1],
                        )

                    # Rename classes used with the "classic" syntax
                    # (leading L and trailing ;).
                    class_names = util.class_name_pattern.findall(line)
                    for class_name in class_names:
                        if class_name in rename_transformations:
                            line = line.replace(
                                class_name, rename_transformations[class_name]
                            )

                    out_file.write(line)

    def rename_class_usages_in_xml(
        self,
        xml_files: List[str],
        rename_transformations: dict,
        interactive: bool = False,
    ):
        dot_rename_transformations = self.slash_to_dot_notation_for_classes(
            rename_transformations
        )

        # Add package name.
        dot_rename_transformations[self.package_name] = self.encrypted_package_name

        for xml_file in util.show_list_progress(
            xml_files,
            interactive=interactive,
            description="Renaming class usages in xml files",
        ):
            with open(xml_file, "r", encoding="utf-8") as current_file:
                file_content = current_file.read()

            # Replace strings from longest to shortest (to avoid replacing
            # partial strings).
            for old_name in sorted(dot_rename_transformations, reverse=True, key=len):
                file_content = file_content.replace(
                    old_name, dot_rename_transformations[old_name]
                )

                # Activity without package name (".ActivityName")
                if (
                    '"{0}"'.format(old_name.replace(self.package_name, ""))
                    in file_content
                ):
                    file_content = file_content.replace(
                        '"{0}"'.format(old_name.replace(self.package_name, "")),
                        '"{0}"'.format(
                            dot_rename_transformations[old_name].replace(
                                self.encrypted_package_name, ""
                            )
                        ),
                    )

            with open(xml_file, "w", encoding="utf-8") as current_file:
                current_file.write(file_content)

    def obfuscate(self, obfuscation_info: Obfuscation):
        self.logger.info('Running "{0}" obfuscator'.format(self.__class__.__name__))

        try:
            Xml.register_namespace(
                "android", "http://schemas.android.com/apk/res/android"
            )

            xml_parser = Xml.XMLParser(encoding="utf-8")
            manifest_tree = Xml.parse(
                obfuscation_info.get_manifest_file(), parser=xml_parser
            )
            manifest_root = manifest_tree.getroot()

            self.package_name = manifest_root.get("package")
            if not self.package_name:
                raise Exception(
                    "Unable to extract package name from application manifest"
                )

            # Get a mapping between class name and smali file path.
            for smali_file in util.show_list_progress(
                obfuscation_info.get_smali_files(),
                interactive=obfuscation_info.interactive,
                description="Class name to smali file mapping",
            ):
                with open(smali_file, "r", encoding="utf-8") as current_file:
                    class_name = None
                    for line in current_file:
                        if not class_name:
                            # Every smali file contains a class.
                            class_match = util.class_pattern.match(line)
                            if class_match:
                                self.class_name_to_smali_file[
                                    class_match.group("class_name")
                                ] = smali_file
                                break

            self.transform_package_name(manifest_root)

            # Write the changes into the manifest file.
            manifest_tree.write(obfuscation_info.get_manifest_file(), encoding="utf-8")

            xml_files: Set[str] = set(
                os.path.join(root, file_name)
                for root, dir_names, file_names in os.walk(
                    obfuscation_info.get_resource_directory()
                )
                for file_name in file_names
                if file_name.endswith(".xml")
                and (
                    "layout" in root or "xml" in root
                )  # Only res/layout-*/ and res/xml-*/ folders.
            )
            xml_files.add(obfuscation_info.get_manifest_file())

            # TODO: use the following code to rename only the classes declared in
            #  application's package.

            # package_smali_files: Set[str] = set(
            #     smali_file
            #     for class_name, smali_file in self.class_name_to_smali_file.items()
            #     if class_name[1:].startswith(self.package_name.replace(".", "/"))
            # )
            #
            # # Rename the classes declared in the application's package.
            # class_rename_transformations = self.rename_class_declarations(
            #     list(package_smali_files), obfuscation_info.interactive
            # )

            # Get user defined ignore package list.
            self.ignore_package_names = obfuscation_info.get_ignore_package_names()

            # Rename all classes declared in smali files.
            class_rename_transformations = self.rename_class_declarations(
                obfuscation_info.get_smali_files(), obfuscation_info.interactive
            )

            # Update renamed classes through all the smali files.
            self.rename_class_usages_in_smali(
                obfuscation_info.get_smali_files(),
                class_rename_transformations,
                obfuscation_info.interactive,
            )

            # Update renamed classes through all the xml files.
            self.rename_class_usages_in_xml(
                list(xml_files),
                class_rename_transformations,
                obfuscation_info.interactive,
            )

        except Exception as e:
            self.logger.error(
                'Error during execution of "{0}" obfuscator: {1}'.format(
                    self.__class__.__name__, e
                )
            )
            raise

        finally:
            obfuscation_info.used_obfuscators.append(self.__class__.__name__)

```

`src/obfuscapk/obfuscators/const_string_encryption.obfuscator`:

```obfuscator
[Core]
Name = ConstStringEncryption
Module = const_string_encryption

[Documentation]
Description = Encrypt constant strings in code
Version = 1.0

```

`src/obfuscapk/obfuscators/const_string_encryption/__init__.py`:

```py
#!/usr/bin/env python3

from .const_string_encryption import ConstStringEncryption

```

`src/obfuscapk/obfuscators/const_string_encryption/const_string_encryption.py`:

```py
#!/usr/bin/env python3

import logging
import os
import re
from binascii import hexlify
from typing import List, Set

from Crypto.Cipher import AES
from Crypto.Protocol.KDF import PBKDF2
from Crypto.Util.Padding import pad

from obfuscapk import obfuscator_category
from obfuscapk import util
from obfuscapk.obfuscation import Obfuscation


class ConstStringEncryption(obfuscator_category.IEncryptionObfuscator):
    def __init__(self):
        self.logger = logging.getLogger(
            "{0}.{1}".format(__name__, self.__class__.__name__)
        )
        super().__init__()

        self.encryption_secret = "This-key-need-to-be-32-character"

    def encrypt_string(self, string_to_encrypt: str) -> str:
        # This is needed to remove the escaping added by Python. For example, if we
        # find in smali the instruction const-string v0, "\"message\"" Android will
        # treat it as "message" while in Python it's \"message\", so we need to encrypt
        # "message" and not \"message\" (we have to remove the unnecessary escaping,
        # otherwise the backslashes would by encrypted as part of the string).
        string_to_encrypt = string_to_encrypt.encode(errors="replace").decode(
            "unicode_escape"
        )

        key = PBKDF2(
            password=self.encryption_secret,
            salt=self.encryption_secret.encode(),
            dkLen=32,
            count=128,
        )
        encrypted_string = hexlify(
            AES.new(key=key, mode=AES.MODE_ECB).encrypt(
                pad(string_to_encrypt.encode(errors="replace"), AES.block_size)
            )
        ).decode()
        return encrypted_string

    def obfuscate(self, obfuscation_info: Obfuscation):
        self.logger.info('Running "{0}" obfuscator'.format(self.__class__.__name__))

        self.encryption_secret = obfuscation_info.encryption_secret
        try:
            encrypted_strings: Set[str] = set()

            # .field <other_optional_stuff> <string_name>:Ljava/lang/String; =
            # "<string_value>"
            static_string_pattern = re.compile(
                r"\.field.+?static.+?(?P<string_name>\S+?):"
                r'Ljava/lang/String;\s=\s"(?P<string_value>.+)"',
                re.UNICODE,
            )

            for smali_file in util.show_list_progress(
                obfuscation_info.get_smali_files(),
                interactive=obfuscation_info.interactive,
                description="Encrypting constant strings",
            ):
                self.logger.debug(
                    'Encrypting constant strings in file "{0}"'.format(smali_file)
                )

                with open(smali_file, "r", encoding="utf-8") as current_file:
                    lines = current_file.readlines()

                class_name = None

                # Line numbers where a static string is declared.
                static_string_index: List[int] = []

                # Names of the static strings.
                static_string_name: List[str] = []

                # Values of the static strings.
                static_string_value: List[str] = []

                direct_methods_line = -1
                static_constructor_line = -1

                # Line numbers where a constant string is declared.
                string_index: List[int] = []

                # Registers containing the constant strings.
                string_register: List[str] = []

                # Values of the constant strings.
                string_value: List[str] = []

                current_local_count = 0
                for line_number, line in enumerate(lines):
                    if not class_name:
                        class_match = util.class_pattern.match(line)
                        if class_match:
                            class_name = class_match.group("class_name")
                            continue

                    if line.startswith("# direct methods"):
                        direct_methods_line = line_number
                        continue

                    if line.startswith(".method") and line.strip().endswith(
                        "static constructor <clinit>()V"
                    ):
                        static_constructor_line = line_number
                        continue

                    static_string_match = static_string_pattern.match(line)
                    if static_string_match and static_string_match.group(
                        "string_value"
                    ):
                        # A static non empty string initialization was found.
                        static_string_index.append(line_number)
                        static_string_name.append(
                            static_string_match.group("string_name")
                        )
                        static_string_value.append(
                            static_string_match.group("string_value")
                        )

                    # We are iterating the lines in order, so each time we enter a
                    # method we'll find the declaration with the number of local
                    # registers available. When we'll encounter a constant string later
                    # in the body of the method, we'll look at its register value and if
                    # it's greater than 15 we won't encrypt it (the invoke instruction
                    # that we need later won't take registers with values greater
                    # than 15).
                    match = util.locals_pattern.match(line)
                    if match:
                        current_local_count = int(match.group("local_count"))
                        continue

                    # If the constant string has a register v0-v15 we can proceed with
                    # the encryption, but if it uses a p<number> register, before
                    # encrypting we have to check if <number> + locals <= 15.
                    string_match = util.const_string_pattern.match(line)
                    if string_match and string_match.group("string"):
                        reg_type = string_match.group("register")[:1]
                        reg_number = int(string_match.group("register")[1:])
                        if (reg_type == "v" and reg_number <= 15) or (
                            reg_type == "p" and reg_number + current_local_count <= 15
                        ):
                            # A non empty string was found in a register <= 15.
                            string_index.append(line_number)
                            string_register.append(string_match.group("register"))
                            string_value.append(string_match.group("string"))

                # Const string encryption.

                for string_number, index in enumerate(string_index):
                    lines[index] = (
                        '\tconst-string/jumbo {register}, "{enc_string}"\n'
                        "\n\tinvoke-static {{{register}}}, "
                        "Lcom/decryptstringmanager/DecryptString"
                        ";->decryptString(Ljava/lang/String;)Ljava/lang/String;\n"
                        "\n\tmove-result-object {register}\n".format(
                            register=string_register[string_number],
                            enc_string=self.encrypt_string(string_value[string_number]),
                        )
                    )

                    encrypted_strings.add(string_value[string_number])

                # Static string encryption.

                static_string_encryption_code = ""
                for string_number, index in enumerate(static_string_index):
                    # Remove the original initialization.
                    lines[index] = "{0}\n".format(lines[index].split(" = ")[0])

                    # Initialize the static string from an encrypted string.
                    static_string_encryption_code += (
                        '\tconst-string/jumbo v0, "{enc_string}"\n'
                        "\n\tinvoke-static {{v0}}, "
                        "Lcom/decryptstringmanager/DecryptString"
                        ";->decryptString(Ljava/lang/String;)Ljava/lang/String;\n"
                        "\n\tmove-result-object v0\n"
                        "\n\tsput-object v0, {class_name}->"
                        "{string_name}:Ljava/lang/String;\n\n".format(
                            enc_string=self.encrypt_string(
                                static_string_value[string_number]
                            ),
                            class_name=class_name,
                            string_name=static_string_name[string_number],
                        )
                    )

                    encrypted_strings.add(static_string_value[string_number])

                if static_string_encryption_code != "":
                    if static_constructor_line != -1:
                        # Add static string encryption to the existing static constructor.
                        local_match = util.locals_pattern.match(
                            lines[static_constructor_line + 1]
                        )
                        if local_match:
                            # At least one register is needed.
                            local_count = int(local_match.group("local_count"))
                            if local_count == 0:
                                lines[static_constructor_line + 1] = "\t.locals 1\n"
                            lines[static_constructor_line + 2] = "\n{0}".format(
                                static_string_encryption_code
                            )
                    else:
                        # Add a new static constructor for the static string encryption.
                        if direct_methods_line != -1:
                            new_constructor_line = direct_methods_line
                        else:
                            new_constructor_line = len(lines) - 1

                        lines[new_constructor_line] = (
                            "{original}"
                            ".method static constructor <clinit>()V\n"
                            "\t.locals 1\n\n"
                            "{encryption_code}"
                            "\treturn-void\n"
                            ".end method\n\n".format(
                                original=lines[new_constructor_line],
                                encryption_code=static_string_encryption_code,
                            )
                        )

                with open(smali_file, "w", encoding="utf-8") as current_file:
                    current_file.writelines(lines)

            if (
                not obfuscation_info.decrypt_string_smali_file_added_flag
                and encrypted_strings
            ):
                # Add to the app the code for decrypting the encrypted strings. The code
                # for decrypting can be put in any smali directory, since it will be
                # moved to the correct directory when rebuilding the application.
                destination_dir = os.path.dirname(obfuscation_info.get_smali_files()[0])
                destination_file = os.path.join(destination_dir, "DecryptString.smali")
                with open(
                    destination_file, "w", encoding="utf-8"
                ) as decrypt_string_smali:
                    decrypt_string_smali.write(
                        util.get_decrypt_string_smali_code(self.encryption_secret)
                    )
                    obfuscation_info.decrypt_string_smali_file_added_flag = True

        except Exception as e:
            self.logger.error(
                'Error during execution of "{0}" obfuscator: {1}'.format(
                    self.__class__.__name__, e
                )
            )
            raise

        finally:
            obfuscation_info.used_obfuscators.append(self.__class__.__name__)

```

`src/obfuscapk/obfuscators/debug_removal.obfuscator`:

```obfuscator
[Core]
Name = DebugRemoval
Module = debug_removal

[Documentation]
Description = Remove debug information
Version = 1.0

```

`src/obfuscapk/obfuscators/debug_removal/__init__.py`:

```py
#!/usr/bin/env python3

from .debug_removal import DebugRemoval

```

`src/obfuscapk/obfuscators/debug_removal/debug_removal.py`:

```py
#!/usr/bin/env python3

import logging
import re

from obfuscapk import obfuscator_category
from obfuscapk import util
from obfuscapk.obfuscation import Obfuscation


class DebugRemoval(obfuscator_category.ICodeObfuscator):
    def __init__(self):
        self.logger = logging.getLogger(
            "{0}.{1}".format(__name__, self.__class__.__name__)
        )
        super().__init__()

    def obfuscate(self, obfuscation_info: Obfuscation):
        self.logger.info('Running "{0}" obfuscator'.format(self.__class__.__name__))

        try:
            debug_op_codes = [
                ".source ",
                ".line ",
                ".prologue",
                ".epilogue",
                ".local ",
                ".end local",
                ".restart local",
                ".param ",
            ]

            param_pattern = re.compile(r"\s+\.param\s(?P<register>[vp0-9]+)")

            for smali_file in util.show_list_progress(
                obfuscation_info.get_smali_files(),
                interactive=obfuscation_info.interactive,
                description="Removing debug information",
            ):
                self.logger.debug(
                    'Removing debug information from file "{0}"'.format(smali_file)
                )

                with open(smali_file, "r", encoding="utf-8") as current_file:
                    file_content = current_file.read()

                with open(smali_file, "w", encoding="utf-8") as current_file:
                    # Keep only the lines not containing debug op codes.
                    # ".param <annotation> .end param" shouldn't be removed.
                    reversed_lines_to_keep = []
                    inside_param_declaration = False
                    for line in reversed(file_content.splitlines(keepends=True)):
                        if line.strip().startswith(".end param"):
                            inside_param_declaration = True
                            reversed_lines_to_keep.append(line)
                        elif (
                            line.strip().startswith(".param ")
                            and inside_param_declaration
                        ):
                            inside_param_declaration = False
                            # Remove unnecessary data from param (name and type
                            # comment).
                            line = "{0}\n".format(param_pattern.match(line).group())
                            reversed_lines_to_keep.append(line)
                        elif not inside_param_declaration:
                            if not any(
                                line.strip().startswith(op_code)
                                for op_code in debug_op_codes
                            ):
                                reversed_lines_to_keep.append(line)
                        else:
                            reversed_lines_to_keep.append(line)

                    current_file.writelines(list(reversed(reversed_lines_to_keep)))

        except Exception as e:
            self.logger.error(
                'Error during execution of "{0}" obfuscator: {1}'.format(
                    self.__class__.__name__, e
                )
            )
            raise

        finally:
            obfuscation_info.used_obfuscators.append(self.__class__.__name__)

```

`src/obfuscapk/obfuscators/debug_removal/example/after.smali`:

```smali
.class public Lcom/obfuscapk/demo/DebugInfoDemo;
.super Ljava/lang/Object;


# direct methods
.method public constructor <init>()V
    .locals 0

    invoke-direct {p0}, Ljava/lang/Object;-><init>()V

    return-void
.end method

.method public static getDebugMessage(Ljava/lang/String;)Ljava/lang/String;
    .locals 3
    .param p0
        .annotation build Landroid/support/annotation/NonNull;
        .end annotation
    .end param

    const-string/jumbo v0, "Debug message from %s"

    const/4 v1, 0x1

    new-array v1, v1, [Ljava/lang/Object;

    const/4 v2, 0x0

    aput-object p0, v1, v2

    invoke-static {v0, v1}, Ljava/lang/String;->format(Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;

    move-result-object v0

    return-object v0
.end method

```

`src/obfuscapk/obfuscators/debug_removal/example/before.smali`:

```smali
.class public Lcom/obfuscapk/demo/DebugInfoDemo;
.super Ljava/lang/Object;
.source "DebugInfoDemo.java"


# direct methods
.method public constructor <init>()V
    .locals 0

    .prologue
    .line 5
    invoke-direct {p0}, Ljava/lang/Object;-><init>()V

    return-void
.end method

.method public static getDebugMessage(Ljava/lang/String;)Ljava/lang/String;
    .locals 3
    .param p0, "from"    # Ljava/lang/String;
        .annotation build Landroid/support/annotation/NonNull;
        .end annotation
    .end param

    .prologue
    .line 7
    const-string/jumbo v0, "Debug message from %s"

    const/4 v1, 0x1

    new-array v1, v1, [Ljava/lang/Object;

    const/4 v2, 0x0

    aput-object p0, v1, v2

    invoke-static {v0, v1}, Ljava/lang/String;->format(Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;

    move-result-object v0

    return-object v0
.end method

```

`src/obfuscapk/obfuscators/debug_removal/example/original.java`:

```java
package com.obfuscapk.demo;

import android.support.annotation.NonNull;

public class DebugInfoDemo {
    public static String getDebugMessage(@NonNull String from) {
        return String.format("Debug message from %s", from);
    }
}

```

`src/obfuscapk/obfuscators/field_rename.obfuscator`:

```obfuscator
[Core]
Name = FieldRename
Module = field_rename

[Documentation]
Description = Rename fields
Version = 1.0

```

`src/obfuscapk/obfuscators/field_rename/__init__.py`:

```py
#!/usr/bin/env python3

from .field_rename import FieldRename

```

`src/obfuscapk/obfuscators/field_rename/field_rename.py`:

```py
#!/usr/bin/env python3

import logging
from typing import List, Set

from obfuscapk import obfuscator_category
from obfuscapk import util
from obfuscapk.obfuscation import Obfuscation


class FieldRename(obfuscator_category.IRenameObfuscator):
    def __init__(self):
        self.logger = logging.getLogger(
            "{0}.{1}".format(__name__, self.__class__.__name__)
        )
        super().__init__()

        self.ignore_package_names = []

        self.is_adding_fields = True

        self.max_fields_to_add = 0
        self.added_fields = 0

    def rename_field(self, field_name: str) -> str:
        field_md5 = util.get_string_md5(field_name)
        return "f{0}".format(field_md5.lower()[:8])

    def get_sdk_class_names(self, smali_files: List[str]) -> Set[str]:
        class_names: Set[str] = set()
        for smali_file in smali_files:
            with open(smali_file, "r", encoding="utf-8") as current_file:
                for line in current_file:
                    class_match = util.class_pattern.match(line)
                    if class_match:
                        # This is probably a SDK class, but we have its declaration so
                        # we can change the fields inside it.
                        if class_match.group("class_name").startswith(
                            ("Landroid", "Ljava")
                        ):
                            class_names.add(class_match.group("class_name"))
                        # There is only one class declaration per file.
                        break
        return class_names

    def rename_field_declarations(
        self, smali_files: List[str], interactive: bool = False
    ) -> Set[str]:
        renamed_fields: Set[str] = set()

        # Search for field definitions that can be renamed.
        for smali_file in util.show_list_progress(
            smali_files,
            interactive=interactive,
            description="Renaming field declarations",
        ):
            with util.inplace_edit_file(smali_file) as (in_file, out_file):
                class_name = None
                for line in in_file:
                    ignore = False

                    if not class_name:
                        class_match = util.class_pattern.match(line)
                        if class_match:
                            class_name = class_match.group("class_name")

                    # Field declared in class.
                    field_match = util.field_pattern.match(line)

                    if class_name.startswith(tuple(self.ignore_package_names)):
                        ignore = True

                    if field_match:
                        field_name = field_match.group("field_name")
                        # Avoid sub-fields and user defined packages.
                        if not ignore and "$" not in field_name:
                            # Rename field declaration (usages of this field will be
                            # renamed later) and add some random fields.
                            line = line.replace(
                                "{0}:".format(field_name),
                                "{0}:".format(self.rename_field(field_name)),
                            )
                            out_file.write(line)

                            # Add random fields.
                            if self.added_fields < self.max_fields_to_add:
                                for _ in range(util.get_random_int(1, 4)):
                                    out_file.write("\n")
                                    out_file.write(
                                        line.replace(
                                            ":",
                                            "{0}:".format(util.get_random_string(8)),
                                        )
                                    )
                                    self.added_fields += 1

                            field = "{field_name}:{field_type}".format(
                                field_name=field_match.group("field_name"),
                                field_type=field_match.group("field_type"),
                            )
                            renamed_fields.add(field)
                        else:
                            out_file.write(line)
                    else:
                        out_file.write(line)

        return renamed_fields

    def rename_field_references(
        self,
        fields_to_rename: Set[str],
        smali_files: List[str],
        sdk_classes: Set[str],
        interactive: bool = False,
    ):
        for smali_file in util.show_list_progress(
            smali_files,
            interactive=interactive,
            description="Renaming field references",
        ):
            with util.inplace_edit_file(smali_file) as (in_file, out_file):
                for line in in_file:
                    # Field usage.
                    field_usage_match = util.field_usage_pattern.match(line)
                    if field_usage_match:
                        field = "{field_name}:{field_type}".format(
                            field_name=field_usage_match.group("field_name"),
                            field_type=field_usage_match.group("field_type"),
                        )
                        class_name = field_usage_match.group("field_object")
                        field_name = field_usage_match.group("field_name")
                        if field in fields_to_rename and (
                            not class_name.startswith(("Landroid", "Ljava"))
                            or class_name in sdk_classes
                        ):
                            # Rename field usage.
                            out_file.write(
                                line.replace(
                                    "{0}:".format(field_name),
                                    "{0}:".format(self.rename_field(field_name)),
                                )
                            )
                        else:
                            out_file.write(line)
                    else:
                        out_file.write(line)

    def obfuscate(self, obfuscation_info: Obfuscation):
        self.logger.info('Running "{0}" obfuscator'.format(self.__class__.__name__))

        # Get user defined ignore package list.
        self.ignore_package_names = obfuscation_info.get_ignore_package_names()

        try:
            sdk_class_declarations = self.get_sdk_class_names(
                obfuscation_info.get_smali_files()
            )
            renamed_field_declarations: Set[str] = set()

            # There is a field limit for dex files.
            self.max_fields_to_add = (
                obfuscation_info.get_remaining_fields_per_obfuscator()
            )
            self.added_fields = 0

            if obfuscation_info.is_multidex():
                for index, dex_smali_files in enumerate(
                    util.show_list_progress(
                        obfuscation_info.get_multidex_smali_files(),
                        interactive=obfuscation_info.interactive,
                        unit="dex",
                        description="Processing multidex",
                    )
                ):
                    self.max_fields_to_add = (
                        obfuscation_info.get_remaining_fields_per_obfuscator()[index]
                    )
                    self.added_fields = 0
                    renamed_field_declarations.update(
                        self.rename_field_declarations(
                            dex_smali_files, obfuscation_info.interactive
                        )
                    )
            else:
                renamed_field_declarations = self.rename_field_declarations(
                    obfuscation_info.get_smali_files(), obfuscation_info.interactive
                )

            # When renaming field references it makes no difference if this is a
            # multidex application, since at this point we are not introducing any new
            # field.
            self.rename_field_references(
                renamed_field_declarations,
                obfuscation_info.get_smali_files(),
                sdk_class_declarations,
                obfuscation_info.interactive,
            )

        except Exception as e:
            self.logger.error(
                'Error during execution of "{0}" obfuscator: {1}'.format(
                    self.__class__.__name__, e
                )
            )
            raise

        finally:
            obfuscation_info.used_obfuscators.append(self.__class__.__name__)

```

`src/obfuscapk/obfuscators/goto.obfuscator`:

```obfuscator
[Core]
Name = Goto
Module = goto

[Documentation]
Description = Reorder code using goto instructions
Version = 1.0

```

`src/obfuscapk/obfuscators/goto/__init__.py`:

```py
#!/usr/bin/env python3

from .goto import Goto

```

`src/obfuscapk/obfuscators/goto/example/after.smali`:

```smali
.class public Lcom/obfuscapk/demo/OrderDemo;
.super Ljava/lang/Object;
.source "OrderDemo.java"


# direct methods
.method public constructor <init>()V
    .locals 0

    goto/32 :after_last_instruction

    :before_first_instruction

    .prologue
    .line 6
    invoke-direct {p0}, Ljava/lang/Object;-><init>()V

    return-void

    :after_last_instruction

    goto/32 :before_first_instruction

.end method

.method public static getGotoMessage()Ljava/lang/String;
    .locals 5

    goto/32 :after_last_instruction

    :before_first_instruction

    .prologue
    .line 9
    new-instance v3, Ljava/util/ArrayList;

    invoke-direct {v3}, Ljava/util/ArrayList;-><init>()V

    .line 11
    .local v3, "messages":Ljava/util/ArrayList;, "Ljava/util/ArrayList<Ljava/lang/String;>;"
    const-string/jumbo v0, "message1"

    .line 12
    .local v0, "message1":Ljava/lang/String;
    invoke-virtual {v3, v0}, Ljava/util/ArrayList;->add(Ljava/lang/Object;)Z

    .line 14
    const-string/jumbo v1, "message2"

    .line 15
    .local v1, "message2":Ljava/lang/String;
    invoke-virtual {v3, v1}, Ljava/util/ArrayList;->add(Ljava/lang/Object;)Z

    .line 17
    const-string/jumbo v2, "message3"

    .line 18
    .local v2, "message3":Ljava/lang/String;
    invoke-virtual {v3, v2}, Ljava/util/ArrayList;->add(Ljava/lang/Object;)Z

    .line 20
    invoke-virtual {v3}, Ljava/util/ArrayList;->toArray()[Ljava/lang/Object;

    move-result-object v4

    invoke-static {v4}, Ljava/util/Arrays;->toString([Ljava/lang/Object;)Ljava/lang/String;

    move-result-object v4

    return-object v4

    :after_last_instruction

    goto/32 :before_first_instruction

.end method

```

`src/obfuscapk/obfuscators/goto/example/before.smali`:

```smali
.class public Lcom/obfuscapk/demo/OrderDemo;
.super Ljava/lang/Object;
.source "OrderDemo.java"


# direct methods
.method public constructor <init>()V
    .locals 0

    .prologue
    .line 6
    invoke-direct {p0}, Ljava/lang/Object;-><init>()V

    return-void
.end method

.method public static getGotoMessage()Ljava/lang/String;
    .locals 5

    .prologue
    .line 9
    new-instance v3, Ljava/util/ArrayList;

    invoke-direct {v3}, Ljava/util/ArrayList;-><init>()V

    .line 11
    .local v3, "messages":Ljava/util/ArrayList;, "Ljava/util/ArrayList<Ljava/lang/String;>;"
    const-string/jumbo v0, "message1"

    .line 12
    .local v0, "message1":Ljava/lang/String;
    invoke-virtual {v3, v0}, Ljava/util/ArrayList;->add(Ljava/lang/Object;)Z

    .line 14
    const-string/jumbo v1, "message2"

    .line 15
    .local v1, "message2":Ljava/lang/String;
    invoke-virtual {v3, v1}, Ljava/util/ArrayList;->add(Ljava/lang/Object;)Z

    .line 17
    const-string/jumbo v2, "message3"

    .line 18
    .local v2, "message3":Ljava/lang/String;
    invoke-virtual {v3, v2}, Ljava/util/ArrayList;->add(Ljava/lang/Object;)Z

    .line 20
    invoke-virtual {v3}, Ljava/util/ArrayList;->toArray()[Ljava/lang/Object;

    move-result-object v4

    invoke-static {v4}, Ljava/util/Arrays;->toString([Ljava/lang/Object;)Ljava/lang/String;

    move-result-object v4

    return-object v4
.end method

```

`src/obfuscapk/obfuscators/goto/example/original.java`:

```java
package com.obfuscapk.demo;

import java.util.ArrayList;
import java.util.Arrays;

public class OrderDemo {
    public static String getGotoMessage() {
        // Just some ordered instructions.
        ArrayList<String> messages = new ArrayList<>();

        String message1 = "message1";
        messages.add(message1);

        String message2 = "message2";
        messages.add(message2);

        String message3 = "message3";
        messages.add(message3);

        return Arrays.toString(messages.toArray());
    }
}

```

`src/obfuscapk/obfuscators/goto/goto.py`:

```py
#!/usr/bin/env python3

import logging

from obfuscapk import obfuscator_category
from obfuscapk import util
from obfuscapk.obfuscation import Obfuscation


class Goto(obfuscator_category.ICodeObfuscator):
    def __init__(self):
        self.logger = logging.getLogger(
            "{0}.{1}".format(__name__, self.__class__.__name__)
        )
        super().__init__()

    def obfuscate(self, obfuscation_info: Obfuscation):
        self.logger.info('Running "{0}" obfuscator'.format(self.__class__.__name__))

        try:
            for smali_file in util.show_list_progress(
                obfuscation_info.get_smali_files(),
                interactive=obfuscation_info.interactive,
                description='Inserting "goto" instructions in smali files',
            ):
                self.logger.debug(
                    'Inserting "goto" instructions in file "{0}"'.format(smali_file)
                )
                with util.inplace_edit_file(smali_file) as (in_file, out_file):
                    editing_method = False
                    for line in in_file:
                        if (
                            line.startswith(".method ")
                            and " abstract " not in line
                            and " native " not in line
                            and not editing_method
                        ):
                            # If at the beginning of a non abstract/native method
                            # (after the .locals instruction), insert a "goto" to the
                            # label at the end of the method and a label to the first
                            # instruction of the method.
                            out_file.write(line)
                            editing_method = True

                        elif editing_method and util.locals_pattern.match(line):
                            out_file.write(line)
                            out_file.write("\n\tgoto/32 :after_last_instruction\n\n")
                            out_file.write("\t:before_first_instruction\n")

                        elif line.startswith(".end method") and editing_method:
                            # If at the end of the method, insert a label after the
                            # last instruction of the method and a "goto" to the label
                            # at the beginning of the method. This will not cause an
                            # endless loop because the method will return at some point
                            # and the second "goto" won't be called again when the
                            # method finishes.
                            out_file.write("\n\t:after_last_instruction\n\n")
                            out_file.write("\tgoto/32 :before_first_instruction\n\n")
                            out_file.write(line)
                            editing_method = False

                        else:
                            out_file.write(line)

        except Exception as e:
            self.logger.error(
                'Error during execution of "{0}" obfuscator: {1}'.format(
                    self.__class__.__name__, e
                )
            )
            raise

        finally:
            obfuscation_info.used_obfuscators.append(self.__class__.__name__)

```

`src/obfuscapk/obfuscators/lib_encryption.obfuscator`:

```obfuscator
[Core]
Name = LibEncryption
Module = lib_encryption

[Documentation]
Description = Encrypt native libs
Version = 1.0

```

`src/obfuscapk/obfuscators/lib_encryption/__init__.py`:

```py
#!/usr/bin/env python3

from .lib_encryption import LibEncryption

```

`src/obfuscapk/obfuscators/lib_encryption/example/after.smali`:

```smali
.class public Lcom/obfuscapk/demo/NativeLibraryDemo;
.super Ljava/lang/Object;
.source "NativeLibraryDemo.java"


# direct methods
.method static constructor <clinit>()V
    .locals 2

    .prologue
    .line 8
    const-string/jumbo v0, "native-lib"

    const-class v1, Lcom/obfuscapk/demo/NativeLibraryDemo;

    invoke-static {v1, v0}, Lcom/decryptassetmanager/DecryptAsset;->loadEncryptedLibrary(Ljava/lang/Class;Ljava/lang/String;)V

    .line 9
    return-void
.end method

.method public constructor <init>()V
    .locals 0

    .prologue
    .line 3
    invoke-direct {p0}, Ljava/lang/Object;-><init>()V

    return-void
.end method

.method private native stringFromJNI()Ljava/lang/String;
.end method


# virtual methods
.method public getMessageFromNativeLib()Ljava/lang/String;
    .locals 1

    .prologue
    .line 14
    invoke-direct {p0}, Lcom/obfuscapk/demo/NativeLibraryDemo;->stringFromJNI()Ljava/lang/String;

    move-result-object v0

    return-object v0
.end method

```

`src/obfuscapk/obfuscators/lib_encryption/example/before.smali`:

```smali
.class public Lcom/obfuscapk/demo/NativeLibraryDemo;
.super Ljava/lang/Object;
.source "NativeLibraryDemo.java"


# direct methods
.method static constructor <clinit>()V
    .locals 1

    .prologue
    .line 8
    const-string/jumbo v0, "native-lib"

    invoke-static {v0}, Ljava/lang/System;->loadLibrary(Ljava/lang/String;)V

    .line 9
    return-void
.end method

.method public constructor <init>()V
    .locals 0

    .prologue
    .line 3
    invoke-direct {p0}, Ljava/lang/Object;-><init>()V

    return-void
.end method

.method private native stringFromJNI()Ljava/lang/String;
.end method


# virtual methods
.method public getMessageFromNativeLib()Ljava/lang/String;
    .locals 1

    .prologue
    .line 14
    invoke-direct {p0}, Lcom/obfuscapk/demo/NativeLibraryDemo;->stringFromJNI()Ljava/lang/String;

    move-result-object v0

    return-object v0
.end method

```

`src/obfuscapk/obfuscators/lib_encryption/example/original.java`:

```java
package com.obfuscapk.demo;

public class NativeLibraryDemo {

    // Used to load the 'native-lib' library.
    static {
        // This is the instruction that will be replaced by loading the encrypted lib from assets.
        System.loadLibrary("native-lib");
    }

    private native String stringFromJNI();

    public String getMessageFromNativeLib() {
        return stringFromJNI();
    }
}

```

`src/obfuscapk/obfuscators/lib_encryption/lib_encryption.py`:

```py
#!/usr/bin/env python3

import logging
import os
import re
from typing import List, Dict

from Crypto.Cipher import AES
from Crypto.Util.Padding import pad

from obfuscapk import obfuscator_category
from obfuscapk import util
from obfuscapk.obfuscation import Obfuscation


class LibEncryption(obfuscator_category.IEncryptionObfuscator):
    def __init__(self):
        self.logger = logging.getLogger(
            "{0}.{1}".format(__name__, self.__class__.__name__)
        )
        super().__init__()

        self.encryption_secret = "This-key-need-to-be-32-character"

    def obfuscate(self, obfuscation_info: Obfuscation):
        self.logger.info('Running "{0}" obfuscator'.format(self.__class__.__name__))

        self.encryption_secret = obfuscation_info.encryption_secret
        try:
            native_libs = obfuscation_info.get_native_lib_files()

            native_lib_invoke_pattern = re.compile(
                r"\s+invoke-static\s{(?P<invoke_pass>[vp0-9]+)},\s"
                r"Ljava/lang/System;->loadLibrary\(Ljava/lang/String;\)V"
            )

            encrypted_to_original_mapping: Dict[str, str] = {}

            if native_libs:
                for smali_file in util.show_list_progress(
                    obfuscation_info.get_smali_files(),
                    interactive=obfuscation_info.interactive,
                    description="Encrypting native libraries",
                ):
                    self.logger.debug(
                        "Replacing native libraries with encrypted native libraries "
                        'in file "{0}"'.format(smali_file)
                    )

                    with open(smali_file, "r", encoding="utf-8") as current_file:
                        lines = current_file.readlines()

                    class_name = None

                    local_count = 16

                    # Names of the loaded libraries.
                    lib_names: List[str] = []

                    editing_constructor = False
                    start_index = 0
                    for line_number, line in enumerate(lines):
                        if not class_name:
                            class_match = util.class_pattern.match(line)
                            if class_match:
                                class_name = class_match.group("class_name")
                                continue

                        # Native libraries should be loaded inside static constructors.
                        if (
                            line.startswith(".method static constructor <clinit>()V")
                            and not editing_constructor
                        ):
                            # Entering static constructor.
                            editing_constructor = True
                            start_index = line_number + 1
                            local_match = util.locals_pattern.match(
                                lines[line_number + 1]
                            )
                            if local_match:
                                local_count = int(local_match.group("local_count"))
                                if local_count <= 15:
                                    # An additional register is needed for the
                                    # encryption.
                                    local_count += 1
                                    lines[line_number + 1] = "\t.locals {0}\n".format(
                                        local_count
                                    )
                                    continue

                            # For some reason the locals declaration was not found where
                            # it should be, so assume the local registers are all used
                            # (we can't add any instruction here).
                            break

                        elif line.startswith(".end method") and editing_constructor:
                            # Only one static constructor per class.
                            break

                        elif editing_constructor:
                            # Inside static constructor.
                            invoke_match = native_lib_invoke_pattern.match(line)
                            if invoke_match:
                                # Native library load instruction. Iterate the
                                # constructor lines backwards in order to find the
                                # string containing the name of the loaded library.
                                for l_num in range(line_number - 1, start_index, -1):
                                    string_match = util.const_string_pattern.match(
                                        lines[l_num]
                                    )
                                    if string_match and string_match.group(
                                        "register"
                                    ) == invoke_match.group("invoke_pass"):
                                        # Native library string declaration.
                                        lib_names.append(string_match.group("string"))

                                # Static constructors take no parameters, so the highest
                                # register is v<local_count - 1>.
                                lines[line_number] = (
                                    "\tconst-class v{class_register_num}, "
                                    "{class_name}\n\n"
                                    "\tinvoke-static {{v{class_register_num}, "
                                    "{original_register}}}, "
                                    "Lcom/decryptassetmanager/DecryptAsset;->"
                                    "loadEncryptedLibrary("
                                    "Ljava/lang/Class;Ljava/lang/String;)V\n".format(
                                        class_name=class_name,
                                        original_register=invoke_match.group(
                                            "invoke_pass"
                                        ),
                                        class_register_num=local_count - 1,
                                    )
                                )

                        # Encrypt the native libraries used in code and put them
                        # in assets folder.
                        assets_dir = obfuscation_info.get_assets_directory()
                        os.makedirs(assets_dir, exist_ok=True)
                        for native_lib in native_libs:
                            for lib_name in lib_names:
                                if native_lib.endswith("{0}.so".format(lib_name)):
                                    arch = os.path.basename(os.path.dirname(native_lib))
                                    encrypted_lib_path = os.path.join(
                                        assets_dir,
                                        "lib.{arch}.{lib_name}.so".format(
                                            arch=arch, lib_name=lib_name
                                        ),
                                    )

                                    with open(native_lib, "rb") as native_lib_file:
                                        encrypted_lib = AES.new(
                                            key=self.encryption_secret.encode(),
                                            mode=AES.MODE_ECB,
                                        ).encrypt(
                                            pad(native_lib_file.read(), AES.block_size)
                                        )

                                    with open(
                                        encrypted_lib_path, "wb"
                                    ) as encrypted_lib_file:
                                        encrypted_lib_file.write(encrypted_lib)

                                    encrypted_to_original_mapping[
                                        encrypted_lib_path
                                    ] = native_lib

                    with open(smali_file, "w", encoding="utf-8") as current_file:
                        current_file.writelines(lines)

                if (
                    not obfuscation_info.decrypt_asset_smali_file_added_flag
                    and encrypted_to_original_mapping
                ):
                    # Add to the app the code for decrypting the encrypted native
                    # libraries. The code for decrypting can be put in any smali
                    # directory, since it will be moved to the correct directory
                    # when rebuilding the application.
                    destination_dir = os.path.dirname(
                        obfuscation_info.get_smali_files()[0]
                    )
                    destination_file = os.path.join(
                        destination_dir, "DecryptAsset.smali"
                    )
                    with open(
                        destination_file, "w", encoding="utf-8"
                    ) as decrypt_asset_smali:
                        decrypt_asset_smali.write(
                            util.get_decrypt_asset_smali_code(self.encryption_secret)
                        )
                        obfuscation_info.decrypt_asset_smali_file_added_flag = True

                # Remove the original native libraries that were encrypted (the
                # encrypted ones will be used instead).
                for _, original_lib in encrypted_to_original_mapping.items():
                    try:
                        os.remove(original_lib)
                    except OSError as e:
                        self.logger.warning(
                            'Unable to delete native library "{0}": {1}'.format(
                                original_lib, e
                            )
                        )

            else:
                self.logger.debug("No native libraries found")

        except Exception as e:
            self.logger.error(
                'Error during execution of "{0}" obfuscator: {1}'.format(
                    self.__class__.__name__, e
                )
            )
            raise

        finally:
            obfuscation_info.used_obfuscators.append(self.__class__.__name__)

```

`src/obfuscapk/obfuscators/method_overload.obfuscator`:

```obfuscator
[Core]
Name = MethodOverload
Module = method_overload

[Documentation]
Description = Overload methods
Version = 1.0

```

`src/obfuscapk/obfuscators/method_overload/__init__.py`:

```py
#!/usr/bin/env python3

from .method_overload import MethodOverload

```

`src/obfuscapk/obfuscators/method_overload/example/after.smali`:

```smali
.class public Lcom/obfuscapk/demo/OrderDemo;
.super Ljava/lang/Object;
.source "OrderDemo.java"


# direct methods
.method public constructor <init>()V
    .locals 0

    .prologue
    .line 6
    invoke-direct {p0}, Ljava/lang/Object;-><init>()V

    return-void
.end method

.method public static getGotoMessage(SZIB)V
    .locals 0

    const/16 p0, 0x2a

    const/16 p1, 0xd2

    mul-int p2, p0, p1

    add-int p3, p2, p1

    int-to-double p0, p3

    return-void
.end method

.method public static getGotoMessage(SBIZ)V
    .locals 0

    const/16 p0, 0x2a

    const/16 p1, 0xd2

    mul-int p2, p0, p1

    add-int p3, p2, p1

    int-to-double p0, p3

    return-void
.end method

.method public static getGotoMessage(BZIS)V
    .locals 0

    const/16 p0, 0x2a

    const/16 p1, 0xd2

    mul-int p2, p0, p1

    add-int p3, p2, p1

    int-to-double p0, p3

    return-void
.end method

.method public static getGotoMessage()Ljava/lang/String;
    .locals 5

    .prologue
    .line 9
    new-instance v3, Ljava/util/ArrayList;

    invoke-direct {v3}, Ljava/util/ArrayList;-><init>()V

    .line 11
    .local v3, "messages":Ljava/util/ArrayList;, "Ljava/util/ArrayList<Ljava/lang/String;>;"
    const-string/jumbo v0, "message1"

    .line 12
    .local v0, "message1":Ljava/lang/String;
    invoke-virtual {v3, v0}, Ljava/util/ArrayList;->add(Ljava/lang/Object;)Z

    .line 14
    const-string/jumbo v1, "message2"

    .line 15
    .local v1, "message2":Ljava/lang/String;
    invoke-virtual {v3, v1}, Ljava/util/ArrayList;->add(Ljava/lang/Object;)Z

    .line 17
    const-string/jumbo v2, "message3"

    .line 18
    .local v2, "message3":Ljava/lang/String;
    invoke-virtual {v3, v2}, Ljava/util/ArrayList;->add(Ljava/lang/Object;)Z

    .line 20
    invoke-virtual {v3}, Ljava/util/ArrayList;->toArray()[Ljava/lang/Object;

    move-result-object v4

    invoke-static {v4}, Ljava/util/Arrays;->toString([Ljava/lang/Object;)Ljava/lang/String;

    move-result-object v4

    return-object v4
.end method

```

`src/obfuscapk/obfuscators/method_overload/example/before.smali`:

```smali
.class public Lcom/obfuscapk/demo/OrderDemo;
.super Ljava/lang/Object;
.source "OrderDemo.java"


# direct methods
.method public constructor <init>()V
    .locals 0

    .prologue
    .line 6
    invoke-direct {p0}, Ljava/lang/Object;-><init>()V

    return-void
.end method

.method public static getGotoMessage()Ljava/lang/String;
    .locals 5

    .prologue
    .line 9
    new-instance v3, Ljava/util/ArrayList;

    invoke-direct {v3}, Ljava/util/ArrayList;-><init>()V

    .line 11
    .local v3, "messages":Ljava/util/ArrayList;, "Ljava/util/ArrayList<Ljava/lang/String;>;"
    const-string/jumbo v0, "message1"

    .line 12
    .local v0, "message1":Ljava/lang/String;
    invoke-virtual {v3, v0}, Ljava/util/ArrayList;->add(Ljava/lang/Object;)Z

    .line 14
    const-string/jumbo v1, "message2"

    .line 15
    .local v1, "message2":Ljava/lang/String;
    invoke-virtual {v3, v1}, Ljava/util/ArrayList;->add(Ljava/lang/Object;)Z

    .line 17
    const-string/jumbo v2, "message3"

    .line 18
    .local v2, "message3":Ljava/lang/String;
    invoke-virtual {v3, v2}, Ljava/util/ArrayList;->add(Ljava/lang/Object;)Z

    .line 20
    invoke-virtual {v3}, Ljava/util/ArrayList;->toArray()[Ljava/lang/Object;

    move-result-object v4

    invoke-static {v4}, Ljava/util/Arrays;->toString([Ljava/lang/Object;)Ljava/lang/String;

    move-result-object v4

    return-object v4
.end method

```

`src/obfuscapk/obfuscators/method_overload/example/original.java`:

```java
package com.obfuscapk.demo;

import java.util.ArrayList;
import java.util.Arrays;

public class OrderDemo {
    public static String getGotoMessage() {
        // Just some ordered instructions.
        ArrayList<String> messages = new ArrayList<>();

        String message1 = "message1";
        messages.add(message1);

        String message2 = "message2";
        messages.add(message2);

        String message3 = "message3";
        messages.add(message3);

        return Arrays.toString(messages.toArray());
    }
}

```

`src/obfuscapk/obfuscators/method_overload/method_overload.py`:

```py
#!/usr/bin/env python3

import logging
import random
from typing import List, Set

from obfuscapk import obfuscator_category
from obfuscapk import util
from obfuscapk.obfuscation import Obfuscation


class MethodOverload(obfuscator_category.ICodeObfuscator):
    def __init__(self):
        self.logger = logging.getLogger(
            "{0}.{1}".format(__name__, self.__class__.__name__)
        )
        super().__init__()

        self.is_adding_methods = True

        self.param_types = ["Ljava/lang/String;", "Z", "B", "S", "C", "I", "F"]

    def add_method_overloads_to_file(
        self,
        smali_file: str,
        overloaded_method_body: str,
        class_names_to_ignore: Set[str],
    ) -> int:
        new_methods_num: int = 0
        with util.inplace_edit_file(smali_file) as (in_file, out_file):
            skip_remaining_lines = False
            class_name = None
            for line in in_file:
                if skip_remaining_lines:
                    out_file.write(line)
                    continue

                if not class_name:
                    class_match = util.class_pattern.match(line)
                    # If this is an enum class, skip it.
                    if " enum " in line:
                        skip_remaining_lines = True
                        out_file.write(line)
                        continue
                    elif class_match:
                        class_name = class_match.group("class_name")
                        if class_name in class_names_to_ignore:
                            # The methods of this class should be ignored when
                            # renaming, so proceed with the next class.
                            skip_remaining_lines = True
                        out_file.write(line)
                        continue

                # Skip virtual methods, consider only the direct methods defined
                # earlier in the file.
                if line.startswith("# virtual methods"):
                    skip_remaining_lines = True
                    out_file.write(line)
                    continue

                # Method declared in class.
                method_match = util.method_pattern.match(line)

                # Avoid constructors, native and abstract methods.
                if (
                    method_match
                    and "<init>" not in line
                    and "<clinit>" not in line
                    and " native " not in line
                    and " abstract " not in line
                ):
                    # Create lists with random parameters to be added to the method
                    # signature. Add 3 overloads for each method and for each overload
                    # use 4 random params.
                    for params in util.get_random_list_permutations(
                        random.sample(self.param_types, 4)
                    )[:3]:
                        new_param = "".join(params)
                        # Update parameter list and add void return type.
                        overloaded_signature = line.replace(
                            "({0}){1}".format(
                                method_match.group("method_param"),
                                method_match.group("method_return"),
                            ),
                            "({0}{1})V".format(
                                method_match.group("method_param"), new_param
                            ),
                        )
                        out_file.write(overloaded_signature)
                        out_file.write(overloaded_method_body)
                        new_methods_num += 1

                    # Print original method.
                    out_file.write(line)
                else:
                    out_file.write(line)

        return new_methods_num

    def add_method_overloads(
        self,
        smali_files: List[str],
        class_names_to_ignore: Set[str],
        max_methods_to_add: int,
        interactive: bool = False,
    ):
        overloaded_method_body = util.get_smali_method_overload()
        added_methods = 0

        for smali_file in util.show_list_progress(
            smali_files,
            interactive=interactive,
            description="Inserting method overloads in smali files",
        ):
            self.logger.debug(
                'Inserting method overloads in file "{0}"'.format(smali_file)
            )
            if added_methods < max_methods_to_add:
                added_methods += self.add_method_overloads_to_file(
                    smali_file, overloaded_method_body, class_names_to_ignore
                )
            else:
                break

        self.logger.debug("{0} new overloaded methods were added".format(added_methods))

    def obfuscate(self, obfuscation_info: Obfuscation):
        self.logger.info('Running "{0}" obfuscator'.format(self.__class__.__name__))

        try:
            # NOTE: only direct methods (methods that are by nature non-overridable,
            # namely private instance methods, constructors and static methods) will be
            # overloaded.

            android_class_names: Set[str] = set(util.get_android_class_names())

            # There is a method limit for dex files.
            max_methods_to_add = obfuscation_info.get_remaining_methods_per_obfuscator()

            if obfuscation_info.is_multidex():
                for index, dex_smali_files in enumerate(
                    util.show_list_progress(
                        obfuscation_info.get_multidex_smali_files(),
                        interactive=obfuscation_info.interactive,
                        unit="dex",
                        description="Processing multidex",
                    )
                ):
                    max_methods_to_add = (
                        obfuscation_info.get_remaining_methods_per_obfuscator()[index]
                    )
                    self.add_method_overloads(
                        dex_smali_files,
                        android_class_names,
                        max_methods_to_add,
                        obfuscation_info.interactive,
                    )
            else:
                self.add_method_overloads(
                    obfuscation_info.get_smali_files(),
                    android_class_names,
                    max_methods_to_add,
                    obfuscation_info.interactive,
                )

        except Exception as e:
            self.logger.error(
                'Error during execution of "{0}" obfuscator: {1}'.format(
                    self.__class__.__name__, e
                )
            )
            raise

        finally:
            obfuscation_info.used_obfuscators.append(self.__class__.__name__)

```

`src/obfuscapk/obfuscators/method_rename.obfuscator`:

```obfuscator
[Core]
Name = MethodRename
Module = method_rename

[Documentation]
Description = Rename methods
Version = 1.0

```

`src/obfuscapk/obfuscators/method_rename/__init__.py`:

```py
#!/usr/bin/env python3

from .method_rename import MethodRename

```

`src/obfuscapk/obfuscators/method_rename/method_rename.py`:

```py
#!/usr/bin/env python3

import logging
from typing import List, Set

from obfuscapk import obfuscator_category
from obfuscapk import util
from obfuscapk.obfuscation import Obfuscation


class MethodRename(obfuscator_category.IRenameObfuscator):
    def __init__(self):
        self.logger = logging.getLogger(
            "{0}.{1}".format(__name__, self.__class__.__name__)
        )
        super().__init__()

        self.ignore_package_names = []

    def rename_method(self, method_name: str) -> str:
        method_md5 = util.get_string_md5(method_name)
        return "m{0}".format(method_md5.lower()[:8])

    def rename_method_declarations(
        self,
        smali_files: List[str],
        class_names_to_ignore: Set[str],
        interactive: bool = False,
    ) -> Set[str]:
        renamed_methods: Set[str] = set()

        # Search for method definitions that can be renamed.
        for smali_file in util.show_list_progress(
            smali_files,
            interactive=interactive,
            description="Renaming method declarations",
        ):
            with util.inplace_edit_file(smali_file) as (in_file, out_file):
                skip_remaining_lines = False
                class_name = None
                for line in in_file:
                    if skip_remaining_lines:
                        out_file.write(line)
                        continue

                    if not class_name:
                        class_match = util.class_pattern.match(line)
                        # If this is an enum class, don't rename anything.
                        if " enum " in line:
                            skip_remaining_lines = True
                            out_file.write(line)
                            continue
                        elif class_match:
                            class_name = class_match.group("class_name")
                            if (
                                class_name in class_names_to_ignore
                                or class_name.startswith(
                                    tuple(self.ignore_package_names)
                                )
                            ):
                                # The methods of this class should be ignored when
                                # renaming, so proceed with the next class.
                                skip_remaining_lines = True
                            out_file.write(line)
                            continue

                    # Skip virtual methods, consider only the direct methods defined
                    # earlier in the file.
                    if line.startswith("# virtual methods"):
                        skip_remaining_lines = True
                        out_file.write(line)
                        continue

                    # Method declared in class.
                    method_match = util.method_pattern.match(line)

                    # Avoid constructors, native and abstract methods.
                    if (
                        method_match
                        and "<init>" not in line
                        and "<clinit>" not in line
                        and " native " not in line
                        and " abstract " not in line
                    ):
                        method = "{method_name}({method_param}){method_return}".format(
                            method_name=method_match.group("method_name"),
                            method_param=method_match.group("method_param"),
                            method_return=method_match.group("method_return"),
                        )
                        # Rename method declaration (invocations of this method will be
                        # renamed later).
                        method_name = method_match.group("method_name")
                        out_file.write(
                            line.replace(
                                "{0}(".format(method_name),
                                "{0}(".format(self.rename_method(method_name)),
                            )
                        )
                        # Direct methods cannot be overridden, so they can be called
                        # only by the same class that declares them.
                        renamed_methods.add(
                            "{class_name}->{method}".format(
                                class_name=class_name, method=method
                            )
                        )
                    else:
                        out_file.write(line)

        return renamed_methods

    def rename_method_invocations(
        self,
        smali_files: List[str],
        methods_to_rename: Set[str],
        interactive: bool = False,
    ):
        for smali_file in util.show_list_progress(
            smali_files,
            interactive=interactive,
            description="Renaming method invocations",
        ):
            with util.inplace_edit_file(smali_file) as (in_file, out_file):
                for line in in_file:
                    # Method invocation.
                    invoke_match = util.invoke_pattern.match(line)
                    if invoke_match:
                        method = (
                            "{class_name}->"
                            "{method_name}({method_param}){method_return}".format(
                                class_name=invoke_match.group("invoke_object"),
                                method_name=invoke_match.group("invoke_method"),
                                method_param=invoke_match.group("invoke_param"),
                                method_return=invoke_match.group("invoke_return"),
                            )
                        )
                        invoke_type = invoke_match.group("invoke_type")
                        # Rename the method invocation only if is direct or static (we
                        # are renaming only direct methods). The list of methods to
                        # rename already contains the class name of each method, since
                        # here we have a list of methods whose declarations were already
                        # renamed.
                        if (
                            "direct" in invoke_type or "static" in invoke_type
                        ) and method in methods_to_rename:
                            method_name = invoke_match.group("invoke_method")
                            out_file.write(
                                line.replace(
                                    "->{0}(".format(method_name),
                                    "->{0}(".format(self.rename_method(method_name)),
                                )
                            )
                        else:
                            out_file.write(line)
                    else:
                        out_file.write(line)

    def obfuscate(self, obfuscation_info: Obfuscation):
        self.logger.info('Running "{0}" obfuscator'.format(self.__class__.__name__))

        # Get user defined ignore package list.
        self.ignore_package_names = obfuscation_info.get_ignore_package_names()

        try:
            # NOTE: only direct methods (methods that are by nature non-overridable,
            # namely private instance methods, constructors and static methods) will be
            # renamed.

            android_class_names: Set[str] = set(util.get_android_class_names())

            renamed_methods: Set[str] = self.rename_method_declarations(
                obfuscation_info.get_smali_files(),
                android_class_names,
                obfuscation_info.interactive,
            )

            self.rename_method_invocations(
                obfuscation_info.get_smali_files(),
                renamed_methods,
                obfuscation_info.interactive,
            )

        except Exception as e:
            self.logger.error(
                'Error during execution of "{0}" obfuscator: {1}'.format(
                    self.__class__.__name__, e
                )
            )
            raise

        finally:
            obfuscation_info.used_obfuscators.append(self.__class__.__name__)

```

`src/obfuscapk/obfuscators/new_alignment.obfuscator`:

```obfuscator
[Core]
Name = NewAlignment
Module = new_alignment

[Documentation]
Description = Realign the application
Version = 1.0

```

`src/obfuscapk/obfuscators/new_alignment/__init__.py`:

```py
#!/usr/bin/env python3

from .new_alignment import NewAlignment

```

`src/obfuscapk/obfuscators/new_alignment/new_alignment.py`:

```py
#!/usr/bin/env python3

import logging

from obfuscapk import obfuscator_category
from obfuscapk.obfuscation import Obfuscation


class NewAlignment(obfuscator_category.ITrivialObfuscator):
    def __init__(self):
        self.logger = logging.getLogger(
            "{0}.{1}".format(__name__, self.__class__.__name__)
        )
        super().__init__()

    def obfuscate(self, obfuscation_info: Obfuscation):
        self.logger.info('Running "{0}" obfuscator'.format(self.__class__.__name__))

        try:
            obfuscation_info.align_obfuscated_apk()
        except Exception as e:
            self.logger.error(
                'Error during execution of "{0}" obfuscator: {1}'.format(
                    self.__class__.__name__, e
                )
            )
            raise

        finally:
            obfuscation_info.used_obfuscators.append(self.__class__.__name__)

```

`src/obfuscapk/obfuscators/new_signature.obfuscator`:

```obfuscator
[Core]
Name = NewSignature
Module = new_signature

[Documentation]
Description = Re-sign the application with a new custom signature
Version = 1.0

```

`src/obfuscapk/obfuscators/new_signature/__init__.py`:

```py
#!/usr/bin/env python3

from .new_signature import NewSignature

```

`src/obfuscapk/obfuscators/new_signature/new_signature.py`:

```py
#!/usr/bin/env python3

import logging

from obfuscapk import obfuscator_category
from obfuscapk.obfuscation import Obfuscation


class NewSignature(obfuscator_category.ITrivialObfuscator):
    def __init__(self):
        self.logger = logging.getLogger(
            "{0}.{1}".format(__name__, self.__class__.__name__)
        )
        super().__init__()

    def obfuscate(self, obfuscation_info: Obfuscation):
        self.logger.info('Running "{0}" obfuscator'.format(self.__class__.__name__))

        try:
            obfuscation_info.sign_obfuscated_apk()
        except Exception as e:
            self.logger.error(
                'Error during execution of "{0}" obfuscator: {1}'.format(
                    self.__class__.__name__, e
                )
            )
            raise

        finally:
            obfuscation_info.used_obfuscators.append(self.__class__.__name__)

```

`src/obfuscapk/obfuscators/nop.obfuscator`:

```obfuscator
[Core]
Name = Nop
Module = nop

[Documentation]
Description = Add multiple nop sequences between instructions
Version = 1.0

```

`src/obfuscapk/obfuscators/nop/__init__.py`:

```py
#!/usr/bin/env python3

from .nop import Nop

```

`src/obfuscapk/obfuscators/nop/example/after.smali`:

```smali
.class public Lcom/obfuscapk/demo/NopDemo;
.super Ljava/lang/Object;
.source "NopDemo.java"


# direct methods
.method public constructor <init>()V
    .locals 0

    .prologue
    .line 3
    invoke-direct {p0}, Ljava/lang/Object;-><init>()V

    return-void
    nop
.end method

.method public static getNopMessage(Ljava/lang/String;)Ljava/lang/String;
    .locals 5
    .param p0, "from"    # Ljava/lang/String;

    .prologue
    .line 6
    const-string/jumbo v2, "Nop message: "
    nop

    .line 7
    .local v2, "messageStart":Ljava/lang/String;
    const-string/jumbo v1, "sending a nop message from "
    nop
    nop
    nop
    nop
    nop

    .line 8
    .local v1, "messageBody":Ljava/lang/String;
    new-instance v3, Ljava/lang/StringBuilder;
    nop
    nop
    nop
    nop
    nop

    invoke-direct {v3}, Ljava/lang/StringBuilder;-><init>()V

    invoke-virtual {v3, v2}, Ljava/lang/StringBuilder;->append(Ljava/lang/String;)Ljava/lang/StringBuilder;

    move-result-object v3
    nop
    nop
    nop
    nop

    invoke-virtual {v3, v1}, Ljava/lang/StringBuilder;->append(Ljava/lang/String;)Ljava/lang/StringBuilder;

    move-result-object v3
    nop
    nop
    nop

    invoke-virtual {v3, p0}, Ljava/lang/StringBuilder;->append(Ljava/lang/String;)Ljava/lang/StringBuilder;

    move-result-object v3
    nop
    nop
    nop
    nop

    invoke-virtual {v3}, Ljava/lang/StringBuilder;->toString()Ljava/lang/String;

    move-result-object v0
    nop
    nop

    .line 9
    .local v0, "finalMessage":Ljava/lang/String;
    new-instance v3, Ljava/lang/StringBuilder;
    nop
    nop
    nop

    invoke-direct {v3}, Ljava/lang/StringBuilder;-><init>()V

    invoke-virtual {v3, v0}, Ljava/lang/StringBuilder;->append(Ljava/lang/String;)Ljava/lang/StringBuilder;

    move-result-object v3
    nop
    nop
    nop
    nop

    const-string/jumbo v4, "!"
    nop
    nop
    nop
    nop

    invoke-virtual {v3, v4}, Ljava/lang/StringBuilder;->append(Ljava/lang/String;)Ljava/lang/StringBuilder;

    move-result-object v3
    nop
    nop
    nop

    invoke-virtual {v3}, Ljava/lang/StringBuilder;->toString()Ljava/lang/String;

    move-result-object v0
    nop
    nop
    nop
    nop

    .line 10
    return-object v0
    nop
    nop
    nop
    nop
    nop
.end method

```

`src/obfuscapk/obfuscators/nop/example/before.smali`:

```smali
.class public Lcom/obfuscapk/demo/NopDemo;
.super Ljava/lang/Object;
.source "NopDemo.java"


# direct methods
.method public constructor <init>()V
    .locals 0

    .prologue
    .line 3
    invoke-direct {p0}, Ljava/lang/Object;-><init>()V

    return-void
.end method

.method public static getNopMessage(Ljava/lang/String;)Ljava/lang/String;
    .locals 5
    .param p0, "from"    # Ljava/lang/String;

    .prologue
    .line 6
    const-string/jumbo v2, "Nop message: "

    .line 7
    .local v2, "messageStart":Ljava/lang/String;
    const-string/jumbo v1, "sending a nop message from "

    .line 8
    .local v1, "messageBody":Ljava/lang/String;
    new-instance v3, Ljava/lang/StringBuilder;

    invoke-direct {v3}, Ljava/lang/StringBuilder;-><init>()V

    invoke-virtual {v3, v2}, Ljava/lang/StringBuilder;->append(Ljava/lang/String;)Ljava/lang/StringBuilder;

    move-result-object v3

    invoke-virtual {v3, v1}, Ljava/lang/StringBuilder;->append(Ljava/lang/String;)Ljava/lang/StringBuilder;

    move-result-object v3

    invoke-virtual {v3, p0}, Ljava/lang/StringBuilder;->append(Ljava/lang/String;)Ljava/lang/StringBuilder;

    move-result-object v3

    invoke-virtual {v3}, Ljava/lang/StringBuilder;->toString()Ljava/lang/String;

    move-result-object v0

    .line 9
    .local v0, "finalMessage":Ljava/lang/String;
    new-instance v3, Ljava/lang/StringBuilder;

    invoke-direct {v3}, Ljava/lang/StringBuilder;-><init>()V

    invoke-virtual {v3, v0}, Ljava/lang/StringBuilder;->append(Ljava/lang/String;)Ljava/lang/StringBuilder;

    move-result-object v3

    const-string/jumbo v4, "!"

    invoke-virtual {v3, v4}, Ljava/lang/StringBuilder;->append(Ljava/lang/String;)Ljava/lang/StringBuilder;

    move-result-object v3

    invoke-virtual {v3}, Ljava/lang/StringBuilder;->toString()Ljava/lang/String;

    move-result-object v0

    .line 10
    return-object v0
.end method

```

`src/obfuscapk/obfuscators/nop/example/original.java`:

```java
package com.obfuscapk.demo;

public class NopDemo {
    public static String getNopMessage(String from) {
        // Just some random instructions...
        String messageStart = "Nop message: ";
        String messageBody = "sending a nop message from ";
        String finalMessage = messageStart + messageBody + from;
        finalMessage += "!";
        return finalMessage;
    }
}

```

`src/obfuscapk/obfuscators/nop/nop.py`:

```py
#!/usr/bin/env python3

import logging
import re

from obfuscapk import obfuscator_category
from obfuscapk import util
from obfuscapk.obfuscation import Obfuscation


class Nop(obfuscator_category.ICodeObfuscator):
    def __init__(self):
        self.logger = logging.getLogger(
            "{0}.{1}".format(__name__, self.__class__.__name__)
        )
        super().__init__()

    def obfuscate(self, obfuscation_info: Obfuscation):
        self.logger.info('Running "{0}" obfuscator'.format(self.__class__.__name__))

        try:
            op_codes = util.get_nop_valid_op_codes()
            pattern = re.compile(r"\s+(?P<op_code>\S+)")

            for smali_file in util.show_list_progress(
                obfuscation_info.get_smali_files(),
                interactive=obfuscation_info.interactive,
                description='Inserting "nop" instructions in smali files',
            ):
                self.logger.debug(
                    'Inserting "nop" instructions in file "{0}"'.format(smali_file)
                )
                with util.inplace_edit_file(smali_file) as (in_file, out_file):
                    for line in in_file:
                        # Print original instruction.
                        out_file.write(line)

                        # Check if this line contains an op code at the beginning
                        # of the string.
                        match = pattern.match(line)
                        if match:
                            op_code = match.group("op_code")
                            # If this is a valid op code, insert some nop instructions
                            # after it.
                            if op_code in op_codes:
                                nop_count = util.get_random_int(1, 5)
                                out_file.write("\tnop\n" * nop_count)

        except Exception as e:
            self.logger.error(
                'Error during execution of "{0}" obfuscator: {1}'.format(
                    self.__class__.__name__, e
                )
            )
            raise

        finally:
            obfuscation_info.used_obfuscators.append(self.__class__.__name__)

```

`src/obfuscapk/obfuscators/random_manifest.obfuscator`:

```obfuscator
[Core]
Name = RandomManifest
Module = random_manifest

[Documentation]
Description = Randomly reorder entries in the manifest file
Version = 1.0

```

`src/obfuscapk/obfuscators/random_manifest/__init__.py`:

```py
#!/usr/bin/env python3

from .random_manifest import RandomManifest

```

`src/obfuscapk/obfuscators/random_manifest/example/after.xml`:

```xml
<manifest xmlns:obfuscation="http://schemas.android.com/apk/res/android" obfuscation:compileSdkVersion="29" obfuscation:compileSdkVersionCodename="10" package="com.obfuscapk.demo" platformBuildVersionCode="29" platformBuildVersionName="10">
    <uses-permission obfuscation:name="android.permission.ACCESS_COARSE_LOCATION" />
    <uses-permission obfuscation:name="android.permission.VIBRATE" />
    <uses-permission obfuscation:name="android.permission.ACCESS_NETWORK_STATE" />
    <uses-feature obfuscation:name="android.hardware.location" />
    <uses-permission obfuscation:name="android.permission.INTERNET" />
    <application obfuscation:allowBackup="true" obfuscation:debuggable="true" obfuscation:extractNativeLibs="false" obfuscation:icon="@mipmap/ic_launcher" obfuscation:label="@string/app_name" obfuscation:roundIcon="@mipmap/ic_launcher_round" obfuscation:theme="@style/AppTheme">
        <activity obfuscation:name="com.obfuscapk.demo.MainActivity">
            <intent-filter>
                <category obfuscation:name="android.intent.category.LAUNCHER" />
                <action obfuscation:name="android.intent.action.MAIN" />
            </intent-filter>
        </activity>
    </application>
</manifest>

```

`src/obfuscapk/obfuscators/random_manifest/example/before.xml`:

```xml
<?xml version="1.0" encoding="utf-8" standalone="no"?><manifest xmlns:android="http://schemas.android.com/apk/res/android" android:compileSdkVersion="29" android:compileSdkVersionCodename="10" package="com.obfuscapk.demo" platformBuildVersionCode="29" platformBuildVersionName="10">
    <uses-permission android:name="android.permission.INTERNET"/>
    <uses-permission android:name="android.permission.VIBRATE"/>
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION"/>
    <uses-feature android:name="android.hardware.location"/>
    <application android:allowBackup="true" android:debuggable="true" android:extractNativeLibs="false" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:roundIcon="@mipmap/ic_launcher_round" android:theme="@style/AppTheme">
        <activity android:name="com.obfuscapk.demo.MainActivity">
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>
    </application>
</manifest>

```

`src/obfuscapk/obfuscators/random_manifest/random_manifest.py`:

```py
#!/usr/bin/env python3

import logging
import random
import xml.etree.cElementTree as Xml
from xml.etree.cElementTree import Element

from obfuscapk import obfuscator_category
from obfuscapk.obfuscation import Obfuscation


class RandomManifest(obfuscator_category.IResourcesObfuscator):
    def __init__(self):
        self.logger = logging.getLogger(
            "{0}.{1}".format(__name__, self.__class__.__name__)
        )
        super().__init__()

    # http://effbot.org/zone/element-lib.htm#prettyprint
    def indent_xml(self, element: Element, level=0):
        indentation = "\n" + level * "    "
        if len(element):
            if not element.text or not element.text.strip():
                element.text = indentation + "    "
            if not element.tail or not element.tail.strip():
                element.tail = indentation
            for element in element:
                self.indent_xml(element, level + 1)
            if not element.tail or not element.tail.strip():
                element.tail = indentation
        else:
            if level and (not element.tail or not element.tail.strip()):
                element.tail = indentation

    # https://stackoverflow.com/a/27550126/5268548
    def xml_elements_equal(self, one: Element, other: Element) -> bool:
        if type(one) != type(other):
            return False
        if one.tag != other.tag:
            return False

        if one.text and other.text:
            if one.text.strip() != other.text.strip():
                return False
        elif one.text != other.text:
            return False

        if one.tail and other.tail:
            if one.tail.strip() != other.tail.strip():
                return False
        elif one.tail != other.tail:
            return False

        if one.attrib != other.attrib:
            return False
        if len(one) != len(other):
            return False

        return all(self.xml_elements_equal(e1, e2) for e1, e2 in zip(one, other))

    def remove_xml_duplicates(self, root: Element):
        # Recursively eliminate duplicates starting from children nodes.
        for element in root:
            self.remove_xml_duplicates(element)

        non_duplicates = []
        elements_to_remove = []

        # Find duplicate nodes which have the same parent node.
        for element in root:
            if any(self.xml_elements_equal(element, nd) for nd in non_duplicates):
                elements_to_remove.append(element)
            else:
                non_duplicates.append(element)

        # Remove existing duplicates at this level.
        for element_to_remove in elements_to_remove:
            root.remove(element_to_remove)

    def scramble_xml_element(self, element: Element):
        children = []

        # Get the children of the current element.
        for child in element:
            children.append(child)

        # Remove the children from the current element (they will be added later
        # in a different order).
        for child in children:
            element.remove(child)

        # Shuffle the order of the children of the element and add them again to
        # the element. Then repeat the scramble operation recursively.
        random.shuffle(children)
        for child in children:
            element.append(child)
            self.scramble_xml_element(child)

    def obfuscate(self, obfuscation_info: Obfuscation):
        self.logger.info('Running "{0}" obfuscator'.format(self.__class__.__name__))

        try:
            # Change default namespace.
            Xml.register_namespace(
                "obfuscation", "http://schemas.android.com/apk/res/android"
            )

            xml_parser = Xml.XMLParser(encoding="utf-8")
            manifest_tree = Xml.parse(
                obfuscation_info.get_manifest_file(), parser=xml_parser
            )
            manifest_root = manifest_tree.getroot()
            self.remove_xml_duplicates(manifest_root)
            self.scramble_xml_element(manifest_root)
            self.indent_xml(manifest_root)

            # Write the changes into the manifest file.
            manifest_tree.write(obfuscation_info.get_manifest_file(), encoding="utf-8")

        except Exception as e:
            self.logger.error(
                'Error during execution of "{0}" obfuscator: {1}'.format(
                    self.__class__.__name__, e
                )
            )
            raise

        finally:
            obfuscation_info.used_obfuscators.append(self.__class__.__name__)

```

`src/obfuscapk/obfuscators/rebuild.obfuscator`:

```obfuscator
[Core]
Name = Rebuild
Module = rebuild

[Documentation]
Description = Rebuild the application
Version = 1.0

```

`src/obfuscapk/obfuscators/rebuild/__init__.py`:

```py
#!/usr/bin/env python3

from .rebuild import Rebuild

```

`src/obfuscapk/obfuscators/rebuild/rebuild.py`:

```py
#!/usr/bin/env python3

import logging

from obfuscapk import obfuscator_category
from obfuscapk.obfuscation import Obfuscation


class Rebuild(obfuscator_category.ITrivialObfuscator):
    def __init__(self):
        self.logger = logging.getLogger(
            "{0}.{1}".format(__name__, self.__class__.__name__)
        )
        super().__init__()

    def obfuscate(self, obfuscation_info: Obfuscation):
        self.logger.info('Running "{0}" obfuscator'.format(self.__class__.__name__))

        try:
            obfuscation_info.build_obfuscated_apk()
        except Exception as e:
            self.logger.error(
                'Error during execution of "{0}" obfuscator: {1}'.format(
                    self.__class__.__name__, e
                )
            )
            raise

        finally:
            obfuscation_info.used_obfuscators.append(self.__class__.__name__)

```

`src/obfuscapk/obfuscators/reflection.obfuscator`:

```obfuscator
[Core]
Name = Reflection
Module = reflection

[Documentation]
Description = Apply reflection
Version = 1.0

```

`src/obfuscapk/obfuscators/reflection/__init__.py`:

```py
#!/usr/bin/env python3

from .reflection import Reflection

```

`src/obfuscapk/obfuscators/reflection/reflection.py`:

```py
#!/usr/bin/env python3

import logging
import os
import re
from typing import List, Set

from obfuscapk import obfuscator_category
from obfuscapk import util
from obfuscapk.obfuscation import Obfuscation


class Reflection(obfuscator_category.ICodeObfuscator):
    def __init__(self):
        self.logger = logging.getLogger(
            "{0}.{1}".format(__name__, self.__class__.__name__)
        )
        super().__init__()

        self.android_class_names: Set[str] = set(util.get_android_class_names())

        self.methods_with_reflection: int = 0

        # Will be populated before running the reflection obfuscator.
        self.class_name_to_smali_file: dict = {}

        # Keep track of the length of the added instructions for reflection obfuscator,
        # since there is a limit for the number of maximum instructions in a try catch
        # block. Not all the instructions have the same length.
        self.obfuscator_instructions_length: int = 0
        self.obfuscator_instructions_limit: int = 60000

        self.primitive_types: Set[str] = {"I", "Z", "B", "S", "J", "F", "D", "C"}

        self.type_dict = {
            "I": "Ljava/lang/Integer;",
            "Z": "Ljava/lang/Boolean;",
            "B": "Ljava/lang/Byte;",
            "S": "Ljava/lang/Short;",
            "J": "Ljava/lang/Long;",
            "F": "Ljava/lang/Float;",
            "D": "Ljava/lang/Double;",
            "C": "Ljava/lang/Character;",
        }

        self.sget_dict = {
            "I": "Ljava/lang/Integer;->TYPE:Ljava/lang/Class;",
            "Z": "Ljava/lang/Boolean;->TYPE:Ljava/lang/Class;",
            "B": "Ljava/lang/Byte;->TYPE:Ljava/lang/Class;",
            "S": "Ljava/lang/Short;->TYPE:Ljava/lang/Class;",
            "J": "Ljava/lang/Long;->TYPE:Ljava/lang/Class;",
            "F": "Ljava/lang/Float;->TYPE:Ljava/lang/Class;",
            "D": "Ljava/lang/Double;->TYPE:Ljava/lang/Class;",
            "C": "Ljava/lang/Character;->TYPE:Ljava/lang/Class;",
        }

        self.cast_dict = {
            "I": "Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;",
            "Z": "Ljava/lang/Boolean;->valueOf(Z)Ljava/lang/Boolean;",
            "B": "Ljava/lang/Byte;->valueOf(B)Ljava/lang/Byte;",
            "S": "Ljava/lang/Short;->valueOf(S)Ljava/lang/Short;",
            "J": "Ljava/lang/Long;->valueOf(J)Ljava/lang/Long;",
            "F": "Ljava/lang/Float;->valueOf(F)Ljava/lang/Float;",
            "D": "Ljava/lang/Double;->valueOf(D)Ljava/lang/Double;",
            "C": "Ljava/lang/Character;->valueOf(C)Ljava/lang/Character;",
        }

        self.reverse_cast_dict = {
            "I": "Ljava/lang/Integer;->intValue()I",
            "Z": "Ljava/lang/Boolean;->booleanValue()Z",
            "B": "Ljava/lang/Byte;->byteValue()B",
            "S": "Ljava/lang/Short;->shortValue()S",
            "J": "Ljava/lang/Long;->longValue()J",
            "F": "Ljava/lang/Float;->floatValue()F",
            "D": "Ljava/lang/Double;->doubleValue()D",
            "C": "Ljava/lang/Character;->charValue()C",
        }

    def class_is_public_and_declared_in_smali(self, class_name: str) -> bool:
        smali_file: str = self.class_name_to_smali_file.get(class_name, None)

        # The smali of this class is not present (this is probably a system class).
        if not smali_file:
            return False

        with open(smali_file, "r", encoding="utf-8") as current_file:
            for line in current_file:
                # Check if this is a public non abstract class.
                class_match = util.class_pattern.match(line)
                if class_match:
                    if " public " in line and " abstract " not in line:
                        return True
                    else:
                        return False

    def method_is_all_public(
        self, class_name: str, method_signature: str, param_string: str
    ) -> bool:
        if not self.class_is_public_and_declared_in_smali(class_name):
            return False

        smali_file: str = self.class_name_to_smali_file[class_name]
        with open(smali_file, "r", encoding="utf-8") as current_file:
            for line in current_file:
                if " public " in line:
                    method_match = util.method_pattern.match(line)
                    if method_match:
                        signature = (
                            "{method_name}({method_param})"
                            "{method_return}".format(
                                method_name=method_match.group("method_name"),
                                method_param=method_match.group("method_param"),
                                method_return=method_match.group("method_return"),
                            )
                        )
                        if signature == method_signature:
                            # Public method declared in public class, let's check if all
                            # its parameters are public.
                            for param in self.split_method_params(param_string):
                                # System classes that are public.
                                if (
                                    param in self.primitive_types
                                    or param in self.android_class_names
                                ):
                                    continue

                                # The class of this parameter is not present in the
                                # smali files or is not public.
                                if not self.class_is_public_and_declared_in_smali(
                                    param
                                ):
                                    return False

                            return True

        return False

    def split_method_params(self, param_string: str) -> List[str]:
        params: List[str] = []

        possible_classes = param_string.split(";")
        for possible_class in possible_classes:
            # Make sure the parameter list is not empty.
            if possible_class:
                if possible_class.startswith("L"):
                    # Class.
                    params.append("{0};".format(possible_class))
                elif possible_class.startswith("["):
                    # Array + other optional parameters (e.g. [ILjava/lang/Object).
                    for string_position in range(1, len(possible_class)):
                        if possible_class[string_position] == "[":
                            # Multi-dimensional array, proceed with the next char.
                            continue
                        elif possible_class[string_position] == "L":
                            # Class array, no need to proceed with the next char.
                            params.append("{0};".format(possible_class))
                            break
                        else:
                            # Primitive type array, add it to the list and proceed with
                            # the rest of the string
                            params.append(possible_class[: string_position + 1])
                            params.extend(
                                self.split_method_params(
                                    possible_class[string_position + 1 :]
                                )
                            )
                            break
                elif possible_class[0] in self.primitive_types:
                    # Primitive type + other optional parameters
                    # (e.g. ILjava/lang/Object).
                    params.append(possible_class[0])
                    params.extend(self.split_method_params(possible_class[1:]))

        return params

    def count_needed_registers(self, params: List[str]) -> int:
        needed_registers: int = 0

        for param in params:
            # Long and double variables need 2 registers.
            if param == "J" or param == "D":
                needed_registers += 2
            else:
                needed_registers += 1

        return needed_registers

    def add_smali_reflection_code(
        self, class_name: str, method_name: str, param_string: str
    ) -> str:
        params = self.split_method_params(param_string)

        smali_code = "\n\tconst/4 v1, {param_num:#x}\n\n".format(param_num=len(params))
        self.obfuscator_instructions_length += 1

        if len(params) > 0:
            smali_code += "\tnew-array v1, v1, [Ljava/lang/Class;\n\n"
            self.obfuscator_instructions_length += 2

        for param_index, param in enumerate(params):
            smali_code += "\tconst/4 v2, {param_num:#x}\n\n".format(
                param_num=param_index
            )
            self.obfuscator_instructions_length += 1

            class_param = self.sget_dict.get(param, None)
            if class_param:
                smali_code += "\tsget-object v3, {param}\n\n".format(param=class_param)
                self.obfuscator_instructions_length += 2
            else:
                smali_code += "\tconst-class v3, {param}\n\n".format(param=param)
                self.obfuscator_instructions_length += 2

            smali_code += "\taput-object v3, v1, v2\n\n"
            self.obfuscator_instructions_length += 2

        smali_code += (
            "\tconst-class v2, {class_name}\n\n"
            '\tconst-string v3, "{method_name}"\n\n'.format(
                class_name=class_name, method_name=method_name
            )
        )
        self.obfuscator_instructions_length += 4

        smali_code += (
            "\tinvoke-virtual {v2, v3, v1}, Ljava/lang/Class;->"
            "getDeclaredMethod(Ljava/lang/String;[Ljava/lang/Class;)"
            "Ljava/lang/reflect/Method;\n\n"
        )
        self.obfuscator_instructions_length += 3

        smali_code += (
            "\tmove-result-object v1\n\n"
            "\tsget-object v2, Lcom/apireflectionmanager/ApiReflection;->"
            "obfuscatedMethods:Ljava/util/List;\n\n"
        )
        self.obfuscator_instructions_length += 3

        smali_code += (
            "\tinvoke-interface {v2, v1}, Ljava/util/List;->add(Ljava/lang/Object;)Z\n"
        )
        self.obfuscator_instructions_length += 3

        return smali_code

    def create_reflection_method(
        self,
        num_of_methods: int,
        local_count: int,
        is_virtual_method: bool,
        invoke_registers: str,
        invoke_parameters: str,
    ):
        # Split method passed registers (if the method has no registers there is an
        # empty line that has to be removed, that's why strip() is used).
        invoke_registers = [
            register.strip()
            for register in invoke_registers.split(", ")
            if register.strip()
        ]

        params = self.split_method_params(invoke_parameters)

        param_to_register: List[
            List[str]
        ] = []  # list[i][0] = i-th param, list[i][1] = [i-th param register(s)]

        if is_virtual_method:
            # If this is a virtual method, the first register is the object instance
            # and not a parameter.
            register_index = 1
            for param in params:
                # Long and double variables need 2 registers.
                if param == "J" or param == "D":
                    param_to_register.append(
                        [param, invoke_registers[register_index : register_index + 2]]
                    )
                    register_index += 2
                else:
                    param_to_register.append(
                        [param, [invoke_registers[register_index]]]
                    )
                    register_index += 1
        else:
            # This is a static method, so we don't need a reference to the object
            # instance. If this is a virtual method, the first register is the object
            # instance and not a parameter.
            register_index = 0
            for param in params:
                # Long and double variables need 2 registers.
                if param == "J" or param == "D":
                    param_to_register.append(
                        [param, invoke_registers[register_index : register_index + 2]]
                    )
                    register_index += 2
                else:
                    param_to_register.append(
                        [param, [invoke_registers[register_index]]]
                    )
                    register_index += 1

        smali_code = "\tconst/4 #reg1#, {register_num:#x}\n\n".format(
            register_num=len(params)
        )

        if len(params) > 0:
            smali_code += "\tnew-array #reg1#, #reg1#, [Ljava/lang/Object;\n\n"
            for param_index, param_and_register in enumerate(param_to_register):
                # param_and_register[0] = parameter type
                # param_and_register[1] = [register(s) holding the passed parameter(s)]
                cast_primitive_to_class = self.cast_dict.get(
                    param_and_register[0], None
                )

                if cast_primitive_to_class:
                    if len(param_and_register[1]) > 1:
                        # 2 register parameter.
                        smali_code += (
                            "\tinvoke-static {{{register_pair}}}, {cast}\n\n"
                            "\tmove-result-object #reg2#\n\n".format(
                                register_pair=", ".join(param_and_register[1]),
                                cast=cast_primitive_to_class,
                            )
                        )
                    else:
                        smali_code += (
                            "\tinvoke-static {{{register}}}, {cast}\n\n"
                            "\tmove-result-object #reg2#\n\n".format(
                                register=param_and_register[1][0],
                                cast=cast_primitive_to_class,
                            )
                        )

                    smali_code += (
                        "\tconst/4 #reg4#, {param_index:#x}\n\n"
                        "\taput-object #reg2#, #reg1#, #reg4#\n\n".format(
                            param_index=param_index
                        )
                    )

                else:
                    smali_code += (
                        "\tconst/4 #reg3#, {param_index:#x}\n\n"
                        "\taput-object {register}, #reg1#, #reg3#\n\n".format(
                            param_index=param_index, register=param_and_register[1][0]
                        )
                    )

        smali_code += "\tconst/16 #reg3#, {method_num:#x}\n\n".format(
            method_num=num_of_methods
        )

        if is_virtual_method:
            smali_code += (
                "\tinvoke-static {{#reg3#, {obj_instance}, #reg1#}}, "
                "Lcom/apireflectionmanager/ApiReflection;->"
                "obfuscate(ILjava/lang/Object;[Ljava/lang/Object;)"
                "Ljava/lang/Object;\n".format(obj_instance=invoke_registers[0])
            )
        else:
            smali_code += "\tconst/4 #reg4#, 0x0\n\n"
            smali_code += (
                "\tinvoke-static {#reg3#, #reg4#, #reg1#}, "
                "Lcom/apireflectionmanager/ApiReflection;->"
                "obfuscate(ILjava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;\n"
            )

        for index in range(0, 4):
            smali_code = smali_code.replace(
                "#reg{0}#".format(index + 1), "v{0}".format(local_count + index)
            )

        return smali_code

    def obfuscate(self, obfuscation_info: Obfuscation):
        self.logger.info('Running "{0}" obfuscator'.format(self.__class__.__name__))

        try:
            for smali_file in util.show_list_progress(
                obfuscation_info.get_smali_files(),
                interactive=obfuscation_info.interactive,
                description="Class name to smali file mapping",
            ):
                with open(smali_file, "r", encoding="utf-8") as current_file:
                    class_name = None
                    for line in current_file:
                        if not class_name:
                            # Every smali file contains a class.
                            class_match = util.class_pattern.match(line)
                            if class_match:
                                self.class_name_to_smali_file[
                                    class_match.group("class_name")
                                ] = smali_file
                                break

            obfuscator_smali_code: str = ""

            move_result_pattern = re.compile(
                r"\s+move-result.*?\s(?P<register>[vp0-9]+)"
            )

            for smali_file in util.show_list_progress(
                obfuscation_info.get_smali_files(),
                interactive=obfuscation_info.interactive,
                description="Obfuscating using reflection",
            ):
                self.logger.debug(
                    'Obfuscating using reflection in file "{0}"'.format(smali_file)
                )

                # There is no space for further reflection instructions.
                if (
                    self.obfuscator_instructions_length
                    >= self.obfuscator_instructions_limit
                ):
                    break

                with open(smali_file, "r", encoding="utf-8") as current_file:
                    lines = current_file.readlines()

                # Line numbers where a method is declared.
                method_index: List[int] = []

                # For each method in method_index, True if there are enough registers
                # to perform some operations by using reflection, False otherwise.
                method_is_reflectable: List[bool] = []

                # The number of local registers of each method in method_index.
                method_local_count: List[int] = []

                # Find the method declarations in this smali file.
                for line_number, line in enumerate(lines):
                    method_match = util.method_pattern.match(line)
                    if method_match:
                        method_index.append(line_number)

                        param_count = self.count_needed_registers(
                            self.split_method_params(method_match.group("method_param"))
                        )

                        # Save the number of local registers of this method.
                        local_count = 16
                        local_match = util.locals_pattern.match(lines[line_number + 1])
                        if local_match:
                            local_count = int(local_match.group("local_count"))
                            method_local_count.append(local_count)
                        else:
                            # For some reason the locals declaration was not found where
                            # it should be, so assume the local registers are all used.
                            method_local_count.append(local_count)

                        # If there are enough registers available we can perform some
                        # reflection operations.
                        if param_count + local_count <= 11:
                            method_is_reflectable.append(True)
                        else:
                            method_is_reflectable.append(False)

                # Look for method invocations inside the methods declared in this
                # smali file, and change normal invocations with invocations through
                # reflection.
                for method_number, index in enumerate(method_index):
                    # If there are enough registers for reflection operations, look for
                    # method invocations inside each method's body.
                    if method_is_reflectable[method_number]:
                        current_line_number = index
                        while not lines[current_line_number].startswith(".end method"):
                            # There is no space for further reflection instructions.
                            if (
                                self.obfuscator_instructions_length
                                >= self.obfuscator_instructions_limit
                            ):
                                break

                            current_line_number += 1

                            invoke_match = util.invoke_pattern.match(
                                lines[current_line_number]
                            )

                            if (
                                invoke_match
                                and "<init>" not in lines[current_line_number]
                            ):
                                # The method belongs to an Android class or is
                                # invoked on an array.
                                if invoke_match.group(
                                    "invoke_object"
                                ) in self.android_class_names or invoke_match.group(
                                    "invoke_object"
                                ).startswith(
                                    "["
                                ):
                                    continue

                                method_signature = (
                                    "{method_name}({method_param})"
                                    "{method_return}".format(
                                        method_name=invoke_match.group("invoke_method"),
                                        method_param=invoke_match.group("invoke_param"),
                                        method_return=invoke_match.group(
                                            "invoke_return"
                                        ),
                                    )
                                )

                                # The method to reflect has to be public, has to be
                                # declared in a public class and all its parameters
                                # have to be public.
                                if not self.method_is_all_public(
                                    invoke_match.group("invoke_object"),
                                    method_signature,
                                    invoke_match.group("invoke_param"),
                                ):
                                    continue

                                if (
                                    invoke_match.group("invoke_type")
                                    == "invoke-virtual"
                                ):
                                    tmp_is_virtual = True
                                elif (
                                    invoke_match.group("invoke_type") == "invoke-static"
                                ):
                                    tmp_is_virtual = False
                                else:
                                    continue

                                tmp_register = invoke_match.group("invoke_pass")
                                tmp_class_name = invoke_match.group("invoke_object")
                                tmp_method = invoke_match.group("invoke_method")
                                tmp_param = invoke_match.group("invoke_param")
                                tmp_return_type = invoke_match.group("invoke_return")

                                # Check if the method invocation result is used in
                                # the following lines.
                                for move_result_index in range(
                                    current_line_number + 1,
                                    min(current_line_number + 10, len(lines) - 1),
                                ):
                                    if "invoke-" in lines[move_result_index]:
                                        # New method invocation, the previous method
                                        # result is not used.
                                        break

                                    move_result_match = move_result_pattern.match(
                                        lines[move_result_index]
                                    )
                                    if move_result_match:
                                        tmp_result_register = move_result_match.group(
                                            "register"
                                        )

                                        # Fix the move-result instruction after the
                                        # method invocation.
                                        new_move_result = ""
                                        if tmp_return_type in self.primitive_types:
                                            new_move_result += (
                                                "\tmove-result-object "
                                                "{result_register}\n\n"
                                                "\tcheck-cast {result_register}, "
                                                "{result_class}\n\n".format(
                                                    result_register=tmp_result_register,
                                                    result_class=self.type_dict[
                                                        tmp_return_type
                                                    ],
                                                )
                                            )

                                            new_move_result += (
                                                "\tinvoke-virtual "
                                                "{{{result_register}}}, {cast}\n\n".format(
                                                    result_register=tmp_result_register,
                                                    cast=self.reverse_cast_dict[
                                                        tmp_return_type
                                                    ],
                                                )
                                            )

                                            if (
                                                tmp_return_type == "J"
                                                or tmp_return_type == "D"
                                            ):
                                                new_move_result += (
                                                    "\tmove-result-wide "
                                                    "{result_register}\n".format(
                                                        result_register=tmp_result_register
                                                    )
                                                )
                                            else:
                                                new_move_result += (
                                                    "\tmove-result "
                                                    "{result_register}\n".format(
                                                        result_register=tmp_result_register
                                                    )
                                                )

                                        else:
                                            new_move_result += (
                                                "\tmove-result-object "
                                                "{result_register}\n\n"
                                                "\tcheck-cast {result_register}, "
                                                "{return_type}\n".format(
                                                    result_register=tmp_result_register,
                                                    return_type=tmp_return_type,
                                                )
                                            )

                                        lines[move_result_index] = new_move_result

                                # Add the original method to the list of methods
                                # using reflection.
                                obfuscator_smali_code += self.add_smali_reflection_code(
                                    tmp_class_name, tmp_method, tmp_param
                                )

                                # Change the original code with code using reflection.
                                lines[
                                    current_line_number
                                ] = self.create_reflection_method(
                                    self.methods_with_reflection,
                                    method_local_count[method_number],
                                    tmp_is_virtual,
                                    tmp_register,
                                    tmp_param,
                                )

                                self.methods_with_reflection += 1

                                # Add the registers needed for performing reflection.
                                lines[index + 1] = "\t.locals {0}\n".format(
                                    method_local_count[method_number] + 4
                                )

                with open(smali_file, "w", encoding="utf-8") as current_file:
                    current_file.writelines(lines)

            # Add to the app the code needed for the reflection obfuscator. The code
            # can be put in any smali directory, since it will be moved to the correct
            # directory when rebuilding the application.
            destination_dir = os.path.dirname(obfuscation_info.get_smali_files()[0])
            destination_file = os.path.join(destination_dir, "ApiReflection.smali")
            with open(destination_file, "w", encoding="utf-8") as api_reflection_smali:
                reflection_code = util.get_api_reflection_smali_code().replace(
                    "#!code_to_replace!#", obfuscator_smali_code
                )
                api_reflection_smali.write(reflection_code)

        except Exception as e:
            self.logger.error(
                'Error during execution of "{0}" obfuscator: {1}'.format(
                    self.__class__.__name__, e
                )
            )
            raise

        finally:
            obfuscation_info.used_obfuscators.append(self.__class__.__name__)

```

`src/obfuscapk/obfuscators/reorder.obfuscator`:

```obfuscator
[Core]
Name = Reorder
Module = reorder

[Documentation]
Description = Reorder code by shuffling code blocks
Version = 1.0

```

`src/obfuscapk/obfuscators/reorder/__init__.py`:

```py
#!/usr/bin/env python3

from .reorder import Reorder

```

`src/obfuscapk/obfuscators/reorder/example/after.smali`:

```smali
.class public Lcom/obfuscapk/demo/OrderDemo;
.super Ljava/lang/Object;
.source "OrderDemo.java"


# direct methods
.method public constructor <init>()V
    .locals 0

    .prologue
    .line 6
    goto/32 :l_tQCKFqpiHRBRQciF_0

    nop

    :l_oshIgQxSuXqmHWGJ_1
    return-void
    :l_tQCKFqpiHRBRQciF_0
    invoke-direct {p0}, Ljava/lang/Object;-><init>()V

    goto/32 :l_oshIgQxSuXqmHWGJ_1

    nop

.end method

.method public static getGotoMessage()Ljava/lang/String;
    .locals 5

    .prologue
    .line 9
    goto/32 :l_eBkbmfkmuZTYwAgJ_0

    nop

    :l_QMdQTrZBOlokaNUc_10
    return-object v4
    :l_kOqAKmRqIzEtMrpu_2
    const-string/jumbo v0, "message1"

    .line 12
    .local v0, "message1":Ljava/lang/String;
    goto/32 :l_xReCXfmtkdGhgSBm_3

    nop

    :l_sDhILXmJzXsfcXUr_8
    invoke-virtual {v3}, Ljava/util/ArrayList;->toArray()[Ljava/lang/Object;

    move-result-object v4

    goto/32 :l_hxqpYFdVKuYdybMT_9

    nop

    :l_CvcmNMlasjdVLEnV_5
    invoke-virtual {v3, v1}, Ljava/util/ArrayList;->add(Ljava/lang/Object;)Z

    .line 17
    goto/32 :l_dbUktrjcDOLMeNVZ_6

    nop

    :l_KvFcAHhVAtjRMgfv_1
    invoke-direct {v3}, Ljava/util/ArrayList;-><init>()V

    .line 11
    .local v3, "messages":Ljava/util/ArrayList;, "Ljava/util/ArrayList<Ljava/lang/String;>;"
    goto/32 :l_kOqAKmRqIzEtMrpu_2

    nop

    :l_xReCXfmtkdGhgSBm_3
    invoke-virtual {v3, v0}, Ljava/util/ArrayList;->add(Ljava/lang/Object;)Z

    .line 14
    goto/32 :l_ILLEMEdMoEmHnmxs_4

    nop

    :l_eBkbmfkmuZTYwAgJ_0
    new-instance v3, Ljava/util/ArrayList;

    goto/32 :l_KvFcAHhVAtjRMgfv_1

    nop

    :l_dbUktrjcDOLMeNVZ_6
    const-string/jumbo v2, "message3"

    .line 18
    .local v2, "message3":Ljava/lang/String;
    goto/32 :l_CVAqRcEaIIREDEwX_7

    nop

    :l_hxqpYFdVKuYdybMT_9
    invoke-static {v4}, Ljava/util/Arrays;->toString([Ljava/lang/Object;)Ljava/lang/String;

    move-result-object v4

    goto/32 :l_QMdQTrZBOlokaNUc_10

    nop

    :l_ILLEMEdMoEmHnmxs_4
    const-string/jumbo v1, "message2"

    .line 15
    .local v1, "message2":Ljava/lang/String;
    goto/32 :l_CvcmNMlasjdVLEnV_5

    nop

    :l_CVAqRcEaIIREDEwX_7
    invoke-virtual {v3, v2}, Ljava/util/ArrayList;->add(Ljava/lang/Object;)Z

    .line 20
    goto/32 :l_sDhILXmJzXsfcXUr_8

    nop

.end method

```

`src/obfuscapk/obfuscators/reorder/example/before.smali`:

```smali
.class public Lcom/obfuscapk/demo/OrderDemo;
.super Ljava/lang/Object;
.source "OrderDemo.java"


# direct methods
.method public constructor <init>()V
    .locals 0

    .prologue
    .line 6
    invoke-direct {p0}, Ljava/lang/Object;-><init>()V

    return-void
.end method

.method public static getGotoMessage()Ljava/lang/String;
    .locals 5

    .prologue
    .line 9
    new-instance v3, Ljava/util/ArrayList;

    invoke-direct {v3}, Ljava/util/ArrayList;-><init>()V

    .line 11
    .local v3, "messages":Ljava/util/ArrayList;, "Ljava/util/ArrayList<Ljava/lang/String;>;"
    const-string/jumbo v0, "message1"

    .line 12
    .local v0, "message1":Ljava/lang/String;
    invoke-virtual {v3, v0}, Ljava/util/ArrayList;->add(Ljava/lang/Object;)Z

    .line 14
    const-string/jumbo v1, "message2"

    .line 15
    .local v1, "message2":Ljava/lang/String;
    invoke-virtual {v3, v1}, Ljava/util/ArrayList;->add(Ljava/lang/Object;)Z

    .line 17
    const-string/jumbo v2, "message3"

    .line 18
    .local v2, "message3":Ljava/lang/String;
    invoke-virtual {v3, v2}, Ljava/util/ArrayList;->add(Ljava/lang/Object;)Z

    .line 20
    invoke-virtual {v3}, Ljava/util/ArrayList;->toArray()[Ljava/lang/Object;

    move-result-object v4

    invoke-static {v4}, Ljava/util/Arrays;->toString([Ljava/lang/Object;)Ljava/lang/String;

    move-result-object v4

    return-object v4
.end method

```

`src/obfuscapk/obfuscators/reorder/example/original.java`:

```java
package com.obfuscapk.demo;

import java.util.ArrayList;
import java.util.Arrays;

public class OrderDemo {
    public static String getGotoMessage() {
        // Just some ordered instructions.
        ArrayList<String> messages = new ArrayList<>();

        String message1 = "message1";
        messages.add(message1);

        String message2 = "message2";
        messages.add(message2);

        String message3 = "message3";
        messages.add(message3);

        return Arrays.toString(messages.toArray());
    }
}

```

`src/obfuscapk/obfuscators/reorder/reorder.py`:

```py
#!/usr/bin/env python3

import logging
import random
import re
from typing import List

from obfuscapk import obfuscator_category
from obfuscapk import util
from obfuscapk.obfuscation import Obfuscation


class CodeBlock:
    def __init__(self, jump_id=0, smali_code=""):
        self.jump_id = jump_id
        self.smali_code = smali_code

    def add_smali_code_to_block(self, smali_code):
        self.smali_code += smali_code


class Reorder(obfuscator_category.ICodeObfuscator):
    def __init__(self):
        self.logger = logging.getLogger(
            "{0}.{1}".format(__name__, self.__class__.__name__)
        )
        super().__init__()

        self.if_mapping = {
            "if-eq": "if-ne",
            "if-ne": "if-eq",
            "if-lt": "if-ge",
            "if-ge": "if-lt",
            "if-gt": "if-le",
            "if-le": "if-gt",
            "if-eqz": "if-nez",
            "if-nez": "if-eqz",
            "if-ltz": "if-gez",
            "if-gez": "if-ltz",
            "if-gtz": "if-lez",
            "if-lez": "if-gtz",
        }

    def obfuscate(self, obfuscation_info: Obfuscation):
        self.logger.info('Running "{0}" obfuscator'.format(self.__class__.__name__))

        try:
            op_codes = util.get_code_block_valid_op_codes()
            op_code_pattern = re.compile(r"\s+(?P<op_code>\S+)")
            if_pattern = re.compile(
                r"\s+(?P<if_op_code>\S+)"
                r"\s(?P<register>[vp0-9,\s]+?),\s:(?P<goto_label>\S+)"
            )

            for smali_file in util.show_list_progress(
                obfuscation_info.get_smali_files(),
                interactive=obfuscation_info.interactive,
                description="Code reordering",
            ):
                self.logger.debug('Reordering code in file "{0}"'.format(smali_file))
                with util.inplace_edit_file(smali_file) as (in_file, out_file):
                    editing_method = False
                    inside_try_catch = False
                    jump_count = 0
                    for line in in_file:
                        if (
                            line.startswith(".method ")
                            and " abstract " not in line
                            and " native " not in line
                            and not editing_method
                        ):
                            # If at the beginning of a non abstract/native method
                            out_file.write(line)
                            editing_method = True
                            inside_try_catch = False
                            jump_count = 0

                        elif line.startswith(".end method") and editing_method:
                            # If a the end of the method.
                            out_file.write(line)
                            editing_method = False
                            inside_try_catch = False

                        elif editing_method:
                            # Inside method. Check if this line contains an op code at
                            # the beginning of the string.
                            match = op_code_pattern.match(line)
                            if match:
                                op_code = match.group("op_code")

                                # Check if we are entering or leaving a try-catch
                                # block of code.
                                if op_code.startswith(":try_start_"):
                                    out_file.write(line)
                                    inside_try_catch = True
                                elif op_code.startswith(":try_end_"):
                                    out_file.write(line)
                                    inside_try_catch = False

                                # If this is a valid op code, and we are not inside a
                                # try-catch block, mark this section with a special
                                # label that will be used later and invert the if
                                # conditions (if any).
                                elif op_code in op_codes and not inside_try_catch:
                                    jump_name = util.get_random_string(16)
                                    out_file.write(
                                        "\tgoto/32 :l_{label}_{count}\n\n".format(
                                            label=jump_name, count=jump_count
                                        )
                                    )
                                    out_file.write("\tnop\n\n")
                                    out_file.write("#!code_block!#\n")
                                    out_file.write(
                                        "\t:l_{label}_{count}\n".format(
                                            label=jump_name, count=jump_count
                                        )
                                    )
                                    jump_count += 1

                                    new_if = self.if_mapping.get(op_code, None)
                                    if new_if:
                                        if_match = if_pattern.match(line)
                                        random_label_name = util.get_random_string(16)
                                        out_file.write(
                                            "\t{if_cond} {register}, "
                                            ":gl_{new_label}\n\n".format(
                                                if_cond=new_if,
                                                register=if_match.group("register"),
                                                new_label=random_label_name,
                                            )
                                        )
                                        out_file.write(
                                            "\tgoto/32 :{0}\n\n".format(
                                                if_match.group("goto_label")
                                            )
                                        )
                                        out_file.write(
                                            "\t:gl_{0}".format(random_label_name)
                                        )
                                    else:
                                        out_file.write(line)
                                else:
                                    out_file.write(line)
                            else:
                                out_file.write(line)

                        else:
                            out_file.write(line)

                # Reorder code blocks randomly.
                with util.inplace_edit_file(smali_file) as (in_file, out_file):
                    editing_method = False
                    block_count = 0
                    code_blocks: List[CodeBlock] = []
                    current_code_block = None
                    for line in in_file:
                        if (
                            line.startswith(".method ")
                            and " abstract " not in line
                            and " native " not in line
                            and not editing_method
                        ):
                            # If at the beginning of a non abstract/native method
                            out_file.write(line)
                            editing_method = True
                            block_count = 0
                            code_blocks = []
                            current_code_block = None

                        elif line.startswith(".end method") and editing_method:
                            # If a the end of the method.
                            editing_method = False
                            random.shuffle(code_blocks)
                            for code_block in code_blocks:
                                out_file.write(code_block.smali_code)
                            out_file.write(line)

                        elif editing_method:
                            # Inside method. Check if this line is marked with
                            # a special label.
                            if line.startswith("#!code_block!#"):
                                block_count += 1
                                current_code_block = CodeBlock(block_count, "")
                                code_blocks.append(current_code_block)
                            else:
                                if block_count > 0 and current_code_block:
                                    current_code_block.add_smali_code_to_block(line)
                                else:
                                    out_file.write(line)

                        else:
                            out_file.write(line)

        except Exception as e:
            self.logger.error(
                'Error during execution of "{0}" obfuscator: {1}'.format(
                    self.__class__.__name__, e
                )
            )
            raise

        finally:
            obfuscation_info.used_obfuscators.append(self.__class__.__name__)

```

`src/obfuscapk/obfuscators/res_string_encryption.obfuscator`:

```obfuscator
[Core]
Name = ResStringEncryption
Module = res_string_encryption

[Documentation]
Description = Encrypt strings in resources (only those called inside code)
Version = 1.0

```

`src/obfuscapk/obfuscators/res_string_encryption/__init__.py`:

```py
#!/usr/bin/env python3

from .res_string_encryption import ResStringEncryption

```

`src/obfuscapk/obfuscators/res_string_encryption/res_string_encryption.py`:

```py
#!/usr/bin/env python3

import logging
import os
import re
import xml.etree.cElementTree as Xml
from binascii import hexlify
from typing import List, Set

from Crypto.Cipher import AES
from Crypto.Protocol.KDF import PBKDF2
from Crypto.Util.Padding import pad

from obfuscapk import obfuscator_category
from obfuscapk import util
from obfuscapk.obfuscation import Obfuscation


class ResStringEncryption(obfuscator_category.IEncryptionObfuscator):
    def __init__(self):
        self.logger = logging.getLogger(
            "{0}.{1}".format(__name__, self.__class__.__name__)
        )
        super().__init__()

        self.encryption_secret = "This-key-need-to-be-32-character"

    def encrypt_string(self, string_to_encrypt: str) -> str:
        # This is needed to remove the escaping added by Python. For example, if we
        # find in string resources the string "\"message\"" Android will treat it as
        # "message" while in Python it's \"message\", so we need to encrypt "message"
        # and not \"message\" (we have to remove the unnecessary escaping, otherwise
        # the backslashes would by encrypted as part of the string).
        string_to_encrypt = string_to_encrypt.encode(errors="replace").decode(
            "unicode_escape"
        )

        key = PBKDF2(
            password=self.encryption_secret,
            salt=self.encryption_secret.encode(),
            dkLen=32,
            count=128,
        )
        encrypted_string = hexlify(
            AES.new(key=key, mode=AES.MODE_ECB).encrypt(
                pad(string_to_encrypt.encode(errors="replace"), AES.block_size)
            )
        ).decode()
        return encrypted_string

    def encrypt_string_resources(
        self, string_resources_xml_file: str, string_names_to_encrypt: Set[str]
    ):
        xml_parser = Xml.XMLParser(encoding="utf-8")
        xml_tree = Xml.parse(string_resources_xml_file, parser=xml_parser)

        for xml_string in xml_tree.iter("string"):
            string_name = xml_string.get("name", None)
            string_value = xml_string.text
            if string_name and string_value and string_name in string_names_to_encrypt:
                encrypted_string_value = self.encrypt_string(string_value)
                xml_string.text = encrypted_string_value

        xml_tree.write(string_resources_xml_file, encoding="utf-8")

    def encrypt_string_array_resources(
        self,
        string_array_resources_xml_file: str,
        string_array_names_to_encrypt: Set[str],
    ):
        xml_parser = Xml.XMLParser(encoding="utf-8")
        xml_tree = Xml.parse(string_array_resources_xml_file, parser=xml_parser)

        for xml_string_array in xml_tree.iter("string-array"):
            string_array_name = xml_string_array.get("name", None)
            if string_array_name and string_array_name in string_array_names_to_encrypt:
                for item in xml_string_array.iter("item"):
                    if item.text:
                        encrypted_string_value = self.encrypt_string(item.text)
                        item.text = encrypted_string_value

        xml_tree.write(string_array_resources_xml_file, encoding="utf-8")

    def obfuscate(self, obfuscation_info: Obfuscation):
        self.logger.info('Running "{0}" obfuscator'.format(self.__class__.__name__))

        self.encryption_secret = obfuscation_info.encryption_secret
        try:
            string_res_field_pattern = re.compile(
                r"\.field\spublic\sstatic\sfinal\s(?P<string_name>\S+?):I\s=\s"
                r"(?P<string_id>[0-9a-fA-FxX]+)",
                re.UNICODE,
            )

            string_id_pattern = re.compile(
                r"\s+const\s(?P<register>[vp0-9]+),\s(?P<id>\S+)"
            )

            string_array_id_pattern = re.compile(
                r"\s+const/high16\s(?P<register>[vp0-9]+),\s(?P<id>\S+)"
            )

            load_string_res_pattern = re.compile(
                r"\s+invoke-virtual\s"
                r"{[vp0-9]+,\s(?P<param_register>[vp0-9]+)},\s"
                r"(Landroid/content/res/Resources;->getString\(I\)Ljava/lang/String;"
                r"|Landroid/content/Context;->getString\(I\)Ljava/lang/String;)"
            )

            load_string_array_res_pattern = re.compile(
                r"\s+invoke-virtual\s"
                r"{[vp0-9]+,\s(?P<param_register>[vp0-9]+)},\s"
                r"Landroid/content/res/Resources;->"
                r"getStringArray\(I\)\[Ljava/lang/String;"
            )

            move_result_obj_pattern = re.compile(
                r"\s+move-result-object\s(?P<register>[vp0-9]+)"
            )

            # Set with the names of the encrypted string and string array resources.
            encrypted_res_strings: Set[str] = set()
            encrypted_res_string_arrays: Set[str] = set()

            # Find the mappings between string name and string id.
            string_id_to_string_name: dict = {}
            string_array_id_to_string_name: dict = {}
            for smali_file in obfuscation_info.get_smali_files():
                if smali_file.endswith("R$string.smali"):
                    with open(smali_file, "r", encoding="utf-8") as current_file:
                        for line in current_file:
                            if line.startswith(".method "):
                                # Method declaration reached, no more field declarations
                                # from now on.
                                break
                            field_match = string_res_field_pattern.match(line)
                            if field_match:
                                # String name and id declaration.
                                string_id_to_string_name[
                                    field_match.group("string_id")
                                ] = field_match.group("string_name")

                elif smali_file.endswith("R$array.smali"):
                    with open(smali_file, "r", encoding="utf-8") as current_file:
                        for line in current_file:
                            if line.startswith(".method "):
                                # Method declaration reached, no more field declarations
                                # from now on.
                                break
                            field_match = string_res_field_pattern.match(line)
                            if field_match:
                                # String array name and id declaration.
                                string_array_id_to_string_name[
                                    field_match.group("string_id")
                                ] = field_match.group("string_name")

            for smali_file in util.show_list_progress(
                obfuscation_info.get_smali_files(),
                interactive=obfuscation_info.interactive,
                description="Encrypting string resources",
            ):
                self.logger.debug(
                    'Encrypting string resources in file "{0}"'.format(smali_file)
                )

                with open(smali_file, "r", encoding="utf-8") as current_file:
                    lines = current_file.readlines()

                # Line numbers where a string is loaded from resources.
                string_index: List[int] = []

                # Registers containing the strings loaded from resources.
                string_register: List[str] = []

                # The number of local registers in the method where a string resource
                # is loaded.
                string_local_count: List[int] = []

                # Line numbers where a string array is loaded from resources.
                string_array_index: List[int] = []

                # Registers containing the string arrays loaded from resources.
                string_array_register: List[str] = []

                # The number of local registers in the method where a string array
                # resource is loaded.
                string_array_local_count: List[int] = []

                # Look for resource strings that can be encrypted.
                current_local_count = 0
                for line_number, line in enumerate(lines):
                    # We are iterating the lines in order, so each time we enter a
                    # method we'll find the declaration with the number of local
                    # registers available. We need this information because the invoke
                    # instruction that we need later won't take registers with values
                    # greater than 15.
                    match = util.locals_pattern.match(line)
                    if match:
                        current_local_count = int(match.group("local_count"))
                        continue

                    string_res_match = load_string_res_pattern.match(line)
                    if string_res_match:
                        string_index.append(line_number)
                        string_register.append(string_res_match.group("param_register"))
                        string_local_count.append(current_local_count)
                        continue

                    string_array_res_match = load_string_array_res_pattern.match(line)
                    if string_array_res_match:
                        string_array_index.append(line_number)
                        string_array_register.append(
                            string_array_res_match.group("param_register")
                        )
                        string_array_local_count.append(current_local_count)

                # Iterate the lines backwards (until the method declaration is reached)
                # and find the id of each string resource.
                for string_number, index in enumerate(string_index):
                    for line_number in range(index - 1, 0, -1):
                        if lines[line_number].startswith(".method "):
                            # Method declaration reached, no string resource found so
                            # proceed with the next (if any). If we are here it means
                            # that the string was loaded from a variable and not from
                            # a constant reference, so this string should not be
                            # encrypted. We set the corresponding string_index to -1
                            # and we won't insert any decryption code for this string.
                            string_index[string_number] = -1
                            break

                        # NOTE: if a string is loaded from resources, it will be
                        # encrypted. If other code loads the same string but using a
                        # variable instead of the resource id, it won't work anymore
                        # and this case is not handled by this obfuscator.

                        id_match = string_id_pattern.match(lines[line_number])
                        if (
                            id_match
                            and id_match.group("register")
                            == string_register[string_number]
                        ):
                            # String id declaration, get the name corresponding to
                            # the id and add it to the list of string resources to
                            # be encrypted.
                            if id_match.group("id") in string_id_to_string_name:
                                encrypted_res_strings.add(
                                    string_id_to_string_name[id_match.group("id")]
                                )

                            # Proceed with the next asset file (if any).
                            break

                # Iterate the lines backwards (until the method declaration is reached)
                # and find the id of each string array resource.
                for string_array_number, index in enumerate(string_array_index):
                    for line_number in range(index - 1, 0, -1):
                        if lines[line_number].startswith(".method "):
                            # Method declaration reached, no string array resource
                            # found so proceed with the next (if any).
                            # If we are here it means that the string was loaded from a
                            # variable and not from a constant reference, so this string
                            # should not be encrypted. We set the corresponding
                            # string_array_index to -1 and we won't insert any
                            # decryption code for this string.
                            string_array_index[string_array_number] = -1
                            break

                        # NOTE: if a string array is loaded from resources, it will be
                        # encrypted. If other code loads the same string array but using
                        # a variable instead of the resource id, it won't work anymore
                        # and this case is not handled by this obfuscator.

                        id_match = string_array_id_pattern.match(lines[line_number])
                        if (
                            id_match
                            and id_match.group("register")
                            == string_array_register[string_array_number]
                        ):
                            # String array id declaration, get the name corresponding to
                            # the id and add it to the list of string array resources
                            # to be encrypted.
                            if id_match.group("id") in string_array_id_to_string_name:
                                encrypted_res_string_arrays.add(
                                    string_array_id_to_string_name[id_match.group("id")]
                                )

                            # Proceed with the next asset file (if any).
                            break

                # After each string resource is loaded, decrypt it (the string resource
                # will be encrypted directly in the xml file).
                for string_number, index in enumerate(
                    i for i in string_index if i != -1
                ):
                    # For each resource string loaded, look for the next
                    # move-result-object instruction to see in which register the string
                    # is saved, in order to add a new instruction to decrypt it.
                    for line_number in range(index + 1, len(lines)):
                        if lines[line_number].startswith(".end method"):
                            # Method end reached, no move-result-object instruction
                            # found for this string resource (the loaded string is not
                            # used), so proceed with the next (if any).
                            break

                        # If the string resource is put into a register v0-v15 we can
                        # proceed with the encryption, but if it uses a p<number>
                        # register, before encrypting we have to check if
                        # <number> + locals <= 15.
                        move_result_match = move_result_obj_pattern.match(
                            lines[line_number]
                        )
                        if move_result_match:
                            reg_type = move_result_match.group("register")[:1]
                            reg_number = int(move_result_match.group("register")[1:])
                            if (reg_type == "v" and reg_number <= 15) or (
                                reg_type == "p"
                                and reg_number + string_local_count[string_number] <= 15
                            ):
                                # Add string decrypt instruction.
                                lines[line_number] += (
                                    "\n\tinvoke-static {{{register}}}, "
                                    "Lcom/decryptstringmanager/DecryptString;->"
                                    "decryptString(Ljava/lang/String;)"
                                    "Ljava/lang/String;\n\n".format(
                                        register=move_result_match.group("register")
                                    )
                                    + lines[line_number]
                                )

                            # Proceed with the next string resource (if any).
                            break

                # After each string array resource is loaded, decrypt it (the string
                # array resource will be encrypted directly in the xml file).
                for string_array_number, index in enumerate(
                    i for i in string_array_index if i != -1
                ):
                    # For each resource string array loaded, look for the next
                    # move-result-object instruction to see in which register the string
                    # array is saved, in order to add a new instruction to decrypt it.
                    for line_number in range(index + 1, len(lines)):
                        if lines[line_number].startswith(".end method"):
                            # Method end reached, no move-result-object instruction
                            # found for this string array resource (the loaded string
                            # array is not used), so proceed with the next (if any).
                            break

                        # If the string array resource is put into a register v0-v15 we
                        # can proceed with the encryption, but if it uses a p<number>
                        # register, before encrypting we have to check if
                        # <number> + locals <= 15.
                        move_result_match = move_result_obj_pattern.match(
                            lines[line_number]
                        )
                        if move_result_match:
                            reg_type = move_result_match.group("register")[:1]
                            reg_number = int(move_result_match.group("register")[1:])
                            if (reg_type == "v" and reg_number <= 15) or (
                                reg_type == "p"
                                and reg_number
                                + string_array_local_count[string_array_number]
                                <= 15
                            ):
                                # Add string array decrypt instruction.
                                lines[line_number] += (
                                    "\n\tinvoke-static {{{register}}}, "
                                    "Lcom/decryptstringmanager/DecryptString;->"
                                    "decryptStringArray([Ljava/lang/String;)"
                                    "[Ljava/lang/String;\n\n".format(
                                        register=move_result_match.group("register")
                                    )
                                    + lines[line_number]
                                )

                            # Proceed with the next string array resource (if any).
                            break

                with open(smali_file, "w", encoding="utf-8") as current_file:
                    current_file.writelines(lines)

            # Encrypt the strings and the string arrays in the resource files.
            strings_xml_path = os.path.join(
                obfuscation_info.get_resource_directory(), "values", "strings.xml"
            )
            string_arrays_xml_path = os.path.join(
                obfuscation_info.get_resource_directory(), "values", "arrays.xml"
            )
            if os.path.isfile(strings_xml_path):
                self.encrypt_string_resources(strings_xml_path, encrypted_res_strings)
            if os.path.isfile(string_arrays_xml_path):
                self.encrypt_string_array_resources(
                    string_arrays_xml_path, encrypted_res_string_arrays
                )

            if not obfuscation_info.decrypt_string_smali_file_added_flag and (
                encrypted_res_strings or encrypted_res_string_arrays
            ):
                # Add to the app the code for decrypting the encrypted strings. The code
                # for decrypting can be put in any smali directory, since it will be
                # moved to the correct directory when rebuilding the application.
                destination_dir = os.path.dirname(obfuscation_info.get_smali_files()[0])
                destination_file = os.path.join(destination_dir, "DecryptString.smali")
                with open(
                    destination_file, "w", encoding="utf-8"
                ) as decrypt_string_smali:
                    decrypt_string_smali.write(
                        util.get_decrypt_string_smali_code(self.encryption_secret)
                    )
                    obfuscation_info.decrypt_string_smali_file_added_flag = True

        except Exception as e:
            self.logger.error(
                'Error during execution of "{0}" obfuscator: {1}'.format(
                    self.__class__.__name__, e
                )
            )
            raise

        finally:
            obfuscation_info.used_obfuscators.append(self.__class__.__name__)

```

`src/obfuscapk/obfuscators/virus_total.obfuscator`:

```obfuscator
[Core]
Name = VirusTotal
Module = virus_total

[Documentation]
Description = Send the original and the obfuscated application to Virus Total
Version = 1.0

```

`src/obfuscapk/obfuscators/virus_total/__init__.py`:

```py
#!/usr/bin/env python3

from .virus_total import VirusTotal

```

`src/obfuscapk/obfuscators/virus_total/virus_total.py`:

```py
#!/usr/bin/env python3

import json
import logging
import os
from pprint import pformat
from typing import Optional, Dict

import vt

from obfuscapk import obfuscator_category
from obfuscapk.obfuscation import Obfuscation
from obfuscapk.util import sha256sum


class VirusTotal(obfuscator_category.IOtherObfuscator):
    def __init__(self):
        self.logger = logging.getLogger(
            "{0}.{1}".format(__name__, self.__class__.__name__)
        )
        super().__init__()
        self.vt_session = None

    @staticmethod
    def get_positives(report: Dict) -> int:
        return report["data"]["attributes"]["last_analysis_stats"]["malicious"]

    def get_report_or_none(self, sha256_hash: str) -> Optional[dict]:
        try:
            report = self.vt_session.get_json(f"/files/{sha256_hash}")
            return report
        except vt.error.APIError:
            return None

    def scan_apk_file(self, apk_file_path: str) -> dict:
        self.logger.info('Scanning file "{0}"'.format(apk_file_path))
        sha256_hash = sha256sum(apk_file_path)
        report = self.get_report_or_none(sha256_hash)
        if report is not None:
            return report

        with open(apk_file_path, "rb") as f:
            self.logger.info(f"Uploading '{apk_file_path}' to VirusTotal...")
            analysis = self.vt_session.scan_file(f, wait_for_completion=True)
            assert analysis.status == "completed"

        report = self.get_report_or_none(sha256_hash)
        if report is None:
            raise Exception(
                'Error while retrieving scan for file "{0}"'.format(apk_file_path)
            )
        return report

    def obfuscate(self, obfuscation_info: Obfuscation):
        self.logger.info("Sending original and obfuscated application to Virus Total")

        try:
            if not os.path.isfile(obfuscation_info.obfuscated_apk_path):
                raise FileNotFoundError(
                    "Obfuscated apk was not found. Did you execute the Rebuild "
                    "obfuscator?"
                )

            if obfuscation_info.virus_total_api_key is None:
                raise ValueError(
                    "A valid API key has to be provided in order to submit the "
                    "obfuscated application to Virus Total"
                )

            self.vt_session = vt.Client(obfuscation_info.virus_total_api_key)

            original_report = self.scan_apk_file(obfuscation_info.apk_path)
            self.logger.info(
                "Original apk scan result ({0} positives): {1}".format(
                    self.get_positives(original_report), pformat(original_report)
                )
            )
            obfuscated_report = self.scan_apk_file(obfuscation_info.obfuscated_apk_path)
            self.logger.info(
                "Obfuscated apk scan result ({0} positives): {1}".format(
                    self.get_positives(obfuscated_report),
                    pformat(obfuscated_report),
                )
            )

            # Save Virus Total results in 2 json file (original and obfuscated) in
            # the same directory as the obfuscated apk.
            original_report_path = os.path.join(
                os.path.dirname(obfuscation_info.obfuscated_apk_path),
                "{0}.virustotal-original.json".format(
                    os.path.splitext(os.path.basename(obfuscation_info.apk_path))[0]
                ),
            )
            obfuscated_report_path = os.path.join(
                os.path.dirname(obfuscation_info.obfuscated_apk_path),
                "{0}.virustotal-obfuscated.json".format(
                    os.path.splitext(
                        os.path.basename(obfuscation_info.obfuscated_apk_path)
                    )[0]
                ),
            )
            with open(original_report_path, "w") as original_json, open(
                obfuscated_report_path, "w"
            ) as obfuscated_json:
                original_json.write(
                    json.dumps(
                        {"used_obfuscators": [], "virustotal_scan": original_report},
                        indent=2,
                        sort_keys=True,
                    )
                )
                obfuscated_json.write(
                    json.dumps(
                        {
                            "used_obfuscators": obfuscation_info.used_obfuscators,
                            "virustotal_scan": obfuscated_report,
                        },
                        indent=2,
                        sort_keys=True,
                    )
                )

        except Exception as e:
            self.logger.error("Error during Virus Total analysis: {0}".format(e))
            raise

        finally:
            self.vt_session.close()
            obfuscation_info.used_obfuscators.append(self.__class__.__name__)

```

`src/obfuscapk/resources/android_class_names_api_27.txt`:

```txt
Landroid/accessibilityservice/AccessibilityButtonController;
Landroid/accessibilityservice/AccessibilityButtonController$AccessibilityButtonCallback;
Landroid/accessibilityservice/AccessibilityService;
Landroid/accessibilityservice/AccessibilityService$GestureResultCallback;
Landroid/accessibilityservice/AccessibilityServiceInfo;
Landroid/accessibilityservice/AccessibilityService$MagnificationController;
Landroid/accessibilityservice/AccessibilityService$MagnificationController$OnMagnificationChangedListener;
Landroid/accessibilityservice/AccessibilityService$SoftKeyboardController;
Landroid/accessibilityservice/AccessibilityService$SoftKeyboardController$OnShowModeChangedListener;
Landroid/accessibilityservice/FingerprintGestureController;
Landroid/accessibilityservice/FingerprintGestureController$FingerprintGestureCallback;
Landroid/accessibilityservice/GestureDescription;
Landroid/accessibilityservice/GestureDescription$Builder;
Landroid/accessibilityservice/GestureDescription$StrokeDescription;
Landroid/accounts/AbstractAccountAuthenticator;
Landroid/accounts/Account;
Landroid/accounts/AccountAuthenticatorActivity;
Landroid/accounts/AccountAuthenticatorResponse;
Landroid/accounts/AccountManager;
Landroid/accounts/AccountManagerCallback;
Landroid/accounts/AccountManagerFuture;
Landroid/accounts/AccountsException;
Landroid/accounts/AuthenticatorDescription;
Landroid/accounts/AuthenticatorException;
Landroid/accounts/NetworkErrorException;
Landroid/accounts/OnAccountsUpdateListener;
Landroid/accounts/OperationCanceledException;
Landroid/animation/Animator;
Landroid/animation/Animator$AnimatorListener;
Landroid/animation/Animator$AnimatorPauseListener;
Landroid/animation/AnimatorInflater;
Landroid/animation/AnimatorListenerAdapter;
Landroid/animation/AnimatorSet;
Landroid/animation/AnimatorSet$Builder;
Landroid/animation/ArgbEvaluator;
Landroid/animation/BidirectionalTypeConverter;
Landroid/animation/FloatArrayEvaluator;
Landroid/animation/FloatEvaluator;
Landroid/animation/IntArrayEvaluator;
Landroid/animation/IntEvaluator;
Landroid/animation/Keyframe;
Landroid/animation/LayoutTransition;
Landroid/animation/LayoutTransition$TransitionListener;
Landroid/animation/ObjectAnimator;
Landroid/animation/PointFEvaluator;
Landroid/animation/PropertyValuesHolder;
Landroid/animation/RectEvaluator;
Landroid/animation/StateListAnimator;
Landroid/animation/TimeAnimator;
Landroid/animation/TimeAnimator$TimeListener;
Landroid/animation/TimeInterpolator;
Landroid/animation/TypeConverter;
Landroid/animation/TypeEvaluator;
Landroid/animation/ValueAnimator;
Landroid/animation/ValueAnimator$AnimatorUpdateListener;
Landroid/annotation/SuppressLint;
Landroid/annotation/TargetApi;
Landroid/app/ActionBar;
Landroid/app/ActionBar$LayoutParams;
Landroid/app/ActionBar$OnMenuVisibilityListener;
Landroid/app/ActionBar$OnNavigationListener;
Landroid/app/ActionBar$Tab;
Landroid/app/ActionBar$TabListener;
Landroid/app/Activity;
Landroid/app/ActivityGroup;
Landroid/app/ActivityManager;
Landroid/app/ActivityManager$AppTask;
Landroid/app/ActivityManager$MemoryInfo;
Landroid/app/ActivityManager$ProcessErrorStateInfo;
Landroid/app/ActivityManager$RecentTaskInfo;
Landroid/app/ActivityManager$RunningAppProcessInfo;
Landroid/app/ActivityManager$RunningServiceInfo;
Landroid/app/ActivityManager$RunningTaskInfo;
Landroid/app/ActivityManager$TaskDescription;
Landroid/app/ActivityOptions;
Landroid/app/admin/ConnectEvent;
Landroid/app/admin/DeviceAdminInfo;
Landroid/app/admin/DeviceAdminReceiver;
Landroid/app/admin/DeviceAdminService;
Landroid/app/admin/DevicePolicyManager;
Landroid/app/admin/DnsEvent;
Landroid/app/admin/NetworkEvent;
Landroid/app/admin/SecurityLog;
Landroid/app/admin/SecurityLog$SecurityEvent;
Landroid/app/admin/SystemUpdateInfo;
Landroid/app/admin/SystemUpdatePolicy;
Landroid/app/AlarmManager;
Landroid/app/AlarmManager$AlarmClockInfo;
Landroid/app/AlarmManager$OnAlarmListener;
Landroid/app/AlertDialog;
Landroid/app/AlertDialog$Builder;
Landroid/app/AliasActivity;
Landroid/app/Application;
Landroid/app/Application$ActivityLifecycleCallbacks;
Landroid/app/ApplicationErrorReport;
Landroid/app/ApplicationErrorReport$AnrInfo;
Landroid/app/ApplicationErrorReport$BatteryInfo;
Landroid/app/ApplicationErrorReport$CrashInfo;
Landroid/app/ApplicationErrorReport$RunningServiceInfo;
Landroid/app/Application$OnProvideAssistDataListener;
Landroid/app/AppOpsManager;
Landroid/app/AppOpsManager$OnOpChangedListener;
Landroid/app/assist/AssistContent;
Landroid/app/assist/AssistStructure;
Landroid/app/assist/AssistStructure$ViewNode;
Landroid/app/assist/AssistStructure$WindowNode;
Landroid/app/AuthenticationRequiredException;
Landroid/app/AutomaticZenRule;
Landroid/app/backup/BackupAgent;
Landroid/app/backup/BackupAgentHelper;
Landroid/app/backup/BackupDataInput;
Landroid/app/backup/BackupDataInputStream;
Landroid/app/backup/BackupDataOutput;
Landroid/app/backup/BackupHelper;
Landroid/app/backup/BackupManager;
Landroid/app/backup/FileBackupHelper;
Landroid/app/backup/FullBackupDataOutput;
Landroid/app/backup/RestoreObserver;
Landroid/app/backup/SharedPreferencesBackupHelper;
Landroid/app/DatePickerDialog;
Landroid/app/DatePickerDialog$OnDateSetListener;
Landroid/app/Dialog;
Landroid/app/DialogFragment;
Landroid/app/DownloadManager;
Landroid/app/DownloadManager$Query;
Landroid/app/DownloadManager$Request;
Landroid/app/ExpandableListActivity;
Landroid/app/Fragment;
Landroid/app/FragmentBreadCrumbs;
Landroid/app/FragmentBreadCrumbs$OnBreadCrumbClickListener;
Landroid/app/FragmentContainer;
Landroid/app/FragmentController;
Landroid/app/FragmentHostCallback;
Landroid/app/Fragment$InstantiationException;
Landroid/app/FragmentManager;
Landroid/app/FragmentManager$BackStackEntry;
Landroid/app/FragmentManager$FragmentLifecycleCallbacks;
Landroid/app/FragmentManagerNonConfig;
Landroid/app/FragmentManager$OnBackStackChangedListener;
Landroid/app/Fragment$SavedState;
Landroid/app/FragmentTransaction;
Landroid/app/Instrumentation;
Landroid/app/Instrumentation$ActivityMonitor;
Landroid/app/Instrumentation$ActivityResult;
Landroid/app/IntentService;
Landroid/app/job/JobInfo;
Landroid/app/job/JobInfo$Builder;
Landroid/app/job/JobInfo$TriggerContentUri;
Landroid/app/job/JobParameters;
Landroid/app/job/JobScheduler;
Landroid/app/job/JobService;
Landroid/app/job/JobServiceEngine;
Landroid/app/job/JobWorkItem;
Landroid/app/KeyguardManager;
Landroid/app/KeyguardManager$KeyguardDismissCallback;
Landroid/app/KeyguardManager$KeyguardLock;
Landroid/app/KeyguardManager$OnKeyguardExitResult;
Landroid/app/LauncherActivity;
Landroid/app/LauncherActivity$IconResizer;
Landroid/app/LauncherActivity$ListItem;
Landroid/app/ListActivity;
Landroid/app/ListFragment;
Landroid/app/LoaderManager;
Landroid/app/LoaderManager$LoaderCallbacks;
Landroid/app/LocalActivityManager;
Landroid/app/MediaRouteActionProvider;
Landroid/app/MediaRouteButton;
Landroid/app/NativeActivity;
Landroid/app/Notification;
Landroid/app/Notification$Action;
Landroid/app/Notification$Action$Builder;
Landroid/app/Notification$Action$Extender;
Landroid/app/Notification$Action$WearableExtender;
Landroid/app/Notification$BigPictureStyle;
Landroid/app/Notification$BigTextStyle;
Landroid/app/Notification$Builder;
Landroid/app/Notification$CarExtender;
Landroid/app/Notification$CarExtender$Builder;
Landroid/app/Notification$CarExtender$UnreadConversation;
Landroid/app/NotificationChannel;
Landroid/app/NotificationChannelGroup;
Landroid/app/Notification$DecoratedCustomViewStyle;
Landroid/app/Notification$DecoratedMediaCustomViewStyle;
Landroid/app/Notification$Extender;
Landroid/app/Notification$InboxStyle;
Landroid/app/NotificationManager;
Landroid/app/NotificationManager$Policy;
Landroid/app/Notification$MediaStyle;
Landroid/app/Notification$MessagingStyle;
Landroid/app/Notification$MessagingStyle$Message;
Landroid/app/Notification$Style;
Landroid/app/Notification$WearableExtender;
Landroid/app/PendingIntent;
Landroid/app/PendingIntent$CanceledException;
Landroid/app/PendingIntent$OnFinished;
Landroid/app/PictureInPictureParams;
Landroid/app/PictureInPictureParams$Builder;
Landroid/app/Presentation;
Landroid/app/ProgressDialog;
Landroid/app/RemoteAction;
Landroid/app/RemoteInput;
Landroid/app/RemoteInput$Builder;
Landroid/app/SearchableInfo;
Landroid/app/SearchManager;
Landroid/app/SearchManager$OnCancelListener;
Landroid/app/SearchManager$OnDismissListener;
Landroid/app/Service;
Landroid/app/SharedElementCallback;
Landroid/app/SharedElementCallback$OnSharedElementsReadyListener;
Landroid/app/TabActivity;
Landroid/app/TaskStackBuilder;
Landroid/app/TimePickerDialog;
Landroid/app/TimePickerDialog$OnTimeSetListener;
Landroid/app/UiAutomation;
Landroid/app/UiAutomation$AccessibilityEventFilter;
Landroid/app/UiAutomation$OnAccessibilityEventListener;
Landroid/app/UiModeManager;
Landroid/app/usage/ConfigurationStats;
Landroid/app/usage/ExternalStorageStats;
Landroid/app/usage/NetworkStats;
Landroid/app/usage/NetworkStats$Bucket;
Landroid/app/usage/NetworkStatsManager;
Landroid/app/usage/NetworkStatsManager$UsageCallback;
Landroid/app/usage/StorageStats;
Landroid/app/usage/StorageStatsManager;
Landroid/app/usage/UsageEvents;
Landroid/app/usage/UsageEvents$Event;
Landroid/app/usage/UsageStats;
Landroid/app/usage/UsageStatsManager;
Landroid/app/VoiceInteractor;
Landroid/app/VoiceInteractor$AbortVoiceRequest;
Landroid/app/VoiceInteractor$CommandRequest;
Landroid/app/VoiceInteractor$CompleteVoiceRequest;
Landroid/app/VoiceInteractor$ConfirmationRequest;
Landroid/app/VoiceInteractor$PickOptionRequest;
Landroid/app/VoiceInteractor$PickOptionRequest$Option;
Landroid/app/VoiceInteractor$Prompt;
Landroid/app/VoiceInteractor$Request;
Landroid/app/WallpaperColors;
Landroid/app/WallpaperInfo;
Landroid/app/WallpaperManager;
Landroid/app/WallpaperManager$OnColorsChangedListener;
Landroid/appwidget/AppWidgetHost;
Landroid/appwidget/AppWidgetHostView;
Landroid/appwidget/AppWidgetManager;
Landroid/appwidget/AppWidgetProvider;
Landroid/appwidget/AppWidgetProviderInfo;
Landroid/bluetooth/BluetoothA2dp;
Landroid/bluetooth/BluetoothAdapter;
Landroid/bluetooth/BluetoothAdapter$LeScanCallback;
Landroid/bluetooth/BluetoothAssignedNumbers;
Landroid/bluetooth/BluetoothClass;
Landroid/bluetooth/BluetoothClass$Device;
Landroid/bluetooth/BluetoothClass$Device$Major;
Landroid/bluetooth/BluetoothClass$Service;
Landroid/bluetooth/BluetoothDevice;
Landroid/bluetooth/BluetoothGatt;
Landroid/bluetooth/BluetoothGattCallback;
Landroid/bluetooth/BluetoothGattCharacteristic;
Landroid/bluetooth/BluetoothGattDescriptor;
Landroid/bluetooth/BluetoothGattServer;
Landroid/bluetooth/BluetoothGattServerCallback;
Landroid/bluetooth/BluetoothGattService;
Landroid/bluetooth/BluetoothHeadset;
Landroid/bluetooth/BluetoothHealth;
Landroid/bluetooth/BluetoothHealthAppConfiguration;
Landroid/bluetooth/BluetoothHealthCallback;
Landroid/bluetooth/BluetoothManager;
Landroid/bluetooth/BluetoothProfile;
Landroid/bluetooth/BluetoothProfile$ServiceListener;
Landroid/bluetooth/BluetoothServerSocket;
Landroid/bluetooth/BluetoothSocket;
Landroid/bluetooth/le/AdvertiseCallback;
Landroid/bluetooth/le/AdvertiseData;
Landroid/bluetooth/le/AdvertiseData$Builder;
Landroid/bluetooth/le/AdvertiseSettings;
Landroid/bluetooth/le/AdvertiseSettings$Builder;
Landroid/bluetooth/le/AdvertisingSet;
Landroid/bluetooth/le/AdvertisingSetCallback;
Landroid/bluetooth/le/AdvertisingSetParameters;
Landroid/bluetooth/le/AdvertisingSetParameters$Builder;
Landroid/bluetooth/le/BluetoothLeAdvertiser;
Landroid/bluetooth/le/BluetoothLeScanner;
Landroid/bluetooth/le/PeriodicAdvertisingParameters;
Landroid/bluetooth/le/PeriodicAdvertisingParameters$Builder;
Landroid/bluetooth/le/ScanCallback;
Landroid/bluetooth/le/ScanFilter;
Landroid/bluetooth/le/ScanFilter$Builder;
Landroid/bluetooth/le/ScanRecord;
Landroid/bluetooth/le/ScanResult;
Landroid/bluetooth/le/ScanSettings;
Landroid/bluetooth/le/ScanSettings$Builder;
Landroid/companion/AssociationRequest;
Landroid/companion/AssociationRequest$Builder;
Landroid/companion/BluetoothDeviceFilter;
Landroid/companion/BluetoothDeviceFilter$Builder;
Landroid/companion/BluetoothLeDeviceFilter;
Landroid/companion/BluetoothLeDeviceFilter$Builder;
Landroid/companion/CompanionDeviceManager;
Landroid/companion/CompanionDeviceManager$Callback;
Landroid/companion/DeviceFilter;
Landroid/companion/WifiDeviceFilter;
Landroid/companion/WifiDeviceFilter$Builder;
Landroid/content/AbstractThreadedSyncAdapter;
Landroid/content/ActivityNotFoundException;
Landroid/content/AsyncQueryHandler;
Landroid/content/AsyncQueryHandler$WorkerArgs;
Landroid/content/AsyncQueryHandler$WorkerHandler;
Landroid/content/AsyncTaskLoader;
Landroid/content/BroadcastReceiver;
Landroid/content/BroadcastReceiver$PendingResult;
Landroid/content/ClipboardManager;
Landroid/content/ClipboardManager$OnPrimaryClipChangedListener;
Landroid/content/ClipData;
Landroid/content/ClipData$Item;
Landroid/content/ClipDescription;
Landroid/content/ComponentCallbacks;
Landroid/content/ComponentCallbacks2;
Landroid/content/ComponentName;
Landroid/content/ContentProvider;
Landroid/content/ContentProviderClient;
Landroid/content/ContentProviderOperation;
Landroid/content/ContentProviderOperation$Builder;
Landroid/content/ContentProvider$PipeDataWriter;
Landroid/content/ContentProviderResult;
Landroid/content/ContentQueryMap;
Landroid/content/ContentResolver;
Landroid/content/ContentUris;
Landroid/content/ContentValues;
Landroid/content/Context;
Landroid/content/ContextWrapper;
Landroid/content/CursorLoader;
Landroid/content/DialogInterface;
Landroid/content/DialogInterface$OnCancelListener;
Landroid/content/DialogInterface$OnClickListener;
Landroid/content/DialogInterface$OnDismissListener;
Landroid/content/DialogInterface$OnKeyListener;
Landroid/content/DialogInterface$OnMultiChoiceClickListener;
Landroid/content/DialogInterface$OnShowListener;
Landroid/content/Entity;
Landroid/content/EntityIterator;
Landroid/content/Entity$NamedContentValues;
Landroid/content/Intent;
Landroid/content/IntentFilter;
Landroid/content/IntentFilter$AuthorityEntry;
Landroid/content/Intent$FilterComparison;
Landroid/content/IntentFilter$MalformedMimeTypeException;
Landroid/content/IntentSender;
Landroid/content/IntentSender$OnFinished;
Landroid/content/IntentSender$SendIntentException;
Landroid/content/Intent$ShortcutIconResource;
Landroid/content/Loader;
Landroid/content/Loader$ForceLoadContentObserver;
Landroid/content/Loader$OnLoadCanceledListener;
Landroid/content/Loader$OnLoadCompleteListener;
Landroid/content/MutableContextWrapper;
Landroid/content/OperationApplicationException;
Landroid/content/PeriodicSync;
Landroid/content/pm/ActivityInfo;
Landroid/content/pm/ActivityInfo$WindowLayout;
Landroid/content/pm/ApplicationInfo;
Landroid/content/pm/ApplicationInfo$DisplayNameComparator;
Landroid/content/pm/ChangedPackages;
Landroid/content/pm/ComponentInfo;
Landroid/content/pm/ConfigurationInfo;
Landroid/content/pm/FeatureGroupInfo;
Landroid/content/pm/FeatureInfo;
Landroid/content/pm/InstrumentationInfo;
Landroid/content/pm/LabeledIntent;
Landroid/content/pm/LauncherActivityInfo;
Landroid/content/pm/LauncherApps;
Landroid/content/pm/LauncherApps$Callback;
Landroid/content/pm/LauncherApps$PinItemRequest;
Landroid/content/pm/LauncherApps$ShortcutQuery;
Landroid/content/pm/PackageInfo;
Landroid/content/pm/PackageInstaller;
Landroid/content/pm/PackageInstaller$Session;
Landroid/content/pm/PackageInstaller$SessionCallback;
Landroid/content/pm/PackageInstaller$SessionInfo;
Landroid/content/pm/PackageInstaller$SessionParams;
Landroid/content/pm/PackageItemInfo;
Landroid/content/pm/PackageItemInfo$DisplayNameComparator;
Landroid/content/pm/PackageManager;
Landroid/content/pm/PackageManager$NameNotFoundException;
Landroid/content/pm/PackageStats;
Landroid/content/pm/PathPermission;
Landroid/content/pm/PermissionGroupInfo;
Landroid/content/pm/PermissionInfo;
Landroid/content/pm/ProviderInfo;
Landroid/content/pm/ResolveInfo;
Landroid/content/pm/ResolveInfo$DisplayNameComparator;
Landroid/content/pm/ServiceInfo;
Landroid/content/pm/SharedLibraryInfo;
Landroid/content/pm/ShortcutInfo;
Landroid/content/pm/ShortcutInfo$Builder;
Landroid/content/pm/ShortcutManager;
Landroid/content/pm/Signature;
Landroid/content/pm/VersionedPackage;
Landroid/content/QuickViewConstants;
Landroid/content/ReceiverCallNotAllowedException;
Landroid/content/res/AssetFileDescriptor;
Landroid/content/res/AssetFileDescriptor$AutoCloseInputStream;
Landroid/content/res/AssetFileDescriptor$AutoCloseOutputStream;
Landroid/content/res/AssetManager;
Landroid/content/res/AssetManager$AssetInputStream;
Landroid/content/res/ColorStateList;
Landroid/content/res/Configuration;
Landroid/content/res/ObbInfo;
Landroid/content/res/ObbScanner;
Landroid/content/res/Resources;
Landroid/content/res/Resources$NotFoundException;
Landroid/content/res/Resources$Theme;
Landroid/content/RestrictionEntry;
Landroid/content/RestrictionsManager;
Landroid/content/res/TypedArray;
Landroid/content/res/XmlResourceParser;
Landroid/content/SearchRecentSuggestionsProvider;
Landroid/content/ServiceConnection;
Landroid/content/SharedPreferences;
Landroid/content/SharedPreferences$Editor;
Landroid/content/SharedPreferences$OnSharedPreferenceChangeListener;
Landroid/content/SyncAdapterType;
Landroid/content/SyncContext;
Landroid/content/SyncInfo;
Landroid/content/SyncRequest;
Landroid/content/SyncRequest$Builder;
Landroid/content/SyncResult;
Landroid/content/SyncStats;
Landroid/content/SyncStatusObserver;
Landroid/content/UriMatcher;
Landroid/content/UriPermission;
Landroid/database/AbstractCursor;
Landroid/database/AbstractCursor$SelfContentObserver;
Landroid/database/AbstractWindowedCursor;
Landroid/database/CharArrayBuffer;
Landroid/database/ContentObservable;
Landroid/database/ContentObserver;
Landroid/database/CrossProcessCursor;
Landroid/database/CrossProcessCursorWrapper;
Landroid/database/Cursor;
Landroid/database/CursorIndexOutOfBoundsException;
Landroid/database/CursorJoiner;
Landroid/database/CursorJoiner$Result;
Landroid/database/CursorWindow;
Landroid/database/CursorWrapper;
Landroid/database/DatabaseErrorHandler;
Landroid/database/DatabaseUtils;
Landroid/database/DatabaseUtils$InsertHelper;
Landroid/database/DataSetObservable;
Landroid/database/DataSetObserver;
Landroid/database/DefaultDatabaseErrorHandler;
Landroid/database/MatrixCursor;
Landroid/database/MatrixCursor$RowBuilder;
Landroid/database/MergeCursor;
Landroid/database/Observable;
Landroid/database/SQLException;
Landroid/database/sqlite/SQLiteAbortException;
Landroid/database/sqlite/SQLiteAccessPermException;
Landroid/database/sqlite/SQLiteBindOrColumnIndexOutOfRangeException;
Landroid/database/sqlite/SQLiteBlobTooBigException;
Landroid/database/sqlite/SQLiteCantOpenDatabaseException;
Landroid/database/sqlite/SQLiteClosable;
Landroid/database/sqlite/SQLiteConstraintException;
Landroid/database/sqlite/SQLiteCursor;
Landroid/database/sqlite/SQLiteCursorDriver;
Landroid/database/sqlite/SQLiteDatabase;
Landroid/database/sqlite/SQLiteDatabaseCorruptException;
Landroid/database/sqlite/SQLiteDatabase$CursorFactory;
Landroid/database/sqlite/SQLiteDatabaseLockedException;
Landroid/database/sqlite/SQLiteDatabase$OpenParams;
Landroid/database/sqlite/SQLiteDatabase$OpenParams$Builder;
Landroid/database/sqlite/SQLiteDatatypeMismatchException;
Landroid/database/sqlite/SQLiteDiskIOException;
Landroid/database/sqlite/SQLiteDoneException;
Landroid/database/sqlite/SQLiteException;
Landroid/database/sqlite/SQLiteFullException;
Landroid/database/sqlite/SQLiteMisuseException;
Landroid/database/sqlite/SQLiteOpenHelper;
Landroid/database/sqlite/SQLiteOutOfMemoryException;
Landroid/database/sqlite/SQLiteProgram;
Landroid/database/sqlite/SQLiteQuery;
Landroid/database/sqlite/SQLiteQueryBuilder;
Landroid/database/sqlite/SQLiteReadOnlyDatabaseException;
Landroid/database/sqlite/SQLiteStatement;
Landroid/database/sqlite/SQLiteTableLockedException;
Landroid/database/sqlite/SQLiteTransactionListener;
Landroid/database/StaleDataException;
Landroid/databinding/BaseObservable;
Landroid/databinding/Bindable;
Landroid/databinding/BindingAdapter;
Landroid/databinding/BindingConversion;
Landroid/databinding/BindingMethod;
Landroid/databinding/BindingMethods;
Landroid/databinding/CallbackRegistry;
Landroid/databinding/CallbackRegistry$NotifierCallback;
Landroid/databinding/DataBindingComponent;
Landroid/databinding/DataBindingUtil;
Landroid/databinding/InverseBindingAdapter;
Landroid/databinding/InverseBindingListener;
Landroid/databinding/InverseBindingMethod;
Landroid/databinding/InverseBindingMethods;
Landroid/databinding/ListChangeRegistry;
Landroid/databinding/MapChangeRegistry;
Landroid/databinding/Observable;
Landroid/databinding/ObservableArrayList;
Landroid/databinding/ObservableArrayMap;
Landroid/databinding/ObservableBoolean;
Landroid/databinding/ObservableByte;
Landroid/databinding/ObservableChar;
Landroid/databinding/ObservableDouble;
Landroid/databinding/ObservableField;
Landroid/databinding/ObservableFloat;
Landroid/databinding/ObservableInt;
Landroid/databinding/ObservableList;
Landroid/databinding/ObservableList$OnListChangedCallback;
Landroid/databinding/ObservableLong;
Landroid/databinding/ObservableMap;
Landroid/databinding/ObservableMap$OnMapChangedCallback;
Landroid/databinding/Observable$OnPropertyChangedCallback;
Landroid/databinding/ObservableParcelable;
Landroid/databinding/ObservableShort;
Landroid/databinding/OnRebindCallback;
Landroid/databinding/PropertyChangeRegistry;
Landroid/databinding/ViewDataBinding;
Landroid/databinding/ViewStubProxy;
Landroid/drm/DrmConvertedStatus;
Landroid/drm/DrmErrorEvent;
Landroid/drm/DrmEvent;
Landroid/drm/DrmInfo;
Landroid/drm/DrmInfoEvent;
Landroid/drm/DrmInfoRequest;
Landroid/drm/DrmInfoStatus;
Landroid/drm/DrmManagerClient;
Landroid/drm/DrmManagerClient$OnErrorListener;
Landroid/drm/DrmManagerClient$OnEventListener;
Landroid/drm/DrmManagerClient$OnInfoListener;
Landroid/drm/DrmRights;
Landroid/drm/DrmStore;
Landroid/drm/DrmStore$Action;
Landroid/drm/DrmStore$ConstraintsColumns;
Landroid/drm/DrmStore$DrmObjectType;
Landroid/drm/DrmStore$Playback;
Landroid/drm/DrmStore$RightsStatus;
Landroid/drm/DrmSupportInfo;
Landroid/drm/DrmUtils;
Landroid/drm/DrmUtils$ExtendedMetadataParser;
Landroid/drm/ProcessedData;
Landroid/gesture/Gesture;
Landroid/gesture/GestureLibraries;
Landroid/gesture/GestureLibrary;
Landroid/gesture/GestureOverlayView;
Landroid/gesture/GestureOverlayView$OnGestureListener;
Landroid/gesture/GestureOverlayView$OnGesturePerformedListener;
Landroid/gesture/GestureOverlayView$OnGesturingListener;
Landroid/gesture/GesturePoint;
Landroid/gesture/GestureStore;
Landroid/gesture/GestureStroke;
Landroid/gesture/GestureUtils;
Landroid/gesture/OrientedBoundingBox;
Landroid/gesture/Prediction;
Landroid/graphics/Bitmap;
Landroid/graphics/Bitmap$CompressFormat;
Landroid/graphics/Bitmap$Config;
Landroid/graphics/BitmapFactory;
Landroid/graphics/BitmapFactory$Options;
Landroid/graphics/BitmapRegionDecoder;
Landroid/graphics/BitmapShader;
Landroid/graphics/BlurMaskFilter;
Landroid/graphics/BlurMaskFilter$Blur;
Landroid/graphics/Camera;
Landroid/graphics/Canvas;
Landroid/graphics/Canvas$EdgeType;
Landroid/graphics/Canvas$VertexMode;
Landroid/graphics/Color;
Landroid/graphics/ColorFilter;
Landroid/graphics/ColorMatrix;
Landroid/graphics/ColorMatrixColorFilter;
Landroid/graphics/ColorSpace;
Landroid/graphics/ColorSpace$Adaptation;
Landroid/graphics/ColorSpace$Connector;
Landroid/graphics/ColorSpace$Model;
Landroid/graphics/ColorSpace$Named;
Landroid/graphics/ColorSpace$RenderIntent;
Landroid/graphics/ColorSpace$Rgb;
Landroid/graphics/ColorSpace$Rgb$TransferParameters;
Landroid/graphics/ComposePathEffect;
Landroid/graphics/ComposeShader;
Landroid/graphics/CornerPathEffect;
Landroid/graphics/DashPathEffect;
Landroid/graphics/DiscretePathEffect;
Landroid/graphics/drawable/AdaptiveIconDrawable;
Landroid/graphics/drawable/Animatable;
Landroid/graphics/drawable/Animatable2;
Landroid/graphics/drawable/Animatable2$AnimationCallback;
Landroid/graphics/drawable/AnimatedStateListDrawable;
Landroid/graphics/drawable/AnimatedVectorDrawable;
Landroid/graphics/drawable/AnimationDrawable;
Landroid/graphics/drawable/BitmapDrawable;
Landroid/graphics/drawable/ClipDrawable;
Landroid/graphics/drawable/ColorDrawable;
Landroid/graphics/drawable/Drawable;
Landroid/graphics/drawable/Drawable$Callback;
Landroid/graphics/drawable/Drawable$ConstantState;
Landroid/graphics/drawable/DrawableContainer;
Landroid/graphics/drawable/DrawableContainer$DrawableContainerState;
Landroid/graphics/drawable/DrawableWrapper;
Landroid/graphics/drawable/GradientDrawable;
Landroid/graphics/drawable/GradientDrawable$Orientation;
Landroid/graphics/drawable/Icon;
Landroid/graphics/drawable/Icon$OnDrawableLoadedListener;
Landroid/graphics/drawable/InsetDrawable;
Landroid/graphics/drawable/LayerDrawable;
Landroid/graphics/drawable/LevelListDrawable;
Landroid/graphics/drawable/NinePatchDrawable;
Landroid/graphics/drawable/PaintDrawable;
Landroid/graphics/drawable/PictureDrawable;
Landroid/graphics/drawable/RippleDrawable;
Landroid/graphics/drawable/RotateDrawable;
Landroid/graphics/drawable/ScaleDrawable;
Landroid/graphics/drawable/ShapeDrawable;
Landroid/graphics/drawable/ShapeDrawable$ShaderFactory;
Landroid/graphics/drawable/shapes/ArcShape;
Landroid/graphics/drawable/shapes/OvalShape;
Landroid/graphics/drawable/shapes/PathShape;
Landroid/graphics/drawable/shapes/RectShape;
Landroid/graphics/drawable/shapes/RoundRectShape;
Landroid/graphics/drawable/shapes/Shape;
Landroid/graphics/drawable/StateListDrawable;
Landroid/graphics/drawable/TransitionDrawable;
Landroid/graphics/drawable/VectorDrawable;
Landroid/graphics/DrawFilter;
Landroid/graphics/EmbossMaskFilter;
Landroid/graphics/fonts/FontVariationAxis;
Landroid/graphics/ImageFormat;
Landroid/graphics/Interpolator;
Landroid/graphics/Interpolator$Result;
Landroid/graphics/LightingColorFilter;
Landroid/graphics/LinearGradient;
Landroid/graphics/MaskFilter;
Landroid/graphics/Matrix;
Landroid/graphics/Matrix$ScaleToFit;
Landroid/graphics/Movie;
Landroid/graphics/NinePatch;
Landroid/graphics/Outline;
Landroid/graphics/Paint;
Landroid/graphics/Paint$Align;
Landroid/graphics/Paint$Cap;
Landroid/graphics/PaintFlagsDrawFilter;
Landroid/graphics/Paint$FontMetrics;
Landroid/graphics/Paint$FontMetricsInt;
Landroid/graphics/Paint$Join;
Landroid/graphics/Paint$Style;
Landroid/graphics/Path;
Landroid/graphics/PathDashPathEffect;
Landroid/graphics/PathDashPathEffect$Style;
Landroid/graphics/Path$Direction;
Landroid/graphics/PathEffect;
Landroid/graphics/Path$FillType;
Landroid/graphics/PathMeasure;
Landroid/graphics/Path$Op;
Landroid/graphics/pdf/PdfDocument;
Landroid/graphics/pdf/PdfDocument$Page;
Landroid/graphics/pdf/PdfDocument$PageInfo;
Landroid/graphics/pdf/PdfDocument$PageInfo$Builder;
Landroid/graphics/pdf/PdfRenderer;
Landroid/graphics/pdf/PdfRenderer$Page;
Landroid/graphics/Picture;
Landroid/graphics/PixelFormat;
Landroid/graphics/Point;
Landroid/graphics/PointF;
Landroid/graphics/PorterDuff;
Landroid/graphics/PorterDuffColorFilter;
Landroid/graphics/PorterDuff$Mode;
Landroid/graphics/PorterDuffXfermode;
Landroid/graphics/RadialGradient;
Landroid/graphics/Rect;
Landroid/graphics/RectF;
Landroid/graphics/Region;
Landroid/graphics/RegionIterator;
Landroid/graphics/Region$Op;
Landroid/graphics/Shader;
Landroid/graphics/Shader$TileMode;
Landroid/graphics/SumPathEffect;
Landroid/graphics/SurfaceTexture;
Landroid/graphics/SurfaceTexture$OnFrameAvailableListener;
Landroid/graphics/SurfaceTexture$OutOfResourcesException;
Landroid/graphics/SweepGradient;
Landroid/graphics/Typeface;
Landroid/graphics/Typeface$Builder;
Landroid/graphics/Xfermode;
Landroid/graphics/YuvImage;
Landroid/hardware/Camera;
Landroid/hardware/camera2/CameraAccessException;
Landroid/hardware/camera2/CameraCaptureSession;
Landroid/hardware/camera2/CameraCaptureSession$CaptureCallback;
Landroid/hardware/camera2/CameraCaptureSession$StateCallback;
Landroid/hardware/camera2/CameraCharacteristics;
Landroid/hardware/camera2/CameraCharacteristics$Key;
Landroid/hardware/camera2/CameraConstrainedHighSpeedCaptureSession;
Landroid/hardware/camera2/CameraDevice;
Landroid/hardware/camera2/CameraDevice$StateCallback;
Landroid/hardware/camera2/CameraManager;
Landroid/hardware/camera2/CameraManager$AvailabilityCallback;
Landroid/hardware/camera2/CameraManager$TorchCallback;
Landroid/hardware/camera2/CameraMetadata;
Landroid/hardware/camera2/CaptureFailure;
Landroid/hardware/camera2/CaptureRequest;
Landroid/hardware/camera2/CaptureRequest$Builder;
Landroid/hardware/camera2/CaptureRequest$Key;
Landroid/hardware/camera2/CaptureResult;
Landroid/hardware/camera2/CaptureResult$Key;
Landroid/hardware/camera2/DngCreator;
Landroid/hardware/camera2/params/BlackLevelPattern;
Landroid/hardware/camera2/params/ColorSpaceTransform;
Landroid/hardware/camera2/params/Face;
Landroid/hardware/camera2/params/InputConfiguration;
Landroid/hardware/camera2/params/LensShadingMap;
Landroid/hardware/camera2/params/MeteringRectangle;
Landroid/hardware/camera2/params/OutputConfiguration;
Landroid/hardware/camera2/params/RggbChannelVector;
Landroid/hardware/camera2/params/StreamConfigurationMap;
Landroid/hardware/camera2/params/TonemapCurve;
Landroid/hardware/camera2/TotalCaptureResult;
Landroid/hardware/Camera$Area;
Landroid/hardware/Camera$AutoFocusCallback;
Landroid/hardware/Camera$AutoFocusMoveCallback;
Landroid/hardware/Camera$CameraInfo;
Landroid/hardware/Camera$ErrorCallback;
Landroid/hardware/Camera$Face;
Landroid/hardware/Camera$FaceDetectionListener;
Landroid/hardware/Camera$OnZoomChangeListener;
Landroid/hardware/Camera$Parameters;
Landroid/hardware/Camera$PictureCallback;
Landroid/hardware/Camera$PreviewCallback;
Landroid/hardware/Camera$ShutterCallback;
Landroid/hardware/Camera$Size;
Landroid/hardware/ConsumerIrManager;
Landroid/hardware/ConsumerIrManager$CarrierFrequencyRange;
Landroid/hardware/display/DisplayManager;
Landroid/hardware/display/DisplayManager$DisplayListener;
Landroid/hardware/display/VirtualDisplay;
Landroid/hardware/display/VirtualDisplay$Callback;
Landroid/hardware/fingerprint/FingerprintManager;
Landroid/hardware/fingerprint/FingerprintManager$AuthenticationCallback;
Landroid/hardware/fingerprint/FingerprintManager$AuthenticationResult;
Landroid/hardware/fingerprint/FingerprintManager$CryptoObject;
Landroid/hardware/GeomagneticField;
Landroid/hardware/HardwareBuffer;
Landroid/hardware/input/InputManager;
Landroid/hardware/input/InputManager$InputDeviceListener;
Landroid/hardware/Sensor;
Landroid/hardware/SensorAdditionalInfo;
Landroid/hardware/SensorDirectChannel;
Landroid/hardware/SensorEvent;
Landroid/hardware/SensorEventCallback;
Landroid/hardware/SensorEventListener;
Landroid/hardware/SensorEventListener2;
Landroid/hardware/SensorListener;
Landroid/hardware/SensorManager;
Landroid/hardware/SensorManager$DynamicSensorCallback;
Landroid/hardware/TriggerEvent;
Landroid/hardware/TriggerEventListener;
Landroid/hardware/usb/UsbAccessory;
Landroid/hardware/usb/UsbConfiguration;
Landroid/hardware/usb/UsbConstants;
Landroid/hardware/usb/UsbDevice;
Landroid/hardware/usb/UsbDeviceConnection;
Landroid/hardware/usb/UsbEndpoint;
Landroid/hardware/usb/UsbInterface;
Landroid/hardware/usb/UsbManager;
Landroid/hardware/usb/UsbRequest;
Landroid/icu/lang/UCharacter;
Landroid/icu/lang/UCharacter$BidiPairedBracketType;
Landroid/icu/lang/UCharacterCategory;
Landroid/icu/lang/UCharacter$DecompositionType;
Landroid/icu/lang/UCharacterDirection;
Landroid/icu/lang/UCharacter$EastAsianWidth;
Landroid/icu/lang/UCharacterEnums;
Landroid/icu/lang/UCharacterEnums$ECharacterCategory;
Landroid/icu/lang/UCharacterEnums$ECharacterDirection;
Landroid/icu/lang/UCharacter$GraphemeClusterBreak;
Landroid/icu/lang/UCharacter$HangulSyllableType;
Landroid/icu/lang/UCharacter$JoiningGroup;
Landroid/icu/lang/UCharacter$JoiningType;
Landroid/icu/lang/UCharacter$LineBreak;
Landroid/icu/lang/UCharacter$NumericType;
Landroid/icu/lang/UCharacter$SentenceBreak;
Landroid/icu/lang/UCharacter$UnicodeBlock;
Landroid/icu/lang/UCharacter$WordBreak;
Landroid/icu/lang/UProperty;
Landroid/icu/lang/UProperty$NameChoice;
Landroid/icu/lang/UScript;
Landroid/icu/lang/UScript$ScriptUsage;
Landroid/icu/math/BigDecimal;
Landroid/icu/math/MathContext;
Landroid/icu/text/AlphabeticIndex;
Landroid/icu/text/AlphabeticIndex$Bucket;
Landroid/icu/text/AlphabeticIndex$Bucket$LabelType;
Landroid/icu/text/AlphabeticIndex$ImmutableIndex;
Landroid/icu/text/AlphabeticIndex$Record;
Landroid/icu/text/BreakIterator;
Landroid/icu/text/CollationElementIterator;
Landroid/icu/text/CollationKey;
Landroid/icu/text/CollationKey$BoundMode;
Landroid/icu/text/Collator;
Landroid/icu/text/Collator$ReorderCodes;
Landroid/icu/text/CompactDecimalFormat;
Landroid/icu/text/CompactDecimalFormat$CompactStyle;
Landroid/icu/text/CurrencyPluralInfo;
Landroid/icu/text/DateFormat;
Landroid/icu/text/DateFormat$BooleanAttribute;
Landroid/icu/text/DateFormat$Field;
Landroid/icu/text/DateFormatSymbols;
Landroid/icu/text/DateIntervalFormat;
Landroid/icu/text/DateIntervalInfo;
Landroid/icu/text/DateIntervalInfo$PatternInfo;
Landroid/icu/text/DateTimePatternGenerator;
Landroid/icu/text/DateTimePatternGenerator$PatternInfo;
Landroid/icu/text/DecimalFormat;
Landroid/icu/text/DecimalFormatSymbols;
Landroid/icu/text/DisplayContext;
Landroid/icu/text/DisplayContext$Type;
Landroid/icu/text/IDNA;
Landroid/icu/text/IDNA$Error;
Landroid/icu/text/IDNA$Info;
Landroid/icu/text/ListFormatter;
Landroid/icu/text/LocaleDisplayNames;
Landroid/icu/text/LocaleDisplayNames$DialectHandling;
Landroid/icu/text/LocaleDisplayNames$UiListItem;
Landroid/icu/text/MeasureFormat;
Landroid/icu/text/MeasureFormat$FormatWidth;
Landroid/icu/text/MessageFormat;
Landroid/icu/text/MessageFormat$Field;
Landroid/icu/text/MessagePattern;
Landroid/icu/text/MessagePattern$ApostropheMode;
Landroid/icu/text/MessagePattern$ArgType;
Landroid/icu/text/MessagePattern$Part;
Landroid/icu/text/MessagePattern$Part$Type;
Landroid/icu/text/Normalizer;
Landroid/icu/text/Normalizer2;
Landroid/icu/text/Normalizer2$Mode;
Landroid/icu/text/Normalizer$QuickCheckResult;
Landroid/icu/text/NumberFormat;
Landroid/icu/text/NumberFormat$Field;
Landroid/icu/text/NumberingSystem;
Landroid/icu/text/PluralFormat;
Landroid/icu/text/PluralRules;
Landroid/icu/text/PluralRules$PluralType;
Landroid/icu/text/RelativeDateTimeFormatter;
Landroid/icu/text/RelativeDateTimeFormatter$AbsoluteUnit;
Landroid/icu/text/RelativeDateTimeFormatter$Direction;
Landroid/icu/text/RelativeDateTimeFormatter$RelativeUnit;
Landroid/icu/text/RelativeDateTimeFormatter$Style;
Landroid/icu/text/Replaceable;
Landroid/icu/text/RuleBasedCollator;
Landroid/icu/text/ScientificNumberFormatter;
Landroid/icu/text/SearchIterator;
Landroid/icu/text/SearchIterator$ElementComparisonType;
Landroid/icu/text/SelectFormat;
Landroid/icu/text/SimpleDateFormat;
Landroid/icu/text/StringPrepParseException;
Landroid/icu/text/StringSearch;
Landroid/icu/text/SymbolTable;
Landroid/icu/text/TimeZoneFormat;
Landroid/icu/text/TimeZoneFormat$GMTOffsetPatternType;
Landroid/icu/text/TimeZoneFormat$ParseOption;
Landroid/icu/text/TimeZoneFormat$Style;
Landroid/icu/text/TimeZoneFormat$TimeType;
Landroid/icu/text/TimeZoneNames;
Landroid/icu/text/TimeZoneNames$NameType;
Landroid/icu/text/UCharacterIterator;
Landroid/icu/text/UFormat;
Landroid/icu/text/UnicodeFilter;
Landroid/icu/text/UnicodeMatcher;
Landroid/icu/text/UnicodeSet;
Landroid/icu/text/UnicodeSet$ComparisonStyle;
Landroid/icu/text/UnicodeSet$EntryRange;
Landroid/icu/text/UnicodeSetIterator;
Landroid/icu/text/UnicodeSet$SpanCondition;
Landroid/icu/text/UnicodeSetSpanner;
Landroid/icu/text/UnicodeSetSpanner$CountMethod;
Landroid/icu/text/UnicodeSetSpanner$TrimOption;
Landroid/icu/util/BuddhistCalendar;
Landroid/icu/util/Calendar;
Landroid/icu/util/Calendar$WeekData;
Landroid/icu/util/ChineseCalendar;
Landroid/icu/util/CopticCalendar;
Landroid/icu/util/Currency;
Landroid/icu/util/CurrencyAmount;
Landroid/icu/util/Currency$CurrencyUsage;
Landroid/icu/util/DateInterval;
Landroid/icu/util/EthiopicCalendar;
Landroid/icu/util/Freezable;
Landroid/icu/util/GregorianCalendar;
Landroid/icu/util/HebrewCalendar;
Landroid/icu/util/ICUUncheckedIOException;
Landroid/icu/util/IndianCalendar;
Landroid/icu/util/IslamicCalendar;
Landroid/icu/util/IslamicCalendar$CalculationType;
Landroid/icu/util/JapaneseCalendar;
Landroid/icu/util/Measure;
Landroid/icu/util/MeasureUnit;
Landroid/icu/util/Output;
Landroid/icu/util/RangeValueIterator;
Landroid/icu/util/RangeValueIterator$Element;
Landroid/icu/util/TaiwanCalendar;
Landroid/icu/util/TimeUnit;
Landroid/icu/util/TimeZone;
Landroid/icu/util/TimeZone$SystemTimeZoneType;
Landroid/icu/util/ULocale;
Landroid/icu/util/ULocale$Builder;
Landroid/icu/util/ULocale$Category;
Landroid/icu/util/UniversalTimeScale;
Landroid/icu/util/ValueIterator;
Landroid/icu/util/ValueIterator$Element;
Landroid/icu/util/VersionInfo;
Landroid/inputmethodservice/AbstractInputMethodService;
Landroid/inputmethodservice/AbstractInputMethodService$AbstractInputMethodImpl;
Landroid/inputmethodservice/AbstractInputMethodService$AbstractInputMethodSessionImpl;
Landroid/inputmethodservice/ExtractEditText;
Landroid/inputmethodservice/InputMethodService;
Landroid/inputmethodservice/InputMethodService$InputMethodImpl;
Landroid/inputmethodservice/InputMethodService$InputMethodSessionImpl;
Landroid/inputmethodservice/InputMethodService$Insets;
Landroid/inputmethodservice/Keyboard;
Landroid/inputmethodservice/Keyboard$Key;
Landroid/inputmethodservice/Keyboard$Row;
Landroid/inputmethodservice/KeyboardView;
Landroid/inputmethodservice/KeyboardView$OnKeyboardActionListener;
Landroid/location/Address;
Landroid/location/Criteria;
Landroid/location/Geocoder;
Landroid/location/GnssClock;
Landroid/location/GnssMeasurement;
Landroid/location/GnssMeasurementsEvent;
Landroid/location/GnssMeasurementsEvent$Callback;
Landroid/location/GnssNavigationMessage;
Landroid/location/GnssNavigationMessage$Callback;
Landroid/location/GnssStatus;
Landroid/location/GnssStatus$Callback;
Landroid/location/GpsSatellite;
Landroid/location/GpsStatus;
Landroid/location/GpsStatus$Listener;
Landroid/location/GpsStatus$NmeaListener;
Landroid/location/Location;
Landroid/location/LocationListener;
Landroid/location/LocationManager;
Landroid/location/LocationProvider;
Landroid/location/OnNmeaMessageListener;
Landroid/location/SettingInjectorService;
Landroid/Manifest;
Landroid/Manifest$permission;
Landroid/Manifest$permission_group;
Landroid/media/AsyncPlayer;
Landroid/media/AudioAttributes;
Landroid/media/AudioAttributes$Builder;
Landroid/media/AudioDeviceCallback;
Landroid/media/AudioDeviceInfo;
Landroid/media/AudioFocusRequest;
Landroid/media/AudioFocusRequest$Builder;
Landroid/media/AudioFormat;
Landroid/media/AudioFormat$Builder;
Landroid/media/audiofx/AcousticEchoCanceler;
Landroid/media/audiofx/AudioEffect;
Landroid/media/audiofx/AudioEffect$Descriptor;
Landroid/media/audiofx/AudioEffect$OnControlStatusChangeListener;
Landroid/media/audiofx/AudioEffect$OnEnableStatusChangeListener;
Landroid/media/audiofx/AutomaticGainControl;
Landroid/media/audiofx/BassBoost;
Landroid/media/audiofx/BassBoost$OnParameterChangeListener;
Landroid/media/audiofx/BassBoost$Settings;
Landroid/media/audiofx/EnvironmentalReverb;
Landroid/media/audiofx/EnvironmentalReverb$OnParameterChangeListener;
Landroid/media/audiofx/EnvironmentalReverb$Settings;
Landroid/media/audiofx/Equalizer;
Landroid/media/audiofx/Equalizer$OnParameterChangeListener;
Landroid/media/audiofx/Equalizer$Settings;
Landroid/media/audiofx/LoudnessEnhancer;
Landroid/media/audiofx/NoiseSuppressor;
Landroid/media/audiofx/PresetReverb;
Landroid/media/audiofx/PresetReverb$OnParameterChangeListener;
Landroid/media/audiofx/PresetReverb$Settings;
Landroid/media/audiofx/Virtualizer;
Landroid/media/audiofx/Virtualizer$OnParameterChangeListener;
Landroid/media/audiofx/Virtualizer$Settings;
Landroid/media/audiofx/Visualizer;
Landroid/media/audiofx/Visualizer$MeasurementPeakRms;
Landroid/media/audiofx/Visualizer$OnDataCaptureListener;
Landroid/media/AudioManager;
Landroid/media/AudioManager$AudioPlaybackCallback;
Landroid/media/AudioManager$AudioRecordingCallback;
Landroid/media/AudioManager$OnAudioFocusChangeListener;
Landroid/media/AudioPlaybackConfiguration;
Landroid/media/AudioRecord;
Landroid/media/AudioRecord$Builder;
Landroid/media/AudioRecordingConfiguration;
Landroid/media/AudioRecord$OnRecordPositionUpdateListener;
Landroid/media/AudioRecord$OnRoutingChangedListener;
Landroid/media/AudioRouting;
Landroid/media/AudioRouting$OnRoutingChangedListener;
Landroid/media/AudioTimestamp;
Landroid/media/AudioTrack;
Landroid/media/AudioTrack$Builder;
Landroid/media/AudioTrack$OnPlaybackPositionUpdateListener;
Landroid/media/AudioTrack$OnRoutingChangedListener;
Landroid/media/browse/MediaBrowser;
Landroid/media/browse/MediaBrowser$ConnectionCallback;
Landroid/media/browse/MediaBrowser$ItemCallback;
Landroid/media/browse/MediaBrowser$MediaItem;
Landroid/media/browse/MediaBrowser$SubscriptionCallback;
Landroid/media/CamcorderProfile;
Landroid/media/CameraProfile;
Landroid/media/DeniedByServerException;
Landroid/media/DrmInitData;
Landroid/media/DrmInitData$SchemeInitData;
Landroid/media/effect/Effect;
Landroid/media/effect/EffectContext;
Landroid/media/effect/EffectFactory;
Landroid/media/effect/EffectUpdateListener;
Landroid/media/ExifInterface;
Landroid/media/FaceDetector;
Landroid/media/FaceDetector$Face;
Landroid/media/Image;
Landroid/media/Image$Plane;
Landroid/media/ImageReader;
Landroid/media/ImageReader$OnImageAvailableListener;
Landroid/media/ImageWriter;
Landroid/media/ImageWriter$OnImageReleasedListener;
Landroid/media/JetPlayer;
Landroid/media/JetPlayer$OnJetEventListener;
Landroid/media/MediaActionSound;
Landroid/media/MediaCas;
Landroid/media/MediaCas$EventListener;
Landroid/media/MediaCasException;
Landroid/media/MediaCasException$DeniedByServerException;
Landroid/media/MediaCasException$NotProvisionedException;
Landroid/media/MediaCasException$ResourceBusyException;
Landroid/media/MediaCasException$UnsupportedCasException;
Landroid/media/MediaCas$PluginDescriptor;
Landroid/media/MediaCas$Session;
Landroid/media/MediaCasStateException;
Landroid/media/MediaCodec;
Landroid/media/MediaCodec$BufferInfo;
Landroid/media/MediaCodec$Callback;
Landroid/media/MediaCodec$CodecException;
Landroid/media/MediaCodec$CryptoException;
Landroid/media/MediaCodec$CryptoInfo;
Landroid/media/MediaCodec$CryptoInfo$Pattern;
Landroid/media/MediaCodecInfo;
Landroid/media/MediaCodecInfo$AudioCapabilities;
Landroid/media/MediaCodecInfo$CodecCapabilities;
Landroid/media/MediaCodecInfo$CodecProfileLevel;
Landroid/media/MediaCodecInfo$EncoderCapabilities;
Landroid/media/MediaCodecInfo$VideoCapabilities;
Landroid/media/MediaCodecList;
Landroid/media/MediaCodec$MetricsConstants;
Landroid/media/MediaCodec$OnFrameRenderedListener;
Landroid/media/MediaCrypto;
Landroid/media/MediaCryptoException;
Landroid/media/MediaDataSource;
Landroid/media/MediaDescrambler;
Landroid/media/MediaDescription;
Landroid/media/MediaDescription$Builder;
Landroid/media/MediaDrm;
Landroid/media/MediaDrm$CryptoSession;
Landroid/media/MediaDrmException;
Landroid/media/MediaDrm$KeyRequest;
Landroid/media/MediaDrm$KeyStatus;
Landroid/media/MediaDrm$MediaDrmStateException;
Landroid/media/MediaDrm$OnEventListener;
Landroid/media/MediaDrm$OnExpirationUpdateListener;
Landroid/media/MediaDrm$OnKeyStatusChangeListener;
Landroid/media/MediaDrm$ProvisionRequest;
Landroid/media/MediaDrmResetException;
Landroid/media/MediaExtractor;
Landroid/media/MediaExtractor$CasInfo;
Landroid/media/MediaExtractor$MetricsConstants;
Landroid/media/MediaFormat;
Landroid/media/MediaMetadata;
Landroid/media/MediaMetadata$Builder;
Landroid/media/MediaMetadataEditor;
Landroid/media/MediaMetadataRetriever;
Landroid/media/MediaMuxer;
Landroid/media/MediaMuxer$OutputFormat;
Landroid/media/MediaPlayer;
Landroid/media/MediaPlayer$DrmInfo;
Landroid/media/MediaPlayer$MetricsConstants;
Landroid/media/MediaPlayer$NoDrmSchemeException;
Landroid/media/MediaPlayer$OnBufferingUpdateListener;
Landroid/media/MediaPlayer$OnCompletionListener;
Landroid/media/MediaPlayer$OnDrmConfigHelper;
Landroid/media/MediaPlayer$OnDrmInfoListener;
Landroid/media/MediaPlayer$OnDrmPreparedListener;
Landroid/media/MediaPlayer$OnErrorListener;
Landroid/media/MediaPlayer$OnInfoListener;
Landroid/media/MediaPlayer$OnPreparedListener;
Landroid/media/MediaPlayer$OnSeekCompleteListener;
Landroid/media/MediaPlayer$OnTimedMetaDataAvailableListener;
Landroid/media/MediaPlayer$OnTimedTextListener;
Landroid/media/MediaPlayer$OnVideoSizeChangedListener;
Landroid/media/MediaPlayer$ProvisioningNetworkErrorException;
Landroid/media/MediaPlayer$ProvisioningServerErrorException;
Landroid/media/MediaPlayer$TrackInfo;
Landroid/media/MediaRecorder;
Landroid/media/MediaRecorder$AudioEncoder;
Landroid/media/MediaRecorder$AudioSource;
Landroid/media/MediaRecorder$MetricsConstants;
Landroid/media/MediaRecorder$OnErrorListener;
Landroid/media/MediaRecorder$OnInfoListener;
Landroid/media/MediaRecorder$OutputFormat;
Landroid/media/MediaRecorder$VideoEncoder;
Landroid/media/MediaRecorder$VideoSource;
Landroid/media/MediaRouter;
Landroid/media/MediaRouter$Callback;
Landroid/media/MediaRouter$RouteCategory;
Landroid/media/MediaRouter$RouteGroup;
Landroid/media/MediaRouter$RouteInfo;
Landroid/media/MediaRouter$SimpleCallback;
Landroid/media/MediaRouter$UserRouteInfo;
Landroid/media/MediaRouter$VolumeCallback;
Landroid/media/MediaScannerConnection;
Landroid/media/MediaScannerConnection$MediaScannerConnectionClient;
Landroid/media/MediaScannerConnection$OnScanCompletedListener;
Landroid/media/MediaSync;
Landroid/media/MediaSync$Callback;
Landroid/media/MediaSyncEvent;
Landroid/media/MediaSync$OnErrorListener;
Landroid/media/MediaTimestamp;
Landroid/media/midi/MidiDevice;
Landroid/media/midi/MidiDeviceInfo;
Landroid/media/midi/MidiDeviceInfo$PortInfo;
Landroid/media/midi/MidiDevice$MidiConnection;
Landroid/media/midi/MidiDeviceService;
Landroid/media/midi/MidiDeviceStatus;
Landroid/media/midi/MidiInputPort;
Landroid/media/midi/MidiManager;
Landroid/media/midi/MidiManager$DeviceCallback;
Landroid/media/midi/MidiManager$OnDeviceOpenedListener;
Landroid/media/midi/MidiOutputPort;
Landroid/media/midi/MidiReceiver;
Landroid/media/midi/MidiSender;
Landroid/media/NotProvisionedException;
Landroid/media/PlaybackParams;
Landroid/media/projection/MediaProjection;
Landroid/media/projection/MediaProjection$Callback;
Landroid/media/projection/MediaProjectionManager;
Landroid/media/Rating;
Landroid/media/RemoteControlClient;
Landroid/media/RemoteControlClient$MetadataEditor;
Landroid/media/RemoteControlClient$OnGetPlaybackPositionListener;
Landroid/media/RemoteControlClient$OnMetadataUpdateListener;
Landroid/media/RemoteControlClient$OnPlaybackPositionUpdateListener;
Landroid/media/RemoteController;
Landroid/media/RemoteController$MetadataEditor;
Landroid/media/RemoteController$OnClientUpdateListener;
Landroid/media/ResourceBusyException;
Landroid/media/Ringtone;
Landroid/media/RingtoneManager;
Landroid/media/session/MediaController;
Landroid/media/session/MediaController$Callback;
Landroid/media/session/MediaController$PlaybackInfo;
Landroid/media/session/MediaController$TransportControls;
Landroid/media/session/MediaSession;
Landroid/media/session/MediaSession$Callback;
Landroid/media/session/MediaSessionManager;
Landroid/media/session/MediaSessionManager$OnActiveSessionsChangedListener;
Landroid/media/session/MediaSession$QueueItem;
Landroid/media/session/MediaSession$Token;
Landroid/media/session/PlaybackState;
Landroid/media/session/PlaybackState$Builder;
Landroid/media/session/PlaybackState$CustomAction;
Landroid/media/session/PlaybackState$CustomAction$Builder;
Landroid/media/SoundPool;
Landroid/media/SoundPool$Builder;
Landroid/media/SoundPool$OnLoadCompleteListener;
Landroid/media/SyncParams;
Landroid/media/ThumbnailUtils;
Landroid/media/TimedMetaData;
Landroid/media/TimedText;
Landroid/media/ToneGenerator;
Landroid/media/tv/TvContentRating;
Landroid/media/tv/TvContract;
Landroid/media/tv/TvContract$BaseTvColumns;
Landroid/media/tv/TvContract$Channels;
Landroid/media/tv/TvContract$Channels$Logo;
Landroid/media/tv/TvContract$PreviewPrograms;
Landroid/media/tv/TvContract$Programs;
Landroid/media/tv/TvContract$Programs$Genres;
Landroid/media/tv/TvContract$RecordedPrograms;
Landroid/media/tv/TvContract$WatchNextPrograms;
Landroid/media/tv/TvInputInfo;
Landroid/media/tv/TvInputInfo$Builder;
Landroid/media/tv/TvInputManager;
Landroid/media/tv/TvInputManager$TvInputCallback;
Landroid/media/tv/TvInputService;
Landroid/media/tv/TvInputService$HardwareSession;
Landroid/media/tv/TvInputService$RecordingSession;
Landroid/media/tv/TvInputService$Session;
Landroid/media/tv/TvRecordingClient;
Landroid/media/tv/TvRecordingClient$RecordingCallback;
Landroid/media/tv/TvTrackInfo;
Landroid/media/tv/TvTrackInfo$Builder;
Landroid/media/tv/TvView;
Landroid/media/tv/TvView$OnUnhandledInputEventListener;
Landroid/media/tv/TvView$TimeShiftPositionCallback;
Landroid/media/tv/TvView$TvInputCallback;
Landroid/media/UnsupportedSchemeException;
Landroid/media/VolumeAutomation;
Landroid/media/VolumeProvider;
Landroid/media/VolumeShaper;
Landroid/media/VolumeShaper$Configuration;
Landroid/media/VolumeShaper$Configuration$Builder;
Landroid/media/VolumeShaper$Operation;
Landroid/mtp/MtpConstants;
Landroid/mtp/MtpDevice;
Landroid/mtp/MtpDeviceInfo;
Landroid/mtp/MtpEvent;
Landroid/mtp/MtpObjectInfo;
Landroid/mtp/MtpObjectInfo$Builder;
Landroid/mtp/MtpStorageInfo;
Landroid/net/CaptivePortal;
Landroid/net/ConnectivityManager;
Landroid/net/ConnectivityManager$NetworkCallback;
Landroid/net/ConnectivityManager$OnNetworkActiveListener;
Landroid/net/Credentials;
Landroid/net/DhcpInfo;
Landroid/net/http/HttpResponseCache;
Landroid/net/http/SslCertificate;
Landroid/net/http/SslCertificate$DName;
Landroid/net/http/SslError;
Landroid/net/http/X509TrustManagerExtensions;
Landroid/net/IpPrefix;
Landroid/net/LinkAddress;
Landroid/net/LinkProperties;
Landroid/net/LocalServerSocket;
Landroid/net/LocalSocket;
Landroid/net/LocalSocketAddress;
Landroid/net/LocalSocketAddress$Namespace;
Landroid/net/MailTo;
Landroid/net/Network;
Landroid/net/NetworkCapabilities;
Landroid/net/NetworkInfo;
Landroid/net/NetworkInfo$DetailedState;
Landroid/net/NetworkInfo$State;
Landroid/net/NetworkRequest;
Landroid/net/NetworkRequest$Builder;
Landroid/net/NetworkSpecifier;
Landroid/net/nsd/NsdManager;
Landroid/net/nsd/NsdManager$DiscoveryListener;
Landroid/net/nsd/NsdManager$RegistrationListener;
Landroid/net/nsd/NsdManager$ResolveListener;
Landroid/net/nsd/NsdServiceInfo;
Landroid/net/ParseException;
Landroid/net/Proxy;
Landroid/net/ProxyInfo;
Landroid/net/RouteInfo;
Landroid/net/rtp/AudioCodec;
Landroid/net/rtp/AudioGroup;
Landroid/net/rtp/AudioStream;
Landroid/net/rtp/RtpStream;
Landroid/net/sip/SipAudioCall;
Landroid/net/sip/SipAudioCall$Listener;
Landroid/net/sip/SipErrorCode;
Landroid/net/sip/SipException;
Landroid/net/sip/SipManager;
Landroid/net/sip/SipProfile;
Landroid/net/sip/SipProfile$Builder;
Landroid/net/sip/SipRegistrationListener;
Landroid/net/sip/SipSession;
Landroid/net/sip/SipSession$Listener;
Landroid/net/sip/SipSession$State;
Landroid/net/SSLCertificateSocketFactory;
Landroid/net/SSLSessionCache;
Landroid/net/TrafficStats;
Landroid/net/Uri;
Landroid/net/Uri$Builder;
Landroid/net/UrlQuerySanitizer;
Landroid/net/UrlQuerySanitizer$IllegalCharacterValueSanitizer;
Landroid/net/UrlQuerySanitizer$ParameterValuePair;
Landroid/net/UrlQuerySanitizer$ValueSanitizer;
Landroid/net/VpnService;
Landroid/net/VpnService$Builder;
Landroid/net/wifi/aware/AttachCallback;
Landroid/net/wifi/aware/Characteristics;
Landroid/net/wifi/aware/DiscoverySession;
Landroid/net/wifi/aware/DiscoverySessionCallback;
Landroid/net/wifi/aware/IdentityChangedListener;
Landroid/net/wifi/aware/PeerHandle;
Landroid/net/wifi/aware/PublishConfig;
Landroid/net/wifi/aware/PublishConfig$Builder;
Landroid/net/wifi/aware/PublishDiscoverySession;
Landroid/net/wifi/aware/SubscribeConfig;
Landroid/net/wifi/aware/SubscribeConfig$Builder;
Landroid/net/wifi/aware/SubscribeDiscoverySession;
Landroid/net/wifi/aware/WifiAwareManager;
Landroid/net/wifi/aware/WifiAwareSession;
Landroid/net/wifi/hotspot2/ConfigParser;
Landroid/net/wifi/hotspot2/omadm/PpsMoParser;
Landroid/net/wifi/hotspot2/PasspointConfiguration;
Landroid/net/wifi/hotspot2/pps/Credential;
Landroid/net/wifi/hotspot2/pps/Credential$CertificateCredential;
Landroid/net/wifi/hotspot2/pps/Credential$SimCredential;
Landroid/net/wifi/hotspot2/pps/Credential$UserCredential;
Landroid/net/wifi/hotspot2/pps/HomeSp;
Landroid/net/wifi/p2p/nsd/WifiP2pDnsSdServiceInfo;
Landroid/net/wifi/p2p/nsd/WifiP2pDnsSdServiceRequest;
Landroid/net/wifi/p2p/nsd/WifiP2pServiceInfo;
Landroid/net/wifi/p2p/nsd/WifiP2pServiceRequest;
Landroid/net/wifi/p2p/nsd/WifiP2pUpnpServiceInfo;
Landroid/net/wifi/p2p/nsd/WifiP2pUpnpServiceRequest;
Landroid/net/wifi/p2p/WifiP2pConfig;
Landroid/net/wifi/p2p/WifiP2pDevice;
Landroid/net/wifi/p2p/WifiP2pDeviceList;
Landroid/net/wifi/p2p/WifiP2pGroup;
Landroid/net/wifi/p2p/WifiP2pInfo;
Landroid/net/wifi/p2p/WifiP2pManager;
Landroid/net/wifi/p2p/WifiP2pManager$ActionListener;
Landroid/net/wifi/p2p/WifiP2pManager$Channel;
Landroid/net/wifi/p2p/WifiP2pManager$ChannelListener;
Landroid/net/wifi/p2p/WifiP2pManager$ConnectionInfoListener;
Landroid/net/wifi/p2p/WifiP2pManager$DnsSdServiceResponseListener;
Landroid/net/wifi/p2p/WifiP2pManager$DnsSdTxtRecordListener;
Landroid/net/wifi/p2p/WifiP2pManager$PeerListListener;
Landroid/net/wifi/p2p/WifiP2pManager$ServiceResponseListener;
Landroid/net/wifi/p2p/WifiP2pManager$UpnpServiceResponseListener;
Landroid/net/wifi/p3p/WifiP2pManager$GroupInfoListener;
Landroid/net/wifi/ScanResult;
Landroid/net/wifi/SupplicantState;
Landroid/net/wifi/WifiConfiguration;
Landroid/net/wifi/WifiConfiguration$AuthAlgorithm;
Landroid/net/wifi/WifiConfiguration$GroupCipher;
Landroid/net/wifi/WifiConfiguration$KeyMgmt;
Landroid/net/wifi/WifiConfiguration$PairwiseCipher;
Landroid/net/wifi/WifiConfiguration$Protocol;
Landroid/net/wifi/WifiConfiguration$Status;
Landroid/net/wifi/WifiEnterpriseConfig;
Landroid/net/wifi/WifiEnterpriseConfig$Eap;
Landroid/net/wifi/WifiEnterpriseConfig$Phase2;
Landroid/net/wifi/WifiInfo;
Landroid/net/wifi/WifiManager;
Landroid/net/wifi/WifiManager$LocalOnlyHotspotCallback;
Landroid/net/wifi/WifiManager$LocalOnlyHotspotReservation;
Landroid/net/wifi/WifiManager$MulticastLock;
Landroid/net/wifi/WifiManager$WifiLock;
Landroid/net/wifi/WifiManager$WpsCallback;
Landroid/net/wifi/WpsInfo;
Landroid/nfc/cardemulation/CardEmulation;
Landroid/nfc/cardemulation/HostApduService;
Landroid/nfc/cardemulation/HostNfcFService;
Landroid/nfc/cardemulation/NfcFCardEmulation;
Landroid/nfc/cardemulation/OffHostApduService;
Landroid/nfc/FormatException;
Landroid/nfc/NdefMessage;
Landroid/nfc/NdefRecord;
Landroid/nfc/NfcAdapter;
Landroid/nfc/NfcAdapter$CreateBeamUrisCallback;
Landroid/nfc/NfcAdapter$CreateNdefMessageCallback;
Landroid/nfc/NfcAdapter$OnNdefPushCompleteCallback;
Landroid/nfc/NfcAdapter$OnTagRemovedListener;
Landroid/nfc/NfcAdapter$ReaderCallback;
Landroid/nfc/NfcEvent;
Landroid/nfc/NfcManager;
Landroid/nfc/Tag;
Landroid/nfc/TagLostException;
Landroid/nfc/tech/IsoDep;
Landroid/nfc/tech/MifareClassic;
Landroid/nfc/tech/MifareUltralight;
Landroid/nfc/tech/Ndef;
Landroid/nfc/tech/NdefFormatable;
Landroid/nfc/tech/NfcA;
Landroid/nfc/tech/NfcB;
Landroid/nfc/tech/NfcBarcode;
Landroid/nfc/tech/NfcF;
Landroid/nfc/tech/NfcV;
Landroid/nfc/tech/TagTechnology;
Landroid/opengl/EGL14;
Landroid/opengl/EGLConfig;
Landroid/opengl/EGLContext;
Landroid/opengl/EGLDisplay;
Landroid/opengl/EGLExt;
Landroid/opengl/EGLObjectHandle;
Landroid/opengl/EGLSurface;
Landroid/opengl/ETC1;
Landroid/opengl/ETC1Util;
Landroid/opengl/ETC1Util$ETC1Texture;
Landroid/opengl/GLDebugHelper;
Landroid/opengl/GLES10;
Landroid/opengl/GLES10Ext;
Landroid/opengl/GLES11;
Landroid/opengl/GLES11Ext;
Landroid/opengl/GLES20;
Landroid/opengl/GLES30;
Landroid/opengl/GLES31;
Landroid/opengl/GLES31Ext;
Landroid/opengl/GLES31Ext$DebugProcKHR;
Landroid/opengl/GLES32;
Landroid/opengl/GLES32$DebugProc;
Landroid/opengl/GLException;
Landroid/opengl/GLSurfaceView;
Landroid/opengl/GLSurfaceView$EGLConfigChooser;
Landroid/opengl/GLSurfaceView$EGLContextFactory;
Landroid/opengl/GLSurfaceView$EGLWindowSurfaceFactory;
Landroid/opengl/GLSurfaceView$GLWrapper;
Landroid/opengl/GLSurfaceView$Renderer;
Landroid/opengl/GLU;
Landroid/opengl/GLUtils;
Landroid/opengl/Matrix;
Landroid/opengl/Visibility;
Landroid/os/AsyncTask;
Landroid/os/AsyncTask$Status;
Landroid/os/BadParcelableException;
Landroid/os/BaseBundle;
Landroid/os/BatteryManager;
Landroid/os/Binder;
Landroid/os/Build;
Landroid/os/Build$VERSION;
Landroid/os/Build$VERSION_CODES;
Landroid/os/Bundle;
Landroid/os/CancellationSignal;
Landroid/os/CancellationSignal$OnCancelListener;
Landroid/os/ConditionVariable;
Landroid/os/CountDownTimer;
Landroid/os/CpuUsageInfo;
Landroid/os/DeadObjectException;
Landroid/os/DeadSystemException;
Landroid/os/Debug;
Landroid/os/Debug$InstructionCount;
Landroid/os/Debug$MemoryInfo;
Landroid/os/DropBoxManager;
Landroid/os/DropBoxManager$Entry;
Landroid/os/Environment;
Landroid/os/FileObserver;
Landroid/os/FileUriExposedException;
Landroid/os/Handler;
Landroid/os/Handler$Callback;
Landroid/os/HandlerThread;
Landroid/os/HardwarePropertiesManager;
Landroid/os/health/HealthStats;
Landroid/os/health/PackageHealthStats;
Landroid/os/health/PidHealthStats;
Landroid/os/health/ProcessHealthStats;
Landroid/os/health/ServiceHealthStats;
Landroid/os/health/SystemHealthManager;
Landroid/os/health/TimerStat;
Landroid/os/health/UidHealthStats;
Landroid/os/IBinder;
Landroid/os/IBinder$DeathRecipient;
Landroid/os/IInterface;
Landroid/os/LocaleList;
Landroid/os/Looper;
Landroid/os/MemoryFile;
Landroid/os/Message;
Landroid/os/MessageQueue;
Landroid/os/MessageQueue$IdleHandler;
Landroid/os/MessageQueue$OnFileDescriptorEventListener;
Landroid/os/Messenger;
Landroid/os/NetworkOnMainThreadException;
Landroid/os/OperationCanceledException;
Landroid/os/Parcel;
Landroid/os/Parcelable;
Landroid/os/Parcelable$ClassLoaderCreator;
Landroid/os/Parcelable$Creator;
Landroid/os/ParcelFileDescriptor;
Landroid/os/ParcelFileDescriptor$AutoCloseInputStream;
Landroid/os/ParcelFileDescriptor$AutoCloseOutputStream;
Landroid/os/ParcelFileDescriptor$FileDescriptorDetachedException;
Landroid/os/ParcelFileDescriptor$OnCloseListener;
Landroid/os/ParcelFormatException;
Landroid/os/ParcelUuid;
Landroid/os/PatternMatcher;
Landroid/os/PersistableBundle;
Landroid/os/PowerManager;
Landroid/os/PowerManager$WakeLock;
Landroid/os/Process;
Landroid/os/ProxyFileDescriptorCallback;
Landroid/os/RecoverySystem;
Landroid/os/RecoverySystem$ProgressListener;
Landroid/os/RemoteCallbackList;
Landroid/os/RemoteException;
Landroid/os/ResultReceiver;
Landroid/os/SharedMemory;
Landroid/os/StatFs;
Landroid/os/storage/OnObbStateChangeListener;
Landroid/os/storage/StorageManager;
Landroid/os/storage/StorageVolume;
Landroid/os/StrictMode;
Landroid/os/StrictMode$ThreadPolicy;
Landroid/os/StrictMode$ThreadPolicy$Builder;
Landroid/os/StrictMode$VmPolicy;
Landroid/os/StrictMode$VmPolicy$Builder;
Landroid/os/SystemClock;
Landroid/os/TestLooperManager;
Landroid/os/TokenWatcher;
Landroid/os/Trace;
Landroid/os/TransactionTooLargeException;
Landroid/os/UserHandle;
Landroid/os/UserManager;
Landroid/os/VibrationEffect;
Landroid/os/Vibrator;
Landroid/os/WorkSource;
Landroid/preference/CheckBoxPreference;
Landroid/preference/DialogPreference;
Landroid/preference/EditTextPreference;
Landroid/preference/ListPreference;
Landroid/preference/MultiSelectListPreference;
Landroid/preference/Preference;
Landroid/preference/PreferenceActivity;
Landroid/preference/PreferenceActivity$Header;
Landroid/preference/Preference$BaseSavedState;
Landroid/preference/PreferenceCategory;
Landroid/preference/PreferenceDataStore;
Landroid/preference/PreferenceFragment;
Landroid/preference/PreferenceFragment$OnPreferenceStartFragmentCallback;
Landroid/preference/PreferenceGroup;
Landroid/preference/PreferenceManager;
Landroid/preference/PreferenceManager$OnActivityDestroyListener;
Landroid/preference/PreferenceManager$OnActivityResultListener;
Landroid/preference/PreferenceManager$OnActivityStopListener;
Landroid/preference/Preference$OnPreferenceChangeListener;
Landroid/preference/Preference$OnPreferenceClickListener;
Landroid/preference/PreferenceScreen;
Landroid/preference/RingtonePreference;
Landroid/preference/SwitchPreference;
Landroid/preference/TwoStatePreference;
Landroid/print/PageRange;
Landroid/print/pdf/PrintedPdfDocument;
Landroid/print/PrintAttributes;
Landroid/print/PrintAttributes$Builder;
Landroid/print/PrintAttributes$Margins;
Landroid/print/PrintAttributes$MediaSize;
Landroid/print/PrintAttributes$Resolution;
Landroid/print/PrintDocumentAdapter;
Landroid/print/PrintDocumentAdapter$LayoutResultCallback;
Landroid/print/PrintDocumentAdapter$WriteResultCallback;
Landroid/print/PrintDocumentInfo;
Landroid/print/PrintDocumentInfo$Builder;
Landroid/print/PrinterCapabilitiesInfo;
Landroid/print/PrinterCapabilitiesInfo$Builder;
Landroid/print/PrinterId;
Landroid/print/PrinterInfo;
Landroid/print/PrinterInfo$Builder;
Landroid/print/PrintJob;
Landroid/print/PrintJobId;
Landroid/print/PrintJobInfo;
Landroid/print/PrintJobInfo$Builder;
Landroid/print/PrintManager;
Landroid/printservice/CustomPrinterIconCallback;
Landroid/printservice/PrintDocument;
Landroid/printservice/PrinterDiscoverySession;
Landroid/printservice/PrintJob;
Landroid/printservice/PrintService;
Landroid/provider/AlarmClock;
Landroid/provider/BaseColumns;
Landroid/provider/BlockedNumberContract;
Landroid/provider/BlockedNumberContract$BlockedNumbers;
Landroid/provider/Browser;
Landroid/provider/CalendarContract;
Landroid/provider/CalendarContract$Attendees;
Landroid/provider/CalendarContract$AttendeesColumns;
Landroid/provider/CalendarContract$CalendarAlerts;
Landroid/provider/CalendarContract$CalendarAlertsColumns;
Landroid/provider/CalendarContract$CalendarCache;
Landroid/provider/CalendarContract$CalendarCacheColumns;
Landroid/provider/CalendarContract$CalendarColumns;
Landroid/provider/CalendarContract$CalendarEntity;
Landroid/provider/CalendarContract$Calendars;
Landroid/provider/CalendarContract$CalendarSyncColumns;
Landroid/provider/CalendarContract$Colors;
Landroid/provider/CalendarContract$ColorsColumns;
Landroid/provider/CalendarContract$EventDays;
Landroid/provider/CalendarContract$EventDaysColumns;
Landroid/provider/CalendarContract$Events;
Landroid/provider/CalendarContract$EventsColumns;
Landroid/provider/CalendarContract$EventsEntity;
Landroid/provider/CalendarContract$ExtendedProperties;
Landroid/provider/CalendarContract$ExtendedPropertiesColumns;
Landroid/provider/CalendarContract$Instances;
Landroid/provider/CalendarContract$Reminders;
Landroid/provider/CalendarContract$RemindersColumns;
Landroid/provider/CalendarContract$SyncColumns;
Landroid/provider/CalendarContract$SyncState;
Landroid/provider/CallLog;
Landroid/provider/CallLog$Calls;
Landroid/provider/Contacts;
Landroid/provider/Contacts$ContactMethods;
Landroid/provider/Contacts$ContactMethodsColumns;
Landroid/provider/ContactsContract;
Landroid/provider/ContactsContract$AggregationExceptions;
Landroid/provider/ContactsContract$BaseSyncColumns;
Landroid/provider/ContactsContract$CommonDataKinds;
Landroid/provider/ContactsContract$CommonDataKinds$BaseTypes;
Landroid/provider/ContactsContract$CommonDataKinds$Callable;
Landroid/provider/ContactsContract$CommonDataKinds$CommonColumns;
Landroid/provider/ContactsContract$CommonDataKinds$Contactables;
Landroid/provider/ContactsContract$CommonDataKinds$Email;
Landroid/provider/ContactsContract$CommonDataKinds$Event;
Landroid/provider/ContactsContract$CommonDataKinds$GroupMembership;
Landroid/provider/ContactsContract$CommonDataKinds$Identity;
Landroid/provider/ContactsContract$CommonDataKinds$Im;
Landroid/provider/ContactsContract$CommonDataKinds$Nickname;
Landroid/provider/ContactsContract$CommonDataKinds$Note;
Landroid/provider/ContactsContract$CommonDataKinds$Organization;
Landroid/provider/ContactsContract$CommonDataKinds$Phone;
Landroid/provider/ContactsContract$CommonDataKinds$Photo;
Landroid/provider/ContactsContract$CommonDataKinds$Relation;
Landroid/provider/ContactsContract$CommonDataKinds$SipAddress;
Landroid/provider/ContactsContract$CommonDataKinds$StructuredName;
Landroid/provider/ContactsContract$CommonDataKinds$StructuredPostal;
Landroid/provider/ContactsContract$CommonDataKinds$Website;
Landroid/provider/ContactsContract$ContactNameColumns;
Landroid/provider/ContactsContract$ContactOptionsColumns;
Landroid/provider/ContactsContract$Contacts;
Landroid/provider/ContactsContract$Contacts$AggregationSuggestions;
Landroid/provider/ContactsContract$Contacts$AggregationSuggestions$Builder;
Landroid/provider/ContactsContract$ContactsColumns;
Landroid/provider/ContactsContract$Contacts$Data;
Landroid/provider/ContactsContract$Contacts$Entity;
Landroid/provider/ContactsContract$Contacts$Photo;
Landroid/provider/ContactsContract$ContactStatusColumns;
Landroid/provider/ContactsContract$Data;
Landroid/provider/ContactsContract$DataColumns;
Landroid/provider/ContactsContract$DataColumnsWithJoins;
Landroid/provider/ContactsContract$DataUsageFeedback;
Landroid/provider/ContactsContract$DataUsageStatColumns;
Landroid/provider/ContactsContract$DeletedContacts;
Landroid/provider/ContactsContract$DeletedContactsColumns;
Landroid/provider/ContactsContract$Directory;
Landroid/provider/ContactsContract$DisplayNameSources;
Landroid/provider/ContactsContract$DisplayPhoto;
Landroid/provider/ContactsContract$FullNameStyle;
Landroid/provider/ContactsContract$Groups;
Landroid/provider/ContactsContract$GroupsColumns;
Landroid/provider/ContactsContract$Intents;
Landroid/provider/ContactsContract$Intents$Insert;
Landroid/provider/ContactsContract$PhoneLookup;
Landroid/provider/ContactsContract$PhoneLookupColumns;
Landroid/provider/ContactsContract$PhoneticNameStyle;
Landroid/provider/ContactsContract$PinnedPositions;
Landroid/provider/ContactsContract$Presence;
Landroid/provider/ContactsContract$PresenceColumns;
Landroid/provider/ContactsContract$Profile;
Landroid/provider/ContactsContract$ProfileSyncState;
Landroid/provider/ContactsContract$ProviderStatus;
Landroid/provider/ContactsContract$QuickContact;
Landroid/provider/ContactsContract$RawContacts;
Landroid/provider/ContactsContract$RawContactsColumns;
Landroid/provider/ContactsContract$RawContacts$Data;
Landroid/provider/ContactsContract$RawContacts$DisplayPhoto;
Landroid/provider/ContactsContract$RawContacts$Entity;
Landroid/provider/ContactsContract$RawContactsEntity;
Landroid/provider/ContactsContract$SearchSnippets;
Landroid/provider/ContactsContract$Settings;
Landroid/provider/ContactsContract$SettingsColumns;
Landroid/provider/ContactsContract$StatusColumns;
Landroid/provider/ContactsContract$StatusUpdates;
Landroid/provider/ContactsContract$SyncColumns;
Landroid/provider/ContactsContract$SyncState;
Landroid/provider/Contacts$Extensions;
Landroid/provider/Contacts$ExtensionsColumns;
Landroid/provider/Contacts$GroupMembership;
Landroid/provider/Contacts$Groups;
Landroid/provider/Contacts$GroupsColumns;
Landroid/provider/Contacts$Intents;
Landroid/provider/Contacts$Intents$Insert;
Landroid/provider/Contacts$Intents$UI;
Landroid/provider/Contacts$OrganizationColumns;
Landroid/provider/Contacts$Organizations;
Landroid/provider/Contacts$People;
Landroid/provider/Contacts$PeopleColumns;
Landroid/provider/Contacts$People$ContactMethods;
Landroid/provider/Contacts$People$Extensions;
Landroid/provider/Contacts$People$Phones;
Landroid/provider/Contacts$Phones;
Landroid/provider/Contacts$PhonesColumns;
Landroid/provider/Contacts$Photos;
Landroid/provider/Contacts$PhotosColumns;
Landroid/provider/Contacts$PresenceColumns;
Landroid/provider/Contacts$Settings;
Landroid/provider/Contacts$SettingsColumns;
Landroid/provider/DocumentsContract;
Landroid/provider/DocumentsContract$Document;
Landroid/provider/DocumentsContract$Path;
Landroid/provider/DocumentsContract$Root;
Landroid/provider/DocumentsProvider;
Landroid/provider/FontRequest;
Landroid/provider/FontsContract;
Landroid/provider/FontsContract$Columns;
Landroid/provider/FontsContract$FontFamilyResult;
Landroid/provider/FontsContract$FontInfo;
Landroid/provider/FontsContract$FontRequestCallback;
Landroid/provider/LiveFolders;
Landroid/provider/MediaStore;
Landroid/provider/MediaStore$Audio;
Landroid/provider/MediaStore$Audio$AlbumColumns;
Landroid/provider/MediaStore$Audio$Albums;
Landroid/provider/MediaStore$Audio$ArtistColumns;
Landroid/provider/MediaStore$Audio$Artists;
Landroid/provider/MediaStore$Audio$Artists$Albums;
Landroid/provider/MediaStore$Audio$AudioColumns;
Landroid/provider/MediaStore$Audio$Genres;
Landroid/provider/MediaStore$Audio$GenresColumns;
Landroid/provider/MediaStore$Audio$Genres$Members;
Landroid/provider/MediaStore$Audio$Media;
Landroid/provider/MediaStore$Audio$Playlists;
Landroid/provider/MediaStore$Audio$PlaylistsColumns;
Landroid/provider/MediaStore$Audio$Playlists$Members;
Landroid/provider/MediaStore$Audio$Radio;
Landroid/provider/MediaStore$Files;
Landroid/provider/MediaStore$Files$FileColumns;
Landroid/provider/MediaStore$Images;
Landroid/provider/MediaStore$Images$ImageColumns;
Landroid/provider/MediaStore$Images$Media;
Landroid/provider/MediaStore$Images$Thumbnails;
Landroid/provider/MediaStore$MediaColumns;
Landroid/provider/MediaStore$Video;
Landroid/provider/MediaStore$Video$Media;
Landroid/provider/MediaStore$Video$Thumbnails;
Landroid/provider/MediaStore$Video$VideoColumns;
Landroid/provider/OpenableColumns;
Landroid/provider/SearchRecentSuggestions;
Landroid/provider/Settings;
Landroid/provider/Settings$Global;
Landroid/provider/Settings$NameValueTable;
Landroid/provider/Settings$Secure;
Landroid/provider/Settings$SettingNotFoundException;
Landroid/provider/Settings$System;
Landroid/provider/SyncStateContract;
Landroid/provider/SyncStateContract$Columns;
Landroid/provider/SyncStateContract$Constants;
Landroid/provider/SyncStateContract$Helpers;
Landroid/provider/Telephony;
Landroid/provider/Telephony$BaseMmsColumns;
Landroid/provider/Telephony$CanonicalAddressesColumns;
Landroid/provider/Telephony$Carriers;
Landroid/provider/Telephony$Mms;
Landroid/provider/Telephony$Mms$Addr;
Landroid/provider/Telephony$Mms$Draft;
Landroid/provider/Telephony$Mms$Inbox;
Landroid/provider/Telephony$Mms$Intents;
Landroid/provider/Telephony$Mms$Outbox;
Landroid/provider/Telephony$Mms$Part;
Landroid/provider/Telephony$Mms$Rate;
Landroid/provider/Telephony$Mms$Sent;
Landroid/provider/Telephony$MmsSms;
Landroid/provider/Telephony$MmsSms$PendingMessages;
Landroid/provider/Telephony$ServiceStateTable;
Landroid/provider/Telephony$Sms;
Landroid/provider/Telephony$Sms$Conversations;
Landroid/provider/Telephony$Sms$Draft;
Landroid/provider/Telephony$Sms$Inbox;
Landroid/provider/Telephony$Sms$Intents;
Landroid/provider/Telephony$Sms$Outbox;
Landroid/provider/Telephony$Sms$Sent;
Landroid/provider/Telephony$TextBasedSmsColumns;
Landroid/provider/Telephony$Threads;
Landroid/provider/Telephony$ThreadsColumns;
Landroid/provider/UserDictionary;
Landroid/provider/UserDictionary$Words;
Landroid/provider/VoicemailContract;
Landroid/provider/VoicemailContract$Status;
Landroid/provider/VoicemailContract$Voicemails;
Landroid/R;
Landroid/R$anim;
Landroid/R$animator;
Landroid/R$array;
Landroid/R$attr;
Landroid/R$bool;
Landroid/R$color;
Landroid/R$dimen;
Landroid/R$drawable;
Landroid/renderscript/Allocation;
Landroid/renderscript/AllocationAdapter;
Landroid/renderscript/Allocation$MipmapControl;
Landroid/renderscript/Allocation$OnBufferAvailableListener;
Landroid/renderscript/BaseObj;
Landroid/renderscript/Byte2;
Landroid/renderscript/Byte3;
Landroid/renderscript/Byte4;
Landroid/renderscript/Double2;
Landroid/renderscript/Double3;
Landroid/renderscript/Double4;
Landroid/renderscript/Element;
Landroid/renderscript/Element$Builder;
Landroid/renderscript/Element$DataKind;
Landroid/renderscript/Element$DataType;
Landroid/renderscript/FieldPacker;
Landroid/renderscript/Float2;
Landroid/renderscript/Float3;
Landroid/renderscript/Float4;
Landroid/renderscript/Int2;
Landroid/renderscript/Int3;
Landroid/renderscript/Int4;
Landroid/renderscript/Long2;
Landroid/renderscript/Long3;
Landroid/renderscript/Long4;
Landroid/renderscript/Matrix2f;
Landroid/renderscript/Matrix3f;
Landroid/renderscript/Matrix4f;
Landroid/renderscript/RenderScript;
Landroid/renderscript/RenderScript$ContextType;
Landroid/renderscript/RenderScript$Priority;
Landroid/renderscript/RenderScript$RSErrorHandler;
Landroid/renderscript/RenderScript$RSMessageHandler;
Landroid/renderscript/RSDriverException;
Landroid/renderscript/RSIllegalArgumentException;
Landroid/renderscript/RSInvalidStateException;
Landroid/renderscript/RSRuntimeException;
Landroid/renderscript/Sampler;
Landroid/renderscript/Sampler$Builder;
Landroid/renderscript/Sampler$Value;
Landroid/renderscript/Script;
Landroid/renderscript/Script$Builder;
Landroid/renderscript/ScriptC;
Landroid/renderscript/Script$FieldBase;
Landroid/renderscript/Script$FieldID;
Landroid/renderscript/ScriptGroup;
Landroid/renderscript/ScriptGroup$Binding;
Landroid/renderscript/ScriptGroup$Builder;
Landroid/renderscript/ScriptGroup$Builder2;
Landroid/renderscript/ScriptGroup$Closure;
Landroid/renderscript/ScriptGroup$Future;
Landroid/renderscript/ScriptGroup$Input;
Landroid/renderscript/ScriptIntrinsic;
Landroid/renderscript/ScriptIntrinsic3DLUT;
Landroid/renderscript/ScriptIntrinsicBLAS;
Landroid/renderscript/ScriptIntrinsicBlend;
Landroid/renderscript/ScriptIntrinsicBlur;
Landroid/renderscript/ScriptIntrinsicColorMatrix;
Landroid/renderscript/ScriptIntrinsicConvolve3x3;
Landroid/renderscript/ScriptIntrinsicConvolve5x5;
Landroid/renderscript/ScriptIntrinsicHistogram;
Landroid/renderscript/ScriptIntrinsicLUT;
Landroid/renderscript/ScriptIntrinsicResize;
Landroid/renderscript/ScriptIntrinsicYuvToRGB;
Landroid/renderscript/Script$InvokeID;
Landroid/renderscript/Script$KernelID;
Landroid/renderscript/Script$LaunchOptions;
Landroid/renderscript/Short2;
Landroid/renderscript/Short3;
Landroid/renderscript/Short4;
Landroid/renderscript/Type;
Landroid/renderscript/Type$Builder;
Landroid/renderscript/Type$CubemapFace;
Landroid/R$fraction;
Landroid/R$id;
Landroid/R$integer;
Landroid/R$interpolator;
Landroid/R$layout;
Landroid/R$menu;
Landroid/R$mipmap;
Landroid/R$plurals;
Landroid/R$raw;
Landroid/R$string;
Landroid/R$style;
Landroid/R$styleable;
Landroid/R$transition;
Landroid/R$xml;
Landroid/sax/Element;
Landroid/sax/ElementListener;
Landroid/sax/EndElementListener;
Landroid/sax/EndTextElementListener;
Landroid/sax/RootElement;
Landroid/sax/StartElementListener;
Landroid/sax/TextElementListener;
Landroid/security/KeyChain;
Landroid/security/KeyChainAliasCallback;
Landroid/security/KeyChainException;
Landroid/security/KeyPairGeneratorSpec;
Landroid/security/KeyPairGeneratorSpec$Builder;
Landroid/security/keystore/KeyExpiredException;
Landroid/security/keystore/KeyGenParameterSpec;
Landroid/security/keystore/KeyGenParameterSpec$Builder;
Landroid/security/keystore/KeyInfo;
Landroid/security/keystore/KeyNotYetValidException;
Landroid/security/keystore/KeyPermanentlyInvalidatedException;
Landroid/security/keystore/KeyProperties;
Landroid/security/keystore/KeyProtection;
Landroid/security/keystore/KeyProtection$Builder;
Landroid/security/KeyStoreParameter;
Landroid/security/KeyStoreParameter$Builder;
Landroid/security/keystore/UserNotAuthenticatedException;
Landroid/security/NetworkSecurityPolicy;
Landroid/service/autofill/AutofillService;
Landroid/service/autofill/CharSequenceTransformation;
Landroid/service/autofill/CharSequenceTransformation$Builder;
Landroid/service/autofill/CustomDescription;
Landroid/service/autofill/CustomDescription$Builder;
Landroid/service/autofill/Dataset;
Landroid/service/autofill/Dataset$Builder;
Landroid/service/autofill/FillCallback;
Landroid/service/autofill/FillContext;
Landroid/service/autofill/FillEventHistory;
Landroid/service/autofill/FillEventHistory$Event;
Landroid/service/autofill/FillRequest;
Landroid/service/autofill/FillResponse;
Landroid/service/autofill/FillResponse$Builder;
Landroid/service/autofill/ImageTransformation;
Landroid/service/autofill/ImageTransformation$Builder;
Landroid/service/autofill/LuhnChecksumValidator;
Landroid/service/autofill/RegexValidator;
Landroid/service/autofill/SaveCallback;
Landroid/service/autofill/SaveInfo;
Landroid/service/autofill/SaveInfo$Builder;
Landroid/service/autofill/SaveRequest;
Landroid/service/autofill/Transformation;
Landroid/service/autofill/Validator;
Landroid/service/autofill/Validators;
Landroid/service/carrier/CarrierIdentifier;
Landroid/service/carrier/CarrierMessagingService;
Landroid/service/carrier/CarrierMessagingService$ResultCallback;
Landroid/service/carrier/CarrierMessagingService$SendMmsResult;
Landroid/service/carrier/CarrierMessagingService$SendMultipartSmsResult;
Landroid/service/carrier/CarrierMessagingService$SendSmsResult;
Landroid/service/carrier/CarrierService;
Landroid/service/carrier/MessagePdu;
Landroid/service/chooser/ChooserTarget;
Landroid/service/chooser/ChooserTargetService;
Landroid/service/dreams/DreamService;
Landroid/service/media/CameraPrewarmService;
Landroid/service/media/MediaBrowserService;
Landroid/service/media/MediaBrowserService$BrowserRoot;
Landroid/service/media/MediaBrowserService$Result;
Landroid/service/notification/Condition;
Landroid/service/notification/ConditionProviderService;
Landroid/service/notification/NotificationListenerService;
Landroid/service/notification/NotificationListenerService$Ranking;
Landroid/service/notification/NotificationListenerService$RankingMap;
Landroid/service/notification/StatusBarNotification;
Landroid/service/quicksettings/Tile;
Landroid/service/quicksettings/TileService;
Landroid/service/restrictions/RestrictionsReceiver;
Landroid/service/textservice/SpellCheckerService;
Landroid/service/textservice/SpellCheckerService$Session;
Landroid/service/voice/AlwaysOnHotwordDetector;
Landroid/service/voice/AlwaysOnHotwordDetector$Callback;
Landroid/service/voice/AlwaysOnHotwordDetector$EventPayload;
Landroid/service/voice/VoiceInteractionService;
Landroid/service/voice/VoiceInteractionSession;
Landroid/service/voice/VoiceInteractionSession$AbortVoiceRequest;
Landroid/service/voice/VoiceInteractionSession$CommandRequest;
Landroid/service/voice/VoiceInteractionSession$CompleteVoiceRequest;
Landroid/service/voice/VoiceInteractionSession$ConfirmationRequest;
Landroid/service/voice/VoiceInteractionSession$Insets;
Landroid/service/voice/VoiceInteractionSession$PickOptionRequest;
Landroid/service/voice/VoiceInteractionSession$Request;
Landroid/service/voice/VoiceInteractionSessionService;
Landroid/service/vr/VrListenerService;
Landroid/service/wallpaper/WallpaperService;
Landroid/service/wallpaper/WallpaperService$Engine;
Landroid/speech/RecognitionListener;
Landroid/speech/RecognitionService;
Landroid/speech/RecognitionService$Callback;
Landroid/speech/RecognizerIntent;
Landroid/speech/RecognizerResultsIntent;
Landroid/speech/SpeechRecognizer;
Landroid/speech/tts/SynthesisCallback;
Landroid/speech/tts/SynthesisRequest;
Landroid/speech/tts/TextToSpeech;
Landroid/speech/tts/TextToSpeech$Engine;
Landroid/speech/tts/TextToSpeech$EngineInfo;
Landroid/speech/tts/TextToSpeech$OnInitListener;
Landroid/speech/tts/TextToSpeech$OnUtteranceCompletedListener;
Landroid/speech/tts/TextToSpeechService;
Landroid/speech/tts/UtteranceProgressListener;
Landroid/speech/tts/Voice;
Landroid/support/test/annotation/UiThreadTest;
Landroid/support/test/espresso/matcher/ViewMatchers;
Landroid/support/test/filters/FlakyTest;
Landroid/support/test/filters/LargeTest;
Landroid/support/test/filters/MediumTest;
Landroid/support/test/filters/SmallTest;
Landroid/support/test/filters/Suppress;
Landroid/support/test/InstrumentationRegistry;
Landroid/support/test/rule/ActivityTestRule;
Landroid/support/test/rule/ServiceTestRule;
Landroid/support/test/runner/AndroidJUnitRunner;
Landroid/support/v4/view/ViewPager;
Landroid/system/ErrnoException;
Landroid/system/Os;
Landroid/system/OsConstants;
Landroid/system/StructPollfd;
Landroid/system/StructStat;
Landroid/system/StructStatVfs;
Landroid/system/StructTimespec;
Landroid/system/StructUtsname;
Landroid/telecom/Call;
Landroid/telecom/CallAudioState;
Landroid/telecom/Call$Callback;
Landroid/telecom/Call$Details;
Landroid/telecom/Call$RttCall;
Landroid/telecom/CallScreeningService;
Landroid/telecom/CallScreeningService$CallResponse;
Landroid/telecom/CallScreeningService$CallResponse$Builder;
Landroid/telecom/Conference;
Landroid/telecom/Conferenceable;
Landroid/telecom/Connection;
Landroid/telecom/ConnectionRequest;
Landroid/telecom/Connection$RttModifyStatus;
Landroid/telecom/ConnectionService;
Landroid/telecom/Connection$VideoProvider;
Landroid/telecom/DisconnectCause;
Landroid/telecom/GatewayInfo;
Landroid/telecom/InCallService;
Landroid/telecom/InCallService$VideoCall;
Landroid/telecom/InCallService$VideoCall$Callback;
Landroid/telecom/PhoneAccount;
Landroid/telecom/PhoneAccount$Builder;
Landroid/telecom/PhoneAccountHandle;
Landroid/telecom/RemoteConference;
Landroid/telecom/RemoteConference$Callback;
Landroid/telecom/RemoteConnection;
Landroid/telecom/RemoteConnection$Callback;
Landroid/telecom/RemoteConnection$VideoProvider;
Landroid/telecom/RemoteConnection$VideoProvider$Callback;
Landroid/telecom/StatusHints;
Landroid/telecom/TelecomManager;
Landroid/telecom/VideoProfile;
Landroid/telecom/VideoProfile$CameraCapabilities;
Landroid/telephony/CarrierConfigManager;
Landroid/telephony/cdma/CdmaCellLocation;
Landroid/telephony/CellIdentityCdma;
Landroid/telephony/CellIdentityGsm;
Landroid/telephony/CellIdentityLte;
Landroid/telephony/CellIdentityWcdma;
Landroid/telephony/CellInfo;
Landroid/telephony/CellInfoCdma;
Landroid/telephony/CellInfoGsm;
Landroid/telephony/CellInfoLte;
Landroid/telephony/CellInfoWcdma;
Landroid/telephony/CellLocation;
Landroid/telephony/CellSignalStrength;
Landroid/telephony/CellSignalStrengthCdma;
Landroid/telephony/CellSignalStrengthGsm;
Landroid/telephony/CellSignalStrengthLte;
Landroid/telephony/CellSignalStrengthWcdma;
Landroid/telephony/gsm/GsmCellLocation;
Landroid/telephony/gsm/SmsManager;
Landroid/telephony/gsm/SmsMessage;
Landroid/telephony/gsm/SmsMessage$MessageClass;
Landroid/telephony/gsm/SmsMessage$SubmitPdu;
Landroid/telephony/IccOpenLogicalChannelResponse;
Landroid/telephony/NeighboringCellInfo;
Landroid/telephony/PhoneNumberFormattingTextWatcher;
Landroid/telephony/PhoneNumberUtils;
Landroid/telephony/PhoneStateListener;
Landroid/telephony/ServiceState;
Landroid/telephony/SignalStrength;
Landroid/telephony/SmsManager;
Landroid/telephony/SmsMessage;
Landroid/telephony/SmsMessage$MessageClass;
Landroid/telephony/SmsMessage$SubmitPdu;
Landroid/telephony/SubscriptionInfo;
Landroid/telephony/SubscriptionManager;
Landroid/telephony/SubscriptionManager$OnSubscriptionsChangedListener;
Landroid/telephony/TelephonyManager;
Landroid/telephony/TelephonyManager$UssdResponseCallback;
Landroid/telephony/VisualVoicemailService;
Landroid/telephony/VisualVoicemailService$VisualVoicemailTask;
Landroid/telephony/VisualVoicemailSms;
Landroid/telephony/VisualVoicemailSmsFilterSettings;
Landroid/telephony/VisualVoicemailSmsFilterSettings$Builder;
Landroid/test/ActivityInstrumentationTestCase;
Landroid/test/ActivityInstrumentationTestCase2;
Landroid/test/ActivityTestCase;
Landroid/test/ActivityUnitTestCase;
Landroid/test/AndroidTestCase;
Landroid/test/AndroidTestRunner;
Landroid/test/ApplicationTestCase;
Landroid/test/AssertionFailedError;
Landroid/test/ComparisonFailure;
Landroid/test/FlakyTest;
Landroid/test/InstrumentationTestCase;
Landroid/test/InstrumentationTestRunner;
Landroid/test/InstrumentationTestSuite;
Landroid/test/IsolatedContext;
Landroid/test/LoaderTestCase;
Landroid/test/mock/MockApplication;
Landroid/test/mock/MockContentProvider;
Landroid/test/mock/MockContentResolver;
Landroid/test/mock/MockContext;
Landroid/test/mock/MockCursor;
Landroid/test/mock/MockDialogInterface;
Landroid/test/mock/MockPackageManager;
Landroid/test/mock/MockResources;
Landroid/test/MoreAsserts;
Landroid/test/PerformanceTestCase;
Landroid/test/PerformanceTestCase$Intermediates;
Landroid/test/ProviderTestCase;
Landroid/test/ProviderTestCase2;
Landroid/test/RenamingDelegatingContext;
Landroid/test/ServiceTestCase;
Landroid/test/SingleLaunchActivityTestCase;
Landroid/test/suitebuilder/annotation/LargeTest;
Landroid/test/suitebuilder/annotation/MediumTest;
Landroid/test/suitebuilder/annotation/SmallTest;
Landroid/test/suitebuilder/annotation/Smoke;
Landroid/test/suitebuilder/annotation/Suppress;
Landroid/test/suitebuilder/TestMethod;
Landroid/test/suitebuilder/TestSuiteBuilder;
Landroid/test/suitebuilder/TestSuiteBuilder$FailedToCreateTests;
Landroid/test/SyncBaseInstrumentation;
Landroid/test/TestSuiteProvider;
Landroid/test/TouchUtils;
Landroid/test/UiThreadTest;
Landroid/test/ViewAsserts;
Landroid/text/AlteredCharSequence;
Landroid/text/AndroidCharacter;
Landroid/text/Annotation;
Landroid/text/AutoText;
Landroid/text/BidiFormatter;
Landroid/text/BidiFormatter$Builder;
Landroid/text/BoringLayout;
Landroid/text/BoringLayout$Metrics;
Landroid/text/ClipboardManager;
Landroid/text/DynamicLayout;
Landroid/text/Editable;
Landroid/text/Editable$Factory;
Landroid/text/format/DateFormat;
Landroid/text/format/DateUtils;
Landroid/text/format/Formatter;
Landroid/text/format/Time;
Landroid/text/GetChars;
Landroid/text/Html;
Landroid/text/Html$ImageGetter;
Landroid/text/Html$TagHandler;
Landroid/text/InputFilter;
Landroid/text/InputFilter$AllCaps;
Landroid/text/InputFilter$LengthFilter;
Landroid/text/InputType;
Landroid/text/Layout;
Landroid/text/Layout$Alignment;
Landroid/text/Layout$Directions;
Landroid/text/LoginFilter;
Landroid/text/LoginFilter$PasswordFilterGMail;
Landroid/text/LoginFilter$UsernameFilterGeneric;
Landroid/text/LoginFilter$UsernameFilterGMail;
Landroid/text/method/ArrowKeyMovementMethod;
Landroid/text/method/BaseKeyListener;
Landroid/text/method/BaseMovementMethod;
Landroid/text/method/CharacterPickerDialog;
Landroid/text/method/DateKeyListener;
Landroid/text/method/DateTimeKeyListener;
Landroid/text/method/DialerKeyListener;
Landroid/text/method/DigitsKeyListener;
Landroid/text/method/HideReturnsTransformationMethod;
Landroid/text/method/KeyListener;
Landroid/text/method/LinkMovementMethod;
Landroid/text/method/MetaKeyKeyListener;
Landroid/text/method/MovementMethod;
Landroid/text/method/MultiTapKeyListener;
Landroid/text/method/NumberKeyListener;
Landroid/text/method/PasswordTransformationMethod;
Landroid/text/method/QwertyKeyListener;
Landroid/text/method/ReplacementTransformationMethod;
Landroid/text/method/ScrollingMovementMethod;
Landroid/text/method/SingleLineTransformationMethod;
Landroid/text/method/TextKeyListener;
Landroid/text/method/TextKeyListener$Capitalize;
Landroid/text/method/TimeKeyListener;
Landroid/text/method/Touch;
Landroid/text/method/TransformationMethod;
Landroid/text/NoCopySpan;
Landroid/text/NoCopySpan$Concrete;
Landroid/text/ParcelableSpan;
Landroid/text/Selection;
Landroid/text/Spannable;
Landroid/text/Spannable$Factory;
Landroid/text/SpannableString;
Landroid/text/SpannableStringBuilder;
Landroid/text/Spanned;
Landroid/text/SpannedString;
Landroid/text/SpanWatcher;
Landroid/text/StaticLayout;
Landroid/text/StaticLayout$Builder;
Landroid/text/style/AbsoluteSizeSpan;
Landroid/text/style/AlignmentSpan;
Landroid/text/style/AlignmentSpan$Standard;
Landroid/text/style/BackgroundColorSpan;
Landroid/text/style/BulletSpan;
Landroid/text/style/CharacterStyle;
Landroid/text/style/ClickableSpan;
Landroid/text/style/DrawableMarginSpan;
Landroid/text/style/DynamicDrawableSpan;
Landroid/text/style/EasyEditSpan;
Landroid/text/style/ForegroundColorSpan;
Landroid/text/style/IconMarginSpan;
Landroid/text/style/ImageSpan;
Landroid/text/style/LeadingMarginSpan;
Landroid/text/style/LeadingMarginSpan$LeadingMarginSpan2;
Landroid/text/style/LeadingMarginSpan$Standard;
Landroid/text/style/LineBackgroundSpan;
Landroid/text/style/LineHeightSpan;
Landroid/text/style/LineHeightSpan$WithDensity;
Landroid/text/style/LocaleSpan;
Landroid/text/style/MaskFilterSpan;
Landroid/text/style/MetricAffectingSpan;
Landroid/text/style/ParagraphStyle;
Landroid/text/style/QuoteSpan;
Landroid/text/style/RelativeSizeSpan;
Landroid/text/style/ReplacementSpan;
Landroid/text/style/ScaleXSpan;
Landroid/text/style/StyleSpan;
Landroid/text/style/SubscriptSpan;
Landroid/text/style/SuggestionSpan;
Landroid/text/style/SuperscriptSpan;
Landroid/text/style/TabStopSpan;
Landroid/text/style/TabStopSpan$Standard;
Landroid/text/style/TextAppearanceSpan;
Landroid/text/style/TtsSpan;
Landroid/text/style/TtsSpan$Builder;
Landroid/text/style/TtsSpan$CardinalBuilder;
Landroid/text/style/TtsSpan$DateBuilder;
Landroid/text/style/TtsSpan$DecimalBuilder;
Landroid/text/style/TtsSpan$DigitsBuilder;
Landroid/text/style/TtsSpan$ElectronicBuilder;
Landroid/text/style/TtsSpan$FractionBuilder;
Landroid/text/style/TtsSpan$MeasureBuilder;
Landroid/text/style/TtsSpan$MoneyBuilder;
Landroid/text/style/TtsSpan$OrdinalBuilder;
Landroid/text/style/TtsSpan$SemioticClassBuilder;
Landroid/text/style/TtsSpan$TelephoneBuilder;
Landroid/text/style/TtsSpan$TextBuilder;
Landroid/text/style/TtsSpan$TimeBuilder;
Landroid/text/style/TtsSpan$VerbatimBuilder;
Landroid/text/style/TypefaceSpan;
Landroid/text/style/UnderlineSpan;
Landroid/text/style/UpdateAppearance;
Landroid/text/style/UpdateLayout;
Landroid/text/style/URLSpan;
Landroid/text/style/WrapTogetherSpan;
Landroid/text/TextDirectionHeuristic;
Landroid/text/TextDirectionHeuristics;
Landroid/text/TextPaint;
Landroid/text/TextUtils;
Landroid/text/TextUtils$EllipsizeCallback;
Landroid/text/TextUtils$SimpleStringSplitter;
Landroid/text/TextUtils$StringSplitter;
Landroid/text/TextUtils$TruncateAt;
Landroid/text/TextWatcher;
Landroid/text/util/Linkify;
Landroid/text/util/Linkify$MatchFilter;
Landroid/text/util/Linkify$TransformFilter;
Landroid/text/util/Rfc822Token;
Landroid/text/util/Rfc822Tokenizer;
Landroid/transition/ArcMotion;
Landroid/transition/AutoTransition;
Landroid/transition/ChangeBounds;
Landroid/transition/ChangeClipBounds;
Landroid/transition/ChangeImageTransform;
Landroid/transition/ChangeScroll;
Landroid/transition/ChangeTransform;
Landroid/transition/CircularPropagation;
Landroid/transition/Explode;
Landroid/transition/Fade;
Landroid/transition/PathMotion;
Landroid/transition/PatternPathMotion;
Landroid/transition/Scene;
Landroid/transition/SidePropagation;
Landroid/transition/Slide;
Landroid/transition/Transition;
Landroid/transition/Transition$EpicenterCallback;
Landroid/transition/TransitionInflater;
Landroid/transition/TransitionListenerAdapter;
Landroid/transition/TransitionManager;
Landroid/transition/TransitionPropagation;
Landroid/transition/TransitionSet;
Landroid/transition/Transition$TransitionListener;
Landroid/transition/TransitionValues;
Landroid/transition/Visibility;
Landroid/transition/VisibilityPropagation;
Landroid/util/AndroidException;
Landroid/util/AndroidRuntimeException;
Landroid/util/ArrayMap;
Landroid/util/ArraySet;
Landroid/util/AtomicFile;
Landroid/util/AttributeSet;
Landroid/util/Base64;
Landroid/util/Base64DataException;
Landroid/util/Base64InputStream;
Landroid/util/Base64OutputStream;
Landroid/util/Config;
Landroid/util/DebugUtils;
Landroid/util/DisplayMetrics;
Landroid/util/EventLog;
Landroid/util/EventLog$Event;
Landroid/util/EventLogTags;
Landroid/util/EventLogTags$Description;
Landroid/util/FloatMath;
Landroid/util/FloatProperty;
Landroid/util/Half;
Landroid/util/IntProperty;
Landroid/util/JsonReader;
Landroid/util/JsonToken;
Landroid/util/JsonWriter;
Landroid/util/LayoutDirection;
Landroid/util/Log;
Landroid/util/LogPrinter;
Landroid/util/LongSparseArray;
Landroid/util/LruCache;
Landroid/util/MalformedJsonException;
Landroid/util/MonthDisplayHelper;
Landroid/util/MutableBoolean;
Landroid/util/MutableByte;
Landroid/util/MutableChar;
Landroid/util/MutableDouble;
Landroid/util/MutableFloat;
Landroid/util/MutableInt;
Landroid/util/MutableLong;
Landroid/util/MutableShort;
Landroid/util/NoSuchPropertyException;
Landroid/util/Pair;
Landroid/util/Patterns;
Landroid/util/Printer;
Landroid/util/PrintStreamPrinter;
Landroid/util/PrintWriterPrinter;
Landroid/util/Property;
Landroid/util/Range;
Landroid/util/Rational;
Landroid/util/Size;
Landroid/util/SizeF;
Landroid/util/SparseArray;
Landroid/util/SparseBooleanArray;
Landroid/util/SparseIntArray;
Landroid/util/SparseLongArray;
Landroid/util/StateSet;
Landroid/util/StringBuilderPrinter;
Landroid/util/TimeFormatException;
Landroid/util/TimeUtils;
Landroid/util/TimingLogger;
Landroid/util/TypedValue;
Landroid/util/Xml;
Landroid/util/Xml$Encoding;
Landroid/view/AbsSavedState;
Landroid/view/accessibility/AccessibilityEvent;
Landroid/view/accessibility/AccessibilityEventSource;
Landroid/view/accessibility/AccessibilityManager;
Landroid/view/accessibility/AccessibilityManager$AccessibilityStateChangeListener;
Landroid/view/accessibility/AccessibilityManager$TouchExplorationStateChangeListener;
Landroid/view/accessibility/AccessibilityNodeInfo;
Landroid/view/accessibility/AccessibilityNodeInfo$AccessibilityAction;
Landroid/view/accessibility/AccessibilityNodeInfo$CollectionInfo;
Landroid/view/accessibility/AccessibilityNodeInfo$CollectionItemInfo;
Landroid/view/accessibility/AccessibilityNodeInfo$RangeInfo;
Landroid/view/accessibility/AccessibilityNodeProvider;
Landroid/view/accessibility/AccessibilityRecord;
Landroid/view/accessibility/AccessibilityRequestPreparer;
Landroid/view/accessibility/AccessibilityWindowInfo;
Landroid/view/accessibility/CaptioningManager;
Landroid/view/accessibility/CaptioningManager$CaptioningChangeListener;
Landroid/view/accessibility/CaptioningManager$CaptionStyle;
Landroid/view/ActionMode;
Landroid/view/ActionMode$Callback;
Landroid/view/ActionMode$Callback2;
Landroid/view/ActionProvider;
Landroid/view/ActionProvider$VisibilityListener;
Landroid/view/animation/AccelerateDecelerateInterpolator;
Landroid/view/animation/AccelerateInterpolator;
Landroid/view/animation/AlphaAnimation;
Landroid/view/animation/Animation;
Landroid/view/animation/Animation$AnimationListener;
Landroid/view/animation/Animation$Description;
Landroid/view/animation/AnimationSet;
Landroid/view/animation/AnimationUtils;
Landroid/view/animation/AnticipateInterpolator;
Landroid/view/animation/AnticipateOvershootInterpolator;
Landroid/view/animation/BaseInterpolator;
Landroid/view/animation/BounceInterpolator;
Landroid/view/animation/CycleInterpolator;
Landroid/view/animation/DecelerateInterpolator;
Landroid/view/animation/GridLayoutAnimationController;
Landroid/view/animation/GridLayoutAnimationController$AnimationParameters;
Landroid/view/animation/Interpolator;
Landroid/view/animation/LayoutAnimationController;
Landroid/view/animation/LayoutAnimationController$AnimationParameters;
Landroid/view/animation/LinearInterpolator;
Landroid/view/animation/OvershootInterpolator;
Landroid/view/animation/PathInterpolator;
Landroid/view/animation/RotateAnimation;
Landroid/view/animation/ScaleAnimation;
Landroid/view/animation/Transformation;
Landroid/view/animation/TranslateAnimation;
Landroid/view/autofill/AutofillId;
Landroid/view/autofill/AutofillManager;
Landroid/view/autofill/AutofillManager$AutofillCallback;
Landroid/view/autofill/AutofillValue;
Landroid/view/Choreographer;
Landroid/view/Choreographer$FrameCallback;
Landroid/view/CollapsibleActionView;
Landroid/view/ContextMenu;
Landroid/view/ContextMenu$ContextMenuInfo;
Landroid/view/ContextThemeWrapper;
Landroid/view/Display;
Landroid/view/Display$HdrCapabilities;
Landroid/view/Display$Mode;
Landroid/view/DragAndDropPermissions;
Landroid/view/DragEvent;
Landroid/view/FocusFinder;
Landroid/view/FrameMetrics;
Landroid/view/FrameStats;
Landroid/view/GestureDetector;
Landroid/view/GestureDetector$OnContextClickListener;
Landroid/view/GestureDetector$OnDoubleTapListener;
Landroid/view/GestureDetector$OnGestureListener;
Landroid/view/GestureDetector$SimpleOnGestureListener;
Landroid/view/Gravity;
Landroid/view/HapticFeedbackConstants;
Landroid/view/InflateException;
Landroid/view/InputDevice;
Landroid/view/InputDevice$MotionRange;
Landroid/view/InputEvent;
Landroid/view/inputmethod/BaseInputConnection;
Landroid/view/inputmethod/CompletionInfo;
Landroid/view/inputmethod/CorrectionInfo;
Landroid/view/inputmethod/CursorAnchorInfo;
Landroid/view/inputmethod/CursorAnchorInfo$Builder;
Landroid/view/inputmethod/EditorInfo;
Landroid/view/inputmethod/ExtractedText;
Landroid/view/inputmethod/ExtractedTextRequest;
Landroid/view/inputmethod/InputBinding;
Landroid/view/inputmethod/InputConnection;
Landroid/view/inputmethod/InputConnectionWrapper;
Landroid/view/inputmethod/InputContentInfo;
Landroid/view/inputmethod/InputMethod;
Landroid/view/inputmethod/InputMethodInfo;
Landroid/view/inputmethod/InputMethodManager;
Landroid/view/inputmethod/InputMethodSession;
Landroid/view/inputmethod/InputMethod$SessionCallback;
Landroid/view/inputmethod/InputMethodSession$EventCallback;
Landroid/view/inputmethod/InputMethodSubtype;
Landroid/view/inputmethod/InputMethodSubtype$InputMethodSubtypeBuilder;
Landroid/view/InputQueue;
Landroid/view/InputQueue$Callback;
Landroid/view/KeyboardShortcutGroup;
Landroid/view/KeyboardShortcutInfo;
Landroid/view/KeyCharacterMap;
Landroid/view/KeyCharacterMap$KeyData;
Landroid/view/KeyCharacterMap$UnavailableException;
Landroid/view/KeyEvent;
Landroid/view/KeyEvent$Callback;
Landroid/view/KeyEvent$DispatcherState;
Landroid/view/LayoutInflater;
Landroid/view/LayoutInflater$Factory;
Landroid/view/LayoutInflater$Factory2;
Landroid/view/LayoutInflater$Filter;
Landroid/view/Menu;
Landroid/view/MenuInflater;
Landroid/view/MenuItem;
Landroid/view/MenuItem$OnActionExpandListener;
Landroid/view/MenuItem$OnMenuItemClickListener;
Landroid/view/MotionEvent;
Landroid/view/MotionEvent$PointerCoords;
Landroid/view/MotionEvent$PointerProperties;
Landroid/view/OrientationEventListener;
Landroid/view/OrientationListener;
Landroid/view/PixelCopy;
Landroid/view/PixelCopy$OnPixelCopyFinishedListener;
Landroid/view/PointerIcon;
Landroid/view/ScaleGestureDetector;
Landroid/view/ScaleGestureDetector$OnScaleGestureListener;
Landroid/view/ScaleGestureDetector$SimpleOnScaleGestureListener;
Landroid/view/SearchEvent;
Landroid/view/SoundEffectConstants;
Landroid/view/SubMenu;
Landroid/view/Surface;
Landroid/view/SurfaceHolder;
Landroid/view/SurfaceHolder$BadSurfaceTypeException;
Landroid/view/SurfaceHolder$Callback;
Landroid/view/SurfaceHolder$Callback2;
Landroid/view/Surface$OutOfResourcesException;
Landroid/view/SurfaceView;
Landroid/view/textclassifier/TextClassification;
Landroid/view/textclassifier/TextClassification$Builder;
Landroid/view/textclassifier/TextClassificationManager;
Landroid/view/textclassifier/TextClassifier;
Landroid/view/textclassifier/TextSelection;
Landroid/view/textclassifier/TextSelection$Builder;
Landroid/view/textservice/SentenceSuggestionsInfo;
Landroid/view/textservice/SpellCheckerInfo;
Landroid/view/textservice/SpellCheckerSession;
Landroid/view/textservice/SpellCheckerSession$SpellCheckerSessionListener;
Landroid/view/textservice/SpellCheckerSubtype;
Landroid/view/textservice/SuggestionsInfo;
Landroid/view/textservice/TextInfo;
Landroid/view/textservice/TextServicesManager;
Landroid/view/TextureView;
Landroid/view/TextureView$SurfaceTextureListener;
Landroid/view/TouchDelegate;
Landroid/view/VelocityTracker;
Landroid/view/View;
Landroid/view/View$AccessibilityDelegate;
Landroid/view/ViewAnimationUtils;
Landroid/view/View$BaseSavedState;
Landroid/view/ViewConfiguration;
Landroid/view/ViewDebug;
Landroid/view/ViewDebug$CapturedViewProperty;
Landroid/view/ViewDebug$ExportedProperty;
Landroid/view/ViewDebug$FlagToString;
Landroid/view/ViewDebug$HierarchyTraceType;
Landroid/view/ViewDebug$IntToString;
Landroid/view/ViewDebug$RecyclerTraceType;
Landroid/view/View$DragShadowBuilder;
Landroid/view/ViewGroup;
Landroid/view/ViewGroup$LayoutParams;
Landroid/view/ViewGroup$MarginLayoutParams;
Landroid/view/ViewGroup$OnHierarchyChangeListener;
Landroid/view/ViewGroupOverlay;
Landroid/view/ViewManager;
Landroid/view/View$MeasureSpec;
Landroid/view/View$OnApplyWindowInsetsListener;
Landroid/view/View$OnAttachStateChangeListener;
Landroid/view/View$OnCapturedPointerListener;
Landroid/view/View$OnClickListener;
Landroid/view/View$OnContextClickListener;
Landroid/view/View$OnCreateContextMenuListener;
Landroid/view/View$OnDragListener;
Landroid/view/View$OnFocusChangeListener;
Landroid/view/View$OnGenericMotionListener;
Landroid/view/View$OnHoverListener;
Landroid/view/View$OnKeyListener;
Landroid/view/View$OnLayoutChangeListener;
Landroid/view/View$OnLongClickListener;
Landroid/view/View$OnScrollChangeListener;
Landroid/view/View$OnSystemUiVisibilityChangeListener;
Landroid/view/View$OnTouchListener;
Landroid/view/ViewOutlineProvider;
Landroid/view/ViewOverlay;
Landroid/view/ViewParent;
Landroid/view/ViewPropertyAnimator;
Landroid/view/ViewStructure;
Landroid/view/ViewStructure$HtmlInfo;
Landroid/view/ViewStructure$HtmlInfo$Builder;
Landroid/view/ViewStub;
Landroid/view/ViewStub$OnInflateListener;
Landroid/view/ViewTreeObserver;
Landroid/view/ViewTreeObserver$OnDrawListener;
Landroid/view/ViewTreeObserver$OnGlobalFocusChangeListener;
Landroid/view/ViewTreeObserver$OnGlobalLayoutListener;
Landroid/view/ViewTreeObserver$OnPreDrawListener;
Landroid/view/ViewTreeObserver$OnScrollChangedListener;
Landroid/view/ViewTreeObserver$OnTouchModeChangeListener;
Landroid/view/ViewTreeObserver$OnWindowAttachListener;
Landroid/view/ViewTreeObserver$OnWindowFocusChangeListener;
Landroid/view/Window;
Landroid/view/WindowAnimationFrameStats;
Landroid/view/Window$Callback;
Landroid/view/WindowContentFrameStats;
Landroid/view/WindowId;
Landroid/view/WindowId$FocusObserver;
Landroid/view/WindowInsets;
Landroid/view/WindowManager;
Landroid/view/WindowManager$BadTokenException;
Landroid/view/WindowManager$InvalidDisplayException;
Landroid/view/WindowManager$LayoutParams;
Landroid/view/Window$OnFrameMetricsAvailableListener;
Landroid/view/Window$OnRestrictedCaptionAreaChangedListener;
Landroid/webkit/ClientCertRequest;
Landroid/webkit/ConsoleMessage;
Landroid/webkit/ConsoleMessage$MessageLevel;
Landroid/webkit/CookieManager;
Landroid/webkit/CookieSyncManager;
Landroid/webkit/DateSorter;
Landroid/webkit/DownloadListener;
Landroid/webkit/GeolocationPermissions;
Landroid/webkit/GeolocationPermissions$Callback;
Landroid/webkit/HttpAuthHandler;
Landroid/webkit/JavascriptInterface;
Landroid/webkit/JsPromptResult;
Landroid/webkit/JsResult;
Landroid/webkit/MimeTypeMap;
Landroid/webkit/PermissionRequest;
Landroid/webkit/PluginStub;
Landroid/webkit/RenderProcessGoneDetail;
Landroid/webkit/SafeBrowsingResponse;
Landroid/webkit/ServiceWorkerClient;
Landroid/webkit/ServiceWorkerController;
Landroid/webkit/ServiceWorkerWebSettings;
Landroid/webkit/SslErrorHandler;
Landroid/webkit/URLUtil;
Landroid/webkit/ValueCallback;
Landroid/webkit/WebBackForwardList;
Landroid/webkit/WebChromeClient;
Landroid/webkit/WebChromeClient$CustomViewCallback;
Landroid/webkit/WebChromeClient$FileChooserParams;
Landroid/webkit/WebHistoryItem;
Landroid/webkit/WebIconDatabase;
Landroid/webkit/WebIconDatabase$IconListener;
Landroid/webkit/WebMessage;
Landroid/webkit/WebMessagePort;
Landroid/webkit/WebMessagePort$WebMessageCallback;
Landroid/webkit/WebResourceError;
Landroid/webkit/WebResourceRequest;
Landroid/webkit/WebResourceResponse;
Landroid/webkit/WebSettings;
Landroid/webkit/WebSettings$LayoutAlgorithm;
Landroid/webkit/WebSettings$PluginState;
Landroid/webkit/WebSettings$RenderPriority;
Landroid/webkit/WebSettings$TextSize;
Landroid/webkit/WebSettings$ZoomDensity;
Landroid/webkit/WebStorage;
Landroid/webkit/WebStorage$Origin;
Landroid/webkit/WebStorage$QuotaUpdater;
Landroid/webkit/WebView;
Landroid/webkit/WebViewClient;
Landroid/webkit/WebViewDatabase;
Landroid/webkit/WebView$FindListener;
Landroid/webkit/WebViewFragment;
Landroid/webkit/WebView$HitTestResult;
Landroid/webkit/WebView$PictureListener;
Landroid/webkit/WebView$VisualStateCallback;
Landroid/webkit/WebView$WebViewTransport;
Landroid/widget/AbsListView;
Landroid/widget/AbsListView$LayoutParams;
Landroid/widget/AbsListView$MultiChoiceModeListener;
Landroid/widget/AbsListView$OnScrollListener;
Landroid/widget/AbsListView$RecyclerListener;
Landroid/widget/AbsListView$SelectionBoundsAdjuster;
Landroid/widget/AbsoluteLayout;
Landroid/widget/AbsoluteLayout$LayoutParams;
Landroid/widget/AbsSeekBar;
Landroid/widget/AbsSpinner;
Landroid/widget/ActionMenuView;
Landroid/widget/ActionMenuView$LayoutParams;
Landroid/widget/ActionMenuView$OnMenuItemClickListener;
Landroid/widget/Adapter;
Landroid/widget/AdapterView;
Landroid/widget/AdapterView$AdapterContextMenuInfo;
Landroid/widget/AdapterViewAnimator;
Landroid/widget/AdapterViewFlipper;
Landroid/widget/AdapterView$OnItemClickListener;
Landroid/widget/AdapterView$OnItemLongClickListener;
Landroid/widget/AdapterView$OnItemSelectedListener;
Landroid/widget/Advanceable;
Landroid/widget/AlphabetIndexer;
Landroid/widget/AnalogClock;
Landroid/widget/ArrayAdapter;
Landroid/widget/AutoCompleteTextView;
Landroid/widget/AutoCompleteTextView$OnDismissListener;
Landroid/widget/AutoCompleteTextView$Validator;
Landroid/widget/BaseAdapter;
Landroid/widget/BaseExpandableListAdapter;
Landroid/widget/Button;
Landroid/widget/CalendarView;
Landroid/widget/CalendarView$OnDateChangeListener;
Landroid/widget/Checkable;
Landroid/widget/CheckBox;
Landroid/widget/CheckedTextView;
Landroid/widget/Chronometer;
Landroid/widget/Chronometer$OnChronometerTickListener;
Landroid/widget/CompoundButton;
Landroid/widget/CompoundButton$OnCheckedChangeListener;
Landroid/widget/CursorAdapter;
Landroid/widget/CursorTreeAdapter;
Landroid/widget/DatePicker;
Landroid/widget/DatePicker$OnDateChangedListener;
Landroid/widget/DialerFilter;
Landroid/widget/DigitalClock;
Landroid/widget/EdgeEffect;
Landroid/widget/EditText;
Landroid/widget/ExpandableListAdapter;
Landroid/widget/ExpandableListView;
Landroid/widget/ExpandableListView$ExpandableListContextMenuInfo;
Landroid/widget/ExpandableListView$OnChildClickListener;
Landroid/widget/ExpandableListView$OnGroupClickListener;
Landroid/widget/ExpandableListView$OnGroupCollapseListener;
Landroid/widget/ExpandableListView$OnGroupExpandListener;
Landroid/widget/Filter;
Landroid/widget/Filterable;
Landroid/widget/Filter$FilterListener;
Landroid/widget/Filter$FilterResults;
Landroid/widget/FilterQueryProvider;
Landroid/widget/FrameLayout;
Landroid/widget/FrameLayout$LayoutParams;
Landroid/widget/Gallery;
Landroid/widget/Gallery$LayoutParams;
Landroid/widget/GridLayout;
Landroid/widget/GridLayout$Alignment;
Landroid/widget/GridLayout$LayoutParams;
Landroid/widget/GridLayout$Spec;
Landroid/widget/GridView;
Landroid/widget/HeaderViewListAdapter;
Landroid/widget/HeterogeneousExpandableList;
Landroid/widget/HorizontalScrollView;
Landroid/widget/ImageButton;
Landroid/widget/ImageSwitcher;
Landroid/widget/ImageView;
Landroid/widget/ImageView$ScaleType;
Landroid/widget/LinearLayout;
Landroid/widget/LinearLayout$LayoutParams;
Landroid/widget/ListAdapter;
Landroid/widget/ListPopupWindow;
Landroid/widget/ListView;
Landroid/widget/ListView$FixedViewInfo;
Landroid/widget/MediaController;
Landroid/widget/MediaController$MediaPlayerControl;
Landroid/widget/MultiAutoCompleteTextView;
Landroid/widget/MultiAutoCompleteTextView$CommaTokenizer;
Landroid/widget/MultiAutoCompleteTextView$Tokenizer;
Landroid/widget/NumberPicker;
Landroid/widget/NumberPicker$Formatter;
Landroid/widget/NumberPicker$OnScrollListener;
Landroid/widget/NumberPicker$OnValueChangeListener;
Landroid/widget/OverScroller;
Landroid/widget/PopupMenu;
Landroid/widget/PopupMenu$OnDismissListener;
Landroid/widget/PopupMenu$OnMenuItemClickListener;
Landroid/widget/PopupWindow;
Landroid/widget/PopupWindow$OnDismissListener;
Landroid/widget/ProgressBar;
Landroid/widget/QuickContactBadge;
Landroid/widget/RadioButton;
Landroid/widget/RadioGroup;
Landroid/widget/RadioGroup$LayoutParams;
Landroid/widget/RadioGroup$OnCheckedChangeListener;
Landroid/widget/RatingBar;
Landroid/widget/RatingBar$OnRatingBarChangeListener;
Landroid/widget/RelativeLayout;
Landroid/widget/RelativeLayout$LayoutParams;
Landroid/widget/RemoteViews;
Landroid/widget/RemoteViews$ActionException;
Landroid/widget/RemoteViews$RemoteView;
Landroid/widget/RemoteViewsService;
Landroid/widget/RemoteViewsService$RemoteViewsFactory;
Landroid/widget/ResourceCursorAdapter;
Landroid/widget/ResourceCursorTreeAdapter;
Landroid/widget/Scroller;
Landroid/widget/ScrollView;
Landroid/widget/SearchView;
Landroid/widget/SearchView$OnCloseListener;
Landroid/widget/SearchView$OnQueryTextListener;
Landroid/widget/SearchView$OnSuggestionListener;
Landroid/widget/SectionIndexer;
Landroid/widget/SeekBar;
Landroid/widget/SeekBar$OnSeekBarChangeListener;
Landroid/widget/ShareActionProvider;
Landroid/widget/ShareActionProvider$OnShareTargetSelectedListener;
Landroid/widget/SimpleAdapter;
Landroid/widget/SimpleAdapter$ViewBinder;
Landroid/widget/SimpleCursorAdapter;
Landroid/widget/SimpleCursorAdapter$CursorToStringConverter;
Landroid/widget/SimpleCursorAdapter$ViewBinder;
Landroid/widget/SimpleCursorTreeAdapter;
Landroid/widget/SimpleCursorTreeAdapter$ViewBinder;
Landroid/widget/SimpleExpandableListAdapter;
Landroid/widget/SlidingDrawer;
Landroid/widget/SlidingDrawer$OnDrawerCloseListener;
Landroid/widget/SlidingDrawer$OnDrawerOpenListener;
Landroid/widget/SlidingDrawer$OnDrawerScrollListener;
Landroid/widget/Space;
Landroid/widget/Spinner;
Landroid/widget/SpinnerAdapter;
Landroid/widget/StackView;
Landroid/widget/Switch;
Landroid/widget/TabHost;
Landroid/widget/TabHost$OnTabChangeListener;
Landroid/widget/TabHost$TabContentFactory;
Landroid/widget/TabHost$TabSpec;
Landroid/widget/TableLayout;
Landroid/widget/TableLayout$LayoutParams;
Landroid/widget/TableRow;
Landroid/widget/TableRow$LayoutParams;
Landroid/widget/TabWidget;
Landroid/widget/TextClock;
Landroid/widget/TextSwitcher;
Landroid/widget/TextView;
Landroid/widget/TextView$BufferType;
Landroid/widget/TextView$OnEditorActionListener;
Landroid/widget/TextView$SavedState;
Landroid/widget/ThemedSpinnerAdapter;
Landroid/widget/TimePicker;
Landroid/widget/TimePicker$OnTimeChangedListener;
Landroid/widget/Toast;
Landroid/widget/ToggleButton;
Landroid/widget/Toolbar;
Landroid/widget/Toolbar$LayoutParams;
Landroid/widget/Toolbar$OnMenuItemClickListener;
Landroid/widget/TwoLineListItem;
Landroid/widget/VideoView;
Landroid/widget/ViewAnimator;
Landroid/widget/ViewFlipper;
Landroid/widget/ViewSwitcher;
Landroid/widget/ViewSwitcher$ViewFactory;
Landroid/widget/WrapperListAdapter;
Landroid/widget/ZoomButton;
Landroid/widget/ZoomButtonsController;
Landroid/widget/ZoomButtonsController$OnZoomListener;
Landroid/widget/ZoomControls;
Lcom/android/internal/util/Predicate;
Ldalvik/annotation/TestTarget;
Ldalvik/annotation/TestTargetClass;
Ldalvik/bytecode/OpcodeInfo;
Ldalvik/bytecode/Opcodes;
Ldalvik/system/BaseDexClassLoader;
Ldalvik/system/DelegateLastClassLoader;
Ldalvik/system/DexClassLoader;
Ldalvik/system/DexFile;
Ldalvik/system/InMemoryDexClassLoader;
Ldalvik/system/PathClassLoader;
Ljava/awt/font/NumericShaper;
Ljava/awt/font/NumericShaper$Range;
Ljava/awt/font/TextAttribute;
Ljava/beans/IndexedPropertyChangeEvent;
Ljava/beans/PropertyChangeEvent;
Ljava/beans/PropertyChangeListener;
Ljava/beans/PropertyChangeListenerProxy;
Ljava/beans/PropertyChangeSupport;
Ljava/io/BufferedInputStream;
Ljava/io/BufferedOutputStream;
Ljava/io/BufferedReader;
Ljava/io/BufferedWriter;
Ljava/io/ByteArrayInputStream;
Ljava/io/ByteArrayOutputStream;
Ljava/io/CharArrayReader;
Ljava/io/CharArrayWriter;
Ljava/io/CharConversionException;
Ljava/io/Closeable;
Ljava/io/Console;
Ljava/io/DataInput;
Ljava/io/DataInputStream;
Ljava/io/DataOutput;
Ljava/io/DataOutputStream;
Ljava/io/EOFException;
Ljava/io/Externalizable;
Ljava/io/File;
Ljava/io/FileDescriptor;
Ljava/io/FileFilter;
Ljava/io/FileInputStream;
Ljava/io/FilenameFilter;
Ljava/io/FileNotFoundException;
Ljava/io/FileOutputStream;
Ljava/io/FilePermission;
Ljava/io/FileReader;
Ljava/io/FileWriter;
Ljava/io/FilterInputStream;
Ljava/io/FilterOutputStream;
Ljava/io/FilterReader;
Ljava/io/FilterWriter;
Ljava/io/Flushable;
Ljava/io/InputStream;
Ljava/io/InputStreamReader;
Ljava/io/InterruptedIOException;
Ljava/io/InvalidClassException;
Ljava/io/InvalidObjectException;
Ljava/io/IOError;
Ljava/io/IOException;
Ljava/io/LineNumberInputStream;
Ljava/io/LineNumberReader;
Ljava/io/NotActiveException;
Ljava/io/NotSerializableException;
Ljava/io/ObjectInput;
Ljava/io/ObjectInputStream;
Ljava/io/ObjectInputStream$GetField;
Ljava/io/ObjectInputValidation;
Ljava/io/ObjectOutput;
Ljava/io/ObjectOutputStream;
Ljava/io/ObjectOutputStream$PutField;
Ljava/io/ObjectStreamClass;
Ljava/io/ObjectStreamConstants;
Ljava/io/ObjectStreamException;
Ljava/io/ObjectStreamField;
Ljava/io/OptionalDataException;
Ljava/io/OutputStream;
Ljava/io/OutputStreamWriter;
Ljava/io/PipedInputStream;
Ljava/io/PipedOutputStream;
Ljava/io/PipedReader;
Ljava/io/PipedWriter;
Ljava/io/PrintStream;
Ljava/io/PrintWriter;
Ljava/io/PushbackInputStream;
Ljava/io/PushbackReader;
Ljava/io/RandomAccessFile;
Ljava/io/Reader;
Ljava/io/SequenceInputStream;
Ljava/io/Serializable;
Ljava/io/SerializablePermission;
Ljava/io/StreamCorruptedException;
Ljava/io/StreamTokenizer;
Ljava/io/StringBufferInputStream;
Ljava/io/StringReader;
Ljava/io/StringWriter;
Ljava/io/SyncFailedException;
Ljava/io/UncheckedIOException;
Ljava/io/UnsupportedEncodingException;
Ljava/io/UTFDataFormatException;
Ljava/io/WriteAbortedException;
Ljava/io/Writer;
Ljava/lang/AbstractMethodError;
Ljava/lang/annotation/Annotation;
Ljava/lang/annotation/AnnotationFormatError;
Ljava/lang/annotation/AnnotationTypeMismatchException;
Ljava/lang/annotation/Documented;
Ljava/lang/annotation/ElementType;
Ljava/lang/annotation/IncompleteAnnotationException;
Ljava/lang/annotation/Inherited;
Ljava/lang/annotation/Native;
Ljava/lang/annotation/Repeatable;
Ljava/lang/annotation/Retention;
Ljava/lang/annotation/RetentionPolicy;
Ljava/lang/annotation/Target;
Ljava/lang/Appendable;
Ljava/lang/ArithmeticException;
Ljava/lang/ArrayIndexOutOfBoundsException;
Ljava/lang/ArrayStoreException;
Ljava/lang/AssertionError;
Ljava/lang/AutoCloseable;
Ljava/lang/Boolean;
Ljava/lang/BootstrapMethodError;
Ljava/lang/Byte;
Ljava/lang/Character;
Ljava/lang/Character$Subset;
Ljava/lang/Character$UnicodeBlock;
Ljava/lang/Character$UnicodeScript;
Ljava/lang/CharSequence;
Ljava/lang/Class;
Ljava/lang/ClassCastException;
Ljava/lang/ClassCircularityError;
Ljava/lang/ClassFormatError;
Ljava/lang/ClassLoader;
Ljava/lang/ClassNotFoundException;
Ljava/lang/Cloneable;
Ljava/lang/CloneNotSupportedException;
Ljava/lang/Comparable;
Ljava/lang/Compiler;
Ljava/lang/Deprecated;
Ljava/lang/Double;
Ljava/lang/Enum;
Ljava/lang/EnumConstantNotPresentException;
Ljava/lang/Error;
Ljava/lang/Exception;
Ljava/lang/ExceptionInInitializerError;
Ljava/lang/Float;
Ljava/lang/FunctionalInterface;
Ljava/lang/IllegalAccessError;
Ljava/lang/IllegalAccessException;
Ljava/lang/IllegalArgumentException;
Ljava/lang/IllegalMonitorStateException;
Ljava/lang/IllegalStateException;
Ljava/lang/IllegalThreadStateException;
Ljava/lang/IncompatibleClassChangeError;
Ljava/lang/IndexOutOfBoundsException;
Ljava/lang/InheritableThreadLocal;
Ljava/lang/InstantiationError;
Ljava/lang/InstantiationException;
Ljava/lang/Integer;
Ljava/lang/InternalError;
Ljava/lang/InterruptedException;
Ljava/lang/invoke/CallSite;
Ljava/lang/invoke/ConstantCallSite;
Ljava/lang/invoke/LambdaConversionException;
Ljava/lang/invoke/MethodHandle;
Ljava/lang/invoke/MethodHandleInfo;
Ljava/lang/invoke/MethodHandles;
Ljava/lang/invoke/MethodHandles$Lookup;
Ljava/lang/invoke/MethodType;
Ljava/lang/invoke/MutableCallSite;
Ljava/lang/invoke/VolatileCallSite;
Ljava/lang/invoke/WrongMethodTypeException;
Ljava/lang/Iterable;
Ljava/lang/LinkageError;
Ljava/lang/Long;
Ljava/lang/Math;
Ljava/lang/NegativeArraySizeException;
Ljava/lang/NoClassDefFoundError;
Ljava/lang/NoSuchFieldError;
Ljava/lang/NoSuchFieldException;
Ljava/lang/NoSuchMethodError;
Ljava/lang/NoSuchMethodException;
Ljava/lang/NullPointerException;
Ljava/lang/Number;
Ljava/lang/NumberFormatException;
Ljava/lang/Object;
Ljava/lang/OutOfMemoryError;
Ljava/lang/Override;
Ljava/lang/Package;
Ljava/lang/Process;
Ljava/lang/ProcessBuilder;
Ljava/lang/ProcessBuilder$Redirect;
Ljava/lang/ProcessBuilder$Redirect$Type;
Ljava/lang/Readable;
Ljava/lang/reflect/AccessibleObject;
Ljava/lang/reflect/AnnotatedElement;
Ljava/lang/reflect/Array;
Ljava/lang/reflect/Constructor;
Ljava/lang/reflect/Executable;
Ljava/lang/reflect/Field;
Ljava/lang/reflect/GenericArrayType;
Ljava/lang/reflect/GenericDeclaration;
Ljava/lang/reflect/GenericSignatureFormatError;
Ljava/lang/reflect/InvocationHandler;
Ljava/lang/reflect/InvocationTargetException;
Ljava/lang/ReflectiveOperationException;
Ljava/lang/reflect/MalformedParameterizedTypeException;
Ljava/lang/reflect/Member;
Ljava/lang/reflect/Method;
Ljava/lang/reflect/Modifier;
Ljava/lang/reflect/Parameter;
Ljava/lang/reflect/ParameterizedType;
Ljava/lang/reflect/Proxy;
Ljava/lang/reflect/ReflectPermission;
Ljava/lang/reflect/Type;
Ljava/lang/reflect/TypeVariable;
Ljava/lang/reflect/UndeclaredThrowableException;
Ljava/lang/reflect/WildcardType;
Ljava/lang/ref/PhantomReference;
Ljava/lang/ref/Reference;
Ljava/lang/ref/ReferenceQueue;
Ljava/lang/ref/SoftReference;
Ljava/lang/ref/WeakReference;
Ljava/lang/Runnable;
Ljava/lang/Runtime;
Ljava/lang/RuntimeException;
Ljava/lang/RuntimePermission;
Ljava/lang/SafeVarargs;
Ljava/lang/SecurityException;
Ljava/lang/SecurityManager;
Ljava/lang/Short;
Ljava/lang/StackOverflowError;
Ljava/lang/StackTraceElement;
Ljava/lang/StrictMath;
Ljava/lang/String;
Ljava/lang/StringBuffer;
Ljava/lang/StringBuilder;
Ljava/lang/StringIndexOutOfBoundsException;
Ljava/lang/SuppressWarnings;
Ljava/lang/System;
Ljava/lang/Thread;
Ljava/lang/ThreadDeath;
Ljava/lang/ThreadGroup;
Ljava/lang/ThreadLocal;
Ljava/lang/Thread$State;
Ljava/lang/Thread$UncaughtExceptionHandler;
Ljava/lang/Throwable;
Ljava/lang/TypeNotPresentException;
Ljava/lang/UnknownError;
Ljava/lang/UnsatisfiedLinkError;
Ljava/lang/UnsupportedClassVersionError;
Ljava/lang/UnsupportedOperationException;
Ljava/lang/VerifyError;
Ljava/lang/VirtualMachineError;
Ljava/lang/Void;
Ljava/math/BigDecimal;
Ljava/math/BigInteger;
Ljava/math/MathContext;
Ljava/math/RoundingMode;
Ljava/net/Authenticator;
Ljava/net/Authenticator$RequestorType;
Ljava/net/BindException;
Ljava/net/CacheRequest;
Ljava/net/CacheResponse;
Ljava/net/ConnectException;
Ljava/net/ContentHandler;
Ljava/net/ContentHandlerFactory;
Ljava/net/CookieHandler;
Ljava/net/CookieManager;
Ljava/net/CookiePolicy;
Ljava/net/CookieStore;
Ljava/net/DatagramPacket;
Ljava/net/DatagramSocket;
Ljava/net/DatagramSocketImpl;
Ljava/net/DatagramSocketImplFactory;
Ljava/net/FileNameMap;
Ljava/net/HttpCookie;
Ljava/net/HttpRetryException;
Ljava/net/HttpURLConnection;
Ljava/net/IDN;
Ljava/net/Inet4Address;
Ljava/net/Inet6Address;
Ljava/net/InetAddress;
Ljava/net/InetSocketAddress;
Ljava/net/InterfaceAddress;
Ljava/net/JarURLConnection;
Ljava/net/MalformedURLException;
Ljava/net/MulticastSocket;
Ljava/net/NetPermission;
Ljava/net/NetworkInterface;
Ljava/net/NoRouteToHostException;
Ljava/net/PasswordAuthentication;
Ljava/net/PortUnreachableException;
Ljava/net/ProtocolException;
Ljava/net/ProtocolFamily;
Ljava/net/Proxy;
Ljava/net/ProxySelector;
Ljava/net/Proxy$Type;
Ljava/net/ResponseCache;
Ljava/net/SecureCacheResponse;
Ljava/net/ServerSocket;
Ljava/net/Socket;
Ljava/net/SocketAddress;
Ljava/net/SocketException;
Ljava/net/SocketImpl;
Ljava/net/SocketImplFactory;
Ljava/net/SocketOption;
Ljava/net/SocketOptions;
Ljava/net/SocketPermission;
Ljava/net/SocketTimeoutException;
Ljava/net/StandardProtocolFamily;
Ljava/net/StandardSocketOptions;
Ljava/net/UnknownHostException;
Ljava/net/UnknownServiceException;
Ljava/net/URI;
Ljava/net/URISyntaxException;
Ljava/net/URL;
Ljava/net/URLClassLoader;
Ljava/net/URLConnection;
Ljava/net/URLDecoder;
Ljava/net/URLEncoder;
Ljava/net/URLStreamHandler;
Ljava/net/URLStreamHandlerFactory;
Ljava/nio/Buffer;
Ljava/nio/BufferOverflowException;
Ljava/nio/BufferUnderflowException;
Ljava/nio/ByteBuffer;
Ljava/nio/ByteOrder;
Ljava/nio/channels/AcceptPendingException;
Ljava/nio/channels/AlreadyBoundException;
Ljava/nio/channels/AlreadyConnectedException;
Ljava/nio/channels/AsynchronousByteChannel;
Ljava/nio/channels/AsynchronousChannel;
Ljava/nio/channels/AsynchronousChannelGroup;
Ljava/nio/channels/AsynchronousCloseException;
Ljava/nio/channels/AsynchronousFileChannel;
Ljava/nio/channels/AsynchronousServerSocketChannel;
Ljava/nio/channels/AsynchronousSocketChannel;
Ljava/nio/channels/ByteChannel;
Ljava/nio/channels/CancelledKeyException;
Ljava/nio/channels/Channel;
Ljava/nio/channels/Channels;
Ljava/nio/channels/ClosedByInterruptException;
Ljava/nio/channels/ClosedChannelException;
Ljava/nio/channels/ClosedSelectorException;
Ljava/nio/channels/CompletionHandler;
Ljava/nio/channels/ConnectionPendingException;
Ljava/nio/channels/DatagramChannel;
Ljava/nio/channels/FileChannel;
Ljava/nio/channels/FileChannel$MapMode;
Ljava/nio/channels/FileLock;
Ljava/nio/channels/FileLockInterruptionException;
Ljava/nio/channels/GatheringByteChannel;
Ljava/nio/channels/IllegalBlockingModeException;
Ljava/nio/channels/IllegalChannelGroupException;
Ljava/nio/channels/IllegalSelectorException;
Ljava/nio/channels/InterruptedByTimeoutException;
Ljava/nio/channels/InterruptibleChannel;
Ljava/nio/channels/MembershipKey;
Ljava/nio/channels/MulticastChannel;
Ljava/nio/channels/NetworkChannel;
Ljava/nio/channels/NoConnectionPendingException;
Ljava/nio/channels/NonReadableChannelException;
Ljava/nio/channels/NonWritableChannelException;
Ljava/nio/channels/NotYetBoundException;
Ljava/nio/channels/NotYetConnectedException;
Ljava/nio/channels/OverlappingFileLockException;
Ljava/nio/channels/Pipe;
Ljava/nio/channels/Pipe$SinkChannel;
Ljava/nio/channels/Pipe$SourceChannel;
Ljava/nio/channels/ReadableByteChannel;
Ljava/nio/channels/ReadPendingException;
Ljava/nio/channels/ScatteringByteChannel;
Ljava/nio/channels/SeekableByteChannel;
Ljava/nio/channels/SelectableChannel;
Ljava/nio/channels/SelectionKey;
Ljava/nio/channels/Selector;
Ljava/nio/channels/ServerSocketChannel;
Ljava/nio/channels/ShutdownChannelGroupException;
Ljava/nio/channels/SocketChannel;
Ljava/nio/channels/spi/AbstractInterruptibleChannel;
Ljava/nio/channels/spi/AbstractSelectableChannel;
Ljava/nio/channels/spi/AbstractSelectionKey;
Ljava/nio/channels/spi/AbstractSelector;
Ljava/nio/channels/spi/AsynchronousChannelProvider;
Ljava/nio/channels/spi/SelectorProvider;
Ljava/nio/channels/UnresolvedAddressException;
Ljava/nio/channels/UnsupportedAddressTypeException;
Ljava/nio/channels/WritableByteChannel;
Ljava/nio/channels/WritePendingException;
Ljava/nio/CharBuffer;
Ljava/nio/charset/CharacterCodingException;
Ljava/nio/charset/Charset;
Ljava/nio/charset/CharsetDecoder;
Ljava/nio/charset/CharsetEncoder;
Ljava/nio/charset/CoderMalfunctionError;
Ljava/nio/charset/CoderResult;
Ljava/nio/charset/CodingErrorAction;
Ljava/nio/charset/IllegalCharsetNameException;
Ljava/nio/charset/MalformedInputException;
Ljava/nio/charset/spi/CharsetProvider;
Ljava/nio/charset/StandardCharsets;
Ljava/nio/charset/UnmappableCharacterException;
Ljava/nio/charset/UnsupportedCharsetException;
Ljava/nio/DoubleBuffer;
Ljava/nio/file/AccessDeniedException;
Ljava/nio/file/AccessMode;
Ljava/nio/file/AtomicMoveNotSupportedException;
Ljava/nio/file/attribute/AclEntry;
Ljava/nio/file/attribute/AclEntry$Builder;
Ljava/nio/file/attribute/AclEntryFlag;
Ljava/nio/file/attribute/AclEntryPermission;
Ljava/nio/file/attribute/AclEntryType;
Ljava/nio/file/attribute/AclFileAttributeView;
Ljava/nio/file/attribute/AttributeView;
Ljava/nio/file/attribute/BasicFileAttributes;
Ljava/nio/file/attribute/BasicFileAttributeView;
Ljava/nio/file/attribute/DosFileAttributes;
Ljava/nio/file/attribute/DosFileAttributeView;
Ljava/nio/file/attribute/FileAttribute;
Ljava/nio/file/attribute/FileAttributeView;
Ljava/nio/file/attribute/FileOwnerAttributeView;
Ljava/nio/file/attribute/FileStoreAttributeView;
Ljava/nio/file/attribute/FileTime;
Ljava/nio/file/attribute/GroupPrincipal;
Ljava/nio/file/attribute/PosixFileAttributes;
Ljava/nio/file/attribute/PosixFileAttributeView;
Ljava/nio/file/attribute/PosixFilePermission;
Ljava/nio/file/attribute/PosixFilePermissions;
Ljava/nio/file/attribute/UserDefinedFileAttributeView;
Ljava/nio/file/attribute/UserPrincipal;
Ljava/nio/file/attribute/UserPrincipalLookupService;
Ljava/nio/file/attribute/UserPrincipalNotFoundException;
Ljava/nio/file/ClosedDirectoryStreamException;
Ljava/nio/file/ClosedFileSystemException;
Ljava/nio/file/ClosedWatchServiceException;
Ljava/nio/file/CopyOption;
Ljava/nio/file/DirectoryIteratorException;
Ljava/nio/file/DirectoryNotEmptyException;
Ljava/nio/file/DirectoryStream;
Ljava/nio/file/DirectoryStream$Filter;
Ljava/nio/file/FileAlreadyExistsException;
Ljava/nio/file/Files;
Ljava/nio/file/FileStore;
Ljava/nio/file/FileSystem;
Ljava/nio/file/FileSystemAlreadyExistsException;
Ljava/nio/file/FileSystemException;
Ljava/nio/file/FileSystemLoopException;
Ljava/nio/file/FileSystemNotFoundException;
Ljava/nio/file/FileSystems;
Ljava/nio/file/FileVisitOption;
Ljava/nio/file/FileVisitor;
Ljava/nio/file/FileVisitResult;
Ljava/nio/file/InvalidPathException;
Ljava/nio/file/LinkOption;
Ljava/nio/file/LinkPermission;
Ljava/nio/file/NoSuchFileException;
Ljava/nio/file/NotDirectoryException;
Ljava/nio/file/NotLinkException;
Ljava/nio/file/OpenOption;
Ljava/nio/file/Path;
Ljava/nio/file/PathMatcher;
Ljava/nio/file/Paths;
Ljava/nio/file/ProviderMismatchException;
Ljava/nio/file/ProviderNotFoundException;
Ljava/nio/file/ReadOnlyFileSystemException;
Ljava/nio/file/SecureDirectoryStream;
Ljava/nio/file/SimpleFileVisitor;
Ljava/nio/file/spi/FileSystemProvider;
Ljava/nio/file/spi/FileTypeDetector;
Ljava/nio/file/StandardCopyOption;
Ljava/nio/file/StandardOpenOption;
Ljava/nio/file/StandardWatchEventKinds;
Ljava/nio/file/Watchable;
Ljava/nio/file/WatchEvent;
Ljava/nio/file/WatchEvent$Kind;
Ljava/nio/file/WatchEvent$Modifier;
Ljava/nio/file/WatchKey;
Ljava/nio/file/WatchService;
Ljava/nio/FloatBuffer;
Ljava/nio/IntBuffer;
Ljava/nio/InvalidMarkException;
Ljava/nio/LongBuffer;
Ljava/nio/MappedByteBuffer;
Ljava/nio/ReadOnlyBufferException;
Ljava/nio/ShortBuffer;
Ljava/security/AccessControlContext;
Ljava/security/AccessControlException;
Ljava/security/AccessController;
Ljava/security/acl/Acl;
Ljava/security/acl/AclEntry;
Ljava/security/acl/AclNotFoundException;
Ljava/security/acl/Group;
Ljava/security/acl/LastOwnerException;
Ljava/security/acl/NotOwnerException;
Ljava/security/acl/Owner;
Ljava/security/acl/Permission;
Ljava/security/AlgorithmConstraints;
Ljava/security/AlgorithmParameterGenerator;
Ljava/security/AlgorithmParameterGeneratorSpi;
Ljava/security/AlgorithmParameters;
Ljava/security/AlgorithmParametersSpi;
Ljava/security/AllPermission;
Ljava/security/AuthProvider;
Ljava/security/BasicPermission;
Ljava/security/cert/Certificate;
Ljava/security/cert/Certificate$CertificateRep;
Ljava/security/cert/CertificateEncodingException;
Ljava/security/cert/CertificateException;
Ljava/security/cert/CertificateExpiredException;
Ljava/security/cert/CertificateFactory;
Ljava/security/cert/CertificateFactorySpi;
Ljava/security/cert/CertificateNotYetValidException;
Ljava/security/cert/CertificateParsingException;
Ljava/security/cert/CertificateRevokedException;
Ljava/security/cert/CertPath;
Ljava/security/cert/CertPathBuilder;
Ljava/security/cert/CertPathBuilderException;
Ljava/security/cert/CertPathBuilderResult;
Ljava/security/cert/CertPathBuilderSpi;
Ljava/security/cert/CertPath$CertPathRep;
Ljava/security/cert/CertPathChecker;
Ljava/security/cert/CertPathParameters;
Ljava/security/cert/CertPathValidator;
Ljava/security/cert/CertPathValidatorException;
Ljava/security/cert/CertPathValidatorException$BasicReason;
Ljava/security/cert/CertPathValidatorException$Reason;
Ljava/security/cert/CertPathValidatorResult;
Ljava/security/cert/CertPathValidatorSpi;
Ljava/security/cert/CertSelector;
Ljava/security/cert/CertStore;
Ljava/security/cert/CertStoreException;
Ljava/security/cert/CertStoreParameters;
Ljava/security/cert/CertStoreSpi;
Ljava/security/cert/CollectionCertStoreParameters;
Ljava/security/cert/CRL;
Ljava/security/cert/CRLException;
Ljava/security/cert/CRLReason;
Ljava/security/cert/CRLSelector;
Ljava/security/cert/Extension;
Ljava/security/Certificate;
Ljava/security/cert/LDAPCertStoreParameters;
Ljava/security/cert/PKIXBuilderParameters;
Ljava/security/cert/PKIXCertPathBuilderResult;
Ljava/security/cert/PKIXCertPathChecker;
Ljava/security/cert/PKIXCertPathValidatorResult;
Ljava/security/cert/PKIXParameters;
Ljava/security/cert/PKIXReason;
Ljava/security/cert/PKIXRevocationChecker;
Ljava/security/cert/PKIXRevocationChecker$Option;
Ljava/security/cert/PolicyNode;
Ljava/security/cert/PolicyQualifierInfo;
Ljava/security/cert/TrustAnchor;
Ljava/security/cert/X509Certificate;
Ljava/security/cert/X509CertSelector;
Ljava/security/cert/X509CRL;
Ljava/security/cert/X509CRLEntry;
Ljava/security/cert/X509CRLSelector;
Ljava/security/cert/X509Extension;
Ljava/security/CodeSigner;
Ljava/security/CodeSource;
Ljava/security/CryptoPrimitive;
Ljava/security/DigestException;
Ljava/security/DigestInputStream;
Ljava/security/DigestOutputStream;
Ljava/security/DomainCombiner;
Ljava/security/DomainLoadStoreParameter;
Ljava/security/GeneralSecurityException;
Ljava/security/Guard;
Ljava/security/GuardedObject;
Ljava/security/Identity;
Ljava/security/IdentityScope;
Ljava/security/interfaces/DSAKey;
Ljava/security/interfaces/DSAKeyPairGenerator;
Ljava/security/interfaces/DSAParams;
Ljava/security/interfaces/DSAPrivateKey;
Ljava/security/interfaces/DSAPublicKey;
Ljava/security/interfaces/ECKey;
Ljava/security/interfaces/ECPrivateKey;
Ljava/security/interfaces/ECPublicKey;
Ljava/security/interfaces/RSAKey;
Ljava/security/interfaces/RSAMultiPrimePrivateCrtKey;
Ljava/security/interfaces/RSAPrivateCrtKey;
Ljava/security/interfaces/RSAPrivateKey;
Ljava/security/interfaces/RSAPublicKey;
Ljava/security/InvalidAlgorithmParameterException;
Ljava/security/InvalidKeyException;
Ljava/security/InvalidParameterException;
Ljava/security/Key;
Ljava/security/KeyException;
Ljava/security/KeyFactory;
Ljava/security/KeyFactorySpi;
Ljava/security/KeyManagementException;
Ljava/security/KeyPair;
Ljava/security/KeyPairGenerator;
Ljava/security/KeyPairGeneratorSpi;
Ljava/security/KeyRep;
Ljava/security/KeyRep$Type;
Ljava/security/KeyStore;
Ljava/security/KeyStore$Builder;
Ljava/security/KeyStore$CallbackHandlerProtection;
Ljava/security/KeyStore$Entry;
Ljava/security/KeyStore$Entry$Attribute;
Ljava/security/KeyStoreException;
Ljava/security/KeyStore$LoadStoreParameter;
Ljava/security/KeyStore$PasswordProtection;
Ljava/security/KeyStore$PrivateKeyEntry;
Ljava/security/KeyStore$ProtectionParameter;
Ljava/security/KeyStore$SecretKeyEntry;
Ljava/security/KeyStoreSpi;
Ljava/security/KeyStore$TrustedCertificateEntry;
Ljava/security/MessageDigest;
Ljava/security/MessageDigestSpi;
Ljava/security/NoSuchAlgorithmException;
Ljava/security/NoSuchProviderException;
Ljava/security/Permission;
Ljava/security/PermissionCollection;
Ljava/security/Permissions;
Ljava/security/PKCS12Attribute;
Ljava/security/Policy;
Ljava/security/Policy$Parameters;
Ljava/security/PolicySpi;
Ljava/security/Principal;
Ljava/security/PrivateKey;
Ljava/security/PrivilegedAction;
Ljava/security/PrivilegedActionException;
Ljava/security/PrivilegedExceptionAction;
Ljava/security/ProtectionDomain;
Ljava/security/Provider;
Ljava/security/ProviderException;
Ljava/security/Provider$Service;
Ljava/security/PublicKey;
Ljava/security/SecureClassLoader;
Ljava/security/SecureRandom;
Ljava/security/SecureRandomSpi;
Ljava/security/Security;
Ljava/security/SecurityPermission;
Ljava/security/Signature;
Ljava/security/SignatureException;
Ljava/security/SignatureSpi;
Ljava/security/SignedObject;
Ljava/security/Signer;
Ljava/security/spec/AlgorithmParameterSpec;
Ljava/security/spec/DSAParameterSpec;
Ljava/security/spec/DSAPrivateKeySpec;
Ljava/security/spec/DSAPublicKeySpec;
Ljava/security/spec/ECField;
Ljava/security/spec/ECFieldF2m;
Ljava/security/spec/ECFieldFp;
Ljava/security/spec/ECGenParameterSpec;
Ljava/security/spec/ECParameterSpec;
Ljava/security/spec/ECPoint;
Ljava/security/spec/ECPrivateKeySpec;
Ljava/security/spec/ECPublicKeySpec;
Ljava/security/spec/EllipticCurve;
Ljava/security/spec/EncodedKeySpec;
Ljava/security/spec/InvalidKeySpecException;
Ljava/security/spec/InvalidParameterSpecException;
Ljava/security/spec/KeySpec;
Ljava/security/spec/MGF1ParameterSpec;
Ljava/security/spec/PKCS8EncodedKeySpec;
Ljava/security/spec/PSSParameterSpec;
Ljava/security/spec/RSAKeyGenParameterSpec;
Ljava/security/spec/RSAMultiPrimePrivateCrtKeySpec;
Ljava/security/spec/RSAOtherPrimeInfo;
Ljava/security/spec/RSAPrivateCrtKeySpec;
Ljava/security/spec/RSAPrivateKeySpec;
Ljava/security/spec/RSAPublicKeySpec;
Ljava/security/spec/X509EncodedKeySpec;
Ljava/security/Timestamp;
Ljava/security/UnrecoverableEntryException;
Ljava/security/UnrecoverableKeyException;
Ljava/security/UnresolvedPermission;
Ljava/sql/Array;
Ljava/sql/BatchUpdateException;
Ljava/sql/Blob;
Ljava/sql/CallableStatement;
Ljava/sql/ClientInfoStatus;
Ljava/sql/Clob;
Ljava/sql/Connection;
Ljava/sql/DatabaseMetaData;
Ljava/sql/DataTruncation;
Ljava/sql/Date;
Ljava/sql/Driver;
Ljava/sql/DriverManager;
Ljava/sql/DriverPropertyInfo;
Ljava/sql/NClob;
Ljava/sql/ParameterMetaData;
Ljava/sql/PreparedStatement;
Ljava/sql/Ref;
Ljava/sql/ResultSet;
Ljava/sql/ResultSetMetaData;
Ljava/sql/RowId;
Ljava/sql/RowIdLifetime;
Ljava/sql/Savepoint;
Ljava/sql/SQLClientInfoException;
Ljava/sql/SQLData;
Ljava/sql/SQLDataException;
Ljava/sql/SQLException;
Ljava/sql/SQLFeatureNotSupportedException;
Ljava/sql/SQLInput;
Ljava/sql/SQLIntegrityConstraintViolationException;
Ljava/sql/SQLInvalidAuthorizationSpecException;
Ljava/sql/SQLNonTransientConnectionException;
Ljava/sql/SQLNonTransientException;
Ljava/sql/SQLOutput;
Ljava/sql/SQLPermission;
Ljava/sql/SQLRecoverableException;
Ljava/sql/SQLSyntaxErrorException;
Ljava/sql/SQLTimeoutException;
Ljava/sql/SQLTransactionRollbackException;
Ljava/sql/SQLTransientConnectionException;
Ljava/sql/SQLTransientException;
Ljava/sql/SQLWarning;
Ljava/sql/SQLXML;
Ljava/sql/Statement;
Ljava/sql/Struct;
Ljava/sql/Time;
Ljava/sql/Timestamp;
Ljava/sql/Types;
Ljava/sql/Wrapper;
Ljava/text/Annotation;
Ljava/text/AttributedCharacterIterator;
Ljava/text/AttributedCharacterIterator$Attribute;
Ljava/text/AttributedString;
Ljava/text/Bidi;
Ljava/text/BreakIterator;
Ljava/text/CharacterIterator;
Ljava/text/ChoiceFormat;
Ljava/text/CollationElementIterator;
Ljava/text/CollationKey;
Ljava/text/Collator;
Ljava/text/DateFormat;
Ljava/text/DateFormat$Field;
Ljava/text/DateFormatSymbols;
Ljava/text/DecimalFormat;
Ljava/text/DecimalFormatSymbols;
Ljava/text/FieldPosition;
Ljava/text/Format;
Ljava/text/Format$Field;
Ljava/text/MessageFormat;
Ljava/text/MessageFormat$Field;
Ljava/text/Normalizer;
Ljava/text/Normalizer$Form;
Ljava/text/NumberFormat;
Ljava/text/NumberFormat$Field;
Ljava/text/ParseException;
Ljava/text/ParsePosition;
Ljava/text/RuleBasedCollator;
Ljava/text/SimpleDateFormat;
Ljava/text/StringCharacterIterator;
Ljava/time/chrono/AbstractChronology;
Ljava/time/chrono/ChronoLocalDate;
Ljava/time/chrono/ChronoLocalDateTime;
Ljava/time/chrono/Chronology;
Ljava/time/chrono/ChronoPeriod;
Ljava/time/chrono/ChronoZonedDateTime;
Ljava/time/chrono/Era;
Ljava/time/chrono/HijrahChronology;
Ljava/time/chrono/HijrahDate;
Ljava/time/chrono/HijrahEra;
Ljava/time/chrono/IsoChronology;
Ljava/time/chrono/IsoEra;
Ljava/time/chrono/JapaneseChronology;
Ljava/time/chrono/JapaneseDate;
Ljava/time/chrono/JapaneseEra;
Ljava/time/chrono/MinguoChronology;
Ljava/time/chrono/MinguoDate;
Ljava/time/chrono/MinguoEra;
Ljava/time/chrono/ThaiBuddhistChronology;
Ljava/time/chrono/ThaiBuddhistDate;
Ljava/time/chrono/ThaiBuddhistEra;
Ljava/time/Clock;
Ljava/time/DateTimeException;
Ljava/time/DayOfWeek;
Ljava/time/Duration;
Ljava/time/format/DateTimeFormatter;
Ljava/time/format/DateTimeFormatterBuilder;
Ljava/time/format/DateTimeParseException;
Ljava/time/format/DecimalStyle;
Ljava/time/format/FormatStyle;
Ljava/time/format/ResolverStyle;
Ljava/time/format/SignStyle;
Ljava/time/format/TextStyle;
Ljava/time/Instant;
Ljava/time/LocalDate;
Ljava/time/LocalDateTime;
Ljava/time/LocalTime;
Ljava/time/Month;
Ljava/time/MonthDay;
Ljava/time/OffsetDateTime;
Ljava/time/OffsetTime;
Ljava/time/Period;
Ljava/time/temporal/ChronoField;
Ljava/time/temporal/ChronoUnit;
Ljava/time/temporal/IsoFields;
Ljava/time/temporal/JulianFields;
Ljava/time/temporal/Temporal;
Ljava/time/temporal/TemporalAccessor;
Ljava/time/temporal/TemporalAdjuster;
Ljava/time/temporal/TemporalAdjusters;
Ljava/time/temporal/TemporalAmount;
Ljava/time/temporal/TemporalField;
Ljava/time/temporal/TemporalQueries;
Ljava/time/temporal/TemporalQuery;
Ljava/time/temporal/TemporalUnit;
Ljava/time/temporal/UnsupportedTemporalTypeException;
Ljava/time/temporal/ValueRange;
Ljava/time/temporal/WeekFields;
Ljava/time/Year;
Ljava/time/YearMonth;
Ljava/time/ZonedDateTime;
Ljava/time/ZoneId;
Ljava/time/ZoneOffset;
Ljava/time/zone/ZoneOffsetTransition;
Ljava/time/zone/ZoneOffsetTransitionRule;
Ljava/time/zone/ZoneOffsetTransitionRule$TimeDefinition;
Ljava/time/zone/ZoneRules;
Ljava/time/zone/ZoneRulesException;
Ljava/util/AbstractCollection;
Ljava/util/AbstractList;
Ljava/util/AbstractMap;
Ljava/util/AbstractMap$SimpleEntry;
Ljava/util/AbstractMap$SimpleImmutableEntry;
Ljava/util/AbstractQueue;
Ljava/util/AbstractSequentialList;
Ljava/util/AbstractSet;
Ljava/util/ArrayDeque;
Ljava/util/ArrayList;
Ljava/util/Arrays;
Ljava/util/Base64;
Ljava/util/Base64$Decoder;
Ljava/util/Base64$Encoder;
Ljava/util/BitSet;
Ljava/util/Calendar;
Ljava/util/Calendar$Builder;
Ljava/util/Collection;
Ljava/util/Collections;
Ljava/util/Comparator;
Ljava/util/concurrent/AbstractExecutorService;
Ljava/util/concurrent/ArrayBlockingQueue;
Ljava/util/concurrent/atomic/AtomicBoolean;
Ljava/util/concurrent/atomic/AtomicInteger;
Ljava/util/concurrent/atomic/AtomicIntegerArray;
Ljava/util/concurrent/atomic/AtomicIntegerFieldUpdater;
Ljava/util/concurrent/atomic/AtomicLong;
Ljava/util/concurrent/atomic/AtomicLongArray;
Ljava/util/concurrent/atomic/AtomicLongFieldUpdater;
Ljava/util/concurrent/atomic/AtomicMarkableReference;
Ljava/util/concurrent/atomic/AtomicReference;
Ljava/util/concurrent/atomic/AtomicReferenceArray;
Ljava/util/concurrent/atomic/AtomicReferenceFieldUpdater;
Ljava/util/concurrent/atomic/AtomicStampedReference;
Ljava/util/concurrent/atomic/DoubleAccumulator;
Ljava/util/concurrent/atomic/DoubleAdder;
Ljava/util/concurrent/atomic/LongAccumulator;
Ljava/util/concurrent/atomic/LongAdder;
Ljava/util/concurrent/BlockingDeque;
Ljava/util/concurrent/BlockingQueue;
Ljava/util/concurrent/BrokenBarrierException;
Ljava/util/concurrent/Callable;
Ljava/util/concurrent/CancellationException;
Ljava/util/concurrent/CompletableFuture;
Ljava/util/concurrent/CompletableFuture$AsynchronousCompletionTask;
Ljava/util/concurrent/CompletionException;
Ljava/util/concurrent/CompletionService;
Ljava/util/concurrent/CompletionStage;
Ljava/util/concurrent/ConcurrentHashMap;
Ljava/util/concurrent/ConcurrentHashMap$KeySetView;
Ljava/util/concurrent/ConcurrentLinkedDeque;
Ljava/util/concurrent/ConcurrentLinkedQueue;
Ljava/util/concurrent/ConcurrentMap;
Ljava/util/concurrent/ConcurrentNavigableMap;
Ljava/util/concurrent/ConcurrentSkipListMap;
Ljava/util/concurrent/ConcurrentSkipListSet;
Ljava/util/concurrent/CopyOnWriteArrayList;
Ljava/util/concurrent/CopyOnWriteArraySet;
Ljava/util/concurrent/CountDownLatch;
Ljava/util/concurrent/CountedCompleter;
Ljava/util/concurrent/CyclicBarrier;
Ljava/util/concurrent/Delayed;
Ljava/util/concurrent/DelayQueue;
Ljava/util/concurrent/Exchanger;
Ljava/util/concurrent/ExecutionException;
Ljava/util/concurrent/Executor;
Ljava/util/concurrent/ExecutorCompletionService;
Ljava/util/concurrent/Executors;
Ljava/util/concurrent/ExecutorService;
Ljava/util/concurrent/ForkJoinPool;
Ljava/util/concurrent/ForkJoinPool$ForkJoinWorkerThreadFactory;
Ljava/util/concurrent/ForkJoinPool$ManagedBlocker;
Ljava/util/concurrent/ForkJoinTask;
Ljava/util/concurrent/ForkJoinWorkerThread;
Ljava/util/concurrent/Future;
Ljava/util/concurrent/FutureTask;
Ljava/util/concurrent/LinkedBlockingDeque;
Ljava/util/concurrent/LinkedBlockingQueue;
Ljava/util/concurrent/LinkedTransferQueue;
Ljava/util/concurrent/locks/AbstractOwnableSynchronizer;
Ljava/util/concurrent/locks/AbstractQueuedLongSynchronizer;
Ljava/util/concurrent/locks/AbstractQueuedLongSynchronizer$ConditionObject;
Ljava/util/concurrent/locks/AbstractQueuedSynchronizer;
Ljava/util/concurrent/locks/AbstractQueuedSynchronizer$ConditionObject;
Ljava/util/concurrent/locks/Condition;
Ljava/util/concurrent/locks/Lock;
Ljava/util/concurrent/locks/LockSupport;
Ljava/util/concurrent/locks/ReadWriteLock;
Ljava/util/concurrent/locks/ReentrantLock;
Ljava/util/concurrent/locks/ReentrantReadWriteLock;
Ljava/util/concurrent/locks/ReentrantReadWriteLock$ReadLock;
Ljava/util/concurrent/locks/ReentrantReadWriteLock$WriteLock;
Ljava/util/concurrent/locks/StampedLock;
Ljava/util/ConcurrentModificationException;
Ljava/util/concurrent/Phaser;
Ljava/util/concurrent/PriorityBlockingQueue;
Ljava/util/concurrent/RecursiveAction;
Ljava/util/concurrent/RecursiveTask;
Ljava/util/concurrent/RejectedExecutionException;
Ljava/util/concurrent/RejectedExecutionHandler;
Ljava/util/concurrent/RunnableFuture;
Ljava/util/concurrent/RunnableScheduledFuture;
Ljava/util/concurrent/ScheduledExecutorService;
Ljava/util/concurrent/ScheduledFuture;
Ljava/util/concurrent/ScheduledThreadPoolExecutor;
Ljava/util/concurrent/Semaphore;
Ljava/util/concurrent/SynchronousQueue;
Ljava/util/concurrent/ThreadFactory;
Ljava/util/concurrent/ThreadLocalRandom;
Ljava/util/concurrent/ThreadPoolExecutor;
Ljava/util/concurrent/ThreadPoolExecutor$AbortPolicy;
Ljava/util/concurrent/ThreadPoolExecutor$CallerRunsPolicy;
Ljava/util/concurrent/ThreadPoolExecutor$DiscardOldestPolicy;
Ljava/util/concurrent/ThreadPoolExecutor$DiscardPolicy;
Ljava/util/concurrent/TimeoutException;
Ljava/util/concurrent/TimeUnit;
Ljava/util/concurrent/TransferQueue;
Ljava/util/Currency;
Ljava/util/Date;
Ljava/util/Deque;
Ljava/util/Dictionary;
Ljava/util/DoubleSummaryStatistics;
Ljava/util/DuplicateFormatFlagsException;
Ljava/util/EmptyStackException;
Ljava/util/Enumeration;
Ljava/util/EnumMap;
Ljava/util/EnumSet;
Ljava/util/EventListener;
Ljava/util/EventListenerProxy;
Ljava/util/EventObject;
Ljava/util/FormatFlagsConversionMismatchException;
Ljava/util/Formattable;
Ljava/util/FormattableFlags;
Ljava/util/Formatter;
Ljava/util/Formatter$BigDecimalLayoutForm;
Ljava/util/FormatterClosedException;
Ljava/util/function/BiConsumer;
Ljava/util/function/BiFunction;
Ljava/util/function/BinaryOperator;
Ljava/util/function/BiPredicate;
Ljava/util/function/BooleanSupplier;
Ljava/util/function/Consumer;
Ljava/util/function/DoubleBinaryOperator;
Ljava/util/function/DoubleConsumer;
Ljava/util/function/DoubleFunction;
Ljava/util/function/DoublePredicate;
Ljava/util/function/DoubleSupplier;
Ljava/util/function/DoubleToIntFunction;
Ljava/util/function/DoubleToLongFunction;
Ljava/util/function/DoubleUnaryOperator;
Ljava/util/function/Function;
Ljava/util/function/IntBinaryOperator;
Ljava/util/function/IntConsumer;
Ljava/util/function/IntFunction;
Ljava/util/function/IntPredicate;
Ljava/util/function/IntSupplier;
Ljava/util/function/IntToDoubleFunction;
Ljava/util/function/IntToLongFunction;
Ljava/util/function/IntUnaryOperator;
Ljava/util/function/LongBinaryOperator;
Ljava/util/function/LongConsumer;
Ljava/util/function/LongFunction;
Ljava/util/function/LongPredicate;
Ljava/util/function/LongSupplier;
Ljava/util/function/LongToDoubleFunction;
Ljava/util/function/LongToIntFunction;
Ljava/util/function/LongUnaryOperator;
Ljava/util/function/ObjDoubleConsumer;
Ljava/util/function/ObjIntConsumer;
Ljava/util/function/ObjLongConsumer;
Ljava/util/function/Predicate;
Ljava/util/function/Supplier;
Ljava/util/function/ToDoubleBiFunction;
Ljava/util/function/ToDoubleFunction;
Ljava/util/function/ToIntBiFunction;
Ljava/util/function/ToIntFunction;
Ljava/util/function/ToLongBiFunction;
Ljava/util/function/ToLongFunction;
Ljava/util/function/UnaryOperator;
Ljava/util/GregorianCalendar;
Ljava/util/HashMap;
Ljava/util/HashSet;
Ljava/util/Hashtable;
Ljava/util/IdentityHashMap;
Ljava/util/IllegalFormatCodePointException;
Ljava/util/IllegalFormatConversionException;
Ljava/util/IllegalFormatException;
Ljava/util/IllegalFormatFlagsException;
Ljava/util/IllegalFormatPrecisionException;
Ljava/util/IllegalFormatWidthException;
Ljava/util/IllformedLocaleException;
Ljava/util/InputMismatchException;
Ljava/util/IntSummaryStatistics;
Ljava/util/InvalidPropertiesFormatException;
Ljava/util/Iterator;
Ljava/util/jar/Attributes;
Ljava/util/jar/Attributes$Name;
Ljava/util/jar/JarEntry;
Ljava/util/jar/JarException;
Ljava/util/jar/JarFile;
Ljava/util/jar/JarInputStream;
Ljava/util/jar/JarOutputStream;
Ljava/util/jar/Manifest;
Ljava/util/jar/Pack200;
Ljava/util/jar/Pack200$Packer;
Ljava/util/jar/Pack200$Unpacker;
Ljava/util/LinkedHashMap;
Ljava/util/LinkedHashSet;
Ljava/util/LinkedList;
Ljava/util/List;
Ljava/util/ListIterator;
Ljava/util/ListResourceBundle;
Ljava/util/Locale;
Ljava/util/Locale$Builder;
Ljava/util/Locale$Category;
Ljava/util/Locale$FilteringMode;
Ljava/util/Locale$LanguageRange;
Ljava/util/logging/ConsoleHandler;
Ljava/util/logging/ErrorManager;
Ljava/util/logging/FileHandler;
Ljava/util/logging/Filter;
Ljava/util/logging/Formatter;
Ljava/util/logging/Handler;
Ljava/util/logging/Level;
Ljava/util/logging/Logger;
Ljava/util/logging/LoggingMXBean;
Ljava/util/logging/LoggingPermission;
Ljava/util/logging/LogManager;
Ljava/util/logging/LogRecord;
Ljava/util/logging/MemoryHandler;
Ljava/util/logging/SimpleFormatter;
Ljava/util/logging/SocketHandler;
Ljava/util/logging/StreamHandler;
Ljava/util/logging/XMLFormatter;
Ljava/util/LongSummaryStatistics;
Ljava/util/Map;
Ljava/util/Map$Entry;
Ljava/util/MissingFormatArgumentException;
Ljava/util/MissingFormatWidthException;
Ljava/util/MissingResourceException;
Ljava/util/NavigableMap;
Ljava/util/NavigableSet;
Ljava/util/NoSuchElementException;
Ljava/util/Objects;
Ljava/util/Observable;
Ljava/util/Observer;
Ljava/util/Optional;
Ljava/util/OptionalDouble;
Ljava/util/OptionalInt;
Ljava/util/OptionalLong;
Ljava/util/prefs/AbstractPreferences;
Ljava/util/prefs/BackingStoreException;
Ljava/util/prefs/InvalidPreferencesFormatException;
Ljava/util/prefs/NodeChangeEvent;
Ljava/util/prefs/NodeChangeListener;
Ljava/util/prefs/PreferenceChangeEvent;
Ljava/util/prefs/PreferenceChangeListener;
Ljava/util/prefs/Preferences;
Ljava/util/prefs/PreferencesFactory;
Ljava/util/PrimitiveIterator;
Ljava/util/PrimitiveIterator$OfDouble;
Ljava/util/PrimitiveIterator$OfInt;
Ljava/util/PrimitiveIterator$OfLong;
Ljava/util/PriorityQueue;
Ljava/util/Properties;
Ljava/util/PropertyPermission;
Ljava/util/PropertyResourceBundle;
Ljava/util/Queue;
Ljava/util/Random;
Ljava/util/RandomAccess;
Ljava/util/regex/Matcher;
Ljava/util/regex/MatchResult;
Ljava/util/regex/Pattern;
Ljava/util/regex/PatternSyntaxException;
Ljava/util/ResourceBundle;
Ljava/util/ResourceBundle$Control;
Ljava/util/Scanner;
Ljava/util/ServiceConfigurationError;
Ljava/util/ServiceLoader;
Ljava/util/Set;
Ljava/util/SimpleTimeZone;
Ljava/util/SortedMap;
Ljava/util/SortedSet;
Ljava/util/Spliterator;
Ljava/util/Spliterator$OfDouble;
Ljava/util/Spliterator$OfInt;
Ljava/util/Spliterator$OfLong;
Ljava/util/Spliterator$OfPrimitive;
Ljava/util/Spliterators;
Ljava/util/Spliterators$AbstractDoubleSpliterator;
Ljava/util/Spliterators$AbstractIntSpliterator;
Ljava/util/Spliterators$AbstractLongSpliterator;
Ljava/util/Spliterators$AbstractSpliterator;
Ljava/util/SplittableRandom;
Ljava/util/Stack;
Ljava/util/stream/BaseStream;
Ljava/util/stream/Collector;
Ljava/util/stream/Collector$Characteristics;
Ljava/util/stream/Collectors;
Ljava/util/stream/DoubleStream;
Ljava/util/stream/DoubleStream$Builder;
Ljava/util/stream/IntStream;
Ljava/util/stream/IntStream$Builder;
Ljava/util/stream/LongStream;
Ljava/util/stream/LongStream$Builder;
Ljava/util/stream/Stream;
Ljava/util/stream/Stream$Builder;
Ljava/util/stream/StreamSupport;
Ljava/util/StringJoiner;
Ljava/util/StringTokenizer;
Ljava/util/Timer;
Ljava/util/TimerTask;
Ljava/util/TimeZone;
Ljava/util/TooManyListenersException;
Ljava/util/TreeMap;
Ljava/util/TreeSet;
Ljava/util/UnknownFormatConversionException;
Ljava/util/UnknownFormatFlagsException;
Ljava/util/UUID;
Ljava/util/Vector;
Ljava/util/WeakHashMap;
Ljava/util/zip/Adler32;
Ljava/util/zip/CheckedInputStream;
Ljava/util/zip/CheckedOutputStream;
Ljava/util/zip/Checksum;
Ljava/util/zip/CRC32;
Ljava/util/zip/DataFormatException;
Ljava/util/zip/Deflater;
Ljava/util/zip/DeflaterInputStream;
Ljava/util/zip/DeflaterOutputStream;
Ljava/util/zip/GZIPInputStream;
Ljava/util/zip/GZIPOutputStream;
Ljava/util/zip/Inflater;
Ljava/util/zip/InflaterInputStream;
Ljava/util/zip/InflaterOutputStream;
Ljava/util/zip/ZipEntry;
Ljava/util/zip/ZipError;
Ljava/util/zip/ZipException;
Ljava/util/zip/ZipFile;
Ljava/util/zip/ZipInputStream;
Ljava/util/zip/ZipOutputStream;
Ljavax/crypto/AEADBadTagException;
Ljavax/crypto/BadPaddingException;
Ljavax/crypto/Cipher;
Ljavax/crypto/CipherInputStream;
Ljavax/crypto/CipherOutputStream;
Ljavax/crypto/CipherSpi;
Ljavax/crypto/EncryptedPrivateKeyInfo;
Ljavax/crypto/ExemptionMechanism;
Ljavax/crypto/ExemptionMechanismException;
Ljavax/crypto/ExemptionMechanismSpi;
Ljavax/crypto/IllegalBlockSizeException;
Ljavax/crypto/interfaces/DHKey;
Ljavax/crypto/interfaces/DHPrivateKey;
Ljavax/crypto/interfaces/DHPublicKey;
Ljavax/crypto/interfaces/PBEKey;
Ljavax/crypto/KeyAgreement;
Ljavax/crypto/KeyAgreementSpi;
Ljavax/crypto/KeyGenerator;
Ljavax/crypto/KeyGeneratorSpi;
Ljavax/crypto/Mac;
Ljavax/crypto/MacSpi;
Ljavax/crypto/NoSuchPaddingException;
Ljavax/crypto/NullCipher;
Ljavax/crypto/SealedObject;
Ljavax/crypto/SecretKey;
Ljavax/crypto/SecretKeyFactory;
Ljavax/crypto/SecretKeyFactorySpi;
Ljavax/crypto/ShortBufferException;
Ljavax/crypto/spec/DESedeKeySpec;
Ljavax/crypto/spec/DESKeySpec;
Ljavax/crypto/spec/DHGenParameterSpec;
Ljavax/crypto/spec/DHParameterSpec;
Ljavax/crypto/spec/DHPrivateKeySpec;
Ljavax/crypto/spec/DHPublicKeySpec;
Ljavax/crypto/spec/GCMParameterSpec;
Ljavax/crypto/spec/IvParameterSpec;
Ljavax/crypto/spec/OAEPParameterSpec;
Ljavax/crypto/spec/PBEKeySpec;
Ljavax/crypto/spec/PBEParameterSpec;
Ljavax/crypto/spec/PSource;
Ljavax/crypto/spec/PSource$PSpecified;
Ljavax/crypto/spec/RC2ParameterSpec;
Ljavax/crypto/spec/RC5ParameterSpec;
Ljavax/crypto/spec/SecretKeySpec;
Ljavax/microedition/khronos/egl/EGL;
Ljavax/microedition/khronos/egl/EGL10;
Ljavax/microedition/khronos/egl/EGL11;
Ljavax/microedition/khronos/egl/EGLConfig;
Ljavax/microedition/khronos/egl/EGLContext;
Ljavax/microedition/khronos/egl/EGLDisplay;
Ljavax/microedition/khronos/egl/EGLSurface;
Ljavax/microedition/khronos/opengles/GL;
Ljavax/microedition/khronos/opengles/GL10;
Ljavax/microedition/khronos/opengles/GL10Ext;
Ljavax/microedition/khronos/opengles/GL11;
Ljavax/microedition/khronos/opengles/GL11Ext;
Ljavax/microedition/khronos/opengles/GL11ExtensionPack;
Ljavax/net/ServerSocketFactory;
Ljavax/net/SocketFactory;
Ljavax/net/ssl/CertPathTrustManagerParameters;
Ljavax/net/ssl/ExtendedSSLSession;
Ljavax/net/ssl/HandshakeCompletedEvent;
Ljavax/net/ssl/HandshakeCompletedListener;
Ljavax/net/ssl/HostnameVerifier;
Ljavax/net/ssl/HttpsURLConnection;
Ljavax/net/ssl/KeyManager;
Ljavax/net/ssl/KeyManagerFactory;
Ljavax/net/ssl/KeyManagerFactorySpi;
Ljavax/net/ssl/KeyStoreBuilderParameters;
Ljavax/net/ssl/ManagerFactoryParameters;
Ljavax/net/ssl/SNIHostName;
Ljavax/net/ssl/SNIMatcher;
Ljavax/net/ssl/SNIServerName;
Ljavax/net/ssl/SSLContext;
Ljavax/net/ssl/SSLContextSpi;
Ljavax/net/ssl/SSLEngine;
Ljavax/net/ssl/SSLEngineResult;
Ljavax/net/ssl/SSLEngineResult$HandshakeStatus;
Ljavax/net/ssl/SSLEngineResult$Status;
Ljavax/net/ssl/SSLException;
Ljavax/net/ssl/SSLHandshakeException;
Ljavax/net/ssl/SSLKeyException;
Ljavax/net/ssl/SSLParameters;
Ljavax/net/ssl/SSLPeerUnverifiedException;
Ljavax/net/ssl/SSLPermission;
Ljavax/net/ssl/SSLProtocolException;
Ljavax/net/ssl/SSLServerSocket;
Ljavax/net/ssl/SSLServerSocketFactory;
Ljavax/net/ssl/SSLSession;
Ljavax/net/ssl/SSLSessionBindingEvent;
Ljavax/net/ssl/SSLSessionBindingListener;
Ljavax/net/ssl/SSLSessionContext;
Ljavax/net/ssl/SSLSocket;
Ljavax/net/ssl/SSLSocketFactory;
Ljavax/net/ssl/StandardConstants;
Ljavax/net/ssl/TrustManager;
Ljavax/net/ssl/TrustManagerFactory;
Ljavax/net/ssl/TrustManagerFactorySpi;
Ljavax/net/ssl/X509ExtendedKeyManager;
Ljavax/net/ssl/X509ExtendedTrustManager;
Ljavax/net/ssl/X509KeyManager;
Ljavax/net/ssl/X509TrustManager;
Ljavax/security/auth/AuthPermission;
Ljavax/security/auth/callback/Callback;
Ljavax/security/auth/callback/CallbackHandler;
Ljavax/security/auth/callback/PasswordCallback;
Ljavax/security/auth/callback/UnsupportedCallbackException;
Ljavax/security/auth/Destroyable;
Ljavax/security/auth/DestroyFailedException;
Ljavax/security/auth/login/LoginException;
Ljavax/security/auth/PrivateCredentialPermission;
Ljavax/security/auth/Subject;
Ljavax/security/auth/SubjectDomainCombiner;
Ljavax/security/auth/x500/X500Principal;
Ljavax/security/cert/Certificate;
Ljavax/security/cert/CertificateEncodingException;
Ljavax/security/cert/CertificateException;
Ljavax/security/cert/CertificateExpiredException;
Ljavax/security/cert/CertificateNotYetValidException;
Ljavax/security/cert/CertificateParsingException;
Ljavax/security/cert/X509Certificate;
Ljavax/sql/CommonDataSource;
Ljavax/sql/ConnectionEvent;
Ljavax/sql/ConnectionEventListener;
Ljavax/sql/ConnectionPoolDataSource;
Ljavax/sql/DataSource;
Ljavax/sql/PooledConnection;
Ljavax/sql/RowSet;
Ljavax/sql/RowSetEvent;
Ljavax/sql/RowSetInternal;
Ljavax/sql/RowSetListener;
Ljavax/sql/RowSetMetaData;
Ljavax/sql/RowSetReader;
Ljavax/sql/RowSetWriter;
Ljavax/sql/StatementEvent;
Ljavax/sql/StatementEventListener;
Ljavax/xml/datatype/DatatypeConfigurationException;
Ljavax/xml/datatype/DatatypeConstants;
Ljavax/xml/datatype/DatatypeConstants$Field;
Ljavax/xml/datatype/DatatypeFactory;
Ljavax/xml/datatype/Duration;
Ljavax/xml/datatype/XMLGregorianCalendar;
Ljavax/xml/namespace/NamespaceContext;
Ljavax/xml/namespace/QName;
Ljavax/xml/parsers/DocumentBuilder;
Ljavax/xml/parsers/DocumentBuilderFactory;
Ljavax/xml/parsers/FactoryConfigurationError;
Ljavax/xml/parsers/ParserConfigurationException;
Ljavax/xml/parsers/SAXParser;
Ljavax/xml/parsers/SAXParserFactory;
Ljavax/xml/transform/dom/DOMLocator;
Ljavax/xml/transform/dom/DOMResult;
Ljavax/xml/transform/dom/DOMSource;
Ljavax/xml/transform/ErrorListener;
Ljavax/xml/transform/OutputKeys;
Ljavax/xml/transform/Result;
Ljavax/xml/transform/sax/SAXResult;
Ljavax/xml/transform/sax/SAXSource;
Ljavax/xml/transform/sax/SAXTransformerFactory;
Ljavax/xml/transform/sax/TemplatesHandler;
Ljavax/xml/transform/sax/TransformerHandler;
Ljavax/xml/transform/Source;
Ljavax/xml/transform/SourceLocator;
Ljavax/xml/transform/stream/StreamResult;
Ljavax/xml/transform/stream/StreamSource;
Ljavax/xml/transform/Templates;
Ljavax/xml/transform/Transformer;
Ljavax/xml/transform/TransformerConfigurationException;
Ljavax/xml/transform/TransformerException;
Ljavax/xml/transform/TransformerFactory;
Ljavax/xml/transform/TransformerFactoryConfigurationError;
Ljavax/xml/transform/URIResolver;
Ljavax/xml/validation/Schema;
Ljavax/xml/validation/SchemaFactory;
Ljavax/xml/validation/SchemaFactoryLoader;
Ljavax/xml/validation/TypeInfoProvider;
Ljavax/xml/validation/Validator;
Ljavax/xml/validation/ValidatorHandler;
Ljavax/xml/XMLConstants;
Ljavax/xml/xpath/XPath;
Ljavax/xml/xpath/XPathConstants;
Ljavax/xml/xpath/XPathException;
Ljavax/xml/xpath/XPathExpression;
Ljavax/xml/xpath/XPathExpressionException;
Ljavax/xml/xpath/XPathFactory;
Ljavax/xml/xpath/XPathFactoryConfigurationException;
Ljavax/xml/xpath/XPathFunction;
Ljavax/xml/xpath/XPathFunctionException;
Ljavax/xml/xpath/XPathFunctionResolver;
Ljavax/xml/xpath/XPathVariableResolver;
Ljunit/framework/Assert;
Ljunit/framework/AssertionFailedError;
Ljunit/framework/ComparisonFailure;
Ljunit/framework/Protectable;
Ljunit/framework/Test;
Ljunit/framework/TestCase;
Ljunit/framework/TestFailure;
Ljunit/framework/TestListener;
Ljunit/framework/TestResult;
Ljunit/framework/TestSuite;
Ljunit/runner/BaseTestRunner;
Ljunit/runner/TestSuiteLoader;
Ljunit/runner/Version;
Lorg/apache/http/conn/ConnectTimeoutException;
Lorg/apache/http/conn/scheme/HostNameResolver;
Lorg/apache/http/conn/scheme/LayeredSocketFactory;
Lorg/apache/http/conn/scheme/SocketFactory;
Lorg/apache/http/conn/ssl/AbstractVerifier;
Lorg/apache/http/conn/ssl/AllowAllHostnameVerifier;
Lorg/apache/http/conn/ssl/BrowserCompatHostnameVerifier;
Lorg/apache/http/conn/ssl/SSLSocketFactory;
Lorg/apache/http/conn/ssl/StrictHostnameVerifier;
Lorg/apache/http/conn/ssl/X509HostnameVerifier;
Lorg/apache/http/params/CoreConnectionPNames;
Lorg/apache/http/params/HttpConnectionParams;
Lorg/apache/http/params/HttpParams;
Lorg/json/JSONArray;
Lorg/json/JSONException;
Lorg/json/JSONObject;
Lorg/json/JSONStringer;
Lorg/json/JSONTokener;
Lorg/w3c/dom/Attr;
Lorg/w3c/dom/CDATASection;
Lorg/w3c/dom/CharacterData;
Lorg/w3c/dom/Comment;
Lorg/w3c/dom/Document;
Lorg/w3c/dom/DocumentFragment;
Lorg/w3c/dom/DocumentType;
Lorg/w3c/dom/DOMConfiguration;
Lorg/w3c/dom/DOMError;
Lorg/w3c/dom/DOMErrorHandler;
Lorg/w3c/dom/DOMException;
Lorg/w3c/dom/DOMImplementation;
Lorg/w3c/dom/DOMImplementationList;
Lorg/w3c/dom/DOMImplementationSource;
Lorg/w3c/dom/DOMLocator;
Lorg/w3c/dom/DOMStringList;
Lorg/w3c/dom/Element;
Lorg/w3c/dom/Entity;
Lorg/w3c/dom/EntityReference;
Lorg/w3c/dom/ls/DOMImplementationLS;
Lorg/w3c/dom/ls/LSException;
Lorg/w3c/dom/ls/LSInput;
Lorg/w3c/dom/ls/LSOutput;
Lorg/w3c/dom/ls/LSParser;
Lorg/w3c/dom/ls/LSParserFilter;
Lorg/w3c/dom/ls/LSResourceResolver;
Lorg/w3c/dom/ls/LSSerializer;
Lorg/w3c/dom/NamedNodeMap;
Lorg/w3c/dom/NameList;
Lorg/w3c/dom/Node;
Lorg/w3c/dom/NodeList;
Lorg/w3c/dom/Notation;
Lorg/w3c/dom/ProcessingInstruction;
Lorg/w3c/dom/Text;
Lorg/w3c/dom/TypeInfo;
Lorg/w3c/dom/UserDataHandler;
Lorg/xmlpull/v1/sax2/Driver;
Lorg/xmlpull/v1/XmlPullParser;
Lorg/xmlpull/v1/XmlPullParserException;
Lorg/xmlpull/v1/XmlPullParserFactory;
Lorg/xmlpull/v1/XmlSerializer;
Lorg/xml/sax/AttributeList;
Lorg/xml/sax/Attributes;
Lorg/xml/sax/ContentHandler;
Lorg/xml/sax/DocumentHandler;
Lorg/xml/sax/DTDHandler;
Lorg/xml/sax/EntityResolver;
Lorg/xml/sax/ErrorHandler;
Lorg/xml/sax/ext/Attributes2;
Lorg/xml/sax/ext/Attributes2Impl;
Lorg/xml/sax/ext/DeclHandler;
Lorg/xml/sax/ext/DefaultHandler2;
Lorg/xml/sax/ext/EntityResolver2;
Lorg/xml/sax/ext/LexicalHandler;
Lorg/xml/sax/ext/Locator2;
Lorg/xml/sax/ext/Locator2Impl;
Lorg/xml/sax/HandlerBase;
Lorg/xml/sax/helpers/AttributeListImpl;
Lorg/xml/sax/helpers/AttributesImpl;
Lorg/xml/sax/helpers/DefaultHandler;
Lorg/xml/sax/helpers/LocatorImpl;
Lorg/xml/sax/helpers/NamespaceSupport;
Lorg/xml/sax/helpers/ParserAdapter;
Lorg/xml/sax/helpers/ParserFactory;
Lorg/xml/sax/helpers/XMLFilterImpl;
Lorg/xml/sax/helpers/XMLReaderAdapter;
Lorg/xml/sax/helpers/XMLReaderFactory;
Lorg/xml/sax/InputSource;
Lorg/xml/sax/Locator;
Lorg/xml/sax/Parser;
Lorg/xml/sax/SAXException;
Lorg/xml/sax/SAXNotRecognizedException;
Lorg/xml/sax/SAXNotSupportedException;
Lorg/xml/sax/SAXParseException;
Lorg/xml/sax/XMLFilter;
Lorg/xml/sax/XMLReader;
Landroid/text/style/StrikethroughSpan;

```

`src/obfuscapk/resources/code_block_valid_op_codes.txt`:

```txt
move
move/from16
move/16
move-wide
move-wide/from16
move-wide/16
move-object
move-object/from16
move-object/16
return-void
return
return-wide
return-object
const/4
const/16
const
const/high16
const-wide/16
const-wide/32
const-wide
const-wide/high16
const-string
const-string/jumbo
const-class
monitor-enter
monitor-exit
check-cast
instance-of
array-length
new-instance
new-array
filled-new-array
filled-new-array/range
throw
goto
goto/16
goto/32
cmpl-float
cmpg-float
cmpl-double
cmpg-double
cmp-long
if-eq
if-ne
if-lt
if-ge
if-gt
if-le
if-eqz
if-nez
if-ltz
if-gez
if-gtz
if-lez
aget
aget-wide
aget-object
aget-boolean
aget-byte
aget-char
aget-short
aput
aput-wide
aput-object
aput-boolean
aput-byte
aput-char
aput-short
iget
iget-wide
iget-object
iget-boolean
iget-byte
iget-char
iget-short
iput
iput-wide
iput-object
iput-boolean
iput-byte
iput-char
iput-short
sget
sget-wide
sget-object
sget-boolean
sget-byte
sget-char
sget-short
sput
sput-wide
sput-object
sput-boolean
sput-byte
sput-char
sput-short
invoke-virtual
invoke-super
invoke-direct
invoke-static
invoke-interface
invoke-virtual/range
invoke-super/range
invoke-direct/range
invoke-static/range
invoke-interface/range
neg-int
not-int
neg-long
not-long
neg-float
neg-double
int-to-long
int-to-float
int-to-double
long-to-int
long-to-float
long-to-double
float-to-int
float-to-long
float-to-double
double-to-int
double-to-long
double-to-float
int-to-byte
int-to-char
int-to-short
add-int
sub-int
mul-int
div-int
rem-int
and-int
or-int
xor-int
shl-int
shr-int
ushr-int
add-long
sub-long
mul-long
div-long
rem-long
and-long
or-long
xor-long
shl-long
shr-long
ushr-long
add-float
sub-float
mul-float
div-float
rem-float
add-double
sub-double
mul-double
div-double
rem-double
add-int/2addr
sub-int/2addr
mul-int/2addr
div-int/2addr
rem-int/2addr
and-int/2addr
or-int/2addr
xor-int/2addr
shl-int/2addr
shr-int/2addr
ushr-int/2addr
add-long/2addr
sub-long/2addr
mul-long/2addr
div-long/2addr
rem-long/2addr
and-long/2addr
or-long/2addr
xor-long/2addr
shl-long/2addr
shr-long/2addr
ushr-long/2addr
add-float/2addr
sub-float/2addr
mul-float/2addr
div-float/2addr
rem-float/2addr
add-double/2addr
sub-double/2addr
mul-double/2addr
div-double/2addr
rem-double/2addr
add-int/lit16
rsub-int
mul-int/lit16
div-int/lit16
rem-int/lit16
and-int/lit16
or-int/lit16
xor-int/lit16
add-int/lit8
rsub-int/lit8
mul-int/lit8
div-int/lit8
rem-int/lit8
and-int/lit8
or-int/lit8
xor-int/lit8
shl-int/lit8
shr-int/lit8
ushr-int/lit8

```

`src/obfuscapk/resources/dangerous_api.txt`:

```txt
Landroid/accounts/AccountAuthenticatorActivity;->clearWallpaper()V
Landroid/accounts/AccountAuthenticatorActivity;->removeStickyBroadcast(Landroid/content/Intent;)V
Landroid/accounts/AccountAuthenticatorActivity;->removeStickyBroadcastAsUser(Landroid/content/Intent;Landroid/os/UserHandle;)V
Landroid/accounts/AccountAuthenticatorActivity;->setWallpaper(Landroid/graphics/Bitmap;)V
Landroid/accounts/AccountAuthenticatorActivity;->setWallpaper(Ljava/io/InputStream;)V
Landroid/accounts/AccountAuthenticatorActivity;->stopService(Landroid/content/Intent;)Z
Landroid/accounts/AccountAuthenticatorActivity;->unbindService(Landroid/content/ServiceConnection;)V
Landroid/app/Activity;->clearWallpaper()V
Landroid/app/Activity;->removeStickyBroadcast(Landroid/content/Intent;)V
Landroid/app/Activity;->removeStickyBroadcastAsUser(Landroid/content/Intent;Landroid/os/UserHandle;)V
Landroid/app/Activity;->setWallpaper(Landroid/graphics/Bitmap;)V
Landroid/app/Activity;->setWallpaper(Ljava/io/InputStream;)V
Landroid/app/Activity;->stopLockTask()V
Landroid/app/Activity;->stopService(Landroid/content/Intent;)Z
Landroid/app/Activity;->unbindService(Landroid/content/ServiceConnection;)V
Landroid/app/ActivityGroup;->clearWallpaper()V
Landroid/app/ActivityGroup;->removeStickyBroadcast(Landroid/content/Intent;)V
Landroid/app/ActivityGroup;->removeStickyBroadcastAsUser(Landroid/content/Intent;Landroid/os/UserHandle;)V
Landroid/app/ActivityGroup;->setWallpaper(Landroid/graphics/Bitmap;)V
Landroid/app/ActivityGroup;->setWallpaper(Ljava/io/InputStream;)V
Landroid/app/ActivityGroup;->stopService(Landroid/content/Intent;)Z
Landroid/app/ActivityGroup;->unbindService(Landroid/content/ServiceConnection;)V
Landroid/app/ActivityManager;->getRecentTasks(II)Ljava/util/List;
Landroid/app/ActivityManager;->getRunningAppProcesses()Ljava/util/List;
Landroid/app/ActivityManager;->getRunningTasks(I)Ljava/util/List;
Landroid/app/ActivityManager;->killBackgroundProcesses(Ljava/lang/String;)V
Landroid/app/ActivityManager;->moveTaskToFront(II)V
Landroid/app/ActivityManager;->moveTaskToFront(IILandroid/os/Bundle;)V
Landroid/app/ActivityManager;->restartPackage(Ljava/lang/String;)V
Landroid/app/admin/DevicePolicyManager;->getWifiMacAddress(Landroid/content/ComponentName;)Ljava/lang/String;
Landroid/app/AliasActivity;->clearWallpaper()V
Landroid/app/AliasActivity;->removeStickyBroadcast(Landroid/content/Intent;)V
Landroid/app/AliasActivity;->removeStickyBroadcastAsUser(Landroid/content/Intent;Landroid/os/UserHandle;)V
Landroid/app/AliasActivity;->setWallpaper(Landroid/graphics/Bitmap;)V
Landroid/app/AliasActivity;->setWallpaper(Ljava/io/InputStream;)V
Landroid/app/AliasActivity;->stopService(Landroid/content/Intent;)Z
Landroid/app/AliasActivity;->unbindService(Landroid/content/ServiceConnection;)V
Landroid/app/Application;->clearWallpaper()V
Landroid/app/Application;->removeStickyBroadcast(Landroid/content/Intent;)V
Landroid/app/Application;->removeStickyBroadcastAsUser(Landroid/content/Intent;Landroid/os/UserHandle;)V
Landroid/app/Application;->setWallpaper(Landroid/graphics/Bitmap;)V
Landroid/app/Application;->setWallpaper(Ljava/io/InputStream;)V
Landroid/app/Application;->stopService(Landroid/content/Intent;)Z
Landroid/app/Application;->unbindService(Landroid/content/ServiceConnection;)V
Landroid/app/backup/BackupAgentHelper;->clearWallpaper()V
Landroid/app/backup/BackupAgentHelper;->removeStickyBroadcast(Landroid/content/Intent;)V
Landroid/app/backup/BackupAgentHelper;->removeStickyBroadcastAsUser(Landroid/content/Intent;Landroid/os/UserHandle;)V
Landroid/app/backup/BackupAgentHelper;->setWallpaper(Landroid/graphics/Bitmap;)V
Landroid/app/backup/BackupAgentHelper;->setWallpaper(Ljava/io/InputStream;)V
Landroid/app/backup/BackupAgentHelper;->stopService(Landroid/content/Intent;)Z
Landroid/app/backup/BackupAgentHelper;->unbindService(Landroid/content/ServiceConnection;)V
Landroid/app/backup/BackupManager;->dataChanged()V
Landroid/app/backup/BackupManager;->dataChanged(Ljava/lang/String;)V
Landroid/app/ExpandableListActivity;->clearWallpaper()V
Landroid/app/ExpandableListActivity;->removeStickyBroadcast(Landroid/content/Intent;)V
Landroid/app/ExpandableListActivity;->removeStickyBroadcastAsUser(Landroid/content/Intent;Landroid/os/UserHandle;)V
Landroid/app/ExpandableListActivity;->setWallpaper(Landroid/graphics/Bitmap;)V
Landroid/app/ExpandableListActivity;->setWallpaper(Ljava/io/InputStream;)V
Landroid/app/ExpandableListActivity;->stopService(Landroid/content/Intent;)Z
Landroid/app/ExpandableListActivity;->unbindService(Landroid/content/ServiceConnection;)V
Landroid/app/JobSchedulerImpl;->schedule(Landroid/app/job/JobInfo;)I
Landroid/app/KeyguardManager$KeyguardLock;->disableKeyguard()V
Landroid/app/KeyguardManager$KeyguardLock;->reenableKeyguard()V
Landroid/app/KeyguardManager;->exitKeyguardSecurely(Landroid/app/KeyguardManager$OnKeyguardExitResult;)V
Landroid/app/ListActivity;->clearWallpaper()V
Landroid/app/ListActivity;->removeStickyBroadcast(Landroid/content/Intent;)V
Landroid/app/ListActivity;->removeStickyBroadcastAsUser(Landroid/content/Intent;Landroid/os/UserHandle;)V
Landroid/app/ListActivity;->setWallpaper(Landroid/graphics/Bitmap;)V
Landroid/app/ListActivity;->setWallpaper(Ljava/io/InputStream;)V
Landroid/app/ListActivity;->stopService(Landroid/content/Intent;)Z
Landroid/app/ListActivity;->unbindService(Landroid/content/ServiceConnection;)V
Landroid/app/NativeActivity;->clearWallpaper()V
Landroid/app/NativeActivity;->removeStickyBroadcast(Landroid/content/Intent;)V
Landroid/app/NativeActivity;->removeStickyBroadcastAsUser(Landroid/content/Intent;Landroid/os/UserHandle;)V
Landroid/app/NativeActivity;->setWallpaper(Landroid/graphics/Bitmap;)V
Landroid/app/NativeActivity;->setWallpaper(Ljava/io/InputStream;)V
Landroid/app/NativeActivity;->stopService(Landroid/content/Intent;)Z
Landroid/app/NativeActivity;->unbindService(Landroid/content/ServiceConnection;)V
Landroid/app/Service;->stopSelf()V
Landroid/app/Service;->stopSelf(I)V
Landroid/app/Service;->stopSelfResult(I)Z
Landroid/app/TabActivity;->clearWallpaper()V
Landroid/app/TabActivity;->removeStickyBroadcast(Landroid/content/Intent;)V
Landroid/app/TabActivity;->removeStickyBroadcastAsUser(Landroid/content/Intent;Landroid/os/UserHandle;)V
Landroid/app/TabActivity;->setWallpaper(Landroid/graphics/Bitmap;)V
Landroid/app/TabActivity;->setWallpaper(Ljava/io/InputStream;)V
Landroid/app/TabActivity;->stopService(Landroid/content/Intent;)Z
Landroid/app/TabActivity;->unbindService(Landroid/content/ServiceConnection;)V
Landroid/app/WallpaperManager;->clear()V
Landroid/app/WallpaperManager;->clear(I)V
Landroid/app/WallpaperManager;->setBitmap(Landroid/graphics/Bitmap;)V
Landroid/app/WallpaperManager;->setBitmap(Landroid/graphics/Bitmap;Landroid/graphics/Rect;Z)I
Landroid/app/WallpaperManager;->setBitmap(Landroid/graphics/Bitmap;Landroid/graphics/Rect;ZI)I
Landroid/app/WallpaperManager;->setResource(I)V
Landroid/app/WallpaperManager;->setResource(II)I
Landroid/app/WallpaperManager;->setStream(Ljava/io/InputStream;)V
Landroid/app/WallpaperManager;->setStream(Ljava/io/InputStream;Landroid/graphics/Rect;Z)I
Landroid/app/WallpaperManager;->setStream(Ljava/io/InputStream;Landroid/graphics/Rect;ZI)I
Landroid/app/WallpaperManager;->suggestDesiredDimensions(II)V
Landroid/bluetooth/BluetoothA2dp;->getConnectedDevices()Ljava/util/List;
Landroid/bluetooth/BluetoothA2dp;->getConnectionState(Landroid/bluetooth/BluetoothDevice;)I
Landroid/bluetooth/BluetoothA2dp;->getDevicesMatchingConnectionStates([I)Ljava/util/List;
Landroid/bluetooth/BluetoothA2dp;->isA2dpPlaying(Landroid/bluetooth/BluetoothDevice;)Z
Landroid/bluetooth/BluetoothAdapter;->cancelDiscovery()Z
Landroid/bluetooth/BluetoothAdapter;->closeProfileProxy(ILandroid/bluetooth/BluetoothProfile;)V
Landroid/bluetooth/BluetoothAdapter;->disable()Z
Landroid/bluetooth/BluetoothAdapter;->enable()Z
Landroid/bluetooth/BluetoothAdapter;->getAddress()Ljava/lang/String;
Landroid/bluetooth/BluetoothAdapter;->getBluetoothLeAdvertiser()Landroid/bluetooth/le/BluetoothLeAdvertiser;
Landroid/bluetooth/BluetoothAdapter;->getBluetoothLeScanner()Landroid/bluetooth/le/BluetoothLeScanner;
Landroid/bluetooth/BluetoothAdapter;->getBondedDevices()Ljava/util/Set;
Landroid/bluetooth/BluetoothAdapter;->getName()Ljava/lang/String;
Landroid/bluetooth/BluetoothAdapter;->getProfileConnectionState(I)I
Landroid/bluetooth/BluetoothAdapter;->getProfileProxy(Landroid/content/Context;Landroid/bluetooth/BluetoothProfile$ServiceListener;I)Z
Landroid/bluetooth/BluetoothAdapter;->getScanMode()I
Landroid/bluetooth/BluetoothAdapter;->getState()I
Landroid/bluetooth/BluetoothAdapter;->isDiscovering()Z
Landroid/bluetooth/BluetoothAdapter;->isEnabled()Z
Landroid/bluetooth/BluetoothAdapter;->isMultipleAdvertisementSupported()Z
Landroid/bluetooth/BluetoothAdapter;->isOffloadedFilteringSupported()Z
Landroid/bluetooth/BluetoothAdapter;->isOffloadedScanBatchingSupported()Z
Landroid/bluetooth/BluetoothAdapter;->listenUsingInsecureRfcommWithServiceRecord(Ljava/lang/String;Ljava/util/UUID;)Landroid/bluetooth/BluetoothServerSocket;
Landroid/bluetooth/BluetoothAdapter;->listenUsingRfcommWithServiceRecord(Ljava/lang/String;Ljava/util/UUID;)Landroid/bluetooth/BluetoothServerSocket;
Landroid/bluetooth/BluetoothAdapter;->setName(Ljava/lang/String;)Z
Landroid/bluetooth/BluetoothAdapter;->startDiscovery()Z
Landroid/bluetooth/BluetoothAdapter;->startLeScan(L[java/util/UUID;Landroid/bluetooth/BluetoothAdapter$LeScanCallback;)Z
Landroid/bluetooth/BluetoothAdapter;->startLeScan(Landroid/bluetooth/BluetoothAdapter$LeScanCallback;)Z
Landroid/bluetooth/BluetoothAdapter;->stopLeScan(Landroid/bluetooth/BluetoothAdapter$LeScanCallback;)V
Landroid/bluetooth/BluetoothDevice;->connectGatt(Landroid/content/Context;ZLandroid/bluetooth/BluetoothGattCallback;)Landroid/bluetooth/BluetoothGatt;
Landroid/bluetooth/BluetoothDevice;->connectGatt(Landroid/content/Context;ZLandroid/bluetooth/BluetoothGattCallback;I)Landroid/bluetooth/BluetoothGatt;
Landroid/bluetooth/BluetoothDevice;->createBond()Z
Landroid/bluetooth/BluetoothDevice;->createInsecureRfcommSocketToServiceRecord(Ljava/util/UUID;)Landroid/bluetooth/BluetoothSocket;
Landroid/bluetooth/BluetoothDevice;->createRfcommSocketToServiceRecord(Ljava/util/UUID;)Landroid/bluetooth/BluetoothSocket;
Landroid/bluetooth/BluetoothDevice;->fetchUuidsWithSdp()Z
Landroid/bluetooth/BluetoothDevice;->getBluetoothClass()Landroid/bluetooth/BluetoothClass;
Landroid/bluetooth/BluetoothDevice;->getBondState()I
Landroid/bluetooth/BluetoothDevice;->getName()Ljava/lang/String;
Landroid/bluetooth/BluetoothDevice;->getType()I
Landroid/bluetooth/BluetoothDevice;->getUuids()[Landroid/os/ParcelUuid;
Landroid/bluetooth/BluetoothDevice;->setPin([B)Z
Landroid/bluetooth/BluetoothGatt;->abortReliableWrite()V
Landroid/bluetooth/BluetoothGatt;->abortReliableWrite(Landroid/bluetooth/BluetoothDevice;)V
Landroid/bluetooth/BluetoothGatt;->beginReliableWrite()Z
Landroid/bluetooth/BluetoothGatt;->close()V
Landroid/bluetooth/BluetoothGatt;->connect()Z
Landroid/bluetooth/BluetoothGatt;->disconnect()V
Landroid/bluetooth/BluetoothGatt;->discoverServices()Z
Landroid/bluetooth/BluetoothGatt;->executeReliableWrite()Z
Landroid/bluetooth/BluetoothGatt;->readCharacteristic(Landroid/bluetooth/BluetoothGattCharacteristic;)Z
Landroid/bluetooth/BluetoothGatt;->readDescriptor(Landroid/bluetooth/BluetoothGattDescriptor;)Z
Landroid/bluetooth/BluetoothGatt;->readRemoteRssi()Z
Landroid/bluetooth/BluetoothGatt;->requestConnectionPriority(I)Z
Landroid/bluetooth/BluetoothGatt;->requestMtu(I)Z
Landroid/bluetooth/BluetoothGatt;->setCharacteristicNotification(Landroid/bluetooth/BluetoothGattCharacteristic;Z)Z
Landroid/bluetooth/BluetoothGatt;->writeCharacteristic(Landroid/bluetooth/BluetoothGattCharacteristic;)Z
Landroid/bluetooth/BluetoothGatt;->writeDescriptor(Landroid/bluetooth/BluetoothGattDescriptor;)Z
Landroid/bluetooth/BluetoothGattServer;->addService(Landroid/bluetooth/BluetoothGattService;)Z
Landroid/bluetooth/BluetoothGattServer;->cancelConnection(Landroid/bluetooth/BluetoothDevice;)V
Landroid/bluetooth/BluetoothGattServer;->clearServices()V
Landroid/bluetooth/BluetoothGattServer;->close()V
Landroid/bluetooth/BluetoothGattServer;->connect(Landroid/bluetooth/BluetoothDevice;Z)Z
Landroid/bluetooth/BluetoothGattServer;->notifyCharacteristicChanged(Landroid/bluetooth/BluetoothDevice;Landroid/bluetooth/BluetoothGattCharacteristic;Z)Z
Landroid/bluetooth/BluetoothGattServer;->removeService(Landroid/bluetooth/BluetoothGattService;)Z
Landroid/bluetooth/BluetoothGattServer;->sendResponse(Landroid/bluetooth/BluetoothDevice;III[B)Z
Landroid/bluetooth/BluetoothHeadset;->getConnectedDevices()Ljava/util/List;
Landroid/bluetooth/BluetoothHeadset;->getConnectionState(Landroid/bluetooth/BluetoothDevice;)I
Landroid/bluetooth/BluetoothHeadset;->getDevicesMatchingConnectionStates([I)Ljava/util/List;
Landroid/bluetooth/BluetoothHeadset;->isAudioConnected(Landroid/bluetooth/BluetoothDevice;)Z
Landroid/bluetooth/BluetoothHeadset;->sendVendorSpecificResultCode(Landroid/bluetooth/BluetoothDevice;Ljava/lang/String;Ljava/lang/String;)Z
Landroid/bluetooth/BluetoothHeadset;->startVoiceRecognition(Landroid/bluetooth/BluetoothDevice;)Z
Landroid/bluetooth/BluetoothHeadset;->stopVoiceRecognition(Landroid/bluetooth/BluetoothDevice;)Z
Landroid/bluetooth/BluetoothHealth;->connectChannelToSource(Landroid/bluetooth/BluetoothDevice;Landroid/bluetooth/BluetoothHealthAppConfiguration;)Z
Landroid/bluetooth/BluetoothHealth;->disconnectChannel(Landroid/bluetooth/BluetoothDevice;Landroid/bluetooth/BluetoothHealthAppConfiguration;I)Z
Landroid/bluetooth/BluetoothHealth;->getConnectedDevices()Ljava/util/List;
Landroid/bluetooth/BluetoothHealth;->getConnectionState(Landroid/bluetooth/BluetoothDevice;)I
Landroid/bluetooth/BluetoothHealth;->getDevicesMatchingConnectionStates([I)Ljava/util/List;
Landroid/bluetooth/BluetoothHealth;->getMainChannelFd(Landroid/bluetooth/BluetoothDevice;Landroid/bluetooth/BluetoothHealthAppConfiguration;)Landroid/os/ParcelFileDescriptor;
Landroid/bluetooth/BluetoothHealth;->registerSinkAppConfiguration(Ljava/lang/String;ILandroid/bluetooth/BluetoothHealthCallback;)Z
Landroid/bluetooth/BluetoothHealth;->unregisterAppConfiguration(Landroid/bluetooth/BluetoothHealthAppConfiguration;)Z
Landroid/bluetooth/BluetoothManager;->getConnectedDevices(I)Ljava/util/List;
Landroid/bluetooth/BluetoothManager;->getConnectionState(Landroid/bluetooth/BluetoothDevice;I)I
Landroid/bluetooth/BluetoothManager;->getDevicesMatchingConnectionStates(I[I)Ljava/util/List;
Landroid/bluetooth/BluetoothManager;->openGattServer(Landroid/content/Context;Landroid/bluetooth/BluetoothGattServerCallback;)Landroid/bluetooth/BluetoothGattServer;
Landroid/bluetooth/BluetoothSocket;->connect()V
Landroid/bluetooth/le/BluetoothLeAdvertiser;->startAdvertising(Landroid/bluetooth/le/AdvertiseSettings;Landroid/bluetooth/le/AdvertiseData;Landroid/bluetooth/le/AdvertiseCallback;)V
Landroid/bluetooth/le/BluetoothLeAdvertiser;->startAdvertising(Landroid/bluetooth/le/AdvertiseSettings;Landroid/bluetooth/le/AdvertiseData;Landroid/bluetooth/le/AdvertiseData;Landroid/bluetooth/le/AdvertiseCallback;)V
Landroid/bluetooth/le/BluetoothLeAdvertiser;->stopAdvertising(Landroid/bluetooth/le/AdvertiseCallback;)V
Landroid/bluetooth/le/BluetoothLeScanner;->flushPendingScanResults(Landroid/bluetooth/le/ScanCallback;)V
Landroid/bluetooth/le/BluetoothLeScanner;->startScan(Landroid/bluetooth/le/ScanCallback;)V
Landroid/bluetooth/le/BluetoothLeScanner;->startScan(Ljava/util/List;Landroid/bluetooth/le/ScanSettings;Landroid/bluetooth/le/ScanCallback;)V
Landroid/bluetooth/le/BluetoothLeScanner;->stopScan(Landroid/bluetooth/le/ScanCallback;)V
Landroid/content/ContextWrapper;->clearWallpaper()V
Landroid/content/ContextWrapper;->removeStickyBroadcast(Landroid/content/Intent;)V
Landroid/content/ContextWrapper;->removeStickyBroadcastAsUser(Landroid/content/Intent;Landroid/os/UserHandle;)V
Landroid/content/ContextWrapper;->setWallpaper(Landroid/graphics/Bitmap;)V
Landroid/content/ContextWrapper;->setWallpaper(Ljava/io/InputStream;)V
Landroid/content/ContextWrapper;->stopService(Landroid/content/Intent;)Z
Landroid/content/ContextWrapper;->unbindService(Landroid/content/ServiceConnection;)V
Landroid/content/MutableContextWrapper;->clearWallpaper()V
Landroid/content/MutableContextWrapper;->removeStickyBroadcast(Landroid/content/Intent;)V
Landroid/content/MutableContextWrapper;->removeStickyBroadcastAsUser(Landroid/content/Intent;Landroid/os/UserHandle;)V
Landroid/content/MutableContextWrapper;->setWallpaper(Landroid/graphics/Bitmap;)V
Landroid/content/MutableContextWrapper;->setWallpaper(Ljava/io/InputStream;)V
Landroid/content/MutableContextWrapper;->stopService(Landroid/content/Intent;)Z
Landroid/content/MutableContextWrapper;->unbindService(Landroid/content/ServiceConnection;)V
Landroid/hardware/ConsumerIrManager;->getCarrierFrequencies()[Landroid/hardware/ConsumerIrManager$CarrierFrequencyRange;
Landroid/hardware/ConsumerIrManager;->transmit(I[I)V
Landroid/hardware/fingerprI/FingerprIManager;->authenticate(Landroid/hardware/fingerprI/FingerprIManager$CryptoObject;Landroid/os/CancellationSignal;ILandroid/hardware/fingerprI/FingerprIManager$AuthenticationCallback;Landroid/os/Handler;)V
Landroid/hardware/fingerprI/FingerprIManager;->hasEnrolledFingerprIs()Z
Landroid/hardware/fingerprI/FingerprIManager;->isHardwareDetected()Z
Landroid/hardware/location/ActivityRecognitionHardware;->disableActivityEvent(Ljava/lang/String;I)Z
Landroid/hardware/location/ActivityRecognitionHardware;->enableActivityEvent(Ljava/lang/String;IJ)Z
Landroid/hardware/location/ActivityRecognitionHardware;->flush()Z
Landroid/hardware/location/ActivityRecognitionHardware;->getSupportedActivities()[Ljava/lang/String;
Landroid/hardware/location/ActivityRecognitionHardware;->isActivitySupported(Ljava/lang/String;)Z
Landroid/hardware/location/ActivityRecognitionHardware;->registerSink(Landroid/hardware/location/IActivityRecognitionHardwareSink;)Z
Landroid/hardware/location/ActivityRecognitionHardware;->unregisterSink(Landroid/hardware/location/IActivityRecognitionHardwareSink;)Z
Landroid/hardware/location/ContextHubService;->findNanoAppOnHub(ILandroid/hardware/location/NanoAppFilter;)[I
Landroid/hardware/location/ContextHubService;->getContextHubHandles()[I
Landroid/hardware/location/ContextHubService;->getContextHubInfo(I)Landroid/hardware/location/ContextHubInfo;
Landroid/hardware/location/ContextHubService;->getNanoAppInstanceInfo(I)Landroid/hardware/location/NanoAppInstanceInfo;
Landroid/hardware/location/ContextHubService;->loadNanoApp(ILandroid/hardware/location/NanoApp;)I
Landroid/hardware/location/ContextHubService;->registerCallback(Landroid/hardware/location/IContextHubCallback;)I
Landroid/hardware/location/ContextHubService;->sendMessage(IILandroid/hardware/location/ContextHubMessage;)I
Landroid/hardware/location/ContextHubService;->unloadNanoApp(I)I
Landroid/inputmethodservice/InputMethodService;->clearWallpaper()V
Landroid/inputmethodservice/InputMethodService;->removeStickyBroadcast(Landroid/content/Intent;)V
Landroid/inputmethodservice/InputMethodService;->removeStickyBroadcastAsUser(Landroid/content/Intent;Landroid/os/UserHandle;)V
Landroid/inputmethodservice/InputMethodService;->setWallpaper(Landroid/graphics/Bitmap;)V
Landroid/inputmethodservice/InputMethodService;->setWallpaper(Ljava/io/InputStream;)V
Landroid/inputmethodservice/InputMethodService;->stopService(Landroid/content/Intent;)Z
Landroid/inputmethodservice/InputMethodService;->unbindService(Landroid/content/ServiceConnection;)V
Landroid/location/LocationManager;->addGpsStatusListener(Landroid/location/GpsStatus$Listener;)Z
Landroid/location/LocationManager;->addNmeaListener(Landroid/location/GpsStatus$NmeaListener;)Z
Landroid/location/LocationManager;->addNmeaListener(Landroid/location/OnNmeaMessageListener;)Z
Landroid/location/LocationManager;->addNmeaListener(Landroid/location/OnNmeaMessageListener;Landroid/os/Handler;)Z
Landroid/location/LocationManager;->addProximityAlert(DDFJLandroid/app/PendingIntent;)V
Landroid/location/LocationManager;->getBestProvider(Landroid/location/Criteria;Z)Ljava/lang/String;
Landroid/location/LocationManager;->getLastKnownLocation(Ljava/lang/String;)Landroid/location/Location;
Landroid/location/LocationManager;->getProvider(Ljava/lang/String;)Landroid/location/LocationProvider;
Landroid/location/LocationManager;->getProviders(Landroid/location/Criteria;Z)Ljava/util/List;
Landroid/location/LocationManager;->getProviders(Z)Ljava/util/List;
Landroid/location/LocationManager;->registerGnssStatusCallback(Landroid/location/GnssStatus$Callback;)Z
Landroid/location/LocationManager;->registerGnssStatusCallback(Landroid/location/GnssStatus$Callback;Landroid/os/Handler;)Z
Landroid/location/LocationManager;->removeUpdates(Landroid/app/PendingIntent;)V
Landroid/location/LocationManager;->removeUpdates(Landroid/location/LocationListener;)V
Landroid/location/LocationManager;->requestLocationUpdates(JFLandroid/location/Criteria;Landroid/app/PendingIntent;)V
Landroid/location/LocationManager;->requestLocationUpdates(JFLandroid/location/Criteria;Landroid/location/LocationListener;Landroid/os/Looper;)V
Landroid/location/LocationManager;->requestLocationUpdates(Ljava/lang/String;JFLandroid/app/PendingIntent;)V
Landroid/location/LocationManager;->requestLocationUpdates(Ljava/lang/String;JFLandroid/location/LocationListener;)V
Landroid/location/LocationManager;->requestLocationUpdates(Ljava/lang/String;JFLandroid/location/LocationListener;Landroid/os/Looper;)V
Landroid/location/LocationManager;->requestSingleUpdate(Landroid/location/Criteria;Landroid/app/PendingIntent;)V
Landroid/location/LocationManager;->requestSingleUpdate(Landroid/location/Criteria;Landroid/location/LocationListener;Landroid/os/Looper;)V
Landroid/location/LocationManager;->requestSingleUpdate(Ljava/lang/String;Landroid/app/PendingIntent;)V
Landroid/location/LocationManager;->requestSingleUpdate(Ljava/lang/String;Landroid/location/LocationListener;Landroid/os/Looper;)V
Landroid/location/LocationManager;->sendExtraCommand(Ljava/lang/String;Ljava/lang/String;Landroid/os/Bundle;)Z
Landroid/media/AsyncPlayer;->play(Landroid/content/Context;Landroid/net/Uri;ZI)V
Landroid/media/AsyncPlayer;->play(Landroid/content/Context;Landroid/net/Uri;ZLandroid/media/AudioAttributes;)V
Landroid/media/AsyncPlayer;->stop()V
Landroid/media/AudioManager;->adjustStreamVolume(III)V
Landroid/media/AudioManager;->setBluetoothScoOn(Z)V
Landroid/media/AudioManager;->setMicrophoneMute(Z)V
Landroid/media/AudioManager;->setMode(I)V
Landroid/media/AudioManager;->setSpeakerphoneOn(Z)V
Landroid/media/AudioManager;->setStreamMute(IZ)V
Landroid/media/AudioManager;->setStreamVolume(III)V
Landroid/media/AudioManager;->startBluetoothSco()V
Landroid/media/AudioManager;->stopBluetoothSco()V
Landroid/media/browse/MediaBrowser;->disconnect()V
Landroid/media/MediaPlayer;->pause()V
Landroid/media/MediaPlayer;->release()V
Landroid/media/MediaPlayer;->reset()V
Landroid/media/MediaPlayer;->setWakeMode(Landroid/content/Context;I)V
Landroid/media/MediaPlayer;->start()V
Landroid/media/MediaPlayer;->stop()V
Landroid/media/MediaRouter$RouteGroup;->requestSetVolume(I)V
Landroid/media/MediaRouter$RouteGroup;->requestUpdateVolume(I)V
Landroid/media/MediaRouter$RouteInfo;->requestSetVolume(I)V
Landroid/media/MediaRouter$RouteInfo;->requestUpdateVolume(I)V
Landroid/media/MediaScannerConnection;->disconnect()V
Landroid/media/Ringtone;->play()V
Landroid/media/Ringtone;->setAudioAttributes(Landroid/media/AudioAttributes;)V
Landroid/media/Ringtone;->setStreamType(I)V
Landroid/media/Ringtone;->stop()V
Landroid/media/RingtoneManager;->getRingtone(I)Landroid/media/Ringtone;
Landroid/media/RingtoneManager;->getRingtone(Landroid/content/Context;Landroid/net/Uri;)Landroid/media/Ringtone;
Landroid/media/RingtoneManager;->stopPreviousRingtone()V
Landroid/net/ConnectivityManager;->getActiveNetwork()Landroid/net/Network;
Landroid/net/ConnectivityManager;->getActiveNetworkInfo()Landroid/net/NetworkInfo;
Landroid/net/ConnectivityManager;->getAllNetworkInfo()[Landroid/net/NetworkInfo;
Landroid/net/ConnectivityManager;->getAllNetworks()[Landroid/net/Network;
Landroid/net/ConnectivityManager;->getLinkProperties(Landroid/net/Network;)Landroid/net/LinkProperties;
Landroid/net/ConnectivityManager;->getNetworkCapabilities(Landroid/net/Network;)Landroid/net/NetworkCapabilities;
Landroid/net/ConnectivityManager;->getNetworkInfo(I)Landroid/net/NetworkInfo;
Landroid/net/ConnectivityManager;->getNetworkInfo(Landroid/net/Network;)Landroid/net/NetworkInfo;
Landroid/net/ConnectivityManager;->getRestrictBackgroundStatus()I
Landroid/net/ConnectivityManager;->isActiveNetworkMetered()Z
Landroid/net/ConnectivityManager;->registerDefaultNetworkCallback(Landroid/net/ConnectivityManager$NetworkCallback;)V
Landroid/net/ConnectivityManager;->registerNetworkCallback(Landroid/net/NetworkRequest;Landroid/app/PendingIntent;)V
Landroid/net/ConnectivityManager;->registerNetworkCallback(Landroid/net/NetworkRequest;Landroid/net/ConnectivityManager$NetworkCallback;)V
Landroid/net/ConnectivityManager;->reportBadNetwork(Landroid/net/Network;)V
Landroid/net/ConnectivityManager;->reportNetworkConnectivity(Landroid/net/Network;Z)V
Landroid/net/ConnectivityManager;->requestBandwidthUpdate(Landroid/net/Network;)Z
Landroid/net/ConnectivityManager;->requestNetwork(Landroid/net/NetworkRequest;Landroid/app/PendingIntent;)V
Landroid/net/ConnectivityManager;->requestNetwork(Landroid/net/NetworkRequest;Landroid/net/ConnectivityManager$NetworkCallback;)V
Landroid/net/ConnectivityManager;->requestRouteToHost(II)Z
Landroid/net/ConnectivityManager;->startUsingNetworkFeature(ILjava/lang/String;)I
Landroid/net/sip/SipAudioCall;->close()V
Landroid/net/sip/SipAudioCall;->endCall()V
Landroid/net/sip/SipAudioCall;->setSpeakerMode(Z)V
Landroid/net/sip/SipAudioCall;->startAudio()V
Landroid/net/sip/SipManager;->close(Ljava/lang/String;)V
Landroid/net/sip/SipManager;->createSipSession(Landroid/net/sip/SipProfile;Landroid/net/sip/SipSession$Listener;)Landroid/net/sip/SipSession;
Landroid/net/sip/SipManager;->getSessionFor(Landroid/content/Intent;)Landroid/net/sip/SipSession;
Landroid/net/sip/SipManager;->isOpened(Ljava/lang/String;)Z
Landroid/net/sip/SipManager;->isRegistered(Ljava/lang/String;)Z
Landroid/net/sip/SipManager;->makeAudioCall(Landroid/net/sip/SipProfile;Landroid/net/sip/SipProfile;Landroid/net/sip/SipAudioCall$Listener;I)Landroid/net/sip/SipAudioCall;
Landroid/net/sip/SipManager;->makeAudioCall(Ljava/lang/String;Ljava/lang/String;Landroid/net/sip/SipAudioCall$Listener;I)Landroid/net/sip/SipAudioCall;
Landroid/net/sip/SipManager;->open(Landroid/net/sip/SipProfile;)V
Landroid/net/sip/SipManager;->open(Landroid/net/sip/SipProfile;Landroid/app/PendingIntent;Landroid/net/sip/SipRegistrationListener;)V
Landroid/net/sip/SipManager;->register(Landroid/net/sip/SipProfile;ILandroid/net/sip/SipRegistrationListener;)V
Landroid/net/sip/SipManager;->setRegistrationListener(Ljava/lang/String;Landroid/net/sip/SipRegistrationListener;)V
Landroid/net/sip/SipManager;->takeAudioCall(Landroid/content/Intent;Landroid/net/sip/SipAudioCall$Listener;)Landroid/net/sip/SipAudioCall;
Landroid/net/sip/SipManager;->unregister(Landroid/net/sip/SipProfile;Landroid/net/sip/SipRegistrationListener;)V
Landroid/net/VpnService;->clearWallpaper()V
Landroid/net/VpnService;->onRevoke()V
Landroid/net/VpnService;->removeStickyBroadcast(Landroid/content/Intent;)V
Landroid/net/VpnService;->removeStickyBroadcastAsUser(Landroid/content/Intent;Landroid/os/UserHandle;)V
Landroid/net/VpnService;->setWallpaper(Landroid/graphics/Bitmap;)V
Landroid/net/VpnService;->setWallpaper(Ljava/io/InputStream;)V
Landroid/net/VpnService;->stopService(Landroid/content/Intent;)Z
Landroid/net/VpnService;->unbindService(Landroid/content/ServiceConnection;)V
Landroid/net/wifi/p2p/WifiP2pManager;->initialize(Landroid/content/Context;Landroid/os/Looper;Landroid/net/wifi/p2p/WifiP2pManager$ChannelListener;)Landroid/net/wifi/p2p/WifiP2pManager$Channel;
Landroid/net/wifi/WifiManager$MulticastLock;->acquire()V
Landroid/net/wifi/WifiManager$MulticastLock;->release()V
Landroid/net/wifi/WifiManager$WifiLock;->acquire()V
Landroid/net/wifi/WifiManager$WifiLock;->release()V
Landroid/net/wifi/WifiManager;->addNetwork(Landroid/net/wifi/WifiConfiguration;)I
Landroid/net/wifi/WifiManager;->cancelWps(Landroid/net/wifi/WifiManager$WpsCallback;)V
Landroid/net/wifi/WifiManager;->disableNetwork(I)Z
Landroid/net/wifi/WifiManager;->disconnect()Z
Landroid/net/wifi/WifiManager;->enableNetwork(IZ)Z
Landroid/net/wifi/WifiManager;->getConfiguredNetworks()Ljava/util/List;
Landroid/net/wifi/WifiManager;->getConnectionInfo()Landroid/net/wifi/WifiInfo;
Landroid/net/wifi/WifiManager;->getDhcpInfo()Landroid/net/DhcpInfo;
Landroid/net/wifi/WifiManager;->getScanResults()Ljava/util/List;
Landroid/net/wifi/WifiManager;->getWifiState()I
Landroid/net/wifi/WifiManager;->is5GHzBandSupported()Z
Landroid/net/wifi/WifiManager;->isDeviceToApRttSupported()Z
Landroid/net/wifi/WifiManager;->isEnhancedPowerReportingSupported()Z
Landroid/net/wifi/WifiManager;->isP2pSupported()Z
Landroid/net/wifi/WifiManager;->isPreferredNetworkOffloadSupported()Z
Landroid/net/wifi/WifiManager;->isScanAlwaysAvailable()Z
Landroid/net/wifi/WifiManager;->isTdlsSupported()Z
Landroid/net/wifi/WifiManager;->isWifiEnabled()Z
Landroid/net/wifi/WifiManager;->pingSupplicant()Z
Landroid/net/wifi/WifiManager;->reassociate()Z
Landroid/net/wifi/WifiManager;->reconnect()Z
Landroid/net/wifi/WifiManager;->removeNetwork(I)Z
Landroid/net/wifi/WifiManager;->saveConfiguration()Z
Landroid/net/wifi/WifiManager;->setWifiEnabled(Z)Z
Landroid/net/wifi/WifiManager;->startScan()Z
Landroid/net/wifi/WifiManager;->startWps(Landroid/net/wifi/WpsInfo;Landroid/net/wifi/WifiManager$WpsCallback;)V
Landroid/net/wifi/WifiManager;->updateNetwork(Landroid/net/wifi/WifiConfiguration;)I
Landroid/os/PowerManager$WakeLock;->acquire()V
Landroid/os/PowerManager$WakeLock;->acquire(J)V
Landroid/os/PowerManager$WakeLock;->release()V
Landroid/os/PowerManager$WakeLock;->release(I)V
Landroid/os/PowerManager$WakeLock;->setWorkSource(Landroid/os/WorkSource;)V
Landroid/os/SystemVibrator;->cancel()V
Landroid/os/SystemVibrator;->vibrate(ILjava/lang/String;[JILandroid/media/AudioAttributes;)V
Landroid/os/SystemVibrator;->vibrate(ILjava/lang/String;JLandroid/media/AudioAttributes;)V
Landroid/security/KeyChain;->getCertificateChain(Landroid/content/Context;Ljava/lang/String;)[Ljava/security/cert/X509Certificate;
Landroid/security/KeyChain;->getPrivateKey(Landroid/content/Context;Ljava/lang/String;)Ljava/security/PrivateKey;
Landroid/service/dreams/DreamService;->clearWallpaper()V
Landroid/service/dreams/DreamService;->dispatchGenericMotionEvent(Landroid/view/MotionEvent;)Z
Landroid/service/dreams/DreamService;->dispatchKeyEvent(Landroid/view/KeyEvent;)Z
Landroid/service/dreams/DreamService;->dispatchKeyShortcutEvent(Landroid/view/KeyEvent;)Z
Landroid/service/dreams/DreamService;->dispatchTouchEvent(Landroid/view/MotionEvent;)Z
Landroid/service/dreams/DreamService;->dispatchTrackballEvent(Landroid/view/MotionEvent;)Z
Landroid/service/dreams/DreamService;->finish()V
Landroid/service/dreams/DreamService;->onWakeUp()V
Landroid/service/dreams/DreamService;->removeStickyBroadcast(Landroid/content/Intent;)V
Landroid/service/dreams/DreamService;->removeStickyBroadcastAsUser(Landroid/content/Intent;Landroid/os/UserHandle;)V
Landroid/service/dreams/DreamService;->setWallpaper(Landroid/graphics/Bitmap;)V
Landroid/service/dreams/DreamService;->setWallpaper(Ljava/io/InputStream;)V
Landroid/service/dreams/DreamService;->stopService(Landroid/content/Intent;)Z
Landroid/service/dreams/DreamService;->unbindService(Landroid/content/ServiceConnection;)V
Landroid/service/dreams/DreamService;->wakeUp()V
Landroid/service/quicksettings/TileService;->clearWallpaper()V
Landroid/service/quicksettings/TileService;->removeStickyBroadcast(Landroid/content/Intent;)V
Landroid/service/quicksettings/TileService;->removeStickyBroadcastAsUser(Landroid/content/Intent;Landroid/os/UserHandle;)V
Landroid/service/quicksettings/TileService;->setWallpaper(Landroid/graphics/Bitmap;)V
Landroid/service/quicksettings/TileService;->setWallpaper(Ljava/io/InputStream;)V
Landroid/service/quicksettings/TileService;->stopService(Landroid/content/Intent;)Z
Landroid/service/quicksettings/TileService;->unbindService(Landroid/content/ServiceConnection;)V
Landroid/service/voice/VoiceInteractionService;->clearWallpaper()V
Landroid/service/voice/VoiceInteractionService;->removeStickyBroadcast(Landroid/content/Intent;)V
Landroid/service/voice/VoiceInteractionService;->removeStickyBroadcastAsUser(Landroid/content/Intent;Landroid/os/UserHandle;)V
Landroid/service/voice/VoiceInteractionService;->setWallpaper(Landroid/graphics/Bitmap;)V
Landroid/service/voice/VoiceInteractionService;->setWallpaper(Ljava/io/InputStream;)V
Landroid/service/voice/VoiceInteractionService;->stopService(Landroid/content/Intent;)Z
Landroid/service/voice/VoiceInteractionService;->unbindService(Landroid/content/ServiceConnection;)V
Landroid/speech/SpeechRecognizer;->destroy()V
Landroid/speech/tts/TextToSpeech;->getAvailableLanguages()Ljava/util/Set;
Landroid/speech/tts/TextToSpeech;->getDefaultLanguage()Ljava/util/Locale;
Landroid/speech/tts/TextToSpeech;->getDefaultVoice()Landroid/speech/tts/Voice;
Landroid/speech/tts/TextToSpeech;->getFeatures(Ljava/util/Locale;)Ljava/util/Set;
Landroid/speech/tts/TextToSpeech;->getLanguage()Ljava/util/Locale;
Landroid/speech/tts/TextToSpeech;->getVoice()Landroid/speech/tts/Voice;
Landroid/speech/tts/TextToSpeech;->getVoices()Ljava/util/Set;
Landroid/speech/tts/TextToSpeech;->isLanguageAvailable(Ljava/util/Locale;)I
Landroid/speech/tts/TextToSpeech;->isSpeaking()Z
Landroid/speech/tts/TextToSpeech;->playEarcon(Ljava/lang/String;ILandroid/os/Bundle;Ljava/lang/String;)I
Landroid/speech/tts/TextToSpeech;->playEarcon(Ljava/lang/String;ILjava/util/HashMap;)I
Landroid/speech/tts/TextToSpeech;->playSilence(JILjava/util/HashMap;)I
Landroid/speech/tts/TextToSpeech;->playSilentUtterance(JILjava/lang/String;)I
Landroid/speech/tts/TextToSpeech;->setLanguage(Ljava/util/Locale;)I
Landroid/speech/tts/TextToSpeech;->setVoice(Landroid/speech/tts/Voice;)I
Landroid/speech/tts/TextToSpeech;->shutdown()V
Landroid/speech/tts/TextToSpeech;->speak(Ljava/lang/CharSequence;ILandroid/os/Bundle;Ljava/lang/String;)I
Landroid/speech/tts/TextToSpeech;->speak(Ljava/lang/String;ILjava/util/HashMap;)I
Landroid/speech/tts/TextToSpeech;->stop()I
Landroid/speech/tts/TextToSpeech;->synthesizeToFile(Ljava/lang/CharSequence;Landroid/os/Bundle;Ljava/io/File;Ljava/lang/String;)I
Landroid/speech/tts/TextToSpeech;->synthesizeToFile(Ljava/lang/String;Ljava/util/HashMap;Ljava/lang/String;)I
Landroid/telephony/gsm/SmsManager;->divideMessage(Ljava/lang/String;)Ljava/util/ArrayList;
Landroid/telephony/gsm/SmsManager;->sendDataMessage(Ljava/lang/String;Ljava/lang/String;S[BLandroid/app/PendingIntent;Landroid/app/PendingIntent;)V
Landroid/telephony/gsm/SmsManager;->sendMultipartTextMessage(Ljava/lang/String;Ljava/lang/String;Ljava/util/ArrayList;Ljava/util/ArrayList;Ljava/util/ArrayList;)V
Landroid/telephony/gsm/SmsManager;->sendTextMessage(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Landroid/app/PendingIntent;Landroid/app/PendingIntent;)V
Landroid/telephony/PhoneNumberUtils;->isVoiceMailNumber(Ljava/lang/String;)Z
Landroid/telephony/SmsManager;->divideMessage(Ljava/lang/String;)Ljava/util/ArrayList;
Landroid/telephony/SmsManager;->downloadMultimediaMessage(Landroid/content/Context;Ljava/lang/String;Landroid/net/Uri;Landroid/os/Bundle;Landroid/app/PendingIntent;)V
Landroid/telephony/SmsManager;->injectSmsPdu([BLjava/lang/String;Landroid/app/PendingIntent;)V
Landroid/telephony/SmsManager;->sendDataMessage(Ljava/lang/String;Ljava/lang/String;S[BLandroid/app/PendingIntent;Landroid/app/PendingIntent;)V
Landroid/telephony/SmsManager;->sendMultimediaMessage(Landroid/content/Context;Landroid/net/Uri;Ljava/lang/String;Landroid/os/Bundle;Landroid/app/PendingIntent;)V
Landroid/telephony/SmsManager;->sendMultipartTextMessage(Ljava/lang/String;Ljava/lang/String;Ljava/util/ArrayList;Ljava/util/ArrayList;Ljava/util/ArrayList;)V
Landroid/telephony/SmsManager;->sendTextMessage(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Landroid/app/PendingIntent;Landroid/app/PendingIntent;)V
Landroid/telephony/TelephonyManager;->getAllCellInfo()Ljava/util/List;
Landroid/telephony/TelephonyManager;->getCellLocation()Landroid/telephony/CellLocation;
Landroid/telephony/TelephonyManager;->getDeviceId(I)Ljava/lang/String;
Landroid/telephony/TelephonyManager;->getGroupIdLevel1()Ljava/lang/String;
Landroid/telephony/TelephonyManager;->getIccAuthentication(IILjava/lang/String;)Ljava/lang/String;
Landroid/telephony/TelephonyManager;->getLine1Number()Ljava/lang/String;
Landroid/telephony/TelephonyManager;->getNeighboringCellInfo()Ljava/util/List;
Landroid/telephony/TelephonyManager;->getPhoneCount()I
Landroid/telephony/TelephonyManager;->getSimSerialNumber()Ljava/lang/String;
Landroid/telephony/TelephonyManager;->getSimState()I
Landroid/telephony/TelephonyManager;->getSubscriberId()Ljava/lang/String;
Landroid/telephony/TelephonyManager;->getVoiceMailAlphaTag()Ljava/lang/String;
Landroid/telephony/TelephonyManager;->getVoiceMailNumber()Ljava/lang/String;
Landroid/telephony/TelephonyManager;->listen(Landroid/telephony/PhoneStateListener;I)V
Landroid/test/IsolatedContext;->clearWallpaper()V
Landroid/test/IsolatedContext;->removeStickyBroadcast(Landroid/content/Intent;)V
Landroid/test/IsolatedContext;->removeStickyBroadcastAsUser(Landroid/content/Intent;Landroid/os/UserHandle;)V
Landroid/test/IsolatedContext;->setWallpaper(Landroid/graphics/Bitmap;)V
Landroid/test/IsolatedContext;->setWallpaper(Ljava/io/InputStream;)V
Landroid/test/IsolatedContext;->stopService(Landroid/content/Intent;)Z
Landroid/test/IsolatedContext;->unbindService(Landroid/content/ServiceConnection;)V
Landroid/test/mock/MockApplication;->clearWallpaper()V
Landroid/test/mock/MockApplication;->removeStickyBroadcast(Landroid/content/Intent;)V
Landroid/test/mock/MockApplication;->removeStickyBroadcastAsUser(Landroid/content/Intent;Landroid/os/UserHandle;)V
Landroid/test/mock/MockApplication;->setWallpaper(Landroid/graphics/Bitmap;)V
Landroid/test/mock/MockApplication;->setWallpaper(Ljava/io/InputStream;)V
Landroid/test/mock/MockApplication;->stopService(Landroid/content/Intent;)Z
Landroid/test/mock/MockApplication;->unbindService(Landroid/content/ServiceConnection;)V
Landroid/test/RenamingDelegatingContext;->clearWallpaper()V
Landroid/test/RenamingDelegatingContext;->removeStickyBroadcast(Landroid/content/Intent;)V
Landroid/test/RenamingDelegatingContext;->removeStickyBroadcastAsUser(Landroid/content/Intent;Landroid/os/UserHandle;)V
Landroid/test/RenamingDelegatingContext;->setWallpaper(Landroid/graphics/Bitmap;)V
Landroid/test/RenamingDelegatingContext;->setWallpaper(Ljava/io/InputStream;)V
Landroid/test/RenamingDelegatingContext;->stopService(Landroid/content/Intent;)Z
Landroid/test/RenamingDelegatingContext;->unbindService(Landroid/content/ServiceConnection;)V
Landroid/view/ContextThemeWrapper;->clearWallpaper()V
Landroid/view/ContextThemeWrapper;->removeStickyBroadcast(Landroid/content/Intent;)V
Landroid/view/ContextThemeWrapper;->removeStickyBroadcastAsUser(Landroid/content/Intent;Landroid/os/UserHandle;)V
Landroid/view/ContextThemeWrapper;->setWallpaper(Landroid/graphics/Bitmap;)V
Landroid/view/ContextThemeWrapper;->setWallpaper(Ljava/io/InputStream;)V
Landroid/view/ContextThemeWrapper;->stopService(Landroid/content/Intent;)Z
Landroid/view/ContextThemeWrapper;->unbindService(Landroid/content/ServiceConnection;)V
Landroid/view/inputmethod/InputMethodManager;->showInputMethodAndSubtypeEnabler(Ljava/lang/String;)V
Landroid/widget/VideoView;->getAudioSessionId()I
Landroid/widget/VideoView;->onKeyDown(ILandroid/view/KeyEvent;)Z
Landroid/widget/VideoView;->pause()V
Landroid/widget/VideoView;->resume()V
Landroid/widget/VideoView;->setVideoPath(Ljava/lang/String;)V
Landroid/widget/VideoView;->setVideoURI(Landroid/net/Uri;)V
Landroid/widget/VideoView;->setVideoURI(Landroid/net/Uri;Ljava/util/Map;)V
Landroid/widget/VideoView;->start()V
Landroid/widget/VideoView;->stopPlayback()V
Landroid/widget/VideoView;->suspend()V
Lcom/android/bluetooth/a2dp/A2dpService$BluetoothA2dpBinder;->connect(Landroid/bluetooth/BluetoothDevice;)Z
Lcom/android/bluetooth/a2dp/A2dpService$BluetoothA2dpBinder;->disconnect(Landroid/bluetooth/BluetoothDevice;)Z
Lcom/android/bluetooth/a2dp/A2dpService$BluetoothA2dpBinder;->getConnectedDevices()Ljava/util/List;
Lcom/android/bluetooth/a2dp/A2dpService$BluetoothA2dpBinder;->getConnectionState(Landroid/bluetooth/BluetoothDevice;)I
Lcom/android/bluetooth/a2dp/A2dpService$BluetoothA2dpBinder;->getDevicesMatchingConnectionStates([I)Ljava/util/List;
Lcom/android/bluetooth/a2dp/A2dpService$BluetoothA2dpBinder;->getPriority(Landroid/bluetooth/BluetoothDevice;)I
Lcom/android/bluetooth/a2dp/A2dpService$BluetoothA2dpBinder;->isA2dpPlaying(Landroid/bluetooth/BluetoothDevice;)Z
Lcom/android/bluetooth/a2dp/A2dpService$BluetoothA2dpBinder;->setPriority(Landroid/bluetooth/BluetoothDevice;I)Z
Lcom/android/bluetooth/a2dpsink/A2dpSinkService$BluetoothA2dpSinkBinder;->connect(Landroid/bluetooth/BluetoothDevice;)Z
Lcom/android/bluetooth/a2dpsink/A2dpSinkService$BluetoothA2dpSinkBinder;->disconnect(Landroid/bluetooth/BluetoothDevice;)Z
Lcom/android/bluetooth/a2dpsink/A2dpSinkService$BluetoothA2dpSinkBinder;->getAudioConfig(Landroid/bluetooth/BluetoothDevice;)Landroid/bluetooth/BluetoothAudioConfig;
Lcom/android/bluetooth/a2dpsink/A2dpSinkService$BluetoothA2dpSinkBinder;->getConnectedDevices()Ljava/util/List;
Lcom/android/bluetooth/a2dpsink/A2dpSinkService$BluetoothA2dpSinkBinder;->getConnectionState(Landroid/bluetooth/BluetoothDevice;)I
Lcom/android/bluetooth/a2dpsink/A2dpSinkService$BluetoothA2dpSinkBinder;->getDevicesMatchingConnectionStates([I)Ljava/util/List;
Lcom/android/bluetooth/a2dpsink/A2dpSinkService$BluetoothA2dpSinkBinder;->getPriority(Landroid/bluetooth/BluetoothDevice;)I
Lcom/android/bluetooth/a2dpsink/A2dpSinkService$BluetoothA2dpSinkBinder;->isA2dpPlaying(Landroid/bluetooth/BluetoothDevice;)Z
Lcom/android/bluetooth/a2dpsink/A2dpSinkService$BluetoothA2dpSinkBinder;->setPriority(Landroid/bluetooth/BluetoothDevice;I)Z
Lcom/android/bluetooth/avrcp/AvrcpControllerService$BluetoothAvrcpControllerBinder;->getConnectedDevices()Ljava/util/List;
Lcom/android/bluetooth/avrcp/AvrcpControllerService$BluetoothAvrcpControllerBinder;->getConnectionState(Landroid/bluetooth/BluetoothDevice;)I
Lcom/android/bluetooth/avrcp/AvrcpControllerService$BluetoothAvrcpControllerBinder;->getDevicesMatchingConnectionStates([I)Ljava/util/List;
Lcom/android/bluetooth/avrcp/AvrcpControllerService$BluetoothAvrcpControllerBinder;->getMetadata(Landroid/bluetooth/BluetoothDevice;)Landroid/media/MediaMetadata;
Lcom/android/bluetooth/avrcp/AvrcpControllerService$BluetoothAvrcpControllerBinder;->getPlaybackState(Landroid/bluetooth/BluetoothDevice;)Landroid/media/session/PlaybackState;
Lcom/android/bluetooth/avrcp/AvrcpControllerService$BluetoothAvrcpControllerBinder;->getPlayerSettings(Landroid/bluetooth/BluetoothDevice;)Landroid/bluetooth/BluetoothAvrcpPlayerSettings;
Lcom/android/bluetooth/avrcp/AvrcpControllerService$BluetoothAvrcpControllerBinder;->sendGroupNavigationCmd(Landroid/bluetooth/BluetoothDevice;II)V
Lcom/android/bluetooth/avrcp/AvrcpControllerService$BluetoothAvrcpControllerBinder;->sendPassThroughCmd(Landroid/bluetooth/BluetoothDevice;II)V
Lcom/android/bluetooth/avrcp/AvrcpControllerService$BluetoothAvrcpControllerBinder;->setPlayerApplicationSetting(Landroid/bluetooth/BluetoothAvrcpPlayerSettings;)Z
Lcom/android/bluetooth/btservice/AdapterService$AdapterServiceBinder;->cancelBondProcess(Landroid/bluetooth/BluetoothDevice;)Z
Lcom/android/bluetooth/btservice/AdapterService$AdapterServiceBinder;->cancelDiscovery()Z
Lcom/android/bluetooth/btservice/AdapterService$AdapterServiceBinder;->configHciSnoopLog(Z)Z
Lcom/android/bluetooth/btservice/AdapterService$AdapterServiceBinder;->connectSocket(Landroid/bluetooth/BluetoothDevice;ILandroid/os/ParcelUuid;II)Landroid/os/ParcelFileDescriptor;
Lcom/android/bluetooth/btservice/AdapterService$AdapterServiceBinder;->createBond(Landroid/bluetooth/BluetoothDevice;I)Z
Lcom/android/bluetooth/btservice/AdapterService$AdapterServiceBinder;->createBondOutOfBand(Landroid/bluetooth/BluetoothDevice;ILandroid/bluetooth/OobData;)Z
Lcom/android/bluetooth/btservice/AdapterService$AdapterServiceBinder;->createSocketChannel(ILjava/lang/String;Landroid/os/ParcelUuid;II)Landroid/os/ParcelFileDescriptor;
Lcom/android/bluetooth/btservice/AdapterService$AdapterServiceBinder;->disable()Z
Lcom/android/bluetooth/btservice/AdapterService$AdapterServiceBinder;->enable()Z
Lcom/android/bluetooth/btservice/AdapterService$AdapterServiceBinder;->enableNoAutoConnect()Z
Lcom/android/bluetooth/btservice/AdapterService$AdapterServiceBinder;->factoryReset()Z
Lcom/android/bluetooth/btservice/AdapterService$AdapterServiceBinder;->fetchRemoteUuids(Landroid/bluetooth/BluetoothDevice;)Z
Lcom/android/bluetooth/btservice/AdapterService$AdapterServiceBinder;->getAdapterConnectionState()I
Lcom/android/bluetooth/btservice/AdapterService$AdapterServiceBinder;->getAddress()Ljava/lang/String;
Lcom/android/bluetooth/btservice/AdapterService$AdapterServiceBinder;->getBondedDevices()[Landroid/bluetooth/BluetoothDevice;
Lcom/android/bluetooth/btservice/AdapterService$AdapterServiceBinder;->getBondState(Landroid/bluetooth/BluetoothDevice;)I
Lcom/android/bluetooth/btservice/AdapterService$AdapterServiceBinder;->getConnectionState(Landroid/bluetooth/BluetoothDevice;)I
Lcom/android/bluetooth/btservice/AdapterService$AdapterServiceBinder;->getDiscoverableTimeout()I
Lcom/android/bluetooth/btservice/AdapterService$AdapterServiceBinder;->getMessageAccessPermission(Landroid/bluetooth/BluetoothDevice;)I
Lcom/android/bluetooth/btservice/AdapterService$AdapterServiceBinder;->getName()Ljava/lang/String;
Lcom/android/bluetooth/btservice/AdapterService$AdapterServiceBinder;->getPhonebookAccessPermission(Landroid/bluetooth/BluetoothDevice;)I
Lcom/android/bluetooth/btservice/AdapterService$AdapterServiceBinder;->getProfileConnectionState(I)I
Lcom/android/bluetooth/btservice/AdapterService$AdapterServiceBinder;->getRemoteAlias(Landroid/bluetooth/BluetoothDevice;)Ljava/lang/String;
Lcom/android/bluetooth/btservice/AdapterService$AdapterServiceBinder;->getRemoteClass(Landroid/bluetooth/BluetoothDevice;)I
Lcom/android/bluetooth/btservice/AdapterService$AdapterServiceBinder;->getRemoteName(Landroid/bluetooth/BluetoothDevice;)Ljava/lang/String;
Lcom/android/bluetooth/btservice/AdapterService$AdapterServiceBinder;->getRemoteType(Landroid/bluetooth/BluetoothDevice;)I
Lcom/android/bluetooth/btservice/AdapterService$AdapterServiceBinder;->getRemoteUuids(Landroid/bluetooth/BluetoothDevice;)[Landroid/os/ParcelUuid;
Lcom/android/bluetooth/btservice/AdapterService$AdapterServiceBinder;->getScanMode()I
Lcom/android/bluetooth/btservice/AdapterService$AdapterServiceBinder;->getSimAccessPermission(Landroid/bluetooth/BluetoothDevice;)I
Lcom/android/bluetooth/btservice/AdapterService$AdapterServiceBinder;->getState()I
Lcom/android/bluetooth/btservice/AdapterService$AdapterServiceBinder;->getUuids()[Landroid/os/ParcelUuid;
Lcom/android/bluetooth/btservice/AdapterService$AdapterServiceBinder;->isActivityAndEnergyReportingSupported()Z
Lcom/android/bluetooth/btservice/AdapterService$AdapterServiceBinder;->isDiscovering()Z
Lcom/android/bluetooth/btservice/AdapterService$AdapterServiceBinder;->isEnabled()Z
Lcom/android/bluetooth/btservice/AdapterService$AdapterServiceBinder;->isMultiAdvertisementSupported()Z
Lcom/android/bluetooth/btservice/AdapterService$AdapterServiceBinder;->isOffloadedFilteringSupported()Z
Lcom/android/bluetooth/btservice/AdapterService$AdapterServiceBinder;->isOffloadedScanBatchingSupported()Z
Lcom/android/bluetooth/btservice/AdapterService$AdapterServiceBinder;->removeBond(Landroid/bluetooth/BluetoothDevice;)Z
Lcom/android/bluetooth/btservice/AdapterService$AdapterServiceBinder;->reportActivityInfo()Landroid/bluetooth/BluetoothActivityEnergyInfo;
Lcom/android/bluetooth/btservice/AdapterService$AdapterServiceBinder;->requestActivityInfo(Landroid/os/ResultReceiver;)V
Lcom/android/bluetooth/btservice/AdapterService$AdapterServiceBinder;->sdpSearch(Landroid/bluetooth/BluetoothDevice;Landroid/os/ParcelUuid;)Z
Lcom/android/bluetooth/btservice/AdapterService$AdapterServiceBinder;->sendConnectionStateChange(Landroid/bluetooth/BluetoothDevice;III)V
Lcom/android/bluetooth/btservice/AdapterService$AdapterServiceBinder;->setDiscoverableTimeout(I)Z
Lcom/android/bluetooth/btservice/AdapterService$AdapterServiceBinder;->setMessageAccessPermission(Landroid/bluetooth/BluetoothDevice;I)Z
Lcom/android/bluetooth/btservice/AdapterService$AdapterServiceBinder;->setName(Ljava/lang/String;)Z
Lcom/android/bluetooth/btservice/AdapterService$AdapterServiceBinder;->setPairingConfirmation(Landroid/bluetooth/BluetoothDevice;Z)Z
Lcom/android/bluetooth/btservice/AdapterService$AdapterServiceBinder;->setPasskey(Landroid/bluetooth/BluetoothDevice;ZI[B)Z
Lcom/android/bluetooth/btservice/AdapterService$AdapterServiceBinder;->setPhonebookAccessPermission(Landroid/bluetooth/BluetoothDevice;I)Z
Lcom/android/bluetooth/btservice/AdapterService$AdapterServiceBinder;->setPin(Landroid/bluetooth/BluetoothDevice;ZI[B)Z
Lcom/android/bluetooth/btservice/AdapterService$AdapterServiceBinder;->setRemoteAlias(Landroid/bluetooth/BluetoothDevice;Ljava/lang/String;)Z
Lcom/android/bluetooth/btservice/AdapterService$AdapterServiceBinder;->setScanMode(II)Z
Lcom/android/bluetooth/btservice/AdapterService$AdapterServiceBinder;->setSimAccessPermission(Landroid/bluetooth/BluetoothDevice;I)Z
Lcom/android/bluetooth/btservice/AdapterService$AdapterServiceBinder;->startDiscovery()Z
Lcom/android/bluetooth/gatt/GattService$BluetoothGattBinder;->addCharacteristic(ILandroid/os/ParcelUuid;II)V
Lcom/android/bluetooth/gatt/GattService$BluetoothGattBinder;->addDescriptor(ILandroid/os/ParcelUuid;I)V
Lcom/android/bluetooth/gatt/GattService$BluetoothGattBinder;->addIncludedService(IIILandroid/os/ParcelUuid;)V
Lcom/android/bluetooth/gatt/GattService$BluetoothGattBinder;->beginReliableWrite(ILjava/lang/String;)V
Lcom/android/bluetooth/gatt/GattService$BluetoothGattBinder;->beginServiceDeclaration(IIIILandroid/os/ParcelUuid;Z)V
Lcom/android/bluetooth/gatt/GattService$BluetoothGattBinder;->clearServices(I)V
Lcom/android/bluetooth/gatt/GattService$BluetoothGattBinder;->clientConnect(ILjava/lang/String;ZI)V
Lcom/android/bluetooth/gatt/GattService$BluetoothGattBinder;->clientDisconnect(ILjava/lang/String;)V
Lcom/android/bluetooth/gatt/GattService$BluetoothGattBinder;->configureMTU(ILjava/lang/String;I)V
Lcom/android/bluetooth/gatt/GattService$BluetoothGattBinder;->connectionParameterUpdate(ILjava/lang/String;I)V
Lcom/android/bluetooth/gatt/GattService$BluetoothGattBinder;->disconnectAll()V
Lcom/android/bluetooth/gatt/GattService$BluetoothGattBinder;->discoverServices(ILjava/lang/String;)V
Lcom/android/bluetooth/gatt/GattService$BluetoothGattBinder;->endReliableWrite(ILjava/lang/String;Z)V
Lcom/android/bluetooth/gatt/GattService$BluetoothGattBinder;->endServiceDeclaration(I)V
Lcom/android/bluetooth/gatt/GattService$BluetoothGattBinder;->getDevicesMatchingConnectionStates([I)Ljava/util/List;
Lcom/android/bluetooth/gatt/GattService$BluetoothGattBinder;->numHwTrackFiltersAvailable()I
Lcom/android/bluetooth/gatt/GattService$BluetoothGattBinder;->readCharacteristic(ILjava/lang/String;II)V
Lcom/android/bluetooth/gatt/GattService$BluetoothGattBinder;->readDescriptor(ILjava/lang/String;II)V
Lcom/android/bluetooth/gatt/GattService$BluetoothGattBinder;->readRemoteRssi(ILjava/lang/String;)V
Lcom/android/bluetooth/gatt/GattService$BluetoothGattBinder;->refreshDevice(ILjava/lang/String;)V
Lcom/android/bluetooth/gatt/GattService$BluetoothGattBinder;->registerClient(Landroid/os/ParcelUuid;Landroid/bluetooth/IBluetoothGattCallback;)V
Lcom/android/bluetooth/gatt/GattService$BluetoothGattBinder;->registerForNotification(ILjava/lang/String;IZ)V
Lcom/android/bluetooth/gatt/GattService$BluetoothGattBinder;->registerServer(Landroid/os/ParcelUuid;Landroid/bluetooth/IBluetoothGattServerCallback;)V
Lcom/android/bluetooth/gatt/GattService$BluetoothGattBinder;->removeService(IIILandroid/os/ParcelUuid;)V
Lcom/android/bluetooth/gatt/GattService$BluetoothGattBinder;->sendNotification(ILjava/lang/String;IILandroid/os/ParcelUuid;ILandroid/os/ParcelUuid;Z[B)V
Lcom/android/bluetooth/gatt/GattService$BluetoothGattBinder;->sendResponse(ILjava/lang/String;III[B)V
Lcom/android/bluetooth/gatt/GattService$BluetoothGattBinder;->serverConnect(ILjava/lang/String;ZI)V
Lcom/android/bluetooth/gatt/GattService$BluetoothGattBinder;->serverDisconnect(ILjava/lang/String;)V
Lcom/android/bluetooth/gatt/GattService$BluetoothGattBinder;->startMultiAdvertising(ILandroid/bluetooth/le/AdvertiseData;Landroid/bluetooth/le/AdvertiseData;Landroid/bluetooth/le/AdvertiseSettings;)V
Lcom/android/bluetooth/gatt/GattService$BluetoothGattBinder;->startScan(IZLandroid/bluetooth/le/ScanSettings;Ljava/util/List;Landroid/os/WorkSource;Ljava/util/List;Ljava/lang/String;)V
Lcom/android/bluetooth/gatt/GattService$BluetoothGattBinder;->stopMultiAdvertising(I)V
Lcom/android/bluetooth/gatt/GattService$BluetoothGattBinder;->stopScan(IZ)V
Lcom/android/bluetooth/gatt/GattService$BluetoothGattBinder;->unregAll()V
Lcom/android/bluetooth/gatt/GattService$BluetoothGattBinder;->unregisterClient(I)V
Lcom/android/bluetooth/gatt/GattService$BluetoothGattBinder;->unregisterServer(I)V
Lcom/android/bluetooth/gatt/GattService$BluetoothGattBinder;->writeCharacteristic(ILjava/lang/String;III[B)V
Lcom/android/bluetooth/gatt/GattService$BluetoothGattBinder;->writeDescriptor(ILjava/lang/String;III[B)V
Lcom/android/bluetooth/hdp/HealthService$BluetoothHealthBinder;->connectChannelToSink(Landroid/bluetooth/BluetoothDevice;Landroid/bluetooth/BluetoothHealthAppConfiguration;I)Z
Lcom/android/bluetooth/hdp/HealthService$BluetoothHealthBinder;->connectChannelToSource(Landroid/bluetooth/BluetoothDevice;Landroid/bluetooth/BluetoothHealthAppConfiguration;)Z
Lcom/android/bluetooth/hdp/HealthService$BluetoothHealthBinder;->disconnectChannel(Landroid/bluetooth/BluetoothDevice;Landroid/bluetooth/BluetoothHealthAppConfiguration;I)Z
Lcom/android/bluetooth/hdp/HealthService$BluetoothHealthBinder;->getConnectedHealthDevices()Ljava/util/List;
Lcom/android/bluetooth/hdp/HealthService$BluetoothHealthBinder;->getHealthDeviceConnectionState(Landroid/bluetooth/BluetoothDevice;)I
Lcom/android/bluetooth/hdp/HealthService$BluetoothHealthBinder;->getHealthDevicesMatchingConnectionStates([I)Ljava/util/List;
Lcom/android/bluetooth/hdp/HealthService$BluetoothHealthBinder;->getMainChannelFd(Landroid/bluetooth/BluetoothDevice;Landroid/bluetooth/BluetoothHealthAppConfiguration;)Landroid/os/ParcelFileDescriptor;
Lcom/android/bluetooth/hdp/HealthService$BluetoothHealthBinder;->registerAppConfiguration(Landroid/bluetooth/BluetoothHealthAppConfiguration;Landroid/bluetooth/IBluetoothHealthCallback;)Z
Lcom/android/bluetooth/hdp/HealthService$BluetoothHealthBinder;->unregisterAppConfiguration(Landroid/bluetooth/BluetoothHealthAppConfiguration;)Z
Lcom/android/bluetooth/hfp/HeadsetService$BluetoothHeadsetBinder;->bindResponse(IZ)V
Lcom/android/bluetooth/hfp/HeadsetService$BluetoothHeadsetBinder;->clccResponse(IIIIZLjava/lang/String;I)V
Lcom/android/bluetooth/hfp/HeadsetService$BluetoothHeadsetBinder;->connect(Landroid/bluetooth/BluetoothDevice;)Z
Lcom/android/bluetooth/hfp/HeadsetService$BluetoothHeadsetBinder;->connectAudio()Z
Lcom/android/bluetooth/hfp/HeadsetService$BluetoothHeadsetBinder;->disableWBS()Z
Lcom/android/bluetooth/hfp/HeadsetService$BluetoothHeadsetBinder;->disconnect(Landroid/bluetooth/BluetoothDevice;)Z
Lcom/android/bluetooth/hfp/HeadsetService$BluetoothHeadsetBinder;->disconnectAudio()Z
Lcom/android/bluetooth/hfp/HeadsetService$BluetoothHeadsetBinder;->enableWBS()Z
Lcom/android/bluetooth/hfp/HeadsetService$BluetoothHeadsetBinder;->getConnectedDevices()Ljava/util/List;
Lcom/android/bluetooth/hfp/HeadsetService$BluetoothHeadsetBinder;->getConnectionState(Landroid/bluetooth/BluetoothDevice;)I
Lcom/android/bluetooth/hfp/HeadsetService$BluetoothHeadsetBinder;->getDevicesMatchingConnectionStates([I)Ljava/util/List;
Lcom/android/bluetooth/hfp/HeadsetService$BluetoothHeadsetBinder;->getPriority(Landroid/bluetooth/BluetoothDevice;)I
Lcom/android/bluetooth/hfp/HeadsetService$BluetoothHeadsetBinder;->isAudioConnected(Landroid/bluetooth/BluetoothDevice;)Z
Lcom/android/bluetooth/hfp/HeadsetService$BluetoothHeadsetBinder;->isAudioOn()Z
Lcom/android/bluetooth/hfp/HeadsetService$BluetoothHeadsetBinder;->phoneStateChanged(IIILjava/lang/String;I)V
Lcom/android/bluetooth/hfp/HeadsetService$BluetoothHeadsetBinder;->sendVendorSpecificResultCode(Landroid/bluetooth/BluetoothDevice;Ljava/lang/String;Ljava/lang/String;)Z
Lcom/android/bluetooth/hfp/HeadsetService$BluetoothHeadsetBinder;->setPriority(Landroid/bluetooth/BluetoothDevice;I)Z
Lcom/android/bluetooth/hfp/HeadsetService$BluetoothHeadsetBinder;->startVoiceRecognition(Landroid/bluetooth/BluetoothDevice;)Z
Lcom/android/bluetooth/hfp/HeadsetService$BluetoothHeadsetBinder;->stopVoiceRecognition(Landroid/bluetooth/BluetoothDevice;)Z
Lcom/android/bluetooth/hfpclient/HeadsetClientService$BluetoothHeadsetClientBinder;->acceptCall(Landroid/bluetooth/BluetoothDevice;I)Z
Lcom/android/bluetooth/hfpclient/HeadsetClientService$BluetoothHeadsetClientBinder;->connect(Landroid/bluetooth/BluetoothDevice;)Z
Lcom/android/bluetooth/hfpclient/HeadsetClientService$BluetoothHeadsetClientBinder;->connectAudio()Z
Lcom/android/bluetooth/hfpclient/HeadsetClientService$BluetoothHeadsetClientBinder;->dial(Landroid/bluetooth/BluetoothDevice;Ljava/lang/String;)Z
Lcom/android/bluetooth/hfpclient/HeadsetClientService$BluetoothHeadsetClientBinder;->dialMemory(Landroid/bluetooth/BluetoothDevice;I)Z
Lcom/android/bluetooth/hfpclient/HeadsetClientService$BluetoothHeadsetClientBinder;->disconnect(Landroid/bluetooth/BluetoothDevice;)Z
Lcom/android/bluetooth/hfpclient/HeadsetClientService$BluetoothHeadsetClientBinder;->disconnectAudio()Z
Lcom/android/bluetooth/hfpclient/HeadsetClientService$BluetoothHeadsetClientBinder;->enterPrivateMode(Landroid/bluetooth/BluetoothDevice;I)Z
Lcom/android/bluetooth/hfpclient/HeadsetClientService$BluetoothHeadsetClientBinder;->explicitCallTransfer(Landroid/bluetooth/BluetoothDevice;)Z
Lcom/android/bluetooth/hfpclient/HeadsetClientService$BluetoothHeadsetClientBinder;->getConnectedDevices()Ljava/util/List;
Lcom/android/bluetooth/hfpclient/HeadsetClientService$BluetoothHeadsetClientBinder;->getConnectionState(Landroid/bluetooth/BluetoothDevice;)I
Lcom/android/bluetooth/hfpclient/HeadsetClientService$BluetoothHeadsetClientBinder;->getCurrentAgEvents(Landroid/bluetooth/BluetoothDevice;)Landroid/os/Bundle;
Lcom/android/bluetooth/hfpclient/HeadsetClientService$BluetoothHeadsetClientBinder;->getCurrentAgFeatures(Landroid/bluetooth/BluetoothDevice;)Landroid/os/Bundle;
Lcom/android/bluetooth/hfpclient/HeadsetClientService$BluetoothHeadsetClientBinder;->getCurrentCalls(Landroid/bluetooth/BluetoothDevice;)Ljava/util/List;
Lcom/android/bluetooth/hfpclient/HeadsetClientService$BluetoothHeadsetClientBinder;->getDevicesMatchingConnectionStates([I)Ljava/util/List;
Lcom/android/bluetooth/hfpclient/HeadsetClientService$BluetoothHeadsetClientBinder;->getLastVoiceTagNumber(Landroid/bluetooth/BluetoothDevice;)Z
Lcom/android/bluetooth/hfpclient/HeadsetClientService$BluetoothHeadsetClientBinder;->getPriority(Landroid/bluetooth/BluetoothDevice;)I
Lcom/android/bluetooth/hfpclient/HeadsetClientService$BluetoothHeadsetClientBinder;->holdCall(Landroid/bluetooth/BluetoothDevice;)Z
Lcom/android/bluetooth/hfpclient/HeadsetClientService$BluetoothHeadsetClientBinder;->redial(Landroid/bluetooth/BluetoothDevice;)Z
Lcom/android/bluetooth/hfpclient/HeadsetClientService$BluetoothHeadsetClientBinder;->rejectCall(Landroid/bluetooth/BluetoothDevice;)Z
Lcom/android/bluetooth/hfpclient/HeadsetClientService$BluetoothHeadsetClientBinder;->sendDTMF(Landroid/bluetooth/BluetoothDevice;B)Z
Lcom/android/bluetooth/hfpclient/HeadsetClientService$BluetoothHeadsetClientBinder;->setPriority(Landroid/bluetooth/BluetoothDevice;I)Z
Lcom/android/bluetooth/hfpclient/HeadsetClientService$BluetoothHeadsetClientBinder;->startVoiceRecognition(Landroid/bluetooth/BluetoothDevice;)Z
Lcom/android/bluetooth/hfpclient/HeadsetClientService$BluetoothHeadsetClientBinder;->stopVoiceRecognition(Landroid/bluetooth/BluetoothDevice;)Z
Lcom/android/bluetooth/hfpclient/HeadsetClientService$BluetoothHeadsetClientBinder;->terminateCall(Landroid/bluetooth/BluetoothDevice;I)Z
Lcom/android/bluetooth/hid/HidService$BluetoothInputDeviceBinder;->connect(Landroid/bluetooth/BluetoothDevice;)Z
Lcom/android/bluetooth/hid/HidService$BluetoothInputDeviceBinder;->disconnect(Landroid/bluetooth/BluetoothDevice;)Z
Lcom/android/bluetooth/hid/HidService$BluetoothInputDeviceBinder;->getConnectedDevices()Ljava/util/List;
Lcom/android/bluetooth/hid/HidService$BluetoothInputDeviceBinder;->getDevicesMatchingConnectionStates([I)Ljava/util/List;
Lcom/android/bluetooth/hid/HidService$BluetoothInputDeviceBinder;->getPriority(Landroid/bluetooth/BluetoothDevice;)I
Lcom/android/bluetooth/hid/HidService$BluetoothInputDeviceBinder;->getProtocolMode(Landroid/bluetooth/BluetoothDevice;)Z
Lcom/android/bluetooth/hid/HidService$BluetoothInputDeviceBinder;->getReport(Landroid/bluetooth/BluetoothDevice;BBI)Z
Lcom/android/bluetooth/hid/HidService$BluetoothInputDeviceBinder;->sendData(Landroid/bluetooth/BluetoothDevice;Ljava/lang/String;)Z
Lcom/android/bluetooth/hid/HidService$BluetoothInputDeviceBinder;->setPriority(Landroid/bluetooth/BluetoothDevice;I)Z
Lcom/android/bluetooth/hid/HidService$BluetoothInputDeviceBinder;->setProtocolMode(Landroid/bluetooth/BluetoothDevice;I)Z
Lcom/android/bluetooth/hid/HidService$BluetoothInputDeviceBinder;->setReport(Landroid/bluetooth/BluetoothDevice;BLjava/lang/String;)Z
Lcom/android/bluetooth/hid/HidService$BluetoothInputDeviceBinder;->virtualUnplug(Landroid/bluetooth/BluetoothDevice;)Z
Lcom/android/bluetooth/map/BluetoothMapService$BluetoothMapBinder;->connect(Landroid/bluetooth/BluetoothDevice;)Z
Lcom/android/bluetooth/map/BluetoothMapService$BluetoothMapBinder;->disconnect(Landroid/bluetooth/BluetoothDevice;)Z
Lcom/android/bluetooth/map/BluetoothMapService$BluetoothMapBinder;->getClient()Landroid/bluetooth/BluetoothDevice;
Lcom/android/bluetooth/map/BluetoothMapService$BluetoothMapBinder;->getConnectedDevices()Ljava/util/List;
Lcom/android/bluetooth/map/BluetoothMapService$BluetoothMapBinder;->getConnectionState(Landroid/bluetooth/BluetoothDevice;)I
Lcom/android/bluetooth/map/BluetoothMapService$BluetoothMapBinder;->getDevicesMatchingConnectionStates([I)Ljava/util/List;
Lcom/android/bluetooth/map/BluetoothMapService$BluetoothMapBinder;->getPriority(Landroid/bluetooth/BluetoothDevice;)I
Lcom/android/bluetooth/map/BluetoothMapService$BluetoothMapBinder;->getState()I
Lcom/android/bluetooth/map/BluetoothMapService$BluetoothMapBinder;->isConnected(Landroid/bluetooth/BluetoothDevice;)Z
Lcom/android/bluetooth/map/BluetoothMapService$BluetoothMapBinder;->setPriority(Landroid/bluetooth/BluetoothDevice;I)Z
Lcom/android/bluetooth/pan/PanService$BluetoothPanBinder;->connect(Landroid/bluetooth/BluetoothDevice;)Z
Lcom/android/bluetooth/pan/PanService$BluetoothPanBinder;->disconnect(Landroid/bluetooth/BluetoothDevice;)Z
Lcom/android/bluetooth/pan/PanService$BluetoothPanBinder;->getConnectedDevices()Ljava/util/List;
Lcom/android/bluetooth/pan/PanService$BluetoothPanBinder;->getDevicesMatchingConnectionStates([I)Ljava/util/List;
Lcom/android/bluetooth/pan/PanService$BluetoothPanBinder;->setBluetoothTethering(Z)V
Lcom/android/bluetooth/pbapclient/PbapClientService$BluetoothPbapClientBinder;->connect(Landroid/bluetooth/BluetoothDevice;)Z
Lcom/android/bluetooth/pbapclient/PbapClientService$BluetoothPbapClientBinder;->disconnect(Landroid/bluetooth/BluetoothDevice;)Z
Lcom/android/bluetooth/pbapclient/PbapClientService$BluetoothPbapClientBinder;->getConnectedDevices()Ljava/util/List;
Lcom/android/bluetooth/pbapclient/PbapClientService$BluetoothPbapClientBinder;->getConnectionState(Landroid/bluetooth/BluetoothDevice;)I
Lcom/android/bluetooth/pbapclient/PbapClientService$BluetoothPbapClientBinder;->getDevicesMatchingConnectionStates([I)Ljava/util/List;
Lcom/android/bluetooth/pbapclient/PbapClientService$BluetoothPbapClientBinder;->getPriority(Landroid/bluetooth/BluetoothDevice;)I
Lcom/android/bluetooth/pbapclient/PbapClientService$BluetoothPbapClientBinder;->setPriority(Landroid/bluetooth/BluetoothDevice;I)Z
Lcom/android/bluetooth/sap/SapService$SapBinder;->connect(Landroid/bluetooth/BluetoothDevice;)Z
Lcom/android/bluetooth/sap/SapService$SapBinder;->disconnect(Landroid/bluetooth/BluetoothDevice;)Z
Lcom/android/bluetooth/sap/SapService$SapBinder;->getClient()Landroid/bluetooth/BluetoothDevice;
Lcom/android/bluetooth/sap/SapService$SapBinder;->getConnectedDevices()Ljava/util/List;
Lcom/android/bluetooth/sap/SapService$SapBinder;->getConnectionState(Landroid/bluetooth/BluetoothDevice;)I
Lcom/android/bluetooth/sap/SapService$SapBinder;->getDevicesMatchingConnectionStates([I)Ljava/util/List;
Lcom/android/bluetooth/sap/SapService$SapBinder;->getPriority(Landroid/bluetooth/BluetoothDevice;)I
Lcom/android/bluetooth/sap/SapService$SapBinder;->getState()I
Lcom/android/bluetooth/sap/SapService$SapBinder;->isConnected(Landroid/bluetooth/BluetoothDevice;)Z
Lcom/android/bluetooth/sap/SapService$SapBinder;->setPriority(Landroid/bluetooth/BluetoothDevice;I)Z
Lcom/android/car/CarRadioService;->setPreset(Landroid/car/hardware/radio/CarRadioPreset;)Z
Lcom/android/car/ICarImpl;->getCarService(Ljava/lang/String;)Landroid/os/IBinder;
Lcom/android/car/pm/CarPackageManagerService;->setAppBlockingPolicy(Ljava/lang/String;Landroid/car/content/pm/CarAppBlockingPolicy;I)V
Lcom/android/Iernal/telephony/PhoneSubInfoController;->getCompleteVoiceMailNumber()Ljava/lang/String;
Lcom/android/Iernal/telephony/PhoneSubInfoController;->getCompleteVoiceMailNumberForSubscriber(I)Ljava/lang/String;
Lcom/android/Iernal/telephony/PhoneSubInfoController;->getDeviceId(Ljava/lang/String;)Ljava/lang/String;
Lcom/android/Iernal/telephony/PhoneSubInfoController;->getDeviceIdForPhone(ILjava/lang/String;)Ljava/lang/String;
Lcom/android/Iernal/telephony/PhoneSubInfoController;->getDeviceSvn(Ljava/lang/String;)Ljava/lang/String;
Lcom/android/Iernal/telephony/PhoneSubInfoController;->getDeviceSvnUsingSubId(ILjava/lang/String;)Ljava/lang/String;
Lcom/android/Iernal/telephony/PhoneSubInfoController;->getGroupIdLevel1(Ljava/lang/String;)Ljava/lang/String;
Lcom/android/Iernal/telephony/PhoneSubInfoController;->getGroupIdLevel1ForSubscriber(ILjava/lang/String;)Ljava/lang/String;
Lcom/android/Iernal/telephony/PhoneSubInfoController;->getIccSerialNumber(Ljava/lang/String;)Ljava/lang/String;
Lcom/android/Iernal/telephony/PhoneSubInfoController;->getIccSerialNumberForSubscriber(ILjava/lang/String;)Ljava/lang/String;
Lcom/android/Iernal/telephony/PhoneSubInfoController;->getIccSimChallengeResponse(IIILjava/lang/String;)Ljava/lang/String;
Lcom/android/Iernal/telephony/PhoneSubInfoController;->getImeiForSubscriber(ILjava/lang/String;)Ljava/lang/String;
Lcom/android/Iernal/telephony/PhoneSubInfoController;->getIsimChallengeResponse(Ljava/lang/String;)Ljava/lang/String;
Lcom/android/Iernal/telephony/PhoneSubInfoController;->getIsimDomain()Ljava/lang/String;
Lcom/android/Iernal/telephony/PhoneSubInfoController;->getIsimImpi()Ljava/lang/String;
Lcom/android/Iernal/telephony/PhoneSubInfoController;->getIsimImpu()[Ljava/lang/String;
Lcom/android/Iernal/telephony/PhoneSubInfoController;->getIsimIst()Ljava/lang/String;
Lcom/android/Iernal/telephony/PhoneSubInfoController;->getIsimPcscf()[Ljava/lang/String;
Lcom/android/Iernal/telephony/PhoneSubInfoController;->getLine1AlphaTag(Ljava/lang/String;)Ljava/lang/String;
Lcom/android/Iernal/telephony/PhoneSubInfoController;->getLine1AlphaTagForSubscriber(ILjava/lang/String;)Ljava/lang/String;
Lcom/android/Iernal/telephony/PhoneSubInfoController;->getLine1Number(Ljava/lang/String;)Ljava/lang/String;
Lcom/android/Iernal/telephony/PhoneSubInfoController;->getLine1NumberForSubscriber(ILjava/lang/String;)Ljava/lang/String;
Lcom/android/Iernal/telephony/PhoneSubInfoController;->getMsisdn(Ljava/lang/String;)Ljava/lang/String;
Lcom/android/Iernal/telephony/PhoneSubInfoController;->getMsisdnForSubscriber(ILjava/lang/String;)Ljava/lang/String;
Lcom/android/Iernal/telephony/PhoneSubInfoController;->getNaiForSubscriber(ILjava/lang/String;)Ljava/lang/String;
Lcom/android/Iernal/telephony/PhoneSubInfoController;->getSubscriberId(Ljava/lang/String;)Ljava/lang/String;
Lcom/android/Iernal/telephony/PhoneSubInfoController;->getSubscriberIdForSubscriber(ILjava/lang/String;)Ljava/lang/String;
Lcom/android/Iernal/telephony/PhoneSubInfoController;->getVoiceMailAlphaTag(Ljava/lang/String;)Ljava/lang/String;
Lcom/android/Iernal/telephony/PhoneSubInfoController;->getVoiceMailAlphaTagForSubscriber(ILjava/lang/String;)Ljava/lang/String;
Lcom/android/Iernal/telephony/PhoneSubInfoController;->getVoiceMailNumber(Ljava/lang/String;)Ljava/lang/String;
Lcom/android/Iernal/telephony/PhoneSubInfoController;->getVoiceMailNumberForSubscriber(ILjava/lang/String;)Ljava/lang/String;
Lcom/android/Iernal/telephony/SubscriptionController;->addSubInfoRecord(Ljava/lang/String;I)I
Lcom/android/Iernal/telephony/SubscriptionController;->clearDefaultsForInactiveSubIds()V
Lcom/android/Iernal/telephony/SubscriptionController;->clearSubInfo()I
Lcom/android/Iernal/telephony/SubscriptionController;->getActiveSubInfoCount(Ljava/lang/String;)I
Lcom/android/Iernal/telephony/SubscriptionController;->getActiveSubscriptionInfo(ILjava/lang/String;)Landroid/telephony/SubscriptionInfo;
Lcom/android/Iernal/telephony/SubscriptionController;->getActiveSubscriptionInfoForIccId(Ljava/lang/String;Ljava/lang/String;)Landroid/telephony/SubscriptionInfo;
Lcom/android/Iernal/telephony/SubscriptionController;->getActiveSubscriptionInfoForSimSlotIndex(ILjava/lang/String;)Landroid/telephony/SubscriptionInfo;
Lcom/android/Iernal/telephony/SubscriptionController;->getActiveSubscriptionInfoList(Ljava/lang/String;)Ljava/util/List;
Lcom/android/Iernal/telephony/SubscriptionController;->getAllSubInfoCount(Ljava/lang/String;)I
Lcom/android/Iernal/telephony/SubscriptionController;->getAllSubInfoList(Ljava/lang/String;)Ljava/util/List;
Lcom/android/Iernal/telephony/SubscriptionController;->getSubscriptionProperty(ILjava/lang/String;Ljava/lang/String;)Ljava/lang/String;
Lcom/android/Iernal/telephony/SubscriptionController;->setDataRoaming(II)I
Lcom/android/Iernal/telephony/SubscriptionController;->setDefaultDataSubId(I)V
Lcom/android/Iernal/telephony/SubscriptionController;->setDefaultSmsSubId(I)V
Lcom/android/Iernal/telephony/SubscriptionController;->setDefaultVoiceSubId(I)V
Lcom/android/Iernal/telephony/SubscriptionController;->setDisplayName(Ljava/lang/String;I)I
Lcom/android/Iernal/telephony/SubscriptionController;->setDisplayNameUsingSrc(Ljava/lang/String;IJ)I
Lcom/android/Iernal/telephony/SubscriptionController;->setDisplayNumber(Ljava/lang/String;I)I
Lcom/android/Iernal/telephony/SubscriptionController;->setIconTI(II)I
Lcom/android/Iernal/telephony/SubscriptionController;->setSubscriptionProperty(ILjava/lang/String;Ljava/lang/String;)V
Lcom/android/Iernal/telephony/UiccPhoneBookController;->getAdnRecordsInEf(I)Ljava/util/List;
Lcom/android/Iernal/telephony/UiccPhoneBookController;->getAdnRecordsInEfForSubscriber(II)Ljava/util/List;
Lcom/android/Iernal/telephony/UiccPhoneBookController;->updateAdnRecordsInEfByIndex(ILjava/lang/String;Ljava/lang/String;ILjava/lang/String;)Z
Lcom/android/Iernal/telephony/UiccPhoneBookController;->updateAdnRecordsInEfByIndexForSubscriber(IILjava/lang/String;Ljava/lang/String;ILjava/lang/String;)Z
Lcom/android/Iernal/telephony/UiccPhoneBookController;->updateAdnRecordsInEfBySearch(ILjava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Z
Lcom/android/Iernal/telephony/UiccPhoneBookController;->updateAdnRecordsInEfBySearchForSubscriber(IILjava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Z
Lcom/android/Iernal/telephony/UiccSmsController;->copyMessageToIccEfForSubscriber(ILjava/lang/String;I[B[B)Z
Lcom/android/Iernal/telephony/UiccSmsController;->disableCellBroadcastForSubscriber(III)Z
Lcom/android/Iernal/telephony/UiccSmsController;->disableCellBroadcastRangeForSubscriber(IIII)Z
Lcom/android/Iernal/telephony/UiccSmsController;->enableCellBroadcastForSubscriber(III)Z
Lcom/android/Iernal/telephony/UiccSmsController;->enableCellBroadcastRangeForSubscriber(IIII)Z
Lcom/android/Iernal/telephony/UiccSmsController;->getAllMessagesFromIccEfForSubscriber(ILjava/lang/String;)Ljava/util/List;
Lcom/android/Iernal/telephony/UiccSmsController;->sendDataForSubscriber(ILjava/lang/String;Ljava/lang/String;Ljava/lang/String;I[BLandroid/app/PendingIntent;Landroid/app/PendingIntent;)V
Lcom/android/Iernal/telephony/UiccSmsController;->sendDataForSubscriberWithSelfPermissions(ILjava/lang/String;Ljava/lang/String;Ljava/lang/String;I[BLandroid/app/PendingIntent;Landroid/app/PendingIntent;)V
Lcom/android/Iernal/telephony/UiccSmsController;->sendMultipartTextForSubscriber(ILjava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/util/List;Ljava/util/List;Ljava/util/List;Z)V
Lcom/android/Iernal/telephony/UiccSmsController;->sendStoredMultipartText(ILjava/lang/String;Landroid/net/Uri;Ljava/lang/String;Ljava/util/List;Ljava/util/List;)V
Lcom/android/Iernal/telephony/UiccSmsController;->sendStoredText(ILjava/lang/String;Landroid/net/Uri;Ljava/lang/String;Landroid/app/PendingIntent;Landroid/app/PendingIntent;)V
Lcom/android/Iernal/telephony/UiccSmsController;->sendTextForSubscriber(ILjava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Landroid/app/PendingIntent;Landroid/app/PendingIntent;Z)V
Lcom/android/Iernal/telephony/UiccSmsController;->sendTextForSubscriberWithSelfPermissions(ILjava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Landroid/app/PendingIntent;Landroid/app/PendingIntent;Z)V
Lcom/android/Iernal/telephony/UiccSmsController;->updateMessageOnIccEfForSubscriber(ILjava/lang/String;II[B)Z
Lcom/android/phone/CarrierConfigLoader;->getConfigForSubId(I)Landroid/os/PersistableBundle;
Lcom/android/phone/CarrierConfigLoader;->notifyConfigChangedForSubId(I)V
Lcom/android/phone/CarrierConfigLoader;->updateConfigForPhoneId(ILjava/lang/String;)V
Lcom/android/phone/PhoneInterfaceManager;->answerRingingCall()V
Lcom/android/phone/PhoneInterfaceManager;->answerRingingCallForSubscriber(I)V
Lcom/android/phone/PhoneInterfaceManager;->call(Ljava/lang/String;Ljava/lang/String;)V
Lcom/android/phone/PhoneInterfaceManager;->carrierActionSetMeteredApnsEnabled(IZ)V
Lcom/android/phone/PhoneInterfaceManager;->carrierActionSetRadioEnabled(IZ)V
Lcom/android/phone/PhoneInterfaceManager;->disableDataConnectivity()Z
Lcom/android/phone/PhoneInterfaceManager;->disableLocationUpdates()V
Lcom/android/phone/PhoneInterfaceManager;->disableLocationUpdatesForSubscriber(I)V
Lcom/android/phone/PhoneInterfaceManager;->enableDataConnectivity()Z
Lcom/android/phone/PhoneInterfaceManager;->enableLocationUpdates()V
Lcom/android/phone/PhoneInterfaceManager;->enableLocationUpdatesForSubscriber(I)V
Lcom/android/phone/PhoneInterfaceManager;->enableVideoCalling(Z)V
Lcom/android/phone/PhoneInterfaceManager;->endCall()Z
Lcom/android/phone/PhoneInterfaceManager;->endCallForSubscriber(I)Z
Lcom/android/phone/PhoneInterfaceManager;->factoryReset(I)V
Lcom/android/phone/PhoneInterfaceManager;->getAidForAppType(II)Ljava/lang/String;
Lcom/android/phone/PhoneInterfaceManager;->getAllCellInfo(Ljava/lang/String;)Ljava/util/List;
Lcom/android/phone/PhoneInterfaceManager;->getAllowedCarriers(I)Ljava/util/List;
Lcom/android/phone/PhoneInterfaceManager;->getCalculatedPreferredNetworkType(Ljava/lang/String;)I
Lcom/android/phone/PhoneInterfaceManager;->getCdmaEriIconIndex(Ljava/lang/String;)I
Lcom/android/phone/PhoneInterfaceManager;->getCdmaEriIconIndexForSubscriber(ILjava/lang/String;)I
Lcom/android/phone/PhoneInterfaceManager;->getCdmaEriIconMode(Ljava/lang/String;)I
Lcom/android/phone/PhoneInterfaceManager;->getCdmaEriIconModeForSubscriber(ILjava/lang/String;)I
Lcom/android/phone/PhoneInterfaceManager;->getCdmaEriText(Ljava/lang/String;)Ljava/lang/String;
Lcom/android/phone/PhoneInterfaceManager;->getCdmaEriTextForSubscriber(ILjava/lang/String;)Ljava/lang/String;
Lcom/android/phone/PhoneInterfaceManager;->getCdmaMdn(I)Ljava/lang/String;
Lcom/android/phone/PhoneInterfaceManager;->getCdmaMin(I)Ljava/lang/String;
Lcom/android/phone/PhoneInterfaceManager;->getCdmaPrlVersion(I)Ljava/lang/String;
Lcom/android/phone/PhoneInterfaceManager;->getCellLocation(Ljava/lang/String;)Landroid/os/Bundle;
Lcom/android/phone/PhoneInterfaceManager;->getCellNetworkScanResults(I)Lcom/android/Iernal/telephony/CellNetworkScanResult;
Lcom/android/phone/PhoneInterfaceManager;->getDataEnabled(I)Z
Lcom/android/phone/PhoneInterfaceManager;->getDataNetworkType(Ljava/lang/String;)I
Lcom/android/phone/PhoneInterfaceManager;->getDataNetworkTypeForSubscriber(ILjava/lang/String;)I
Lcom/android/phone/PhoneInterfaceManager;->getDeviceId(Ljava/lang/String;)Ljava/lang/String;
Lcom/android/phone/PhoneInterfaceManager;->getDeviceSoftwareVersionForSlot(ILjava/lang/String;)Ljava/lang/String;
Lcom/android/phone/PhoneInterfaceManager;->getEsn(I)Ljava/lang/String;
Lcom/android/phone/PhoneInterfaceManager;->getImeiForSlot(ILjava/lang/String;)Ljava/lang/String;
Lcom/android/phone/PhoneInterfaceManager;->getLine1AlphaTagForDisplay(ILjava/lang/String;)Ljava/lang/String;
Lcom/android/phone/PhoneInterfaceManager;->getLine1NumberForDisplay(ILjava/lang/String;)Ljava/lang/String;
Lcom/android/phone/PhoneInterfaceManager;->getLteOnCdmaMode(Ljava/lang/String;)I
Lcom/android/phone/PhoneInterfaceManager;->getLteOnCdmaModeForSubscriber(ILjava/lang/String;)I
Lcom/android/phone/PhoneInterfaceManager;->getMergedSubscriberIds(Ljava/lang/String;)[Ljava/lang/String;
Lcom/android/phone/PhoneInterfaceManager;->getNeighboringCellInfo(Ljava/lang/String;)Ljava/util/List;
Lcom/android/phone/PhoneInterfaceManager;->getNetworkTypeForSubscriber(ILjava/lang/String;)I
Lcom/android/phone/PhoneInterfaceManager;->getPcscfAddress(Ljava/lang/String;Ljava/lang/String;)[Ljava/lang/String;
Lcom/android/phone/PhoneInterfaceManager;->getPreferredNetworkType(I)I
Lcom/android/phone/PhoneInterfaceManager;->getRadioAccessFamily(ILjava/lang/String;)I
Lcom/android/phone/PhoneInterfaceManager;->getServiceStateForSubscriber(ILjava/lang/String;)Landroid/telephony/ServiceState;
Lcom/android/phone/PhoneInterfaceManager;->getSystemVisualVoicemailSmsFilterSettings(Ljava/lang/String;I)Landroid/telephony/VisualVoicemailSmsFilterSettings;
Lcom/android/phone/PhoneInterfaceManager;->getTelephonyHistograms()Ljava/util/List;
Lcom/android/phone/PhoneInterfaceManager;->getTetherApnRequired()I
Lcom/android/phone/PhoneInterfaceManager;->getVoiceNetworkTypeForSubscriber(ILjava/lang/String;)I
Lcom/android/phone/PhoneInterfaceManager;->getVtDataUsage()J
Lcom/android/phone/PhoneInterfaceManager;->handlePinMmi(Ljava/lang/String;)Z
Lcom/android/phone/PhoneInterfaceManager;->handlePinMmiForSubscriber(ILjava/lang/String;)Z
Lcom/android/phone/PhoneInterfaceManager;->iccCloseLogicalChannel(II)Z
Lcom/android/phone/PhoneInterfaceManager;->iccExchangeSimIO(IIIIIILjava/lang/String;)[B
Lcom/android/phone/PhoneInterfaceManager;->iccOpenLogicalChannel(ILjava/lang/String;)Landroid/telephony/IccOpenLogicalChannelResponse;
Lcom/android/phone/PhoneInterfaceManager;->iccTransmitApduBasicChannel(IIIIIILjava/lang/String;)Ljava/lang/String;
Lcom/android/phone/PhoneInterfaceManager;->iccTransmitApduLogicalChannel(IIIIIIILjava/lang/String;)Ljava/lang/String;
Lcom/android/phone/PhoneInterfaceManager;->invokeOemRilRequestRaw([B[B)I
Lcom/android/phone/PhoneInterfaceManager;->isIdle(Ljava/lang/String;)Z
Lcom/android/phone/PhoneInterfaceManager;->isIdleForSubscriber(ILjava/lang/String;)Z
Lcom/android/phone/PhoneInterfaceManager;->isOffhook(Ljava/lang/String;)Z
Lcom/android/phone/PhoneInterfaceManager;->isOffhookForSubscriber(ILjava/lang/String;)Z
Lcom/android/phone/PhoneInterfaceManager;->isRadioOn(Ljava/lang/String;)Z
Lcom/android/phone/PhoneInterfaceManager;->isRadioOnForSubscriber(ILjava/lang/String;)Z
Lcom/android/phone/PhoneInterfaceManager;->isRinging(Ljava/lang/String;)Z
Lcom/android/phone/PhoneInterfaceManager;->isRingingForSubscriber(ILjava/lang/String;)Z
Lcom/android/phone/PhoneInterfaceManager;->isVideoCallingEnabled(Ljava/lang/String;)Z
Lcom/android/phone/PhoneInterfaceManager;->isVisualVoicemailEnabled(Ljava/lang/String;Landroid/telecom/PhoneAccountHandle;)Z
Lcom/android/phone/PhoneInterfaceManager;->nvReadItem(I)Ljava/lang/String;
Lcom/android/phone/PhoneInterfaceManager;->nvResetConfig(I)Z
Lcom/android/phone/PhoneInterfaceManager;->nvWriteCdmaPrl([B)Z
Lcom/android/phone/PhoneInterfaceManager;->nvWriteItem(ILjava/lang/String;)Z
Lcom/android/phone/PhoneInterfaceManager;->requestModemActivityInfo(Landroid/os/ResultReceiver;)V
Lcom/android/phone/PhoneInterfaceManager;->sendEnvelopeWithStatus(ILjava/lang/String;)Ljava/lang/String;
Lcom/android/phone/PhoneInterfaceManager;->setAllowedCarriers(ILjava/util/List;)I
Lcom/android/phone/PhoneInterfaceManager;->setDataEnabled(IZ)V
Lcom/android/phone/PhoneInterfaceManager;->setImsRegistrationState(Z)V
Lcom/android/phone/PhoneInterfaceManager;->setNetworkSelectionModeAutomatic(I)V
Lcom/android/phone/PhoneInterfaceManager;->setNetworkSelectionModeManual(ILcom/android/Iernal/telephony/OperatorInfo;Z)Z
Lcom/android/phone/PhoneInterfaceManager;->setPolicyDataEnabled(ZI)V
Lcom/android/phone/PhoneInterfaceManager;->setPreferredNetworkType(II)Z
Lcom/android/phone/PhoneInterfaceManager;->setRadio(Z)Z
Lcom/android/phone/PhoneInterfaceManager;->setRadioForSubscriber(IZ)Z
Lcom/android/phone/PhoneInterfaceManager;->setRadioPower(Z)Z
Lcom/android/phone/PhoneInterfaceManager;->setVisualVoicemailEnabled(Ljava/lang/String;Landroid/telecom/PhoneAccountHandle;Z)V
Lcom/android/phone/PhoneInterfaceManager;->shutdownMobileRadios()V
Lcom/android/phone/PhoneInterfaceManager;->supplyPin(Ljava/lang/String;)Z
Lcom/android/phone/PhoneInterfaceManager;->supplyPinForSubscriber(ILjava/lang/String;)Z
Lcom/android/phone/PhoneInterfaceManager;->supplyPinReportResult(Ljava/lang/String;)[I
Lcom/android/phone/PhoneInterfaceManager;->supplyPinReportResultForSubscriber(ILjava/lang/String;)[I
Lcom/android/phone/PhoneInterfaceManager;->supplyPuk(Ljava/lang/String;Ljava/lang/String;)Z
Lcom/android/phone/PhoneInterfaceManager;->supplyPukForSubscriber(ILjava/lang/String;Ljava/lang/String;)Z
Lcom/android/phone/PhoneInterfaceManager;->supplyPukReportResult(Ljava/lang/String;Ljava/lang/String;)[I
Lcom/android/phone/PhoneInterfaceManager;->supplyPukReportResultForSubscriber(ILjava/lang/String;Ljava/lang/String;)[I
Lcom/android/phone/PhoneInterfaceManager;->toggleRadioOnOff()V
Lcom/android/phone/PhoneInterfaceManager;->toggleRadioOnOffForSubscriber(I)V
Lcom/android/providers/contacts/ContactsProvider2;->getType(Landroid/net/Uri;)Ljava/lang/String;
Lcom/android/server/accessibility/AccessibilityManagerService$Service;->findAccessibilityNodeInfoByAccessibilityId(IJILandroid/view/accessibility/IAccessibilityInteractionConnectionCallback;IJ)Z
Lcom/android/server/accessibility/AccessibilityManagerService$Service;->findAccessibilityNodeInfosByText(IJLjava/lang/String;ILandroid/view/accessibility/IAccessibilityInteractionConnectionCallback;J)Z
Lcom/android/server/accessibility/AccessibilityManagerService$Service;->findAccessibilityNodeInfosByViewId(IJLjava/lang/String;ILandroid/view/accessibility/IAccessibilityInteractionConnectionCallback;J)Z
Lcom/android/server/accessibility/AccessibilityManagerService$Service;->findFocus(IJIILandroid/view/accessibility/IAccessibilityInteractionConnectionCallback;J)Z
Lcom/android/server/accessibility/AccessibilityManagerService$Service;->focusSearch(IJIILandroid/view/accessibility/IAccessibilityInteractionConnectionCallback;J)Z
Lcom/android/server/accessibility/AccessibilityManagerService$Service;->getMagnificationCenterX()F
Lcom/android/server/accessibility/AccessibilityManagerService$Service;->getMagnificationCenterY()F
Lcom/android/server/accessibility/AccessibilityManagerService$Service;->getMagnificationRegion()Landroid/graphics/Region;
Lcom/android/server/accessibility/AccessibilityManagerService$Service;->getMagnificationScale()F
Lcom/android/server/accessibility/AccessibilityManagerService$Service;->getWindow(I)Landroid/view/accessibility/AccessibilityWindowInfo;
Lcom/android/server/accessibility/AccessibilityManagerService$Service;->getWindows()Ljava/util/List;
Lcom/android/server/accessibility/AccessibilityManagerService$Service;->performAccessibilityAction(IJILandroid/os/Bundle;ILandroid/view/accessibility/IAccessibilityInteractionConnectionCallback;J)Z
Lcom/android/server/accessibility/AccessibilityManagerService$Service;->performGlobalAction(I)Z
Lcom/android/server/accessibility/AccessibilityManagerService$Service;->resetMagnification(Z)Z
Lcom/android/server/accessibility/AccessibilityManagerService$Service;->setMagnificationScaleAndCenter(FFFZ)Z
Lcom/android/server/accessibility/AccessibilityManagerService$Service;->setSoftKeyboardShowMode(I)Z
Lcom/android/server/accessibility/AccessibilityManagerService;->addAccessibilityInteractionConnection(Landroid/view/IWindow;Landroid/view/accessibility/IAccessibilityInteractionConnection;I)I
Lcom/android/server/accessibility/AccessibilityManagerService;->addClient(Landroid/view/accessibility/IAccessibilityManagerClient;I)I
Lcom/android/server/accessibility/AccessibilityManagerService;->disableAccessibilityService(Landroid/content/ComponentName;I)V
Lcom/android/server/accessibility/AccessibilityManagerService;->enableAccessibilityService(Landroid/content/ComponentName;I)V
Lcom/android/server/accessibility/AccessibilityManagerService;->getEnabledAccessibilityServiceList(II)Ljava/util/List;
Lcom/android/server/accessibility/AccessibilityManagerService;->getInstalledAccessibilityServiceList(I)Ljava/util/List;
Lcom/android/server/accessibility/AccessibilityManagerService;->getWindowToken(II)Landroid/os/IBinder;
Lcom/android/server/accessibility/AccessibilityManagerService;->Ierrupt(I)V
Lcom/android/server/accessibility/AccessibilityManagerService;->removeAccessibilityInteractionConnection(Landroid/view/IWindow;)V
Lcom/android/server/accessibility/AccessibilityManagerService;->sendAccessibilityEvent(Landroid/view/accessibility/AccessibilityEvent;I)Z
Lcom/android/server/accessibility/AccessibilityManagerService;->temporaryEnableAccessibilityStateUntilKeyguardRemoved(Landroid/content/ComponentName;Z)V
Lcom/android/server/accounts/AccountManagerService;->addAccountAsUser(Landroid/accounts/IAccountManagerResponse;Ljava/lang/String;Ljava/lang/String;L[java/lang/String;ZLandroid/os/Bundle;I)V
Lcom/android/server/accounts/AccountManagerService;->addSharedAccountsFromParentUser(II)V
Lcom/android/server/accounts/AccountManagerService;->confirmCredentialsAsUser(Landroid/accounts/IAccountManagerResponse;Landroid/accounts/Account;Landroid/os/Bundle;ZI)V
Lcom/android/server/accounts/AccountManagerService;->copyAccountToUser(Landroid/accounts/IAccountManagerResponse;Landroid/accounts/Account;II)V
Lcom/android/server/accounts/AccountManagerService;->finishSessionAsUser(Landroid/accounts/IAccountManagerResponse;Landroid/os/Bundle;ZLandroid/os/Bundle;I)V
Lcom/android/server/accounts/AccountManagerService;->getAccounts(Ljava/lang/String;Ljava/lang/String;)[Landroid/accounts/Account;
Lcom/android/server/accounts/AccountManagerService;->getAccountsAsUser(Ljava/lang/String;ILjava/lang/String;)[Landroid/accounts/Account;
Lcom/android/server/accounts/AccountManagerService;->getAccountsByTypeForPackage(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)[Landroid/accounts/Account;
Lcom/android/server/accounts/AccountManagerService;->getAccountsForPackage(Ljava/lang/String;ILjava/lang/String;)[Landroid/accounts/Account;
Lcom/android/server/accounts/AccountManagerService;->getAuthenticatorTypes(I)[Landroid/accounts/AuthenticatorDescription;
Lcom/android/server/accounts/AccountManagerService;->removeAccount(Landroid/accounts/IAccountManagerResponse;Landroid/accounts/Account;Z)V
Lcom/android/server/accounts/AccountManagerService;->removeAccountAsUser(Landroid/accounts/IAccountManagerResponse;Landroid/accounts/Account;ZI)V
Lcom/android/server/am/ActivityManagerService;->appNotRespondingViaProvider(Landroid/os/IBinder;)V
Lcom/android/server/am/ActivityManagerService;->bindBackupAgent(Ljava/lang/String;II)Z
Lcom/android/server/am/ActivityManagerService;->bindService(Landroid/app/IApplicationThread;Landroid/os/IBinder;Landroid/content/Intent;Ljava/lang/String;Landroid/app/IServiceConnection;ILjava/lang/String;I)I
Lcom/android/server/am/ActivityManagerService;->bootAnimationComplete()V
Lcom/android/server/am/ActivityManagerService;->clearGrantedUriPermissions(Ljava/lang/String;I)V
Lcom/android/server/am/ActivityManagerService;->clearPendingBackup()V
Lcom/android/server/am/ActivityManagerService;->crashApplication(IILjava/lang/String;Ljava/lang/String;)V
Lcom/android/server/am/ActivityManagerService;->createStackOnDisplay(I)Landroid/app/IActivityContainer;
Lcom/android/server/am/ActivityManagerService;->createVirtualActivityContainer(Landroid/os/IBinder;Landroid/app/IActivityContainerCallback;)Landroid/app/IActivityContainer;
Lcom/android/server/am/ActivityManagerService;->deleteActivityContainer(Landroid/app/IActivityContainer;)V
Lcom/android/server/am/ActivityManagerService;->dumpHeap(Ljava/lang/String;IZLjava/lang/String;Landroid/os/ParcelFileDescriptor;)Z
Lcom/android/server/am/ActivityManagerService;->finishHeavyWeightApp()V
Lcom/android/server/am/ActivityManagerService;->forceStopPackage(Ljava/lang/String;I)V
Lcom/android/server/am/ActivityManagerService;->getAllStackInfos()Ljava/util/List;
Lcom/android/server/am/ActivityManagerService;->getAssistContextExtras(I)Landroid/os/Bundle;
Lcom/android/server/am/ActivityManagerService;->getContentProviderExternal(Ljava/lang/String;ILandroid/os/IBinder;)Landroid/app/IActivityManager$ContentProviderHolder;
Lcom/android/server/am/ActivityManagerService;->getCurrentUser()Landroid/content/pm/UserInfo;
Lcom/android/server/am/ActivityManagerService;->getGrantedUriPermissions(Ljava/lang/String;I)Landroid/content/pm/ParceledListSlice;
Lcom/android/server/am/ActivityManagerService;->getIntentForIntentSender(Landroid/content/IIntentSender;)Landroid/content/Intent;
Lcom/android/server/am/ActivityManagerService;->getPackageProcessState(Ljava/lang/String;Ljava/lang/String;)I
Lcom/android/server/am/ActivityManagerService;->getRecentTasks(III)Landroid/content/pm/ParceledListSlice;
Lcom/android/server/am/ActivityManagerService;->getRunningAppProcesses()Ljava/util/List;
Lcom/android/server/am/ActivityManagerService;->getRunningExternalApplications()Ljava/util/List;
Lcom/android/server/am/ActivityManagerService;->getRunningUserIds()[I
Lcom/android/server/am/ActivityManagerService;->getStackInfo(I)Landroid/app/ActivityManager$StackInfo;
Lcom/android/server/am/ActivityManagerService;->getTaskBounds(I)Landroid/graphics/Rect;
Lcom/android/server/am/ActivityManagerService;->getTaskDescriptionIcon(Ljava/lang/String;I)Landroid/graphics/Bitmap;
Lcom/android/server/am/ActivityManagerService;->getTasks(II)Ljava/util/List;
Lcom/android/server/am/ActivityManagerService;->getTaskThumbnail(I)Landroid/app/ActivityManager$TaskThumbnail;
Lcom/android/server/am/ActivityManagerService;->hang(Landroid/os/IBinder;Z)V
Lcom/android/server/am/ActivityManagerService;->inputDispatchingTimedOut(IZLjava/lang/String;)J
Lcom/android/server/am/ActivityManagerService;->isInHomeStack(I)Z
Lcom/android/server/am/ActivityManagerService;->isUserRunning(II)Z
Lcom/android/server/am/ActivityManagerService;->killAllBackgroundProcesses()V
Lcom/android/server/am/ActivityManagerService;->killBackgroundProcesses(Ljava/lang/String;I)V
Lcom/android/server/am/ActivityManagerService;->killPackageDependents(Ljava/lang/String;I)V
Lcom/android/server/am/ActivityManagerService;->killUid(IILjava/lang/String;)V
Lcom/android/server/am/ActivityManagerService;->launchAssistIntent(Landroid/content/Intent;ILjava/lang/String;ILandroid/os/Bundle;)Z
Lcom/android/server/am/ActivityManagerService;->moveTaskBackwards(I)V
Lcom/android/server/am/ActivityManagerService;->moveTasksToFullscreenStack(IZ)V
Lcom/android/server/am/ActivityManagerService;->moveTaskToDockedStack(IIZZLandroid/graphics/Rect;Z)Z
Lcom/android/server/am/ActivityManagerService;->moveTaskToFront(IILandroid/os/Bundle;)V
Lcom/android/server/am/ActivityManagerService;->moveTaskToStack(IIZ)V
Lcom/android/server/am/ActivityManagerService;->moveTopActivityToPinnedStack(ILandroid/graphics/Rect;)Z
Lcom/android/server/am/ActivityManagerService;->navigateUpTo(Landroid/os/IBinder;Landroid/content/Intent;ILandroid/content/Intent;)Z
Lcom/android/server/am/ActivityManagerService;->performIdleMaIenance()V
Lcom/android/server/am/ActivityManagerService;->positionTaskInStack(III)V
Lcom/android/server/am/ActivityManagerService;->profileControl(Ljava/lang/String;IZLandroid/app/ProfilerInfo;I)Z
Lcom/android/server/am/ActivityManagerService;->registerProcessObserver(Landroid/app/IProcessObserver;)V
Lcom/android/server/am/ActivityManagerService;->registerTaskStackListener(Landroid/app/ITaskStackListener;)V
Lcom/android/server/am/ActivityManagerService;->registerUidObserver(Landroid/app/IUidObserver;I)V
Lcom/android/server/am/ActivityManagerService;->registerUserSwitchObserver(Landroid/app/IUserSwitchObserver;Ljava/lang/String;)V
Lcom/android/server/am/ActivityManagerService;->removeContentProviderExternal(Ljava/lang/String;Landroid/os/IBinder;)V
Lcom/android/server/am/ActivityManagerService;->removeStack(I)V
Lcom/android/server/am/ActivityManagerService;->removeTask(I)Z
Lcom/android/server/am/ActivityManagerService;->requestAssistContextExtras(ILcom/android/Iernal/os/IResultReceiver;Landroid/os/Bundle;Landroid/os/IBinder;ZZ)Z
Lcom/android/server/am/ActivityManagerService;->requestBugReport(I)V
Lcom/android/server/am/ActivityManagerService;->resizeDockedStack(Landroid/graphics/Rect;Landroid/graphics/Rect;Landroid/graphics/Rect;Landroid/graphics/Rect;Landroid/graphics/Rect;)V
Lcom/android/server/am/ActivityManagerService;->resizePinnedStack(Landroid/graphics/Rect;Landroid/graphics/Rect;)V
Lcom/android/server/am/ActivityManagerService;->resizeStack(ILandroid/graphics/Rect;ZZZI)V
Lcom/android/server/am/ActivityManagerService;->resizeTask(ILandroid/graphics/Rect;I)V
Lcom/android/server/am/ActivityManagerService;->restart()V
Lcom/android/server/am/ActivityManagerService;->resumeAppSwitches()V
Lcom/android/server/am/ActivityManagerService;->sendIdleJobTrigger()V
Lcom/android/server/am/ActivityManagerService;->setActivityController(Landroid/app/IActivityController;Z)V
Lcom/android/server/am/ActivityManagerService;->setAlwaysFinish(Z)V
Lcom/android/server/am/ActivityManagerService;->setDebugApp(Ljava/lang/String;ZZ)V
Lcom/android/server/am/ActivityManagerService;->setDumpHeapDebugLimit(Ljava/lang/String;IJLjava/lang/String;)V
Lcom/android/server/am/ActivityManagerService;->setFocusedStack(I)V
Lcom/android/server/am/ActivityManagerService;->setFocusedTask(I)V
Lcom/android/server/am/ActivityManagerService;->setFrontActivityScreenCompatMode(I)V
Lcom/android/server/am/ActivityManagerService;->setHasTopUi(Z)V
Lcom/android/server/am/ActivityManagerService;->setLenientBackgroundCheck(Z)V
Lcom/android/server/am/ActivityManagerService;->setLockScreenShown(ZZ)V
Lcom/android/server/am/ActivityManagerService;->setPackageAskScreenCompat(Ljava/lang/String;Z)V
Lcom/android/server/am/ActivityManagerService;->setPackageScreenCompatMode(Ljava/lang/String;I)V
Lcom/android/server/am/ActivityManagerService;->setProcessForeground(Landroid/os/IBinder;IZ)V
Lcom/android/server/am/ActivityManagerService;->setProcessLimit(I)V
Lcom/android/server/am/ActivityManagerService;->setTaskDescription(Landroid/os/IBinder;Landroid/app/ActivityManager$TaskDescription;)V
Lcom/android/server/am/ActivityManagerService;->shutdown(I)Z
Lcom/android/server/am/ActivityManagerService;->signalPersistentProcesses(I)V
Lcom/android/server/am/ActivityManagerService;->startActivities(Landroid/app/IApplicationThread;Ljava/lang/String;L[android/content/Intent;L[java/lang/String;Landroid/os/IBinder;Landroid/os/Bundle;I)I
Lcom/android/server/am/ActivityManagerService;->startActivity(Landroid/app/IApplicationThread;Ljava/lang/String;Landroid/content/Intent;Ljava/lang/String;Landroid/os/IBinder;Ljava/lang/String;IILandroid/app/ProfilerInfo;Landroid/os/Bundle;)I
Lcom/android/server/am/ActivityManagerService;->startActivityAndWait(Landroid/app/IApplicationThread;Ljava/lang/String;Landroid/content/Intent;Ljava/lang/String;Landroid/os/IBinder;Ljava/lang/String;IILandroid/app/ProfilerInfo;Landroid/os/Bundle;I)Landroid/app/IActivityManager$WaitResult;
Lcom/android/server/am/ActivityManagerService;->startActivityAsCaller(Landroid/app/IApplicationThread;Ljava/lang/String;Landroid/content/Intent;Ljava/lang/String;Landroid/os/IBinder;Ljava/lang/String;IILandroid/app/ProfilerInfo;Landroid/os/Bundle;ZI)I
Lcom/android/server/am/ActivityManagerService;->startActivityAsUser(Landroid/app/IApplicationThread;Ljava/lang/String;Landroid/content/Intent;Ljava/lang/String;Landroid/os/IBinder;Ljava/lang/String;IILandroid/app/ProfilerInfo;Landroid/os/Bundle;I)I
Lcom/android/server/am/ActivityManagerService;->startActivityFromRecents(ILandroid/os/Bundle;)I
Lcom/android/server/am/ActivityManagerService;->startActivityWithConfig(Landroid/app/IApplicationThread;Ljava/lang/String;Landroid/content/Intent;Ljava/lang/String;Landroid/os/IBinder;Ljava/lang/String;IILandroid/content/res/Configuration;Landroid/os/Bundle;I)I
Lcom/android/server/am/ActivityManagerService;->startBinderTracking()Z
Lcom/android/server/am/ActivityManagerService;->startConfirmDeviceCredentialIntent(Landroid/content/Intent;)V
Lcom/android/server/am/ActivityManagerService;->startSystemLockTaskMode(I)V
Lcom/android/server/am/ActivityManagerService;->startUserInBackground(I)Z
Lcom/android/server/am/ActivityManagerService;->startVoiceActivity(Ljava/lang/String;IILandroid/content/Intent;Ljava/lang/String;Landroid/service/voice/IVoiceInteractionSession;Lcom/android/Iernal/app/IVoiceInteractor;ILandroid/app/ProfilerInfo;Landroid/os/Bundle;I)I
Lcom/android/server/am/ActivityManagerService;->stopAppSwitches()V
Lcom/android/server/am/ActivityManagerService;->stopBinderTrackingAndDump(Landroid/os/ParcelFileDescriptor;)Z
Lcom/android/server/am/ActivityManagerService;->stopLockTaskMode()V
Lcom/android/server/am/ActivityManagerService;->stopService(Landroid/app/IApplicationThread;Landroid/content/Intent;Ljava/lang/String;I)I
Lcom/android/server/am/ActivityManagerService;->stopServiceToken(Landroid/content/ComponentName;Landroid/os/IBinder;I)Z
Lcom/android/server/am/ActivityManagerService;->stopSystemLockTaskMode()V
Lcom/android/server/am/ActivityManagerService;->stopUser(IZLandroid/app/IStopUserCallback;)I
Lcom/android/server/am/ActivityManagerService;->suppressResizeConfigChanges(Z)V
Lcom/android/server/am/ActivityManagerService;->swapDockedAndFullscreenStack()V
Lcom/android/server/am/ActivityManagerService;->unbindService(Landroid/app/IServiceConnection;)Z
Lcom/android/server/am/ActivityManagerService;->unbroadcastIntent(Landroid/app/IApplicationThread;Landroid/content/Intent;I)V
Lcom/android/server/am/ActivityManagerService;->unhandledBack()V
Lcom/android/server/am/ActivityManagerService;->unlockUser(I[B[BLandroid/os/IProgressListener;)Z
Lcom/android/server/am/ActivityManagerService;->updateConfiguration(Landroid/content/res/Configuration;)V
Lcom/android/server/am/ActivityManagerService;->updatePersistentConfiguration(Landroid/content/res/Configuration;)V
Lcom/android/server/am/BatteryStatsService;->getAwakeTimeBattery()J
Lcom/android/server/am/BatteryStatsService;->getAwakeTimePlugged()J
Lcom/android/server/am/BatteryStatsService;->getStatistics()[B
Lcom/android/server/am/BatteryStatsService;->getStatisticsStream()Landroid/os/ParcelFileDescriptor;
Lcom/android/server/am/BatteryStatsService;->noteBleScanStarted(Landroid/os/WorkSource;)V
Lcom/android/server/am/BatteryStatsService;->noteBleScanStopped(Landroid/os/WorkSource;)V
Lcom/android/server/am/BatteryStatsService;->noteBluetoothControllerActivity(Landroid/bluetooth/BluetoothActivityEnergyInfo;)V
Lcom/android/server/am/BatteryStatsService;->noteChangeWakelockFromSource(Landroid/os/WorkSource;ILjava/lang/String;Ljava/lang/String;ILandroid/os/WorkSource;ILjava/lang/String;Ljava/lang/String;IZ)V
Lcom/android/server/am/BatteryStatsService;->noteConnectivityChanged(ILjava/lang/String;)V
Lcom/android/server/am/BatteryStatsService;->noteDeviceIdleMode(ILjava/lang/String;I)V
Lcom/android/server/am/BatteryStatsService;->noteEvent(ILjava/lang/String;I)V
Lcom/android/server/am/BatteryStatsService;->noteFlashlightOff(I)V
Lcom/android/server/am/BatteryStatsService;->noteFlashlightOn(I)V
Lcom/android/server/am/BatteryStatsService;->noteFullWifiLockAcquired(I)V
Lcom/android/server/am/BatteryStatsService;->noteFullWifiLockAcquiredFromSource(Landroid/os/WorkSource;)V
Lcom/android/server/am/BatteryStatsService;->noteFullWifiLockReleased(I)V
Lcom/android/server/am/BatteryStatsService;->noteFullWifiLockReleasedFromSource(Landroid/os/WorkSource;)V
Lcom/android/server/am/BatteryStatsService;->noteInteractive(Z)V
Lcom/android/server/am/BatteryStatsService;->noteJobFinish(Ljava/lang/String;I)V
Lcom/android/server/am/BatteryStatsService;->noteJobStart(Ljava/lang/String;I)V
Lcom/android/server/am/BatteryStatsService;->noteLongPartialWakelockFinish(Ljava/lang/String;Ljava/lang/String;I)V
Lcom/android/server/am/BatteryStatsService;->noteLongPartialWakelockStart(Ljava/lang/String;Ljava/lang/String;I)V
Lcom/android/server/am/BatteryStatsService;->noteMobileRadioPowerState(IJI)V
Lcom/android/server/am/BatteryStatsService;->noteModemControllerActivity(Landroid/telephony/ModemActivityInfo;)V
Lcom/android/server/am/BatteryStatsService;->noteNetworkInterfaceType(Ljava/lang/String;I)V
Lcom/android/server/am/BatteryStatsService;->noteNetworkStatsEnabled()V
Lcom/android/server/am/BatteryStatsService;->notePhoneDataConnectionState(IZ)V
Lcom/android/server/am/BatteryStatsService;->notePhoneOff()V
Lcom/android/server/am/BatteryStatsService;->notePhoneOn()V
Lcom/android/server/am/BatteryStatsService;->notePhoneSignalStrength(Landroid/telephony/SignalStrength;)V
Lcom/android/server/am/BatteryStatsService;->notePhoneState(I)V
Lcom/android/server/am/BatteryStatsService;->noteResetAudio()V
Lcom/android/server/am/BatteryStatsService;->noteResetBleScan()V
Lcom/android/server/am/BatteryStatsService;->noteResetCamera()V
Lcom/android/server/am/BatteryStatsService;->noteResetFlashlight()V
Lcom/android/server/am/BatteryStatsService;->noteResetVideo()V
Lcom/android/server/am/BatteryStatsService;->noteScreenBrightness(I)V
Lcom/android/server/am/BatteryStatsService;->noteScreenState(I)V
Lcom/android/server/am/BatteryStatsService;->noteStartAudio(I)V
Lcom/android/server/am/BatteryStatsService;->noteStartCamera(I)V
Lcom/android/server/am/BatteryStatsService;->noteStartGps(I)V
Lcom/android/server/am/BatteryStatsService;->noteStartSensor(II)V
Lcom/android/server/am/BatteryStatsService;->noteStartVideo(I)V
Lcom/android/server/am/BatteryStatsService;->noteStartWakelock(IILjava/lang/String;Ljava/lang/String;IZ)V
Lcom/android/server/am/BatteryStatsService;->noteStartWakelockFromSource(Landroid/os/WorkSource;ILjava/lang/String;Ljava/lang/String;IZ)V
Lcom/android/server/am/BatteryStatsService;->noteStopAudio(I)V
Lcom/android/server/am/BatteryStatsService;->noteStopCamera(I)V
Lcom/android/server/am/BatteryStatsService;->noteStopGps(I)V
Lcom/android/server/am/BatteryStatsService;->noteStopSensor(II)V
Lcom/android/server/am/BatteryStatsService;->noteStopVideo(I)V
Lcom/android/server/am/BatteryStatsService;->noteStopWakelock(IILjava/lang/String;Ljava/lang/String;I)V
Lcom/android/server/am/BatteryStatsService;->noteStopWakelockFromSource(Landroid/os/WorkSource;ILjava/lang/String;Ljava/lang/String;I)V
Lcom/android/server/am/BatteryStatsService;->noteSyncFinish(Ljava/lang/String;I)V
Lcom/android/server/am/BatteryStatsService;->noteSyncStart(Ljava/lang/String;I)V
Lcom/android/server/am/BatteryStatsService;->noteUserActivity(II)V
Lcom/android/server/am/BatteryStatsService;->noteVibratorOff(I)V
Lcom/android/server/am/BatteryStatsService;->noteVibratorOn(IJ)V
Lcom/android/server/am/BatteryStatsService;->noteWakeUp(Ljava/lang/String;I)V
Lcom/android/server/am/BatteryStatsService;->noteWifiBatchedScanStartedFromSource(Landroid/os/WorkSource;I)V
Lcom/android/server/am/BatteryStatsService;->noteWifiBatchedScanStoppedFromSource(Landroid/os/WorkSource;)V
Lcom/android/server/am/BatteryStatsService;->noteWifiControllerActivity(Landroid/net/wifi/WifiActivityEnergyInfo;)V
Lcom/android/server/am/BatteryStatsService;->noteWifiMulticastDisabled(I)V
Lcom/android/server/am/BatteryStatsService;->noteWifiMulticastDisabledFromSource(Landroid/os/WorkSource;)V
Lcom/android/server/am/BatteryStatsService;->noteWifiMulticastEnabled(I)V
Lcom/android/server/am/BatteryStatsService;->noteWifiMulticastEnabledFromSource(Landroid/os/WorkSource;)V
Lcom/android/server/am/BatteryStatsService;->noteWifiOff()V
Lcom/android/server/am/BatteryStatsService;->noteWifiOn()V
Lcom/android/server/am/BatteryStatsService;->noteWifiRadioPowerState(IJI)V
Lcom/android/server/am/BatteryStatsService;->noteWifiRssiChanged(I)V
Lcom/android/server/am/BatteryStatsService;->noteWifiRunning(Landroid/os/WorkSource;)V
Lcom/android/server/am/BatteryStatsService;->noteWifiRunningChanged(Landroid/os/WorkSource;Landroid/os/WorkSource;)V
Lcom/android/server/am/BatteryStatsService;->noteWifiScanStarted(I)V
Lcom/android/server/am/BatteryStatsService;->noteWifiScanStartedFromSource(Landroid/os/WorkSource;)V
Lcom/android/server/am/BatteryStatsService;->noteWifiScanStopped(I)V
Lcom/android/server/am/BatteryStatsService;->noteWifiScanStoppedFromSource(Landroid/os/WorkSource;)V
Lcom/android/server/am/BatteryStatsService;->noteWifiState(ILjava/lang/String;)V
Lcom/android/server/am/BatteryStatsService;->noteWifiStopped(Landroid/os/WorkSource;)V
Lcom/android/server/am/BatteryStatsService;->noteWifiSupplicantStateChanged(IZ)V
Lcom/android/server/am/BatteryStatsService;->setBatteryState(IIIIIII)V
Lcom/android/server/am/BatteryStatsService;->takeUidSnapshot(I)Landroid/os/health/HealthStatsParceler;
Lcom/android/server/am/BatteryStatsService;->takeUidSnapshots([I)[Landroid/os/health/HealthStatsParceler;
Lcom/android/server/am/PendingIntentRecord;->send(ILandroid/content/Intent;Ljava/lang/String;Landroid/content/IIntentReceiver;Ljava/lang/String;Landroid/os/Bundle;)V
Lcom/android/server/am/ProcessStatsService;->getCurrentStats(Ljava/util/List;)[B
Lcom/android/server/am/ProcessStatsService;->getStatsOverTime(J)Landroid/os/ParcelFileDescriptor;
Lcom/android/server/AppOpsService;->checkAudioOperation(IIILjava/lang/String;)I
Lcom/android/server/AppOpsService;->checkOperation(IILjava/lang/String;)I
Lcom/android/server/AppOpsService;->finishOperation(Landroid/os/IBinder;IILjava/lang/String;)V
Lcom/android/server/AppOpsService;->getOpsForPackage(ILjava/lang/String;[I)Ljava/util/List;
Lcom/android/server/AppOpsService;->getPackagesForOps([I)Ljava/util/List;
Lcom/android/server/AppOpsService;->noteOperation(IILjava/lang/String;)I
Lcom/android/server/AppOpsService;->resetAllModes(ILjava/lang/String;)V
Lcom/android/server/AppOpsService;->setAudioRestriction(IIIIL[java/lang/String;)V
Lcom/android/server/AppOpsService;->setMode(IILjava/lang/String;I)V
Lcom/android/server/AppOpsService;->setUidMode(III)V
Lcom/android/server/AppOpsService;->setUserRestriction(IZLandroid/os/IBinder;IL[java/lang/String;)V
Lcom/android/server/AppOpsService;->startOperation(Landroid/os/IBinder;IILjava/lang/String;)I
Lcom/android/server/appwidget/AppWidgetServiceImpl;->bindAppWidgetId(Ljava/lang/String;IILandroid/content/ComponentName;Landroid/os/Bundle;)Z
Lcom/android/server/appwidget/AppWidgetServiceImpl;->bindRemoteViewsService(Ljava/lang/String;ILandroid/content/Intent;Landroid/os/IBinder;)V
Lcom/android/server/appwidget/AppWidgetServiceImpl;->createAppWidgetConfigIntentSender(Ljava/lang/String;II)Landroid/content/IntentSender;
Lcom/android/server/appwidget/AppWidgetServiceImpl;->deleteAppWidgetId(Ljava/lang/String;I)V
Lcom/android/server/appwidget/AppWidgetServiceImpl;->getAppWidgetInfo(Ljava/lang/String;I)Landroid/appwidget/AppWidgetProviderInfo;
Lcom/android/server/appwidget/AppWidgetServiceImpl;->getAppWidgetOptions(Ljava/lang/String;I)Landroid/os/Bundle;
Lcom/android/server/appwidget/AppWidgetServiceImpl;->getAppWidgetViews(Ljava/lang/String;I)Landroid/widget/RemoteViews;
Lcom/android/server/appwidget/AppWidgetServiceImpl;->hasBindAppWidgetPermission(Ljava/lang/String;I)Z
Lcom/android/server/appwidget/AppWidgetServiceImpl;->notifyAppWidgetViewDataChanged(Ljava/lang/String;[II)V
Lcom/android/server/appwidget/AppWidgetServiceImpl;->partiallyUpdateAppWidgetIds(Ljava/lang/String;[ILandroid/widget/RemoteViews;)V
Lcom/android/server/appwidget/AppWidgetServiceImpl;->setBindAppWidgetPermission(Ljava/lang/String;IZ)V
Lcom/android/server/appwidget/AppWidgetServiceImpl;->unbindRemoteViewsService(Ljava/lang/String;ILandroid/content/Intent;)V
Lcom/android/server/appwidget/AppWidgetServiceImpl;->updateAppWidgetIds(Ljava/lang/String;[ILandroid/widget/RemoteViews;)V
Lcom/android/server/appwidget/AppWidgetServiceImpl;->updateAppWidgetOptions(Ljava/lang/String;ILandroid/os/Bundle;)V
Lcom/android/server/audio/AudioService;->disableSafeMediaVolume(Ljava/lang/String;)V
Lcom/android/server/audio/AudioService;->forceRemoteSubmixFullVolume(ZLandroid/os/IBinder;)V
Lcom/android/server/audio/AudioService;->notifyVolumeControllerVisible(Landroid/media/IVolumeController;Z)V
Lcom/android/server/audio/AudioService;->registerAudioPolicy(Landroid/media/audiopolicy/AudioPolicyConfig;Landroid/media/audiopolicy/IAudioPolicyCallback;Z)Ljava/lang/String;
Lcom/android/server/audio/AudioService;->requestAudioFocus(Landroid/media/AudioAttributes;ILandroid/os/IBinder;Landroid/media/IAudioFocusDispatcher;Ljava/lang/String;Ljava/lang/String;ILandroid/media/audiopolicy/IAudioPolicyCallback;)I
Lcom/android/server/audio/AudioService;->setBluetoothScoOn(Z)V
Lcom/android/server/audio/AudioService;->setFocusPropertiesForPolicy(ILandroid/media/audiopolicy/IAudioPolicyCallback;)I
Lcom/android/server/audio/AudioService;->setMasterMute(ZILjava/lang/String;I)V
Lcom/android/server/audio/AudioService;->setMicrophoneMute(ZLjava/lang/String;I)V
Lcom/android/server/audio/AudioService;->setMode(ILandroid/os/IBinder;Ljava/lang/String;)V
Lcom/android/server/audio/AudioService;->setRingerModeInternal(ILjava/lang/String;)V
Lcom/android/server/audio/AudioService;->setRingtonePlayer(Landroid/media/IRingtonePlayer;)V
Lcom/android/server/audio/AudioService;->setSpeakerphoneOn(Z)V
Lcom/android/server/audio/AudioService;->setVolumeController(Landroid/media/IVolumeController;)V
Lcom/android/server/audio/AudioService;->setVolumePolicy(Landroid/media/VolumePolicy;)V
Lcom/android/server/audio/AudioService;->startBluetoothSco(Landroid/os/IBinder;I)V
Lcom/android/server/audio/AudioService;->startBluetoothScoVirtualCall(Landroid/os/IBinder;)V
Lcom/android/server/audio/AudioService;->stopBluetoothSco(Landroid/os/IBinder;)V
Lcom/android/server/backup/BackupManagerService$ActiveRestoreSession;->getAvailableRestoreSets(Landroid/app/backup/IRestoreObserver;)I
Lcom/android/server/backup/BackupManagerService$ActiveRestoreSession;->restoreAll(JLandroid/app/backup/IRestoreObserver;)I
Lcom/android/server/backup/BackupManagerService$ActiveRestoreSession;->restorePackage(Ljava/lang/String;Landroid/app/backup/IRestoreObserver;)I
Lcom/android/server/backup/BackupManagerService$ActiveRestoreSession;->restoreSome(JLandroid/app/backup/IRestoreObserver;L[java/lang/String;)I
Lcom/android/server/backup/Trampoline;->acknowledgeFullBackupOrRestore(IZLjava/lang/String;Ljava/lang/String;Landroid/app/backup/IFullBackupRestoreObserver;)V
Lcom/android/server/backup/Trampoline;->backupNow()V
Lcom/android/server/backup/Trampoline;->beginRestoreSession(Ljava/lang/String;Ljava/lang/String;)Landroid/app/backup/IRestoreSession;
Lcom/android/server/backup/Trampoline;->clearBackupData(Ljava/lang/String;Ljava/lang/String;)V
Lcom/android/server/backup/Trampoline;->dataChanged(Ljava/lang/String;)V
Lcom/android/server/backup/Trampoline;->fullBackup(Landroid/os/ParcelFileDescriptor;ZZZZZZZL[java/lang/String;)V
Lcom/android/server/backup/Trampoline;->fullRestore(Landroid/os/ParcelFileDescriptor;)V
Lcom/android/server/backup/Trampoline;->fullTransportBackup(L[java/lang/String;)V
Lcom/android/server/backup/Trampoline;->getAvailableRestoreToken(Ljava/lang/String;)J
Lcom/android/server/backup/Trampoline;->getConfigurationIntent(Ljava/lang/String;)Landroid/content/Intent;
Lcom/android/server/backup/Trampoline;->getCurrentTransport()Ljava/lang/String;
Lcom/android/server/backup/Trampoline;->getDataManagementIntent(Ljava/lang/String;)Landroid/content/Intent;
Lcom/android/server/backup/Trampoline;->getDataManagementLabel(Ljava/lang/String;)Ljava/lang/String;
Lcom/android/server/backup/Trampoline;->getDestinationString(Ljava/lang/String;)Ljava/lang/String;
Lcom/android/server/backup/Trampoline;->hasBackupPassword()Z
Lcom/android/server/backup/Trampoline;->isAppEligibleForBackup(Ljava/lang/String;)Z
Lcom/android/server/backup/Trampoline;->isBackupEnabled()Z
Lcom/android/server/backup/Trampoline;->listAllTransports()[Ljava/lang/String;
Lcom/android/server/backup/Trampoline;->requestBackup(L[java/lang/String;Landroid/app/backup/IBackupObserver;)I
Lcom/android/server/backup/Trampoline;->restoreAtInstall(Ljava/lang/String;I)V
Lcom/android/server/backup/Trampoline;->selectBackupTransport(Ljava/lang/String;)Ljava/lang/String;
Lcom/android/server/backup/Trampoline;->setAutoRestore(Z)V
Lcom/android/server/backup/Trampoline;->setBackupEnabled(Z)V
Lcom/android/server/backup/Trampoline;->setBackupPassword(Ljava/lang/String;Ljava/lang/String;)Z
Lcom/android/server/backup/Trampoline;->setBackupProvisioned(Z)V
Lcom/android/server/BluetoothManagerService;->disable(Z)Z
Lcom/android/server/BluetoothManagerService;->enable()Z
Lcom/android/server/BluetoothManagerService;->enableNoAutoConnect()Z
Lcom/android/server/BluetoothManagerService;->getAddress()Ljava/lang/String;
Lcom/android/server/BluetoothManagerService;->getName()Ljava/lang/String;
Lcom/android/server/BluetoothManagerService;->registerStateChangeCallback(Landroid/bluetooth/IBluetoothStateChangeCallback;)V
Lcom/android/server/BluetoothManagerService;->unregisterAdapter(Landroid/bluetooth/IBluetoothManagerCallback;)V
Lcom/android/server/BluetoothManagerService;->unregisterStateChangeCallback(Landroid/bluetooth/IBluetoothStateChangeCallback;)V
Lcom/android/server/connectivity/IpConnectivityMetrics$Impl;->logEvent(Landroid/net/ConnectivityMetricsEvent;)I
Lcom/android/server/connectivity/MetricsLoggerService$MetricsLoggerImpl;->getEvents(Landroid/net/ConnectivityMetricsEvent$Reference;)[Landroid/net/ConnectivityMetricsEvent;
Lcom/android/server/connectivity/MetricsLoggerService$MetricsLoggerImpl;->logEvent(Landroid/net/ConnectivityMetricsEvent;)J
Lcom/android/server/connectivity/MetricsLoggerService$MetricsLoggerImpl;->logEvents(L[android/net/ConnectivityMetricsEvent;)J
Lcom/android/server/connectivity/MetricsLoggerService$MetricsLoggerImpl;->register(Landroid/app/PendingIntent;)Z
Lcom/android/server/connectivity/MetricsLoggerService$MetricsLoggerImpl;->unregister(Landroid/app/PendingIntent;)V
Lcom/android/server/ConnectivityService;->factoryReset()V
Lcom/android/server/ConnectivityService;->getActiveLinkProperties()Landroid/net/LinkProperties;
Lcom/android/server/ConnectivityService;->getActiveNetwork()Landroid/net/Network;
Lcom/android/server/ConnectivityService;->getActiveNetworkForUid(IZ)Landroid/net/Network;
Lcom/android/server/ConnectivityService;->getActiveNetworkInfo()Landroid/net/NetworkInfo;
Lcom/android/server/ConnectivityService;->getActiveNetworkInfoForUid(IZ)Landroid/net/NetworkInfo;
Lcom/android/server/ConnectivityService;->getActiveNetworkQuotaInfo()Landroid/net/NetworkQuotaInfo;
Lcom/android/server/ConnectivityService;->getAllNetworkInfo()[Landroid/net/NetworkInfo;
Lcom/android/server/ConnectivityService;->getAllNetworks()[Landroid/net/Network;
Lcom/android/server/ConnectivityService;->getAllNetworkState()[Landroid/net/NetworkState;
Lcom/android/server/ConnectivityService;->getAllVpnInfo()[Lcom/android/Iernal/net/VpnInfo;
Lcom/android/server/ConnectivityService;->getAlwaysOnVpnPackage(I)Ljava/lang/String;
Lcom/android/server/ConnectivityService;->getDefaultNetworkCapabilitiesForUser(I)[Landroid/net/NetworkCapabilities;
Lcom/android/server/ConnectivityService;->getLastTetherError(Ljava/lang/String;)I
Lcom/android/server/ConnectivityService;->getLegacyVpnInfo(I)Lcom/android/Iernal/net/LegacyVpnInfo;
Lcom/android/server/ConnectivityService;->getLinkProperties(Landroid/net/Network;)Landroid/net/LinkProperties;
Lcom/android/server/ConnectivityService;->getLinkPropertiesForType(I)Landroid/net/LinkProperties;
Lcom/android/server/ConnectivityService;->getMobileProvisioningUrl()Ljava/lang/String;
Lcom/android/server/ConnectivityService;->getNetworkCapabilities(Landroid/net/Network;)Landroid/net/NetworkCapabilities;
Lcom/android/server/ConnectivityService;->getNetworkForType(I)Landroid/net/Network;
Lcom/android/server/ConnectivityService;->getNetworkInfo(I)Landroid/net/NetworkInfo;
Lcom/android/server/ConnectivityService;->getNetworkInfoForUid(Landroid/net/Network;IZ)Landroid/net/NetworkInfo;
Lcom/android/server/ConnectivityService;->getTetherableBluetoothRegexs()[Ljava/lang/String;
Lcom/android/server/ConnectivityService;->getTetherableIfaces()[Ljava/lang/String;
Lcom/android/server/ConnectivityService;->getTetherableUsbRegexs()[Ljava/lang/String;
Lcom/android/server/ConnectivityService;->getTetherableWifiRegexs()[Ljava/lang/String;
Lcom/android/server/ConnectivityService;->getTetheredDhcpRanges()[Ljava/lang/String;
Lcom/android/server/ConnectivityService;->getTetheredIfaces()[Ljava/lang/String;
Lcom/android/server/ConnectivityService;->getTetheringErroredIfaces()[Ljava/lang/String;
Lcom/android/server/ConnectivityService;->getVpnConfig(I)Lcom/android/Iernal/net/VpnConfig;
Lcom/android/server/ConnectivityService;->isActiveNetworkMetered()Z
Lcom/android/server/ConnectivityService;->isNetworkSupported(I)Z
Lcom/android/server/ConnectivityService;->isTetheringSupported()Z
Lcom/android/server/ConnectivityService;->listenForNetwork(Landroid/net/NetworkCapabilities;Landroid/os/Messenger;Landroid/os/IBinder;)Landroid/net/NetworkRequest;
Lcom/android/server/ConnectivityService;->pendingListenForNetwork(Landroid/net/NetworkCapabilities;Landroid/app/PendingIntent;)V
Lcom/android/server/ConnectivityService;->pendingRequestForNetwork(Landroid/net/NetworkCapabilities;Landroid/app/PendingIntent;)Landroid/net/NetworkRequest;
Lcom/android/server/ConnectivityService;->prepareVpn(Ljava/lang/String;Ljava/lang/String;I)Z
Lcom/android/server/ConnectivityService;->registerNetworkAgent(Landroid/os/Messenger;Landroid/net/NetworkInfo;Landroid/net/LinkProperties;Landroid/net/NetworkCapabilities;ILandroid/net/NetworkMisc;)I
Lcom/android/server/ConnectivityService;->registerNetworkFactory(Landroid/os/Messenger;Ljava/lang/String;)V
Lcom/android/server/ConnectivityService;->reportInetCondition(II)V
Lcom/android/server/ConnectivityService;->reportNetworkConnectivity(Landroid/net/Network;Z)V
Lcom/android/server/ConnectivityService;->requestBandwidthUpdate(Landroid/net/Network;)Z
Lcom/android/server/ConnectivityService;->requestNetwork(Landroid/net/NetworkCapabilities;Landroid/os/Messenger;ILandroid/os/IBinder;I)Landroid/net/NetworkRequest;
Lcom/android/server/ConnectivityService;->requestRouteToHostAddress(I[B)Z
Lcom/android/server/ConnectivityService;->setAcceptUnvalidated(Landroid/net/Network;ZZ)V
Lcom/android/server/ConnectivityService;->setAirplaneMode(Z)V
Lcom/android/server/ConnectivityService;->setAlwaysOnVpnPackage(ILjava/lang/String;Z)Z
Lcom/android/server/ConnectivityService;->setAVUnvalidated(Landroid/net/Network;)V
Lcom/android/server/ConnectivityService;->setGlobalProxy(Landroid/net/ProxyInfo;)V
Lcom/android/server/ConnectivityService;->setProvisioningNotificationVisible(ZILjava/lang/String;)V
Lcom/android/server/ConnectivityService;->setUsbTethering(Z)I
Lcom/android/server/ConnectivityService;->setVpnPackageAuthorization(Ljava/lang/String;IZ)V
Lcom/android/server/ConnectivityService;->startLegacyVpn(Lcom/android/Iernal/net/VpnProfile;)V
Lcom/android/server/ConnectivityService;->startNattKeepalive(Landroid/net/Network;ILandroid/os/Messenger;Landroid/os/IBinder;Ljava/lang/String;ILjava/lang/String;)V
Lcom/android/server/ConnectivityService;->startTethering(ILandroid/os/ResultReceiver;Z)V
Lcom/android/server/ConnectivityService;->stopTethering(I)V
Lcom/android/server/ConnectivityService;->tether(Ljava/lang/String;)I
Lcom/android/server/ConnectivityService;->unregisterNetworkFactory(Landroid/os/Messenger;)V
Lcom/android/server/ConnectivityService;->untether(Ljava/lang/String;)I
Lcom/android/server/ConnectivityService;->updateLockdownVpn()Z
Lcom/android/server/ConsumerIrService;->getCarrierFrequencies()[I
Lcom/android/server/ConsumerIrService;->transmit(Ljava/lang/String;I[I)V
Lcom/android/server/content/ContentService;->addPeriodicSync(Landroid/accounts/Account;Ljava/lang/String;Landroid/os/Bundle;J)V
Lcom/android/server/content/ContentService;->cancelSync(Landroid/accounts/Account;Ljava/lang/String;Landroid/content/ComponentName;)V
Lcom/android/server/content/ContentService;->cancelSyncAsUser(Landroid/accounts/Account;Ljava/lang/String;Landroid/content/ComponentName;I)V
Lcom/android/server/content/ContentService;->getCache(Ljava/lang/String;Landroid/net/Uri;I)Landroid/os/Bundle;
Lcom/android/server/content/ContentService;->getCurrentSyncs()Ljava/util/List;
Lcom/android/server/content/ContentService;->getCurrentSyncsAsUser(I)Ljava/util/List;
Lcom/android/server/content/ContentService;->getIsSyncable(Landroid/accounts/Account;Ljava/lang/String;)I
Lcom/android/server/content/ContentService;->getIsSyncableAsUser(Landroid/accounts/Account;Ljava/lang/String;I)I
Lcom/android/server/content/ContentService;->getMasterSyncAutomatically()Z
Lcom/android/server/content/ContentService;->getMasterSyncAutomaticallyAsUser(I)Z
Lcom/android/server/content/ContentService;->getPeriodicSyncs(Landroid/accounts/Account;Ljava/lang/String;Landroid/content/ComponentName;)Ljava/util/List;
Lcom/android/server/content/ContentService;->getSyncAdapterPackagesForAuthorityAsUser(Ljava/lang/String;I)[Ljava/lang/String;
Lcom/android/server/content/ContentService;->getSyncAdapterTypes()[Landroid/content/SyncAdapterType;
Lcom/android/server/content/ContentService;->getSyncAdapterTypesAsUser(I)[Landroid/content/SyncAdapterType;
Lcom/android/server/content/ContentService;->getSyncAutomatically(Landroid/accounts/Account;Ljava/lang/String;)Z
Lcom/android/server/content/ContentService;->getSyncAutomaticallyAsUser(Landroid/accounts/Account;Ljava/lang/String;I)Z
Lcom/android/server/content/ContentService;->getSyncStatus(Landroid/accounts/Account;Ljava/lang/String;Landroid/content/ComponentName;)Landroid/content/SyncStatusInfo;
Lcom/android/server/content/ContentService;->getSyncStatusAsUser(Landroid/accounts/Account;Ljava/lang/String;Landroid/content/ComponentName;I)Landroid/content/SyncStatusInfo;
Lcom/android/server/content/ContentService;->isSyncActive(Landroid/accounts/Account;Ljava/lang/String;Landroid/content/ComponentName;)Z
Lcom/android/server/content/ContentService;->isSyncPending(Landroid/accounts/Account;Ljava/lang/String;Landroid/content/ComponentName;)Z
Lcom/android/server/content/ContentService;->isSyncPendingAsUser(Landroid/accounts/Account;Ljava/lang/String;Landroid/content/ComponentName;I)Z
Lcom/android/server/content/ContentService;->putCache(Ljava/lang/String;Landroid/net/Uri;Landroid/os/Bundle;I)V
Lcom/android/server/content/ContentService;->registerContentObserver(Landroid/net/Uri;ZLandroid/database/IContentObserver;I)V
Lcom/android/server/content/ContentService;->removePeriodicSync(Landroid/accounts/Account;Ljava/lang/String;Landroid/os/Bundle;)V
Lcom/android/server/content/ContentService;->setIsSyncable(Landroid/accounts/Account;Ljava/lang/String;I)V
Lcom/android/server/content/ContentService;->setMasterSyncAutomatically(Z)V
Lcom/android/server/content/ContentService;->setMasterSyncAutomaticallyAsUser(ZI)V
Lcom/android/server/content/ContentService;->setSyncAutomatically(Landroid/accounts/Account;Ljava/lang/String;Z)V
Lcom/android/server/content/ContentService;->setSyncAutomaticallyAsUser(Landroid/accounts/Account;Ljava/lang/String;ZI)V
Lcom/android/server/content/ContentService;->sync(Landroid/content/SyncRequest;)V
Lcom/android/server/content/ContentService;->syncAsUser(Landroid/content/SyncRequest;I)V
Lcom/android/server/DeviceIdleController$BinderService;->addPowerSaveTempWhitelistApp(Ljava/lang/String;JILjava/lang/String;)V
Lcom/android/server/DeviceIdleController$BinderService;->addPowerSaveTempWhitelistAppForMms(Ljava/lang/String;ILjava/lang/String;)J
Lcom/android/server/DeviceIdleController$BinderService;->addPowerSaveTempWhitelistAppForSms(Ljava/lang/String;ILjava/lang/String;)J
Lcom/android/server/DeviceIdleController$BinderService;->addPowerSaveWhitelistApp(Ljava/lang/String;)V
Lcom/android/server/DeviceIdleController$BinderService;->exitIdle(Ljava/lang/String;)V
Lcom/android/server/DeviceIdleController$BinderService;->removePowerSaveWhitelistApp(Ljava/lang/String;)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->addCrossProfileIntentFilter(Landroid/content/ComponentName;Landroid/content/IntentFilter;I)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->addCrossProfileWidgetProvider(Landroid/content/ComponentName;Ljava/lang/String;)Z
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->addPersistentPreferredActivity(Landroid/content/ComponentName;Landroid/content/IntentFilter;Landroid/content/ComponentName;)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->approveCaCert(Ljava/lang/String;IZ)Z
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->choosePrivateKeyAlias(ILandroid/net/Uri;Ljava/lang/String;Landroid/os/IBinder;)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->clearCrossProfileIntentFilters(Landroid/content/ComponentName;)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->clearDeviceOwner(Ljava/lang/String;)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->clearPackagePersistentPreferredActivities(Landroid/content/ComponentName;Ljava/lang/String;)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->clearProfileOwner(Landroid/content/ComponentName;)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->createAndManageUser(Landroid/content/ComponentName;Ljava/lang/String;Landroid/content/ComponentName;Landroid/os/PersistableBundle;I)Landroid/os/UserHandle;
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->enableSystemApp(Landroid/content/ComponentName;Ljava/lang/String;)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->enableSystemAppWithIntent(Landroid/content/ComponentName;Landroid/content/Intent;)I
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->enforceCanManageCaCerts(Landroid/content/ComponentName;)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->forceRemoveActiveAdmin(Landroid/content/ComponentName;I)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getAccountTypesWithManagementDisabled()[Ljava/lang/String;
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getAccountTypesWithManagementDisabledAsUser(I)[Ljava/lang/String;
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getActiveAdmins(I)Ljava/util/List;
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getAlwaysOnVpnPackage(Landroid/content/ComponentName;)Ljava/lang/String;
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getApplicationRestrictions(Landroid/content/ComponentName;Ljava/lang/String;)Landroid/os/Bundle;
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getApplicationRestrictionsManagingPackage(Landroid/content/ComponentName;)Ljava/lang/String;
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getAutoTimeRequired()Z
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getBluetoothContactSharingDisabled(Landroid/content/ComponentName;)Z
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getBluetoothContactSharingDisabledForUser(I)Z
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getCameraDisabled(Landroid/content/ComponentName;I)Z
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getCertInstallerPackage(Landroid/content/ComponentName;)Ljava/lang/String;
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getCrossProfileCallerIdDisabled(Landroid/content/ComponentName;)Z
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getCrossProfileCallerIdDisabledForUser(I)Z
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getCrossProfileContactsSearchDisabled(Landroid/content/ComponentName;)Z
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getCrossProfileContactsSearchDisabledForUser(I)Z
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getCrossProfileWidgetProviders(Landroid/content/ComponentName;)Ljava/util/List;
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getCurrentFailedPasswordAttempts(IZ)I
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getDeviceOwnerComponent(Z)Landroid/content/ComponentName;
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getDeviceOwnerName()Ljava/lang/String;
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getDeviceOwnerUserId()I
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getDoNotAskCredentialsOnBoot()Z
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getForceEphemeralUsers(Landroid/content/ComponentName;)Z
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getGlobalProxyAdmin(I)Landroid/content/ComponentName;
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getKeepUninstalledPackages(Landroid/content/ComponentName;)Ljava/util/List;
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getKeyguardDisabledFeatures(Landroid/content/ComponentName;IZ)I
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getLockTaskPackages(Landroid/content/ComponentName;)[Ljava/lang/String;
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getLongSupportMessage(Landroid/content/ComponentName;)Ljava/lang/CharSequence;
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getLongSupportMessageForUser(Landroid/content/ComponentName;I)Ljava/lang/CharSequence;
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getMaximumFailedPasswordsForWipe(Landroid/content/ComponentName;IZ)I
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getMaximumTimeToLock(Landroid/content/ComponentName;IZ)J
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getMaximumTimeToLockForUserAndProfiles(I)J
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getOrganizationColor(Landroid/content/ComponentName;)I
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getOrganizationColorForUser(I)I
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getOrganizationName(Landroid/content/ComponentName;)Ljava/lang/CharSequence;
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getOrganizationNameForUser(I)Ljava/lang/CharSequence;
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getPasswordExpiration(Landroid/content/ComponentName;IZ)J
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getPasswordExpirationTimeout(Landroid/content/ComponentName;IZ)J
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getPasswordHistoryLength(Landroid/content/ComponentName;IZ)I
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getPasswordMinimumLength(Landroid/content/ComponentName;IZ)I
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getPasswordMinimumLetters(Landroid/content/ComponentName;IZ)I
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getPasswordMinimumLowerCase(Landroid/content/ComponentName;IZ)I
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getPasswordMinimumNonLetter(Landroid/content/ComponentName;IZ)I
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getPasswordMinimumNumeric(Landroid/content/ComponentName;IZ)I
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getPasswordMinimumSymbols(Landroid/content/ComponentName;IZ)I
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getPasswordMinimumUpperCase(Landroid/content/ComponentName;IZ)I
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getPasswordQuality(Landroid/content/ComponentName;IZ)I
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getPermissionGrantState(Landroid/content/ComponentName;Ljava/lang/String;Ljava/lang/String;)I
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getPermissionPolicy(Landroid/content/ComponentName;)I
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getPermittedAccessibilityServices(Landroid/content/ComponentName;)Ljava/util/List;
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getPermittedAccessibilityServicesForUser(I)Ljava/util/List;
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getPermittedInputMethods(Landroid/content/ComponentName;)Ljava/util/List;
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getPermittedInputMethodsForCurrentUser()Ljava/util/List;
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getProfileOwnerName(I)Ljava/lang/String;
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getProfileWithMinimumFailedPasswordsForWipe(IZ)I
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getRemoveWarning(Landroid/content/ComponentName;Landroid/os/RemoteCallback;I)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getRequiredStrongAuthTimeout(Landroid/content/ComponentName;IZ)J
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getRestrictionsProvider(I)Landroid/content/ComponentName;
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getScreenCaptureDisabled(Landroid/content/ComponentName;I)Z
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getShortSupportMessage(Landroid/content/ComponentName;)Ljava/lang/CharSequence;
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getShortSupportMessageForUser(Landroid/content/ComponentName;I)Ljava/lang/CharSequence;
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getStorageEncryption(Landroid/content/ComponentName;I)Z
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getStorageEncryptionStatus(Ljava/lang/String;I)I
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getTrustAgentConfiguration(Landroid/content/ComponentName;Landroid/content/ComponentName;IZ)Ljava/util/List;
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getUserProvisioningState()I
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getUserRestrictions(Landroid/content/ComponentName;)Landroid/os/Bundle;
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->getWifiMacAddress(Landroid/content/ComponentName;)Ljava/lang/String;
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->hasGrantedPolicy(Landroid/content/ComponentName;II)Z
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->hasUserSetupCompleted()Z
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->installCaCert(Landroid/content/ComponentName;[B)Z
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->installKeyPair(Landroid/content/ComponentName;[B[B[BLjava/lang/String;Z)Z
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->isAccessibilityServicePermittedByAdmin(Landroid/content/ComponentName;Ljava/lang/String;I)Z
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->isActivePasswordSufficient(IZ)Z
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->isAdminActive(Landroid/content/ComponentName;I)Z
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->isAffiliatedUser()Z
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->isApplicationHidden(Landroid/content/ComponentName;Ljava/lang/String;)Z
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->isBackupServiceEnabled(Landroid/content/ComponentName;)Z
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->isCaCertApproved(Ljava/lang/String;I)Z
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->isCallerApplicationRestrictionsManagingPackage()Z
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->isDeviceProvisioningConfigApplied()Z
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->isInputMethodPermittedByAdmin(Landroid/content/ComponentName;Ljava/lang/String;I)Z
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->isLockTaskPermitted(Ljava/lang/String;)Z
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->isManagedProfile(Landroid/content/ComponentName;)Z
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->isMasterVolumeMuted(Landroid/content/ComponentName;)Z
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->isPackageSuspended(Landroid/content/ComponentName;Ljava/lang/String;)Z
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->isProfileActivePasswordSufficientForParent(I)Z
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->isProvisioningAllowed(Ljava/lang/String;)Z
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->isRemovingAdmin(Landroid/content/ComponentName;I)Z
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->isSecurityLoggingEnabled(Landroid/content/ComponentName;)Z
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->isSystemOnlyUser(Landroid/content/ComponentName;)Z
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->isUninstallBlocked(Landroid/content/ComponentName;Ljava/lang/String;)Z
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->isUninstallInQueue(Ljava/lang/String;)Z
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->lockNow(Z)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->notifyLockTaskModeChanged(ZLjava/lang/String;I)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->notifyPendingSystemUpdate(J)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->packageHasActiveAdmins(Ljava/lang/String;I)Z
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->reboot(Landroid/content/ComponentName;)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->removeActiveAdmin(Landroid/content/ComponentName;I)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->removeCrossProfileWidgetProvider(Landroid/content/ComponentName;Ljava/lang/String;)Z
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->removeKeyPair(Landroid/content/ComponentName;Ljava/lang/String;)Z
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->removeUser(Landroid/content/ComponentName;Landroid/os/UserHandle;)Z
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->reportFailedFingerprIAttempt(I)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->reportFailedPasswordAttempt(I)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->reportKeyguardDismissed(I)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->reportKeyguardSecured(I)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->reportSuccessfulFingerprIAttempt(I)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->reportSuccessfulPasswordAttempt(I)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->requestBugreport(Landroid/content/ComponentName;)Z
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->resetPassword(Ljava/lang/String;I)Z
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->retrievePreRebootSecurityLogs(Landroid/content/ComponentName;)Landroid/content/pm/ParceledListSlice;
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->retrieveSecurityLogs(Landroid/content/ComponentName;)Landroid/content/pm/ParceledListSlice;
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setAccountManagementDisabled(Landroid/content/ComponentName;Ljava/lang/String;Z)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setActiveAdmin(Landroid/content/ComponentName;ZI)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setActivePasswordState(IIIIIIIII)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setAffiliationIds(Landroid/content/ComponentName;Ljava/util/List;)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setAlwaysOnVpnPackage(Landroid/content/ComponentName;Ljava/lang/String;Z)Z
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setApplicationHidden(Landroid/content/ComponentName;Ljava/lang/String;Z)Z
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setApplicationRestrictions(Landroid/content/ComponentName;Ljava/lang/String;Landroid/os/Bundle;)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setApplicationRestrictionsManagingPackage(Landroid/content/ComponentName;Ljava/lang/String;)Z
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setAutoTimeRequired(Landroid/content/ComponentName;Z)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setBackupServiceEnabled(Landroid/content/ComponentName;Z)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setBluetoothContactSharingDisabled(Landroid/content/ComponentName;Z)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setCameraDisabled(Landroid/content/ComponentName;Z)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setCertInstallerPackage(Landroid/content/ComponentName;Ljava/lang/String;)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setCrossProfileCallerIdDisabled(Landroid/content/ComponentName;Z)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setCrossProfileContactsSearchDisabled(Landroid/content/ComponentName;Z)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setDeviceOwner(Landroid/content/ComponentName;Ljava/lang/String;I)Z
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setDeviceOwnerLockScreenInfo(Landroid/content/ComponentName;Ljava/lang/CharSequence;)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setDeviceProvisioningConfigApplied()V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setForceEphemeralUsers(Landroid/content/ComponentName;Z)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setGlobalProxy(Landroid/content/ComponentName;Ljava/lang/String;Ljava/lang/String;)Landroid/content/ComponentName;
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setGlobalSetting(Landroid/content/ComponentName;Ljava/lang/String;Ljava/lang/String;)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setKeepUninstalledPackages(Landroid/content/ComponentName;Ljava/util/List;)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setKeyguardDisabled(Landroid/content/ComponentName;Z)Z
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setKeyguardDisabledFeatures(Landroid/content/ComponentName;IZ)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setLockTaskPackages(Landroid/content/ComponentName;L[java/lang/String;)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setLongSupportMessage(Landroid/content/ComponentName;Ljava/lang/CharSequence;)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setMasterVolumeMuted(Landroid/content/ComponentName;Z)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setMaximumFailedPasswordsForWipe(Landroid/content/ComponentName;IZ)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setMaximumTimeToLock(Landroid/content/ComponentName;JZ)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setOrganizationColor(Landroid/content/ComponentName;I)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setOrganizationColorForUser(II)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setOrganizationName(Landroid/content/ComponentName;Ljava/lang/CharSequence;)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setPackagesSuspended(Landroid/content/ComponentName;L[java/lang/String;Z)[Ljava/lang/String;
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setPasswordExpirationTimeout(Landroid/content/ComponentName;JZ)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setPasswordHistoryLength(Landroid/content/ComponentName;IZ)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setPasswordMinimumLength(Landroid/content/ComponentName;IZ)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setPasswordMinimumLetters(Landroid/content/ComponentName;IZ)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setPasswordMinimumLowerCase(Landroid/content/ComponentName;IZ)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setPasswordMinimumNonLetter(Landroid/content/ComponentName;IZ)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setPasswordMinimumNumeric(Landroid/content/ComponentName;IZ)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setPasswordMinimumSymbols(Landroid/content/ComponentName;IZ)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setPasswordMinimumUpperCase(Landroid/content/ComponentName;IZ)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setPasswordQuality(Landroid/content/ComponentName;IZ)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setPermissionGrantState(Landroid/content/ComponentName;Ljava/lang/String;Ljava/lang/String;I)Z
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setPermissionPolicy(Landroid/content/ComponentName;I)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setPermittedAccessibilityServices(Landroid/content/ComponentName;Ljava/util/List;)Z
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setPermittedInputMethods(Landroid/content/ComponentName;Ljava/util/List;)Z
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setProfileEnabled(Landroid/content/ComponentName;)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setProfileName(Landroid/content/ComponentName;Ljava/lang/String;)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setProfileOwner(Landroid/content/ComponentName;Ljava/lang/String;I)Z
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setRecommendedGlobalProxy(Landroid/content/ComponentName;Landroid/net/ProxyInfo;)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setRequiredStrongAuthTimeout(Landroid/content/ComponentName;JZ)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setRestrictionsProvider(Landroid/content/ComponentName;Landroid/content/ComponentName;)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setScreenCaptureDisabled(Landroid/content/ComponentName;Z)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setSecureSetting(Landroid/content/ComponentName;Ljava/lang/String;Ljava/lang/String;)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setSecurityLoggingEnabled(Landroid/content/ComponentName;Z)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setShortSupportMessage(Landroid/content/ComponentName;Ljava/lang/CharSequence;)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setStatusBarDisabled(Landroid/content/ComponentName;Z)Z
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setStorageEncryption(Landroid/content/ComponentName;Z)I
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setSystemUpdatePolicy(Landroid/content/ComponentName;Landroid/app/admin/SystemUpdatePolicy;)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setTrustAgentConfiguration(Landroid/content/ComponentName;Landroid/content/ComponentName;Landroid/os/PersistableBundle;Z)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setUninstallBlocked(Landroid/content/ComponentName;Ljava/lang/String;Z)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setUserIcon(Landroid/content/ComponentName;Landroid/graphics/Bitmap;)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setUserProvisioningState(II)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->setUserRestriction(Landroid/content/ComponentName;Ljava/lang/String;Z)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->switchUser(Landroid/content/ComponentName;Landroid/os/UserHandle;)Z
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->uninstallCaCerts(Landroid/content/ComponentName;L[java/lang/String;)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->uninstallPackageWithActiveAdmins(Ljava/lang/String;)V
Lcom/android/server/devicepolicy/DevicePolicyManagerService;->wipeData(I)V
Lcom/android/server/display/DisplayManagerService$BinderService;->connectWifiDisplay(Ljava/lang/String;)V
Lcom/android/server/display/DisplayManagerService$BinderService;->createVirtualDisplay(Landroid/hardware/display/IVirtualDisplayCallback;Landroid/media/projection/IMediaProjection;Ljava/lang/String;Ljava/lang/String;IIILandroid/view/Surface;I)I
Lcom/android/server/display/DisplayManagerService$BinderService;->forgetWifiDisplay(Ljava/lang/String;)V
Lcom/android/server/display/DisplayManagerService$BinderService;->pauseWifiDisplay()V
Lcom/android/server/display/DisplayManagerService$BinderService;->renameWifiDisplay(Ljava/lang/String;Ljava/lang/String;)V
Lcom/android/server/display/DisplayManagerService$BinderService;->requestColorMode(II)V
Lcom/android/server/display/DisplayManagerService$BinderService;->resumeWifiDisplay()V
Lcom/android/server/display/DisplayManagerService$BinderService;->startWifiDisplayScan()V
Lcom/android/server/display/DisplayManagerService$BinderService;->stopWifiDisplayScan()V
Lcom/android/server/dreams/DreamManagerService$BinderService;->awaken()V
Lcom/android/server/dreams/DreamManagerService$BinderService;->dream()V
Lcom/android/server/dreams/DreamManagerService$BinderService;->getDefaultDreamComponent()Landroid/content/ComponentName;
Lcom/android/server/dreams/DreamManagerService$BinderService;->getDreamComponents()[Landroid/content/ComponentName;
Lcom/android/server/dreams/DreamManagerService$BinderService;->isDreaming()Z
Lcom/android/server/dreams/DreamManagerService$BinderService;->setDreamComponents(L[android/content/ComponentName;)V
Lcom/android/server/dreams/DreamManagerService$BinderService;->testDream(Landroid/content/ComponentName;)V
Lcom/android/server/ethernet/EthernetServiceImpl;->addListener(Landroid/net/IEthernetServiceListener;)V
Lcom/android/server/ethernet/EthernetServiceImpl;->getConfiguration()Landroid/net/IpConfiguration;
Lcom/android/server/ethernet/EthernetServiceImpl;->isAvailable()Z
Lcom/android/server/ethernet/EthernetServiceImpl;->removeListener(Landroid/net/IEthernetServiceListener;)V
Lcom/android/server/ethernet/EthernetServiceImpl;->setConfiguration(Landroid/net/IpConfiguration;)V
Lcom/android/server/fingerprI/FingerprIService$FingerprIServiceWrapper;->authenticate(Landroid/os/IBinder;JILandroid/hardware/fingerprI/IFingerprIServiceReceiver;ILjava/lang/String;)V
Lcom/android/server/fingerprI/FingerprIService$FingerprIServiceWrapper;->cancelAuthentication(Landroid/os/IBinder;Ljava/lang/String;)V
Lcom/android/server/fingerprI/FingerprIService$FingerprIServiceWrapper;->cancelEnrollment(Landroid/os/IBinder;)V
Lcom/android/server/fingerprI/FingerprIService$FingerprIServiceWrapper;->enroll(Landroid/os/IBinder;[BILandroid/hardware/fingerprI/IFingerprIServiceReceiver;ILjava/lang/String;)V
Lcom/android/server/fingerprI/FingerprIService$FingerprIServiceWrapper;->getEnrolledFingerprIs(ILjava/lang/String;)Ljava/util/List;
Lcom/android/server/fingerprI/FingerprIService$FingerprIServiceWrapper;->hasEnrolledFingerprIs(ILjava/lang/String;)Z
Lcom/android/server/fingerprI/FingerprIService$FingerprIServiceWrapper;->isHardwareDetected(JLjava/lang/String;)Z
Lcom/android/server/fingerprI/FingerprIService$FingerprIServiceWrapper;->postEnroll(Landroid/os/IBinder;)I
Lcom/android/server/fingerprI/FingerprIService$FingerprIServiceWrapper;->preEnroll(Landroid/os/IBinder;)J
Lcom/android/server/fingerprI/FingerprIService$FingerprIServiceWrapper;->remove(Landroid/os/IBinder;IIILandroid/hardware/fingerprI/IFingerprIServiceReceiver;)V
Lcom/android/server/fingerprI/FingerprIService$FingerprIServiceWrapper;->rename(IILjava/lang/String;)V
Lcom/android/server/fingerprI/FingerprIService$FingerprIServiceWrapper;->resetTimeout([B)V
Lcom/android/server/fingerprI/FingerprIService$FingerprIServiceWrapper;->setActiveUser(I)V
Lcom/android/server/hdmi/HdmiControlService$BinderService;->addDeviceEventListener(Landroid/hardware/hdmi/IHdmiDeviceEventListener;)V
Lcom/android/server/hdmi/HdmiControlService$BinderService;->addHdmiMhlVendorCommandListener(Landroid/hardware/hdmi/IHdmiMhlVendorCommandListener;)V
Lcom/android/server/hdmi/HdmiControlService$BinderService;->addHotplugEventListener(Landroid/hardware/hdmi/IHdmiHotplugEventListener;)V
Lcom/android/server/hdmi/HdmiControlService$BinderService;->addSystemAudioModeChangeListener(Landroid/hardware/hdmi/IHdmiSystemAudioModeChangeListener;)V
Lcom/android/server/hdmi/HdmiControlService$BinderService;->addVendorCommandListener(Landroid/hardware/hdmi/IHdmiVendorCommandListener;I)V
Lcom/android/server/hdmi/HdmiControlService$BinderService;->canChangeSystemAudioMode()Z
Lcom/android/server/hdmi/HdmiControlService$BinderService;->clearTimerRecording(II[B)V
Lcom/android/server/hdmi/HdmiControlService$BinderService;->deviceSelect(ILandroid/hardware/hdmi/IHdmiControlCallback;)V
Lcom/android/server/hdmi/HdmiControlService$BinderService;->getActiveSource()Landroid/hardware/hdmi/HdmiDeviceInfo;
Lcom/android/server/hdmi/HdmiControlService$BinderService;->getDeviceList()Ljava/util/List;
Lcom/android/server/hdmi/HdmiControlService$BinderService;->getInputDevices()Ljava/util/List;
Lcom/android/server/hdmi/HdmiControlService$BinderService;->getPortInfo()Ljava/util/List;
Lcom/android/server/hdmi/HdmiControlService$BinderService;->getSupportedTypes()[I
Lcom/android/server/hdmi/HdmiControlService$BinderService;->getSystemAudioMode()Z
Lcom/android/server/hdmi/HdmiControlService$BinderService;->oneTouchPlay(Landroid/hardware/hdmi/IHdmiControlCallback;)V
Lcom/android/server/hdmi/HdmiControlService$BinderService;->portSelect(ILandroid/hardware/hdmi/IHdmiControlCallback;)V
Lcom/android/server/hdmi/HdmiControlService$BinderService;->queryDisplayStatus(Landroid/hardware/hdmi/IHdmiControlCallback;)V
Lcom/android/server/hdmi/HdmiControlService$BinderService;->removeHotplugEventListener(Landroid/hardware/hdmi/IHdmiHotplugEventListener;)V
Lcom/android/server/hdmi/HdmiControlService$BinderService;->removeSystemAudioModeChangeListener(Landroid/hardware/hdmi/IHdmiSystemAudioModeChangeListener;)V
Lcom/android/server/hdmi/HdmiControlService$BinderService;->sendKeyEvent(IIZ)V
Lcom/android/server/hdmi/HdmiControlService$BinderService;->sendMhlVendorCommand(III[B)V
Lcom/android/server/hdmi/HdmiControlService$BinderService;->sendStandby(II)V
Lcom/android/server/hdmi/HdmiControlService$BinderService;->sendVendorCommand(II[BZ)V
Lcom/android/server/hdmi/HdmiControlService$BinderService;->setArcMode(Z)V
Lcom/android/server/hdmi/HdmiControlService$BinderService;->setHdmiRecordListener(Landroid/hardware/hdmi/IHdmiRecordListener;)V
Lcom/android/server/hdmi/HdmiControlService$BinderService;->setInputChangeListener(Landroid/hardware/hdmi/IHdmiInputChangeListener;)V
Lcom/android/server/hdmi/HdmiControlService$BinderService;->setProhibitMode(Z)V
Lcom/android/server/hdmi/HdmiControlService$BinderService;->setSystemAudioMode(ZLandroid/hardware/hdmi/IHdmiControlCallback;)V
Lcom/android/server/hdmi/HdmiControlService$BinderService;->setSystemAudioMute(Z)V
Lcom/android/server/hdmi/HdmiControlService$BinderService;->setSystemAudioVolume(III)V
Lcom/android/server/hdmi/HdmiControlService$BinderService;->startOneTouchRecord(I[B)V
Lcom/android/server/hdmi/HdmiControlService$BinderService;->startTimerRecording(II[B)V
Lcom/android/server/hdmi/HdmiControlService$BinderService;->stopOneTouchRecord(I)V
Lcom/android/server/input/InputManagerService;->addKeyboardLayoutForInputDevice(Landroid/hardware/input/InputDeviceIdentifier;Ljava/lang/String;)V
Lcom/android/server/input/InputManagerService;->isInTabletMode()I
Lcom/android/server/input/InputManagerService;->registerTabletModeChangedListener(Landroid/hardware/input/ITabletModeChangedListener;)V
Lcom/android/server/input/InputManagerService;->removeKeyboardLayoutForInputDevice(Landroid/hardware/input/InputDeviceIdentifier;Ljava/lang/String;)V
Lcom/android/server/input/InputManagerService;->setCurrentKeyboardLayoutForInputDevice(Landroid/hardware/input/InputDeviceIdentifier;Ljava/lang/String;)V
Lcom/android/server/input/InputManagerService;->setKeyboardLayoutForInputDevice(Landroid/hardware/input/InputDeviceIdentifier;Landroid/view/inputmethod/InputMethodInfo;Landroid/view/inputmethod/InputMethodSubtype;Ljava/lang/String;)V
Lcom/android/server/input/InputManagerService;->setTouchCalibrationForInputDevice(Ljava/lang/String;ILandroid/hardware/input/TouchCalibration;)V
Lcom/android/server/input/InputManagerService;->tryPoIerSpeed(I)V
Lcom/android/server/InputMethodManagerService;->addClient(Lcom/android/Iernal/view/IInputMethodClient;Lcom/android/Iernal/view/IInputContext;II)V
Lcom/android/server/InputMethodManagerService;->clearLastInputMethodWindowForTransition(Landroid/os/IBinder;)V
Lcom/android/server/InputMethodManagerService;->createInputContentUriToken(Landroid/os/IBinder;Landroid/net/Uri;Ljava/lang/String;)Lcom/android/Iernal/inputmethod/IInputContentUriToken;
Lcom/android/server/InputMethodManagerService;->getCurrentInputMethodSubtype()Landroid/view/inputmethod/InputMethodSubtype;
Lcom/android/server/InputMethodManagerService;->getEnabledInputMethodList()Ljava/util/List;
Lcom/android/server/InputMethodManagerService;->getEnabledInputMethodSubtypeList(Ljava/lang/String;Z)Ljava/util/List;
Lcom/android/server/InputMethodManagerService;->getInputMethodList()Ljava/util/List;
Lcom/android/server/InputMethodManagerService;->getLastInputMethodSubtype()Landroid/view/inputmethod/InputMethodSubtype;
Lcom/android/server/InputMethodManagerService;->hideMySoftInput(Landroid/os/IBinder;I)V
Lcom/android/server/InputMethodManagerService;->hideSoftInput(Lcom/android/Iernal/view/IInputMethodClient;ILandroid/os/ResultReceiver;)Z
Lcom/android/server/InputMethodManagerService;->notifySuggestionPicked(Landroid/text/style/SuggestionSpan;Ljava/lang/String;I)Z
Lcom/android/server/InputMethodManagerService;->registerSuggestionSpansForNotification(L[android/text/style/SuggestionSpan;)V
Lcom/android/server/InputMethodManagerService;->removeClient(Lcom/android/Iernal/view/IInputMethodClient;)V
Lcom/android/server/InputMethodManagerService;->setAdditionalInputMethodSubtypes(Ljava/lang/String;L[android/view/inputmethod/InputMethodSubtype;)V
Lcom/android/server/InputMethodManagerService;->setCurrentInputMethodSubtype(Landroid/view/inputmethod/InputMethodSubtype;)Z
Lcom/android/server/InputMethodManagerService;->setInputMethod(Landroid/os/IBinder;Ljava/lang/String;)V
Lcom/android/server/InputMethodManagerService;->setInputMethodAndSubtype(Landroid/os/IBinder;Ljava/lang/String;Landroid/view/inputmethod/InputMethodSubtype;)V
Lcom/android/server/InputMethodManagerService;->setInputMethodEnabled(Ljava/lang/String;Z)Z
Lcom/android/server/InputMethodManagerService;->shouldOfferSwitchingToNextInputMethod(Landroid/os/IBinder;)Z
Lcom/android/server/InputMethodManagerService;->showInputMethodAndSubtypeEnablerFromClient(Lcom/android/Iernal/view/IInputMethodClient;Ljava/lang/String;)V
Lcom/android/server/InputMethodManagerService;->showInputMethodPickerFromClient(Lcom/android/Iernal/view/IInputMethodClient;I)V
Lcom/android/server/InputMethodManagerService;->showMySoftInput(Landroid/os/IBinder;I)V
Lcom/android/server/InputMethodManagerService;->showSoftInput(Lcom/android/Iernal/view/IInputMethodClient;ILandroid/os/ResultReceiver;)Z
Lcom/android/server/InputMethodManagerService;->startInputOrWindowGainedFocus(ILcom/android/Iernal/view/IInputMethodClient;Landroid/os/IBinder;IIILandroid/view/inputmethod/EditorInfo;Lcom/android/Iernal/view/IInputContext;I)Lcom/android/Iernal/view/InputBindResult;
Lcom/android/server/InputMethodManagerService;->switchToLastInputMethod(Landroid/os/IBinder;)Z
Lcom/android/server/InputMethodManagerService;->switchToNextInputMethod(Landroid/os/IBinder;Z)Z
Lcom/android/server/job/JobSchedulerService$JobSchedulerStub;->schedule(Landroid/app/job/JobInfo;)I
Lcom/android/server/job/JobSchedulerService$JobSchedulerStub;->scheduleAsPackage(Landroid/app/job/JobInfo;Ljava/lang/String;ILjava/lang/String;)I
Lcom/android/server/LocationManagerService;->addGnssMeasurementsListener(Landroid/location/IGnssMeasurementsListener;Ljava/lang/String;)Z
Lcom/android/server/LocationManagerService;->addGnssNavigationMessageListener(Landroid/location/IGnssNavigationMessageListener;Ljava/lang/String;)Z
Lcom/android/server/LocationManagerService;->getBestProvider(Landroid/location/Criteria;Z)Ljava/lang/String;
Lcom/android/server/LocationManagerService;->getLastLocation(Landroid/location/LocationRequest;Ljava/lang/String;)Landroid/location/Location;
Lcom/android/server/LocationManagerService;->getProviderProperties(Ljava/lang/String;)Lcom/android/Iernal/location/ProviderProperties;
Lcom/android/server/LocationManagerService;->getProviders(Landroid/location/Criteria;Z)Ljava/util/List;
Lcom/android/server/LocationManagerService;->registerGnssStatusCallback(Landroid/location/IGnssStatusListener;Ljava/lang/String;)Z
Lcom/android/server/LocationManagerService;->removeUpdates(Landroid/location/ILocationListener;Landroid/app/PendingIntent;Ljava/lang/String;)V
Lcom/android/server/LocationManagerService;->reportLocation(Landroid/location/Location;Z)V
Lcom/android/server/LocationManagerService;->requestGeofence(Landroid/location/LocationRequest;Landroid/location/Geofence;Landroid/app/PendingIntent;Ljava/lang/String;)V
Lcom/android/server/LocationManagerService;->requestLocationUpdates(Landroid/location/LocationRequest;Landroid/location/ILocationListener;Landroid/app/PendingIntent;Ljava/lang/String;)V
Lcom/android/server/LocationManagerService;->sendExtraCommand(Ljava/lang/String;Ljava/lang/String;Landroid/os/Bundle;)Z
Lcom/android/server/LockSettingsService;->checkPassword(Ljava/lang/String;ILcom/android/Iernal/widget/ICheckCredentialProgressCallback;)Lcom/android/Iernal/widget/VerifyCredentialResponse;
Lcom/android/server/LockSettingsService;->checkPattern(Ljava/lang/String;ILcom/android/Iernal/widget/ICheckCredentialProgressCallback;)Lcom/android/Iernal/widget/VerifyCredentialResponse;
Lcom/android/server/LockSettingsService;->checkVoldPassword(I)Z
Lcom/android/server/LockSettingsService;->getBoolean(Ljava/lang/String;ZI)Z
Lcom/android/server/LockSettingsService;->getLong(Ljava/lang/String;JI)J
Lcom/android/server/LockSettingsService;->getSeparateProfileChallengeEnabled(I)Z
Lcom/android/server/LockSettingsService;->getString(Ljava/lang/String;Ljava/lang/String;I)Ljava/lang/String;
Lcom/android/server/LockSettingsService;->getStrongAuthForUser(I)I
Lcom/android/server/LockSettingsService;->registerStrongAuthTracker(Landroid/app/trust/IStrongAuthTracker;)V
Lcom/android/server/LockSettingsService;->requireStrongAuth(II)V
Lcom/android/server/LockSettingsService;->resetKeyStore(I)V
Lcom/android/server/LockSettingsService;->setBoolean(Ljava/lang/String;ZI)V
Lcom/android/server/LockSettingsService;->setLockPassword(Ljava/lang/String;Ljava/lang/String;I)V
Lcom/android/server/LockSettingsService;->setLockPattern(Ljava/lang/String;Ljava/lang/String;I)V
Lcom/android/server/LockSettingsService;->setLong(Ljava/lang/String;JI)V
Lcom/android/server/LockSettingsService;->setSeparateProfileChallengeEnabled(IZLjava/lang/String;)V
Lcom/android/server/LockSettingsService;->setString(Ljava/lang/String;Ljava/lang/String;I)V
Lcom/android/server/LockSettingsService;->systemReady()V
Lcom/android/server/LockSettingsService;->unregisterStrongAuthTracker(Landroid/app/trust/IStrongAuthTracker;)V
Lcom/android/server/LockSettingsService;->userPresent(I)V
Lcom/android/server/LockSettingsService;->verifyPassword(Ljava/lang/String;JI)Lcom/android/Iernal/widget/VerifyCredentialResponse;
Lcom/android/server/LockSettingsService;->verifyPattern(Ljava/lang/String;JI)Lcom/android/Iernal/widget/VerifyCredentialResponse;
Lcom/android/server/LockSettingsService;->verifyTiedProfileChallenge(Ljava/lang/String;ZJI)Lcom/android/Iernal/widget/VerifyCredentialResponse;
Lcom/android/server/media/MediaRouterService;->registerClientAsUser(Landroid/media/IMediaRouterClient;Ljava/lang/String;I)V
Lcom/android/server/media/MediaSessionRecord$SessionStub;->setFlags(I)V
Lcom/android/server/media/projection/MediaProjectionManagerService$BinderService;->addCallback(Landroid/media/projection/IMediaProjectionWatcherCallback;)V
Lcom/android/server/media/projection/MediaProjectionManagerService$BinderService;->createProjection(ILjava/lang/String;IZ)Landroid/media/projection/IMediaProjection;
Lcom/android/server/media/projection/MediaProjectionManagerService$BinderService;->getActiveProjectionInfo()Landroid/media/projection/MediaProjectionInfo;
Lcom/android/server/media/projection/MediaProjectionManagerService$BinderService;->removeCallback(Landroid/media/projection/IMediaProjectionWatcherCallback;)V
Lcom/android/server/media/projection/MediaProjectionManagerService$BinderService;->stopActiveProjection()V
Lcom/android/server/MmsServiceBroker$BinderService;->downloadMessage(ILjava/lang/String;Ljava/lang/String;Landroid/net/Uri;Landroid/os/Bundle;Landroid/app/PendingIntent;)V
Lcom/android/server/MmsServiceBroker$BinderService;->sendMessage(ILjava/lang/String;Landroid/net/Uri;Ljava/lang/String;Landroid/os/Bundle;Landroid/app/PendingIntent;)V
Lcom/android/server/MountService;->addUserKeyAuth(II[B[B)V
Lcom/android/server/MountService;->benchmark(Ljava/lang/String;)J
Lcom/android/server/MountService;->changeEncryptionPassword(ILjava/lang/String;)I
Lcom/android/server/MountService;->clearPassword()V
Lcom/android/server/MountService;->createSecureContainer(Ljava/lang/String;ILjava/lang/String;Ljava/lang/String;IZ)I
Lcom/android/server/MountService;->createUserKey(IIZ)V
Lcom/android/server/MountService;->decryptStorage(Ljava/lang/String;)I
Lcom/android/server/MountService;->destroySecureContainer(Ljava/lang/String;Z)I
Lcom/android/server/MountService;->destroyUserKey(I)V
Lcom/android/server/MountService;->destroyUserStorage(Ljava/lang/String;II)V
Lcom/android/server/MountService;->encryptStorage(ILjava/lang/String;)I
Lcom/android/server/MountService;->finalizeSecureContainer(Ljava/lang/String;)I
Lcom/android/server/MountService;->fixateNewestUserKeyAuth(I)V
Lcom/android/server/MountService;->fixPermissionsSecureContainer(Ljava/lang/String;ILjava/lang/String;)I
Lcom/android/server/MountService;->forgetAllVolumes()V
Lcom/android/server/MountService;->forgetVolume(Ljava/lang/String;)V
Lcom/android/server/MountService;->format(Ljava/lang/String;)V
Lcom/android/server/MountService;->formatVolume(Ljava/lang/String;)I
Lcom/android/server/MountService;->getEncryptionState()I
Lcom/android/server/MountService;->getField(Ljava/lang/String;)Ljava/lang/String;
Lcom/android/server/MountService;->getPassword()Ljava/lang/String;
Lcom/android/server/MountService;->getPasswordType()I
Lcom/android/server/MountService;->getPrimaryStorageUuid()Ljava/lang/String;
Lcom/android/server/MountService;->getSecureContainerFilesystemPath(Ljava/lang/String;)Ljava/lang/String;
Lcom/android/server/MountService;->getSecureContainerList()[Ljava/lang/String;
Lcom/android/server/MountService;->getSecureContainerPath(Ljava/lang/String;)Ljava/lang/String;
Lcom/android/server/MountService;->getStorageUsers(Ljava/lang/String;)[I
Lcom/android/server/MountService;->isConvertibleToFBE()Z
Lcom/android/server/MountService;->isSecureContainerMounted(Ljava/lang/String;)Z
Lcom/android/server/MountService;->lockUserKey(I)V
Lcom/android/server/MountService;->mount(Ljava/lang/String;)V
Lcom/android/server/MountService;->mountSecureContainer(Ljava/lang/String;Ljava/lang/String;IZ)I
Lcom/android/server/MountService;->mountVolume(Ljava/lang/String;)I
Lcom/android/server/MountService;->partitionMixed(Ljava/lang/String;I)V
Lcom/android/server/MountService;->partitionPrivate(Ljava/lang/String;)V
Lcom/android/server/MountService;->partitionPublic(Ljava/lang/String;)V
Lcom/android/server/MountService;->prepareUserStorage(Ljava/lang/String;III)V
Lcom/android/server/MountService;->renameSecureContainer(Ljava/lang/String;Ljava/lang/String;)I
Lcom/android/server/MountService;->resizeSecureContainer(Ljava/lang/String;ILjava/lang/String;)I
Lcom/android/server/MountService;->runMaIenance()V
Lcom/android/server/MountService;->setDebugFlags(II)V
Lcom/android/server/MountService;->setField(Ljava/lang/String;Ljava/lang/String;)V
Lcom/android/server/MountService;->setPrimaryStorageUuid(Ljava/lang/String;Landroid/content/pm/IPackageMoveObserver;)V
Lcom/android/server/MountService;->setVolumeNickname(Ljava/lang/String;Ljava/lang/String;)V
Lcom/android/server/MountService;->setVolumeUserFlags(Ljava/lang/String;II)V
Lcom/android/server/MountService;->shutdown(Landroid/os/storage/IMountShutdownObserver;)V
Lcom/android/server/MountService;->unlockUserKey(II[B[B)V
Lcom/android/server/MountService;->unmount(Ljava/lang/String;)V
Lcom/android/server/MountService;->unmountSecureContainer(Ljava/lang/String;Z)I
Lcom/android/server/MountService;->unmountVolume(Ljava/lang/String;ZZ)V
Lcom/android/server/MountService;->verifyEncryptionPassword(Ljava/lang/String;)I
Lcom/android/server/net/NetworkPolicyManagerService;->addRestrictBackgroundWhitelistedUid(I)V
Lcom/android/server/net/NetworkPolicyManagerService;->addUidPolicy(II)V
Lcom/android/server/net/NetworkPolicyManagerService;->factoryReset(Ljava/lang/String;)V
Lcom/android/server/net/NetworkPolicyManagerService;->getNetworkPolicies(Ljava/lang/String;)[Landroid/net/NetworkPolicy;
Lcom/android/server/net/NetworkPolicyManagerService;->getNetworkQuotaInfo(Landroid/net/NetworkState;)Landroid/net/NetworkQuotaInfo;
Lcom/android/server/net/NetworkPolicyManagerService;->getRestrictBackground()Z
Lcom/android/server/net/NetworkPolicyManagerService;->getRestrictBackgroundByCaller()I
Lcom/android/server/net/NetworkPolicyManagerService;->getRestrictBackgroundWhitelistedUids()[I
Lcom/android/server/net/NetworkPolicyManagerService;->getUidPolicy(I)I
Lcom/android/server/net/NetworkPolicyManagerService;->getUidsWithPolicy(I)[I
Lcom/android/server/net/NetworkPolicyManagerService;->isUidForeground(I)Z
Lcom/android/server/net/NetworkPolicyManagerService;->onTetheringChanged(Ljava/lang/String;Z)V
Lcom/android/server/net/NetworkPolicyManagerService;->registerListener(Landroid/net/INetworkPolicyListener;)V
Lcom/android/server/net/NetworkPolicyManagerService;->removeRestrictBackgroundWhitelistedUid(I)V
Lcom/android/server/net/NetworkPolicyManagerService;->removeUidPolicy(II)V
Lcom/android/server/net/NetworkPolicyManagerService;->setConnectivityListener(Landroid/net/INetworkPolicyListener;)V
Lcom/android/server/net/NetworkPolicyManagerService;->setDeviceIdleMode(Z)V
Lcom/android/server/net/NetworkPolicyManagerService;->setNetworkPolicies(L[android/net/NetworkPolicy;)V
Lcom/android/server/net/NetworkPolicyManagerService;->setRestrictBackground(Z)V
Lcom/android/server/net/NetworkPolicyManagerService;->setUidPolicy(II)V
Lcom/android/server/net/NetworkPolicyManagerService;->snoozeLimit(Landroid/net/NetworkTemplate;)V
Lcom/android/server/net/NetworkPolicyManagerService;->unregisterListener(Landroid/net/INetworkPolicyListener;)V
Lcom/android/server/net/NetworkStatsService;->advisePersistThreshold(J)V
Lcom/android/server/net/NetworkStatsService;->forceUpdate()V
Lcom/android/server/net/NetworkStatsService;->forceUpdateIfaces()V
Lcom/android/server/net/NetworkStatsService;->getDataLayerSnapshotForUid(I)Landroid/net/NetworkStats;
Lcom/android/server/net/NetworkStatsService;->getNetworkTotalBytes(Landroid/net/NetworkTemplate;JJ)J
Lcom/android/server/net/NetworkStatsService;->incrementOperationCount(III)V
Lcom/android/server/net/NetworkStatsService;->registerUsageCallback(Ljava/lang/String;Landroid/net/DataUsageRequest;Landroid/os/Messenger;Landroid/os/IBinder;)Landroid/net/DataUsageRequest;
Lcom/android/server/net/NetworkStatsService;->setUidForeground(IZ)V
Lcom/android/server/NetworkManagementService;->addIdleTimer(Ljava/lang/String;II)V
Lcom/android/server/NetworkManagementService;->addInterfaceToLocalNetwork(Ljava/lang/String;Ljava/util/List;)V
Lcom/android/server/NetworkManagementService;->addInterfaceToNetwork(Ljava/lang/String;I)V
Lcom/android/server/NetworkManagementService;->addLegacyRouteForNetId(ILandroid/net/RouteInfo;I)V
Lcom/android/server/NetworkManagementService;->addRoute(ILandroid/net/RouteInfo;)V
Lcom/android/server/NetworkManagementService;->addVpnUidRanges(IL[android/net/UidRange;)V
Lcom/android/server/NetworkManagementService;->allowProtect(I)V
Lcom/android/server/NetworkManagementService;->attachPppd(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V
Lcom/android/server/NetworkManagementService;->clearDefaultNetId()V
Lcom/android/server/NetworkManagementService;->clearInterfaceAddresses(Ljava/lang/String;)V
Lcom/android/server/NetworkManagementService;->clearPermission([I)V
Lcom/android/server/NetworkManagementService;->createPhysicalNetwork(ILjava/lang/String;)V
Lcom/android/server/NetworkManagementService;->createVirtualNetwork(IZZ)V
Lcom/android/server/NetworkManagementService;->denyProtect(I)V
Lcom/android/server/NetworkManagementService;->detachPppd(Ljava/lang/String;)V
Lcom/android/server/NetworkManagementService;->disableIpv6(Ljava/lang/String;)V
Lcom/android/server/NetworkManagementService;->disableNat(Ljava/lang/String;Ljava/lang/String;)V
Lcom/android/server/NetworkManagementService;->enableIpv6(Ljava/lang/String;)V
Lcom/android/server/NetworkManagementService;->enableNat(Ljava/lang/String;Ljava/lang/String;)V
Lcom/android/server/NetworkManagementService;->getDnsForwarders()[Ljava/lang/String;
Lcom/android/server/NetworkManagementService;->getInterfaceConfig(Ljava/lang/String;)Landroid/net/InterfaceConfiguration;
Lcom/android/server/NetworkManagementService;->getIpForwardingEnabled()Z
Lcom/android/server/NetworkManagementService;->getNetworkStatsDetail()Landroid/net/NetworkStats;
Lcom/android/server/NetworkManagementService;->getNetworkStatsSummaryDev()Landroid/net/NetworkStats;
Lcom/android/server/NetworkManagementService;->getNetworkStatsSummaryXt()Landroid/net/NetworkStats;
Lcom/android/server/NetworkManagementService;->getNetworkStatsTethering()Landroid/net/NetworkStats;
Lcom/android/server/NetworkManagementService;->getNetworkStatsUidDetail(I)Landroid/net/NetworkStats;
Lcom/android/server/NetworkManagementService;->isBandwidthControlEnabled()Z
Lcom/android/server/NetworkManagementService;->isClatdStarted(Ljava/lang/String;)Z
Lcom/android/server/NetworkManagementService;->isTetheringStarted()Z
Lcom/android/server/NetworkManagementService;->listInterfaces()[Ljava/lang/String;
Lcom/android/server/NetworkManagementService;->listTetheredInterfaces()[Ljava/lang/String;
Lcom/android/server/NetworkManagementService;->listTtys()[Ljava/lang/String;
Lcom/android/server/NetworkManagementService;->registerObserver(Landroid/net/INetworkManagementEventObserver;)V
Lcom/android/server/NetworkManagementService;->removeIdleTimer(Ljava/lang/String;)V
Lcom/android/server/NetworkManagementService;->removeInterfaceAlert(Ljava/lang/String;)V
Lcom/android/server/NetworkManagementService;->removeInterfaceFromLocalNetwork(Ljava/lang/String;)V
Lcom/android/server/NetworkManagementService;->removeInterfaceFromNetwork(Ljava/lang/String;I)V
Lcom/android/server/NetworkManagementService;->removeInterfaceQuota(Ljava/lang/String;)V
Lcom/android/server/NetworkManagementService;->removeNetwork(I)V
Lcom/android/server/NetworkManagementService;->removeRoute(ILandroid/net/RouteInfo;)V
Lcom/android/server/NetworkManagementService;->removeRoutesFromLocalNetwork(Ljava/util/List;)I
Lcom/android/server/NetworkManagementService;->removeVpnUidRanges(IL[android/net/UidRange;)V
Lcom/android/server/NetworkManagementService;->setAccessPoI(Landroid/net/wifi/WifiConfiguration;Ljava/lang/String;)V
Lcom/android/server/NetworkManagementService;->setDefaultNetId(I)V
Lcom/android/server/NetworkManagementService;->setDnsConfigurationForNetwork(IL[java/lang/String;Ljava/lang/String;)V
Lcom/android/server/NetworkManagementService;->setDnsForwarders(Landroid/net/Network;L[java/lang/String;)V
Lcom/android/server/NetworkManagementService;->setDnsServersForNetwork(IL[java/lang/String;Ljava/lang/String;)V
Lcom/android/server/NetworkManagementService;->setGlobalAlert(J)V
Lcom/android/server/NetworkManagementService;->setInterfaceAlert(Ljava/lang/String;J)V
Lcom/android/server/NetworkManagementService;->setInterfaceConfig(Ljava/lang/String;Landroid/net/InterfaceConfiguration;)V
Lcom/android/server/NetworkManagementService;->setInterfaceDown(Ljava/lang/String;)V
Lcom/android/server/NetworkManagementService;->setInterfaceIpv6NdOffload(Ljava/lang/String;Z)V
Lcom/android/server/NetworkManagementService;->setInterfaceIpv6PrivacyExtensions(Ljava/lang/String;Z)V
Lcom/android/server/NetworkManagementService;->setInterfaceQuota(Ljava/lang/String;J)V
Lcom/android/server/NetworkManagementService;->setInterfaceUp(Ljava/lang/String;)V
Lcom/android/server/NetworkManagementService;->setIpForwardingEnabled(Z)V
Lcom/android/server/NetworkManagementService;->setMtu(Ljava/lang/String;I)V
Lcom/android/server/NetworkManagementService;->setNetworkPermission(ILjava/lang/String;)V
Lcom/android/server/NetworkManagementService;->setPermission(Ljava/lang/String;[I)V
Lcom/android/server/NetworkManagementService;->setUidCleartextNetworkPolicy(II)V
Lcom/android/server/NetworkManagementService;->setUidMeteredNetworkBlacklist(IZ)V
Lcom/android/server/NetworkManagementService;->setUidMeteredNetworkWhitelist(IZ)V
Lcom/android/server/NetworkManagementService;->shutdown()V
Lcom/android/server/NetworkManagementService;->startAccessPoI(Landroid/net/wifi/WifiConfiguration;Ljava/lang/String;)V
Lcom/android/server/NetworkManagementService;->startClatd(Ljava/lang/String;)V
Lcom/android/server/NetworkManagementService;->startInterfaceForwarding(Ljava/lang/String;Ljava/lang/String;)V
Lcom/android/server/NetworkManagementService;->startTethering(L[java/lang/String;)V
Lcom/android/server/NetworkManagementService;->stopAccessPoI(Ljava/lang/String;)V
Lcom/android/server/NetworkManagementService;->stopClatd(Ljava/lang/String;)V
Lcom/android/server/NetworkManagementService;->stopInterfaceForwarding(Ljava/lang/String;Ljava/lang/String;)V
Lcom/android/server/NetworkManagementService;->stopTethering()V
Lcom/android/server/NetworkManagementService;->tetherInterface(Ljava/lang/String;)V
Lcom/android/server/NetworkManagementService;->unregisterObserver(Landroid/net/INetworkManagementEventObserver;)V
Lcom/android/server/NetworkManagementService;->untetherInterface(Ljava/lang/String;)V
Lcom/android/server/NetworkManagementService;->wifiFirmwareReload(Ljava/lang/String;Ljava/lang/String;)V
Lcom/android/server/NetworkScoreService;->clearScores()Z
Lcom/android/server/NetworkScoreService;->disableScoring()V
Lcom/android/server/NetworkScoreService;->registerNetworkScoreCache(ILandroid/net/INetworkScoreCache;)V
Lcom/android/server/NetworkScoreService;->setActiveScorer(Ljava/lang/String;)Z
Lcom/android/server/NetworkScoreService;->updateScores(L[android/net/ScoredNetwork;)Z
Lcom/android/server/NsdService;->getMessenger()Landroid/os/Messenger;
Lcom/android/server/NsdService;->setEnabled(Z)V
Lcom/android/server/pm/PackageInstallerService;->createSession(Landroid/content/pm/PackageInstaller$SessionParams;Ljava/lang/String;I)I
Lcom/android/server/pm/PackageInstallerService;->getAllSessions(I)Landroid/content/pm/ParceledListSlice;
Lcom/android/server/pm/PackageInstallerService;->getMySessions(Ljava/lang/String;I)Landroid/content/pm/ParceledListSlice;
Lcom/android/server/pm/PackageInstallerService;->registerCallback(Landroid/content/pm/IPackageInstallerCallback;I)V
Lcom/android/server/pm/PackageInstallerService;->setPermissionsResult(IZ)V
Lcom/android/server/pm/PackageInstallerService;->uninstall(Ljava/lang/String;Ljava/lang/String;ILandroid/content/IntentSender;I)V
Lcom/android/server/pm/PackageManagerService;->addCrossProfileIntentFilter(Landroid/content/IntentFilter;Ljava/lang/String;III)V
Lcom/android/server/pm/PackageManagerService;->addOnPermissionsChangeListener(Landroid/content/pm/IOnPermissionsChangeListener;)V
Lcom/android/server/pm/PackageManagerService;->addPreferredActivity(Landroid/content/IntentFilter;IL[android/content/ComponentName;Landroid/content/ComponentName;I)V
Lcom/android/server/pm/PackageManagerService;->canForwardTo(Landroid/content/Intent;Ljava/lang/String;II)Z
Lcom/android/server/pm/PackageManagerService;->clearApplicationUserData(Ljava/lang/String;Landroid/content/pm/IPackageDataObserver;I)V
Lcom/android/server/pm/PackageManagerService;->clearCrossProfileIntentFilters(ILjava/lang/String;)V
Lcom/android/server/pm/PackageManagerService;->clearPackagePreferredActivities(Ljava/lang/String;)V
Lcom/android/server/pm/PackageManagerService;->deleteApplicationCacheFiles(Ljava/lang/String;Landroid/content/pm/IPackageDataObserver;)V
Lcom/android/server/pm/PackageManagerService;->deleteApplicationCacheFilesAsUser(Ljava/lang/String;ILandroid/content/pm/IPackageDataObserver;)V
Lcom/android/server/pm/PackageManagerService;->deletePackage(Ljava/lang/String;Landroid/content/pm/IPackageDeleteObserver2;II)V
Lcom/android/server/pm/PackageManagerService;->deletePackageAsUser(Ljava/lang/String;Landroid/content/pm/IPackageDeleteObserver;II)V
Lcom/android/server/pm/PackageManagerService;->extendVerificationTimeout(IIJ)V
Lcom/android/server/pm/PackageManagerService;->flushPackageRestrictionsAsUser(I)V
Lcom/android/server/pm/PackageManagerService;->freeStorage(Ljava/lang/String;JLandroid/content/IntentSender;)V
Lcom/android/server/pm/PackageManagerService;->freeStorageAndNotify(Ljava/lang/String;JLandroid/content/pm/IPackageDataObserver;)V
Lcom/android/server/pm/PackageManagerService;->getActivityInfo(Landroid/content/ComponentName;II)Landroid/content/pm/ActivityInfo;
Lcom/android/server/pm/PackageManagerService;->getApplicationEnabledSetting(Ljava/lang/String;I)I
Lcom/android/server/pm/PackageManagerService;->getApplicationHiddenSettingAsUser(Ljava/lang/String;I)Z
Lcom/android/server/pm/PackageManagerService;->getApplicationInfo(Ljava/lang/String;II)Landroid/content/pm/ApplicationInfo;
Lcom/android/server/pm/PackageManagerService;->getComponentEnabledSetting(Landroid/content/ComponentName;I)I
Lcom/android/server/pm/PackageManagerService;->getHomeActivities(Ljava/util/List;)Landroid/content/ComponentName;
Lcom/android/server/pm/PackageManagerService;->getInstalledPackages(II)Landroid/content/pm/ParceledListSlice;
Lcom/android/server/pm/PackageManagerService;->getLastChosenActivity(Landroid/content/Intent;Ljava/lang/String;I)Landroid/content/pm/ResolveInfo;
Lcom/android/server/pm/PackageManagerService;->getMoveStatus(I)I
Lcom/android/server/pm/PackageManagerService;->getPackageGids(Ljava/lang/String;II)[I
Lcom/android/server/pm/PackageManagerService;->getPackageInfo(Ljava/lang/String;II)Landroid/content/pm/PackageInfo;
Lcom/android/server/pm/PackageManagerService;->getPackageSizeInfo(Ljava/lang/String;ILandroid/content/pm/IPackageStatsObserver;)V
Lcom/android/server/pm/PackageManagerService;->getPackageUid(Ljava/lang/String;II)I
Lcom/android/server/pm/PackageManagerService;->getPermissionFlags(Ljava/lang/String;Ljava/lang/String;I)I
Lcom/android/server/pm/PackageManagerService;->getProviderInfo(Landroid/content/ComponentName;II)Landroid/content/pm/ProviderInfo;
Lcom/android/server/pm/PackageManagerService;->getReceiverInfo(Landroid/content/ComponentName;II)Landroid/content/pm/ActivityInfo;
Lcom/android/server/pm/PackageManagerService;->getServiceInfo(Landroid/content/ComponentName;II)Landroid/content/pm/ServiceInfo;
Lcom/android/server/pm/PackageManagerService;->getVerifierDeviceIdentity()Landroid/content/pm/VerifierDeviceIdentity;
Lcom/android/server/pm/PackageManagerService;->grantRuntimePermission(Ljava/lang/String;Ljava/lang/String;I)V
Lcom/android/server/pm/PackageManagerService;->installExistingPackageAsUser(Ljava/lang/String;I)I
Lcom/android/server/pm/PackageManagerService;->installPackageAsUser(Ljava/lang/String;Landroid/content/pm/IPackageInstallObserver2;ILjava/lang/String;I)V
Lcom/android/server/pm/PackageManagerService;->isEphemeralApplication(Ljava/lang/String;I)Z
Lcom/android/server/pm/PackageManagerService;->isPackageAvailable(Ljava/lang/String;I)Z
Lcom/android/server/pm/PackageManagerService;->isPackageSuspendedForUser(Ljava/lang/String;I)Z
Lcom/android/server/pm/PackageManagerService;->isPermissionRevokedByPolicy(Ljava/lang/String;Ljava/lang/String;I)Z
Lcom/android/server/pm/PackageManagerService;->movePackage(Ljava/lang/String;Ljava/lang/String;)I
Lcom/android/server/pm/PackageManagerService;->movePrimaryStorage(Ljava/lang/String;)I
Lcom/android/server/pm/PackageManagerService;->queryIntentActivities(Landroid/content/Intent;Ljava/lang/String;II)Landroid/content/pm/ParceledListSlice;
Lcom/android/server/pm/PackageManagerService;->queryIntentActivityOptions(Landroid/content/ComponentName;L[android/content/Intent;L[java/lang/String;Landroid/content/Intent;Ljava/lang/String;II)Landroid/content/pm/ParceledListSlice;
Lcom/android/server/pm/PackageManagerService;->queryIntentContentProviders(Landroid/content/Intent;Ljava/lang/String;II)Landroid/content/pm/ParceledListSlice;
Lcom/android/server/pm/PackageManagerService;->queryIntentReceivers(Landroid/content/Intent;Ljava/lang/String;II)Landroid/content/pm/ParceledListSlice;
Lcom/android/server/pm/PackageManagerService;->queryIntentServices(Landroid/content/Intent;Ljava/lang/String;II)Landroid/content/pm/ParceledListSlice;
Lcom/android/server/pm/PackageManagerService;->registerMoveCallback(Landroid/content/pm/IPackageMoveObserver;)V
Lcom/android/server/pm/PackageManagerService;->replacePreferredActivity(Landroid/content/IntentFilter;IL[android/content/ComponentName;Landroid/content/ComponentName;I)V
Lcom/android/server/pm/PackageManagerService;->resetApplicationPreferences(I)V
Lcom/android/server/pm/PackageManagerService;->resetRuntimePermissions()V
Lcom/android/server/pm/PackageManagerService;->resolveIntent(Landroid/content/Intent;Ljava/lang/String;II)Landroid/content/pm/ResolveInfo;
Lcom/android/server/pm/PackageManagerService;->resolveService(Landroid/content/Intent;Ljava/lang/String;II)Landroid/content/pm/ResolveInfo;
Lcom/android/server/pm/PackageManagerService;->revokeRuntimePermission(Ljava/lang/String;Ljava/lang/String;I)V
Lcom/android/server/pm/PackageManagerService;->setApplicationEnabledSetting(Ljava/lang/String;IIILjava/lang/String;)V
Lcom/android/server/pm/PackageManagerService;->setApplicationHiddenSettingAsUser(Ljava/lang/String;ZI)Z
Lcom/android/server/pm/PackageManagerService;->setBlockUninstallForUser(Ljava/lang/String;ZI)Z
Lcom/android/server/pm/PackageManagerService;->setComponentEnabledSetting(Landroid/content/ComponentName;III)V
Lcom/android/server/pm/PackageManagerService;->setDefaultBrowserPackageName(Ljava/lang/String;I)Z
Lcom/android/server/pm/PackageManagerService;->setHomeActivity(Landroid/content/ComponentName;I)V
Lcom/android/server/pm/PackageManagerService;->setInstallLocation(I)Z
Lcom/android/server/pm/PackageManagerService;->setLastChosenActivity(Landroid/content/Intent;Ljava/lang/String;ILandroid/content/IntentFilter;ILandroid/content/ComponentName;)V
Lcom/android/server/pm/PackageManagerService;->setPackagesSuspendedAsUser(L[java/lang/String;ZI)[Ljava/lang/String;
Lcom/android/server/pm/PackageManagerService;->setPackageStoppedState(Ljava/lang/String;ZI)V
Lcom/android/server/pm/PackageManagerService;->setPermissionEnforced(Ljava/lang/String;Z)V
Lcom/android/server/pm/PackageManagerService;->shouldShowRequestPermissionRationale(Ljava/lang/String;Ljava/lang/String;I)Z
Lcom/android/server/pm/PackageManagerService;->systemReady()V
Lcom/android/server/pm/PackageManagerService;->unregisterMoveCallback(Landroid/content/pm/IPackageMoveObserver;)V
Lcom/android/server/pm/PackageManagerService;->updateExternalMediaStatus(ZZ)V
Lcom/android/server/pm/PackageManagerService;->updateIntentVerificationStatus(Ljava/lang/String;II)Z
Lcom/android/server/pm/PackageManagerService;->updatePermissionFlags(Ljava/lang/String;Ljava/lang/String;III)V
Lcom/android/server/pm/PackageManagerService;->updatePermissionFlagsForAllApps(III)V
Lcom/android/server/pm/PackageManagerService;->verifyIntentFilter(IILjava/util/List;)V
Lcom/android/server/pm/PackageManagerService;->verifyPendingInstall(II)V
Lcom/android/server/pm/ShortcutService;->onApplicationActive(Ljava/lang/String;I)V
Lcom/android/server/power/PowerManagerService$BinderService;->acquireWakeLock(Landroid/os/IBinder;ILjava/lang/String;Ljava/lang/String;Landroid/os/WorkSource;Ljava/lang/String;)V
Lcom/android/server/power/PowerManagerService$BinderService;->acquireWakeLockWithUid(Landroid/os/IBinder;ILjava/lang/String;Ljava/lang/String;I)V
Lcom/android/server/power/PowerManagerService$BinderService;->boostScreenBrightness(J)V
Lcom/android/server/power/PowerManagerService$BinderService;->crash(Ljava/lang/String;)V
Lcom/android/server/power/PowerManagerService$BinderService;->goToSleep(JII)V
Lcom/android/server/power/PowerManagerService$BinderService;->nap(J)V
Lcom/android/server/power/PowerManagerService$BinderService;->powerHI(II)V
Lcom/android/server/power/PowerManagerService$BinderService;->reboot(ZLjava/lang/String;Z)V
Lcom/android/server/power/PowerManagerService$BinderService;->rebootSafeMode(ZZ)V
Lcom/android/server/power/PowerManagerService$BinderService;->releaseWakeLock(Landroid/os/IBinder;I)V
Lcom/android/server/power/PowerManagerService$BinderService;->setAttentionLight(ZI)V
Lcom/android/server/power/PowerManagerService$BinderService;->setPowerSaveMode(Z)Z
Lcom/android/server/power/PowerManagerService$BinderService;->setTemporaryScreenAutoBrightnessAdjustmentSettingOverride(F)V
Lcom/android/server/power/PowerManagerService$BinderService;->setTemporaryScreenBrightnessSettingOverride(I)V
Lcom/android/server/power/PowerManagerService$BinderService;->shutdown(ZLjava/lang/String;Z)V
Lcom/android/server/power/PowerManagerService$BinderService;->updateWakeLockUids(Landroid/os/IBinder;[I)V
Lcom/android/server/power/PowerManagerService$BinderService;->updateWakeLockWorkSource(Landroid/os/IBinder;Landroid/os/WorkSource;Ljava/lang/String;)V
Lcom/android/server/power/PowerManagerService$BinderService;->userActivity(JII)V
Lcom/android/server/power/PowerManagerService$BinderService;->wakeUp(JLjava/lang/String;Ljava/lang/String;)V
Lcom/android/server/prI/PrIManagerService$PrIManagerImpl;->addPrIJobStateChangeListener(Landroid/prI/IPrIJobStateChangeListener;II)V
Lcom/android/server/prI/PrIManagerService$PrIManagerImpl;->cancelPrIJob(Landroid/prI/PrIJobId;II)V
Lcom/android/server/prI/PrIManagerService$PrIManagerImpl;->getPrIJobInfo(Landroid/prI/PrIJobId;II)Landroid/prI/PrIJobInfo;
Lcom/android/server/prI/PrIManagerService$PrIManagerImpl;->getPrIJobInfos(II)Ljava/util/List;
Lcom/android/server/prI/PrIManagerService$PrIManagerImpl;->prI(Ljava/lang/String;Landroid/prI/IPrIDocumentAdapter;Landroid/prI/PrIAttributes;Ljava/lang/String;II)Landroid/os/Bundle;
Lcom/android/server/prI/PrIManagerService$PrIManagerImpl;->restartPrIJob(Landroid/prI/PrIJobId;II)V
Lcom/android/server/RecoverySystemService$BinderService;->clearBcb()Z
Lcom/android/server/RecoverySystemService$BinderService;->rebootRecoveryWithCommand(Ljava/lang/String;)V
Lcom/android/server/RecoverySystemService$BinderService;->setupBcb(Ljava/lang/String;)Z
Lcom/android/server/RecoverySystemService$BinderService;->uncrypt(Ljava/lang/String;Landroid/os/IRecoverySystemProgressListener;)Z
Lcom/android/server/SerialService;->getSerialPorts()[Ljava/lang/String;
Lcom/android/server/SerialService;->openSerialPort(Ljava/lang/String;)Landroid/os/ParcelFileDescriptor;
Lcom/android/server/sip/SipService;->close(Ljava/lang/String;Ljava/lang/String;)V
Lcom/android/server/sip/SipService;->createSession(Landroid/net/sip/SipProfile;Landroid/net/sip/ISipSessionListener;Ljava/lang/String;)Landroid/net/sip/ISipSession;
Lcom/android/server/sip/SipService;->getListOfProfiles(Ljava/lang/String;)[Landroid/net/sip/SipProfile;
Lcom/android/server/sip/SipService;->getPendingSession(Ljava/lang/String;Ljava/lang/String;)Landroid/net/sip/ISipSession;
Lcom/android/server/sip/SipService;->isOpened(Ljava/lang/String;Ljava/lang/String;)Z
Lcom/android/server/sip/SipService;->isRegistered(Ljava/lang/String;Ljava/lang/String;)Z
Lcom/android/server/sip/SipService;->open3(Landroid/net/sip/SipProfile;Landroid/app/PendingIntent;Landroid/net/sip/ISipSessionListener;Ljava/lang/String;)V
Lcom/android/server/sip/SipService;->open(Landroid/net/sip/SipProfile;Ljava/lang/String;)V
Lcom/android/server/sip/SipService;->setRegistrationListener(Ljava/lang/String;Landroid/net/sip/ISipSessionListener;Ljava/lang/String;)V
Lcom/android/server/soundtrigger/SoundTriggerService$SoundTriggerServiceStub;->deleteSoundModel(Landroid/os/ParcelUuid;)V
Lcom/android/server/soundtrigger/SoundTriggerService$SoundTriggerServiceStub;->getSoundModel(Landroid/os/ParcelUuid;)Landroid/hardware/soundtrigger/SoundTrigger$GenericSoundModel;
Lcom/android/server/soundtrigger/SoundTriggerService$SoundTriggerServiceStub;->startRecognition(Landroid/os/ParcelUuid;Landroid/hardware/soundtrigger/IRecognitionStatusCallback;Landroid/hardware/soundtrigger/SoundTrigger$RecognitionConfig;)I
Lcom/android/server/soundtrigger/SoundTriggerService$SoundTriggerServiceStub;->stopRecognition(Landroid/os/ParcelUuid;Landroid/hardware/soundtrigger/IRecognitionStatusCallback;)I
Lcom/android/server/soundtrigger/SoundTriggerService$SoundTriggerServiceStub;->updateSoundModel(Landroid/hardware/soundtrigger/SoundTrigger$GenericSoundModel;)V
Lcom/android/server/statusbar/StatusBarManagerService;->addTile(Landroid/content/ComponentName;)V
Lcom/android/server/statusbar/StatusBarManagerService;->clearNotificationEffects()V
Lcom/android/server/statusbar/StatusBarManagerService;->clickTile(Landroid/content/ComponentName;)V
Lcom/android/server/statusbar/StatusBarManagerService;->collapsePanels()V
Lcom/android/server/statusbar/StatusBarManagerService;->disable2(ILandroid/os/IBinder;Ljava/lang/String;)V
Lcom/android/server/statusbar/StatusBarManagerService;->disable2ForUser(ILandroid/os/IBinder;Ljava/lang/String;I)V
Lcom/android/server/statusbar/StatusBarManagerService;->disable(ILandroid/os/IBinder;Ljava/lang/String;)V
Lcom/android/server/statusbar/StatusBarManagerService;->disableForUser(ILandroid/os/IBinder;Ljava/lang/String;I)V
Lcom/android/server/statusbar/StatusBarManagerService;->expandNotificationsPanel()V
Lcom/android/server/statusbar/StatusBarManagerService;->expandSettingsPanel(Ljava/lang/String;)V
Lcom/android/server/statusbar/StatusBarManagerService;->handleSystemNavigationKey(I)V
Lcom/android/server/statusbar/StatusBarManagerService;->onClearAllNotifications(I)V
Lcom/android/server/statusbar/StatusBarManagerService;->onNotificationActionClick(Ljava/lang/String;I)V
Lcom/android/server/statusbar/StatusBarManagerService;->onNotificationClear(Ljava/lang/String;Ljava/lang/String;II)V
Lcom/android/server/statusbar/StatusBarManagerService;->onNotificationClick(Ljava/lang/String;)V
Lcom/android/server/statusbar/StatusBarManagerService;->onNotificationError(Ljava/lang/String;Ljava/lang/String;IIILjava/lang/String;I)V
Lcom/android/server/statusbar/StatusBarManagerService;->onNotificationExpansionChanged(Ljava/lang/String;ZZ)V
Lcom/android/server/statusbar/StatusBarManagerService;->onNotificationVisibilityChanged(L[com/android/Iernal/statusbar/NotificationVisibility;L[com/android/Iernal/statusbar/NotificationVisibility;)V
Lcom/android/server/statusbar/StatusBarManagerService;->onPanelHidden()V
Lcom/android/server/statusbar/StatusBarManagerService;->onPanelRevealed(ZI)V
Lcom/android/server/statusbar/StatusBarManagerService;->registerStatusBar(Lcom/android/Iernal/statusbar/IStatusBar;Ljava/util/List;Ljava/util/List;[ILjava/util/List;Landroid/graphics/Rect;Landroid/graphics/Rect;)V
Lcom/android/server/statusbar/StatusBarManagerService;->removeIcon(Ljava/lang/String;)V
Lcom/android/server/statusbar/StatusBarManagerService;->remTile(Landroid/content/ComponentName;)V
Lcom/android/server/statusbar/StatusBarManagerService;->setIcon(Ljava/lang/String;Ljava/lang/String;IILjava/lang/String;)V
Lcom/android/server/statusbar/StatusBarManagerService;->setIconVisibility(Ljava/lang/String;Z)V
Lcom/android/server/statusbar/StatusBarManagerService;->setImeWindowStatus(Landroid/os/IBinder;IIZ)V
Lcom/android/server/statusbar/StatusBarManagerService;->setSystemUiVisibility(IILjava/lang/String;)V
Lcom/android/server/TelephonyRegistry;->addOnSubscriptionsChangedListener(Ljava/lang/String;Lcom/android/Iernal/telephony/IOnSubscriptionsChangedListener;)V
Lcom/android/server/TelephonyRegistry;->listen(Ljava/lang/String;Lcom/android/Iernal/telephony/IPhoneStateListener;IZ)V
Lcom/android/server/TelephonyRegistry;->listenForSubscriber(ILjava/lang/String;Lcom/android/Iernal/telephony/IPhoneStateListener;IZ)V
Lcom/android/server/TelephonyRegistry;->notifyCallForwardingChanged(Z)V
Lcom/android/server/TelephonyRegistry;->notifyCallForwardingChangedForSubscriber(IZ)V
Lcom/android/server/TelephonyRegistry;->notifyCallState(ILjava/lang/String;)V
Lcom/android/server/TelephonyRegistry;->notifyCallStateForPhoneId(IIILjava/lang/String;)V
Lcom/android/server/TelephonyRegistry;->notifyCarrierNetworkChange(Z)V
Lcom/android/server/TelephonyRegistry;->notifyCellInfo(Ljava/util/List;)V
Lcom/android/server/TelephonyRegistry;->notifyCellInfoForSubscriber(ILjava/util/List;)V
Lcom/android/server/TelephonyRegistry;->notifyCellLocation(Landroid/os/Bundle;)V
Lcom/android/server/TelephonyRegistry;->notifyCellLocationForSubscriber(ILandroid/os/Bundle;)V
Lcom/android/server/TelephonyRegistry;->notifyDataActivity(I)V
Lcom/android/server/TelephonyRegistry;->notifyDataActivityForSubscriber(II)V
Lcom/android/server/TelephonyRegistry;->notifyDataConnection(IZLjava/lang/String;Ljava/lang/String;Ljava/lang/String;Landroid/net/LinkProperties;Landroid/net/NetworkCapabilities;IZ)V
Lcom/android/server/TelephonyRegistry;->notifyDataConnectionFailed(Ljava/lang/String;Ljava/lang/String;)V
Lcom/android/server/TelephonyRegistry;->notifyDataConnectionFailedForSubscriber(ILjava/lang/String;Ljava/lang/String;)V
Lcom/android/server/TelephonyRegistry;->notifyDataConnectionForSubscriber(IIZLjava/lang/String;Ljava/lang/String;Ljava/lang/String;Landroid/net/LinkProperties;Landroid/net/NetworkCapabilities;IZ)V
Lcom/android/server/TelephonyRegistry;->notifyDisconnectCause(II)V
Lcom/android/server/TelephonyRegistry;->notifyMessageWaitingChangedForPhoneId(IIZ)V
Lcom/android/server/TelephonyRegistry;->notifyOemHookRawEventForSubscriber(I[B)V
Lcom/android/server/TelephonyRegistry;->notifyOtaspChanged(I)V
Lcom/android/server/TelephonyRegistry;->notifyPreciseCallState(III)V
Lcom/android/server/TelephonyRegistry;->notifyPreciseDataConnectionFailed(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V
Lcom/android/server/TelephonyRegistry;->notifyServiceStateForPhoneId(IILandroid/telephony/ServiceState;)V
Lcom/android/server/TelephonyRegistry;->notifySignalStrengthForPhoneId(IILandroid/telephony/SignalStrength;)V
Lcom/android/server/TelephonyRegistry;->notifyVoLteServiceStateChanged(Landroid/telephony/VoLteServiceState;)V
Lcom/android/server/TextServicesManagerService;->setCurrentSpellChecker(Ljava/lang/String;Ljava/lang/String;)V
Lcom/android/server/TextServicesManagerService;->setCurrentSpellCheckerSubtype(Ljava/lang/String;I)V
Lcom/android/server/TextServicesManagerService;->setSpellCheckerEnabled(Z)V
Lcom/android/server/tv/TvInputManagerService$BinderService;->acquireTvInputHardware(ILandroid/media/tv/ITvInputHardwareCallback;Landroid/media/tv/TvInputInfo;I)Landroid/media/tv/ITvInputHardware;
Lcom/android/server/tv/TvInputManagerService$BinderService;->addBlockedRating(Ljava/lang/String;I)V
Lcom/android/server/tv/TvInputManagerService$BinderService;->captureFrame(Ljava/lang/String;Landroid/view/Surface;Landroid/media/tv/TvStreamConfig;I)Z
Lcom/android/server/tv/TvInputManagerService$BinderService;->getAvailableTvStreamConfigList(Ljava/lang/String;I)Ljava/util/List;
Lcom/android/server/tv/TvInputManagerService$BinderService;->getDvbDeviceList()Ljava/util/List;
Lcom/android/server/tv/TvInputManagerService$BinderService;->getHardwareList()Ljava/util/List;
Lcom/android/server/tv/TvInputManagerService$BinderService;->openDvbDevice(Landroid/media/tv/DvbDeviceInfo;I)Landroid/os/ParcelFileDescriptor;
Lcom/android/server/tv/TvInputManagerService$BinderService;->releaseTvInputHardware(ILandroid/media/tv/ITvInputHardware;I)V
Lcom/android/server/tv/TvInputManagerService$BinderService;->removeBlockedRating(Ljava/lang/String;I)V
Lcom/android/server/tv/TvInputManagerService$BinderService;->setParentalControlsEnabled(ZI)V
Lcom/android/server/tv/TvInputManagerService$BinderService;->unblockContent(Landroid/os/IBinder;Ljava/lang/String;I)V
Lcom/android/server/tv/TvInputManagerService$ServiceCallback;->addHardwareInput(ILandroid/media/tv/TvInputInfo;)V
Lcom/android/server/tv/TvInputManagerService$ServiceCallback;->addHdmiInput(ILandroid/media/tv/TvInputInfo;)V
Lcom/android/server/tv/TvInputManagerService$ServiceCallback;->removeHardwareInput(Ljava/lang/String;)V
Lcom/android/server/UpdateLockService;->acquireUpdateLock(Landroid/os/IBinder;Ljava/lang/String;)V
Lcom/android/server/UpdateLockService;->releaseUpdateLock(Landroid/os/IBinder;)V
Lcom/android/server/usage/UsageStatsService$BinderService;->onCarrierPrivilegedAppsChanged()V
Lcom/android/server/usage/UsageStatsService$BinderService;->queryConfigurationStats(IJJLjava/lang/String;)Landroid/content/pm/ParceledListSlice;
Lcom/android/server/usage/UsageStatsService$BinderService;->queryEvents(JJLjava/lang/String;)Landroid/app/usage/UsageEvents;
Lcom/android/server/usage/UsageStatsService$BinderService;->queryUsageStats(IJJLjava/lang/String;)Landroid/content/pm/ParceledListSlice;
Lcom/android/server/usage/UsageStatsService$BinderService;->setAppInactive(Ljava/lang/String;ZI)V
Lcom/android/server/usb/UsbService;->allowUsbDebugging(ZLjava/lang/String;)V
Lcom/android/server/usb/UsbService;->clearDefaults(Ljava/lang/String;I)V
Lcom/android/server/usb/UsbService;->clearUsbDebuggingKeys()V
Lcom/android/server/usb/UsbService;->denyUsbDebugging()V
Lcom/android/server/usb/UsbService;->getPorts()[Landroid/hardware/usb/UsbPort;
Lcom/android/server/usb/UsbService;->getPortStatus(Ljava/lang/String;)Landroid/hardware/usb/UsbPortStatus;
Lcom/android/server/usb/UsbService;->grantAccessoryPermission(Landroid/hardware/usb/UsbAccessory;I)V
Lcom/android/server/usb/UsbService;->grantDevicePermission(Landroid/hardware/usb/UsbDevice;I)V
Lcom/android/server/usb/UsbService;->hasDefaults(Ljava/lang/String;I)Z
Lcom/android/server/usb/UsbService;->isFunctionEnabled(Ljava/lang/String;)Z
Lcom/android/server/usb/UsbService;->setAccessoryPackage(Landroid/hardware/usb/UsbAccessory;Ljava/lang/String;I)V
Lcom/android/server/usb/UsbService;->setCurrentFunction(Ljava/lang/String;)V
Lcom/android/server/usb/UsbService;->setDevicePackage(Landroid/hardware/usb/UsbDevice;Ljava/lang/String;I)V
Lcom/android/server/usb/UsbService;->setPortRoles(Ljava/lang/String;II)V
Lcom/android/server/usb/UsbService;->setUsbDataUnlocked(Z)V
Lcom/android/server/VibratorService;->cancelVibrate(Landroid/os/IBinder;)V
Lcom/android/server/VibratorService;->vibrate(ILjava/lang/String;JILandroid/os/IBinder;)V
Lcom/android/server/VibratorService;->vibratePattern(ILjava/lang/String;[JIILandroid/os/IBinder;)V
Lcom/android/server/voiceIeraction/VoiceInteractionManagerService$VoiceInteractionManagerServiceStub;->activeServiceSupportsAssist()Z
Lcom/android/server/voiceIeraction/VoiceInteractionManagerService$VoiceInteractionManagerServiceStub;->activeServiceSupportsLaunchFromKeyguard()Z
Lcom/android/server/voiceIeraction/VoiceInteractionManagerService$VoiceInteractionManagerServiceStub;->deleteKeyphraseSoundModel(ILjava/lang/String;)I
Lcom/android/server/voiceIeraction/VoiceInteractionManagerService$VoiceInteractionManagerServiceStub;->getActiveServiceComponentName()Landroid/content/ComponentName;
Lcom/android/server/voiceIeraction/VoiceInteractionManagerService$VoiceInteractionManagerServiceStub;->getKeyphraseSoundModel(ILjava/lang/String;)Landroid/hardware/soundtrigger/SoundTrigger$KeyphraseSoundModel;
Lcom/android/server/voiceIeraction/VoiceInteractionManagerService$VoiceInteractionManagerServiceStub;->hideCurrentSession()V
Lcom/android/server/voiceIeraction/VoiceInteractionManagerService$VoiceInteractionManagerServiceStub;->isSessionRunning()Z
Lcom/android/server/voiceIeraction/VoiceInteractionManagerService$VoiceInteractionManagerServiceStub;->launchVoiceAssistFromKeyguard()V
Lcom/android/server/voiceIeraction/VoiceInteractionManagerService$VoiceInteractionManagerServiceStub;->onLockscreenShown()V
Lcom/android/server/voiceIeraction/VoiceInteractionManagerService$VoiceInteractionManagerServiceStub;->registerVoiceInteractionSessionListener(Lcom/android/Iernal/app/IVoiceInteractionSessionListener;)V
Lcom/android/server/voiceIeraction/VoiceInteractionManagerService$VoiceInteractionManagerServiceStub;->showSessionForActiveService(Landroid/os/Bundle;ILcom/android/Iernal/app/IVoiceInteractionSessionShowCallback;Landroid/os/IBinder;)Z
Lcom/android/server/voiceIeraction/VoiceInteractionManagerService$VoiceInteractionManagerServiceStub;->updateKeyphraseSoundModel(Landroid/hardware/soundtrigger/SoundTrigger$KeyphraseSoundModel;)I
Lcom/android/server/wallpaper/WallpaperManagerService;->clearWallpaper(Ljava/lang/String;II)V
Lcom/android/server/wallpaper/WallpaperManagerService;->setDimensionHIs(IILjava/lang/String;)V
Lcom/android/server/wallpaper/WallpaperManagerService;->setDisplayPadding(Landroid/graphics/Rect;Ljava/lang/String;)V
Lcom/android/server/wallpaper/WallpaperManagerService;->setLockWallpaperCallback(Landroid/app/IWallpaperManagerCallback;)Z
Lcom/android/server/wallpaper/WallpaperManagerService;->setWallpaper(Ljava/lang/String;Ljava/lang/String;Landroid/graphics/Rect;ZLandroid/os/Bundle;ILandroid/app/IWallpaperManagerCallback;I)Landroid/os/ParcelFileDescriptor;
Lcom/android/server/wallpaper/WallpaperManagerService;->setWallpaperComponent(Landroid/content/ComponentName;)V
Lcom/android/server/wallpaper/WallpaperManagerService;->setWallpaperComponentChecked(Landroid/content/ComponentName;Ljava/lang/String;I)V
Lcom/android/server/webkit/WebViewUpdateService$BinderService;->changeProviderAndSetting(Ljava/lang/String;)Ljava/lang/String;
Lcom/android/server/webkit/WebViewUpdateService$BinderService;->enableFallbackLogic(Z)V
Lcom/android/server/wifi/p2p/WifiP2pServiceImpl;->getMessenger()Landroid/os/Messenger;
Lcom/android/server/wifi/p2p/WifiP2pServiceImpl;->getP2pStateMachineMessenger()Landroid/os/Messenger;
Lcom/android/server/wifi/p2p/WifiP2pServiceImpl;->setMiracastMode(I)V
Lcom/android/server/wifi/WifiServiceImpl;->acquireMulticastLock(Landroid/os/IBinder;Ljava/lang/String;)V
Lcom/android/server/wifi/WifiServiceImpl;->acquireWifiLock(Landroid/os/IBinder;ILjava/lang/String;Landroid/os/WorkSource;)Z
Lcom/android/server/wifi/WifiServiceImpl;->addOrUpdateNetwork(Landroid/net/wifi/WifiConfiguration;)I
Lcom/android/server/wifi/WifiServiceImpl;->addToBlacklist(Ljava/lang/String;)V
Lcom/android/server/wifi/WifiServiceImpl;->clearBlacklist()V
Lcom/android/server/wifi/WifiServiceImpl;->disableEphemeralNetwork(Ljava/lang/String;)V
Lcom/android/server/wifi/WifiServiceImpl;->disableNetwork(I)Z
Lcom/android/server/wifi/WifiServiceImpl;->disconnect()V
Lcom/android/server/wifi/WifiServiceImpl;->enableAggressiveHandover(I)V
Lcom/android/server/wifi/WifiServiceImpl;->enableNetwork(IZ)Z
Lcom/android/server/wifi/WifiServiceImpl;->enableVerboseLogging(I)V
Lcom/android/server/wifi/WifiServiceImpl;->enableWifiConnectivityManager(Z)V
Lcom/android/server/wifi/WifiServiceImpl;->factoryReset()V
Lcom/android/server/wifi/WifiServiceImpl;->getAggressiveHandover()I
Lcom/android/server/wifi/WifiServiceImpl;->getAllowScansWithTraffic()I
Lcom/android/server/wifi/WifiServiceImpl;->getConfigFile()Ljava/lang/String;
Lcom/android/server/wifi/WifiServiceImpl;->getConfiguredNetworks()Ljava/util/List;
Lcom/android/server/wifi/WifiServiceImpl;->getConnectionInfo()Landroid/net/wifi/WifiInfo;
Lcom/android/server/wifi/WifiServiceImpl;->getConnectionStatistics()Landroid/net/wifi/WifiConnectionStatistics;
Lcom/android/server/wifi/WifiServiceImpl;->getCountryCode()Ljava/lang/String;
Lcom/android/server/wifi/WifiServiceImpl;->getCurrentNetwork()Landroid/net/Network;
Lcom/android/server/wifi/WifiServiceImpl;->getDhcpInfo()Landroid/net/DhcpInfo;
Lcom/android/server/wifi/WifiServiceImpl;->getEnableAutoJoinWhenAssociated()Z
Lcom/android/server/wifi/WifiServiceImpl;->getFrequencyBand()I
Lcom/android/server/wifi/WifiServiceImpl;->getMatchingWifiConfig(Landroid/net/wifi/ScanResult;)Landroid/net/wifi/WifiConfiguration;
Lcom/android/server/wifi/WifiServiceImpl;->getPrivilegedConfiguredNetworks()Ljava/util/List;
Lcom/android/server/wifi/WifiServiceImpl;->getScanResults(Ljava/lang/String;)Ljava/util/List;
Lcom/android/server/wifi/WifiServiceImpl;->getSupportedFeatures()I
Lcom/android/server/wifi/WifiServiceImpl;->getVerboseLoggingLevel()I
Lcom/android/server/wifi/WifiServiceImpl;->getWifiApConfiguration()Landroid/net/wifi/WifiConfiguration;
Lcom/android/server/wifi/WifiServiceImpl;->getWifiApEnabledState()I
Lcom/android/server/wifi/WifiServiceImpl;->getWifiEnabledState()I
Lcom/android/server/wifi/WifiServiceImpl;->getWifiServiceMessenger()Landroid/os/Messenger;
Lcom/android/server/wifi/WifiServiceImpl;->getWpsNfcConfigurationToken(I)Ljava/lang/String;
Lcom/android/server/wifi/WifiServiceImpl;->initializeMulticastFiltering()V
Lcom/android/server/wifi/WifiServiceImpl;->isMulticastEnabled()Z
Lcom/android/server/wifi/WifiServiceImpl;->isScanAlwaysAvailable()Z
Lcom/android/server/wifi/WifiServiceImpl;->pingSupplicant()Z
Lcom/android/server/wifi/WifiServiceImpl;->reassociate()V
Lcom/android/server/wifi/WifiServiceImpl;->reconnect()V
Lcom/android/server/wifi/WifiServiceImpl;->releaseMulticastLock()V
Lcom/android/server/wifi/WifiServiceImpl;->releaseWifiLock(Landroid/os/IBinder;)Z
Lcom/android/server/wifi/WifiServiceImpl;->removeNetwork(I)Z
Lcom/android/server/wifi/WifiServiceImpl;->reportActivityInfo()Landroid/net/wifi/WifiActivityEnergyInfo;
Lcom/android/server/wifi/WifiServiceImpl;->requestActivityInfo(Landroid/os/ResultReceiver;)V
Lcom/android/server/wifi/WifiServiceImpl;->saveConfiguration()Z
Lcom/android/server/wifi/WifiServiceImpl;->setAllowScansWithTraffic(I)V
Lcom/android/server/wifi/WifiServiceImpl;->setCountryCode(Ljava/lang/String;Z)V
Lcom/android/server/wifi/WifiServiceImpl;->setEnableAutoJoinWhenAssociated(Z)Z
Lcom/android/server/wifi/WifiServiceImpl;->setFrequencyBand(IZ)V
Lcom/android/server/wifi/WifiServiceImpl;->setWifiApConfiguration(Landroid/net/wifi/WifiConfiguration;)V
Lcom/android/server/wifi/WifiServiceImpl;->setWifiApEnabled(Landroid/net/wifi/WifiConfiguration;Z)V
Lcom/android/server/wifi/WifiServiceImpl;->setWifiEnabled(Z)Z
Lcom/android/server/wifi/WifiServiceImpl;->startScan(Landroid/net/wifi/ScanSettings;Landroid/os/WorkSource;)V
Lcom/android/server/wifi/WifiServiceImpl;->updateWifiLockWorkSource(Landroid/os/IBinder;Landroid/os/WorkSource;)V
Lcom/android/server/wm/WindowManagerService;->addAppToken(ILandroid/view/IApplicationToken;IIIZZIIZZLandroid/graphics/Rect;Landroid/content/res/Configuration;IZZII)V
Lcom/android/server/wm/WindowManagerService;->addWindowToken(Landroid/os/IBinder;I)V
Lcom/android/server/wm/WindowManagerService;->clearForcedDisplayDensityForUser(II)V
Lcom/android/server/wm/WindowManagerService;->clearForcedDisplaySize(I)V
Lcom/android/server/wm/WindowManagerService;->clearWindowContentFrameStats(Landroid/os/IBinder;)Z
Lcom/android/server/wm/WindowManagerService;->disableKeyguard(Landroid/os/IBinder;Ljava/lang/String;)V
Lcom/android/server/wm/WindowManagerService;->dismissKeyguard()V
Lcom/android/server/wm/WindowManagerService;->executeAppTransition()V
Lcom/android/server/wm/WindowManagerService;->exitKeyguardSecurely(Landroid/view/IOnKeyguardExitResult;)V
Lcom/android/server/wm/WindowManagerService;->freezeRotation(I)V
Lcom/android/server/wm/WindowManagerService;->getWindowContentFrameStats(Landroid/os/IBinder;)Landroid/view/WindowContentFrameStats;
Lcom/android/server/wm/WindowManagerService;->isViewServerRunning()Z
Lcom/android/server/wm/WindowManagerService;->keyguardGoingAway(I)V
Lcom/android/server/wm/WindowManagerService;->lockNow(Landroid/os/Bundle;)V
Lcom/android/server/wm/WindowManagerService;->notifyAppResumed(Landroid/os/IBinder;ZZ)V
Lcom/android/server/wm/WindowManagerService;->notifyAppStopped(Landroid/os/IBinder;)V
Lcom/android/server/wm/WindowManagerService;->pauseKeyDispatching(Landroid/os/IBinder;)V
Lcom/android/server/wm/WindowManagerService;->prepareAppTransition(IZ)V
Lcom/android/server/wm/WindowManagerService;->reenableKeyguard(Landroid/os/IBinder;)V
Lcom/android/server/wm/WindowManagerService;->registerDockedStackListener(Landroid/view/IDockedStackListener;)V
Lcom/android/server/wm/WindowManagerService;->registerShortcutKey(JLcom/android/Iernal/policy/IShortcutService;)V
Lcom/android/server/wm/WindowManagerService;->removeAppToken(Landroid/os/IBinder;)V
Lcom/android/server/wm/WindowManagerService;->removeWindowToken(Landroid/os/IBinder;)V
Lcom/android/server/wm/WindowManagerService;->requestAssistScreenshot(Lcom/android/Iernal/app/IAssistScreenshotReceiver;)Z
Lcom/android/server/wm/WindowManagerService;->resumeKeyDispatching(Landroid/os/IBinder;)V
Lcom/android/server/wm/WindowManagerService;->screenshotApplications(Landroid/os/IBinder;IIIF)Landroid/graphics/Bitmap;
Lcom/android/server/wm/WindowManagerService;->screenshotWallpaper()Landroid/graphics/Bitmap;
Lcom/android/server/wm/WindowManagerService;->setAnimationScale(IF)V
Lcom/android/server/wm/WindowManagerService;->setAnimationScales([F)V
Lcom/android/server/wm/WindowManagerService;->setAppOrientation(Landroid/view/IApplicationToken;I)V
Lcom/android/server/wm/WindowManagerService;->setAppStartingWindow(Landroid/os/IBinder;Ljava/lang/String;ILandroid/content/res/CompatibilityInfo;Ljava/lang/CharSequence;IIIILandroid/os/IBinder;Z)Z
Lcom/android/server/wm/WindowManagerService;->setAppTask(Landroid/os/IBinder;IILandroid/graphics/Rect;Landroid/content/res/Configuration;IZ)V
Lcom/android/server/wm/WindowManagerService;->setAppVisibility(Landroid/os/IBinder;Z)V
Lcom/android/server/wm/WindowManagerService;->setEventDispatching(Z)V
Lcom/android/server/wm/WindowManagerService;->setFocusedApp(Landroid/os/IBinder;Z)V
Lcom/android/server/wm/WindowManagerService;->setForcedDisplayDensityForUser(III)V
Lcom/android/server/wm/WindowManagerService;->setForcedDisplayScalingMode(II)V
Lcom/android/server/wm/WindowManagerService;->setForcedDisplaySize(III)V
Lcom/android/server/wm/WindowManagerService;->setNewConfiguration(Landroid/content/res/Configuration;)[I
Lcom/android/server/wm/WindowManagerService;->setOverscan(IIIII)V
Lcom/android/server/wm/WindowManagerService;->setRecentsVisibility(Z)V
Lcom/android/server/wm/WindowManagerService;->setTvPipVisibility(Z)V
Lcom/android/server/wm/WindowManagerService;->startAppFreezingScreen(Landroid/os/IBinder;I)V
Lcom/android/server/wm/WindowManagerService;->startFreezingScreen(II)V
Lcom/android/server/wm/WindowManagerService;->startViewServer(I)Z
Lcom/android/server/wm/WindowManagerService;->statusBarVisibilityChanged(I)V
Lcom/android/server/wm/WindowManagerService;->stopAppFreezingScreen(Landroid/os/IBinder;Z)V
Lcom/android/server/wm/WindowManagerService;->stopFreezingScreen()V
Lcom/android/server/wm/WindowManagerService;->stopViewServer()Z
Lcom/android/server/wm/WindowManagerService;->thawRotation()V
Lcom/android/server/wm/WindowManagerService;->updateOrientationFromAppTokens(Landroid/content/res/Configuration;Landroid/os/IBinder;)Landroid/content/res/Configuration;

```

`src/obfuscapk/resources/java/DecryptAsset.java`:

```java
package com.decryptassetmanager;

import android.content.res.AssetManager;
import android.os.Build;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;

import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;

public class DecryptAsset {
    public static InputStream decryptAsset(AssetManager assetManager, String assetName) {
        try {
            return new FileInputStream(decryptAssetFileUsingContext(assetManager, assetName));
        } catch (Exception ignored) { }

        return null;
    }

    public static void loadEncryptedLibrary(Class invokingClass, String libraryName) {
        String architecture = Build.SUPPORTED_ABIS[0];
        String encryptedLibraryName = String.format("lib.%s.%s.so", architecture, libraryName);

        File decryptedLibrary = decryptAssetFileUsingClassLoader(invokingClass,
                encryptedLibraryName);
        if (decryptedLibrary != null && decryptedLibrary.exists()) {
            System.load(decryptedLibrary.getPath());
        }
    }

    private static byte[] readBytes(InputStream inputStream) throws IOException {
        byte[] array = new byte[1024];
        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
        while (true) {
            int read = inputStream.read(array);
            if (read == -1) {
                break;
            }
            byteArrayOutputStream.write(array, 0, read);
        }
        return byteArrayOutputStream.toByteArray();
    }

    private static File decryptAssetFileUsingContext(AssetManager assetManager, String assetName) {
        try {
            SecretKeySpec secretKeySpec = new SecretKeySpec(
                    "This-key-need-to-be-32-character".getBytes(), "AES");
            Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5PADDING");
            cipher.init(Cipher.DECRYPT_MODE, secretKeySpec);

            InputStream assetInputStream = assetManager.open(assetName);

            byte[] decryptedContent = cipher.doFinal(readBytes(assetInputStream));
            File tempFile = File.createTempFile("decrypted_", null);

            FileOutputStream fileOutputStream = new FileOutputStream(tempFile);
            fileOutputStream.write(decryptedContent);
            fileOutputStream.close();
            return tempFile;

        } catch (Exception ignored) { }

        return null;
    }

    private static File decryptAssetFileUsingClassLoader(Class invokingClass, String assetName) {
        try {
            SecretKeySpec secretKeySpec = new SecretKeySpec(
                    "This-key-need-to-be-32-character".getBytes(), "AES");
            Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5PADDING");
            cipher.init(Cipher.DECRYPT_MODE, secretKeySpec);

            InputStream assetInputStream = invokingClass.getClassLoader()
                    .getResourceAsStream(String.format("assets/%s", assetName));

            byte[] decryptedContent = cipher.doFinal(readBytes(assetInputStream));
            File tempFile = File.createTempFile("decrypted_", null);

            FileOutputStream fileOutputStream = new FileOutputStream(tempFile);
            fileOutputStream.write(decryptedContent);
            fileOutputStream.close();
            return tempFile;

        } catch (Exception ignored) { }

        return null;
    }
}

```

`src/obfuscapk/resources/libs_to_ignore.txt`:

```txt
afzkl/development/
android/arch/
android/content/
android/opengl/
android/support/
android/widget/
androidx/
anet/channel/
anetwork/channel/
anywheresoftware/
au/com/bytecode/opencsv/
biz/neoline/
butterknife/
ch/boye/httpclientandroidlib/
ch/qos/logback/
cn/domob/
cn/jiguang/
cn/jpush/android/
cn/sharesdk/
cn/smssdk/
cn/uc/gamesdk/
com/ace/universalimageloader/
com/actionbarsherlock/
com/activeandroid/
com/adfonic/
com/adjust/
com/admob/
com/adobe/
com/adsdk/
com/adsmogo/
com/adtech/
com/adwhirl/
com/adwo/
com/alibaba/fastjson/
com/alibaba/mtl/
com/alimama/mobile/
com/alipay/
com/aliyun/
com/amap/
com/amazon/ags/
com/amazon/device/
com/amazon/identity/
com/amazon/inapp/
com/amazon/insights/
com/amazonaws/
com/android/vending/
com/android/volley/
com/androidplot/
com/androidquery/
com/ansca/corona/
com/anzhi/market/
com/appbrain/
com/appbyme/
com/apperhand/
com/appflood/
com/applovin/
com/appmakr/
com/appodeal/
com/appquanta/
com/appsflyer/
com/appyet/
com/astuetz/
com/auth0/android/
com/auth0/jwt/
com/autonavi/
com/aviary/
com/avos/avoscloud/
com/badlogic/
com/baidu/android/
com/baidu/appx/
com/baidu/autoupdatesdk/
com/baidu/bdgame/
com/baidu/cyberplayer/
com/baidu/frontia/
com/baidu/location/
com/baidu/mapapi/
com/baidu/mobads/
com/baidu/mobstat/
com/baidu/mtjstatsdk/
com/baidu/navi/
com/baidu/navisdk/
com/baidu/paysdk/
com/baidu/platform/
com/baidu/sapi2/
com/baidu/searchsdk/
com/baidu/tiebasdk/
com/baidu/wallet/
com/bda/controller/
com/bea/xml/stream/
com/biznessapps/
com/bugsense/
com/bumptech/glide/
com/chartboost/sdk/
com/chineseall/reader/
com/commonsware/cwac/merge/
com/commonsware/cwac/sacklist/
com/comscore/
com/conduit/app/
com/coolcloud/uac/
com/coremedia/iso/
com/crashlytics/android/
com/crowdcompass/
com/daggertech/
com/daimajia/androidanimations/
com/data/
com/db4o/
com/deploygate/
com/digits/sdk/vcard/
com/doapps/
com/dobao/
com/dropbox/
com/duoku/
com/easemob/
com/esotericsoftware/
com/espian/showcaseview/
com/everyplay/
com/external/
com/facebook/
com/fasterxml/
com/flurry/android/
com/flurry/org/
com/flurry/sdk/
com/goodbarber/
com/google/ads/
com/google/analytics/
com/google/android/apps/dashclock/api/
com/google/android/exoplayer/
com/google/android/gcm/
com/google/android/gms/
com/google/android/material/
com/google/android/net/
com/google/android/vending/
com/google/android/youtube/
com/google/api/
com/google/appinventor/
com/google/common/
com/google/firebase/
com/google/gdata/
com/google/gson/
com/google/i18n/
com/google/inject/
com/google/maps/android/
com/google/protobuf/
com/google/tagmanager/
com/google/thirdparty/
com/google/zxing/
com/googlecode/apdfviewer/
com/handmark/pulltorefresh/
com/heyzap/
com/huawei/android/
com/huawei/ecs/
com/huntmads/
com/iapppay/
com/ibm/icu/
com/idddx/
com/idddx/sdk/
com/iflytek/speech/
com/iflytek/sunflower/
com/iflytek/thirdparty/
com/igaworks/
com/igexin/
com/immersion/hapticmediasdk/
com/inmobi/
com/inneractive/
com/ironsource/
com/iwanvi/
com/j256/
com/jakewharton/disklrucache/
com/jasonkostempski/
com/jayway/jsonpath/
com/jcodecraeer/xrecyclerview/progressindicator/
com/jcraft/jsch/
com/jirbo/adcolony/
com/jiubang/commerce/
com/jumptap/
com/kakao/talk/
com/kbeanie/imagechooser/
com/koushikdutta/async/
com/kuguo/ad/
com/leadbolt/
com/lenovo/lps/
com/letv/adlib/
com/letv/datastatistics/
com/letv/lepaysdk/
com/letv/sdk/
com/letvcloud/
com/lidroid/xutils/
com/loopj/
com/madhouse/android/ads/
com/magook/
com/magtab/
com/mashape/relocation/
com/maximono/
com/meitu/android/trivialdrivesample/
com/melnykov/fab/
com/milkmangames/extensions/android/coremobile/
com/millennialmedia/
com/mindprod/ledatastream/
com/mob/commons/
com/mob/tools/
com/mobcent/
com/mobclick/android/
com/mobeta/
com/mobfox/
com/mobisage/android/
com/mongodb/
com/mopub/
com/my/target/core/ui/
com/myappengine/
com/myshare/dynamic/
com/naef/jnlua/
com/nd/dianjin/
com/neatplug/u3d/plugins/
com/nerd/TapdaqUnityPlugin/
com/netease/nim/
com/netease/ntespm/
com/newrelic/
com/ngpinc/
com/nhaarman/listviewanimations/
com/nineoldandroids/
com/nokia/payment/
com/nostra13/
com/nuance/
com/nv/support/pulltorefresh/
com/onbarcode/
com/openfeint/
com/outlinegames/
com/papaya/
com/parse/
com/path/android/jobqueue/
com/paypal/
com/phonegap/
com/playhaven/
com/pocketchange/
com/polites/
com/pollfish/
com/prime31/
com/purplebrain/adbuddiz/
com/qihoo/gamecenter/
com/qihoo/psdk/
com/qihoo/stat/
com/qihoopp/framework/
com/qihoopp/qcoinpay/
com/qmoney/ui/
com/qoppa/
com/qwapi/
com/radiusnetworks/
com/readystatesoftware/sqliteasset/
com/renn/rennsdk/
com/revmob/
com/samsung/spen/
com/scoreloop/
com/sec/android/iap/
com/shengliwang/CarLogo/
com/sina/sso/
com/sina/weibo/
com/skplanet/
com/slidingmenu/
com/smaato/
com/spoledge/
com/sponsorpay/
com/squareup/okhttp/
com/squareup/otto/
com/squareup/picasso/
com/squareup/pollexor/
com/squareup/seismic/
com/squareup/tape/
com/squareup/timessquare/
com/startapp/
com/stericson/RootTools/
com/subsplash/
com/sun/activation/
com/sun/mail/
com/supersonic/adapters/supersonicads/
com/supersonic/mediationsdk/
com/supersonicads/sdk/
com/taobao/accs/
com/tapdaq/sdk/
com/tapdaq/tapdaqunityads/
com/tapit/
com/tapjoy/
com/tencent/android/tpush/
com/tencent/bugly/
com/tencent/common/
com/tencent/connect/
com/tencent/jsutil/
com/tencent/lbs/
com/tencent/map/
com/tencent/mm/
com/tencent/mobwin/
com/tencent/mta/
com/tencent/open/
com/tencent/plus/
com/tencent/qqconnect/
com/tencent/qzone/
com/tencent/record/
com/tencent/sdkutil/
com/tencent/smtt/
com/tencent/stat/
com/tencent/tauth/
com/tencent/utils/
com/tencent/webnet/
com/tencent/weibo/
com/tencent/weiyun/
com/tencent/wpa/
com/tencent/wxop/
com/tendcloud/tenddata/
com/threatmetrix/
com/turbomanage/httpclient/
com/umeng/analytics/
com/umeng/api/
com/umeng/common/
com/umeng/fb/
com/umeng/message/
com/umeng/newxp/view/
com/umeng/socialize/
com/umeng/socom/
com/umeng/update/
com/umeng/xp/
com/unionpay/mobile/android/
com/unionpay/sdk/
com/unionpay/tsmservice/
com/unity3d/ads/
com/urbanairship/
com/uservoice/uservoicesdk/
com/ut/mini/
com/uzmap/pkg/uzkit/
com/vercoop/
com/verizon/
com/viewpagerindicator/
com/vividsolutions/jts/
com/vjianke/pulltorefresh/
com/vl/pulltorefresh/
com/vpon/
com/vungle/
com/wm/pulltorefresh/
com/xiaomi/mipush/sdk/
com/xiaomi/push/
com/xiaomi/smack/
com/xiaomi/xmpush/
com/yandex/mobile/ads/
com/yixia/
cz/msebera/android/httpclient/
de/greenrobot/dao/
de/greenrobot/event/
de/keyboardsurfer/
fr/castorfle/
gnu/commonlisp/
gnu/ecmascript/
gnu/kawa/
gnu/mapping/
gnu/xml/
hirondelle/date4j/
im/quar/
info/guardianproject/bouncycastle/
io/dcloud/
io/fabric/sdk/
it/gmariotti/cardslib/
it/sauronsoftware/ftp4j/
javax/activation/
javax/annotation/
javax/jmdns/
javax/mail/
javax/servlet/
javax/ws/
junit/
kankan/wheel/
me/apla/cordova/
me/zhanghai/android/
microsoft/mappoint/
mobisocial/omlet/
mobisocial/omlib/
mono/android/
net/authorize/
net/hockeyapp/android/
net/lingala/zip4j/
net/minidev/json/
net/simonvt/menudrawer/
net/sourceforge/pinyin4j/
net/sourceforge/zbar/
net/tsz/afinal/
net/youmi/
nl/siegmann/epublib/
oauth/signpost/
okhttp3/
okio/
opentk/
org/achartengine/
org/anddev/andengine/
org/andengine/
org/android/agoo/
org/androidannotations/
org/apache/commons/
org/apache/cordova/
org/apache/harmony/
org/apache/http/
org/apache/james/
org/apache/log4j/
org/apache/tools/ant/
org/appcelerator/
org/aspectj/
org/bouncycastle/
org/ccil/cowan/tagsoup/
org/cocos2d/
org/cocos2dx/
org/codehaus/jackson/
org/dom4j/
org/ebookdroid/
org/geometerplus/zlibrary/
org/hamcrest/
org/htmlcleaner/
org/ice4j/
org/ini4j/
org/jaudiotagger/
org/java_websocket/
org/jaxen/
org/jdeferred/
org/jdom/
org/jdom2/
org/jivesoftware/
org/joda/time/
org/json/
org/jsoup/
org/junit/
org/kde/necessitas/ministro/
org/kobjects/
org/ksoap2/
org/kxml2/
org/lobobrowser/
org/mapsforge/
org/metalev/multitouch/
org/mozilla/intl/chardet/
org/mozilla/javascript/
org/mozilla/universalchardet/
org/msgpack/
org/nexage/sourcekit/mraid/
org/ocpsoft/prettytime/
org/openudid/
org/osmdroid/
org/scribe/
org/simpleframework/
org/slf4j/
org/spongycastle/
org/springframework/
org/tukaani/xz/
org/vudroid/
org/xbill/DNS/
org/xinhua/analytics/
org/xmlpull/
org/yaml/snakeyaml/
org/zywx/
pagerslidingtabstrip/
pdftron/
pl/polidea/
pts/PhoneGap/
retrofit/
retrofit2/
roboguice/
rx/internal/
safiap/framework/
shared_presage/com/
ti/imagefactory/
ti/modules/titanium/
twitter4j/
uk/co/senab/actionbarpulltorefresh/
v2/com/playhaven/
xamarin/
zfee/sdk/

```

`src/obfuscapk/resources/nop_valid_op_codes.txt`:

```txt
move
move/from16
move/16
move-wide
move-wide/from16
move-wide/16
move-object
move-object/from16
move-object/16
move-result
move-result-wide
move-result-object
move-exception
return-void
return
return-wide
return-object
const/4
const/16
const
const/high16
const-wide/16
const-wide/32
const-wide
const-wide/high16
const-string
const-string/jumbo
const-class
monitor-enter
monitor-exit
check-cast
instance-of
array-length
new-instance
new-array
filled-new-array
filled-new-array/range
throw
goto
goto/16
goto/32
cmpl-float
cmpg-float
cmpl-double
cmpg-double
cmp-long
if-eq
if-ne
if-lt
if-ge
if-gt
if-le
if-eqz
if-nez
if-ltz
if-gez
if-gtz
if-lez
aget
aget-wide
aget-object
aget-boolean
aget-byte
aget-char
aget-short
aput
aput-wide
aput-object
aput-boolean
aput-byte
aput-char
aput-short
iget
iget-wide
iget-object
iget-boolean
iget-byte
iget-char
iget-short
iput
iput-wide
iput-object
iput-boolean
iput-byte
iput-char
iput-short
sget
sget-wide
sget-object
sget-boolean
sget-byte
sget-char
sget-short
sput
sput-wide
sput-object
sput-boolean
sput-byte
sput-char
sput-short
neg-int
not-int
neg-long
not-long
neg-float
neg-double
int-to-long
int-to-float
int-to-double
long-to-int
long-to-float
long-to-double
float-to-int
float-to-long
float-to-double
double-to-int
double-to-long
double-to-float
int-to-byte
int-to-char
int-to-short
add-int
sub-int
mul-int
div-int
rem-int
and-int
or-int
xor-int
shl-int
shr-int
ushr-int
add-long
sub-long
mul-long
div-long
rem-long
and-long
or-long
xor-long
shl-long
shr-long
ushr-long
add-float
sub-float
mul-float
div-float
rem-float
add-double
sub-double
mul-double
div-double
rem-double
add-int/2addr
sub-int/2addr
mul-int/2addr
div-int/2addr
rem-int/2addr
and-int/2addr
or-int/2addr
xor-int/2addr
shl-int/2addr
shr-int/2addr
ushr-int/2addr
add-long/2addr
sub-long/2addr
mul-long/2addr
div-long/2addr
rem-long/2addr
and-long/2addr
or-long/2addr
xor-long/2addr
shl-long/2addr
shr-long/2addr
ushr-long/2addr
add-float/2addr
sub-float/2addr
mul-float/2addr
div-float/2addr
rem-float/2addr
add-double/2addr
sub-double/2addr
mul-double/2addr
div-double/2addr
rem-double/2addr
add-int/lit16
rsub-int
mul-int/lit16
div-int/lit16
rem-int/lit16
and-int/lit16
or-int/lit16
xor-int/lit16
add-int/lit8
rsub-int/lit8
mul-int/lit8
div-int/lit8
rem-int/lit8
and-int/lit8
or-int/lit8
xor-int/lit8
shl-int/lit8
shr-int/lit8
ushr-int/lit8

```

`src/obfuscapk/resources/smali/AdvancedApiReflection.smali`:

```smali
.class public Lcom/apireflectionmanager/AdvancedApiReflection;
.super Ljava/lang/Object;


# static fields
.field private static final obfuscatedMethods:Ljava/util/List;
    .annotation system Ldalvik/annotation/Signature;
        value = {
            "Ljava/util/List<",
            "Ljava/lang/reflect/Method;",
            ">;"
        }
    .end annotation
.end field


# direct methods
.method static constructor <clinit>()V
    .locals 4

    new-instance v0, Ljava/util/ArrayList;

    invoke-direct {v0}, Ljava/util/ArrayList;-><init>()V

    sput-object v0, Lcom/apireflectionmanager/AdvancedApiReflection;->obfuscatedMethods:Ljava/util/List;

    :try_start_0
#!code_to_replace!#
    :try_end_0
    .catch Ljava/lang/NoSuchMethodException; {:try_start_0 .. :try_end_0} :catch_0

    goto :goto_0

    :catch_0
    move-exception v0

    invoke-virtual {v0}, Ljava/lang/NoSuchMethodException;->printStackTrace()V

    :goto_0
    return-void
.end method

.method public constructor <init>()V
    .locals 0

    invoke-direct {p0}, Ljava/lang/Object;-><init>()V

    return-void
.end method

.method public static obfuscate(ILjava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;
    .locals 1

    :try_start_0
    sget-object v0, Lcom/apireflectionmanager/AdvancedApiReflection;->obfuscatedMethods:Ljava/util/List;

    invoke-interface {v0, p0}, Ljava/util/List;->get(I)Ljava/lang/Object;

    move-result-object p0

    check-cast p0, Ljava/lang/reflect/Method;

    invoke-virtual {p0, p1, p2}, Ljava/lang/reflect/Method;->invoke(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;

    move-result-object p0
    
    :try_end_0
    .catch Ljava/lang/IllegalAccessException; {:try_start_0 .. :try_end_0} :catch_1
    .catch Ljava/lang/reflect/InvocationTargetException; {:try_start_0 .. :try_end_0} :catch_0
    return-object p0

    :catch_0
    move-exception v0

    invoke-virtual {v0}, Ljava/lang/reflect/InvocationTargetException;->getCause()Ljava/lang/Throwable;

    move-result-object v0

    check-cast v0, Ljava/lang/Exception;

    throw v0

    :catch_1
    move-exception v0

    invoke-virtual {v0}, Ljava/lang/IllegalAccessException;->printStackTrace()V
    
    const/4 v0, 0x0

    return-object v0
.end method

```

`src/obfuscapk/resources/smali/ApiReflection.smali`:

```smali
.class public Lcom/apireflectionmanager/ApiReflection;
.super Ljava/lang/Object;


# static fields
.field private static final obfuscatedMethods:Ljava/util/List;
    .annotation system Ldalvik/annotation/Signature;
        value = {
            "Ljava/util/List<",
            "Ljava/lang/reflect/Method;",
            ">;"
        }
    .end annotation
.end field


# direct methods
.method static constructor <clinit>()V
    .locals 4

    new-instance v0, Ljava/util/ArrayList;

    invoke-direct {v0}, Ljava/util/ArrayList;-><init>()V

    sput-object v0, Lcom/apireflectionmanager/ApiReflection;->obfuscatedMethods:Ljava/util/List;

    :try_start_0
#!code_to_replace!#
    :try_end_0
    .catch Ljava/lang/NoSuchMethodException; {:try_start_0 .. :try_end_0} :catch_0

    goto :goto_0

    :catch_0
    move-exception v0

    invoke-virtual {v0}, Ljava/lang/NoSuchMethodException;->printStackTrace()V

    :goto_0
    return-void
.end method

.method public constructor <init>()V
    .locals 0

    invoke-direct {p0}, Ljava/lang/Object;-><init>()V

    return-void
.end method

.method public static obfuscate(ILjava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;
    .locals 1

    :try_start_0
    sget-object v0, Lcom/apireflectionmanager/ApiReflection;->obfuscatedMethods:Ljava/util/List;

    invoke-interface {v0, p0}, Ljava/util/List;->get(I)Ljava/lang/Object;

    move-result-object p0

    check-cast p0, Ljava/lang/reflect/Method;

    invoke-virtual {p0, p1, p2}, Ljava/lang/reflect/Method;->invoke(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;

    move-result-object p0
    
    :try_end_0
    .catch Ljava/lang/IllegalAccessException; {:try_start_0 .. :try_end_0} :catch_1
    .catch Ljava/lang/reflect/InvocationTargetException; {:try_start_0 .. :try_end_0} :catch_0
    return-object p0

    :catch_0
    move-exception v0

    invoke-virtual {v0}, Ljava/lang/reflect/InvocationTargetException;->getCause()Ljava/lang/Throwable;

    move-result-object v0

    check-cast v0, Ljava/lang/Exception;

    throw v0

    :catch_1
    move-exception v0

    invoke-virtual {v0}, Ljava/lang/IllegalAccessException;->printStackTrace()V
    
    const/4 v0, 0x0

    return-object v0
.end method

```

`src/obfuscapk/resources/smali/DecryptAsset.smali`:

```smali
.class public Lcom/decryptassetmanager/DecryptAsset;
.super Ljava/lang/Object;


# direct methods
.method public constructor <init>()V
    .locals 0

    invoke-direct {p0}, Ljava/lang/Object;-><init>()V

    return-void
.end method

.method public static decryptAsset(Landroid/content/res/AssetManager;Ljava/lang/String;)Ljava/io/InputStream;
    .locals 2

    :try_start_0
    new-instance v0, Ljava/io/FileInputStream;

    invoke-static {p0, p1}, Lcom/decryptassetmanager/DecryptAsset;->decryptAssetFileUsingContext(Landroid/content/res/AssetManager;Ljava/lang/String;)Ljava/io/File;

    move-result-object v1

    invoke-direct {v0, v1}, Ljava/io/FileInputStream;-><init>(Ljava/io/File;)V
    :try_end_0
    .catch Ljava/lang/Exception; {:try_start_0 .. :try_end_0} :catch_0

    :goto_0
    return-object v0

    :catch_0
    move-exception v0

    const/4 v0, 0x0

    goto :goto_0
.end method

.method private static decryptAssetFileUsingClassLoader(Ljava/lang/Class;Ljava/lang/String;)Ljava/io/File;
    .locals 11

    const/4 v6, 0x0

    :try_start_0
    new-instance v4, Ljavax/crypto/spec/SecretKeySpec;

    const-string/jumbo v7, "This-key-need-to-be-32-character"

    invoke-virtual {v7}, Ljava/lang/String;->getBytes()[B

    move-result-object v7

    const-string/jumbo v8, "AES"

    invoke-direct {v4, v7, v8}, Ljavax/crypto/spec/SecretKeySpec;-><init>([BLjava/lang/String;)V

    const-string/jumbo v7, "AES/ECB/PKCS5PADDING"

    invoke-static {v7}, Ljavax/crypto/Cipher;->getInstance(Ljava/lang/String;)Ljavax/crypto/Cipher;

    move-result-object v1

    const/4 v7, 0x2

    invoke-virtual {v1, v7, v4}, Ljavax/crypto/Cipher;->init(ILjava/security/Key;)V

    invoke-virtual {p0}, Ljava/lang/Class;->getClassLoader()Ljava/lang/ClassLoader;

    move-result-object v7

    const-string/jumbo v8, "assets/%s"

    const/4 v9, 0x1

    new-array v9, v9, [Ljava/lang/Object;

    const/4 v10, 0x0

    aput-object p1, v9, v10

    invoke-static {v8, v9}, Ljava/lang/String;->format(Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;

    move-result-object v8

    invoke-virtual {v7, v8}, Ljava/lang/ClassLoader;->getResourceAsStream(Ljava/lang/String;)Ljava/io/InputStream;

    move-result-object v0

    invoke-static {v0}, Lcom/decryptassetmanager/DecryptAsset;->readBytes(Ljava/io/InputStream;)[B

    move-result-object v7

    invoke-virtual {v1, v7}, Ljavax/crypto/Cipher;->doFinal([B)[B

    move-result-object v2

    const-string/jumbo v7, "decrypted_"

    const/4 v8, 0x0

    invoke-static {v7, v8}, Ljava/io/File;->createTempFile(Ljava/lang/String;Ljava/lang/String;)Ljava/io/File;

    move-result-object v5

    new-instance v3, Ljava/io/FileOutputStream;

    invoke-direct {v3, v5}, Ljava/io/FileOutputStream;-><init>(Ljava/io/File;)V

    invoke-virtual {v3, v2}, Ljava/io/FileOutputStream;->write([B)V

    invoke-virtual {v3}, Ljava/io/FileOutputStream;->close()V
    :try_end_0
    .catch Ljava/lang/Exception; {:try_start_0 .. :try_end_0} :catch_0

    :goto_0
    return-object v5

    :catch_0
    move-exception v7

    move-object v5, v6

    goto :goto_0
.end method

.method private static decryptAssetFileUsingContext(Landroid/content/res/AssetManager;Ljava/lang/String;)Ljava/io/File;
    .locals 9

    const/4 v6, 0x0

    :try_start_0
    new-instance v4, Ljavax/crypto/spec/SecretKeySpec;

    const-string/jumbo v7, "This-key-need-to-be-32-character"

    invoke-virtual {v7}, Ljava/lang/String;->getBytes()[B

    move-result-object v7

    const-string/jumbo v8, "AES"

    invoke-direct {v4, v7, v8}, Ljavax/crypto/spec/SecretKeySpec;-><init>([BLjava/lang/String;)V

    const-string/jumbo v7, "AES/ECB/PKCS5PADDING"

    invoke-static {v7}, Ljavax/crypto/Cipher;->getInstance(Ljava/lang/String;)Ljavax/crypto/Cipher;

    move-result-object v1

    const/4 v7, 0x2

    invoke-virtual {v1, v7, v4}, Ljavax/crypto/Cipher;->init(ILjava/security/Key;)V

    invoke-virtual {p0, p1}, Landroid/content/res/AssetManager;->open(Ljava/lang/String;)Ljava/io/InputStream;

    move-result-object v0

    invoke-static {v0}, Lcom/decryptassetmanager/DecryptAsset;->readBytes(Ljava/io/InputStream;)[B

    move-result-object v7

    invoke-virtual {v1, v7}, Ljavax/crypto/Cipher;->doFinal([B)[B

    move-result-object v2

    const-string/jumbo v7, "decrypted_"

    const/4 v8, 0x0

    invoke-static {v7, v8}, Ljava/io/File;->createTempFile(Ljava/lang/String;Ljava/lang/String;)Ljava/io/File;

    move-result-object v5

    new-instance v3, Ljava/io/FileOutputStream;

    invoke-direct {v3, v5}, Ljava/io/FileOutputStream;-><init>(Ljava/io/File;)V

    invoke-virtual {v3, v2}, Ljava/io/FileOutputStream;->write([B)V

    invoke-virtual {v3}, Ljava/io/FileOutputStream;->close()V
    :try_end_0
    .catch Ljava/lang/Exception; {:try_start_0 .. :try_end_0} :catch_0

    :goto_0
    return-object v5

    :catch_0
    move-exception v7

    move-object v5, v6

    goto :goto_0
.end method

.method public static loadEncryptedLibrary(Ljava/lang/Class;Ljava/lang/String;)V
    .locals 6

    const/4 v5, 0x0

    sget-object v3, Landroid/os/Build;->SUPPORTED_ABIS:[Ljava/lang/String;

    aget-object v0, v3, v5

    const-string/jumbo v3, "lib.%s.%s.so"

    const/4 v4, 0x2

    new-array v4, v4, [Ljava/lang/Object;

    aput-object v0, v4, v5

    const/4 v5, 0x1

    aput-object p1, v4, v5

    invoke-static {v3, v4}, Ljava/lang/String;->format(Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;

    move-result-object v2

    invoke-static {p0, v2}, Lcom/decryptassetmanager/DecryptAsset;->decryptAssetFileUsingClassLoader(Ljava/lang/Class;Ljava/lang/String;)Ljava/io/File;

    move-result-object v1

    if-eqz v1, :cond_0

    invoke-virtual {v1}, Ljava/io/File;->exists()Z

    move-result v3

    if-eqz v3, :cond_0

    invoke-virtual {v1}, Ljava/io/File;->getPath()Ljava/lang/String;

    move-result-object v3

    invoke-static {v3}, Ljava/lang/System;->load(Ljava/lang/String;)V

    :cond_0
    return-void
.end method

.method private static readBytes(Ljava/io/InputStream;)[B
    .locals 4
    .annotation system Ldalvik/annotation/Throws;
        value = {
            Ljava/io/IOException;
        }
    .end annotation

    const/16 v3, 0x400

    new-array v0, v3, [B

    new-instance v1, Ljava/io/ByteArrayOutputStream;

    invoke-direct {v1}, Ljava/io/ByteArrayOutputStream;-><init>()V

    :goto_0
    invoke-virtual {p0, v0}, Ljava/io/InputStream;->read([B)I

    move-result v2

    const/4 v3, -0x1

    if-ne v2, v3, :cond_0

    invoke-virtual {v1}, Ljava/io/ByteArrayOutputStream;->toByteArray()[B

    move-result-object v3

    return-object v3

    :cond_0
    const/4 v3, 0x0

    invoke-virtual {v1, v0, v3, v2}, Ljava/io/ByteArrayOutputStream;->write([BII)V

    goto :goto_0
.end method

```

`src/obfuscapk/resources/smali/DecryptString.smali`:

```smali
.class public Lcom/decryptstringmanager/DecryptString;
.super Ljava/lang/Object;


# direct methods
.method public constructor <init>()V
    .locals 0

    invoke-direct {p0}, Ljava/lang/Object;-><init>()V

    return-void
.end method

.method public static decipher(Ljava/lang/String;)Ljava/lang/String;
    .locals 6
    .annotation system Ldalvik/annotation/Throws;
        value = {
            Ljava/lang/Exception;
        }
    .end annotation

    const-string v0, "PBKDF2WithHmacSHA1"

    invoke-static {v0}, Ljavax/crypto/SecretKeyFactory;->getInstance(Ljava/lang/String;)Ljavax/crypto/SecretKeyFactory;

    move-result-object v0

    new-instance v1, Ljavax/crypto/spec/PBEKeySpec;

    const-string v2, "This-key-need-to-be-32-character"

    invoke-virtual {v2}, Ljava/lang/String;->toCharArray()[C

    move-result-object v2

    const-string v3, "This-key-need-to-be-32-character"

    invoke-virtual {v3}, Ljava/lang/String;->getBytes()[B

    move-result-object v3

    const/16 v4, 0x80

    const/16 v5, 0x100

    invoke-direct {v1, v2, v3, v4, v5}, Ljavax/crypto/spec/PBEKeySpec;-><init>([C[BII)V

    invoke-virtual {v0, v1}, Ljavax/crypto/SecretKeyFactory;->generateSecret(Ljava/security/spec/KeySpec;)Ljavax/crypto/SecretKey;

    move-result-object v0

    new-instance v1, Ljavax/crypto/spec/SecretKeySpec;

    invoke-interface {v0}, Ljavax/crypto/SecretKey;->getEncoded()[B

    move-result-object v0

    const-string v2, "AES"

    invoke-direct {v1, v0, v2}, Ljavax/crypto/spec/SecretKeySpec;-><init>([BLjava/lang/String;)V

    const-string v0, "AES/ECB/PKCS5Padding"

    invoke-static {v0}, Ljavax/crypto/Cipher;->getInstance(Ljava/lang/String;)Ljavax/crypto/Cipher;

    move-result-object v0

    const/4 v2, 0x2

    invoke-virtual {v0, v2, v1}, Ljavax/crypto/Cipher;->init(ILjava/security/Key;)V

    new-instance v1, Ljava/lang/String;

    invoke-static {p0}, Lcom/decryptstringmanager/DecryptString;->toByte(Ljava/lang/String;)[B

    move-result-object p0

    invoke-virtual {v0, p0}, Ljavax/crypto/Cipher;->doFinal([B)[B

    move-result-object p0

    invoke-direct {v1, p0}, Ljava/lang/String;-><init>([B)V

    return-object v1
.end method

.method public static decryptString(Ljava/lang/String;)Ljava/lang/String;
    .locals 0

    :try_start_0
    invoke-static {p0}, Lcom/decryptstringmanager/DecryptString;->decipher(Ljava/lang/String;)Ljava/lang/String;

    move-result-object p0
    :try_end_0
    .catch Ljava/lang/Exception; {:try_start_0 .. :try_end_0} :catch_0

    return-object p0

    :catch_0
    move-exception p0

    invoke-virtual {p0}, Ljava/lang/Exception;->printStackTrace()V

    const/4 p0, 0x0

    return-object p0
.end method

.method public static decryptStringArray([Ljava/lang/String;)[Ljava/lang/String;
    .locals 3

    array-length v0, p0

    new-array v0, v0, [Ljava/lang/String;

    const/4 v1, 0x0

    :goto_0
    array-length v2, p0

    if-ge v1, v2, :cond_0

    aget-object v2, p0, v1

    invoke-static {v2}, Lcom/decryptstringmanager/DecryptString;->decryptString(Ljava/lang/String;)Ljava/lang/String;

    move-result-object v2

    aput-object v2, v0, v1

    add-int/lit8 v1, v1, 0x1

    goto :goto_0

    :cond_0
    return-object v0
.end method

.method private static toByte(Ljava/lang/String;)[B
    .locals 6

    invoke-virtual {p0}, Ljava/lang/String;->length()I

    move-result v0

    const/4 v1, 0x2

    div-int/2addr v0, v1

    new-array v2, v0, [B

    const/4 v3, 0x0

    :goto_0
    if-ge v3, v0, :cond_0

    mul-int v4, v1, v3

    add-int/lit8 v5, v4, 0x2

    invoke-virtual {p0, v4, v5}, Ljava/lang/String;->substring(II)Ljava/lang/String;

    move-result-object v4

    const/16 v5, 0x10

    invoke-static {v4, v5}, Ljava/lang/Integer;->valueOf(Ljava/lang/String;I)Ljava/lang/Integer;

    move-result-object v4

    invoke-virtual {v4}, Ljava/lang/Integer;->byteValue()B

    move-result v4

    aput-byte v4, v2, v3

    add-int/lit8 v3, v3, 0x1

    goto :goto_0

    :cond_0
    return-object v2
.end method

```

`src/obfuscapk/resources/smali/overloaded_method_body.smali`:

```smali
    .locals 0

    const/16 p0, 0x2a

    const/16 p1, 0xd2

    mul-int p2, p0, p1

    add-int p3, p2, p1

    int-to-double p0, p3

    return-void
.end method


```

`src/obfuscapk/tool.py`:

```py
#!/usr/bin/env python3

import io
import logging
import os
import shutil
import subprocess
import tempfile
import zipfile
from typing import List


class Apktool(object):
    def __init__(self):
        self.logger = logging.getLogger(
            "{0}.{1}".format(__name__, self.__class__.__name__)
        )

        if "APKTOOL_PATH" in os.environ:
            self.apktool_path: str = os.environ["APKTOOL_PATH"]
        else:
            self.apktool_path: str = "apktool"

        full_apktool_path = shutil.which(self.apktool_path)

        # Make sure to use the full path of the executable (needed for cross-platform
        # compatibility).
        if full_apktool_path is None:
            raise RuntimeError(
                'Something is wrong with executable "{0}"'.format(self.apktool_path)
            )
        else:
            self.apktool_path = full_apktool_path

    def decode(
        self, apk_path: str, output_dir_path: str = None, force: bool = False
    ) -> str:
        # Check if the apk file to decode is a valid file.
        if not os.path.isfile(apk_path):
            self.logger.error('Unable to find file "{0}"'.format(apk_path))
            raise FileNotFoundError('Unable to find file "{0}"'.format(apk_path))

        # If no output directory is specified, use a new directory in the same
        # directory as the apk file to decode.
        if not output_dir_path:
            output_dir_path = os.path.join(
                os.path.dirname(apk_path),
                os.path.splitext(os.path.basename(apk_path))[0],
            )
            self.logger.debug(
                "No output directory provided, the result will be saved in the "
                "same directory as the input file, in a directory with the same "
                'name as the input file: "{0}"'.format(output_dir_path)
            )

        # If an output directory is provided, make sure that the path to that
        # directory exists (the final directory will be created by apktool).
        elif not os.path.isdir(os.path.dirname(output_dir_path)):
            self.logger.error(
                'Unable to find output directory "{0}", apktool won\'t be able to '
                'create the directory "{1}"'.format(
                    os.path.dirname(output_dir_path), output_dir_path
                )
            )
            raise NotADirectoryError(
                'Unable to find output directory "{0}", apktool won\'t be able to '
                'create the directory "{1}"'.format(
                    os.path.dirname(output_dir_path), output_dir_path
                )
            )

        # Inform the user if an existing output directory is provided without the
        # "force" flag.
        if os.path.isdir(output_dir_path) and not force:
            self.logger.error(
                'Output directory "{0}" already exists, use the "force" flag '
                "to overwrite".format(output_dir_path)
            )
            raise FileExistsError(
                'Output directory "{0}" already exists, use the "force" flag '
                "to overwrite".format(output_dir_path)
            )

        decode_cmd: List[str] = [
            self.apktool_path,
            "--frame-path",
            tempfile.gettempdir(),
            "d",
            apk_path,
            "-o",
            output_dir_path,
        ]

        if force:
            decode_cmd.insert(4, "--force")

        try:
            self.logger.info(
                'Running decode command "{0}"'.format(" ".join(decode_cmd))
            )
            # A new line character is sent as input since newer versions of Apktool
            # have an interactive prompt on Windows where the user should press a key.
            output = subprocess.check_output(
                decode_cmd, stderr=subprocess.STDOUT, input=b"\n"
            ).strip()
            if b"Exception in thread " in output:
                # Report exception raised in Apktool.
                raise subprocess.CalledProcessError(1, decode_cmd, output)
            return output.decode(errors="replace")
        except subprocess.CalledProcessError as e:
            self.logger.error(
                "Error during decode command: {0}".format(
                    e.output.decode(errors="replace") if e.output else e
                )
            )
            raise
        except Exception as e:
            self.logger.error("Error during decoding: {0}".format(e))
            raise

    def build(
        self, source_dir_path: str, output_apk_path: str = None, use_aapt2: bool = False
    ) -> str:
        # Check if the input directory exists.
        if not os.path.isdir(source_dir_path):
            self.logger.error(
                'Unable to find source directory "{0}"'.format(source_dir_path)
            )
            raise NotADirectoryError(
                'Unable to find source directory "{0}"'.format(source_dir_path)
            )

        # If no output apk path is specified, the new apk will be saved in the
        # default path: <source_dir_path>/dist/<source_dir_name>.apk
        if not output_apk_path:
            output_apk_path = os.path.join(
                source_dir_path,
                "dist",
                "{0}.apk".format(os.path.basename(source_dir_path)),
            )
            self.logger.debug(
                "No output apk path provided, the new apk will be saved in the "
                'default path: "{0}"'.format(output_apk_path)
            )

        build_cmd: List[str] = [
            self.apktool_path,
            "--frame-path",
            tempfile.gettempdir(),
            "b",
            "--force-all",
            source_dir_path,
            "-o",
            output_apk_path,
        ]

        if use_aapt2:
            build_cmd.insert(-2, "--use-aapt2")

        try:
            self.logger.info('Running build command "{0}"'.format(" ".join(build_cmd)))
            # A new line character is sent as input since newer versions of Apktool
            # have an interactive prompt on Windows where the user should press a key.
            output = subprocess.check_output(
                build_cmd, stderr=subprocess.STDOUT, input=b"\n"
            ).strip()
            if (
                b"brut.directory.PathNotExist: " in output
                or b"Exception in thread " in output
            ):
                # Report exception raised in Apktool.
                raise subprocess.CalledProcessError(1, build_cmd, output)

            if not os.path.isfile(output_apk_path):
                raise FileNotFoundError(
                    '"{0}" was not built correctly. Apktool output:\n{1}'.format(
                        output_apk_path, output.decode(errors="replace")
                    )
                )

            return output.decode(errors="replace")
        except subprocess.CalledProcessError as e:
            self.logger.error(
                "Error during build command: {0}".format(
                    e.output.decode(errors="replace") if e.output else e
                )
            )
            raise
        except Exception as e:
            self.logger.error("Error during building: {0}".format(e))
            raise


class Zipalign(object):
    def __init__(self):
        self.logger = logging.getLogger(
            "{0}.{1}".format(__name__, self.__class__.__name__)
        )

        if "ZIPALIGN_PATH" in os.environ:
            self.zipalign_path: str = os.environ["ZIPALIGN_PATH"]
        else:
            self.zipalign_path: str = "zipalign"

        full_zipalign_path = shutil.which(self.zipalign_path)

        # Make sure to use the full path of the executable (needed for cross-platform
        # compatibility).
        if full_zipalign_path is None:
            raise RuntimeError(
                'Something is wrong with executable "{0}"'.format(self.zipalign_path)
            )
        else:
            self.zipalign_path = full_zipalign_path

    def align(self, apk_path: str) -> str:
        # Check if the apk file to align is a valid file.
        if not os.path.isfile(apk_path):
            self.logger.error('Unable to find file "{0}"'.format(apk_path))
            raise FileNotFoundError('Unable to find file "{0}"'.format(apk_path))

        # Since zipalign cannot be run inplace, a temp file will be created.
        apk_copy_path = "{0}.copy.apk".format(
            os.path.join(
                os.path.dirname(apk_path),
                os.path.splitext(os.path.basename(apk_path))[0],
            )
        )

        try:
            apk_copy_path = shutil.copy2(apk_path, apk_copy_path)

            align_cmd = [
                self.zipalign_path,
                "-p",
                "-v",
                "-f",
                "4",
                apk_copy_path,
                apk_path,
            ]

            self.logger.info('Running align command "{0}"'.format(" ".join(align_cmd)))
            output = subprocess.check_output(
                align_cmd, stderr=subprocess.STDOUT
            ).strip()
            return output.decode(errors="replace")
        except subprocess.CalledProcessError as e:
            self.logger.error(
                "Error during align command: {0}".format(
                    e.output.decode(errors="replace") if e.output else e
                )
            )
            raise
        except Exception as e:
            self.logger.error("Error during aligning: {0}".format(e))
            raise
        finally:
            # Remove the temp file used for zipalign.
            if os.path.isfile(apk_copy_path):
                os.remove(apk_copy_path)


class ApkSigner(object):
    def __init__(self):
        self.logger = logging.getLogger(
            "{0}.{1}".format(__name__, self.__class__.__name__)
        )

        if "APKSIGNER_PATH" in os.environ:
            self.apksigner_path: str = os.environ["APKSIGNER_PATH"]
        else:
            self.apksigner_path: str = "apksigner"

        full_apksigner_path = shutil.which(self.apksigner_path)

        # Make sure to use the full path of the executable (needed for cross-platform
        # compatibility).
        if full_apksigner_path is None:
            raise RuntimeError(
                'Something is wrong with executable "{0}"'.format(self.apksigner_path)
            )
        else:
            self.apksigner_path = full_apksigner_path

    def sign(
        self,
        apk_path: str,
        keystore_file_path: str,
        keystore_password: str,
        key_alias: str,
        key_password: str = None,
    ) -> str:
        # Check if the apk file to sign is a valid file.
        if not os.path.isfile(apk_path):
            self.logger.error('Unable to find file "{0}"'.format(apk_path))
            raise FileNotFoundError('Unable to find file "{0}"'.format(apk_path))

        sign_cmd: List[str] = [
            self.apksigner_path,
            "sign",
            "-v",
            "--ks",
            keystore_file_path,
            "--ks-key-alias",
            key_alias,
            "--ks-pass",
            f"pass:{keystore_password}",
            apk_path,
        ]

        if key_password:
            sign_cmd.insert(-1, "--key-pass")
            sign_cmd.insert(-1, f"pass:{key_password}")

        try:
            self.logger.info('Running sign command "{0}"'.format(" ".join(sign_cmd)))
            output = subprocess.check_output(sign_cmd, stderr=subprocess.STDOUT).strip()
            return output.decode(errors="replace")
        except subprocess.CalledProcessError as e:
            self.logger.error(
                "Error during sign command: {0}".format(
                    e.output.decode(errors="replace") if e.output else e
                )
            )
            raise
        except Exception as e:
            self.logger.error("Error during signing: {0}".format(e))
            raise

    def resign(
        self,
        apk_path: str,
        keystore_file_path: str,
        keystore_password: str,
        key_alias: str,
        key_password: str = None,
    ) -> str:
        # If present, delete the old signature of the apk and then sign it with the
        # new signature. Since Python doesn't allow directly deleting a file inside an
        # archive, an OS independent solution is to create a new archive without
        # including the signature files.

        try:
            unsigned_apk_buffer = io.BytesIO()

            with zipfile.ZipFile(apk_path, "r") as current_apk:
                # Check if the current apk is already signed.
                if any(
                    entry.filename.startswith("META-INF/")
                    for entry in current_apk.infolist()
                ):
                    self.logger.info(
                        'Removing current signature from apk "{0}"'.format(apk_path)
                    )

                    # Create a new in-memory archive without the signature.
                    with zipfile.ZipFile(
                        unsigned_apk_buffer, "w"
                    ) as unsigned_apk_zip_buffer:
                        for entry in current_apk.infolist():
                            if not entry.filename.startswith("META-INF/"):
                                unsigned_apk_zip_buffer.writestr(
                                    entry, current_apk.read(entry.filename)
                                )

                    # Write the in-memory archive to disk.
                    with open(apk_path, "wb") as unsigned_apk:
                        unsigned_apk.write(unsigned_apk_buffer.getvalue())

        except Exception as e:
            self.logger.error(
                "Error during the removal of the old signature: {0}".format(e)
            )
            raise

        return self.sign(
            apk_path, keystore_file_path, keystore_password, key_alias, key_password
        )

```

`src/obfuscapk/toolbundledecompiler.py`:

```py
#!/usr/bin/env python3

import logging
import os
import platform
import shutil
import subprocess
from typing import List


class BundleDecompiler(object):
    def __init__(self):
        self.logger = logging.getLogger(
            "{0}.{1}".format(__name__, self.__class__.__name__)
        )

        if platform.system() == "Windows":
            self.logger.warning(
                "BundleDecompiler is not yet available on Windows platform"
            )
            return

        if "BUNDLE_DECOMPILER_PATH" in os.environ:
            self.bundledecompiler_path: str = os.environ["BUNDLE_DECOMPILER_PATH"]
        else:
            self.bundledecompiler_path: str = "BundleDecompiler.jar"

        full_bundledecompiler_path = shutil.which(self.bundledecompiler_path)

        # Make sure bundle decompiler is available
        if not os.path.isfile(full_bundledecompiler_path):
            raise RuntimeError(
                'Cannot find BundleDecompiler with executable "{0}"'.format(
                    full_bundledecompiler_path
                )
            )

        # Make sure to use the full path of the executable (needed for cross-platform
        # compatibility).
        if full_bundledecompiler_path is None:
            raise RuntimeError(
                'Something is wrong with executable "{0}"'.format(
                    self.bundledecompiler_path
                )
            )
        else:
            self.bundledecompiler_path = full_bundledecompiler_path

    def decode(
        self, aab_path: str, output_dir_path: str = None, force: bool = False
    ) -> str:
        if platform.system() == "Windows":
            raise NotImplementedError(
                "BundleDecompiler is not yet available on Windows platform"
            )

        # Check if the aab file to decode is a valid file.
        if not os.path.isfile(aab_path):
            self.logger.error('Unable to find file "{0}"'.format(aab_path))
            raise FileNotFoundError('Unable to find file "{0}"'.format(aab_path))

        # If no output directory is specified, use a new directory in the same
        # directory as the aab file to decode.
        if not output_dir_path:
            output_dir_path = os.path.join(
                os.path.dirname(aab_path),
                os.path.splitext(os.path.basename(aab_path))[0],
            )
            self.logger.debug(
                "No output directory provided, the result will be saved in the "
                "same directory as the input file, in a directory with the same "
                'name as the input file: "{0}"'.format(output_dir_path)
            )

        # If an output directory is provided, make sure that the path to that
        # directory exists (the final directory will be created by aabtool).
        elif not os.path.isdir(os.path.dirname(output_dir_path)):
            self.logger.error(
                'Unable to find output directory "{0}", aabtool won\'t be able to '
                'create the directory "{1}"'.format(
                    os.path.dirname(output_dir_path), output_dir_path
                )
            )
            raise NotADirectoryError(
                'Unable to find output directory "{0}", aabtool won\'t be able to '
                'create the directory "{1}"'.format(
                    os.path.dirname(output_dir_path), output_dir_path
                )
            )

        # Inform the user if an existing output directory is provided without the
        # "force" flag.
        if os.path.isdir(output_dir_path) and not force:
            self.logger.error(
                'Output directory "{0}" already exists, use the "force" flag '
                "to overwrite".format(output_dir_path)
            )
            raise FileExistsError(
                'Output directory "{0}" already exists, use the "force" flag '
                "to overwrite".format(output_dir_path)
            )

        decode_cmd: List[str] = [
            "java",
            "-jar",
            self.bundledecompiler_path,
            "d",
            "--in=" + aab_path,
            "--out=" + output_dir_path,
        ]

        if force:
            self.logger.warning("Bundle Decompiler does not support force")

        try:
            self.logger.info(
                'Running decode command "{0}"'.format(" ".join(decode_cmd))
            )
            # A new line character is sent as input since newer versions of aabtool
            # have an interactive prompt on Windows where the user should press a key.
            output = subprocess.check_output(
                decode_cmd, stderr=subprocess.STDOUT, input=b"\n"
            ).strip()
            if b"Exception in thread " in output:
                # Report exception raised in aabtool.
                raise subprocess.CalledProcessError(1, decode_cmd, output)
            return output.decode(errors="replace")
        except subprocess.CalledProcessError as e:
            self.logger.error(
                "Error during decode command: {0}".format(
                    e.output.decode(errors="replace") if e.output else e
                )
            )
            raise
        except Exception as e:
            self.logger.error("Error during decoding: {0}".format(e))
            raise

    def build(self, source_dir_path: str, output_aab_path: str = None) -> str:
        if platform.system() == "Windows":
            raise NotImplementedError(
                "BundleDecompiler is not yet available on Windows platform"
            )

        # Check if the input directory exists.
        if not os.path.isdir(source_dir_path):
            self.logger.error(
                'Unable to find source directory "{0}"'.format(source_dir_path)
            )
            raise NotADirectoryError(
                'Unable to find source directory "{0}"'.format(source_dir_path)
            )

        # If no output aab path is specified, the new aab will be saved in the
        # default path: <source_dir_path>/dist/<source_dir_name>.aab
        if not output_aab_path:
            output_aab_path = os.path.join(
                source_dir_path,
                "output",
                "{0}.aab".format(os.path.basename(source_dir_path)),
            )
            self.logger.debug(
                "No output aab path provided, the new aab will be saved in the "
                'default path: "{0}"'.format(output_aab_path)
            )

        build_cmd: List[str] = [
            "java",
            "-jar",
            self.bundledecompiler_path,
            "b",
            "--in=" + source_dir_path,
            "--out=" + output_aab_path,
        ]

        try:
            self.logger.info('Running build command "{0}"'.format(" ".join(build_cmd)))
            # A new line character is sent as input since newer versions of aabtool
            # have an interactive prompt on Windows where the user should press a key.
            output = subprocess.check_output(
                build_cmd, stderr=subprocess.STDOUT, input=b"\n"
            ).strip()
            if (
                b"brut.directory.PathNotExist: " in output
                or b"Exception in thread " in output
            ):
                # Report exception raised in aabtool.
                raise subprocess.CalledProcessError(1, build_cmd, output)

            if not os.path.isfile(output_aab_path):
                raise FileNotFoundError(
                    '"{0}" was not built correctly. aabtool output:\n{1}'.format(
                        output_aab_path, output.decode(errors="replace")
                    )
                )

            return output.decode(errors="replace")
        except subprocess.CalledProcessError as e:
            self.logger.error(
                "Error during build command: {0}".format(
                    e.output.decode(errors="replace") if e.output else e
                )
            )
            raise
        except Exception as e:
            self.logger.error("Error during building: {0}".format(e))
            raise


class AABSigner(object):
    def __init__(self):
        self.logger = logging.getLogger(
            "{0}.{1}".format(__name__, self.__class__.__name__)
        )

        if platform.system() == "Windows":
            self.logger.warning(
                "BundleDecompiler is not yet available on Windows platform"
            )
            return

        if "BUNDLE_DECOMPILER_PATH" in os.environ:
            self.aabsigner_path: str = os.environ["BUNDLE_DECOMPILER_PATH"]
        else:
            self.aabsigner_path: str = "BundleDecompiler.jar"

        full_aabsigner_path = shutil.which(self.aabsigner_path)

        # Make sure to use the full path of the executable (needed for cross-platform
        # compatibility).
        if full_aabsigner_path is None:
            raise RuntimeError(
                'Something is wrong with executable "{0}"'.format(self.aabsigner_path)
            )
        else:
            self.aabsigner_path = full_aabsigner_path

    def sign(
        self,
        aab_path: str,
    ) -> str:
        if platform.system() == "Windows":
            raise NotImplementedError(
                "BundleDecompiler is not yet available on Windows platform"
            )

        # Check if the aab file to sign is a valid file.
        if not os.path.isfile(aab_path):
            self.logger.error('Unable to find file "{0}"'.format(aab_path))
            raise FileNotFoundError('Unable to find file "{0}"'.format(aab_path))

        sign_cmd: List[str] = [
            "java",
            "-jar",
            self.aabsigner_path,
            "sign-bundle",
            "--in=" + aab_path,
            "--out=" + aab_path.replace(".aab", "_signed.aab"),
        ]

        try:
            self.logger.info('Running sign command "{0}"'.format(" ".join(sign_cmd)))
            output = subprocess.check_output(sign_cmd, stderr=subprocess.STDOUT).strip()
            return output.decode(errors="replace")
        except subprocess.CalledProcessError as e:
            self.logger.error(
                "Error during sign command: {0}".format(
                    e.output.decode(errors="replace") if e.output else e
                )
            )
            raise
        except Exception as e:
            self.logger.error("Error during signing: {0}".format(e))
            raise

```

`src/obfuscapk/util.py`:

```py
#!/usr/bin/env python3

import itertools
import logging
import os
import random
import re
import string
from contextlib import contextmanager
from hashlib import md5, sha256
from typing import List

from tqdm import tqdm

logger = logging.getLogger(__name__)

# A seed to be used for random operations.
random_seed = 42
random.seed(random_seed)

########################################################################################
#                                Common regex patterns.                                #
########################################################################################

# L<class_name>;  # Every class name starts with L and ends with ;
class_name_pattern = re.compile(r"L[^():\s]+?;", re.UNICODE)

# .class <other_optional_stuff> <class_name;>  # Every class name ends with ;
class_pattern = re.compile(r"\.class.+?(?P<class_name>\S+?;)", re.UNICODE)

# .super <class_name;>  # Every class name ends with ;
super_class_pattern = re.compile(r"\.super\s(?P<class_name>\S+?;)", re.UNICODE)

# .locals <number>
locals_pattern = re.compile(r"\s+\.locals\s(?P<local_count>\d+)")

# .field <other_optional_stuff> <field_name>:<field_type> <optional_initialization>
field_pattern = re.compile(
    r"\.field.+?(?P<field_name>\S+?):" r"(?P<field_type>\S+)", re.UNICODE
)

# .method <other_optional_stuff> <method_name>(<param>)<return_type>
method_pattern = re.compile(
    r"\.method.+?(?P<method_name>\S+?)"
    r"\((?P<method_param>\S*?)\)"
    r"(?P<method_return>\S+)",
    re.UNICODE,
)

# <spaces> value = <class_name>-><method>(<param>)<return_type>
annotation_method_pattern = re.compile(
    r"\s+value\s=\s(?P<method_object>\S+?)"
    r"->(?P<method_name>\S+?)"
    r"\((?P<method_param>\S*?)\)"
    r"(?P<method_return>\S+)",
    re.UNICODE,
)

# <spaces> <usage_type> <param>, <field_object>-><field_name>:<field_type>
field_usage_pattern = re.compile(
    r"\s+(?P<usage_type>[is](get|put)\S*)\s"
    r"(?P<field_param>[vp0-9,\s]+),\s"
    r"(?P<field_object>\S+?)"
    r"->(?P<field_name>\S+?):"
    r"(?P<field_type>\S+)",
    re.UNICODE,
)

# <spaces> invoke-<type> {<passed_param>}, <class_name>-><method>(<param>)<return_type>
invoke_pattern = re.compile(
    r"\s+(?P<invoke_type>invoke-\S+)\s"
    r"{(?P<invoke_pass>[vp0-9,.\s]*)},\s"
    r"(?P<invoke_object>\S+?)"
    r"->(?P<invoke_method>\S+?)"
    r"\((?P<invoke_param>\S*?)\)"
    r"(?P<invoke_return>\S+)",
    re.UNICODE,
)

# <spaces> const-string <register>, "<string>"  # This also matches const-string/jumbo
const_string_pattern = re.compile(
    r"\s+const-string(/jumbo)?\s(?P<register>[vp0-9]+),\s" r'"(?P<string>.+)"',
    re.UNICODE,
)


########################################################################################


# When iterating over list L, "for element in show_list_progress(L, interactive=True)"
# will show a progress bar. When setting "interactive=False", no progress bar will be
# shown. While using this method, no other code should write to standard output.
def show_list_progress(
    the_list: list,
    interactive: bool = False,
    unit: str = "file",
    description: str = None,
):
    if not interactive:
        return the_list
    else:
        return tqdm(
            the_list,
            dynamic_ncols=True,
            unit=unit,
            desc=description,
            bar_format="{l_bar}{bar}|[{elapsed}<{remaining}, {rate_fmt}]",
        )


def get_random_int(min_int: int, max_int: int) -> int:
    return random.randint(min_int, max_int)


def get_random_string(length: int) -> str:
    return "".join(random.choices(string.ascii_letters, k=length))


def get_random_list_permutations(input_list: list) -> list:
    permuted_list = list(itertools.permutations(input_list))
    random.shuffle(permuted_list)
    return permuted_list


def get_file_hash(file_path: str, hash_function, block_size=65536) -> str:
    with open(file_path, "rb", buffering=0) as f:
        for chunk in iter(lambda: f.read(block_size), b""):
            hash_function.update(chunk)
    return hash_function.hexdigest()


def md5sum(file_path: str) -> str:
    return get_file_hash(file_path, md5())


def sha256sum(file_path: str) -> str:
    return get_file_hash(file_path, sha256())


def get_string_md5(input_string: str) -> str:
    return md5(input_string.encode()).hexdigest()


# Adapted from https://www.zopatista.com/python/2013/11/26/inplace-file-rewriting/
@contextmanager
def inplace_edit_file(file_name: str):
    """
    Allow for a file to be replaced with new content.

    Yield a tuple of (readable, writable) file objects, where writable replaces
    readable. If an exception occurs, the old file is restored, removing the
    written data.
    """

    backup_file_name = "{0}{1}{2}".format(file_name, os.extsep, "bak")

    try:
        os.unlink(backup_file_name)
    except OSError:
        pass
    os.rename(file_name, backup_file_name)

    readable = open(backup_file_name, "r", encoding="utf-8")
    try:
        perm = os.fstat(readable.fileno()).st_mode
    except OSError:
        writable = open(file_name, "w", encoding="utf-8", newline="")
    else:
        os_mode = os.O_CREAT | os.O_WRONLY | os.O_TRUNC
        if hasattr(os, "O_BINARY"):
            os_mode |= os.O_BINARY
        fd = os.open(file_name, os_mode, perm)
        writable = open(fd, "w", encoding="utf-8", newline="")
        try:
            if hasattr(os, "chmod"):
                os.chmod(file_name, perm)
        except OSError:
            pass
    try:
        yield readable, writable
    except Exception as e:
        try:
            os.unlink(file_name)
        except OSError:
            pass
        os.rename(backup_file_name, file_name)

        logger.error(
            'Error during inplace editing file "{0}": {1}'.format(file_name, e)
        )
        raise
    finally:
        readable.close()
        writable.close()
        try:
            os.unlink(backup_file_name)
        except OSError:
            pass


def get_text_from_file(file_name: str) -> str:
    try:
        with open(file_name, "r", encoding="utf-8") as file:
            return file.read()
    except Exception as e:
        logger.error('Error during reading file "{0}": {1}'.format(file_name, e))
        raise


def get_non_empty_lines_from_file(file_name: str) -> List[str]:
    try:
        with open(file_name, "r", encoding="utf-8") as file:
            # Return a list with the non blank lines contained in the file.
            return list(filter(None, (line.rstrip() for line in file)))
    except Exception as e:
        logger.error('Error during reading file "{0}": {1}'.format(file_name, e))
        raise


# Adapted from https://github.com/pkumza/LiteRadar
def get_libs_to_ignore() -> List[str]:
    return get_non_empty_lines_from_file(
        os.path.join(os.path.dirname(__file__), "resources", "libs_to_ignore.txt")
    )


# Adapted from https://github.com/reddr/axplorer
def get_dangerous_api() -> List[str]:
    return get_non_empty_lines_from_file(
        os.path.join(os.path.dirname(__file__), "resources", "dangerous_api.txt")
    )


def get_nop_valid_op_codes() -> List[str]:
    return get_non_empty_lines_from_file(
        os.path.join(os.path.dirname(__file__), "resources", "nop_valid_op_codes.txt")
    )


def get_code_block_valid_op_codes() -> List[str]:
    return get_non_empty_lines_from_file(
        os.path.join(
            os.path.dirname(__file__), "resources", "code_block_valid_op_codes.txt"
        )
    )


def get_android_class_names() -> List[str]:
    return get_non_empty_lines_from_file(
        os.path.join(
            os.path.dirname(__file__), "resources", "android_class_names_api_27.txt"
        )
    )


def get_smali_method_overload() -> str:
    return get_text_from_file(
        os.path.join(
            os.path.dirname(__file__),
            "resources",
            "smali",
            "overloaded_method_body.smali",
        )
    )


def get_decrypt_asset_smali_code(encryption_secret: str) -> str:
    text = get_text_from_file(
        os.path.join(
            os.path.dirname(__file__), "resources", "smali", "DecryptAsset.smali"
        )
    )
    return replace_default_secret_key(text, encryption_secret)


def get_decrypt_string_smali_code(encryption_secret: str) -> str:
    text = get_text_from_file(
        os.path.join(
            os.path.dirname(__file__), "resources", "smali", "DecryptString.smali"
        )
    )
    return replace_default_secret_key(text, encryption_secret)


def replace_default_secret_key(text: str, encryption_secret: str) -> str:
    return text.replace("This-key-need-to-be-32-character", encryption_secret)


def get_api_reflection_smali_code() -> str:
    return get_text_from_file(
        os.path.join(
            os.path.dirname(__file__), "resources", "smali", "ApiReflection.smali"
        )
    )


def get_advanced_api_reflection_smali_code() -> str:
    return get_text_from_file(
        os.path.join(
            os.path.dirname(__file__),
            "resources",
            "smali",
            "AdvancedApiReflection.smali",
        )
    )

```

`src/requirements.txt`:

```txt
pycryptodome==3.12.0
pytest-cov==3.0.0
tqdm==4.62.3
vt-py==0.13.0
Yapsy==1.12.2

```

`src/test/test_cli.py`:

```py
#!/usr/bin/env python3

import os

import pytest

from obfuscapk import cli

# noinspection PyUnresolvedReferences
from test.test_fixtures import (
    tmp_working_directory_path,
    tmp_demo_apk_v10_original_path,
)


class TestCommandLine(object):
    def test_valid_basic_command_without_quotes(
        self,
        tmp_working_directory_path: str,
        tmp_demo_apk_v10_original_path: str,
        monkeypatch,
    ):
        obfuscated_apk_path = os.path.join(tmp_working_directory_path, "obfuscated.apk")

        # Mock the command line parser.
        arguments = cli.get_cmd_args(
            "-w {working_dir} -d {destination} "
            "-o Rebuild -o NewAlignment -o NewSignature {apk_file}".format(
                working_dir=tmp_working_directory_path,
                destination=obfuscated_apk_path,
                apk_file=tmp_demo_apk_v10_original_path,
            ).split()
        )
        monkeypatch.setattr(cli, "get_cmd_args", lambda: arguments)

        cli.main()

        assert os.path.isfile(obfuscated_apk_path)

    def test_valid_basic_command_with_quotes(
        self,
        tmp_working_directory_path: str,
        tmp_demo_apk_v10_original_path: str,
        monkeypatch,
    ):
        obfuscated_apk_path = os.path.join(tmp_working_directory_path, "obfuscated.apk")

        # Mock the command line parser.
        arguments = cli.get_cmd_args(
            "-w '{working_dir}' -d \"{destination}\" "
            "-o Rebuild -k \"key1\" -k 'key2' '{apk_file}'".format(
                working_dir=tmp_working_directory_path,
                destination=obfuscated_apk_path,
                apk_file=tmp_demo_apk_v10_original_path,
            ).split()
        )
        monkeypatch.setattr(cli, "get_cmd_args", lambda: arguments)

        cli.main()

        assert os.path.isfile(obfuscated_apk_path)

    def test_valid_basic_command_with_custom_keystore(
        self,
        tmp_working_directory_path: str,
        tmp_demo_apk_v10_original_path: str,
        monkeypatch,
    ):
        obfuscated_apk_path = os.path.join(tmp_working_directory_path, "obfuscated.apk")

        # Mock the command line parser.
        arguments = cli.get_cmd_args(
            "-w {working_dir} -d {destination} "
            "-o Rebuild -o NewAlignment -o NewSignature "
            "--keystore-file {keystore_file} --keystore-password {keystore_password} "
            "--key-alias {key_alias} --key-password {key_password} {apk_file}".format(
                working_dir=tmp_working_directory_path,
                destination=obfuscated_apk_path,
                apk_file=tmp_demo_apk_v10_original_path,
                keystore_file=os.path.join(
                    os.path.dirname(__file__),
                    os.path.pardir,
                    "obfuscapk",
                    "resources",
                    "obfuscation_keystore.jks",
                ),
                keystore_password="obfuscation_password",
                key_alias="obfuscation_key",
                key_password="obfuscation_password",
            ).split()
        )
        monkeypatch.setattr(cli, "get_cmd_args", lambda: arguments)

        cli.main()

        assert os.path.isfile(obfuscated_apk_path)

    def test_missing_required_parameters(self, monkeypatch):
        # Mock the command line parser.
        original = cli.get_cmd_args
        monkeypatch.setattr(cli, "get_cmd_args", lambda: original([]))

        with pytest.raises(SystemExit) as e:
            cli.main()
        assert e.value.code == 2

    def test_missing_external_tool(self, monkeypatch):
        monkeypatch.setenv("APKTOOL_PATH", "invalid.apktool.path")

        # Mock the command line parser.
        arguments = cli.get_cmd_args("-o Rebuild ignore.apk".split())
        monkeypatch.setattr(cli, "get_cmd_args", lambda: arguments)

        with pytest.raises(RuntimeError) as e:
            cli.main()
        assert "Something is wrong with executable" in str(e.value)

```

`src/test/test_fixtures.py`:

```py
#!/usr/bin/env python3

import shutil
from pathlib import Path

import pytest


@pytest.fixture(scope="function")
def tmp_working_directory_path(tmp_path) -> str:
    """
    Return a path to a temporary working directory (different path for each test).
    """
    destination = tmp_path.joinpath("obfuscation_working_dir")
    destination.mkdir()
    return str(destination)


@pytest.fixture(scope="function")
def tmp_demo_apk_v10_original_path(tmp_path) -> str:
    """
    Return a path to a valid demo apk file generated with Android Studio (different
    path for each test, but the apk file is the same).
    """
    source = (
        Path(__file__)
        .resolve()
        .parent.joinpath(
            "test_resources", "v1.0", "com.obfuscapk.demo.v1.0-original.apk"
        )
    )
    destination = tmp_path.joinpath("com.obfuscapk.demo.v1.0-original.apk")
    destination = shutil.copy2(source, destination)
    return str(destination)


@pytest.fixture(scope="function")
def tmp_demo_apk_v10_rebuild_path(tmp_path) -> str:
    """
    Return a path to a valid demo apk file generated with Apktool (different path for
    each test, but the apk file is the same). This can be useful to test signing and
    aligning.
    """
    source = (
        Path(__file__)
        .resolve()
        .parent.joinpath(
            "test_resources", "v1.0", "com.obfuscapk.demo.v1.0-rebuild.apk"
        )
    )
    destination = tmp_path.joinpath("com.obfuscapk.demo.v1.0-rebuild.apk")
    destination = shutil.copy2(source, destination)
    return str(destination)


@pytest.fixture(scope="function")
def tmp_demo_apk_v10_decoded_files_directory_path(tmp_path) -> str:
    """
    Return a path to a valid directory with the decoded files generated by Apktool
    (different path for each test, but the files are the same). This can be useful to
    test apk rebuilding.
    """
    source = (
        Path(__file__)
        .resolve()
        .parent.joinpath("test_resources", "v1.0", "com.obfuscapk.demo.v1.0-original")
    )
    destination = tmp_path.joinpath("com.obfuscapk.demo.v1.0-original")
    destination = shutil.copytree(source, destination)
    return str(destination)

```

`src/test/test_obfuscation.py`:

```py
#!/usr/bin/env python3

import os

import pytest

from obfuscapk.main import check_external_tool_dependencies, perform_obfuscation
from obfuscapk.obfuscation import Obfuscation
from obfuscapk.tool import Apktool

# noinspection PyUnresolvedReferences
from test.test_fixtures import (
    tmp_working_directory_path,
    tmp_demo_apk_v10_original_path,
    tmp_demo_apk_v10_rebuild_path,
)


# noinspection PyProtectedMember
class TestObfuscation(object):
    def test_valid_external_tools(self):
        # If something is wrong an exception will be thrown and the test will fail.
        check_external_tool_dependencies()

    def test_perform_full_obfuscation_valid_apk(
        self,
        tmp_working_directory_path: str,
        tmp_demo_apk_v10_original_path: str,
    ):
        obfuscated_apk_path = os.path.join(tmp_working_directory_path, "obfuscated.apk")
        perform_obfuscation(
            tmp_demo_apk_v10_original_path,
            [
                "DebugRemoval",
                "LibEncryption",
                "CallIndirection",
                "MethodRename",
                "AssetEncryption",
                "MethodOverload",
                "ConstStringEncryption",
                "ResStringEncryption",
                "ArithmeticBranch",
                "FieldRename",
                "Nop",
                "Goto",
                "ClassRename",
                "Reflection",
                "AdvancedReflection",
                "Reorder",
                "RandomManifest",
                "Rebuild",
                "NewAlignment",
                "NewSignature",
            ],
            tmp_working_directory_path,
            obfuscated_apk_path,
            interactive=True,
            ignore_libs=True,
        )
        assert os.path.isfile(obfuscated_apk_path)

    def test_perform_obfuscation_error_missing_external_tool(self, monkeypatch):
        monkeypatch.setenv("APKTOOL_PATH", "invalid.apktool.path")
        with pytest.raises(RuntimeError) as e:
            perform_obfuscation("ignore.apk", [])
        assert "Something is wrong with executable" in str(e.value)

    def test_perform_obfuscation_error_invalid_apk_path(self):
        with pytest.raises(FileNotFoundError):
            perform_obfuscation("invalid.apk.path", [])

    def test_perform_obfuscation_error_invalid_obfuscator_name(
        self,
        tmp_demo_apk_v10_original_path: str,
    ):
        with pytest.raises(ValueError):
            perform_obfuscation(
                tmp_demo_apk_v10_original_path,
                ["invalid.obfuscator.name"],
            )

    def test_perform_obfuscation_error_generic_obfuscator_error(
        self, tmp_working_directory_path: str
    ):
        # The Rebuild obfuscator will fail with an invalid input file.
        invalid_file_path = os.path.join(tmp_working_directory_path, "invalid.apk")

        with open(invalid_file_path, "w") as invalid_file:
            invalid_file.write("This is not an apk file\n")

        with pytest.raises(Exception):
            perform_obfuscation(invalid_file_path, ["Rebuild"])

    def test_obfuscation_error_invalid_apk_path(self):
        with pytest.raises(FileNotFoundError):
            Obfuscation("invalid.apk.path")

    def test_obfuscation_error_working_dir_creation(
        self, tmp_demo_apk_v10_original_path: str, monkeypatch
    ):
        def mock(*args, **kwargs):
            raise Exception

        monkeypatch.setattr("os.makedirs", mock)

        with pytest.raises(Exception):
            Obfuscation(tmp_demo_apk_v10_original_path)

    def test_obfuscation_get_total_fields(self, tmp_demo_apk_v10_original_path: str):
        obfuscation = Obfuscation(tmp_demo_apk_v10_original_path)
        total_fields = obfuscation._get_total_fields()
        assert isinstance(total_fields, int)
        assert total_fields > 10

    def test_obfuscation_get_total_methods(self, tmp_demo_apk_v10_original_path: str):
        obfuscation = Obfuscation(tmp_demo_apk_v10_original_path)
        total_methods = obfuscation._get_total_methods()
        assert isinstance(total_methods, int)
        assert total_methods > 10

    def test_obfuscation_get_remaining_fields(
        self, tmp_demo_apk_v10_original_path: str
    ):
        obfuscation = Obfuscation(tmp_demo_apk_v10_original_path)
        remaining_fields = obfuscation._get_remaining_fields()
        assert isinstance(remaining_fields, int)
        assert remaining_fields > 63500

    def test_obfuscation_get_remaining_methods(
        self, tmp_demo_apk_v10_original_path: str
    ):
        obfuscation = Obfuscation(tmp_demo_apk_v10_original_path)
        remaining_methods = obfuscation._get_remaining_methods()
        assert isinstance(remaining_methods, int)
        assert remaining_methods > 63500

    def test_obfuscation_decode_apk_success(self, tmp_demo_apk_v10_original_path: str):
        obfuscation = Obfuscation(
            tmp_demo_apk_v10_original_path, ignore_libs=True, interactive=True
        )

        assert not obfuscation._decoded_apk_path

        obfuscation.decode_apk()

        assert os.path.isdir(obfuscation._decoded_apk_path)

    def test_obfuscation_decode_apk_error(
        self, tmp_demo_apk_v10_original_path: str, monkeypatch
    ):
        def mock(*args, **kwargs):
            raise Exception

        monkeypatch.setattr(Apktool, "decode", mock)

        obfuscation = Obfuscation(
            tmp_demo_apk_v10_original_path, ignore_libs=True, interactive=True
        )

        with pytest.raises(Exception):
            obfuscation.decode_apk()

    def test_obfuscation_remaining_fields_per_obfuscator(
        self, tmp_demo_apk_v10_original_path: str
    ):
        obfuscation = Obfuscation(tmp_demo_apk_v10_original_path)
        obfuscators_adding_fields = 3
        obfuscation.obfuscators_adding_fields = obfuscators_adding_fields
        result = obfuscation.get_remaining_fields_per_obfuscator()
        assert isinstance(result, int)
        assert (
            result == obfuscation._get_remaining_fields() // obfuscators_adding_fields
        )

    def test_obfuscation_remaining_methods_per_obfuscator(
        self, tmp_demo_apk_v10_original_path: str
    ):
        obfuscation = Obfuscation(tmp_demo_apk_v10_original_path)
        obfuscators_adding_methods = 3
        obfuscation.obfuscators_adding_methods = obfuscators_adding_methods
        result = obfuscation.get_remaining_methods_per_obfuscator()
        assert isinstance(result, int)
        assert (
            result == obfuscation._get_remaining_methods() // obfuscators_adding_methods
        )

    def test_obfuscation_build_obfuscated_apk_success(
        self,
        tmp_working_directory_path: str,
        tmp_demo_apk_v10_original_path: str,
    ):
        obfuscated_apk_path = os.path.join(tmp_working_directory_path, "obfuscated.apk")
        obfuscation = Obfuscation(
            tmp_demo_apk_v10_original_path,
            tmp_working_directory_path,
            obfuscated_apk_path,
        )

        assert not os.path.isfile(obfuscated_apk_path)

        obfuscation.build_obfuscated_apk()

        assert os.path.isfile(obfuscated_apk_path)

    def test_obfuscation_build_obfuscated_apk_error(
        self, tmp_demo_apk_v10_original_path: str
    ):
        obfuscation = Obfuscation(tmp_demo_apk_v10_original_path)
        obfuscation._is_decoded = True
        obfuscation._decoded_apk_path = "invalid.decoded.apk.path"

        with pytest.raises(Exception):
            obfuscation.build_obfuscated_apk()

    def test_obfuscation_sign_obfuscated_apk_success(
        self,
        tmp_working_directory_path: str,
        tmp_demo_apk_v10_original_path: str,
        tmp_demo_apk_v10_rebuild_path: str,
    ):
        obfuscated_apk_path = os.path.join(tmp_working_directory_path, "obfuscated.apk")
        obfuscation = Obfuscation(
            tmp_demo_apk_v10_original_path,
            tmp_working_directory_path,
            obfuscated_apk_path,
        )
        obfuscation.obfuscated_apk_path = tmp_demo_apk_v10_rebuild_path

        # In case of errors an exception would be thrown and the test would fail.
        obfuscation.sign_obfuscated_apk()

    def test_obfuscation_sign_obfuscated_apk_error_invalid_apk(
        self, tmp_demo_apk_v10_original_path: str
    ):
        obfuscation = Obfuscation(tmp_demo_apk_v10_original_path)
        obfuscation.obfuscated_apk_path = "invalid.apk.path"

        with pytest.raises(Exception):
            obfuscation.sign_obfuscated_apk()

    def test_obfuscation_sign_obfuscated_apk_error_missing_keystore_file(
        self,
        tmp_working_directory_path: str,
        tmp_demo_apk_v10_original_path: str,
        tmp_demo_apk_v10_rebuild_path: str,
    ):
        obfuscated_apk_path = os.path.join(tmp_working_directory_path, "obfuscated.apk")
        obfuscation = Obfuscation(
            tmp_demo_apk_v10_original_path,
            tmp_working_directory_path,
            obfuscated_apk_path,
            keystore_file="invalid.keystore.path",
        )
        obfuscation.obfuscated_apk_path = tmp_demo_apk_v10_rebuild_path

        with pytest.raises(FileNotFoundError):
            obfuscation.sign_obfuscated_apk()

    def test_obfuscation_sign_obfuscated_apk_error_missing_keystore_password(
        self,
        tmp_working_directory_path: str,
        tmp_demo_apk_v10_original_path: str,
        tmp_demo_apk_v10_rebuild_path: str,
    ):
        obfuscated_apk_path = os.path.join(tmp_working_directory_path, "obfuscated.apk")
        obfuscation = Obfuscation(
            tmp_demo_apk_v10_original_path,
            tmp_working_directory_path,
            obfuscated_apk_path,
            keystore_file=os.path.join(
                os.path.dirname(__file__),
                os.path.pardir,
                "obfuscapk",
                "resources",
                "obfuscation_keystore.jks",
            ),
            key_password=None,
        )
        obfuscation.obfuscated_apk_path = tmp_demo_apk_v10_rebuild_path

        with pytest.raises(ValueError):
            obfuscation.sign_obfuscated_apk()

    def test_obfuscation_align_obfuscated_apk_success(
        self,
        tmp_working_directory_path: str,
        tmp_demo_apk_v10_original_path: str,
        tmp_demo_apk_v10_rebuild_path: str,
    ):
        obfuscated_apk_path = os.path.join(tmp_working_directory_path, "obfuscated.apk")
        obfuscation = Obfuscation(
            tmp_demo_apk_v10_original_path,
            tmp_working_directory_path,
            obfuscated_apk_path,
        )
        obfuscation.obfuscated_apk_path = tmp_demo_apk_v10_rebuild_path

        # In case of errors an exception would be thrown.
        obfuscation.align_obfuscated_apk()

    def test_obfuscation_align_obfuscated_apk_error(
        self, tmp_demo_apk_v10_original_path: str
    ):
        obfuscation = Obfuscation(tmp_demo_apk_v10_original_path)
        obfuscation.obfuscated_apk_path = "invalid.apk.path"

        with pytest.raises(Exception):
            obfuscation.align_obfuscated_apk()

    def test_is_multidex(self, tmp_demo_apk_v10_original_path: str):
        obfuscation = Obfuscation(tmp_demo_apk_v10_original_path)
        is_multidex = obfuscation.is_multidex()
        assert is_multidex is False

    def test_get_manifest_file(self, tmp_demo_apk_v10_original_path: str):
        obfuscation = Obfuscation(tmp_demo_apk_v10_original_path)
        manifest = obfuscation.get_manifest_file()
        assert os.path.isfile(manifest)

    def test_get_smali_files(self, tmp_demo_apk_v10_original_path: str):
        obfuscation = Obfuscation(tmp_demo_apk_v10_original_path)
        smali_files = obfuscation.get_smali_files()
        assert len(smali_files) > 5
        assert all(os.path.isfile(smali_file) for smali_file in smali_files)

    def test_get_multidex_smali_files(self, tmp_demo_apk_v10_original_path: str):
        obfuscation = Obfuscation(tmp_demo_apk_v10_original_path)
        smali_files = obfuscation.get_multidex_smali_files()
        # This test application is not multidex.
        assert len(smali_files) == 0

    def test_get_native_lib_files(self, tmp_demo_apk_v10_original_path: str):
        obfuscation = Obfuscation(tmp_demo_apk_v10_original_path)
        native_libs = obfuscation.get_native_lib_files()
        assert len(native_libs) > 0
        assert all(os.path.isfile(native_lib) for native_lib in native_libs)

    def test_get_assets_directory(self, tmp_demo_apk_v10_original_path: str):
        obfuscation = Obfuscation(tmp_demo_apk_v10_original_path)
        assets_dir = obfuscation.get_assets_directory()
        assert os.path.isdir(assets_dir)
        assert "message.txt" in os.listdir(assets_dir)

    def test_get_resource_directory(self, tmp_demo_apk_v10_original_path: str):
        obfuscation = Obfuscation(tmp_demo_apk_v10_original_path)
        resource_dir = obfuscation.get_resource_directory()
        assert os.path.isdir(resource_dir)
        assert "drawable" in os.listdir(resource_dir)

```

`src/test/test_resources/v1.0/com.obfuscapk.demo.v1.0-original/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8" standalone="no"?><manifest xmlns:android="http://schemas.android.com/apk/res/android" android:compileSdkVersion="29" android:compileSdkVersionCodename="10" package="com.obfuscapk.demo" platformBuildVersionCode="29" platformBuildVersionName="10">
    <uses-permission android:name="android.permission.INTERNET"/>
    <uses-permission android:name="android.permission.VIBRATE"/>
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION"/>
    <uses-feature android:name="android.hardware.location"/>
    <application android:allowBackup="true" android:extractNativeLibs="false" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:roundIcon="@mipmap/ic_launcher_round" android:theme="@style/AppTheme">
        <activity android:name="com.obfuscapk.demo.MainActivity">
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>
    </application>
</manifest>
```

`src/test/test_resources/v1.0/com.obfuscapk.demo.v1.0-original/apktool.yml`:

```yml
!!brut.androlib.meta.MetaInfo
apkFileName: com.obfuscapk.demo.v1.0-original.apk
compressionType: false
doNotCompress:
- resources.arsc
- assets/message.txt
- lib/x86/libnative-lib.so
isFrameworkApk: false
packageInfo:
  forcedPackageId: '127'
  renameManifestPackage: null
sdkInfo:
  minSdkVersion: '24'
  targetSdkVersion: '29'
sharedLibrary: false
sparseResources: false
unknownFiles: {}
usesFramework:
  ids:
  - 1
  tag: null
version: 2.4.1
versionInfo:
  versionCode: '1'
  versionName: '1.0'

```

`src/test/test_resources/v1.0/com.obfuscapk.demo.v1.0-original/assets/message.txt`:

```txt
This is a message contained into an asset file

```

`src/test/test_resources/v1.0/com.obfuscapk.demo.v1.0-original/res/drawable/$ic_launcher_foreground__0.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<gradient android:angle="0.0" android:type="linear" android:startX="42.9492" android:startY="49.59793" android:endX="85.84757" android:endY="92.4963"
  xmlns:android="http://schemas.android.com/apk/res/android" xmlns:aapt="http://schemas.android.com/aapt">
    <item android:color="#44000000" android:offset="0.0" />
    <item android:color="#00000000" android:offset="1.0" />
</gradient>
```

`src/test/test_resources/v1.0/com.obfuscapk.demo.v1.0-original/res/drawable/ic_launcher_background.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<vector android:height="108.0dip" android:width="108.0dip" android:viewportWidth="108.0" android:viewportHeight="108.0"
  xmlns:android="http://schemas.android.com/apk/res/android">
    <path android:fillColor="#ff3ddc84" android:pathData="M0,0h108v108h-108z" />
    <path android:fillColor="#00000000" android:pathData="M9,0L9,108" android:strokeColor="#33ffffff" android:strokeWidth="0.8" />
    <path android:fillColor="#00000000" android:pathData="M19,0L19,108" android:strokeColor="#33ffffff" android:strokeWidth="0.8" />
    <path android:fillColor="#00000000" android:pathData="M29,0L29,108" android:strokeColor="#33ffffff" android:strokeWidth="0.8" />
    <path android:fillColor="#00000000" android:pathData="M39,0L39,108" android:strokeColor="#33ffffff" android:strokeWidth="0.8" />
    <path android:fillColor="#00000000" android:pathData="M49,0L49,108" android:strokeColor="#33ffffff" android:strokeWidth="0.8" />
    <path android:fillColor="#00000000" android:pathData="M59,0L59,108" android:strokeColor="#33ffffff" android:strokeWidth="0.8" />
    <path android:fillColor="#00000000" android:pathData="M69,0L69,108" android:strokeColor="#33ffffff" android:strokeWidth="0.8" />
    <path android:fillColor="#00000000" android:pathData="M79,0L79,108" android:strokeColor="#33ffffff" android:strokeWidth="0.8" />
    <path android:fillColor="#00000000" android:pathData="M89,0L89,108" android:strokeColor="#33ffffff" android:strokeWidth="0.8" />
    <path android:fillColor="#00000000" android:pathData="M99,0L99,108" android:strokeColor="#33ffffff" android:strokeWidth="0.8" />
    <path android:fillColor="#00000000" android:pathData="M0,9L108,9" android:strokeColor="#33ffffff" android:strokeWidth="0.8" />
    <path android:fillColor="#00000000" android:pathData="M0,19L108,19" android:strokeColor="#33ffffff" android:strokeWidth="0.8" />
    <path android:fillColor="#00000000" android:pathData="M0,29L108,29" android:strokeColor="#33ffffff" android:strokeWidth="0.8" />
    <path android:fillColor="#00000000" android:pathData="M0,39L108,39" android:strokeColor="#33ffffff" android:strokeWidth="0.8" />
    <path android:fillColor="#00000000" android:pathData="M0,49L108,49" android:strokeColor="#33ffffff" android:strokeWidth="0.8" />
    <path android:fillColor="#00000000" android:pathData="M0,59L108,59" android:strokeColor="#33ffffff" android:strokeWidth="0.8" />
    <path android:fillColor="#00000000" android:pathData="M0,69L108,69" android:strokeColor="#33ffffff" android:strokeWidth="0.8" />
    <path android:fillColor="#00000000" android:pathData="M0,79L108,79" android:strokeColor="#33ffffff" android:strokeWidth="0.8" />
    <path android:fillColor="#00000000" android:pathData="M0,89L108,89" android:strokeColor="#33ffffff" android:strokeWidth="0.8" />
    <path android:fillColor="#00000000" android:pathData="M0,99L108,99" android:strokeColor="#33ffffff" android:strokeWidth="0.8" />
    <path android:fillColor="#00000000" android:pathData="M19,29L89,29" android:strokeColor="#33ffffff" android:strokeWidth="0.8" />
    <path android:fillColor="#00000000" android:pathData="M19,39L89,39" android:strokeColor="#33ffffff" android:strokeWidth="0.8" />
    <path android:fillColor="#00000000" android:pathData="M19,49L89,49" android:strokeColor="#33ffffff" android:strokeWidth="0.8" />
    <path android:fillColor="#00000000" android:pathData="M19,59L89,59" android:strokeColor="#33ffffff" android:strokeWidth="0.8" />
    <path android:fillColor="#00000000" android:pathData="M19,69L89,69" android:strokeColor="#33ffffff" android:strokeWidth="0.8" />
    <path android:fillColor="#00000000" android:pathData="M19,79L89,79" android:strokeColor="#33ffffff" android:strokeWidth="0.8" />
    <path android:fillColor="#00000000" android:pathData="M29,19L29,89" android:strokeColor="#33ffffff" android:strokeWidth="0.8" />
    <path android:fillColor="#00000000" android:pathData="M39,19L39,89" android:strokeColor="#33ffffff" android:strokeWidth="0.8" />
    <path android:fillColor="#00000000" android:pathData="M49,19L49,89" android:strokeColor="#33ffffff" android:strokeWidth="0.8" />
    <path android:fillColor="#00000000" android:pathData="M59,19L59,89" android:strokeColor="#33ffffff" android:strokeWidth="0.8" />
    <path android:fillColor="#00000000" android:pathData="M69,19L69,89" android:strokeColor="#33ffffff" android:strokeWidth="0.8" />
    <path android:fillColor="#00000000" android:pathData="M79,19L79,89" android:strokeColor="#33ffffff" android:strokeWidth="0.8" />
</vector>
```

`src/test/test_resources/v1.0/com.obfuscapk.demo.v1.0-original/res/drawable/ic_launcher_foreground.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<vector android:height="108.0dip" android:width="108.0dip" android:viewportWidth="108.0" android:viewportHeight="108.0"
  xmlns:android="http://schemas.android.com/apk/res/android" xmlns:aapt="http://schemas.android.com/aapt">
    <path android:fillColor="@drawable/$ic_launcher_foreground__0" android:pathData="M31,63.928c0,0 6.4,-11 12.1,-13.1c7.2,-2.6 26,-1.4 26,-1.4l38.1,38.1L107,108.928l-32,-1L31,63.928z" />
    <path android:fillColor="#ffffffff" android:pathData="M65.3,45.828l3.8,-6.6c0.2,-0.4 0.1,-0.9 -0.3,-1.1c-0.4,-0.2 -0.9,-0.1 -1.1,0.3l-3.9,6.7c-6.3,-2.8 -13.4,-2.8 -19.7,0l-3.9,-6.7c-0.2,-0.4 -0.7,-0.5 -1.1,-0.3C38.8,38.328 38.7,38.828 38.9,39.228l3.8,6.6C36.2,49.428 31.7,56.028 31,63.928h46C76.3,56.028 71.8,49.428 65.3,45.828zM43.4,57.328c-0.8,0 -1.5,-0.5 -1.8,-1.2c-0.3,-0.7 -0.1,-1.5 0.4,-2.1c0.5,-0.5 1.4,-0.7 2.1,-0.4c0.7,0.3 1.2,1 1.2,1.8C45.3,56.528 44.5,57.328 43.4,57.328L43.4,57.328zM64.6,57.328c-0.8,0 -1.5,-0.5 -1.8,-1.2s-0.1,-1.5 0.4,-2.1c0.5,-0.5 1.4,-0.7 2.1,-0.4c0.7,0.3 1.2,1 1.2,1.8C66.5,56.528 65.6,57.328 64.6,57.328L64.6,57.328z" android:strokeColor="#00000000" android:strokeWidth="1.0" android:fillType="nonZero" />
</vector>
```

`src/test/test_resources/v1.0/com.obfuscapk.demo.v1.0-original/res/layout/activity_main.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<TableLayout android:layout_width="fill_parent" android:layout_height="fill_parent"
  xmlns:android="http://schemas.android.com/apk/res/android">
    <TableRow android:layout_marginTop="70.0dip">
        <TextView android:textSize="35.0sp" android:textStyle="bold" android:textColor="@color/colorAccent" android:layout_gravity="center" android:layout_width="fill_parent" android:layout_height="wrap_content" android:text="@string/app_name" android:textAlignment="center" />
    </TableRow>
    <TableRow android:layout_marginTop="50.0dip">
        <TextView android:textSize="18.0sp" android:textColor="@color/textForeground" android:layout_width="wrap_content" android:layout_height="fill_parent" android:text="@string/app_description" android:paddingStart="20.0dip" android:paddingEnd="20.0dip" />
    </TableRow>
    <TableRow android:layout_marginTop="20.0dip">
        <EditText android:textColor="@color/textForeground" android:id="@id/start_password" android:padding="20.0dip" android:layout_width="fill_parent" android:layout_height="fill_parent" android:hint="Password" android:singleLine="true" android:inputType="textPassword" android:drawableStart="@android:drawable/ic_lock_lock" android:layout_marginStart="20.0dip" android:layout_marginEnd="20.0dip" />
    </TableRow>
    <TableRow android:layout_marginTop="20.0dip">
        <Button android:textSize="25.0sp" android:textStyle="bold" android:textColor="@color/colorAccent" android:id="@id/start_button" android:layout_width="wrap_content" android:layout_height="fill_parent" android:text="Start" android:layout_marginStart="20.0dip" android:layout_marginEnd="20.0dip" android:backgroundTint="@color/buttonBackground" />
    </TableRow>
</TableLayout>
```

`src/test/test_resources/v1.0/com.obfuscapk.demo.v1.0-original/res/mipmap-anydpi-v26/ic_launcher.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon
  xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@drawable/ic_launcher_background" />
    <foreground android:drawable="@drawable/ic_launcher_foreground" />
</adaptive-icon>
```

`src/test/test_resources/v1.0/com.obfuscapk.demo.v1.0-original/res/mipmap-anydpi-v26/ic_launcher_round.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon
  xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@drawable/ic_launcher_background" />
    <foreground android:drawable="@drawable/ic_launcher_foreground" />
</adaptive-icon>
```

`src/test/test_resources/v1.0/com.obfuscapk.demo.v1.0-original/res/values/colors.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="buttonBackground">#ff504538</color>
    <color name="colorAccent">#fff5a623</color>
    <color name="textForeground">#ffb7a99a</color>
</resources>

```

`src/test/test_resources/v1.0/com.obfuscapk.demo.v1.0-original/res/values/ids.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <item type="id" name="start_button" />
    <item type="id" name="start_password" />
</resources>

```

`src/test/test_resources/v1.0/com.obfuscapk.demo.v1.0-original/res/values/public.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <public type="color" name="buttonBackground" id="0x7f010000" />
    <public type="color" name="colorAccent" id="0x7f010001" />
    <public type="color" name="textForeground" id="0x7f010002" />
    <public type="drawable" name="$ic_launcher_foreground__0" id="0x7f020000" />
    <public type="drawable" name="ic_launcher_background" id="0x7f020001" />
    <public type="drawable" name="ic_launcher_foreground" id="0x7f020002" />
    <public type="id" name="start_button" id="0x7f030000" />
    <public type="id" name="start_password" id="0x7f030001" />
    <public type="layout" name="activity_main" id="0x7f040000" />
    <public type="mipmap" name="ic_launcher" id="0x7f050000" />
    <public type="mipmap" name="ic_launcher_round" id="0x7f050001" />
    <public type="string" name="app_description" id="0x7f060000" />
    <public type="string" name="app_name" id="0x7f060001" />
    <public type="style" name="AppTheme" id="0x7f070000" />
</resources>
```

`src/test/test_resources/v1.0/com.obfuscapk.demo.v1.0-original/res/values/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="app_description">This is a very basic Android application used to test the obfuscation techniques implemented in Obfuscapk.</string>
    <string name="app_name">Obfuscapk Demo</string>
</resources>

```

`src/test/test_resources/v1.0/com.obfuscapk.demo.v1.0-original/res/values/styles.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <style name="AppTheme" parent="@android:style/Theme.Material.NoActionBar.Fullscreen">
        <item name="android:colorAccent">@color/colorAccent</item>
    </style>
</resources>

```

`src/test/test_resources/v1.0/com.obfuscapk.demo.v1.0-original/smali/com/obfuscapk/demo/-$$Lambda$MainActivity$nhRfBCF8GXdGfWKghAWk7qFxa0k.smali`:

```smali
.class public final synthetic Lcom/obfuscapk/demo/-$$Lambda$MainActivity$nhRfBCF8GXdGfWKghAWk7qFxa0k;
.super Ljava/lang/Object;
.source "lambda"

# interfaces
.implements Landroid/view/View$OnClickListener;


# instance fields
.field private final synthetic f$0:Lcom/obfuscapk/demo/MainActivity;

.field private final synthetic f$1:Landroid/widget/EditText;


# direct methods
.method public synthetic constructor <init>(Lcom/obfuscapk/demo/MainActivity;Landroid/widget/EditText;)V
    .locals 0

    invoke-direct {p0}, Ljava/lang/Object;-><init>()V

    iput-object p1, p0, Lcom/obfuscapk/demo/-$$Lambda$MainActivity$nhRfBCF8GXdGfWKghAWk7qFxa0k;->f$0:Lcom/obfuscapk/demo/MainActivity;

    iput-object p2, p0, Lcom/obfuscapk/demo/-$$Lambda$MainActivity$nhRfBCF8GXdGfWKghAWk7qFxa0k;->f$1:Landroid/widget/EditText;

    return-void
.end method


# virtual methods
.method public final onClick(Landroid/view/View;)V
    .locals 2

    iget-object v0, p0, Lcom/obfuscapk/demo/-$$Lambda$MainActivity$nhRfBCF8GXdGfWKghAWk7qFxa0k;->f$0:Lcom/obfuscapk/demo/MainActivity;

    iget-object v1, p0, Lcom/obfuscapk/demo/-$$Lambda$MainActivity$nhRfBCF8GXdGfWKghAWk7qFxa0k;->f$1:Landroid/widget/EditText;

    invoke-virtual {v0, v1, p1}, Lcom/obfuscapk/demo/MainActivity;->lambda$onCreate$0$MainActivity(Landroid/widget/EditText;Landroid/view/View;)V

    return-void
.end method

```

`src/test/test_resources/v1.0/com.obfuscapk.demo.v1.0-original/smali/com/obfuscapk/demo/AssetDemo.smali`:

```smali
.class public Lcom/obfuscapk/demo/AssetDemo;
.super Ljava/lang/Object;
.source "AssetDemo.java"


# direct methods
.method public constructor <init>()V
    .locals 0

    .line 9
    invoke-direct {p0}, Ljava/lang/Object;-><init>()V

    return-void
.end method

.method private static readBytes(Ljava/io/InputStream;)[B
    .locals 4
    .annotation system Ldalvik/annotation/Throws;
        value = {
            Ljava/io/IOException;
        }
    .end annotation

    const/16 v0, 0x400

    new-array v0, v0, [B

    .line 13
    new-instance v1, Ljava/io/ByteArrayOutputStream;

    invoke-direct {v1}, Ljava/io/ByteArrayOutputStream;-><init>()V

    .line 15
    :goto_0
    invoke-virtual {p0, v0}, Ljava/io/InputStream;->read([B)I

    move-result v2

    const/4 v3, -0x1

    if-ne v2, v3, :cond_0

    .line 21
    invoke-virtual {v1}, Ljava/io/ByteArrayOutputStream;->toByteArray()[B

    move-result-object p0

    return-object p0

    :cond_0
    const/4 v3, 0x0

    .line 19
    invoke-virtual {v1, v0, v3, v2}, Ljava/io/ByteArrayOutputStream;->write([BII)V

    goto :goto_0
.end method


# virtual methods
.method public getMessageFromAsset(Landroid/content/res/AssetManager;)Ljava/lang/String;
    .locals 1
    .annotation system Ldalvik/annotation/Throws;
        value = {
            Ljava/io/IOException;
        }
    .end annotation

    const-string v0, "message.txt"

    .line 26
    invoke-virtual {p1, v0}, Landroid/content/res/AssetManager;->open(Ljava/lang/String;)Ljava/io/InputStream;

    move-result-object p1

    .line 27
    new-instance v0, Ljava/lang/String;

    invoke-static {p1}, Lcom/obfuscapk/demo/AssetDemo;->readBytes(Ljava/io/InputStream;)[B

    move-result-object p1

    invoke-direct {v0, p1}, Ljava/lang/String;-><init>([B)V

    return-object v0
.end method

```

`src/test/test_resources/v1.0/com.obfuscapk.demo.v1.0-original/smali/com/obfuscapk/demo/BuildConfig.smali`:

```smali
.class public final Lcom/obfuscapk/demo/BuildConfig;
.super Ljava/lang/Object;
.source "BuildConfig.java"


# static fields
.field public static final APPLICATION_ID:Ljava/lang/String; = "com.obfuscapk.demo"

.field public static final BUILD_TYPE:Ljava/lang/String; = "debug"

.field public static final DEBUG:Z = false

.field public static final FLAVOR:Ljava/lang/String; = ""

.field public static final VERSION_CODE:I = 0x1

.field public static final VERSION_NAME:Ljava/lang/String; = "1.0"


# direct methods
.method public constructor <init>()V
    .locals 0

    .line 6
    invoke-direct {p0}, Ljava/lang/Object;-><init>()V

    return-void
.end method

```

`src/test/test_resources/v1.0/com.obfuscapk.demo.v1.0-original/smali/com/obfuscapk/demo/DebugInfoDemo.smali`:

```smali
.class public Lcom/obfuscapk/demo/DebugInfoDemo;
.super Ljava/lang/Object;
.source "DebugInfoDemo.java"


# direct methods
.method public constructor <init>()V
    .locals 0

    .line 3
    invoke-direct {p0}, Ljava/lang/Object;-><init>()V

    return-void
.end method

.method public static getDebugMessage(Ljava/lang/String;)Ljava/lang/String;
    .locals 2

    const/4 v0, 0x1

    new-array v0, v0, [Ljava/lang/Object;

    const/4 v1, 0x0

    aput-object p0, v0, v1

    const-string p0, "Debug message from %s"

    .line 5
    invoke-static {p0, v0}, Ljava/lang/String;->format(Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;

    move-result-object p0

    return-object p0
.end method

```

`src/test/test_resources/v1.0/com.obfuscapk.demo.v1.0-original/smali/com/obfuscapk/demo/MainActivity.smali`:

```smali
.class public Lcom/obfuscapk/demo/MainActivity;
.super Landroid/app/Activity;
.source "MainActivity.java"


# direct methods
.method public constructor <init>()V
    .locals 0

    .line 11
    invoke-direct {p0}, Landroid/app/Activity;-><init>()V

    return-void
.end method


# virtual methods
.method public synthetic lambda$onCreate$0$MainActivity(Landroid/widget/EditText;Landroid/view/View;)V
    .locals 1

    .line 22
    invoke-virtual {p1}, Landroid/widget/EditText;->getText()Landroid/text/Editable;

    move-result-object p1

    invoke-virtual {p1}, Ljava/lang/Object;->toString()Ljava/lang/String;

    move-result-object p1

    const-string p2, "Obfuscapk"

    .line 23
    invoke-virtual {p2, p1}, Ljava/lang/String;->equals(Ljava/lang/Object;)Z

    move-result p1

    const/4 p2, 0x0

    if-eqz p1, :cond_0

    .line 24
    invoke-virtual {p0}, Lcom/obfuscapk/demo/MainActivity;->getApplicationContext()Landroid/content/Context;

    move-result-object p1

    const-string v0, "Correct password!"

    invoke-static {p1, v0, p2}, Landroid/widget/Toast;->makeText(Landroid/content/Context;Ljava/lang/CharSequence;I)Landroid/widget/Toast;

    move-result-object p1

    invoke-virtual {p1}, Landroid/widget/Toast;->show()V

    goto :goto_0

    .line 26
    :cond_0
    invoke-virtual {p0}, Lcom/obfuscapk/demo/MainActivity;->getApplicationContext()Landroid/content/Context;

    move-result-object p1

    const-string v0, "Wrong password!"

    invoke-static {p1, v0, p2}, Landroid/widget/Toast;->makeText(Landroid/content/Context;Ljava/lang/CharSequence;I)Landroid/widget/Toast;

    move-result-object p1

    invoke-virtual {p1}, Landroid/widget/Toast;->show()V

    :goto_0
    return-void
.end method

.method protected onCreate(Landroid/os/Bundle;)V
    .locals 3

    const-string v0, "Obfuscapk"

    .line 15
    invoke-super {p0, p1}, Landroid/app/Activity;->onCreate(Landroid/os/Bundle;)V

    const/high16 p1, 0x7f040000

    .line 16
    invoke-virtual {p0, p1}, Lcom/obfuscapk/demo/MainActivity;->setContentView(I)V

    const/high16 p1, 0x7f030000

    .line 18
    invoke-virtual {p0, p1}, Lcom/obfuscapk/demo/MainActivity;->findViewById(I)Landroid/view/View;

    move-result-object p1

    check-cast p1, Landroid/widget/Button;

    const v1, 0x7f030001

    .line 19
    invoke-virtual {p0, v1}, Lcom/obfuscapk/demo/MainActivity;->findViewById(I)Landroid/view/View;

    move-result-object v1

    check-cast v1, Landroid/widget/EditText;

    .line 21
    new-instance v2, Lcom/obfuscapk/demo/-$$Lambda$MainActivity$nhRfBCF8GXdGfWKghAWk7qFxa0k;

    invoke-direct {v2, p0, v1}, Lcom/obfuscapk/demo/-$$Lambda$MainActivity$nhRfBCF8GXdGfWKghAWk7qFxa0k;-><init>(Lcom/obfuscapk/demo/MainActivity;Landroid/widget/EditText;)V

    invoke-virtual {p1, v2}, Landroid/widget/Button;->setOnClickListener(Landroid/view/View$OnClickListener;)V

    .line 31
    :try_start_0
    new-instance p1, Lcom/obfuscapk/demo/AssetDemo;

    invoke-direct {p1}, Lcom/obfuscapk/demo/AssetDemo;-><init>()V

    const-string v1, "ASSET TEST"

    .line 32
    invoke-virtual {p0}, Lcom/obfuscapk/demo/MainActivity;->getAssets()Landroid/content/res/AssetManager;

    move-result-object v2

    invoke-virtual {p1, v2}, Lcom/obfuscapk/demo/AssetDemo;->getMessageFromAsset(Landroid/content/res/AssetManager;)Ljava/lang/String;

    move-result-object p1

    invoke-static {v1, p1}, Landroid/util/Log;->i(Ljava/lang/String;Ljava/lang/String;)I

    const-string p1, "DEBUG INFO TEST"

    .line 34
    invoke-static {v0}, Lcom/obfuscapk/demo/DebugInfoDemo;->getDebugMessage(Ljava/lang/String;)Ljava/lang/String;

    move-result-object v1

    invoke-static {p1, v1}, Landroid/util/Log;->i(Ljava/lang/String;Ljava/lang/String;)I

    const-string p1, "GOTO TEST"

    .line 36
    invoke-static {}, Lcom/obfuscapk/demo/OrderDemo;->getGotoMessage()Ljava/lang/String;

    move-result-object v1

    invoke-static {p1, v1}, Landroid/util/Log;->i(Ljava/lang/String;Ljava/lang/String;)I

    .line 38
    new-instance p1, Lcom/obfuscapk/demo/NativeLibraryDemo;

    invoke-direct {p1}, Lcom/obfuscapk/demo/NativeLibraryDemo;-><init>()V

    const-string v1, "NATIVE LIB TEST"

    .line 39
    invoke-virtual {p1}, Lcom/obfuscapk/demo/NativeLibraryDemo;->getMessageFromNativeLib()Ljava/lang/String;

    move-result-object p1

    invoke-static {v1, p1}, Landroid/util/Log;->i(Ljava/lang/String;Ljava/lang/String;)I

    const-string p1, "NOP TEST"

    .line 41
    invoke-static {v0}, Lcom/obfuscapk/demo/NopDemo;->getNopMessage(Ljava/lang/String;)Ljava/lang/String;

    move-result-object v0

    invoke-static {p1, v0}, Landroid/util/Log;->i(Ljava/lang/String;Ljava/lang/String;)I

    const-string p1, "REORDER TEST"

    .line 43
    invoke-static {}, Lcom/obfuscapk/demo/OrderDemo;->getGotoMessage()Ljava/lang/String;

    move-result-object v0

    invoke-static {p1, v0}, Landroid/util/Log;->i(Ljava/lang/String;Ljava/lang/String;)I
    :try_end_0
    .catch Ljava/lang/Exception; {:try_start_0 .. :try_end_0} :catch_0

    goto :goto_0

    :catch_0
    move-exception p1

    .line 45
    invoke-virtual {p0}, Lcom/obfuscapk/demo/MainActivity;->getApplicationContext()Landroid/content/Context;

    move-result-object v0

    invoke-virtual {p1}, Ljava/lang/Exception;->toString()Ljava/lang/String;

    move-result-object v1

    const/4 v2, 0x0

    invoke-static {v0, v1, v2}, Landroid/widget/Toast;->makeText(Landroid/content/Context;Ljava/lang/CharSequence;I)Landroid/widget/Toast;

    move-result-object v0

    invoke-virtual {v0}, Landroid/widget/Toast;->show()V

    .line 46
    invoke-virtual {p1}, Ljava/lang/Exception;->toString()Ljava/lang/String;

    move-result-object p1

    const-string v0, "MAIN ERROR"

    invoke-static {v0, p1}, Landroid/util/Log;->e(Ljava/lang/String;Ljava/lang/String;)I

    :goto_0
    return-void
.end method

```

`src/test/test_resources/v1.0/com.obfuscapk.demo.v1.0-original/smali/com/obfuscapk/demo/NativeLibraryDemo.smali`:

```smali
.class public Lcom/obfuscapk/demo/NativeLibraryDemo;
.super Ljava/lang/Object;
.source "NativeLibraryDemo.java"


# direct methods
.method static constructor <clinit>()V
    .locals 1

    const-string v0, "native-lib"

    .line 8
    invoke-static {v0}, Ljava/lang/System;->loadLibrary(Ljava/lang/String;)V

    return-void
.end method

.method public constructor <init>()V
    .locals 0

    .line 3
    invoke-direct {p0}, Ljava/lang/Object;-><init>()V

    return-void
.end method

.method private native stringFromJNI()Ljava/lang/String;
.end method


# virtual methods
.method public getMessageFromNativeLib()Ljava/lang/String;
    .locals 1

    .line 14
    invoke-direct {p0}, Lcom/obfuscapk/demo/NativeLibraryDemo;->stringFromJNI()Ljava/lang/String;

    move-result-object v0

    return-object v0
.end method

```

`src/test/test_resources/v1.0/com.obfuscapk.demo.v1.0-original/smali/com/obfuscapk/demo/NopDemo.smali`:

```smali
.class public Lcom/obfuscapk/demo/NopDemo;
.super Ljava/lang/Object;
.source "NopDemo.java"


# direct methods
.method public constructor <init>()V
    .locals 0

    .line 3
    invoke-direct {p0}, Ljava/lang/Object;-><init>()V

    return-void
.end method

.method public static getNopMessage(Ljava/lang/String;)Ljava/lang/String;
    .locals 2

    .line 8
    new-instance v0, Ljava/lang/StringBuilder;

    invoke-direct {v0}, Ljava/lang/StringBuilder;-><init>()V

    const-string v1, "Nop message: "

    invoke-virtual {v0, v1}, Ljava/lang/StringBuilder;->append(Ljava/lang/String;)Ljava/lang/StringBuilder;

    const-string v1, "sending a nop message from "

    invoke-virtual {v0, v1}, Ljava/lang/StringBuilder;->append(Ljava/lang/String;)Ljava/lang/StringBuilder;

    invoke-virtual {v0, p0}, Ljava/lang/StringBuilder;->append(Ljava/lang/String;)Ljava/lang/StringBuilder;

    invoke-virtual {v0}, Ljava/lang/StringBuilder;->toString()Ljava/lang/String;

    move-result-object p0

    return-object p0
.end method

```

`src/test/test_resources/v1.0/com.obfuscapk.demo.v1.0-original/smali/com/obfuscapk/demo/OrderDemo.smali`:

```smali
.class public Lcom/obfuscapk/demo/OrderDemo;
.super Ljava/lang/Object;
.source "OrderDemo.java"


# direct methods
.method public constructor <init>()V
    .locals 0

    .line 6
    invoke-direct {p0}, Ljava/lang/Object;-><init>()V

    return-void
.end method

.method public static getGotoMessage()Ljava/lang/String;
    .locals 2

    .line 9
    new-instance v0, Ljava/util/ArrayList;

    invoke-direct {v0}, Ljava/util/ArrayList;-><init>()V

    const-string v1, "message1"

    .line 12
    invoke-virtual {v0, v1}, Ljava/util/ArrayList;->add(Ljava/lang/Object;)Z

    const-string v1, "message2"

    .line 15
    invoke-virtual {v0, v1}, Ljava/util/ArrayList;->add(Ljava/lang/Object;)Z

    const-string v1, "message3"

    .line 18
    invoke-virtual {v0, v1}, Ljava/util/ArrayList;->add(Ljava/lang/Object;)Z

    .line 20
    invoke-virtual {v0}, Ljava/util/ArrayList;->toArray()[Ljava/lang/Object;

    move-result-object v0

    invoke-static {v0}, Ljava/util/Arrays;->toString([Ljava/lang/Object;)Ljava/lang/String;

    move-result-object v0

    return-object v0
.end method

```

`src/test/test_resources/v1.0/com.obfuscapk.demo.v1.0-original/smali/com/obfuscapk/demo/R$color.smali`:

```smali
.class public final Lcom/obfuscapk/demo/R$color;
.super Ljava/lang/Object;


# annotations
.annotation system Ldalvik/annotation/EnclosingClass;
    value = Lcom/obfuscapk/demo/R;
.end annotation

.annotation system Ldalvik/annotation/InnerClass;
    accessFlags = 0x19
    name = "color"
.end annotation


# static fields
.field public static final buttonBackground:I = 0x7f010000

.field public static final colorAccent:I = 0x7f010001

.field public static final textForeground:I = 0x7f010002


# direct methods
.method private constructor <init>()V
    .locals 0

    invoke-direct {p0}, Ljava/lang/Object;-><init>()V

    return-void
.end method

```

`src/test/test_resources/v1.0/com.obfuscapk.demo.v1.0-original/smali/com/obfuscapk/demo/R$drawable.smali`:

```smali
.class public final Lcom/obfuscapk/demo/R$drawable;
.super Ljava/lang/Object;


# annotations
.annotation system Ldalvik/annotation/EnclosingClass;
    value = Lcom/obfuscapk/demo/R;
.end annotation

.annotation system Ldalvik/annotation/InnerClass;
    accessFlags = 0x19
    name = "drawable"
.end annotation


# static fields
.field public static final ic_launcher_background:I = 0x7f020001

.field public static final ic_launcher_foreground:I = 0x7f020002


# direct methods
.method private constructor <init>()V
    .locals 0

    invoke-direct {p0}, Ljava/lang/Object;-><init>()V

    return-void
.end method

```

`src/test/test_resources/v1.0/com.obfuscapk.demo.v1.0-original/smali/com/obfuscapk/demo/R$id.smali`:

```smali
.class public final Lcom/obfuscapk/demo/R$id;
.super Ljava/lang/Object;


# annotations
.annotation system Ldalvik/annotation/EnclosingClass;
    value = Lcom/obfuscapk/demo/R;
.end annotation

.annotation system Ldalvik/annotation/InnerClass;
    accessFlags = 0x19
    name = "id"
.end annotation


# static fields
.field public static final start_button:I = 0x7f030000

.field public static final start_password:I = 0x7f030001


# direct methods
.method private constructor <init>()V
    .locals 0

    invoke-direct {p0}, Ljava/lang/Object;-><init>()V

    return-void
.end method

```

`src/test/test_resources/v1.0/com.obfuscapk.demo.v1.0-original/smali/com/obfuscapk/demo/R$layout.smali`:

```smali
.class public final Lcom/obfuscapk/demo/R$layout;
.super Ljava/lang/Object;


# annotations
.annotation system Ldalvik/annotation/EnclosingClass;
    value = Lcom/obfuscapk/demo/R;
.end annotation

.annotation system Ldalvik/annotation/InnerClass;
    accessFlags = 0x19
    name = "layout"
.end annotation


# static fields
.field public static final activity_main:I = 0x7f040000


# direct methods
.method private constructor <init>()V
    .locals 0

    invoke-direct {p0}, Ljava/lang/Object;-><init>()V

    return-void
.end method

```

`src/test/test_resources/v1.0/com.obfuscapk.demo.v1.0-original/smali/com/obfuscapk/demo/R$mipmap.smali`:

```smali
.class public final Lcom/obfuscapk/demo/R$mipmap;
.super Ljava/lang/Object;


# annotations
.annotation system Ldalvik/annotation/EnclosingClass;
    value = Lcom/obfuscapk/demo/R;
.end annotation

.annotation system Ldalvik/annotation/InnerClass;
    accessFlags = 0x19
    name = "mipmap"
.end annotation


# static fields
.field public static final ic_launcher:I = 0x7f050000

.field public static final ic_launcher_round:I = 0x7f050001


# direct methods
.method private constructor <init>()V
    .locals 0

    invoke-direct {p0}, Ljava/lang/Object;-><init>()V

    return-void
.end method

```

`src/test/test_resources/v1.0/com.obfuscapk.demo.v1.0-original/smali/com/obfuscapk/demo/R$string.smali`:

```smali
.class public final Lcom/obfuscapk/demo/R$string;
.super Ljava/lang/Object;


# annotations
.annotation system Ldalvik/annotation/EnclosingClass;
    value = Lcom/obfuscapk/demo/R;
.end annotation

.annotation system Ldalvik/annotation/InnerClass;
    accessFlags = 0x19
    name = "string"
.end annotation


# static fields
.field public static final app_description:I = 0x7f060000

.field public static final app_name:I = 0x7f060001


# direct methods
.method private constructor <init>()V
    .locals 0

    invoke-direct {p0}, Ljava/lang/Object;-><init>()V

    return-void
.end method

```

`src/test/test_resources/v1.0/com.obfuscapk.demo.v1.0-original/smali/com/obfuscapk/demo/R$style.smali`:

```smali
.class public final Lcom/obfuscapk/demo/R$style;
.super Ljava/lang/Object;


# annotations
.annotation system Ldalvik/annotation/EnclosingClass;
    value = Lcom/obfuscapk/demo/R;
.end annotation

.annotation system Ldalvik/annotation/InnerClass;
    accessFlags = 0x19
    name = "style"
.end annotation


# static fields
.field public static final AppTheme:I = 0x7f070000


# direct methods
.method private constructor <init>()V
    .locals 0

    invoke-direct {p0}, Ljava/lang/Object;-><init>()V

    return-void
.end method

```

`src/test/test_resources/v1.0/com.obfuscapk.demo.v1.0-original/smali/com/obfuscapk/demo/R.smali`:

```smali
.class public final Lcom/obfuscapk/demo/R;
.super Ljava/lang/Object;


# annotations
.annotation system Ldalvik/annotation/MemberClasses;
    value = {
        Lcom/obfuscapk/demo/R$color;,
        Lcom/obfuscapk/demo/R$drawable;,
        Lcom/obfuscapk/demo/R$id;,
        Lcom/obfuscapk/demo/R$layout;,
        Lcom/obfuscapk/demo/R$mipmap;,
        Lcom/obfuscapk/demo/R$string;,
        Lcom/obfuscapk/demo/R$style;
    }
.end annotation


# direct methods
.method private constructor <init>()V
    .locals 0

    invoke-direct {p0}, Ljava/lang/Object;-><init>()V

    return-void
.end method

```

`src/test/test_tool.py`:

```py
#!/usr/bin/env python3

import os
import subprocess

import pytest

from obfuscapk.tool import Apktool, ApkSigner, Zipalign

# noinspection PyUnresolvedReferences
from test.test_fixtures import (
    tmp_working_directory_path,
    tmp_demo_apk_v10_original_path,
    tmp_demo_apk_v10_rebuild_path,
    tmp_demo_apk_v10_decoded_files_directory_path,
)


class TestApktool(object):
    def test_apktool_valid_path(self):
        apktool = Apktool()
        assert os.path.isfile(apktool.apktool_path)

        output = subprocess.check_output(
            apktool.apktool_path, stderr=subprocess.STDOUT, input=b"\n"
        ).decode()
        assert "usage: apktool" in output.lower()

    def test_apktool_wrong_path(self, monkeypatch):
        monkeypatch.setenv("APKTOOL_PATH", "invalid.apktool.path")
        with pytest.raises(RuntimeError):
            Apktool()

    def test_decode_valid_apk(self, tmp_demo_apk_v10_original_path: str):
        output = Apktool().decode(tmp_demo_apk_v10_original_path)
        assert "using apktool" in output.lower()

    def test_decode_error_invalid_apk_path(self):
        with pytest.raises(FileNotFoundError):
            Apktool().decode("invalid.apk.path")

    def test_decode_error_invalid_output_directory(
        self, tmp_demo_apk_v10_original_path: str
    ):
        with pytest.raises(NotADirectoryError):
            Apktool().decode(tmp_demo_apk_v10_original_path, "invalid.directory")

    def test_decode_error_existing_directory(
        self, tmp_working_directory_path: str, tmp_demo_apk_v10_original_path: str
    ):
        with pytest.raises(FileExistsError):
            Apktool().decode(
                tmp_demo_apk_v10_original_path, tmp_working_directory_path, force=False
            )

    def test_decode_error_invalid_file(self, tmp_working_directory_path: str):
        invalid_file_path = os.path.join(tmp_working_directory_path, "invalid.apk")

        with open(invalid_file_path, "w") as invalid_file:
            invalid_file.write("This is not an apk file\n")

        with pytest.raises(subprocess.CalledProcessError):
            Apktool().decode(invalid_file_path, force=True)

    def test_decode_error_generic(
        self, tmp_demo_apk_v10_original_path: str, monkeypatch
    ):
        def mock(*args, **kwargs):
            raise Exception

        monkeypatch.setattr("subprocess.check_output", mock)

        with pytest.raises(Exception):
            Apktool().decode(tmp_demo_apk_v10_original_path, force=True)

    def test_build_valid_apk(
        self,
        tmp_working_directory_path: str,
        tmp_demo_apk_v10_decoded_files_directory_path: str,
    ):
        output_apk_path = os.path.join(tmp_working_directory_path, "output.apk")
        output = Apktool().build(
            tmp_demo_apk_v10_decoded_files_directory_path,
            output_apk_path,
        )
        assert "using apktool" in output.lower()
        assert os.path.isfile(output_apk_path)

    def test_build_error_invalid_input_directory_path(self):
        with pytest.raises(NotADirectoryError):
            Apktool().build("invalid.input.directory.path")

    def test_build_error_invalid_input_directory(self, tmp_working_directory_path: str):
        invalid_directory_path = os.path.join(tmp_working_directory_path, "empty")
        os.makedirs(invalid_directory_path)

        with pytest.raises(subprocess.CalledProcessError):
            Apktool().build(invalid_directory_path)

    def test_build_error_generic(
        self, tmp_demo_apk_v10_decoded_files_directory_path: str, monkeypatch
    ):
        def mock(*args, **kwargs):
            raise Exception

        monkeypatch.setattr("subprocess.check_output", mock)

        with pytest.raises(Exception):
            Apktool().build(tmp_demo_apk_v10_decoded_files_directory_path)


class TestApkSigner(object):
    def test_apksigner_valid_path(self):
        apksigner = ApkSigner()
        assert os.path.isfile(apksigner.apksigner_path)

        output = subprocess.check_output(
            apksigner.apksigner_path, stderr=subprocess.STDOUT
        ).decode()
        assert "usage: apksigner" in output.lower()

    def test_apksigner_wrong_path(self, monkeypatch):
        monkeypatch.setenv("APKSIGNER_PATH", "invalid.apksigner.path")
        with pytest.raises(RuntimeError):
            ApkSigner()

    def test_resign_valid_apk(self, tmp_demo_apk_v10_rebuild_path: str):
        output = ApkSigner().resign(
            tmp_demo_apk_v10_rebuild_path,
            os.path.join(
                os.path.dirname(__file__),
                os.path.pardir,
                "obfuscapk",
                "resources",
                "obfuscation_keystore.jks",
            ),
            "obfuscation_password",
            "obfuscation_key",
        )
        assert "signed" in output.lower()

    def test_resign_error_generic(
        self, tmp_demo_apk_v10_original_path: str, monkeypatch
    ):
        def mock(*args, **kwargs):
            raise Exception

        monkeypatch.setattr("subprocess.check_output", mock)

        with pytest.raises(Exception):
            ApkSigner().resign(
                tmp_demo_apk_v10_original_path, "ignore", "ignore", "ignore"
            )

    def test_resign_error_signature_removal_error(
        self, tmp_demo_apk_v10_original_path: str, monkeypatch
    ):
        def mock(*args, **kwargs):
            raise Exception

        monkeypatch.setattr("zipfile.ZipFile", mock)

        with pytest.raises(Exception):
            ApkSigner().resign(
                tmp_demo_apk_v10_original_path, "ignore", "ignore", "ignore"
            )

    def test_sign_error_invalid_apk_path(self):
        with pytest.raises(FileNotFoundError):
            ApkSigner().sign("invalid.apk.path", "ignore", "ignore", "ignore")

    def test_sign_error_invalid_file(self, tmp_working_directory_path: str):
        invalid_file_path = os.path.join(tmp_working_directory_path, "invalid.apk")

        with open(invalid_file_path, "w") as invalid_file:
            invalid_file.write("This is not an apk file\n")

        with pytest.raises(subprocess.CalledProcessError):
            ApkSigner().sign(invalid_file_path, "ignore", "ignore", "ignore")

    def test_sign_error_invalid_key_password(self, tmp_demo_apk_v10_rebuild_path: str):
        with pytest.raises(subprocess.CalledProcessError):
            ApkSigner().sign(
                tmp_demo_apk_v10_rebuild_path,
                os.path.join(
                    os.path.dirname(__file__),
                    os.path.pardir,
                    "obfuscapk",
                    "resources",
                    "obfuscation_keystore.jks",
                ),
                "obfuscation_password",
                "obfuscation_key",
                "invalid.key.password",
            )


class TestZipalign(object):
    def test_zipalign_valid_path(self):
        zipalign = Zipalign()
        assert os.path.isfile(zipalign.zipalign_path)

        with pytest.raises(subprocess.CalledProcessError) as e:
            subprocess.check_output(zipalign.zipalign_path, stderr=subprocess.STDOUT)
        assert "usage: zipalign" in e.value.output.decode().lower()

    def test_zipalign_wrong_path(self, monkeypatch):
        monkeypatch.setenv("ZIPALIGN_PATH", "invalid.zipalign.path")
        with pytest.raises(RuntimeError):
            Zipalign()

    def test_align_valid_apk(self, tmp_demo_apk_v10_rebuild_path: str):
        output = Zipalign().align(tmp_demo_apk_v10_rebuild_path)
        assert "verification succes" in output.lower()

    def test_align_error_invalid_apk_path(self):
        with pytest.raises(FileNotFoundError):
            Zipalign().align("invalid.apk.path")

    def test_align_error_invalid_file(self, tmp_working_directory_path: str):
        invalid_file_path = os.path.join(tmp_working_directory_path, "invalid.apk")

        with open(invalid_file_path, "w") as invalid_file:
            invalid_file.write("This is not an apk file\n")

        with pytest.raises(subprocess.CalledProcessError):
            Zipalign().align(invalid_file_path)

    def test_align_error_generic(self, tmp_demo_apk_v10_rebuild_path: str, monkeypatch):
        def mock(*args, **kwargs):
            raise Exception

        monkeypatch.setattr("subprocess.check_output", mock)

        with pytest.raises(Exception):
            Zipalign().align(tmp_demo_apk_v10_rebuild_path)

```