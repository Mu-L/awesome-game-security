Project Path: arc_sneakyevilSK_IL2CPP_Resolver_akkh4mp5

Source Tree:

```txt
arc_sneakyevilSK_IL2CPP_Resolver_akkh4mp5
├── API
│   ├── Callback.hpp
│   ├── Class.hpp
│   ├── Domain.hpp
│   ├── ResolveCall.hpp
│   ├── String.hpp
│   └── Thread.hpp
├── Data.hpp
├── Defines.hpp
├── IL2CPP_Resolver.hpp
├── LICENSE
├── README.md
├── SystemTypeCache.hpp
├── Unity
│   ├── API
│   │   ├── Camera.hpp
│   │   ├── Component.hpp
│   │   ├── GameObject.hpp
│   │   ├── LayerMask.hpp
│   │   ├── Object.hpp
│   │   ├── Rigidbody.hpp
│   │   └── Transform.hpp
│   ├── Defines.hpp
│   ├── Obfuscators.hpp
│   └── Structures
│       ├── Engine.hpp
│       ├── System_String.hpp
│       ├── il2cpp.hpp
│       ├── il2cppArray.hpp
│       └── il2cppDictionary.hpp
└── Utils
    ├── Hash.hpp
    ├── Helper.hpp
    └── VTable.hpp

```

`API/Callback.hpp`:

```hpp
#pragma once

namespace IL2CPP
{
	struct CallbackHook_t
	{
		std::vector<void*> m_Funcs;

		void** m_VFunc = nullptr;
		void* m_Original = nullptr;
	};

	namespace Callback
	{
		namespace OnUpdate
		{
			CallbackHook_t m_CallbackHook;

			void Add(void* m_pFunction) 
			{ 
				m_CallbackHook.m_Funcs.emplace_back(m_pFunction);
			}

			void __fastcall Hook(void* rcx)
			{
				for (void* m_Func : m_CallbackHook.m_Funcs)
					reinterpret_cast<void(*)()>(m_Func)();

				reinterpret_cast<void(__fastcall*)(void*)>(m_CallbackHook.m_Original)(rcx);
			}
		}

		namespace OnLateUpdate
		{
			CallbackHook_t m_CallbackHook;

			void Add(void* m_pFunction)
			{
				m_CallbackHook.m_Funcs.emplace_back(m_pFunction);
			}

			void __fastcall Hook(void* rcx)
			{
				for (void* m_Func : m_CallbackHook.m_Funcs)
					reinterpret_cast<void(*)()>(m_Func)();

				reinterpret_cast<void(__fastcall*)(void*)>(m_CallbackHook.m_Original)(rcx);
			}
		}

		void Initialize()
		{
			void* m_IL2CPPThread = Thread::Attach(IL2CPP::Domain::Get());

			// Find
			void** m_MonoBehaviourVTable = *reinterpret_cast<void***>(IL2CPP::Helper::GetMonoBehaviour()->m_CachedPtr);
			if (m_MonoBehaviourVTable)
			{
#ifdef _WIN64
				OnUpdate::m_CallbackHook.m_VFunc		= Utils::VTable::FindFunction(m_MonoBehaviourVTable, 99, { 0x33, 0xD2, 0xE9 }); // xor edx, edx | jmp
				OnLateUpdate::m_CallbackHook.m_VFunc	= Utils::VTable::FindFunction(m_MonoBehaviourVTable, 99, { 0xBA, 0x01, 0x00, 0x00, 0x00, 0xE9 }); //  mov edx, 1 | jmp
#elif _WIN32
				OnUpdate::m_CallbackHook.m_VFunc		= Utils::VTable::FindFunction(m_MonoBehaviourVTable, 99, { 0x6A, 0x00, 0xE8 }); // push 00 | call
				OnLateUpdate::m_CallbackHook.m_VFunc	= Utils::VTable::FindFunction(m_MonoBehaviourVTable, 99, { 0x6A, 0x01, 0xE8 }); // push 01 | call
#endif
			}

			IL2CPP::Thread::Detach(m_IL2CPPThread);

			// Replace (Hook)
			Utils::VTable::ReplaceFunction(OnUpdate::m_CallbackHook.m_VFunc, OnUpdate::Hook, &OnUpdate::m_CallbackHook.m_Original);
			Utils::VTable::ReplaceFunction(OnLateUpdate::m_CallbackHook.m_VFunc, OnLateUpdate::Hook, &OnLateUpdate::m_CallbackHook.m_Original);
		}

		void Uninitialize()
		{
			Utils::VTable::ReplaceFunction(OnUpdate::m_CallbackHook.m_VFunc, OnUpdate::m_CallbackHook.m_Original);
			Utils::VTable::ReplaceFunction(OnLateUpdate::m_CallbackHook.m_VFunc, OnLateUpdate::m_CallbackHook.m_Original);
		}
	}
}
```

`API/Class.hpp`:

```hpp
#pragma once

namespace IL2CPP
{
    namespace Class
    {
        Unity::il2cppFieldInfo* GetFields(Unity::il2cppClass* m_pClass, void** m_pIterator)
        {
            return reinterpret_cast<Unity::il2cppFieldInfo * (IL2CPP_CALLING_CONVENTION)(void*, void**)>(Functions.m_ClassGetFields)(m_pClass, m_pIterator);
        }

        void FetchFields(Unity::il2cppClass* m_pClass, std::vector<Unity::il2cppFieldInfo*>* m_pVector, void* m_pFieldIterator = nullptr)
        {
            m_pVector->clear();

            while (1)
            {
                Unity::il2cppFieldInfo* m_pField = GetFields(m_pClass, &m_pFieldIterator);
                if (!m_pField)
                    break;

                m_pVector->emplace_back(m_pField);
            }
        }

        Unity::il2cppMethodInfo* GetMethods(Unity::il2cppClass* m_pClass, void** m_pIterator)
        {
            return reinterpret_cast<Unity::il2cppMethodInfo * (IL2CPP_CALLING_CONVENTION)(void*, void**)>(Functions.m_ClassGetMethods)(m_pClass, m_pIterator);
        }

        void FetchMethods(Unity::il2cppClass* m_pClass, std::vector<Unity::il2cppMethodInfo*>* m_pVector, void* m_pMethodIterator = nullptr)
        {
            m_pVector->clear();

            while (1)
            {
                Unity::il2cppMethodInfo* m_pMethod = GetMethods(m_pClass, &m_pMethodIterator);
                if (!m_pMethod)
                    break;

                m_pVector->emplace_back(m_pMethod);
            }
        }

        Unity::il2cppType* GetType(Unity::il2cppClass* m_pClass)
        {
            return reinterpret_cast<Unity::il2cppType * (IL2CPP_CALLING_CONVENTION)(void*)>(Functions.m_ClassGetType)(m_pClass);
        }

        Unity::il2cppObject* GetSystemType(Unity::il2cppClass* m_pClass)
        {
            return reinterpret_cast<Unity::il2cppObject * (IL2CPP_CALLING_CONVENTION)(void*)>(Functions.m_TypeGetObject)(GetType(m_pClass));
        }

        Unity::il2cppClass* GetFromName(Unity::il2cppImage* m_pImage, const char* m_pNamespace, const char* m_pName)
        {
            return reinterpret_cast<Unity::il2cppClass * (IL2CPP_CALLING_CONVENTION)(void*, const char*, const char*)>(Functions.m_ClassFromName)(m_pImage, m_pNamespace, m_pName);
        }

        Unity::il2cppClass* Find(const char* m_pName)
        {
            size_t m_sAssembliesCount = 0U;
            Unity::il2cppAssembly** m_pAssemblies = Domain::GetAssemblies(&m_sAssembliesCount);
            if (!m_pAssemblies || 0U >= m_sAssembliesCount) return nullptr;

            const char* m_pNameSpaceEnd = strrchr(m_pName, '.');
            char* m_pNameSpace = nullptr;
            if (m_pNameSpaceEnd)
            {
                uintptr_t m_uNamespaceSize = static_cast<uintptr_t>(m_pNameSpaceEnd - m_pName);
                m_pNameSpace = new char[m_uNamespaceSize + 1];
                memcpy(m_pNameSpace, m_pName, m_uNamespaceSize);
                m_pNameSpace[m_uNamespaceSize] = '\0';

                m_pName = m_pNameSpaceEnd + 1;
            }
            else
            {
                m_pNameSpace = new char[2];
                memset(m_pNameSpace, 0, 2);
            }

            Unity::il2cppClass* m_pClassReturn = nullptr;
            for (size_t i = 0U; m_sAssembliesCount > i; ++i)
            {
                Unity::il2cppAssembly* m_pAssembly = m_pAssemblies[i];
                if (!m_pAssembly || !m_pAssembly->m_pImage) continue;

                m_pClassReturn = GetFromName(m_pAssembly->m_pImage, m_pNameSpace, m_pName);
                if (m_pClassReturn) break;
            }

            delete[] m_pNameSpace;
            return m_pClassReturn;
        }

        Unity::il2cppObject* GetSystemType(const char* m_pClassName)
        {
            Unity::il2cppClass* m_pClass = Find(m_pClassName);
            if (!m_pClass)
                return nullptr;

            return GetSystemType(m_pClass);
        }

        void FetchClasses(std::vector<Unity::il2cppClass*>* m_pVector, const char* m_pModuleName, const char* m_pNamespace)
        {
            m_pVector->clear();

            size_t m_sAssembliesCount = 0U;
            Unity::il2cppAssembly** m_pAssemblies = Domain::GetAssemblies(&m_sAssembliesCount);
            if (!m_pAssemblies || 0U >= m_sAssembliesCount) return;

            Unity::il2cppImage* m_pImage = nullptr;
            for (size_t i = 0U; m_sAssembliesCount > i; ++i)
            {
                Unity::il2cppAssembly* m_pAssembly = m_pAssemblies[i];
                if (!m_pAssembly || !m_pAssembly->m_pImage || strcmp(m_pAssembly->m_pImage->m_pNameNoExt, m_pModuleName) != 0)
                    continue;

                m_pImage = m_pAssembly->m_pImage;
                break;
            }

            if (m_pImage)
            {
                size_t m_sClassesCount = reinterpret_cast<size_t(IL2CPP_CALLING_CONVENTION)(void*)>(Functions.m_ImageGetClassCount)(m_pImage);
                for (size_t i = 0U; m_sClassesCount > i; ++i)
                {
                    Unity::il2cppClass* m_pClass = reinterpret_cast<Unity::il2cppClass * (IL2CPP_CALLING_CONVENTION)(void*, size_t)>(Functions.m_ImageGetClass)(m_pImage, i);
                    if (m_pNamespace)
                    {
                        if (m_pNamespace[0] == '\0')
                        {
                            if (m_pClass->m_pNamespace[0] != '\0')
                                continue;
                        }
                        else if (strcmp(m_pClass->m_pNamespace, m_pNamespace) != 0)
                            continue;
                    }

                    m_pVector->emplace_back(m_pClass);
                }
            }
        }

        namespace Utils
        {
            int GetFieldOffset(Unity::il2cppClass* m_pClass, const char* m_pName)
            {
                void* m_pFieldIterator = nullptr;
                while (1)
                {
                    Unity::il2cppFieldInfo* m_pField = GetFields(m_pClass, &m_pFieldIterator);
                    if (!m_pField)
                        break;

                    if (strcmp(m_pField->m_pName, m_pName) == 0)
                        return m_pField->m_iOffset;
                }

                return -1;
            }

            int GetFieldOffset(const char* m_pClassName, const char* m_pName)
            {
                Unity::il2cppClass* m_pClass = Find(m_pClassName);
                if (m_pClass)
                    return GetFieldOffset(m_pClass, m_pName);

                return -1;
            }

            void SetStaticField(Unity::il2cppClass* m_pClass, const char* m_pMemberName, void* m_pValue) {
                Unity::il2cppFieldInfo* m_pField = reinterpret_cast<Unity::il2cppFieldInfo * (IL2CPP_CALLING_CONVENTION)(void*, const char*)>(Functions.m_ClassGetFieldFromName)(m_pClass, m_pMemberName);
                if (m_pField)
                    reinterpret_cast<void (IL2CPP_CALLING_CONVENTION)(Unity::il2cppFieldInfo*, void*)>(Functions.m_FieldStaticSetValue)(m_pField, m_pValue);
            }

            void SetStaticField(const char* m_pClassName, const char* m_pMemberName, void* m_pValue) {
                Unity::il2cppClass* m_pClass = Find(m_pClassName);
                if (m_pClass)
                    SetStaticField(m_pClass, m_pMemberName, m_pValue);
            }

            void* GetStaticField(Unity::il2cppClass* m_pClass, const char* m_pMemberName) {
                Unity::il2cppFieldInfo* m_pField = reinterpret_cast<Unity::il2cppFieldInfo * (IL2CPP_CALLING_CONVENTION)(void*, const char*)>(Functions.m_ClassGetFieldFromName)(m_pClass, m_pMemberName);
                void* m_pValue = nullptr;
                if (m_pField)
                    reinterpret_cast<void (IL2CPP_CALLING_CONVENTION)(Unity::il2cppFieldInfo*, void*)>(Functions.m_FieldStaticGetValue)(m_pField, &m_pValue);

                return m_pValue;
            }

            void* GetStaticField(const char* m_pClassName, const char* m_pMemberName)
            {
                Unity::il2cppClass* m_pClass = Find(m_pClassName);
                if (m_pClass)
                    return GetStaticField(m_pClass, m_pMemberName);

                return nullptr;
            }

            void* GetMethodPointer(Unity::il2cppClass* m_pClass, const char* m_pMethodName, int m_iArgs = -1)
            {
                Unity::il2cppMethodInfo* pMethod = reinterpret_cast<Unity::il2cppMethodInfo * (IL2CPP_CALLING_CONVENTION)(void*, const char*, int)>(Functions.m_ClassGetMethodFromName)(m_pClass, m_pMethodName, m_iArgs);
                if (!pMethod) return nullptr;

                return pMethod->m_pMethodPointer;
            }

            void* GetMethodPointer(const char* m_pClassName, const char* m_pMethodName, int m_iArgs = -1)
            {
                Unity::il2cppClass* m_pClass = Find(m_pClassName);
                if (m_pClass)
                    return GetMethodPointer(m_pClass, m_pMethodName, m_iArgs);

                return nullptr;
            }

            const char* MethodGetParamName(Unity::il2cppMethodInfo* m_pMethodInfo, uint32_t index)
            {
                if (index >= m_pMethodInfo->m_uArgsCount)
                    return nullptr;

                return reinterpret_cast<const char * (IL2CPP_CALLING_CONVENTION)(void*, uint32_t)>(Functions.m_MethodGetParamName)(m_pMethodInfo, index);
            }

            Unity::il2cppType* GetMethodParamType(Unity::il2cppMethodInfo* m_pMethodInfo, uint32_t index) {
                if (index >= m_pMethodInfo->m_uArgsCount)
                    return nullptr;

                return reinterpret_cast<Unity::il2cppType * (IL2CPP_CALLING_CONVENTION)(void*, uint32_t)>(Functions.m_MethodGetParam)(m_pMethodInfo, index);
            }

            Unity::il2cppClass* ClassFromType(Unity::il2cppType * type)
            {
                return reinterpret_cast<Unity::il2cppClass * (IL2CPP_CALLING_CONVENTION)(void*)>(Functions.m_ClassFromIl2cppType)(type);
            }

            void* GetMethodPointer(const char* m_pClassName, const char* m_pMethodName, std::initializer_list<const char*> m_vNames)
            {
                Unity::il2cppClass* m_pClass = Find(m_pClassName);
                if (!m_pClass)
                    return nullptr;

                int m_iNamesCount = static_cast<int>(m_vNames.size());
                const char** m_pNames = const_cast<const char**>(m_vNames.begin());

                void* m_pMethodIterator = nullptr;
                while (1)
                {
                    Unity::il2cppMethodInfo* m_pMethod = GetMethods(m_pClass, &m_pMethodIterator);
                    if (!m_pMethod)
                        break;

                    if (strcmp(m_pMethod->m_pName, m_pMethodName) != 0)
                        continue;

                    #ifdef UNITY_VERSION_2022_3_8F1
                    Unity::il2cppType** m_pCurrentParameterTypes = m_pMethod->m_pParameters;

                    for (size_t i = 0; i < m_pMethod->m_uArgsCount; ++i)
                    {
                        Unity::il2cppType* m_pCurrentParameterType = m_pCurrentParameterTypes[i];
                        Unity::il2cppClass* m_pClass = ClassFromType(m_pCurrentParameterType);

                        if (strcmp(m_pClass->m_pName, m_pNames[i]) != 0)
                            break;

                        if ((i + 1) == m_iNamesCount)
                            return m_pMethod->m_pMethodPointer;
                    }
                    #else
                    Unity::il2cppParameterInfo* m_pCurrentParameters = m_pMethod->m_pParameters;
                    for (int i = 0; m_iNamesCount > i; ++i)
                    {
                        if (strcmp(m_pCurrentParameters->m_pName, m_pNames[i]) != 0)
                            break;

                        m_pCurrentParameters++; // m_pCurrentParameters += sizeof(Unity::il2cppParameterInfo);
                        if ((i + 1) == m_iNamesCount)
                            return m_pMethod->m_pMethodPointer;
                    }
                    #endif
                }
                return nullptr;
            }

            Unity::il2cppClass* FilterClass(std::vector<Unity::il2cppClass*>* m_pClasses, std::initializer_list<const char*> m_vNames, int m_iFoundCount = -1)
            {
                int m_iNamesCount = static_cast<int>(m_vNames.size());
                const char** m_pNames = const_cast<const char**>(m_vNames.begin());

                if (0 >= m_iFoundCount || m_iFoundCount > m_iNamesCount)
                    m_iFoundCount = m_iNamesCount;

                Unity::il2cppClass* m_pReturn = nullptr;
                for (size_t c = 0; m_pClasses->size() > c; ++c)
                {
                    int m_iFoundCountNow = 0;

                    Unity::il2cppClass* m_pClass = m_pClasses->operator[](c);
                    if (!m_pClass)
                        continue;

                    for (int i = 0; m_iNamesCount > i; ++i)
                    {
                        const char* m_pNameToFind = m_pNames[i];

                        bool m_bFoundInClass = false;
                        if (m_pNameToFind[0] == '~') // Field
                            m_bFoundInClass = GetFieldOffset(m_pClass, &m_pNameToFind[1]) >= 0;
                        else if (m_pNameToFind[0] == '-') // Method
                            m_bFoundInClass = GetMethodPointer(m_pClass, &m_pNameToFind[1]) != nullptr;
                        else // Both
                        {
                            m_bFoundInClass = GetFieldOffset(m_pClass, m_pNameToFind) >= 0;
                            if (!m_bFoundInClass)
                                m_bFoundInClass = GetMethodPointer(m_pClass, m_pNameToFind) != nullptr;
                        }

                        if (m_bFoundInClass)
                            ++m_iFoundCountNow;
                    }

                    if (m_iFoundCount == m_iFoundCountNow)
                    {
                        m_pReturn = m_pClass;
                        break;
                    }
                }

                return m_pReturn;
            }

            void* FilterClassToMethodPointer(std::vector<Unity::il2cppClass*>* m_pClasses, const char* m_pMethodName, int m_iArgs = -1)
            {
                void* m_pMethodPointer = nullptr;
                for (size_t c = 0; m_pClasses->size() > c; ++c)
                {
                    Unity::il2cppClass* m_pClass = m_pClasses->operator[](c);
                    if (!m_pClass)
                        continue;

                    m_pMethodPointer = GetMethodPointer(m_pClass, m_pMethodName, m_iArgs);
                    if (m_pMethodPointer)
                        break;
                }

                return m_pMethodPointer;
            }
        }
    }

    enum class m_eClassPropType : int
    {
        Unknown = 0,
        Field,			// Member of class that can be accessed directly by RVA
        Property,		// Member of class that can be accessed by calling function
        Method,			// Function of class
    };

    // Main Class
    class CClass
    {
    public:
        Unity::il2cppObject m_Object = { 0 };
        void* m_CachedPtr = nullptr;

        // Wrappers for namespace, ah...
        Unity::il2cppFieldInfo* GetFields(void** m_pIterator)
        {
            return Class::GetFields(m_Object.m_pClass, m_pIterator);
        }

        void FetchFields(std::vector<Unity::il2cppFieldInfo*>* m_pVector, void* m_pFieldIterator = nullptr)
        {
            Class::FetchFields(m_Object.m_pClass, m_pVector, m_pFieldIterator);
        }

        Unity::il2cppMethodInfo* GetMethods(void** m_pIterator)
        {
            return Class::GetMethods(m_Object.m_pClass, m_pIterator);
        }

        void FetchMethods(std::vector<Unity::il2cppMethodInfo*>* m_pVector, void* m_pMethodIterator = nullptr)
        {
            Class::FetchMethods(m_Object.m_pClass, m_pVector, m_pMethodIterator);
        }

        void* GetMethodPointer(const char* m_pMethodName, int m_iArgs = -1)
        {
            return Class::Utils::GetMethodPointer(m_Object.m_pClass, m_pMethodName, m_iArgs);
        }

        m_eClassPropType GetPropType(const char* m_pPropType)
        {
            Unity::il2cppFieldInfo* pField = reinterpret_cast<Unity::il2cppFieldInfo*(IL2CPP_CALLING_CONVENTION)(void*, const char*)>(Functions.m_ClassGetFieldFromName)(m_Object.m_pClass, m_pPropType);
            if (pField)
                return m_eClassPropType::Field;

            Unity::il2cppPropertyInfo* pProperty = reinterpret_cast<Unity::il2cppPropertyInfo*(IL2CPP_CALLING_CONVENTION)(void*, const char*)>(Functions.m_ClassGetPropertyFromName)(m_Object.m_pClass, m_pPropType);
            if (pProperty)
                return m_eClassPropType::Property;

            Unity::il2cppMethodInfo* pMethod = reinterpret_cast<Unity::il2cppMethodInfo*(IL2CPP_CALLING_CONVENTION)(void*, const char*, int)>(Functions.m_ClassGetMethodFromName)(m_Object.m_pClass, m_pPropType, -1);
            if (pMethod)
                return m_eClassPropType::Method;

            return m_eClassPropType::Unknown;
        }

        // Call Method
        template<typename TReturn, typename... TArgs>
        TReturn CallMethod(void* m_pMethod, TArgs... tArgs) { return reinterpret_cast<TReturn(UNITY_CALLING_CONVENTION)(void*, TArgs...)>(m_pMethod)(this, tArgs...); }

        template<typename TReturn, typename... TArgs>
        TReturn CallMethod(const char* m_pMethodName, TArgs... tArgs) { return CallMethod<TReturn>(GetMethodPointer(m_pMethodName), tArgs...); }

        template<typename TReturn, typename... TArgs>
        TReturn CallMethodSafe(void* m_pMethod, TArgs... tArgs)
        {
            if (!m_pMethod)
            {
#ifdef _DEBUG 
                __debugbreak(); // remove it when you wanna step through your code and be like why the fuck it doesn't do anything.
#endif

                TReturn m_tDefault = {}; // void goes like illegal use of type. (use void* and fuck them)
                return m_tDefault;
            }

            return CallMethod<TReturn>(m_pMethod, tArgs...);
        }

        template<typename TReturn, typename... TArgs>
        TReturn CallMethodSafe(const char* m_pMethodName, TArgs... tArgs) { return CallMethodSafe<TReturn>(GetMethodPointer(m_pMethodName), tArgs...); }

        // Properties/Fields

        template<typename T>
        T GetPropertyValue(const char* m_pPropertyName)
        {
            Unity::il2cppPropertyInfo* pProperty = reinterpret_cast<Unity::il2cppPropertyInfo * (IL2CPP_CALLING_CONVENTION)(void*, const char*)>(Functions.m_ClassGetPropertyFromName)(m_Object.m_pClass, m_pPropertyName);
            if (pProperty && pProperty->m_pGet)
                return reinterpret_cast<T(UNITY_CALLING_CONVENTION)(void*)>(pProperty->m_pGet->m_pMethodPointer)(this);

            T tDefault = {};
            return tDefault;
        }

        template<typename T>
        void SetPropertyValue(const char* m_pPropertyName, T m_tValue)
        {
            Unity::il2cppPropertyInfo* pProperty = reinterpret_cast<Unity::il2cppPropertyInfo * (IL2CPP_CALLING_CONVENTION)(void*, const char*)>(Functions.m_ClassGetPropertyFromName)(m_Object.m_pClass, m_pPropertyName);
            if (pProperty && pProperty->m_pSet)
                return reinterpret_cast<void(UNITY_CALLING_CONVENTION)(void*, T)>(pProperty->m_pSet->m_pMethodPointer)(this, m_tValue);
        }

        template<typename T>
        __inline T GetMemberValue(int m_iOffset)
        {
            return *reinterpret_cast<T*>(reinterpret_cast<uintptr_t>(this) + m_iOffset);
        }

        template<typename T>
        __inline void SetMemberValue(int m_iOffset, T m_tValue)
        {
            *reinterpret_cast<T*>(reinterpret_cast<uintptr_t>(this) + m_iOffset) = m_tValue;
        }

        template<typename T>
        __inline T GetMemberValue(Unity::il2cppFieldInfo* m_pField)
        {
            if (!m_pField || 0 > m_pField->m_iOffset)
            {
                T m_tDefault = {};
                return m_tDefault;
            }

            return GetMemberValue<T>(m_pField->m_iOffset);
        }

        template<typename T>
        __inline void SetMemberValue(Unity::il2cppFieldInfo* m_pField, T m_tValue)
        {
            if (!m_pField || 0 > m_pField->m_iOffset)
                return;

            SetMemberValue<T>(m_pField->m_iOffset, m_tValue);
        }

        template<typename T>
        T GetMemberValue(const char* m_pMemberName)
        {
            Unity::il2cppFieldInfo* pField = reinterpret_cast<Unity::il2cppFieldInfo * (IL2CPP_CALLING_CONVENTION)(void*, const char*)>(Functions.m_ClassGetFieldFromName)(m_Object.m_pClass, m_pMemberName);
            if (pField)
            {
                if (pField->m_iOffset >= 0) return *reinterpret_cast<T*>(reinterpret_cast<uintptr_t>(this) + pField->m_iOffset);
            }
            else
                return GetPropertyValue<T>(m_pMemberName);

            T tDefault = {};
            return tDefault;
        }

        template<typename T>
        void SetMemberValue(const char* m_pMemberName, T m_tValue)
        {
            Unity::il2cppFieldInfo* pField = reinterpret_cast<Unity::il2cppFieldInfo * (IL2CPP_CALLING_CONVENTION)(void*, const char*)>(Functions.m_ClassGetFieldFromName)(m_Object.m_pClass, m_pMemberName);
            if (pField)
            {
                if (pField->m_iOffset >= 0) *reinterpret_cast<T*>(reinterpret_cast<uintptr_t>(this) + pField->m_iOffset) = m_tValue;
                return;
            }

            SetPropertyValue<T>(m_pMemberName, m_tValue);
        }

        template<typename T>
        __inline T GetObscuredViaOffset(int m_iOffset)
        {
            if (m_iOffset >= 0)
            {
                switch (sizeof(T))
                {
                    case sizeof(double) :
                    {
                        long long m_lKey = *reinterpret_cast<long long*>(reinterpret_cast<uintptr_t>(this) + m_iOffset);
                        long long m_lValue = *reinterpret_cast<long long*>(reinterpret_cast<uintptr_t>(this) + m_iOffset + sizeof(m_lKey));

                        m_lValue ^= m_lKey;
                        return *reinterpret_cast<T*>(&m_lValue);
                    }
                    break;
                    case sizeof(int) :
                    {
                        int m_iKey = *reinterpret_cast<int*>(reinterpret_cast<uintptr_t>(this) + m_iOffset);
                        int m_iValue = *reinterpret_cast<int*>(reinterpret_cast<uintptr_t>(this) + m_iOffset + sizeof(m_iKey));

                        m_iValue ^= m_iKey;
                        return *reinterpret_cast<T*>(&m_iValue);
                    }
                    break;
                    case sizeof(bool) :
                    {
                        unsigned char m_uKey = *reinterpret_cast<unsigned char*>(reinterpret_cast<uintptr_t>(this) + m_iOffset);
                        int m_iValue = *reinterpret_cast<int*>(reinterpret_cast<uintptr_t>(this) + m_iOffset + sizeof(m_uKey));

                        m_iValue ^= m_uKey;
                        return *reinterpret_cast<T*>(&m_iValue);
                    }
                    break;
                }
            }

            T m_tDefault = { 0 };
            return m_tDefault;
        }

        template<typename T>
        T GetObscuredValue(const char* m_pMemberName)
        {
            Unity::il2cppFieldInfo* m_pField = reinterpret_cast<Unity::il2cppFieldInfo * (IL2CPP_CALLING_CONVENTION)(void*, const char*)>(Functions.m_ClassGetFieldFromName)(m_Object.m_pClass, m_pMemberName);
            return GetObscuredViaOffset<T>(m_pField ? m_pField->m_iOffset : -1);
        }

        template<typename T>
        __inline void SetObscuredViaOffset(int m_iOffset, T m_tValue)
        {
            if (0 > m_iOffset)
                return;

            switch (sizeof(T))
            {
                case sizeof(double) :
                {
                    long long m_lKey = *reinterpret_cast<long long*>(reinterpret_cast<uintptr_t>(this) + m_iOffset);
                    long long* m_pValue = reinterpret_cast<long long*>(reinterpret_cast<uintptr_t>(this) + m_iOffset + sizeof(m_lKey));

                    *m_pValue = *reinterpret_cast<long long*>(&m_tValue) ^ m_lKey;
                }
                break;
                case sizeof(int) :
                {
                    int m_iKey = *reinterpret_cast<int*>(reinterpret_cast<uintptr_t>(this) + m_iOffset);
                    int* m_pValue = reinterpret_cast<int*>(reinterpret_cast<uintptr_t>(this) + m_iOffset + sizeof(m_iKey));

                    *m_pValue = *reinterpret_cast<int*>(&m_tValue) ^ m_iKey;
                }
                break;
                case sizeof(bool) :
                {
                    unsigned char m_uKey = *reinterpret_cast<unsigned char*>(reinterpret_cast<uintptr_t>(this) + m_iOffset);
                    int* m_pValue = reinterpret_cast<int*>(reinterpret_cast<uintptr_t>(this) + m_iOffset + sizeof(m_uKey));

                    *m_pValue = *reinterpret_cast<int*>(&m_tValue) ^ m_uKey;
                }
                break;
            }
        }

        template<typename T>
        void SetObscuredValue(const char* m_pMemberName, T m_tValue)
        {
            Unity::il2cppFieldInfo* m_pField = reinterpret_cast<Unity::il2cppFieldInfo * (IL2CPP_CALLING_CONVENTION)(void*, const char*)>(Functions.m_ClassGetFieldFromName)(m_Object.m_pClass, m_pMemberName);
            if (!m_pField)
                return;

            SetObscuredViaOffset<T>(m_pField->m_iOffset, m_tValue);
        }
    };
}
```

`API/Domain.hpp`:

```hpp
#pragma once

namespace IL2CPP
{
	namespace Domain
	{
		void* Get()
		{
			return reinterpret_cast<void*(IL2CPP_CALLING_CONVENTION)()>(Functions.m_DomainGet)();
		}

		Unity::il2cppAssembly** GetAssemblies(size_t* m_Size)
		{
			return reinterpret_cast<Unity::il2cppAssembly**(IL2CPP_CALLING_CONVENTION)(void*, size_t*)>(Functions.m_DomainGetAssemblies)(Get(), m_Size);
		}
	}
}
```

`API/ResolveCall.hpp`:

```hpp
#pragma once

namespace IL2CPP
{
	// Without this function, you're pretty much fucked up.
	void* ResolveCall(const char* m_Name)
	{
		return reinterpret_cast<void*(IL2CPP_CALLING_CONVENTION)(const char*)>(Functions.m_ResolveFunction)(m_Name);
	}
}
```

`API/String.hpp`:

```hpp
#pragma once

namespace IL2CPP
{
	namespace String
	{
		Unity::System_String* New(const char* m_String)
		{
			return reinterpret_cast<Unity::System_String*(IL2CPP_CALLING_CONVENTION)(const char*)>(Functions.m_StringNew)(m_String);
		}

		Unity::System_String* New(std::string m_String) 
		{ 
			return New(&m_String[0]);
		}

		namespace NoGC
		{
			Unity::System_String* New(const char* m_String)
			{
				Unity::System_String* m_NewString = new Unity::System_String;
				m_NewString->m_pClass = IL2CPP::Class::Find(IL2CPP_RStr("System.String"));
				m_NewString->m_iLength = swprintf_s(m_NewString->m_wString, (sizeof(Unity::System_String::m_wString) / 4), L"%hs", m_String);

				return m_NewString;
			}

			Unity::System_String* New(std::string m_String) 
			{
				return New(&m_String[0]); 
			}
		}
	}
}
```

`API/Thread.hpp`:

```hpp
#pragma once

namespace IL2CPP
{
	namespace Thread
	{
		void* Attach(void* m_Domain)
		{
			return reinterpret_cast<void* (IL2CPP_CALLING_CONVENTION)(void*)>(Functions.m_ThreadAttach)(m_Domain);
		}

		void Detach(void* m_Thread)
		{
			reinterpret_cast<void(IL2CPP_CALLING_CONVENTION)(void*)>(Functions.m_ThreadDetach)(m_Thread);
		}
	}

	// Our Stuff
	class CThread
	{
	public:
		void* m_OnStart = nullptr;
		void* m_OnEnd = nullptr;

		static DWORD __stdcall Handler(void* m_Reserved)
		{
			void* m_IL2CPPThread = Thread::Attach(Domain::Get());

			CThread* m_Thread = reinterpret_cast<CThread*>(m_Reserved);
			void* m_ThreadStart = m_Thread->m_OnStart;
			void* m_ThreadEnd = m_Thread->m_OnEnd;
			delete m_Thread;

			reinterpret_cast<void(*)()>(m_ThreadStart)();
			if (m_ThreadEnd)
				reinterpret_cast<void(*)()>(m_ThreadEnd)();

			Thread::Detach(m_IL2CPPThread);
			return 0x0;
		}

		CThread() { /* Why would you even do this? */ }
		CThread(void* m_OnStartFunc, void* m_OnEndFunc)
		{
			m_OnStart	= m_OnStartFunc;
			m_OnEnd		= m_OnEndFunc;

			if (!m_OnStart)
			{
				IL2CPP_ASSERT("IL2CPP::CThread - m_OnStart is nullptr");
				return;
			}

			HANDLE m_Thread = CreateThread(0, 0, Handler, this, 0, 0);
			if (m_Thread)
				CloseHandle(m_Thread);
		}
	};

	namespace Thread
	{
		void Create(void* m_OnStartFunc, void* m_OnEndFunc = nullptr)
		{
			CThread* m_Thread = new CThread(m_OnStartFunc, m_OnEndFunc);
			IL2CPP_ASSERT(m_Thread && "IL2CPP::Thread::Create - Failed!");
		}
	}
}
```

`Data.hpp`:

```hpp
#pragma once

namespace IL2CPP
{
	struct Globals_t
	{
		HMODULE m_GameAssembly = nullptr;
	};
	Globals_t Globals;

	struct Functions_t
	{
		void* m_ClassFromName = nullptr;
		void* m_ClassGetFields = nullptr;
		void* m_ClassGetFieldFromName = nullptr;
		void* m_ClassGetMethods = nullptr;
		void* m_ClassGetMethodFromName = nullptr;
		void* m_ClassGetPropertyFromName = nullptr;
		void* m_ClassGetType = nullptr;

		void* m_DomainGet = nullptr;
		void* m_DomainGetAssemblies = nullptr;

		void* m_Free = nullptr;

		void* m_ImageGetClass = nullptr;
		void* m_ImageGetClassCount = nullptr;

		void* m_ResolveFunction = nullptr;

		void* m_StringNew = nullptr;

		void* m_ThreadAttach = nullptr;
		void* m_ThreadDetach = nullptr;

		void* m_TypeGetObject = nullptr;

		void* m_pObjectNew = nullptr;
		void* m_MethodGetParamName = nullptr;
		void* m_MethodGetParam = nullptr;
		void* m_ClassFromIl2cppType = nullptr;

		void* m_FieldStaticGetValue = nullptr;
		void* m_FieldStaticSetValue = nullptr;
	};
	Functions_t Functions;
}

```

`Defines.hpp`:

```hpp
#pragma once

#define IL2CPP_INIT_EXPORT								IL2CPP_RStr("il2cpp_init")
#define IL2CPP_CLASS_FROM_NAME_EXPORT					IL2CPP_RStr("il2cpp_class_from_name")
#define IL2CPP_CLASS_GET_FIELDS							IL2CPP_RStr("il2cpp_class_get_fields")
#define IL2CPP_CLASS_GET_FIELD_FROM_NAME_EXPORT			IL2CPP_RStr("il2cpp_class_get_field_from_name")
#define IL2CPP_CLASS_GET_METHODS						IL2CPP_RStr("il2cpp_class_get_methods")
#define IL2CPP_CLASS_GET_METHOD_FROM_NAME_EXPORT		IL2CPP_RStr("il2cpp_class_get_method_from_name")
#define IL2CPP_CLASS_GET_PROPERTY_FROM_NAME_EXPORT		IL2CPP_RStr("il2cpp_class_get_property_from_name")
#define IL2CPP_CLASS_GET_TYPE_EXPORT					IL2CPP_RStr("il2cpp_class_get_type")
#define IL2CPP_DOMAIN_GET_EXPORT						IL2CPP_RStr("il2cpp_domain_get")
#define IL2CPP_DOMAIN_GET_ASSEMBLIES_EXPORT				IL2CPP_RStr("il2cpp_domain_get_assemblies")
#define IL2CPP_FREE_EXPORT								IL2CPP_RStr("il2cpp_free")
#define IL2CPP_IMAGE_GET_CLASS_EXPORT					IL2CPP_RStr("il2cpp_image_get_class")
#define IL2CPP_IMAGE_GET_CLASS_COUNT_EXPORT				IL2CPP_RStr("il2cpp_image_get_class_count")
#define IL2CPP_RESOLVE_FUNC_EXPORT						IL2CPP_RStr("il2cpp_resolve_icall")
#define IL2CPP_STRING_NEW_EXPORT						IL2CPP_RStr("il2cpp_string_new")
#define IL2CPP_THREAD_ATTACH_EXPORT						IL2CPP_RStr("il2cpp_thread_attach")
#define IL2CPP_THREAD_DETACH_EXPORT						IL2CPP_RStr("il2cpp_thread_detach")
#define IL2CPP_TYPE_GET_OBJECT_EXPORT					IL2CPP_RStr("il2cpp_type_get_object")
#define IL2CPP_OBJECT_NEW								IL2CPP_RStr("il2cpp_object_new")
#define IL2CPP_METHOD_GET_PARAM_NAME					IL2CPP_RStr("il2cpp_method_get_param_name")
#define IL2CPP_METHOD_GET_PARAM							IL2CPP_RStr("il2cpp_method_get_param")
#define IL2CPP_CLASS_FROM_IL2CPP_TYPE					IL2CPP_RStr("il2cpp_class_from_il2cpp_type")
#define IL2CPP_FIELD_STATIC_GET_VALUE					IL2CPP_RStr("il2cpp_field_static_get_value")
#define IL2CPP_FIELD_STATIC_SET_VALUE					IL2CPP_RStr("il2cpp_field_static_set_value")

// Calling Convention
#ifdef _WIN64
	#define IL2CPP_CALLING_CONVENTION __fastcall*
#elif _WIN32
	#define IL2CPP_CALLING_CONVENTION __cdecl*
#endif

```

`IL2CPP_Resolver.hpp`:

```hpp
#pragma once

// Default Headers
#include <cstdint>
#include <iostream>
#define _USE_MATH_DEFINES
#include <math.h>
#include <vector>
#include <unordered_map>
#include <Windows.h>

// Application Defines
#ifndef UNITY_VERSION_2022_3_8F1
	// If Unity version is equal or greater than 2022.3.8f1 uncomment this define.
	// #define UNITY_VERSION_2022_3_8F1
#endif

// IL2CPP Defines

// Disable Asserts
//#define IL2CPP_ASSERT(x) assert(0)
#ifndef IL2CPP_ASSERT
	#include <cassert>
	#define IL2CPP_ASSERT(x) assert(x)
#endif

#ifndef IL2CPP_RStr 
	// If you wanna forward to some string encryption just define before including this file.
	#define IL2CPP_RStr(x) x
#endif

#ifndef IL2CPP_MAIN_MODULE
	// If the game for some reason uses diff module name just define own one before including this file.
	#define IL2CPP_MAIN_MODULE IL2CPP_RStr("GameAssembly.dll")
#endif

#include "Defines.hpp"

// IL2CPP Headers
#include "Data.hpp"

// Unity Headers
#include "Unity/Obfuscators.hpp"
#include "Unity/Defines.hpp"
#include "Unity/Structures/il2cpp.hpp"
#include "Unity/Structures/il2cppArray.hpp"
#include "Unity/Structures/il2cppDictionary.hpp"
#include "Unity/Structures/Engine.hpp"
#include "Unity/Structures/System_String.hpp"

// IL2CPP Utils
#include "Utils/Hash.hpp"
#include "Utils/VTable.hpp"

// IL2CPP API Headers
#include "API/Domain.hpp"
#include "API/Class.hpp"
#include "API/ResolveCall.hpp"
#include "API/String.hpp"
#include "API/Thread.hpp"

// IL2CPP Headers before Unity API
#include "SystemTypeCache.hpp"

// Unity Class APIs - So they're accessible everywhere
namespace Unity
{
	class CCamera;
	class CComponent;
	class CGameObject;
	class CLayerMask;
	class CObject;
	class CRigidbody;
	class CTransform;
}

// Unity API
#include "Unity/API/Object.hpp"
#include "Unity/API/GameObject.hpp"
#include "Unity/API/Camera.hpp"
#include "Unity/API/Component.hpp"
#include "Unity/API/LayerMask.hpp"
#include "Unity/API/Rigidbody.hpp"
#include "Unity/API/Transform.hpp"

// IL2CPP Headers after Unity API
#include "Utils/Helper.hpp"
#include "API/Callback.hpp"

namespace IL2CPP
{
	namespace UnityAPI
	{
		enum m_eExportObfuscationType
		{
			None = 0,
			ROT = 1,
			MAX = 2,
		};
		m_eExportObfuscationType m_ExportObfuscation = m_eExportObfuscationType::None;

		int m_ROTObfuscationValue = -1;
		void* ResolveExport(const char* m_Name)
		{
			switch (m_ExportObfuscation)
			{
				case m_eExportObfuscationType::ROT:
				{
					if (m_ROTObfuscationValue == -1) // Bruteforce
					{
						for (int i = 1; 26 > i; ++i)
						{
							void* m_Return = GetProcAddress(Globals.m_GameAssembly, &Unity::Obfuscators::ROT_String(m_Name, i)[0]);
							if (m_Return)
							{
								m_ROTObfuscationValue = i;
								return m_Return;
							}
						}

						return nullptr;
					}

					return GetProcAddress(Globals.m_GameAssembly, &Unity::Obfuscators::ROT_String(m_Name, m_ROTObfuscationValue)[0]);
				}
				default: return GetProcAddress(Globals.m_GameAssembly, m_Name);
			}

			return nullptr;
		}

		bool ResolveExport_Boolean(void** m_Address, const char* m_Name)
		{
			*m_Address = ResolveExport(m_Name);
			IL2CPP_ASSERT(*m_Address != nullptr && "Couldn't resolve export!");
			return (*m_Address);
		}

		bool Initialize()
		{
			bool m_InitExportResolved = false;
			for (int i = 0; m_eExportObfuscationType::MAX > i; ++i)
			{
				m_ExportObfuscation = static_cast<m_eExportObfuscationType>(i);
				if (ResolveExport(IL2CPP_INIT_EXPORT))
				{
					m_InitExportResolved = true;
					break;
				}
			}

			IL2CPP_ASSERT(m_InitExportResolved && "Couldn't resolve il2cpp_init!");
			if (!m_InitExportResolved) 
				return false;

			std::unordered_map<std::string, void**> m_ExportMap =
			{
				{ IL2CPP_CLASS_FROM_NAME_EXPORT,					&Functions.m_ClassFromName },
				{ IL2CPP_CLASS_GET_FIELDS,							&Functions.m_ClassGetFields },
				{ IL2CPP_CLASS_GET_FIELD_FROM_NAME_EXPORT,			&Functions.m_ClassGetFieldFromName },
				{ IL2CPP_CLASS_GET_METHODS,							&Functions.m_ClassGetMethods },
				{ IL2CPP_CLASS_GET_METHOD_FROM_NAME_EXPORT,			&Functions.m_ClassGetMethodFromName },
				{ IL2CPP_CLASS_GET_PROPERTY_FROM_NAME_EXPORT,		&Functions.m_ClassGetPropertyFromName },
				{ IL2CPP_CLASS_GET_TYPE_EXPORT,						&Functions.m_ClassGetType },
				{ IL2CPP_DOMAIN_GET_EXPORT,							&Functions.m_DomainGet },
				{ IL2CPP_DOMAIN_GET_ASSEMBLIES_EXPORT,				&Functions.m_DomainGetAssemblies },
				{ IL2CPP_FREE_EXPORT,								&Functions.m_Free },
				{ IL2CPP_IMAGE_GET_CLASS_EXPORT,					&Functions.m_ImageGetClass },
				{ IL2CPP_IMAGE_GET_CLASS_COUNT_EXPORT,				&Functions.m_ImageGetClassCount },
				{ IL2CPP_RESOLVE_FUNC_EXPORT,						&Functions.m_ResolveFunction },
				{ IL2CPP_STRING_NEW_EXPORT,							&Functions.m_StringNew },
				{ IL2CPP_THREAD_ATTACH_EXPORT,						&Functions.m_ThreadAttach },
				{ IL2CPP_THREAD_DETACH_EXPORT,						&Functions.m_ThreadDetach },
				{ IL2CPP_TYPE_GET_OBJECT_EXPORT,					&Functions.m_TypeGetObject },
				{ IL2CPP_OBJECT_NEW,								&Functions.m_pObjectNew },
				{ IL2CPP_METHOD_GET_PARAM_NAME,						&Functions.m_MethodGetParamName },
				{ IL2CPP_METHOD_GET_PARAM,							&Functions.m_MethodGetParam },
				{ IL2CPP_CLASS_FROM_IL2CPP_TYPE,					&Functions.m_ClassFromIl2cppType },
				{ IL2CPP_FIELD_STATIC_GET_VALUE,					&Functions.m_FieldStaticGetValue },
				{ IL2CPP_FIELD_STATIC_SET_VALUE,					&Functions.m_FieldStaticSetValue },
			};

			for (auto& m_ExportPair : m_ExportMap)
			{
				if (!ResolveExport_Boolean(m_ExportPair.second, &m_ExportPair.first[0]))
					return false;
			}

			// Unity APIs
			Unity::Camera::Initialize();
			Unity::Component::Initialize();
			Unity::GameObject::Initialize();
			Unity::LayerMask::Initialize();
			Unity::Object::Initialize();
			Unity::RigidBody::Initialize();
			Unity::Transform::Initialize();

			// Caches
			IL2CPP::SystemTypeCache::Initializer::PreCache();

			return true;
		}
	}

	/* 
	*	You need to call this, before using any IL2CPP/Unity Functions!
	*	Args:
	*		m_WaitForModule - Will wait for main module if you're loading your dll earlier than the main module.
	*		m_MaxSecondsWait - Max seconds it will wait for main module to load otherwise will return false to prevent infinite loop.
	*/
	bool Initialize(bool m_WaitForModule = false, int m_MaxSecondsWait = 60)
	{
		Globals.m_GameAssembly = GetModuleHandleA(IL2CPP_MAIN_MODULE);

		if (m_WaitForModule)
		{
			int m_SecondsWaited = 0;
			while (!Globals.m_GameAssembly)
			{
				if (m_SecondsWaited >= m_MaxSecondsWait)
					return false;

				Globals.m_GameAssembly = GetModuleHandleA(IL2CPP_MAIN_MODULE);
				++m_SecondsWaited;
				Sleep(1000);
			}
		}

		if (!UnityAPI::Initialize())
			return false;

		return true;
	}
}

```

`LICENSE`:

```
This is free and unencumbered software released into the public domain.

Anyone is free to copy, modify, publish, use, compile, sell, or
distribute this software, either in source code form or as a compiled
binary, for any purpose, commercial or non-commercial, and by any
means.

In jurisdictions that recognize copyright laws, the author or authors
of this software dedicate any and all copyright interest in the
software to the public domain. We make this dedication for the benefit
of the public at large and to the detriment of our heirs and
successors. We intend this dedication to be an overt act of
relinquishment in perpetuity of all present and future rights to this
software under copyright law.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

For more information, please refer to <https://unlicense.org>

```

`README.md`:

```md
## IL2CPP Resolver
A run-time API resolver for IL2CPP Unity.

[External Version(Rework WIP)](https://github.com/extremeblackliu/IL2CPP_Resolver_External) | [(Old) Pre-HeaderOnly Version](https://github.com/sneakyevil/IL2CPP_Resolver/tree/old_nonheader)

### Quick Example
```cpp
#include <IL2CPP_Resolver.hpp>

void SomeFunction()
{
    IL2CPP::Initialize(); // This needs to be called once!

    Unity::CGameObject* m_Local = Unity::GameObject::Find("LocalPlayer");
    Unity::CComponent* m_LocalData = m_Local->GetComponent("PlayerData");
    m_LocalData->SetMemberValue<bool>("CanFly", true);
}
```

### Registering OnUpdate Callback
```cpp
void OurUpdateFunction()
{
    // Your special code...
}

void OnLoad()
{
    IL2CPP::Initialize();

    IL2CPP::Callback::Initialize();
    IL2CPP::Callback::OnUpdate::Add(OurUpdateFunction);
}
```

More: https://sneakyevil.gitbook.io/il2cpp-resolver/

```

`SystemTypeCache.hpp`:

```hpp
#pragma once

namespace IL2CPP
{
	namespace SystemTypeCache
	{
		std::unordered_map<uint32_t, Unity::il2cppObject*> m_Map;

		void Add(uint32_t m_Hash, Unity::il2cppObject* m_SystemType)
		{
			m_Map[m_Hash] = m_SystemType;
		}

		void Add(const char* m_Name, Unity::il2cppObject* m_SystemType)
		{
			Add(Utils::Hash::Get(m_Name), m_SystemType);
		}

		Unity::il2cppObject* Get(uint32_t m_Hash)
		{
			return m_Map[m_Hash];
		}

		Unity::il2cppObject* Get(const char* m_Name)
		{
			return Get(Utils::Hash::Get(m_Name));
		}

		// Legacy Naming
		Unity::il2cppObject* Find(uint32_t m_Hash)
		{
			return Get(m_Hash);
		}

		Unity::il2cppObject* Find(const char* m_Name)
		{
			return Get(m_Name);
		}

		namespace Initializer
		{
			std::vector<const char*> m_List;

			void Add(const char* m_Name) 
			{ 
				m_List.emplace_back(m_Name);
			}

			void PreCache()
			{
				for (const char* m_Name : m_List)
					SystemTypeCache::Add(m_Name, IL2CPP::Class::GetSystemType(m_Name));

				m_List.clear();
			}
		}
	}
}
```

`Unity/API/Camera.hpp`:

```hpp
#pragma once

namespace Unity
{
	struct CameraFunctions_t
	{
		void* m_GetCurrent = nullptr;
		void* m_GetMain = nullptr;
		void* m_GetDepth = nullptr;
		void* m_SetDepth = nullptr;
		void* m_GetFieldOfView = nullptr;
		void* m_SetFieldOfView = nullptr;
		void* m_WorldToScreen = nullptr;
	};
	CameraFunctions_t m_CameraFunctions;

	class CCamera : public CGameObject
	{
	public:
		float GetDepth()
		{
			return reinterpret_cast<float(UNITY_CALLING_CONVENTION)(void*)>(m_CameraFunctions.m_GetDepth)(this);
		}

		void SetDepth(float m_fValue)
		{
			reinterpret_cast<void(UNITY_CALLING_CONVENTION)(void*, float)>(m_CameraFunctions.m_SetDepth)(this, m_fValue);
		}

		float GetFieldOfView()
		{
			return reinterpret_cast<float(UNITY_CALLING_CONVENTION)(void*)>(m_CameraFunctions.m_GetFieldOfView)(this);
		}

		void SetFieldOfView(float m_fValue)
		{
			reinterpret_cast<void(UNITY_CALLING_CONVENTION)(void*, float)>(m_CameraFunctions.m_SetFieldOfView)(this, m_fValue);
		}

		void WorldToScreen(Vector3& m_vWorld, Vector3& m_vScreen, int m_iEye = 2)
		{
			reinterpret_cast<void(UNITY_CALLING_CONVENTION)(void*, Vector3&, int, Vector3&)>(m_CameraFunctions.m_WorldToScreen)(this, m_vWorld, m_iEye, m_vScreen);
		}
	};

	namespace Camera
	{
		void Initialize()
		{
			IL2CPP::SystemTypeCache::Initializer::Add(UNITY_CAMERA_CLASS);

			m_CameraFunctions.m_GetCurrent		= IL2CPP::ResolveCall(UNITY_CAMERA_GETCURRENT);
			m_CameraFunctions.m_GetMain			= IL2CPP::ResolveCall(UNITY_CAMERA_GETMAIN);
			m_CameraFunctions.m_GetDepth		= IL2CPP::ResolveCall(UNITY_CAMERA_GETDEPTH);
			m_CameraFunctions.m_SetDepth		= IL2CPP::ResolveCall(UNITY_CAMERA_SETDEPTH);
			m_CameraFunctions.m_GetFieldOfView	= IL2CPP::ResolveCall(UNITY_CAMERA_GETFIELDOFVIEW);
			m_CameraFunctions.m_SetFieldOfView	= IL2CPP::ResolveCall(UNITY_CAMERA_SETFIELDOFVIEW);
			m_CameraFunctions.m_WorldToScreen	= IL2CPP::ResolveCall(UNITY_CAMERA_WORLDTOSCREEN);
		}

		CCamera* GetCurrent()
		{
			return reinterpret_cast<CCamera*(UNITY_CALLING_CONVENTION)()>(m_CameraFunctions.m_GetCurrent)();
		}

		CCamera* GetMain()
		{
			return reinterpret_cast<CCamera*(UNITY_CALLING_CONVENTION)()>(m_CameraFunctions.m_GetMain)();
		}
	}

	enum m_eCameraType : int
	{
		m_eCameraType_Game = 1,
		m_eCameraType_SceneView = 2,
		m_eCameraType_Preview = 4,
		m_eCameraType_VR = 8,
		m_eCameraType_Reflection = 16,
	};

	enum m_eCameraEye : int
	{
		m_eCameraEye_Left = 0,
		m_eCameraEye_Right = 1,
		m_eCameraEye_Center = 2,
	};
}
```

`Unity/API/Component.hpp`:

```hpp
#pragma once

namespace Unity
{
	struct ComponentFunctions_t
	{
		void* m_GetGameObject = nullptr;
		void* m_GetTransform = nullptr;
	};
	ComponentFunctions_t m_ComponentFunctions;

	class CComponent : public CObject
	{
	public:
		CGameObject* GetGameObject()
		{
			return reinterpret_cast<CGameObject*(UNITY_CALLING_CONVENTION)(void*)>(m_ComponentFunctions.m_GetGameObject)(this);
		}

		CTransform* GetTransform()
		{
			return reinterpret_cast<CTransform*(UNITY_CALLING_CONVENTION)(void*)>(m_ComponentFunctions.m_GetTransform)(this);
		}
	};

	namespace Component
	{
		void Initialize()
		{
			IL2CPP::SystemTypeCache::Initializer::Add(UNITY_COMPONENT_CLASS);

			m_ComponentFunctions.m_GetGameObject	= IL2CPP::ResolveCall(UNITY_COMPONENT_GETGAMEOBJECT);
			m_ComponentFunctions.m_GetTransform		= IL2CPP::ResolveCall(UNITY_COMPONENT_GETTRANSFORM);
		}
	}
}
```

`Unity/API/GameObject.hpp`:

```hpp
#pragma once

namespace Unity
{
	struct GameObjectFunctions_t
	{
		void* m_AddComponent = nullptr;
		void* m_CreatePrimitive = nullptr;
		void* m_Find = nullptr;
		void* m_FindGameObjectsWithTag = nullptr;
		void* m_GetComponent = nullptr;
		void* m_GetComponents = nullptr;
		void* m_GetComponentInChildren = nullptr;
		void* m_GetActive = nullptr;
		void* m_GetLayer = nullptr;
		void* m_GetTransform = nullptr;
		void* m_SetActive = nullptr;
		void* m_SetLayer = nullptr;
	};
	GameObjectFunctions_t m_GameObjectFunctions;

	class CGameObject : public CObject
	{
	public:
		void AddComponent(il2cppObject* m_pSystemType)
		{
			reinterpret_cast<void(UNITY_CALLING_CONVENTION)(void*, void*)>(m_GameObjectFunctions.m_AddComponent)(this, m_pSystemType);
		}

		CComponent* GetComponent(const char* m_pName)
		{
			return reinterpret_cast<CComponent*(UNITY_CALLING_CONVENTION)(void*, System_String*)>(m_GameObjectFunctions.m_GetComponent)(this, IL2CPP::String::New(m_pName));
		}

		CComponent* GetComponentInChildren(il2cppObject* m_pSystemType, bool includeInactive)
		{
			return reinterpret_cast<CComponent*(UNITY_CALLING_CONVENTION)(void*, void*, bool)>(m_GameObjectFunctions.m_GetComponentInChildren)(this, m_pSystemType, includeInactive);
		}

		// e.g CGameObject->GetComponentInChildren("Namespace.Component");
		CComponent* GetComponentInChildren(const char* type)
		{
			il2cppClass* m_pClass = IL2CPP::Class::Find(type);
			if (!m_pClass) return nullptr;

			return GetComponentInChildren(IL2CPP::Class::GetSystemType(m_pClass), true);
		}

		il2cppArray<CComponent*>* GetComponents(il2cppObject* m_pSystemType)
		{
			/* 
			0 - Object
			1 - Type
			2 - Use search type as array return type
			3 - Recursive
			4 - Include inactive
			5 - Reverse
			6 - Result list
			*/
			return reinterpret_cast<Unity::il2cppArray<CComponent*>*(UNITY_CALLING_CONVENTION)(void*, void*, bool, bool, bool, bool, void*)>(m_GameObjectFunctions.m_GetComponents)(this, m_pSystemType, false, false, true, false, nullptr);
		}

		il2cppArray<CComponent*>* GetComponents(const char* m_pSystemTypeName)
		{
			il2cppClass* m_pClass = IL2CPP::Class::Find(m_pSystemTypeName);
			if (!m_pClass) return nullptr;

			return GetComponents(IL2CPP::Class::GetSystemType(m_pClass));
		}

		CComponent* GetComponentByIndex(il2cppObject* m_pSystemType, unsigned int m_uIndex = 0U)
		{
			il2cppArray<CComponent*>* m_pComponents = GetComponents(m_pSystemType);
			if (!m_pComponents || m_uIndex >= m_pComponents->m_uMaxLength) return nullptr;

			return m_pComponents->operator[](m_uIndex);
		}

		CComponent* GetComponentByIndex(const char* m_pSystemTypeName, unsigned int m_uIndex = 0U)
		{
			il2cppClass* m_pClass = IL2CPP::Class::Find(m_pSystemTypeName);
			if (!m_pClass) return nullptr;

			return GetComponentByIndex(IL2CPP::Class::GetSystemType(m_pClass), m_uIndex);
		}

		CTransform* GetTransform()
		{
			return reinterpret_cast<CTransform*(UNITY_CALLING_CONVENTION)(void*)>(m_GameObjectFunctions.m_GetTransform)(this);
		}

		bool GetActive()
		{
			return reinterpret_cast<bool(UNITY_CALLING_CONVENTION)(void*)>(m_GameObjectFunctions.m_GetActive)(this);
		}

		unsigned int GetLayer()
		{
			return reinterpret_cast<unsigned int(UNITY_CALLING_CONVENTION)(void*)>(m_GameObjectFunctions.m_GetLayer)(this);
		}

		/*
		* (WARNING) when you use GameObject::Find and you set the object to unactive, you won't find it anymore with that slow function.
		*/
		void SetActive(bool m_bActive)
		{
			reinterpret_cast<void(UNITY_CALLING_CONVENTION)(void*, bool)>(m_GameObjectFunctions.m_SetActive)(this, m_bActive);
		}

		void SetLayer(unsigned int m_uLayer)
		{
			reinterpret_cast<void(UNITY_CALLING_CONVENTION)(void*, unsigned int)>(m_GameObjectFunctions.m_SetLayer)(this, m_uLayer);
		}
	};

	namespace GameObject
	{
		enum class m_ePrimitiveType : int
		{
			Default = 0,
			Sphere = 0,
			Capsule,
			Cylinder,
			Cube,
			Plane,
			Quad,
		};

		void Initialize()
		{
			IL2CPP::SystemTypeCache::Initializer::Add(UNITY_GAMEOBJECT_CLASS);

			m_GameObjectFunctions.m_AddComponent			= IL2CPP::ResolveCall(UNITY_GAMEOBJECT_ADDCOMPONENT);
			m_GameObjectFunctions.m_CreatePrimitive			= IL2CPP::ResolveCall(UNITY_GAMEOBJECT_CREATEPRIMITIVE);
			m_GameObjectFunctions.m_Find					= IL2CPP::ResolveCall(UNITY_GAMEOBJECT_FIND);
			m_GameObjectFunctions.m_FindGameObjectsWithTag	= IL2CPP::ResolveCall(UNITY_GAMEOBJECT_FINDGAMEOBJECTWITHTAG);
			m_GameObjectFunctions.m_GetComponent			= IL2CPP::ResolveCall(UNITY_GAMEOBJECT_GETCOMPONENT);
			m_GameObjectFunctions.m_GetComponents			= IL2CPP::ResolveCall(UNITY_GAMEOBJECT_GETCOMPONENTS);
			m_GameObjectFunctions.m_GetComponentInChildren	= IL2CPP::ResolveCall(UNITY_GAMEOBJECT_GETCOMPONENTINCHILDREN);
			m_GameObjectFunctions.m_GetActive				= IL2CPP::ResolveCall(UNITY_GAMEOBJECT_GETACTIVE);
			m_GameObjectFunctions.m_GetLayer				= IL2CPP::ResolveCall(UNITY_GAMEOBJECT_GETLAYER);
			m_GameObjectFunctions.m_GetTransform			= IL2CPP::ResolveCall(UNITY_GAMEOBJECT_GETTRANSFORM);
			m_GameObjectFunctions.m_SetActive				= IL2CPP::ResolveCall(UNITY_GAMEOBJECT_SETACTIVE);
			m_GameObjectFunctions.m_SetLayer				= IL2CPP::ResolveCall(UNITY_GAMEOBJECT_SETLAYER);
		}

		CGameObject* CreatePrimitive(m_ePrimitiveType m_Type)
		{
			return reinterpret_cast<CGameObject*(UNITY_CALLING_CONVENTION)(m_ePrimitiveType)>(m_GameObjectFunctions.m_CreatePrimitive)(m_Type);
		}

		CGameObject* Find(const char* m_Name)
		{
			return reinterpret_cast<CGameObject*(UNITY_CALLING_CONVENTION)(System_String*)>(m_GameObjectFunctions.m_Find)(IL2CPP::String::New(m_Name));
		}

		il2cppArray<CGameObject*>* FindWithTag(const char* m_Tag)
		{
			return reinterpret_cast<il2cppArray<CGameObject*>*(UNITY_CALLING_CONVENTION)(void*)>(m_GameObjectFunctions.m_FindGameObjectsWithTag)(IL2CPP::String::New(m_Tag));
		}
	}
}

```

`Unity/API/LayerMask.hpp`:

```hpp
#pragma once

namespace Unity
{
	struct LayerMaskFunctions_t
	{
		void* m_LayerToName = nullptr;
		void* m_NameToLayer = nullptr;
	};
	LayerMaskFunctions_t m_LayerMaskFunctions;

	namespace LayerMask
	{
		void Initialize()
		{
			IL2CPP::SystemTypeCache::Initializer::Add(UNITY_LAYERMASK_CLASS);

			m_LayerMaskFunctions.m_LayerToName = IL2CPP::ResolveCall(UNITY_LAYERMASK_LAYERTONAME);
			m_LayerMaskFunctions.m_NameToLayer = IL2CPP::ResolveCall(UNITY_LAYERMASK_NAMETOLAYER);
		}

		System_String* LayerToName(unsigned int m_uLayer)
		{
			return reinterpret_cast<System_String*(UNITY_CALLING_CONVENTION)(unsigned int)>(m_LayerMaskFunctions.m_LayerToName)(m_uLayer);
		}

		uint32_t NameToLayer(const char* m_pName)
		{
			return reinterpret_cast<uint32_t(UNITY_CALLING_CONVENTION)(void*)>(m_LayerMaskFunctions.m_NameToLayer)(IL2CPP::String::New(m_pName));
		}
	}
}
```

`Unity/API/Object.hpp`:

```hpp
#pragma once

namespace Unity
{
	struct ObjectFunctions_t
	{
		void* m_Destroy = nullptr;
		void* m_FindObjectsOfType = nullptr;
		void* m_GetName = nullptr;
	};
	ObjectFunctions_t m_ObjectFunctions;

	class CObject : public IL2CPP::CClass
	{
	public:
		void Destroy(float fTimeDelay = 0.f)
		{
			reinterpret_cast<void(UNITY_CALLING_CONVENTION)(void*, float)>(m_ObjectFunctions.m_Destroy)(this, fTimeDelay);
		}

		System_String* GetName()
		{
			return reinterpret_cast<System_String*(UNITY_CALLING_CONVENTION)(void*)>(m_ObjectFunctions.m_GetName)(this);
		}
	};

	namespace Object
	{
		void Initialize()
		{
			IL2CPP::SystemTypeCache::Initializer::Add(UNITY_OBJECT_CLASS);

			m_ObjectFunctions.m_Destroy				= IL2CPP::ResolveCall(UNITY_OBJECT_DESTROY);
			m_ObjectFunctions.m_FindObjectsOfType	= IL2CPP::ResolveCall(UNITY_OBJECT_FINDOBJECTSOFTYPE);
			m_ObjectFunctions.m_GetName				= IL2CPP::ResolveCall(UNITY_OBJECT_GETNAME);
		}

		static il2cppObject* New(il2cppClass* m_pClass)
		{
			return reinterpret_cast<Unity::il2cppObject*(UNITY_CALLING_CONVENTION)(void*)>(IL2CPP::Functions.m_pObjectNew)(m_pClass);
		}
	
		template<typename T>
		static il2cppArray<T*>* FindObjectsOfType(il2cppObject* m_pSystemType, bool m_bIncludeInactive = false)
		{
			return reinterpret_cast<Unity::il2cppArray<T*>*(UNITY_CALLING_CONVENTION)(void*, bool)>(m_ObjectFunctions.m_FindObjectsOfType)(m_pSystemType, m_bIncludeInactive);
		}

		template<typename T>
		static il2cppArray<T*>* FindObjectsOfType(const char* m_pSystemTypeName, bool m_bIncludeInactive = false)
		{
			il2cppClass* m_pClass = IL2CPP::Class::Find(m_pSystemTypeName);
			if (!m_pClass) return nullptr;

			return FindObjectsOfType<T>(IL2CPP::Class::GetSystemType(m_pClass), m_bIncludeInactive);
		}

		template<typename T>
		static T* FindObjectOfType(il2cppObject* m_pSystemType, bool m_bIncludeInactive = false)
		{
			il2cppArray<T*>* m_pArray = FindObjectsOfType<T>(m_pSystemType, m_bIncludeInactive);
			if (!m_pArray || m_pArray->m_uMaxLength == 0U) return nullptr;

			return m_pArray->m_pValues[0];
		}

		template<typename T>
		static T* FindObjectOfType(const char* m_pSystemTypeName, bool m_bIncludeInactive = false)
		{
			il2cppClass* m_pClass = IL2CPP::Class::Find(m_pSystemTypeName);
			if (!m_pClass) return nullptr;

			return FindObjectOfType<T>(IL2CPP::Class::GetSystemType(m_pClass), m_bIncludeInactive);
		}
	}
} 

```

`Unity/API/Rigidbody.hpp`:

```hpp
#pragma once

namespace Unity
{
	struct RigidbodyFunctions_t
	{
		void* m_GetDetectCollisions = nullptr;
		void* m_GetVelocity = nullptr;
		void* m_SetDetectCollisions = nullptr;
		void* m_SetVelocity = nullptr;
	};
	RigidbodyFunctions_t m_RigidbodyFunctions;

	class CRigidbody : public IL2CPP::CClass
	{
	public:
		bool GetDetectCollisions()
		{
			return reinterpret_cast<bool(UNITY_CALLING_CONVENTION)(void*)>(m_RigidbodyFunctions.m_GetDetectCollisions)(this);
		}

		void SetDetectCollisions(bool m_bDetect)
		{
			reinterpret_cast<void(UNITY_CALLING_CONVENTION)(void*, bool)>(m_RigidbodyFunctions.m_SetDetectCollisions)(this, m_bDetect);
		}

		Vector3 GetVelocity()
		{
			Vector3 vRet;
			reinterpret_cast<void(UNITY_CALLING_CONVENTION)(void*, Vector3&)>(m_RigidbodyFunctions.m_GetVelocity)(this, vRet);
			return vRet;
		}

		void SetVelocity(Vector3 m_vVector)
		{
			reinterpret_cast<void(UNITY_CALLING_CONVENTION)(void*, Vector3)>(m_RigidbodyFunctions.m_SetVelocity)(this, m_vVector);
		}
	};

	namespace RigidBody
	{
		void Initialize()
		{
			IL2CPP::SystemTypeCache::Initializer::Add(UNITY_RIGIDBODY_CLASS);

			m_RigidbodyFunctions.m_GetDetectCollisions	= IL2CPP::ResolveCall(UNITY_RIGIDBODY_GETDETECTCOLLISIONS);
			m_RigidbodyFunctions.m_GetVelocity			= IL2CPP::ResolveCall(UNITY_RIGIDBODY_GETVELOCITY);
			m_RigidbodyFunctions.m_SetDetectCollisions	= IL2CPP::ResolveCall(UNITY_RIGIDBODY_SETDETECTCOLLISIONS);
			m_RigidbodyFunctions.m_SetVelocity			= IL2CPP::ResolveCall(UNITY_RIGIDBODY_SETVELOCITY);

		}
	}
}
```

`Unity/API/Transform.hpp`:

```hpp
#pragma once

namespace Unity
{
	struct TransformFunctions_t
	{
		void* m_GetParent = nullptr;
		void* m_GetRoot = nullptr;
		void* m_GetChild = nullptr;
		void* m_GetChildCount = nullptr;
		void* m_FindChild = nullptr;
		void* m_GetPosition = nullptr;
		void* m_GetRotation = nullptr;
		void* m_GetLocalPosition = nullptr;
		void* m_GetLocalScale = nullptr;
		void* m_SetPosition = nullptr;
		void* m_SetRotation = nullptr;
		void* m_SetLocalPosition = nullptr;
		void* m_SetLocalScale = nullptr;
	};
	TransformFunctions_t m_TransformFunctions;

	class CTransform : public IL2CPP::CClass
	{
	public:
		CTransform* GetParent()
		{
			return reinterpret_cast<CTransform*(UNITY_CALLING_CONVENTION)(void*)>(m_TransformFunctions.m_GetParent)(this);
		}

		CTransform* GetRoot()
		{
			return reinterpret_cast<CTransform*(UNITY_CALLING_CONVENTION)(void*)>(m_TransformFunctions.m_GetRoot)(this);
		}

		CTransform* GetChild(int m_iIndex)
		{
			return reinterpret_cast<CTransform*(UNITY_CALLING_CONVENTION)(void*, int)>(m_TransformFunctions.m_GetChild)(this, m_iIndex);
		}

		int GetChildCount()
		{
			return reinterpret_cast<int(UNITY_CALLING_CONVENTION)(void*)>(m_TransformFunctions.m_GetChildCount)(this);
		}

		CTransform* FindChild(const char* path, bool isActiveOnly)
		{
			return reinterpret_cast<CTransform * (UNITY_CALLING_CONVENTION)(void*, System_String*, bool)>(m_TransformFunctions.m_FindChild)(this, IL2CPP::String::New(path), isActiveOnly);
		}

		// e.g CGameObject->GetTransform()->FindChild("child1/child2/child3");
		CTransform* FindChild(const char* path)
		{
			if (path == NULL) {
				return nullptr;
			}
			return FindChild(path, false);
		}

		Vector3 GetPosition()
		{
			Vector3 vRet;
			reinterpret_cast<void(UNITY_CALLING_CONVENTION)(void*, Vector3&)>(m_TransformFunctions.m_GetPosition)(this, vRet);
			return vRet;
		}

		Quaternion GetRotation()
		{
			Quaternion m_qRet;
			reinterpret_cast<void(UNITY_CALLING_CONVENTION)(void*, Quaternion&)>(m_TransformFunctions.m_GetRotation)(this, m_qRet);
			return m_qRet;
		}

		Vector3 GetLocalPosition()
		{
			Vector3 vRet;
			reinterpret_cast<void(UNITY_CALLING_CONVENTION)(void*, Vector3&)>(m_TransformFunctions.m_GetLocalPosition)(this, vRet);
			return vRet;
		}

		Vector3 GetLocalScale()
		{
			Vector3 vRet;
			reinterpret_cast<void(UNITY_CALLING_CONVENTION)(void*, Vector3&)>(m_TransformFunctions.m_GetLocalScale)(this, vRet);
			return vRet;
		}

		void SetPosition(Vector3 m_vVector)
		{
			reinterpret_cast<void(UNITY_CALLING_CONVENTION)(void*, Vector3)>(m_TransformFunctions.m_SetPosition)(this, m_vVector);
		}

		void SetRotation(Quaternion m_qQuat)
		{
			reinterpret_cast<void(UNITY_CALLING_CONVENTION)(void*, Quaternion)>(m_TransformFunctions.m_SetRotation)(this, m_qQuat);
		}

		void SetLocalPosition(Vector3 m_vVector)
		{
			reinterpret_cast<void(UNITY_CALLING_CONVENTION)(void*, Vector3)>(m_TransformFunctions.m_SetLocalPosition)(this, m_vVector);
		}

		void SetLocalScale(Vector3 m_vVector)
		{
			reinterpret_cast<void(UNITY_CALLING_CONVENTION)(void*, Vector3)>(m_TransformFunctions.m_SetLocalScale)(this, m_vVector);
		}
	};

	namespace Transform
	{
		void Initialize()
		{
			IL2CPP::SystemTypeCache::Initializer::Add(UNITY_TRANSFORM_CLASS);

			m_TransformFunctions.m_GetParent		= IL2CPP::ResolveCall(UNITY_TRANSFORM_GETPARENT);
			m_TransformFunctions.m_GetRoot			= IL2CPP::ResolveCall(UNITY_TRANSFORM_GETROOT);
			m_TransformFunctions.m_GetChild			= IL2CPP::ResolveCall(UNITY_TRANSFORM_GETCHILD);
			m_TransformFunctions.m_GetChildCount	= IL2CPP::ResolveCall(UNITY_TRANSFORM_GETCHILDCOUNT);
			m_TransformFunctions.m_FindChild		= IL2CPP::ResolveCall(UNITY_TRANSFORM_FINDCHILD);
			m_TransformFunctions.m_GetPosition		= IL2CPP::ResolveCall(UNITY_TRANSFORM_GETPOSITION);
			m_TransformFunctions.m_GetRotation		= IL2CPP::ResolveCall(UNITY_TRANSFORM_GETROTATION);
			m_TransformFunctions.m_GetLocalPosition = IL2CPP::ResolveCall(UNITY_TRANSFORM_GETLOCALPOSITION);
			m_TransformFunctions.m_GetLocalScale	= IL2CPP::ResolveCall(UNITY_TRANSFORM_GETLOCALSCALE);
			m_TransformFunctions.m_SetPosition		= IL2CPP::ResolveCall(UNITY_TRANSFORM_SETPOSITION);
			m_TransformFunctions.m_SetRotation		= IL2CPP::ResolveCall(UNITY_TRANSFORM_SETROTATION);
			m_TransformFunctions.m_SetLocalPosition = IL2CPP::ResolveCall(UNITY_TRANSFORM_SETLOCALPOSITION);
			m_TransformFunctions.m_SetLocalScale	= IL2CPP::ResolveCall(UNITY_TRANSFORM_SETLOCALSCALE);
		}
	}
}
```

`Unity/Defines.hpp`:

```hpp
#pragma once
// Calling Convention
#ifdef _WIN64
    #define UNITY_CALLING_CONVENTION __fastcall*
#elif _WIN32
    #define UNITY_CALLING_CONVENTION __cdecl*
#endif

// Camera
#define UNITY_CAMERA_CLASS                                          "UnityEngine.Camera"
#define UNITY_CAMERA_GETCURRENT                                     IL2CPP_RStr(UNITY_CAMERA_CLASS"::get_current")
#define UNITY_CAMERA_GETMAIN                                        IL2CPP_RStr(UNITY_CAMERA_CLASS"::get_main")
#define UNITY_CAMERA_GETDEPTH                                       IL2CPP_RStr(UNITY_CAMERA_CLASS"::get_depth")
#define UNITY_CAMERA_SETDEPTH                                       IL2CPP_RStr(UNITY_CAMERA_CLASS"::set_depth")
#define UNITY_CAMERA_GETFIELDOFVIEW                                 IL2CPP_RStr(UNITY_CAMERA_CLASS"::get_fieldOfView")
#define UNITY_CAMERA_SETFIELDOFVIEW                                 IL2CPP_RStr(UNITY_CAMERA_CLASS"::set_fieldOfView")
#define UNITY_CAMERA_WORLDTOSCREEN                                  IL2CPP_RStr(UNITY_CAMERA_CLASS"::WorldToScreenPoint_Injected")

// Component
#define UNITY_COMPONENT_CLASS										"UnityEngine.Component"
#define UNITY_COMPONENT_GETGAMEOBJECT								IL2CPP_RStr(UNITY_COMPONENT_CLASS"::get_gameObject")
#define UNITY_COMPONENT_GETTRANSFORM								IL2CPP_RStr(UNITY_COMPONENT_CLASS"::get_transform")

// GameObject
#define UNITY_GAMEOBJECT_CLASS										"UnityEngine.GameObject"
#define UNITY_GAMEOBJECT_ADDCOMPONENT 								IL2CPP_RStr(UNITY_GAMEOBJECT_CLASS"::Internal_AddComponentWithType")
#define UNITY_GAMEOBJECT_CREATEPRIMITIVE 							IL2CPP_RStr(UNITY_GAMEOBJECT_CLASS"::CreatePrimitive")
#define UNITY_GAMEOBJECT_FIND 										IL2CPP_RStr(UNITY_GAMEOBJECT_CLASS"::Find")
#define UNITY_GAMEOBJECT_GETCOMPONENT 								IL2CPP_RStr(UNITY_GAMEOBJECT_CLASS"::GetComponentByName")
#define UNITY_GAMEOBJECT_GETCOMPONENTS								IL2CPP_RStr(UNITY_GAMEOBJECT_CLASS"::GetComponentsInternal")
#define UNITY_GAMEOBJECT_GETCOMPONENTINCHILDREN 					IL2CPP_RStr(UNITY_GAMEOBJECT_CLASS"::GetComponentInChildren")
#define UNITY_GAMEOBJECT_GETACTIVE 									IL2CPP_RStr(UNITY_GAMEOBJECT_CLASS"::get_active")
#define UNITY_GAMEOBJECT_GETLAYER 									IL2CPP_RStr(UNITY_GAMEOBJECT_CLASS"::get_layer")
#define UNITY_GAMEOBJECT_GETTRANSFORM 								IL2CPP_RStr(UNITY_GAMEOBJECT_CLASS"::get_transform")
#define UNITY_GAMEOBJECT_SETACTIVE 									IL2CPP_RStr(UNITY_GAMEOBJECT_CLASS"::set_active")
#define UNITY_GAMEOBJECT_SETLAYER 									IL2CPP_RStr(UNITY_GAMEOBJECT_CLASS"::set_layer")
#define UNITY_GAMEOBJECT_FINDGAMEOBJECTWITHTAG					    IL2CPP_RStr(UNITY_GAMEOBJECT_CLASS"::FindGameObjectsWithTag")

// LayerMask
#define UNITY_LAYERMASK_CLASS										"UnityEngine.LayerMask"
#define UNITY_LAYERMASK_LAYERTONAME									IL2CPP_RStr(UNITY_LAYERMASK_CLASS"::LayerToName")
#define UNITY_LAYERMASK_NAMETOLAYER									IL2CPP_RStr(UNITY_LAYERMASK_CLASS"::NameToLayer")

// MonoBehaviour
#define UNITY_MONOBEHAVIOUR_CLASS                                   "UnityEngine.MonoBehaviour"

// Object
#define UNITY_OBJECT_CLASS											"UnityEngine.Object"
#define UNITY_OBJECT_DESTROY										IL2CPP_RStr(UNITY_OBJECT_CLASS"::Destroy")
#define UNITY_OBJECT_FINDOBJECTSOFTYPE								IL2CPP_RStr(UNITY_OBJECT_CLASS"::FindObjectsOfType(System.Type,System.Boolean)")
#define UNITY_OBJECT_GETNAME										IL2CPP_RStr(UNITY_OBJECT_CLASS"::GetName")

// Rigidbody
#define UNITY_RIGIDBODY_CLASS										"UnityEngine.Rigidbody"
#define UNITY_RIGIDBODY_GETDETECTCOLLISIONS                         IL2CPP_RStr(UNITY_RIGIDBODY_CLASS"::get_detectCollisions")
#define UNITY_RIGIDBODY_GETVELOCITY                                 IL2CPP_RStr(UNITY_RIGIDBODY_CLASS"::get_velocity_Injected")
#define UNITY_RIGIDBODY_SETDETECTCOLLISIONS                         IL2CPP_RStr(UNITY_RIGIDBODY_CLASS"::set_detectCollisions")
#define UNITY_RIGIDBODY_SETVELOCITY                                 IL2CPP_RStr(UNITY_RIGIDBODY_CLASS"::set_velocity_Injected")

// Transform
#define UNITY_TRANSFORM_CLASS										"UnityEngine.Transform"
#define UNITY_TRANSFORM_GETPARENT                                   IL2CPP_RStr(UNITY_TRANSFORM_CLASS"::GetParent")
#define UNITY_TRANSFORM_GETROOT                                     IL2CPP_RStr(UNITY_TRANSFORM_CLASS"::GetRoot")
#define UNITY_TRANSFORM_GETCHILD                                    IL2CPP_RStr(UNITY_TRANSFORM_CLASS"::GetChild")
#define UNITY_TRANSFORM_GETCHILDCOUNT                               IL2CPP_RStr(UNITY_TRANSFORM_CLASS"::get_childCount")
#define UNITY_TRANSFORM_FINDCHILD                                   IL2CPP_RStr(UNITY_TRANSFORM_CLASS"::FindRelativeTransformWithPath")
#define UNITY_TRANSFORM_GETPOSITION									IL2CPP_RStr(UNITY_TRANSFORM_CLASS"::get_position_Injected")
#define UNITY_TRANSFORM_GETROTATION									IL2CPP_RStr(UNITY_TRANSFORM_CLASS"::get_rotation_Injected")
#define UNITY_TRANSFORM_GETLOCALPOSITION							IL2CPP_RStr(UNITY_TRANSFORM_CLASS"::get_localPosition_Injected")
#define UNITY_TRANSFORM_GETLOCALSCALE								IL2CPP_RStr(UNITY_TRANSFORM_CLASS"::get_localScale_Injected")
#define UNITY_TRANSFORM_SETPOSITION									IL2CPP_RStr(UNITY_TRANSFORM_CLASS"::set_position_Injected")
#define UNITY_TRANSFORM_SETROTATION									IL2CPP_RStr(UNITY_TRANSFORM_CLASS"::set_rotation_Injected")
#define UNITY_TRANSFORM_SETLOCALPOSITION							IL2CPP_RStr(UNITY_TRANSFORM_CLASS"::set_localPosition_Injected")
#define UNITY_TRANSFORM_SETLOCALSCALE								IL2CPP_RStr(UNITY_TRANSFORM_CLASS"::set_localScale_Injected")

namespace Unity
{
    enum m_eTypeEnum
    {
        Type_Void = 1,
        Type_Boolean = 2,
        Type_Character = 3,
        Type_Integer = 8,
        Type_Float = 12,
        Type_String = 14,
        Type_Pointer = 15,
        Type_ValueType = 17,
        Type_Class = 18,
        Type_Variable = 19,
        Type_Array = 20,
        Type_Enum = 85,
	};

    enum m_eFieldAttribute
    {
        FieldAttribute_Compiler,
        FieldAttribute_Private,
        FieldAttribute_FamilyAndAssembly,
        FieldAttribute_Assembly,
        FieldAttribute_Family,
        FieldAttribute_FamilyOrAssembly,
        FieldAttribute_Public,
        FieldAttribute_AccessMask,
        FieldAttribute_Static = 16,
        FieldAttribute_InitOnly = 32,
        FieldAttribute_Literal = 64,
        FieldAttribute_NotSerialized = 128,
        FieldAttribute_HasRVA = 256,
        FieldAttribute_SpecialName = 512,
        FieldAttribute_RTSpecialName = 1024,
        FieldAttribute_HasMarshal = 4096,
        FieldAttribute_InvokeImpl = 8192,
        FieldAttribute_Default = 32768,
        FieldAttribute_Reserved = 38144,
    };
}

```

`Unity/Obfuscators.hpp`:

```hpp
#pragma once

namespace Unity
{
	namespace Obfuscators
	{
        // Should do the basic work
        std::string ROT_String(const char* pString, int iValue)
        {
            std::string sRet;
            size_t sSize = strlen(pString);
            for (size_t i = 0; sSize > i; ++i)
            {
                bool bIsUppercase = pString[i] >= 'A' && 'Z' >= pString[i];
                bool bIsLowercase = !bIsUppercase && pString[i] >= 'a' && 'z' >= pString[i];
                if (!bIsUppercase && !bIsLowercase)
                {
                    sRet += pString[i];
                    continue;
                }

                int iNewValue = static_cast<int>(pString[i]) + iValue;
                if (bIsUppercase)
                {
                    int iMaxValue = static_cast<int>('Z');
                    while (iNewValue > iMaxValue) iNewValue = static_cast<int>('A') + (iNewValue - iMaxValue);
                }
                else
                {
                    int iMaxValue = static_cast<int>('z');
                    while (iNewValue > iMaxValue) iNewValue = static_cast<int>('a') + (iNewValue - iMaxValue);
                }

                sRet += static_cast<char>(iNewValue);
            }

            sRet += '\0';
            return sRet;
        }
	}
}
```

`Unity/Structures/Engine.hpp`:

```hpp
#pragma once

namespace Unity
{
	struct Vector2
	{
		float x, y;

		Vector2() { x = y = 0.f; }
		Vector2(float f1, float f2) { x = f1; y = f2; }
	};

	struct Vector3
	{
		float x, y, z;

		Vector3() { x = y = z = 0.f; }
		Vector3(float f1, float f2, float f3) { x = f1; y = f2; z = f3; }
		
		float Length()
		{
			return x * x + y * y + z * z;
		}
		
		float Dot(Vector3 b)
		{
			return x * b.x + y * b.y + z * b.z;
		}

		Vector3 Normalize()
		{
			float len = Length();
			if (len > 0)
				return Vector3(x / len, y / len, z / len);
			else
				return Vector3(x, y, z);
		}
		void ToVectors(Vector3* m_pForward, Vector3* m_pRight, Vector3* m_pUp)
		{
			float m_fDeg2Rad = static_cast<float>(M_PI) / 180.f;

			float m_fSinX = sinf(x * m_fDeg2Rad);
			float m_fCosX = cosf(x * m_fDeg2Rad);

			float m_fSinY = sinf(y * m_fDeg2Rad);
			float m_fCosY = cosf(y * m_fDeg2Rad);

			float m_fSinZ = sinf(z * m_fDeg2Rad);
			float m_fCosZ = cosf(z * m_fDeg2Rad);

			if (m_pForward)
			{
				m_pForward->x = m_fCosX * m_fCosY;
				m_pForward->y = -m_fSinX;
				m_pForward->z = m_fCosX * m_fSinY;
			}

			if (m_pRight)
			{
				m_pRight->x = -1.f * m_fSinZ * m_fSinX * m_fCosY + -1.f * m_fCosZ * -m_fSinY;
				m_pRight->y = -1.f * m_fSinZ * m_fCosX;
				m_pRight->z = -1.f * m_fSinZ * m_fSinX * m_fSinY + -1.f * m_fCosZ * m_fCosY;
			}

			if (m_pUp)
			{
				m_pUp->x = m_fCosZ * m_fSinX * m_fCosY + -m_fSinZ * -m_fSinY;
				m_pUp->y = m_fCosZ * m_fCosX;
				m_pUp->z = m_fCosZ * m_fSinX * m_fSinY + -m_fSinZ * m_fCosY;
			}
		}
	};

	struct Vector4
	{
		float x, y, z, w;

		Vector4() { x = y = z = w = 0.f; }
		Vector4(float f1, float f2, float f3, float f4) { x = f1; y = f2; z = f3; w = f4; }
	};

	struct Quaternion
	{
		float x, y, z, w;

		Quaternion() { x = y = z = w = 0.f; }
		Quaternion(float f1, float f2, float f3, float f4) { x = f1; y = f2; z = f3; w = f4; }

		Quaternion Euler(float m_fX, float m_fY, float m_fZ)
		{
			float m_fDeg2Rad = static_cast<float>(M_PI) / 180.f;

			m_fX = m_fX * m_fDeg2Rad * 0.5f;
			m_fY = m_fY * m_fDeg2Rad * 0.5f;
			m_fZ = m_fZ * m_fDeg2Rad * 0.5f;

			float m_fSinX = sinf(m_fX);
			float m_fCosX = cosf(m_fX);

			float m_fSinY = sinf(m_fY);
			float m_fCosY = cosf(m_fY);

			float m_fSinZ = sinf(m_fZ);
			float m_fCosZ = cosf(m_fZ);

			x = m_fCosY * m_fSinX * m_fCosZ + m_fSinY * m_fCosX * m_fSinZ;
			y = m_fSinY * m_fCosX * m_fCosZ - m_fCosY * m_fSinX * m_fSinZ;
			z = m_fCosY * m_fCosX * m_fSinZ - m_fSinY * m_fSinX * m_fCosZ;
			w = m_fCosY * m_fCosX * m_fCosZ + m_fSinY * m_fSinX * m_fSinZ;

			return *this;
		}

		Quaternion Euler(Vector3 m_vRot)
		{
			return Euler(m_vRot.x, m_vRot.y, m_vRot.z);
		}

		Vector3 ToEuler()
		{
			Vector3 m_vEuler;

			float m_fDist = (x * x) + (y * y) + (z * z) + (w * w);

			float m_fTest = x * w - y * z;
			if (m_fTest > 0.4995f * m_fDist)
			{
				m_vEuler.x = static_cast<float>(M_PI) * 0.5f;
				m_vEuler.y = 2.f * atan2f(y, x);
				m_vEuler.z = 0.f;
			}
			else if (m_fTest < -0.4995f * m_fDist)
			{
				m_vEuler.x = static_cast<float>(M_PI) * -0.5f;
				m_vEuler.y = -2.f * atan2f(y, x);
				m_vEuler.z = 0.f;
			}
			else
			{
				m_vEuler.x = asinf(2.f * (w * x - y * z));
				m_vEuler.y = atan2f(2.f * w * y + 2.f * z * x, 1.f - 2.f * (x * x + y * y));
				m_vEuler.z = atan2f(2.f * w * z + 2.f * x * y, 1.f - 2.f * (z * z + x * x));
			}

			float m_fRad2Deg = 180.f / static_cast<float>(M_PI);
			m_vEuler.x *= m_fRad2Deg;
			m_vEuler.y *= m_fRad2Deg;
			m_vEuler.z *= m_fRad2Deg;

			return m_vEuler;
		}
	};

	struct Bounds
	{
		Vector3 m_vCenter;
		Vector3 m_vExtents;
	};

	struct Plane
	{
		Vector3 m_vNormal;
		float fDistance;
	};

	struct Ray
	{
		Vector3 m_vOrigin;
		Vector3 m_vDirection;
	};

	struct Rect
	{
		float fX, fY;
		float fWidth, fHeight;

		Rect() { fX = fY = fWidth = fHeight = 0.f; }
		Rect(float f1, float f2, float f3, float f4) { fX = f1; fY = f2; fWidth = f3; fHeight = f4; }
	};

	struct Color
	{
		float r, g, b, a;

		Color() { r = g = b = a = 0.f; }
		Color(float fRed = 0.f, float fGreen = 0.f, float fBlue = 0.f, float fAlpha = 1.f) { r = fRed; g = fGreen; b = fBlue; a = fAlpha; }
	};

	struct Matrix4x4
	{
		float m[4][4] = { 0 };

		Matrix4x4() { }

		float* operator[](int i) { return m[i]; }
	};
}

```

`Unity/Structures/System_String.hpp`:

```hpp
#pragma once

namespace Unity
{
	struct System_String : il2cppObject
	{
		int m_iLength;
		wchar_t m_wString[1024];

		void Clear()
		{
			if (!this) return;

			memset(m_wString, 0, static_cast<size_t>(m_iLength) * 2);
			m_iLength = 0;
		}

		std::string ToString()
		{
		    if (!this) return "";

		    std::string sRet(static_cast<size_t>(m_iLength + 1) * 4, '\0');
		    WideCharToMultiByte(CP_UTF8, 0, m_wString, m_iLength, &sRet[0], static_cast<int>(sRet.size()), 0, 0);
		    return sRet;
		}
	};
}

```

`Unity/Structures/il2cpp.hpp`:

```hpp
#pragma once

namespace Unity
{
	struct il2cppImage
	{
		const char* m_pName;
		const char* m_pNameNoExt;
	};

	struct il2cppAssemblyName
	{
		const char* m_pName;
		const char* m_pCulture;
		const char* m_pHash;
		const char* m_pPublicKey;
		unsigned int m_uHash;
		int m_iHashLength;
		unsigned int m_uFlags;
		int m_iMajor;
		int m_iMinor;
		int m_iBuild;
		int m_bRevision;
		unsigned char m_uPublicKeyToken[8];
	};

	struct il2cppAssembly
	{
		il2cppImage* m_pImage;
		unsigned int m_uToken;
		int m_ReferencedAssemblyStart;
		int m_ReferencedAssemblyCount;
		il2cppAssemblyName m_aName;
	};

	struct il2cppClass
	{
		void* m_pImage;
		void* m_pGC;
		const char* m_pName;
		const char* m_pNamespace;
		void* m_pValue;
		void* m_pArgs;
		il2cppClass* m_pElementClass;
		il2cppClass* m_pCastClass;
		il2cppClass* m_pDeclareClass;
		il2cppClass* m_pParentClass;
		void* m_pGenericClass;
		void* m_pTypeDefinition;
		void* m_pInteropData;
		void* m_pFields;
		void* m_pEvents;
		void* m_pProperties;
		void** m_pMethods;
		il2cppClass** m_pNestedTypes;
		il2cppClass** m_ImplementedInterfaces;
		void* m_pInterfaceOffsets;
		void* m_pStaticFields;
		void* m_pRGCTX;
	};

	struct il2cppObject
	{
		il2cppClass* m_pClass = nullptr;
		void* m_pMonitor = nullptr;
	};

#ifdef UNITY_VERSION_2022_3_8F1
	struct il2cppType
	{
		void* data;
		unsigned int bits;
	};
#else
	struct il2cppType
	{
		union
		{
			void* m_pDummy;
			unsigned int m_uClassIndex;
			il2cppType* m_pType;
			void* m_pArray;
			unsigned int m_uGenericParameterIndex;
			void* m_pGenericClass;
		};
		unsigned int m_uAttributes : 16;
		unsigned int m_uType : 8;
		unsigned int m_uMods : 6;
		unsigned int m_uByref : 1;
		unsigned int m_uPinned : 1;
	};
#endif

	struct il2cppFieldInfo
	{
		const char* m_pName;
		il2cppType* m_pType;
		il2cppClass* m_pParentClass;
		int m_iOffset;
		int m_iAttributeIndex;
		unsigned int m_uToken;
	};
	
	struct il2cppParameterInfo
	{
		const char* m_pName;
		int m_iPosition;
		unsigned int m_uToken;
		il2cppType* m_pParameterType;
	};
	
	struct il2cppMethodInfo
	{
		void* m_pMethodPointer;
#ifdef UNITY_VERSION_2022_3_8F1
		void* m_pVirtualMethodPointer;
#endif
		void* m_pInvokerMethod;
		const char* m_pName;
		il2cppClass* m_pClass;
		il2cppType* m_pReturnType;
#ifdef UNITY_VERSION_2022_3_8F1
		il2cppType** m_pParameters;
#else
		il2cppParameterInfo* m_pParameters;
#endif

		union
		{
			void* m_pRGCTX;
			void* m_pMethodDefinition;
		};

		union
		{
			void* m_pGenericMethod;
			void* m_pGenericContainer;
		};

		unsigned int m_uToken;
		unsigned short m_uFlags;
		unsigned short m_uFlags2;
		unsigned short m_uSlot;
		unsigned char m_uArgsCount;
		unsigned char m_uGeneric : 1;
		unsigned char m_uInflated : 1;
		unsigned char m_uWrapperType : 1;
		unsigned char m_uMarshaledFromNative : 1;
	};

	struct il2cppPropertyInfo
	{
		il2cppClass* m_pParentClass;
		const char* m_pName;
		il2cppMethodInfo* m_pGet;
		il2cppMethodInfo* m_pSet;
		unsigned int m_uAttributes;
		unsigned int m_uToken;
	};

	struct il2cppArrayBounds
	{
		uintptr_t m_uLength;
		int m_iLowerBound;
	};
}

```

`Unity/Structures/il2cppArray.hpp`:

```hpp
#pragma once

namespace Unity
{
	template<typename T>
	struct il2cppArray : il2cppObject
	{
		il2cppArrayBounds* m_pBounds = nullptr;
		uintptr_t m_uMaxLength = 0;
		T* m_pValues = nullptr;

		uintptr_t GetData()
		{
			return reinterpret_cast<uintptr_t>(&m_pValues);
		}

		T& operator[](unsigned int m_uIndex)
		{
			return *reinterpret_cast<T*>(GetData() + sizeof(T) * m_uIndex);
		}

		T& At(unsigned int m_uIndex)
		{
			return operator[](m_uIndex);
		}

		void Insert(T* m_pArray, uintptr_t m_uSize, uintptr_t m_uIndex = 0)
		{
			if ((m_uSize + m_uIndex) >= m_uMaxLength)
			{
				if (m_uIndex >= m_uMaxLength)
					return;

				m_uSize = m_uMaxLength - m_uIndex;
			}

			for (uintptr_t u = 0; m_uSize > u; ++u)
				operator[](u + m_uIndex) = m_pArray[u];
		}

		void Fill(T m_tValue)
		{
			for (uintptr_t u = 0; m_uMaxLength > u; ++u)
				operator[](u) = m_tValue;
		}

		void RemoveAt(unsigned int m_uIndex)
		{
			if (m_uIndex >= m_uMaxLength)
				return;

			if (m_uMaxLength > (m_uIndex + 1))
			{
				for (unsigned int u = m_uIndex; (static_cast<unsigned int>(m_uMaxLength) - m_uIndex) > u; ++u)
					operator[](u) = operator[](u + 1);
			}

			--m_uMaxLength;
		}

		void RemoveRange(unsigned int m_uIndex, unsigned int m_uCount)
		{
			if (m_uCount == 0)
				m_uCount = 1;

			unsigned int m_uTotal = m_uIndex + m_uCount;
			if (m_uTotal >= m_uMaxLength)
				return;

			if (m_uMaxLength > (m_uTotal + 1))
			{
				for (unsigned int u = m_uIndex; (static_cast<unsigned int>(m_uMaxLength) - m_uTotal) >= u; ++u)
					operator[](u) = operator[](u + m_uCount);
			}

			m_uMaxLength -= m_uCount;
		}

		void RemoveAll()
		{
			if (m_uMaxLength > 0)
			{
				memset(GetData(), 0, sizeof(T) * m_uMaxLength);
				m_uMaxLength = 0;
			}
		}
	};

	// Defined here because its basically same shit
	template<typename T>
	struct il2cppList : il2cppObject
	{
		il2cppArray<T>* m_pListArray;

		il2cppArray<T>* ToArray() { return m_pListArray; }
	};
}
```

`Unity/Structures/il2cppDictionary.hpp`:

```hpp
#pragma once

namespace Unity
{
	template<typename TKey,typename TValue>
	struct il2cppDictionary : il2cppObject
	{
		struct Entry
		{
			int m_iHashCode;
			int m_iNext;
			TKey m_tKey;
			TValue m_tValue;
		};
		il2cppArray<int>* m_pBuckets;
		il2cppArray<Entry*>* m_pEntries;
		int m_iCount;
		int m_iVersion;
		int m_iFreeList;
		int m_iFreeCount;
		void* m_pComparer;
		void* m_pKeys;
		void* m_pValues;

		Entry* GetEntry()
		{
			return (Entry*)m_pEntries->GetData();
		}

		TKey GetKeyByIndex(int iIndex)
		{
			TKey tKey = { 0 };
			
			Entry* pEntry = GetEntry();
			if (pEntry)
				tKey = pEntry[iIndex].m_tKey;

			return tKey;
		}

		TValue GetValueByIndex(int iIndex)
		{
			TValue tValue = { 0 };

			Entry* pEntry = GetEntry();
			if (pEntry)
				tValue = pEntry[iIndex].m_tValue;

			return tValue;
		}

		TValue GetValueByKey(TKey tKey)
		{
			TValue tValue = { 0 };
			for (int i = 0; i < m_iCount; i++) {
				if (GetEntry()[i].m_tKey == tKey)
					tValue =  GetEntry()[i].m_tValue;
			}
			return tValue;
		}
	};
}

```

`Utils/Hash.hpp`:

```hpp
#pragma once

namespace IL2CPP
{
	namespace Utils
	{
        namespace Hash
        {
            uint32_t Get(const char* m_String)
            {
                uint32_t m_Hash = 0;

                for (; *m_String; ++m_String)
                {
                    m_Hash += *m_String;
                    m_Hash += m_Hash << 10;
                    m_Hash ^= m_Hash >> 6;
                }

                m_Hash += m_Hash << 3;
                m_Hash ^= m_Hash >> 11;
                m_Hash += m_Hash << 15;

                return m_Hash;
            }

            constexpr uint32_t GetCompileTime(const char* m_String)
            {
                uint32_t m_Hash = 0;

                for (; *m_String; ++m_String)
                {
                    m_Hash += *m_String;
                    m_Hash += m_Hash << 10;
                    m_Hash ^= m_Hash >> 6;
                }

                m_Hash += m_Hash << 3;
                m_Hash ^= m_Hash >> 11;
                m_Hash += m_Hash << 15;

                return m_Hash;
            }
        }
	}
}

#define IL2CPP_HASH(m_String) \
[](){ \
    static constexpr uint32_t m_Hash = IL2CPP::Utils::Hash::GetCompileTime(m_String); \
    return m_Hash; \
}()

```

`Utils/Helper.hpp`:

```hpp
#pragma once

namespace IL2CPP
{
	namespace Helper
	{
		Unity::CComponent* GetMonoBehaviour()
		{
			Unity::il2cppArray<Unity::CGameObject*>* m_Objects = Unity::Object::FindObjectsOfType<Unity::CGameObject>(UNITY_GAMEOBJECT_CLASS);
			for (uintptr_t u = 0U; m_Objects->m_uMaxLength > u; ++u)
			{
				Unity::CGameObject* m_Object = m_Objects->operator[](static_cast<unsigned int>(u));
				if (!m_Object) continue;

				Unity::CComponent* m_MonoBehaviour = m_Object->GetComponentByIndex(UNITY_MONOBEHAVIOUR_CLASS);
				if (m_MonoBehaviour)
					return m_MonoBehaviour;
			}

			return nullptr;
		}
	}
}
```

`Utils/VTable.hpp`:

```hpp
#pragma once

namespace IL2CPP
{
    namespace Utils
    {
        namespace VTable
        {
            void ReplaceFunction(void** m_VTableFunc, void* m_NewFunc, void** m_Original = nullptr)
            {
                if (!m_VTableFunc)
                    return;

                DWORD m_OldProtection = 0x0;
                if (!VirtualProtect(m_VTableFunc, sizeof(void*), PAGE_READWRITE, &m_OldProtection))
                    return;
             
                if (m_Original) 
                    *m_Original = *m_VTableFunc;

                *m_VTableFunc = m_NewFunc;
                VirtualProtect(m_VTableFunc, sizeof(void*), m_OldProtection, &m_OldProtection);
            }

            void** FindFunction(void** m_VTable, int m_Count, std::initializer_list<unsigned char> m_Opcodes)
            {
                size_t m_OpcodeSize = m_Opcodes.size();
                const void* m_OpcodesPtr = m_Opcodes.begin();

                for (int i = 0; m_Count > i; ++i)
                {
                    if (memcmp(m_VTable[i], m_OpcodesPtr, m_OpcodeSize) == 0)
                        return &m_VTable[i];
                }

                return 0;
            }
        }
    }
}
```