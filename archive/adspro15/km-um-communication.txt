Project Path: arc_adspro15_km-um-communication_mskof45x

Source Tree:

```txt
arc_adspro15_km-um-communication_mskof45x
├── LICENSE
├── README.md
├── callback-km
│   ├── CvcSv
│   │   ├── Cvc.c
│   │   ├── Cvc.h
│   │   ├── CvcInternal.c
│   │   └── CvcInternal.h
│   ├── Declaration.h
│   ├── Main.c
│   ├── Native
│   │   ├── Native.h
│   │   ├── Pe.c
│   │   ├── Pe.h
│   │   ├── Ut.c
│   │   └── Ut.h
│   ├── Nt.h
│   ├── callback-km.inf
│   ├── callback-km.vcxproj
│   ├── callback-km.vcxproj.filters
│   ├── hde
│   │   ├── hde64.c
│   │   ├── hde64.h
│   │   ├── pstdint.h
│   │   └── table64.h
│   └── stdafx.h
├── callback-um
│   ├── CRT
│   │   ├── Alloc.c
│   │   ├── Alloc.h
│   │   ├── CRT.c
│   │   ├── CRT.h
│   │   ├── IsCtype.c
│   │   ├── List.h
│   │   ├── Memory.c
│   │   ├── Semaphore.h
│   │   ├── Sprintf.c
│   │   ├── Sprintf.h
│   │   ├── String.c
│   │   ├── String.h
│   │   ├── WString.c
│   │   └── WString.h
│   ├── Cse
│   │   ├── Cse.c
│   │   └── Cse.h
│   ├── CvcCl
│   │   ├── Cvc.c
│   │   ├── Cvc.h
│   │   └── Dispatcher.asm
│   ├── Declaration.h
│   ├── Main.c
│   ├── callback-um.vcxproj
│   ├── callback-um.vcxproj.filters
│   ├── stdafx.c
│   └── stdafx.h
├── dispatch-km
│   ├── dispatch-km.inf
│   ├── dispatch-km.vcxproj
│   ├── dispatch-km.vcxproj.filters
│   └── main.c
├── dispatch-um
│   ├── dispatch-um.vcxproj
│   ├── dispatch-um.vcxproj.filters
│   └── main.cpp
├── ioctl-km
│   ├── Driver.c
│   ├── ioctl-km.inf
│   ├── ioctl-km.vcxproj
│   └── ioctl-km.vcxproj.filters
├── ioctl-um
│   ├── Driver.cpp
│   ├── Driver.h
│   ├── Main.cpp
│   ├── ioctl-um.vcxproj
│   └── ioctl-um.vcxproj.filters
├── km-um-communication.sln
├── named-pipe-km
│   ├── main.c
│   ├── named-pipe-km.inf
│   ├── named-pipe-km.vcxproj
│   └── named-pipe-km.vcxproj.filters
├── named-pipe-um
│   ├── main.cpp
│   ├── named-pipe-um.vcxproj
│   └── named-pipe-um.vcxproj.filters
├── shared-memory-km
│   ├── Structs.h
│   ├── dependencies.h
│   ├── loop.h
│   ├── main.c
│   ├── main.h
│   ├── shared-memory-km.inf
│   ├── shared-memory-km.vcxproj
│   ├── shared-memory-km.vcxproj.filters
│   └── undocumented_structs.h
├── shared-memory-um
│   ├── KernelHelpers.h
│   ├── Kernelrequests.h
│   ├── Structs.h
│   ├── main.cpp
│   ├── shared-memory-um.vcxproj
│   └── shared-memory-um.vcxproj.filters
├── socket-km
│   ├── imports.h
│   ├── ksocket
│   │   ├── berkeley.c
│   │   ├── berkeley.h
│   │   ├── ksocket.c
│   │   └── ksocket.h
│   ├── log.h
│   ├── main.cpp
│   ├── packet_handler.cpp
│   ├── server.cpp
│   ├── server_shared.h
│   ├── socket-km.inf
│   ├── socket-km.vcxproj
│   ├── socket-km.vcxproj.filters
│   ├── sockets.h
│   └── stdint.h
└── socket-um
    ├── driver.cpp
    ├── driver.h
    ├── main.cpp
    ├── server_shared.h
    ├── socket-um.vcxproj
    └── socket-um.vcxproj.filters

```

`LICENSE`:

```
MIT License

Copyright (c) 2019 Alexander Bruun

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# km-um-communication
A somewhat wide collection of various kernelmode-usermode communication methods in one repository (mainly just for learning purposes).

## Project structure
![project structure](https://i.gyazo.com/473599b605f59017210ff17c5c7dcf08.png)

```

`callback-km/CvcSv/Cvc.c`:

```c
#include "../Native/Native.h"
#include "../hde/hde64.h"
#include "../../Declaration.h"
#include "Cvc.h"
#include "CvcInternal.h"

BOOLEAN CvcClosure = FALSE;
BOOLEAN Shutdown = FALSE;
KGUARDED_MUTEX CvcMutex;
PEPROCESS ClientProcess = NULL;
PVOID pfnDispatcher = NULL;
HANDLE CvcpPendingThreadId = NULL;


extern OpenAdapter_t pfOpenAdapter;

#pragma code_seg(push)
#pragma code_seg("PAGE")

NTSTATUS
CvcpOpenAdapterHook(
	PVOID Arg
);

NTSTATUS
CvcpProcessAddConnectionMsg(
	const pCvcAddConnection Message
) {

	PAGED_CODE();

	NTSTATUS Status = STATUS_SUCCESS;

	PETHREAD SlaveThread = NULL;
	PRKEVENT RequestEvent = NULL;
	PRKEVENT CompliteEvent = NULL;

	Status = ObReferenceObjectByHandleWithTag(
		Message->SlaveHandle,
		(ACCESS_MASK)2,
		*PsThreadType,
		UserMode,
		'tlfD',
		&SlaveThread,
		NULL
	);

	if (!NT_SUCCESS(Status)) {

		DbgPrint("%s: Cannot reference thread\n", __FUNCTION__);
		goto FinalStub;
	}

	Status = ObReferenceObjectByHandleWithTag(
		Message->RequestEvent,
		(ACCESS_MASK)2,
		*ExEventObjectType,
		UserMode,
		'tlfD',
		&RequestEvent,
		NULL
	);

	if (!NT_SUCCESS(Status)) {

		DbgPrint("%s: Cannot reference RequestEvent\n", __FUNCTION__);
		goto FinalStub;
	}

	Status = ObReferenceObjectByHandleWithTag(
		Message->CompliteEvent,
		(ACCESS_MASK)2,
		*ExEventObjectType,
		UserMode,
		'tlfD',
		&CompliteEvent,
		NULL
	);

	if (!NT_SUCCESS(Status)) {

		DbgPrint("%s: Cannot reference CompliteEvent\n", __FUNCTION__);
		goto FinalStub;
	}

	CvcpPendingThreadId = PsGetThreadId(SlaveThread);

	CvciHookOpenAdapter((PVOID)CvcpOpenAdapterHook);

	KeSetEvent(RequestEvent, 1, FALSE);

	LARGE_INTEGER Timeout = { .QuadPart = -8000 };

	int RetryCount = 0;

	while (KeWaitForSingleObject(
		CompliteEvent,
		Executive,
		KernelMode,
		TRUE,
		&Timeout) != STATUS_WAIT_0) {

		if (PsIsThreadTerminating(SlaveThread)) {

			DbgPrint("%s: PsIsThreadTerminating(SlaveThread)\n", __FUNCTION__);
			Status = STATUS_THREAD_IS_TERMINATING;
			break;
		}
		else if (RetryCount > 0x60) {

			DbgPrint("%s: RetryCount > 0x60\n", __FUNCTION__);
			Status = STATUS_DRIVER_CANCEL_TIMEOUT;
			break;
		}

		RetryCount++;
	}

FinalStub:;

	if (SlaveThread) {

		ObDereferenceObject(SlaveThread);
	}

	if (CompliteEvent) {

		ObDereferenceObject(CompliteEvent);
	}

	if (RequestEvent) {

		ObDereferenceObject(RequestEvent);
	}

	CvciUnhookOpenAdapter();

	CvcpPendingThreadId = NULL;

	return Status;
}

NTSTATUS
CvcpProcessHelloWorldMsg(
	const pCvcHelloWorld Message
) {

	NTSTATUS Status = STATUS_UNSUCCESSFUL;

	if (Message->Magic == ' cvC') {

		DbgPrint("Hello world!\n");

		ANSI_STRING UserOutput = RTL_CONSTANT_STRING("Hello, user!");

		PVOID Input = NULL;
		ULONG InputLen = 0;

		Status = CvciUsermodeCallout(
			CVCKE_DISPLAY,
			NULL,
			pfnDispatcher,
			UserOutput.Buffer,
			UserOutput.MaximumLength,
			&Input,
			&InputLen
		);
	}

	return Status;
}

NTSTATUS
CvcpProcessReadMsg(
	const pCvcRead Message
) {

	NTSTATUS Status = STATUS_SUCCESS;
	PEPROCESS Process = NULL;

	Status = PsLookupProcessByProcessId(Message->Pid, &Process);


	if (!NT_SUCCESS(Status)) {

		return Status;
	}

	SIZE_T Result = 0;

	__try {

		Status = MmCopyVirtualMemory(
			Process,
			(PVOID)Message->Ptr,
			PsGetCurrentProcess(),
			(PVOID)Message->pOut,
			Message->Size,
			KernelMode,
			&Result
		);
	}
	__except (EXCEPTION_EXECUTE_HANDLER) {

		Status = GetExceptionCode();
	}


	ObDereferenceObject(Process);

	return Status;
}

NTSTATUS
CvcpProcessWriteMsg(
	const pCvcWrite Message
) {

	NTSTATUS Status = STATUS_SUCCESS;
	PEPROCESS Process = NULL;

	Status = PsLookupProcessByProcessId(Message->Pid, &Process);

	if (!NT_SUCCESS(Status)) {

		return Status;
	}

	SIZE_T Result = 0;

	__try {

		Status = MmCopyVirtualMemory(
			PsGetCurrentProcess(),
			(PVOID)Message->pSrc,
			Process,
			(PVOID)Message->Ptr,
			Message->Size,
			KernelMode,
			&Result
		);
	}
	__except (EXCEPTION_EXECUTE_HANDLER) {

		Status = GetExceptionCode();
	}

	ObDereferenceObject(Process);

	return Status;
}

BOOLEAN
CvcpProcessUserMessage(
	const BOOLEAN IsMainConnection,
	const PVOID InputData,
	const ULONG InputDataLen
) {

	NTSTATUS UserStatus = STATUS_SUCCESS;
	pCvcCLMsg ClMessage = (pCvcCLMsg)ALIGN_UP_BY(
		alloca(InputDataLen + MEMORY_ALLOCATION_ALIGNMENT),
		MEMORY_ALLOCATION_ALIGNMENT
	);

	__try {

		RtlSecureZeroMemory(ClMessage, InputDataLen);
		RtlCopyMemory(ClMessage, InputData, InputDataLen);

	}
	__except (EXCEPTION_EXECUTE_HANDLER) {

		ClMessage = NULL;
		UserStatus = GetExceptionCode();
	}

	if (!ClMessage || !NT_SUCCESS(UserStatus)) {

		DbgPrint("%s: Exception occured while trying to access user message\n", __FUNCTION__);
		return FALSE;
	}

	__try {

		*ClMessage->pResultStatus = STATUS_SUCCESS;
	}
	__except (EXCEPTION_EXECUTE_HANDLER) {

		UserStatus = GetExceptionCode();
	}

	if (!NT_SUCCESS(UserStatus)) {

		DbgPrint("%s: Exception while trying to write ResultStatus\n", __FUNCTION__);
		return FALSE;
	}

	PRKEVENT CompliteEvent;
	UserStatus = ObReferenceObjectByHandleWithTag(
		ClMessage->CompliteEvent,
		(ACCESS_MASK)2,
		*ExEventObjectType,
		UserMode,
		'tlfD',
		&CompliteEvent,
		NULL
	);

	if (!NT_SUCCESS(UserStatus)) {

		DbgPrint("%s: Cannot reference event\n", __FUNCTION__);
		return FALSE;
	}

	switch (((pCvcNull)&ClMessage->Data)->Type)
	{
	case CVCCL_ADD_CONNECTION:
		UserStatus = IsMainConnection
			? CvcpProcessAddConnectionMsg((pCvcAddConnection)&ClMessage->Data)
			: STATUS_ILLEGAL_FUNCTION;
		break;
	case CVCCL_HELLO_WORLD:
		UserStatus = CvcpProcessHelloWorldMsg((pCvcHelloWorld)&ClMessage->Data);
		break;
	case CVCCL_READ:
		UserStatus = CvcpProcessReadMsg((pCvcRead)&ClMessage->Data);
		break;
	case CVCCL_WRITE:
		UserStatus = CvcpProcessWriteMsg((pCvcWrite)&ClMessage->Data);
		break;
	default:
		UserStatus = STATUS_INVALID_PARAMETER;
		break;
	}

	*ClMessage->pResultStatus = UserStatus;

	KeSetEvent(CompliteEvent, 1, FALSE);
	ObDereferenceObject(CompliteEvent);
	return TRUE;
}

VOID
CvcMain(
	PVOID StartContext
) {

	UNREFERENCED_PARAMETER(StartContext);
	PAGED_CODE();

	KeInitializeGuardedMutex(&CvcMutex);

	while (!CvcClosure) {

		PAGED_CODE();

		while (!NT_SUCCESS(CvcCreate())) {

			if (CvcClosure) {

				CvciExit();
				CvcTerminate();
				PsTerminateSystemThread(0);
			}

			LARGE_INTEGER WaitTime = { .QuadPart = -1000 };

			KeDelayExecutionThread(
				KernelMode,
				TRUE,
				&WaitTime
			);
		}

		KeWaitForSingleObject(
			ClientProcess,
			Executive,
			KernelMode,
			TRUE,
			NULL
		);

		CvcTerminate();
	}

	CvciExit();

	PsTerminateSystemThread(0);
}

BOOLEAN CvcpPrCmp(
	PEPROCESS TempPr,
	PSYSTEM_THREAD_INFORMATION ThreadsInfo,
	DWORD_PTR Limit
) {

	UNREFERENCED_PARAMETER(ThreadsInfo);
	UNREFERENCED_PARAMETER(Limit);
	PAGED_CODE();

	BOOLEAN Correct = FALSE;
	KAPC_STATE ApcState;
	KeStackAttachProcess(TempPr, &ApcState);

	__try {

		PPEB Peb = PsGetProcessPeb(TempPr);

		pfnDispatcher = LdrFindProcAdressA(Peb->ImageBaseAddress, "KeUserCallbackDispatcher");

		if (pfnDispatcher) {

			Correct = TRUE;
		}
	}
	__except (EXCEPTION_EXECUTE_HANDLER) {

		DbgPrint("%s: Exception 0x%X\n", __FUNCTION__, GetExceptionCode());
	}

	if (!Correct) {

		pfnDispatcher = NULL;
	}

	KeUnstackDetachProcess(&ApcState);

	return Correct;
}

VOID
CvcpDispatcher(
	const pCvcConnection pConnection
) {

	const BOOLEAN IsMainConnection = pConnection == NULL;

	while (!Shutdown && !PsIsThreadTerminating(KeGetCurrentThread())) {

		PVOID Input = NULL;
		ULONG InputLen = 0;

		NTSTATUS Status = CvciUsermodeCallout(
			CVCKE_NOP,
			pConnection,
			pfnDispatcher,
			NULL,
			0,
			&Input,
			&InputLen
		);

		if (NT_SUCCESS(Status) && Input && InputLen) {

			if (!CvcpProcessUserMessage(IsMainConnection, Input, InputLen)) {

				/*
				Something hardly messed up - break connection
				*/
				DbgPrint("%s: Break connection\n", __FUNCTION__);
				return;
			}
		}
	}
}

NTSTATUS
CvcpOpenAdapterHook(
	PVOID Arg
) {

	KeAcquireGuardedMutex(&CvcMutex);

	if (IoGetCurrentProcess() == ClientProcess &&
		CvcpPendingThreadId
		? CvcpPendingThreadId == PsGetCurrentThreadId()
		: TRUE) {

		CvciUnhookOpenAdapter();
		KeReleaseGuardedMutex(&CvcMutex);

		NTSTATUS Status = STATUS_SUCCESS;

		ConnectionRequest Request = { .CompliteEvent = NULL, .Connection = NULL};
		
		__try {
		
			RtlCopyMemory(&Request, CvciGetUserArgument(), sizeof(ConnectionRequest));
		}
		__except(EXCEPTION_EXECUTE_HANDLER) {

			DbgPrint("%s: Exception read request\n", __FUNCTION__);
			Status = GetExceptionCode();
		}

		if (!NT_SUCCESS(Status)) {

			return STATUS_CONNECTION_ABORTED;
		}

		if (CvcpPendingThreadId && Request.Connection) {

			PRKEVENT CompliteEvent;

			Status = ObReferenceObjectByHandleWithTag(
				Request.CompliteEvent,
				(ACCESS_MASK)2,
				*ExEventObjectType,
				UserMode,
				'tlfD',
				&CompliteEvent,
				NULL
			);

			if (!NT_SUCCESS(Status)) {
				DbgPrint("%s: Failed referencing hCompliteEvent\n", __FUNCTION__);
				return STATUS_CONNECTION_ABORTED;
			}
			
			KeSetEvent(CompliteEvent, 1, FALSE);
			ObDereferenceObject(CompliteEvent);
			CvcpPendingThreadId = NULL;
		}
		else if (CvcpPendingThreadId || Request.Connection) {

			DbgPrint("%s: CvcpPendingThreadId || Request.Connection\n", __FUNCTION__);
			return STATUS_CONNECTION_ABORTED;
		}

		CvcpDispatcher(Request.Connection);

		return STATUS_CONNECTION_ABORTED;

	}

	KeReleaseGuardedMutex(&CvcMutex);

	return pfOpenAdapter(Arg);
}

NTSTATUS
CvcCreate(
	VOID
) {

	PAGED_CODE();
	Shutdown = FALSE;

	NTSTATUS Status = UtFindProcesses(L"CvcUm.exe", &ClientProcess, CvcpPrCmp);

	if (!NT_SUCCESS(Status)) {

		return Status;
	}

	KAPC_STATE Kapc;

	KeStackAttachProcess(ClientProcess, &Kapc);
	CvciHookOpenAdapter((PVOID)CvcpOpenAdapterHook);//patch dxgk interface for process session
	KeUnstackDetachProcess(&Kapc);

	return Status;
}

VOID
CvcTerminate(
	VOID
) {

	PAGED_CODE();
	Shutdown = TRUE;
	CvcpPendingThreadId = NULL;

	if (ClientProcess) {

		KAPC_STATE Kapc;

		KeStackAttachProcess(ClientProcess, &Kapc);
		CvciUnhookOpenAdapter();
		KeUnstackDetachProcess(&Kapc);

		ObDereferenceObject(ClientProcess);
		ClientProcess = NULL;
	}

	pfnDispatcher = NULL;
}
#pragma code_seg(pop)

```

`callback-km/CvcSv/Cvc.h`:

```h
#pragma once
/*
Cvc - Communication via callback function prefix
*/

extern BOOLEAN CvcClosure;

NTSTATUS
CvcInitInternals(
	VOID
);

VOID
CvcMain(
	PVOID StartContext
);

NTSTATUS
CvcCreate(
	VOID
);

VOID
CvcTerminate(
	VOID
);
```

`callback-km/CvcSv/CvcInternal.c`:

```c
#include "../Native/Native.h"
#include "../hde/hde64.h"
#include "../../Declaration.h"
#include "Cvc.h"
#include "CvcInternal.h"

MmCreateKernelStack_t MmCreateKernelStack = NULL;
MmDeleteKernelStack_t MmDeleteKernelStack = NULL;


#ifndef DXGK_WIN32K_QUERY_INTERFACE
/***/#define DXGK_WIN32K_QUERY_INTERFACE CTL_CODE(FILE_DEVICE_VIDEO,0x815,METHOD_NEITHER,FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#endif

KiCallUserMode_t ShellKiCallUserMode = NULL;
PVOID* pfnShellUmDispatcher = NULL;

PDXGKWIN32K_INTERFACE gDxgkInterface = NULL;
ULONG OpenAdapterIdx = 0;
OpenAdapter_t pfOpenAdapter = NULL;

KPCR ** KiProcessorBlock = NULL;
ULONG OfTrapFrame = 0;
ULONG OfIdealProcessor = 0;
ULONG OfParentNode = 0;
ULONG OfNodeNumber = 0;

#pragma code_seg(push)
#pragma code_seg("INIT")

NTSTATUS
CvcipFindDxgkInterface(
	VOID
) {

	PAGED_CODE();
	PDXGKWIN32K_INTERFACE pInterface = NULL;
	PFILE_OBJECT gpDxgkFileObject = NULL;
	NTSTATUS Status = STATUS_SUCCESS;
	PEPROCESS Csrss = NULL;
	KAPC_STATE Kapc;

	Status = UtFindProcesses(L"csrss.exe", &Csrss, NULL);

	if (!NT_SUCCESS(Status)) {

		goto OutStub;
	}

	KeStackAttachProcess(Csrss, &Kapc);

	pInterface = (PDXGKWIN32K_INTERFACE)ExAllocatePoolWithTag(NonPagedPool, sizeof(DXGKWIN32K_INTERFACE), MEMORY_TAG);

	if (!pInterface) {

		Status = STATUS_NO_MEMORY;
		goto OutStub;
	}

	RtlSecureZeroMemory(pInterface, sizeof(DXGKWIN32K_INTERFACE));

	PVOID win32k = NULL;
	Status = UtFindSystemImage("win32kbase.sys", &win32k);

	if (!NT_SUCCESS(Status)) {

		Status = UtFindSystemImage("win32k.sys", &win32k);
		if (!NT_SUCCESS(Status)) {

			DbgPrint("%s: UtFindSystemImage status 0x%X\n", __FUNCTION__, Status);
			Status = STATUS_MISSING_SYSTEMFILE;
			goto OutStub;
		}
	}

	PVOID SectionMin, SectionMax;
	if (!RtlSectionRange(win32k, ".data", &SectionMin, &SectionMax)) {

		DbgPrint("%s: RtlSectionRange failed\n",__FUNCTION__);
		Status = STATUS_UNSUCCESSFUL;
		goto OutStub;
	}

	UNICODE_STRING ObjectName = RTL_CONSTANT_STRING(L"\\Device\\DxgKrnl");
	PDEVICE_OBJECT gpDxgkDeviceObject = NULL;

	Status = IoGetDeviceObjectPointer(
		&ObjectName,
		GENERIC_READ | GENERIC_WRITE,
		&gpDxgkFileObject,
		&gpDxgkDeviceObject
	);

	if (!NT_SUCCESS(Status)) {

		goto OutStub;
	}

	IO_STATUS_BLOCK IoStatus;
	KEVENT Event;
	KeInitializeEvent(
		&Event,
		SynchronizationEvent,
		FALSE
	);

	Status = STATUS_UNSUCCESSFUL;

	for (WORD i = 1; i < 0xFF; i++) {//for windows 10

		pInterface->Magic = i;

		for (WORD j = 0x200; j < sizeof(DXGKWIN32K_INTERFACE); j += sizeof(DWORD64)) {

			pInterface->Size = j;

			RtlSecureZeroMemory(&IoStatus, sizeof(IoStatus));

			PIRP pIrp = IoBuildDeviceIoControlRequest(
				DXGK_WIN32K_QUERY_INTERFACE,
				gpDxgkDeviceObject,
				pInterface,
				pInterface->Size,
				pInterface,
				pInterface->Size,
				TRUE,
				&Event,
				&IoStatus
			);

			if (!pIrp) {

				Status = STATUS_NO_MEMORY;
				goto OutStub;
			}

			Status = IofCallDriver(gpDxgkDeviceObject, pIrp);

			if (Status == STATUS_PENDING) {

				KeWaitForSingleObject(
					&Event,
					Executive,
					KernelMode,
					FALSE,
					NULL
				);
				Status = IoStatus.Status;
			}

			if (NT_SUCCESS(Status)) {

				break;
			}
		}
		if (NT_SUCCESS(Status)) {

			break;
		}
	}

	if (!NT_SUCCESS(Status)) {

		DbgPrint("%s: Can't query dxgk interface 0x%X\n", __FUNCTION__, Status);
		Status = STATUS_UNSUCCESSFUL;
		goto OutStub;
	}

	ULONG IdxOpenAdapter = (ULONG)-1;

	__try {

		for (ULONG i = 0x3; i < 0x10; i++) {

			DWORD64 Temp = (DWORD64)pInterface->pFn[i];
			hde64s hde;

			do {

				hde64_disasm((PVOID)Temp, &hde);


				if (hde.opcode == 0x0F && (hde.opcode2 >= 0x80 && hde.opcode2 <= 0x8F)) {

					DWORD64 Temp1 = Temp + hde.len + (int)hde.imm.imm32;
					hde64s hde1;

					do {

						hde64_disasm((PVOID)Temp1, &hde1);

						if (hde1.imm.imm64 == 0x7D1) {

							IdxOpenAdapter = i;
							break;
						}

						Temp1 += hde1.len;

					} while (
						hde1.opcode != 0xC3 &&
						hde1.opcode != 0xC2 &&
						hde1.opcode != 0xCC &&
						hde1.opcode != 0xE9
						);
				}

				if (hde.imm.imm64 == 0x7D1) {

					IdxOpenAdapter = i;
					break;
				}
				else if (IdxOpenAdapter != (ULONG)-1) {

					break;
				}

				Temp += hde.len;

			} while (
				hde.opcode != 0xC3 &&
				hde.opcode != 0xC2 &&
				hde.opcode != 0xCC 
				);

			if (IdxOpenAdapter != (ULONG)-1) {

				break;
			}
		}
	}
	__except (EXCEPTION_EXECUTE_HANDLER) {

		DbgPrint("%s: IdxOpenAdapter Exception\n", __FUNCTION__);
		Status = GetExceptionCode();
	}

	if (!NT_SUCCESS(Status)) {

		goto OutStub;
	}

	if (IdxOpenAdapter != (ULONG)-1) {

		OpenAdapterIdx = IdxOpenAdapter;
	}
	else {

		DbgPrint("%s: IdxOpenAdapter == -1\n", __FUNCTION__);
		Status = STATUS_UNSUCCESSFUL;
		goto OutStub;
	}

	PDXGKWIN32K_INTERFACE pDxInterface = NULL;
	PBYTE ScanPtr = (PBYTE)SectionMin;

	__try {

		while (ScanPtr < (PBYTE)SectionMax - 0x30) {

			if (RtlEqualMemory(ScanPtr, pInterface->pFn, 0x30)) {

				pDxInterface = (PDXGKWIN32K_INTERFACE)(ScanPtr - FIELD_OFFSET(DXGKWIN32K_INTERFACE, pFn));
				break;
			}

			ScanPtr++;
		}
	}
	__except (EXCEPTION_EXECUTE_HANDLER) {

		DbgPrint("%s: pDxInterface Exception\n", __FUNCTION__);
		Status = STATUS_UNSUCCESSFUL;
	}

	if (!NT_SUCCESS(Status)) {

		goto OutStub;
	}

	if (pDxInterface != NULL) {

		gDxgkInterface = pDxInterface;
	}
	else {

		pDxInterface = LdrFindProcAdressA(win32k, "?gDxgkInterface@@3U_DXGKWIN32K_INTERFACE@@A");

		if (!pDxInterface) {

			DbgPrint("%s: pDxInterface == NULL\n", __FUNCTION__);
			Status = STATUS_UNSUCCESSFUL;
			goto OutStub;
		}
	}

	pfOpenAdapter = (OpenAdapter_t)gDxgkInterface->pFn[OpenAdapterIdx];

OutStub:;

	if (Csrss) {

		KeUnstackDetachProcess(&Kapc);
		ObDereferenceObject(Csrss);
	}

	if (gpDxgkFileObject) {

		ObDereferenceObject(gpDxgkFileObject);
	}

	if (pInterface) {

		ExFreePoolWithTag(pInterface, MEMORY_TAG);
	}

	return Status;
}

NTSTATUS
CvcipSolveTrapFrameOffset(
	VOID
) {

	PAGED_CODE();
	UNICODE_STRING ExpName = RTL_CONSTANT_STRING(L"KeRaiseUserException");
	DWORD64 Temp = (DWORD64)MmGetSystemRoutineAddress(&ExpName);

	if (!Temp) {

		return STATUS_NOT_IMPLEMENTED;
	}

	hde64s hde;

	uint8_t ThreadModRM = (uint8_t)-1;
	uint8_t ThreadRexR = (uint8_t)-1;

	do {

		hde64_disasm((PVOID)Temp, &hde);

		if (ThreadModRM == (uint8_t)-1) {

			if (hde.p_seg == PREFIX_SEGMENT_GS &&
				hde.disp.disp32 == 0x188 &&
				(hde.flags & F_MODRM)
				) {

				ThreadModRM = hde.modrm_reg;
				ThreadRexR = hde.rex_r;
			}
		}
		else if ((hde.flags & F_MODRM) && (hde.modrm & 0x7) == ThreadModRM) {

			if (!ThreadRexR &&hde.rex_w) {

				OfTrapFrame = hde.disp.disp32;
				break;
			}
			else if (ThreadRexR && hde.rex_b) {

				OfTrapFrame = hde.disp.disp32;
				break;
			}
		}

		Temp += hde.len;

	} while (
		hde.opcode != 0xC3 &&
		hde.opcode != 0xC2 &&
		hde.opcode != 0xCC
		);



	return OfTrapFrame ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
}


typedef struct _RelAsm {
	ULONG UniqueID;
	ULONG SrcRel;
	DWORD64 DstAbs;
}RelAsm;

typedef struct _LdrShell {

	RelAsm	RelCalls[0x10];
	int		RelCallCount;

	RelAsm	RelData[0x10];
	int		RelDataCount;

	RelAsm	RelJumpsOut[0x10];
	int		RelJumpOutCount;

}LdrShell, *pLdrShell;

int
RtlUniqueRef(
	RelAsm* Data,
	int DataLen
) {

	ULONG Out = 0;

	for (int i = 0; i < DataLen; i++) {

		BOOLEAN Unique = TRUE;
		int j = i - 1;

		while (j >= 0) {

			if (Data[j].DstAbs == Data[i].DstAbs) {

				Unique = FALSE;
				Data[i].UniqueID = Data[j].UniqueID;
				break;
			}
			j--;
		}

		if (Unique) {

			Out++;
			Data[i].UniqueID = Out;
		}
	}

	return Out;
}

NTSTATUS
CvcipBuildUsermodeCallShell(
	const DWORD64 KiCallUserMode
) {

	const pLdrShell pLdr = (pLdrShell)ExAllocatePoolWithTag(
		NonPagedPool,
		sizeof(LdrShell),
		MEMORY_TAG
	);

	if (!pLdr) {

		return STATUS_NO_MEMORY;
	}

	RtlZeroMemory(pLdr, sizeof(LdrShell));

	DWORD64 KeUserCallbackDispatcher = 0;
	DWORD64 KiSystemServiceExit = 0;

	hde64s hde;
	DWORD64 Temp = KiCallUserMode;

	do {

		hde64_disasm((PVOID)Temp, &hde);
		Temp += hde.len;
	} while (
		hde.opcode != 0xC3 &&
		hde.opcode != 0xC2 &&
		hde.opcode != 0xCC
		);

	const DWORD64 KiCallUserModeEnd = Temp;
	const DWORD64 FunctionLen = KiCallUserModeEnd - KiCallUserMode;

	Temp = KiCallUserMode;

	do {

		hde64_disasm((PVOID)Temp, &hde);

		if (hde.opcode == 0xE8) {

			pLdr->RelCalls[pLdr->RelCallCount].SrcRel = (ULONG)(Temp - KiCallUserMode);
			pLdr->RelCalls[pLdr->RelCallCount].DstAbs = Temp + hde.len + (int)hde.imm.imm32;

			pLdr->RelCallCount++;
		}
		else if (hde.modrm_rm == 0x5 && hde.modrm_mod == 0x0) {

			const DWORD64 Ptr = Temp + hde.len + (int)hde.disp.disp32;

			if (hde.opcode == 0x8B && (hde.flags & F_PREFIX_REX)) {

				KeUserCallbackDispatcher = Ptr;

			}
			else if (hde.opcode == 0x8D) {

				KiSystemServiceExit = Ptr;
			}

			pLdr->RelData[pLdr->RelDataCount].SrcRel = (ULONG)(Temp - KiCallUserMode);
			pLdr->RelData[pLdr->RelDataCount].DstAbs = Ptr;
			pLdr->RelDataCount++;
		}
		else if (hde.opcode == 0x0F && (hde.opcode2 >= 0x80 && hde.opcode2 <= 0x8F)) {

			const DWORD64 Ptr = Temp + hde.len + (int)hde.imm.imm32;

			if (!(Ptr > KiCallUserMode && Ptr < KiCallUserModeEnd)) {

				pLdr->RelJumpsOut[pLdr->RelJumpOutCount].SrcRel = (ULONG)(Temp - KiCallUserMode);
				pLdr->RelJumpsOut[pLdr->RelJumpOutCount].DstAbs = Ptr;
				pLdr->RelJumpOutCount++;
			}
		}
		if (pLdr->RelJumpOutCount >= 0x10 || pLdr->RelDataCount >= 0x10 || pLdr->RelCallCount >= 0x10) {

			break;
		}

		Temp += hde.len;
	} while (
		hde.opcode != 0xC3 &&
		hde.opcode != 0xC2 &&
		hde.opcode != 0xCC
		);

	if (pLdr->RelJumpOutCount >= 0x10 || pLdr->RelDataCount >= 0x10 || pLdr->RelCallCount >= 0x10) {

		DbgPrint("%s: Relative data >= 0x10, extend size\n", __FUNCTION__);
		return STATUS_UNSUCCESSFUL;
	}

	const BYTE CallRel[] = { 0xFF, 0x15, 0x00, 0x00, 0x00, 0x00 };
	const BYTE JumpRel[] = { 0xE9, 0x00, 0x00, 0x00, 0x00 };
	const BYTE LogicJumpRel[] = { 0x00, 0x00 };
	const BYTE AbsJump[] = { 0xFF, 0x25, 0x00, 0x00, 0x00, 0x00, };

	const int UniqueData = RtlUniqueRef(pLdr->RelData, pLdr->RelDataCount);
	const int UniqueCalls = RtlUniqueRef(pLdr->RelCalls, pLdr->RelCallCount);

	const DWORD64 CallStubLen = ALIGN_UP_BY(
		ALIGN_UP_BY(
			sizeof(CallRel) +
			sizeof(JumpRel),
			MEMORY_ALLOCATION_ALIGNMENT) + sizeof(DWORD64),
		MEMORY_ALLOCATION_ALIGNMENT);

	const DWORD64 JumpStubLen = ALIGN_UP_BY(
		ALIGN_UP_BY(
			sizeof(LogicJumpRel) +
			sizeof(JumpRel) +
			sizeof(AbsJump),
			MEMORY_ALLOCATION_ALIGNMENT) + sizeof(DWORD64),
		MEMORY_ALLOCATION_ALIGNMENT);

	const DWORD64 TotalLen =
		FunctionLen +
		MEMORY_ALLOCATION_ALIGNMENT +
		UniqueData * sizeof(DWORD64) +
		UniqueCalls * CallStubLen +
		pLdr->RelJumpOutCount * JumpStubLen;

	DbgPrint("%s: TotalLen = 0x%X\n", __FUNCTION__, TotalLen);

	const DWORD64 ShellPtr = (DWORD64)ExAllocatePoolWithTag(
		NonPagedPoolExecute,
		TotalLen,
		MEMORY_TAG
	);

	if (!ShellPtr) {

		ExFreePoolWithTag(pLdr, MEMORY_TAG);
		return STATUS_NO_MEMORY;
	}

	RtlSecureZeroMemory(
		(PVOID)ShellPtr,
		TotalLen
	);

	RtlCopyMemory((PVOID)ShellPtr, (PVOID)KiCallUserMode, FunctionLen);

	PVOID* DataPtr = (PVOID*)ALIGN_UP_BY(ShellPtr + FunctionLen, MEMORY_ALLOCATION_ALIGNMENT);

	/*
	relocate all data refs
	*/

	for (int i = 0; i < pLdr->RelDataCount; i++) {

		const DWORD64 TargetInstruction = ShellPtr + pLdr->RelData[i].SrcRel;

		hde64_disasm((PVOID)TargetInstruction, &hde);

		if (hde.opcode == 0xF6) {//test

			*(int*)(TargetInstruction + 0x2) = (int)((DWORD64)&DataPtr[pLdr->RelData[i].UniqueID - 1] - (TargetInstruction + 0x7));

		}
		else if (hde.opcode == 0x8D) {//lea KiSystemServiceExit

			*(char*)(TargetInstruction + 0x1) = 0x8B;//replace to mov
			*(int*)(TargetInstruction + 0x3) = (int)((DWORD64)&DataPtr[pLdr->RelData[i].UniqueID - 1] - (TargetInstruction + 0x7));
		}
		else {//mov

			if (hde.flags & F_PREFIX_REX) {

				*(int*)(TargetInstruction + 0x3) = (int)((DWORD64)&DataPtr[pLdr->RelData[i].UniqueID - 1] - (TargetInstruction + 0x7));
			}
			else {

				*(int*)(TargetInstruction + 0x2) = (int)((DWORD64)&DataPtr[pLdr->RelData[i].UniqueID - 1] - (TargetInstruction + 0x6));
			}
		}

		if (hde.opcode != 0x8D) {

			*(DWORD64*)&DataPtr[pLdr->RelData[i].UniqueID - 1] = *(DWORD64*)pLdr->RelData[i].DstAbs;

			if (pLdr->RelData[i].DstAbs == KeUserCallbackDispatcher) {

				pfnShellUmDispatcher = &DataPtr[pLdr->RelData[i].UniqueID - 1];
			}
		}
		else {

			*(DWORD64*)&DataPtr[pLdr->RelData[i].UniqueID - 1] = pLdr->RelData[i].DstAbs;
		}

	}


	const DWORD64 CallStubsPtr = ALIGN_UP_BY((DWORD64)&DataPtr[UniqueData], MEMORY_ALLOCATION_ALIGNMENT);

	/*
	call original -> jmp callstub
	...
	callstub:
	call [calle pointer]
	jmp back
	...
	dq calle pointer
	*/

	for (int i = 0; i < pLdr->RelCallCount; i++) {

		const DWORD64 StubPtr = CallStubsPtr + CallStubLen * (pLdr->RelCalls[i].UniqueID - 1);
		const DWORD64 TargetJump = ShellPtr + pLdr->RelCalls[i].SrcRel;
		const DWORD64 TargetJumpRet = TargetJump + sizeof(JumpRel);

		/*
		set rva jump to stub
		*/

		RtlCopyMemory((PVOID)TargetJump, JumpRel, sizeof(JumpRel));

		*(int*)(TargetJump + 0x1) = (int)(StubPtr - TargetJumpRet);

		/*
		call function by pointer at rva
		*/

		RtlCopyMemory((PVOID)StubPtr, CallRel, sizeof(CallRel));

		*(int*)(StubPtr + 0x2) = (int)(ALIGN_UP_BY(StubPtr + sizeof(CallRel) + sizeof(JumpRel), MEMORY_ALLOCATION_ALIGNMENT) - (StubPtr + sizeof(CallRel)));

		/*
		set absolute pointer for call
		*/

		*(DWORD64*)ALIGN_UP_BY(StubPtr + sizeof(CallRel) + sizeof(JumpRel), MEMORY_ALLOCATION_ALIGNMENT) = pLdr->RelCalls[i].DstAbs;

		RtlCopyMemory((PVOID)(StubPtr + sizeof(CallRel)), JumpRel, sizeof(JumpRel));

		/*
		jumps back to code
		*/

		*(int*)(StubPtr + sizeof(CallRel) + 0x1) = (int)(TargetJumpRet - (StubPtr + sizeof(CallRel) + sizeof(JumpRel)));
	}

	const DWORD64 RelJumpsOutPtr = ALIGN_UP_BY(CallStubsPtr + CallStubLen * (UniqueCalls - 1), MEMORY_ALLOCATION_ALIGNMENT);

	/*
	j* out original -> jmp jmpstub
	...
	jmpstub:
	j* rel8 pass
	jmp back
	pass:
	jmp qword ptr [jump pointer]
	...
	dq jump pointer
	*/

	for (int i = 0; i < pLdr->RelJumpOutCount; i++) {

		const DWORD64 StubPtr = RelJumpsOutPtr + JumpStubLen * i;
		const DWORD64 TargetJump = ShellPtr + pLdr->RelJumpsOut[i].SrcRel;
		const DWORD64 TargetJumpRet = TargetJump + sizeof(JumpRel);

		RtlCopyMemory((PVOID)StubPtr, LogicJumpRel, sizeof(LogicJumpRel));

		/*
		set opcode for rel8 logical jump form rel32 src
		*/

		*(char*)StubPtr = *(char*)(TargetJump + 0x1) - 0x10;

		/*
		set rel8 for logical jump to pass mark
		*/

		*(char*)(StubPtr + 0x1) = sizeof(JumpRel);

		/*
		write jump back if not pass
		*/

		RtlCopyMemory((PVOID)(StubPtr + sizeof(LogicJumpRel)), JumpRel, sizeof(JumpRel));

		/*
		set rel32 for jump back
		*/

		*(int*)(StubPtr + sizeof(LogicJumpRel) + 0x1) = (int)(TargetJumpRet - (StubPtr + sizeof(LogicJumpRel) + 0x5));


		RtlCopyMemory((PVOID)(StubPtr + sizeof(LogicJumpRel) + sizeof(JumpRel)), AbsJump, sizeof(AbsJump));

		/*
		set abs jump to pass address
		*/

		*(int*)(StubPtr + sizeof(LogicJumpRel) + sizeof(JumpRel) + 0x2) = (int)(
			(int)ALIGN_UP_BY(StubPtr + sizeof(LogicJumpRel) + sizeof(JumpRel) + sizeof(AbsJump), MEMORY_ALLOCATION_ALIGNMENT) -
			(StubPtr + sizeof(LogicJumpRel) + sizeof(JumpRel) + sizeof(AbsJump))
			);

		*(DWORD64*)ALIGN_UP_BY(StubPtr + sizeof(LogicJumpRel) + sizeof(JumpRel) + sizeof(AbsJump), MEMORY_ALLOCATION_ALIGNMENT) = pLdr->RelJumpsOut[i].DstAbs;

		/*
		set rva jump to stub
		*/

		RtlCopyMemory((PVOID)TargetJump, JumpRel, sizeof(JumpRel));

		*(int*)(TargetJump + 0x1) = (int)(StubPtr - TargetJumpRet);

		*(char*)(TargetJump + 0x5) = 0x90;//nop spare
	}


	ExFreePoolWithTag(pLdr, MEMORY_TAG);
	DbgPrint("%s: ShellPtr 0x%p\n", __FUNCTION__, ShellPtr);

	ShellKiCallUserMode = (KiCallUserMode_t)ShellPtr;

	return STATUS_SUCCESS;
}


NTSTATUS
CvcipSolveAllocatePagesForMdl(
	VOID
) {

	hde64s hde;

	DWORD64 Temp = (DWORD64)MmAllocatePagesForMdl;

	uint8_t ThreadModRMReg = (uint8_t)-1;
	uint8_t IdealProcModRMReg = (uint8_t)-1;
	uint8_t KiProcessorBlockModRMReg = (uint8_t)-1;
	uint8_t KiProcessorBlockRexR = (uint8_t)-1;
	uint8_t KPCRBModRMReg = (uint8_t)-1;
	uint8_t ParentNodeModRMReg = (uint8_t)-1;
	uint8_t NodeNumberModRMReg = (uint8_t)-1;


	do {

		hde64_disasm((PVOID)Temp, &hde);

		if (!OfIdealProcessor) {

			if (ThreadModRMReg == (uint8_t)-1) {

				if (hde.p_seg == PREFIX_SEGMENT_GS &&
					hde.disp.disp32 == 0x188 &&
					(hde.flags & F_MODRM)
					) {

					ThreadModRMReg = hde.modrm_reg;
				}
			}
			else if ((hde.flags & F_MODRM) && !(hde.flags & F_PREFIX_REX) && (hde.modrm & 0x7) == ThreadModRMReg) {

				OfIdealProcessor = hde.disp.disp32;
				IdealProcModRMReg = hde.modrm_reg;
			}
		}
		if (!KiProcessorBlock) {

			if (hde.modrm_rm == 0x5 && hde.modrm_mod == 0x0) {

				KiProcessorBlock = (KPCR **)(Temp + hde.len + (int)hde.disp.disp32);
				KiProcessorBlockModRMReg = hde.modrm_reg;
				KiProcessorBlockRexR = hde.rex_r;
			}
		}
		else if (KPCRBModRMReg == (uint8_t)-1) {

			if (hde.sib_base == KiProcessorBlockModRMReg && hde.sib_index == IdealProcModRMReg && hde.sib_scale == 0x3) {

				KPCRBModRMReg = hde.modrm_reg;
			}
		}
		else if (ParentNodeModRMReg == (uint8_t)-1) {

			if ((hde.modrm & 0x7) == KPCRBModRMReg) {

				OfParentNode = hde.disp.disp32;
				ParentNodeModRMReg = hde.modrm_reg;
			}
		}
		else if (NodeNumberModRMReg == (uint8_t)-1) {

			if ((hde.modrm & 0x7) == ParentNodeModRMReg) {

				OfNodeNumber = hde.disp.disp32;
				break;
			}
		}

		Temp += hde.len;

	} while (
		hde.opcode != 0xC3 &&
		hde.opcode != 0xC2 &&
		hde.opcode != 0xCC
		);

	return KiProcessorBlock && OfIdealProcessor && OfParentNode && OfNodeNumber ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
}


NTSTATUS
CvcipSolveKeUsermodeCallback(
	VOID
) {

	PAGED_CODE();

	UNICODE_STRING ExpName = RTL_CONSTANT_STRING(L"KeUserModeCallback");
	DWORD64 Temp = (DWORD64)MmGetSystemRoutineAddress(&ExpName);

	BOOLEAN ExpectMmCreateKernelStack = FALSE;
	BOOLEAN ExpectMmDeleteKernelStack = FALSE;

	DWORD64 KiCallUserMode = 0;
	if (!Temp) {

		return STATUS_NOT_IMPLEMENTED;
	}

	hde64s hde;

	do {

		hde64_disasm((PVOID)Temp, &hde);

		if (hde.opcode == 0xE8) {

			const DWORD64 Ptr = Temp + hde.len + (int)hde.imm.imm32;

			if (*(DWORD64*)Ptr == 0x4800000138EC8148) {// bytes of sub rsp, 138h + rex prefix of next instruction

				KiCallUserMode = Ptr;
			}
			else if (ExpectMmCreateKernelStack) {

				MmCreateKernelStack = (MmCreateKernelStack_t)Ptr;
				ExpectMmCreateKernelStack = FALSE;
			}
			else if (ExpectMmDeleteKernelStack) {

				MmDeleteKernelStack = (MmDeleteKernelStack_t)Ptr;
				ExpectMmDeleteKernelStack = FALSE;
			}
		}
		else if (hde.opcode == 0x33) {

			if (hde.modrm == 0xC9) {//xor ecx, ecx

				ExpectMmCreateKernelStack = TRUE;
			}
			else if (hde.modrm == 0xD2) {// xor edx, edx

				ExpectMmDeleteKernelStack = TRUE;
			}
		}

		Temp += hde.len;

	} while (
		hde.opcode != 0xC3 &&
		hde.opcode != 0xC2 &&
		hde.opcode != 0xCC
		);

	if (!KiCallUserMode) {

		DbgPrint("%s: !KiCallUserMode\n", __FUNCTION__);
		return STATUS_UNSUCCESSFUL;
	}

	if (MmCreateKernelStack && MmDeleteKernelStack) {

		if (!NT_SUCCESS(CvcipSolveAllocatePagesForMdl())) {

			DbgPrint("%s: !CvcipSolveAllocatePagesForMdl\n", __FUNCTION__);
			return STATUS_UNSUCCESSFUL;
		}
	}
	else if (MmCreateKernelStack || MmDeleteKernelStack) {

		DbgPrint("%s: MmCreateKernelStack || MmDeleteKernelStack\n", __FUNCTION__);
		return STATUS_UNSUCCESSFUL;
	}

	return CvcipBuildUsermodeCallShell(KiCallUserMode);
}

NTSTATUS
CvcInitInternals(
	VOID
) {

	PAGED_CODE();

	NTSTATUS Status = CvcipSolveTrapFrameOffset();

	if (!NT_SUCCESS(Status)) {

		DbgPrint("%s: Failed CvcipSolveTrapFrameOffset\n", __FUNCTION__);
		return Status;
	}

	Status = CvcipSolveKeUsermodeCallback();

	if (!NT_SUCCESS(Status)) {

		CvciExit();

		DbgPrint("%s: CvcipSolveKeUsermodeCallback\n",__FUNCTION__);

		return Status;
	}

	Status = CvcipFindDxgkInterface();

	if (!NT_SUCCESS(Status)) {

		CvciExit();

		DbgPrint("%s: CvcipFindDxgkInterface\n", __FUNCTION__);
		return Status;
	}

	return Status;
}

#pragma code_seg(pop)


#pragma code_seg(push)
#pragma code_seg("PAGE")

VOID
CvciHookOpenAdapter(
	PVOID pFn
) {

	gDxgkInterface->pFn[OpenAdapterIdx] = pFn;
}


VOID
CvciUnhookOpenAdapter(
	VOID
) {

	gDxgkInterface->pFn[OpenAdapterIdx] = (PVOID)pfOpenAdapter;
}

VOID
CvciExit(
	VOID
) {

	if (ShellKiCallUserMode) {

		ExFreePoolWithTag((PVOID)ShellKiCallUserMode, MEMORY_TAG);
	}
}

PVOID
CvciGetUserArgument(
	VOID
) {

	const _PKTRAP_FRAME Trap = *(_PKTRAP_FRAME*)((DWORD64)KeGetCurrentThread() + OfTrapFrame);
	return *(PVOID*)(Trap->Rbp + 0x8);
}

/*
Irql must be PASSIVE_LEVEL
All apc must be enabled
*/
NTSTATUS
CvciUsermodeCallout(
	CvcMsgTypeKe	MsgType,
	PVOID			pConnection,
	PVOID			Dispatcher,
	PVOID			InputBuffer,
	ULONG			InputLength,
	PVOID *			OutputBuffer,
	ULONG *			OutputLength
) {

	PAGED_CODE();
	NTSTATUS Status = STATUS_SUCCESS;

	*pfnShellUmDispatcher = Dispatcher;

	const _PKTRAP_FRAME Trap = *(_PKTRAP_FRAME*)((DWORD64)KeGetCurrentThread() + OfTrapFrame);
	ULONGLONG OldStack = Trap->Rsp;
	PCALLOUT_FRAME CalloutFrame = NULL;
	__try {

		ULONG Length = ALIGN_UP_BY(InputLength + sizeof(CALLOUT_FRAME), MEMORY_ALLOCATION_ALIGNMENT);

		CalloutFrame = (PCALLOUT_FRAME)(Trap->Rsp - Length);

		if (InputLength && InputBuffer) {

			RtlCopyMemory(CalloutFrame + 1, InputBuffer, InputLength);
		}
		
		CalloutFrame->MsgType = MsgType;
		CalloutFrame->Buffer = (PVOID)(CalloutFrame + 1);
		CalloutFrame->Length = InputLength;
		CalloutFrame->pConnection = pConnection;
	}
	__except (EXCEPTION_EXECUTE_HANDLER) {

		Status = GetExceptionCode();
	}

	if (!NT_SUCCESS(Status)) {

		return Status;
	}

	//__debugbreak();

	Trap->Rsp = (ULONGLONG)CalloutFrame;

	if (MmCreateKernelStack && MmDeleteKernelStack) {//win 8+ version

		const ULONG IdealProcessor = *(ULONG*)((DWORD64)KeGetCurrentThread() + OfIdealProcessor);
		const DWORD64 ParentNode = *(DWORD64*)((DWORD64)KiProcessorBlock[IdealProcessor] + OfParentNode);
		const WORD NodeNumber = *(WORD*)(ParentNode + OfNodeNumber);

		DWORD64 StackBase = (DWORD64)MmCreateKernelStack(FALSE, NodeNumber, KeGetCurrentThread());

		if (StackBase) {

			PKSTACK_CONTROL KSC = (PKSTACK_CONTROL)(StackBase - sizeof(KSTACK_CONTROL));

			KSC->StackBase = StackBase;
			KSC->StackLimit = StackBase - KERNEL_STACK_SIZE;
			KSC->PreviousStackBase = *(DWORD64*)((DWORD64)KeGetCurrentThread() + 0x38);//KernelStack
			KSC->PreviousStackLimit = *(DWORD64*)((DWORD64)KeGetCurrentThread() + 0x30);//StackLimit
			KSC->PreviousInitialStack = *(DWORD64*)((DWORD64)KeGetCurrentThread() + 0x28);//InitialStack

			Status = ShellKiCallUserMode(
				OutputBuffer,
				OutputLength,
				KSC,
				StackBase
			);

			MmDeleteKernelStack((PVOID)StackBase, FALSE);
		}
		else {

			Status = STATUS_NO_MEMORY;
		}
	}
	else {//win 7 version

		Status = ShellKiCallUserMode(
			OutputBuffer,
			OutputLength,
			0,
			0
		);
	}
	Trap->Rsp = OldStack;

	return Status;
}
#pragma code_seg(pop)

```

`callback-km/CvcSv/CvcInternal.h`:

```h
#pragma once

NTSTATUS
CvcInitInternals(
	VOID
);

VOID
CvciHookOpenAdapter(
	PVOID pFn
);

VOID
CvciUnhookOpenAdapter(
	VOID
);

VOID
CvciExit(
	VOID
);

PVOID
CvciGetUserArgument(
	VOID
);

typedef struct _CALLOUT_FRAME {
	CvcMsgTypeKe	MsgType;
	ULONG			Length;
	PVOID			Buffer;
	PVOID			pConnection;
} CALLOUT_FRAME, *PCALLOUT_FRAME;

NTSTATUS
CvciUsermodeCallout(
	CvcMsgTypeKe	MsgType,
	PVOID			pConnection,
	PVOID			Dispatcher,
	PVOID			InputBuffer,
	ULONG			InputLength,
	PVOID *			OutputBuffer,
	ULONG *			OutputLength
);

```

`callback-km/Declaration.h`:

```h
#pragma once
#include "../callback-um/CRT/Semaphore.h"

/*
Kernelmode message type that describe what subroutine should be run on usermode
*/
typedef enum _CvcMsgTypeKe
{
	CVCKE_NOP,
	CVCKE_DISPLAY,
	CVCKE_MAX,
	CVCKE_FORCE_DWORD = 0x7fffffff
}CvcMsgTypeKe, * pCvcMsgTypeKe;

/*
Usermode message type that describe what subroutine should be run on kernelmode
*/
typedef enum _CvcMsgTypeCL
{
	CVCCL_ADD_CONNECTION,
	CVCCL_HELLO_WORLD,
	CVCCL_READ,
	CVCCL_WRITE,
	CVCCL_MAX,
	CVCCL_FORCE_DWORD = 0x7fffffff
}CvcMsgTypeCL, * pCvcMsgTypeCL;

/*
User message that will be passed to kernelmode dispatcher
*/
typedef struct _CvcCLMsg {
	/*
	Pointer to variable that will recive operation status
	*/
	volatile NTSTATUS* pResultStatus;
	/*
	Event that used for synchronisation betwen kernelmode\usermode. Will be in signal state when request are complited
	*/
	HANDLE				CompliteEvent;
	/*
	Offset to user defined message
	*/
	CHAR				Data;
}CvcCLMsg, * pCvcCLMsg;

/*
Usermode structure that describe connection and being used for communication.
Created internally and should be acessed internally.
*/
typedef struct _CvcConnection {

	/*
	Thread id of master thread
	*/
	DWORD				MasterId;
	/*
	Thread id of slave thread
	*/
	DWORD				SlaveId;
	/*
	Handle to slave thread
	*/
	HANDLE				SlaveHandle;
	/*
	Double linked list that links connections
	*/
	LIST_ENTRY			CvcConnectionLinks;
	/*
	Handle to event that will be in signal state when request are exist
	*/
	HANDLE				RequestEvent;
	/*
	Semaphore that will be owned when callout in processing
	*/
	SEMAPHORE			CalloutSema;
	/*
	Status of last operation
	*/
	volatile NTSTATUS		LastStatus;
	/*
	Handle to event that will be in signal state when request are complited
	*/
	HANDLE				CompliteEvent;
	/*
	Lenght of pending message in bytes
	*/
	ULONG				PendingMsgLen;
	/*
	Pointer to pending message
	*/
	pCvcCLMsg			pMsgPending;

}CvcConnection, * pCvcConnection;

#ifndef CVCMESSAGE_COMMON
/***/#define CVCMESSAGE_COMMON sizeof(volatile NTSTATUS *) + sizeof(HANDLE)
#endif

typedef struct _ConnectionRequest {
	pCvcConnection 			Connection;
	HANDLE 				CompliteEvent;
}ConnectionRequest, * pConnectionRequest;

typedef struct _CvcNull {
	CvcMsgTypeCL			Type;
}CvcNull, * pCvcNull;

typedef struct _CvcAddConnection {
	CvcMsgTypeCL			Type;
	HANDLE				SlaveHandle;
	HANDLE				RequestEvent;
	HANDLE				CompliteEvent;
}CvcAddConnection, * pCvcAddConnection;

typedef struct _CvcHelloWorld {
	CvcMsgTypeCL			Type;
	DWORD				Magic;
}CvcHelloWorld, * pCvcHelloWorld;

typedef struct _CvcRead {
	CvcMsgTypeCL			Type;
	HANDLE				Pid;
	DWORD64				Ptr;
	ULONG				Size;
	PVOID				pOut;
}CvcRead, * pCvcRead;

typedef struct _CvcWrite {
	CvcMsgTypeCL			Type;
	HANDLE				Pid;
	DWORD64				Ptr;
	ULONG				Size;
	PVOID				pSrc;
}CvcWrite, * pCvcWrite;

```

`callback-km/Main.c`:

```c
#include "stdafx.h"
#include "CvcSv/Cvc.h"

HANDLE g_hCvcMainThread = NULL;

#pragma code_seg(push)
#pragma code_seg("PAGE")

VOID
DriverUnload(
	PDRIVER_OBJECT pDriverObject
) {

	UNREFERENCED_PARAMETER(pDriverObject);
	PAGED_CODE();

	CvcClosure = TRUE;

	KeWaitForSingleObject(
		g_hCvcMainThread,
		Executive,
		KernelMode,
		FALSE,
		NULL
	);

	ObDereferenceObject(g_hCvcMainThread);
	g_hCvcMainThread = NULL;

	DbgPrint("Driver unload\n");
}

#pragma code_seg(pop)

#pragma code_seg(push)
#pragma code_seg("INIT")

NTSTATUS
DriverEntry(
	PDRIVER_OBJECT pDriverObject,
	PUNICODE_STRING pRegistryPath
) {

	UNREFERENCED_PARAMETER(pRegistryPath);
	PAGED_CODE();
	DbgPrint("Driver load\n");

	pDriverObject->DriverUnload = &DriverUnload;

	NTSTATUS Status = CvcInitInternals();

	if (!NT_SUCCESS(Status)) {

		DbgPrint("CvcInitInternals function failed 0x%X", Status);
		return STATUS_UNSUCCESSFUL;
	}

	CvcClosure = FALSE;
	HANDLE hCvcMainThread = NULL;

	Status = PsCreateSystemThread(
		&hCvcMainThread,
		GENERIC_ALL,
		NULL,
		NULL,
		NULL,
		CvcMain,
		NULL
	);
	
	if (!NT_SUCCESS(Status)) {

		DbgPrint("Start CvcMain function failed 0x%X", Status);
		return STATUS_UNSUCCESSFUL;
	}

	Status = ObReferenceObjectByHandle(
		hCvcMainThread,
		THREAD_ALL_ACCESS,
		NULL,
		KernelMode,
		&g_hCvcMainThread,
		NULL
	);

	if (!NT_SUCCESS(Status)) {

		DbgPrint("Referencing CvcMain thread failed 0x%X", Status);
		CvcClosure = TRUE;
	}

	return STATUS_SUCCESS;
}
#pragma code_seg(pop)
```

`callback-km/Native/Native.h`:

```h
#pragma once
#include "../stdafx.h"
#include "Ut.h"
#include "Pe.h"
```

`callback-km/Native/Pe.c`:

```c
#include "Native.h"

#pragma code_seg(push)
#pragma code_seg("PAGE")

PIMAGE_NT_HEADERS RtlImageNtHeader(PVOID Base) {

	PIMAGE_NT_HEADERS NtHeaders = NULL;

	if (Base != NULL && Base != (PVOID)-1) {

		const PIMAGE_DOS_HEADER DosHeaders = (PIMAGE_DOS_HEADER)Base;

		if (DosHeaders->e_magic == IMAGE_DOS_SIGNATURE) {

			NtHeaders = RvaToVa(PIMAGE_NT_HEADERS, Base, DosHeaders->e_lfanew);

			if (NtHeaders->Signature != IMAGE_NT_SIGNATURE) {

				NtHeaders = NULL;
			}
		}
	}

	return NtHeaders;
}

PVOID LdrFindProcAdressA(const PVOID Base, const char* Name) {

	ANSI_STRING TargetName = { 0 };
	RtlInitAnsiString(&TargetName, Name);

	const PIMAGE_NT_HEADERS NtHeaders = RtlImageNtHeader(Base);

	if (!NtHeaders) {

		return NULL;
	}

	if (IMAGE_DIRECTORY_ENTRY_EXPORT >= NtHeaders->OptionalHeader.NumberOfRvaAndSizes) {

		return NULL;
	}

	const PIMAGE_DATA_DIRECTORY ExportDataDir = &NtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];

	if (!ExportDataDir->VirtualAddress || !ExportDataDir->Size) {

		return NULL;
	}

	const PIMAGE_EXPORT_DIRECTORY ExportDir = RvaToVa(PIMAGE_EXPORT_DIRECTORY, Base, ExportDataDir->VirtualAddress);

	if (!ExportDir->AddressOfNames || !ExportDir->AddressOfNameOrdinals || !ExportDir->AddressOfFunctions) {

		return NULL;
	}

	const PULONG	AddressOfFunctions = RvaToVa(PULONG, Base, ExportDir->AddressOfFunctions);
	const PULONG	AddressOfNames = RvaToVa(PULONG, Base, ExportDir->AddressOfNames);
	const PWORD		Ordinals = RvaToVa(PWORD, Base, ExportDir->AddressOfNameOrdinals);

	for (DWORD i = 0u; i < ExportDir->NumberOfNames; i++) {

		const char* ExportName = RvaToVa(const char*, Base, AddressOfNames[i]);

		ANSI_STRING Export = { 0 };
		RtlInitAnsiString(&Export, ExportName);

		
		if (RtlEqualString(&Export, &TargetName, FALSE)) {

			return RvaToVa(PVOID, Base, AddressOfFunctions[Ordinals[i]]);
		}
	}

	return NULL;
}

PIMAGE_SECTION_HEADER RtlpFindSection(const PVOID Base, const char * SectionName) {

	const PIMAGE_NT_HEADERS NtHeaders = RtlImageNtHeader(Base);

	if (!NtHeaders) {

		return NULL;
	}

	PIMAGE_SECTION_HEADER NtSection;
	NtSection = IMAGE_FIRST_SECTION(NtHeaders);

	ANSI_STRING ASection;
	RtlInitAnsiString(&ASection, SectionName);

	for (ULONG i = 0; i < NtHeaders->FileHeader.NumberOfSections; i++) {

		if (memcmp(SectionName, ASection.Buffer, ASection.Length) == 0) {

			return NtSection;
		}

		++NtSection;
	}

	return NULL;
}

BOOLEAN RtlSectionRange(const PVOID Base, const char * SectionName, PVOID * Min, PVOID * Max) {

	const PIMAGE_NT_HEADERS NtHeaders = RtlImageNtHeader(Base);

	if (!NtHeaders) {

		return FALSE;
	}
	
	PIMAGE_SECTION_HEADER NtSection;

	NtSection = IMAGE_FIRST_SECTION(NtHeaders);

	ANSI_STRING ASection;
	RtlInitAnsiString(&ASection, SectionName);

	for (ULONG i = 0; i < NtHeaders->FileHeader.NumberOfSections; i++) {

		if (memcmp(NtSection->Name, ASection.Buffer, ASection.Length) == 0) {

			if (Min) {

				*Min = RvaToVa(PVOID, Base, NtSection->VirtualAddress);
			}

			if (Max) {

				NtSection++;
				*Max = RvaToVa(PVOID, Base, NtSection->VirtualAddress);
			}
			return TRUE;
		}
		NtSection++;
	}

	return FALSE;
}

PVOID RtlpFindPatternEx(const PBYTE Start, const PBYTE End, const PBYTE Pattern, const size_t PatternLen, const BYTE WildCard) {

	PBYTE ScanPtr = (PBYTE)Start;
	size_t TempMatch = 0;

	while (ScanPtr < End - PatternLen) {

		for (TempMatch = 0; TempMatch < PatternLen; TempMatch++) {

			if (Pattern[TempMatch] != WildCard && ScanPtr[TempMatch] != Pattern[TempMatch]) {

				break;
			}
		}

		if (TempMatch == PatternLen) {

			return ScanPtr;
		}
		ScanPtr++;
	}

	return NULL;
}
#pragma code_seg(pop)
```

`callback-km/Native/Pe.h`:

```h
#pragma once
#ifndef RvaToVa
/***/#define RvaToVa(Cast,Base,Rel) ((Cast)((DWORD_PTR)(Base) + (DWORD_PTR)(Rel)))
#endif

PIMAGE_NT_HEADERS
RtlImageNtHeader(
	PVOID Base
);

PVOID
LdrFindProcAdressA(
	const PVOID Base,
	const char* Name
);

PIMAGE_SECTION_HEADER
RtlpFindSection(
	const PVOID Base,
	const char*SectionName
);

BOOLEAN
RtlSectionRange(
	const PVOID Base,
	const char*SectionName,
	PVOID * Min,
	PVOID * Max
);

PVOID
RtlpFindPatternEx(
	const PBYTE Start,
	const PBYTE End,
	const PBYTE Pattern,
	const size_t PatternLen,
	const BYTE WildCard
);

#ifndef RtlFindPatternEx
/***/#define RtlFindPatternEx(Start,End,Pattern,WildCard) RtlpFindPatternEx(Start,End,Pattern,_countof(Pattern),WildCard)
#endif
```

`callback-km/Native/Ut.c`:

```c
#include "Native.h"

#pragma code_seg(push)
#pragma code_seg("PAGE")

NTSTATUS
UtQsi(
	DWORD	SystemInformationClass,
	PVOID*	DataOut
) {

	PVOID pData = NULL;
	ULONG InfoLength = 0x8000;
	NTSTATUS Status = STATUS_SUCCESS;

	for (pData = ExAllocatePoolWithTag(NonPagedPool, InfoLength, MEMORY_TAG)
		;
		; pData = ExAllocatePoolWithTag(NonPagedPool, InfoLength, MEMORY_TAG)) {

		if (pData == NULL) {

			return STATUS_NO_MEMORY;
		}

		Status = NtQuerySystemInformation(SystemInformationClass, pData, InfoLength, NULL);

		if (Status != STATUS_INFO_LENGTH_MISMATCH) {

			break;
		}

		ExFreePoolWithTag(pData, MEMORY_TAG);
		InfoLength += 0x8000;
	}

	if (!NT_SUCCESS(Status)) {

		ExFreePoolWithTag(pData, MEMORY_TAG);
		return Status;
	}

	__try {

		*DataOut = pData;
	}
	__except (EXCEPTION_EXECUTE_HANDLER) {

		ExFreePoolWithTag(pData, MEMORY_TAG);
		return GetExceptionCode();
	}

	return STATUS_SUCCESS;
}

NTSTATUS
UtFindProcesses(
	const wchar_t *Name,
	PEPROCESS * OutPr,
	PrCmp_t ProcessCompareFunc
) {

	NTSTATUS Status = STATUS_SUCCESS;

	if (!Name) {

		return STATUS_INVALID_PARAMETER_1;
	}

	UNICODE_STRING TargetName = { 0 };
	RtlInitUnicodeString(&TargetName, Name);

	if (!TargetName.Length) {

		return STATUS_INVALID_PARAMETER_1;
	}

	if (!OutPr) {

		return STATUS_INVALID_PARAMETER_2;
	}

	*OutPr = NULL;
	PVOID pData = NULL;

	Status = UtQsi(0x5, &pData);

	if (!NT_SUCCESS(Status)) {

		return Status;
	}

	PEPROCESS TargetProcess = NULL;

	__try {

		PSYSTEM_PROCESS_INFORMATION pProcessInfo = (PSYSTEM_PROCESS_INFORMATION)pData;

		do {

			if (RtlEqualUnicodeString(&pProcessInfo->ImageName, &TargetName, TRUE)) {

				PEPROCESS TempEprocess = NULL;
				Status = PsLookupProcessByProcessId(pProcessInfo->UniqueProcessId, &TempEprocess);

				if (NT_SUCCESS(Status)) {

					if (ProcessCompareFunc) {

						if (ProcessCompareFunc(
							TempEprocess,
							pProcessInfo->Threads,
							(DWORD_PTR)pProcessInfo + pProcessInfo->NextEntryOffset)
							) {

							TargetProcess = TempEprocess;
							break;
						}
					}
					else {

						TargetProcess = TempEprocess;
						break;
					}
					ObfDereferenceObject(TempEprocess);
				}
			}

			if (!pProcessInfo->NextEntryOffset) {

				break;
			}

			pProcessInfo = (PSYSTEM_PROCESS_INFORMATION)((DWORD_PTR)pProcessInfo + pProcessInfo->NextEntryOffset);

		} while (TRUE);
	}
	__except (EXCEPTION_EXECUTE_HANDLER) {

		DbgPrint("%s:exception 0x%X\n", __FUNCTION__, GetExceptionCode());
	}

	ExFreePoolWithTag(pData, MEMORY_TAG);

	if (TargetProcess == NULL) {

		return STATUS_UNSUCCESSFUL;
	}

	*OutPr = TargetProcess;
	return STATUS_SUCCESS;
}

NTSTATUS
UtFindSystemImage(
	const char* cName,
	PVOID* ImageBase
) {

	ANSI_STRING Name;
	RtlInitAnsiString(&Name, cName);
	NTSTATUS Status = STATUS_SUCCESS;
	PRTL_PROCESS_MODULES pData = NULL;
	
	if (!Name.Length) {

		return STATUS_INVALID_PARAMETER_1;
	}

	if (!ImageBase) {

		return STATUS_INVALID_PARAMETER_2;
	}

	*ImageBase = NULL;

	Status = UtQsi(0xB, (PVOID*)&pData);

	if (!NT_SUCCESS(Status)) {

		return Status;
	}

	PVOID Output = NULL;
	for (ULONG i = 0; i < pData->NumberOfModules; i++) {

		ANSI_STRING Comperand;
		RtlInitAnsiString(&Comperand, (PCSZ)(pData->Modules[i].FullPathName + pData->Modules[i].OffsetToFileName));

		if (RtlEqualString(&Name, &Comperand, TRUE)) {

			Output = pData->Modules[i].ImageBase;
			break;
		}
	}
	
	ExFreePoolWithTag(pData, MEMORY_TAG);

	*ImageBase = Output;
	
	return Output ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
}

PVOID
UtFindNtos(
	VOID
) {

	PAGED_CODE();
	
	DWORD64 Page = (DWORD64)PAGE_ALIGN(__readmsr(0xC0000082));

	while (*(WORD*)Page != IMAGE_DOS_SIGNATURE && *(DWORD64*)(Page + 0x4E) != 0x6F72702073696854) {

		Page -= PAGE_SIZE;
	}
	
	return (PVOID)Page;
}

#pragma code_seg(pop)
```

`callback-km/Native/Ut.h`:

```h
#pragma once
typedef BOOLEAN(__fastcall*PrCmp_t)(PEPROCESS, PSYSTEM_THREAD_INFORMATION, DWORD_PTR);

NTSTATUS
UtQsi(
	DWORD	SystemInformationClass,
	PVOID*	pData
);

NTSTATUS
UtFindProcesses(
	const wchar_t *Name,
	PEPROCESS * OutPr,
	PrCmp_t ProcessCompareFunc
);

NTSTATUS
UtFindSystemImage(
	const char* cName,
	PVOID* ImageBase
);

PVOID
UtFindNtos(
	VOID
);
```

`callback-km/Nt.h`:

```h
#pragma once
typedef struct _SYSTEM_THREAD_INFORMATION
{
	LARGE_INTEGER KernelTime;
	LARGE_INTEGER UserTime;
	LARGE_INTEGER CreateTime;
	ULONG WaitTime;
	PVOID StartAddress;
	CLIENT_ID ClientId;
	KPRIORITY Priority;
	LONG BasePriority;
	ULONG ContextSwitches;
	ULONG ThreadState;
	KWAIT_REASON WaitReason;
} SYSTEM_THREAD_INFORMATION, *PSYSTEM_THREAD_INFORMATION;

typedef struct _SYSTEM_PROCESS_INFORMATION
{
	ULONG NextEntryOffset;
	ULONG NumberOfThreads;
	LARGE_INTEGER WorkingSetPrivateSize;
	ULONG HardFaultCount;
	ULONG NumberOfThreadsHighWatermark;
	ULONGLONG CycleTime;
	LARGE_INTEGER CreateTime;
	LARGE_INTEGER UserTime;
	LARGE_INTEGER KernelTime;
	UNICODE_STRING ImageName;
	KPRIORITY BasePriority;
	HANDLE UniqueProcessId;
	HANDLE InheritedFromUniqueProcessId;
	ULONG HandleCount;
	ULONG SessionId;
	ULONG_PTR UniqueProcessKey;
	SIZE_T PeakVirtualSize;
	SIZE_T VirtualSize;
	ULONG PageFaultCount;
	SIZE_T PeakWorkingSetSize;
	SIZE_T WorkingSetSize;
	SIZE_T QuotaPeakPagedPoolUsage;
	SIZE_T QuotaPagedPoolUsage;
	SIZE_T QuotaPeakNonPagedPoolUsage;
	SIZE_T QuotaNonPagedPoolUsage;
	SIZE_T PagefileUsage;
	SIZE_T PeakPagefileUsage;
	SIZE_T PrivatePageCount;
	LARGE_INTEGER ReadOperationCount;
	LARGE_INTEGER WriteOperationCount;
	LARGE_INTEGER OtherOperationCount;
	LARGE_INTEGER ReadTransferCount;
	LARGE_INTEGER WriteTransferCount;
	LARGE_INTEGER OtherTransferCount;
	SYSTEM_THREAD_INFORMATION Threads[1];
} SYSTEM_PROCESS_INFORMATION, *PSYSTEM_PROCESS_INFORMATION;

typedef struct _SYSTEM_GDI_DRIVER_INFORMATION
{
	UNICODE_STRING DriverName;
	PVOID ImageAddress;
	PVOID SectionPointer;
	PVOID EntryPoint;
	IMAGE_EXPORT_DIRECTORY *ExportSectionPointer;
	ULONG ImageLength;
}SYSTEM_GDI_DRIVER_INFORMATION,*PSYSTEM_GDI_DRIVER_INFORMATION;


typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
	HANDLE	Section;
	PVOID	MappedBase;
	PVOID	ImageBase;
	ULONG	ImageSize;
	ULONG	Flags;
	USHORT	LoadOrderIndex;
	USHORT	InitOrderIndex;
	USHORT	LoadCount;
	USHORT	OffsetToFileName;
	UCHAR	FullPathName[256];
} RTL_PROCESS_MODULE_INFORMATION, *PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES
{
	ULONG NumberOfModules;
	RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, *PRTL_PROCESS_MODULES;

struct _PEB {
	BOOLEAN InheritedAddressSpace;
	BOOLEAN ReadImageFileExecOptions;
	BOOLEAN BeingDebugged;
	BOOLEAN BitField;
	HANDLE Mutant;
	PVOID ImageBaseAddress;
};

#pragma pack(push, 1)
typedef struct __KTRAP_FRAME
{
	/* 0x0000 */ unsigned __int64 P1Home;
	/* 0x0008 */ unsigned __int64 P2Home;
	/* 0x0010 */ unsigned __int64 P3Home;
	/* 0x0018 */ unsigned __int64 P4Home;
	/* 0x0020 */ unsigned __int64 P5;
	/* 0x0028 */ char PreviousMode;
	/* 0x0029 */ unsigned char PreviousIrql;
	/* 0x002a */ unsigned char FaultIndicator;
	/* 0x002b */ unsigned char ExceptionActive;
	/* 0x002c */ unsigned long MxCsr;
	/* 0x0030 */ unsigned __int64 Rax;
	/* 0x0038 */ unsigned __int64 Rcx;
	/* 0x0040 */ unsigned __int64 Rdx;
	/* 0x0048 */ unsigned __int64 R8;
	/* 0x0050 */ unsigned __int64 R9;
	/* 0x0058 */ unsigned __int64 R10;
	/* 0x0060 */ unsigned __int64 R11;
	union
	{
		/* 0x0068 */ unsigned __int64 GsBase;
		/* 0x0068 */ unsigned __int64 GsSwap;
	}; /* size: 0x0008 */
	/* 0x0070 */ struct _M128A Xmm0;
	/* 0x0080 */ struct _M128A Xmm1;
	/* 0x0090 */ struct _M128A Xmm2;
	/* 0x00a0 */ struct _M128A Xmm3;
	/* 0x00b0 */ struct _M128A Xmm4;
	/* 0x00c0 */ struct _M128A Xmm5;
	union
	{
		/* 0x00d0 */ unsigned __int64 FaultAddress;
		/* 0x00d0 */ unsigned __int64 ContextRecord;
		/* 0x00d0 */ unsigned __int64 TimeStampCKCL;
	}; /* size: 0x0008 */
	/* 0x00d8 */ unsigned __int64 Dr0;
	/* 0x00e0 */ unsigned __int64 Dr1;
	/* 0x00e8 */ unsigned __int64 Dr2;
	/* 0x00f0 */ unsigned __int64 Dr3;
	/* 0x00f8 */ unsigned __int64 Dr6;
	/* 0x0100 */ unsigned __int64 Dr7;
	union
	{
		struct
		{
			/* 0x0108 */ unsigned __int64 DebugControl;
			/* 0x0110 */ unsigned __int64 LastBranchToRip;
			/* 0x0118 */ unsigned __int64 LastBranchFromRip;
			/* 0x0120 */ unsigned __int64 LastExceptionToRip;
			/* 0x0128 */ unsigned __int64 LastExceptionFromRip;
		}; /* size: 0x0028 */
		struct
		{
			/* 0x0108 */ unsigned __int64 LastBranchControl;
			/* 0x0110 */ unsigned long LastBranchMSR;
		}; /* size: 0x000c */
	}; /* size: 0x0028 */
	/* 0x0130 */ unsigned short SegDs;
	/* 0x0132 */ unsigned short SegEs;
	/* 0x0134 */ unsigned short SegFs;
	/* 0x0136 */ unsigned short SegGs;
	/* 0x0138 */ unsigned __int64 TrapFrame;
	/* 0x0140 */ unsigned __int64 Rbx;
	/* 0x0148 */ unsigned __int64 Rdi;
	/* 0x0150 */ unsigned __int64 Rsi;
	/* 0x0158 */ unsigned __int64 Rbp;
	union
	{
		/* 0x0160 */ unsigned __int64 ErrorCode;
		/* 0x0160 */ unsigned __int64 ExceptionFrame;
		/* 0x0160 */ unsigned __int64 TimeStampKlog;
	}; /* size: 0x0008 */
	/* 0x0168 */ unsigned __int64 Rip;
	/* 0x0170 */ unsigned short SegCs;
	/* 0x0172 */ unsigned char Fill0;
	/* 0x0173 */ unsigned char Logging;
	/* 0x0174 */ unsigned short Fill1[2];
	/* 0x0178 */ unsigned long EFlags;
	/* 0x017c */ unsigned long Fill2;
	/* 0x0180 */ unsigned __int64 Rsp;
	/* 0x0188 */ unsigned short SegSs;
	/* 0x018a */ unsigned short Fill3;
	/* 0x018c */ long CodePatchCycle;
} _KTRAP_FRAME, *_PKTRAP_FRAME; /* size: 0x0190 */
#pragma pack(pop)

typedef struct _KSTACK_CONTROL {

	DWORD64 StackBase;
	DWORD64 StackLimit;
	DWORD64 PreviousStackBase;
	DWORD64 PreviousStackLimit;
	DWORD64 Spare0;
	DWORD64 PreviousInitialStack;
}KSTACK_CONTROL,*PKSTACK_CONTROL;


DECLSPEC_ALIGN(8) typedef struct _DXGKWIN32K_INTERFACE {

	WORD	 Size;
	WORD	 Magic;
	DWORD64	 Null;
	PVOID	 pFn[0x1FE];

}DXGKWIN32K_INTERFACE, *PDXGKWIN32K_INTERFACE;

typedef NTSTATUS(NTAPI *GDI_BATCHFLUSH_ROUTINE) (VOID);

DECLSPEC_IMPORT
NTSTATUS
NTAPI
NtQuerySystemInformation(
	IN	DWORD					SystemInformationClass,
	OUT PVOID                   SystemInformation,
	IN	ULONG                   SystemInformationLength,
	OUT PULONG                  ReturnLength
);

DECLSPEC_IMPORT
NTSTATUS
NTAPI
NtSetSystemInformation(
	IN DWORD_PTR SystemInformationClass,
	IN PVOID SystemInformation,
	IN ULONG SystemInformationLength
);

DECLSPEC_IMPORT
PPEB
NTAPI
PsGetProcessPeb(
	IN PEPROCESS Process
);

DECLSPEC_IMPORT
PNT_TIB64
NTAPI
PsGetThreadTeb(
	IN PETHREAD Thread
);

DECLSPEC_IMPORT
NTSTATUS
NTAPI
MmCopyVirtualMemory(
	PEPROCESS SourceProcess,
	PVOID SourceAddress,
	PEPROCESS TargetProcess,
	PVOID TargetAddress,
	SIZE_T BufferSize,
	KPROCESSOR_MODE PreviousMode,
	PSIZE_T ReturnSize
);

typedef NTSTATUS
(NTAPI*OpenAdapter_t)(
	PVOID
	);

typedef NTSTATUS
(NTAPI*KiCallUserMode_t)(
	PVOID *Outputbuffer,
	PULONG OutputLength,
	//Added in windows 8+
	PKSTACK_CONTROL KSC,
	DWORD64 NewStackBase
	);

typedef PVOID
(NTAPI*MmCreateKernelStack_t)(
	BOOLEAN LargeStack,
	WORD NodeNumber,
	PETHREAD Thread
	);

typedef VOID
(NTAPI*MmDeleteKernelStack_t)(
	PVOID Stack,
	BOOLEAN LargeStack
	);
```

`callback-km/callback-km.inf`:

```inf
;
; callback-km.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=Sample ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=callback-km.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages

[DestinationDirs]
DefaultDestDir = 12
callback-km_Device_CoInstaller_CopyFiles = 11

; ================= Class section =====================

[ClassInstall32]
Addreg=SampleClassReg

[SampleClassReg]
HKR,,,0,%ClassName%
HKR,,Icon,,-5

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
callback-km.sys  = 1,,
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll=1 ; make sure the number matches with SourceDisksNames

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%callback-km.DeviceDesc%=callback-km_Device, Root\callback-km ; TODO: edit hw-id

[callback-km_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
callback-km.sys

;-------------- Service installation
[callback-km_Device.NT.Services]
AddService = callback-km,%SPSVCINST_ASSOCSERVICE%, callback-km_Service_Inst

; -------------- callback-km driver install sections
[callback-km_Service_Inst]
DisplayName    = %callback-km.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\callback-km.sys

;
;--- callback-km_Device Coinstaller installation ------
;

[callback-km_Device.NT.CoInstallers]
AddReg=callback-km_Device_CoInstaller_AddReg
CopyFiles=callback-km_Device_CoInstaller_CopyFiles

[callback-km_Device_CoInstaller_AddReg]
HKR,,CoInstallers32,0x00010000, "WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll,WdfCoInstaller"

[callback-km_Device_CoInstaller_CopyFiles]
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll

[callback-km_Device.NT.Wdf]
KmdfService =  callback-km, callback-km_wdfsect
[callback-km_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName="Samples" ; TODO: edit ClassName
DiskName = "callback-km Installation Disk"
callback-km.DeviceDesc = "callback-km Device"
callback-km.SVCDESC = "callback-km Service"

```

`callback-km/callback-km.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{4B4C81B1-150A-4EAE-80BD-B42EDC19D1A8}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>callback_km</RootNamespace>
    <WindowsTargetPlatformVersion>$(LatestTargetPlatformVersion)</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <Optimization>Disabled</Optimization>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <ControlFlowGuard>false</ControlFlowGuard>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <CallingConvention>FastCall</CallingConvention>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <CompileAs>CompileAsC</CompileAs>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <DisableSpecificWarnings>4201;4005;4603;4627;4986;4987;4996;%(DisableSpecificWarnings)</DisableSpecificWarnings>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>DebugFull</GenerateDebugInformation>
    </Link>
    <Link>
      <GenerateWindowsMetadata>false</GenerateWindowsMetadata>
    </Link>
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
    <Link>
      <MergeSections>_TEXT=.text;_PAGE=PAGE;</MergeSections>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="CvcSv\Cvc.h" />
    <ClInclude Include="CvcSv\CvcInternal.h" />
    <ClInclude Include="hde\hde64.h" />
    <ClInclude Include="hde\pstdint.h" />
    <ClInclude Include="hde\table64.h" />
    <ClInclude Include="Native\Native.h" />
    <ClInclude Include="Native\Pe.h" />
    <ClInclude Include="Native\Ut.h" />
    <ClInclude Include="Nt.h" />
    <ClInclude Include="stdafx.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="CvcSv\Cvc.c" />
    <ClCompile Include="CvcSv\CvcInternal.c" />
    <ClCompile Include="hde\hde64.c" />
    <ClCompile Include="Main.c" />
    <ClCompile Include="Native\Pe.c" />
    <ClCompile Include="Native\Ut.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`callback-km/callback-km.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClInclude Include="Nt.h" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="CvcSv\Cvc.h" />
    <ClInclude Include="CvcSv\CvcInternal.h" />
    <ClInclude Include="hde\hde64.h" />
    <ClInclude Include="hde\pstdint.h" />
    <ClInclude Include="hde\table64.h" />
    <ClInclude Include="Native\Native.h" />
    <ClInclude Include="Native\Pe.h" />
    <ClInclude Include="Native\Ut.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="CvcSv\Cvc.c" />
    <ClCompile Include="CvcSv\CvcInternal.c" />
    <ClCompile Include="hde\hde64.c" />
    <ClCompile Include="Native\Pe.c" />
    <ClCompile Include="Native\Ut.c" />
    <ClCompile Include="Main.c" />
  </ItemGroup>
</Project>
```

`callback-km/hde/hde64.c`:

```c
/*
 * Hacker Disassembler Engine 64 C
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 */
#include "../stdafx.h"
#include "hde64.h"
#include "table64.h"

#pragma warning(push)
#pragma warning(disable:4701)
#pragma warning(disable:4706)

#pragma code_seg(push)
#pragma code_seg("INIT")

unsigned int hde64_disasm(const void *code, hde64s *hs)
{
    uint8_t x, c = 0, *p = (uint8_t *)code, cflags, opcode, pref = 0;
    uint8_t *ht = hde64_table, m_mod, m_reg, m_rm, disp_size = 0;
    uint8_t op64 = 0;

	RtlSecureZeroMemory(hs, sizeof(hde64s));

    for (x = 16; x; x--)
        switch (c = *p++) {
            case 0xf3:
                hs->p_rep = c;
                pref |= PRE_F3;
                break;
            case 0xf2:
                hs->p_rep = c;
                pref |= PRE_F2;
                break;
            case 0xf0:
                hs->p_lock = c;
                pref |= PRE_LOCK;
                break;
            case 0x26: case 0x2e: case 0x36:
            case 0x3e: case 0x64: case 0x65:
                hs->p_seg = c;
                pref |= PRE_SEG;
                break;
            case 0x66:
                hs->p_66 = c;
                pref |= PRE_66;
                break;
            case 0x67:
                hs->p_67 = c;
                pref |= PRE_67;
                break;
            default:
                goto pref_done;
        }
  pref_done:

    hs->flags = (uint32_t)pref << 23;

    if (!pref)
        pref |= PRE_NONE;

    if ((c & 0xf0) == 0x40) {
        hs->flags |= F_PREFIX_REX;
        if ((hs->rex_w = (c & 0xf) >> 3) && (*p & 0xf8) == 0xb8)
            op64++;
        hs->rex_r = (c & 7) >> 2;
        hs->rex_x = (c & 3) >> 1;
        hs->rex_b = c & 1;
        if (((c = *p++) & 0xf0) == 0x40) {
            opcode = c;
            goto error_opcode;
        }
    }

    if ((hs->opcode = c) == 0x0f) {
        hs->opcode2 = c = *p++;
        ht += DELTA_OPCODES;
    } else if (c >= 0xa0 && c <= 0xa3) {
        op64++;
        if (pref & PRE_67)
            pref |= PRE_66;
        else
            pref &= ~PRE_66;
    }

    opcode = c;
    cflags = ht[ht[opcode / 4] + (opcode % 4)];

    if (cflags == C_ERROR) {
      error_opcode:
        hs->flags |= F_ERROR | F_ERROR_OPCODE;
        cflags = 0;
        if ((opcode & -3) == 0x24)
            cflags++;
    }

    x = 0;
    if (cflags & C_GROUP) {
        uint16_t t;
        t = *(uint16_t *)(ht + (cflags & 0x7f));
        cflags = (uint8_t)t;
        x = (uint8_t)(t >> 8);
    }

    if (hs->opcode2) {
        ht = hde64_table + DELTA_PREFIXES;
        if (ht[ht[opcode / 4] + (opcode % 4)] & pref)
            hs->flags |= F_ERROR | F_ERROR_OPCODE;
    }

    if (cflags & C_MODRM) {
        hs->flags |= F_MODRM;
        hs->modrm = c = *p++;
        hs->modrm_mod = m_mod = c >> 6;
        hs->modrm_rm = m_rm = c & 7;
        hs->modrm_reg = m_reg = (c & 0x3f) >> 3;

        if (x && ((x << m_reg) & 0x80))
            hs->flags |= F_ERROR | F_ERROR_OPCODE;

        if (!hs->opcode2 && opcode >= 0xd9 && opcode <= 0xdf) {
            uint8_t t = opcode - 0xd9;
            if (m_mod == 3) {
                ht = hde64_table + DELTA_FPU_MODRM + t*8;
                t = ht[m_reg] << m_rm;
            } else {
                ht = hde64_table + DELTA_FPU_REG;
                t = ht[t] << m_reg;
            }
            if (t & 0x80)
                hs->flags |= F_ERROR | F_ERROR_OPCODE;
        }

        if (pref & PRE_LOCK) {
            if (m_mod == 3) {
                hs->flags |= F_ERROR | F_ERROR_LOCK;
            } else {
                uint8_t *table_end, op = opcode;
                if (hs->opcode2) {
                    ht = hde64_table + DELTA_OP2_LOCK_OK;
                    table_end = ht + DELTA_OP_ONLY_MEM - DELTA_OP2_LOCK_OK;
                } else {
                    ht = hde64_table + DELTA_OP_LOCK_OK;
                    table_end = ht + DELTA_OP2_LOCK_OK - DELTA_OP_LOCK_OK;
                    op &= -2;
                }
                for (; ht != table_end; ht++)
                    if (*ht++ == op) {
                        if (!((*ht << m_reg) & 0x80))
                            goto no_lock_error;
                        else
                            break;
                    }
                hs->flags |= F_ERROR | F_ERROR_LOCK;
              no_lock_error:
                ;
            }
        }

        if (hs->opcode2) {
            switch (opcode) {
                case 0x20: case 0x22:
                    m_mod = 3;
                    if (m_reg > 4 || m_reg == 1)
                        goto error_operand;
                    else
                        goto no_error_operand;
                case 0x21: case 0x23:
                    m_mod = 3;
                    if (m_reg == 4 || m_reg == 5)
                        goto error_operand;
                    else
                        goto no_error_operand;
            }
        } else {
            switch (opcode) {
                case 0x8c:
                    if (m_reg > 5)
                        goto error_operand;
                    else
                        goto no_error_operand;
                case 0x8e:
                    if (m_reg == 1 || m_reg > 5)
                        goto error_operand;
                    else
                        goto no_error_operand;
            }
        }

        if (m_mod == 3) {
            uint8_t *table_end;
            if (hs->opcode2) {
                ht = hde64_table + DELTA_OP2_ONLY_MEM;
                table_end = ht + sizeof(hde64_table) - DELTA_OP2_ONLY_MEM;
            } else {
                ht = hde64_table + DELTA_OP_ONLY_MEM;
                table_end = ht + DELTA_OP2_ONLY_MEM - DELTA_OP_ONLY_MEM;
            }
            for (; ht != table_end; ht += 2)
                if (*ht++ == opcode) {
                    if (*ht++ & pref && !((*ht << m_reg) & 0x80))
                        goto error_operand;
                    else
                        break;
                }
            goto no_error_operand;
        } else if (hs->opcode2) {
            switch (opcode) {
                case 0x50: case 0xd7: case 0xf7:
                    if (pref & (PRE_NONE | PRE_66))
                        goto error_operand;
                    break;
                case 0xd6:
                    if (pref & (PRE_F2 | PRE_F3))
                        goto error_operand;
                    break;
                case 0xc5:
                    goto error_operand;
            }
            goto no_error_operand;
        } else
            goto no_error_operand;

      error_operand:
        hs->flags |= F_ERROR | F_ERROR_OPERAND;
      no_error_operand:

        c = *p++;
        if (m_reg <= 1) {
            if (opcode == 0xf6)
                cflags |= C_IMM8;
            else if (opcode == 0xf7)
                cflags |= C_IMM_P66;
        }

        switch (m_mod) {
            case 0:
                if (pref & PRE_67) {
                    if (m_rm == 6)
                        disp_size = 2;
                } else
                    if (m_rm == 5)
                        disp_size = 4;
                break;
            case 1:
                disp_size = 1;
                break;
            case 2:
                disp_size = 2;
                if (!(pref & PRE_67))
                    disp_size <<= 1;
        }

        if (m_mod != 3 && m_rm == 4) {
            hs->flags |= F_SIB;
            p++;
            hs->sib = c;
            hs->sib_scale = c >> 6;
            hs->sib_index = (c & 0x3f) >> 3;
            if ((hs->sib_base = c & 7) == 5 && !(m_mod & 1))
                disp_size = 4;
        }

        p--;
        switch (disp_size) {
            case 1:
                hs->flags |= F_DISP8;
                hs->disp.disp8 = *p;
                break;
            case 2:
                hs->flags |= F_DISP16;
                hs->disp.disp16 = *(uint16_t *)p;
                break;
            case 4:
                hs->flags |= F_DISP32;
                hs->disp.disp32 = *(uint32_t *)p;
        }
        p += disp_size;
    } else if (pref & PRE_LOCK)
        hs->flags |= F_ERROR | F_ERROR_LOCK;

    if (cflags & C_IMM_P66) {
        if (cflags & C_REL32) {
            if (pref & PRE_66) {
                hs->flags |= F_IMM16 | F_RELATIVE;
                hs->imm.imm16 = *(uint16_t *)p;
                p += 2;
                goto disasm_done;
            }
            goto rel32_ok;
        }
        if (op64) {
            hs->flags |= F_IMM64;
            hs->imm.imm64 = *(uint64_t *)p;
            p += 8;
        } else if (!(pref & PRE_66)) {
            hs->flags |= F_IMM32;
            hs->imm.imm32 = *(uint32_t *)p;
            p += 4;
        } else
            goto imm16_ok;
    }


    if (cflags & C_IMM16) {
      imm16_ok:
        hs->flags |= F_IMM16;
        hs->imm.imm16 = *(uint16_t *)p;
        p += 2;
    }
    if (cflags & C_IMM8) {
        hs->flags |= F_IMM8;
        hs->imm.imm8 = *p++;
    }

    if (cflags & C_REL32) {
      rel32_ok:
        hs->flags |= F_IMM32 | F_RELATIVE;
        hs->imm.imm32 = *(uint32_t *)p;
        p += 4;
    } else if (cflags & C_REL8) {
        hs->flags |= F_IMM8 | F_RELATIVE;
        hs->imm.imm8 = *p++;
    }

  disasm_done:

    if ((hs->len = (uint8_t)(p-(uint8_t *)code)) > 15) {
        hs->flags |= F_ERROR | F_ERROR_LENGTH;
        hs->len = 15;
    }

    return (unsigned int)hs->len;
}
#pragma code_seg(pop)

#pragma warning(pop)
```

`callback-km/hde/hde64.h`:

```h
/*
 * Hacker Disassembler Engine 64
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 * hde64.h: C/C++ header file
 *
 */

#ifndef _HDE64_H_
#define _HDE64_H_

/* stdint.h - C99 standard header
 * http://en.wikipedia.org/wiki/stdint.h
 *
 * if your compiler doesn't contain "stdint.h" header (for
 * example, Microsoft Visual C++), you can download file:
 *   http://www.azillionmonkeys.com/qed/pstdint.h
 * and change next line to:
 *   #include "pstdint.h"
 */
#include "pstdint.h"

#define F_MODRM         0x00000001
#define F_SIB           0x00000002
#define F_IMM8          0x00000004
#define F_IMM16         0x00000008
#define F_IMM32         0x00000010
#define F_IMM64         0x00000020
#define F_DISP8         0x00000040
#define F_DISP16        0x00000080
#define F_DISP32        0x00000100
#define F_RELATIVE      0x00000200
#define F_ERROR         0x00001000
#define F_ERROR_OPCODE  0x00002000
#define F_ERROR_LENGTH  0x00004000
#define F_ERROR_LOCK    0x00008000
#define F_ERROR_OPERAND 0x00010000
#define F_PREFIX_REPNZ  0x01000000
#define F_PREFIX_REPX   0x02000000
#define F_PREFIX_REP    0x03000000
#define F_PREFIX_66     0x04000000
#define F_PREFIX_67     0x08000000
#define F_PREFIX_LOCK   0x10000000
#define F_PREFIX_SEG    0x20000000
#define F_PREFIX_REX    0x40000000
#define F_PREFIX_ANY    0x7f000000

#define PREFIX_SEGMENT_CS   0x2e
#define PREFIX_SEGMENT_SS   0x36
#define PREFIX_SEGMENT_DS   0x3e
#define PREFIX_SEGMENT_ES   0x26
#define PREFIX_SEGMENT_FS   0x64
#define PREFIX_SEGMENT_GS   0x65
#define PREFIX_LOCK         0xf0
#define PREFIX_REPNZ        0xf2
#define PREFIX_REPX         0xf3
#define PREFIX_OPERAND_SIZE 0x66
#define PREFIX_ADDRESS_SIZE 0x67

#pragma pack(push,1)

typedef struct {
    uint8_t len;
    uint8_t p_rep;
    uint8_t p_lock;
    uint8_t p_seg;
    uint8_t p_66;
    uint8_t p_67;
    uint8_t rex;
    uint8_t rex_w;
    uint8_t rex_r;
    uint8_t rex_x;
    uint8_t rex_b;
    uint8_t opcode;
    uint8_t opcode2;
    uint8_t modrm;
    uint8_t modrm_mod;
    uint8_t modrm_reg;
    uint8_t modrm_rm;
    uint8_t sib;
    uint8_t sib_scale;
    uint8_t sib_index;
    uint8_t sib_base;
    union {
        uint8_t imm8;
        uint16_t imm16;
        uint32_t imm32;
        uint64_t imm64;
    } imm;
    union {
        uint8_t disp8;
        uint16_t disp16;
        uint32_t disp32;
    } disp;
    uint32_t flags;
} hde64s;

#pragma pack(pop)

unsigned int hde64_disasm(const void *code, hde64s *hs);

#endif /* _HDE64_H_ */
```

`callback-km/hde/pstdint.h`:

```h
/*
 *  MinHook - The Minimalistic API Hooking Library for x64/x86
 *  Copyright (C) 2009-2015 Tsuda Kageyu. All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR
 *  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 *  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#pragma once


// Integer types for HDE.
typedef __int8   int8_t;
typedef __int16  int16_t;
typedef __int32  int32_t;
typedef __int64  int64_t;
typedef unsigned __int8  uint8_t;
typedef unsigned __int16 uint16_t;
typedef unsigned __int32 uint32_t;
typedef unsigned __int64 uint64_t;
```

`callback-km/hde/table64.h`:

```h
/*
 * Hacker Disassembler Engine 64 C
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 */

#define C_NONE    0x00
#define C_MODRM   0x01
#define C_IMM8    0x02
#define C_IMM16   0x04
#define C_IMM_P66 0x10
#define C_REL8    0x20
#define C_REL32   0x40
#define C_GROUP   0x80
#define C_ERROR   0xff

#define PRE_ANY  0x00
#define PRE_NONE 0x01
#define PRE_F2   0x02
#define PRE_F3   0x04
#define PRE_66   0x08
#define PRE_67   0x10
#define PRE_LOCK 0x20
#define PRE_SEG  0x40
#define PRE_ALL  0xff

#define DELTA_OPCODES      0x4a
#define DELTA_FPU_REG      0xfd
#define DELTA_FPU_MODRM    0x104
#define DELTA_PREFIXES     0x13c
#define DELTA_OP_LOCK_OK   0x1ae
#define DELTA_OP2_LOCK_OK  0x1c6
#define DELTA_OP_ONLY_MEM  0x1d8
#define DELTA_OP2_ONLY_MEM 0x1e7

unsigned char hde64_table[] = {
  0xa5,0xaa,0xa5,0xb8,0xa5,0xaa,0xa5,0xaa,0xa5,0xb8,0xa5,0xb8,0xa5,0xb8,0xa5,
  0xb8,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xac,0xc0,0xcc,0xc0,0xa1,0xa1,
  0xa1,0xa1,0xb1,0xa5,0xa5,0xa6,0xc0,0xc0,0xd7,0xda,0xe0,0xc0,0xe4,0xc0,0xea,
  0xea,0xe0,0xe0,0x98,0xc8,0xee,0xf1,0xa5,0xd3,0xa5,0xa5,0xa1,0xea,0x9e,0xc0,
  0xc0,0xc2,0xc0,0xe6,0x03,0x7f,0x11,0x7f,0x01,0x7f,0x01,0x3f,0x01,0x01,0xab,
  0x8b,0x90,0x64,0x5b,0x5b,0x5b,0x5b,0x5b,0x92,0x5b,0x5b,0x76,0x90,0x92,0x92,
  0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x6a,0x73,0x90,
  0x5b,0x52,0x52,0x52,0x52,0x5b,0x5b,0x5b,0x5b,0x77,0x7c,0x77,0x85,0x5b,0x5b,
  0x70,0x5b,0x7a,0xaf,0x76,0x76,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,
  0x5b,0x5b,0x86,0x01,0x03,0x01,0x04,0x03,0xd5,0x03,0xd5,0x03,0xcc,0x01,0xbc,
  0x03,0xf0,0x03,0x03,0x04,0x00,0x50,0x50,0x50,0x50,0xff,0x20,0x20,0x20,0x20,
  0x01,0x01,0x01,0x01,0xc4,0x02,0x10,0xff,0xff,0xff,0x01,0x00,0x03,0x11,0xff,
  0x03,0xc4,0xc6,0xc8,0x02,0x10,0x00,0xff,0xcc,0x01,0x01,0x01,0x00,0x00,0x00,
  0x00,0x01,0x01,0x03,0x01,0xff,0xff,0xc0,0xc2,0x10,0x11,0x02,0x03,0x01,0x01,
  0x01,0xff,0xff,0xff,0x00,0x00,0x00,0xff,0x00,0x00,0xff,0xff,0xff,0xff,0x10,
  0x10,0x10,0x10,0x02,0x10,0x00,0x00,0xc6,0xc8,0x02,0x02,0x02,0x02,0x06,0x00,
  0x04,0x00,0x02,0xff,0x00,0xc0,0xc2,0x01,0x01,0x03,0x03,0x03,0xca,0x40,0x00,
  0x0a,0x00,0x04,0x00,0x00,0x00,0x00,0x7f,0x00,0x33,0x01,0x00,0x00,0x00,0x00,
  0x00,0x00,0xff,0xbf,0xff,0xff,0x00,0x00,0x00,0x00,0x07,0x00,0x00,0xff,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,
  0x00,0x00,0x00,0xbf,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7f,0x00,0x00,
  0xff,0x40,0x40,0x40,0x40,0x41,0x49,0x40,0x40,0x40,0x40,0x4c,0x42,0x40,0x40,
  0x40,0x40,0x40,0x40,0x40,0x40,0x4f,0x44,0x53,0x40,0x40,0x40,0x44,0x57,0x43,
  0x5c,0x40,0x60,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,
  0x40,0x40,0x64,0x66,0x6e,0x6b,0x40,0x40,0x6a,0x46,0x40,0x40,0x44,0x46,0x40,
  0x40,0x5b,0x44,0x40,0x40,0x00,0x00,0x00,0x00,0x06,0x06,0x06,0x06,0x01,0x06,
  0x06,0x02,0x06,0x06,0x00,0x06,0x00,0x0a,0x0a,0x00,0x00,0x00,0x02,0x07,0x07,
  0x06,0x02,0x0d,0x06,0x06,0x06,0x0e,0x05,0x05,0x02,0x02,0x00,0x00,0x04,0x04,
  0x04,0x04,0x05,0x06,0x06,0x06,0x00,0x00,0x00,0x0e,0x00,0x00,0x08,0x00,0x10,
  0x00,0x18,0x00,0x20,0x00,0x28,0x00,0x30,0x00,0x80,0x01,0x82,0x01,0x86,0x00,
  0xf6,0xcf,0xfe,0x3f,0xab,0x00,0xb0,0x00,0xb1,0x00,0xb3,0x00,0xba,0xf8,0xbb,
  0x00,0xc0,0x00,0xc1,0x00,0xc7,0xbf,0x62,0xff,0x00,0x8d,0xff,0x00,0xc4,0xff,
  0x00,0xc5,0xff,0x00,0xff,0xff,0xeb,0x01,0xff,0x0e,0x12,0x08,0x00,0x13,0x09,
  0x00,0x16,0x08,0x00,0x17,0x09,0x00,0x2b,0x09,0x00,0xae,0xff,0x07,0xb2,0xff,
  0x00,0xb4,0xff,0x00,0xb5,0xff,0x00,0xc3,0x01,0x00,0xc7,0xff,0xbf,0xe7,0x08,
  0x00,0xf0,0x02,0x00
};
```

`callback-km/stdafx.h`:

```h
#pragma once
#include <ntifs.h>
#include <ntstatus.h>
#include <minwindef.h>
#include <ntimage.h>
#include <intrin.h>
#include "Nt.h"

#pragma intrinsic(_disable)
#pragma intrinsic(_enable)

#ifndef MEMORY_TAG
/***/#define MEMORY_TAG ' cvC'
#endif
```

`callback-um/CRT/Alloc.c`:

```c
#include "CRT.h"

HANDLE ProcessHeap = NULL;

NTSTATUS InitAllocations() {

	ProcessHeap = GetProcessHeap();
	if (!ProcessHeap) {

		return NTSTATUS_FROM_WIN32(GetLastError());
	}

	return STATUS_SUCCESS;
}

__declspec(allocator,restrict) void * __cdecl malloc(size_t _Size) {
	
	return HeapAlloc(ProcessHeap, 0, _Size);
}

void __cdecl free(void * _Block) {

	if (_Block) {

		HeapFree(ProcessHeap, 0, _Block);
	}
}
```

`callback-um/CRT/Alloc.h`:

```h
#pragma once

#ifndef ALIGN_UP
/***/#define ALIGN_UP(x,n)		(((DWORD_PTR)(x) + (n - 1)) & ~(n - 1))
#endif

#ifndef ALIGN_DOWN
/***/#define ALIGN_DOWN(x,n)	(((DWORD_PTR)(x)) & ~(n - 1))
#endif

NTSTATUS InitAllocations();
```

`callback-um/CRT/CRT.c`:

```c
#include "CRT.h"
#include "Alloc.h"

NTSTATUS InitCRT() {

	return InitAllocations();
}
```

`callback-um/CRT/CRT.h`:

```h
#pragma once
#include "../stdafx.h"
#include "List.h"
#include "String.h"
#include "WString.h"
#include "Alloc.h"
#include "Semaphore.h"
#include "Sprintf.h"

NTSTATUS InitCRT();
```

`callback-um/CRT/IsCtype.c`:

```c
#include "CRT.h"

int isspace(int c) { return ((c >= 0x09 && c <= 0x0D) || (c == 0x20)); }

int isupper(int c) { return (c >= 'A' && c <= 'Z'); }

int isalpha(int c) { return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'); }

int isdigit(int c) { return (c >= '0' && c <= '9'); }

int isxdigit(int c) { return (c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'); }

int isalnum(int c) { return isalpha(c) || isdigit(c); }

int isprint(int c) { return c >= ' '; }

int toupper(int c)
{
	if (c < 'a' || c > 'z')
		return c;
	return c - 0x20;
}

int tolower(int c)
{
	if (c < 'A' || c > 'Z')
		return c;
	return c + 0x20;
}
```

`callback-um/CRT/List.h`:

```h
#pragma once
#include "CRT.h"

static FORCEINLINE
VOID
InitializeListHead(
	_Out_ PLIST_ENTRY ListHead
)

{

	ListHead->Flink = ListHead->Blink = ListHead;
	return;
}

static BOOLEAN
CFORCEINLINE
IsListEmpty(
	_In_ const LIST_ENTRY * ListHead
)

{

	return (BOOLEAN)(ListHead->Flink == ListHead);
}

static FORCEINLINE
BOOLEAN
RemoveEntryList(
	_In_ PLIST_ENTRY Entry
)

{

	PLIST_ENTRY Blink;
	PLIST_ENTRY Flink;

	Flink = Entry->Flink;
	Blink = Entry->Blink;
	Blink->Flink = Flink;
	Flink->Blink = Blink;
	return (BOOLEAN)(Flink == Blink);
}

static FORCEINLINE
PLIST_ENTRY
RemoveHeadList(
	_Inout_ PLIST_ENTRY ListHead
)

{

	PLIST_ENTRY Flink;
	PLIST_ENTRY Entry;

	Entry = ListHead->Flink;
	Flink = Entry->Flink;
	ListHead->Flink = Flink;
	Flink->Blink = ListHead;
	return Entry;
}



static FORCEINLINE
PLIST_ENTRY
RemoveTailList(
	_Inout_ PLIST_ENTRY ListHead
)

{

	PLIST_ENTRY Blink;
	PLIST_ENTRY Entry;

	Entry = ListHead->Blink;
	Blink = Entry->Blink;
	ListHead->Blink = Blink;
	Blink->Flink = ListHead;
	return Entry;
}


static FORCEINLINE
VOID
InsertTailList(
	_Inout_ PLIST_ENTRY ListHead,
	_Inout_ PLIST_ENTRY Entry
)
{

	PLIST_ENTRY Blink;

	Blink = ListHead->Blink;
	Entry->Flink = ListHead;
	Entry->Blink = Blink;
	Blink->Flink = Entry;
	ListHead->Blink = Entry;
	return;
}


static FORCEINLINE
VOID
InsertHeadList(
	_Inout_ PLIST_ENTRY ListHead,
	_Inout_ PLIST_ENTRY Entry
)
{

	PLIST_ENTRY Flink;

	Flink = ListHead->Flink;
	Entry->Flink = Flink;
	Entry->Blink = ListHead;
	Flink->Blink = Entry;
	ListHead->Flink = Entry;
	return;
}

static FORCEINLINE
VOID
AppendTailList(
	_Inout_ PLIST_ENTRY ListHead,
	_Inout_ PLIST_ENTRY ListToAppend
)
{

	PLIST_ENTRY ListEnd = ListHead->Blink;

	ListHead->Blink->Flink = ListToAppend;
	ListHead->Blink = ListToAppend->Blink;
	ListToAppend->Blink->Flink = ListHead;
	ListToAppend->Blink = ListEnd;
	return;
}
```

`callback-um/CRT/Memory.c`:

```c
#include "CRT.h"

int memcmp(const void *Buf1, const void *Buf2, size_t n) {

	if (!n) {

		return 0;
	}

	const unsigned char *Ptr1 = (const unsigned char*)Buf1;
	const unsigned char *Ptr2 = (const unsigned char*)Buf2;

	for (size_t i = 0; i < n; i++) {

		if (Ptr1[i] != Ptr2[i])
			return Ptr1[i] - Ptr2[i];
	}

	return 0;
}

void *memset(void *Dst, int Val, size_t Size) {

	__stosb((BYTE*)Dst, (BYTE)Val, Size);
	return Dst;
}

void *memcpy(void *Dst, const void *Src, size_t Size) {

	__movsb((BYTE*)Dst, (const BYTE*)Src, Size);
	return Dst;
}

void *memmove(void *Dst, const void *Src, size_t n)
{
	void *ret = Dst;
	if (Dst <= Src || (char *)Dst >= ((char *)Src + n)) {

		while (n--) {

			*(char*)Dst = *(char*)Src;
			Dst = (char*)Dst + 1;
			Src = (char*)Src + 1;
		}
	}
	else {

		Dst = (char*)Dst + n - 1;
		Src = (char*)Src + n - 1;

		while (n--) {

			*(char*)Dst = *(char*)Src;
			Dst = (char*)Dst - 1;
			Src = (char*)Src - 1;
		}
	}

	return ret;
}

EXCEPTION_DISPOSITION
__C_specific_handler(
	struct _EXCEPTION_RECORD* ExceptionRecord,
	void* EstablisherFrame,
	struct _CONTEXT* ContextRecord,
	struct _DISPATCHER_CONTEXT* DispatcherContext
) {

	typedef EXCEPTION_DISPOSITION
	(__fastcall* TdHandler)(
		struct _EXCEPTION_RECORD*,
		void*,
		struct _CONTEXT*,
		struct _DISPATCHER_CONTEXT*
		);
	static TdHandler pFn = NULL;

	while (!pFn) {

		HMODULE hNtDll = GetModuleHandleA("ntdll.dll");
		if (hNtDll) {

			pFn = (TdHandler)GetProcAddress(hNtDll, "__C_specific_handler");
		}
		_mm_pause();
	}

	return pFn(
		ExceptionRecord,
		EstablisherFrame,
		ContextRecord,
		DispatcherContext
	);
}
```

`callback-um/CRT/Semaphore.h`:

```h
#pragma once

typedef struct _SEMAPHORE
{
	volatile LONG_PTR BeingOwned;
}SEMAPHORE,*PSEMAPHORE;

static FORCEINLINE BOOLEAN TryLockSemaphore(const PSEMAPHORE Sema) {

#ifdef _M_AMD64
	return _InterlockedCompareExchange64(&Sema->BeingOwned, TRUE, FALSE) == FALSE;
#else
	return _InterlockedCompareExchange(&Sema->BeingOwned, TRUE, FALSE) == FALSE;
#endif
}

static FORCEINLINE VOID UnlockSemaphore(const PSEMAPHORE Sema) {

#ifdef _M_AMD64
	_InterlockedExchange64(&Sema->BeingOwned, FALSE);
#else
	_InterlockedExchange(&Sema->BeingOwned, FALSE);
#endif
}

static FORCEINLINE VOID LockSemaphore(const PSEMAPHORE Sema) {

	while (!TryLockSemaphore(Sema))
		_mm_pause();
}
```

`callback-um/CRT/Sprintf.c`:

```c
///////////////////////////////////////////////////////////////////////////////
// \author (c) Marco Paland (info@paland.com)
//             2014-2019, PALANDesign Hannover, Germany
//
// \license The MIT License (MIT)
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//
// \brief Tiny printf, sprintf and (v)snprintf implementation, optimized for speed on
//        embedded systems with a very limited resources. These routines are thread
//        safe and reentrant!
//        Use this instead of the bloated standard/newlib printf cause these use
//        malloc for printf (and may not be thread safe).
//
///////////////////////////////////////////////////////////////////////////////

#include <stdbool.h>
#include <stdint.h>
#include "CRT.h"

// define this globally (e.g. gcc -DPRINTF_INCLUDE_CONFIG_H ...) to include the
// printf_config.h header file
// default: undefined
#ifdef PRINTF_INCLUDE_CONFIG_H
#include "printf_config.h"
#endif


// 'ntoa' conversion buffer size, this must be big enough to hold one converted
// numeric number including padded zeros (dynamically created on stack)
// default: 32 byte
#ifndef PRINTF_NTOA_BUFFER_SIZE
#define PRINTF_NTOA_BUFFER_SIZE    32U
#endif

// 'ftoa' conversion buffer size, this must be big enough to hold one converted
// float number including padded zeros (dynamically created on stack)
// default: 32 byte
#ifndef PRINTF_FTOA_BUFFER_SIZE
#define PRINTF_FTOA_BUFFER_SIZE    32U
#endif

// support for the floating point type (%f)
// default: activated
#ifndef PRINTF_DISABLE_SUPPORT_FLOAT
#define PRINTF_SUPPORT_FLOAT
#endif

// support for exponential floating point notation (%e/%g)
// default: activated
#ifndef PRINTF_DISABLE_SUPPORT_EXPONENTIAL
#define PRINTF_SUPPORT_EXPONENTIAL
#endif

// define the default floating point precision
// default: 6 digits
#ifndef PRINTF_DEFAULT_FLOAT_PRECISION
#define PRINTF_DEFAULT_FLOAT_PRECISION  6U
#endif

// define the largest float suitable to print with %f
// default: 1e9
#ifndef PRINTF_MAX_FLOAT
#define PRINTF_MAX_FLOAT  1e9
#endif

// support for the long long types (%llu or %p)
// default: activated
#ifndef PRINTF_DISABLE_SUPPORT_LONG_LONG
#define PRINTF_SUPPORT_LONG_LONG
#endif

// support for the ptrdiff_t type (%t)
// ptrdiff_t is normally defined in <stddef.h> as long or long long type
// default: activated
#ifndef PRINTF_DISABLE_SUPPORT_PTRDIFF_T
#define PRINTF_SUPPORT_PTRDIFF_T
#endif

///////////////////////////////////////////////////////////////////////////////

// internal flag definitions
#define FLAGS_ZEROPAD   (1U <<  0U)
#define FLAGS_LEFT      (1U <<  1U)
#define FLAGS_PLUS      (1U <<  2U)
#define FLAGS_SPACE     (1U <<  3U)
#define FLAGS_HASH      (1U <<  4U)
#define FLAGS_UPPERCASE (1U <<  5U)
#define FLAGS_CHAR      (1U <<  6U)
#define FLAGS_SHORT     (1U <<  7U)
#define FLAGS_LONG      (1U <<  8U)
#define FLAGS_LONG_LONG (1U <<  9U)
#define FLAGS_PRECISION (1U << 10U)
#define FLAGS_ADAPT_EXP (1U << 11U)


// import float.h for DBL_MAX
#if defined(PRINTF_SUPPORT_FLOAT)
#include <float.h>
#endif


// output function type
typedef void(*out_fct_type)(char character, void* buffer, size_t idx, size_t maxlen);


// wrapper (used as buffer) for output function type
typedef struct {
	void(*fct)(char character, void* arg);
	void* arg;
} out_fct_wrap_type;


// internal buffer output
static inline void _out_buffer(char character, void* buffer, size_t idx, size_t maxlen)
{
	if (idx < maxlen) {
		((char*)buffer)[idx] = character;
	}
}


// internal null output
static inline void _out_null(char character, void* buffer, size_t idx, size_t maxlen)
{
	(void)character; (void)buffer; (void)idx; (void)maxlen;
}

// internal secure strlen
// \return The length of the string (excluding the terminating 0) limited by 'maxsize'
static inline unsigned int _strnlen_s(const char* str, size_t maxsize)
{
	const char* s;
	for (s = str; *s && maxsize--; ++s);
	return (unsigned int)(s - str);
}


// internal test if char is a digit (0-9)
// \return true if char is a digit
static inline bool _is_digit(char ch)
{
	return (ch >= '0') && (ch <= '9');
}


// internal ASCII string to unsigned int conversion
static unsigned int _atoi(const char** str)
{
	unsigned int i = 0U;
	while (_is_digit(**str)) {
		i = i * 10U + (unsigned int)(*((*str)++) - '0');
	}
	return i;
}


// output the specified string in reverse, taking care of any zero-padding
static size_t _out_rev(out_fct_type out, char* buffer, size_t idx, size_t maxlen, const char* buf, size_t len, unsigned int width, unsigned int flags)
{
	const size_t start_idx = idx;

	// pad spaces up to given width
	if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
		for (size_t i = len; i < width; i++) {
			out(' ', buffer, idx++, maxlen);
		}
	}

	// reverse string
	while (len) {
		out(buf[--len], buffer, idx++, maxlen);
	}

	// append pad spaces up to given width
	if (flags & FLAGS_LEFT) {
		while (idx - start_idx < width) {
			out(' ', buffer, idx++, maxlen);
		}
	}

	return idx;
}


// internal itoa format
static size_t _ntoa_format(out_fct_type out, char* buffer, size_t idx, size_t maxlen, char* buf, size_t len, bool negative, unsigned int base, unsigned int prec, unsigned int width, unsigned int flags)
{
	// pad leading zeros
	if (!(flags & FLAGS_LEFT)) {
		if (width && (flags & FLAGS_ZEROPAD) && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
			width--;
		}
		while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
			buf[len++] = '0';
		}
		while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
			buf[len++] = '0';
		}
	}

	// handle hash
	if (flags & FLAGS_HASH) {
		if (!(flags & FLAGS_PRECISION) && len && ((len == prec) || (len == width))) {
			len--;
			if (len && (base == 16U)) {
				len--;
			}
		}
		if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
			buf[len++] = 'x';
		}
		else if ((base == 16U) && (flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
			buf[len++] = 'X';
		}
		else if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
			buf[len++] = 'b';
		}
		if (len < PRINTF_NTOA_BUFFER_SIZE) {
			buf[len++] = '0';
		}
	}

	if (len < PRINTF_NTOA_BUFFER_SIZE) {
		if (negative) {
			buf[len++] = '-';
		}
		else if (flags & FLAGS_PLUS) {
			buf[len++] = '+';  // ignore the space if the '+' exists
		}
		else if (flags & FLAGS_SPACE) {
			buf[len++] = ' ';
		}
	}

	return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
}


// internal itoa for 'long' type
static size_t _ntoa_long(out_fct_type out, char* buffer, size_t idx, size_t maxlen, unsigned long value, bool negative, unsigned long base, unsigned int prec, unsigned int width, unsigned int flags)
{
	char buf[PRINTF_NTOA_BUFFER_SIZE];
	size_t len = 0U;

	// no hash for 0 values
	if (!value) {
		flags &= ~FLAGS_HASH;
	}

	// write if precision != 0 and value is != 0
	if (!(flags & FLAGS_PRECISION) || value) {
		do {
			const char digit = (char)(value % base);
			buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
			value /= base;
		} while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
	}

	return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);
}


// internal itoa for 'long long' type
#if defined(PRINTF_SUPPORT_LONG_LONG)
static size_t _ntoa_long_long(out_fct_type out, char* buffer, size_t idx, size_t maxlen, unsigned long long value, bool negative, unsigned long long base, unsigned int prec, unsigned int width, unsigned int flags)
{
	char buf[PRINTF_NTOA_BUFFER_SIZE];
	size_t len = 0U;

	// no hash for 0 values
	if (!value) {
		flags &= ~FLAGS_HASH;
	}

	// write if precision != 0 and value is != 0
	if (!(flags & FLAGS_PRECISION) || value) {
		do {
			const char digit = (char)(value % base);
			buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
			value /= base;
		} while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
	}

	return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);
}
#endif  // PRINTF_SUPPORT_LONG_LONG


#if defined(PRINTF_SUPPORT_FLOAT)

#if defined(PRINTF_SUPPORT_EXPONENTIAL)
// forward declaration so that _ftoa can switch to exp notation for values > PRINTF_MAX_FLOAT
static size_t _etoa(out_fct_type out, char* buffer, size_t idx, size_t maxlen, double value, unsigned int prec, unsigned int width, unsigned int flags);
#endif


// internal ftoa for fixed decimal floating point
static size_t _ftoa(out_fct_type out, char* buffer, size_t idx, size_t maxlen, double value, unsigned int prec, unsigned int width, unsigned int flags)
{
	char buf[PRINTF_FTOA_BUFFER_SIZE];
	size_t len = 0U;
	double diff = 0.0;

	// powers of 10
	static const double pow10[] = { 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000 };

	// test for special values
	if (value != value)
		return _out_rev(out, buffer, idx, maxlen, "nan", 3, width, flags);
	if (value < -DBL_MAX)
		return _out_rev(out, buffer, idx, maxlen, "fni-", 4, width, flags);
	if (value > DBL_MAX)
		return _out_rev(out, buffer, idx, maxlen, (flags & FLAGS_PLUS) ? "fni+" : "fni", (flags & FLAGS_PLUS) ? 4U : 3U, width, flags);

	// test for very large values
	// standard printf behavior is to print EVERY whole number digit -- which could be 100s of characters overflowing your buffers == bad
	if ((value > PRINTF_MAX_FLOAT) || (value < -PRINTF_MAX_FLOAT)) {
#if defined(PRINTF_SUPPORT_EXPONENTIAL)
		return _etoa(out, buffer, idx, maxlen, value, prec, width, flags);
#else
		return 0U;
#endif
	}

	// test for negative
	bool negative = false;
	if (value < 0) {
		negative = true;
		value = 0 - value;
	}

	// set default precision, if not set explicitly
	if (!(flags & FLAGS_PRECISION)) {
		prec = PRINTF_DEFAULT_FLOAT_PRECISION;
	}
	// limit precision to 9, cause a prec >= 10 can lead to overflow errors
	while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
		buf[len++] = '0';
		prec--;
	}

	int whole = (int)value;
	double tmp = (value - whole) * pow10[prec];
	unsigned long frac = (unsigned long)tmp;
	diff = tmp - frac;

	if (diff > 0.5) {
		++frac;
		// handle rollover, e.g. case 0.99 with prec 1 is 1.0
		if (frac >= pow10[prec]) {
			frac = 0;
			++whole;
		}
	}
	else if (diff < 0.5) {
	}
	else if ((frac == 0U) || (frac & 1U)) {
		// if halfway, round up if odd OR if last digit is 0
		++frac;
	}

	if (prec == 0U) {
		diff = value - (double)whole;
		if ((!(diff < 0.5) || (diff > 0.5)) && (whole & 1)) {
			// exactly 0.5 and ODD, then round up
			// 1.5 -> 2, but 2.5 -> 2
			++whole;
		}
	}
	else {
		unsigned int count = prec;
		// now do fractional part, as an unsigned number
		while (len < PRINTF_FTOA_BUFFER_SIZE) {
			--count;
			buf[len++] = (char)(48U + (frac % 10U));
			if (!(frac /= 10U)) {
				break;
			}
		}
		// add extra 0s
		while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
			buf[len++] = '0';
		}
		if (len < PRINTF_FTOA_BUFFER_SIZE) {
			// add decimal
			buf[len++] = '.';
		}
	}
	
	// do whole part, number is reversed
	while (len < PRINTF_FTOA_BUFFER_SIZE) {
		buf[len++] = (char)(48 + (whole % 10));
		if (!(whole /= 10)) {
			break;
		}
	}

	// pad leading zeros
	if (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD)) {
		if (width && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
			width--;
		}
		while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
			buf[len++] = '0';
		}
	}

	if (len < PRINTF_FTOA_BUFFER_SIZE) {
		if (negative) {
			buf[len++] = '-';
		}
		else if (flags & FLAGS_PLUS) {
			buf[len++] = '+';  // ignore the space if the '+' exists
		}
		else if (flags & FLAGS_SPACE) {
			buf[len++] = ' ';
		}
	}
	
	return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
}


#if defined(PRINTF_SUPPORT_EXPONENTIAL)
// internal ftoa variant for exponential floating-point type, contributed by Martijn Jasperse <m.jasperse@gmail.com>
static size_t _etoa(out_fct_type out, char* buffer, size_t idx, size_t maxlen, double value, unsigned int prec, unsigned int width, unsigned int flags)
{
	// check for NaN and special values
	if ((value != value) || (value > DBL_MAX) || (value < -DBL_MAX)) {
		return _ftoa(out, buffer, idx, maxlen, value, prec, width, flags);
	}

	// determine the sign
	const bool negative = value < 0;
	if (negative) {
		value = -value;
	}

	// default precision
	if (!(flags & FLAGS_PRECISION)) {
		prec = PRINTF_DEFAULT_FLOAT_PRECISION;
	}

	// determine the decimal exponent
	// based on the algorithm by David Gay (https://www.ampl.com/netlib/fp/dtoa.c)
	union {
		uint64_t U;
		double   F;
	} conv;

	conv.F = value;
	int exp2 = (int)((conv.U >> 52U) & 0x07FFU) - 1023;           // effectively log2
	conv.U = (conv.U & ((1ULL << 52U) - 1U)) | (1023ULL << 52U);  // drop the exponent so conv.F is now in [1,2)
	// now approximate log10 from the log2 integer part and an expansion of ln around 1.5
	int expval = (int)(0.1760912590558 + exp2 * 0.301029995663981 + (conv.F - 1.5) * 0.289529654602168);
	// now we want to compute 10^expval but we want to be sure it won't overflow
	exp2 = (int)(expval * 3.321928094887362 + 0.5);
	const double z = expval * 2.302585092994046 - exp2 * 0.6931471805599453;
	const double z2 = z * z;
	conv.U = (uint64_t)(exp2 + 1023) << 52U;
	// compute exp(z) using continued fractions, see https://en.wikipedia.org/wiki/Exponential_function#Continued_fractions_for_ex
	conv.F *= 1 + 2 * z / (2 - z + (z2 / (6 + (z2 / (10 + z2 / 14)))));
	// correct for rounding errors
	if (value < conv.F) {
		expval--;
		conv.F /= 10;
	}

	// the exponent format is "%+03d" and largest value is "307", so set aside 4-5 characters
	unsigned int minwidth = ((expval < 100) && (expval > -100)) ? 4U : 5U;

	// in "%g" mode, "prec" is the number of *significant figures* not decimals
	if (flags & FLAGS_ADAPT_EXP) {
		// do we want to fall-back to "%f" mode?
		if ((value >= 1e-4) && (value < 1e6)) {
			if ((int)prec > expval) {
				prec = (unsigned)((int)prec - expval - 1);
			}
			else {
				prec = 0;
			}
			flags |= FLAGS_PRECISION;   // make sure _ftoa respects precision
			// no characters in exponent
			minwidth = 0U;
			expval = 0;
		}
		else {
			// we use one sigfig for the whole part
			if ((prec > 0) && (flags & FLAGS_PRECISION)) {
				--prec;
			}
		}
	}

	// will everything fit?
	unsigned int fwidth = width;
	if (width > minwidth) {
		// we didn't fall-back so subtract the characters required for the exponent
		fwidth -= minwidth;
	}
	else {
		// not enough characters, so go back to default sizing
		fwidth = 0U;
	}
	if ((flags & FLAGS_LEFT) && minwidth) {
		// if we're padding on the right, DON'T pad the floating part
		fwidth = 0U;
	}

	// rescale the float value
	if (expval) {
		value /= conv.F;
	}

	// output the floating part
	const size_t start_idx = idx;
	idx = _ftoa(out, buffer, idx, maxlen, negative ? -value : value, prec, fwidth, flags & ~FLAGS_ADAPT_EXP);

	// output the exponent part
	if (minwidth) {
		// output the exponential symbol
		out((flags & FLAGS_UPPERCASE) ? 'E' : 'e', buffer, idx++, maxlen);
		// output the exponent value
		idx = _ntoa_long(out, buffer, idx, maxlen, (expval < 0) ? -expval : expval, expval < 0, 10, 0, minwidth - 1, FLAGS_ZEROPAD | FLAGS_PLUS);
		// might need to right-pad spaces
		if (flags & FLAGS_LEFT) {
			while (idx - start_idx < width) out(' ', buffer, idx++, maxlen);
		}
	}
	return idx;
}
#endif  // PRINTF_SUPPORT_EXPONENTIAL
#endif  // PRINTF_SUPPORT_FLOAT


// internal vsnprintf
static int __vsnprintf(out_fct_type out, char* buffer, const size_t maxlen, const char* format, va_list va)
{
	unsigned int flags, width, precision, n;
	size_t idx = 0U;

	if (!buffer) {
		// use null output function
		out = _out_null;
	}

	while (*format)
	{
		// format specifier?  %[flags][width][.precision][length]
		if (*format != '%') {
			// no
			out(*format, buffer, idx++, maxlen);
			format++;
			continue;
		}
		else {
			// yes, evaluate it
			format++;
		}

		// evaluate flags
		flags = 0U;
		do {
			switch (*format) {
			case '0': flags |= FLAGS_ZEROPAD; format++; n = 1U; break;
			case '-': flags |= FLAGS_LEFT;    format++; n = 1U; break;
			case '+': flags |= FLAGS_PLUS;    format++; n = 1U; break;
			case ' ': flags |= FLAGS_SPACE;   format++; n = 1U; break;
			case '#': flags |= FLAGS_HASH;    format++; n = 1U; break;
			default:                                   n = 0U; break;
			}
		} while (n);

		// evaluate width field
		width = 0U;
		if (_is_digit(*format)) {
			width = _atoi(&format);
		}
		else if (*format == '*') {
			const int w = va_arg(va, int);
			if (w < 0) {
				flags |= FLAGS_LEFT;    // reverse padding
				width = (unsigned int)-w;
			}
			else {
				width = (unsigned int)w;
			}
			format++;
		}

		// evaluate precision field
		precision = 0U;
		if (*format == '.') {
			flags |= FLAGS_PRECISION;
			format++;
			if (_is_digit(*format)) {
				precision = _atoi(&format);
			}
			else if (*format == '*') {
				const int prec = (int)va_arg(va, int);
				precision = prec > 0 ? (unsigned int)prec : 0U;
				format++;
			}
		}

		// evaluate length field
		switch (*format) {
		case 'l':
			flags |= FLAGS_LONG;
			format++;
			if (*format == 'l') {
				flags |= FLAGS_LONG_LONG;
				format++;
			}
			break;
		case 'h':
			flags |= FLAGS_SHORT;
			format++;
			if (*format == 'h') {
				flags |= FLAGS_CHAR;
				format++;
			}
			break;
#if defined(PRINTF_SUPPORT_PTRDIFF_T)
		case 't':
			flags |= (sizeof(ptrdiff_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
			format++;
			break;
#endif
		case 'j':
			flags |= (sizeof(intmax_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
			format++;
			break;
		case 'z':
			flags |= (sizeof(size_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
			format++;
			break;
		default:
			break;
		}

		// evaluate specifier
		switch (*format) {
		case 'd':
		case 'i':
		case 'u':
		case 'x':
		case 'X':
		case 'o':
		case 'b': {
			// set the base
			unsigned int base;
			if (*format == 'x' || *format == 'X') {
				base = 16U;
			}
			else if (*format == 'o') {
				base = 8U;
			}
			else if (*format == 'b') {
				base = 2U;
			}
			else {
				base = 10U;
				flags &= ~FLAGS_HASH;   // no hash for dec format
			}
			// uppercase
			if (*format == 'X') {
				flags |= FLAGS_UPPERCASE;
			}

			// no plus or space flag for u, x, X, o, b
			if ((*format != 'i') && (*format != 'd')) {
				flags &= ~(FLAGS_PLUS | FLAGS_SPACE);
			}

			// ignore '0' flag when precision is given
			if (flags & FLAGS_PRECISION) {
				flags &= ~FLAGS_ZEROPAD;
			}

			// convert the integer
			if ((*format == 'i') || (*format == 'd')) {
				// signed
				if (flags & FLAGS_LONG_LONG) {
#if defined(PRINTF_SUPPORT_LONG_LONG)
					const long long value = va_arg(va, long long);
					idx = _ntoa_long_long(out, buffer, idx, maxlen, (unsigned long long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
#endif
				}
				else if (flags & FLAGS_LONG) {
					const long value = va_arg(va, long);
					idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
				}
				else {
					const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
					idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned int)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
				}
			}
			else {
				// unsigned
				if (flags & FLAGS_LONG_LONG) {
#if defined(PRINTF_SUPPORT_LONG_LONG)
					idx = _ntoa_long_long(out, buffer, idx, maxlen, va_arg(va, unsigned long long), false, base, precision, width, flags);
#endif
				}
				else if (flags & FLAGS_LONG) {
					idx = _ntoa_long(out, buffer, idx, maxlen, va_arg(va, unsigned long), false, base, precision, width, flags);
				}
				else {
					const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
					idx = _ntoa_long(out, buffer, idx, maxlen, value, false, base, precision, width, flags);
				}
			}
			format++;
			break;
		}
#if defined(PRINTF_SUPPORT_FLOAT)
		case 'f':
		case 'F':
			if (*format == 'F') flags |= FLAGS_UPPERCASE;
			idx = _ftoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
			format++;
			break;
#if defined(PRINTF_SUPPORT_EXPONENTIAL)
		case 'e':
		case 'E':
		case 'g':
		case 'G':
			if ((*format == 'g') || (*format == 'G')) flags |= FLAGS_ADAPT_EXP;
			if ((*format == 'E') || (*format == 'G')) flags |= FLAGS_UPPERCASE;
			idx = _etoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
			format++;
			break;
#endif  // PRINTF_SUPPORT_EXPONENTIAL
#endif  // PRINTF_SUPPORT_FLOAT
		case 'c': {
			unsigned int l = 1U;
			// pre padding
			if (!(flags & FLAGS_LEFT)) {
				while (l++ < width) {
					out(' ', buffer, idx++, maxlen);
				}
			}
			// char output
			out((char)va_arg(va, int), buffer, idx++, maxlen);
			// post padding
			if (flags & FLAGS_LEFT) {
				while (l++ < width) {
					out(' ', buffer, idx++, maxlen);
				}
			}
			format++;
			break;
		}

		case 's': {
			const char* p = va_arg(va, char*);
			unsigned int l = _strnlen_s(p, precision ? precision : (size_t)-1);
			// pre padding
			if (flags & FLAGS_PRECISION) {
				l = (l < precision ? l : precision);
			}
			if (!(flags & FLAGS_LEFT)) {
				while (l++ < width) {
					out(' ', buffer, idx++, maxlen);
				}
			}
			// string output
			while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
				out(*(p++), buffer, idx++, maxlen);
			}
			// post padding
			if (flags & FLAGS_LEFT) {
				while (l++ < width) {
					out(' ', buffer, idx++, maxlen);
				}
			}
			format++;
			break;
		}

		case 'p': {
			width = sizeof(void*) * 2U;
			flags |= FLAGS_ZEROPAD | FLAGS_UPPERCASE;
#if defined(PRINTF_SUPPORT_LONG_LONG)
			const bool is_ll = sizeof(uintptr_t) == sizeof(long long);
			if (is_ll) {
				idx = _ntoa_long_long(out, buffer, idx, maxlen, (uintptr_t)va_arg(va, void*), false, 16U, precision, width, flags);
			}
			else {
#endif
				idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)((uintptr_t)va_arg(va, void*)), false, 16U, precision, width, flags);
#if defined(PRINTF_SUPPORT_LONG_LONG)
			}
#endif
			format++;
			break;
		}

		case '%':
			out('%', buffer, idx++, maxlen);
			format++;
			break;

		default:
			out(*format, buffer, idx++, maxlen);
			format++;
			break;
		}
	}

	// termination
	out((char)0, buffer, idx < maxlen ? idx : maxlen - 1U, maxlen);

	// return written chars without terminating \0
	return (int)idx;
}


///////////////////////////////////////////////////////////////////////////////


int sprintf_(char* buffer, const char* format, ...)
{
	va_list va;
	va_start(va, format);
	const int ret = __vsnprintf(_out_buffer, buffer, (size_t)-1, format, va);
	va_end(va);
	return ret;
}


int snprintf_(char* buffer, size_t count, const char* format, ...)
{
	va_list va;
	va_start(va, format);
	const int ret = __vsnprintf(_out_buffer, buffer, count, format, va);
	va_end(va);
	return ret;
}


int vsnprintf_(char* buffer, size_t count, const char* format, va_list va)
{
	return __vsnprintf(_out_buffer, buffer, count, format, va);
}
```

`callback-um/CRT/Sprintf.h`:

```h
#pragma once

#ifndef sprintf
/***/#define sprintf sprintf_
#endif
int sprintf_(char* buffer, const char* format, ...);

#ifndef snprintf
/***/#define snprintf  snprintf_
#endif
int  snprintf_(char* buffer, size_t count, const char* format, ...);

#ifndef vsnprintf
/***/#define vsnprintf vsnprintf_
#endif
int vsnprintf_(char* buffer, size_t count, const char* format, va_list va);
```

`callback-um/CRT/String.c`:

```c
#include "CRT.h"

size_t strlen(const char *Str) {

	char * S = (char*)Str;

	while (*S != 0)
		S++;

	return S - Str;
}

char *strchr(char const* Str, int Ch) {

	char * StrPtr = (char*)Str;

	while (*StrPtr) {

		if (*StrPtr == Ch)
			return StrPtr;
		StrPtr++;
	}

	return 0;
}

char* strrchr(char const* Str, int Ch) {

	char *End = (char*)(Str + strlen(Str) + 1);

	while (End != Str) {

		End--;
		if (*End == Ch)
			return End;
	}

	return 0;
}

int strcmp(const char *Str1, const char *Str2) {

	if (Str1 == Str2)
		return 0;

	while (*Str1 == *Str2 && *Str1 != 0)
		Str1++,
		Str2++;

	return (*Str1 - *Str2);
}

int strncmp(const char *s1, const char *s2, size_t n) {

	if (n == 0)
		return 0;

	const unsigned char *p1 = (const unsigned char*)s1;
	const unsigned char *p2 = (const unsigned char*)s2;

	for (size_t i = 0; i < n; i++) {

		if (!p1[i] || p1[i] != p2[i])
			return p1[i] - p2[i];
	}

	return 0;
}

char *strcpy(char *DstPtr, const char *SrcPtr) {

	char *Ptr = DstPtr;

	if (DstPtr == SrcPtr)
		return DstPtr;

	while (*SrcPtr != 0) {
		*Ptr = *SrcPtr;
		Ptr++;
		SrcPtr++;
	}

	*Ptr = '\0';

	return DstPtr;
}

char *strdup(const char *Src) {

	if (!Src)
		return 0;

	char *DstPtr = (char*)malloc(strlen(Src) + 1);
	strcpy(DstPtr, Src);

	return DstPtr;
}


char *strcat(char *Dst, const char *Src) {

	while (*Dst != 0)
		Dst++;

	while (*Src != 0) {
		*Dst = *Src;
		Dst++;
		Src++;
	}

	*Dst = 0;

	return Dst;
}

char *strstr(char const* Str, char const* Substr) {

	size_t StrLen = strlen(Str);
	size_t SubstrLen = strlen(Substr);

	if (!SubstrLen)
		return (char *)Str;

	if (StrLen < SubstrLen)
		return 0;

	for (int i = 0; i < (int)(StrLen - SubstrLen + 1); i++) {

		if (!strcmp(&Str[i], Substr))
			return (char *)(&Str[i]);
	}

	return 0;
}

VOID AsciiToLowerCaseA(const char *  Output, const char * Src) {

	char * SrcPtr = (char*)Src;
	char * OutputPtr = (char*)Output;

	while (*SrcPtr) {

		if (isupper((int)*SrcPtr)) {
			*OutputPtr = (char)tolower(*SrcPtr);
		}
		else {
			*OutputPtr = *SrcPtr;
		}
		SrcPtr++;
		OutputPtr++;
	}

	*OutputPtr = '\0';
}

VOID AsciiCharToWide(const wchar_t * Output, const char * Src) {

	char * SrcPtr = (char*)Src;
	wchar_t * OutputPtr = (wchar_t*)Output;

	while (*SrcPtr) {
		*OutputPtr = (wchar_t)*SrcPtr;

		SrcPtr++;
		OutputPtr++;
	}

	*OutputPtr = L'\0';
}

```

`callback-um/CRT/String.h`:

```h
#pragma once

size_t
strlen(
	const char *Str
);

char*
strchr(
	char const* Str,
	int Ch
);

char*
strrchr(
	char const* Str,
	int Ch
);

int
strcmp(
	const char *Str1,
	const char *Str2
);

int
strncmp(
	const char *s1,
	const char *s2,
	size_t n
);

char*
strcpy(
	char *DstPtr,
	const char *SrcPtr
);

char*
strdup(
	const char *Src
);

char*
strcat(
	char *Dst,
	const char *Src
);

char*
strstr(
	char const* Str,
	char const* Substr
);

VOID
AsciiToLowerCaseA(
	const char * Output,
	const char * Src
);

VOID
AsciiCharToWide(
	const wchar_t * Output,
	const char * Src
);

#ifndef RtlStringSizeA
/***/#define RtlStringSizeA(s) ((strlen(s) + 1) * sizeof(char))
#endif
```

`callback-um/CRT/WString.c`:

```c
#include "CRT.h"

size_t wcslen(const wchar_t *Str) {

	wchar_t * S = (wchar_t*)Str;

	while (*S != L'\0')
		S++;

	return S - Str;
}

wchar_t* wcschr(const wchar_t *Str, wchar_t Ch) {

	wchar_t * StrPtr = (wchar_t*)Str;

	while (*StrPtr) {

		if (*StrPtr == Ch)
			return StrPtr;
		StrPtr++;
	}

	return 0;
}

wchar_t* wcsrchr(const wchar_t *Str, wchar_t Ch) {

	wchar_t *End = (wchar_t*)(Str + wcslen(Str) + 1);

	while (End != Str) {

		End--;
		if (*End == Ch)
			return End;
	}

	return 0;
}

int wcscmp(const wchar_t *Str1, const wchar_t *Str2) {

	if (Str1 == Str2)
		return 0;

	while (*Str1 == *Str2 && *Str1 != 0)
		Str1++,
		Str2++;

	return (*Str1 - *Str2);
}

int wcsncmp(const wchar_t *S1, const wchar_t *S2, size_t n) {

	if (n == 0)
		return 0;

	unsigned char *			p1 = (unsigned char*)S1;
	unsigned char *			p2 = (unsigned char*)S2;

	for (size_t i = 0; i < n; i++) {

		if (!p1[i] || p1[i] != p2[i])
			return p1[i] - p2[i];
	}

	return 0;
}

wchar_t* wcscpy(wchar_t *Dst, const wchar_t *Src) {

	wchar_t *Ptr = Dst;

	if (Dst == Src)
		return Dst;

	while (*Src != 0) {
		*Ptr = *Src;
		Ptr++;
		Src++;
	}

	*Ptr = L'\0';

	return Dst;
}

wchar_t* wcsdup(const wchar_t *Src) {

	if (!Src)
		return 0;

	wchar_t *Dst = (wchar_t*)malloc((wcslen(Src) + 1) * sizeof(wchar_t));
	wcscpy(Dst, Src);
	return Dst;
}

wchar_t* wcscat(wchar_t *Dst, const wchar_t *Src) {

	while (*Dst != 0)
		Dst++;

	while (*Src != 0) {
		*Dst = *Src;
		Dst++;
		Src++;
	}

	*Dst = 0;

	return Dst;
}

wchar_t * wcsstr(const wchar_t *Str, const wchar_t *SubStr) {

	size_t StrLen = wcslen(Str);
	size_t SubstrLen = wcslen(SubStr);

	if (!SubstrLen)
		return (wchar_t *)Str;

	if (StrLen < SubstrLen)
		return 0;

	for (int i = 0; i < (int)(StrLen - SubstrLen + 1); i++) {

		if (!wcscmp(&Str[i], SubStr))
			return (wchar_t *)(&Str[i]);
	}

	return 0;
}

BOOLEAN AsciiToLowerCaseW(const wchar_t *  Output, const wchar_t * Src) {

	wchar_t * SrcPtr = (wchar_t*)Src;
	wchar_t * OutputPtr = (wchar_t*)Output;

	while (*SrcPtr) {

		if (!__isascii(*SrcPtr))
			return FALSE;

		if (isupper((CHAR)*SrcPtr)) {
			*OutputPtr = (wchar_t)tolower(*SrcPtr);
		}
		else {
			*OutputPtr = *SrcPtr;
		}

		SrcPtr++;
		OutputPtr++;
	}

	*OutputPtr = L'\0';
	return TRUE;
}

BOOLEAN AsciiWideToChar(const char * Output, const  wchar_t * Src) {

	wchar_t * SrcPtr = (wchar_t*)Src;
	char * OutputPtr = (char*)Output;

	while (*SrcPtr) {

		if (!__isascii(*SrcPtr))
			return FALSE;

		*OutputPtr = (char)*SrcPtr;

		SrcPtr++;
		OutputPtr++;
	}

	*OutputPtr = '\0';

	return TRUE;
}
```

`callback-um/CRT/WString.h`:

```h
#pragma once

size_t
wcslen(
	const wchar_t *Str
);

wchar_t*
wcschr(
	const wchar_t *Str,
	wchar_t Ch
);

wchar_t*
wcsrchr(
	const wchar_t *Str,
	wchar_t Ch
);

int
wcscmp(
	const wchar_t *Str1,
	const wchar_t *Str2
);

int
wcsncmp(
	const wchar_t *S1,
	const wchar_t *S2,
	size_t n
);

wchar_t*
wcscpy(
	wchar_t *Dst,
	const wchar_t *Src
);

wchar_t*
wcsdup(
	const wchar_t *Src
);

wchar_t*
wcscat(
	wchar_t *Dst,
	const wchar_t *Src
);

wchar_t*
wcsstr(
	const wchar_t *Str,
	const wchar_t *SubStr
);

BOOLEAN
AsciiToLowerCaseW(
	const wchar_t *  Output,
	const wchar_t * Src
);

BOOLEAN
AsciiWideToChar(
	const char * Output,
	const  wchar_t * Src
);

#ifndef RtlStringSizeW
/***/#define RtlStringSizeW(s) ((wcslen(s) + 1) * sizeof(wchar_t))
#endif
```

`callback-um/Cse/Cse.c`:

```c
#include "../stdafx.h"
#include "Cse.h"

HANDLE hCseOutput = INVALID_HANDLE_VALUE;
HANDLE hCseInput = INVALID_HANDLE_VALUE;


BOOLEAN
CsepConsoleCreated(
	VOID
) {

	return 
		hCseOutput != INVALID_HANDLE_VALUE &&
		hCseInput != INVALID_HANDLE_VALUE;
}

NTSTATUS
CseCreate(
	VOID
) {

	if (CsepConsoleCreated()) {

		return STATUS_ALREADY_COMPLETE;
	}

	if (!AllocConsole()) {

		return NTSTATUS_FROM_WIN32(GetLastError());
	}

	hCseOutput = GetStdHandle(STD_OUTPUT_HANDLE);
	hCseInput = GetStdHandle(STD_INPUT_HANDLE);

	if (!CsepConsoleCreated()) {

		return STATUS_UNSUCCESSFUL;
	}

	return STATUS_SUCCESS;
}

NTSTATUS
CseTerminate(
	VOID
) {

	hCseOutput = GetStdHandle(STD_OUTPUT_HANDLE);
	hCseInput = GetStdHandle(STD_INPUT_HANDLE);

	if (!CsepConsoleCreated()) {

		return STATUS_ALREADY_COMPLETE;
	}

	if (!FreeConsole()) {

		return NTSTATUS_FROM_WIN32(GetLastError());
	}

	hCseOutput = hCseInput = INVALID_HANDLE_VALUE;

	return STATUS_SUCCESS;
}

NTSTATUS
CseClear(
	VOID
) {

	if (!CsepConsoleCreated()) {

		return STATUS_UNSUCCESSFUL;
	}

	CONSOLE_SCREEN_BUFFER_INFO CseScreenInfo = { 0 };

	if (!GetConsoleScreenBufferInfo(hCseOutput,&CseScreenInfo)) {

		return NTSTATUS_FROM_WIN32(GetLastError());
	}

	COORD TopLeft = { 0 };
	DWORD Written = 0;

	if (!FillConsoleOutputCharacterA(
		hCseOutput,
		'\0',
		CseScreenInfo.dwSize.Y * CseScreenInfo.dwSize.X,
		TopLeft,
		&Written)) {

		return NTSTATUS_FROM_WIN32(GetLastError());
	}

	if (!SetConsoleCursorPosition(hCseOutput, TopLeft)) {
		return NTSTATUS_FROM_WIN32(GetLastError());
	}

	return STATUS_SUCCESS;
}

NTSTATUS
CseOutputA(
	const char* Text
) {

	if (hCseOutput == INVALID_HANDLE_VALUE) {

		return STATUS_INVALID_HANDLE;
	}

	if (!Text) {

		return STATUS_INVALID_PARAMETER;
	}

	DWORD ToWrite = 0;
	PVOID Buffer = NULL;

	__try {

		ToWrite = (DWORD)(strlen(Text) + 1);
		Buffer = alloca((ToWrite + 1) * sizeof(char));
		strcpy(Buffer, Text);
		strcat(Buffer, "\n");
	}
	__except (EXCEPTION_EXECUTE_HANDLER) {

		return GetExceptionCode();
	}

	DWORD CharsWritten = 0;

	if (!WriteConsoleA(hCseOutput, Buffer, ToWrite, &CharsWritten, NULL)) {

		return NTSTATUS_FROM_WIN32(GetLastError());
	}

	return STATUS_SUCCESS;
}

NTSTATUS
CseOutputW(
	const wchar_t* Text
) {

	if (hCseOutput == INVALID_HANDLE_VALUE) {

		return STATUS_INVALID_HANDLE;
	}

	if (!Text) {

		return STATUS_INVALID_PARAMETER;
	}

	DWORD ToWrite = 0;
	PVOID Buffer = NULL;

	__try {

		ToWrite = (DWORD)(wcslen(Text) + 1);
		Buffer = alloca((ToWrite + 1) * sizeof(wchar_t));
		wcscpy(Buffer, Text);
		wcscat(Buffer, L"\n");
	}
	__except (EXCEPTION_EXECUTE_HANDLER) {

		return GetExceptionCode();
	}

	DWORD CharsWritten = 0;

	if (!WriteConsoleW(hCseOutput, Buffer, ToWrite, &CharsWritten, NULL)) {

		return NTSTATUS_FROM_WIN32(GetLastError());
	}

	return STATUS_SUCCESS;
}

NTSTATUS
CseWaitInput(
	VOID
) {

	if (hCseInput == INVALID_HANDLE_VALUE) {

		return STATUS_INVALID_HANDLE;
	}

	DWORD read;
	wchar_t buff[256];
	ZeroMemory(buff, sizeof(buff));

	if (!ReadConsoleW(hCseInput, buff, sizeof(buff), &read, NULL)) {

		return NTSTATUS_FROM_WIN32(GetLastError());
	}

	return STATUS_SUCCESS;
}
```

`callback-um/Cse/Cse.h`:

```h
#pragma once
/*
 Cse - Console function prefix
*/

NTSTATUS
CseCreate(
	VOID
);

NTSTATUS
CseTerminate(
	VOID
);

NTSTATUS
CseClear(
	VOID
);

NTSTATUS
CseOutputA(
	const char* Text
);

NTSTATUS
CseOutputW(
	const wchar_t* Text
);

NTSTATUS
CseWaitInput(
	VOID
);
```

`callback-um/CvcCl/Cvc.c`:

```c
#include "../stdafx.h"
#include "Cvc.h"
#include "../Cse/Cse.h"

#pragma comment(linker, "/export:KeUserCallbackDispatcher")
#pragma comment( lib, "gdi32.lib" )
#pragma comment( lib, "ntdll.lib" )

DECLSPEC_IMPORT
NTSTATUS
NTAPI
NtCallbackReturn(
	IN PVOID                Result OPTIONAL,
	IN ULONG                ResultLength,
	IN NTSTATUS             Status
);

NTSTATUS
CvcpProcessConnect(
	PVOID Arg,
	pConnectionRequest Request
);

NTSTATUS
CvcpPostAddConnection(
	const pCvcConnection pConnectionToAdd
);

LIST_ENTRY		CvcpConnectionsList;
SEMAPHORE		CvcpConnectionWorkerSema;
pCvcConnection	CvcpUserMainConnection = NULL;

DWORD
CvcpConnectionStart(
	LPVOID Param
) {

	const pCvcConnection TargetConnection = (pCvcConnection)Param;

	if (TargetConnection != NULL) {

		WaitForSingleObject(TargetConnection->RequestEvent, INFINITE);
	}

	char buff[0x60];
	*(HDC*)buff = GetDC(NULL);

	pConnectionRequest pRequest = (pConnectionRequest)ALIGN_UP(
		alloca(sizeof(ConnectionRequest) + MEMORY_ALLOCATION_ALIGNMENT),
		MEMORY_ALLOCATION_ALIGNMENT
	);

	pRequest->Connection = TargetConnection;
	pRequest->CompliteEvent = TargetConnection ? TargetConnection->CompliteEvent : NULL;

	NTSTATUS Status = CvcpProcessConnect(
		buff,
		pRequest
	);

	ReleaseDC(NULL, *(HDC*)buff);

	return Status;
}

NTSTATUS CvcpDispatcher(
	const CvcMsgTypeKe Msg,
	const PVOID Data,
	const ULONG DataLen,
	const pCvcConnection pConnection
) {

	const pCvcConnection TargetConnection = pConnection == NULL
		? CvcpUserMainConnection
		: pConnection;

	if (Msg == CVCKE_DISPLAY) {

		char* Buffer = alloca(DataLen);
		sprintf(Buffer, Data);
		CseOutputA(Buffer);

		return NtCallbackReturn(NULL, 0, STATUS_SUCCESS);
	}

	WaitForSingleObject(TargetConnection->RequestEvent, INFINITE);

	if (!TargetConnection->pMsgPending) {

		return NtCallbackReturn(NULL, 0, STATUS_INVALID_MESSAGE);
	}

	return NtCallbackReturn(TargetConnection->pMsgPending, TargetConnection->PendingMsgLen, STATUS_SUCCESS);
}

NTSTATUS
CvcpCreateConnection(
	pCvcConnection* ppConnection
) {

	if (!ppConnection) {

		return STATUS_INVALID_PARAMETER;
	}

	const pCvcConnection pConnection = (pCvcConnection)malloc(sizeof(CvcConnection));

	if (!pConnection) {

		return STATUS_NO_MEMORY;
	}

	ZeroMemory(pConnection, sizeof(CvcConnection));

	pConnection->MasterId = GetCurrentThreadId();

	if (!(pConnection->RequestEvent = CreateEventA(NULL, FALSE, FALSE, NULL))) {

		goto FailStub;
	}

	if (!(pConnection->CompliteEvent = CreateEventA(NULL, FALSE, FALSE, NULL))) {

		goto FailStub;
	}

	const BOOLEAN SecondaryConnection = ppConnection != &CvcpUserMainConnection;

	pConnection->SlaveHandle = CreateThread(NULL, 0, CvcpConnectionStart, SecondaryConnection ? (LPVOID)pConnection : NULL, 0, &pConnection->SlaveId);

	if (!pConnection->SlaveHandle) {

		goto FailStub;
	}

	LockSemaphore(&CvcpConnectionWorkerSema);

	InsertTailList(&CvcpConnectionsList, &pConnection->CvcConnectionLinks);

	if (SecondaryConnection) {

		if (!CvcpUserMainConnection) {

			SetLastError(ERROR_CONNECTION_INVALID);
			UnlockSemaphore(&CvcpConnectionWorkerSema);

			goto FailStub;
		}

		if (!NT_SUCCESS(CvcpPostAddConnection(pConnection))) {

			SetLastError(ERROR_CONNECTION_ABORTED);
			UnlockSemaphore(&CvcpConnectionWorkerSema);
			goto FailStub;
		}
	}

	UnlockSemaphore(&CvcpConnectionWorkerSema);

	*ppConnection = pConnection;

	return STATUS_SUCCESS;

FailStub:;

	if (pConnection->RequestEvent) {

		CloseHandle(pConnection->RequestEvent);
	}

	if (pConnection->CompliteEvent) {

		CloseHandle(pConnection->CompliteEvent);
	}

	if (pConnection->SlaveHandle) {

		TerminateThread(pConnection->SlaveHandle, 0);
		CloseHandle(pConnection->SlaveHandle);
	}

	free(pConnection);

	return NTSTATUS_FROM_WIN32(GetLastError());
}

VOID
CvcpCloseConnection(
	const pCvcConnection pConnection
) {

	if (!pConnection) {

		return;
	}

	LockSemaphore(&CvcpConnectionWorkerSema);

	TerminateThread(pConnection->SlaveHandle, 0);
	CloseHandle(pConnection->SlaveHandle);
	CloseHandle(pConnection->RequestEvent);
	CloseHandle(pConnection->CompliteEvent);
	RemoveEntryList(&pConnection->CvcConnectionLinks);
	free(pConnection);

	UnlockSemaphore(&CvcpConnectionWorkerSema);
}

DWORD
CvcpThreadStart(
	LPVOID Param
) {

	NTSTATUS Status = STATUS_SUCCESS;
	pCvcConnection Connection = NULL;

	Status = CvcpCreateConnection(&Connection);

	if (!NT_SUCCESS(Status)) {

		return Status;
	}

	__try {

		__try {

			Status = ((CvcThreadStart_t)Param)(Connection);
		}
		__finally {

			CvcpCloseConnection(Connection);
		}
	}
	__except (EXCEPTION_EXECUTE_HANDLER) {

		Status = GetExceptionCode();
	}

	return Status;
}

NTSTATUS
CvcCreate(
	VOID
) {

	if (CvcpUserMainConnection) {

		return STATUS_ALREADY_COMPLETE;
	}

	InitializeListHead(&CvcpConnectionsList);
	return CvcpCreateConnection(&CvcpUserMainConnection);
}

VOID
CvcTerminate(
	VOID
) {

	if (CvcpUserMainConnection) {

		CvcpCloseConnection(CvcpUserMainConnection);
		CvcpUserMainConnection = NULL;
	}
}

VOID
CvcWaitConnections(
	VOID
) {

	while (TRUE) {

		Sleep(0x1000);

		LockSemaphore(&CvcpConnectionWorkerSema);

		if (!CvcpUserMainConnection || CvcpConnectionsList.Blink == &CvcpUserMainConnection->CvcConnectionLinks) {

			UnlockSemaphore(&CvcpConnectionWorkerSema);
			break;
		}

		UnlockSemaphore(&CvcpConnectionWorkerSema);
	}
}

BOOLEAN
CvcConnectionActive(
	const pCvcConnection pConnection
) {

	const pCvcConnection TargetConnection = pConnection == NULL
		? CvcpUserMainConnection
		: pConnection;

	BOOLEAN ConnectionActive;

	LockSemaphore(&TargetConnection->CalloutSema);

	ConnectionActive = TargetConnection->LastStatus != STATUS_CONNECTION_DISCONNECTED;

	UnlockSemaphore(&TargetConnection->CalloutSema);

	return ConnectionActive;
}

NTSTATUS
CvcSpawnThread(
	const CvcThreadStart_t ThreadStart
) {

	HANDLE Master = CreateThread(NULL, 0, CvcpThreadStart, (LPVOID)ThreadStart, 0, NULL);

	if (!Master) {

		return NTSTATUS_FROM_WIN32(GetLastError());
	}

	CloseHandle(Master);

	return STATUS_SUCCESS;
}

NTSTATUS
CvcPostEx(
	const PVOID pData,
	const ULONG DataLen,
	const pCvcConnection pConnection
) {

	const pCvcConnection TargetConnection = pConnection == NULL
		? CvcpUserMainConnection
		: pConnection;

	if (!TargetConnection) {

		return STATUS_CONNECTION_INVALID;
	}

	LockSemaphore(&TargetConnection->CalloutSema);

	if (TargetConnection->LastStatus == STATUS_CONNECTION_DISCONNECTED) {

		UnlockSemaphore(&TargetConnection->CalloutSema);
		return STATUS_CONNECTION_DISCONNECTED;
	}

	const ULONG MessageSize =
		CVCMESSAGE_COMMON +
		DataLen;

	TargetConnection->PendingMsgLen = MessageSize;

	TargetConnection->pMsgPending = (pCvcCLMsg)ALIGN_UP(
		alloca(MessageSize + MEMORY_ALLOCATION_ALIGNMENT),
		MEMORY_ALLOCATION_ALIGNMENT
	);

	ZeroMemory(TargetConnection->pMsgPending, MessageSize);
	TargetConnection->pMsgPending->pResultStatus = &TargetConnection->LastStatus;
	TargetConnection->pMsgPending->CompliteEvent = TargetConnection->CompliteEvent;
	memcpy(&TargetConnection->pMsgPending->Data, pData, DataLen);

	SetEvent(TargetConnection->RequestEvent);

	DWORD ExitCode = 0;

	while (GetExitCodeThread(TargetConnection->SlaveHandle, &ExitCode) && ExitCode == STILL_ACTIVE) {

		if (WaitForSingleObject(TargetConnection->CompliteEvent, 0x1000) == WAIT_OBJECT_0) {

			break;
		}
	}

	NTSTATUS Status;

	if (ExitCode == STILL_ACTIVE) {

		Status = TargetConnection->LastStatus;
	}
	else {

		Status = TargetConnection->LastStatus = STATUS_CONNECTION_DISCONNECTED;
	}

	TargetConnection->pMsgPending = NULL;

	UnlockSemaphore(&TargetConnection->CalloutSema);

	return Status;
}

NTSTATUS
CvcpPostAddConnection(
	const pCvcConnection pConnectionToAdd
) {

	CvcAddConnection AddConnection;
	AddConnection.Type = CVCCL_ADD_CONNECTION;
	AddConnection.SlaveHandle = pConnectionToAdd->SlaveHandle;
	AddConnection.RequestEvent = pConnectionToAdd->RequestEvent;
	AddConnection.CompliteEvent = pConnectionToAdd->CompliteEvent;

	return CvcPostEx(&AddConnection, sizeof(AddConnection), NULL);
}

NTSTATUS
CvcPostHelloWorld(
	const pCvcConnection pCurrentConnection
) {

	CvcHelloWorld HelloWorld;
	HelloWorld.Type = CVCCL_HELLO_WORLD;
	HelloWorld.Magic = ' cvC';

	return CvcPostEx(&HelloWorld, sizeof(HelloWorld), pCurrentConnection);
}

NTSTATUS
CvcPostRead(
	const pCvcConnection pCurrentConnection,
	const HANDLE Pid,
	const DWORD64 Ptr,
	const ULONG Size,
	const PVOID pOut
) {

	CvcRead Read;
	Read.Type = CVCCL_READ;
	Read.Pid = Pid;
	Read.Ptr = Ptr;
	Read.Size = Size;
	Read.pOut = pOut;

	return CvcPostEx(&Read, sizeof(Read), pCurrentConnection);
}


NTSTATUS
CvcPostWrite(
	const pCvcConnection pCurrentConnection,
	const HANDLE Pid,
	const DWORD64 Ptr,
	const ULONG Size,
	const PVOID pSrc
) {

	CvcWrite Write;
	Write.Type = CVCCL_WRITE;
	Write.Pid = Pid;
	Write.Ptr = Ptr;
	Write.Size = Size;
	Write.pSrc = pSrc;

	return CvcPostEx(&Write, sizeof(Write), pCurrentConnection);
}

```

`callback-um/CvcCl/Cvc.h`:

```h
#pragma once
#include "../Declaration.h"
/*
Cvc - Communication via callback function prefix
*/

typedef NTSTATUS
(__fastcall* CvcThreadStart_t)
(const pCvcConnection pConnection);

NTSTATUS
CvcCreate(
	VOID
);

VOID
CvcTerminate(
	VOID
);

VOID
CvcWaitConnections(
	VOID
);

BOOLEAN
CvcConnectionActive(
	const pCvcConnection Connection
);

NTSTATUS
CvcSpawnThread(
	const CvcThreadStart_t ThreadStart
);

NTSTATUS
CvcPostEx(
	const PVOID pData,
	const ULONG DataLen,
	const pCvcConnection pConnection
);

NTSTATUS
CvcPostHelloWorld(
	const pCvcConnection CurrentConnection
);

NTSTATUS
CvcPostRead(
	const pCvcConnection pCurrentConnection,
	const HANDLE Pid,
	const DWORD64 Ptr,
	const ULONG Size,
	const PVOID pOut
);

NTSTATUS
CvcPostWrite(
	const pCvcConnection pCurrentConnection,
	const HANDLE Pid,
	const DWORD64 Ptr,
	const ULONG Size,
	const PVOID pSrc
);

```

`callback-um/CvcCl/Dispatcher.asm`:

```asm
EXTERN NtCallbackReturn		: proc
EXTERN CvcpDispatcher		: proc
EXTERN D3DKMTOpenAdapterFromHdc : proc

Cvc	struct
	Msg		dd ?
	DataLen		dd ?
	Data		dq ?
	pConnection	dq ?
Cvc	ends

_TEXT SEGMENT

PUBLIC KeUserCallbackDispatcher
KeUserCallbackDispatcher PROC
		;int 3
		mov	ecx, Cvc.Msg[rsp]			; 
		mov	rdx, Cvc.Data[rsp]			;
		mov	r8d, Cvc.DataLen[rsp]			;
		mov	r9, Cvc.pConnection[rsp]		;
		call	CvcpDispatcher
		xor	rcx, rcx				; Result
		xor	rdx, rdx				; ResultLength
		mov	r8d, eax				; Status
		call	NtCallbackReturn
		ret

KeUserCallbackDispatcher ENDP

PUBLIC CvcpProcessConnect
CvcpProcessConnect PROC

		sub	rsp, 60h				; allocate shadow space
		push	rbp					; save previous stack base pointer
		;
		; set stack base pointer. Will be used in kernelmode routine
		; to get user argument. rbp will be saved on stack in KiSystemCall64.
		;
		mov	rbp, rsp				
		mov	[rbp+8h], rdx				; save second argument
		call	D3DKMTOpenAdapterFromHdc
		pop	rbp					; restore previous stack base pointer
		add	rsp, 60h				; deallocate
		ret

CvcpProcessConnect ENDP

end

```

`callback-um/Declaration.h`:

```h
#pragma once
#include "../callback-um/CRT/Semaphore.h"

/*
Kernelmode message type that describe what subroutine should be run on usermode
*/
typedef enum _CvcMsgTypeKe
{
	CVCKE_NOP,
	CVCKE_DISPLAY,
	CVCKE_MAX,
	CVCKE_FORCE_DWORD = 0x7fffffff
}CvcMsgTypeKe, * pCvcMsgTypeKe;

/*
Usermode message type that describe what subroutine should be run on kernelmode
*/
typedef enum _CvcMsgTypeCL
{
	CVCCL_ADD_CONNECTION,
	CVCCL_HELLO_WORLD,
	CVCCL_READ,
	CVCCL_WRITE,
	CVCCL_MAX,
	CVCCL_FORCE_DWORD = 0x7fffffff
}CvcMsgTypeCL, * pCvcMsgTypeCL;

/*
User message that will be passed to kernelmode dispatcher
*/
typedef struct _CvcCLMsg {
	/*
	Pointer to variable that will recive operation status
	*/
	volatile NTSTATUS* pResultStatus;
	/*
	Event that used for synchronisation betwen kernelmode\usermode. Will be in signal state when request are complited
	*/
	HANDLE				CompliteEvent;
	/*
	Offset to user defined message
	*/
	CHAR				Data;
}CvcCLMsg, * pCvcCLMsg;

/*
Usermode structure that describe connection and being used for communication.
Created internally and should be acessed internally.
*/
typedef struct _CvcConnection {

	/*
	Thread id of master thread
	*/
	DWORD				MasterId;
	/*
	Thread id of slave thread
	*/
	DWORD				SlaveId;
	/*
	Handle to slave thread
	*/
	HANDLE				SlaveHandle;
	/*
	Double linked list that links connections
	*/
	LIST_ENTRY			CvcConnectionLinks;
	/*
	Handle to event that will be in signal state when request are exist
	*/
	HANDLE				RequestEvent;
	/*
	Semaphore that will be owned when callout in processing
	*/
	SEMAPHORE			CalloutSema;
	/*
	Status of last operation
	*/
	volatile NTSTATUS		LastStatus;
	/*
	Handle to event that will be in signal state when request are complited
	*/
	HANDLE				CompliteEvent;
	/*
	Lenght of pending message in bytes
	*/
	ULONG				PendingMsgLen;
	/*
	Pointer to pending message
	*/
	pCvcCLMsg			pMsgPending;

}CvcConnection, * pCvcConnection;

#ifndef CVCMESSAGE_COMMON
/***/#define CVCMESSAGE_COMMON sizeof(volatile NTSTATUS *) + sizeof(HANDLE)
#endif

typedef struct _ConnectionRequest {
	pCvcConnection 			Connection;
	HANDLE 				CompliteEvent;
}ConnectionRequest, * pConnectionRequest;

typedef struct _CvcNull {
	CvcMsgTypeCL			Type;
}CvcNull, * pCvcNull;

typedef struct _CvcAddConnection {
	CvcMsgTypeCL			Type;
	HANDLE				SlaveHandle;
	HANDLE				RequestEvent;
	HANDLE				CompliteEvent;
}CvcAddConnection, * pCvcAddConnection;

typedef struct _CvcHelloWorld {
	CvcMsgTypeCL			Type;
	DWORD				Magic;
}CvcHelloWorld, * pCvcHelloWorld;

typedef struct _CvcRead {
	CvcMsgTypeCL			Type;
	HANDLE				Pid;
	DWORD64				Ptr;
	ULONG				Size;
	PVOID				pOut;
}CvcRead, * pCvcRead;

typedef struct _CvcWrite {
	CvcMsgTypeCL			Type;
	HANDLE				Pid;
	DWORD64				Ptr;
	ULONG				Size;
	PVOID				pSrc;
}CvcWrite, * pCvcWrite;

```

`callback-um/Main.c`:

```c
#include "stdafx.h"
#include "Cse/Cse.h"
#include "CvcCl/Cvc.h"

NTSTATUS
__fastcall
TestThread(
	const pCvcConnection pConnection
) {

	NTSTATUS Status = STATUS_SUCCESS;
	
	char buff[0x100];
	WORD DosSignature = 0;

	sprintf(buff, "%s", __FUNCTION__);
	CseOutputA(buff);

	const PLARGE_INTEGER CvcResults = malloc(sizeof(LARGE_INTEGER) * 1000);

	if (CvcResults) {

		ZeroMemory(CvcResults, sizeof(LARGE_INTEGER) * 1000);

		LARGE_INTEGER Start, End, Elapsed, Freq;
		QueryPerformanceFrequency(&Freq);

		const HANDLE Pid = (HANDLE)GetCurrentProcessId();
		const DWORD64 Ptr = (DWORD64)GetModuleHandleA(NULL);

		for (int i = 0; i < 1000; i++) {

			QueryPerformanceCounter(&Start);

			Status = CvcPostRead(
				pConnection,
				Pid,
				Ptr,
				sizeof(WORD),
				&DosSignature
			);

			QueryPerformanceCounter(&End);
			Elapsed.QuadPart = End.QuadPart - Start.QuadPart;

			Elapsed.QuadPart *= 1000000;
			Elapsed.QuadPart /= Freq.QuadPart;
			CvcResults[i] = Elapsed;
		}

		sprintf(buff, "%s: DosSignature = %x", __FUNCTION__, DosSignature);
		CseOutputA(buff);

		LARGE_INTEGER Min = { .QuadPart = 0xFFFFFFFF };
		LARGE_INTEGER Max = { .QuadPart = 0x0 };
		LARGE_INTEGER Avg = { .QuadPart = 0x0 };

		for (int i = 0; i < 1000; i++) {

			if (Min.QuadPart > CvcResults[i].QuadPart) {

				Min.QuadPart = CvcResults[i].QuadPart;
			}

			if (Max.QuadPart < CvcResults[i].QuadPart) {

				Max.QuadPart = CvcResults[i].QuadPart;
			}

			Avg.QuadPart += CvcResults[i].QuadPart;
		}

		Avg.QuadPart /= 1000;

		sprintf(buff, "%s: Min = %d microseconds", __FUNCTION__, Min.QuadPart);
		CseOutputA(buff);

		sprintf(buff, "%s: Max = %d microseconds", __FUNCTION__, Max.QuadPart);
		CseOutputA(buff);

		sprintf(buff, "%s: Avg = %d microseconds", __FUNCTION__, Avg.QuadPart);
		CseOutputA(buff);

		free(CvcResults);
	}
	
	return STATUS_SUCCESS;
}

int
Main(
	VOID
) {

	NTSTATUS Status = STATUS_SUCCESS;

	if (!NT_SUCCESS(Status = InitCRT())) {

		TerminateProcess((HANDLE)-1, Status);
	}

	if (!NT_SUCCESS(Status = CseCreate())) {

		TerminateProcess((HANDLE)-1, Status);
	}

	if (!NT_SUCCESS(Status = CseOutputA("Hi"))) {

		TerminateProcess((HANDLE)-1, Status);
	}

	if (!NT_SUCCESS(Status = CvcCreate())) {

		TerminateProcess((HANDLE)-1, Status);
	}

	CvcPostHelloWorld(NULL);
	char buff[0x100];
	sprintf(buff, "Status0 = 0x%X", Status);
	CseOutputA(buff);
	
	if (!NT_SUCCESS(Status = CvcSpawnThread(TestThread))) {

		TerminateProcess((HANDLE)-1, Status);
	}

	sprintf(buff, "Status1 = 0x%X", Status);

	CseOutputA(buff);

	WORD DosSignature = 0;

	const PLARGE_INTEGER CvcResults = malloc(sizeof(LARGE_INTEGER) * 1000);
	ZeroMemory(CvcResults, sizeof(LARGE_INTEGER) * 1000);

	LARGE_INTEGER Start, End, Elapsed, Freq;
	QueryPerformanceFrequency(&Freq);

	const HANDLE Pid = (HANDLE)GetCurrentProcessId();
	const DWORD64 Ptr = (DWORD64)GetModuleHandleA(NULL);

	for (int i = 0; i < 1000; i++) {

		QueryPerformanceCounter(&Start);

		Status = CvcPostRead(
			NULL,
			Pid,
			Ptr,
			sizeof(WORD),
			&DosSignature
		);

		QueryPerformanceCounter(&End);
		Elapsed.QuadPart = End.QuadPart - Start.QuadPart;

		Elapsed.QuadPart *= 1000000;
		Elapsed.QuadPart /= Freq.QuadPart;
		CvcResults[i] = Elapsed;
	}

	sprintf(buff, "%s: DosSignature = %x", __FUNCTION__, DosSignature);
	CseOutputA(buff);

	LARGE_INTEGER Min = { .QuadPart = 0xFFFFFFFF };
	LARGE_INTEGER Max = { .QuadPart = 0x0 };
	LARGE_INTEGER Avg = { .QuadPart = 0x0 };

	for (int i = 0; i < 1000; i++) {

		if (Min.QuadPart > CvcResults[i].QuadPart) {

			Min.QuadPart = CvcResults[i].QuadPart;
		}

		if (Max.QuadPart < CvcResults[i].QuadPart) {

			Max.QuadPart = CvcResults[i].QuadPart;
		}

		Avg.QuadPart += CvcResults[i].QuadPart;
	}

	Avg.QuadPart /= 1000;

	sprintf(buff, "%s: Min = %d microseconds",__FUNCTION__, Min.QuadPart);
	CseOutputA(buff);

	sprintf(buff, "%s: Max = %d microseconds", __FUNCTION__, Max.QuadPart);
	CseOutputA(buff);

	sprintf(buff, "%s: Avg = %d microseconds", __FUNCTION__, Avg.QuadPart);
	CseOutputA(buff);
	
	free(CvcResults);
	CvcWaitConnections();
	CvcTerminate();

	if (!NT_SUCCESS(Status = CseWaitInput())) {

		TerminateProcess((HANDLE)-1, Status);
	}

	if (!NT_SUCCESS(Status = CseClear())) {

		TerminateProcess((HANDLE)-1, Status);
	}

	TerminateProcess((HANDLE)-1, 0);

	return 0;
}

```

`callback-um/callback-um.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{667DC8CB-B5E1-4473-8FED-3DE15D72AE5F}</ProjectGuid>
    <RootNamespace>callbackum</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>false</SDLCheck>
      <ConformanceMode>false</ConformanceMode>
      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <StringPooling>true</StringPooling>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions</EnableEnhancedInstructionSet>
      <FloatingPointExceptions>false</FloatingPointExceptions>
      <RuntimeTypeInfo>false</RuntimeTypeInfo>
      <EnableModules>false</EnableModules>
      <CallingConvention>FastCall</CallingConvention>
      <CompileAs>CompileAsC</CompileAs>
      <DisableSpecificWarnings>4005;%(DisableSpecificWarnings)</DisableSpecificWarnings>
      <ControlFlowGuard>false</ControlFlowGuard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <GenerateWindowsMetadata>false</GenerateWindowsMetadata>
      <EntryPointSymbol>Main</EntryPointSymbol>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="CRT\Alloc.c" />
    <ClCompile Include="CRT\CRT.c" />
    <ClCompile Include="CRT\IsCtype.c" />
    <ClCompile Include="CRT\Memory.c" />
    <ClCompile Include="CRT\Sprintf.c" />
    <ClCompile Include="CRT\String.c" />
    <ClCompile Include="CRT\WString.c" />
    <ClCompile Include="Cse\Cse.c" />
    <ClCompile Include="CvcCl\Cvc.c" />
    <ClCompile Include="Main.c" />
    <ClCompile Include="stdafx.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="CRT\Alloc.h" />
    <ClInclude Include="CRT\CRT.h" />
    <ClInclude Include="CRT\List.h" />
    <ClInclude Include="CRT\Semaphore.h" />
    <ClInclude Include="CRT\Sprintf.h" />
    <ClInclude Include="CRT\String.h" />
    <ClInclude Include="CRT\WString.h" />
    <ClInclude Include="Cse\Cse.h" />
    <ClInclude Include="CvcCl\Cvc.h" />
    <ClInclude Include="Declaration.h" />
    <ClInclude Include="stdafx.h" />
  </ItemGroup>
  <ItemGroup>
    <None Include="CvcCl\Dispatcher.asm" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`callback-um/callback-um.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="Main.c" />
    <ClCompile Include="stdafx.c" />
    <ClCompile Include="CRT\Alloc.c" />
    <ClCompile Include="CRT\CRT.c" />
    <ClCompile Include="CRT\IsCtype.c" />
    <ClCompile Include="CRT\Memory.c" />
    <ClCompile Include="CRT\Sprintf.c" />
    <ClCompile Include="CRT\String.c" />
    <ClCompile Include="CRT\WString.c" />
    <ClCompile Include="Cse\Cse.c" />
    <ClCompile Include="CvcCl\Cvc.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="CRT\Alloc.h" />
    <ClInclude Include="CRT\CRT.h" />
    <ClInclude Include="CRT\List.h" />
    <ClInclude Include="CRT\Semaphore.h" />
    <ClInclude Include="CRT\Sprintf.h" />
    <ClInclude Include="CRT\String.h" />
    <ClInclude Include="CRT\WString.h" />
    <ClInclude Include="Cse\Cse.h" />
    <ClInclude Include="CvcCl\Cvc.h" />
    <ClInclude Include="Declaration.h" />
  </ItemGroup>
  <ItemGroup>
    <None Include="CvcCl\Dispatcher.asm" />
  </ItemGroup>
</Project>
```

`callback-um/stdafx.c`:

```c
#include "stdafx.h"
```

`callback-um/stdafx.h`:

```h
#pragma once
#include <Windows.h>
#include <ntstatus.h>
#include <malloc.h>
#include <subauth.h>
#include <intrin.h>
#include "CRT/CRT.h"

#pragma region Memory

/***/#pragma function(memcmp)
/***/#pragma function(memset)
/***/#pragma function(memcpy)
/***/#pragma function(memmove)

#pragma endregion



#pragma region String

/***/#pragma function(strlen)
/***/#pragma function(strcmp)
/***/#pragma function(strcat)
/***/#pragma function(strcpy)

#pragma endregion



#pragma region WString

/***/#pragma function(wcslen)
/***/#pragma function(wcscmp)
/***/#pragma function(wcscat)
/***/#pragma function(wcscpy)

#pragma endregion
```

`dispatch-km/dispatch-km.inf`:

```inf
;
; dispatch-km.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=Sample ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=dispatch-km.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages

[DestinationDirs]
DefaultDestDir = 12
dispatch-km_Device_CoInstaller_CopyFiles = 11

; ================= Class section =====================

[ClassInstall32]
Addreg=SampleClassReg

[SampleClassReg]
HKR,,,0,%ClassName%
HKR,,Icon,,-5

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
dispatch-km.sys  = 1,,
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll=1 ; make sure the number matches with SourceDisksNames

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%dispatch-km.DeviceDesc%=dispatch-km_Device, Root\dispatch-km ; TODO: edit hw-id

[dispatch-km_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
dispatch-km.sys

;-------------- Service installation
[dispatch-km_Device.NT.Services]
AddService = dispatch-km,%SPSVCINST_ASSOCSERVICE%, dispatch-km_Service_Inst

; -------------- dispatch-km driver install sections
[dispatch-km_Service_Inst]
DisplayName    = %dispatch-km.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\dispatch-km.sys

;
;--- dispatch-km_Device Coinstaller installation ------
;

[dispatch-km_Device.NT.CoInstallers]
AddReg=dispatch-km_Device_CoInstaller_AddReg
CopyFiles=dispatch-km_Device_CoInstaller_CopyFiles

[dispatch-km_Device_CoInstaller_AddReg]
HKR,,CoInstallers32,0x00010000, "WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll,WdfCoInstaller"

[dispatch-km_Device_CoInstaller_CopyFiles]
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll

[dispatch-km_Device.NT.Wdf]
KmdfService =  dispatch-km, dispatch-km_wdfsect
[dispatch-km_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName="Samples" ; TODO: edit ClassName
DiskName = "dispatch-km Installation Disk"
dispatch-km.DeviceDesc = "dispatch-km Device"
dispatch-km.SVCDESC = "dispatch-km Service"

```

`dispatch-km/dispatch-km.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{FD57C3F9-DFDE-4B34-9BEF-1B7C9EC4D582}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>dispatch_km</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`dispatch-km/dispatch-km.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="main.c" />
  </ItemGroup>
</Project>
```

`dispatch-km/main.c`:

```c
#include <ntddk.h> 

const WCHAR sc_wszDeviceNameBuffer[]	= L"\\Device\\Dispatch_Test";
const WCHAR sc_wszDeviceSymLinkBuffer[] = L"\\DosDevices\\Dispatch_Test";

NTSTATUS OnIRPRead(PDEVICE_OBJECT pDriverObject, PIRP pIrp)
{
	UNREFERENCED_PARAMETER(pDriverObject);

	char szBuffer[255] = "Hello from kernel land!";
	strcpy(pIrp->AssociatedIrp.SystemBuffer, szBuffer);
	DbgPrint("Message: %s(%u) sent from kernel!", szBuffer, strlen(szBuffer));

	pIrp->IoStatus.Status = STATUS_SUCCESS;
	pIrp->IoStatus.Information = strlen(szBuffer);
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}

NTSTATUS OnIRPWrite(PDEVICE_OBJECT pDriverObject, PIRP pIrp)
{
	UNREFERENCED_PARAMETER(pDriverObject);

	char szBuffer[255] = { 0 };
	strcpy(szBuffer, pIrp->AssociatedIrp.SystemBuffer);
	DbgPrint("User message received: %s(%u)", szBuffer, strlen(szBuffer));

	pIrp->IoStatus.Status = STATUS_SUCCESS;
	pIrp->IoStatus.Information = strlen(szBuffer);
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}

NTSTATUS OnMajorFunctionCall(PDEVICE_OBJECT pDriverObject, PIRP pIrp)
{
	PIO_STACK_LOCATION pStack = IoGetCurrentIrpStackLocation(pIrp);
	switch (pStack->MajorFunction)
	{
		case IRP_MJ_READ:
			OnIRPRead(pDriverObject, pIrp);
			break;

		case IRP_MJ_WRITE:
			OnIRPWrite(pDriverObject, pIrp);
			break;

		default:
			pIrp->IoStatus.Status = STATUS_SUCCESS;
			IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	}
	return STATUS_SUCCESS;
}


VOID OnDriverUnload(IN PDRIVER_OBJECT pDriverObject)
{
	UNREFERENCED_PARAMETER(pDriverObject);

	DbgPrint("Driver unload routine triggered!\n");

	UNICODE_STRING symLink;
	RtlInitUnicodeString(&symLink, sc_wszDeviceSymLinkBuffer);

	IoDeleteSymbolicLink(&symLink);
	if (pDriverObject && pDriverObject->DeviceObject)
	{
		IoDeleteDevice(pDriverObject->DeviceObject);
	}
}

NTSTATUS DriverEntry(IN PDRIVER_OBJECT pDriverObject, IN PUNICODE_STRING pRegistryPath)
{
	// Process params
	UNREFERENCED_PARAMETER(pRegistryPath);

	if (!pDriverObject)
	{
		DbgPrint("DispatchTestSys driver entry is null!\n");
		return STATUS_FAILED_DRIVER_ENTRY;
	}

	// Hello world!
	DbgPrint("Driver loaded, system range start in %p, Our entry at: %p\n", MmSystemRangeStart, DriverEntry);

	// Register unload routine
	pDriverObject->DriverUnload = &OnDriverUnload;

	// Veriable decleration
	NTSTATUS ntStatus = 0;

	// Normalize name and symbolic link.
	UNICODE_STRING deviceNameUnicodeString, deviceSymLinkUnicodeString;
	RtlInitUnicodeString(&deviceNameUnicodeString, sc_wszDeviceNameBuffer);
	RtlInitUnicodeString(&deviceSymLinkUnicodeString, sc_wszDeviceSymLinkBuffer);

	// Create the device.
	PDEVICE_OBJECT pDeviceObject = NULL;
	ntStatus = IoCreateDevice(pDriverObject, 0, &deviceNameUnicodeString, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &pDeviceObject);
	if (ntStatus != STATUS_SUCCESS)
	{
		DbgPrint("DispatchTestSys IoCreateDevice fail! Status: %p\n", ntStatus);
		return ntStatus;
	}

	// Create the symbolic link
	ntStatus = IoCreateSymbolicLink(&deviceSymLinkUnicodeString, &deviceNameUnicodeString);
	if (ntStatus != STATUS_SUCCESS)
	{
		DbgPrint("DispatchTestSys IoCreateSymbolicLink fail! Status: %p\n", ntStatus);
		return ntStatus;
	}

	// Register driver major callbacks
	for (ULONG t = 0; t <= IRP_MJ_MAXIMUM_FUNCTION; t++)
		pDriverObject->MajorFunction[t] = &OnMajorFunctionCall;

	pDeviceObject->Flags |= DO_BUFFERED_IO;

	DbgPrint("Ioctl driver entry completed!\n");

	return STATUS_SUCCESS;
}



```

`dispatch-um/dispatch-um.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{F7341DC6-DD9E-476A-A59A-8D8DB95903F4}</ProjectGuid>
    <RootNamespace>dispatchum</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`dispatch-um/dispatch-um.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="main.cpp" />
  </ItemGroup>
</Project>
```

`dispatch-um/main.cpp`:

```cpp
#include <Windows.h>
#include <string>
#include <iostream>

static const std::string	gsc_szSymLink	= "\\\\.\\Dispatch_Test";
static HANDLE				gs_hDriver		= INVALID_HANDLE_VALUE;

void ShowErrorMessage(const std::string & szError, DWORD dwErrorCode)
{
	char szErrorMessage[4096] = { 0 };

	auto dwFlags = DWORD(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_MAX_WIDTH_MASK);
	FormatMessageA(dwFlags, NULL, dwErrorCode, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), szErrorMessage, _countof(szErrorMessage), NULL);

	printf("%s | Error: %u - Description: %s\n", szError.c_str(), dwErrorCode, szErrorMessage);
}

bool ReadRoutine()
{
	auto dwReadCount	= 0UL;
	char szBuff[255]	= { 0 };
	if (ReadFile(gs_hDriver, szBuff, sizeof(szBuff), &dwReadCount, NULL) == FALSE)
	{
		ShowErrorMessage("ReadFile fail!", GetLastError());
		return false;
	}

	printf("Read message content: %s Size: %u\n", szBuff, dwReadCount);
	return true;
}

bool WriteRoutine()
{
	printf("Enter message: ");

	auto szMessage = std::string("");
	std::cin >> szMessage;

	auto dwMessageSize = static_cast<DWORD>(szMessage.size());

	auto dwWriteCount = 0UL;
	if (WriteFile(gs_hDriver, szMessage.c_str(), dwMessageSize + 1, &dwWriteCount, NULL) == FALSE)
	{
		ShowErrorMessage("WriteFile fail!", GetLastError());
		return false;
	}

	printf("Message sent! Size: %u Content size: %u\n", dwWriteCount, dwMessageSize);
	return true;
}

int main()
{
	printf("Communication CLI started! Target device: %s\n", gsc_szSymLink.c_str());

	gs_hDriver = CreateFileA(gsc_szSymLink.c_str(), GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);
	if (!gs_hDriver || gs_hDriver == INVALID_HANDLE_VALUE)
	{
		ShowErrorMessage("CreateFileA fail!", GetLastError());
		return 1;
	}
	printf("Handle succesfully created: %p\n", gs_hDriver);

	printf("--------------------------------------\n");

	char pInput = '0';
	while (pInput != 'x')
	{
		printf("Please select:\n1 --> Read message\n2 --> Write message\nx --> Exit\n");
		std::cin >> pInput;

		switch (pInput)
		{
			case '1':
			{
				ReadRoutine();
			} break;

			case '2':
			{
				WriteRoutine();
			} break;

			case 'x':
				return 0;

			default:
				continue;
		}
	}


    return 0;
}


```

`ioctl-km/Driver.c`:

```c
#include <ntifs.h> 
#include <ntddk.h> 
#include <ntstrsafe.h> 
#include <stdlib.h>

#define IOCTL_READ_MEM CTL_CODE(FILE_DEVICE_UNKNOWN, 0x999, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)
#define IOCTL_WRITE_MEM CTL_CODE(FILE_DEVICE_UNKNOWN, 0x998, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)

PDEVICE_OBJECT pDeviceObject;
UNICODE_STRING dev, dos;

DRIVER_DISPATCH Create;
DRIVER_DISPATCH IOCTL;
DRIVER_DISPATCH Close;
DRIVER_UNLOAD Unload;

void Unload(PDRIVER_OBJECT pDriverObject) {
	IoDeleteSymbolicLink(&dos);
	IoDeleteDevice(pDriverObject->DeviceObject);
}

NTSTATUS Create(PDEVICE_OBJECT DeviceObject, PIRP irp)
{
	irp->IoStatus.Status = STATUS_SUCCESS;
	irp->IoStatus.Information = 0;

	IoCompleteRequest(irp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}

NTSTATUS Close(PDEVICE_OBJECT DeviceObject, PIRP irp)
{
	irp->IoStatus.Status = STATUS_SUCCESS;
	irp->IoStatus.Information = 0;
	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "kernel mod unloading");
	IoCompleteRequest(irp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}

struct {
	int PID;
	void * Addr;
	void * Value;
	int Bytes;
}
UserLand;

NTSTATUS NTAPI MmCopyVirtualMemory
(
	PEPROCESS SourceProcess,
	PVOID SourceAddress,
	PEPROCESS TargetProcess,
	PVOID TargetAddress,
	SIZE_T BufferSize,
	KPROCESSOR_MODE PreviousMode,
	PSIZE_T ReturnSize
);

NTSTATUS ReadProcessMemory(HANDLE PID, PVOID SourceAddress, PVOID TargetAddress, SIZE_T Size) {
	SIZE_T Result;
	PEPROCESS SourceProcess, TargetProcess;
	PsLookupProcessByProcessId(PID, &SourceProcess);
	TargetProcess = PsGetCurrentProcess();
	__try {
		MmCopyVirtualMemory(SourceProcess, SourceAddress, TargetProcess, TargetAddress, Size, KernelMode, &Result);
		return STATUS_SUCCESS;
	}
	__except (EXCEPTION_EXECUTE_HANDLER) {
		return STATUS_ACCESS_DENIED;
	}
}

NTSTATUS WriteProcessMemory(HANDLE PID, PVOID SourceAddress, PVOID TargetAddress, SIZE_T Size) {
	SIZE_T Result;
	PEPROCESS SourceProcess, TargetProcess;
	PsLookupProcessByProcessId(PID, &SourceProcess);
	TargetProcess = PsGetCurrentProcess();
	__try {
		MmCopyVirtualMemory(TargetProcess, TargetAddress, SourceProcess, SourceAddress, Size, KernelMode, &Result);
		return STATUS_SUCCESS;
	}
	__except (EXCEPTION_EXECUTE_HANDLER) {
		return STATUS_ACCESS_DENIED;
	}
}

NTSTATUS IOCTL(PDEVICE_OBJECT DeviceObject, PIRP irp) {
	PUCHAR UserBuffer;
	PIO_STACK_LOCATION io;

	io = IoGetCurrentIrpStackLocation(irp);
	switch (io->Parameters.DeviceIoControl.IoControlCode) {
	case IOCTL_READ_MEM:
		memcpy(&UserLand, irp->AssociatedIrp.SystemBuffer, sizeof(UserLand));
		UserBuffer = (PUCHAR)MmGetSystemAddressForMdlSafe(irp->MdlAddress, NormalPagePriority);
		if (UserBuffer && UserLand.Addr != NULL) {
			ReadProcessMemory((HANDLE)UserLand.PID, UserLand.Addr, (PVOID)UserBuffer, UserLand.Bytes);
		}
		KeFlushIoBuffers(irp->MdlAddress, TRUE, FALSE);
		irp->IoStatus.Information = 0;
		break;
	case IOCTL_WRITE_MEM:
		memcpy(&UserLand, irp->AssociatedIrp.SystemBuffer, sizeof(UserLand));
		UserBuffer = (PUCHAR)MmGetSystemAddressForMdlSafe(irp->MdlAddress, NormalPagePriority);
		if (UserBuffer && UserLand.Addr != NULL) {
			WriteProcessMemory((HANDLE)UserLand.PID, UserLand.Addr, (PVOID)UserBuffer, UserLand.Bytes);
		}
		KeFlushIoBuffers(irp->MdlAddress, TRUE, FALSE);
		irp->IoStatus.Information = 0;
		break;
	default:

		irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
		irp->IoStatus.Information = 0;

		IoCompleteRequest(irp, IO_NO_INCREMENT);
		return STATUS_INVALID_DEVICE_REQUEST;
	}
	irp->IoStatus.Status = STATUS_SUCCESS;
	irp->IoStatus.Information = 0;
	IoCompleteRequest(irp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}

UNICODE_STRING DeviceName = RTL_CONSTANT_STRING(L"\\Device\\KRPM_Driver"), SymbolicLink = RTL_CONSTANT_STRING(L"\\DosDevices\\KRPM_Driver");
PDEVICE_OBJECT pDeviceObject;

NTSTATUS DriverEntry(PDRIVER_OBJECT pDriverObject, PUNICODE_STRING pRegistryPath) {


	ULONG i;

	IoCreateDevice(pDriverObject, 0, &DeviceName, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &pDeviceObject);
	IoCreateSymbolicLink(&SymbolicLink, &DeviceName);

	IoSetDeviceInterfaceState(pRegistryPath, TRUE);

	pDriverObject->MajorFunction[IRP_MJ_CREATE] = Create;
	pDriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = IOCTL;
	pDriverObject->MajorFunction[IRP_MJ_CLOSE] = Close;

	pDriverObject->DriverUnload = Unload;

	pDeviceObject->Flags |= DO_DIRECT_IO;
	pDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "kernel mod loaded");
	return STATUS_SUCCESS;
}
```

`ioctl-km/ioctl-km.inf`:

```inf
;
; ioctl-km.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=Sample ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=ioctl-km.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages

[DestinationDirs]
DefaultDestDir = 12
ioctl-km_Device_CoInstaller_CopyFiles = 11

; ================= Class section =====================

[ClassInstall32]
Addreg=SampleClassReg

[SampleClassReg]
HKR,,,0,%ClassName%
HKR,,Icon,,-5

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
ioctl-km.sys  = 1,,
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll=1 ; make sure the number matches with SourceDisksNames

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%ioctl-km.DeviceDesc%=ioctl-km_Device, Root\ioctl-km ; TODO: edit hw-id

[ioctl-km_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
ioctl-km.sys

;-------------- Service installation
[ioctl-km_Device.NT.Services]
AddService = ioctl-km,%SPSVCINST_ASSOCSERVICE%, ioctl-km_Service_Inst

; -------------- ioctl-km driver install sections
[ioctl-km_Service_Inst]
DisplayName    = %ioctl-km.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\ioctl-km.sys

;
;--- ioctl-km_Device Coinstaller installation ------
;

[ioctl-km_Device.NT.CoInstallers]
AddReg=ioctl-km_Device_CoInstaller_AddReg
CopyFiles=ioctl-km_Device_CoInstaller_CopyFiles

[ioctl-km_Device_CoInstaller_AddReg]
HKR,,CoInstallers32,0x00010000, "WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll,WdfCoInstaller"

[ioctl-km_Device_CoInstaller_CopyFiles]
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll

[ioctl-km_Device.NT.Wdf]
KmdfService =  ioctl-km, ioctl-km_wdfsect
[ioctl-km_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName="Samples" ; TODO: edit ClassName
DiskName = "ioctl-km Installation Disk"
ioctl-km.DeviceDesc = "ioctl-km Device"
ioctl-km.SVCDESC = "ioctl-km Service"

```

`ioctl-km/ioctl-km.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{8C20051E-9D3A-46AF-8F7A-320262A9DCED}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>ioctl_km</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <TreatLinkerWarningAsErrors>false</TreatLinkerWarningAsErrors>
    </Link>
    <ClCompile />
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Driver.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`ioctl-km/ioctl-km.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="Driver.c" />
  </ItemGroup>
</Project>
```

`ioctl-um/Driver.cpp`:

```cpp
#include "Driver.h"

BOOL MoaRpm::load_driver(std::string TargetDriver, std::string TargetServiceName, std::string TargetServiceDesc)
{
	SC_HANDLE ServiceManager = OpenSCManager(NULL, NULL, SC_MANAGER_CREATE_SERVICE);
	if (!ServiceManager) return FALSE;
	SC_HANDLE ServiceHandle = CreateService(ServiceManager, TargetServiceName.c_str(), TargetServiceDesc.c_str(), SERVICE_START | DELETE | SERVICE_STOP, SERVICE_KERNEL_DRIVER, SERVICE_DEMAND_START, SERVICE_ERROR_IGNORE, TargetDriver.c_str(), NULL, NULL, NULL, NULL, NULL);
	if (!ServiceHandle)
	{
		ServiceHandle = OpenService(ServiceManager, TargetServiceName.c_str(), SERVICE_START | DELETE | SERVICE_STOP);
		if (!ServiceHandle) return FALSE;
	}
	if (!StartServiceA(ServiceHandle, NULL, NULL)) return FALSE;
	CloseServiceHandle(ServiceHandle);
	CloseServiceHandle(ServiceManager);
	return TRUE;
}

BOOL MoaRpm::delete_service(std::string TargetServiceName)
{
	SERVICE_STATUS ServiceStatus;
	SC_HANDLE ServiceManager = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
	if (!ServiceManager) return FALSE;
	SC_HANDLE ServiceHandle = OpenService(ServiceManager, TargetServiceName.c_str(), SERVICE_STOP | DELETE);
	if (!ServiceHandle) return FALSE;
	if (!ControlService(ServiceHandle, SERVICE_CONTROL_STOP, &ServiceStatus)) return FALSE;
	if (!DeleteService(ServiceHandle)) return FALSE;
	CloseServiceHandle(ServiceHandle);
	CloseServiceHandle(ServiceManager);
	return TRUE;
}

std::string MoaRpm::exePath() {
	char buffer[MAX_PATH];
	GetModuleFileName(NULL, buffer, MAX_PATH);
	std::string::size_type pos = std::string(buffer).find_last_of("\\/");
	return std::string(buffer).substr(0, pos);
}

bool MoaRpm::isElevated() {
	BOOL fRet = FALSE;
	HANDLE hToken = NULL;
	if (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken)) {
		TOKEN_ELEVATION Elevation;
		DWORD cbSize = sizeof(TOKEN_ELEVATION);
		if (GetTokenInformation(hToken, TokenElevation, &Elevation, sizeof(Elevation), &cbSize)) {
			fRet = Elevation.TokenIsElevated;
		}
	}
	if (hToken) {
		CloseHandle(hToken);
	}
	return fRet;
}

bool MoaRpm::isTestMode() {
	typedef NTSTATUS(__stdcall* td_NtQuerySystemInformation)(
		ULONG           SystemInformationClass,
		PVOID           SystemInformation,
		ULONG           SystemInformationLength,
		PULONG          ReturnLength
		);

	struct SYSTEM_CODEINTEGRITY_INFORMATION {
		ULONG Length;
		ULONG CodeIntegrityOptions;
	};

	static td_NtQuerySystemInformation NtQuerySystemInformation = (td_NtQuerySystemInformation)GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtQuerySystemInformation");

	SYSTEM_CODEINTEGRITY_INFORMATION Integrity = { sizeof(SYSTEM_CODEINTEGRITY_INFORMATION), 0 };
	NTSTATUS status = NtQuerySystemInformation(103, &Integrity, sizeof(Integrity), NULL);

	return (NT_SUCCESS(status) && (Integrity.CodeIntegrityOptions & 1));
}

void MoaRpm::init(DWORD pID, MOA_MODE AccessMode) {
	this->pID = pID;
	this->mode = AccessMode;
	if (this->mode == MOA_MODE::KERNEL) {
		if (!this->isElevated()) {
			MessageBox(NULL, "Must be running as admin for kernel mode stuff", "Fatal Error", MB_OK);
			exit(1);
		}
		if (!this->isTestMode()) {
			MessageBox(NULL, "Must have testing mode enabled to load unsigned driver", "Fatal Error", MB_OK);
			exit(1);
		}
		std::ifstream infile("kRpm.sys");
		if (!infile.good()) {
			std::cout << "Extracting File" << std::endl;
			std::ofstream fout;
			fout.open("kRpm.sys", std::ios::binary | std::ios::out);
			fout.write((char*)&MoaRpm::rawDriver, 8304);
			fout.close();
		}
		this->load_driver(exePath() + "\\kRpm.sys", "kRpm", "Kernel level readprocessmemory and writeprocessmemory");
	}
	else {

		this->hProcess = OpenProcess(PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_VM_OPERATION, FALSE, pID);
	}
}

MoaRpm::MoaRpm(DWORD pID, MOA_MODE AccessMode) {
	this->init(pID, AccessMode);
}

MoaRpm::MoaRpm(const char* windowname, MOA_MODE AccessMode) {
	HWND targetWindow = FindWindow(NULL, windowname);
	//if (!targetWindow) printf("target window not found");
	GetWindowThreadProcessId(targetWindow, &this->pID);
	//printf("Target PID:%d\n", this->pID);
	this->init(pID, AccessMode);
}

MoaRpm::~MoaRpm() {
	if (this->mode == MOA_MODE::KERNEL) {
		this->delete_service("kRpm");
	}
	else {
		CloseHandle(this->hProcess);
	}
}

void MoaRpm::readRaw(LPCVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize, SIZE_T* lpNumberOfBytesRead) {
	if (this->mode == MOA_MODE::STANDARD) {
		ReadProcessMemory(this->hProcess, lpBaseAddress, lpBuffer, nSize, lpNumberOfBytesRead);
	}
	if (this->mode == MOA_MODE::NTDLL) {
		NtReadVirtualMemory(this->hProcess, (PVOID)lpBaseAddress, lpBuffer, nSize, (PULONG)lpNumberOfBytesRead);
	}
	if (this->mode == MOA_MODE::KERNEL) {
		struct Rpmdata
		{
			HANDLE pid;
			PVOID SourceAddress;
			PVOID TargetAddress;
			SIZE_T Size;
		} rpm;
		rpm.pid = (HANDLE)pID;
		rpm.SourceAddress = (PVOID)lpBaseAddress;
		rpm.TargetAddress = lpBuffer;
		rpm.Size = nSize;
		HANDLE hDevice = INVALID_HANDLE_VALUE;
		BOOL bResult = FALSE;
		DWORD junk = 0;

		hDevice = CreateFileW(DRIVER_NAME, 0, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);

		if (hDevice != INVALID_HANDLE_VALUE) {
			bResult = DeviceIoControl(hDevice, IOCTL_READ_MEM, &rpm, sizeof(rpm), lpBuffer, nSize, &junk, (LPOVERLAPPED)NULL);
			CloseHandle(hDevice);
			return;
		}
	}
}

bool MoaRpm::writeRaw(LPCVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize, SIZE_T* lpNumberOfBytesRead) {
	if (this->mode == MOA_MODE::STANDARD) {
		WriteProcessMemory(this->hProcess, (PVOID)lpBaseAddress, lpBuffer, nSize, lpNumberOfBytesRead);
		return (*lpNumberOfBytesRead == nSize);
	}
	if (this->mode == MOA_MODE::NTDLL) {
		NtWriteVirtualMemory(this->hProcess, (PVOID)lpBaseAddress, lpBuffer, nSize, (PULONG)lpNumberOfBytesRead);
		return (*lpNumberOfBytesRead == nSize);
	}
	if (this->mode == MOA_MODE::KERNEL) {
		struct Rpmdata
		{
			HANDLE pid;
			PVOID SourceAddress;
			PVOID TargetAddress;
			SIZE_T Size;
		} rpm;
		rpm.pid = (HANDLE)pID;
		rpm.SourceAddress = (PVOID)lpBaseAddress;
		rpm.TargetAddress = lpBuffer;
		rpm.Size = nSize;
		HANDLE hDevice = INVALID_HANDLE_VALUE;
		BOOL bResult = FALSE;
		DWORD junk = 0;

		hDevice = CreateFileW(DRIVER_NAME, 0, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);

		if (hDevice != INVALID_HANDLE_VALUE) {
			bResult = DeviceIoControl(hDevice, IOCTL_WRITE_MEM, &rpm, sizeof(rpm), lpBuffer, nSize, &junk, (LPOVERLAPPED)NULL);
			CloseHandle(hDevice);
			return false;
		}
	}
	return true;
}

const unsigned char MoaRpm::rawDriver[8304] = {
	0x4D, 0x5A, 0x90, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
	0xFF, 0xFF, 0x00, 0x00, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xD0, 0x00, 0x00, 0x00, 0x0E, 0x1F, 0xBA, 0x0E, 0x00, 0xB4, 0x09, 0xCD,
	0x21, 0xB8, 0x01, 0x4C, 0xCD, 0x21, 0x54, 0x68, 0x69, 0x73, 0x20, 0x70,
	0x72, 0x6F, 0x67, 0x72, 0x61, 0x6D, 0x20, 0x63, 0x61, 0x6E, 0x6E, 0x6F,
	0x74, 0x20, 0x62, 0x65, 0x20, 0x72, 0x75, 0x6E, 0x20, 0x69, 0x6E, 0x20,
	0x44, 0x4F, 0x53, 0x20, 0x6D, 0x6F, 0x64, 0x65, 0x2E, 0x0D, 0x0D, 0x0A,
	0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE7, 0x21, 0xDB, 0x95,
	0xA3, 0x40, 0xB5, 0xC6, 0xA3, 0x40, 0xB5, 0xC6, 0xA3, 0x40, 0xB5, 0xC6,
	0xA3, 0x40, 0xB4, 0xC6, 0xAE, 0x40, 0xB5, 0xC6, 0xC6, 0x26, 0xB4, 0xC7,
	0xA0, 0x40, 0xB5, 0xC6, 0xC6, 0x26, 0xB6, 0xC7, 0xA2, 0x40, 0xB5, 0xC6,
	0xC6, 0x26, 0xB1, 0xC7, 0xA7, 0x40, 0xB5, 0xC6, 0x33, 0x29, 0xB1, 0xC7,
	0xA2, 0x40, 0xB5, 0xC6, 0x33, 0x29, 0xB7, 0xC7, 0xA2, 0x40, 0xB5, 0xC6,
	0x52, 0x69, 0x63, 0x68, 0xA3, 0x40, 0xB5, 0xC6, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x50, 0x45, 0x00, 0x00, 0x64, 0x86, 0x06, 0x00,
	0x45, 0x99, 0x20, 0x5C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xF0, 0x00, 0x22, 0x00, 0x0B, 0x02, 0x0E, 0x10, 0x00, 0x0A, 0x00, 0x00,
	0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00,
	0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00,
	0x00, 0x10, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00,
	0x0A, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x70, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x5F, 0x4C, 0x00, 0x00,
	0x01, 0x00, 0xE0, 0x41, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x5C, 0x50, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00,
	0x6C, 0x00, 0x00, 0x00, 0x00, 0x1A, 0x00, 0x00, 0x70, 0x06, 0x00, 0x00,
	0x00, 0x60, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x21, 0x00, 0x00,
	0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x40, 0x21, 0x00, 0x00, 0x08, 0x01, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00,
	0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x2E, 0x74, 0x65, 0x78, 0x74, 0x00, 0x00, 0x00,
	0x02, 0x04, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00,
	0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x68, 0x2E, 0x72, 0x64, 0x61,
	0x74, 0x61, 0x00, 0x00, 0x8C, 0x04, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00,
	0x00, 0x06, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x48,
	0x2E, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00,
	0x00, 0x30, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x40, 0x00, 0x00, 0xC8, 0x2E, 0x70, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00,
	0x6C, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
	0x00, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x48, 0x49, 0x4E, 0x49, 0x54,
	0x00, 0x00, 0x00, 0x00, 0x30, 0x02, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00,
	0x00, 0x04, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x62,
	0x2E, 0x72, 0x65, 0x6C, 0x6F, 0x63, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00,
	0x00, 0x60, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x40, 0x00, 0x00, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x40, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x83, 0x62,
	0x30, 0x00, 0x4C, 0x8D, 0x05, 0xBF, 0x03, 0x00, 0x00, 0x48, 0x83, 0x62,
	0x38, 0x00, 0x48, 0x8B, 0xDA, 0x33, 0xD2, 0x8D, 0x4A, 0x4D, 0xFF, 0x15,
	0xDC, 0x0F, 0x00, 0x00, 0x33, 0xD2, 0x48, 0x8B, 0xCB, 0xFF, 0x15, 0xE9,
	0x0F, 0x00, 0x00, 0x33, 0xC0, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0xC3, 0xCC,
	0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x83, 0xEC, 0x28,
	0x83, 0x62, 0x30, 0x00, 0x48, 0x8B, 0xCA, 0x48, 0x83, 0x62, 0x38, 0x00,
	0x33, 0xD2, 0xFF, 0x15, 0xC0, 0x0F, 0x00, 0x00, 0x33, 0xC0, 0x48, 0x83,
	0xC4, 0x28, 0xC3, 0xCC, 0x48, 0x89, 0x5C, 0x24, 0x08, 0x57, 0x48, 0x83,
	0xEC, 0x40, 0x48, 0x8D, 0x05, 0xFF, 0x1F, 0x00, 0x00, 0x48, 0x8B, 0xDA,
	0x48, 0x89, 0x44, 0x24, 0x30, 0x4C, 0x8D, 0x05, 0x80, 0x1F, 0x00, 0x00,
	0xC6, 0x44, 0x24, 0x28, 0x00, 0x41, 0xB9, 0x22, 0x00, 0x00, 0x00, 0x33,
	0xD2, 0xC7, 0x44, 0x24, 0x20, 0x00, 0x01, 0x00, 0x00, 0x48, 0x8B, 0xF9,
	0xFF, 0x15, 0x82, 0x0F, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x5B, 0x1F, 0x00,
	0x00, 0x48, 0x8D, 0x0D, 0x64, 0x1F, 0x00, 0x00, 0xFF, 0x15, 0x76, 0x0F,
	0x00, 0x00, 0xB2, 0x01, 0x48, 0x8B, 0xCB, 0xFF, 0x15, 0x8B, 0x0F, 0x00,
	0x00, 0x48, 0x8D, 0x05, 0x7C, 0xFF, 0xFF, 0xFF, 0x33, 0xD2, 0x48, 0x89,
	0x47, 0x70, 0x4C, 0x8D, 0x05, 0x1F, 0x03, 0x00, 0x00, 0x48, 0x8D, 0x05,
	0x58, 0x00, 0x00, 0x00, 0x48, 0x89, 0x87, 0xE0, 0x00, 0x00, 0x00, 0x48,
	0x8D, 0x05, 0x1A, 0xFF, 0xFF, 0xFF, 0x48, 0x89, 0x87, 0x80, 0x00, 0x00,
	0x00, 0x8D, 0x4A, 0x4D, 0x48, 0x8D, 0x05, 0xF9, 0x01, 0x00, 0x00, 0x48,
	0x89, 0x47, 0x68, 0x48, 0x8B, 0x05, 0x6E, 0x1F, 0x00, 0x00, 0x83, 0x48,
	0x30, 0x10, 0x48, 0x8B, 0x05, 0x63, 0x1F, 0x00, 0x00, 0x0F, 0xBA, 0x70,
	0x30, 0x07, 0xFF, 0x15, 0xE8, 0x0E, 0x00, 0x00, 0x48, 0x8B, 0x5C, 0x24,
	0x50, 0x33, 0xC0, 0x48, 0x83, 0xC4, 0x40, 0x5F, 0xC3, 0xCC, 0xCC, 0xCC,
	0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x89, 0x5C, 0x24,
	0x08, 0x57, 0x48, 0x83, 0xEC, 0x30, 0x48, 0x8B, 0x8A, 0xB8, 0x00, 0x00,
	0x00, 0x48, 0x8B, 0xDA, 0x8B, 0x51, 0x18, 0x81, 0xEA, 0x62, 0x26, 0x22,
	0x00, 0x0F, 0x84, 0x88, 0x00, 0x00, 0x00, 0x83, 0xFA, 0x04, 0x74, 0x0D,
	0xBF, 0x10, 0x00, 0x00, 0xC0, 0x89, 0x7B, 0x30, 0xE9, 0xF6, 0x00, 0x00,
	0x00, 0x48, 0x8B, 0x43, 0x18, 0x0F, 0x10, 0x00, 0x0F, 0x11, 0x05, 0xCD,
	0x1E, 0x00, 0x00, 0x0F, 0x10, 0x48, 0x10, 0x0F, 0x11, 0x0D, 0xD2, 0x1E,
	0x00, 0x00, 0x48, 0x8B, 0x4B, 0x08, 0xF6, 0x41, 0x0A, 0x05, 0x74, 0x06,
	0x48, 0x8B, 0x41, 0x18, 0xEB, 0x1C, 0x45, 0x33, 0xC9, 0xC7, 0x44, 0x24,
	0x28, 0x10, 0x00, 0x00, 0x00, 0x83, 0x64, 0x24, 0x20, 0x00, 0x33, 0xD2,
	0x45, 0x8D, 0x41, 0x01, 0xFF, 0x15, 0x66, 0x0E, 0x00, 0x00, 0x48, 0x85,
	0xC0, 0x0F, 0x84, 0x94, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x15, 0x8E, 0x1E,
	0x00, 0x00, 0x48, 0x85, 0xD2, 0x0F, 0x84, 0x84, 0x00, 0x00, 0x00, 0x4C,
	0x63, 0x0D, 0x8E, 0x1E, 0x00, 0x00, 0x4C, 0x8B, 0xC0, 0x48, 0x63, 0x0D,
	0x6C, 0x1E, 0x00, 0x00, 0xE8, 0x9F, 0x00, 0x00, 0x00, 0xEB, 0x6C, 0x48,
	0x8B, 0x43, 0x18, 0x0F, 0x10, 0x00, 0x0F, 0x11, 0x05, 0x57, 0x1E, 0x00,
	0x00, 0x0F, 0x10, 0x48, 0x10, 0x0F, 0x11, 0x0D, 0x5C, 0x1E, 0x00, 0x00,
	0x48, 0x8B, 0x4B, 0x08, 0xF6, 0x41, 0x0A, 0x05, 0x74, 0x06, 0x48, 0x8B,
	0x41, 0x18, 0xEB, 0x1C, 0x45, 0x33, 0xC9, 0xC7, 0x44, 0x24, 0x28, 0x10,
	0x00, 0x00, 0x00, 0x83, 0x64, 0x24, 0x20, 0x00, 0x33, 0xD2, 0x45, 0x8D,
	0x41, 0x01, 0xFF, 0x15, 0xF0, 0x0D, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x74,
	0x22, 0x48, 0x8B, 0x15, 0x1C, 0x1E, 0x00, 0x00, 0x48, 0x85, 0xD2, 0x74,
	0x16, 0x4C, 0x63, 0x0D, 0x20, 0x1E, 0x00, 0x00, 0x4C, 0x8B, 0xC0, 0x48,
	0x63, 0x0D, 0xFE, 0x1D, 0x00, 0x00, 0xE8, 0xD1, 0x00, 0x00, 0x00, 0x48,
	0x8B, 0x4B, 0x08, 0x45, 0x33, 0xC0, 0xB2, 0x01, 0xE8, 0x2D, 0x01, 0x00,
	0x00, 0x83, 0x63, 0x30, 0x00, 0x33, 0xFF, 0x48, 0x83, 0x63, 0x38, 0x00,
	0x33, 0xD2, 0x48, 0x8B, 0xCB, 0xFF, 0x15, 0xAD, 0x0D, 0x00, 0x00, 0x48,
	0x8B, 0x5C, 0x24, 0x40, 0x8B, 0xC7, 0x48, 0x83, 0xC4, 0x30, 0x5F, 0xC3,
	0x48, 0x89, 0x5C, 0x24, 0x08, 0x48, 0x89, 0x74, 0x24, 0x10, 0x57, 0x48,
	0x83, 0xEC, 0x50, 0x49, 0x8B, 0xD9, 0x49, 0x8B, 0xF8, 0x48, 0x8B, 0xF2,
	0x48, 0x8D, 0x54, 0x24, 0x40, 0xFF, 0x15, 0xB5, 0x0D, 0x00, 0x00, 0xFF,
	0x15, 0x9F, 0x0D, 0x00, 0x00, 0x90, 0x48, 0x8D, 0x4C, 0x24, 0x48, 0x48,
	0x89, 0x4C, 0x24, 0x30, 0xC6, 0x44, 0x24, 0x28, 0x00, 0x48, 0x89, 0x5C,
	0x24, 0x20, 0x4C, 0x8B, 0xCF, 0x4C, 0x8B, 0xC0, 0x48, 0x8B, 0xD6, 0x48,
	0x8B, 0x4C, 0x24, 0x40, 0xE8, 0xBF, 0x00, 0x00, 0x00, 0x33, 0xC0, 0xEB,
	0x05, 0xB8, 0x22, 0x00, 0x00, 0xC0, 0x48, 0x8B, 0x5C, 0x24, 0x60, 0x48,
	0x8B, 0x74, 0x24, 0x68, 0x48, 0x83, 0xC4, 0x50, 0x5F, 0xC3, 0xCC, 0xCC,
	0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0x40, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x8B, 0xD9, 0x48, 0x8D, 0x0D,
	0x60, 0x1D, 0x00, 0x00, 0xFF, 0x15, 0x32, 0x0D, 0x00, 0x00, 0x48, 0x8B,
	0x4B, 0x08, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0x48, 0xFF, 0x25, 0x1A, 0x0D,
	0x00, 0x00, 0xCC, 0xCC, 0x48, 0x89, 0x5C, 0x24, 0x08, 0x48, 0x89, 0x74,
	0x24, 0x10, 0x57, 0x48, 0x83, 0xEC, 0x50, 0x49, 0x8B, 0xD9, 0x49, 0x8B,
	0xF8, 0x48, 0x8B, 0xF2, 0x48, 0x8D, 0x54, 0x24, 0x40, 0xFF, 0x15, 0x15,
	0x0D, 0x00, 0x00, 0xFF, 0x15, 0xFF, 0x0C, 0x00, 0x00, 0x90, 0x48, 0x8D,
	0x4C, 0x24, 0x48, 0x48, 0x89, 0x4C, 0x24, 0x30, 0xC6, 0x44, 0x24, 0x28,
	0x00, 0x48, 0x89, 0x5C, 0x24, 0x20, 0x4C, 0x8B, 0xCE, 0x4C, 0x8B, 0x44,
	0x24, 0x40, 0x48, 0x8B, 0xD7, 0x48, 0x8B, 0xC8, 0xE8, 0x1F, 0x00, 0x00,
	0x00, 0x33, 0xC0, 0xEB, 0x05, 0xB8, 0x22, 0x00, 0x00, 0xC0, 0x48, 0x8B,
	0x5C, 0x24, 0x60, 0x48, 0x8B, 0x74, 0x24, 0x68, 0x48, 0x83, 0xC4, 0x50,
	0x5F, 0xC3, 0xFF, 0x25, 0x80, 0x0C, 0x00, 0x00, 0xFF, 0x25, 0xCA, 0x0C,
	0x00, 0x00, 0xFF, 0x25, 0xCC, 0x0C, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC,
	0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC2, 0x00, 0x00, 0xCC,
	0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x66, 0x66, 0x0F, 0x1F, 0x84, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xFF, 0xE0, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x6B, 0x65, 0x72, 0x6E,
	0x65, 0x6C, 0x20, 0x6D, 0x6F, 0x64, 0x20, 0x75, 0x6E, 0x6C, 0x6F, 0x61,
	0x64, 0x69, 0x6E, 0x67, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0xCC, 0xCC, 0xCC, 0xCC, 0x6B, 0x65, 0x72, 0x6E, 0x65, 0x6C, 0x20, 0x6D,
	0x6F, 0x64, 0x20, 0x6C, 0x6F, 0x61, 0x64, 0x65, 0x64, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xF8, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x06, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1A, 0x51, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x3A, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x50, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x62, 0x51, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x7A, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x8C, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA4, 0x51, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xBA, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xD6, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF4, 0x51, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0A, 0x52, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA0, 0x13, 0x00, 0x40,
	0x01, 0x00, 0x00, 0x00, 0xC0, 0x13, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00,
	0x00, 0x10, 0x00, 0x00, 0x40, 0x10, 0x00, 0x00, 0x30, 0x11, 0x00, 0x00,
	0xF0, 0x12, 0x00, 0x00, 0xA0, 0x13, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5C, 0x00, 0x44, 0x00,
	0x65, 0x00, 0x76, 0x00, 0x69, 0x00, 0x63, 0x00, 0x65, 0x00, 0x5C, 0x00,
	0x4B, 0x00, 0x52, 0x00, 0x50, 0x00, 0x4D, 0x00, 0x5F, 0x00, 0x44, 0x00,
	0x72, 0x00, 0x69, 0x00, 0x76, 0x00, 0x65, 0x00, 0x72, 0x00, 0x00, 0x00,
	0x5C, 0x00, 0x44, 0x00, 0x6F, 0x00, 0x73, 0x00, 0x44, 0x00, 0x65, 0x00,
	0x76, 0x00, 0x69, 0x00, 0x63, 0x00, 0x65, 0x00, 0x73, 0x00, 0x5C, 0x00,
	0x4B, 0x00, 0x52, 0x00, 0x50, 0x00, 0x4D, 0x00, 0x5F, 0x00, 0x44, 0x00,
	0x72, 0x00, 0x69, 0x00, 0x76, 0x00, 0x65, 0x00, 0x72, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x45, 0x99, 0x20, 0x5C, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
	0x54, 0x00, 0x00, 0x00, 0x48, 0x22, 0x00, 0x00, 0x48, 0x0C, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x45, 0x99, 0x20, 0x5C, 0x00, 0x00, 0x00, 0x00,
	0x0D, 0x00, 0x00, 0x00, 0x38, 0x01, 0x00, 0x00, 0x9C, 0x22, 0x00, 0x00,
	0x9C, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x20, 0x30, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x70, 0x20, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00,
	0x78, 0x20, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x80, 0x20, 0x00, 0x40,
	0x01, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x45, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x52, 0x53, 0x44, 0x53, 0x9E, 0x56, 0xE0, 0xAA, 0x57, 0x7D, 0xAF, 0x4C,
	0x98, 0x01, 0xCA, 0x94, 0xB9, 0x11, 0xA6, 0xFB, 0x01, 0x00, 0x00, 0x00,
	0x43, 0x3A, 0x5C, 0x55, 0x73, 0x65, 0x72, 0x73, 0x5C, 0x74, 0x65, 0x73,
	0x74, 0x65, 0x72, 0x5C, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x5C, 0x72,
	0x65, 0x70, 0x6F, 0x73, 0x5C, 0x4D, 0x79, 0x44, 0x72, 0x69, 0x76, 0x65,
	0x72, 0x31, 0x5C, 0x78, 0x36, 0x34, 0x5C, 0x52, 0x65, 0x6C, 0x65, 0x61,
	0x73, 0x65, 0x5C, 0x6B, 0x52, 0x70, 0x6D, 0x2E, 0x70, 0x64, 0x62, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0xB0, 0x03, 0x00, 0x00,
	0x2E, 0x74, 0x65, 0x78, 0x74, 0x24, 0x6D, 0x6E, 0x00, 0x00, 0x00, 0x00,
	0xB0, 0x13, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x2E, 0x74, 0x65, 0x78,
	0x74, 0x24, 0x6D, 0x6E, 0x24, 0x30, 0x30, 0x00, 0xD0, 0x13, 0x00, 0x00,
	0x32, 0x00, 0x00, 0x00, 0x2E, 0x74, 0x65, 0x78, 0x74, 0x24, 0x73, 0x00,
	0x00, 0x20, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x2E, 0x69, 0x64, 0x61,
	0x74, 0x61, 0x24, 0x35, 0x00, 0x00, 0x00, 0x00, 0x70, 0x20, 0x00, 0x00,
	0x10, 0x00, 0x00, 0x00, 0x2E, 0x30, 0x30, 0x63, 0x66, 0x67, 0x00, 0x00,
	0x80, 0x20, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x2E, 0x67, 0x66, 0x69,
	0x64, 0x73, 0x00, 0x00, 0xA0, 0x20, 0x00, 0x00, 0xA8, 0x01, 0x00, 0x00,
	0x2E, 0x72, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0x48, 0x22, 0x00, 0x00,
	0x90, 0x01, 0x00, 0x00, 0x2E, 0x72, 0x64, 0x61, 0x74, 0x61, 0x24, 0x7A,
	0x7A, 0x7A, 0x64, 0x62, 0x67, 0x00, 0x00, 0x00, 0xD8, 0x23, 0x00, 0x00,
	0xB4, 0x00, 0x00, 0x00, 0x2E, 0x78, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00,
	0x00, 0x30, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x2E, 0x64, 0x61, 0x74,
	0x61, 0x00, 0x00, 0x00, 0x40, 0x30, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00,
	0x2E, 0x62, 0x73, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00,
	0x6C, 0x00, 0x00, 0x00, 0x2E, 0x70, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00,
	0x00, 0x50, 0x00, 0x00, 0x5C, 0x00, 0x00, 0x00, 0x49, 0x4E, 0x49, 0x54,
	0x00, 0x00, 0x00, 0x00, 0x5C, 0x50, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00,
	0x2E, 0x69, 0x64, 0x61, 0x74, 0x61, 0x24, 0x32, 0x00, 0x00, 0x00, 0x00,
	0x70, 0x50, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x2E, 0x69, 0x64, 0x61,
	0x74, 0x61, 0x24, 0x33, 0x00, 0x00, 0x00, 0x00, 0x88, 0x50, 0x00, 0x00,
	0x70, 0x00, 0x00, 0x00, 0x2E, 0x69, 0x64, 0x61, 0x74, 0x61, 0x24, 0x34,
	0x00, 0x00, 0x00, 0x00, 0xF8, 0x50, 0x00, 0x00, 0x38, 0x01, 0x00, 0x00,
	0x2E, 0x69, 0x64, 0x61, 0x74, 0x61, 0x24, 0x36, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x02, 0x04, 0x03, 0x00, 0x01, 0x16, 0x00, 0x06,
	0x04, 0x42, 0x00, 0x00, 0x02, 0x0A, 0x06, 0x00, 0x02, 0x16, 0x00, 0x06,
	0x0A, 0x34, 0x08, 0x00, 0x0A, 0x52, 0x06, 0x70, 0x02, 0x06, 0x04, 0x00,
	0x02, 0x16, 0x00, 0x06, 0x06, 0x32, 0x02, 0x30, 0x02, 0x06, 0x04, 0x00,
	0x08, 0x16, 0x00, 0x06, 0x06, 0x32, 0x02, 0x30, 0x0A, 0x0F, 0x08, 0x00,
	0x02, 0x16, 0x00, 0x06, 0x0F, 0x64, 0x0D, 0x00, 0x0F, 0x34, 0x0C, 0x00,
	0x0F, 0x92, 0x0B, 0x70, 0x8E, 0x13, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0xA2, 0x12, 0x00, 0x00, 0xCD, 0x12, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0xCD, 0x12, 0x00, 0x00, 0x0A, 0x0F, 0x08, 0x00, 0x02, 0x16, 0x00, 0x06,
	0x0F, 0x64, 0x0D, 0x00, 0x0F, 0x34, 0x0C, 0x00, 0x0F, 0x92, 0x0B, 0x70,
	0x8E, 0x13, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x42, 0x13, 0x00, 0x00,
	0x6D, 0x13, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x6D, 0x13, 0x00, 0x00,
	0x02, 0x0A, 0x06, 0x00, 0x02, 0x16, 0x00, 0x06, 0x0A, 0x34, 0x0A, 0x00,
	0x0A, 0x72, 0x06, 0x70, 0x02, 0x0A, 0x06, 0x00, 0x02, 0x16, 0x00, 0x06,
	0x0A, 0x34, 0x06, 0x00, 0x0A, 0x32, 0x06, 0x70, 0x00, 0x00, 0x00, 0x00,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x26, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xA0, 0x20, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x2E, 0x00, 0x30, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xC8, 0x20, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00,
	0x32, 0xA2, 0xDF, 0x2D, 0x99, 0x2B, 0x00, 0x00, 0xCD, 0x5D, 0x20, 0xD2,
	0x66, 0xD4, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x10, 0x00, 0x00, 0x37, 0x10, 0x00, 0x00, 0xF4, 0x23, 0x00, 0x00,
	0x40, 0x10, 0x00, 0x00, 0x5F, 0x10, 0x00, 0x00, 0xD8, 0x23, 0x00, 0x00,
	0x60, 0x10, 0x00, 0x00, 0x25, 0x11, 0x00, 0x00, 0x64, 0x24, 0x00, 0x00,
	0x30, 0x11, 0x00, 0x00, 0x78, 0x12, 0x00, 0x00, 0xE4, 0x23, 0x00, 0x00,
	0x78, 0x12, 0x00, 0x00, 0xE2, 0x12, 0x00, 0x00, 0x0C, 0x24, 0x00, 0x00,
	0xF0, 0x12, 0x00, 0x00, 0x16, 0x13, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00,
	0x18, 0x13, 0x00, 0x00, 0x82, 0x13, 0x00, 0x00, 0x38, 0x24, 0x00, 0x00,
	0xC0, 0x13, 0x00, 0x00, 0xC5, 0x13, 0x00, 0x00, 0x88, 0x24, 0x00, 0x00,
	0x00, 0x50, 0x00, 0x00, 0x2B, 0x50, 0x00, 0x00, 0x74, 0x24, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x89, 0x5C, 0x24,
	0x08, 0x57, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x8B, 0xDA, 0x48, 0x8B, 0xF9,
	0xE8, 0x17, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xD3, 0x48, 0x8B, 0xCF, 0xE8,
	0x40, 0xC0, 0xFF, 0xFF, 0x48, 0x8B, 0x5C, 0x24, 0x30, 0x48, 0x83, 0xC4,
	0x20, 0x5F, 0xC3, 0xCC, 0x48, 0x8B, 0x05, 0xED, 0xDF, 0xFF, 0xFF, 0x48,
	0x85, 0xC0, 0x74, 0x1A, 0x48, 0xB9, 0x32, 0xA2, 0xDF, 0x2D, 0x99, 0x2B,
	0x00, 0x00, 0x48, 0x3B, 0xC1, 0x74, 0x0B, 0x48, 0xF7, 0xD0, 0x48, 0x89,
	0x05, 0xD7, 0xDF, 0xFF, 0xFF, 0xC3, 0xB9, 0x06, 0x00, 0x00, 0x00, 0xCD,
	0x29, 0xCC, 0xCC, 0xCC, 0x88, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x22, 0x52, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xF8, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x51, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x1A, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x3A, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x51, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x62, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x7A, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8C, 0x51, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xA4, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xBA, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD6, 0x51, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xF4, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0A, 0x52, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x5A, 0x00, 0x44, 0x62, 0x67, 0x50, 0x72, 0x69,
	0x6E, 0x74, 0x45, 0x78, 0x00, 0x00, 0x01, 0x04, 0x4B, 0x65, 0x46, 0x6C,
	0x75, 0x73, 0x68, 0x49, 0x6F, 0x42, 0x75, 0x66, 0x66, 0x65, 0x72, 0x73,
	0x00, 0x00, 0x28, 0x05, 0x4D, 0x6D, 0x4D, 0x61, 0x70, 0x4C, 0x6F, 0x63,
	0x6B, 0x65, 0x64, 0x50, 0x61, 0x67, 0x65, 0x73, 0x53, 0x70, 0x65, 0x63,
	0x69, 0x66, 0x79, 0x43, 0x61, 0x63, 0x68, 0x65, 0x00, 0x00, 0xAA, 0x03,
	0x49, 0x6F, 0x66, 0x43, 0x6F, 0x6D, 0x70, 0x6C, 0x65, 0x74, 0x65, 0x52,
	0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x00, 0x00, 0x93, 0x02, 0x49, 0x6F,
	0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65,
	0x00, 0x00, 0x9E, 0x02, 0x49, 0x6F, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65,
	0x53, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x69, 0x63, 0x4C, 0x69, 0x6E, 0x6B,
	0x00, 0x00, 0xAA, 0x02, 0x49, 0x6F, 0x44, 0x65, 0x6C, 0x65, 0x74, 0x65,
	0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x00, 0x00, 0xAC, 0x02, 0x49, 0x6F,
	0x44, 0x65, 0x6C, 0x65, 0x74, 0x65, 0x53, 0x79, 0x6D, 0x62, 0x6F, 0x6C,
	0x69, 0x63, 0x4C, 0x69, 0x6E, 0x6B, 0x00, 0x00, 0xCE, 0x02, 0x49, 0x6F,
	0x47, 0x65, 0x74, 0x43, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x50, 0x72,
	0x6F, 0x63, 0x65, 0x73, 0x73, 0x00, 0x52, 0x03, 0x49, 0x6F, 0x53, 0x65,
	0x74, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x49, 0x6E, 0x74, 0x65, 0x72,
	0x66, 0x61, 0x63, 0x65, 0x53, 0x74, 0x61, 0x74, 0x65, 0x00, 0xD6, 0x06,
	0x50, 0x73, 0x4C, 0x6F, 0x6F, 0x6B, 0x75, 0x70, 0x50, 0x72, 0x6F, 0x63,
	0x65, 0x73, 0x73, 0x42, 0x79, 0x50, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73,
	0x49, 0x64, 0x00, 0x00, 0xFE, 0x04, 0x4D, 0x6D, 0x43, 0x6F, 0x70, 0x79,
	0x56, 0x69, 0x72, 0x74, 0x75, 0x61, 0x6C, 0x4D, 0x65, 0x6D, 0x6F, 0x72,
	0x79, 0x00, 0xBB, 0x0A, 0x5F, 0x5F, 0x43, 0x5F, 0x73, 0x70, 0x65, 0x63,
	0x69, 0x66, 0x69, 0x63, 0x5F, 0x68, 0x61, 0x6E, 0x64, 0x6C, 0x65, 0x72,
	0x00, 0x00, 0x6E, 0x74, 0x6F, 0x73, 0x6B, 0x72, 0x6E, 0x6C, 0x2E, 0x65,
	0x78, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x20, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x70, 0xA0, 0x78, 0xA0,
	0x98, 0xA1, 0xB0, 0xA1, 0xB8, 0xA1, 0xC0, 0xA1, 0x00, 0x30, 0x00, 0x00,
	0x0C, 0x00, 0x00, 0x00, 0x08, 0xA0, 0x18, 0xA0, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x06, 0x00, 0x00,
	0x00, 0x02, 0x02, 0x00, 0x30, 0x82, 0x06, 0x5E, 0x06, 0x09, 0x2A, 0x86,
	0x48, 0x86, 0xF7, 0x0D, 0x01, 0x07, 0x02, 0xA0, 0x82, 0x06, 0x4F, 0x30,
	0x82, 0x06, 0x4B, 0x02, 0x01, 0x01, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x05,
	0x2B, 0x0E, 0x03, 0x02, 0x1A, 0x05, 0x00, 0x30, 0x82, 0x01, 0x40, 0x06,
	0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x02, 0x01, 0x04, 0xA0,
	0x82, 0x01, 0x30, 0x30, 0x82, 0x01, 0x2C, 0x30, 0x82, 0x01, 0x05, 0x06,
	0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x02, 0x01, 0x0F, 0x30,
	0x81, 0xF6, 0x03, 0x01, 0x00, 0xA0, 0x81, 0xF0, 0xA1, 0x81, 0xED, 0x04,
	0x10, 0xA6, 0xB5, 0x86, 0xD5, 0xB4, 0xA1, 0x24, 0x66, 0xAE, 0x05, 0xA2,
	0x17, 0xDA, 0x8E, 0x60, 0xD6, 0x04, 0x81, 0xD8, 0x31, 0x81, 0xD5, 0x30,
	0x81, 0xD2, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x02,
	0x03, 0x01, 0x31, 0x81, 0xC3, 0x04, 0x81, 0xC0, 0x00, 0x00, 0x00, 0x00,
	0x78, 0xAE, 0x31, 0x8B, 0x4F, 0x20, 0xA3, 0xC1, 0xD9, 0x5B, 0xF6, 0xFE,
	0x59, 0x14, 0x57, 0x44, 0x11, 0x9C, 0x94, 0x24, 0x00, 0x04, 0x00, 0x00,
	0x3D, 0x1A, 0x6A, 0x7E, 0x78, 0xF9, 0x02, 0xF2, 0xAB, 0x56, 0x28, 0xE5,
	0xB8, 0x9A, 0x34, 0x21, 0x23, 0xCB, 0x8D, 0xB8, 0x00, 0x0A, 0x00, 0x00,
	0xCF, 0x78, 0x4B, 0x82, 0x97, 0xB0, 0xAB, 0x63, 0x0A, 0x64, 0xB6, 0x4D,
	0x4B, 0x93, 0xA0, 0x94, 0xB9, 0x26, 0xBE, 0xA1, 0x00, 0x10, 0x00, 0x00,
	0xBE, 0xA0, 0x6E, 0xD5, 0x69, 0xFC, 0x96, 0x39, 0xE3, 0xB0, 0xAB, 0x45,
	0x48, 0x7E, 0x5F, 0xD2, 0x51, 0x29, 0x40, 0xBD, 0x00, 0x12, 0x00, 0x00,
	0x09, 0x94, 0x26, 0xDE, 0x28, 0x1D, 0x47, 0xEE, 0x12, 0x72, 0x04, 0x46,
	0x44, 0x60, 0xD5, 0x10, 0x24, 0x00, 0x4E, 0x4D, 0x00, 0x14, 0x00, 0x00,
	0xDE, 0xFC, 0x4E, 0x67, 0xA5, 0x93, 0x58, 0x6E, 0x42, 0x81, 0x3C, 0xB6,
	0xB5, 0x3F, 0x8C, 0x9B, 0x16, 0xFD, 0x47, 0x7D, 0x00, 0x18, 0x00, 0x00,
	0xBF, 0xC1, 0xDA, 0x56, 0xC9, 0x6C, 0x1C, 0xEC, 0xA7, 0xFB, 0x77, 0xA2,
	0x31, 0xFE, 0xF8, 0xE1, 0x54, 0x57, 0x8F, 0x6B, 0x00, 0x1A, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x21, 0x30, 0x09,
	0x06, 0x05, 0x2B, 0x0E, 0x03, 0x02, 0x1A, 0x05, 0x00, 0x04, 0x14, 0x2F,
	0xB9, 0x30, 0xF7, 0x99, 0xD9, 0xB2, 0xF7, 0xBB, 0x13, 0x2B, 0x23, 0xF6,
	0x90, 0xC0, 0x18, 0x64, 0x6C, 0x2F, 0x07, 0xA0, 0x82, 0x03, 0x12, 0x30,
	0x82, 0x03, 0x0E, 0x30, 0x82, 0x01, 0xF6, 0xA0, 0x03, 0x02, 0x01, 0x02,
	0x02, 0x10, 0x3C, 0x97, 0x6A, 0x9E, 0x99, 0x10, 0x37, 0xB3, 0x48, 0x81,
	0xCA, 0xDA, 0x7C, 0xEC, 0xCB, 0xC3, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86,
	0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05, 0x05, 0x00, 0x30, 0x30, 0x31,
	0x2E, 0x30, 0x2C, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x25, 0x57, 0x44,
	0x4B, 0x54, 0x65, 0x73, 0x74, 0x43, 0x65, 0x72, 0x74, 0x20, 0x74, 0x65,
	0x73, 0x74, 0x65, 0x72, 0x2C, 0x31, 0x33, 0x31, 0x38, 0x38, 0x33, 0x30,
	0x30, 0x31, 0x33, 0x31, 0x32, 0x38, 0x34, 0x36, 0x30, 0x34, 0x38, 0x30,
	0x1E, 0x17, 0x0D, 0x31, 0x38, 0x31, 0x32, 0x30, 0x33, 0x30, 0x38, 0x34,
	0x32, 0x31, 0x32, 0x5A, 0x17, 0x0D, 0x32, 0x38, 0x31, 0x32, 0x30, 0x33,
	0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x5A, 0x30, 0x30, 0x31, 0x2E, 0x30,
	0x2C, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x25, 0x57, 0x44, 0x4B, 0x54,
	0x65, 0x73, 0x74, 0x43, 0x65, 0x72, 0x74, 0x20, 0x74, 0x65, 0x73, 0x74,
	0x65, 0x72, 0x2C, 0x31, 0x33, 0x31, 0x38, 0x38, 0x33, 0x30, 0x30, 0x31,
	0x33, 0x31, 0x32, 0x38, 0x34, 0x36, 0x30, 0x34, 0x38, 0x30, 0x82, 0x01,
	0x22, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01,
	0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0F, 0x00, 0x30, 0x82, 0x01,
	0x0A, 0x02, 0x82, 0x01, 0x01, 0x00, 0xCE, 0x88, 0x95, 0x8C, 0x55, 0x4A,
	0xD2, 0xCB, 0x33, 0xAF, 0xA1, 0xE5, 0x61, 0x7C, 0x30, 0x5A, 0xD6, 0x20,
	0x7E, 0x7F, 0xED, 0xA8, 0xE3, 0xCF, 0xF9, 0x4F, 0x7B, 0x25, 0x07, 0x74,
	0xE9, 0xDB, 0x71, 0xE0, 0xE8, 0xC0, 0xB2, 0x30, 0x16, 0xE8, 0xD9, 0x82,
	0x09, 0x0A, 0x61, 0x37, 0x40, 0x9C, 0xC6, 0x52, 0x7D, 0xF3, 0xD7, 0x24,
	0xEE, 0x08, 0x51, 0x21, 0x87, 0xD2, 0x34, 0x58, 0x3C, 0xE2, 0x17, 0xA1,
	0x84, 0x2F, 0x4E, 0x0A, 0x70, 0x17, 0x19, 0x34, 0x26, 0xD6, 0x91, 0xD3,
	0x0D, 0x98, 0xB3, 0x79, 0x01, 0x02, 0xF7, 0x01, 0x35, 0xB6, 0x7B, 0x35,
	0x7C, 0x26, 0x01, 0x8E, 0xB4, 0x4B, 0xC3, 0x3E, 0x80, 0x48, 0x2E, 0x69,
	0x94, 0x1A, 0xF8, 0x22, 0xF2, 0x0E, 0xB4, 0x8B, 0x0D, 0xED, 0x4F, 0x5B,
	0x35, 0x00, 0x2A, 0x72, 0x8B, 0xEE, 0x27, 0xDB, 0x92, 0x1A, 0xDB, 0x7E,
	0x1B, 0xA9, 0x61, 0x28, 0xC7, 0x6E, 0x6C, 0x1E, 0xD0, 0x4F, 0xD9, 0xBF,
	0x3C, 0x42, 0x89, 0xEC, 0x43, 0x24, 0xDD, 0x2A, 0x18, 0x5B, 0x39, 0x2B,
	0x5F, 0xDD, 0x74, 0x88, 0x65, 0x77, 0x78, 0xE1, 0xC1, 0x45, 0xA3, 0x6B,
	0x6E, 0x38, 0xD8, 0xC7, 0x2F, 0x7F, 0x6E, 0xE6, 0x5E, 0x5C, 0xF4, 0x66,
	0x31, 0x50, 0xBE, 0x6E, 0x1C, 0xC1, 0x56, 0xCB, 0x6E, 0x00, 0xCE, 0xDB,
	0x83, 0x30, 0x43, 0x9E, 0x60, 0x63, 0x0F, 0xDB, 0x4A, 0x01, 0x44, 0x6D,
	0xAD, 0xFC, 0x6A, 0xBC, 0x05, 0xCA, 0xEA, 0x9F, 0x0D, 0x84, 0x11, 0x3B,
	0x8C, 0x9D, 0x55, 0x49, 0xA8, 0xB2, 0x73, 0x6F, 0xBE, 0xA0, 0xCB, 0x8A,
	0xF7, 0x2F, 0x64, 0x14, 0x5E, 0x70, 0x54, 0x0F, 0x65, 0xE2, 0x26, 0x6D,
	0xAF, 0xC4, 0xC3, 0x8D, 0xDD, 0x2B, 0x68, 0xBE, 0xF1, 0x20, 0xF1, 0x60,
	0x71, 0x4B, 0x71, 0x83, 0xA5, 0x71, 0xC7, 0xF3, 0x8D, 0xB1, 0x02, 0x03,
	0x01, 0x00, 0x01, 0xA3, 0x24, 0x30, 0x22, 0x30, 0x0B, 0x06, 0x03, 0x55,
	0x1D, 0x0F, 0x04, 0x04, 0x03, 0x02, 0x04, 0x30, 0x30, 0x13, 0x06, 0x03,
	0x55, 0x1D, 0x25, 0x04, 0x0C, 0x30, 0x0A, 0x06, 0x08, 0x2B, 0x06, 0x01,
	0x05, 0x05, 0x07, 0x03, 0x03, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48,
	0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05, 0x05, 0x00, 0x03, 0x82, 0x01, 0x01,
	0x00, 0xCC, 0x5A, 0xF7, 0x65, 0x7E, 0x32, 0xD9, 0xF7, 0x21, 0x5F, 0x7E,
	0x24, 0xA7, 0x2D, 0xAE, 0x2A, 0x89, 0x6F, 0xC3, 0x03, 0xEB, 0xE6, 0xE9,
	0xAF, 0x44, 0x40, 0xE8, 0x9A, 0xD0, 0x39, 0xA4, 0x72, 0x85, 0x13, 0xB1,
	0xBB, 0xAD, 0x88, 0x7A, 0x44, 0x08, 0xB8, 0x5F, 0x24, 0xA3, 0xB4, 0xC8,
	0x3F, 0x7F, 0xB5, 0xCF, 0x10, 0x8D, 0x1B, 0xAB, 0x69, 0x03, 0x04, 0x1B,
	0x11, 0x82, 0x01, 0xDD, 0xAF, 0xC0, 0xD4, 0xFA, 0x38, 0xAC, 0xEC, 0x7E,
	0x79, 0xED, 0x44, 0x16, 0x80, 0x43, 0x30, 0x92, 0x6B, 0x38, 0xF2, 0xB0,
	0x18, 0xF1, 0x61, 0x2E, 0x09, 0x58, 0xB5, 0xE1, 0x87, 0xA3, 0xD7, 0xC0,
	0x04, 0x1A, 0x07, 0xC8, 0x92, 0x29, 0x2C, 0x64, 0x57, 0xFA, 0x56, 0xF9,
	0xC6, 0x51, 0x46, 0xFE, 0xE7, 0x6F, 0xAF, 0xB3, 0x31, 0xDD, 0xE8, 0x76,
	0x4F, 0x8E, 0x13, 0xA6, 0x41, 0xFD, 0x44, 0x45, 0xB6, 0xC4, 0xD7, 0x5F,
	0xEE, 0xCA, 0x23, 0x00, 0x26, 0x4C, 0x70, 0x7B, 0x17, 0x2E, 0x07, 0x39,
	0x65, 0xE1, 0x58, 0x0F, 0xCA, 0x16, 0x84, 0x96, 0x61, 0xE6, 0x71, 0xBB,
	0x41, 0x02, 0x7A, 0x5E, 0x3E, 0x65, 0xCC, 0x7E, 0x61, 0x16, 0x2E, 0x58,
	0x0A, 0x4A, 0x25, 0x42, 0x36, 0x1C, 0xF7, 0x5A, 0xDE, 0x64, 0x46, 0x9A,
	0xFA, 0xD6, 0x5B, 0x4C, 0xE2, 0x99, 0x01, 0x8C, 0x32, 0xE0, 0x2C, 0x6F,
	0x5D, 0xA5, 0x60, 0x8C, 0x53, 0x48, 0xF0, 0xE7, 0x46, 0x27, 0xA0, 0xC3,
	0x80, 0xDC, 0x64, 0xA7, 0xCC, 0x16, 0x5D, 0x71, 0x48, 0xF0, 0x78, 0x0E,
	0xED, 0xD9, 0x3B, 0xCD, 0xBD, 0xA5, 0x36, 0xDC, 0xD9, 0x93, 0x71, 0xE1,
	0x6A, 0x08, 0xAF, 0x0A, 0x03, 0xBF, 0xF1, 0x94, 0xD9, 0x8E, 0xC1, 0xA1,
	0x8A, 0xF6, 0xDD, 0x17, 0xA4, 0xCA, 0x9D, 0x81, 0xB1, 0x94, 0xAB, 0x36,
	0xB0, 0x3D, 0x6E, 0xEB, 0x96, 0x31, 0x82, 0x01, 0xDD, 0x30, 0x82, 0x01,
	0xD9, 0x02, 0x01, 0x01, 0x30, 0x44, 0x30, 0x30, 0x31, 0x2E, 0x30, 0x2C,
	0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x25, 0x57, 0x44, 0x4B, 0x54, 0x65,
	0x73, 0x74, 0x43, 0x65, 0x72, 0x74, 0x20, 0x74, 0x65, 0x73, 0x74, 0x65,
	0x72, 0x2C, 0x31, 0x33, 0x31, 0x38, 0x38, 0x33, 0x30, 0x30, 0x31, 0x33,
	0x31, 0x32, 0x38, 0x34, 0x36, 0x30, 0x34, 0x38, 0x02, 0x10, 0x3C, 0x97,
	0x6A, 0x9E, 0x99, 0x10, 0x37, 0xB3, 0x48, 0x81, 0xCA, 0xDA, 0x7C, 0xEC,
	0xCB, 0xC3, 0x30, 0x09, 0x06, 0x05, 0x2B, 0x0E, 0x03, 0x02, 0x1A, 0x05,
	0x00, 0xA0, 0x70, 0x30, 0x10, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01,
	0x82, 0x37, 0x02, 0x01, 0x0C, 0x31, 0x02, 0x30, 0x00, 0x30, 0x19, 0x06,
	0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x09, 0x03, 0x31, 0x0C,
	0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x02, 0x01, 0x04,
	0x30, 0x1C, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x02,
	0x01, 0x0B, 0x31, 0x0E, 0x30, 0x0C, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04,
	0x01, 0x82, 0x37, 0x02, 0x01, 0x15, 0x30, 0x23, 0x06, 0x09, 0x2A, 0x86,
	0x48, 0x86, 0xF7, 0x0D, 0x01, 0x09, 0x04, 0x31, 0x16, 0x04, 0x14, 0x50,
	0x15, 0x3D, 0xE9, 0x4A, 0xC3, 0xD0, 0x5C, 0xBA, 0x16, 0x2D, 0xB0, 0xA2,
	0xEE, 0xF2, 0xC7, 0x3C, 0xF9, 0x33, 0x6B, 0x30, 0x0D, 0x06, 0x09, 0x2A,
	0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x04, 0x82,
	0x01, 0x00, 0x4F, 0x3A, 0x2C, 0xD9, 0x27, 0xFE, 0xC7, 0x88, 0x37, 0x15,
	0x28, 0xEE, 0x21, 0x69, 0x7F, 0x04, 0xE0, 0x9B, 0xB0, 0x9D, 0xBB, 0xC2,
	0x11, 0x1F, 0xD9, 0x0D, 0x90, 0xB9, 0x9A, 0x4A, 0xA2, 0x8A, 0x61, 0x16,
	0x47, 0x32, 0xDA, 0xA6, 0x21, 0xFC, 0x35, 0xE0, 0x38, 0xF0, 0x44, 0x61,
	0x1B, 0x17, 0x5C, 0x3F, 0xD1, 0x92, 0xAB, 0x5D, 0x85, 0x70, 0xC7, 0xD3,
	0x5D, 0xD0, 0xE3, 0xB8, 0x21, 0x26, 0x4E, 0x42, 0xB6, 0x5F, 0xED, 0x33,
	0xB1, 0x71, 0x51, 0xB2, 0x62, 0xB1, 0xFC, 0xEE, 0x38, 0x64, 0x81, 0xF6,
	0xA6, 0xB1, 0x82, 0xEB, 0x2D, 0xEC, 0x5B, 0x98, 0x50, 0x6B, 0x82, 0x4D,
	0x12, 0x98, 0x6E, 0xFD, 0x71, 0x61, 0xA0, 0xED, 0x87, 0x7D, 0x57, 0xB8,
	0x16, 0x1D, 0x01, 0x89, 0xF9, 0x8F, 0xAC, 0xF5, 0x23, 0x79, 0x5E, 0x34,
	0x19, 0x52, 0xBC, 0xD8, 0x5C, 0xAB, 0x2D, 0x06, 0x21, 0x19, 0x5E, 0x58,
	0xE8, 0x61, 0x85, 0xCD, 0x10, 0xBC, 0x20, 0xBD, 0x71, 0x29, 0xFC, 0x92,
	0xD9, 0xA4, 0x31, 0x1D, 0xE6, 0xD1, 0x83, 0x23, 0x34, 0xA4, 0xB5, 0x92,
	0x04, 0x4F, 0x63, 0xFB, 0x47, 0xFB, 0xD1, 0x97, 0x10, 0x56, 0x36, 0x02,
	0x78, 0xE7, 0x1D, 0x31, 0x17, 0x6E, 0x2F, 0xC6, 0x22, 0x9D, 0xC1, 0x61,
	0xFB, 0x73, 0xC0, 0x82, 0x40, 0xEC, 0xA7, 0x79, 0xE6, 0x4E, 0x17, 0x3C,
	0x90, 0x52, 0x0C, 0xEA, 0x4D, 0x95, 0x33, 0x93, 0xB6, 0x0C, 0x4C, 0xA2,
	0x74, 0x8F, 0xC1, 0xDD, 0x20, 0x72, 0x08, 0xAF, 0xCA, 0xCB, 0x97, 0xB9,
	0x8F, 0xB5, 0x75, 0xF5, 0x4D, 0x95, 0xC5, 0x2A, 0x55, 0x07, 0xAC, 0xE7,
	0xB6, 0xFF, 0x2D, 0xFB, 0x55, 0x4E, 0x95, 0xD9, 0xCB, 0x28, 0x3F, 0x43,
	0x06, 0xDE, 0x86, 0x68, 0xB8, 0x7A, 0x72, 0x33, 0x5F, 0x66, 0x49, 0x4D,
	0xD9, 0xFC, 0x0E, 0x29, 0x6F, 0xE5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

```

`ioctl-um/Driver.h`:

```h
#include <stdio.h>
#include <Windows.h>
#include <winioctl.h>
#include <string>
#include <Winternl.h>
#include <iostream>
#include <fstream>
#include <assert.h>
#pragma comment(lib, "ntdll.lib")
#pragma warning(disable: 4996)
#define IOCTL_READ_MEM CTL_CODE(FILE_DEVICE_UNKNOWN, 0x999, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)
#define IOCTL_WRITE_MEM CTL_CODE(FILE_DEVICE_UNKNOWN, 0x998, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)
#define DRIVER_NAME L"\\\\.\\KRPM_Driver"

EXTERN_C NTSTATUS NTAPI NtReadVirtualMemory(HANDLE, PVOID, PVOID, ULONG, PULONG);
EXTERN_C NTSTATUS NTAPI NtWriteVirtualMemory(HANDLE, PVOID, PVOID, ULONG, PULONG);

//#pragma comment(lib, "MoaRpm.lib")

class MoaRpm {
public:
	static enum MOA_MODE {
		STANDARD,
		NTDLL,
		KERNEL
	};
private:
	DWORD pID;
	HANDLE hProcess;
	MOA_MODE mode = MOA_MODE::STANDARD;
	BOOL load_driver(std::string TargetDriver, std::string TargetServiceName, std::string TargetServiceDesc);

	BOOL delete_service(std::string TargetServiceName);
	std::string exePath();
	bool isElevated();

	bool isTestMode();
	const static unsigned char rawDriver[8304];
	void init(DWORD pID, MOA_MODE AccessMode);
public:
	MoaRpm(DWORD pID, MOA_MODE AccessMode);
	MoaRpm(const char* windowname, MOA_MODE AccessMode);
	~MoaRpm();
	void readRaw(LPCVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesRead);
	bool writeRaw(LPCVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesRead);

	template <class cData>
	cData read(DWORD_PTR Address);

	template <class cData>
	bool write(DWORD_PTR Address, cData buffer);

	template<class CharT = char>
	std::basic_string<CharT> readString(DWORD_PTR address, size_t max_length = 256);
};

template <class cData>
cData MoaRpm::read(DWORD_PTR Address) {
	cData B;
	SIZE_T bytesRead;
	this->readRaw((LPCVOID)Address, &B, sizeof(B), &bytesRead);
	return B;
}

template <class cData>
bool MoaRpm::write(DWORD_PTR Address, cData buffer) {
	SIZE_T bytesRead;
	this->writeRaw((LPCVOID)Address, &buffer, sizeof(cData), &bytesRead);
	return true;
}

template<class CharT>
std::basic_string<CharT> MoaRpm::readString(DWORD_PTR address, size_t max_length)
{
	std::basic_string<CharT> str(max_length, CharT());
	SIZE_T bytesRead;
	this->readRaw((LPVOID)address, &str[0], sizeof(CharT) * max_length, &bytesRead);
	auto it = str.find(CharT());
	if (it == str.npos) str.clear();
	else str.resize(it);
	return str;
}
```

`ioctl-um/Main.cpp`:

```cpp
#include "Driver.h"
#include <iostream>

int main()
{
	//	MoaRpm rpm("star wars battlefront", MoaRpm::MOA_MODE::KERNEL);
	MoaRpm rpm("star wars battlefront", MoaRpm::MOA_MODE::NTDLL);
	//MoaRpm rpm("star wars battlefront", MoaRpm::MOA_MODE::STANDARD);
	auto pGameContext = rpm.read<DWORD_PTR>(0x142AE8080);
	auto pPlayerManager = rpm.read<DWORD_PTR>(pGameContext + 0x68);
	auto pLocalPlayer = rpm.read<DWORD_PTR>(pPlayerManager + 0x550);
	auto pLocalSoldier = rpm.read<DWORD_PTR>(pLocalPlayer + 0x2cb8);
	rpm.write<byte>(pLocalSoldier + 0x02AC, 241);
	auto playerName = rpm.readString(rpm.read<DWORD_PTR>(pLocalPlayer + 0x18));
	std::cout << "player name\t" << playerName << std::endl;
	getchar();
	return 0;
}

```

`ioctl-um/ioctl-um.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{D64D1DF6-F132-4957-8F6E-514271F88934}</ProjectGuid>
    <RootNamespace>ioctlum</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="Driver.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Driver.cpp" />
    <ClCompile Include="Main.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`ioctl-um/ioctl-um.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="Driver.cpp" />
    <ClCompile Include="Main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Driver.h" />
  </ItemGroup>
</Project>
```

`km-um-communication.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.29209.152
MinimumVisualStudioVersion = 10.0.40219.1
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "callback", "callback", "{43D6F9D6-4AB0-4125-BC60-0463A28341E8}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "ioctl", "ioctl", "{E6164A0B-35FA-4902-B940-C4765FD62334}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "shared-memory", "shared-memory", "{CF30BA8D-2D2C-4D65-AF53-BB6ECB2B04AE}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "socket", "socket", "{EF2228E9-38EE-4A65-A210-6AD68B3F27C9}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "callback-km", "callback-km\callback-km.vcxproj", "{4B4C81B1-150A-4EAE-80BD-B42EDC19D1A8}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ioctl-km", "ioctl-km\ioctl-km.vcxproj", "{8C20051E-9D3A-46AF-8F7A-320262A9DCED}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "shared-memory-km", "shared-memory-km\shared-memory-km.vcxproj", "{89672149-9CFF-48A1-A2B3-F9578A8E1E95}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "socket-km", "socket-km\socket-km.vcxproj", "{1BB91B25-67A5-4CB7-8379-DF7C886CE06A}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "callback-um", "callback-um\callback-um.vcxproj", "{667DC8CB-B5E1-4473-8FED-3DE15D72AE5F}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ioctl-um", "ioctl-um\ioctl-um.vcxproj", "{D64D1DF6-F132-4957-8F6E-514271F88934}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "shared-memory-um", "shared-memory-um\shared-memory-um.vcxproj", "{1EEF30F8-1723-49B9-BFEA-2F9075F6638F}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "socket-um", "socket-um\socket-um.vcxproj", "{DDCB0847-184C-4769-8713-A3006A6AF794}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "dispatch", "dispatch", "{20E262E3-AF8F-4B6A-B9D6-F75646F3AC0D}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "named-pipe", "named-pipe", "{B599320D-C9DF-4ED8-A421-AAB2BFDBE177}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "dispatch-um", "dispatch-um\dispatch-um.vcxproj", "{F7341DC6-DD9E-476A-A59A-8D8DB95903F4}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "dispatch-km", "dispatch-km\dispatch-km.vcxproj", "{FD57C3F9-DFDE-4B34-9BEF-1B7C9EC4D582}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "named-pipe-km", "named-pipe-km\named-pipe-km.vcxproj", "{D70338B7-7C40-4A0C-8E50-4FDD68E15C18}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "named-pipe-um", "named-pipe-um\named-pipe-um.vcxproj", "{364E311D-7EF9-4A33-A831-5A0F646C0467}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{4B4C81B1-150A-4EAE-80BD-B42EDC19D1A8}.Debug|ARM.ActiveCfg = Debug|ARM
		{4B4C81B1-150A-4EAE-80BD-B42EDC19D1A8}.Debug|ARM.Build.0 = Debug|ARM
		{4B4C81B1-150A-4EAE-80BD-B42EDC19D1A8}.Debug|ARM.Deploy.0 = Debug|ARM
		{4B4C81B1-150A-4EAE-80BD-B42EDC19D1A8}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{4B4C81B1-150A-4EAE-80BD-B42EDC19D1A8}.Debug|ARM64.Build.0 = Debug|ARM64
		{4B4C81B1-150A-4EAE-80BD-B42EDC19D1A8}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{4B4C81B1-150A-4EAE-80BD-B42EDC19D1A8}.Debug|x64.ActiveCfg = Debug|x64
		{4B4C81B1-150A-4EAE-80BD-B42EDC19D1A8}.Debug|x64.Build.0 = Debug|x64
		{4B4C81B1-150A-4EAE-80BD-B42EDC19D1A8}.Debug|x64.Deploy.0 = Debug|x64
		{4B4C81B1-150A-4EAE-80BD-B42EDC19D1A8}.Debug|x86.ActiveCfg = Debug|Win32
		{4B4C81B1-150A-4EAE-80BD-B42EDC19D1A8}.Debug|x86.Build.0 = Debug|Win32
		{4B4C81B1-150A-4EAE-80BD-B42EDC19D1A8}.Debug|x86.Deploy.0 = Debug|Win32
		{4B4C81B1-150A-4EAE-80BD-B42EDC19D1A8}.Release|ARM.ActiveCfg = Release|ARM
		{4B4C81B1-150A-4EAE-80BD-B42EDC19D1A8}.Release|ARM.Build.0 = Release|ARM
		{4B4C81B1-150A-4EAE-80BD-B42EDC19D1A8}.Release|ARM.Deploy.0 = Release|ARM
		{4B4C81B1-150A-4EAE-80BD-B42EDC19D1A8}.Release|ARM64.ActiveCfg = Release|ARM64
		{4B4C81B1-150A-4EAE-80BD-B42EDC19D1A8}.Release|ARM64.Build.0 = Release|ARM64
		{4B4C81B1-150A-4EAE-80BD-B42EDC19D1A8}.Release|ARM64.Deploy.0 = Release|ARM64
		{4B4C81B1-150A-4EAE-80BD-B42EDC19D1A8}.Release|x64.ActiveCfg = Release|x64
		{4B4C81B1-150A-4EAE-80BD-B42EDC19D1A8}.Release|x64.Build.0 = Release|x64
		{4B4C81B1-150A-4EAE-80BD-B42EDC19D1A8}.Release|x64.Deploy.0 = Release|x64
		{4B4C81B1-150A-4EAE-80BD-B42EDC19D1A8}.Release|x86.ActiveCfg = Release|Win32
		{4B4C81B1-150A-4EAE-80BD-B42EDC19D1A8}.Release|x86.Build.0 = Release|Win32
		{4B4C81B1-150A-4EAE-80BD-B42EDC19D1A8}.Release|x86.Deploy.0 = Release|Win32
		{8C20051E-9D3A-46AF-8F7A-320262A9DCED}.Debug|ARM.ActiveCfg = Debug|ARM
		{8C20051E-9D3A-46AF-8F7A-320262A9DCED}.Debug|ARM.Build.0 = Debug|ARM
		{8C20051E-9D3A-46AF-8F7A-320262A9DCED}.Debug|ARM.Deploy.0 = Debug|ARM
		{8C20051E-9D3A-46AF-8F7A-320262A9DCED}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{8C20051E-9D3A-46AF-8F7A-320262A9DCED}.Debug|ARM64.Build.0 = Debug|ARM64
		{8C20051E-9D3A-46AF-8F7A-320262A9DCED}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{8C20051E-9D3A-46AF-8F7A-320262A9DCED}.Debug|x64.ActiveCfg = Debug|x64
		{8C20051E-9D3A-46AF-8F7A-320262A9DCED}.Debug|x64.Build.0 = Debug|x64
		{8C20051E-9D3A-46AF-8F7A-320262A9DCED}.Debug|x64.Deploy.0 = Debug|x64
		{8C20051E-9D3A-46AF-8F7A-320262A9DCED}.Debug|x86.ActiveCfg = Debug|Win32
		{8C20051E-9D3A-46AF-8F7A-320262A9DCED}.Debug|x86.Build.0 = Debug|Win32
		{8C20051E-9D3A-46AF-8F7A-320262A9DCED}.Debug|x86.Deploy.0 = Debug|Win32
		{8C20051E-9D3A-46AF-8F7A-320262A9DCED}.Release|ARM.ActiveCfg = Release|ARM
		{8C20051E-9D3A-46AF-8F7A-320262A9DCED}.Release|ARM.Build.0 = Release|ARM
		{8C20051E-9D3A-46AF-8F7A-320262A9DCED}.Release|ARM.Deploy.0 = Release|ARM
		{8C20051E-9D3A-46AF-8F7A-320262A9DCED}.Release|ARM64.ActiveCfg = Release|ARM64
		{8C20051E-9D3A-46AF-8F7A-320262A9DCED}.Release|ARM64.Build.0 = Release|ARM64
		{8C20051E-9D3A-46AF-8F7A-320262A9DCED}.Release|ARM64.Deploy.0 = Release|ARM64
		{8C20051E-9D3A-46AF-8F7A-320262A9DCED}.Release|x64.ActiveCfg = Release|x64
		{8C20051E-9D3A-46AF-8F7A-320262A9DCED}.Release|x64.Build.0 = Release|x64
		{8C20051E-9D3A-46AF-8F7A-320262A9DCED}.Release|x64.Deploy.0 = Release|x64
		{8C20051E-9D3A-46AF-8F7A-320262A9DCED}.Release|x86.ActiveCfg = Release|Win32
		{8C20051E-9D3A-46AF-8F7A-320262A9DCED}.Release|x86.Build.0 = Release|Win32
		{8C20051E-9D3A-46AF-8F7A-320262A9DCED}.Release|x86.Deploy.0 = Release|Win32
		{89672149-9CFF-48A1-A2B3-F9578A8E1E95}.Debug|ARM.ActiveCfg = Debug|ARM
		{89672149-9CFF-48A1-A2B3-F9578A8E1E95}.Debug|ARM.Build.0 = Debug|ARM
		{89672149-9CFF-48A1-A2B3-F9578A8E1E95}.Debug|ARM.Deploy.0 = Debug|ARM
		{89672149-9CFF-48A1-A2B3-F9578A8E1E95}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{89672149-9CFF-48A1-A2B3-F9578A8E1E95}.Debug|ARM64.Build.0 = Debug|ARM64
		{89672149-9CFF-48A1-A2B3-F9578A8E1E95}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{89672149-9CFF-48A1-A2B3-F9578A8E1E95}.Debug|x64.ActiveCfg = Debug|x64
		{89672149-9CFF-48A1-A2B3-F9578A8E1E95}.Debug|x64.Build.0 = Debug|x64
		{89672149-9CFF-48A1-A2B3-F9578A8E1E95}.Debug|x64.Deploy.0 = Debug|x64
		{89672149-9CFF-48A1-A2B3-F9578A8E1E95}.Debug|x86.ActiveCfg = Debug|Win32
		{89672149-9CFF-48A1-A2B3-F9578A8E1E95}.Debug|x86.Build.0 = Debug|Win32
		{89672149-9CFF-48A1-A2B3-F9578A8E1E95}.Debug|x86.Deploy.0 = Debug|Win32
		{89672149-9CFF-48A1-A2B3-F9578A8E1E95}.Release|ARM.ActiveCfg = Release|ARM
		{89672149-9CFF-48A1-A2B3-F9578A8E1E95}.Release|ARM.Build.0 = Release|ARM
		{89672149-9CFF-48A1-A2B3-F9578A8E1E95}.Release|ARM.Deploy.0 = Release|ARM
		{89672149-9CFF-48A1-A2B3-F9578A8E1E95}.Release|ARM64.ActiveCfg = Release|ARM64
		{89672149-9CFF-48A1-A2B3-F9578A8E1E95}.Release|ARM64.Build.0 = Release|ARM64
		{89672149-9CFF-48A1-A2B3-F9578A8E1E95}.Release|ARM64.Deploy.0 = Release|ARM64
		{89672149-9CFF-48A1-A2B3-F9578A8E1E95}.Release|x64.ActiveCfg = Release|x64
		{89672149-9CFF-48A1-A2B3-F9578A8E1E95}.Release|x64.Build.0 = Release|x64
		{89672149-9CFF-48A1-A2B3-F9578A8E1E95}.Release|x64.Deploy.0 = Release|x64
		{89672149-9CFF-48A1-A2B3-F9578A8E1E95}.Release|x86.ActiveCfg = Release|Win32
		{89672149-9CFF-48A1-A2B3-F9578A8E1E95}.Release|x86.Build.0 = Release|Win32
		{89672149-9CFF-48A1-A2B3-F9578A8E1E95}.Release|x86.Deploy.0 = Release|Win32
		{1BB91B25-67A5-4CB7-8379-DF7C886CE06A}.Debug|ARM.ActiveCfg = Debug|ARM
		{1BB91B25-67A5-4CB7-8379-DF7C886CE06A}.Debug|ARM.Build.0 = Debug|ARM
		{1BB91B25-67A5-4CB7-8379-DF7C886CE06A}.Debug|ARM.Deploy.0 = Debug|ARM
		{1BB91B25-67A5-4CB7-8379-DF7C886CE06A}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{1BB91B25-67A5-4CB7-8379-DF7C886CE06A}.Debug|ARM64.Build.0 = Debug|ARM64
		{1BB91B25-67A5-4CB7-8379-DF7C886CE06A}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{1BB91B25-67A5-4CB7-8379-DF7C886CE06A}.Debug|x64.ActiveCfg = Debug|x64
		{1BB91B25-67A5-4CB7-8379-DF7C886CE06A}.Debug|x64.Build.0 = Debug|x64
		{1BB91B25-67A5-4CB7-8379-DF7C886CE06A}.Debug|x64.Deploy.0 = Debug|x64
		{1BB91B25-67A5-4CB7-8379-DF7C886CE06A}.Debug|x86.ActiveCfg = Debug|Win32
		{1BB91B25-67A5-4CB7-8379-DF7C886CE06A}.Debug|x86.Build.0 = Debug|Win32
		{1BB91B25-67A5-4CB7-8379-DF7C886CE06A}.Debug|x86.Deploy.0 = Debug|Win32
		{1BB91B25-67A5-4CB7-8379-DF7C886CE06A}.Release|ARM.ActiveCfg = Release|ARM
		{1BB91B25-67A5-4CB7-8379-DF7C886CE06A}.Release|ARM.Build.0 = Release|ARM
		{1BB91B25-67A5-4CB7-8379-DF7C886CE06A}.Release|ARM.Deploy.0 = Release|ARM
		{1BB91B25-67A5-4CB7-8379-DF7C886CE06A}.Release|ARM64.ActiveCfg = Release|ARM64
		{1BB91B25-67A5-4CB7-8379-DF7C886CE06A}.Release|ARM64.Build.0 = Release|ARM64
		{1BB91B25-67A5-4CB7-8379-DF7C886CE06A}.Release|ARM64.Deploy.0 = Release|ARM64
		{1BB91B25-67A5-4CB7-8379-DF7C886CE06A}.Release|x64.ActiveCfg = Release|x64
		{1BB91B25-67A5-4CB7-8379-DF7C886CE06A}.Release|x64.Build.0 = Release|x64
		{1BB91B25-67A5-4CB7-8379-DF7C886CE06A}.Release|x64.Deploy.0 = Release|x64
		{1BB91B25-67A5-4CB7-8379-DF7C886CE06A}.Release|x86.ActiveCfg = Release|Win32
		{1BB91B25-67A5-4CB7-8379-DF7C886CE06A}.Release|x86.Build.0 = Release|Win32
		{1BB91B25-67A5-4CB7-8379-DF7C886CE06A}.Release|x86.Deploy.0 = Release|Win32
		{667DC8CB-B5E1-4473-8FED-3DE15D72AE5F}.Debug|ARM.ActiveCfg = Debug|Win32
		{667DC8CB-B5E1-4473-8FED-3DE15D72AE5F}.Debug|ARM64.ActiveCfg = Debug|Win32
		{667DC8CB-B5E1-4473-8FED-3DE15D72AE5F}.Debug|x64.ActiveCfg = Debug|x64
		{667DC8CB-B5E1-4473-8FED-3DE15D72AE5F}.Debug|x64.Build.0 = Debug|x64
		{667DC8CB-B5E1-4473-8FED-3DE15D72AE5F}.Debug|x86.ActiveCfg = Debug|Win32
		{667DC8CB-B5E1-4473-8FED-3DE15D72AE5F}.Debug|x86.Build.0 = Debug|Win32
		{667DC8CB-B5E1-4473-8FED-3DE15D72AE5F}.Release|ARM.ActiveCfg = Release|Win32
		{667DC8CB-B5E1-4473-8FED-3DE15D72AE5F}.Release|ARM64.ActiveCfg = Release|Win32
		{667DC8CB-B5E1-4473-8FED-3DE15D72AE5F}.Release|x64.ActiveCfg = Release|x64
		{667DC8CB-B5E1-4473-8FED-3DE15D72AE5F}.Release|x64.Build.0 = Release|x64
		{667DC8CB-B5E1-4473-8FED-3DE15D72AE5F}.Release|x86.ActiveCfg = Release|Win32
		{667DC8CB-B5E1-4473-8FED-3DE15D72AE5F}.Release|x86.Build.0 = Release|Win32
		{D64D1DF6-F132-4957-8F6E-514271F88934}.Debug|ARM.ActiveCfg = Debug|Win32
		{D64D1DF6-F132-4957-8F6E-514271F88934}.Debug|ARM64.ActiveCfg = Debug|Win32
		{D64D1DF6-F132-4957-8F6E-514271F88934}.Debug|x64.ActiveCfg = Debug|x64
		{D64D1DF6-F132-4957-8F6E-514271F88934}.Debug|x64.Build.0 = Debug|x64
		{D64D1DF6-F132-4957-8F6E-514271F88934}.Debug|x86.ActiveCfg = Debug|Win32
		{D64D1DF6-F132-4957-8F6E-514271F88934}.Debug|x86.Build.0 = Debug|Win32
		{D64D1DF6-F132-4957-8F6E-514271F88934}.Release|ARM.ActiveCfg = Release|Win32
		{D64D1DF6-F132-4957-8F6E-514271F88934}.Release|ARM64.ActiveCfg = Release|Win32
		{D64D1DF6-F132-4957-8F6E-514271F88934}.Release|x64.ActiveCfg = Release|x64
		{D64D1DF6-F132-4957-8F6E-514271F88934}.Release|x64.Build.0 = Release|x64
		{D64D1DF6-F132-4957-8F6E-514271F88934}.Release|x86.ActiveCfg = Release|Win32
		{D64D1DF6-F132-4957-8F6E-514271F88934}.Release|x86.Build.0 = Release|Win32
		{1EEF30F8-1723-49B9-BFEA-2F9075F6638F}.Debug|ARM.ActiveCfg = Debug|Win32
		{1EEF30F8-1723-49B9-BFEA-2F9075F6638F}.Debug|ARM64.ActiveCfg = Debug|Win32
		{1EEF30F8-1723-49B9-BFEA-2F9075F6638F}.Debug|x64.ActiveCfg = Debug|x64
		{1EEF30F8-1723-49B9-BFEA-2F9075F6638F}.Debug|x64.Build.0 = Debug|x64
		{1EEF30F8-1723-49B9-BFEA-2F9075F6638F}.Debug|x86.ActiveCfg = Debug|Win32
		{1EEF30F8-1723-49B9-BFEA-2F9075F6638F}.Debug|x86.Build.0 = Debug|Win32
		{1EEF30F8-1723-49B9-BFEA-2F9075F6638F}.Release|ARM.ActiveCfg = Release|Win32
		{1EEF30F8-1723-49B9-BFEA-2F9075F6638F}.Release|ARM64.ActiveCfg = Release|Win32
		{1EEF30F8-1723-49B9-BFEA-2F9075F6638F}.Release|x64.ActiveCfg = Release|x64
		{1EEF30F8-1723-49B9-BFEA-2F9075F6638F}.Release|x64.Build.0 = Release|x64
		{1EEF30F8-1723-49B9-BFEA-2F9075F6638F}.Release|x86.ActiveCfg = Release|Win32
		{1EEF30F8-1723-49B9-BFEA-2F9075F6638F}.Release|x86.Build.0 = Release|Win32
		{DDCB0847-184C-4769-8713-A3006A6AF794}.Debug|ARM.ActiveCfg = Debug|Win32
		{DDCB0847-184C-4769-8713-A3006A6AF794}.Debug|ARM64.ActiveCfg = Debug|Win32
		{DDCB0847-184C-4769-8713-A3006A6AF794}.Debug|x64.ActiveCfg = Debug|x64
		{DDCB0847-184C-4769-8713-A3006A6AF794}.Debug|x64.Build.0 = Debug|x64
		{DDCB0847-184C-4769-8713-A3006A6AF794}.Debug|x86.ActiveCfg = Debug|Win32
		{DDCB0847-184C-4769-8713-A3006A6AF794}.Debug|x86.Build.0 = Debug|Win32
		{DDCB0847-184C-4769-8713-A3006A6AF794}.Release|ARM.ActiveCfg = Release|Win32
		{DDCB0847-184C-4769-8713-A3006A6AF794}.Release|ARM64.ActiveCfg = Release|Win32
		{DDCB0847-184C-4769-8713-A3006A6AF794}.Release|x64.ActiveCfg = Release|x64
		{DDCB0847-184C-4769-8713-A3006A6AF794}.Release|x64.Build.0 = Release|x64
		{DDCB0847-184C-4769-8713-A3006A6AF794}.Release|x86.ActiveCfg = Release|Win32
		{DDCB0847-184C-4769-8713-A3006A6AF794}.Release|x86.Build.0 = Release|Win32
		{F7341DC6-DD9E-476A-A59A-8D8DB95903F4}.Debug|ARM.ActiveCfg = Debug|Win32
		{F7341DC6-DD9E-476A-A59A-8D8DB95903F4}.Debug|ARM64.ActiveCfg = Debug|Win32
		{F7341DC6-DD9E-476A-A59A-8D8DB95903F4}.Debug|x64.ActiveCfg = Debug|x64
		{F7341DC6-DD9E-476A-A59A-8D8DB95903F4}.Debug|x64.Build.0 = Debug|x64
		{F7341DC6-DD9E-476A-A59A-8D8DB95903F4}.Debug|x86.ActiveCfg = Debug|Win32
		{F7341DC6-DD9E-476A-A59A-8D8DB95903F4}.Debug|x86.Build.0 = Debug|Win32
		{F7341DC6-DD9E-476A-A59A-8D8DB95903F4}.Release|ARM.ActiveCfg = Release|Win32
		{F7341DC6-DD9E-476A-A59A-8D8DB95903F4}.Release|ARM64.ActiveCfg = Release|Win32
		{F7341DC6-DD9E-476A-A59A-8D8DB95903F4}.Release|x64.ActiveCfg = Release|x64
		{F7341DC6-DD9E-476A-A59A-8D8DB95903F4}.Release|x64.Build.0 = Release|x64
		{F7341DC6-DD9E-476A-A59A-8D8DB95903F4}.Release|x86.ActiveCfg = Release|Win32
		{F7341DC6-DD9E-476A-A59A-8D8DB95903F4}.Release|x86.Build.0 = Release|Win32
		{FD57C3F9-DFDE-4B34-9BEF-1B7C9EC4D582}.Debug|ARM.ActiveCfg = Debug|ARM
		{FD57C3F9-DFDE-4B34-9BEF-1B7C9EC4D582}.Debug|ARM.Build.0 = Debug|ARM
		{FD57C3F9-DFDE-4B34-9BEF-1B7C9EC4D582}.Debug|ARM.Deploy.0 = Debug|ARM
		{FD57C3F9-DFDE-4B34-9BEF-1B7C9EC4D582}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{FD57C3F9-DFDE-4B34-9BEF-1B7C9EC4D582}.Debug|ARM64.Build.0 = Debug|ARM64
		{FD57C3F9-DFDE-4B34-9BEF-1B7C9EC4D582}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{FD57C3F9-DFDE-4B34-9BEF-1B7C9EC4D582}.Debug|x64.ActiveCfg = Debug|x64
		{FD57C3F9-DFDE-4B34-9BEF-1B7C9EC4D582}.Debug|x64.Build.0 = Debug|x64
		{FD57C3F9-DFDE-4B34-9BEF-1B7C9EC4D582}.Debug|x64.Deploy.0 = Debug|x64
		{FD57C3F9-DFDE-4B34-9BEF-1B7C9EC4D582}.Debug|x86.ActiveCfg = Debug|Win32
		{FD57C3F9-DFDE-4B34-9BEF-1B7C9EC4D582}.Debug|x86.Build.0 = Debug|Win32
		{FD57C3F9-DFDE-4B34-9BEF-1B7C9EC4D582}.Debug|x86.Deploy.0 = Debug|Win32
		{FD57C3F9-DFDE-4B34-9BEF-1B7C9EC4D582}.Release|ARM.ActiveCfg = Release|ARM
		{FD57C3F9-DFDE-4B34-9BEF-1B7C9EC4D582}.Release|ARM.Build.0 = Release|ARM
		{FD57C3F9-DFDE-4B34-9BEF-1B7C9EC4D582}.Release|ARM.Deploy.0 = Release|ARM
		{FD57C3F9-DFDE-4B34-9BEF-1B7C9EC4D582}.Release|ARM64.ActiveCfg = Release|ARM64
		{FD57C3F9-DFDE-4B34-9BEF-1B7C9EC4D582}.Release|ARM64.Build.0 = Release|ARM64
		{FD57C3F9-DFDE-4B34-9BEF-1B7C9EC4D582}.Release|ARM64.Deploy.0 = Release|ARM64
		{FD57C3F9-DFDE-4B34-9BEF-1B7C9EC4D582}.Release|x64.ActiveCfg = Release|x64
		{FD57C3F9-DFDE-4B34-9BEF-1B7C9EC4D582}.Release|x64.Build.0 = Release|x64
		{FD57C3F9-DFDE-4B34-9BEF-1B7C9EC4D582}.Release|x64.Deploy.0 = Release|x64
		{FD57C3F9-DFDE-4B34-9BEF-1B7C9EC4D582}.Release|x86.ActiveCfg = Release|Win32
		{FD57C3F9-DFDE-4B34-9BEF-1B7C9EC4D582}.Release|x86.Build.0 = Release|Win32
		{FD57C3F9-DFDE-4B34-9BEF-1B7C9EC4D582}.Release|x86.Deploy.0 = Release|Win32
		{D70338B7-7C40-4A0C-8E50-4FDD68E15C18}.Debug|ARM.ActiveCfg = Debug|ARM
		{D70338B7-7C40-4A0C-8E50-4FDD68E15C18}.Debug|ARM.Build.0 = Debug|ARM
		{D70338B7-7C40-4A0C-8E50-4FDD68E15C18}.Debug|ARM.Deploy.0 = Debug|ARM
		{D70338B7-7C40-4A0C-8E50-4FDD68E15C18}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{D70338B7-7C40-4A0C-8E50-4FDD68E15C18}.Debug|ARM64.Build.0 = Debug|ARM64
		{D70338B7-7C40-4A0C-8E50-4FDD68E15C18}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{D70338B7-7C40-4A0C-8E50-4FDD68E15C18}.Debug|x64.ActiveCfg = Debug|x64
		{D70338B7-7C40-4A0C-8E50-4FDD68E15C18}.Debug|x64.Build.0 = Debug|x64
		{D70338B7-7C40-4A0C-8E50-4FDD68E15C18}.Debug|x64.Deploy.0 = Debug|x64
		{D70338B7-7C40-4A0C-8E50-4FDD68E15C18}.Debug|x86.ActiveCfg = Debug|Win32
		{D70338B7-7C40-4A0C-8E50-4FDD68E15C18}.Debug|x86.Build.0 = Debug|Win32
		{D70338B7-7C40-4A0C-8E50-4FDD68E15C18}.Debug|x86.Deploy.0 = Debug|Win32
		{D70338B7-7C40-4A0C-8E50-4FDD68E15C18}.Release|ARM.ActiveCfg = Release|ARM
		{D70338B7-7C40-4A0C-8E50-4FDD68E15C18}.Release|ARM.Build.0 = Release|ARM
		{D70338B7-7C40-4A0C-8E50-4FDD68E15C18}.Release|ARM.Deploy.0 = Release|ARM
		{D70338B7-7C40-4A0C-8E50-4FDD68E15C18}.Release|ARM64.ActiveCfg = Release|ARM64
		{D70338B7-7C40-4A0C-8E50-4FDD68E15C18}.Release|ARM64.Build.0 = Release|ARM64
		{D70338B7-7C40-4A0C-8E50-4FDD68E15C18}.Release|ARM64.Deploy.0 = Release|ARM64
		{D70338B7-7C40-4A0C-8E50-4FDD68E15C18}.Release|x64.ActiveCfg = Release|x64
		{D70338B7-7C40-4A0C-8E50-4FDD68E15C18}.Release|x64.Build.0 = Release|x64
		{D70338B7-7C40-4A0C-8E50-4FDD68E15C18}.Release|x64.Deploy.0 = Release|x64
		{D70338B7-7C40-4A0C-8E50-4FDD68E15C18}.Release|x86.ActiveCfg = Release|Win32
		{D70338B7-7C40-4A0C-8E50-4FDD68E15C18}.Release|x86.Build.0 = Release|Win32
		{D70338B7-7C40-4A0C-8E50-4FDD68E15C18}.Release|x86.Deploy.0 = Release|Win32
		{364E311D-7EF9-4A33-A831-5A0F646C0467}.Debug|ARM.ActiveCfg = Debug|Win32
		{364E311D-7EF9-4A33-A831-5A0F646C0467}.Debug|ARM64.ActiveCfg = Debug|Win32
		{364E311D-7EF9-4A33-A831-5A0F646C0467}.Debug|x64.ActiveCfg = Debug|x64
		{364E311D-7EF9-4A33-A831-5A0F646C0467}.Debug|x64.Build.0 = Debug|x64
		{364E311D-7EF9-4A33-A831-5A0F646C0467}.Debug|x86.ActiveCfg = Debug|Win32
		{364E311D-7EF9-4A33-A831-5A0F646C0467}.Debug|x86.Build.0 = Debug|Win32
		{364E311D-7EF9-4A33-A831-5A0F646C0467}.Release|ARM.ActiveCfg = Release|Win32
		{364E311D-7EF9-4A33-A831-5A0F646C0467}.Release|ARM64.ActiveCfg = Release|Win32
		{364E311D-7EF9-4A33-A831-5A0F646C0467}.Release|x64.ActiveCfg = Release|x64
		{364E311D-7EF9-4A33-A831-5A0F646C0467}.Release|x64.Build.0 = Release|x64
		{364E311D-7EF9-4A33-A831-5A0F646C0467}.Release|x86.ActiveCfg = Release|Win32
		{364E311D-7EF9-4A33-A831-5A0F646C0467}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(NestedProjects) = preSolution
		{4B4C81B1-150A-4EAE-80BD-B42EDC19D1A8} = {43D6F9D6-4AB0-4125-BC60-0463A28341E8}
		{8C20051E-9D3A-46AF-8F7A-320262A9DCED} = {E6164A0B-35FA-4902-B940-C4765FD62334}
		{89672149-9CFF-48A1-A2B3-F9578A8E1E95} = {CF30BA8D-2D2C-4D65-AF53-BB6ECB2B04AE}
		{1BB91B25-67A5-4CB7-8379-DF7C886CE06A} = {EF2228E9-38EE-4A65-A210-6AD68B3F27C9}
		{667DC8CB-B5E1-4473-8FED-3DE15D72AE5F} = {43D6F9D6-4AB0-4125-BC60-0463A28341E8}
		{D64D1DF6-F132-4957-8F6E-514271F88934} = {E6164A0B-35FA-4902-B940-C4765FD62334}
		{1EEF30F8-1723-49B9-BFEA-2F9075F6638F} = {CF30BA8D-2D2C-4D65-AF53-BB6ECB2B04AE}
		{DDCB0847-184C-4769-8713-A3006A6AF794} = {EF2228E9-38EE-4A65-A210-6AD68B3F27C9}
		{F7341DC6-DD9E-476A-A59A-8D8DB95903F4} = {20E262E3-AF8F-4B6A-B9D6-F75646F3AC0D}
		{FD57C3F9-DFDE-4B34-9BEF-1B7C9EC4D582} = {20E262E3-AF8F-4B6A-B9D6-F75646F3AC0D}
		{D70338B7-7C40-4A0C-8E50-4FDD68E15C18} = {B599320D-C9DF-4ED8-A421-AAB2BFDBE177}
		{364E311D-7EF9-4A33-A831-5A0F646C0467} = {B599320D-C9DF-4ED8-A421-AAB2BFDBE177}
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {8AD1A633-9639-48D1-8251-3FC8CA1F7357}
	EndGlobalSection
EndGlobal

```

`named-pipe-km/main.c`:

```c
#include <ntddk.h> 
#include <stdio.h>
#include <stdarg.h>

#define PIPE_OPEN_IO_CODE	CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_NEITHER, FILE_ANY_ACCESS)  
#define PIPE_MSG_IO_CODE	CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_NEITHER, FILE_ANY_ACCESS)  

const WCHAR gc_wszDeviceNameBuffer[]	= L"\\Device\\PipeClient_Test";
const WCHAR gc_wszDeviceSymLinkBuffer[] = L"\\DosDevices\\PipeClient_Test";
const WCHAR gc_wszPipeName[]			= L"\\Device\\NamedPipe\\TestCommPipe";

static HANDLE s_hServerPipe = NULL;
static KMUTEX s_pPipeMutex	= { 0 };

typedef struct _KERNEL_IO_DBG_MSG_DATA
{
	CHAR szMessage[255];
} SKernelIODbgMsgData, *PKernelIODbgMsgData;

// PIPE
VOID WritePipeMessage(const char* c_szMessage, ...)
{
	char szBuff[0x100];

	va_list vaArgList;
	va_start(vaArgList, c_szMessage);
	vsprintf(szBuff, c_szMessage, vaArgList);
	va_end(vaArgList);

	if (KeGetCurrentIrql() == PASSIVE_LEVEL)
	{
		KeWaitForMutexObject(&s_pPipeMutex, Executive, KernelMode, FALSE, NULL);

		if (s_hServerPipe)
		{
			IO_STATUS_BLOCK IoStatusBlock;
			ZwWriteFile(s_hServerPipe, 0, NULL, NULL, &IoStatusBlock, szBuff, (ULONG)strlen(szBuff) + 1, NULL, NULL);
		}

		KeReleaseMutex(&s_pPipeMutex, FALSE);
	} 
}

VOID OpenServerPipe()
{
	UNICODE_STRING usPipeName;
	RtlInitUnicodeString(&usPipeName, gc_wszPipeName);

	OBJECT_ATTRIBUTES ObjectAttributes;
	InitializeObjectAttributes(&ObjectAttributes, &usPipeName, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);

	KeWaitForMutexObject(&s_pPipeMutex, Executive, KernelMode, FALSE, NULL);

	IO_STATUS_BLOCK IoStatusBlock;
	NTSTATUS ntStatus = ZwCreateFile(&s_hServerPipe, FILE_WRITE_DATA | SYNCHRONIZE, &ObjectAttributes, &IoStatusBlock,0, FILE_ATTRIBUTE_NORMAL, 0, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0);
	if (!NT_SUCCESS(ntStatus))
	{
		DbgPrint("ZwCreateFile fail, Status: %p\n", ntStatus);
	}

	KeReleaseMutex(&s_pPipeMutex, FALSE);
}

VOID CloseServerPipe()
{
	KeWaitForMutexObject(&s_pPipeMutex, Executive, KernelMode, FALSE, NULL);

	if (s_hServerPipe)
	{
		ZwClose(s_hServerPipe);
		s_hServerPipe = NULL;
	}

	KeReleaseMutex(&s_pPipeMutex, FALSE);
}

// IOCTL
#define IO_INPUT(Type)  ((Type)(pIrpStack->Parameters.DeviceIoControl.Type3InputBuffer)) 
#define IO_OUTPUT(Type) ((Type)(pIrp->UserBuffer))

NTSTATUS OnIoControl(PDEVICE_OBJECT pDriverObject, PIRP pIrp)
{
	UNREFERENCED_PARAMETER(pDriverObject);

	DbgPrint("IRP_MJ_DEVICE_CONTROL handled!\n");

	NTSTATUS ntStatus = STATUS_SUCCESS;
	__try
	{
		PIO_STACK_LOCATION pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
		ULONG uIoControlCode = pIrpStack->Parameters.DeviceIoControl.IoControlCode;
		switch (uIoControlCode)
		{
			case PIPE_OPEN_IO_CODE:
			{
				DbgPrint("Pipe open packet received\n");
				OpenServerPipe();
			} break;

			case PIPE_MSG_IO_CODE:
			{
				DbgPrint("Pipe message packet received\n");
				WritePipeMessage(IO_INPUT(PKernelIODbgMsgData)->szMessage);
			} break;
		}
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		ntStatus = STATUS_UNSUCCESSFUL;
		DbgPrint("OnIoControl Exception catched!\n");
	}

	pIrp->IoStatus.Status = ntStatus;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	return ntStatus;
}

NTSTATUS OnMajorFunctionCall(PDEVICE_OBJECT pDriverObject, PIRP pIrp)
{
	PIO_STACK_LOCATION pStack = IoGetCurrentIrpStackLocation(pIrp);
	switch (pStack->MajorFunction)
	{
		case IRP_MJ_DEVICE_CONTROL:
			OnIoControl(pDriverObject, pIrp);
			break;

		default:
			pIrp->IoStatus.Status = STATUS_SUCCESS;
			IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	}
	return STATUS_SUCCESS;
}

// Routine
VOID OnDriverUnload(IN PDRIVER_OBJECT pDriverObject)
{
	UNREFERENCED_PARAMETER(pDriverObject);

	DbgPrint("Driver unload routine triggered!\n");

	CloseServerPipe();

	UNICODE_STRING symLink;
	RtlInitUnicodeString(&symLink, gc_wszDeviceSymLinkBuffer);

	IoDeleteSymbolicLink(&symLink);
	if (pDriverObject && pDriverObject->DeviceObject)
	{
		IoDeleteDevice(pDriverObject->DeviceObject);
	}
}

NTSTATUS DriverEntry(IN PDRIVER_OBJECT pDriverObject, IN PUNICODE_STRING pRegistryPath)
{
	// Process params
	UNREFERENCED_PARAMETER(pRegistryPath);

	if (!pDriverObject)
	{
		DbgPrint("NamedPipeTestSys driver entry is null!\n");
		return STATUS_FAILED_DRIVER_ENTRY;
	}

	// Hello world!
	DbgPrint("Driver loaded, system range start in %p, Our entry at: %p\n", MmSystemRangeStart, DriverEntry);

	// Register unload routine
	pDriverObject->DriverUnload = &OnDriverUnload;

	// Veriable decleration
	NTSTATUS ntStatus = 0;

	// Normalize name and symbolic link.
	UNICODE_STRING deviceNameUnicodeString, deviceSymLinkUnicodeString;
	RtlInitUnicodeString(&deviceNameUnicodeString, gc_wszDeviceNameBuffer);
	RtlInitUnicodeString(&deviceSymLinkUnicodeString, gc_wszDeviceSymLinkBuffer);

	// Create the device.
	PDEVICE_OBJECT pDeviceObject = NULL;
	ntStatus = IoCreateDevice(pDriverObject, 0, &deviceNameUnicodeString, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &pDeviceObject);
	if (ntStatus != STATUS_SUCCESS)
	{
		DbgPrint("NamedPipeTestSys IoCreateDevice fail! Status: %p\n", ntStatus);
		return ntStatus;
	}

	// Create the symbolic link
	ntStatus = IoCreateSymbolicLink(&deviceSymLinkUnicodeString, &deviceNameUnicodeString);
	if (ntStatus != STATUS_SUCCESS)
	{
		DbgPrint("NamedPipeTestSys IoCreateSymbolicLink fail! Status: %p\n", ntStatus);
		return ntStatus;
	}

	// Register driver major callbacks
	for (ULONG t = 0; t <= IRP_MJ_MAXIMUM_FUNCTION; t++)
		pDriverObject->MajorFunction[t] = &OnMajorFunctionCall;

	pDeviceObject->Flags |= DO_DIRECT_IO;
	pDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

	KeInitializeMutex(&s_pPipeMutex, 0);

	DbgPrint("NamedPipeTestSys driver entry completed!\n");

	return STATUS_SUCCESS;
}



```

`named-pipe-km/named-pipe-km.inf`:

```inf
;
; named-pipe-km.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=Sample ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=named-pipe-km.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages

[DestinationDirs]
DefaultDestDir = 12
named-pipe-km_Device_CoInstaller_CopyFiles = 11

; ================= Class section =====================

[ClassInstall32]
Addreg=SampleClassReg

[SampleClassReg]
HKR,,,0,%ClassName%
HKR,,Icon,,-5

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
named-pipe-km.sys  = 1,,
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll=1 ; make sure the number matches with SourceDisksNames

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%named-pipe-km.DeviceDesc%=named-pipe-km_Device, Root\named-pipe-km ; TODO: edit hw-id

[named-pipe-km_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
named-pipe-km.sys

;-------------- Service installation
[named-pipe-km_Device.NT.Services]
AddService = named-pipe-km,%SPSVCINST_ASSOCSERVICE%, named-pipe-km_Service_Inst

; -------------- named-pipe-km driver install sections
[named-pipe-km_Service_Inst]
DisplayName    = %named-pipe-km.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\named-pipe-km.sys

;
;--- named-pipe-km_Device Coinstaller installation ------
;

[named-pipe-km_Device.NT.CoInstallers]
AddReg=named-pipe-km_Device_CoInstaller_AddReg
CopyFiles=named-pipe-km_Device_CoInstaller_CopyFiles

[named-pipe-km_Device_CoInstaller_AddReg]
HKR,,CoInstallers32,0x00010000, "WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll,WdfCoInstaller"

[named-pipe-km_Device_CoInstaller_CopyFiles]
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll

[named-pipe-km_Device.NT.Wdf]
KmdfService =  named-pipe-km, named-pipe-km_wdfsect
[named-pipe-km_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName="Samples" ; TODO: edit ClassName
DiskName = "named-pipe-km Installation Disk"
named-pipe-km.DeviceDesc = "named-pipe-km Device"
named-pipe-km.SVCDESC = "named-pipe-km Service"

```

`named-pipe-km/named-pipe-km.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{D70338B7-7C40-4A0C-8E50-4FDD68E15C18}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>named_pipe_km</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`named-pipe-km/named-pipe-km.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="main.c" />
  </ItemGroup>
</Project>
```

`named-pipe-um/main.cpp`:

```cpp
#define _CRT_SECURE_NO_WARNINGS
#include <Windows.h>
#include <iostream>
#include <string>
#include <winioctl.h>  

#define MAX_PACKET_SIZE 0x10000
#define PIPE_OPEN_IO_CODE CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_NEITHER, FILE_ANY_ACCESS)  
#define PIPE_MSG_IO_CODE CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_NEITHER, FILE_ANY_ACCESS)  

static const std::string	gsc_szSymLink	= "\\\\.\\PipeClient_Test";
static HANDLE				gs_hDriver		= INVALID_HANDLE_VALUE;
static const std::string	gs_szPipeName	= "\\\\.\\pipe\\TestCommPipe";;

// IOCTL
typedef struct _KERNEL_IO_MSG_DATA
{
	CHAR szMessage[255];
} SKernelIOMsgData, *PKernelIOMsgData;

bool OpenPipePacket()
{
	auto cbBytesReturned = 0UL;
	auto bRet = DeviceIoControl(gs_hDriver, PIPE_OPEN_IO_CODE, nullptr, 0, nullptr, 0, &cbBytesReturned, NULL);
	printf("Open IO completed! Result: %d\n", bRet);

	return (bRet == TRUE);
}

bool MessagePacket()
{
	printf("Enter message: ");

	auto szMessage = std::string("");
	std::cin >> szMessage;

	SKernelIOMsgData pData;
	strcpy(pData.szMessage, szMessage.c_str());

	auto cbBytesReturned = 0UL;
	auto bRet = DeviceIoControl(gs_hDriver, PIPE_MSG_IO_CODE, &pData, sizeof(pData), &pData, sizeof(pData), &cbBytesReturned, NULL);
	printf("Msg IO completed! Result: %d\n", bRet);

	return true;
}

// PIPE
bool IsValidHandle(HANDLE hTarget)
{
	auto dwInfo = 0UL;
	if (GetHandleInformation(hTarget, &dwInfo) == false)
		return false;
	return true;
}

bool Read(HANDLE hPipe, LPVOID lpBuffer, DWORD dwNumberOfBytesToRead)
{
	if (!hPipe)
	{
		printf("Target pipe must be open\n");
		return false;
	}

	auto bSuccess = ::ReadFile(hPipe, lpBuffer, dwNumberOfBytesToRead, NULL, NULL);
	if (!bSuccess)
	{
		printf("ReadFile fail, Error: %u\n", GetLastError());
		return false;
	}
	return true;
}

template <class T>
bool Read(HANDLE hPipe, T& data) 
{ 
	return Read(hPipe, &data, sizeof(T));
}

DWORD WINAPI InstanceThread(LPVOID lpvParam)
{
	printf("InstanceThread created, receiving and processing messages.\n");

	auto hPipe = (HANDLE)lpvParam;
	if (!hPipe)
		return 0;

	BYTE pData[MAX_PACKET_SIZE];
	while (true)
	{
		if (Read(hPipe, pData) == false)
		{
			auto dwError = GetLastError();
			if (dwError == ERROR_BROKEN_PIPE)
			{
				printf("IO Client disconnected\n");
				break;
			}
			else if (!hPipe || IsValidHandle(hPipe) == false)
			{
				printf("Client has closed the connection or pipe got broken\n");
				break;
			}
			else
			{
				printf("IO ReadFile fail! Error: %u\n", dwError);
				break;
			}
		}

		auto szData = reinterpret_cast<const char*>(pData);
		printf("*** Pipe msg: %s\n", szData);

		FlushFileBuffers(hPipe);
		Sleep(100);
	}

	FlushFileBuffers(hPipe);
	DisconnectNamedPipe(hPipe);
	CloseHandle(hPipe);

	printf("InstanceThread exitting.\n");
	return 1;
}

DWORD WINAPI CreatePipeServer(LPVOID)
{
	SECURITY_DESCRIPTOR sd;
	InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);
	SetSecurityDescriptorDacl(&sd, TRUE, static_cast<PACL>(0), FALSE);

	SECURITY_ATTRIBUTES sa;
	sa.nLength = sizeof(sa);
	sa.lpSecurityDescriptor = &sd;
	sa.bInheritHandle = FALSE;

	while (true)
	{
		auto hPipe = CreateNamedPipeA(gs_szPipeName.c_str(), PIPE_ACCESS_DUPLEX, PIPE_TYPE_BYTE | PIPE_READMODE_BYTE | PIPE_WAIT, PIPE_UNLIMITED_INSTANCES, MAX_PACKET_SIZE, MAX_PACKET_SIZE, 0, &sa);
		if (!hPipe || hPipe == INVALID_HANDLE_VALUE)
		{
			printf("CreateNamedPipeA fail, Error: %u\n", GetLastError());
			return 0;
		}
		printf("Pipe handle succesfully created: %p\n", hPipe);

		auto bConnect = ::ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);
		if (bConnect)
		{
			printf("Client connected, creating a processing thread.\n");

			// Create a thread for this client. 
			auto dwThreadId = 0UL;
			auto hThread	= CreateThread(NULL, 0, InstanceThread, (LPVOID)hPipe, 0, &dwThreadId);

			if (!hThread || hThread == INVALID_HANDLE_VALUE)
			{
				printf("CreateThread fail, Error: %u\n", GetLastError());
				return 0;
			}
			CloseHandle(hThread);
		}
		else
		{
			CloseHandle(hPipe); // The client could not connect, so close the pipe. 
		}
	}
	return 0;
}


// Routine
int main()
{
	printf("Communication CLI started! Target device: %s\n", gsc_szSymLink.c_str());

	gs_hDriver = CreateFileA(gsc_szSymLink.c_str(), GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);
	if (!gs_hDriver || gs_hDriver == INVALID_HANDLE_VALUE)
	{
		printf("CreateFileA fail! Error: %u", GetLastError());
		return 1;
	}
	printf("Handle succesfully created: %p\n", gs_hDriver);

	auto hPipeServerThread = CreateThread(0, 0, CreatePipeServer, 0, 0, 0);

	printf("--------------------------------------\n");

	char pInput = '0';
	while (pInput != 'x')
	{
		printf("Please select:\n1 --> Open pipe packet\n2 --> Message packet\nx --> Exit\n");
		std::cin >> pInput;

		switch (pInput)
		{
			case '1':
			{
				OpenPipePacket();
			} break;
			
			case '2':
			{
				MessagePacket();
			} break;

			case 'x':
				return 0;

			default:
				continue;
		}
	}

    return 0;
}


```

`named-pipe-um/named-pipe-um.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{364E311D-7EF9-4A33-A831-5A0F646C0467}</ProjectGuid>
    <RootNamespace>namedpipeum</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`named-pipe-um/named-pipe-um.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="main.cpp" />
  </ItemGroup>
</Project>
```

`shared-memory-km/Structs.h`:

```h
#pragma once
#include "main.h"

typedef struct _KM_READ_REQUEST
{
	ULONG ProcessId;
	UINT_PTR SourceAddress;
	ULONGLONG Size;
	void* Output;

} KM_READ_REQUEST;

typedef struct _KM_WRITE_REQUEST
{
	ULONG ProcessId;
	ULONG ProcessidOfSource;
	UINT_PTR SourceAddress;
	UINT_PTR TargetAddress;
	ULONGLONG Size;

} KM_WRITE_REQUEST;

typedef struct _GET_USERMODULE_IN_PROCESS
{
	ULONG pid;
	ULONG64 BaseAddress;
} GET_USERMODULE_IN_PROCESS;

typedef struct PiDDBCacheEntry
{
	LIST_ENTRY		List;
	UNICODE_STRING	DriverName;
	ULONG			TimeDateStamp;
	NTSTATUS		LoadStatus;
	char			_0x0028[16]; // data from the shim engine, or uninitialized memory for custom drivers
}PIDCacheobj;

#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES        16

typedef struct _IMAGE_DATA_DIRECTORY
{
	ULONG VirtualAddress;
	ULONG Size;
} IMAGE_DATA_DIRECTORY, * PIMAGE_DATA_DIRECTORY;

typedef struct _IMAGE_OPTIONAL_HEADER64
{
	USHORT Magic;
	UCHAR MajorLinkerVersion;
	UCHAR MinorLinkerVersion;
	ULONG SizeOfCode;
	ULONG SizeOfInitializedData;
	ULONG SizeOfUninitializedData;
	ULONG AddressOfEntryPoint;
	ULONG BaseOfCode;
	ULONGLONG ImageBase;
	ULONG SectionAlignment;
	ULONG FileAlignment;
	USHORT MajorOperatingSystemVersion;
	USHORT MinorOperatingSystemVersion;
	USHORT MajorImageVersion;
	USHORT MinorImageVersion;
	USHORT MajorSubsystemVersion;
	USHORT MinorSubsystemVersion;
	ULONG Win32VersionValue;
	ULONG SizeOfImage;
	ULONG SizeOfHeaders;
	ULONG CheckSum;
	USHORT Subsystem;
	USHORT DllCharacteristics;
	ULONGLONG SizeOfStackReserve;
	ULONGLONG SizeOfStackCommit;
	ULONGLONG SizeOfHeapReserve;
	ULONGLONG SizeOfHeapCommit;
	ULONG LoaderFlags;
	ULONG NumberOfRvaAndSizes;
	struct _IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER64, * PIMAGE_OPTIONAL_HEADER64;

typedef struct _IMAGE_FILE_HEADER
{
	USHORT Machine;
	USHORT NumberOfSections;
	ULONG TimeDateStamp;
	ULONG PointerToSymbolTable;
	ULONG NumberOfSymbols;
	USHORT SizeOfOptionalHeader;
	USHORT Characteristics;
} IMAGE_FILE_HEADER, * PIMAGE_FILE_HEADER;

typedef struct _IMAGE_NT_HEADERS64
{
	ULONG Signature;
	struct _IMAGE_FILE_HEADER FileHeader;
	struct _IMAGE_OPTIONAL_HEADER64 OptionalHeader;
} IMAGE_NT_HEADERS64, * PIMAGE_NT_HEADERS64;

typedef struct _IMAGE_SECTION_HEADER
{
	UCHAR  Name[8];
	union
	{
		ULONG PhysicalAddress;
		ULONG VirtualSize;
	} Misc;
	ULONG VirtualAddress;
	ULONG SizeOfRawData;
	ULONG PointerToRawData;
	ULONG PointerToRelocations;
	ULONG PointerToLinenumbers;
	USHORT  NumberOfRelocations;
	USHORT  NumberOfLinenumbers;
	ULONG Characteristics;
} IMAGE_SECTION_HEADER, * PIMAGE_SECTION_HEADER;

NTSYSAPI
PIMAGE_NT_HEADERS
NTAPI
RtlImageNtHeader(PVOID Base);

typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
	HANDLE Section;
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR  FullPathName[256];
} RTL_PROCESS_MODULE_INFORMATION, * PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES
{
	ULONG NumberOfModules;
	RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, * PRTL_PROCESS_MODULES;

#define MM_UNLOADED_DRIVERS_SIZE 50
typedef struct _MM_UNLOADED_DRIVER
{
	UNICODE_STRING 	Name;
	PVOID 			ModuleStart;
	PVOID 			ModuleEnd;
	ULONG64 		UnloadTime;
} MM_UNLOADED_DRIVER, * PMM_UNLOADED_DRIVER;

```

`shared-memory-km/dependencies.h`:

```h
#pragma once

NTSTATUS NTAPI MmCopyVirtualMemory
(
	PEPROCESS SourceProcess,
	PVOID SourceAddress,
	PEPROCESS TargetProcess,
	PVOID TargetAddress,
	SIZE_T BufferSize,
	KPROCESSOR_MODE PreviousMode,
	PSIZE_T ReturnSize
);

NTKERNELAPI
NTSTATUS
PsLookupProcessByProcessId(
	IN HANDLE ProcessId,
	OUT PEPROCESS* Process
);

NTKERNELAPI
PPEB
PsGetProcessPeb(
	IN PEPROCESS Process
);

NTSTATUS ZwQuerySystemInformation(ULONG InfoClass, PVOID Buffer, ULONG Length, PULONG ReturnLength);

```

`shared-memory-km/loop.h`:

```h
#pragma once

#define ABSOLUTE(wait) (wait)

#define RELATIVE(wait) (-(wait))

#define NANOSECONDS(nanos) \
(((signed __int64)(nanos)) / 100L)

#define MICROSECONDS(micros) \
(((signed __int64)(micros)) * NANOSECONDS(1000L))

#define MILLISECONDS(milli) \
(((signed __int64)(milli)) * MICROSECONDS(1000L))

#define SECONDS(seconds) \
(((signed __int64)(seconds)) * MILLISECONDS(1000L))

```

`shared-memory-km/main.c`:

```c
#include "main.h"
#include "dependencies.h"
#include "loop.h"
#include "undocumented_structs.h"
#include "Structs.h"

VOID ReadSharedMemory
(
)
{
	if (sectionHandle)
		return;

	if (SharedSection)
		ZwUnmapViewOfSection(NtCurrentProcess(), SharedSection);

	SIZE_T ulViewSize = 1024 * 10;
	NTSTATUS ntStatus = ZwMapViewOfSection(sectionHandle, NtCurrentProcess(), &SharedSection, 0, ulViewSize, NULL, &ulViewSize, ViewShare, 0, PAGE_READWRITE | PAGE_NOCACHE);
	if (ntStatus != STATUS_SUCCESS)
	{
		DbgPrintEx(0, 0, "ZwMapViewOfSection fail! Status: %p\n", ntStatus);
		ZwClose(sectionHandle);
		return;
	}
}

NTSTATUS CreateSharedMemory
(
)
{
	NTSTATUS Status = STATUS_SUCCESS;
	DbgPrintEx(0, 0, "calling CreateSharedMemory...\n");

	Status = RtlCreateSecurityDescriptor(&SecDescriptor, SECURITY_DESCRIPTOR_REVISION);
	if (!NT_SUCCESS(Status)) {
		DbgPrintEx(0, 0, "RtlCreateSecurityDescriptor failed : %p\n", Status);
		return Status;
	}

	DaclLength = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) * 3 + RtlLengthSid(SeExports->SeLocalSystemSid) + RtlLengthSid(SeExports->SeAliasAdminsSid) +
		RtlLengthSid(SeExports->SeWorldSid);

	Dacl = ExAllocatePoolWithTag(PagedPool, DaclLength, 'lcaD');

	if (Dacl == NULL) {
		return STATUS_INSUFFICIENT_RESOURCES;
		DbgPrintEx(0, 0, "ExAllocatePoolWithTag  failed  : %p\n", Status);
	}

	Status = RtlCreateAcl(Dacl, DaclLength, ACL_REVISION);

	if (!NT_SUCCESS(Status)) {
		ExFreePool(Dacl);
		DbgPrintEx(0, 0, "RtlCreateAcl  failed  : %p\n", Status);
		return Status;
	}

	Status = RtlAddAccessAllowedAce(Dacl, ACL_REVISION, FILE_ALL_ACCESS, SeExports->SeWorldSid);

	if (!NT_SUCCESS(Status)) {
		ExFreePool(Dacl);
		DbgPrintEx(0, 0, "RtlAddAccessAllowedAce SeWorldSid failed  : %p\n", Status);
		return Status;
	}

	Status = RtlAddAccessAllowedAce(Dacl,
		ACL_REVISION,
		FILE_ALL_ACCESS,
		SeExports->SeAliasAdminsSid);

	if (!NT_SUCCESS(Status)) {
		ExFreePool(Dacl);
		DbgPrintEx(0, 0, "RtlAddAccessAllowedAce SeAliasAdminsSid failed  : %p\n", Status);
		return Status;
	}

	Status = RtlAddAccessAllowedAce(Dacl,
		ACL_REVISION,
		FILE_ALL_ACCESS,
		SeExports->SeLocalSystemSid);

	if (!NT_SUCCESS(Status)) {
		ExFreePool(Dacl);
		DbgPrintEx(0, 0, "RtlAddAccessAllowedAce SeLocalSystemSid failed  : %p\n", Status);
		return Status;
	}

	Status = RtlSetDaclSecurityDescriptor(&SecDescriptor,
		TRUE,
		Dacl,
		FALSE);

	if (!NT_SUCCESS(Status)) {
		ExFreePool(Dacl);
		DbgPrintEx(0, 0, "RtlSetDaclSecurityDescriptor failed  : %p\n", Status);
		return Status;
	}

	OBJECT_ATTRIBUTES objAttr;
	UNICODE_STRING sectionName;
	RtlInitUnicodeString(&sectionName, SharedSectionName);
	InitializeObjectAttributes(&objAttr, &sectionName, OBJ_CASE_INSENSITIVE, NULL, &SecDescriptor);

	if (!NT_SUCCESS(Status)) {
		DbgPrintEx(0, 0, "last thing  has failed : %p\n", Status);
	}

	LARGE_INTEGER lMaxSize = { 0 };
	lMaxSize.HighPart = 0;
	lMaxSize.LowPart = 1024 * 10;
	Status = ZwCreateSection(&sectionHandle, SECTION_ALL_ACCESS, &objAttr, &lMaxSize, PAGE_READWRITE, SEC_COMMIT, NULL); // Create section with section handle, object attributes, and the size of shared mem struct
	if (!NT_SUCCESS(Status))
	{
		DbgPrintEx(0, 0, "ZwCreateSection failed: %p\n", Status);
		return Status;
	}

	SIZE_T ulViewSize = 1024 * 10;   // &sectionHandle before was here i guess i am correct 
	Status = ZwMapViewOfSection(sectionHandle, NtCurrentProcess(), &SharedSection, 0, ulViewSize, NULL, &ulViewSize, ViewShare, 0, PAGE_READWRITE | PAGE_NOCACHE);
	if (!NT_SUCCESS(Status)) {
		DbgPrintEx(0, 0, "ZwMapViewOfSection fail! Status: %p\n", Status);
		ZwClose(sectionHandle);
		return Status;
	}

	DbgPrintEx(0, 0, "CreateSharedMemory called finished \n");

	ExFreePool(Dacl);

	return Status;
}

NTSTATUS WriteKernelMemory
(
	PEPROCESS ProcessOfTarget,
	PVOID SourceAddress,
	PVOID TargetAddress,
	SIZE_T Size,
	KM_WRITE_REQUEST* pdata
)
{
	PSIZE_T Bytes;
	NTSTATUS status = STATUS_SUCCESS;

	DbgPrintEx(0, 0, "ProcessidOfSource : %u \n", pdata->ProcessidOfSource);

	PEPROCESS ProcessOfSource;
	status = PsLookupProcessByProcessId(pdata->ProcessidOfSource, &ProcessOfSource);
	if (NT_SUCCESS(status)) {
		DbgPrintEx(0, 0, "PsLookupProcessByProcessId has success ProcessOfSource address : %p \n", ProcessOfSource);
	}
	else {
		status = STATUS_ACCESS_DENIED;
		ObDereferenceObject(ProcessOfSource);
		DbgPrintEx(0, 0, "PsLookupProcessByProcessId Failed Error code : %p \n", status);
		return status;
	}

	KAPC_STATE state;
	KeStackAttachProcess((PKPROCESS)ProcessOfSource, &state);
	DbgPrintEx(0, 0, "Calling MmCopyVirtualMemory withtin the source context. \n");
	status = MmCopyVirtualMemory(PsGetCurrentProcess(), SourceAddress, ProcessOfTarget, TargetAddress, Size, KernelMode, &Bytes);
	KeUnstackDetachProcess(&state);

	if (!NT_SUCCESS(status))
	{
		DbgPrintEx(0, 0, "Error Code... %x\n", status);
		DbgPrintEx(0, 0, "MmCopyVirtualMemory_Error =  PsGetCurrentProcess : %p SourceAddress : %p ProcessOfTarget : %p TargetAddress :  %p Size : %x Bytes : %x \n", PsGetCurrentProcess(), SourceAddress, ProcessOfTarget, TargetAddress, Size, Bytes);
	}
	else
	{
		DbgPrintEx(0, 0, "MmCopyVirtualMemory Success! %x\n", status);
		DbgPrintEx(0, 0, "Bytes : %x \n", Bytes);
	}
}

NTSTATUS ReadKernelMemory
(
	PEPROCESS Process,
	PVOID SourceAddress,
	PVOID TargetAddress,
	SIZE_T Size
)
{
	PSIZE_T Bytes;
	NTSTATUS status = STATUS_SUCCESS;

	KAPC_STATE state;
	KeStackAttachProcess((PKPROCESS)Process, &state);
	DbgPrintEx(0, 0, "we are inside the context memory... \n");
	DbgPrintEx(0, 0, "Calling MmCopyVirtualMemory... \n");
	MmCopyVirtualMemory(PsGetCurrentProcess(), SourceAddress, Process, TargetAddress, Size, KernelMode, &Bytes);
	KeUnstackDetachProcess(&state);

	if (!NT_SUCCESS(status))
	{
		DbgPrintEx(0, 0, "Error Code... %x\n", status);
		DbgPrintEx(0, 0, "__MmCopyVirtualMemory Error || Process : %p || SourceAddress : %p || PsGetCurrentProcess() : %p || TargetAddress : %p || Size : %x  Bytes : %x \n", Process, SourceAddress, PsGetCurrentProcess, TargetAddress, Size, Bytes);
	}
	else
	{
		DbgPrintEx(0, 0, "MmCopyVirtualMemory Success! %x\n", status);
		DbgPrintEx(0, 0, "Bytes Read : %u \n", Bytes);
	}
}

ULONG64 GetModuleBasex64
(
	PEPROCESS proc,
	UNICODE_STRING
	module_name
)
{
	PPEB pPeb = PsGetProcessPeb(proc);

	if (!pPeb) {
		DbgPrintEx(0, 0, "Error pPeb not found \n");
		return 0; // failed
	}

	KAPC_STATE state;

	KeStackAttachProcess(proc, &state);

	PPEB_LDR_DATA pLdr = (PPEB_LDR_DATA)pPeb->Ldr;

	if (!pLdr) {
		DbgPrintEx(0, 0, "Error pLdr not found \n");
		KeUnstackDetachProcess(&state);
		return 0; // failed
	}

	for (PLIST_ENTRY list = (PLIST_ENTRY)pLdr->ModuleListLoadOrder.Flink;
		list != &pLdr->ModuleListLoadOrder; list = (PLIST_ENTRY)list->Flink) {
		PLDR_DATA_TABLE_ENTRY pEntry =
			CONTAINING_RECORD(list, LDR_DATA_TABLE_ENTRY, InLoadOrderModuleList);
		if (RtlCompareUnicodeString(&pEntry->BaseDllName, &module_name, TRUE) ==
			0) {
			ULONG64 baseAddr = (ULONG64)pEntry->DllBase;
			KeUnstackDetachProcess(&state);
			return baseAddr;
		}
	}
	DbgPrintEx(0, 0, "Error exiting funcion nothing was found found \n");
	KeUnstackDetachProcess(&state);

	return 0;
}

PVOID g_KernelBase = NULL;
ULONG g_KernelSize = 0;

PMM_UNLOADED_DRIVER MmUnloadedDrivers;
PULONG				MmLastUnloadedDriver;

PVOID ResolveRelativeAddress
(
	_In_ PVOID Instruction,
	_In_ ULONG OffsetOffset,
	_In_ ULONG InstructionSize
)
{
	ULONG_PTR Instr = (ULONG_PTR)Instruction;
	LONG RipOffset = *(PLONG)(Instr + OffsetOffset);
	PVOID ResolvedAddr = (PVOID)(Instr + InstructionSize + RipOffset);

	return ResolvedAddr;
}

NTSTATUS BBSearchPattern
(
	IN PCUCHAR pattern,
	IN UCHAR wildcard,
	IN ULONG_PTR len,
	IN const VOID* base,
	IN ULONG_PTR size,
	OUT PVOID* ppFound
)
{
	ASSERT(ppFound != NULL && pattern != NULL && base != NULL);
	if (ppFound == NULL || pattern == NULL || base == NULL)
		return STATUS_INVALID_PARAMETER;

	for (ULONG_PTR i = 0; i < size - len; i++)
	{
		BOOLEAN found = TRUE;
		for (ULONG_PTR j = 0; j < len; j++)
		{
			if (pattern[j] != wildcard && pattern[j] != ((PCUCHAR)base)[i + j])
			{
				found = FALSE;
				break;
			}
		}

		if (found != FALSE)
		{
			*ppFound = (PUCHAR)base + i;
			return STATUS_SUCCESS;
		}
	}

	return STATUS_NOT_FOUND;
}

PVOID GetKernelBase
(
	OUT PULONG pSize
)
{
	NTSTATUS status = STATUS_SUCCESS;
	ULONG bytes = 0;
	PRTL_PROCESS_MODULES pMods = NULL;
	PVOID checkPtr = NULL;
	UNICODE_STRING routineName;

	if (g_KernelBase != NULL)
	{
		if (pSize)
			*pSize = g_KernelSize;
		return g_KernelBase;
	}

	RtlUnicodeStringInit(&routineName, L"NtOpenFile");

	checkPtr = MmGetSystemRoutineAddress(&routineName);
	if (checkPtr == NULL)
		return NULL;

	status = ZwQuerySystemInformation(SystemModuleInformation, 0, bytes, &bytes);
	if (bytes == 0)
	{
		DbgPrintEx(0, 0, "BlackBone: %s: Invalid SystemModuleInformation size\n");
		return NULL;
	}

	pMods = (PRTL_PROCESS_MODULES)ExAllocatePoolWithTag(NonPagedPool, bytes, 0x454E4F45); // 'ENON'
	RtlZeroMemory(pMods, bytes);

	status = ZwQuerySystemInformation(SystemModuleInformation, pMods, bytes, &bytes);

	if (NT_SUCCESS(status))
	{
		PRTL_PROCESS_MODULE_INFORMATION pMod = pMods->Modules;

		for (ULONG i = 0; i < pMods->NumberOfModules; i++)
		{
			if (checkPtr >= pMod[i].ImageBase &&
				checkPtr < (PVOID)((PUCHAR)pMod[i].ImageBase + pMod[i].ImageSize))
			{
				g_KernelBase = pMod[i].ImageBase;
				g_KernelSize = pMod[i].ImageSize;
				if (pSize)
					*pSize = g_KernelSize;
				break;
			}
		}
	}

	if (pMods)
		ExFreePoolWithTag(pMods, 0x454E4F45);

	DbgPrintEx(0, 0, "g_KernelBase : %p\n", g_KernelBase);
	DbgPrintEx(0, 0, "g_KernelSize : %p\n", g_KernelSize);

	return g_KernelBase;
}


NTSTATUS BBScanSection
(
	IN PCCHAR section,
	IN PCUCHAR pattern,
	IN UCHAR wildcard,
	IN ULONG_PTR len,
	OUT PVOID* ppFound
)
{
	ASSERT(ppFound != NULL);
	if (ppFound == NULL)
		return STATUS_INVALID_PARAMETER;

	PVOID base = GetKernelBase(NULL);
	if (!base)
		return STATUS_NOT_FOUND;

	PIMAGE_NT_HEADERS64 pHdr = RtlImageNtHeader(base);
	if (!pHdr)
		return STATUS_INVALID_IMAGE_FORMAT;

	PIMAGE_SECTION_HEADER pFirstSection = (PIMAGE_SECTION_HEADER)(pHdr + 1);
	for (PIMAGE_SECTION_HEADER pSection = pFirstSection; pSection < pFirstSection + pHdr->FileHeader.NumberOfSections; pSection++)
	{
		ANSI_STRING s1, s2;
		RtlInitAnsiString(&s1, section);
		RtlInitAnsiString(&s2, (PCCHAR)pSection->Name);
		if (RtlCompareString(&s1, &s2, TRUE) == 0)
		{
			PVOID ptr = NULL;
			NTSTATUS status = BBSearchPattern(pattern, wildcard, len, (PUCHAR)base + pSection->VirtualAddress, pSection->Misc.VirtualSize, &ptr);
			if (NT_SUCCESS(status))
				*(PULONG)ppFound = (ULONG)((PUCHAR)ptr - (PUCHAR)base);

			return status;
		}
	}

	return STATUS_NOT_FOUND;
}

NTSTATUS FindMmDriverData
(
	VOID
)
{
	UCHAR MmLastUnloadedDrivers_sig[] = "\x8B\x05\xCC\xCC\xCC\xCC\x83\xF8\x32";

	UINT64 MmLastUnloadedDriversPtr = NULL;
	if (!NT_SUCCESS(BBScanSection("PAGE", MmLastUnloadedDrivers_sig, 0xCC, sizeof(MmLastUnloadedDrivers_sig) - 1, (UINT64*)(&MmLastUnloadedDriversPtr)))) {
		DbgPrintEx(0, 0, "Unable to find MmLastUnloadedDriversPtr sig.\n");
		return FALSE;
	}

	DbgPrintEx(0, 0, "MmLastUnloadedDriversPtr func address : %p  \n", MmLastUnloadedDriversPtr);

	RtlZeroMemory(MmLastUnloadedDrivers_sig, sizeof(MmLastUnloadedDrivers_sig) - 1);

	// ida pattern : 48 8B 05 ? ? ? ? 48 8D 1C D0
	UCHAR MmUnloadedDrivers_sig[] = "\x48\x8B\x05\xCC\xCC\xCC\xCC\x48\x8D\x1C\xD0";
	UINT64 MmUnloadedDriversPtr = NULL;


	if (!NT_SUCCESS(BBScanSection("PAGE", MmUnloadedDrivers_sig, 0xCC, sizeof(MmUnloadedDrivers_sig) - 1, (UINT64*)(&MmUnloadedDriversPtr)))) {
		DbgPrintEx(0, 0, "Unable to find MmUnloadedDriversPtr sig.\n");
		return FALSE;
	}
	DbgPrintEx(0, 0, "MmUnloadedDriversPtr func address : %p  \n", MmUnloadedDriversPtr);

	RtlZeroMemory(MmUnloadedDrivers_sig, sizeof(MmUnloadedDrivers_sig) - 1);

	UINT64 realPtrMmunloadedDrivers = NULL;

	realPtrMmunloadedDrivers = (UINT64)g_KernelBase + MmUnloadedDriversPtr;
	DbgPrintEx(0, 0, "realPtrMmunloadedDrivers function address : %p\n", realPtrMmunloadedDrivers);
	MmUnloadedDrivers = *(PMM_UNLOADED_DRIVER*)ResolveRelativeAddress(realPtrMmunloadedDrivers, 3, 7);
	DbgPrintEx(0, 0, "MmUnloadedDrivers relative address is: %p  \n", MmUnloadedDrivers);

	UINT64 realPtrMmLastUnloadedDrivers = NULL;

	realPtrMmLastUnloadedDrivers = (UINT64)g_KernelBase + MmLastUnloadedDriversPtr;
	DbgPrintEx(0, 0, "realPtrMmLastUnloadedDrivers function address : %p\n", realPtrMmLastUnloadedDrivers);
	MmLastUnloadedDriver = (PULONG)ResolveRelativeAddress(realPtrMmLastUnloadedDrivers, 2, 6);
	DbgPrintEx(0, 0, "MmLastUnloadedDriver relative address is: %p  \n", MmLastUnloadedDriver);

	return STATUS_SUCCESS;
}

BOOLEAN IsUnloadedDriverEntryEmpty(_In_ PMM_UNLOADED_DRIVER Entry)
{
	if (Entry->Name.MaximumLength == 0 ||
		Entry->Name.Length == 0 ||
		Entry->Name.Buffer == NULL)
	{
		return TRUE;
	}

	return FALSE;
}

BOOLEAN IsMmUnloadedDriversFilled(VOID)
{
	for (ULONG Index = 0; Index < MM_UNLOADED_DRIVERS_SIZE; ++Index)
	{
		PMM_UNLOADED_DRIVER Entry = &MmUnloadedDrivers[Index];
		if (IsUnloadedDriverEntryEmpty(Entry))
		{
			return FALSE;
		}
	}

	return TRUE;
}


NTSTATUS ClearUnloadedDriver(_In_ PUNICODE_STRING	DriverName, _In_ BOOLEAN	 AccquireResource)
{
	if (AccquireResource)
	{
		ExAcquireResourceExclusiveLite(&PsLoadedModuleResource, TRUE);
	}

	BOOLEAN Modified = FALSE;
	BOOLEAN Filled = IsMmUnloadedDriversFilled();

	for (ULONG Index = 0; Index < MM_UNLOADED_DRIVERS_SIZE; ++Index)
	{
		PMM_UNLOADED_DRIVER Entry = &MmUnloadedDrivers[Index];
		if (Modified)
		{
			PMM_UNLOADED_DRIVER PrevEntry = &MmUnloadedDrivers[Index - 1];
			RtlCopyMemory(PrevEntry, Entry, sizeof(MM_UNLOADED_DRIVER));

			if (Index == MM_UNLOADED_DRIVERS_SIZE - 1)
			{
				RtlFillMemory(Entry, sizeof(MM_UNLOADED_DRIVER), 0);
			}
		}
		else if (RtlEqualUnicodeString(DriverName, &Entry->Name, TRUE))
		{
			PVOID BufferPool = Entry->Name.Buffer;
			RtlFillMemory(Entry, sizeof(MM_UNLOADED_DRIVER), 0);
			ExFreePoolWithTag(BufferPool, 'TDmM');

			*MmLastUnloadedDriver = (Filled ? MM_UNLOADED_DRIVERS_SIZE : *MmLastUnloadedDriver) - 1;
			Modified = TRUE;
		}
	}

	if (Modified)
	{
		ULONG64 PreviousTime = 0;

		for (LONG Index = MM_UNLOADED_DRIVERS_SIZE - 2; Index >= 0; --Index)
		{
			PMM_UNLOADED_DRIVER Entry = &MmUnloadedDrivers[Index];
			if (IsUnloadedDriverEntryEmpty(Entry))
			{
				continue;
			}

			if (PreviousTime != 0 && Entry->UnloadTime > PreviousTime)
			{
				Entry->UnloadTime = PreviousTime - 100;
			}

			PreviousTime = Entry->UnloadTime;
		}

		ClearUnloadedDriver(DriverName, FALSE);
	}

	if (AccquireResource)
	{
		ExReleaseResourceLite(&PsLoadedModuleResource);
	}

	return Modified ? STATUS_SUCCESS : STATUS_NOT_FOUND;
}

BOOLEAN LocatePiDDB(PERESOURCE* lock, PRTL_AVL_TABLE* table)
{
	UCHAR PiDDBLockPtr_sig[] = "\x48\x8D\x0D\xCC\xCC\xCC\xCC\xE8\xCC\xCC\xCC\xCC\x48\x8B\x0D\xCC\xCC\xCC\xCC\x33\xDB";
	UCHAR PiDTablePtr_sig[] = "\x48\x8D\x0D\xCC\xCC\xCC\xCC\xE8\xCC\xCC\xCC\xCC\x3D\xCC\xCC\xCC\xCC\x0F\x83\xCC\xCC\xCC\xCC";

	UINT64 PiDDBLockPtr = NULL;
	if (!NT_SUCCESS(BBScanSection("PAGE", PiDDBLockPtr_sig, 0xCC, sizeof(PiDDBLockPtr_sig) - 1, (UINT64*)(&PiDDBLockPtr)))) {
		DbgPrintEx(0, 0, "Unable to find PiDDBLockPtr sig.\n");
		return FALSE;
	}
	DbgPrintEx(0, 0, "Ok PiDDBLockPtr sig was found : %p  \n", PiDDBLockPtr);

	RtlZeroMemory(PiDDBLockPtr_sig, sizeof(PiDDBLockPtr_sig) - 1);

	UINT64 PiDTablePtr = NULL;
	if (!NT_SUCCESS(BBScanSection("PAGE", PiDTablePtr_sig, 0xCC, sizeof(PiDTablePtr_sig) - 1, (UINT64*)(&PiDTablePtr)))) {
		DbgPrintEx(0, 0, "Unable to find PiDTablePtr sig.\n");
		return FALSE;
	}
	DbgPrintEx(0, 0, "Ok PiDTablePtr sig was found : %p  \n", PiDTablePtr);

	RtlZeroMemory(PiDTablePtr_sig, sizeof(PiDTablePtr_sig) - 1);

	UINT64 RealPtrPIDLock = NULL;

	RealPtrPIDLock = (UINT64)g_KernelBase + PiDDBLockPtr;

	DbgPrintEx(0, 0, "RealPtrPIDLock :%p\n", RealPtrPIDLock);


	*lock = (PERESOURCE)ResolveRelativeAddress(RealPtrPIDLock, 3, 7);

	UINT64 RealPtrPIDTable = NULL;

	RealPtrPIDTable = (UINT64)g_KernelBase + PiDTablePtr;

	DbgPrintEx(0, 0, "RealPtrPIDTable :%p\n", RealPtrPIDTable);

	*table = (PRTL_AVL_TABLE)(ResolveRelativeAddress(RealPtrPIDTable, 3, 7));

	return TRUE;
}

VOID DriverLoop() {

	while (TRUE)
	{
		DbgPrintEx(0, 0, "running waiting for a command to execute.. \n");
		ReadSharedMemory();
		if (strcmp((PCHAR)SharedSection, "Stop") == 0) {
			DbgPrintEx(0, 0, "breaking out of the loop\n");
			break;
		}
		while (!(PCHAR)SharedSection == NULL && strcmp((PCHAR)SharedSection, "Write") == 0)
		{
			DbgPrintEx(0, 0, "Writing memory loop is running\n");

			KeSetEvent(SharedEvent_dt, 0, FALSE);

			LARGE_INTEGER Timeout;
			Timeout.QuadPart = RELATIVE(SECONDS(1));
			KeDelayExecutionThread(KernelMode, FALSE, &Timeout);
			ReadSharedMemory();

			KM_WRITE_REQUEST* WriteInput = (KM_WRITE_REQUEST*)SharedSection;
			PEPROCESS Process;
			NTSTATUS Status = STATUS_SUCCESS;

			Status = PsLookupProcessByProcessId(WriteInput->ProcessId, &Process);
			if (NT_SUCCESS(Status)) {
				DbgPrintEx(0, 0, "PsLookupProcessByProcessId has success! : %p \n", Status);
				DbgPrintEx(0, 0, "Writing memory.\n");
				WriteKernelMemory(Process, WriteInput->SourceAddress, WriteInput->TargetAddress, WriteInput->Size, WriteInput);
			}
			else {
				Status = STATUS_ACCESS_DENIED;
				ObDereferenceObject(Process);
				DbgPrintEx(0, 0, "PsLookupProcessByProcessId Failed Error code : %p \n", Status);
				return Status;
			}

			KeResetEvent(SharedEvent_dt);
			KeSetEvent(SharedEvent_trigger, 0, FALSE);
			break;
		}

		while (!(PCHAR)SharedSection == NULL && strcmp((PCHAR)SharedSection, "Read") == 0) {
			DbgPrintEx(0, 0, "Read memory loop is running\n");

			KeSetEvent(SharedEvent_dt, 0, FALSE);

			LARGE_INTEGER Timeout;
			Timeout.QuadPart = RELATIVE(SECONDS(1));
			KeDelayExecutionThread(KernelMode, FALSE, &Timeout);
			ReadSharedMemory();

			KM_READ_REQUEST* ReadInput = (KM_READ_REQUEST*)SharedSection;
			void* ReadOutput = NULL;
			PEPROCESS Process;
			NTSTATUS Status = STATUS_SUCCESS;

			DbgPrintEx(0, 0, "ReadInput : %p PID : %u SourceAddress : %p ReadOutput : %p Size : %x \n", ReadInput, ReadInput->ProcessId, ReadInput->SourceAddress, ReadOutput, ReadInput->Size);
			DbgPrintEx(0, 0, "(Before mmcopyvirtualmemory) ReadOutput : %p \n", ReadOutput);

			Status = PsLookupProcessByProcessId(ReadInput->ProcessId, &Process);
			if (NT_SUCCESS(Status)) {
				DbgPrintEx(0, 0, "PsLookupProcessByProcessId has success! : %p \n", Status);
				DbgPrintEx(0, 0, "ReadKernelMemory will be called now !.\n");
				ReadKernelMemory(Process, ReadInput->SourceAddress, &ReadOutput, ReadInput->Size);
			}
			else {
				Status = STATUS_ACCESS_DENIED;
				ObDereferenceObject(Process);
				DbgPrintEx(0, 0, "PsLookupProcessByProcessId Failed Error code : %p \n", Status);
				return Status;
			}

			ReadInput->Output = ReadOutput;

			ReadSharedMemory();
			if (0 == memcpy(SharedSection, ReadInput, sizeof(KM_READ_REQUEST))) {
				DbgPrintEx(0, 0, "memcpy failed \n");
			}

			KeSetEvent(SharedEvent_ReadyRead, 0, FALSE);
			KeResetEvent(SharedEvent_dt);
			KeResetEvent(SharedEvent_ReadyRead);
			KeSetEvent(SharedEvent_trigger, 0, FALSE);
			break;
		}

		while (!(PCHAR)SharedSection == NULL && strcmp((PCHAR)SharedSection, "Clearmm") == 0) {
			DbgPrintEx(0, 0, "Clear Mmunloaded Drivers memory loop is running\n");


			LARGE_INTEGER Timeout;
			Timeout.QuadPart = RELATIVE(SECONDS(1));
			KeDelayExecutionThread(KernelMode, FALSE, &Timeout);

			FindMmDriverData();

			DbgPrintEx(0, 0, "MMunload cleared check with lm command\n");
		}

		while (!(PCHAR)SharedSection == NULL && strcmp((PCHAR)SharedSection, "getBase") == 0) {
			DbgPrintEx(0, 0, "getBase loop is running\n");

			KeSetEvent(SharedEvent_dt, 0, FALSE);

			LARGE_INTEGER Timeout;
			Timeout.QuadPart = RELATIVE(SECONDS(1));
			KeDelayExecutionThread(KernelMode, FALSE, &Timeout);
			ReadSharedMemory();

			GET_USERMODULE_IN_PROCESS* getbase = (GET_USERMODULE_IN_PROCESS*)SharedSection;

			NTSTATUS status = STATUS_SUCCESS;
			PEPROCESS TargetProcess;
			status = PsLookupProcessByProcessId(getbase->pid, &TargetProcess);
			if (!NT_SUCCESS(status)) {
				DbgPrintEx(0, 0, "PsLookupProcessByProcessId failed\n");
			}
			else
			{
				DbgPrintEx(0, 0, "PsLookupProcessByProcessId Success!\n");
			}

			UNICODE_STRING DLLName;
			RtlInitUnicodeString(&DLLName, L"dummy.exe");
			getbase->BaseAddress = GetModuleBasex64(TargetProcess, DLLName);


			DbgPrintEx(0, 0, "getbase->BaseAddress is : %p \n", getbase->BaseAddress);

			ReadSharedMemory();

			if (0 == memcpy(SharedSection, getbase, sizeof(GET_USERMODULE_IN_PROCESS))) {
				DbgPrintEx(0, 0, "memcpy failed \n");
			}

			KeSetEvent(SharedEvent_ReadyRead, 0, FALSE);
			KeResetEvent(SharedEvent_dt);
			KeResetEvent(SharedEvent_ReadyRead);
		}


		while (!(PCHAR)SharedSection == NULL && strcmp((PCHAR)SharedSection, "Clearpid") == 0) {
			DbgPrintEx(0, 0, "Clearpid loop is running\n");

			KeSetEvent(SharedEvent_dt, 0, FALSE);

			LARGE_INTEGER Timeout;
			Timeout.QuadPart = RELATIVE(SECONDS(1));
			KeDelayExecutionThread(KernelMode, FALSE, &Timeout);

			PERESOURCE PiDDBLock = NULL;
			PRTL_AVL_TABLE PiDDBCacheTable = NULL;
			if (!LocatePiDDB(&PiDDBLock, &PiDDBCacheTable) && PiDDBLock == NULL && PiDDBCacheTable == NULL) {
				DbgPrintEx(0, 0, "LocatePiDDB() failed..\n");

				ReadSharedMemory();
				PCHAR TestString = "failed2clear";
				if (0 == memcpy(SharedSection, TestString, 12)) {
					DbgPrintEx(0, 0, "memcpy failed \n");
				}
				else
				{
					DbgPrintEx(0, 0, "Sent ClearPID_fail msg\n");
					KeSetEvent(SharedEvent_ReadyRead, 0, FALSE);
				}
				KeResetEvent(SharedEvent_ReadyRead);
				return STATUS_UNSUCCESSFUL;
			}
			else
			{
				DbgPrintEx(0, 0, "LocatePiDDB() SUCCESS!!!!!..\n");
				DbgPrintEx(0, 0, "PiDDBLock :%p \n", PiDDBLock);
				DbgPrintEx(0, 0, "PiDDBCacheTable :%p\n", PiDDBCacheTable);

				PIDCacheobj lookupEntry;

				UNICODE_STRING DriverName = RTL_CONSTANT_STRING(L"Capcom.sys");

				lookupEntry.DriverName = DriverName;
				lookupEntry.TimeDateStamp = 0x57CD1415;

				ExAcquireResourceExclusiveLite(PiDDBLock, TRUE);

				PIDCacheobj* pFoundEntry = (PIDCacheobj*)RtlLookupElementGenericTableAvl(PiDDBCacheTable, &lookupEntry);
				if (pFoundEntry == NULL)
				{
					DbgPrintEx(0, 0, "pFoundEntry == NULL\n");
					// release the ddb resource lock
					ExReleaseResourceLite(PiDDBLock);
					return 0;
				}
				else
				{
					DbgPrintEx(0, 0, "pFoundEntry Found!\n");

					RemoveEntryList(&pFoundEntry->List);

					RtlDeleteElementGenericTableAvl(PiDDBCacheTable, pFoundEntry);

					ExReleaseResourceLite(PiDDBLock);

					ReadSharedMemory();
					PCHAR pidstring = "ClearedPID";
					if (0 == memcpy(SharedSection, pidstring, 10)) {
						DbgPrintEx(0, 0, "memcpy failed \n");
					}
					else
					{
						DbgPrintEx(0, 0, "Sent clearedpid msg\n");
						KeSetEvent(SharedEvent_ReadyRead, 0, FALSE);
					}
				}
			}

			KeResetEvent(SharedEvent_dt);
			KeResetEvent(SharedEvent_ReadyRead);
		}

		while (!(PCHAR)SharedSection == NULL && strcmp((PCHAR)SharedSection, "Clearmm") == 0) {

			DbgPrintEx(0, 0, "Clearmm loop is running\n");

			KeSetEvent(SharedEvent_dt, 0, FALSE);

			LARGE_INTEGER Timeout;
			Timeout.QuadPart = RELATIVE(SECONDS(1));
			KeDelayExecutionThread(KernelMode, FALSE, &Timeout);

			FindMmDriverData();

			UNICODE_STRING DriverName = RTL_CONSTANT_STRING(L"Capcom.sys");
			if (!NT_SUCCESS(ClearUnloadedDriver(&DriverName, TRUE))) {
				DbgPrintEx(0, 0, "ClearUnloadedDriver failed.\n");
			}
			else
			{
				ReadSharedMemory();
				PCHAR TestString = "Cleared";
				if (0 == memcpy(SharedSection, TestString, 7)) {
					DbgPrintEx(0, 0, "memcpy failed \n");
				}
				else
				{
					DbgPrintEx(0, 0, "Sent Clear msg\n");
					KeSetEvent(SharedEvent_ReadyRead, 0, FALSE);
				}

				DbgPrintEx(0, 0, "ClearUnloadedDriver SUCCESS!.\n");
			}

			KeResetEvent(SharedEvent_dt);
			KeResetEvent(SharedEvent_ReadyRead);
		}
		LARGE_INTEGER Timeout;
		Timeout.QuadPart = RELATIVE(SECONDS(1));
		KeDelayExecutionThread(KernelMode, FALSE, &Timeout);
	}
}

VOID OpenEvents() {

	NTSTATUS status = STATUS_SUCCESS;

	RtlInitUnicodeString(&EventName_dt, L"\\BaseNamedObjects\\DataArrived");
	SharedEvent_dt = IoCreateNotificationEvent(&EventName_dt, &SharedEventHandle_dt);
	if (SharedEvent_dt == NULL) {
		DbgPrintEx(0, 0, "It didn't work lol ! \n", status);
		return STATUS_UNSUCCESSFUL;
	}

	RtlInitUnicodeString(&EventName_trigger, L"\\BaseNamedObjects\\trigger");
	SharedEvent_trigger = IoCreateNotificationEvent(&EventName_trigger, &SharedEventHandle_trigger);
	if (SharedEvent_trigger == NULL) {
		DbgPrintEx(0, 0, "It didn't work lol ! \n", status);
		return STATUS_UNSUCCESSFUL;
	}

	RtlInitUnicodeString(&EventName_ReadyRead, L"\\BaseNamedObjects\\ReadyRead");
	SharedEvent_ReadyRead = IoCreateNotificationEvent(&EventName_ReadyRead, &SharedEventHandle_ReadyRead);
	if (SharedEvent_ReadyRead == NULL) {
		DbgPrintEx(0, 0, "It didn't work lol ! \n", status);
		return STATUS_UNSUCCESSFUL;
	}
}

NTSTATUS DriverEntry(IN PDRIVER_OBJECT pDriverObject, IN PUNICODE_STRING pRegistryPath) {
	NTSTATUS status = STATUS_SUCCESS;
	UNREFERENCED_PARAMETER(pRegistryPath);

	DbgPrintEx(0, 0, "Driver loaded !!\n");

	pDriverObject->DriverUnload = DriverUnload;

	CreateSharedMemory();

	OpenEvents();

	DriverLoop();

	DbgPrintEx(0, 0, "driver entry completed!\n");

	return STATUS_SUCCESS;
}

VOID DriverUnload(IN PDRIVER_OBJECT pDriverObject) {

	DbgPrintEx(0, 0, "Driver Unloading routine called! \n");

	if (SharedSection)
		ZwUnmapViewOfSection(NtCurrentProcess(), SharedSection);

	if (sectionHandle)
		ZwClose(sectionHandle);
}

```

`shared-memory-km/main.h`:

```h
#pragma once
#include <ntdef.h>
#include <ntifs.h>
#include <ntddk.h>
#include <windef.h>
#include <Ntstrsafe.h>

const WCHAR SharedSectionName[] = L"\\BaseNamedObjects\\shared-memory";

PVOID	pSharedSection = NULL;
PVOID	pSectionObj = NULL;
HANDLE	hSection = NULL;

VOID DriverUnload(IN PDRIVER_OBJECT pDriverObject);
NTSTATUS CreateCall(PDEVICE_OBJECT DeviceObject, PIRP irp);
NTSTATUS CloseCall(PDEVICE_OBJECT DeviceObject, PIRP irp);

SECURITY_DESCRIPTOR SecDescriptor;
HANDLE sectionHandle;
PVOID	SharedSection = NULL;
PVOID	Sharedoutputvar = NULL;
ULONG DaclLength;
PACL Dacl;

HANDLE  SharedEventHandle_trigger = NULL;
PKEVENT SharedEvent_trigger = NULL;
UNICODE_STRING EventName_trigger;

HANDLE  SharedEventHandle_ReadyRead = NULL;
PKEVENT SharedEvent_ReadyRead = NULL;
UNICODE_STRING EventName_ReadyRead;

HANDLE  SharedEventHandle_dt = NULL;
PKEVENT SharedEvent_dt = NULL;
UNICODE_STRING EventName_dt;

extern NTKERNELAPI ERESOURCE PsLoadedModuleResource;
NTSTATUS ZwQuerySystemInformation(ULONG InfoClass, PVOID Buffer, ULONG Length, PULONG ReturnLength);

```

`shared-memory-km/shared-memory-km.inf`:

```inf
;
; shared-memory-km.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=Sample ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=shared-memory-km.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages

[DestinationDirs]
DefaultDestDir = 12
shared-memory-km_Device_CoInstaller_CopyFiles = 11

; ================= Class section =====================

[ClassInstall32]
Addreg=SampleClassReg

[SampleClassReg]
HKR,,,0,%ClassName%
HKR,,Icon,,-5

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
shared-memory-km.sys  = 1,,
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll=1 ; make sure the number matches with SourceDisksNames

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%shared-memory-km.DeviceDesc%=shared-memory-km_Device, Root\shared-memory-km ; TODO: edit hw-id

[shared-memory-km_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
shared-memory-km.sys

;-------------- Service installation
[shared-memory-km_Device.NT.Services]
AddService = shared-memory-km,%SPSVCINST_ASSOCSERVICE%, shared-memory-km_Service_Inst

; -------------- shared-memory-km driver install sections
[shared-memory-km_Service_Inst]
DisplayName    = %shared-memory-km.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\shared-memory-km.sys

;
;--- shared-memory-km_Device Coinstaller installation ------
;

[shared-memory-km_Device.NT.CoInstallers]
AddReg=shared-memory-km_Device_CoInstaller_AddReg
CopyFiles=shared-memory-km_Device_CoInstaller_CopyFiles

[shared-memory-km_Device_CoInstaller_AddReg]
HKR,,CoInstallers32,0x00010000, "WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll,WdfCoInstaller"

[shared-memory-km_Device_CoInstaller_CopyFiles]
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll

[shared-memory-km_Device.NT.Wdf]
KmdfService =  shared-memory-km, shared-memory-km_wdfsect
[shared-memory-km_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName="Samples" ; TODO: edit ClassName
DiskName = "shared-memory-km Installation Disk"
shared-memory-km.DeviceDesc = "shared-memory-km Device"
shared-memory-km.SVCDESC = "shared-memory-km Service"

```

`shared-memory-km/shared-memory-km.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{89672149-9CFF-48A1-A2B3-F9578A8E1E95}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>shared_memory_km</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="dependencies.h" />
    <ClInclude Include="loop.h" />
    <ClInclude Include="main.h" />
    <ClInclude Include="Structs.h" />
    <ClInclude Include="undocumented_structs.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`shared-memory-km/shared-memory-km.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="main.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="main.h" />
    <ClInclude Include="Structs.h" />
    <ClInclude Include="undocumented_structs.h" />
    <ClInclude Include="dependencies.h" />
    <ClInclude Include="loop.h" />
  </ItemGroup>
</Project>
```

`shared-memory-km/undocumented_structs.h`:

```h
#pragma once
#include <ntifs.h>
#include <windef.h>

typedef struct _PEB_LDR_DATA {
	ULONG Length;
	BOOLEAN Initialized;
	PVOID SsHandle;
	LIST_ENTRY ModuleListLoadOrder;
	LIST_ENTRY ModuleListMemoryOrder;
	LIST_ENTRY ModuleListInitOrder;
} PEB_LDR_DATA, * PPEB_LDR_DATA;

typedef struct _RTL_USER_PROCESS_PARAMETERS {
	BYTE Reserved1[16];
	PVOID Reserved2[10];
	UNICODE_STRING ImagePathName;
	UNICODE_STRING CommandLine;
} RTL_USER_PROCESS_PARAMETERS, * PRTL_USER_PROCESS_PARAMETERS;

typedef void(__stdcall* PPS_POST_PROCESS_INIT_ROUTINE)(void);

typedef struct _PEB {
	BYTE Reserved1[2];
	BYTE BeingDebugged;
	BYTE Reserved2[1];
	PVOID Reserved3[2];
	PPEB_LDR_DATA Ldr;
	PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
	PVOID Reserved4[3];
	PVOID AtlThunkSListPtr;
	PVOID Reserved5;
	ULONG Reserved6;
	PVOID Reserved7;
	ULONG Reserved8;
	ULONG AtlThunkSListPtr32;
	PVOID Reserved9[45];
	BYTE Reserved10[96];
	PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;
	BYTE Reserved11[128];
	PVOID Reserved12[1];
	ULONG SessionId;
} PEB, * PPEB;


typedef struct _LDR_DATA_TABLE_ENTRY {
	LIST_ENTRY InLoadOrderModuleList;
	LIST_ENTRY InMemoryOrderModuleList;
	LIST_ENTRY InInitializationOrderModuleList;
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;  // in bytes
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	ULONG Flags;  // LDR_*
	USHORT LoadCount;
	USHORT TlsIndex;
	LIST_ENTRY HashLinks;
	PVOID SectionPointer;
	ULONG CheckSum;
	ULONG TimeDateStamp;
} LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;

typedef enum _SYSTEM_INFORMATION_CLASS
{
	SystemBasicInformation,
	SystemProcessorInformation,
	SystemPerformanceInformation,
	SystemTimeOfDayInformation,
	SystemPathInformation,
	SystemProcessInformation,
	SystemCallCountInformation,
	SystemDeviceInformation,
	SystemProcessorPerformanceInformation,
	SystemFlagsInformation,
	SystemCallTimeInformation,
	SystemModuleInformation = 0x0B
} SYSTEM_INFORMATION_CLASS,
* PSYSTEM_INFORMATION_CLASS;

```

`shared-memory-um/KernelHelpers.h`:

```h
#pragma once
#include <windows.h>
#include <iostream>

ULONG PID;
ULONG64 baseaddr = NULL;
HANDLE hMapFileW;
HANDLE hMapFileR;
HANDLE g_hMutex;

HANDLE SharedEvent_dataarv;
HANDLE SharedEvent_trigger;
HANDLE SharedEvent_ready2read;

```

`shared-memory-um/Kernelrequests.h`:

```h
#pragma once
#include <iostream>
#include <vector>
#include <windows.h>
#include <tlhelp32.h>
#include "KernelHelpers.h"
#include "Structs.h"
#include <stdio.h>
#include <aclapi.h>

DWORD dwRes;
SECURITY_ATTRIBUTES sa;
PSECURITY_DESCRIPTOR pSD = NULL;
SID_IDENTIFIER_AUTHORITY SIDAuthWorld = SECURITY_WORLD_SID_AUTHORITY;
PACL pAcl = NULL;
PSID pEveryoneSID = NULL;
EXPLICIT_ACCESS ea[1];

class Kernelrequests
{
public:
	DWORD_PTR FindProcessId(const std::string& processName)
	{
		PROCESSENTRY32 processInfo;
		processInfo.dwSize = sizeof(processInfo);

		HANDLE processesSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
		if (processesSnapshot == INVALID_HANDLE_VALUE)
			return 0;

		Process32First(processesSnapshot, &processInfo);
		if (!processName.compare(processInfo.szExeFile))
		{
			CloseHandle(processesSnapshot);
			return processInfo.th32ProcessID;
		}

		while (Process32Next(processesSnapshot, &processInfo))
		{
			if (!processName.compare(processInfo.szExeFile))
			{
				CloseHandle(processesSnapshot);
				return processInfo.th32ProcessID;
			}
		}

		CloseHandle(processesSnapshot);
		return 0;
	}

	template<typename T>
	bool Write(UINT_PTR WriteAddress, const T& value)
	{
		return WriteVirtualMemoryRaw(WriteAddress, (UINT_PTR)&value, sizeof(T));
	}

	bool WriteVirtualMemoryRaw(UINT_PTR WriteAddress, UINT_PTR SourceAddress, SIZE_T WriteSize)
	{
		auto Write_memoryst = (char*)MapViewOfFile(hMapFileW, FILE_MAP_WRITE, 0, 0, 4096);
		char str[8];
		strcpy_s(str, "Write");
		RtlCopyMemory(Write_memoryst, str, strlen(str) + 1);

		UnmapViewOfFile(Write_memoryst);

		WaitForSingleObject(SharedEvent_dataarv, INFINITE);

		KM_WRITE_REQUEST* Sent_struct = (KM_WRITE_REQUEST*)MapViewOfFile(hMapFileW, FILE_MAP_WRITE, 0, 0, sizeof(KM_WRITE_REQUEST));

		if (!Sent_struct) {
			return false;
		}

		KM_WRITE_REQUEST  WriteRequest;
		WriteRequest.ProcessId = PID;
		WriteRequest.ProcessidOfSource = GetCurrentProcessId(); // gets our program PID.
		WriteRequest.TargetAddress = WriteAddress;
		WriteRequest.SourceAddress = SourceAddress;
		WriteRequest.Size = WriteSize;

		KM_WRITE_REQUEST* test_ptr = &WriteRequest;
		if (0 == memcpy(Sent_struct, test_ptr, sizeof(KM_WRITE_REQUEST))) {
			return false;
		}

		UnmapViewOfFile(Sent_struct);

		WaitForSingleObject(SharedEvent_trigger, INFINITE);
		ResetEvent(SharedEvent_trigger);
		return true;
	}

	template <typename type>
	type Read(UINT_PTR ReadAddress)
	{
		auto Read_memoryst = (char*)MapViewOfFile(hMapFileW, FILE_MAP_WRITE, 0, 0, 4096);
		char str[8];
		strcpy_s(str, "Read");
		RtlCopyMemory(Read_memoryst, str, strlen(str) + 1);

		UnmapViewOfFile(Read_memoryst);

		WaitForSingleObject(SharedEvent_dataarv, INFINITE);

		KM_READ_REQUEST* Sent_struct = (KM_READ_REQUEST*)MapViewOfFile(hMapFileW, FILE_MAP_WRITE, 0, 0, sizeof(KM_READ_REQUEST));

		if (!Sent_struct) {
			return false;
		}

		KM_READ_REQUEST ReadRequest{};

		type response{};

		ReadRequest.ProcessId = PID;
		ReadRequest.SourceAddress = ReadAddress;
		ReadRequest.Size = sizeof(type);
		ReadRequest.Output = &response;

		KM_READ_REQUEST* test_ptr = &ReadRequest;
		if (0 == memcpy(Sent_struct, test_ptr, sizeof(KM_READ_REQUEST))) {
			return 1;
		}

		UnmapViewOfFile(Sent_struct);

		WaitForSingleObject(SharedEvent_ready2read, INFINITE);

		KM_READ_REQUEST* Read_struct = (KM_READ_REQUEST*)MapViewOfFile(hMapFileR, FILE_MAP_READ, 0, 0, sizeof(KM_READ_REQUEST));
		if (!Read_struct)
		{
			return 0;
		}

		type Returnval = ((type)Read_struct->Output);

		UnmapViewOfFile(Read_struct);
		WaitForSingleObject(SharedEvent_trigger, INFINITE);
		ResetEvent(SharedEvent_trigger);
		return Returnval;
	}

	bool ClearMmunloadedDrivers() {
		auto Clearmm_memoryst = (char*)MapViewOfFile(hMapFileW, FILE_MAP_WRITE, 0, 0, 4096);
		if (!hMapFileW || hMapFileW == INVALID_HANDLE_VALUE) {
			printf("MapViewOfFile(Clearmm_memoryst) fail! Error: %u\n", GetLastError());
			return false;
		}
		char str[10];
		strcpy_s(str, "Clearmm");
		if (0 == RtlCopyMemory(Clearmm_memoryst, str, strlen(str) + 1)) {
			printf("RtlCopyMemory(Clearmm_memoryst) fail! Error: %u\n", GetLastError());
			return false;
		}
		printf("message has been sent to kernel [Clearmm]! \n");
		UnmapViewOfFile(Clearmm_memoryst);

		WaitForSingleObject(SharedEvent_ready2read, INFINITE);

		auto pBuf = (char*)MapViewOfFile(hMapFileR, FILE_MAP_READ, 0, 0, 4096);
		if (!pBuf)
		{
			printf("OpenFileMappingA(read) fail! Error: %u\n", GetLastError());
			return 0;
		}

		printf("Data: %s\n", pBuf);
		UnmapViewOfFile(pBuf);
		return true;
	}

	bool ClearPIDCache() {
		auto ClearPIDCache_mem = (char*)MapViewOfFile(hMapFileW, FILE_MAP_WRITE, 0, 0, 4096);
		if (!hMapFileW || hMapFileW == INVALID_HANDLE_VALUE) {
			printf("MapViewOfFile(ClearPIDCache_mem) fail! Error: %u\n", GetLastError());
			return false;
		}
		char str1[11];
		strcpy_s(str1, "Clearpid");
		if (0 == RtlCopyMemory(ClearPIDCache_mem, str1, strlen(str1) + 1)) {
			printf("RtlCopyMemory(ClearPIDCache_mem) fail! Error: %u\n", GetLastError());
			return false;
		}
		printf("message has been sent to kernel [ClearPIDCache_mem]! \n");
		UnmapViewOfFile(ClearPIDCache_mem);

		WaitForSingleObject(SharedEvent_ready2read, INFINITE);

		auto pBuf = (char*)MapViewOfFile(hMapFileR, FILE_MAP_READ, 0, 0, 4096);
		if (!pBuf)
		{
			printf("OpenFileMappingA(read) fail! Error: %u\n", GetLastError());
			return 0;
		}

		printf("Data: %s\n", pBuf);
		UnmapViewOfFile(pBuf);
		return true;
	}

	ULONG64 GetModuleBase(ULONG pid) {

		auto GetModuleBase_msg = (char*)MapViewOfFile(hMapFileW, FILE_MAP_WRITE, 0, 0, 4096);
		if (!hMapFileW || hMapFileW == INVALID_HANDLE_VALUE) {
			return 0;
		}
		char str[10];
		strcpy_s(str, "getBase");
		if (0 == RtlCopyMemory(GetModuleBase_msg, str, strlen(str) + 1)) {
			return 0;
		}

		UnmapViewOfFile(GetModuleBase_msg);

		WaitForSingleObject(SharedEvent_dataarv, INFINITE);

		GET_USERMODULE_IN_PROCESS* Sent_struct = (GET_USERMODULE_IN_PROCESS*)MapViewOfFile(hMapFileW, FILE_MAP_WRITE, 0, 0, sizeof(GET_USERMODULE_IN_PROCESS));

		if (!Sent_struct) {
			return 0;
		}

		GET_USERMODULE_IN_PROCESS requestbase;

		requestbase.pid = pid;

		GET_USERMODULE_IN_PROCESS* test_ptr = &requestbase;
		if (0 == memcpy(Sent_struct, test_ptr, sizeof(GET_USERMODULE_IN_PROCESS))) {
			return 0;
		}

		UnmapViewOfFile(Sent_struct);

		WaitForSingleObject(SharedEvent_ready2read, INFINITE);

		GET_USERMODULE_IN_PROCESS* getbase_struct = (GET_USERMODULE_IN_PROCESS*)MapViewOfFile(hMapFileR, FILE_MAP_READ, 0, 0, sizeof(GET_USERMODULE_IN_PROCESS));
		if (!getbase_struct)
		{
			return 0;
		}

		ULONG64 base = NULL;

		base = getbase_struct->BaseAddress;

		UnmapViewOfFile(getbase_struct);

		return base;
	}

	void createSecuritydesc() {
		if (!AllocateAndInitializeSid(
			&SIDAuthWorld,
			1,
			SECURITY_WORLD_RID,
			0, 0, 0, 0, 0, 0, 0,
			&pEveryoneSID))
		{
		}

		ZeroMemory(&ea, sizeof(EXPLICIT_ACCESS));
		ea[0].grfAccessPermissions = SPECIFIC_RIGHTS_ALL | STANDARD_RIGHTS_ALL;
		ea[0].grfAccessMode = SET_ACCESS;
		ea[0].grfInheritance = NO_INHERITANCE;
		ea[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
		ea[0].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
		ea[0].Trustee.ptstrName = (LPTSTR)pEveryoneSID;

		dwRes = SetEntriesInAcl(1, ea, NULL, &pAcl);

		pSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH);

		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = pSD;
		sa.bInheritHandle = FALSE;
	}


	void createConsMenu() {
		static const char* ConHdr = "==================================================\n"
			"|        shared-memory driver by alxbrn          |\n"
			"| Press F8 to open shared memory.                |\n"
			"| Press F6 to write Memory!.					  |\n"
			"| Press F9 to Trigger kernel loop!.              |\n"
			"==================================================\n\n";
		SetConsoleTitleA("shared-memory by alxbrn");
		SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 0xD);
		printf(ConHdr);
		SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 0x5);
	}

	void CreateSharedEvents() {
		SharedEvent_dataarv = CreateEventA(&sa, TRUE, FALSE, "Global\\DataArrived");
		if (!SharedEvent_dataarv)
		{
		}

		SharedEvent_trigger = CreateEventA(&sa, TRUE, FALSE, "Global\\trigger");
		if (!SharedEvent_trigger)
		{
		}

		SharedEvent_ready2read = CreateEventA(&sa, TRUE, FALSE, "Global\\ReadyRead");
		if (!SharedEvent_ready2read)
		{
		}
	}

	bool OpenSharedMemory() {
		hMapFileW = OpenFileMappingA(FILE_MAP_WRITE, FALSE, "Global\\SharedMem");
		if (!hMapFileW || hMapFileW == INVALID_HANDLE_VALUE)
		{
			return false;
	}

		hMapFileR = OpenFileMappingA(FILE_MAP_READ, FALSE, "Global\\SharedMem");
		if (!hMapFileR || hMapFileR == INVALID_HANDLE_VALUE)
		{
			return false;
		}
		printf("[Completed] SHared MEmory is available to use !.\n");
		SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 0xA);
		return true;
	}

	void GetPidNBaseAddr() {
		PID = FindProcessId("dummy.exe");
		std::cout << "PID IS : " << PID << std::endl;

		baseaddr = GetModuleBase(PID);
		std::cout << "base address is : " << std::hex << baseaddr << std::endl;
	}
};

```

`shared-memory-um/Structs.h`:

```h
#pragma once
#include <windows.h>

typedef struct _KM_READ_REQUEST
{
	ULONG ProcessId;
	UINT_PTR SourceAddress;
	ULONGLONG Size;
	void* Output;

} KM_READ_REQUEST;

typedef struct _KM_WRITE_REQUEST
{
	ULONG ProcessId;
	ULONG ProcessidOfSource;
	UINT_PTR SourceAddress;
	UINT_PTR TargetAddress;
	ULONGLONG Size;
} KM_WRITE_REQUEST;

typedef struct _GET_USERMODULE_IN_PROCESS
{
	ULONG pid;
	ULONG64 BaseAddress;
} GET_USERMODULE_IN_PROCESS;

```

`shared-memory-um/main.cpp`:

```cpp
#include <iostream>
#include <windows.h>
#include "Kernelrequests.h"
#include "KernelHelpers.h"
#include <tchar.h>

Kernelrequests* pMem;

void sendrequests() {
	// pMem->Read<int>(0x123456);
	// pMem->Write<int>(0x123456,55);

	pMem->ClearMmunloadedDrivers();
	pMem->ClearPIDCache();
}

void stoploop() {
	auto stopmsg = (char*)MapViewOfFile(hMapFileW, FILE_MAP_WRITE, 0, 0, 4096);

	char stopmms[8];
	strcpy_s(stopmms, "Stop");

	RtlCopyMemory(stopmsg, stopmms, strlen(stopmms) + 1);

	printf("message has been sent to kernel [Stop]! \n");

	FlushViewOfFile(stopmsg, 4096);
	UnmapViewOfFile(stopmsg);
}

int main() {
	pMem->createConsMenu();

	pMem->GetPidNBaseAddr();

	pMem->createSecuritydesc();

	pMem->CreateSharedEvents();

	while (true)
	{
		if (GetAsyncKeyState(VK_F8))
		{
			if (!pMem->OpenSharedMemory()) {
				printf("OpenSharedMemory returned false.[failed]\n");
			}
			Sleep(100);
		}
		else if (GetAsyncKeyState(VK_F6)) {
			sendrequests();
			printf("[Completed] sent sendrequests msg to kernel![sendrequests] \n");
			SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 0xA);
			Sleep(100);
		}
		else if (GetAsyncKeyState(VK_F5)) {
			stoploop();
			Sleep(100);
		}
		Sleep(1);
	}

	system("pause");
}

```

`shared-memory-um/shared-memory-um.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{1EEF30F8-1723-49B9-BFEA-2F9075F6638F}</ProjectGuid>
    <RootNamespace>sharedmemoryum</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="KernelHelpers.h" />
    <ClInclude Include="Kernelrequests.h" />
    <ClInclude Include="Structs.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`shared-memory-um/shared-memory-um.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Structs.h" />
    <ClInclude Include="KernelHelpers.h" />
    <ClInclude Include="Kernelrequests.h" />
  </ItemGroup>
</Project>
```

`socket-km/imports.h`:

```h
#pragma once
#include <ntddk.h>

#include <intrin.h>
#include <stdlib.h>
#include <Ntstrsafe.h>

typedef enum _SYSTEM_INFORMATION_CLASS
{
	SystemBasicInformation = 0x0,
	SystemProcessorInformation = 0x1,
	SystemPerformanceInformation = 0x2,
	SystemTimeOfDayInformation = 0x3,
	SystemPathInformation = 0x4,
	SystemProcessInformation = 0x5,
	SystemCallCountInformation = 0x6,
	SystemDeviceInformation = 0x7,
	SystemProcessorPerformanceInformation = 0x8,
	SystemFlagsInformation = 0x9,
	SystemCallTimeInformation = 0xa,
	SystemModuleInformation = 0xb,
	SystemLocksInformation = 0xc,
	SystemStackTraceInformation = 0xd,
	SystemPagedPoolInformation = 0xe,
	SystemNonPagedPoolInformation = 0xf,
	SystemHandleInformation = 0x10,
	SystemObjectInformation = 0x11,
	SystemPageFileInformation = 0x12,
	SystemVdmInstemulInformation = 0x13,
	SystemVdmBopInformation = 0x14,
	SystemFileCacheInformation = 0x15,
	SystemPoolTagInformation = 0x16,
	SystemInterruptInformation = 0x17,
	SystemDpcBehaviorInformation = 0x18,
	SystemFullMemoryInformation = 0x19,
	SystemLoadGdiDriverInformation = 0x1a,
	SystemUnloadGdiDriverInformation = 0x1b,
	SystemTimeAdjustmentInformation = 0x1c,
	SystemSummaryMemoryInformation = 0x1d,
	SystemMirrorMemoryInformation = 0x1e,
	SystemPerformanceTraceInformation = 0x1f,
	SystemObsolete0 = 0x20,
	SystemExceptionInformation = 0x21,
	SystemCrashDumpStateInformation = 0x22,
	SystemKernelDebuggerInformation = 0x23,
	SystemContextSwitchInformation = 0x24,
	SystemRegistryQuotaInformation = 0x25,
	SystemExtendServiceTableInformation = 0x26,
	SystemPrioritySeperation = 0x27,
	SystemVerifierAddDriverInformation = 0x28,
	SystemVerifierRemoveDriverInformation = 0x29,
	SystemProcessorIdleInformation = 0x2a,
	SystemLegacyDriverInformation = 0x2b,
	SystemCurrentTimeZoneInformation = 0x2c,
	SystemLookasideInformation = 0x2d,
	SystemTimeSlipNotification = 0x2e,
	SystemSessionCreate = 0x2f,
	SystemSessionDetach = 0x30,
	SystemSessionInformation = 0x31,
	SystemRangeStartInformation = 0x32,
	SystemVerifierInformation = 0x33,
	SystemVerifierThunkExtend = 0x34,
	SystemSessionProcessInformation = 0x35,
	SystemLoadGdiDriverInSystemSpace = 0x36,
	SystemNumaProcessorMap = 0x37,
	SystemPrefetcherInformation = 0x38,
	SystemExtendedProcessInformation = 0x39,
	SystemRecommendedSharedDataAlignment = 0x3a,
	SystemComPlusPackage = 0x3b,
	SystemNumaAvailableMemory = 0x3c,
	SystemProcessorPowerInformation = 0x3d,
	SystemEmulationBasicInformation = 0x3e,
	SystemEmulationProcessorInformation = 0x3f,
	SystemExtendedHandleInformation = 0x40,
	SystemLostDelayedWriteInformation = 0x41,
	SystemBigPoolInformation = 0x42,
	SystemSessionPoolTagInformation = 0x43,
	SystemSessionMappedViewInformation = 0x44,
	SystemHotpatchInformation = 0x45,
	SystemObjectSecurityMode = 0x46,
	SystemWatchdogTimerHandler = 0x47,
	SystemWatchdogTimerInformation = 0x48,
	SystemLogicalProcessorInformation = 0x49,
	SystemWow64SharedInformationObsolete = 0x4a,
	SystemRegisterFirmwareTableInformationHandler = 0x4b,
	SystemFirmwareTableInformation = 0x4c,
	SystemModuleInformationEx = 0x4d,
	SystemVerifierTriageInformation = 0x4e,
	SystemSuperfetchInformation = 0x4f,
	SystemMemoryListInformation = 0x50,
	SystemFileCacheInformationEx = 0x51,
	SystemThreadPriorityClientIdInformation = 0x52,
	SystemProcessorIdleCycleTimeInformation = 0x53,
	SystemVerifierCancellationInformation = 0x54,
	SystemProcessorPowerInformationEx = 0x55,
	SystemRefTraceInformation = 0x56,
	SystemSpecialPoolInformation = 0x57,
	SystemProcessIdInformation = 0x58,
	SystemErrorPortInformation = 0x59,
	SystemBootEnvironmentInformation = 0x5a,
	SystemHypervisorInformation = 0x5b,
	SystemVerifierInformationEx = 0x5c,
	SystemTimeZoneInformation = 0x5d,
	SystemImageFileExecutionOptionsInformation = 0x5e,
	SystemCoverageInformation = 0x5f,
	SystemPrefetchPatchInformation = 0x60,
	SystemVerifierFaultsInformation = 0x61,
	SystemSystemPartitionInformation = 0x62,
	SystemSystemDiskInformation = 0x63,
	SystemProcessorPerformanceDistribution = 0x64,
	SystemNumaProximityNodeInformation = 0x65,
	SystemDynamicTimeZoneInformation = 0x66,
	SystemCodeIntegrityInformation = 0x67,
	SystemProcessorMicrocodeUpdateInformation = 0x68,
	SystemProcessorBrandString = 0x69,
	SystemVirtualAddressInformation = 0x6a,
	SystemLogicalProcessorAndGroupInformation = 0x6b,
	SystemProcessorCycleTimeInformation = 0x6c,
	SystemStoreInformation = 0x6d,
	SystemRegistryAppendString = 0x6e,
	SystemAitSamplingValue = 0x6f,
	SystemVhdBootInformation = 0x70,
	SystemCpuQuotaInformation = 0x71,
	SystemNativeBasicInformation = 0x72,
	SystemErrorPortTimeouts = 0x73,
	SystemLowPriorityIoInformation = 0x74,
	SystemBootEntropyInformation = 0x75,
	SystemVerifierCountersInformation = 0x76,
	SystemPagedPoolInformationEx = 0x77,
	SystemSystemPtesInformationEx = 0x78,
	SystemNodeDistanceInformation = 0x79,
	SystemAcpiAuditInformation = 0x7a,
	SystemBasicPerformanceInformation = 0x7b,
	SystemQueryPerformanceCounterInformation = 0x7c,
	SystemSessionBigPoolInformation = 0x7d,
	SystemBootGraphicsInformation = 0x7e,
	SystemScrubPhysicalMemoryInformation = 0x7f,
	SystemBadPageInformation = 0x80,
	SystemProcessorProfileControlArea = 0x81,
	SystemCombinePhysicalMemoryInformation = 0x82,
	SystemEntropyInterruptTimingInformation = 0x83,
	SystemConsoleInformation = 0x84,
	SystemPlatformBinaryInformation = 0x85,
	SystemThrottleNotificationInformation = 0x86,
	SystemHypervisorProcessorCountInformation = 0x87,
	SystemDeviceDataInformation = 0x88,
	SystemDeviceDataEnumerationInformation = 0x89,
	SystemMemoryTopologyInformation = 0x8a,
	SystemMemoryChannelInformation = 0x8b,
	SystemBootLogoInformation = 0x8c,
	SystemProcessorPerformanceInformationEx = 0x8d,
	SystemSpare0 = 0x8e,
	SystemSecureBootPolicyInformation = 0x8f,
	SystemPageFileInformationEx = 0x90,
	SystemSecureBootInformation = 0x91,
	SystemEntropyInterruptTimingRawInformation = 0x92,
	SystemPortableWorkspaceEfiLauncherInformation = 0x93,
	SystemFullProcessInformation = 0x94,
	SystemKernelDebuggerInformationEx = 0x95,
	SystemBootMetadataInformation = 0x96,
	SystemSoftRebootInformation = 0x97,
	SystemElamCertificateInformation = 0x98,
	SystemOfflineDumpConfigInformation = 0x99,
	SystemProcessorFeaturesInformation = 0x9a,
	SystemRegistryReconciliationInformation = 0x9b,
	MaxSystemInfoClass = 0x9c,
} SYSTEM_INFORMATION_CLASS;

typedef struct _DYNDATA
{
	UINT64 CallbackListOffset;
}DYNDATA, * PDYNDATA;

typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
	HANDLE Section;         // Not filled in
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR  FullPathName[MAXIMUM_FILENAME_LENGTH];
} RTL_PROCESS_MODULE_INFORMATION, * PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES
{
	ULONG NumberOfModules;
	RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, * PRTL_PROCESS_MODULES;

typedef struct _CALLBACK_ENTRY {
	UINT16 Version; // 0x0
	UINT16 OperationRegistrationCount; // 0x2
	UINT32 unk1; // 0x4
	PVOID RegistrationContext; // 0x8
	UNICODE_STRING Altitude; // 0x10
} CALLBACK_ENTRY, * PCALLBACK_ENTRY;

typedef struct _OBJECT_CALLBACK_ENTRY {
	LIST_ENTRY CallbackList;
	OB_OPERATION Operations;
	ULONG Active;
	/*OB_HANDLE*/ PCALLBACK_ENTRY CallbackEntry;
	POBJECT_TYPE ObjectType;
	POB_PRE_OPERATION_CALLBACK  PreOperation;
	POB_POST_OPERATION_CALLBACK PostOperation;
} OBJECT_CALLBACK_ENTRY, * POBJECT_CALLBACK_ENTRY;

struct REQUEST_STRUCT
{
	PIO_COMPLETION_ROUTINE OldRoutine;
	PVOID OldContext;
	ULONG OutputBufferLength;
	PVOID SystemBuffer;
};

typedef struct _PS_CALLBACK_ENTRY
{
	PVOID* Callback;
	LARGE_INTEGER* Fillz;
} PS_CALLBACK_ENTRY, * PPS_CALLBACK_ENTRY;

typedef struct _OB_CALLBACK_ADDRESSES
{
	UINT64* pProcPreCallback, * pProcPostCallback;
	UINT64* pThreadPreCallback, * pThreadPostCallback;
	UINT64 OrigProcPre, OrigProcPost;
	UINT64 OrigThreadPre, OrigThreadPost;
}OB_CALLBACK_ADDRESSES, * POB_CALLBACK_ADDRESSES;

typedef struct _IDINFO
{
	USHORT	wGenConfig;
	USHORT	wNumCyls;
	USHORT	wReserved;
	USHORT	wNumHeads;
	USHORT	wBytesPerTrack;
	USHORT	wBytesPerSector;
	USHORT	wNumSectorsPerTrack;
	USHORT	wVendorUnique[3];
	CHAR	sSerialNumber[20];
	USHORT	wBufferType;
	USHORT	wBufferSize;
	USHORT	wECCSize;
	CHAR	sFirmwareRev[8];
	CHAR	sModelNumber[40];
	USHORT	wMoreVendorUnique;
	USHORT	wDoubleWordIO;
	struct {
		USHORT	Reserved : 8;
		USHORT	DMA : 1;
		USHORT	LBA : 1;
		USHORT	DisIORDY : 1;
		USHORT	IORDY : 1;
		USHORT	SoftReset : 1;
		USHORT	Overlap : 1;
		USHORT	Queue : 1;
		USHORT	InlDMA : 1;
	} wCapabilities;
	USHORT	wReserved1;
	USHORT	wPIOTiming;
	USHORT	wDMATiming;
	struct {
		USHORT	CHSNumber : 1;
		USHORT	CycleNumber : 1;
		USHORT	UnltraDMA : 1;
		USHORT	Reserved : 13;
	} wFieldValidity;
	USHORT	wNumCurCyls;
	USHORT	wNumCurHeads;
	USHORT	wNumCurSectorsPerTrack;
	USHORT	wCurSectorsLow;
	USHORT	wCurSectorsHigh;
	struct {
		USHORT	CurNumber : 8;
		USHORT	Multi : 1;
		USHORT	Reserved : 7;
	} wMultSectorStuff;
	ULONG	dwTotalSectors;
	USHORT	wSingleWordDMA;
	struct {
		USHORT	Mode0 : 1;
		USHORT	Mode1 : 1;
		USHORT	Mode2 : 1;
		USHORT	Reserved1 : 5;
		USHORT	Mode0Sel : 1;
		USHORT	Mode1Sel : 1;
		USHORT	Mode2Sel : 1;
		USHORT	Reserved2 : 5;
	} wMultiWordDMA;
	struct {
		USHORT	AdvPOIModes : 8;
		USHORT	Reserved : 8;
	} wPIOCapacity;
	USHORT	wMinMultiWordDMACycle;
	USHORT	wRecMultiWordDMACycle;
	USHORT	wMinPIONoFlowCycle;
	USHORT	wMinPOIFlowCycle;
	USHORT	wReserved69[11];
	struct {
		USHORT	Reserved1 : 1;
		USHORT	ATA1 : 1;
		USHORT	ATA2 : 1;
		USHORT	ATA3 : 1;
		USHORT	ATA4 : 1;
		USHORT	ATA5 : 1;
		USHORT	ATA6 : 1;
		USHORT	ATA7 : 1;
		USHORT	ATA8 : 1;
		USHORT	ATA9 : 1;
		USHORT	ATA10 : 1;
		USHORT	ATA11 : 1;
		USHORT	ATA12 : 1;
		USHORT	ATA13 : 1;
		USHORT	ATA14 : 1;
		USHORT	Reserved2 : 1;
	} wMajorVersion;
	USHORT	wMinorVersion;
	USHORT	wReserved82[6];
	struct {
		USHORT	Mode0 : 1;
		USHORT	Mode1 : 1;
		USHORT	Mode2 : 1;
		USHORT	Mode3 : 1;
		USHORT	Mode4 : 1;
		USHORT	Mode5 : 1;
		USHORT	Mode6 : 1;
		USHORT	Mode7 : 1;
		USHORT	Mode0Sel : 1;
		USHORT	Mode1Sel : 1;
		USHORT	Mode2Sel : 1;
		USHORT	Mode3Sel : 1;
		USHORT	Mode4Sel : 1;
		USHORT	Mode5Sel : 1;
		USHORT	Mode6Sel : 1;
		USHORT	Mode7Sel : 1;
	} wUltraDMA;
	USHORT	wReserved89[167];
} IDINFO, * PIDINFO;

typedef struct _SYSTEM_MODULE   // Information Class 11
{
	ULONG_PTR Reserved[2];
	PVOID Base;
	ULONG Size;
	ULONG Flags;
	USHORT Index;
	USHORT Unknown;
	USHORT LoadCount;
	USHORT ModuleNameOffset;
	CHAR ImageName[256];
} SYSTEM_MODULE, * PSYSTEM_MODULE;

typedef struct _SYSTEM_MODULE_INFORMATION   // Information Class 11
{
	ULONG_PTR ulModuleCount;
	SYSTEM_MODULE Modules[1];
} SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;

struct piddbcache
{
	LIST_ENTRY		List;
	UNICODE_STRING	DriverName;
	ULONG			TimeDateStamp;
	NTSTATUS		LoadStatus;
	char			_0x0028[16]; // data from the shim engine, or uninitialized memory for custom drivers
};

extern "C"
{
	NTKERNELAPI NTSTATUS MmCopyVirtualMemory(
		IN PEPROCESS		SourceProcess,
		IN PVOID			SourceAddress,
		IN PEPROCESS		TargetProcess,
		IN PVOID			TargetAddress,
		IN SIZE_T			BufferSize,
		IN KPROCESSOR_MODE  PreviousMode,
		OUT PSIZE_T			ReturnSize
	);

	NTKERNELAPI NTSTATUS PsLookupProcessByProcessId(
		IN HANDLE			ProcessId,
		OUT PEPROCESS*		Process
	);

	NTKERNELAPI PVOID PsGetProcessSectionBaseAddress(
		IN PEPROCESS		Process
	);

	NTKERNELAPI NTSTATUS ZwQuerySystemInformation(
		SYSTEM_INFORMATION_CLASS SystemInformationClass, 
		PVOID SystemInformation, 
		ULONG SystemInformationLength, 
		PULONG ReturnLength
	);

	NTSYSAPI ULONG RtlRandomEx(
		PULONG Seed
	);
}

template <typename t = void*>
t find_pattern(void* start, size_t length, const char* pattern, const char* mask) {
	const auto data = static_cast<const char*>(start);
	const auto pattern_length = strlen(mask);

	for (size_t i = 0; i <= length - pattern_length; i++)
	{
		bool accumulative_found = true;

		for (size_t j = 0; j < pattern_length; j++)
		{
			if (!MmIsAddressValid(reinterpret_cast<void*>(reinterpret_cast<uintptr_t>(data) + i + j)))
			{
				accumulative_found = false;
				break;
			}

			if (data[i + j] != pattern[j] && mask[j] != '?')
			{
				accumulative_found = false;
				break;
			}
		}

		if (accumulative_found)
		{
			return (t)(reinterpret_cast<uintptr_t>(data) + i);
		}
	}

	return (t)nullptr;
}

uintptr_t dereference(uintptr_t address, unsigned int offset) {
	if (address == 0)
		return 0;

	return address + (int)((*(int*)(address + offset) + offset) + sizeof(int));
}
```

`socket-km/ksocket/berkeley.c`:

```c
#include "berkeley.h"
#include "ksocket.h"

//////////////////////////////////////////////////////////////////////////
// Definitions.
//////////////////////////////////////////////////////////////////////////

#define MEMORY_TAG            ' bsK'
#define SOCKETFD_MAX          128
#define TO_SOCKETFD(index)    ((index % SOCKETFD_MAX)  + 1)
#define FROM_SOCKETFD(sockfd) ((sockfd)                - 1)

//////////////////////////////////////////////////////////////////////////
// Function prototypes.
//////////////////////////////////////////////////////////////////////////

NTSTATUS
NTAPI
KspUtilAddrInfoToAddrInfoEx(
  _In_ PADDRINFOA AddrInfo,
  _Out_ PADDRINFOEXW* AddrInfoEx
  );

NTSTATUS
NTAPI
KspUtilAddrInfoExToAddrInfo(
  _In_ PADDRINFOEXW AddrInfoEx,
  _Out_ PADDRINFOA* AddrInfo
  );

VOID
NTAPI
KspUtilFreeAddrInfo(
  _In_ PADDRINFOA AddrInfo
  );

VOID
NTAPI
KspUtilFreeAddrInfoEx(
  _In_ PADDRINFOEXW AddrInfo
  );

//////////////////////////////////////////////////////////////////////////
// Variables.
//////////////////////////////////////////////////////////////////////////

//
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!! NOTE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!! NOTE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!! NOTE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// This is complete bollocks and ideally it should be replaced with
// something like RTL_AVL_TABLE.
//
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!! NOTE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!! NOTE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!! NOTE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//

PKSOCKET KsArray[SOCKETFD_MAX] = { 0 };
ULONG    KsIndex = 0;

//////////////////////////////////////////////////////////////////////////
// Private functions.
//////////////////////////////////////////////////////////////////////////

NTSTATUS
NTAPI
KspUtilAddrInfoToAddrInfoEx(
  _In_ PADDRINFOA AddrInfo,
  _Out_ PADDRINFOEXW* AddrInfoEx
  )
{
  NTSTATUS Status;

  //
  // Convert NULL input into NULL output.
  //

  if (AddrInfo == NULL)
  {
    *AddrInfoEx = NULL;
    return STATUS_SUCCESS;
  }

  //
  // Allocate memory for the output structure.
  //

  PADDRINFOEXW Result = ExAllocatePoolWithTag(PagedPool, sizeof(ADDRINFOEXW), MEMORY_TAG);

  if (Result == NULL)
  {
    Status = STATUS_INSUFFICIENT_RESOURCES;
    goto Error1;
  }

  //
  // Copy numeric values.
  //

  RtlZeroMemory(Result, sizeof(ADDRINFOEXW));
  Result->ai_flags    = AddrInfo->ai_flags;
  Result->ai_family   = AddrInfo->ai_family;
  Result->ai_socktype = AddrInfo->ai_socktype;
  Result->ai_protocol = AddrInfo->ai_protocol;
  Result->ai_addrlen  = AddrInfo->ai_addrlen;

  //
  // Copy canonical name.
  //

  ANSI_STRING CanonicalNameAnsi;
  UNICODE_STRING CanonicalNameUnicode;

  if (AddrInfo->ai_canonname)
  {
    RtlInitAnsiString(&CanonicalNameAnsi, AddrInfo->ai_canonname);

    Status = RtlAnsiStringToUnicodeString(&CanonicalNameUnicode, &CanonicalNameAnsi, TRUE);

    if (!NT_SUCCESS(Status))
    {
      goto Error2;
    }

    Result->ai_canonname = CanonicalNameUnicode.Buffer;
  }

  //
  // Copy address.
  //

  Result->ai_addr = AddrInfo->ai_addr;

  //
  // Copy the next structure (recursively).
  //

  PADDRINFOEXW NextAddrInfo;
  Status = KspUtilAddrInfoToAddrInfoEx(AddrInfo->ai_next, &NextAddrInfo);

  if (!NT_SUCCESS(Status))
  {
    goto Error3;
  }

  Result->ai_next = NextAddrInfo;

  //
  // All done!
  //

  *AddrInfoEx = Result;

  return Status;

Error3:
  RtlFreeAnsiString(&CanonicalNameAnsi);

Error2:
  ExFreePoolWithTag(Result, MEMORY_TAG);

Error1:
  return Status;
}

NTSTATUS
NTAPI
KspUtilAddrInfoExToAddrInfo(
  _In_ PADDRINFOEXW AddrInfoEx,
  _Out_ PADDRINFOA* AddrInfo
  )
{
  NTSTATUS Status;

  //
  // Convert NULL input into NULL output.
  //

  if (AddrInfoEx == NULL)
  {
    *AddrInfo = NULL;
    return STATUS_SUCCESS;
  }

  //
  // Allocate memory for the output structure.
  //

  PADDRINFOA Result = ExAllocatePoolWithTag(PagedPool, sizeof(ADDRINFOA), MEMORY_TAG);

  if (Result == NULL)
  {
    Status = STATUS_INSUFFICIENT_RESOURCES;
    goto Error1;
  }

  //
  // Copy numeric values.
  //

  RtlZeroMemory(Result, sizeof(ADDRINFOA));
  Result->ai_flags    = AddrInfoEx->ai_flags;
  Result->ai_family   = AddrInfoEx->ai_family;
  Result->ai_socktype = AddrInfoEx->ai_socktype;
  Result->ai_protocol = AddrInfoEx->ai_protocol;
  Result->ai_addrlen  = AddrInfoEx->ai_addrlen;

  //
  // Copy canonical name.
  //

  UNICODE_STRING CanonicalNameUnicode;
  ANSI_STRING CanonicalNameAnsi;

  if (AddrInfoEx->ai_canonname)
  {
    RtlInitUnicodeString(&CanonicalNameUnicode, AddrInfoEx->ai_canonname);
    Status = RtlUnicodeStringToAnsiString(&CanonicalNameAnsi, &CanonicalNameUnicode, TRUE);

    if (!NT_SUCCESS(Status))
    {
      goto Error2;
    }

    Result->ai_canonname = CanonicalNameAnsi.Buffer;
  }

  //
  // Copy address.
  //

  Result->ai_addr = AddrInfoEx->ai_addr;

  //
  // Copy the next structure (recursively).
  //

  PADDRINFOA NextAddrInfo;
  Status = KspUtilAddrInfoExToAddrInfo(AddrInfoEx->ai_next, &NextAddrInfo);

  if (!NT_SUCCESS(Status))
  {
    goto Error3;
  }

  Result->ai_next = NextAddrInfo;

  //
  // All done!
  //

  *AddrInfo = Result;

  return Status;

Error3:
  RtlFreeAnsiString(&CanonicalNameAnsi);

Error2:
  ExFreePoolWithTag(Result, MEMORY_TAG);

Error1:
  return Status;
}

VOID
NTAPI
KspUtilFreeAddrInfo(
  _In_ PADDRINFOA AddrInfo
  )
{
  //
  // Free all structures recursively.
  //

  if (AddrInfo->ai_next)
  {
    KspUtilFreeAddrInfo(AddrInfo->ai_next);
  }

  //
  // Free the canonical name buffer.
  //

  if (AddrInfo->ai_canonname)
  {
    ANSI_STRING CanonicalName;
    RtlInitAnsiString(&CanonicalName, AddrInfo->ai_canonname);
    RtlFreeAnsiString(&CanonicalName);
  }

  //
  // Finally, free the structure itself.
  //

  ExFreePoolWithTag(AddrInfo, MEMORY_TAG);
}

VOID
NTAPI
KspUtilFreeAddrInfoEx(
  _In_ PADDRINFOEXW AddrInfo
  )
{
  //
  // Free all structures recursively.
  //

  if (AddrInfo->ai_next)
  {
    KspUtilFreeAddrInfoEx(AddrInfo->ai_next);
  }

  //
  // Free the canonical name buffer.
  //

  if (AddrInfo->ai_canonname)
  {
    UNICODE_STRING CanonicalName;
    RtlInitUnicodeString(&CanonicalName, AddrInfo->ai_canonname);
    RtlFreeUnicodeString(&CanonicalName);
  }

  //
  // Finally, free the structure itself.
  //

  ExFreePoolWithTag(AddrInfo, MEMORY_TAG);
}

//////////////////////////////////////////////////////////////////////////
// Public functions.
//////////////////////////////////////////////////////////////////////////

uint32_t htonl(uint32_t hostlong)
{
  return RtlUlongByteSwap(hostlong);
}

uint16_t htons(uint16_t hostshort)
{
  return RtlUshortByteSwap(hostshort);
}

uint32_t ntohl(uint32_t netlong)
{
  return RtlUlongByteSwap(netlong);
}

uint16_t ntohs(uint16_t netshort)
{
  return RtlUshortByteSwap(netshort);
}

int getaddrinfo(const char* node, const char* service, const struct addrinfo* hints, struct addrinfo** res)
{
  NTSTATUS Status;

  //
  // Convert node name to the UNICODE_STRING (if present).
  //

  ANSI_STRING NodeNameAnsi;
  UNICODE_STRING NodeNameUnicode;
  PUNICODE_STRING NodeName = NULL;

  if (node)
  {
    RtlInitAnsiString(&NodeNameAnsi, node);
    Status = RtlAnsiStringToUnicodeString(&NodeNameUnicode, &NodeNameAnsi, TRUE);

    if (!NT_SUCCESS(Status))
    {
      goto Error1;
    }

    NodeName = &NodeNameUnicode;
  }

  //
  // Convert service name to the UNICODE_STRING (if present).
  //

  ANSI_STRING ServiceNameAnsi;
  UNICODE_STRING ServiceNameUnicode;
  PUNICODE_STRING ServiceName = NULL;

  if (service)
  {
    RtlInitAnsiString(&ServiceNameAnsi, service);
    Status = RtlAnsiStringToUnicodeString(&ServiceNameUnicode, &ServiceNameAnsi, TRUE);

    if (!NT_SUCCESS(Status))
    {
      goto Error2;
    }

    ServiceName = &ServiceNameUnicode;
  }

  //
  // Convert "struct addrinfo" to the "ADDRINFOEXW".
  //

  PADDRINFOEXW Hints;
  Status = KspUtilAddrInfoToAddrInfoEx((PADDRINFOA)hints, &Hints);

  if (!NT_SUCCESS(Status))
  {
    goto Error3;
  }

  //
  // All data is prepared, call the underlying API.
  //

  PADDRINFOEXW Result;
  Status = KsGetAddrInfo(NodeName, ServiceName, Hints, &Result);

  //
  // Free the memory of the converted "Hints".
  //

  KspUtilFreeAddrInfoEx(Hints);

  if (!NT_SUCCESS(Status))
  {
    goto Error3;
  }

  //
  // Convert the result "ADDRINFOEXW" to the "struct addrinfo".
  //

  Status = KspUtilAddrInfoExToAddrInfo(Result, res);

  //
  // Free the original result.
  //

  KsFreeAddrInfo(Result);

  if (!NT_SUCCESS(Status))
  {
    goto Error3;
  }

  return STATUS_SUCCESS;

Error3:
  RtlFreeUnicodeString(&ServiceNameUnicode);

Error2:
  RtlFreeUnicodeString(&NodeNameUnicode);

Error1:
  return Status;
}

void freeaddrinfo(struct addrinfo *res)
{
  //
  // Call our implementation.
  //

  KspUtilFreeAddrInfo(res);
}

int socket_connection(int domain, int type, int protocol)
{
  NTSTATUS Status;
  PKSOCKET Socket;

  Status = KsCreateConnectionSocket(
    &Socket,
    (ADDRESS_FAMILY)domain,
    (USHORT)type,
    (ULONG)protocol
    );

  if (NT_SUCCESS(Status))
  {
    int sockfd = TO_SOCKETFD(KsIndex++);

    KsArray[FROM_SOCKETFD(sockfd)] = Socket;

    return sockfd;
  }

  return -1;
}

int socket_listen(int domain, int type, int protocol)
{
  NTSTATUS Status;
  PKSOCKET Socket;

  //
  // WskSocket() returns STATUS_PROTOCOL_UNREACHABLE (0xC000023E)
  // when Protocol == 0, so coerce this value to IPPROTO_TCP here.
  //

  Status = KsCreateListenSocket(
    &Socket,
    (ADDRESS_FAMILY)domain,
    (USHORT)type,
    protocol ? (ULONG)protocol : IPPROTO_TCP
    );

  if (NT_SUCCESS(Status))
  {
    int sockfd = TO_SOCKETFD(KsIndex++);

    KsArray[FROM_SOCKETFD(sockfd)] = Socket;

    return sockfd;
  }

  return -1;
}

int socket_datagram(int domain, int type, int protocol)
{
  NTSTATUS Status;
  PKSOCKET Socket;

  Status = KsCreateDatagramSocket(
    &Socket,
    (ADDRESS_FAMILY)domain,
    (USHORT)type,
    (ULONG)protocol
    );

  if (NT_SUCCESS(Status))
  {
    int sockfd = TO_SOCKETFD(KsIndex++);

    KsArray[FROM_SOCKETFD(sockfd)] = Socket;

    return sockfd;
  }

  return -1;
}

int connect(int sockfd, const struct sockaddr* addr, socklen_t addrlen)
{
  UNREFERENCED_PARAMETER(addrlen);

  NTSTATUS Status;
  PKSOCKET Socket = KsArray[FROM_SOCKETFD(sockfd)];

  Status = KsConnect(Socket, (PSOCKADDR)addr);

  return NT_SUCCESS(Status)
    ? 0
    : -1;
}

int listen(int sockfd, int backlog)
{
  UNREFERENCED_PARAMETER(sockfd);
  UNREFERENCED_PARAMETER(backlog);
  return 0;
}

int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen)
{
  UNREFERENCED_PARAMETER(addrlen);

  NTSTATUS Status;
  PKSOCKET Socket = KsArray[FROM_SOCKETFD(sockfd)];

  Status = KsBind(Socket, (PSOCKADDR)addr);

  return NT_SUCCESS(Status)
    ? 0
    : -1;
}

int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen)
{
  NTSTATUS Status;
  PKSOCKET Socket = KsArray[FROM_SOCKETFD(sockfd)];

  PKSOCKET NewSocket;
  Status = KsAccept(Socket, &NewSocket, NULL, (PSOCKADDR)addr);
  *addrlen = sizeof(SOCKADDR);

  if (NT_SUCCESS(Status))
  {
    int newsockfd = TO_SOCKETFD(KsIndex++);

    KsArray[FROM_SOCKETFD(newsockfd)] = NewSocket;

    return newsockfd;
  }

  return -1;
}

int send(int sockfd, const void* buf, size_t len, int flags)
{
  NTSTATUS Status;
  PKSOCKET Socket = KsArray[FROM_SOCKETFD(sockfd)];

  ULONG Length = (ULONG)len;
  Status = KsSend(Socket, (PVOID)buf, &Length, (ULONG)flags);

  return NT_SUCCESS(Status)
    ? (int)Length
    : -1;
}

int sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen)
{
  UNREFERENCED_PARAMETER(addrlen);

  NTSTATUS Status;
  PKSOCKET Socket = KsArray[FROM_SOCKETFD(sockfd)];

  ULONG Length = (ULONG)len;
  Status = KsSendTo(Socket, (PVOID)buf, &Length, (ULONG)flags, (PSOCKADDR)dest_addr);

  return NT_SUCCESS(Status)
    ? (int)Length
    : -1;
}

int recv(int sockfd, void* buf, size_t len, int flags)
{
  NTSTATUS Status;
  PKSOCKET Socket = KsArray[FROM_SOCKETFD(sockfd)];

  ULONG Length = (ULONG)len;
  Status = KsRecv(Socket, (PVOID)buf, &Length, (ULONG)flags);

  return NT_SUCCESS(Status)
    ? (int)Length
    : -1;
}

int recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen)
{
  UNREFERENCED_PARAMETER(addrlen);

  NTSTATUS Status;
  PKSOCKET Socket = KsArray[FROM_SOCKETFD(sockfd)];

  ULONG Length = (ULONG)len;
  Status = KsSendTo(Socket, (PVOID)buf, &Length, (ULONG)flags, (PSOCKADDR)src_addr);
  *addrlen = sizeof(SOCKADDR);

  return NT_SUCCESS(Status)
    ? (int)Length
    : -1;
}

int closesocket(int sockfd)
{
  NTSTATUS Status;
  PKSOCKET Socket = KsArray[FROM_SOCKETFD(sockfd)];

  Status = KsCloseSocket(Socket);

  KsArray[FROM_SOCKETFD(sockfd)] = NULL;

  return NT_SUCCESS(Status)
    ? 0
    : -1;
}

```

`socket-km/ksocket/berkeley.h`:

```h
#pragma once
#include <ntddk.h>
#include <wsk.h>
#include "../stdint.h"

typedef int       socklen_t;
typedef intptr_t  ssize_t;

uint32_t htonl(uint32_t hostlong);
uint16_t htons(uint16_t hostshort);
uint32_t ntohl(uint32_t netlong);
uint16_t ntohs(uint16_t netshort);

int getaddrinfo(const char* node, const char* service, const struct addrinfo* hints, struct addrinfo** res);
void freeaddrinfo(struct addrinfo *res);

int socket_connection(int domain, int type, int protocol);
int socket_listen(int domain, int type, int protocol);
int socket_datagram(int domain, int type, int protocol);
int connect(int sockfd, const struct sockaddr* addr, socklen_t addrlen);
int listen(int sockfd, int backlog);
int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
int send(int sockfd, const void* buf, size_t len, int flags);
int sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);
int recv(int sockfd, void* buf, size_t len, int flags);
int recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);
int closesocket(int sockfd);

#define socket  socket_connection

```

`socket-km/ksocket/ksocket.c`:

```c
#include "ksocket.h"

//////////////////////////////////////////////////////////////////////////
// Definitions.
//////////////////////////////////////////////////////////////////////////

#define MEMORY_TAG            '  sK'

//////////////////////////////////////////////////////////////////////////
// Structures.
//////////////////////////////////////////////////////////////////////////

typedef struct _KSOCKET_ASYNC_CONTEXT
{
  KEVENT CompletionEvent;
  PIRP Irp;
} KSOCKET_ASYNC_CONTEXT, *PKSOCKET_ASYNC_CONTEXT;

typedef struct _KSOCKET
{
  PWSK_SOCKET	WskSocket;

  union
  {
    PVOID WskDispatch;

    PWSK_PROVIDER_CONNECTION_DISPATCH WskConnectionDispatch;
    PWSK_PROVIDER_LISTEN_DISPATCH WskListenDispatch;
    PWSK_PROVIDER_DATAGRAM_DISPATCH WskDatagramDispatch;
#if (NTDDI_VERSION >= NTDDI_WIN10_RS2)
    PWSK_PROVIDER_STREAM_DISPATCH WskStreamDispatch;
#endif
  };

  KSOCKET_ASYNC_CONTEXT AsyncContext;
} KSOCKET, *PKSOCKET;

//////////////////////////////////////////////////////////////////////////
// Variables.
//////////////////////////////////////////////////////////////////////////

WSK_REGISTRATION     WskRegistration;
WSK_PROVIDER_NPI     WskProvider;
WSK_CLIENT_DISPATCH  WskDispatch = { MAKE_WSK_VERSION(1,0), 0, NULL };

//////////////////////////////////////////////////////////////////////////
// Function prototypes.
//////////////////////////////////////////////////////////////////////////

NTSTATUS
NTAPI
KspAsyncContextAllocate(
  _Inout_ PKSOCKET_ASYNC_CONTEXT AsyncContext
  );

VOID
NTAPI
KspAsyncContextFree(
  _In_ PKSOCKET_ASYNC_CONTEXT AsyncContext
  );

VOID
NTAPI
KspAsyncContextReset(
  _In_ PKSOCKET_ASYNC_CONTEXT AsyncContext
  );

NTSTATUS
NTAPI
KspAsyncContextCompletionRoutine(
  _In_ PDEVICE_OBJECT	DeviceObject,
  _In_ PIRP Irp,
  _In_ PKEVENT CompletionEvent
  );

NTSTATUS
NTAPI
KspAsyncContextWaitForCompletion(
  _In_ PKSOCKET_ASYNC_CONTEXT AsyncContext,
  _Inout_ PNTSTATUS Status
  );

//////////////////////////////////////////////////////////////////////////
// Private functions.
//////////////////////////////////////////////////////////////////////////

NTSTATUS
NTAPI
KspAsyncContextAllocate(
  _Inout_ PKSOCKET_ASYNC_CONTEXT AsyncContext
  )
{
  //
  // Initialize the completion event.
  //

  KeInitializeEvent(
    &AsyncContext->CompletionEvent,
    SynchronizationEvent,
    FALSE
    );

  //
  // Initialize the IRP.
  //

  AsyncContext->Irp = IoAllocateIrp(1, FALSE);

  if (AsyncContext->Irp == NULL)
  {
    return STATUS_INSUFFICIENT_RESOURCES;
  }

  //
  // KspAsyncContextCompletionRoutine will set
  // the CompletionEvent.
  //

  IoSetCompletionRoutine(
    AsyncContext->Irp,
    &KspAsyncContextCompletionRoutine,
    &AsyncContext->CompletionEvent,
    TRUE,
    TRUE,
    TRUE
    );

  return STATUS_SUCCESS;
}

VOID
NTAPI
KspAsyncContextFree(
  _In_ PKSOCKET_ASYNC_CONTEXT AsyncContext
  )
{
  //
  // Free the IRP.
  //

  IoFreeIrp(AsyncContext->Irp);
}

VOID
NTAPI
KspAsyncContextReset(
  _In_ PKSOCKET_ASYNC_CONTEXT AsyncContext
  )
{
  //
  // If the WSK application allocated the IRP, or is reusing an IRP
  // that it previously allocated, then it must set an IoCompletion
  // routine for the IRP before calling a WSK function.  In this
  // situation, the WSK application must specify TRUE for the
  // InvokeOnSuccess, InvokeOnError, and InvokeOnCancel parameters that
  // are passed to the IoSetCompletionRoutine function to ensure that
  // the IoCompletion routine is always called. Furthermore, the IoCompletion
  // routine that is set for the IRP must always return
  // STATUS_MORE_PROCESSING_REQUIRED to terminate the completion processing
  // of the IRP.  If the WSK application is done using the IRP after the
  // IoCompletion routine has been called, then it should call the IoFreeIrp
  // function to free the IRP before returning from the IoCompletion routine.
  // If the WSK application does not free the IRP then it can reuse the IRP
  // for a call to another WSK function.
  //
  // (ref: https://docs.microsoft.com/en-us/windows-hardware/drivers/network/using-irps-with-winsock-kernel-functions)
  //

  //
  // Reset the completion event.
  //

  KeResetEvent(&AsyncContext->CompletionEvent);

  //
  // Reuse the IRP.
  //

  IoReuseIrp(AsyncContext->Irp, STATUS_UNSUCCESSFUL);

  IoSetCompletionRoutine(
    AsyncContext->Irp,
    &KspAsyncContextCompletionRoutine,
    &AsyncContext->CompletionEvent,
    TRUE,
    TRUE,
    TRUE
    );
}

NTSTATUS
NTAPI
KspAsyncContextCompletionRoutine(
  _In_ PDEVICE_OBJECT	DeviceObject,
  _In_ PIRP Irp,
  _In_ PKEVENT CompletionEvent
  )
{
  UNREFERENCED_PARAMETER(DeviceObject);
  UNREFERENCED_PARAMETER(Irp);

  KeSetEvent(CompletionEvent, IO_NO_INCREMENT, FALSE);
  return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
NTAPI
KspAsyncContextWaitForCompletion(
  _In_ PKSOCKET_ASYNC_CONTEXT AsyncContext,
  _Inout_ PNTSTATUS Status
  )
{
  if (*Status == STATUS_PENDING)
  {
    KeWaitForSingleObject(
      &AsyncContext->CompletionEvent,
      Executive,
      KernelMode,
      FALSE,
      NULL
      );

    *Status = AsyncContext->Irp->IoStatus.Status;
  }

  return *Status;
}

//////////////////////////////////////////////////////////////////////////
// Public functions.
//////////////////////////////////////////////////////////////////////////

NTSTATUS
NTAPI
KsInitialize(
  VOID
  )
{
  NTSTATUS Status;

  //
  // Register as a WSK client.
  //

  WSK_CLIENT_NPI WskClient;
  WskClient.ClientContext = NULL;
  WskClient.Dispatch      = &WskDispatch;

  Status = WskRegister(&WskClient, &WskRegistration);

  if (!NT_SUCCESS(Status))
  {
    return Status;
  }

  //
  // Capture the provider NPI.
  //

  return WskCaptureProviderNPI(
    &WskRegistration,
    WSK_INFINITE_WAIT,
    &WskProvider
    );
}

VOID
NTAPI
KsDestroy(
  VOID
  )
{
  //
  // Release the provider NPI instance.
  //

  WskReleaseProviderNPI(&WskRegistration);

  //
  // Deregister as a WSK client.
  //

  WskDeregister(&WskRegistration);
}

NTSTATUS
NTAPI
KsGetAddrInfo(
  _In_ PUNICODE_STRING NodeName,
  _In_ PUNICODE_STRING ServiceName,
  _In_ PADDRINFOEXW Hints,
  _Out_ PADDRINFOEXW* Result
  )
{
  NTSTATUS Status;

  //
  // Allocate async context.
  //

  KSOCKET_ASYNC_CONTEXT AsyncContext;
  Status = KspAsyncContextAllocate(&AsyncContext);

  if (!NT_SUCCESS(Status))
  {
    return Status;
  }

  //
  // Call the WSK API.
  //

  Status = WskProvider.Dispatch->WskGetAddressInfo(
    WskProvider.Client,         // Client
    NodeName,                   // NodeName
    ServiceName,                // ServiceName
    0,                          // NameSpace
    NULL,                       // Provider
    Hints,                      // Hints
    Result,                     // Result
    NULL,                       // OwningProcess
    NULL,                       // OwningThread
    AsyncContext.Irp            // Irp
    );

  KspAsyncContextWaitForCompletion(&AsyncContext, &Status);

  //
  // Free the async context.
  //

  KspAsyncContextFree(&AsyncContext);

  return Status;
}

VOID
NTAPI
KsFreeAddrInfo(
  _In_ PADDRINFOEXW AddrInfo
  )
{
  WskProvider.Dispatch->WskFreeAddressInfo(
    WskProvider.Client,         // Client
    AddrInfo                    // AddrInfo
    );
}

NTSTATUS
NTAPI
KsCreateSocket(
  _Out_ PKSOCKET* Socket,
  _In_ ADDRESS_FAMILY AddressFamily,
  _In_ USHORT SocketType,
  _In_ ULONG Protocol,
  _In_ ULONG Flags
  )
{
  NTSTATUS Status;

  //
  // Allocate memory for the socket structure.
  //

  PKSOCKET NewSocket = ExAllocatePoolWithTag(PagedPool, sizeof(KSOCKET), MEMORY_TAG);

  //
  // Allocate async context for the socket.
  //

  Status = KspAsyncContextAllocate(&NewSocket->AsyncContext);

  if (!NT_SUCCESS(Status))
  {
    return Status;
  }

  //
  // Create the WSK socket.
  //

  Status = WskProvider.Dispatch->WskSocket(
    WskProvider.Client,         // Client
    AddressFamily,              // AddressFamily
    SocketType,                 // SocketType
    Protocol,                   // Protocol
    Flags,                      // Flags
    NULL,                       // SocketContext
    NULL,                       // Dispatch
    NULL,                       // OwningProcess
    NULL,                       // OwningThread
    NULL,                       // SecurityDescriptor
    NewSocket->AsyncContext.Irp // Irp
    );

  KspAsyncContextWaitForCompletion(&NewSocket->AsyncContext, &Status);

  //
  // Save the socket instance and the socket dispatch table.
  //

  if (NT_SUCCESS(Status))
  {
    NewSocket->WskSocket = (PWSK_SOCKET)NewSocket->AsyncContext.Irp->IoStatus.Information;
    NewSocket->WskDispatch = (PVOID)NewSocket->WskSocket->Dispatch;

    *Socket = NewSocket;
  }

  return Status;
}

NTSTATUS
NTAPI
KsCreateConnectionSocket(
  _Out_ PKSOCKET* Socket,
  _In_ ADDRESS_FAMILY AddressFamily,
  _In_ USHORT SocketType,
  _In_ ULONG Protocol
  )
{
  return KsCreateSocket(Socket, AddressFamily, SocketType, Protocol, WSK_FLAG_CONNECTION_SOCKET);
}

NTSTATUS
NTAPI
KsCreateListenSocket(
  _Out_ PKSOCKET* Socket,
  _In_ ADDRESS_FAMILY AddressFamily,
  _In_ USHORT SocketType,
  _In_ ULONG Protocol
  )
{
  return KsCreateSocket(Socket, AddressFamily, SocketType, Protocol, WSK_FLAG_LISTEN_SOCKET);
}

NTSTATUS
NTAPI
KsCreateDatagramSocket(
  _Out_ PKSOCKET* Socket,
  _In_ ADDRESS_FAMILY AddressFamily,
  _In_ USHORT SocketType,
  _In_ ULONG Protocol
  )
{
  return KsCreateSocket(Socket, AddressFamily, SocketType, Protocol, WSK_FLAG_DATAGRAM_SOCKET);
}

NTSTATUS
NTAPI
KsCloseSocket(
  _In_ PKSOCKET Socket
  )
{
  NTSTATUS Status;

  //
  // Reset the async context.
  //

  KspAsyncContextReset(&Socket->AsyncContext);

  //
  // Close the WSK socket.
  //

  Status = Socket->WskConnectionDispatch->WskCloseSocket(
    Socket->WskSocket,
    Socket->AsyncContext.Irp
    );

  KspAsyncContextWaitForCompletion(&Socket->AsyncContext, &Status);

  //
  // Free the async context.
  //

  KspAsyncContextFree(&Socket->AsyncContext);

  //
  // Free memory for the socket structure.
  //

  ExFreePoolWithTag(Socket, MEMORY_TAG);

  return Status;
}

NTSTATUS
NTAPI
KsBind(
  _In_ PKSOCKET Socket,
  _In_ PSOCKADDR LocalAddress
  )
{
  NTSTATUS Status;

  //
  // Reset the async context.
  //

  KspAsyncContextReset(&Socket->AsyncContext);

  //
  // Bind the socket.
  //

  Status = Socket->WskListenDispatch->WskBind(
    Socket->WskSocket,          // Socket
    LocalAddress,               // LocalAddress
    0,                          // Flags (reserved)
    Socket->AsyncContext.Irp    // Irp
    );

  KspAsyncContextWaitForCompletion(&Socket->AsyncContext, &Status);

  return Status;
}

NTSTATUS
NTAPI
KsAccept(
  _In_ PKSOCKET Socket,
  _Out_ PKSOCKET* NewSocket,
  _Out_opt_ PSOCKADDR LocalAddress,
  _Out_opt_ PSOCKADDR RemoteAddress
  )
{
  NTSTATUS Status;

  //
  // Reset the async context.
  //

  KspAsyncContextReset(&Socket->AsyncContext);

  //
  // Accept the connection.
  //

  Status = Socket->WskListenDispatch->WskAccept(
    Socket->WskSocket,          // ListenSocket
    0,                          // Flags
    NULL,                       // AcceptSocketContext
    NULL,                       // AcceptSocketDispatch
    LocalAddress,               // LocalAddress
    RemoteAddress,              // RemoteAddress
    Socket->AsyncContext.Irp    // Irp
    );

  KspAsyncContextWaitForCompletion(&Socket->AsyncContext, &Status);

  //
  // Save the socket instance and the socket dispatch table.
  //

  if (NT_SUCCESS(Status))
  {
    PKSOCKET KNewSocket = ExAllocatePoolWithTag(PagedPool, sizeof(KSOCKET), MEMORY_TAG);

    KNewSocket->WskSocket = (PWSK_SOCKET)Socket->AsyncContext.Irp->IoStatus.Information;
    KNewSocket->WskDispatch = (PVOID)KNewSocket->WskSocket->Dispatch;
    KspAsyncContextAllocate(&KNewSocket->AsyncContext);

    *NewSocket = KNewSocket;
  }

  return Status;
}

NTSTATUS
NTAPI
KsConnect(
  _In_ PKSOCKET Socket,
  _In_ PSOCKADDR RemoteAddress
  )
{
  NTSTATUS Status;

  //
  // Reset the async context.
  //

  KspAsyncContextReset(&Socket->AsyncContext);

  //
  // Bind the socket to the local address.
  //

  SOCKADDR_IN LocalAddress;
  LocalAddress.sin_family       = AF_INET;
  LocalAddress.sin_addr.s_addr  = INADDR_ANY;
  LocalAddress.sin_port         = 0;

  Status = Socket->WskConnectionDispatch->WskBind(
    Socket->WskSocket,          // Socket
    (PSOCKADDR)&LocalAddress,   // LocalAddress
    0,                          // Flags (reserved)
    Socket->AsyncContext.Irp    // Irp
    );

  KspAsyncContextWaitForCompletion(&Socket->AsyncContext, &Status);

  if (!NT_SUCCESS(Status))
  {
    return Status;
  }

  //
  // Reset the async context (again).
  //

  KspAsyncContextReset(&Socket->AsyncContext);

  //
  // Connect to the remote host.
  //
  // N.B.: Instead of calling WskSocket(), WskBind() and WskConnect(),
  // it is possible to just call WskSocketConnect().
  //

  Status = Socket->WskConnectionDispatch->WskConnect(
    Socket->WskSocket,          // Socket
    RemoteAddress,              // RemoteAddress
    0,                          // Flags (reserved)
    Socket->AsyncContext.Irp    // Irp
    );

  KspAsyncContextWaitForCompletion(&Socket->AsyncContext, &Status);

  return Status;
}

NTSTATUS
NTAPI
KsSendRecv(
  _In_ PKSOCKET Socket,
  _In_ PVOID Buffer,
  _Inout_ PULONG Length,
  _In_ ULONG Flags,
  _In_ BOOLEAN Send
  )
{
  NTSTATUS Status;

  //
  // Wrap the buffer into the "WSK buffer".
  //

  WSK_BUF WskBuffer;
  WskBuffer.Offset  = 0;
  WskBuffer.Length  = *Length;
  WskBuffer.Mdl     = IoAllocateMdl(Buffer, (ULONG)WskBuffer.Length, FALSE, FALSE, NULL);

  __try
  {
    MmProbeAndLockPages(WskBuffer.Mdl, KernelMode, IoWriteAccess);
  }
  __except (EXCEPTION_EXECUTE_HANDLER)
  {
    Status = STATUS_ACCESS_VIOLATION;
    goto Exit;
  }

  //
  // Reset the async context.
  //

  KspAsyncContextReset(&Socket->AsyncContext);

  //
  // Send / receive the data.
  //

  if (Send)
  {
    Status = Socket->WskConnectionDispatch->WskSend(
      Socket->WskSocket,        // Socket
      &WskBuffer,               // Buffer
      Flags,                    // Flags
      Socket->AsyncContext.Irp  // Irp
      );
  }
  else
  {
    Status = Socket->WskConnectionDispatch->WskReceive(
      Socket->WskSocket,        // Socket
      &WskBuffer,               // Buffer
      Flags,                    // Flags
      Socket->AsyncContext.Irp  // Irp
      );
  }

  KspAsyncContextWaitForCompletion(&Socket->AsyncContext, &Status);

  //
  // Set the number of bytes sent / received.
  //

  if (NT_SUCCESS(Status))
  {
    *Length = (ULONG)Socket->AsyncContext.Irp->IoStatus.Information;
  }

Exit:
  //
  // Free the MDL.
  //

  IoFreeMdl(WskBuffer.Mdl);
  return Status;
}

NTSTATUS
NTAPI
KsSendRecvUdp(
  _In_ PKSOCKET Socket,
  _In_ PVOID Buffer,
  _Inout_ PULONG Length,
  _In_ ULONG Flags,
  _In_ PSOCKADDR RemoteAddress,
  _In_ BOOLEAN Send
  )
{
  NTSTATUS Status;

  //
  // Wrap the buffer into the "WSK buffer".
  //

  WSK_BUF WskBuffer;
  WskBuffer.Offset  = 0;
  WskBuffer.Length  = *Length;
  WskBuffer.Mdl     = IoAllocateMdl(Buffer, (ULONG)WskBuffer.Length, FALSE, FALSE, NULL);

  __try
  {
    MmProbeAndLockPages(WskBuffer.Mdl, KernelMode, IoWriteAccess);
  }
  __except (EXCEPTION_EXECUTE_HANDLER)
  {
    Status = STATUS_ACCESS_VIOLATION;
    goto Exit;
  }

  //
  // Reset the async context.
  //

  KspAsyncContextReset(&Socket->AsyncContext);

  //
  // Send / receive the data.
  //

  if (Send)
  {
    Status = Socket->WskDatagramDispatch->WskSendTo(
      Socket->WskSocket,        // Socket
      &WskBuffer,               // Buffer
      Flags,                    // Flags (reserved)
      RemoteAddress,            // RemoteAddress
      0,                        // ControlInfoLength
      NULL,                     // ControlInfo
      Socket->AsyncContext.Irp  // Irp
      );
  }
  else
  {
    Status = Socket->WskDatagramDispatch->WskReceiveFrom(
      Socket->WskSocket,        // Socket
      &WskBuffer,               // Buffer
      Flags,                    // Flags (reserved)
      RemoteAddress,            // RemoteAddress
      0,                        // ControlInfoLength
      NULL,                     // ControlInfo
      NULL,                     // ControlFlags
      Socket->AsyncContext.Irp  // Irp
      );
  }

  KspAsyncContextWaitForCompletion(&Socket->AsyncContext, &Status);

  //
  // Set the number of bytes sent / received.
  //

  if (NT_SUCCESS(Status))
  {
    *Length = (ULONG)Socket->AsyncContext.Irp->IoStatus.Information;
  }

Exit:
  //
  // Free the MDL.
  //

  IoFreeMdl(WskBuffer.Mdl);
  return Status;
}

NTSTATUS
NTAPI
KsSend(
  _In_ PKSOCKET Socket,
  _In_ PVOID Buffer,
  _Inout_ PULONG Length,
  _In_ ULONG Flags
  )
{
  return KsSendRecv(Socket, Buffer, Length, Flags, TRUE);
}

NTSTATUS
NTAPI
KsRecv(
  _In_ PKSOCKET Socket,
  _In_ PVOID Buffer,
  _Inout_ PULONG Length,
  _In_ ULONG Flags
  )
{
  return KsSendRecv(Socket, Buffer, Length, Flags, FALSE);
}

NTSTATUS
NTAPI
KsSendTo(
  _In_ PKSOCKET Socket,
  _In_ PVOID Buffer,
  _Inout_ PULONG Length,
  _In_ ULONG Flags,
  _In_ PSOCKADDR RemoteAddress
  )
{
  return KsSendRecvUdp(Socket, Buffer, Length, Flags, RemoteAddress, TRUE);
}

NTSTATUS
NTAPI
KsRecvFrom(
  _In_ PKSOCKET Socket,
  _In_ PVOID Buffer,
  _Inout_ PULONG Length,
  _In_ ULONG Flags,
  _In_ PSOCKADDR RemoteAddress
  )
{
  return KsSendRecvUdp(Socket, Buffer, Length, Flags, RemoteAddress, FALSE);
}

```

`socket-km/ksocket/ksocket.h`:

```h
#pragma once
#include <ntddk.h>
#include <wsk.h>

typedef struct _KSOCKET KSOCKET, *PKSOCKET;

NTSTATUS
NTAPI
KsInitialize(
  VOID
  );

VOID
NTAPI
KsDestroy(
  VOID
  );

NTSTATUS
NTAPI
KsGetAddrInfo(
  _In_ PUNICODE_STRING NodeName,
  _In_ PUNICODE_STRING ServiceName,
  _In_ PADDRINFOEXW Hints,
  _Out_ PADDRINFOEXW* Result
  );

VOID
NTAPI
KsFreeAddrInfo(
  _In_ PADDRINFOEXW AddrInfo
  );

NTSTATUS
NTAPI
KsCreateSocket(
  _Out_ PKSOCKET* Socket,
  _In_ ADDRESS_FAMILY AddressFamily,
  _In_ USHORT SocketType,
  _In_ ULONG Protocol,
  _In_ ULONG Flags
  );

NTSTATUS
NTAPI
KsCreateConnectionSocket(
  _Out_ PKSOCKET* Socket,
  _In_ ADDRESS_FAMILY AddressFamily,
  _In_ USHORT SocketType,
  _In_ ULONG Protocol
  );

NTSTATUS
NTAPI
KsCreateListenSocket(
  _Out_ PKSOCKET* Socket,
  _In_ ADDRESS_FAMILY AddressFamily,
  _In_ USHORT SocketType,
  _In_ ULONG Protocol
  );

NTSTATUS
NTAPI
KsCreateDatagramSocket(
  _Out_ PKSOCKET* Socket,
  _In_ ADDRESS_FAMILY AddressFamily,
  _In_ USHORT SocketType,
  _In_ ULONG Protocol
  );

NTSTATUS
NTAPI
KsCloseSocket(
  _In_ PKSOCKET Socket
  );

NTSTATUS
NTAPI
KsBind(
  _In_ PKSOCKET Socket,
  _In_ PSOCKADDR LocalAddress
  );

NTSTATUS
NTAPI
KsAccept(
  _In_ PKSOCKET Socket,
  _Out_ PKSOCKET* NewSocket,
  _Out_opt_ PSOCKADDR LocalAddress,
  _Out_opt_ PSOCKADDR RemoteAddress
  );

NTSTATUS
NTAPI
KsConnect(
  _In_ PKSOCKET Socket,
  _In_ PSOCKADDR RemoteAddress
  );

NTSTATUS
NTAPI
KsSendRecv(
  _In_ PKSOCKET Socket,
  _In_ PVOID Buffer,
  _Inout_ PULONG Length,
  _In_ ULONG Flags,
  _In_ BOOLEAN Send
  );

NTSTATUS
NTAPI
KsSendRecvUdp(
  _In_ PKSOCKET Socket,
  _In_ PVOID Buffer,
  _Inout_ PULONG Length,
  _In_ ULONG Flags,
  _In_ PSOCKADDR RemoteAddress,
  _In_ BOOLEAN Send
  );

NTSTATUS
NTAPI
KsSend(
  _In_ PKSOCKET Socket,
  _In_ PVOID Buffer,
  _Inout_ PULONG Length,
  _In_ ULONG Flags
  );

NTSTATUS
NTAPI
KsRecv(
  _In_ PKSOCKET Socket,
  _In_ PVOID Buffer,
  _Inout_ PULONG Length,
  _In_ ULONG Flags
  );

NTSTATUS
NTAPI
KsSendTo(
  _In_ PKSOCKET Socket,
  _In_ PVOID Buffer,
  _Inout_ PULONG Length,
  _In_ ULONG Flags,
  _In_ PSOCKADDR RemoteAddress
  );

NTSTATUS
NTAPI
KsRecvFrom(
  _In_ PKSOCKET Socket,
  _In_ PVOID Buffer,
  _Inout_ PULONG Length,
  _In_ ULONG Flags,
  _In_ PSOCKADDR RemoteAddress
  );

```

`socket-km/log.h`:

```h
#pragma once
#include <ntddk.h>

template <typename... Args>
void log(const char* format, Args... args)
{
	DbgPrintEx(0, 0, "[alxbrn_driver] ");
	DbgPrintEx(0, 0, format, args...);
	DbgPrintEx(0, 0, "\n");
}
```

`socket-km/main.cpp`:

```cpp
#include "log.h"

extern void NTAPI server_thread(void*);

extern "C" NTSTATUS DriverEntry(
	PDRIVER_OBJECT  driver_object,
	PUNICODE_STRING registry_path
)
{
	// These are invalid for mapped drivers.
	UNREFERENCED_PARAMETER(driver_object);
	UNREFERENCED_PARAMETER(registry_path);

	HANDLE thread_handle = nullptr;

	// Create server thread that will wait for incoming connections.
	const auto status = PsCreateSystemThread(
		&thread_handle,
		GENERIC_ALL,
		nullptr,
		nullptr,
		nullptr,
		server_thread,
		nullptr
	);

	if (!NT_SUCCESS(status))
	{
		log("Failed to create server thread. Status code: %X.", status);
		return STATUS_UNSUCCESSFUL;
	}

	ZwClose(thread_handle);
	return STATUS_SUCCESS;
}
```

`socket-km/packet_handler.cpp`:

```cpp
#include "server_shared.h"
#include "sockets.h"
#include "imports.h"
#include "log.h"

static uint64_t handle_copy_memory(const PacketCopyMemory& packet)
{
	PEPROCESS dest_process = nullptr;
	PEPROCESS src_process = nullptr;

	if (!NT_SUCCESS(PsLookupProcessByProcessId(HANDLE(packet.dest_process_id), &dest_process)))
	{
		return uint64_t(STATUS_INVALID_CID);
	}

	if (!NT_SUCCESS(PsLookupProcessByProcessId(HANDLE(packet.src_process_id), &src_process)))
	{
		ObDereferenceObject(dest_process);
		return uint64_t(STATUS_INVALID_CID);
	}

	SIZE_T   return_size = 0;
	NTSTATUS status = MmCopyVirtualMemory(
		src_process,
		(void*)packet.src_address,
		dest_process,
		(void*)packet.dest_address,
		packet.size,
		UserMode,
		&return_size
	);

	ObDereferenceObject(dest_process);
	ObDereferenceObject(src_process);

	return uint64_t(status);
}

static uint64_t handle_get_base_address(const PacketGetBaseAddress& packet)
{
	PEPROCESS process = nullptr;
	NTSTATUS  status = PsLookupProcessByProcessId(HANDLE(packet.process_id), &process);

	if (!NT_SUCCESS(status))
		return 0;

	const auto base_address = uint64_t(PsGetProcessSectionBaseAddress(process));
	ObDereferenceObject(process);

	return base_address;
}

// Send completion packet.
bool complete_request(const SOCKET client_connection, const uint64_t result)
{
	Packet packet{ };

	packet.header.magic = packet_magic;
	packet.header.type = PacketType::packet_completed;
	packet.data.completed.result = result;

	return send(client_connection, &packet, sizeof(packet), 0) != SOCKET_ERROR;
}

static uintptr_t get_kernel_address(const char* name, size_t& size) {
	NTSTATUS status = STATUS_SUCCESS;
	ULONG neededSize = 0;

	ZwQuerySystemInformation(
		SystemModuleInformation,
		&neededSize,
		0,
		&neededSize
	);

	PSYSTEM_MODULE_INFORMATION pModuleList;

	pModuleList = (PSYSTEM_MODULE_INFORMATION)ExAllocatePool(NonPagedPool, neededSize);

	if (!pModuleList) {
		log("ExAllocatePoolWithTag failed(kernel addr)\n");
		return 0;
	}

	status = ZwQuerySystemInformation(SystemModuleInformation,
		pModuleList,
		neededSize,
		0
	);

	ULONG i = 0;
	uintptr_t address = 0;

	for (i = 0; i < pModuleList->ulModuleCount; i++)
	{
		SYSTEM_MODULE mod = pModuleList->Modules[i];

		address = uintptr_t(pModuleList->Modules[i].Base);
		size = uintptr_t(pModuleList->Modules[i].Size);
		if (strstr(mod.ImageName, name) != NULL)
			break;
	}

	ExFreePool(pModuleList);

	return address;
}

static uint64_t clean_piddb_cache() {
	log("clean_piddb_cache started!");
	PRTL_AVL_TABLE PiDDBCacheTable;

	size_t size;
	uintptr_t ntoskrnlBase = get_kernel_address("ntoskrnl.exe", size);

	log("ntoskrnl.exe: %d\n", ntoskrnlBase);
	log("ntoskrnl.exe size: %d\n", size);

	PiDDBCacheTable = (PRTL_AVL_TABLE)dereference(find_pattern<uintptr_t>((void*)ntoskrnlBase, size, "\x48\x8d\x0d\x00\x00\x00\x00\xe8\x00\x00\x00\x00\x3d\x00\x00\x00\x00\x0f\x83", "xxx????x????x????xx"), 3);

	log("PiDDBCacheTable: %d\n", PiDDBCacheTable);

	if (!PiDDBCacheTable) {
		log("PiDDBCacheTable equals 0\n");
		return 0;
	}

	uintptr_t entry_address = uintptr_t(PiDDBCacheTable->BalancedRoot.RightChild) + sizeof(RTL_BALANCED_LINKS);
	log("entry_address: %d\n", entry_address);

	piddbcache* entry = (piddbcache*)(entry_address);

	/*capcom.sys(drvmap) : 0x57CD1415 iqvw64e.sys(kdmapper) : 0x5284EAC3, also cpuz driver*/
	if (entry->TimeDateStamp == 0x57CD1415 || entry->TimeDateStamp == 0x5284EAC3) {
		entry->TimeDateStamp = 0x54EAC3;
		entry->DriverName = RTL_CONSTANT_STRING(L"monitor.sys");
	}

	log("clean_piddb_cache before:\n");
	ULONG count = 0;
	for (auto link = entry->List.Flink; link != entry->List.Blink; link = link->Flink, count++)
	{
		piddbcache* cache_entry = (piddbcache*)(link);

		log("cache_entry count: %lu name: %wZ \t\t stamp: %x \t\t load_status: %q \n",
			count,
			cache_entry->DriverName,
			cache_entry->TimeDateStamp,
			cache_entry->LoadStatus);

		if (cache_entry->TimeDateStamp == 0x57CD1415 || cache_entry->TimeDateStamp == 0x5284EAC3) {
			cache_entry->TimeDateStamp = 0x54EAC4 + count;
			cache_entry->DriverName = RTL_CONSTANT_STRING(L"monitor.sys");
		}
	}

	return 1;
}

static uint64_t clean_unloaded_drivers() {
	log("clean_uloaded_drivers started!\n");
	ULONG bytes = 0;
	auto status = ZwQuerySystemInformation(SystemModuleInformation, 0, bytes, &bytes);

	if (!bytes)
		return 0;

	PRTL_PROCESS_MODULES modules = (PRTL_PROCESS_MODULES)ExAllocatePool(NonPagedPool, bytes);

	status = ZwQuerySystemInformation(SystemModuleInformation, modules, bytes, &bytes);

	if (!NT_SUCCESS(status)) {
		log("ZwQuerySystemInformation failed(unloaded drivers)\n");
		ExFreePool(modules);
		return 0;
	}

	PRTL_PROCESS_MODULE_INFORMATION module = modules->Modules;
	uintptr_t ntoskrnlBase = 0;
	size_t ntoskrnlSize = 0;

	ntoskrnlBase = get_kernel_address("ntoskrnl.exe", ntoskrnlSize);

	ExFreePool(modules);

	if (ntoskrnlBase <= 0) {
		log("get_kernel_address failed(unloaded drivers)\n");
		return 0;
	}

	// NOTE: 4C 8B ? ? ? ? ? 4C 8B C9 4D 85 ? 74 + 3 + current signature address = MmUnloadedDrivers
	auto mmUnloadedDriversPtr = find_pattern<uintptr_t>((void*)ntoskrnlBase, ntoskrnlSize, "\x4C\x8B\x00\x00\x00\x00\x00\x4C\x8B\xC9\x4D\x85\x00\x74", "xx?????xxxxx?x");

	log("mmUnloadedDriversPtr: %d\n", mmUnloadedDriversPtr);

	if (!mmUnloadedDriversPtr) {
		log("mmUnloadedDriversPtr equals 0(unloaded drivers)\n");
		return 0;
	}

	uintptr_t mmUnloadedDrivers = dereference(mmUnloadedDriversPtr, 3);

	memset(*(uintptr_t**)mmUnloadedDrivers, 0, 0x7D0);

	log("clean_uloaded_drivers finished!\n");

	return 1;
}

static uint64_t spoof_drives()
{
	log("Not implemented!");

	return 1;
}

uint64_t handle_incoming_packet(const Packet& packet)
{
	switch (packet.header.type)
	{
	case PacketType::packet_copy_memory:
		return handle_copy_memory(packet.data.copy_memory);

	case PacketType::packet_get_base_address:
		return handle_get_base_address(packet.data.get_base_address);

	case PacketType::packet_clean_piddbcachetable:
		return clean_piddb_cache();

	case PacketType::packet_clean_mmunloadeddrivers:
		return clean_unloaded_drivers();

	case PacketType::packet_spoof_drives:
		return spoof_drives();

	default:
		break;
	}

	return uint64_t(STATUS_NOT_IMPLEMENTED);
}

```

`socket-km/server.cpp`:

```cpp
#include "server_shared.h"
#include "sockets.h"
#include "log.h"

extern uint64_t handle_incoming_packet(const Packet& packet);
extern bool		complete_request(SOCKET client_connection, uint64_t result);

static SOCKET create_listen_socket()
{
	SOCKADDR_IN address{ };

	address.sin_family	= AF_INET;
	address.sin_port	= htons(server_port);

	const auto listen_socket = socket_listen(AF_INET, SOCK_STREAM, 0);
	if (listen_socket == INVALID_SOCKET)
	{
		log("Failed to create listen socket.");
		return INVALID_SOCKET;
	}

	if (bind(listen_socket, (SOCKADDR*)&address, sizeof(address)) == SOCKET_ERROR)
	{
		log("Failed to bind socket.");

		closesocket(listen_socket);
		return INVALID_SOCKET;
	}

	if (listen(listen_socket, 10) == SOCKET_ERROR)
	{
		log("Failed to set socket mode to listening.");

		closesocket(listen_socket);
		return INVALID_SOCKET;
	}

	return listen_socket;
}

// Connection handling thread.
static void NTAPI connection_thread(void* connection_socket)
{
	const auto client_connection = SOCKET(ULONG_PTR(connection_socket));
	log("New connection.");

	Packet packet{ };
	while (true)
	{
		const auto result = recv(client_connection, (void*)&packet, sizeof(packet), 0);
		if (result <= 0)
			break;

		if (result < sizeof(PacketHeader))
			continue;

		if (packet.header.magic != packet_magic)
			continue;

		const auto packet_result = handle_incoming_packet(packet);
		if (!complete_request(client_connection, packet_result))
			break;
	}

	log("Connection closed.");
	closesocket(client_connection);
}

// Main server thread.
void NTAPI server_thread(void*)
{
	auto status = KsInitialize();
	if (!NT_SUCCESS(status))
	{
		log("Failed to initialize KSOCKET. Status code: %X.", status);
		return;
	}

	const auto listen_socket = create_listen_socket();
	if (listen_socket == INVALID_SOCKET)
	{
		log("Failed to initialize listening socket.");

		KsDestroy();
		return;
	}

	log("Listening on port %d.", server_port);

	while (true)
	{
		sockaddr  socket_addr{ };
		socklen_t socket_length{ };

		const auto client_connection = accept(listen_socket, &socket_addr, &socket_length);
		if (client_connection == INVALID_SOCKET)
		{
			log("Failed to accept client connection.");
			break;
		}

		HANDLE thread_handle = nullptr;

		// Create a thread that will handle connection with client.
		// TODO: Limit number of threads.
		status = PsCreateSystemThread(
			&thread_handle,
			GENERIC_ALL,
			nullptr,
			nullptr,
			nullptr,
			connection_thread,
			(void*)client_connection
		);

		if (!NT_SUCCESS(status))
		{
			log("Failed to create thread for handling client connection.");

			closesocket(client_connection);
			break;
		}

		ZwClose(thread_handle);
	}

	closesocket(listen_socket);

	// Better not destroy, maybe threads handling client connection are still running.
	// TODO: Fix it
	// KsDestroy();
}
```

`socket-km/server_shared.h`:

```h
#pragma once
#include "stdint.h"

constexpr auto packet_magic = 0x12345568;
constexpr auto server_ip = 0x7F000001; // 127.0.0.1
constexpr auto server_port = 29125;

enum class PacketType
{
	packet_copy_memory,
	packet_get_base_address,
	packet_clean_piddbcachetable,
	packet_clean_mmunloadeddrivers,
	packet_spoof_drives,
	packet_completed
};

struct PacketCopyMemory
{
	uint32_t dest_process_id;
	uint64_t dest_address;

	uint32_t src_process_id;
	uint64_t src_address;

	uint32_t size;
};

struct PacketGetBaseAddress
{
	uint32_t process_id;
};

struct PacketGetProcessId
{
	char* process_name;
};

struct PacketCleanPiDDBCacheTable {
};

struct PacketCleanMMUnloadedDrivers {
};

struct PacketSpoofDrives {
};

struct PackedCompleted
{
	uint64_t result;
};

struct PacketHeader
{
	uint32_t   magic;
	PacketType type;
};

struct Packet
{
	PacketHeader header;
	union
	{
		PacketCopyMemory	 copy_memory;
		PacketGetBaseAddress get_base_address;
		PacketCleanPiDDBCacheTable clean_piddbcachetable;
		PacketCleanMMUnloadedDrivers clean_mmunloadeddrivers;
		PacketSpoofDrives	 spoof_drives;
		PackedCompleted		 completed;
	} data;
};

```

`socket-km/socket-km.inf`:

```inf
;
; socket-km.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=Sample ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=socket-km.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages

[DestinationDirs]
DefaultDestDir = 12
socket-km_Device_CoInstaller_CopyFiles = 11

; ================= Class section =====================

[ClassInstall32]
Addreg=SampleClassReg

[SampleClassReg]
HKR,,,0,%ClassName%
HKR,,Icon,,-5

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
socket-km.sys  = 1,,
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll=1 ; make sure the number matches with SourceDisksNames

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%socket-km.DeviceDesc%=socket-km_Device, Root\socket-km ; TODO: edit hw-id

[socket-km_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
socket-km.sys

;-------------- Service installation
[socket-km_Device.NT.Services]
AddService = socket-km,%SPSVCINST_ASSOCSERVICE%, socket-km_Service_Inst

; -------------- socket-km driver install sections
[socket-km_Service_Inst]
DisplayName    = %socket-km.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\socket-km.sys

;
;--- socket-km_Device Coinstaller installation ------
;

[socket-km_Device.NT.CoInstallers]
AddReg=socket-km_Device_CoInstaller_AddReg
CopyFiles=socket-km_Device_CoInstaller_CopyFiles

[socket-km_Device_CoInstaller_AddReg]
HKR,,CoInstallers32,0x00010000, "WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll,WdfCoInstaller"

[socket-km_Device_CoInstaller_CopyFiles]
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll

[socket-km_Device.NT.Wdf]
KmdfService =  socket-km, socket-km_wdfsect
[socket-km_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName="Samples" ; TODO: edit ClassName
DiskName = "socket-km Installation Disk"
socket-km.DeviceDesc = "socket-km Device"
socket-km.SVCDESC = "socket-km Service"

```

`socket-km/socket-km.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{1BB91B25-67A5-4CB7-8379-DF7C886CE06A}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>socket_km</RootNamespace>
    <WindowsTargetPlatformVersion>$(LatestTargetPlatformVersion)</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
    <Link>
      <AdditionalDependencies>Netio.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="ksocket\berkeley.c" />
    <ClCompile Include="ksocket\ksocket.c" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="packet_handler.cpp" />
    <ClCompile Include="server.cpp" />
    <ClCompile Include="util.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="imports.h" />
    <ClInclude Include="ksocket\berkeley.h" />
    <ClInclude Include="ksocket\ksocket.h" />
    <ClInclude Include="log.h" />
    <ClInclude Include="server_shared.h" />
    <ClInclude Include="sockets.h" />
    <ClInclude Include="stdint.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`socket-km/socket-km.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="server.cpp" />
    <ClCompile Include="util.c" />
    <ClCompile Include="ksocket\berkeley.c" />
    <ClCompile Include="ksocket\ksocket.c" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="packet_handler.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="server_shared.h" />
    <ClInclude Include="sockets.h" />
    <ClInclude Include="stdint.h" />
    <ClInclude Include="ksocket\berkeley.h" />
    <ClInclude Include="ksocket\ksocket.h" />
    <ClInclude Include="imports.h" />
    <ClInclude Include="log.h" />
  </ItemGroup>
</Project>
```

`socket-km/sockets.h`:

```h
#pragma once

extern "C"
{
	#include "ksocket/ksocket.h"
	#include "ksocket/berkeley.h"
}

typedef int SOCKET;

#define INVALID_SOCKET  (SOCKET)(-1)
#define SOCKET_ERROR            (-1)
```

`socket-km/stdint.h`:

```h
#pragma once

typedef signed char        int8_t;
typedef short              int16_t;
typedef int                int32_t;
typedef long long          int64_t;
typedef unsigned char      uint8_t;
typedef unsigned short     uint16_t;
typedef unsigned int       uint32_t;
typedef unsigned long long uint64_t;
```

`socket-um/driver.cpp`:

```cpp
#include "driver.h"
#include "server_shared.h"

#pragma comment(lib, "Ws2_32")

static bool send_packet(
	const SOCKET	connection,
	const Packet& packet,
	uint64_t& out_result)
{
	Packet completion_packet{ };

	if (send(connection, (const char*)&packet, sizeof(Packet), 0) == SOCKET_ERROR)
		return false;

	const auto result = recv(connection, (char*)&completion_packet, sizeof(Packet), 0);
	if (result < sizeof(PacketHeader) ||
		completion_packet.header.magic != packet_magic ||
		completion_packet.header.type != PacketType::packet_completed)
		return false;

	out_result = completion_packet.data.completed.result;
	return true;
}

static uint32_t copy_memory(
	const SOCKET	connection,
	const uint32_t	src_process_id,
	const uintptr_t src_address,
	const uint32_t	dest_process_id,
	const uintptr_t	dest_address,
	const size_t	size)
{
	Packet packet{ };

	packet.header.magic = packet_magic;
	packet.header.type = PacketType::packet_copy_memory;

	auto& data = packet.data.copy_memory;
	data.src_process_id = src_process_id;
	data.src_address = uint64_t(src_address);
	data.dest_process_id = dest_process_id;
	data.dest_address = uint64_t(dest_address);
	data.size = uint64_t(size);

	uint64_t result = 0;
	if (send_packet(connection, packet, result))
		return uint32_t(result);

	return 0;
}

void driver::initialize()
{
	WSADATA wsa_data;
	WSAStartup(MAKEWORD(2, 2), &wsa_data);
}

void driver::deinitialize()
{
	WSACleanup();
}

SOCKET driver::connect()
{
	SOCKADDR_IN address{ };

	address.sin_family = AF_INET;
	address.sin_addr.s_addr = htonl(server_ip);
	address.sin_port = htons(server_port);

	const auto connection = socket(AF_INET, SOCK_STREAM, 0);
	if (connection == INVALID_SOCKET)
		return INVALID_SOCKET;

	if (connect(connection, (SOCKADDR*)&address, sizeof(address)) == SOCKET_ERROR)
	{
		closesocket(connection);
		return INVALID_SOCKET;
	}

	return connection;
}

void driver::disconnect(const SOCKET connection)
{
	closesocket(connection);
}

uint32_t driver::read_memory(
	const SOCKET	connection,
	const uint32_t	process_id,
	const uintptr_t address,
	const uintptr_t buffer,
	const size_t	size)
{
	return copy_memory(connection, process_id, address, GetCurrentProcessId(), buffer, size);
}

uint32_t driver::write_memory(
	const SOCKET	connection,
	const uint32_t	process_id,
	const uintptr_t address,
	const uintptr_t buffer,
	const size_t	size)
{
	return copy_memory(connection, GetCurrentProcessId(), buffer, process_id, address, size);
}

uint64_t driver::get_process_base_address(const SOCKET connection, const uint32_t process_id)
{
	Packet packet{ };

	packet.header.magic = packet_magic;
	packet.header.type = PacketType::packet_get_base_address;

	auto& data = packet.data.get_base_address;
	data.process_id = process_id;

	uint64_t result = 0;
	if (send_packet(connection, packet, result))
		return result;

	return 0;
}

uint64_t driver::clean_piddbcachetable(const SOCKET connection)
{
	Packet packet{ };

	packet.header.magic = packet_magic;
	packet.header.type = PacketType::packet_clean_piddbcachetable;

	auto& data = packet.data.clean_piddbcachetable;

	uint64_t result = 0;
	if (send_packet(connection, packet, result))
		return 1;

	return 0;
}

uint64_t driver::clean_mmunloadeddrivers(const SOCKET connection)
{
	Packet packet{ };

	packet.header.magic = packet_magic;
	packet.header.type = PacketType::packet_clean_mmunloadeddrivers;

	auto& data = packet.data.clean_mmunloadeddrivers;

	uint64_t result = 0;
	if (send_packet(connection, packet, result))
		return 1;

	return 0;
}

uint64_t driver::spoof_drives(const SOCKET connection)
{
	Packet packet{ };

	packet.header.magic = packet_magic;
	packet.header.type = PacketType::packet_spoof_drives;

	auto& data = packet.data.spoof_drives;

	uint64_t result = 0;
	if (send_packet(connection, packet, result))
		return 1;

	return 0;
}

```

`socket-um/driver.h`:

```h
#pragma once
#include <WinSock2.h>
#include <cstdint>

namespace driver
{
	void	initialize();
	void	deinitialize();

	SOCKET	connect();
	void	disconnect(SOCKET connection);

	uint32_t read_memory(SOCKET connection, uint32_t process_id, uintptr_t address, uintptr_t buffer, size_t size);
	uint32_t write_memory(SOCKET connection, uint32_t process_id, uintptr_t address, uintptr_t buffer, size_t size);
	uint64_t get_process_base_address(SOCKET connection, uint32_t process_id);
	uint64_t clean_piddbcachetable(SOCKET connection);
	uint64_t clean_mmunloadeddrivers(SOCKET connection);
	uint64_t spoof_drives(SOCKET connection);

	template <typename T>
	T read(const SOCKET connection, const uint32_t process_id, const uintptr_t address)
	{
		T buffer{ };
		read_memory(connection, process_id, address, uint64_t(&buffer), sizeof(T));

		return buffer;
	}

	template <typename T>
	void write(const SOCKET connection, const uint32_t process_id, const uintptr_t address, const T& buffer)
	{
		write_memory(connection, process_id, address, uint64_t(&buffer), sizeof(T));
	}
}
```

`socket-um/main.cpp`:

```cpp
#include "driver.h"
#include <iostream>
#include <TlHelp32.h>

std::uint32_t find_process_by_id(const std::string& name)
{
	const auto snap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	if (snap == INVALID_HANDLE_VALUE) {
		return 0;
	}

	PROCESSENTRY32 proc_entry{};
	proc_entry.dwSize = sizeof proc_entry;

	auto found_process = false;
	if (!!Process32First(snap, &proc_entry)) {
		do {
			if (name == proc_entry.szExeFile) {
				found_process = true;
				break;
			}
		} while (!!Process32Next(snap, &proc_entry));
	}

	CloseHandle(snap);
	return found_process
		? proc_entry.th32ProcessID
		: 0;
}

void example()
{
	const auto connection = driver::connect();
	if (connection == INVALID_SOCKET)
	{
		std::cout << "Connection failed.\n";
		return;
	}

	// Loader spoofing
	driver::clean_piddbcachetable(connection);
	driver::clean_mmunloadeddrivers(connection);

	// Spoof drives
	driver::spoof_drives(connection);

	// Cheat related stuff
	const auto pid = find_process_by_id("notepad.exe");
	std::printf("Process id: %p.\n", pid);

	const auto base_address = driver::get_process_base_address(connection, pid);
	std::printf("Process base address: %p.\n", (void*)base_address);

	const auto dos_magic = driver::read<uint16_t>(connection, pid, base_address);
	std::printf("DOS signature: %X.\n", dos_magic);

	driver::disconnect(connection);
}

int main()
{
	driver::initialize();

	example();

	driver::deinitialize();
	std::cin.get();
}

```

`socket-um/server_shared.h`:

```h
#pragma once
#include "stdint.h"

constexpr auto packet_magic = 0x12345568;
constexpr auto server_ip = 0x7F000001; // 127.0.0.1
constexpr auto server_port = 29125;

enum class PacketType
{
	packet_copy_memory,
	packet_get_base_address,
	packet_clean_piddbcachetable,
	packet_clean_mmunloadeddrivers,
	packet_spoof_drives,
	packet_completed
};

struct PacketCopyMemory
{
	uint32_t dest_process_id;
	uint64_t dest_address;

	uint32_t src_process_id;
	uint64_t src_address;

	uint32_t size;
};

struct PacketGetBaseAddress
{
	uint32_t process_id;
};

struct PacketGetProcessId
{
	char* process_name;
};

struct PacketCleanPiDDBCacheTable {
};

struct PacketCleanMMUnloadedDrivers {
};

struct PacketSpoofDrives {
};

struct PackedCompleted
{
	uint64_t result;
};

struct PacketHeader
{
	uint32_t   magic;
	PacketType type;
};

struct Packet
{
	PacketHeader header;
	union
	{
		PacketCopyMemory	 copy_memory;
		PacketGetBaseAddress get_base_address;
		PacketCleanPiDDBCacheTable clean_piddbcachetable;
		PacketCleanMMUnloadedDrivers clean_mmunloadeddrivers;
		PacketSpoofDrives	 spoof_drives;
		PackedCompleted		 completed;
	} data;
};

```

`socket-um/socket-um.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{DDCB0847-184C-4769-8713-A3006A6AF794}</ProjectGuid>
    <RootNamespace>socketum</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="driver.h" />
    <ClInclude Include="server_shared.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="driver.cpp" />
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`socket-um/socket-um.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClInclude Include="server_shared.h" />
    <ClInclude Include="driver.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="driver.cpp" />
    <ClCompile Include="main.cpp" />
  </ItemGroup>
</Project>
```