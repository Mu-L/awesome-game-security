Project Path: arc_Sentient111_VulnerableDriverScanner_2d4byrzx

Source Tree:

```txt
arc_Sentient111_VulnerableDriverScanner_2d4byrzx
├── README.md
└── VulnerableDriverScanner
    ├── ConsoleApplication1.sln
    ├── ConsoleApplication1.vcxproj
    ├── ConsoleApplication1.vcxproj.filters
    ├── FileFinder.h
    ├── PeFile.h
    └── VulnerableDriverScanner.cpp

```

`README.md`:

```md
# VulnerableDriverScanner
 
## DESCRIPTION
This project scans a directory for drivers and checks for a list of imports (currently IoCreateSymbolicLink and IoCreateDevice).

```

`VulnerableDriverScanner/ConsoleApplication1.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31624.102
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ConsoleApplication1", "ConsoleApplication1.vcxproj", "{9421EF64-C5EC-4EC9-9C03-5D877394E674}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{9421EF64-C5EC-4EC9-9C03-5D877394E674}.Debug|x64.ActiveCfg = Debug|x64
		{9421EF64-C5EC-4EC9-9C03-5D877394E674}.Debug|x64.Build.0 = Debug|x64
		{9421EF64-C5EC-4EC9-9C03-5D877394E674}.Debug|x86.ActiveCfg = Debug|Win32
		{9421EF64-C5EC-4EC9-9C03-5D877394E674}.Debug|x86.Build.0 = Debug|Win32
		{9421EF64-C5EC-4EC9-9C03-5D877394E674}.Release|x64.ActiveCfg = Release|x64
		{9421EF64-C5EC-4EC9-9C03-5D877394E674}.Release|x64.Build.0 = Release|x64
		{9421EF64-C5EC-4EC9-9C03-5D877394E674}.Release|x86.ActiveCfg = Release|Win32
		{9421EF64-C5EC-4EC9-9C03-5D877394E674}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {FB44F48E-F3AA-4B01-B488-9F780B772D1C}
	EndGlobalSection
EndGlobal

```

`VulnerableDriverScanner/ConsoleApplication1.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{9421ef64-c5ec-4ec9-9c03-5d877394e674}</ProjectGuid>
    <RootNamespace>VulnerableDriverScanner</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>VulnerableDriverScanner</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="VulnerableDriverScanner.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="FileFinder.h" />
    <ClInclude Include="PeFile.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`VulnerableDriverScanner/ConsoleApplication1.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="VulnerableDriverScanner.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="PeFile.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="FileFinder.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`VulnerableDriverScanner/FileFinder.h`:

```h
#pragma once
#include <iostream>
#include <Windows.h>
#include <string>
#include <vector>
#include <filesystem>


void FindFilesOfType(std::string dir, std::string& extention, std::vector<std::string>* foundFiles)
{
    std::filesystem::directory_iterator directoryIterator (dir);
	for (const auto& dirEntry : directoryIterator)
	{
		if (dirEntry.is_directory())
		{
			FindFilesOfType(dirEntry.path().string(), extention, foundFiles);
		}

		std::string currentExtention = dirEntry.path().extension().string();
		if (!strcmp(currentExtention.c_str(), extention.c_str()))
		{
			foundFiles->push_back(dirEntry.path().string());
		}
	}

}

bool CreateCopy(std::string& path, std::string& newPath)
{
	//open input and output steam
	std::ofstream newFile(newPath, std::ios::binary);
	std::ifstream baseFile(path, std::ios::binary);

	//error checks
	if (!newFile.is_open())
	{
		std::cout << "Could not open newFile stream";
		return false;
	}

	if (!baseFile.is_open())
	{
		std::cout << "Could not open basefile stream";
		return false;
	}

	//get filesize
	baseFile.seekg(0, std::ios::end);
	int fileSize = baseFile.tellg();
	baseFile.seekg(0, std::ios::beg);

	//create buffer for filesize and copy into it
	char* content = new char[fileSize];
	baseFile.read(content, fileSize);
	//copy buffer to new file
	newFile.write(content, fileSize);

	//clean up
	baseFile.close();
	newFile.close();
	delete[] content;
	return true;
}
```

`VulnerableDriverScanner/PeFile.h`:

```h
#pragma once
#include <Windows.h>
#include <iostream>
#include <string>
#include <fstream>

//no clue why dis is not in the normal header
#define IMAGE_FILE_MACHINE_RISCV64 0x5064

class PeFile
{
public:
	//ctors
	PeFile(std::string path);
	~PeFile();

	//functions
	bool HasImport(std::string& importName);
	
	PVOID ntHeaders = nullptr;
	PIMAGE_DOS_HEADER dosHeader = nullptr;

	//variables
	bool isOpen = false;
	bool is64Bit = false;


private:
	uintptr_t fileBuffer = 0;

	bool HasImport32(std::string& importName);
	bool HasImport64(std::string& importName);

	uintptr_t TranslateVa(uintptr_t rva)
	{
		//PIMAGE_NT_HEADERS32 
		PIMAGE_FILE_HEADER fileHeader = &((PIMAGE_NT_HEADERS32)this->ntHeaders)->FileHeader;

		PIMAGE_SECTION_HEADER currentSection = IMAGE_FIRST_SECTION((PIMAGE_NT_HEADERS32)this->ntHeaders);

		for (size_t i = 0; i < ((PIMAGE_NT_HEADERS32)this->ntHeaders)->FileHeader.NumberOfSections; ++i, ++currentSection)
		{
			if (rva >= currentSection->VirtualAddress && rva < currentSection->VirtualAddress + currentSection->Misc.VirtualSize)
			{
				return this->fileBuffer + currentSection->PointerToRawData + (rva - currentSection->VirtualAddress);
			}
		}
		return 0;
	}
};

bool PeFile::HasImport64(std::string& importName)
{
	PIMAGE_NT_HEADERS64 currentNtheaders = (PIMAGE_NT_HEADERS64)this->ntHeaders;

	if (!currentNtheaders)
	{
		printf("[PE] failed to get nt header\n");
		return false;
	}

	PIMAGE_IMPORT_DESCRIPTOR importDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)TranslateVa(currentNtheaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);

	if (!importDescriptor)
	{
		printf("[PE] failed to get import descriptior\n");
		return false;
	}

	for (; importDescriptor->FirstThunk; ++importDescriptor)
	{
		for (PIMAGE_THUNK_DATA thunk = (PIMAGE_THUNK_DATA)TranslateVa(importDescriptor->FirstThunk); thunk->u1.AddressOfData != 0; ++thunk)
		{
			PIMAGE_IMPORT_BY_NAME importByName = (PIMAGE_IMPORT_BY_NAME)TranslateVa(thunk->u1.AddressOfData);
			if (!importByName)
				return false;

			if (!strcmp(importByName->Name, importName.c_str()))
			{
				return true;
			}

		}
	}
	return false;
}


bool PeFile::HasImport32(std::string& importName)
{
	PIMAGE_NT_HEADERS fileHeader = (PIMAGE_NT_HEADERS)this->ntHeaders;
	PIMAGE_IMPORT_DESCRIPTOR importDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)TranslateVa(fileHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);

	if (!importDescriptor)
	{
		printf("[PE] failed to get import descriptior\n");
		return false;
	}

	for (; importDescriptor->FirstThunk; ++importDescriptor)
	{
		for (PIMAGE_THUNK_DATA thunk = (PIMAGE_THUNK_DATA)TranslateVa(importDescriptor->FirstThunk); thunk->u1.AddressOfData; ++thunk)
		{
			PIMAGE_IMPORT_BY_NAME importByName = (PIMAGE_IMPORT_BY_NAME)TranslateVa(thunk->u1.AddressOfData);
			if (!strcmp(importByName->Name, importName.c_str()))
			{
				return true;
			}
		}
	}
}


bool PeFile::HasImport(std::string& importName)
{
	if (this->is64Bit)
	{
		return HasImport64(importName);
	}
	else
	{
		return HasImport32(importName);
	}
}

PeFile::PeFile(std::string path)
{
	std::ifstream inputPeFile(path, std::ios::binary);
	if (!inputPeFile.is_open())
	{
		printf("[PE] failed to open %s\n", path.c_str());
		return;
	}

	inputPeFile.seekg(0, std::ios::end);
	int fileSize = inputPeFile.tellg();
	inputPeFile.seekg(0, std::ios::beg);

	if (!fileSize)
	{
		printf("[PE] following driver has a invalid file size\n");
		printf("%s\n", path.c_str());
		inputPeFile.close();
		return;
	}

	this->fileBuffer = (uintptr_t)VirtualAlloc(NULL, fileSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (!fileBuffer)
	{
		printf("[PE] failed to allocate memory for file buffer %x\n", GetLastError());
		inputPeFile.close();
		return;
	}

	inputPeFile.read((char*)this->fileBuffer, fileSize);
	inputPeFile.close();


	this->dosHeader = (PIMAGE_DOS_HEADER)(this->fileBuffer);
	PIMAGE_NT_HEADERS64 ntHeaders = (PIMAGE_NT_HEADERS64)(this->fileBuffer + this->dosHeader->e_lfanew);

	WORD machineType = ntHeaders->FileHeader.Machine;

	if (machineType == IMAGE_FILE_MACHINE_AMD64 || machineType == IMAGE_FILE_MACHINE_ARM64 || machineType == IMAGE_FILE_MACHINE_RISCV64)
	{
		//image is 64 bit
		this->is64Bit = true;
	}
	
	else if (machineType == IMAGE_FILE_MACHINE_I386)
	{
		//image is 32 bit
		this->is64Bit = false;
	}

	else
	{
		printf("[PE] pe file does not have a valid machine type\n");
		return;
	}

	this->ntHeaders = ntHeaders;
	this->isOpen = true;
}

PeFile::~PeFile()
{
	if (this->isOpen)
	{
		if (!VirtualFree((PVOID)this->fileBuffer, NULL, MEM_RELEASE))
		{
			printf("[PE] failed to free pe file buffer %x\n", GetLastError());
		}
	}
}
```

`VulnerableDriverScanner/VulnerableDriverScanner.cpp`:

```cpp
#include "PeFile.h"
#include "FileFinder.h"

std::vector<std::string> wantedImports = {"IoCreateSymbolicLink", "IoCreateDevice"};

std::vector<std::string> foundDrivers;
std::string extention(".sys");



int main()
{
    std::cout << "Enter scan path:";
    std::filesystem::path scanPath;
    std::cin >> scanPath;

    std::cout << "Enter output path:";
    std::filesystem::path outputPath;
    std::cin >> outputPath;

    //fills foundDrivers with all the paths of .sys files found in the search dir
    FindFilesOfType(scanPath.string(), extention, &foundDrivers);

    for (std::string currDriverPath : foundDrivers)
    {
        PeFile currentPeFile(currDriverPath);
        if (!currentPeFile.isOpen || !currentPeFile.is64Bit)
            continue;
        
        for (std::string wantedImport : wantedImports)
        {
            if (currentPeFile.HasImport(wantedImport))
            { 
                std::filesystem::path driverPath(currDriverPath);
                std::string newPath(outputPath.string() + driverPath.filename().string());
                if (!CreateCopy(currDriverPath, newPath))
                {
                    printf("failed to create copy\n");
                }
                break;
            }
        }
    }

}


```